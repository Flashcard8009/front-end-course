WEBVTT

00:00.940 --> 00:06.340
好 这就看了 咱们利用CommonJets的知识来做一个小的练习

00:06.340 --> 00:09.540
做啥练习呢 就做一个斗地组的洗牌发牌

00:09.540 --> 00:11.340
就做一个洗牌发牌的程序

00:11.340 --> 00:14.140
NodeJets呢 它没有界面

00:14.140 --> 00:17.940
它不像浏览器啊 能够写一个ATM的页面给你渲染出来 对吧

00:17.940 --> 00:21.740
NodeJets没有界面 能够看到的东西呢 就有一个控制台

00:21.740 --> 00:25.340
如果说你要做界面的话 可能要还要借助不少的东西才行

00:25.340 --> 00:28.740
不过呢 我们这门客呢 也不是专门来讲NodeJets的

00:28.740 --> 00:31.740
主要是练习模块化 所以做这么一个小的练习

00:31.740 --> 00:33.140
在控制台上打印出来就行了

00:34.540 --> 00:37.640
我们以后呢 有学了模块化之后呢

00:37.640 --> 00:39.840
我们设计到一个 任何一个问题的时候呢

00:39.840 --> 00:43.940
我们都可以尽量的把它细分为一个一个的模块

00:43.940 --> 00:47.740
每个模块呢 完成那么一点点单独的功能

00:47.740 --> 00:50.540
这样子一来呢 每个模块变得比较简单

00:50.540 --> 00:54.440
它们合起来呢 又可以完成一个功能强大的应用

00:54.440 --> 00:58.240
并且呢 模块你把花分的比较精细的之后呢

00:58.240 --> 01:01.840
它可以让每一个模块呢 可以不断的重复使用

01:01.840 --> 01:04.240
也可以减少代码 减少重复代码

01:04.240 --> 01:08.240
说花分模块呢 是一个非常高深的学问

01:08.240 --> 01:10.440
那么怎么来花分模块呢 这一个东西呢

01:10.440 --> 01:14.040
就需要大家平时多去开发 多去看一些项目

01:14.040 --> 01:16.140
做一些应用 慢慢去体会了

01:16.140 --> 01:18.440
就跟程序思维一样 需要一段时间的积累

01:18.440 --> 01:21.240
慢慢积累起来 也不是那么一时半会

01:21.240 --> 01:24.540
能够积累起来的 我这里呢 给大家把模块呢

01:24.540 --> 01:26.640
应该花分好了 我们直接看

01:27.640 --> 01:29.440
首先呢 有一个工具模块

01:29.440 --> 01:31.140
这个模块呢 因为要洗牌嘛

01:31.140 --> 01:34.840
肯定要在一个 肯定设计到一个数组里面打乱顺序

01:34.840 --> 01:38.240
那么我们这个模块呢 主要是用于将一个数组的

01:38.240 --> 01:41.040
所谓内容打乱 就设计这么一个功能

01:41.040 --> 01:44.540
跟什么铺客牌啊 这些东西 没有任何关系

01:44.540 --> 01:47.940
就是用来打乱的 好 我们在这里呢

01:47.940 --> 01:51.340
新建一个文件 一个模块就是一个文件

01:51.940 --> 01:54.640
我们这里呢 给他取个名字 叫做YouTube

01:54.640 --> 01:57.240
YouTube 工具 这里边有些工具

01:57.240 --> 01:59.940
那么这里边呢 我们要导出一个函数

01:59.940 --> 02:01.140
对吧 要导出一个函数

02:01.140 --> 02:02.540
ok 我们在marge

02:07.640 --> 02:10.040
直接导出一个对象 对象里面呢 包含了一个函数

02:10.040 --> 02:13.140
什么函数呢 函数的名字呢 叫做

02:13.140 --> 02:14.440
该取个名字嘛

02:15.240 --> 02:17.440
sort

02:17.440 --> 02:18.940
rhythm

02:18.940 --> 02:22.540
就是将一个数组里面内容打乱

02:22.540 --> 02:25.040
你给我什么呢 给我一个数组

02:25.040 --> 02:27.340
当然我这种协法呢 是ES6的协法

02:27.340 --> 02:30.040
ES5的协法是这样子

02:30.040 --> 02:31.340
都是一样子

02:31.340 --> 02:33.740
这个函数打个注释 干嘛呢

02:33.740 --> 02:39.840
就是将一个数组的内容打乱

02:39.840 --> 02:41.440
就乱序排序

02:41.640 --> 02:44.840
然后给我传一个数组进来

02:44.840 --> 02:46.240
传递的数组

02:46.240 --> 02:47.140
那怎么打乱呢

02:47.140 --> 02:49.740
我们知道打乱数组其实非常非常简单

02:49.740 --> 02:51.740
你就用sort

02:51.740 --> 02:53.540
数字里面一个方法叫sort

02:53.540 --> 02:56.040
sort里面不是要写函数吗

02:56.040 --> 02:57.940
函数要给我第1个数 给我第2个数

02:57.940 --> 02:59.540
我来比较大小 对不对

02:59.540 --> 03:02.840
我们通常的返回a-b 或者是b-a

03:02.840 --> 03:04.940
如果要打乱的话 直接返回max

03:04.940 --> 03:06.840
第二Rhythm

03:06.840 --> 03:09.240
减去0.5

03:09.340 --> 03:11.240
这个东西其实都是

03:11.240 --> 03:13.740
诚哥的GS基础课程里面都讲过的

03:13.740 --> 03:15.840
我就不再相信说了

03:15.840 --> 03:17.940
好 这样子就可以实现乱序排序了

03:17.940 --> 03:20.740
对吧 咱们来试一下

03:20.740 --> 03:23.940
我们在这里写一个test.gs

03:23.940 --> 03:25.540
这个东西要专门来用来测试

03:25.540 --> 03:27.440
测试这些模块的功能

03:27.440 --> 03:28.440
咱们来试一下

03:28.440 --> 03:29.540
require

03:29.540 --> 03:32.140
导入这个模块

03:32.140 --> 03:34.340
点儿鞋杠 不要忘了写点儿鞋杠

03:34.340 --> 03:36.940
导入这个模块

03:36.940 --> 03:39.140
UTO

03:39.540 --> 03:41.640
然后我们给它一个数组

03:41.640 --> 03:43.540
给它一个数组

03:43.540 --> 03:44.840
ar

03:44.840 --> 03:50.450
随便写一个数组

03:50.450 --> 03:52.950
然后使用UTO里面的一个功能

03:52.950 --> 03:54.650
叫做SourceRhythm

03:54.650 --> 03:56.350
把这个数组给它

03:56.350 --> 03:57.950
然后我们最后输出这个数组

03:57.950 --> 04:00.350
看一下吧

04:01.850 --> 04:03.550
轻轰

04:03.550 --> 04:04.750
load

04:04.750 --> 04:06.550
test

04:06.550 --> 04:08.250
我们要在这里运行的

04:08.250 --> 04:09.750
文件加变了

04:09.850 --> 04:11.350
中间打开

04:11.350 --> 04:14.050
load test

04:14.050 --> 04:15.650
你看一下

04:15.650 --> 04:16.550
是不是打断了

04:16.550 --> 04:18.150
对吧 再来一次

04:18.150 --> 04:19.350
是不是每次都不一样

04:19.350 --> 04:21.750
对吧 随即排序 打断了

04:21.750 --> 04:22.750
那么测试过后

04:22.750 --> 04:24.150
这个模块是不是做好了

04:24.150 --> 04:24.650
对吧

04:24.650 --> 04:25.550
当然我们以后

04:25.550 --> 04:27.350
你在开发一个具体应用的时候

04:27.350 --> 04:28.450
可能一个模块

04:28.450 --> 04:30.250
代码没有那么的简单

04:30.250 --> 04:33.350
但是你把它分成不同的小模块之后

04:33.350 --> 04:34.150
每个模块的代码

04:34.150 --> 04:36.250
它一定不会太贵于负责

04:36.250 --> 04:37.650
好 这个就打乱了

04:37.650 --> 04:38.350
当然这一块

04:38.350 --> 04:41.550
你可以用箭头函数写得更加方便

04:41.550 --> 04:43.450
那么这个模块就做出来了

04:43.450 --> 04:44.650
然后第二个模块

04:44.650 --> 04:47.950
它让你做一个Pook牌的构造函数

04:47.950 --> 04:49.250
就这个模块它要做什么

04:49.250 --> 04:50.850
要导出一个构造函数

04:50.850 --> 04:52.750
当然你学过ES6的话

04:52.750 --> 04:54.150
那么你可以导出一个类

04:54.150 --> 04:56.550
因为类就是一个构造函数的余法堂

04:56.550 --> 04:59.550
我们这里写上一个Pork

04:59.550 --> 05:01.350
Pork 是不是这个意思

05:01.350 --> 05:03.150
是不是单词

05:03.150 --> 05:04.550
管它的Pork

05:04.550 --> 05:06.750
Pork好像是猪肉的意思

05:06.750 --> 05:10.250
我看一下 查一下吧

05:10.250 --> 05:14.950
翻译

05:14.950 --> 05:16.950
看一下吧

05:16.950 --> 05:20.250
Pook牌

05:20.250 --> 05:23.820
Poker

05:23.820 --> 05:27.420
Poker好像真的是猪肉的意思

05:27.420 --> 05:29.520
真的是猪肉

05:29.520 --> 05:31.520
好 这个Poker

05:31.520 --> 05:33.720
那么这个模块里面我们导出一个什么

05:33.720 --> 05:37.120
导出一个就是一个构造函数

05:37.220 --> 05:38.320
或者是一个类

05:38.320 --> 05:40.820
咱们比方写的这么一个构造函数

05:40.820 --> 05:44.220
就一个Poker 构造函数

05:44.220 --> 05:45.920
那么这个构造函数里面

05:45.920 --> 05:47.820
它有哪些属性呢

05:47.820 --> 05:49.320
一个一张Pook牌

05:49.320 --> 05:52.420
一张Pook牌它有花色有排面

05:52.420 --> 05:54.120
对吧 有花色有排面

05:54.120 --> 05:56.820
那么这里我们写上花色是什么

05:56.820 --> 05:59.220
花色什么有传给我 color

05:59.220 --> 06:00.420
还有什么排面是什么

06:00.420 --> 06:03.320
排面是个数字也传给我 color

06:03.320 --> 06:04.920
负责 color

06:04.920 --> 06:07.620
排面 number 负责为 number

06:07.620 --> 06:09.920
咱们把构造函数写好

06:09.920 --> 06:11.520
非常简单一个构造函数

06:11.520 --> 06:14.020
然后这个Pook牌花色是一道四

06:14.020 --> 06:15.020
排面是一道十五

06:15.020 --> 06:17.120
甚至你来这里面可以做一些验证

06:17.120 --> 06:17.420
对吧

06:17.420 --> 06:19.620
我们只能搞定构造函数就行了

06:19.620 --> 06:22.020
然后它里面提供一个方法叫 toStream

06:22.020 --> 06:23.520
于是我们在Poker里面

06:23.520 --> 06:24.820
写上一个在原型上

06:24.820 --> 06:28.020
给它加个方法 toStream

06:28.020 --> 06:28.720
这个方法干嘛呢

06:28.720 --> 06:30.820
它是用来返回一个制服串的

06:30.820 --> 06:32.620
它把我们当前这张Pook牌

06:32.620 --> 06:34.220
它用什么样的制服串来表示

06:34.220 --> 06:35.320
我们把它返回

06:35.320 --> 06:37.120
好 这里我们比方说吧

06:38.720 --> 06:40.020
我们这里如果说

06:40.020 --> 06:41.520
我们先显示花色

06:41.520 --> 06:43.620
先显示一个花色

06:43.620 --> 06:45.320
然后再显示排面

06:45.320 --> 06:46.420
比方说梅花1

06:46.420 --> 06:47.620
我们就显这样的显示

06:50.120 --> 06:52.620
梅花1 我们就这样的显示

06:52.620 --> 06:54.620
梅花1

06:54.620 --> 06:56.120
1的话用A来显示

06:56.120 --> 06:57.920
用J 就是肩 对吧

06:57.920 --> 07:00.620
肩 Ace 用这样来显示

07:00.620 --> 07:03.020
梅花2我们用这种方式来显示

07:03.020 --> 07:04.820
十呢 用这种方式

07:04.820 --> 07:06.820
十一呢 十一就是勾

07:06.820 --> 07:08.320
对吧 用这种方式

07:08.320 --> 07:10.820
十二呢 用框

07:10.820 --> 07:13.020
十三呢 用K

07:13.020 --> 07:14.120
十四是小王

07:14.120 --> 07:16.820
小王的话 我们用九坑

07:16.820 --> 07:18.720
大王呢 我们用大写的九坑

07:18.720 --> 07:20.520
好吧 我们用这种方式来显示

07:20.520 --> 07:23.220
因为控制台也不知道该怎么显示的

07:23.220 --> 07:25.220
也就是说我们最终返回的制服串

07:25.220 --> 07:27.020
要符合这样的标准

07:27.020 --> 07:28.320
好 那么这个函数怎么显

07:28.320 --> 07:29.920
我们首先把花色搞定

07:29.920 --> 07:31.420
花色就是四个数字

07:31.420 --> 07:32.720
一到四 对吧

07:32.720 --> 07:34.620
好 那么我们写上一个制服串

07:34.620 --> 07:36.420
STR

07:36.420 --> 07:37.420
如果判断一下

07:37.420 --> 07:40.620
如果说我们的花色等于一

07:40.620 --> 07:41.620
等于一的话

07:41.620 --> 07:44.620
我们把这个STR给它复制为什么呢

07:44.620 --> 07:49.420
复制为一是啥呀

07:49.420 --> 07:51.820
应该是黑桃债钱 是吧

07:51.820 --> 07:53.720
梅花吧 按照这个顺序来吧

07:53.720 --> 07:56.220
按照这个顺序来

07:56.220 --> 07:58.620
花色

07:58.620 --> 07:59.820
那么如果是梅花的话

07:59.820 --> 08:01.120
我们就这样子写

08:01.220 --> 08:02.420
lcf

08:02.420 --> 08:03.420
this color

08:03.420 --> 08:05.020
如果说等于二

08:05.020 --> 08:06.420
当然也可以用switch结构

08:06.420 --> 08:09.920
都行 开发的方式有很多种

08:09.920 --> 08:11.620
红桃

08:11.620 --> 08:12.620
lcf

08:12.620 --> 08:15.520
如果说color等于三

08:15.520 --> 08:19.620
那么STR等于这个

08:19.620 --> 08:21.120
就生成一个制服串

08:21.120 --> 08:22.620
如果说lcf的话就是四

08:22.620 --> 08:25.620
对吧 四的话我们就用黑桃

08:25.620 --> 08:28.220
OK 花色是不是搞定了

08:28.220 --> 08:29.220
花色搞定之后

08:29.320 --> 08:30.420
后面还是还有什么

08:30.420 --> 08:32.220
还有排面

08:32.220 --> 08:33.520
还要拼接上排面

08:33.520 --> 08:35.520
就第一个花色还要拼接上排面

08:35.520 --> 08:36.620
对吧

08:36.620 --> 08:38.920
排面的话我们怎么来写呢

08:38.920 --> 08:39.920
排面的话

08:39.920 --> 08:43.520
你看如果从二到十的话

08:43.520 --> 08:45.620
就这个排面如果是大于等于二

08:45.620 --> 08:46.520
小于等于十

08:46.520 --> 08:47.620
是不是直接把数字拼上去

08:47.620 --> 08:48.420
完事了

08:48.420 --> 08:49.420
判断一下

08:49.420 --> 08:51.120
如果说那个number

08:51.120 --> 08:52.320
我们的属性

08:52.320 --> 08:53.120
number

08:53.120 --> 08:54.220
如果说number

08:54.220 --> 08:56.820
就大于等于二

08:56.820 --> 08:58.420
并且number

08:58.420 --> 09:00.220
如果说小于等于十

09:00.220 --> 09:02.220
那么是不是直接把排面拼上去

09:02.220 --> 09:03.320
就完事了

09:03.320 --> 09:05.020
拼上个number

09:05.020 --> 09:06.620
对吧 拼上去完事了

09:06.620 --> 09:07.920
好 如果说

09:07.920 --> 09:09.120
尤其这种特殊情况

09:09.120 --> 09:12.220
如果说number等于一

09:12.220 --> 09:13.420
number等于一的话

09:13.420 --> 09:14.420
拼接上什么

09:14.420 --> 09:16.320
拼接上就是A

09:16.320 --> 09:17.420
A

09:17.420 --> 09:19.620
如果说number等于

09:19.620 --> 09:21.320
number等于什么

09:21.320 --> 09:24.920
等于11

09:24.920 --> 09:26.220
判断没

09:26.320 --> 09:27.820
拼接上什么

09:27.820 --> 09:29.320
勾

09:29.320 --> 09:31.020
复制一下吧

09:31.020 --> 09:33.920
12 13 14 15

09:33.920 --> 09:37.520
12 13 14 15

09:37.520 --> 09:39.520
12的话拼接上Q

09:39.520 --> 09:41.020
13的话拼接上K

09:41.020 --> 09:44.620
14的话拼接上小王9克

09:44.620 --> 09:47.320
大王的话大写的9克

09:47.320 --> 09:48.220
完了 对吧 完了

09:48.220 --> 09:50.620
最后我们把字不算返回

09:50.620 --> 09:52.120
那么这样子我们就

09:52.120 --> 09:53.820
做出来这么一个勾招函数

09:53.820 --> 09:54.820
但是你要注意

09:54.920 --> 09:56.420
这个勾招函数其实

09:56.420 --> 09:58.220
它并没有导出

09:58.220 --> 09:59.720
外面的模块是不能使用的

09:59.720 --> 10:00.920
那么我们需要把这个

10:00.920 --> 10:01.820
勾招函数导出

10:01.820 --> 10:02.420
怎么导出呢

10:02.420 --> 10:03.820
我们可以用这种方式

10:03.820 --> 10:06.420
就export

10:06.420 --> 10:07.020
等于什么

10:07.020 --> 10:08.020
poker

10:08.020 --> 10:10.320
把这个勾招函数直接复制给export

10:10.320 --> 10:12.020
那么导出的是不是就是这个玩意

10:12.020 --> 10:13.120
对吧 就是这个玩意

10:13.120 --> 10:15.020
就是这个勾招函数了

10:15.020 --> 10:16.120
没问题吧

10:16.120 --> 10:17.920
OK

10:17.920 --> 10:18.420
当然了

10:18.420 --> 10:19.820
这个邪法又很灵活

10:19.820 --> 10:21.620
完全可以是不是可以这样子写

10:21.620 --> 10:23.220
我们把它写成个利民函数

10:23.220 --> 10:24.520
是不是可以这样子写

10:24.520 --> 10:27.420
然后这边是不是可以这样子写

10:27.420 --> 10:28.720
这下面是不是可以把这个

10:28.720 --> 10:30.020
这个地方改成这个

10:30.020 --> 10:30.820
对吧

10:30.820 --> 10:31.620
完全可以对吧

10:31.620 --> 10:32.720
有什么不可以的

10:32.720 --> 10:33.520
当然都可以写

10:33.520 --> 10:35.020
都可以写

10:35.020 --> 10:37.820
好 这种写法

10:37.820 --> 10:39.820
好 那么这两个模块是不是做完了

10:39.820 --> 10:40.820
对吧 就做完了

10:40.820 --> 10:41.820
好 我们来测试一下

10:41.820 --> 10:43.120
测试一下这个poker牌的

10:43.120 --> 10:45.620
这么一个东西

10:45.620 --> 10:46.420
测试一下

10:46.420 --> 10:49.920
然后我们来测试一下poker

10:49.920 --> 10:51.820
当然这个名字随便秘

10:51.820 --> 10:53.120
因为我们的名字

10:53.120 --> 10:55.520
是在导入模块的时候才确定的

10:55.520 --> 10:57.220
它用什么名字才确定的

10:57.220 --> 10:59.020
不是说你这里导出用的是什么名字

10:59.020 --> 11:00.220
我就必须要用什么名字

11:00.220 --> 11:02.320
导出是这个玩意

11:02.320 --> 11:04.320
它会把这个玩意返回

11:04.320 --> 11:05.720
它是一个含书的返回值

11:05.720 --> 11:07.020
你按用什么样的接收

11:07.020 --> 11:08.120
按用什么东西接收

11:08.120 --> 11:09.120
就用什么东西接收

11:09.120 --> 11:09.620
对吧

11:09.620 --> 11:10.720
这个无所谓的

11:10.720 --> 11:12.420
只不过我们习惯上的一般是

11:12.420 --> 11:14.420
把它作为这个模块名

11:14.420 --> 11:15.420
那么这里呢

11:15.420 --> 11:19.620
requirepoker

11:19.620 --> 11:20.220
好了

11:20.220 --> 11:21.520
那么我们再试一下

11:21.520 --> 11:24.220
我们建立一个poker牌

11:24.220 --> 11:26.120
因为它导出的就是个构造含书

11:26.120 --> 11:26.520
对吧

11:26.520 --> 11:27.120
你看这边

11:27.120 --> 11:28.820
导出的就是个构造含书

11:28.820 --> 11:30.120
那么这边就当作构造含书

11:30.120 --> 11:31.320
使用完事了

11:31.320 --> 11:32.920
比方说1

11:32.920 --> 11:33.720
1

11:33.720 --> 11:34.720
两个都是1

11:34.720 --> 11:35.520
花色为1

11:35.520 --> 11:36.420
排面为1

11:36.420 --> 11:38.720
那么我们输出一下

11:38.720 --> 11:40.020
输出一下p点

11:40.020 --> 11:41.420
toolstream

11:41.420 --> 11:42.520
把转换的置物串

11:42.520 --> 11:44.220
因为它不是一个toolstream方法吗

11:44.220 --> 11:44.920
有个含书

11:44.920 --> 11:45.720
返回一个置物串

11:45.720 --> 11:46.920
把个置物串输出

11:46.920 --> 11:48.520
好 来试一下

11:48.520 --> 11:49.020
clear

11:49.020 --> 11:51.820
清空一下那个控制台

11:51.820 --> 11:53.920
load test

11:53.920 --> 11:55.520
你看是没画A

11:55.520 --> 11:55.820
对吧

11:55.820 --> 11:57.120
输出没画A了

11:57.120 --> 11:57.920
再来

11:57.920 --> 12:02.130
如果说这里是11

12:02.130 --> 12:03.330
是没画解

12:03.330 --> 12:03.930
对吧

12:03.930 --> 12:07.220
这里是4

12:07.220 --> 12:08.220
是黑桃解

12:08.220 --> 12:08.420
对吧

12:08.420 --> 12:09.920
就是就搞定了

12:09.920 --> 12:10.120
好了

12:10.120 --> 12:11.220
这些东西搞定了之后

12:11.220 --> 12:14.120
我们最后来完成一个入口文件

12:14.120 --> 12:14.920
入口文件

12:14.920 --> 12:16.720
就是我们要创建54张poker牌

12:16.720 --> 12:17.220
要洗牌

12:17.220 --> 12:18.120
要发牌

12:18.120 --> 12:20.620
一看有了这些模块帮助之后

12:20.720 --> 12:23.320
很多代码我们就可以不用写了

12:23.320 --> 12:24.720
因为它功能已经齐全了

12:24.720 --> 12:26.520
我们只需要拿出来用就行了

12:26.520 --> 12:27.820
比方说我们这里写个入口文件

12:27.820 --> 12:29.320
因这个事点解释

12:29.320 --> 12:30.520
来吧

12:30.520 --> 12:32.520
关闭其他

12:32.520 --> 12:34.720
首先我们要创建54张poker牌

12:34.720 --> 12:36.520
是不是要得一个数组

12:36.520 --> 12:37.620
是不是得一个数组

12:37.620 --> 12:38.720
poker

12:38.720 --> 12:39.020
对吧

12:39.020 --> 12:40.620
一个数组

12:40.620 --> 12:42.120
poker牌的数组

12:42.120 --> 12:44.120
poker牌的数组

12:44.120 --> 12:46.220
数组里面要加54张poker牌

12:46.220 --> 12:48.620
每加一张是不是一个poker牌对象

12:48.620 --> 12:48.920
对吧

12:48.920 --> 12:50.920
每一个poker牌是不是个对象

12:50.920 --> 12:51.720
那么来吧

12:51.720 --> 12:54.520
我们是不是要把个poker牌的构造函数导入进来

12:54.520 --> 12:54.720
对啊

12:54.720 --> 12:55.220
require

12:59.320 --> 13:00.120
poker

13:00.120 --> 13:05.320
这是导入poker牌的构造函数

13:05.320 --> 13:06.120
导入进来

13:06.120 --> 13:07.620
然后有54张poker牌

13:07.620 --> 13:09.520
那么我们每张poker牌

13:09.520 --> 13:11.120
除了大小王之外

13:11.120 --> 13:13.220
每张poker牌是不是有四种发射

13:13.220 --> 13:13.520
对吧

13:13.520 --> 13:14.420
有四种发射

13:14.420 --> 13:15.420
那么除了大小王

13:15.420 --> 13:16.320
大小王之外

13:16.320 --> 13:18.620
是不是52张

13:18.720 --> 13:19.820
poker牌的发射一个

13:19.820 --> 13:21.120
应该是1到13

13:21.120 --> 13:21.720
来吧

13:21.720 --> 13:22.820
循环一次

13:22.820 --> 13:23.920
循环一次

13:23.920 --> 13:25.120
i等于一开始

13:25.120 --> 13:27.020
i小于等于13

13:27.020 --> 13:27.620
对吧

13:27.620 --> 13:28.420
1到k嘛

13:28.420 --> 13:29.320
对不对

13:29.320 --> 13:30.020
排面

13:30.020 --> 13:31.420
循环排面

13:31.420 --> 13:32.220
循环排面

13:32.220 --> 13:33.420
循环完了过后呢

13:33.420 --> 13:34.720
又循环什么了

13:34.720 --> 13:35.520
循环发射

13:36.920 --> 13:38.520
发射不是有四种吗

13:38.520 --> 13:38.820
对不对

13:38.820 --> 13:40.220
小于等于4

13:40.220 --> 13:40.820
接下来

13:42.620 --> 13:43.820
i是排面

13:43.820 --> 13:44.220
排面

13:44.220 --> 13:45.720
这是循环

13:45.720 --> 13:47.220
排面

13:47.220 --> 13:49.220
这是循环

13:50.520 --> 13:52.520
循环发射

13:52.520 --> 13:52.820
好

13:52.820 --> 13:54.220
那么每一次循环

13:54.220 --> 13:56.120
是不是往这个数组里面加一张

13:56.120 --> 13:56.420
对吧

13:56.420 --> 13:58.220
往数组里面加一张poker牌

13:58.220 --> 13:59.420
那么这个poker牌来自于哪呢

13:59.420 --> 14:00.920
是创是通过这个构造

14:00.920 --> 14:02.420
函数创建的对象

14:02.420 --> 14:03.820
每一张poker牌就是个对象

14:03.820 --> 14:05.420
六一个poker

14:05.420 --> 14:05.620
好

14:05.620 --> 14:06.720
poker里面要告诉你

14:06.720 --> 14:07.620
要传一个发射

14:07.620 --> 14:09.220
发射是怎么接

14:09.220 --> 14:09.920
排面呢

14:09.920 --> 14:10.320
哎

14:10.320 --> 14:10.820
对吧

14:10.820 --> 14:11.820
传进去完事了

14:11.820 --> 14:13.520
这样子是不是加了多少张呢

14:13.520 --> 14:14.420
四三十一十

14:14.420 --> 14:14.920
52张

14:14.920 --> 14:15.220
对吧

14:15.220 --> 14:16.220
52张poker牌

14:16.220 --> 14:17.320
还差一个大小王

14:17.320 --> 14:20.020
那么我们单独加poker是poker

14:20.020 --> 14:21.220
六一个poker

14:21.220 --> 14:21.920
大小王

14:21.920 --> 14:23.320
大王发射呢

14:23.320 --> 14:25.620
大王的发射好像是没有的

14:25.620 --> 14:26.320
没有

14:26.320 --> 14:27.720
没有我们用个附一吗

14:27.720 --> 14:29.220
用个附一

14:29.220 --> 14:29.820
对

14:29.820 --> 14:30.820
这里还有一个情况

14:30.820 --> 14:31.720
还有一种情况

14:31.720 --> 14:32.520
我当时没有考虑

14:32.520 --> 14:34.220
就是大小王的情况

14:34.220 --> 14:34.920
大小王的情况

14:34.920 --> 14:36.220
大小王的情况是没有发射的

14:36.220 --> 14:36.820
对吧

14:36.820 --> 14:37.620
大小王的情况呢

14:37.620 --> 14:39.120
我们就这里不用拼接了

14:39.120 --> 14:40.820
直接复制就完事了

14:40.820 --> 14:41.820
就不用拼接了

14:41.820 --> 14:44.220
把前面的干覆盖掉

14:44.220 --> 14:45.520
那么大小王是没有发射的

14:45.520 --> 14:46.020
没有发射的

14:46.020 --> 14:47.520
我们给他传个NT犯都行

14:47.520 --> 14:48.620
都行

14:48.620 --> 14:49.820
那么没有发射的话

14:49.820 --> 14:51.820
我们用NOW

14:51.820 --> 14:53.020
NUMBER的14

14:53.020 --> 14:54.920
表示大王

14:54.920 --> 14:57.520
再来一个小王

14:57.520 --> 14:59.020
那15

14:59.020 --> 14:59.820
加两个

14:59.820 --> 15:01.620
加两个到宿主里面去

15:01.620 --> 15:02.320
对吧

15:02.320 --> 15:03.120
没问题吧

15:03.120 --> 15:04.520
那么咱们试一下

15:04.520 --> 15:06.620
把宿主里面的东西全部打印出来

15:06.620 --> 15:07.720
试一下

15:07.720 --> 15:09.320
i等于0

15:09.320 --> 15:10.520
当你学过es6的话

15:10.520 --> 15:13.920
你完全可以用425循环之类的

15:13.920 --> 15:18.320
Pocus Lens i++

15:18.320 --> 15:21.520
那么拿到每一张覆盖牌

15:21.520 --> 15:23.220
Pocus i

15:23.220 --> 15:24.720
然后把它打印出来

15:24.720 --> 15:27.520
输出p.txt

15:27.520 --> 15:28.720
打印出来

15:28.720 --> 15:33.670
好 试一下

15:33.670 --> 15:34.870
这里不是运行test

15:34.870 --> 15:36.870
运行入口函数 index

15:36.870 --> 15:37.970
你看

15:37.970 --> 15:38.670
说打印出来了

15:38.670 --> 15:40.070
每一张覆盖牌就打印出来了

15:40.070 --> 15:40.870
对吧

15:40.870 --> 15:41.870
从a开始

15:41.870 --> 15:44.170
那么现在的牌是满足一定顺序的

15:44.170 --> 15:45.470
看是不是洗好的牌

15:45.570 --> 15:47.670
刚刚一个一副新牌满足一定顺序

15:47.670 --> 15:49.270
那么现在把它打乱

15:49.270 --> 15:50.770
怎么打乱呢

15:50.770 --> 15:51.770
怎么打乱呢

15:51.770 --> 15:55.060
打乱铺盖牌

15:55.060 --> 15:56.760
打乱铺盖牌是不是要用到我们的

15:56.760 --> 15:58.960
之前那个函数工具函数

15:58.960 --> 15:59.860
导出了一个什么呢

15:59.860 --> 16:00.860
sort

16:00.860 --> 16:01.460
rhythm

16:01.460 --> 16:02.060
对吧

16:02.060 --> 16:02.560
OK

16:02.560 --> 16:04.260
我们来UTO导入

16:06.660 --> 16:08.560
那么导入到底是一个函数

16:08.560 --> 16:09.460
还是一个对象呢

16:09.460 --> 16:10.460
关键看这个模块

16:10.460 --> 16:11.660
导出的到底是它

16:11.660 --> 16:12.560
它导出的是什么

16:12.560 --> 16:13.660
导出的是个对象

16:13.660 --> 16:13.860
对吧

16:13.860 --> 16:14.760
导出的是个对象

16:14.760 --> 16:15.360
所以说

16:15.360 --> 16:17.560
这个这里接受的东西也是个对象

16:17.560 --> 16:19.360
那么对象里面提供了一个方法

16:19.360 --> 16:20.260
叫做sort

16:20.260 --> 16:20.960
rhythm

16:20.960 --> 16:22.060
你给它一个数组

16:22.060 --> 16:24.360
它会把个数组里面的顺序打乱

16:24.360 --> 16:25.260
好打乱之后呢

16:25.260 --> 16:27.960
我们再来再来输出这个输出里边的东西

16:27.960 --> 16:28.760
再输出

16:28.760 --> 16:32.260
我们用for循环也可以

16:32.260 --> 16:33.160
输出你们懂的

16:33.160 --> 16:34.360
也有for2不循环也可以

16:34.360 --> 16:35.760
比方说用for2不循环

16:38.460 --> 16:40.360
好输出p点

16:40.360 --> 16:42.360
当然这是es6的东西

16:42.360 --> 16:43.460
没看过es6的东西

16:43.460 --> 16:45.760
对象俩赶快把看es6很重要

16:46.960 --> 16:48.560
好你看是不是打乱了

16:48.560 --> 16:49.460
相当于是洗牌了

16:49.460 --> 16:50.160
对吧

16:50.160 --> 16:51.560
就打乱了

16:51.560 --> 16:53.160
整个过程打乱了

16:53.160 --> 16:55.560
好那么这里就是打乱铺个牌

16:55.560 --> 16:56.660
打乱铺个牌之后呢

16:56.660 --> 16:57.760
我们要发牌

16:57.760 --> 17:00.360
斗地主是一人发多少张

17:00.360 --> 17:00.860
发多少张

17:00.860 --> 17:02.660
是不是发17张

17:02.660 --> 17:03.660
对不对

17:03.660 --> 17:05.160
斗地主是不是一人发17张

17:05.160 --> 17:06.960
打乱过后就这样呗

17:06.960 --> 17:08.060
player1

17:08.060 --> 17:09.560
玩家1

17:09.560 --> 17:12.160
从铺客牌里边snaps对吧

17:12.260 --> 17:13.260
结取对不对

17:13.260 --> 17:15.160
结取结就怎么了

17:15.160 --> 17:17.660
开始0

17:17.660 --> 17:18.660
然后呢

17:18.660 --> 17:19.660
end

17:19.660 --> 17:20.860
是不是17

17:20.860 --> 17:21.160
对吧

17:21.160 --> 17:22.960
0到16是不是就17张

17:22.960 --> 17:23.360
对不对

17:23.360 --> 17:23.960
0到16

17:23.960 --> 17:25.460
因为他取不到最后的字吗

17:25.460 --> 17:26.560
17张

17:26.560 --> 17:26.760
好

17:26.760 --> 17:27.160
然后呢

17:27.160 --> 17:28.560
player2

17:28.560 --> 17:31.160
第二个玩家snaps

17:31.160 --> 17:32.660
0到多少张了

17:32.660 --> 17:33.660
0到

17:33.660 --> 17:35.260
就是17到多少张了

17:35.260 --> 17:37.560
17加上17

17:37.560 --> 17:38.760
17加17多少

17:38.760 --> 17:40.160
34

17:40.160 --> 17:41.960
对吧

17:41.960 --> 17:42.460
然后呢

17:42.460 --> 17:43.560
第三个玩家

17:43.560 --> 17:44.560
player3

17:44.560 --> 17:45.560
pocus

17:45.560 --> 17:46.960
snaps

17:46.960 --> 17:47.960
34到多少

17:47.960 --> 17:49.460
34到51

17:49.460 --> 17:50.460
对吧

17:50.460 --> 17:51.160
好

17:51.160 --> 17:52.560
那么桌面上

17:52.560 --> 17:53.960
desk

17:53.960 --> 17:55.560
桌面上是不是还剩3张

17:55.560 --> 17:56.660
对不对

17:56.660 --> 17:58.060
snaps

17:58.060 --> 17:59.660
51到结束

17:59.660 --> 18:01.960
51 52

18:01.960 --> 18:02.960
看一下啊

18:02.960 --> 18:03.860
写对不对

18:03.860 --> 18:04.360
17

18:04.360 --> 18:05.060
0到16

18:05.060 --> 18:05.960
17张嘛

18:05.960 --> 18:07.360
17到34

18:07.360 --> 18:08.360
17张

18:08.360 --> 18:09.360
17张

18:09.360 --> 18:11.560
呃

18:11.560 --> 18:12.460
然后呢

18:12.460 --> 18:14.960
34到51

18:14.960 --> 18:16.060
17张

18:16.060 --> 18:17.360
然后从51开始

18:17.360 --> 18:18.860
51 52 53

18:18.860 --> 18:19.360
54

18:19.360 --> 18:19.560
哎

18:19.560 --> 18:21.760
为什么还剩4张啊

18:21.760 --> 18:24.760
怎么算的呢

18:24.760 --> 18:25.260
怎么算的

18:25.260 --> 18:26.960
我想想啊

18:26.960 --> 18:28.060
怎么

18:28.060 --> 18:30.060
我这里也还蒙住了呢

18:30.060 --> 18:30.260
哦

18:30.260 --> 18:30.860
对了啊

18:30.860 --> 18:32.560
下表他最高到53

18:32.560 --> 18:33.460
不可能到54的

18:33.460 --> 18:33.860
对了的啊

18:33.860 --> 18:34.460
对了的

18:34.460 --> 18:35.560
桌面上剩3张

18:35.560 --> 18:35.960
对吧

18:35.960 --> 18:37.160
那么一次打印出来啊

18:37.160 --> 18:38.260
一次打印出来

18:38.260 --> 18:39.460
比方说我们一次打印

18:39.460 --> 18:41.160
玩家1

18:41.160 --> 18:43.060
玩家1的话

18:43.060 --> 18:44.560
我们把这些铺盖牌里边的内容

18:44.560 --> 18:45.560
全部拼接起来嘛

18:45.560 --> 18:46.160
啊

18:46.160 --> 18:47.360
定一个变量str

18:47.360 --> 18:48.460
啊

18:48.460 --> 18:50.260
定个变量拼接起来

18:50.260 --> 18:50.660
好

18:50.660 --> 18:50.960
来吧

18:50.960 --> 18:51.460
循环

18:53.360 --> 18:54.560
i等于0

18:54.560 --> 18:56.160
i小于player1

18:56.160 --> 18:57.260
dirnance

18:57.260 --> 18:58.760
i加加

18:58.760 --> 18:59.260
i加加

19:03.900 --> 19:04.400
好

19:04.400 --> 19:04.900
呃

19:04.900 --> 19:05.600
然后呢

19:05.600 --> 19:07.200
我们这里呢

19:07.200 --> 19:08.800
我看一下啊

19:08.800 --> 19:09.200
嗯

19:09.200 --> 19:10.600
这里每一次循环

19:10.600 --> 19:11.600
拿到一个玩家

19:11.600 --> 19:13.200
拿到拿到一张铺盖牌

19:13.200 --> 19:14.100
player1

19:14.100 --> 19:14.400
i

19:15.800 --> 19:16.100
好

19:16.100 --> 19:16.700
然后呢

19:16.700 --> 19:18.500
把这个铺盖牌的制服串呢

19:18.500 --> 19:21.100
拼接到这个制服串里边去啊

19:21.100 --> 19:22.700
拼接到这个制服串里边去

19:22.700 --> 19:23.400
拼接进去

19:23.400 --> 19:24.500
p

19:24.500 --> 19:26.000
然后再拼接一个

19:26.000 --> 19:27.300
拼接一个空格嘛

19:27.300 --> 19:27.700
两个

19:27.700 --> 19:28.800
三个空格

19:28.800 --> 19:30.300
拼接上三个空格

19:30.300 --> 19:31.100
没问题吧

19:31.100 --> 19:32.300
每一次把这个牌面啊

19:32.300 --> 19:33.500
把这个牌的

19:33.500 --> 19:34.100
哦

19:34.100 --> 19:35.700
还有一个touching

19:35.700 --> 19:37.000
调一个touching方法

19:37.000 --> 19:37.700
把这个铺牌

19:37.700 --> 19:39.400
调那个铺牌的touching方法

19:39.400 --> 19:40.300
得到个制服串

19:40.300 --> 19:40.900
把这个制服串呢

19:40.900 --> 19:42.100
用个空格隔一下啊

19:42.100 --> 19:42.600
隔一下

19:42.600 --> 19:44.000
那么拼接完了这个stune

19:44.000 --> 19:45.400
这个这个制服串

19:45.400 --> 19:47.400
是不是就我们的玩家一的结果

19:47.400 --> 19:47.500
好

19:47.500 --> 19:49.300
那么咱们来试一下啊

19:49.300 --> 19:50.700
可以清空

19:50.700 --> 19:51.900
漏的音这个是

19:52.800 --> 19:53.600
你看玩家一

19:53.600 --> 19:55.200
是不是打印出来了

19:55.200 --> 19:55.300
好

19:55.300 --> 19:56.100
那么同样的道理

19:56.100 --> 19:57.600
玩家二玩家三玩家四

19:57.600 --> 19:59.400
什么都可以用类似的方式在打一

19:59.400 --> 19:59.800
对吧

19:59.800 --> 20:00.600
类似的方式打印

20:00.600 --> 20:01.700
那么我们可以看到

20:01.700 --> 20:03.900
这一块东西是不是又有重复代码

20:03.900 --> 20:05.200
打印一个数组

20:05.200 --> 20:06.100
一个铺盖牌的数组

20:06.100 --> 20:07.500
是不是又有重复代码

20:07.500 --> 20:07.800
哎

20:07.800 --> 20:08.800
那么这个重复代码呢

20:08.800 --> 20:09.800
我们是不是可以

20:09.800 --> 20:10.700
写到哪呢

20:10.700 --> 20:12.000
写到铺盖牌里面也可以

20:12.000 --> 20:13.800
写到这个uq里面也可以啊

20:13.800 --> 20:15.000
比方我们在uq里面

20:15.000 --> 20:16.600
写再加上一个嘛print

20:17.800 --> 20:18.700
打印

20:18.700 --> 20:20.200
你给我一个铺盖牌的数组

20:21.700 --> 20:22.600
pokers

20:22.600 --> 20:23.700
给我一个铺盖牌的数组

20:23.700 --> 20:25.800
那么我就可以把它打印出来啊

20:26.900 --> 20:30.200
打印一个铺盖牌的数组

20:30.200 --> 20:31.200
好怎么打印呢

20:31.200 --> 20:32.400
我们把个代码复制一下

20:33.500 --> 20:35.200
把这个代码复制一下

20:36.000 --> 20:36.600
好是吧

20:36.600 --> 20:37.400
把写成模块

20:37.400 --> 20:38.400
那么就可以重用了

20:38.400 --> 20:38.700
对吧

20:38.700 --> 20:39.600
就可以重用了

20:39.600 --> 20:41.100
这些东西都可以灵活处理

20:41.100 --> 20:42.800
那么玩家一怎么来了

20:42.800 --> 20:44.200
就是uq

20:44.800 --> 20:46.400
模块里面多了一个方法了print

20:46.900 --> 20:47.500
print

20:47.500 --> 20:49.100
把玩家一传进去

20:49.700 --> 20:50.900
player一对吧

20:50.900 --> 20:51.900
玩家一传进去

20:51.900 --> 20:53.100
那么玩家二呢

20:53.100 --> 20:53.700
一次来

20:56.600 --> 20:57.300
复制啊

20:57.700 --> 20:59.100
玩家二玩家三

20:59.500 --> 21:00.200
玩家二

21:00.600 --> 21:01.400
玩家三

21:01.400 --> 21:02.200
玩家二

21:02.200 --> 21:03.000
玩家三

21:03.000 --> 21:03.900
然后了桌面

21:06.140 --> 21:06.840
桌面

21:07.240 --> 21:08.740
桌面是什么desk

21:08.740 --> 21:10.240
这些都是铺牌的数组

21:10.240 --> 21:10.540
对吧

21:11.540 --> 21:12.240
来看一下

21:13.740 --> 21:14.240
来

21:14.840 --> 21:15.340
哦这边

21:15.340 --> 21:15.940
哦这边

21:17.140 --> 21:17.640
这边

21:17.640 --> 21:17.940
哎

21:17.940 --> 21:18.440
这边

21:19.140 --> 21:19.540
这边呢

21:19.540 --> 21:21.040
我们不能用player一

21:21.040 --> 21:22.040
有一个参数

21:22.240 --> 21:23.440
pocus

21:25.240 --> 21:25.640
好了

21:26.040 --> 21:26.540
看一下吧

21:28.240 --> 21:28.640
你看

21:28.640 --> 21:29.740
这样是不是打印出来了

21:29.840 --> 21:31.840
桌面玩家一玩家二玩家三

21:32.840 --> 21:33.540
非常简单

21:33.540 --> 21:34.340
就这么一回事

21:35.740 --> 21:35.940
好

21:35.940 --> 21:36.940
这就是关于这一款

21:36.940 --> 21:37.340
当然呢

21:37.340 --> 21:38.340
你还可以进行

21:38.340 --> 21:40.540
对每一个玩家的手牌来进行排序

21:40.540 --> 21:41.940
也可以在这里边写个函数啊

21:41.940 --> 21:43.140
对一个数组里边的东西

21:43.140 --> 21:44.840
对铺牌进行排序都可以

21:45.540 --> 21:46.740
我们通过这个例子呢

21:46.740 --> 21:48.940
终点不是说我要讲什么铺牌

21:48.940 --> 21:50.240
这个东西无所谓的

21:50.240 --> 21:51.340
用啥例子都行

21:51.540 --> 21:52.740
主要是通过这个例子呢

21:52.740 --> 21:55.040
我告诉大家的就是磨块化

21:55.240 --> 21:56.940
让大家体会到磨块化的好处

21:57.240 --> 21:58.040
就是磨块化了

21:58.040 --> 21:58.840
可以把这些功能呢

21:58.840 --> 22:00.640
把一些复杂的功能进行细分

22:00.640 --> 22:02.040
细分到每一个磨块

22:02.240 --> 22:02.740
第一个呢

22:02.740 --> 22:03.940
是减少复杂度

22:04.340 --> 22:04.640
第二个呢

22:04.640 --> 22:07.140
我们可以重用这某一个部分的功能

22:07.140 --> 22:08.240
比方说这个铺牌

22:08.340 --> 22:09.640
那不一定是斗地主啊

22:09.840 --> 22:11.140
一块是别的什么玩意

22:11.140 --> 22:12.040
那么只要用到铺牌

22:12.040 --> 22:12.940
是不是都可以用这个

22:13.240 --> 22:14.540
都可以用这个就是人类

22:14.540 --> 22:16.340
都可以用这个构造函数

22:16.440 --> 22:17.440
那比方说这个磨块

22:17.440 --> 22:20.340
这个磨块里面提供了一个乱序排序的方式

22:20.340 --> 22:21.640
那么不管是铺牌也好

22:21.640 --> 22:23.840
还是以后什么数字数组也好

22:23.840 --> 22:25.040
是不是都可以用这个磨块

22:25.040 --> 22:25.540
对吧

22:25.940 --> 22:26.540
而且呢

22:26.540 --> 22:27.040
将来呢

22:27.040 --> 22:28.540
我们学了一些什么

22:29.440 --> 22:31.840
保管力器工具之后呢

22:31.840 --> 22:33.540
比方说用学了NPM之后呢

22:33.640 --> 22:36.240
你还可以把你自己的磨块做成一个通用磨块

22:36.240 --> 22:38.240
在不同的项目里边都可以反复使用

22:39.040 --> 22:39.440
以后呢

22:39.440 --> 22:40.640
我们可以看到很多

22:40.640 --> 22:42.340
已经有很多的通用磨块了

22:42.340 --> 22:43.340
网上啊

22:43.340 --> 22:45.440
已经有几百万几千万个了

22:46.140 --> 22:47.940
都可以拿来拿过来直接使用

22:48.840 --> 22:49.040
好

22:49.040 --> 22:50.540
这就是磨块化啊

22:50.540 --> 22:51.740
在loader.js里边

22:51.740 --> 22:52.740
它的使用方式

22:52.740 --> 22:54.240
common.js它的规范

22:54.840 --> 22:56.140
把这个都把练习啊

22:56.140 --> 22:56.840
下来做一下啊

22:56.840 --> 22:58.540
体会一下common.js

22:58.640 --> 22:59.940
那么common.js呢

22:59.940 --> 23:00.740
就倒是结束了

23:00.740 --> 23:02.340
我们磨块化的课程呢

23:02.340 --> 23:03.440
是非常简单的

23:04.540 --> 23:06.040
common.js在loader.js上

23:06.040 --> 23:07.440
是用了非常成功的

23:07.540 --> 23:08.240
但是呢

23:08.240 --> 23:08.840
后来呢

23:08.840 --> 23:10.440
用到了一个扭烂期段的时候呢

23:10.440 --> 23:12.440
发现了一些问题不好解决

23:12.840 --> 23:13.440
于是呢

23:13.440 --> 23:16.640
就设计到我们后边要讲的AMD和CMD

23:16.940 --> 23:17.440
好了

23:17.440 --> 23:18.640
咱们下一张再见

