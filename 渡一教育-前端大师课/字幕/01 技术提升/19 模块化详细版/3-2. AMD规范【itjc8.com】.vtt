WEBVTT

00:00.880 --> 00:07.780
好 接下来我们这一张节后边的就是讲解具体的AMD和CM的规范

00:07.780 --> 00:12.780
这两个规范跟我之前说的就没有那么的重要了

00:12.780 --> 00:16.380
不过大家听一听也非常简单 聊一聊就行了

00:16.380 --> 00:18.880
了解一下我们前端过去的一些历史

00:18.880 --> 00:22.880
因为这两个东西现在已经被ES6模块化规范所取代了

00:22.880 --> 00:27.880
像在github上面我刚刚看了一下AMD规范和CM的规范

00:27.880 --> 00:33.880
他们的相应的实现代码都已经很久没更新了 了解一下吧 了解一下

00:33.880 --> 00:39.880
首先我们看一下AMD规范 它的全称叫做blah blah blah blah blah blah blah

00:39.880 --> 00:45.880
这个全称的第一个单词 如果你学过ES6的话 叫做synchronous

00:45.880 --> 00:49.880
叫做异部的 对吧 模块化定义 异部模块定义

00:49.880 --> 00:53.880
那么为什么叫异部的呢 通过上节后的学习你应该明白了

00:53.880 --> 00:56.880
因为我们远程夹载的话 为了避免组设

00:56.880 --> 00:59.880
把它做成异部是最好的 使用回调函数的方式

00:59.880 --> 01:03.880
夹载完了过后 你再去运行它 这样子是最好的

01:03.880 --> 01:08.880
它的实现失怒的跟我们上节课讲的东西就差不多了

01:08.880 --> 01:13.880
第一个它是要异部夹载 异部夹载远程文件去读取过来

01:13.880 --> 01:18.880
第二步就是把我们的代码用手动的方式写到一个函数里边

01:19.880 --> 01:26.880
具体的做法它是这样子 在我们导入和导出模块的时候

01:26.880 --> 01:31.880
你都必须要把导入和导出模块的代码放到一个define函数里边

01:31.880 --> 01:35.880
避免拳击污染 并且同时可以实现异部

01:35.880 --> 01:41.880
它只是一个规范而已 那么这个规范要实现的必须要有一个GS来实现

01:41.880 --> 01:46.880
实现的GS叫做required的GS 就这个GS实现了AMD规范

01:46.880 --> 01:50.880
这就可能我们就简单的认识一下 不会讲得那么细

01:50.880 --> 01:52.880
因为这个东西现在确实不怎么用了

01:52.880 --> 01:54.880
required.GS它实现了AMD规范

01:54.880 --> 01:59.880
required.GS我已经跟大家下载下载了 在这

01:59.880 --> 02:01.880
其实代码也没有多少

02:01.880 --> 02:05.880
我记得它最初的代码可能只有几十行 代码就解决了

02:05.880 --> 02:12.880
后来为了增强它的功能 为了适配一些奇奇怪怪的输选模式

02:12.880 --> 02:14.880
它又增加了不少的代码 不管它

02:14.880 --> 02:17.880
我们一会儿就简单认识一下 认识一下它就行了

02:17.880 --> 02:19.880
好 那么它怎么用呢

02:19.880 --> 02:22.880
我们来举个例子 比方说我们这里一张图

02:22.880 --> 02:25.880
我要实现这么一个效果 这是入口文件

02:25.880 --> 02:27.880
这个入口文件依赖两个文件

02:27.880 --> 02:29.880
adder.GS和b.GS

02:29.880 --> 02:32.880
而这个adder.GS依赖另外一个文件也是b.GS

02:32.880 --> 02:35.880
比方说要形成这么一种依赖关系

02:35.880 --> 02:38.880
如果说我们用common.GS大家都知道该怎么去写

02:38.880 --> 02:41.880
那如果说我们用AMD规范呢 该怎么写呢

02:41.880 --> 02:43.880
好 接下来我们给它写一次

02:43.880 --> 02:46.880
首先我要写这页面 因为我们在浏览器里边执行

02:46.880 --> 02:49.880
肯定要从页面里边执行 这毫无疑问的

02:49.880 --> 02:51.880
这不是node的环境了

02:51.880 --> 02:53.880
页面里边去引用啥呢

02:53.880 --> 02:56.880
去引用我们的require.GS

02:56.880 --> 02:59.880
把引用起来就行了

02:59.880 --> 03:01.880
为了就是因为模块的话

03:01.880 --> 03:03.880
它解决的就是复杂的依赖关系 对吧

03:03.880 --> 03:06.880
所以说我们只需要给它一个入口文件就行了

03:06.880 --> 03:08.880
那么怎么来给它一个入口文件呢

03:08.880 --> 03:09.880
是这样给的

03:09.880 --> 03:11.880
你在这个元素里面呢

03:11.880 --> 03:14.880
写上这么一个自定义属性 叫做data.me

03:14.880 --> 03:17.880
表示的是入口文件 也叫做启动文件

03:17.880 --> 03:19.880
如果说你学习了

03:19.880 --> 03:21.880
如果说你学习过C语言的话

03:21.880 --> 03:23.880
你应该知道me这个东西就表示的是

03:23.880 --> 03:26.880
主含书 启动含书 入口含书

03:26.880 --> 03:28.880
就表示入口的意思 对吧

03:28.880 --> 03:29.880
就从这里启动

03:29.880 --> 03:32.880
那么这个GS里边呢 它就会读取这个元素

03:32.880 --> 03:34.880
读取这个元素的自定义属性

03:34.880 --> 03:36.880
把这个自定义属性里边的内容读出来

03:36.880 --> 03:39.880
把这个内容作为启动文件

03:39.880 --> 03:40.880
那么这里边写啥呢

03:40.880 --> 03:42.880
就写上你入口文件的位置

03:42.880 --> 03:43.880
在哪呢

03:43.880 --> 03:44.880
我们这里写一个嘛

03:44.880 --> 03:47.880
比方说写上一个index.js

03:47.880 --> 03:49.880
那么入口文件在哪呢

03:49.880 --> 03:51.880
入口文件就是.js

03:51.880 --> 03:52.880
然后呢

03:52.880 --> 03:54.880
index.js

03:54.880 --> 03:56.880
对吧 就完了

03:56.880 --> 03:57.880
这个GS呢

03:57.880 --> 03:58.880
因为我们引用的是这个GS

03:58.880 --> 04:00.880
这个GS里面就会读取

04:00.880 --> 04:01.880
这个元素的这个位置东西

04:01.880 --> 04:03.880
那么把它作为入口文件

04:03.880 --> 04:04.880
来 我们来运行一下

04:04.880 --> 04:07.880
我们在index.js里面输出一句话

04:07.880 --> 04:09.880
这是入口文件

04:09.880 --> 04:11.880
好 咱们把它运行出来

04:11.880 --> 04:13.880
看一下

04:13.880 --> 04:15.880
点击右键 检查

04:15.880 --> 04:16.880
控制台

04:16.880 --> 04:17.880
你看了没

04:17.880 --> 04:19.880
是不是运行到这个东西 入口文件

04:19.880 --> 04:21.880
这就奇了怪了

04:21.880 --> 04:22.880
我们有没有去引用这个

04:22.880 --> 04:24.880
index.js 文件啊

04:24.880 --> 04:25.880
有没有引用

04:25.880 --> 04:26.880
是不是没有引用啊

04:26.880 --> 04:28.880
那它怎么这个GS文件执行了呢

04:28.880 --> 04:30.880
怎么回事呢 有这么神奇吗

04:30.880 --> 04:32.880
其实要实现这个东西非常非常简单

04:32.880 --> 04:34.880
这个东西是它写的 对吧

04:34.880 --> 04:36.880
比方说你来写这个东西

04:36.880 --> 04:37.880
你怎么写

04:37.880 --> 04:39.880
你又读取这个元素吗

04:39.880 --> 04:41.880
读这个元素里面的什么

04:41.880 --> 04:42.880
data.me对吧

04:42.880 --> 04:43.880
把属性能不能读出来

04:43.880 --> 04:44.880
能读出来吧

04:44.880 --> 04:45.880
读出来之后呢

04:45.880 --> 04:47.880
是不是我就可以生成一个

04:47.880 --> 04:49.880
script元素放到这儿

04:49.880 --> 04:50.880
对吧 放到head里面

04:50.880 --> 04:51.880
给它加一个

04:51.880 --> 04:53.880
在head里面加一个script

04:53.880 --> 04:54.880
这个脚背元素

04:54.880 --> 04:55.880
加进去过后呢

04:55.880 --> 04:56.880
这个脚背元素自然呢

04:56.880 --> 04:57.880
就会读取这个解释了

04:57.880 --> 04:58.880
咱们来看一下

04:58.880 --> 04:59.880
它是不是这样做的

04:59.880 --> 05:01.880
我们检查一下页面元素

05:01.880 --> 05:02.880
在页面元素里面

05:02.880 --> 05:03.880
head里面你看一下

05:03.880 --> 05:04.880
是不是加了个元素了

05:04.880 --> 05:05.880
对吧

05:05.880 --> 05:07.880
加了个元素src的元素

05:07.880 --> 05:09.880
就是我们写的那个入口文件地址

05:09.880 --> 05:10.880
它就是用这种方式来控制的

05:10.880 --> 05:12.880
给你加一个script元素

05:12.880 --> 05:13.880
那么我们的网络传输里面

05:13.880 --> 05:14.880
你看一下

05:14.880 --> 05:16.880
是不是多了一个index的解释了

05:16.880 --> 05:17.880
对吧

05:17.880 --> 05:19.880
先加在required的解释

05:19.880 --> 05:20.880
那么这里面读了个入口文件

05:20.880 --> 05:21.880
读到了过后

05:21.880 --> 05:23.880
就会加在我们的index的解释

05:23.880 --> 05:24.880
这两个不用管

05:24.880 --> 05:25.880
这两个是

05:25.880 --> 05:27.880
我这个vscode的插件

05:27.880 --> 05:28.880
自己家的注入的一些东西

05:28.880 --> 05:29.880
不用管

05:29.880 --> 05:30.880
没问题吧

05:30.880 --> 05:32.880
这就是它加在入口文件的方式

05:32.880 --> 05:33.880
非常简单

05:33.880 --> 05:34.880
了解一下就行了

05:34.880 --> 05:35.880
下面大家有兴趣的话

05:35.880 --> 05:36.880
自己写一下

05:36.880 --> 05:37.880
没兴趣的话就算了

05:37.880 --> 05:39.880
这个东西简单了解

05:39.880 --> 05:40.880
然后接下来

05:40.880 --> 05:42.880
我们要形成这么一种结构

05:42.880 --> 05:43.880
要形成这么一种结构

05:43.880 --> 05:44.880
来吧

05:44.880 --> 05:45.880
我们比方说

05:45.880 --> 05:47.880
我们先写一个必点解释

05:47.880 --> 05:48.880
因为入口文件

05:48.880 --> 05:49.880
它要依赖它

05:49.880 --> 05:51.880
我们先写一个必点解释

05:51.880 --> 05:52.880
我们在解释里面

05:52.880 --> 05:53.880
新建个文件

05:53.880 --> 05:54.880
必点解释

05:54.880 --> 05:56.880
那么这里要设计到一个问题

05:56.880 --> 05:58.880
我怎么来导出

05:58.880 --> 05:59.880
如果说common解释的话

05:59.880 --> 06:00.880
那么就直接写单

06:00.880 --> 06:01.880
就还手了

06:01.880 --> 06:02.880
对吧

06:02.880 --> 06:04.880
加上一个marge

06:04.880 --> 06:05.880
就不导出了

06:05.880 --> 06:06.880
但是呢

06:06.880 --> 06:07.880
我们之前说过

06:07.880 --> 06:08.880
在浏览器环境下面

06:08.880 --> 06:09.880
你必须要手动的

06:09.880 --> 06:11.880
把它放到一个函数环境里边

06:11.880 --> 06:13.880
不然的话会污染全局变量

06:13.880 --> 06:14.880
怎么办呢

06:14.880 --> 06:15.880
它是这样子

06:15.880 --> 06:16.880
无论你要导出

06:16.880 --> 06:17.880
还是要导入

06:17.880 --> 06:18.880
都必须要使用

06:18.880 --> 06:20.880
这个required解释

06:20.880 --> 06:22.880
这个required解释里面

06:22.880 --> 06:24.880
提供了一个全局的方法

06:24.880 --> 06:26.880
它里面有没有污染全局变量

06:26.880 --> 06:27.880
肯定有

06:27.880 --> 06:28.880
它给你全局的

06:28.880 --> 06:30.880
一个方法叫做define

06:30.880 --> 06:32.880
提供了这么一个方法

06:32.880 --> 06:33.880
提供了这么一个方法

06:33.880 --> 06:34.880
define

06:34.880 --> 06:36.880
好,define这个方法里面写啥呢

06:36.880 --> 06:38.880
有好多种写法

06:38.880 --> 06:39.880
我刚才介绍一种

06:39.880 --> 06:40.880
其中一种最简单的写法

06:40.880 --> 06:42.880
就是你要导出什么

06:42.880 --> 06:43.880
你就写什么

06:43.880 --> 06:44.880
不要用你写个123

06:44.880 --> 06:45.880
我们没了

06:45.880 --> 06:46.880
你又导出了123

06:46.880 --> 06:47.880
对吧

06:47.880 --> 06:48.880
就导出了123

06:48.880 --> 06:49.880
你写个对象

06:49.880 --> 06:50.880
你又导出了一个对象

06:50.880 --> 06:51.880
你导出了一个对象

06:51.880 --> 06:52.880
就这么简单

06:52.880 --> 06:53.880
就这么简单

06:53.880 --> 06:54.880
能理解吗

06:54.880 --> 06:56.880
如果说你的导出的内容

06:56.880 --> 06:59.880
是经过一系列的过程来导出的

06:59.880 --> 07:00.880
那怎么办呢

07:00.880 --> 07:02.880
你可以写个函数

07:02.880 --> 07:04.880
你可以写个函数

07:04.880 --> 07:06.880
这个函数的返回值

07:06.880 --> 07:07.880
就是导出内容

07:07.880 --> 07:08.880
这是比较

07:08.880 --> 07:10.880
如果说你以前使用

07:10.880 --> 07:11.880
当然你不存在以前了

07:11.880 --> 07:12.880
就我们以前

07:12.880 --> 07:14.880
如果说使用AMD的话

07:14.880 --> 07:15.880
那么就说

07:15.880 --> 07:17.880
一般都会通过这种方式

07:17.880 --> 07:18.880
比方说这里边的代码

07:18.880 --> 07:19.880
因为在函数环境里边

07:19.880 --> 07:20.880
是不是不会

07:20.880 --> 07:21.880
不会受到任何污染

07:21.880 --> 07:22.880
对吧

07:22.880 --> 07:23.880
这里边你想定义啥

07:23.880 --> 07:24.880
就定义啥

07:24.880 --> 07:25.880
不会受到任何污染

07:25.880 --> 07:26.880
函数里边

07:26.880 --> 07:28.880
那么这个函数的返回值

07:28.880 --> 07:30.880
就是你的导出的结果

07:30.880 --> 07:32.880
比方说我们导出一个啥呢

07:32.880 --> 07:34.880
导出一个对象

07:34.880 --> 07:35.880
一个对象

07:35.880 --> 07:36.880
name

07:36.880 --> 07:38.880
b模块

07:38.880 --> 07:40.880
比方说

07:40.880 --> 07:41.880
还有一些其他数据

07:41.880 --> 07:43.880
data

07:43.880 --> 07:46.880
b模块的数据

07:46.880 --> 07:47.880
当然随便导出啥都行

07:47.880 --> 07:48.880
导出一个字幕串

07:48.880 --> 07:49.880
我再导出一个对象

07:49.880 --> 07:50.880
导出一个字幕串也可以

07:50.880 --> 07:52.880
导出一个数字也可以

07:52.880 --> 07:53.880
导出一个函数也可以

07:53.880 --> 07:54.880
你返回啥

07:54.880 --> 07:55.880
导出啥

07:55.880 --> 07:56.880
是不是很简单

07:56.880 --> 07:57.880
b点儿阶势就写完了

07:57.880 --> 07:58.880
就写完了

07:58.880 --> 07:59.880
好

07:59.880 --> 08:00.880
那咱们来看一下

08:00.880 --> 08:01.880
来看一下

08:01.880 --> 08:03.880
b点儿阶势写完了之后

08:03.880 --> 08:04.880
我们再回到

08:04.880 --> 08:05.880
index的阶势里边

08:05.880 --> 08:06.880
入口文件里边

08:06.880 --> 08:08.880
那么入口文件怎么来导入它呢

08:08.880 --> 08:09.880
也是一样的

08:09.880 --> 08:10.880
第一

08:10.880 --> 08:12.880
因为你这个入口文件

08:12.880 --> 08:13.880
也是个模块

08:13.880 --> 08:14.880
你也需要导出

08:14.880 --> 08:15.880
对不对

08:15.880 --> 08:16.880
那怎么导入呢

08:16.880 --> 08:17.880
你使用这样的参数

08:17.880 --> 08:19.880
一个数组

08:19.880 --> 08:21.880
这个数组里边写的东西

08:21.880 --> 08:23.880
就是你的模块名称

08:23.880 --> 08:25.880
模块名称有很多种写法

08:25.880 --> 08:26.880
还可以自定义模块名称

08:26.880 --> 08:27.880
不过这些东西

08:27.880 --> 08:28.880
细节

08:28.880 --> 08:29.880
这些细致没解的东西

08:29.880 --> 08:30.880
我们不管了

08:30.880 --> 08:31.880
我们就简单介绍一下

08:31.880 --> 08:33.880
这里我们通常使用的模块名称

08:33.880 --> 08:34.880
就是文件名称

08:34.880 --> 08:35.880
那么路径就是

08:35.880 --> 08:37.880
相对于入口文件的路径

08:37.880 --> 08:38.880
那么比方说

08:38.880 --> 08:39.880
我们要导入b

08:39.880 --> 08:41.880
是不是跟入口文件是同一个路径

08:41.880 --> 08:42.880
同一个路径

08:42.880 --> 08:43.880
那么就就解上模块名称

08:43.880 --> 08:44.880
这个文件名

08:44.880 --> 08:45.880
b就行了

08:45.880 --> 08:47.880
不要写后边的点儿阶势

08:47.880 --> 08:48.880
不要写点儿阶势

08:48.880 --> 08:49.880
写上点儿阶势之后

08:49.880 --> 08:50.880
它又有另外的处理方式

08:50.880 --> 08:51.880
不用管它

08:51.880 --> 08:53.880
你就写上一个文件名称

08:53.880 --> 08:54.880
b

08:54.880 --> 08:55.880
不要那意思

08:55.880 --> 08:56.880
那么你就表示

08:56.880 --> 08:59.880
我这个文件里边要导入模块 b

08:59.880 --> 09:01.880
如果说你要导入多个模块的话

09:01.880 --> 09:03.880
那么你还可以写上别的模块

09:03.880 --> 09:04.880
ac

09:04.880 --> 09:05.880
还可以写上别的模块

09:05.880 --> 09:07.880
那如果说你只导入一个模块的话

09:07.880 --> 09:09.880
在数组里边写上一个模块就行了

09:09.880 --> 09:10.880
因为它是个数组

09:10.880 --> 09:12.880
它可以导入多个模块

09:12.880 --> 09:14.880
然后第二个参数

09:14.880 --> 09:16.880
写上你自己模块内部的代码

09:16.880 --> 09:17.880
在这里

09:17.880 --> 09:19.880
写上模块内部的代码

09:19.880 --> 09:20.880
不要那意思吗

09:20.880 --> 09:23.880
那么这个就是模块内部的代码

09:23.880 --> 09:24.880
那么这个方式

09:24.880 --> 09:26.880
跟这边的b的方式

09:26.880 --> 09:28.880
含义是一样的

09:28.880 --> 09:30.880
这些都是模块内部的代码

09:30.880 --> 09:34.880
都是模块内部的代码

09:34.880 --> 09:36.880
都是模块内部的代码

09:36.880 --> 09:37.880
那么这个函数的反回之

09:37.880 --> 09:39.880
就作为这个模块导出的东西

09:39.880 --> 09:41.880
比方说在index里边

09:41.880 --> 09:44.880
那么这个是我们index入口文件模块里边

09:44.880 --> 09:46.880
它要依赖b

09:46.880 --> 09:48.880
并且它要运行一段自己的函数

09:48.880 --> 09:49.880
然后运行完了过后

09:49.880 --> 09:50.880
它反回的东西

09:50.880 --> 09:52.880
就是这个index模块

09:52.880 --> 09:53.880
它要导入的东西

09:53.880 --> 09:54.880
只不过呢

09:54.880 --> 09:55.880
入口文件里边

09:55.880 --> 09:57.880
它也没什么需要导出了

09:57.880 --> 09:58.880
也没什么需要导出了

09:58.880 --> 10:00.880
也可以不写反回之了

10:00.880 --> 10:01.880
就反回扬迪范嘛

10:01.880 --> 10:02.880
没问题吧

10:02.880 --> 10:04.880
就这种模式

10:04.880 --> 10:06.880
然后我这里说一下

10:06.880 --> 10:08.880
这个函数是什么时候执行了

10:08.880 --> 10:10.880
如果说你写了一代的话

10:10.880 --> 10:12.880
那么它这执行是一步的

10:12.880 --> 10:14.880
它要等到b这个模块

10:14.880 --> 10:16.880
也说远程去加在这个js

10:16.880 --> 10:19.880
它生成一个script的元素

10:19.880 --> 10:22.880
去远程加在这个b点js

10:22.880 --> 10:23.880
加在完了过后

10:23.880 --> 10:24.880
它会运行这个函数

10:24.880 --> 10:25.880
是不是一步的

10:25.880 --> 10:27.880
那么是不是就是我们上节课

10:27.880 --> 10:29.880
讲两个问题就解决了

10:29.880 --> 10:30.880
它首先是一步的

10:30.880 --> 10:31.880
这个函数运行是一步的

10:31.880 --> 10:34.880
它要等到模块b加在完成

10:34.880 --> 10:39.880
等模块等b点js加在

10:39.880 --> 10:43.880
加在完成后

10:43.880 --> 10:45.880
运行该函数

10:45.880 --> 10:47.880
所以它是一步的

10:47.880 --> 10:48.880
另外它也解决了

10:48.880 --> 10:51.880
我们之前说的那个污染权娶的问题

10:51.880 --> 10:53.880
它把它放到一个函数环境里面执行

10:53.880 --> 10:55.880
因为它本来就是自己写的函数

10:55.880 --> 10:56.880
它自然在函数环境里面

10:56.880 --> 10:58.880
就解决这个问题了

10:58.880 --> 11:00.880
我们导入一个b

11:00.880 --> 11:01.880
导入b模块过后

11:01.880 --> 11:04.880
我希望把b模块导入的内容输出

11:04.880 --> 11:07.880
我怎么输出导入的模块内容

11:07.880 --> 11:08.880
是这样子来处理的

11:08.880 --> 11:11.880
你这里导入的b这个模块

11:11.880 --> 11:12.880
那怎么办呢

11:12.880 --> 11:14.880
这里它就会有一个相应的参数

11:14.880 --> 11:15.880
你这里写了一个模块

11:15.880 --> 11:17.880
那么这里就有一个参数

11:17.880 --> 11:18.880
你这里写了三个模块

11:18.880 --> 11:19.880
这里就有三个参数

11:19.880 --> 11:21.880
分别对应对应的模块

11:21.880 --> 11:23.880
比方说你这里写个abc

11:23.880 --> 11:24.880
那么这个abc这个变量

11:24.880 --> 11:26.880
它就是把b这个模块导入的内容

11:26.880 --> 11:28.880
放到这个abc里面

11:28.880 --> 11:29.880
当然我们平时呢

11:29.880 --> 11:30.880
一般情况下

11:30.880 --> 11:32.880
我们会把一个参数的名字

11:32.880 --> 11:35.880
跟这个模块的名字写成一字

11:35.880 --> 11:37.880
这样子方便变人

11:37.880 --> 11:38.880
我们输出b这个模块

11:38.880 --> 11:40.880
保存你看一下

11:40.880 --> 11:43.880
你看一下是不是输出了这么一个东西

11:44.880 --> 11:45.880
说明什么

11:45.880 --> 11:46.880
说明我这里是不是

11:46.880 --> 11:48.880
把b模块的东西拿到了

11:48.880 --> 11:49.880
对不对

11:49.880 --> 11:50.880
是不是拿到了

11:50.880 --> 11:51.880
然后我们看一下

11:51.880 --> 11:52.880
这个网页元素里面

11:52.880 --> 11:54.880
是不是多了一个这个元素

11:54.880 --> 11:56.880
多了这么一个元素

11:56.880 --> 11:57.880
因为它在运行入口文件的时候

11:57.880 --> 11:58.880
它就会发现

11:58.880 --> 12:00.880
我还依赖b这个模块

12:00.880 --> 12:02.880
于是它就会生成一个script元素

12:02.880 --> 12:03.880
放到这儿

12:03.880 --> 12:04.880
那么导入这个b模块

12:04.880 --> 12:06.880
当这个元素加载完成之后

12:06.880 --> 12:08.880
它就会运行这个函数

12:08.880 --> 12:09.880
对吧

12:09.880 --> 12:10.880
没问题吧

12:10.880 --> 12:11.880
输出b就可以得到了

12:11.880 --> 12:12.880
就这么简单

12:12.880 --> 12:13.880
就这么简单

12:13.880 --> 12:15.880
那如果说我们还要

12:15.880 --> 12:16.880
那么现在我们就已经形成

12:16.880 --> 12:17.880
这种关系了

12:17.880 --> 12:18.880
对吧

12:18.880 --> 12:19.880
是不是已经形成这种关系了

12:19.880 --> 12:20.880
我们比方说

12:20.880 --> 12:22.880
再继续加上a2.js

12:22.880 --> 12:23.880
和b2.js

12:23.880 --> 12:25.880
比方说我们加上a2.js

12:25.880 --> 12:26.880
a2.js

12:26.880 --> 12:28.880
我们把这个复字过来吧

12:28.880 --> 12:30.880
我们自己重新写吧

12:30.880 --> 12:31.880
再来一遍

12:31.880 --> 12:32.880
a2.js

12:32.880 --> 12:34.880
它是不是要依赖b这个模块

12:34.880 --> 12:35.880
对吧

12:35.880 --> 12:36.880
是不是要依赖b这个模块

12:36.880 --> 12:37.880
我们怎么写

12:37.880 --> 12:38.880
b

12:38.880 --> 12:39.880
对吧

12:39.880 --> 12:40.880
依赖b这个模块

12:40.880 --> 12:41.880
并且把b的模块

12:41.880 --> 12:43.880
作为参数传进来了

12:43.880 --> 12:45.880
我们这里就是

12:45.880 --> 12:46.880
输出一下吧

12:46.880 --> 12:49.880
这是a模块的内部代码

12:49.880 --> 12:51.880
我们这里把这个放过来

12:51.880 --> 12:53.880
放了b模块的内部代码里面来

12:53.880 --> 12:58.640
这是b模块的内部代码

12:58.640 --> 12:59.640
这是a模块的内部代码

12:59.640 --> 13:01.640
然后我们再来看一下

13:01.640 --> 13:03.640
我们这里直接返回

13:03.640 --> 13:04.640
返回表示a模块

13:04.640 --> 13:05.640
它导出的东西

13:05.640 --> 13:07.640
其实就是把common界

13:07.640 --> 13:08.640
common界是无非

13:08.640 --> 13:09.640
就是把这一段代码

13:09.640 --> 13:10.640
直接写了

13:10.640 --> 13:11.640
那么这里

13:11.640 --> 13:12.640
就是把它放到

13:12.640 --> 13:13.640
一个函数里面

13:13.640 --> 13:14.640
common界是通过

13:14.640 --> 13:16.640
module.export导出的

13:16.640 --> 13:18.640
那么这里是直接返回的

13:18.640 --> 13:19.640
就这么个区别

13:19.640 --> 13:20.640
好 返回

13:20.640 --> 13:22.640
比方说我们这里返回一个

13:22.640 --> 13:23.640
name

13:23.640 --> 13:24.640
a模块

13:24.640 --> 13:25.640
比方说我们返回一个

13:25.640 --> 13:26.640
字书串

13:27.640 --> 13:30.640
a模块的内容

13:30.640 --> 13:31.640
好 咱们来看一下

13:31.640 --> 13:32.640
保存

13:33.640 --> 13:34.640
首先我们看一下

13:34.640 --> 13:35.640
有没有a模块输出

13:35.640 --> 13:36.640
是没有

13:36.640 --> 13:37.640
这句话没有输出

13:37.640 --> 13:38.640
为啥

13:38.640 --> 13:39.640
因为我们运行的

13:39.640 --> 13:40.640
只是入口文件

13:40.640 --> 13:41.640
而入口文件里面

13:41.640 --> 13:42.640
它并不依赖

13:42.640 --> 13:43.640
a模块

13:43.640 --> 13:44.640
所以说a模块

13:44.640 --> 13:45.640
它没有加载

13:45.640 --> 13:46.640
我们可以通过

13:46.640 --> 13:47.640
这个元素里面

13:47.640 --> 13:48.640
可以清楚的看到

13:48.640 --> 13:49.640
a模块也没有加载

13:49.640 --> 13:50.640
是不是没有加载

13:50.640 --> 13:51.640
对吧 没有加载

13:52.640 --> 13:53.640
好 那么我们

13:53.640 --> 13:54.640
如果说在intx里面

13:54.640 --> 13:56.640
还要引用a模块怎么办

13:57.640 --> 13:58.640
对吧

13:58.640 --> 13:59.640
顺序的话

13:59.640 --> 14:00.640
无所谓

14:00.640 --> 14:01.640
看你怎么用

14:01.640 --> 14:02.640
比方说我们这里

14:02.640 --> 14:03.640
这里得到a

14:03.640 --> 14:04.640
我们输出

14:04.640 --> 14:05.640
b模块

14:05.640 --> 14:06.640
a模块

14:06.640 --> 14:07.640
咱们来看一下

14:07.640 --> 14:08.640
保存

14:08.640 --> 14:09.640
于是我们看一下

14:09.640 --> 14:10.640
我们a模块

14:10.640 --> 14:12.640
b模块的内容拿到了

14:12.640 --> 14:13.640
对吧

14:13.640 --> 14:14.640
a模块的内容

14:14.640 --> 14:15.640
是不是也拿到了

14:15.640 --> 14:16.640
就这么个东西

14:16.640 --> 14:17.640
冰起来 a模块

14:17.640 --> 14:18.640
b模块是不是都运行的

14:18.640 --> 14:19.640
就这么简单

14:19.640 --> 14:20.640
就这么简单

14:20.640 --> 14:21.640
而且你会看到

14:21.640 --> 14:22.640
a模块

14:22.640 --> 14:24.640
b模块由于被引用了两次

14:24.640 --> 14:25.640
你看

14:25.640 --> 14:26.640
a代理用它

14:26.640 --> 14:27.640
它字节

14:27.640 --> 14:28.640
入口文件也在用它

14:28.640 --> 14:29.640
对吧

14:29.640 --> 14:30.640
但是这个模块里面

14:30.640 --> 14:31.640
代码

14:31.640 --> 14:32.640
就这一部分代码

14:32.640 --> 14:33.640
是不是只运行了一次

14:33.640 --> 14:34.640
你看

14:34.640 --> 14:35.640
b模块的代码

14:35.640 --> 14:36.640
是不是只运行了一次

14:36.640 --> 14:37.640
这说明了啥

14:37.640 --> 14:38.640
说明了啥

14:38.640 --> 14:39.640
是不是说明了

14:39.640 --> 14:41.640
它也有缓存

14:41.640 --> 14:43.640
它不会重复地去夹展

14:43.640 --> 14:44.640
它也有缓存的

14:44.640 --> 14:45.640
怎么样类似吗

14:45.640 --> 14:46.640
ok

14:46.640 --> 14:48.640
其他实现缓存的也很简单

14:48.640 --> 14:49.640
它就看

14:49.640 --> 14:50.640
每一个模块

14:50.640 --> 14:51.640
它给它一个名字

14:51.640 --> 14:52.640
你看一下

14:52.640 --> 14:53.640
叫margeu

14:53.640 --> 14:54.640
b

14:54.640 --> 14:55.640
每一个模块

14:55.640 --> 14:56.640
它给它一个自定义属性

14:56.640 --> 14:57.640
放到元素里面

14:57.640 --> 14:58.640
它发现这个元

14:58.640 --> 14:59.640
模块已经夹展过了

14:59.640 --> 15:00.640
它就不会再重新夹展

15:02.640 --> 15:03.640
这是关于

15:04.640 --> 15:06.640
amd它的实现方式

15:06.640 --> 15:07.640
就是非常简单

15:07.640 --> 15:12.640
其实在require的

15:12.640 --> 15:15.640
它除了实现amd这种模式之外

15:15.640 --> 15:16.640
它还给你

15:16.640 --> 15:18.640
为了方便那些

15:18.640 --> 15:19.640
用common.js

15:19.640 --> 15:21.640
用习惯了的人

15:21.640 --> 15:22.640
为了方便他们

15:22.640 --> 15:23.640
它其实还给你

15:23.640 --> 15:24.640
做出来一种方案

15:24.640 --> 15:25.640
就是跟common.js

15:25.640 --> 15:26.640
差不多的方案

15:26.640 --> 15:27.640
它怎么做的呢

15:27.640 --> 15:28.640
我给它顺便说一下

15:28.640 --> 15:29.640
其实现在都没啥用了

15:29.640 --> 15:30.640
就以前

15:31.640 --> 15:33.640
在es6出来之前

15:33.640 --> 15:34.640
还可以拥有

15:34.640 --> 15:35.640
它怎么用的

15:35.640 --> 15:36.640
它是这样子

15:37.640 --> 15:39.640
用这种方案

15:39.640 --> 15:40.640
跟common.js

15:40.640 --> 15:42.640
其实差别还是蛮大的

15:42.640 --> 15:43.640
差别还是蛮大的

15:43.640 --> 15:45.640
那有没有跟common.js

15:45.640 --> 15:46.640
类似的方案

15:46.640 --> 15:47.640
它做出来这么一种方式

15:47.640 --> 15:48.640
就是说你

15:48.640 --> 15:49.640
一翻里面

15:49.640 --> 15:50.640
你直接写个函数

15:50.640 --> 15:51.640
这个函数

15:51.640 --> 15:52.640
它会给你传入

15:52.640 --> 15:53.640
三个函数

15:53.640 --> 15:54.640
如果说你直接写一个函数

15:54.640 --> 15:55.640
不加任何其他函数的话

15:55.640 --> 15:56.640
它会给你传入

15:56.640 --> 15:57.640
三个函数

15:57.640 --> 15:58.640
这三个函数

15:58.640 --> 16:00.640
分别是require

16:00.640 --> 16:01.640
export

16:01.640 --> 16:02.640
module

16:03.640 --> 16:04.640
你懂了是吧

16:04.640 --> 16:05.640
你懂了

16:05.640 --> 16:06.640
这三个玩意

16:06.640 --> 16:07.720
是不是就是

16:07.720 --> 16:08.640
common.js

16:08.640 --> 16:09.640
里面那种东西

16:12.640 --> 16:13.640
就是这个东西

16:13.640 --> 16:14.640
那么它会

16:14.640 --> 16:15.640
最后跟common.js

16:15.640 --> 16:16.640
一样

16:16.640 --> 16:17.640
它会把module.export

16:17.640 --> 16:18.640
直接返回

16:18.640 --> 16:19.640
所以说

16:19.640 --> 16:20.640
你这里面

16:20.640 --> 16:21.640
还可以这样子写

16:21.640 --> 16:22.640
就是你要导出什么东西

16:22.640 --> 16:23.640
你可以怎么写呢

16:24.640 --> 16:26.640
module.export

16:26.640 --> 16:27.640
当然你返回也可以

16:27.640 --> 16:28.640
也可以

16:28.640 --> 16:29.640
因为它最终

16:29.640 --> 16:30.640
还不是把这个东西返回

16:30.640 --> 16:31.640
你返回也可以

16:32.640 --> 16:33.640
它就这样写了

16:34.640 --> 16:35.640
没有什么

16:35.640 --> 16:36.640
这样子也行

16:36.640 --> 16:37.640
你看吧

16:37.640 --> 16:38.640
所以也行

16:38.640 --> 16:40.640
B模块仍然可以导出

16:40.640 --> 16:42.640
你看B模块我们用这种写法仍然可以导出

16:42.640 --> 16:45.640
那么A模块我们也可以用这种方式

16:45.640 --> 16:48.640
我在想我要不要把之前的注释掉

16:48.640 --> 16:49.640
尽量不要注释掉

16:49.640 --> 16:57.820
我们重新写

16:57.820 --> 16:59.820
低点解释

16:59.820 --> 17:02.260
OK

17:02.260 --> 17:04.260
我们把之前的注释掉

17:04.260 --> 17:05.260
不划算了

17:05.260 --> 17:06.260
方便大家去变人

17:06.260 --> 17:08.260
就两种写法都可以

17:08.260 --> 17:10.260
这种写法是为了

17:10.260 --> 17:12.260
让使用common解释的人

17:12.260 --> 17:13.260
方便一点

17:13.260 --> 17:14.260
就是在common解释外面

17:14.260 --> 17:15.260
掏了一个东西

17:15.260 --> 17:16.260
就掏了这个玩意

17:16.260 --> 17:17.260
就掏了这个玩意

17:17.260 --> 17:18.260
其他啥都没变

17:18.260 --> 17:19.260
那么A点解释

17:19.260 --> 17:21.260
我们同样用common解释来写

17:21.260 --> 17:22.260
也可以写出来

17:22.260 --> 17:23.260
Defend

17:24.260 --> 17:25.260
Defend

17:25.260 --> 17:26.260
Defend是肯定必须要写的

17:26.260 --> 17:27.260
你必须要把它放到寒树里边

17:27.260 --> 17:28.260
因为流量机厂商

17:28.260 --> 17:30.260
它不会把它放到寒树里边

17:30.260 --> 17:31.260
你必须要手动放

17:31.260 --> 17:32.260
那么直接写寒树

17:32.260 --> 17:34.260
当然你学过ES6的话

17:34.260 --> 17:35.260
你还可以写箭头寒树

17:35.260 --> 17:36.260
Export

17:36.260 --> 17:38.260
当这个参数的名字

17:38.260 --> 17:39.260
你随便写

17:39.260 --> 17:41.260
只不过我们为了跟common解释

17:41.260 --> 17:42.260
这样的就是相似

17:42.260 --> 17:44.260
我们也可以用这种方式来写

17:44.260 --> 17:46.260
就尽量把名字也写成一样的

17:47.260 --> 17:48.260
那么这里

17:48.260 --> 17:49.260
我们要导出

17:49.260 --> 17:50.260
用什么导出

17:50.260 --> 17:51.260
用什么导出

17:51.260 --> 17:52.260
这里要依赖B

17:52.260 --> 17:53.260
对吧

17:53.260 --> 17:54.260
要依赖B

17:54.260 --> 17:55.260
依赖B怎么来依赖

17:55.260 --> 17:56.260
是不是用require

17:57.260 --> 17:58.260
B

17:58.260 --> 17:59.260
当然这里就不要

17:59.260 --> 18:00.260
可以写点小钢

18:00.260 --> 18:01.260
也可以不写

18:01.260 --> 18:02.260
这毕竟不是漏的环境

18:02.260 --> 18:04.260
漏的环境里边是有要求的

18:04.260 --> 18:05.260
这里必须要写

18:05.260 --> 18:06.260
这要写钢

18:06.260 --> 18:07.260
在这里不用写了

18:07.260 --> 18:08.260
那么这里是不是可以得到

18:08.260 --> 18:09.260
递得结果

18:09.260 --> 18:10.260
实际上实现的原理是一样的

18:10.260 --> 18:11.260
这个函数

18:11.260 --> 18:14.260
它也会去生成一个script的元素

18:14.260 --> 18:16.260
它也会去生成那个元素

18:16.260 --> 18:18.260
那么把B某块导出的那种

18:18.260 --> 18:19.260
放到这个边疆B里边

18:19.260 --> 18:21.260
我们这里比方说说一下

18:21.260 --> 18:22.260
M某块的内部代码

18:22.260 --> 18:23.260
它导出了B

18:23.260 --> 18:24.260
对吧

18:24.260 --> 18:25.260
导出了B

18:25.260 --> 18:26.260
那么这里可以返回

18:26.260 --> 18:28.260
返回表示M某块导出

18:28.260 --> 18:29.260
也可以使用

18:29.260 --> 18:31.260
Module.export

18:31.260 --> 18:33.260
当然它也可以使用export

18:33.260 --> 18:35.260
它的用法和它的缺陷

18:35.260 --> 18:38.260
跟common解释是完全一样的

18:38.260 --> 18:41.260
比方说这是M某块

18:41.260 --> 18:44.260
M某块的内容

18:44.260 --> 18:45.260
是一样的

18:45.260 --> 18:46.260
好,那么再来

18:46.260 --> 18:47.260
再来

18:47.260 --> 18:49.260
在那个入口文件里边

18:49.260 --> 18:51.260
我们也可以这样写

18:51.260 --> 18:53.260
define

18:53.260 --> 18:56.260
这里我们用箭头函数写一次吧

18:56.260 --> 18:58.260
当然你也可以用普通方法来写

18:58.260 --> 19:00.260
export

19:00.260 --> 19:03.260
module

19:03.260 --> 19:06.260
那么这里是一样的

19:06.260 --> 19:07.260
输出

19:07.260 --> 19:08.260
A和B

19:08.260 --> 19:09.260
B和A

19:09.260 --> 19:10.260
A和B

19:10.260 --> 19:11.260
无所谓

19:11.260 --> 19:12.260
那么这里我们怎么来

19:12.260 --> 19:14.260
A等于required

19:14.260 --> 19:15.260
A

19:15.260 --> 19:17.260
B等于required

19:17.260 --> 19:18.260
B

19:21.260 --> 19:22.260
好,是不是写完了

19:22.260 --> 19:23.260
对吧

19:23.260 --> 19:24.260
是一样的

19:24.260 --> 19:25.260
没什么区别

19:25.260 --> 19:26.260
好,看一下吧

19:26.260 --> 19:27.260
是一样的

19:27.260 --> 19:28.260
M某块夹在了

19:28.260 --> 19:29.260
它导入了B某块的内容

19:29.260 --> 19:31.260
入口文件的也夹在出来了

19:31.260 --> 19:32.260
B某块的内容

19:32.260 --> 19:33.260
A某块的内容

19:33.260 --> 19:34.260
并且它也有缓存

19:34.260 --> 19:36.260
B某块执行了一次

19:36.260 --> 19:37.260
是不是非常简单

19:37.260 --> 19:38.260
非常简单

19:38.260 --> 19:40.260
只写起来你必须要夹个

19:40.260 --> 19:41.260
就在外面掏个D范而已

19:41.260 --> 19:42.260
其他没啥偏的话

19:42.260 --> 19:44.260
就是AMD规范

19:44.260 --> 19:45.260
我们这门客

19:45.260 --> 19:47.260
这门客整门客都非常非常简单

19:47.260 --> 19:49.260
但是特别好玩

19:49.260 --> 19:50.260
也特别实用

19:50.260 --> 19:52.260
好了,这是关于AMD规范

