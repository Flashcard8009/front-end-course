WEBVTT

00:00.050 --> 00:05.050
大家好 欢迎收看独立教育给大家提供的你不知道GS系列专题的课程

00:05.050 --> 00:10.050
我是独立教育CTO 叫陈子彤 也是咱们独立教育的前端技术主负的人

00:10.050 --> 00:18.050
今天给大家带来的是一个GS运行机制的一个底层的原理 主要是做这方面一个讲解

00:18.050 --> 00:24.050
我相信很多人一直在使用GS 一直在用它去做各种各样的项目

00:24.050 --> 00:30.050
对这个底层有这样一个声的了解 尤其是GS这样一个运行机制

00:30.050 --> 00:35.050
其实说实在的 如果是你不了解的话 其实你依旧可以去完成一些项目

00:35.050 --> 00:39.050
但是可能会出现一些错误的时候 你未必会知道怎么回事

00:39.050 --> 00:42.050
如果你不知道的话 等过前过去以后的话

00:42.050 --> 00:49.050
那就是你可能就永远都没有办法 说永远再没有意识想要去了解这一块

00:49.050 --> 00:51.050
但这一块往往又很重要

00:51.050 --> 00:54.050
那比如说讲这一块之前吧

00:54.050 --> 00:58.050
我还是给大家首先来普及一下乱七的一些常铸的线程

00:58.050 --> 01:02.050
当然这是一个在我看来吧 是个很重要的一个支持点

01:02.050 --> 01:06.050
当然如果说你要做一个前端那些高级开发的话

01:06.050 --> 01:10.050
你也必须的去了解GS这样的各种特性 光会用的 这只是第一步而已

01:10.050 --> 01:16.050
那咱来看一下 我们一直长时候我们GS是单线程

01:16.050 --> 01:18.050
我们GS线程怎么怎么样

01:18.050 --> 01:20.050
单线程我们627中啊

01:20.050 --> 01:22.050
一个627中它包含了很多种线程

01:22.050 --> 01:25.050
就比如说我们常说的GS引擎线程

01:25.050 --> 01:28.050
有时候它用来解释和执行GS代码

01:28.050 --> 01:31.050
出自这样的还有GOL线程 它用来绘制用户画面

01:31.050 --> 01:34.050
当然它是与主线程是互斥的

01:34.050 --> 01:36.050
这个互斥是怎么回事呢 咱一会说

01:36.050 --> 01:39.050
还有一些关于就是异部的一些线程

01:39.050 --> 01:43.050
比如说HTEP网络请求线程 它主要用来处理

01:43.050 --> 01:45.050
比如说你在前端发送了一些网络请求

01:45.050 --> 01:48.050
比如说GS发送一个异部请求

01:48.050 --> 01:51.050
好了 请求之后的服务器当码就出去发送给你以后

01:51.050 --> 01:55.050
那我们是要触发这样的一个回调函数的

01:55.050 --> 01:58.050
那那个时候呢 其实是有HTEP网络请求线程

01:58.050 --> 02:01.050
由它来进行这样的一个回调的一个管控

02:01.050 --> 02:07.050
当然还有定时器触发线程和浏览器触发线程

02:07.050 --> 02:14.050
那这里面有个解释 就是这个定时触发器线程

02:14.050 --> 02:19.050
就是这样的线程 它是负责set-out和set-intel

02:19.050 --> 02:22.050
当他们就是在等待时间结束以后的话

02:22.050 --> 02:25.050
他们负责把这个函数或是把这个任务推到任务队的之中

02:25.050 --> 02:29.050
那浏览器线程 你看这个 看这样的一个描述

02:29.050 --> 02:31.050
大概你也会对它有个这样的了解

02:31.050 --> 02:33.050
而这里面很多情况下都提到一个词

02:33.050 --> 02:35.050
就叫做任务队列

02:35.050 --> 02:37.050
那任务队列呢 它其实是我们GS

02:37.050 --> 02:40.050
GS引起的线程 这里面的一块的概念

02:40.050 --> 02:42.050
咱一会说 好 但你现在要知道一点

02:42.050 --> 02:45.050
就是浏览器中 基本可以这么说

02:45.050 --> 02:49.050
大部分的浏览器中都是就这五个线程的

02:49.050 --> 02:53.050
那这五个线程呢 其实是被一个叫做UI主线程

02:53.050 --> 02:57.050
通了它来进行这样的协调去运作的

02:57.050 --> 03:01.050
那咱看一下 这个几个线程是如何来进行这样的一个协调工作的

03:01.050 --> 03:03.050
这里面有个图

03:03.050 --> 03:08.050
那这个图呢 因为看到 这一块叫做GS引起的线程

03:08.050 --> 03:10.050
那这里面每一个举行

03:10.050 --> 03:13.050
那其实它都当做一个函数的

03:13.050 --> 03:16.050
都可以当做一个任务 这个任务的本质上

03:16.050 --> 03:18.050
其实可以列出函数的执行

03:18.050 --> 03:23.050
那无论是 你看 无论是你当你去触发了一个事件

03:23.050 --> 03:28.050
之后呢 这个事件 管控事件的这样的一个线程

03:28.050 --> 03:31.050
它把一个任务给你推到了这样的GS举行程之中

03:31.050 --> 03:33.050
还是说这个电人器隔了一段时间

03:33.050 --> 03:34.050
把任务给你放到里面去

03:34.050 --> 03:36.050
或者是说呢 你看 或者是说

03:36.050 --> 03:39.050
比如说网络这个请求之后的话

03:39.050 --> 03:41.050
这个数据要往回传了

03:41.050 --> 03:43.050
完了 回到函数被触发

03:43.050 --> 03:45.050
也是当这个任务 给它放到里面去

03:45.050 --> 03:47.050
无论是这几种任务的

03:47.050 --> 03:49.050
最后其实都会被推到这样的GS行程之中

03:49.050 --> 03:51.050
把它进行这样的一个处理

03:51.050 --> 03:55.050
当然呢 比如说 当这个事件

03:55.050 --> 03:57.050
比如说触发以后 当然呢

03:57.050 --> 03:59.050
比如说一个按钮 点完这个 点完这个按钮以后

03:59.050 --> 04:01.050
它会进行这样的一个事件的触发

04:01.050 --> 04:03.050
但是你会发现这个按钮 它被点了以后的话

04:03.050 --> 04:06.050
它也依旧会有这样一个图形化的一个变化

04:06.050 --> 04:09.050
就是它有个被点击的这样一个感觉

04:09.050 --> 04:11.050
你可以去写一个Batch

04:11.050 --> 04:12.050
写这样一个按钮

04:12.050 --> 04:14.050
当你点完它以后的话 这个按钮

04:14.050 --> 04:16.050
它是有这个先天浏览器

04:16.050 --> 04:18.050
给它这样一个默认的样式变化的

04:18.050 --> 04:20.050
那这一块

04:20.050 --> 04:22.050
确实呢 是我们这样的浏览器

04:22.050 --> 04:24.050
GUI 渲染线手 由它来负责

04:24.050 --> 04:27.050
或者是说 只要页面发生了这样的一些

04:27.050 --> 04:30.050
显示的 比如说 显示标签

04:30.050 --> 04:32.050
或者说显示Stats 还是样式

04:32.050 --> 04:34.050
这样的一些变化来使用

04:34.050 --> 04:36.050
只要是用户能看见的这些变化的话

04:36.050 --> 04:38.050
都是由GUI选择线程

04:38.050 --> 04:40.050
由它来负责去完成的

04:40.050 --> 04:42.050
那这边我们来说一下

04:42.050 --> 04:44.050
GIS引擎线程跟GUI线程它是互赤的

04:44.050 --> 04:46.050
这个互赤是什么意思呢

04:46.050 --> 04:49.050
也就是说 当我点了一个按钮

04:49.050 --> 04:51.050
比如说

04:51.050 --> 04:53.050
就是 当我想点一个按钮

04:53.050 --> 04:54.050
但是呢

04:54.050 --> 04:56.050
我点了它之后

04:56.050 --> 04:58.050
我点了它之前 其实呢

04:58.050 --> 05:00.050
GIS里面在进行死循环

05:00.050 --> 05:01.050
那这个时候

05:01.050 --> 05:04.050
由于GIS线程在不断的去工作

05:04.050 --> 05:05.050
它始终都没有停

05:05.050 --> 05:07.050
那那个时候我去点这个按钮的时候

05:07.050 --> 05:09.050
它是没有这样的一个样式的变化了

05:09.050 --> 05:11.050
咱们可以来看一下

05:11.050 --> 05:12.050
现在呢

05:12.050 --> 05:15.050
我在这给你写个Budget B-U-T-T-O-N

05:15.050 --> 05:16.050
当然呢

05:16.050 --> 05:18.050
这里面 我就不写死循环了

05:18.050 --> 05:19.050
因为一写死循环的话

05:19.050 --> 05:22.050
这个路平软件可能它就会崩

05:22.050 --> 05:23.050
那

05:23.050 --> 05:25.050
你可以回去自己去尝试一下

05:25.050 --> 05:26.050
但我大概给你举个例子

05:26.050 --> 05:28.050
怎么来进行这样的一个测试

05:28.050 --> 05:29.050
在这写一个ID

05:29.050 --> 05:31.050
我这儿呢 来个B-U-T-N

05:31.050 --> 05:32.050
好

05:32.050 --> 05:34.050
现在呢 我握了一个O-B-T-N

05:35.050 --> 05:36.050
它等于一个

05:36.050 --> 05:39.050
Document.getElementByD

05:39.050 --> 05:40.050
OK 那在这呢

05:40.050 --> 05:41.050
我写个B-T-N

05:41.050 --> 05:43.050
我让这儿来个B-T-N

05:43.050 --> 05:45.050
O-B-T-N.onclean

05:45.050 --> 05:47.050
等于一个方式

05:47.050 --> 05:48.050
方式

05:48.050 --> 05:50.050
好 那在这里呢

05:51.050 --> 05:53.050
我点完它以后的话

05:53.050 --> 05:54.050
我可以调一个函数

05:54.050 --> 05:56.050
就是函数的叫做

05:56.050 --> 05:57.050
循环函数

05:57.050 --> 05:58.050
或者叫做

05:58.050 --> 05:59.050
死循环函数对吧

05:59.050 --> 06:00.050
在这呢

06:00.050 --> 06:02.050
可以写一个函数

06:02.050 --> 06:04.050
就叫做Dialogue

06:05.050 --> 06:07.050
好 那它里面就干点事情

06:07.050 --> 06:08.050
就写个死循环

06:08.050 --> 06:10.050
好 那这样的话

06:10.050 --> 06:12.050
我再去点完这个按钮以后的话

06:12.050 --> 06:13.050
你去点让它

06:16.700 --> 06:17.700
你去点让它

06:17.700 --> 06:19.700
或者说是

06:22.660 --> 06:23.660
好 或者说是这样

06:23.660 --> 06:24.660
我在

06:24.660 --> 06:26.660
先点让死循环之后呢

06:26.660 --> 06:27.660
我再去点这个按钮

06:27.660 --> 06:28.660
但这个按钮里面

06:28.660 --> 06:29.660
你只有什么都无所谓了

06:29.660 --> 06:31.660
那其实你执行什么的话

06:31.660 --> 06:32.660
你也输出不了了

06:32.660 --> 06:33.660
因为什么呢

06:33.660 --> 06:35.660
因为这个地方是个死循环

06:35.660 --> 06:36.660
当它一执行以后的话

06:36.660 --> 06:38.660
当它一执行以后的话

06:38.660 --> 06:41.660
那整个GS引擎处在一个这样的

06:41.660 --> 06:42.660
不断的执行

06:42.660 --> 06:44.660
这块代码的一个状态

06:44.660 --> 06:45.660
那你后面呢

06:45.660 --> 06:47.660
无论再有什么样的任务的话

06:47.660 --> 06:48.660
你怎么去操作

06:48.660 --> 06:49.660
或者说怎么去出发的话

06:49.660 --> 06:51.660
它都不会去往下执行

06:51.660 --> 06:53.660
那这就是GS引擎

06:53.660 --> 06:54.660
它是一个

06:54.660 --> 06:55.660
GS引擎的下一层

06:55.660 --> 06:56.660
它是一个单线程

06:56.660 --> 06:58.660
所带来的这样一种状况

06:58.660 --> 06:59.660
那我们之后呢

06:59.660 --> 07:00.660
会详细的去讲

07:00.660 --> 07:01.660
现在你只要去看一下

07:01.660 --> 07:02.660
状态就OK了

07:02.660 --> 07:04.660
好 那咱看一下刷新一次

07:04.660 --> 07:05.660
但这里面

07:05.660 --> 07:06.660
如果说

07:06.660 --> 07:08.660
我要给它珍惜的死一会的话

07:08.660 --> 07:10.660
咱这个视频就不用录了

07:10.660 --> 07:11.660
就崩溃了

07:11.660 --> 07:13.660
那没关系 现在我只给你看个按钮

07:13.660 --> 07:14.660
这我先写个RUN

07:14.660 --> 07:15.660
好 只给你看按钮

07:15.660 --> 07:16.660
它这样一个变化

07:16.660 --> 07:17.660
刷新一次

07:17.660 --> 07:18.660
当我点这个按钮就好了

07:18.660 --> 07:19.660
点这个按钮的时候呢

07:19.660 --> 07:20.660
这个按钮的

07:20.660 --> 07:22.660
这个阴影或者这个按钮的样式

07:22.660 --> 07:24.660
会发生这样的一些变化

07:24.660 --> 07:27.660
那其实当我在点这个按钮的时候

07:27.660 --> 07:29.660
它到底发生什么样的事呢

07:29.660 --> 07:31.660
当然它会把

07:31.660 --> 07:33.660
再开一个图啊

07:33.660 --> 07:35.660
它会把这样的一个

07:35.660 --> 07:36.660
就是事件

07:36.660 --> 07:38.660
对应了一个实现处理寒座

07:38.660 --> 07:39.660
当中的一个任务

07:39.660 --> 07:40.660
给它放到这样一个GS引擎

07:40.660 --> 07:41.660
现场里面

07:41.660 --> 07:42.660
等待它去执行

07:42.660 --> 07:43.660
当然呢

07:43.660 --> 07:45.660
除此之外的话

07:45.660 --> 07:46.660
也会由这个轮软器GUI

07:46.660 --> 07:47.660
现在现场

07:47.660 --> 07:49.660
去进行这样的一个

07:49.660 --> 07:51.660
按钮样式变化的一个处理

07:51.660 --> 07:52.660
当然呢

07:52.660 --> 07:54.660
这个任务是由

07:54.660 --> 07:56.660
谁被放到这个GS引擎

07:56.660 --> 07:57.660
呃

07:57.660 --> 07:58.660
现场之中呢

07:58.660 --> 08:00.660
其实是由这样的一个叫做

08:00.660 --> 08:01.660
叫做

08:01.660 --> 08:02.660
轮软器实现处理

08:02.660 --> 08:04.660
现场由它来把这个任务

08:04.660 --> 08:06.660
或者说由它来进行这个任务

08:06.660 --> 08:07.660
并且把这个任务

08:07.660 --> 08:09.660
给它放到这样的一个

08:09.660 --> 08:11.660
GS引擎现场之中

08:11.660 --> 08:13.660
那咱们在这里面呢

08:13.660 --> 08:15.660
我是不做过多的

08:15.660 --> 08:17.660
对其它现场的一个描述

08:17.660 --> 08:19.660
咱主要来讲这个GS引擎

08:19.660 --> 08:20.660
现场

08:20.660 --> 08:21.660
因为它呢

08:21.660 --> 08:22.660
是我们

08:22.660 --> 08:23.660
呃

08:27.660 --> 08:28.660
好那么再往下来

08:28.660 --> 08:29.660
那这个互斥的意思

08:29.660 --> 08:31.660
咱大概已经懂了对不对

08:31.660 --> 08:32.660
就是说

08:32.660 --> 08:33.660
反正当然这样

08:33.660 --> 08:35.660
这个互斥咱们可以再说一遍

08:35.660 --> 08:36.660
啊就是这个

08:36.660 --> 08:38.660
互斥这个意思就是

08:38.660 --> 08:39.660
当我点它的时候

08:39.660 --> 08:40.660
比如当我在点它之前

08:40.660 --> 08:42.660
这个死形果然已经

08:42.660 --> 08:43.660
执行了

08:43.660 --> 08:44.660
ok 它已经在执行的话

08:44.660 --> 08:45.660
那你要知道这个死形果然是

08:45.660 --> 08:46.660
进步不完的

08:46.660 --> 08:47.660
只要GS现场进步不完

08:47.660 --> 08:49.660
ok 即使我点它

08:50.660 --> 08:52.660
好了那它这样的一个

08:52.660 --> 08:53.660
样式的一个变化

08:53.660 --> 08:55.660
依旧不会有

08:55.660 --> 08:57.660
依旧不会有这样的一个变化

08:57.660 --> 08:59.660
那这就是

08:59.660 --> 09:00.660
呃

09:00.660 --> 09:02.660
它俩互斥的最后一个表现的一个状态

09:02.660 --> 09:03.660
这里面有话可以读一读啊

09:03.660 --> 09:05.660
而且我们GS在操作DOM

09:05.660 --> 09:06.660
元素的时候

09:06.660 --> 09:07.660
竟然会影响到

09:07.660 --> 09:08.660
这个

09:08.660 --> 09:10.660
呃 GUI的一个渲染结果

09:10.660 --> 09:11.660
因此呢

09:11.660 --> 09:13.660
GS现成与GUI现成

09:13.660 --> 09:14.660
其实是互斥的

09:14.660 --> 09:15.660
也就是说

09:15.660 --> 09:16.660
当GS引擎

09:16.660 --> 09:17.660
呃

09:17.660 --> 09:18.660
GS引擎现成处于一个

09:18.660 --> 09:19.660
运行状态时呢

09:19.660 --> 09:20.660
GUI渲染现成

09:20.660 --> 09:22.660
将处于一个冻结的状态

09:22.660 --> 09:23.660
呃

09:23.660 --> 09:25.660
也就是说我在干活的时候呢

09:25.660 --> 09:26.660
你怎么样呢

09:26.660 --> 09:27.660
你给我休息吧

09:27.660 --> 09:28.660
对吧

09:28.660 --> 09:29.660
好咱这样下来

09:29.660 --> 09:30.660
OK

09:30.660 --> 09:31.660
做了一个大概那几个

09:31.660 --> 09:32.660
现成的一个普技以后的话

09:32.660 --> 09:33.660
咱们现在来看一下

09:33.660 --> 09:34.660
呃

09:34.660 --> 09:35.660
GS

09:35.660 --> 09:36.660
GS引擎这个

09:36.660 --> 09:37.660
现成

09:37.660 --> 09:39.660
它的一个这样的一个执行机制啊

09:39.660 --> 09:40.660
但咱们要首先明白一点

09:40.660 --> 09:41.660
呃

09:41.660 --> 09:42.660
就是我们GS啊

09:42.660 --> 09:43.660
这个语言

09:43.660 --> 09:44.660
或者说我们

09:44.660 --> 09:45.660
GS引擎

09:45.660 --> 09:46.660
现成

09:46.660 --> 09:47.660
它就是一个

09:47.660 --> 09:48.660
单现成

09:48.660 --> 09:49.660
呃

09:49.660 --> 09:50.660
这个单现成是什么意思呢

09:50.660 --> 09:52.660
咱换句大白话来说的话

09:52.660 --> 09:53.660
就是

09:53.660 --> 09:54.660
呃

09:54.660 --> 09:55.660
这个现成呢

09:55.660 --> 09:56.660
它同一现段里面

09:56.660 --> 09:57.660
只能做一件事情

09:57.660 --> 09:58.660
其实我们六案期之中

09:58.660 --> 09:59.660
呃

09:59.660 --> 10:00.660
在做事呢

10:00.660 --> 10:01.660
基本上都是

10:01.660 --> 10:03.660
以现成为最小单

10:03.660 --> 10:04.660
以现成为最小单元的

10:04.660 --> 10:05.660
呃

10:05.660 --> 10:06.660
但有的时候我们GS

10:06.660 --> 10:07.660
这个

10:07.660 --> 10:08.660
引擎

10:08.660 --> 10:09.660
现成它既然是单现成的话

10:09.660 --> 10:10.660
那

10:10.660 --> 10:11.660
也就这么一点

10:11.660 --> 10:12.660
比如说

10:12.660 --> 10:13.660
它在做事的时候呢

10:13.660 --> 10:14.660
同一现段里面

10:14.660 --> 10:16.660
不可能去做多个事情

10:16.660 --> 10:17.660
好

10:17.660 --> 10:18.660
OK

10:18.660 --> 10:19.660
那有人会说

10:19.660 --> 10:21.660
那GS引擎

10:21.660 --> 10:22.660
单现成的话

10:22.660 --> 10:23.660
那可能处理效率

10:23.660 --> 10:24.660
它不是非常高

10:24.660 --> 10:25.660
对不对

10:25.660 --> 10:26.660
处理这样一个

10:26.660 --> 10:27.660
比如说处理这样一个

10:27.660 --> 10:28.660
前端一个业务吧

10:28.660 --> 10:29.660
或者前端这样一个逻辑弹吧

10:29.660 --> 10:30.660
呃

10:30.660 --> 10:31.660
它这样效率

10:31.660 --> 10:32.660
它不是非常高

10:32.660 --> 10:33.660
那GS引擎

10:33.660 --> 10:34.660
当初被设计的时候

10:34.660 --> 10:35.660
是多现成

10:35.660 --> 10:36.660
该有多好啊

10:36.660 --> 10:37.660
对吧

10:37.660 --> 10:38.660
那当然呢

10:38.660 --> 10:39.660
我们GS

10:39.660 --> 10:40.660
设计出来

10:40.660 --> 10:41.660
其实本质的目的呢

10:41.660 --> 10:42.660
就是为了

10:42.660 --> 10:43.660
呃

10:43.660 --> 10:44.660
用来做这样的一个用户

10:44.660 --> 10:46.660
和这个前端项目之间的一个交互

10:46.660 --> 10:47.660
它大部分的工作

10:47.660 --> 10:48.660
都是用来吹DOM

10:48.660 --> 10:50.660
那假如GS是多现成的话

10:50.660 --> 10:51.660
像修改DOM的话

10:51.660 --> 10:52.660
那另一个现成

10:52.660 --> 10:54.660
比如说想删除一个DOM

10:54.660 --> 10:55.660
那这个时候呢

10:55.660 --> 10:56.660
它们就会

10:56.660 --> 10:58.660
就是衍生出很多复杂的问题

10:58.660 --> 10:59.660
就比如说这样一个

10:59.660 --> 11:00.660
死锁的一个问题

11:00.660 --> 11:01.660
啊

11:01.660 --> 11:02.660
那好了

11:02.660 --> 11:03.660
那如果是真正回到

11:03.660 --> 11:05.660
这样一个多现成的状态的话

11:05.660 --> 11:06.660
那其实我们这个GS

11:06.660 --> 11:07.660
呃

11:07.660 --> 11:08.660
它的一个优点

11:08.660 --> 11:09.660
就推演不出来了

11:09.660 --> 11:10.660
这不就回到跟其他语言

11:10.660 --> 11:11.660
这个

11:11.660 --> 11:12.660
呃

11:12.660 --> 11:13.660
同一个尴尬的困境嘛

11:13.660 --> 11:14.660
对吧

11:14.660 --> 11:15.660
就比如说

11:15.660 --> 11:16.660
呃

11:16.660 --> 11:17.660
呃

11:17.660 --> 11:18.660
呃

11:18.660 --> 11:19.660
那如果说我这个前端项目

11:19.660 --> 11:21.660
由于现在这个前端发展得越来越快

11:21.660 --> 11:23.660
它要做的事情也越来越多

11:23.660 --> 11:24.660
尤其是

11:24.660 --> 11:26.660
这个大量的数据在进行渲染的时候

11:26.660 --> 11:27.660
或者说

11:27.660 --> 11:28.660
呃

11:28.660 --> 11:29.660
号端要给你大量的数据

11:29.660 --> 11:30.660
需要你去

11:30.660 --> 11:32.660
生成大量的这样一个标签

11:32.660 --> 11:33.660
呃

11:33.660 --> 11:34.660
那这种情况下的话

11:34.660 --> 11:36.660
我这个整个标签器

11:36.660 --> 11:37.660
如果说你是担心什么的

11:37.660 --> 11:38.660
这样一个状态的话

11:38.660 --> 11:40.660
你的计算能力不是很强的话

11:40.660 --> 11:42.660
那你依旧不能打到

11:42.660 --> 11:43.660
很好的这样一个用户体验的

11:43.660 --> 11:44.660
对吧

11:44.660 --> 11:45.660
就比如说

11:45.660 --> 11:46.660
我同时给你个10万个

11:46.660 --> 11:47.660
这样那个

11:47.660 --> 11:48.660
呃数据

11:48.660 --> 11:49.660
需要你用10万个ly

11:49.660 --> 11:50.660
来进行这样的一个渲染

11:50.660 --> 11:51.660
而且平凡的进行

11:51.660 --> 11:52.660
删除

11:52.660 --> 11:54.660
或者说进行这样的一个修改

11:54.660 --> 11:56.660
那

11:56.660 --> 11:57.660
你担心什么的话

11:57.660 --> 11:58.660
你同时一段时间

11:58.660 --> 11:59.660
能干一个活的

11:59.660 --> 12:00.660
那

12:00.660 --> 12:01.660
你想想

12:01.660 --> 12:02.660
这个这么多的数据的话

12:02.660 --> 12:03.660
你渲染起来的话

12:03.660 --> 12:04.660
一定需要花很多时间

12:04.660 --> 12:05.660
那这个时候

12:05.660 --> 12:06.660
应该怎么办呢

12:06.660 --> 12:07.660
那当然呢

12:07.660 --> 12:08.660
就对于这样的一种情况呢

12:08.660 --> 12:09.660
呃

12:09.660 --> 12:10.660
我们现在

12:10.660 --> 12:11.660
其实也有很多

12:11.660 --> 12:12.660
好的方法来处理

12:12.660 --> 12:13.660
呃

12:13.660 --> 12:14.660
那就比如说

12:14.660 --> 12:15.660
呃

12:15.660 --> 12:16.660
我们到后期

12:16.660 --> 12:17.660
尤其在我们这个

12:17.660 --> 12:18.660
进线班之中呢

12:18.660 --> 12:19.660
会讲这个优异

12:19.660 --> 12:20.660
那

12:20.660 --> 12:21.660
讲到优异呢

12:21.660 --> 12:22.660
会讲这样弄的JS

12:22.660 --> 12:23.660
那当然

12:23.660 --> 12:24.660
那现在我们在

12:24.660 --> 12:25.660
真正写相的时候

12:25.660 --> 12:26.660
都追逐前后端分离

12:26.660 --> 12:27.660
因为这样的情况下

12:27.660 --> 12:28.660
效率是最高的

12:28.660 --> 12:29.660
那当然呢

12:29.660 --> 12:31.660
我们为了保证同学们

12:31.660 --> 12:32.660
有这样的一个

12:32.660 --> 12:33.660
整这样的一个

12:33.660 --> 12:34.660
开发的一个概念

12:34.660 --> 12:35.660
并且呢

12:35.660 --> 12:37.660
希望你能真正的

12:37.660 --> 12:38.660
去了解这样的一个

12:38.660 --> 12:39.660
前端

12:39.660 --> 12:40.660
适用的去了解

12:40.660 --> 12:41.660
就是咱必然的

12:41.660 --> 12:42.660
得去知道

12:42.660 --> 12:43.660
一些后台的一些知识

12:44.660 --> 12:45.660
那尤其是

12:45.660 --> 12:46.660
针对于VOE

12:46.660 --> 12:47.660
或者说针对于

12:47.660 --> 12:49.660
这种大量数据渲染

12:49.660 --> 12:50.660
对吧

12:50.660 --> 12:51.660
这样的一个幼灵鱼

12:51.660 --> 12:53.660
那我们有一个技术

12:53.660 --> 12:54.660
叫做SSR

12:54.660 --> 12:55.660
就是浮气渲染

12:55.660 --> 12:57.660
浮端渲染技术

12:57.660 --> 12:58.660
可以通过这样的技术呢

12:58.660 --> 12:59.660
进行

12:59.660 --> 13:00.660
然后在后台

13:00.660 --> 13:01.660
去

13:01.660 --> 13:02.660
呃

13:02.660 --> 13:03.660
进行这样的一个

13:03.660 --> 13:04.660
大量数据的一个

13:04.660 --> 13:05.660
计算

13:05.660 --> 13:06.660
计算以后呢

13:06.660 --> 13:07.660
我可以呢

13:07.660 --> 13:08.660
生成这样的一个标签

13:08.660 --> 13:09.660
或者说

13:09.660 --> 13:10.660
生成这样的一个

13:10.660 --> 13:11.660
组圈

13:11.660 --> 13:12.660
形式的一个组件

13:12.660 --> 13:13.660
我们在前端呢

13:13.660 --> 13:14.660
再把这个组架

13:14.660 --> 13:15.660
给它收成到

13:15.660 --> 13:16.660
这个页面里面来

13:16.660 --> 13:17.660
那这样情况下的话

13:17.660 --> 13:18.660
VOE跟NodeGIS

13:18.660 --> 13:19.660
相互来配合的话

13:19.660 --> 13:20.660
就完全能搞得

13:20.660 --> 13:21.660
这种大量数据

13:21.660 --> 13:22.660
计算的一个

13:22.660 --> 13:23.660
呃

13:23.660 --> 13:24.660
情景

13:24.660 --> 13:25.660
好

13:25.660 --> 13:26.660
那这样的话

13:26.660 --> 13:27.660
其实

13:27.660 --> 13:28.660
我们GIS

13:28.660 --> 13:29.660
由于有了这个NodeGIS

13:29.660 --> 13:30.660
这样前端的一个配合

13:30.660 --> 13:31.660
由于有了这个VOE

13:31.660 --> 13:32.660
这种SSR

13:32.660 --> 13:33.660
这样的一个技术的话

13:33.660 --> 13:34.660
呃

13:34.660 --> 13:35.660
很多情况下的话

13:35.660 --> 13:37.660
我们靠我们这样的一个

13:37.660 --> 13:38.660
GS圆

13:38.660 --> 13:39.660
就是能完成

13:39.660 --> 13:40.660
很多很多

13:40.660 --> 13:41.660
好

13:41.660 --> 13:42.660
整战这样的事情

13:42.660 --> 13:43.660
整战这样的事情

13:43.660 --> 13:44.660
好

13:44.660 --> 13:45.660
那OK

13:45.660 --> 13:46.660
那到这的话

13:46.660 --> 13:47.660
其实我们已经大概

13:47.660 --> 13:48.660
把整个前面的

13:48.660 --> 13:49.660
就是已经

13:49.660 --> 13:50.660
普及完了

13:50.660 --> 13:51.660
那接下来呢

13:51.660 --> 13:52.660
我们又开始

13:52.660 --> 13:53.660
正式的来

13:53.660 --> 13:54.660
来说说我们今天的一个重点

13:54.660 --> 13:55.660
就是

13:55.660 --> 13:56.660
呃GS引擎

13:56.660 --> 13:57.660
现成的吧

13:57.660 --> 13:58.660
它的一个执行机制

13:58.660 --> 13:59.660
到底是什么样子的

13:59.660 --> 14:00.660
好

14:00.660 --> 14:01.660
好

14:01.660 --> 14:02.660
咱看一下

14:02.660 --> 14:03.660
呃

14:03.660 --> 14:04.660
那么JASK

14:04.660 --> 14:05.660
是基于单线程运行的

14:05.660 --> 14:06.660
同时呢

14:06.660 --> 14:07.660
又是可以异步执行的

14:07.660 --> 14:08.660
呃

14:08.660 --> 14:09.660
这个异步呢

14:09.660 --> 14:10.660
我们计算机中的

14:10.660 --> 14:11.660
同步和异步的话

14:11.660 --> 14:12.660
跟我们人类中的

14:12.660 --> 14:13.660
同步异步照相反

14:13.660 --> 14:14.660
我们计算机中的异步

14:14.660 --> 14:15.660
呃

14:15.660 --> 14:16.660
其实就是同一时间段里面

14:16.660 --> 14:17.660
你可以干

14:17.660 --> 14:18.660
两个事情了

14:18.660 --> 14:19.660
啊

14:19.660 --> 14:20.660
那同步呢就是

14:20.660 --> 14:21.660
同一同一时间段里面

14:21.660 --> 14:22.660
只能干一件事情

14:22.660 --> 14:23.660
那咱们刚才

14:23.660 --> 14:24.660
其实说了

14:24.660 --> 14:25.660
这个

14:25.660 --> 14:26.660
JASK引擎

14:26.660 --> 14:27.660
这个现成

14:27.660 --> 14:28.660
它不就是

14:28.660 --> 14:29.660
这个单线程吗

14:29.660 --> 14:30.660
对吧

14:30.660 --> 14:31.660
为什么

14:31.660 --> 14:32.660
这里面又设计到了一个叫做

14:32.660 --> 14:34.660
可以异步执行呢

14:34.660 --> 14:35.660
那那不岂不就是说

14:35.660 --> 14:37.660
把之前的这样的一个情况

14:37.660 --> 14:38.660
推翻了

14:38.660 --> 14:39.660
可以同一时间段

14:39.660 --> 14:40.660
就快两件事了吗

14:40.660 --> 14:41.660
啊

14:41.660 --> 14:42.660
ok 那这一本呢

14:42.660 --> 14:43.660
你先双异步照

14:43.660 --> 14:44.660
咱们要

14:44.660 --> 14:45.660
做一个后续的

14:45.660 --> 14:46.660
一个身份了解之后

14:46.660 --> 14:47.660
我们就理解怎么回事了

14:47.660 --> 14:48.660
那咱再来读

14:48.660 --> 14:50.660
说一般来讲

14:50.660 --> 14:51.660
这种

14:51.660 --> 14:52.660
既是单线程

14:52.660 --> 14:54.660
又是异步的语言

14:54.660 --> 14:55.660
都是基于时间来驱动的

14:55.660 --> 14:56.660
恰好乱性的

14:56.660 --> 14:57.660
就给予这个JASK

14:57.660 --> 14:58.660
提供了这么一个环境

14:58.660 --> 14:59.660
啊

14:59.660 --> 15:00.660
那这个环境呢

15:00.660 --> 15:01.660
其实

15:01.660 --> 15:02.660
呃

15:02.660 --> 15:03.660
除了是这个JASK引擎

15:03.660 --> 15:04.660
这个现成的

15:04.660 --> 15:05.660
一个运行机制以外的话

15:05.660 --> 15:06.660
其实还有

15:06.660 --> 15:07.660
其他的这样的

15:07.660 --> 15:08.660
配合

15:08.660 --> 15:09.660
所以说那最后

15:09.660 --> 15:10.660
所表现出来的状态呢

15:10.660 --> 15:11.660
就是

15:11.660 --> 15:12.660
JAS引擎现成中

15:12.660 --> 15:13.660
这样的一个主线程

15:13.660 --> 15:14.660
它是单线程的

15:14.660 --> 15:15.660
要说它确实

15:15.660 --> 15:16.660
一个旋转有没有

15:16.660 --> 15:17.660
只能干一件事情

15:17.660 --> 15:18.660
但是可以异步

15:18.660 --> 15:19.660
进行这样的一些

15:19.660 --> 15:20.660
操作的话

15:20.660 --> 15:21.660
其实是由于其他眼前

15:21.660 --> 15:23.660
是由于其他现成

15:23.660 --> 15:24.660
这样的一个介入

15:24.660 --> 15:25.660
或者说其他现成

15:25.660 --> 15:26.660
这样的一个辅助

15:26.660 --> 15:27.660
最后才呈现出来

15:27.660 --> 15:28.660
我们JAS

15:28.660 --> 15:29.660
在乱性中运行的时候

15:29.660 --> 15:30.660
啊

15:30.660 --> 15:31.660
既可以同步

15:31.660 --> 15:32.660
又可以异步

15:32.660 --> 15:33.660
那在这呢

15:33.660 --> 15:34.660
我给你看一个图啊

15:34.660 --> 15:35.660
好

15:35.660 --> 15:36.660
那这一般呢

15:36.660 --> 15:37.660
它的一个描述啊

15:37.660 --> 15:38.660
就是我们可以把

15:38.660 --> 15:39.660
每个函数

15:39.660 --> 15:40.660
或者说把每个

15:40.660 --> 15:41.660
真正要执行的代码

15:41.660 --> 15:42.660
当做一个任务

15:42.660 --> 15:43.660
来放到这个

15:43.660 --> 15:45.660
来进行这样的一个

15:45.660 --> 15:46.660
就是

15:47.660 --> 15:48.660
来进行这样的一个

15:48.660 --> 15:50.660
图的一个流程的话

15:50.660 --> 15:51.660
一个

15:51.660 --> 15:52.660
这么说吧

15:52.660 --> 15:53.660
我们可以把这个

15:53.660 --> 15:54.660
每个函数

15:54.660 --> 15:55.660
和每个要执行的代码

15:55.660 --> 15:56.660
对吧

15:56.660 --> 15:57.660
当做的是一个任务

15:57.660 --> 15:58.660
那既然是当做一个任务的话

15:58.660 --> 15:59.660
好了

15:59.660 --> 16:00.660
那我们来看一下

16:00.660 --> 16:01.660
它这样的一个执行机制啊

16:01.660 --> 16:02.660
这种任务的一个执行机制

16:02.660 --> 16:03.660
它到底有什么样子啊

16:03.660 --> 16:04.660
首先

16:04.660 --> 16:05.660
如果说你这个任务

16:05.660 --> 16:06.660
这是一个普通

16:06.660 --> 16:07.660
还是说这个执行

16:07.660 --> 16:08.660
它不是一道

16:08.660 --> 16:09.660
那些异部的一些操作

16:09.660 --> 16:10.660
就比如说

16:10.660 --> 16:11.660
它不是一道

16:11.660 --> 16:12.660
事件的出发

16:12.660 --> 16:13.660
它不是一道

16:13.660 --> 16:14.660
低人气

16:14.660 --> 16:15.660
它不是一道

16:15.660 --> 16:16.660
这样的一个网络的一个请求

16:16.660 --> 16:17.660
那这样的话

16:17.660 --> 16:18.660
好了

16:18.660 --> 16:19.660
那你这个普通的任务

16:19.660 --> 16:20.660
任务呢

16:20.660 --> 16:21.660
其实它就是一个同步的任务

16:21.660 --> 16:22.660
那同步的任务呢

16:22.660 --> 16:23.660
放到哪呢

16:23.660 --> 16:24.660
好了

16:24.660 --> 16:25.660
它要放到

16:25.660 --> 16:26.660
这个看

16:26.660 --> 16:27.660
从这开始啊

16:27.660 --> 16:28.660
同步任务

16:28.660 --> 16:29.660
要放到这个主线程之中

16:29.660 --> 16:30.660
那主线程呢

16:30.660 --> 16:31.660
其实里面有个人叫做

16:31.660 --> 16:32.660
执行站

16:32.660 --> 16:33.660
咱一会儿说话

16:33.660 --> 16:34.660
那主线程呢

16:34.660 --> 16:35.660
是单线程的

16:35.660 --> 16:36.660
那如果说你这个任务

16:36.660 --> 16:37.660
一个一个你给我的话

16:37.660 --> 16:38.660
那我必须得

16:38.660 --> 16:39.660
一个一个去执行

16:39.660 --> 16:40.660
对吧

16:40.660 --> 16:41.660
那当一个执行不完的话

16:41.660 --> 16:42.660
另外一个任务

16:42.660 --> 16:43.660
就执行不了了

16:43.660 --> 16:44.660
好

16:44.660 --> 16:45.660
那这个主线程

16:45.660 --> 16:46.660
里面有很多任务

16:46.660 --> 16:47.660
好

16:47.660 --> 16:48.660
当这个系列任务

16:48.660 --> 16:49.660
一个一个都执行完毕以后

16:49.660 --> 16:50.660
它会怎么样呢

16:50.660 --> 16:51.660
它会去看一下

16:51.660 --> 16:52.660
你看这啊

16:52.660 --> 16:53.660
叫做独取任务

16:53.660 --> 16:54.660
对列中的结果

16:54.660 --> 16:55.660
那什么是任务对列呢

16:55.660 --> 16:56.660
那咱看一下

16:56.660 --> 16:57.660
这啊

16:57.660 --> 16:58.660
就是如果说

16:58.660 --> 16:59.660
一开始你这个任务

16:59.660 --> 17:00.660
它不是一个同步任务

17:00.660 --> 17:01.660
而是一个异部任务的话

17:01.660 --> 17:02.660
那这个异部任务呢

17:02.660 --> 17:04.660
就一万天一天报之中

17:04.660 --> 17:05.660
来先注册一下

17:05.660 --> 17:07.660
有这样的一个函数

17:07.660 --> 17:08.660
之后呢

17:08.660 --> 17:09.660
可能要在某个时间段里面

17:09.660 --> 17:10.660
被触发

17:10.660 --> 17:11.660
那好了

17:11.660 --> 17:13.660
那在这注册完以后呢

17:13.660 --> 17:14.660
等到真正

17:14.660 --> 17:15.660
就比如说

17:15.660 --> 17:16.660
定任器

17:16.660 --> 17:17.660
它那个延迟时间到了

17:17.660 --> 17:18.660
这个函数

17:18.660 --> 17:19.660
或者说这个任务

17:19.660 --> 17:20.660
要被真正的去执行了

17:20.660 --> 17:21.660
或者说

17:21.660 --> 17:23.660
发送网络请求的时候呢

17:23.660 --> 17:24.660
那

17:24.660 --> 17:25.660
这个时候就真正反完

17:25.660 --> 17:26.660
给你到天多了

17:26.660 --> 17:27.660
那你也真正要

17:27.660 --> 17:28.660
就使用这个回到函数呢

17:28.660 --> 17:29.660
那那个时候呢

17:29.660 --> 17:30.660
会把这样的一个函数

17:30.660 --> 17:31.660
或者说把这样的一个任务

17:31.660 --> 17:32.660
放到这样的一个叫

17:32.660 --> 17:34.660
英文的quip里面

17:34.660 --> 17:35.660
就是放到这个

17:35.660 --> 17:36.660
时间对练里面

17:36.660 --> 17:38.660
但是对练有个概念呢

17:38.660 --> 17:39.660
就是

17:39.660 --> 17:41.660
叫做先进先从

17:41.660 --> 17:42.660
就比如说

17:42.660 --> 17:43.660
有一个门

17:43.660 --> 17:44.660
好了

17:44.660 --> 17:45.660
我们从这个门口开始

17:45.660 --> 17:47.660
123456号排队

17:47.660 --> 17:48.660
好了那先排的人

17:48.660 --> 17:49.660
只能是先往头处理

17:49.660 --> 17:50.660
对不对

17:50.660 --> 17:51.660
就比如说12345678号

17:51.660 --> 17:52.660
好了

17:52.660 --> 17:53.660
那先出门的话

17:53.660 --> 17:54.660
只能是1号吧

17:54.660 --> 17:55.660
对吧

17:55.660 --> 17:56.660
那你排的时候呢

17:56.660 --> 17:57.660
你确实你也是从1

17:57.660 --> 17:58.660
开始来先排的

17:58.660 --> 17:59.660
反正这样不一样

17:59.660 --> 18:00.660
这样的一个

18:00.660 --> 18:02.660
概念叫做先进后处

18:02.660 --> 18:03.660
对不对

18:03.660 --> 18:05.660
那我们这一块知识呢

18:05.660 --> 18:07.660
是一个加深那个知识

18:07.660 --> 18:08.660
很多情况的话

18:08.660 --> 18:09.660
如果说

18:09.660 --> 18:10.660
你听不太懂的话

18:10.660 --> 18:11.660
或者说你听得一致半解的话

18:11.660 --> 18:12.660
我建议啊

18:12.660 --> 18:14.660
我建议你回到我们这样的一个

18:14.660 --> 18:15.660
独一

18:15.660 --> 18:16.660
你回到我们这样的一个

18:16.660 --> 18:17.660
同学课堂上

18:17.660 --> 18:19.660
去来搜索一下独一

18:19.660 --> 18:20.660
我们独一呢

18:20.660 --> 18:21.660
有一个课手

18:21.660 --> 18:23.660
叫做just curbing精英课堂

18:23.660 --> 18:24.660
在那里面呢

18:24.660 --> 18:26.660
我们基本上有很多个学生

18:26.660 --> 18:27.660
就是

18:27.660 --> 18:28.660
我们每个月吧

18:28.660 --> 18:29.660
基本上有好几千名学生吧

18:29.660 --> 18:32.660
再进行这样的一个观看和学习

18:32.660 --> 18:33.660
我们也是这个

18:33.660 --> 18:34.660
整个同学平台上

18:34.660 --> 18:35.660
或者说等

18:35.660 --> 18:37.660
整个同学平台前端上面

18:37.660 --> 18:39.660
全中最高的这样的一个机构

18:39.660 --> 18:41.660
那我们老师这家园课呢

18:41.660 --> 18:42.660
前几例课吧

18:42.660 --> 18:44.660
也是很深入的

18:44.660 --> 18:45.660
那如果说你这个技术不太好的话

18:45.660 --> 18:47.660
我就不建议你先听听那样的课

18:47.660 --> 18:48.660
之后再回到我们这一边来

18:48.660 --> 18:49.660
来听我们这样的课

18:49.660 --> 18:50.660
因为我们这一块呢

18:50.660 --> 18:52.660
是加深的一个过程

18:52.660 --> 18:54.660
好 那咱们这样

18:54.660 --> 18:57.660
那咱们再回到这个图里面来吧

18:58.660 --> 19:00.660
就是这个图呢

19:01.660 --> 19:02.660
到这就是好

19:02.660 --> 19:03.660
把那些回到寒树呢

19:03.660 --> 19:04.660
放到这个任务里面来

19:04.660 --> 19:06.660
放到任务里面来之后的话

19:06.660 --> 19:07.660
ok 那咱们说了这个

19:07.660 --> 19:09.660
主线程序这些课的任务

19:09.660 --> 19:10.660
全执行完了以后的话

19:10.660 --> 19:12.660
他会去看一下你这个

19:12.660 --> 19:14.660
时间对列你们有没有其他任务

19:14.660 --> 19:15.660
如果有的话

19:15.660 --> 19:16.660
好 给你拿出来就执行

19:16.660 --> 19:17.660
如果你有的话

19:17.660 --> 19:18.660
给你拿出来就执行

19:18.660 --> 19:20.660
ok 那这个过程

19:20.660 --> 19:22.660
就是当任务对列

19:22.660 --> 19:23.660
就是当这个

19:23.660 --> 19:24.660
主线程序中的任务

19:24.660 --> 19:26.660
全部都执行完以后的话

19:26.660 --> 19:27.660
他就不断的来看

19:27.660 --> 19:29.660
任务对列里面有没有任务

19:29.660 --> 19:30.660
那这个过程呢

19:30.660 --> 19:31.660
叫做事件轮曲

19:31.660 --> 19:32.660
叫event loop

19:32.660 --> 19:33.660
这个我们以后

19:33.660 --> 19:34.660
我们之后呢

19:34.660 --> 19:36.660
也会详细的来说一说

19:36.660 --> 19:37.660
那这一门呢

19:37.660 --> 19:38.660
其实就衍生出来

19:38.660 --> 19:39.660
一个这样的一个时间机制

19:39.660 --> 19:40.660
再来看一下

19:40.660 --> 19:41.660
就是按照导图

19:41.660 --> 19:43.660
这样的一个内容的描述的话

19:43.660 --> 19:44.660
其实就是

19:44.660 --> 19:45.660
我们这个GS中

19:45.660 --> 19:47.660
在执行任何一个功能的话

19:47.660 --> 19:48.660
其实只要

19:48.660 --> 19:49.660
只要GS的话

19:49.660 --> 19:51.660
无非就分两种任务

19:51.660 --> 19:52.660
一种是同步

19:52.660 --> 19:53.660
一种是异步

19:53.660 --> 19:54.660
那同步和任务呢

19:54.660 --> 19:55.660
其实会

19:55.660 --> 19:56.660
异步呢

19:56.660 --> 19:57.660
分别会

19:57.660 --> 19:59.660
进到两种不同的执行场所

19:59.660 --> 20:00.660
那同步呢

20:00.660 --> 20:02.660
是进入到主线程序中

20:02.660 --> 20:03.660
异步呢

20:03.660 --> 20:04.660
是先进入到这样的

20:04.660 --> 20:05.660
event table之中

20:05.660 --> 20:06.660
而且在里面出色寒兽

20:06.660 --> 20:08.660
那当指定的事情完成

20:08.660 --> 20:09.660
这个指定的事情

20:09.660 --> 20:10.660
就我们刚才说的

20:10.660 --> 20:11.660
比如说这个电源器

20:11.660 --> 20:12.660
要延迟多少毫秒

20:12.660 --> 20:13.660
对吧

20:13.660 --> 20:15.660
去出发这样的一个寒兽

20:15.660 --> 20:16.660
或者说这个

20:16.660 --> 20:17.660
当你像弧端

20:17.660 --> 20:18.660
发送完数据

20:18.660 --> 20:19.660
请留以后

20:19.660 --> 20:20.660
这个数据回来了

20:20.660 --> 20:21.660
对吧

20:21.660 --> 20:22.660
来出发这样的回教寒兽

20:22.660 --> 20:23.660
并且呢

20:23.660 --> 20:24.660
还有一个

20:24.660 --> 20:26.660
当被用户来出发的时候呢

20:26.660 --> 20:27.660
好了

20:27.660 --> 20:28.660
他也会啊

20:28.660 --> 20:30.660
去把这样的一个

20:30.660 --> 20:33.660
他去把这样的一个event table之中

20:33.660 --> 20:34.660
所测过的这样的寒兽

20:34.660 --> 20:36.660
放到这个任务队内里面来

20:36.660 --> 20:37.660
那主线程

20:37.660 --> 20:39.660
主线程的你们的任务

20:39.660 --> 20:40.660
当指定全部

20:40.660 --> 20:41.660
当全部都指定完毕以后的话

20:41.660 --> 20:42.660
他会来看一下

20:42.660 --> 20:43.660
这个新队里面

20:43.660 --> 20:45.660
到底有没有对应的

20:45.660 --> 20:46.660
这样的一个任务

20:46.660 --> 20:47.660
如果有的话

20:47.660 --> 20:48.660
不

20:48.660 --> 20:49.660
不是对应的任务

20:49.660 --> 20:50.660
就是看一下

20:50.660 --> 20:51.660
你这个任务队里面

20:51.660 --> 20:52.660
到底有没有任务

20:52.660 --> 20:53.660
如果有的话

20:53.660 --> 20:54.660
他一个一个按顺序

20:54.660 --> 20:55.660
对吧

20:55.660 --> 20:56.660
拿出来去执行

20:56.660 --> 20:57.660
那整个

20:57.660 --> 20:58.660
这样的一个重复

20:58.660 --> 21:01.660
去看任务队里面这样的一个过程呢

21:01.660 --> 21:02.660
就形成我们

21:02.660 --> 21:03.660
长熟的一个event log

21:03.660 --> 21:04.660
这个

21:04.660 --> 21:05.660
刚才我们已经说了

21:05.660 --> 21:06.660
好

21:06.660 --> 21:07.660
咱咱往下来看一下吧

21:07.660 --> 21:08.660
那同步任务的话

21:08.660 --> 21:09.660
咱们具体来

21:09.660 --> 21:11.660
就是通过代码

21:11.660 --> 21:12.660
来进行这样一个

21:12.660 --> 21:13.660
凶的讲解

21:13.660 --> 21:14.660
什么叫同步任务呢

21:14.660 --> 21:15.660
就是除了我所说的

21:15.660 --> 21:16.660
那个阿迦克斯

21:16.660 --> 21:17.660
网络请求

21:17.660 --> 21:18.660
对吧

21:18.660 --> 21:19.660
异布的网络请求

21:19.660 --> 21:20.660
除了网络请求

21:20.660 --> 21:21.660
除了那种

21:21.660 --> 21:22.660
跟人欽

21:22.660 --> 21:23.660
那种实际的

21:23.660 --> 21:24.660
一个出发以外的话

21:24.660 --> 21:25.660
剩下所有的任务呢

21:25.660 --> 21:26.660
都叫做同步任务

21:26.660 --> 21:27.660
比如说这个寒兽的执行

21:27.660 --> 21:28.660
它就是一个任务

21:28.660 --> 21:29.660
那寒兽执行

21:29.660 --> 21:30.660
它就是一种

21:30.660 --> 21:31.660
同步的任务

21:31.660 --> 21:32.660
那咱来看一下

21:32.660 --> 21:34.660
现在呢

21:34.660 --> 21:36.660
我在这

21:36.660 --> 21:37.660
我给你写一个寒兽

21:37.660 --> 21:38.660
叫做Alcher

21:38.660 --> 21:40.660
Boyotr

21:40.660 --> 21:41.660
在这呢

21:41.660 --> 21:42.660
我给你写一个层次

21:42.660 --> 21:43.660
叫Ot

21:43.660 --> 21:44.660
好

21:44.660 --> 21:45.660
在里面写一个方式

21:45.660 --> 21:46.660
叫做Inner

21:46.660 --> 21:48.660
Inner

21:48.660 --> 21:49.660
好

21:49.660 --> 21:50.660
Inner

21:50.660 --> 21:51.660
那在这呢

21:51.660 --> 21:52.660
It吧

21:52.660 --> 21:53.660
It

21:53.660 --> 21:54.660
好

21:54.660 --> 21:55.660
那我在这个里面

21:55.660 --> 21:56.660
去输入一句话

21:56.660 --> 21:57.660
就要cancel.log一下

21:57.660 --> 21:58.660
好

21:58.660 --> 21:59.660
CON

21:59.660 --> 22:00.660
少个N

22:00.660 --> 22:01.660
CON

22:01.660 --> 22:02.660
在这呢

22:02.660 --> 22:03.660
我来写一个

22:03.660 --> 22:04.660
输入IT吧

22:04.660 --> 22:05.660
好

22:05.660 --> 22:06.660
那在下面呢

22:06.660 --> 22:08.660
我来执行这个Inner

22:08.660 --> 22:09.660
我刷一个20

22:09.660 --> 22:10.660
那在这呢

22:10.660 --> 22:11.660
我再去

22:11.660 --> 22:13.660
来输出一下

22:13.660 --> 22:14.660
这样一个Ot

22:16.660 --> 22:17.660
好

22:17.660 --> 22:18.660
那在外側呢

22:18.660 --> 22:19.660
我再来一个Ot

22:19.660 --> 22:20.660
好

22:20.660 --> 22:21.660
当我这个寒兽

22:21.660 --> 22:22.660
在执行的时候呢

22:22.660 --> 22:23.660
实际上呢

22:23.660 --> 22:24.660
其实我给你看一下

22:24.660 --> 22:25.660
它是有这样的一个

22:25.660 --> 22:26.660
调用站的

22:26.660 --> 22:27.660
我得把每次好

22:27.660 --> 22:28.660
再帮我算一下

22:28.660 --> 22:29.660
刷新一下

22:29.660 --> 22:30.660
看一眼

22:31.660 --> 22:32.660
OK

22:32.660 --> 22:33.660
这里面叫调用站

22:33.660 --> 22:34.660
这个调用站里面

22:34.660 --> 22:35.660
其实呢

22:35.660 --> 22:36.660
其实是有这样的一个

22:36.660 --> 22:38.660
就是寒兽的一个描述的

22:38.660 --> 22:39.660
那我在这吧

22:39.660 --> 22:40.660
我在这给你写

22:40.660 --> 22:41.660
第八个来看一下

22:41.660 --> 22:42.660
你看看这个Inner

22:42.660 --> 22:44.660
它这样的一个调用站

22:44.660 --> 22:46.660
到底是什么用事

22:46.660 --> 22:47.660
好

22:47.660 --> 22:48.660
刷新意思

22:48.660 --> 22:49.660
但是这里面呢

22:50.660 --> 22:51.660
等咱们讲

22:51.660 --> 22:52.660
Dance的时候呢

22:52.660 --> 22:53.660
还会想起来说出

22:53.660 --> 22:54.660
这一块

22:54.660 --> 22:55.660
但你先来看一下

22:55.660 --> 22:56.660
刷新字

22:57.660 --> 22:58.660
OK

22:58.660 --> 22:59.660
这个调用站对吧

22:59.660 --> 23:00.660
它会

23:00.660 --> 23:01.660
这个调用站

23:01.660 --> 23:02.660
其实就是

23:02.660 --> 23:03.660
或者说叫做实行站

23:03.660 --> 23:04.660
这个支援站里面呢

23:04.660 --> 23:05.660
就有这个Inner

23:05.660 --> 23:06.660
和Outer对不对

23:06.660 --> 23:07.660
那Inner和Outer呢

23:07.660 --> 23:09.660
是谁先出发

23:09.660 --> 23:10.660
那这个Inner和Outer呢

23:10.660 --> 23:11.660
是谁先

23:11.660 --> 23:12.660
真的去支援完呢

23:12.660 --> 23:13.660
所以还是这个Inner

23:13.660 --> 23:14.660
他先支援完呢

23:14.660 --> 23:15.660
当Inner支援完以后的话

23:15.660 --> 23:17.660
Outer他再去支援完

23:17.660 --> 23:18.660
那OK

23:19.660 --> 23:20.660
我们会发现

23:21.660 --> 23:22.660
这个

23:22.660 --> 23:23.660
整个这个

23:23.660 --> 23:24.660
每个函数

23:24.660 --> 23:25.660
都当作一个任务

23:25.660 --> 23:26.660
来执行的话

23:26.660 --> 23:27.660
好了

23:27.660 --> 23:28.660
那这里面必须的

23:28.660 --> 23:29.660
说一说到

23:29.660 --> 23:30.660
刚才这个一个概念

23:30.660 --> 23:31.660
叫做这个支援站

23:31.660 --> 23:32.660
对不对

23:32.660 --> 23:33.660
那支援站

23:33.660 --> 23:34.660
它到底是什么一个东西呢

23:34.660 --> 23:35.660
它存在Inner呢

23:35.660 --> 23:36.660
咱来看一下

23:37.660 --> 23:38.660
这边我来用文字

23:38.660 --> 23:39.660
先给你来描述一下

23:39.660 --> 23:40.660
首先呢

23:40.660 --> 23:41.660
就是咱把

23:41.660 --> 23:42.660
刚才这个过程

23:42.660 --> 23:44.660
给你先抛弃一次吧

23:44.660 --> 23:45.660
这边呢

23:45.660 --> 23:46.660
我订了两个函数

23:46.660 --> 23:47.660
当然

23:47.660 --> 23:48.660
第一个函数呢

23:48.660 --> 23:49.660
我们并不是

23:49.660 --> 23:50.660
把它当作一个任务

23:50.660 --> 23:51.660
只能执行的时候呢

23:51.660 --> 23:53.660
才被当作是一个任务

23:53.660 --> 23:54.660
那我们先是来支援这个Outer

23:54.660 --> 23:56.660
那Outer在支援的时候呢

23:56.660 --> 23:57.660
他定义了他对不对

23:57.660 --> 23:58.660
但你要知道

23:58.660 --> 23:59.660
Outer在支援之前的话

23:59.660 --> 24:00.660
是有很多

24:00.660 --> 24:01.660
准备的一个工作呢

24:01.660 --> 24:02.660
就比如说预备意

24:02.660 --> 24:03.660
预备意

24:03.660 --> 24:04.660
那预备意的话

24:04.660 --> 24:05.660
是什么意思的话

24:05.660 --> 24:06.660
你不懂的话

24:06.660 --> 24:07.660
你也可以去

24:07.660 --> 24:08.660
搜这个在Twitter

24:08.660 --> 24:09.660
搜独一

24:09.660 --> 24:10.660
来看一下我们的GS进行课堂

24:10.660 --> 24:11.660
我们那个里面

24:11.660 --> 24:12.660
想去的就讲了

24:12.660 --> 24:13.660
预备意的这样的几个过程

24:13.660 --> 24:14.660
好

24:14.660 --> 24:15.660
那

24:16.660 --> 24:18.660
首先他建立预备意的过程

24:18.660 --> 24:19.660
那咱们看一下吧

24:19.660 --> 24:20.660
如果说我来描述的话

24:20.660 --> 24:21.660
就是

24:21.660 --> 24:22.660
我们每个任务

24:22.660 --> 24:23.660
真正

24:23.660 --> 24:24.660
尤其是同不任务

24:24.660 --> 24:25.660
当然那其实

24:25.660 --> 24:26.660
预备任务之后

24:26.660 --> 24:27.660
也会被放到这样的

24:27.660 --> 24:28.660
一个执行站

24:28.660 --> 24:29.660
去执行

24:29.660 --> 24:30.660
那咱们咱们

24:30.660 --> 24:31.660
咱们这边先指说

24:31.660 --> 24:32.660
同不任务

24:32.660 --> 24:33.660
比如说每个这种

24:33.660 --> 24:34.660
函数执行

24:34.660 --> 24:35.660
或者说

24:35.660 --> 24:36.660
每个这样的一个任务

24:36.660 --> 24:37.660
他都是会被

24:37.660 --> 24:39.660
放到这个执行站之中的

24:39.660 --> 24:40.660
那执行站

24:40.660 --> 24:41.660
一开始的时候

24:41.660 --> 24:42.660
当你没有代码

24:42.660 --> 24:43.660
或者说没有函数

24:43.660 --> 24:44.660
来执行的时候

24:44.660 --> 24:45.660
它里面就是空的

24:45.660 --> 24:46.660
OK

24:46.660 --> 24:47.660
那如果说

24:47.660 --> 24:48.660
这边

24:49.660 --> 24:50.660
我换一个参

24:50.660 --> 24:51.660
他说

24:51.660 --> 24:52.660
这边FO

24:52.660 --> 24:54.660
你给他看做

24:54.660 --> 24:55.660
这样吧

24:55.660 --> 24:56.660
他写FO吧

24:56.660 --> 24:57.660
不给名

24:57.660 --> 24:58.660
FO

24:58.660 --> 24:59.660
这边我给你写个bar

24:59.660 --> 25:00.660
比2

25:01.660 --> 25:02.660
好

25:02.660 --> 25:03.660
那这样的话就是

25:03.660 --> 25:04.660
当这个函数

25:04.660 --> 25:05.660
在真正执行的时候

25:08.660 --> 25:09.660
一开始的时候

25:09.660 --> 25:10.660
执行站是空的

25:10.660 --> 25:11.660
当这个函数

25:11.660 --> 25:12.660
在执行的时候

25:12.660 --> 25:13.660
你看

25:13.660 --> 25:14.660
执行站

25:14.660 --> 25:15.660
执行站

25:15.660 --> 25:16.660
它就相当于

25:16.660 --> 25:17.660
创建了一帧

25:17.660 --> 25:18.660
那这一帧

25:18.660 --> 25:19.660
其实会包含

25:19.660 --> 25:20.660
一些行产主别量

25:20.660 --> 25:21.660
其实它就是

25:21.660 --> 25:23.660
一个预编意义的过程

25:23.660 --> 25:24.660
之后

25:24.660 --> 25:25.660
它会把这一帧

25:25.660 --> 25:26.660
压到站之中

25:26.660 --> 25:27.660
也就是说

25:27.660 --> 25:29.660
压到站之中的话

25:29.660 --> 25:30.660
我们知道

25:30.660 --> 25:31.660
这样的一个

25:31.660 --> 25:32.660
纯属的理念

25:32.660 --> 25:33.660
就是你先进的

25:33.660 --> 25:34.660
要后处

25:34.660 --> 25:35.660
这就好比

25:35.660 --> 25:36.660
比如说

25:36.660 --> 25:37.660
你可以想象成一个

25:38.660 --> 25:39.660
羽毛球球桶

25:39.660 --> 25:40.660
羽毛球球桶的话

25:40.660 --> 25:41.660
是不是

25:41.660 --> 25:43.660
上下是开口的

25:43.660 --> 25:44.660
你把这个桶

25:44.660 --> 25:45.660
放到这个桌面上

25:45.660 --> 25:46.660
那下车的口

25:46.660 --> 25:48.660
被桌面给封死了

25:48.660 --> 25:49.660
那如果说

25:49.660 --> 25:50.660
我有羽毛球的话

25:50.660 --> 25:51.660
我只能去

25:51.660 --> 25:52.660
往上面口去愣

25:52.660 --> 25:53.660
一个一个一个

25:53.660 --> 25:54.660
就说三个球

25:54.660 --> 25:55.660
把这三个球给的

25:55.660 --> 25:56.660
编号

25:56.660 --> 25:57.660
1 2 3

25:57.660 --> 25:58.660
三球编号以后的话

25:58.660 --> 25:59.660
第一个球

25:59.660 --> 26:00.660
先往里面放

26:00.660 --> 26:01.660
第二球再往里面放

26:01.660 --> 26:02.660
第三球再往里面放

26:02.660 --> 26:03.660
假如这个球桶

26:03.660 --> 26:04.660
你不能

26:04.660 --> 26:05.660
给它拿起来

26:05.660 --> 26:06.660
它必须始终

26:06.660 --> 26:07.660
是放到桌面上的

26:07.660 --> 26:08.660
那你在

26:08.660 --> 26:10.660
从中取球的时候

26:10.660 --> 26:11.660
是不是得

26:11.660 --> 26:12.660
比如从上上口开来取

26:12.660 --> 26:13.660
对吧

26:13.660 --> 26:14.660
那你要知道

26:14.660 --> 26:15.660
你这个三个羽毛球

26:15.660 --> 26:16.660
第三个球是最后放的

26:16.660 --> 26:18.660
它一定是在最上面

26:18.660 --> 26:19.660
那你拿出去的时候

26:19.660 --> 26:20.660
那这个羽毛球

26:20.660 --> 26:22.660
一定是最先被拿出去的

26:22.660 --> 26:23.660
那你这个入球桶的时候

26:23.660 --> 26:25.660
其实这个顺序是1 2 3

26:25.660 --> 26:26.660
你出球桶的时候

26:26.660 --> 26:27.660
其实是3 2 1

26:27.660 --> 26:28.660
对吧

26:28.660 --> 26:29.660
那么这样的一个

26:29.660 --> 26:30.660
程序的理念

26:30.660 --> 26:31.660
它就是你先进来的任务

26:31.660 --> 26:32.660
对吧

26:32.660 --> 26:33.660
你耗处

26:33.660 --> 26:34.660
那比如说

26:34.660 --> 26:35.660
我们FO这个函数

26:35.660 --> 26:36.660
它执行

26:36.660 --> 26:37.660
其实是先被放的

26:37.660 --> 26:38.660
这个战之中的

26:38.660 --> 26:39.660
你看这

26:39.660 --> 26:40.660
在马的时候

26:40.660 --> 26:41.660
我们执行

26:41.660 --> 26:42.660
这个必

26:42.660 --> 26:43.660
这个函数

26:43.660 --> 26:44.660
也就是说

26:44.660 --> 26:46.660
在它执行的时候

26:46.660 --> 26:47.660
OK

26:47.660 --> 26:48.660
在它执行还没执行完的

26:48.660 --> 26:49.660
对吧

26:49.660 --> 26:50.660
我们现在执行它了

26:50.660 --> 26:51.660
那现在执行它的话

26:51.660 --> 26:52.660
OK

26:52.660 --> 26:53.660
它也会经历这样的

26:53.660 --> 26:54.660
预编意义的过程

26:54.660 --> 26:55.660
也是穿进新的一个针

26:55.660 --> 26:56.660
这个针穿进完了以后的话

26:56.660 --> 26:58.660
也会被摇到这个战之中

26:58.660 --> 26:59.660
那当这个函数

26:59.660 --> 27:00.660
执行完以后的话

27:00.660 --> 27:01.660
好了

27:01.660 --> 27:02.660
有时候当这个函数

27:02.660 --> 27:03.660
执行完以后的话

27:03.660 --> 27:04.660
它就会弹处站

27:04.660 --> 27:05.660
有时候

27:05.660 --> 27:06.660
这个

27:06.660 --> 27:07.660
当然我再说说来一遍

27:07.660 --> 27:08.660
好

27:08.660 --> 27:09.660
它也会

27:09.660 --> 27:10.660
它就会弹处站

27:10.660 --> 27:11.660
从战中出去了

27:11.660 --> 27:12.660
你说它没了

27:12.660 --> 27:13.660
它没了以后的话

27:13.660 --> 27:14.660
是不是就只剩FO了

27:14.660 --> 27:15.660
对吧

27:15.660 --> 27:16.660
那就是

27:16.660 --> 27:17.660
它走了以后

27:17.660 --> 27:18.660
或者说这个任务

27:18.660 --> 27:19.660
被执行完了以后的话

27:19.660 --> 27:20.660
真正去执行的

27:20.660 --> 27:21.660
就是FO了

27:21.660 --> 27:22.660
那咱们看一下

27:22.660 --> 27:24.660
还是用文字来描述一下

27:24.660 --> 27:25.660
就是FO

27:25.660 --> 27:26.660
要必要

27:26.660 --> 27:27.660
还执行完以后的话

27:27.660 --> 27:28.660
弹处站

27:28.660 --> 27:29.660
那接下来就是它来执行

27:29.660 --> 27:30.660
它来执行以后的话

27:30.660 --> 27:31.660
当然它也会弹处站

27:31.660 --> 27:32.660
那这个时候

27:32.660 --> 27:33.660
占了一空

27:33.660 --> 27:34.660
占了一空

27:34.660 --> 27:35.660
占了一空以后的话

27:35.660 --> 27:36.660
其实

27:36.660 --> 27:37.660
最后

27:37.660 --> 27:38.660
我会看一下

27:38.660 --> 27:39.660
因为它对列

27:39.660 --> 27:40.660
对列里面

27:40.660 --> 27:41.660
它有没有新的任务

27:41.660 --> 27:42.660
有任务的话

27:42.660 --> 27:43.660
拿出来

27:43.660 --> 27:44.660
再放到战中

27:44.660 --> 27:45.660
再来执行

27:45.660 --> 27:46.660
那其实

27:46.660 --> 27:47.660
我们这一门

27:47.660 --> 27:48.660
一般情况下

27:48.660 --> 27:50.660
会把我们所谓的执行站

27:50.660 --> 27:51.660
作为

27:51.660 --> 27:53.660
把它当作

27:53.660 --> 27:54.660
GSE引擎

27:54.660 --> 27:56.660
现成之中的主现成

27:56.660 --> 27:57.660
也就是说

27:57.660 --> 27:58.660
执行站

27:58.660 --> 27:59.660
它只有一个

27:59.660 --> 28:00.660
它同一时间段里面

28:00.660 --> 28:02.660
只能干一件事情

28:03.660 --> 28:04.660
那好了

28:04.660 --> 28:05.660
那咱看一下

28:05.660 --> 28:06.660
是不是这样

28:06.660 --> 28:07.660
这样

28:07.660 --> 28:08.660
当然第八个

28:08.660 --> 28:09.660
先不写了

28:09.660 --> 28:10.660
先不写了

28:10.660 --> 28:11.660
咱这样

28:11.660 --> 28:14.220
我刷新一次

28:14.220 --> 28:15.220
好

28:15.220 --> 28:16.220
最后呢

28:16.220 --> 28:17.220
是不是输出了

28:17.220 --> 28:18.220
这样的一个

28:18.220 --> 28:19.220
二十和安底帆的

28:19.220 --> 28:20.220
对吧

28:20.220 --> 28:21.220
安底帆

28:21.220 --> 28:22.220
这有没有传执对吧

28:22.220 --> 28:23.220
那传一个十

28:23.220 --> 28:24.220
三包存一下

28:24.220 --> 28:25.220
是不是先二十执行

28:25.220 --> 28:26.220
再十就执行

28:26.220 --> 28:27.220
对吧

28:27.220 --> 28:28.220
先二十

28:28.220 --> 28:29.220
再来十

28:29.220 --> 28:30.220
好

28:30.220 --> 28:31.220
那这样的话

28:31.220 --> 28:32.220
其实

28:32.220 --> 28:33.220
我们大概

28:33.220 --> 28:34.220
大概

28:34.220 --> 28:35.220
对这个执行站

28:35.220 --> 28:36.220
和这个

28:36.220 --> 28:37.220
所谓的

28:37.220 --> 28:38.220
这是异部的任务

28:38.220 --> 28:39.220
它会怎么办呢

28:39.220 --> 28:40.220
异部的任务的话

28:40.220 --> 28:41.220
就比如说

28:41.220 --> 28:42.220
展开这儿

28:42.220 --> 28:43.220
你真正用一个

28:43.220 --> 28:44.220
阿甲克斯

28:44.220 --> 28:45.220
去发送一个网络请求

28:45.220 --> 28:46.220
当然阿甲克斯的话

28:46.220 --> 28:47.220
如果你不懂的话

28:47.220 --> 28:48.220
我们就业班

28:48.220 --> 28:49.220
会强调的去讲

28:49.220 --> 28:50.220
它的原码是什么

28:50.220 --> 28:51.220
它的设计师你念什么

28:51.220 --> 28:52.220
我们这一码

28:52.220 --> 28:53.220
使用的是一个

28:53.220 --> 28:54.220
几块

28:54.220 --> 28:55.220
它所封装好的

28:55.220 --> 28:56.220
一个阿甲克斯

28:56.220 --> 28:57.220
我们也会在

28:57.220 --> 28:58.220
就业班里面

28:58.220 --> 28:59.220
去讲这个几块

28:59.220 --> 29:00.220
并且除了教你

29:00.220 --> 29:01.220
去怎么去使用它

29:01.220 --> 29:02.220
这是第一步

29:02.220 --> 29:03.220
第二步就是

29:03.220 --> 29:04.220
来看一下

29:04.220 --> 29:05.220
原码怎么写了

29:05.220 --> 29:06.220
之后再教你

29:06.220 --> 29:07.220
这个GS库

29:07.220 --> 29:08.220
因为剩余

29:08.220 --> 29:09.220
它不是剩余

29:09.220 --> 29:10.220
你要想真正

29:10.220 --> 29:11.220
在这个行业之中

29:11.220 --> 29:12.220
有正常力的话

29:12.220 --> 29:13.220
你就必须的

29:13.220 --> 29:14.220
有这样的一个

29:14.220 --> 29:15.220
对库

29:15.220 --> 29:16.220
和对这个框架的

29:16.220 --> 29:17.220
这样的一个

29:17.220 --> 29:18.220
设计的能力

29:18.220 --> 29:19.220
那好了

29:19.220 --> 29:20.220
那咱不说那么多

29:20.220 --> 29:21.220
咱来看这儿

29:21.220 --> 29:22.220
如果说你发送通

29:22.220 --> 29:23.220
阿甲克斯来发送

29:23.220 --> 29:24.220
一个网络请求的话

29:24.220 --> 29:25.220
那

29:25.220 --> 29:26.220
这个网络请求

29:26.220 --> 29:27.220
当然它是一个

29:27.220 --> 29:28.220
我们设计师

29:28.220 --> 29:30.220
是一个异部的请求

29:30.220 --> 29:32.220
那这个异部的请求的话

29:32.220 --> 29:34.220
它到底发生什么

29:34.220 --> 29:35.220
那个过程呢

29:35.220 --> 29:36.220
其实咱可以看看

29:36.220 --> 29:37.220
就是这个异部的任务

29:37.220 --> 29:39.220
它会走这个整个图的

29:39.220 --> 29:40.220
诶

29:40.220 --> 29:41.220
右半步

29:41.220 --> 29:42.220
对吧

29:42.220 --> 29:43.220
走这半步

29:43.220 --> 29:44.220
那咱们看一下吧

29:44.220 --> 29:45.220
我用文字来描述一下

29:45.220 --> 29:46.220
就在带码

29:46.220 --> 29:47.220
就是它的本质就是

29:47.220 --> 29:48.220
像这个地址发送网络请求

29:48.220 --> 29:49.220
当然

29:49.220 --> 29:50.220
数据

29:50.220 --> 29:51.220
传进去的参数

29:51.220 --> 29:52.220
我什么都没写

29:52.220 --> 29:53.220
那最后

29:53.220 --> 29:54.220
当这个数据

29:54.220 --> 29:55.220
请求回来以后的话

29:55.220 --> 29:56.220
好 返回

29:56.220 --> 29:57.220
返回到这个

29:57.220 --> 29:58.220
前段以后的话

29:58.220 --> 29:59.220
会出发将来

29:59.220 --> 30:00.220
回到韩寿

30:00.220 --> 30:01.220
再回到韩寿里面

30:01.220 --> 30:02.220
去执行它

30:02.220 --> 30:03.220
所返回的一个数据

30:03.220 --> 30:04.220
那OK

30:04.220 --> 30:05.220
那咱三看一下

30:05.220 --> 30:06.220
它到底经历了

30:06.220 --> 30:07.220
就是用文字来描述的话

30:07.220 --> 30:08.220
按照那个流程图

30:08.220 --> 30:09.220
到底经历了哪些过程啊

30:09.220 --> 30:10.220
首先

30:10.220 --> 30:11.220
埃亚克斯

30:11.220 --> 30:12.220
这个发送

30:12.220 --> 30:13.220
埃亚克斯请求

30:13.220 --> 30:14.220
这样一个异部的任务

30:14.220 --> 30:15.220
异部的任务呢

30:15.220 --> 30:16.220
它会往右侧去走

30:16.220 --> 30:17.220
右侧去走的话

30:17.220 --> 30:18.220
首先它进行了

30:18.220 --> 30:19.220
这样一个英文的提报里面

30:19.220 --> 30:20.220
去注册一下

30:20.220 --> 30:21.220
这样一个回到韩寿

30:21.220 --> 30:22.220
success

30:22.220 --> 30:23.220
那也就是说

30:23.220 --> 30:24.220
success这个韩寿

30:24.220 --> 30:25.220
已经被注册好了

30:25.220 --> 30:26.220
那什么时候

30:26.220 --> 30:27.220
触发呢

30:27.220 --> 30:28.220
只有当

30:28.220 --> 30:29.220
对 只有当这个

30:29.220 --> 30:30.220
埃亚克斯事件

30:30.220 --> 30:31.220
完成以后

30:31.220 --> 30:32.220
htp

30:32.220 --> 30:33.220
htp

30:33.220 --> 30:34.220
请求现成

30:34.220 --> 30:35.220
把这个

30:35.220 --> 30:36.220
这个真正的任务

30:36.220 --> 30:37.220
或者说

30:37.220 --> 30:38.220
把这个success

30:38.220 --> 30:39.220
这个韩寿的

30:39.220 --> 30:40.220
执行的任务吧

30:40.220 --> 30:41.220
给他放到这个

30:41.220 --> 30:43.220
实验队队里面去以后

30:43.220 --> 30:44.220
OK

30:44.220 --> 30:45.220
我们主任称

30:45.220 --> 30:47.220
到他空的情况下的话

30:47.220 --> 30:49.220
他才会去出发他

30:49.220 --> 30:50.220
那咱再来看一下

30:50.220 --> 30:51.220
这个流程啊

30:51.220 --> 30:52.220
也就是说

30:52.220 --> 30:53.220
当去执行他

30:53.220 --> 30:55.220
执行这段代码的时候

30:55.220 --> 30:56.220
实际上这个

30:56.220 --> 30:57.220
异部任务发

30:57.220 --> 30:58.220
发送以后的话

30:58.220 --> 30:59.220
异部的任务

30:59.220 --> 31:00.220
发送以后的话

31:00.220 --> 31:01.220
你要知道

31:01.220 --> 31:02.220
这个请求

31:02.220 --> 31:03.220
一定的这样

31:03.220 --> 31:04.220
等待的一个时间

31:04.220 --> 31:05.220
那当他看完

31:05.220 --> 31:06.220
这段话以后的话

31:06.220 --> 31:07.220
紧接着

31:07.220 --> 31:08.220
会是用下面

31:08.220 --> 31:09.220
他这样的一段话

31:09.220 --> 31:10.220
那这段话

31:10.220 --> 31:11.220
其实他也是个任务

31:11.220 --> 31:12.220
就是要

31:12.220 --> 31:13.220
去输出一下这个乱

31:13.220 --> 31:14.220
对不对

31:14.220 --> 31:15.220
那最后

31:15.220 --> 31:16.220
所表现出来的状态

31:16.220 --> 31:17.220
基本上一定是

31:17.220 --> 31:18.220
一定是先输出这个乱

31:18.220 --> 31:19.220
等输出完

31:19.220 --> 31:20.220
乱以后的话

31:20.220 --> 31:21.220
才会去

31:21.220 --> 31:23.220
就是当这个

31:23.220 --> 31:24.220
数据

31:24.220 --> 31:25.220
被请求回来以后的话

31:25.220 --> 31:26.220
被放到这个

31:26.220 --> 31:27.220
任务队里以后

31:27.220 --> 31:28.220
反正

31:28.220 --> 31:29.220
克斯的落过这个任务

31:29.220 --> 31:30.220
也执行完了对吧

31:30.220 --> 31:31.220
这个占空了

31:31.220 --> 31:32.220
去看一下

31:32.220 --> 31:33.220
哎呀

31:33.220 --> 31:34.220
你就用在里面有没有东西

31:34.220 --> 31:35.220
如果有的话

31:35.220 --> 31:36.220
给你拿到我的站里面

31:36.220 --> 31:37.220
再进来执行

31:37.220 --> 31:38.220
ok

31:38.220 --> 31:39.220
那说到这的话

31:39.220 --> 31:40.220
可能还会有些同学

31:40.220 --> 31:41.220
有点懵

31:41.220 --> 31:42.220
毕竟这一块

31:42.220 --> 31:43.220
相对来说

31:43.220 --> 31:44.220
比较底层一点

31:44.220 --> 31:45.220
需要你具备一些

31:45.220 --> 31:47.220
比较扎实的一个知识

31:47.220 --> 31:48.220
那ok

31:48.220 --> 31:49.220
那咱站我下来

31:50.220 --> 31:51.220
这样

31:51.220 --> 31:52.220
如果说前面

31:52.220 --> 31:53.220
你还不是很理解的话

31:53.220 --> 31:54.220
这样我们再换张图

31:54.220 --> 31:55.220
再给你想象的

31:55.220 --> 31:56.220
来说一说

31:56.220 --> 31:57.220
那我们gis

31:57.220 --> 31:58.220
引擎现成的话

31:58.220 --> 31:59.220
其实

31:59.220 --> 32:00.220
不好意思

32:00.220 --> 32:01.220
它的主现成

32:01.220 --> 32:04.220
是这样的一个单现成

32:04.220 --> 32:05.220
我们可以来看一下了

32:05.220 --> 32:06.220
其实这个是gis引擎

32:06.220 --> 32:09.220
现成所管控的一个区域

32:09.220 --> 32:10.220
ok

32:10.220 --> 32:11.220
那左侧这一块

32:11.220 --> 32:12.220
其实

32:12.220 --> 32:13.220
就是在一个真正

32:13.220 --> 32:14.220
就是在gis引擎

32:14.220 --> 32:16.220
现成真正在执行的时候

32:16.220 --> 32:18.220
它会创建这个堆合站

32:18.220 --> 32:20.220
就是我们所说的执行站

32:20.220 --> 32:21.220
那每个孩子的执行

32:21.220 --> 32:22.220
或者说

32:22.220 --> 32:23.220
每个功能性代码的执行

32:23.220 --> 32:25.220
都会被当作任务

32:25.220 --> 32:26.220
放到这个站之中

32:26.220 --> 32:27.220
那就按照这种

32:27.220 --> 32:28.220
先进先出的方式

32:28.220 --> 32:29.220
来一个一个执行

32:29.220 --> 32:30.220
ok

32:30.220 --> 32:31.220
那在执行的过程中

32:31.220 --> 32:32.220
比如说

32:32.220 --> 32:34.220
它把前面这个话

32:34.220 --> 32:35.220
拿出来执行

32:35.220 --> 32:37.220
执行完了以后的话

32:37.220 --> 32:38.220
它会把下一个任务

32:38.220 --> 32:39.220
再拿出来执行

32:39.220 --> 32:40.220
如果下一个任务

32:40.220 --> 32:41.220
是去调用一个

32:41.220 --> 32:42.220
index的话

32:42.220 --> 32:43.220
那ok

32:43.220 --> 32:45.220
那这个gis引擎

32:45.220 --> 32:46.220
现成的

32:46.220 --> 32:47.220
就会调用这样的一个

32:47.220 --> 32:48.220
web api

32:48.220 --> 32:50.220
把这个web api

32:50.220 --> 32:51.220
当然这个是

32:51.220 --> 32:52.220
web api

32:52.220 --> 32:53.220
是这个gis引擎

32:53.220 --> 32:55.220
外部所提供的一些功能

32:55.220 --> 32:57.220
你只是去调

32:57.220 --> 32:58.220
去跟它说一下

32:58.220 --> 32:59.220
你把这个功能先介绍一下

32:59.220 --> 33:00.220
我来去使用一下

33:00.220 --> 33:02.220
你发生了一个网络请求

33:02.220 --> 33:03.220
当然这个网络请求

33:03.220 --> 33:04.220
这个东西呢

33:04.220 --> 33:06.220
确实是

33:06.220 --> 33:07.220
你把这个

33:07.220 --> 33:08.220
它这个功能

33:08.220 --> 33:09.220
就是给它

33:09.220 --> 33:11.220
拿到你这样的一个gis之中

33:11.220 --> 33:12.220
对吧

33:12.220 --> 33:13.220
拿到你这样的一个

33:13.220 --> 33:14.220
gis

33:14.220 --> 33:16.220
gis引擎的这个

33:16.220 --> 33:17.220
现成之中的话

33:17.220 --> 33:18.220
你去给它

33:18.220 --> 33:19.220
做这样的一个

33:19.220 --> 33:21.220
网络请求的操作

33:21.220 --> 33:22.220
确实

33:22.220 --> 33:23.220
这个东西

33:23.220 --> 33:24.220
虽然是外部人来提供的

33:24.220 --> 33:25.220
当然其实

33:25.220 --> 33:26.220
你是把它介过来

33:26.220 --> 33:27.220
你来去使用的

33:27.220 --> 33:28.220
对吧

33:28.220 --> 33:29.220
好

33:29.220 --> 33:31.220
那你在使用的时候呢

33:31.220 --> 33:32.220
这个请求你发出去了

33:32.220 --> 33:34.220
你发到这个服务系统了

33:34.220 --> 33:35.220
好了

33:35.220 --> 33:36.220
那事业的事

33:36.220 --> 33:37.220
谁来管呢

33:37.220 --> 33:38.220
就是用那个htp网络请求

33:38.220 --> 33:39.220
现在对吧

33:39.220 --> 33:40.220
由它来负责管控

33:40.220 --> 33:41.220
当然这个数据真正

33:41.220 --> 33:43.220
回来的时候呢

33:43.220 --> 33:44.220
它会把这个

33:44.220 --> 33:46.220
它会去监测到

33:46.220 --> 33:47.220
监测到以后的话

33:47.220 --> 33:48.220
它会把这个回到函数

33:48.220 --> 33:50.220
给它放到这个

33:50.220 --> 33:51.220
其实你们应该叫做

33:51.220 --> 33:52.220
事件对列

33:52.220 --> 33:54.220
叫emdq里面来

33:54.220 --> 33:55.220
给它放到这样的一个

33:55.220 --> 33:56.220
事件对列里面来

33:56.220 --> 33:58.220
那放到里面来的话

33:58.220 --> 33:59.220
OK

33:59.220 --> 34:01.220
它可能会进行这样的一个排队

34:01.220 --> 34:02.220
怎么来排呢

34:02.220 --> 34:03.220
就比如说

34:03.220 --> 34:05.220
你之前可能

34:05.220 --> 34:06.220
还触发了一个

34:06.220 --> 34:07.220
比如说还触发了一个

34:07.220 --> 34:08.220
事件

34:08.220 --> 34:09.220
那事件的这样的一个

34:09.220 --> 34:10.220
事件处理函数

34:10.220 --> 34:11.220
也要被当作任务

34:11.220 --> 34:12.220
放到这个

34:12.220 --> 34:13.220
事件

34:13.220 --> 34:14.220
放到这个emdq里面来

34:14.220 --> 34:15.220
那当然

34:15.220 --> 34:16.220
那可能说你有个电源器

34:16.220 --> 34:17.220
对吧

34:17.220 --> 34:18.220
这个电源器

34:18.220 --> 34:19.220
它比如说隔了一段时间

34:19.220 --> 34:20.220
也把这个任务

34:20.220 --> 34:21.220
它放到里面来

34:21.220 --> 34:22.220
那比如说你这个ax

34:22.220 --> 34:24.220
是最后

34:24.220 --> 34:25.220
去把一个数据

34:25.220 --> 34:26.220
请你回来

34:26.220 --> 34:27.220
对吧

34:27.220 --> 34:28.220
那这个任务一定是放到

34:28.220 --> 34:29.220
它们两个任务之后

34:29.220 --> 34:30.220
来进行这样的一个

34:30.220 --> 34:31.220
说法的

34:31.220 --> 34:33.220
那它这个顺序进行排队

34:33.220 --> 34:34.220
那排队的时候呢

34:34.220 --> 34:35.220
好了

34:35.220 --> 34:36.220
并不是一排队

34:36.220 --> 34:37.220
就能触发啊

34:37.220 --> 34:38.220
而是说

34:38.220 --> 34:39.220
你看好了

34:39.220 --> 34:40.220
这个之星站中

34:40.220 --> 34:41.220
或者说这个GS

34:41.220 --> 34:43.220
已经现成的

34:43.220 --> 34:44.220
主线程之中

34:44.220 --> 34:45.220
可以列成

34:45.220 --> 34:46.220
它是个主线程

34:46.220 --> 34:47.220
就是

34:47.220 --> 34:48.220
GS已经现成

34:48.220 --> 34:49.220
里面也分很多部分

34:49.220 --> 34:50.220
其中有的部分

34:50.220 --> 34:51.220
都可以管得列成

34:51.220 --> 34:52.220
叫做主线程

34:52.220 --> 34:54.220
它是真正用来干事的

34:54.220 --> 34:55.220
比如说

34:55.220 --> 34:56.220
这个线程中的

34:56.220 --> 34:57.220
这样的一个之星站

34:57.220 --> 34:58.220
对吧

34:58.220 --> 34:59.220
好

34:59.220 --> 35:00.220
它在真正的

35:00.220 --> 35:01.220
把这个站里面

35:01.220 --> 35:02.220
每个任务全进空以后

35:02.220 --> 35:03.220
它会去看一下

35:03.220 --> 35:04.220
这个队里面

35:04.220 --> 35:05.220
有没有任务

35:05.220 --> 35:06.220
如果有的话

35:06.220 --> 35:07.220
拿过来之行

35:07.220 --> 35:08.220
对吧

35:08.220 --> 35:09.220
拿过来之行

35:09.220 --> 35:10.220
以后的话

35:10.220 --> 35:11.220
我可以再看一下

35:11.220 --> 35:12.220
没有任务

35:12.220 --> 35:13.220
有的话

35:13.220 --> 35:14.220
拿过来之行

35:14.220 --> 35:15.220
那按照这样的一个

35:15.220 --> 35:16.220
喜欢的操作的话

35:16.220 --> 35:17.220
也就是说

35:17.220 --> 35:18.220
这是我们

35:18.220 --> 35:19.220
所谓的

35:19.220 --> 35:20.220
事件轮寻

35:20.220 --> 35:21.220
那如果说

35:21.220 --> 35:22.220
这个地方

35:22.220 --> 35:23.220
你大概懂了以后的话

35:23.220 --> 35:24.220
那种

35:24.220 --> 35:26.220
这儿它就是个死心管

35:26.220 --> 35:27.220
卡死在这儿了

35:27.220 --> 35:28.220
那不管你前面

35:28.220 --> 35:29.220
对吧

35:29.220 --> 35:30.220
有多少个什么

35:30.220 --> 35:31.220
地人器啊

35:31.220 --> 35:32.220
多少个事件

35:32.220 --> 35:33.220
被出发呀

35:33.220 --> 35:34.220
或者说是

35:34.220 --> 35:35.220
有多少个网络请求

35:35.220 --> 35:36.220
这个数据

35:36.220 --> 35:37.220
请回来对吧

35:37.220 --> 35:38.220
把所有的任务

35:38.220 --> 35:39.220
全放到这个

35:39.220 --> 35:40.220
事件队里面来

35:40.220 --> 35:41.220
排了满满的

35:41.220 --> 35:42.220
但是呢

35:42.220 --> 35:43.220
由于你这是个死心管

35:43.220 --> 35:44.220
对不对

35:44.220 --> 35:45.220
你也依旧不会

35:45.220 --> 35:47.220
去执行它们

35:47.220 --> 35:49.220
它会一直卡死在这儿

35:49.220 --> 35:50.220
那也就是说

35:50.220 --> 35:51.220
这个是我们GX

35:51.220 --> 35:52.220
单线程的一个特点

35:52.220 --> 35:53.220
说你用它们

35:53.220 --> 35:54.220
它们

35:54.220 --> 35:55.220
它们对吧

35:55.220 --> 35:56.220
它们分别

35:56.220 --> 35:58.220
分别依靠

35:58.220 --> 36:00.220
分别依靠

36:00.220 --> 36:02.220
这些线程

36:02.220 --> 36:03.220
它们

36:03.220 --> 36:04.220
它们对吧

36:04.220 --> 36:06.220
分别依靠这些线程

36:06.220 --> 36:07.220
最后来辅助

36:07.220 --> 36:09.220
整个GX线程

36:09.220 --> 36:11.220
完成了这样

36:11.220 --> 36:13.220
看似异部的一个操作

36:13.220 --> 36:14.220
但其实呢

36:14.220 --> 36:15.220
我们归根到底

36:15.220 --> 36:17.220
GX线程的主线程

36:17.220 --> 36:18.220
这块对吧

36:18.220 --> 36:19.220
它就是单线程的

36:19.220 --> 36:21.220
你帮我去

36:21.220 --> 36:22.220
怎么说以后

36:22.220 --> 36:23.220
你把任务给我撇到

36:23.220 --> 36:24.220
这个队内里面来了

36:24.220 --> 36:25.220
但我这里面事

36:25.220 --> 36:26.220
不干完的话

36:26.220 --> 36:27.220
怎么样

36:27.220 --> 36:28.220
依旧没有办法去执行

36:28.220 --> 36:29.220
这些东西

36:29.220 --> 36:31.220
那这里面呢

36:31.220 --> 36:32.220
其实

36:32.220 --> 36:33.220
我就能拿一个电源器

36:33.220 --> 36:34.220
来举例子

36:34.220 --> 36:35.220
因为很多同学

36:35.220 --> 36:36.220
在用电源器的时候呢

36:36.220 --> 36:37.220
所用跟所想

36:37.220 --> 36:39.220
它完全是不一样的

36:39.220 --> 36:41.220
那我们需要

36:41.220 --> 36:42.220
重新来理解

36:42.220 --> 36:43.220
或者说重新来定一下

36:43.220 --> 36:44.220
这个电源器

36:44.220 --> 36:45.220
我们set time out

36:45.220 --> 36:47.220
并不是严格意义上的

36:47.220 --> 36:48.220
比如说每隔一段时间

36:48.220 --> 36:49.220
对吧

36:49.220 --> 36:50.220
并不是严格意义上的

36:50.220 --> 36:51.220
隔了一段时间

36:51.220 --> 36:52.220
今后执行什么的事

36:52.220 --> 36:53.220
而是说呢

36:53.220 --> 36:54.220
你看好了

36:54.220 --> 36:55.220
set time out是

36:55.220 --> 36:57.220
等待时间结束以后

36:57.220 --> 36:59.220
并不是直接执行

36:59.220 --> 37:00.220
而是先把这个

37:00.220 --> 37:01.220
就是当这个等待时间

37:01.220 --> 37:02.220
结束以后

37:02.220 --> 37:03.220
它会把这个

37:03.220 --> 37:04.220
函数当任务

37:04.220 --> 37:05.220
给它推入到

37:05.220 --> 37:06.220
连接的任务队内之中

37:06.220 --> 37:07.220
比如说给它推到这

37:07.220 --> 37:09.220
推到推到这的话

37:09.220 --> 37:10.220
它能执行的

37:10.220 --> 37:11.220
直接去执行吗

37:11.220 --> 37:12.220
不行对吧

37:12.220 --> 37:14.220
必须在同步队内

37:14.220 --> 37:15.220
结束后

37:15.220 --> 37:16.220
或者说我们GX

37:16.220 --> 37:17.220
主线程之中的

37:17.220 --> 37:18.220
这样的一个精湛

37:18.220 --> 37:19.220
对吧

37:19.220 --> 37:21.220
必须当这执行完了以后的话

37:21.220 --> 37:22.220
好

37:22.220 --> 37:23.220
完成之后呢

37:23.220 --> 37:24.220
依次调用

37:24.220 --> 37:25.220
任务队内中的一个任务

37:25.220 --> 37:26.220
对吧

37:26.220 --> 37:27.220
它会把这个任务

37:27.220 --> 37:28.220
一个一个拿出来

37:28.220 --> 37:29.220
等执行拿到了

37:29.220 --> 37:30.220
你以后的话

37:30.220 --> 37:32.220
才是真正的执行

37:32.220 --> 37:33.220
那如果说前面

37:33.220 --> 37:34.220
比如说前面

37:34.220 --> 37:36.220
如果是死循环的话对吧

37:36.220 --> 37:37.220
那你这后面

37:37.220 --> 37:39.220
根本就没办法去执行了

37:39.220 --> 37:40.220
那如果说前面

37:40.220 --> 37:41.220
不是死循环的话

37:41.220 --> 37:42.220
但突然有个代码

37:42.220 --> 37:43.220
比如说

37:43.220 --> 37:44.220
它执行时间非常长

37:44.220 --> 37:45.220
但是你那个电扇器呢

37:45.220 --> 37:46.220
比如说是延迟

37:46.220 --> 37:47.220
100画面去执行

37:47.220 --> 37:48.220
那那个代码人

37:48.220 --> 37:49.220
就执行了一秒

37:49.220 --> 37:50.220
一秒多

37:50.220 --> 37:51.220
那最后一定会造成

37:51.220 --> 37:52.220
这个电扇器

37:52.220 --> 37:54.220
它不准的这样的一个情况

37:54.220 --> 37:55.220
那好

37:55.220 --> 37:56.220
那咱再往下来

37:56.220 --> 37:57.220
因为SETTIMEOUT的话

37:57.220 --> 37:58.220
其实有的时候

37:58.220 --> 37:59.220
我们会使用这个理论

37:59.220 --> 38:00.220
这个理论是什么意思呢

38:00.220 --> 38:01.220
就是这个理论呢

38:01.220 --> 38:03.220
就是当GS主线

38:03.220 --> 38:05.220
从之中那个执行站

38:05.220 --> 38:07.220
它为空的时候

38:07.220 --> 38:09.220
我们就立马去执行

38:09.220 --> 38:11.220
这样的一个任务

38:11.220 --> 38:12.220
它的本意是这样的

38:12.220 --> 38:13.220
但你就要知道

38:13.220 --> 38:14.220
你就是写理论

38:14.220 --> 38:16.220
按照我们这个HMR标准来讲的话

38:16.220 --> 38:19.220
它也就是4毫秒左右

38:19.220 --> 38:20.220
也就是说你碰到

38:20.220 --> 38:21.220
这个代码以后的话

38:21.220 --> 38:23.220
它会延迟4毫秒

38:23.220 --> 38:24.220
把这个任务

38:24.220 --> 38:25.220
给你放到这样的一个

38:25.220 --> 38:27.220
时间对立你们来

38:27.220 --> 38:28.220
也得必须的等到

38:28.220 --> 38:29.220
这个站没空了

38:29.220 --> 38:30.220
对吧

38:30.220 --> 38:31.220
把这个任务一个一个拿

38:31.220 --> 38:32.220
拿到你以后

38:32.220 --> 38:34.220
才能执行

38:34.220 --> 38:35.220
那SETTIMEOUT的话

38:35.220 --> 38:36.220
它是每个一段时间

38:36.220 --> 38:37.220
把一个任务放到这个时间

38:37.220 --> 38:38.220
它对立你们来

38:38.220 --> 38:39.220
对不对

38:39.220 --> 38:41.220
它懂得它以后的话

38:41.220 --> 38:43.220
自然而然就懂得它

38:43.220 --> 38:44.220
那这样的话

38:44.220 --> 38:45.220
咱们再往下来看

38:46.220 --> 38:48.220
就针对于这样的一段代码

38:48.220 --> 38:49.220
咱来看一下

38:49.220 --> 38:50.220
我隔这个400毫秒

38:50.220 --> 38:51.220
到底能不能

38:51.220 --> 38:52.220
对吧

38:52.220 --> 38:54.220
准时的去请这样的一个东西

38:54.220 --> 38:55.220
好

38:55.220 --> 38:56.220
我咱做一个测验

38:56.220 --> 38:57.220
比如说在这呢

38:57.220 --> 38:58.220
我去写个

38:58.220 --> 38:59.220
它的时候

38:59.220 --> 39:00.220
它叫做SLEEP

39:01.220 --> 39:02.220
这里面呢

39:02.220 --> 39:04.220
我就写个1千

39:04.220 --> 39:05.220
1千

39:05.220 --> 39:06.220
这写个長径TEMP

39:06.220 --> 39:07.220
对吧

39:07.220 --> 39:08.220
但是这边

39:08.220 --> 39:09.220
我来个放循环

39:09.220 --> 39:10.220
放循环

39:10.220 --> 39:11.220
SETTIMEOUT

39:11.220 --> 39:12.220
只是决定放循环

39:12.220 --> 39:13.220
指定多少圈

39:13.220 --> 39:14.220
好

39:14.220 --> 39:16.220
我I去小于一个

39:16.220 --> 39:17.220
SLEEP

39:17.220 --> 39:18.220
I去小于一个TEMP

39:18.220 --> 39:19.220
好

39:19.220 --> 39:20.220
I去来这样

39:20.220 --> 39:21.220
在里面呢

39:21.220 --> 39:23.220
我就不断地输出这个I

39:23.220 --> 39:24.220
好

39:24.220 --> 39:26.220
那我在写一个SLEEP的时候呢

39:26.220 --> 39:29.980
在写一个SLEEP的时候呢

39:29.980 --> 39:30.980
好

39:30.980 --> 39:31.980
我往里面传个指子

39:31.980 --> 39:33.980
传个十百千万

39:33.980 --> 39:34.980
传十万

39:34.980 --> 39:35.980
让它转十万圈

39:35.980 --> 39:36.980
好

39:36.980 --> 39:37.980
那我在这呢

39:37.980 --> 39:38.980
那我在它

39:38.980 --> 39:39.980
你执行之前吧

39:39.980 --> 39:41.980
我就调一个SETTIMEOUT

39:41.980 --> 39:42.980
SETTIMEOUT

39:42.980 --> 39:43.980
那写它时候

39:43.980 --> 39:44.980
那我这样

39:44.980 --> 39:45.980
我哥一百毫秒

39:45.980 --> 39:47.980
去支撑一下它

39:47.980 --> 39:50.420
好

39:50.420 --> 39:51.420
那在这呢

39:51.420 --> 39:52.420
我去来输出一下

39:52.420 --> 39:54.420
来输出一下

39:54.420 --> 39:55.420
来这样吧

39:55.420 --> 39:56.420
来输下时间吧

39:56.420 --> 39:57.420
行吧

39:57.420 --> 39:58.420
来输下时间

39:58.420 --> 39:59.420
比如说我在这首先

39:59.420 --> 40:00.420
我有个叫做SETTIMEOUT

40:00.420 --> 40:01.420
SETTIMEOUT

40:01.420 --> 40:03.420
它的有一个NU

40:03.420 --> 40:04.420
DATE

40:06.420 --> 40:07.420
DATE

40:07.420 --> 40:08.420
好

40:08.420 --> 40:09.420
来个加号

40:09.420 --> 40:10.420
加号的话就直接调

40:10.420 --> 40:11.420
它这样的一个GuyTEMP了

40:11.420 --> 40:12.420
好

40:12.420 --> 40:13.420
那之后的话

40:13.420 --> 40:14.420
我首先呢

40:14.420 --> 40:17.420
来去输出一下它

40:17.420 --> 40:18.420
SETTIMEOUT

40:20.420 --> 40:21.420
SETTIMEOUT

40:21.420 --> 40:22.420
好

40:22.420 --> 40:23.420
那在这呢

40:23.420 --> 40:24.420
我最后输出

40:24.420 --> 40:25.420
最后输出这个

40:25.420 --> 40:27.420
一个NU DATE

40:27.420 --> 40:28.420
新在这呢

40:28.420 --> 40:30.420
来创建一个这样的一个新对象

40:30.420 --> 40:31.420
那最后再执行

40:31.420 --> 40:32.420
真正在执行这个任务的时候呢

40:32.420 --> 40:34.420
我把它输出出来

40:34.420 --> 40:35.420
也就是说

40:35.420 --> 40:37.420
我把这个新创的这个对象

40:37.420 --> 40:38.420
当前的时间

40:38.420 --> 40:41.420
减去这个一开始的时间

40:41.420 --> 40:42.420
SETTIMEOUT

40:42.420 --> 40:43.420
把它俩这个CHARS给输出来

40:43.420 --> 40:45.420
我来看一下

40:45.420 --> 40:46.420
比如说

40:46.420 --> 40:47.420
一开始

40:47.420 --> 40:48.420
走到

40:48.420 --> 40:49.420
不说一开始

40:49.420 --> 40:50.420
先输出它

40:50.420 --> 40:51.420
这个SETTIMEOUT

40:51.420 --> 40:53.420
先去来输出一遍

40:53.420 --> 40:54.420
看一开始

40:54.420 --> 40:56.420
要去执行它的时候

40:56.420 --> 40:57.420
那个时间的时刻

40:57.420 --> 40:58.420
它是多少

40:58.420 --> 41:00.420
那我这边要延迟100毫秒

41:00.420 --> 41:01.420
好了

41:01.420 --> 41:02.420
你延迟100毫秒的话

41:02.420 --> 41:03.420
有时候各100毫秒的这个任务呢

41:03.420 --> 41:05.420
会被放到那个时间队列之中

41:05.420 --> 41:07.420
那你要知道

41:07.420 --> 41:08.420
当你碰到它以后的话

41:08.420 --> 41:09.420
你立马又碰到它

41:09.420 --> 41:11.420
它其实要被放到这样的一个

41:11.420 --> 41:12.420
执行站之中

41:12.420 --> 41:14.420
去执行这样的一个执行

41:14.420 --> 41:15.420
并且呢

41:15.420 --> 41:16.420
这个

41:16.420 --> 41:18.420
它在执行的时候你会发现

41:18.420 --> 41:20.420
这里面写了一个循环

41:20.420 --> 41:21.420
这个循环呢

41:21.420 --> 41:22.420
会循环10万次

41:22.420 --> 41:23.420
那循环10万次的话

41:23.420 --> 41:25.420
它会真正会执行多长时间

41:25.420 --> 41:26.420
它不一定

41:26.420 --> 41:28.420
比如说可能会执行一秒钟

41:28.420 --> 41:29.420
那它执行一秒钟的话

41:29.420 --> 41:30.420
那你要知道

41:30.420 --> 41:31.420
它在执行100毫秒的

41:31.420 --> 41:33.420
它在执行到100毫秒的时候

41:33.420 --> 41:34.420
这个任务呢

41:34.420 --> 41:36.420
就已经被放到这个任务队列之中了

41:36.420 --> 41:37.420
那我是希望呢

41:37.420 --> 41:38.420
这个执行站之中

41:38.420 --> 41:40.420
是能把这个10万去玩的

41:40.420 --> 41:41.420
100毫秒之内

41:41.420 --> 41:42.420
全部都执行完

41:42.420 --> 41:43.420
那这样的话

41:43.420 --> 41:44.420
执行站一雷空

41:44.420 --> 41:45.420
就立马把这个函数

41:45.420 --> 41:46.420
拿出来去执行了

41:46.420 --> 41:47.420
那那个时候

41:47.420 --> 41:48.420
它们的差值

41:48.420 --> 41:49.420
按理来讲的话

41:49.420 --> 41:50.420
就应该大约是100毫秒

41:50.420 --> 41:51.420
但是如果说

41:51.420 --> 41:52.420
如果说

41:52.420 --> 41:53.420
这个里面在执行的时候

41:53.420 --> 41:55.420
它在去执行的时候呢

41:55.420 --> 41:56.420
它转的圈数

41:56.420 --> 41:57.420
10万圈

41:57.420 --> 41:58.420
花费的时间是一秒钟

41:58.420 --> 41:59.420
对不对

41:59.420 --> 42:00.420
那一秒钟的话

42:00.420 --> 42:01.420
即使到100毫秒

42:01.420 --> 42:02.420
你把这个任务

42:02.420 --> 42:03.420
放到这个实验队列里面来了

42:03.420 --> 42:04.420
那后面900毫秒

42:04.420 --> 42:05.420
它依旧需要

42:05.420 --> 42:06.420
先把它这个自己的东西

42:06.420 --> 42:07.420
来执行完

42:07.420 --> 42:08.420
执行完以后的话

42:08.420 --> 42:09.420
再来去

42:09.420 --> 42:10.420
这个任务队列之中

42:10.420 --> 42:11.420
去看一下

42:11.420 --> 42:12.420
有没有新的任务

42:12.420 --> 42:13.420
如果有的话

42:13.420 --> 42:14.420
再拿到这个

42:14.420 --> 42:15.420
解释职员从之中的

42:15.420 --> 42:17.420
这样的一个执行站之中

42:17.420 --> 42:18.420
再去执行

42:18.420 --> 42:19.420
那必然之后的时间呢

42:19.420 --> 42:20.420
一定会大于100毫秒

42:20.420 --> 42:21.420
而且会大于很多

42:21.420 --> 42:22.420
我再来看一下

42:22.420 --> 42:23.420
到底是不是这样的话

42:23.420 --> 42:24.420
好

42:24.420 --> 42:35.060
小心子

42:35.060 --> 42:36.060
好

42:36.060 --> 42:37.060
一万圈

42:37.060 --> 42:38.060
十万圈是有点多

42:38.060 --> 42:39.060
是有点多

42:39.060 --> 42:40.060
这样吧

42:40.060 --> 42:41.060
一万圈

42:41.060 --> 42:42.060
比较好一点

42:42.060 --> 42:43.060
你看

42:43.060 --> 42:45.060
现在这个定任器对不对

42:46.060 --> 42:48.060
现在这个定任器

42:48.060 --> 42:50.060
它一定不可能

42:50.060 --> 42:51.060
就是得到100毫秒

42:51.060 --> 42:52.060
采取职员对不对

42:52.060 --> 42:53.060
因为我已经说了这么多话

42:53.060 --> 42:54.060
100毫秒早就过去了

42:54.060 --> 42:56.060
但它依旧没有去执行

42:56.060 --> 42:57.060
在这的话

42:57.060 --> 42:58.060
你要疯狂地等

42:58.060 --> 42:59.060
等到很长时间

42:59.060 --> 43:00.060
这样

43:00.060 --> 43:04.880
我重新刷新一下吧

43:04.880 --> 43:05.880
那这里面呢

43:05.880 --> 43:06.880
出现一个

43:06.880 --> 43:08.880
比较残的状况

43:08.880 --> 43:09.880
它卡死了对吧

43:09.880 --> 43:10.880
那现在呢

43:10.880 --> 43:11.880
我们也能证明一个问题

43:11.880 --> 43:13.880
就是你这个东西

43:13.880 --> 43:15.880
确实

43:15.880 --> 43:16.880
确实

43:16.880 --> 43:19.880
没有用了

43:19.880 --> 43:21.880
好

43:21.880 --> 43:25.510
你查了一下

43:25.510 --> 43:26.510
好

43:26.510 --> 43:27.510
这样

43:27.510 --> 43:28.510
十万圈确实稍微有点大

43:28.510 --> 43:30.510
我这样给你打开一次

43:30.510 --> 43:33.510
把你放在里面来吧

43:33.510 --> 43:35.510
一万圈还好啦对吧

43:35.510 --> 43:36.510
十万圈确实有点大

43:36.510 --> 43:37.510
好

43:37.510 --> 43:38.510
咱看这个坎塑

43:38.510 --> 43:39.510
坎塑

43:39.510 --> 43:40.510
那坎塑呢

43:40.510 --> 43:41.510
OK

43:41.510 --> 43:42.510
最后

43:42.510 --> 43:43.510
好了

43:43.510 --> 43:45.950
这个

43:45.950 --> 43:46.950
比如说

43:46.950 --> 43:49.950
最后的话

43:49.950 --> 43:51.950
执行完这个一万圈对不对

43:51.950 --> 43:52.950
我们后来

43:52.950 --> 43:53.950
就是来试试它了

43:53.950 --> 43:54.950
因为这种执行站

43:54.950 --> 43:55.950
这种把

43:55.950 --> 43:56.950
把这种执行完以后的话

43:56.950 --> 43:57.950
才会把这个

43:57.950 --> 43:58.950
人物对内面这个任务

43:58.950 --> 44:00.950
给它拿出来去执行

44:00.950 --> 44:01.950
那我们希望它是

44:01.950 --> 44:03.950
延迟一百毫秒去执行它

44:03.950 --> 44:04.950
但你看最后

44:04.950 --> 44:06.950
它延迟了多长时间

44:06.950 --> 44:07.950
延迟了将近

44:07.950 --> 44:08.950
九百五十八毫秒

44:08.950 --> 44:09.950
将近一秒钟对吧

44:09.950 --> 44:10.950
延迟了一秒

44:10.950 --> 44:12.950
一秒钟对吧

44:12.950 --> 44:13.950
那好了

44:13.950 --> 44:14.950
那这样的话我们就知道了

44:14.950 --> 44:16.950
其实电源器它不准的话

44:16.950 --> 44:17.950
有很多种原因

44:17.950 --> 44:18.950
第一种原因

44:18.950 --> 44:19.950
它就是因为

44:19.950 --> 44:20.950
这个电源器的底层

44:20.950 --> 44:21.950
就是用红维书它来写的

44:21.950 --> 44:23.950
它就是没有那么准的

44:23.950 --> 44:24.950
当然呢

44:24.950 --> 44:25.950
按照这个

44:25.950 --> 44:26.950
GS的一个执行机制

44:26.950 --> 44:27.950
它来讲的话

44:27.950 --> 44:28.950
其实呢

44:28.950 --> 44:30.950
由于是这样的一种机制导致的

44:30.950 --> 44:32.950
它没有办法真正的那么准

44:32.950 --> 44:33.950
那

44:33.950 --> 44:35.950
我们再以后碰到这个

44:35.950 --> 44:36.950
电源器或者碰到

44:36.950 --> 44:38.950
一些异布的一些操作的时候

44:38.950 --> 44:39.950
如果

44:39.950 --> 44:40.950
这个

44:40.950 --> 44:41.950
你所碰到这样的一个结果

44:41.950 --> 44:42.950
跟你预想的一个状况

44:42.950 --> 44:43.950
它不一样的情况下的话

44:43.950 --> 44:45.950
你一定要来回一回意

44:45.950 --> 44:47.950
这个整个GS在运行的时候

44:47.950 --> 44:49.950
它的机制到底是什么一回事

44:49.950 --> 44:51.950
它到底是怎么一回事

44:51.950 --> 44:53.950
它到底是什么样子的

44:53.950 --> 44:54.950
这个非常重要

44:54.950 --> 44:55.950
因为其实只有当你

44:55.950 --> 44:56.950
真正去了解的这个

44:56.950 --> 44:57.950
底层原理以后的话

44:57.950 --> 44:59.950
你才能更好的去避免

44:59.950 --> 45:01.950
BUG的一个产生

45:01.950 --> 45:02.950
有了以后的话

45:02.950 --> 45:04.950
你也可以更快的去把这个BUG

45:04.950 --> 45:05.950
捕捉到 订了一道

45:05.950 --> 45:06.950
给它调试回来

45:06.950 --> 45:07.950
那你做的网页

45:07.950 --> 45:08.950
它的性能也才会

45:08.950 --> 45:10.950
它更高模对不对

45:10.950 --> 45:11.950
那

45:11.950 --> 45:12.950
这边来给大家总结一句话对吧

45:12.950 --> 45:13.950
比如说

45:13.950 --> 45:14.950
只有你真正了解

45:14.950 --> 45:15.950
底层原理以后的话

45:15.950 --> 45:16.950
你才能走这种

45:16.950 --> 45:18.950
可持一化的一个发展

45:18.950 --> 45:19.950
那个道乎

45:19.950 --> 45:20.950
这个可持一化是什么意思

45:20.950 --> 45:21.950
就是你在公司

45:21.950 --> 45:22.950
如果说你千年

45:22.950 --> 45:23.950
干的是一样的一件事情

45:23.950 --> 45:24.950
对不对

45:24.950 --> 45:25.950
比如说你十年五年

45:25.950 --> 45:26.950
你干的是一样的事情

45:26.950 --> 45:27.950
你的心思按照

45:27.950 --> 45:28.950
每年固定的一个

45:28.950 --> 45:29.950
掌握就好像掌握的话

45:29.950 --> 45:30.950
你没有什么一个

45:30.950 --> 45:31.950
太好的一个

45:31.950 --> 45:32.950
这样的一个

45:32.950 --> 45:34.950
甚至一个机会

45:34.950 --> 45:35.950
那

45:35.950 --> 45:36.950
那你依旧是

45:36.950 --> 45:37.950
永远都是这样一个

45:37.950 --> 45:38.950
出局前的工程师

45:38.950 --> 45:40.950
但我希望大家

45:40.950 --> 45:41.950
能不断突破

45:41.950 --> 45:42.950
自己了解

45:42.950 --> 45:43.950
底层的这些原理

45:43.950 --> 45:45.950
往更高的一个阶层

45:45.950 --> 45:46.950
或者说

45:46.950 --> 45:47.950
往更高的这样一个心思

45:47.950 --> 45:49.950
去冲击

45:49.950 --> 45:50.950
那当然

45:50.950 --> 45:51.950
那最后呢

45:51.950 --> 45:52.950
还有这样的一句话

45:52.950 --> 45:53.950
就是

45:53.950 --> 45:54.950
如果你不去了解

45:54.950 --> 45:55.950
这样一个底层的话

45:55.950 --> 45:56.950
我给你

45:56.950 --> 45:57.950
你就会

45:57.950 --> 45:58.950
感受到一个

45:58.950 --> 45:59.950
怎么说呢

45:59.950 --> 46:00.950
感受到这样一个

46:00.950 --> 46:01.950
很深的一个危机感

46:01.950 --> 46:02.950
因为

46:02.950 --> 46:03.950
你会发现

46:03.950 --> 46:05.950
长江后浪推前浪

46:05.950 --> 46:06.950
对吧

46:06.950 --> 46:07.950
学前端的人

46:07.950 --> 46:08.950
或者说

46:08.950 --> 46:09.950
学互联网

46:09.950 --> 46:10.950
编程

46:10.950 --> 46:11.950
他们是

46:11.950 --> 46:12.950
一般

46:12.950 --> 46:13.950
一般的吧

46:13.950 --> 46:14.950
那后辈们

46:14.950 --> 46:15.950
可能

46:15.950 --> 46:16.950
很多同学呢

46:16.950 --> 46:17.950
是注意到了

46:17.950 --> 46:18.950
这个底层的一个重要性的

46:18.950 --> 46:19.950
那他们喜欢以后的话

46:19.950 --> 46:20.950
那他们的

46:20.950 --> 46:21.950
升职

46:21.950 --> 46:22.950
他们这样的一个

46:22.950 --> 46:23.950
经验的空间

46:23.950 --> 46:24.950
就比你还要多

46:24.950 --> 46:25.950
那即使你入行

46:25.950 --> 46:26.950
比他们早的话

46:26.950 --> 46:27.950
你也未必呢

46:27.950 --> 46:28.950
能取得一个

46:28.950 --> 46:29.950
比他们还要好的

46:29.950 --> 46:30.950
这样的一个结果

46:30.950 --> 46:31.950
所以说呢

46:31.950 --> 46:32.950
无论你现在

46:32.950 --> 46:33.950
是处于刚

46:33.950 --> 46:34.950
学习的一个状态

46:34.950 --> 46:35.950
还是说

46:35.950 --> 46:36.950
正在工作的一个状态

46:36.950 --> 46:37.950
还是说

46:37.950 --> 46:38.950
转业的一个状态

46:38.950 --> 46:39.950
我都希望你能

46:39.950 --> 46:40.950
把这个底层原理

46:40.950 --> 46:41.950
给它弄懂

46:41.950 --> 46:42.950
那最后呢

46:42.950 --> 46:44.950
希望大家

46:44.950 --> 46:45.950
对吧

46:45.950 --> 46:46.950
来加到我们这样的一个群之中

46:46.950 --> 46:48.950
你可以加到我们这样一个

46:48.950 --> 46:49.950
先加我们这样的一个小度

46:49.950 --> 46:50.950
加完小度以后的话

46:50.950 --> 46:51.950
小度会带你

46:51.950 --> 46:52.950
拉到我们这样的

46:52.950 --> 46:53.950
一个现场的工艺群

46:53.950 --> 46:55.950
我们现场工艺群呢

46:55.950 --> 46:57.950
有很多很多这样的

46:57.950 --> 46:58.950
在下的学员

46:58.950 --> 46:59.950
他们会在这里面

46:59.950 --> 47:00.950
讨论各种各样的

47:00.950 --> 47:01.950
一个前端的问题

47:01.950 --> 47:02.950
我们的老师呢

47:02.950 --> 47:03.950
也会

47:03.950 --> 47:04.950
二次老师的

47:04.950 --> 47:05.950
这个全天后的

47:05.950 --> 47:06.950
只要有时间的话

47:06.950 --> 47:07.950
就是都是会全天后的

47:07.950 --> 47:08.950
无条件的

47:08.950 --> 47:09.950
这样的一个答疑

47:09.950 --> 47:12.950
那以后有什么样的

47:12.950 --> 47:13.950
一些问题的话

47:13.950 --> 47:14.950
你都可以加到群中

47:14.950 --> 47:15.950
跟我们进入这样的

47:15.950 --> 47:16.950
一个讨论

47:16.950 --> 47:17.950
好

47:17.950 --> 47:18.950
那今天呢

47:18.950 --> 47:19.950
课程就到这里

47:19.950 --> 47:20.950
那我们下期再见

47:20.950 --> 47:21.950
拜拜

