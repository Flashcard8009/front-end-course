WEBVTT

00:00.000 --> 00:02.560
看继续说看独立教育给大家提供的

00:02.560 --> 00:05.000
你不知道GS系列的专题可诚

00:05.000 --> 00:08.000
我还是主教人 陈思虫

00:08.000 --> 00:12.000
这个依旧是我这样的一个帅气的自拍者

00:12.000 --> 00:16.000
我是咱们独立教育的前端的储复的人

00:16.000 --> 00:19.000
当然也是咱们独立的CTO

00:19.000 --> 00:22.000
今天我给大家带来的一个概念

00:22.000 --> 00:24.000
叫做一个惰性寒暑

00:24.000 --> 00:28.000
当然惰性寒暑其实我们在平常编程的时候

00:28.000 --> 00:31.000
尤其是你做一个初级功试的话

00:31.000 --> 00:32.000
你可能本来会注意这些

00:32.000 --> 00:36.000
但是一旦你要编一些高效的酷寒暑的话

00:36.000 --> 00:39.000
你就必须的把这样的一个概念考虑进去

00:39.000 --> 00:42.000
首先惰性寒暑它其实就是

00:42.000 --> 00:44.000
针对于那些平凡使用的寒暑

00:44.000 --> 00:47.000
一个优化的一个操作性的一个概念

00:47.000 --> 00:51.000
当然它常用在一些寒暑酷的编写

00:51.000 --> 00:54.000
包括在设计模式中

00:54.000 --> 00:56.000
有个模式叫做单立模式

00:56.000 --> 00:59.000
单立模式中也用到了这样的一个概念

00:59.000 --> 01:01.000
所以说才能实现这种

01:01.000 --> 01:03.000
你通过这样的一个单立模式

01:03.000 --> 01:05.000
所创建出的一些对象

01:05.000 --> 01:07.000
它永远它都是唯一的一个

01:07.000 --> 01:09.000
当然模式这一块

01:09.000 --> 01:11.000
我们后面在进阶课程

01:11.000 --> 01:14.000
就是我们对于它有这样一个进阶班的课程

01:14.000 --> 01:16.000
在这个课程之中会详细的去

01:16.000 --> 01:19.000
抛弃前端毙绘的极大设计模式

01:19.000 --> 01:21.000
并且把这个模式给你

01:21.000 --> 01:25.000
应用到组建和架构之中

01:25.000 --> 01:26.000
那这一块的话

01:26.000 --> 01:27.000
我只是简单给你提一下

01:27.000 --> 01:28.000
说有这么个东西

01:28.000 --> 01:29.000
我们度性函数呢

01:29.000 --> 01:31.000
其实也用到了几个

01:31.000 --> 01:32.000
我们度性函数的概念

01:32.000 --> 01:33.000
也用到了其中

01:33.000 --> 01:35.000
你想具体的去适用的了解的话

01:35.000 --> 01:37.000
那你可以去我们

01:37.000 --> 01:39.000
同一平台上去搜这样的一个

01:39.000 --> 01:40.000
度异

01:40.000 --> 01:41.000
排名第一呢

01:41.000 --> 01:43.000
说我们这样的一个GS工业课程

01:43.000 --> 01:45.000
你可以点你去看我们机构

01:45.000 --> 01:47.000
我们机构的话有很多其他的一个课程

01:47.000 --> 01:49.000
ok 那暂解说到这里

01:49.000 --> 01:50.000
我们先来回到主题

01:50.000 --> 01:52.000
来说一下这个度性函数

01:52.000 --> 01:54.000
ok 那这个度性函数的话

01:54.000 --> 01:56.000
讲它之前

01:56.000 --> 01:57.000
我还是要提个场景

01:57.000 --> 01:58.000
或者说提个

01:58.000 --> 02:00.000
提个demo吧

02:00.000 --> 02:02.000
要说要求我们写一个函数

02:02.000 --> 02:03.000
这个函数呢

02:03.000 --> 02:05.000
在首次调用时

02:05.000 --> 02:08.000
它要返回一个NewDate

02:08.000 --> 02:11.000
所NewDate的对象

02:11.000 --> 02:12.000
所调的该Time

02:12.000 --> 02:14.000
它所返回这样的一个好秒数

02:14.000 --> 02:16.000
那这里面你要注意的一点

02:16.000 --> 02:18.000
就是我第一次调用它的时候

02:18.000 --> 02:20.000
它才把这个时间计算出来

02:20.000 --> 02:21.000
那之后的话

02:21.000 --> 02:23.000
我再平函去调用很多次的话

02:23.000 --> 02:25.000
它也依旧是这样的一个时间

02:25.000 --> 02:26.000
那当然呢

02:26.000 --> 02:29.000
按照我们传统的一个实验方法的话

02:29.000 --> 02:31.000
我们可以这么做

02:31.000 --> 02:34.000
首先我方设一下

02:34.000 --> 02:36.000
在这里创建一个函数

02:36.000 --> 02:39.310
好 当我全局呢

02:39.310 --> 02:40.310
握一个T

02:40.310 --> 02:41.310
握一个T

02:41.310 --> 02:42.310
它等于乱

02:42.310 --> 02:43.310
一开始等于乱

02:43.310 --> 02:44.310
好 那在这个函数里面呢

02:44.310 --> 02:46.310
我可以上来先判断

02:46.310 --> 02:47.310
想先判断一下

02:47.310 --> 02:49.310
你这个T到底有没有值

02:49.310 --> 02:51.310
但如果有值的话

02:51.310 --> 02:52.310
我就把这个T反而出去

02:52.310 --> 02:53.310
但你要知道一点

02:53.310 --> 02:56.310
第一次的时候一定是没有值的

02:56.310 --> 02:57.310
一定是没有值的

02:57.310 --> 02:58.310
然后这个T呢

02:58.310 --> 03:02.310
等于一个NewDig的Gatian

03:02.310 --> 03:05.310
那这个时间或者成功以后的话

03:05.310 --> 03:07.310
我可以把这个时间再返回出来

03:07.310 --> 03:08.310
那也就是说

03:08.310 --> 03:09.310
现在这个逻辑就是

03:09.310 --> 03:10.310
第一次一定没有值的

03:10.310 --> 03:11.310
没有值的话

03:11.310 --> 03:13.310
好 我给这个T去附上这个值

03:13.310 --> 03:14.310
放置以后的话

03:14.310 --> 03:15.310
当这个函数在调的时候

03:15.310 --> 03:16.310
也就是说

03:16.310 --> 03:18.310
它第一次返回的一定是这个T

03:18.310 --> 03:20.310
也一定是通过这个Return

03:20.310 --> 03:21.310
来返回的值

03:21.310 --> 03:23.310
而不是通过这个F里面这个Return

03:23.310 --> 03:24.310
但你要知道一点

03:24.310 --> 03:25.310
但你第二次

03:25.310 --> 03:26.310
或者说第N次

03:26.310 --> 03:28.310
再去调这个函数的时候

03:28.310 --> 03:30.310
你上来都需要进行这样一个判断

03:30.310 --> 03:31.310
判断完了以后的话

03:31.310 --> 03:32.310
你都需要判断一下

03:32.310 --> 03:34.310
这个T到底有没有

03:34.310 --> 03:36.310
但第一次调的是没有的

03:36.310 --> 03:37.310
剩下其余的次数调用的话

03:37.310 --> 03:38.310
它都是有的

03:38.310 --> 03:39.310
那自然而然的话

03:39.310 --> 03:41.310
就会进到这个F之中去返回它

03:41.310 --> 03:42.310
那咱可以看一下

03:42.310 --> 03:47.310
我现在输出一个Test

03:47.310 --> 03:52.760
在这呢

03:52.760 --> 03:54.760
好 我再输出一遍

03:54.760 --> 03:57.760
当然我现在能把这样的一个东西

03:57.760 --> 03:58.760
复制4行

03:58.760 --> 04:00.760
复制4行以后的话

04:00.760 --> 04:01.760
我刷新一下

04:01.760 --> 04:02.760
咱们看一下

04:02.760 --> 04:03.760
在这个cancel里面

04:03.760 --> 04:05.760
你说它返回了这样的一个

04:05.760 --> 04:07.760
它只用了4次

04:07.760 --> 04:10.760
它返回了这个4次的这个好秒数

04:10.760 --> 04:12.760
它都是同一个

04:12.760 --> 04:14.760
那就证明一点

04:14.760 --> 04:15.760
有的时候

04:15.760 --> 04:16.760
当我们第一次在

04:16.760 --> 04:17.760
进行这个函数的时候

04:17.760 --> 04:22.760
它需要去通过NewData.guideTime

04:22.760 --> 04:24.760
去把这个时间获取到

04:24.760 --> 04:25.760
获取到以后的话

04:25.760 --> 04:28.760
等在之后的一些执行的过程中的话

04:28.760 --> 04:29.760
它返回的都是

04:29.760 --> 04:33.760
那个那一次它所获取这样的一个时间

04:33.760 --> 04:36.760
那这个情况基本上是满足我们说

04:36.760 --> 04:37.760
所说的这样的一个情况

04:37.760 --> 04:39.760
但你要知道一点

04:39.760 --> 04:40.760
这个函数如果说

04:40.760 --> 04:42.760
后续平凡的调用的话

04:42.760 --> 04:43.760
它就一定会

04:43.760 --> 04:46.760
每次都走遍F判断

04:46.760 --> 04:47.760
但其实我们知道

04:47.760 --> 04:49.760
当它执行完第一次以后的话

04:49.760 --> 04:50.760
就是我们开发者

04:50.760 --> 04:51.760
它已经知道

04:51.760 --> 04:52.760
当我们

04:52.760 --> 04:54.760
当它执行完第一次以后的话

04:54.760 --> 04:58.760
其实后面的这些测数

04:58.760 --> 05:00.760
它是完全可以

05:00.760 --> 05:02.760
不需要取经这样一个判断的

05:02.760 --> 05:04.760
因为这个T已经拿到手了

05:04.760 --> 05:05.760
对吧

05:05.760 --> 05:07.760
你直接使用这个T就OK了

05:07.760 --> 05:08.760
但是

05:08.760 --> 05:10.760
这个函数我们在编写的时候

05:10.760 --> 05:12.760
或者我们在定义的时候

05:12.760 --> 05:13.760
并没有把这样的一个

05:13.760 --> 05:15.760
主观的一个思想投到里面来

05:15.760 --> 05:16.760
接下来的话

05:16.760 --> 05:18.760
我们就需要对这样的函数

05:18.760 --> 05:19.760
进行一个改进

05:19.760 --> 05:21.760
把它改变成一个剁星寒兽

05:21.760 --> 05:22.760
但在改变成一个

05:22.760 --> 05:24.760
真正的剁星寒兽之前

05:24.760 --> 05:25.760
我来再说一下

05:25.760 --> 05:28.760
其实通过这样的一个

05:28.760 --> 05:30.760
通过这样的一个

05:30.760 --> 05:32.760
代码的一个逻辑吧

05:32.760 --> 05:37.760
它有几个点不太好

05:37.760 --> 05:38.760
第一点就是

05:38.760 --> 05:41.760
由于你生命的权局

05:41.760 --> 05:42.760
别量一个T

05:42.760 --> 05:43.760
那这样的话

05:43.760 --> 05:44.760
你通过一个寒兽

05:44.760 --> 05:45.760
再去

05:45.760 --> 05:46.760
执行动物的时候

05:46.760 --> 05:48.760
把这个外界的T给改变了

05:49.760 --> 05:50.760
这个不符合一个

05:50.760 --> 05:51.760
纯寒兽的一个概念

05:51.760 --> 05:52.760
但是纯寒兽的话

05:52.760 --> 05:53.760
我们在你不知道的

05:53.760 --> 05:54.760
GSC的战典里面

05:54.760 --> 05:55.760
咱有说过

05:55.760 --> 05:57.760
如果说你不懂的话

05:57.760 --> 05:58.760
你可以去看一看它

05:58.760 --> 06:00.760
那这是第一个不好的点

06:00.760 --> 06:01.760
第二个不好点的话

06:01.760 --> 06:02.760
也就是说

06:02.760 --> 06:04.760
像咱刚才说的这个AF

06:04.760 --> 06:06.760
你会执行很多次

06:06.760 --> 06:07.760
就是

06:07.760 --> 06:09.760
融入一些判断

06:09.760 --> 06:10.760
其实这个

06:10.760 --> 06:12.760
我们把这个弱兽

06:12.760 --> 06:13.760
我们把它只能改成

06:13.760 --> 06:14.760
一个剁星寒兽的话

06:14.760 --> 06:16.760
就可以完全避免掉

06:16.760 --> 06:18.760
多次这些平凡的

06:18.760 --> 06:19.760
无用的这样的一个判断

06:19.760 --> 06:20.760
当然

06:20.760 --> 06:21.760
第一次它一定是有用的

06:21.760 --> 06:22.760
第二次的话

06:22.760 --> 06:23.760
如何给它简化成

06:23.760 --> 06:25.760
不需要一个AF判断

06:25.760 --> 06:26.760
依旧可以返回

06:26.760 --> 06:27.760
这唯一一个T

06:27.760 --> 06:28.760
好

06:28.760 --> 06:29.760
别着急

06:29.760 --> 06:30.760
咱一个一个来

06:30.760 --> 06:31.760
首先

06:31.760 --> 06:32.760
我先把第一个问题

06:32.760 --> 06:33.760
解决

06:33.760 --> 06:35.760
就是权局变量T

06:35.760 --> 06:37.760
权局变量T

06:40.760 --> 06:41.760
当然我可以尝试

06:41.760 --> 06:42.760
使用这样的一个

06:43.760 --> 06:44.760
我可以尝试

06:44.760 --> 06:46.760
使用这样的一个B-Bow

06:46.760 --> 06:47.760
使用B-Bow的话

06:47.760 --> 06:48.760
我们都知道

06:48.760 --> 06:50.760
B-Bow其实是可以这样

06:50.760 --> 06:51.760
封闭综域的

06:51.760 --> 06:52.760
一般我们在写这样一个

06:52.760 --> 06:53.760
酷寒术的时候

06:53.760 --> 06:54.760
其实首先要

06:54.760 --> 06:55.760
低点就要考虑

06:55.760 --> 06:56.760
去封闭综域

06:56.760 --> 06:58.760
无论是变形Depth

06:58.760 --> 07:00.760
还得演这样Decorate

07:00.760 --> 07:01.760
这种GS Core

07:01.760 --> 07:02.760
它里面都定了

07:02.760 --> 07:03.760
大量的变量

07:03.760 --> 07:04.760
这些大量变量的话

07:04.760 --> 07:05.760
如果说

07:05.760 --> 07:06.760
一旦引到你的页面之中的话

07:06.760 --> 07:08.760
它不进行这样的一个

07:09.760 --> 07:10.760
封闭的话

07:10.760 --> 07:11.760
这么多变量的话

07:11.760 --> 07:12.760
一定会

07:12.760 --> 07:14.760
对你所变的项目

07:14.760 --> 07:16.760
有变量污染的一个效果

07:16.760 --> 07:17.760
所以说

07:17.760 --> 07:18.760
它在编写的时候

07:18.760 --> 07:19.760
都很注意

07:19.760 --> 07:20.760
把整个

07:20.760 --> 07:22.760
这样一个GS Core

07:22.760 --> 07:23.760
给它封闭这样的综域

07:23.760 --> 07:24.760
那这样的话

07:24.760 --> 07:26.760
我可以使用B-Bow的方式

07:26.760 --> 07:28.760
来进行综域的封闭

07:28.760 --> 07:29.760
但如果说你对B-Bow

07:29.760 --> 07:30.760
不是很了解的话

07:30.760 --> 07:31.760
我建议你

07:31.760 --> 07:32.760
去看一下我们

07:32.760 --> 07:34.760
独一GS的工艺课

07:34.760 --> 07:36.760
还是要在腾讯课堂上

07:36.760 --> 07:37.760
搜独一

07:37.760 --> 07:38.760
或者说在腾讯课堂上

07:38.760 --> 07:40.760
直接点前端

07:40.760 --> 07:41.760
我们那个前端

07:41.760 --> 07:42.760
点完以后的话

07:42.760 --> 07:44.760
搜的课程排名地位的

07:44.760 --> 07:45.760
就是我们

07:46.760 --> 07:48.760
那在这的话

07:49.760 --> 07:50.760
我现在呢

07:50.760 --> 07:51.760
还是为一个Test

07:51.760 --> 07:52.760
让它等一个

07:52.760 --> 07:53.760
立即执行函数

07:53.760 --> 07:55.760
一个执行的方式

07:55.760 --> 07:56.760
在这呢

07:56.760 --> 07:57.760
一直行执行完以后

07:59.760 --> 08:01.760
我要求它返回一个函数

08:01.760 --> 08:02.760
因为这个Test

08:02.760 --> 08:03.760
我必须的要求

08:03.760 --> 08:04.760
它最后是一个函数

08:04.760 --> 08:05.760
才能在后面陆续的

08:05.760 --> 08:06.760
就掉了很多次

08:06.760 --> 08:07.760
那如果这么做呢

08:07.760 --> 08:08.760
如果说我上来

08:08.760 --> 08:09.760
在这个地方

08:09.760 --> 08:10.760
在这个地方

08:10.760 --> 08:11.760
为一个T

08:11.760 --> 08:12.760
为个T以后的话

08:12.760 --> 08:13.760
在这我拥有一个Date

08:13.760 --> 08:14.760
完了之后

08:14.760 --> 08:15.760
再应该Time

08:15.760 --> 08:16.760
好

08:16.760 --> 08:17.760
那这样的话

08:17.760 --> 08:19.760
我在这个新访的函数里面

08:19.760 --> 08:20.760
执行的功能

08:20.760 --> 08:21.760
只是返回一个T而已的话

08:21.760 --> 08:22.760
那这样的话

08:22.760 --> 08:23.760
咱来看一下

08:23.760 --> 08:25.760
究竟可不可以呢

08:25.760 --> 08:27.760
究竟可不可以做到

08:27.760 --> 08:29.760
但它已经做到了这个T

08:29.760 --> 08:31.760
它没有进行这样的一个

08:31.760 --> 08:32.760
全局变成一个误览

08:32.760 --> 08:33.760
对吧

08:33.760 --> 08:35.760
它只是封闭到了这样的一个

08:35.760 --> 08:36.760
自己的AO之中

08:36.760 --> 08:38.760
或者是封闭到了这样的

08:38.760 --> 08:39.760
误览中

08:39.760 --> 08:40.760
那当然呢

08:40.760 --> 08:41.760
我这么去执行一下

08:41.760 --> 08:42.760
咱看效果

08:42.760 --> 08:43.760
到底可不可以

08:43.760 --> 08:44.760
OK 确实是出

08:44.760 --> 08:45.760
两个条件的值

08:45.760 --> 08:46.760
对吧

08:46.760 --> 08:47.760
但是呢

08:47.760 --> 08:49.760
它另一个问题

08:49.760 --> 08:50.760
又出现了

08:50.760 --> 08:52.760
这个问题就是

08:52.760 --> 08:54.760
你在就是

08:54.760 --> 08:56.760
你在这个T的一个计算的时候

08:56.760 --> 08:57.760
并不是在我

08:57.760 --> 08:59.760
第一次执行的时候

08:59.760 --> 09:00.760
去计算的

09:00.760 --> 09:01.760
可是怎么样

09:01.760 --> 09:02.760
而是在这个立即这样

09:02.760 --> 09:03.760
执行的时候

09:03.760 --> 09:04.760
或者说是

09:04.760 --> 09:05.760
当初始化

09:05.760 --> 09:06.760
这个Test变量的时候

09:06.760 --> 09:07.760
它就已经把这个

09:07.760 --> 09:08.760
这个计算出来了

09:08.760 --> 09:09.760
那这样的话

09:09.760 --> 09:10.760
显然不符合

09:10.760 --> 09:11.760
我们刚才所说的

09:11.760 --> 09:12.760
这样的一个标准

09:12.760 --> 09:13.760
因为呢

09:13.760 --> 09:14.760
在下面我们说了

09:14.760 --> 09:15.760
这个函数

09:15.760 --> 09:16.760
返回首次

09:16.760 --> 09:19.760
所调的那个时候的时间

09:19.760 --> 09:20.760
这门说了

09:20.760 --> 09:21.760
注意是首次

09:21.760 --> 09:22.760
而且其实呢

09:22.760 --> 09:23.760
我们如果说

09:23.760 --> 09:24.760
把这个多型函数的概念

09:24.760 --> 09:25.760
牵一到了

09:25.760 --> 09:26.760
其他的扣函数之中的话

09:26.760 --> 09:27.760
我们也是

09:27.760 --> 09:28.760
要在首次

09:28.760 --> 09:30.760
去执行这个函数

09:30.760 --> 09:31.760
功能的时候

09:31.760 --> 09:32.760
才要进行这样的一个

09:32.760 --> 09:34.760
初始化的一个计算

09:34.760 --> 09:35.760
但这里面呢

09:35.760 --> 09:36.760
不行对吧

09:36.760 --> 09:38.760
这门我直接就去计算了

09:38.760 --> 09:39.760
并不是在首次的时候

09:39.760 --> 09:40.760
才去计算的

09:40.760 --> 09:41.760
那好了

09:41.760 --> 09:42.760
那我这么做

09:42.760 --> 09:43.760
我这么做

09:43.760 --> 09:44.760
把他扛上S下

09:44.760 --> 09:45.760
对吧

09:45.760 --> 09:46.760
我不这么改了

09:46.760 --> 09:47.760
我在这把F判断一下

09:47.760 --> 09:48.760
我看你个T有没有值

09:48.760 --> 09:49.760
当然

09:49.760 --> 09:50.760
如果说你有值的话

09:50.760 --> 09:52.760
我就直接返回T

09:52.760 --> 09:53.760
但我在上面

09:53.760 --> 09:54.760
还是需要位个T的

09:54.760 --> 09:58.200
它T一开始是一个难

09:58.200 --> 09:59.200
OK

09:59.200 --> 10:00.200
那这样的话

10:00.200 --> 10:01.200
我还是要在这边看一下

10:01.200 --> 10:02.200
你有没有T

10:02.200 --> 10:03.200
如果有T的话

10:03.200 --> 10:04.200
直接返回你

10:04.200 --> 10:05.200
那没有T的话

10:06.200 --> 10:07.200
对吧

10:07.200 --> 10:08.200
应该T

10:08.200 --> 10:09.200
现在你这么做的话

10:09.200 --> 10:10.200
咱俩看一看

10:10.200 --> 10:11.200
行不行呢

10:11.200 --> 10:12.200
刷新一次

10:12.200 --> 10:14.200
当然这是可以的对吧

10:14.200 --> 10:15.200
他确实解决了

10:15.200 --> 10:18.200
这个拳击变量弯的一个问题

10:18.200 --> 10:19.200
同时呢

10:19.200 --> 10:20.200
他也解决了

10:20.200 --> 10:22.200
这个首次DOWN的一个问题

10:22.200 --> 10:23.200
但是呢

10:23.200 --> 10:24.200
他依旧没有解决

10:24.200 --> 10:25.200
我们刚才

10:25.200 --> 10:27.200
在这说的一个问题

10:27.200 --> 10:28.200
就是

10:28.200 --> 10:29.200
这个函数

10:29.200 --> 10:30.200
他执行完第1次以后的话

10:30.200 --> 10:31.200
他执行第2次

10:31.200 --> 10:32.200
或者说

10:32.200 --> 10:34.200
他执行第3次

10:34.200 --> 10:35.200
第4次

10:35.200 --> 10:36.200
哪怕第N次的话

10:36.200 --> 10:37.200
他也需要

10:37.200 --> 10:38.200
每次执行的时候

10:38.200 --> 10:39.200
都上来判断一下

10:39.200 --> 10:41.200
这个T到底有没有指导

10:41.200 --> 10:42.200
我们其实

10:42.200 --> 10:43.200
自己开发者心里

10:43.200 --> 10:44.200
都已经知道了

10:44.200 --> 10:45.200
第一次执行完

10:45.200 --> 10:46.200
他一定是有指的

10:46.200 --> 10:47.200
那我们可不可以

10:47.200 --> 10:48.200
通过一种方式

10:48.200 --> 10:49.200
去改进他一下呢

10:49.200 --> 10:51.200
当他执行完第1次以后的话

10:51.200 --> 10:53.200
之后的执行

10:53.200 --> 10:54.200
我们都不需要判断

10:54.200 --> 10:55.200
直接返回这个职

10:55.200 --> 10:56.200
就可以了

10:56.200 --> 10:57.200
那就是剁新函数的

10:57.200 --> 10:58.200
一个真实的一个概念

10:58.200 --> 11:00.200
那我们在这呢

11:00.200 --> 11:02.200
给他给你去进行一个

11:03.200 --> 11:04.200
进行这样的一个

11:04.200 --> 11:05.200
完美版多型函数的

11:05.200 --> 11:06.200
一个编写

11:06.200 --> 11:07.200
但是呢

11:07.200 --> 11:09.200
前提要求他还是这样的

11:09.200 --> 11:11.200
就是我们说说的

11:11.200 --> 11:13.200
前看数

11:13.200 --> 11:14.200
首次的时候

11:14.200 --> 11:15.200
调用他

11:15.200 --> 11:16.200
是在你首次调用他的时候

11:16.200 --> 11:17.200
他要返回一个时间

11:17.200 --> 11:18.200
这里面一定要注意

11:18.200 --> 11:19.200
是首次

11:19.200 --> 11:20.200
而且呢

11:20.200 --> 11:21.200
只要复制加了几个条件

11:21.200 --> 11:22.200
就是你不要

11:22.200 --> 11:23.200
对吧 进行全体辩论

11:23.200 --> 11:24.200
污染

11:24.200 --> 11:25.200
好 那在这的话

11:25.200 --> 11:27.200
我们来看一下

11:27.200 --> 11:28.200
首先呢

11:28.200 --> 11:29.200
我握一个Test

11:29.200 --> 11:30.200
还是握一个Test

11:30.200 --> 11:31.200
在这呢

11:31.200 --> 11:32.200
我握一个

11:32.200 --> 11:34.200
立即函数

11:34.200 --> 11:38.940
好

11:38.940 --> 11:39.940
在这呢

11:39.940 --> 11:40.940
我握一个函数

11:41.940 --> 11:42.940
其实或者说

11:42.940 --> 11:43.940
我干脆吧

11:43.940 --> 11:45.940
其实就没有必要

11:45.940 --> 11:47.940
写这样一个必包了

11:47.940 --> 11:48.940
我可以这么做

11:48.940 --> 11:50.940
我可以

11:50.940 --> 11:51.940
没有必要写

11:51.940 --> 11:52.940
通过写立即函数

11:52.940 --> 11:53.940
来来来

11:53.940 --> 11:54.940
成这样的一个必包了

11:54.940 --> 11:55.940
我们换种方式

11:55.940 --> 11:56.940
其实

11:56.940 --> 11:57.940
里面也有这样的

11:57.940 --> 11:58.940
必包的一个概念了

11:58.940 --> 11:59.940
好

11:59.940 --> 12:00.940
现在我握一下

12:00.940 --> 12:01.940
Test的一个函数

12:01.940 --> 12:02.940
这个函数呢

12:02.940 --> 12:03.940
算是我做的

12:03.940 --> 12:04.940
当然

12:04.940 --> 12:05.940
这边我就补判断了

12:05.940 --> 12:06.940
我就直接给Test

12:06.940 --> 12:07.940
放一个字

12:07.940 --> 12:08.940
叫NewDate

12:08.940 --> 12:09.940
GateTime

12:09.940 --> 12:11.940
那要说

12:11.940 --> 12:12.940
这个还是在

12:12.940 --> 12:14.940
第一次执行的时候呢

12:14.940 --> 12:15.940
我就一定要把

12:15.940 --> 12:17.940
这个Test返还出去

12:17.940 --> 12:18.940
那这样的话

12:18.940 --> 12:19.940
我在执行这个Test的时候

12:19.940 --> 12:20.940
执行很多

12:20.940 --> 12:21.940
那我执行第四个时候

12:21.940 --> 12:22.940
这个Test

12:22.940 --> 12:23.940
一定是

12:23.940 --> 12:24.940
计算出一个新的指示

12:24.940 --> 12:25.940
把他返回出去了

12:25.940 --> 12:27.940
但是我在执行

12:27.940 --> 12:28.940
第二次的时候

12:28.940 --> 12:33.220
执行第三次的时候呢

12:33.220 --> 12:34.220
按照这个代码的逻辑

12:34.220 --> 12:35.220
给他当然需要

12:35.220 --> 12:36.220
重新去计算

12:36.220 --> 12:37.220
好了

12:37.220 --> 12:38.220
那我们怎么办呢

12:38.220 --> 12:39.220
就这样吧

12:39.220 --> 12:40.220
你要明白一个概念

12:40.220 --> 12:41.220
这个概念就是

12:41.220 --> 12:43.220
首先函数

12:43.220 --> 12:45.220
无论是你通过函数声名

12:45.220 --> 12:46.220
来定一个函数

12:46.220 --> 12:48.220
还是通过这样的一个

12:48.220 --> 12:49.220
函数表达式

12:49.220 --> 12:51.220
这叫做函数表达式

12:51.220 --> 12:52.220
来定一个函数

12:52.220 --> 12:54.220
你知道这个名字

12:54.220 --> 12:55.220
函数的名字

12:55.220 --> 12:56.220
它其实本身是个变量

12:56.220 --> 12:57.220
它里面存的呢

12:57.220 --> 12:59.220
是一个函数的一个

12:59.220 --> 13:00.220
一用值

13:00.220 --> 13:01.220
其实函数呢

13:01.220 --> 13:03.220
它本身也是一种数据

13:03.220 --> 13:04.220
那这样的话

13:04.220 --> 13:05.220
我们是不是可以知道

13:05.220 --> 13:06.220
这个变量是可以存任何

13:06.220 --> 13:08.220
只能进行这样的一个改变

13:08.220 --> 13:09.220
在我们这个GS

13:09.220 --> 13:10.220
这个弱了性原主

13:10.220 --> 13:11.220
它是很灵活的

13:11.220 --> 13:13.220
那既然是这样的话

13:13.220 --> 13:14.220
我们就可以考虑一下

13:14.220 --> 13:16.220
当你第一次把这个值算完以后的话

13:16.220 --> 13:19.220
我是否可以把这个Test

13:19.220 --> 13:21.220
这个变量所存的函数

13:21.220 --> 13:22.220
给你改变一下

13:22.220 --> 13:23.220
给你换成另外一个函数

13:23.220 --> 13:24.220
那这个函数呢

13:24.220 --> 13:25.220
放在这个T

13:25.220 --> 13:27.220
那其实在这个地方呢

13:27.220 --> 13:29.220
就真正的形成了一个B包

13:29.220 --> 13:30.220
就像那个B包

13:30.220 --> 13:32.220
那当然呢

13:32.220 --> 13:33.220
我在这如果说

13:33.220 --> 13:36.220
直接返回一个T的话

13:36.220 --> 13:40.220
如果说我在这直接去返回一个T的话

13:40.220 --> 13:43.220
那显然咱看起来的话

13:43.220 --> 13:46.220
可能在这里面Test

13:46.220 --> 13:48.220
没有参加什么事的

13:48.220 --> 13:49.220
但咱先不用管

13:49.220 --> 13:50.220
咱先看一下我这么写

13:50.220 --> 13:51.220
好不好使吧

13:51.220 --> 13:54.220
行吧 上一次的看一眼

13:54.220 --> 13:57.220
在这来个Test

13:57.220 --> 13:58.220
再来个Test

13:58.220 --> 13:59.220
再来个Test

13:59.220 --> 14:01.220
这样其实都OK的

14:01.220 --> 14:02.220
那这边呢

14:02.220 --> 14:05.220
只是为了在这个函数的内部

14:05.220 --> 14:07.220
体验出Test的一个用处吧

14:07.220 --> 14:09.220
我在这把这个地方

14:09.220 --> 14:10.220
就不直接去返回T了

14:10.220 --> 14:13.220
而是直接返回一个

14:13.220 --> 14:15.220
它的执行

14:15.220 --> 14:16.220
那这样的话

14:16.220 --> 14:17.220
咱来看一下

14:17.220 --> 14:22.580
刷新一次

14:22.580 --> 14:23.580
那也就是说

14:23.580 --> 14:24.580
我们这个Test

14:24.580 --> 14:26.580
是从哪儿开始来启动的

14:26.580 --> 14:27.580
就是从这个

14:27.580 --> 14:28.580
就是我们新的Test

14:28.580 --> 14:30.580
其实从这个返回直中

14:30.580 --> 14:31.580
就开始启动了

14:31.580 --> 14:34.950
好了 那咱看一下

14:34.950 --> 14:35.950
刷新一次

14:35.950 --> 14:36.950
现在我使用了三次

14:36.950 --> 14:38.950
也会怕再刷新一下

14:38.950 --> 14:39.950
它都是一样的

14:39.950 --> 14:42.950
都是返回首次执行的那个时间

14:42.950 --> 14:43.950
而且这里面

14:43.950 --> 14:45.950
没有全局变量的那个污染

14:45.950 --> 14:46.950
但这个T

14:46.950 --> 14:47.950
这个T我没有wort对吧

14:47.950 --> 14:48.950
如果说我没有wort的话

14:48.950 --> 14:50.950
那这里面就麻烦了

14:50.950 --> 14:53.950
那它就是一个暗示全局变量

14:53.950 --> 14:55.950
为什么是暗示全局变量的话

14:55.950 --> 14:56.950
这个我们GS攻击科

14:56.950 --> 14:57.950
它也有说

14:57.950 --> 14:58.950
你可以去看一看

14:58.950 --> 15:00.950
这边我还是需要去wort它

15:00.950 --> 15:01.950
去wort它

15:01.950 --> 15:02.950
好 我们再来一遍

15:02.950 --> 15:03.950
看一看

15:03.950 --> 15:05.950
可以三个相同的值

15:05.950 --> 15:06.950
那也说

15:06.950 --> 15:08.950
这就是剁新函数的一个

15:08.950 --> 15:10.950
最基本的一个概念吧

15:10.950 --> 15:12.950
就是一个函数

15:12.950 --> 15:15.950
在定义你们内部功能的时候

15:15.950 --> 15:17.950
其实在内部

15:17.950 --> 15:19.950
我们又重写了函数

15:19.950 --> 15:21.950
但是当这个

15:21.950 --> 15:23.950
但是当这个函数执行之后

15:23.950 --> 15:24.950
它在一个返回直

15:24.950 --> 15:25.950
或者说

15:25.950 --> 15:26.950
它起到的

15:26.950 --> 15:28.950
第一次执行的一个这种的话

15:28.950 --> 15:30.950
当然跟它本次定义

15:30.950 --> 15:31.950
一定是有关的

15:31.950 --> 15:32.950
好了

15:32.950 --> 15:35.950
那可能这个概念咱大概理解了

15:35.950 --> 15:36.950
理解了以后的话

15:36.950 --> 15:37.950
怎么去应用呢

15:37.950 --> 15:39.950
这个就很重要了

15:39.950 --> 15:42.950
前面这样的一些演变的过程呢

15:42.950 --> 15:43.950
你仔细听听

15:43.950 --> 15:45.950
听懂个70%

15:45.950 --> 15:47.950
听懂个50% 60%就可以了

15:47.950 --> 15:50.950
接下来咱拿一个具体的一个

15:50.950 --> 15:52.950
就是风招的一个函数

15:52.950 --> 15:54.950
或者说我们具体常用的

15:54.950 --> 15:56.950
频繁使用的一个函数

15:56.950 --> 15:58.950
来做这样的一个模拟用

15:58.950 --> 16:00.950
当然我们知道

16:00.950 --> 16:01.950
我们使用ZQ2也好

16:01.950 --> 16:02.950
或者说是

16:02.950 --> 16:04.950
你看我们这样的一个独一供应课

16:04.950 --> 16:06.950
我们前期带你去风招

16:06.950 --> 16:08.950
这样一个保定实验的函数也好

16:08.950 --> 16:10.950
这样的一个功能

16:10.950 --> 16:12.950
都是被频繁去使用的

16:12.950 --> 16:13.950
那你要想

16:13.950 --> 16:14.950
一个酷的编写也好

16:14.950 --> 16:16.950
还是说你自己想写了一个

16:16.950 --> 16:17.950
兼容性的函数也好

16:17.950 --> 16:19.950
你都需要知道

16:19.950 --> 16:21.950
首先你需要让它

16:21.950 --> 16:24.950
在各种练习期中都可以去运行

16:24.950 --> 16:25.950
这是第一步

16:25.950 --> 16:26.950
第二步就是你要知道

16:26.950 --> 16:27.950
这个功能既然被风招出来的

16:27.950 --> 16:29.950
那就一定是被频繁去使用的

16:29.950 --> 16:30.950
那这个里面

16:30.950 --> 16:31.950
我们就可以把这个

16:31.950 --> 16:32.950
惰性函数的概念

16:32.950 --> 16:33.950
给它引到里面来

16:33.950 --> 16:34.950
那咱们来看一下

16:34.950 --> 16:35.950
我现在方式一个

16:35.950 --> 16:36.950
AddEvent

16:37.950 --> 16:38.950
AddEvent

16:38.950 --> 16:40.950
那要绑定一个实验的话

16:40.950 --> 16:41.950
在这的话

16:41.950 --> 16:42.950
可以传递三个参数

16:42.950 --> 16:44.950
第一就是你要给谁绑的实验

16:44.950 --> 16:45.950
当然呢

16:45.950 --> 16:46.950
要绑定什么实验

16:46.950 --> 16:47.950
三个呢

16:47.950 --> 16:48.950
这个实验的处理

16:48.950 --> 16:49.950
还是它是谁

16:49.950 --> 16:50.950
那我可以在这个里面

16:50.950 --> 16:51.950
好

16:51.950 --> 16:52.950
来去

16:52.950 --> 16:53.950
首先呢

16:53.950 --> 16:54.950
判断一下

16:54.950 --> 16:55.950
看一下你这个

16:55.950 --> 16:57.950
当前我这个627

16:57.950 --> 16:58.950
所运行的这个页面

16:58.950 --> 16:59.950
对吧

16:59.950 --> 17:01.950
它是否支持到我们下面的

17:01.950 --> 17:03.950
AddEventListener

17:03.950 --> 17:04.950
这个方法

17:05.950 --> 17:06.950
但如果你支持的话

17:06.950 --> 17:07.950
我就通过

17:07.950 --> 17:08.950
它来调用一下

17:08.950 --> 17:09.950
AddEventListener

17:09.950 --> 17:10.950
在这呢

17:10.950 --> 17:11.950
先传一个tab类型

17:11.950 --> 17:12.950
再传一个

17:13.950 --> 17:14.950
你的一个

17:16.950 --> 17:17.950
HALD

17:17.950 --> 17:18.950
再传一下你这样的

17:18.950 --> 17:19.950
实验处理函数

17:19.950 --> 17:20.950
之后呢

17:20.950 --> 17:21.950
再传一下是否

17:21.950 --> 17:22.950
是否采用

17:22.950 --> 17:24.950
这个世界冒泡的这样的一个

17:24.950 --> 17:26.950
补货的一个

17:26.950 --> 17:27.950
是否采用

17:27.950 --> 17:28.950
这样的一个

17:28.950 --> 17:29.950
实验冒泡

17:29.950 --> 17:30.950
这种实验处理模型

17:30.950 --> 17:32.950
当你添 false的话

17:32.950 --> 17:33.950
就是采用

17:33.950 --> 17:34.950
实验冒泡这样的

17:34.950 --> 17:35.950
处理模型

17:35.950 --> 17:36.950
你添出的话

17:36.950 --> 17:37.950
就是采用

17:37.950 --> 17:38.950
实验补货

17:38.950 --> 17:39.950
好了

17:39.950 --> 17:40.950
我在 else 一下

17:40.950 --> 17:41.950
在 else 下的话

17:41.950 --> 17:42.950
我在这呢

17:42.950 --> 17:43.950
就是如果你没有

17:43.950 --> 17:45.950
w3c推荐的这样的

17:45.950 --> 17:46.950
AddEventListener

17:46.950 --> 17:47.950
这个方法的话

17:47.950 --> 17:48.950
那证明你可能是

17:48.950 --> 17:49.950
ie 的老版本的

17:49.950 --> 17:50.950
对不对

17:50.950 --> 17:51.950
那我就可以通过

17:51.950 --> 17:53.950
attach event 对吧

17:53.950 --> 17:54.950
它是 event

17:54.950 --> 17:55.950
来进行这样的

17:55.950 --> 17:56.950
实验的一个

17:56.950 --> 17:57.950
在这里还是

17:57.950 --> 17:58.950
第一个呢

17:58.950 --> 17:59.950
是存在了

17:59.950 --> 18:00.950
一个世界的类型

18:00.950 --> 18:01.950
第二个呢

18:01.950 --> 18:02.950
是来传一下

18:02.950 --> 18:03.950
世界的处理函数

18:03.950 --> 18:04.950
ok

18:04.950 --> 18:05.950
那这个是我们之前

18:05.950 --> 18:06.950
所做的这样的

18:06.950 --> 18:07.950
简单的一个封装

18:07.950 --> 18:09.950
但这样它真的好吗

18:09.950 --> 18:10.950
它一定不是

18:10.950 --> 18:11.950
它做了一个

18:11.950 --> 18:12.950
cool的话

18:12.950 --> 18:13.950
它一定不是非常好的

18:13.950 --> 18:14.950
因为你要知道

18:14.950 --> 18:15.950
这个函数

18:15.950 --> 18:16.950
一旦被封装出来以后的话

18:16.950 --> 18:17.950
它就会被平衡地使用

18:17.950 --> 18:18.950
但是你要知道

18:18.950 --> 18:19.950
如果说

18:19.950 --> 18:20.950
你每次使用一次它

18:20.950 --> 18:21.950
对吧

18:21.950 --> 18:22.950
每次使用一次它

18:22.950 --> 18:23.950
好

18:23.950 --> 18:24.950
你执行

18:25.950 --> 18:27.950
当你执行完以后的话

18:27.950 --> 18:28.950
它就一定会进到

18:28.950 --> 18:29.950
这个

18:29.950 --> 18:30.950
一定会进到这样的

18:30.950 --> 18:31.950
一个判断里面来

18:31.950 --> 18:32.950
那进到这个

18:32.950 --> 18:33.950
判断里面来以后的话

18:34.950 --> 18:35.950
好

18:35.950 --> 18:36.950
当然它第一次

18:36.950 --> 18:37.950
进完了之后

18:37.950 --> 18:38.950
它一定会按照这样的

18:38.950 --> 18:39.950
一个方式

18:39.950 --> 18:40.950
比如说是这样

18:40.950 --> 18:41.950
我在comment

18:41.950 --> 18:42.950
里面去进行

18:42.950 --> 18:43.950
好

18:43.950 --> 18:44.950
好

18:44.950 --> 18:45.950
这个函数

18:45.950 --> 18:46.950
在第一次它进行的时候呢

18:46.950 --> 18:47.950
ok

18:47.950 --> 18:48.950
它就一定会进到

18:48.950 --> 18:49.950
进到这个判断

18:49.950 --> 18:50.950
那这个判断的话

18:50.950 --> 18:51.950
ok

18:51.950 --> 18:52.950
会走到这个里面来

18:52.950 --> 18:53.950
那ok

18:53.950 --> 18:54.950
过一遍了

18:54.950 --> 18:55.950
对吧

18:55.950 --> 18:56.950
其实我们是希望

18:56.950 --> 18:57.950
这个

18:57.950 --> 18:58.950
这个剁新函数

18:58.950 --> 18:59.950
它并不是真的懒

18:59.950 --> 19:00.950
而是呢

19:00.950 --> 19:01.950
它有这样一个

19:01.950 --> 19:03.950
就是类似于记忆的

19:03.950 --> 19:04.950
一个功能

19:04.950 --> 19:05.950
就是当你第一次

19:05.950 --> 19:06.950
已经走到这以后的话

19:06.950 --> 19:07.950
那好了

19:07.950 --> 19:08.950
那我后面的话

19:08.950 --> 19:09.950
就没有必要

19:09.950 --> 19:10.950
再进行平凡的一次

19:10.950 --> 19:11.950
判断

19:11.950 --> 19:12.950
对吧

19:12.950 --> 19:13.950
因为我已经知道了

19:13.950 --> 19:14.950
我这个代码

19:14.950 --> 19:15.950
是跑在

19:15.950 --> 19:16.950
支持AdVan

19:16.950 --> 19:17.950
的类似的

19:17.950 --> 19:18.950
这个环境之中的

19:18.950 --> 19:19.950
那以后的话

19:19.950 --> 19:20.950
那我

19:20.950 --> 19:21.950
但凡从AdVan

19:21.950 --> 19:22.950
来绑定

19:22.950 --> 19:23.950
再判断呢

19:23.950 --> 19:24.950
对吧

19:24.950 --> 19:25.950
每次都杀了

19:25.950 --> 19:26.950
判断

19:26.950 --> 19:27.950
这样的话

19:27.950 --> 19:28.950
显得比较low

19:28.950 --> 19:29.950
那我们可以怎么做呢

19:29.950 --> 19:30.950
当然我们可以这么做

19:30.950 --> 19:31.950
按照

19:31.950 --> 19:32.950
上面这样的

19:32.950 --> 19:33.950
剁新函数的一个

19:33.950 --> 19:34.950
变形方式

19:34.950 --> 19:35.950
我们来的话

19:35.950 --> 19:36.950
就是这么来写

19:36.950 --> 19:37.950
我让AdInVan

19:37.950 --> 19:38.950
给它

19:38.950 --> 19:39.950
改成一个

19:39.950 --> 19:41.950
另外一个函数

19:41.950 --> 19:42.950
在这呢

19:42.950 --> 19:43.950
我让它

19:43.950 --> 19:44.950
接受三个参数

19:44.950 --> 19:45.950
这三个参数

19:45.950 --> 19:46.950
跟在上面是一样的

19:46.950 --> 19:47.950
ok

19:47.950 --> 19:48.950
那在这呢

19:48.950 --> 19:49.950
我把它

19:49.950 --> 19:50.950
再拿过来

19:51.950 --> 19:52.950
放这边来

19:52.950 --> 19:53.950
ok

19:53.950 --> 19:54.950
同样的道理

19:54.950 --> 19:55.950
在这呢

19:55.950 --> 19:56.950
也是啊

19:56.950 --> 19:57.950
如果说你第一次

19:57.950 --> 19:58.950
走的就是

19:58.950 --> 19:59.950
AdVan的话

19:59.950 --> 20:01.950
那我就完全可以

20:01.950 --> 20:02.950
按AdInVan了

20:02.950 --> 20:03.950
对吧

20:03.950 --> 20:04.950
变成这样的

20:05.950 --> 20:07.950
也是接受三个参数

20:07.950 --> 20:08.950
只不过这里面

20:08.950 --> 20:09.950
是第二个

20:09.950 --> 20:10.950
AdInVan了

20:10.950 --> 20:11.950
对吧

20:11.950 --> 20:12.950
但AdInVan

20:12.950 --> 20:13.950
的时候呢

20:13.950 --> 20:14.950
第一个参数

20:14.950 --> 20:15.950
需要加个

20:15.950 --> 20:16.950
加Tab

20:16.950 --> 20:17.950
好

20:17.950 --> 20:18.950
再来一个

20:18.950 --> 20:19.950
Helder

20:19.950 --> 20:20.950
那通过这样的一个

20:20.950 --> 20:21.950
多性的方法

20:21.950 --> 20:22.950
的一个植入的话

20:22.950 --> 20:23.950
那我们

20:23.950 --> 20:24.950
通过这个AdInVan的

20:24.950 --> 20:26.950
第一次在调用的时候

20:26.950 --> 20:27.950
它

20:27.950 --> 20:28.950
比如说走到了A分里面来

20:28.950 --> 20:29.950
那紧接着

20:29.950 --> 20:30.950
这个AdInVan的

20:30.950 --> 20:31.950
就喊出

20:31.950 --> 20:32.950
其实它本身发生了改变

20:32.950 --> 20:33.950
那发生改变的话

20:33.950 --> 20:35.950
最后所呈现出的一个状态

20:35.950 --> 20:36.950
就仿佛有了这样的

20:36.950 --> 20:37.950
记忆的一个功能

20:37.950 --> 20:38.950
就是之后

20:38.950 --> 20:39.950
你再去使用它的话

20:39.950 --> 20:40.950
它其实都

20:40.950 --> 20:41.950
它其实都是

20:41.950 --> 20:42.950
不通过判断

20:42.950 --> 20:44.950
而是直接去使用

20:44.950 --> 20:45.950
这个AdInVan的

20:45.950 --> 20:46.950
或者说

20:46.950 --> 20:47.950
直接去使用

20:47.950 --> 20:48.950
它是AdInVan的吧

20:48.950 --> 20:49.950
所以你这个运行

20:49.950 --> 20:50.950
改变面的

20:50.950 --> 20:51.950
一个环境是有关的

20:51.950 --> 20:52.950
那OK

20:52.950 --> 20:53.950
那咱可以拿它

20:53.950 --> 20:54.950
去试一试

20:54.950 --> 20:55.950
去试试

20:55.950 --> 20:56.950
它是否真正有这样的

20:56.950 --> 20:57.950
一个多性的一个功能

20:57.950 --> 20:58.950
对吧

20:58.950 --> 20:59.950
是否变成真正

20:59.950 --> 21:00.950
这样一个

21:00.950 --> 21:01.950
多性的函数

21:01.950 --> 21:02.950
再帮我伸一下

21:08.080 --> 21:09.080
在这呢

21:09.080 --> 21:11.080
我来给你写一个DIV

21:11.080 --> 21:12.080
再来个ID

21:12.080 --> 21:13.080
ID

21:13.080 --> 21:14.080
来个demo

21:14.080 --> 21:15.080
就在个Style

21:15.080 --> 21:16.080
行间样式

21:17.080 --> 21:18.080
那如果说

21:18.080 --> 21:19.080
你真正在开发的时候的话

21:19.080 --> 21:20.080
你这样

21:20.080 --> 21:21.080
不要这么去写

21:21.080 --> 21:22.080
不要去给

21:22.080 --> 21:23.080
一个标签的吧

21:23.080 --> 21:24.080
手动的

21:24.080 --> 21:25.080
加上一个行间样式

21:25.080 --> 21:27.080
我们要注重行为

21:27.080 --> 21:28.080
叫做行为

21:28.080 --> 21:29.080
结构样式

21:29.080 --> 21:30.080
相分离样

21:30.080 --> 21:31.080
这样的一个变成的规范

21:31.080 --> 21:32.080
好

21:32.080 --> 21:33.080
在这呢

21:33.080 --> 21:34.080
我来个

21:34.080 --> 21:35.080
橙色

21:35.080 --> 21:36.080
OK

21:36.080 --> 21:37.080
保存一下

21:37.080 --> 21:38.080
现在我刷新一次

21:38.080 --> 21:39.080
看一眼

21:39.080 --> 21:40.080
OK

21:40.080 --> 21:41.080
但这本来14行报了个错

21:41.080 --> 21:42.080
对吧

21:42.080 --> 21:43.080
14行

21:43.080 --> 21:44.080
AdInVan

21:44.080 --> 21:45.080
AdInVan

21:45.080 --> 21:46.080
ISTNR

21:48.080 --> 21:49.080
啊

21:49.080 --> 21:50.080
看我没有这个纸

21:50.080 --> 21:51.080
对吧

21:51.080 --> 21:52.080
很重要

21:52.080 --> 21:53.080
因为我在集中这个函式的时候

21:53.080 --> 21:54.080
我确实没有

21:54.080 --> 21:55.080
我传说对吧

21:55.080 --> 21:56.080
在这的话

21:56.080 --> 21:57.080
首先我传一下这个

21:59.080 --> 22:00.080
DIV对吧

22:00.080 --> 22:01.080
要知道

22:01.080 --> 22:02.080
一个标签

22:02.080 --> 22:03.080
如果说它有ID的话

22:03.080 --> 22:04.080
那这个ID的话

22:04.080 --> 22:05.080
其实我们是可以

22:05.080 --> 22:06.080
根据那个document的点

22:06.080 --> 22:07.080
干AdInVan

22:07.080 --> 22:08.080
来获取它这样的一个

22:08.080 --> 22:09.080
DOM的对象

22:09.080 --> 22:10.080
当然呢

22:10.080 --> 22:11.080
你可以直接

22:11.080 --> 22:12.080
拿这个ID的名字

22:12.080 --> 22:13.080
作为它这样的一个

22:13.080 --> 22:14.080
DOM的对象

22:14.080 --> 22:15.080
这也是

22:15.080 --> 22:16.080
就是

22:16.080 --> 22:17.080
一个减变的一个操作

22:17.080 --> 22:18.080
当然呢

22:18.080 --> 22:19.080
同样

22:19.080 --> 22:20.080
当你正式开发的时候

22:20.080 --> 22:21.080
你还是最好这么做

22:21.080 --> 22:22.080
对吧

22:22.080 --> 22:23.080
不是

22:23.080 --> 22:24.080
我一个ODIV

22:24.080 --> 22:25.080
通过document的点

22:25.080 --> 22:26.080
通过document的点

22:26.080 --> 22:27.080
getAdInVan

22:27.080 --> 22:28.080
对吧

22:28.080 --> 22:29.080
通过这个

22:29.080 --> 22:30.080
让一个ID的名乘

22:30.080 --> 22:31.080
来获取这样的一个

22:31.080 --> 22:32.080
DOM对象

22:32.080 --> 22:33.080
那这边呢

22:33.080 --> 22:34.080
我们只是做一个测试

22:34.080 --> 22:35.080
所以说给你简写一下

22:35.080 --> 22:36.080
好

22:36.080 --> 22:37.080
那在这的话

22:37.080 --> 22:38.080
第一个里面

22:38.080 --> 22:39.080
传demo

22:39.080 --> 22:40.080
第二个呢

22:40.080 --> 22:41.080
我传table

22:41.080 --> 22:42.080
不说传click

22:42.080 --> 22:43.080
好

22:43.080 --> 22:44.080
第三个呢

22:44.080 --> 22:45.080
传函数

22:45.080 --> 22:46.080
OK

22:46.080 --> 22:47.080
那这个函数的话

22:47.080 --> 22:48.080
不说

22:48.080 --> 22:49.080
谈一个alert

22:49.080 --> 22:50.080
OK

22:50.080 --> 22:51.080
确实谈成弄了

22:51.080 --> 22:52.080
那这样吧

22:52.080 --> 22:53.080
我在这

22:53.080 --> 22:54.080
给你输出一个

22:57.080 --> 22:58.080
输出一个叫做

23:00.080 --> 23:01.080
last

23:01.080 --> 23:02.080
在这呢

23:02.080 --> 23:03.080
来输出一个first

23:03.080 --> 23:05.080
我们做这样一个测验

23:05.080 --> 23:07.080
F-i-r-s-t

23:07.080 --> 23:08.080
做这样测验

23:08.080 --> 23:09.080
咱看一下

23:09.080 --> 23:10.080
我第一次去保定

23:10.080 --> 23:11.080
一个实践对吧

23:11.080 --> 23:12.080
好

23:12.080 --> 23:13.080
我再来

23:13.080 --> 23:14.080
我第二次

23:14.080 --> 23:15.080
再保定个实践的话

23:15.080 --> 23:16.080
我是否有去进行

23:16.080 --> 23:17.080
这样一个判断

23:17.080 --> 23:18.080
如果有进行判断的话

23:18.080 --> 23:19.080
F-i-r-s-t

23:19.080 --> 23:20.080
对吧

23:20.080 --> 23:21.080
但是如果没有的话

23:21.080 --> 23:22.080
一定会输出这个last

23:22.080 --> 23:23.080
所以说我在这

23:24.080 --> 23:25.080
再注册一遍

23:25.080 --> 23:26.080
或者再执行一遍

23:26.080 --> 23:27.080
那我在这呢

23:27.080 --> 23:28.080
我再执行一遍

23:28.080 --> 23:29.080
我执行个两遍

23:29.080 --> 23:30.080
好

23:30.080 --> 23:31.080
咱看一下

23:31.080 --> 23:32.080
上线测

23:32.080 --> 23:33.080
是不是

23:33.080 --> 23:34.080
只有第一次是first

23:34.080 --> 23:36.080
上两次都是last

23:36.080 --> 23:37.080
对吧

23:37.080 --> 23:38.080
有时候通过多型函数的

23:38.080 --> 23:39.080
这样一个

23:39.080 --> 23:40.080
方式一个植物

23:40.080 --> 23:41.080
我去避免了

23:41.080 --> 23:43.080
它每次在进行的时候

23:43.080 --> 23:44.080
都进行这样一个

23:44.080 --> 23:45.080
无用的判断

23:45.080 --> 23:46.080
好

23:46.080 --> 23:47.080
我点开

23:47.080 --> 23:49.080
确实三个世界全绑成功

23:49.080 --> 23:50.080
好

23:50.080 --> 23:52.080
那这个多型函数的概念

23:52.080 --> 23:53.080
我们已经说完了

23:53.080 --> 23:54.080
那下次呢

23:54.080 --> 23:57.080
我再还会给大家带来一些

23:57.080 --> 23:58.080
更实用的这样一个

23:58.080 --> 24:00.080
变成的一个理念

24:00.080 --> 24:01.080
那我希望你们呢

24:01.080 --> 24:03.080
能够继续收听我们这样的一个

24:03.080 --> 24:05.080
你不知道GS一个课程

24:05.080 --> 24:06.080
当然那如果说

24:06.080 --> 24:07.080
你觉得我们这个课程

24:07.080 --> 24:08.080
有点难

24:08.080 --> 24:10.080
那正面的这个GS基础

24:10.080 --> 24:12.080
还是有待去提高的

24:12.080 --> 24:13.080
怎么来提高呢

24:13.080 --> 24:14.080
这里马上我可以推荐

24:14.080 --> 24:16.080
有没有一种方式

24:16.080 --> 24:18.080
那是在你

24:19.080 --> 24:20.080
就是

24:20.080 --> 24:22.080
如果说你看过我们这样的一个

24:22.080 --> 24:24.080
独一的一个GS攻击课程的话

24:24.080 --> 24:26.080
你可以辅助这个GS全面指南

24:26.080 --> 24:28.080
和高性能对吧

24:28.080 --> 24:30.080
你去进行这样的一个

24:30.080 --> 24:31.080
结合的一个智能

24:31.080 --> 24:33.080
支点的一个梳理

24:33.080 --> 24:34.080
当然呢

24:34.080 --> 24:35.080
如果说你没有看过

24:35.080 --> 24:36.080
我们这样的课程的话

24:36.080 --> 24:37.080
我是首要的

24:37.080 --> 24:39.080
去推荐你们看这样的课程

24:39.080 --> 24:40.080
因为这个课的话

24:40.080 --> 24:41.080
基本上覆盖了

24:41.080 --> 24:43.080
所有的GS的这样一个面

24:43.080 --> 24:44.080
而且讲得非常深

24:44.080 --> 24:45.080
毕竟嘛

24:45.080 --> 24:46.080
GS基础才是决定一个

24:46.080 --> 24:48.080
前的功能使能走不远的

24:48.080 --> 24:50.080
这样的一个决定性的一个因素

24:50.080 --> 24:51.080
就是说呢

24:51.080 --> 24:52.080
如果你GS不够好的话

24:52.080 --> 24:53.080
我希望你回去

24:53.080 --> 24:55.080
赶紧听听我们这样的课程

24:55.080 --> 24:56.080
好了

24:56.080 --> 24:57.080
那最后呢

24:57.080 --> 24:58.080
我要跟大家说一下

24:58.080 --> 24:59.080
就是

25:01.080 --> 25:02.080
如果说

25:02.080 --> 25:03.080
你没有在我们这样的

25:03.080 --> 25:04.080
一个线上攻击群的话

25:04.080 --> 25:05.080
你可以加我们这样的小肚

25:05.080 --> 25:06.080
那我们小肚呢

25:06.080 --> 25:07.080
会把你带到

25:07.080 --> 25:08.080
我们这样的一个线上攻击群之中

25:08.080 --> 25:10.080
我们线上攻击群呢

25:10.080 --> 25:12.080
现在已经到了

25:12.080 --> 25:13.080
五六个群了

25:13.080 --> 25:14.080
在我录的时候

25:14.080 --> 25:16.080
应该是到五六个群了

25:16.080 --> 25:17.080
那

25:17.080 --> 25:18.080
我们的老师呢

25:18.080 --> 25:20.080
也会全天性的

25:20.080 --> 25:21.080
在这个攻击群里面

25:21.080 --> 25:22.080
去给大家

25:22.080 --> 25:23.080
给大家这样的一个

25:23.080 --> 25:24.080
纪录性的一个问题

25:24.080 --> 25:25.080
如果说你正在

25:25.080 --> 25:27.080
去学习这样的一个技术

25:27.080 --> 25:28.080
或者说

25:28.080 --> 25:29.080
你打算要学

25:29.080 --> 25:31.080
或者说你正在想

25:31.080 --> 25:32.080
就是你已经学完了

25:32.080 --> 25:33.080
已经处在这样一个

25:33.080 --> 25:34.080
就职的状态

25:34.080 --> 25:36.080
你想提高你这样的一个

25:36.080 --> 25:37.080
前端

25:37.080 --> 25:38.080
提高你这样的一个

25:38.080 --> 25:39.080
前端的一个技能的话

25:39.080 --> 25:40.080
你都是可以

25:40.080 --> 25:42.080
加了我们这样的一个群之中的

25:43.080 --> 25:44.080
那

25:44.080 --> 25:45.080
最后呢

25:45.080 --> 25:46.080
最后呢

25:46.080 --> 25:47.080
还是再什么距离吧

25:47.080 --> 25:48.080
就是

25:48.080 --> 25:49.080
如果你有任何

25:49.080 --> 25:50.080
纪录性的问题的话

25:50.080 --> 25:52.080
欢迎在我们去来讨论

25:52.080 --> 25:53.080
那再见了各位

