WEBVTT

00:00.370 --> 00:04.370
好了 同学们 我们现在已经完成了CSS和ATM的升级

00:04.370 --> 00:09.370
那么接下来呢 就一个方向了 就是我们要完成介石语言的升级

00:09.370 --> 00:13.370
而这个介石语言的升级呢 我们之前说过啊 它分为两个部分

00:13.370 --> 00:18.370
一个是语言本身 就怎么说话 怎么语法呀 循环呀 数主啊

00:18.370 --> 00:23.370
对象像这些语言本身的东西 然后另一部分呢 是那个外北API

00:23.370 --> 00:27.370
就是浏览器给你提供了一些功能 比方说像

00:27.370 --> 00:32.370
或者动物元素啊 注册动物时间啊 对吧 它们都是基于语言本身做出来的

00:32.370 --> 00:37.370
那么我们这一部分的学习啊 就本阶段呢 我们学习的是语言层面的升级

00:37.370 --> 00:42.370
而这一部分的升级其实已经完成了 就咱们讲H5的时候去给大家说了 对吧

00:42.370 --> 00:45.370
我们学习的是语言层面的升级 这这一部分

00:45.370 --> 00:49.370
我给大家首先说一下咱们这一阶段学习的到底是啥

00:49.370 --> 00:54.370
然后呢 这一阶段怎么学习呢 因为这一阶段会出现

00:54.370 --> 00:58.370
很多的新语法 以及大量的API

00:58.370 --> 01:04.370
那么对于新语法也好 对于API也好 咱们应该有一个什么样的心态来学习

01:04.370 --> 01:09.370
我这里要着重的说一下 为什么我要去罗里巴说这些东西啊

01:09.370 --> 01:15.370
因为我要去照顾很多学习习惯 学习心态不好的同学

01:15.370 --> 01:20.370
因为咱们 据我的观察 很多同学他学习心态啊

01:20.370 --> 01:24.370
和过去在高中初中的时候学习的习惯特别不好

01:24.370 --> 01:28.370
首先咱们这个程序开发是一个相当于是一个理工科

01:28.370 --> 01:32.370
理工科的所有东西一个都不需要备

01:32.370 --> 01:36.370
我高中和初中的时候一个公式没备过 一个定理没备过

01:36.370 --> 01:40.370
那那个作业怎么做得出来 忘了就去查 就翻书

01:40.370 --> 01:45.370
然后呢 这个通过是什么方式记住的 是通过长期的训练

01:45.370 --> 01:50.370
长期的实操 浅疑默化的去记住的

01:50.370 --> 01:54.370
很多人就觉得 咱们学完一门课 是不是我那一门课这东西就搞定了

01:54.370 --> 01:57.370
以后就OK了 我以后就再也不用回头去看了 不是的

01:57.370 --> 02:01.370
学习根本就不是这样子的 比方说我们前面ATM CSS

02:01.370 --> 02:04.370
学了这么多东西对吧 我们也做了练习了 那是不是就完了呢

02:04.370 --> 02:07.370
你学完了就过了呢 你觉得过得了吗

02:07.370 --> 02:11.370
那为什么我要给你准备闻到 过不了的同学

02:11.370 --> 02:15.370
你要在以后的开发中 如果说遇到了相关的东西

02:15.370 --> 02:18.370
你觉得要去使用 这一块我要使用CCS3

02:18.370 --> 02:21.370
但是呢 我忘了CCS3能不能做这个事

02:21.370 --> 02:24.370
我也忘了他具体怎么去写这个代码 查阅

02:24.370 --> 02:27.370
通过文档去查阅 只能这样做

02:27.370 --> 02:31.370
这是学习的唯一方式 千万不能背

02:31.370 --> 02:34.370
被纯粹是浪费时间 一点都记不住的

02:34.370 --> 02:36.370
比方说我再给大家举个例子

02:36.370 --> 02:39.370
比方说你学一个东西 你学它的时候

02:39.370 --> 02:43.370
可能你花费了三天的时间 把学完了

02:43.370 --> 02:46.370
学完了不等于你吸收了 知道吧

02:46.370 --> 02:49.370
那么你吸收需要多好时间的

02:49.370 --> 02:53.370
可能需要三个句 甚至三年 甚至三十年

02:53.370 --> 02:58.370
那看什么东西 比方说有些学习后段的同学

02:58.370 --> 03:01.370
肯定接触过面向对象的东西

03:01.370 --> 03:04.370
面向对象学多久呢 一周 两周

03:04.370 --> 03:06.370
差不多了 面向对象开发

03:06.370 --> 03:09.370
你需要吸收多久 三十年都不够

03:09.370 --> 03:15.370
每一次去思考它 每一次去看一些书籍

03:15.370 --> 03:19.370
一些博客 或者是一些高手写的代码

03:19.370 --> 03:22.370
你都会有新的感触和收获

03:22.370 --> 03:25.370
学习本来就是这个样子 这才是学习本来的样子

03:25.370 --> 03:27.370
所以说很多同学可能对学习有误解

03:27.370 --> 03:30.370
觉得我学了三天 那我就应该够了

03:30.370 --> 03:33.370
那三天我当时觉得学会就OK了

03:33.370 --> 03:35.370
其实远远不止如此

03:35.370 --> 03:37.370
那么包括我们这个阶段讲的

03:37.370 --> 03:40.370
ES代码成绩 东西特别特别多

03:40.370 --> 03:42.370
那我对你的要求是什么 你能去记这些东西吧

03:42.370 --> 03:44.370
记不住

03:44.370 --> 03:47.370
有很多同学都要问 以前我讲过ES6

03:47.370 --> 03:49.370
很多同学问 袁老师ES6这么多东西

03:49.370 --> 03:52.370
我什么长期下使用了 你不要去想这些问题

03:52.370 --> 03:55.370
你只要在当时能够听懂

03:55.370 --> 03:58.370
当时能够把练习做出来 就OK了

03:58.370 --> 04:02.370
OK 什么OK呢 就是你当时已经理解那个知识了

04:02.370 --> 04:05.370
至少理解了其中一部分了 有那么一点印象了

04:05.370 --> 04:08.370
将来我们在开发中用不用它

04:08.370 --> 04:11.370
看你自己的心情 你想起了就用它

04:11.370 --> 04:13.370
想不起就拉倒

04:13.370 --> 04:15.370
比如说我们像我们这个阶段学习的

04:15.370 --> 04:17.370
各种各样的ES的改动

04:17.370 --> 04:22.370
其实99%你不学它

04:22.370 --> 04:25.370
你用过去的那种老办法 仍然有效

04:25.370 --> 04:26.370
仍然可以做

04:26.370 --> 04:28.370
它只是给你提供了一些新的方式

04:28.370 --> 04:31.370
更舒服的方式 它不是在恶心里的

04:31.370 --> 04:33.370
它是来帮助你的

04:33.370 --> 04:35.370
就是你以前那个单码写得太恶心了

04:35.370 --> 04:37.370
我给你换一种舒服的方式来写

04:37.370 --> 04:39.370
如果说你不接受

04:39.370 --> 04:42.370
那么你照样用之前的没有任何问题

04:42.370 --> 04:44.370
明儿的意思吧

04:44.370 --> 04:46.370
那么我们这个ES6

04:46.370 --> 04:48.370
这个ES的这些升级

04:48.370 --> 04:49.370
我们是怎么去掌握它的

04:49.370 --> 04:50.370
我们先学习它

04:50.370 --> 04:52.370
先知道它的存在

04:52.370 --> 04:54.370
我们做一些练习 听懂它什么意思

04:54.370 --> 04:55.370
每个点都提出很简单

04:55.370 --> 04:58.370
东西虽然多 但是每一个点都提出很简单的

04:58.370 --> 05:00.370
听懂它什么意思

05:00.370 --> 05:02.370
然后做一些练习就OK了

05:02.370 --> 05:03.370
就够用了

05:03.370 --> 05:05.370
然后在将来我们的开发中

05:05.370 --> 05:07.370
有一天你表面里写循环

05:07.370 --> 05:09.370
你写的写的

05:09.370 --> 05:11.370
我觉得那个佛循环写得太恶心了

05:11.370 --> 05:12.370
写的代码太多了

05:12.370 --> 05:13.370
也突然想到

05:13.370 --> 05:15.370
咱们袁老师之前讲的一个ES的事

05:15.370 --> 05:16.370
说你讲过一个循环

05:16.370 --> 05:18.370
可以非常方便的去循环一个数字

05:18.370 --> 05:19.370
那就是佛二五循环

05:19.370 --> 05:20.370
你就想起来了

05:20.370 --> 05:22.370
想起来就去使用它

05:22.370 --> 05:24.370
就查一下文档 看一下文档

05:24.370 --> 05:25.370
马上就回忆起来了

05:25.370 --> 05:26.370
然后去使用它

05:26.370 --> 05:29.370
这样子在长期的这种过程中

05:29.370 --> 05:30.370
潜移默化的

05:30.370 --> 05:32.370
慢慢的去掌握它

05:32.370 --> 05:34.370
才能真正的变成你的东西

05:34.370 --> 05:36.370
学习本来就是这个样子的

05:36.370 --> 05:37.370
你没有接近课程

05:37.370 --> 05:39.370
好 咱们回头来

05:39.370 --> 05:40.370
讲了这么多废话了

05:40.370 --> 05:43.370
我们回头来讲这个ES

05:43.370 --> 05:45.370
到底做了哪些语言层面的升级

05:45.370 --> 05:46.370
我在重生意识

05:46.370 --> 05:47.370
它不是在恶心里的

05:47.370 --> 05:49.370
它是在帮助里的

05:49.370 --> 05:50.370
因为过去的解释语言

05:50.370 --> 05:52.370
确实存在了太多太多的问题了

05:52.370 --> 05:54.370
一直以来无人问津

05:54.370 --> 05:56.370
现在官方出手

05:56.370 --> 05:58.370
然后对它进行改动

05:58.370 --> 06:01.370
这里顺便给大家提一个提议水

06:01.370 --> 06:04.370
这个ES这个版本是这样

06:04.370 --> 06:07.370
过去是好几年出一个版本

06:07.370 --> 06:11.370
现在从2015年过后

06:11.370 --> 06:14.370
就是每年一个新版本

06:14.370 --> 06:16.370
2015年的ES版本就是ES6

06:16.370 --> 06:17.370
一定那么的ES6

06:17.370 --> 06:19.370
像我们这里的大量的改动

06:19.370 --> 06:20.370
都是基于ES6的

06:20.370 --> 06:22.370
都是ES6出现的改动

06:22.370 --> 06:24.370
然后ES6过后

06:24.370 --> 06:26.370
就是每年一个新版本

06:26.370 --> 06:27.370
每年新版本

06:27.370 --> 06:28.370
官方的意思就是说

06:28.370 --> 06:30.370
我不再用这个数字来编号了

06:30.370 --> 06:31.370
我用连份来编号

06:31.370 --> 06:33.370
所以说ES6也叫做ES2015

06:33.370 --> 06:35.370
然后后面就是ES2017

06:35.370 --> 06:36.370
2016

06:36.370 --> 06:37.370
那么就是我们的

06:37.370 --> 06:40.370
我们平时说的ES7

06:40.370 --> 06:41.370
然后后面就是

06:41.370 --> 06:42.370
就不再用数字了

06:42.370 --> 06:44.370
就是ES2017

06:44.370 --> 06:45.370
ES2018

06:45.370 --> 06:46.370
ES2019

06:46.370 --> 06:47.370
202021

06:47.370 --> 06:48.370
2021是吧

06:48.370 --> 06:50.370
这就是一个常识

06:50.370 --> 06:52.370
给大家说一下

06:52.370 --> 06:53.370
这里边改动很多

06:53.370 --> 06:54.370
所以说有些地方的

06:54.370 --> 06:55.370
不是很好归内

06:55.370 --> 06:56.370
因此我把

06:56.370 --> 06:57.370
第一节课

06:57.370 --> 06:59.370
我就给他做了一个0税的改动

06:59.370 --> 07:00.370
就看一看

07:00.370 --> 07:01.370
每个地方都很简单

07:01.370 --> 07:03.370
首先看一个严格模式

07:03.370 --> 07:05.370
这是ES5的新增语法

07:05.370 --> 07:07.370
我简单的说一下

07:07.370 --> 07:08.370
他来解决什么问题

07:08.370 --> 07:09.370
他就说

07:09.370 --> 07:11.370
以前的这个介石语言

07:11.370 --> 07:12.370
灵活是灵活

07:12.370 --> 07:14.370
但是有些地方的不严谨

07:14.370 --> 07:16.370
就造成了一些

07:16.370 --> 07:17.370
写单码的一些隐患

07:17.370 --> 07:19.370
所以说在ES5

07:19.370 --> 07:20.370
他给你提出来这么一个东西

07:20.370 --> 07:21.370
要严格模式

07:21.370 --> 07:22.370
严格模式

07:22.370 --> 07:23.370
你可以参考这

07:23.370 --> 07:25.370
上面这个是比较简单的

07:25.370 --> 07:26.370
一个文档

07:26.370 --> 07:27.370
下面是官方的

07:27.370 --> 07:29.370
详细的文档

07:29.370 --> 07:31.370
严格模式其实非常简单

07:31.370 --> 07:33.370
你就是加一句代码

07:33.370 --> 07:35.370
你就加一句代码

07:35.370 --> 07:36.370
在这儿

07:36.370 --> 07:38.370
use straight

07:38.370 --> 07:40.370
完了

07:40.370 --> 07:41.370
加到最上面

07:41.370 --> 07:43.370
然后后边的整个代码

07:43.370 --> 07:44.370
就处于严格模式了

07:44.370 --> 07:45.370
那么严格模式

07:45.370 --> 07:46.370
有什么样的特点

07:46.370 --> 07:48.370
只要去看文档

07:48.370 --> 07:49.370
比方说

07:49.370 --> 07:51.370
他能够提高预编译的效率

07:51.370 --> 07:54.370
然后还有什么

07:54.370 --> 07:58.740
在这里

07:58.740 --> 08:02.570
我觉得他说的

08:02.570 --> 08:04.570
在哪个地方

08:04.570 --> 08:05.570
在这

08:05.570 --> 08:06.570
他一条条说的

08:06.570 --> 08:08.570
然后了这个

08:08.570 --> 08:12.840
跑了

08:12.840 --> 08:13.840
我觉得他这里说的

08:13.840 --> 08:14.840
对在这

08:14.840 --> 08:15.840
严格模式的限制

08:15.840 --> 08:17.840
有哪些代码你就不在

08:17.840 --> 08:19.840
哪些不规范的代码

08:19.840 --> 08:20.840
你就不能再使用了

08:20.840 --> 08:21.840
要包错了

08:21.840 --> 08:22.840
比方说像这种代码

08:22.840 --> 08:23.840
要包错了

08:23.840 --> 08:24.840
你没有定义

08:24.840 --> 08:25.840
没有定义一边

08:25.840 --> 08:26.840
让你给他复职

08:26.840 --> 08:27.840
就是严格模式

08:27.840 --> 08:28.840
大概去看一下

08:28.840 --> 08:29.840
就是平时开发

08:29.840 --> 08:30.840
对我们开发

08:30.840 --> 08:31.840
有没有什么影响呢

08:31.840 --> 08:33.840
基本上没有什么影响

08:33.840 --> 08:34.840
因为之后呢

08:34.840 --> 08:36.840
我们使用模块化之后

08:36.840 --> 08:39.840
除非公司有要求

08:39.840 --> 08:40.840
否则的话

08:40.840 --> 08:41.840
你加不加严格模式

08:41.840 --> 08:42.840
你自己看的吧

08:42.840 --> 08:43.840
他有什么样的变化

08:43.840 --> 08:44.840
你加了过去

08:44.840 --> 08:45.840
什么变化

08:45.840 --> 08:46.840
自己看这些例子

08:46.840 --> 08:47.840
严格模式

08:47.840 --> 08:48.840
大概说一下

08:48.840 --> 08:50.840
好 下面这个

08:50.840 --> 08:51.840
对我们开发有影响的

08:51.840 --> 08:53.840
特别特别简单

08:53.840 --> 08:55.840
叫net和const

08:55.840 --> 08:56.840
它是两个关键字

08:56.840 --> 08:58.840
他就说es6

08:58.840 --> 08:59.840
他建议了

08:59.840 --> 09:00.840
不再使用var

09:00.840 --> 09:01.840
来定义变量的

09:01.840 --> 09:02.840
而使用net

09:02.840 --> 09:03.840
定义变量

09:03.840 --> 09:05.840
用const定义长量

09:05.840 --> 09:07.840
比方说你之前

09:07.840 --> 09:08.840
用var定义的变量

09:08.840 --> 09:09.840
那么现在用net

09:09.840 --> 09:12.840
然后之前用var定义的变量

09:12.840 --> 09:13.840
现在用const

09:13.840 --> 09:14.840
那么这两个有什么区别呢

09:14.840 --> 09:16.840
这个就是变量

09:16.840 --> 09:17.840
这个是长量

09:17.840 --> 09:18.840
长量是什么意思

09:18.840 --> 09:19.840
就是你够复职过后

09:19.840 --> 09:20.840
就不能更改了

09:20.840 --> 09:22.840
这就是这么一个

09:22.840 --> 09:24.840
一个新则的关键字

09:24.840 --> 09:25.840
所以说

09:25.840 --> 09:26.840
开发是有影响的

09:26.840 --> 09:27.840
但是非常简单

09:27.840 --> 09:28.840
你以后定义变量

09:28.840 --> 09:29.840
你不再使用var

09:29.840 --> 09:30.840
就完事了

09:30.840 --> 09:31.840
你直接使用net

09:31.840 --> 09:33.840
如果说你要不可更改的变量

09:33.840 --> 09:34.840
就是使用const

09:34.840 --> 09:36.840
那么对我们以后都开发了

09:36.840 --> 09:38.840
通常情况是这样子的

09:38.840 --> 09:39.840
所有的变量

09:39.840 --> 09:41.840
全部使用const

09:41.840 --> 09:44.840
如果说实在需要修改变量

09:44.840 --> 09:46.840
再使用net

09:46.840 --> 09:47.840
比方说我们这里

09:47.840 --> 09:49.840
定义一个变量

09:49.840 --> 09:51.840
直接用const定义

09:51.840 --> 09:52.840
直接给它复职

09:52.840 --> 09:54.840
然后将来你写着写着

09:54.840 --> 09:55.840
好像对A要修改

09:55.840 --> 09:57.840
那么这个时候离运行

09:57.840 --> 09:58.840
就会爆出

09:58.840 --> 10:00.840
他说你再尝试

10:00.840 --> 10:02.840
给一个长量复职

10:02.840 --> 10:03.840
和samant

10:03.840 --> 10:04.840
表示复职的意思

10:04.840 --> 10:05.840
复职给谁

10:05.840 --> 10:06.840
一个长量

10:06.840 --> 10:07.840
你再给长量复职

10:07.840 --> 10:08.840
所以说这里要爆出

10:08.840 --> 10:09.840
那爆出的时候

10:09.840 --> 10:10.840
你再看一下

10:10.840 --> 10:11.840
原来这一行爆出了

10:11.840 --> 10:12.840
那么这个A

10:12.840 --> 10:13.840
到底能不能更改

10:13.840 --> 10:14.840
好想一想

10:14.840 --> 10:15.840
好像能更改

10:15.840 --> 10:16.840
那么这个时候

10:16.840 --> 10:17.840
再把它改成net

10:17.840 --> 10:18.840
也有意思吧

10:18.840 --> 10:19.840
平时我们开发

10:19.840 --> 10:20.840
是用这种方式开发的

10:20.840 --> 10:21.840
先定义const

10:21.840 --> 10:22.840
然后在复职的时候

10:22.840 --> 10:23.840
发现确实要更改

10:23.840 --> 10:25.840
那么就把它变成net

10:25.840 --> 10:26.840
那为什么要把它变成

10:26.840 --> 10:27.840
不可更改呢

10:27.840 --> 10:29.840
因为我们既也是

10:29.840 --> 10:30.840
那个变量了

10:30.840 --> 10:31.840
更改了要更改去

10:31.840 --> 10:32.840
就会导致这个变量里面

10:32.840 --> 10:33.840
可能

10:33.840 --> 10:34.840
比方说我们这里

10:34.840 --> 10:36.840
定一个A级17

10:36.840 --> 10:40.410
那么可能中间

10:40.410 --> 10:42.410
经过了一长串代码

10:42.410 --> 10:43.410
结果了这个时候

10:43.410 --> 10:44.410
你的A级

10:44.410 --> 10:46.410
变成了一个毛利卡了

10:47.410 --> 10:49.410
它可能只是变成这个东西的

10:49.410 --> 10:51.410
它的含义都变了对吧

10:51.410 --> 10:52.410
变成了名字了

10:52.410 --> 10:54.410
所以为了防治这种情况

10:54.410 --> 10:56.410
把它变成const

10:56.410 --> 10:57.410
是最稳妥的

10:57.410 --> 10:59.410
这样最不容易出bug

10:59.410 --> 11:00.410
到时候一更改

11:00.410 --> 11:01.410
那么马上给你报处

11:01.410 --> 11:02.410
这个地方不能更改

11:02.410 --> 11:04.410
所以说这里呢

11:04.410 --> 11:05.410
给大家说一下

11:05.410 --> 11:07.410
这是一种开发习惯

11:07.410 --> 11:08.410
那么这个net

11:08.410 --> 11:10.410
const除了

11:10.410 --> 11:11.410
变得关键之外

11:11.410 --> 11:12.410
还有什么样的特点呢

11:12.410 --> 11:13.410
我们一个个看一下吧

11:13.410 --> 11:14.410
来过一下

11:14.410 --> 11:15.410
这些东西到时候

11:15.410 --> 11:17.410
跟以后的面试题

11:17.410 --> 11:18.410
倒是有些关系

11:18.410 --> 11:20.410
不过现在我们还不讲面试题

11:20.410 --> 11:22.410
我们大家看一下就行了

11:22.410 --> 11:23.410
首先呢

11:23.410 --> 11:25.410
它不会再作为全局

11:25.410 --> 11:26.410
就全局定义的变量

11:26.410 --> 11:28.410
它不会再作为属性

11:28.410 --> 11:29.410
现在到全局对象中了

11:29.410 --> 11:30.410
啥意思

11:30.410 --> 11:31.410
就是以前啊

11:31.410 --> 11:32.410
我们定义一个变量

11:32.410 --> 11:34.410
那个从中式停耳型的对吧

11:34.410 --> 11:35.410
我们定一个wa

11:35.410 --> 11:36.410
然后呢window里面

11:36.410 --> 11:37.410
就会出现一个a

11:37.410 --> 11:38.410
怪不怪吧

11:38.410 --> 11:39.410
怪的不得了

11:39.410 --> 11:40.410
那么现在呢

11:40.410 --> 11:41.410
我们再定义一个

11:41.410 --> 11:42.410
用net来定义一个变量

11:42.410 --> 11:43.410
那window里面

11:43.410 --> 11:44.410
还不会出现d

11:44.410 --> 11:45.410
window里面

11:45.410 --> 11:46.410
不会再出现d了

11:46.410 --> 11:47.410
就这么个意思

11:47.410 --> 11:48.410
好 这是第一个点

11:48.410 --> 11:49.410
第二个点

11:49.410 --> 11:50.410
在变量定义之前

11:50.410 --> 11:51.410
使用它会爆错

11:51.410 --> 11:54.410
哎哟 这个问题

11:54.410 --> 11:55.410
你们如果说

11:55.410 --> 11:56.410
一开始

11:56.410 --> 11:57.410
第一门语言接触的

11:57.410 --> 11:58.410
就是介石语言

11:58.410 --> 11:59.410
倒是没有什么感觉

11:59.410 --> 12:00.410
对吧

12:00.410 --> 12:01.410
你觉得这个代码

12:01.410 --> 12:02.410
倒是挺正常的

12:02.410 --> 12:04.410
这个代码是极其不正常的啊

12:04.410 --> 12:06.410
比方说你这个A级的

12:06.410 --> 12:07.410
你这样

12:07.410 --> 12:08.410
这个代码是极不正常的

12:08.410 --> 12:11.410
它在变量定义之前

12:11.410 --> 12:13.410
去使用它

12:13.410 --> 12:16.410
它还居然可以不爆错

12:16.410 --> 12:18.410
这是有隐患的

12:18.410 --> 12:19.410
那么为什么不爆错呢

12:19.410 --> 12:20.410
是因为过去了

12:20.410 --> 12:22.410
它有个变量提升

12:22.410 --> 12:23.410
你写的定义在

12:23.410 --> 12:24.410
任何地方的变量

12:24.410 --> 12:25.410
在诠据环境里边

12:25.410 --> 12:26.410
都会提升到定义

12:26.410 --> 12:28.410
你在函数里边定义的变量

12:28.410 --> 12:29.410
都会提升到函数的定义

12:29.410 --> 12:31.410
所以说它变成这个样子

12:31.410 --> 12:32.410
因此它不爆错

12:32.410 --> 12:33.410
对吧

12:33.410 --> 12:34.410
以前有这个问题

12:34.410 --> 12:35.410
那么那一车呢

12:35.410 --> 12:36.410
它就不会有这个问题

12:36.410 --> 12:38.410
那么那一车就比较正常了

12:38.410 --> 12:39.410
终于回归到正常了

12:39.410 --> 12:40.410
那一车抗射都一样

12:40.410 --> 12:42.410
那么这个时候它就爆错了

12:42.410 --> 12:44.410
它告诉你

12:44.410 --> 12:45.410
A级

12:45.410 --> 12:48.410
不能在初始化之前

12:48.410 --> 12:49.410
使用这个变量

12:49.410 --> 12:50.410
它就爆错了

12:50.410 --> 12:52.410
爆错是正常的

12:52.410 --> 12:54.410
这是这个

12:54.410 --> 12:55.410
不可重复定义

12:55.410 --> 12:56.410
变统命变量

12:56.410 --> 12:57.410
这也是个老问题了

12:57.410 --> 12:58.410
这个问题

12:58.410 --> 12:59.410
要多怪有多怪

12:59.410 --> 13:00.410
以前的还去

13:00.410 --> 13:02.410
以前一些VAR

13:03.410 --> 13:06.410
它允许这样做

13:06.410 --> 13:07.410
你看这个代码有多怪

13:07.410 --> 13:10.410
你可能觉得

13:10.410 --> 13:11.410
看久了

13:11.410 --> 13:12.410
好像也挺正常的

13:12.410 --> 13:13.410
这极其不正常

13:13.410 --> 13:14.410
没有任何一个语言

13:14.410 --> 13:16.410
敢这样去做的

13:16.410 --> 13:17.410
正常的情况下

13:17.410 --> 13:18.410
这是什么的

13:18.410 --> 13:19.410
类似就变正常了

13:19.410 --> 13:24.280
进行

13:24.280 --> 13:25.280
它直接爆错了

13:25.280 --> 13:27.280
它说这个A已经存在了

13:27.280 --> 13:28.280
相对常见错误

13:28.280 --> 13:30.280
你可以有这么一点印象

13:30.280 --> 13:31.280
这个A已经存在了

13:31.280 --> 13:33.280
所以说你不能再重新定义了

13:33.280 --> 13:34.280
你可以跟它重新复制

13:34.280 --> 13:35.280
没问题

13:35.280 --> 13:36.280
它不能重新定义了

13:36.280 --> 13:38.280
它变得更加严格了

13:38.280 --> 13:40.280
然后使用抗射程

13:40.280 --> 13:41.280
必须初始化

13:41.280 --> 13:42.280
因为它是一个场量

13:42.280 --> 13:43.280
场量在一开始

13:43.280 --> 13:45.280
必须要确定下来

13:45.280 --> 13:46.280
比方说什么

13:46.280 --> 13:47.280
要场量

13:47.280 --> 13:48.280
像是3.1415926

13:48.280 --> 13:49.280
它固定的

13:49.280 --> 13:50.280
那么像这些量

13:50.280 --> 13:51.280
必须要在一开始

13:51.280 --> 13:52.280
要定义下来

13:52.280 --> 13:53.280
如果说你一开始不定义

13:53.280 --> 13:54.280
直接它定义

13:54.280 --> 13:55.280
不给它复制的话

13:55.280 --> 13:56.280
要爆错的

13:56.280 --> 13:57.280
它说 missing

13:57.280 --> 13:58.280
缺少了initializer

13:58.280 --> 13:59.280
缺少了初始化

13:59.280 --> 14:01.280
在场量的声明中

14:01.280 --> 14:02.280
缺少初始化

14:02.280 --> 14:04.660
那么你给它初始化一下

14:04.660 --> 14:05.660
就行了

14:05.660 --> 14:06.660
对吧

14:06.660 --> 14:07.660
然后再来看

14:07.660 --> 14:09.660
然后变量剧有快极作用剧

14:09.660 --> 14:10.660
在代码块之外

14:10.660 --> 14:12.660
是不可使用的

14:12.660 --> 14:13.660
啥意思呢

14:14.660 --> 14:16.660
这个点就很重要了

14:17.660 --> 14:18.660
我们过去

14:18.660 --> 14:19.660
只有两个作用剧

14:19.660 --> 14:20.660
一种是全剧作用剧

14:20.660 --> 14:21.660
比如定的变量剧

14:21.660 --> 14:22.660
全剧作用剧

14:22.660 --> 14:23.660
或者是在一个函数里边

14:23.660 --> 14:24.660
定一个变量

14:24.660 --> 14:25.660
那么叫函数作用剧

14:25.660 --> 14:27.660
它是没有快极作用剧的

14:27.660 --> 14:28.660
什么叫快极作用剧

14:28.660 --> 14:29.660
比方说的一个判断

14:30.660 --> 14:31.660
判断里边

14:31.660 --> 14:32.660
这就是个代码块

14:33.660 --> 14:34.660
这里边是没有作用剧的

14:34.660 --> 14:36.660
我给它演示一下吧

14:37.660 --> 14:38.660
比方说我们这里

14:38.660 --> 14:39.660
就写个处吧

14:39.660 --> 14:41.660
然后我们定一个变量A

14:41.660 --> 14:42.660
等于2

14:42.660 --> 14:43.660
然后我们这里输出A

14:44.660 --> 14:45.660
该输出多少

14:45.660 --> 14:46.660
该输出2

14:46.660 --> 14:47.660
实际上我告诉大家

14:47.660 --> 14:48.660
在一个正常的语言中

14:48.660 --> 14:49.660
这个代码是

14:50.660 --> 14:51.660
不太正常的

14:51.660 --> 14:52.660
是

14:52.660 --> 14:53.660
是有点怪的

14:53.660 --> 14:54.660
你在这个代码块里边

14:54.660 --> 14:55.660
定的变量

14:55.660 --> 14:57.660
应该只能在这个代码块里边使用

14:57.660 --> 14:59.660
除了这个代码块是不能用的

15:00.660 --> 15:01.660
但是过去

15:01.660 --> 15:02.660
由于没有快极作用剧

15:02.660 --> 15:04.660
所以说导致了还有变量提升

15:04.660 --> 15:05.660
一提升就跑到外面去了

15:06.660 --> 15:07.660
就变成这个样子

15:08.660 --> 15:09.660
所以说它就变得可以用了

15:09.660 --> 15:10.660
就很奇怪

15:11.660 --> 15:12.660
因此呢

15:12.660 --> 15:13.660
在ES6里边

15:13.660 --> 15:14.660
它就告诉你

15:14.660 --> 15:15.660
以用这个东西不行了

15:15.660 --> 15:16.660
它就正常了

15:16.660 --> 15:17.660
它变成了快极作用剧

15:17.660 --> 15:18.660
它这个变量

15:18.660 --> 15:19.660
只在代码块里边使用

15:20.660 --> 15:22.660
包括判端、循环、Switch

15:22.660 --> 15:23.660
这些都是一样

15:23.660 --> 15:24.660
它只在这个块里边使用

15:24.660 --> 15:25.660
除了这个块就不能用了

15:25.660 --> 15:26.660
它说这个A

15:26.660 --> 15:27.660
也是拿底范的

15:27.660 --> 15:28.660
没有定义

15:28.660 --> 15:29.660
原来的意思呢

15:29.660 --> 15:30.660
就这么个意思

15:30.660 --> 15:31.660
它变成正常了

15:31.660 --> 15:32.660
它不再试一下

15:32.660 --> 15:33.660
那么怪异的模式了

15:33.660 --> 15:35.660
其实对我们开发的影响的话

15:35.660 --> 15:37.660
你就是把它变成内置

15:37.660 --> 15:38.660
变成Const

15:38.660 --> 15:39.660
然后需要改动的话变成内置

15:39.660 --> 15:40.660
就完了

15:40.660 --> 15:41.660
对我们开发就这个影响

15:42.660 --> 15:43.660
然后这个快极作用剧

15:43.660 --> 15:44.660
其实还给我们以前

15:44.660 --> 15:45.660
造成很多的困扰

15:45.660 --> 15:46.660
比方说

15:46.660 --> 15:48.660
我们以前用一些货循环

15:49.660 --> 15:50.660
i小与10

15:50.660 --> 15:51.660
这里下面举了很多例子

15:51.660 --> 15:52.660
可以去看一下

15:54.660 --> 15:56.660
然后我们在这里写一个

16:00.660 --> 16:01.660
隔一秒钟之后

16:01.660 --> 16:02.660
输出一个i

16:02.660 --> 16:04.660
那么这里循环10次

16:04.660 --> 16:05.660
是不是叫

16:05.660 --> 16:07.660
一秒钟之后要输出10个数字

16:07.660 --> 16:08.660
对不对

16:08.660 --> 16:10.660
那么这里我们输出啥呢

16:10.660 --> 16:11.660
这是个经典的问题

16:11.660 --> 16:12.660
对不对

16:12.660 --> 16:13.660
输出什么呢

16:13.660 --> 16:14.660
输出了一秒钟之后

16:14.660 --> 16:15.660
还输出10个10

16:15.660 --> 16:16.660
为什么输出10个10呢

16:16.660 --> 16:17.660
你这样子看就明白了

16:17.660 --> 16:18.660
它有提升

16:18.660 --> 16:19.660
它没有快极作用剧

16:19.660 --> 16:20.660
它有提升

16:20.660 --> 16:21.660
可以把i提到这了

16:22.660 --> 16:23.660
那么你看一下这个函数

16:23.660 --> 16:24.660
一秒钟之后

16:24.660 --> 16:25.660
一秒钟之后

16:25.660 --> 16:26.660
循环是不是结束了

16:27.660 --> 16:28.660
一秒钟是不是循环结束了

16:28.660 --> 16:29.660
循环为什么结束

16:29.660 --> 16:30.660
因为i一直哪家

16:30.660 --> 16:31.660
一直哪家

16:31.660 --> 16:32.660
加到10了

16:32.660 --> 16:33.660
对不对

16:33.660 --> 16:34.660
所以循环就结束了

16:35.660 --> 16:36.660
因此循环结束过后

16:36.660 --> 16:37.660
等到一秒钟

16:38.660 --> 16:39.660
然后开始输出

16:39.660 --> 16:40.660
输出的是什么

16:40.660 --> 16:41.660
输出的是同一个i

16:42.660 --> 16:43.660
这个问题呢

16:43.660 --> 16:44.660
我就不再多说了

16:44.660 --> 16:45.660
你们以前一定是

16:45.660 --> 16:46.660
这个问题的

16:46.660 --> 16:47.660
它输出了10个

16:47.660 --> 16:48.660
相同的i

16:48.660 --> 16:49.660
那么这个i的只

16:49.660 --> 16:50.660
最后是多少

16:50.660 --> 16:51.660
最终就是10

16:52.660 --> 16:53.660
那么这个问题

16:53.660 --> 16:54.660
怎么解决呢

16:54.660 --> 16:55.660
以前我们要用

16:55.660 --> 16:56.660
使用立即执行函数

16:56.660 --> 16:57.660
对吧

16:57.660 --> 16:58.660
我们看这个代码

16:58.660 --> 16:59.660
使用立即执行函数

16:59.660 --> 17:00.660
自己看一下

17:00.660 --> 17:01.660
这是你以前的指示

17:01.660 --> 17:02.660
现在解决方式

17:02.660 --> 17:03.660
非常简单

17:03.660 --> 17:04.660
让它变成耐词玩事

17:04.660 --> 17:05.660
玩了

17:05.660 --> 17:06.660
没了

17:06.660 --> 17:07.660
一秒钟之后

17:07.660 --> 17:08.660
就输出了

17:08.660 --> 17:09.660
1235的喜欢球

17:09.660 --> 17:10.660
因为它有快极作用剧

17:10.660 --> 17:11.660
它只在

17:11.660 --> 17:13.660
每一次循环中有效

17:13.660 --> 17:14.660
那么第一次循环

17:14.660 --> 17:16.660
和第二次循环用的i

17:16.660 --> 17:17.660
实际上

17:17.660 --> 17:18.660
它给你做了特殊处理

17:18.660 --> 17:19.660
它不是同一个i

17:20.660 --> 17:21.660
那么就可以

17:21.660 --> 17:23.660
让每一个

17:23.660 --> 17:24.660
使用自己的i

17:24.660 --> 17:25.660
那么第一次是0

17:25.660 --> 17:26.660
第二次是1

17:26.660 --> 17:27.660
总之这个问题就解决了

17:27.660 --> 17:28.660
反正就解决了

17:29.660 --> 17:31.660
你用了net和const之后

17:31.660 --> 17:32.660
你会发现很多

17:32.660 --> 17:33.660
一些遗留的问题

17:33.660 --> 17:34.660
它自然而然就没了

17:34.660 --> 17:35.660
这就是

17:35.660 --> 17:36.660
咱们这个net和const

17:37.660 --> 17:38.660
没了

17:38.660 --> 17:39.660
然后这里

17:39.660 --> 17:40.660
我们可以有两个

17:40.660 --> 17:41.660
有两个练习

17:41.660 --> 17:42.660
咱们再看一下吧

17:42.660 --> 17:43.660
下面代码

17:43.660 --> 17:44.660
错误错在哪

17:45.660 --> 17:46.660
只能看一

17:46.660 --> 17:47.660
有没有错误

17:50.670 --> 17:51.670
有没有

17:51.670 --> 17:52.670
有错误对吧

17:52.670 --> 17:53.670
第一句话倒是没错误

17:53.670 --> 17:54.670
第二句话有错误

17:54.670 --> 17:55.670
什么错误

17:55.670 --> 17:57.670
就是必须给产量

17:57.670 --> 17:58.670
进行初始化

17:59.670 --> 18:01.670
missing in the snycer

18:01.670 --> 18:02.670
缺少了初始化

18:02.670 --> 18:03.670
在产量的生命中

18:03.670 --> 18:04.670
缺少初始化

18:04.670 --> 18:05.670
单码断二

18:05.670 --> 18:06.670
有没有错误

18:09.370 --> 18:10.370
有没有

18:10.370 --> 18:12.370
net是没有错误的

18:12.370 --> 18:13.370
const有错误

18:13.370 --> 18:14.370
因为你尝试

18:14.370 --> 18:16.370
对const变量进行修改

18:18.740 --> 18:19.740
那么这里

18:19.740 --> 18:21.740
我就顺便再说一句这个

18:22.740 --> 18:24.740
const虽然本身不能被修改

18:25.740 --> 18:26.740
但是这种情况

18:26.740 --> 18:28.740
你看一下A等于B等于2

18:29.740 --> 18:30.740
OB界A

18:30.740 --> 18:31.740
复制为3

18:31.740 --> 18:32.740
这样可以吗

18:33.740 --> 18:34.740
同学们

18:34.740 --> 18:35.740
这样绝对可以吗

18:36.740 --> 18:37.740
是可以的

18:37.740 --> 18:38.740
是可以的

18:39.740 --> 18:40.740
没有问题的

18:40.740 --> 18:41.740
叔叔没有抱错

18:41.740 --> 18:43.740
什么叫产量不可修

18:43.740 --> 18:44.740
不可更改

18:44.740 --> 18:45.740
指的是

18:45.740 --> 18:46.740
产量是谁

18:46.740 --> 18:47.740
产量是他

18:47.740 --> 18:49.740
你不能对他重新复制

18:49.740 --> 18:50.740
明白了意思吧

18:50.740 --> 18:51.740
你不能说

18:51.740 --> 18:52.740
这样子是不行的

18:52.740 --> 18:53.740
对他重新复制是不行的

18:53.740 --> 18:55.740
这样子是要抱错的

18:55.740 --> 18:57.740
你再给产量重新复制

18:57.740 --> 18:58.740
但这个属性是不是产量

18:58.740 --> 18:59.740
属性哪有产量的

18:59.740 --> 19:01.740
属性要变量的不是

19:01.740 --> 19:02.740
它就是属性

19:02.740 --> 19:03.740
所以这些都是正常的

19:03.740 --> 19:05.740
只是你这个符号

19:05.740 --> 19:06.740
这个OB界符号是产量

19:06.740 --> 19:08.740
你不能对他重新复制

19:08.740 --> 19:09.740
就是不能出现这样的代码

19:09.740 --> 19:11.740
OB界等于沙沙沙

19:11.740 --> 19:12.740
不能出现这种东西

19:12.740 --> 19:13.740
其他都是可以的

19:15.740 --> 19:16.740
搞清楚

19:16.740 --> 19:17.740
那么这里呢

19:17.740 --> 19:18.740
就是对B重新

19:18.740 --> 19:19.740
相当于是

19:19.740 --> 19:20.740
加加就相当于是改变他的值

19:20.740 --> 19:21.740
所以说不行

19:22.740 --> 19:24.740
好再下一个

19:24.740 --> 19:25.740
代码段3有没有错过

19:27.740 --> 19:28.740
是不是有错过

19:28.740 --> 19:30.740
你在变量之前使用它了

19:30.740 --> 19:31.740
过去的这个是没有错过的

19:31.740 --> 19:32.740
是用内测

19:32.740 --> 19:33.740
那么就变正常了

19:33.740 --> 19:34.740
它有错过

19:35.740 --> 19:36.740
好代码段4

19:36.740 --> 19:37.740
我再说一次

19:37.740 --> 19:39.740
你们只要能够听懂

19:39.740 --> 19:40.740
我的课

19:40.740 --> 19:43.740
能够把那练习做出来

19:43.740 --> 19:44.740
就OK了

19:44.740 --> 19:45.740
忘随便忘

19:46.740 --> 19:48.740
后边慢慢的去加深影响

19:48.740 --> 19:49.740
因为我们后边代码

19:49.740 --> 19:50.740
都会用内测放出来定义变量

19:51.740 --> 19:52.740
慢慢去加深影响

19:53.740 --> 19:54.740
好代码段4

19:54.740 --> 19:55.740
这个东西没有错过

19:56.740 --> 19:57.740
是不是有错过

19:57.740 --> 19:58.740
怎么错过

19:58.740 --> 19:59.740
就重复定义变量了

19:59.740 --> 20:00.740
以前是可以的

20:00.740 --> 20:01.740
现在是不行的

20:02.740 --> 20:03.740
好了完事

20:04.740 --> 20:05.740
好第二题

20:06.740 --> 20:08.740
这题就是非常典型的一个例子

20:08.740 --> 20:11.740
比方说咱们这里有10个按钮

20:12.740 --> 20:13.740
有10个按钮

20:13.740 --> 20:16.740
那么现在我要做这么一件事

20:16.740 --> 20:18.740
就是我要遍地所有按钮

20:18.740 --> 20:19.740
给它注册点击事件

20:22.380 --> 20:23.380
通常写一下吧

20:23.380 --> 20:24.380
当天视频写一下吧

20:25.380 --> 20:26.380
得到所有的按钮注册点击事件

20:27.380 --> 20:28.380
这个很简单

20:30.380 --> 20:31.380
好咋先

20:31.380 --> 20:33.380
Focus

20:34.380 --> 20:35.380
拿到所有的按钮

20:39.380 --> 20:40.380
我们用Const

20:40.380 --> 20:41.380
之后就用Const

20:42.380 --> 20:43.380
拿到按钮过后

20:43.380 --> 20:44.380
我们要循环它

20:44.380 --> 20:45.380
对不对

20:45.380 --> 20:46.380
怎么循环它

20:53.380 --> 20:54.380
循环所有的按钮

20:54.380 --> 20:55.380
然后给每一个按钮了

20:55.380 --> 20:56.380
注册点击事件

20:56.380 --> 20:57.380
是不是on click

20:58.380 --> 20:59.380
当然你用Agg

20:59.380 --> 21:00.380
因为它nation了也是一样

21:01.380 --> 21:02.380
注册点击事件

21:02.380 --> 21:03.380
点击的时候干嘛呢

21:04.380 --> 21:06.380
输出一个数字

21:06.380 --> 21:07.380
这个数字表示的是

21:07.380 --> 21:08.380
点的是第几个按钮

21:08.380 --> 21:10.380
就输出

21:10.380 --> 21:11.380
意思就是输出

21:11.380 --> 21:12.380
我们输出i加1也行

21:13.380 --> 21:14.380
i从0开始

21:14.380 --> 21:15.380
加1过就从1开始

21:17.380 --> 21:18.380
那么过去呢

21:18.380 --> 21:19.380
你看过去呢

21:19.380 --> 21:21.380
我们用挖来试一下

21:21.380 --> 21:23.380
过去会有个什么情况

21:23.380 --> 21:24.380
点第1个

21:24.380 --> 21:25.380
第2个实义

21:25.380 --> 21:26.380
全是实义对吧

21:26.380 --> 21:27.380
这个问题呢

21:27.380 --> 21:28.380
跟那个seton mouse

21:28.380 --> 21:29.380
本质是一样的

21:29.380 --> 21:30.380
当它点击它的时候

21:30.380 --> 21:32.380
这个循环早就结束了

21:33.380 --> 21:34.380
我点它的时候

21:34.380 --> 21:35.380
循环早就结束了

21:35.380 --> 21:36.380
输出循环结束

21:38.380 --> 21:39.380
循环结束

21:40.380 --> 21:41.380
然后做了一个i

21:44.070 --> 21:45.070
我就输出i嘛

21:45.070 --> 21:46.070
这样看得清

21:46.070 --> 21:47.070
看得好理解点

21:47.070 --> 21:48.070
好 你看

21:48.070 --> 21:49.070
我还没有点

21:49.070 --> 21:50.070
我还没有点按钮

21:50.070 --> 21:51.070
是不是循环早就结束了

21:52.070 --> 21:53.070
那个循环过程中

21:53.070 --> 21:54.070
只是给它注册了时间而已

21:54.070 --> 21:55.070
i的只是实

21:55.070 --> 21:57.070
那么现在我点按钮

21:57.070 --> 21:58.070
输出i

21:58.070 --> 21:59.070
那不就是输出实吗

21:59.070 --> 22:00.070
这是过去的问题

22:00.070 --> 22:01.070
对吧

22:01.070 --> 22:02.070
那么现在把它编成内的

22:02.070 --> 22:03.070
问题就不见了

22:05.770 --> 22:07.770
首先i它不能在循环外使用了

22:07.770 --> 22:09.770
因为它是有块儿集中用域的

22:09.770 --> 22:10.770
除了这个块儿集中用域

22:10.770 --> 22:11.770
它就不能用了

22:11.770 --> 22:13.770
所以我们只能知道循环结束了

22:14.770 --> 22:15.770
然后那每一个按钮点击的时候

22:15.770 --> 22:17.770
它用的是自己的那个i

22:17.770 --> 22:19.770
它每一个都有自己的作用域

22:19.770 --> 22:21.770
这些问题就自然而然的消失了

22:22.770 --> 22:24.770
反正你只有直接用内车

22:24.770 --> 22:25.770
抗死了

22:25.770 --> 22:26.770
你会发现这个世界

22:26.770 --> 22:27.770
以下变得清爽了

22:28.770 --> 22:30.770
这是这么一个升级

22:30.770 --> 22:32.770
将来密运算

22:32.770 --> 22:34.770
我连例子都不想给你举了

22:34.770 --> 22:35.770
你自己看嘛

22:35.770 --> 22:36.770
你知道这个

22:36.770 --> 22:37.770
两个新号就是密运算

22:37.770 --> 22:38.770
啥意思

22:38.770 --> 22:39.770
二德三次房

22:39.770 --> 22:40.770
二德四次房

22:41.770 --> 22:43.770
下面制服串新增的API

22:45.770 --> 22:46.770
你自己看一下吧

22:47.770 --> 22:48.770
这里边有一个链接

22:48.770 --> 22:50.770
就链接到官方文档MDN的官方文档

22:51.770 --> 22:52.770
非常简单

22:52.770 --> 22:53.770
第一个就是

22:53.770 --> 22:54.770
我来看

22:55.770 --> 22:56.770
演示一个就行了

22:57.770 --> 22:58.770
API就更加不要急了

22:58.770 --> 22:59.770
与法呢

22:59.770 --> 23:00.770
我们还多多掏掏

23:00.770 --> 23:01.770
看一看吧

23:01.770 --> 23:02.770
也不用背

23:02.770 --> 23:03.770
API就更不要急了

23:03.770 --> 23:04.770
需要个时候来查

23:04.770 --> 23:06.770
就是以前的制服串里边

23:06.770 --> 23:07.770
你首先要看懂

23:07.770 --> 23:09.770
看懂文档是啥意思

23:09.770 --> 23:11.770
实际Prototype

23:11.770 --> 23:12.770
Increase

23:13.770 --> 23:14.770
为什么要这样子写

23:15.770 --> 23:17.770
说明它是一个圆形方法

23:17.770 --> 23:19.770
这个increase是个圆形方法

23:19.770 --> 23:21.770
什么叫圆形方法

23:21.770 --> 23:22.770
圆形方法

23:22.770 --> 23:24.770
比方说9个例子

23:24.770 --> 23:26.770
要学会看文档了

23:26.770 --> 23:28.770
比方说我是这样子写的

23:28.770 --> 23:29.770
叉叉叉

23:30.770 --> 23:32.770
说明它是一个静态方法

23:32.770 --> 23:34.770
静态方法怎么调用的

23:34.770 --> 23:36.770
是使用这种方式来调用的

23:36.770 --> 23:37.770
比方说这个from charcoal的

23:37.770 --> 23:38.770
它就是个静态方法

23:38.770 --> 23:40.770
直接使用那个

23:40.770 --> 23:41.770
内名

23:41.770 --> 23:43.770
这个函数名

23:43.770 --> 23:44.770
方法名

23:44.770 --> 23:45.770
调用的

23:45.770 --> 23:46.770
知道吧

23:47.770 --> 23:49.770
然后什么叫圆形方法呢

23:49.770 --> 23:50.770
圆形方法

23:50.770 --> 23:51.770
你不能用这种方式来调用

23:51.770 --> 23:52.770
比方说increase

23:52.770 --> 23:53.770
根本没有这个方法

23:53.770 --> 23:55.770
圆形方法必须要用实力去调用

23:55.770 --> 23:57.770
比方说你真正的有一个制服串

23:57.770 --> 23:59.770
比方说一个abc这个制服串

23:59.770 --> 24:00.770
用increase

24:00.770 --> 24:02.770
这叫圆形方法

24:02.770 --> 24:03.770
原来的意思吧

24:04.770 --> 24:06.770
这是要看懂文档

24:06.770 --> 24:07.770
那么increase是一个圆形方法

24:07.770 --> 24:09.770
就是我们直接使用 ceram Brown

24:09.770 --> 24:10.770
increase就可以调用

24:10.770 --> 24:11.770
它啥意思呢

24:11.770 --> 24:12.770
就是看一下

24:12.770 --> 24:13.770
这个制服就是说

24:13.770 --> 24:15.770
是否包含某一个制服

24:15.770 --> 24:16.770
以前没有这个方法的

24:16.770 --> 24:18.270
以前我们要自己写个函数

24:18.270 --> 24:19.770
用index的手以去判断

24:19.770 --> 24:20.770
很麻烦

24:20.770 --> 24:21.770
现在我们直接可以用这个方法了

24:22.770 --> 24:23.770
看一下有没有b这个制服呢

24:23.770 --> 24:24.770
有

24:25.770 --> 24:26.770
谁这个制服呢

24:26.770 --> 24:27.770
有

24:27.770 --> 24:28.770
d这个制服

24:28.770 --> 24:29.770
force

24:30.770 --> 24:31.770
就这么有这回事

24:32.770 --> 24:33.290
fark

24:33.290 --> 24:34.770
新 fitted schin

24:34.770 --> 24:35.770
粤的

24:35.770 --> 24:37.070
B

24:37.070 --> 24:39.110
去除制服串的守卫空白制服

24:39.370 --> 24:40.910
比方说一个制服串

24:41.690 --> 24:42.190
A

24:42.450 --> 24:42.950
E

24:43.210 --> 24:43.730
C

24:45.270 --> 24:46.030
点Tune

24:47.050 --> 24:49.110
那么它可以去掉它的守卫空白制服

24:49.370 --> 24:50.630
你看守卫空白制服是不是去掉了

24:50.890 --> 24:51.910
中间是不会去掉了

24:52.170 --> 24:52.950
叫Tune

24:53.210 --> 24:54.730
但是它不会改变这个制服串本身

24:54.990 --> 24:56.270
它是返回一个新的制服串

24:56.790 --> 24:58.830
然后呢我们可以使用TuneStart

24:59.590 --> 25:01.390
去掉开始的空白制服

25:01.650 --> 25:03.190
也可以使用不用去计啊

25:03.690 --> 25:04.210
TuneEnd

25:04.470 --> 25:05.750
去掉末尾的空白制服

25:06.750 --> 25:07.550
它就起这么一个作用

25:07.810 --> 25:09.590
那有时候说它为什么要去掉呢

25:09.850 --> 25:11.390
比方说有的时候我们网页上

25:11.650 --> 25:12.650
收集用户信息

25:12.910 --> 25:13.930
让用户注册

25:14.190 --> 25:14.970
填写帐号密码

25:15.730 --> 25:17.530
那用户有的时候可能进武团

25:18.290 --> 25:20.610
玩玩多了经常给你敲几个空格

25:21.110 --> 25:21.630
在前面

25:22.130 --> 25:23.930
然后我们就需要把守卫空白制服给它去掉

25:24.190 --> 25:24.950
因为这个空格呢

25:25.210 --> 25:25.710
在帐号里面

25:25.970 --> 25:27.510
守卫空白制服是没有任何意义的

25:28.030 --> 25:29.310
我们需要把守卫空白制服去掉

25:30.830 --> 25:32.630
然后这个给它加了一个Replex All

25:32.890 --> 25:34.670
可以去可以替换所有的制服

25:34.870 --> 25:36.150
以前只有一个Replex对吧

25:36.410 --> 25:38.210
Replex如果第1个参数传输不错的话

25:38.210 --> 25:38.970
它只会去掉

25:39.230 --> 25:41.270
只会给你替换第1个

25:42.050 --> 25:43.330
除非你写正的表达是

25:44.610 --> 25:45.370
ABC

25:45.630 --> 25:46.150
ABC

25:46.410 --> 25:46.910
ABC

25:47.170 --> 25:48.450
以前我们用Replex

25:48.950 --> 25:49.730
把ABC

25:49.990 --> 25:51.270
变成123

25:53.050 --> 25:54.590
它只会替换第1个

25:55.350 --> 25:57.410
那么现在我们有了一个Replex All

25:57.670 --> 25:58.430
它可以替换所有

25:59.710 --> 26:00.470
就这么的东西

26:00.990 --> 26:01.750
StartWiz

26:02.270 --> 26:04.570
判断一个制服算是不是以某一个东西开头

26:04.670 --> 26:05.170
ABC

26:06.430 --> 26:07.030
ABC

26:07.270 --> 26:08.210
水面侠写的

26:08.970 --> 26:11.270
StartWiz

26:11.530 --> 26:12.710
是不是也ABC开头

26:12.970 --> 26:13.470
2

26:13.710 --> 26:14.950
是不是ABC一开头

26:15.210 --> 26:15.710
Force

26:16.150 --> 26:17.430
另外一个是Andwiz

26:17.670 --> 26:18.950
是不是以某个东西结尾

26:19.210 --> 26:19.990
自己看吧

26:20.750 --> 26:21.710
大概说一下

26:22.550 --> 26:24.330
这是一些API了解就想了

26:24.590 --> 26:26.130
想起来就用想不想拿到

26:26.390 --> 26:28.430
这东西不是说没有人拿把刀

26:28.690 --> 26:29.970
架在脖子上必须要用

26:30.230 --> 26:30.730
你学了必须要用

26:30.990 --> 26:32.010
没有人这样搞

26:32.990 --> 26:35.290
是一个长期潜移默化的过程

26:35.530 --> 26:36.370
想起来就用

26:36.610 --> 26:38.170
你用了一时觉得它爽了

26:38.410 --> 26:39.950
那么将来你就会想到

26:40.210 --> 26:41.230
你就会不停地用它

26:41.490 --> 26:42.250
慢慢就记住了

26:42.490 --> 26:43.270
就是这么一个过程

26:44.050 --> 26:45.330
需要个长期的期待

26:46.090 --> 26:48.130
接下来是一个语法

26:48.390 --> 26:49.170
叫模板制服串

26:49.430 --> 26:50.690
就本节课的最后一个东西

26:53.250 --> 26:55.050
模板制服串它是这么一回事

26:55.310 --> 26:58.130
ES6以前咱们用制服串都是用两种形式

26:58.370 --> 26:59.150
一种是单印号

26:59.410 --> 27:00.690
一种是双印号来写

27:00.890 --> 27:02.430
甭管是单印号双印号

27:03.190 --> 27:05.250
拼接制服串总是一个麻烦事

27:05.510 --> 27:08.070
不要说你们他有的时候拼着拼着我都拼晕了

27:08.830 --> 27:10.870
所以说以前的做开发的时候

27:11.130 --> 27:12.430
面试体经常问题

27:13.690 --> 27:16.010
拼接制服串有什么样有什么样好的技巧

27:16.270 --> 27:17.270
以前是有些技巧的

27:17.530 --> 27:19.590
不过这些技巧在ES6出现过后

27:20.090 --> 27:20.870
统统拉垮了

27:21.370 --> 27:23.430
因为ES6这个模板制服串太强大了

27:25.210 --> 27:26.250
模板制服串的写法就是

27:26.510 --> 27:28.290
一个反印号开头一个反印号结尾

27:28.550 --> 27:29.310
中间写制服串那种

27:29.510 --> 27:30.310
写法跟一样

27:30.550 --> 27:32.030
就是把单印号变成反印号了

27:32.470 --> 27:33.470
他有什么好处呢

27:33.730 --> 27:35.150
他的好处是搭搭地有的

27:37.670 --> 27:38.430
比方说

27:38.690 --> 27:41.090
以前我再写着写着能换行吧在这里

27:41.510 --> 27:42.030
不能吧

27:42.290 --> 27:44.850
以前你试一下用单印号用双印号你看能换行吗

27:45.610 --> 27:46.370
你不能换行

27:46.630 --> 27:47.670
你只以前怎么做

27:47.830 --> 27:49.470
以前只能写个写钢N

27:49.990 --> 27:51.510
用这个东西表示制服串换行

27:51.770 --> 27:53.050
现在用模板制服串直接换行

27:53.810 --> 27:55.090
他就直接识别出换行

27:55.350 --> 27:56.890
然后把这个地方就替换成写钢N了

27:58.170 --> 28:00.210
那么如果说制服串里边要拼接怎么办呢

28:00.470 --> 28:01.490
以前我们要写个

28:01.750 --> 28:03.550
制服串结束然后两个加

28:03.790 --> 28:04.570
现在仍然可以啊

28:04.830 --> 28:05.590
仍然可以没问题的

28:06.610 --> 28:09.170
有了模板制服串过后用这种拼接方式就太low了

28:09.430 --> 28:10.190
你看这里怎么拼接的

28:12.600 --> 28:13.360
我有个对象

28:13.620 --> 28:14.380
对象里边有两个属性

28:14.640 --> 28:16.700
现在呢我要写个制服串拼接成这么一个东西

28:16.940 --> 28:17.460
姓名

28:20.050 --> 28:20.830
以前我要打写

28:21.330 --> 28:21.850
我要这东西

28:22.110 --> 28:23.130
拼接拼接

28:23.390 --> 28:24.150
你看这个多额心

28:24.410 --> 28:25.170
还这里换个行

28:26.210 --> 28:28.510
现在我们直接用模板制服串的话就非常简单

28:30.900 --> 28:31.400
姓名

28:31.660 --> 28:32.940
你直接写制服串内容就行了

28:33.200 --> 28:33.720
好这个地方

28:33.980 --> 28:35.500
要拼接那就写个多乐站位

28:35.760 --> 28:37.040
然后两个大括号

28:37.560 --> 28:39.100
中间就写个介石表达式

28:39.860 --> 28:41.140
中间是个介石表达式

28:41.400 --> 28:42.540
他会把这个表达式内容

28:42.800 --> 28:43.960
油热点M什么摩尼卡

28:44.220 --> 28:46.260
那么他会把摩尼卡就替换掉这个位置

28:48.060 --> 28:49.080
这就是拼接

28:49.340 --> 28:50.360
就是很舒服啊现在

28:50.620 --> 28:51.640
我们来输出一下S1

28:55.780 --> 28:56.460
对吧就出来了

28:58.120 --> 28:58.620
那意思

29:00.620 --> 29:03.380
好这是制服串拼接那么这个制服串拼接我们以后

29:04.380 --> 29:06.700
在这种情况下是非常有用的比方说像这种

29:09.410 --> 29:10.430
你看一下

29:10.690 --> 29:10.950
这个代码

29:13.410 --> 29:15.990
比方说一个用户我觉得简单的一个例子

29:16.230 --> 29:17.270
一个用户有些属性

29:17.510 --> 29:20.330
然后我要把它拼接成一段ATM显示到页面上

29:20.590 --> 29:23.150
比方说我设置某一个容器的InnerATM

29:23.410 --> 29:24.430
把这个ATM设计进去

29:24.690 --> 29:26.210
所以我以前要拼接很麻烦

29:26.470 --> 29:29.030
那么现在呢有的模板制服串过后拼接非常简单

29:29.290 --> 29:30.410
你中间随便换行

29:30.670 --> 29:31.550
把个直接复制过来

29:31.950 --> 29:33.230
然后哪个地方要替换

29:33.470 --> 29:35.270
这个地方要替换写个多了两个大泼号

29:35.790 --> 29:37.070
把要替换的东西写到中间就完事了

29:37.830 --> 29:38.610
非常方便

29:39.890 --> 29:41.150
我们来输出一下这个ATM

29:42.190 --> 29:43.990
输出的结果下面都有出示啊就这个结果

29:45.770 --> 29:46.790
你看这个地方

29:47.310 --> 29:47.810
是不是就

29:49.350 --> 29:50.630
这个玩意

29:53.680 --> 29:54.940
这个地方是不是替换成了

29:55.460 --> 29:57.000
就这个东西是不是替换成了它

29:57.520 --> 29:58.800
这个东西是不是替换成了

29:59.060 --> 29:59.560
实际

30:00.060 --> 30:01.100
对就这么个东西

30:02.380 --> 30:03.660
好那么这里有个练习商

30:03.920 --> 30:04.680
咱们来做一下吧

30:04.940 --> 30:06.720
这个练习商那是写了一个静态页面

30:13.230 --> 30:15.530
我们的单码里边的其实只有

30:15.790 --> 30:17.310
央视不用管都给你们写好了

30:17.570 --> 30:19.370
然后这里都是静态内容啊全是静态的

30:19.630 --> 30:21.930
就是说说一下咱们的这个元素结构啊

30:22.190 --> 30:25.510
然后我们的那个央视给你弄好了都是静态的

30:25.770 --> 30:27.290
现在呢你手上有一个数组

30:28.330 --> 30:28.830
就这个

30:29.090 --> 30:30.370
Movie使有这么一个数组

30:31.650 --> 30:32.410
这个数组里边

30:33.190 --> 30:34.470
每一个对象就是一个电影

30:35.870 --> 30:38.110
电影的编号这个东西不用管我们好像用不上

30:38.370 --> 30:40.710
电影的评分电影的标题电影的

30:40.970 --> 30:43.270
超链接地址有点了过后再跳到哪去

30:43.530 --> 30:44.810
电影的图片

30:45.070 --> 30:48.150
图片地址下面的各种东西不用管总之是一个电影的数组

30:48.650 --> 30:49.670
有这么一个对象数组

30:50.190 --> 30:53.770
现在要让你把这个数组转换成ATML

30:54.530 --> 30:56.330
每一个电影转换成ATML

30:56.590 --> 30:57.610
填充到哪

30:58.110 --> 30:59.390
填充到这个DIV里面去

30:59.910 --> 31:00.930
这个康天站里面去

31:01.710 --> 31:04.010
也就是说你一个电影要生成这么一个DIV

31:04.230 --> 31:05.490
一个电影叫生成这么一个DIV

31:05.750 --> 31:06.270
然后给它加进去

31:07.290 --> 31:08.570
这是个最简单的就是

31:08.830 --> 31:10.370
一个动作操作对吧

31:10.870 --> 31:11.650
那我们现在怎么做

31:11.910 --> 31:13.690
我就把之前的那种精彩的那种删了啊

31:19.360 --> 31:20.640
这是我们一个电影的DIV

31:20.900 --> 31:22.680
我把每一个电影要转换成这么一种格式

31:23.460 --> 31:24.220
那怎么写呢

31:24.480 --> 31:26.020
是不是我们要循环电影数组

31:26.780 --> 31:27.300
循环呗

31:28.060 --> 31:30.380
那只i等于零i小于movies

31:31.380 --> 31:32.160
dialins

31:32.420 --> 31:32.920
i加加

31:33.440 --> 31:34.720
那么每一个电影是不是可以拿到

31:36.000 --> 31:36.500
之后都

31:37.020 --> 31:38.300
改过来了啊不再用挖了

31:39.380 --> 31:41.420
是不是可以拿到每个电影对象

31:44.990 --> 31:46.870
可以拿到这里有很多个对吧

31:47.130 --> 31:47.910
电影对象可以拿到

31:48.410 --> 31:50.710
那每一个电影对象我要把它变成一个ATM

31:52.750 --> 31:53.270
ATM

31:53.530 --> 31:54.810
我们可以用什么磨半子不穿

31:55.070 --> 31:55.830
你们可以自己做一下

31:56.090 --> 31:56.870
让你视频自己做一下

31:57.370 --> 31:57.890
尝试一下

31:59.670 --> 31:59.930
好嘞

32:00.190 --> 32:01.710
那我们再继续讲啊

32:02.230 --> 32:04.530
所以我就把这个玩一下直接复制上去过来

32:04.790 --> 32:05.550
不玩了嘛

32:07.110 --> 32:07.850
然后我们对

32:08.110 --> 32:09.150
长口对象里边来

32:09.670 --> 32:10.430
哪些地方要改

32:10.630 --> 32:12.930
首先这个超链接的地址是不是要读这个

32:13.450 --> 32:14.210
对象的UIL

32:14.470 --> 32:15.750
那就拼呗

32:16.530 --> 32:17.290
M点

32:17.550 --> 32:19.090
UIL把拼到这个位置

32:19.850 --> 32:21.390
然后那个图片的路径

32:21.650 --> 32:22.930
图片的路径是不是要读这个

32:23.190 --> 32:23.690
cover

32:23.950 --> 32:25.490
那就拼呗你看这个多舒服

32:26.010 --> 32:26.510
cover

32:29.100 --> 32:31.160
然后这个超链接地址是不是也要拼

32:31.420 --> 32:33.200
那你看以前用单一号里去试一下了

32:33.460 --> 32:33.960
多噁心

32:34.220 --> 32:35.520
这个地方是不是要拼那个

32:36.020 --> 32:37.040
电影的标题

32:37.820 --> 32:39.600
对吧是不是就拼出来了拼出来这么一个

32:39.860 --> 32:40.360
制服串了

32:41.340 --> 32:42.860
然后呢我要干嘛

32:43.120 --> 32:43.940
我要把这个

32:44.200 --> 32:46.860
这是一个电影对吧每一个电影的

32:47.480 --> 32:48.760
我用一个完整的ATM吧

32:50.300 --> 32:51.320
然后这里我们Const

32:52.860 --> 32:54.400
先给他复这个空制服串

32:54.660 --> 32:57.900
然后每循环一次我往一个制服串拼接一段

32:58.240 --> 32:59.260
拼接一段ATM

32:59.520 --> 33:01.820
制服串对吧拼接一个电影的ATM

33:02.580 --> 33:04.620
那么这个肯定要运行要抱错的啊

33:05.140 --> 33:07.700
他说不能给产量复制所以说你看

33:07.860 --> 33:09.700
哦原来这个地方是产量想了一下

33:09.700 --> 33:11.740
好像他确实需要变对吧变成内容

33:13.240 --> 33:15.500
好循环我结束过后这个ATM是不是就出来了

33:17.410 --> 33:19.850
然后呢我把这个ATM复制给谁

33:20.950 --> 33:22.290
复制给document

33:23.450 --> 33:24.250
query

33:25.350 --> 33:26.110
上了一个团

33:27.690 --> 33:28.490
抗天呐

33:29.290 --> 33:30.290
intel ATM

33:31.690 --> 33:33.050
intel ATM

33:33.450 --> 33:33.990
复制

33:38.960 --> 33:39.560
抗天呐

33:41.000 --> 33:41.900
啊

33:42.200 --> 33:42.900
哈哈

33:44.300 --> 33:44.860
他这个

33:46.560 --> 33:48.160
图片他那边有那个啊

33:49.360 --> 33:52.000
啊那这个我我没办法我我确实没办法

33:52.000 --> 33:53.360
他这个图片他是有

33:54.460 --> 33:55.260
他是有那个啥

33:55.700 --> 33:57.960
呃他这个图片呢他是有

33:58.320 --> 33:59.260
防盗链的

33:59.400 --> 34:01.160
所以说呢你通过别的网站

34:01.860 --> 34:04.460
去链接这个图片呢他他不让你访问啊

34:04.460 --> 34:05.960
谁让这个图片是有的啊

34:05.960 --> 34:07.960
你直接访问在留言器里边访问是可以的

34:08.660 --> 34:09.800
比较说这个图片路径

34:10.900 --> 34:12.400
你可以点击右键检查啊

34:13.340 --> 34:15.600
这图片路径点击右键啊openware

34:15.600 --> 34:17.380
引人lil tab是可以访问的

34:17.380 --> 34:19.880
但是你用emil起元素在别的网站里边

34:19.880 --> 34:20.720
访问你就是不学

34:20.720 --> 34:22.580
这个图片我是来自于豆瓣的啊

34:22.580 --> 34:23.880
所以说他不允许你访问

34:23.880 --> 34:25.040
总之我们无所谓吧

34:25.040 --> 34:26.380
我们只是把一个练习做好

34:27.880 --> 34:29.180
练习像博伴直播社

34:29.680 --> 34:31.680
好了没了啊本节课就学了这么一些东西

34:31.680 --> 34:33.680
非常凝散的是不是每个东西都很简单

34:34.080 --> 34:36.280
这样我们就整个这部分都是这样子

34:36.280 --> 34:37.480
每个东西都很简单

34:38.480 --> 34:40.280
我一负担的就是最后一个

34:40.280 --> 34:41.880
我们放到最后把异布处理

34:42.360 --> 34:43.760
这是一个重点也是个难点

34:43.760 --> 34:45.360
其他地方都很简单

34:45.360 --> 34:46.760
就是东西多

34:46.760 --> 34:47.960
但是不需要礼拜

34:47.960 --> 34:49.360
有那边点印象就行了

34:49.360 --> 34:51.360
这是一个需要长期在开发中

34:51.360 --> 34:53.360
浅一末化的每个过程

34:53.360 --> 34:55.360
好这这部分内容啊

