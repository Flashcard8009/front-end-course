WEBVTT

00:00.000 --> 00:07.000
大家好 我是袁老师 咱们在这一课来聊一聊事件循环

00:07.000 --> 00:12.000
首先说这个事件循环 它到底有多重要呢 就这么跟你说

00:12.000 --> 00:16.000
你要不会事件循环 你根本就不懂前端

00:16.000 --> 00:21.000
有这么严重吗 必须有这么严重 一点不跟你开玩笑

00:21.000 --> 00:28.000
因为事件循环是浏览器的核心原理 没有事件循环浏览器的核心原理

00:28.000 --> 00:34.000
没有事件循环浏览器根本就跑不起来 啥用没有

00:34.000 --> 00:39.000
你说这个事件循环有多重要 而我们前端不就是跟浏览器打交道吗

00:39.000 --> 00:42.000
所以事件循环重要性不言而喻

00:42.000 --> 00:48.000
如果说你学前端是为了玩一玩 娱乐娱乐 那无所谓了

00:48.000 --> 00:54.000
因为咱们前端技术里边有一条从业余到职业的分水岭

00:54.000 --> 01:00.000
这个分水岭上面有很多的技术 事件循环是其中之一

01:00.000 --> 01:05.000
你要玩一玩不学也吧 但是你要把前端当成职业

01:05.000 --> 01:10.000
要谋求一个好的职业发展 事件循环你根本就绕不过去

01:10.000 --> 01:14.000
而且这个事件循环从实际的角度来说

01:14.000 --> 01:20.000
跟我们很多的技术产生的关联 比方说像什么技时期

01:20.000 --> 01:26.000
像什么将来你们要学习的promise 还有网络部分的阿迦克斯

01:26.000 --> 01:30.000
还有将来你们要学习的load 都跟事件循环有关系

01:30.000 --> 01:33.000
你说这些玩意哪个不是面试者常靠地

01:33.000 --> 01:36.000
所以说这个事件循环有的时候我们说

01:36.000 --> 01:42.000
它可以极大的缩减面试的时间 怎么讲

01:42.000 --> 01:46.000
你在面试了 来 首先来聊一聊事件循环吧

01:46.000 --> 01:49.000
你要聊得上来咱们就接着聊呗

01:49.000 --> 01:54.000
你要聊不上来我还温啥呢 你说我温啥 它不用温了

01:54.000 --> 01:58.000
所以事件循环对面试官而言

01:58.000 --> 02:03.000
可以极大的提高工作的效率 缩减的面试时间

02:03.000 --> 02:08.000
而且咱们介石里边有很多的奇奇怪怪的东西

02:08.000 --> 02:11.000
不知道大家发现没有 这里头听完之后

02:11.000 --> 02:15.000
你会发现很多奇怪的东西都可以得到解释了

02:16.000 --> 02:19.000
于是同学们静一下心来

02:19.000 --> 02:24.000
踏踏实实的跟着袁老师花了30 40 凡几十分钟的时间

02:24.000 --> 02:28.000
把这个事件循环测测的地地搞清楚

02:28.000 --> 02:33.000
如果说你之前没有学过事件循环 那么恭喜你

02:33.000 --> 02:39.000
你接下来这段时间看到的将是全网最权威的事件循环解释

02:39.000 --> 02:43.000
你看了这个玩意之后 其他的都可以不用看了

02:43.000 --> 02:46.000
如果说你之前学过事件循环

02:46.000 --> 02:51.000
那么我要求你把脑袋里边的东西全部清空

02:51.000 --> 02:53.000
全部忘记 为啥呢

02:53.000 --> 02:59.000
因为目前我看到的所有的教程里边讲的事件循环全是有问题的

02:59.000 --> 03:03.000
我都是说的比较客气了 很多就是完全错误的

03:04.000 --> 03:07.000
为啥我这么自信呢 你们听一会儿就知道了

03:07.000 --> 03:10.000
因为我的事件循环的支持来源

03:10.000 --> 03:14.000
一是W3C官网 第二是谷歌浏览器的实现员

03:15.000 --> 03:19.000
就不糾结了嘛 所以你踏踏实实地跟着我的思路

03:19.000 --> 03:21.000
把事件循环搞清楚

03:22.000 --> 03:25.000
咱们这个事件循环要讲的话

03:25.000 --> 03:28.000
我们要把它前因后果都要讲清楚

03:29.000 --> 03:32.000
不能直接讲它 不然不知道它怎么来的

03:32.000 --> 03:35.000
我们在首先讲浏览器的进程模型

03:35.000 --> 03:39.000
因为这个事件循环跟浏览器是密切相关的

03:39.000 --> 03:43.000
它不是跟什么介式相关 它跟介式有关系吗 有关系

03:43.000 --> 03:45.000
因为浏览器要执行介式

03:45.000 --> 03:48.000
它的关联是浏览器的边东西

03:48.000 --> 03:50.000
它是跟浏览器密切相关的

03:50.000 --> 03:53.000
所以说你得先了解浏览器

03:53.000 --> 03:57.000
那么讲浏览器呢 我们要讲一个浏览器的进程模型

03:57.000 --> 03:59.000
啥叫进程啊

03:59.000 --> 04:01.000
首先来看 什么叫进程

04:01.000 --> 04:04.000
一个程序 就是你们自己写过程序对吧

04:04.000 --> 04:06.000
写过介式程序嘛

04:06.000 --> 04:10.000
像QQ啊 微信啊 什么游戏啊 它们都属于程序

04:10.000 --> 04:13.000
程序运行需要啥

04:13.000 --> 04:16.000
它需要内存空间

04:16.000 --> 04:19.000
为啥呀 程序里边不得有变量吗

04:19.000 --> 04:22.000
不得有堆箱吗 不得有函数吗

04:22.000 --> 04:25.000
这些东西哪个不是放到内存里边的

04:25.000 --> 04:28.000
所以它需要有一块自己专属的内存空间

04:28.000 --> 04:30.000
分配给你一块你玩吧

04:30.000 --> 04:33.000
不够了再说 我给你扩容

04:33.000 --> 04:36.000
于是程序运行需要有一块专属的内存空间

04:36.000 --> 04:40.000
你可以把进程简单的理解为

04:40.000 --> 04:43.000
就是这块内存空间

04:43.000 --> 04:46.000
这块内存空间 就是进程

04:46.000 --> 04:50.000
那么每一个程序呢 启动的时候

04:50.000 --> 04:52.000
至少得有一个进程

04:52.000 --> 04:55.000
这个好理解吧 你至少得有一块空间嘛

04:55.000 --> 04:58.000
对吧 而且进程与进程之间呢

04:58.000 --> 05:00.000
是相互独立的

05:00.000 --> 05:02.000
就内存空间之间是隔离的

05:02.000 --> 05:06.000
一看这里 QQ 微信和王者荣耀

05:06.000 --> 05:09.000
他们的内存有的多 有的少 无所谓了

05:09.000 --> 05:12.000
但是他们的内存有没有交叉呀

05:12.000 --> 05:15.000
不可能交叉的 交叉的话就变成共享

05:15.000 --> 05:18.000
变成共用了 那有出大问题

05:18.000 --> 05:21.000
为什么呢 因为进程之所以这样设计

05:21.000 --> 05:24.000
它的目的就是为了隔离

05:24.000 --> 05:26.000
隔离的好处在什么呢

05:26.000 --> 05:28.000
QQ里自己出了问题了 表示内存空间里面

05:28.000 --> 05:30.000
乱着套了 自己崩溃了

05:30.000 --> 05:33.000
不会影响到微信 跟它有啥关系呢

05:33.000 --> 05:36.000
不会影响到你玩那个王者荣耀

05:36.000 --> 05:39.000
就这么个意思 他是为了隔离

05:39.000 --> 05:43.000
好 那么进程之间他是相互隔离的

05:43.000 --> 05:45.000
那他们之间能不能通信呢

05:45.000 --> 05:48.000
就比方说QQ里边想用微信里边的东西

05:48.000 --> 05:51.000
能不能用呢 不是说完全不行

05:51.000 --> 05:55.000
只要你想要 他愿意给就行

05:55.000 --> 05:58.000
说即使要通信 也需要双方同意

05:58.000 --> 06:02.000
比方说我家 跟隔壁家是相互努力的

06:02.000 --> 06:05.000
比方隔壁住的邓哥 咱们一个老师

06:05.000 --> 06:09.000
邓哥跟他媳妇儿吵架 影响不到我这边

06:09.000 --> 06:12.000
我家里边包饺子缺了酱油

06:12.000 --> 06:15.000
我也不能直接冲到邓哥家里边去拿吧

06:15.000 --> 06:18.000
我得干嘛呀 我得敲门嘛 对不对

06:18.000 --> 06:21.000
邓哥少一开门 说石柜呀 你怎么才来呀

06:21.000 --> 06:24.000
有日子没来了 邓哥不在家 赶快进来呗

06:24.000 --> 06:27.000
这个时候得到别人同意之后呢

06:27.000 --> 06:30.000
我才能去拿他的数据 就这么个意思

06:30.000 --> 06:35.000
这是进城 进城搞清楚了之后呢

06:35.000 --> 06:38.000
咱们来看县城 为什么要说县城呢

06:38.000 --> 06:40.000
因为这两个玩意就是密不可分的

06:40.000 --> 06:42.000
进城说完了说县城

06:42.000 --> 06:44.000
你才能理解浏览器的进城模型

06:44.000 --> 06:46.000
你理解了浏览器的进城模型

06:46.000 --> 06:49.000
才知道事件循环发生在哪个位置

06:49.000 --> 06:52.000
然后呢 我们才能去讲这个事件循环

06:52.000 --> 06:55.000
直到进城 我们再看县城

06:55.000 --> 06:59.000
除了进城之后 它有了内存空间了

06:59.000 --> 07:03.000
我们就可以运行程序的代码了

07:03.000 --> 07:06.000
那么问题是 谁来运行代码

07:06.000 --> 07:10.000
谁来运行代码呢 运行代码的那个人

07:10.000 --> 07:13.000
我们把它类比于人 一个人在读代码

07:13.000 --> 07:15.000
再运行那个代码 那个人呢

07:15.000 --> 07:18.000
我们就可以把它简单的成为县城

07:18.000 --> 07:22.000
所以说一个进城 它至少得有一个县城

07:23.000 --> 07:25.000
不然的话给你分配一块内存空间

07:25.000 --> 07:28.000
你又不干活 你不中拥啊 你又是啥拥啊

07:28.000 --> 07:30.000
赶快就把你给消灭掉了

07:30.000 --> 07:32.000
把这个进城给杀死

07:32.000 --> 07:35.000
我们把推出进城叫做杀死进城

07:35.000 --> 07:38.000
因为拥了 内存空间给你回收掉了

07:38.000 --> 07:41.000
因为咱们现实世界里面倒是有一些空置房

07:41.000 --> 07:45.000
没人住 但是在计算机里面不行

07:45.000 --> 07:48.000
计算机里面的内存是寸土寸金

07:48.000 --> 07:51.000
给了你就必须要干活

07:51.000 --> 07:54.000
一个人运行代码 那么给你的内存空间

07:54.000 --> 07:55.000
不是瞎给吗

07:55.000 --> 07:58.000
所以一个进城至少得有一个县城

07:58.000 --> 08:00.000
去干活去运行代码

08:00.000 --> 08:02.000
因此在进城启动的时候

08:02.000 --> 08:06.000
就会自动的创建一个县城来运行代码

08:06.000 --> 08:07.000
那么这个县城呢

08:07.000 --> 08:09.000
我们把它称之为主县城

08:09.000 --> 08:11.000
就是跟随着进城启动的时候

08:11.000 --> 08:13.000
产生了县城

08:13.000 --> 08:16.000
另外一个小的知识点 大家了解一下

08:16.000 --> 08:19.000
如果说主县城结束了

08:19.000 --> 08:21.000
整个程序就结束了

08:21.000 --> 08:23.000
这个了解一下就行了

08:23.000 --> 08:26.000
但是很多程序它比较复杂

08:26.000 --> 08:29.000
它可能需要同时的执行多块代码

08:29.000 --> 08:32.000
比方说像王者荣耀

08:32.000 --> 08:34.000
他要做很多事

08:34.000 --> 08:36.000
他要监听你的各种操作

08:36.000 --> 08:39.000
要让人物的跟随你的操作来移动

08:39.000 --> 08:41.000
还要进行网络通信

08:41.000 --> 08:44.000
看别人是咋操作的 都需要网络的

08:44.000 --> 08:46.000
这么多事情要做

08:46.000 --> 08:49.000
可能一个人忙不过来

08:49.000 --> 08:52.000
于是主县城忙不过来的时候

08:52.000 --> 08:54.000
他就会想办法

08:54.000 --> 08:56.000
他想什么办法呢 就多招联人呗

08:56.000 --> 08:59.000
会启动更多的县城来执行代码

08:59.000 --> 09:01.000
就跟我们家里面是一样的

09:01.000 --> 09:03.000
家里面不是有很多人吗 对不对

09:03.000 --> 09:05.000
内存空间就是我们整个屋子

09:05.000 --> 09:07.000
屋子里面不是有很多人吗

09:07.000 --> 09:08.000
邓哥家里面有很多人

09:08.000 --> 09:11.000
邓哥的媳妇 邓哥的孩子 邓哥的父母

09:11.000 --> 09:13.000
都不是人吗

09:14.000 --> 09:16.000
不都是人吗 对吧

09:18.000 --> 09:20.000
每个人是不是有每个人自己要做的事

09:20.000 --> 09:22.000
邓哥要做啥事

09:22.000 --> 09:27.000
邓哥要洗衣服 做饭 洗碗 扫地

09:27.000 --> 09:29.000
就做这么一些事

09:29.000 --> 09:32.000
接孩子 送孩子 扶倒孩子 写作业

09:32.000 --> 09:34.000
有很多事

09:34.000 --> 09:36.000
别人也有事 邓哥的媳妇要做啥

09:36.000 --> 09:40.000
邓哥的媳妇要看电影 追剧

09:40.000 --> 09:42.000
买东西 购物

09:42.000 --> 09:43.000
有很多事 是吧

09:43.000 --> 09:46.000
邓哥的父母要溜了 打麻将

09:46.000 --> 09:48.000
有很多事

09:48.000 --> 09:50.000
那么这些事他们可以同时进行

09:50.000 --> 09:52.000
邓哥的洗碗 你做饭

09:52.000 --> 09:55.000
不影响邓哥的媳妇 追剧

09:55.000 --> 09:57.000
所以说一个进城里面

09:57.000 --> 09:59.000
实际上可以包含多个县城

09:59.000 --> 10:00.000
就这么个意思

10:00.000 --> 10:01.000
看一下这个图

10:01.000 --> 10:04.000
比方说我们以王者荣耀为例

10:04.000 --> 10:06.000
王者荣耀是一个程序

10:06.000 --> 10:08.000
它是一个进城

10:08.000 --> 10:10.000
启动时候给它分配了一块内存空间

10:10.000 --> 10:11.000
就进城

10:11.000 --> 10:14.000
空间有了 那就干活呗

10:14.000 --> 10:16.000
它启动的时候会产生一个主县城

10:16.000 --> 10:18.000
它有很多事要做

10:18.000 --> 10:20.000
比如说要处理登录注册之类的事情

10:20.000 --> 10:22.000
要显示登录界面

10:22.000 --> 10:24.000
这都是属于它的任务

10:24.000 --> 10:26.000
有很多任务要一个个去做

10:26.000 --> 10:29.000
然后同时还有一个游戏县城

10:29.000 --> 10:31.000
来监控用户的操作

10:31.000 --> 10:33.000
点击 键盘的时间

10:33.000 --> 10:37.000
然后还要去响应用户的操作

10:37.000 --> 10:39.000
这些人物要跟随着用户的操作来移动

10:39.000 --> 10:42.000
那么这些人物放到游戏县城里面去做

10:42.000 --> 10:44.000
我只是举个例子

10:44.000 --> 10:46.000
那么这就是网络县城要通信的

10:46.000 --> 10:48.000
要看一下别人有没有移动

10:48.000 --> 10:50.000
移动到哪了 放了什么技能

10:50.000 --> 10:52.000
就这么一个意思

10:52.000 --> 10:54.000
它要同时进行很多的事情

10:54.000 --> 10:57.000
那么就产生了很多的县城

10:57.000 --> 11:00.000
当然王者荣耀不只是三个 多的很

11:00.000 --> 11:02.000
那么这些人物要用到的内存空间在哪

11:02.000 --> 11:03.000
都是这些

11:03.000 --> 11:05.000
他们共享一块内存空间

11:05.000 --> 11:07.000
都是自家人嘛

11:07.000 --> 11:09.000
你家里边进冰箱里边拿东西

11:09.000 --> 11:11.000
不需要打真情吧

11:11.000 --> 11:13.000
都自家人随便拿 随便用

11:13.000 --> 11:15.000
就这么个意思

11:15.000 --> 11:18.000
这是进城和县城的概念

11:18.000 --> 11:20.000
没问题吧 搞清楚了吧

11:20.000 --> 11:23.000
搞清楚这个东西过后

11:23.000 --> 11:26.000
我们就可以聊浏览器的进城模型了

11:26.000 --> 11:29.000
目的就是为了聊浏览器的进城模型

11:29.000 --> 11:31.000
聊完了浏览器的进城模型之后

11:31.000 --> 11:33.000
我们就可以聊时间循环了

11:33.000 --> 11:36.000
咱们来看一下浏览器有哪些进城和县城

11:37.000 --> 11:39.000
浏览器是一个应用程序

11:39.000 --> 11:41.000
而且它是一个多进城

11:41.000 --> 11:43.000
多县城的应用程序

11:43.000 --> 11:46.000
多县城我们可以理解

11:46.000 --> 11:48.000
因为我刚才说了

11:48.000 --> 11:50.000
一个程序可能要很多人来干活

11:50.000 --> 11:52.000
要很多人来运行代码

11:52.000 --> 11:54.000
你运行这一块代码 你运行那一块代码

11:54.000 --> 11:56.000
同时进行

11:56.000 --> 11:58.000
那为什么是多进城呢

11:58.000 --> 12:00.000
这个咋理解呢

12:00.000 --> 12:02.000
看好啊

12:02.000 --> 12:05.000
浏览器内部工作极其的复杂

12:05.000 --> 12:08.000
你知道现在浏览器有多复杂吗

12:08.000 --> 12:10.000
咋也不是以前十多年前的

12:10.000 --> 12:12.000
IED的那个时代了

12:12.000 --> 12:14.000
现在的浏览器的复杂度

12:14.000 --> 12:17.000
已经接近操作系统了

12:17.000 --> 12:20.000
其实我们开发领域

12:20.000 --> 12:24.000
说做什么技术研发

12:24.000 --> 12:26.000
很多都是扯烂的

12:26.000 --> 12:28.000
什么叫技术研发

12:28.000 --> 12:30.000
在我的概念里边

12:30.000 --> 12:32.000
搞操作系统开发

12:32.000 --> 12:34.000
搞浏览器开发

12:34.000 --> 12:37.000
这些玩意儿才叫技术研发

12:37.000 --> 12:39.000
其他的做什么业务需求

12:39.000 --> 12:41.000
写个程序啊 写个APP啊

12:41.000 --> 12:43.000
提一个公共库啊

12:43.000 --> 12:45.000
那个玩意儿叫啥研发

12:45.000 --> 12:46.000
那个玩意儿相对于浏览器

12:46.000 --> 12:49.000
相对于操作系统来说简单的不得了

12:49.000 --> 12:51.000
就大概说一下这个意思就行了

12:51.000 --> 12:54.000
就浏览器里边东西特别特别复杂

12:54.000 --> 12:55.000
现在浏览器

12:55.000 --> 12:56.000
像谷歌浏览器

12:56.000 --> 12:59.000
它都可以在浏览器里面存在一个操作系统

12:59.000 --> 13:00.000
就在浏览器窗口里边

13:00.000 --> 13:03.000
你可以像用Windows那样去操作东西

13:03.000 --> 13:05.000
就复杂到这种程度

13:05.000 --> 13:08.000
为了避免相互影响

13:08.000 --> 13:09.000
什么相互影响

13:09.000 --> 13:10.000
它里边各个功能模块

13:10.000 --> 13:12.000
相互影响

13:12.000 --> 13:14.000
减少连环崩溃的

13:14.000 --> 13:15.000
崩溃的击率

13:15.000 --> 13:16.000
这啥意思呢

13:16.000 --> 13:18.000
就是如果说它只有一个进程的话

13:18.000 --> 13:20.000
比方说这是浏览器

13:20.000 --> 13:22.000
浏览器给它开辟一块

13:22.000 --> 13:24.000
独立的内存空间

13:24.000 --> 13:26.000
所有事情全部在里边做

13:26.000 --> 13:29.000
这么多复杂的事

13:29.000 --> 13:30.000
很容易就导致

13:30.000 --> 13:32.000
一个功能出问题了

13:32.000 --> 13:33.000
全部崩溃了

13:33.000 --> 13:35.000
整个浏览器又崩溃了

13:35.000 --> 13:38.000
所以说它需要有很多个

13:38.000 --> 13:40.000
独立的内存空间

13:40.000 --> 13:42.000
也就是很多个进程

13:42.000 --> 13:43.000
可不可以呢

13:43.000 --> 13:44.000
是可以的没问题

13:44.000 --> 13:46.000
你可以这样想象吧

13:46.000 --> 13:47.000
邓哥呢

13:47.000 --> 13:49.000
有邓哥比较帅

13:49.000 --> 13:51.000
不知道他没见过没

13:51.000 --> 13:53.000
邓哥有好几个女朋友

13:53.000 --> 13:54.000
那怎么办呢

13:54.000 --> 13:56.000
为了避免打架

13:56.000 --> 14:00.000
不能把他们全部放到一个屋子里边

14:00.000 --> 14:03.000
那不上天了吗

14:03.000 --> 14:06.000
一个人在里面大吵大闹

14:06.000 --> 14:08.000
那整个家里面不得安宁

14:08.000 --> 14:10.000
那整个家里面就崩溃了

14:10.000 --> 14:11.000
那么怎么办呢

14:11.000 --> 14:13.000
得有多套房子

14:13.000 --> 14:14.000
大一台一套

14:14.000 --> 14:15.000
二一台一套

14:15.000 --> 14:16.000
三一台一套

14:16.000 --> 14:18.000
真是比较合理的

14:18.000 --> 14:20.000
大一台在家里边发脾气

14:20.000 --> 14:22.000
跟二一台就没关系

14:22.000 --> 14:23.000
懂了意思吗

14:23.000 --> 14:25.000
所以说浏览器呢

14:25.000 --> 14:26.000
它启动的时候

14:26.000 --> 14:29.000
实际上会开辟多个进程

14:29.000 --> 14:31.000
这些进程里面主要有三个

14:31.000 --> 14:32.000
其实不只三个

14:32.000 --> 14:35.000
但是我们要关心的其实就是这三个

14:35.000 --> 14:36.000
一个是浏览器进程

14:36.000 --> 14:37.000
一个是网络进程

14:37.000 --> 14:39.000
一个是渲染进程

14:39.000 --> 14:40.000
我们以后来说

14:40.000 --> 14:42.000
他们到底是干嘛的

14:42.000 --> 14:44.000
从这个图上面

14:44.000 --> 14:45.000
你可以看到

14:45.000 --> 14:47.000
每个进程是不是有一块独立的

14:47.000 --> 14:48.000
内存空间

14:48.000 --> 14:50.000
这是浏览器进程的

14:50.000 --> 14:51.000
这是网络进程的

14:51.000 --> 14:53.000
这是渲染进程的

14:53.000 --> 14:54.000
那么这样子一来

14:54.000 --> 14:55.000
什么好处呢

14:55.000 --> 14:57.000
比方说网络这一块

14:57.000 --> 14:58.000
这里一块崩溃了

14:58.000 --> 15:00.000
它不会影响到渲染

15:00.000 --> 15:03.000
不会影响到浏览器的进程

15:03.000 --> 15:04.000
其实我们这里可以

15:04.000 --> 15:06.000
通过浏览器看一下

15:06.000 --> 15:07.000
在浏览器里边

15:07.000 --> 15:08.000
可以非常清楚的看到

15:08.000 --> 15:10.000
它的进程模型

15:10.000 --> 15:13.000
点击这有一个更多工具

15:13.000 --> 15:14.000
这里边有个任务管理器

15:14.000 --> 15:15.000
看到没

15:15.000 --> 15:16.000
打开

15:16.000 --> 15:17.000
你看我们目前

15:17.000 --> 15:19.000
一个窗口都没有开

15:19.000 --> 15:20.000
对吧

15:20.000 --> 15:21.000
你看有多少进程

15:21.000 --> 15:22.000
是不是一大堆

15:22.000 --> 15:23.000
能看清楚吗

15:23.000 --> 15:25.000
我给大家放大一点

15:25.000 --> 15:26.000
是不是一大堆

15:26.000 --> 15:27.000
那么我们刚才说

15:27.000 --> 15:28.000
三个进程在哪呢

15:28.000 --> 15:29.000
看着

15:30.000 --> 15:31.000
第一个你看

15:31.000 --> 15:33.000
是个浏览器进程

15:33.000 --> 15:34.000
你看这个

15:34.000 --> 15:35.000
network service

15:35.000 --> 15:37.000
网络进程

15:37.000 --> 15:39.000
那么渲染进程在哪呢

15:39.000 --> 15:40.000
渲染进程就是

15:40.000 --> 15:42.000
一个标签页

15:42.000 --> 15:44.000
一个渲染进程

15:44.000 --> 15:45.000
一个标签页

15:45.000 --> 15:46.000
一个渲染进程

15:46.000 --> 15:47.000
比方说我们再来

15:47.000 --> 15:49.000
去打开一个新的标签页

15:49.000 --> 15:50.000
输入一个百度

15:50.000 --> 15:52.000
再来看一下这个进程模型

15:52.000 --> 15:54.000
在这

15:54.000 --> 15:56.000
我把这个调一下

15:56.000 --> 15:58.000
这样子吧

15:58.000 --> 15:59.000
好你看一下

15:59.000 --> 16:00.000
目前的进程

16:00.000 --> 16:01.000
浏览器进程

16:01.000 --> 16:02.000
网络进程

16:02.000 --> 16:03.000
还有啥

16:03.000 --> 16:04.000
这个新标签页

16:04.000 --> 16:06.000
就是空白标签页一个进程

16:06.000 --> 16:08.000
然后还有一个百度

16:08.000 --> 16:09.000
说这是渲染进程

16:09.000 --> 16:11.000
百度有一个渲染进程

16:11.000 --> 16:13.000
这个新标签页

16:13.000 --> 16:14.000
有一个渲染进程

16:14.000 --> 16:15.000
上面

16:15.000 --> 16:16.000
它是有很多很多进程的

16:16.000 --> 16:18.000
它不是一个

16:18.000 --> 16:19.000
好

16:19.000 --> 16:20.000
那么我们来聊一聊

16:20.000 --> 16:21.000
这三个进程

16:21.000 --> 16:22.000
到底是干嘛用的

16:22.000 --> 16:23.000
首先是浏览器进程

16:23.000 --> 16:24.000
它主要做什么呢

16:24.000 --> 16:26.000
它主要负责界面的展示

16:26.000 --> 16:27.000
什么界面展示

16:27.000 --> 16:29.000
不是页面的展示

16:29.000 --> 16:31.000
它不是这个界面的展示

16:31.000 --> 16:32.000
它是负责

16:32.000 --> 16:34.000
比方说标签页的样子

16:34.000 --> 16:36.000
还有这里后退前进

16:36.000 --> 16:37.000
按钮刷新按钮

16:37.000 --> 16:39.000
这个导航栏

16:39.000 --> 16:41.000
就这些部分的展示

16:41.000 --> 16:42.000
懂得意思吧

16:42.000 --> 16:43.000
这是这个浏览器进程

16:43.000 --> 16:44.000
要做的事

16:44.000 --> 16:46.000
还包括用户交互

16:46.000 --> 16:47.000
比方说用户在浏览器

16:47.000 --> 16:49.000
窗口里边点了啥

16:49.000 --> 16:50.000
滚动了滚动条

16:50.000 --> 16:52.000
滚动了鼠标滚轮

16:52.000 --> 16:54.000
或者是按钮盘

16:54.000 --> 16:56.000
这些东西都属于用户交互

16:56.000 --> 16:58.000
也是浏览器进程要负责的

16:58.000 --> 16:59.000
它要监听

16:59.000 --> 17:00.000
你到底动没动

17:00.000 --> 17:01.000
你到底点没点

17:01.000 --> 17:03.000
到底滑没滑

17:03.000 --> 17:05.000
这些是浏览器进程要处理的事

17:05.000 --> 17:07.000
还有一些什么指进程管理

17:07.000 --> 17:08.000
实际上呢

17:08.000 --> 17:10.000
这里就顺便了解一下就行了

17:10.000 --> 17:12.000
就是像这些进程

17:12.000 --> 17:13.000
网络进程

17:13.000 --> 17:14.000
渲染进程

17:14.000 --> 17:15.000
都是浏览器进程

17:15.000 --> 17:16.000
给它启动出来的

17:16.000 --> 17:17.000
就一开始

17:17.000 --> 17:18.000
最开始的时候

17:18.000 --> 17:19.000
只有一个进程

17:19.000 --> 17:21.000
但是它马上就会启动

17:21.000 --> 17:22.000
多个进程

17:22.000 --> 17:23.000
是由它来启动进程

17:23.000 --> 17:24.000
启动起来的

17:24.000 --> 17:26.000
所以叫止进程管理

17:26.000 --> 17:29.000
其他进程是由它来启动的

17:29.000 --> 17:30.000
这就是浏览器进程

17:30.000 --> 17:32.000
了解就行了

17:32.000 --> 17:34.000
我们刚才之前学过进程和现程

17:34.000 --> 17:37.000
我们说一个进程里边

17:37.000 --> 17:39.000
不能没有人干活

17:39.000 --> 17:42.000
进程里边又会包含多个现程

17:42.000 --> 17:43.000
因此浏览器的进程里边

17:43.000 --> 17:45.000
它会包含多个现程

17:45.000 --> 17:47.000
来处理不同的任务

17:47.000 --> 17:49.000
然后有的现程负责介面的展示

17:49.000 --> 17:50.000
就是后腿前进

17:50.000 --> 17:52.000
地址栏

17:52.000 --> 17:53.000
它到底长什么样子

17:53.000 --> 17:55.000
还有浏览器的皮肤之类的

17:55.000 --> 17:57.000
还有就是用户交互

17:57.000 --> 17:59.000
有一个现程专门来监听

17:59.000 --> 18:01.000
耳朵一直听

18:01.000 --> 18:04.000
用户到底有没有做什么操作

18:04.000 --> 18:06.000
就这么个意思

18:06.000 --> 18:07.000
接下来

18:07.000 --> 18:09.000
第二个进程 网络进程

18:09.000 --> 18:12.000
因为浏览器需要跟网络通信

18:12.000 --> 18:14.000
你写一个URLD指标

18:14.000 --> 18:15.000
这里写个百度

18:15.000 --> 18:17.000
一回车不得有网络通信

18:17.000 --> 18:19.000
这些图片不得有网络通信

18:19.000 --> 18:20.000
夹载出来吗

18:20.000 --> 18:23.000
所以说这些网络资源的夹载

18:23.000 --> 18:25.000
又需要单独的进程去处理

18:25.000 --> 18:27.000
叫做网络进程

18:27.000 --> 18:28.000
当然它里边

18:28.000 --> 18:30.000
也会分为很多个现程

18:30.000 --> 18:32.000
来处理不同的网络任务

18:32.000 --> 18:33.000
了解就行了

18:33.000 --> 18:34.000
我们这几课

18:34.000 --> 18:37.000
这些东西不会的详细讲

18:37.000 --> 18:39.000
重点关注下边的进程

18:39.000 --> 18:41.000
渲染进程

18:41.000 --> 18:42.000
这是我们本节课

18:42.000 --> 18:44.000
要重点讲解的进程

18:44.000 --> 18:49.940
喝口水

18:49.940 --> 18:52.940
渲染进程启动后

18:52.940 --> 18:54.940
它要做什么呢

18:54.940 --> 18:57.940
它会开启一个渲染主线程

18:57.940 --> 18:58.940
这个好理解吧

18:58.940 --> 18:59.940
一个进程启动过后

18:59.940 --> 19:01.940
是不是都有一个主进程

19:01.940 --> 19:03.940
那么渲染进程启动过后

19:03.940 --> 19:07.940
它那个随着开启的主线程

19:07.940 --> 19:10.940
就成为渲染主线程

19:10.940 --> 19:12.940
我们后边讲的都是它

19:12.940 --> 19:14.940
都跟它相关

19:14.940 --> 19:15.940
它要做什么事

19:15.940 --> 19:16.940
它做的事情

19:16.940 --> 19:19.940
就跟我们关系就特别重大了

19:19.940 --> 19:21.940
ATM4SS

19:21.940 --> 19:23.940
JS

19:23.940 --> 19:26.940
全是在它上面执行的

19:26.940 --> 19:29.940
就我们写的所有前端代码

19:29.940 --> 19:32.940
都是在这个现程里边执行的

19:32.940 --> 19:34.940
你说这么重要

19:34.940 --> 19:36.940
而且浏览器

19:36.940 --> 19:38.940
它会为每一个标签页

19:38.940 --> 19:41.940
开启一个全新的渲染进程

19:41.940 --> 19:42.940
刚才我们也看到过了

19:42.940 --> 19:45.940
它可以保证标签页之间

19:45.940 --> 19:47.940
不相互影响

19:47.940 --> 19:48.940
你看吧

19:48.940 --> 19:49.940
刚才看了过了

19:49.940 --> 19:50.940
这里有两个标签页

19:50.940 --> 19:52.940
于是我们在那个浏览器的

19:52.940 --> 19:53.940
任务管理器里边

19:53.940 --> 19:55.940
会看到有两个渲染进程

19:55.940 --> 19:56.940
你看

19:56.940 --> 19:57.940
这个新标签页

19:57.940 --> 19:58.940
你看这个

19:58.940 --> 19:59.940
百度一下

19:59.940 --> 20:00.940
百度这个标签页

20:00.940 --> 20:02.940
每一个标签页

20:02.940 --> 20:05.940
会开启一个新的渲染进程

20:05.940 --> 20:07.940
保证新标签页

20:07.940 --> 20:08.940
百度标签页崩溃了

20:08.940 --> 20:10.940
它不会影响到别的标签页

20:10.940 --> 20:13.940
进程之间是隔离的

20:13.940 --> 20:14.940
这意思吧

20:14.940 --> 20:18.940
其实这里大家了解一下

20:18.940 --> 20:23.940
就是浏览器目前最新版本里边

20:23.940 --> 20:26.940
有点想改变这种模式了

20:26.940 --> 20:27.940
为啥呢

20:27.940 --> 20:28.940
因为这样子做的话

20:28.940 --> 20:30.940
会开批的进程太多了

20:30.940 --> 20:31.940
你想一想

20:31.940 --> 20:32.940
平时你们上网的时候

20:32.940 --> 20:34.940
标签页可能很多很多

20:34.940 --> 20:36.940
特别像咱们搞钱专开发的

20:36.940 --> 20:39.940
要随时随地查阅各种文档资料

20:39.940 --> 20:41.940
所以说你们将来在开发的过程中

20:41.940 --> 20:44.940
你跟浏览器是这个样子的

20:44.940 --> 20:45.940
那这样子一来的话

20:45.940 --> 20:47.940
你可以想象得到

20:47.940 --> 20:50.940
它那个进程里边的看一下吧

20:50.940 --> 20:52.940
所以大堆渲染进程

20:52.940 --> 20:55.940
占用了很多的内存空间

20:55.940 --> 20:56.940
有的开玩笑说

20:56.940 --> 20:58.940
Krom也不是开玩笑了

20:58.940 --> 20:59.940
就真的

20:59.940 --> 21:01.940
谷歌浏览器特别吃内存

21:01.940 --> 21:03.940
内存杀手

21:03.940 --> 21:04.940
为什么呢

21:04.940 --> 21:05.940
就是因为它这种模式

21:05.940 --> 21:06.940
所以说目前

21:06.940 --> 21:08.940
谷歌浏览器想寻求改变

21:08.940 --> 21:10.940
它做了一些调整

21:10.940 --> 21:13.940
不过了目前在新版本的浏览器里边

21:13.940 --> 21:14.940
目前还是兼容状态

21:14.940 --> 21:16.940
就是还是用之前的那种模式

21:16.940 --> 21:18.940
一个标签页 一个进程

21:18.940 --> 21:20.940
但将来就会有变动了

21:20.940 --> 21:22.940
极有可能会有变动

21:22.940 --> 21:24.940
同学们如果说有兴趣的话

21:24.940 --> 21:26.940
可以看一下谷歌的官方说明文档

21:26.940 --> 21:28.940
它这里写的非常清楚

21:28.940 --> 21:30.940
它打算弄成什么样子

21:30.940 --> 21:33.940
它以后它会针对不同的平台

21:33.940 --> 21:35.940
像Windows 麦克丽娜克斯

21:35.940 --> 21:37.940
包括KromOS

21:37.940 --> 21:39.940
把浏览器作为一个操作系统

21:39.940 --> 21:41.940
这个玩意你们了解就行了

21:41.940 --> 21:43.940
针对这些平台的话

21:43.940 --> 21:45.940
它会启动这个模式

21:45.940 --> 21:47.940
就是一个占点 一个进程

21:47.940 --> 21:50.940
而不是一个标签页 一个进程

21:50.940 --> 21:51.940
就是一个占点

21:51.940 --> 21:52.940
什么意思呢

21:52.940 --> 21:53.940
就是你访问百度

21:53.940 --> 21:56.940
没问题 给你开个确诊进程

21:56.940 --> 21:58.940
但是你访问的还是百度

21:58.940 --> 22:01.940
只不过你访问的是百度的别的地方

22:01.940 --> 22:03.940
我看一下 百度图片

22:03.940 --> 22:05.940
还不对

22:05.940 --> 22:07.940
这样吧

22:07.940 --> 22:08.940
淘宝

22:08.940 --> 22:12.250
淘宝 这是一个进程

22:12.250 --> 22:14.250
如果说你访问的是

22:14.250 --> 22:16.250
淘宝某一个商品

22:16.250 --> 22:18.250
它都是属于淘宝网站

22:18.250 --> 22:20.250
比方说我这里点这个

22:20.250 --> 22:22.250
它们都是属于淘宝网站

22:22.250 --> 22:24.250
那么这样子的

22:24.250 --> 22:26.250
它就只会开一个进程

22:26.250 --> 22:28.250
这样子做是为了减少进程的数量

22:28.250 --> 22:29.250
一个占点

22:29.250 --> 22:31.250
不管有多少标签页

22:31.250 --> 22:33.250
它们同属于一个进程

22:33.250 --> 22:34.250
它是想变成这样子

22:34.250 --> 22:36.250
但是目前的默认情况下

22:36.250 --> 22:37.250
还不是这个

22:37.250 --> 22:39.250
还是一个标签页 一个进程

22:39.250 --> 22:41.250
可能会改成这样子

22:41.250 --> 22:43.250
之后它还针对其他情况

22:43.250 --> 22:45.250
比方说像Android

22:45.250 --> 22:47.250
然后针对那个

22:47.250 --> 22:50.250
第一内存的设备

22:50.250 --> 22:52.250
又是什么模式

22:52.250 --> 22:54.250
就是这些东西

22:54.250 --> 22:56.250
下面有它的历史模式

22:56.250 --> 22:58.250
就是我们目前正在使用的模式

22:58.250 --> 23:00.250
就是一个标签页

23:00.250 --> 23:02.250
一个进程

23:02.250 --> 23:03.250
per type

23:03.250 --> 23:05.250
type就是标签页

23:05.250 --> 23:07.250
process就进程

23:07.250 --> 23:09.250
一个标签页 一个进程

23:09.250 --> 23:11.250
目前使用的是这种模式

23:11.250 --> 23:13.250
其实之前也有其他模式

23:13.250 --> 23:15.250
不过需要进行配置和设置

23:15.250 --> 23:17.250
这些我们就不展开了

23:17.250 --> 23:18.250
有兴趣的同学可以了解一下

23:18.250 --> 23:20.250
这是谷歌的官方文档

23:20.250 --> 23:21.250
OK

23:21.250 --> 23:25.250
这就是浏览器的进程和线程模型

23:25.250 --> 23:27.250
就第一部分知识

23:27.250 --> 23:29.250
那么讲这部分知识要做什么呢

23:29.250 --> 23:33.250
我们叫引出渲染进程里边的

23:33.250 --> 23:35.250
渲染组线程

23:35.250 --> 23:38.250
因为我们世界循环发生在哪

23:38.250 --> 23:41.250
发生在这里边

23:41.250 --> 23:43.250
它为什么会发生在这里边

23:43.250 --> 23:46.250
世界循环到底又是什么东西

23:46.250 --> 23:48.250
我们接着往后看

23:48.250 --> 23:54.250
说这个渲染组线程是如何工作的呢

23:54.250 --> 23:57.250
渲染组线程是浏览器里边

23:57.250 --> 24:00.250
最繁忙的线程

24:00.250 --> 24:02.250
需要它处理的任务

24:02.250 --> 24:03.250
特别特别多

24:03.250 --> 24:05.250
我下面也罗略了一些

24:05.250 --> 24:06.250
之前我们其实也提到过

24:06.250 --> 24:07.250
他要做啥事

24:07.250 --> 24:09.250
Atemil 柜塔管

24:09.250 --> 24:11.250
CSS 柜塔管

24:11.250 --> 24:13.250
JS 柜塔管

24:13.250 --> 24:14.250
展开来说的话

24:14.250 --> 24:15.250
他要解析Atemil

24:15.250 --> 24:17.250
什么叫解析

24:17.250 --> 24:19.250
Atemil拿到了是一个制服圈

24:19.250 --> 24:20.250
他在把他解析

24:20.250 --> 24:21.250
他写的是啥

24:21.250 --> 24:22.250
你写的监控号

24:22.250 --> 24:23.250
你管他到底是啥

24:23.250 --> 24:25.250
他在理解

24:25.250 --> 24:27.250
然后CSS里边写选择器

24:27.250 --> 24:28.250
一个底

24:28.250 --> 24:29.250
后边写一个英文单词

24:29.250 --> 24:30.250
这是啥

24:30.250 --> 24:31.250
他在先把他理解

24:31.250 --> 24:33.250
理解的过程就是解析

24:33.250 --> 24:35.250
之后我们会详细说

24:35.250 --> 24:37.250
就是后边的课程我们会详细说

24:37.250 --> 24:39.250
这里我们简单了解一下就行了

24:39.250 --> 24:41.250
还就是央视要算

24:42.250 --> 24:44.250
你写到EM

24:44.250 --> 24:46.250
他要把它换算成PX

24:46.250 --> 24:47.250
把换算成像书

24:47.250 --> 24:49.250
你写的百分比

24:49.250 --> 24:51.250
也要把它换算成像书

24:51.250 --> 24:53.250
这都需要计算的

24:53.250 --> 24:55.250
包括央视冲突了

24:55.250 --> 24:57.250
是不是要进行沉迭规则

24:57.250 --> 25:00.250
要淘汰掉那些优先级低的

25:00.250 --> 25:02.250
最后就只剩一个

25:02.250 --> 25:03.250
这些计算过程

25:03.250 --> 25:05.250
也是主线程要做的

25:05.250 --> 25:07.250
还就是布局

25:08.250 --> 25:09.250
我们每一个元素

25:09.250 --> 25:11.250
它有多宽多高

25:11.250 --> 25:12.250
要算出来

25:12.250 --> 25:14.250
每个元素的位置

25:14.250 --> 25:15.250
要算出来

25:15.250 --> 25:17.250
我们把这一块统称为

25:17.250 --> 25:19.250
几何信息

25:19.250 --> 25:21.250
要全部算出来

25:21.250 --> 25:23.250
然后就可以画到页面上去了

25:23.250 --> 25:25.250
还要图成

25:25.250 --> 25:27.250
Zindex哪个在前

25:27.250 --> 25:29.250
哪个在后

25:29.250 --> 25:32.250
画背景还是宣画元素里面的元素

25:32.250 --> 25:34.250
它都要计算的

25:34.250 --> 25:36.250
我们平时觉得理所当然的事

25:36.250 --> 25:37.250
写了代码就可以显示出来了

25:37.250 --> 25:39.250
其实它要做很多很多

25:39.250 --> 25:41.250
复杂的操作

25:41.250 --> 25:42.250
才能把它显示出来

25:42.250 --> 25:44.250
这些网页都是

25:44.250 --> 25:47.250
宣然主线程的工作

25:47.250 --> 25:50.250
还要把每秒把页面画六十次

25:50.250 --> 25:51.250
简单了解

25:51.250 --> 25:54.250
主要是为了说明它很忙

25:54.250 --> 25:56.250
每秒把页面画六十次

25:56.250 --> 25:58.250
这些指示其实

25:58.250 --> 26:00.250
都要专门的课程去讲

26:00.250 --> 26:02.250
每秒把页面画六十次

26:02.250 --> 26:03.250
什么意思呢

26:03.250 --> 26:04.250
就是你们不知道

26:04.250 --> 26:05.250
我外面玩过游戏

26:05.250 --> 26:07.250
特别是PC装的游戏

26:07.250 --> 26:10.250
它有个FPS

26:10.250 --> 26:11.250
就帧率

26:11.250 --> 26:12.250
就是每秒钟

26:12.250 --> 26:15.250
它要把显示的东西

26:15.250 --> 26:17.250
画多好吃

26:17.250 --> 26:18.250
那么这样子

26:18.250 --> 26:20.250
用户才不会感觉到

26:20.250 --> 26:22.250
有跳跃

26:22.250 --> 26:24.250
像你们看电影的事了

26:24.250 --> 26:27.250
一秒钟会有很多的画面闪过

26:27.250 --> 26:30.250
这样子你会看到画面是连续的

26:30.250 --> 26:32.250
其实我们在浏览器里边

26:32.250 --> 26:34.250
在其他的应用程序也好

26:34.250 --> 26:36.250
都有这个东西在里边

26:36.250 --> 26:37.250
包括我们在这里

26:37.250 --> 26:38.250
比如说滚动滚动条

26:38.250 --> 26:40.250
你为什么会觉得它是个动画呢

26:40.250 --> 26:42.250
它是不停的在画

26:42.250 --> 26:43.250
不停的在画

26:43.250 --> 26:44.250
每一张图片之间

26:44.250 --> 26:45.250
间隔很小

26:45.250 --> 26:47.250
所以你感觉到一个滚动的动画

26:47.250 --> 26:49.250
这里也是一样

26:49.250 --> 26:50.250
浏览器它的界面上

26:50.250 --> 26:51.250
它要把界面

26:51.250 --> 26:53.250
每一秒钟画六十次

26:53.250 --> 26:54.250
这样子你会感觉到

26:54.250 --> 26:55.250
画面是流畅的

26:55.250 --> 26:56.250
是平滑的

26:56.250 --> 26:58.250
简单了解就行了

26:58.250 --> 27:01.250
这些东西我们将来有机会了

27:01.250 --> 27:02.250
有些东西我们后边会讲

27:02.250 --> 27:04.250
有些东西就是在

27:04.250 --> 27:07.250
咱们后期的课程里边

27:07.250 --> 27:09.250
还要执行介石带

27:09.250 --> 27:11.250
还要处理事件函数

27:11.250 --> 27:13.250
监听了事件过后

27:13.250 --> 27:14.250
按了点亮按钮之后

27:14.250 --> 27:15.250
它要运行啥函数

27:15.250 --> 27:17.250
也是它处理

27:17.250 --> 27:18.250
计时器到时间了

27:18.250 --> 27:20.250
它还要执行它的回调函数

27:20.250 --> 27:22.250
全是它的处理

27:22.250 --> 27:24.250
你说忙不忙

27:24.250 --> 27:26.250
所以说像袁老师

27:26.250 --> 27:29.250
这么忙的人

27:29.250 --> 27:31.250
在这个浏览器的渲染

27:31.250 --> 27:33.250
主线层面前

27:33.250 --> 27:35.250
我能算躺平

27:35.250 --> 27:37.250
它就忙到这种程度

27:37.250 --> 27:39.250
我们说996已经很辛苦了

27:39.250 --> 27:41.250
它是007

27:41.250 --> 27:43.250
而且还没有工资

27:43.250 --> 27:45.250
不停地忙

27:45.250 --> 27:47.250
这里有个思考题

27:47.250 --> 27:49.250
就是说

27:50.250 --> 27:53.250
为什么渲染进程

27:53.250 --> 27:55.250
不是用于多个线层

27:55.250 --> 27:56.250
来处理这些事

27:56.250 --> 27:57.250
它不是很忙吗

27:57.250 --> 27:59.250
那你开多个线层

27:59.250 --> 28:01.250
不要全部交给主线层

28:01.250 --> 28:02.250
每个线层

28:02.250 --> 28:03.250
不是可以同时处理吗

28:03.250 --> 28:05.250
一个线层做ATML

28:05.250 --> 28:07.250
一个线层做CSS

28:07.250 --> 28:08.250
一个线层

28:08.250 --> 28:09.250
化页面

28:09.250 --> 28:10.250
一个线层执行介石

28:10.250 --> 28:11.250
多好啊

28:11.250 --> 28:12.250
互不干擾

28:12.250 --> 28:13.250
它为什么不这样做

28:13.250 --> 28:14.250
我给你们说

28:14.250 --> 28:16.250
这个问题

28:16.250 --> 28:18.250
不简单

28:18.250 --> 28:19.250
这个问题

28:19.250 --> 28:21.250
不是让你们现在思考

28:21.250 --> 28:22.250
现在思考的话

28:22.250 --> 28:24.250
你得出来结论也是不对的

28:24.250 --> 28:27.250
你们工作个两三年之后

28:27.250 --> 28:28.250
把这个问题

28:28.250 --> 28:29.250
可以把记下来

28:29.250 --> 28:30.250
工作个两三年之后

28:30.250 --> 28:32.250
不要忘了这个问题

28:32.250 --> 28:33.250
想一想

28:33.250 --> 28:34.250
当你有一天

28:34.250 --> 28:36.250
把这个问题搞清楚了过后

28:36.250 --> 28:38.250
浏览起了很多东西

28:38.250 --> 28:40.250
你就彻底搞清楚了

28:40.250 --> 28:41.250
不简单的

28:41.250 --> 28:42.250
两三年之后

28:42.250 --> 28:43.250
你可以再回过头

28:43.250 --> 28:44.250
来跟袁老师来进行讨论

28:44.250 --> 28:45.250
先留在这儿

28:45.250 --> 28:47.250
这个思考题

28:48.250 --> 28:50.250
反正我的结论就是

28:50.250 --> 28:52.250
没有办法

28:52.250 --> 28:54.250
我先把结论告诉你们

28:54.250 --> 28:55.250
浏览起

28:55.250 --> 28:56.250
他也苦啊

28:56.250 --> 28:57.250
他不是不想

28:57.250 --> 28:58.250
他做不到啊

28:58.250 --> 28:59.250
他最终

28:59.250 --> 29:00.250
全横过来

29:00.250 --> 29:01.250
全横过去

29:01.250 --> 29:02.250
他只能这样干

29:02.250 --> 29:03.250
他不是傻

29:03.250 --> 29:04.250
他不是不知道

29:04.250 --> 29:06.250
开皮多线层

29:06.250 --> 29:07.250
他没办法

29:07.250 --> 29:09.250
他只能这样干

29:09.250 --> 29:11.250
至于为什么呢

29:11.250 --> 29:12.250
留给大家

29:12.250 --> 29:14.250
别忘了这个问题就行了

29:14.250 --> 29:15.250
现在不用去思考

29:15.250 --> 29:16.250
你说一个线层

29:16.250 --> 29:19.250
毫无利己的动机

29:19.250 --> 29:20.250
把浏览起的事业

29:20.250 --> 29:22.250
作为自己的事业

29:22.250 --> 29:24.250
你说这是怎样的一种精神

29:24.250 --> 29:25.250
还没有工资

29:25.250 --> 29:27.250
天天忙

29:27.250 --> 29:29.250
那么要处理这么多任务

29:29.250 --> 29:31.250
忙就算了

29:31.250 --> 29:32.250
忙我就忙

29:32.250 --> 29:33.250
我也不叫苦

29:33.250 --> 29:34.250
也不叫累

29:34.250 --> 29:36.250
我就这个命

29:36.250 --> 29:37.250
那怎么办呢

29:37.250 --> 29:39.250
关键是

29:39.250 --> 29:40.250
你忙归忙

29:40.250 --> 29:41.250
还遇到一些

29:41.250 --> 29:43.250
不好处理的问题

29:43.250 --> 29:45.250
就是如何调度任务

29:45.250 --> 29:47.250
啥意思

29:47.250 --> 29:49.250
我给大家举几个例子

29:49.250 --> 29:51.250
比方说你正在执行

29:51.250 --> 29:52.250
一个介石函数

29:52.250 --> 29:53.250
你执行到一半了

29:53.250 --> 29:55.250
它有十行代码

29:55.250 --> 29:56.250
你运行到第五行了

29:56.250 --> 29:57.250
这个时候用户

29:57.250 --> 29:59.250
点击了某一个按钮

29:59.250 --> 30:01.250
怎么办

30:01.250 --> 30:03.250
我是暂停这个还代码的执行

30:03.250 --> 30:04.250
马上去执行

30:04.250 --> 30:07.250
用户的点击时间吗

30:07.250 --> 30:08.250
还是说我把这块

30:08.250 --> 30:10.250
函数执行完了之后

30:10.250 --> 30:12.250
再去执行那个

30:12.250 --> 30:13.250
点击事件的处理

30:13.250 --> 30:15.250
我怎么办

30:15.250 --> 30:16.250
第二个

30:16.250 --> 30:18.250
比方说我又运行

30:18.250 --> 30:19.250
一个介石函数

30:19.250 --> 30:20.250
我运行到一半了

30:20.250 --> 30:22.250
十行代码我运行到第五行

30:22.250 --> 30:23.250
这个时候有一个

30:23.250 --> 30:24.250
计时器到时间了

30:24.250 --> 30:26.250
我怎么办

30:26.250 --> 30:28.250
我暂停去执行那个计时器

30:28.250 --> 30:30.250
还是我把这个代码运行完了

30:30.250 --> 30:32.250
我再去执行计时器

30:32.250 --> 30:34.250
都是问题

30:34.250 --> 30:36.250
比方说

30:36.250 --> 30:38.250
浏览器告诉我

30:38.250 --> 30:40.250
用户点了一个按钮

30:40.250 --> 30:42.250
这个时候呢

30:42.250 --> 30:43.250
计时器也到哪时间了

30:43.250 --> 30:45.250
他们同时到的

30:45.250 --> 30:46.250
用户点了按钮的同时

30:46.250 --> 30:47.250
计时器也到时间了

30:47.250 --> 30:50.250
我处理哪一个呢

30:50.250 --> 30:52.250
全都是问题

30:52.250 --> 30:54.250
这些逻辑没理通的话

30:54.250 --> 30:55.250
就算忙

30:55.250 --> 30:58.250
他都不知道该怎么去忙

30:58.250 --> 31:00.250
那怎么办呢

31:00.250 --> 31:01.250
浏览器呢

31:01.250 --> 31:02.250
就想到了一个

31:02.250 --> 31:04.250
绝妙的主意

31:04.250 --> 31:05.250
这我啥也不干了

31:05.250 --> 31:06.250
我躺平了

31:06.250 --> 31:07.250
不玩了

31:07.250 --> 31:09.250
去他俩的我不玩了

31:09.250 --> 31:11.250
我躺平呗

31:11.250 --> 31:12.250
他本来就这么忙

31:12.250 --> 31:14.250
你还给我出这些难题

31:14.250 --> 31:15.250
那我不玩了

31:15.250 --> 31:17.250
当然这是开玩笑

31:17.250 --> 31:18.250
不可能罢工的

31:18.250 --> 31:19.250
怎么办呢

31:19.250 --> 31:20.250
得想一个办法

31:20.250 --> 31:22.250
办法就是排队

31:24.250 --> 31:25.250
有秩序的

31:25.250 --> 31:27.250
一件事一件事的做

31:27.250 --> 31:28.250
我事情很多

31:28.250 --> 31:30.250
但是每一件事做完之后

31:30.250 --> 31:32.250
再做下一件排队呗

31:32.250 --> 31:34.250
一个任务一个任务排队

31:34.250 --> 31:35.250
先生你好

31:35.250 --> 31:37.250
来请出是你的证件

31:37.250 --> 31:38.250
你是第一个任务

31:38.250 --> 31:39.250
你要办理什么业务

31:39.250 --> 31:40.250
把这件事搞完之后

31:41.250 --> 31:42.250
先生再见

31:42.250 --> 31:43.250
欢迎下时光临

31:43.250 --> 31:44.250
下一个先生

31:44.250 --> 31:45.250
像一个女士来过来

31:45.250 --> 31:46.250
哪里要办事

31:46.250 --> 31:48.250
就这么个意思排队

31:49.250 --> 31:51.250
整个逻辑呢

31:51.250 --> 31:52.250
就是这张图

31:52.250 --> 31:53.250
看一下这张图

31:53.250 --> 31:54.250
这张图是极其重要的

31:54.250 --> 31:56.250
后面会有反复的讲

31:56.250 --> 32:00.560
这是我们的浏览器主线程

32:00.560 --> 32:01.560
这是线程上

32:01.560 --> 32:03.560
正在执行的任务

32:03.560 --> 32:04.560
他可能有些任务

32:04.560 --> 32:05.560
正在执行

32:05.560 --> 32:08.560
下边有一个排队

32:08.560 --> 32:10.560
叫做消息对立

32:10.560 --> 32:12.560
Message Queen

32:12.560 --> 32:13.560
有的教材里边

32:13.560 --> 32:16.560
也把它叫做事件对立

32:16.560 --> 32:17.560
这里就排队

32:17.560 --> 32:19.560
有很多任务在这里排

32:19.560 --> 32:21.560
像目前正在处理一个任务

32:21.560 --> 32:22.560
然后现在对立里边

32:22.560 --> 32:23.560
还有一个任务

32:23.560 --> 32:26.560
还正在等待处理

32:26.560 --> 32:28.560
而且这个任务的处理过程中

32:28.560 --> 32:31.560
他可能会产生一些别的任务

32:31.560 --> 32:32.560
比如说浏览器主线程里边

32:32.560 --> 32:33.560
他执行这个任务

32:33.560 --> 32:35.560
他会产生一个新的任务

32:35.560 --> 32:36.560
这个新的任务呢

32:36.560 --> 32:38.560
又拿去排队

32:38.560 --> 32:40.560
到队里边去排

32:40.560 --> 32:41.560
比如说邓哥

32:41.560 --> 32:42.560
邓哥去办理

32:42.560 --> 32:44.560
银行里边办理银行卡

32:44.560 --> 32:46.560
办理的过程中说

32:46.560 --> 32:50.560
美女我媳妇还要办一张银行卡

32:50.560 --> 32:51.560
贵源就说你排队呗

32:51.560 --> 32:52.560
后边排队

32:52.560 --> 32:54.560
懂了意思吗

32:54.560 --> 32:56.560
那么这个队里边的任务

32:56.560 --> 32:57.560
他不仅仅是来源于

32:57.560 --> 33:01.560
他不仅仅是有可能来源于

33:01.560 --> 33:04.560
他还有可能来源于其他线程

33:04.560 --> 33:06.560
这又怎么理解呢

33:06.560 --> 33:07.560
比方说

33:07.560 --> 33:08.560
像我们的浏览器线程里边

33:08.560 --> 33:10.560
被用户交互事件吗

33:10.560 --> 33:13.560
用户点击了一下

33:13.560 --> 33:15.560
是由其他线程在监听

33:15.560 --> 33:16.560
还记得吗

33:16.560 --> 33:21.660
看一下看到没

33:21.660 --> 33:23.660
浏览器进程里边

33:23.660 --> 33:24.660
他可以监听用户

33:24.660 --> 33:26.660
到底点没点

33:26.660 --> 33:28.660
用户点了一个按钮

33:28.660 --> 33:30.660
那么这个时候呢

33:30.660 --> 33:33.660
他会把按钮的

33:33.660 --> 33:35.660
事件处理函数

33:35.660 --> 33:37.660
作为一个任务

33:37.660 --> 33:39.660
拿去排队

33:39.660 --> 33:41.660
因为浏览器线程

33:41.660 --> 33:43.660
浏览器线程

33:43.660 --> 33:45.660
它是不执行

33:45.660 --> 33:47.660
既也是代码的

33:47.660 --> 33:48.660
但它可以做一件事

33:48.660 --> 33:50.660
把这个任务拿去排队

33:50.660 --> 33:51.660
等待宣然

33:51.660 --> 33:53.660
主线程去执行

33:53.660 --> 33:55.660
比方说一个计时器到时间了

33:55.660 --> 33:57.660
一个人拿个卡个表

33:57.660 --> 33:58.660
正在计时

33:58.660 --> 34:00.660
计时个一分钟30秒

34:00.660 --> 34:01.660
计时器到时间了

34:01.660 --> 34:03.660
它又把那个

34:03.660 --> 34:05.660
回调函数拿去排队

34:05.660 --> 34:07.660
等待执行

34:07.660 --> 34:08.660
明白这个意思吗

34:08.660 --> 34:10.660
所以说

34:10.660 --> 34:12.660
是不是可以回答一些问题了

34:12.660 --> 34:17.170
当正在执行一个介式函数

34:17.170 --> 34:20.170
说明正在执行一个任务

34:20.170 --> 34:22.170
执行到一般的时候

34:22.170 --> 34:24.170
用户点击的按钮

34:24.170 --> 34:26.170
我应该立即去执行

34:26.170 --> 34:28.170
点击时间的处理函数吗

34:28.170 --> 34:30.170
不会

34:30.170 --> 34:31.170
不会

34:31.170 --> 34:32.170
它得把手上的事情

34:32.170 --> 34:34.170
干完了之后

34:34.170 --> 34:36.170
从这个排队里边去拿

34:36.170 --> 34:38.170
比方说

34:38.170 --> 34:40.170
这个地方用户点了一个按钮

34:40.170 --> 34:41.170
正在执行

34:41.170 --> 34:42.170
用户点了个按钮

34:42.170 --> 34:44.170
其他线程监听到了

34:44.170 --> 34:45.170
于是它会把这个任务

34:45.170 --> 34:47.170
夹到队里边去

34:47.170 --> 34:48.170
等待被执行

34:48.170 --> 34:49.170
排队一杯

34:49.170 --> 34:50.170
而且前面可能

34:50.170 --> 34:51.170
已经有了两个任务了

34:51.170 --> 34:52.170
已经排着了

34:52.170 --> 34:54.170
那就继续排

34:54.170 --> 34:56.170
当我主线程把这个任务

34:56.170 --> 34:57.170
搞定之后

34:57.170 --> 34:59.170
把这个任务搞定之后

34:59.170 --> 35:01.170
那么主线程清空了

35:01.170 --> 35:03.170
没东西可以执行了

35:03.170 --> 35:05.170
于是从消息队里边

35:05.170 --> 35:07.170
拿第一个任务出来

35:07.170 --> 35:09.170
下一位往前面走

35:09.170 --> 35:11.170
给人家执行

35:11.170 --> 35:12.170
执行完了过后

35:12.170 --> 35:13.170
那么这个也OK了

35:13.170 --> 35:15.170
然后又拿下一个

35:15.170 --> 35:17.170
然后又拿下一个

35:17.170 --> 35:19.170
一次拿去执行

35:19.170 --> 35:21.170
就这么个意思

35:21.170 --> 35:24.610
好 咱们来具体看一下

35:24.610 --> 35:26.610
在最开始的时候

35:26.610 --> 35:27.610
轩然主线程

35:27.610 --> 35:30.610
它会进入一个无线循环

35:30.610 --> 35:35.650
什么叫无线循环

35:35.650 --> 35:39.220
这就是无线循环

35:39.220 --> 35:41.220
无穷无尽的循环下去

35:41.220 --> 35:43.220
真的是如此吗

35:43.220 --> 35:44.220
咱们来看一下吧

35:44.220 --> 35:45.220
看啥呢

35:45.220 --> 35:46.220
给大家看一下

35:46.220 --> 35:47.220
浏览器的圆码

35:47.220 --> 35:53.020
再

35:53.020 --> 35:55.020
我先开一个工程吧

35:55.020 --> 35:56.020
等一下

35:56.020 --> 35:57.020
我先开个工程

35:57.020 --> 36:04.400
然后在这

36:04.400 --> 36:06.400
看一下吧

36:06.400 --> 36:07.400
在这

36:07.400 --> 36:09.400
这边已经打开了

36:09.400 --> 36:11.400
我做了一个书签

36:11.400 --> 36:14.400
大概在这个位置

36:14.400 --> 36:16.400
这是圆码是C++写的

36:16.400 --> 36:17.400
你肯定看不懂

36:17.400 --> 36:18.400
你不用去看懂

36:18.400 --> 36:20.400
我们来看关键信息就行了

36:20.400 --> 36:21.400
看着

36:21.400 --> 36:24.400
这就是轩然主线程的启动

36:24.400 --> 36:26.400
轩然主线程的启动函数

36:26.400 --> 36:28.400
弱

36:28.400 --> 36:30.400
在启动函数里边做了啥事呢

36:30.400 --> 36:32.400
它进入了一个死循环

36:32.400 --> 36:34.400
无穷无尽的循环

36:34.400 --> 36:36.400
这个玩意就是死循环吗

36:36.400 --> 36:37.400
这个玩意也是死循环

36:37.400 --> 36:38.400
在纪念式里边

36:38.400 --> 36:40.400
其实也可以写出一样的逻辑

36:40.400 --> 36:41.400
大家看一下吧

36:41.400 --> 36:44.710
我打开个浏览器

36:44.710 --> 36:46.710
比方在控制台里边我写个FOR

36:46.710 --> 36:47.710
两个分号

36:47.710 --> 36:48.710
这啥意思呢

36:48.710 --> 36:49.710
其实很简单

36:49.710 --> 36:50.710
我们平时复杂写的

36:50.710 --> 36:51.710
是不是这样写的

36:51.710 --> 36:53.710
这里写的是某一个东西

36:55.710 --> 36:56.710
是不是这样写的

36:56.710 --> 36:58.710
前边我无非就是一开始

36:58.710 --> 36:59.710
不执行这个

36:59.710 --> 37:01.710
条件的条件为空

37:01.710 --> 37:03.710
为空的话就是永远为真

37:03.710 --> 37:04.710
然后在这里

37:04.710 --> 37:05.710
我也不需要执行

37:05.710 --> 37:08.710
也不需要执行任何东西

37:08.710 --> 37:10.710
就是条件永远为真

37:10.710 --> 37:12.710
其实这个跟外奥处是一样的

37:12.710 --> 37:14.710
然后这里帮我们写个Console

37:15.710 --> 37:16.710
你看一下

37:16.710 --> 37:18.710
马上浏览器又不停的打印

37:19.710 --> 37:20.710
就这个意思

37:21.710 --> 37:24.920
关掉

37:26.920 --> 37:27.920
最开始的时候

37:27.920 --> 37:30.920
轩然主线程会进入一个无线循环

37:30.920 --> 37:32.920
那么这个无线循环

37:32.920 --> 37:34.920
每一次循环做啥呢

37:34.920 --> 37:36.920
每一次循环做了一大堆事

37:36.920 --> 37:37.920
看这

37:37.920 --> 37:38.920
Do Work

37:39.920 --> 37:41.920
Next Working For

37:41.920 --> 37:45.920
表示拿到下一个任务

37:45.920 --> 37:46.920
从哪里拿

37:46.920 --> 37:49.920
就是从消息对列里面去拿

37:50.920 --> 37:52.920
你看我们这块代码的文件名字

37:53.920 --> 37:57.060
Message Loop

37:59.060 --> 38:00.060
这个文念夹

38:00.060 --> 38:01.060
Message Loop

38:01.060 --> 38:02.060
Message是什么意思

38:02.060 --> 38:04.060
消息 loop 循环

38:05.060 --> 38:07.060
知道为什么叫事件循环了吗

38:08.060 --> 38:11.060
事件循环它又叫做消息循环

38:12.060 --> 38:14.060
只是不同的名称而已

38:14.060 --> 38:16.060
在W3C的官方文档里边

38:17.060 --> 38:19.950
因为我们所谓的标准

38:19.950 --> 38:21.950
ATMOS CSS的标准

38:21.950 --> 38:23.950
都是属于包括浏览器的标准

38:23.950 --> 38:24.950
都是属于W3C的

38:24.950 --> 38:26.950
W3C的标准文档里边

38:26.950 --> 38:29.950
它把它叫做事件循环叫Event Loop

38:29.950 --> 38:31.950
但是在谷歌浏览器里边

38:31.950 --> 38:34.950
它把它叫做Message Loop

38:34.950 --> 38:35.950
都一个意思其实

38:36.950 --> 38:38.950
有点细微的感觉上有点不一样

38:39.950 --> 38:41.950
所以说我们说消息循环和事件循环

38:41.950 --> 38:42.950
是一个东西

38:43.950 --> 38:44.950
看一下吧

38:44.950 --> 38:45.950
这就是消息循环

38:46.950 --> 38:47.950
为什么叫消息循环

38:47.950 --> 38:48.950
知道了吧

38:48.950 --> 38:50.950
它就是循环在哪消息

38:51.950 --> 38:52.950
每一次循环

38:52.950 --> 38:54.950
从对立里边哪一个任务去执行

38:54.950 --> 38:55.950
执行完了过后

38:55.950 --> 38:57.950
下一次循环哪下一个任务

38:58.950 --> 38:59.950
所以看第二条

38:59.950 --> 39:01.950
每一次循环会检查消息对列中

39:01.950 --> 39:02.950
释放有任务存在

39:02.950 --> 39:03.950
如果有的话

39:03.950 --> 39:05.950
就取出第一个任务执行

39:05.950 --> 39:06.950
执行完过后进入下一次循环

39:06.950 --> 39:07.950
如果说没有的话

39:07.950 --> 39:09.950
如果说没任务怎么办

39:09.950 --> 39:10.950
没任务就休息呗

39:11.950 --> 39:12.950
踏踏实实地休息

39:13.950 --> 39:14.950
你没事做不休息干嘛呢

39:15.950 --> 39:16.950
进入休眠状态

39:17.950 --> 39:19.950
如果说突然一开始没有任务

39:19.950 --> 39:21.950
后来又突然出现一个任务

39:21.950 --> 39:22.950
那么就会唤醒

39:22.950 --> 39:24.950
其他所有的县城

39:24.950 --> 39:25.950
包括其他进城的县城

39:25.950 --> 39:27.950
可以随时的向消息

39:27.950 --> 39:29.950
对列中加任务

39:29.950 --> 39:30.950
比方那个计时县城

39:30.950 --> 39:31.950
计时期到了

39:31.950 --> 39:33.950
往里边加任务

39:33.950 --> 39:35.950
比方说一个交互县城

39:35.950 --> 39:36.950
监听到了用户

39:36.950 --> 39:38.950
点击了他往里边加任务

39:39.950 --> 39:40.950
他加任务的时候

39:40.950 --> 39:43.950
一定是把它加到消息的末尾

39:44.950 --> 39:47.950
你先来的就先执行

39:47.950 --> 39:48.950
对吧

39:48.950 --> 39:50.950
后来的排队就这么个意思

39:51.950 --> 39:52.950
在添加任务的时候

39:52.950 --> 39:54.950
如果说主县城是休眠的

39:54.950 --> 39:56.950
那么就会唤醒

39:56.950 --> 39:58.950
以继续循环拿任务

39:58.950 --> 39:59.950
这个很好理解吧

39:59.950 --> 40:01.950
对吧 就是一开始的时候

40:01.950 --> 40:02.950
就这样子

40:02.950 --> 40:03.950
一开始的时候

40:03.950 --> 40:04.950
对列是空的

40:04.950 --> 40:05.950
然后主县城

40:05.950 --> 40:07.950
也没有什么东西可以执行

40:07.950 --> 40:08.950
那就休眠了

40:08.950 --> 40:11.950
这个时候来了一个任务排队

40:11.950 --> 40:12.950
一排队的时候

40:12.950 --> 40:14.950
主县城就会被唤醒

40:14.950 --> 40:15.950
兄弟 醒了

40:15.950 --> 40:16.950
别睡了

40:16.950 --> 40:17.950
我这来人了

40:17.950 --> 40:18.950
来吧

40:18.950 --> 40:20.950
来 先生您好

40:20.950 --> 40:21.950
过来执行

40:21.950 --> 40:22.950
就这个意思

40:22.950 --> 40:23.950
执行完了过后

40:23.950 --> 40:24.950
如果说没事的话

40:24.950 --> 40:25.950
又可以休息了

40:25.950 --> 40:26.950
当然如果说有事的话

40:26.950 --> 40:28.950
他还要一时把也执行完

40:28.950 --> 40:29.950
就这么个意思

40:30.950 --> 40:32.950
这就是事件循环

40:32.950 --> 40:33.950
整个过程

40:33.950 --> 40:35.950
被称为事件循环

40:35.950 --> 40:37.950
也称为消息循环

40:38.950 --> 40:40.950
事件循环的核心东西

40:40.950 --> 40:41.950
差不多到这了

40:41.950 --> 40:43.950
但是光知道这些东西

40:43.950 --> 40:44.950
还是不够的

40:44.950 --> 40:45.950
你还要知道

40:45.950 --> 40:48.950
事件循环里边的一些细节

40:48.950 --> 40:49.950
所以说我们接下来

40:49.950 --> 40:50.950
看下一个节

40:50.950 --> 40:51.950
叫做若干解释

40:51.950 --> 40:53.950
这里面我会解释

40:53.950 --> 40:54.950
三个东西

40:54.950 --> 40:56.950
这三个东西搞清楚了

40:56.950 --> 40:57.950
你会对事件循环

40:57.950 --> 40:59.950
有进一步的理解

40:59.950 --> 41:00.950
好 第一个东西

41:00.950 --> 41:02.950
我就是我们常常说的

41:02.950 --> 41:05.950
一步到底是什么玩意儿

41:05.950 --> 41:07.950
其实这个一步

41:07.950 --> 41:09.950
跟事件循环

41:09.950 --> 41:11.950
有着拖不开的干系

41:11.950 --> 41:12.950
我们一会儿说

41:12.950 --> 41:13.950
什么样的关系

41:13.950 --> 41:15.950
出来看什么叫一步

41:15.950 --> 41:17.950
在单码的执行过程中

41:17.950 --> 41:18.950
会遇到一些

41:18.950 --> 41:21.950
无法立即执行的任务

41:21.950 --> 41:22.950
哪些

41:22.950 --> 41:23.950
你们自己总结吧

41:23.950 --> 41:24.950
有哪些任务是

41:24.950 --> 41:25.950
没法立即执行的

41:25.950 --> 41:26.950
什么

41:26.950 --> 41:27.950
set them out

41:28.950 --> 41:29.950
这里面不传个函数吗

41:29.950 --> 41:30.950
对吧

41:30.950 --> 41:31.950
然后传个时间

41:31.950 --> 41:32.950
比较三秒之后

41:32.950 --> 41:35.950
三秒之后执行这个函数

41:35.950 --> 41:37.950
那么这个函数

41:37.950 --> 41:40.950
不就是没有办法立即执行吗

41:40.950 --> 41:42.950
还有什么

41:42.950 --> 41:43.950
网络通信

41:43.950 --> 41:45.950
有什么没有学过网络通信

41:45.950 --> 41:46.950
没关系

41:46.950 --> 41:48.950
我就简单的用个伟代码吧

41:48.950 --> 41:49.950
通信

41:49.950 --> 41:50.950
对吧

41:50.950 --> 41:51.950
你通信完了过后

41:51.950 --> 41:53.950
你要执行一个函数

41:53.950 --> 41:55.950
通信需不需要时间

41:55.950 --> 41:56.950
需要吧

41:56.950 --> 41:57.950
一段时间过后

41:57.950 --> 41:58.950
你要执行这个函数

41:58.950 --> 42:00.950
通信完成之后

42:00.950 --> 42:01.950
要执行

42:01.950 --> 42:03.950
将来你们学网络部分的时候

42:03.950 --> 42:04.950
学了个阿加克斯

42:04.950 --> 42:06.950
你就会学到这个玩意儿

42:06.950 --> 42:08.950
它就是用类似的方式在处理的

42:08.950 --> 42:09.950
还有什么呢

42:09.950 --> 42:10.950
还有时间

42:16.950 --> 42:17.950
点击时间

42:17.950 --> 42:20.950
点击的时候要运行一个函数

42:20.950 --> 42:21.950
这里传的是不是函数

42:21.950 --> 42:23.950
它是不是马上要执行

42:23.950 --> 42:24.950
不是

42:24.950 --> 42:27.950
等它点击过后再执行

42:27.950 --> 42:29.950
这些都是属于

42:29.950 --> 42:32.950
无法立即执行的任务

42:32.950 --> 42:33.950
那么这个任务

42:33.950 --> 42:35.950
会造成一个什么样的问题呢

42:36.950 --> 42:37.950
如果说

42:37.950 --> 42:39.950
让渲染主线程

42:39.950 --> 42:41.950
等待这些任务的时机到达

42:41.950 --> 42:43.950
比方你即时即时一秒钟

42:43.950 --> 42:44.950
那我主线程在运行的时候

42:44.950 --> 42:46.950
我就等一秒钟

42:46.950 --> 42:48.950
这就会导致主线程

42:48.950 --> 42:50.950
长期处于组色的状态

42:50.950 --> 42:52.950
什么叫组色

42:52.950 --> 42:55.950
见过堵车吧

42:55.950 --> 42:57.950
堵车为什么这么头痛

42:57.950 --> 42:59.950
这么让人愤怒

42:59.950 --> 43:00.950
为什么

43:00.950 --> 43:02.950
是因为

43:02.950 --> 43:04.950
堵车的时候

43:04.950 --> 43:05.950
我还有事

43:05.950 --> 43:07.950
我不是没事

43:07.950 --> 43:09.950
我还有很多事情要处理

43:09.950 --> 43:11.950
但是因为我现在堵住了

43:11.950 --> 43:12.950
我处理不了

43:12.950 --> 43:14.950
才让人着急

43:14.950 --> 43:16.950
不是这样吗

43:16.950 --> 43:18.950
那么主色也是一样

43:18.950 --> 43:20.950
我还有好多事要处理

43:20.950 --> 43:22.950
主线程一天忙得不得了

43:22.950 --> 43:26.950
我还要在那里撒等一秒钟

43:26.950 --> 43:29.950
那么就会造成很多问题

43:29.950 --> 43:30.950
而且呢

43:30.950 --> 43:32.950
主线程还有一个重要任务

43:32.950 --> 43:33.950
就是要画呀

43:33.950 --> 43:36.950
在页面上一秒钟要画六十次

43:36.950 --> 43:38.950
那你这样子一堵车

43:38.950 --> 43:40.950
我还在那撒等一秒钟

43:40.950 --> 43:41.950
我画都没法画了

43:41.950 --> 43:43.950
因为我就一个人

43:43.950 --> 43:45.950
这个人一天忙着要死

43:45.950 --> 43:47.950
你还让我这里撒等

43:47.950 --> 43:49.950
比方邓哥当服务员

43:49.950 --> 43:52.950
在房间里面就他一个服务员

43:52.950 --> 43:54.950
有十来桌客人要处理

43:54.950 --> 43:57.950
但是呢他要邓哥有十套金

43:57.950 --> 43:59.950
他要一个一个去处理

43:59.950 --> 44:01.950
第一个客人来了

44:01.950 --> 44:03.950
先生您好您要点什么

44:03.950 --> 44:05.950
点了菜把这个菜交给厨师

44:05.950 --> 44:07.950
厨师去做菜我再等呗

44:07.950 --> 44:09.950
其他说客人等着受不了

44:09.950 --> 44:10.950
就开始骂了

44:10.950 --> 44:12.950
不着急我一个一个服务完了再说

44:12.950 --> 44:14.950
他有这么多事要处理

44:14.950 --> 44:15.950
他能等吗同学

44:15.950 --> 44:17.950
他等不了啊

44:17.950 --> 44:18.950
等他真的要等的话

44:18.950 --> 44:20.950
把第一个客人送走了

44:20.950 --> 44:22.950
再去服务第二桌

44:22.950 --> 44:24.950
哪还有第二桌

44:24.950 --> 44:25.950
说全跑了

44:25.950 --> 44:27.950
说这里也是一样

44:27.950 --> 44:30.950
如果说你长期在那下干等的话

44:30.950 --> 44:31.950
就会导致主线

44:31.950 --> 44:33.950
成连画页面的功夫都没了

44:33.950 --> 44:36.950
导致浏览器卡死

44:36.950 --> 44:38.950
后面的任务排了一堆

44:38.950 --> 44:40.950
排一堆任务

44:40.950 --> 44:41.950
但是呢他还在等

44:41.950 --> 44:42.950
等了个计时期

44:42.950 --> 44:45.950
加上一张图啊可以看得很清楚

44:45.950 --> 44:48.950
当我们去雕用那个set time out

44:48.950 --> 44:50.950
比方第一个

44:50.950 --> 44:52.950
当我们去雕这个函数的时候

44:52.950 --> 44:53.950
实际上在做什么呢

44:53.950 --> 44:54.950
计时开始

44:54.950 --> 44:57.950
就雕这个set time out的函数

44:57.950 --> 44:58.950
他在做什么

44:58.950 --> 45:00.950
他自己不会去计时的

45:00.950 --> 45:02.950
他也没有这个计时的功能

45:02.950 --> 45:04.950
他做什么怎么来计时的

45:04.950 --> 45:06.950
找这个计时线程

45:06.950 --> 45:08.950
这里呢其实挺复杂的

45:08.950 --> 45:09.950
我跟你说

45:09.950 --> 45:11.950
计时器啊

45:11.950 --> 45:14.950
它甚至比世界循环

45:14.950 --> 45:16.950
还要复杂的多的多的多

45:16.950 --> 45:19.950
复杂过一百倍的不止

45:19.950 --> 45:20.950
就这么复杂

45:20.950 --> 45:21.950
就平时你们用个计时器

45:21.950 --> 45:23.950
用挺爽的是吧

45:23.950 --> 45:24.950
不过呢这一块呢

45:24.950 --> 45:25.950
确实你就不需要

45:25.950 --> 45:27.950
再知道它的底层原理了

45:27.950 --> 45:28.950
这个太复杂了

45:28.950 --> 45:30.950
实际上呢它个计时线程的

45:30.950 --> 45:31.950
说法不是很准确

45:31.950 --> 45:32.950
它实际上雕的是

45:32.950 --> 45:33.950
操作系统的东西

45:33.950 --> 45:35.950
不过呢我们可以简单的

45:35.950 --> 45:36.950
把理解为另一个人

45:36.950 --> 45:38.950
掐着表在计时

45:38.950 --> 45:40.950
这个set time out的函数

45:40.950 --> 45:43.950
实际上呢它是通知来哥们

45:43.950 --> 45:45.950
那个代表的哥们

45:45.950 --> 45:46.950
代劳力士的哥们

45:46.950 --> 45:47.950
你来帮我计个时吧

45:47.950 --> 45:49.950
你给我计时三秒钟

45:49.950 --> 45:50.950
三秒钟过后呢

45:50.950 --> 45:52.950
通知我运行这个函数

45:52.950 --> 45:53.950
就这么个意思

45:53.950 --> 45:54.950
于是呢它会交给

45:54.950 --> 45:56.950
通知计时线程去计时

45:56.950 --> 45:57.950
计时线程呢

45:57.950 --> 45:58.950
因为它是不同的线程

45:58.950 --> 46:00.950
它就可以同时进行

46:00.950 --> 46:03.950
先计时 计时开始 等待

46:03.950 --> 46:06.950
等待完了过后 计时结束

46:06.950 --> 46:08.950
如果说主线程

46:08.950 --> 46:10.950
它也跟着等的话

46:10.950 --> 46:11.950
我计时开始了

46:11.950 --> 46:12.950
我等别人计时

46:12.950 --> 46:13.950
我也等呗

46:13.950 --> 46:16.950
我等第一桌客人吃完饭

46:16.950 --> 46:17.950
我等厨师炒完菜

46:17.950 --> 46:18.950
我再去做别的

46:18.950 --> 46:20.950
它就会跟着等

46:20.950 --> 46:21.950
这种跟着等

46:21.950 --> 46:23.950
有没有好处的同学

46:23.950 --> 46:25.950
不要看他这么傻的

46:25.950 --> 46:27.950
他其实还是有好处的

46:27.950 --> 46:28.950
什么好处呢

46:28.950 --> 46:31.950
就是时间线是同步的

46:31.950 --> 46:32.950
是不是

46:32.950 --> 46:34.950
你就等第一桌客人吃完

46:34.950 --> 46:35.950
你到时间线跟

46:35.950 --> 46:36.950
第一桌的客人的时间线

46:36.950 --> 46:37.950
是不是同步的

46:37.950 --> 46:40.950
客人吃着你就等着

46:40.950 --> 46:42.950
那个好处在这

46:42.950 --> 46:43.950
不过那个好处是

46:43.950 --> 46:46.950
远远无法掩盖它的问题

46:46.950 --> 46:49.950
它主设等待计时完成

46:49.950 --> 46:50.950
它跟着等

46:50.950 --> 46:51.950
你看后边一大堆人

46:51.950 --> 46:52.950
在排队 不管

46:52.950 --> 46:53.950
我就要等

46:53.950 --> 46:56.950
必须要把这个人服务好

46:56.950 --> 46:59.950
好 等它计时完成之后

46:59.950 --> 47:00.950
计时结束

47:00.950 --> 47:01.950
计时线成了

47:01.950 --> 47:02.950
它就会通知

47:02.950 --> 47:03.950
我计时完成了

47:03.950 --> 47:05.950
那么它再去执行

47:05.950 --> 47:06.950
那个回调函数

47:06.950 --> 47:07.950
因为这个函数

47:07.950 --> 47:08.950
一定要在主线程执行

47:08.950 --> 47:10.950
计时线是执行不了的

47:10.950 --> 47:12.950
如果说用这种模式

47:12.950 --> 47:14.950
就叫做同步

47:14.950 --> 47:19.740
同步代码有什么特点呢

47:19.740 --> 47:20.740
非常好理解

47:20.740 --> 47:21.740
从代码的角度

47:21.740 --> 47:23.740
非常非常好理解

47:23.740 --> 47:24.740
比方说我这里

47:24.740 --> 47:26.740
输出一个1

47:26.740 --> 47:27.740
我这里呢

47:27.740 --> 47:35.180
1 下面输出一个2

47:35.180 --> 47:37.180
如果说是同步的话

47:37.180 --> 47:38.180
会怎么样

47:38.180 --> 47:40.180
这个代码卡个3秒钟

47:40.180 --> 47:41.180
然后输出1

47:41.180 --> 47:43.180
然后再输出2

47:43.180 --> 47:45.180
它就会这样

47:45.180 --> 47:48.180
那么看上去好理解

47:48.180 --> 47:50.180
当然是造成的问题

47:50.180 --> 47:51.180
特别恐怖

47:51.180 --> 47:53.180
怎么个恐怖法

47:53.180 --> 47:55.180
你看后边排了多少人呢

47:55.180 --> 47:56.180
而且这些任务里边

47:56.180 --> 47:57.180
还有一些什么任务

47:57.180 --> 47:59.180
还有一些渲染页面的任务

47:59.180 --> 48:01.180
要把页面画一遍的任务

48:01.180 --> 48:02.180
画都没法画了

48:02.180 --> 48:04.180
页面处于卡式状态

48:04.180 --> 48:05.180
所有的事件交互

48:05.180 --> 48:06.180
全部在这里排队

48:06.180 --> 48:07.180
比方期间3秒钟

48:07.180 --> 48:09.180
期间用户点击到按钮

48:09.180 --> 48:10.180
没反应的

48:10.180 --> 48:11.180
在这里排队

48:11.180 --> 48:13.180
因为目前他太忙了

48:13.180 --> 48:14.180
主线程忙不过来

48:14.180 --> 48:15.180
他在等着

48:15.180 --> 48:16.180
等到他这些东西

48:16.180 --> 48:18.180
全部做完了之后

48:18.180 --> 48:21.180
才有时间去取下一个任务

48:21.180 --> 48:22.180
懂的意思吧

48:22.180 --> 48:25.180
这就是同步的代码

48:25.180 --> 48:26.180
这样代码不好

48:26.180 --> 48:28.180
有问题那怎么办呢

48:28.180 --> 48:29.180
就得异步

48:29.180 --> 48:30.180
看着啊

48:30.180 --> 48:32.180
主线程承担着

48:32.180 --> 48:34.180
极其重要的工作

48:34.180 --> 48:35.180
你看GS代码

48:35.180 --> 48:36.180
ATM代码

48:36.180 --> 48:37.180
CS代码都在上面运行

48:37.180 --> 48:39.180
画页面也在上面运行

48:39.180 --> 48:42.180
它是无论如何都不能主色的

48:42.180 --> 48:44.180
主色要出大问题的

48:44.180 --> 48:46.180
永远就是卡式的状态了

48:46.180 --> 48:47.180
所以呢

48:47.180 --> 48:49.180
浏览器选择了异步

48:49.180 --> 48:52.180
而不使用同步来解决

48:52.180 --> 48:54.180
异步是怎么解决的

48:54.180 --> 48:56.180
你看

48:56.180 --> 48:57.180
变成这样了

48:57.180 --> 48:58.180
看这个代码

48:58.180 --> 49:00.180
计时开始

49:00.180 --> 49:01.180
我要调个C time mouse

49:01.180 --> 49:02.180
我要计时了

49:02.180 --> 49:03.180
怎么办呢

49:03.180 --> 49:06.180
通知你这个计时线程

49:06.180 --> 49:08.180
来给我掐个表计时

49:08.180 --> 49:11.180
我就结束了

49:11.180 --> 49:13.180
第一桌客人点完菜

49:13.180 --> 49:15.180
邓哥把那个菜单交给厨师

49:15.180 --> 49:16.180
就白白了

49:16.180 --> 49:18.180
我不会站在那里等厨师

49:18.180 --> 49:19.180
把菜做完

49:19.180 --> 49:22.180
我直接就去服务下一个客人了

49:22.180 --> 49:23.180
懂的意思吗

49:23.180 --> 49:24.180
那么计时线程你去计时

49:24.180 --> 49:25.180
我不管了

49:25.180 --> 49:26.180
你去计时

49:26.180 --> 49:27.180
你去计时

49:27.180 --> 49:30.180
这件事就完结束了

49:30.180 --> 49:32.180
对于主线程而言就结束了

49:32.180 --> 49:34.180
他就直接拿下一个任务执行

49:34.180 --> 49:35.180
下个任务执行完

49:35.180 --> 49:36.180
再下一个任务就执行去了

49:36.180 --> 49:38.180
就不管了

49:38.180 --> 49:39.180
突然有一天

49:39.180 --> 49:41.180
邓哥在服务第三桌客人的时候

49:41.180 --> 49:43.180
这个厨师喊了一句

49:43.180 --> 49:47.180
比方说邓哥目前正在服务第三桌客人

49:47.180 --> 49:48.180
这个时候厨师喊了一句

49:48.180 --> 49:49.180
兄弟

49:49.180 --> 49:52.180
我这个计时结束了

49:52.180 --> 49:53.180
主线程知道吗

49:53.180 --> 49:55.180
主线程压根就不知道

49:55.180 --> 49:56.180
为啥不知道

49:56.180 --> 49:57.180
因为这个计时线程

49:57.180 --> 49:59.180
他不会去通知主线程

49:59.180 --> 50:04.180
而是把之前的回调函数

50:04.180 --> 50:06.180
就这个回调函数

50:06.180 --> 50:09.180
把它加入到任务对列里面去

50:09.180 --> 50:10.180
就消息对列

50:10.180 --> 50:11.180
排队呗

50:11.180 --> 50:13.180
我这结束完了排队

50:13.180 --> 50:15.180
所以呢

50:15.180 --> 50:16.180
主线程啥都不知道

50:16.180 --> 50:18.180
他就一个一个任务执行

50:18.180 --> 50:19.180
不要拿完了

50:19.180 --> 50:20.180
拿这个

50:20.180 --> 50:21.180
这个拿完了

50:21.180 --> 50:22.180
拿这个

50:22.180 --> 50:23.180
这个拿完了

50:23.180 --> 50:24.180
拿这个

50:24.180 --> 50:25.180
他甚至都不知道

50:25.180 --> 50:26.180
这个任务就是计时期的任务

50:26.180 --> 50:28.180
他都不知道

50:28.180 --> 50:29.180
到底是什么

50:29.180 --> 50:31.180
是这么回事

50:31.180 --> 50:33.180
所以说他不知道

50:33.180 --> 50:34.180
他肯定是知道的

50:34.180 --> 50:36.180
但是你可以这样理解

50:36.180 --> 50:39.180
他就一个任务去取出来执行

50:39.180 --> 50:40.180
那么这样子一来

50:40.180 --> 50:42.180
你可以琢磨一下

50:42.180 --> 50:44.180
主线程是不是就充分的

50:44.180 --> 50:47.180
提高了生产效率

50:47.180 --> 50:49.180
这个服务员虽然只有一个人

50:49.180 --> 50:50.180
但他不停的忙

50:50.180 --> 50:51.180
不停的忙

50:51.180 --> 50:53.180
美食美客都在做事

50:53.180 --> 50:55.180
他不会在那个虾等

50:55.180 --> 50:56.180
所以呢

50:56.180 --> 50:58.180
在这种模式下边

50:58.180 --> 51:01.180
主线程永不主色

51:01.180 --> 51:02.180
永远都在忙

51:02.180 --> 51:03.180
忙就是对的

51:03.180 --> 51:05.180
他本来就有很多事

51:05.180 --> 51:06.180
就应该忙

51:06.180 --> 51:07.180
在那些闲着

51:07.180 --> 51:08.180
有大堆事情在那里等着

51:08.180 --> 51:11.180
他却在那里玩王中荣耀

51:11.180 --> 51:13.180
刷手机等厨师做菜

51:13.180 --> 51:15.180
他就不对了

51:15.180 --> 51:16.180
好

51:16.180 --> 51:18.180
那么这就是异部的概念

51:18.180 --> 51:20.180
这个模式就是异部

51:20.180 --> 51:21.180
因为时间线不同意了

51:21.180 --> 51:23.180
即使有他自己的时间线

51:23.180 --> 51:25.180
虽然主线程有他自己的时间线

51:25.180 --> 51:28.180
不同意了就异部

51:28.180 --> 51:29.180
好

51:29.180 --> 51:31.180
那么来看一下有道面试题

51:31.180 --> 51:34.180
问题如何理解介石的异部

51:34.180 --> 51:36.180
下边是一个参考答案

51:36.180 --> 51:37.180
同学们可以自行阅读一下

51:37.180 --> 51:39.180
这个参考答案

51:39.180 --> 51:40.180
这个参考答案在面试的时候

51:40.180 --> 51:42.180
如果说你能够说个百分之

51:42.180 --> 51:45.180
七八十给面试观听

51:45.180 --> 51:47.180
百分一百分你能拿两百

51:47.180 --> 51:49.180
否则这么跟你说

51:49.180 --> 51:51.180
那个面试观的整个灵魂

51:51.180 --> 51:53.180
会受到你的洗礼

51:53.180 --> 51:56.180
因为能说出这种话的人

51:56.180 --> 51:58.180
极少

51:58.180 --> 51:59.180
看一下读一下吧

51:59.180 --> 52:01.180
为什么会有

52:01.180 --> 52:03.180
问题如何理解介石的异部

52:03.180 --> 52:04.180
对吧一开始面试完

52:04.180 --> 52:05.180
就随便问一问

52:05.180 --> 52:06.180
看你的基本功

52:06.180 --> 52:07.180
这段话一说出来

52:07.180 --> 52:09.180
他人都麻了

52:09.180 --> 52:11.180
介石是一门单线程的

52:11.180 --> 52:13.180
原则是一定要说的

52:13.180 --> 52:14.180
为什么

52:14.180 --> 52:16.180
你不说单线程

52:16.180 --> 52:18.180
你就解释不了

52:18.180 --> 52:20.180
主色带来的问题

52:20.180 --> 52:21.180
解释不了主色带来的问题

52:21.180 --> 52:23.180
你就解释不了异部

52:23.180 --> 52:25.180
它是单线程

52:25.180 --> 52:26.180
怎么理解单线程

52:26.180 --> 52:29.180
并不是浏览器是单线程

52:29.180 --> 52:32.180
而是介石是执行在哪儿的

52:32.180 --> 52:35.180
执行在渲染主线程上的

52:35.180 --> 52:37.180
就一个线程在执行介石

52:37.180 --> 52:39.180
是这么个意思

52:39.180 --> 52:44.710
为什么说他单线程

52:44.710 --> 52:45.710
解释清楚

52:45.710 --> 52:46.710
因为它是运行在

52:46.710 --> 52:48.710
浏览器的渲染主线程中

52:48.710 --> 52:50.710
你把这几个字一说出来

52:50.710 --> 52:53.710
秒杀其他竞争者

52:53.710 --> 52:55.710
全部秒杀

52:55.710 --> 52:57.710
而渲染主线程只有一个

52:57.710 --> 52:58.710
很多人不知道

52:58.710 --> 53:01.710
个渲染主线程是啥都不知道

53:01.710 --> 53:02.710
而渲染主线程

53:02.710 --> 53:04.710
承担着诸多的工作

53:04.710 --> 53:06.710
讲清楚

53:06.710 --> 53:07.710
哪些工作

53:07.710 --> 53:08.710
渲染页面

53:08.710 --> 53:10.710
它要做

53:10.710 --> 53:12.710
执行介石也要做

53:12.710 --> 53:13.710
还有好多

53:13.710 --> 53:15.710
你知道多少 说多少

53:15.710 --> 53:17.710
讲什么解析TML

53:17.710 --> 53:20.710
解析CSS都要做

53:20.710 --> 53:22.710
执行事件回调都要做

53:22.710 --> 53:25.710
执行介石器回调都要做

53:25.710 --> 53:28.710
都是渲染主线程完成的

53:28.710 --> 53:30.710
一旦使用同步的方式

53:30.710 --> 53:31.710
就可能会导致

53:31.710 --> 53:34.710
主线程产生主色

53:34.710 --> 53:36.710
为什么要加可能呢

53:36.710 --> 53:39.710
如果说你整个程序执行

53:39.710 --> 53:40.710
不使用介石器

53:40.710 --> 53:41.710
也不使用网络

53:41.710 --> 53:42.710
也不使用事件

53:42.710 --> 53:43.710
那就不会主色

53:43.710 --> 53:45.710
就没有等待的东西

53:45.710 --> 53:47.710
一旦等待就会产生主色

53:47.710 --> 53:49.710
前提 用同步的方式

53:49.710 --> 53:51.710
从而导致

53:51.710 --> 53:53.710
一大堆人去排队

53:53.710 --> 53:55.710
就消息队里中有很多其他任务

53:55.710 --> 53:56.710
无法得到执行

53:56.710 --> 53:58.710
这边排了一大堆

53:58.710 --> 54:00.710
这边排了一大堆

54:00.710 --> 54:03.710
没法执行

54:03.710 --> 54:04.710
这样一来

54:04.710 --> 54:06.710
有什么问题呢

54:06.710 --> 54:08.710
这是一条逻辑线

54:08.710 --> 54:10.710
因为它是单线程

54:10.710 --> 54:12.710
解释研究单线程到底是啥

54:12.710 --> 54:14.710
是因为渲染主线程只有一个

54:14.710 --> 54:16.710
因为它是单线程

54:16.710 --> 54:18.710
所以它用同步会导致主色

54:18.710 --> 54:20.710
因为它会导致主色

54:20.710 --> 54:22.710
所以说造成什么问题

54:22.710 --> 54:25.710
导致繁忙的主线程

54:25.710 --> 54:27.710
白白的消耗时间

54:27.710 --> 54:28.710
没干活

54:28.710 --> 54:30.710
同时又导致页面

54:30.710 --> 54:31.710
无法及时更新

54:31.710 --> 54:33.710
在那里排队

54:33.710 --> 54:35.710
我的渲染页面

54:35.710 --> 54:36.710
我的实验监听

54:36.710 --> 54:37.710
全在那里排队

54:37.710 --> 54:39.710
给用户造成卡式现象

54:40.710 --> 54:42.710
所以浏览器怎么解决的

54:42.710 --> 54:43.710
采用的是一意不来解决

54:43.710 --> 54:45.710
你看这个逻辑线是非常的清晰的

54:47.710 --> 54:48.710
有问题了

54:48.710 --> 54:49.710
所以是一步出现的

54:49.710 --> 54:51.710
一步怎么做的呢

54:51.710 --> 54:52.710
当某些任务发生的时候

54:52.710 --> 54:53.710
比方介石器啊

54:53.710 --> 54:55.710
网络啊 事件监听啊对吧

54:55.710 --> 54:56.710
主线程会把这个任务

54:56.710 --> 54:57.710
交给其他线程去处理

54:57.710 --> 54:58.710
你去计时吧

54:58.710 --> 55:00.710
你去监听用户点击吧

55:00.710 --> 55:01.710
我就不管了

55:01.710 --> 55:03.710
我就直接干后边的事了

55:03.710 --> 55:04.710
我还有这么多事

55:04.710 --> 55:05.710
忙啊对吧

55:05.710 --> 55:06.710
原格

55:06.710 --> 55:07.710
又实贵

55:07.710 --> 55:09.710
为什么这么求意识不来

55:09.710 --> 55:10.710
我忙啊

55:10.710 --> 55:13.710
自身结束任务的执行

55:13.710 --> 55:15.710
即使你马上结束任务的执行

55:15.710 --> 55:17.710
转而去执行后续的代码

55:17.710 --> 55:20.710
当其他线程完成的时候

55:20.710 --> 55:22.710
他会把那些回调函数

55:22.710 --> 55:23.710
包装成任务啊

55:23.710 --> 55:25.710
这句黄为的说

55:25.710 --> 55:30.110
你要能够说出

55:30.110 --> 55:31.110
把回调函数

55:31.110 --> 55:33.110
包装成任务的人

55:33.110 --> 55:34.110
我可以说

55:34.110 --> 55:37.110
几千个人里边能出一个吧

55:38.110 --> 55:40.110
这个玩意没有研究过

55:40.110 --> 55:41.110
浏览器员吧

55:41.110 --> 55:43.110
你不可能说出这句话的

55:43.110 --> 55:45.110
因为在浏览器员里边

55:45.110 --> 55:46.110
所有的任务

55:46.110 --> 55:48.110
它实际上是一个结构体

55:48.110 --> 55:49.110
其实就是一个

55:49.110 --> 55:51.110
你可以把理解为一个对象

55:51.110 --> 55:53.110
对象里边还有一些东西

55:53.110 --> 55:55.110
以混文还会说

55:55.110 --> 55:57.110
以后说细节的时候还会说

55:57.110 --> 55:58.110
它会把一个任务

55:58.110 --> 55:59.110
加到对接里边去

55:59.110 --> 56:01.110
而不是直接把回调函数加进去

56:01.110 --> 56:03.110
我们平时分析一些

56:03.110 --> 56:04.110
代码体的时候

56:04.110 --> 56:06.110
可以把它简单的说成

56:06.110 --> 56:07.110
一个回调函数

56:07.110 --> 56:09.110
就是这里的一个任务

56:09.110 --> 56:11.110
但是实际上任务是一个对象

56:11.110 --> 56:15.260
把传递的回调函数

56:15.260 --> 56:16.260
包装成任务

56:16.260 --> 56:18.260
加到对列的墨尾

56:18.260 --> 56:21.260
等待主线程调度

56:21.260 --> 56:24.260
调度这个词说的多专业

56:24.260 --> 56:26.260
在这种异部模式下

56:26.260 --> 56:27.260
浏览器可以实现

56:27.260 --> 56:29.260
永不主色

56:29.260 --> 56:30.260
这就是异部

56:30.260 --> 56:31.260
它要解决的问题

56:31.260 --> 56:32.260
让它永不主色

56:32.260 --> 56:34.260
永远不要瞎等

56:34.260 --> 56:36.260
从而最大程度的保证了

56:36.260 --> 56:39.260
单线程的流畅运行

56:39.260 --> 56:42.760
这段话是我自己写的

56:42.760 --> 56:44.760
我自己读下头皮发

56:44.760 --> 56:45.760
我不知道面试官

56:45.760 --> 56:48.760
听到这段话是什么感觉

56:48.760 --> 56:52.760
这就是异部对异部的解释

56:52.760 --> 56:53.760
下一段

56:53.760 --> 56:56.760
介石为何

56:56.760 --> 57:00.760
为何会阻碍渲染

57:00.760 --> 57:02.760
这要从一段代码说起

57:02.760 --> 57:03.760
这句话到底啥意思

57:03.760 --> 57:07.070
我们要从一段代码说起

57:07.070 --> 57:09.070
这段代码我们把它放到

57:09.070 --> 57:10.070
页面里面去

57:10.070 --> 57:11.070
其实我页面上已经

57:11.070 --> 57:14.070
这里已经写了一个了

57:14.070 --> 57:15.070
看一下那段代码

57:15.070 --> 57:16.070
其实非常简单

57:16.070 --> 57:19.070
获取页面上的A71元素

57:19.070 --> 57:23.070
获取页面上的安扭元素

57:23.070 --> 57:25.070
然后我这里写了个辅助函数

57:25.070 --> 57:27.070
这个辅助函数在做什么呢

57:27.070 --> 57:28.070
你看一下吧

57:28.070 --> 57:30.070
给我传一个时间

57:30.070 --> 57:32.070
毫秒

57:32.070 --> 57:34.070
我记录一个时间点

57:34.070 --> 57:35.070
然后看一下

57:35.070 --> 57:38.070
这个时间减去之前的那个时间

57:38.070 --> 57:41.070
如果说是小云你给我传的时间

57:41.070 --> 57:43.070
我就继续循环

57:43.070 --> 57:44.070
说白了

57:44.070 --> 57:48.070
这个段代码就是死循环指定的时间

57:48.070 --> 57:49.070
你给我传个一秒钟

57:49.070 --> 57:52.070
我这个代码就在这里死循环一秒钟

57:52.070 --> 57:54.070
就这么个意思

57:54.070 --> 57:55.070
能理解吧

57:55.070 --> 57:56.070
因为时间没到

57:56.070 --> 57:59.070
它就出不了循环

57:59.070 --> 58:00.070
这个不是核心的

58:00.070 --> 58:01.070
你只要知道

58:01.070 --> 58:02.070
函数在做什么就行了

58:02.070 --> 58:04.070
看下面

58:04.070 --> 58:06.070
当安扭点击的时候

58:06.070 --> 58:07.070
我做了这么件事

58:07.070 --> 58:08.070
我给这个A71

58:08.070 --> 58:10.070
设置了一个文本

58:10.070 --> 58:12.070
把英文变成中文

58:12.070 --> 58:13.070
元老师很帅

58:13.070 --> 58:15.070
然后我去调这个函数

58:15.070 --> 58:18.070
死循环三秒

58:18.070 --> 58:20.070
会发生啥呀

58:20.070 --> 58:22.070
当我点击这个安扭的时候

58:22.070 --> 58:24.070
会发生一件什么事

58:24.070 --> 58:28.960
同学可以自己想一想

58:28.960 --> 58:29.960
点这个安扭

58:29.960 --> 58:31.960
它会发生啥

58:31.960 --> 58:32.960
把英文放过来

58:32.960 --> 58:37.550
代码放过来

58:37.550 --> 58:39.550
怎么样呢

58:39.550 --> 58:40.550
试一下吧

58:40.550 --> 58:41.550
点击

58:41.550 --> 58:42.550
卡了

58:42.550 --> 58:43.550
现在啥也动不了

58:43.550 --> 58:47.380
等三秒

58:47.380 --> 58:49.380
三秒过后变成这个

58:49.380 --> 58:51.380
看到没

58:51.380 --> 58:52.380
为啥呢

58:52.380 --> 58:55.380
它为啥不是先变成文本

58:55.380 --> 58:57.380
变成这个中文

58:57.380 --> 58:59.380
然后再等三秒呢

58:59.380 --> 59:01.380
代码不就这样写的吗

59:01.380 --> 59:03.380
咱们利用事件循环

59:03.380 --> 59:04.380
来解释这块代码

59:04.380 --> 59:06.380
就非常明白了

59:06.380 --> 59:07.380
就非常清楚了

59:07.380 --> 59:09.380
好,咱们来看一下

59:09.380 --> 59:11.380
把这个代码

59:11.380 --> 59:13.380
截个图

59:13.380 --> 59:18.420
到那个

59:18.420 --> 59:20.420
演示里边去

59:20.420 --> 59:22.420
这里我准备好一个图

59:22.420 --> 59:24.420
来进行演示

59:24.420 --> 59:28.420
把它稍微的放小一点

59:28.420 --> 59:31.240
放这吧

59:31.240 --> 59:34.620
好,同学看一下

59:34.620 --> 59:35.620
一开始呢

59:35.620 --> 59:37.620
我们的渲染主线程

59:37.620 --> 59:39.620
其他的事情我就略过了

59:39.620 --> 59:41.620
其实要做很多事的

59:42.620 --> 59:44.620
这些我就略过了

59:44.620 --> 59:46.620
我就看它执行解释

59:46.620 --> 59:48.620
一开始消息对立是空的

59:48.620 --> 59:50.620
没东西,没有任务排队

59:50.620 --> 59:52.620
执行解释的时候呢

59:52.620 --> 59:54.620
我开始在做什么呀

59:54.620 --> 59:56.620
获取H1,获取B天

59:56.620 --> 59:57.620
这些都正在执行啊

59:57.620 --> 59:58.620
执行过程中

59:58.620 --> 01:00:00.620
然后订了一个函数

01:00:00.620 --> 01:00:01.620
然后呢给这个B

01:00:01.620 --> 01:00:02.620
看这

01:00:02.620 --> 01:00:04.620
给这个按钮注册了一个点

01:00:04.620 --> 01:00:06.620
机事件

01:00:06.620 --> 01:00:09.620
这句话在干什么

01:00:09.620 --> 01:00:11.620
在干什么呢

01:00:11.620 --> 01:00:14.620
这句话还会做这么一件事

01:00:14.620 --> 01:00:16.620
它会让通知兄弟

01:00:16.620 --> 01:00:19.620
你这个交互线程

01:00:19.620 --> 01:00:21.620
来,程序而说了

01:00:21.620 --> 01:00:24.620
你要去监听那个

01:00:24.620 --> 01:00:26.620
按钮的点击

01:00:26.620 --> 01:00:27.620
你帮我监听一下

01:00:27.620 --> 01:00:28.620
我不管了

01:00:28.620 --> 01:00:30.620
对吧,我不可能在那里啥等的

01:00:30.620 --> 01:00:32.620
我还有好些事了

01:00:32.620 --> 01:00:34.620
你去监听一下哦

01:00:34.620 --> 01:00:35.620
那么于是呢

01:00:35.620 --> 01:00:37.620
这句话的作用

01:00:37.620 --> 01:00:39.620
是告诉交互线程

01:00:39.620 --> 01:00:41.620
你去监听

01:00:41.620 --> 01:00:45.620
按钮点击

01:00:45.620 --> 01:00:47.620
点击后执行什么

01:00:47.620 --> 01:00:52.210
执行一个函数

01:00:52.210 --> 01:00:54.210
就这么个意思

01:00:54.210 --> 01:00:56.210
这是交互线程做的事

01:00:56.210 --> 01:00:58.210
好,那么主线程就执行完了

01:00:58.210 --> 01:00:59.210
结束了

01:00:59.210 --> 01:01:01.210
它不会在那里等的

01:01:01.210 --> 01:01:02.210
结束了

01:01:02.210 --> 01:01:04.210
兄弟,还有没有人排队啊

01:01:04.210 --> 01:01:05.210
有排队的,赶快上来

01:01:05.210 --> 01:01:06.210
没排队的,我就休息了

01:01:06.210 --> 01:01:07.210
我就休眠了

01:01:07.210 --> 01:01:09.210
他休眠了

01:01:09.210 --> 01:01:11.210
经常他还有一些别的事

01:01:11.210 --> 01:01:12.210
不过我们可以的

01:01:12.210 --> 01:01:14.210
那些事情可以忽略

01:01:14.210 --> 01:01:17.210
对我们来说可以忽略

01:01:17.210 --> 01:01:19.210
好,等啊等啊

01:01:19.210 --> 01:01:20.210
现在扭上去就这样子

01:01:20.210 --> 01:01:22.210
就是最开始的样子

01:01:22.210 --> 01:01:24.210
没啥事可以干了

01:01:24.210 --> 01:01:26.210
然后突然有一天

01:01:26.210 --> 01:01:28.210
用户点击了按钮

01:01:28.210 --> 01:01:30.210
这个时候交互线程发现了

01:01:30.210 --> 01:01:32.210
哎,这个兄弟点了按钮了

01:01:32.210 --> 01:01:33.210
怎么办,怎么办

01:01:33.210 --> 01:01:35.210
商量一下,哎呦,他有个函数要执行

01:01:35.210 --> 01:01:36.210
咋办呀

01:01:36.210 --> 01:01:38.210
把这个函数放哪儿

01:01:38.210 --> 01:01:41.210
送到消息队列里面去

01:01:41.210 --> 01:01:43.210
于是消息队列里面

01:01:43.210 --> 01:01:45.210
就会有这么一个函数

01:01:45.210 --> 01:01:47.210
它其实是一个任务对象

01:01:47.210 --> 01:01:48.210
你可以把它理解

01:01:48.210 --> 01:01:51.220
我就一个函数

01:01:51.220 --> 01:01:54.430
放进去了

01:01:54.430 --> 01:01:56.430
去执行吧

01:01:56.430 --> 01:01:57.430
这个时候

01:01:57.430 --> 01:01:59.430
刚刚还在睡大觉的主线程

01:01:59.430 --> 01:02:01.430
你看,哎呦,来人了

01:02:01.430 --> 01:02:02.430
真困了

01:02:02.430 --> 01:02:03.430
来吧

01:02:03.430 --> 01:02:05.430
过来,兄弟,来执行吧

01:02:05.430 --> 01:02:07.430
好,拿到这个函数

01:02:07.430 --> 01:02:09.430
开始执行

01:02:09.430 --> 01:02:11.430
执行的过程中干嘛呀

01:02:11.430 --> 01:02:13.430
首先把这个

01:02:13.430 --> 01:02:15.430
元素的文本改成这个

01:02:15.430 --> 01:02:17.430
同学们,听好

01:02:17.430 --> 01:02:19.430
这句话在干什么

01:02:19.430 --> 01:02:21.430
这句话呢

01:02:21.430 --> 01:02:23.430
首先设置了多么的文本

01:02:23.430 --> 01:02:25.430
设置了没,设置了

01:02:25.430 --> 01:02:27.430
它不是没有设置

01:02:27.430 --> 01:02:29.430
但是设置了并不代表

01:02:29.430 --> 01:02:31.430
我在浏览器上能看得见

01:02:31.430 --> 01:02:33.430
我要在浏览器上能看得见

01:02:33.430 --> 01:02:35.430
新的东西需要干嘛

01:02:35.430 --> 01:02:38.430
需要重新渲染

01:02:38.430 --> 01:02:40.430
需要绘制

01:02:40.430 --> 01:02:43.430
就像一个画家把它画出来一样

01:02:43.430 --> 01:02:45.430
我这个东西改了过后

01:02:45.430 --> 01:02:47.430
我会产生一个新的任务

01:02:47.430 --> 01:02:49.430
就是一个绘制任务

01:02:49.430 --> 01:02:54.470
它要去排队的

01:02:54.470 --> 01:02:55.470
绘制

01:02:55.470 --> 01:02:57.470
它得排队

01:02:57.470 --> 01:03:00.470
看一下之前的那个图啊

01:03:00.470 --> 01:03:02.980
你看

01:03:02.980 --> 01:03:03.980
这里的任务

01:03:03.980 --> 01:03:06.980
是不是有可能会导致一个新任务去排队

01:03:06.980 --> 01:03:08.980
看到没

01:03:08.980 --> 01:03:10.980
它得排队

01:03:10.980 --> 01:03:13.980
于是那我们这个函数继续运行

01:03:13.980 --> 01:03:15.980
继续运行是不是掉了别的函数

01:03:15.980 --> 01:03:16.980
这个函数在干嘛

01:03:16.980 --> 01:03:19.980
死循环个三秒钟

01:03:19.980 --> 01:03:20.980
所以呢

01:03:20.980 --> 01:03:22.980
这个函数它又在干嘛

01:03:22.980 --> 01:03:27.250
又在死循环三秒

01:03:27.250 --> 01:03:29.250
三千毫秒

01:03:29.250 --> 01:03:30.250
是吧

01:03:30.250 --> 01:03:32.250
那怎么办呢

01:03:32.250 --> 01:03:33.250
我现在想汇制

01:03:33.250 --> 01:03:35.250
但汇制不了啊

01:03:35.250 --> 01:03:36.250
我在这里忙着要死的话

01:03:36.250 --> 01:03:38.250
还有三秒钟要执行

01:03:38.250 --> 01:03:39.250
其实没啥事

01:03:39.250 --> 01:03:40.250
但是它不知道啊

01:03:40.250 --> 01:03:41.250
它觉得这个事情很重要

01:03:41.250 --> 01:03:43.250
一代的循环嘛

01:03:43.250 --> 01:03:44.250
既然写了循环

01:03:44.250 --> 01:03:45.250
我肯定要循环

01:03:45.250 --> 01:03:47.250
循环个三秒钟

01:03:47.250 --> 01:03:49.250
三秒钟循环结束了

01:03:49.250 --> 01:03:51.250
这个任务结束了

01:03:51.250 --> 01:03:53.250
然后这个函数

01:03:53.250 --> 01:03:54.250
你是不是也结束了

01:03:54.250 --> 01:03:55.250
因为它循环了

01:03:55.250 --> 01:03:57.250
三秒钟之后就没东西了嘛

01:03:57.250 --> 01:03:58.250
结束了

01:03:58.250 --> 01:03:59.250
结束了之后

01:03:59.250 --> 01:04:01.250
现在主线城闲下来了

01:04:01.250 --> 01:04:03.250
然后才从消息队列中

01:04:03.250 --> 01:04:05.250
去拿出来汇制

01:04:05.250 --> 01:04:07.250
这就是为什么你们卡了三秒

01:04:07.250 --> 01:04:10.250
才看到了最终结果

01:04:10.250 --> 01:04:12.250
它其实文本早就改了

01:04:12.250 --> 01:04:14.250
它没把它画出来

01:04:14.250 --> 01:04:15.250
做了意思吧

01:04:15.250 --> 01:04:16.250
所以我们再来看一下

01:04:16.250 --> 01:04:18.250
点击

01:04:18.250 --> 01:04:21.250
三秒过后变成这个样子

01:04:21.250 --> 01:04:23.250
而且在这三秒期间

01:04:23.250 --> 01:04:26.880
如果说你发生了一些别的事

01:04:26.880 --> 01:04:27.880
比方说

01:04:27.880 --> 01:04:29.880
我这个在这个消息队列里边说

01:04:29.880 --> 01:04:30.880
比方说三秒期间

01:04:30.880 --> 01:04:32.880
你又点击了另外一个东西

01:04:32.880 --> 01:04:34.880
比方说滚动了滚动条

01:04:34.880 --> 01:04:39.580
或者是改变了窗口大小

01:04:39.580 --> 01:04:41.580
或者是你又干嘛了

01:04:41.580 --> 01:04:43.580
你又点击了别的按钮

01:04:43.580 --> 01:04:47.780
全都要排队

01:04:47.780 --> 01:04:49.780
都在后面排队的牌子

01:04:49.780 --> 01:04:51.780
等它忙完了过后

01:04:51.780 --> 01:04:53.780
再一个个拿出来执行

01:04:53.780 --> 01:04:55.780
懂了意思吧

01:04:55.780 --> 01:04:58.780
这就是解释的执行

01:04:58.780 --> 01:05:02.780
它会影响夜面的汇制

01:05:02.780 --> 01:05:04.780
如果说你执行的时间很长

01:05:04.780 --> 01:05:05.780
一段解释

01:05:05.780 --> 01:05:06.780
执行的时间很长

01:05:06.780 --> 01:05:07.780
就会导致这个汇制

01:05:07.780 --> 01:05:10.780
这个任务一直得不到执行

01:05:10.780 --> 01:05:13.780
就导致浏览器有卡死的状态

01:05:14.780 --> 01:05:16.780
所以我们以后接触到的

01:05:16.780 --> 01:05:17.780
react双加

01:05:17.780 --> 01:05:20.780
是否用了一个叫做fiber的机制

01:05:20.780 --> 01:05:22.780
来解决这个问题

01:05:22.780 --> 01:05:25.780
不要让一段解释执行的太长时间

01:05:25.780 --> 01:05:26.780
因为有些运算的

01:05:26.780 --> 01:05:28.780
确实运算量比较大

01:05:28.780 --> 01:05:30.780
代码的执行时间比较长

01:05:30.780 --> 01:05:31.780
就会导致那个时候

01:05:31.780 --> 01:05:33.780
会有那么零点几秒

01:05:33.780 --> 01:05:34.780
卡了一下

01:05:34.780 --> 01:05:35.780
卡顿了一下

01:05:35.780 --> 01:05:37.780
就这个道理

01:05:37.780 --> 01:05:41.780
这是关于解释阻碍渲染

01:05:41.780 --> 01:05:42.780
为什么会阻碍渲染

01:05:42.780 --> 01:05:43.780
其实很简单

01:05:43.780 --> 01:05:45.780
因为解释和渲染

01:05:45.780 --> 01:05:47.780
他们都在浏览器的渲染主线城上

01:05:47.780 --> 01:05:48.780
就这么简单

01:05:48.780 --> 01:05:49.780
你执行解释

01:05:49.780 --> 01:05:50.780
拉渲染等着

01:05:50.780 --> 01:05:53.780
你在渲染解释执行也等着

01:05:53.780 --> 01:05:54.780
就这么简单

01:05:54.780 --> 01:05:56.780
都在一个线城上

01:05:56.780 --> 01:05:57.780
就拉一个人

01:05:57.780 --> 01:05:59.780
照顾这边的时候

01:05:59.780 --> 01:06:00.780
那边就等着

01:06:00.780 --> 01:06:01.780
处理那边的时候

01:06:01.780 --> 01:06:02.780
这边就等着

01:06:03.780 --> 01:06:04.780
这是这个问题

01:06:04.780 --> 01:06:05.780
再下一个

01:06:06.780 --> 01:06:08.780
说这个问题很有意思

01:06:08.780 --> 01:06:09.780
说这个任务

01:06:09.780 --> 01:06:11.780
有这么多任务要执行

01:06:11.780 --> 01:06:12.780
有的时候呢

01:06:12.780 --> 01:06:13.780
要渲染

01:06:13.780 --> 01:06:14.780
有的时候要执行解释

01:06:14.780 --> 01:06:15.780
有的时候呢

01:06:15.780 --> 01:06:17.780
要执行用户的点击时间

01:06:17.780 --> 01:06:19.780
有的时候要执行解释

01:06:19.780 --> 01:06:20.780
实际实际

01:06:20.780 --> 01:06:23.780
就没有一个优先级吗

01:06:23.780 --> 01:06:25.780
大家都排队吗

01:06:25.780 --> 01:06:26.780
有的任务

01:06:26.780 --> 01:06:27.780
难道就没有

01:06:27.780 --> 01:06:28.780
特别急的时候吗

01:06:28.780 --> 01:06:30.780
人都有特别急的时候

01:06:30.780 --> 01:06:31.780
比方说我感冒了

01:06:31.780 --> 01:06:32.780
我去看医生

01:06:32.780 --> 01:06:34.780
我感觉自己挺着急的

01:06:34.780 --> 01:06:35.780
这个时候

01:06:35.780 --> 01:06:36.780
凳哥跑过来了

01:06:36.780 --> 01:06:37.780
嘴巴里边含一个灯泡

01:06:37.780 --> 01:06:38.780
我就觉得

01:06:38.780 --> 01:06:40.780
他比我更着急

01:06:40.780 --> 01:06:41.780
要不然先看他吧

01:06:41.780 --> 01:06:42.780
就一个医生

01:06:42.780 --> 01:06:43.780
单线城吗

01:06:44.780 --> 01:06:45.780
要不然先看他吧

01:06:46.780 --> 01:06:48.780
是不是都有一个优先级的呀

01:06:48.780 --> 01:06:49.780
那么任务有优先级吗

01:06:49.780 --> 01:06:50.780
不好意思

01:06:51.780 --> 01:06:53.780
任务他没有优先级

01:06:54.780 --> 01:06:55.780
他就是排队

01:06:55.780 --> 01:06:57.780
谁先来谁就看

01:06:57.780 --> 01:06:59.780
先进先出

01:06:59.780 --> 01:07:00.780
先来的人

01:07:00.780 --> 01:07:01.780
就先被取出去

01:07:01.780 --> 01:07:02.780
你看对立

01:07:03.780 --> 01:07:05.780
排队都是在摸尾排队的

01:07:05.780 --> 01:07:06.780
看一下

01:07:06.780 --> 01:07:07.780
都在摸尾排队

01:07:07.780 --> 01:07:09.780
取的时候都从第1个取

01:07:09.780 --> 01:07:10.780
因为第1个人最先来吗

01:07:11.780 --> 01:07:12.780
先进先出

01:07:12.780 --> 01:07:13.780
这是对立的特点

01:07:14.780 --> 01:07:18.780
但是消息对立有优先级

01:07:19.780 --> 01:07:20.780
这什么意思

01:07:21.780 --> 01:07:22.780
什么意思

01:07:22.780 --> 01:07:25.780
看一下W3C的最新解释

01:07:25.780 --> 01:07:26.780
为什么说最新解释呢

01:07:26.780 --> 01:07:28.780
跟过去不一样的

01:07:29.780 --> 01:07:30.780
过去是怎么说的

01:07:30.780 --> 01:07:32.780
过去说我们

01:07:32.780 --> 01:07:34.780
任务其实是有两个对立

01:07:34.780 --> 01:07:35.780
有两个排队

01:07:36.780 --> 01:07:37.780
一个是普通的

01:07:37.780 --> 01:07:38.780
叫做红任务

01:07:38.780 --> 01:07:40.780
一个是VIP的对立

01:07:40.780 --> 01:07:41.780
叫做微任务

01:07:41.780 --> 01:07:42.780
现在不是了

01:07:43.780 --> 01:07:44.780
两个对立

01:07:44.780 --> 01:07:45.780
根本就搞不定

01:07:45.780 --> 01:07:46.780
现在这么复杂的

01:07:46.780 --> 01:07:47.780
浏览器场景

01:07:48.780 --> 01:07:49.780
因此现在最新解释

01:07:49.780 --> 01:07:50.780
是这样的

01:07:50.780 --> 01:07:52.780
抛弃了红对立的说法

01:07:53.780 --> 01:07:54.780
每一个任务

01:07:54.780 --> 01:07:55.780
它都有一个任务类型

01:07:58.420 --> 01:07:59.420
看一下

01:08:00.420 --> 01:08:01.420
谷歌浏览器的源

01:08:02.420 --> 01:08:03.420
在哪呢

01:08:03.420 --> 01:08:04.420
在这

01:08:05.420 --> 01:08:06.420
Task

01:08:06.420 --> 01:08:07.420
什么任务

01:08:07.420 --> 01:08:09.420
Type类型

01:08:13.140 --> 01:08:14.140
每一个字段

01:08:14.140 --> 01:08:15.140
它就是个任务类型

01:08:15.140 --> 01:08:16.140
你看有多少

01:08:18.140 --> 01:08:19.140
来看一下吧

01:08:19.140 --> 01:08:20.140
看一些比较有意思的

01:08:21.140 --> 01:08:22.140
这三个东西

01:08:22.140 --> 01:08:24.140
属于技术器的任务类型

01:08:24.140 --> 01:08:25.140
你看技术器

01:08:25.140 --> 01:08:26.140
它都分了三种

01:08:27.140 --> 01:08:28.140
我就不展开了

01:08:28.140 --> 01:08:30.140
这个人展开不得了

01:08:30.140 --> 01:08:32.140
你不需要了解这么深

01:08:32.140 --> 01:08:33.140
这些你可能

01:08:33.140 --> 01:08:34.140
找几万个人

01:08:34.140 --> 01:08:36.140
能有一个多多少少

01:08:36.140 --> 01:08:37.140
都很难

01:08:37.140 --> 01:08:38.140
都找不到

01:08:38.140 --> 01:08:39.140
不需要了解这么深

01:08:39.140 --> 01:08:40.140
因为

01:08:40.140 --> 01:08:42.140
前端领域里边

01:08:42.140 --> 01:08:44.140
会是一家家的不督

01:08:44.140 --> 01:08:45.140
不是说没有不督

01:08:46.140 --> 01:08:47.140
会是一家家的

01:08:47.140 --> 01:08:48.140
这些都是谁家家代吗

01:08:48.140 --> 01:08:50.140
会是一家家的

01:08:50.140 --> 01:08:51.140
又能看懂

01:08:51.140 --> 01:08:53.140
浏览器源吗的更少

01:08:54.140 --> 01:08:55.140
会是一家家还能看懂

01:08:55.140 --> 01:08:56.140
浏览器源吗

01:08:56.140 --> 01:08:58.140
还能把它讲出来的更少

01:08:59.140 --> 01:09:00.140
会是一家家会看懂

01:09:00.140 --> 01:09:01.140
浏览器源吗

01:09:01.140 --> 01:09:02.140
还能把它讲出来

01:09:02.140 --> 01:09:03.140
还能把它讲得清楚的

01:09:03.140 --> 01:09:06.700
那我就没看见

01:09:07.700 --> 01:09:08.700
我们来看一下

01:09:08.700 --> 01:09:09.700
这里边有这么多任务对立

01:09:09.700 --> 01:09:10.700
你看一下吧

01:09:10.700 --> 01:09:11.700
我们给你看几个吧

01:09:12.700 --> 01:09:18.450
这是那个用户交户的

01:09:18.450 --> 01:09:19.450
就这个任务

01:09:19.450 --> 01:09:20.450
是跟用户交户相关的

01:09:20.450 --> 01:09:22.450
比方说点击了按钮之后

01:09:22.450 --> 01:09:23.450
有个回调函数

01:09:23.450 --> 01:09:24.450
那么那个任务

01:09:24.450 --> 01:09:25.450
就是这个类型

01:09:25.450 --> 01:09:27.450
这是跟网络相关的

01:09:27.450 --> 01:09:28.450
任务类型

01:09:28.450 --> 01:09:29.450
刚才我们看到几个

01:09:29.450 --> 01:09:31.450
跟计时器相关的

01:09:31.450 --> 01:09:32.450
都类似吧

01:09:32.450 --> 01:09:35.450
它有很多种任务类型的

01:09:39.450 --> 01:09:41.450
W30是这样说的

01:09:41.450 --> 01:09:43.450
同一个类型的任务

01:09:43.450 --> 01:09:44.450
必须在一个对立

01:09:45.450 --> 01:09:46.450
这是它意思

01:09:47.450 --> 01:09:48.450
就是它可以有多个对立的

01:09:48.450 --> 01:09:50.450
我们刚才只花了一个对立

01:09:50.450 --> 01:09:51.450
只有一个人排

01:09:51.450 --> 01:09:52.450
就是一排对立

01:09:52.450 --> 01:09:53.450
它其实有多排的

01:09:54.450 --> 01:09:55.450
但是有要求

01:09:56.450 --> 01:09:57.450
同一个类型的任务

01:09:57.450 --> 01:09:58.450
必须在一个对立

01:09:59.450 --> 01:10:02.450
比方说那个用户的事件处理

01:10:02.450 --> 01:10:03.450
然后点击事件

01:10:03.450 --> 01:10:05.450
你不能说一个点击事件在这

01:10:05.450 --> 01:10:06.450
一个点击事件在处理在这

01:10:06.450 --> 01:10:07.450
不行

01:10:07.450 --> 01:10:08.450
必须在同一个对立

01:10:08.450 --> 01:10:09.450
这是它的要求

01:10:10.450 --> 01:10:11.450
它还要求什么呢

01:10:11.450 --> 01:10:13.450
不同类型的任务

01:10:13.450 --> 01:10:17.450
可以分属于不同的对立

01:10:17.450 --> 01:10:18.450
啥意思

01:10:19.450 --> 01:10:20.450
比方这个对立里边

01:10:20.450 --> 01:10:22.450
只排计时器的任务

01:10:23.450 --> 01:10:24.450
跟计时器的任务相关的

01:10:25.450 --> 01:10:26.450
这个对立里边只排

01:10:27.450 --> 01:10:28.450
用户点击的任务

01:10:31.450 --> 01:10:33.450
这个对立里边

01:10:33.450 --> 01:10:34.450
只排网络任务

01:10:36.760 --> 01:10:38.760
相同的任务都在一个对立

01:10:39.760 --> 01:10:40.760
而不同的任务

01:10:40.760 --> 01:10:43.760
可以分属于不同的对立

01:10:43.760 --> 01:10:45.760
它也可以不分属

01:10:45.760 --> 01:10:46.760
比方说我把

01:10:46.760 --> 01:10:48.760
网络任务跟计时器的任务

01:10:48.760 --> 01:10:49.760
排在一起

01:10:50.760 --> 01:10:51.760
可不可以

01:10:51.760 --> 01:10:52.760
换个颜色吧

01:10:53.760 --> 01:10:54.760
网络任务跟计时器的任务

01:10:54.760 --> 01:10:55.760
排在一起

01:10:55.760 --> 01:10:56.760
也是允许的

01:10:57.760 --> 01:10:58.760
W30没有明确规定

01:10:58.760 --> 01:10:59.760
W30就是定标准的

01:10:59.760 --> 01:11:00.760
它不做事了

01:11:00.760 --> 01:11:01.760
它现在就嗶嗶

01:11:01.760 --> 01:11:02.760
你应该这样做

01:11:02.760 --> 01:11:03.760
你应该这样做

01:11:03.760 --> 01:11:04.760
流量器

01:11:04.760 --> 01:11:05.760
不管你是谷歌

01:11:05.760 --> 01:11:06.760
还是IE还是什么

01:11:06.760 --> 01:11:07.760
你都应该这样做

01:11:07.760 --> 01:11:08.760
它就嗶嗶

01:11:08.760 --> 01:11:09.760
它不做事了

01:11:09.760 --> 01:11:11.760
让那些流量器厂商自己去忙

01:11:12.760 --> 01:11:13.760
它是定标准的

01:11:13.760 --> 01:11:15.760
当裁判的是很好玩的

01:11:15.760 --> 01:11:17.760
当裁判也不简单

01:11:18.760 --> 01:11:19.760
就是这个意思

01:11:19.760 --> 01:11:21.760
你不同的任务

01:11:21.760 --> 01:11:22.760
可以放到一个对立

01:11:23.760 --> 01:11:24.760
但是你不能说

01:11:24.760 --> 01:11:25.760
这个地方放网络

01:11:25.760 --> 01:11:26.760
又跑到另外一个地方

01:11:26.760 --> 01:11:27.760
又放网络

01:11:27.760 --> 01:11:28.760
那是不行的

01:11:28.760 --> 01:11:29.760
因为什么

01:11:29.760 --> 01:11:30.760
因为统一个类型的任务

01:11:30.760 --> 01:11:31.760
必须在一个对立

01:11:31.760 --> 01:11:32.760
其实这些东西瞭解就行了

01:11:32.760 --> 01:11:33.760
都没几个人知道的

01:11:33.760 --> 01:11:34.760
知道

01:11:35.760 --> 01:11:38.760
然后在一次事件循环中

01:11:38.760 --> 01:11:40.760
什么叫一次事件循环

01:11:41.760 --> 01:11:43.760
事件循环不是一个死循环吗

01:11:43.760 --> 01:11:45.760
每一次循环的时候

01:11:45.760 --> 01:11:47.760
不是要取出一个吗

01:11:47.760 --> 01:11:49.760
流量器可以根据

01:11:49.760 --> 01:11:51.760
实际情况

01:11:51.760 --> 01:11:52.760
这个时候

01:11:52.760 --> 01:11:54.760
它终于没有那么强硬了

01:11:54.760 --> 01:11:56.760
你自己看着来吧

01:11:56.760 --> 01:11:58.760
你自己根据你的需要

01:11:58.760 --> 01:11:59.760
可以从不同的对立里面

01:11:59.760 --> 01:12:00.760
取任务执行

01:12:00.760 --> 01:12:01.760
你看

01:12:01.760 --> 01:12:02.760
现在就有很多个对立了

01:12:02.760 --> 01:12:03.760
排了很多个了

01:12:03.760 --> 01:12:04.760
那么我这回一次

01:12:04.760 --> 01:12:06.760
应该从哪个对立里面取呢

01:12:06.760 --> 01:12:08.760
流量器你自己去决定

01:12:08.760 --> 01:12:09.760
那就造成差异了

01:12:09.760 --> 01:12:10.760
有的流量器这样做

01:12:10.760 --> 01:12:12.760
有的流量器那样做

01:12:12.760 --> 01:12:13.760
而且

01:12:13.760 --> 01:12:15.760
同一个流量器

01:12:15.760 --> 01:12:16.760
不同的版本

01:12:16.760 --> 01:12:18.760
可能做法也不一样

01:12:18.760 --> 01:12:19.760
比方说有的时候

01:12:19.760 --> 01:12:20.760
他做一次循环

01:12:20.760 --> 01:12:21.760
他觉得

01:12:21.760 --> 01:12:22.760
这个计时器等的太久了

01:12:22.760 --> 01:12:23.760
我必须要从计时器里面

01:12:23.760 --> 01:12:25.760
去拿来执行了

01:12:25.760 --> 01:12:26.760
有的时候

01:12:26.760 --> 01:12:27.760
计时器等于等吧

01:12:27.760 --> 01:12:28.760
我还有更重要的事

01:12:28.760 --> 01:12:30.760
用户的点击很重要

01:12:30.760 --> 01:12:31.760
我把点击执行了

01:12:31.760 --> 01:12:34.760
他自己根据实际情况去决定

01:12:34.760 --> 01:12:36.760
谷歌流量器决定的过程

01:12:36.760 --> 01:12:38.760
是很复杂的

01:12:38.760 --> 01:12:40.760
我可以稍微给大家提一下

01:12:40.760 --> 01:12:42.760
他有一些基本的原则

01:12:42.760 --> 01:12:45.760
以后给他可以安然演示一下吧

01:12:45.760 --> 01:12:49.200
不同的情况自己去决定

01:12:49.200 --> 01:12:51.200
这是他第一个要求

01:12:51.200 --> 01:12:52.200
也就是说

01:12:52.200 --> 01:12:53.200
第一个要求说来说去

01:12:53.200 --> 01:12:54.200
他就是可以有多个对立

01:12:54.200 --> 01:12:56.200
到底有多好个流量器自己决定

01:12:56.200 --> 01:12:57.200
刚才我们看到流量器

01:12:57.200 --> 01:12:58.200
研磨里面

01:12:58.200 --> 01:12:59.200
是不是有很多任务类型

01:12:59.200 --> 01:13:00.200
但并不代表流量器

01:13:00.200 --> 01:13:01.200
有这么多对立

01:13:01.200 --> 01:13:03.200
他很多不同的类型

01:13:03.200 --> 01:13:05.200
走到一个对立里面去了

01:13:05.200 --> 01:13:06.200
是这么个意思

01:13:06.200 --> 01:13:08.200
第二条

01:13:08.200 --> 01:13:10.200
标准 解释

01:13:10.200 --> 01:13:14.200
流量器必须准备好一个V对立

01:13:14.200 --> 01:13:16.200
就有一个对立你是跑不掉的

01:13:16.200 --> 01:13:18.200
我不管你去其他准备掉多少

01:13:18.200 --> 01:13:19.200
我不管

01:13:19.200 --> 01:13:21.200
但是有一个对立必须是V对立

01:13:21.200 --> 01:13:24.200
他的英文单词叫做micro

01:13:24.200 --> 01:13:26.200
Microsoft就是微软

01:13:26.200 --> 01:13:28.200
microqueen

01:13:28.200 --> 01:13:31.200
microtaskqueen

01:13:31.200 --> 01:13:33.200
叫V对立

01:13:33.200 --> 01:13:35.200
V对立中的任务

01:13:35.200 --> 01:13:37.200
要比所有其他对立里边

01:13:37.200 --> 01:13:39.200
都要有限执行

01:13:39.200 --> 01:13:41.200
这个里面就是VIP

01:13:41.200 --> 01:13:43.200
VIP中P

01:13:43.200 --> 01:13:45.200
他没完 其他全都给我等

01:13:45.200 --> 01:13:47.200
就这么厉害

01:13:47.200 --> 01:13:49.200
连汇制都要给我等

01:13:49.200 --> 01:13:50.200
你画都不能画

01:13:50.200 --> 01:13:52.200
必须要等我全部执行完

01:13:52.200 --> 01:13:54.200
在微对立

01:13:54.200 --> 01:13:56.200
这里有官方的原文解释

01:13:56.200 --> 01:13:58.200
有兴趣的同学

01:13:58.200 --> 01:14:00.200
可以看一看

01:14:00.200 --> 01:14:01.200
在这

01:14:01.200 --> 01:14:03.200
如何来执行一个微对立

01:14:03.200 --> 01:14:06.200
microtask起个point

01:14:06.200 --> 01:14:08.200
就微对立的检查

01:14:08.200 --> 01:14:10.200
微认为的检查点

01:14:10.200 --> 01:14:12.200
他其实说来说去就是

01:14:12.200 --> 01:14:14.200
在这

01:14:14.200 --> 01:14:16.200
当微对立

01:14:16.200 --> 01:14:17.200
你看micro

01:14:17.200 --> 01:14:20.200
看得清楚吗

01:14:20.200 --> 01:14:22.200
我这一方小伴

01:14:22.200 --> 01:14:23.200
看这

01:14:23.200 --> 01:14:25.200
当微对立

01:14:25.200 --> 01:14:27.200
不为空的时候

01:14:27.200 --> 01:14:28.200
做些什么事

01:14:28.200 --> 01:14:30.200
让一个变量的值

01:14:30.200 --> 01:14:32.200
它可以归成很细

01:14:32.200 --> 01:14:33.200
让这个变量的值

01:14:33.200 --> 01:14:35.200
等于对立的第一个

01:14:36.200 --> 01:14:38.200
然后第二条不用看了

01:14:38.200 --> 01:14:40.200
第三条就是执行这个变量的值

01:14:40.200 --> 01:14:41.200
就这么简单

01:14:41.200 --> 01:14:43.200
说来说就有一个意思

01:14:43.200 --> 01:14:44.200
就是

01:14:44.200 --> 01:14:46.200
你要把微对立执行完

01:14:47.200 --> 01:14:49.200
这里有个题外话

01:14:49.200 --> 01:14:51.200
就是浏览器的复杂度急剧提升

01:14:51.200 --> 01:14:54.200
W3C不再使用红对立的说法

01:14:54.200 --> 01:14:56.200
那个画分太简单了

01:14:56.200 --> 01:14:58.200
两个对立不够的

01:14:58.200 --> 01:15:00.200
目前的谷歌浏览器

01:15:00.200 --> 01:15:02.200
有多少个对立有很多

01:15:02.200 --> 01:15:05.200
我没仔细去数过

01:15:05.200 --> 01:15:06.200
但是它至少包含了

01:15:06.200 --> 01:15:08.200
跟我们密切相关的

01:15:08.200 --> 01:15:09.200
至少包含了这三个对立

01:15:09.200 --> 01:15:10.200
严实对立

01:15:10.200 --> 01:15:13.200
这个玩意主要是来存放计时期的

01:15:13.200 --> 01:15:16.200
它的优先级是中

01:15:16.200 --> 01:15:19.200
交互对立就是用户点击

01:15:19.200 --> 01:15:21.200
比如说那个改变窗口大小

01:15:21.200 --> 01:15:23.200
比如滚动条

01:15:23.200 --> 01:15:25.200
数标事件键盘事件

01:15:25.200 --> 01:15:27.200
像这些东西

01:15:27.200 --> 01:15:29.200
它属于交互对立

01:15:29.200 --> 01:15:30.200
用户产生了交互

01:15:30.200 --> 01:15:32.200
那么这里边的任务

01:15:32.200 --> 01:15:34.200
它的优先级高

01:15:34.200 --> 01:15:35.200
还有就是围队的

01:15:35.200 --> 01:15:36.200
不用说了

01:15:36.200 --> 01:15:37.200
W3C明确要求

01:15:37.200 --> 01:15:39.200
它的优先级是最高的

01:15:39.200 --> 01:15:41.580
这些到底

01:15:41.580 --> 01:15:42.580
目前的

01:15:42.580 --> 01:15:43.580
这两个都好理解

01:15:43.580 --> 01:15:45.580
把计时器里边毁掉就放这

01:15:45.580 --> 01:15:47.580
然后用户的事件就放这

01:15:47.580 --> 01:15:49.580
就放到这个地方排队

01:15:49.580 --> 01:15:50.580
然后围队的放什么东西

01:15:50.580 --> 01:15:52.580
到围队的呢

01:15:52.580 --> 01:15:54.580
就看这两个知识里

01:15:54.580 --> 01:15:55.580
有没有学过了

01:15:55.580 --> 01:15:57.580
Promise rotation of the server

01:15:57.580 --> 01:15:58.580
第二个可能有很多人

01:15:58.580 --> 01:15:59.580
听都没听过

01:15:59.580 --> 01:16:00.580
Promise有些人听过

01:16:00.580 --> 01:16:02.580
可能没有掌握的很好

01:16:02.580 --> 01:16:03.580
有些人可能没学过

01:16:03.580 --> 01:16:04.580
无所谓

01:16:04.580 --> 01:16:05.580
那我就告诉你

01:16:05.580 --> 01:16:06.580
现在直接告诉你

01:16:06.580 --> 01:16:08.580
你们以后都要学习的Promise

01:16:08.580 --> 01:16:09.580
很重要的一个指示链

01:16:09.580 --> 01:16:10.580
面试长靠题

01:16:10.580 --> 01:16:12.580
我现在就直接告诉你

01:16:12.580 --> 01:16:14.580
就这个代码

01:16:14.580 --> 01:16:16.580
把函数放这

01:16:16.580 --> 01:16:17.580
你只要把函数放这

01:16:17.580 --> 01:16:20.580
那么这个函数直接到围队的

01:16:20.580 --> 01:16:22.580
以后里面就会知道

01:16:22.580 --> 01:16:23.580
这个到底是啥意思的

01:16:23.580 --> 01:16:24.580
现在不用管啥意思

01:16:24.580 --> 01:16:25.580
就这个代码

01:16:25.580 --> 01:16:26.580
你把函数放这

01:16:26.580 --> 01:16:28.580
这个函数直接到围队的

01:16:28.580 --> 01:16:29.580
那么就有意思

01:16:29.580 --> 01:16:31.580
我就可以出一些题了

01:16:31.580 --> 01:16:36.960
看着

01:16:36.960 --> 01:16:38.960
我们来看一个题

01:16:38.960 --> 01:16:46.210
1.js

01:16:46.210 --> 01:16:47.210
比方说

01:16:47.210 --> 01:16:51.210
我们这有一个set time out

01:16:51.210 --> 01:16:53.210
计时器

01:16:53.210 --> 01:16:56.710
0秒后

01:16:56.710 --> 01:16:58.710
输出一个1

01:16:58.710 --> 01:17:00.710
这里输出一个2

01:17:00.710 --> 01:17:03.710
这个代码会得到多少呢

01:17:03.710 --> 01:17:05.710
再多看几道题

01:17:05.710 --> 01:17:09.980
很简单代码

01:17:09.980 --> 01:17:10.980
会得到多少呢

01:17:10.980 --> 01:17:12.980
1.2还是2.1呢

01:17:12.980 --> 01:17:13.980
你不能想当然

01:17:13.980 --> 01:17:14.980
你想啊

01:17:14.980 --> 01:17:16.980
这个0秒不是马上到了吗

01:17:16.980 --> 01:17:18.980
马上到了不应该输出1吗

01:17:18.980 --> 01:17:19.980
对吧

01:17:19.980 --> 01:17:20.980
然后再输出2.2

01:17:20.980 --> 01:17:23.980
实际结果肯定是2.1

01:17:23.980 --> 01:17:24.980
好

01:17:24.980 --> 01:17:25.980
来吧

01:17:25.980 --> 01:17:28.940
看一下

01:17:28.940 --> 01:17:29.940
还为啥是2.1

01:17:29.940 --> 01:17:30.940
这个图

01:17:30.940 --> 01:17:33.940
到研视里面去

01:17:33.940 --> 01:17:35.940
我们现在

01:17:35.940 --> 01:17:36.940
观察完整格式

01:17:36.940 --> 01:17:37.940
围队的研视队的

01:17:37.940 --> 01:17:38.940
交互队的

01:17:38.940 --> 01:17:40.940
把图贴出来

01:17:40.940 --> 01:17:41.940
这个是全局代码

01:17:41.940 --> 01:17:42.940
所以一开始

01:17:42.940 --> 01:17:44.940
执行的是全局的GS

01:17:44.940 --> 01:17:47.940
没问题吧

01:17:47.940 --> 01:17:48.940
对队的全是空的

01:17:48.940 --> 01:17:49.940
其实有一些别的事

01:17:49.940 --> 01:17:51.940
不过我们不用管

01:17:51.940 --> 01:17:53.940
我们只管GS的任务

01:17:53.940 --> 01:17:55.940
执行全局GS

01:17:55.940 --> 01:17:58.940
执行的过程干什么事

01:17:58.940 --> 01:17:59.940
计时

01:17:59.940 --> 01:18:01.940
是不是在计时

01:18:01.940 --> 01:18:02.940
计时在干嘛

01:18:02.940 --> 01:18:04.940
是不是通知那个拿表的家伙

01:18:04.940 --> 01:18:05.940
兄弟

01:18:05.940 --> 01:18:06.940
拿一个拿表的人

01:18:06.940 --> 01:18:08.940
来给我计个实吧

01:18:08.940 --> 01:18:10.940
其他县城开始启动了

01:18:10.940 --> 01:18:11.940
我又统称为其他县城

01:18:11.940 --> 01:18:13.940
其实有各种各样的县城

01:18:13.940 --> 01:18:15.940
其他县城开始启动了

01:18:15.940 --> 01:18:16.940
来吧

01:18:16.940 --> 01:18:17.940
计时几秒钟

01:18:17.940 --> 01:18:18.940
领秒

01:18:18.940 --> 01:18:19.940
行

01:18:19.940 --> 01:18:20.940
领秒到干嘛

01:18:20.940 --> 01:18:21.940
执行一个函数

01:18:21.940 --> 01:18:22.940
输出1

01:18:22.940 --> 01:18:28.890
领秒是不是马上就到了

01:18:28.890 --> 01:18:29.890
到了没

01:18:29.890 --> 01:18:30.890
马上到了

01:18:30.890 --> 01:18:31.890
排队

01:18:31.890 --> 01:18:34.520
排队

01:18:34.520 --> 01:18:35.520
交互队

01:18:35.520 --> 01:18:37.520
排队

01:18:37.520 --> 01:18:39.520
执行这个函数

01:18:39.520 --> 01:18:40.520
去排队

01:18:40.520 --> 01:18:41.520
领秒马上到了

01:18:41.520 --> 01:18:42.520
完事

01:18:42.520 --> 01:18:43.520
我的活干完了

01:18:43.520 --> 01:18:45.520
主县城这边

01:18:45.520 --> 01:18:46.520
执行权律界也是

01:18:46.520 --> 01:18:47.520
他发出了通知

01:18:47.520 --> 01:18:50.520
然后还得接着往后执行

01:18:50.520 --> 01:18:52.520
还没执行完

01:18:52.520 --> 01:18:54.520
你看这个还得执行吗

01:18:54.520 --> 01:18:56.520
所以还没执行完

01:18:56.520 --> 01:18:59.520
没执行完是不是还得输出2

01:18:59.520 --> 01:19:01.520
所以说他一开始输出几

01:19:01.520 --> 01:19:03.520
输出了12

01:19:03.520 --> 01:19:04.520
这样子

01:19:04.520 --> 01:19:06.520
把目前手上该干的活

01:19:06.520 --> 01:19:08.520
全部干完了

01:19:08.520 --> 01:19:09.520
他一定要全部干完了

01:19:09.520 --> 01:19:11.520
没什么别的干的了

01:19:11.520 --> 01:19:15.520
然后才会从其他队的那边去拿

01:19:15.520 --> 01:19:17.520
干完了

01:19:17.520 --> 01:19:19.520
这一干完了过后一看

01:19:19.520 --> 01:19:21.520
这么多队列

01:19:21.520 --> 01:19:22.520
围队里面有吗

01:19:22.520 --> 01:19:23.520
没有

01:19:23.520 --> 01:19:24.520
它是优先级最高的

01:19:24.520 --> 01:19:26.520
没有那就算了

01:19:26.520 --> 01:19:28.520
刚才是一道严实队的

01:19:28.520 --> 01:19:29.520
不好意思

01:19:29.520 --> 01:19:32.520
交互队的优先级的次值

01:19:32.520 --> 01:19:33.520
也算是很高的

01:19:33.520 --> 01:19:35.520
也没东西

01:19:35.520 --> 01:19:36.520
严实队的

01:19:36.520 --> 01:19:38.520
你有个东西

01:19:38.520 --> 01:19:39.520
那行了

01:19:39.520 --> 01:19:40.520
执行这个函数

01:19:40.520 --> 01:19:42.520
所以说输出了1

01:19:42.520 --> 01:19:45.520
这是2.1的由来

01:19:45.520 --> 01:19:48.520
咱们再来一道题

01:19:48.520 --> 01:19:51.520
把刚才第一道这个的函数拿过来

01:19:51.520 --> 01:19:52.520
我要用

01:19:52.520 --> 01:19:57.200
这个函数

01:19:57.200 --> 01:19:58.200
使循环个三秒钟

01:19:58.200 --> 01:20:00.200
使循环指定的时间

01:20:00.200 --> 01:20:01.200
咱们再来

01:20:01.200 --> 01:20:02.200
0秒后输出1

01:20:02.200 --> 01:20:06.200
然后我这里地内

01:20:06.200 --> 01:20:07.200
3秒

01:20:07.200 --> 01:20:09.200
我就1秒吧

01:20:09.200 --> 01:20:10.200
使循环1秒

01:20:10.200 --> 01:20:11.200
输出2

01:20:11.200 --> 01:20:15.730
那这个有输出多少呢

01:20:15.730 --> 01:20:16.730
这个有输出多少呢

01:20:16.730 --> 01:20:21.730
我借个图

01:20:21.730 --> 01:20:30.580
好过来看

01:20:30.580 --> 01:20:32.580
好全局单码一开始

01:20:32.580 --> 01:20:33.580
执行的是全局

01:20:33.580 --> 01:20:35.580
对吧

01:20:35.580 --> 01:20:37.580
全局单码里边干嘛呢

01:20:37.580 --> 01:20:38.580
定义函数不用管了

01:20:38.580 --> 01:20:39.580
定义函数不是执行

01:20:39.580 --> 01:20:42.580
好这里在执行函数

01:20:42.580 --> 01:20:43.580
这里谁谈老子

01:20:43.580 --> 01:20:44.580
执行函数

01:20:44.580 --> 01:20:45.580
这个函数干嘛

01:20:45.580 --> 01:20:46.580
之前说过了呀

01:20:46.580 --> 01:20:48.580
是不是你就给我计时

01:20:48.580 --> 01:20:49.580
你给我计时

01:20:49.580 --> 01:20:50.580
计时几秒

01:20:50.580 --> 01:20:51.580
0秒

01:20:51.580 --> 01:20:52.580
0秒不是马上到了吗

01:20:52.580 --> 01:20:54.580
然后执行函数

01:20:54.580 --> 01:20:55.580
那么这个函数的数

01:20:55.580 --> 01:20:56.580
马上就到哪了

01:20:56.580 --> 01:21:00.460
到了一个严时堆裂

01:21:00.460 --> 01:21:03.460
好但是全局还没执行完

01:21:03.460 --> 01:21:04.460
一排队就排这边

01:21:04.460 --> 01:21:06.460
我要手上活干完了之后

01:21:06.460 --> 01:21:07.460
才有时间看你

01:21:07.460 --> 01:21:08.460
全局继续执行

01:21:08.460 --> 01:21:10.460
好那么这里是干嘛

01:21:10.460 --> 01:21:13.460
使循环个1秒钟

01:21:13.460 --> 01:21:15.460
1秒

01:21:15.460 --> 01:21:16.460
使循环

01:21:16.460 --> 01:21:19.840
那怎么办呢

01:21:19.840 --> 01:21:20.840
这个地方比较主色

01:21:20.840 --> 01:21:22.840
主色是啥事不干

01:21:22.840 --> 01:21:23.840
这个地方再干事

01:21:23.840 --> 01:21:24.840
干嘛还在循环

01:21:24.840 --> 01:21:27.840
就循环了1秒钟

01:21:27.840 --> 01:21:28.840
他再干活

01:21:28.840 --> 01:21:30.840
主色是啥也不干

01:21:30.840 --> 01:21:32.840
好那么这里呢

01:21:32.840 --> 01:21:34.840
使循环个1秒钟

01:21:34.840 --> 01:21:35.840
1秒就等边

01:21:35.840 --> 01:21:36.840
这写错了

01:21:36.840 --> 01:21:38.840
以前1秒钟

01:21:38.840 --> 01:21:40.840
1秒完了之后

01:21:40.840 --> 01:21:42.840
然后再回到全局继续执行

01:21:42.840 --> 01:21:44.840
还有个什么输出2

01:21:44.840 --> 01:21:45.840
玩2输出

01:21:45.840 --> 01:21:47.840
这样子全局执行完了

01:21:47.840 --> 01:21:50.840
执行完了过后

01:21:50.840 --> 01:21:52.840
主线程没事干了

01:21:52.840 --> 01:21:54.840
这个时候看排队

01:21:54.840 --> 01:21:55.840
你是空的

01:21:55.840 --> 01:21:56.840
你游行级是最高的

01:21:56.840 --> 01:21:57.840
你空的

01:21:57.840 --> 01:21:59.840
交互队列没东西

01:21:59.840 --> 01:22:01.840
然后就只能看延时队列了

01:22:01.840 --> 01:22:02.840
拿出来执行

01:22:02.840 --> 01:22:03.840
输出1

01:22:03.840 --> 01:22:04.840
因此个代码会怎么样

01:22:04.840 --> 01:22:06.840
会等待个1秒钟

01:22:06.840 --> 01:22:08.840
然后同时输出

01:22:08.840 --> 01:22:09.840
先输出2再输出1

01:22:09.840 --> 01:22:10.840
看一下吧

01:22:10.840 --> 01:22:13.790
运行

01:22:13.790 --> 01:22:14.790
等待1秒钟

01:22:14.790 --> 01:22:16.790
2 1

01:22:16.790 --> 01:22:18.790
懂了意思吧

01:22:18.790 --> 01:22:20.790
好咱们再来

01:22:20.790 --> 01:22:22.790
把这个主色掉

01:22:22.790 --> 01:22:23.790
接下来呢

01:22:23.790 --> 01:22:25.790
我们给它加一个V队列

01:22:25.790 --> 01:22:28.790
Promise Z

01:22:28.790 --> 01:22:30.790
语咒

01:22:30.790 --> 01:22:32.790
这个东西到底在干嘛

01:22:32.790 --> 01:22:33.790
这个代码是它意思

01:22:33.790 --> 01:22:34.790
你们没有学过

01:22:34.790 --> 01:22:35.790
肯定不知道

01:22:35.790 --> 01:22:36.790
我这个玩意

01:22:36.790 --> 01:22:38.790
也不是一辆句话能解释得清楚的

01:22:38.790 --> 01:22:39.790
你只需要知道这个寒数

01:22:39.790 --> 01:22:41.790
马上把它放到V队里

01:22:41.790 --> 01:22:42.790
代码的作用就是

01:22:42.790 --> 01:22:43.790
把这里边的东西

01:22:43.790 --> 01:22:45.790
直接放到V队里

01:22:45.790 --> 01:22:47.790
输出2

01:22:47.790 --> 01:22:49.790
这里是输出3

01:22:49.790 --> 01:22:55.280
这个东西又怎么执行了

01:22:55.280 --> 01:23:01.410
好 又来

01:23:01.410 --> 01:23:03.410
放过来吧

01:23:03.410 --> 01:23:05.410
好 下面空出台

01:23:05.410 --> 01:23:06.410
来吧

01:23:06.410 --> 01:23:08.410
一开始是什么 全局

01:23:08.410 --> 01:23:10.410
全单把执行的过程中

01:23:10.410 --> 01:23:12.410
首先你去计时吧

01:23:12.410 --> 01:23:14.410
你计时0秒钟过后

01:23:14.410 --> 01:23:16.410
运行一个寒数输出1

01:23:16.410 --> 01:23:18.410
我把它叫做fn1嘛

01:23:18.410 --> 01:23:19.410
0秒过后

01:23:19.410 --> 01:23:20.410
运行这个寒数

01:23:20.410 --> 01:23:21.410
那计时马上就到了

01:23:21.410 --> 01:23:24.410
进入严实队列

01:23:24.410 --> 01:23:26.410
好 继续运行全局还没完

01:23:26.410 --> 01:23:28.410
主线城里面执行一个任务的时候

01:23:28.410 --> 01:23:30.410
一定要把任务执行干干净净过后

01:23:30.410 --> 01:23:32.410
才会去看下一个任务

01:23:32.410 --> 01:23:34.410
就像你到一个窗口

01:23:34.410 --> 01:23:35.410
去搬你业务的时候

01:23:35.410 --> 01:23:36.410
你不能说搬你一半

01:23:36.410 --> 01:23:38.410
然后跑去执行别的了

01:23:38.410 --> 01:23:39.410
那你不骂人吗

01:23:39.410 --> 01:23:40.410
你肯定要把我的事

01:23:40.410 --> 01:23:42.410
弄干净了过后再去执行别的

01:23:42.410 --> 01:23:44.410
好 全局继续执行

01:23:44.410 --> 01:23:46.410
那么这个代码的作用是什么呢

01:23:46.410 --> 01:23:47.410
刚才说了

01:23:47.410 --> 01:23:48.410
这个代码就一个作用

01:23:48.410 --> 01:23:50.410
把那个寒数直接放到V队里

01:23:50.410 --> 01:23:51.410
好 于是呢

01:23:51.410 --> 01:23:52.410
V队里有一个寒数

01:23:52.410 --> 01:23:54.410
我们把鼓起把它叫做fn2

01:23:54.410 --> 01:23:56.410
就输出2的一个寒数

01:23:56.410 --> 01:23:59.410
好 全局完美还没完

01:23:59.410 --> 01:24:01.410
你不能执行一半跑了

01:24:01.410 --> 01:24:03.410
说既也是里面不可能说

01:24:03.410 --> 01:24:05.410
我执行一个寒数执行到一半

01:24:05.410 --> 01:24:07.410
我不执行的跑去执行别的了

01:24:07.410 --> 01:24:08.410
不可能的

01:24:08.410 --> 01:24:10.410
天下就乱套了

01:24:10.410 --> 01:24:11.410
肯定不能这样干的

01:24:11.410 --> 01:24:13.410
一个寒数一定是干干净净的执行完

01:24:13.410 --> 01:24:15.410
好 输出3

01:24:15.410 --> 01:24:17.410
于是通知要看到3

01:24:17.410 --> 01:24:18.410
最先看到了13

01:24:18.410 --> 01:24:19.410
好 这个时候全局

01:24:19.410 --> 01:24:21.410
确实没东西可以执行了

01:24:21.410 --> 01:24:23.410
全局结束

01:24:23.410 --> 01:24:24.410
来看排队

01:24:24.410 --> 01:24:26.410
它就不管谁先

01:24:26.410 --> 01:24:28.410
它就看哪个队列要先看

01:24:28.410 --> 01:24:30.410
先看哪个队列V队里

01:24:30.410 --> 01:24:32.410
它就不管V队里面是

01:24:32.410 --> 01:24:35.410
跟f1,f2,1和2

01:24:35.410 --> 01:24:37.410
到底是哪个先到哪个后到

01:24:37.410 --> 01:24:38.410
我就看V队里

01:24:38.410 --> 01:24:40.410
因为它的优先级最高

01:24:40.410 --> 01:24:42.410
它有 那就拿出来执行

01:24:42.410 --> 01:24:44.410
所以说输出了什么 输出了2

01:24:44.410 --> 01:24:46.410
好 这个寒数执行完了

01:24:46.410 --> 01:24:47.410
没什么别的事了

01:24:47.410 --> 01:24:49.410
这个寒数结束

01:24:49.410 --> 01:24:50.410
执行结束

01:24:50.410 --> 01:24:51.410
又看下一个

01:24:51.410 --> 01:24:53.410
fn1拿过来

01:24:53.410 --> 01:24:54.410
没东西了嘛

01:24:54.410 --> 01:24:55.410
其他队列都没东西了

01:24:55.410 --> 01:24:56.410
就输出1

01:24:56.410 --> 01:24:58.410
所以得到结果是321

01:24:58.410 --> 01:25:00.980
运行

01:25:00.980 --> 01:25:02.980
看到没

01:25:02.980 --> 01:25:03.980
好 我们接下来

01:25:03.980 --> 01:25:05.980
再看一些别的题

01:25:05.980 --> 01:25:09.290
多来演练一下

01:25:09.290 --> 01:25:10.290
这个题你们自己说

01:25:10.290 --> 01:25:13.290
这个题我是解释过类似的

01:25:13.290 --> 01:25:14.290
自己说输出啥

01:25:14.290 --> 01:25:16.660
得到结果是啥

01:25:16.660 --> 01:25:17.660
看一下

01:25:17.660 --> 01:25:18.660
暂停

01:25:18.660 --> 01:25:19.660
我都忘了自己在路过

01:25:19.660 --> 01:25:21.660
你们可以暂停

01:25:21.660 --> 01:25:22.660
好 直接说答案

01:25:22.660 --> 01:25:24.660
21

01:25:24.660 --> 01:25:25.660
如果看不懂

01:25:25.660 --> 01:25:26.660
21的

01:25:26.660 --> 01:25:28.660
往回退几分钟

01:25:28.660 --> 01:25:29.660
看我之前那个解释

01:25:29.660 --> 01:25:30.660
之前我等待的是1秒钟

01:25:30.660 --> 01:25:31.660
这里等待3秒钟

01:25:31.660 --> 01:25:33.660
这道题是21

01:25:33.660 --> 01:25:35.660
这道题有难度

01:25:35.660 --> 01:25:37.980
但是

01:25:37.980 --> 01:25:38.980
以后你们既然学过了

01:25:38.980 --> 01:25:39.980
这个事件循环

01:25:39.980 --> 01:25:40.980
做这种类似的

01:25:40.980 --> 01:25:42.980
跟事件循环相关的题

01:25:42.980 --> 01:25:44.980
跟异部相关的题

01:25:44.980 --> 01:25:45.980
画个图

01:25:45.980 --> 01:25:47.980
像我这样画个图

01:25:47.980 --> 01:25:48.980
或者是利用了个技师本

01:25:48.980 --> 01:25:49.980
来写上

01:25:49.980 --> 01:25:51.980
这里是主线程在干嘛

01:25:51.980 --> 01:25:52.980
然后呢

01:25:52.980 --> 01:25:54.980
这里是围队列在干嘛

01:25:54.980 --> 01:25:56.980
这里是严实队列在干嘛

01:25:56.980 --> 01:25:57.980
你自己画个图

01:25:57.980 --> 01:25:58.980
写个文字也可以

01:25:58.980 --> 01:26:01.980
我这里还说画图了

01:26:01.980 --> 01:26:02.980
画图是万物一石的

01:26:02.980 --> 01:26:04.980
绝对不会出错的

01:26:04.980 --> 01:26:06.980
无论那个题道多怪多复杂

01:26:06.980 --> 01:26:07.980
你只要画图

01:26:07.980 --> 01:26:08.980
绝不会出问题

01:26:08.980 --> 01:26:13.250
好 一开始是全局

01:26:13.250 --> 01:26:14.250
就这样分析吧

01:26:14.250 --> 01:26:16.250
不可能出问题的

01:26:16.250 --> 01:26:18.250
好 全局

01:26:18.250 --> 01:26:20.250
在抓干嘛

01:26:20.250 --> 01:26:21.250
执行setter mode

01:26:21.250 --> 01:26:22.250
这个setter mode干嘛

01:26:22.250 --> 01:26:24.250
是0秒后执行一个函数

01:26:24.250 --> 01:26:25.250
它这里要输出3

01:26:25.250 --> 01:26:27.250
我就姑且把它叫做fn3

01:26:27.250 --> 01:26:28.250
对吧

01:26:28.250 --> 01:26:30.250
a现在就没有执行

01:26:30.250 --> 01:26:31.250
a现在没有执行

01:26:31.250 --> 01:26:32.250
只有定义 对吧

01:26:32.250 --> 01:26:33.250
它并没有执行

01:26:33.250 --> 01:26:35.250
不管它有多复杂

01:26:35.250 --> 01:26:36.250
一步一步看

01:26:36.250 --> 01:26:37.250
于是呢

01:26:37.250 --> 01:26:38.250
0秒过后

01:26:38.250 --> 01:26:39.250
0秒不是其他现在的技师吗

01:26:39.250 --> 01:26:41.250
一技师0秒是不是马上到了

01:26:41.250 --> 01:26:42.250
就直接跑了

01:26:42.250 --> 01:26:43.250
我就直接画了严实队列了

01:26:43.250 --> 01:26:46.250
0秒干嘛 执行fn3

01:26:46.250 --> 01:26:48.250
就是输出3那个函数

01:26:48.250 --> 01:26:51.250
好 所以它冒子就运行完了

01:26:51.250 --> 01:26:52.250
现在会不会运行这个代吧

01:26:52.250 --> 01:26:53.250
不会啊

01:26:53.250 --> 01:26:55.250
这个函数在排队

01:26:55.250 --> 01:26:56.250
现在就继续往后执行

01:26:56.250 --> 01:26:57.250
这个在干嘛

01:26:57.250 --> 01:27:00.250
夹到v队列输出4

01:27:00.250 --> 01:27:02.250
好 微队列

01:27:02.250 --> 01:27:03.250
有个fn4

01:27:03.250 --> 01:27:06.250
需要输出4的那个函数

01:27:06.250 --> 01:27:08.250
接着往后看

01:27:08.250 --> 01:27:10.250
好

01:27:10.250 --> 01:27:11.250
输出5 对吧

01:27:11.250 --> 01:27:13.250
你再把全局执行完了过后

01:27:13.250 --> 01:27:15.250
你才能去看排队

01:27:15.250 --> 01:27:16.250
你不能

01:27:16.250 --> 01:27:18.250
哪怕你是VIP

01:27:18.250 --> 01:27:20.250
你不能太霸道了

01:27:20.250 --> 01:27:22.250
别人正在看病

01:27:22.250 --> 01:27:23.250
你正在做手术

01:27:23.250 --> 01:27:24.250
你让医生把手术放下

01:27:24.250 --> 01:27:25.250
你现在看我的感冒

01:27:25.250 --> 01:27:27.250
也太霸道了

01:27:27.250 --> 01:27:29.250
不能这样子

01:27:29.250 --> 01:27:32.250
所以说你再把个全局弄完了再说

01:27:32.250 --> 01:27:33.250
输出一个啥

01:27:33.250 --> 01:27:34.250
最开始输出5

01:27:34.250 --> 01:27:37.250
这个时候全局结束

01:27:37.250 --> 01:27:39.250
全局结束了过后

01:27:39.250 --> 01:27:40.250
干嘛

01:27:40.250 --> 01:27:42.250
微队列对吧

01:27:42.250 --> 01:27:43.250
它都有排

01:27:43.250 --> 01:27:44.250
尽管f3先排

01:27:44.250 --> 01:27:45.250
f4n4排

01:27:45.250 --> 01:27:47.250
后排

01:27:47.250 --> 01:27:48.250
但是它是VIP

01:27:48.250 --> 01:27:49.250
不过不好意思了

01:27:49.250 --> 01:27:51.250
那就先

01:27:51.250 --> 01:27:53.250
有钱可以为所欲为

01:27:53.250 --> 01:27:54.250
f4

01:27:54.250 --> 01:27:56.250
那么就输出4

01:27:56.250 --> 01:27:59.250
f4 执行结束

01:27:59.250 --> 01:28:00.250
拜拜

01:28:00.250 --> 01:28:02.250
又回到f3

01:28:02.250 --> 01:28:04.250
f3在干嘛

01:28:04.250 --> 01:28:06.250
现在运行这个函数

01:28:06.250 --> 01:28:08.250
是不是输出3

01:28:08.250 --> 01:28:10.250
拿过来运行

01:28:10.250 --> 01:28:11.250
f3拿出来运行

01:28:11.250 --> 01:28:12.250
输出减 输出3

01:28:12.250 --> 01:28:13.250
然后又干嘛

01:28:13.250 --> 01:28:17.250
又把一个函数放到微队里

01:28:17.250 --> 01:28:18.250
看到没

01:28:18.250 --> 01:28:20.250
又把一个函数放到微队里

01:28:22.250 --> 01:28:24.250
然后我们来看

01:28:24.250 --> 01:28:26.250
这句话是把函数A

01:28:26.250 --> 01:28:31.160
放到微队里

01:28:31.160 --> 01:28:32.160
没问题吧

01:28:32.160 --> 01:28:34.160
然后f3运行结束

01:28:34.160 --> 01:28:35.160
没东西了

01:28:35.160 --> 01:28:37.160
我把一个东西放到微队里

01:28:37.160 --> 01:28:38.160
我就结束了

01:28:38.160 --> 01:28:40.160
f3运行结束

01:28:40.160 --> 01:28:41.160
运行结束过后

01:28:41.160 --> 01:28:42.160
别的没排队了

01:28:42.160 --> 01:28:44.160
微队里拿出来

01:28:44.160 --> 01:28:45.160
运行A

01:28:45.160 --> 01:28:47.160
运行A输出减 输出1

01:28:47.160 --> 01:28:49.160
A这个函数

01:28:49.160 --> 01:28:50.160
这个函数又在干嘛

01:28:50.160 --> 01:28:52.160
又再把一个f2

01:28:52.160 --> 01:28:53.160
放到微队里

01:28:53.160 --> 01:28:58.430
我不管它执行的过程有多怪

01:28:58.430 --> 01:28:59.430
f2放到微队里

01:28:59.430 --> 01:29:01.430
那么A就结束了

01:29:01.430 --> 01:29:03.430
排队f2拿过来运行

01:29:03.430 --> 01:29:04.430
这就是事件循环

01:29:04.430 --> 01:29:05.430
看到没

01:29:05.430 --> 01:29:06.430
每一次拿个任务出来运行

01:29:06.430 --> 01:29:07.430
输出减 输出2

01:29:07.430 --> 01:29:08.430
结束

01:29:08.430 --> 01:29:14.410
54312运行

01:29:14.410 --> 01:29:15.410
不可能错的

01:29:15.410 --> 01:29:17.410
绝不可能错

01:29:17.410 --> 01:29:18.410
还说改一下

01:29:18.410 --> 01:29:19.410
改成这样子

01:29:19.410 --> 01:29:26.110
你们自己来

01:29:26.110 --> 01:29:27.110
一个暂停视频

01:29:27.110 --> 01:29:28.110
用我的方法自己来

01:29:28.110 --> 01:29:32.740
然后再看我的演示

01:29:32.740 --> 01:29:34.740
这都能画图

01:29:34.740 --> 01:29:35.740
能错

01:29:35.740 --> 01:29:36.740
能错就怪了

01:29:36.740 --> 01:29:40.120
来吧

01:29:40.120 --> 01:29:42.120
全局改一下

01:29:42.120 --> 01:29:46.650
一开始干嘛

01:29:46.650 --> 01:29:48.650
即时输出f3

01:29:48.650 --> 01:29:49.650
演示对立

01:29:49.650 --> 01:29:54.340
0秒过后

01:29:54.340 --> 01:29:55.340
执行f3

01:29:55.340 --> 01:29:56.340
输出3那个函数

01:29:56.340 --> 01:29:59.340
然后这句话

01:29:59.340 --> 01:30:00.340
直接加微队里

01:30:00.340 --> 01:30:02.340
把A那个函数加微队里

01:30:02.340 --> 01:30:06.940
A那个函数加微队里

01:30:06.940 --> 01:30:08.940
然后输出一个

01:30:08.940 --> 01:30:09.940
全局结束

01:30:10.940 --> 01:30:12.940
都有排队干嘛

01:30:12.940 --> 01:30:14.940
A打出来运行

01:30:14.940 --> 01:30:17.940
运行A输出减 输出1

01:30:17.940 --> 01:30:18.940
然后又把f2

01:30:18.940 --> 01:30:19.940
放微队里

01:30:19.940 --> 01:30:22.940
输出2那个函数放微队里

01:30:22.940 --> 01:30:25.940
结束

01:30:25.940 --> 01:30:26.940
再看

01:30:26.940 --> 01:30:27.940
不好意思f3

01:30:27.940 --> 01:30:28.940
又有VIP了

01:30:28.940 --> 01:30:29.940
我一定要把VIP

01:30:29.940 --> 01:30:31.940
全部服务完了

01:30:31.940 --> 01:30:32.940
头等舱客人

01:30:32.940 --> 01:30:33.940
全部上机了过后

01:30:33.940 --> 01:30:35.940
经济舱舱能上

01:30:35.940 --> 01:30:36.940
我也不知道是谁规定的

01:30:36.940 --> 01:30:38.940
反正就是这么规定的

01:30:38.940 --> 01:30:40.940
所以f2

01:30:40.940 --> 01:30:43.700
拿过来

01:30:43.700 --> 01:30:44.700
f2执行

01:30:44.700 --> 01:30:50.700
f2

01:30:50.700 --> 01:30:52.700
就输出2

01:30:52.700 --> 01:30:55.700
f2结束

01:30:55.700 --> 01:30:57.700
现在终于没东西了

01:30:57.700 --> 01:30:59.700
这不只有演示对立了

01:30:59.700 --> 01:31:01.700
演示对立的

01:31:01.700 --> 01:31:03.700
拿出来执行

01:31:03.700 --> 01:31:05.700
输出3

01:31:05.700 --> 01:31:07.700
5123

01:31:07.700 --> 01:31:08.700
好看一下

01:31:08.700 --> 01:31:10.700
不可能错的

01:31:10.700 --> 01:31:15.700
运行5123

01:31:15.700 --> 01:31:16.700
好

01:31:16.700 --> 01:31:17.700
所以说事件循环

01:31:17.700 --> 01:31:18.700
学了过后的这些面试题

01:31:18.700 --> 01:31:20.700
这些代码题都能做了

01:31:20.700 --> 01:31:21.700
将来你们的面试题

01:31:21.700 --> 01:31:23.700
里面还会结合Promise

01:31:23.700 --> 01:31:25.700
加上事件循环

01:31:25.700 --> 01:31:26.700
对吧

01:31:26.700 --> 01:31:27.700
因为Promise里面

01:31:27.700 --> 01:31:29.700
跟微队里有很有关系

01:31:29.700 --> 01:31:30.700
配合起来考

01:31:30.700 --> 01:31:31.700
再加上直接摊帽子

01:31:31.700 --> 01:31:34.260
一起来考

01:31:34.260 --> 01:31:35.260
其中瀏覽器

01:31:35.260 --> 01:31:36.260
还有很多其他对立

01:31:36.260 --> 01:31:38.260
跟我们的开发关系不大了

01:31:38.260 --> 01:31:40.260
讲到面试题

01:31:40.260 --> 01:31:41.260
这道面试题

01:31:41.260 --> 01:31:42.260
让你闪述一下

01:31:42.260 --> 01:31:43.260
GSE的事件循环

01:31:43.260 --> 01:31:44.260
其实在回答面试题的时候

01:31:44.260 --> 01:31:46.260
很多同学不喜欢回答那种

01:31:46.260 --> 01:31:47.260
什么闪述啊

01:31:47.260 --> 01:31:48.260
说明啊

01:31:48.260 --> 01:31:49.260
对吧

01:31:49.260 --> 01:31:50.260
聊一聊理解啊

01:31:50.260 --> 01:31:51.260
我跟你说

01:31:51.260 --> 01:31:53.260
这种题是最容易拿高分的

01:31:53.260 --> 01:31:55.260
只要你有一个合适的教程

01:31:55.260 --> 01:31:57.260
告诉你该怎么去回答

01:31:57.260 --> 01:31:59.260
可以甩开

01:31:59.260 --> 01:32:01.260
就是其他性能的一大截

01:32:01.260 --> 01:32:02.260
这种题

01:32:02.260 --> 01:32:04.260
不用写代码去靠书

01:32:04.260 --> 01:32:05.260
你只要理解到位了

01:32:05.260 --> 01:32:06.260
你说出来的东西

01:32:06.260 --> 01:32:08.260
你觉得跟别人不一样

01:32:08.260 --> 01:32:10.260
闪述一下GSE的事件循环

01:32:10.260 --> 01:32:12.260
你会怎么说

01:32:12.260 --> 01:32:14.260
看参考答案

01:32:14.260 --> 01:32:16.260
又是头皮发麻的参考答案

01:32:16.260 --> 01:32:18.260
事件循环又叫做消息循环

01:32:18.260 --> 01:32:19.260
你可以跟他聊一聊

01:32:19.260 --> 01:32:20.260
为什么

01:32:20.260 --> 01:32:23.260
官方的描述叫做event loop

01:32:23.260 --> 01:32:25.260
浏览器的内部实现

01:32:25.260 --> 01:32:35.620
叫做message loop

01:32:35.620 --> 01:32:36.620
不一样的

01:32:36.620 --> 01:32:38.620
其实说的东西是一样的

01:32:38.620 --> 01:32:39.620
名字不一样

01:32:39.620 --> 01:32:40.620
所以有叫做消息循环

01:32:40.620 --> 01:32:41.620
刚才吹个流衣嘛

01:32:41.620 --> 01:32:42.620
对吧

01:32:42.620 --> 01:32:43.620
把他吓一跳

01:32:43.620 --> 01:32:45.620
浏览器渲染主线程

01:32:45.620 --> 01:32:48.620
是浏览器渲染主线程的工作方式

01:32:48.620 --> 01:32:49.620
我跟你说

01:32:49.620 --> 01:32:51.620
你只要把这个名词说出来

01:32:51.620 --> 01:32:53.620
就要吓人一跳

01:32:53.620 --> 01:32:55.620
因为很多人都根本不知道

01:32:55.620 --> 01:32:57.620
这个是啥东西

01:32:57.620 --> 01:32:59.620
知道工作方式

01:32:59.620 --> 01:33:01.620
在原

01:33:01.620 --> 01:33:03.620
你自己看吧

01:33:03.620 --> 01:33:04.620
一边说是

01:33:04.620 --> 01:33:05.620
敢把这个玩意说出来

01:33:05.620 --> 01:33:07.620
得多吓人

01:33:07.620 --> 01:33:08.620
他开启一个

01:33:08.620 --> 01:33:12.620
不会结束的护循环

01:33:13.620 --> 01:33:14.620
看见过是吧

01:33:14.620 --> 01:33:16.620
每次循环从消息队里面

01:33:16.620 --> 01:33:17.620
取出一个任务执行

01:33:17.620 --> 01:33:20.620
这就是一次时间循环

01:33:20.620 --> 01:33:22.620
其他线程只要在合适的时候

01:33:22.620 --> 01:33:23.620
比方说用户点击了

01:33:23.620 --> 01:33:25.620
比方说继续到期了

01:33:25.620 --> 01:33:28.620
把任务加到队列莫为即可

01:33:28.620 --> 01:33:30.620
过去把消息队列

01:33:30.620 --> 01:33:31.620
简单分为红队列和微队列

01:33:31.620 --> 01:33:32.620
但这种说法

01:33:32.620 --> 01:33:34.620
已经无法满足

01:33:34.620 --> 01:33:35.620
复杂的浏览器环境

01:33:35.620 --> 01:33:36.620
你说这个玩意

01:33:36.620 --> 01:33:38.620
你不知道你谁能说得出来

01:33:38.620 --> 01:33:39.620
取而代之的是

01:33:39.620 --> 01:33:40.620
另外一种

01:33:40.620 --> 01:33:41.620
更加灵活多变的处理方式

01:33:41.620 --> 01:33:42.620
具体怎么处理的

01:33:42.620 --> 01:33:44.620
按照W3C的官方解释

01:33:44.620 --> 01:33:45.620
你看这叫专业

01:33:45.620 --> 01:33:47.620
这种说法叫专业

01:33:47.620 --> 01:33:49.620
每个任务有不同的类型

01:33:49.620 --> 01:33:51.620
同类型的任务

01:33:51.620 --> 01:33:52.620
必须放在同一个队列

01:33:52.620 --> 01:33:54.620
你都是一起的

01:33:54.620 --> 01:33:56.620
灯哥口里含着灯泡

01:33:56.620 --> 01:33:58.620
灯哥的父亲王老爷

01:33:58.620 --> 01:33:59.620
口里边也含着灯泡

01:33:59.620 --> 01:34:00.620
那么同样的

01:34:00.620 --> 01:34:02.620
他们在一个队列里面排队

01:34:02.620 --> 01:34:04.620
进行到医院去处理

01:34:04.620 --> 01:34:05.620
不同的任务

01:34:05.620 --> 01:34:09.620
可以属于不同的队列

01:34:09.620 --> 01:34:13.620
比如有人把那个水壶

01:34:13.620 --> 01:34:14.620
扣在脑袋上了

01:34:14.620 --> 01:34:16.620
跟含灯泡的道理

01:34:16.620 --> 01:34:17.620
差不多

01:34:17.620 --> 01:34:18.620
雖然它类型不一样

01:34:18.620 --> 01:34:20.620
但是也可以排到同一个队列

01:34:20.620 --> 01:34:23.620
但是你不能一会

01:34:23.620 --> 01:34:24.620
这个队列里面排

01:34:24.620 --> 01:34:25.620
吞灯泡的

01:34:25.620 --> 01:34:26.620
另外一个队列里面

01:34:26.620 --> 01:34:27.620
还有排吞灯泡的

01:34:27.620 --> 01:34:28.620
那就不行了

01:34:28.620 --> 01:34:29.620
都要排在一起的

01:34:29.620 --> 01:34:31.620
你自己去理解一下这句话

01:34:31.620 --> 01:34:34.620
不同队列有不同的优先级

01:34:34.620 --> 01:34:35.620
在一次事件循环中

01:34:35.620 --> 01:34:37.620
有浏览器自行决定

01:34:37.620 --> 01:34:38.620
因为官方还没有说

01:34:38.620 --> 01:34:39.620
哪个优先级

01:34:39.620 --> 01:34:40.620
刚刚哪一个优先级

01:34:40.620 --> 01:34:41.620
他就说了

01:34:41.620 --> 01:34:43.620
围队列是最高优先级

01:34:43.620 --> 01:34:46.620
必须率先得到执行

01:34:46.620 --> 01:34:47.620
但是其他的队列

01:34:47.620 --> 01:34:48.620
他就没说了

01:34:48.620 --> 01:34:49.620
浏览器你自己去决定吧

01:34:49.620 --> 01:34:51.620
但浏览器必须有一个围队列

01:34:51.620 --> 01:34:52.620
围队列的任务

01:34:52.620 --> 01:34:53.620
有一个最高的优先级

01:34:53.620 --> 01:34:55.620
必须优先调度执行

01:34:55.620 --> 01:34:56.620
其实我这里

01:34:56.620 --> 01:34:57.620
还有一个例子

01:34:57.620 --> 01:34:58.620
给大家看一下

01:34:58.620 --> 01:34:59.620
这个例子可能比较复杂

01:34:59.620 --> 01:35:01.620
你们了解一下就行了

01:35:01.620 --> 01:35:03.620
其实在浏览器里面

01:35:03.620 --> 01:35:05.620
它是这么认为的

01:35:05.620 --> 01:35:08.620
它认为即使期到达时间

01:35:08.620 --> 01:35:10.620
那个任务

01:35:10.620 --> 01:35:12.620
也不能说它完全

01:35:12.620 --> 01:35:14.620
优先级低

01:35:14.620 --> 01:35:15.620
但是它优先级

01:35:15.620 --> 01:35:16.620
肯定没有那么高

01:35:16.620 --> 01:35:18.620
你都等了一会了

01:35:18.620 --> 01:35:19.620
多等个几毫秒

01:35:19.620 --> 01:35:21.620
其实浏览器觉得无所谓

01:35:21.620 --> 01:35:23.620
它认为什么优先级最高

01:35:23.620 --> 01:35:25.620
除了W3C里面

01:35:25.620 --> 01:35:26.620
规定的微任务

01:35:26.620 --> 01:35:28.620
它认为用户交户

01:35:28.620 --> 01:35:31.620
是必须要立即相应的

01:35:31.620 --> 01:35:32.620
不能给用户

01:35:32.620 --> 01:35:34.620
感觉你点了一个按钮

01:35:35.620 --> 01:35:37.620
半天没反应

01:35:37.620 --> 01:35:39.620
这种体验就特别差

01:35:39.620 --> 01:35:40.620
所以说它会认为

01:35:40.620 --> 01:35:42.620
用户的交户很重要

01:35:42.620 --> 01:35:44.620
这里我给大家做个例子

01:35:44.620 --> 01:35:46.620
这里写了个辅助函数

01:35:46.620 --> 01:35:47.620
使循环的

01:35:47.620 --> 01:35:48.620
简单看一下

01:35:48.620 --> 01:35:49.620
你能看到吗

01:35:49.620 --> 01:35:50.620
看不懂算了

01:35:50.620 --> 01:35:52.620
这个玩意就了解一下就行了

01:35:52.620 --> 01:35:53.620
这里有两个按钮

01:35:53.620 --> 01:35:54.620
一个开始

01:35:54.620 --> 01:35:55.620
一个是添加交户人物

01:35:55.620 --> 01:35:56.620
这啥意思呢

01:35:56.620 --> 01:35:57.620
我写了三个函数

01:35:57.620 --> 01:35:58.620
第一个函数

01:35:58.620 --> 01:36:00.620
是添加一个延时人物

01:36:00.620 --> 01:36:01.620
到队列里面去

01:36:01.620 --> 01:36:02.620
我就给它展示了

01:36:02.620 --> 01:36:03.620
三个队列

01:36:03.620 --> 01:36:05.620
这是延时队列

01:36:05.620 --> 01:36:06.620
这个函数的作用

01:36:06.620 --> 01:36:07.620
就是添加一个东西

01:36:07.620 --> 01:36:08.620
到延时队列里面去

01:36:08.620 --> 01:36:10.620
这个是添加一个网络队列

01:36:10.620 --> 01:36:13.620
网络队列你们就不用看了吧

01:36:13.620 --> 01:36:14.620
就不用看了

01:36:14.620 --> 01:36:16.620
你们好多同学还没学过网络

01:36:16.620 --> 01:36:17.620
不用看了

01:36:17.620 --> 01:36:19.620
我就看延时和交户

01:36:19.620 --> 01:36:21.620
两个简单一点

01:36:21.620 --> 01:36:23.620
我就两个队列

01:36:23.620 --> 01:36:24.620
这里不涉及到微队列

01:36:24.620 --> 01:36:25.620
就两个队列

01:36:25.620 --> 01:36:26.620
一个是延时队列

01:36:26.620 --> 01:36:28.620
这个函数就添加一个东西

01:36:28.620 --> 01:36:29.620
到延时队列

01:36:29.620 --> 01:36:30.620
然后再单码很简单

01:36:30.620 --> 01:36:32.620
我先输出一个描述

01:36:32.620 --> 01:36:33.620
添加到延时队列

01:36:33.620 --> 01:36:34.620
怎么添加的

01:36:34.620 --> 01:36:36.620
我又计时100毫秒

01:36:36.620 --> 01:36:37.620
100毫秒过后

01:36:37.620 --> 01:36:39.620
是不是这个函数就到哪了

01:36:39.620 --> 01:36:40.620
到延时队列了

01:36:40.620 --> 01:36:42.620
它计时期吗

01:36:42.620 --> 01:36:44.620
说到延时队列

01:36:44.620 --> 01:36:46.620
为了保证

01:36:46.620 --> 01:36:48.620
我这个函数执行完了过后

01:36:48.620 --> 01:36:49.620
它一定到延时队列

01:36:49.620 --> 01:36:50.620
因为这个玩意

01:36:50.620 --> 01:36:51.620
它等100毫秒之后

01:36:51.620 --> 01:36:53.620
才会到延时队列

01:36:53.620 --> 01:36:54.620
对吧

01:36:54.620 --> 01:36:55.620
所以说为了保证

01:36:55.620 --> 01:36:56.620
它肯定到了延时队列

01:36:56.620 --> 01:36:57.620
所以说我这里

01:36:57.620 --> 01:36:59.620
强行给它死循环两秒钟

01:36:59.620 --> 01:37:00.620
那时间肯定到了

01:37:00.620 --> 01:37:01.620
对不对

01:37:01.620 --> 01:37:02.620
拿手标那个家伙

01:37:02.620 --> 01:37:04.620
我都等了你两秒钟

01:37:04.620 --> 01:37:05.620
你还没有给我加进去

01:37:05.620 --> 01:37:06.620
不可能

01:37:06.620 --> 01:37:08.620
等了两秒的作用

01:37:08.620 --> 01:37:10.620
保证这个函数运行完之后

01:37:10.620 --> 01:37:13.700
这个东西

01:37:13.700 --> 01:37:15.700
它一定到了延时队列

01:37:15.700 --> 01:37:16.700
就起着每个作用

01:37:16.700 --> 01:37:17.700
尽量看

01:37:17.700 --> 01:37:18.700
能看东西看

01:37:18.700 --> 01:37:19.700
看不懂算了

01:37:19.700 --> 01:37:21.700
这个玩意是添加到交互队列

01:37:21.700 --> 01:37:22.700
什么意思呢

01:37:22.700 --> 01:37:23.700
这有另外一个队列

01:37:23.700 --> 01:37:24.700
我先输出一句话

01:37:24.700 --> 01:37:26.700
我要现在添加交互队列了

01:37:26.700 --> 01:37:29.700
这个时候我注册一个点击事件

01:37:29.700 --> 01:37:32.700
我这里为什么会用简头函数

01:37:33.700 --> 01:37:37.260
我写一个ES5的吧

01:37:37.260 --> 01:37:39.260
你们尽量看得懂一点

01:37:40.260 --> 01:37:43.260
这是一个交互队列

01:37:44.260 --> 01:37:45.260
当点击的时候

01:37:45.260 --> 01:37:47.260
这个函数是不是会到这

01:37:47.260 --> 01:37:49.260
我这里等两秒钟

01:37:49.260 --> 01:37:50.260
目的是什么

01:37:50.260 --> 01:37:53.260
我给用户一点反应的时间

01:37:53.260 --> 01:37:54.260
不然的话瞬间过去

01:37:54.260 --> 01:37:55.260
用户反应不过来

01:37:55.260 --> 01:37:56.260
我等了两秒钟

01:37:56.260 --> 01:37:57.260
这两秒钟之内

01:37:57.260 --> 01:37:59.260
用户自己去点一下那个按钮

01:38:00.260 --> 01:38:01.260
然后一点这个按钮

01:38:01.260 --> 01:38:02.260
这个函数是不是到这了

01:38:03.260 --> 01:38:04.260
我等了两秒钟

01:38:04.260 --> 01:38:05.260
我给你两秒钟的时间

01:38:05.260 --> 01:38:06.260
当你去点

01:38:06.260 --> 01:38:07.260
点了过后

01:38:07.260 --> 01:38:09.260
这个函数就会到交互队列了

01:38:09.260 --> 01:38:10.260
就是我的目的是什么呢

01:38:10.260 --> 01:38:13.260
我的目的就是要做成有两个队列

01:38:13.260 --> 01:38:14.260
一个队列有严实任务

01:38:14.260 --> 01:38:16.260
一个队列是交互任务

01:38:16.260 --> 01:38:18.260
我要告诉你们哪个先取

01:38:18.260 --> 01:38:19.260
哪个后取

01:38:19.260 --> 01:38:21.260
按照我之前的说法

01:38:21.260 --> 01:38:24.260
就是要先取交互队列的东西

01:38:24.260 --> 01:38:26.260
而不管他们哪个先到

01:38:26.260 --> 01:38:27.260
哪个后到

01:38:28.260 --> 01:38:30.260
哪怕你是一个即时

01:38:30.260 --> 01:38:31.260
一个严实队列先到

01:38:32.260 --> 01:38:33.260
任务先到

01:38:33.260 --> 01:38:35.260
这个交互队列后到

01:38:35.260 --> 01:38:36.260
但是我到时候取的时候

01:38:36.260 --> 01:38:37.260
两个都有

01:38:37.260 --> 01:38:38.260
我一定先取交互的

01:38:38.260 --> 01:38:40.260
因为浏览器觉得交互任务

01:38:40.260 --> 01:38:41.260
更加重要

01:38:41.260 --> 01:38:42.260
就这么个意思

01:38:42.260 --> 01:38:44.260
我就要告诉你们这个

01:38:44.260 --> 01:38:45.260
好

01:38:45.260 --> 01:38:47.260
最后我点击这个按钮的时候

01:38:47.260 --> 01:38:48.260
点击这个按钮的时候

01:38:48.260 --> 01:38:49.260
开始

01:38:49.260 --> 01:38:50.260
我做这么两件事

01:38:50.260 --> 01:38:52.260
先添加到严实队列

01:38:52.260 --> 01:38:54.260
再添加到交互队列

01:38:54.260 --> 01:38:56.260
看一下他们的最终执行

01:38:56.260 --> 01:38:58.260
是按照这个添加顺序执行的吗

01:39:02.560 --> 01:39:04.560
那些以前的一些教程里

01:39:04.560 --> 01:39:06.560
比如说任务只有两个队列

01:39:06.560 --> 01:39:07.560
一个红队的一个微队列

01:39:07.560 --> 01:39:08.560
它就解释不了这个现象

01:39:08.560 --> 01:39:09.560
它是很多个队列的

01:39:11.560 --> 01:39:12.560
看着开始

01:39:12.560 --> 01:39:13.560
添加到严实队列

01:39:14.560 --> 01:39:16.560
好 马上点一下添加这个按钮

01:39:16.560 --> 01:39:17.560
你看

01:39:17.560 --> 01:39:19.560
一定是交互队列执行

01:39:19.560 --> 01:39:21.560
延迟队列执行

01:39:21.560 --> 01:39:22.560
我就要跟你说这个

01:39:22.560 --> 01:39:24.560
其实添加的顺序是

01:39:24.560 --> 01:39:25.560
先添加到的严实

01:39:25.560 --> 01:39:26.560
再添加到交互

01:39:26.560 --> 01:39:27.560
最后执行的时候

01:39:27.560 --> 01:39:29.560
两个队列都有

01:39:29.560 --> 01:39:30.560
就是我忙完了之后

01:39:30.560 --> 01:39:31.560
发现两个队列都有

01:39:31.560 --> 01:39:33.560
我就不管你谁先来还是后来

01:39:33.560 --> 01:39:34.560
我一定是从

01:39:34.560 --> 01:39:36.560
交互队列里面取第一个

01:39:36.560 --> 01:39:38.560
因为交互任务更加重要

01:39:38.560 --> 01:39:39.560
就这么个意思

01:39:39.560 --> 01:39:40.560
我就跟你说明这个

01:39:40.560 --> 01:39:42.560
能看到就看 看不能算

01:39:42.560 --> 01:39:44.560
好 最后的问题

01:39:44.560 --> 01:39:46.560
这个问题也是经常问的

01:39:46.560 --> 01:39:48.560
但是你的回答

01:39:48.560 --> 01:39:52.560
要远远超出面试官的预期

01:39:52.560 --> 01:39:54.560
那超到没边缘了

01:39:54.560 --> 01:39:55.560
快把他吓死了

01:39:59.470 --> 01:40:01.470
既然始终的技术器

01:40:01.470 --> 01:40:03.470
能做到精确计时吗

01:40:03.470 --> 01:40:04.470
为什么

01:40:04.470 --> 01:40:06.470
就是一个

01:40:06.470 --> 01:40:08.470
能做到精确计时吗

01:40:08.470 --> 01:40:11.470
你看着该怎么回答

01:40:11.470 --> 01:40:12.470
首先不行

01:40:12.470 --> 01:40:14.470
为啥四个原因

01:40:14.470 --> 01:40:15.470
第一个

01:40:15.470 --> 01:40:17.470
计算机硬件没有

01:40:17.470 --> 01:40:18.470
你看这些

01:40:18.470 --> 01:40:20.470
都快被别人吓死了

01:40:20.470 --> 01:40:22.470
计算机硬件没有原子中

01:40:22.470 --> 01:40:24.470
最准准确的计时是原子中

01:40:24.470 --> 01:40:27.470
啥时候的原子中你直接摆渡

01:40:27.470 --> 01:40:29.470
计算机里面没有原子中

01:40:29.470 --> 01:40:31.470
它是利用那个CPU技讯器做的

01:40:31.470 --> 01:40:33.470
无法做到精确计时

01:40:33.470 --> 01:40:35.470
硬件就做不到

01:40:35.470 --> 01:40:37.470
你还指望一个GS能做到

01:40:37.470 --> 01:40:39.470
当然这个第一条是有

01:40:39.470 --> 01:40:41.470
确实有点抬杠的意思

01:40:41.470 --> 01:40:43.470
那个原子中怎么可能有呢

01:40:43.470 --> 01:40:45.470
好 第二点

01:40:45.470 --> 01:40:47.470
操作系统即时

01:40:47.470 --> 01:40:49.470
函数本身就有少量偏差

01:40:49.470 --> 01:40:51.470
其实我们用的那个GS里边

01:40:51.470 --> 01:40:53.470
set timeout和set interval

01:40:53.470 --> 01:40:55.470
它其实是

01:40:55.470 --> 01:40:58.470
最终雕用的是操作系统的函数

01:40:58.470 --> 01:41:00.470
不同的操作系统

01:41:00.470 --> 01:41:01.470
它的实现不一样

01:41:01.470 --> 01:41:03.470
Windows和Mac就不一样

01:41:03.470 --> 01:41:05.470
你看Google语论系的原罢里边

01:41:05.470 --> 01:41:07.470
它实际上是针对Mac和Windows

01:41:07.470 --> 01:41:09.470
都做了不同的实现

01:41:09.470 --> 01:41:11.470
雕的是不同的函数

01:41:11.470 --> 01:41:13.470
说本身就有操作系统都有偏差

01:41:13.470 --> 01:41:14.470
我又雕的是你的

01:41:14.470 --> 01:41:16.470
那这个偏差就直接带过来了

01:41:16.470 --> 01:41:18.470
就携带了这样的一个偏差

01:41:18.470 --> 01:41:20.470
这是第二个原因

01:41:20.470 --> 01:41:21.470
第三个原因

01:41:21.470 --> 01:41:23.470
按照W3C的标准

01:41:23.470 --> 01:41:25.470
浏览器实现计时器的时候

01:41:25.470 --> 01:41:27.470
如果千套成绩

01:41:27.470 --> 01:41:28.470
超过了五成

01:41:28.470 --> 01:41:30.470
只会带有4毫秒的最少时间

01:41:30.470 --> 01:41:31.470
这啥意思

01:41:31.470 --> 01:41:36.190
就是我写一个set timeout

01:41:37.190 --> 01:41:39.190
我这里写个函数

01:41:39.190 --> 01:41:41.190
我在这里边写吧

01:41:41.190 --> 01:41:44.890
随便写一个文件吧

01:41:44.890 --> 01:41:49.930
说清楚就行了

01:41:49.930 --> 01:41:50.930
难得掩饰了

01:41:50.930 --> 01:41:52.930
为什么写个方形

01:41:52.930 --> 01:41:57.330
我这个写个0秒

01:41:57.330 --> 01:41:58.330
0秒过后运行这个函数

01:41:58.330 --> 01:41:59.330
是0秒过后运行吗

01:41:59.330 --> 01:42:01.330
它确实是0秒过后

01:42:01.330 --> 01:42:03.330
0秒过后把它加到哪

01:42:03.330 --> 01:42:05.330
加到延时对立

01:42:05.330 --> 01:42:06.330
没问题的

01:42:06.330 --> 01:42:09.330
但是如果说你千套的成绩生了

01:42:10.330 --> 01:42:12.330
超过了五成

01:42:12.330 --> 01:42:14.330
不好意思

01:42:14.330 --> 01:42:16.330
你这个地方的0秒

01:42:16.330 --> 01:42:18.330
就会变成4

01:42:18.330 --> 01:42:20.330
为啥要这样做

01:42:20.330 --> 01:42:21.330
我就不展开了

01:42:21.330 --> 01:42:23.330
得要说一大堆大的东西

01:42:23.330 --> 01:42:25.330
它有它的考虑

01:42:26.330 --> 01:42:27.330
最早的时候

01:42:27.330 --> 01:42:28.330
你不用千套

01:42:28.330 --> 01:42:30.330
它直接就是4

01:42:30.330 --> 01:42:31.330
现在不会了

01:42:31.330 --> 01:42:33.330
那为啥又不会了

01:42:33.330 --> 01:42:34.330
这个真不展开了

01:42:34.330 --> 01:42:36.330
这块我真没法展开了

01:42:36.330 --> 01:42:38.330
就这样吧

01:42:38.330 --> 01:42:40.330
千套超过五成的时候

01:42:40.330 --> 01:42:42.330
它最小就是4

01:42:42.330 --> 01:42:44.330
那么后面都是4

01:42:44.330 --> 01:42:46.330
后面全是4

01:42:46.330 --> 01:42:49.330
外边4成是0

01:42:49.330 --> 01:42:51.330
超过五成变4

01:42:51.330 --> 01:42:53.330
第五成好像也是0

01:42:53.330 --> 01:42:55.330
超过五成变4

01:42:55.330 --> 01:42:57.330
就这么个道理

01:42:57.330 --> 01:42:59.330
好

01:42:59.330 --> 01:43:00.330
再看一下

01:43:00.330 --> 01:43:02.330
看看浏览器的视线源

01:43:03.330 --> 01:43:05.330
我记得把弄在这

01:43:05.330 --> 01:43:07.330
Timer

01:43:07.330 --> 01:43:09.330
这个是ZTimeout的源

01:43:09.330 --> 01:43:10.330
在这

01:43:10.330 --> 01:43:12.330
这里面是ZTimeout的源

01:43:12.330 --> 01:43:14.330
里面就有

01:43:14.330 --> 01:43:16.330
看一下这里

01:43:16.330 --> 01:43:18.330
这个是ZTimeout的源

01:43:18.330 --> 01:43:20.330
ZTimeout的源

01:43:20.330 --> 01:43:22.330
这个地方

01:43:22.330 --> 01:43:24.330
这不是介绍代码

01:43:24.330 --> 01:43:26.330
看一下

01:43:26.330 --> 01:43:27.330
Max

01:43:27.330 --> 01:43:31.330
最大的Timer

01:43:31.330 --> 01:43:32.330
千套

01:43:32.330 --> 01:43:35.330
最大的千套等级5级

01:43:35.330 --> 01:43:37.330
超过了最大的千套等级

01:43:37.330 --> 01:43:38.330
你看这里

01:43:38.330 --> 01:43:40.330
按照W3C的

01:43:40.330 --> 01:43:41.330
W3C的官网

01:43:41.330 --> 01:43:44.330
按照W3C的官网的解释

01:43:44.330 --> 01:43:46.330
即时器

01:43:46.330 --> 01:43:48.330
如果说

01:43:48.330 --> 01:43:50.330
间隔时间小为了4毫秒

01:43:50.330 --> 01:43:53.330
它会被增加到4毫秒

01:43:53.330 --> 01:43:54.330
什么时候呢

01:43:54.330 --> 01:43:55.330
不是所有的时候

01:43:55.330 --> 01:43:56.330
当千套的层级

01:43:56.330 --> 01:43:58.330
超过5级的时候

01:43:59.330 --> 01:44:00.330
它这里写了

01:44:00.330 --> 01:44:01.330
第一个5

01:44:01.330 --> 01:44:02.330
超过5级

01:44:02.330 --> 01:44:04.330
最少的时间4毫秒

01:44:04.330 --> 01:44:06.330
看没

01:44:07.330 --> 01:44:08.330
你说这些玩意

01:44:08.330 --> 01:44:09.330
你跟面士官说了

01:44:09.330 --> 01:44:11.330
不怕吓死

01:44:11.330 --> 01:44:13.330
它最后一个原因

01:44:13.330 --> 01:44:15.330
面士官希望你回答这个

01:44:15.330 --> 01:44:17.330
但是你把这三个夹上去了

01:44:17.330 --> 01:44:19.330
就特别吓人

01:44:19.330 --> 01:44:21.330
受事件循环的影响

01:44:21.330 --> 01:44:23.330
即时器的回掉函数

01:44:23.330 --> 01:44:26.330
只能在主线层空闲的时候运行

01:44:27.330 --> 01:44:28.330
所以说过的

01:44:29.330 --> 01:44:31.330
你主线层要闲下来过后

01:44:31.330 --> 01:44:33.330
才从对列里面去取东西

01:44:33.330 --> 01:44:34.330
去执行

01:44:35.330 --> 01:44:36.330
这是事件循环

01:44:36.330 --> 01:44:37.330
我闲下来了

01:44:37.330 --> 01:44:38.330
我就拿下一个

01:44:38.330 --> 01:44:40.330
这个人服务完了就下一个

01:44:41.330 --> 01:44:42.330
所以你虽然即时器的

01:44:42.330 --> 01:44:43.330
0秒过后

01:44:43.330 --> 01:44:44.330
你已经

01:44:44.330 --> 01:44:45.330
像我们刚才的解释一样

01:44:45.330 --> 01:44:47.330
你0秒过后

01:44:47.330 --> 01:44:48.330
你已经把它加到

01:44:48.330 --> 01:44:49.330
延时对列了

01:44:49.330 --> 01:44:50.330
但是因为种种原因

01:44:50.330 --> 01:44:51.330
它可能还在忙

01:44:51.330 --> 01:44:52.330
它还有维对的要取

01:44:52.330 --> 01:44:54.330
还有交付时间要取

01:44:54.330 --> 01:44:55.330
你就得等

01:44:56.330 --> 01:44:57.330
这又造成了差异

01:44:57.330 --> 01:45:00.330
面士官是希望你回答这个

01:45:00.330 --> 01:45:02.330
但是你真正要回答的时候

01:45:02.330 --> 01:45:04.330
要把前三条夹上

01:45:05.330 --> 01:45:07.330
秒杀其他的音频者

01:45:08.330 --> 01:45:10.330
你光一个事件循环

01:45:10.330 --> 01:45:11.330
你能做到这一点

01:45:11.330 --> 01:45:12.330
如果说你每一个知识点

01:45:12.330 --> 01:45:13.330
都能做到这一点

01:45:14.330 --> 01:45:15.330
你救不了业

01:45:15.330 --> 01:45:16.330
你不能高兴救业

01:45:16.330 --> 01:45:18.330
我用头去装那个墙

01:45:18.330 --> 01:45:19.330
最后总结一下吧

01:45:20.330 --> 01:45:21.330
我们这一刻一开始讲了

01:45:21.330 --> 01:45:23.330
浏览器的进程模型

01:45:23.330 --> 01:45:25.330
告诉你浏览器启动过后

01:45:25.330 --> 01:45:27.330
它会开启多个进程

01:45:27.330 --> 01:45:28.330
为了隔离

01:45:28.330 --> 01:45:30.330
避免一个进程的功能

01:45:30.330 --> 01:45:32.330
运行崩溃了之后

01:45:32.330 --> 01:45:33.330
影响到其他进程

01:45:33.330 --> 01:45:34.330
隔离之后

01:45:34.330 --> 01:45:35.330
一个进程崩溃

01:45:35.330 --> 01:45:36.330
不会影响到别人

01:45:37.330 --> 01:45:38.330
然后在这些进程里边

01:45:38.330 --> 01:45:40.330
我们重点讲了

01:45:40.330 --> 01:45:41.330
渲染进程

01:45:41.330 --> 01:45:43.330
特别是渲染进程里边的

01:45:43.330 --> 01:45:46.330
主线程叫做渲染主线程

01:45:46.330 --> 01:45:48.330
因为渲染主线程的承担的事情

01:45:48.330 --> 01:45:49.330
太多了

01:45:49.330 --> 01:45:50.330
太忙了

01:45:50.330 --> 01:45:52.330
所以它找到了一种方式

01:45:52.330 --> 01:45:55.330
来解决事情混乱的问题

01:45:55.330 --> 01:45:57.330
同学们也可以学习一下

01:45:57.330 --> 01:45:58.330
当你事情多的时候

01:45:59.330 --> 01:46:00.330
你可以排队

01:46:00.330 --> 01:46:01.330
这些事情

01:46:01.330 --> 01:46:02.330
一件一件处理

01:46:03.330 --> 01:46:04.330
不要同时处理几件

01:46:04.330 --> 01:46:05.330
人都是单线程的

01:46:07.330 --> 01:46:08.330
这样子我们使用一个

01:46:08.330 --> 01:46:09.330
对列的方式

01:46:09.330 --> 01:46:10.330
把一个任务

01:46:10.330 --> 01:46:11.330
一个任务取出来执行

01:46:11.330 --> 01:46:12.330
执行完了之后

01:46:12.330 --> 01:46:13.330
再取下一个

01:46:13.330 --> 01:46:15.330
这就是事件循环

01:46:15.330 --> 01:46:16.330
实际上它本质上

01:46:16.330 --> 01:46:18.330
就是用了一个无限的循环

01:46:18.330 --> 01:46:20.330
每一次循环取一个任务执行

01:46:20.330 --> 01:46:21.330
执行完了取下一个

01:46:21.330 --> 01:46:22.330
下一次循环取下一个

01:46:23.330 --> 01:46:24.330
那么这个事件循环

01:46:24.330 --> 01:46:26.330
其实跟异部就有关系

01:46:26.330 --> 01:46:27.330
如果说

01:46:27.330 --> 01:46:29.330
我们使用同步的方式

01:46:29.330 --> 01:46:30.330
就会造成组色

01:46:30.330 --> 01:46:32.330
而用这种事件循环的方式

01:46:32.330 --> 01:46:35.330
把任务加到对列别排队

01:46:35.330 --> 01:46:37.330
就不会有这个组色的问题

01:46:37.330 --> 01:46:38.330
所以说我们有一句话

01:46:38.330 --> 01:46:40.330
非常经典的一句话

01:46:40.330 --> 01:46:41.330
这么经典的话

01:46:41.330 --> 01:46:42.330
是谁说的

01:46:42.330 --> 01:46:43.330
就是袁老师说的

01:46:44.330 --> 01:46:50.330
叫做事件循环是异部的实现方式

01:46:50.330 --> 01:46:53.330
另外一句话也是袁老师说的

01:46:53.330 --> 01:46:58.330
叫做单线程是异部产生的原因

01:46:58.330 --> 01:46:59.330
读一下

01:46:59.330 --> 01:47:01.330
单线程是异部产生的原因

01:47:01.330 --> 01:47:04.330
事件循环是异部的实现方式

01:47:04.330 --> 01:47:06.330
把这句话有意无意的

01:47:06.330 --> 01:47:07.330
在面试的过程中

01:47:07.330 --> 01:47:09.330
讲给面试观听

01:47:09.330 --> 01:47:12.330
你说这些话你说多了

01:47:12.330 --> 01:47:15.330
包括我这里讲的一些面试你说多了

01:47:15.330 --> 01:47:18.330
你得当心那个面试观的小心张

01:47:18.330 --> 01:47:20.330
这些话他都要自己消化一下

01:47:20.330 --> 01:47:23.330
然后才能恍然大悟

01:47:23.330 --> 01:47:25.330
然后就是异部的实现

01:47:25.330 --> 01:47:27.330
可以解决组线程组色的问题

01:47:27.330 --> 01:47:28.330
有了异部之后

01:47:28.330 --> 01:47:30.330
线程永不组色

01:47:30.330 --> 01:47:32.330
我们的整个浏览器的运行

01:47:32.330 --> 01:47:34.330
就非常流畅了

01:47:34.330 --> 01:47:35.330
然后我们在事件循环里边

01:47:35.330 --> 01:47:37.330
实际上使用了多个对列

01:47:37.330 --> 01:47:39.330
有微对列有严实对列有交互对列

01:47:39.330 --> 01:47:41.330
最先执行的一定是微对列

01:47:41.330 --> 01:47:42.330
第一是取任务的时候

01:47:42.330 --> 01:47:44.330
优先从微对列里面去取

01:47:44.330 --> 01:47:46.330
取完了之后再去看其他对列

01:47:46.330 --> 01:47:48.330
实际上这一块浏览器的具体实现里边

01:47:48.330 --> 01:47:50.330
还有很多很多的细节

01:47:50.330 --> 01:47:52.330
实际上是非常复杂的

01:47:52.330 --> 01:47:54.330
但是毕竟我们培养的是前端工程师

01:47:54.330 --> 01:47:56.330
培养的并不是让你去除区域

01:47:56.330 --> 01:47:59.330
开发浏览器没到那种程度

01:47:59.330 --> 01:48:01.330
所以我们这一块讲到这

01:48:01.330 --> 01:48:03.330
就已经讲得非常深入了

01:48:03.330 --> 01:48:05.330
然后在严实对列和交互对列这一块

01:48:05.330 --> 01:48:07.330
目前来讲是交互对列优先取

01:48:07.330 --> 01:48:09.330
然后严实对列的后去

01:48:09.330 --> 01:48:10.330
将来会怎么样不知道

01:48:10.330 --> 01:48:12.330
但一定是微对列首先取

01:48:12.330 --> 01:48:14.330
它的优先级是最高的

01:48:14.330 --> 01:48:16.330
好其他的就没啥了

01:48:16.330 --> 01:48:18.330
这就是整个的本节课的脉络

01:48:18.330 --> 01:48:20.330
这种节鞋的话脉络还是非常清晰的

01:48:20.330 --> 01:48:23.330
同一门下去之后一定要好好去消化

01:48:23.330 --> 01:48:25.330
好吧这是事件循环这一块的支持

01:48:25.330 --> 01:48:27.330
OK那么这一刻就到这了

01:48:27.330 --> 01:48:28.330
拜拜

