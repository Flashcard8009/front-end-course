WEBVTT

00:00.110 --> 00:02.810
上天看到咱们说了这个零碎的改动对吧

00:02.810 --> 00:04.010
零碎碎的一些东西

00:04.710 --> 00:07.310
接下来呢就是一叶层套的东西了

00:07.910 --> 00:09.310
我就说ES-6啊

00:09.910 --> 00:11.910
它对于我们语法层面的更新

00:11.910 --> 00:14.310
那是真的是下了决心动了刀子的

00:14.910 --> 00:17.810
我当年呢学这个ES-6呢是看了一本书

00:18.210 --> 00:20.510
这个书呢我把PTF给你们下载下来的啊

00:20.610 --> 00:21.510
也翻译过来了

00:21.510 --> 00:23.410
就是网上有人翻译的

00:23.810 --> 00:25.510
那么这本书呢一会我给你们发下去

00:26.210 --> 00:27.610
你们可以去看一看这本书

00:27.610 --> 00:29.810
这本书呢基本上就详细记录了ES-6

00:30.310 --> 00:31.910
对哪些层面做了更新

00:32.810 --> 00:34.010
内容非常的详细

00:34.310 --> 00:37.510
这本书的作者呢就是参与制定ES-6标准的

00:37.910 --> 00:38.810
啊一个

00:39.210 --> 00:40.610
呃开发者

00:41.210 --> 00:42.910
除了这本书呢是值得一看的啊

00:42.910 --> 00:44.910
同学们下来如果说有时间的话

00:44.910 --> 00:46.310
可以去好好看一下这本书

00:46.310 --> 00:47.510
一把这本书看完了

00:47.510 --> 00:49.910
基本上你所有的ES-6的面试全部搞定了

00:51.110 --> 00:52.010
好这是

00:52.910 --> 00:53.710
那个

00:54.210 --> 00:57.210
咱们这些课呢就讲那个宿主层面的更新

00:58.010 --> 00:59.610
看它对于宿主做的那些改动

00:59.710 --> 01:01.810
宿主呢历来是一个大问题

01:02.810 --> 01:04.210
是既也是大问题啊

01:04.310 --> 01:07.010
在ES-3就ES-5之前

01:07.210 --> 01:09.510
你知道宿主里边API有多少吗

01:09.910 --> 01:11.010
只用那么几个

01:11.410 --> 01:13.510
比方说铺锡加一个东西

01:13.510 --> 01:15.110
帕谈一个东西出来

01:15.510 --> 01:18.010
还有那个呃reverse

01:18.710 --> 01:19.310
翻转

01:20.610 --> 01:22.710
还有还有那么一下边的三层宿主

01:22.710 --> 01:24.810
还有宿主阶段就那么几个API

01:24.910 --> 01:26.110
特别特别少

01:26.710 --> 01:29.810
然后ES-5呢给我们增加了很多的宿主API

01:29.910 --> 01:31.610
然后ES-6呢又加了一些

01:31.810 --> 01:32.710
好咱们来看看啊

01:32.710 --> 01:33.810
首先宿主这边

01:34.510 --> 01:36.810
有一个语法层面的变化

01:37.410 --> 01:38.210
这个语法层面呢

01:38.210 --> 01:40.010
倒是跟宿主没有直接关系了

01:40.010 --> 01:44.110
只不过我们通常使用它来操作宿主

01:44.410 --> 01:46.710
这个for2叫做for25循环

01:46.710 --> 01:47.610
什么意思呢

01:47.610 --> 01:50.010
它提供了一种非常非常爽的方式

01:50.410 --> 01:53.810
让你去遍地各种宿主和伪宿主

01:53.810 --> 01:54.810
伪宿主也可以

01:55.710 --> 01:57.510
那么它里边还是有细节的

01:57.510 --> 01:59.210
我们细节不用去升级那么多

01:59.210 --> 02:01.510
因为我们目前的这个阶段只是

02:01.710 --> 02:03.010
教大家如何去使用

02:03.410 --> 02:04.210
给大家看一下吧

02:04.810 --> 02:05.810
过去了有一个宿主

02:06.310 --> 02:07.610
我要变力它怎么变力的

02:07.610 --> 02:08.610
是不是得用for循环

02:08.610 --> 02:08.910
对吧

02:08.910 --> 02:11.210
不管你用for还是net都得用for循环吗

02:11.510 --> 02:13.010
然后一个个循循环

02:13.110 --> 02:15.810
把每一个用下标拿出来循环它

02:16.310 --> 02:18.110
有了for25循环之后啊

02:18.110 --> 02:19.610
我们就可以用这种方式了

02:20.210 --> 02:21.110
非常简洁

02:21.210 --> 02:22.910
for这里定一个变量

02:23.010 --> 02:24.710
利用net-conc8都可以

02:24.710 --> 02:26.510
其实我们一般用conc

02:26.710 --> 02:28.710
然后这里边定一个变量名字

02:28.710 --> 02:29.710
名字里随便取

02:30.010 --> 02:30.910
关键字O

02:31.310 --> 02:31.910
然后宿主

02:32.010 --> 02:32.710
啥意思啊

02:32.710 --> 02:35.410
它就把宿主的每一项第一次给你取出来

02:35.410 --> 02:36.510
首先把第一项

02:36.910 --> 02:38.510
取出来放到item里边

02:38.610 --> 02:40.110
然后运行循环题

02:40.210 --> 02:40.910
运行一遍

02:41.510 --> 02:44.710
然后第二项B取出来放到item里边

02:44.910 --> 02:46.210
又运行一遍循环题

02:46.710 --> 02:49.610
然后第三项C取出来放到item里边

02:49.710 --> 02:50.910
又运行一次循环题

02:51.410 --> 02:52.110
没了意思吧

02:52.210 --> 02:53.610
这就是for25循环

02:53.610 --> 02:54.410
非常简单

02:54.710 --> 02:56.410
然后它不仅可以循环数组啊

02:56.410 --> 02:57.610
还可以循环伪数组

02:57.610 --> 02:59.210
比方说你通过document

02:59.310 --> 03:00.310
queryStacketO

03:00.310 --> 03:01.810
是不是拿到一堆元素

03:01.810 --> 03:03.110
这个元素不是真正的数组

03:03.410 --> 03:04.610
它是一个伪数组

03:05.310 --> 03:05.910
但是呢

03:06.010 --> 03:08.110
也可以通过for25循环来循环它

03:08.110 --> 03:08.710
for

03:09.510 --> 03:10.710
变量名字25

03:11.310 --> 03:13.610
然后这个伪数组或者数组名字

03:13.610 --> 03:15.810
然后它就一项一项拿出来放到这个变量里边

03:15.810 --> 03:17.210
变量名字里随便取的啊

03:17.610 --> 03:18.910
然后去运行循环题

03:19.710 --> 03:20.910
它就是for25循环

03:22.510 --> 03:23.210
然后接下来呢

03:23.210 --> 03:25.210
除了这个语法层面的变化呢

03:25.210 --> 03:25.810
还要给你

03:25.810 --> 03:26.610
但是我再说一次

03:26.610 --> 03:27.610
这个for25呢

03:27.610 --> 03:28.810
其实跟数组啊

03:28.810 --> 03:29.810
它没有直接的关系

03:29.810 --> 03:31.410
因为它还可以循环伪数组

03:31.610 --> 03:32.210
呃

03:32.210 --> 03:34.610
它实际上里边是有一些迭代器的指示

03:34.610 --> 03:35.210
不过那个指示呢

03:35.210 --> 03:36.310
我们目前不涉及

03:37.510 --> 03:38.110
通常情况下

03:38.110 --> 03:39.010
我们用for25循环

03:39.010 --> 03:40.710
就是循环数组合为数组

03:40.910 --> 03:42.410
然后接下来是数组里边

03:42.510 --> 03:44.810
新增了很多很多的API

03:45.110 --> 03:46.110
大量的API

03:46.610 --> 03:47.910
我们快速的

03:48.110 --> 03:49.210
把它过一遍

03:49.210 --> 03:50.610
然后接下来我们就来做

03:51.010 --> 03:51.610
练习题

03:51.910 --> 03:52.810
通过练习题

03:52.810 --> 03:53.810
不断的去加深它

03:53.810 --> 03:54.610
加深影响

03:55.310 --> 03:57.010
好一个是意志而畏

03:58.110 --> 03:59.110
判断一个东西

03:59.110 --> 03:59.810
是不是数组里

03:59.810 --> 04:00.910
看我这个文档怎么写的

04:00.910 --> 04:02.210
而畏点意志而畏

04:02.210 --> 04:03.010
那么是不是什么

04:03.010 --> 04:04.710
是静态方法

04:04.910 --> 04:06.610
直接通过构造还说调用的

04:07.310 --> 04:07.610
啊

04:07.610 --> 04:08.310
那么比方说啊

04:08.310 --> 04:09.410
我就要举个例子啊

04:10.010 --> 04:10.610
呃

04:10.610 --> 04:11.110
有

04:11.110 --> 04:12.610
我们就随便找军东吧

04:13.110 --> 04:13.810
随便来一个

04:15.110 --> 04:16.310
然后我们找到共产

04:16.610 --> 04:17.210
元素

04:18.110 --> 04:18.910
空置太大

04:21.270 --> 04:23.570
随便找一个找一些元素哈

04:23.670 --> 04:25.070
我们比方说就找

04:25.570 --> 04:26.370
document

04:26.770 --> 04:27.570
query

04:27.770 --> 04:28.570
selector

04:28.870 --> 04:29.270
哦

04:29.570 --> 04:30.970
找所有的A元素吧

04:31.170 --> 04:31.970
我们拿到

04:32.470 --> 04:33.070
links

04:33.670 --> 04:34.470
随到A元素

04:35.070 --> 04:37.970
那么这个A元素是一个伪数组还是真数组啊

04:39.070 --> 04:40.270
它是一个伪数组对吧

04:40.270 --> 04:41.070
我们都知道

04:41.070 --> 04:41.870
但有的时候呢

04:41.870 --> 04:42.670
我们拿到一个变量

04:42.670 --> 04:43.570
它可能是真数组

04:43.570 --> 04:44.470
也可能是伪数组

04:44.470 --> 04:45.170
我们不知道

04:45.170 --> 04:46.670
我们就可以通过这个而畏

04:47.170 --> 04:47.970
意志而畏

04:47.970 --> 04:49.970
它是不是一个数组来经营判断

04:50.370 --> 04:51.770
那么比方说把links传进去

04:51.770 --> 04:52.770
他告诉我是force

04:52.770 --> 04:53.970
它不是一个真正的数组

04:53.970 --> 04:54.970
它是一个伪数组

04:55.170 --> 04:55.770
不要历史吧

04:55.770 --> 04:56.570
就这个函数啊

04:56.570 --> 04:57.470
它就在判断

04:57.870 --> 04:59.370
某一个东西它是不是一个数组

04:59.670 --> 05:01.170
那比方说我给他一容意志而畏

05:01.170 --> 05:02.270
要传一个数组进去

05:05.000 --> 05:05.400
哎

05:06.100 --> 05:08.000
所以去是真数组

05:08.100 --> 05:09.100
然后该传一个

05:11.000 --> 05:11.600
这块

05:12.500 --> 05:13.800
force为数组

05:14.500 --> 05:14.800
啊

05:14.800 --> 05:15.700
不是真数组

05:15.700 --> 05:16.100
对啊

05:16.100 --> 05:16.700
传一个数字

05:16.700 --> 05:17.600
那更加不是数组

05:18.600 --> 05:20.600
这就是意志而畏啊

05:20.600 --> 05:21.600
它判断一个东西

05:21.600 --> 05:22.600
它是不是数组

05:22.600 --> 05:24.600
然后还有个而畏

05:24.600 --> 05:26.600
它是把一个东西转换成数组

05:27.600 --> 05:29.600
它通常是把一个伪数组

05:29.600 --> 05:30.600
转换成一个真数组

05:30.600 --> 05:31.600
比方说我们还是刚才这个

05:32.600 --> 05:33.600
刚才我们不是一个links吗

05:33.600 --> 05:34.600
对吧

05:34.600 --> 05:35.600
这是什么伪数组

05:35.600 --> 05:36.600
我们可以通过而畏

05:36.600 --> 05:37.600
force

05:37.600 --> 05:39.600
把这个links传进去

05:39.600 --> 05:41.600
它不会改变这个数组的啊

05:41.600 --> 05:43.600
它只是反回一个新的数组

05:43.600 --> 05:44.600
反回一个新的数组

05:44.600 --> 05:45.600
就是真数组

05:45.600 --> 05:46.600
比方说

05:46.600 --> 05:47.600
lr

05:47.600 --> 05:48.600
我们来接受一下

05:48.600 --> 05:49.600
好

05:49.600 --> 05:50.600
这样我们来看个lr

05:50.600 --> 05:51.600
它就是个真正的数组

05:51.600 --> 05:52.600
好

05:52.600 --> 05:53.600
我们可以通过而畏

05:53.600 --> 05:55.600
意志而畏去判断一下lr

05:55.600 --> 05:56.600
说去

05:56.600 --> 05:57.600
变成真数组

05:57.600 --> 05:59.600
就这么一个回事

05:59.600 --> 06:01.600
那我为什么要把它转换成真数组呢

06:01.600 --> 06:02.600
有的时候是这样子

06:02.600 --> 06:03.600
就是为

06:03.600 --> 06:04.600
因为我们数组里边

06:04.600 --> 06:05.600
增加了很多的API

06:05.600 --> 06:06.600
对吧

06:06.600 --> 06:07.600
你看这些有很多很多的函数

06:07.600 --> 06:09.600
那么伪数组是没有的

06:09.600 --> 06:10.600
这函数伪数组是没有的

06:10.600 --> 06:11.600
所以有的时候

06:11.600 --> 06:12.600
我们可以把

06:12.600 --> 06:13.600
转换成真数组过后

06:13.600 --> 06:14.600
就可以使用这些函数了

06:14.600 --> 06:15.600
好

06:15.600 --> 06:16.600
你看这些函数

06:16.600 --> 06:17.600
这函数特别特别多

06:17.600 --> 06:19.600
我们这里比方一个一个看吧

06:19.600 --> 06:20.600
快速的了解一下

06:20.600 --> 06:21.600
后面一个图例

06:21.600 --> 06:22.600
可以通过这个图

06:22.600 --> 06:23.600
快速的看出

06:23.600 --> 06:24.600
这个函数在做什么事情

06:24.600 --> 06:25.600
这个函数在做什么事呢

06:25.600 --> 06:27.600
将数组的某些向设之为n

06:27.600 --> 06:29.600
你看它是圆形方法

06:29.600 --> 06:31.600
将数组的某些向设之为n

06:31.600 --> 06:32.600
通常情况下

06:32.600 --> 06:33.600
就是在做数组填充的

06:33.600 --> 06:34.600
比方说这里准备好了一个数组

06:34.600 --> 06:35.600
这个数组里边

06:35.600 --> 06:36.600
每一项都没有值

06:36.600 --> 06:37.600
对吧

06:37.600 --> 06:38.600
是一个西松数组

06:38.600 --> 06:39.600
然后我给它

06:39.600 --> 06:41.600
每一项填充一个值

06:41.600 --> 06:42.600
就填充了

06:42.600 --> 06:43.600
就这个样子

06:43.600 --> 06:44.600
咱们举个例子

06:44.600 --> 06:46.600
我这里可以定一个数组

06:46.600 --> 06:47.600
30

06:47.600 --> 06:48.600
长度为30的数组

06:48.600 --> 06:50.600
但是这个数组是一个西松数组

06:50.600 --> 06:51.600
里边只有一个长度

06:51.600 --> 06:52.600
每一项没有值

06:52.600 --> 06:54.600
然后我可以通过这个数组

06:54.600 --> 06:55.600
这是个数组

06:55.600 --> 06:56.600
我当然也可以用变量

06:56.600 --> 06:58.600
有些朋友不用变量保存

06:58.600 --> 06:59.600
根本就不知道

06:59.600 --> 07:00.600
这程序怎么写了

07:00.600 --> 07:01.600
必须得用变量保存

07:01.600 --> 07:03.600
那就变量保存一下

07:03.600 --> 07:05.600
表达是跟变量本质上

07:05.600 --> 07:06.600
也没什么区别

07:06.600 --> 07:07.600
只要是数组就行

07:08.600 --> 07:09.600
二位

07:09.600 --> 07:11.600
长度为30的数组

07:11.600 --> 07:12.600
那么我可以

07:12.600 --> 07:13.600
这个数组里面是空的

07:13.600 --> 07:14.600
对吧

07:14.600 --> 07:15.600
我可以把它填充

07:15.600 --> 07:18.600
填充比较多能填充一个123

07:18.600 --> 07:19.600
那么这样子数组里边

07:19.600 --> 07:21.600
每一项就是一个123了

07:21.600 --> 07:23.600
咱们再看一下AR

07:23.600 --> 07:25.600
AR是不是每个项就123了

07:25.600 --> 07:26.600
而且这个feel还说

07:26.600 --> 07:27.600
它会返回当前的数组

07:27.600 --> 07:28.600
就这个玩意

07:28.600 --> 07:30.600
这个表达仍然是一个数组

07:30.600 --> 07:31.600
就是AR

07:31.600 --> 07:32.600
你要的意思

07:32.600 --> 07:33.600
做填充的

07:34.600 --> 07:35.600
好

07:35.600 --> 07:36.600
我们以后再做练习

07:36.600 --> 07:37.600
快速的过一遍

07:37.600 --> 07:38.600
然后for each

07:38.600 --> 07:40.600
for each是在做什么事

07:40.600 --> 07:41.600
for each来做什么事

07:41.600 --> 07:42.600
就是在遍地的

07:42.600 --> 07:43.600
遍地数组的

07:43.600 --> 07:46.600
我们除了可以用for4循环

07:46.600 --> 07:47.600
除了可以用for4循环

07:47.600 --> 07:49.600
可以用for5循环之外

07:49.600 --> 07:50.600
还可以通过for each

07:50.600 --> 07:51.600
遍地数组

07:51.600 --> 07:52.600
那么我们来看一下

07:52.600 --> 07:53.600
它里面传的是一个fn

07:53.600 --> 07:54.600
fn是什么

07:54.600 --> 07:55.600
函数

07:55.600 --> 07:56.600
你看一下咱们这个图例

07:56.600 --> 07:58.600
数组里面每一项有东西

07:58.600 --> 07:59.600
然后通过for each函数

07:59.600 --> 08:00.600
可以把一项一项的拿出来

08:00.600 --> 08:01.600
遍地

08:02.600 --> 08:03.600
现在我们遍地方式

08:03.600 --> 08:04.600
有各种各样的

08:04.600 --> 08:05.600
有很多的方式可以遍地

08:05.600 --> 08:06.600
我这里随便找个介绍

08:06.600 --> 08:07.600
你来写

08:08.600 --> 08:09.600
比方说

08:09.600 --> 08:11.600
我这里呢就举个例子

08:12.600 --> 08:14.600
我写这么一个数组

08:14.600 --> 08:17.040
当然是数字

08:17.040 --> 08:19.040
当然对象那些也无所谓

08:20.040 --> 08:21.040
都行

08:21.040 --> 08:22.040
然后我们要遍地

08:22.040 --> 08:24.040
它是不是可以用for5循环

08:24.040 --> 08:25.040
你可以在这里

08:25.040 --> 08:27.040
在vscode里面打上for5

08:27.040 --> 08:28.040
按下type键

08:28.040 --> 08:30.040
它就跟你生存这个代码了

08:30.040 --> 08:32.040
那么这个每一项的循环的名字

08:32.040 --> 08:33.040
随便写一个

08:34.040 --> 08:35.040
然后每循环什么

08:35.040 --> 08:36.040
循环ARR

08:37.040 --> 08:38.040
每次循环干嘛

08:38.040 --> 08:39.040
我是你输出item

08:41.540 --> 08:42.540
是不是一项像循环出来

08:42.540 --> 08:43.540
这是一种遍地方式

08:43.540 --> 08:44.540
除了这种方式之外

08:44.540 --> 08:46.540
我们还可以利用数组里面的圆形方法

08:46.540 --> 08:47.540
叫for each

08:47.540 --> 08:48.540
这里边传什么呢

08:48.540 --> 08:49.540
传一个函数

08:50.540 --> 08:52.540
这个函数有一个参数

08:54.920 --> 08:55.920
输出一下

08:55.920 --> 08:56.920
我们先看效果

08:56.920 --> 08:57.920
运行

08:57.920 --> 08:58.920
这样可以遍地

08:58.920 --> 08:59.920
一项一项拿出来

08:59.920 --> 09:00.920
那么到底是怎么回算

09:00.920 --> 09:01.920
还是这样子

09:01.920 --> 09:03.920
你在用对数组进行遍地

09:03.920 --> 09:04.920
遍地的时候

09:04.920 --> 09:05.920
它就会一项一项拿出来

09:05.920 --> 09:07.920
第一项拿出来

09:07.920 --> 09:09.920
雕用这个函数

09:09.920 --> 09:11.920
把它作为参数传给item

09:11.920 --> 09:12.920
然后你运行的函数

09:12.920 --> 09:13.920
运行一遍

09:14.920 --> 09:15.920
第二项拿出来

09:15.920 --> 09:17.920
把这个玩意儿

09:17.920 --> 09:19.920
雕用函数传给函数

09:19.920 --> 09:21.920
然后再把函数运行一遍

09:21.920 --> 09:22.920
然后再来

09:22.920 --> 09:23.920
把这一项拿出来

09:23.920 --> 09:24.920
雕用函数

09:24.920 --> 09:25.920
把这一项运行一遍

09:25.920 --> 09:26.920
对吧

09:26.920 --> 09:27.920
最后就一项一项数出来了

09:28.920 --> 09:29.920
本质跟这个本质

09:30.920 --> 09:31.920
没差区别的

09:31.920 --> 09:32.920
都是遍地

09:32.920 --> 09:33.920
然后这个函数

09:33.920 --> 09:34.920
其实还可以写

09:34.920 --> 09:35.920
第二个函数和第三个函数

09:35.920 --> 09:37.920
第二个函数是下标

09:38.920 --> 09:40.920
第三个参数是数主本身

09:40.920 --> 09:41.920
如果说你需要的话

09:41.920 --> 09:43.920
你就写这个参数

09:43.920 --> 09:44.920
不需要的话就拿着

09:45.920 --> 09:46.920
你看一下

09:47.920 --> 09:48.920
第一项

09:48.920 --> 09:49.920
第一次运行函数45

09:49.920 --> 09:50.920
对吧

09:50.920 --> 09:51.920
把45传进来了

09:51.920 --> 09:52.920
下标是0

09:52.920 --> 09:53.920
然后数主本身

09:53.920 --> 09:54.920
那一直没变

09:54.920 --> 09:55.920
第二项

09:55.920 --> 09:56.920
数字直式期

09:56.920 --> 09:58.920
下标为1

09:58.920 --> 09:59.920
然后这个拿过来

09:59.920 --> 10:00.920
然后这个名字

10:00.920 --> 10:02.920
有同学程序学懵了

10:02.920 --> 10:03.920
老是这里写的是item

10:03.920 --> 10:05.920
所以说以后一定要写item

10:06.920 --> 10:08.920
这只是个行参名字

10:08.920 --> 10:09.920
随便写

10:09.920 --> 10:10.920
它可以传递过来

10:10.920 --> 10:11.920
它只是把纸

10:11.920 --> 10:12.920
可以传递过来

10:12.920 --> 10:13.920
想咋写

10:15.920 --> 10:16.920
不要学懵了

10:19.550 --> 10:21.550
然后这里是for一起

10:21.550 --> 10:22.550
用来辨历的

10:22.550 --> 10:23.550
还有一个就是map

10:23.550 --> 10:25.550
map是来做映射的

10:25.550 --> 10:26.550
这个函数挺有意思

10:26.550 --> 10:28.550
而且用的非常非常广泛

10:28.550 --> 10:29.550
它是可以把一个数主

10:29.550 --> 10:31.550
把每一项映射成为一个新的东西

10:31.550 --> 10:33.550
这里有个图示

10:33.550 --> 10:34.550
你看我这里把一个圆

10:34.550 --> 10:36.550
加上两一横一数

10:36.550 --> 10:37.550
映射出来

10:37.550 --> 10:38.550
变成这个样子

10:38.550 --> 10:39.550
把三角也加上一横一数

10:39.550 --> 10:42.550
按照同一种规则来进行映射

10:42.550 --> 10:44.550
把一个数主变成一个新的数主

10:44.550 --> 10:46.550
它不会改动圆数主的

10:46.550 --> 10:48.550
你后边很多方法

10:48.550 --> 10:50.550
后边我看一下哪有

10:50.550 --> 10:52.550
这些后边就是圆形方法

10:52.550 --> 10:53.550
除了废有之外

10:53.550 --> 10:54.550
for一起map

10:54.550 --> 10:55.550
这些后边的所有方法

10:55.550 --> 10:57.550
它都不会改变圆内的数主

10:57.550 --> 10:59.550
它会返回一个新的数主

10:59.550 --> 11:00.550
叫map

11:00.550 --> 11:01.550
咱们来举个例子

11:01.550 --> 11:03.550
比方说我这里有一个数主

11:03.550 --> 11:06.550
我想把数主里面的每一项翻背

11:06.550 --> 11:07.550
对吧

11:07.550 --> 11:08.550
然后怎么办呢

11:08.550 --> 11:09.550
我就可以使用ARMap

11:09.550 --> 11:10.550
这里边传一个函数

11:10.550 --> 11:12.550
这里写的是fn

11:12.550 --> 11:13.550
传一个函数

11:13.550 --> 11:14.550
那么这个函数的格式

11:14.550 --> 11:16.550
跟for一起全部完全一样

11:16.550 --> 11:17.550
第一项是我们数主的每一项

11:17.550 --> 11:18.550
第二项是数主的价格

11:18.550 --> 11:20.550
第三个是整个数主本身

11:20.550 --> 11:22.550
那你要用多少就写多少

11:22.550 --> 11:23.550
我要方个写

11:23.550 --> 11:25.550
我把数主的每一项拿到

11:25.550 --> 11:26.550
然后我返回

11:26.550 --> 11:27.550
这里需要返回

11:27.550 --> 11:29.550
返回一个item成译2

11:29.550 --> 11:30.550
我们来看一下

11:30.550 --> 11:32.550
它就会返回一个新的数主

11:32.550 --> 11:33.550
我们来接受一下

11:33.550 --> 11:35.550
远数主不会变化的

11:35.550 --> 11:38.550
数数6AR2

11:38.550 --> 11:40.550
数数每一项翻背了

11:40.550 --> 11:42.550
看一下是不是翻背了

11:42.550 --> 11:44.550
那到底是怎么回算呢

11:44.550 --> 11:45.550
咱们来看一下

11:45.550 --> 11:47.550
它整个map就是映射

11:47.550 --> 11:50.550
你看45是不是被映射成90

11:50.550 --> 11:52.550
7是不是被映射成14

11:52.550 --> 11:54.550
2是不是被映射成4

11:54.550 --> 11:55.550
对吧

11:55.550 --> 11:56.550
它就是在做映射的

11:56.550 --> 11:57.550
它具体怎么映射的呢

11:57.550 --> 11:59.550
它首先把第一项拿出来

11:59.550 --> 12:00.550
调用这个函数

12:00.550 --> 12:01.550
传到item里面去

12:01.550 --> 12:03.550
它把你返回的结果

12:03.550 --> 12:05.550
作为新数主的第一项

12:05.550 --> 12:07.550
90

12:07.550 --> 12:10.550
然后再把7传进来

12:10.550 --> 12:12.550
把返回了7乘124

12:12.550 --> 12:13.550
把返回的结果

12:13.550 --> 12:15.550
作为新数主的第二项

12:15.550 --> 12:17.550
是不是就一项一项映射过来了

12:17.550 --> 12:18.550
那么你写的这个函数

12:18.550 --> 12:19.550
就是映射的关系

12:19.550 --> 12:20.550
你给我什么

12:20.550 --> 12:22.550
我给你什么

12:22.550 --> 12:23.550
我决定了

12:23.550 --> 12:24.550
这里映射可以玩出

12:24.550 --> 12:25.550
很多种花样

12:25.550 --> 12:26.550
那如果说

12:26.550 --> 12:27.550
这里返回的是新的数字

12:27.550 --> 12:28.550
那我返回一个对象

12:28.550 --> 12:29.550
可以吗

12:29.550 --> 12:30.550
可以啊

12:30.550 --> 12:31.550
我给你返回一个item

12:31.550 --> 12:33.550
double n

12:33.550 --> 12:35.550
我给你返回一个item乘1

12:35.550 --> 12:36.550
我随便下写

12:36.550 --> 12:37.550
你返回

12:37.550 --> 12:38.550
你看得到的数主

12:38.550 --> 12:40.550
就是个对象数主了

12:40.550 --> 12:41.550
非常好用

12:41.550 --> 12:43.550
它把45传进来

12:43.550 --> 12:44.550
然后返回的是什么呢

12:44.550 --> 12:46.550
返回的是一个对象

12:46.550 --> 12:47.550
对象的n

12:47.550 --> 12:48.550
是不是item本身

12:48.550 --> 12:49.550
你看第一项

12:49.550 --> 12:50.550
nitem本身

12:50.550 --> 12:52.550
第二项double n

12:52.550 --> 12:54.550
是不是item乘1294

12:54.550 --> 12:55.550
返回的是一个对象

12:55.550 --> 12:57.550
那么作为新数主的第一项

12:57.550 --> 12:58.550
然后第二项

12:58.550 --> 12:59.550
重复这个过程

12:59.550 --> 13:00.550
7拿过来

13:00.550 --> 13:01.550
那么返回的是什么呢

13:01.550 --> 13:02.550
返回的是一个新的对象

13:02.550 --> 13:03.550
看呗

13:03.550 --> 13:05.550
n的值等于7

13:05.550 --> 13:06.550
然后double n

13:06.550 --> 13:08.550
等于7乘124

13:08.550 --> 13:10.550
一项一项进行映射

13:10.550 --> 13:11.550
这个传进来的

13:11.550 --> 13:12.550
就是映射关系

13:12.550 --> 13:13.550
它给我什么

13:13.550 --> 13:14.550
把原来的数主

13:14.550 --> 13:15.550
每一项给我

13:15.550 --> 13:16.550
我给你返回一个

13:16.550 --> 13:18.550
对应的另外一项

13:18.550 --> 13:20.550
那就是映射

13:20.550 --> 13:21.550
映射很有用的

13:21.550 --> 13:22.550
我们后边会决

13:22.550 --> 13:23.550
很多很多的避子

13:23.550 --> 13:24.550
所以说映射

13:24.550 --> 13:25.550
好 接下来

13:25.550 --> 13:26.550
下面这个filter

13:27.550 --> 13:28.550
里面都是传寒书

13:28.550 --> 13:29.550
你看这边都是传寒书

13:29.550 --> 13:31.550
filter是做筛选

13:31.550 --> 13:32.550
比方说我们这里

13:32.550 --> 13:33.550
在这里这些吧

13:33.550 --> 13:35.550
我要保留所有的激素

13:35.550 --> 13:36.550
我不要偶数

13:36.550 --> 13:37.550
我只要激素

13:37.550 --> 13:38.550
怎么办呢

13:38.550 --> 13:40.550
filter做筛选的

13:40.550 --> 13:41.550
你看这个图

13:41.550 --> 13:43.550
filter它映射的关系

13:43.550 --> 13:44.550
原来的数主有几项

13:44.550 --> 13:45.550
新的数主就有几项

13:45.550 --> 13:46.550
一项一项映射过来

13:46.550 --> 13:47.550
filter就不一样了

13:47.550 --> 13:49.550
原来的数主有多少项

13:49.550 --> 13:51.550
新的数主可能要少一些

13:51.550 --> 13:53.550
有些东西被筛选交了

13:54.550 --> 13:57.550
好 那么filter

13:57.550 --> 13:59.550
我们这里边传一个寒数

13:59.550 --> 14:00.550
还是一样

14:00.550 --> 14:01.550
格式还是一样

14:01.550 --> 14:02.550
有三个参数

14:02.550 --> 14:03.550
我们只需要用一个

14:03.550 --> 14:05.550
它把每一项传过来

14:05.550 --> 14:07.550
我要判断它是不是激素

14:07.550 --> 14:08.550
返回true就保留

14:08.550 --> 14:10.550
返回force就去掉

14:10.550 --> 14:11.550
仍然一样

14:11.550 --> 14:12.550
它不会改变原数主

14:12.550 --> 14:17.590
它会返回一个新的数主

14:17.590 --> 14:19.590
我们数数就A2

14:19.590 --> 14:20.590
那么返回是吧

14:20.590 --> 14:22.590
比方说我返回一个true

14:22.590 --> 14:24.590
那就所有项全部要保留

14:24.590 --> 14:26.590
每一项都返回的是true

14:26.590 --> 14:27.590
你甭管给我什么

14:27.590 --> 14:28.590
我都返回true

14:28.590 --> 14:29.590
我就每一项都保留

14:29.590 --> 14:31.590
返回得到的新数主跟原数主有一样

14:31.590 --> 14:32.590
完全一样

14:32.590 --> 14:34.590
那如果说我返回force的话

14:34.590 --> 14:35.590
那么每一项都不保留

14:35.590 --> 14:36.590
不保留的话

14:36.590 --> 14:38.590
新数主就一项都没有

14:38.590 --> 14:39.590
那么到底要不要保留

14:39.590 --> 14:40.590
那我们一般来说

14:40.590 --> 14:42.590
要根据这一项来决定

14:42.590 --> 14:43.590
比方说我刚才的例子

14:43.590 --> 14:45.590
就是说我只保留激素

14:45.590 --> 14:46.590
那么什么叫激素呢

14:46.590 --> 14:48.590
Item除一二的余书不为零

14:48.590 --> 14:50.590
这个条件满足

14:50.590 --> 14:52.590
这个条件为true

14:52.590 --> 14:53.590
是不是就是激素

14:53.590 --> 14:55.590
所以说我到底返回true还是force

14:55.590 --> 14:57.590
是根据这一项的指示来决定的

14:57.590 --> 14:59.590
那么这样子我就可以保留所谓的激素了

14:59.590 --> 15:01.590
写法极其的灵活

15:01.590 --> 15:03.590
你只需要最终结果就是返回true

15:03.590 --> 15:04.590
还是返回force

15:04.590 --> 15:06.590
true那么这一项就保留

15:06.590 --> 15:08.590
force这一项就不保留

15:08.590 --> 15:09.590
有些人从这个代码看不懂

15:09.590 --> 15:11.590
他的目的就这样写

15:11.590 --> 15:13.590
除一二不等于零

15:13.590 --> 15:14.590
是不是激素

15:14.590 --> 15:16.590
那一返回true

15:16.590 --> 15:18.590
l是不是激素返回force

15:18.590 --> 15:20.590
那这个代码应该能看懂的

15:20.590 --> 15:22.590
效果是完全一样的

15:22.590 --> 15:23.590
不简洁

15:23.590 --> 15:24.590
为什么呢

15:24.590 --> 15:26.590
因为true返回true

15:26.590 --> 15:28.590
true force返回force

15:28.590 --> 15:30.590
那你直接把它返回不完了吗

15:30.590 --> 15:33.590
都是future

15:33.590 --> 15:35.590
下一个reduce

15:35.590 --> 15:37.590
这个还说稍险有点复杂

15:37.590 --> 15:38.590
它叫做聚合

15:38.590 --> 15:40.590
它是把素书里面所有东西

15:40.590 --> 15:42.590
全部揉在一起聚合成一

15:42.590 --> 15:44.590
一个东西

15:44.590 --> 15:46.590
那么常见的情况是什么

15:46.590 --> 15:47.590
就求和

15:47.590 --> 15:49.590
把素书里面所有东西拿出来求和

15:49.590 --> 15:50.590
咱们来看一下吧

15:51.590 --> 15:52.590
以前求和

15:52.590 --> 15:53.590
我们要去循环

15:53.590 --> 15:55.590
它一项一项用个便量一个个去加

15:55.590 --> 15:56.590
现在不用了

15:56.590 --> 15:57.590
直接使用reduce

15:57.590 --> 15:59.590
但reduce它不仅仅是可以求和

15:59.590 --> 16:00.590
凡是

16:00.590 --> 16:01.590
以后把它变成这种形式

16:01.590 --> 16:02.590
就是很多项

16:02.590 --> 16:03.590
把它揉成一项

16:03.590 --> 16:05.590
按照某一种规则把它揉成一项

16:05.590 --> 16:06.590
那就可以用reduce

16:06.590 --> 16:08.590
它有两个参数

16:08.590 --> 16:09.590
第一个参数传一个函数

16:09.590 --> 16:11.590
函数有两个参数

16:11.590 --> 16:12.590
a和b

16:12.590 --> 16:13.590
当一个名字里随便去

16:13.590 --> 16:15.590
第二个参数来传一个默认值

16:15.590 --> 16:16.590
我们传一个0

16:16.590 --> 16:18.590
我先把代码写完

16:18.590 --> 16:20.590
让大家给大家给大家解释

16:20.590 --> 16:22.590
求和求完了

16:24.590 --> 16:25.590
119

16:25.590 --> 16:26.590
那么它到底是怎么运行的

16:26.590 --> 16:28.590
那我给大家解释一下

16:28.590 --> 16:30.590
这个reduce函数是这么运行的

16:30.590 --> 16:31.590
它在内部

16:31.590 --> 16:32.590
它首先给你开一个空间

16:32.590 --> 16:34.590
比方说我介绍一下

16:34.590 --> 16:35.590
维绕着吧

16:35.590 --> 16:36.590
结果

16:36.590 --> 16:37.590
这个结果一开始为你

16:37.590 --> 16:38.590
这个是第二个参数

16:38.590 --> 16:40.590
第一个参数是一个函数

16:40.590 --> 16:41.590
第二个参数

16:41.590 --> 16:44.590
它最终结果先把它设置为

16:44.590 --> 16:45.590
第二个参数

16:45.590 --> 16:46.590
就是设置为一个默认值

16:46.590 --> 16:47.590
就你给它传的什么

16:47.590 --> 16:49.590
它就设置什么

16:49.590 --> 16:51.590
然后接下来开始调用了

16:51.590 --> 16:53.590
它首先做这么一件事

16:53.590 --> 16:57.590
它把这个结果放给a

16:57.590 --> 17:00.590
然后把它第一项给b

17:00.590 --> 17:02.590
就是a始终是目前的结果

17:02.590 --> 17:03.590
当前的结果

17:03.590 --> 17:04.590
当前结果是0

17:04.590 --> 17:05.590
对吧

17:05.590 --> 17:06.590
然后呢

17:06.590 --> 17:08.590
把45给b

17:08.590 --> 17:09.590
然后再返回什么呢

17:09.590 --> 17:10.590
返回a加b

17:10.590 --> 17:11.590
a加b是多少

17:11.590 --> 17:12.590
45

17:12.590 --> 17:13.590
于是呢

17:13.590 --> 17:14.590
它就把结果更新

17:14.590 --> 17:15.590
更新为45

17:15.590 --> 17:16.590
好

17:16.590 --> 17:17.590
接下来下一步

17:17.590 --> 17:20.590
又把这个45从右传给a

17:20.590 --> 17:21.590
然后呢

17:21.590 --> 17:23.590
把第二项传给b

17:23.590 --> 17:24.590
返回多少

17:24.590 --> 17:26.590
45加7

17:26.590 --> 17:27.590
是不是52

17:27.590 --> 17:29.590
然后把结果更新

17:29.590 --> 17:30.590
52

17:30.590 --> 17:31.590
你看没有

17:31.590 --> 17:32.590
那个a这个参数

17:32.590 --> 17:34.590
就是目前汇总的结果

17:34.590 --> 17:35.590
然后52给a

17:35.590 --> 17:36.590
然后呢

17:36.590 --> 17:37.590
2给b

17:39.590 --> 17:40.590
返回什么

17:40.590 --> 17:41.590
52加2

17:41.590 --> 17:42.590
是54

17:42.590 --> 17:43.590
你看这样子最终结果

17:43.590 --> 17:44.590
是不是球合

17:44.590 --> 17:45.590
对吧

17:45.590 --> 17:46.590
然后呢

17:46.590 --> 17:47.590
比方说最后

17:47.590 --> 17:48.590
最后就是

17:48.590 --> 17:49.590
刚才结果是

17:49.590 --> 17:50.590
最后呢

17:50.590 --> 17:51.590
116了

17:51.590 --> 17:52.590
到116了

17:52.590 --> 17:53.590
就最后了啊

17:53.590 --> 17:54.590
然后呢

17:54.590 --> 17:55.590
又把一个116给谁

17:55.590 --> 17:56.590
给a

17:56.590 --> 17:57.590
最后一个给3

17:57.590 --> 17:58.590
给b

17:58.590 --> 17:59.590
然后返回116

17:59.590 --> 18:00.590
加3

18:00.590 --> 18:01.590
是119

18:01.590 --> 18:02.590
好

18:02.590 --> 18:03.590
然后发现呢

18:03.590 --> 18:04.590
是个数损循环了

18:04.590 --> 18:05.590
没了

18:05.590 --> 18:06.590
没了过后

18:06.590 --> 18:07.590
这个最终的结果

18:07.590 --> 18:08.590
就是把作为一个

18:08.590 --> 18:09.590
函数结果返回

18:09.590 --> 18:10.590
这是reduce

18:10.590 --> 18:12.590
它能用来去做聚合的

18:12.590 --> 18:15.280
好

18:15.280 --> 18:16.280
再下一个

18:16.280 --> 18:17.280
上

18:17.280 --> 18:18.280
它判断一个数损中

18:18.280 --> 18:19.280
是不是至少有

18:19.280 --> 18:21.280
一项通过函数的测试

18:21.280 --> 18:22.280
这里表传函数的啊

18:22.280 --> 18:23.280
什么意思

18:23.280 --> 18:24.280
比方说这里有一个数损

18:24.280 --> 18:25.280
我要做测试一下

18:25.280 --> 18:26.280
看这个数损里边

18:26.280 --> 18:27.280
有没有

18:27.280 --> 18:28.280
三边

18:28.280 --> 18:29.280
就是包含

18:29.280 --> 18:30.280
至少包含三条边的

18:30.280 --> 18:31.280
三条边

18:31.280 --> 18:32.280
大约等于三条边的

18:32.280 --> 18:33.280
有没有

18:33.280 --> 18:34.280
只要有一项就行

18:34.280 --> 18:35.280
然后返回就是去

18:35.280 --> 18:36.280
那么还有一个

18:36.280 --> 18:37.280
Avery是对应的

18:37.280 --> 18:38.280
Avery呢

18:38.280 --> 18:39.280
它的用法就完全

18:39.280 --> 18:40.280
协法都完全一样

18:40.280 --> 18:41.280
就是个名字变一下

18:41.280 --> 18:42.280
那么它什么意思呢

18:42.280 --> 18:44.280
它就是要保证数损

18:44.280 --> 18:45.280
每一项都满足条件

18:45.280 --> 18:46.280
比方说这里

18:46.280 --> 18:47.280
至少有三边

18:47.280 --> 18:48.280
但是原本没有三边

18:48.280 --> 18:50.280
这个形状没有三条边

18:50.280 --> 18:52.280
所以它就返回Force

18:52.280 --> 18:53.280
虽然这三项符合

18:53.280 --> 18:54.280
但是有两项不符合

18:54.280 --> 18:55.280
那也不行

18:55.280 --> 18:56.280
必须要每一项都符合

18:56.280 --> 18:57.280
叫Avery

18:57.280 --> 18:58.280
没了意思吧

18:58.280 --> 18:59.280
它返回的是True和Force

18:59.280 --> 19:00.280
好

19:00.280 --> 19:01.280
既然比方举个例子

19:01.280 --> 19:02.280
我来看一下

19:02.280 --> 19:03.280
这个数损里边

19:03.280 --> 19:04.280
有没有

19:05.280 --> 19:06.280
叫做上

19:07.280 --> 19:08.280
这个数损里边

19:08.280 --> 19:09.280
有没有

19:09.280 --> 19:11.280
大约六十的数呢

19:11.280 --> 19:12.280
有没有呢

19:13.280 --> 19:14.280
我们怎么来判断

19:14.280 --> 19:15.280
返回的什么呢

19:15.280 --> 19:17.280
返回的就是True和Force

19:17.280 --> 19:20.280
到底对每一项进行测试

19:20.280 --> 19:22.280
看这一项有没有通过测试

19:22.280 --> 19:23.280
那么通过就返回去

19:23.280 --> 19:25.280
没有通过就返回Force

19:25.280 --> 19:26.280
那我们的测试条件是什么

19:26.280 --> 19:28.280
是不是大约等于六十

19:28.280 --> 19:29.280
对吧

19:29.280 --> 19:30.280
看一项

19:30.280 --> 19:32.280
有没有一项大约等于六十

19:32.280 --> 19:33.280
就是上这么多

19:33.280 --> 19:34.280
还有Ridals

19:34.280 --> 19:35.280
我们来输出一项Ridals

19:35.280 --> 19:37.280
它返回的是True和Force

19:39.280 --> 19:40.280
Force

19:40.280 --> 19:41.280
一项都没有

19:42.280 --> 19:44.280
只要有一项都是True

19:44.280 --> 19:45.280
那比如说我这里

19:45.280 --> 19:47.280
是不是有一项大约五十呢

19:47.280 --> 19:48.280
运行

19:48.280 --> 19:49.280
True

19:49.280 --> 19:51.280
这一项大约五十

19:51.280 --> 19:52.280
就是上

19:52.280 --> 19:53.280
上什么意思

19:53.280 --> 19:54.280
有一些就行

19:54.280 --> 19:55.280
有一个就行

19:56.280 --> 19:57.280
然后还有一个就是Avery

19:57.280 --> 19:59.280
Avery必须要保证

19:59.280 --> 20:01.280
每一项都要满足这个条件

20:01.280 --> 20:02.280
那么这里呢

20:02.280 --> 20:03.280
True还是Force

20:03.280 --> 20:04.280
现在才有

20:05.280 --> 20:06.280
Force

20:06.280 --> 20:07.280
很多项都不满足

20:07.280 --> 20:08.280
必须要保证

20:08.280 --> 20:10.280
每一项都满足

20:10.280 --> 20:11.280
如果说我这里写的是

20:11.280 --> 20:12.280
小鱼等

20:12.280 --> 20:13.280
小鱼六十呢

20:13.280 --> 20:14.280
满满的条件

20:14.280 --> 20:16.280
然后发现每一项都满足

20:16.280 --> 20:17.280
那就True

20:17.280 --> 20:18.280
对吧

20:18.280 --> 20:19.280
就这么简单

20:25.410 --> 20:28.410
这是Sum和Avery

20:29.410 --> 20:30.410
然后下面这个Fand

20:31.410 --> 20:32.410
Fand这个函数

20:32.410 --> 20:34.410
就是跟Sum

20:34.410 --> 20:36.410
跟Sum函数其实差不多

20:36.410 --> 20:38.410
它只要有一项满足就行

20:38.410 --> 20:40.410
但是它返回都不一样

20:40.410 --> 20:41.410
Sum是返回True和Force

20:41.410 --> 20:42.410
有没有

20:42.410 --> 20:44.410
Fand是把能找到了第1项

20:44.410 --> 20:46.410
把那个内项返回

20:47.410 --> 20:49.410
比方说我这里能用Fand

20:57.110 --> 20:58.110
还是一样

20:58.110 --> 20:59.110
找一下有没有

20:59.110 --> 21:00.110
大鱼等于50的

21:00.110 --> 21:01.110
你看邪法都有完全一样

21:01.110 --> 21:03.110
大鱼等于50的

21:03.110 --> 21:04.110
有没有

21:04.110 --> 21:06.110
有的话你把找到了内项返回

21:06.110 --> 21:08.110
它返回的不是True和Force

21:10.110 --> 21:11.110
是不是57

21:11.110 --> 21:12.110
就这一项是满足条件的

21:12.110 --> 21:13.110
对吧

21:13.110 --> 21:14.110
那么后边如果说

21:14.110 --> 21:15.110
还有一个53

21:15.110 --> 21:16.110
那么53会不会返回

21:16.110 --> 21:17.110
它不会

21:17.110 --> 21:18.110
它只会返回找到的第1项

21:18.110 --> 21:19.110
那有人说

21:19.110 --> 21:21.110
我要记返回53和57呢

21:21.110 --> 21:23.110
两个都要返回呢

21:26.000 --> 21:27.000
Future

21:27.000 --> 21:28.000
甩选别

21:28.000 --> 21:29.000
对吧

21:29.000 --> 21:30.000
满足条件的保留

21:30.000 --> 21:31.000
不满足条件的区别

21:33.000 --> 21:34.000
好 下一个

21:34.000 --> 21:36.000
includes

21:36.000 --> 21:37.000
这个呢

21:37.000 --> 21:38.000
它传到就不是函数了

21:38.000 --> 21:40.000
传到是某一项

21:40.000 --> 21:42.000
它就是判断

21:42.000 --> 21:43.000
这一项

21:43.000 --> 21:44.000
是不是那个

21:44.000 --> 21:46.000
在数组中存占

21:46.000 --> 21:47.000
好

21:47.000 --> 21:48.000
我们这里再看一下

21:49.000 --> 21:50.000
看一下这一项

21:50.000 --> 21:51.000
是不是在数组中存占

21:51.000 --> 21:52.000
比方说我们很简单

21:52.000 --> 21:53.000
我看一下数组里面

21:53.000 --> 21:54.000
是不是包含

21:54.000 --> 21:56.000
数组里面是不是包含2

21:58.000 --> 21:59.000
includes

21:59.000 --> 22:00.000
2传进去

22:00.000 --> 22:01.000
全就这么简单

22:01.000 --> 22:04.760
输出一下Retro

22:04.760 --> 22:05.760
True

22:05.760 --> 22:06.760
对吧

22:06.760 --> 22:07.760
包含2

22:07.760 --> 22:08.760
如果说包含22

22:08.760 --> 22:09.760
Force

22:09.760 --> 22:10.760
它不包含

22:10.760 --> 22:12.760
它返回的是True和Force

22:12.760 --> 22:13.760
所以它比较的时候

22:13.760 --> 22:14.760
它怎么看到

22:14.760 --> 22:15.760
判断数组里面

22:15.760 --> 22:16.760
有没有这一项

22:16.760 --> 22:17.760
它是一项一项比较的

22:17.760 --> 22:18.760
它比较的方式

22:18.760 --> 22:19.760
是用Objects的意思

22:19.760 --> 22:20.760
那么这个

22:20.760 --> 22:21.760
这个函数大家没有学过

22:21.760 --> 22:22.760
给大家简单说一下

22:22.760 --> 22:23.760
这个Objects的意思

22:23.760 --> 22:24.760
你可以把它理解为

22:24.760 --> 22:25.760
三个等号

22:26.760 --> 22:27.760
Objects

22:27.760 --> 22:28.760
意思

22:28.760 --> 22:29.760
然后1

22:29.760 --> 22:30.760
所以相当的

22:30.760 --> 22:31.760
但是1和致不出来

22:31.760 --> 22:32.760
1是不是不相等

22:32.760 --> 22:33.760
对吧

22:33.760 --> 22:34.760
你可以把简单的理解

22:34.760 --> 22:35.760
为三个等号

22:35.760 --> 22:36.760
这是一个函数的方式

22:36.760 --> 22:37.760
来判断

22:37.760 --> 22:38.760
那么跟着1

22:38.760 --> 22:39.760
这种方式

22:39.760 --> 22:40.760
是不一样的

22:40.760 --> 22:42.760
Objects的意思

22:42.760 --> 22:43.760
当然呢

22:43.760 --> 22:44.760
你看一下这个代码

22:45.760 --> 22:47.760
返回True还是Force

22:47.760 --> 22:48.760
两个对象

22:50.760 --> 22:51.760
这基本功

22:51.760 --> 22:52.760
非常基本的

22:52.760 --> 22:53.760
返回Force

22:53.760 --> 22:54.760
为什么

22:54.760 --> 22:55.760
因为两个对象

22:55.760 --> 22:56.760
是地址是不一样的

22:57.760 --> 22:58.760
对象

22:58.760 --> 22:59.760
数组

22:59.760 --> 23:00.760
你只要看到大国号

23:00.760 --> 23:01.760
一定是新的

23:01.760 --> 23:02.760
一个新的对象

23:02.760 --> 23:03.760
一个新的对象

23:03.760 --> 23:04.760
一个新的对象

23:04.760 --> 23:05.760
两个新的对象

23:05.760 --> 23:06.760
跟他们的地址

23:06.760 --> 23:07.760
肯定不一样

23:07.760 --> 23:08.760
那么同样的

23:08.760 --> 23:09.760
数组也是一样

23:09.760 --> 23:10.760
一个新的数组

23:10.760 --> 23:11.760
一个新的数组

23:11.760 --> 23:12.760
在数组本质上

23:12.760 --> 23:13.760
也是对象

23:13.760 --> 23:14.760
所以两个是不一样的

23:15.760 --> 23:16.760
Includes

23:16.760 --> 23:17.760
好了

23:17.760 --> 23:18.760
那么这些API就讲完了

23:18.760 --> 23:19.760
快速的过了一遍

23:19.760 --> 23:20.760
对吧

23:20.760 --> 23:22.760
有那么一丁点印象了

23:22.760 --> 23:23.760
然后接下来

23:23.760 --> 23:24.760
我们在练习中

23:24.760 --> 23:25.760
不断的去想法

23:25.760 --> 23:26.760
第一道题

23:29.710 --> 23:30.710
这里有很多按钮

23:30.710 --> 23:32.710
让你用forO5循环

23:32.710 --> 23:34.710
便利所有的按钮

23:34.710 --> 23:36.710
为其注册点击事件

23:36.710 --> 23:37.710
点击的时候

23:37.710 --> 23:38.710
就输出内容就行了

23:38.710 --> 23:39.710
不要点地的按钮

23:39.710 --> 23:40.710
就输出按钮

23:40.710 --> 23:42.710
输出它的文本内容就行了

23:43.710 --> 23:44.710
大家做一下

23:45.710 --> 23:46.710
好了没

23:46.710 --> 23:48.710
不知道你们怎么写的

23:48.710 --> 23:49.710
我这里给他写一遍

23:49.710 --> 23:50.710
但这个答案不是唯一的

23:50.710 --> 23:52.710
利用传统的forO5循环

23:52.710 --> 23:53.710
也可以做

23:53.710 --> 23:54.710
我们有forO5循环

23:54.710 --> 23:56.710
那么这里首先用document

23:58.710 --> 24:00.710
拿到所有的按钮

24:00.710 --> 24:01.710
拿到是不是一个伪术

24:01.710 --> 24:02.710
对吧

24:02.710 --> 24:04.710
然后用forO5循环去循环他

24:04.710 --> 24:05.710
循环每一项就是个按钮

24:05.710 --> 24:07.710
你随便用个辩量接受一下

24:07.710 --> 24:08.710
那么循环谁呢

24:08.710 --> 24:09.710
循环BTS

24:09.710 --> 24:10.710
对吧

24:10.710 --> 24:11.710
把这里

24:11.710 --> 24:12.710
这个按钮中每一项拿出来

24:12.710 --> 24:13.710
放给他

24:13.710 --> 24:14.710
那么就进行循环

24:14.710 --> 24:15.710
每一项呢

24:15.710 --> 24:16.710
我就给他注册点击事件

24:16.710 --> 24:17.710
点击的时候干嘛

24:18.710 --> 24:20.710
我就输出

24:20.710 --> 24:22.710
按钮的那个

24:22.710 --> 24:24.710
文本

24:24.710 --> 24:25.710
inner text

24:25.710 --> 24:26.710
当然你可以用list

24:26.710 --> 24:27.710
inner text

24:27.710 --> 24:28.710
也是可以的

24:37.680 --> 24:38.680
看一下啊

24:38.680 --> 24:39.680
按钮1 按钮2 按钮3

24:39.680 --> 24:40.680
就随便点

24:40.680 --> 24:41.680
是不是没问题了

24:42.680 --> 24:43.680
就这个题

24:43.680 --> 24:44.680
非常简单吧

24:44.680 --> 24:45.680
练习一下forO5循环

24:46.680 --> 24:47.680
然后像一个

24:48.680 --> 24:49.680
我不应该把

24:49.680 --> 24:50.680
我不应该把题写到这儿啊

24:50.680 --> 24:51.680
不好意思

24:51.680 --> 24:52.680
我把这个念习题

24:52.680 --> 24:53.680
复制一下

24:53.680 --> 24:54.680
扣上代码

24:55.680 --> 24:57.680
念习题

24:57.680 --> 24:58.680
参考答案

24:59.680 --> 25:05.700
好

25:05.700 --> 25:06.700
我要做一个念习

25:06.700 --> 25:09.590
第二题

25:11.590 --> 25:13.590
得到所有按钮文本

25:14.590 --> 25:15.590
形成的数组

25:16.590 --> 25:17.590
就我这里有很多按钮

25:17.590 --> 25:18.590
对吧

25:18.590 --> 25:19.590
我要的拿到的不是按钮

25:19.590 --> 25:20.590
我要拿到的是这么一个东西

25:20.590 --> 25:21.590
一个数组

25:22.590 --> 25:23.590
第一个按钮的文本

25:23.590 --> 25:24.590
第二个按钮的文本

25:24.590 --> 25:25.590
然后第三个第四个

25:25.590 --> 25:26.590
也把所有的按钮文本

25:26.590 --> 25:27.590
形成这么一个数组

25:27.590 --> 25:28.590
大家想想怎么做

25:32.180 --> 25:34.180
这就是一个典型的

25:34.180 --> 25:35.180
映射场景

25:35.180 --> 25:36.180
我手上有啥

25:36.180 --> 25:37.180
我能拿到啥

25:37.180 --> 25:38.180
我是不是拿到

25:38.180 --> 25:39.180
所有的按钮啊

25:42.180 --> 25:43.180
就拿到所有的按钮

25:45.180 --> 25:46.180
那么这个按钮的

25:46.180 --> 25:47.180
这个数组的每一项

25:47.180 --> 25:48.180
是不是一个

25:49.180 --> 25:50.180
动物元素

25:50.180 --> 25:51.180
我要把

25:51.180 --> 25:52.180
第一个动物元素

25:52.180 --> 25:53.180
变成这个

25:53.180 --> 25:54.180
我要把

25:54.180 --> 25:55.180
第二个动物元素变成这个

25:55.180 --> 25:56.180
是不是就

25:56.180 --> 25:58.180
就是一个非常典型的

25:58.180 --> 25:59.180
映射场景

25:59.180 --> 26:00.180
数组的相不变

26:00.180 --> 26:01.180
长度不变

26:01.180 --> 26:03.180
但是每一项变了

26:03.180 --> 26:05.180
按照某一种规则变了

26:05.180 --> 26:06.180
所以说这个

26:06.180 --> 26:07.180
这个东西该怎么写

26:07.180 --> 26:09.180
首先我把它转换成数组

26:09.180 --> 26:10.180
我可以用

26:11.180 --> 26:12.180
查文的

26:12.180 --> 26:13.180
我们它不是数组

26:13.180 --> 26:14.180
因为它没有

26:14.180 --> 26:15.180
我们要做映射

26:15.180 --> 26:16.180
映射是不是必须要用

26:16.180 --> 26:17.180
麦普函数

26:17.180 --> 26:18.180
麦普函数的话

26:18.180 --> 26:19.180
我们

26:19.180 --> 26:20.180
它不是一颗真正的

26:20.180 --> 26:21.180
这个数组

26:21.180 --> 26:22.180
它是我一数组

26:22.180 --> 26:23.180
没有麦普函数

26:23.180 --> 26:24.180
因此我把它

26:24.180 --> 26:25.180
转换成真数组

26:25.180 --> 26:26.180
是吧

26:26.180 --> 26:28.180
那么这是不是个真数组

26:28.180 --> 26:29.180
那么它是不是真数组

26:29.180 --> 26:30.180
它是真数组

26:30.180 --> 26:31.180
它就有麦普函数

26:31.180 --> 26:32.180
然后这里边

26:32.180 --> 26:34.180
是不是传一个函数进去

26:34.180 --> 26:35.180
函数的每一项

26:35.180 --> 26:36.180
每一项

26:36.180 --> 26:37.180
之前是数字

26:37.180 --> 26:38.180
那不是说

26:38.180 --> 26:39.180
所有的数字

26:39.180 --> 26:40.180
数组都是数字

26:40.180 --> 26:41.180
这个数组

26:41.180 --> 26:42.180
每一项是什么

26:42.180 --> 26:43.180
是个动物元素

26:43.180 --> 26:44.180
这个item

26:44.180 --> 26:45.180
是个动物元素

26:45.180 --> 26:54.020
比较舒服一下item

26:57.020 --> 26:58.020
为什么

26:59.020 --> 27:00.020
没有输出

27:05.020 --> 27:06.020
你看是不是动物元素

27:06.020 --> 27:07.020
每一项

27:07.020 --> 27:08.020
好然后呢

27:08.020 --> 27:09.020
我要的是

27:09.020 --> 27:10.020
我要的不是动物元素

27:10.020 --> 27:11.020
我要是这个动物元素的

27:15.020 --> 27:16.020
你给我的是动物元素

27:16.020 --> 27:18.020
我跟你硬设成为它的文本

27:18.020 --> 27:19.020
那么反而回到

27:19.020 --> 27:21.020
是一个新数组

27:22.020 --> 27:23.020
那么这个新数组

27:23.020 --> 27:24.020
就是我们想要的东西

27:26.330 --> 27:27.330
好保存

27:27.330 --> 27:28.330
你看

27:28.330 --> 27:29.330
这是硬设

27:29.330 --> 27:30.330
把每一个动物对象

27:30.330 --> 27:32.330
硬设成了一个文本

27:33.330 --> 27:34.330
把每一个动物对象

27:34.330 --> 27:35.330
硬设成了一个文本

27:36.330 --> 27:37.330
对吧

27:37.330 --> 27:38.330
硬设的场景特别多

27:39.330 --> 27:40.330
好这是这道题

27:41.330 --> 27:42.330
第三题

27:44.640 --> 27:45.640
好想想怎么做

27:45.640 --> 27:46.640
我要做什么呢

27:46.640 --> 27:49.640
我要拿到按钮文本形成的数组

27:49.640 --> 27:50.640
然后我要拿到

27:50.640 --> 27:51.640
老老师这么一个东西

27:54.470 --> 27:55.470
赢这个是什么

27:55.470 --> 27:56.470
是第几个按钮

27:56.470 --> 27:57.470
下标从零开始

27:57.470 --> 27:58.470
这是第1个

27:58.470 --> 27:59.470
然后呢

27:59.470 --> 28:00.470
然后呢

28:00.470 --> 28:01.470
按钮到文本市场

28:01.470 --> 28:02.470
我要拿到这么一个东西

28:03.470 --> 28:04.470
又咋做

28:05.470 --> 28:06.470
不一样的吗

28:06.470 --> 28:08.470
同学们不一样的吗

28:08.470 --> 28:11.470
你这个玩意儿跟这个有啥区别啊

28:11.470 --> 28:13.470
它是不是还是硬设

28:13.470 --> 28:14.470
之前是硬设成制服串

28:14.470 --> 28:16.470
你现在硬设成对象你不会了吗

28:18.470 --> 28:19.470
之前是把这个玩意儿

28:19.470 --> 28:20.470
硬设成一个制服串

28:21.470 --> 28:23.470
然后现在我要把它硬设成一个对象

28:25.470 --> 28:27.470
那就返回对象的

28:28.470 --> 28:30.470
应这个设为多少

28:30.470 --> 28:31.470
那就是下标嘛

28:31.470 --> 28:32.470
那下标是不是这个传输

28:32.470 --> 28:34.470
有第二个传输就是下标

28:34.470 --> 28:35.470
那你就为按一边

28:37.470 --> 28:38.470
那么文本为啥

28:38.470 --> 28:40.470
文本不就是这个数组的

28:41.470 --> 28:42.470
InnerCake什么

28:44.470 --> 28:46.470
你给我一个每一项给我

28:46.470 --> 28:47.470
每一项的下标给我

28:47.470 --> 28:48.470
然后呢我给你返回一个对象

28:49.470 --> 28:51.470
不就这么回事吗

28:54.040 --> 28:55.040
再来看

28:59.330 --> 29:00.330
放心

29:01.330 --> 29:03.330
你看就是拿到了

29:04.330 --> 29:05.330
通过这个硬设啊

29:05.330 --> 29:06.330
以后以后你会发现

29:07.330 --> 29:08.330
只要我有这么一个场景

29:08.330 --> 29:09.330
我有一个数组

29:11.330 --> 29:12.330
但是那个数组呢

29:12.330 --> 29:13.330
里边的东西呢

29:13.330 --> 29:14.330
不是我想要的格式

29:14.330 --> 29:16.330
我要把它变成另外的东西

29:16.330 --> 29:17.330
把每一项变成另外的东西

29:17.330 --> 29:18.330
保持数组长度不变

29:19.330 --> 29:20.330
把每一项变成另外一个东西

29:20.330 --> 29:21.330
就直接来硬设

29:21.330 --> 29:22.330
瞬间要反应过来

29:22.330 --> 29:23.330
是硬设

29:24.330 --> 29:25.330
硬设

29:26.330 --> 29:30.630
瞬间要反应过来

29:35.730 --> 29:47.070
好 接下来下面的题

29:48.070 --> 29:49.070
就瞬间式的题了

29:50.070 --> 29:55.170
我的题好像写的

29:57.170 --> 29:58.170
地方写错了

29:59.170 --> 30:00.170
疲势

30:02.170 --> 30:03.170
把疲势去掉

30:03.170 --> 30:04.170
疲势的题跟那个

30:05.170 --> 30:06.170
疲势没有 只要疲势

30:07.170 --> 30:08.170
第五道题

30:08.170 --> 30:09.170
而且写多了一个

30:10.170 --> 30:11.170
写错了一个

30:12.170 --> 30:14.170
得到一个随机数

30:15.170 --> 30:16.170
组成了数组

30:17.170 --> 30:18.170
数组长度为十

30:18.170 --> 30:20.170
随书的范围在0到1时间

30:21.170 --> 30:22.170
就是说啊

30:22.170 --> 30:23.170
我这里要拿到一个数

30:23.170 --> 30:24.170
让你去写这么一个代码

30:25.170 --> 30:26.170
再重新一次

30:26.170 --> 30:27.170
这些代码

30:27.170 --> 30:28.170
跟我之前说的

30:28.170 --> 30:29.170
是一样的

30:29.170 --> 30:30.170
就是说

30:30.170 --> 30:32.170
你可以用过去的方式写

30:32.170 --> 30:33.170
你可以写没关系

30:34.170 --> 30:35.170
但是老是跟你写的方式

30:35.170 --> 30:37.170
你至少必须要写一遍

30:38.170 --> 30:39.170
你在学会型的方式用不用

30:39.170 --> 30:41.170
反正这些都是工具

30:41.170 --> 30:43.170
韩束 API

30:43.170 --> 30:44.170
语法都是工具

30:45.170 --> 30:47.170
要不要用你自己决定

30:47.170 --> 30:48.170
但是你得会

30:50.170 --> 30:51.170
咱们国家

30:52.170 --> 30:53.170
合物器必须得一有

30:54.170 --> 30:55.170
但是不一定用

30:55.170 --> 30:56.170
用不用再说

30:56.170 --> 30:57.170
但是你得一有

30:57.170 --> 30:58.170
你得会

30:59.170 --> 31:00.170
因此这一块

31:00.170 --> 31:01.170
你要用过去的方式写

31:01.170 --> 31:02.170
可以没问题

31:02.170 --> 31:03.170
但是老是写的

31:03.170 --> 31:04.170
你必须要会

31:06.170 --> 31:08.170
它让你去得到一个数组

31:08.170 --> 31:09.170
这个数组长度为十

31:10.170 --> 31:11.170
随机数范

31:11.170 --> 31:12.170
每数组的每一项

31:12.170 --> 31:13.170
是一个随机数

31:14.170 --> 31:15.170
那么就得到那次结果

31:15.170 --> 31:16.170
就这样子

31:16.170 --> 31:17.170
0到1之间随机数

31:17.170 --> 31:18.170
第一项是这个

31:18.170 --> 31:19.170
第二项是这个

31:19.170 --> 31:20.170
第三项是这个

31:20.170 --> 31:21.170
一直有十项

31:21.170 --> 31:23.170
那这个功能以前怎么做呢

31:23.170 --> 31:24.170
所以循环实施

31:24.170 --> 31:26.170
每一次生成一个随机数

31:26.170 --> 31:27.170
往数组里边加

31:28.170 --> 31:29.170
那这个玩意你自己去写

31:29.170 --> 31:30.170
过去的写法

31:30.170 --> 31:32.170
那我现在用一些新的写法来写

31:32.170 --> 31:34.170
这些写法是很多的

31:34.170 --> 31:35.170
过去的写法

31:35.170 --> 31:36.170
不是说错

31:36.170 --> 31:37.170
也不是说不好

31:37.170 --> 31:39.170
只是比较挪说

31:39.170 --> 31:41.170
新的写法就比较快了

31:41.170 --> 31:43.170
我可以生成一个数组

31:43.170 --> 31:44.170
长度为多少十

31:45.170 --> 31:46.170
对吧

31:47.170 --> 31:48.170
那么我们这里

31:49.170 --> 31:50.170
使用map

31:52.170 --> 31:54.170
是把每一项来进行映射

31:55.170 --> 31:56.170
那每一项是

31:56.170 --> 31:58.170
你不要传啥无所谓

31:58.170 --> 31:59.170
你随便给我传啥都无所谓

31:59.170 --> 32:01.170
因为反正我不用你

32:01.170 --> 32:02.170
要生成一个数组

32:02.170 --> 32:03.170
数组每一项是undefine

32:03.170 --> 32:05.170
我不用都不用你那一项

32:05.170 --> 32:06.170
我直接给你返回一个随机数

32:07.170 --> 32:08.170
对吧

32:08.170 --> 32:09.170
返回的是什么maps点

32:10.170 --> 32:12.170
不就是映射吗

32:12.170 --> 32:13.170
数组一开始啥都没有

32:13.170 --> 32:15.170
每一项有十项一边啥都没有

32:15.170 --> 32:16.170
把每一项映射成一个随机数

32:16.170 --> 32:18.170
每一项都调用这个函数生成一个随机数

32:18.170 --> 32:20.170
返回一个新数组

32:21.170 --> 32:23.170
那么这就是我们需要的一个数组

32:23.170 --> 32:25.170
那么大家看一下

32:25.170 --> 32:26.170
有没有这场数数

32:28.170 --> 32:29.170
发现什么没有

32:29.170 --> 32:30.170
为什么没有呢

32:30.170 --> 32:31.170
我们来看一下这个函数

32:31.170 --> 32:32.170
没有调用啊

32:32.170 --> 32:33.170
按理说它有十项

32:33.170 --> 32:34.170
应该调用十次这个函数

32:34.170 --> 32:35.170
有没有调用啊

32:35.170 --> 32:36.170
一世都没有调用

32:36.170 --> 32:37.170
这是为什么呢

32:37.170 --> 32:38.170
因为通过这个area

32:38.170 --> 32:39.170
这有个细节

32:39.170 --> 32:40.170
通过这种方式

32:40.170 --> 32:41.170
这是过去的一些技术

32:41.170 --> 32:43.170
通过这种方式生成的数组

32:43.170 --> 32:44.170
它是一个稀松数组

32:44.170 --> 32:45.170
它只有一个长度为十

32:45.170 --> 32:47.170
数组的每一项你没有给值

32:47.170 --> 32:48.170
对吧

32:48.170 --> 32:49.170
它不知道每一项是什么

32:49.170 --> 32:50.170
它是个稀松数组

32:50.170 --> 32:52.170
稀松数组是没法进行映射的

32:52.170 --> 32:54.170
不是说没法进行映射

32:54.170 --> 32:56.170
就是它那些0123456789

32:56.170 --> 32:57.170
那个下标

32:57.170 --> 32:58.170
它是不会进行映射的

32:58.170 --> 32:59.170
因为它没这个东西

33:00.170 --> 33:01.170
那怎么办呢

33:01.170 --> 33:02.170
那我简单的

33:02.170 --> 33:04.170
我不把它变成稀松数据完事了

33:04.170 --> 33:06.170
我给它费我一个0

33:06.170 --> 33:07.170
这样子的数组

33:07.170 --> 33:09.170
是不是就一开始就有值了

33:09.170 --> 33:10.170
数组的每一项就有值了

33:11.170 --> 33:12.170
对吧

33:12.170 --> 33:13.170
然后我再去映射

33:13.170 --> 33:14.170
这个0也好

33:14.170 --> 33:15.170
1也好

33:15.170 --> 33:16.170
无所谓

33:16.170 --> 33:17.170
我给它负责为0

33:17.170 --> 33:18.170
负责为abca

33:18.170 --> 33:20.170
随便负责为啥都行

33:20.170 --> 33:21.170
因为我不用

33:21.170 --> 33:29.350
它每一项我根本就不用的

33:29.350 --> 33:30.350
它每一项我根本就不用

33:30.350 --> 33:32.350
第一项我管它第一项是啥

33:32.350 --> 33:34.350
反正我返回给你一个水积数

33:34.350 --> 33:35.350
我把它映射成一个水积数

33:35.350 --> 33:36.350
所以说

33:36.350 --> 33:37.350
这一项到底是啥

33:37.350 --> 33:38.350
其实无所谓的

33:38.350 --> 33:39.350
就写个0吧

33:39.350 --> 33:40.350
那么现在我们来看一下

33:40.350 --> 33:42.350
就是生成了一个水积数的数组

33:42.350 --> 33:43.350
长度为十

33:43.350 --> 33:45.350
那么这样子显然就要比那个

33:45.350 --> 33:47.350
用佛询环一个个去铺洗

33:47.350 --> 33:48.350
要简单的多了

33:49.350 --> 33:50.350
好 这是这个题

33:50.350 --> 33:51.350
下一个

33:51.350 --> 33:53.350
得到一个水积数生成的数组

33:53.350 --> 33:54.350
长度为十一样的

33:54.350 --> 33:55.350
水积数的范围

33:55.350 --> 33:57.350
控制在十到一百之间

33:58.350 --> 33:59.350
我看多少同学

33:59.350 --> 34:00.350
这个写不出来

34:02.350 --> 34:03.350
就前面的写出来了

34:03.350 --> 34:04.350
这个写不出来

34:05.350 --> 34:07.350
这个弹码还得多练

34:07.350 --> 34:09.350
弹码是极其灵活的

34:09.350 --> 34:10.350
不要去背场景

34:10.350 --> 34:11.350
我老实说

34:11.350 --> 34:12.350
这个题是这么做的

34:12.350 --> 34:13.350
以后就把它背下来

34:13.350 --> 34:14.350
那么将来我遇到了

34:14.350 --> 34:15.350
一模一样的地方

34:15.350 --> 34:16.350
我就可以写出来了

34:16.350 --> 34:17.350
那你这样背的话

34:17.350 --> 34:18.350
我跟你们说

34:20.350 --> 34:21.350
以后学到

34:21.350 --> 34:22.350
进养老院你都学不完

34:22.350 --> 34:24.350
因为长期是无穷无尽的

34:24.350 --> 34:25.350
你要去

34:25.350 --> 34:26.350
你不要去背一台

34:26.350 --> 34:27.350
要去灵活的处理

34:27.350 --> 34:28.350
根据长期

34:28.350 --> 34:29.350
比方说

34:29.350 --> 34:30.350
这个东西需要训练

34:30.350 --> 34:31.350
慢慢来

34:31.350 --> 34:32.350
弹码写的越多

34:32.350 --> 34:34.350
你这个感觉越强

34:35.350 --> 34:36.350
那就一样的

34:36.350 --> 34:38.350
我就把这个复制过来吧

34:39.350 --> 34:40.350
复制过来吗

34:41.350 --> 34:42.350
这里我之前无非

34:42.350 --> 34:43.350
就是这个地方出了问题

34:43.350 --> 34:44.350
这个地方我们返回的是

34:44.350 --> 34:46.350
0到1之间的水积数

34:46.350 --> 34:48.350
那我这个地方返回

34:48.350 --> 34:49.350
返回什么呢

34:49.350 --> 34:50.350
10到100之间的水积数

34:50.350 --> 34:56.040
返回多少到多少的水积数

34:57.040 --> 34:58.040
它是一个固定公式的

34:59.040 --> 35:03.530
啥公式

35:04.530 --> 35:08.530
乘以它的取值范围

35:08.530 --> 35:09.530
取值范围是什么

35:09.530 --> 35:10.530
10到100

35:10.530 --> 35:11.530
100有多少

35:11.530 --> 35:12.530
就是它的可能性

35:12.530 --> 35:13.530
一多号的可能性

35:13.530 --> 35:14.530
就是100

35:14.530 --> 35:15.530
减去10

35:16.530 --> 35:17.530
所以有这么多可能性

35:17.530 --> 35:18.530
对吧

35:18.530 --> 35:19.530
100减去10

35:19.530 --> 35:20.530
然后加10

35:21.530 --> 35:23.530
加上最小组织就可以了

35:23.530 --> 35:24.530
就生成水积数

35:24.530 --> 35:25.530
不过生成水积数有小数

35:25.530 --> 35:26.530
把它变成整个数

35:27.530 --> 35:28.530
总之你每一项

35:28.530 --> 35:29.530
我就给你返回这个东西

35:29.530 --> 35:31.530
那么生成出来就自然死

35:31.530 --> 35:32.530
它是取不到100的

35:32.530 --> 35:34.530
所以我这东西法是取不到100的

35:34.530 --> 35:35.530
如果说要取到100的话

35:35.530 --> 35:36.530
你这里需要

35:37.530 --> 35:39.530
你这里需要把那个加1

35:40.530 --> 35:41.530
你需要加1的

35:42.530 --> 35:43.530
拜拜

35:51.970 --> 35:52.970
这里需要加1

35:52.970 --> 35:53.970
这里也需要加1

35:54.970 --> 35:55.970
这里不需要

35:55.970 --> 35:56.970
这里需要加1

35:57.970 --> 35:58.970
这是那个

36:00.970 --> 36:01.970
第二题

36:01.970 --> 36:02.970
下面

36:02.970 --> 36:04.970
判断某个制服串S

36:04.970 --> 36:06.970
是不是这些东西当中的一个

36:06.970 --> 36:07.970
比方说有个制服串

36:07.970 --> 36:09.970
你不知道它是啥

36:09.970 --> 36:10.970
它可能是别人用户

36:10.970 --> 36:11.970
在店面上输入的

36:11.970 --> 36:12.970
在尾闷框里面输入的

36:12.970 --> 36:13.970
你都不知道它是什么

36:13.970 --> 36:15.970
比方可能制服串里面

36:15.970 --> 36:16.970
是这个东西

36:18.970 --> 36:19.970
Ds

36:19.970 --> 36:21.970
要判断的是这个制服串

36:21.970 --> 36:22.970
是不是等于它

36:22.970 --> 36:23.970
或者是不是等于它

36:23.970 --> 36:24.970
或者是不是等于它

36:24.970 --> 36:25.970
或者是不是等于它

36:25.970 --> 36:27.970
只要它等于它们任何中的一个

36:27.970 --> 36:28.970
都可以

36:30.970 --> 36:32.970
这种情场景一般用来做什么

36:32.970 --> 36:33.970
判断一些

36:33.970 --> 36:35.970
特别是在做上传文件的时候

36:35.970 --> 36:37.970
判断文件的后罪名

36:37.970 --> 36:38.970
是不是合法的

36:39.970 --> 36:40.970
比方说有这么一个场景

36:40.970 --> 36:41.970
要判断它

36:41.970 --> 36:42.970
是不是等于它们中的一个

36:42.970 --> 36:43.970
但是它的直立是不知道的

36:43.970 --> 36:45.970
我这里是随便瞎写的

36:45.970 --> 36:46.970
它又可能是来自于界面的

36:46.970 --> 36:47.970
比方来自于某一个

36:47.970 --> 36:48.970
文闷框的来留值

36:48.970 --> 36:50.970
你都不知道它写的是什么

36:50.970 --> 36:52.970
那么现在我就随便写一个

36:52.970 --> 36:54.970
判断它是不是从体统中的一个

36:54.970 --> 36:55.970
那怎么判断呢

36:55.970 --> 36:56.970
以前我们可以用衣服判断

36:56.970 --> 36:57.970
对吧

36:57.970 --> 36:58.970
s是不是

36:58.970 --> 37:00.970
s是不是等于

37:00.970 --> 37:01.970
jpg

37:01.970 --> 37:03.970
或者s是不是

37:03.970 --> 37:05.970
是不是等于

37:05.970 --> 37:06.970
jpg

37:06.970 --> 37:07.970
对不对

37:07.970 --> 37:08.970
那么这样写起来比较麻烦

37:08.970 --> 37:09.970
可不可以当然可以

37:09.970 --> 37:11.970
写起来比较麻烦

37:11.970 --> 37:12.970
我们可以现在可以怎么写

37:12.970 --> 37:13.970
我把这些玩意

37:13.970 --> 37:14.970
放到输出里面

37:14.970 --> 37:16.970
就是我的可能性

37:16.970 --> 37:18.970
我允许的指

37:18.970 --> 37:19.970
放到输出里面

37:19.970 --> 37:21.970
bmp

37:21.970 --> 37:22.970
叫gf

37:22.970 --> 37:24.970
然后判断这个输出里面

37:24.970 --> 37:26.970
是不是包含它就完事了

37:26.970 --> 37:28.970
是不是这个意思

37:28.970 --> 37:29.970
includes

37:29.970 --> 37:32.600
这个

37:32.600 --> 37:34.600
includes

37:34.600 --> 37:35.600
是不是包含了

37:35.600 --> 37:36.600
把这个q和force

37:36.600 --> 37:38.600
包含谁包含 s

37:38.600 --> 37:40.600
就是什么结果

37:40.600 --> 37:45.320
好看一下

37:45.320 --> 37:46.320
就可以

37:46.320 --> 37:47.320
不包含

37:47.320 --> 37:49.320
那就说明这个输入有问题

37:49.320 --> 37:50.320
这个支付说不行

37:50.320 --> 37:52.320
然后如果说是png

37:52.320 --> 37:53.320
比方说那么就包含

37:53.320 --> 37:55.320
那么就说明ok

37:55.320 --> 37:56.320
它能通过

37:56.320 --> 37:57.320
当然这个玩意

37:57.320 --> 37:59.320
我是直接把输入放这儿了

37:59.320 --> 38:00.320
一开始有个变量

38:00.320 --> 38:01.320
放到变量里面

38:01.320 --> 38:02.320
通过这个变量去调用

38:02.320 --> 38:06.280
可不可以

38:06.280 --> 38:09.280
表达式就看不懂了

38:09.280 --> 38:11.280
这是第五个大题

38:11.280 --> 38:13.280
第六个大题

38:13.280 --> 38:14.280
就有个大题

38:14.280 --> 38:15.280
这里有个输入

38:15.280 --> 38:16.280
准备好了

38:16.280 --> 38:17.280
学生的输入

38:17.280 --> 38:18.280
这是学生的编号

38:18.280 --> 38:19.280
这是学生的名字

38:19.280 --> 38:20.280
学生的性别

38:20.280 --> 38:21.280
学生的年龄

38:21.280 --> 38:22.280
学生的住址

38:22.280 --> 38:23.280
学生的电话

38:23.280 --> 38:24.280
我这里是随机生成的

38:24.280 --> 38:25.280
你不用管

38:25.280 --> 38:27.280
反正就是这么一个学生输入

38:27.280 --> 38:29.280
这个输入的格式

38:29.280 --> 38:30.280
基本上就是

38:30.280 --> 38:33.280
每个学生就是用这种格式

38:33.280 --> 38:35.280
每个学生就是这样子

38:35.280 --> 38:37.280
然后让你做下面的题

38:37.280 --> 38:39.280
一道一道来

38:39.280 --> 38:40.280
你把这些题做完了

38:40.280 --> 38:43.280
就让这些喊数基本上联系到了

38:43.280 --> 38:46.280
便利输出学生的姓名

38:46.280 --> 38:47.280
做

38:47.280 --> 38:49.280
一道题一道去先自己做

38:49.280 --> 38:51.280
想办法

38:51.280 --> 38:52.280
做不出来

38:52.280 --> 38:53.280
实在做不出来了

38:53.280 --> 38:54.280
听老师讲

38:54.280 --> 38:55.280
然后听到老师讲之后再做一遍

38:55.280 --> 38:57.280
跟按照老师的协访协访一遍

38:57.280 --> 38:58.280
加深影响

38:58.280 --> 39:00.280
必须按照我说的做

39:00.280 --> 39:03.280
不要自作聪明

39:03.280 --> 39:04.280
好 来

39:04.280 --> 39:06.280
这一般方法是不是很多

39:06.280 --> 39:07.280
可以用 for 循环

39:07.280 --> 39:09.280
可以用 for 二五循环

39:09.280 --> 39:10.280
也可以用

39:10.280 --> 39:12.280
喊数的 for 一起都可以

39:12.280 --> 39:13.280
我们可以用什么呢

39:13.280 --> 39:14.280
for 二五循环

39:14.280 --> 39:16.280
循环每一个学生

39:16.280 --> 39:17.280
循环学生的宿主

39:17.280 --> 39:18.280
students

39:18.280 --> 39:20.280
然后输出学生的姓名

39:20.280 --> 39:22.280
对吧 这个非常简单

39:22.280 --> 39:24.280
影响

39:24.280 --> 39:26.280
所以输出了很多的学生姓名

39:26.280 --> 39:28.280
当然这是 for 二五循环

39:28.280 --> 39:29.280
也可以用什么

39:29.280 --> 39:32.280
students 里边的 for 一起

39:32.280 --> 39:33.280
是不是这个喊数

39:33.280 --> 39:34.280
传一个喊数进去

39:34.280 --> 39:36.280
把每一个学生给我

39:36.280 --> 39:38.280
然后我就是输出学生的姓名

39:38.280 --> 39:40.280
是不是一样的

39:40.280 --> 39:44.100
for 一起

39:44.100 --> 39:45.100
它就会把每一个

39:45.100 --> 39:47.100
第一个 输出的第一项给我

39:47.100 --> 39:49.100
它只能看懂数字数组

39:49.100 --> 39:50.100
只要数 数组

39:50.100 --> 39:51.100
它不是数字

39:51.100 --> 39:52.100
它就看不懂了

39:52.100 --> 39:53.100
那不一样的嘛

39:53.100 --> 39:55.100
它数字的话一项一项传进来

39:55.100 --> 39:56.100
它对项的话

39:56.100 --> 39:58.100
是不是把对项一项一项传进来的

39:58.100 --> 39:59.100
果然就是对项了

39:59.100 --> 40:00.100
就是学生的对项

40:00.100 --> 40:01.100
把第一个学生传进来

40:01.100 --> 40:02.100
第二个学生传进来

40:02.100 --> 40:03.100
对吧

40:03.100 --> 40:05.800
好 下一个

40:05.800 --> 40:06.800
得到所有女生

40:06.800 --> 40:10.170
当然得到所有女生

40:10.170 --> 40:11.170
是不是得到一个对

40:11.170 --> 40:12.170
得到一个叔叔

40:12.170 --> 40:13.170
对吧 叔叔里边

40:13.170 --> 40:15.170
所有的学生都是女生

40:15.170 --> 40:17.170
来 写

40:17.170 --> 40:18.170
没道理啊

40:18.170 --> 40:19.170
我后面就不说了

40:19.170 --> 40:22.740
我讲之前 你们先写

40:22.740 --> 40:24.740
好 那么这里该怎么做呢

40:24.740 --> 40:25.740
是不是做筛选

40:25.740 --> 40:26.740
因为我们这里是个

40:26.740 --> 40:28.740
完整的学生数组

40:28.740 --> 40:30.740
我这里是一个完整的数组

40:30.740 --> 40:32.740
然后呢

40:32.740 --> 40:33.740
我要得到的结果

40:33.740 --> 40:34.740
是不是要被它少一些

40:34.740 --> 40:36.740
就有些东西我不要了

40:36.740 --> 40:38.740
我不会改变数字的某一项

40:38.740 --> 40:40.740
数字里面的东西我不动

40:40.740 --> 40:41.740
但是我把一些东西

40:41.740 --> 40:42.740
去掉不要了

40:42.740 --> 40:44.740
这就是典型的筛选

40:44.740 --> 40:45.740
那么我们可以怎么办

40:45.740 --> 40:47.740
Students

40:47.740 --> 40:49.740
以前是不是可以也可以写

40:49.740 --> 40:50.740
对吧

40:50.740 --> 40:52.740
现在我们用Future

40:52.740 --> 40:53.740
筛选

40:53.740 --> 40:56.740
一个一个的学生给我

40:56.740 --> 40:58.740
那么什么我要

40:58.740 --> 40:59.740
什么不要

40:59.740 --> 41:00.740
要的是哪些

41:00.740 --> 41:02.740
要的就是学生的

41:02.740 --> 41:04.740
sex 性别等于什么

41:04.740 --> 41:05.740
等于女

41:05.740 --> 41:07.740
要反回True和Force

41:07.740 --> 41:08.740
反回的是True

41:08.740 --> 41:10.740
那么这一项就要

41:10.740 --> 41:11.740
反回的是Force

41:11.740 --> 41:12.740
这一项就不要

41:12.740 --> 41:13.740
那么到底反回True和Force

41:13.740 --> 41:14.740
你自己去判断

41:14.740 --> 41:15.740
然后说这里

41:15.740 --> 41:16.740
sex 等于女

41:16.740 --> 41:18.740
那么就是我要的学生

41:18.740 --> 41:19.740
那么这里

41:19.740 --> 41:20.740
我反回的是什么

41:20.740 --> 41:21.740
最终就是

41:21.740 --> 41:23.740
最终的结果

41:23.740 --> 41:24.740
说出非常

41:28.370 --> 41:29.370
是不是得到所有的女生

41:29.370 --> 41:30.370
这些名字跟

41:30.370 --> 41:31.370
好像名字

41:31.370 --> 41:32.370
跟性别有点对不上

41:32.370 --> 41:33.370
我这是随机生存的

41:33.370 --> 41:34.370
随机生存的

41:34.370 --> 41:35.370
不要去纠结这个

41:35.370 --> 41:37.370
可是真实的学生

41:37.370 --> 41:40.810
再下一个

41:40.810 --> 41:41.810
得到所有年龄

41:41.810 --> 41:44.810
在二十五岁以下的女生

41:44.810 --> 41:46.810
又来了

41:46.810 --> 41:47.810
我这里就直接讲

41:47.810 --> 41:48.810
我现在默认你们

41:48.810 --> 41:50.810
自己已经去写过了

41:51.810 --> 41:54.810
是不是还是筛选

41:54.810 --> 41:56.810
还是筛选

41:56.810 --> 41:57.810
反正你得到的东西

41:57.810 --> 41:58.810
结果跟那个

41:58.810 --> 41:59.810
可能要比那个元素

41:59.810 --> 42:01.810
主要小一些点心的筛选

42:01.810 --> 42:03.810
你不会改变元素者东西

42:03.810 --> 42:04.810
点心的筛选

42:04.810 --> 42:05.810
条件是什么

42:05.810 --> 42:07.810
什么条件满足

42:07.810 --> 42:08.810
我就要保留了

42:08.810 --> 42:09.810
是不是就是

42:09.810 --> 42:11.810
学生的年龄

42:11.810 --> 42:13.810
在二十五岁以下

42:13.810 --> 42:14.810
小于等于也行

42:14.810 --> 42:15.810
他都无所谓

42:15.810 --> 42:18.810
并且他还得是女生

42:18.810 --> 42:22.250
这个是等于女

42:22.250 --> 42:28.960
来输出一下

42:28.960 --> 42:29.960
这些女生都是小

42:29.960 --> 42:30.960
年龄都是小于二十五岁的

42:30.960 --> 42:34.720
直接去看

42:34.720 --> 42:35.720
下一道题

42:35.720 --> 42:39.720
找到所有姓程的学生

42:39.720 --> 42:40.720
不是女生

42:40.720 --> 42:42.720
找到所有姓程的学生

42:42.720 --> 42:44.720
所以还是筛选

42:44.720 --> 42:45.720
筛选来筛选去

42:45.720 --> 42:46.720
筛选用的特别多

42:46.720 --> 42:49.720
我们形式开发的时候

42:49.720 --> 42:50.720
比方说我们这里

42:50.720 --> 42:51.720
要找到所有姓程的

42:51.720 --> 42:53.720
他名字开刀

42:53.720 --> 42:55.720
他的名字有个什么特点

42:55.720 --> 42:57.720
名字的第一个制服

42:57.720 --> 42:58.720
应该等于

42:58.720 --> 43:00.720
成

43:00.720 --> 43:01.720
对不对

43:01.720 --> 43:03.720
去找到所有的姓程的

43:03.720 --> 43:08.280
我这里没有姓程的学生

43:08.280 --> 43:09.280
我看一下

43:09.280 --> 43:10.280
我查一下

43:10.280 --> 43:12.280
有可能我真没有姓程的学生

43:12.280 --> 43:13.280
还真没有

43:13.280 --> 43:14.280
那就欢迎别的姓

43:14.280 --> 43:15.280
欢迎别的姓

43:15.280 --> 43:18.280
原来说换了一个王

43:18.280 --> 43:21.280
王是大姓

43:21.280 --> 43:22.280
学生是随即生存的

43:22.280 --> 43:23.280
我也不知道

43:23.280 --> 43:25.280
我生存了哪些学生

43:25.280 --> 43:26.280
找到一个

43:26.280 --> 43:28.280
有没有多个的呢

43:28.280 --> 43:31.280
就没有一个聪明的

43:31.280 --> 43:33.280
缝呢

43:33.280 --> 43:40.370
我试一下

43:40.370 --> 43:41.370
缝

43:43.370 --> 43:45.370
缝有好几个

43:45.370 --> 43:48.370
你自己去看一下

43:48.370 --> 43:49.370
那么除了用这种方式

43:49.370 --> 43:50.370
当然还有很多种方式

43:50.370 --> 43:52.370
比方说我们商业课学的

43:52.370 --> 43:54.370
制服串的API

43:54.370 --> 43:56.370
里面有个start switch

43:56.370 --> 43:57.370
判断制服串是不是

43:57.370 --> 43:58.370
以什么开头

43:58.370 --> 43:59.370
是不是可以用上了

43:59.370 --> 44:00.370
我判断他的名字

44:00.370 --> 44:01.370
是不是start switch

44:01.370 --> 44:02.370
以什么开头

44:02.370 --> 44:05.370
以缝开头

44:05.370 --> 44:06.370
对不对

44:06.370 --> 44:09.370
还不是一样的吗

44:09.370 --> 44:10.370
是一样的

44:10.370 --> 44:11.370
因为这个函数

44:11.370 --> 44:13.370
本身返回的就是处和方式

44:13.370 --> 44:14.370
返回处就表示

44:14.370 --> 44:15.370
他一试以他开头

44:15.370 --> 44:16.370
返回处

44:16.370 --> 44:17.370
返回处的话

44:17.370 --> 44:18.370
那么这边也返回处

44:18.370 --> 44:19.370
返回处表示

44:19.370 --> 44:21.370
这个学生要保留

44:21.370 --> 44:22.370
原来

44:22.370 --> 44:23.370
得到电话号码

44:23.370 --> 44:26.370
以一结尾的学生

44:26.370 --> 44:28.370
你们自己解解一遍

44:28.370 --> 44:32.860
电话号码

44:32.860 --> 44:34.860
Andress

44:34.860 --> 44:35.860
这个字骨串

44:35.860 --> 44:36.860
以什么

44:36.860 --> 44:37.860
以一结尾

44:37.860 --> 44:41.070
你看这些电话号码

44:41.070 --> 44:43.070
是不是都是以一结尾

44:43.070 --> 44:45.070
返回一个新宿主

44:45.070 --> 44:47.070
他不会改动原宿主

44:47.070 --> 44:51.070
得到学生新名组成的宿主

44:51.070 --> 44:53.070
都是他

44:53.070 --> 44:56.070
得到学生新名组成的宿主

44:56.070 --> 44:58.070
是不是典型的映射

44:58.070 --> 44:59.070
他不会改

44:59.070 --> 45:00.070
他不会导致

45:00.070 --> 45:02.070
原宿主的数量减少

45:02.070 --> 45:03.070
他不会说

45:03.070 --> 45:05.070
你这个学生我不要了

45:05.070 --> 45:06.070
不会吧

45:06.070 --> 45:07.070
你看前面都会

45:07.070 --> 45:08.070
对吧

45:08.070 --> 45:09.070
不要说他个电话号码

45:09.070 --> 45:10.070
不是以一结尾的

45:10.070 --> 45:11.070
我就不要了

45:11.070 --> 45:12.070
我这个保留

45:12.070 --> 45:13.070
这个学生保留

45:13.070 --> 45:14.070
这个学生不要

45:14.070 --> 45:15.070
不是的

45:15.070 --> 45:16.070
他是要把学生变成另一种格式

45:16.070 --> 45:17.070
把一个学生对象

45:17.070 --> 45:19.070
变成另一种格式

45:19.070 --> 45:20.070
把学生变成什么

45:20.070 --> 45:22.070
学生姓名

45:22.070 --> 45:24.070
那就是典型的映射

45:24.070 --> 45:28.530
Mag

45:28.530 --> 45:29.530
学生

45:29.530 --> 45:30.530
你给我的是学生对象

45:30.530 --> 45:31.530
我给你的是什么

45:31.530 --> 45:32.530
学生的名字

45:32.530 --> 45:34.530
我把得到一个新宿主

45:34.530 --> 45:35.530
名字

45:35.530 --> 45:36.530
宿主

45:36.530 --> 45:37.530
名字

45:38.530 --> 45:39.530
你看

45:39.530 --> 45:42.840
是不是拿到一个学生的姓名的宿主

45:42.840 --> 45:43.840
好

45:43.840 --> 45:46.410
给我来

45:46.410 --> 45:49.410
得到所有学生姓名

45:49.410 --> 45:51.410
组成的制服串

45:53.410 --> 45:55.410
以兜号分割

45:55.410 --> 45:57.410
得到所有学生姓名

45:57.410 --> 45:59.410
组成的制服串

45:59.410 --> 46:01.410
以兜号分割

46:01.410 --> 46:02.410
你看我现在

46:02.410 --> 46:05.790
是不是拿到学生的宿主了

46:05.790 --> 46:07.790
我现在是不是已经

46:07.790 --> 46:09.790
拿到学生的宿主了

46:09.790 --> 46:15.850
刚才我们演示过了

46:15.850 --> 46:19.420
我要把这个宿主

46:19.420 --> 46:21.420
变成一个制服串

46:21.420 --> 46:22.420
用什么

46:22.420 --> 46:24.420
用胶引背

46:24.420 --> 46:26.420
灵活使用以前的知识

46:26.420 --> 46:28.420
把宿主里面所有东西

46:28.420 --> 46:29.420
连成一个制服串

46:29.420 --> 46:30.420
用什么连接

46:30.420 --> 46:32.420
用兜号连接

46:32.420 --> 46:34.420
不玩了吗

46:34.420 --> 46:36.420
连成个制服串了

46:36.420 --> 46:37.420
好

46:37.420 --> 46:38.420
那么这里的

46:38.420 --> 46:39.420
当然也可以在这里

46:39.420 --> 46:40.420
直接写

46:40.420 --> 46:42.420
宿主吗

46:42.420 --> 46:43.420
我在这里直接用胶引

46:43.420 --> 46:44.420
投赔

46:44.420 --> 46:45.420
当然可以

46:45.420 --> 46:46.420
那么这个玩意直接

46:46.420 --> 46:52.250
制服串了

46:52.250 --> 46:53.250
好

46:53.250 --> 46:54.250
下一个

46:54.250 --> 46:55.250
把所有的学生姓名

46:55.250 --> 46:56.250
以P元数

46:56.250 --> 46:57.250
包起来形成一个

46:57.250 --> 46:58.250
ATM片段

46:58.250 --> 46:59.250
就第一个学生

46:59.250 --> 47:03.780
变成这个

47:03.780 --> 47:05.780
第一个学生变成这个

47:05.780 --> 47:06.780
梁庭

47:06.780 --> 47:13.760
第二个学生变成这个

47:13.760 --> 47:14.760
是在干嘛

47:14.760 --> 47:15.760
在干嘛

47:15.760 --> 47:16.760
在筛选还是在印射

47:16.760 --> 47:17.760
是不是在印射

47:17.760 --> 47:18.760
把第一个学生变成这个

47:18.760 --> 47:19.760
第一个学生变成这个

47:19.760 --> 47:21.760
那怎么弄

47:21.760 --> 47:22.760
还来

47:22.760 --> 47:24.760
又来

47:24.760 --> 47:26.760
Result

47:26.760 --> 47:27.760
Students

47:27.760 --> 47:29.760
Map

47:29.760 --> 47:31.760
你给我一个学生对象

47:31.760 --> 47:32.760
我给力的是一个什么呢

47:32.760 --> 47:34.760
我办制服串

47:34.760 --> 47:35.760
P元数

47:35.760 --> 47:36.760
P元数里面是什么呢

47:36.760 --> 47:38.760
是学生的名字

47:38.760 --> 47:41.320
对吧

47:41.320 --> 47:42.320
然后呢

47:42.320 --> 47:43.320
我输出看一下Result

47:43.320 --> 47:46.400
是不是宿主

47:46.400 --> 47:47.400
宿主的第一项

47:47.400 --> 47:48.400
学生变成这个了

47:48.400 --> 47:49.400
第二项

47:49.400 --> 47:50.400
那个学生对象变成这个了

47:50.400 --> 47:51.400
是不是印射

47:51.400 --> 47:53.400
那现在我要把它连起来

47:53.400 --> 47:54.400
把这一批元数

47:54.400 --> 47:55.400
所有制服串连起来

47:55.400 --> 47:56.400
形成一个ATM变段

47:56.400 --> 47:58.400
那跟刚才不是一样吗

47:58.400 --> 47:59.400
只不过我这里不用

47:59.400 --> 48:00.400
兜号连接

48:00.400 --> 48:01.400
用空制服串连接

48:01.400 --> 48:02.400
就连成那个制服串

48:02.400 --> 48:07.250
明白吧

48:07.250 --> 48:08.250
上节课

48:08.250 --> 48:10.250
咱们是不是做过一件事

48:10.250 --> 48:14.270
拼接那个一个模板制服串

48:14.270 --> 48:16.270
一个电影就是个模板制服串

48:16.270 --> 48:17.270
然后呢

48:17.270 --> 48:18.270
把模板制服串全部加起来

48:18.270 --> 48:19.270
形成一个ATM变段

48:19.270 --> 48:21.270
然后加到容器里面去

48:21.270 --> 48:23.270
你可以尝试一下用Map怎么做

48:23.270 --> 48:25.270
我那里就直接给你

48:25.270 --> 48:26.270
一个电影数组

48:26.270 --> 48:27.270
你只需要把每一个电影

48:27.270 --> 48:29.270
印射成为一个制服串

48:29.270 --> 48:31.270
然后再把制服串就连接起来

48:31.270 --> 48:34.270
就是直接形成ATM变段

48:34.270 --> 48:38.280
你都不用循环

48:38.280 --> 48:39.280
可以去尝试一下

48:39.280 --> 48:42.280
得到所有女生的新民数组

48:42.280 --> 48:43.280
刚才我们得到的是

48:43.280 --> 48:46.280
所有学生的新民数组

48:46.280 --> 48:47.280
这是得到所有的

48:47.280 --> 48:49.280
学生的新民数组

48:49.280 --> 48:55.220
现在我要得到女生

48:55.220 --> 48:59.530
那就是先筛选

48:59.530 --> 49:01.530
先筛选

49:02.530 --> 49:04.530
你必须得是个女生

49:04.530 --> 49:06.530
其他的学生我不要

49:06.530 --> 49:09.680
先筛选

49:09.680 --> 49:10.680
这个筛选完了过后

49:10.680 --> 49:11.680
是不是一个数组

49:11.680 --> 49:12.680
你看这个表达是

49:12.680 --> 49:13.680
这是电视编程

49:13.680 --> 49:15.680
这个就是一个数组

49:15.680 --> 49:16.680
他筛选完了过后

49:16.680 --> 49:17.680
这个是不是返回新的数组

49:17.680 --> 49:18.680
新的数组只有女生

49:18.680 --> 49:19.680
对吧

49:19.680 --> 49:20.680
然后对这个新的数组

49:20.680 --> 49:21.680
再进行印射

49:21.680 --> 49:23.680
是不是就只印射了女生

49:23.680 --> 49:24.680
对不对

49:24.680 --> 49:25.680
那如说你这个东西

49:25.680 --> 49:27.680
实在太牢火了

49:27.680 --> 49:29.680
感觉脑袋快爆青烟了

49:29.680 --> 49:30.680
那么这个时候

49:30.680 --> 49:31.680
你就可以先这样吧

49:31.680 --> 49:33.680
Girls你先用一个变量

49:33.680 --> 49:34.680
一个变量来嘛

49:34.680 --> 49:35.680
我也不知道这有多大

49:35.680 --> 49:36.680
多大的区别

49:36.680 --> 49:37.680
然后呢

49:37.680 --> 49:38.680
这边就用那个Girls

49:38.680 --> 49:40.680
来去印射嘛

49:40.680 --> 49:41.680
先拿到女生

49:41.680 --> 49:43.680
然后再把女生来进行印射

49:43.680 --> 49:45.680
对吧

49:45.680 --> 49:46.680
不要看名字

49:46.680 --> 49:48.680
名字是谁生的

49:48.680 --> 49:49.680
先用Fiora

49:49.680 --> 49:50.680
是不是拿到所有的女生

49:50.680 --> 49:51.680
对这个女生的数组

49:51.680 --> 49:52.680
再进行印射

49:52.680 --> 49:53.680
这又啥区别呢

49:53.680 --> 49:54.680
因为这个表达是

49:54.680 --> 49:55.680
就是保持那变量里面

49:55.680 --> 49:56.680
这个表达是

49:56.680 --> 49:57.680
他把表达是

49:57.680 --> 49:58.680
只保存变量里面

49:58.680 --> 49:59.680
那这个变量跟这个表达

49:59.680 --> 50:00.680
是不是不一样的

50:00.680 --> 50:01.680
你直接拿过来不一样

50:01.680 --> 50:06.930
好

50:06.930 --> 50:07.930
然后再来

50:07.930 --> 50:08.930
当然了

50:08.930 --> 50:09.930
你可不可以

50:09.930 --> 50:11.930
先印射再筛选了可以

50:11.930 --> 50:12.930
只不过呢

50:12.930 --> 50:13.930
你先印射再筛选的话

50:13.930 --> 50:14.930
效率不是那么好

50:14.930 --> 50:16.930
因为比方说有

50:16.930 --> 50:17.930
我举个例子

50:17.930 --> 50:18.930
比方说有一百

50:18.930 --> 50:19.930
一千个学生

50:19.930 --> 50:20.930
九百个是男生

50:20.930 --> 50:21.930
一百个是女生

50:21.930 --> 50:22.930
我觉得夸张一点

50:22.930 --> 50:23.930
那你先印射的话

50:23.930 --> 50:25.930
是不是还得印射一千遍

50:25.930 --> 50:26.930
因为男生也要印射

50:26.930 --> 50:27.930
女生也要印射

50:27.930 --> 50:28.930
对不对

50:28.930 --> 50:29.930
印射完了过后

50:29.930 --> 50:31.930
结果你把男生去掉了

50:31.930 --> 50:33.930
那如果说你是先筛选的话

50:33.930 --> 50:34.930
你只保留了女生

50:34.930 --> 50:35.930
只保留了一百个女生

50:35.930 --> 50:36.930
那我印射的时候

50:36.930 --> 50:38.930
只会印射一百次就OK了

50:38.930 --> 50:39.930
有个小的细节

50:44.760 --> 50:46.760
得到所有女生的姓名

50:46.760 --> 50:50.670
和电话号码

50:50.670 --> 50:51.670
干嘛呀

50:51.670 --> 50:56.880
所有女生是不是先筛选

50:56.880 --> 50:58.880
重新写一遍吧

50:58.880 --> 51:01.880
Students filter

51:01.880 --> 51:03.880
先筛选

51:03.880 --> 51:04.880
只要女生

51:04.880 --> 51:06.880
所以说返回的是

51:06.880 --> 51:09.880
sax等于

51:09.880 --> 51:10.880
那么这是一个表达式

51:10.880 --> 51:11.880
这是一个返回了

51:11.880 --> 51:12.880
所有的女生的数数

51:12.880 --> 51:14.880
这就是所有的女生对象

51:14.880 --> 51:16.880
然后对一个女生对象

51:16.880 --> 51:21.980
来进行印射

51:21.980 --> 51:23.980
每一个女生对象

51:23.980 --> 51:24.980
它变成什么呢

51:24.980 --> 51:25.980
变成这种格式

51:25.980 --> 51:27.980
我只要这两个属性

51:27.980 --> 51:28.980
其他的属性我不要

51:28.980 --> 51:30.980
所以说我这里返回了对象

51:30.980 --> 51:32.980
返回一个新的对象

51:32.980 --> 51:33.980
这个新的对象里边

51:33.980 --> 51:34.980
只有name属性

51:34.980 --> 51:38.290
还有什么tail属性

51:38.290 --> 51:42.630
我只要这两个属性

51:42.630 --> 51:43.630
其他的属性我不要

51:43.630 --> 51:44.630
我就返回一个新的对象

51:44.630 --> 51:45.630
把这个学生对象

51:45.630 --> 51:47.630
印射成为这个学生对象

51:47.630 --> 51:49.630
最后得到印射的结果

51:49.630 --> 51:55.840
这是这一块

51:55.840 --> 51:59.840
得到所有学生的年龄的总和

51:59.840 --> 52:05.070
这个reduce

52:05.070 --> 52:06.070
贵总

52:06.070 --> 52:08.070
把所有东西揉成一块

52:08.070 --> 52:10.070
那么这里怎么来

52:10.070 --> 52:13.070
students reduce

52:13.070 --> 52:15.070
有两个参数对不对

52:15.070 --> 52:17.070
A和B

52:17.070 --> 52:20.640
这里的默认值是什么呢

52:20.640 --> 52:21.640
求和的默认值

52:21.640 --> 52:22.640
就是一个学生

52:22.640 --> 52:23.640
就想这个地方怎么写

52:23.640 --> 52:25.640
就是一个学生都没有的情况下

52:25.640 --> 52:26.640
那么总和是多少

52:26.640 --> 52:28.640
那就是0倍

52:28.640 --> 52:29.640
那么就又来了

52:29.640 --> 52:31.640
他就首先把0传给A

52:31.640 --> 52:33.640
然后把第一个学生传给B

52:33.640 --> 52:35.640
那么B是啥类型

52:35.640 --> 52:37.640
B就是个学生对象

52:37.640 --> 52:38.640
A是什么类型

52:38.640 --> 52:39.640
A是数字

52:39.640 --> 52:41.640
A是目前的贵总

52:41.640 --> 52:44.640
目前贵总的结果

52:44.640 --> 52:46.640
那么就说我要做什么

52:46.640 --> 52:49.640
返回A加上B的A级

52:54.000 --> 52:56.000
上求和

52:56.000 --> 52:57.000
输出

52:57.000 --> 52:59.000
所有的学生的年龄总和

52:59.000 --> 53:01.000
就是1000度

53:01.000 --> 53:02.000
他把第一个学生

53:02.000 --> 53:03.000
还有先把0

53:03.000 --> 53:04.000
之前解释过的

53:04.000 --> 53:06.000
如果这一块搞不清楚的话

53:06.000 --> 53:07.000
回看之前的那个

53:07.000 --> 53:09.000
我讲reduce的那一块

53:09.000 --> 53:11.000
我把他先把0传给A

53:11.000 --> 53:13.000
然后把第一个学生给B

53:13.000 --> 53:14.000
那么我返回了什么

53:14.000 --> 53:16.000
0加上第一个学生的年龄

53:16.000 --> 53:17.000
然后他会记录下来

53:17.000 --> 53:19.000
记录到这个reduce里边

53:19.000 --> 53:20.000
就第一个年龄

53:20.000 --> 53:21.000
比方说15吧

53:21.000 --> 53:23.000
然后又把这个15传给A

53:23.000 --> 53:25.000
又把第二个学生对象传给B

53:25.000 --> 53:26.000
然后就是15

53:26.000 --> 53:28.000
加上第二个学生对象的年龄

53:28.000 --> 53:29.000
那么比方加出来就是

53:29.000 --> 53:30.000
事实

53:30.000 --> 53:31.000
他会把这个返回结果

53:31.000 --> 53:32.000
返回到这个事实

53:32.000 --> 53:34.000
又存到reduce里边

53:34.000 --> 53:35.000
就一项一项去哪家

53:35.000 --> 53:36.000
最后哪家完了过后

53:36.000 --> 53:38.000
就把reduce返回给上

53:38.000 --> 53:43.590
得到所有学生的平均年龄

53:51.920 --> 53:53.920
我就不知道有什么好说的

53:54.920 --> 53:56.920
得到一个对象

53:57.920 --> 53:59.920
对象是这么多

53:59.920 --> 54:00.920
这种格式

54:00.920 --> 54:01.920
这个发挥点想象力

54:04.420 --> 54:05.420
我有很多学生

54:05.420 --> 54:07.420
我要把学生变成这个样子

54:07.420 --> 54:08.420
就一个对象

54:08.420 --> 54:09.420
不是一个宿主

54:09.420 --> 54:10.420
是一个对象

54:10.420 --> 54:11.420
对象里面的NEM

54:11.420 --> 54:13.420
记录了所有学生的名字

54:13.420 --> 54:14.420
所有的学生的名字

54:14.420 --> 54:17.420
A记录了所有学生的年龄

54:17.420 --> 54:20.310
这个该咋做

54:20.310 --> 54:22.310
本质上是啥

54:22.310 --> 54:23.310
本质上

54:23.310 --> 54:25.310
我是要把一个宿主

54:26.310 --> 54:27.310
变成什么

54:27.310 --> 54:28.310
一个对象

54:32.350 --> 54:33.350
你看这个图地吧

54:33.350 --> 54:35.350
哪个是比较符合的

54:35.350 --> 54:36.350
看看图地就行了

54:37.350 --> 54:38.350
哪个是比较符合的

54:38.350 --> 54:41.110
哪个

54:44.250 --> 54:46.250
是不是还是得汇总

54:46.250 --> 54:47.250
你不能feel it

54:47.250 --> 54:48.250
feel it就是

54:48.250 --> 54:49.250
有些学生不要了

54:49.250 --> 54:50.250
有些人保留

54:50.250 --> 54:51.250
得到了还是宿主

54:51.250 --> 54:52.250
MAP是什么

54:52.250 --> 54:53.250
应设

54:53.250 --> 54:54.250
还是宿主

54:54.250 --> 54:55.250
只能这么做什么

54:55.250 --> 54:56.250
还是汇总

54:56.250 --> 54:57.250
我把这些学生

54:57.250 --> 54:58.250
是不是还是汇总

54:58.250 --> 55:00.250
它是汇总的格式不一样

55:00.250 --> 55:02.250
还是汇总成一个对象

55:02.250 --> 55:03.250
那我们来汇总

55:03.250 --> 55:05.250
我们来看一下代码大型

55:05.250 --> 55:07.250
students reduce

55:08.250 --> 55:10.250
然后默认值是什么

55:10.250 --> 55:12.250
你又想一个学生都没有

55:13.250 --> 55:14.250
一个学生都没有的话

55:14.250 --> 55:15.250
那么这个默认值

55:15.250 --> 55:17.250
汇总的结果是啥

55:17.250 --> 55:19.250
是不是就这么一个对象

55:19.250 --> 55:20.250
对象里面有个name属

55:20.250 --> 55:21.250
现在是个空输主

55:21.250 --> 55:23.250
A级是个空输主

55:23.250 --> 55:24.250
对吧

55:24.250 --> 55:25.250
是这么种情况

55:25.250 --> 55:27.250
如果说它一个学生都没有

55:27.250 --> 55:28.250
是不是得到的结果

55:28.250 --> 55:29.250
应该是这个

55:29.250 --> 55:31.760
对不对

55:31.760 --> 55:33.760
好那么这里边怎么写

55:34.760 --> 55:35.760
不好意思

55:35.760 --> 55:36.760
那么还是一样的道理

55:36.760 --> 55:38.760
它首先把它传给A

55:38.760 --> 55:40.760
然后把第一个学生传给B

55:40.760 --> 55:42.760
你要做啥

55:42.760 --> 55:46.070
同学你要做啥

55:46.070 --> 55:48.070
把它传给A

55:48.070 --> 55:49.070
第一个学生传给B

55:49.070 --> 55:50.070
是不是你要把

55:50.070 --> 55:51.070
第一个学生的名字加到这

55:51.070 --> 55:53.070
第一个学生的年龄加到这

55:55.070 --> 55:56.070
A点什么name

55:56.070 --> 55:57.070
push

55:57.070 --> 55:59.070
B点name

56:00.070 --> 56:02.070
A点A级

56:02.070 --> 56:04.070
push B点A级

56:04.070 --> 56:06.070
然后呢返回这个A

56:06.070 --> 56:07.070
对吧

56:07.070 --> 56:08.070
然后呢

56:08.070 --> 56:09.070
第一个学生完了过后

56:09.070 --> 56:10.070
那么这个对象

56:10.070 --> 56:12.070
里面是不是就记住了东西了

56:13.070 --> 56:14.070
你看吧

56:14.070 --> 56:15.070
这样子

56:15.070 --> 56:18.070
一开始这个记住的结果是这个

56:18.070 --> 56:19.070
name

56:19.070 --> 56:21.070
空的对吧

56:21.070 --> 56:22.070
A级

56:22.070 --> 56:23.070
空的

56:23.070 --> 56:24.070
然后呢运行函数

56:24.070 --> 56:25.070
运行函数的话

56:25.070 --> 56:28.070
一开始是不是把这个东西传给了A

56:28.070 --> 56:30.070
都还是一样的道理吧

56:30.070 --> 56:32.070
然后第一个学生传给了B

56:32.070 --> 56:33.070
对吧

56:33.070 --> 56:34.070
第一个学生给了B

56:34.070 --> 56:35.070
然后我们把

56:35.070 --> 56:37.070
第一个学生的name

56:37.070 --> 56:39.070
加到A的name里边去

56:39.070 --> 56:41.070
然后第一个学生的年龄加到A的name

56:41.070 --> 56:42.070
A级里边去

56:42.070 --> 56:44.070
那么你看一下结果是这样子

56:44.070 --> 56:46.070
第一个学生的当三吗

56:46.070 --> 56:48.070
第一个学生的年龄

56:48.070 --> 56:49.070
17吗

56:49.070 --> 56:51.070
就加到数组里边去了

56:51.070 --> 56:52.070
好那么返回返回A

56:52.070 --> 56:53.070
返回A的话

56:53.070 --> 56:54.070
那个记录里边数就加到

56:54.070 --> 56:55.070
就变成这个样子了

56:55.070 --> 56:56.070
然后接下来

56:56.070 --> 56:57.070
第二项

56:57.070 --> 56:59.070
第二项又把它传给A

56:59.070 --> 57:00.070
又把第二个学生传给B

57:00.070 --> 57:01.070
是不是又来一次

57:01.070 --> 57:03.070
又加了一个学生的 name

57:03.070 --> 57:04.070
又加一个学生的年龄

57:04.070 --> 57:05.070
对吧

57:05.070 --> 57:06.070
这就是汇总

57:06.070 --> 57:08.070
汇总他不一定是一定是求和

57:08.070 --> 57:10.070
总之把一坨的东西变成一个东西

57:10.070 --> 57:11.070
就是汇总

57:11.070 --> 57:12.070
好

57:12.070 --> 57:14.070
那么汇总完成我们来看一下

57:14.070 --> 57:15.070
你看如果说

57:15.070 --> 57:16.070
这个东西要用以前的代码

57:16.070 --> 57:17.070
能不能写

57:17.070 --> 57:18.070
肯定是能写的

57:18.070 --> 57:19.070
用循环吧

57:19.070 --> 57:21.070
就是就没有这个代码写

57:21.070 --> 57:23.070
代码写出来简洁

57:23.070 --> 57:25.070
你看nameA级

57:25.070 --> 57:26.070
说出来了

57:26.070 --> 57:28.070
好 这道题

57:28.070 --> 57:29.070
下一道题

57:29.070 --> 57:32.070
找到ID为这个的学生对象

57:32.070 --> 57:35.070
找到其中某一个学生

57:35.070 --> 57:39.070
就在数据中找一个满足条件的那一项

57:39.070 --> 57:41.070
用啥

57:41.070 --> 57:43.070
是fan的

57:43.070 --> 57:46.070
找到满足条件的那一项

57:46.070 --> 57:47.070
第一个满足条件的那一项

57:47.070 --> 57:49.070
那么就是students

57:49.070 --> 57:50.070
fan的

57:50.070 --> 57:53.070
写法跟那个sum是一样的

57:54.070 --> 57:55.070
条件是什么呢

57:55.070 --> 57:57.070
学生的ID要等于

57:57.070 --> 57:59.070
79

57:59.070 --> 58:01.070
6997

58:01.070 --> 58:05.400
如果说找不到的话

58:05.400 --> 58:06.400
反正就是null

58:06.400 --> 58:07.400
大家说一下

58:07.400 --> 58:12.570
如果找不到反正就是null

58:12.570 --> 58:13.570
运行

58:13.570 --> 58:15.570
你看 出来了

58:15.570 --> 58:17.570
找了那一项

58:17.570 --> 58:21.570
是否包含年龄大于28岁的男生

58:21.570 --> 58:22.570
得到的是什么

58:22.570 --> 58:23.570
得到的是true and false

58:23.570 --> 58:24.570
是否包含

58:24.570 --> 58:27.200
sum

58:27.200 --> 58:28.200
对不对

58:28.200 --> 58:29.200
至少有一个包含就行

58:29.200 --> 58:31.200
students

58:31.200 --> 58:36.180
sum

58:36.180 --> 58:38.180
function

58:38.180 --> 58:40.180
sum

58:40.180 --> 58:41.180
条件是什么呢

58:41.180 --> 58:43.180
条件是学生的年龄要大于

58:43.180 --> 58:44.180
等于

58:44.180 --> 58:45.180
大于28岁

58:45.180 --> 58:47.180
他就写完了

58:47.180 --> 58:48.180
对吧

58:48.180 --> 58:49.180
然后反复了一个结果

58:49.180 --> 58:51.180
就是什么true and false

58:51.180 --> 58:53.180
到底有没有这样的学生存在

58:53.180 --> 58:55.180
输出readout

58:55.180 --> 58:57.180
让你先看一下

58:57.180 --> 58:58.180
true

58:58.180 --> 58:59.180
对吧 有这样的学生

58:59.180 --> 59:01.180
然后再下一题

59:01.180 --> 59:03.180
是否所有的女

59:03.180 --> 59:05.180
所有的学生年龄女生

59:05.180 --> 59:07.180
年龄都在28岁以内

59:07.180 --> 59:09.180
那首先你要筛选女生对吧

59:10.180 --> 59:11.180
找到所有的女生

59:16.180 --> 59:18.180
然后看一下这些女生当中

59:18.180 --> 59:19.180
是不是所有的女生

59:19.180 --> 59:21.180
every

59:21.180 --> 59:23.180
的年龄都在28岁以内

59:23.180 --> 59:27.320
小微等于28

59:27.320 --> 59:28.320
false对吧

59:28.320 --> 59:30.320
有些学生可能在28岁以上

59:30.320 --> 59:32.320
就完了

59:32.320 --> 59:34.320
那这就是咱们这节课

59:34.320 --> 59:36.320
学习的东西

59:36.320 --> 59:37.320
不要去背啊

59:37.320 --> 59:38.320
背不住的

59:38.320 --> 59:40.320
你就

59:40.320 --> 59:42.320
大概了解一下

59:42.320 --> 59:44.320
多了很多的数组API

59:44.320 --> 59:46.320
我们最常见的

59:46.320 --> 59:48.320
就是for each

59:48.320 --> 59:49.320
map

59:49.320 --> 59:50.320
filter

59:50.320 --> 59:52.320
Reduce都用的很少

59:52.320 --> 59:54.320
还有一个fand

59:54.320 --> 59:55.320
有的时候用intl

59:55.320 --> 59:57.320
最常见的就是map filter

59:57.320 --> 59:59.320
以及for each

59:59.320 --> 01:00:00.320
这就是咱们这里

01:00:00.320 --> 01:00:02.320
可能那种数组API

