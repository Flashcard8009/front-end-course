WEBVTT

00:00.000 --> 00:20.350
说一下 因为有些同学呢 学到现在啊 学到运算服务的中心啊 就已经开始出现了我最开始说的

00:20.910 --> 00:26.670
浮躁的问题了 因为他觉得学到这么多东西了 为什么还不能做出一个效果出来

00:27.390 --> 00:34.670
呃 我首先要告诉你啊 实话实说 要做出一些不要说效果了啊 不要说什么页面的一些丰富的效果

00:35.390 --> 00:42.510
呃 就是做一个简单的 一个跟数据相关的应用啊 比方说啊 你输入一个考试分数

00:42.990 --> 00:49.790
然后呢 我输出一个理极格了 还是没有极格 就这些简单的应用呢 就到目前呢 我们都还做不了

00:50.190 --> 00:57.070
这也是我为什么在例子里边没有去使用这些实际的例子的原因 前边呢 我讲

00:57.550 --> 01:01.550
加了一些例子啊 就是个在算数运算服这一块啊 我加了一些例子

01:01.870 --> 01:06.030
就是关于什么算以什么温度软化期啊 利息计算期 这些简单的例子

01:06.590 --> 01:10.110
就连这些例子呢都很难找 因为呢 你可以这样理解啊

01:10.670 --> 01:14.350
既也是与法基础这一块呢 咱们学习的是变量和

01:15.070 --> 01:23.790
什么数据类型 对吧 那个呢就相当于是呢 相当于你是学中文学了认字啊 你把字会写了 回认了

01:24.670 --> 01:28.750
运算服这一块相当于啥呢 相当于你学习的是主词

01:29.470 --> 01:36.510
把字组成一个词语 这个词语是什么含义啊 相当于啊 随便举个例子啊 就相当于是学到这个阶段

01:37.070 --> 01:44.990
那你光会主词了过后还不行 你还没有形成完整的句子 你得等到下一张 下一张学习过后就可以做很多东西了

01:45.550 --> 01:47.870
很多有意义的有意识的事情都可以做了

01:48.510 --> 01:54.990
比方说什么一些应用题啊 对吧 跟数学相关的 跟数字相关的一些应用题 我们都可以用程序来解了

01:55.390 --> 01:59.550
因为下一张学习的过后呢 才学习的 相当于是学中文学了

02:00.190 --> 02:04.430
照句啊 你可以写出一个完整的句子 一个完整的含义才出来了

02:04.830 --> 02:09.390
所以说这一张里边呢 我很难啊 脚筋脑子也很难想到一些

02:09.870 --> 02:14.910
有有意义的例子啊 当然可以做一些例子 比方说什么球员的面积啊

02:15.390 --> 02:21.390
球举行的周长啊 去举行 球举行的面积啊 这些东西 其实那些东西呢也意义不大

02:21.710 --> 02:26.830
因为你学的算数运算幅科 就马上就可以做了 就不去说安倍对吧 圆的周长面积

02:27.390 --> 02:34.350
相乘对吧 二派二 什么周长对吧 派二的平方啊 什么举行的面积

02:34.590 --> 02:38.670
长生一宽 这些东西都没有多少意义啊 所以说当时举了两个例子

02:39.150 --> 02:42.990
举了两个例子 这两个例子做完了也就差不多了啊 就差不多了

02:43.950 --> 02:48.910
所以我们老老实实学啊 不要好高勿远 咱们先把基础给他打扎死了

02:49.470 --> 02:54.350
然后呢 后边效果自然而然就出来了啊 现在呢 我们的知识量还不够

02:55.470 --> 03:00.430
好吧 我先说一下这个问题啊 大家心里边不要补浮躁 始终记住我一开始说的话

03:00.990 --> 03:07.070
每一天给自己定一个小目标 我们看到哪节课你就不要想其他的 你就把这节课

03:07.470 --> 03:14.910
听懂 然后呢 把我课堂上我做的例子呢 那些吃透 自己去写一遍啊 把它理解了就行了

03:15.630 --> 03:21.630
好吧 这是关于啊 就是我们课前说一个问题啊 说这个问题 因为根据我先下的受贺经验的话

03:22.110 --> 03:24.110
到这个阶段呢 容易出现这个问题啊

03:25.310 --> 03:28.110
啊 这节课呢 逻辑运算服

03:28.830 --> 03:32.990
逻辑运算服呢 它也叫做布尔运算服 都一个意思啊

03:33.470 --> 03:37.230
它里边呢 就三个 一个是雨 一个是货

03:37.790 --> 03:43.870
一个是飞 就这么三个运算服 所以说我们这节课啊 讲的东西呢 知识面呢其实很小

03:44.110 --> 03:45.870
就这么三个运算服 讲完就完事

03:46.510 --> 03:50.670
一个是雨 雨呢 它也叫做并且啊 并且运算服

03:51.070 --> 03:56.910
啊 我们一个个说啊 第一个是雨 第二个是呢 是货 第三个的是飞啊 一个个说

03:57.870 --> 04:04.350
好 雨这个运算服呢 咱们来看一下它有哪些规则 它的符号呢 是两个啊

04:05.310 --> 04:12.190
这个符号叫它符号呢 这个符号就叫做并且符号啊 有的时候我们也没有说它是啥子符号 有的时候就说的是n的符号

04:13.150 --> 04:22.510
这个是and符号 就是和或者是并且的意思 咱们呢就把它称之为并且符号 或者叫做and符号

04:22.830 --> 04:29.710
注意啊 这里是两个and啊 千万不要写成一个了 一个能不能写呢 能写 但是一个的意思不一样啊

04:30.510 --> 04:34.510
一个的意思呢 是我们后边讲的运算服 所以说一定要写两个啊

04:35.070 --> 04:41.230
好 这是and 那么这两个符号呢 它的写法呢 书写方式啊 它是这样写的

04:41.870 --> 04:42.830
表达是1

04:44.190 --> 04:44.590
并且

04:45.310 --> 04:50.510
表达是2啊 它这样子写的 那它怎么运算的呢 它怎么来算呢

04:51.150 --> 04:58.350
你看 并且大家都知道什么意思 对吧 真真为真啊 其他为假就两个条件都要满足

04:59.790 --> 05:05.070
才叫做并且 对吧 才叫做并且 比方说咱们要考公务员 举个例子吧啊

05:05.710 --> 05:11.390
要考公务员啊 公务员的话必须要是大学毕业啊 本科专科都行

05:11.790 --> 05:22.350
大学毕业 然后连满22岁啊 是不是两个条件 对吧 两个条件都要满足 但我随便说了啊 两个条件都要满足 这就是并且

05:23.550 --> 05:26.510
好 那么它到底是怎么运算的呢 我们这里要说技术问题啊

05:27.230 --> 05:35.390
它的运算方式是 第一个 将表达是1啊 将表达是1进行什么

05:35.950 --> 05:44.830
布尔判定啊 进行布尔判定 什么叫布尔判定 如果表达是1 本身就是一个布尔啊 本身就是一个布尔

05:45.310 --> 05:50.430
ok 那就简单了 那你是真 那我就把你当成真 你是假 我就把你当成假

05:50.990 --> 05:55.710
如果你不是一个布尔类型 那表达是1 比方说表达是1这一块 它有可能是写个字无创

05:56.190 --> 06:02.110
有可能写个数字123 有可能写一个undefend 有可能给一个对象 什么都有可能

06:02.910 --> 06:09.310
所以说不管你写的是啥 我都要进行布尔判定 那么怎么判定的呢 怎么判定的呢

06:10.990 --> 06:16.670
一个规则就是非常非常简单啊 这一块是个重要规则 它不是应付面数的 是非常重要的

06:17.070 --> 06:33.870
就是以下数据均判定为force 以下数据均判定为force 哪些数据呢 第一个数据就是now

06:34.830 --> 06:38.750
now它判定为force 第二个undefend

06:39.630 --> 06:40.430
undefend

06:41.390 --> 06:43.790
不这样子 他怎么能自动割出来

06:44.990 --> 06:47.550
undefend 判定为force 还有呢

06:49.390 --> 06:54.430
force 布尔 布尔类型force本身 他也判定为force 这个没啥好说的

06:55.230 --> 07:05.150
第四个 第四个的话是nan 非数字 如果是这种类型的话 他也判定为force

07:05.790 --> 07:13.390
第五个 第五个是一个空置无串 是一个空置无串 好 空置无串他也判定为force

07:14.110 --> 07:19.710
我想想啊 想想还有什么 还有个数字零 数字零他也判定为force

07:20.190 --> 07:23.230
这些数据均判定为force

07:24.110 --> 07:24.830
其他的

07:26.110 --> 07:31.150
其他数据全部为真 全部为真 简单吧 说非常简单

07:31.630 --> 07:38.750
你看一下 其实也很好理解 零表示没有 对吧 闹表示没有 undefend表示未定义force的肯定force

07:39.310 --> 07:45.710
na表示不是什么 不是非数 就是不是一个数字 不是正常的情况 空置无串表示没有东西 你看

07:46.030 --> 07:51.710
都表示没有不是的意思 对吧 那么这些东西都判定为force 其他的全部判定为真

07:52.830 --> 07:57.470
好 这是关于表达是一的判定 他要先对表达是一进行判定

07:58.270 --> 07:58.830
进行判定

07:59.550 --> 08:05.950
好 接下来第二步 他就这么两步 第二步是什么 表达是一是不是判定出来了啊 根据

08:06.350 --> 08:09.230
管他什么数据 你只要能判定出真假就完事了

08:10.430 --> 08:15.310
如果表达是一的判定结果为假

08:16.350 --> 08:21.630
则直接返回表达是一而不执行

08:22.830 --> 08:26.670
不执行表达是二 我先说啊 说完了再举例子

08:27.630 --> 08:33.630
否则返回表达是二的结果

08:35.230 --> 08:39.150
什么意思 就是说 如果这个地方他判定的结果是假

08:40.190 --> 08:46.190
不用执行表达是二了 直接把表达是一直接返回 把表达是一的结果直接返回

08:47.070 --> 08:52.830
如果表达是一的结果为真 判定结果为真 ok 那就把表达是二的结果返回

08:53.310 --> 08:57.870
明白这个意思吧 好 他为什么要这样子 有这样的规则呢 你想啊 并且

08:59.070 --> 09:01.950
并且是什么 真真为真 对吧 假假其他为假

09:02.910 --> 09:06.670
如果表达是一的结果 已经都判定出来是假了

09:07.710 --> 09:14.030
那表达是二还冷 还需要判定吗 是不需要了 考官务员 你必须要是大学毕业

09:14.590 --> 09:16.910
第二呢 必须要年慢22周岁

09:17.630 --> 09:21.710
你第一个条件 你是一个高中毕业的 或者是你是一个初中毕业的

09:21.950 --> 09:27.230
第一个条件都不满足 还需要看第二个条件吗 不用看了啊 第二条件管理市场都

09:27.870 --> 09:31.870
都不用去考了 都不用报名了 对吧 是这个也含义吧 这就是并且

09:32.510 --> 09:38.430
所以说 由于它是并且这个逻辑关系在这 因此呢 表达是一一旦判定为 force

09:38.830 --> 09:42.590
那么后边就不再运行了 好 咱们来看一下啊 举些例子

09:43.790 --> 09:50.240
tess1 咱们来举些例子啊 好 比方说现在几个简单的吧

09:50.960 --> 10:01.440
比方说5大于3并且3大于2 好 那么它输出的是啥 输出的是整个表达式的结果 对吧

10:02.880 --> 10:06.480
输出的是整个表达式的结果 那么整个表达式它是怎么算的呢

10:07.120 --> 10:13.520
左边一个表达式 右边一个表达式 看来它左边一个表达式 右边一个表达式

10:14.000 --> 10:16.080
好 先算左边这个表达式

10:16.800 --> 10:19.920
左边这个表达式 算出来是什么呢 算出来是不是

10:20.960 --> 10:25.440
q 对吧 q 好 那么它的判定结果是啥 还用说吗

10:25.840 --> 10:31.600
它的判定结果一定是q 对吧 一定是q 好 它的判定结果为q 要不要看第二个表达式

10:32.240 --> 10:35.120
要不要看第二个表达式 我们刚才怎么说的

10:36.160 --> 10:38.080
如果第一个表达式判定结果为假的

10:39.280 --> 10:42.960
好 否则 否则是什么意思啊 否则就是第一个表达式判定结果为真

10:43.680 --> 10:46.800
好 判定结果为真的话 直接返回表达式二的结果

10:47.440 --> 10:54.320
那么这个代码就整个这个表达式就相当于是啥呢 相当于是第二个表达式

10:54.880 --> 10:59.600
对吧 是这个道理吧 你第一个条件满足了 那我只需要看第二个条件就行了

11:00.240 --> 11:05.840
就相当于是第二个表达式 那你说这个输出啥 输出q 对吧 输出q

11:06.400 --> 11:14.080
好 那么看一下呗 好 看一下 运行 看一下啊

11:15.040 --> 11:20.800
你看 刷新啊 你看说不说结果是不是q 对吧q 好 再来啊 再一个例子

11:21.440 --> 11:28.880
console log 好 比方说啊 比方说 我们写一个五大于三并且

11:29.600 --> 11:34.160
一百 好 随便瞎写 并且一百 那么这个输出啥呢

11:35.040 --> 11:40.080
又来呗 又来 先判判断表达式一 表达式一的

11:40.880 --> 11:46.160
值是什么 算出来啊 把算出来 表达式一的值是啥 表达式一的值是不是q 对吧

11:46.800 --> 11:52.960
那第一个条件为真的 表达式一为真的 那么是不是直接返回第二个表达式的结果 对吧 相当于是直接输出了一百

11:53.600 --> 11:59.760
对不对 他就这样子玩的 他是这样子玩的 好 保存输出看一下 输出的结果就是一百

12:00.080 --> 12:06.800
看呗 好 再来个例子啊 其实通过这个例子也可以看出来 他的优先级是不是比较低的

12:07.280 --> 12:17.600
比比较运算幅还要低 你看 算数运算幅的优先级要比什么 比较运算幅高 然后呢 比较运算幅的优先级呢 要比并 要比这个与运算要高

12:18.240 --> 12:20.960
他的优先级是很低的 他比比较运算幅要低

12:21.520 --> 12:23.600
所以说要先算他 然后再算并且

12:24.560 --> 12:32.640
其实优先级这一块啊 所以说我没有没有去刻意去讲每一个运算幅的优先级 其实要讲的话 有一个很大很大的标哥

12:33.200 --> 12:40.400
我没有刻意去讲 为什么呢 因为在这个世界上啊 我也不说那么绝对吧 至少我见过这么多的开发者

12:40.800 --> 12:44.480
我没有见过任何一个开发者 能够把所有的运算幅的优先级全部搞清楚

12:45.680 --> 12:49.840
他不是说他难 只是这件事了没有必要 没有必要去这样做

12:50.400 --> 12:56.320
因为平时呢 我们如果一个表达是写的很长了 遇到了很多的运算幅 搞不清楚优先级了 做什么

12:56.800 --> 13:02.640
加小括号就完了啊 加小括号 因为小括号的优先级是不是最高的 一定是先算小括号的

13:02.880 --> 13:07.760
所以加小括号就完事了啊 那么就可以解决这些问题了 因此没有必要去背啊

13:08.000 --> 13:15.360
我们只是常见的一些啊 就是优先级的 你知道就行了 比方说啊 比较运算幅的优先级肯定是要搞与他的 所以说先算他

13:16.240 --> 13:19.520
好 那么这个输出的结果就是一半啊 刚才看到了 他结果就是一半

13:20.800 --> 13:22.640
好 ok 再来个例子啊 再来个例子

13:23.440 --> 13:24.000
console log

13:25.200 --> 13:32.000
好 三 并 我说的是零并且二啊 零并且二 他输出啥呢

13:33.040 --> 13:36.880
这是啥玩意儿呢 这个玩意儿写的好奇怪 但是他

13:37.600 --> 13:40.960
可以这样子写的啊 虽然那个代码写上 写起来比较奇怪啊

13:41.680 --> 13:46.960
一般的情况下呢 这个并且啊 左右两边的一般都是布尔啊 一般都是布尔类型

13:47.280 --> 13:53.440
因为他要判定吧 条件一是否满足 是否满足 是不是布尔 条件二是否满足 是否满足 是不是布尔 对吧

13:53.680 --> 13:58.080
一般来说的话 左右两边都写布尔 都是写的是布尔 比方说像那个比较运算

13:58.480 --> 14:02.240
比较运算得到的结果 我们之前说过 他就是布尔 你看这个比较运算

14:03.040 --> 14:09.520
五大于三安并且呢 三大于二 你看这样子就非常好阅读啊 容易阅读 但是这个东西零并且二

14:09.840 --> 14:13.840
这种说法呢 就有点怪怪的啊 但是在结实里边是可以运行的

14:14.320 --> 14:22.080
某些语言是肯定不能这样写的 某些语言他要求左右两边必须是布尔 但是结实呢是一个弱类型语言 他没有这样的要求

14:22.400 --> 14:25.680
所以左右两边随便写啊 随便写 那他怎么运行的呢

14:26.480 --> 14:29.520
布尔判定 第一个表达是布尔判定结果为啥

14:31.280 --> 14:33.920
看一下 第一个表达是布尔判定的结果为啥

14:35.280 --> 14:43.200
是不是为假 对吧 为假 他是零嘛 布尔判定的结果为假 那么第一个表达是判定结果为假了过后

14:43.360 --> 14:50.400
规则是啥 你第一个条件都不满足了 我还看第二个条件吗 看都不看了 直接把第一个表达是返回

14:51.200 --> 14:54.400
直接返回第一个表达是 所以说这样子写的相当于是

14:55.360 --> 15:00.880
输出一个零 相当于是输出一个零 保存给你们看一下啊 输出结果就为零 看到没

15:01.760 --> 15:03.360
这是他的判定方式啊 并且

15:04.160 --> 15:05.680
好 咱们再来看啊 再来看

15:06.400 --> 15:12.080
面词题来了啊 马上面词题了 这个就是个面词题 x 等于1

15:12.640 --> 15:13.280
concel log

15:16.320 --> 15:16.960
x 呢

15:18.640 --> 15:19.280
大于

15:20.320 --> 15:20.560
2

15:21.360 --> 15:23.360
并且了 x 加加

15:24.000 --> 15:24.960
大于零

15:25.840 --> 15:28.640
然后再输出 x 他问你

15:29.440 --> 15:30.000
他问你

15:30.880 --> 15:34.240
程序 整个程序最终会输出一个什么样的结果

15:35.760 --> 15:36.400
好 来呗

15:37.200 --> 15:38.400
理一下啊 理一下

15:40.080 --> 15:43.920
好 这里呢 整个表达是啊 把他拿过来啊 整个表达是拿过来

15:44.480 --> 15:49.920
好 左边的这个表达是说 先算出来啊 x 的值是多少 1 对吧 1 是不大于2的

15:50.640 --> 15:53.040
是不是 对吧 不是 那么就是force

15:53.920 --> 15:56.560
好 第一个表达是算出来的结果是force 看到没

15:57.040 --> 15:59.600
算出来的结果是force 还需不需要算第二个

16:00.160 --> 16:05.600
你第一个条件那么满足 我是并且关系 那第二个条件肯定不用看了啊 肯定是不用看了

16:06.080 --> 16:06.560
所以说呢

16:07.600 --> 16:12.960
直接把第一个表达式的结果返回就完事了啊 第一个表达是直接不 第二个表达是直接不运行了啊

16:13.280 --> 16:19.040
不运行了 所以说这个 x 加加是没有运行的啊 是根本就没有运行的 x 的值呢 他仍然保持1

16:19.840 --> 16:22.400
啊 那么得到结果 整个表达式的结果就是force

16:22.720 --> 16:28.320
所以说第一句代码啊 18 行就代码输出啥呢 输出的就是第一个表达式的值 force

16:29.760 --> 16:34.000
好 19 行啦输出啥呢 就输出1 对吧 输出的结果就是force

16:34.240 --> 16:39.600
1 好看一下 force 1 这是一道面识题啊 一道面识题

16:40.720 --> 16:43.840
好 ok 这是关于这个例子 再来啊 再来

16:45.440 --> 16:48.880
好 比方说啊 咱们又来输出这个啊 又来输出这个

16:51.040 --> 16:53.360
三大于二 并且

16:55.360 --> 17:00.720
怎么弄啊 这样子写吧 我就瞎写啊 我就瞎写 1 2 3

17:01.440 --> 17:02.320
啊 4

17:03.760 --> 17:04.080
0

17:04.720 --> 17:06.640
好 我写了这么多并且

17:07.120 --> 17:13.120
怕什么呢 一部分一部分刷不完了吗 对吧 我们之前也说过啊 也说过什么就是那种

17:13.760 --> 17:21.200
啊 就是多个多个运算符一起用 我们不是经常用吗 什么加号又又出现减法又出现惩罚 不是经常在一起用吗

17:21.600 --> 17:26.480
啊 那么这里还不是一样的 一部分一部分刷就完事了啊 好来呗 来刷一下啊

17:27.040 --> 17:31.840
好 首先呢 这个运算符的优先级是不是一样的啊 一样的

17:32.320 --> 17:36.400
相临的两个运算符的优先级一样的 所以艾滋计算就完事了 先计算这一部分

17:36.880 --> 17:39.760
好 这一部分1是不是为真 对吧 判定的结果为真

17:40.320 --> 17:42.720
好 ok 那么这个表达式的结果是不是就是1

17:43.200 --> 17:43.840
对吧 1

17:44.480 --> 17:48.080
好 来 1又并且3 那么1到判定结果为真

17:48.480 --> 17:54.400
哦 不对不对不对 不对不对 怎么回事啊 1到判定结果为真 那么表达 整个表达式的结果是不是

17:54.720 --> 17:58.560
第二个表达式 对吧 就是第二个表达式 第二个表达式的结果为2

17:59.600 --> 18:06.000
没问题吧 ok 好 2又并且3 ok 那么这个地方啊 是不是表达式的结果就是3

18:06.560 --> 18:12.480
对吧 好 3又并且4 表达式的结果是啥 第一个表达式为真 那么直接把第二个表达式返回

18:12.960 --> 18:17.920
就是4 4并且0 它为真 对吧 它为真 好 那么第二

18:18.320 --> 18:22.000
最后一个结果直接返回啊 直接返回 好 那么

18:22.480 --> 18:25.600
得到是什么了 得到就返回的结果就是0 就是0

18:26.160 --> 18:31.760
看没 其实我们也可以这样理解啊 我们不用去用这种方式 我们这样理解

18:32.080 --> 18:35.600
就是如果出现多个并且的时候 整个表达式的结果是啥呢

18:36.400 --> 18:42.560
从左到右看 第一个为假的表达式 第一个判定为假的表达式 是不是就一定是

18:43.440 --> 18:49.920
整个表达式的结果 没问题吧 第一个判定结果为假的表达式一定是整个表达式的结果

18:50.880 --> 18:56.240
啊 如果全部都为真的话 那就是最后一个啊 全部都为真的话就取最后一个

18:57.200 --> 18:59.600
好 比方说啊 比方说我们再来啊

19:02.320 --> 19:11.040
5 6 7啊 整个表达式返回结果是啥 其实我不用 我当然可以用这种方式啊 刚才那种方式一个个看

19:11.360 --> 19:14.320
也可以用刚才那个规律 就是从左到右看

19:15.200 --> 19:19.440
第一个为假的表达式 是不是它啊 那么整个表达式的结果就是0

19:20.000 --> 19:23.760
啊 就是0 好看一下吧 保存一定是0

19:25.600 --> 19:32.160
如果整个表达式 如果所有的数字全部都为真啊 如果所有的判定全部都为真 那就是最后一个表达式的结果就是7

19:32.800 --> 19:33.280
啊 就是7

19:34.480 --> 19:36.000
看呗 就是7

19:36.720 --> 19:43.200
啊 明白了 就这么个意思啊 为什么中间只要有一个假 那么整个判定的结果一定是这个表达式的值呢 为什么呢

19:43.760 --> 19:46.240
你想呗啊 有有这个假在里边

19:46.960 --> 19:51.840
它是不是有短路啊 这个东西叫短路规则啊 这个东西叫做短路规则

19:54.770 --> 19:55.170
短路

19:56.610 --> 20:02.770
什么叫短路规则呢 就是有的时候一个表达式的值出来了 整个表达式的结果就已经出来了

20:03.090 --> 20:08.450
后边的表达是我不用去算啊 比方表达是一个结果出来了 它为假 那么直接把表达是2

20:09.650 --> 20:14.770
呃 对 表达是一个结果为假 直接把表达是一返回就行了 就不用去执行表达是二了

20:14.770 --> 20:18.370
就少执行点呆嘛 这样子呢 可以提高程序运行的速度

20:18.930 --> 20:23.330
啊 好 那么这里呢 我们来看一下呗 我们看一下短路规则是怎么算的啊

20:23.730 --> 20:30.770
好 一并且二 是不是得到结果二对吧 二并且三 你看是不是只要都为真的话就取最后一个

20:32.130 --> 20:38.370
三啊 就是第一个为真的话就取最后一个 三和四就取四 四和零是不是取零啊

20:38.690 --> 20:41.090
第一个为真就取后面的这一个 取零

20:41.570 --> 20:46.770
好如果第一个为假 后边是不是不用看了啊 看这一部分啊 看这一部分

20:47.090 --> 20:53.890
如果第一个为假 后边是不是不用看了 不用看了 那结果就是零对吧 你看零和六是不是零 零和七是不是零 明白这个意思吧

20:54.610 --> 20:58.690
只要中间有一个假 那直接得到这个假 如果全部为真的就是最后一个

20:59.490 --> 21:03.730
啊 就是这这这种这种表达是呢 他有有这么一个功效啊 有这么一个功效

21:04.210 --> 21:10.210
因此呢 我们也有的时候呢 也可以利用他这一点啊 比方说我们可以可以实现这么一个功能

21:10.530 --> 21:15.410
比方说吧 有这么一个效果啊 就是有有一个变量

21:16.610 --> 21:20.130
打住是个吗 有个变量啊 年龄啊年龄

21:20.690 --> 21:26.850
好年龄呢 他有的时候复制呢复错了啊 比方说啊 莫名其妙的原因 当然原因可能很复杂

21:27.170 --> 21:32.530
啊 莫名其妙的原因给他复制为了复数啊 复制为了复数 但是年龄是不可能为复数的对吧

21:32.770 --> 21:37.890
年龄是不可能为复数的 但是有些同学呢觉得这不神经病吗 你干嘛给他复制个复数呢

21:38.690 --> 21:43.570
但是呢 你要这样子想 有的时候数据不是来自于理解的

21:44.050 --> 21:49.970
以后呢 我们学到页面过后呢 在页面上做一些交互的时候呢 数据可能是用回在文闷框里边自己填的

21:50.210 --> 21:56.290
你鬼知道他填啥 对吧 你可能不知道他填的是啥 好 所以说呢 我们有的时候呢 要对他进行处理一下

21:56.690 --> 22:01.330
怎么处理呢 就是说啊 如果年龄为复数

22:02.210 --> 22:10.450
则将其设置为 将其设置为您 追小可以为您 但是呢 你不能为复数

22:11.570 --> 22:13.330
好 那么这个东西该怎么来写代码呢

22:14.050 --> 22:20.690
好 我们就这里呢 其实写代码的方式有很多 比方说我们以后会学习判断啊 判断就是流程控制里边的判断

22:21.010 --> 22:25.010
还学习三目运算符啊 都可以来做这件事 不过呢 这里呢 我介绍

22:25.330 --> 22:30.930
因为我现在学习的是运算符嘛 对吧 并且运算符也可以做这件事

22:31.490 --> 22:38.130
啊 也可以做这件事 他做什么事呢 就这样写 a 级是不是小于您啊

22:38.770 --> 22:44.770
好 然后加上 加上个并且啊 并且 然后呢 把a 级呢 复数为多少呢 复数为您

22:46.050 --> 22:53.090
啊 他现在为什么要爆错了 爆出的原因呢 他是 他认为你这个写法好乖啊 你想把零复数给前面这一坨

22:53.410 --> 23:00.610
这一坨是啥 他前面只能放一个变量 对吧 这是优先级判定的问题 这样子 你把这个地方扩起来啊 扩起来

23:01.810 --> 23:07.650
让介石知道 这一块是一个表达式啊 这一块是个表达式 一个普通的复指表达式啊 他是一个整体

23:08.370 --> 23:16.930
好 就完事了 咱们来输出一下年龄 先看结果啊 我们再来分析 保存看一下啊 年龄是不是零的 他就不再是复数了

23:17.330 --> 23:21.250
啊 如果年龄是正数 是一个正常的值 不受任何影响

23:21.810 --> 23:24.770
啊 22 看一下 22 不受任何影响

23:25.810 --> 23:28.210
那怎么回事呢 他怎么做到的呢 来分析一下

23:29.010 --> 23:30.930
如果这个表达式的值为真

23:31.810 --> 23:37.730
如果他为真 是不是一定要判断 一定要得到第二个表达式 对吧 一定要运行第二个表达式

23:38.450 --> 23:43.890
啊 因为光一个表达式为真还判定不出来 所以说一定要运行第二个表达式 返回第二个表达式的结果

23:44.690 --> 23:47.890
啊 所以说他会运行第二个表达式 他就会把他复制为零

23:48.930 --> 23:52.770
如果这个地方判定的结果为假 是不是第二个表达式就不运行了

23:53.250 --> 24:00.210
对吧 如果第一个表 第一个表达式判定的结果为假 比方说A级本身就是正常的值 就是一个正数 那么第二个表达式就不运行了

24:00.850 --> 24:04.690
所以说我们可以利用巧妙的利用这一点啊 来实现这么一个功能

24:05.010 --> 24:11.570
当然了 我们以后写代码不太会这样的写啊 因为这样子写的很难约读 你约读现在总感觉很怪啊 总感觉很怪

24:11.970 --> 24:15.330
以后呢 我们最好的写法是用三目运算符 或者是呢

24:15.890 --> 24:22.610
用那个我们下一张要学习的流程控制 用衣服判断 那样子写出来代码呢 要优雅一些啊 要容易约读一些

24:23.010 --> 24:31.650
这样代码呢 你虽然看上去很炫技啊 感觉这样子写一下子也可以完成这个功能 但是很难约读啊 约读起来体验不好啊

24:32.370 --> 24:41.170
难以约读和理解 这个代码是不好约读和理解的 对我唐根学同学们说啊 就咱们写代码是给人看的

24:41.890 --> 24:48.610
你不要为了炫技写一些莫名其妙的代码 你会被砍死的啊 你在公司里边呢 我以前看过一句话啊

24:49.010 --> 25:01.090
因为以后呢 你们在公司里边是要团队协作的 就是你的代码呢 你说你自己看着不而行 但是别人看着而行啊 你的代码是要给别人看的 你要怎么去想呢

25:02.130 --> 25:09.730
看你代码的人呢 是一个经常健身 并且呢有暴力倾向 并且呢极其烦躁

25:10.850 --> 25:17.650
同时还知道你家庭住子的人 你要这样去想想 你这样子写代码你自然就乖了啊 你自然就会牢牢实实写了

25:18.450 --> 25:18.850
ok啊

25:19.970 --> 25:29.730
这一块啊 我们我只是告诉大家啊 可以有这种协法啊 可以用这种协法 但是呢 我们不太会用这种协法来处理处理这个问题 我们通常会用以后的条件判断

25:31.810 --> 25:35.090
好 再来到题啊 再来到道题 看大家对这一块的理解啊

25:36.530 --> 25:41.250
定个边量 x 为1 然后呢 输出 输出

25:43.360 --> 25:45.360
啊 x 加加

25:46.240 --> 25:46.720
大于

25:48.240 --> 25:50.400
等于 1 并且

25:51.200 --> 26:00.160
x 加加大于等于 2 并且 x 加加大于等于 2 大于等于

26:01.760 --> 26:05.680
4 并且呢 x 加加大于等于

26:07.040 --> 26:11.200
4 好 输出结果啊输出结果x

26:11.760 --> 26:16.960
好 这两个代码输出啥 输出什么结果 来 给你一点时间啊 你们自行来判定

26:17.600 --> 26:23.970
这个代码会输出一个什么样的结果 好 我讲一下啊

26:25.410 --> 26:26.370
来吧 把复制一下

26:28.450 --> 26:31.410
好 x 的值呢 一开始 为多少呢 为1

26:32.770 --> 26:35.250
来呗 首先呢 第一个表达是先

26:36.610 --> 26:38.770
先把第一个表达是运行出来 x 加加

26:39.730 --> 26:42.770
自征1 返回自征之前的值 1

26:43.410 --> 26:46.290
好 1 是不是大于等于1呢 OK 大于 2

26:46.850 --> 26:53.490
好 第一个表达是为2 是不是 这一块代码 就这个表达是 它的结果 是不是就直接是第二个表达式的结果

26:53.890 --> 26:56.050
对吧 应该是在这 应该是在这

26:56.530 --> 27:02.130
啊 这个 整个这个表达式 它的结果 就直接是表达式2的结果 就直接是它的结果

27:02.450 --> 27:04.290
所以说呢 得到的就是表达式2

27:04.690 --> 27:06.690
好 表达式2开始进行计算啊 计算

27:07.170 --> 27:11.730
好 计算呢 就是 x 加加先自征1 然后返回自征之前的值 2

27:12.610 --> 27:14.770
没问题吧 好 2 是不是大于等于2呢 去

27:15.410 --> 27:15.890
啊 没问题

27:16.530 --> 27:19.090
啊 没问题 好 那么第一个表达式为去

27:19.970 --> 27:22.610
这又是并且对吧 直接得到第二个表达式的值

27:23.250 --> 27:24.450
好 直接算第二个表达式

27:25.650 --> 27:27.890
好 那么第二个表达式自征1 是

27:28.450 --> 27:30.290
好 得到自征之前的值 3

27:30.930 --> 27:33.650
好 那么这个是不是 force 对吧 force 好

27:34.370 --> 27:37.010
既然它都是 force 呢 需不需要看这个表达式

27:37.570 --> 27:40.530
不需要看了啊 不需要看了 这也是我刚才说的啊

27:40.930 --> 27:44.370
这里边呢 只要有一个为假 那么整个表达式的结果就是那个表达式

27:44.770 --> 27:46.850
好 那么直接得到整个表达式的结果就是 force

27:47.010 --> 27:50.450
x 的值呢 为4 所以说输出的结果是 force和4

27:51.250 --> 27:55.300
好 看一下 force和4

27:55.940 --> 27:59.300
没问题吧 这是关于并且啊 关于并且

28:00.180 --> 28:02.980
好 下一个 其实你并且学会了过后 你不

28:03.220 --> 28:05.380
你另外一个啊 就很简单了啊

28:05.780 --> 28:08.900
或 差不多的 差不多的

28:09.460 --> 28:11.860
好 将表达式1进行布尔判定

28:12.420 --> 28:13.780
它的协法啊 符号

28:14.340 --> 28:17.860
它的符号是两个数线 看一下两个数线在哪儿

28:18.500 --> 28:22.020
两个数线在哪儿 是不是在键盘的回车键上面啊

28:22.020 --> 28:23.940
按shift键 然后把它打出来啊

28:24.260 --> 28:26.020
两个数线啊 最一定是两个啊

28:26.580 --> 28:28.820
好 符号是数线 那么协法呢

28:29.460 --> 28:33.140
协法它是差一样的啊 表达式1

28:33.780 --> 28:35.700
或者 表达式2

28:36.340 --> 28:40.500
那么它的具体的运行方式呢 将表达式1进行布尔判定

28:41.140 --> 28:44.260
判定的方式 如何进行布尔判定 规则跟前面是一样的

28:44.980 --> 28:48.660
下面的数据呢 为 force 其他的数据呢 其他的数据全部为

28:49.860 --> 28:50.820
全部 全部都是真

28:51.860 --> 28:53.380
好 判定出来过后呢

28:54.100 --> 28:56.260
或者理想一下 或者理想一下

28:57.140 --> 28:59.060
比方说你要学好这门客啊

28:59.540 --> 29:02.660
你可以先看我的视频 再去看诚哥的视频

29:03.540 --> 29:04.500
这是表达式1

29:04.980 --> 29:07.940
也可以先看诚哥的视频 再来看我的视频

29:08.500 --> 29:11.300
这是表达式2 是满足一个条件就行了 对吧

29:11.780 --> 29:12.900
满足一个条件就行了

29:13.300 --> 29:16.980
所以说呢 如果把表达式1判定出来过后

29:17.700 --> 29:19.300
如果表达式1

29:20.020 --> 29:21.380
怎么样 为真

29:22.500 --> 29:25.620
直接返回 表达式1就可以了

29:26.100 --> 29:27.300
表达式2就不运行的啊

29:27.700 --> 29:30.100
不运行表达式2了啊 不运行表达式2

29:30.740 --> 29:31.460
不运行

29:32.100 --> 29:32.820
表达式2

29:34.100 --> 29:38.100
好 另外一个呢 就否则 如果表达式1为假

29:38.100 --> 29:39.620
就跟前面的刚好相反

29:40.100 --> 29:41.700
如果为假的话还不行

29:41.700 --> 29:44.500
就一个条件不满足 那看一下这个条件能不能满足

29:44.980 --> 29:46.260
你只要满足一个就行了

29:46.820 --> 29:49.540
否则的话 返回表达式2

29:50.340 --> 29:51.300
返回表达式2

29:51.780 --> 29:54.820
这就是 获这个运算 它的运算规则

29:55.140 --> 29:56.180
好 咱们来举个例子

29:56.980 --> 29:57.540
好 这里的

29:58.820 --> 29:59.380
重新来

30:00.180 --> 30:00.740
比方说啊

30:01.460 --> 30:02.740
1

30:03.380 --> 30:04.340
大于3

30:05.220 --> 30:05.860
或者

30:06.900 --> 30:07.380
10

30:07.940 --> 30:08.740
返回的结果是啥

30:09.860 --> 30:10.580
返回的结果是啥

30:11.620 --> 30:13.860
返回的结果自然是10呗 对不对

30:13.860 --> 30:15.060
返回的结果自然是10

30:15.300 --> 30:17.060
第一个判定出来是什么

30:17.540 --> 30:18.580
为假 对吧

30:18.900 --> 30:20.260
第一个判定出来为假

30:20.660 --> 30:23.060
好 为假的话还要接着判定

30:23.300 --> 30:25.380
还要看后边了 还要看后边了

30:25.620 --> 30:25.940
因为

30:26.340 --> 30:28.580
第一个条件不满足 不代表第二个条件不满足

30:28.660 --> 30:30.980
所以它直接把第二个表达式返回

30:31.380 --> 30:33.620
第一个为假 直接把第二个表达式返回

30:33.780 --> 30:34.500
就是输出时

30:34.900 --> 30:36.580
整个表达式的结果就是输出时

30:37.220 --> 30:37.780
好 看一下

30:39.300 --> 30:41.060
输出时 看没 没问题吧

30:41.620 --> 30:43.300
好 接下来咱们再看啊 再看

30:43.940 --> 30:44.900
好 比方说啊

30:46.820 --> 30:48.340
console log

30:50.180 --> 30:50.900
undefend

30:51.700 --> 30:52.580
或者

30:54.340 --> 30:54.660
100

30:55.140 --> 30:56.580
或者是一个字幕创ABC

30:56.900 --> 30:58.020
一个字幕创ABC

30:58.660 --> 31:00.020
好 那这个东西怎么玩呢

31:00.580 --> 31:02.020
第一个东西判定结果为啥

31:02.340 --> 31:03.060
undefend

31:03.540 --> 31:05.140
判定结果为啥 我之前说过了

31:05.140 --> 31:06.260
空嘛 没有嘛

31:06.260 --> 31:07.540
没有判定结果就是假

31:07.940 --> 31:09.780
那么假的话 是不是我后边要看

31:10.020 --> 31:11.380
直接把第二个表达式返回

31:11.620 --> 31:12.900
第二个表达式是ABC

31:12.980 --> 31:13.940
就是输出ABC

31:14.340 --> 31:14.740
看没

31:15.540 --> 31:17.940
好 然后呢我们多写一些啊 多写一些

31:18.580 --> 31:19.300
console log

31:20.740 --> 31:26.100
比方说年或者老或者undefend或者一

31:26.580 --> 31:30.820
或者就是now或者是NAN

31:32.260 --> 31:34.420
那么这个表达式 别管它有多怪

31:34.420 --> 31:35.860
我们平时不会这样写代码的

31:35.860 --> 31:36.900
我们只是讲规则

31:37.380 --> 31:38.260
好 这个返回啥呢

31:39.380 --> 31:42.020
有些聪明人同学呢应该跟之前对应一下

31:42.020 --> 31:42.820
对应一下

31:43.060 --> 31:46.420
之前用并且的时候返回的是第一个为假的 对吧

31:46.820 --> 31:48.100
那么现在用或者的时候呢

31:48.100 --> 31:49.620
返回的就是第一个为真的

31:50.420 --> 31:51.380
或者是最后一个

31:52.500 --> 31:53.780
第一个为真的是不是一

31:53.780 --> 31:55.220
那么这个就返回的是一

31:56.740 --> 31:58.500
怎么来看这个问题呢 你想呗

31:59.060 --> 32:02.820
0是假 对吧 是假 OK

32:02.820 --> 32:03.780
0是假的话

32:04.820 --> 32:05.700
返回后边的一个

32:06.180 --> 32:07.140
返回后边的一个now

32:07.700 --> 32:09.540
好 now和undefend now为假

32:09.540 --> 32:10.980
返回后边的一个undefend

32:11.620 --> 32:12.500
好 undefend

32:13.060 --> 32:15.460
为假返回后边的一个一

32:16.580 --> 32:17.220
一为真的

32:17.540 --> 32:18.660
那是不是返回前面的一个

32:19.380 --> 32:20.660
一为真的就返回前面的一个

32:21.380 --> 32:22.420
一和NAN

32:22.420 --> 32:23.700
那根本不用看一为真的

32:23.700 --> 32:24.740
它直接返回前面的一个

32:25.220 --> 32:26.740
你看没 反正结果就是1

32:27.300 --> 32:27.620
OK

32:28.180 --> 32:30.660
我们呢也可以利用这样一个特点的

32:31.220 --> 32:33.060
我们经常可能会写这么一个代码

32:33.060 --> 32:34.340
这个代码还蛮常见的

32:34.340 --> 32:35.700
相对于并且来说的话

32:35.700 --> 32:36.980
这个代码还蛮常见的

32:36.980 --> 32:37.860
就是或者这个代码

32:38.260 --> 32:39.300
就是有一个比方说

32:39.860 --> 32:41.620
比方说有一个变量

32:42.260 --> 32:43.220
或者是对象吧

32:43.220 --> 32:43.700
一个对象

32:44.260 --> 32:45.940
对象呢里边有一个属性name

32:46.660 --> 32:47.540
随便写啊

32:47.540 --> 32:49.300
有一个什么gender 性别

32:49.300 --> 32:49.620
对吧

32:50.020 --> 32:50.660
随便写啊

32:51.060 --> 32:51.780
有这么一个对象

32:52.180 --> 32:53.060
这个对象里边呢

32:53.060 --> 32:54.340
可能缺少一些属性

32:54.820 --> 32:55.940
可能缺少有些属性

32:55.940 --> 32:57.460
这个对象里边到底有哪些属性

32:57.460 --> 32:58.420
我是不知道的

32:58.420 --> 32:59.300
为什么不知道呢

32:59.300 --> 33:00.420
因为这个对象的数据呢

33:00.420 --> 33:01.620
可能来源于用户

33:02.020 --> 33:03.460
有些数据用户填都没有填

33:04.100 --> 33:05.380
有些数据呢可能不知道

33:06.500 --> 33:08.340
那么我们现在要处理这么一个问题

33:08.980 --> 33:09.860
对象中

33:10.660 --> 33:11.220
如果

33:11.940 --> 33:14.100
如果没有联名

33:14.660 --> 33:15.620
如果没有联名

33:16.500 --> 33:17.140
则怎么样呢

33:17.780 --> 33:18.100
则

33:20.180 --> 33:20.900
得到

33:20.900 --> 33:21.700
应该是这样说

33:22.180 --> 33:23.380
则把将联名

33:23.940 --> 33:24.500
将联名

33:25.460 --> 33:26.980
复职为18

33:26.980 --> 33:27.940
一个默认值

33:28.740 --> 33:29.860
如果没有联名的话

33:29.860 --> 33:31.140
把联名复职为18

33:31.940 --> 33:32.180
好

33:32.180 --> 33:33.300
那这个代码怎么写呢

33:33.300 --> 33:34.020
我们可以这样子写

33:34.500 --> 33:35.460
objag

33:35.460 --> 33:35.860
复职

33:36.660 --> 33:37.460
复职什么词言呢

33:37.860 --> 33:38.900
objag

33:39.620 --> 33:40.740
然后呢或者

33:41.300 --> 33:41.700
ob

33:42.260 --> 33:42.820
或者18

33:43.380 --> 33:43.860
就这样子写

33:44.980 --> 33:45.540
什么意思

33:46.180 --> 33:47.140
你看这个表达是

33:48.020 --> 33:48.820
如果他

33:49.380 --> 33:50.020
他的职

33:50.340 --> 33:51.860
如果取出来是undefined

33:51.860 --> 33:52.660
就是没有复职

33:53.460 --> 33:54.260
那么他是不是讲

33:54.580 --> 33:55.060
他是不是讲

33:55.060 --> 33:56.020
是不是直接取后边了

33:56.340 --> 33:56.980
把18

33:57.220 --> 33:57.860
整个表达是

33:57.860 --> 33:59.140
整个表达是的值就是18

33:59.380 --> 34:00.900
就是把18复职给A级

34:01.620 --> 34:02.180
没问题吧

34:02.500 --> 34:03.540
如果他没有职的话

34:03.700 --> 34:04.900
就是把18复职给A级

34:05.540 --> 34:06.740
好如果他有职

34:06.740 --> 34:08.180
比方他写的值11

34:08.660 --> 34:09.620
如果他有职

34:09.620 --> 34:10.500
判定的结果是不是真

34:11.060 --> 34:11.700
真的话就

34:12.180 --> 34:13.540
再把11复职给他对吧

34:14.260 --> 34:15.780
复职为相同的职

34:15.940 --> 34:17.220
相当于没有任何变化

34:17.620 --> 34:18.340
所以说这里呢

34:18.340 --> 34:19.860
我们也经常用这种代码呢

34:20.020 --> 34:21.380
来取一些默认值

34:21.780 --> 34:22.580
取一些默认值

34:22.820 --> 34:23.300
就是

34:23.540 --> 34:24.260
有些数据呢

34:24.260 --> 34:24.900
如果没有值

34:24.900 --> 34:26.180
我就给他一个默认值

34:26.740 --> 34:27.540
给他一个默认值

34:27.540 --> 34:28.260
就取一个

34:28.740 --> 34:30.260
最终最后一个为真的

34:30.500 --> 34:31.780
最后一个为真的数据

34:32.340 --> 34:33.220
就这么个意思

34:34.340 --> 34:34.660
好

34:34.660 --> 34:35.780
那么但是这个代码呢

34:35.780 --> 34:37.060
是有一点点缺陷的

34:37.060 --> 34:39.060
就是如果A级有值

34:39.060 --> 34:40.100
A级的值是0

34:41.300 --> 34:42.820
如果A级的值是0

34:43.700 --> 34:44.740
如果A级的值是0

34:44.740 --> 34:46.100
是不是还是把18复给他了

34:46.660 --> 34:48.020
假设我们的系统里边

34:48.020 --> 34:49.620
允许A级的值为0

34:49.620 --> 34:51.140
允许A级的值为0

34:51.140 --> 34:52.740
所以说是不是还是把18复给他了

34:53.700 --> 34:55.220
如果你要考虑到这种情况的话

34:55.220 --> 34:56.500
你会怎么应该怎么写呢

34:57.380 --> 34:59.140
如果你要考虑这种情况的话

34:59.140 --> 35:00.820
刚才那一段可能有点绕啊

35:00.820 --> 35:02.660
你可以反复的想一想

35:02.660 --> 35:03.140
看一下

35:03.940 --> 35:05.140
我相信你能想出来

35:05.140 --> 35:06.420
因为都是讲过了规则

35:07.540 --> 35:09.620
如果你要考虑到0的情况

35:09.620 --> 35:11.540
那么你只有安迪范的时候

35:11.540 --> 35:12.660
只有安迪范

35:13.300 --> 35:14.260
如果没有年龄

35:14.260 --> 35:15.140
就是为安迪范

35:16.180 --> 35:17.700
只考虑安迪范的情况

35:18.820 --> 35:19.860
那么应该怎么写呢

35:20.500 --> 35:21.220
应该怎么写呢

35:21.860 --> 35:22.740
我们就可以这样子写

35:23.380 --> 35:24.500
是不是等于安迪范的

35:25.060 --> 35:28.180
然后再把这个货整改成并且

35:28.580 --> 35:29.780
你看一下这样子是不是完事了

35:30.500 --> 35:32.580
如果这个条件为真

35:33.140 --> 35:34.900
如果这个判定的结果为真

35:34.900 --> 35:37.540
这个表达是说明A级等于安迪范的

35:37.540 --> 35:38.660
那么就是去对吧

35:38.660 --> 35:40.260
判定出来去

35:40.260 --> 35:41.380
由于使用的是并且

35:41.860 --> 35:43.140
由于使用的是并且

35:43.140 --> 35:45.460
那么这里肯定要读后边的这个字

35:45.860 --> 35:47.220
并且肯定要看后边这个

35:47.540 --> 35:48.740
所以就把18复给他了

35:49.380 --> 35:49.940
都行

35:50.340 --> 35:50.900
都行

35:51.380 --> 35:53.780
如果你不考虑什么只为安迪范的人情况

35:53.780 --> 35:55.300
你就可以用下面这种写法

35:55.860 --> 35:56.420
A级

35:58.980 --> 36:01.300
A级等于什么OB界点A级

36:01.940 --> 36:02.740
或者是吧

36:03.780 --> 36:05.060
当然我再重称一次

36:05.540 --> 36:08.180
这种写法是不太容易阅读的

36:08.180 --> 36:09.540
不太容易阅读

36:09.940 --> 36:10.580
所以呢

36:11.140 --> 36:14.580
不是很建议初学者用这种写法

36:14.580 --> 36:16.180
除非你以后写习惯了

36:16.180 --> 36:16.820
写习惯了

36:16.820 --> 36:18.100
一看这个代码就知道什么意思

36:18.900 --> 36:19.940
你写习惯了可以

36:20.180 --> 36:21.700
如果你没有写习惯的话

36:21.700 --> 36:22.340
比较绕的话

36:22.340 --> 36:23.700
不太建议用这种写法

36:23.700 --> 36:24.980
因为他不太容易阅读

36:24.980 --> 36:26.660
咱们的代码是给人看的

36:28.740 --> 36:30.020
这是关于或者

36:30.660 --> 36:31.540
非常非常简单

36:32.260 --> 36:32.500
好

36:32.500 --> 36:33.860
那么现在我问大家一个问题

36:34.260 --> 36:35.060
问大家一个问题

36:35.780 --> 36:38.660
就是或者和并且

36:39.380 --> 36:40.500
或者和并且

36:41.220 --> 36:42.980
整个表达是不是返回了结果

36:42.980 --> 36:44.020
是不是一定是布尔

36:46.220 --> 36:47.900
返回的内情是不是一定是布尔

36:48.940 --> 36:51.100
整个表达是返回的内情是不是一定是布尔

36:53.460 --> 36:54.340
不一定

36:54.980 --> 36:55.540
怎么不一定

36:55.540 --> 36:56.900
一看我从头到尾说这句话没

36:57.460 --> 36:59.620
从我之前讲比较运算符的时候说了

36:59.620 --> 37:00.740
一开始就记录了

37:00.740 --> 37:01.700
笔记里面就说了

37:02.740 --> 37:04.820
比较运算符返回的结果一定是布尔

37:04.820 --> 37:05.940
它不可能是别的东西

37:06.660 --> 37:08.500
但是逻辑运算符不一定

37:09.620 --> 37:11.060
那个情况太多了

37:11.060 --> 37:12.660
你看这个表达是返回的结果是啥

37:13.380 --> 37:14.740
是18是number

37:15.220 --> 37:15.860
是布尔吗

37:15.860 --> 37:16.580
它不是布尔

37:17.460 --> 37:18.180
不是布尔

37:18.180 --> 37:19.060
它是number

37:19.060 --> 37:20.340
有可能返回的结果是A级

37:20.340 --> 37:21.220
它也不是布尔

37:21.620 --> 37:22.340
也不是布尔

37:23.300 --> 37:25.620
比方说这个表达是返回的结果是1

37:25.620 --> 37:26.580
也是一个number

37:26.580 --> 37:27.060
对吧

37:27.060 --> 37:28.340
所以说这个地方不一定的

37:28.980 --> 37:30.020
不要说不能说

37:31.540 --> 37:34.020
逻辑运算符返回的内情也一定是布尔

37:34.020 --> 37:35.700
在其他语言里面确实是这样子

37:36.020 --> 37:37.300
其他语言比方说加辣

37:37.300 --> 37:38.100
C下培养

37:38.100 --> 37:39.860
他们里面

37:39.860 --> 37:43.620
它的布尔运算符返回的结果一定是布尔

37:43.620 --> 37:45.620
但是在介石里面不一样

37:45.620 --> 37:46.820
介石是不一样的

37:47.540 --> 37:47.860
好

37:47.860 --> 37:48.820
下面这个飞

37:50.740 --> 37:51.780
飞它的符号

37:53.060 --> 37:53.940
符号是什么呢

37:53.940 --> 37:54.900
一个感叹号

37:54.900 --> 37:55.700
英文感叹号

37:56.420 --> 37:57.540
数据写到后边

37:57.540 --> 38:00.500
它的写法是飞

38:01.060 --> 38:02.340
后边写上数据

38:03.460 --> 38:04.180
它这样的写法

38:04.740 --> 38:05.860
也就是说它是一个什么

38:05.860 --> 38:07.300
一个一远运算符

38:08.740 --> 38:09.540
一远运算符

38:09.540 --> 38:10.340
只有一个数据

38:10.980 --> 38:12.100
什么意思呢

38:12.100 --> 38:12.820
它指的是什么意思

38:13.300 --> 38:14.980
它意思就很简单

38:14.980 --> 38:20.420
将数据的布尔判定结果直接取反

38:21.140 --> 38:23.140
如果判定的结果为去

38:23.140 --> 38:24.340
返回的就是force

38:24.340 --> 38:26.740
判定的结果为force

38:26.740 --> 38:27.940
返回的就是去

38:27.940 --> 38:28.420
所以说

38:29.940 --> 38:30.900
飞运算符

38:31.620 --> 38:32.580
飞运算符

38:32.580 --> 38:34.980
一定返回布尔类型

38:36.900 --> 38:38.420
因为它返回的一定是去

38:38.420 --> 38:39.140
或者是force

38:40.180 --> 38:40.980
咱们来看一下飞

38:42.100 --> 38:42.900
这个很简单

38:42.900 --> 38:44.020
非常非常简单

38:44.020 --> 38:46.100
比方说咱们输出

38:46.100 --> 38:46.660
直接输出

38:47.540 --> 38:48.260
log

38:48.340 --> 38:49.060
飞

38:49.060 --> 38:49.540
飞去

38:50.580 --> 38:51.540
就是不是真的

38:51.540 --> 38:52.580
不是真的是假的

38:52.580 --> 38:52.980
对不对

38:52.980 --> 38:54.900
返回的是force

38:54.900 --> 38:55.380
看一下

38:56.340 --> 38:57.460
飞的话

38:57.460 --> 38:58.580
我们读代码的时候

38:58.580 --> 39:00.100
往往把它读成不是

39:00.100 --> 39:00.500
没有

39:01.380 --> 39:02.180
不存在

39:02.180 --> 39:02.660
怎么样

39:02.660 --> 39:03.380
怎么样

39:03.380 --> 39:04.340
往往是这样的去读

39:04.980 --> 39:05.300
force

39:06.500 --> 39:06.820
看没

39:08.100 --> 39:08.820
那么比方说

39:09.780 --> 39:10.420
log

39:10.420 --> 39:11.140
感叹号

39:11.140 --> 39:11.860
undefend

39:11.860 --> 39:12.260
怎么读

39:13.220 --> 39:13.700
输出

39:14.660 --> 39:15.220
是不是

39:16.020 --> 39:17.220
是不是不存在

39:17.780 --> 39:18.420
不存在

39:18.420 --> 39:19.620
undefend肯定是不存在

39:19.620 --> 39:20.100
对吧

39:20.100 --> 39:21.460
是不是不存在

39:21.460 --> 39:22.820
是不是不存在

39:22.820 --> 39:23.460
肯定是

39:23.460 --> 39:23.780
对吧

39:23.780 --> 39:25.220
那么返回的结果就是去

39:26.340 --> 39:27.300
返回就是去

39:27.300 --> 39:28.260
它一定返回布尔

39:28.260 --> 39:30.020
它不可能返回其他类型了

39:30.020 --> 39:30.660
看没

39:30.660 --> 39:31.380
这是飞

39:31.380 --> 39:32.020
飞运算符

39:33.140 --> 39:33.860
好吧

39:33.860 --> 39:34.980
其实非常非常简单

39:34.980 --> 39:36.340
非常非常简单

39:36.340 --> 39:37.140
大家注意一下

39:37.140 --> 39:38.420
飞运算符的优先级

39:38.420 --> 39:39.060
它有点高

39:39.780 --> 39:41.540
它的优先级是有点高的

39:41.540 --> 39:42.100
比方说

39:42.100 --> 39:42.980
这个代码

39:44.100 --> 39:44.660
比方说

39:44.660 --> 39:44.820
2

39:46.340 --> 39:46.820
加上

39:47.700 --> 39:48.020
1

39:48.820 --> 39:49.060
好

39:49.060 --> 39:50.740
这个代码怎么去理解呢

39:50.740 --> 39:51.940
你不要去理解成为

39:51.940 --> 39:54.100
先把2加1再去取飞

39:54.100 --> 39:55.060
再去取飞

39:55.060 --> 39:56.020
不是这个意思

39:56.020 --> 39:56.900
不是这个意思

39:56.900 --> 39:57.860
它是什么意思呢

39:57.860 --> 39:59.060
把2取飞

39:59.060 --> 40:00.340
它的优先级满高的

40:00.340 --> 40:01.300
把2取飞

40:01.300 --> 40:02.660
取飞过后再加上1

40:03.300 --> 40:03.940
来吧

40:03.940 --> 40:04.980
来吧算呗

40:04.980 --> 40:06.500
2是一个判定结果是啥

40:06.500 --> 40:07.380
判定结果是真

40:07.380 --> 40:07.780
对吧

40:07.780 --> 40:08.340
是真

40:08.340 --> 40:09.780
那么取飞就是force

40:10.580 --> 40:11.780
force加1

40:11.780 --> 40:13.300
那么把force转换的数字

40:13.300 --> 40:14.340
就是0

40:14.340 --> 40:15.460
0加1

40:15.460 --> 40:17.140
所以说最终得到的结果是1

40:17.620 --> 40:18.340
保存看一下

40:18.340 --> 40:20.420
得到的结果是1

40:20.420 --> 40:21.940
它的优先级比较高的

40:23.620 --> 40:23.860
好

40:23.860 --> 40:24.180
接下来

40:24.180 --> 40:26.900
让我们来做一个练习

40:26.900 --> 40:27.700
做一个练习

40:29.380 --> 40:29.700
好

40:29.700 --> 40:29.940
看着

40:31.060 --> 40:32.580
我们做一个简单的小练习

40:33.780 --> 40:34.340
比方说

40:35.780 --> 40:36.740
在变量中

40:36.740 --> 40:38.820
在变量中存放

40:39.380 --> 40:40.900
连连份

40:42.340 --> 40:43.780
就是是哪一连

40:43.780 --> 40:44.500
存一个连份

40:45.380 --> 40:45.700
一二

40:46.500 --> 40:46.820
一二

40:47.220 --> 40:48.100
注意变量命名

40:48.100 --> 40:50.500
一定要命名为一个有意义的单词

40:50.500 --> 40:51.780
一二的话比方说今年

40:52.500 --> 40:53.300
2019年

40:54.500 --> 40:54.980
好

40:54.980 --> 40:55.940
那么现在呢

40:57.380 --> 40:58.420
判定

40:58.420 --> 40:58.900
判断

41:00.100 --> 41:02.660
就是用那个用逻辑运算

41:03.780 --> 41:04.260
判断

41:05.700 --> 41:06.740
当年

41:06.740 --> 41:07.220
该年

41:08.660 --> 41:10.820
是否是润连

41:10.820 --> 41:12.020
是否是润连

41:12.020 --> 41:12.260
好

41:12.260 --> 41:13.780
润连的规则是什么呢

41:13.780 --> 41:14.660
润连规则

41:16.180 --> 41:16.900
润连

41:16.980 --> 41:17.620
规则是

41:18.580 --> 41:20.260
四连一润

41:23.220 --> 41:23.940
百年

41:24.980 --> 41:25.380
不润

41:28.830 --> 41:29.070
好

41:29.070 --> 41:30.270
第二个规则就是

41:30.270 --> 41:31.070
四百年

41:31.710 --> 41:32.110
一润

41:34.210 --> 41:34.370
好

41:34.370 --> 41:35.250
他的判定规则

41:35.970 --> 41:38.450
那么我们要写这个逻辑运算怎么写呢

41:39.010 --> 41:40.530
怎么写来写这个逻辑运算呢

41:41.090 --> 41:41.570
怎么写

41:42.930 --> 41:43.650
你可以这样子写

41:44.850 --> 41:45.250
好

41:45.250 --> 41:46.690
这里不是用两个条件吗

41:46.690 --> 41:46.850
对吧

41:46.850 --> 41:47.810
这是第一个条件

41:47.810 --> 41:48.850
这是第二个条件

41:48.850 --> 41:50.050
那么这两个条件

41:50.770 --> 41:52.850
他们之间的关系是并且还是或者

41:52.850 --> 41:53.250
看一下

41:54.370 --> 41:55.890
通过这是一个阅读理解题

41:56.690 --> 41:58.370
四连一润百年不润

41:58.370 --> 41:59.410
四百年一润

42:00.370 --> 42:01.890
你觉得他们的隐含关系是啥

42:02.450 --> 42:03.650
就是逻辑运算符呢

42:03.650 --> 42:04.770
有些同学觉得很难

42:04.770 --> 42:05.410
难得难得

42:05.410 --> 42:07.090
他这里边有一些逻辑在里边

42:07.730 --> 42:10.130
就是你要判断他的到底是并且还是或者

42:10.930 --> 42:11.330
好

42:11.330 --> 42:12.370
你把它看成个整体啊

42:12.370 --> 42:13.410
这是条件一

42:13.410 --> 42:14.290
这是条件二

42:15.010 --> 42:17.490
条件一和条件二之间呢

42:17.490 --> 42:18.930
他们是或者的关系

42:20.130 --> 42:21.650
要么满足条件一

42:21.650 --> 42:22.850
要么满足条件二

42:22.850 --> 42:24.050
只要满足一个条件

42:24.050 --> 42:24.770
他就是润连

42:25.250 --> 42:25.570
对吧

42:26.450 --> 42:27.730
我怎么看出来的呢

42:27.730 --> 42:29.810
因为条件一里边有一个百年不润

42:30.690 --> 42:32.130
那四百年是不是百年

42:32.130 --> 42:32.450
对吧

42:32.450 --> 42:33.810
那四百年凭什么要润的

42:33.810 --> 42:34.850
你看这两个条件是不是

42:35.410 --> 42:36.370
是不是互相矛盾的

42:36.370 --> 42:36.770
对吧

42:36.770 --> 42:37.970
所以说只能用或者

42:37.970 --> 42:38.930
只能用或者

42:40.530 --> 42:41.410
你不用去纠结

42:41.410 --> 42:42.450
这一块不用去纠结

42:42.450 --> 42:43.650
你实在想不出来就完事了

42:43.650 --> 42:45.010
实在想不出来的话

42:45.010 --> 42:45.730
你听我的

42:45.730 --> 42:46.370
就是或者

42:46.370 --> 42:47.410
就是或者

42:47.410 --> 42:48.770
那么就是条件一

42:49.730 --> 42:50.290
或者

42:50.850 --> 42:51.490
条件二

42:52.050 --> 42:52.610
条件二

42:54.130 --> 42:55.410
条件二是什么呢

42:55.410 --> 42:56.450
条件二很简单

42:56.450 --> 42:57.810
就是四百年一润

42:57.810 --> 42:58.530
条件二

42:58.530 --> 43:00.050
润连的条件二是什么

43:00.050 --> 43:02.050
就是能除亿四百能除净

43:02.050 --> 43:02.610
对吧

43:02.610 --> 43:04.770
连分除亿四百能除净

43:04.770 --> 43:07.170
怎么来判断连分除亿四百能除净呢

43:07.170 --> 43:09.890
你直接用连去除一个四百球余数

43:10.530 --> 43:12.530
这个余数算出来等于零

43:12.530 --> 43:13.170
是不是能除净

43:13.810 --> 43:14.370
没问题吧

43:16.130 --> 43:17.090
除余数嘛

43:17.090 --> 43:18.130
如果能整除的话

43:18.210 --> 43:19.730
是不是刚好是四百的倍数

43:19.730 --> 43:20.370
对吧

43:20.370 --> 43:21.330
能整除四百

43:21.890 --> 43:22.770
就这个意思

43:22.770 --> 43:24.530
你除亿四百去看它的余数

43:24.530 --> 43:25.250
余数为零

43:25.250 --> 43:26.450
那说明能整除

43:26.450 --> 43:28.290
这条件二是不是就写出来了

43:28.290 --> 43:29.730
条件二就写出来了

43:29.730 --> 43:30.050
好

43:30.050 --> 43:31.330
条件一这一块呢

43:31.970 --> 43:34.290
条件一这一块又分为两个条件

43:34.290 --> 43:35.090
四连一润

43:37.970 --> 43:39.970
并且百年不润

43:42.930 --> 43:44.850
条件一这一块又分为两个条件

43:44.850 --> 43:45.490
这一块呢

43:45.490 --> 43:46.050
整个条件呢

43:46.050 --> 43:46.690
我可以用

43:46.770 --> 43:48.130
扩好把扩起来

43:48.130 --> 43:49.170
来改变它的优先级

43:49.170 --> 43:50.770
其实你也可以不用扩好

43:50.770 --> 43:52.290
因为或者的优先级呢

43:52.290 --> 43:53.490
要低于并且

43:53.490 --> 43:55.170
它会先算并且

43:55.170 --> 43:56.370
然后再算或者

43:56.370 --> 43:57.410
所以说这个整个表达是呢

43:57.410 --> 43:57.890
你可以看

43:57.890 --> 43:59.810
看成先把前面这一块算出来

43:59.810 --> 44:00.610
一个条件

44:00.610 --> 44:02.370
然后再把这一块算出来一个条件

44:02.370 --> 44:03.650
然后取或者

44:03.650 --> 44:04.530
你可以这样去看

44:05.250 --> 44:05.410
好

44:05.410 --> 44:06.290
那么看左边了

44:06.290 --> 44:07.090
左边这一块

44:07.090 --> 44:08.130
四连一润

44:08.130 --> 44:08.370
好

44:08.370 --> 44:08.930
你怎么写呢

44:08.930 --> 44:09.650
这个代码

44:09.650 --> 44:10.130
四连一润

44:10.130 --> 44:11.810
说明是四的倍数对吧

44:11.810 --> 44:12.610
四的倍数

44:12.610 --> 44:13.570
除亿四能整除

44:14.450 --> 44:15.650
这第一个条件

44:15.810 --> 44:16.770
百年不认呢

44:16.770 --> 44:19.170
说明不是一百的倍数

44:19.170 --> 44:20.610
除亿一百

44:20.610 --> 44:21.970
不等于零

44:21.970 --> 44:23.490
就写完了

44:24.210 --> 44:26.210
就是判断润连的方式

44:26.210 --> 44:27.410
返回的结果

44:27.410 --> 44:28.610
这个返回的结果

44:28.610 --> 44:30.370
就能判断某一个连份

44:30.370 --> 44:31.570
是不是润连

44:31.570 --> 44:33.250
这是条件一

44:33.250 --> 44:34.130
这是条件二

44:34.130 --> 44:35.170
好好去琢磨一下

44:35.170 --> 44:35.890
这一块呢

44:35.890 --> 44:37.410
对于初学者来说

44:37.410 --> 44:39.090
这一块还要绕一会

44:39.090 --> 44:40.450
当然你编程

44:40.450 --> 44:41.490
编了一段时间程

44:41.490 --> 44:42.690
做了一段时间开发

44:42.690 --> 44:44.530
这个东西就跟我的一样

44:44.610 --> 44:45.250
但是现在呢

44:45.250 --> 44:46.130
有些初学者呢

44:46.130 --> 44:47.090
有几个难点

44:47.090 --> 44:47.730
几个难点

44:47.730 --> 44:48.370
主要是

44:48.370 --> 44:49.970
他无法把这个文字

44:49.970 --> 44:51.410
把它想象成代码

44:51.410 --> 44:51.970
慢慢来

44:51.970 --> 44:53.010
这个东西需要一段时间

44:53.010 --> 44:54.290
期待的慢慢来

44:54.290 --> 44:55.570
那么我就给你写出来

44:55.570 --> 44:56.850
写出来就是这个样子

44:56.850 --> 44:58.450
好好理解一下

44:58.450 --> 44:59.330
四连一润什么意思

44:59.330 --> 45:01.010
就是除亿四能整除

45:01.010 --> 45:02.690
你看这就是能除亿四能整除

45:03.410 --> 45:04.450
好什么叫百年不认呢

45:04.450 --> 45:05.650
除亿一百不能整除

45:05.650 --> 45:07.010
这就是除亿一百不能整除

45:07.010 --> 45:07.970
好整个合起来

45:08.690 --> 45:09.810
是并且关系

45:09.810 --> 45:11.570
那么这个是作为条件一

45:11.570 --> 45:12.530
好条件二的话

45:13.090 --> 45:13.490
在这

45:14.050 --> 45:14.930
能被四百整除

45:15.570 --> 45:17.410
就这个条件和这个条件

45:17.410 --> 45:18.290
满足任何一个

45:18.290 --> 45:19.010
它都四伦连

45:20.050 --> 45:20.690
保存看一下

45:23.150 --> 45:23.790
好看一下

45:23.790 --> 45:24.750
你看现在就不是

45:24.750 --> 45:26.350
有一些有意义的东西就出来了

45:27.070 --> 45:27.470
Force

45:27.470 --> 45:28.190
看没

45:28.190 --> 45:28.510
Force

45:29.150 --> 45:29.950
现在不四伦连

45:29.950 --> 45:31.470
2019年不四伦连

45:31.470 --> 45:31.870
好

45:31.870 --> 45:32.830
2016年呢

45:33.390 --> 45:33.870
保存

45:33.870 --> 45:35.070
2016年四伦连

45:35.070 --> 45:35.790
四伦连

45:37.070 --> 45:38.430
2000年呢

45:38.430 --> 45:39.390
2000年四伦连

45:39.390 --> 45:40.590
它能被四百整除

45:40.590 --> 45:41.070
对吧

45:41.070 --> 45:42.750
2000年四伦连

45:42.750 --> 45:42.990
去

45:45.230 --> 45:45.630
ok

45:45.630 --> 45:46.190
没问题吧

45:46.750 --> 45:47.230
没问题

45:48.030 --> 45:48.190
好

45:48.190 --> 45:48.990
那么接下来呢

45:48.990 --> 45:50.510
我们如果还有这么一个需求

45:51.470 --> 45:52.670
假设还有这么一个需求

45:53.550 --> 45:55.630
就是如果是润连

45:56.910 --> 45:58.270
如果是润连

45:58.270 --> 45:59.950
则输出润连

46:01.710 --> 46:02.350
否则的话

46:03.550 --> 46:04.830
输出平连

46:05.790 --> 46:07.150
否则的话输出平连

46:07.150 --> 46:08.190
那么这个该怎么办呢

46:09.230 --> 46:09.710
其实呢

46:09.710 --> 46:10.190
我这里呢

46:10.190 --> 46:11.150
不做强制要求

46:12.190 --> 46:13.310
不做强制要求

46:13.390 --> 46:14.110
因为这一块呢

46:14.110 --> 46:15.150
最好的做法

46:15.950 --> 46:16.670
是用什么呢

46:16.670 --> 46:19.550
是用我们下一张学习的流程控制

46:19.550 --> 46:20.350
用衣服判断

46:20.910 --> 46:21.390
但是呢

46:21.390 --> 46:23.070
现在我们还没有学习

46:23.070 --> 46:24.190
能不能做到呢

46:24.190 --> 46:25.950
其实他也能做到

46:25.950 --> 46:27.150
也能做到

46:27.150 --> 46:28.430
怎么做呢

46:28.430 --> 46:29.070
怎么做呢

46:29.070 --> 46:30.350
我们可以这样来携带了

46:30.350 --> 46:31.230
看着啊

46:31.230 --> 46:31.550
看着

46:32.110 --> 46:33.150
我把这个表达式呢

46:33.150 --> 46:34.110
放到一个变量里边

46:34.830 --> 46:35.550
result

46:35.550 --> 46:36.510
这是判定结果

46:37.630 --> 46:39.310
我把这个表达式的判定结果放了

46:39.310 --> 46:40.430
放到一个变量里边

46:40.430 --> 46:41.790
这个变量里边记录了啥

46:42.510 --> 46:43.070
或者是

46:43.070 --> 46:43.470
force

46:43.470 --> 46:44.270
你看这些表达是

46:44.830 --> 46:46.030
是不是得到结果全是布尔

46:46.030 --> 46:46.510
对吧

46:46.510 --> 46:47.710
记录了true而force

46:48.510 --> 46:48.830
好

46:48.830 --> 46:49.710
我们可以这样子写

46:50.430 --> 46:52.190
如果result

46:52.190 --> 46:52.750
为q

46:53.630 --> 46:54.670
如果为q的话

46:55.230 --> 46:56.350
那怎么样呢

46:56.350 --> 46:57.630
我们就用个并且

46:57.630 --> 46:59.310
用个并且输出

47:02.190 --> 47:02.670
润连

47:04.770 --> 47:05.250
没问题吧

47:05.890 --> 47:07.330
你看用并且的规则

47:07.330 --> 47:08.370
他如果为q

47:08.370 --> 47:09.890
是不是要运行这个表达式

47:10.290 --> 47:10.690
对吧

47:10.690 --> 47:11.730
他把这个表达式返回

47:11.730 --> 47:12.690
当然这个表达式返回

47:12.770 --> 47:13.890
返回为没有接收

47:13.890 --> 47:14.450
无所谓

47:14.450 --> 47:17.090
但是他在运行第二个表达式

47:17.090 --> 47:18.210
如果他为force的话

47:18.210 --> 47:19.890
他是不会运行这个表达式的

47:19.890 --> 47:20.850
因为是并且

47:20.850 --> 47:22.210
并且他第一个表达式为假

47:22.210 --> 47:23.650
他就不会运行第二个表达式

47:23.650 --> 47:24.770
他为真的时候

47:24.770 --> 47:26.210
才会运行第二个表达式

47:26.210 --> 47:27.250
我们就输出润连

47:27.250 --> 47:28.370
看一下2000年

47:28.370 --> 47:29.010
保存

47:29.890 --> 47:30.610
输出了润连

47:30.610 --> 47:31.250
看没

47:31.250 --> 47:31.650
润连

47:32.690 --> 47:34.770
如果不是润连了2001年

47:34.770 --> 47:35.170
保存

47:35.810 --> 47:37.090
啥都没有输出

47:37.090 --> 47:39.170
因为这个第二个表达式运行不了

47:39.170 --> 47:40.210
就这个表达式运行不了

47:40.210 --> 47:41.010
他就没有输出了

47:41.970 --> 47:42.290
好

47:42.290 --> 47:43.650
那么平连怎么办呢

47:44.530 --> 47:45.490
平连怎么办呢

47:46.770 --> 47:47.170
一看着

47:47.730 --> 47:48.530
我可以这样子写

47:51.580 --> 47:51.980
或者

47:54.740 --> 47:55.140
我想想

47:55.780 --> 47:56.420
我想想

47:56.420 --> 47:57.060
force

47:57.620 --> 47:58.660
不能这样子写

47:59.060 --> 47:59.860
不能这样子写

47:59.860 --> 48:00.500
换一行

48:00.500 --> 48:01.300
再来这样子写

48:01.780 --> 48:02.340
result

48:02.820 --> 48:03.380
或者

48:03.860 --> 48:04.580
console

48:04.580 --> 48:04.980
log

48:05.780 --> 48:06.180
平连

48:06.820 --> 48:07.140
平连

48:07.700 --> 48:08.180
啥意思

48:08.900 --> 48:09.460
如果

48:11.060 --> 48:12.340
如果他为真

48:12.340 --> 48:14.100
是不是不会运行第二个表达式

48:14.260 --> 48:15.300
因为这里用的是或者

48:15.300 --> 48:16.740
只要一个条件满足就行了

48:16.740 --> 48:17.700
如果他为真

48:17.700 --> 48:19.140
就不会运行第二个表达式

48:19.140 --> 48:20.180
如果他为假

48:20.180 --> 48:21.540
那么就会运行第二个表达式

48:22.100 --> 48:22.260
好

48:22.260 --> 48:22.820
咱们来看一下

48:23.300 --> 48:23.940
这里呢

48:23.940 --> 48:25.060
数据是平连了

48:25.060 --> 48:25.620
看没

48:25.620 --> 48:26.020
平连

48:26.580 --> 48:26.740
好

48:26.740 --> 48:27.620
如果是润连

48:27.620 --> 48:28.340
再来看一下

48:28.340 --> 48:29.940
2004年吧

48:29.940 --> 48:30.580
他是润连

48:31.540 --> 48:32.180
你看润连

48:33.220 --> 48:33.380
好

48:33.380 --> 48:34.740
我们可以用这种方式

48:34.740 --> 48:35.860
用这种方式

48:35.860 --> 48:37.540
来搞定这个问题

48:37.540 --> 48:37.860
当然了

48:37.860 --> 48:39.140
这不是一个好的方式

48:39.140 --> 48:40.020
虽然你可以这样写

48:40.020 --> 48:41.380
但不是一个很好的方式

48:41.380 --> 48:42.500
因为这样的写代码了

48:42.500 --> 48:43.700
非常难以阅读

48:43.780 --> 48:44.500
不好阅读

48:45.220 --> 48:45.780
好吧

48:45.780 --> 48:46.900
这是关于

48:46.900 --> 48:48.340
就是这个

48:50.340 --> 48:51.300
逻辑运算符

48:51.300 --> 48:51.540
好

48:51.540 --> 48:52.340
这一回有作业

48:52.340 --> 48:52.820
有作业

48:55.230 --> 48:55.630
作业

48:58.220 --> 48:58.540
好

48:58.540 --> 48:59.420
第一题

48:59.420 --> 49:00.380
第一题

49:00.380 --> 49:02.860
就是用一个变量

49:03.580 --> 49:04.540
用一个变量

49:04.540 --> 49:05.260
保存

49:06.380 --> 49:06.940
保存

49:08.140 --> 49:08.620
成绩

49:09.180 --> 49:09.900
成绩

49:09.900 --> 49:10.780
成绩的值呢

49:10.780 --> 49:11.660
就是0到100

49:11.660 --> 49:12.380
就成绩的值

49:13.500 --> 49:14.060
输出

49:15.260 --> 49:15.740
输出

49:16.300 --> 49:17.180
该成绩

49:17.500 --> 49:19.020
是否及格

49:19.020 --> 49:19.980
你输出的时候

49:19.980 --> 49:21.180
不用你输出制服串

49:21.180 --> 49:23.500
直接输出处和forced就行了

49:23.500 --> 49:25.740
处或forced

49:27.100 --> 49:27.900
如果及格了

49:27.900 --> 49:29.500
你就输出处

49:29.500 --> 49:30.380
如果没有及格

49:30.380 --> 49:31.580
就输出forced

49:32.860 --> 49:34.060
这是关于第一题

49:34.060 --> 49:35.180
来保存成绩

49:36.700 --> 49:37.020
好

49:37.020 --> 49:37.580
第二个题

49:37.580 --> 49:38.300
第二道题

49:40.300 --> 49:41.820
我们之前做过一道题

49:41.820 --> 49:42.940
就是算迅运算符

49:42.940 --> 49:43.660
这一块

49:43.660 --> 49:44.300
做过一道题

49:44.300 --> 49:45.500
就是利息计算器

49:46.140 --> 49:46.940
利息计算器

49:47.900 --> 49:48.140
好

49:48.140 --> 49:48.940
这里

49:48.940 --> 49:50.700
我们再来做一次

49:50.700 --> 49:51.340
设置变量

49:51.340 --> 49:52.460
分别来存放本金

49:52.460 --> 49:52.860
月数

49:52.860 --> 49:53.340
连利率

49:53.340 --> 49:54.060
利息计算利息

49:54.060 --> 49:54.620
对吧

49:54.620 --> 49:54.860
好

49:54.860 --> 49:55.980
那么这里有个规则

49:56.940 --> 49:58.700
如果本金

50:00.060 --> 50:01.340
存放量

50:01.340 --> 50:02.060
存放量

50:03.500 --> 50:04.380
超过了

50:04.380 --> 50:07.580
就是超过了10万

50:07.580 --> 50:08.540
10万

50:08.540 --> 50:09.740
如果本金的存放量

50:09.740 --> 50:10.940
超过10万

50:10.940 --> 50:11.820
连利率

50:12.620 --> 50:13.260
上幅

50:14.220 --> 50:15.260
20%

50:16.220 --> 50:16.940
或者是

50:16.940 --> 50:18.300
上幅20%吧

50:18.300 --> 50:19.260
上幅20%

50:20.220 --> 50:20.620
注意

50:20.620 --> 50:21.660
你计算利息的时候

50:21.660 --> 50:22.860
你要考虑到这一点

50:22.860 --> 50:24.460
它本金有没有超过10万

50:24.460 --> 50:25.820
如果超过了10万的话

50:25.820 --> 50:28.540
连利率要上幅20%

50:28.540 --> 50:30.460
这道题有点难度的

50:30.460 --> 50:31.180
第一题很简单

50:31.180 --> 50:32.220
大家练习一下

50:32.220 --> 50:33.500
第二题还是有点难度的

50:33.500 --> 50:34.540
大家要想一想

50:34.540 --> 50:35.100
该怎么去做

50:35.820 --> 50:37.100
什么叫上幅

50:37.100 --> 50:39.100
连利率上幅20%呢

50:39.100 --> 50:39.740
就是比如

50:41.500 --> 50:43.180
连利率为

50:44.140 --> 50:44.780
比方说

50:44.780 --> 50:46.460
4%

50:48.300 --> 50:50.940
上幅后的连利率

50:51.980 --> 50:52.860
为多少呢

50:52.860 --> 50:54.220
为4%

50:54.940 --> 50:56.140
成义多少呢

50:56.140 --> 50:57.580
成义1.2

50:57.580 --> 50:59.100
就成义1.2

50:59.100 --> 50:59.740
就这个意思

51:00.540 --> 51:01.500
能看到吧

51:01.500 --> 51:02.460
上幅20%

51:02.460 --> 51:02.780
对吧

51:02.780 --> 51:03.420
成义1.2

51:04.060 --> 51:04.780
就这么个意思

51:05.660 --> 51:06.140
第二题呢

51:06.140 --> 51:07.260
好好想一想

51:07.260 --> 51:08.700
第二题你能够做出来的话

51:08.700 --> 51:10.060
这一块一定没什么问题了

51:10.060 --> 51:10.780
就没什么问题了

51:11.420 --> 51:12.140
好吧

51:12.220 --> 51:15.260
这是这两个作业

51:16.300 --> 51:17.420
我看一下

51:19.580 --> 51:21.980
第一个题好像没有用到什么

51:21.980 --> 51:23.260
没有用到逻辑运算幅

51:23.900 --> 51:25.660
第一题好像没有用到逻辑运算幅

51:25.660 --> 51:26.860
那我再加个题吧

51:26.860 --> 51:27.580
我再加个题

51:28.780 --> 51:29.260
再加一个

51:32.110 --> 51:32.590
第一题呢

51:32.590 --> 51:34.190
好像只需要比较运算幅就完事了

51:34.190 --> 51:34.750
对吧

51:34.750 --> 51:36.430
好像不用那个逻辑运算幅

51:36.430 --> 51:36.990
再加一道题

51:38.110 --> 51:39.550
第二题我们这样吧

51:39.550 --> 51:41.310
就是用一个变量

51:42.030 --> 51:44.510
保存连份

51:44.510 --> 51:45.790
保存连份

51:45.790 --> 51:46.910
就是现在是哪一年

51:46.910 --> 51:48.110
我们刚才做过了对吧

51:48.110 --> 51:50.510
得到该年份

51:50.510 --> 51:53.070
恶月的天数

51:53.070 --> 51:54.430
得到该年份

51:54.430 --> 51:55.710
恶月的天数

51:56.430 --> 51:58.510
大家下去好好想一想

51:58.510 --> 51:59.550
好好想一想

51:59.550 --> 52:00.670
这些题呢

52:00.670 --> 52:01.710
大家做的时候呢

52:01.710 --> 52:02.750
千万不要想着

52:02.750 --> 52:03.470
一步登天

52:03.470 --> 52:04.510
以下就把它做完

52:04.510 --> 52:05.870
它一定要分成步凑

52:05.870 --> 52:07.070
一个一个步骤

52:07.070 --> 52:07.870
一个一个步骤

52:07.870 --> 52:08.670
先算出啥

52:08.670 --> 52:09.470
不要说第二题

52:09.470 --> 52:10.990
你要保存一个连份

52:11.150 --> 52:12.590
得到该年二月的天数

52:12.590 --> 52:13.470
你是不是要得到

52:13.470 --> 52:14.750
这个年是不是运连

52:14.750 --> 52:15.470
对吧

52:15.470 --> 52:16.590
我们刚才是不是算过了

52:16.590 --> 52:17.870
课程上是不是做过的

52:17.870 --> 52:19.710
你要首先要能够得到一个结果

52:19.710 --> 52:21.230
能够记录这个年

52:21.230 --> 52:22.430
是不是运连

52:22.430 --> 52:23.870
然后再根据这个结果

52:23.870 --> 52:25.230
来得到二月的天数

52:25.230 --> 52:26.510
你要用这种方式来做

52:26.510 --> 52:27.390
不要想一句话

52:27.390 --> 52:28.190
就把全部写完

52:28.190 --> 52:29.470
千万不要这样做

52:29.470 --> 52:30.910
一定要分步凑来

52:30.910 --> 52:33.070
先得到它是不是运连

52:33.070 --> 52:33.630
然后呢

52:33.630 --> 52:34.830
再根据这个结果

52:34.830 --> 52:36.350
再来得到二月的天数

52:36.350 --> 52:37.150
你这样的想了

52:37.150 --> 52:38.430
这个程序就简单了

52:38.430 --> 52:39.390
不然的话这个

52:39.550 --> 52:41.230
你总想一句话写完的话

52:41.230 --> 52:41.950
你脑袋痛

52:41.950 --> 52:43.230
真的脑袋痛

52:43.230 --> 52:43.790
好吧

52:43.790 --> 52:44.750
好好去想一想

52:44.750 --> 52:45.310
做一下

52:45.310 --> 52:46.270
做不出来没关系

52:46.270 --> 52:47.230
我告诉大家

52:47.230 --> 52:48.670
一开始学程序的时候

52:49.630 --> 52:50.750
不说百分之百吧

52:52.190 --> 52:54.830
应该有百分之六七十的同学吧

52:54.830 --> 52:55.950
百分之六十的同学吧

52:56.670 --> 52:58.750
都无法把全部做也全部做完

52:59.630 --> 53:01.550
总会遇到这样那样的问题

53:01.550 --> 53:03.070
非常非常正常

53:03.070 --> 53:04.030
非常正常的

53:04.030 --> 53:04.910
一开始学程序

53:04.910 --> 53:06.430
就像一开始学走路的时候

53:06.430 --> 53:07.710
一开始学说话的时候

53:07.710 --> 53:08.510
你说不清楚

53:08.590 --> 53:09.150
说不好

53:09.150 --> 53:10.190
是非常正常的

53:10.190 --> 53:10.830
没关系

53:10.830 --> 53:12.190
你一定要去做

53:12.190 --> 53:13.470
一定要去尝试说

53:13.470 --> 53:14.910
一定要去尝试走

53:14.910 --> 53:16.350
如果你永远不练的话

53:16.350 --> 53:17.470
就等着老师

53:17.470 --> 53:18.190
看老师怎么走

53:18.190 --> 53:19.150
看老师怎么说

53:19.150 --> 53:19.870
没用的

53:19.870 --> 53:21.070
你一定要自己去走

53:21.070 --> 53:22.750
走到之后再来看我的讲解

53:22.750 --> 53:24.030
你就会明白

53:24.030 --> 53:25.630
就会体会到很多的东西了

53:25.630 --> 53:27.070
慢慢慢慢你就会发现

53:27.070 --> 53:28.190
程序也不过如此

53:28.190 --> 53:29.550
慢慢就写出来了

53:29.550 --> 53:30.750
非常非常正常

53:30.750 --> 53:32.030
但是一开始没有去做出来

53:32.030 --> 53:33.070
非常正常

53:33.070 --> 53:33.950
你先去做

53:33.950 --> 53:34.510
做不出来

53:34.510 --> 53:35.870
你看我的作品讲解

53:35.870 --> 53:37.390
讲解了之后在自己不要刷了

53:37.390 --> 53:37.950
讲解过后

53:38.510 --> 53:39.390
听懂了

53:39.390 --> 53:40.430
原来应该这么写

53:40.430 --> 53:42.990
你一定要去再去写一遍

53:42.990 --> 53:43.870
不看视频

53:43.870 --> 53:44.510
直接写一遍

53:44.510 --> 53:46.510
千万不要跟着视频抄

53:46.510 --> 53:47.630
一定要把视频关掉

53:47.630 --> 53:48.990
然后再一次去写一遍

53:48.990 --> 53:49.710
写出来过后

53:49.710 --> 53:50.670
哇 你发现

53:50.670 --> 53:52.670
我现在可以自己把独立完成了

53:52.670 --> 53:54.750
虽然是我参考了老师的讲解

53:54.750 --> 53:56.270
但是我自己能够把他

53:56.270 --> 53:57.390
从头到尾写出来了

53:57.390 --> 53:59.310
那这就是一种成就感

53:59.310 --> 53:59.790
好吧

53:59.790 --> 54:00.990
一定要按照我说的作

54:00.990 --> 54:02.110
把这个作业去完成

54:02.110 --> 54:02.430
好吧

54:02.430 --> 54:03.310
这是罗金帅夫

