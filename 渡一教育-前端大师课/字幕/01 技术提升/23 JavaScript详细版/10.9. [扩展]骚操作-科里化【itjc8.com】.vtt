WEBVTT

00:00.000 --> 00:03.000
科理化

00:03.000 --> 00:17.490
科理化 这些科是扩展课程

00:17.490 --> 00:21.490
也说我们后边不一定会用的 不太会用到这个东西

00:21.490 --> 00:27.490
但有的时候用这个玩意儿 能够帮助我们解决某些问题

00:27.490 --> 00:32.490
这个科理化 它叫做单程 叫做career

00:32.490 --> 00:38.490
它是为了纪念一个逻辑学家 叫做hascale

00:39.490 --> 00:43.490
career 它的名字叫这个 所以说以它命名的

00:43.490 --> 00:47.490
尽管不是它发明的东西 另外还有一个语言

00:47.490 --> 00:50.490
一个计算机编程语言 叫做hascale

00:50.490 --> 00:54.490
这个语言也是以它命名的 这个人还蛮屌的

00:54.490 --> 01:01.490
这个科理化 它是函数式编程里边的东西

01:01.490 --> 01:05.490
因此这节课肯定是超纲了 肯定是严重超纲了

01:05.490 --> 01:08.490
因为我们这门课它不涉及到函数式编程

01:08.490 --> 01:13.490
但是确实如果你用这个东西 可以给你某一些时候的开发

01:13.490 --> 01:16.490
造成一些便利 我们后边会举例子

01:16.490 --> 01:19.490
那这个东西有什么用的 它到底是什么玩意儿呢

01:19.490 --> 01:22.490
career 这个career化 其实就是一个函数

01:22.490 --> 01:26.490
所以说我们平时说career化 指的就是career化函数

01:26.490 --> 01:29.490
career化函数

01:29.490 --> 01:32.490
因此我们以后肯定会写这么一个函数

01:32.490 --> 01:35.490
career化函数 它的作用是这样子

01:35.490 --> 01:39.490
它的作用是 我们先把个概念说出来

01:39.490 --> 01:43.490
然后我们再来举例子 它的作用是这样

01:43.490 --> 01:49.490
它是固定某个函数的一些函数

01:49.490 --> 01:58.490
得到该函数生于函数的一个新函数

01:58.490 --> 02:05.490
如果没有生于函数 则调用

02:05.490 --> 02:08.490
这啥意思呢 说了半天都不知道是啥意思

02:08.490 --> 02:12.490
咱们来看一下一个历史 比方说现在career这个函数已经写完了

02:12.490 --> 02:15.490
就比方说它已经写完了

02:15.490 --> 02:19.490
我们来看一下我们怎么用它 从使用的场景出发

02:19.490 --> 02:21.490
我们来看一下怎么来用

02:21.490 --> 02:23.490
比方说这个career函数已经写完了

02:23.490 --> 02:27.490
我们现在有这么一个函数 方形

02:27.490 --> 02:29.490
就f嘛

02:29.490 --> 02:31.490
这里面有三个变量

02:31.490 --> 02:34.490
x y z 三个函数

02:34.490 --> 02:36.490
我说你返回啥呢 返回的是

02:36.490 --> 02:38.490
x 加 y 乘以 z

02:38.490 --> 02:41.490
就这么简单 有这么一个函数

02:41.490 --> 02:44.490
接下来我们来玩这些场景

02:44.490 --> 02:49.490
求表达式的值 看着啊

02:49.490 --> 02:54.490
求2加3乘以5

02:54.490 --> 02:58.490
然后2加5乘以6

02:58.490 --> 03:03.490
然后2加1乘以7 随便嘛

03:03.490 --> 03:07.490
2加2加7乘以16

03:07.490 --> 03:09.490
比方说求这些表达式的值

03:09.490 --> 03:12.490
当然你说那我干嘛要写函数呢

03:12.490 --> 03:13.490
直接求不完了嘛

03:13.490 --> 03:15.490
这是这个例子 举个例子

03:15.490 --> 03:17.490
就是这个函数有三个参数

03:17.490 --> 03:21.490
大家发现没有 我求的每一个表达式的值

03:21.490 --> 03:24.490
它的第一个东西 第一个参数是不是一样的

03:24.490 --> 03:26.490
就是在我们这个场景下边

03:26.490 --> 03:29.490
它求的这些表达式的值 第一个参数是不是一样的

03:29.490 --> 03:31.490
如果不一样的话

03:31.490 --> 03:33.490
如果每个第一个参数都可能不一样的话

03:33.490 --> 03:34.490
那就简单了 对不对

03:34.490 --> 03:35.490
我们就直接输出这个

03:35.490 --> 03:37.490
函数调整的结果不就完了嘛 对不对

03:37.490 --> 03:39.490
2 3 5 对不对

03:39.490 --> 03:41.490
第一个是不是就出来了 对吧

03:41.490 --> 03:43.490
我们这样子输写 那就完事了

03:44.490 --> 03:46.490
然后2 5 6 对吧

03:46.490 --> 03:47.490
就完事了

03:47.490 --> 03:50.490
但是我们发现它第一个参数是一样的

03:50.490 --> 03:52.490
因此为了减变我们后边的开发

03:52.490 --> 03:55.490
我们可以把第一个参数省略掉

03:55.490 --> 03:56.490
给它固定下来

03:56.490 --> 03:58.490
于是我们可以利用柯蒂花

03:58.490 --> 04:00.490
柯蒂花来用来做什么呢

04:00.490 --> 04:01.490
就是用来固定参数的

04:01.490 --> 04:03.490
把一些参数固定下来

04:03.490 --> 04:04.490
它怎么来用的呢

04:04.490 --> 04:06.490
比方说 比方说我们已经写完了

04:06.490 --> 04:07.490
plunging

04:07.490 --> 04:08.490
一个curry函数

04:08.490 --> 04:09.490
这个函数呢

04:09.490 --> 04:11.490
它第一个参数传的是一个函数

04:12.490 --> 04:14.490
就把这个函数传进来

04:14.490 --> 04:17.490
然后第二个参数 后边的参数传啥呢

04:17.490 --> 04:19.490
后边的参数传的是

04:19.490 --> 04:21.490
我要固定哪些参数

04:21.490 --> 04:22.490
比方说传一个2

04:22.490 --> 04:25.490
就表示固定它的第一个参数为2

04:25.490 --> 04:27.490
于是这个curry这个函数呢

04:27.490 --> 04:29.490
会返回一个新的函数

04:29.490 --> 04:30.490
会返回一个新的函数

04:30.490 --> 04:32.490
比方说g嘛

04:32.490 --> 04:33.490
g这个函数

04:33.490 --> 04:34.490
好 那么这个函数呢

04:34.490 --> 04:37.490
它只需要接受剩余两个参数就行了

04:37.490 --> 04:39.490
就这么个意思

04:39.490 --> 04:40.490
好 比方说

04:40.490 --> 04:42.490
那这里我们就可以这样调用了

04:42.490 --> 04:45.490
g3和5

04:45.490 --> 04:46.490
好 这里呢

04:46.490 --> 04:49.490
g多少

04:49.490 --> 04:51.490
5和6

04:51.490 --> 04:53.490
就这么来调用了 看到没

04:53.490 --> 04:56.490
然后是1和7

04:56.490 --> 04:58.490
然后是7和16

04:58.490 --> 04:59.490
看没

04:59.490 --> 05:00.490
我们就可以这样调用

05:00.490 --> 05:02.490
因为我们第一个参数已经固定下来了

05:02.490 --> 05:04.490
我们只需要得到剩余参数就行了

05:04.490 --> 05:06.490
好 这就是curry

05:06.490 --> 05:08.490
再来一个例子

05:08.490 --> 05:11.490
那比方说我们这里

05:11.490 --> 05:13.490
2加5

05:13.490 --> 05:14.490
然后这里呢

05:14.490 --> 05:16.490
2加3

05:16.490 --> 05:18.490
2加3

05:18.490 --> 05:20.490
好 接下来我们继续看

05:20.490 --> 05:21.490
继续看

05:21.490 --> 05:22.490
2加4嘛

05:22.490 --> 05:24.490
2加4

05:24.490 --> 05:26.490
前面这两个

05:26.490 --> 05:27.490
是不是第一个参数一样

05:27.490 --> 05:28.490
后面的参数都不一样

05:28.490 --> 05:29.490
然后后面这两个

05:29.490 --> 05:31.490
所以前两个参数都一样

05:31.490 --> 05:33.490
所以说我们还可以这样做看着

05:34.490 --> 05:35.490
好 这里呢

05:35.490 --> 05:36.490
我们求出这个g 对吧

05:36.490 --> 05:37.490
固定第一个参数

05:37.490 --> 05:38.490
固定第一个参数为2

05:38.490 --> 05:40.490
把第一个参数x固定下来

05:40.490 --> 05:41.490
为2

05:41.490 --> 05:42.490
后面我们只需要填入

05:42.490 --> 05:43.490
后面两个参数就行了

05:43.490 --> 05:44.490
看到没

05:44.490 --> 05:45.490
调用新的这个参数的时候

05:45.490 --> 05:47.490
只需要传入后面两个参数

05:47.490 --> 05:49.490
好 我们后来又发现

05:49.490 --> 05:51.490
后面的计算当中

05:51.490 --> 05:53.490
前面两个参数都是固定的

05:53.490 --> 05:55.490
看没 前面两个参数都是固定的

05:55.490 --> 05:56.490
于是呢

05:56.490 --> 05:58.490
我们又可以这样子来处理

05:59.490 --> 06:01.490
万一这个参数嘛

06:01.490 --> 06:03.490
然后我就继续固定

06:03.490 --> 06:05.490
刚才不是固定那个参数2吗

06:05.490 --> 06:06.490
得到一个新的参数

06:06.490 --> 06:08.490
是不是只剩下两个参数了

06:08.490 --> 06:10.490
然后再固定一个参数

06:10.490 --> 06:12.490
再固定一个参数为4

06:12.490 --> 06:14.490
然后后面我们就可以这样子玩

06:14.490 --> 06:16.490
这个y也是一个参数

06:16.490 --> 06:18.490
就特别特别神奇

06:18.490 --> 06:21.490
它只需要传一个参数去够了

06:21.490 --> 06:23.490
只需要传一个参数去够了

06:23.490 --> 06:25.490
看没

06:25.490 --> 06:27.490
就变成了这个样子

06:27.490 --> 06:29.490
你看这个意思吧

06:29.490 --> 06:32.490
它这里就是这种调用方式

06:32.490 --> 06:34.490
这种调用方式的结果

06:34.490 --> 06:35.490
没问题吧

06:35.490 --> 06:37.490
没有问题吧

06:37.490 --> 06:39.490
然后呢

06:39.490 --> 06:40.490
然后呢

06:40.490 --> 06:41.490
我们这一块

06:41.490 --> 06:43.490
就是我们要实现的就是这个东西

06:43.490 --> 06:45.490
也就是这个东西它会返回啥

06:45.490 --> 06:47.490
它可能会返回一个

06:47.490 --> 06:51.490
它可能会返回的是一个函数

06:51.490 --> 06:52.490
对吧

06:52.490 --> 06:54.490
它可能会返回一个函数

06:54.490 --> 06:55.490
然后调用这个函

06:55.490 --> 06:56.490
它返回的就是一个函数

06:56.490 --> 06:57.490
不是可能

06:57.490 --> 06:58.490
返回的就是一个函数

06:58.490 --> 06:59.490
然后呢

06:59.490 --> 07:00.490
这个调用这个函数呢

07:00.490 --> 07:03.490
它有可能有可能会返回一个新的函数

07:03.490 --> 07:04.490
你看

07:04.490 --> 07:06.490
它就会返回一个新的函数

07:06.490 --> 07:07.490
因为它现在固定的两个函数

07:07.490 --> 07:08.490
参数还不够

07:08.490 --> 07:09.490
对吧

07:09.490 --> 07:10.490
参数还不够

07:10.490 --> 07:12.490
它又返回一个新的函数

07:12.490 --> 07:13.490
然后也有可能呢

07:13.490 --> 07:14.490
就直接调用了

07:14.490 --> 07:16.490
比方说这里直接调用

07:16.490 --> 07:17.490
实现结果了

07:17.490 --> 07:18.490
就特别特别神奇

07:18.490 --> 07:19.490
这个函数

07:19.490 --> 07:20.490
但是它是写法

07:20.490 --> 07:21.490
也不太容易理解

07:21.490 --> 07:23.490
所以说它是个扩展课程

07:23.490 --> 07:24.490
好 接下来咱们来

07:24.490 --> 07:25.490
试着写一下

07:25.490 --> 07:26.490
这个颗粒化

07:26.490 --> 07:27.490
颗粒化

07:27.490 --> 07:28.490
这一节课学了完了

07:28.490 --> 07:29.490
过后呢

07:29.490 --> 07:30.490
咱们下一节课呢

07:30.490 --> 07:31.490
还有一个小操作

07:31.490 --> 07:32.490
也是扩展课程

07:32.490 --> 07:33.490
这个扩展课程呢

07:33.490 --> 07:34.490
它就可能会用到

07:34.490 --> 07:35.490
颗粒化的东西

07:35.490 --> 07:37.490
好 比方说myplunging

07:37.490 --> 07:40.490
好 然后这里curry

07:40.490 --> 07:41.490
发个信

07:41.490 --> 07:42.490
它要传什么参数

07:42.490 --> 07:43.490
传什么

07:43.490 --> 07:44.490
是不是传一个函数进来

07:44.490 --> 07:45.490
对不对

07:45.490 --> 07:46.490
传一个函数进来

07:46.490 --> 07:47.490
好

07:47.490 --> 07:49.490
生下来的随便传

07:49.490 --> 07:50.490
但是第一个必须是个函数

07:50.490 --> 07:52.490
生下来的参数随便传

07:52.490 --> 07:53.490
好

07:53.490 --> 07:55.490
接下来啊

07:55.490 --> 07:56.490
我们这里来表示

07:56.490 --> 07:57.490
它是一个颗粒化

07:57.490 --> 07:59.490
颗粒化函数

07:59.490 --> 08:01.490
好 这个颗粒化函数要干嘛呢

08:01.490 --> 08:03.490
它是不是一定会反回一个函数

08:03.490 --> 08:04.490
对吧

08:04.490 --> 08:05.490
它一定会反回一个函数

08:05.490 --> 08:07.490
刚才我们看到结果了

08:07.490 --> 08:09.490
这个颗粒化

08:09.490 --> 08:10.490
这个curry

08:10.490 --> 08:12.490
它一定会反回一个新的函数

08:12.490 --> 08:15.490
于是它又是个高阶函数

08:15.490 --> 08:17.490
然后这个新的函数里边呢

08:17.490 --> 08:19.490
它可能会接触不同的参数的值

08:19.490 --> 08:20.490
对不对

08:20.490 --> 08:21.490
好 那么现在呢

08:21.490 --> 08:22.490
问题是

08:22.490 --> 08:23.490
第一个问题

08:23.490 --> 08:25.490
我们雕用这个curry

08:25.490 --> 08:26.490
这个函数的时候

08:26.490 --> 08:27.490
第一个函数肯定要传函数

08:27.490 --> 08:28.490
这个没啥好说的

08:28.490 --> 08:29.490
第一个函数肯定传函数

08:29.490 --> 08:30.490
那么后边呢

08:30.490 --> 08:31.490
你随便

08:31.490 --> 08:32.490
你随便传几个

08:32.490 --> 08:33.490
我不管你

08:33.490 --> 08:34.490
随便你传几个

08:34.490 --> 08:36.490
那么后边传的参数是怎么意思呢

08:36.490 --> 08:37.490
是不是给它固定下来

08:37.490 --> 08:38.490
对不对

08:38.490 --> 08:39.490
把它的参数固定下来

08:39.490 --> 08:41.490
那你这里不管怎么样操作

08:41.490 --> 08:43.490
你是不是得把后边的参数得到

08:43.490 --> 08:45.490
得到它其他参数

08:45.490 --> 08:48.490
因此这里有个需求就是得到

08:48.490 --> 08:51.490
从第二个

08:51.490 --> 08:53.490
第二开始的参数

08:53.490 --> 08:55.490
应该说这样说吧

08:55.490 --> 08:58.490
应该是得到从下标

08:58.490 --> 08:59.490
一开始的参数

08:59.490 --> 09:00.490
对吧

09:00.490 --> 09:01.490
我们把参数想象成一个数组

09:01.490 --> 09:02.490
那么得到什么

09:02.490 --> 09:03.490
要得到下标

09:03.490 --> 09:06.490
从下标一开始的一个参数数组

09:06.490 --> 09:08.490
那么怎么得到了

09:08.490 --> 09:09.490
怎么得到了

09:09.490 --> 09:10.490
我们一定有一个对不对

09:10.490 --> 09:11.490
一定有一个

09:11.490 --> 09:12.490
一定有一个

09:12.490 --> 09:13.490
所以说呢

09:13.490 --> 09:14.490
那当然

09:14.490 --> 09:16.490
有没有可能你一个参数都没填

09:16.490 --> 09:17.490
一个参数都没填的话

09:17.490 --> 09:19.490
那这个函数就没有任何意义了

09:19.490 --> 09:21.490
如果你连函数都没给我传的话

09:21.490 --> 09:22.490
那这个函数没有什么意义了

09:22.490 --> 09:24.490
所以说我这里不管这种情况

09:24.490 --> 09:27.490
我只看下标一开始的参数

09:27.490 --> 09:28.490
于是那我怎么来做呢

09:28.490 --> 09:30.490
数组里边

09:30.490 --> 09:31.490
Prototype

09:31.490 --> 09:33.490
里边它不是一个函数叫做

09:33.490 --> 09:35.490
Snyce

09:35.490 --> 09:38.490
来切分数组

09:38.490 --> 09:39.490
切分数组

09:39.490 --> 09:40.490
第一个参数传

09:40.490 --> 09:41.490
传什么

09:41.490 --> 09:43.490
应该用这个

09:43.490 --> 09:47.120
call

09:47.120 --> 09:48.120
第一个参数传什么

09:48.120 --> 09:50.120
传的是不是argument

09:50.120 --> 09:52.120
我们把我们的所有参数的

09:52.120 --> 09:54.120
伪数组传进去

09:54.120 --> 09:55.120
来切分

09:55.120 --> 09:56.120
切分啥呢

09:56.120 --> 09:58.120
从哪个位置开始切分

09:58.120 --> 10:00.120
是不是从第一个位置开始切分

10:00.120 --> 10:01.120
就是第二个

10:01.120 --> 10:03.120
应该说下标唯一的位置开始切分

10:03.120 --> 10:05.120
那么切分得到是不是一个新的数组

10:05.120 --> 10:06.120
对不对

10:06.120 --> 10:07.120
我们保存了个变量里面吧

10:07.120 --> 10:08.120
accus

10:08.120 --> 10:09.120
我们来输出一下

10:09.120 --> 10:10.120
accus

10:10.120 --> 10:12.120
看一下能不能得到正确的结果

10:12.120 --> 10:13.120
好 这边

10:13.120 --> 10:15.120
我们先暂时不着急

10:15.120 --> 10:16.120
先暂时不着急

10:16.120 --> 10:17.120
下面的东西先暂时不着急

10:17.120 --> 10:19.120
我们看一下上面了

10:19.120 --> 10:21.120
我们把2固定下来

10:21.120 --> 10:23.120
那么我们的参数数组里边

10:23.120 --> 10:24.120
是不是应该有个2

10:24.120 --> 10:26.120
看一下

10:26.120 --> 10:27.120
这一块肯定比要糟

10:27.120 --> 10:28.120
肯定比要糟

10:28.120 --> 10:29.120
科丽话这里

10:29.120 --> 10:30.120
代码不多

10:30.120 --> 10:31.120
但是难度比较高

10:31.120 --> 10:33.120
你看 是不是得到我固定的参数

10:33.120 --> 10:34.120
固定的参数是不是一个2

10:34.120 --> 10:36.120
好 那如果我这里传了一个2和3

10:36.120 --> 10:37.120
是不是固定了两个参数了

10:37.120 --> 10:38.120
对不对

10:38.120 --> 10:39.120
固定了两个参数了

10:39.120 --> 10:40.120
你看

10:40.120 --> 10:41.120
是固定的吧

10:41.120 --> 10:42.120
没问题吧

10:42.120 --> 10:44.120
就固定了两个参数了

10:44.120 --> 10:45.120
是这么个意思

10:45.120 --> 10:46.120
这么个意思

10:46.120 --> 10:47.120
没问题吧

10:47.120 --> 10:48.120
OK

10:49.120 --> 10:50.120
好 这是这一块

10:50.120 --> 10:51.120
好 那么也就是说

10:51.120 --> 10:52.120
我们现在得到了是啥呢

10:52.120 --> 10:54.120
得到了就是固定的参数

10:54.120 --> 10:56.120
我们要固定哪些参数

10:56.120 --> 10:57.120
保存在这个数组里边

10:58.120 --> 11:00.120
好 接下来我返回一个函数

11:00.120 --> 11:02.120
这个函数就是在这边的这个函数

11:02.120 --> 11:03.120
就是这个函数

11:03.120 --> 11:05.120
这个函数是不是可以调用

11:05.120 --> 11:06.120
对吧

11:06.120 --> 11:07.120
它是不是也有可能传参数

11:07.120 --> 11:09.120
它也有可能传参数

11:09.120 --> 11:10.120
那么也就是说

11:10.120 --> 11:11.120
这个函数调用的时候

11:11.120 --> 11:12.120
是不是也可能会传参数

11:12.120 --> 11:13.120
对吧

11:13.120 --> 11:14.120
它也可能会传参数

11:14.120 --> 11:15.120
那么我们这里

11:15.120 --> 11:17.120
得到当前这个函数的参数

11:17.120 --> 11:18.120
可不可以得到

11:18.120 --> 11:19.120
把它变成数组

11:19.120 --> 11:20.120
把它变成数组

11:20.120 --> 11:21.120
就是array

11:21.120 --> 11:22.120
from

11:22.120 --> 11:23.120
这个argument

11:23.120 --> 11:24.120
把它变成数组

11:24.120 --> 11:25.120
那么现在我们是得到

11:25.120 --> 11:27.120
当前这个函数的参数

11:27.120 --> 11:28.120
当前

11:28.120 --> 11:29.120
调用的

11:29.120 --> 11:30.120
参数

11:30.120 --> 11:31.120
对吧

11:31.120 --> 11:32.120
就得到了

11:32.120 --> 11:34.120
然后怎么样了

11:34.120 --> 11:35.120
然后怎么样了

11:35.120 --> 11:37.120
接下来我要判断

11:37.120 --> 11:38.120
参数够不够

11:39.120 --> 11:40.120
如果之前固定的参数

11:40.120 --> 11:41.120
已经有了

11:41.120 --> 11:42.120
对吧

11:42.120 --> 11:43.120
之前固定的参数已经有了

11:43.120 --> 11:44.120
那么这是当前的参数

11:44.120 --> 11:45.120
对吧

11:45.120 --> 11:46.120
好 两个数组

11:46.120 --> 11:47.120
这是两个数组

11:47.120 --> 11:48.120
对吧

11:48.120 --> 11:49.120
两个数组

11:49.120 --> 11:50.120
比方说

11:50.120 --> 11:51.120
我们之前固定的参数2

11:51.120 --> 11:52.120
固定的参数2

11:52.120 --> 11:53.120
你看一下

11:53.120 --> 11:54.120
这是个参数数组

11:54.120 --> 11:55.120
2 对不对

11:55.120 --> 11:56.120
好 那么现在

11:56.120 --> 11:57.120
我们这里再调用

11:57.120 --> 11:59.120
返回的是一个新函数

11:59.120 --> 12:01.120
然后我们调用这个函数的时候

12:01.120 --> 12:03.120
调用这个函数的时候

12:04.120 --> 12:05.120
看着

12:05.120 --> 12:06.120
调用这个函数的时候

12:06.120 --> 12:07.120
我们这边

12:08.120 --> 12:09.120
G

12:09.120 --> 12:10.120
然后再调用

12:10.120 --> 12:11.120
3

12:11.120 --> 12:12.120
一看

12:13.120 --> 12:14.120
是吧

12:14.120 --> 12:15.120
又输出了一个3

12:15.120 --> 12:16.120
对不对

12:16.120 --> 12:17.120
一开始输出一个2

12:17.120 --> 12:18.120
我们刚才再输出一次

12:19.120 --> 12:20.120
再输出一次

12:20.120 --> 12:21.120
就是调用carray这个函数

12:21.120 --> 12:22.120
它输出了

12:22.120 --> 12:23.120
它固定的参数

12:23.120 --> 12:24.120
已经调用这个函数

12:24.120 --> 12:25.120
它是也有参数

12:25.120 --> 12:26.120
它剩余的参数

12:27.120 --> 12:28.120
是不是得到两个数组

12:28.120 --> 12:29.120
对不对

12:29.120 --> 12:30.120
两个数组

12:30.120 --> 12:31.120
然后接下来

12:31.120 --> 12:32.120
我们是不把两个数组拼接起来

12:32.120 --> 12:33.120
对不对

12:33.120 --> 12:34.120
拼接起来

12:34.120 --> 12:35.120
用个变量

12:35.120 --> 12:36.120
toto

12:36.120 --> 12:37.120
archius

12:37.120 --> 12:38.120
总共的参数

12:38.120 --> 12:39.120
两个数组拼接

12:39.120 --> 12:40.120
两个数组拼接

12:40.120 --> 12:41.120
是不是很简单

12:41.120 --> 12:42.120
concat

12:42.120 --> 12:43.120
数组里面不是有函数吗

12:43.120 --> 12:44.120
concat

12:44.120 --> 12:45.120
方法

12:45.120 --> 12:46.120
然后拼接carr

12:46.120 --> 12:47.120
archius

12:47.120 --> 12:48.120
注意顺序

12:48.120 --> 12:49.120
它去拼接它

12:49.120 --> 12:50.120
好 那么得到一个

12:50.120 --> 12:51.120
就是总参数

12:51.120 --> 12:52.120
总参数

12:52.120 --> 12:53.120
toto

12:53.120 --> 12:54.120
archius

12:54.120 --> 12:55.120
你看一下

12:56.120 --> 12:57.120
看一下这边

12:57.120 --> 12:58.120
我们这里先固定2

12:58.120 --> 13:00.120
然后再去运行3的时候

13:00.120 --> 13:01.120
你看一下得到的参数

13:01.120 --> 13:02.120
是不是2和3

13:02.120 --> 13:03.120
对不对

13:03.120 --> 13:04.120
所有的参数都得到了

13:04.120 --> 13:07.120
那这里我运行的是3 4

13:07.120 --> 13:08.120
那么得到了参数

13:08.120 --> 13:09.120
是不是2 3 4

13:09.120 --> 13:10.120
对吧

13:10.120 --> 13:11.120
24已经固定下来了

13:11.120 --> 13:12.120
对吧

13:12.120 --> 13:13.120
我们已经固定在这了

13:13.120 --> 13:15.120
放到这个数组里边了

13:15.120 --> 13:17.120
我们得到了总的参数数组

13:17.120 --> 13:19.120
那么接下来干嘛呢

13:19.120 --> 13:21.120
要分成两种情况

13:21.120 --> 13:23.120
哪两种情况了

13:23.120 --> 13:24.120
第一种情况

13:24.120 --> 13:26.120
就是它参数的数量已经够了

13:26.120 --> 13:27.120
然后这里

13:27.120 --> 13:29.120
参数的数量是不是已经够了

13:29.120 --> 13:30.120
一共就需要三个参数

13:30.120 --> 13:31.120
对不对

13:31.120 --> 13:32.120
参数的数量够了

13:32.120 --> 13:34.120
所以说直接调用就完事了

13:34.120 --> 13:36.120
那么关键是怎么来判断

13:36.120 --> 13:37.120
参数数量够不够了

13:37.120 --> 13:38.120
其实判断的是

13:38.120 --> 13:41.120
判断的就是总参数的长度

13:41.120 --> 13:43.120
是不是大于等于

13:43.120 --> 13:47.120
这个函数需要的参数长度

13:47.120 --> 13:48.120
那么怎么来判断

13:48.120 --> 13:49.120
它需要的参数长度呢

13:49.120 --> 13:51.120
所有的函数都有一个属性

13:51.120 --> 13:52.120
叫nance

13:52.120 --> 13:53.120
表示这个函数

13:53.120 --> 13:55.120
它接收几个行参

13:55.120 --> 13:56.120
那么这样子一判断

13:56.120 --> 13:57.120
表示什么

13:57.120 --> 14:00.120
参数数量够了

14:00.120 --> 14:02.120
参数数量够了

14:02.120 --> 14:04.120
那么这个时候

14:04.120 --> 14:05.120
参数的数量

14:05.120 --> 14:06.120
它已经够了

14:06.120 --> 14:07.120
这个时候干嘛呢

14:07.120 --> 14:09.120
是不是直接调用这个函数

14:09.120 --> 14:10.120
就完事了

14:10.120 --> 14:11.120
我们所有的参数

14:11.120 --> 14:12.120
已经拿到了

14:12.120 --> 14:13.120
已经组合起来了

14:13.120 --> 14:14.120
成为一个数组

14:14.120 --> 14:15.120
因此直接调用这个函数

14:15.120 --> 14:18.120
我们用apply

14:18.120 --> 14:19.120
因为apply里面

14:19.120 --> 14:20.120
参数不就是个数组

14:20.120 --> 14:21.120
对不对

14:21.120 --> 14:22.120
z是的话就写了

14:22.120 --> 14:23.120
no

14:23.120 --> 14:24.120
我们这里不carez

14:24.120 --> 14:26.120
然后后面就是参数的数组

14:26.120 --> 14:27.120
是不是我们已经拿到了

14:27.120 --> 14:28.120
总参数的数组

14:28.120 --> 14:29.120
是吧

14:29.120 --> 14:31.120
直接调用这个函数就完事了

14:31.120 --> 14:34.120
把这个函数的调用结果返回

14:34.120 --> 14:35.120
返回

14:35.120 --> 14:36.120
是不是完了

14:36.120 --> 14:38.120
这种情况我就已经处理完了

14:38.120 --> 14:39.120
看一下

14:39.120 --> 14:41.120
那我们把这两个去掉

14:41.120 --> 14:43.120
这两个去掉

14:43.120 --> 14:44.120
看一下

14:44.120 --> 14:46.120
我们刚才固定了一个参数

14:46.120 --> 14:47.120
然后再掉

14:47.120 --> 14:48.120
它得到一个新的函数

14:48.120 --> 14:49.120
这个函数

14:49.120 --> 14:51.120
我们把剩余的参数给它传进去

14:51.120 --> 14:52.120
好看一下结果

14:52.120 --> 14:54.120
2542

14:54.120 --> 14:55.120
对不对

14:55.120 --> 14:56.120
正确的

14:56.120 --> 14:57.120
为什么

14:57.120 --> 14:59.120
2加3等于6

15:00.120 --> 15:01.120
2加3等于5

15:01.120 --> 15:02.120
5乘以525

15:02.120 --> 15:04.120
2加5等于7

15:04.120 --> 15:05.120
7乘以642

15:05.120 --> 15:06.120
说对了

15:06.120 --> 15:07.120
没问题吧

15:07.120 --> 15:08.120
这样子就可以了

15:08.120 --> 15:09.120
就参数数量

15:09.120 --> 15:10.120
如果够了的话

15:10.120 --> 15:11.120
那么我就返回

15:11.120 --> 15:13.120
一个调用的结果

15:13.120 --> 15:14.120
就完事了

15:14.120 --> 15:16.120
那么关键是另外一种情况

15:16.120 --> 15:18.120
参数数量不够

15:18.120 --> 15:19.120
数量

15:19.120 --> 15:21.120
仍然不够

15:21.120 --> 15:23.120
仍然不够

15:23.120 --> 15:24.120
那么这种情况下

15:24.120 --> 15:25.120
是不是要继续返回函数

15:25.120 --> 15:26.120
继续固定参数

15:26.120 --> 15:27.120
对吧

15:27.120 --> 15:28.120
你看这里

15:28.120 --> 15:29.120
参数的数量不够的情况下

15:29.120 --> 15:30.120
你不用这个G

15:30.120 --> 15:32.120
它只传了一个4

15:32.120 --> 15:33.120
它只传了一个4

15:33.120 --> 15:35.120
那么这种情况下

15:35.120 --> 15:37.120
我们得返回一个新的函数

15:37.120 --> 15:39.120
那参数数量不够

15:39.120 --> 15:41.120
好 那这个时候怎么办呢

15:42.120 --> 15:44.120
这个时候怎么办呢

15:44.120 --> 15:45.120
这个时候

15:45.120 --> 15:47.120
我们只需要再一次去调用

15:47.120 --> 15:49.120
这个career就完事了

15:49.120 --> 15:51.120
再一次去调用这个career

15:51.120 --> 15:53.120
重新固定一下新的参数

15:53.120 --> 15:54.120
重新固定参数

15:54.120 --> 15:55.120
就说就完事了

15:55.120 --> 15:56.120
因为这个东西

15:56.120 --> 15:57.120
career这个东西干嘛的

15:57.120 --> 15:59.120
就是来固定参数的

15:59.120 --> 16:00.120
我们重新去调用career

16:00.120 --> 16:02.120
它又会返回一个新的函数

16:02.120 --> 16:04.120
那么就固定了更多的参数了

16:04.120 --> 16:05.120
好吧

16:05.120 --> 16:06.120
那么这里怎么显呢

16:06.120 --> 16:07.120
怎么显呢

16:07.120 --> 16:09.120
那么我们就要通过Z

16:09.120 --> 16:10.120
得到这个career

16:10.120 --> 16:11.120
但是问题是

16:11.120 --> 16:12.120
这里的Z

16:13.120 --> 16:14.120
Z是你用不了

16:14.120 --> 16:16.120
因为这个Z是哪个函数里边

16:16.120 --> 16:17.120
这个函数里边

16:17.120 --> 16:18.120
这个函数是直接调用的

16:18.120 --> 16:19.120
你看外面

16:19.120 --> 16:20.120
是不是直接调用的

16:20.120 --> 16:22.120
因此这里的Z是用不了

16:22.120 --> 16:24.120
因此在这里的Z是不可以用的

16:24.120 --> 16:25.120
这里的Z是可以用的

16:25.120 --> 16:27.120
因为这个时候在这个函数里边

16:27.120 --> 16:29.120
这个函数是怎么调用的

16:29.120 --> 16:30.120
你看

16:30.120 --> 16:31.120
myplugin.career

16:31.120 --> 16:33.120
所以说Z是会指向它

16:33.120 --> 16:34.120
因此我们这样

16:34.120 --> 16:35.120
这里可以怎么办呢

16:35.120 --> 16:36.120
这里也是一种常见的操作

16:36.120 --> 16:37.120
我们把Z

16:37.120 --> 16:38.120
保存到Z里边

16:38.120 --> 16:39.120
就定一个辨量

16:39.120 --> 16:40.120
保存一下Z

16:40.120 --> 16:42.120
Z不是很特殊的一个关键字吗

16:42.120 --> 16:43.120
我们把这个指向的词

16:43.120 --> 16:44.120
保存到一个辨量里边

16:44.120 --> 16:45.120
那么利用B包

16:45.120 --> 16:47.120
那这里是不是可以获取Z

16:47.120 --> 16:48.120
对吧

16:48.120 --> 16:50.120
可以通过这个东西来获取

16:50.120 --> 16:51.120
Z

16:51.120 --> 16:53.120
它里边career

16:53.120 --> 16:54.120
career

16:54.120 --> 16:55.120
然后呢

16:55.120 --> 16:57.120
是不是继续来

16:57.120 --> 16:59.120
apply

16:59.120 --> 17:00.120
什么apply呢

17:00.120 --> 17:01.120
Z

17:01.120 --> 17:02.120
Z的话

17:02.120 --> 17:03.120
那么绑定啥

17:03.120 --> 17:04.120
Z绑定啥

17:04.120 --> 17:05.120
Z是不是绑定Z

17:05.120 --> 17:06.120
对不对

17:06.120 --> 17:07.120
对吧

17:07.120 --> 17:08.120
Z绑定Z

17:08.120 --> 17:09.120
好

17:09.120 --> 17:11.120
后边的参数传啥呢

17:11.120 --> 17:12.120
传啥

17:12.120 --> 17:13.120
第一个参数是不是还是这个

17:13.120 --> 17:15.120
第一个参数是没变化的对不对

17:15.120 --> 17:16.120
第一个参数还是这个

17:16.120 --> 17:18.120
然后后边的参数是不是

17:18.120 --> 17:19.120
它

17:19.120 --> 17:20.120
能理解吗

17:20.120 --> 17:22.120
能不能理解

17:22.120 --> 17:23.120
好 这里再看一下吧

17:23.120 --> 17:24.120
这个地方

17:24.120 --> 17:26.120
一开始我们固定了一个参数

17:26.120 --> 17:27.120
对吧

17:27.120 --> 17:28.120
我们先看这两句话

17:28.120 --> 17:29.120
先看这个

17:29.120 --> 17:30.120
固定了一个参数2

17:30.120 --> 17:31.120
参数数量是不是不够

17:31.120 --> 17:32.120
对不对

17:32.120 --> 17:33.120
返回了一个新的函数G

17:33.120 --> 17:35.120
那么我们再喘一个参数4

17:35.120 --> 17:37.120
现在是不是两个参数了

17:37.120 --> 17:38.120
对吧

17:38.120 --> 17:39.120
两个参数了

17:39.120 --> 17:40.120
那么这个时候得到一个Y

17:40.120 --> 17:44.120
这个Y是不是相当于是这个

17:44.120 --> 17:47.120
是不是相当于是这个

17:47.120 --> 17:48.120
对吧

17:48.120 --> 17:50.120
这个Y是不是相当于这个

17:50.120 --> 17:51.120
好 你看一下吧

17:51.120 --> 17:53.120
我们上面刚才是这样子写的

17:53.120 --> 17:54.120
G等于4

17:54.120 --> 17:55.120
那现在是不是固定了两个参数呢

17:55.120 --> 17:57.120
2和4是不是都要固定下来

17:57.120 --> 17:58.120
对不对

17:58.120 --> 17:59.120
得到参数Y

17:59.120 --> 18:00.120
那么Y相当于是不是相当于这个玩意儿

18:00.120 --> 18:01.120
对不对

18:01.120 --> 18:02.120
所以说我们这里就

18:02.120 --> 18:03.120
就去重新调用一下

18:03.120 --> 18:04.120
已经完事了

18:04.120 --> 18:06.120
那么Carrie里面说要传三个参数

18:06.120 --> 18:07.120
对不对

18:07.120 --> 18:09.120
那第一个参数是不是一定还是这个函数

18:09.120 --> 18:10.120
还是个函数不变

18:10.120 --> 18:11.120
后边的才是

18:11.120 --> 18:14.120
要固定的函数

18:14.120 --> 18:15.120
就这么个意思

18:15.120 --> 18:16.120
它是两部分

18:16.120 --> 18:18.120
第一部分的是函数

18:18.120 --> 18:20.120
第二部分的是函数的参数

18:20.120 --> 18:21.120
所以说我们这里只得到了

18:21.120 --> 18:23.120
这个函数的目前的所有参数

18:23.120 --> 18:25.120
还要给它数组里面加一项

18:25.120 --> 18:26.120
对不对

18:26.120 --> 18:27.120
往数组里面加一项

18:27.120 --> 18:29.120
怎么来加一项呢

18:29.120 --> 18:30.120
偷偷

18:30.120 --> 18:31.120
往数组里面的第一项加一项

18:31.120 --> 18:32.120
该咋咋写

18:32.120 --> 18:33.120
第一项加一项

18:33.120 --> 18:35.120
是不是un-sharped

18:35.120 --> 18:36.120
对不对

18:36.120 --> 18:37.120
un-sharped

18:37.120 --> 18:39.120
往它第一项给它加一项

18:39.120 --> 18:41.120
往它第一项里面加

18:41.120 --> 18:42.120
加啥呢

18:42.120 --> 18:44.120
是不是加函数

18:44.120 --> 18:45.120
加函数

18:45.120 --> 18:46.120
没问题吧

18:46.120 --> 18:48.120
那么我们把这个函数传进来

18:48.120 --> 18:49.120
是不是

18:49.120 --> 18:51.120
我们得到了一个新的函数了

18:51.120 --> 18:53.120
这样我们会得到一个新的函数

18:53.120 --> 18:54.120
这个函数

18:54.120 --> 18:56.120
它只剩下一个函数

18:56.120 --> 18:59.120
或者就只剩下生女的函数了

18:59.120 --> 19:01.120
好咱们再来看一下

19:01.120 --> 19:03.120
那么目前我们来看一下下面的结果

19:03.120 --> 19:06.940
看一下吧

19:06.940 --> 19:07.940
保存

19:07.940 --> 19:08.940
看一下

19:08.940 --> 19:09.940
前边是25

19:09.940 --> 19:10.940
42

19:10.940 --> 19:11.940
刚才验证了没问题

19:11.940 --> 19:13.940
然后后边得到一个新的函数

19:13.940 --> 19:14.940
y

19:14.940 --> 19:15.940
再把期传进去

19:15.940 --> 19:16.940
之前固定了啥

19:16.940 --> 19:17.940
固定了2和4

19:17.940 --> 19:19.940
2加40固定为6

19:19.940 --> 19:20.940
对不对

19:20.940 --> 19:21.940
6742

19:21.940 --> 19:22.940
6742

19:22.940 --> 19:23.940
然后

19:23.940 --> 19:25.940
6乘以16

19:25.940 --> 19:27.940
96

19:27.940 --> 19:29.940
就没问题了

19:29.940 --> 19:30.940
对不对

19:30.940 --> 19:31.940
这就是颗粒化

19:31.940 --> 19:33.940
这么一个函数

19:33.940 --> 19:34.940
就写完了

19:34.940 --> 19:35.940
好好去理一下吧

19:35.940 --> 19:36.940
这个代码并不多

19:36.940 --> 19:38.940
但是这里的理解

19:38.940 --> 19:41.940
你需要好好去理解一下

19:41.940 --> 19:42.940
这个函数写完了之后

19:42.940 --> 19:44.940
我们来看一下它有什么用

19:44.940 --> 19:45.940
做了个稍稍多

19:45.940 --> 19:46.940
到底有什么用的

19:46.940 --> 19:48.940
比方说吧

19:48.940 --> 19:51.940
我们这里有这么个例子

19:51.940 --> 19:57.430
这个例子是这样子

19:57.430 --> 19:58.430
我呢

19:58.430 --> 20:00.430
这里有一个DIV

20:00.430 --> 20:02.430
一个DIV container

20:03.430 --> 20:06.430
我要往这个DIV里面加东西

20:06.430 --> 20:08.430
往它里面加东西

20:08.430 --> 20:09.430
我给它写一个吧

20:09.430 --> 20:10.430
container

20:10.430 --> 20:11.430
写个边方

20:11.430 --> 20:12.430
border

20:12.430 --> 20:13.430
两个箱数

20:13.430 --> 20:14.430
solid

20:14.430 --> 20:16.430
panning

20:16.430 --> 20:17.430
panning

20:17.430 --> 20:19.430
然后30个箱数

20:19.430 --> 20:20.430
行了

20:20.430 --> 20:21.430
看一下吧

20:21.430 --> 20:23.430
我要往这个DIV里面加东西

20:23.430 --> 20:24.430
那加啥东西呢

20:24.430 --> 20:26.430
它可能会加各种各样的东西

20:26.430 --> 20:27.430
可能会加图片

20:27.430 --> 20:28.430
也可能会加啥呢

20:28.430 --> 20:30.430
也可能会加一个

20:30.430 --> 20:32.430
CSS样式

20:32.430 --> 20:34.430
加一个DIV

20:34.430 --> 20:36.430
它还带有CSS样式

20:36.430 --> 20:38.430
可能会加各种各样的东西

20:38.430 --> 20:40.430
为了方便

20:40.430 --> 20:41.430
后边操作

20:41.430 --> 20:42.430
于是我就写了这么一个函数

20:42.430 --> 20:43.430
看着

20:43.430 --> 20:44.430
这个函数是这样子

20:44.430 --> 20:47.430
叫做create element

20:47.430 --> 20:48.430
创建

20:48.430 --> 20:49.430
创建什么

20:49.430 --> 20:50.430
创建一个元素

20:50.430 --> 20:51.430
创建一个元素

20:51.430 --> 20:52.430
写这么一个函数

20:52.430 --> 20:53.430
第一个参数

20:53.430 --> 20:55.430
是元素的名字

20:57.430 --> 20:59.430
第一个参数是容器

20:59.430 --> 21:00.430
就是我要把这个元素

21:00.430 --> 21:02.430
加到哪个容器里面

21:02.430 --> 21:03.430
明白我的意思吧

21:03.430 --> 21:05.430
我们要把哪个元素

21:05.430 --> 21:07.430
加到这个容器里

21:07.430 --> 21:09.430
把元素加到哪个容器里面

21:09.430 --> 21:10.430
那么第一个参数呢

21:10.430 --> 21:11.430
是容器

21:11.430 --> 21:12.430
扛天哪

21:12.430 --> 21:13.430
当然我们这里

21:13.430 --> 21:15.430
肯定会往它那边加

21:15.430 --> 21:17.430
那么我希望这个函数通用

21:17.430 --> 21:18.430
通用的话

21:18.430 --> 21:19.430
那肯定你不能假设

21:19.430 --> 21:20.430
它一定是这个DIV

21:20.430 --> 21:21.430
又可能是别的

21:21.430 --> 21:23.430
那么你第一个参数

21:23.430 --> 21:24.430
肯定要传一个动物对象进来

21:24.430 --> 21:26.430
我要往哪个容器里面加

21:26.430 --> 21:27.430
第二个参数呢

21:27.430 --> 21:28.430
是元素的名称

21:29.430 --> 21:30.430
这个没问题吧

21:31.430 --> 21:32.430
第三个参数呢

21:32.430 --> 21:34.430
是元素的属性

21:34.430 --> 21:36.430
元素的属性PROPS

21:36.430 --> 21:37.430
对元素有哪些属性

21:37.430 --> 21:39.430
比方说1m级元素有SRC属性

21:39.430 --> 21:40.430
对吧

21:40.430 --> 21:41.430
还有什么属性

21:41.430 --> 21:42.430
还有元素呢

21:42.430 --> 21:43.430
A元素

21:43.430 --> 21:44.430
A元素它有什么属性呢

21:44.430 --> 21:45.430
还有就是

21:46.430 --> 21:48.430
A元素它就有REF属性

21:48.430 --> 21:49.430
对不对

21:49.430 --> 21:51.430
第三个参数是属性

21:51.430 --> 21:52.430
第四个参数呢

21:52.430 --> 21:54.430
是元素的

21:54.430 --> 21:55.430
样式

21:55.430 --> 21:57.430
Styles

21:57.430 --> 21:58.430
这两个都是对象

21:58.430 --> 21:59.430
都是对象

21:59.430 --> 22:00.430
都是对象

22:03.430 --> 22:04.430
然后再来

22:04.430 --> 22:05.430
再来

22:05.430 --> 22:06.430
还有什么呢

22:06.430 --> 22:08.430
还有元素的内容

22:08.430 --> 22:09.430
内文本

22:09.430 --> 22:10.430
content

22:10.430 --> 22:11.430
你看它有这么多参数

22:12.430 --> 22:13.430
这个函数我们怎么写呢

22:13.430 --> 22:14.430
我们咋写呢

22:14.430 --> 22:16.430
我们就可以这样子写

22:17.430 --> 22:18.430
首先

22:18.430 --> 22:19.430
Document

22:19.430 --> 22:20.430
CreateElement

22:20.430 --> 22:21.430
创建一个元素

22:21.430 --> 22:22.430
元素的名称

22:22.430 --> 22:23.430
Name对吧

22:23.430 --> 22:24.430
元素的名称

22:25.430 --> 22:27.430
Tact表示标签

22:27.430 --> 22:28.430
叫做Element

22:28.430 --> 22:29.430
L

22:29.430 --> 22:30.430
表示元素

22:30.430 --> 22:32.430
元素通过名称来创建一个元素

22:32.430 --> 22:33.430
然后呢

22:33.430 --> 22:34.430
把这个元素加到哪里边去

22:34.430 --> 22:36.430
加到这个content里面去

22:36.430 --> 22:38.430
Append Child

22:38.430 --> 22:40.430
加到这里面去

22:40.430 --> 22:41.430
然后呢

22:41.430 --> 22:42.430
这个元素是不是有很多属性

22:42.430 --> 22:44.430
是不是要循环这个对象

22:44.430 --> 22:45.430
对不对

22:45.430 --> 22:46.430
这是个对象

22:46.430 --> 22:47.430
假设它是个对象

22:47.430 --> 22:48.430
我们这里

22:48.430 --> 22:49.430
一切函数

22:49.430 --> 22:51.430
它的参数肯定要约定好

22:51.430 --> 22:52.430
肯定要约定好

22:52.430 --> 22:53.430
那么循环这个对象

22:53.430 --> 22:55.430
这个对象里边的属性

22:55.430 --> 22:57.430
属性就是不是就是元素的属性

22:57.430 --> 22:59.430
它就是元素的属性

22:59.430 --> 23:01.430
我们就给这个元素加上这个属性

23:01.430 --> 23:03.430
给它加上这个属性

23:03.430 --> 23:04.430
我们给它设置

23:04.430 --> 23:06.430
给这个元素设置L

23:06.430 --> 23:07.430
它是什么

23:07.430 --> 23:09.430
这个属性等于什么

23:09.430 --> 23:10.430
Probs

23:10.430 --> 23:11.430
属性

23:11.430 --> 23:12.430
这种情况

23:12.430 --> 23:13.430
应该是见多了

23:13.430 --> 23:14.430
对吧

23:14.430 --> 23:15.430
然后是样式

23:15.430 --> 23:16.430
样式

23:16.430 --> 23:17.430
所以也是要循环

23:17.430 --> 23:19.430
样式这里循环这个对象

23:19.430 --> 23:20.430
它们都是对象

23:20.430 --> 23:21.430
然后呢

23:21.430 --> 23:23.430
这个元素里边的

23:23.430 --> 23:24.430
Style

23:24.430 --> 23:25.430
就是Probs

23:25.430 --> 23:28.430
应该等于Styles

23:28.430 --> 23:29.430
Probs

23:29.430 --> 23:30.430
这是样式

23:30.430 --> 23:32.430
最后是元素的内容

23:32.430 --> 23:33.430
Inner

23:33.430 --> 23:34.430
ATML

23:34.430 --> 23:35.430
等于内容

23:36.430 --> 23:37.430
你看这个函数是不是写完了

23:37.430 --> 23:39.430
这个函数其实代码也不多

23:39.430 --> 23:40.430
咱们再试验一下

23:40.430 --> 23:41.430
试验一下这个函数

23:41.430 --> 23:42.430
行不行

23:42.430 --> 23:43.430
能不能

23:43.430 --> 23:44.430
就是正常的使用

23:45.430 --> 23:46.430
我们这样的传递

23:49.430 --> 23:50.430
这样的传递

23:51.430 --> 23:52.430
我们CreateElement

23:52.430 --> 23:53.430
比方说

23:53.430 --> 23:55.430
我要往里边加一个啥呢

23:55.430 --> 23:56.430
加一个

23:57.430 --> 23:59.430
我们要加的是对象是DIV

23:59.430 --> 24:00.430
对不对

24:00.430 --> 24:01.430
加了对象是个DIV

24:01.430 --> 24:03.430
我们这里写Documents

24:03.430 --> 24:04.430
QuerrySelecter

24:04.430 --> 24:05.430
什么

24:05.430 --> 24:06.430
Container

24:06.430 --> 24:07.430
当然我们也可以把它

24:07.430 --> 24:08.430
保存到辨量里边

24:08.430 --> 24:09.430
因为我们以后

24:09.430 --> 24:10.430
会加很多的东西

24:10.430 --> 24:11.430
往里边

24:11.430 --> 24:12.430
容器

24:12.430 --> 24:13.430
我们先得到的容器

24:13.430 --> 24:14.430
那么第1个就是DIV

24:14.430 --> 24:15.430
对不对

24:15.430 --> 24:16.430
我们往里边

24:16.430 --> 24:17.430
加一个这么的东西

24:17.430 --> 24:18.430
好

24:18.430 --> 24:19.430
第2个就是元素的名字

24:19.430 --> 24:20.430
元素的名字

24:20.430 --> 24:21.430
说我们写个一密集

24:21.430 --> 24:22.430
创建一个图片

24:23.430 --> 24:24.430
然后呢

24:24.430 --> 24:25.430
元素有属性

24:25.430 --> 24:26.430
有哪些属性

24:26.430 --> 24:27.430
属性呢

24:27.430 --> 24:28.430
我们就在这里写

24:28.430 --> 24:29.430
图片的src路径

24:30.430 --> 24:31.430
路径是什么呢

24:31.430 --> 24:32.430
我们就随便写一个

24:32.430 --> 24:33.430
随便下载当中的图片吧

24:36.430 --> 24:37.430
好 实际

24:37.430 --> 24:38.430
你懂的对吧

24:41.430 --> 24:42.430
这里

24:42.430 --> 24:44.430
复制一个图片地址吧

24:44.430 --> 24:45.430
领存为

24:45.430 --> 24:46.430
保存下来

24:48.430 --> 24:49.430
1.jpg

24:50.430 --> 24:51.430
放过来

24:51.430 --> 24:53.740
好 这里

24:53.740 --> 24:54.740
我们来设置一下

24:54.740 --> 24:55.740
元素的路

24:55.740 --> 24:56.740
就src属性呢

24:56.740 --> 24:57.740
就是1.jpg

24:57.740 --> 24:58.740
对吧

24:58.740 --> 24:59.740
这是第3个参数

24:59.740 --> 25:00.740
第4个参数呢

25:01.740 --> 25:02.740
第4个参数呢

25:02.740 --> 25:03.740
是元素的央视

25:03.740 --> 25:04.740
央视的话

25:04.740 --> 25:05.740
我们给它设置一个宽度

25:05.740 --> 25:06.740
宽度的话

25:06.740 --> 25:07.740
100个像素

25:08.740 --> 25:11.120
对

25:11.120 --> 25:12.120
100个像素

25:12.120 --> 25:13.120
100个像素

25:13.120 --> 25:14.120
接下来是元素的内容

25:14.120 --> 25:16.120
元素的内容没有

25:16.120 --> 25:17.120
图片没有元素内容

25:17.120 --> 25:18.120
没有元素内容就不写了

25:19.120 --> 25:20.120
好了

25:20.120 --> 25:21.120
写完了

25:21.120 --> 25:22.120
于是我们运行看一下

25:22.120 --> 25:23.120
看下能不能创建张图片

25:23.120 --> 25:24.120
是不是创建了

25:24.120 --> 25:25.120
通过这个函数

25:25.120 --> 25:26.120
我们就可以帮助我们

25:26.120 --> 25:27.120
来创建一个元素进来

25:28.120 --> 25:29.120
我们看一下这个元素

25:29.120 --> 25:30.120
你看

25:30.120 --> 25:31.120
src属性就加进去了

25:31.120 --> 25:32.120
style是不是加进

25:32.120 --> 25:33.120
这个位置是不是加进去了

25:33.120 --> 25:34.120
对吧

25:34.120 --> 25:35.120
内容是昂迪范

25:35.120 --> 25:36.120
内容是昂迪范

25:36.120 --> 25:37.120
但是这个没什么意义

25:37.120 --> 25:38.120
图片里面内容是没意义的

25:38.120 --> 25:39.120
当然那边可以判断一下

25:39.120 --> 25:40.120
有没有内容

25:40.120 --> 25:41.120
如果没有内容的话

25:41.120 --> 25:42.120
就不要夹了

25:42.120 --> 25:43.120
当然这边可以判断

25:43.120 --> 25:44.120
就是

25:44.120 --> 25:46.120
如果有内容的话

25:46.120 --> 25:47.120
如果有内容的话

25:47.120 --> 25:48.120
那么怎么样了

25:48.120 --> 25:49.120
就夹

25:49.120 --> 25:50.120
没有内容就不夹

25:50.120 --> 25:51.120
当然可以判断

25:52.120 --> 25:53.120
保存

25:53.120 --> 25:54.120
那现在就正常的元素了

25:55.120 --> 25:57.120
那么现在我们继续来

25:58.120 --> 25:59.120
比方说的话

25:59.120 --> 26:00.120
比方说

26:00.120 --> 26:01.120
我们这里创建的不是图片

26:01.120 --> 26:02.120
创建的是什么

26:02.120 --> 26:03.120
这个函数不重要

26:03.120 --> 26:04.120
这个函数

26:04.120 --> 26:05.120
它底边怎么写不重要

26:05.120 --> 26:07.120
关键是我们怎么去调用

26:07.120 --> 26:08.120
比方说

26:08.120 --> 26:10.120
我们这里创建的是DIV

26:10.120 --> 26:12.120
创建的是DIV

26:13.120 --> 26:14.120
这个DIV

26:14.120 --> 26:16.120
没有属性

26:17.120 --> 26:18.120
但它有样式

26:18.120 --> 26:19.120
它有样式

26:19.120 --> 26:20.120
有什么样式

26:20.120 --> 26:21.120
这个DIV

26:21.120 --> 26:22.120
它有一个

26:23.120 --> 26:24.120
高度

26:24.120 --> 26:26.120
为100个像素

26:26.120 --> 26:28.120
有一个背景颜色

26:28.120 --> 26:29.120
Background

26:29.120 --> 26:30.120
有一个背景颜色

26:30.120 --> 26:32.120
为F40

26:32.120 --> 26:34.120
有一个Margin

26:34.120 --> 26:35.120
有一个Margin

26:35.120 --> 26:37.120
为30个像素

26:38.120 --> 26:40.120
比方说创建这么个DIV

26:40.120 --> 26:41.120
DIV的内容

26:41.120 --> 26:42.120
我们这里比方说

26:42.120 --> 26:44.120
第一个DIV

26:45.120 --> 26:46.120
比方说

26:46.120 --> 26:47.120
保存

26:47.120 --> 26:48.120
你看一下

26:48.120 --> 26:49.120
DIV是不是创建出来了

26:50.120 --> 26:52.120
但是我们现在有可能

26:52.120 --> 26:53.120
会多次调用这个东西

26:53.120 --> 26:55.120
它会多次调用

26:55.120 --> 26:56.120
这样子写出来

26:56.120 --> 26:57.120
是不是有很多重复代

26:57.120 --> 26:58.120
很麻烦

26:58.120 --> 27:00.120
将来一样式要改的话

27:00.120 --> 27:01.120
就要改很多地方

27:01.120 --> 27:02.120
对不对

27:02.120 --> 27:03.120
要改很多地方

27:03.120 --> 27:04.120
因此这里

27:04.120 --> 27:05.120
我们就可以用颗粒化了

27:05.120 --> 27:06.120
讲了半天

27:06.120 --> 27:07.120
就是为了说明

27:07.120 --> 27:08.120
有些函数

27:08.120 --> 27:09.120
它过于通用

27:09.120 --> 27:11.120
它写的过于通用

27:12.120 --> 27:13.120
而我们用的是

27:13.120 --> 27:14.120
在某些场景下面

27:14.120 --> 27:15.120
用的时候

27:15.120 --> 27:17.120
我们可以利用颗粒化

27:17.120 --> 27:18.120
固定一些

27:19.120 --> 27:20.120
不会变化的参数

27:20.120 --> 27:22.120
那么只保留了一些变化的参数

27:22.120 --> 27:23.120
好

27:23.120 --> 27:24.120
我们来看一下怎么来用

27:24.120 --> 27:26.120
这里我们这样子写

27:26.120 --> 27:27.120
这里不是得到DIV了吗

27:27.120 --> 27:28.120
对吧

27:28.120 --> 27:29.120
我们先用颗粒化

27:33.120 --> 27:34.120
什么函数

27:37.120 --> 27:38.120
固定哪些参数

27:38.120 --> 27:39.120
第一个参数DIV

27:39.120 --> 27:40.120
给它固定下来

27:40.120 --> 27:41.120
第一个参数Name

27:41.120 --> 27:42.120
给它固定下来

27:42.120 --> 27:43.120
第三个参数Props

27:43.120 --> 27:44.120
空的

27:44.120 --> 27:45.120
第四个参数央式

27:45.120 --> 27:47.120
固定下来

27:49.120 --> 27:50.120
于是我们固定了几个参数

27:50.120 --> 27:51.120
是不是固定了四个参数

27:51.120 --> 27:52.120
对不对

27:52.120 --> 27:53.120
我们这里写个

27:53.120 --> 27:54.120
能够变量接受一下

27:54.120 --> 27:55.120
Create

27:56.120 --> 27:57.120
那么后边你看

27:57.120 --> 27:58.120
参数现在仍然不够

27:58.120 --> 27:59.120
对不对

27:59.120 --> 28:00.120
仍然不够

28:00.120 --> 28:01.120
还差一个

28:01.120 --> 28:02.120
我们后边就可以用Create函数

28:02.120 --> 28:03.120
就随便写吧

28:03.120 --> 28:04.120
这是第一个DIV

28:07.120 --> 28:08.120
你看后边写写

28:08.120 --> 28:09.120
是不是非常方便

28:09.120 --> 28:10.120
对不对

28:10.120 --> 28:11.120
非常方便

28:11.120 --> 28:12.120
我们只需要

28:12.120 --> 28:13.120
因为前面都是一样的

28:13.120 --> 28:14.120
前面参数都是一样的

28:14.120 --> 28:15.120
已经固定下来了

28:15.120 --> 28:16.120
我们后边只需要去改变它

28:16.120 --> 28:17.120
不同的参数就行了

28:17.120 --> 28:18.120
就最后一个参数

28:18.120 --> 28:19.120
你看一下

28:20.120 --> 28:21.120
创建了多个DIV

28:21.120 --> 28:24.120
就可以很轻松的去创建这些东西

28:24.120 --> 28:25.120
那么到时候我要改的话

28:25.120 --> 28:26.120
是不是很轻松就可以改了

28:26.120 --> 28:28.120
比方说把文字颜色改成白色

28:29.120 --> 28:31.120
然后背景颜色改成

28:31.120 --> 28:32.120
008C8C

28:33.120 --> 28:34.120
保存

28:34.120 --> 28:35.120
你看一下

28:35.120 --> 28:36.120
全部一起改了

28:36.120 --> 28:37.120
对不对

28:37.120 --> 28:38.120
这就是颗粒化的好处

28:39.120 --> 28:40.120
其实颗粒化在函数式

28:40.120 --> 28:41.120
编程里边

28:41.120 --> 28:42.120
它最重要的作用就是

28:42.120 --> 28:44.120
把一个多参函数

28:44.120 --> 28:46.120
变成单参函数

28:46.120 --> 28:48.120
因为在函数式编程里边

28:48.120 --> 28:49.120
单参函数

28:49.120 --> 28:50.120
它是非常非常重要的

28:50.120 --> 28:52.120
它能实现很多很多丰富的效果

28:53.120 --> 28:54.120
所以说它的主要作用

28:54.120 --> 28:56.120
我们这里顺便说一句

28:56.120 --> 28:57.120
顺便说一句

28:58.120 --> 29:00.120
其实我们讲的也不是函数式编程

29:00.120 --> 29:02.120
在函数式编程中

29:02.120 --> 29:04.120
因为现在无论是前端也好

29:04.120 --> 29:05.120
还是后端的开发

29:05.120 --> 29:06.120
后端就更加不要说了

29:07.120 --> 29:08.120
就是前端环境

29:08.120 --> 29:09.120
应该是最

29:10.120 --> 29:11.120
用的技术是最新的

29:11.120 --> 29:14.120
往往会借出最新的一些编程思想

29:14.120 --> 29:15.120
函数式编程

29:15.120 --> 29:17.120
虽然是一个很古恼的思想

29:17.120 --> 29:18.120
但是最近几年是

29:18.120 --> 29:20.120
才活起来的

29:20.120 --> 29:23.120
在介石里边的函数式编程

29:23.120 --> 29:25.120
可能在有些场景下面会应用

29:25.120 --> 29:27.120
但是目前在实际的开发中

29:27.120 --> 29:28.120
在公司里边实际开发中

29:28.120 --> 29:30.120
函数式编程用的很少很少

29:30.120 --> 29:34.120
因为它对开发者的数字要求非常非常高

29:34.120 --> 29:35.120
所以说你在

29:35.120 --> 29:36.120
哪怕有一个很强的人

29:36.120 --> 29:38.120
他能够熟练应用函数式编程

29:38.120 --> 29:39.120
但其他人不行

29:39.120 --> 29:41.120
你起来当然别人看不懂

29:41.120 --> 29:42.120
用不会用

29:42.120 --> 29:43.120
那也是白搭

29:43.120 --> 29:44.120
对不对

29:44.120 --> 29:46.120
函数式里面其实这个东西用的很少

29:46.120 --> 29:47.120
聊一下就行了

29:47.120 --> 29:48.120
保不齐

29:48.120 --> 29:49.120
但是有的时候

29:49.120 --> 29:50.120
可能你面试体的

29:50.120 --> 29:51.120
做就是面试的时候

29:51.120 --> 29:53.120
你跟面试官这样子聊天的时候

29:53.120 --> 29:55.120
你刚说到函数式编程一些概念

29:55.120 --> 29:57.120
一些理念

29:57.120 --> 29:59.120
这个东西肯定是会会的

29:59.120 --> 30:00.120
加分的

30:00.120 --> 30:03.120
在函数式编程中

30:03.120 --> 30:08.120
可理化最重要的作用

30:08.120 --> 30:11.120
是把多参函数

30:11.120 --> 30:13.120
多参

30:13.120 --> 30:14.120
函数

30:14.120 --> 30:15.120
变为

30:15.120 --> 30:19.460
单参函数

30:19.460 --> 30:20.460
你看这里

30:20.460 --> 30:21.460
这里是不是它的作用

30:21.460 --> 30:22.460
对吧

30:22.460 --> 30:23.460
它有这个函数有多个参数

30:23.460 --> 30:25.460
因为这个函数要足够通用

30:25.460 --> 30:27.460
所以说它写了多个参数

30:27.460 --> 30:28.460
你可以说

30:28.460 --> 30:29.460
你干嘛就不写这个函数的时候

30:29.460 --> 30:31.460
直接写一个参数不完了

30:31.460 --> 30:32.460
那是你看这个场景

30:32.460 --> 30:34.460
那将来别的场景里面

30:34.460 --> 30:35.460
它可能不是DNA

30:35.460 --> 30:37.460
它可能是有别的属性了

30:37.460 --> 30:38.460
那又怎么办

30:38.460 --> 30:39.460
你又再重新写

30:39.460 --> 30:40.460
所以说我们这里

30:40.460 --> 30:41.460
肯定要写一个通用的函数

30:41.460 --> 30:42.460
然后利用可理化

30:42.460 --> 30:44.460
把它变成单参函数

30:45.460 --> 30:47.460
只需要一个参数了

30:47.460 --> 30:49.460
它是起这么一个作用

30:49.460 --> 30:51.460
那既然你看了这个扩展课程

30:51.460 --> 30:52.460
那下来还是把它写一遍

30:52.460 --> 30:54.460
把可理化这个函数写一遍

