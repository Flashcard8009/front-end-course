WEBVTT

00:00.000 --> 00:14.700
这一章讲事件循环

00:14.700 --> 00:24.700
这几章这几页课讲的其实不是说我们应用层面该怎么去携带

00:24.700 --> 00:28.700
讲的是一些核心原理性的知识

00:28.700 --> 00:31.700
这些知识往往会出现在面试题里面

00:31.700 --> 00:34.700
就是面试题如果稍微考深一点的话

00:34.700 --> 00:37.700
它一般一般就会考到原型和原型链

00:37.700 --> 00:40.700
或者是执行上下文和作用语练

00:40.700 --> 00:42.700
或者就是事件循环

00:42.700 --> 00:46.700
事件循环这一块咱们还没有学新漏的解释

00:46.700 --> 00:48.700
就漏的解释我们以前说过

00:48.700 --> 00:53.700
就是解释这个语言它能够在不同的环境里面去执行

00:53.700 --> 00:56.700
漏的解释是一个服务器环境还没有学这一块

00:56.700 --> 01:01.700
事件循环的考题的话往往会在漏的解释那块考

01:01.700 --> 01:04.700
但是它的核心原理是没有变化的

01:04.700 --> 01:06.700
核心原理没有变化

01:06.700 --> 01:09.700
但是在漏的解释那一块会有一些区别

01:09.700 --> 01:12.700
因此我们这节课讲的是它的核心原理

01:12.700 --> 01:15.700
就是无论是什么样的执行环境

01:15.700 --> 01:17.700
浏览器也好 手机端也好

01:17.700 --> 01:20.700
以秀的服务器或者是桌面应用程序也好

01:20.700 --> 01:22.700
它们的核心原理都是一样的

01:22.700 --> 01:27.700
只不过在不同的环境下面可能会有一些细微的差异

01:27.700 --> 01:29.700
所以我们这节课讲的比较简单

01:29.700 --> 01:30.700
讲它的核心原理

01:30.700 --> 01:32.700
那么你们以后学到其他环境的时候

01:32.700 --> 01:36.700
还会给你们补充事件循环在不同的环境下边

01:36.700 --> 01:38.700
它是怎么运作的

01:38.700 --> 01:40.700
事件循环一学习完

01:40.700 --> 01:44.700
那么介石的最底层最核心的原理就已经学习完了

01:44.700 --> 01:48.700
你看我们现在知道了介石的原型和原型链

01:48.700 --> 01:51.700
我们知道了对象之间是怎么来共用共享东西的

01:51.700 --> 01:54.700
也知道了什么执行上下吻合作用预链

01:54.700 --> 01:57.700
我们知道了就是函数执行的过程是什么样子的

01:58.700 --> 02:00.700
然后我们再来学习事件循环

02:00.700 --> 02:07.700
学了事件循环之后你就能理解介石里边异步到底是怎么回事

02:07.700 --> 02:11.700
我们说介石是一个同步的语言

02:11.700 --> 02:15.700
它里边但是有一个非常明显的特点就是异步

02:15.700 --> 02:17.700
叫做异步

02:17.700 --> 02:19.700
这个单词异步是什么意思呢

02:19.700 --> 02:23.700
表示的是有一些函数

02:23.700 --> 02:24.700
什么叫异步

02:24.700 --> 02:30.700
就是某些函数不会立即执行

02:30.700 --> 02:37.700
需要等到某个时机成熟后才会执行

02:37.700 --> 02:42.700
那么这个函数呢该函数叫做异步函数

02:42.700 --> 02:47.700
异步是介石里边一个非常非常重要的一个特点

02:47.700 --> 02:53.700
我当时我记得在地结合的时候就讲该数的时候就好像说过

02:54.700 --> 02:56.700
就是漏的介石

02:56.700 --> 03:01.700
当初他为什么要选择介石作为他的开发语言

03:01.700 --> 03:05.700
就是很大的原因就是因为他支持异步

03:05.700 --> 03:08.700
其实像加法他都不支持异步的

03:08.700 --> 03:15.700
而异步是一个能够很大程度上提高系统吞吐量

03:15.700 --> 03:18.700
可能大家不太知道随着系统吞吐量什么意思

03:18.700 --> 03:22.700
就是能够很好的解决服务系的一些问题的一种方式

03:22.700 --> 03:27.700
所以说他漏在介石最终选择了介石作为服务系的开发语言

03:27.700 --> 03:30.700
那么我们这些课就来学习异步

03:30.700 --> 03:35.700
他是怎么回事在介石里面是怎么来运作的就来学习这么个东西

03:35.700 --> 03:39.700
好这里我先给大家看一个例子

03:39.700 --> 03:41.700
TES1

03:41.700 --> 03:47.700
这个例子里边我们写这么一个

03:48.700 --> 03:53.700
写这样子写个set time out

03:53.700 --> 03:55.700
然后我们这里写个函数

03:55.700 --> 03:57.700
你看这个函数是不是一个异步函数

03:57.700 --> 03:59.700
对吧你凡是看到一个函数

03:59.700 --> 04:04.700
它是要等到某个时期成熟之后才会运行的话

04:04.700 --> 04:06.700
那么这就是一个异步函数

04:06.700 --> 04:08.700
比方说我这里写一秒钟

04:08.700 --> 04:11.700
一秒钟之后运行这个函数

04:11.700 --> 04:13.700
这里输出2

04:14.700 --> 04:19.700
然后下边的输出3

04:19.700 --> 04:22.700
大家看一下这个代码会输出什么样的结果

04:22.700 --> 04:24.700
什么样的结果呢

04:24.700 --> 04:26.700
输出的是1

04:26.700 --> 04:27.700
3

04:27.700 --> 04:28.700
2

04:28.700 --> 04:29.700
对不对

04:29.700 --> 04:31.700
你看这个代码是同步代码

04:31.700 --> 04:32.700
它是同步代码

04:32.700 --> 04:33.700
什么叫同步代码

04:33.700 --> 04:34.700
就是上一句没有执行完

04:34.700 --> 04:36.700
下一句的等着

04:36.700 --> 04:37.700
就同步代码

04:37.700 --> 04:39.700
输出1一开始

04:39.700 --> 04:40.700
然后这里呢

04:40.700 --> 04:42.700
有了一个函调用函数调用

04:42.700 --> 04:43.700
叫做set timeout

04:43.700 --> 04:46.700
这个函数调用里边传了一个函数进去

04:46.700 --> 04:47.700
这个函数就是异步函数

04:47.700 --> 04:50.700
它要等到一秒钟之后才会执行

04:50.700 --> 04:51.700
于是呢

04:51.700 --> 04:53.700
这个函数实际上瞬间就执行完了

04:53.700 --> 04:55.700
瞬间就执行完了

04:55.700 --> 04:56.700
执行完了过了

04:56.700 --> 04:57.700
等完

04:57.700 --> 04:58.700
然后我们现在继续执行

04:58.700 --> 04:59.700
执行3

04:59.700 --> 05:00.700
输出3

05:00.700 --> 05:01.700
然后呢我们再来

05:01.700 --> 05:02.700
等到一秒钟之后

05:02.700 --> 05:03.700
再来输出2

05:03.700 --> 05:04.700
对吧这个应该没有什么疑问

05:04.700 --> 05:06.700
这就是一个异步函数

05:06.700 --> 05:07.700
异步函数呢

05:07.700 --> 05:10.700
无论是这里等待一段时间之后

05:10.700 --> 05:11.700
执行异步函数

05:11.700 --> 05:12.700
还是说

05:14.700 --> 05:16.700
注册事件的函数

05:16.700 --> 05:18.700
函数的就是事件处理程序

05:18.700 --> 05:21.700
它要等到某个事情发生之后

05:21.700 --> 05:22.700
才会运行的函数

05:22.700 --> 05:24.700
这些都是异步函数

05:24.700 --> 05:25.700
它不会立即执行

05:26.700 --> 05:27.700
好然后呢

05:27.700 --> 05:28.700
我们现在看一下

05:28.700 --> 05:29.700
那肯定是输出1

05:29.700 --> 05:30.700
132

05:30.700 --> 05:31.700
这个没什么好说的

05:31.700 --> 05:34.780
看一下吧

05:34.780 --> 05:35.780
好这里呢

05:35.780 --> 05:36.780
我们看一下

05:36.780 --> 05:37.780
132

05:37.780 --> 05:38.780
没问题

05:38.780 --> 05:39.780
对

05:39.780 --> 05:40.780
132

05:40.780 --> 05:41.780
好接下来

05:41.780 --> 05:42.780
来再来改一下

05:42.780 --> 05:45.780
把这里呢改成0

05:45.780 --> 05:46.780
什么意思呢

05:46.780 --> 05:48.780
改成0秒之后

05:48.780 --> 05:49.780
输出2

05:49.780 --> 05:50.780
那是不是瞬间到了

05:50.780 --> 05:51.780
对不对

05:51.780 --> 05:52.780
0毫秒嘛

05:52.780 --> 05:54.780
瞬间就可以到达这个时间

05:54.780 --> 05:55.780
那么我们看一下

05:55.780 --> 05:56.780
这个时候

05:56.780 --> 05:57.780
它输出的结果是啥呢

05:57.780 --> 05:58.780
保存

05:59.780 --> 06:00.780
还是132

06:00.780 --> 06:01.780
这就很奇怪了

06:01.780 --> 06:02.780
然后咱们再来看

06:02.780 --> 06:03.780
再来看

06:03.780 --> 06:05.780
我们这里呢

06:05.780 --> 06:06.780
写一个

06:06.780 --> 06:07.780
复循环

06:08.780 --> 06:09.780
i等于0

06:10.780 --> 06:12.780
i小于

06:12.780 --> 06:13.780
1万

06:13.780 --> 06:14.780
i加加

06:14.780 --> 06:15.780
1万好像太多了

06:15.780 --> 06:17.780
难得等的很

06:17.780 --> 06:18.780
因为我要输出

06:18.780 --> 06:19.780
输出

06:19.780 --> 06:20.780
循环实际上是很快的

06:20.780 --> 06:22.780
但是我这里要输出东西

06:22.780 --> 06:24.780
输出的话比较好时间

06:24.780 --> 06:25.780
所以说呢

06:25.780 --> 06:26.780
这里我们小于1000嘛

06:26.780 --> 06:27.780
循环1000次

06:27.780 --> 06:28.780
这里输出一个

06:28.780 --> 06:29.780
同步代码

06:29.780 --> 06:31.780
这里是同步代码在执行

06:31.780 --> 06:33.780
这里是异步代码

06:33.780 --> 06:34.780
异步代码

06:35.780 --> 06:37.780
就等到某个实际成熟之后执行的代码

06:37.780 --> 06:38.780
好

06:38.780 --> 06:39.780
咱们来看一下

06:39.780 --> 06:40.780
这个异步代码会什么时候执行

06:40.780 --> 06:43.470
保存

06:44.470 --> 06:45.470
这样吧

06:45.470 --> 06:46.470
这样

06:46.470 --> 06:47.470
我这里就输出i嘛

06:47.470 --> 06:48.470
就输出i

06:48.470 --> 06:49.470
保存

06:50.470 --> 06:51.470
好

06:51.470 --> 06:52.470
你会看到

06:52.470 --> 06:53.470
这个异步代码

06:53.470 --> 06:55.470
是要等到循环结束之后

06:55.470 --> 06:56.470
才会执行

06:56.470 --> 06:57.470
那么我们再来

06:57.470 --> 07:00.300
再来夸张一点

07:00.300 --> 07:01.300
5000

07:01.300 --> 07:02.300
你会看到

07:02.300 --> 07:03.300
那么再来

07:03.300 --> 07:04.300
1万

07:04.300 --> 07:05.300
1万

07:05.300 --> 07:08.380
保存

07:08.380 --> 07:09.380
好

07:09.380 --> 07:10.380
这个异步代码

07:10.380 --> 07:11.380
它仍然要等

07:11.380 --> 07:12.380
等到同步代码

07:12.380 --> 07:13.380
全部执行完了过后

07:13.380 --> 07:14.380
异步代码才会执行

07:14.380 --> 07:15.380
那么这个东西

07:15.380 --> 07:17.380
到底是怎么回事

07:17.380 --> 07:18.380
到底是怎么回事

07:18.380 --> 07:19.380
好

07:19.380 --> 07:20.380
这里我慢慢来解释

07:21.380 --> 07:22.380
首先大家要知道

07:22.380 --> 07:24.380
在我们的浏览器环境也好

07:24.380 --> 07:25.380
还是或者说

07:25.380 --> 07:26.380
我们以前

07:26.380 --> 07:28.380
以后结束的服务器环境也好

07:28.380 --> 07:29.380
实际上

07:29.380 --> 07:31.380
它是不止一个县城的

07:31.380 --> 07:33.380
县城是什么呢

07:33.380 --> 07:35.380
县城

07:35.380 --> 07:37.380
县城指的就是

07:37.380 --> 07:38.380
你可以把县城

07:38.380 --> 07:39.380
想象成一个人

07:39.380 --> 07:41.380
咱们的介石程序里边

07:41.380 --> 07:43.380
我们目前开发的介石程序

07:43.380 --> 07:45.380
你可以想象只有一个人

07:45.380 --> 07:47.380
他忙前忙后都是他

07:47.380 --> 07:48.380
他忙着执行函数

07:48.380 --> 07:49.380
忙着输出

07:49.380 --> 07:50.380
忙着计算运算

07:50.380 --> 07:52.380
全是他一个人搞定

07:52.380 --> 07:53.380
但是实际上

07:53.380 --> 07:55.380
我们的宿主环境中

07:55.380 --> 07:57.380
它是有多个县城的

07:57.380 --> 07:59.380
那么比方说浏览器

07:59.380 --> 08:00.380
浏览器里边

08:00.380 --> 08:02.380
它是有多县城的

08:02.380 --> 08:04.380
它有哪些县城呢

08:04.380 --> 08:05.380
我们一个个说

08:05.380 --> 08:08.380
第一个县城是介石执行引擎

08:08.380 --> 08:10.380
介石执行引擎

08:10.380 --> 08:11.380
这是我们目前为止

08:11.380 --> 08:13.380
接触到的一个县城

08:13.380 --> 08:14.380
就是说

08:14.380 --> 08:15.380
我们的介石代码

08:15.380 --> 08:17.380
是交给谁来执行的

08:17.380 --> 08:18.380
这是一个县城

08:18.380 --> 08:19.380
一个县城就是一个人

08:19.380 --> 08:22.380
他负责做某一些事

08:22.380 --> 08:23.380
那么介石执行引擎

08:23.380 --> 08:24.380
他做什么呢

08:24.380 --> 08:28.380
他专门来负责执行介石代码

08:28.380 --> 08:29.380
所有的介石代码

08:29.380 --> 08:31.380
全是靠他来完成的

08:32.380 --> 08:34.380
还有另外一些人

08:34.380 --> 08:36.380
那些人他是同步子

08:36.380 --> 08:38.380
他是就是一起的干活

08:38.380 --> 08:39.380
他不是说

08:39.380 --> 08:41.380
我要等到介石引擎执行完了

08:41.380 --> 08:42.380
我才干活

08:42.380 --> 08:43.380
不是的

08:43.380 --> 08:44.380
介石引擎在工作的时候

08:44.380 --> 08:45.380
其他的人也在工作

08:45.380 --> 08:47.380
就是县城

08:47.380 --> 08:49.380
我们说介石是一个单线城的

08:49.380 --> 08:51.380
单线城的程序

08:51.380 --> 08:52.380
这个说法没有问题的

08:52.380 --> 08:54.380
虽然说我这里说了很多个县城

08:54.380 --> 08:55.380
一会要说很多个县城

08:55.380 --> 08:57.380
但是我说的是什么

08:57.380 --> 08:58.380
说的是浏览器的县城

08:58.380 --> 09:00.380
并没有说介石的县城

09:00.380 --> 09:01.380
介石县城只有一个

09:01.380 --> 09:03.380
它就一个引擎

09:03.380 --> 09:05.380
所有代码全是靠他一个人执行的

09:06.380 --> 09:08.380
所以说这里必须要考虑到一种情况

09:08.380 --> 09:09.380
就比较说

09:09.380 --> 09:10.380
时间到了过后

09:10.380 --> 09:12.380
那我到底是执行这个异不代码

09:12.380 --> 09:14.380
还是继续执行循环的

09:14.380 --> 09:16.380
比方说循环到十次的时候

09:16.380 --> 09:17.380
时间已经到了

09:17.380 --> 09:18.380
那我到底是执行异不代码

09:18.380 --> 09:20.380
还是执行这个循环的

09:20.380 --> 09:22.380
就是这个人必须要做出抉择

09:22.380 --> 09:23.380
因为他只有一个人

09:23.380 --> 09:25.380
如果他有两个人的话就简单了

09:25.380 --> 09:26.380
你去执行这个异不代码

09:26.380 --> 09:27.380
我去执行这个循环

09:27.380 --> 09:28.380
那就简单了

09:28.380 --> 09:30.380
但是介石他只有一个人

09:30.380 --> 09:32.380
因为他是单线城

09:32.380 --> 09:34.380
所以说他就必须要做出抉择

09:34.380 --> 09:35.380
明白我的意思吧

09:35.380 --> 09:37.380
所以说我们说的介石单线城

09:37.380 --> 09:40.380
指的是介石引擎他是一个线城

09:40.380 --> 09:41.380
他没有别的线城了

09:41.380 --> 09:44.380
所以说他只能一次只能干一件事

09:44.380 --> 09:46.380
但是浏览器环境

09:46.380 --> 09:47.380
输主环境不一样

09:47.380 --> 09:49.380
输主环境里边他还有别的线城

09:49.380 --> 09:50.380
在一起工作

09:50.380 --> 09:52.380
还有什么线城呢

09:52.380 --> 09:53.380
还有宣展线城

09:55.380 --> 09:56.380
宣展线城

09:56.380 --> 09:57.380
这个线城负责什么呢

09:57.380 --> 09:59.380
负责宣展页面

10:00.380 --> 10:03.380
比方说重新组织ATM结构

10:03.380 --> 10:05.380
重新组织样式

10:05.380 --> 10:07.380
比方说颜色变化了

10:07.380 --> 10:09.380
那我重新要把这个页面宣展一次

10:09.380 --> 10:11.380
一个元素的宽高尺寸变化了

10:11.380 --> 10:13.380
那么我们要把它进行重排

10:13.380 --> 10:14.380
对吧

10:14.380 --> 10:16.380
他专门来负责宣展页面

10:17.380 --> 10:18.380
明白我的意思吧

10:18.380 --> 10:19.380
现在就两个线城了

10:19.380 --> 10:21.380
他不会影响介石执行引擎的

10:21.380 --> 10:22.380
不会影响的

10:23.380 --> 10:25.380
下一个

10:26.380 --> 10:28.380
下一个是技时器线城

10:29.380 --> 10:31.380
技时器线城

10:31.380 --> 10:33.380
他专门负责技时

10:33.380 --> 10:34.380
专门负责技时

10:34.380 --> 10:35.380
比方说

10:35.380 --> 10:37.380
我们这里开了一个技时器

10:37.380 --> 10:39.380
实际上是用介石线城

10:39.380 --> 10:41.380
用介石引擎这个线城

10:41.380 --> 10:43.380
通知技时器线城

10:43.380 --> 10:44.380
我现在要技时了

10:44.380 --> 10:45.380
你去技时我不管了

10:45.380 --> 10:46.380
我不管了

10:46.380 --> 10:47.380
我马上就往后运行了

10:47.380 --> 10:49.380
我不管了你去帮我技时

10:49.380 --> 10:51.380
技时完了过后给我说一声就行了

10:51.380 --> 10:52.380
是这么回事

10:52.380 --> 10:54.380
他专门来负责技时

10:54.380 --> 10:55.380
也就是我们技时器

10:55.380 --> 10:57.380
调用这个函数的时候

10:57.380 --> 10:58.380
实际上在内部

10:58.380 --> 11:00.380
在函数的内部

11:00.380 --> 11:02.380
它是通知了其他线城

11:02.380 --> 11:03.380
可能有些同学说

11:03.380 --> 11:04.380
那我怎么写代码

11:04.380 --> 11:07.380
才能通知其他线城的工作呢

11:07.380 --> 11:09.380
我们写不了任何代码

11:09.380 --> 11:10.380
我们只能间接的通知

11:10.380 --> 11:11.380
比方调用这些timeout

11:11.380 --> 11:13.380
我们自己写不了任何代码

11:13.380 --> 11:14.380
比方说

11:14.380 --> 11:16.380
我们给他的InnerItem负责

11:16.380 --> 11:18.380
那么他就是通知渲染线城

11:18.380 --> 11:20.380
你负的来重新渲染一遍

11:20.380 --> 11:22.380
我们只能间接的通知

11:22.380 --> 11:24.380
没法直接用代码来通知线城

11:24.380 --> 11:26.380
这是他内部

11:26.380 --> 11:29.380
就是游烂清底层写好的

11:29.380 --> 11:32.380
不允许直接操作的

11:32.380 --> 11:33.380
还有线城吗

11:33.380 --> 11:34.380
还有

11:34.380 --> 11:35.380
还有什么线城呢

11:35.380 --> 11:38.380
还有就是事件监听线城

11:38.380 --> 11:40.380
监听线城

11:40.380 --> 11:41.380
他负责什么呢

11:41.380 --> 11:45.380
负责监听事件

11:45.380 --> 11:46.380
什么意思呢

11:46.380 --> 11:47.380
就好比说

11:47.380 --> 11:48.380
这里有个人

11:48.380 --> 11:49.380
一直在盯着一个按钮看

11:49.380 --> 11:51.380
然后盯着一边上一个按钮

11:51.380 --> 11:53.380
有没有点我

11:53.380 --> 11:54.380
你点了一下

11:54.380 --> 11:55.380
他马上就知道

11:55.380 --> 11:57.380
那么如果有什么事件处理程序的话

11:57.380 --> 11:59.380
我马上要去通知介事引擎

11:59.380 --> 12:02.380
去执行一下这个处理程序

12:02.380 --> 12:04.380
是这么回事

12:04.380 --> 12:05.380
还有一个线城

12:05.380 --> 12:07.380
我们目前没有接触

12:07.380 --> 12:08.380
但是可以解释一下

12:08.380 --> 12:10.380
叫做ADDP

12:10.380 --> 12:13.380
网络线城

12:13.380 --> 12:15.380
这个线城是什么呢

12:15.380 --> 12:17.380
负责网络通信

12:17.380 --> 12:19.380
负责网络通信

12:19.380 --> 12:21.380
比方说我们请求一个地址

12:21.380 --> 12:22.380
请求百度

12:22.380 --> 12:24.380
他要下载这个百度的页面

12:24.380 --> 12:26.380
页面中相关的图片

12:26.380 --> 12:27.380
还要下载页面中相关的

12:27.380 --> 12:30.380
CSS介事数据文件

12:30.380 --> 12:32.380
这些都由这个线城来负责

12:32.380 --> 12:34.380
你要这意思吧

12:34.380 --> 12:35.380
我这里就解释了

12:35.380 --> 12:37.380
浏览器环境里边

12:37.380 --> 12:38.380
它实际上有五个线城

12:38.380 --> 12:40.380
我们平时用的

12:40.380 --> 12:42.380
看到的线城的是这个

12:42.380 --> 12:44.380
我们始终在这里边去操作

12:44.380 --> 12:45.380
因为我们写的介事代码

12:45.380 --> 12:47.380
全是通过它来执行的

12:47.380 --> 12:48.380
但是其他的线城

12:48.380 --> 12:49.380
在负责一些事情

12:49.380 --> 12:51.380
这就解释了一个什么东西呢

12:51.380 --> 12:52.380
这个计时

12:52.380 --> 12:54.380
它不是用CS来计时的

12:54.380 --> 12:56.380
CS完全没法计时

12:56.380 --> 12:58.380
我们讲CS语言

12:58.380 --> 12:59.380
讲了这么久

12:59.380 --> 13:01.380
从来没讲过怎么去计时

13:01.380 --> 13:03.380
它没法计时

13:03.380 --> 13:05.380
它只能靠另外一个线城来计时

13:05.380 --> 13:09.380
因此别的线城在计时的时候

13:09.380 --> 13:11.380
不会影响CS代码

13:11.380 --> 13:12.380
自己的运行

13:12.380 --> 13:13.380
因为它在计时

13:13.380 --> 13:14.380
关我啥事了

13:14.380 --> 13:15.380
我这里调问过

13:15.380 --> 13:16.380
还说马上就结束了

13:16.380 --> 13:18.380
然后我就接着往后运行

13:18.380 --> 13:20.380
首先理解这么一个东西

13:20.380 --> 13:22.380
也这么一个东西

13:22.380 --> 13:24.380
如果我们来画一张图的话

13:24.380 --> 13:26.380
那么就应该是这样的画法

13:26.380 --> 13:28.380
接下来我画图了

13:28.380 --> 13:32.940
这里我们写一个PVT

13:32.940 --> 13:33.940
看着

13:35.940 --> 13:37.940
我们之前学过了执行站

13:37.940 --> 13:38.940
对吧

13:38.940 --> 13:40.940
这里还要把执行站画出来

13:40.940 --> 13:42.940
还要把执行站画出来

13:42.940 --> 13:45.940
接下来我们一边用图来讲

13:45.940 --> 13:49.940
一边来理解这个线城是怎么来互相配合来工作的

13:51.940 --> 13:54.940
这里是执行站

13:54.940 --> 13:56.940
这里是执行站

13:56.940 --> 14:00.640
执行站

14:04.530 --> 14:05.530
这里加出

14:05.530 --> 14:07.530
这是个执行站

14:07.530 --> 14:08.530
首先让我们看到

14:08.530 --> 14:10.530
这里是个全局环境

14:10.530 --> 14:11.530
全局环境

14:11.530 --> 14:12.530
于是要做什么

14:12.530 --> 14:14.530
讲过很多次了

14:14.530 --> 14:15.530
全局上下文

14:15.530 --> 14:17.530
这里是个全局上下文

14:17.530 --> 14:22.630
全局上下文

14:22.630 --> 14:24.630
那么你比如说VORZ

14:24.630 --> 14:25.630
我就不画了

14:25.630 --> 14:27.630
这些不是我们现在的重点了

14:27.630 --> 14:29.630
于是进入全局上下文来执行

14:29.630 --> 14:31.630
因为站的顶部是全局上下文

14:31.630 --> 14:33.630
进入全局上下文来执行

14:33.630 --> 14:35.630
执行的时候

14:35.630 --> 14:37.630
第一次是不是遇到一个函数

14:37.630 --> 14:40.630
函数调用叫做setTimeout函数

14:40.630 --> 14:42.630
叫做setTimeout函数

14:42.630 --> 14:43.630
即时的函数

14:43.630 --> 14:45.630
于是去执行这个函数

14:45.630 --> 14:47.630
叫做setTimeout

14:47.630 --> 14:49.630
看一下它怎么执行的

14:50.630 --> 14:52.630
执行这么个函数

14:54.630 --> 14:55.630
执行这么个函数

14:55.630 --> 14:57.630
这个函数的作用是什么呢

14:57.630 --> 14:59.630
这个作用是

14:59.630 --> 15:01.630
高速计时器现成

15:01.630 --> 15:04.630
这个函数的作用是高速计时器现成

15:04.630 --> 15:07.630
等待多少秒之后

15:07.630 --> 15:09.630
执行另外一个函数

15:09.630 --> 15:11.630
它是通知计时器现成

15:11.630 --> 15:13.630
它自己不做任何计时

15:13.630 --> 15:14.630
既是引擎是做

15:14.630 --> 15:15.630
做不了什么计时的

15:15.630 --> 15:17.630
它只能通知计时器现成

15:17.630 --> 15:19.630
好 计时器现成

15:19.630 --> 15:21.630
相当于是另外一个东西了

15:21.630 --> 15:23.630
相当于是另外一个东西了

15:23.630 --> 15:25.630
我们把这一块区叫做

15:25.630 --> 15:27.630
叫做web API

15:27.630 --> 15:29.630
web API什么意思

15:29.630 --> 15:31.630
就是浏览器宿主环境

15:31.630 --> 15:32.630
我们就用这种写法

15:32.630 --> 15:33.630
就有的教程里面

15:33.630 --> 15:34.630
这里写的是web API

15:34.630 --> 15:37.630
表示浏览器宿主环境里面的功能

15:37.630 --> 15:39.630
我们这里就写宿主环境

15:40.630 --> 15:42.630
因为只有宿主环境中

15:42.630 --> 15:43.630
才有多个现成

15:43.630 --> 15:45.630
宿主环境里面

15:45.630 --> 15:47.630
它能够做很多的事情

15:47.630 --> 15:49.630
包括什么宣展

15:49.630 --> 15:51.630
包括什么

15:51.630 --> 15:52.630
就是计时器

15:52.630 --> 15:54.630
包括什么网络请求

15:54.630 --> 15:55.630
包括时间减停

15:55.630 --> 15:57.630
都是它要做

15:57.630 --> 15:59.630
然后这里干嘛呢

15:59.630 --> 16:00.630
在通知

16:00.630 --> 16:01.630
这个函数它的作用是

16:01.630 --> 16:03.630
通知计时器现成

16:03.630 --> 16:04.630
你干嘛

16:04.630 --> 16:06.630
你要去计时

16:06.630 --> 16:07.630
计时多少

16:07.630 --> 16:09.630
计时领庙

16:09.630 --> 16:11.630
计时领庙之后

16:11.630 --> 16:12.630
你要去运行一个函数

16:12.630 --> 16:13.630
这个函数比方说

16:13.630 --> 16:14.630
要取个名字

16:14.630 --> 16:16.630
取个名字 便于我画图

16:16.630 --> 16:17.630
取个名字

16:17.630 --> 16:18.630
你去运行函数

16:18.630 --> 16:20.630
运行这个A函数

16:20.630 --> 16:21.630
计时领庙之后

16:21.630 --> 16:23.630
运行函数A

16:24.630 --> 16:26.630
通知的宿主环境

16:26.630 --> 16:27.630
它只发出一个通知

16:27.630 --> 16:28.630
它不做任何其他事情

16:28.630 --> 16:30.630
通知完了过后

16:30.630 --> 16:32.630
这个函数调用是不是结束了

16:32.630 --> 16:33.630
调用结束了

16:33.630 --> 16:34.630
然后接着运行

16:34.630 --> 16:35.630
是这么回事

16:35.630 --> 16:37.630
比方说这里不是领庙

16:37.630 --> 16:38.630
领庙可能目前还会

16:38.630 --> 16:39.630
造成一些困扰

16:39.630 --> 16:40.630
那么这里是

16:40.630 --> 16:42.630
比方说100秒

16:42.630 --> 16:43.630
100毫秒

16:43.630 --> 16:44.630
那么这里就是

16:44.630 --> 16:46.630
计时100毫秒

16:46.630 --> 16:48.630
通知计时器现成

16:48.630 --> 16:49.630
计时100毫秒

16:49.630 --> 16:50.630
然后干嘛呢

16:50.630 --> 16:51.630
然后它这里是不是

16:51.630 --> 16:52.630
函数就运行结束了

16:52.630 --> 16:53.630
我已经通知了

16:53.630 --> 16:54.630
我跟另外一个人

16:54.630 --> 16:56.630
现在有多个人了

16:56.630 --> 16:57.630
宿主环境里边有别的现场

16:57.630 --> 16:58.630
有多个人了

16:58.630 --> 17:00.630
就不是介事一个人在忙了

17:00.630 --> 17:01.630
介事

17:01.630 --> 17:02.630
我已经通知他了

17:02.630 --> 17:03.630
那么剩下的事情

17:03.630 --> 17:04.630
他去搞定

17:04.630 --> 17:05.630
我不管了

17:05.630 --> 17:06.630
所以说这个函数

17:06.630 --> 17:07.630
马上就结束了

17:07.630 --> 17:08.630
原来这个意思

17:08.630 --> 17:09.630
它只发出一个通知

17:09.630 --> 17:10.630
后一生

17:10.630 --> 17:12.630
100毫秒之后

17:12.630 --> 17:14.630
你去运行这个函数A

17:14.630 --> 17:16.630
它只发出这么一个通知

17:16.630 --> 17:17.630
后一生就完事了

17:17.630 --> 17:18.630
我就接着做我的事

17:18.630 --> 17:20.630
然后跟我没什么关系了

17:20.630 --> 17:22.630
是这么个意思

17:22.630 --> 17:23.630
你要理解这个

17:23.630 --> 17:25.630
它的执行过程是这样子的

17:25.630 --> 17:26.630
好

17:26.630 --> 17:27.630
然后呢

17:27.630 --> 17:28.630
我们理解的这些东西过后了

17:28.630 --> 17:29.630
再来理解一个概念

17:29.630 --> 17:31.630
叫做事件对立

17:31.630 --> 17:32.630
马上

17:32.630 --> 17:34.630
现在我还没有讲到事件循环

17:34.630 --> 17:35.630
不着急

17:35.630 --> 17:36.630
事件对立

17:36.630 --> 17:38.630
事件对立是什么意思呢

17:38.630 --> 17:40.630
就是一块

17:40.630 --> 17:42.630
一块内存空间

17:42.630 --> 17:44.630
内存空间

17:44.630 --> 17:47.630
用于存放异部函数

17:47.630 --> 17:49.630
这个异部函数指的是

17:49.630 --> 17:52.630
执行时机

17:52.630 --> 17:54.630
到达的异部函数

17:54.630 --> 17:56.630
堆垫有个特点

17:56.630 --> 17:58.630
堆垫它有这么一个特点

17:58.630 --> 18:00.630
我再画个堆垫吧

18:04.070 --> 18:05.070
堆垫它有这么个特点

18:05.070 --> 18:07.070
它加数据是这样加的

18:07.070 --> 18:09.070
我们这里复制一下

18:09.070 --> 18:11.070
这是Costec

18:11.070 --> 18:13.070
这是数组环境

18:13.070 --> 18:15.070
下面这个是事件对立

18:16.070 --> 18:18.070
事件对立

18:19.070 --> 18:21.070
也叫什么

18:21.070 --> 18:23.070
Event Queen

18:23.070 --> 18:25.070
Event Queen

18:25.070 --> 18:26.070
Queens也对没有

18:26.070 --> 18:27.070
对立

18:27.070 --> 18:28.070
我看一下

18:28.070 --> 18:30.070
胆子真的是不放弃

18:30.070 --> 18:32.070
Queen

18:32.070 --> 18:34.070
怎么是皇后啊

18:34.070 --> 18:36.070
应该是个对立

18:36.070 --> 18:38.070
对立我看一下

18:38.070 --> 18:40.070
胆子一垫

18:40.070 --> 18:41.070
对立很像

18:41.070 --> 18:42.070
是这个胆子

18:42.070 --> 18:44.070
事件对立

18:44.070 --> 18:46.070
数组环境的英文叫做

18:46.070 --> 18:47.070
Web API

18:47.070 --> 18:48.070
因为我们这里是浏览器

18:48.070 --> 18:49.070
数组环境

18:49.070 --> 18:51.070
所以说是Web API

18:51.070 --> 18:52.070
好

18:52.070 --> 18:53.070
然后事件对立的

18:53.070 --> 18:55.070
对立的它也是一种数据结构

18:55.070 --> 18:57.070
它的特点是

18:57.070 --> 18:58.070
数据比方说

18:58.070 --> 18:59.070
一个数据

18:59.070 --> 19:00.070
比方说一个数据

19:00.070 --> 19:02.070
数据是先进

19:02.070 --> 19:04.070
先出

19:04.070 --> 19:05.070
后进

19:05.070 --> 19:06.070
后出

19:06.070 --> 19:07.070
它加数据是这样加的

19:07.070 --> 19:08.070
一个数据

19:08.070 --> 19:09.070
两个数据

19:09.070 --> 19:10.070
下当崩尾

19:10.070 --> 19:11.070
三个数据

19:11.070 --> 19:12.070
四个数据

19:12.070 --> 19:13.070
是这样加数据的

19:13.070 --> 19:14.070
初数据是这样出的

19:14.070 --> 19:15.070
排队

19:15.070 --> 19:17.070
就跟我们现实生活中的排队

19:17.070 --> 19:18.070
是一样的

19:18.070 --> 19:19.070
这是

19:19.070 --> 19:20.070
出一个数据

19:20.070 --> 19:21.070
然后再出一个数据

19:21.070 --> 19:22.070
然后这样子

19:22.070 --> 19:23.070
你看是不是排队

19:23.070 --> 19:24.070
对不对

19:24.070 --> 19:26.070
它是这么一种数据结构

19:26.070 --> 19:27.070
好

19:27.070 --> 19:29.070
有这么一个事件对立

19:29.070 --> 19:31.070
对立是有什么用呢

19:31.070 --> 19:32.070
它是一块内存空间

19:32.070 --> 19:33.070
用于存放

19:33.070 --> 19:34.070
执行时机

19:34.070 --> 19:36.070
到达的异部寒宿

19:36.070 --> 19:38.070
就是什么时候

19:38.070 --> 19:39.070
这个寒宿

19:39.070 --> 19:40.070
这些都是异部寒宿

19:40.070 --> 19:41.070
怎么

19:41.070 --> 19:43.070
事件处理寒宿

19:43.070 --> 19:44.070
要等

19:44.070 --> 19:45.070
用户处罚事件

19:45.070 --> 19:46.070
还有什么

19:46.070 --> 19:47.070
计时器

19:47.070 --> 19:48.070
相关的寒宿

19:48.070 --> 19:49.070
是不是都是异部寒宿

19:49.070 --> 19:50.070
你们以后还会学习

19:50.070 --> 19:51.070
阿加克斯

19:51.070 --> 19:52.070
阿加克斯

19:52.070 --> 19:53.070
它也是一个异部寒宿

19:53.070 --> 19:54.070
请求网络等等

19:54.070 --> 19:56.070
异部在GS里面

19:56.070 --> 19:57.070
出现的频率非常非常高

19:57.070 --> 19:58.070
特别是学到后面

19:58.070 --> 20:00.070
出现的频率很高

20:00.070 --> 20:02.070
它是一个异部寒宿

20:02.070 --> 20:03.070
因此还要等

20:03.070 --> 20:04.070
好

20:04.070 --> 20:05.070
现在我们继续执行全局上下文

20:05.070 --> 20:07.070
继续执行全局上下文

20:07.070 --> 20:08.070
好

20:08.070 --> 20:09.070
执行完了

20:09.070 --> 20:11.070
全局上下文之后

20:11.070 --> 20:12.070
比方说这里

20:13.070 --> 20:14.070
比方说一秒钟

20:14.070 --> 20:15.070
我们尽量写多一点

20:15.070 --> 20:16.070
这里一秒钟

20:16.070 --> 20:18.070
一百一千毫秒

20:18.070 --> 20:20.070
那么我来解释一下

20:20.070 --> 20:22.070
这里

20:22.070 --> 20:23.070
通知

20:23.070 --> 20:24.070
计时器现成

20:24.070 --> 20:26.070
你等一千毫秒去执行它

20:26.070 --> 20:27.070
执行这个寒宿

20:27.070 --> 20:28.070
OK 它就去计时器了

20:28.070 --> 20:29.070
我不管了

20:29.070 --> 20:30.070
接下来我开始循环

20:30.070 --> 20:31.070
对吧

20:31.070 --> 20:32.070
循环

20:32.070 --> 20:33.070
那么循环执行的时间

20:33.070 --> 20:34.070
肯定没有一秒钟

20:34.070 --> 20:35.070
很快就执行完了

20:35.070 --> 20:36.070
所以说

20:36.070 --> 20:37.070
全局上下文是不是执行完了

20:37.070 --> 20:38.070
对不对

20:38.070 --> 20:39.070
执行完了

20:39.070 --> 20:40.070
空了

20:40.070 --> 20:41.070
没东西了

20:41.070 --> 20:42.070
等

20:42.070 --> 20:43.070
等一千毫秒

20:43.070 --> 20:44.070
一千毫秒

20:44.070 --> 20:45.070
这一边

20:45.070 --> 20:47.070
它是不是计时结束

20:47.070 --> 20:48.070
对不对

20:48.070 --> 20:49.070
计时结束

20:49.070 --> 20:50.070
计时结束之后

20:50.070 --> 20:52.070
它会把这个寒宿放到哪儿了

20:52.070 --> 20:53.070
它自己执行不了

20:53.070 --> 20:55.070
它是一个计时器现成

20:55.070 --> 20:56.070
我怎么能执行寒宿呢

20:56.070 --> 20:58.070
那是解释引擎干的事

20:58.070 --> 21:00.070
所以它就做这么一件事

21:00.070 --> 21:01.070
它会把这个寒宿

21:01.070 --> 21:02.070
放到

21:02.070 --> 21:04.070
事件对列里边来

21:04.070 --> 21:06.070
它会放到这里边来

21:07.070 --> 21:08.070
放到这

21:08.070 --> 21:09.070
好 放到这有什么用的

21:09.070 --> 21:10.070
它没法执行

21:10.070 --> 21:11.070
执行任何一个东西

21:11.070 --> 21:13.070
都必须要在执行站里边

21:13.070 --> 21:14.070
它为什么叫执行站

21:14.070 --> 21:15.070
它专门来执行东西的

21:15.070 --> 21:17.070
所以说它必须要在这里边执行

21:17.070 --> 21:18.070
但是放到这来

21:18.070 --> 21:19.070
放到这来干嘛

21:19.070 --> 21:20.070
排队等

21:20.070 --> 21:21.070
排队等着

21:21.070 --> 21:23.070
等什么时候呢

21:23.070 --> 21:24.070
等到

21:24.070 --> 21:26.070
这个执行站空了

21:26.070 --> 21:27.070
没东西了

21:27.070 --> 21:28.070
那么解释引擎

21:28.070 --> 21:30.070
会去求一言

21:30.070 --> 21:32.070
事件对列里边有没有东西

21:32.070 --> 21:34.070
如果有东西的话

21:34.070 --> 21:35.070
一个一个拿出来执行

21:35.070 --> 21:36.070
所以说

21:36.070 --> 21:38.070
事件对列的作用是

21:39.070 --> 21:40.070
当

21:42.070 --> 21:45.070
解释引擎空闲时

21:45.070 --> 21:46.070
什么叫空闲

21:46.070 --> 21:47.070
因为解释引擎

21:47.070 --> 21:49.070
它一直执行的是执行站的东西

21:49.070 --> 21:50.070
对吧

21:50.070 --> 21:52.070
就是执行站空了

21:52.070 --> 21:53.070
执行站

21:53.070 --> 21:55.070
没有

21:55.070 --> 21:56.070
可

21:56.070 --> 21:57.070
执行的

21:57.070 --> 21:58.070
上下文

21:58.070 --> 22:00.070
它没有可执行的上下文了

22:00.070 --> 22:01.070
那你执行站了

22:01.070 --> 22:02.070
是不是显着了

22:02.070 --> 22:04.070
那显着我看一下吧

22:04.070 --> 22:06.070
它会

22:06.070 --> 22:09.070
它会从事件对列中

22:09.070 --> 22:10.070
拿出

22:10.070 --> 22:11.070
第一个

22:11.070 --> 22:12.070
第一个

22:13.070 --> 22:14.070
函数

22:14.070 --> 22:15.070
执行

22:16.070 --> 22:17.070
它会从事件对列里边

22:17.070 --> 22:19.070
拿出第一个函数来进行执行

22:19.070 --> 22:20.070
是这么回事

22:20.070 --> 22:21.070
因为它现在空了

22:21.070 --> 22:22.070
对吧

22:22.070 --> 22:23.070
空了一开始事件对列里边

22:23.070 --> 22:24.070
还没东西

22:24.070 --> 22:25.070
那就闲着喝口水

22:25.070 --> 22:26.070
休息一下

22:26.070 --> 22:27.070
一会

22:27.070 --> 22:29.070
这个函数一秒钟到达之后

22:29.070 --> 22:31.070
这个函数就跑到事件对列里边来了

22:31.070 --> 22:32.070
那么解释引擎看

22:32.070 --> 22:33.070
有活干了

22:33.070 --> 22:34.070
有活干了

22:34.070 --> 22:35.070
来东西了

22:35.070 --> 22:36.070
我等了太久了

22:36.070 --> 22:37.070
那么来吧

22:37.070 --> 22:39.070
就把这个函数A拿过来执行

22:39.070 --> 22:41.070
是这么个意思

22:41.070 --> 22:42.070
它是这么个意思

22:42.070 --> 22:44.070
于是现在开始执行函数A

22:44.070 --> 22:45.070
函数A执行

22:45.070 --> 22:46.070
那就输出啥

22:46.070 --> 22:47.070
一不待吧

22:47.070 --> 22:49.070
它就是整个的执行过程是这样子

22:49.070 --> 22:50.070
好

22:50.070 --> 22:51.070
现在我们再来解释

22:51.070 --> 22:53.070
再来解释凌

22:53.070 --> 22:54.070
它是怎么回事

22:54.070 --> 22:55.070
又来

22:55.070 --> 22:56.070
再来一次

22:56.070 --> 22:57.070
凌是怎么回事

22:57.070 --> 22:58.070
比方说

22:58.070 --> 22:59.070
我们再来

22:59.070 --> 23:00.070
这是全句上下文

23:00.070 --> 23:03.770
全句上下文

23:03.770 --> 23:04.770
然后执行的时候

23:04.770 --> 23:05.770
调用了一个什么

23:05.770 --> 23:07.770
调用一个set time out

23:07.770 --> 23:08.770
set time out

23:08.770 --> 23:09.770
就是计时

23:09.770 --> 23:10.770
好

23:10.770 --> 23:11.770
计时的作用是什么

23:11.770 --> 23:13.770
是通知数组环境

23:13.770 --> 23:14.770
你来帮我计时

23:14.770 --> 23:15.770
我肯定是记不了时

23:15.770 --> 23:16.770
通知数组环境

23:16.770 --> 23:17.770
你再计时吧

23:17.770 --> 23:18.770
也不是一个计时现成吗

23:18.770 --> 23:20.770
于是它就计时多少

23:20.770 --> 23:21.770
凌秒

23:21.770 --> 23:22.770
凌秒后运行啥

23:22.770 --> 23:24.770
函数A

23:24.770 --> 23:25.770
好

23:25.770 --> 23:26.770
通知完了过

23:26.770 --> 23:27.770
是不是它立即结束了

23:27.770 --> 23:28.770
它就立即结束了

23:28.770 --> 23:30.770
它就没什么事情可做了

23:30.770 --> 23:32.770
它就是出一个通知

23:32.770 --> 23:33.770
它结束了

23:33.770 --> 23:34.770
它是不是马上也结束了

23:34.770 --> 23:36.770
因为凌秒是不是瞬间到了

23:36.770 --> 23:37.770
瞬间到了

23:37.770 --> 23:39.770
于是它把函数A跑这儿来了

23:39.770 --> 23:41.770
函数A到这儿来了

23:41.770 --> 23:42.770
它的作用就是

23:42.770 --> 23:44.770
数组现成它只做一件事

23:44.770 --> 23:46.770
就是它当条件满足的时候

23:46.770 --> 23:48.770
它会把对应的函数

23:48.770 --> 23:49.770
放到事件对列

23:49.770 --> 23:50.770
它就做这么一件事

23:50.770 --> 23:51.770
其他的事情不管了

23:51.770 --> 23:54.770
它不会去执行这个函数的

23:54.770 --> 23:55.770
然后介石里边

23:55.770 --> 23:57.770
但是介石现在能执行这个函数吗

23:57.770 --> 23:58.770
是不能

23:58.770 --> 24:01.770
因为现在介石引擎忙得要死

24:01.770 --> 24:03.770
根本没时间去看这个事件对列

24:03.770 --> 24:05.770
它还有一个全局上下文

24:05.770 --> 24:06.770
还没有执行完

24:06.770 --> 24:08.770
还有这个循环是不是没执行完

24:08.770 --> 24:09.770
它还没有空闲

24:09.770 --> 24:11.770
只有等它空闲的时候

24:11.770 --> 24:13.770
就是执行站为空

24:13.770 --> 24:14.770
没东西了

24:14.770 --> 24:15.770
它才会从事件对列里边

24:15.770 --> 24:17.770
拿出一个函数来执行

24:17.770 --> 24:18.770
执行站有东西

24:18.770 --> 24:20.770
它是绝对不会看事件对列的

24:20.770 --> 24:22.770
是绝对不会看事件对列的

24:23.770 --> 24:26.770
于是它会继续把执行上下文

24:26.770 --> 24:29.770
执行完执行上下文

24:29.770 --> 24:30.770
执行上下文执行完了之后

24:31.770 --> 24:33.770
把这个循环全部执行完之后

24:33.770 --> 24:35.770
哪怕这个循环要一个小时

24:35.770 --> 24:37.770
那都必须要全部执行

24:38.770 --> 24:39.770
执行完了之后

24:39.770 --> 24:41.770
我终于累了半天

24:41.770 --> 24:42.770
终于忙完了

24:42.770 --> 24:43.770
然后我来看一下

24:43.770 --> 24:45.770
事件对列里面有没有东西

24:45.770 --> 24:47.770
这个人等着黄花菜都快凉了

24:47.770 --> 24:48.770
等了太久了

24:48.770 --> 24:49.770
但是你没办法

24:49.770 --> 24:50.770
他忙了

24:50.770 --> 24:51.770
他就等着

24:51.770 --> 24:52.770
所以说

24:52.770 --> 24:54.770
这个时候再把这个函数A拿过来执行

24:54.770 --> 24:56.770
这个时候我们才看到了

24:56.770 --> 24:57.770
输出结果

24:57.770 --> 24:58.770
为什么

24:58.770 --> 25:00.770
这就是为什么这个异不代码

25:00.770 --> 25:01.770
它一定会在

25:01.770 --> 25:03.770
所有的同步代码之后执行

25:03.770 --> 25:04.770
就是这个原因

25:04.770 --> 25:05.770
看到没

25:06.770 --> 25:07.770
解释清楚了吧

25:07.770 --> 25:08.770
就这么简单

25:08.770 --> 25:09.770
没了

25:09.770 --> 25:11.770
接下来我们再来举些例子

25:11.770 --> 25:13.770
帮助你更加深刻的去珍视这一点

25:13.770 --> 25:14.770
比方说

25:14.770 --> 25:16.770
我们在这里写个事件

25:16.770 --> 25:17.770
事件也是一样

25:17.770 --> 25:19.770
事件也是一样

25:19.770 --> 25:20.770
比方说

25:20.770 --> 25:22.770
我们这里写一个

25:23.770 --> 25:24.770
点击

25:25.770 --> 25:27.770
点击按钮过后

25:27.770 --> 25:29.770
就随便输出一个

25:29.770 --> 25:30.770
找到按钮

25:30.770 --> 25:31.770
Documents

25:31.770 --> 25:32.770
Curry

25:32.770 --> 25:33.770
Select

25:33.770 --> 25:34.770
找到个按钮

25:34.770 --> 25:36.770
然后给它注册点击事件

25:36.770 --> 25:37.770
Unclick

25:37.770 --> 25:38.770
等于方式

25:39.770 --> 25:40.770
Console Log

25:40.770 --> 25:41.770
什么

25:41.770 --> 25:42.770
点击

25:42.770 --> 25:44.770
就是异不代码

25:46.770 --> 25:48.770
然后这里写个循环

25:49.770 --> 25:50.770
你看一下

25:50.770 --> 25:52.770
哪怕这个页面运行出来

25:52.770 --> 25:54.770
瞬间马上点这个按钮

25:54.770 --> 25:55.770
都没用

25:55.770 --> 25:56.770
看着吧

25:58.770 --> 26:02.080
刷新点击

26:03.080 --> 26:04.080
点了

26:04.080 --> 26:05.080
我已经点了

26:05.080 --> 26:06.080
我点了11次了

26:06.080 --> 26:07.080
我点了11次了

26:07.080 --> 26:08.080
有用吗

26:08.080 --> 26:09.080
没用

26:09.080 --> 26:11.080
异不代码还是在最后执行

26:11.080 --> 26:12.080
那是怎么回事呢

26:12.080 --> 26:13.080
好

26:13.080 --> 26:14.080
我来看一下

26:14.080 --> 26:15.080
这一块是怎么回事

26:15.080 --> 26:16.080
我们这里吧

26:16.080 --> 26:17.080
这里再来

26:18.080 --> 26:20.080
我们还是以这个地方为例

26:20.080 --> 26:22.080
还是以这个地方为例

26:22.080 --> 26:23.080
我们就在这画吧

26:23.080 --> 26:25.080
首先运行全局上下纹

26:25.080 --> 26:27.080
上下纹

26:27.080 --> 26:29.080
全局上下纹里边

26:29.080 --> 26:31.080
全局上下纹里边

26:31.080 --> 26:32.080
然后第一开始

26:32.080 --> 26:34.080
就在注册一个

26:34.080 --> 26:35.080
给一个东西复制

26:35.080 --> 26:36.080
对吧

26:36.080 --> 26:38.080
这个地方是不是在注册一个事件

26:38.080 --> 26:39.080
对不对

26:39.080 --> 26:40.080
给一个属性复制

26:40.080 --> 26:41.080
这里没有调用函数

26:41.080 --> 26:42.080
没有调用函数复制

26:42.080 --> 26:44.080
它没有使用ADD1分成Nation了

26:44.080 --> 26:46.080
给它注册一个事件

26:46.080 --> 26:47.080
这是不是一个异不函数

26:47.080 --> 26:48.080
那肯定是一个异不函数

26:48.080 --> 26:49.080
它没法马上执行

26:49.080 --> 26:50.080
它等到某个时机

26:50.080 --> 26:52.080
到达的时候才会执行

26:52.080 --> 26:53.080
往往异不函数

26:53.080 --> 26:54.080
它都会涉及到

26:54.080 --> 26:56.080
浏览器的其他线程

26:56.080 --> 26:58.080
负责来进行处理

26:58.080 --> 26:59.080
好

26:59.080 --> 27:00.080
这句话是什么作用

27:00.080 --> 27:01.080
就是这句话

27:01.080 --> 27:03.080
这句话的作用

27:03.080 --> 27:04.080
它的作用是

27:04.080 --> 27:06.080
通知数组

27:06.080 --> 27:07.080
环境

27:07.080 --> 27:08.080
它的事件

27:08.080 --> 27:09.080
监听线程

27:09.080 --> 27:11.080
你来帮我监听

27:11.080 --> 27:13.080
按钮的点击事件

27:13.080 --> 27:14.080
它通知

27:14.080 --> 27:15.080
通知这边

27:15.080 --> 27:17.080
监听按钮点击

27:19.080 --> 27:20.080
然后运行啥

27:20.080 --> 27:22.080
运行某一个函数

27:22.080 --> 27:23.080
运行函数

27:23.080 --> 27:24.080
比方说函数A

27:24.080 --> 27:26.080
该取个名字好画图

27:26.080 --> 27:28.080
运行函数A

27:28.080 --> 27:30.080
那我通知了

27:30.080 --> 27:31.080
我不管了

27:31.080 --> 27:32.080
然后接下来

27:32.080 --> 27:33.080
我继续运行

27:33.080 --> 27:34.080
上下文

27:34.080 --> 27:35.080
上下文继续运行

27:35.080 --> 27:36.080
是不是遇到循环

27:36.080 --> 27:37.080
对吧遇到循环

27:37.080 --> 27:38.080
开始循环了

27:38.080 --> 27:39.080
开始不断的输出

27:39.080 --> 27:40.080
不断的输出

27:40.080 --> 27:41.080
但是这个时候

27:41.080 --> 27:43.080
用户这里不停的在点击

27:43.080 --> 27:44.080
用户点击的时候

27:44.080 --> 27:45.080
它有没有监听到

27:45.080 --> 27:46.080
它肯定有监听到

27:46.080 --> 27:48.080
它监听到用户点击了

27:48.080 --> 27:50.080
于是用户没点击一次

27:50.080 --> 27:52.080
它就会把这个函数A

27:52.080 --> 27:54.080
移到这个事件队列

27:54.080 --> 27:56.080
移到这个事件队列

27:56.080 --> 27:57.080
但是这边不会消失

27:57.080 --> 27:58.080
这边还会继续监听

27:58.080 --> 28:01.080
除非你把事件给它取消掉了

28:01.080 --> 28:02.080
用户点击一次

28:02.080 --> 28:03.080
它把放到一个

28:03.080 --> 28:04.080
放到一个事件队列

28:04.080 --> 28:05.080
用户又点击了一次

28:05.080 --> 28:06.080
又放到事件队列

28:06.080 --> 28:07.080
用户又点击一次

28:07.080 --> 28:08.080
又放到事件队列

28:08.080 --> 28:09.080
点击到11次

28:09.080 --> 28:10.080
对吧刚才

28:10.080 --> 28:11.080
这里放了11个

28:11.080 --> 28:12.080
我不画了

28:12.080 --> 28:13.080
还在对了

28:13.080 --> 28:14.080
对吧还在对了

28:14.080 --> 28:15.080
好等着吧

28:15.080 --> 28:16.080
等着

28:16.080 --> 28:18.080
那么这里还忙着要死

28:18.080 --> 28:19.080
这件事情你还忙着要死

28:19.080 --> 28:21.080
等它把全局上下文执行完了过后

28:21.080 --> 28:22.080
一回头一看

28:22.080 --> 28:23.080
我靠

28:23.080 --> 28:25.080
事件队列里面有这么多东西了

28:25.080 --> 28:26.080
那来吧一个个来

28:26.080 --> 28:28.080
先运行函数A

28:28.080 --> 28:30.080
先运行函数A

28:30.080 --> 28:32.080
然后把函数A执行完

28:32.080 --> 28:33.080
执行完了过后

28:33.080 --> 28:34.080
函数A没了

28:34.080 --> 28:35.080
又排队吧

28:35.080 --> 28:37.080
下一个函数A又来运行一次

28:37.080 --> 28:38.080
又没了

28:38.080 --> 28:39.080
空了过后

28:39.080 --> 28:40.080
只有空闲过后

28:40.080 --> 28:41.080
才会看着事件队列

28:41.080 --> 28:43.080
又来运行一次

28:43.080 --> 28:45.080
又来运行一次

28:45.080 --> 28:46.080
没问题吧

28:46.080 --> 28:48.080
是这么个意思

28:49.080 --> 28:50.080
那么比方说

28:50.080 --> 28:52.080
我们这里代码再改一下

28:52.080 --> 28:53.080
再改一下

28:53.080 --> 28:54.080
我把这个玩意

28:54.080 --> 28:56.080
我把这个玩意

28:56.080 --> 28:58.080
写到一个函数里面

28:58.080 --> 28:59.080
写到函数里面

29:01.080 --> 29:02.080
或者叫做loop

29:02.080 --> 29:04.080
loop表示循环的意思

29:05.080 --> 29:06.080
其中我已经讲完了

29:06.080 --> 29:08.080
接下来我只是帮助大家理解

29:08.080 --> 29:10.080
深刻地理解这些东西

29:10.080 --> 29:11.080
那么没点击的时候

29:11.080 --> 29:13.080
我们运行一个set timeout

29:13.080 --> 29:14.080
0

29:14.080 --> 29:15.080
没点击一个

29:15.080 --> 29:17.080
一次运行一个set timeout0

29:17.080 --> 29:18.080
输出一个

29:18.080 --> 29:20.080
一不代码

29:20.080 --> 29:21.080
一不代码

29:21.080 --> 29:23.080
然后这里每一次

29:23.080 --> 29:25.080
还要去运行一个loop

29:25.080 --> 29:28.080
那么这个东西又怎么来理解

29:28.080 --> 29:30.080
我点击一次

29:30.080 --> 29:33.080
我们这里先运行一个loop

29:33.080 --> 29:35.080
那么这个程序会输出啥呢

29:35.080 --> 29:37.080
它会怎么输出呢

29:37.080 --> 29:39.080
它会怎么输出

29:39.080 --> 29:41.080
接下来我们来看一下吧

29:43.080 --> 29:45.080
首先我们这里全部删除掉

29:45.080 --> 29:46.080
你把这个地方理解完了

29:46.080 --> 29:48.080
就基本上就没了

29:48.080 --> 29:52.030
好来吧

29:52.030 --> 29:54.030
首先那是权局上下文对吧

29:54.030 --> 29:56.030
权局上下文

29:56.030 --> 29:58.030
这里是个权局上下文

30:00.030 --> 30:03.030
权局上下文

30:03.030 --> 30:06.030
好接下来在权局上下文里面

30:06.030 --> 30:07.030
干嘛呢

30:07.030 --> 30:09.030
是不是注册了一个函数

30:09.030 --> 30:10.030
注册了一个事件

30:10.030 --> 30:12.030
那么是不是告诉了事件

30:12.030 --> 30:13.030
监听现成

30:13.030 --> 30:14.030
你去监听吧

30:14.030 --> 30:15.030
监听什么

30:15.030 --> 30:17.030
监听按钮点击事件

30:17.030 --> 30:19.030
然后监听完了过后运行啥

30:19.030 --> 30:21.030
运行函数A

30:21.030 --> 30:23.030
这个函数

30:23.030 --> 30:24.030
现在运不运行

30:24.030 --> 30:25.030
现在不运行

30:25.030 --> 30:26.030
那么这边会不会等

30:26.030 --> 30:28.030
等它点击肯定不会等

30:28.030 --> 30:30.030
我只是通知他一下

30:30.030 --> 30:31.030
然后我接着运行

30:31.030 --> 30:32.030
运行啥

30:32.030 --> 30:34.030
是不是输出循环

30:34.030 --> 30:35.030
对吧输出循环

30:35.030 --> 30:37.030
那么我们这里演示一遍吧

30:37.030 --> 30:38.030
来演示一遍

30:38.030 --> 30:40.030
比方说在循环之前我就点击了

30:40.030 --> 30:42.030
在循环之前我就点击了

30:42.030 --> 30:44.030
那么这个时候呢

30:44.030 --> 30:45.030
它会把函数A排到哪

30:45.030 --> 30:47.030
排到事件对立

30:47.030 --> 30:48.030
比方点击了两次

30:48.030 --> 30:50.030
在它循环完之前

30:50.030 --> 30:51.030
我就点击了两次

30:51.030 --> 30:53.030
它就会把这个函数A排到

30:53.030 --> 30:55.030
两个函数A排到这个事件对立里边

30:55.030 --> 30:56.030
它监听嘛

30:56.030 --> 30:57.030
对不对

30:57.030 --> 30:58.030
好

30:58.030 --> 31:00.030
但是全剧上下文还没有执行完

31:00.030 --> 31:02.030
因为我这里在运行调用函数对不对

31:02.030 --> 31:03.030
调用函数调用啥函数

31:03.030 --> 31:04.030
是不是路普函数对吧

31:04.030 --> 31:06.030
我这里还在调用路普函数

31:06.030 --> 31:07.030
调用这个函数

31:07.030 --> 31:09.030
是这样子吧对吧没问题吧

31:09.030 --> 31:12.030
函数调用它是不是会创建上下文对吧

31:12.030 --> 31:14.030
我在调用路普函数

31:14.030 --> 31:15.030
还在正在执行

31:15.030 --> 31:18.030
没有时间去执行你的事件对立

31:18.030 --> 31:19.030
没有时间

31:19.030 --> 31:21.030
于是那就等呗

31:21.030 --> 31:22.030
等着呗

31:22.030 --> 31:23.030
接视引擎

31:23.030 --> 31:25.030
等着等着啊

31:25.030 --> 31:27.030
路普终于循环完了

31:27.030 --> 31:28.030
路普结束

31:28.030 --> 31:30.030
然后又回到全剧上下文

31:30.030 --> 31:32.030
发现全剧上下文里边已经没东西了

31:32.030 --> 31:33.030
已经没有东西了

31:33.030 --> 31:34.030
调用结束了

31:34.030 --> 31:35.030
接下来全剧上下文结束

31:35.030 --> 31:36.030
这个时候呢

31:36.030 --> 31:39.030
它才有空去看一下事件对立

31:39.030 --> 31:41.030
开放事件对立里边有东西对吧

31:41.030 --> 31:42.030
好

31:42.030 --> 31:43.030
第一个东西拿出来

31:43.030 --> 31:45.030
执行函数A

31:45.030 --> 31:46.030
执行函数A

31:46.030 --> 31:48.030
执行函数A的时候

31:48.030 --> 31:50.030
执行函数A的时候

31:50.030 --> 31:52.030
是不是又遇到一个异步对吧

31:52.030 --> 31:53.030
又遇到一个异步

31:53.030 --> 31:55.030
函数遇到异步就来一次吧

31:55.030 --> 31:56.030
通知啥

31:56.030 --> 31:58.030
通知计时器现成

31:58.030 --> 32:00.030
我这里怎么这样子写我的天

32:02.030 --> 32:04.030
这是B嘛B

32:04.030 --> 32:06.030
通知一个计时器现成

32:06.030 --> 32:08.030
我刚才是不是也这样写的

32:08.030 --> 32:09.030
吓我一跳

32:09.030 --> 32:11.030
通知计时器现成

32:11.030 --> 32:13.030
0秒之后运行函数B

32:13.030 --> 32:14.030
来通知

32:14.030 --> 32:15.030
它运行啥

32:15.030 --> 32:17.030
运行写Timeout

32:17.030 --> 32:19.030
运行写Timeout

32:19.030 --> 32:20.030
通知什么

32:20.030 --> 32:23.030
通知计时器现成

32:23.030 --> 32:24.030
两个

32:24.030 --> 32:27.030
0秒后

32:27.030 --> 32:29.030
运行函数A

32:29.030 --> 32:30.030
函数B

32:30.030 --> 32:32.030
0秒后运行函数B

32:32.030 --> 32:33.030
那么现在呢

32:33.030 --> 32:34.030
现在呢

32:34.030 --> 32:35.030
就是

32:35.030 --> 32:37.030
这个函数是不是马上运行完了

32:37.030 --> 32:39.030
它只是发出一个通知

32:39.030 --> 32:41.030
这边是不是马上就到达时间了

32:41.030 --> 32:43.030
0秒嘛

32:43.030 --> 32:44.030
所以说这里呢

32:44.030 --> 32:46.030
就把函数B放过来了

32:46.030 --> 32:47.030
看没

32:47.030 --> 32:48.030
又排队嘛

32:48.030 --> 32:49.030
始终只有一个队列

32:49.030 --> 32:50.030
一排队

32:50.030 --> 32:52.030
接着运行函数A

32:52.030 --> 32:53.030
接着运行函数A

32:53.030 --> 32:54.030
函数A要干嘛

32:54.030 --> 32:55.030
是不是又来循环

32:55.030 --> 32:56.030
又调用loop

32:56.030 --> 32:57.030
函数A这个人

32:57.030 --> 32:59.030
比较设比较多

32:59.030 --> 33:01.030
它占用了这个执行站

33:01.030 --> 33:03.030
它一直在调用它

33:03.030 --> 33:04.030
运行loop

33:04.030 --> 33:05.030
loop的时候

33:05.030 --> 33:07.030
运行的时候是不是输出

33:07.030 --> 33:08.030
循环又按车

33:08.030 --> 33:10.030
如果这个时候又点击了

33:10.030 --> 33:11.030
又有人点击了

33:11.030 --> 33:13.030
正在循环的时候又有人点击了

33:13.030 --> 33:14.030
是不是又来一次

33:14.030 --> 33:16.030
又来了一个函数A

33:16.030 --> 33:18.030
又来了一个函数排队

33:18.030 --> 33:20.030
就是这么个意思

33:20.030 --> 33:22.030
然后循环完了之后

33:22.030 --> 33:24.030
然后函数A才调用结束

33:24.030 --> 33:26.030
然后又来看事件队列

33:26.030 --> 33:27.030
看到没

33:27.030 --> 33:29.030
它是用这么一种调用顺序

33:29.030 --> 33:30.030
应该这个意思吧

33:30.030 --> 33:32.030
用了这么一种调用顺序

33:32.030 --> 33:33.030
所以这个函数B

33:33.030 --> 33:34.030
怎么来

33:34.030 --> 33:35.030
什么时候执行了

33:35.030 --> 33:36.030
它在等

33:36.030 --> 33:38.030
等到函数A

33:38.030 --> 33:39.030
前面的两个函数A

33:39.030 --> 33:40.030
执行完了之后

33:40.030 --> 33:42.030
才能去执行这个函数B

33:42.030 --> 33:44.030
是这么个意思

33:44.030 --> 33:45.030
这么个意思

33:45.030 --> 33:46.030
好 咱们来看一下吧

33:46.030 --> 33:48.030
我们这里的

33:48.030 --> 33:50.030
运行吧

33:50.030 --> 33:53.470
看着

33:53.470 --> 33:55.470
刷新

33:55.470 --> 34:00.060
然后点两次

34:00.060 --> 34:02.060
卡住了 让它卡吧

34:02.060 --> 34:05.060
运行的两个

34:05.060 --> 34:07.060
一不带

34:07.060 --> 34:08.060
一不带

34:08.060 --> 34:10.060
前面实际上

34:10.060 --> 34:11.060
前面实际上

34:11.060 --> 34:12.060
循环了多次了

34:12.060 --> 34:13.060
循环了三次

34:13.060 --> 34:14.060
我们刚才分析出来的

34:14.060 --> 34:16.060
它会循环三次

34:16.060 --> 34:17.060
久久久久 有久

34:17.060 --> 34:18.060
看到没

34:18.060 --> 34:19.060
它会循环三次

34:19.060 --> 34:20.060
它会循环三次

34:20.060 --> 34:21.060
然后才会运行一不带

34:21.060 --> 34:22.060
为什么会循环三次

34:22.060 --> 34:23.060
才会运行

34:23.060 --> 34:25.060
它会运行点两次

34:25.060 --> 34:26.060
结果

34:26.060 --> 34:27.060
就是它只排队的

34:27.060 --> 34:28.060
刚才

34:28.060 --> 34:29.060
我们全局上下文里边

34:29.060 --> 34:30.060
运行了一次循环

34:30.060 --> 34:31.060
然后函数A

34:31.060 --> 34:32.060
刚才只行了函数A

34:32.060 --> 34:33.060
里面运行了一次循环

34:33.060 --> 34:35.060
B还在这里排队

34:35.060 --> 34:36.060
然后下一次点击

34:36.060 --> 34:37.060
函数A里面

34:37.060 --> 34:38.060
运行一次循环

34:38.060 --> 34:41.060
那么最后来才轮到函数B

34:41.060 --> 34:43.060
才轮到函数B

34:43.060 --> 34:44.060
总之呢

34:44.060 --> 34:45.060
你要画图

34:45.060 --> 34:46.060
你要画图

34:46.060 --> 34:47.060
才知道是什么意思

34:47.060 --> 34:48.060
总之呢

34:48.060 --> 34:50.060
你以后看到什么异不带

34:50.060 --> 34:51.060
你脑袋里面

34:51.060 --> 34:52.060
马上反应过来

34:52.060 --> 34:53.060
这个函数

34:53.060 --> 34:54.060
它到时候要排队的

34:54.060 --> 34:55.060
它不会干扰

34:55.060 --> 34:56.060
当前的执行的

34:56.060 --> 34:57.060
那么这里

34:57.060 --> 34:58.060
来问大家一个问题

34:58.060 --> 35:00.060
就是在介石中

35:00.060 --> 35:02.060
介石中

35:02.060 --> 35:03.060
不可能

35:03.060 --> 35:04.060
看这句话

35:04.060 --> 35:05.060
是不是正确的

35:05.060 --> 35:07.060
不可能出现

35:07.060 --> 35:08.060
不可能

35:08.060 --> 35:09.060
应该这样说

35:09.060 --> 35:10.060
介石中

35:10.060 --> 35:13.060
某个函数的执行

35:13.060 --> 35:16.060
不可能被打断

35:16.060 --> 35:17.060
什么叫被打断

35:17.060 --> 35:20.080
什么叫被打断

35:20.080 --> 35:21.080
就比方说有个函数

35:21.080 --> 35:22.080
它可能

35:22.080 --> 35:23.080
这里要循环1万次

35:23.080 --> 35:25.080
但它循环到第500次的时候

35:25.080 --> 35:26.080
被其他代码

35:26.080 --> 35:28.080
被其他函数拿过去执行了

35:28.080 --> 35:30.080
有没有这种可能在介石里面

35:30.080 --> 35:31.080
在介石里面

35:31.080 --> 35:33.080
有没有这种可能

35:33.080 --> 35:34.080
它循环到500次的时候

35:34.080 --> 35:36.080
被其他代码拿去执行了

35:36.080 --> 35:37.080
终止了这个循环

35:37.080 --> 35:39.080
那等一会又接着来这个循环

35:39.080 --> 35:40.080
有没有这种可能

35:40.080 --> 35:43.080
在介石里面是绝对不可能的

35:43.080 --> 35:44.080
绝对不可能

35:44.080 --> 35:45.080
为什么

35:45.080 --> 35:47.080
你看到刚才的执行上下文了

35:47.080 --> 35:49.080
它一个函数没有执行完

35:49.080 --> 35:50.080
它能执行下一个函数吗

35:50.080 --> 35:51.080
没有

35:51.080 --> 35:53.080
因为介石引擎

35:53.080 --> 35:54.080
它是单线程的

35:54.080 --> 35:55.080
它只有一个人

35:55.080 --> 35:57.080
它不能抢夺执行

35:57.080 --> 35:59.080
它必须要把一个东西执行完了过后

35:59.080 --> 36:01.080
上下文里面是堆砞

36:01.080 --> 36:02.080
对不对

36:02.080 --> 36:03.080
上下文砞里面

36:03.080 --> 36:05.080
它一定要把一个上下文执行完了过后

36:05.080 --> 36:07.080
才能执行下一个上下文

36:07.080 --> 36:08.080
对吧

36:08.080 --> 36:09.080
那么执行的过程中

36:09.080 --> 36:10.080
执行的过程中

36:10.080 --> 36:11.080
如果遇到函数雕用

36:11.080 --> 36:13.080
那是另外一回事了

36:13.080 --> 36:14.080
如果遇到函数雕用

36:14.080 --> 36:16.080
那么去执行另外一个函数

36:16.080 --> 36:17.080
我说打断是

36:17.080 --> 36:19.080
莫名其妙被打断了

36:19.080 --> 36:21.080
莫名其妙被打断了

36:21.080 --> 36:22.080
当然如果你去

36:22.080 --> 36:23.080
这里去雕用一个函数

36:23.080 --> 36:24.080
它肯定要去转而执行那个函数

36:24.080 --> 36:25.080
那执行完了过

36:25.080 --> 36:26.080
又回到这里来继续执行

36:26.080 --> 36:27.080
对吧

36:27.080 --> 36:29.080
这是叫同步代码

36:29.080 --> 36:30.080
那么一步代码

36:30.080 --> 36:32.080
为什么不会干扰同步代码

36:32.080 --> 36:33.080
比方说

36:33.080 --> 36:34.080
有些同学就担心

36:34.080 --> 36:35.080
担心啥呢

36:35.080 --> 36:36.080
这里是0秒

36:36.080 --> 36:37.080
那会不会

36:37.080 --> 36:39.080
比方说这里写个5毫秒

36:39.080 --> 36:40.080
5毫秒很短

36:40.080 --> 36:41.080
或者是1毫秒

36:41.080 --> 36:42.080
1毫秒很短

36:42.080 --> 36:43.080
那么这里会不会运行到

36:43.080 --> 36:44.080
500毫秒的

36:44.080 --> 36:45.080
500次的循环的时候

36:45.080 --> 36:47.080
它刚好到达100毫秒

36:47.080 --> 36:49.080
那么会转而去执行它

36:49.080 --> 36:50.080
那就担心这个

36:50.080 --> 36:51.080
绝对不可能

36:51.080 --> 36:52.080
它在排队

36:52.080 --> 36:53.080
等我闲的时候

36:53.080 --> 36:54.080
我才会执行

36:54.080 --> 36:57.080
正是因为介石这个特点

36:57.080 --> 36:58.080
让介石语言变得

36:58.080 --> 37:00.080
学习性来变得非常非常轻松

37:00.080 --> 37:02.080
介石语言它有很多的问题

37:03.080 --> 37:04.080
当然这些问题

37:04.080 --> 37:06.080
后来陆陆学习解决了不少了

37:06.080 --> 37:08.080
但是它最强大的一点

37:08.080 --> 37:10.080
就在于它的异部异部机制

37:10.080 --> 37:12.080
它不会强多执行

37:12.080 --> 37:13.080
就是我执行到这一半

37:13.080 --> 37:15.080
我还没有完你就被别人强了

37:15.080 --> 37:16.080
强去执行的

37:16.080 --> 37:18.080
它不会出现这种情况

37:18.080 --> 37:19.080
但是我告诉你

37:19.080 --> 37:20.080
在很多后段语言

37:20.080 --> 37:21.080
它都会出现

37:21.080 --> 37:23.080
加把多线程的语言

37:23.080 --> 37:24.080
它会出现这种情况

37:24.080 --> 37:26.080
CCR加权是多线程的

37:26.080 --> 37:28.080
PACP不是

37:28.080 --> 37:30.080
CCR多线程的

37:30.080 --> 37:31.080
像这些语言

37:31.080 --> 37:33.080
他们由于多线程的存在

37:33.080 --> 37:35.080
一旦你设计到多线程

37:35.080 --> 37:37.080
编程的时候就非常非常恐怖

37:37.080 --> 37:38.080
代码复杂度一下

37:38.080 --> 37:39.080
标声

37:39.080 --> 37:40.080
它不是乘一二了

37:40.080 --> 37:42.080
两个线程它不是乘一二的复杂度

37:42.080 --> 37:44.080
那是平方的复杂度

37:45.080 --> 37:46.080
为什么会标声

37:46.080 --> 37:47.080
因为你时时刻刻要考虑到

37:47.080 --> 37:49.080
你这个代码

37:49.080 --> 37:51.080
是不是会被强多执行

37:51.080 --> 37:52.080
你执行到一半

37:52.080 --> 37:53.080
会被别人强了

37:53.080 --> 37:55.080
要考虑很多问题

37:55.080 --> 37:56.080
比方说

37:56.080 --> 37:58.080
我这里的IS定到外面的

37:58.080 --> 37:59.080
定到外面的

37:59.080 --> 38:00.080
你始终要考虑到

38:00.080 --> 38:02.080
而且我循环到500次的时候

38:02.080 --> 38:03.080
会不会有别人

38:03.080 --> 38:04.080
把这个IS改成了

38:04.080 --> 38:05.080
7 1000

38:05.080 --> 38:06.080
改成了2000

38:06.080 --> 38:07.080
又怎么办

38:07.080 --> 38:08.080
要考虑到这些问题

38:08.080 --> 38:10.080
会把程序变得非常非常复杂

38:10.080 --> 38:12.080
但是既也是绝对不用担心

38:12.080 --> 38:15.080
它一个函数一定是完整执行的

38:15.080 --> 38:16.080
它只有空弦的时候

38:16.080 --> 38:18.080
才会执行这些业不代码

38:18.080 --> 38:20.080
原来这是吧

38:20.080 --> 38:22.080
这是关于事件循环这一块

38:22.080 --> 38:24.080
为什么叫做事件循环

38:24.080 --> 38:25.080
就是它这里

38:25.080 --> 38:26.080
它会形成一个循环

38:26.080 --> 38:28.080
执行站空的时候

38:28.080 --> 38:29.080
拿事件对列

38:29.080 --> 38:30.080
事件对列的执行过程中

38:30.080 --> 38:32.080
有可能放向输主环境

38:32.080 --> 38:34.080
发出一个异步

38:34.080 --> 38:37.080
当异步就是

38:37.080 --> 38:38.080
条件满足的时候

38:38.080 --> 38:39.080
它又过来

38:39.080 --> 38:40.080
它又过去

38:40.080 --> 38:41.080
执行站过程中

38:41.080 --> 38:42.080
它有可能又过来

38:42.080 --> 38:43.080
又可能又倒对点

38:43.080 --> 38:44.080
又可能过去

38:44.080 --> 38:45.080
形成了一个圈

38:45.080 --> 38:46.080
就是个去

38:46.080 --> 38:47.080
事件循环

38:47.080 --> 38:49.080
我们把它形象的称之为

38:49.080 --> 38:51.080
事件循环

38:51.080 --> 38:52.080
事件循环

38:52.080 --> 38:53.080
最后做一个定义

38:53.080 --> 38:54.080
事件循环

38:54.080 --> 38:57.080
它叫做events loop

38:58.080 --> 39:01.080
势子执行站

39:03.080 --> 39:07.080
函数在执行站

39:07.080 --> 39:09.080
输主

39:09.080 --> 39:10.080
现成

39:10.080 --> 39:13.080
以及事件

39:13.080 --> 39:16.080
对列中的

39:16.080 --> 39:19.080
循环执行

39:19.080 --> 39:20.080
循环移动

39:20.080 --> 39:22.080
应该说循环移动

39:22.080 --> 39:23.080
这就是事件循环

39:23.080 --> 39:24.080
解释起来比较抽象

39:24.080 --> 39:25.080
但是看

39:25.080 --> 39:27.080
刚才的例子是不是很倾向

39:27.080 --> 39:28.080
对不对

39:28.080 --> 39:29.080
以后你就知道了

39:29.080 --> 39:31.080
事件到底是怎么回事

39:31.080 --> 39:33.080
那么这个就是

39:33.080 --> 39:34.080
计时期到底是怎么回事

39:34.080 --> 39:35.080
它到底是怎么执行的

39:35.080 --> 39:36.080
就知道了

39:36.080 --> 39:37.080
那么以后

39:37.080 --> 39:38.080
比方说面试的时候

39:38.080 --> 39:39.080
给大家面试观点

39:39.080 --> 39:40.080
他问你

39:40.080 --> 39:41.080
比方说

39:41.080 --> 39:43.080
现在我们正在运行一些函数

39:43.080 --> 39:44.080
那么这个时候

39:44.080 --> 39:45.080
你触发了一些事件

39:45.080 --> 39:46.080
那么这些事件

39:46.080 --> 39:47.080
会不会打断这个函数的执行

39:47.080 --> 39:48.080
它不会

39:48.080 --> 39:49.080
它会等

39:49.080 --> 39:50.080
等这些函数

39:50.080 --> 39:51.080
全部执行完了之后

39:51.080 --> 39:52.080
空了

39:52.080 --> 39:53.080
执行站空了

39:53.080 --> 39:54.080
才会执行它

39:54.080 --> 39:55.080
因为它

39:55.080 --> 39:56.080
因为你点了过后

39:56.080 --> 39:57.080
触发了事件过后

39:57.080 --> 39:58.080
你的函数

39:58.080 --> 39:59.080
你要执行的函数

39:59.080 --> 40:00.080
是在对列里边

40:00.080 --> 40:01.080
它在等着

40:01.080 --> 40:02.080
就完了

40:02.080 --> 40:03.080
这就是事件对列

40:03.080 --> 40:05.080
好了

40:05.080 --> 40:06.080
这几个

40:06.080 --> 40:07.080
那么目不前的致辞

40:07.080 --> 40:10.080
我们解释的原地部分

40:10.080 --> 40:11.080
全部结束了

40:11.080 --> 40:12.080
以后的面试题

40:12.080 --> 40:14.080
随便怎么考虑我告诉你

40:14.080 --> 40:15.080
只要你把原型

40:15.080 --> 40:16.080
原型链搞清楚了

40:16.080 --> 40:17.080
执行上下文

40:17.080 --> 40:18.080
作用预列搞清楚了

40:18.080 --> 40:19.080
事件循环

40:19.080 --> 40:20.080
就这三块

40:20.080 --> 40:21.080
一个是原型

40:21.080 --> 40:22.080
一个是执行上下文

40:22.080 --> 40:23.080
作用预列的话

40:23.080 --> 40:25.080
执行上下文里边的一块知识

40:25.080 --> 40:26.080
然后一个是事件循环

40:26.080 --> 40:27.080
就这三个

40:27.080 --> 40:28.080
原型

40:28.080 --> 40:29.080
执行上下文

40:29.080 --> 40:30.080
事件循环

40:30.080 --> 40:31.080
这三个东西搞清楚了

40:31.080 --> 40:32.080
借识语言就通了

40:32.080 --> 40:33.080
借识语言

40:33.080 --> 40:34.080
其实你说复杂吧

40:34.080 --> 40:35.080
它可能有些地方

40:35.080 --> 40:36.080
这三个东西

40:36.080 --> 40:37.080
确实特别是

40:37.080 --> 40:38.080
作用链这一块

40:38.080 --> 40:39.080
确实有些复杂度

40:39.080 --> 40:40.080
但是相比于

40:40.080 --> 40:41.080
其他语言

40:41.080 --> 40:43.080
已经简单相当相上多了

40:43.080 --> 40:44.080
因为其他语言

40:44.080 --> 40:45.080
你要搞清楚它的底层原理

40:45.080 --> 40:46.080
你要花好多好多

40:46.080 --> 40:47.080
精力和时间

40:47.080 --> 40:48.080
但借识已经完了

40:48.080 --> 40:49.080
它就这么一点

40:49.080 --> 40:50.080
它的核心原理

40:50.080 --> 40:51.080
就这么一些

40:51.080 --> 40:52.080
没了

40:52.080 --> 40:53.080
你再要深入的话

40:53.080 --> 40:54.080
那就要涉及到

40:54.080 --> 40:55.080
抽象 语法 书

40:55.080 --> 40:56.080
那些东西

40:56.080 --> 40:58.080
太底层的东西了

40:58.080 --> 40:59.080
那么太底层的东西

40:59.080 --> 41:00.080
我们这就不讲了

41:00.080 --> 41:02.080
也没出那么多少意义

41:02.080 --> 41:03.080
可能有点点意义

41:03.080 --> 41:04.080
但是意义不大了

41:04.080 --> 41:05.080
但是这三个东西

41:05.080 --> 41:06.080
是有意义的

41:06.080 --> 41:07.080
把这三个东西

41:07.080 --> 41:08.080
搞清楚以后

41:08.080 --> 41:10.080
面试题你随便做

41:10.080 --> 41:11.080
随便做什么面试题

41:11.080 --> 41:12.080
无所谓

41:12.080 --> 41:13.080
当然你还可以

41:13.080 --> 41:14.080
还需要学习

41:14.080 --> 41:15.080
后边的一些新的

41:15.080 --> 41:16.080
ES6的新的语法知识

41:18.080 --> 41:19.080
事件循环讲完了

41:19.080 --> 41:20.080
但是事件循环的知识

41:20.080 --> 41:21.080
还没有彻底结束

41:21.080 --> 41:23.080
因为我之前说过

41:23.080 --> 41:24.080
这个东西

41:24.080 --> 41:25.080
它后边学到具体的

41:25.080 --> 41:26.080
宿主环境以后

41:27.080 --> 41:30.080
以后你们学习了ES6

41:30.080 --> 41:31.080
之后

41:31.080 --> 41:32.080
它还会进一步加深

41:32.080 --> 41:33.080
事件循环

41:34.080 --> 41:35.080
但是目前它的核心

41:35.080 --> 41:36.080
部分就讲完了

41:37.080 --> 41:38.080
那么接下来

41:38.080 --> 41:39.080
后边的课

41:39.080 --> 41:40.080
就是讲的一些

41:40.080 --> 41:41.080
实用性的东西了

41:41.080 --> 41:42.080
凭是我们怎么去写代码

41:42.080 --> 41:44.080
能够写代码

41:44.080 --> 41:45.080
怎么去写

41:45.080 --> 41:47.080
才能写出一些优质的代码

41:47.080 --> 41:48.080
讲的是这么些东西

41:49.080 --> 41:50.080
好 这是事件循环

