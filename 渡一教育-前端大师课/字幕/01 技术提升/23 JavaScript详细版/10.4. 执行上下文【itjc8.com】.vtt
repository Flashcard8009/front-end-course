WEBVTT

00:00.000 --> 00:16.390
这节课呢 非常非常重要

00:17.190 --> 00:21.150
这节课的重要程度呢 应该说是境界部分最重要的

00:22.190 --> 00:29.470
不仅是在面试题里边会经常出现 而且呢 在我对于我们理解程序呢 也至关重要

00:30.070 --> 00:33.230
咱们呢 首先看一道面试题啊 随便看一道题吧

00:34.150 --> 00:37.990
你看一下这道题 你能说出这道题 他说出什么样的结果吗

00:38.990 --> 00:40.990
能说 能说出他的结果吗

00:42.790 --> 00:44.390
看一下啊 看一下

00:47.870 --> 00:54.870
如果你觉得这道题做起来很模糊的话 那么学了这节课之后 你就非常清楚这道题该怎么来做了啊

00:55.630 --> 01:00.350
好 这里呢 我们来说一下本节课 指琴上下文 是一个什么东西

01:00.990 --> 01:08.990
首先呢 我们给他下一个定义啊 什么叫做执行上下文 这块的知识呢 我在公开直播课里面讲过

01:09.590 --> 01:15.230
啊 讲过这节课 但是呢 当时没有录屏 所以说呢 这节课呢 我们录屏一下来 大家如果看着

01:15.790 --> 01:24.510
呃 比较模糊的话感觉 那么就可以反复观看一下啊 比方说你面试之前你可以看一下 因为这这个知识点啊 经常出面试题

01:25.470 --> 01:29.550
好 比方说啊 我们不比方说啊 我们给他下个定义 上下文

01:30.590 --> 01:34.590
什么是执行上下文呢 指的是一个函数

01:35.150 --> 01:42.910
启动 就是运行之前啊 运行之前 为什么会 这个函数会运行 因为有人在调用它

01:43.510 --> 01:48.710
对吧 有人调用函数呢 还会运行这个函数 那么在他运行之前呢

01:49.790 --> 01:56.270
创建的一块内存空间 这就是执行上下文 空间中

01:57.470 --> 02:03.750
包含有该函数执行所需要的数据

02:05.590 --> 02:12.790
啊 为这个函数执行的提供支持啊 为该函数执行提供支持

02:13.230 --> 02:19.110
这是我们给执行上下文创 就是下了一个简单的定义啊 就是什么意思呢 它就是一个内存空间

02:19.470 --> 02:23.150
啊 我们之前也说过很多内存空间 对吧 一个对象里边属性

02:23.990 --> 02:30.110
内存空间啊 一个辨量内存空间 对吧 执行上下文呢 它也是一块内存空间 你可以把它想象成一个对象

02:30.830 --> 02:35.350
啊 你可以把它想象成一个对象 这个对象里边呢 它有一些属性 对吧 一些属性

02:35.750 --> 02:42.230
然后呢 这些属性呢 它为什么为什么作用呢 起什么作用呢 它是为函数的执行提供支持的

02:43.030 --> 02:48.270
咱们呢 先不着急去考虑这个内存空间里边有哪些东西啊

02:48.750 --> 02:56.830
它怎么样为函数提供支持 先不考虑这些 我们先来理解另外一个概念 叫做执行上下文堆战

02:57.190 --> 03:08.270
这个指的是什么意思呢 它叫做Costac 这个其实呢 我们之前讲啥的时候我讲到过啊 我也忘了啊 反正我讲之前我肯定是讲到过 但是没有详细说

03:09.430 --> 03:14.590
那么这一块是什么意思呢 它指的是 就是所有执行上下文

03:15.870 --> 03:18.630
组成的 组成的内存空间

03:19.910 --> 03:20.790
它形成了一个堆战

03:21.790 --> 03:28.990
这个战的结构 应该叫严格来说的话 我们平时说习惯了 叫做堆战 其实严格来说的话叫做战 指行上下文战

03:30.630 --> 03:32.830
它其实是什么意思呢 指的是就是

03:33.830 --> 03:39.230
不是每一个函数运行之前都会创建一块内存空间吗 那么这些内存空间组合起来

03:39.670 --> 03:44.710
就形成了一个指行上下文战 战是一种数据结构 它有这么一个特点

03:45.710 --> 03:53.430
我现在再解释 占这个概念 把这个占式的概念解释通 然后我们再讲执行上下文战 就是Corsetek

03:54.230 --> 03:57.390
好 占是什么意思呢 就是一种数据结构

03:59.430 --> 04:03.870
比方说我们数据就是一种数据结构 对吧 它的特点是先进后出

04:05.470 --> 04:06.310
先进后出

04:09.030 --> 04:10.870
后进先出

04:11.870 --> 04:17.990
咱们现在理解这么一个概念 占的概念 这里我建一个PPT文件嘛 桌面上建一个

04:19.590 --> 04:23.310
比方说我们建一个PPT呢 我的 占

04:26.080 --> 04:28.360
好 以后我把个PPT放到那个 就是我的

04:30.040 --> 04:31.240
就是工程里边

04:32.920 --> 04:36.600
占是什么东西呢 就是一块内存空间 就是内存空间

04:37.560 --> 04:46.720
就是一个占 好 里边那是不是可以装数据 对吧 既然内存空间里边肯定是可以装数据的 好 接下来呢 我们往这个占里边去装数据

04:48.600 --> 04:54.840
装一个数据 然后数据该换个颜色啊 改换个颜色 好 这是数据一啊 这是数据一

04:56.680 --> 05:05.880
数据一 好 装进来了对吧 那一会呢 又来了一个数据啊 又来了一个数据 那么要加一个数据 加一个数据怎么加呢 它是这样子加的

05:06.440 --> 05:11.160
你可以认为这是占的 上边 这是占的下边 对吧 它是从上边下进来的 就像一个杯子

05:11.720 --> 05:17.960
一个杯子 往一个杯子里面放东西 是从上往下加的 好 新加的数据呢 就要加到这 数据二

05:19.080 --> 05:24.640
好 再下一个数据呢 就数据三加到这 那么就形成了这么一种顺序 对吧 加数据是这样子加的

05:25.720 --> 05:30.720
加数据的过程呢 我们把它叫做入占 加数据的过程 我们把它叫做入占

05:33.020 --> 05:35.180
好 这里 入占

05:37.140 --> 05:40.380
就是往占这个内存空间里边加一个数据 就叫做入占

05:41.500 --> 05:48.980
入占了也有一个英文单词呢 叫做什么 PUSH PUSH PUSH这个单词呢 我们以前见过 在数据里边是不是一个方法叫 PUSH 对吧

05:49.340 --> 05:52.780
表示的是把加到什么 加到加到一个数据的末尾

05:53.260 --> 05:58.060
其实它这个单词呢 就是从占里边来的 占里边加的数据呢 就一定是加到占的末尾

05:58.340 --> 06:04.980
它的末尾在上面 它的末尾在上面 这叫做入占 入占什么意思 我再说一次啊 指的是往占里边加数据

06:05.460 --> 06:11.820
往占里边加数据 说了我不画 不画剑头了啊 反正画剑头了 叫入占 好 另外一个数据呢 叫初占

06:13.060 --> 06:18.460
叫初占 初占呢 就是从占里边移出一个数据 叫做 POP POP

06:19.620 --> 06:26.260
好 比方说吧 这里有个数据室 比方说一个数据室 它一开始入占的时候 加到占的末尾了 对吧 一定是加到最上边

06:26.740 --> 06:33.660
然后初占是怎么出动呢 它这样子弹出去 POPP什么意思 就弹出的意思 也就是说我们新加的数据

06:35.180 --> 06:41.020
移出的时候呢 一定是第一个移出的 初占的时候呢 一定是把最新加的数据移出掉

06:41.420 --> 06:47.740
是这么回事 这占这么数据结构 而最先加加的数据呢 最先加的数据呢 是最后移出掉

06:48.500 --> 06:54.820
这是占这么一种特点 它是一种数据结构 当然我们这个课程呢 也跟也不是数据结构的课程

06:55.140 --> 07:04.420
所以说我们这里简单了解一下就行了 其实也没啥东西 就是这么两个词 一个是入占 往里边加数据 加不占的顶部 一个是初占 占了顶部的数据呢 出去

07:05.580 --> 07:12.140
它一定不能是先移 它一定不可能是先移出数据三 再移出数据四的 一定是先移除数据四

07:12.500 --> 07:18.100
然后呢 再移出数据三 二 一 这样子移出的 入占的是一二三四 这样子入占的

07:18.660 --> 07:22.660
明白这个意思吧 好 这里边还有两个数据 一个呢 叫做占顶

07:23.900 --> 07:26.580
占的最顶部 占顶

07:28.380 --> 07:35.140
占顶 占的最顶部 我们把这个最顶边的 最顶部的数据 就是摩尾的数据呢 叫做占顶

07:35.780 --> 07:39.860
然后呢 摩尾就是最底部的数据呢 就最先加的数据呢 叫做占顶

07:40.780 --> 07:41.140
占顶

07:41.860 --> 07:49.220
好 我们有这么两个名词啊 占顶啊 占顶 好 首先了解这么一个知识啊 了解了之后呢 我们再说别的

07:50.180 --> 07:50.980
好 接下来我们再来看

07:52.900 --> 08:00.460
占是这么一种数据结构 那么执行上下文占呢 它本身是一个占 因此呢 它也是这么一种数据结构

08:00.780 --> 08:04.540
只不过它里边装的是啥呢 装的是一个一个的执行上下文

08:05.500 --> 08:11.180
这里呢 必须要先 必须要举例说明才行 啊 比方说我们这里写这么一个例子

08:15.700 --> 08:20.060
啊 这个例子里面呢 我们写一段介石代码啊 这段介石代码呢 我们这样子写

08:20.780 --> 08:23.700
嗯 有一个辩量啊 有个辩量 a

08:24.540 --> 08:30.780
等于一码 随便写啊 瞎写 这个无所谓的 写个函数 test 会有函数 a 函数 a

08:31.340 --> 08:33.900
然后呢 函数 a呢 去调用console

08:35.180 --> 08:38.220
console 调漏个啊 hello

08:40.220 --> 08:41.900
或者是输出 a嘛 a1

08:42.700 --> 08:46.700
然后呢 再输出 再一个函数 b 再一个函数 b

08:47.860 --> 08:54.140
然后呢 输出一个 b 输出一个 b 然后呢 再去调用 b 然后呢 再输出一个

08:55.620 --> 08:59.380
a2 好 接下来呢 我们再来在这里呢 输出一个

09:00.380 --> 09:01.380
global

09:02.380 --> 09:05.220
2 好 上边呢 再输出一个global 1

09:06.340 --> 09:11.620
哎 不要了啊 哎 不要了global 1 好 然后呢 去运行一下 哎 在这里运行

09:12.740 --> 09:20.620
好 接下来呢 我们来看一下 整个程序的执行过程 其实我们以前多多少少提到过啊 我们再来回顾一下 因为这一块执行过程非常重要

09:21.140 --> 09:27.820
它对于我们理解后边的执行上下文非常关键啊 我们先从一个全局的角度来理解它是怎么回事

09:28.820 --> 09:38.700
好 首先呢 我们浏览器在执行这个介石代码的时候 它虽然说是解释型语言 虽然说它一行一行执行

09:39.020 --> 09:45.820
但是呢 它一开始会大致的评论啊 评论我们的代码 好 评论过后呢 它做了这么一件事

09:46.660 --> 09:50.020
好 看着啊 这里要解释执行上下文带

09:52.020 --> 09:52.780
叫做 costec

09:53.780 --> 09:54.780
我们把它移上去啊

09:56.780 --> 09:59.780
好 这里呢 叫做 costec 执行上下文带

10:01.380 --> 10:10.560
costec 我又忘记了之前有没有讲这个东西 没关系啊 不管讲没讲 我这里反正把重新讲一遍

10:11.160 --> 10:13.560
详细的讲一遍 好 一开始呢

10:14.560 --> 10:19.360
这内存空间是空的 这内存空间哪来的 是最一开始就出手化好的啊 你可以想象成为

10:19.840 --> 10:24.320
想象为就是一开始呢 就是介石引擎了 它就创建了这么一块内存空间

10:25.320 --> 10:28.240
准备往里边下东西 准备往里边下东西

10:29.440 --> 10:38.320
好 我这里顺便说一下啊 这个占的内存空间是有限的 它不是无限的 比方说你两季内存 它不是说你一定要把两季内存占满 那不是的 可能它只有

10:39.520 --> 10:46.480
一兆或者是两兆的空间 非常非常小啊 所以占里面的空间一旦用完 它就会暂易出 就像我们之前讲那个

10:46.960 --> 10:50.120
讲那个帝规的时候 对对对 我想起来了 帝规的时候我讲过了

10:51.120 --> 10:54.520
讲帝规的时候 是不是我们说占一出 对不对 那就是这个意思啊

10:55.760 --> 10:56.960
好 然后呢 我们再看

10:58.440 --> 11:01.080
首先呢 介石代码运行之前

11:02.120 --> 11:08.520
任何介石代码运行 它都必须要有个环境啊 都必须要有个环境 我们把这个环境呢叫做上下文

11:09.080 --> 11:10.200
叫做执行上下文

11:11.000 --> 11:18.800
任何的介石代码运行都有必须要有个环境 所以说一开始呢 它看到一个看到的是一生什么看到的是全聚代码 对吧

11:19.080 --> 11:26.200
所以说它一定得有一个全聚环境 就不管你这代码怎么写 它一定得有一个全聚环境 因为我们的代码

11:26.720 --> 11:36.640
包括函数定义 对吧 调用函数 它都可能会出现在全聚代码中 所以说它必须得先有一个全聚环境 叫做全聚执行上下文

11:38.320 --> 11:42.440
全聚 我们先不管上下文那边有哪些东西啊 我们先把这个说出来

11:43.520 --> 11:44.920
全聚执行上下文

11:45.760 --> 11:50.760
指的是什么呢 所有介石代码执行之前

11:52.040 --> 11:55.000
都必须有该环境

11:56.400 --> 11:59.560
所有的介石代码执行之前都必须要有该环境 那么才能执行

12:00.200 --> 12:05.160
因为所有代码 它的歧视位置都是全聚环境

12:05.880 --> 12:10.280
因此呢 我们站一开始呢 在运行之前呢 它首先做这么一件事

12:11.240 --> 12:18.160
首先做这么一件事 往这个站里边加了一个数据 什么数据呢 就是一个执行上下文 叫做全聚

12:19.800 --> 12:24.880
执行上下文 我现在还没有说执行上下文里没有哪些东西 先别管 我们先看它的过程

12:25.720 --> 12:29.680
好 建立好这个执行上下文之后呢 干嘛呢 开始执行代码

12:30.160 --> 12:35.880
就是你要执行代码必须得先有环境 先有上下文 不然的话代码是没法执行的

12:36.360 --> 12:39.760
后边我们就知道了 为什么它得有执行上下文 它里边有哪些东西

12:41.000 --> 12:47.520
有了全聚环境过后呢 开始来执行 在执行的过程中 每一次调用函数

12:48.920 --> 12:54.800
每一次运行函数 都会创建一个新的执行上下文 叫做函数执行上下文

12:58.470 --> 13:05.830
这里呢 这里其实说的就是函数执行上下文 函数执行上下文 因为我们平时用的函数执行上下文是最多的

13:06.150 --> 13:09.910
全聚执行上下文的只有一个 函数执行上下文的可以无数多个

13:10.630 --> 13:16.430
好 于是呢 每一次运行函数 它都会创建函数执行上下文 那你看这句话是不是在运行函数

13:17.030 --> 13:21.630
是不是运行函数 那肯定是嘛 对吧 漏个马在空台里面打印 它是个函数的调用

13:22.470 --> 13:27.590
注意啊 是调用函数啊 不是说定义函数啊 是调用函数

13:28.470 --> 13:33.310
那么调用函数 对吧 那么执行全执行一个 就是新建一个上下文

13:33.990 --> 13:37.390
于是呢 又多了一个上下文了 把它加入到这个占的空间里面

13:38.110 --> 13:39.550
于是呢 这里多了一个上下文了

13:39.950 --> 13:48.470
现在全聚上下文正在执行 正在执行的过程中 执行到这 对吧 又调用函数 好 调用函数于是创建的一个新的执行上下文 叫做console

13:49.510 --> 13:49.910
console

13:51.550 --> 14:02.390
点漏个 上下文 对吧 创建这么一个上下文 好 创建好了上下文之后呢 再去执行这个函数 但是这个函数 它的怎么定义的 我们不知道啊 无所谓吧

14:03.190 --> 14:07.590
这个函数的重用是输出global1 对不对 于是呢 控制台里边输出了global

14:08.270 --> 14:17.430
1 好 这个函数是不是调用完了 调用完了怎么办呢 调用完了过后就出战 出战跑了 没了 消失了 出战

14:18.550 --> 14:24.630
好 于是呢 又回到全聚执行上下文 又回到这 又来继续执行 继续来执行

14:25.510 --> 14:30.710
执行的时候 是不是 遇到这 遇到这要不要创建环境 遇到这就代码 要不要创建环境

14:31.590 --> 14:40.750
不会 这是定义函数 定义函数 它不会创建环境的啊 只有雕用函数才会创建执行环境 没有意思吧

14:41.510 --> 14:47.910
好 于是呢 运行函数A啊 运行函数A 好 这句话 它会忽略啊 会忽略这句话

14:48.590 --> 14:57.190
好 继续运行25行 雕用函数A 这才叫雕用函数 好 雕用函数怎么办 是不是要创建一个执行上下文环境

14:57.910 --> 15:02.110
又要创建一个执行上下文环境 好什么 雕用A的环境

15:03.310 --> 15:13.470
A的环境 没问题吧 又创建了这么一个环境 好于是呢 现在的站的顶部就站顶 它的环境是什么 是这个

15:14.430 --> 15:22.510
执行上下文中始终执行的是什么 始终执行的是站顶的环境啊 这里记一笔

15:23.510 --> 15:36.110
既然是引擎 始终执行的是站顶的上下文 站顶上下文那边的东西 它始终是执行的这个

15:36.750 --> 15:44.590
没有意思吧 于是呢 也就是函数A的环境 现在在站顶部 于是呢 现在执行去执行啥 执行函数A

15:45.550 --> 15:52.310
开始执行函数A了啊 那么就跑到函数A那边去执行 好 函数A的时候来调用啥 调用一个console点log 是不是又在调用函数

15:52.710 --> 15:58.070
好 又在调用函数的时候干嘛呢 是不是又要创建一个环境 咱们把它说细一点啊

15:58.950 --> 16:03.710
又得创建一个环境 就是console点log的环境啊 就是上下文

16:05.070 --> 16:08.750
啊 我这里就不卸上 怎么上下文了啊 你们心里面清楚它是上下文就行了啊

16:09.430 --> 16:18.510
又得创建这么一个函 就是上下文 好 创建了之后呢 是不是开始执行这个函数 执行函数是啥 输出A1啊 输出A1

16:19.470 --> 16:25.830
然后呢 就执行完了 执行完了干嘛 执行完了是不是出战 函数一执行完 你马上要出战 马上要出战

16:26.710 --> 16:30.750
好 接下来我们继续看啊 继续看 然后呢 又定一个B 这里要不要创建环境

16:31.870 --> 16:38.910
要不要创建环境 不会啊 不会 他只有调用函数才会创建环境啊 这句话直接忽略 好 接下来我们看下面

16:40.550 --> 16:46.310
调用这个函数B 调用函数B的时候是要创建环境啊 创建函数B

16:47.310 --> 16:52.310
的环境 好 创建之后是不是转而去执行函数B了 函数B里边是不是输出

16:53.710 --> 16:57.470
支付创B 对吧 于是呢 是不是又创建环境 对吧 他调用函数嘛

16:57.710 --> 17:02.390
console.log 又在创建环境 看到没 他始终这样子一层一层过来的

17:03.270 --> 17:08.870
又在创建环境 好 输出B输出完了 对吧 输出完了过后这个是不是消失了啊 消毁掉了

17:09.910 --> 17:14.270
然后继续看 继续执行函数B 函数B里边还有东西吗 说没有了

17:14.670 --> 17:19.470
函数B里边啥东西都没有了 于是呢 函数B也消失啊 这个地方也消失

17:20.270 --> 17:26.910
于是呢 又回到函数A了 回到函数A过后 函数A这里调用完了 继续执行 是不是又要运行console.log 对吧

17:27.670 --> 17:30.230
于是呢 他又运行这个又创建环境

17:31.270 --> 17:38.190
console.log 又创建这个环境 好 又去输出啥啊 又去刚才刚才输出了啥 刚才输出了B 对吧

17:39.190 --> 17:46.510
然后又输出A2 对吧 输出A2 好 输出完A2过后呢 然后呢 这里的环境是不是消失了啊 消失了

17:46.910 --> 17:53.070
然后又来 又回到这里 好 回到这里过后函数A里边还有东西吗 是不是没东西了 好 没东西了过后

17:53.750 --> 17:54.950
函数A 消毁掉

17:56.750 --> 18:01.870
好 又回到了全局执行商项文 看没 它是用这种方式来执行的 好 又回到这了

18:02.470 --> 18:06.470
之前不是执行到这吗 对吧 又继续执行 好 又输出Globo2

18:07.150 --> 18:13.950
Globo2 于是呢 又创建一个环境console.log 好 输出啥 输出的是

18:15.670 --> 18:23.550
就是Globo2 当这个答案结果的 大家都知道这个结果 对吧 这个一块都知道 这个很简单

18:24.470 --> 18:29.910
好 又输出这个结果 好 输出完了之后呢 是不是这个环境又消毁了 对不对 又消毁了

18:30.910 --> 18:40.550
我们来看一下啊 它就这个环境又消毁了 好 最后呢 全局执行商项文是不是结束了 对不对 全局执行商项文结束了

18:41.270 --> 18:49.110
好 结束之后 那么这一块是不是也消失了 于是呢 整个程序执行结束 站里边没东西了 空了

18:49.790 --> 18:54.670
从一开始没东西到里边开始出现很多很多东西 然后执行执行执行 执行完了过后

18:55.190 --> 18:57.950
这个站又清空了 于是呢 执行结束了

18:59.110 --> 19:05.990
这就是一个程序的执行过程 你可以 如果这一块不了解的 不理解的话 你反复观看一下 我想的已经非常非常清楚了

19:06.590 --> 19:08.910
那么一定要把这一块理解 才能理解后边东西

19:10.110 --> 19:14.670
这是全局执行文 就是站 它里边是怎么来执行函数的

19:15.950 --> 19:20.590
好 接下来我们再来看下面这个概念 叫做执行执行文的内容

19:21.190 --> 19:28.470
它不是一块内存空间吗 对吧 它里边装了 装了一些东西 对不对 装了一些东西 好 我们接下来就要理解 它里边装的是啥东西

19:30.540 --> 19:35.980
就是执行上下文中的内容 它装了什么东西

19:36.980 --> 19:40.060
它装的东西呢 一共有两个 第一个呢

19:41.140 --> 19:48.460
叫做z 还记得这个关键字吗 z 表示啥 表示指向 对吧 指向了某一个对象 对不对

19:49.420 --> 19:56.420
z 指向 另外一个叫做vo 叫做变量对象 我们一个个说

19:57.500 --> 20:05.860
先说z 指向 我们之前说了z可以在哪里用 在函数里边使用 对吧 在函数外边使用的时候 指向的是全局上上下文

20:07.100 --> 20:11.060
函数里边使用的时候 它要根据你调用方式来定 对不对

20:12.180 --> 20:16.340
那么是谁来决定这次指向的 就是执行上下文

20:16.940 --> 20:22.260
在函数运行之前 我们从刚才这个图里边也可以看到 在函数运行之前

20:23.180 --> 20:26.180
它就会创建上下文 只有有了上下文之后

20:26.940 --> 20:34.940
你才能执行 你才能运行代码 那为什么我们的代码里边可以使用z呢 就是因为上下文里边给我们提供了z

20:36.220 --> 20:40.620
那么咱们再来看一下 再来看一下 比方说吧 就这里

20:41.860 --> 20:42.780
换一个 换一个

20:43.780 --> 20:50.380
这里我们输出z 点内 输出z 点内 这里输出的是

20:52.620 --> 20:57.340
比方说吧 我们这里创建一个A的对象 创建一个A的对象 扭一个A

20:59.500 --> 21:06.940
然后呢 这里呢 z 点 abc 等于123 我们下写啊 随便写 这个不重要 我们把这样简化一点啊

21:08.420 --> 21:10.380
好 接下来呢 我们来看一下啊 输出

21:11.260 --> 21:13.900
A的abc abc

21:14.820 --> 21:20.340
咱们来看一下整个程序的执行过程 它的内存空间是怎么变化的啊 认识指向也是怎么来确定的

21:21.380 --> 21:26.620
好 首先呢 我们看到这 看这 我再写个函数b嘛 函数b

21:29.150 --> 21:36.190
函数b 函数b里边只直接输出z 直接输出z 那么这里呢 我们调用b 调用函数b

21:37.190 --> 21:43.430
好 接下来我们看一下啊 或者函数b 写进来嘛 都行啊 怎么写 其实无所谓

21:44.230 --> 21:49.670
好 接下来我们首先看一下这个函 执行上下文站里边 它是怎么来执行的啊 整个过程是什么样子

21:50.150 --> 21:54.470
首先是不是一个全局上下文 对吧 肯定得有个全局上下文嘛 对不对

21:55.430 --> 21:59.630
全局上下文里边 是不是有得有东西 我们说上下文里边 它保存了

22:00.230 --> 22:05.390
你这一块东西 你这一块代码它执行 需要的一些信息保存到这里边

22:06.030 --> 22:12.350
其中有一个信息呢 你可以认为全局上下文就是一个对象啊 你可以认为它就是一个对象 那么比方说吧

22:12.750 --> 22:17.070
它就是一个对象 那对象的话 是不是存的是地址 对不对 那这里是不是存的地址

22:17.470 --> 22:23.430
好 地址是不是要指向一块内存空间啊 来画一下这个内存空间嘛 这是全局对象啊

22:24.190 --> 22:28.510
全局上下文对象啊 它里边是不是

22:29.950 --> 22:31.950
啊 这里边要指向指向这个内存空间

22:32.910 --> 22:36.030
好 我们来画一个箭头啊 指向这个内存空间

22:37.310 --> 22:40.350
指向这儿 给它改一下箭头的粗细和颜色

22:42.590 --> 22:48.350
每次讲公开直播课的时候讲这一块总是很着急 但是呢 现在呢就不用着急了啊 因为我们是

22:48.710 --> 22:54.990
视频课 有的是时间 好 全局上下文对象对象里边有哪些东西呢 我们刚才说了有什么有z 是对不对

22:55.390 --> 23:02.670
有z 是关键字啊 还有什么呢 还有一会我们要说的什么vo v o 呢 我们等一会再说啊 先说z 是和

23:03.150 --> 23:06.190
先说z 是啊 那么这个z 是指向谁呢

23:06.910 --> 23:10.830
这个z 是指向谁呢 这个z 是呢 他指向的 他说根据规则来

23:11.710 --> 23:18.590
啊 跟我们之前说过啊 他根据规则来啊 之前我们说过z 是呢 在全局环境里边 他指向的是什么

23:18.910 --> 23:24.670
全局对象啊 指向的是全局对象 那么在浏览器里边这个z 是指向谁呢 是不是指向温斗对象

23:24.990 --> 23:28.510
对吧 他指向的是温斗对象 他形成了这么一种结构啊

23:29.150 --> 23:37.790
我们没有办法用代码来掩饰 没有办法啊 只能通话图来大家知道啊 指向的是什么 温斗对象 当然不同的环境里边 全局对象是不一样的啊

23:38.030 --> 23:41.550
不过这里呢 肯定是温斗对象 那温斗对象里边是不是一大堆出行 对吧

23:41.950 --> 23:43.710
于是呢 他z 是指向的是温斗对象

23:44.190 --> 23:52.350
因此呢 我们在全局上下文里边能不能使用z 是不是可以使用z 在全局上下文里边使用z 是不是就是指的是温斗对象

23:52.670 --> 23:53.710
对吧 为什么 因为

23:54.350 --> 23:57.710
直行上下文里边 他有一个z 是指向的就是温的对象

23:58.270 --> 24:04.990
不要这意思吧 当然我们花图呢 也有的时候呢也可以简化 他真实的图形是这样子啊 这里是对子

24:05.310 --> 24:10.990
地就粘里边 直行粘里边存的是地址 这些对象呢 都在另外的内存空间里边

24:11.310 --> 24:16.030
其实呢 我们这里也顺便说一下吧 这里的就是不在粘里边的内存空间

24:16.750 --> 24:22.510
就是内存空间不在粘里边 不在直行粘里边 就是在其他部分的内存空间 一般都是对象

24:22.830 --> 24:25.230
一般都是对象 那么这一块空间呢 叫做对

24:25.870 --> 24:26.670
它叫做对

24:27.950 --> 24:29.550
顺便说一下啊 了解就行了

24:30.350 --> 24:30.830
叫做对

24:31.710 --> 24:32.190
叫做hip

24:32.510 --> 24:34.110
粘了的粘了单词的叫做stack

24:34.350 --> 24:36.030
对的空间呢 叫做hip

24:38.510 --> 24:39.150
不要这意思吧

24:40.110 --> 24:44.190
在对上面 这些对象实际上实际上是在对上面 这里只是存了一个地址

24:44.670 --> 24:45.710
只是存了一个地址

24:46.510 --> 24:47.390
是这么个意思啊

24:47.710 --> 24:52.510
但是呢 有的时候呢 为了画的方便 我们也可以把这个东西呢 画到这

24:53.630 --> 24:56.270
也可以画到这 实际上不在这啊 实际上不在粘里边

24:56.670 --> 24:57.630
粘里边只有个地址

24:58.110 --> 24:59.150
是这么个意思啊

24:59.630 --> 25:02.110
我们可以把可以认为它在这 可以认为它在这

25:03.630 --> 25:05.550
好 接下来啊 咱们来看一下啊

25:06.190 --> 25:08.910
Z是它指向这 对吧 Z是它指向温度对象

25:09.950 --> 25:10.590
没问题吧

25:10.830 --> 25:12.430
啊 是这么个意思啊

25:13.630 --> 25:15.710
好 接下来呢 我们再来看啊 再来看

25:16.190 --> 25:19.790
好 VU 我们先暂时不画了啊 暂时不画 VU

25:20.030 --> 25:21.070
我们只画一个Z

25:21.550 --> 25:24.190
它指向这 于是呢 在全局环境里边

25:24.910 --> 25:27.310
全局代码里边Z它用的就是温度

25:28.190 --> 25:29.230
好 接下来我们再来看

25:29.710 --> 25:32.350
于是呢 它开始执行函数了对吧 这个函数呢

25:32.510 --> 25:34.110
我们不说了啊 不说了这个函数

25:34.110 --> 25:36.990
这个Z是不是在全局环境里边 对吧 全局环境里边

25:36.990 --> 25:37.950
所以说它指向温度

25:38.430 --> 25:39.070
好 然后呢

25:39.470 --> 25:41.870
这个代码的结 就是结果大家肯定知道啊

25:41.870 --> 25:44.030
我们以前讲过的 我们主要说说它的过程

25:44.510 --> 25:46.030
好 接下来呢 我们

25:46.030 --> 25:48.670
是不是在运行函数 对吧 在运行函数

25:48.910 --> 25:50.990
运行函数是不是要创建空间

25:52.110 --> 25:53.950
要创建什么上下纹

25:54.430 --> 25:57.870
什么上下纹 现在是A的 函数A的上下纹

25:59.310 --> 25:59.870
函数

26:00.830 --> 26:02.590
函数A的上下纹

26:03.630 --> 26:05.790
好 那么创建A的上下纹的时候

26:05.790 --> 26:07.390
它就必须要确定Z是指向

26:07.950 --> 26:10.030
也就是说Z它是什么时候确定的

26:10.350 --> 26:13.630
它是指的是雕用函数的时候确定的

26:14.350 --> 26:16.110
你没有一雕用函数之前

26:16.110 --> 26:17.790
都是无法确定Z是指向的

26:18.350 --> 26:21.150
它是雕用函数的时候确定的Z是指向

26:21.630 --> 26:24.030
于是呢 这里在雕用函数A 对不对

26:24.030 --> 26:25.150
虽然是用六关键字嘛

26:25.150 --> 26:26.990
但是也是在雕用函数A嘛

26:26.990 --> 26:27.950
它要运行函数嘛

26:28.190 --> 26:30.670
于是呢 它必须要创建函数的直行上下纹

26:30.990 --> 26:32.590
那么创建直行上下纹的时候呢

26:32.590 --> 26:33.710
它要做很多事情

26:33.950 --> 26:36.110
它第一件事情就是要确定Z是指向

26:36.510 --> 26:37.310
Z是指向谁

26:37.870 --> 26:40.110
好 那么这里根据我们以前学过的规则

26:40.110 --> 26:42.030
Z的指向一共有三种 对吧

26:42.350 --> 26:42.910
一共有三种

26:42.910 --> 26:44.350
就是如果你不去改动它的话

26:44.350 --> 26:46.110
它的Z是指向 一共有三种

26:46.350 --> 26:47.790
哪三种呢 我们再来复习一下吧

26:48.270 --> 26:51.230
Z就是直接雕用函数

26:53.070 --> 26:54.190
Z是指向谁

26:54.430 --> 26:55.870
指向全局对象

26:56.430 --> 26:57.310
指向全局对象

26:57.630 --> 26:58.750
第二种情况呢是

26:59.310 --> 27:00.110
第二种情况是

27:02.270 --> 27:03.310
在全局

27:06.590 --> 27:07.550
在函数外

27:07.950 --> 27:09.950
在函数外雕用

27:10.430 --> 27:11.070
使用Z

27:11.150 --> 27:12.030
在函数外的话

27:12.030 --> 27:14.110
Z是指向全局对象

27:14.670 --> 27:16.190
都是我们以前说过的 对吧

27:16.510 --> 27:17.150
以前呢

27:17.310 --> 27:18.990
在函数外使用Z

27:18.990 --> 27:20.510
它走指向的是全局对象

27:20.990 --> 27:21.950
好 还有一种是什么呢

27:21.950 --> 27:23.230
就是通过对象雕用

27:24.190 --> 27:28.830
通过对象雕用函数

27:29.150 --> 27:30.990
通过对象雕用

27:31.550 --> 27:33.070
或什么 或6

27:33.390 --> 27:34.430
6一个函数

27:34.910 --> 27:37.150
就是使用构造函数的那种方式来雕用

27:37.550 --> 27:38.590
那么这个时候呢

27:38.910 --> 27:40.190
指向 Z是指向谁

27:40.430 --> 27:44.750
Z是指向雕用的对象

27:44.910 --> 27:46.990
或什么 新对象

27:48.430 --> 27:48.990
新对象

27:48.990 --> 27:50.750
你6的时候是不是要产生一个新对象

27:50.750 --> 27:50.990
对吧

27:50.990 --> 27:52.510
它指向的是一个新对象

27:52.750 --> 27:53.710
是这么个意思

27:54.430 --> 27:55.630
好 那么我们看这里

27:55.870 --> 27:57.230
这里呢是使用在什么

27:57.230 --> 27:59.230
使用6的方式来雕用函数 对不对

27:59.230 --> 28:00.030
所以说呢

28:00.030 --> 28:02.430
它的Z是指向谁

28:02.830 --> 28:03.550
指向谁

28:03.710 --> 28:04.990
是不是指向一个新对象

28:04.990 --> 28:06.750
对吧 你还产生一个新对象嘛

28:07.710 --> 28:08.830
一个新对象

28:08.830 --> 28:10.190
这个Z是它会指向这

28:11.470 --> 28:12.670
Z是会指向这

28:12.670 --> 28:13.390
于是呢

28:13.390 --> 28:15.870
总之函数的执行上下文里边

28:15.870 --> 28:18.350
它首先必须要确定Z是指向

28:18.350 --> 28:20.350
因为一会函数就要运行了

28:20.350 --> 28:21.550
函数在运行的过程中

28:21.550 --> 28:22.830
它可能会用到Z

28:22.830 --> 28:24.350
你不确定Z是指向的话

28:24.350 --> 28:25.150
它倒是Z

28:25.150 --> 28:25.790
它指向谁呢

28:25.790 --> 28:26.990
它是Z表示谁呢

28:26.990 --> 28:27.950
它就不知道了 对吧

28:27.950 --> 28:29.550
所以说在运行之前

28:29.550 --> 28:30.670
你看我们之前说

28:31.150 --> 28:32.910
这个执行上下文呢

28:32.910 --> 28:36.350
是为函数的执行提供支持 对吧

28:36.430 --> 28:38.510
函数的执行它可能需要用到Z

28:38.510 --> 28:40.750
所以说你必须要先确定Z的指向

28:40.750 --> 28:41.870
它指向一个新对象

28:42.590 --> 28:44.190
那么Z的指向具体怎么指呢

28:44.190 --> 28:45.150
我们以前说过了 对吧

28:45.150 --> 28:46.430
就这么几种情况

28:47.630 --> 28:48.990
好 这是这一块

28:50.270 --> 28:51.390
好 接下来呢

28:51.870 --> 28:54.030
我们就往Z现在指向新对象了 对吧

28:54.030 --> 28:56.510
往新对象里边加一个ABC等于123

28:56.510 --> 28:58.670
于是呢内存里边它就变成这样子了

28:58.670 --> 29:00.590
它里边一个属性ABC

29:00.590 --> 29:03.230
ABC只是123 对吧

29:03.230 --> 29:04.830
还得到这么一个属性值

29:05.630 --> 29:09.070
然后呢继续又创建一个函数B对吧

29:09.070 --> 29:10.110
创建函数无所谓

29:10.110 --> 29:11.310
但是没有调用就无所谓

29:12.030 --> 29:13.950
然后呢又运行调用B

29:14.510 --> 29:16.190
是不是又要产生一个新的上下文

29:17.150 --> 29:18.590
又产生了一个上下文

29:18.590 --> 29:20.030
就是函数B的上下文

29:20.030 --> 29:21.950
那么这里是不是又要确定Z是指向

29:21.950 --> 29:24.110
也要确定完了过后才能运行函数

29:25.470 --> 29:27.150
好 这个Z是指向指向谁

29:27.150 --> 29:28.670
根据我们之前的规则

29:28.670 --> 29:30.430
直接调用函数Z是指向谁

29:31.470 --> 29:33.470
指向的是全具对象温斗

29:33.550 --> 29:35.950
于是呢它这个Z是指向的是谁

29:36.510 --> 29:37.630
指向的是温的对象

29:38.190 --> 29:39.230
又指向的是这个

29:39.230 --> 29:39.710
看没

29:40.510 --> 29:41.470
没问题吧

29:41.470 --> 29:44.110
这才是它的程序的执行过程

29:45.070 --> 29:46.910
于是呢函数B执行完了对吧

29:46.910 --> 29:47.950
函数B执行完了

29:47.950 --> 29:48.990
是输出Z吧对吧

29:48.990 --> 29:49.630
输出Z

29:49.630 --> 29:52.110
输出完了过后函数B是不是运行结束了

29:52.110 --> 29:54.350
运行结束是不是上下文销毁

29:54.350 --> 29:54.750
对吧

29:54.750 --> 29:56.110
销毁这个指向肯定没了

29:56.110 --> 29:56.510
对吧

29:56.510 --> 29:57.310
就指向肯定没了

29:57.310 --> 29:57.870
销毁掉了

29:58.510 --> 29:58.990
没问题吧

30:00.030 --> 30:02.590
然后呢又回到这个函数A带执行

30:02.670 --> 30:04.350
函数A是不是也没了对吧

30:04.350 --> 30:06.270
执行完函数B函数A也没了

30:06.270 --> 30:08.270
好函数A呢又销毁掉

30:08.270 --> 30:09.150
又销毁掉

30:09.790 --> 30:10.830
好这里呢

30:10.830 --> 30:12.430
函数A又销毁掉

30:12.430 --> 30:14.350
但它这个函数呢会有一个返回结果

30:15.230 --> 30:16.110
会有一个返回结果

30:16.110 --> 30:16.750
返回谁

30:16.750 --> 30:18.030
返回这个新对象

30:18.030 --> 30:20.190
然后把这个新对象复制给谁

30:20.190 --> 30:21.390
复制给变量A

30:21.390 --> 30:22.430
于是变量A里边

30:23.150 --> 30:23.630
也有这个

30:24.270 --> 30:25.150
指向这个新对象了

30:25.150 --> 30:26.670
我这里就没有画变量A了

30:26.670 --> 30:27.630
现在还画不了

30:27.630 --> 30:28.750
以后呢我们就可以画了

30:29.550 --> 30:30.670
就可以画这个变量A了

30:30.670 --> 30:32.430
那么变量A了指向这个新对象

30:32.510 --> 30:34.190
然后最后输出新对象里边ABC

30:34.190 --> 30:34.670
输出啥

30:34.670 --> 30:35.630
输出于是123

30:36.750 --> 30:39.470
我通过这么说的罗利巴说了半天

30:39.470 --> 30:40.190
目的是啥

30:40.190 --> 30:41.790
目的是要让你理解

30:41.790 --> 30:43.310
执行上下文里边

30:43.310 --> 30:45.790
它一定要先确定Z的指向

30:46.510 --> 30:47.310
确定了之后

30:47.310 --> 30:48.430
后边再说运行函数

30:49.870 --> 30:50.830
Z指向都没有确定

30:50.830 --> 30:52.270
它是没法运行函数的

30:52.270 --> 30:53.550
所以说这就是为什么说

30:53.550 --> 30:55.790
执行上下文为函数的执行

30:55.790 --> 30:56.670
提供支持

30:56.670 --> 30:57.310
就是这个意思

30:58.670 --> 30:59.710
这是Z指向

30:59.710 --> 31:00.670
Z指向我明显讲过

31:00.670 --> 31:01.710
所以说这个不是重点

31:02.510 --> 31:03.390
重点是下边这个

31:04.350 --> 31:04.830
VO

31:05.550 --> 31:07.390
它叫做变量对象

31:07.390 --> 31:08.110
它又是个对象

31:09.070 --> 31:10.430
执行上下文里边

31:10.430 --> 31:12.830
除了有个Z指向之外呢

31:12.830 --> 31:13.870
它还有一个VO

31:14.590 --> 31:15.710
还有这么一个东西VO

31:16.670 --> 31:18.270
好这个VO是什么东西呢

31:18.270 --> 31:20.190
它的全称叫做Varable

31:21.710 --> 31:22.190
Var

31:22.190 --> 31:23.230
我们平时用var对吧

31:23.230 --> 31:25.150
var就是一个变量的锁写对吧

31:25.150 --> 31:25.870
Varable

31:27.790 --> 31:28.350
Object

31:29.150 --> 31:30.830
它是这个两个单词的锁写

31:30.910 --> 31:32.830
叫做变量对象

31:32.830 --> 31:33.950
叫做变量对象

31:33.950 --> 31:34.830
称之为VO

31:36.190 --> 31:37.630
VO里边它记录了什么呢

31:38.350 --> 31:40.830
VO中记录了

31:42.030 --> 31:43.710
该环境中

31:44.830 --> 31:48.030
该环境中会用

31:48.030 --> 31:49.070
就是所有

31:50.110 --> 31:54.910
声明的变量和函数

31:55.870 --> 32:00.830
声明的参数变量和函数

32:01.550 --> 32:03.070
也就是一个VO里边

32:03.070 --> 32:05.310
它要包含三个东西

32:06.590 --> 32:08.270
一个是参数

32:08.270 --> 32:09.710
一个是变量

32:09.710 --> 32:10.830
一个是函数

32:11.710 --> 32:12.910
一个参数

32:12.910 --> 32:13.470
一个变量

32:13.470 --> 32:14.030
一个函数

32:14.990 --> 32:16.510
它有这么三个东西

32:16.510 --> 32:17.470
有这么三个东西

32:18.350 --> 32:20.190
好咱们挨着挨着来说

32:20.510 --> 32:21.310
挨着来说

32:23.070 --> 32:25.310
首先我们再看一下

32:26.350 --> 32:27.390
再看一下刚才这种情况

32:28.270 --> 32:30.190
刚才的情况是我们要确定Z

32:30.190 --> 32:32.430
Z是现在不讲了

32:32.430 --> 32:33.950
我们现在换另外一个

32:33.950 --> 32:35.550
因为Z是我们刚才已经讲过了

32:35.550 --> 32:37.790
所以说免得图刷得越来越复杂

32:37.790 --> 32:39.470
所以我们就集中精力看另外一个

32:39.470 --> 32:40.030
就是VO

32:42.030 --> 32:42.990
这个VO指向谁

32:44.430 --> 32:45.150
权局

32:45.150 --> 32:46.350
首先是权局环境

32:46.830 --> 32:48.350
首先是权局环境

32:48.430 --> 32:49.950
权局环境里边

32:49.950 --> 32:51.070
VO它指向谁呢

32:52.030 --> 32:52.830
指向一个对象

32:52.830 --> 32:54.350
因为我刚才说了VO是一个对象

32:54.350 --> 32:54.910
对吧

32:54.910 --> 32:56.110
VO是一个对象

32:56.110 --> 32:57.390
所以说权局环境里边

32:57.390 --> 32:59.710
它的VO它仍然指向的是一个对象

33:00.350 --> 33:01.470
指向的是一个对象

33:01.470 --> 33:03.790
好这个对象里边是不是有三个东西

33:03.790 --> 33:04.110
对吧

33:04.110 --> 33:05.390
我们刚才说了有三个东西

33:06.030 --> 33:07.230
其实还不止三个

33:07.230 --> 33:08.350
我们都把话说

33:08.350 --> 33:09.390
还有一些细致末节的

33:09.390 --> 33:10.510
我们就一起说一下吧

33:11.310 --> 33:13.150
比方说它有哪些东西呢

33:14.670 --> 33:15.870
权局环境里边

33:15.950 --> 33:18.190
我们这里有什么参数

33:18.190 --> 33:18.430
对吧

33:18.430 --> 33:19.790
但是权局环境它不是函数

33:19.790 --> 33:20.350
对不对

33:20.350 --> 33:20.990
不是函数

33:20.990 --> 33:21.790
它没有参数

33:21.790 --> 33:22.750
它没有参数

33:22.750 --> 33:23.950
那它有啥呢

33:23.950 --> 33:26.030
有生命的变量

33:26.750 --> 33:27.550
生命的变量

33:29.150 --> 33:30.030
和什么呢

33:30.030 --> 33:31.630
和生命的函数

33:31.630 --> 33:33.070
我们现在还没有具体说

33:33.070 --> 33:34.110
还没有具体说

33:34.110 --> 33:34.910
这个生命的变量

33:34.910 --> 33:35.630
生命的函数

33:35.630 --> 33:36.590
在这个对象里边

33:36.590 --> 33:37.790
是一个什么样的属性

33:37.790 --> 33:38.750
但它一定有

33:38.750 --> 33:39.390
它一定有

33:40.030 --> 33:41.630
那么在权局对象里边

33:41.630 --> 33:42.350
它的VO

33:42.350 --> 33:43.550
它生命的变量

33:43.550 --> 33:45.310
生命的函数是哪些呢

33:45.310 --> 33:47.550
就是除了用户生命的东西之外

33:47.550 --> 33:49.550
还有就是权局对象里边的

33:49.550 --> 33:50.750
所有属性

33:50.750 --> 33:52.190
都算是VO里边的东西

33:52.990 --> 33:54.350
是这么个意思

33:54.350 --> 33:55.470
权局对象里边

33:55.470 --> 33:56.750
所有的属性

33:56.750 --> 33:58.350
都算是VO里边的东西

33:59.070 --> 34:00.270
比方说温斗对象

34:00.270 --> 34:01.470
温斗是不是权局对象

34:01.470 --> 34:02.270
对不对

34:02.270 --> 34:04.270
权局对象里边的所有的属性

34:04.830 --> 34:07.550
它都算做是VO里边的东西

34:07.550 --> 34:08.430
你可以认为

34:08.430 --> 34:09.790
权局环境里边

34:09.790 --> 34:10.910
在浏览器环境下面

34:11.550 --> 34:12.190
你可以认为

34:12.190 --> 34:13.950
权局环境里边的VO

34:14.030 --> 34:15.390
跟这个ZS一样

34:15.390 --> 34:17.150
你可以认为跟ZS一样

34:17.150 --> 34:19.550
它指向的也是温斗对象

34:19.550 --> 34:21.150
这是权局环境比较特殊

34:21.150 --> 34:23.150
还没有说到函数

34:23.150 --> 34:24.750
权局环境比较特殊

34:24.750 --> 34:25.550
它的VO

34:25.550 --> 34:26.590
你可以认为

34:26.590 --> 34:28.270
它指向的也是温斗对象

34:28.270 --> 34:29.870
所以它就形成了这么一种结构了

34:29.870 --> 34:31.630
它有个VO 一个ZS对吧

34:31.630 --> 34:33.230
VO指向这一块

34:33.230 --> 34:35.230
VO指向的是这一块

34:36.750 --> 34:38.830
ZS指向的也是一块

34:38.830 --> 34:40.830
它都是指向的是温的对象

34:40.830 --> 34:41.870
你可以这样认为

34:41.870 --> 34:43.710
可以这样子认为

34:44.430 --> 34:46.030
为什么说这样子

34:46.030 --> 34:46.510
一看

34:47.550 --> 34:48.670
我们说VO里边

34:48.670 --> 34:49.070
记录了

34:49.070 --> 34:50.910
该环境中所有生命的参数

34:50.910 --> 34:52.350
变量和函数

34:52.350 --> 34:53.630
温斗里边的所有属性

34:53.630 --> 34:55.070
是不是可以直接使用的

34:55.070 --> 34:55.390
对不对

34:55.390 --> 34:56.030
可以直接使用

34:56.030 --> 34:57.150
为什么可以直接使用

34:57.150 --> 34:58.510
因为它在VO里边

34:59.390 --> 35:01.310
当执行一个函数也好

35:01.310 --> 35:03.390
执行一个权局代码的也好

35:03.390 --> 35:05.150
它能够直接使用某个东西

35:05.150 --> 35:06.030
那一定是在

35:07.310 --> 35:09.230
执行上下文里边能找到

35:09.230 --> 35:11.070
如果找不到是不能执行的

35:11.070 --> 35:12.110
找不到是不能执行的

35:12.110 --> 35:12.910
它在哪里去找

35:12.990 --> 35:14.110
它在VO里边去找

35:15.310 --> 35:16.430
就这个ZS没关系

35:16.430 --> 35:18.110
它在VO里边去找

35:18.110 --> 35:19.470
比方说我们在

35:19.470 --> 35:20.510
我们使用代码

35:20.510 --> 35:21.630
用最常见的代码对吧

35:21.630 --> 35:22.270
console

35:23.150 --> 35:25.470
我们为什么能够直接使用这个对象

35:25.470 --> 35:26.670
为什么能够直接使用

35:26.670 --> 35:29.310
因为在这个权局环境里边VO

35:30.110 --> 35:32.590
VO里边是不是直接指向这个温斗了

35:32.590 --> 35:32.990
对不对

35:33.710 --> 35:36.670
因此VO它里边有这个东西

35:36.670 --> 35:37.870
有这个属性

35:37.870 --> 35:39.070
VO里边有这个属性

35:39.630 --> 35:40.590
有这个console

35:40.590 --> 35:41.070
这个属性

35:41.070 --> 35:41.710
我们来看一下吧

35:45.410 --> 35:46.770
权局环境比较特殊一点

35:46.770 --> 35:47.890
我先把权局环境说了

35:50.130 --> 35:51.970
温斗就是VO指向了这

35:51.970 --> 35:53.730
这里边是不是一个console

35:53.730 --> 35:54.210
对吧

35:54.210 --> 35:55.410
它是有这个属性的

35:56.050 --> 35:59.010
所以说才能够在这里直接使用

35:59.010 --> 36:00.290
是因为它在权局

36:00.290 --> 36:01.570
它在这个VO里边

36:01.570 --> 36:01.970
对吧

36:01.970 --> 36:02.610
VO里边

36:03.410 --> 36:04.050
你要这个意思吧

36:04.770 --> 36:05.650
能不能明白这个意思

36:06.610 --> 36:08.370
那如果你自己定义一个变量呢

36:09.010 --> 36:10.290
我们之前说过

36:10.290 --> 36:13.170
定义的变量是不是也会附着在

36:13.170 --> 36:14.450
权局对象里边

36:14.530 --> 36:14.930
对吧

36:14.930 --> 36:17.090
通过挖关键制来定义的变量

36:17.090 --> 36:17.810
声明的变量

36:17.810 --> 36:21.170
是不是也会附着在权局对象里边

36:21.170 --> 36:21.730
对不对

36:21.730 --> 36:22.370
所以说

36:22.370 --> 36:23.810
那么你这样子写了过后

36:23.810 --> 36:25.810
VO里边是不是多了一个属性了

36:25.810 --> 36:27.890
相当于是往VO里边添加了一个属性

36:27.890 --> 36:28.370
对吧

36:28.370 --> 36:29.090
加了一个属性

36:29.090 --> 36:31.570
那这里边是不是也有这个变量A了

36:31.570 --> 36:32.930
所以说也可以直接使用

36:34.210 --> 36:34.690
再说一次

36:35.250 --> 36:37.330
我们之所以在权局环境里边

36:37.330 --> 36:38.930
能够使用这些东西

36:38.930 --> 36:41.330
是因为它们的VO

36:42.290 --> 36:43.410
这个执行环境

36:43.410 --> 36:44.450
执行上下文

36:44.450 --> 36:45.890
它指向了温度对象

36:45.890 --> 36:48.050
所以说我们才能直接使用温度对象里面的东西

36:48.050 --> 36:50.210
那假设有一天我们改了

36:50.210 --> 36:51.490
把这个VO指向别的了

36:51.490 --> 36:51.970
那对不起

36:51.970 --> 36:54.050
温度对象里边所有东西不能直接使用

36:55.010 --> 36:56.850
是因为这个原因它才能直接使用

36:57.490 --> 36:58.290
是这么个原因

36:59.250 --> 37:00.610
这是权局环境

37:00.610 --> 37:02.050
权局环境它比较特殊

37:02.050 --> 37:03.650
它里边没有什么参数

37:03.650 --> 37:04.610
那种东西

37:04.610 --> 37:05.170
所以说

37:05.170 --> 37:06.450
权局环境

37:06.450 --> 37:08.050
我们有的时候

37:08.050 --> 37:10.930
也把这个VO给它取一个特别的名字

37:11.570 --> 37:12.290
叫做

37:12.850 --> 37:13.650
叫做什么呢

37:13.650 --> 37:14.850
叫做GO

37:14.850 --> 37:18.450
它的全称叫做Global Objects

37:20.130 --> 37:21.010
GO是什么意思

37:21.010 --> 37:27.170
就是权局执行上下文中的VO

37:27.170 --> 37:28.050
VO

37:28.050 --> 37:29.250
实际上是一个东西

37:29.250 --> 37:30.610
只是说法变了一下

37:30.610 --> 37:31.490
就是有的时候

37:31.490 --> 37:32.850
我们为了特别处理

37:32.850 --> 37:35.090
所以说把这个VO叫做GO

37:35.090 --> 37:35.890
GO

37:36.850 --> 37:37.250
好

37:37.250 --> 37:38.450
接下来权局环境建立好了

37:38.450 --> 37:38.850
对吧

37:38.850 --> 37:40.290
接下来我们来运行啥

37:41.330 --> 37:42.370
运行的是

37:42.370 --> 37:43.490
这些东西不说了

37:43.490 --> 37:44.610
这些东西不说了

37:45.890 --> 37:47.810
我们来运行这个函数A

37:47.810 --> 37:49.410
函数A

37:49.410 --> 37:49.730
好

37:49.730 --> 37:51.490
运行函数A的时候

37:51.490 --> 37:53.170
我们来终点讲一下

37:53.170 --> 37:54.850
这里边会发生哪些事

37:55.730 --> 37:57.170
我们这里新建一个页面

37:58.370 --> 37:59.250
这才是重点

37:59.250 --> 38:00.290
我们重点要讲

38:00.290 --> 38:01.970
运行函数的时候

38:01.970 --> 38:03.410
它的上下文里边

38:03.410 --> 38:04.850
会创建哪些东西

38:08.800 --> 38:09.920
比方说这里一个函数

38:10.720 --> 38:11.440
函数A

38:11.920 --> 38:14.960
GO里边没有定义型的东西

38:14.960 --> 38:16.560
它就只想温德就完事了

38:16.560 --> 38:17.120
好

38:17.120 --> 38:18.880
A里边我们这样子写

38:20.640 --> 38:21.440
有一个参数

38:22.320 --> 38:23.120
A B

38:24.080 --> 38:24.800
两个参数

38:25.520 --> 38:28.000
然后我们这里里边一个变量

38:28.000 --> 38:31.040
变量的名字也叫做C

38:31.040 --> 38:31.680
叫做C

38:33.040 --> 38:34.240
C等于1 2 3

38:34.240 --> 38:36.560
咱们输出A B C

38:37.600 --> 38:38.400
A D C

38:39.760 --> 38:41.200
在前边又输出

38:41.600 --> 38:42.160
A B C

38:44.750 --> 38:45.310
A B C

38:46.030 --> 38:46.190
好

38:46.190 --> 38:47.390
重点是讲这个过程

38:48.350 --> 38:48.510
好

38:48.510 --> 38:49.870
这里能我们调用函数

38:49.870 --> 38:51.070
传一个1和2进去

38:51.870 --> 38:52.510
好吧

38:52.510 --> 38:53.470
接下来我们来看一下

38:53.470 --> 38:54.510
它是怎么执行的

38:54.510 --> 38:55.230
当代码

38:55.230 --> 38:58.270
当全局环境的代码执行到第19行的时候

38:58.910 --> 38:59.390
干嘛呢

39:00.590 --> 39:01.310
它要干嘛呢

39:01.870 --> 39:02.750
它是这样子处理

39:04.110 --> 39:05.630
创建一个执行上下文

39:05.630 --> 39:06.750
谁在执行上下文

39:06.750 --> 39:08.110
函数A的执行上下文

39:09.230 --> 39:10.910
这个执行上下文里边是不是有历史

39:10.910 --> 39:11.230
对吧

39:11.230 --> 39:12.350
先确定历史指向

39:12.350 --> 39:12.990
我们之前说过了

39:13.550 --> 39:14.830
历史指向谁呢

39:14.830 --> 39:16.030
它是直接调用的

39:16.030 --> 39:18.430
因此它的历史它也指向文德

39:18.430 --> 39:20.030
所以历史指向很简单

39:20.030 --> 39:21.390
这个我后面就不画了

39:21.390 --> 39:21.950
历史指向

39:22.670 --> 39:23.710
主要是这个G O

39:24.350 --> 39:24.670
好

39:24.670 --> 39:26.190
G O是不是要指向一个函数

39:26.590 --> 39:26.910
对吧

39:28.190 --> 39:29.470
G O是不是要指向一个对象

39:29.470 --> 39:29.790
对不对

39:30.830 --> 39:32.510
那么我们现在讨论的是

39:32.510 --> 39:34.510
一个函数指向上下文

39:34.510 --> 39:35.630
G O这个对象里边

39:35.630 --> 39:36.830
它装了哪些东西

39:38.350 --> 39:39.630
我们一步一步说

39:40.590 --> 39:40.750
好

39:40.750 --> 39:41.630
装了哪些东西呢

39:41.710 --> 39:43.070
我们把这个这样子对齐

39:43.470 --> 39:44.190
左边对齐

39:44.510 --> 39:45.150
顶端对齐

39:45.870 --> 39:46.510
G O里边

39:46.990 --> 39:47.790
这是一个对象

39:47.790 --> 39:48.510
G O是个对象

39:48.510 --> 39:49.790
对象里面是有很多属性的

39:50.270 --> 39:51.070
我们一个个说

39:51.710 --> 39:53.230
G O里边它先做这么一件事

39:53.710 --> 39:55.150
它会经过这么三步

39:56.430 --> 39:56.910
第一步

39:59.250 --> 40:03.170
确定所有刑餐

40:04.210 --> 40:05.010
刑餐职

40:05.970 --> 40:07.250
确定所有的刑餐

40:07.250 --> 40:08.050
刑餐职

40:08.050 --> 40:09.170
我们以前讲函数的时候

40:09.170 --> 40:10.450
讲过刑餐对吧

40:10.450 --> 40:11.090
刑餐是什么

40:11.090 --> 40:12.610
就是函数生命的时候

40:12.850 --> 40:14.290
就是函数定义的时候

40:14.290 --> 40:16.530
它的参数就是A和B对吧

40:16.530 --> 40:17.970
确定这两个的职

40:17.970 --> 40:19.010
确定刑餐职

40:19.970 --> 40:20.770
然后呢

40:20.770 --> 40:21.490
我们看一下

40:21.490 --> 40:23.570
那这里边刑餐是不是有职了

40:23.570 --> 40:24.290
A等于多少

40:24.850 --> 40:25.570
A等于多少

40:26.770 --> 40:27.490
刑餐

40:27.490 --> 40:28.370
A是不是等于1

40:28.370 --> 40:29.010
B等于2

40:29.010 --> 40:29.890
对不对

40:29.890 --> 40:31.650
刑餐有职了

40:31.650 --> 40:32.530
A等于1

40:33.170 --> 40:34.370
B等于2

40:35.650 --> 40:36.290
放大一点吧

40:36.930 --> 40:37.890
刑餐有职了嘛

40:37.890 --> 40:38.290
对不对

40:39.650 --> 40:40.690
先做这么一件事

40:40.690 --> 40:41.810
还要确定啥呢

40:41.890 --> 40:43.730
当然还要确定一些特殊变量

40:44.530 --> 40:47.170
以及特殊变量

40:47.730 --> 40:48.610
argument

40:49.570 --> 40:50.850
argument对吧

40:50.850 --> 40:52.450
我们在函数里面是不是可以用这个

40:52.450 --> 40:53.810
用这个特殊的变量

40:53.810 --> 40:55.490
尽管我们很少用对不对

40:55.490 --> 40:56.610
但是可不可以用

40:56.610 --> 40:58.130
这个也可以用对吧

40:58.130 --> 40:59.730
要确定这个argument的职

41:00.370 --> 41:01.730
所以说最开始呢

41:02.290 --> 41:03.250
确定了这两个东西

41:04.530 --> 41:05.170
argument

41:06.370 --> 41:07.250
确定到这些属性

41:07.250 --> 41:08.770
这个属性我就不写了

41:08.770 --> 41:10.210
它是一个伪数组对吧

41:10.210 --> 41:11.570
我们之前讲见过

41:12.290 --> 41:13.730
第一步确定这么一个东西

41:13.730 --> 41:15.250
也就是说我们在函数里面

41:15.250 --> 41:17.010
为什么可以直接使用A

41:17.010 --> 41:17.970
直接使用B

41:17.970 --> 41:19.250
就好像是一个变量一样

41:19.250 --> 41:20.210
可以直接使用

41:20.210 --> 41:23.330
是因为它在VO里面

41:23.330 --> 41:24.930
一个函数的变量对象里面

41:25.490 --> 41:26.930
我们执行代码的时候

41:26.930 --> 41:28.370
我们当我们遇到一个东西的时候

41:28.370 --> 41:29.490
它要找的时候呢

41:29.490 --> 41:31.170
它直接从VO里面去找

41:31.170 --> 41:32.370
你使用A可以啊

41:32.370 --> 41:33.410
你看我们这里输出A

41:33.970 --> 41:34.690
可以使用A啊

41:34.690 --> 41:36.130
因为为什么可以使用A

41:36.130 --> 41:37.570
因为A在VO里面

41:38.050 --> 41:38.690
你懂我的意思吧

41:40.450 --> 41:40.770
好

41:40.770 --> 41:41.410
接下来继续

41:42.770 --> 41:44.450
接下来第二步做啥呢

41:45.890 --> 41:46.370
第二步

41:47.810 --> 41:48.450
第一步完了

41:48.450 --> 41:49.330
完了过后

41:49.330 --> 41:50.690
这些讲的所有的步骤

41:50.690 --> 41:53.250
都是确定变量对象用的

41:54.130 --> 41:57.410
第二步确定函数中

41:58.370 --> 42:02.850
所有的所有的所有声明的

42:04.850 --> 42:08.050
通过VO声明的变量

42:09.010 --> 42:13.330
将它们的值

42:14.530 --> 42:16.370
设置为undefend

42:17.330 --> 42:18.450
这是这一步要做的事

42:19.170 --> 42:20.050
确定函数中

42:20.050 --> 42:21.250
反而是你看到一个VO

42:21.250 --> 42:22.130
声明的变量

42:22.130 --> 42:24.050
把它们的值设置为undefend

42:24.850 --> 42:25.650
是这么个意思

42:26.290 --> 42:26.530
好

42:26.530 --> 42:27.250
那么这里呢

42:27.250 --> 42:28.690
你看是不是这个函数的

42:29.170 --> 42:30.050
它少一眼

42:30.050 --> 42:30.850
少一眼

42:30.850 --> 42:32.450
少一眼这个函数的函数体中

42:32.450 --> 42:33.330
有没有这个东西

42:33.330 --> 42:34.130
但是你要注意

42:34.690 --> 42:36.370
它少的是这个函数里边的东西

42:36.370 --> 42:37.730
如果你这边还有个函数

42:37.970 --> 42:38.770
比方说函数B

42:41.360 --> 42:42.800
比方说这里一个D

42:43.760 --> 42:45.520
它会不会看这个东西呢

42:45.520 --> 42:46.320
它不会

42:46.320 --> 42:47.440
因为你现在运行的函数

42:47.440 --> 42:48.320
是A这个函数

42:48.320 --> 42:49.840
所以它只看A这边的东西

42:50.240 --> 42:51.760
它只看A这边的东西

42:51.760 --> 42:53.200
它不会看B这边的东西

42:53.760 --> 42:54.720
不要这个意思吧

42:55.120 --> 42:56.480
它不会看B里边的东西

42:57.200 --> 42:58.320
所以它只看到什么

42:58.320 --> 42:59.360
它只看到里边

42:59.360 --> 43:00.640
确实定义了一个变量

43:00.640 --> 43:01.280
叫C

43:01.280 --> 43:03.120
于是它把这个C放到哪呢

43:03.760 --> 43:04.640
它放到了这

43:05.280 --> 43:06.240
放到这个VO里边

43:07.040 --> 43:07.600
C

43:07.600 --> 43:08.160
放起来了

43:08.800 --> 43:09.280
放起来了

43:09.760 --> 43:10.000
好

43:10.000 --> 43:10.480
这个C

43:11.440 --> 43:12.320
这个C是多少

43:12.640 --> 43:13.760
是undefined

43:13.760 --> 43:14.160
对吧

43:14.160 --> 43:14.800
undefined

43:15.440 --> 43:16.000
没问题吧

43:17.040 --> 43:17.680
确定

43:18.960 --> 43:21.520
就是确定函数的里边

43:21.520 --> 43:23.120
它声明的变量

43:23.760 --> 43:24.400
声明的是啥

43:24.400 --> 43:25.040
直接拿过来

43:25.040 --> 43:25.760
直接拿过来

43:25.760 --> 43:26.880
把它设置为undefined

43:27.440 --> 43:28.160
明显的意思吧

43:30.000 --> 43:30.240
好

43:30.800 --> 43:31.760
那么这是第二步

43:32.080 --> 43:32.720
第二步

43:32.720 --> 43:33.600
第三步呢

43:35.360 --> 43:37.280
确定函数中

43:37.280 --> 43:39.040
通过字面量

43:39.600 --> 43:42.000
声明的函数

43:42.000 --> 43:43.760
就是函数里边可不可以声明函数

43:43.760 --> 43:44.720
也可以对不对

43:44.720 --> 43:45.280
所以说

43:45.280 --> 43:46.160
在确定函数中

43:46.160 --> 43:48.080
通过字面量声明的函数

43:48.560 --> 43:49.920
将它们的值

43:50.560 --> 43:51.440
设置为

43:52.240 --> 43:53.680
指向函数对象

43:54.400 --> 43:54.640
好

43:54.640 --> 43:55.520
这是什么意思

43:55.520 --> 43:59.200
主要是靠我的图来进行理解

43:59.200 --> 44:00.320
比方说这里一个函数B

44:01.200 --> 44:02.160
这里一个函数B

44:02.960 --> 44:03.440
好

44:03.440 --> 44:04.080
然后呢

44:04.080 --> 44:04.960
这里边定义啥

44:04.960 --> 44:06.400
定义个随便定义个啥

44:06.400 --> 44:07.360
这些都无所谓

44:07.360 --> 44:08.560
这些都无所谓

44:08.640 --> 44:09.920
那么它里边的东西我不看

44:09.920 --> 44:11.760
但是这个函数B本身我要看

44:11.760 --> 44:12.240
为什么

44:12.240 --> 44:14.560
因为它是通过函数字面量声明

44:14.560 --> 44:15.360
注意啊

44:15.360 --> 44:17.680
它一定是通过函数字面量声明的

44:18.320 --> 44:19.520
你这样子写就不行了

44:20.160 --> 44:21.600
你这样子写就不行了

44:21.600 --> 44:22.800
这样子写的是啥

44:22.800 --> 44:23.680
这样子写的话

44:23.680 --> 44:24.640
这个B相当于是啥

44:24.640 --> 44:25.600
相当于是个变量

44:25.600 --> 44:26.480
一个普通变量

44:26.480 --> 44:26.800
看到没

44:26.800 --> 44:28.320
跟这个C本质是一样的

44:28.320 --> 44:29.680
是一个普通变量

44:29.680 --> 44:32.080
一定是通过函数字面量声明啊

44:32.960 --> 44:34.160
通过这种方式来声明

44:34.960 --> 44:35.200
好

44:35.200 --> 44:36.240
然后它做什么事情呢

44:36.800 --> 44:38.240
它确定这个函数对象

44:38.480 --> 44:39.760
把函数对象挠到

44:39.760 --> 44:41.040
因为我们之前说过

44:41.040 --> 44:42.480
函数本身就是个函数对象

44:42.480 --> 44:42.960
对不对

44:43.920 --> 44:46.480
函数对象

44:49.040 --> 44:49.760
就是这个东西

44:49.760 --> 44:50.720
把它复制一下

44:52.560 --> 44:53.040
复制一下

44:54.640 --> 44:55.600
就确定这个函数

44:55.600 --> 44:56.320
函数对象

44:56.320 --> 44:56.960
它是个对象

44:59.120 --> 44:59.680
然后呢

45:00.320 --> 45:03.360
这里是不是这个VO里边又多了个东西了

45:03.360 --> 45:03.840
多了个什么

45:04.720 --> 45:05.840
大写的B对不对

45:05.840 --> 45:06.400
大写的B

45:07.200 --> 45:08.160
这个B指向谁

45:08.160 --> 45:08.880
它是一个地址

45:08.880 --> 45:09.120
对吧

45:09.120 --> 45:10.080
因为函数它肯定是

45:10.960 --> 45:12.320
这个函数是一个对象

45:12.320 --> 45:13.360
所以它是个地址

45:13.360 --> 45:14.400
于是它指向这

45:14.400 --> 45:15.440
不过有的是为了方便

45:15.440 --> 45:16.720
我们直接在这里写

45:16.720 --> 45:18.080
直接在这里写也可以

45:18.080 --> 45:18.960
为了分析方便

45:19.600 --> 45:20.080
它指向这

45:21.280 --> 45:22.560
它形成了这么一种结构了

45:23.920 --> 45:25.600
这就解释了啥了

45:26.160 --> 45:27.680
解释了为什么

45:28.480 --> 45:31.280
我们在函数里边

45:31.280 --> 45:33.200
可不可以在这里调用B函数

45:33.200 --> 45:33.680
可不可以

45:34.160 --> 45:35.200
当然可以

45:35.200 --> 45:37.440
它就解释了为什么可以这样子

45:37.520 --> 45:39.840
我们以前只是说提升提升提升

45:39.840 --> 45:41.200
提升到第一行对吧

45:41.200 --> 45:42.240
所以实际上说法

45:42.240 --> 45:43.600
这个说法是不准确的

45:43.600 --> 45:44.240
提升到哪

45:44.480 --> 45:45.600
它提升到哪了

45:45.920 --> 45:49.520
提升到了执行上下文的VO里边

45:49.920 --> 45:50.960
它提升到了这

45:51.920 --> 45:52.800
因为函数

45:52.800 --> 45:53.920
我们后边在

45:53.920 --> 45:55.200
编写函数代码过程中

45:55.200 --> 45:56.960
我们要用到各种各样的东西

45:56.960 --> 45:58.480
那这些东西在哪里去找

45:58.480 --> 46:00.000
就在VO里边去找

46:00.480 --> 46:01.120
原来这意思吧

46:01.680 --> 46:04.160
所以说了这个代码一开始输出啥呢

46:04.560 --> 46:05.520
它一开始输出啥

46:06.240 --> 46:06.880
A和B

46:06.880 --> 46:08.160
我们来看一下VO里边

46:08.160 --> 46:08.720
A和B

46:08.720 --> 46:09.920
我一二对不对

46:09.920 --> 46:10.560
好

46:10.560 --> 46:12.000
然后这个C为啥

46:12.560 --> 46:13.440
不要去看这

46:13.440 --> 46:14.240
不要去看这

46:14.240 --> 46:14.800
看啥

46:15.200 --> 46:15.760
看这

46:16.640 --> 46:17.360
C为啥

46:17.360 --> 46:18.000
undefend

46:18.640 --> 46:19.040
对不对

46:19.040 --> 46:19.760
undefend

46:19.760 --> 46:21.360
所以说一开始输出啥

46:21.360 --> 46:22.720
输出的肯定是undefend

46:24.400 --> 46:24.960
Ab1

46:24.960 --> 46:26.080
2和undefend

46:26.080 --> 46:26.480
看到没

46:27.280 --> 46:29.040
它为什么没有爆错

46:29.040 --> 46:30.320
它就是这个原因

46:30.320 --> 46:32.160
那如果你这里写了一个不存在的东西

46:32.160 --> 46:33.040
比方说abc

46:33.040 --> 46:34.160
这里写了一个abc

46:34.160 --> 46:35.360
那它是不是就爆错了

46:35.520 --> 46:37.040
它为什么要爆错

46:37.040 --> 46:39.920
是因为它在这个VO里边找不到abc

46:39.920 --> 46:40.720
它才爆错了

46:41.760 --> 46:42.480
明白了吧

46:42.480 --> 46:43.520
是这么个意思

46:44.160 --> 46:46.720
它是我们要找的东西全在VO里边

46:46.720 --> 46:48.000
它在VO里边找不到了

46:48.000 --> 46:48.960
它就爆错了

46:48.960 --> 46:50.080
是这么个意思

46:51.520 --> 46:52.640
这里就可以得到C了

46:52.640 --> 46:53.120
对吧

46:53.120 --> 46:54.160
然后继续运行

46:54.160 --> 46:55.040
运行过后了

46:55.040 --> 46:56.800
它这句话就没有声明了

46:56.800 --> 46:58.160
这句话就相当于是没有声明了

46:58.160 --> 46:59.440
没有这个发关键词了

46:59.440 --> 47:00.240
你可以这样理解

47:00.240 --> 47:01.600
就相当于是没有了

47:01.600 --> 47:02.560
你不能把它删掉

47:02.560 --> 47:03.280
删掉它就是

47:03.680 --> 47:05.520
它就跟文的都一样了

47:06.480 --> 47:06.960
那么这里

47:08.480 --> 47:10.000
就是没有这个关键词了

47:10.800 --> 47:11.840
这就直接复制

47:11.840 --> 47:13.200
123复制给C

47:13.200 --> 47:14.720
它实际上保存了哪儿的

47:14.720 --> 47:17.120
它不是保存到VO里边的

47:17.120 --> 47:18.640
VO里边C是什么

47:18.640 --> 47:19.200
123

47:20.000 --> 47:20.640
123

47:20.640 --> 47:21.600
是这么个意思

47:22.160 --> 47:23.280
VO里边C是123

47:23.280 --> 47:24.240
保存过来了

47:24.240 --> 47:24.400
好

47:24.400 --> 47:25.440
保存过来了之后

47:25.440 --> 47:26.160
咱们来看看

47:27.440 --> 47:28.800
然后再输出abc

47:28.800 --> 47:29.520
是不是就输出

47:30.400 --> 47:31.680
这一次就输出了什么

47:31.680 --> 47:32.960
12和123了

47:34.240 --> 47:36.240
虽然这个结果很好理解

47:36.240 --> 47:38.080
但是这个过程里要知道

47:38.080 --> 47:39.200
它是这么回事

47:39.200 --> 47:40.080
在VO里边

47:40.720 --> 47:42.240
它是放到VO里边去了

47:43.440 --> 47:43.680
好

47:43.680 --> 47:44.080
接下来

47:44.720 --> 47:46.480
我们再来说重明的情况

47:48.080 --> 47:50.080
那里的变调名跟参数名重复了

47:50.960 --> 47:52.800
函数的名字跟变调名重复了

47:52.800 --> 47:54.240
那又会怎么办呢

47:54.240 --> 47:55.200
因为它是有顺序的

47:55.200 --> 47:55.520
看到没

47:56.080 --> 47:57.760
它这个过程是有顺序的

47:57.760 --> 47:58.640
那它怎么办呢

47:58.640 --> 47:59.600
它是这样在处理的

48:00.240 --> 48:00.640
看着

48:01.120 --> 48:02.320
我们先说这个变调

48:02.960 --> 48:05.360
如果变调跟前边的东西重复了

48:05.360 --> 48:06.480
跟形成参值重复

48:06.480 --> 48:07.520
跟形成参重复了

48:07.520 --> 48:08.480
名字重复了

48:08.480 --> 48:09.040
怎么办呢

48:09.600 --> 48:10.400
忽略

48:10.400 --> 48:14.640
如果已有该名称的

48:16.320 --> 48:17.440
就是如果VO中

48:17.920 --> 48:20.880
如果VO中已有该名称

48:21.520 --> 48:23.040
则直接忽略

48:24.160 --> 48:24.800
忽略

48:24.800 --> 48:26.080
变调是直接忽略的

48:26.800 --> 48:27.440
比方有什么意思

48:28.240 --> 48:28.960
比方说吧

48:29.040 --> 48:29.600
这边

48:30.560 --> 48:31.360
这个C

48:31.680 --> 48:32.800
我们用的不是C

48:32.800 --> 48:33.600
用的是B

48:34.560 --> 48:35.120
看一下吧

48:35.600 --> 48:36.320
用的是B

48:37.520 --> 48:38.960
那么这个时候怎么办呢

48:39.200 --> 48:39.920
这个时候

48:40.240 --> 48:41.120
这个时候

48:41.280 --> 48:41.920
我们

48:42.800 --> 48:43.840
它是这样在处理的

48:44.320 --> 48:45.360
先确定形参

48:45.360 --> 48:45.680
对吧

48:45.680 --> 48:46.480
还有arguments

48:46.480 --> 48:47.680
arguments我们就不写了

48:47.680 --> 48:49.360
这个东西我们现在跟我们做题

48:49.360 --> 48:50.080
没什么关系

48:51.040 --> 48:52.080
有A和有B

48:52.080 --> 48:52.400
对吧

48:52.400 --> 48:53.600
先有这么两个东西

48:54.480 --> 48:55.520
有这么两个东西

48:55.840 --> 48:56.080
好

48:56.080 --> 48:56.880
接下来呢

48:57.840 --> 48:58.480
第二步

48:58.480 --> 48:59.600
确定变调的

48:59.600 --> 49:00.080
指对吧

49:00.080 --> 49:00.800
变调的

49:00.800 --> 49:01.600
确定变调

49:01.600 --> 49:02.560
变调为undefend

49:02.560 --> 49:03.840
无论是生命的啥变调

49:03.840 --> 49:05.200
它都是设置为undefend

49:05.760 --> 49:06.160
于是呢

49:06.160 --> 49:07.600
它这里看到有这么个变调

49:07.600 --> 49:08.320
变调B

49:09.040 --> 49:09.520
于是呢

49:09.520 --> 49:11.840
它本来打算是在这里建立一个B

49:11.840 --> 49:13.120
跟它设置为undefend

49:13.120 --> 49:14.960
但是当你发现它已经有B了

49:14.960 --> 49:15.360
看到没

49:15.360 --> 49:16.240
已经有了

49:16.240 --> 49:16.800
于是呢

49:16.800 --> 49:17.760
它直接忽略

49:17.760 --> 49:18.960
它就不做这件事了

49:18.960 --> 49:20.160
是这么个意思

49:20.160 --> 49:21.280
是这么个意思

49:21.280 --> 49:21.760
于是呢

49:21.760 --> 49:22.400
这里输出啥

49:23.040 --> 49:23.760
输出啥

49:23.760 --> 49:24.960
是不是还是E2

49:24.960 --> 49:25.600
对不对

49:25.600 --> 49:26.000
好

49:26.000 --> 49:26.800
咱来看一下吧

49:29.260 --> 49:30.460
这F12

49:30.460 --> 49:31.100
你看

49:31.100 --> 49:32.700
第一次输出是不是还是E2

49:32.700 --> 49:33.660
对不对

49:33.660 --> 49:33.900
好

49:33.900 --> 49:35.500
为什么后边又输出了E23呢

49:35.500 --> 49:37.020
是因为后边一把B这指

49:37.020 --> 49:38.860
相当于是把参数的指甲改了

49:38.860 --> 49:39.260
对吧

49:39.260 --> 49:40.700
相当于是改的是参数的指

49:40.700 --> 49:41.980
改的是这个东西

49:41.980 --> 49:42.780
改的是这个东西

49:42.780 --> 49:44.220
把它改成了E23

49:44.220 --> 49:45.020
是这么个意思

49:45.900 --> 49:46.780
你看这个意思吧

49:46.780 --> 49:47.020
好

49:47.020 --> 49:48.940
我们如何来验证这一点呢

49:48.940 --> 49:49.900
我们这样子吧

49:49.900 --> 49:50.540
我们这里呢

49:50.540 --> 49:51.660
不光输出它

49:51.660 --> 49:53.260
还输出什么argument

49:53.260 --> 49:53.500
好

49:53.500 --> 49:53.820
这里呢

49:53.820 --> 49:54.940
我们也不光输出它

49:54.940 --> 49:56.220
再输出什么argument

49:56.220 --> 49:57.340
我们来看一下

49:57.420 --> 49:58.620
保存看一下

49:58.620 --> 50:00.300
你看一下argument里边

50:02.300 --> 50:02.780
这里看

50:02.780 --> 50:04.060
你看一开始是不是E2

50:04.060 --> 50:04.700
对吧

50:04.700 --> 50:05.180
好

50:05.180 --> 50:06.700
把这个B定一个变量B

50:06.700 --> 50:07.660
把它改成了E23

50:07.660 --> 50:10.540
你看参数里边是不是也改了

50:10.540 --> 50:11.260
E1和E23

50:11.260 --> 50:13.260
因为我们以前说过

50:13.260 --> 50:15.980
argument跟参数的指是一对应的

50:15.980 --> 50:16.380
对不对

50:16.380 --> 50:16.940
对应的

50:16.940 --> 50:17.820
你改了参数呢

50:17.820 --> 50:19.100
相当于是改了这儿

50:19.100 --> 50:21.020
通过它就可以验证出

50:21.020 --> 50:22.860
你这个B实际上是参数

50:22.860 --> 50:24.540
实际上就是参数

50:24.540 --> 50:25.500
好吧

50:25.500 --> 50:27.100
这是这个规则

50:27.100 --> 50:28.380
如果已经出现同名的

50:28.380 --> 50:29.980
那么变量这一块的规则是

50:29.980 --> 50:31.100
直接忽略

50:31.100 --> 50:32.460
忽略

50:32.460 --> 50:32.700
好

50:32.700 --> 50:34.780
但是函数就不一样了

50:34.780 --> 50:36.220
如果

50:36.220 --> 50:40.940
VO中已有已存在函数

50:40.940 --> 50:41.980
所以说为什么函数

50:41.980 --> 50:44.140
函数是一等公鸣呢

50:44.140 --> 50:45.020
已存在

50:45.020 --> 50:48.860
已存在这个该名称

50:48.860 --> 50:50.700
则覆盖

50:50.700 --> 50:51.420
覆盖

50:51.420 --> 50:53.100
如果是函数的话就覆盖

50:53.100 --> 50:55.020
如果是变量的话就忽略

50:55.020 --> 50:56.460
记住这个规则

50:56.620 --> 50:57.900
咱们再看一下

50:57.900 --> 50:59.660
那么B刚才忽略掉了

50:59.660 --> 51:00.700
变量B忽略掉了

51:00.700 --> 51:03.500
那么如果函数也是个B呢

51:03.500 --> 51:05.180
函数也是B呢

51:05.180 --> 51:07.740
那么这个时候它就会覆盖

51:07.740 --> 51:09.020
对它进行覆盖

51:09.020 --> 51:10.860
于是这个B变成了啥呢

51:10.860 --> 51:12.460
变成了一个函数了

51:12.460 --> 51:13.340
一个函数了

51:13.340 --> 51:14.700
于是它指向了

51:14.700 --> 51:15.420
指向谁

51:15.420 --> 51:17.180
指向函数对向

51:17.180 --> 51:18.780
指向它

51:18.780 --> 51:21.500
咱们再来输出一下看一下

51:21.500 --> 51:22.460
一开始这个B

51:22.460 --> 51:23.740
一看一下

51:23.740 --> 51:24.940
你看是不是一个函数

51:24.940 --> 51:25.420
对吧

51:25.500 --> 51:26.780
一开始这个B是一个函数

51:26.780 --> 51:28.620
然后你又把它复制为了123

51:28.620 --> 51:29.660
于是它变成了

51:29.660 --> 51:31.260
变成了这个东西了

51:31.260 --> 51:32.460
你看这个意思吧

51:32.460 --> 51:34.140
这就是它的执行过程

51:34.140 --> 51:34.620
它

51:34.620 --> 51:35.820
我们在函数里边

51:35.820 --> 51:37.820
可以用这各种各样的东西

51:37.820 --> 51:41.740
是因为我们在VO里边已经存在了

51:41.740 --> 51:42.940
已经存在了

51:42.940 --> 51:44.460
接下来我们来做一个倒题

51:44.460 --> 51:45.020
做一个倒题

51:45.020 --> 51:46.540
Tesla 4

51:46.540 --> 51:47.580
就这么一个函数吧

51:47.580 --> 51:48.700
就这么一个函数

51:48.700 --> 51:52.300
好 接下来我们这里写这么一个东西

51:53.260 --> 51:57.340
输出A 输出B

51:57.340 --> 51:58.380
然后呢

51:58.380 --> 51:58.780
这里

52:01.100 --> 52:02.380
再订一个A

52:02.380 --> 52:04.220
把它复制为一个函数

52:04.220 --> 52:06.140
复制为一个函数

52:06.140 --> 52:06.700
然后呢

52:07.820 --> 52:08.300
输出

52:09.660 --> 52:10.540
这个函数空的

52:10.540 --> 52:10.940
空的

52:10.940 --> 52:12.140
这个函数也没啥用

52:12.140 --> 52:12.540
空的

52:14.300 --> 52:16.380
好 接下来我们再来看

52:16.380 --> 52:18.620
这里输出A和B

52:20.060 --> 52:20.380
好

52:20.380 --> 52:20.780
然后呢

52:20.780 --> 52:25.180
我们这里下面再来输出A和B

52:26.460 --> 52:27.900
看一下输出啥

52:27.900 --> 52:28.620
输出啥结果

52:28.620 --> 52:29.500
来 大家分析一下

52:31.660 --> 52:32.700
输出什么呢

52:32.700 --> 52:33.580
关键点呢

52:33.580 --> 52:35.980
你一定要分析出VO里边的变化

52:35.980 --> 52:37.740
因为这些东西全在VO里边

52:37.740 --> 52:40.060
你把VO里边的东西发生变化的过程呢

52:40.060 --> 52:40.780
分析出来了

52:40.780 --> 52:42.460
那么你就知道怎么回事了

52:42.460 --> 52:43.180
好吧

52:43.180 --> 52:44.220
好 第一个

52:44.220 --> 52:44.620
第一个

52:45.820 --> 52:47.740
首先我们调用这个A函数

52:47.740 --> 52:48.860
是不是在全剧上下文

52:48.860 --> 52:50.940
上边见了一个VO 对不对

52:50.940 --> 52:51.900
见了一个VO

52:51.900 --> 52:53.020
就是一个执行上下文

52:53.020 --> 52:54.860
是执行上下文的一个VO

52:54.860 --> 52:56.700
VO里边首先有参数 对吧

52:56.700 --> 52:57.820
A和B两个参数

52:57.820 --> 52:59.100
1和2 对不对

52:59.100 --> 53:01.020
好 那么首先它是这种情况

53:01.020 --> 53:03.420
首先让这个参数的值是1和2

53:03.420 --> 53:04.140
还没有这个东西

53:04.940 --> 53:05.820
好 接下来呢

53:05.820 --> 53:07.900
第二步确定变量值

53:07.900 --> 53:08.620
有几个变量

53:09.420 --> 53:10.460
有几个变量

53:10.460 --> 53:11.980
一个 两个 对吧

53:11.980 --> 53:13.020
有两个变量

53:13.020 --> 53:14.300
但是很遗憾的是

53:14.300 --> 53:15.660
这两个变量是不是同名了

53:15.660 --> 53:17.180
跟参数的名字相同了

53:17.180 --> 53:18.700
于是直接忽略

53:18.940 --> 53:20.060
变量本来要负责的

53:20.060 --> 53:22.140
但是它直接忽略了

53:23.260 --> 53:24.380
然后第三步呢

53:24.380 --> 53:27.580
确定函数字面量声明

53:27.580 --> 53:28.380
这个东西看不看

53:29.260 --> 53:29.980
不看

53:29.980 --> 53:32.300
它是表达是不看

53:32.300 --> 53:35.020
于是确定函数字面量声明

53:35.020 --> 53:35.740
确定的是啥

53:35.740 --> 53:36.540
确定的是B

53:37.100 --> 53:37.740
确定的是B

53:38.220 --> 53:38.860
你看这个意思吧

53:39.740 --> 53:42.380
比方说我们这里B呢

53:42.380 --> 53:43.580
它是有个函数 对不对

53:43.580 --> 53:45.420
那么这里B名字相同了覆盖

53:46.140 --> 53:47.740
于是B它又指向谁

53:47.820 --> 53:48.620
指向一个函数了

53:49.260 --> 53:50.060
指向这个函数了

53:51.100 --> 53:52.300
好 接下来继续

53:52.300 --> 53:53.020
继续

53:53.020 --> 53:54.300
我们就认为B是一个函数

53:54.300 --> 53:55.420
我们就简单记录一下

53:55.420 --> 53:56.380
简单记录一下

53:57.100 --> 53:57.820
B是一个函数

53:57.820 --> 53:58.300
FN

53:58.300 --> 53:59.500
用FN来表示一个函数

54:00.220 --> 54:00.860
好

54:00.860 --> 54:01.740
然后又来

54:02.620 --> 54:03.100
还有啥

54:03.100 --> 54:03.740
就没了 对不对

54:03.740 --> 54:04.620
就没了

54:04.620 --> 54:06.300
变量 函数 参数

54:06.300 --> 54:07.100
都确定下来了

54:07.100 --> 54:07.660
没了

54:07.660 --> 54:08.940
好 开始执行代码

54:08.940 --> 54:10.220
一开始输出A和B

54:10.220 --> 54:10.700
输出啥

54:11.340 --> 54:13.820
输出1和函数 对不对

54:13.820 --> 54:14.940
输出这个东西

54:14.940 --> 54:16.620
一开始输出1和函数

54:16.620 --> 54:17.260
咱们来看一下吧

54:18.540 --> 54:19.180
边做边看

54:21.100 --> 54:22.140
好 关闭起来的

54:22.940 --> 54:24.860
刷新 你看1和一个啥

54:24.860 --> 54:25.900
和一个函数

54:25.900 --> 54:26.300
看到没

54:27.020 --> 54:28.300
所以说你在最开始的时候

54:28.300 --> 54:29.260
能不能调用函数

54:29.260 --> 54:29.980
当然没问题

54:29.980 --> 54:31.020
因为它本身就是函数

54:31.020 --> 54:31.580
对不对

54:31.580 --> 54:32.220
可以调用了

54:32.780 --> 54:34.060
好 接下来第二句话

54:34.060 --> 54:35.900
又把这个B复制为123

54:35.900 --> 54:37.740
你看现在B又变成了123了

54:39.580 --> 54:41.020
好 变成123过后了

54:41.020 --> 54:42.780
下面第17行还运行吗

54:42.780 --> 54:43.500
它不运行的

54:44.060 --> 54:45.900
像这种字面量声明函数

54:45.900 --> 54:47.660
它一旦提取到VO过后

54:47.820 --> 54:49.740
你之后可以认为它消失了

54:49.740 --> 54:50.140
就没了

54:50.140 --> 54:51.340
因为已经处理过了

54:51.340 --> 54:52.300
你不用再处理了

54:53.020 --> 54:54.380
已经提取到VO里边了

54:55.020 --> 54:56.060
但是后来一把复改了

54:56.060 --> 54:57.100
那是你自己的事 对吧

54:57.100 --> 54:57.820
你自己把复改了

54:57.820 --> 54:58.700
关我啥事了

54:58.700 --> 55:00.060
它不再运行这个东西了

55:00.460 --> 55:01.580
不再用这个东西了

55:02.220 --> 55:03.820
所以说后边你还想调用

55:03.820 --> 55:04.620
然后这句话之后

55:04.620 --> 55:06.620
你还想调用B这个函数还能调用吗

55:07.020 --> 55:08.060
就是不是比较用不了了

55:08.620 --> 55:11.420
因为VO里边B已经是123了

55:11.420 --> 55:12.620
它已经不再是函数了

55:12.620 --> 55:13.580
明白这个意思吧

55:13.580 --> 55:14.860
你就不能再调用了

55:14.860 --> 55:16.220
这句话是不会运行的

55:16.220 --> 55:17.500
因为它已经处理过了

55:17.900 --> 55:19.740
函数字面量的声明已经处理过了

55:20.940 --> 55:22.940
然后第19行要不要运行

55:22.940 --> 55:23.660
它也要运行

55:23.660 --> 55:25.100
因为这是辩量的复制

55:25.660 --> 55:26.940
这是辩量的复制

55:26.940 --> 55:28.380
它又把A复制为啥

55:28.700 --> 55:30.220
把A又复制为一个函数

55:30.940 --> 55:32.220
它这么回事

55:32.460 --> 55:33.820
把A又复制为一个函数

55:34.140 --> 55:35.740
这是一个普通辩量的复制

55:35.740 --> 55:37.260
不要认为函数有多特殊

55:37.260 --> 55:38.940
它就是一个对象而已

55:38.940 --> 55:40.220
你把对象用复制给A

55:40.220 --> 55:40.700
对不对

55:40.700 --> 55:42.140
怎么A又指向一个函数了

55:43.260 --> 55:44.700
这不是字面量函数声明

55:44.700 --> 55:45.820
这是函数表达4

55:45.980 --> 55:47.100
然后最后输出A呢

55:47.100 --> 55:48.300
A和B就是两个函数

55:48.300 --> 55:48.860
对不对

55:48.860 --> 55:49.740
是不是两个函数

55:50.620 --> 55:51.740
一个第一个是FN

55:51.740 --> 55:52.620
第二个是123

55:55.100 --> 55:55.660
123

55:55.660 --> 55:56.380
看没

55:56.380 --> 55:57.820
它是这么一个过程

55:58.460 --> 55:59.980
你一定要理解

55:59.980 --> 56:02.940
它用的东西全是VO里面的

56:02.940 --> 56:04.060
VO里面没有

56:04.060 --> 56:05.340
你是肯定用不了的

56:05.340 --> 56:06.780
你是肯定用不了的

56:06.780 --> 56:08.220
它查到这些辩量

56:08.220 --> 56:09.660
查到这些东西的时候

56:09.660 --> 56:11.580
全是从VO里面去查

56:11.580 --> 56:12.300
VO里面没有

56:12.300 --> 56:12.780
那就没有

56:13.580 --> 56:14.380
是这么回事

56:15.100 --> 56:15.980
好

56:15.980 --> 56:17.180
接下来我们再回过头来

56:17.180 --> 56:18.300
看一下全句上向文

56:18.300 --> 56:19.820
是不是也是类似的处理

56:19.820 --> 56:21.740
它其实也是类似的处理

56:21.740 --> 56:23.260
也是类似的处理

56:23.260 --> 56:24.460
咱们来看一下全句上向文

56:25.980 --> 56:27.340
这几课全靠理解

56:27.340 --> 56:28.540
全靠理解

56:28.540 --> 56:29.660
你光看我的笔记

56:30.220 --> 56:31.100
你可能光看笔记

56:31.100 --> 56:31.980
看一看不懂

56:31.980 --> 56:33.020
全靠这一块理解

56:33.900 --> 56:34.300
这里呢

56:35.180 --> 56:35.820
比方说

56:35.820 --> 56:37.340
我们这里一个函数A对吧

56:37.340 --> 56:37.980
一个函数A

56:39.260 --> 56:42.060
然后这里面我们定一个变量

56:42.060 --> 56:43.820
变量A123

56:44.860 --> 56:46.860
定一个变量

56:46.860 --> 56:48.380
变量就是

56:48.380 --> 56:50.140
这样子吧

56:50.140 --> 56:50.780
变量

56:51.420 --> 56:53.980
变量G1123

56:53.980 --> 56:54.620
然后呢

56:54.620 --> 56:57.180
这里G2156

56:57.180 --> 56:57.980
然后呢

56:59.260 --> 57:01.580
定一个就是G3

57:01.580 --> 57:03.180
G3直接写ABC

57:04.940 --> 57:06.140
或者不直接写吗

57:06.140 --> 57:07.100
还是不要直接写了

57:07.740 --> 57:09.660
定G3一个函数

57:10.460 --> 57:10.780
好

57:10.780 --> 57:11.420
随便写吧

57:11.420 --> 57:12.140
随便写

57:12.140 --> 57:12.460
好

57:12.460 --> 57:14.220
接下来我们把这个函数折叠起来

57:14.620 --> 57:17.180
一开始创建全局执行商业文的时候

57:17.660 --> 57:19.660
它是不是也要做类似的事情

57:19.660 --> 57:21.260
也要做类似的事情

57:21.260 --> 57:23.020
我们之前说全局执行商业文

57:23.020 --> 57:23.820
它有些特殊

57:23.820 --> 57:24.940
它的名字叫做GO

57:24.940 --> 57:25.100
对吧

57:25.100 --> 57:26.380
它指向的是温斗对象

57:26.380 --> 57:27.820
但是它一事情还是得做

57:27.820 --> 57:28.620
还是得做

57:28.620 --> 57:29.500
什么事情呢

57:29.500 --> 57:31.020
首先参数它肯定不存在

57:31.020 --> 57:31.500
对吧

57:31.500 --> 57:32.620
肯定不存在参数

57:32.620 --> 57:33.740
那么变量是不是存在

57:34.300 --> 57:35.020
变量是不是存在

57:35.020 --> 57:36.380
看一下全局环境里面

57:36.380 --> 57:37.420
今天要哪些变量

57:37.420 --> 57:39.260
是不是G1 G2 G3

57:39.260 --> 57:40.060
对不对

57:40.060 --> 57:40.460
好

57:40.460 --> 57:41.500
于是呢

57:41.500 --> 57:42.620
它怎么样呢

57:42.700 --> 57:44.540
由于它指向的是温斗

57:44.540 --> 57:47.260
所以说它会在温斗对象下边去

57:47.260 --> 57:48.620
因为它指向的温斗

57:48.620 --> 57:50.140
它只能在这里加对吧

57:50.140 --> 57:53.180
G1 G2 G3

57:53.180 --> 57:53.820
看没有

57:53.820 --> 57:54.700
它把加二招了

57:54.700 --> 57:55.820
它的值是啥

57:55.820 --> 57:56.620
全是变量

57:56.620 --> 57:58.140
全都是undefined对吧

57:58.140 --> 57:59.260
全都是undefined的

58:00.700 --> 58:01.580
是这么回事

58:01.580 --> 58:03.500
这就是为什么我们在全局变量

58:04.460 --> 58:06.300
在全局环境下定义的变量

58:06.300 --> 58:07.500
全在温斗对象上面

58:07.500 --> 58:08.700
为什么在温斗对象上面

58:08.700 --> 58:10.380
因为它GO它指向的就是温斗

58:11.340 --> 58:12.540
它的GO里边加东西

58:12.540 --> 58:14.060
就是在温斗里边加东西

58:14.060 --> 58:15.340
是这么个原因

58:16.060 --> 58:16.460
于是呢

58:16.460 --> 58:17.900
这三个变量变成undefined的

58:17.900 --> 58:18.220
对吧

58:19.340 --> 58:20.460
然后再确定函数

58:20.460 --> 58:21.660
函数是不是有个A函数

58:21.660 --> 58:23.180
这是函数字面量声明

58:23.180 --> 58:23.660
对吧

58:23.660 --> 58:25.180
函数字面量声明

58:25.180 --> 58:25.660
于是呢

58:25.660 --> 58:26.700
确定一个函数

58:26.700 --> 58:27.340
函数A

58:28.060 --> 58:28.860
确定一个函数A

58:29.900 --> 58:31.260
这个A是一个函数

58:31.260 --> 58:31.980
函数

58:32.540 --> 58:32.940
于是呢

58:32.940 --> 58:34.140
它的GO变成这个样子

58:34.700 --> 58:35.900
这就是温斗对象里边

58:35.900 --> 58:37.900
为什么会有G1 G2 G3

58:37.900 --> 58:38.460
还有个A

58:38.460 --> 58:39.020
为什么会有

58:39.020 --> 58:39.660
就是这个原因

58:40.540 --> 58:41.100
好 看一下

58:42.060 --> 58:43.980
温斗对象里边还有一个G1

58:45.260 --> 58:47.100
温斗对象里边一个什么G2

58:47.100 --> 58:47.660
它为什么会有

58:47.660 --> 58:48.700
就是因为这个原因

58:48.700 --> 58:50.540
它在被这个

58:50.540 --> 58:51.740
它间接的通过这个

58:53.100 --> 58:56.380
就是变量对象加了这些属性了

58:57.500 --> 58:58.380
好 然后呢

58:58.380 --> 58:59.420
我们继续看

58:59.420 --> 59:00.380
然后开始运行代码

59:00.380 --> 59:01.580
上下文建立好了

59:01.580 --> 59:02.780
过后开始运行代码

59:02.780 --> 59:04.140
G1等于得多少

59:04.140 --> 59:06.540
123等于123

59:06.540 --> 59:08.860
然后G2等于456

59:08.860 --> 59:09.740
这句话也还有运行吗

59:09.820 --> 59:10.460
是不是不运行的

59:11.260 --> 59:12.860
这是早就提出去了

59:12.860 --> 59:13.100
对吧

59:13.740 --> 59:14.700
早就提出去了

59:14.700 --> 59:15.260
提到这了

59:15.260 --> 59:15.740
可能

59:15.740 --> 59:16.220
提到这了

59:16.220 --> 59:16.940
它就不运行的

59:18.220 --> 59:19.340
G2等于456

59:20.860 --> 59:22.060
456

59:22.060 --> 59:22.860
然后呢

59:22.860 --> 59:24.460
G3是不是有等于一个函数

59:24.460 --> 59:24.860
对吧

59:24.860 --> 59:26.140
G3等于一个函数

59:27.500 --> 59:28.780
然后后边调用A

59:28.780 --> 59:30.940
调用A函数是不是要创建新的上下文

59:30.940 --> 59:32.220
你看我们把整个过程走一遍

59:33.100 --> 59:34.540
这是函数A的上下文

59:34.540 --> 59:35.420
只要一调用函数

59:35.420 --> 59:36.940
就会创建新的上下文

59:36.940 --> 59:38.620
这里是VO

59:40.380 --> 59:42.380
新的上下文

59:42.380 --> 59:43.740
又要确定Z是对吧

59:43.740 --> 59:44.620
又要确定Z是

59:44.620 --> 59:45.420
Z是跟一样

59:45.420 --> 59:47.020
因为它是直接调用了

59:47.020 --> 59:48.300
只像温德是一样的

59:48.300 --> 59:49.500
又去零Z是

59:49.500 --> 59:52.700
然后VO是不是要自己重新创建

59:52.700 --> 59:53.340
对吧

59:53.340 --> 59:54.060
VO重新创建

59:54.060 --> 59:56.380
那么开始要看函数A了

59:56.380 --> 59:57.500
现在开始看函数A

59:57.500 --> 59:58.860
你看这里是不是函数A

59:58.860 --> 59:59.420
对吧

59:59.420 --> 01:00:00.380
看这个函数A

01:00:00.380 --> 01:00:02.620
函数A里面是不是刚才的流程又走一遍

01:00:02.620 --> 01:00:03.100
对不对

01:00:03.100 --> 01:00:04.620
后边我们不画了

01:00:04.620 --> 01:00:05.740
刚才的流程又走一遍

01:00:05.740 --> 01:00:07.500
是这么一回事

01:00:07.500 --> 01:00:09.020
它这过程是这样子的

01:00:09.980 --> 01:00:10.620
好

01:00:10.620 --> 01:00:13.580
这里我们再看一些细节

01:00:13.580 --> 01:00:17.840
首先认识一个新的名词

01:00:17.840 --> 01:00:18.880
叫做AO

01:00:18.880 --> 01:00:20.080
我们后边会用到

01:00:20.080 --> 01:00:21.440
这些可能可能不太会用到

01:00:21.440 --> 01:00:22.560
后边会用到

01:00:22.560 --> 01:00:24.240
叫做Active

01:00:24.240 --> 01:00:26.080
Active Objects

01:00:26.080 --> 01:00:27.760
叫做AO

01:00:27.760 --> 01:00:29.200
它也是VO

01:00:29.200 --> 01:00:30.960
它是另外一种说法

01:00:30.960 --> 01:00:36.320
当前正在执行的上下文中的VO

01:00:36.320 --> 01:00:37.760
它叫做AO

01:00:37.760 --> 01:00:39.520
你看一下现在执行的是哪个上下文

01:00:39.520 --> 01:00:40.160
是不是它

01:00:40.160 --> 01:00:40.560
对吧

01:00:40.640 --> 01:00:42.560
它就叫做AO

01:00:42.560 --> 01:00:44.240
是这么个意思

01:00:44.240 --> 01:00:45.520
其实它本质上一样的

01:00:45.520 --> 01:00:47.840
只是教法不一样而已

01:00:47.840 --> 01:00:49.120
是这么个意思

01:00:49.120 --> 01:00:50.960
这是第一个要认识的

01:00:50.960 --> 01:00:53.440
另外还有一个点要认识的就是

01:00:53.440 --> 01:00:56.240
当函数执行时

01:00:56.240 --> 01:01:02.320
当一个上下文中的代码执行的时候

01:01:02.320 --> 01:01:08.720
如果上下文中不存在

01:01:08.720 --> 01:01:11.600
某个属性

01:01:11.600 --> 01:01:13.840
因为我们用的都是上下文里边的属性对吧

01:01:13.840 --> 01:01:15.120
我们用的什么G1G2G3

01:01:15.120 --> 01:01:16.640
都是用它里边的属性

01:01:16.640 --> 01:01:17.520
包括我们这里

01:01:17.520 --> 01:01:20.080
刚才看到的这里边我们建的A和B

01:01:20.080 --> 01:01:20.560
对吧

01:01:20.560 --> 01:01:21.440
A和B

01:01:21.440 --> 01:01:23.600
那么它里边A是什么

01:01:23.600 --> 01:01:24.800
B是2

01:01:24.800 --> 01:01:25.360
对不对

01:01:25.360 --> 01:01:26.320
B是Fn

01:01:26.320 --> 01:01:27.680
一开始的时候

01:01:27.680 --> 01:01:29.680
一开始的时候

01:01:29.680 --> 01:01:32.160
这个A是1

01:01:32.160 --> 01:01:36.320
B是一个函数

01:01:37.280 --> 01:01:39.040
一开始用它的时候

01:01:39.040 --> 01:01:40.240
它是这样子对不对

01:01:40.240 --> 01:01:41.120
我们用它的时候

01:01:41.120 --> 01:01:42.240
用的A和B

01:01:42.240 --> 01:01:43.120
用的是啥

01:01:43.120 --> 01:01:44.240
用的其实就是

01:01:44.240 --> 01:01:46.560
上下文里边的属性名

01:01:46.560 --> 01:01:47.760
用到它的属性

01:01:47.760 --> 01:01:49.760
但是如果它不存在

01:01:49.760 --> 01:01:52.160
如果上下文中不存在某个属性

01:01:52.160 --> 01:01:53.760
我们这里先简单了解一下

01:01:53.760 --> 01:01:54.480
我们下几课了

01:01:54.480 --> 01:01:56.000
还会讲什么作用语练

01:01:56.000 --> 01:01:57.120
还会详细说

01:01:57.120 --> 01:01:59.120
如果上下文中不存在某个属性

01:01:59.120 --> 01:02:05.040
则会从之前的上下文寻找

01:02:06.640 --> 01:02:08.000
之前的上下文寻找

01:02:08.000 --> 01:02:08.720
什么意思呢

01:02:08.720 --> 01:02:09.760
就是用外面的

01:02:10.720 --> 01:02:11.360
比方说

01:02:11.360 --> 01:02:12.960
我们这里要用记忆可不可以用

01:02:12.960 --> 01:02:13.920
可不可以输出记忆

01:02:14.960 --> 01:02:17.040
这里我们输出记忆能不能输出

01:02:17.680 --> 01:02:18.640
是不是可以输出

01:02:18.640 --> 01:02:19.120
对吧

01:02:19.120 --> 01:02:19.840
保存看一下

01:02:19.840 --> 01:02:21.440
是不是可以输出123

01:02:21.440 --> 01:02:23.040
为什么可以输出

01:02:23.040 --> 01:02:24.640
记忆你看在这个上下文里边

01:02:25.600 --> 01:02:28.160
记忆有没有没有怎么办

01:02:28.160 --> 01:02:29.440
从上一个上下文

01:02:29.440 --> 01:02:30.560
从这个上下文里面去找

01:02:30.560 --> 01:02:31.200
是不是有

01:02:31.200 --> 01:02:31.760
对吧

01:02:31.760 --> 01:02:33.280
这就是为什么函数里边

01:02:33.280 --> 01:02:34.160
可以用外面的东西

01:02:34.160 --> 01:02:34.800
就是这个原因

01:02:34.800 --> 01:02:35.920
就是这个原因

01:02:37.040 --> 01:02:38.400
我们下几课还会详细的说

01:02:38.400 --> 01:02:39.680
作用语练

01:02:39.680 --> 01:02:41.120
这就可能我们先暂时了解一下

01:02:42.080 --> 01:02:43.200
那如果同名呢

01:02:43.760 --> 01:02:44.880
如果外边有一个A

01:02:45.440 --> 01:02:47.120
那是跟这里的A同名了

01:02:47.120 --> 01:02:47.680
用谁的

01:02:47.680 --> 01:02:49.120
肯定是用自己的

01:02:49.120 --> 01:02:50.080
肯定是用自己的

01:02:50.080 --> 01:02:52.720
因为它先找的是自己的L里边东西

01:02:52.720 --> 01:02:53.680
找不到

01:02:53.680 --> 01:02:55.840
再从其他的VU里边去找

01:02:55.840 --> 01:02:56.480
全部都找不到

01:02:56.480 --> 01:02:57.600
那就是为定义

01:02:57.600 --> 01:02:58.240
也要抱错

01:02:58.800 --> 01:02:59.600
是这么个意思

01:03:01.120 --> 01:03:02.080
明白了吧

01:03:02.080 --> 01:03:03.680
这就是它的执行的整个过程

01:03:03.680 --> 01:03:05.840
这就是执行上下文的

01:03:06.560 --> 01:03:07.040
指示

01:03:08.640 --> 01:03:09.040
好

01:03:09.040 --> 01:03:09.680
接下来了

01:03:09.680 --> 01:03:10.320
我们来看

01:03:10.320 --> 01:03:10.720
看体

01:03:11.440 --> 01:03:11.840
地体

01:03:13.040 --> 01:03:13.440
看一下

01:03:16.480 --> 01:03:16.880
地体

01:03:17.600 --> 01:03:18.080
输出啥

01:03:19.360 --> 01:03:19.520
好

01:03:19.520 --> 01:03:19.920
输出啥

01:03:20.640 --> 01:03:21.440
输出的时候呢

01:03:21.440 --> 01:03:23.040
要看着它输出啥呢

01:03:23.040 --> 01:03:25.120
你首先得搞清楚

01:03:25.680 --> 01:03:27.120
上下文里边有哪些东西

01:03:27.600 --> 01:03:27.840
好

01:03:27.840 --> 01:03:28.080
我们来

01:03:28.720 --> 01:03:29.280
看一下吧

01:03:29.280 --> 01:03:29.760
分析一下

01:03:29.760 --> 01:03:30.640
我们简单分析一下

01:03:31.040 --> 01:03:32.400
以后你做编诗题的时候

01:03:32.400 --> 01:03:33.520
也可以在纸张上

01:03:33.520 --> 01:03:34.960
或者是如果有电脑的话

01:03:34.960 --> 01:03:35.680
可以电脑上

01:03:35.760 --> 01:03:36.720
用个计时板画一下

01:03:37.520 --> 01:03:38.560
首先是全局

01:03:38.560 --> 01:03:38.880
对吧

01:03:38.880 --> 01:03:39.760
全局上下文

01:03:40.400 --> 01:03:41.440
全局上下文的是什么

01:03:41.440 --> 01:03:42.400
当然是文的对象

01:03:42.400 --> 01:03:44.400
文的对象里边所有的属性都能用

01:03:44.400 --> 01:03:45.120
就是文的对象

01:03:47.200 --> 01:03:48.480
的中的VO

01:03:50.560 --> 01:03:51.680
Z属于不管了

01:03:51.680 --> 01:03:52.800
上下文中的VO

01:03:54.480 --> 01:03:55.200
也就是GO

01:03:55.200 --> 01:03:55.600
对吧

01:03:55.600 --> 01:03:55.920
GO

01:03:57.120 --> 01:03:57.520
然后呢

01:03:57.520 --> 01:03:58.320
它里边有哪些东西呢

01:03:58.320 --> 01:04:00.000
就当然是文的对象的所有属性

01:04:00.000 --> 01:04:01.120
这就是一个文的对象

01:04:01.920 --> 01:04:02.400
然后呢

01:04:02.400 --> 01:04:03.200
我们这里

01:04:03.200 --> 01:04:05.440
可以看到全局环境里边有哪些东西

01:04:06.000 --> 01:04:06.960
有哪些东西

01:04:06.960 --> 01:04:08.000
是不是有一个

01:04:08.000 --> 01:04:09.600
首先确定没有参数的

01:04:09.600 --> 01:04:09.920
对吧

01:04:09.920 --> 01:04:11.280
全局上下文是没有参数的

01:04:11.280 --> 01:04:12.240
于是确定辨量

01:04:12.240 --> 01:04:13.200
副等于它

01:04:13.200 --> 01:04:14.000
on defend

01:04:14.000 --> 01:04:14.640
对吧

01:04:14.640 --> 01:04:15.040
然后呢

01:04:15.040 --> 01:04:15.600
还有什么

01:04:15.600 --> 01:04:16.960
VO是个字面量生命

01:04:16.960 --> 01:04:17.840
是一个函数

01:04:17.840 --> 01:04:18.640
是一个函数

01:04:18.640 --> 01:04:19.600
有这么一个两个东西

01:04:20.400 --> 01:04:20.640
好

01:04:20.640 --> 01:04:22.240
开始运行这个执行上下文

01:04:22.240 --> 01:04:23.440
然后把这个副副指纬

01:04:23.440 --> 01:04:24.720
多少副指纬为1

01:04:24.720 --> 01:04:25.520
对不对

01:04:25.520 --> 01:04:26.720
把这个副副指纬为1

01:04:27.360 --> 01:04:28.160
然后呢

01:04:28.160 --> 01:04:29.120
这就快运行吗

01:04:29.120 --> 01:04:29.760
不运行

01:04:29.760 --> 01:04:30.720
因为它已经提出来了

01:04:30.720 --> 01:04:31.280
提到这了

01:04:31.280 --> 01:04:31.600
对吧

01:04:31.600 --> 01:04:32.720
所以说不用管了

01:04:32.720 --> 01:04:33.840
然后执行这个VO

01:04:34.560 --> 01:04:36.080
也就执行这个函数

01:04:36.080 --> 01:04:37.040
执行这个函数的时候

01:04:37.040 --> 01:04:38.480
是不是又要创建上下文

01:04:39.760 --> 01:04:40.560
我们这样子写吧

01:04:41.920 --> 01:04:42.960
上面一个上下文就是

01:04:44.800 --> 01:04:45.520
VO

01:04:45.520 --> 01:04:46.240
就是AO了

01:04:46.240 --> 01:04:46.480
对吧

01:04:46.480 --> 01:04:47.200
这个叫做GO

01:04:47.920 --> 01:04:48.320
GO

01:04:48.880 --> 01:04:48.960
好

01:04:48.960 --> 01:04:49.840
那么这个是

01:04:49.840 --> 01:04:51.760
bar的上下文

01:04:53.200 --> 01:04:54.160
把这里多写了一个

01:04:55.360 --> 01:04:57.600
bar的上下文

01:04:59.120 --> 01:05:00.080
叫做AO了

01:05:00.080 --> 01:05:00.720
叫做AO

01:05:00.720 --> 01:05:01.840
当然用VO都行

01:05:02.800 --> 01:05:03.040
好

01:05:03.040 --> 01:05:04.240
它里边有哪些东西呢

01:05:04.240 --> 01:05:05.280
是不是要确定这个函数

01:05:05.280 --> 01:05:06.400
把这个函数表演

01:05:06.400 --> 01:05:06.800
对吧

01:05:06.800 --> 01:05:08.080
虽然说一行一行执行

01:05:08.080 --> 01:05:09.520
但是执行之前

01:05:09.520 --> 01:05:10.480
先把它表演

01:05:10.480 --> 01:05:11.520
这个表的过程

01:05:11.520 --> 01:05:12.480
就可以认为

01:05:12.480 --> 01:05:14.480
有些教程里面把它叫做预编译

01:05:14.480 --> 01:05:15.120
不管怎么叫

01:05:15.120 --> 01:05:17.280
就是表演的意思

01:05:18.320 --> 01:05:18.480
好

01:05:18.480 --> 01:05:19.520
它里边有哪些东西呢

01:05:20.240 --> 01:05:21.040
首先看参数

01:05:21.040 --> 01:05:21.520
有参数吗

01:05:21.520 --> 01:05:22.240
没有

01:05:22.240 --> 01:05:23.360
那参数不管

01:05:23.360 --> 01:05:23.600
好

01:05:23.600 --> 01:05:24.800
首先再看变量

01:05:24.800 --> 01:05:25.680
定义变量有吗

01:05:25.680 --> 01:05:26.480
有是吧

01:05:26.480 --> 01:05:27.280
有定义变量

01:05:27.280 --> 01:05:28.400
甭管那个变量在哪

01:05:28.400 --> 01:05:29.200
无所谓

01:05:29.200 --> 01:05:30.240
无所谓

01:05:30.640 --> 01:05:32.000
那么个变量是不是定义了

01:05:32.000 --> 01:05:32.240
好

01:05:32.240 --> 01:05:33.520
定义了过后拿出来

01:05:33.520 --> 01:05:34.160
多少

01:05:34.160 --> 01:05:35.200
直数为啥

01:05:35.200 --> 01:05:36.400
undefend

01:05:36.400 --> 01:05:37.280
undefend

01:05:37.280 --> 01:05:37.600
对吧

01:05:38.480 --> 01:05:39.200
有这么一个变量

01:05:39.200 --> 01:05:39.440
对吧

01:05:40.160 --> 01:05:40.320
好

01:05:40.320 --> 01:05:41.360
然后开始执行

01:05:41.360 --> 01:05:42.000
有函数吗

01:05:42.000 --> 01:05:42.720
没有函数

01:05:42.720 --> 01:05:42.880
好

01:05:42.880 --> 01:05:43.840
开始执行了

01:05:43.840 --> 01:05:44.480
输出负

01:05:44.480 --> 01:05:45.200
输出啥

01:05:45.200 --> 01:05:46.800
先看自己的上下文

01:05:46.800 --> 01:05:47.520
是不是有

01:05:47.520 --> 01:05:47.920
对吧

01:05:47.920 --> 01:05:48.720
输出啥

01:05:48.720 --> 01:05:50.000
是不是输出undefend

01:05:50.000 --> 01:05:51.280
输出undefend

01:05:52.400 --> 01:05:53.760
然后判断

01:05:53.760 --> 01:05:55.920
如果它不为空

01:05:58.320 --> 01:05:58.640
对

01:05:58.640 --> 01:05:59.600
如果它不为空

01:06:00.320 --> 01:06:01.200
如果它不为空

01:06:01.200 --> 01:06:01.760
是这个意思吧

01:06:04.880 --> 01:06:05.360
如果它

01:06:05.360 --> 01:06:05.600
不对

01:06:05.600 --> 01:06:05.760
不对

01:06:05.760 --> 01:06:06.320
不对

01:06:06.320 --> 01:06:06.720
不对

01:06:06.720 --> 01:06:07.920
如果它没有指

01:06:07.920 --> 01:06:08.640
没有指

01:06:08.640 --> 01:06:09.440
是这么个意思

01:06:09.440 --> 01:06:10.480
如果它没有指

01:06:10.480 --> 01:06:11.680
那现在是不是没有指

01:06:11.680 --> 01:06:11.840
好

01:06:11.840 --> 01:06:13.040
没有指把它负责为多少

01:06:13.040 --> 01:06:14.000
负责为10

01:06:14.000 --> 01:06:14.240
好

01:06:14.240 --> 01:06:15.040
它就变成10了

01:06:15.040 --> 01:06:15.440
对吧

01:06:15.440 --> 01:06:15.840
对吧

01:06:15.840 --> 01:06:16.640
把它变成10了

01:06:17.440 --> 01:06:17.680
好

01:06:17.680 --> 01:06:18.160
然后呢

01:06:18.160 --> 01:06:19.280
最后再输出负

01:06:19.280 --> 01:06:20.640
输出负数多少

01:06:20.640 --> 01:06:21.760
是不是输出10

01:06:21.760 --> 01:06:22.080
对吧

01:06:22.080 --> 01:06:22.960
地道题就出来了

01:06:23.760 --> 01:06:23.920
好

01:06:23.920 --> 01:06:24.240
负责

01:06:24.240 --> 01:06:24.960
张天过来看一下

01:06:27.200 --> 01:06:27.680
是吧

01:06:27.680 --> 01:06:28.480
undefend

01:06:28.480 --> 01:06:28.800
10

01:06:30.000 --> 01:06:30.720
最后不管

01:06:30.800 --> 01:06:32.320
最后是整个表达式的返回结果

01:06:33.040 --> 01:06:33.360
好

01:06:33.360 --> 01:06:34.160
这道题就做完了

01:06:34.720 --> 01:06:34.960
好

01:06:34.960 --> 01:06:35.440
下一道题

01:06:36.880 --> 01:06:37.440
又来

01:06:37.440 --> 01:06:37.840
又来

01:06:39.440 --> 01:06:40.480
全球上响文既欧

01:06:40.480 --> 01:06:42.240
我们就直接说既欧嘛

01:06:42.240 --> 01:06:42.560
既欧

01:06:43.360 --> 01:06:45.440
既欧里边有哪些东西

01:06:45.440 --> 01:06:46.080
折叠起来看

01:06:47.120 --> 01:06:47.920
参数没有

01:06:47.920 --> 01:06:49.360
全球上响文没有参数

01:06:49.360 --> 01:06:49.600
好

01:06:49.600 --> 01:06:49.920
辩量

01:06:50.640 --> 01:06:50.880
A

01:06:51.920 --> 01:06:52.480
undefend

01:06:53.200 --> 01:06:53.760
好

01:06:53.760 --> 01:06:54.240
然后呢

01:06:55.040 --> 01:06:55.760
函数B

01:06:55.760 --> 01:06:56.960
B是一个函数

01:06:56.960 --> 01:06:57.520
没了对吧

01:06:57.520 --> 01:06:57.840
没了

01:06:58.480 --> 01:06:58.720
好

01:06:58.720 --> 01:06:59.280
接下来呢

01:07:00.240 --> 01:07:01.360
把F只为1

01:07:02.400 --> 01:07:03.200
F只为1

01:07:03.760 --> 01:07:04.320
然后呢

01:07:04.320 --> 01:07:05.600
雕用B这个函数

01:07:05.600 --> 01:07:06.480
这一块不看

01:07:06.480 --> 01:07:06.720
不看

01:07:06.720 --> 01:07:07.680
已经提出来了

01:07:07.680 --> 01:07:08.720
雕用B这个函数

01:07:09.360 --> 01:07:10.400
雕用B这个函数

01:07:11.280 --> 01:07:11.920
于是呢

01:07:11.920 --> 01:07:13.040
创建B的响响文

01:07:13.040 --> 01:07:14.000
那么就是B的

01:07:14.720 --> 01:07:15.280
B的AO

01:07:17.440 --> 01:07:18.080
AO

01:07:18.080 --> 01:07:18.880
B的AO

01:07:19.280 --> 01:07:19.760
好

01:07:19.760 --> 01:07:21.280
看一下这里边有哪些东西

01:07:21.280 --> 01:07:21.520
好

01:07:21.520 --> 01:07:22.960
这里边参数没有

01:07:22.960 --> 01:07:23.280
辩量

01:07:23.840 --> 01:07:24.720
辩量A是啥

01:07:25.360 --> 01:07:26.000
A是啥

01:07:26.000 --> 01:07:26.480
undefend

01:07:28.240 --> 01:07:28.480
好

01:07:28.560 --> 01:07:29.040
然后呢

01:07:29.040 --> 01:07:29.680
有没有函数

01:07:30.240 --> 01:07:31.200
有函数对吧

01:07:31.200 --> 01:07:31.920
函数呢

01:07:31.920 --> 01:07:33.840
会覆盖掉这个同名的

01:07:33.840 --> 01:07:34.080
值

01:07:34.640 --> 01:07:35.520
这就变成函数了

01:07:36.000 --> 01:07:37.040
你别管这个函数

01:07:37.040 --> 01:07:37.840
在不在Return后面

01:07:37.840 --> 01:07:38.480
跟这个没关系

01:07:38.480 --> 01:07:40.720
现在都还没有执行这个函数

01:07:40.720 --> 01:07:42.240
现在只是在确定上下文

01:07:42.240 --> 01:07:44.320
所以说这个规则是不会变的

01:07:44.320 --> 01:07:45.200
那么A就是个函数

01:07:45.200 --> 01:07:45.760
看到没

01:07:45.760 --> 01:07:46.080
好

01:07:46.080 --> 01:07:47.360
于是这里输出A输了

01:07:47.360 --> 01:07:48.160
输出一个函数

01:07:48.800 --> 01:07:49.920
输出一个函数

01:07:49.920 --> 01:07:51.200
然后再把F只为10

01:07:51.760 --> 01:07:52.960
把谁的F只为10

01:07:52.960 --> 01:07:54.400
当前上下文的A

01:07:54.400 --> 01:07:55.040
输出为10

01:07:55.680 --> 01:07:56.160
好

01:07:56.160 --> 01:07:56.720
然后呢

01:07:57.280 --> 01:07:57.920
函数结束了

01:07:57.920 --> 01:07:58.240
对吧

01:07:58.320 --> 01:07:58.800
就结束了

01:07:58.800 --> 01:07:59.520
那就结束了呗

01:08:00.080 --> 01:08:00.560
结束了呗

01:08:00.880 --> 01:08:01.200
好

01:08:01.200 --> 01:08:01.680
结束过后

01:08:01.680 --> 01:08:02.560
这个东西是不是销毁

01:08:02.560 --> 01:08:02.880
对吧

01:08:02.880 --> 01:08:03.360
销毁掉

01:08:04.240 --> 01:08:04.400
好

01:08:04.400 --> 01:08:05.040
销毁掉过后

01:08:05.040 --> 01:08:05.760
那你继续

01:08:05.760 --> 01:08:07.840
继续到到全句上下文里面执行

01:08:08.720 --> 01:08:10.720
到全句上下文里面去执行

01:08:10.720 --> 01:08:11.680
全句上下文的A

01:08:11.680 --> 01:08:12.320
是不是1

01:08:12.320 --> 01:08:12.560
对吧

01:08:12.560 --> 01:08:13.520
就输出1

01:08:13.520 --> 01:08:14.400
这里输出1

01:08:14.400 --> 01:08:15.920
于是这个代码输出啥

01:08:15.920 --> 01:08:17.520
Fn就是函数

01:08:17.520 --> 01:08:18.160
一个是1

01:08:19.600 --> 01:08:20.000
好

01:08:20.000 --> 01:08:20.560
看一下啊

01:08:21.680 --> 01:08:22.080
对吧

01:08:22.080 --> 01:08:22.880
一个函数

01:08:22.880 --> 01:08:23.360
一个1

01:08:25.200 --> 01:08:25.760
再来啊

01:08:26.480 --> 01:08:27.360
4提三

01:08:27.360 --> 01:08:27.920
看一下这个题

01:08:30.160 --> 01:08:31.280
一定要会做些题啊

01:08:31.280 --> 01:08:33.440
因为执行上下文是非常容易考的

01:08:34.720 --> 01:08:35.280
看一下这个题

01:08:36.960 --> 01:08:37.120
好

01:08:37.120 --> 01:08:37.760
来吧

01:08:37.760 --> 01:08:39.840
你只要用这种方式的分析就一定没问题

01:08:40.240 --> 01:08:42.400
先把这些乱七八糟的东西折些起来啊

01:08:43.040 --> 01:08:43.520
折些起来

01:08:44.000 --> 01:08:44.320
来吧

01:08:44.880 --> 01:08:45.760
首先是GO

01:08:46.080 --> 01:08:47.120
GO里面有哪些东西

01:08:47.680 --> 01:08:48.320
哪些东西

01:08:48.320 --> 01:08:48.960
看辩量

01:08:48.960 --> 01:08:49.840
先看

01:08:49.840 --> 01:08:50.560
肯定没有参数

01:08:50.560 --> 01:08:50.960
对吧

01:08:50.960 --> 01:08:51.520
看辩量

01:08:52.080 --> 01:08:52.800
辩量有哪些

01:08:52.800 --> 01:08:53.200
Fu

01:08:53.200 --> 01:08:53.600
对吧

01:08:53.600 --> 01:08:54.240
Fu为啥

01:08:54.240 --> 01:08:54.720
undefend

01:08:55.280 --> 01:08:55.920
undefend

01:08:55.920 --> 01:08:56.400
还有哪些

01:08:56.400 --> 01:08:57.040
还有什么辩量

01:08:57.680 --> 01:08:58.480
还有什么辩量

01:08:58.480 --> 01:08:58.880
还有吗

01:08:59.440 --> 01:08:59.920
好像没了

01:08:59.920 --> 01:09:00.240
对吧

01:09:00.240 --> 01:09:00.880
变量就没了

01:09:01.360 --> 01:09:01.840
好

01:09:01.840 --> 01:09:02.240
然后呢

01:09:02.240 --> 01:09:02.880
接下来是啥

01:09:03.440 --> 01:09:04.160
接下来是啥

01:09:04.160 --> 01:09:05.040
是不是函数

01:09:05.040 --> 01:09:05.520
对不对

01:09:05.520 --> 01:09:06.240
函数

01:09:06.240 --> 01:09:06.560
好

01:09:06.560 --> 01:09:07.280
函数有没有

01:09:07.280 --> 01:09:08.240
有没有字面函函数

01:09:08.240 --> 01:09:09.600
只看字面函函数啊

01:09:09.600 --> 01:09:10.560
有没有字面函函数

01:09:10.560 --> 01:09:11.200
有对吧

01:09:11.200 --> 01:09:11.840
有一个函数

01:09:12.400 --> 01:09:12.800
Fn

01:09:14.160 --> 01:09:14.640
Fn

01:09:14.640 --> 01:09:15.280
它指向这

01:09:15.280 --> 01:09:15.600
对吧

01:09:15.600 --> 01:09:16.320
指向这个函数

01:09:17.040 --> 01:09:17.520
指向这

01:09:18.800 --> 01:09:19.120
好

01:09:19.680 --> 01:09:20.160
接下来

01:09:20.160 --> 01:09:21.200
我们输出这个Fu

01:09:21.200 --> 01:09:21.840
输出啥

01:09:21.840 --> 01:09:23.040
全球上下文里面输出Fu

01:09:23.040 --> 01:09:24.240
是不是输出Fn

01:09:24.240 --> 01:09:24.880
对吧

01:09:24.880 --> 01:09:25.760
输出这个函数

01:09:25.760 --> 01:09:26.960
输出这个函数

01:09:27.040 --> 01:09:28.480
我们把这个函数叫做log C嘛

01:09:29.200 --> 01:09:29.840
给他取个名字

01:09:29.840 --> 01:09:31.120
免得一会儿分明清楚

01:09:31.120 --> 01:09:32.640
这个是C

01:09:32.640 --> 01:09:34.320
输出C这个函数

01:09:35.120 --> 01:09:35.280
好

01:09:35.280 --> 01:09:36.720
那么就输出这个什么

01:09:36.720 --> 01:09:37.680
输出C这个函数

01:09:38.480 --> 01:09:38.720
好

01:09:38.720 --> 01:09:39.040
然后呢

01:09:39.040 --> 01:09:40.160
又把这个变量的值

01:09:40.160 --> 01:09:41.280
Fu为A

01:09:41.280 --> 01:09:41.760
A

01:09:41.760 --> 01:09:42.400
又把它付为A

01:09:42.400 --> 01:09:43.520
就是在指形上下文

01:09:43.520 --> 01:09:44.480
AO里边

01:09:44.480 --> 01:09:46.320
就GO里边把它复制为什么

01:09:46.320 --> 01:09:47.360
复制为A了

01:09:47.360 --> 01:09:48.080
它又指向这个了

01:09:48.960 --> 01:09:49.600
指向这个了

01:09:50.240 --> 01:09:50.400
好

01:09:50.400 --> 01:09:51.200
然后又输出Fu

01:09:51.200 --> 01:09:52.560
那当然了就输出什么

01:09:52.560 --> 01:09:52.720
A

01:09:54.080 --> 01:09:54.240
好

01:09:54.240 --> 01:09:55.520
现在又重新给它复制

01:09:55.520 --> 01:09:56.720
又把它复制为一个函数了

01:09:57.200 --> 01:09:57.600
好

01:09:57.600 --> 01:09:59.200
这个函数是输出B的

01:09:59.200 --> 01:09:59.680
ok

01:09:59.680 --> 01:10:01.520
那么现在它又变成了一个函数

01:10:01.520 --> 01:10:02.560
然后这个函数输出啥

01:10:02.560 --> 01:10:02.960
输出B

01:10:04.000 --> 01:10:04.240
好

01:10:04.240 --> 01:10:05.360
那么这里输出啥

01:10:05.360 --> 01:10:06.640
输出的是Fn

01:10:06.640 --> 01:10:07.360
它输出的是B

01:10:08.960 --> 01:10:09.200
好

01:10:09.200 --> 01:10:11.360
然后雕用函数是不是很简单的

01:10:11.360 --> 01:10:11.760
对吧

01:10:11.760 --> 01:10:12.240
输出啥

01:10:12.240 --> 01:10:12.960
输出B

01:10:12.960 --> 01:10:14.000
雕用函数嘛

01:10:14.000 --> 01:10:14.240
对吧

01:10:14.240 --> 01:10:15.120
雕用这个负这个函数

01:10:15.120 --> 01:10:16.400
这个函数里边就一个B

01:10:16.400 --> 01:10:16.800
对吧

01:10:16.800 --> 01:10:17.440
就输出这个

01:10:18.240 --> 01:10:18.800
当然

01:10:18.800 --> 01:10:20.240
肯定要建立上下文

01:10:20.240 --> 01:10:21.920
每次雕用函数都要建立上下文

01:10:23.120 --> 01:10:23.360
好

01:10:23.360 --> 01:10:24.480
接下来这就快运行吗

01:10:24.480 --> 01:10:25.280
是不是不运行的

01:10:25.280 --> 01:10:27.200
因为之前已经提出提出来了

01:10:27.200 --> 01:10:29.200
在创建执行上下文的时候已经提出来了

01:10:29.200 --> 01:10:30.400
不再运行的

01:10:30.400 --> 01:10:30.720
好

01:10:30.720 --> 01:10:32.320
于是这句话就看不见一样

01:10:32.320 --> 01:10:33.440
然后这里再输出负

01:10:33.440 --> 01:10:34.240
再看一下负是啥

01:10:34.240 --> 01:10:36.560
是不是还是一样的

01:10:36.560 --> 01:10:37.200
没变化

01:10:37.200 --> 01:10:37.920
对吧

01:10:37.920 --> 01:10:38.080
好

01:10:38.080 --> 01:10:40.400
再雕用负还是输出B

01:10:40.400 --> 01:10:41.360
它就形成这么一个结果

01:10:42.960 --> 01:10:43.360
看一下吧

01:10:44.640 --> 01:10:44.880
对吧

01:10:45.520 --> 01:10:47.120
看一下我们这里刚才分析的

01:10:47.120 --> 01:10:48.320
和这里输出的结果

01:10:48.320 --> 01:10:49.840
有没有有没有问题的

01:10:50.560 --> 01:10:51.440
让刚才分析的

01:10:51.440 --> 01:10:52.240
看一下啊

01:10:52.240 --> 01:10:53.680
第一个输出什么

01:10:53.680 --> 01:10:55.040
FnC对吧

01:10:55.760 --> 01:10:59.040
第一个输出C

01:10:59.040 --> 01:10:59.280
好

01:10:59.280 --> 01:11:00.640
第二个输出的是什么A

01:11:02.160 --> 01:11:02.640
A

01:11:02.640 --> 01:11:03.680
第三个输出的是B

01:11:05.360 --> 01:11:06.240
B

01:11:06.240 --> 01:11:07.120
B

01:11:07.120 --> 01:11:07.920
后面都是一样的

01:11:07.920 --> 01:11:08.320
对吧

01:11:08.320 --> 01:11:08.960
都一样了

01:11:08.960 --> 01:11:09.280
怎么样

01:11:09.280 --> 01:11:09.680
都一样了

01:11:10.800 --> 01:11:12.080
这种题一定要会做

01:11:12.080 --> 01:11:12.800
一定要会做

01:11:13.440 --> 01:11:13.680
好

01:11:13.680 --> 01:11:14.320
下一道题

01:11:14.320 --> 01:11:14.800
第四题

01:11:16.000 --> 01:11:16.720
我看一下这道题

01:11:20.850 --> 01:11:21.890
一样的分析方式

01:11:22.530 --> 01:11:23.810
你们能不能自己分析一下

01:11:24.850 --> 01:11:25.810
能不能自己分析一下

01:11:26.450 --> 01:11:27.490
一样的

01:11:27.570 --> 01:11:28.770
你不要在脑袋里面想

01:11:28.770 --> 01:11:30.290
很多同学就是不愿意动手

01:11:30.290 --> 01:11:31.250
实在在脑袋里面想

01:11:31.250 --> 01:11:32.930
脑袋里面想勇于响晕的

01:11:32.930 --> 01:11:34.050
把话出来

01:11:34.050 --> 01:11:35.410
CO里面有哪些Fu

01:11:35.410 --> 01:11:35.650
对吧

01:11:36.290 --> 01:11:37.250
Undefend

01:11:37.250 --> 01:11:38.130
然后还有啥

01:11:38.130 --> 01:11:38.450
82

01:11:39.250 --> 01:11:39.970
82是啥

01:11:39.970 --> 01:11:40.690
一个函数

01:11:40.690 --> 01:11:41.410
一个函数

01:11:42.210 --> 01:11:43.410
开始执行全局

01:11:43.410 --> 01:11:43.890
上下文

01:11:43.890 --> 01:11:44.530
开始执行了

01:11:45.250 --> 01:11:46.610
执行人把它复制为1

01:11:46.610 --> 01:11:47.730
它变成1了

01:11:47.730 --> 01:11:48.370
然后呢

01:11:48.370 --> 01:11:49.090
调用这个函数

01:11:49.090 --> 01:11:50.370
把3传进去

01:11:50.370 --> 01:11:51.010
于是呢

01:11:51.010 --> 01:11:52.210
又创建一个AO

01:11:52.210 --> 01:11:52.770
对不对

01:11:52.770 --> 01:11:53.730
这个函数的AO

01:11:54.610 --> 01:11:56.050
AO里面有哪些东西

01:11:56.290 --> 01:11:57.970
参数的值A等于多少

01:11:57.970 --> 01:11:58.370
3

01:11:58.930 --> 01:12:00.210
第二步确定辨量

01:12:00.210 --> 01:12:00.930
辨量有哪些

01:12:00.930 --> 01:12:01.890
是不是A1和A

01:12:02.770 --> 01:12:03.650
A1为多少

01:12:03.650 --> 01:12:04.370
Undefend

01:12:04.930 --> 01:12:06.130
A那是不是重明了

01:12:06.130 --> 01:12:07.730
A这个辨量重明了

01:12:07.730 --> 01:12:08.530
跟参数重明了

01:12:08.530 --> 01:12:09.890
不管直接忽略

01:12:10.770 --> 01:12:11.970
然后呢是函数

01:12:11.970 --> 01:12:13.010
函数是不是有个A

01:12:13.010 --> 01:12:13.970
函数要覆盖

01:12:13.970 --> 01:12:14.450
对吧

01:12:14.450 --> 01:12:15.250
函数要覆盖

01:12:16.450 --> 01:12:17.410
好变成这个样子了

01:12:18.290 --> 01:12:18.530
好

01:12:18.530 --> 01:12:18.930
接下来

01:12:20.290 --> 01:12:21.490
再来执行袋嘛

01:12:21.490 --> 01:12:22.610
再开始执行袋嘛

01:12:22.610 --> 01:12:24.210
把A的值负负给A1

01:12:24.850 --> 01:12:25.890
A的值负负给A1

01:12:25.970 --> 01:12:27.890
A1是不是也指向那个同一个函数了

01:12:27.890 --> 01:12:28.370
对吧

01:12:28.370 --> 01:12:29.330
指向同一个函数了

01:12:29.810 --> 01:12:30.050
好

01:12:30.050 --> 01:12:31.810
然后再把负的值负负给A

01:12:31.810 --> 01:12:33.010
看一下有没有负的值

01:12:33.010 --> 01:12:33.810
说没有

01:12:33.810 --> 01:12:34.370
没有的话

01:12:34.370 --> 01:12:35.490
是不是要找从外面去找

01:12:36.210 --> 01:12:37.090
外面有负的值

01:12:37.090 --> 01:12:38.210
把负的值负负给谁

01:12:38.210 --> 01:12:38.850
负负给A

01:12:38.850 --> 01:12:39.970
然后又变成1了

01:12:39.970 --> 01:12:41.730
因为你一定要画出来才能知道

01:12:41.730 --> 01:12:42.610
才能知道结果

01:12:42.610 --> 01:12:43.490
你不画的话

01:12:43.490 --> 01:12:44.290
脑袋要晕的

01:12:45.090 --> 01:12:45.410
好

01:12:45.410 --> 01:12:46.610
然后呢这句话看不看

01:12:46.610 --> 01:12:47.010
不看

01:12:47.010 --> 01:12:47.650
不看

01:12:49.090 --> 01:12:49.490
然后呢

01:12:50.050 --> 01:12:50.690
运行啥

01:12:50.690 --> 01:12:51.730
运行A1

01:12:51.730 --> 01:12:53.330
运行A1它是不是变成VO了

01:12:53.730 --> 01:12:55.170
A1跑上面去了

01:12:55.170 --> 01:12:55.410
对吧

01:12:55.890 --> 01:12:56.610
A1

01:12:57.090 --> 01:12:58.690
它这个函数变成VO了

01:12:58.690 --> 01:13:01.170
就是一层一层建立指行上下文

01:13:01.730 --> 01:13:02.210
好

01:13:02.210 --> 01:13:03.250
VO里边有它什么东西

01:13:03.250 --> 01:13:03.730
啥都没有

01:13:03.730 --> 01:13:04.050
对吧

01:13:04.050 --> 01:13:05.250
没有参数没有变量

01:13:05.250 --> 01:13:05.810
没有函数

01:13:05.810 --> 01:13:06.690
就这个函数里边

01:13:06.690 --> 01:13:07.410
它啥都没有

01:13:07.410 --> 01:13:08.610
它直接输出A

01:13:08.610 --> 01:13:09.010
好

01:13:09.010 --> 01:13:09.890
直接输出A里边

01:13:09.890 --> 01:13:11.090
因为它里边啥都没有

01:13:11.090 --> 01:13:12.930
那A里边是不是A是不是从外面找

01:13:12.930 --> 01:13:13.650
那输出啥

01:13:13.650 --> 01:13:14.770
是不是输出1

01:13:14.770 --> 01:13:15.330
对吧

01:13:15.330 --> 01:13:16.050
输出1

01:13:17.570 --> 01:13:18.530
这里输出1

01:13:18.850 --> 01:13:19.330
对吧

01:13:19.330 --> 01:13:19.650
好

01:13:19.650 --> 01:13:20.690
这个函数指行完了

01:13:20.690 --> 01:13:21.410
指行完了过后

01:13:21.410 --> 01:13:22.610
这个就是销毁掉

01:13:22.610 --> 01:13:23.250
销毁掉过后

01:13:23.250 --> 01:13:24.610
它是不是又变成VO了

01:13:24.610 --> 01:13:24.930
对吧

01:13:25.010 --> 01:13:25.970
又变成VO了

01:13:25.970 --> 01:13:27.090
那VO已经没东西了

01:13:27.090 --> 01:13:27.410
对吧

01:13:27.410 --> 01:13:28.370
A1指行完了过后

01:13:28.370 --> 01:13:29.010
就没东西了

01:13:30.050 --> 01:13:30.530
没东西了

01:13:31.730 --> 01:13:32.210
没问题吧

01:13:33.730 --> 01:13:34.450
没问题吧

01:13:34.450 --> 01:13:35.330
A1指行完了过后

01:13:35.330 --> 01:13:36.050
就没东西了

01:13:36.050 --> 01:13:36.610
没东西了

01:13:36.610 --> 01:13:37.410
它又消失了

01:13:37.410 --> 01:13:37.890
它又消失了

01:13:37.890 --> 01:13:40.210
那现在它又回到全球指行环境

01:13:40.210 --> 01:13:40.930
那么这个里边

01:13:40.930 --> 01:13:42.530
它现在既是VO又是既有

01:13:43.330 --> 01:13:44.050
最终就输出啥

01:13:44.050 --> 01:13:45.010
输出1就完事了

01:13:45.010 --> 01:13:45.410
对吧

01:13:45.410 --> 01:13:46.130
输出1就完事了

01:13:46.690 --> 01:13:46.850
好

01:13:46.850 --> 01:13:47.490
咱们来看一下吧

01:13:50.140 --> 01:13:50.540
对吧

01:13:50.540 --> 01:13:51.020
输出1

01:13:52.140 --> 01:13:53.340
一定要会做这些题

01:13:54.460 --> 01:13:55.660
这就是关于权

01:13:55.740 --> 01:13:56.540
执行上下文

01:13:58.220 --> 01:13:58.940
我们已经了

01:13:58.940 --> 01:14:01.020
执行上下文对战都讲完了

01:14:01.020 --> 01:14:01.580
都讲完了

01:14:02.300 --> 01:14:03.260
执行上下文对战

01:14:03.260 --> 01:14:04.300
就是战也讲完了

01:14:04.860 --> 01:14:05.740
那么我们之前说过

01:14:05.740 --> 01:14:07.420
粘的空间是有限的

01:14:07.420 --> 01:14:09.020
如果你反复调用函数

01:14:09.020 --> 01:14:11.100
不断的去迁套去调用函数

01:14:11.100 --> 01:14:13.740
有可能会把这个函的空间用完

01:14:13.740 --> 01:14:14.780
就比方说吧

01:14:14.780 --> 01:14:16.060
比方说我们在这里

01:14:16.780 --> 01:14:17.660
做一个很简单的例子

01:14:17.660 --> 01:14:18.940
我们之前说过了对吧

01:14:18.940 --> 01:14:19.980
无限帝规

01:14:19.980 --> 01:14:20.380
对不对

01:14:20.380 --> 01:14:21.420
无限帝规

01:14:21.420 --> 01:14:23.900
它会把内存空间占用完

01:14:23.900 --> 01:14:25.020
把粘的内存空间

01:14:25.100 --> 01:14:26.300
不是整个内存

01:14:26.300 --> 01:14:27.740
比方说一个函数a

01:14:27.740 --> 01:14:29.660
这个函数a里边就做一件事

01:14:29.660 --> 01:14:30.940
去重复调用函数a

01:14:30.940 --> 01:14:32.380
然后外面去调用一下

01:14:32.380 --> 01:14:33.260
你看一下

01:14:33.260 --> 01:14:34.460
这个空间很快就用完了

01:14:36.060 --> 01:14:36.540
运行

01:14:37.260 --> 01:14:37.980
你看一下

01:14:37.980 --> 01:14:38.780
它会爆错

01:14:38.780 --> 01:14:39.340
它说什么

01:14:39.900 --> 01:14:41.260
cord stack

01:14:41.260 --> 01:14:42.380
就是执行站

01:14:43.020 --> 01:14:43.660
溢出

01:14:43.660 --> 01:14:45.100
执行站溢出

01:14:45.100 --> 01:14:45.980
那怎么回事呢

01:14:45.980 --> 01:14:47.180
它现在那种方式就是

01:14:48.140 --> 01:14:48.940
就这种方式了

01:14:50.140 --> 01:14:51.580
这边就不用画了

01:14:52.540 --> 01:14:53.980
就是全局对吧

01:14:54.060 --> 01:14:55.420
全局里边去执行

01:14:55.420 --> 01:14:56.700
去执行

01:14:57.820 --> 01:14:58.860
然后执行

01:14:58.860 --> 01:15:00.300
全局里面的调用函数a

01:15:01.420 --> 01:15:03.420
这个函数a还没有运行完

01:15:03.420 --> 01:15:05.020
又在调用函数a

01:15:05.020 --> 01:15:05.980
那么我之前说过

01:15:05.980 --> 01:15:07.500
每一次函数调用都是单独的

01:15:07.500 --> 01:15:08.140
都是独立的

01:15:08.140 --> 01:15:08.940
为什么是独立的

01:15:08.940 --> 01:15:10.700
因为它们的执行上下吻都不一样

01:15:10.700 --> 01:15:11.900
执行的对象都不一样

01:15:12.460 --> 01:15:13.500
所以自然是独立的

01:15:13.500 --> 01:15:13.900
对吧

01:15:13.900 --> 01:15:14.620
自然是独立的

01:15:14.620 --> 01:15:16.140
那比方说这个里边有个变量

01:15:16.140 --> 01:15:17.340
一个变量a等于1

01:15:18.380 --> 01:15:19.260
比方说有个变量吧

01:15:19.740 --> 01:15:19.900
好

01:15:19.900 --> 01:15:21.500
这个变量肯定是不会共用的

01:15:21.900 --> 01:15:23.900
那一开始第一次调用a的时候

01:15:23.900 --> 01:15:24.780
它是不是指向一个

01:15:25.340 --> 01:15:26.460
指向一块空间

01:15:26.460 --> 01:15:27.020
对吧

01:15:27.020 --> 01:15:28.620
都是在帮助里面理解这个东西

01:15:29.260 --> 01:15:30.300
指向这一块空间

01:15:30.300 --> 01:15:32.220
它的什么vO对不对

01:15:32.220 --> 01:15:33.340
它里边的vO

01:15:33.340 --> 01:15:34.620
vO指向这块空间

01:15:34.620 --> 01:15:35.500
我就不画了

01:15:35.500 --> 01:15:37.420
vO里边是吧a为多少

01:15:37.420 --> 01:15:38.700
为1嘛对不对

01:15:38.700 --> 01:15:39.180
为1

01:15:40.300 --> 01:15:41.900
当你运行到这句话之后才为1

01:15:41.900 --> 01:15:43.340
一开始是undefend的

01:15:43.340 --> 01:15:43.660
好

01:15:43.660 --> 01:15:44.300
然后呢

01:15:44.300 --> 01:15:45.180
又去调用a

01:15:45.180 --> 01:15:46.540
那这个函数还没有运行完对吧

01:15:46.540 --> 01:15:48.940
又创建了一个又入战了一个东西

01:15:48.940 --> 01:15:50.380
那么这一次是不是又要去

01:15:50.460 --> 01:15:51.500
创建执行商家门

01:15:51.500 --> 01:15:51.900
对吧

01:15:52.460 --> 01:15:53.340
所以又是一个a

01:15:53.340 --> 01:15:54.380
他们是不一样的

01:15:54.860 --> 01:15:55.740
他们是不一样的

01:15:55.740 --> 01:15:57.020
他们是互相隔离的

01:15:57.020 --> 01:15:57.980
又运行

01:15:57.980 --> 01:15:58.940
是不是又创建

01:15:58.940 --> 01:15:59.420
对吧

01:15:59.420 --> 01:16:01.260
那这样子是不是无休执行下去了

01:16:01.260 --> 01:16:03.100
只到把这个占的空间占满

01:16:03.100 --> 01:16:04.220
然后就直接爆出来了

01:16:04.220 --> 01:16:05.340
占的空间很小的

01:16:05.340 --> 01:16:05.900
很小的

01:16:07.260 --> 01:16:08.540
这是关于这一块

01:16:10.140 --> 01:16:10.940
就没了

01:16:10.940 --> 01:16:12.940
执行商家门这一块

01:16:12.940 --> 01:16:14.140
它的作用是

01:16:14.140 --> 01:16:15.660
帮助里理解

01:16:15.660 --> 01:16:17.100
整个程序的执行

01:16:18.060 --> 01:16:18.860
以及呢

01:16:20.860 --> 01:16:21.260
就是

01:16:23.020 --> 01:16:23.900
以及他

01:16:23.900 --> 01:16:26.220
以及他就是做面试体

01:16:26.220 --> 01:16:27.260
需要用这一块知识

01:16:27.260 --> 01:16:28.860
好好去体会理解一下

01:16:29.740 --> 01:16:31.340
你只有把这一些课的东西

01:16:31.340 --> 01:16:33.660
体会就是搞清楚了

01:16:33.660 --> 01:16:34.540
那么下一课

01:16:34.540 --> 01:16:35.180
我讲那个

01:16:35.740 --> 01:16:36.940
作用预练的时候

01:16:37.580 --> 01:16:39.020
你才知道是怎么回事

01:16:39.020 --> 01:16:39.500
好吧

