WEBVTT

00:00.000 --> 00:15.540
这一章 咱们学习标准库

00:15.540 --> 00:20.060
我再来先解释一下 标准库怎么去理解

00:20.060 --> 00:30.540
首先 库这个词 库这个词 它的英文叫做Nibblery

00:30.540 --> 00:33.100
我写对面

00:33.100 --> 00:39.100
平时我们写的都是写的是lab 简写 全写叫做Nibblery

00:39.100 --> 00:46.590
应该是这样子写的嘛 应该没错 看一下 查一下 查一下 这写错了就尴尬了

00:46.590 --> 00:50.590
平时我们就直接写的是三个词 它表示的是库的意思

00:50.590 --> 00:54.590
Nibblery 对 库 它表示什么意思呢

00:54.590 --> 00:58.390
就是一个仓库的意思 它里边可以存放一些东西

00:58.390 --> 01:00.390
比方说我们这里说的标准库 对吧

01:00.390 --> 01:05.390
指的是什么意思呢 指的是GS已经给你写好了一些对象了

01:05.390 --> 01:09.990
已经给你写好了一些函数了 那么你直接去使用就完事了

01:09.990 --> 01:13.590
就是它把一些常用的功能 已经给你写好了

01:13.590 --> 01:16.590
咱们已经学过了对象 也学过了函数

01:16.590 --> 01:19.790
它已经给你写好了一些函数 以及一些对象

01:19.790 --> 01:22.990
我们只需要去学习如何使用就完事了

01:22.990 --> 01:28.790
咱们整个这一章 学习的就是GS给你提供的

01:28.790 --> 01:31.990
一些写好的函数和写好的对象

01:31.990 --> 01:35.790
它里边有哪些属性 有哪些方法 它有什么样的功能

01:35.790 --> 01:38.390
我们怎么去使用它 学习的就是这么一个东西

01:38.390 --> 01:40.990
所以本章的难度已经非常非常低了

01:40.990 --> 01:43.390
如果你前边什么函数啊 流程控制啊

01:43.390 --> 01:45.790
这些东西都全部学会了的话 那么本章呢

01:45.790 --> 01:49.990
就是非常非常轻松 而且呢本章能够做出丰富的效果

01:49.990 --> 01:53.590
因为它已经给你写好了很多功能强大的函数

01:53.590 --> 01:56.590
因此我们可以利用这些函数啊和对象啊 属性啊

01:56.590 --> 01:58.590
这些东西可以实现丰富的效果

01:58.590 --> 02:00.890
所以本章的学习来说是非常有意思的

02:00.890 --> 02:04.690
并且呢难度也很低啊 裤子就是这么个意思啊

02:04.690 --> 02:08.290
表示一个仓库 它里边存放了一些有用的东西

02:08.290 --> 02:11.390
有的时候呢 我们还会说另外一个词啊

02:11.390 --> 02:13.290
就是这里说我们说的是标准库

02:13.290 --> 02:18.090
其实也可以称之为标准API 标准API

02:18.090 --> 02:19.790
这个API是什么意思呢

02:19.790 --> 02:25.790
这个API呢叫做应用程序 编程接口啊

02:25.890 --> 02:30.490
它的全称叫做Application Programming

02:30.490 --> 02:32.290
Gramming

02:32.290 --> 02:35.990
然后呢是Interface

02:35.990 --> 02:37.490
Application应用程序的意思

02:37.490 --> 02:39.390
所以说我们手机应用叫做叫做什么呢

02:39.390 --> 02:40.590
App 对吧 App

02:40.590 --> 02:42.690
它的全称叫做Application

02:42.690 --> 02:45.390
Programming呢表示的是编程

02:45.390 --> 02:47.990
Interface呢表示的是接口

02:47.990 --> 02:49.890
应用程序编程接口

02:49.890 --> 02:53.090
这两个呢其实含义呢

02:53.090 --> 02:55.690
有点接近 但是也不完全一样

02:55.790 --> 02:59.290
这个库呢这个Library呢表示的彻重点呢

02:59.290 --> 03:01.790
表示的是这里边存放了很多东西

03:01.790 --> 03:03.690
它彻重表示这个东西

03:03.690 --> 03:06.090
API呢它彻重于表示的是

03:06.090 --> 03:07.990
我怎么去使用这些东西

03:07.990 --> 03:10.090
它是使用层面的

03:10.090 --> 03:11.890
编程接口 接口怎么理解呢

03:11.890 --> 03:13.390
就咱们笔记本电脑上

03:13.390 --> 03:14.590
不是有很多接口吗

03:14.590 --> 03:16.690
或者说手机上不是有很多接口吗

03:16.690 --> 03:18.690
有些是充电的接口

03:18.690 --> 03:20.590
有些是Type-C 对吧

03:20.590 --> 03:23.090
现在普遍上都是Type-C的

03:23.090 --> 03:24.890
或者是一些老的手机呢

03:24.990 --> 03:27.490
用的是之前的安卓接口

03:27.490 --> 03:29.190
或者是苹果的接口 对吧

03:29.190 --> 03:32.090
不同的接口的使用方式是不一样的

03:32.090 --> 03:34.690
这里的软件里面的接口呢

03:34.690 --> 03:36.690
表示的是你怎么去使用它

03:36.690 --> 03:37.790
就是给力的一个东西

03:37.790 --> 03:40.590
你怎么去使用就是接口

03:40.590 --> 03:41.690
这里有两种说法

03:41.690 --> 03:43.990
都是一样API和库都是一样

03:43.990 --> 03:45.290
都是类似的意思

03:45.290 --> 03:46.690
都是给力的一些东西

03:46.690 --> 03:50.290
然后你要学习如何去使用它

03:50.290 --> 03:52.190
什么叫标准呢

03:52.190 --> 03:54.090
这个标准又怎么去理解呢

03:54.090 --> 03:57.590
咱们之前讲介石该说的时候就说过

03:57.590 --> 03:59.290
我们的介石语言啊

03:59.290 --> 04:01.190
它是跟环境无关的

04:01.190 --> 04:03.490
它可以在浏览器环境里边执行

04:03.490 --> 04:06.290
也可以在漏的环境里边

04:06.290 --> 04:07.290
比方说以后呢

04:07.290 --> 04:08.490
我们学习到漏的

04:08.490 --> 04:09.690
学习到服务系端

04:09.690 --> 04:11.090
或者是在手机端

04:11.090 --> 04:13.390
或者是在桌面应用程序端

04:13.390 --> 04:15.090
都可以使用介石代码

04:15.090 --> 04:17.090
因此呢介石本身是个语言

04:17.090 --> 04:18.590
他告诉你怎么去说话

04:18.590 --> 04:20.290
他跟在哪里执行

04:20.290 --> 04:21.490
没有什么关系

04:21.490 --> 04:23.090
我们这里说的标准裤指的

04:23.090 --> 04:25.190
就是Akma script标准

04:25.190 --> 04:31.590
Akma script标准

04:31.590 --> 04:33.090
说的是语言标准

04:33.090 --> 04:35.890
就是无论我们目前学习的浏览器

04:35.890 --> 04:38.590
还是呢将来学习的服务器手机

04:38.590 --> 04:40.190
或者是桌面应用程序

04:40.190 --> 04:41.690
这些不同的环境里边

04:41.690 --> 04:43.890
他们这些东西都是一样的

04:43.890 --> 04:46.790
就是本账的是通用的学习的学习东西

04:46.790 --> 04:47.090
以后呢

04:47.090 --> 04:48.790
你们到了漏的环境里边

04:48.790 --> 04:50.790
也可以使用本账学习东西

04:50.790 --> 04:53.890
因为它是标准的语言标准里边东西

04:53.890 --> 04:55.190
你看这意思吧

04:55.190 --> 04:57.390
这就是咱们这一张学习的东西

04:57.390 --> 04:58.090
明白了吧

04:58.090 --> 04:59.590
我们这一张学习是咋呢

04:59.590 --> 05:01.990
学习的就是语言标准里边

05:01.990 --> 05:03.790
给你提供了哪些对象

05:03.790 --> 05:05.090
哪些函数

05:05.090 --> 05:06.790
这些函数和对象里边

05:06.790 --> 05:07.790
有哪些属性

05:07.790 --> 05:09.190
哪些成员方法

05:09.190 --> 05:10.690
可以跟我们使用

05:10.690 --> 05:12.590
就学习这么个东西

05:12.590 --> 05:12.790
好

05:12.790 --> 05:13.590
第一节课

05:13.590 --> 05:13.990
第一节课

05:13.990 --> 05:17.690
我们首先来认识这么两个构造函数

05:17.690 --> 05:19.590
一个构造函数是Object

05:19.690 --> 05:21.190
我们之前讲过了对吧

05:21.190 --> 05:22.890
它是用来创建对象的

05:22.890 --> 05:25.890
任何一个对象是通过它来创建的

05:25.890 --> 05:27.290
然后还有一个方形

05:27.290 --> 05:28.990
方形也是个构造函数

05:28.990 --> 05:29.690
我当时还说了

05:29.690 --> 05:31.090
这个函数的比较特殊

05:31.090 --> 05:33.090
它是在介石引擎启动的时候

05:33.090 --> 05:35.190
直接给你安放在内存里边的

05:35.190 --> 05:36.090
它用来做什么呢

05:36.090 --> 05:37.990
用来创建其他函数的

05:37.990 --> 05:39.390
以反而是通过这个构造函数

05:39.390 --> 05:40.690
创建的对象了

05:40.690 --> 05:42.690
就是一个普通函数

05:42.690 --> 05:44.490
明白这个意思吧

05:44.490 --> 05:45.390
我们一个个来

05:45.390 --> 05:46.890
首先是Object

05:46.890 --> 05:48.690
Object的成里边有哪些属性

05:48.690 --> 05:50.590
有哪些方法可以使用

05:50.590 --> 05:52.990
这里我们就直接按照

05:52.990 --> 05:54.390
就是官方稳当

05:54.390 --> 05:55.590
也不是官方稳当了

05:55.590 --> 05:59.190
MDN上面的稳当的说明来进行查看

05:59.190 --> 06:00.190
我们怎么来搜呢

06:00.190 --> 06:01.190
我们就这样搜

06:01.190 --> 06:04.690
在百度里边去搜索JavaScript

06:04.690 --> 06:06.790
空格然后Object

06:06.790 --> 06:08.990
空格然后MDN

06:08.990 --> 06:11.590
你看第一条就是Object

06:11.590 --> 06:12.790
MDN

06:12.790 --> 06:13.990
看一下

06:13.990 --> 06:17.390
看MDN上面说的有哪些东西

06:17.390 --> 06:18.490
它说什么呢

06:18.590 --> 06:21.590
它说Object是一个构造函数

06:21.590 --> 06:24.390
它用来创建一个对象包装器

06:24.390 --> 06:25.890
那具体是什么意思呢

06:25.890 --> 06:26.890
咱们往下面看

06:26.890 --> 06:28.290
往下面看描述

06:28.290 --> 06:30.590
它说Object的构造函数

06:30.590 --> 06:33.990
为给定的值创建一个对象包装器

06:33.990 --> 06:36.490
如果给定的是NOW或者是Undefend的

06:36.490 --> 06:38.590
它会创建并返回一个空对象

06:38.590 --> 06:40.390
否则的话将返回一个

06:40.390 --> 06:43.590
与给定值对应类型的对象

06:44.790 --> 06:45.990
什么意思

06:45.990 --> 06:46.590
啥意思

06:46.590 --> 06:47.590
咱们来看一下吧

06:47.590 --> 06:49.390
我们这里随便介绍一下

06:49.390 --> 06:51.290
介绍一下TES11

06:51.290 --> 06:54.190
来看一下它到底啥意思

06:54.190 --> 06:55.190
把它运行出来

06:55.190 --> 06:57.290
好 看着

06:57.290 --> 06:58.190
啥意思呢

06:58.190 --> 07:00.590
比方说咱们这里写一个

07:00.590 --> 07:03.590
写一个就是A

07:03.590 --> 07:06.190
然后留一个Objects

07:06.190 --> 07:07.590
这里面写个NOW

07:07.590 --> 07:09.590
或者写个Undefend都一样的

07:09.590 --> 07:12.090
它说了NOW和Undefend是一样的

07:12.090 --> 07:14.290
如果给定的值是NOW和Undefend的话

07:14.290 --> 07:15.290
它得到的是什么呢

07:15.290 --> 07:17.190
得到的是一个空对象

07:17.190 --> 07:18.190
我们看一下这个辩量

07:18.190 --> 07:20.090
你看是不是空对象

07:20.090 --> 07:21.190
对吧

07:21.190 --> 07:23.390
这个跟我们之前讲的冲突冲突

07:23.390 --> 07:24.590
不冲突

07:24.590 --> 07:25.590
之前我们咋写的

07:25.590 --> 07:26.890
是这样子写的对吧

07:26.890 --> 07:29.490
没有给这个构造函数任何参数

07:29.490 --> 07:31.690
没有给参数的时候

07:31.690 --> 07:33.790
是不是参数的值就是Undefend的

07:33.790 --> 07:34.590
对吧

07:34.590 --> 07:35.990
参数的值是不是Undefend的

07:35.990 --> 07:37.190
就是Undefend的

07:37.190 --> 07:38.890
所以说没有给参数的时候

07:38.890 --> 07:40.690
创建的是不是就是一个空对象

07:40.690 --> 07:42.390
啥属性都没有的空对象

07:42.390 --> 07:43.790
就这么个意思

07:43.790 --> 07:45.090
这是它第一个

07:45.090 --> 07:46.890
它这句话的第一个意思

07:46.890 --> 07:49.390
第二个意思说的是什么呢

07:49.390 --> 07:50.490
第二个意思就是说

07:50.490 --> 07:53.290
如果你给的值是有一个值

07:53.290 --> 07:55.990
比方说给的一个值

07:55.990 --> 07:58.790
比方说咱们给的是一个数字1

07:58.790 --> 08:00.290
给的是数字1

08:00.290 --> 08:02.190
那么得到的这个S是啥玩意儿

08:02.190 --> 08:03.390
你看一下

08:03.390 --> 08:04.890
这个S是啥玩意儿

08:04.890 --> 08:07.090
这个就相当于是

08:07.090 --> 08:09.790
你这样子写的NO.1

08:09.790 --> 08:10.890
明白这个意思吧

08:10.890 --> 08:12.390
因为你给的是数字

08:12.390 --> 08:14.290
所以说对象的这个

08:14.290 --> 08:15.890
Object的构造函数

08:15.890 --> 08:18.990
它会帮你去创建一个NO.1的对象

08:18.990 --> 08:20.590
NO.1的包装器

08:20.590 --> 08:22.590
你看这个意思吧

08:22.590 --> 08:23.490
就这样子写

08:23.490 --> 08:25.390
就相当于是下面这样子写法

08:25.390 --> 08:27.590
是一样的

08:27.590 --> 08:30.090
如果你给它是一个制服串

08:30.090 --> 08:31.090
Object是

08:31.090 --> 08:33.490
给它是一个制服串

08:33.490 --> 08:37.390
那么它就相当于是你这样子写的

08:37.390 --> 08:39.390
就相当于是你这样子写

08:39.390 --> 08:40.390
你看这个意思吧

08:40.390 --> 08:41.390
是一样的

08:41.390 --> 08:42.390
两个是一样的

08:42.390 --> 08:44.190
它就是通过这个Object的程度

08:44.190 --> 08:45.690
可以方便的

08:45.690 --> 08:48.590
用统一的一种写法

08:48.590 --> 08:52.090
创建多种不同的包装器对象

08:52.090 --> 08:53.290
就这么个意思

08:53.290 --> 08:56.090
当然我们平时用Object的话

08:56.090 --> 08:57.990
几乎不咋用

08:57.990 --> 09:00.290
因为我们平时的话用Object

09:00.290 --> 09:02.490
都是用来创建一个普通对象

09:02.490 --> 09:03.390
一个普通对象的话

09:03.390 --> 09:05.790
我们直接使用两个大过号书写就完事了

09:05.790 --> 09:07.890
不太会用这个构造函数

09:07.890 --> 09:08.890
但是你要知道

09:08.890 --> 09:10.090
两个大过号书写

09:10.090 --> 09:11.390
实际上是个语法堂

09:11.390 --> 09:13.990
它注意中是通过它来创建的

09:13.990 --> 09:15.890
最终是通过它来创建的对象

09:15.890 --> 09:16.890
明白这个意思吗

09:16.890 --> 09:18.890
OK

09:18.890 --> 09:20.890
咱们我们往下看

09:20.890 --> 09:21.690
它下面就说到了

09:21.690 --> 09:23.090
这个Object的程度

09:23.090 --> 09:24.290
它有哪些属性

09:24.290 --> 09:25.490
有哪些方法

09:25.490 --> 09:26.790
它首先说到了什么

09:26.790 --> 09:28.490
构造函数的属性

09:28.490 --> 09:30.090
和构造函数的方法

09:30.090 --> 09:31.390
什么意思呢

09:31.390 --> 09:34.290
以后你在标准文档里面看到这个东西

09:34.290 --> 09:35.990
你就马上要反映过来

09:35.990 --> 09:36.990
它说的是什么

09:36.990 --> 09:39.790
说的是静态方法

09:39.790 --> 09:41.190
静态属性

09:41.190 --> 09:42.690
指的是这么个意思

09:42.790 --> 09:44.890
它这里把属性和方法是分开的

09:44.890 --> 09:46.690
属性表示的是一个具体的取词

09:46.690 --> 09:48.590
就是除函数之外的取词

09:48.590 --> 09:50.790
方法表示的是

09:50.790 --> 09:52.590
这个属性的指的就是一个函数

09:52.590 --> 09:54.490
它把它分开的

09:54.490 --> 09:56.490
它这里说的构造函数的属性

09:56.490 --> 09:57.990
构造函数的方法指的是什么呢

09:57.990 --> 10:00.290
指的是通过

10:00.290 --> 10:03.890
通过这个就是

10:03.890 --> 10:07.590
构造函数名字来调用的属性和方法

10:07.590 --> 10:09.990
指的是静态属性和静态方法

10:09.990 --> 10:11.490
比方它说到这个属性

10:12.490 --> 10:14.590
这个属性目前对它来说没啥用

10:14.590 --> 10:16.990
它的指固定为一

10:16.990 --> 10:18.290
它实际上啥意思呢

10:18.290 --> 10:21.190
实际上表示的是这个构造函数有几个参数

10:21.190 --> 10:22.390
它有几个参数

10:22.390 --> 10:24.890
我们看到刚才我们写的东西

10:24.890 --> 10:26.490
构造函数里面是不是有一个参数

10:26.490 --> 10:27.090
对吧

10:27.090 --> 10:28.490
这个构造函数需要一个参数

10:28.490 --> 10:29.490
当然你可以不传递

10:29.490 --> 10:32.290
不传递的话就是undefined的

10:32.290 --> 10:33.990
所以说我们可以通过这个属性

10:33.990 --> 10:34.890
open函数

10:34.890 --> 10:36.790
点函数

10:36.790 --> 10:38.590
你看是不是静态的属性

10:38.590 --> 10:39.490
没问题吧

10:39.490 --> 10:42.990
通过构造函数名字来使用的属性

10:42.990 --> 10:44.290
叫静态属性

10:44.290 --> 10:46.690
这个静态的属性固定为一

10:46.690 --> 10:47.890
这个东西没啥用

10:47.890 --> 10:48.690
只是告诉大家

10:48.690 --> 10:50.090
它这里说的是静态属性

10:51.290 --> 10:53.290
咱们再看一下静态方法

10:53.290 --> 10:55.390
静态方法有一些地方有些用

10:55.390 --> 10:56.990
目前我讲不完

10:56.990 --> 10:59.190
有些东西我们需要在进阶部分讲解

10:59.190 --> 10:59.790
有些东西

10:59.790 --> 11:02.190
而且有些东西平时几乎不打用

11:02.190 --> 11:03.390
所以说也不会讲解

11:03.390 --> 11:05.190
还有一些东西已经过时了

11:05.190 --> 11:07.390
或者是已经不再是标准里边东西了

11:07.390 --> 11:09.390
所以说也不再讲解

11:09.490 --> 11:11.290
目前我们讲解这么一些

11:12.290 --> 11:14.090
第一个是这个

11:15.690 --> 11:18.790
这是一个静态方法

11:19.790 --> 11:20.490
它什么意思

11:20.490 --> 11:22.090
我们可以点击进去看一下

11:22.390 --> 11:22.890
点击进去

11:22.890 --> 11:24.490
按住键盘的ctrl键

11:24.490 --> 11:25.990
可以新打开一个窗口

11:25.990 --> 11:26.690
点击一下

11:27.290 --> 11:28.290
看一下这个tiss

11:29.090 --> 11:29.990
看一下这个方法

11:29.990 --> 11:32.390
这个方法还有的时候还蛮有用的

11:32.990 --> 11:34.190
我们先讲解一下吧

11:34.790 --> 11:35.790
它又没有参数了

11:35.790 --> 11:36.890
有一个参数看没

11:36.890 --> 11:37.490
它给你讲了

11:38.090 --> 11:40.090
你需要传一个参数

11:40.390 --> 11:41.890
这个参数下面有解释

11:42.290 --> 11:42.890
什么意思呢

11:42.890 --> 11:44.690
参数你要传一个对象进去

11:44.890 --> 11:46.190
你要传一个对象进去

11:46.490 --> 11:48.690
它会这个方法会给你返回什么呢

11:48.890 --> 11:50.590
返回的结果是

11:50.690 --> 11:52.390
这个对象可以的

11:52.490 --> 11:56.790
可以每一句的所有属性名的制服创数组

11:57.190 --> 11:58.390
什么叫可每一句的

11:58.390 --> 11:59.090
现在别管

11:59.390 --> 11:59.890
现在别管

11:59.890 --> 12:00.890
我们以后再说

12:01.390 --> 12:03.190
现在你只需要知道它得到的是什么

12:03.190 --> 12:03.890
得到的是

12:04.190 --> 12:07.290
这个对象所有的制服创数组

12:07.590 --> 12:09.890
所有的属性名组成了制服创数组

12:10.290 --> 12:10.990
举个例子吧

12:11.790 --> 12:12.490
比方说

12:14.290 --> 12:17.490
我们这一张全是学习的是别人给你提供的东西

12:17.490 --> 12:18.390
你怎么去用它

12:18.990 --> 12:19.590
有一个对象

12:19.590 --> 12:20.790
我们随便写个对象

12:21.690 --> 12:22.390
x

12:23.290 --> 12:23.890
y

12:25.190 --> 12:26.190
然后z

12:26.790 --> 12:27.490
随便写吧

12:27.590 --> 12:28.190
随便写

12:28.190 --> 12:28.790
布尔吧

12:30.390 --> 12:30.990
随便写

12:31.790 --> 12:34.290
咱们可以利用这个静态的

12:34.790 --> 12:36.490
静态的方法

12:36.790 --> 12:37.890
object

12:38.090 --> 12:38.590
第二

12:38.590 --> 12:38.890
什么

12:39.390 --> 12:39.890
key

12:40.090 --> 12:41.090
key表示什么意思

12:41.290 --> 12:42.090
表示j

12:43.290 --> 12:44.090
不是这个j

12:47.790 --> 12:48.690
不是这个j

12:49.690 --> 12:50.490
不是这个j

12:50.690 --> 12:52.690
j叫做key

12:52.690 --> 12:53.490
叫这个j

12:53.590 --> 12:54.290
j盘的j

12:54.590 --> 12:55.390
j盘的j

12:55.790 --> 12:56.690
j表示什么意思呢

12:56.690 --> 12:58.590
你可以认为j就是属性的名字

12:58.790 --> 12:59.690
属性的名字

12:59.990 --> 13:01.490
属性的值就叫做值

13:01.690 --> 13:02.790
j和值

13:02.790 --> 13:05.090
我们可以把一个属性的叫做j值对

13:05.590 --> 13:06.690
一个j 一个值

13:06.690 --> 13:07.690
成为一对

13:07.690 --> 13:08.690
叫做j值对

13:09.290 --> 13:10.890
这个key的意思表示的是j

13:11.090 --> 13:11.790
获取的是什么

13:11.790 --> 13:12.790
获取的是j

13:13.090 --> 13:14.390
这里边要传参数呢

13:14.390 --> 13:15.390
要传一个参数

13:15.390 --> 13:16.090
参数的名

13:16.090 --> 13:17.690
参数就传一个对象进去

13:18.190 --> 13:19.690
比方说我们把个对象传进去

13:20.490 --> 13:21.690
于是它就可以

13:21.690 --> 13:23.890
这个函数它就可以帮我们获取

13:24.090 --> 13:25.090
这个对象里边

13:25.090 --> 13:26.990
所有的属性名

13:27.290 --> 13:28.390
组成的数组

13:28.890 --> 13:29.490
看一下

13:29.490 --> 13:30.090
看一下

13:31.490 --> 13:32.090
组成的数组

13:32.090 --> 13:33.490
我们输出这个数组看一下

13:33.690 --> 13:35.290
ar 输出

13:35.490 --> 13:36.290
保存看一下

13:38.290 --> 13:38.990
可以看到

13:39.390 --> 13:40.390
输出得到的是什么

13:40.390 --> 13:42.290
得到的数组就是xyz

13:42.890 --> 13:43.590
能看懂吗

13:43.890 --> 13:44.790
是非常简单

13:45.290 --> 13:45.590
好

13:45.590 --> 13:47.390
那如果这个obj

13:47.590 --> 13:49.190
如果这个obj是一个数组

13:49.190 --> 13:50.290
数组是不是对象

13:50.590 --> 13:51.690
是不是对象数组

13:51.990 --> 13:52.790
当然是对象

13:52.790 --> 13:53.690
为什么不是对象

13:53.690 --> 13:54.490
我们之前说过

13:55.090 --> 13:56.090
如果它是一个数组

13:56.090 --> 13:57.290
得到的结果是什么

13:57.290 --> 13:59.390
你看得到的是012345

13:59.390 --> 13:59.890
看到没

14:00.390 --> 14:01.490
这是数组的属性

14:02.090 --> 14:02.690
没问题吧

14:03.290 --> 14:04.390
通过这个函数

14:04.390 --> 14:05.790
它可以得到一个对象的

14:06.090 --> 14:08.090
所有的属性组成

14:08.090 --> 14:09.090
属性的名字

14:09.090 --> 14:10.790
组成的数组

14:11.790 --> 14:12.890
这个函数

14:13.090 --> 14:14.390
有的时候可能会有用

14:14.390 --> 14:15.990
咱们现在有这么个印象

14:16.790 --> 14:17.690
这个函数完了

14:17.890 --> 14:18.990
咱们再看下一个函数

14:19.490 --> 14:20.390
values

14:20.790 --> 14:22.990
objects也是个静态方法

14:23.190 --> 14:23.890
values

14:24.490 --> 14:25.290
这个方法

14:25.290 --> 14:27.290
跟keyz的用法是一样的

14:27.490 --> 14:30.190
keyz得到的是属性名

14:30.790 --> 14:33.790
这个values得到的是属性值

14:33.790 --> 14:35.290
得到的是属性值

14:35.590 --> 14:36.790
咱们还是同一个对象

14:38.490 --> 14:40.590
咱们这里把它换成values

14:40.990 --> 14:41.590
看一下

14:41.590 --> 14:42.590
换成value是

14:42.790 --> 14:43.390
保存

14:43.390 --> 14:43.990
看一下

14:45.690 --> 14:46.190
这边

14:46.890 --> 14:47.590
你看了没

14:47.990 --> 14:49.490
通这个values得到的是什么

14:49.490 --> 14:51.290
得到的是属性值的数组

14:51.290 --> 14:51.790
看没

14:52.290 --> 14:53.690
属性值的数组

14:54.290 --> 14:54.990
没问题吧

14:55.790 --> 14:56.990
这是属性值的数组

14:58.090 --> 14:59.290
再来

14:59.690 --> 15:00.990
它还有一个东西

15:01.590 --> 15:02.590
叫做

15:03.890 --> 15:04.590
entress

15:04.890 --> 15:05.590
entress

15:05.790 --> 15:06.890
它得到的是什么呢

15:06.890 --> 15:08.290
得到的也是一个数组

15:08.390 --> 15:09.690
它这个数组的每一项

15:09.690 --> 15:11.290
它既包含属性名

15:11.290 --> 15:12.690
又包含属性值

15:13.090 --> 15:14.090
咱们来看一下这个

15:14.790 --> 15:15.490
entress

15:17.390 --> 15:18.490
以后我们做一面的时候

15:18.490 --> 15:19.290
可能会用到

15:19.690 --> 15:20.290
可能会用到

15:20.290 --> 15:21.290
有这么个印象就行了

15:21.290 --> 15:21.890
不用去背

15:22.490 --> 15:25.490
entress表示的是得到的是属性名

15:25.590 --> 15:27.090
和属性值的数组

15:27.290 --> 15:28.290
保存看一下

15:28.290 --> 15:29.190
还是个对象

15:29.390 --> 15:31.590
得到个对象的每一个属性名和属性值

15:31.790 --> 15:32.290
看一下

15:32.890 --> 15:33.890
得到的结果就是这个

15:34.190 --> 15:34.590
看没

15:34.790 --> 15:36.190
每一项是一个数组

15:36.190 --> 15:37.990
它看整个是一个数组

15:38.190 --> 15:39.790
每一项它又是一个数组

15:39.890 --> 15:41.090
这个数组有两项

15:41.090 --> 15:42.190
第一项是属性名

15:42.190 --> 15:43.190
第二项是属性值

15:43.190 --> 15:43.590
看没

15:44.090 --> 15:44.490
你想啊

15:44.490 --> 15:46.290
它除了用这种方式还能怎么办呢

15:46.990 --> 15:47.690
属性的名字

15:47.690 --> 15:48.490
属性的值

15:48.490 --> 15:48.890
看没

15:49.690 --> 15:50.390
属性的名字

15:50.390 --> 15:50.990
属性的值

15:50.990 --> 15:52.190
它变成这么一种结构了

15:52.990 --> 15:53.490
ok

15:53.590 --> 15:54.890
这是关于第一个

15:55.990 --> 15:58.290
就是这个静态

15:58.490 --> 15:59.690
静态的方法里边

15:59.690 --> 16:01.090
我们先认识这么三个

16:01.390 --> 16:03.990
三个entress keys和values

16:04.890 --> 16:05.290
好吧

16:05.890 --> 16:06.290
好

16:06.290 --> 16:07.290
接下来我们再看啊

16:07.390 --> 16:09.690
除了静态的属性和方法之外

16:09.790 --> 16:11.790
它还有很多的实力方法

16:11.790 --> 16:12.190
你看

16:12.190 --> 16:13.290
object的实力

16:13.990 --> 16:15.090
实力就是一个对象

16:15.290 --> 16:17.190
通过object的构造还是创建了对象

16:17.690 --> 16:19.490
也叫做圆形方法

16:19.490 --> 16:20.290
圆形

16:20.690 --> 16:22.290
圆形属性

16:22.490 --> 16:23.190
当然圆形了

16:23.190 --> 16:25.490
我们现在还没有学习这个概念

16:25.490 --> 16:26.590
所以说我上一课呢

16:26.690 --> 16:27.990
就是在上一章的时候

16:28.190 --> 16:29.290
并没有讲圆形

16:29.590 --> 16:31.390
先不着急去学圆形

16:31.390 --> 16:32.890
我们现在就把它看作是

16:33.290 --> 16:34.190
实力方

16:34.190 --> 16:36.090
实力属性和实力方法

16:36.290 --> 16:36.490
好

16:36.490 --> 16:37.290
下面说的属性呢

16:37.290 --> 16:39.990
指的是实力的属性和实力的方法

16:40.190 --> 16:41.490
属性没有什么东西啊

16:41.590 --> 16:43.690
大家看这个标准文档里边啊

16:43.690 --> 16:45.090
这个官方这个文档里边

16:45.090 --> 16:46.190
他写的这么个东西

16:46.390 --> 16:48.290
object的proto type

16:48.990 --> 16:50.290
这个表示圆形

16:50.290 --> 16:51.890
圆形的我们现在还没有学习

16:51.890 --> 16:52.690
没关系

16:52.990 --> 16:53.890
没关系

16:53.990 --> 16:55.590
你就看后边这一部分就行了

16:56.190 --> 16:56.890
后边这一部分

16:56.890 --> 16:59.190
他告诉你这个实力的属性名字是什么

17:00.390 --> 17:02.590
目前的object的实力属性呢

17:02.590 --> 17:03.590
没有什么好说的

17:03.590 --> 17:04.590
目前都用不上

17:04.790 --> 17:05.090
而且呢

17:05.090 --> 17:05.590
有一些呢

17:05.590 --> 17:07.590
也不再是不推荐你使用的

17:07.890 --> 17:07.990
好

17:07.990 --> 17:08.990
我们往下面看

17:09.190 --> 17:10.090
主要是往下面看

17:10.090 --> 17:10.890
看方法

17:11.990 --> 17:14.290
object的这个对象里边呢

17:14.290 --> 17:15.590
有一些实力方法

17:15.590 --> 17:16.690
我们这里要讲几个

17:16.690 --> 17:17.590
要讲几个

17:17.990 --> 17:18.190
好

17:18.190 --> 17:19.990
第一个方法叫做toestune

17:20.290 --> 17:21.390
toestune方法

17:21.990 --> 17:22.590
这个方法呢

17:22.590 --> 17:24.990
我们打开页面看一下啊

17:25.190 --> 17:26.190
这个toestune方法

17:26.290 --> 17:27.190
表示的是

17:27.290 --> 17:30.090
返回一个对象的制服串

17:30.290 --> 17:31.490
返回一个对象的制服串

17:31.490 --> 17:32.390
他没有参数

17:32.790 --> 17:34.390
这个方法返回的是一个制服串

17:34.990 --> 17:36.690
我们之前学过函数学过返回值

17:36.690 --> 17:37.090
对吧

17:37.090 --> 17:38.390
我告诉你返回的制服串

17:38.390 --> 17:39.590
那就你就马上知道

17:39.590 --> 17:39.790
哎

17:39.790 --> 17:40.790
这个方法运行完了过后

17:40.790 --> 17:42.390
我可以用一个辩量来接收

17:42.490 --> 17:43.490
这个方法的值

17:43.590 --> 17:44.590
这个方法返回的结果呢

17:44.590 --> 17:45.490
就是个制服串

17:46.190 --> 17:47.090
好表示什么意思呢

17:47.090 --> 17:48.090
表示得到这个

17:48.290 --> 17:50.390
对象制服串的格式

17:50.690 --> 17:50.890
好

17:50.890 --> 17:51.790
咱们来看一下啊

17:52.690 --> 17:54.190
比方说test2

17:55.190 --> 17:56.290
好

17:56.890 --> 17:57.590
看着啊

17:58.390 --> 18:00.090
vahobj

18:00.090 --> 18:01.290
我们随便写个对象吧

18:01.290 --> 18:02.290
就瞎写

18:02.890 --> 18:03.790
瞎写个对象

18:04.390 --> 18:04.790
啊

18:05.490 --> 18:06.390
这个对象呢

18:06.690 --> 18:07.590
他是不是个对象

18:07.590 --> 18:07.990
对吧

18:07.990 --> 18:10.590
这个对象就相当于是你溜了一个object车

18:10.590 --> 18:11.090
对吧

18:11.290 --> 18:11.790
那现在呢

18:11.790 --> 18:13.990
我们学了一个实力的方法

18:13.990 --> 18:14.990
指的是什么意思呢

18:14.990 --> 18:17.290
要通过对翼象去调用啊

18:17.290 --> 18:17.890
toestune

18:18.190 --> 18:20.090
通过对翼象去调整的方法

18:20.090 --> 18:21.190
这叫实力方法

18:21.290 --> 18:22.390
而不是通过

18:22.590 --> 18:24.490
构造函数去调用的方法

18:24.490 --> 18:24.890
啊

18:26.390 --> 18:28.190
不是通过构造函数调用的方法

18:28.190 --> 18:30.190
而是通过对象去调用的方法

18:30.590 --> 18:31.290
明显这个意思吧

18:31.790 --> 18:31.990
好

18:31.990 --> 18:32.990
咱们来看一下啊

18:34.390 --> 18:34.890
log

18:36.090 --> 18:36.490
啊

18:37.790 --> 18:38.590
找到他啊

18:39.390 --> 18:40.590
运行输出看一下

18:40.690 --> 18:42.190
这个返回的是一个制服串啊

18:42.190 --> 18:44.190
整个表达是返回的一个制服串

18:44.190 --> 18:45.890
看这个返回的制服串试试啊

18:46.290 --> 18:47.090
看一下试试啊

18:48.890 --> 18:49.290
啊

18:49.990 --> 18:50.590
看到没

18:51.490 --> 18:52.190
熟不熟悉啊

18:52.190 --> 18:52.890
这个制服串

18:53.690 --> 18:54.790
是不是有点熟悉啊

18:55.290 --> 18:56.590
这个制服串什么意思呢

18:56.990 --> 18:59.290
就是把一个对象转换成制服串啊

18:59.290 --> 19:00.590
转换成制服串格式

19:00.790 --> 19:02.290
转换成制服串格式过后了

19:02.290 --> 19:03.390
它就变成了这个样子

19:03.790 --> 19:04.790
哎是不是很熟悉

19:04.790 --> 19:05.290
以前呢

19:05.290 --> 19:07.190
我们说一个制服串啊

19:07.190 --> 19:10.090
不一个对象要转换成制服串

19:10.090 --> 19:12.390
或者说一个对象要转换成数字啊

19:12.390 --> 19:13.690
它先转换成制服串的时候

19:13.690 --> 19:15.490
转换成转换出来就是这种格式

19:15.490 --> 19:16.090
为什么

19:16.090 --> 19:18.490
是因为他调用了toestune方法啊

19:18.490 --> 19:19.790
是因为他调用了toestune

19:20.390 --> 19:21.190
什么意思啊

19:21.190 --> 19:22.790
我们还是把记记到笔记里边吧

19:23.090 --> 19:24.390
啊我们刚才说了静态

19:24.990 --> 19:25.290
啊

19:26.390 --> 19:27.090
静态

19:27.590 --> 19:29.690
啊静态成员吧

19:29.690 --> 19:32.390
啊静态成员成员就包括属性包括方法

19:32.390 --> 19:32.990
静态成员呢

19:32.990 --> 19:34.090
我们刚才说了三个啊

19:34.090 --> 19:34.890
一个是tease

19:35.390 --> 19:36.090
啊tease

19:36.490 --> 19:37.790
啊这个表示的是

19:38.090 --> 19:38.690
得到

19:39.290 --> 19:41.790
对象某个对象

19:43.090 --> 19:44.790
啊这里面要传个对象啊

19:45.090 --> 19:47.190
得到某个对象的什么的

19:47.190 --> 19:50.390
那就是所有属性名数组

19:51.290 --> 19:52.990
啊这个是还有一个是values

19:53.290 --> 19:54.790
得到的是某个对象

19:55.890 --> 20:00.190
得到某个对象的所有属性值数组

20:00.790 --> 20:03.490
啊当大家的最好去查官方文档啊

20:03.690 --> 20:05.590
我这是写到这里啊给大家提个息

20:05.590 --> 20:07.090
我们讲了这么一些东西

20:07.190 --> 20:08.490
还有呢就是entress

20:09.290 --> 20:11.590
啊这个是里边也要传某个对象

20:12.190 --> 20:12.990
某个对象

20:13.590 --> 20:14.590
啊得到了是

20:14.790 --> 20:21.290
得到某个对象的所有属性值名和属性值的数组

20:22.090 --> 20:23.190
啊这静态成员

20:23.390 --> 20:24.690
还有实力成员呢

20:24.990 --> 20:26.190
实力成员

20:26.390 --> 20:26.990
实力成员呢

20:26.990 --> 20:28.690
我们刚才讲了一个就是toost

20:28.990 --> 20:29.990
啊toost

20:29.990 --> 20:30.690
运方法

20:31.990 --> 20:32.590
方法

20:33.090 --> 20:33.790
那么这个方法呢

20:33.790 --> 20:37.690
是得到某个对象的制服串格式

20:37.890 --> 20:39.990
啊他制服串表示出来应该是什么样子

20:41.390 --> 20:43.090
啊默认情况下呢

20:43.390 --> 20:44.490
啊这是纪别啊

20:44.990 --> 20:46.490
默认情况下

20:48.600 --> 20:50.300
呃该方法

20:50.900 --> 20:53.700
固定返回啊返回什么呢

20:55.820 --> 20:56.820
就是不能说固定啊

20:56.820 --> 20:58.720
我们以后再说一种特殊情况啊

20:58.920 --> 21:00.120
固定返回这么一个纸

21:00.320 --> 21:01.520
就是objects

21:01.820 --> 21:02.520
objects

21:02.620 --> 21:04.020
就我们之前说过的对吧

21:04.420 --> 21:05.720
固定返回这么一个东西

21:06.020 --> 21:07.520
好所以说我们可以看到啊

21:07.520 --> 21:08.120
就这里

21:08.720 --> 21:09.820
这是个对象吧对吧

21:09.820 --> 21:10.920
是objects的对象

21:10.920 --> 21:12.720
因此呢他有这个实力方法toost

21:12.720 --> 21:13.020
运

21:13.820 --> 21:14.620
因此呢

21:14.720 --> 21:15.920
他的那结果是什么呢

21:16.020 --> 21:16.920
就是这个objects

21:16.920 --> 21:17.520
objects

21:18.920 --> 21:20.220
好能不能编呢

21:20.420 --> 21:22.220
可以编啊可以编

21:22.420 --> 21:24.820
就是实力成员啊

21:25.920 --> 21:27.120
实力成员

21:27.920 --> 21:28.820
可以被

21:29.520 --> 21:31.020
可以被重写

21:31.120 --> 21:32.120
什么叫重写

21:32.220 --> 21:34.720
就是被对象里边的成员重写啊

21:34.720 --> 21:35.420
比方说啊

21:35.520 --> 21:37.020
这个对象里边不是有这个方法吗

21:37.020 --> 21:39.620
啊我给他重新再重新给他复制啊

21:39.620 --> 21:41.220
他不是有toost军这个属性吗

21:41.520 --> 21:44.220
对吧我重新给他复制啊方形

21:44.520 --> 21:45.320
你看着啊

21:45.520 --> 21:46.520
重新给他复制

21:46.620 --> 21:47.420
返回什么呢

21:48.020 --> 21:49.820
返回当前对象的x

21:49.820 --> 21:51.020
和当前对象的y

21:51.020 --> 21:51.520
对吧

21:52.020 --> 21:53.320
当前对象的x

21:53.720 --> 21:55.220
加上凭借上一个豆号

21:55.220 --> 21:56.920
再凭借上一个当前对象的y

21:57.020 --> 21:58.820
你看是不是重新给他复制的

21:59.120 --> 22:00.420
好那么现在这个属性的

22:00.420 --> 22:02.420
是不是重新一个新的对象了

22:02.520 --> 22:03.020
ok

22:03.020 --> 22:04.620
那么一个新的函数了

22:04.720 --> 22:06.620
因此呢我们这里调用这个函数的时候

22:06.620 --> 22:07.520
是不是得到一个新

22:07.620 --> 22:09.320
就这运行的是这个函数

22:09.520 --> 22:11.320
而不再是之前写好的函数了

22:11.520 --> 22:13.320
啊当然可以重写没有任何问题

22:13.560 --> 22:14.420
保存看一下

22:14.720 --> 22:15.920
你这样子写的过后你看

22:16.520 --> 22:17.920
图式距离来变成这个样子

22:18.520 --> 22:19.320
你看这个意思吧

22:20.120 --> 22:21.920
好实际上呢有很多的对象呢

22:21.920 --> 22:23.320
他都重写了这个图式距离

22:23.420 --> 22:24.220
比方说啊

22:25.420 --> 22:26.420
这个obj

22:26.420 --> 22:27.820
一个数组是不是对象

22:28.220 --> 22:29.220
数组是不是对象

22:29.220 --> 22:30.620
当然是对象对吧

22:31.020 --> 22:32.220
只要是对象啊

22:32.220 --> 22:33.920
这里一块也比较特殊的点

22:34.020 --> 22:35.320
就是只要是对象

22:37.420 --> 22:39.120
所有对象啊

22:39.420 --> 22:41.620
所有对象不管你是什么函数

22:42.020 --> 22:42.920
还是数组

22:43.020 --> 22:44.120
只要你是对象

22:45.020 --> 22:46.020
都拥有

22:47.720 --> 22:51.320
都拥有obj的

22:51.520 --> 22:53.520
所有实力成员

22:55.020 --> 22:56.220
只要你是一个对象

22:56.220 --> 23:00.220
你一定拥有obj的所有实力成员

23:00.320 --> 23:02.920
当然图式距离是他的实力成员

23:03.020 --> 23:06.120
因此呢所有对象都有图式距离

23:06.320 --> 23:07.220
都有图式距离

23:07.220 --> 23:07.920
咱们来看一下

23:08.220 --> 23:09.720
数组的图式距离有没有图式距离

23:09.720 --> 23:11.920
那当然有啊当然有保存看一下

23:12.520 --> 23:14.220
数组的图式距离变成这个样子的

23:14.420 --> 23:15.220
说明了啥

23:15.720 --> 23:16.720
是不是说明了

23:16.920 --> 23:18.620
数组里边的图式距离

23:19.120 --> 23:22.420
是把obj车里面的图式距离给它重写掉了

23:22.420 --> 23:22.820
对吧

23:22.920 --> 23:24.820
所以说我们才看得到这个这样的结果

23:25.420 --> 23:26.120
没有这个意思吧

23:26.820 --> 23:27.220
好

23:27.320 --> 23:28.720
然后我们再看一下其他的啊

23:28.720 --> 23:29.620
再看一下其他的

23:30.420 --> 23:31.120
接着看吧

23:32.020 --> 23:33.820
我们同样给obj可以复制为什么

23:33.820 --> 23:34.720
6nm

23:34.820 --> 23:35.820
对吧6nm

23:36.020 --> 23:37.820
好6nm复制完了过后呢

23:37.820 --> 23:39.520
我们同样的可以用什么

23:39.720 --> 23:42.720
可以得得到obj的图式距离

23:42.720 --> 23:43.920
看一下得到什么支付串

23:44.620 --> 23:45.020
啊

23:45.320 --> 23:47.120
得到了是这个数字的支付串

23:47.120 --> 23:47.820
你看了没

23:48.220 --> 23:49.220
是不是重写掉了

23:49.420 --> 23:51.720
这个number这个对象里边呢

23:51.720 --> 23:52.920
给它重写掉了这个

23:53.120 --> 23:53.820
图式距离

23:54.320 --> 23:55.920
好再比如啊再比如

23:56.720 --> 23:58.420
啊obj

23:58.920 --> 24:00.220
第二什么了

24:00.720 --> 24:02.120
obj重应该复制

24:02.320 --> 24:03.720
复制为一个nm

24:04.320 --> 24:05.920
布定啊nm

24:06.720 --> 24:08.120
啊给它复制为q

24:09.120 --> 24:10.720
好看一下啊obj

24:10.720 --> 24:11.320
touston

24:12.520 --> 24:13.020
看一下

24:13.220 --> 24:14.920
是不是得到了得到一个支付串

24:14.920 --> 24:16.520
q啊得到一个支付串数

24:16.620 --> 24:18.320
说明这些东西是不是都被重写掉了

24:18.320 --> 24:19.820
它怎么重写的啊

24:20.120 --> 24:21.720
你可以认为它是这样的重写的啊

24:21.920 --> 24:23.320
我给大家写一个吧

24:23.920 --> 24:25.520
比方说咱们呢

24:25.720 --> 24:26.820
写个my number

24:27.120 --> 24:27.920
my number

24:28.620 --> 24:30.520
模拟这个number的构造函数

24:30.520 --> 24:31.820
你看他怎么写的啊

24:31.820 --> 24:32.920
给我一个数字啊

24:32.920 --> 24:34.520
我来创建一个对象啊

24:34.520 --> 24:35.820
创建一个对象啊

24:35.820 --> 24:37.820
之前呢终于大堆事情不管了啊

24:37.820 --> 24:38.820
我们主要是看

24:38.820 --> 24:39.820
他怎么重写的

24:39.820 --> 24:41.320
怎么重写非常简单

24:41.420 --> 24:43.020
你可以认为他就是这样重写的

24:43.620 --> 24:45.420
啊但是我这里有意说一啊

24:45.520 --> 24:47.020
实际上他不是这样重写的啊

24:47.020 --> 24:49.420
但是呢你可以认为他是这样的重写的

24:50.020 --> 24:51.120
啊驴套

24:51.720 --> 24:52.120
n

24:52.520 --> 24:53.820
啊n或者是

24:54.020 --> 24:55.320
支付串拼接上n

24:55.320 --> 24:56.620
对吧把它变成支付串

24:57.320 --> 24:58.220
返回一个支付串嘛

24:58.220 --> 24:58.620
对吧

24:58.620 --> 25:00.220
一个空支付串拼接一个n

25:00.220 --> 25:02.020
那么他得到的结果一定是支付串

25:02.420 --> 25:03.820
啊你可以认为他是这样的写的

25:04.220 --> 25:04.920
你要这意思吧

25:04.920 --> 25:06.520
那么通过这个勾到韩式创建的东西

25:06.520 --> 25:08.120
是不是都有这个图示军了

25:08.820 --> 25:09.520
没问题吧

25:10.020 --> 25:12.020
啊比方说好举个例子

25:12.120 --> 25:12.720
举个例子

25:14.220 --> 25:16.520
好这里呢我们写一个啊

25:17.520 --> 25:17.920
a

25:18.520 --> 25:18.920
a

25:19.320 --> 25:20.920
6或者就obj吗

25:21.220 --> 25:21.920
obj

25:22.220 --> 25:23.620
6一个my number

25:23.920 --> 25:24.720
my number

25:24.920 --> 25:26.220
给他个数字123

25:26.420 --> 25:28.220
你看一下obj的图示军

25:28.620 --> 25:29.120
保存

25:29.920 --> 25:31.320
你看是不是支付串123

25:31.520 --> 25:32.420
对吧黑色的吧

25:32.420 --> 25:33.420
支付串123

25:34.320 --> 25:34.920
ok啊

25:35.720 --> 25:37.720
啊这是关于啊就是

25:38.420 --> 25:39.920
这个图示军啊图示军

25:39.920 --> 25:41.020
当然还有韩数啊

25:41.020 --> 25:43.020
还有韩数韩数是不是对象

25:43.820 --> 25:44.620
啊就这个韩数吗

25:44.620 --> 25:45.420
就这个韩数

25:45.620 --> 25:48.220
好我们来输出my number的图示军

25:48.220 --> 25:49.920
my number的首先有没有图示军

25:49.920 --> 25:51.220
我们首先想这个问题

25:51.620 --> 25:52.720
有没有图示军

25:52.920 --> 25:53.720
这个成员

25:54.520 --> 25:55.320
是不是一定有

25:55.420 --> 25:56.620
韩数是不是对象

25:56.820 --> 25:58.820
韩数当然也是对象

25:58.920 --> 25:59.620
所以说呢

25:59.620 --> 26:02.420
韩数呢他自然而然也会拥有

26:02.720 --> 26:04.720
obj车里边的成员图示军

26:05.020 --> 26:06.720
好看一下啊这个输出什么东西

26:07.420 --> 26:08.020
输出啥了

26:08.020 --> 26:09.420
他就把这个韩数的结构

26:09.420 --> 26:10.820
就整个单码就输出了

26:11.220 --> 26:11.920
说明了啥了

26:11.920 --> 26:13.420
说明了这个韩数的图示军呢

26:13.420 --> 26:15.020
是不是也是被重新掉了

26:15.020 --> 26:15.520
对吧

26:15.620 --> 26:16.920
也是给他重新掉了

26:17.620 --> 26:20.620
好这是关于啊图示军啊图示军

26:21.720 --> 26:22.620
好下一个啊

26:22.820 --> 26:23.620
下一个方法

26:23.920 --> 26:24.420
看一下

26:26.520 --> 26:29.220
下一个方法呢是这个

26:30.420 --> 26:31.120
value

26:31.520 --> 26:32.320
value

26:32.620 --> 26:33.420
指责是什么呢

26:33.520 --> 26:37.920
指责是返回这个对象的值的表示形式

26:38.820 --> 26:40.220
可能大家感觉不出来

26:40.220 --> 26:41.820
这个有什么用啊这个玩意

26:42.120 --> 26:42.520
没关系

26:42.520 --> 26:44.320
我先讲讲了过后再说他有什么用

26:44.620 --> 26:45.620
value无方法

26:45.820 --> 26:49.820
这是得到某个对象的值

26:50.520 --> 26:51.120
的值

26:51.520 --> 26:53.120
他返回的可能是任何东西

26:53.120 --> 26:54.820
他返回的可能是个字幕串

26:54.920 --> 26:55.820
也可能是个对象

26:55.820 --> 26:56.720
也可能是个数字

26:56.720 --> 26:57.820
不一定啊不一定

26:58.220 --> 26:59.420
默认情况下

26:59.820 --> 27:01.120
默认情况下

27:01.620 --> 27:03.220
返回返回的是什么呢

27:03.320 --> 27:05.720
返回该对象本身

27:05.920 --> 27:06.920
该对象本身

27:07.520 --> 27:08.320
什么意思呢

27:08.320 --> 27:09.120
我们来看一下

27:09.120 --> 27:09.920
看一下这个例子

27:10.620 --> 27:11.320
在这个一面

27:11.320 --> 27:12.320
一会我连起来

27:12.320 --> 27:13.620
所以就知道他有什么意义了

27:14.320 --> 27:15.120
好方个型

27:16.120 --> 27:17.520
啊不是方个型啊

27:17.520 --> 27:18.220
一个对象吧

27:18.320 --> 27:19.420
对象OB借

27:20.220 --> 27:21.420
啊随便写啊随便写

27:21.720 --> 27:22.220
啊Y

27:22.720 --> 27:23.320
随便写

27:23.620 --> 27:24.020
好

27:24.920 --> 27:26.120
接下来我们来输出

27:26.420 --> 27:28.020
OB借value

27:29.720 --> 27:30.420
value

27:31.020 --> 27:32.520
好没有参数啊没有参数

27:33.620 --> 27:34.820
好运行看一下

27:35.320 --> 27:36.420
他返回了什么结果

27:39.020 --> 27:40.020
好你会看到

27:40.020 --> 27:41.820
他返回的结果是不是还是他自己

27:42.020 --> 27:42.520
对吧

27:42.720 --> 27:43.520
整个这个函数

27:43.520 --> 27:44.820
返回的结果还是他自己

27:44.920 --> 27:45.420
甚至呢

27:45.420 --> 27:46.520
我们可以用比较来

27:46.620 --> 27:47.620
比较一下啊

27:47.620 --> 27:49.320
跟这个OB借是不是一样的

27:49.520 --> 27:50.520
这个东西value

27:50.520 --> 27:52.020
跟他自己是不是一样的

27:52.320 --> 27:53.320
你会发现是true

27:53.420 --> 27:55.020
说明两个地址都是一样的

27:55.520 --> 27:56.020
因此呢

27:56.020 --> 27:58.120
你可以认为他是怎么写的代码呢

27:58.220 --> 28:00.120
这个OB借这个构造函数啊

28:00.220 --> 28:01.320
你可以这样的想啊

28:01.420 --> 28:02.520
他是怎么写的代码呢

28:02.620 --> 28:02.920
他说

28:02.920 --> 28:04.920
当前有一个函数叫做value

28:05.320 --> 28:06.520
value等于什么呢

28:06.520 --> 28:07.420
等于一个函数

28:07.420 --> 28:08.820
这个函数返回啥呢

28:09.720 --> 28:11.320
这个函数返回的就是他自身

28:11.420 --> 28:12.620
他就返回了他自身

28:12.920 --> 28:14.120
把Z直接返回

28:14.320 --> 28:15.720
他自己是啥就是啥

28:16.420 --> 28:17.520
所以说这个东西

28:17.620 --> 28:19.420
目前好像是没有什么意义

28:19.420 --> 28:19.720
对吧

28:19.720 --> 28:20.920
好像是没有什么意义

28:21.420 --> 28:22.420
但是这个玩意

28:22.520 --> 28:23.620
他是有意义的

28:24.020 --> 28:25.720
好接下来说我们来说一下

28:25.720 --> 28:27.520
这个true and value

28:27.520 --> 28:28.720
这个两个方法

28:28.720 --> 28:29.920
他有什么样的意义

28:30.620 --> 28:31.920
他的意义在哪呢

28:31.920 --> 28:32.820
是这样子的

28:33.520 --> 28:35.120
嗯在介石中

28:36.420 --> 28:37.820
当进行啊

28:37.820 --> 28:42.120
当自动的进行内形转换时啊

28:42.120 --> 28:43.220
内形转换时

28:43.720 --> 28:47.820
如果要对一个对象进行转换

28:48.120 --> 28:48.320
啊

28:48.320 --> 28:50.120
如果他要把一个对象啊

28:50.120 --> 28:51.420
转换成某些类型

28:51.620 --> 28:53.020
比较转换的一个字母创意对吧

28:53.220 --> 28:54.720
然后对一个对象进行转换

28:55.220 --> 28:56.120
实际上

28:56.120 --> 28:57.420
我们之前说一个对象呢

28:57.420 --> 28:58.920
他会把他先转换成一个字母创

28:58.920 --> 29:00.320
转换成这个字母创意对吧

29:00.820 --> 29:01.920
转换成这个字母创意

29:01.920 --> 29:03.020
我们当时是这样说的

29:03.020 --> 29:04.720
实际上是怎么做的呢

29:04.920 --> 29:07.020
实际上是

29:07.920 --> 29:08.420
呃

29:08.420 --> 29:10.020
调先调用

29:10.920 --> 29:14.220
先调用对象的value

29:14.920 --> 29:16.520
value 方法

29:17.320 --> 29:18.820
然后调用

29:19.220 --> 29:20.920
对象的啊

29:21.720 --> 29:22.220
呃

29:22.720 --> 29:24.020
to stream啊

29:24.220 --> 29:25.820
然后再调用返回

29:26.020 --> 29:28.620
然后调用返回结果的

29:29.720 --> 29:30.820
to stream啊

29:30.820 --> 29:31.820
to stream 方法

29:33.890 --> 29:35.990
将得到的结果啊

29:35.990 --> 29:38.590
得到的结果进行进一步

29:39.190 --> 29:39.790
转换

29:40.290 --> 29:42.490
他是用这种方式来进行转换的啊

29:42.890 --> 29:44.790
在接式里边自动进行转换的时候

29:44.790 --> 29:46.590
他实际上用这种方式来进行转换的

29:46.790 --> 29:46.890
好

29:46.890 --> 29:47.790
咱们来举个例子

29:48.890 --> 29:49.590
比方说

29:50.090 --> 29:51.490
我们之前说什么呢

29:51.790 --> 29:52.190
呃

29:52.190 --> 29:52.990
这里个对象啊

29:52.990 --> 29:54.590
这个对象如果这个对象呢

29:54.590 --> 29:55.390
跟这个

29:55.990 --> 29:56.790
跟这个什么

29:56.990 --> 29:59.290
我们输出跟这个一来相加

29:59.590 --> 30:00.690
得到结果是啥

30:01.190 --> 30:02.190
得到结果是啥

30:02.990 --> 30:03.890
啊看着啊

30:04.490 --> 30:06.090
他会得到一个什么样的结果呢

30:06.890 --> 30:09.190
得到一个是制服创意对吧

30:09.190 --> 30:10.290
制服创意

30:10.390 --> 30:11.790
为什么会这样子呢

30:11.790 --> 30:13.390
因为他是先把这个

30:13.390 --> 30:16.990
他先调用的是obj.value

30:18.700 --> 30:20.200
整个表达是返回的是啥

30:20.200 --> 30:22.200
是不是返回这个obj对象对吧

30:22.300 --> 30:24.400
把返回的这个结果啊

30:24.500 --> 30:28.200
把返回的这个结果再去调用to stream

30:28.600 --> 30:30.000
再去调用to stream

30:30.200 --> 30:31.000
于是呢

30:31.000 --> 30:33.200
拼拼接出来是不是这个样子

30:33.700 --> 30:34.400
没问题吧

30:34.800 --> 30:36.500
调用value得到自身嘛

30:36.700 --> 30:39.000
得到自身过后再调用to stream得到这个

30:39.000 --> 30:41.500
得到什么就是一个综扩号obj.

30:41.700 --> 30:42.600
好一个制服创

30:42.700 --> 30:45.000
把这个制服创再去拼接一是不是

30:45.000 --> 30:46.700
就是这个制服创后面加了个一

30:46.700 --> 30:47.200
对吧

30:48.000 --> 30:49.700
好接下来看着啊

30:49.800 --> 30:52.500
我一旦去对这两个方法进行的改动

30:52.500 --> 30:53.500
你看会怎么样

30:53.700 --> 30:55.600
比方说吧先改一下to stream

30:55.900 --> 30:56.300
啊

30:56.300 --> 30:57.200
我们之前说过对吧

30:57.200 --> 30:58.000
可以这样子写

30:58.200 --> 31:00.200
当然呢也可以完整的写法

31:00.300 --> 31:02.300
这样子写都想啊都想一样的

31:03.300 --> 31:03.700
啊

31:04.000 --> 31:05.700
比方说我把to stream呢

31:05.700 --> 31:07.700
改成了返回一个制服创

31:08.300 --> 31:08.900
Hello

31:09.600 --> 31:10.900
你看一下会怎么样了

31:11.500 --> 31:12.200
保存

31:13.100 --> 31:14.700
他就变成了Hello一了

31:15.400 --> 31:15.800
啊

31:16.000 --> 31:17.900
就像这种下面的写法了

31:17.900 --> 31:20.000
就相当于是跟上面的写法是一样的

31:20.300 --> 31:21.800
是一样的啊

31:21.900 --> 31:22.700
没有任何

31:23.800 --> 31:24.200
这里

31:25.100 --> 31:26.900
跟上面这个写法是一样的

31:26.900 --> 31:27.900
就这种写法

31:28.000 --> 31:30.100
他实际上会把它变成这种格式

31:30.300 --> 31:32.300
先调用value而无再调用to stream

31:32.300 --> 31:35.500
我们来看一下obj加1等于多少保存

31:36.000 --> 31:37.500
这等于Hello一了

31:38.200 --> 31:38.900
没问题吧

31:39.200 --> 31:40.700
说明他是调用了to stream方法

31:40.700 --> 31:41.000
对吧

31:41.000 --> 31:42.000
就他制服创

31:42.000 --> 31:43.900
好如果我这里返回的是2呢

31:44.800 --> 31:46.300
如果这里返回的是2呢

31:46.300 --> 31:47.900
这个相加的结果是多少呢

31:48.100 --> 31:49.500
就变成了3看到没

31:50.000 --> 31:50.700
什么神奇

31:51.000 --> 31:53.300
实际上他的本质上是调用这个value而无

31:53.300 --> 31:54.500
再调用这个to stream

31:55.400 --> 31:56.600
好比方说啊

31:56.700 --> 31:58.400
比方说我这个to stream呢

31:58.400 --> 32:00.000
我不动啊我不动

32:00.100 --> 32:02.100
我把这个value而无该改了

32:02.600 --> 32:03.700
改了value

32:04.000 --> 32:04.600
看着啊

32:05.300 --> 32:06.600
value而无该改了

32:06.900 --> 32:08.100
改成了返回啥呢

32:08.600 --> 32:10.000
啊返回一个

32:10.600 --> 32:12.700
数字啊返回个数字123

32:13.000 --> 32:14.200
那你觉得会是多少

32:14.300 --> 32:15.100
不知道结果

32:16.200 --> 32:17.000
会是多少呢

32:17.700 --> 32:20.000
啊这是一道面识题告诉大家

32:20.100 --> 32:21.400
这是一道面识题的

32:21.800 --> 32:23.800
你告诉我这个他的结果是多少

32:24.000 --> 32:25.000
你要好好想一想啊

32:25.000 --> 32:26.100
他的本质是啥

32:27.500 --> 32:29.800
按照刚才我们的说法呢

32:29.800 --> 32:30.900
分析出来了

32:31.300 --> 32:34.100
你应该得到的结果是1231

32:34.100 --> 32:34.700
才对

32:34.800 --> 32:36.500
为什么是1231呢

32:36.800 --> 32:38.100
因为你想一想啊

32:38.600 --> 32:40.300
首先他调用value而无对吧

32:40.500 --> 32:41.700
调用value而无

32:42.100 --> 32:42.900
得到结果是啥

32:42.900 --> 32:44.100
得到结果是不是123

32:44.100 --> 32:45.500
一个数字123

32:45.700 --> 32:47.000
是不是还要调用to stream

32:47.300 --> 32:48.700
好那么接下来想一想

32:48.700 --> 32:49.700
我们之前说过的

32:49.800 --> 32:51.000
这这里相当于是啥

32:51.000 --> 32:52.500
相当于是一个123对吧

32:52.500 --> 32:53.800
一个数字123

32:53.900 --> 32:55.900
好123是个原始类型

32:56.300 --> 32:57.800
就这个地方相当于是

32:57.800 --> 32:58.700
你可以这样子想

32:59.100 --> 33:00.900
这个地方相当于是一个123

33:00.900 --> 33:01.400
对吧

33:01.500 --> 33:03.200
然后123去调用to stream

33:03.300 --> 33:04.900
那是不是原始类型

33:04.900 --> 33:05.400
对吧

33:05.700 --> 33:07.700
原始类型去调用一个方法

33:07.700 --> 33:09.500
是不是要把它转换成包装内

33:09.600 --> 33:10.000
对吧

33:10.000 --> 33:12.200
要使用包装内把它包装起来

33:12.400 --> 33:13.000
好那这里呢

33:13.000 --> 33:15.100
就相当于是你溜了一个什么

33:15.200 --> 33:17.200
溜了一个number把a放进去

33:17.300 --> 33:18.100
明白这个意思吧

33:18.500 --> 33:19.800
把123放进去

33:20.000 --> 33:21.300
好number的to stream

33:21.300 --> 33:24.000
还反回了是一个数字本身的制服串

33:24.200 --> 33:25.700
数字本身的制服串

33:25.800 --> 33:28.400
于是这个地方就变成一个制服串123

33:30.000 --> 33:30.700
能看懂吗

33:31.300 --> 33:32.000
整个过程

33:34.400 --> 33:36.000
按照我们刚才的分析

33:36.000 --> 33:39.100
它这里应该得到的是123

33:39.200 --> 33:39.800
12

33:40.100 --> 33:41.600
这里是数字123

33:41.600 --> 33:43.600
转换成制服串过后变成123

33:43.700 --> 33:44.400
123

33:44.400 --> 33:45.700
制服串在凭借上1

33:45.700 --> 33:46.600
就是123

33:46.600 --> 33:48.700
但是很奇怪的是

33:48.700 --> 33:49.600
它得到的是

33:51.900 --> 33:53.500
我这里不能直接这样子

33:53.500 --> 33:54.600
是ob借加1

33:55.000 --> 33:56.000
如果是刚才那种写法

33:56.000 --> 33:56.800
它肯定是123

33:56.800 --> 33:58.000
123

33:58.700 --> 33:58.900
好

33:58.900 --> 34:00.700
但是如果我这样子写了

34:01.200 --> 34:02.200
这样子写了

34:02.700 --> 34:03.300
是什么

34:03.300 --> 34:05.400
它就变成了124

34:05.400 --> 34:06.700
这是怎么回事

34:06.700 --> 34:08.000
怎么那么奇怪

34:08.000 --> 34:09.500
是因为介石

34:09.500 --> 34:11.500
它是这种有这么个威褶

34:11.900 --> 34:13.700
如果调用了

34:14.000 --> 34:14.900
value

34:16.100 --> 34:19.000
已经得到了原始内想

34:19.400 --> 34:20.800
它已经得到了原始内想

34:21.000 --> 34:22.800
则不再调用

34:23.400 --> 34:24.800
不再调用图示军

34:24.900 --> 34:26.200
它是这么一个规则

34:26.400 --> 34:27.400
已经得到了原始内想

34:27.400 --> 34:28.800
它就不会再调用图示军了

34:30.400 --> 34:30.600
好

34:30.600 --> 34:31.800
这是关于这一块

34:31.800 --> 34:32.400
它这一块

34:32.400 --> 34:33.200
什么回事

34:34.900 --> 34:36.500
我们以后在做转换的时候

34:36.500 --> 34:38.800
特别是在面对面试体的时候

34:38.800 --> 34:39.900
你一定要清楚

34:40.200 --> 34:41.000
特别是在做什么

34:41.000 --> 34:42.000
算数运算的时候

34:42.000 --> 34:44.000
不是对象进行算数运算

34:44.000 --> 34:44.700
还要转换

34:44.700 --> 34:45.000
对吧

34:45.000 --> 34:46.600
它到底是怎么转换的

34:46.700 --> 34:48.700
它是先调用value

34:49.100 --> 34:50.300
如果value

34:50.300 --> 34:51.600
调用完了过后

34:51.600 --> 34:54.500
发现它还没有得到原始内想

34:54.900 --> 34:57.300
还是一个对象

34:57.300 --> 34:57.700
OK

34:57.700 --> 34:59.400
那去调用图示军的方法

34:59.400 --> 35:00.300
来得到对象

35:00.700 --> 35:02.200
来得到一个制补串

35:02.700 --> 35:03.600
得到一个制补串

35:04.000 --> 35:06.200
如果你还必须要转换成数字的话

35:06.200 --> 35:07.500
然后调用lumber

35:07.500 --> 35:09.000
这个函数把它转换成数字

35:10.200 --> 35:13.200
这是关于这个OB几个扯理员

35:13.200 --> 35:14.900
OB几个里边其实我们用的东西

35:14.900 --> 35:15.800
其实没有那么多

35:15.800 --> 35:16.400
不多

35:16.400 --> 35:18.100
三个静态成员可能会用到

35:18.100 --> 35:19.300
还有这两个实力成员

35:19.300 --> 35:20.800
主要是应付面试的

35:20.900 --> 35:22.300
平时我们自己的话

35:23.300 --> 35:24.200
不是很会用

35:24.200 --> 35:27.000
不太会用这两个方法

35:28.600 --> 35:30.000
这是关于OB几个字

35:30.300 --> 35:31.600
下面这个方形

35:33.100 --> 35:33.900
我们说过

35:33.900 --> 35:35.900
所有通过方形

35:35.900 --> 35:37.600
这个构造函数创建的对象

35:37.600 --> 35:38.900
都是一个函数

35:38.900 --> 35:40.100
都是一个函数

35:40.100 --> 35:41.400
那么换而言之

35:41.400 --> 35:42.600
换而言之

35:42.600 --> 35:44.300
所有函数

35:45.200 --> 35:48.300
都具有方可形中的

35:48.400 --> 35:48.800
什么

35:50.400 --> 35:52.100
实力成员

35:52.100 --> 35:52.900
就是方可形

35:54.200 --> 35:55.700
这里边的实力成员

35:55.700 --> 35:57.500
所有的函数都具有

35:57.500 --> 35:58.800
我们也可以在百度里边

35:58.800 --> 36:01.000
通过同样的方式来进行搜索

36:01.000 --> 36:02.300
就是javascripts

36:02.300 --> 36:03.500
方可形

36:03.500 --> 36:04.600
MDN

36:04.600 --> 36:06.100
我们可以看到

36:06.100 --> 36:06.900
应该是第三个

36:06.900 --> 36:07.800
第三个方可形

36:08.900 --> 36:09.800
看一下

36:09.800 --> 36:11.300
看一下这里边有哪些东西

36:11.300 --> 36:12.600
有哪些东西

36:12.600 --> 36:13.700
首先

36:13.700 --> 36:15.400
这里其实它前面你可以看一下

36:15.400 --> 36:16.400
它已经说到了

36:16.400 --> 36:19.400
它说在javascript中的每一个函数

36:19.400 --> 36:22.100
实际上都是一个方形的对象

36:22.100 --> 36:23.200
通过六一个方可形的

36:23.200 --> 36:24.600
可以创建一个函数

36:25.400 --> 36:25.700
好吧

36:25.700 --> 36:26.400
我们往下看

36:26.400 --> 36:26.900
往下看

36:28.500 --> 36:31.000
然后它这里边说到了

36:31.000 --> 36:32.300
这里边有哪些

36:32.300 --> 36:33.000
就是

36:35.000 --> 36:35.600
实力

36:36.900 --> 36:37.600
写到了

36:37.600 --> 36:38.500
我在这

36:38.500 --> 36:39.700
有哪些实力成员

36:39.700 --> 36:41.400
有哪些实力成员

36:41.400 --> 36:41.800
好

36:41.800 --> 36:43.900
上面就是属性我们不看了

36:43.900 --> 36:45.100
属性不用看

36:45.100 --> 36:45.900
属性里边

36:45.900 --> 36:46.700
就一个东西

36:46.700 --> 36:49.500
这个东西还目前还已经过期了

36:49.500 --> 36:51.900
叫做arguments

36:51.900 --> 36:52.900
它已经过期了

36:52.900 --> 36:54.400
但是这个东西过期了过

36:54.400 --> 36:55.800
它下面有个说法就是

36:57.200 --> 36:58.300
说了这个东西

36:58.300 --> 37:00.500
已经被一个关键字

37:00.500 --> 37:03.100
关键字arguments替代了

37:03.100 --> 37:04.200
你可以使用这个关键字

37:04.200 --> 37:05.300
来达到一样的效果

37:05.300 --> 37:06.300
这是什么东西呢

37:06.300 --> 37:07.100
它指的是

37:07.100 --> 37:09.500
以输主的形式获取

37:09.500 --> 37:13.500
传入函数的所有参数

37:13.500 --> 37:14.500
它是一个关键字

37:14.600 --> 37:16.200
我们这里就说一下关键字

37:18.300 --> 37:19.500
这多出一个语法了

37:19.500 --> 37:20.700
它就不是一个什么属性了

37:20.700 --> 37:21.500
是个语法

37:22.200 --> 37:23.900
语法arguments

37:25.300 --> 37:26.300
它获取的是什么呢

37:26.300 --> 37:28.500
获取在函数中

37:29.900 --> 37:31.300
在函数中使用

37:32.500 --> 37:36.500
获取该函数调用时

37:37.500 --> 37:40.500
传递的所有参数

37:40.500 --> 37:42.000
传递的所有参数

37:42.000 --> 37:43.400
什么意思呢

37:43.400 --> 37:46.420
就个例子

37:46.420 --> 37:47.420
比方说

37:47.420 --> 37:48.420
这里写个函数

37:48.420 --> 37:49.420
当前比方

37:51.420 --> 37:53.420
写个a和b两个参数

37:54.420 --> 37:56.020
我们这里的输出什么了

37:56.020 --> 37:58.020
输出a和b

37:58.020 --> 38:01.420
然后再输出一个关键字arguments

38:01.420 --> 38:03.620
你看 难受的表示关键字

38:03.620 --> 38:05.620
接下来我们来调用这个函数

38:05.620 --> 38:07.820
因为其实我们本来

38:07.820 --> 38:09.420
这里可讲的不是这个东西的

38:09.420 --> 38:11.720
因为我们讲的是这个方式的成员

38:11.720 --> 38:12.020
对吧

38:12.020 --> 38:13.820
它里边有哪些属性的方法

38:13.820 --> 38:15.120
但是我们既然说到这了

38:15.120 --> 38:16.920
就顺便把它说一下

38:16.920 --> 38:18.220
因为它这个成员

38:18.220 --> 38:20.420
它这个静态成员都不再使用了

38:20.420 --> 38:21.520
都不再去使用了

38:21.520 --> 38:22.920
它建议你使用这个东西

38:22.920 --> 38:25.320
因此我就把这个东西说一下arguments

38:26.920 --> 38:29.920
比方说我传入一个1传入一个2

38:29.920 --> 38:30.820
传入一个2

38:30.820 --> 38:31.920
我们来打印看一下

38:33.520 --> 38:34.020
看一下

38:37.570 --> 38:38.670
我们会发现

38:38.670 --> 38:41.270
我们前边打印出来了1和2

38:41.270 --> 38:42.170
没问题吧

38:42.170 --> 38:44.970
前面a和b打印出来了1和2

38:44.970 --> 38:46.870
而下面好像有一个数组

38:46.870 --> 38:47.870
你看到没

38:47.970 --> 38:48.870
好像有个数组

38:48.870 --> 38:50.670
你看有数组长度

38:50.670 --> 38:52.670
有下标0和1

38:52.670 --> 38:54.170
第一个参数是1

38:54.170 --> 38:55.570
第二个参数是2

38:56.770 --> 38:57.670
能看到吗

38:57.670 --> 38:59.570
它相当于是把你这个参数

38:59.570 --> 39:01.770
装到了这个数组里边

39:01.770 --> 39:03.770
但它不是真正的数组

39:03.770 --> 39:05.870
它只是一个假数组

39:05.870 --> 39:06.870
什么叫真正的数组

39:06.870 --> 39:09.370
真正的数组是通过而瑞

39:09.370 --> 39:10.770
这个构造函数创建的

39:10.770 --> 39:12.170
才叫真数组

39:12.170 --> 39:12.970
那么这个东西

39:12.970 --> 39:13.970
它是一个假数组

39:13.970 --> 39:14.970
一个假数组

39:14.970 --> 39:15.970
它不是一个真数组

39:15.970 --> 39:16.970
但是你可不可以循环

39:17.070 --> 39:18.670
它当然可以用佛循环

39:18.670 --> 39:19.470
它有下标

39:19.470 --> 39:19.970
对不对

39:19.970 --> 39:21.170
你当然可以循环它

39:21.170 --> 39:24.670
但是它可能会缺少数组的里边的一些成员

39:24.670 --> 39:26.170
比方数组的里边又不是

39:26.170 --> 39:27.170
我们之前讲数组的时候

39:27.170 --> 39:28.670
讲了很多的函数

39:28.670 --> 39:29.270
对不对

39:29.270 --> 39:30.470
它数组里边有很多函数

39:30.470 --> 39:32.070
它只缺少的

39:32.070 --> 39:32.870
这是一个伪数组

39:32.870 --> 39:33.470
咱们记彼

39:35.670 --> 39:37.870
我们以后还会遇到很多的伪数组

39:37.870 --> 39:40.470
是一个内数组

39:40.470 --> 39:45.940
也称为伪数组

39:46.940 --> 39:49.340
称为伪数组

39:51.840 --> 39:53.540
就是什么叫伪数组

39:53.540 --> 39:54.140
指的是

39:55.540 --> 39:59.140
没有通过

39:59.140 --> 40:01.940
而为构造函数

40:01.940 --> 40:04.940
创建的

40:04.940 --> 40:09.840
类似于数组结构的对象

40:09.840 --> 40:10.540
就这个对象

40:10.540 --> 40:12.540
它看上去很像一个数组结构

40:12.540 --> 40:13.240
你看没有

40:13.240 --> 40:13.840
它有什么呢

40:13.840 --> 40:14.840
有李玲一

40:15.040 --> 40:16.000
下标有什么

40:16.000 --> 40:17.840
类似表示数组的长度

40:17.840 --> 40:20.140
但是它不是通过

40:20.140 --> 40:22.040
而为构造函数创建的

40:22.040 --> 40:23.640
因此它会缺少

40:23.640 --> 40:26.340
伪数组中伪数组

40:26.340 --> 40:32.540
会缺少大量的数组实力方法

40:32.540 --> 40:33.640
我们之前讲过数组里边

40:33.640 --> 40:34.640
有很多实力方法

40:34.640 --> 40:35.640
什么splice

40:35.640 --> 40:37.640
删除什么snice

40:37.640 --> 40:41.540
就是减击一段

40:41.540 --> 40:42.540
数组一段

40:42.540 --> 40:44.140
比方说什么pop

40:44.140 --> 40:45.140
比方说pop

40:45.140 --> 40:46.740
加一项就是

40:46.740 --> 40:47.540
弹出一项

40:47.540 --> 40:48.140
对吧

40:48.140 --> 40:50.540
像讲了很多的数组的实力方法

40:50.540 --> 40:52.440
但是伪数组是缺失的

40:52.440 --> 40:53.440
因为它没有通过

40:53.440 --> 40:54.940
耳锐构造函数创建

40:54.940 --> 40:57.140
你只有通过构造函数创建的

40:57.140 --> 40:58.040
构造函数里边

40:58.040 --> 40:59.940
才会给你注入这些方法

41:01.140 --> 41:02.040
这个argument

41:02.040 --> 41:02.940
它就是个伪数组

41:04.140 --> 41:05.740
伪数组通常可以循环

41:05.740 --> 41:07.440
循环是没问题的

41:07.440 --> 41:07.640
好

41:07.640 --> 41:08.740
接下来我们再看

41:08.740 --> 41:11.040
如果我们的参数不止两个

41:11.040 --> 41:11.740
看着

41:11.740 --> 41:12.740
不止两个

41:14.340 --> 41:16.240
传了五个参数进去

41:16.240 --> 41:17.340
看一下

41:17.340 --> 41:19.540
我们这里边是不是只能得到a和b

41:19.540 --> 41:19.840
对吧

41:19.840 --> 41:21.440
只能得到a和b

41:21.440 --> 41:22.240
你看

41:22.240 --> 41:23.940
因为它其他就没有参数了

41:23.940 --> 41:25.940
但是它其他的多余的参数

41:25.940 --> 41:27.340
我们可以在这个数组里边

41:27.340 --> 41:29.740
在这个伪数组里边是不是可以取到

41:29.740 --> 41:30.640
看没

41:30.640 --> 41:32.240
我们可以得到这个数组的长度

41:32.240 --> 41:33.740
一共有五个参数

41:33.740 --> 41:34.540
每个参数是多少

41:34.540 --> 41:36.740
我们可以一次取到

41:36.740 --> 41:38.940
这就是这个关键词的好处

41:38.940 --> 41:40.740
它可以取到一些多余的参数

41:41.740 --> 41:42.940
好

41:42.940 --> 41:44.040
那么这个的关键词

41:44.040 --> 41:45.840
它还有一个特点

41:45.840 --> 41:46.940
它会怎么样呢

41:46.940 --> 41:49.540
它会跟我们的形参进行对应

41:51.540 --> 41:52.740
再起一笔

41:52.740 --> 41:53.540
arguments

41:57.230 --> 42:03.030
会与arguments数组中的值

42:03.030 --> 42:08.230
会与对应的形参

42:08.230 --> 42:09.230
硬设

42:09.230 --> 42:10.230
会进行硬设

42:10.230 --> 42:11.030
什么要硬设呢

42:11.030 --> 42:13.330
我们一会看效果就知道了

42:13.330 --> 42:13.630
好

42:13.630 --> 42:14.230
看效果

42:14.230 --> 42:15.630
看效果

42:15.630 --> 42:17.330
这边

42:17.330 --> 42:19.830
我们这样子写

42:19.830 --> 42:25.230
我们这里把arguments的第一项改成abc

42:25.230 --> 42:26.130
管它什么参数

42:26.130 --> 42:27.830
该改成abc

42:27.830 --> 42:30.130
然后改变这个b的值

42:30.130 --> 42:31.030
为多少呢

42:31.030 --> 42:33.130
为123

42:33.130 --> 42:33.830
接下来

42:33.830 --> 42:35.130
我们不用看那么多参数

42:35.130 --> 42:36.030
只看两个参数

42:36.030 --> 42:37.030
看着

42:37.030 --> 42:38.630
我们传到两个参数进去

42:39.630 --> 42:41.730
a的值是1b的值是2

42:41.730 --> 42:44.430
那么arguments里面存的也是1和2

42:44.430 --> 42:46.630
我们把第一个位置改成abc

42:46.630 --> 42:48.830
把第二个位置改成123

42:48.830 --> 42:51.030
接下来我们来输出a和b arguments

42:51.030 --> 42:52.030
看一下输出什么结果

42:53.430 --> 42:54.930
因为发现两个都改了

42:54.930 --> 42:56.430
两个都改了

42:56.430 --> 42:58.730
当我们改arguments第一项的时候

42:58.730 --> 42:59.830
a也跟着变了

42:59.830 --> 43:00.730
这叫硬设

43:00.730 --> 43:02.130
它们两个是一个东西

43:02.130 --> 43:02.830
你改了它

43:02.830 --> 43:04.430
它也跟着变

43:04.430 --> 43:05.630
当我改它的时候

43:05.630 --> 43:06.430
它也会跟着变

43:06.430 --> 43:07.230
看到没

43:07.230 --> 43:08.430
改它的时候

43:08.430 --> 43:09.630
它也会跟着变

43:09.630 --> 43:10.430
这就是硬设

43:12.130 --> 43:13.730
但是这里容易出面识题

43:13.730 --> 43:14.930
出的是什么面识题呢

43:14.930 --> 43:16.330
它可能会这样子出

43:16.330 --> 43:17.930
我没有传参数

43:17.930 --> 43:20.330
我没有传参数会怎么样

43:21.330 --> 43:22.130
保存看一下

43:23.630 --> 43:24.930
没有传参数你会发现

43:24.930 --> 43:26.730
它硬设不出来了

43:26.730 --> 43:28.130
怎么来理解呢

43:28.130 --> 43:28.830
怎么来理解呢

43:28.830 --> 43:30.930
我们来这样子看呗

43:30.930 --> 43:32.030
一下就理解了

43:32.030 --> 43:33.030
你不用去使信用备

43:33.030 --> 43:34.930
你理解就完事了

43:34.930 --> 43:36.030
a和b两个参数

43:36.030 --> 43:36.930
对吧

43:36.930 --> 43:38.830
它也是我没有传参数

43:38.830 --> 43:40.630
那a的值是不是undefend

43:40.630 --> 43:40.930
对吧

43:40.930 --> 43:42.030
a的值undefend

43:42.030 --> 43:43.130
别传参数就undefend

43:43.130 --> 43:44.230
我们之前讲过的

43:44.230 --> 43:45.830
b的值那undefend

43:45.830 --> 43:46.430
好

43:46.430 --> 43:47.430
然后argument

43:47.430 --> 43:48.430
你没有传参数吗

43:48.430 --> 43:48.930
对不对

43:48.930 --> 43:50.230
argument

43:50.230 --> 43:51.430
没有传参数里边

43:51.430 --> 43:52.830
你可以把它当成数组

43:52.830 --> 43:54.430
这数组是不是空的

43:54.430 --> 43:56.130
你告诉我空的咋硬设了

43:56.130 --> 43:57.330
你告诉我咋硬设

43:57.330 --> 43:58.630
它倒是想把这个a

43:58.630 --> 43:59.630
硬设到它第一个位置

43:59.630 --> 44:01.230
它没有东西

44:01.230 --> 44:03.130
它没东西是不是没法硬设

44:03.130 --> 44:03.730
对吧

44:03.730 --> 44:05.430
那么这个时候是不是硬设失败

44:05.430 --> 44:06.330
a和b

44:06.330 --> 44:08.030
通通硬设失败

44:08.030 --> 44:08.230
好

44:08.230 --> 44:09.230
硬设失败了过后

44:09.230 --> 44:11.130
你后边改动就分开的了

44:11.130 --> 44:12.830
你把argument第一项变成啥

44:12.830 --> 44:14.330
变成abc

44:14.330 --> 44:15.430
跟a没关系

44:15.430 --> 44:17.630
因为它硬设已经失败了

44:17.630 --> 44:18.730
硬设是在最开始

44:18.730 --> 44:20.930
函数雕用的时候最开始发生的

44:20.930 --> 44:21.630
那硬设失败了

44:21.630 --> 44:23.030
它就不硬设了

44:23.030 --> 44:24.930
那么第二个位置

44:24.930 --> 44:26.530
变成abc对吧

44:26.530 --> 44:28.830
然后你把b变成了123

44:28.830 --> 44:30.730
变成这个样子了

44:30.730 --> 44:32.330
能理解吗

44:32.330 --> 44:32.530
好

44:32.530 --> 44:34.530
接下来我们再来看

44:34.530 --> 44:36.430
如果我第一个参数传了一个e

44:36.430 --> 44:38.230
没有传第二个参数

44:38.230 --> 44:39.530
我没有传第二个参数

44:39.530 --> 44:40.830
我们又来分析

44:40.830 --> 44:42.530
又来分析

44:42.530 --> 44:43.530
好a和b

44:43.530 --> 44:44.530
两个字

44:44.530 --> 44:46.930
a传了一个字多少

44:46.930 --> 44:47.630
e

44:47.630 --> 44:48.530
b

44:48.530 --> 44:49.730
b传没传没传

44:49.730 --> 44:50.730
indefend

44:50.730 --> 44:51.930
argument

44:51.930 --> 44:54.530
argument

44:54.530 --> 44:55.930
argument里面是个数组

44:55.930 --> 44:57.230
你把它当成数组

44:57.230 --> 44:58.530
这个数组是有一项

44:58.530 --> 44:59.230
对不对

44:59.230 --> 45:00.930
一项就是e

45:00.930 --> 45:02.030
一项

45:02.030 --> 45:02.830
那么你会发现

45:02.830 --> 45:05.130
这个a是不是跟它硬设了

45:05.130 --> 45:07.230
第一个参数跟它这个位置硬设了

45:07.230 --> 45:09.630
因此你现在改动了argument过后

45:09.630 --> 45:12.030
改动了第一项把它改成abc

45:12.030 --> 45:13.830
是不是这里要跟着改

45:13.830 --> 45:15.030
他们两个是一个东西

45:15.030 --> 45:16.830
所以说也要跟着改

45:16.830 --> 45:17.030
好

45:17.030 --> 45:18.830
当你去改这个b的时候

45:18.830 --> 45:20.530
是不是不会影响到这

45:20.530 --> 45:20.830
对吧

45:20.830 --> 45:21.730
去改这个b的时候

45:21.730 --> 45:22.730
不会影响到这

45:22.730 --> 45:23.830
所以数数什么结果呢

45:23.830 --> 45:26.030
就说abc123

45:26.030 --> 45:28.130
以及下面的123

45:28.130 --> 45:29.830
没保存

45:29.830 --> 45:30.730
保存看一下

45:30.730 --> 45:32.130
abc123

45:32.230 --> 45:33.330
以及下面的abc

45:33.330 --> 45:35.130
下面的abc

45:35.130 --> 45:36.430
要会做这种提议

45:36.430 --> 45:37.130
它没发硬设

45:37.130 --> 45:38.430
它就不硬设了

45:38.430 --> 45:39.330
比方说

45:39.330 --> 45:40.830
有些提了它故意搞你

45:40.830 --> 45:41.430
知道吗

45:41.430 --> 45:44.430
它这样子写undefend

45:44.430 --> 45:45.030
有些同学说

45:45.030 --> 45:46.430
就去使劲硬背

45:46.430 --> 45:47.330
这里传undefend

45:47.330 --> 45:48.130
它就不硬设

45:48.130 --> 45:48.830
是传undefend

45:48.830 --> 45:50.030
就不硬设吗

45:50.030 --> 45:50.530
不是

45:50.530 --> 45:51.830
是它没发硬设的时候

45:51.830 --> 45:53.130
不硬设

45:53.130 --> 45:54.430
保存我们看一下

45:54.430 --> 45:55.830
这样子有怎么理解呢

45:55.830 --> 45:56.330
传了谁

45:56.330 --> 45:57.230
传了a和b

45:57.230 --> 45:57.730
对吧

45:57.730 --> 45:58.830
a的值呢

45:58.830 --> 45:59.730
a的值为多少

45:59.730 --> 46:01.330
eb的值为多少

46:02.330 --> 46:04.730
argument的值为多少

46:04.730 --> 46:06.130
第一个向为一

46:06.130 --> 46:07.430
第二个向为undefend

46:07.430 --> 46:08.130
你看现在

46:08.130 --> 46:09.730
是不是可以硬设

46:09.730 --> 46:10.830
是不是可以硬设

46:10.830 --> 46:12.330
a硬设到这一位置

46:12.330 --> 46:13.630
b硬设到这一个位置

46:13.630 --> 46:14.630
是不是可以硬设

46:14.630 --> 46:15.830
所以说现在得到的结果

46:15.830 --> 46:17.130
就是可以硬设的

46:17.130 --> 46:19.630
两个都是abc123

46:19.630 --> 46:20.330
你看

46:20.330 --> 46:21.830
两个都是abc123

46:21.830 --> 46:23.130
就是可以硬设的时候

46:23.130 --> 46:23.930
它就能硬设

46:23.930 --> 46:24.730
它不能硬设的时候

46:24.730 --> 46:25.730
它就没发硬设

46:25.730 --> 46:27.330
那就这么简单

46:27.330 --> 46:28.930
好吧

46:28.930 --> 46:30.230
这是关于补充一点

46:30.330 --> 46:31.430
这是关于argument

46:33.230 --> 46:34.430
然后我们接着说

46:34.430 --> 46:36.230
我们这里的重点是方式里边的

46:36.230 --> 46:37.230
这些成员

46:37.230 --> 46:38.630
这些成员

46:38.630 --> 46:39.830
这个地方

46:39.830 --> 46:41.930
方式dirname

46:41.930 --> 46:43.430
这是函数的名字

46:43.430 --> 46:44.830
函数的名称

46:44.830 --> 46:46.630
函数名称

46:46.630 --> 46:47.830
这个已经过时了

46:47.830 --> 46:49.030
你不太建议使用了

46:49.030 --> 46:49.730
它说

46:49.730 --> 46:50.430
不是过时

46:50.430 --> 46:52.230
它说这种API

46:52.230 --> 46:54.930
已经不再是标准的API了

46:54.930 --> 46:56.230
已经不再是标准结构了

46:56.230 --> 46:57.830
不太建议你使用了

47:00.430 --> 47:03.030
然后那个nense是获取参数的个数

47:03.030 --> 47:04.030
这样子可以用

47:04.030 --> 47:06.230
可以用这个nense获取参数个数

47:06.230 --> 47:06.830
也就是说

47:06.830 --> 47:08.030
这些东西都不是精彩的

47:08.030 --> 47:09.030
是实力属性

47:09.030 --> 47:10.230
是实力属性

47:10.230 --> 47:11.030
什么意思呢

47:11.030 --> 47:12.830
比方说我们可以通过

47:14.230 --> 47:15.230
这不是一个函数吗

47:15.230 --> 47:16.030
test对吧

47:16.030 --> 47:17.230
test这个函数

47:17.230 --> 47:18.830
这里就把注尸量

47:20.030 --> 47:21.230
通过这个argument

47:21.230 --> 47:22.630
得到了是实际

47:22.630 --> 47:24.630
传入的参数的数量

47:24.630 --> 47:26.030
你传了一个就一个

47:26.030 --> 47:26.830
传了两个就两个

47:26.830 --> 47:28.630
传了10个就10个

47:29.030 --> 47:30.030
我们有的时候

47:30.030 --> 47:31.830
是要获取这个函数

47:31.830 --> 47:33.230
形参的数量

47:33.230 --> 47:34.430
就这里写了几个

47:35.030 --> 47:36.030
这里写了几个

47:36.430 --> 47:37.430
那这里怎么获取

47:37.430 --> 47:38.630
你看我现在不调用函数了

47:38.630 --> 47:39.630
函数调入不调用

47:40.230 --> 47:41.630
就不运行这里面的东西

47:41.630 --> 47:43.630
我只是想单纯的想获取

47:43.630 --> 47:45.630
这个函数它的形参数量

47:45.830 --> 47:46.630
这里记忆一笔

47:48.030 --> 47:49.630
这下面全是实力成员

47:49.630 --> 47:50.630
实力成员

47:51.630 --> 47:53.030
实力成员

47:54.030 --> 47:55.430
这个nense属性

47:56.230 --> 47:58.230
得到函数

47:59.230 --> 48:00.630
形参数量

48:01.030 --> 48:01.630
得到函数

48:01.630 --> 48:02.630
形参的数量

48:03.630 --> 48:04.430
比方说

48:06.430 --> 48:07.230
这里

48:07.430 --> 48:07.630
好

48:07.630 --> 48:08.630
这个tesse这个函数

48:08.630 --> 48:09.630
我们给它点nense

48:09.630 --> 48:10.630
你看是不是2

48:10.630 --> 48:11.230
对吧

48:11.230 --> 48:11.630
2

48:11.630 --> 48:12.830
我都没有调用这个函数

48:12.830 --> 48:14.430
你鬼知道我传了几个参数

48:15.230 --> 48:16.230
将来会传几个参数

48:16.230 --> 48:16.830
无所谓

48:16.830 --> 48:18.230
我得到的是形参数量

48:18.230 --> 48:19.430
管理传几个参数了

48:19.430 --> 48:20.430
我才不管你

48:21.430 --> 48:21.830
d

48:21.830 --> 48:22.230
好

48:22.230 --> 48:23.430
看着写到4个对吧

48:23.430 --> 48:24.830
都没有调用这个函数

48:25.430 --> 48:26.430
直接得到函数

48:26.430 --> 48:27.430
形参的数量

48:28.430 --> 48:29.830
虽然说没有多大意义

48:29.830 --> 48:30.830
没有多大意义

48:31.830 --> 48:32.030
好

48:32.030 --> 48:33.230
这是这个nense

48:33.230 --> 48:34.430
再看一下这个name

48:34.430 --> 48:36.230
这个name就是函数名字

48:36.230 --> 48:37.430
就是函数名字

48:37.430 --> 48:38.030
看一下吧

48:38.430 --> 48:41.030
这个tesse点name是函数名字

48:44.560 --> 48:45.760
我们这里顺便说一下

48:45.760 --> 48:46.760
第一名函数

48:46.760 --> 48:47.760
它的名字是啥了

48:48.160 --> 48:49.160
我们来看一下这个

48:49.560 --> 48:50.560
这个挺有意思的

48:50.960 --> 48:52.560
如果我们这个函数是这样子写的

48:53.360 --> 48:54.960
test是这样子写的

48:54.960 --> 48:56.760
是用表达式的这种方式来写的

48:57.160 --> 48:58.560
那么这个函数的名字是啥的

48:58.560 --> 49:00.160
有可能可能会认为是test

49:00.160 --> 49:00.960
我们来看一下吧

49:02.960 --> 49:04.560
test点name

49:05.960 --> 49:07.160
确实是等于test

49:07.160 --> 49:09.960
但是如果你这里写的不是另名函数

49:09.960 --> 49:11.160
比方说写的是abc

49:11.160 --> 49:12.560
给了它的一个名字

49:12.560 --> 49:13.360
我们来看一下

49:14.160 --> 49:15.360
test点name

49:15.760 --> 49:16.960
它变成了abc了

49:17.760 --> 49:20.560
所以说这个东西容易造成昏小

49:20.560 --> 49:23.360
因此它都现在都不建议你去使用这个属性了

49:23.360 --> 49:24.760
这个属性没多少意义了

49:25.760 --> 49:27.760
这是关于函数的

49:27.760 --> 49:29.160
这两个实力属性

49:29.160 --> 49:30.360
names和names

49:31.160 --> 49:32.360
好 下面

49:34.360 --> 49:37.760
下面这里面有两个函数

49:37.760 --> 49:38.760
就是方法

49:38.760 --> 49:40.760
两个方法我要隆重介绍一下

49:41.360 --> 49:42.960
一个方法叫做apply

49:43.160 --> 49:44.160
apply方法

49:44.160 --> 49:45.560
一个方法叫做call

49:45.760 --> 49:46.560
call方法

49:47.360 --> 49:49.360
好 这两个方法有什么用了

49:49.360 --> 49:50.560
它指的是

49:51.160 --> 49:52.360
绑定z是

49:52.360 --> 49:55.360
它的作用是可以改变z的指向

49:55.360 --> 49:56.960
改变z的指向

49:56.960 --> 49:57.960
我举个例子

49:59.160 --> 50:00.360
这里我要专门来

50:01.360 --> 50:02.360
拿一个例子来说

50:02.760 --> 50:04.960
改变z指向

50:06.360 --> 50:08.160
所有的函数都有这些

50:08.160 --> 50:09.360
这些是实力成员

50:09.360 --> 50:09.960
对吧

50:09.960 --> 50:12.160
所有的函数都是方形的实力

50:12.160 --> 50:12.960
都是它的对象

50:12.960 --> 50:14.960
因此所有的函数都有这些方法

50:15.560 --> 50:16.760
好 举个例子

50:18.740 --> 50:20.540
比方说方形

50:22.140 --> 50:24.140
test 或者是say hello

50:24.140 --> 50:26.140
写个函数 say hello

50:27.140 --> 50:29.340
这个函数里边我们这样子写代

50:30.540 --> 50:31.340
这样子写代

50:33.940 --> 50:34.740
输出

50:36.140 --> 50:37.340
z是点n

50:38.140 --> 50:40.140
z是点h

50:40.740 --> 50:41.540
输出这个

50:42.540 --> 50:43.940
输出这么个东西

50:44.340 --> 50:46.940
好 如果我直接调用say hello

50:47.540 --> 50:48.540
是不是会出问题

50:48.540 --> 50:50.340
因为z是指向谁的

50:50.540 --> 50:51.540
指向谁的

50:51.540 --> 50:52.940
指向的是window对象

50:52.940 --> 50:53.340
对吧

50:53.340 --> 50:54.540
指向的是window对象

50:54.540 --> 50:56.140
哪怕你这里写了一个函数

50:56.140 --> 50:56.940
比方说用户

50:57.540 --> 50:58.140
用户1

50:58.540 --> 50:59.140
用户1

51:00.740 --> 51:01.540
写了一个函数

51:01.540 --> 51:03.540
然后来这个函数里边有个name属相

51:03.540 --> 51:04.540
有个name属相

51:04.540 --> 51:05.340
有个年年

51:05.340 --> 51:05.740
对吧

51:06.340 --> 51:08.140
哪怕你写了这么一个用户对象

51:08.140 --> 51:09.740
你这里调用那个say hello

51:09.740 --> 51:10.540
它z呢

51:10.540 --> 51:11.340
它指向的是window

51:11.340 --> 51:12.340
我们之前讲过的

51:12.940 --> 51:14.940
我们之前说z指向关键取决于

51:14.940 --> 51:16.540
你这个函数怎么去调用

51:16.540 --> 51:17.740
怎么去调用这个函数

51:18.940 --> 51:19.740
那有的

51:19.740 --> 51:21.340
但是我现在又不能去这样做

51:21.540 --> 51:23.340
我又不能去优热1点say hello

51:23.340 --> 51:24.940
因为优热1里边没这个函数

51:24.940 --> 51:25.940
你明白这个意思吧

51:26.540 --> 51:28.140
优热1它是没有这个函数的

51:28.540 --> 51:29.740
它是没有这个函数的

51:29.740 --> 51:30.940
所以你不能去这样调用

51:31.540 --> 51:32.940
有些人说我在这里写这么一个

51:32.940 --> 51:33.740
不完了吗

51:33.740 --> 51:33.940
对吧

51:33.940 --> 51:34.540
say hello

51:35.340 --> 51:36.740
给它复制为这个say hello

51:36.940 --> 51:37.740
这不可以调用了吗

51:38.540 --> 51:39.140
当然可以

51:39.140 --> 51:39.740
当然可以

51:39.740 --> 51:41.940
但是我们现在探求的是另外一种方式

51:41.940 --> 51:42.940
就是有的时候

51:42.940 --> 51:43.940
你可能没有

51:43.940 --> 51:45.940
不会让你这么轻易的去改变

51:45.940 --> 51:46.940
就是这些对象

51:46.940 --> 51:48.740
有可能这些对象是别人写的

51:48.740 --> 51:49.540
你没有

51:49.540 --> 51:50.740
没有权利去改动

51:51.140 --> 51:54.140
但是我又确实想说出它的名字和联名

51:55.140 --> 51:55.740
怎么办呢

51:56.340 --> 51:56.940
怎么办呢

51:56.940 --> 51:58.940
当然你可以用一个函数把对象传进来

51:58.940 --> 51:59.340
对吧

51:59.740 --> 52:01.340
现在我们探讨的是另外一个东西

52:01.540 --> 52:03.940
这个东西以后我们可能会比较管用

52:04.340 --> 52:05.540
在某些时候特别管用

52:06.540 --> 52:09.940
比方说我们现在要去运行这个函数

52:10.340 --> 52:11.940
现在就是希望这样子

52:12.140 --> 52:13.740
我现在说白了

52:14.140 --> 52:14.740
我有一个对象

52:15.140 --> 52:15.940
我有一个函数

52:16.540 --> 52:17.740
我可能还有别的用户

52:17.940 --> 52:18.740
还有别的用户

52:21.420 --> 52:22.220
还有别的用户

52:23.820 --> 52:26.420
我希望雕这个函数的时候

52:26.420 --> 52:29.220
我Z是要指向某一个对象

52:30.220 --> 52:32.220
那么我们现在要做的就是

52:32.220 --> 52:34.420
要改变这个Z是指向

52:35.020 --> 52:36.220
怎么改变呢

52:36.220 --> 52:36.820
看着

52:37.820 --> 52:40.820
所有的函数都有这么一个

52:41.620 --> 52:44.220
属性也叫做成员方法

52:44.820 --> 52:48.220
叫做一个属性的叫做apply

52:48.220 --> 52:49.620
一个属性的叫做call

52:50.020 --> 52:51.220
这两个属性是一样的

52:51.420 --> 52:52.820
这两个方法是一样的意思

52:53.020 --> 52:54.220
我们首先看apply

52:57.020 --> 52:57.820
通过这个方法

52:58.020 --> 52:58.820
一个方法哪来的

52:58.820 --> 52:59.820
我们函数里边没有

52:59.820 --> 53:00.220
对吧

53:00.220 --> 53:01.220
但是它是方形

53:01.420 --> 53:02.420
它是方形的对象

53:02.420 --> 53:04.420
因此方形的给它注入了这么一些方法

53:06.420 --> 53:08.420
这个函数里边有这么一个方法

53:08.620 --> 53:09.220
apply

53:09.220 --> 53:11.020
apply的它是一个方法

53:11.020 --> 53:13.020
它第一个参数就表示的是

53:13.620 --> 53:15.620
我执行这个函数

53:15.820 --> 53:19.420
这个函数内部的Z是指向谁

53:19.420 --> 53:20.820
它第一个参数就是这个意思

53:21.820 --> 53:23.220
我马上执行这个函数

53:24.420 --> 53:26.620
调用它的时候就相当于是在调用它

53:26.820 --> 53:28.220
但是它的好处在于

53:28.220 --> 53:29.420
你可以指定

53:29.620 --> 53:32.220
告诉它Z的指向是谁

53:33.020 --> 53:33.820
指向谁呢

53:34.420 --> 53:35.220
指向的是谁呢

53:35.620 --> 53:37.220
指向的比方说U2E

53:37.820 --> 53:38.220
看着

53:40.220 --> 53:40.620
运行

53:43.360 --> 53:43.760
你看

53:44.360 --> 53:45.360
输出了正常的结果

53:46.360 --> 53:47.560
说明了啥呀

53:47.960 --> 53:49.360
说明了这句话在调

53:49.560 --> 53:50.560
还有两个作用

53:50.560 --> 53:52.360
第一个作用调用函数

53:52.360 --> 53:53.360
调用哪个函数

53:53.360 --> 53:54.160
这个函数

53:54.160 --> 53:55.360
因为它在apply

53:55.360 --> 53:56.360
apply表示什么意思

53:56.360 --> 53:58.160
要应用

53:58.360 --> 53:59.560
在调用这个函数

53:59.560 --> 54:01.960
并且给它指定了Z的指

54:01.960 --> 54:04.360
Z的指一定要指向U2E

54:04.360 --> 54:06.360
一定指向U2E

54:06.360 --> 54:07.360
明白的意思吗

54:07.360 --> 54:10.760
通过这个函数可以指定Z的指向

54:12.160 --> 54:13.360
那么比方说再调用

54:13.360 --> 54:14.560
下一次再调用

54:14.560 --> 54:16.960
我们也可以用另外一个叫做call

54:17.960 --> 54:19.360
也是一样的作用

54:19.760 --> 54:20.360
好

54:20.360 --> 54:23.360
第一个参数的还是Z的指向是谁

54:23.360 --> 54:24.360
比方说U2E

54:25.360 --> 54:27.360
再一次调用下来这个函数

54:27.960 --> 54:30.360
让Z的指向U2E看一下

54:31.360 --> 54:31.860
一看

54:32.560 --> 54:33.360
怎么搞定的

54:33.860 --> 54:34.560
没问题吧

54:34.560 --> 54:35.360
没问题吧

54:36.360 --> 54:36.760
好

54:36.960 --> 54:37.960
这我们记彼啊

54:39.360 --> 54:39.960
apply

54:40.960 --> 54:41.560
方法

54:42.360 --> 54:43.160
这个方法做什么呢

54:43.560 --> 54:44.560
调用函数

54:44.960 --> 54:45.760
调用函数

54:46.760 --> 54:47.560
同时

54:48.160 --> 54:52.360
同时指定函数中的Z指向

54:53.160 --> 54:53.360
好

54:53.360 --> 54:55.560
然后再看一下这个call方法

54:56.960 --> 54:57.960
调用函数

54:59.160 --> 55:04.160
同时指定函数中的Z指向

55:04.160 --> 55:05.560
它两个方法函是一样的

55:05.760 --> 55:06.760
函是一样的

55:07.760 --> 55:09.360
那他们有没有区别呢

55:10.160 --> 55:11.160
他们有区别

55:11.160 --> 55:12.560
他们有一点区别

55:12.960 --> 55:14.760
比方说我们这里有参数

55:14.960 --> 55:16.360
有参数的时候才有区别

55:17.760 --> 55:18.760
参数就随便写了

55:18.760 --> 55:19.760
我也不知道举什么例子

55:19.760 --> 55:20.960
随便写了A和B

55:22.160 --> 55:23.360
那我输出A和B

55:23.760 --> 55:24.760
这两个参数的值

55:25.560 --> 55:25.760
好

55:25.760 --> 55:26.960
那么这里有两个参数了

55:26.960 --> 55:27.360
对吧

55:27.360 --> 55:27.960
有两个参数

55:27.960 --> 55:29.160
你可能要传参数

55:29.760 --> 55:31.360
传参数的时候有区别

55:32.160 --> 55:33.160
而用apply

55:33.160 --> 55:35.360
传参数在后边跟着传

55:35.760 --> 55:36.560
运行这个函数

55:36.560 --> 55:37.960
把Z绑定为这个

55:37.960 --> 55:39.360
后边就是函数的参数

55:39.860 --> 55:41.560
参数把它放到数组里边

55:42.160 --> 55:43.160
把它放到数组里边

55:43.560 --> 55:44.560
它是这样子传地的

55:44.760 --> 55:45.960
把1传给A

55:45.960 --> 55:47.360
把2传给B

55:47.360 --> 55:48.360
它是这样子传地的

55:49.960 --> 55:50.560
看一下吧

55:50.560 --> 55:52.160
这里有说明对吧

55:52.160 --> 55:54.360
参数是以数组的形式传入

55:56.360 --> 55:58.360
另外一个也可以传参数

55:58.360 --> 55:59.960
参数是直接写到后边

56:00.160 --> 56:01.560
就看你自己习惯用哪种

56:01.560 --> 56:02.160
就这个区别

56:02.160 --> 56:03.160
其他没啥区别

56:03.160 --> 56:03.960
都一样

56:03.960 --> 56:06.160
他们主要是用来改变Z是指向的

56:07.160 --> 56:07.760
apply

56:07.760 --> 56:08.560
call都行

56:08.560 --> 56:09.560
都行

56:09.560 --> 56:10.360
好看一下

56:10.360 --> 56:11.360
我们就把它记一下

56:11.360 --> 56:12.160
就是

56:12.560 --> 56:13.960
参数以

56:14.760 --> 56:15.960
数组传递

56:16.360 --> 56:17.360
这个参数

56:18.360 --> 56:20.160
以列表传递

56:20.760 --> 56:21.560
就这个区别

56:21.960 --> 56:22.560
包存

56:22.960 --> 56:23.360
你看

56:23.960 --> 56:25.160
这个结果是一样的

56:25.160 --> 56:25.960
结果是一样的

56:25.960 --> 56:27.160
你看参数都输出了

56:27.960 --> 56:28.760
没问题吧

56:28.760 --> 56:29.960
这是关于这个

56:30.960 --> 56:32.960
方可行里边

56:33.760 --> 56:35.760
其实我们这一张

56:35.960 --> 56:37.160
应该上得很轻松的

56:37.160 --> 56:38.960
如果你觉得这一张很恼火

56:38.960 --> 56:41.160
那是你之前出的问题

56:41.160 --> 56:43.360
比方说我说方可行的实力成员

56:43.360 --> 56:44.560
你是不是要晕一下

56:44.960 --> 56:45.960
方可行的实力成员

56:45.960 --> 56:47.360
你是不是要晕一下

56:47.360 --> 56:48.360
如果你要晕一下

56:48.360 --> 56:49.960
那肯定是你之前出的问题

56:50.360 --> 56:51.560
方可行的实力成员

56:51.560 --> 56:52.760
什么是什么意思

56:52.960 --> 56:53.760
指的是

56:54.760 --> 56:55.760
方可行的对象

56:55.760 --> 56:57.560
方可行的对象是不是就是这些函数

56:57.560 --> 56:59.160
这些函数的成员

56:59.360 --> 56:59.760
看没有

56:59.760 --> 57:00.760
这些函数的成员

57:00.760 --> 57:01.960
就叫实力成员

57:03.360 --> 57:04.760
我说方可行的静态成员

57:04.760 --> 57:06.360
虽然方可行没有静态成员

57:06.360 --> 57:08.360
那比方说我说方可行的静态成员

57:08.360 --> 57:08.960
指的是什么

57:08.960 --> 57:11.760
指的是通过这个构造函数去找到成员

57:11.960 --> 57:13.360
是这么个意思

57:13.360 --> 57:14.560
要搞清楚

57:15.560 --> 57:16.760
其实方可行他

57:16.760 --> 57:19.160
只是我们现在没有学习他的静态成员

57:19.160 --> 57:20.560
实际上他还是有的

57:20.560 --> 57:24.000
这是关于这个点

57:24.000 --> 57:25.000
Apply和扩

57:25.000 --> 57:27.000
那这个东西有什么意义呢

57:27.000 --> 57:28.000
他的意义呢

57:29.000 --> 57:32.000
往往我们用的最常见的就是

57:35.000 --> 57:42.000
通常可以利用Apply和扩方方法

57:43.000 --> 57:44.000
做什么呢

57:44.000 --> 57:45.000
做什么呢

57:45.000 --> 57:49.000
将某个尾数组

57:49.000 --> 57:51.000
某个尾数组

57:51.000 --> 57:54.000
转换为真数组

57:54.000 --> 57:56.000
好具体怎么转呢

57:56.000 --> 57:57.000
给大家看一下

57:57.000 --> 57:58.000
这个地方大家要注意听哦

57:58.000 --> 58:01.000
这是我们以后经常要用到的方式

58:01.000 --> 58:02.000
我们以后呢

58:02.000 --> 58:04.000
会接触很多很多的尾数组

58:04.000 --> 58:06.000
包括在页面上啊

58:06.000 --> 58:07.000
什么很多的元素

58:07.000 --> 58:08.000
对吧拿到

58:08.000 --> 58:09.000
很多的元素过后

58:09.000 --> 58:11.000
得到的就是一个尾数组

58:11.000 --> 58:12.000
那么这些尾数组

58:12.000 --> 58:13.000
有的时候呢

58:13.000 --> 58:15.000
我们需要用到真数组里面的一些方法

58:15.000 --> 58:17.000
但是尾数组里面是没有这些方法的

58:17.000 --> 58:18.000
我们需要用

58:18.000 --> 58:19.000
那怎么办呢

58:19.000 --> 58:21.000
需要把它转换为真数组

58:21.000 --> 58:23.000
好怎么来转

58:23.000 --> 58:25.000
看这一种非常巧妙的办法

58:25.000 --> 58:28.000
比方说我这里有个函数

58:28.000 --> 58:29.000
函数里面不是有个尾数组

58:29.000 --> 58:30.000
叫做argument

58:30.000 --> 58:31.000
对吧

58:31.000 --> 58:32.000
argument我们是

58:32.000 --> 58:33.000
现在目前接触的

58:33.000 --> 58:34.000
第一个尾数组

58:34.000 --> 58:35.000
我们后面还会接触

58:35.000 --> 58:36.000
其他的尾数组

58:36.000 --> 58:38.000
好有这么一个argument

58:38.000 --> 58:39.000
这个尾数组

58:39.000 --> 58:40.000
ok

58:40.000 --> 58:41.000
现在呢

58:41.000 --> 58:43.000
函数给它传一些参数进去

58:43.000 --> 58:44.000
给它传一些参数进去

58:44.000 --> 58:45.000
你看这些全是尾数组

58:45.000 --> 58:47.000
它放到一个尾数组里边去了

58:47.000 --> 58:48.000
现在呢

58:48.000 --> 58:49.000
我们要在函数里边

58:49.000 --> 58:50.000
把这个argument

58:50.000 --> 58:52.000
转换为真数组

58:52.000 --> 58:54.000
将argument

58:54.000 --> 58:57.000
转换为真数组

58:57.000 --> 59:00.000
转换为

59:00.000 --> 59:02.000
真数组

59:02.000 --> 59:03.000
好先看一下

59:03.000 --> 59:04.000
先看一下目前的

59:04.000 --> 59:07.340
好目前呢

59:07.340 --> 59:09.340
我们得到的是一个尾数组

59:09.340 --> 59:10.340
argument

59:10.340 --> 59:11.340
它不是array

59:11.340 --> 59:13.340
好我们把它转换成真数组

59:13.340 --> 59:15.340
怎么转换呢

59:15.340 --> 59:16.340
怎么转换呢

59:16.340 --> 59:17.340
我们可以用这种

59:17.340 --> 59:19.340
巧妙的办法看着

59:19.340 --> 59:21.340
这是不是一个数组

59:21.340 --> 59:22.340
两个中过号

59:22.340 --> 59:23.340
你先想一想

59:23.340 --> 59:25.340
它是不是一个数组

59:25.340 --> 59:26.340
没问题吧

59:26.340 --> 59:27.340
它肯定是个数组

59:27.340 --> 59:28.340
对吧

59:28.340 --> 59:29.340
它没有任何东西

59:29.340 --> 59:30.340
是个数组

59:30.340 --> 59:31.340
数组里边

59:31.340 --> 59:32.340
是不是有一个实力方法

59:32.340 --> 59:33.340
我们以前学过了

59:33.340 --> 59:34.340
对吧

59:34.340 --> 59:35.340
数组里面有很多的方法

59:35.340 --> 59:37.340
一个方法叫做slice

59:37.340 --> 59:38.340
对吧

59:38.340 --> 59:39.340
这是不是个函数

59:39.340 --> 59:40.340
这是数组里边

59:40.340 --> 59:41.340
一个函数

59:41.340 --> 59:43.340
数组里边一个函数

59:43.340 --> 59:44.340
slice表示什么意思

59:44.340 --> 59:45.340
表示的是

59:45.340 --> 59:47.340
这个数组的切片

59:47.340 --> 59:48.340
给这个数组从

59:48.340 --> 59:49.340
数组的第几项开始

59:49.340 --> 59:51.340
到第几项之间

59:51.340 --> 59:52.340
我们把它切出来

59:52.340 --> 59:53.340
得到一个新数组

59:53.340 --> 59:54.340
这个意思吧

59:54.340 --> 59:55.340
如果我不传参数

59:55.340 --> 59:56.340
是不是得到

59:56.340 --> 59:58.340
完全一个完整的新数组

59:58.340 --> 01:00:00.340
没问题吧

01:00:00.340 --> 01:00:01.340
所以往来

01:00:01.340 --> 01:00:02.340
一说又还给我了

01:00:02.340 --> 01:00:03.340
你好好回忆一下

01:00:03.340 --> 01:00:04.340
要不然你把之前

01:00:04.340 --> 01:00:05.340
那个slice

01:00:05.340 --> 01:00:06.340
数组的一颗看一下

01:00:06.340 --> 01:00:07.340
slice

01:00:07.340 --> 01:00:09.340
要不然去看一下mdn

01:00:09.340 --> 01:00:10.340
说一下吧

01:00:10.340 --> 01:00:12.340
好 3 2

01:00:13.340 --> 01:00:15.340
虽然我是说的是视频课程

01:00:15.340 --> 01:00:16.340
但是我能感觉到

01:00:16.340 --> 01:00:17.340
你们像这些

01:00:17.340 --> 01:00:18.340
比较少见的东西

01:00:18.340 --> 01:00:20.340
用的比较少的东西

01:00:20.340 --> 01:00:21.340
你可能忘了

01:00:21.340 --> 01:00:22.340
slice

01:00:22.340 --> 01:00:25.340
比方说我这里写一个1和3

01:00:25.340 --> 01:00:26.340
得到的是什么呢

01:00:26.340 --> 01:00:28.340
得到的是下标1开始

01:00:28.340 --> 01:00:30.340
下标2 3取不到

01:00:30.340 --> 01:00:32.340
得到的是56和7

01:00:32.340 --> 01:00:33.340
看一下

01:00:33.340 --> 01:00:34.340
6而锐

01:00:34.340 --> 01:00:38.480
数出6而锐

01:00:38.480 --> 01:00:40.480
看一下得到的是56和7

01:00:41.480 --> 01:00:42.480
你看没有

01:00:42.480 --> 01:00:43.480
56和7

01:00:43.480 --> 01:00:44.480
这是个新的数组

01:00:44.480 --> 01:00:46.480
如果我不传参数

01:00:46.480 --> 01:00:47.480
是不是得到一个

01:00:47.480 --> 01:00:48.480
完整的新数组

01:00:48.480 --> 01:00:49.480
没问题吧

01:00:49.480 --> 01:00:50.480
你看

01:00:50.480 --> 01:00:52.480
完整的新数组

01:00:52.480 --> 01:00:54.480
他是怎么来得到

01:00:54.480 --> 01:00:55.480
完整的新数组呢

01:00:55.480 --> 01:00:57.480
因为这个slice里边

01:00:57.480 --> 01:00:58.480
这个函数里边

01:00:58.480 --> 01:01:00.480
他用到了z

01:01:00.480 --> 01:01:01.480
z表示什么

01:01:01.480 --> 01:01:03.480
就表示当前数组

01:01:03.480 --> 01:01:04.480
从当前数组来

01:01:04.480 --> 01:01:05.480
解取

01:01:05.480 --> 01:01:08.480
解取一段返回

01:01:08.480 --> 01:01:10.480
神奇的事情来了

01:01:10.480 --> 01:01:11.480
看着

01:01:11.480 --> 01:01:12.480
它是不是函数

01:01:12.480 --> 01:01:13.480
是函数吧

01:01:13.480 --> 01:01:14.480
函数

01:01:14.480 --> 01:01:16.480
它一定是一个方式的对象

01:01:16.480 --> 01:01:17.480
好

01:01:17.480 --> 01:01:19.480
那么既然它是方式的对象

01:01:19.480 --> 01:01:20.480
它一定拥有实力成员

01:01:20.480 --> 01:01:21.480
core

01:01:21.480 --> 01:01:22.480
或者是apply

01:01:22.480 --> 01:01:24.480
我给它改变z

01:01:24.480 --> 01:01:25.480
指向

01:01:25.480 --> 01:01:27.480
让它指向这个

01:01:27.480 --> 01:01:29.480
让它指向这个尾数组

01:01:29.480 --> 01:01:30.480
于是呢

01:01:30.480 --> 01:01:32.480
它运行的时候

01:01:32.480 --> 01:01:33.480
是不是把z

01:01:33.480 --> 01:01:35.480
当成这个尾数组了

01:01:35.480 --> 01:01:36.480
它在循环

01:01:36.480 --> 01:01:37.480
在进行解去的时候

01:01:37.480 --> 01:01:38.480
它把z

01:01:38.480 --> 01:01:40.480
当成了尾数组

01:01:40.480 --> 01:01:42.480
给它改变z指向

01:01:42.480 --> 01:01:43.480
它调用这个函数

01:01:43.480 --> 01:01:45.480
同时给它改变z指向

01:01:45.480 --> 01:01:47.480
指向这个尾数组

01:01:47.480 --> 01:01:48.480
于是呢

01:01:48.480 --> 01:01:49.480
它就在尾数组基础上

01:01:49.480 --> 01:01:50.480
来进行解取

01:01:50.480 --> 01:01:51.480
返回一个新数组

01:01:51.480 --> 01:01:52.480
好

01:01:52.480 --> 01:01:53.480
我们来得到一个新数组

01:01:53.480 --> 01:01:54.480
6而为

01:01:54.480 --> 01:01:56.480
看着

01:01:56.480 --> 01:01:57.480
下面两句话去掉

01:01:57.480 --> 01:01:59.480
在这里输出

01:01:59.480 --> 01:02:01.480
6而为

01:02:01.480 --> 01:02:03.480
保存看一下

01:02:03.480 --> 01:02:04.480
你看

01:02:04.480 --> 01:02:05.480
现在我们得到的

01:02:05.480 --> 01:02:07.480
就是一个真实的数组

01:02:07.480 --> 01:02:08.480
看没

01:02:08.480 --> 01:02:09.480
一个真实的数组

01:02:09.480 --> 01:02:10.480
前面是一个尾数组

01:02:10.480 --> 01:02:11.480
argument

01:02:11.480 --> 01:02:12.480
现在我们通过这个argument

01:02:12.480 --> 01:02:14.480
得到一个真实的数组

01:02:14.480 --> 01:02:15.480
有了真实的数组过后

01:02:15.480 --> 01:02:16.480
真实的数组里面

01:02:16.480 --> 01:02:17.480
所有的成员方法

01:02:17.480 --> 01:02:18.480
全部可以用了

01:02:18.480 --> 01:02:19.480
什么snice

01:02:19.480 --> 01:02:20.480
splice

01:02:20.480 --> 01:02:21.480
pop

01:02:21.480 --> 01:02:22.480
poop

01:02:22.480 --> 01:02:23.480
全部可以用了

01:02:23.480 --> 01:02:24.480
尾数组是用不了的

01:02:24.480 --> 01:02:25.480
很多方法都是缺失的

01:02:25.480 --> 01:02:27.480
但真数组是可以的

01:02:27.480 --> 01:02:28.480
是可以的

01:02:28.480 --> 01:02:29.480
明白这个意思吗

01:02:29.480 --> 01:02:31.480
它为什么要用尾数组

01:02:31.480 --> 01:02:33.480
因为它觉得有些东西

01:02:33.480 --> 01:02:34.480
不用把它当成数组

01:02:34.480 --> 01:02:35.480
它不需要有这么多数性

01:02:35.480 --> 01:02:36.480
有这些数性

01:02:36.480 --> 01:02:37.480
它会占用内存空间

01:02:37.480 --> 01:02:38.480
所以说

01:02:38.480 --> 01:02:39.480
它可以做了个尾数组出来

01:02:39.480 --> 01:02:40.480
但是我可以

01:02:40.480 --> 01:02:41.480
有的时候要用的时候

01:02:41.480 --> 01:02:43.480
可以把它转换为真数组

01:02:43.480 --> 01:02:44.480
那么之后

01:02:44.480 --> 01:02:45.480
我们还会学习

01:02:45.480 --> 01:02:46.480
标准库里面数组的

01:02:46.480 --> 01:02:47.480
还会再次学习

01:02:47.480 --> 01:02:49.480
标准库里面数组的一些

01:02:49.480 --> 01:02:50.480
常用的实力方法

01:02:50.480 --> 01:02:51.480
那么我们就可以

01:02:51.480 --> 01:02:53.480
用那些实力方法了

01:02:53.480 --> 01:02:54.480
明白这个意思吗

01:02:54.480 --> 01:02:55.480
再来看一次

01:02:55.480 --> 01:02:56.480
随便用弄一个数组出来

01:02:56.480 --> 01:02:57.480
一个空数组

01:02:57.480 --> 01:02:59.480
它有一个snice方法

01:02:59.480 --> 01:03:00.480
snice是一个方法

01:03:00.480 --> 01:03:01.480
它自然有

01:03:01.480 --> 01:03:03.480
有这个函数里面的成员

01:03:03.480 --> 01:03:04.480
成员方法

01:03:04.480 --> 01:03:05.480
扩

01:03:05.480 --> 01:03:06.480
这个方法可以改变

01:03:06.480 --> 01:03:07.480
race的指向

01:03:07.480 --> 01:03:08.480
那么这句话的意思就是

01:03:08.480 --> 01:03:10.480
调用snice方法

01:03:10.480 --> 01:03:12.480
改变race的指向

01:03:12.480 --> 01:03:13.480
指向谁呢

01:03:13.480 --> 01:03:14.480
指向这个尾数组

01:03:14.480 --> 01:03:15.480
让它从这个尾数组里面

01:03:15.480 --> 01:03:16.480
去解取一段

01:03:16.480 --> 01:03:18.480
那么后边我没有给参数了

01:03:18.480 --> 01:03:19.480
没有给参数

01:03:19.480 --> 01:03:20.480
它就解取这个尾数组的

01:03:20.480 --> 01:03:21.480
全部形成一个

01:03:21.480 --> 01:03:23.480
新数组返回

01:03:23.480 --> 01:03:25.480
如果你不这样子写

01:03:25.480 --> 01:03:26.480
如果你不这样子写

01:03:26.480 --> 01:03:27.480
像之前那样子写

01:03:27.480 --> 01:03:29.480
它直接调用的话

01:03:29.480 --> 01:03:30.480
那么它是把race当成谁的

01:03:30.480 --> 01:03:32.480
当成这个对象

01:03:32.480 --> 01:03:33.480
一个对象是空的

01:03:33.480 --> 01:03:34.480
对吧

01:03:34.480 --> 01:03:35.480
你这个对象是空的

01:03:35.480 --> 01:03:36.480
所以说

01:03:36.480 --> 01:03:37.480
race为这个对象的时候

01:03:37.480 --> 01:03:39.480
它结束不出来任何东西

01:03:39.480 --> 01:03:40.480
有些同学说

01:03:40.480 --> 01:03:41.480
那还不简单吗

01:03:41.480 --> 01:03:42.480
你把这个东西换成argument

01:03:42.480 --> 01:03:43.480
对不起

01:03:43.480 --> 01:03:44.480
argument是个尾数组

01:03:44.480 --> 01:03:45.480
它没有这个东西

01:03:45.480 --> 01:03:46.480
它没有这个东西

01:03:46.480 --> 01:03:48.480
只有真数组才有

01:03:48.480 --> 01:03:49.480
你看这个意思

01:03:49.480 --> 01:03:50.480
我们可以通过这种方式

01:03:50.480 --> 01:03:52.480
把它转换成真数组

01:03:52.480 --> 01:03:53.480
以后

01:03:53.480 --> 01:03:55.480
你要转换成真数组的时候

01:03:55.480 --> 01:03:57.480
都可以使用这种方式

01:03:57.480 --> 01:03:58.480
好

01:03:58.480 --> 01:03:59.480
这是关于

01:03:59.480 --> 01:04:00.480
如何把一个尾数组

01:04:00.480 --> 01:04:01.480
转换成真数组

01:04:01.480 --> 01:04:03.480
这是一种非常非常常见的方式

01:04:03.480 --> 01:04:04.480
大家要注意

01:04:04.480 --> 01:04:05.480
要记住

01:04:05.480 --> 01:04:06.480
好了

01:04:06.480 --> 01:04:07.480
我们再看一下

01:04:07.480 --> 01:04:08.480
再看一下

01:04:08.480 --> 01:04:09.480
这个方式里面

01:04:09.480 --> 01:04:10.480
还有哪些东西呢

01:04:10.480 --> 01:04:11.480
它是下面说的

01:04:11.480 --> 01:04:12.480
还有一个toast gene

01:04:12.480 --> 01:04:13.480
对吧

01:04:13.480 --> 01:04:14.480
你看它这里是不是

01:04:14.480 --> 01:04:15.480
提示的说得很明白了

01:04:15.480 --> 01:04:16.480
它说获取这个

01:04:16.480 --> 01:04:17.480
函数实现的

01:04:17.480 --> 01:04:18.480
单一码的制服串

01:04:18.480 --> 01:04:19.480
它覆盖了谁呢

01:04:19.480 --> 01:04:20.480
覆盖了

01:04:20.480 --> 01:04:22.480
这个对象上面的

01:04:22.480 --> 01:04:23.480
toast gene方法

01:04:23.480 --> 01:04:24.480
因为函数

01:04:24.480 --> 01:04:25.480
它本身也是对象

01:04:25.480 --> 01:04:26.480
它也有toast gene

01:04:26.480 --> 01:04:27.480
所以说

01:04:27.480 --> 01:04:28.480
它自己写的一个toast gene

01:04:28.480 --> 01:04:29.480
来覆盖了之前的方法

01:04:29.480 --> 01:04:30.480
我们之前说过的这个问题

01:04:30.480 --> 01:04:31.480
对吧

01:04:31.480 --> 01:04:32.480
还有啥呢

01:04:33.480 --> 01:04:34.480
还有这个band

01:04:34.480 --> 01:04:35.480
这个band我们来看一下

01:04:35.480 --> 01:04:37.480
这个band也是用来改变ZS的

01:04:37.480 --> 01:04:39.480
也是用来改变ZS的

01:04:39.480 --> 01:04:40.480
没问题吧

01:04:40.480 --> 01:04:41.480
只不过它改变ZS的

01:04:41.480 --> 01:04:43.480
它比较有意思

01:04:43.480 --> 01:04:45.480
它比较有意思

01:04:45.480 --> 01:04:46.480
它这个改变ZS

01:04:46.480 --> 01:04:48.480
它是这样子来做的

01:04:48.480 --> 01:04:49.480
看着

01:04:49.480 --> 01:04:51.480
它改变ZS的指向

01:04:51.480 --> 01:04:52.480
它是这样子来做的

01:04:52.480 --> 01:04:55.480
我们看一下改变ZS指向

01:04:56.480 --> 01:05:00.240
还是这个页面

01:05:00.240 --> 01:05:02.240
把运行出来

01:05:02.240 --> 01:05:06.450
还是要改变ZS指向

01:05:06.450 --> 01:05:07.450
有两个对象

01:05:07.450 --> 01:05:08.450
现在我要调用这个函数

01:05:08.450 --> 01:05:10.450
改变它的ZS指向

01:05:10.450 --> 01:05:11.450
指向谁呢

01:05:11.450 --> 01:05:12.450
指向UZER1

01:05:12.450 --> 01:05:13.450
看一下怎么写

01:05:13.450 --> 01:05:14.450
我们还可以用这种方式来写

01:05:14.450 --> 01:05:15.450
say hello

01:05:15.450 --> 01:05:17.450
里面一个函数叫band

01:05:17.450 --> 01:05:19.450
它也是可以改变ZS指向

01:05:19.450 --> 01:05:21.450
它叫做绑定

01:05:21.450 --> 01:05:23.450
下面叫做调用

01:05:23.450 --> 01:05:24.450
apply call

01:05:24.450 --> 01:05:26.450
都有调用的意思

01:05:26.450 --> 01:05:28.450
而这个band就是绑定

01:05:28.450 --> 01:05:30.450
绑定它不会调用的

01:05:30.450 --> 01:05:32.450
它只是绑定ZS

01:05:32.450 --> 01:05:34.450
你把ZS传给它

01:05:34.450 --> 01:05:36.450
你把ZS传给它

01:05:36.450 --> 01:05:37.450
ZS传递谁呢

01:05:37.450 --> 01:05:40.450
传递就是UZER1

01:05:40.450 --> 01:05:41.450
后面有参数

01:05:41.450 --> 01:05:42.450
参数的话

01:05:42.450 --> 01:05:43.450
跟course一样的

01:05:43.450 --> 01:05:44.450
跟course一样的

01:05:44.450 --> 01:05:45.450
可以进行传递

01:05:45.450 --> 01:05:46.450
传递参数

01:05:46.450 --> 01:05:49.450
比方说传递1和2

01:05:49.450 --> 01:05:50.450
随便传递

01:05:50.450 --> 01:05:52.450
传递一个参数给A和B

01:05:52.450 --> 01:05:53.450
那么这个函数

01:05:53.450 --> 01:05:54.450
它不会调用

01:05:54.450 --> 01:05:55.450
保存你看一下

01:05:55.450 --> 01:05:57.450
函数有没有调用

01:05:57.450 --> 01:05:58.450
函数没有输出

01:05:58.450 --> 01:06:00.450
没有输出还没有调用

01:06:00.450 --> 01:06:01.450
那么它会

01:06:01.450 --> 01:06:02.450
它怎么样绑定呢

01:06:02.450 --> 01:06:04.450
它是返回一个新函数

01:06:04.450 --> 01:06:06.450
new funk

01:06:06.450 --> 01:06:07.450
返回一个新函数

01:06:07.450 --> 01:06:10.450
这个新函数无论你用

01:06:10.450 --> 01:06:11.450
什么样的方式调用

01:06:11.450 --> 01:06:14.450
它的ZS指向固定固定为UZER1

01:06:14.450 --> 01:06:16.450
它是起这么一个作用

01:06:16.450 --> 01:06:17.450
new funk

01:06:17.450 --> 01:06:18.450
你调用的时候

01:06:18.450 --> 01:06:22.450
它ZS的指向固定为UZER1

01:06:22.450 --> 01:06:25.450
保存你看一下

01:06:25.450 --> 01:06:26.450
尽管我们是直接调用的

01:06:26.450 --> 01:06:27.450
我们之前说

01:06:27.450 --> 01:06:28.450
直接调用一个函数

01:06:28.450 --> 01:06:29.450
它指向的是谁

01:06:29.450 --> 01:06:31.450
指向的是全局变量

01:06:31.450 --> 01:06:32.450
全局对象 稳斗

01:06:32.450 --> 01:06:34.450
但是现在不一样了

01:06:34.450 --> 01:06:35.450
它绑定了ZS

01:06:35.450 --> 01:06:37.450
那么这个函数无论你咋调用

01:06:37.450 --> 01:06:39.450
它指向的都是UZER1

01:06:39.450 --> 01:06:41.450
这样子写的好处在于

01:06:41.450 --> 01:06:43.450
你后面可以调用多次

01:06:43.450 --> 01:06:45.450
它ZS的指向不会改变

01:06:45.450 --> 01:06:46.450
它比下面的好地方

01:06:46.450 --> 01:06:47.450
好的地方就在于

01:06:47.450 --> 01:06:48.450
下面它执行了一次过后

01:06:48.450 --> 01:06:49.450
下一次再来调用

01:06:49.450 --> 01:06:51.450
是不是又得重新用一次erpline

01:06:51.450 --> 01:06:52.450
对吧

01:06:52.450 --> 01:06:53.450
又得重新用一次erpline

01:06:53.450 --> 01:06:54.450
改变ZS指向

01:06:54.450 --> 01:06:56.450
那这个地方就不用了

01:06:56.450 --> 01:06:58.450
这种方式适用于

01:06:58.450 --> 01:07:00.450
我们得到一个函数

01:07:00.450 --> 01:07:02.450
改变了ZS指向得到一个函数

01:07:02.450 --> 01:07:04.450
这个函数可能要多次调用

01:07:04.450 --> 01:07:06.450
为了方便我们可以用band

01:07:06.450 --> 01:07:08.450
得到一个新的函数

01:07:08.450 --> 01:07:11.450
一个函数能不能返回一个函数

01:07:11.450 --> 01:07:12.450
当然没问题

01:07:12.450 --> 01:07:13.450
函数可以返回任何东西

01:07:13.450 --> 01:07:14.450
可以返回对象

01:07:14.450 --> 01:07:15.450
返回字不串

01:07:15.450 --> 01:07:17.450
返回undefined

01:07:17.450 --> 01:07:18.450
返回数字

01:07:18.450 --> 01:07:19.450
当然也可以返回一个函数

01:07:19.450 --> 01:07:21.450
函数是一等公米

01:07:22.450 --> 01:07:23.450
咱们记一下

01:07:23.450 --> 01:07:25.450
这个band方法

01:07:25.450 --> 01:07:29.450
这个是得到一个新函数

01:07:29.450 --> 01:07:32.450
该函数中的ZS

01:07:32.450 --> 01:07:35.450
始终指向

01:07:35.450 --> 01:07:37.450
始终指向

01:07:37.450 --> 01:07:39.450
指定的

01:07:39.450 --> 01:07:41.450
指定的

01:07:41.450 --> 01:07:43.450
得到一个新的函数

01:07:43.450 --> 01:07:44.450
这个新的函数

01:07:44.450 --> 01:07:46.450
跟这个函数的函数内容是一样的

01:07:46.450 --> 01:07:47.450
只不过它的ZS指向

01:07:47.450 --> 01:07:48.450
始终指向

01:07:48.450 --> 01:07:50.450
你指定的ZS

01:07:50.450 --> 01:07:52.450
这是关于band

01:07:52.450 --> 01:07:53.450
以后可能学到

01:07:53.450 --> 01:07:55.450
后边的时候会用到

01:07:55.450 --> 01:07:57.450
其他就没啥了

01:07:57.450 --> 01:08:00.450
所有的函数都有这些东西

01:08:00.450 --> 01:08:02.450
那么咱们这一课

01:08:02.450 --> 01:08:04.450
学到object和方形

01:08:04.450 --> 01:08:06.450
这两个对象

01:08:06.450 --> 01:08:07.450
这两个对象

01:08:07.450 --> 01:08:08.450
一个表示对象

01:08:08.450 --> 01:08:09.450
所有的对象

01:08:09.450 --> 01:08:11.450
它都有它的实力成员

01:08:11.450 --> 01:08:12.450
函数也是对象

01:08:12.450 --> 01:08:15.450
函数也有它的实力成员

01:08:15.450 --> 01:08:17.450
另外一个是

01:08:17.450 --> 01:08:18.450
函数

01:08:18.450 --> 01:08:19.450
所有的函数

01:08:19.450 --> 01:08:21.450
都会拥有这些实力成员

01:08:21.450 --> 01:08:23.450
那咱们之后还会学习很多

01:08:23.450 --> 01:08:25.450
比方说咱们学习实均

01:08:25.450 --> 01:08:27.450
我介绍了实均的实力成员的时候

01:08:27.450 --> 01:08:28.450
是不是什么意思

01:08:28.450 --> 01:08:29.450
说明所有的制服串

01:08:29.450 --> 01:08:31.450
都有这些实力成员

01:08:31.450 --> 01:08:33.450
后边我们会学习array

01:08:33.450 --> 01:08:35.450
我们说到array的实力成员

01:08:35.450 --> 01:08:37.450
那么指的是什么意思呢

01:08:37.450 --> 01:08:38.450
指的是所有的array

01:08:38.450 --> 01:08:40.450
都有这些实力成员

01:08:40.450 --> 01:08:42.450
是这么一个意思

01:08:42.450 --> 01:08:43.450
好了

01:08:43.450 --> 01:08:44.450
这是关于

01:08:44.450 --> 01:08:46.450
这个Object和方式

