WEBVTT

00:00.000 --> 00:03.000
第1道题

00:03.000 --> 00:13.120
来呗

00:13.120 --> 00:15.120
第1道题 来啊

00:15.120 --> 00:17.120
第1道题

00:17.120 --> 00:20.120
一点也挺没有

00:20.120 --> 00:22.120
第1道题啊

00:22.120 --> 00:25.120
第1道题是提示用户输入数组的长度

00:25.120 --> 00:27.120
让用户输入一个数组的长度

00:27.120 --> 00:29.120
以及输入每一项的值

00:29.120 --> 00:30.120
然后输出这个数组

00:30.120 --> 00:32.120
我们来看一下第1道题

00:32.120 --> 00:35.120
可能第1道题就把好的同学就搞晕了

00:35.120 --> 00:36.120
首先来呗

00:36.120 --> 00:38.120
先让用户输入一个数组的长度嘛

00:38.120 --> 00:39.120
对吧

00:39.120 --> 00:41.120
我们得到一个变量

00:41.120 --> 00:43.120
表示数组的长度

00:43.120 --> 00:45.120
提示用户输入

00:45.120 --> 00:47.120
把它转换成数字

00:47.120 --> 00:49.120
请输入数

00:49.120 --> 00:51.120
输入数组的长度

00:51.120 --> 00:54.120
输入的长度

00:54.120 --> 00:56.120
让用户输入这个数组的长度

00:56.120 --> 00:58.120
看一下

00:58.120 --> 01:00.120
没问题吧

01:00.120 --> 01:02.120
让用户输入这个数组的长度

01:02.120 --> 01:04.120
当然用户有可能输入有误

01:04.120 --> 01:06.120
有可能会输入有误

01:06.120 --> 01:08.120
判断一下

01:08.120 --> 01:10.120
如果意思NAN

01:10.120 --> 01:12.120
如果意思NAN

01:12.120 --> 01:14.120
它是一个非数字

01:14.120 --> 01:15.120
或者是

01:15.120 --> 01:17.120
这个数字小于0

01:17.120 --> 01:19.120
长度是不能为付出的

01:19.120 --> 01:21.120
有可能这个数字

01:21.120 --> 01:22.120
数字是小于0的

01:22.120 --> 01:23.120
或者NAN

01:23.120 --> 01:24.120
小于了0

01:24.120 --> 01:26.120
那么我们这里就输出

01:26.120 --> 01:28.120
输入有误

01:28.120 --> 01:30.120
输入有误

01:30.120 --> 01:31.120
OK

01:31.120 --> 01:32.120
就结束了

01:32.120 --> 01:33.120
就结束了

01:33.120 --> 01:34.120
什么都不做了

01:34.120 --> 01:36.120
好 咱们再看一下

01:36.120 --> 01:38.120
输出长度

01:38.120 --> 01:40.120
输入一个字物串

01:40.120 --> 01:42.120
一个不正确的长度

01:42.120 --> 01:44.120
点确定

01:44.120 --> 01:46.120
这个长度

01:46.120 --> 01:48.120
这个长度我看一下

01:48.120 --> 01:49.120
ABC

01:49.120 --> 01:50.120
输入有误

01:50.120 --> 01:51.120
再刷新

01:51.120 --> 01:52.120
如果是一个数字

01:52.120 --> 01:53.120
然后这里

01:53.120 --> 01:54.120
字物串的话

01:54.120 --> 01:55.120
输入有误

01:55.120 --> 01:56.120
刚才怎么回事

01:56.120 --> 01:57.120
刚才应该是没刷新

01:57.120 --> 01:58.120
这里

01:58.120 --> 01:59.120
输入一个长度

01:59.120 --> 02:00.120
然后字物串

02:00.120 --> 02:01.120
点确定

02:01.120 --> 02:03.120
说实就表示输入正确

02:03.120 --> 02:05.120
输入正确干嘛

02:05.120 --> 02:07.120
输入正确要干嘛

02:07.120 --> 02:09.120
输入正确是不是要一次提示

02:09.120 --> 02:11.120
用户

02:11.120 --> 02:13.120
来输入每一个数组的内容

02:13.120 --> 02:15.120
数组的每一项内容

02:15.120 --> 02:16.120
那么这里

02:16.120 --> 02:18.120
我们首先建立一个数组

02:18.120 --> 02:20.120
六一个R

02:20.120 --> 02:22.120
这里我就不能用中括号了

02:22.120 --> 02:23.120
就不能用中括号了

02:23.120 --> 02:24.120
因为为什么

02:24.120 --> 02:26.120
因为这个数组

02:26.120 --> 02:27.120
这个数组的长度

02:27.120 --> 02:28.120
是不是已经确定下来了

02:28.120 --> 02:29.120
但是你中括号

02:29.120 --> 02:31.120
但是数组的每一项你不知道是啥

02:31.120 --> 02:33.120
它每一项你不知道是啥

02:33.120 --> 02:34.120
所以说

02:34.120 --> 02:35.120
我们应该用什么呢

02:35.120 --> 02:37.120
应该用是吧

02:37.120 --> 02:39.120
应该用就是六一个R

02:39.120 --> 02:40.120
来确定它的长度

02:40.120 --> 02:41.120
长度是多少

02:41.120 --> 02:43.120
长度是内

02:43.120 --> 02:45.120
把这个东西放进来

02:45.120 --> 02:46.120
表示创建一个长度

02:46.120 --> 02:48.120
为这么多的一个数组

02:48.120 --> 02:49.120
如果你用中括号的话

02:49.120 --> 02:50.120
你现在又不知道

02:50.120 --> 02:51.120
数组的每一项的值

02:51.120 --> 02:52.120
对吧

02:52.120 --> 02:53.120
也不知道它每一项的值

02:53.120 --> 02:54.120
当然你用中括号

02:54.120 --> 02:56.120
其实我一会写完了之后

02:56.120 --> 02:57.120
我再说一下

02:57.120 --> 02:58.120
中括号的解法

02:58.120 --> 03:00.120
其实中括号也可以

03:00.120 --> 03:01.120
得到数组的长度之后

03:01.120 --> 03:02.120
怎么办呢

03:02.120 --> 03:04.120
是不是循环

03:04.120 --> 03:05.120
数组有五项

03:05.120 --> 03:06.120
你就循环五次

03:06.120 --> 03:08.120
每一循环一次

03:08.120 --> 03:11.120
让用户来输入一个数组的数据

03:11.120 --> 03:13.120
循环

03:13.120 --> 03:14.120
好循环

03:14.120 --> 03:15.120
I小于它

03:15.120 --> 03:16.120
可以小于NN

03:16.120 --> 03:18.120
也可以小于AR2.nance

03:18.120 --> 03:19.120
是不是一样的

03:19.120 --> 03:20.120
对吧

03:20.120 --> 03:21.120
这两个是一样的

03:21.120 --> 03:22.120
是一样的

03:22.120 --> 03:25.120
I加一加

03:25.120 --> 03:26.120
好

03:26.120 --> 03:27.120
每循环一次做什么呢

03:27.120 --> 03:29.120
提示用户输入

03:29.120 --> 03:31.120
提示

03:31.120 --> 03:34.120
提示用户输入

03:34.120 --> 03:37.120
数组的这一项的值

03:37.120 --> 03:39.120
你看这里

03:39.120 --> 03:40.120
以及数组每一项的值

03:40.120 --> 03:42.120
它也是让用户输入的

03:42.120 --> 03:43.120
好

03:43.120 --> 03:44.120
那么我们这里就提示一下

03:44.120 --> 03:46.120
提示一下

03:46.120 --> 03:47.120
propt

03:47.120 --> 03:48.120
提示

03:48.120 --> 03:51.120
请输入数组

03:51.120 --> 03:52.120
第几项

03:52.120 --> 03:54.120
第几项的值呢

03:54.120 --> 03:55.120
好

03:55.120 --> 03:57.120
这个I等于0的时候

03:57.120 --> 03:58.120
是不是第一项

03:58.120 --> 03:59.120
I等于1的时候

03:59.120 --> 04:00.120
第二项

04:00.120 --> 04:01.120
I等于3的时候

04:01.120 --> 04:02.120
第四项

04:02.120 --> 04:03.120
所以说这个问号位置

04:03.120 --> 04:04.120
去拼接一下

04:04.120 --> 04:06.120
拼接什么呢

04:06.120 --> 04:08.120
拼接I加1

04:08.120 --> 04:09.120
I加1

04:09.120 --> 04:10.120
但是你注意拼接I加1的时候

04:10.120 --> 04:12.120
你一定要把这个I加1

04:12.120 --> 04:13.120
扩起来

04:13.120 --> 04:14.120
一定要扩起来

04:14.120 --> 04:15.120
因为如果你不扩起来的话

04:15.120 --> 04:17.120
它是从做到有进行运算

04:17.120 --> 04:18.120
它先拼接I

04:18.120 --> 04:19.120
然后再去拼接1

04:19.120 --> 04:21.120
它就不是拼接到I加1了

04:21.120 --> 04:22.120
要把它扩起来

04:22.120 --> 04:23.120
要把它扩起来

04:25.120 --> 04:26.120
好

04:26.120 --> 04:27.120
请输入这一项的值

04:27.120 --> 04:28.120
那么它的值呢

04:28.120 --> 04:29.120
我这里提的一边

04:29.120 --> 04:31.120
没有说必须是数字

04:31.120 --> 04:32.120
没有说必须是数字

04:32.120 --> 04:33.120
所以说这一块呢

04:33.120 --> 04:34.120
我们没有必要把它

04:34.120 --> 04:35.120
转换成数字

04:35.120 --> 04:36.120
没必要了

04:36.120 --> 04:39.120
直接把用户输入的结果

04:39.120 --> 04:41.120
直接把用户输入的结果

04:41.120 --> 04:42.120
怎么样呢

04:42.120 --> 04:43.120
保存到

04:43.120 --> 04:45.120
保存到数组的第I项

04:45.120 --> 04:46.120
保存进来

04:46.120 --> 04:48.120
是不是就完事了

04:48.120 --> 04:49.120
给这一项复制

04:49.120 --> 04:51.120
给这个属性复制就完事了

04:52.120 --> 04:53.120
就完了

04:53.120 --> 04:54.120
对吧

04:54.120 --> 04:55.120
就完了

04:55.120 --> 04:56.120
然后最后我们输出这个数组

04:56.120 --> 04:58.120
最后我们输出这个数组

04:58.120 --> 04:59.120
保存看一下

04:59.120 --> 05:00.120
看一下

05:00.120 --> 05:03.560
这里我重新刷新一次

05:03.560 --> 05:04.560
请输入数字的长度

05:04.560 --> 05:06.560
长度比方说是3

05:06.560 --> 05:07.560
你看

05:07.560 --> 05:09.560
它提示你输入第1项的值

05:09.560 --> 05:10.560
随便写吧

05:10.560 --> 05:12.560
第2项的值随便写

05:12.560 --> 05:14.560
第3项的值随便写

05:14.560 --> 05:15.560
你看

05:15.560 --> 05:16.560
数字就创建好了

05:16.560 --> 05:18.560
就是让用户来输入

05:18.560 --> 05:19.560
数组里边的内容

05:19.560 --> 05:21.560
我为什么要讲这个东西呢

05:21.560 --> 05:23.560
是因为就在提示你

05:23.560 --> 05:24.560
数组里边的内容

05:24.560 --> 05:25.560
你不能做任何假设

05:25.560 --> 05:27.560
你不能假设数组里面的内容是啥

05:27.560 --> 05:28.560
是啥

05:28.560 --> 05:29.560
你没法做假设

05:29.560 --> 05:31.560
你是不知道数组里面是啥的

05:31.560 --> 05:34.560
因为它有可能来自于用户的数组

05:34.560 --> 05:35.560
OK

05:35.560 --> 05:36.560
这第一题

05:36.560 --> 05:37.560
好

05:37.560 --> 05:38.560
第二题

05:39.560 --> 05:40.560
初始化一个数字数组

05:40.560 --> 05:41.560
怎么叫数字数组

05:41.560 --> 05:43.560
就数组的每一项是个数字

05:43.560 --> 05:44.560
然后求和

05:44.560 --> 05:45.560
做过的对吧

05:45.560 --> 05:46.560
做过的

05:46.560 --> 05:47.560
所以说

05:47.560 --> 05:48.560
这里不再做了

05:48.560 --> 05:49.560
第三题

05:49.560 --> 05:50.560
初始化一个数字数组

05:50.560 --> 05:52.560
然后输出数组中所有的基数

05:52.560 --> 05:54.560
这个题很简单

05:54.560 --> 05:55.560
怎么来吧

05:56.560 --> 05:57.560
第三题

05:57.560 --> 05:59.560
这个就关掉了

05:59.560 --> 06:00.560
关掉

06:00.560 --> 06:01.560
好

06:01.560 --> 06:02.560
第三题

06:02.560 --> 06:07.510
初始化一个数字的数组

06:07.510 --> 06:08.510
数字随便写吧

06:08.510 --> 06:09.510
随便写

06:12.020 --> 06:15.020
输出这个数组中的所有基数

06:15.020 --> 06:17.020
输出这个数组中所有的基数

06:17.020 --> 06:18.020
怎么输出呢

06:18.020 --> 06:19.020
是不是又循环

06:19.020 --> 06:20.020
对吧

06:20.020 --> 06:21.020
又循环

06:21.020 --> 06:22.020
好

06:22.020 --> 06:27.020
index

06:27.020 --> 06:29.020
循环数组的所有下标

06:29.020 --> 06:31.020
把下标一个个下标拿到

06:31.020 --> 06:32.020
拿到之后

06:32.020 --> 06:34.020
输出这个数组中所有的基数

06:34.020 --> 06:36.020
我们怎么来得到

06:36.020 --> 06:37.020
它的数字

06:37.020 --> 06:39.020
是不是可以通过这个表达式

06:39.020 --> 06:40.020
对吧

06:40.020 --> 06:41.020
可以通过这个表达式

06:41.020 --> 06:42.020
来得到这个数组中

06:42.020 --> 06:44.020
这一项的数字

06:44.020 --> 06:45.020
这个是下标

06:45.020 --> 06:46.020
主意

06:46.020 --> 06:47.020
它不是数字

06:47.020 --> 06:48.020
它是下标

06:48.020 --> 06:49.020
我们通过这个表达式

06:49.020 --> 06:50.020
通过下标

06:50.020 --> 06:52.020
输出这个数组的其中一项

06:52.020 --> 06:53.020
取出来过后

06:53.020 --> 06:54.020
判断这一项

06:54.020 --> 06:56.020
判断这个表达式

06:56.020 --> 06:57.020
是不是基数

06:57.020 --> 06:58.020
你不要去判断这个东西

06:58.020 --> 06:59.020
是不是基数

06:59.020 --> 07:01.020
判断这个表达式

07:01.020 --> 07:02.020
是不是基数

07:02.020 --> 07:03.020
除以2

07:03.020 --> 07:06.020
不等于0

07:06.020 --> 07:07.020
那么这就是基数

07:07.020 --> 07:08.020
基数的话

07:08.020 --> 07:10.020
我们就输出这一项

07:10.020 --> 07:12.020
输出这一项

07:12.020 --> 07:13.020
没问题吧

07:13.020 --> 07:14.020
保存看一下

07:14.020 --> 07:20.080
看一下

07:20.080 --> 07:22.080
输出了

07:22.080 --> 07:23.080
就这些

07:23.080 --> 07:24.080
2111 21

07:24.080 --> 07:25.080
对吧

07:25.080 --> 07:26.080
都是基数

07:26.080 --> 07:27.080
好

07:27.080 --> 07:28.080
这是这道题

07:28.080 --> 07:29.080
好

07:29.080 --> 07:30.080
然后下面

07:30.080 --> 07:31.080
输出这个数组中

07:31.080 --> 07:33.080
所有的数数

07:33.080 --> 07:34.080
所有的数数

07:34.080 --> 07:35.080
是不是一样的

07:35.080 --> 07:36.080
一样的

07:36.080 --> 07:37.080
只是输出的做法

07:37.080 --> 07:38.080
稍微麻烦一点

07:38.080 --> 07:39.080
麻烦一点

07:39.080 --> 07:40.080
刚才的是判断基数

07:40.080 --> 07:41.080
那么现在

07:41.080 --> 07:43.080
我们判断啥

07:43.080 --> 07:45.080
判断index

07:45.080 --> 07:47.080
是不是

07:47.080 --> 07:48.080
是不是数数

07:48.080 --> 07:49.080
是这样吗

07:49.080 --> 07:51.080
是不是判断的index

07:52.080 --> 07:53.080
是判断的它吗

07:53.080 --> 07:54.080
判断的是啥

07:54.080 --> 07:56.080
判断的是这个玩意

07:56.080 --> 07:58.080
判断的这个东西

07:58.080 --> 07:59.080
是不是数数

07:59.080 --> 08:00.080
你把它当成一个整体

08:00.080 --> 08:01.080
通过这个下标

08:01.080 --> 08:03.080
去取出数数的这一项

08:03.080 --> 08:04.080
判断的不是下标

08:04.080 --> 08:07.080
判断的是数数的这一项

08:07.080 --> 08:09.080
那么你不要去看外面的

08:09.080 --> 08:10.080
现在给力的这个东西

08:10.080 --> 08:11.080
你看它是不是数数

08:11.080 --> 08:12.080
是不是又来一遍

08:12.080 --> 08:13.080
对吧

08:13.080 --> 08:14.080
又来一遍

08:14.080 --> 08:15.080
判断的数数

08:15.080 --> 08:17.080
isfand

08:17.080 --> 08:18.080
去找

08:18.080 --> 08:19.080
对吧

08:19.080 --> 08:20.080
去找

08:20.080 --> 08:21.080
找啥呢

08:22.080 --> 08:23.080
i等于0

08:23.080 --> 08:24.080
i小

08:24.080 --> 08:25.080
i等于2

08:25.080 --> 08:26.080
从2开始

08:26.080 --> 08:27.080
对吧

08:27.080 --> 08:28.080
2到它的什么

08:28.080 --> 08:29.080
它减1

08:29.080 --> 08:31.080
2到它减1之间的数字

08:33.080 --> 08:35.080
判断这个东西

08:35.080 --> 08:36.080
判断这个数字

08:36.080 --> 08:37.080
是不是数数

08:37.080 --> 08:38.080
对吧

08:38.080 --> 08:39.080
就在2到它减1之间去看

08:39.080 --> 08:40.080
看一下有没有一个数

08:40.080 --> 08:41.080
能整出它

08:41.080 --> 08:43.080
如果找到了其中一个数

08:45.080 --> 08:46.080
除1i

08:46.080 --> 08:47.080
能整出

08:47.080 --> 08:48.080
能整出

08:48.080 --> 08:49.080
如果找到了能整出

08:49.080 --> 08:50.080
怎么办呢

08:50.080 --> 08:51.080
就把它设为q

08:51.080 --> 08:52.080
把它设为q

08:54.080 --> 08:55.080
找到了

08:55.080 --> 08:56.080
然后break 结束

08:56.080 --> 08:58.080
判断数数的代码

08:59.080 --> 09:00.080
找到之后

09:00.080 --> 09:01.080
最后判断一下

09:01.080 --> 09:02.080
有没有找到呢

09:02.080 --> 09:04.080
如果

09:04.080 --> 09:06.080
如果没有找到

09:07.080 --> 09:09.080
并且

09:09.080 --> 09:11.080
这个数字

09:11.080 --> 09:13.080
又是大于

09:13.080 --> 09:14.080
大于什么

09:14.080 --> 09:15.080
大于等于2的

09:15.080 --> 09:16.080
是不是数数

09:16.080 --> 09:17.080
对吧

09:17.080 --> 09:18.080
没有问题吧

09:18.080 --> 09:19.080
如果没有找到

09:19.080 --> 09:20.080
如果这一块

09:20.080 --> 09:21.080
你有问题的话

09:21.080 --> 09:22.080
咱们视频教程的好处

09:22.080 --> 09:23.080
就是你可以回看一下

09:23.080 --> 09:25.080
回看一下之前的代码

09:25.080 --> 09:27.080
如果没有找到这个东西

09:27.080 --> 09:29.080
说明它只能被1和自身整出

09:29.080 --> 09:31.080
并且它又大于等于2

09:31.080 --> 09:33.080
因为这里还考虑一下

09:33.080 --> 09:35.080
进不了循环的情况

09:35.080 --> 09:36.080
因为它是1的话

09:36.080 --> 09:37.080
它可能进不了循环

09:38.080 --> 09:39.080
所以要考虑到

09:39.080 --> 09:40.080
它大于等于2

09:40.080 --> 09:41.080
如果这两个条件

09:41.080 --> 09:42.080
都满足

09:42.080 --> 09:43.080
是不是数数

09:43.080 --> 09:44.080
OK 你就把这个数字

09:44.080 --> 09:45.080
输出就完事了

09:45.080 --> 09:46.080
你把这个数字输出

09:46.080 --> 09:48.080
好 这就是

09:49.080 --> 09:51.080
输出这里边所有的数数

09:51.080 --> 09:53.080
保存看一下

09:54.080 --> 09:56.080
第四 我可以在这里干

09:56.080 --> 09:57.080
四

09:57.080 --> 09:59.080
你看 得到结果就是这个

09:59.080 --> 10:01.080
这是输出数数

10:01.080 --> 10:02.080
输出

10:02.080 --> 10:03.080
那输出也是这些

10:03.080 --> 10:04.080
对吧

10:04.080 --> 10:05.080
我们再起个二

10:05.080 --> 10:06.080
保存看一下

10:06.080 --> 10:08.080
二也是输出

10:08.080 --> 10:10.080
好了 这是

10:10.080 --> 10:12.080
第四题

10:12.080 --> 10:14.080
第五题

10:14.080 --> 10:15.080
飞波拉气数列

10:15.080 --> 10:16.080
你可能不知道

10:16.080 --> 10:17.080
飞波拉气数列是啥

10:17.080 --> 10:18.080
都没关系

10:18.080 --> 10:19.080
这里会给你解释

10:19.080 --> 10:20.080
很简单

10:20.080 --> 10:22.080
它是这样一种数列

10:23.080 --> 10:25.080
前两位固定为1

10:25.080 --> 10:27.080
前两位固定为1

10:27.080 --> 10:29.080
后边的位置

10:29.080 --> 10:30.080
第N位的值

10:30.080 --> 10:31.080
等于第N-1位

10:31.080 --> 10:33.080
加上第N-2位

10:33.080 --> 10:34.080
就这一位的值

10:34.080 --> 10:35.080
等于前面

10:35.080 --> 10:36.080
这一项加这一项

10:36.080 --> 10:37.080
这一项

10:37.080 --> 10:39.080
它等于这一项加这一项

10:39.080 --> 10:40.080
这一项等于

10:40.080 --> 10:41.080
这一项加这一项

10:41.080 --> 10:43.080
你看 这是飞波拉气数列

10:43.080 --> 10:45.080
然后让用户输入

10:45.080 --> 10:47.080
飞波拉气数列的长度

10:47.080 --> 10:49.080
然后在控制台中

10:49.080 --> 10:52.080
打印该长度的飞波拉气数列

10:52.080 --> 10:54.080
效果主项 下面没写效果

10:54.080 --> 10:57.080
没什么效果好写的

10:57.080 --> 10:59.080
就是让用户输入一个长度

10:59.080 --> 11:01.080
然后打印这个数列就完事了

11:01.080 --> 11:04.390
咱们来呗

11:04.390 --> 11:06.390
首先 请输入长度

11:06.390 --> 11:07.390
长度

11:09.390 --> 11:10.390
对了

11:10.390 --> 11:12.390
刚才挖的坑好像没填

11:12.390 --> 11:13.390
地道体

11:13.390 --> 11:14.390
地道体我说了

11:14.390 --> 11:16.390
这里可以写中扩号

11:16.390 --> 11:18.390
其实中扩号你直接写就完事了

11:18.390 --> 11:19.390
直接写中扩号就完事了

11:19.390 --> 11:21.390
这是一个长度为0的输组

11:21.390 --> 11:22.390
但是我们可以动态的

11:22.390 --> 11:24.390
再往里边加东西

11:24.390 --> 11:25.390
可以动态的加东西

11:25.390 --> 11:26.390
就在运行的过程中

11:26.390 --> 11:28.390
给它不断的加东西

11:28.390 --> 11:30.390
i等于0的时候

11:30.390 --> 11:31.390
给它加一个

11:31.390 --> 11:32.390
下标为0的位置

11:32.390 --> 11:33.390
给它加一个东西

11:33.390 --> 11:34.390
下标为1的位置

11:34.390 --> 11:35.390
给它加一个东西

11:35.390 --> 11:36.390
动态的给它加

11:36.390 --> 11:38.390
这样改成中扩号也没问题

11:39.390 --> 11:41.390
这里我们首先提示用户

11:41.390 --> 11:44.830
输入飞波拉气数列的长度

11:44.830 --> 11:49.830
请输入飞波拉气数列的长度

11:50.830 --> 11:51.830
得到用户的输入长度

11:51.830 --> 11:53.830
当然还是一样的

11:53.830 --> 11:55.830
可以判断一下

11:55.830 --> 11:57.830
把复制一下吧

11:58.830 --> 11:59.830
判断一下

11:59.830 --> 12:01.830
这个长度是不是输入正确的

12:01.830 --> 12:03.830
是不是输入正确的

12:03.830 --> 12:05.830
如果你输入正确的话

12:05.830 --> 12:07.830
如果你输入正确怎么样呢

12:08.830 --> 12:09.830
我就创建一个输组

12:09.830 --> 12:11.830
里边加东西

12:12.830 --> 12:13.830
来吧

12:14.830 --> 12:15.830
创建一个输组

12:17.830 --> 12:18.830
六一个耳锐

12:18.830 --> 12:19.830
六一个耳锐

12:19.830 --> 12:20.830
里边传一个内

12:21.830 --> 12:22.830
或者是我们直接写两个中文号

12:22.830 --> 12:23.830
也行

12:23.830 --> 12:24.830
因为可以动态的加

12:25.830 --> 12:26.830
创建一个输组

12:26.830 --> 12:27.830
然后循环

12:28.830 --> 12:29.830
循环 i等于0

12:29.830 --> 12:30.830
i小于内

12:30.830 --> 12:31.830
i加加

12:33.830 --> 12:35.830
循环这个输组的每一项

12:35.830 --> 12:36.830
一次给它加就行了

12:37.830 --> 12:39.830
飞波拉气数列它是这么一个规则

12:39.830 --> 12:40.830
如果是第一项

12:42.830 --> 12:44.830
第一项就下标为0吗

12:45.830 --> 12:48.830
或者是第二项下标为1

12:49.830 --> 12:50.830
如果是这两项的话

12:52.830 --> 12:53.830
结果是多少

12:53.830 --> 12:54.830
是不是两个1

12:54.830 --> 12:55.830
对吧

12:55.830 --> 12:56.830
就是两个1

12:56.830 --> 12:57.830
如果是第一项

12:57.830 --> 12:58.830
或者是第二项的话

12:58.830 --> 12:59.830
那么怎么样呢

12:59.830 --> 13:00.830
输组的这一项

13:00.830 --> 13:01.830
给它取之为1

13:02.830 --> 13:03.830
取之为1

13:03.830 --> 13:04.830
好

13:04.830 --> 13:05.830
咱们把这个输组输出看一下

13:06.830 --> 13:07.830
哎呀

13:07.830 --> 13:11.420
输出看一下

13:11.420 --> 13:12.420
打开

13:13.420 --> 13:14.420
好

13:14.420 --> 13:16.420
接下来让我们来输出长度为4

13:16.420 --> 13:17.420
长度为4

13:17.420 --> 13:18.420
你看一下

13:18.420 --> 13:19.420
输组目前

13:19.420 --> 13:20.420
对吧

13:20.420 --> 13:21.420
前面两项是遥遥

13:21.420 --> 13:22.420
没问题吧

13:22.420 --> 13:23.420
前面两项是遥遥

13:23.420 --> 13:24.420
好

13:24.420 --> 13:25.420
接下来 else

13:26.420 --> 13:27.420
如果不是第一项

13:27.420 --> 13:28.420
也不是第二项

13:28.420 --> 13:29.420
怎么样呢

13:30.420 --> 13:31.420
不是第一项

13:31.420 --> 13:32.420
也不是第二项

13:32.420 --> 13:33.420
那么不是第一项

13:33.420 --> 13:34.420
不是第二项

13:34.420 --> 13:35.420
这一项的值得用啥

13:36.420 --> 13:38.420
等于前边的这一项

13:39.420 --> 13:40.420
i-1

13:40.420 --> 13:41.420
加上

13:42.420 --> 13:43.420
前面的这一项

13:43.420 --> 13:44.420
i-2

13:44.420 --> 13:45.420
没问题吧

13:46.420 --> 13:47.420
好

13:47.420 --> 13:48.420
你看一下

13:49.420 --> 13:50.420
这一项

13:50.420 --> 13:51.420
它不是第一项

13:51.420 --> 13:52.420
也不是第二项

13:52.420 --> 13:53.420
它等于什么呢

13:53.420 --> 13:54.420
这个时候

13:54.420 --> 13:55.420
i等于2

13:55.420 --> 13:56.420
0

13:56.420 --> 13:57.420
1

13:57.420 --> 13:58.420
2

13:58.420 --> 13:59.420
i等于2

13:59.420 --> 14:00.420
等于

14:00.420 --> 14:01.420
它的值等于啥呢

14:01.420 --> 14:02.420
等于

14:02.420 --> 14:04.420
i等于0的这一项

14:05.420 --> 14:07.420
加上i等于1的这一项

14:08.420 --> 14:09.420
没问题吧

14:09.420 --> 14:10.420
好

14:10.420 --> 14:11.420
这一项

14:11.420 --> 14:12.420
i等于3

14:12.420 --> 14:13.420
i等于3

14:13.420 --> 14:14.420
等于

14:14.420 --> 14:16.420
i等于1的这一项

14:16.420 --> 14:18.420
和i等于2的这一项相加

14:18.420 --> 14:19.420
好

14:19.420 --> 14:20.420
这一项

14:20.420 --> 14:21.420
i等于4

14:21.420 --> 14:22.420
注意

14:22.420 --> 14:23.420
我说的是下标

14:23.420 --> 14:24.420
i是下标

14:24.420 --> 14:25.420
i等于4

14:25.420 --> 14:26.420
那么它等于什么呢

14:26.420 --> 14:27.420
i等于2的这一项

14:27.420 --> 14:29.420
加上i等于3的这一项

14:29.420 --> 14:30.420
对吧

14:30.420 --> 14:31.420
是的

14:31.420 --> 14:32.420
i-2加上i-1

14:32.420 --> 14:33.420
对不对

14:34.420 --> 14:35.420
把取出来

14:35.420 --> 14:36.420
把这一项取出来

14:36.420 --> 14:37.420
把这一项取出来

14:37.420 --> 14:38.420
加

14:38.420 --> 14:39.420
就是这一项的值

14:40.420 --> 14:41.420
保存看一下

14:42.420 --> 14:43.420
刷新

14:44.420 --> 14:45.420
比方说

14:45.420 --> 14:47.420
整理咱们写一个5项

14:48.420 --> 14:49.420
11235

14:51.420 --> 14:52.420
再来10项

14:53.420 --> 14:54.420
10项

14:54.420 --> 14:55.420
非布拉奇书的

14:56.420 --> 14:57.420
这就搞定了

14:59.420 --> 15:00.420
这是

15:00.420 --> 15:01.420
第5题

15:01.420 --> 15:02.420
第5题

15:02.420 --> 15:03.420
还是一样的

15:03.420 --> 15:04.420
这些东西我写得很快

15:04.420 --> 15:05.420
但是你们下去要消化

15:07.420 --> 15:08.420
定6题

15:08.420 --> 15:10.420
定6题它就在高速里

15:10.420 --> 15:11.420
书主里边

15:12.420 --> 15:14.420
它不是只能存数字

15:14.420 --> 15:16.420
它可以存任何东西

15:16.420 --> 15:18.420
可以存一个对象也可以

15:18.420 --> 15:20.420
我们以后会经常在书主里边存对象

15:20.420 --> 15:22.420
只是现阶段我们

15:22.420 --> 15:24.420
找不到一些合适的例子

15:24.420 --> 15:26.420
很难找到一些合适的例子

15:26.420 --> 15:27.420
我们以后会经常存对象

15:27.420 --> 15:28.420
到书主里边去

15:29.420 --> 15:30.420
咱们看第6题

15:35.060 --> 15:36.060
运行出来

15:36.060 --> 15:37.060
第6题运行出来

15:41.670 --> 15:42.670
好 定6题

15:42.670 --> 15:45.670
定6题是定义一个用户书主

15:45.670 --> 15:46.670
什么叫用户书主

15:47.670 --> 15:48.670
我们说什么书主

15:48.670 --> 15:49.670
指的是书主里面

15:49.670 --> 15:51.670
每一项是什么东西

15:51.670 --> 15:53.670
比方说我说一个字不错书主

15:53.670 --> 15:54.670
指的是什么意思呢

15:54.670 --> 15:55.670
指的是

15:55.670 --> 15:56.670
这个书主里面每一项

15:56.670 --> 15:57.670
是一个字不错

15:58.670 --> 16:00.670
我说的是一个书字书主

16:00.670 --> 16:01.670
指的是书主的每一项

16:01.670 --> 16:02.670
是一个书字

16:02.670 --> 16:03.670
我说用户书主

16:03.670 --> 16:05.670
指的是书主的每一项

16:05.670 --> 16:06.670
是一个用户

16:07.670 --> 16:08.670
用户是啥

16:08.670 --> 16:09.670
肯定是个对象

16:09.670 --> 16:10.670
书主的每一项

16:10.670 --> 16:11.670
我这里还在

16:11.670 --> 16:12.670
不断的提示里

16:12.670 --> 16:14.670
书主的每一项是一个用户对象

16:14.670 --> 16:17.670
用户对象里面包含帐号密码

16:17.670 --> 16:18.670
随意的初始化一些对象

16:18.670 --> 16:20.670
到这个书主里面

16:20.670 --> 16:21.670
就是让你练习一下

16:21.670 --> 16:23.670
不要认为书主里面

16:23.670 --> 16:25.670
老是只能出现书字

16:25.670 --> 16:26.670
他可以出现任何东西

16:26.670 --> 16:27.670
我们给他取个名字

16:27.670 --> 16:28.670
User

16:28.670 --> 16:30.670
表示的是用户

16:30.670 --> 16:31.670
用户的集合

16:31.670 --> 16:33.670
加上个s表示复书

16:33.670 --> 16:34.670
用户的书主

16:34.670 --> 16:35.670
好 这是个书主

16:36.670 --> 16:37.670
书主里面存啥呢

16:37.670 --> 16:38.670
它每一项存的

16:38.670 --> 16:39.670
是个对象

16:39.670 --> 16:40.670
我们这样展开写

16:40.670 --> 16:41.670
好看一点

16:41.670 --> 16:42.670
书主的第一项

16:42.670 --> 16:43.670
一个用户对象

16:43.670 --> 16:44.670
帐号

16:44.670 --> 16:45.670
帐号呢

16:45.670 --> 16:46.670
我们用login id

16:46.670 --> 16:47.670
login id

16:47.670 --> 16:48.670
表示登录的帐号

16:48.670 --> 16:49.670
帐号呢

16:49.670 --> 16:50.670
我们随便写吧

16:50.670 --> 16:51.670
然后密码

16:51.670 --> 16:52.670
login password

16:52.670 --> 16:53.670
password

16:53.670 --> 16:54.670
这些常见的单词要记住

16:54.670 --> 16:55.670
password是个缩写

16:55.670 --> 16:57.670
它的全称叫做password

16:58.670 --> 16:59.670
password

16:59.670 --> 17:01.670
我们平时写成pwd

17:02.670 --> 17:03.670
当然那也可以用什么

17:03.670 --> 17:05.670
也可以用妥封密码

17:06.670 --> 17:07.670
pwd

17:07.670 --> 17:08.670
密码呢

17:08.670 --> 17:09.670
就123

17:09.670 --> 17:10.670
123

17:10.670 --> 17:11.670
这是第一个用户

17:11.670 --> 17:12.670
第一个用户

17:12.670 --> 17:13.670
第一个用户

17:13.670 --> 17:14.670
它是书主的其中一项

17:14.670 --> 17:15.670
好 第二个用户

17:15.670 --> 17:16.670
我们一次来写

17:16.670 --> 17:17.670
第三个第四个

17:17.670 --> 17:18.670
一次写就行了

17:18.670 --> 17:19.670
一次写就行了

17:19.670 --> 17:20.670
你格式化一下

17:20.670 --> 17:21.670
还变成这个样子

17:21.670 --> 17:22.670
其实是一样的

17:22.670 --> 17:23.670
第一个用户

17:23.670 --> 17:24.670
第二个用户

17:24.670 --> 17:25.670
第三个用户

17:25.670 --> 17:26.670
是一样的

17:26.670 --> 17:28.670
就看你自己习惯了

17:28.670 --> 17:29.670
改一下吧

17:29.670 --> 17:30.670
一

17:30.670 --> 17:31.670
四

17:31.670 --> 17:32.670
二

17:32.670 --> 17:33.670
五

17:33.670 --> 17:34.670
三

17:34.670 --> 17:35.670
六

17:35.670 --> 17:36.670
随便写个

17:36.670 --> 17:37.670
就是有这么一些用户

17:37.670 --> 17:39.670
保存到的书主里边

17:39.670 --> 17:40.670
你不能做假设

17:40.670 --> 17:41.670
你不能去假设

17:41.670 --> 17:43.670
这个用户里面有几个用户

17:43.670 --> 17:44.670
不能假设这个书主里面

17:44.670 --> 17:45.670
有几个用户

17:45.670 --> 17:46.670
每个用户的账号密码是什么

17:46.670 --> 17:47.670
你不能去假设

17:47.670 --> 17:48.670
因为这个书主

17:48.670 --> 17:50.670
有可能来自于别的地方

17:50.670 --> 17:51.670
可能来自于用户输入

17:51.670 --> 17:53.670
比较用户注册的往里面加

17:53.670 --> 17:54.670
有可能来自于什么

17:54.670 --> 17:55.670
来自于以后我们要学的

17:55.670 --> 17:56.670
ax请求

17:56.670 --> 17:57.670
等等等等

17:57.670 --> 17:58.670
它可能来自于别的地方

17:58.670 --> 18:00.670
你不能做假设的

18:00.670 --> 18:01.670
好 这里呢

18:01.670 --> 18:03.670
让用户输入账号和密码

18:04.670 --> 18:05.670
罗点ID

18:05.670 --> 18:06.670
用户输入账号

18:07.670 --> 18:09.670
请输入账号

18:10.670 --> 18:11.670
我们就直接写了

18:11.670 --> 18:12.670
补习做什么

18:12.670 --> 18:13.670
输入验证了

18:14.670 --> 18:15.670
这些东西你要做的话也可以

18:15.670 --> 18:17.670
请输入密码

18:19.670 --> 18:21.670
让用户输入账号密码

18:21.670 --> 18:23.670
输入之后干嘛呢

18:23.670 --> 18:25.670
我要判断的是啥

18:25.670 --> 18:26.670
判断的是这个账号

18:26.670 --> 18:27.670
这个密码

18:27.670 --> 18:29.670
在书主里边能不能找到

18:30.670 --> 18:31.670
是吧 是这个意思吧

18:31.670 --> 18:32.670
对吧

18:32.670 --> 18:34.670
我要判断这个账号密码

18:34.670 --> 18:35.670
在这个书主里边

18:35.670 --> 18:36.670
能不能找到

18:36.670 --> 18:37.670
找到了

18:38.670 --> 18:39.670
登陆成功

18:39.670 --> 18:40.670
没有找到

18:40.670 --> 18:41.670
登陆失败

18:41.670 --> 18:42.670
登陆失败

18:42.670 --> 18:44.670
所以说这里是个查

18:44.670 --> 18:46.670
是个查造问题

18:46.670 --> 18:47.670
查造问题

18:47.670 --> 18:49.670
就是查找这个书主里边

18:49.670 --> 18:51.670
有没有账号等于这个密码

18:51.670 --> 18:52.670
等于这个东西

18:52.670 --> 18:54.670
好 那查到问题来找呗

18:54.670 --> 18:55.670
对吧 订了变量

18:55.670 --> 18:56.670
是否找到

18:56.670 --> 18:57.670
一开始都没找

18:57.670 --> 18:58.670
肯定没有找到

18:58.670 --> 18:59.670
没有找到

18:59.670 --> 19:01.670
一是去书主里边去找

19:01.670 --> 19:02.670
i等于0

19:02.670 --> 19:03.670
i小于

19:04.670 --> 19:05.670
i加加

19:06.670 --> 19:08.670
好 循环这个书主

19:08.670 --> 19:09.670
i来来找呗

19:09.670 --> 19:11.670
书主的每一项是啥

19:11.670 --> 19:12.670
是数字吗

19:13.670 --> 19:14.670
是字不错吗

19:14.670 --> 19:15.670
是啥

19:15.670 --> 19:16.670
书主的每一项

19:16.670 --> 19:17.670
是一个对象

19:17.670 --> 19:19.670
书主的每一项是个对象

19:19.670 --> 19:20.670
所以说呢

19:20.670 --> 19:22.670
你可以把这个对象拿出来

19:22.670 --> 19:23.670
拿出来

19:23.670 --> 19:25.670
把这个对象拿出来

19:25.670 --> 19:26.670
拿出来

19:26.670 --> 19:27.670
这是个对象

19:27.670 --> 19:28.670
一定要注意

19:28.670 --> 19:29.670
它不是什么字不错

19:29.670 --> 19:30.670
也不是数字

19:30.670 --> 19:31.670
它是一个对象

19:31.670 --> 19:32.670
现在书主的每一项

19:32.670 --> 19:34.670
拿出来过后

19:34.670 --> 19:36.670
来看一下这个对象的啥

19:36.670 --> 19:39.670
看一下这个对象的账号

19:39.670 --> 19:42.670
是不是等于用户输入的账号

19:42.670 --> 19:44.670
这个对象的密码

19:44.670 --> 19:47.670
是不是等于用户输入的密码

19:47.670 --> 19:49.670
这不就是查到问题吗

19:49.670 --> 19:51.670
如果两个都相等

19:51.670 --> 19:52.670
是不是找到了

19:52.670 --> 19:54.670
如果两个都相等

19:54.670 --> 19:55.670
是不是就找到了

19:55.670 --> 19:56.670
账号等于这个账号

19:56.670 --> 19:57.670
密码也等于这个密码

19:57.670 --> 19:58.670
是不是找到了

19:58.670 --> 19:59.670
找到怎么办

19:59.670 --> 20:00.670
isfand

20:01.670 --> 20:02.670
找到了

20:02.670 --> 20:03.670
然后结束

20:03.670 --> 20:04.670
不要再找了

20:04.670 --> 20:06.670
是不是格式还是一样的

20:06.670 --> 20:07.670
对吧

20:07.670 --> 20:08.670
它的协法格式还是一样的

20:08.670 --> 20:10.670
最后来我们判断一下

20:10.670 --> 20:11.670
如果找到了

20:11.670 --> 20:12.670
是不是登录成功

20:12.670 --> 20:13.670
对不对

20:13.670 --> 20:14.670
登录成功

20:14.670 --> 20:16.670
登录成功

20:16.670 --> 20:18.670
else呢

20:18.670 --> 20:19.670
就是登录失败

20:19.670 --> 20:20.670
登录失败

20:20.670 --> 20:25.900
好 写完了

20:25.900 --> 20:26.900
保存看一下

20:26.900 --> 20:27.900
看一下

20:27.900 --> 20:28.900
账号

20:28.900 --> 20:30.900
我们就abc

20:30.900 --> 20:32.900
密码123

20:32.900 --> 20:33.900
这里没打开

20:33.900 --> 20:34.900
登录成功

20:34.900 --> 20:36.900
好 再来发现一次

20:36.900 --> 20:37.900
账号

20:37.900 --> 20:38.900
随便写

20:38.900 --> 20:39.900
密码随便写

20:39.900 --> 20:40.900
登录失败

20:40.900 --> 20:41.900
没有这个用户

20:41.900 --> 20:43.900
这就是登录最基本的做法

20:43.900 --> 20:44.900
最基本的做法

20:44.900 --> 20:46.900
当然以后肯定会有些变化

20:46.900 --> 20:48.900
但是基本的实度是这样子

20:48.900 --> 20:50.900
就是在一个数组里边去找

20:50.900 --> 20:51.900
找一下

20:51.900 --> 20:53.900
它有没有满足条件的东西

20:53.900 --> 20:55.900
有没有满足条件的东西

20:55.900 --> 20:57.900
有些同学呢

20:57.900 --> 20:58.900
这里有个疑问

20:58.900 --> 21:00.900
我之前讲到这一块的时候

21:00.900 --> 21:01.900
有些同学在问

21:01.900 --> 21:02.900
他说

21:02.900 --> 21:04.900
不能这样子写吗

21:04.900 --> 21:05.900
我们数组里边

21:05.900 --> 21:06.900
不是有一个因

21:06.900 --> 21:07.900
这个是二无吗

21:07.900 --> 21:08.900
有这么一个函数

21:08.900 --> 21:09.900
对吧 有这么一个函数

21:09.900 --> 21:11.900
他就可以帮你来寻找

21:11.900 --> 21:12.900
对吧

21:12.900 --> 21:13.900
帮你来寻找

21:13.900 --> 21:14.900
寻找他的下标位置

21:14.900 --> 21:16.900
如果这个函数返回

21:16.900 --> 21:17.900
负一

21:17.900 --> 21:18.900
如果返回负一

21:18.900 --> 21:19.900
就表示没有找到

21:19.900 --> 21:21.900
否则的话就找到了

21:21.900 --> 21:22.900
对吧

21:22.900 --> 21:23.900
可以利用这么一个函数

21:23.900 --> 21:25.900
好 这个函数里边传啥呢

21:25.900 --> 21:28.900
这里面邪法就千奇百怪了

21:28.900 --> 21:30.900
给我传这个玩意儿的有

21:30.900 --> 21:31.900
然后密码传进去

21:31.900 --> 21:33.900
他以为

21:33.900 --> 21:35.900
这里面可以传两个

21:35.900 --> 21:36.900
这个因这个设备呢

21:36.900 --> 21:38.900
它确实

21:38.900 --> 21:40.900
它确实是可以传两个的

21:40.900 --> 21:42.900
确实是可以传两个的

21:42.900 --> 21:44.900
但是呢

21:44.900 --> 21:45.900
我这里要说一下

21:45.900 --> 21:47.900
它确实可以传两个

21:47.900 --> 21:49.900
但是它意识不是你这个意识

21:49.900 --> 21:50.900
如果你传两个的话

21:50.900 --> 21:51.900
第二个位置

21:51.900 --> 21:52.900
它传的是什么呢

21:52.900 --> 21:53.900
从什么位置

21:53.900 --> 21:55.900
从哪个下标开始查找

21:55.900 --> 21:56.900
它传的是

21:56.900 --> 21:57.900
它指的是这么一个意识

21:57.900 --> 21:59.900
这是查找的东西

21:59.900 --> 22:02.900
这是从哪个下标开始查找

22:02.900 --> 22:03.900
它可以传两个

22:03.900 --> 22:04.900
但是呢

22:04.900 --> 22:05.900
我们一般就传一个

22:05.900 --> 22:07.900
但是你把意识都搞错了

22:07.900 --> 22:08.900
对吧

22:08.900 --> 22:09.900
你把意识都搞错了

22:09.900 --> 22:10.900
它不是这个意识

22:10.900 --> 22:11.900
第二个位置的东西呢

22:11.900 --> 22:12.900
它表示

22:12.900 --> 22:14.900
从哪个下标开始查找

22:14.900 --> 22:15.900
好

22:15.900 --> 22:17.900
所以说我们这里只能传一个

22:17.900 --> 22:18.900
传一个呢

22:18.900 --> 22:19.900
有些很聪明的东西

22:19.900 --> 22:20.900
它这样子写

22:20.900 --> 22:21.900
你能这样子写出来

22:21.900 --> 22:22.900
就表示已经很聪明了

22:22.900 --> 22:24.900
属性的名字

22:24.900 --> 22:26.900
为LokinID

22:26.900 --> 22:28.900
属性的

22:28.900 --> 22:29.900
这个属性的值呢

22:29.900 --> 22:30.900
为LokinPassword

22:30.900 --> 22:32.900
什么意思

22:32.900 --> 22:33.900
什么意思

22:33.900 --> 22:34.900
表示的是

22:34.900 --> 22:35.900
我要找一下这个对象

22:35.900 --> 22:37.900
存不存在

22:37.900 --> 22:39.900
找这个对象存不存在

22:39.900 --> 22:41.900
这个对象的属性名呢

22:41.900 --> 22:42.900
是LokinID

22:42.900 --> 22:43.900
你看跟这边的属性名

22:43.900 --> 22:44.900
是不是一样的

22:44.900 --> 22:46.900
属性名是一样的

22:46.900 --> 22:47.900
LokinID

22:47.900 --> 22:48.900
属性的值呢

22:48.900 --> 22:49.900
来自于变量

22:49.900 --> 22:50.900
这个

22:50.900 --> 22:51.900
虽然是写的一样的

22:51.900 --> 22:52.900
但是意识不一样

22:52.900 --> 22:53.900
这是属性名

22:53.900 --> 22:54.900
这是属性的值

22:54.900 --> 22:55.900
属性的值呢

22:55.900 --> 22:56.900
来自于变量LokinID

22:56.900 --> 22:57.900
这里的属性名呢

22:57.900 --> 22:58.900
LokinPassword

22:58.900 --> 22:59.900
这里的属性值呢

22:59.900 --> 23:00.900
Lokin

23:00.900 --> 23:01.900
来自于变量LokinPassword

23:01.900 --> 23:02.900
这里顺便说一句

23:02.900 --> 23:04.900
顺便说一句

23:04.900 --> 23:05.900
就是说

23:05.900 --> 23:06.900
如果你的属性的名字

23:06.900 --> 23:09.900
和他的值写的是一样的

23:09.900 --> 23:10.900
如果你属性的名字

23:10.900 --> 23:12.900
和属性的值写的是一样的

23:12.900 --> 23:13.900
也就是说

23:13.900 --> 23:14.900
你有一个变量

23:14.900 --> 23:17.900
跟属性的名字是一样的

23:17.900 --> 23:19.900
那么你可以这样子简写

23:19.900 --> 23:20.900
可以这样简写

23:20.900 --> 23:21.900
直接这样子写

23:21.900 --> 23:22.900
可以的

23:22.900 --> 23:23.900
没问题

23:23.900 --> 23:25.900
那这种写法是个愚法堂

23:25.900 --> 23:27.900
它就相当于是这种写法

23:27.900 --> 23:28.900
是一样的

23:28.900 --> 23:29.900
好

23:29.900 --> 23:30.900
现在问题是

23:30.900 --> 23:32.900
就算你这样做了

23:32.900 --> 23:33.900
能找到用户吗

23:33.900 --> 23:35.900
能找到吗

23:35.900 --> 23:36.900
我们来看一下吧

23:36.900 --> 23:37.900
好

23:37.900 --> 23:38.900
来看一下

23:38.900 --> 23:39.900
你传了一个对象进去

23:39.900 --> 23:40.900
账号

23:40.900 --> 23:41.900
这个账号

23:41.900 --> 23:42.900
密码

23:42.900 --> 23:43.900
这个密码

23:43.900 --> 23:44.900
匹配一下什么呢

23:44.900 --> 23:45.900
在这个数组里面匹配一下

23:45.900 --> 23:47.900
看有没有个对象跟他相等

23:47.900 --> 23:50.900
能找到吗

23:50.900 --> 23:51.900
等于-1

23:51.900 --> 23:52.900
表示没有找到

23:52.900 --> 23:53.900
没有找到

23:53.900 --> 23:59.070
登录失败

23:59.070 --> 24:00.070
看一下吧

24:00.070 --> 24:01.070
我们都不用去

24:01.070 --> 24:03.070
我们都不用去写登录成功了

24:03.070 --> 24:04.070
因为它永远失败

24:04.070 --> 24:07.070
它永远都是失败的

24:07.070 --> 24:08.070
这里我们刷新设

24:08.070 --> 24:10.070
刷新设

24:10.070 --> 24:12.070
ABC

24:12.070 --> 24:13.070
123

24:13.070 --> 24:14.070
登录失败

24:14.070 --> 24:15.070
本来是有这样的用户的

24:15.070 --> 24:17.070
但是它永远登录失败

24:17.070 --> 24:18.070
随便这么写都登录失败

24:18.070 --> 24:19.070
不用写了

24:19.070 --> 24:20.070
不用看了

24:20.070 --> 24:21.070
为什么呢

24:21.070 --> 24:23.070
因为我们之前说过

24:23.070 --> 24:24.070
它查照的时候

24:24.070 --> 24:26.070
是用严格相等

24:26.070 --> 24:27.070
进行查照的

24:27.070 --> 24:29.070
你这里是新建了一个对象

24:29.070 --> 24:31.070
它不可能跟之前的对象相等的

24:31.070 --> 24:32.070
它不可能相等的

24:32.070 --> 24:34.070
所以说这种办法不行

24:34.070 --> 24:36.070
这种办法对于什么查数字

24:36.070 --> 24:37.070
查字不穿

24:37.070 --> 24:39.070
那些东西没问题

24:39.070 --> 24:41.070
但是对于查对象不行了

24:41.070 --> 24:42.070
因为对象

24:42.070 --> 24:43.070
它比较的是地址

24:43.070 --> 24:45.070
你这里新建那个用户

24:45.070 --> 24:46.070
新建那个对象

24:46.070 --> 24:48.070
它地址肯定是不一样的

24:48.070 --> 24:50.070
所以这种办法是不行的

24:50.070 --> 24:51.070
大家注意一下

24:51.070 --> 24:53.070
但是你能够想到这一块

24:53.070 --> 24:54.070
就很不错了

24:54.070 --> 24:55.070
就非常不错

24:55.070 --> 24:57.070
证明你对多知情的东西

24:57.070 --> 24:59.070
至少有印象

24:59.070 --> 25:02.070
这是第六题

25:02.070 --> 25:04.070
第七题

25:04.070 --> 25:08.070
初始化一个5×5的二维数组

25:08.070 --> 25:10.070
数组的每一项是个数字

25:10.070 --> 25:13.070
计算堆角线之合

25:13.070 --> 25:14.070
看一下

25:14.070 --> 25:20.140
第七题

25:20.140 --> 25:22.140
第七题咱们把其他关闭掉

25:22.140 --> 25:26.690
运行出来

25:26.690 --> 25:27.690
第七题

25:27.690 --> 25:30.690
首先建立一个二维数组

25:30.690 --> 25:31.690
二维数组

25:31.690 --> 25:32.690
我们说过的

25:32.690 --> 25:34.690
就是数组的每一项是一个数组

25:34.690 --> 25:36.690
数组的每一项是个数组

25:36.690 --> 25:37.690
5×5的二维数组

25:37.690 --> 25:38.690
就是有

25:38.690 --> 25:41.690
这个数组的有五项

25:43.690 --> 25:49.240
有五项

25:49.240 --> 25:51.240
我先打字怎么回事

25:52.240 --> 25:53.240
有五项

25:53.240 --> 25:55.240
每一项里面是啥

25:55.240 --> 25:57.240
每一项里面有一些数字

25:57.240 --> 25:58.240
有五个数字

25:58.240 --> 26:00.240
就这么个意思

26:01.240 --> 26:04.240
每一项里面有五个数字

26:04.240 --> 26:06.240
就这个意思

26:06.240 --> 26:08.240
我就写一位数

26:08.240 --> 26:10.240
方便验证一点

26:10.240 --> 26:12.240
写一位数

26:12.240 --> 26:13.240
方便验证一点

26:13.240 --> 26:15.240
我这里复制一下吧

26:15.240 --> 26:17.240
稍微随便改一下

26:17.240 --> 26:19.240
三

26:19.240 --> 26:21.240
二

26:21.240 --> 26:23.240
四

26:23.240 --> 26:26.260
五

26:26.260 --> 26:27.260
二

26:27.260 --> 26:28.260
瞎改

26:28.260 --> 26:30.260
当然可以写两位数

26:30.260 --> 26:31.260
当然可以

26:31.260 --> 26:32.260
我这里主要是

26:32.260 --> 26:33.260
为了大家看清楚

26:33.260 --> 26:34.260
把这个逻辑讲到

26:34.260 --> 26:36.260
这就是一个5×5的数组

26:36.260 --> 26:37.260
好

26:37.260 --> 26:39.260
那么我们现在要算的是

26:39.260 --> 26:41.260
算的是对角线之合

26:41.260 --> 26:42.260
就是它

26:42.260 --> 26:43.260
加它

26:43.260 --> 26:44.260
加它

26:44.260 --> 26:45.260
加它

26:45.260 --> 26:46.260
加它

26:46.260 --> 26:47.260
这是一个对角线

26:47.260 --> 26:48.260
然后是

26:48.260 --> 26:49.260
它

26:49.260 --> 26:50.260
加它

26:50.260 --> 26:51.260
加它

26:51.260 --> 26:52.260
加它

26:52.260 --> 26:53.260
加它

26:53.260 --> 26:55.260
这就是对角线之合

26:55.260 --> 26:57.260
5加0加6加8加9

26:57.260 --> 26:59.260
然后2加0加6加7加7

26:59.260 --> 27:01.260
这个6是不是加了两次

27:01.260 --> 27:02.260
对吧

27:02.260 --> 27:03.260
无所谓

27:03.260 --> 27:04.260
加两次加两次

27:04.260 --> 27:05.260
当然如果你可以

27:05.260 --> 27:06.260
如果你认为

27:06.260 --> 27:08.260
这个6只能加一次

27:08.260 --> 27:09.260
也可以

27:09.260 --> 27:10.260
就加一次吧

27:10.260 --> 27:11.260
这就加一次

27:11.260 --> 27:12.260
不能不加两次了

27:12.260 --> 27:13.260
加一次

27:13.260 --> 27:15.260
随便随便

27:15.260 --> 27:16.260
好

27:16.260 --> 27:19.820
那么现在我们求对角线之合

27:19.820 --> 27:21.820
线之合

27:21.820 --> 27:22.820
好

27:22.820 --> 27:23.820
我们来看一下对角线

27:23.820 --> 27:24.820
首先我们要知道

27:24.820 --> 27:25.820
我们

27:25.820 --> 27:26.820
要相加

27:26.820 --> 27:27.820
对吧

27:27.820 --> 27:28.820
要求合

27:28.820 --> 27:29.820
是不是肯定要用这个东西

27:29.820 --> 27:30.820
这个毫无疑问吧

27:30.820 --> 27:31.820
无论要怎么求合

27:31.820 --> 27:32.820
肯定要用这个东西

27:32.820 --> 27:33.820
然后既然要求合

27:33.820 --> 27:35.820
是不是把他的每一个数字

27:35.820 --> 27:36.820
要一个一个拿出来

27:36.820 --> 27:37.820
对吧

27:37.820 --> 27:38.820
要把他的每一个数字

27:38.820 --> 27:39.820
一个一个拿出来

27:39.820 --> 27:40.820
好循环

27:40.820 --> 27:43.820
小于AR.nance

27:43.820 --> 27:45.820
这是循环啥

27:45.820 --> 27:46.820
循环这个数组

27:46.820 --> 27:47.820
每一项

27:47.820 --> 27:48.820
第一项

27:48.820 --> 27:49.820
第二项

27:49.820 --> 27:50.820
第三项

27:50.820 --> 27:51.820
第四项

27:51.820 --> 27:52.820
第五项

27:52.820 --> 27:53.820
循环外面这个数组

27:53.820 --> 27:54.820
好

27:54.820 --> 27:55.820
循环到每一个数组

27:55.820 --> 27:57.820
这个ARI

27:57.820 --> 27:58.820
ARI

27:58.820 --> 27:59.820
它是不是也是个数组

27:59.820 --> 28:00.820
是一个数组

28:00.820 --> 28:01.820
它也是个数组

28:01.820 --> 28:02.820
还要循环它

28:02.820 --> 28:03.820
对吧

28:03.820 --> 28:04.820
循环这个数组

28:04.820 --> 28:05.820
4

28:05.820 --> 28:06.820
5

28:06.820 --> 28:07.820
2

28:07.820 --> 28:08.820
借0

28:08.820 --> 28:10.820
借小于ARI.nance

28:10.820 --> 28:14.650
借下来

28:14.650 --> 28:15.650
好

28:15.650 --> 28:16.650
你看

28:16.650 --> 28:17.650
我们就循环出了每个数组

28:17.650 --> 28:18.650
好

28:18.650 --> 28:20.650
现在我们就可以通过表达是

28:20.650 --> 28:21.650
ARI

28:21.650 --> 28:22.650
借

28:22.650 --> 28:24.650
通过这个表达是

28:24.650 --> 28:25.650
来取出啥呢

28:25.650 --> 28:27.650
取出数组这一项

28:27.650 --> 28:28.650
前面你看

28:28.650 --> 28:29.650
这个是个数组

28:29.650 --> 28:30.650
好

28:30.650 --> 28:31.650
这一刻呢

28:31.650 --> 28:32.650
它也是个数组

28:32.650 --> 28:33.650
它的数组里边

28:33.650 --> 28:34.650
其中一项

28:34.650 --> 28:35.650
这一项也是个数组

28:35.650 --> 28:36.650
好

28:36.650 --> 28:37.650
数组里边再取出这一项

28:37.650 --> 28:38.650
取出这个数组里边

28:38.650 --> 28:39.650
这一项

28:39.650 --> 28:40.650
好

28:40.650 --> 28:41.650
现在的问题是

28:41.650 --> 28:44.650
什么情况下

28:44.650 --> 28:45.650
什么情况下

28:45.650 --> 28:47.650
我要把它夹到这里边去

28:47.650 --> 28:48.650
你看

28:48.650 --> 28:50.650
是不是问题是转换了这个了

28:50.650 --> 28:54.980
问题就转换为这个了

28:54.980 --> 28:56.980
转换这个问题了

28:56.980 --> 28:57.980
什么情况下

28:57.980 --> 28:59.980
我要把它夹到这里边去

28:59.980 --> 29:00.980
只要把这个判断搞定

29:00.980 --> 29:01.980
是不是就搞定了

29:01.980 --> 29:02.980
好

29:02.980 --> 29:03.980
关键是这里

29:03.980 --> 29:05.980
怎么来知道它是不是对角线

29:05.980 --> 29:06.980
对角线

29:06.980 --> 29:08.980
这是一个5×5的数组

29:08.980 --> 29:09.980
好

29:09.980 --> 29:10.980
咱们来看一下

29:10.980 --> 29:13.980
对角线第1个位置

29:13.980 --> 29:15.980
我们看一下第1个位置

29:15.980 --> 29:17.980
对角线的第1个位置

29:17.980 --> 29:18.980
好

29:18.980 --> 29:21.980
就是I等于0

29:21.980 --> 29:22.980
对吧

29:22.980 --> 29:23.980
I等于0

29:23.980 --> 29:25.980
数组的第1项

29:25.980 --> 29:26.980
数组的第1项

29:26.980 --> 29:28.980
你可以认为I就是行号

29:28.980 --> 29:29.980
第几行

29:29.980 --> 29:30.980
好

29:30.980 --> 29:31.980
接等于几

29:31.980 --> 29:32.980
I等于0

29:32.980 --> 29:33.980
接等于几

29:33.980 --> 29:34.980
接等于几

29:34.980 --> 29:36.980
接也是不是也是0

29:36.980 --> 29:37.980
对吧

29:37.980 --> 29:38.980
也是0

29:38.980 --> 29:39.980
好

29:39.980 --> 29:40.980
再来

29:40.980 --> 29:41.980
这是对角线吧

29:41.980 --> 29:42.980
对角线

29:42.980 --> 29:43.980
好

29:43.980 --> 29:44.980
这个是啥呢

29:44.980 --> 29:45.980
I等于几

29:45.980 --> 29:46.980
I等于1

29:46.980 --> 29:48.980
接呢等于1

29:48.980 --> 29:49.980
没问题吧

29:49.980 --> 29:50.980
好

29:50.980 --> 29:51.980
这个是几

29:51.980 --> 29:52.980
I等于2

29:52.980 --> 29:53.980
接等于2

29:53.980 --> 29:55.980
然后一次是3

29:55.980 --> 29:56.980
3

29:56.980 --> 29:57.980
4

29:57.980 --> 29:58.980
4

29:58.980 --> 30:00.980
I和接是不是一样的

30:01.980 --> 30:03.980
I和接是不是一样的

30:03.980 --> 30:05.980
也就是说对角线一个特点是什么

30:05.980 --> 30:06.980
I和接

30:06.980 --> 30:08.980
它的值是一样的

30:08.980 --> 30:10.980
这是一种情况

30:10.980 --> 30:12.980
那么这种情况是不是把这些东西就搞定了

30:12.980 --> 30:13.980
就搞定了

30:13.980 --> 30:14.980
对吧

30:14.980 --> 30:15.980
好

30:15.980 --> 30:16.980
还有吗

30:16.980 --> 30:18.980
还有吗

30:18.980 --> 30:19.980
好

30:19.980 --> 30:20.980
咱们再看另一个规律

30:20.980 --> 30:21.980
另一个规律

30:21.980 --> 30:22.980
这个规律我就删掉了

30:22.980 --> 30:23.980
删掉了

30:23.980 --> 30:24.980
好

30:24.980 --> 30:25.980
这边也是对角线

30:25.980 --> 30:26.980
来吧

30:26.980 --> 30:27.980
这个是I等于几

30:27.980 --> 30:28.980
I等于4

30:29.980 --> 30:30.980
I等于4

30:30.980 --> 30:31.980
接等于几

30:32.980 --> 30:33.980
I等于0

30:33.980 --> 30:34.980
I等于0

30:34.980 --> 30:35.980
第一行吗

30:35.980 --> 30:36.980
接等于几

30:36.980 --> 30:37.980
接等于4

30:37.980 --> 30:39.980
然后第二个

30:39.980 --> 30:40.980
这个对角线

30:40.980 --> 30:41.980
这个位置

30:41.980 --> 30:42.980
I等于几

30:42.980 --> 30:44.980
I等于1

30:44.980 --> 30:46.980
接等于3

30:46.980 --> 30:47.980
然后呢

30:47.980 --> 30:48.980
I等于2

30:48.980 --> 30:49.980
接等于2

30:49.980 --> 30:50.980
I等于3

30:50.980 --> 30:51.980
接等于1

30:51.980 --> 30:52.980
I等于4

30:52.980 --> 30:53.980
接等于0

30:53.980 --> 30:54.980
啥特点

30:54.980 --> 30:56.980
I加接的值

30:56.980 --> 30:57.980
等于4

30:57.980 --> 30:58.980
对吧

30:58.980 --> 30:59.980
为什么等于4呢

30:59.980 --> 31:00.980
因为啥是5×5

31:00.980 --> 31:01.980
就是5-1

31:01.980 --> 31:02.980
长度-1

31:02.980 --> 31:03.980
就是长度-1

31:03.980 --> 31:04.980
好

31:04.980 --> 31:05.980
那么我们这里可以写

31:05.980 --> 31:07.980
或者

31:07.980 --> 31:09.980
I加接等于4

31:10.980 --> 31:11.980
你看这个东西是不是

31:11.980 --> 31:12.980
就对角线了

31:12.980 --> 31:13.980
对吧

31:13.980 --> 31:14.980
对角线了

31:14.980 --> 31:15.980
或者是我们把4换成什么

31:15.980 --> 31:16.980
长度-1

31:16.980 --> 31:17.980
长度-1都可以

31:17.980 --> 31:18.980
都行

31:18.980 --> 31:19.980
好

31:19.980 --> 31:20.980
这两个条件

31:20.980 --> 31:21.980
满足任何一个

31:21.980 --> 31:22.980
就是对角线

31:22.980 --> 31:23.980
好

31:23.980 --> 31:25.980
我们最后把个合输出

31:25.980 --> 31:26.980
对角线之合

31:26.980 --> 31:27.980
看一下

31:27.980 --> 31:28.980
44

31:28.980 --> 31:29.980
好

31:29.980 --> 31:30.980
来算一下

31:30.980 --> 31:31.980
咱们来算一下

31:31.980 --> 31:32.980
是不是44

31:32.980 --> 31:33.980
5加0

31:33.980 --> 31:34.980
5

31:34.980 --> 31:35.980
11

31:35.980 --> 31:37.980
11 19

31:37.980 --> 31:39.980
28

31:41.980 --> 31:42.980
35

31:44.980 --> 31:45.980
42

31:45.980 --> 31:46.980
这个加过了

31:46.980 --> 31:47.980
不加了

31:47.980 --> 31:48.980
42加2

31:48.980 --> 31:49.980
44

31:49.980 --> 31:50.980
看没

31:51.980 --> 31:52.980
这就是

31:53.980 --> 31:54.980
对角线之合

31:55.980 --> 31:56.980
这道题

31:57.980 --> 31:58.980
好了

31:58.980 --> 31:59.980
下面第八题

31:59.980 --> 32:01.980
第八题有难度了

32:01.980 --> 32:02.980
有难度

32:02.980 --> 32:03.980
排序

32:03.980 --> 32:05.980
排序这一块的话

32:05.980 --> 32:07.980
应该算是

32:07.980 --> 32:09.980
初学数组这一块的

32:09.980 --> 32:11.980
一个中级博士了

32:11.980 --> 32:12.980
他难度非常高

32:12.980 --> 32:14.980
因为大家的逻辑思维

32:14.980 --> 32:17.980
现在训练的时间还比较短

32:17.980 --> 32:18.980
因此这一块

32:18.980 --> 32:19.980
他不是什么数学问题

32:19.980 --> 32:21.980
是数学问题都是小事

32:21.980 --> 32:23.980
主要是逻辑思维

32:24.980 --> 32:25.980
所以说一开始

32:25.980 --> 32:26.980
学生选择逻辑思维

32:26.980 --> 32:27.980
他没经过

32:27.980 --> 32:29.980
没经过长时间的训练

32:29.980 --> 32:30.980
所以说这一块

32:30.980 --> 32:31.980
大家可能学习

32:31.980 --> 32:32.980
听起来的比较浪货

32:32.980 --> 32:33.980
自己做出来

32:33.980 --> 32:34.980
几乎是聊聊无忌

32:34.980 --> 32:35.980
能够自己做出来的

32:35.980 --> 32:36.980
聊聊无忌

32:36.980 --> 32:37.980
很少很少

32:37.980 --> 32:39.980
做不出来很正常

32:39.980 --> 32:41.980
听过后都会感觉有点晕

32:41.980 --> 32:42.980
没关系

32:42.980 --> 32:43.980
你听了之后

32:43.980 --> 32:45.980
你下来好好去想一想

32:45.980 --> 32:46.980
但是一定要把它写出来

32:46.980 --> 32:48.980
因为排序这一块

32:48.980 --> 32:49.980
面试很容易考

32:49.980 --> 32:50.980
很容易考

32:50.980 --> 32:52.980
尽管我们介石里边

32:52.980 --> 32:53.980
它有一个东西

32:53.980 --> 32:54.980
可以自动排序

32:54.980 --> 32:55.980
可以自动完成排序

32:55.980 --> 32:56.980
我们后面会讲

32:56.980 --> 32:59.980
但是排序这个算法

32:59.980 --> 33:00.980
这种计算方式

33:00.980 --> 33:02.980
它面试的是容易考

33:02.980 --> 33:03.980
所以说

33:03.980 --> 33:05.980
这一块大家一定要会

33:05.980 --> 33:06.980
不需要去背

33:06.980 --> 33:08.980
你只要你把它写出来一次

33:08.980 --> 33:10.980
你只要写出来一次就够了

33:10.980 --> 33:11.980
写出来一次过后

33:11.980 --> 33:13.980
以后哪怕你忘了

33:13.980 --> 33:14.980
你只要把诗路

33:14.980 --> 33:15.980
引去你一下

33:15.980 --> 33:16.980
你一下诗路

33:16.980 --> 33:17.980
OK

33:17.980 --> 33:18.980
你一下子又可以写出来了

33:18.980 --> 33:21.980
排序它有很多种计算方式

33:21.980 --> 33:23.980
我们说的算法

33:23.980 --> 33:24.980
算法是什么

33:24.980 --> 33:25.980
就是计算方式

33:25.980 --> 33:27.980
它有很多种计算方式

33:27.980 --> 33:28.980
我这里面介绍了

33:28.980 --> 33:29.980
其中一种计算方式

33:29.980 --> 33:31.980
是针对数字排序的

33:31.980 --> 33:33.980
哪种计算方式呢

33:33.980 --> 33:35.980
就是冒泡排序

33:35.980 --> 33:39.980
冒泡排序是怎么排的呢

33:39.980 --> 33:40.980
我给大家看一下

33:40.980 --> 33:41.980
看地址

33:41.980 --> 33:42.980
当然下面大家肯定是

33:42.980 --> 33:43.980
读过题的

33:43.980 --> 33:45.980
因为我之前说过

33:45.980 --> 33:46.980
你听我的课

33:46.980 --> 33:48.980
一定要先去把作业做一遍

33:48.980 --> 33:49.980
做一遍过后再来听

33:49.980 --> 33:50.980
一说都没做

33:50.980 --> 33:52.980
就不要来听了

33:52.980 --> 33:53.980
咱们来看一下

33:53.980 --> 33:55.980
我这里就直接说了

33:55.980 --> 33:56.980
举个例子

33:56.980 --> 33:59.980
它排序到底是怎么排的

33:59.980 --> 34:00.980
有这么一个数组

34:00.980 --> 34:11.220
我就直接冠开了写

34:11.220 --> 34:13.220
这是一个数组

34:13.220 --> 34:14.220
排序怎么排呢

34:14.220 --> 34:17.220
我们现在用冒泡排序

34:17.220 --> 34:19.220
冒泡排序它怎么排呢

34:19.220 --> 34:20.220
首先第一次

34:20.220 --> 34:21.220
看着

34:21.220 --> 34:22.220
第一次

34:22.220 --> 34:23.220
分几次来排

34:23.220 --> 34:24.220
第一次

34:24.220 --> 34:25.220
它要想办法

34:25.220 --> 34:27.220
把最大的数字

34:27.220 --> 34:28.220
把这个数组里边

34:28.220 --> 34:29.220
最大的数字

34:29.220 --> 34:31.220
放到这个位置

34:31.220 --> 34:32.220
它要想办法

34:32.220 --> 34:33.220
把数组里边

34:33.220 --> 34:34.220
最大的这个数字

34:34.220 --> 34:36.220
放到这个位置

34:36.220 --> 34:37.220
那它怎么来放呢

34:37.220 --> 34:39.220
它这样子来放

34:39.220 --> 34:42.220
首先比较第一位和第二位

34:42.220 --> 34:45.220
首先比较第一位和第二位

34:45.220 --> 34:47.220
如果第一位比第二位大

34:47.220 --> 34:49.220
就相邻这两位

34:49.220 --> 34:51.220
如果前面的比后边大

34:51.220 --> 34:53.220
交换

34:53.220 --> 34:55.220
第一次排序

34:55.220 --> 34:56.220
第一次排序

34:56.220 --> 34:57.220
它是这样排的

34:57.220 --> 35:00.220
先比较这两位

35:00.220 --> 35:02.220
前面的比后面大交换

35:02.220 --> 35:04.220
交换出来就是二

35:04.220 --> 35:06.220
这样子写吧

35:06.220 --> 35:07.220
我们写到这

35:07.220 --> 35:08.220
我们写到

35:08.220 --> 35:12.220
专门来建一个文件来冒泡排序

35:12.220 --> 35:14.220
冒泡排序

35:14.220 --> 35:25.020
看一下

35:25.020 --> 35:30.170
冒泡排序到底是怎么排的

35:30.170 --> 35:31.170
这是一个数组

35:31.170 --> 35:33.170
第一次

35:35.800 --> 35:36.800
冒泡排序

35:36.800 --> 35:37.800
它排很多次

35:37.800 --> 35:38.800
第一次

35:38.800 --> 35:42.880
怎么排呢

35:42.880 --> 35:43.880
一个个来

35:43.880 --> 35:45.880
首先比较前两位

35:45.880 --> 35:47.880
前面的比后面大交换

35:47.880 --> 35:49.880
交换过后是不是23

35:49.880 --> 35:50.880
44

35:50.880 --> 35:51.880
581

35:51.880 --> 35:52.880
对吧

35:52.880 --> 35:53.880
后面没动

35:53.880 --> 35:54.880
前面两位交换

35:54.880 --> 35:55.880
好

35:55.880 --> 35:56.880
接下来比较

35:56.880 --> 35:58.880
第二位和第三位

35:58.880 --> 35:59.880
再来比较

35:59.880 --> 36:01.880
如果前面的比后面大交换

36:01.880 --> 36:02.880
好

36:02.880 --> 36:03.880
现在是不是没动

36:03.880 --> 36:04.880
对吧

36:04.880 --> 36:05.880
没动

36:05.880 --> 36:06.880
第三次

36:06.880 --> 36:08.880
比较第三位和第四位

36:08.880 --> 36:09.880
如果大

36:09.880 --> 36:11.880
前面比后面大交换

36:11.880 --> 36:13.880
5

36:13.880 --> 36:15.880
相当于是大的数字

36:15.880 --> 36:16.880
就像一个泡泡一样

36:16.880 --> 36:17.880
不断的往上冒

36:17.880 --> 36:18.880
不断的往上冒

36:18.880 --> 36:20.880
就冒泡排序

36:20.880 --> 36:21.880
然后再来

36:21.880 --> 36:23.880
这一位和这一位比较

36:23.880 --> 36:24.880
这两位比较

36:24.880 --> 36:26.880
大的话交换

36:26.880 --> 36:27.880
比较出来

36:27.880 --> 36:28.880
应该是这样

36:28.880 --> 36:29.880
复制一下

36:29.880 --> 36:30.880
我想慢一点

36:30.880 --> 36:31.880
让大家理解

36:31.880 --> 36:33.880
844

36:34.880 --> 36:35.880
然后这一位和这一位

36:35.880 --> 36:37.880
进行比较交换

36:39.880 --> 36:40.880
1

36:40.880 --> 36:41.880
14

36:41.880 --> 36:42.880
你看

36:42.880 --> 36:44.880
第一次排序完成了之后

36:44.880 --> 36:45.880
最大的数字

36:45.880 --> 36:46.880
是不是一定在最后的

36:46.880 --> 36:47.880
一定在最后

36:47.880 --> 36:48.880
好

36:48.880 --> 36:49.880
这是第一次

36:49.880 --> 36:50.880
好

36:50.880 --> 36:51.880
第二次

36:51.880 --> 36:53.880
第二次了

36:53.880 --> 36:54.880
好

36:54.880 --> 36:55.880
第二次

36:55.880 --> 36:56.880
是不是把这个第一次的结果

36:56.880 --> 36:57.880
第一次已经排成这个样子了

36:57.880 --> 36:58.880
对吧

36:58.880 --> 36:59.880
又继续来排

36:59.880 --> 37:01.880
第一次排成这个样子了

37:01.880 --> 37:02.880
又重来一次

37:02.880 --> 37:03.880
那么第二次的时候

37:03.880 --> 37:05.880
最后一个数字不管了

37:05.880 --> 37:07.880
不管最后一个数字了

37:07.880 --> 37:08.880
它只看前面的

37:08.880 --> 37:10.880
把前面的排好就行了

37:10.880 --> 37:11.880
好 OK

37:11.880 --> 37:12.880
我们继续来

37:12.880 --> 37:13.880
第二次

37:13.880 --> 37:15.880
它比它大交换

37:15.880 --> 37:17.880
现在第一次不动

37:17.880 --> 37:20.190
不动

37:20.190 --> 37:22.190
然后看这一部分

37:22.190 --> 37:25.190
就是第二个和第三个比较

37:25.190 --> 37:27.190
那么大的话交换

37:27.190 --> 37:28.190
5

37:28.190 --> 37:29.190
23

37:29.190 --> 37:31.190
它比较这样排的

37:31.190 --> 37:33.190
然后继续

37:33.190 --> 37:36.190
然后8和23比较

37:36.190 --> 37:37.190
交换

37:37.190 --> 37:38.190
8

37:38.190 --> 37:39.190
23

37:39.190 --> 37:40.190
好 继续

37:40.190 --> 37:42.190
然后1和23比较

37:42.190 --> 37:43.190
交换

37:43.190 --> 37:44.190
1 23

37:44.190 --> 37:46.190
那你看这样子排完了过后

37:46.190 --> 37:48.190
第二大的数字

37:48.190 --> 37:50.190
是不是在这了

37:50.190 --> 37:51.190
在这了 对吧

37:51.190 --> 37:53.190
你看第一次循环

37:53.190 --> 37:54.190
第一次做了几次

37:54.190 --> 37:55.190
排了五次

37:55.190 --> 37:56.190
排了几次了

37:56.190 --> 37:58.190
排了五次

37:58.190 --> 38:00.190
第一次排了五次

38:00.190 --> 38:02.190
好 第二次排了多少次呢

38:02.190 --> 38:04.190
排了几次呢

38:04.190 --> 38:05.190
排了四次

38:05.190 --> 38:06.190
它只排四次

38:06.190 --> 38:08.190
因为最后数字不用管了

38:08.190 --> 38:10.190
好 咱们再看

38:10.190 --> 38:12.190
第三次

38:12.190 --> 38:13.190
第三次排去

38:13.190 --> 38:14.190
排几次呢

38:14.190 --> 38:15.190
想象到了

38:15.190 --> 38:16.190
排三次

38:16.190 --> 38:18.190
就只看这个了

38:18.190 --> 38:20.190
现在我们只看这几位了

38:20.190 --> 38:21.190
这几位了

38:21.190 --> 38:23.190
好 继续来看

38:23.190 --> 38:27.190
好 二和五比较不动

38:27.190 --> 38:28.190
不动

38:28.190 --> 38:30.190
好 接下来

38:30.190 --> 38:33.190
五和二十三比较不动

38:33.190 --> 38:35.190
二十三和一比较

38:35.190 --> 38:36.190
交换 对吧

38:36.190 --> 38:37.190
交换

38:37.190 --> 38:38.190
一

38:38.190 --> 38:39.190
二十三

38:39.190 --> 38:41.190
这第三次排去

38:41.190 --> 38:43.190
你看这个意思吧

38:43.190 --> 38:44.190
再来看

38:44.190 --> 38:46.190
第四次

38:46.190 --> 38:48.190
第四次只排两次

38:48.190 --> 38:49.190
只排两次

38:49.190 --> 38:50.190
好 又来

38:50.190 --> 38:51.190
按照这个基础上去

38:51.190 --> 38:52.190
继续排

38:52.190 --> 38:53.190
只看前面这三个了

38:53.190 --> 38:55.190
只看前面这三个

38:55.190 --> 38:56.190
好 第一个

38:56.190 --> 38:57.190
不动

38:57.190 --> 38:58.190
不动

38:58.190 --> 38:59.190
二和五不动

38:59.190 --> 39:02.190
好 五和一交换

39:02.190 --> 39:03.190
交换

39:03.190 --> 39:05.190
一和五

39:05.190 --> 39:07.190
好 这是第四次

39:07.190 --> 39:09.190
第五次

39:09.190 --> 39:10.190
第五次

39:10.190 --> 39:12.190
是不是只排一次了

39:12.190 --> 39:13.190
只排一次了

39:13.190 --> 39:15.190
好 只看前面这两位

39:15.190 --> 39:16.190
只看前面这两位

39:16.190 --> 39:17.190
是不是交换

39:17.190 --> 39:20.210
对吧 交换

39:20.210 --> 39:21.210
一

39:21.210 --> 39:22.210
二

39:22.210 --> 39:23.210
所以就排完了

39:23.210 --> 39:26.210
这就是冒泡排去的排去方式

39:26.210 --> 39:28.210
冒泡排去的排去方式

39:28.210 --> 39:30.210
总的来说排了五次

39:30.210 --> 39:32.210
有六个数字排了五次

39:32.210 --> 39:34.210
有六个数字排了五次

39:34.210 --> 39:38.210
然后每一次排序

39:38.210 --> 39:40.210
第一次排序排了五次

39:40.210 --> 39:41.210
第二次排序排了四次

39:41.210 --> 39:43.210
第三次排序排了三次

39:43.210 --> 39:44.210
第四次排序排了两次

39:44.210 --> 39:46.210
第五次排序排一次

39:46.210 --> 39:51.210
这就是冒泡排序的排序方式

39:51.210 --> 39:53.210
排序方式

39:53.210 --> 39:57.580
那么我们写成代码该怎么写呢

39:57.580 --> 39:58.580
首先我们来说

39:58.580 --> 40:00.580
总的来说

40:00.580 --> 40:02.580
排几次

40:02.580 --> 40:03.580
排了五次对吧

40:03.580 --> 40:04.580
排了五次

40:04.580 --> 40:06.580
是不是循环五次

40:06.580 --> 40:07.580
有问题吧

40:07.580 --> 40:08.580
循环五次嘛

40:08.580 --> 40:09.580
对不对

40:09.580 --> 40:10.580
循环五次

40:10.580 --> 40:11.580
好 为什么是五次呢

40:11.580 --> 40:13.580
因为这个数组是长度为六

40:13.580 --> 40:14.580
那你想这个道理

40:14.580 --> 40:15.580
你可以自己想象呗

40:15.580 --> 40:17.580
如果这个数组长度为七

40:17.580 --> 40:18.580
排六次

40:18.580 --> 40:20.580
整体的上排六次

40:20.580 --> 40:21.580
长度为八

40:21.580 --> 40:23.580
整体上排多少次

40:23.580 --> 40:25.580
排七次

40:25.580 --> 40:27.580
其实你可以想象到逻辑道理

40:27.580 --> 40:28.580
为什么是整体上

40:28.580 --> 40:30.580
什么是长度减移呢

40:30.580 --> 40:31.580
你想啊

40:31.580 --> 40:32.580
这个数组是六项

40:32.580 --> 40:33.580
对吧

40:33.580 --> 40:34.580
有六个东西

40:34.580 --> 40:36.580
它第一次把最大的放这

40:36.580 --> 40:38.580
第二次把最大的放这

40:38.580 --> 40:39.580
第二大的放这

40:39.580 --> 40:41.580
第三次把第三大的放这

40:41.580 --> 40:43.580
第四次把第四大的放这

40:43.580 --> 40:47.580
第五次把第五大的放这

40:47.580 --> 40:49.580
那前面这个是不是自然而然就出来了

40:49.580 --> 40:50.580
对吧

40:50.580 --> 40:51.580
你不用排了对吧

40:51.580 --> 40:52.580
就自然而然就出来了

40:52.580 --> 40:53.580
因为你把大的都放后边了

40:53.580 --> 40:54.580
前面的自然是最小的

40:54.580 --> 40:56.580
所以说我们这里呢

40:56.580 --> 40:58.580
循环

40:58.580 --> 41:00.580
假设有这么一个数组

41:00.580 --> 41:02.960
number吧

41:02.960 --> 41:03.960
number

41:03.960 --> 41:08.230
最好加上一个s

41:08.230 --> 41:10.230
就要加上一个s

41:10.230 --> 41:12.230
表示numbers

41:12.230 --> 41:14.230
有这么一个数组

41:14.230 --> 41:16.230
循环

41:16.230 --> 41:18.230
i

41:18.230 --> 41:20.230
等于0

41:20.230 --> 41:21.230
循环几次

41:21.230 --> 41:24.230
循环数组长度减1次

41:24.230 --> 41:25.230
对吧

41:25.230 --> 41:29.230
循环的数组长度减1次

41:29.230 --> 41:31.230
循环这么多次

41:31.230 --> 41:33.230
OK

41:33.230 --> 41:35.230
循环这个玩意

41:35.230 --> 41:37.230
就排多少次嘛

41:37.230 --> 41:38.230
就排这么多次

41:38.230 --> 41:39.230
排这么多次

41:39.230 --> 41:41.230
当然也可以从i从1开始

41:41.230 --> 41:43.230
小于那时也可以

41:43.230 --> 41:46.230
i的话就表示第几次

41:46.230 --> 41:48.230
i的话就表示的是第几次

41:48.230 --> 41:50.230
当然也是可以从1

41:50.230 --> 41:52.230
从1开始那里好理解一点

41:52.230 --> 41:53.230
这是第1次

41:53.230 --> 41:54.230
第2次

41:54.230 --> 41:55.230
第3次

41:55.230 --> 41:56.230
好

41:56.230 --> 41:57.230
然后每一次

41:57.230 --> 41:58.230
这是第几次

41:58.230 --> 42:00.230
第几次

42:00.230 --> 42:02.230
第1次排序

42:02.230 --> 42:04.230
那么就相当于是重复这个动作

42:04.230 --> 42:05.230
第1次

42:05.230 --> 42:06.230
第2次

42:06.230 --> 42:07.230
第3次

42:07.230 --> 42:09.230
你看i在变化

42:09.230 --> 42:10.230
一直变到5

42:10.230 --> 42:11.230
一直变到5

42:11.230 --> 42:12.230
没问题吧

42:12.230 --> 42:14.230
没问题

42:14.230 --> 42:15.230
好

42:15.230 --> 42:16.230
看着

42:16.230 --> 42:18.230
第1次排序

42:18.230 --> 42:19.230
第1次排序

42:19.230 --> 42:21.230
第1次排序做啥呢

42:21.230 --> 42:23.230
做啥呢

42:23.230 --> 42:24.230
想一想

42:24.230 --> 42:26.230
第1次排序要做啥

42:26.230 --> 42:29.230
是不是又从这个数组

42:29.230 --> 42:31.230
第0位开始的吧

42:31.230 --> 42:33.230
第0位和第1位比较

42:33.230 --> 42:36.230
然后第1位和第2位比较

42:36.230 --> 42:38.230
然后第2位和第3位比较

42:38.230 --> 42:40.230
然后第3位和第4位比较

42:40.230 --> 42:43.230
然后第4位和第5位比较

42:43.230 --> 42:44.230
你看这意思吧

42:44.230 --> 42:45.230
那么也就是说

42:45.230 --> 42:46.230
我们这里要不断的进行

42:46.230 --> 42:48.230
两位两位的比较

42:48.230 --> 42:50.230
那么我们这里要写个循环

42:50.230 --> 42:52.230
循环

42:52.230 --> 42:55.230
这个接从0开始

42:55.230 --> 42:57.230
比较0到

42:57.230 --> 42:59.230
我们这样说吧

42:59.230 --> 43:00.230
这样子的写

43:00.230 --> 43:02.230
排了5次

43:02.230 --> 43:04.230
比较的位置是

43:04.230 --> 43:06.230
比较的位置

43:06.230 --> 43:07.230
位置

43:07.230 --> 43:08.230
从多少到到多少呢

43:08.230 --> 43:11.230
从0到多少

43:11.230 --> 43:12.230
第1次排序

43:12.230 --> 43:13.230
比较的位置从0开始

43:13.230 --> 43:15.230
比较0到0和1

43:15.230 --> 43:16.230
1和2

43:16.230 --> 43:17.230
2和3

43:17.230 --> 43:18.230
3和4

43:18.230 --> 43:19.230
4和5

43:19.230 --> 43:20.230
比较到这一位

43:20.230 --> 43:21.230
这一位就行了

43:21.230 --> 43:22.230
0到4

43:22.230 --> 43:23.230
没问题吧

43:23.230 --> 43:26.230
比较的位置是从0到4

43:26.230 --> 43:27.230
拿到0

43:27.230 --> 43:28.230
0就和1比较

43:28.230 --> 43:29.230
拿到1

43:29.230 --> 43:30.230
1和2比较

43:30.230 --> 43:31.230
拿到2

43:31.230 --> 43:32.230
2和3比较

43:32.230 --> 43:33.230
3和4比较

43:33.230 --> 43:34.230
拿到4

43:34.230 --> 43:35.230
4和5比较

43:35.230 --> 43:36.230
比较的位置是从0到4

43:36.230 --> 43:37.230
你看0到4

43:37.230 --> 43:38.230
是不是刚好5次

43:38.230 --> 43:39.230
从0到4

43:39.230 --> 43:41.230
0到4之间循环

43:41.230 --> 43:42.230
是不是刚好5次

43:42.230 --> 43:43.230
好

43:43.230 --> 43:44.230
那么下面这个

43:44.230 --> 43:45.230
排了4次

43:45.230 --> 43:46.230
为什么排4次呢

43:46.230 --> 43:48.230
比较的位置是从0到3

43:48.230 --> 43:50.230
是不是从0到3

43:50.230 --> 43:51.230
对吧

43:51.230 --> 43:52.230
0到3吧

43:52.230 --> 43:53.230
因为最后位置不用比较了

43:53.230 --> 43:55.230
比较0到1

43:55.230 --> 43:56.230
1到2

43:56.230 --> 43:57.230
2到3

43:57.230 --> 43:58.230
3到4

43:58.230 --> 43:59.230
够了

43:59.230 --> 44:00.230
后面的不用比较了

44:00.230 --> 44:02.230
比较的位置是从0到3

44:02.230 --> 44:03.230
这里

44:03.230 --> 44:04.230
所以排了3次

44:04.230 --> 44:05.230
0到2

44:05.230 --> 44:06.230
这里排了2次

44:06.230 --> 44:07.230
0到1

44:07.230 --> 44:08.230
排了1次

44:08.230 --> 44:09.230
0到0

44:09.230 --> 44:10.230
0到0

44:10.230 --> 44:11.230
排1次

44:11.230 --> 44:13.230
那么都是从0开始

44:13.230 --> 44:14.230
所以说界等于0

44:14.230 --> 44:15.230
这个没问题

44:15.230 --> 44:18.230
关键是这个数字哪来的

44:18.230 --> 44:20.230
5-1

44:20.230 --> 44:22.230
4-2

44:22.230 --> 44:24.230
3-

44:24.230 --> 44:26.230
第3次排序

44:26.230 --> 44:28.230
我看看

44:28.230 --> 44:29.230
等一下

44:29.230 --> 44:30.230
等一下

44:30.230 --> 44:31.230
不是

44:31.230 --> 44:33.230
不是5-1

44:33.230 --> 44:34.230
数组的长度

44:34.230 --> 44:36.230
减去1

44:36.230 --> 44:38.230
数组的长度减去1

44:38.230 --> 44:39.230
是不是5次

44:39.230 --> 44:41.230
数组的长度减去2

44:41.230 --> 44:42.230
是不是4次

44:42.230 --> 44:43.230
数组的长度减3

44:43.230 --> 44:44.230
是不是3次

44:44.230 --> 44:45.230
数组的长度减4

44:45.230 --> 44:46.230
是不是4次

44:46.230 --> 44:47.230
2次

44:47.230 --> 44:48.230
4次

44:48.230 --> 44:49.230
4次

44:49.230 --> 44:50.230
4次

44:50.230 --> 44:51.230
4次

44:51.230 --> 44:52.230
4次

44:52.230 --> 44:53.230
4次

44:53.230 --> 44:54.230
4次

44:54.230 --> 44:55.230
4次

44:55.230 --> 44:56.230
4次

44:56.230 --> 44:57.230
4次

44:57.230 --> 44:58.230
4次

44:58.230 --> 44:59.230
4次

44:59.230 --> 45:00.230
4次

45:00.230 --> 45:01.230
4次

45:01.230 --> 45:02.230
4次

45:02.230 --> 45:03.230
4次

45:03.230 --> 45:04.230
4次

45:04.230 --> 45:05.230
4次

45:05.230 --> 45:06.230
4次

45:06.230 --> 45:07.230
4次

45:07.230 --> 45:08.230
4次

45:08.230 --> 45:09.230
4次

45:09.230 --> 45:10.230
4次

45:10.230 --> 45:11.230
4次

45:11.230 --> 45:12.230
4次

45:12.230 --> 45:13.230
4次

45:13.230 --> 45:14.230
4次

45:14.230 --> 45:15.230
4次

45:15.230 --> 45:16.230
4次

45:16.230 --> 45:17.230
4次

45:17.230 --> 45:18.230
4次

45:18.230 --> 45:19.230
4次

45:19.230 --> 45:20.230
4次

45:20.230 --> 45:21.230
4次

45:21.230 --> 45:22.230
4次

45:22.230 --> 45:23.230
4次

45:23.230 --> 45:24.230
4次

45:24.230 --> 45:25.230
4次

45:25.230 --> 45:26.230
4次

45:26.230 --> 45:27.230
4次

45:27.230 --> 45:28.230
4次

45:28.230 --> 45:29.230
4次

45:29.230 --> 45:30.230
4次

45:30.230 --> 45:31.230
4次

45:31.230 --> 45:32.230
4次

45:32.230 --> 45:33.230
4次

45:33.230 --> 45:34.230
4次

45:34.230 --> 45:35.230
4次

45:35.230 --> 45:36.230
4次

45:36.230 --> 45:37.230
4次

45:37.230 --> 45:38.230
4次

45:38.230 --> 45:39.230
4次

45:39.230 --> 45:40.230
4次

45:40.230 --> 45:41.230
4次

45:41.230 --> 45:42.230
4次

45:42.230 --> 45:43.230
4次

45:43.230 --> 45:44.230
4次

45:44.230 --> 45:45.230
4次

45:45.230 --> 45:49.230
如果前邊的比後邊的大交換

45:49.230 --> 45:50.230
如果

45:50.230 --> 45:51.230
那麼

45:51.230 --> 45:52.230
借

45:52.230 --> 45:53.230
大於了

45:53.230 --> 45:54.230
那麼是

45:54.230 --> 45:55.230
借

45:55.230 --> 45:56.230
加1

45:56.230 --> 45:58.230
如果前邊的比後邊的大

45:58.230 --> 45:59.230
是不是要交換

45:59.230 --> 46:00.230
好交換

46:00.230 --> 46:02.230
之前我們學過變量交換

46:02.230 --> 46:04.230
那交換數組裡面兩個東西

46:04.230 --> 46:06.230
是不是一樣的交換

46:06.230 --> 46:08.230
好先把這個保存一下

46:08.230 --> 46:09.230
保存

46:09.230 --> 46:10.230
借

46:10.230 --> 46:11.230
保存一下

46:11.230 --> 46:12.230
然後呢

46:12.230 --> 46:13.230
然後呢

46:13.230 --> 46:15.230
把這一項重新複製

46:15.230 --> 46:16.230
複製為什麼呢

46:16.230 --> 46:17.230
複製為

46:17.230 --> 46:19.230
它後邊一項的值

46:19.230 --> 46:20.230
然後呢

46:20.230 --> 46:21.230
再把後邊一項的值呢

46:21.230 --> 46:22.230
複製為

46:22.230 --> 46:24.230
之前占存的值

46:24.230 --> 46:25.230
就交換了

46:26.230 --> 46:27.230
對排序

46:27.230 --> 46:28.230
寫完了

46:29.230 --> 46:30.230
代碼沒有多少

46:30.230 --> 46:31.230
但是呢

46:31.230 --> 46:32.230
邏輯

46:32.230 --> 46:33.230
它還是比較複雜的

46:33.230 --> 46:34.230
特別是對於初學者

46:34.230 --> 46:35.230
它是比較複雜的

46:35.230 --> 46:36.230
你需要

46:36.230 --> 46:38.230
需要花費

46:38.230 --> 46:40.230
好幾個小時的時間估計

46:40.230 --> 46:41.230
你才能把它理解透

46:42.230 --> 46:43.230
就這麼點代碼

46:43.230 --> 46:44.230
你不要去背啊

46:44.230 --> 46:45.230
背沒有任何意義

46:45.230 --> 46:46.230
你稍微一點點寫錯了

46:46.230 --> 46:47.230
一個符號

46:47.230 --> 46:48.230
一個I乘寫

46:48.230 --> 46:49.230
借寫什麼

46:49.230 --> 46:50.230
I寫什麼借

46:50.230 --> 46:51.230
都要出問題

46:51.230 --> 46:52.230
所以不用去背

46:52.230 --> 46:53.230
好看一下

46:56.890 --> 46:57.890
刷新

46:57.890 --> 46:58.890
你看是不是排完了

46:59.890 --> 47:01.890
這樣的代碼是通用的

47:01.890 --> 47:02.890
無論你這個數組裡邊

47:02.890 --> 47:04.890
寫了多少個出東西

47:04.890 --> 47:05.890
隨便你寫

47:05.890 --> 47:06.890
隨便你寫

47:06.890 --> 47:07.890
寫了多少個東西

47:07.890 --> 47:08.890
它都能給你排好

47:09.890 --> 47:10.890
保存

47:10.890 --> 47:11.890
看一下

47:13.890 --> 47:14.890
好吧

47:15.890 --> 47:16.890
OK啊

47:16.890 --> 47:17.890
這是關於排序這一塊

47:17.890 --> 47:18.890
這需要你消化

47:19.890 --> 47:20.890
好你把前面的我建議你

47:20.890 --> 47:21.890
先消化

47:21.890 --> 47:22.890
一道題一道題消化完了

47:22.890 --> 47:24.890
過後再來聽最後一道題

47:25.890 --> 47:26.890
最後一道題難度

47:26.890 --> 47:28.890
可能還要搞寫

47:28.890 --> 47:29.890
可能還要搞寫

47:30.890 --> 47:31.890
好這道題

47:32.890 --> 47:33.890
再說一次

47:33.890 --> 47:34.890
我反復地強調

47:34.890 --> 47:35.890
你就知道這個東西

47:35.890 --> 47:36.890
有多重要了

47:36.890 --> 47:37.890
就是說

47:37.890 --> 47:38.890
咱們聽課

47:38.890 --> 47:40.890
一定特別是作業講解

47:40.890 --> 47:42.890
一定要先去做一次作業

47:42.890 --> 47:44.890
哪怕你做不出來都沒關係

47:44.890 --> 47:45.890
只要你花了心思

47:45.890 --> 47:46.890
比方說第九題

47:46.890 --> 47:48.890
你花了兩個小時

47:48.890 --> 47:50.890
然後再來聽

47:50.890 --> 47:52.890
和你花了一個小時再來聽

47:52.890 --> 47:54.890
它肯定是不一樣的

47:54.890 --> 47:56.890
哪怕你都沒有做出來

47:56.890 --> 47:58.890
哪怕你都沒有做出來

47:58.890 --> 47:59.890
哪怕你手都沒動

47:59.890 --> 48:01.890
最後代碼都寫不出來

48:01.890 --> 48:02.890
都沒關係

48:02.890 --> 48:03.890
但是你花費的時間和精力

48:03.890 --> 48:04.890
你只要花費了

48:04.890 --> 48:05.890
一定會有效果的

48:05.890 --> 48:07.890
你的理解就會越深刻

48:07.890 --> 48:09.890
花費的精力和時間越多

48:09.890 --> 48:10.890
你思考的越多

48:10.890 --> 48:12.890
你對它的理解就會越深刻

48:12.890 --> 48:14.890
有些同學每次聽作業講解

48:14.890 --> 48:15.890
就用打磕碎

48:15.890 --> 48:16.890
為什麼打磕碎

48:16.890 --> 48:17.890
因為他從來沒做過

48:17.890 --> 48:18.890
他做都沒去做

48:18.890 --> 48:20.890
他也沒有任何疑問腦袋裡面

48:20.890 --> 48:21.890
也沒去想過

48:21.890 --> 48:23.890
所以他一定會打磕碎的

48:23.890 --> 48:25.890
因為他沒有這種感覺

48:25.890 --> 48:27.890
當你心中有一些疑惑的時候

48:27.890 --> 48:28.890
你希望從我的課程裏面

48:28.890 --> 48:30.890
去解決你的疑惑的時候

48:30.890 --> 48:31.890
你怎麼可能打磕碎

48:31.890 --> 48:33.890
絕對不可能打磕碎的

48:33.890 --> 48:34.890
好

48:34.890 --> 48:35.890
說一下第九題

48:36.890 --> 48:37.890
有一個素

48:37.890 --> 48:39.890
存放了一些數字

48:39.890 --> 48:42.890
要找出出現頻率最高的數字

48:43.890 --> 48:44.890
好

48:44.890 --> 48:45.890
比方說

48:45.890 --> 48:46.890
我們這裡

48:46.890 --> 48:48.890
這是一個統計問題

48:48.890 --> 48:49.890
而且這道題

48:49.890 --> 48:51.890
面試題已經出現過無數次了

48:51.890 --> 48:52.890
出現過無數次了

48:52.890 --> 48:53.890
千萬不要背

48:53.890 --> 48:54.890
千萬不要背

48:54.890 --> 48:55.890
背不住的

48:55.890 --> 48:56.890
你絕對背不住的

48:56.890 --> 48:57.890
好

48:57.890 --> 48:58.890
這裡比方說

48:58.890 --> 49:00.890
有這麼一個數字

49:00.890 --> 49:02.890
Numbers

49:02.890 --> 49:04.890
裏面存到一些數字

49:04.890 --> 49:05.890
隨便寫

49:05.890 --> 49:07.890
2 3 4 5

49:07.890 --> 49:09.890
2 3 4 5

49:09.890 --> 49:10.890
5

49:10.890 --> 49:12.890
2 2 2 3

49:12.890 --> 49:14.890
3 3 3 5

49:15.890 --> 49:17.890
比方說存到這麼一些數字

49:17.890 --> 49:19.890
我要找出這個數組裏面

49:19.890 --> 49:21.890
哪個數字出現的頻率最多

49:21.890 --> 49:22.890
最終我要輸出

49:22.890 --> 49:24.890
比方說我最終要輸出啥

49:24.890 --> 49:26.890
哪個數字出現最多

49:26.890 --> 49:27.890
2

49:27.890 --> 49:28.890
好像是2

49:28.890 --> 49:29.890
好像是2

49:29.890 --> 49:30.890
輸出

49:30.890 --> 49:31.890
2

49:31.890 --> 49:33.890
出現

49:33.890 --> 49:35.890
頻率最高

49:35.890 --> 49:37.890
出現了多少次呢

49:37.890 --> 49:38.890
出現了

49:38.890 --> 49:40.890
1 2 3 4 5

49:40.890 --> 49:42.890
5次

49:42.890 --> 49:44.890
要解決這個問題

49:44.890 --> 49:46.890
其實

49:46.890 --> 49:47.890
你很多時候

49:47.890 --> 49:49.890
你解決這些問題的時候

49:49.890 --> 49:51.890
你不用想那麼複雜

49:51.890 --> 49:53.890
你就先想你怎麼做

49:53.890 --> 49:55.890
你要解決這個問題怎麼做

49:55.890 --> 49:56.890
不要用程序

49:56.890 --> 49:57.890
就你忍耐做

49:57.890 --> 49:58.890
交給你

49:58.890 --> 50:00.890
我告訴你一些數字

50:00.890 --> 50:01.890
你把出現頻率最高的數字

50:01.890 --> 50:02.890
和它出現的次數

50:02.890 --> 50:03.890
給我找到

50:03.890 --> 50:04.890
你會怎麼做

50:04.890 --> 50:05.890
有些同學說

50:05.890 --> 50:06.890
我就看

50:06.890 --> 50:07.890
這個數

50:07.890 --> 50:08.890
這個數我現在告訴你

50:08.890 --> 50:09.890
有一千萬項

50:09.890 --> 50:11.890
有一千萬項

50:11.890 --> 50:12.890
來你給我看

50:12.890 --> 50:13.890
你怎麼給我看

50:13.890 --> 50:14.890
那你怎麼做呢

50:14.890 --> 50:16.890
你必須要找方法

50:16.890 --> 50:18.890
你要找到一個流程

50:18.890 --> 50:19.890
找到一個流程

50:19.890 --> 50:20.890
就可以解決這個問題

50:20.890 --> 50:22.890
你要找到這個流程和方法

50:22.890 --> 50:24.890
而不是直接告訴我結果

50:24.890 --> 50:27.890
而你只要找到了這個流程和方法

50:27.890 --> 50:29.890
你就會發現程序就寫出來了

50:29.890 --> 50:31.890
這就是程序的思路

50:32.890 --> 50:34.890
包括我們之前說什麼

50:34.890 --> 50:35.890
找沒找到

50:35.890 --> 50:36.890
對吧

50:36.890 --> 50:37.890
查找問題

50:37.890 --> 50:38.890
包括什麼求和問題

50:38.890 --> 50:39.890
你可能會覺得

50:39.890 --> 50:41.890
一下子就算出來了

50:41.890 --> 50:42.890
兄弟

50:42.890 --> 50:43.890
因為數字很小

50:43.890 --> 50:44.890
那如果我告訴你

50:44.890 --> 50:45.890
這個一千萬項的數字

50:45.890 --> 50:46.890
你怎麼算

50:46.890 --> 50:47.890
你是不是要找方法

50:47.890 --> 50:48.890
找思路

50:48.890 --> 50:49.890
思路就是方法

50:49.890 --> 50:51.890
你只要把方法找到了

50:51.890 --> 50:52.890
思路自然就出來了

50:52.890 --> 50:53.890
那假設這個數字

50:53.890 --> 50:54.890
有一千萬項

50:54.890 --> 50:56.890
那你怎麼做呢

50:56.890 --> 50:57.890
怎麼做

50:57.890 --> 50:58.890
我可以用這種方式

50:58.890 --> 51:00.890
我記錄

51:01.890 --> 51:03.890
比方說我第一個數字

51:03.890 --> 51:04.890
看到是2

51:04.890 --> 51:05.890
我就記錄

51:05.890 --> 51:07.890
2出現了幾次

51:07.890 --> 51:09.890
出現了一次

51:09.890 --> 51:11.890
我就記錄

51:11.890 --> 51:13.890
又找到一個3

51:13.890 --> 51:14.890
3出現一次

51:15.890 --> 51:16.890
又找到一個4

51:16.890 --> 51:18.890
4出現幾次

51:18.890 --> 51:19.890
4出現一次

51:19.890 --> 51:20.890
又找到一個5

51:20.890 --> 51:21.890
5出現一次

51:21.890 --> 51:23.890
又找到一個234出現一次

51:24.890 --> 51:25.890
又找到一個5

51:25.890 --> 51:27.890
這個5是不是已經存在了

51:27.890 --> 51:29.890
是不是已經存在了

51:29.890 --> 51:30.890
沒問題吧

51:30.890 --> 51:31.890
這個5已經存在了

51:31.890 --> 51:32.890
對吧

51:32.890 --> 51:33.890
5已經存在了

51:33.890 --> 51:34.890
是不是我帶

51:34.890 --> 51:35.890
我就不去加這個東西了

51:35.890 --> 51:37.890
我就把它加1

51:37.890 --> 51:38.890
2次

51:38.890 --> 51:39.890
又找到一個5

51:39.890 --> 51:40.890
3次

51:40.890 --> 51:41.890
找到一個2

51:41.890 --> 51:42.890
2次

51:42.890 --> 51:43.890
2次

51:43.890 --> 51:44.890
3次

51:44.890 --> 51:45.890
2次

51:45.890 --> 51:46.890
4次

51:46.890 --> 51:47.890
5次

51:47.890 --> 51:48.890
333

51:48.890 --> 51:49.890
3的話

51:49.890 --> 51:50.890
4次

51:50.890 --> 51:52.890
最後又出現一個5

51:52.890 --> 51:53.890
4次

51:53.890 --> 51:54.890
找出來了

51:54.890 --> 51:55.890
好

51:55.890 --> 51:56.890
我把這個東西找出來

51:56.890 --> 51:58.890
做記錄

51:58.890 --> 52:00.890
這個東西找出來過後

52:00.890 --> 52:01.890
看著

52:01.890 --> 52:03.890
這個東西找出來過後

52:03.890 --> 52:04.890
怎麼辦呢

52:04.890 --> 52:07.890
然後按照從高到低

52:07.890 --> 52:09.890
按照這個東西的從高到低排序

52:09.890 --> 52:10.890
是不是完了

52:10.890 --> 52:12.890
按照這個東西的從高到低

52:12.890 --> 52:13.890
進行排序

52:13.890 --> 52:15.890
然後取出它的第一個

52:15.890 --> 52:17.890
是不是就完事了

52:17.890 --> 52:18.890
就完事了

52:18.890 --> 52:20.890
還要看忙了

52:20.890 --> 52:21.890
是吧

52:21.890 --> 52:22.890
就這樣就完事了

52:22.890 --> 52:23.890
這樣就完事了

52:24.890 --> 52:25.890
沒問題吧

52:25.890 --> 52:27.890
沒問題吧

52:27.890 --> 52:29.890
應該沒問題

52:29.890 --> 52:30.890
好

52:30.890 --> 52:32.890
那麼具體怎麼做呢

52:32.890 --> 52:33.890
具體怎麼做呢

52:33.890 --> 52:35.890
首先我要記錄

52:35.890 --> 52:37.890
把它記錄成這個樣子

52:37.890 --> 52:38.890
好

52:38.890 --> 52:40.890
怎麼把它記錄成這個樣子呢

52:40.890 --> 52:42.890
你是不是可以把它當成一個對象

52:42.890 --> 52:45.890
是不是可以把它當成一個對象

52:45.890 --> 52:47.890
沒問題吧

52:47.890 --> 52:49.890
把這個玩意兒當成一個對象

52:49.890 --> 52:50.890
是不是完了

52:50.890 --> 52:51.890
對不對

52:51.890 --> 52:52.890
好

52:52.890 --> 52:54.890
這個東西是不是對象的屬性

52:54.890 --> 52:56.890
這個東西是不是對象的屬性值

52:56.890 --> 52:57.890
屬性名

52:57.890 --> 52:58.890
屬性值

52:58.890 --> 52:59.890
屬性名

52:59.890 --> 53:00.890
屬性值

53:00.890 --> 53:01.890
沒問題吧

53:01.890 --> 53:02.890
屬性名

53:02.890 --> 53:04.890
屬性值

53:04.890 --> 53:05.890
也就是說

53:05.890 --> 53:07.890
我們首先要得到這麼一個東西

53:07.890 --> 53:09.890
再說後面的事情

53:09.890 --> 53:11.890
首先要得到這麼一個東西

53:13.890 --> 53:14.890
得到

53:15.890 --> 53:17.890
記錄對象

53:17.890 --> 53:19.890
得到一個記錄對象

53:20.890 --> 53:21.890
好

53:21.890 --> 53:22.890
那個對象

53:22.890 --> 53:23.890
我們先建一個對象

53:23.890 --> 53:24.890
一個OBG

53:24.890 --> 53:26.890
或者叫Record記錄

53:26.890 --> 53:27.890
好

53:27.890 --> 53:28.890
這是一個空對象

53:28.890 --> 53:29.890
沒有東西

53:29.890 --> 53:30.890
沒有屬性

53:30.890 --> 53:31.890
記錄對象

53:32.890 --> 53:33.890
好

53:33.890 --> 53:34.890
接下來幹嘛呢

53:34.890 --> 53:35.890
是不是循環宿主

53:35.890 --> 53:37.890
往這個對象裡邊加屬性

53:37.890 --> 53:39.890
往這個對象裡邊加屬性

53:39.890 --> 53:41.890
宿主裡邊一個一個拿出來看

53:41.890 --> 53:42.890
循環宿主

53:43.890 --> 53:44.890
I等於0

53:44.890 --> 53:45.890
I小於

53:46.890 --> 53:47.890
Num

53:48.890 --> 53:49.890
Ns

53:49.890 --> 53:50.890
I++

53:55.380 --> 53:56.380
循環這個宿主

53:56.380 --> 53:57.380
好

53:57.380 --> 53:59.380
宿主裡邊的每一項拿出來

53:59.380 --> 54:00.380
拿出這一項N

54:00.380 --> 54:01.380
假設拿出這一項N

54:01.380 --> 54:03.380
把這一項拿出來

54:03.380 --> 54:04.380
好

54:04.380 --> 54:06.380
拿出N過後我要幹嘛呢

54:06.380 --> 54:08.380
比方說

54:08.380 --> 54:09.380
從頭開始

54:09.380 --> 54:10.380
從頭開始

54:10.380 --> 54:11.380
一個對象

54:11.380 --> 54:13.380
把宿主的第一項拿出來了

54:13.380 --> 54:14.380
第一項是

54:14.380 --> 54:15.380
第一項是2

54:15.380 --> 54:16.380
第一項是2

54:16.380 --> 54:17.380
我要幹嘛

54:17.380 --> 54:18.380
是不是把這個2

54:18.380 --> 54:19.380
作為它的屬性名

54:19.380 --> 54:20.380
對吧

54:20.380 --> 54:21.380
作為它的屬性名

54:21.380 --> 54:23.380
然後給它寫個E

54:23.380 --> 54:24.380
對不對

54:24.380 --> 54:25.380
寫個E

54:26.380 --> 54:28.380
把這個2作為屬性名

54:28.380 --> 54:30.380
然後給它寫的就是E

54:30.380 --> 54:32.380
當然前提條件是什麼

54:32.380 --> 54:35.380
前提條件是個對象裡邊的屬性不存在

54:35.380 --> 54:37.380
如果這個屬性已經存在了

54:37.380 --> 54:38.380
比方說比要到後邊

54:38.380 --> 54:40.380
這也是個2

54:40.380 --> 54:41.380
也是個2

54:41.380 --> 54:42.380
那麼這個屬性已經存在了

54:42.380 --> 54:43.380
是不是加E

54:43.380 --> 54:44.380
加E

54:44.380 --> 54:46.380
屬性存在就加E

54:46.380 --> 54:47.380
就不斷的加E

54:47.380 --> 54:48.380
你看這個意思

54:49.380 --> 54:50.380
好

54:50.380 --> 54:51.380
那麼這裡呢

54:51.380 --> 54:52.380
我們這裡可以判斷一下

54:52.380 --> 54:53.380
判斷啥

54:53.380 --> 54:54.380
你把施度分析出來過後

54:54.380 --> 54:55.380
就要轉換成代碼

54:56.380 --> 54:57.380
一開始學習程序

54:57.380 --> 54:58.380
施度分析不出來

54:58.380 --> 54:59.380
很正常

54:59.380 --> 55:00.380
非常亮正常

55:01.380 --> 55:02.380
但是你以前

55:02.380 --> 55:03.380
現在要訓練的是什麼

55:03.380 --> 55:04.380
施度已經出來了

55:04.380 --> 55:06.380
你怎麼把它寫成代碼

55:06.380 --> 55:07.380
很多同學下不了手

55:07.380 --> 55:09.380
是有兩個原因

55:09.380 --> 55:11.380
一個原因是施度出不來

55:11.380 --> 55:12.380
沒有施度

55:12.380 --> 55:13.380
這個很解

55:13.380 --> 55:14.380
我能理解

55:14.380 --> 55:16.380
但是如果施度已經出來了

55:16.380 --> 55:17.380
你寫不出來代碼

55:17.380 --> 55:19.380
那麼你就要反覆練習了

55:19.380 --> 55:20.380
好

55:20.380 --> 55:21.380
現在判斷一下

55:21.380 --> 55:22.380
判斷啥

55:22.380 --> 55:24.380
判斷這個對象的屬性

55:24.380 --> 55:26.380
以這個東西作為屬性名

55:27.380 --> 55:28.380
它的屬性是不是存在

55:28.380 --> 55:29.380
那怎麼寫代碼

55:30.380 --> 55:32.690
這是個對象

55:33.690 --> 55:34.690
是不是這樣的寫

55:35.690 --> 55:37.690
把N的值拿出來作為屬性名

55:37.690 --> 55:39.690
你能不能這樣子寫

55:39.690 --> 55:40.690
能不能這樣子寫

55:40.690 --> 55:41.690
不能這樣子寫

55:41.690 --> 55:42.690
這樣的寫法

55:42.690 --> 55:43.690
相當於是

55:43.690 --> 55:45.690
屬性名字為N

55:45.690 --> 55:46.690
屬性名字為N

55:46.690 --> 55:49.690
而不是把N的值作為屬性名

55:49.690 --> 55:50.690
所以說你得這樣寫

55:51.690 --> 55:52.690
看一下這個屬性是不是存在

55:54.690 --> 55:56.690
如果這個屬性存在

55:56.690 --> 55:57.690
存在的話

55:57.690 --> 55:58.690
它一定不能不為N

55:58.690 --> 55:59.690
它一定不可能是N

55:59.690 --> 56:00.690
它至少都是E

56:00.690 --> 56:01.690
至少都是E

56:01.690 --> 56:02.690
所以說

56:02.690 --> 56:03.690
如果這個為Q

56:03.690 --> 56:04.690
如果這個為Q的話

56:04.690 --> 56:05.690
屬性一定存在

56:05.690 --> 56:07.690
因為如果屬性不存在的話

56:07.690 --> 56:08.690
它是Undefined

56:08.690 --> 56:09.690
Undefined的話

56:09.690 --> 56:11.690
它是判定為Force

56:12.690 --> 56:13.690
所以說

56:13.690 --> 56:14.690
如果這個判斷為真

56:14.690 --> 56:16.690
說明屬性一定存在

56:16.690 --> 56:18.690
存在怎麼辦

56:19.690 --> 56:21.690
存在是不是屬性的值

56:21.690 --> 56:22.690
加1

56:22.690 --> 56:23.690
對吧

56:23.690 --> 56:24.690
加加

56:25.690 --> 56:26.690
沒問題吧

56:26.690 --> 56:28.690
這個屬性的值取出來

56:28.690 --> 56:30.690
把這個屬性的值取出來

56:30.690 --> 56:32.690
這個屬性的值取出來

56:32.690 --> 56:33.690
加1

56:33.690 --> 56:34.690
好

56:34.690 --> 56:36.690
L就是屬性不存在

56:36.690 --> 56:38.690
屬性不存在怎麼辦呢

56:38.690 --> 56:40.690
給這個屬性負值為1

56:40.690 --> 56:42.690
它第一次出現

56:42.690 --> 56:44.690
你看這個循環運行完了過後

56:44.690 --> 56:46.690
這裡面是不是存放了記錄了

56:46.690 --> 56:47.690
看一下

56:47.690 --> 56:48.690
打印出來這個Record

56:48.690 --> 56:49.690
看一下

56:49.690 --> 56:51.690
先把這個記錄找到

56:52.690 --> 56:57.370
看一下

56:57.370 --> 56:58.370
刷新

56:59.370 --> 57:00.370
好你看

57:00.370 --> 57:01.370
是吧記錄找到了

57:01.370 --> 57:02.370
2出現了5次

57:02.370 --> 57:03.370
3出現了4次

57:03.370 --> 57:04.370
4出現了1次

57:04.370 --> 57:05.370
5出現了4次

57:05.370 --> 57:06.370
2、3、4出現1次

57:06.370 --> 57:07.370
找到了

57:08.370 --> 57:09.370
有些同學說

57:09.370 --> 57:10.370
那就完了

57:10.370 --> 57:11.370
直接取第一項就完了

57:11.370 --> 57:12.370
那是因為你假設

57:12.370 --> 57:14.370
第一項就是出現的最高的

57:14.370 --> 57:15.370
憑什麼呢

57:15.370 --> 57:16.370
比如說

57:16.370 --> 57:18.370
我剛才多出現幾次

57:19.370 --> 57:20.370
看一下

57:21.370 --> 57:23.370
那現在第一項還出現的次數是最高嗎

57:23.370 --> 57:24.370
不一定

57:26.370 --> 57:28.370
那麼現在又怎麼辦呢

57:29.370 --> 57:30.370
那麼現在

57:30.370 --> 57:32.370
又遇到一個問題了

57:32.370 --> 57:33.370
就是我拿到這個記錄對象過後

57:33.370 --> 57:35.370
我怎麼來取出

57:35.370 --> 57:37.370
值最大的對象

57:37.370 --> 57:40.370
怎麼來取出這個值最大的

57:40.370 --> 57:41.370
這個東西

57:41.370 --> 57:42.370
怎麼來取

57:44.370 --> 57:45.370
怎麼取呢

57:45.370 --> 57:47.370
這裡可以排序

57:47.370 --> 57:48.370
可以排序

57:48.370 --> 57:49.370
但是這裡的排序比較複雜

57:49.370 --> 57:50.370
因為

57:50.370 --> 57:51.370
如果你把它當成一個樹主的話

57:51.370 --> 57:52.370
它是一個吸沖樹主

57:52.370 --> 57:54.370
是一個吸沖樹主

57:54.370 --> 57:55.370
你還沒有這個認識

57:55.370 --> 57:56.370
認識還不存在

57:56.370 --> 57:57.370
你要排序的話

57:57.370 --> 57:58.370
不是人要排

57:58.370 --> 58:00.370
那麼這裡怎麼辦呢

58:00.370 --> 58:04.370
我們要找到值最大的那個東西

58:04.370 --> 58:06.370
找到值最大的那個東西

58:06.370 --> 58:07.370
那怎麼找呢

58:07.370 --> 58:08.370
好看著

58:08.370 --> 58:10.370
這裡有一個解

58:10.370 --> 58:11.370
有一個非常

58:12.370 --> 58:13.370
非常牛的辦法

58:14.370 --> 58:15.370
怎麼找呢

58:15.370 --> 58:17.370
我記錄一個東西

58:17.370 --> 58:19.370
一個是屬性名

58:19.370 --> 58:20.370
屬性名

58:20.370 --> 58:21.370
屬性名

58:21.370 --> 58:23.370
一個是屬性值

58:23.370 --> 58:24.370
屬性值

58:26.370 --> 58:27.370
屬性名

58:27.370 --> 58:29.370
我給它設為安迪範的

58:30.370 --> 58:31.370
屬性值

58:31.370 --> 58:32.370
也給它設為安迪範的

58:32.370 --> 58:33.370
好

58:33.370 --> 58:34.370
接下來開始找

58:34.370 --> 58:35.370
看著

58:35.370 --> 58:36.370
開始找

58:37.370 --> 58:38.370
第一個

58:38.370 --> 58:39.370
把屬性全部拿出來

58:39.370 --> 58:41.370
把它的屬性名和屬性值

58:41.370 --> 58:42.370
一個個拿出來

58:42.370 --> 58:44.370
先拿出二和五

58:44.370 --> 58:46.370
先拿出二和五

58:46.370 --> 58:47.370
如果

58:47.370 --> 58:49.370
如果這裡是安迪範的

58:49.370 --> 58:50.370
那直接把它記錄為五

58:50.370 --> 58:52.370
屬性值記錄為二

58:53.370 --> 58:55.370
先把這樣的記錄

58:55.370 --> 58:56.370
或者說

58:56.370 --> 58:57.370
我們循環

58:57.370 --> 59:00.370
我們一開始就把第一個屬性名和屬性值記錄下來

59:00.370 --> 59:01.370
或者一開始就是安迪範的

59:01.370 --> 59:02.370
無所謂

59:03.370 --> 59:05.370
把屬性值記錄為五

59:05.370 --> 59:07.370
屬性名記錄為二

59:07.370 --> 59:09.370
然後再看第二個屬性

59:09.370 --> 59:10.370
三和四

59:10.370 --> 59:11.370
四

59:11.370 --> 59:13.370
如果比五大重新記錄

59:13.370 --> 59:15.370
如果比五小就不記錄

59:15.370 --> 59:17.370
第三個屬性

59:17.370 --> 59:18.370
四和一

59:18.370 --> 59:19.370
一比五小

59:19.370 --> 59:21.370
就看屬性值

59:21.370 --> 59:23.370
因為我們要拿到的是

59:23.370 --> 59:25.370
拿到的是最大的屬性

59:25.370 --> 59:27.370
其實我們以後取最大值最小值

59:27.370 --> 59:29.370
也可以用類似的方式

59:29.370 --> 59:31.370
拿到第三個屬性

59:31.370 --> 59:32.370
四和一

59:32.370 --> 59:33.370
看屬性值

59:33.370 --> 59:35.370
如果屬性值比它大

59:35.370 --> 59:36.370
覆蓋掉

59:36.370 --> 59:37.370
如果屬性值比它小

59:37.370 --> 59:38.370
不動

59:38.370 --> 59:40.370
然後第四個屬性是不是比它大

59:40.370 --> 59:41.370
屬性值比它大

59:41.370 --> 59:42.370
OK

59:42.370 --> 59:43.370
把它變成十

59:43.370 --> 59:45.370
把屬性名變成五

59:45.370 --> 59:47.370
沒問題吧

59:47.370 --> 59:48.370
沒問題

59:48.370 --> 59:49.370
是吧

59:49.370 --> 59:51.370
然後第五個

59:51.370 --> 59:52.370
值比它小不動

59:52.370 --> 59:53.370
好

59:53.370 --> 59:54.370
最後循環完了之後

59:54.370 --> 59:55.370
你看一下這裡記錄的

59:55.370 --> 59:57.370
是不是最大的那個

59:57.370 --> 59:58.370
頻率出現的數字

59:58.370 --> 59:59.370
最高的就是五

59:59.370 --> 01:00:02.370
出現的十次就出來了

01:00:02.370 --> 01:00:03.370
當然這裡要兩個變量

01:00:03.370 --> 01:00:04.370
對吧

01:00:04.370 --> 01:00:05.370
這裡要寫兩個變量

01:00:05.370 --> 01:00:06.370
也可以用一個對象

01:00:06.370 --> 01:00:07.370
對吧

01:00:07.370 --> 01:00:10.450
也可以用一個對象

01:00:10.450 --> 01:00:12.450
這裡是個對象

01:00:12.450 --> 01:00:14.450
這個對象的第一個屬性

01:00:14.450 --> 01:00:16.450
表示的是藍本

01:00:16.450 --> 01:00:17.450
藍本

01:00:17.450 --> 01:00:18.450
數字是什麼

01:00:18.450 --> 01:00:19.450
數字是五

01:00:19.450 --> 01:00:20.450
頻率

01:00:20.450 --> 01:00:21.450
頻率怎麼說的

01:00:21.450 --> 01:00:23.450
頻率單詞是什麼

01:00:23.450 --> 01:00:25.450
frequency

01:00:25.450 --> 01:00:26.450
是不是

01:00:26.450 --> 01:00:29.530
頻率

01:00:29.530 --> 01:00:30.530
頻率

01:00:30.530 --> 01:00:31.530
好像叫frequency

01:00:31.530 --> 01:00:35.250
好看一下

01:00:35.250 --> 01:00:37.250
frequency

01:00:37.250 --> 01:00:39.250
用這個吧

01:00:39.250 --> 01:00:41.250
用屬性

01:00:41.250 --> 01:00:42.250
用一個對象也行

01:00:42.250 --> 01:00:44.250
先讓那個對象為undefine

01:00:44.250 --> 01:00:45.250
對吧

01:00:45.250 --> 01:00:46.250
先讓那個對象為undefine

01:00:46.250 --> 01:00:47.250
然後呢

01:00:47.250 --> 01:00:48.250
第一個像

01:00:48.250 --> 01:00:49.250
它如果為undefine

01:00:49.250 --> 01:00:50.250
它直接覆蓋

01:00:50.250 --> 01:00:51.250
直接覆蓋

01:00:51.250 --> 01:00:52.250
好我們找到這個

01:00:52.250 --> 01:00:53.250
十字過後

01:00:53.250 --> 01:00:54.250
我們就可以寫代碼了

01:00:54.250 --> 01:00:55.250
result

01:00:55.250 --> 01:00:56.250
結果

01:00:56.250 --> 01:00:57.250
結果

01:00:57.250 --> 01:00:58.250
它一開始為undefine

01:00:58.250 --> 01:01:00.250
也就是一開始不複製

01:01:00.250 --> 01:01:01.250
一開始不複製

01:01:01.250 --> 01:01:03.250
結果對象

01:01:03.250 --> 01:01:04.250
然後循環什麼呢

01:01:04.250 --> 01:01:06.250
循環這個數組

01:01:06.250 --> 01:01:07.250
循環這個數組

01:01:07.250 --> 01:01:08.250
而不是數組

01:01:08.250 --> 01:01:09.250
循環這個對象

01:01:09.250 --> 01:01:10.250
循環這個對象

01:01:10.250 --> 01:01:11.250
關於如何循環對象

01:01:11.250 --> 01:01:12.250
是不是講過的

01:01:12.250 --> 01:01:13.250
for in循環

01:01:13.250 --> 01:01:16.750
循環這個對象

01:01:18.750 --> 01:01:19.750
好對象的

01:01:19.750 --> 01:01:20.750
就把一個一個的屬性名

01:01:20.750 --> 01:01:21.750
和屬性值拿出來看

01:01:21.750 --> 01:01:22.750
對吧

01:01:22.750 --> 01:01:24.750
好如果判斷

01:01:24.750 --> 01:01:26.750
如果result

01:01:26.750 --> 01:01:27.750
為空

01:01:27.750 --> 01:01:28.750
就是為undefine

01:01:28.750 --> 01:01:29.750
就是相當於是什麼

01:01:29.750 --> 01:01:31.750
相當於是result沒有值

01:01:31.750 --> 01:01:32.750
這個對象沒有值

01:01:32.750 --> 01:01:33.750
這個東西沒有值

01:01:33.750 --> 01:01:35.750
沒有值是不是一定是覆蓋過去

01:01:35.750 --> 01:01:36.750
對吧

01:01:36.750 --> 01:01:37.750
一開始這個對象

01:01:37.750 --> 01:01:38.750
result這個對象

01:01:38.750 --> 01:01:39.750
一開始呢

01:01:39.750 --> 01:01:41.750
是undefine的

01:01:41.750 --> 01:01:42.750
一開始是undefine的

01:01:42.750 --> 01:01:43.750
沒有值

01:01:43.750 --> 01:01:44.750
那麼是不是直接覆蓋過去

01:01:44.750 --> 01:01:45.750
完成了

01:01:45.750 --> 01:01:46.750
把這個東西覆蓋過去

01:01:46.750 --> 01:01:47.750
完成了

01:01:48.750 --> 01:01:49.750
還有什麼情況下要覆蓋呢

01:01:49.750 --> 01:01:50.750
是

01:01:51.750 --> 01:01:52.750
看一下

01:01:52.750 --> 01:01:53.750
比方說一開始

01:01:53.750 --> 01:01:54.750
一開始25

01:01:54.750 --> 01:01:55.750
對吧

01:01:55.750 --> 01:01:56.750
25

01:01:56.750 --> 01:01:57.750
把這個覆蓋過去

01:01:57.750 --> 01:01:58.750
它現在變成這個

01:01:58.750 --> 01:01:59.750
它undefine的時候呢

01:01:59.750 --> 01:02:00.750
要覆蓋

01:02:00.750 --> 01:02:01.750
那麼還有這種情況

01:02:01.750 --> 01:02:03.750
就是它為這個值的時候

01:02:03.750 --> 01:02:05.750
當我到的這個地方

01:02:05.750 --> 01:02:06.750
循環到這個地方

01:02:06.750 --> 01:02:07.750
時是不是比五大

01:02:07.750 --> 01:02:08.750
頻率比五大

01:02:08.750 --> 01:02:09.750
所以說這個時候

01:02:09.750 --> 01:02:10.750
是不是也要覆蓋

01:02:10.750 --> 01:02:11.750
覆蓋最大的

01:02:11.750 --> 01:02:13.750
保存最大的

01:02:13.750 --> 01:02:15.750
那麼這個地方也要覆蓋

01:02:15.750 --> 01:02:16.750
就這種情況

01:02:16.750 --> 01:02:18.750
或者是另外一種情況

01:02:18.750 --> 01:02:19.750
另外一種情況

01:02:19.750 --> 01:02:20.750
就是什麼呢

01:02:20.750 --> 01:02:22.750
就是這個record

01:02:22.750 --> 01:02:24.750
它的屬性值

01:02:24.750 --> 01:02:26.750
就這個對象的屬性值

01:02:26.750 --> 01:02:28.750
大於了

01:02:28.750 --> 01:02:29.750
大於了什麼呢

01:02:29.750 --> 01:02:32.750
大於了result的frequency

01:02:32.750 --> 01:02:34.750
大於了這個屬性

01:02:35.750 --> 01:02:37.750
大於了這個屬性

01:02:37.750 --> 01:02:38.750
好

01:02:38.750 --> 01:02:39.750
這兩種情況

01:02:39.750 --> 01:02:40.750
任何一種

01:02:40.750 --> 01:02:41.750
是不是要覆蓋

01:02:41.750 --> 01:02:42.750
對吧

01:02:42.750 --> 01:02:43.750
要覆蓋result

01:02:43.750 --> 01:02:44.750
等於什麼呢

01:02:44.750 --> 01:02:45.750
等於一個對象

01:02:45.750 --> 01:02:46.750
這個對象的什麼呢

01:02:46.750 --> 01:02:47.750
number

01:02:47.750 --> 01:02:48.750
為啥

01:02:48.750 --> 01:02:49.750
wayprop

01:02:49.750 --> 01:02:50.750
是不是屬性名

01:02:50.750 --> 01:02:51.750
它的值呢

01:02:51.750 --> 01:02:52.750
frequency

01:02:52.750 --> 01:02:53.750
它的值

01:02:54.750 --> 01:02:55.750
為啥

01:02:55.750 --> 01:02:57.750
為是不是屬性值

01:02:57.750 --> 01:02:58.750
屬性值

01:02:59.750 --> 01:03:00.750
好

01:03:00.750 --> 01:03:01.750
看一下

01:03:01.750 --> 01:03:02.750
最後呢

01:03:02.750 --> 01:03:04.750
我們輸出這個結果對象

01:03:04.750 --> 01:03:05.750
保存

01:03:05.750 --> 01:03:06.750
看一下

01:03:07.750 --> 01:03:08.750
number

01:03:08.750 --> 01:03:09.750
五

01:03:09.750 --> 01:03:11.750
出現頻率十次

01:03:11.750 --> 01:03:12.750
看不

01:03:12.750 --> 01:03:13.750
number五

01:03:13.750 --> 01:03:14.750
出現頻率十次

01:03:14.750 --> 01:03:15.750
好

01:03:15.750 --> 01:03:16.750
最終呢

01:03:16.750 --> 01:03:17.750
我們就可以輸出了

01:03:17.750 --> 01:03:18.750
用模板支付出來輸出

01:03:18.750 --> 01:03:19.750
輸出什麼

01:03:19.750 --> 01:03:24.790
什麼的出現頻率最高呢

01:03:25.790 --> 01:03:27.790
result的number

01:03:27.790 --> 01:03:28.790
出現頻率最高

01:03:28.790 --> 01:03:29.790
出現了幾次呢

01:03:29.790 --> 01:03:31.790
出現了result

01:03:31.790 --> 01:03:32.790
frequency

01:03:33.790 --> 01:03:34.790
frequency

01:03:35.790 --> 01:03:36.790
保存看一下

01:03:37.790 --> 01:03:38.790
五的出現頻率最高

01:03:38.790 --> 01:03:39.790
出現了十次

01:03:39.790 --> 01:03:40.790
這樣子呢

01:03:40.790 --> 01:03:42.790
我就把這個持頻統計出來了

01:03:42.790 --> 01:03:43.790
統計出來了

01:03:43.790 --> 01:03:45.790
代碼其實不多

01:03:45.790 --> 01:03:46.790
但是呢

01:03:46.790 --> 01:03:48.790
需要這種巧妙的解決辦法

01:03:49.790 --> 01:03:50.790
你可能想不到

01:03:50.790 --> 01:03:51.790
沒關係

01:03:51.790 --> 01:03:52.790
應該怎麼樣呢

01:03:52.790 --> 01:03:53.790
我給你思路過後

01:03:54.790 --> 01:03:55.790
哪怕你做不出來

01:03:55.790 --> 01:03:56.790
沒關係

01:03:56.790 --> 01:03:57.790
你聽完了過後

01:03:57.790 --> 01:03:58.790
我給你的思路

01:03:58.790 --> 01:03:59.790
你應該把做出來了

01:03:59.790 --> 01:04:00.790
如果你還做不出來

01:04:00.790 --> 01:04:01.790
ok

01:04:01.790 --> 01:04:02.790
再看一面

01:04:02.790 --> 01:04:03.790
再看一面

01:04:03.790 --> 01:04:04.790
不要去背代碼

01:04:04.790 --> 01:04:05.790
千萬不要去背代碼

01:04:05.790 --> 01:04:06.790
你要去體會到

01:04:06.790 --> 01:04:07.790
我怎麼把思路

01:04:07.790 --> 01:04:09.790
轉換成代碼的

01:04:09.790 --> 01:04:10.790
你去體會這個東西

01:04:10.790 --> 01:04:11.790
最終呢

01:04:11.790 --> 01:04:12.790
你一定要去寫出來

01:04:12.790 --> 01:04:14.790
就是你寫作業的時候

01:04:14.790 --> 01:04:15.790
千萬不要想

01:04:15.790 --> 01:04:16.790
我寫這個時候

01:04:16.790 --> 01:04:17.790
老師剛才打寫的

01:04:17.790 --> 01:04:18.790
千萬不要去想這個問題

01:04:18.790 --> 01:04:19.790
應該想的是什麼

01:04:19.790 --> 01:04:20.790
思路是什麼

01:04:20.790 --> 01:04:21.790
怎麼樣把這個思路

01:04:21.790 --> 01:04:22.790
轉換成代碼

01:04:22.790 --> 01:04:23.790
如果你忘了

01:04:23.790 --> 01:04:24.790
可以回過頭來看一下

01:04:24.790 --> 01:04:25.790
但是千萬不要去想

01:04:25.790 --> 01:04:26.790
老師寫的是什麼

01:04:26.790 --> 01:04:27.790
沒有意義

01:04:27.790 --> 01:04:28.790
千萬不要這樣想

01:04:28.790 --> 01:04:29.790
好

01:04:29.790 --> 01:04:30.790
那麼這個倒題

01:04:30.790 --> 01:04:31.790
說完了之後

01:04:31.790 --> 01:04:33.790
其實

01:04:33.790 --> 01:04:34.790
我們可以順便說一下

01:04:34.790 --> 01:04:36.790
求最大值最小值

01:04:36.790 --> 01:04:38.790
最大值

01:04:38.790 --> 01:04:40.790
當然求個最大值的問題

01:04:40.790 --> 01:04:41.790
好

01:04:41.790 --> 01:04:42.790
最大值的問題

01:04:42.790 --> 01:04:43.790
我們這個作業裏面沒有

01:04:43.790 --> 01:04:44.790
但是也很簡單了

01:04:48.100 --> 01:04:49.100
一個數組

01:04:50.100 --> 01:04:51.100
隨便寫

01:04:55.850 --> 01:04:57.850
求這個數組中最大值

01:04:57.850 --> 01:04:58.850
求最大值

01:04:59.850 --> 01:05:01.850
好最大值怎麼求

01:05:01.850 --> 01:05:02.850
首先想思路

01:05:02.850 --> 01:05:04.850
思路想出來再轉換成代碼

01:05:05.850 --> 01:05:06.850
怎麼求呢

01:05:06.850 --> 01:05:07.850
最大值

01:05:08.850 --> 01:05:09.850
最大值的話

01:05:09.850 --> 01:05:10.850
我們可以這樣

01:05:10.850 --> 01:05:11.850
不要說我交給你來做

01:05:11.850 --> 01:05:13.850
你不要去用想程序

01:05:13.850 --> 01:05:14.850
你來做這件事情

01:05:14.850 --> 01:05:16.850
有一個長度為一千萬的數組

01:05:16.850 --> 01:05:18.850
你要找到它的最大值

01:05:18.850 --> 01:05:19.850
怎麼找

01:05:19.850 --> 01:05:20.850
怎麼找

01:05:20.850 --> 01:05:21.850
思路是這樣子

01:05:21.850 --> 01:05:23.850
你拿個東西來記錄

01:05:24.850 --> 01:05:26.850
拿個東西來記錄

01:05:26.850 --> 01:05:28.850
先把它設置為什麼呢

01:05:28.850 --> 01:05:30.850
先把它設置為AndyFan

01:05:30.850 --> 01:05:31.850
先把它設置為AndyFan

01:05:32.850 --> 01:05:34.850
然後循環這個數組

01:05:34.850 --> 01:05:35.850
把數組的第1項拿出來

01:05:35.850 --> 01:05:37.850
它如果是AndyFan

01:05:37.850 --> 01:05:38.850
它如果是AndyFan

01:05:38.850 --> 01:05:39.850
OK

01:05:39.850 --> 01:05:40.850
那麼我們就把它設置為

01:05:40.850 --> 01:05:42.850
把它覆蓋過去

01:05:42.850 --> 01:05:43.850
或者是把這個數據

01:05:43.850 --> 01:05:44.850
設置為這個數組的

01:05:44.850 --> 01:05:46.850
設置為第1項

01:05:46.850 --> 01:05:48.850
只要數組的長度不小於1

01:05:48.850 --> 01:05:49.850
那麼就把它設置為第1項

01:05:50.850 --> 01:05:52.850
咱們從第二項開始看

01:05:52.850 --> 01:05:54.850
如果第二項比它大覆蓋

01:05:54.850 --> 01:05:56.850
如果比它小的話不動

01:05:56.850 --> 01:05:57.850
第三項不動

01:05:57.850 --> 01:05:58.850
第四項不動

01:05:58.850 --> 01:06:00.850
第五項比它大了覆蓋

01:06:00.850 --> 01:06:01.850
第四項

01:06:01.850 --> 01:06:03.850
然後它比它小不動

01:06:03.850 --> 01:06:04.850
那麼這樣子

01:06:04.850 --> 01:06:05.850
最後出來的結果

01:06:05.850 --> 01:06:07.850
是不是它一定是最大的

01:06:07.850 --> 01:06:08.850
對吧

01:06:08.850 --> 01:06:09.850
你把思路找到

01:06:09.850 --> 01:06:10.850
那麼我們就可以寫了

01:06:10.850 --> 01:06:12.850
你思路出來的就可以寫了

01:06:12.850 --> 01:06:13.850
最大值為多少呢

01:06:13.850 --> 01:06:15.850
為這個數組第1項

01:06:15.850 --> 01:06:17.850
把它存過去

01:06:17.850 --> 01:06:18.850
當然前提條件

01:06:18.850 --> 01:06:20.850
這個數組長度不能為0

01:06:20.850 --> 01:06:21.850
不能是一個空數組

01:06:21.850 --> 01:06:23.850
裡面必須要有東西

01:06:23.850 --> 01:06:24.850
所以說你可以先判斷一下

01:06:24.850 --> 01:06:25.850
可以先判斷一下

01:06:25.850 --> 01:06:27.850
如果這個數組長度為0的話

01:06:27.850 --> 01:06:28.850
哪來的最大值最小值呢

01:06:28.850 --> 01:06:29.850
對吧

01:06:29.850 --> 01:06:30.850
可以先判斷一下

01:06:30.850 --> 01:06:31.850
好

01:06:31.850 --> 01:06:32.850
然後就循環

01:06:32.850 --> 01:06:33.850
循環的時候

01:06:33.850 --> 01:06:34.850
i從幾開始

01:06:34.850 --> 01:06:36.850
從1開始

01:06:36.850 --> 01:06:37.850
你看

01:06:37.850 --> 01:06:38.850
不同的思路

01:06:38.850 --> 01:06:40.850
你得到的代碼是不一樣的

01:06:40.850 --> 01:06:41.850
你先得有思路

01:06:41.850 --> 01:06:42.850
你沒有思路

01:06:42.850 --> 01:06:43.850
你去背這個東西毫無意義

01:06:43.850 --> 01:06:44.850
你怎麼知道

01:06:44.850 --> 01:06:46.850
i為什麼一定是1開始呢

01:06:46.850 --> 01:06:47.850
它因為它有思路的

01:06:47.850 --> 01:06:49.850
因為第1項已經拿過去了

01:06:49.850 --> 01:06:50.850
我們不用看第1項了

01:06:50.850 --> 01:06:51.850
從第2項開始看

01:06:51.850 --> 01:06:52.850
好

01:06:52.850 --> 01:06:54.850
如果發現這個數字的

01:06:54.850 --> 01:06:55.850
大於到什麼

01:06:55.850 --> 01:06:56.850
大於到max

01:06:56.850 --> 01:06:57.850
重新記錄

01:06:57.850 --> 01:06:59.850
重新記錄這個數字

01:06:59.850 --> 01:07:01.850
重新記錄

01:07:01.850 --> 01:07:03.850
能不能break

01:07:03.850 --> 01:07:05.850
能不能結束

01:07:05.850 --> 01:07:06.850
肯定不能結束

01:07:06.850 --> 01:07:07.850
數組要看完

01:07:07.850 --> 01:07:08.850
把整個數組看完

01:07:08.850 --> 01:07:10.850
最後數數最大值

01:07:10.850 --> 01:07:11.850
數數max

01:07:11.850 --> 01:07:13.850
那麼最小值是不是一樣的

01:07:13.850 --> 01:07:14.850
一樣的思路

01:07:14.850 --> 01:07:18.860
看一下666

01:07:19.860 --> 01:07:20.860
明白吧

01:07:20.860 --> 01:07:21.860
沒問題吧

01:07:22.860 --> 01:07:23.860
消化

01:07:23.860 --> 01:07:25.860
一定要下去消化這一塊的作業

01:07:25.860 --> 01:07:26.860
雖然這一塊作業

01:07:26.860 --> 01:07:27.860
沒有循環那麼多

01:07:27.860 --> 01:07:28.860
我之前反覆的強調

01:07:28.860 --> 01:07:29.860
循環那一塊

01:07:29.860 --> 01:07:30.860
還真的是重點

01:07:30.860 --> 01:07:31.860
因為循環你搞清楚了過

01:07:31.860 --> 01:07:32.860
數組這一塊

01:07:32.860 --> 01:07:34.860
就降低到很大的難度了

01:07:34.860 --> 01:07:35.860
因為數組基本上

01:07:35.860 --> 01:07:37.860
要跟循環經常要連用

01:07:37.860 --> 01:07:38.860
一看我們這裡的題

01:07:38.860 --> 01:07:40.860
基本上每道題都有循環

01:07:40.860 --> 01:07:41.860
基本上都有循環

01:07:41.860 --> 01:07:42.860
它經常都要連用的

01:07:42.860 --> 01:07:43.860
所以說

01:07:43.860 --> 01:07:44.860
你一定要先把循環搞清楚

01:07:44.860 --> 01:07:45.860
才能學數組

01:07:45.860 --> 01:07:46.860
好吧

01:07:46.860 --> 01:07:47.860
OK

01:07:47.860 --> 01:07:48.860
這是

01:07:48.860 --> 01:07:50.860
流程控制的

01:07:50.860 --> 01:07:51.860
這數組應用

01:07:51.860 --> 01:07:52.860
流程控制就講完了

01:07:52.860 --> 01:07:53.860
就差不多了

01:07:53.860 --> 01:07:54.860
流程控制這一塊

01:07:54.860 --> 01:07:55.860
其實數組

01:07:55.860 --> 01:07:56.860
它都不屬於流程控制的

01:07:56.860 --> 01:07:58.860
只是數組經常跟循環

01:07:58.860 --> 01:07:59.860
判斷這些來連用

01:07:59.860 --> 01:08:00.860
所以說

01:08:00.860 --> 01:08:01.860
我們把它加到這裡來

01:08:02.860 --> 01:08:03.860
好了這一塊過了

01:08:03.860 --> 01:08:04.860
如果你把能把

01:08:04.860 --> 01:08:05.860
這一個關卡過了

01:08:05.860 --> 01:08:06.860
第四章的話

01:08:06.860 --> 01:08:09.860
以前我在線下收課的時候

01:08:09.860 --> 01:08:11.860
要講兩天

01:08:11.860 --> 01:08:12.860
兩到三天

01:08:12.860 --> 01:08:14.860
基本上兩到三天的時間

01:08:14.860 --> 01:08:15.860
然後

01:08:15.860 --> 01:08:16.860
線下收課

01:08:16.860 --> 01:08:18.860
因為同學的學到時間比較長

01:08:18.860 --> 01:08:19.860
基本上一天是

01:08:19.860 --> 01:08:20.860
18個小時

01:08:20.860 --> 01:08:21.860
到了去流程控制這一塊

01:08:21.860 --> 01:08:22.860
可能還要加班

01:08:22.860 --> 01:08:23.860
可能晚上回去還要加班

01:08:23.860 --> 01:08:24.860
還要去看

01:08:24.860 --> 01:08:25.860
還要去做練習

01:08:25.860 --> 01:08:26.860
可能加菜了

01:08:26.860 --> 01:08:27.860
一天得要多少小時呢

01:08:27.860 --> 01:08:28.860
一天得要

01:08:28.860 --> 01:08:29.860
得要12個小時左右

01:08:29.860 --> 01:08:30.860
學兩到三天

01:08:30.860 --> 01:08:31.860
你自己體會一下

01:08:31.860 --> 01:08:32.860
這一塊

01:08:32.860 --> 01:08:33.860
千萬不要快速給我結束

01:08:33.860 --> 01:08:34.860
一定要慢一點

01:08:34.860 --> 01:08:35.860
慢一點

01:08:35.860 --> 01:08:36.860
一塊塊吃透

01:08:36.860 --> 01:08:37.860
這一塊你搞清楚了

01:08:37.860 --> 01:08:39.860
那後面什麼寒樹

01:08:39.860 --> 01:08:40.860
寒樹啊

01:08:40.860 --> 01:08:41.860
後面什麼就是

01:08:41.860 --> 01:08:44.860
包括瀏覽器裡面的一些操作

01:08:44.860 --> 01:08:45.860
在瀏覽器裡面

01:08:45.860 --> 01:08:46.860
控制介面

01:08:46.860 --> 01:08:47.860
做一些效果出來

01:08:47.860 --> 01:08:48.860
都很簡單

01:08:48.860 --> 01:08:49.860
流程控制

01:08:49.860 --> 01:08:51.860
這是第四章到此為止

01:08:51.860 --> 01:08:52.860
結束了

01:08:52.860 --> 01:08:53.860
拜拜

