WEBVTT

00:00.000 --> 00:03.000
比较运算符

00:03.000 --> 00:18.990
比较运算符这一块我还是把它分为两个部分的讲吧

00:18.990 --> 00:21.990
因为它跟之前的算式运算符差不多

00:21.990 --> 00:26.990
平时我们用的时候 简单的令人发誓

00:26.990 --> 00:31.990
但是面试题的时候 它又规则了又比较复杂

00:31.990 --> 00:34.990
因为这一块东西它的细节比较多

00:34.990 --> 00:37.990
我们单独来聊细节 先把它简单的说了

00:37.990 --> 00:42.990
比较运算符通常就是比较数字的大小

00:42.990 --> 00:48.990
它分为这么一些 一个是大小比较

00:48.990 --> 00:52.990
大小比较分为这么几个 四个 一个是大渔符号

00:52.990 --> 00:54.990
一个是小渔符号

00:54.990 --> 00:57.990
然后一个是大渔等于 一个是小渔等于

00:57.990 --> 01:00.990
很好理解 非常非常好理解

01:00.990 --> 01:02.990
比方说6大渔等于4 对吧

01:02.990 --> 01:06.990
6大渔4 6也大渔等于4 都是一样的

01:06.990 --> 01:11.990
还有一个就是相等比较

01:11.990 --> 01:15.990
那么也分为四个 一个是相等

01:15.990 --> 01:20.990
一个是感叹号 表示不相等

01:20.990 --> 01:22.990
这样子写 不相等

01:22.990 --> 01:24.990
一个是严格相等

01:24.990 --> 01:26.990
一个是严格不相等

01:26.990 --> 01:33.620
也分为这么四个 写开一点

01:33.620 --> 01:37.620
一共就这么八个运算符 比较运算符

01:37.620 --> 01:40.620
比较运算符这一块 通常情况下

01:40.620 --> 01:42.620
特别是大小比较这一块

01:42.620 --> 01:45.620
通常情况下 都是指的是两个数字比较

01:45.620 --> 01:48.620
所以说我们平时开发代码的时候

01:48.620 --> 01:51.620
通常用比较大小的时候 都是两个数字

01:51.620 --> 01:54.620
因此两个数字比较非常非常简单 贼简单

01:54.620 --> 01:55.620
简单不得了

01:55.620 --> 01:58.620
相等比较这一块 它可以是数字

01:58.620 --> 02:01.620
也可以是其他类型 比方说制服串

02:01.620 --> 02:02.620
两个制服串比较相等

02:02.620 --> 02:05.620
或者是两个布尔兹来比较相等

02:05.620 --> 02:08.620
都可以

02:08.620 --> 02:12.620
那么比较运算符 不管是大小比较也好

02:12.620 --> 02:14.620
还是相等比较也好

02:14.620 --> 02:18.620
它们都有个共同的特征 就是比较运算符

02:18.620 --> 02:20.620
我这里把它加出

02:20.620 --> 02:26.620
比较运算符的返回类型

02:26.620 --> 02:28.620
什么叫返回类型 想一想

02:28.620 --> 02:33.620
回忆一下 什么叫做返回类型

02:33.620 --> 02:34.620
返回类型是啥意思呢

02:34.620 --> 02:36.620
返回类型表示的是

02:36.620 --> 02:39.620
这个表达是返回的结果

02:39.620 --> 02:43.620
就算出来的结果的类型

02:43.620 --> 02:45.620
比方说1加2结果是3

02:45.620 --> 02:47.620
3的类型叫做返回类型

02:47.620 --> 02:50.620
3的类型就是数字

02:50.620 --> 02:52.620
返回类型就是number

02:52.620 --> 02:53.620
就这么个意思

02:53.620 --> 02:56.620
比较运算符的返回类型是啥呢

02:56.620 --> 02:59.620
布尔 布林

02:59.620 --> 03:01.620
布林是什么 是和否

03:01.620 --> 03:04.620
比方说6是不是大于5

03:04.620 --> 03:06.620
这就是一个是不是

03:06.620 --> 03:07.620
返回的结果是一个布尔

03:07.620 --> 03:10.620
它一定返回布尔 绝不可能返回其他东西

03:10.620 --> 03:12.620
所以说比较运算符这一块

03:12.620 --> 03:14.620
它的返回类型大家记住

03:14.620 --> 03:16.620
一定是布尔 一定是布尔

03:16.620 --> 03:19.620
好 第二个 一个统一的规则

03:19.620 --> 03:21.620
这些都是统一规则

03:21.620 --> 03:27.620
好 第二个就是算数运算符的优先级

03:27.620 --> 03:29.620
高于 高于啥呢

03:29.620 --> 03:31.620
高于比较运算符

03:31.620 --> 03:33.620
高于比较运算符

03:33.620 --> 03:35.620
就是比方说啊

03:35.620 --> 03:36.620
我举个例子吧

03:36.620 --> 03:38.620
举个例子

03:38.620 --> 03:42.700
test1

03:42.700 --> 03:44.700
script

03:44.700 --> 03:46.700
比方说咱们直接输出

03:46.700 --> 03:49.700
输出6大于5

03:49.700 --> 03:51.700
会输出什么呢

03:51.700 --> 03:52.700
它输出的是啥

03:52.700 --> 03:53.700
输出的不是6

03:53.700 --> 03:54.700
输出的也不是5

03:54.700 --> 03:57.700
输出的是这个表达式的结果

03:57.700 --> 03:59.700
这个表达式的结果是什么类型

03:59.700 --> 04:01.700
说过了 刚刚说过了

04:01.700 --> 04:02.700
什么类型

04:02.700 --> 04:04.700
表达式的返回结果一定是布尔

04:04.700 --> 04:06.700
比较运算符

04:06.700 --> 04:08.700
表达式的返回结果一定是布尔

04:08.700 --> 04:09.700
所以说输出啥

04:09.700 --> 04:11.700
输出去

04:11.700 --> 04:12.700
6一定是大于5的

04:12.700 --> 04:14.700
所以说输出去

04:14.700 --> 04:16.700
好 看一下

04:16.700 --> 04:18.700
你看 得到结果是去

04:18.700 --> 04:20.700
好 再来啊

04:20.700 --> 04:22.700
6是不是大于等于5呢

04:22.700 --> 04:24.700
有些同学可能还搞不清楚

04:24.700 --> 04:25.700
什么叫大于等于

04:25.700 --> 04:27.700
就是大于或者是等于

04:27.700 --> 04:29.700
或者是等于

04:29.700 --> 04:30.700
6说大于等于5

04:30.700 --> 04:31.700
是不是也是去

04:31.700 --> 04:32.700
对吧 也是去

04:32.700 --> 04:33.700
这个很简单

04:33.700 --> 04:35.700
那比方说

04:35.700 --> 04:37.700
2加3

04:37.700 --> 04:39.700
这个怎么理解呢

04:39.700 --> 04:41.700
有两种理解方法

04:41.700 --> 04:43.700
一个是2加上啥呢

04:43.700 --> 04:45.700
加上这个表达式的结果

04:45.700 --> 04:47.700
加上这个表达式的结果

04:47.700 --> 04:48.700
表达式为布尔对吧

04:48.700 --> 04:50.700
布尔也是可以进行数学运算的

04:50.700 --> 04:51.700
我们之前说过

04:51.700 --> 04:53.700
布尔进行数学运算的时候

04:53.700 --> 04:55.700
进行转换

04:55.700 --> 04:57.700
自动进行转换

04:57.700 --> 04:59.700
True表示1

04:59.700 --> 05:01.700
Force表示0

05:01.700 --> 05:02.700
自动进行转换

05:02.700 --> 05:04.700
那么这是一种理解方式

05:04.700 --> 05:05.700
另一种理解方式是

05:05.700 --> 05:07.700
2加3的结果

05:07.700 --> 05:08.700
来跟5进行比较

05:08.700 --> 05:09.700
那么到底是哪一种呢

05:09.700 --> 05:11.700
叫看优先级

05:11.700 --> 05:12.700
我们刚才说了

05:12.700 --> 05:14.700
比较运算幅的优先级

05:14.700 --> 05:16.700
是低于算数运算幅的

05:16.700 --> 05:18.700
那么这个地方是算数运算幅

05:18.700 --> 05:20.700
所以说它的优先级要高一些

05:20.700 --> 05:21.700
所以说先算它

05:21.700 --> 05:23.700
它算出来再跟5进行比较

05:23.700 --> 05:24.700
这么个意思

05:24.700 --> 05:26.700
那么这个结果是啥

05:26.700 --> 05:28.700
这个结果是不是True对吧

05:28.700 --> 05:29.700
True

05:29.700 --> 05:30.700
看没

05:30.700 --> 05:32.700
这么两点

05:32.700 --> 05:34.700
其实也就差不多了

05:34.700 --> 05:36.700
大小比较的话就差不多了

05:36.700 --> 05:37.700
因为大小比较的话

05:37.700 --> 05:38.700
我们平时一般来说

05:38.700 --> 05:40.700
就是比较两个数字

05:40.700 --> 05:41.700
就是比较两个数字

05:41.700 --> 05:43.700
这个有一点点比较特殊的地方

05:43.700 --> 05:45.700
就是我们先讲统一规则

05:45.700 --> 05:47.700
然后再说细节

05:47.700 --> 05:49.700
有一个点比较特殊的

05:49.700 --> 05:51.700
就是制符券

05:51.700 --> 05:53.700
两个制符券

05:53.700 --> 05:55.700
比较大小

05:55.700 --> 05:58.700
我们这里先这样吧

05:58.700 --> 06:01.700
大小比较

06:01.700 --> 06:02.700
两个制符券

06:02.700 --> 06:03.700
如果是两个数字

06:03.700 --> 06:05.700
直接比较大小就完事了

06:05.700 --> 06:07.700
如果是两个制符券比较大小

06:07.700 --> 06:08.700
比较的是什么呢

06:08.700 --> 06:10.700
比较的是

06:10.700 --> 06:12.700
优先级

06:12.700 --> 06:16.700
比较的是制符券的

06:17.700 --> 06:19.700
制符编码

06:19.700 --> 06:22.700
比较的是制符券的制符编码

06:22.700 --> 06:24.700
那么这是什么意思呢

06:24.700 --> 06:25.700
什么意思呢

06:25.700 --> 06:27.700
我们知道每一个制符

06:27.700 --> 06:29.700
它都有一个编码

06:29.700 --> 06:30.700
这个在我的课程

06:30.700 --> 06:32.700
Atman和CSS里面讲过的

06:32.700 --> 06:33.700
有可能你没有听过

06:33.700 --> 06:35.700
我的Atman和CSS的课程

06:35.700 --> 06:36.700
那么我这里简单说一下吧

06:36.700 --> 06:39.700
就是计算机它是不能保存文字的

06:39.700 --> 06:41.700
文字是保存不了的

06:41.700 --> 06:43.700
它只能保存数字

06:43.700 --> 06:44.700
那么文字怎么办呢

06:44.700 --> 06:45.700
它就做了一个字典

06:45.700 --> 06:46.700
就是每一个文字

06:46.700 --> 06:47.700
它对于一个数字

06:47.700 --> 06:49.700
每一个文字对于一个数字

06:49.700 --> 06:51.700
它做了一个字典出来

06:51.700 --> 06:52.700
那么这个字典呢

06:52.700 --> 06:54.700
就是一个制符编码

06:54.700 --> 06:55.700
相当于是个制典

06:55.700 --> 06:56.700
我们再看一下吧

06:56.700 --> 06:58.700
制符编码有很多

06:58.700 --> 07:00.700
其中一个最基本的编码就是

07:00.700 --> 07:01.700
Askma

07:01.700 --> 07:04.700
看一下Askma

07:04.700 --> 07:09.210
看一下百度百克

07:09.210 --> 07:11.210
咱们找一下吧

07:11.210 --> 07:14.210
找一下

07:15.210 --> 07:17.210
这个表格

07:17.210 --> 07:20.210
这里一个表格看一下吧

07:21.210 --> 07:26.210
比方说我们来看一个制符吧

07:26.210 --> 07:27.210
一个制符圈里面

07:27.210 --> 07:29.210
大写字母A看一下

07:29.210 --> 07:31.210
大写字母A

07:31.210 --> 07:32.210
它对应的数字是多少

07:32.210 --> 07:35.210
对应的数字就是65

07:35.210 --> 07:36.210
大写字母B

07:36.210 --> 07:38.210
对应的数字就是66

07:38.210 --> 07:40.210
因为计算机它实变不了文字

07:40.210 --> 07:41.210
它不知道文字是啥

07:41.210 --> 07:43.210
它只能实变数字

07:43.210 --> 07:45.210
所以说它会有一个表格

07:45.210 --> 07:46.210
来对应这个关系

07:46.210 --> 07:48.210
文字和数字的关系

07:48.210 --> 07:50.210
那么这就是编码制符编码

07:50.210 --> 07:52.210
所以说我们当我们比较

07:52.210 --> 07:53.210
制符圈的时候比较的是什么呢

07:53.210 --> 07:56.210
比较的是制符编码

07:56.210 --> 07:57.210
比方说

07:57.210 --> 07:58.210
我们看第二个

07:58.210 --> 07:59.210
下一个

07:59.210 --> 08:01.210
log

08:01.210 --> 08:04.210
A是不是大于B呢

08:04.210 --> 08:05.210
A是不是大于B呢

08:05.210 --> 08:06.210
我们来看一下

08:06.210 --> 08:07.210
那么就看

08:07.210 --> 08:08.210
它会进行转换

08:08.210 --> 08:10.210
把这两个制符圈

08:10.210 --> 08:12.210
转换成编码

08:12.210 --> 08:13.210
编码的格式

08:13.210 --> 08:15.210
编码的格式A的编码是多少

08:15.210 --> 08:16.210
是65

08:16.210 --> 08:18.210
B的编码是66

08:18.210 --> 08:20.210
如果是两个制符圈

08:20.210 --> 08:21.210
进行比较的时候

08:21.210 --> 08:23.210
它是进行编码转换

08:23.210 --> 08:24.210
那么这里转换多少

08:24.210 --> 08:26.210
转换成65

08:26.210 --> 08:28.210
这里转换成66

08:28.210 --> 08:30.210
那么这个比较是force

08:30.210 --> 08:31.210
force

08:31.210 --> 08:33.210
看一下

08:33.210 --> 08:35.210
这里明显出来

08:35.210 --> 08:36.210
force

08:36.210 --> 08:37.210
没问题吧

08:37.210 --> 08:38.210
好 再来

08:39.210 --> 08:41.210
那如果是这样子比较呢

08:41.210 --> 08:42.210
AB

08:42.210 --> 08:43.210
AB

08:43.210 --> 08:44.210
好 这里呢

08:44.210 --> 08:46.210
就写一个AC

08:46.210 --> 08:48.210
好 这又怎么比较呢

08:48.210 --> 08:50.210
它先比较第一个制符的编码

08:50.210 --> 08:52.210
如果第一个制符的编码相等

08:52.210 --> 08:54.210
再比较第二个制符的编码

08:54.210 --> 08:55.210
它就这样子比较

08:55.210 --> 08:57.210
一次比较

08:57.210 --> 08:59.210
那么我们来看一下

08:59.210 --> 09:01.210
A的编码相同的

09:01.210 --> 09:03.210
那么比较B的编码

09:03.210 --> 09:05.210
B的编码要比C要小

09:05.210 --> 09:06.210
所以说

09:06.210 --> 09:09.210
这个比较结果也是force

09:09.210 --> 09:10.210
也是force

09:10.210 --> 09:12.210
这个比较出来是假

09:12.210 --> 09:14.210
它不是大于它

09:14.210 --> 09:15.210
而是小于它的

09:15.210 --> 09:17.210
保存看一下

09:17.210 --> 09:18.210
也是force

09:18.210 --> 09:20.210
好 咱们再来看

09:20.210 --> 09:21.210
再来看

09:21.210 --> 09:23.210
下面再写一个LOG

09:24.210 --> 09:26.210
1

09:26.210 --> 09:27.210
然后呢

09:27.210 --> 09:29.210
大于

09:29.210 --> 09:30.210
2

09:30.210 --> 09:32.210
大于2

09:32.210 --> 09:33.210
那么这个是编码

09:33.210 --> 09:34.210
我们来比较一下

09:34.210 --> 09:36.210
1的编码是不是大于2的

09:36.210 --> 09:38.210
我们来看一下OSC

09:38.210 --> 09:40.210
1的编码

09:40.210 --> 09:42.210
数字它也有制符创的格式

09:42.210 --> 09:44.210
数字也有制符创的格式

09:44.210 --> 09:46.210
所以说看数字的编码

09:46.210 --> 09:47.210
1是49

09:47.210 --> 09:48.210
2是50

09:48.210 --> 09:49.210
所以说

09:49.210 --> 09:51.210
这个比较出来也是force

09:51.210 --> 09:53.210
也是force

09:53.210 --> 09:54.210
好 那么这个时候

09:54.210 --> 09:56.210
我们再来这样子写

09:56.210 --> 09:57.210
腰腰

09:57.210 --> 09:59.210
这就有意思了

09:59.210 --> 10:02.210
那么这个编码是不是大于2呢

10:02.210 --> 10:04.210
是不是大于2呢

10:04.210 --> 10:05.210
我们来看一下

10:05.210 --> 10:07.210
先看来看结果

10:07.210 --> 10:09.210
它仍然是force

10:09.210 --> 10:10.210
那么这就奇怪了

10:10.210 --> 10:11.210
好像说呢

10:11.210 --> 10:13.210
你两个1

10:13.210 --> 10:15.210
我这里写的两个1

10:15.210 --> 10:18.210
应该是49加49

10:18.210 --> 10:20.210
它不是这样子比较的

10:20.210 --> 10:21.210
它不是这样子比较的

10:21.210 --> 10:23.210
它是一个一个比较

10:23.210 --> 10:25.210
如果第一个

10:25.210 --> 10:27.210
跟第二个就不相等

10:27.210 --> 10:28.210
那么结果就直接出来了

10:28.210 --> 10:29.210
如果相等的话

10:29.210 --> 10:31.210
再往后边比较

10:31.210 --> 10:32.210
它第一个不相等

10:32.210 --> 10:33.210
不相等的话

10:33.210 --> 10:34.210
结果就直接出来了

10:34.210 --> 10:36.210
1跟2比较

10:36.210 --> 10:37.210
它不相等

10:37.210 --> 10:38.210
不相等的话

10:38.210 --> 10:39.210
结果直接出来

10:39.210 --> 10:40.210
出来结果是它

10:40.210 --> 10:41.210
1是小于2的

10:41.210 --> 10:42.210
这里用的是大于

10:42.210 --> 10:44.210
所以说是force

10:44.210 --> 10:45.210
你看这个意思吧

10:45.210 --> 10:46.210
那么比方说

10:46.210 --> 10:48.210
11是不是大于1呢

10:48.210 --> 10:49.210
是不是大于1呢

10:49.210 --> 10:51.210
那么这就不一样了

10:51.210 --> 10:52.210
首先第一个位置

10:52.210 --> 10:54.210
编码是不是一样的

10:54.210 --> 10:57.210
编码都是49

10:57.210 --> 10:59.210
那么再比较第二个

10:59.210 --> 11:00.210
它没有第二个

11:00.210 --> 11:01.210
这个制护串有第二个

11:01.210 --> 11:02.210
它没有第二个

11:02.210 --> 11:03.210
没有第二个的话

11:03.210 --> 11:05.210
就把它当成0

11:05.210 --> 11:06.210
就把它当成0

11:06.210 --> 11:08.210
那么这个是1

11:08.210 --> 11:09.210
对吧

11:09.210 --> 11:10.210
所以说

11:10.210 --> 11:12.210
那么这个1表示的制护编码是49

11:12.210 --> 11:14.210
49一定是大于0的

11:14.210 --> 11:16.210
所以说这个就成立

11:16.210 --> 11:18.210
保存看一下

11:18.210 --> 11:19.210
成立

11:19.210 --> 11:21.210
这是两个制护串的比较

11:21.210 --> 11:22.210
这种情况下

11:22.210 --> 11:23.210
我们有可能会遇到

11:23.210 --> 11:24.210
其实也遇到了不多

11:24.210 --> 11:26.210
也遇到了不多

11:26.210 --> 11:28.210
接下来

11:28.210 --> 11:30.210
我们要说细节了

11:30.210 --> 11:32.210
细节要开始了

11:32.210 --> 11:34.210
如果不考虑细节的话

11:34.210 --> 11:35.210
平时我们用的就是

11:35.210 --> 11:37.210
就是数字之间的比较

11:37.210 --> 11:38.210
大小比较的话

11:38.210 --> 11:39.210
就是数字之间的比较

11:39.210 --> 11:41.210
所以说没啥好说的

11:41.210 --> 11:42.210
但是呢

11:42.210 --> 11:44.210
一旦涉及到不同的一形

11:44.210 --> 11:46.210
如果还有一个不是数字

11:46.210 --> 11:47.210
两个制护串

11:47.210 --> 11:48.210
怎么样那些东西

11:48.210 --> 11:50.210
各种细节就来了

11:50.210 --> 11:51.210
第一个细节呢

11:51.210 --> 11:52.210
说了

11:52.210 --> 11:53.210
这东西其实也可以看细节

11:53.210 --> 11:55.210
也可以当作细节

11:55.210 --> 11:56.210
第一个东西已经说了

11:56.210 --> 11:57.210
就是两个制护串比较

11:57.210 --> 11:59.210
比较的是制护串的制护边嘛

11:59.210 --> 12:01.210
一位一位进行比较

12:01.210 --> 12:02.210
好

12:02.210 --> 12:04.210
那么另外一种情况

12:04.210 --> 12:07.210
如果一个

12:07.210 --> 12:09.210
不是制护串

12:09.210 --> 12:11.210
不是制护串

12:11.210 --> 12:13.210
并且

12:13.210 --> 12:15.210
两个

12:15.210 --> 12:17.210
两个都是

12:17.210 --> 12:19.210
原始类型

12:19.210 --> 12:21.210
两个都是原始类型

12:21.210 --> 12:23.210
我这样子说吧

12:23.210 --> 12:25.210
我想想啊

12:25.210 --> 12:27.210
怎么来研究这个东西

12:27.210 --> 12:28.210
就这样说

12:28.210 --> 12:30.210
这是第二种情况

12:30.210 --> 12:32.210
如果其中一个不是制护串

12:32.210 --> 12:34.210
如果两个都是制护串

12:34.210 --> 12:35.210
OK

12:35.210 --> 12:36.210
那么比较制护串边嘛

12:36.210 --> 12:38.210
如果其中一个不是制护串

12:38.210 --> 12:39.210
并且呢

12:39.210 --> 12:41.210
两个都是原始类型

12:41.210 --> 12:42.210
什么原始类型

12:42.210 --> 12:43.210
布尔

12:43.210 --> 12:44.210
数字

12:44.210 --> 12:45.210
制护串

12:45.210 --> 12:46.210
这些都是原始类型

12:46.210 --> 12:47.210
好

12:47.210 --> 12:48.210
这个时候怎么办呢

12:48.210 --> 12:50.210
将他们

12:50.210 --> 12:52.210
都转换为

12:52.210 --> 12:55.210
数字进行比较

12:55.210 --> 12:57.210
都转换为数字进行比较

12:57.210 --> 12:58.210
好

12:58.210 --> 12:59.210
我们来看一下啊

12:59.210 --> 13:01.210
这是怎么一种情况

13:01.210 --> 13:03.210
第二个页面

13:03.210 --> 13:05.210
比方说

13:05.210 --> 13:06.210
左边呢

13:06.210 --> 13:08.210
我写的是一个制护串

13:08.210 --> 13:10.210
一个制护串A

13:10.210 --> 13:12.210
右边呢写的是

13:12.210 --> 13:13.210
不是制护串的哦

13:13.210 --> 13:14.210
现在不是两个制护串的

13:14.210 --> 13:15.210
写的是一个数字

13:15.210 --> 13:16.210
写的是一个数字

13:16.210 --> 13:18.210
我们这样子写吧

13:18.210 --> 13:20.210
这里写的是一个数字

13:20.210 --> 13:23.210
比方说10

13:23.210 --> 13:25.210
那么这个比较出来是啥呢

13:25.210 --> 13:27.210
比较出来是啥

13:27.210 --> 13:28.210
有些同学说

13:28.210 --> 13:29.210
应该比较出来是真

13:29.210 --> 13:30.210
对吧

13:30.210 --> 13:31.210
是真

13:31.210 --> 13:32.210
布尔嘛

13:32.210 --> 13:33.210
真和假

13:33.210 --> 13:34.210
应该比较出来是真

13:34.210 --> 13:35.210
是这样子吗

13:35.210 --> 13:36.210
如果你这样想的话

13:36.210 --> 13:37.210
你肯定是认为

13:37.210 --> 13:38.210
这一块呢

13:38.210 --> 13:39.210
是把他的什么

13:39.210 --> 13:40.210
编码算出来

13:40.210 --> 13:41.210
一的编码是多少

13:41.210 --> 13:42.210
一的编码

13:42.210 --> 13:43.210
我们刚才看了的

13:43.210 --> 13:44.210
一的编码是49

13:44.210 --> 13:45.210
对吧

13:45.210 --> 13:46.210
那么49是大于10的

13:46.210 --> 13:47.210
所以说

13:47.210 --> 13:48.210
有些同学觉得

13:48.210 --> 13:49.210
应该这样比较

13:49.210 --> 13:52.210
现在是要做内形的转换

13:52.210 --> 13:53.210
只有第一种情况

13:53.210 --> 13:55.210
比较的才是制抚编码

13:55.210 --> 13:57.210
两个都是制抚串

13:57.210 --> 13:59.210
比较的才是制抚编码

13:59.210 --> 14:01.210
一位一位进行比较

14:01.210 --> 14:03.210
如果其中一个不是制抚串

14:03.210 --> 14:04.210
只有一个制抚串

14:04.210 --> 14:06.210
或者是都不是制抚串

14:06.210 --> 14:07.210
都是其他的原式内形

14:07.210 --> 14:08.210
总之

14:08.210 --> 14:09.210
如果一个

14:09.210 --> 14:11.210
只要有一个不是制抚串

14:11.210 --> 14:13.210
那么他们比较的时候

14:13.210 --> 14:16.210
都要转换成数字

14:16.210 --> 14:17.210
那么转换数字

14:17.210 --> 14:18.210
之前是不是讲过的

14:19.210 --> 14:20.210
制抚串转数字

14:20.210 --> 14:21.210
之前是不是讲过的

14:21.210 --> 14:22.210
来

14:22.210 --> 14:23.210
做几道题

14:23.210 --> 14:25.210
这个制抚串转换的数字是啥

14:25.210 --> 14:26.210
是啥

14:26.210 --> 14:27.210
是不是1

14:27.210 --> 14:29.210
这个制抚串转换的数字是啥

14:29.210 --> 14:31.210
是不是0

14:31.210 --> 14:32.210
再来

14:32.210 --> 14:34.210
那么这个制抚串几个空格

14:34.210 --> 14:36.210
转换的数字是啥

14:36.210 --> 14:38.210
忽略空格0

14:38.210 --> 14:41.210
这个制抚串转换的数字是啥

14:41.210 --> 14:42.210
是啥

14:42.210 --> 14:44.210
是不是NAN

14:44.210 --> 14:45.210
对吧NAN

14:45.210 --> 14:46.210
没问题吧

14:46.210 --> 14:48.210
这个制抚串转换的数字

14:48.210 --> 14:50.210
就是3.14

14:50.210 --> 14:52.210
这是制抚串转数字的规律

14:52.210 --> 14:54.210
总之把这个制抚串转换的数字

14:54.210 --> 14:55.210
进行比较

14:55.210 --> 14:56.210
那么这个比较出来是啥

14:56.210 --> 14:58.210
相当于就是1和10比比较

14:58.210 --> 15:00.210
那么结果自然是假

15:00.210 --> 15:01.210
自然是假

15:03.210 --> 15:04.210
好看一下

15:04.210 --> 15:05.210
Force

15:05.210 --> 15:07.210
好 再来

15:07.210 --> 15:08.210
Console

15:08.210 --> 15:09.210
Log

15:09.210 --> 15:11.210
然后是

15:11.210 --> 15:12.210
2

15:12.210 --> 15:13.210
是不是大于

15:13.210 --> 15:15.210
2

15:15.210 --> 15:17.210
来 想一想

15:17.210 --> 15:19.210
结果是多少

15:20.210 --> 15:23.650
多少呢

15:23.650 --> 15:24.650
是不是真

15:24.650 --> 15:26.650
对吧 是真 怎么来的

15:26.650 --> 15:28.650
只要一个不是数字

15:28.650 --> 15:29.650
只要一个不是制抚串

15:29.650 --> 15:31.650
一定是转换的数字

15:31.650 --> 15:33.650
两个都是原式内形

15:33.650 --> 15:35.650
并且一个不是制抚串

15:35.650 --> 15:37.650
都要转换的数字

15:37.650 --> 15:38.650
那么这个东西转换的数字是多少

15:38.650 --> 15:39.650
是不是2

15:39.650 --> 15:40.650
对吧

15:40.650 --> 15:41.650
2

15:41.650 --> 15:42.650
那么这个东西

15:42.650 --> 15:43.650
转换的数字是多少

15:43.650 --> 15:45.650
我说过的布尔转数字

15:45.650 --> 15:46.650
是不是1

15:46.650 --> 15:47.650
2是不是大于1

15:47.650 --> 15:48.650
对吧

15:48.650 --> 15:50.650
比较的结果是去

15:51.650 --> 15:52.650
没问题吧

15:52.650 --> 15:53.650
好 再来看

15:53.650 --> 15:55.650
这里还有一个规则

15:55.650 --> 15:57.650
还有规则

15:57.650 --> 15:59.650
就是NAN

15:59.650 --> 16:01.650
NAN

16:01.650 --> 16:02.650
与

16:02.650 --> 16:04.650
任何

16:04.650 --> 16:06.650
数字比较

16:06.650 --> 16:08.650
与任何数字比较

16:08.650 --> 16:10.650
得到的结果

16:10.650 --> 16:12.650
都是NAN

16:13.650 --> 16:15.650
得到的结果都是NAN

16:15.650 --> 16:16.650
不

16:16.650 --> 16:17.650
得到的结果都是Force

16:17.650 --> 16:18.650
怎么是NAN呢

16:18.650 --> 16:20.650
得到的结果都是Force

16:20.650 --> 16:22.650
就是NAN不能与任何东西比较

16:22.650 --> 16:23.650
比较 要比较

16:23.650 --> 16:25.650
就给你Force

16:25.650 --> 16:27.650
好 看一下

16:27.650 --> 16:28.650
那么比方说

16:28.650 --> 16:29.650
比方说我们这里

16:29.650 --> 16:31.650
因为NAN是一个特殊的数字

16:31.650 --> 16:32.650
它也是数字吧

16:32.650 --> 16:33.650
对吧 它不需要转换了

16:33.650 --> 16:34.650
它转换结果还是

16:34.650 --> 16:35.650
它本身就是数字

16:35.650 --> 16:37.650
好 是不是大于0呢

16:37.650 --> 16:38.650
我们来看一下

16:38.650 --> 16:41.650
保存Force

16:41.650 --> 16:42.650
我们直接在这里写吧

16:42.650 --> 16:44.650
NAN

16:44.650 --> 16:45.650
是不是等于

16:45.650 --> 16:46.650
是不是小于0呢

16:46.650 --> 16:48.650
Force

16:48.650 --> 16:50.650
NAN

16:50.650 --> 16:52.650
是不是大于

16:52.650 --> 16:54.650
NAN

16:54.650 --> 16:55.650
Force

16:55.650 --> 16:56.650
NAN

16:56.650 --> 16:58.650
是不是小于NAN

16:58.650 --> 16:59.650
Force

16:59.650 --> 17:01.650
它跟什么东西比较都是Force

17:01.650 --> 17:02.650
这是NAN

17:02.650 --> 17:03.650
好 再来看

17:03.650 --> 17:04.650
有几个特殊数字

17:04.650 --> 17:05.650
我说一下主要是

17:05.650 --> 17:07.650
Infinity

17:07.650 --> 17:09.650
表示无穷大

17:09.650 --> 17:11.650
无穷大

17:11.650 --> 17:14.650
比与任何其他数字比较

17:14.650 --> 17:15.650
就是应该这样说

17:15.650 --> 17:19.650
无穷大比任何数字都大

17:19.650 --> 17:20.650
都大

17:20.650 --> 17:22.650
好 看一下吧

17:22.650 --> 17:24.650
Infinity

17:24.650 --> 17:25.650
Infinity

17:25.650 --> 17:27.650
大于0呢

17:27.650 --> 17:28.650
True

17:28.650 --> 17:30.650
大于10万呢

17:30.650 --> 17:31.650
True

17:31.650 --> 17:32.650
无穷大

17:32.650 --> 17:34.650
肯定比任何数字都大

17:34.650 --> 17:35.650
那么同样的

17:35.650 --> 17:36.650
负无穷大

17:36.650 --> 17:39.650
负的Infinity

17:39.650 --> 17:40.650
Infinity

17:41.650 --> 17:45.650
是不是比任何数字都小

17:45.650 --> 17:46.650
对吧

17:46.650 --> 17:48.650
肯定比任何数字都小

17:48.650 --> 17:49.650
看一下

17:49.650 --> 17:51.650
负的Infinity

17:51.650 --> 17:52.650
负的Infinity

17:52.650 --> 17:53.650
是不是小于0呢

17:53.650 --> 17:54.650
True

17:54.650 --> 17:55.650
负的Infinity

17:55.650 --> 17:56.650
是不是小于1万呢

17:56.650 --> 17:57.650
True

17:57.650 --> 17:58.650
是不是小于负的10万呢

17:58.650 --> 17:59.650
True

17:59.650 --> 18:00.650
很好理解吧

18:00.650 --> 18:01.650
没问题吧

18:01.650 --> 18:03.650
它是负无穷嘛

18:03.650 --> 18:04.650
好 那么结过来了

18:04.650 --> 18:06.650
有意思来了

18:06.650 --> 18:08.650
这个无穷数字

18:08.650 --> 18:10.650
跟NAN比较呢

18:10.650 --> 18:12.650
一样的

18:12.650 --> 18:13.650
NAN

18:13.650 --> 18:15.650
它都不是一个正常的数字

18:15.650 --> 18:16.650
它没法比较

18:16.650 --> 18:18.650
说怎么比较都是False

18:18.650 --> 18:19.650
咱们来看一下

18:19.650 --> 18:20.650
NAN

18:20.650 --> 18:22.650
是不是小于

18:22.650 --> 18:23.650
Infinity

18:23.650 --> 18:24.650
False

18:24.650 --> 18:26.650
尽管它是负无穷

18:26.650 --> 18:28.650
它都不是数字没法比

18:28.650 --> 18:29.650
就没法比较

18:29.650 --> 18:31.650
所以得到结果一定是False

18:31.650 --> 18:32.650
这是

18:32.650 --> 18:34.650
这个第二个细节

18:34.650 --> 18:35.650
第二个细节

18:35.650 --> 18:37.650
好 两个字不错的比较

18:37.650 --> 18:38.650
说了

18:38.650 --> 18:39.650
然后呢

18:39.650 --> 18:40.650
其中一个不是制服串

18:40.650 --> 18:42.650
但是两个都是原式内形

18:42.650 --> 18:43.650
它们比较大小

18:43.650 --> 18:44.650
也说了

18:44.650 --> 18:46.650
好 第三个

18:46.650 --> 18:48.650
好 第三个还有什么情况呢

18:48.650 --> 18:50.650
其实还有一个情况

18:50.650 --> 18:52.650
就是其中一个不是原式内形

18:52.650 --> 18:54.650
是引用内形

18:54.650 --> 18:55.650
就对象

18:55.650 --> 18:57.650
如果其中

18:57.650 --> 18:59.650
一个是对象

18:59.650 --> 19:01.650
怎么办呢

19:01.650 --> 19:03.650
将对象

19:03.650 --> 19:04.650
转换为

19:04.650 --> 19:06.650
原式内形

19:06.650 --> 19:08.650
然后

19:08.650 --> 19:10.650
按照规则1

19:10.650 --> 19:12.650
或

19:12.650 --> 19:14.650
规则2

19:14.650 --> 19:16.650
进行比较

19:16.650 --> 19:18.650
就是要把一个对象

19:18.650 --> 19:19.650
转换成原式内形

19:19.650 --> 19:21.650
那么转换成原式内形

19:21.650 --> 19:22.650
我们之前也说过

19:22.650 --> 19:24.650
在算是运算负的那一块说过

19:24.650 --> 19:25.650
我当时还说

19:25.650 --> 19:26.650
这一块

19:26.650 --> 19:27.650
目前呢

19:27.650 --> 19:29.650
你们只需要知道

19:29.650 --> 19:30.650
对象转换成原式内形过后

19:30.650 --> 19:32.650
就是一个制服串

19:32.650 --> 19:33.650
应该这样说

19:33.650 --> 19:34.650
目前

19:35.650 --> 19:36.650
目前呢

19:36.650 --> 19:37.650
对象

19:37.650 --> 19:38.650
转换为

19:38.650 --> 19:40.650
原式内形

19:40.650 --> 19:41.650
后

19:41.650 --> 19:42.650
是什么呢

19:42.650 --> 19:43.650
是

19:43.650 --> 19:44.650
制服串

19:44.650 --> 19:45.650
这个东西

19:46.650 --> 19:47.650
不解个词

19:48.650 --> 19:49.650
不解个词

19:49.650 --> 19:50.650
它是这么一个东西

19:50.650 --> 19:51.650
制服串转换成原式内形过后

19:51.650 --> 19:52.650
是一个制服串

19:52.650 --> 19:53.650
这个东西

19:53.650 --> 19:54.650
好 那看一下

19:55.650 --> 19:56.650
比方说

19:57.650 --> 19:58.650
Consult

19:59.650 --> 20:00.650
三

20:00.650 --> 20:01.650
是不是大于

20:01.650 --> 20:02.650
一个对象呢

20:02.650 --> 20:03.650
一个对象呢

20:03.650 --> 20:04.650
三

20:04.650 --> 20:05.650
是不是大于一个对象呢

20:05.650 --> 20:06.650
看一下

20:06.650 --> 20:07.650
这个比较算是的

20:08.650 --> 20:09.650
好 你看

20:09.650 --> 20:10.650
其中一个地方是

20:10.650 --> 20:11.650
是对象了

20:11.650 --> 20:12.650
对象了

20:12.650 --> 20:13.650
对象了

20:13.650 --> 20:14.650
先把它转换成制服串

20:14.650 --> 20:16.650
就把它转换成原式内形

20:16.650 --> 20:18.650
目前的原式内形就是制服串

20:18.650 --> 20:19.650
先把它转换成这个玩意

20:19.650 --> 20:20.650
转换这个玩意过后

20:20.650 --> 20:22.650
再来按照规则1

20:22.650 --> 20:23.650
或者是规则2

20:23.650 --> 20:24.650
那么现在肯定是规则2了

20:24.650 --> 20:25.650
对吧

20:25.650 --> 20:26.650
现在肯定是规则2了

20:26.650 --> 20:27.650
规则2里边是什么

20:27.650 --> 20:29.650
如果其中一个不是制服串

20:29.650 --> 20:30.650
你看它是不是不是制服串

20:30.650 --> 20:32.650
两个都是原式内形了

20:32.650 --> 20:33.650
它不是制服串

20:33.650 --> 20:34.650
那么怎么办

20:34.650 --> 20:36.650
全部转换成数字

20:36.650 --> 20:37.650
它要转换成数字

20:37.650 --> 20:38.650
它转换成数字是什么

20:38.650 --> 20:39.650
n an

20:39.650 --> 20:41.650
所以说结果是

20:41.650 --> 20:42.650
结果是不是force

20:42.650 --> 20:43.650
对吧

20:43.650 --> 20:44.650
就force

20:44.650 --> 20:45.650
看一下

20:45.650 --> 20:47.650
最后一个比较结果

20:47.650 --> 20:48.650
force

20:48.650 --> 20:49.650
这就是

20:49.650 --> 20:51.650
有对象的时候它的转换方式

20:51.650 --> 20:53.650
就用这种方式来转换

20:54.650 --> 20:55.650
ok

20:55.650 --> 20:56.650
好

20:56.650 --> 20:57.650
这是关于这三个

20:57.650 --> 20:58.650
这三个

20:58.650 --> 20:59.650
对了

20:59.650 --> 21:00.650
还有undefend

21:00.650 --> 21:01.650
和now

21:01.650 --> 21:02.650
是不是一样的

21:04.650 --> 21:05.650
now

21:05.650 --> 21:07.650
是不是

21:07.650 --> 21:08.650
大于富一呢

21:08.650 --> 21:09.650
来

21:09.650 --> 21:10.650
说一下这个

21:10.650 --> 21:12.650
这些全是要面试的时候

21:12.650 --> 21:13.650
可能会靠

21:13.650 --> 21:14.650
我们平时哪会写这样的代码呀

21:14.650 --> 21:15.650
我的天啊

21:15.650 --> 21:16.650
这样代码我要封

21:16.650 --> 21:17.650
看着要封

21:18.650 --> 21:19.650
now是不是大于富一呢

21:19.650 --> 21:20.650
来回忆一下

21:20.650 --> 21:22.650
是不是两个原式内形

21:22.650 --> 21:23.650
对吧

21:23.650 --> 21:24.650
原式内形

21:24.650 --> 21:25.650
原式内形咋办

21:25.650 --> 21:26.650
是不是转数字

21:26.650 --> 21:27.650
对吧

21:27.650 --> 21:28.650
它转数字

21:28.650 --> 21:29.650
为多少

21:29.650 --> 21:30.650
now转数字

21:30.650 --> 21:31.650
说过的

21:31.650 --> 21:32.650
0

21:32.650 --> 21:33.650
0

21:33.650 --> 21:34.650
0是大于富一

21:34.650 --> 21:35.650
对吧

21:35.650 --> 21:36.650
大于的

21:36.650 --> 21:37.650
所以说这个结果呢

21:37.650 --> 21:38.650
是2

21:38.650 --> 21:39.650
2

21:39.650 --> 21:40.650
好

21:40.650 --> 21:42.650
那么如果我写的是这样子呢

21:42.650 --> 21:43.650
undefend

21:43.650 --> 21:45.650
是不是大于富一呢

21:45.650 --> 21:47.650
如果我是这样子写的呢

21:47.650 --> 21:48.650
undefend

21:48.650 --> 21:49.650
是不是大于富一

21:49.650 --> 21:50.650
好

21:50.650 --> 21:51.650
那么这个东西转数字

21:51.650 --> 21:52.650
转数为啥

21:52.650 --> 21:54.650
undefend转出来的数字

21:54.650 --> 21:56.650
就是nann

21:56.650 --> 21:57.650
跟任何东西比较

21:57.650 --> 21:58.650
nann

21:58.650 --> 21:59.650
都是force

21:59.650 --> 22:00.650
都是force

22:01.650 --> 22:03.650
这是关于这一块

22:03.650 --> 22:04.650
关于这一块

22:04.650 --> 22:05.650
大小比较这一块

22:05.650 --> 22:06.650
它的一些细节

22:06.650 --> 22:08.650
其实它的基本用法很简单

22:08.650 --> 22:09.650
就是比较两个数字

22:09.650 --> 22:10.650
有可能呢

22:10.650 --> 22:11.650
我们可以

22:11.650 --> 22:13.650
可能是把数字放到变量里边

22:13.650 --> 22:15.650
一个a变量等于5

22:15.650 --> 22:16.650
一个b的变量等于4

22:16.650 --> 22:18.650
我们来比较a和b的大小

22:18.650 --> 22:19.650
当然可以

22:19.650 --> 22:20.650
任何出现

22:20.650 --> 22:21.650
可以出现数据的地方

22:21.650 --> 22:22.650
都可以出现

22:22.650 --> 22:24.650
都可以出现这个变量

22:24.650 --> 22:25.650
没有任何问题

22:25.650 --> 22:26.650
这样比较也没有任何问题

22:26.650 --> 22:27.650
看一下之前的

22:28.650 --> 22:29.650
没有任何问题

22:30.650 --> 22:32.650
这是关于大小比较

22:32.650 --> 22:33.650
很简单

22:34.650 --> 22:35.650
主要是有些细节

22:35.650 --> 22:36.650
细节的话

22:36.650 --> 22:37.650
我建大家不要去背

22:37.650 --> 22:39.650
千万千万不要去背

22:39.650 --> 22:40.650
你不要去伪烂自己

22:40.650 --> 22:41.650
这些东西

22:41.650 --> 22:42.650
我反正背不住

22:42.650 --> 22:44.650
一般在面试之前

22:44.650 --> 22:45.650
你会不会突然复习一下

22:45.650 --> 22:46.650
目前呢

22:46.650 --> 22:47.650
你要有个印象

22:47.650 --> 22:48.650
知道有这么回事

22:48.650 --> 22:50.650
但是你以后忘了过后

22:50.650 --> 22:51.650
你可以回来查一下就行了

22:51.650 --> 22:53.650
千万不要去背

22:53.650 --> 22:54.650
不要去背

22:54.650 --> 22:55.650
这是关于大小比较的细节

22:55.650 --> 22:56.650
好

22:56.650 --> 22:59.150
接下来我们来看

22:59.150 --> 23:00.150
相等比较

23:00.150 --> 23:02.150
这一块我们要说的多一点

23:03.150 --> 23:04.150
相等比较

23:05.150 --> 23:06.150
好

23:06.150 --> 23:07.150
相等比较呢

23:07.150 --> 23:08.150
有两种比较方式

23:08.150 --> 23:09.150
一种是相等

23:09.150 --> 23:11.150
一种是严格相等

23:11.150 --> 23:12.150
好

23:12.150 --> 23:13.150
一种是不相等

23:13.150 --> 23:15.150
一种是严格不相等

23:15.150 --> 23:16.150
严格不相等

23:16.150 --> 23:17.150
我们先来说

23:17.150 --> 23:18.150
第一个

23:22.150 --> 23:23.150
普通

23:23.150 --> 23:25.150
我们把它叫做普通相等比较

23:25.150 --> 23:26.150
有的时候

23:26.150 --> 23:28.150
就直接把它称为相等比较

23:28.150 --> 23:29.150
相等比较

23:29.150 --> 23:30.150
就这个

23:30.150 --> 23:31.150
第一个

23:31.150 --> 23:33.150
就这样子来写吧

23:33.150 --> 23:34.150
就第一个

23:34.150 --> 23:36.150
它叫做相等比较

23:36.150 --> 23:37.150
有的时候

23:37.150 --> 23:38.150
这个词呢

23:38.150 --> 23:39.150
不好说

23:39.150 --> 23:41.150
我们把整个归内

23:41.150 --> 23:43.150
把它归成相等比较

23:43.150 --> 23:44.150
那么这个东西

23:44.150 --> 23:45.150
也叫做相等比较

23:45.150 --> 23:46.150
你懂我说的什么意思就行了

23:46.150 --> 23:47.150
两个等号

23:47.150 --> 23:49.150
把它称为相等比较

23:49.150 --> 23:50.150
把整个归内

23:50.150 --> 23:52.150
也把它归成相等比较

23:52.150 --> 23:53.150
好

23:53.150 --> 23:54.150
第一个

23:54.150 --> 23:56.150
那么它这里边有哪些规则

23:56.150 --> 23:57.150
比较的是什么

23:57.150 --> 23:59.150
通常比较两个数据

23:59.150 --> 24:00.150
是否相等

24:00.150 --> 24:02.150
比较两个数据

24:02.150 --> 24:04.150
是否

24:04.150 --> 24:05.150
相等

24:06.150 --> 24:07.150
相等

24:07.150 --> 24:09.150
相等的话就返回处

24:09.150 --> 24:11.150
不相等的话就返回force

24:11.150 --> 24:12.150
这个很简单

24:12.150 --> 24:13.150
它的基本用法非常非常简单

24:13.150 --> 24:14.150
好

24:14.150 --> 24:15.150
比方说

24:15.150 --> 24:16.150
好

24:16.150 --> 24:17.150
一

24:17.150 --> 24:18.150
是不是等于一呢

24:18.150 --> 24:19.150
一定等于一

24:19.150 --> 24:20.150
对吧

24:20.150 --> 24:21.150
看一下

24:21.150 --> 24:22.150
把其他关了

24:25.490 --> 24:26.490
去对吧

24:26.490 --> 24:27.490
去

24:27.490 --> 24:28.490
非常非常简单

24:28.490 --> 24:29.490
非常非常简单

24:29.490 --> 24:30.490
好

24:30.490 --> 24:31.490
然后我们就一起说吧

24:31.490 --> 24:33.490
相等比较和

24:35.490 --> 24:36.490
不相等比较

24:36.490 --> 24:37.490
不相等比较

24:37.490 --> 24:38.490
一起说吧

24:38.490 --> 24:39.490
因为它是差不多

24:41.490 --> 24:42.490
再看一下

24:42.490 --> 24:44.490
相等和

24:45.490 --> 24:46.490
感叹号

24:46.490 --> 24:47.490
一个等号

24:47.490 --> 24:49.490
这是相等比较和

24:49.490 --> 24:50.490
不相等比较

24:50.490 --> 24:51.490
那么相等

24:51.490 --> 24:52.490
是比较两个数据

24:52.490 --> 24:53.490
是否相等

24:53.490 --> 24:54.490
好

24:54.490 --> 24:55.490
另外一个就是

24:55.490 --> 24:56.490
感叹号等号

24:56.490 --> 24:57.490
这个比较的是什么呢

24:57.490 --> 24:59.490
比较的两个数字

24:59.490 --> 25:00.490
两个数据

25:01.490 --> 25:02.490
两个数据

25:02.490 --> 25:04.490
是否不相等

25:04.490 --> 25:06.490
是否不相等

25:06.490 --> 25:07.490
好比方说

25:07.490 --> 25:08.490
刚才我们看到了

25:08.490 --> 25:09.490
这个

25:09.490 --> 25:10.490
一

25:10.490 --> 25:11.490
是等于一的

25:11.490 --> 25:12.490
好

25:12.490 --> 25:13.490
我们再来写一个

25:13.490 --> 25:14.490
log1

25:14.490 --> 25:16.490
是不是不等于一呢

25:16.490 --> 25:17.490
是不是不等于

25:17.490 --> 25:18.490
是不是

25:18.490 --> 25:19.490
一定等于

25:19.490 --> 25:20.490
对吧

25:20.490 --> 25:21.490
它不是不等于

25:21.490 --> 25:22.490
不是不等于

25:22.490 --> 25:23.490
对吧

25:23.490 --> 25:24.490
是force

25:24.490 --> 25:25.490
你看

25:25.490 --> 25:26.490
第一个是去

25:26.490 --> 25:27.490
第二个是force

25:28.490 --> 25:29.490
没问题吧

25:29.490 --> 25:30.490
这是相等比较

25:30.490 --> 25:31.490
好

25:31.490 --> 25:32.490
相等比较

25:32.490 --> 25:33.490
它本身没啥

25:33.490 --> 25:34.490
没啥问题

25:34.490 --> 25:35.490
比方说

25:35.490 --> 25:36.490
我们比较制服串也可以

25:36.490 --> 25:37.490
比较制服串

25:37.490 --> 25:38.490
abc

25:38.490 --> 25:39.490
是不是等于

25:39.490 --> 25:40.490
abc

25:40.490 --> 25:41.490
它不是一定要比较数字的

25:41.490 --> 25:43.490
比较制服串也可以

25:43.490 --> 25:44.490
那么

25:44.490 --> 25:45.490
abc

25:46.490 --> 25:47.490
空格

25:47.490 --> 25:48.490
加个空格

25:48.490 --> 25:50.490
是不是不等于abc呢

25:50.490 --> 25:51.490
两个都是去

25:51.490 --> 25:52.490
对吧

25:52.490 --> 25:53.490
加了空格

25:53.490 --> 25:54.490
所以说

25:54.490 --> 25:55.490
两个制服串不一样了

25:55.490 --> 25:56.490
不一样了

25:56.490 --> 25:57.490
看一下

25:57.490 --> 25:58.490
两个都是去

25:59.490 --> 26:00.490
这个东西

26:00.490 --> 26:01.490
不等于它

26:01.490 --> 26:02.490
它呢

26:02.490 --> 26:03.490
等它相等

26:03.490 --> 26:04.490
两个都是去

26:04.490 --> 26:05.490
没啥问题

26:05.490 --> 26:06.490
好

26:06.490 --> 26:07.490
关键是细节又来了

26:07.490 --> 26:08.490
细节又来了

26:08.490 --> 26:10.490
就是不同类型又怎么办

26:10.490 --> 26:13.250
好

26:13.250 --> 26:14.250
细节

26:14.250 --> 26:15.250
细节

26:15.250 --> 26:17.250
就是不同类型又怎么办

26:17.250 --> 26:19.250
这里主要说一下细节

26:19.250 --> 26:20.250
我再重测一次

26:20.250 --> 26:22.250
就是咱们这节课

26:22.250 --> 26:23.250
它其实我都快要讲完了

26:23.250 --> 26:24.250
对吧

26:24.250 --> 26:26.250
再讲个严格相等就讲完了

26:26.250 --> 26:27.250
它没什么好说的

26:27.250 --> 26:28.250
但是呢

26:28.250 --> 26:29.250
主要是它细节比较多

26:29.250 --> 26:31.250
细节在这里的容易出面是提

26:31.250 --> 26:32.250
好

26:32.250 --> 26:33.250
我们来看一下细节

26:33.250 --> 26:34.250
好

26:34.250 --> 26:35.250
首先第一点

26:35.250 --> 26:36.250
就是

26:36.250 --> 26:38.250
两端的类型

26:38.250 --> 26:41.250
两端的类型相同

26:41.250 --> 26:42.250
左右两边

26:42.250 --> 26:43.250
比较的类型是一样的

26:43.250 --> 26:44.250
就像这种情况

26:44.250 --> 26:45.250
制服串呢

26:45.250 --> 26:46.250
跟制服串比较

26:46.250 --> 26:48.250
数字跟数字比较

26:48.250 --> 26:50.250
这才是我们希望看到的

26:50.250 --> 26:52.250
这一般才是我们希望看到的

26:52.250 --> 26:53.250
好

26:53.250 --> 26:54.250
这种情况呢

26:54.250 --> 26:55.250
直接比较

26:55.250 --> 26:56.250
直接比较

26:56.250 --> 26:58.250
两个数据

26:58.250 --> 27:01.250
本身是否相同

27:01.250 --> 27:02.250
相同

27:02.250 --> 27:03.250
那么这里有个细节

27:03.250 --> 27:04.250
刚才已经说了

27:04.250 --> 27:05.250
其实我这里

27:05.250 --> 27:06.250
刚才就已经说了

27:06.250 --> 27:07.250
就是比较的时候

27:07.250 --> 27:08.250
觉得例子呢

27:08.250 --> 27:09.250
就是两个类型是一样的

27:09.250 --> 27:10.250
但是呢

27:10.250 --> 27:11.250
这里有个细节

27:11.250 --> 27:12.250
大家注意一下

27:12.250 --> 27:13.250
就是

27:13.250 --> 27:15.250
两个对象

27:15.250 --> 27:17.250
比较的是

27:17.250 --> 27:18.250
地址

27:18.250 --> 27:19.250
因为我们知道

27:19.250 --> 27:21.250
里面存放的是对象的地址

27:21.250 --> 27:22.250
如果两边

27:22.250 --> 27:23.250
两端是对象的话

27:23.250 --> 27:24.250
它比较的是对象的地址

27:24.250 --> 27:25.250
是不是一样的

27:25.250 --> 27:26.250
我们之前说过对吧

27:26.250 --> 27:27.250
引用类型

27:27.250 --> 27:28.250
它里面存的都是地址

27:28.250 --> 27:29.250
你要比较的地址

27:29.250 --> 27:30.250
是不是一样

27:30.250 --> 27:32.250
而不是对象的内容

27:32.250 --> 27:33.250
比方说

27:33.250 --> 27:34.250
那么这里呢

27:34.250 --> 27:35.250
比方说

27:35.250 --> 27:37.250
我们这里写一个

27:37.250 --> 27:38.250
A

27:38.250 --> 27:39.250
等于一个对象

27:39.250 --> 27:40.250
一个空对象

27:40.250 --> 27:41.250
啥都没有

27:41.250 --> 27:42.250
B也是一个空对象

27:42.250 --> 27:43.250
啥都没有

27:43.250 --> 27:44.250
那么我们这里比较

27:44.250 --> 27:45.250
比较啥呢

27:45.250 --> 27:46.250
比较A

27:46.250 --> 27:47.250
是不等于B

27:47.250 --> 27:48.250
比较的是啥呢

27:48.250 --> 27:49.250
比较的是A

27:49.250 --> 27:50.250
里面存放的地址

27:50.250 --> 27:51.250
和B

27:51.250 --> 27:52.250
里面存放的地址

27:52.250 --> 27:53.250
是不是一样的

27:53.250 --> 27:54.250
他们的地址

27:54.250 --> 27:55.250
是不是一样的

27:55.250 --> 27:56.250
你别告诉我

27:56.250 --> 27:57.250
他们的地址是一样的

27:57.250 --> 27:58.250
他们的地址

27:58.250 --> 27:59.250
肯定是不一样的

27:59.250 --> 28:01.250
这是两个对象

28:01.250 --> 28:03.250
开辟了两个空间

28:03.250 --> 28:04.250
把新建个对象

28:04.250 --> 28:05.250
把它的地址

28:05.250 --> 28:06.250
存到A

28:06.250 --> 28:07.250
里面

28:07.250 --> 28:08.250
再新建个对象

28:08.250 --> 28:09.250
把它的地址存到B

28:09.250 --> 28:10.250
里面

28:10.250 --> 28:11.250
就是碰巧了

28:11.250 --> 28:12.250
这两个对象

28:12.250 --> 28:13.250
里面的内容是一样的

28:13.250 --> 28:14.250
所以说

28:14.250 --> 28:15.250
这一块比较出来

28:15.250 --> 28:16.250
是Force

28:16.250 --> 28:17.250
看一下

28:17.250 --> 28:18.250
这是两个

28:18.250 --> 28:20.250
同内形的比较

28:20.250 --> 28:21.250
你看Force

28:22.250 --> 28:24.250
这个我顺便说一下

28:24.250 --> 28:25.250
接下来说的是

28:25.250 --> 28:26.250
不同内形

28:26.250 --> 28:27.250
不同内形

28:27.250 --> 28:28.250
那就麻烦了

28:28.250 --> 28:30.250
两端的内形不同

28:30.250 --> 28:32.250
两端的内形不同

28:32.250 --> 28:33.250
我也不知道

28:33.250 --> 28:34.250
面识体

28:34.250 --> 28:35.250
为什么这么喜欢

28:35.250 --> 28:36.250
考测些东西

28:36.250 --> 28:38.250
两端的内形不同

28:38.250 --> 28:39.250
不同的话

28:39.250 --> 28:40.250
要分几种情况

28:40.250 --> 28:41.250
第一个

28:41.250 --> 28:42.250
一个个说

28:42.250 --> 28:44.250
第一个

28:44.250 --> 28:45.250
第一种情况

28:45.250 --> 28:46.250
是两端

28:46.250 --> 28:49.250
鸭

28:49.250 --> 28:51.250
和鸭滴饭

28:51.250 --> 28:52.250
鸭滴饭

28:52.250 --> 28:54.250
这两个比较特殊的内形

28:54.250 --> 28:55.250
这两个比较特殊的内形

28:55.250 --> 28:57.250
用相等运算幅的时候

28:57.250 --> 28:59.250
它规则又不太一样了

28:59.250 --> 29:00.250
以前是直接转成数字

29:00.250 --> 29:01.250
对吧

29:01.250 --> 29:03.250
现在又不太一样了

29:03.250 --> 29:04.250
鸭和鸭滴饭

29:04.250 --> 29:07.250
它们之间相等

29:07.250 --> 29:08.250
它们之间比较的时候

29:08.250 --> 29:09.250
是相等的

29:09.250 --> 29:12.250
但和其他内形

29:12.250 --> 29:14.250
比较不相等

29:14.250 --> 29:16.250
和其他原式内形

29:16.250 --> 29:19.250
原式内形比较

29:19.250 --> 29:23.820
则不相等

29:23.820 --> 29:24.820
则不相等

29:24.820 --> 29:25.820
比方说

29:25.820 --> 29:26.820
比方说

29:26.820 --> 29:27.820
咱们继续

29:27.820 --> 29:28.820
在这里

29:28.820 --> 29:30.820
console log

29:30.820 --> 29:31.820
now

29:31.820 --> 29:32.820
now

29:32.820 --> 29:34.820
是不是等于undefend

29:34.820 --> 29:35.820
是不是等于呢

29:35.820 --> 29:36.820
ok 是等于的

29:36.820 --> 29:37.820
它居然是等于的

29:37.820 --> 29:38.820
to

29:38.820 --> 29:39.820
看一下

29:39.820 --> 29:40.820
你看

29:40.820 --> 29:41.820
输出的结果是to

29:41.820 --> 29:43.820
它们两个是相等的

29:43.820 --> 29:44.820
那么我们再来

29:44.820 --> 29:45.820
比方说now

29:45.820 --> 29:46.820
不相等是一样的

29:46.820 --> 29:47.820
不等是一样的

29:47.820 --> 29:48.820
不等的话

29:48.820 --> 29:49.820
相当于是啥呢

29:49.820 --> 29:50.820
相当于就是把

29:50.820 --> 29:52.820
相等的比较结果取反

29:52.820 --> 29:54.820
相等比较出来是to

29:54.820 --> 29:56.820
不相等的比较出来就是force

29:56.820 --> 29:58.820
相等比较出来是force

29:58.820 --> 29:59.820
不相等的比较出来就是to

29:59.820 --> 30:00.820
是相反的

30:00.820 --> 30:02.820
其实规则是一样的

30:02.820 --> 30:03.820
force

30:03.820 --> 30:04.820
你看

30:04.820 --> 30:05.820
对了

30:05.820 --> 30:06.820
force

30:06.820 --> 30:07.820
两个是相等的

30:07.820 --> 30:08.820
所以说你用不相等的话

30:08.820 --> 30:10.820
比较出来是force

30:10.820 --> 30:11.820
force

30:11.820 --> 30:12.820
好

30:12.820 --> 30:13.820
再来

30:13.820 --> 30:15.820
然后我们看一下

30:15.820 --> 30:18.820
now跟数字一来比较

30:18.820 --> 30:19.820
数字零来比较

30:19.820 --> 30:20.820
按照以前的说法

30:20.820 --> 30:22.820
比方比较大小的时候

30:22.820 --> 30:23.820
比较大小的时候

30:23.820 --> 30:25.820
now跟零来比较

30:25.820 --> 30:27.820
now会把它转换成零

30:27.820 --> 30:28.820
然后再跟零来比较

30:28.820 --> 30:30.820
所以说以前的结果

30:30.820 --> 30:31.820
比方说这里

30:31.820 --> 30:32.820
now是不是大于零

30:32.820 --> 30:34.820
肯定是不是大于零

30:34.820 --> 30:35.820
不是大于零

30:35.820 --> 30:36.820
看没有force

30:36.820 --> 30:38.820
now是不是大于等于零呢

30:38.820 --> 30:39.820
是to

30:39.820 --> 30:40.820
对吧

30:40.820 --> 30:41.820
是to

30:42.820 --> 30:44.820
但是神奇的事情是什么呢

30:44.820 --> 30:45.820
神奇的事情是

30:45.820 --> 30:47.820
now是不是等于零呢

30:47.820 --> 30:49.820
看一下force

30:49.820 --> 30:51.820
还有这就是非常非常恶心的地方

30:51.820 --> 30:52.820
对吧

30:52.820 --> 30:54.820
非常违反直觉

30:54.820 --> 30:55.820
非常违反直觉

30:55.820 --> 30:56.820
因为为啥呢

30:56.820 --> 30:57.820
有这么一套规则

30:57.820 --> 31:00.820
就是他们在用相等比较的时候

31:00.820 --> 31:02.820
跟其他原式那一种比较

31:02.820 --> 31:04.820
它怎么比较都不相等

31:04.820 --> 31:05.820
怎么比较都不相等

31:05.820 --> 31:06.820
我记得有个学生

31:06.820 --> 31:08.820
有个同学他问过我这个问题

31:08.820 --> 31:10.820
就在面试题的时候遇到了

31:10.820 --> 31:12.820
就他觉得下来觉得很奇怪

31:12.820 --> 31:14.820
now为什么是大于等于零的

31:14.820 --> 31:15.820
但是他

31:15.820 --> 31:17.820
大于零他是force

31:17.820 --> 31:18.820
说明他不大于零对吧

31:18.820 --> 31:20.820
那么大于等于零是to

31:20.820 --> 31:22.820
那么说明这个now是等于零的

31:22.820 --> 31:23.820
但是

31:23.820 --> 31:25.820
跟零相等比较的时候又是force

31:25.820 --> 31:26.820
就感觉很奇怪

31:26.820 --> 31:28.820
他就是这种神奇的规则

31:28.820 --> 31:29.820
那怎么办呢

31:29.820 --> 31:30.820
你只能把它记住

31:30.820 --> 31:32.820
但是不要去使尽应备

31:32.820 --> 31:34.820
我们有这么个印象就行了

31:34.820 --> 31:36.820
以后面试之前再回来查

31:36.820 --> 31:37.820
不用去使尽应备

31:37.820 --> 31:38.820
这个是force

31:38.820 --> 31:40.820
因为跟now跟任何的

31:40.820 --> 31:42.820
任何的原始类型比较都是

31:42.820 --> 31:43.820
都是啥呢

31:43.820 --> 31:44.820
都是force

31:44.820 --> 31:47.820
undefend跟你那比较

31:47.820 --> 31:48.820
也是force

31:48.820 --> 31:50.820
毫无疑问的都是一样的

31:50.820 --> 31:51.820
看一下

31:51.820 --> 31:52.820
很违反直觉

31:52.820 --> 31:53.820
说吧

31:53.820 --> 31:54.820
对吧

31:54.820 --> 31:55.820
很违反直觉

31:55.820 --> 31:57.820
这是关于now和undefend

31:57.820 --> 31:59.820
这两个比较特殊的地方

31:59.820 --> 32:00.820
接下来

32:00.820 --> 32:02.820
我们就把now和undefend除开

32:02.820 --> 32:03.820
除开

32:03.820 --> 32:05.820
其他原始类型

32:05.820 --> 32:07.820
就什么布尔

32:07.820 --> 32:08.820
什么数字

32:08.820 --> 32:09.820
制布串

32:09.820 --> 32:10.820
这种

32:10.820 --> 32:12.820
其他原始类型

32:12.820 --> 32:13.820
但大前提

32:13.820 --> 32:15.820
大前提是两端的类型不一样

32:15.820 --> 32:18.820
其他原始类型

32:18.820 --> 32:20.820
其他原始类型

32:20.820 --> 32:23.820
比较时

32:23.820 --> 32:25.820
先转换为数字

32:25.820 --> 32:27.820
再进行比较

32:27.820 --> 32:29.820
再进行比较

32:29.820 --> 32:30.820
看一下

32:30.820 --> 32:32.820
先转换的数字再进行比较

32:32.820 --> 32:33.820
比方说

32:33.820 --> 32:35.820
我们这里说出

32:35.820 --> 32:37.820
制布串

32:37.820 --> 32:38.820
1

32:38.820 --> 32:39.820
是不是等于

32:39.820 --> 32:40.820
1

32:40.820 --> 32:41.820
是不是等于

32:41.820 --> 32:43.820
转换

32:43.820 --> 32:45.820
两端的类型不一样

32:45.820 --> 32:46.820
都是原始类型

32:46.820 --> 32:48.820
又不为now和undefend

32:48.820 --> 32:50.820
那么就是这个条件了

32:50.820 --> 32:52.820
两端的类型不同

32:52.820 --> 32:54.820
这个条件

32:54.820 --> 32:55.820
其他原始类型

32:55.820 --> 32:56.820
两端的类型不一样

32:56.820 --> 32:58.820
并且又不是now和undefend

32:58.820 --> 33:00.820
就是其他原始类型

33:00.820 --> 33:01.820
比较的时候

33:01.820 --> 33:02.820
先转换成数字

33:02.820 --> 33:03.820
那么这个东西

33:03.820 --> 33:04.820
转换成数字

33:04.820 --> 33:05.820
然后再进行比较

33:05.820 --> 33:06.820
是不是相等的

33:06.820 --> 33:08.820
那么这个东西是相等的

33:08.820 --> 33:10.820
其实这个东西也比较违反直觉

33:10.820 --> 33:12.820
也比较违反直觉

33:12.820 --> 33:13.820
看一下

33:13.820 --> 33:14.820
没有问题吧

33:14.820 --> 33:15.820
好 再来

33:15.820 --> 33:16.820
再来

33:16.820 --> 33:17.820
console log

33:17.820 --> 33:18.820
2

33:18.820 --> 33:20.820
是不是等于1呢

33:20.820 --> 33:22.820
那么这个是个布尔

33:22.820 --> 33:23.820
布尔转换成数字

33:23.820 --> 33:24.820
2就转换成1

33:24.820 --> 33:26.820
1跟1是相等的

33:26.820 --> 33:27.820
所以说是2

33:27.820 --> 33:29.820
保存看一下

33:29.820 --> 33:31.820
2

33:31.820 --> 33:33.820
好 再来

33:33.820 --> 33:35.820
然后

33:35.820 --> 33:38.820
2是不是等于2呢

33:38.820 --> 33:39.820
是不是还是

33:39.820 --> 33:41.820
应该是force

33:41.820 --> 33:43.820
看一下

33:43.820 --> 33:44.820
force

33:44.820 --> 33:46.820
因为初转换的结果是1

33:46.820 --> 33:48.820
应该这个意思吧

33:48.820 --> 33:49.820
OK

33:49.820 --> 33:51.820
这次关于这一块

33:51.820 --> 33:52.820
关于这一块

33:52.820 --> 33:53.820
就很神奇

33:53.820 --> 33:55.820
我们再来一个

33:55.820 --> 33:57.820
console.log

33:57.820 --> 33:58.820
2是不是等于

33:58.820 --> 33:59.820
制服创意呢

33:59.820 --> 34:01.820
是不是等于制服创意

34:01.820 --> 34:02.820
结果是啥

34:02.820 --> 34:04.820
都转换成数字

34:04.820 --> 34:05.820
两种的内情不一样

34:05.820 --> 34:06.820
又不是undefined

34:06.820 --> 34:07.820
又不是now

34:07.820 --> 34:09.820
转换成数字

34:09.820 --> 34:10.820
q转换成数字是啥

34:10.820 --> 34:12.820
q转换成数字是1

34:12.820 --> 34:14.820
这个制服创意的数字是1

34:14.820 --> 34:16.820
所以后来结果是q

34:16.820 --> 34:18.820
就是很违反直觉

34:18.820 --> 34:19.820
本来是不能比较的

34:19.820 --> 34:20.820
本来是不能比较的

34:20.820 --> 34:22.820
所以结果是q

34:22.820 --> 34:24.820
好 再来

34:24.820 --> 34:25.820
那么数字里边

34:25.820 --> 34:27.820
有些特殊的数字

34:27.820 --> 34:29.820
特殊的数字

34:29.820 --> 34:30.820
NAN

34:30.820 --> 34:31.820
对吧

34:31.820 --> 34:32.820
NAN

34:32.820 --> 34:34.820
与任何数字

34:34.820 --> 34:36.820
与任何数字比较

34:36.820 --> 34:37.820
都是force

34:37.820 --> 34:39.820
包括自身

34:39.820 --> 34:40.820
包括自身

34:40.820 --> 34:42.820
好 这是NAN

34:42.820 --> 34:43.820
好 咱们来看一下

34:43.820 --> 34:44.820
直接在这里写吧

34:44.820 --> 34:45.820
直接在这里写

34:45.820 --> 34:46.820
NAN

34:46.820 --> 34:48.820
等于1吗

34:48.820 --> 34:49.820
force

34:49.820 --> 34:50.820
NAN

34:50.820 --> 34:51.820
等于0吗

34:51.820 --> 34:52.820
force

34:52.820 --> 34:53.820
NAN

34:53.820 --> 34:55.820
等于NAN吗

34:55.820 --> 34:57.820
force

34:57.820 --> 34:58.820
神奇吗

34:58.820 --> 34:59.820
非常违反直觉

34:59.820 --> 35:00.820
非常违反直觉

35:00.820 --> 35:02.820
这是关于NAN

35:02.820 --> 35:04.820
数字这一块比较

35:04.820 --> 35:05.820
好

35:05.820 --> 35:07.820
另外就是

35:07.820 --> 35:09.820
无限

35:09.820 --> 35:10.820
infinity

35:10.820 --> 35:12.820
infinity

35:12.820 --> 35:14.820
和

35:14.820 --> 35:17.820
force的infinity

35:17.820 --> 35:19.820
这两个数字

35:19.820 --> 35:22.820
只能和自身相等

35:22.820 --> 35:24.820
只能和自身相等

35:24.820 --> 35:25.820
其他的都不等

35:25.820 --> 35:26.820
其他都不等

35:26.820 --> 35:28.820
这个不符合

35:28.820 --> 35:30.820
这个没有超出直觉

35:30.820 --> 35:32.820
这是满足直觉的

35:32.820 --> 35:34.820
无限大只能跟无限大比较

35:34.820 --> 35:35.820
相等

35:35.820 --> 35:36.820
负的无限大

35:36.820 --> 35:37.820
只能跟负的无限大比较

35:37.820 --> 35:38.820
相等

35:38.820 --> 35:39.820
其他都不相等

35:39.820 --> 35:40.820
比方说

35:40.820 --> 35:41.820
无限大

35:41.820 --> 35:43.820
你跟任何数字比较都不行

35:43.820 --> 35:44.820
跟任何数字比较都不行

35:44.820 --> 35:45.820
都是force

35:45.820 --> 35:46.820
而你只能跟

35:46.820 --> 35:47.820
谁相等呢

35:47.820 --> 35:48.820
只能是跟自己相等

35:48.820 --> 35:49.820
看不

35:49.820 --> 35:51.820
无限大和无限大比较为q

35:52.820 --> 35:54.820
接下来再看

35:54.820 --> 35:55.820
还有一个就是对象

35:55.820 --> 35:56.820
引用内形

35:56.820 --> 35:57.820
引用内形

35:57.820 --> 35:59.820
引用内形

35:59.820 --> 36:00.820
就是对象

36:00.820 --> 36:01.820
我们就说对象

36:01.820 --> 36:03.820
因为我们现在引用内形只学了对象

36:03.820 --> 36:05.820
其他的引用内形其实也是一样的

36:05.820 --> 36:08.820
对象比较是

36:08.820 --> 36:11.820
要先转换为

36:11.820 --> 36:13.820
原始内形

36:13.820 --> 36:14.820
那么转换成什么原始内形

36:14.820 --> 36:15.820
我们之前是不是说过的

36:15.820 --> 36:17.820
对象转原始内形

36:17.820 --> 36:18.820
是不是转成这个

36:18.820 --> 36:19.820
对吧

36:19.820 --> 36:20.820
目前我们学的对象

36:20.820 --> 36:21.820
转换成原始内形

36:21.820 --> 36:22.820
都是转换成这个玩意

36:22.820 --> 36:24.820
然后再进行比较

36:24.820 --> 36:26.820
对象转换成原始内形

36:26.820 --> 36:30.820
后再进行比较

36:30.820 --> 36:32.820
再进行比较

36:32.820 --> 36:33.820
那么这里

36:33.820 --> 36:34.820
当然如果是两个对象

36:34.820 --> 36:35.820
又不一样了

36:35.820 --> 36:36.820
两个对象就是

36:36.820 --> 36:37.820
两端内形相同

36:37.820 --> 36:39.820
那就直接比较地址

36:39.820 --> 36:40.820
我说的是

36:40.820 --> 36:41.820
两端内形不一样

36:41.820 --> 36:42.820
就是其中一端

36:42.820 --> 36:43.820
是原始内形

36:43.820 --> 36:44.820
一端是对象

36:44.820 --> 36:45.820
是这种情况

36:45.820 --> 36:46.820
一端是原始内形

36:46.820 --> 36:47.820
一端是对象

36:48.820 --> 36:49.820
咱们来看一下

36:50.820 --> 36:51.820
console log

36:51.820 --> 36:53.820
一个空的对象

36:54.820 --> 36:55.820
一个空的对象

36:55.820 --> 36:56.820
跟零来比较

36:56.820 --> 36:57.820
是啥呢

36:57.820 --> 36:58.820
你觉得是啥

36:59.820 --> 37:00.820
先把对象

37:00.820 --> 37:01.820
转换成原始内形

37:01.820 --> 37:03.820
原始内形是啥

37:03.820 --> 37:05.820
原始内形是啥

37:05.820 --> 37:06.820
是不是一个制服串

37:06.820 --> 37:07.820
就这个玩意

37:07.820 --> 37:08.820
这个玩意

37:08.820 --> 37:09.820
制服串

37:09.820 --> 37:10.820
那么这个制服串

37:11.820 --> 37:12.820
然后跟数字进行比较

37:12.820 --> 37:13.820
那是不是

37:13.820 --> 37:15.820
要把他又转换的数字

37:15.820 --> 37:16.820
他转换的数字是不是NAN

37:17.820 --> 37:19.820
NAN跟零比较

37:19.820 --> 37:20.820
肯定是force

37:20.820 --> 37:21.820
肯定是force

37:21.820 --> 37:23.820
那么这里比较出来的结果就是force

37:24.820 --> 37:25.820
看一下

37:25.820 --> 37:27.820
force

37:27.820 --> 37:30.820
这就是他比较的方式

37:30.820 --> 37:31.820
比较的方式

37:31.820 --> 37:33.820
这是相等比较

37:33.820 --> 37:34.820
和不相等比较

37:34.820 --> 37:35.820
都是指的是

37:35.820 --> 37:37.820
都是有这些规则

37:37.820 --> 37:38.820
规则都是一样的

37:39.820 --> 37:41.820
咱们再来看另外一种相等比较

37:42.820 --> 37:43.820
我这里先说一句

37:44.820 --> 37:46.820
由于

37:46.820 --> 37:51.820
由于相等比较

37:51.820 --> 37:52.820
和不相等比较

37:54.820 --> 37:55.820
比较

37:56.820 --> 37:58.820
对于不同内形的数据

38:00.820 --> 38:01.820
的数据

38:02.820 --> 38:04.820
比较违反直觉

38:04.820 --> 38:06.820
比较违反直觉

38:06.820 --> 38:07.820
因此

38:07.820 --> 38:08.820
通常

38:10.820 --> 38:12.820
我们不使用

38:13.820 --> 38:14.820
我们不使用

38:14.820 --> 38:16.820
这种比较方式

38:17.820 --> 38:19.820
而是使用

38:19.820 --> 38:20.820
更加

38:22.820 --> 38:23.820
更加

38:23.820 --> 38:24.820
接近

38:25.820 --> 38:26.820
直觉的

38:28.820 --> 38:29.820
直觉的

38:29.820 --> 38:30.820
就是

38:30.820 --> 38:31.820
严格

38:31.820 --> 38:32.820
相等

38:32.820 --> 38:33.820
和

38:33.820 --> 38:34.820
严格

38:34.820 --> 38:35.820
不相等

38:37.820 --> 38:38.820
比较

38:38.820 --> 38:39.820
就是我们下面要讲的

38:39.820 --> 38:40.820
因为这种相等比较

38:40.820 --> 38:41.820
和不相等比较

38:41.820 --> 38:42.820
比较违反直觉

38:42.820 --> 38:43.820
它是可以比较

38:43.820 --> 38:44.820
两个不同的内形的

38:45.820 --> 38:46.820
不同的内形要转来转去

38:46.820 --> 38:47.820
就感觉很奇怪

38:48.820 --> 38:49.820
这些比较都可以比较

38:49.820 --> 38:50.820
就觉得很奇怪

38:50.820 --> 38:51.820
所以说

38:51.820 --> 38:52.820
我们更加会使用

38:53.820 --> 38:54.820
用严格相等

38:54.820 --> 38:55.820
和严格不相等来比较

38:55.820 --> 38:57.820
所以我下面我要说的是

38:57.820 --> 38:58.820
严格相等

38:58.820 --> 38:59.820
和严格不相等

39:00.820 --> 39:01.820
就是三个等号

39:01.820 --> 39:02.820
表示严格相等

39:03.820 --> 39:04.820
和

39:04.820 --> 39:05.820
感碳

39:05.820 --> 39:06.820
两个等号

39:06.820 --> 39:08.820
这个表示严格不相等

39:08.820 --> 39:09.820
这是严格

39:09.820 --> 39:10.820
相等

39:11.820 --> 39:12.820
和

39:12.820 --> 39:13.820
严格

39:13.820 --> 39:14.820
不相等

39:16.820 --> 39:17.820
这是怎么比较的呢

39:18.820 --> 39:19.820
一个说

39:19.820 --> 39:20.820
严格相等

39:22.820 --> 39:23.820
严格相等

39:23.820 --> 39:24.820
它比较的是

39:24.820 --> 39:26.820
两端的数据

39:28.820 --> 39:29.820
和内形

39:29.820 --> 39:30.820
必须相同

39:32.820 --> 39:33.820
才会出

39:33.820 --> 39:35.820
两端的数据和内形

39:35.820 --> 39:36.820
必须要相同

39:36.820 --> 39:37.820
才会出

39:38.820 --> 39:39.820
不相等

39:39.820 --> 39:41.820
就是跟严格相等相反的情况

39:41.820 --> 39:42.820
对吧

39:42.820 --> 39:43.820
就是相反的情况了

39:43.820 --> 39:45.820
就是两端的

39:45.820 --> 39:47.820
两端的数据

39:48.820 --> 39:49.820
和内形

39:51.820 --> 39:54.700
不相同

39:54.700 --> 39:55.700
好

39:55.700 --> 39:56.700
咱们来看一下

39:57.700 --> 39:58.700
这里

40:01.460 --> 40:02.460
这里

40:02.460 --> 40:03.460
console

40:03.460 --> 40:04.460
log

40:04.460 --> 40:05.460
比方说

40:05.460 --> 40:07.460
一和处比较

40:07.460 --> 40:08.460
现在我们用三个等号

40:09.460 --> 40:10.460
那肯定是force

40:10.460 --> 40:11.460
肯定是force

40:11.460 --> 40:12.460
因为内形不一样

40:12.460 --> 40:13.460
内形不一样

40:13.460 --> 40:14.460
想都不用想

40:14.460 --> 40:16.460
一定不相同

40:16.460 --> 40:17.460
它的结果一定是force

40:17.460 --> 40:19.460
所以一下就解决所有问题了

40:19.460 --> 40:21.460
也比较符合直觉

40:21.460 --> 40:22.460
两个内形都不一样

40:22.460 --> 40:23.460
怎么比较呢

40:23.460 --> 40:24.460
force

40:24.460 --> 40:25.460
一定是force

40:25.460 --> 40:26.460
那么如果是两个等号就不一样了

40:26.460 --> 40:28.460
两个等号是相等比较

40:28.460 --> 40:29.460
它要转换的

40:29.460 --> 40:30.460
就很奇怪转换出来

40:30.460 --> 40:31.460
就是去

40:32.460 --> 40:33.460
用三个等号

40:33.460 --> 40:34.460
更加符合直觉

40:34.460 --> 40:35.460
三个等号

40:35.460 --> 40:36.460
其实它规则非常简单

40:37.460 --> 40:38.460
换个其他

40:39.460 --> 40:40.460
这里我来说一下吧

40:41.460 --> 40:43.460
三个等号的规则其实很简单

40:43.460 --> 40:44.460
第一个就是

40:44.460 --> 40:45.460
两端内形相同

40:45.460 --> 40:47.460
两端内形相同

40:48.460 --> 40:50.460
那么规则和什么

40:50.460 --> 40:54.460
和两端内形相同

40:54.460 --> 40:55.460
应该这样说

40:55.460 --> 40:59.460
规则和相等比较一致

40:59.460 --> 41:01.460
跟上面的规则是一样的

41:01.460 --> 41:02.460
比较数据是不是一样的

41:02.460 --> 41:04.460
如果是对象的话

41:04.460 --> 41:05.460
比较的是地址

41:05.460 --> 41:06.460
这个就没什么好说的了

41:06.460 --> 41:07.460
如果两端的内形相同

41:07.460 --> 41:09.460
规则跟它一样

41:09.460 --> 41:10.460
第二个就是

41:10.460 --> 41:13.460
两端内形不同

41:13.460 --> 41:15.460
两端内形不同

41:15.460 --> 41:17.460
为Force

41:17.460 --> 41:19.460
就不用纠结了

41:19.460 --> 41:21.460
它规则非常简单

41:21.460 --> 41:22.460
比方说

41:22.460 --> 41:24.460
比方说比较的是

41:24.460 --> 41:25.460
两端内形不同

41:25.460 --> 41:26.460
一个是对象

41:26.460 --> 41:28.460
一个是对象

41:28.460 --> 41:30.460
另外一个是一个数字

41:30.460 --> 41:31.460
那肯定是

41:31.460 --> 41:32.460
写错了

41:32.460 --> 41:33.460
另外一个是数字

41:33.460 --> 41:35.460
那肯定是Force

41:35.460 --> 41:36.460
把它扩起来

41:36.460 --> 41:38.460
这个表达是要扩起来

41:38.460 --> 41:39.460
它认为

41:39.460 --> 41:40.460
我之前说过这个问题的

41:40.460 --> 41:41.460
它认为

41:41.460 --> 41:43.460
这是个代码块

41:43.460 --> 41:44.460
为Force

41:44.460 --> 41:45.460
没问题吧

41:45.460 --> 41:46.460
那么一端

41:46.460 --> 41:47.460
一个字不串

41:47.460 --> 41:48.460
一

41:48.460 --> 41:49.460
另一端

41:49.460 --> 41:50.460
我一个数字一

41:50.460 --> 41:51.460
那一定是Force

41:51.460 --> 41:52.460
一定是Force

41:52.460 --> 41:53.460
两端内形不一样

41:53.460 --> 41:54.460
直接是Force

41:54.460 --> 41:55.460
我们以后

41:55.460 --> 41:57.460
尽量用严格

41:57.460 --> 41:58.460
严格相等

41:58.460 --> 41:59.460
和严格不相等来比较

41:59.460 --> 42:00.460
这样子

42:00.460 --> 42:02.460
能更加符合直觉一点

42:02.460 --> 42:03.460
那么其实数字

42:03.460 --> 42:04.460
这一块

42:04.460 --> 42:05.460
其实是一样的

42:05.460 --> 42:06.460
比方说两端都是数字

42:06.460 --> 42:07.460
数字这一块

42:07.460 --> 42:08.460
是一样的

42:08.460 --> 42:09.460
我把前面复制过来

42:09.460 --> 42:12.460
数字这一块的规则是一样的

42:12.460 --> 42:14.460
如果两端是数字

42:14.460 --> 42:15.460
就数字规则

42:15.460 --> 42:16.460
规则

42:16.460 --> 42:17.460
是一样的

42:17.460 --> 42:18.460
跟之前是一样的

42:18.460 --> 42:19.460
NAN

42:19.460 --> 42:20.460
跟所有的数字比较

42:20.460 --> 42:21.460
都是NAN

42:21.460 --> 42:22.460
都是Force

42:22.460 --> 42:23.460
Infinity

42:23.460 --> 42:24.460
只能与自身相等

42:24.460 --> 42:25.460
看一下吧

42:25.460 --> 42:26.460
NAN

42:26.460 --> 42:28.460
哪怕你用严格相等

42:28.460 --> 42:29.460
它也是Force

42:29.460 --> 42:30.460
因为他们都是数字

42:30.460 --> 42:31.460
对吧

42:31.460 --> 42:32.460
两个都是数字

42:32.460 --> 42:33.460
两个都是非数字

42:33.460 --> 42:34.460
它是没法比较的

42:34.460 --> 42:35.460
所以它是Force

42:35.460 --> 42:36.460
无穷大和无穷小

42:36.460 --> 42:37.460
只能跟自身比较

42:37.460 --> 42:38.460
维修

42:38.460 --> 42:39.460
就没啥问题了吧

42:39.460 --> 42:40.460
就很简单了

42:40.460 --> 42:41.460
对吧

42:41.460 --> 42:42.460
很简单了

42:42.460 --> 42:44.460
那么这里还有一个地方就是NOW

42:44.460 --> 42:46.460
NOW和undefine

42:46.460 --> 42:48.460
和undefine

42:48.460 --> 42:50.460
这两个内形

42:50.460 --> 42:51.460
是不是一样的

42:51.460 --> 42:52.460
两个内形一样吗

42:52.460 --> 42:53.460
是不是不一样

42:53.460 --> 42:54.460
NOW是一个内形

42:54.460 --> 42:55.460
undefine是一个内形

42:55.460 --> 42:57.460
所以说他们内形是不一样的

42:57.460 --> 42:58.460
内形不一样的话

42:58.460 --> 43:00.460
结果为Force

43:00.460 --> 43:02.460
如果是两个等号的话

43:02.460 --> 43:04.460
如果是两个等号的话

43:04.460 --> 43:05.460
它是相等的

43:05.460 --> 43:06.460
另外吧

43:06.460 --> 43:08.460
总之用严格相等的话

43:08.460 --> 43:09.460
它一定要参考内形

43:09.460 --> 43:10.460
内形不一样

43:10.460 --> 43:11.460
你谈都不要谈

43:11.460 --> 43:13.460
你一定为Force

43:13.460 --> 43:15.460
内形只有一样的情况下

43:15.460 --> 43:16.460
我们比较它的内容

43:16.460 --> 43:17.460
内容是不是一样的

43:17.460 --> 43:19.460
所以说这种比较方式

43:19.460 --> 43:20.460
更加容易

43:20.460 --> 43:22.460
我们更加容易理解程序的

43:22.460 --> 43:23.460
就是判定方式

43:23.460 --> 43:24.460
更加容易理解

43:24.460 --> 43:25.460
它规则很简单

43:25.460 --> 43:26.460
我们以后

43:26.460 --> 43:27.460
比较的时候

43:27.460 --> 43:29.460
尽量用严格相等

43:29.460 --> 43:30.460
和严格不相等

43:30.460 --> 43:31.460
好吧

43:31.460 --> 43:32.460
OK

43:32.460 --> 43:34.460
这是关于比较运算符

43:34.460 --> 43:36.460
其实很简单

43:36.460 --> 43:38.460
记住这么几个点就行了

43:38.460 --> 43:39.460
平时用的话

43:39.460 --> 43:40.460
记住这么两个点

43:40.460 --> 43:42.460
一个是比较运算符的话

43:42.460 --> 43:43.460
它反回的内形是布尔

43:43.460 --> 43:44.460
反回的一定是一个真

43:44.460 --> 43:45.460
或者是假

43:45.460 --> 43:47.460
它不会反回什么数字

43:47.460 --> 43:48.460
反回什么支付错

43:48.460 --> 43:49.460
不可能的

43:49.460 --> 43:50.460
一定是反回的是一个布尔

43:50.460 --> 43:52.460
布尔也反回了有什么用

43:52.460 --> 43:53.460
我们之后

43:53.460 --> 43:54.460
比方说学以后

43:54.460 --> 43:55.460
学到什么判断

43:55.460 --> 43:57.460
循环的时候

43:57.460 --> 43:59.460
布尔都非常非常有用处

43:59.460 --> 44:00.460
好吧

44:00.460 --> 44:02.460
这是关于它的反回内形

44:02.460 --> 44:04.460
因为它的优先级是

44:04.460 --> 44:06.460
低于算数运算符的

44:06.460 --> 44:08.460
有算数运算符会先算

44:08.460 --> 44:09.460
然后再来进行比较

44:09.460 --> 44:10.460
先算出来结果之后

44:10.460 --> 44:12.460
再来进行比较

44:12.460 --> 44:14.460
那么里边的比较细节的话

44:14.460 --> 44:15.460
大家可以去看一下

44:15.460 --> 44:16.460
以后面试的时候

44:16.460 --> 44:18.460
可能会用到

44:18.460 --> 44:19.460
这里

44:19.460 --> 44:20.460
这里应该是

44:20.460 --> 44:21.460
对了

44:21.460 --> 44:22.460
没问题

44:22.460 --> 44:23.460
大小比较好像都比较

44:23.460 --> 44:24.460
好

44:24.460 --> 44:25.460
这是关于比较运算符

44:25.460 --> 44:26.460
又讲完一个了

44:26.460 --> 44:28.460
其实运算符这一个章节

44:28.460 --> 44:30.460
就很愁唱

44:31.460 --> 44:32.460
因为这个章节

44:32.460 --> 44:34.460
平时我们用的话

44:34.460 --> 44:35.460
用的很简单

44:35.460 --> 44:36.460
没有那么复杂

44:36.460 --> 44:37.460
但是它面试的时候

44:37.460 --> 44:39.460
老是去考这些玩意儿

44:39.460 --> 44:40.460
所以说我必须要讲到

44:40.460 --> 44:41.460
必须要讲到

44:41.460 --> 44:42.460
我这个时候不讲的话

44:42.460 --> 44:43.460
我也不知道什么时候

44:43.460 --> 44:45.460
再把它安插进来这个知识

44:45.460 --> 44:47.460
所以说我现在就把讲了吧

44:47.460 --> 44:50.460
大家这些东西先了解

44:50.460 --> 44:51.460
我每一课我都说了

44:51.460 --> 44:52.460
有些东西

44:52.460 --> 44:53.460
那是面试的时候

44:53.460 --> 44:56.460
为了做面试体的时候用的

44:56.460 --> 44:58.460
平时写代码很少用的

44:58.460 --> 45:00.460
因为平时写代码其实用的很简单

45:00.460 --> 45:01.460
但是我们先了解

45:01.460 --> 45:03.460
以后你要毕业的时候

45:03.460 --> 45:04.460
你要去找工作的时候

45:04.460 --> 45:05.460
可以回过头来看一下

45:05.460 --> 45:06.460
好吧

45:06.460 --> 45:07.460
这是关于比较运算符

