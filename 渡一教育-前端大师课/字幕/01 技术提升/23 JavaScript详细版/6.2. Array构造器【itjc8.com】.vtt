WEBVTT

00:00.000 --> 00:15.140
而瑞 而瑞勾招器

00:15.900 --> 00:19.500
我再说一次啊 我实际上是不厌其反的说的一些重要的知识

00:19.760 --> 00:20.780
就关于这个

00:21.280 --> 00:26.920
什么叫静态 什么叫做实力 静态方法 静态成员和实力方法实力成员

00:27.180 --> 00:27.940
举个例子啊

00:28.200 --> 00:34.080
比方说我说这个abc呢 是erid实力方法

00:35.100 --> 00:35.620
什么意思啊

00:36.380 --> 00:37.660
如果我说abc是

00:37.820 --> 00:40.480
erid实力方法 那指的是什么意思呢

00:40.740 --> 00:45.080
指的是啊你要去通过这个勾招器创建一个对象

00:45.600 --> 00:48.660
你要去通过这个勾招器创建一个对象

00:49.700 --> 00:52.240
创建了之后呢 调用这个abc

00:52.500 --> 00:56.100
通过它的对象来去调用这个abc 这叫实力方法

00:56.600 --> 01:00.440
如果我说这个abc呢 是erid静态方法

01:01.220 --> 01:05.060
指的是什么意思呢 指的这个abc呢 是直接通过这个勾招器

01:06.040 --> 01:08.080
直接调用的 直接调用的

01:08.340 --> 01:11.160
这么个意思啊 是这么个意思 一定要搞清楚啊

01:11.420 --> 01:14.480
像我们后边会反复的说到什么实力成员 静态成员

01:15.000 --> 01:17.560
erid表示的是一个数组

01:17.820 --> 01:22.420
凡是通过erid 凡是通过这个勾招器创建的对象的都是数组

01:22.680 --> 01:27.800
凡是通过erid勾招函数 它也叫做勾招器

01:28.300 --> 01:30.860
凡是通过这个erid勾招函数创建的

01:31.380 --> 01:32.140
对象

01:32.660 --> 01:34.460
都是数组 都是数组

01:35.260 --> 01:40.780
不是说这个对象里边有什么下标 有长度它就是数组了 那不一定的 那不一定的 那叫伪数组

01:41.180 --> 01:43.860
我们之前接触过ocuments 对吧 它就是一个伪数组

01:44.580 --> 01:48.180
伪数组呢 可以用一些方法来转换成真数组

01:48.620 --> 01:52.060
但是真数组它一定是通过erid这个勾招函数创建的对象

01:52.500 --> 01:56.820
当然我们平时用两个综扩号 对吧 这里直接写东西 它是一个数组 为什么呢

01:56.980 --> 02:00.300
因为这是一个语法堂 它本质上是通过erid来创建的

02:00.900 --> 02:09.340
原来这意思吧 咱们这一课就来学习erid里边有哪些静态的成员 有哪些实力的成员 成员就包括属性 包括方法

02:10.980 --> 02:14.100
其实我们之前已经说了很多了 其实但是还是不止

02:14.540 --> 02:21.540
erid里边东西太多了 功能太强大了 我们这些东西呢 这一课学习了之后 会学习很多很多的方法

02:21.900 --> 02:28.300
或者是属性 不用去背 不用去背 有这么个印象 将来我们要拥到一某一块知识的时候

02:28.460 --> 02:36.460
要拥有某一个功能的时候 你要回忆得起 我们erid里边 它提供了这么一些方法 可以跟我们使用

02:37.980 --> 02:44.140
至于它怎么去使用 可能忘了 没关系 我们到时候再回过头来查 你可以查我的元代码这个笔记

02:44.700 --> 02:51.340
说到这里 那就顺便说一下 对吧 咱们的这个元代码在哪里获取 在这里获取 少码加微信

02:51.820 --> 02:56.740
获取元代 加群 进群过后可以进行交流 都是跟你们差不多的学员

02:57.300 --> 02:59.860
也有老师在里边 所以说可以交流 可以问问题

03:02.980 --> 03:09.940
然后呢 我们这里为什么还要哪一节课出来讲 就是就是因为还有很多还有很多很多 所以这些可能时间呢会稍微长一点

03:10.140 --> 03:18.340
不过这一课呢 没有多少难度 因为你只要之前的知识巩固了 这一课这一课就学习 它可以提供的方法 提供的属性 怎么去使用就完成了

03:19.180 --> 03:24.460
因为我们以后开发中的数组是一个非常非常常见的这么一种结构

03:24.980 --> 03:33.460
因此呢 学习他的这些常用的方法 可以帮助我们今后在开发中啊 减少我们的代码量 可以提高我们的开发效率

03:33.700 --> 03:41.900
因为有的时候呢 你会发现 我们没有必要去写一些自己的函数了 直接用数组里面提供给你的函数就已经够了啊 因为他提供了非常非常多的函数

03:43.060 --> 03:43.820
好 这里呢

03:44.940 --> 03:53.420
呃 顺便说一下吧 就是以前在耶十五之前啊 耶十五这个版本是一二零零九年啊 二零零九年出来了

03:53.820 --> 04:02.860
啊 这个耶十五这个版本出来之前 呃 其实数组里面方法并不多 但是耶十五出来之后呢 数组里面就多了很多很多的方法了啊 非常非常使用

04:03.340 --> 04:10.140
好 这也可给大家讲解一下 首先我们看这个数组的静态成员啊 什么叫静态成员 就是通过而瑞直接调用的成员就静态成员

04:11.020 --> 04:17.020
好 这个静态成员呢 他里面有哪些呢 咱们还是到这个mdn上面去查啊

04:17.740 --> 04:19.740
呃 而瑞

04:21.180 --> 04:31.100
呃 mdn 收一下啊 就第一个啊 第一第一个 咱们去看一下啊 mdn里边咋说的 他里边有哪些东西啊 他告诉你数组的基本用法 怎么去用啊 怎么去用

04:31.340 --> 04:40.060
说了一大堆对吧 这些我们都讲过的啊 都讲过的就不用再说了啊 不用再说了啊 他这里还顺便告诉你了 怎么去复制一个数组对吧 我们也讲过的snice对吧

04:40.220 --> 04:41.980
snice 可以复制一个新数组

04:42.780 --> 04:50.140
好 什么这些东西啊 访问数组元素我们都讲过了对吧 都讲过的snice和数组下标的关系就是下标加一嘛 对吧

04:51.340 --> 04:55.660
没有什么好说的啊 没有什么好说的 ok 我们直接看到这啊 直接看到这

04:57.500 --> 05:04.700
这里是指他的静态方法啊 静态方法 静态方法有哪些呢 我们可以看 来来来看一下啊 第一个是fra

05:05.660 --> 05:05.980
fra

05:08.220 --> 05:14.060
这个方法有什么用啊 这个方法呢 可以将可以将一个伪数组

05:15.180 --> 05:18.460
伪数组 怎么打不出来了 伪数组

05:19.180 --> 05:26.540
转换为真数组 就是我们之前已经学过一种方式来转换为真数组了 那么这里呢 又多了一种方式

05:26.940 --> 05:34.620
啊 这这个方法呢 有了之以前没有啊 现在有了 有了之又这个方法过后呢 我们可以更加轻松的把一个伪数组转换成真数组

05:34.700 --> 05:39.820
咱们来看一下 test 1 啊 这里和东西比较多啊 咱们慢慢来不着急

05:42.120 --> 05:51.640
但是都很简单啊 这里咱们写一个函数吧 一个函数啊 伪数组呗 对不对啊 我们这里呢 得到一个新的数组 通过什么eray

05:52.280 --> 06:03.560
from france france来自于哪啊 从哪从哪个地方来创建一个新数组啊 把argument传进去 这是一个伪数组对吧 伪数组 ok 我们通过它来创建一个新数组

06:04.280 --> 06:12.200
这里呢 我们把这个 new array 输出啊 看一下是不是是不是一个新真的数组 好 这里我们调用这个函数啊 随便写一些参数 随便写

06:13.240 --> 06:15.400
啊 保存啊 运行处来看一下

06:16.280 --> 06:22.600
f10 刷新 你看 是不是得到一个新数组了 就这么简单啊 得到了真数组过后呢

06:23.240 --> 06:28.760
它就是用 array 的构造函数创建的 因此呢 你可以使用 array 我们后边讲的很多的实力方法都可以用

06:29.720 --> 06:35.480
啊 这就是第一个啊 from 方法 非常非常简单 可以用来创造一个伪数组来转换成一个新的数组

06:36.600 --> 06:42.120
一个真的数组啊 这里 array is array 这个表示什么意思呢 他是返回的是一个

06:42.600 --> 06:49.400
布尔啊 返回的是一个布尔 表示判断你给定的东西是不是一个数组啊 判断你给定的东西是不是一个数组

06:49.720 --> 06:53.080
意识 array 方法 可以判断一个

06:53.720 --> 06:59.320
给定的对象 给定的数据不一定是对象 是否为一个数组

07:01.000 --> 07:06.600
什么叫 就是应该这样说啊 是否为一个真数组 什么叫真数组 就是通过 array 构造器来创建的数组

07:07.400 --> 07:12.120
好 比方说啊 咱们这里可以输出一下 输出一下啥呢 输出一下这个 array

07:12.760 --> 07:19.080
静态方法 意识 array 是不是数组 把 argument 传进去 你看它会给我返回什么东西

07:19.480 --> 07:26.280
啊 保存啊 看一下啊 它会返回一个 force 对吧 说明这个 argument 它不再是一个 它不是一个真的数组

07:26.840 --> 07:30.920
好 那么转换之后呢 我们再来输出啊 转换之后 再来输出 array

07:31.560 --> 07:33.640
意思 array啊 这个 new array

07:34.360 --> 07:37.560
把这个传进去 看这个东西是不是一个真的数组 转换之后

07:38.120 --> 07:43.800
你看 是不是 true 表示是一个真的数组 什么叫真的数组 就是通过 array 的构造器来创建的数组

07:44.280 --> 07:49.560
当然了 如果你给它给的参数是啥呢 比方说你给的参数是数字啊 它当然不是数组啊

07:51.080 --> 07:56.920
哎 等一下啊 等一下啊 我写错了啊 写错了 不是不是一啊

07:57.800 --> 08:06.760
是意思 array 意思 array 一 你看 force 对吧 制服出来 制服出来扔进去 这些东西就不用说了啦 肯定不是数组啊 force

08:07.480 --> 08:09.800
没问题吧 这是关于意思 array

08:10.600 --> 08:12.040
好 这个另外一个 uh

08:12.680 --> 08:19.080
它是根据一组参数来创建新的数组实力啊 支持任意参数的数量和类型 是什么意思呢

08:19.480 --> 08:24.680
啊 这里简单说一下啊 这个东西我们用的不多 但是有的时候呢 可能会用的啊 用的很少

08:25.160 --> 08:26.120
好 array 二五

08:26.840 --> 08:30.840
二五是什么意思呢 比方说写个一 你看一下 得到一个数组 第一项为一

08:31.240 --> 08:37.960
写个二 一和二 得到前两项 一和二 它就相当于是我们这样子写对吧 我们这样子写得到一个数组

08:38.120 --> 08:45.400
我们这样子写是不是也得得到一个数组 对吧 而为二五呢 就相当于是用中科号这种写法来创建来来创建数组

08:45.960 --> 08:48.120
它跟这个 array 的构造函数有什么区别呢

08:48.440 --> 08:53.800
而这个构造函数 我们当时说了啊 array 的构造函数有两种用法 因为它的特殊写法导致的还有两种用法

08:53.960 --> 08:56.280
一种是用六二位来创建一个构造函

08:56.920 --> 08:59.880
创建一个创建一个数组 另一种呢 是直接通过二位

09:00.360 --> 09:04.600
不用六关键字 我们之前说过了 对吧 也可以创建一个数组 效果是一样的啊

09:04.840 --> 09:10.440
我们之前说过 在构造函数里面可以判断 它到底有没有用六关键字来调用 那么我们最后该返回一碗事了

09:12.120 --> 09:17.560
好 那么这是那个 但是用构造函数的时候呢 用构造函数的时候 如果你只穿一个纸

09:17.880 --> 09:23.160
它表示数组的长度 对吧 它表示数组的长度 但是如果你用二二五呢

09:23.560 --> 09:27.400
你只穿一个纸呢 表示这个数组有一项 其中第一项为三

09:27.960 --> 09:31.160
它表示这么个意思 这是这两者的区别 大家注意一下啊

09:32.120 --> 09:41.240
这是关于 而为了静态 静态的方法 就这么三个 这么三个 非常非常简单 也很实用 而二五方法

09:43.640 --> 09:46.040
类似于 终扩号

09:47.960 --> 09:51.400
创建数组 一次赋予

09:52.280 --> 09:54.920
赋予 数组每一项的值

09:56.360 --> 09:57.400
好 这是二五方法

09:58.280 --> 10:03.880
好 接下来我们的重点是 看它的实力成员 实力成员超级多 超级多

10:04.760 --> 10:09.000
数组实力成员里边有很多很多东西 咱们一个按在来看吧 按在来看

10:09.960 --> 10:15.880
有些有些东西呢 是实验性的API 就是它比方这个feal这个函数这个方法

10:16.280 --> 10:20.920
它是个实验性的API 所以说呢 这个实验性的API呢 我们可以了解一下啊

10:21.240 --> 10:25.000
但是在真正的 以后在公司里面去做开发的时候 谨慎使用

10:25.320 --> 10:30.360
看公司的规定 一般公司有规定的 比方说你用哪一个版本的东西啊 公司是有规定的

10:30.680 --> 10:34.280
所以说呢 这一块呢 还是要介绍一下啊 因为有些确实太好用了

10:34.680 --> 10:39.720
我们还是要介绍一下 第一个feal feal 是不是讲过的 我也忘了啊 是不是讲过的

10:40.040 --> 10:42.760
feal方法 没讲过讲一下吧 很简单啊 是

10:43.400 --> 10:49.560
这是实力成员啊 注意 这是实力成员 填充数组啊 用某个数据

10:50.840 --> 10:54.200
填充数组啊 填充数组啊 看一下

10:55.240 --> 10:59.720
就在这里看吧 比方说我们这里有个数组啊 有个数组 new array

11:00.760 --> 11:08.200
100 200项啊 200项的数组 好这个array里面是空的 对吧 空的全都没有啊 只有一个nence 200 没有下标

11:08.440 --> 11:12.440
好 我们这里可以用它的实力方法 你看 实力方法是不是通过对象来调用的

11:13.000 --> 11:15.480
feal 比方说feal feal abc

11:16.040 --> 11:19.800
你看 于是这200项全部变成abc了 就这么简单

11:20.440 --> 11:24.120
把数组的每一项都填充为这个东西 就填充 就feal

11:24.680 --> 11:29.640
好 了解一下就行了 pop 讲过的对吧 poohie 讲过的 ok 基督一下就行了 pop

11:30.680 --> 11:32.520
poohie 讲过的不说了 不说了

11:33.800 --> 11:36.680
好 然后呢 reverse reverse

11:37.720 --> 11:43.720
好 reverse 是什么意思呢 reverse 是把数组颠倒顺序 把数组颠倒顺序

11:44.040 --> 11:47.400
好 我们来看一下 reverse 这个函数 reverse

11:48.120 --> 11:54.280
将当前数组颠倒顺序 颠倒顺序

11:55.000 --> 11:57.560
好 看一下啊 比方说这里呢 我们有一个数组

11:58.520 --> 12:01.800
随便写吧 1 2 3 4 5

12:02.440 --> 12:06.360
好 然后呢 我们把arrowinus用那个 reverse reverse

12:06.760 --> 12:11.000
调用 reverse 好 调用 reverse 过后你看 整个表达是返回的结果

12:11.400 --> 12:14.360
就是一个新的数组 不是新的数组 还是当前数组

12:14.680 --> 12:19.000
当前数组呢 导序过来了 对吧 我们再看一下当前数组 ar 看一下

12:19.400 --> 12:23.480
得到的结果是不是导过来了 对吧 导过来 它不是导序排序啊

12:23.960 --> 12:26.520
它不是导序排序 它是颠倒顺序

12:27.080 --> 12:31.080
有些同学可能会认为它是导序排序 不是这个意思啊 它是颠倒顺序

12:31.560 --> 12:35.880
啊 就是如果你当前的排序是深序排序的话 那么调用这个函数过后呢

12:36.200 --> 12:40.520
你得到的是导序的排序结果 如果当前的排序不是深序排序 是乱的

12:40.520 --> 12:44.200
它导过来还是乱的啊 只不过呢 它是颠倒了数组的顺序

12:44.520 --> 12:45.880
它是这么个意思啊 Reversed

12:47.080 --> 12:50.200
sheffs 讲过了 对吧 说什么讲过 sheffs 讲过了

12:50.840 --> 12:57.000
sheffs 讲过了 不说了 下一个 sort 对数组进行排序

12:58.200 --> 13:04.040
对数组进行排序 返回 并返回当前数组 它会改变数组的顺序

13:04.680 --> 13:08.600
那么我们以前是不是写了一个函数啊 写的函数叫做 sort 对吧

13:08.840 --> 13:13.480
那么现在呢 其实这个函数不用我们自己写 它已经给你提供了啊 已经给你提供了

13:13.720 --> 13:19.160
就是对数组进行排序 进行排序

13:20.280 --> 13:23.720
好 比方说啊 咱们把这个复制一下啊 来个例子啊

13:25.640 --> 13:32.120
好 这里面呢 我们去建一个数组 比方说写个 3 1 2

13:33.160 --> 13:38.920
6 5 4 建这么一个数组 然后呢 我要对这个数组深序进行排序

13:39.400 --> 13:44.520
怎么排序呢 我们可以用这种 ar sort 我们以前写过排序函数 对吧

13:44.680 --> 13:48.680
那么他其实已经给你提供了 你不用自己去写了 sort 自己来排序

13:49.160 --> 13:53.160
好 然后呢 输出这个数组 看一下排完序过后 是不是正确了 结果

13:53.640 --> 13:55.640
好 这里运行啊 运行

13:57.560 --> 14:04.840
好 f 12啊 刷新你看一下 说排完序了 123456 就这么简单 不用我们自己去写这个函数

14:05.800 --> 14:18.120
但是 但是有坑啊 有坑 比方说2 111啊 比方说这个是

14:19.320 --> 14:23.560
这个是20 32啊 32

14:24.200 --> 14:29.320
这个是111 好 咱们来看一下这个排序能不能得到正确的结果 保存看一下

14:30.920 --> 14:33.960
所以出问题了 看一下是不是出问题了

14:34.920 --> 14:39.560
哎 这怎么回算了 为什么排出来变成这个样子了 好 这个时候你该怎么办

14:40.520 --> 14:43.640
啊 如果没有老师啊 以后你自学遇到这些问题该怎么办

14:44.440 --> 14:49.800
文档都摆在面前了 你要去查一下呗 他出了问题就看一下他具体怎么说的

14:50.120 --> 14:53.320
好 我们点击这个超链接啊 看一下他到底是怎么说的

14:53.800 --> 15:01.160
他说他用了什么算法对数组进行排序 我们之前用的是冒泡算法 对吧 他用的是原地算法啊 我们这里不去展开讲解了

15:01.800 --> 15:06.760
啊 我们不去展开讲解这个算法了 没关系啊 不是这个算法的问题 我们继续往后看

15:07.640 --> 15:14.840
他说默认的排序顺序是根据制服串的Ulicor的码点

15:16.200 --> 15:21.320
啥意思 就是他的排序顺序不是按照数字的大小来进行排序的

15:21.880 --> 15:29.800
他是按照什么 把数字当成制服串 按照制服串的编码来进行排序的 我们知道每个制服有编码 对吧 包括数字在内

15:30.280 --> 15:37.320
数字啊 字母啊 标点符号啊 这些都有编码 他默认顺序是按照制服串的编码来进行排序的

15:37.720 --> 15:48.360
因此他不是按照数字的大小来排序的 他为什么11比他小 11为什么比3小呢 是因为他从比较第一个制服1和比较第一个制服3

15:49.560 --> 15:54.600
制服1的编码和制服3的编码比较 那么制服1的编码比3小 所以说他排到前面

15:54.760 --> 16:01.320
明白这个意思了 他是这么来排的啊 所谓说呢 这不符合我们的要求

16:02.040 --> 16:07.800
并且呢 不仅如此啊 并且我们今后呢 制服这个数主力比较可能是对象

16:08.680 --> 16:15.960
那对象怎么排序呢 那又怎么排了 他也是把对象转换成制服串 而对象能不能转上制服串 是不是可以 对吧 value而不

16:16.280 --> 16:21.800
然后呢 再调用toos gene 对吧 把它转换成制服串 再来进行排序 他是用这种方式来排的

16:22.520 --> 16:28.120
因此呢 他有的时候不符合我们的要求 比方说现在我们要按数字的大小来排 他就不符合我们的要求

16:28.520 --> 16:34.600
那怎么办呢 那你想一想 我们以前自己写这个函数的时候是怎么解决这个问题的

16:36.280 --> 16:45.800
咋解决的 我们是不是给了他一个回调函数啊 专门来比较大小的回调函数来解决这个问题 我来告诉他怎么来比较大小

16:46.360 --> 16:48.240
我来告诉你怎么去比较大小

16:48.880 --> 16:56.960
因此呢 我们有了之前的这个知识过后 那你现在就很好理解了 这个sourcer啊 这个东西啊 他是可以传一个函数进去了 你看

16:57.600 --> 17:00.800
compare function 比较的函数

17:01.560 --> 17:08.920
他会给你两个东西 第一个元数 嘿 第二个元数 对吧 他会给你 他会给你两个东西 你告诉他

17:09.440 --> 17:15.480
返回的结果 告诉他返回的 就是这个比较的结果 你告诉他就行了啊 告诉他就行了

17:16.040 --> 17:21.640
好 那么这里呢 他告诉你怎么来比较呢 就是这个函数呢 给你传两个东西 如果

17:22.840 --> 17:29.800
如果小于0 表示什么意思呢 表示a比b要小 a比b要小 所以a会排到b的前面

17:30.560 --> 17:35.800
a会排到b的前面 如果小于0的话 那么如果等于0的话 两个相对位置不变

17:36.200 --> 17:36.680
就相等

17:37.360 --> 17:44.160
大于0的话 说明a比b大 a会排到b的后边 是不是跟我们之前是一样的 跟之前做的作业是一样的

17:44.400 --> 17:46.840
也就是说 这一块呢 我们是可以传函数的

17:48.160 --> 17:51.880
我们通过一个函数来告诉他 a和b哪个大 哪个大

17:52.360 --> 17:57.960
然后大到排后边 小的排前面就这么个意思 那么我们怎么返回了 之前咋返回了 是不是a减b

17:58.600 --> 18:04.760
对吧 a减b a比b大的话 就是返回正数 否则返回0 否则返回复数

18:05.320 --> 18:09.320
就这么回事 好不好 说一看一下 现在是不是正确排序了

18:10.080 --> 18:15.480
有些东西说 导序排序怎么办 是不是b减a 对吧 a比b大 我就返回复数

18:16.680 --> 18:18.720
a比b大 我就返回复数 让b排在前面

18:20.400 --> 18:27.960
啊 对不对 a比b大 我就返回一个复数 让那个啥 让那个a排前面

18:28.440 --> 18:33.080
a排前面 那总之你导 导着排就行了 你看下面是不是导序排序

18:33.720 --> 18:37.360
因此还有这个回调函数过后 你看这个数字函数是不是变得通用了

18:38.040 --> 18:45.520
就说明啥呢 说明我之前说的没问题啊 官方他也是这样做的啊 也是这样做的 有了回调函数过后的 这个函数就更加通用了

18:46.240 --> 18:53.760
好吧 这是个数字函数 当然呢 包括什么对象排序 是不是也可以用这种方式 也可以用类似的方式 对吧

18:55.120 --> 19:01.280
好 那么有的时候呢 我们可能会需要一个什么排序呢 可能会需要一个随机排序

19:02.280 --> 19:09.400
啊 随机打乱顺序 我以前讲过没 好像没讲过对吧 那我这里讲一下吧

19:10.000 --> 19:15.520
随机打乱顺序是什么意思呢 也就是说我这里返回一个正数 返回一个复数

19:16.000 --> 19:22.880
他是随机的 他有可能返回正数 有可能会返回复数 他是随机的 那比较大小是随机的 排序是不是就随机了

19:23.680 --> 19:28.400
啊 因为排序他就一脱于比较大小 对吧 他有的时候这个比这个大 有的时候这个比这个小

19:29.200 --> 19:35.960
所以说这个随机排序很简单 我返回一个什么呢 比较大小的时候 返回一个mess.radon 是不是 产生个随机数

19:36.440 --> 19:44.080
0到1之间的一个随机小数 减去0.5 减去一半 是不是一般的几率是复数 一般的几率是正数

19:44.480 --> 19:48.240
对吧 那么他比较出来的结果就是有可能abb大 有可能abb小

19:48.800 --> 19:54.320
输不准的 输不准的话 那么他比较大小就是随机的 比较大小随机 那么排序就是随机的

19:55.120 --> 20:01.760
保存看一下啊 你看就是这就是个随机的排序啊 每次刷新刷新的得到的结果都可能不太一样 看见没

20:02.200 --> 20:08.280
再刷新 你看没 得到结果都不太一样 这就是一个非常简单的打乱数组顺序的方式

20:09.240 --> 20:18.240
你要这个意思啊 这也叫做也叫做洗牌 洗牌 就是本贯这个数组是什么数组 本贯这个数组是什么数组 一个微向数组也好

20:18.720 --> 20:26.480
一个什么 一个就是普通的数字数组 一个支付刷数组都行 我都可以用这种方式来打论它的顺序 随机打断

20:27.400 --> 20:30.200
好吧 这是关于这个sort啊sort排序

20:31.320 --> 20:39.720
你看 你看我们有的 之前这是现在就非常好理解了 他已经给你写好了啊splice呢 表示的是三处啊 安切不成的 我们讲过了 讲过了就不说了

20:40.560 --> 20:41.080
splice

20:42.600 --> 20:47.920
splice 这是三处 还有onshopt 也是三处 三处守卫啊 讲过了就不说了

20:48.720 --> 20:54.560
好 接下来他说下边这个方法 他下边这一方法呢 他有个特点 有个共同的特点

20:55.080 --> 20:59.600
都是实力方法啊 只不过这一方有一个特点是什么的 他不会改变

21:00.080 --> 21:03.680
雕用他们对象的值 他只会返回一个新的数组

21:04.440 --> 21:08.720
我们把这种方法呢 叫做这种函数啊 这种方法叫做存函数

21:09.640 --> 21:12.160
存函数啊 或者说无

21:13.120 --> 21:19.920
复作用函数 当然无复作用和存函数的还有一些其他要求啊 我们在先暂时这么叫 他表示怎么意思呢

21:20.440 --> 21:28.880
不会导致当前对象发生改变 当然还有一些其他要求啊 我们目前呢还不还没有接受到后边的知识

21:29.440 --> 21:35.120
就是其他课程的知识了 我们现在先暂时这么理解 我们把它叫做存函数啊 叫做存方法存函数

21:35.680 --> 21:38.800
那么下边说的这一方法呢 他都不会改变当前数组

21:39.520 --> 21:46.360
我们之前接接受过一些方法 他不会改变当前数组的 咱们来看一下啊 有哪些方法 有些我们是学过的 对吧 一个是康凯子

21:46.800 --> 21:54.160
表示连接啊 连接 他可以组合若干个数组来得到一个新数组啊 康凯子

21:54.720 --> 22:02.520
康凯子 康凯子的意思就是连接的意思啊 组合新 组合多个数组来得到一个新数组 比方说咱们来看一下吧

22:03.080 --> 22:22.800
这里呢 比方说有两个数组吧 两个数组 一 随便吧 然后呢 第二个数组 四 五 六 然后第三个数组 来三个吧 七 八 九 啊 这个多了一个啊

22:23.680 --> 22:31.120
好 这三个数组 我想把这三个数组拼接起来成为一个新的数组 怎么拼接呢 我就用AR1康凯子

22:31.600 --> 22:41.640
康凯子AR2扔进去 AR3扔进去 他就把AR2和AR3的东西一次拼到AR1里边 但是他不会改变AR1

22:42.200 --> 22:50.680
我们要接收 用一个新数组来接收 他返回一个新的数组 他不会改变原就的东西 保存

22:52.640 --> 22:57.680
看一下 你看得到新 没运行 看一下

22:58.680 --> 23:07.960
好 你看是不是得到一个新数组了 好 我们再看一下AR1有没有变 没变 没变 对吧 都没变 他不会改动原来的东西

23:08.400 --> 23:13.400
他没有副作用 否则没有副作用 就是把之前的东西就当前的对象给他改了 就是副作用

23:13.840 --> 23:18.440
没有副作用的函数呢 他得到的东西呢 他永远是返回一个新的东西 他不影响之前的

23:18.920 --> 23:24.840
好吧 这是关于康凯子啊 好 这些函数啊 下面的函数都是没有副作用的啊 都是没有副作用的

23:25.560 --> 23:32.160
好 下面这个includes 他返回一个bure true 或者是force 这个是一个实验性质的函数啊

23:33.160 --> 23:36.280
我记得实验es6里面出来的 非常非常好用这个函数

23:36.920 --> 23:43.320
但是现在基本上有这个新版本的流量器都支持了啊 所以还是要学习一下他includes 咱们来看一下

23:44.520 --> 23:48.840
这个includes 他表示什么意思呢 表示的是includes

23:49.960 --> 23:53.960
includes这个单词什么意思 表示是否包含对吧 是否有某个东西

23:54.600 --> 23:57.720
是否 就是数组中 是否包含

23:58.600 --> 23:59.400
是否包含

24:00.440 --> 24:09.960
满足条件的元素 是不是我们之前写过那次的代码 写过一个函数 来判断一个数组里边 是不是包含满足条件的元素 对吧 写过这么一个东西

24:10.760 --> 24:15.240
好 我们来看一下啊 来看一下 这个includes我们点进去 看一下他怎么用的

24:16.440 --> 24:17.240
看一下怎么用的

24:17.960 --> 24:27.000
他说 根据情况来进行判定啊 你传一个什么呢 传一个指进来 他从这个数组里边去找这个指存不存在

24:27.400 --> 24:35.400
并且还可以传第二个参数 你看一下以后看到官方文档里边这样子写 两个中阔号里边写上一个兜号一个参数 表示什么意思呢

24:35.640 --> 24:38.200
表示这个参数是可选的 你可以传可以不传

24:39.080 --> 24:40.200
可以传可以不传

24:41.080 --> 24:45.400
表示什么意思 第二参数表示什么意思呢 表示从指定位置开始进行寻找

24:45.800 --> 24:46.600
就个例子吧

24:48.200 --> 24:50.280
看一下啊 比方说咱们有一个数组

24:51.320 --> 24:54.920
啊 一个数组 AR AR 有些数字啊 有些数字

24:55.560 --> 24:59.160
好 我来判断一下这个数字中是否包含67

24:59.960 --> 25:03.880
是否包含67 以前的我们得写寻环对吧 或者自己写一个函数

25:04.440 --> 25:10.120
现在呢 其实他提供给力的这个东西了 已经提供给力的给力的 叫做includes

25:10.680 --> 25:11.320
includes

25:11.720 --> 25:14.440
好 然后这里边填啥呢 比方说填67

25:15.400 --> 25:19.240
判断的是啥 判断的67是不是在这个数组中存在 就这么简单

25:19.640 --> 25:21.960
看一下呗 F12

25:22.440 --> 25:26.520
你看一下 Q 对吧 得到了结果了 67在这个数组里边存在

25:26.760 --> 25:31.560
他还可以传第二个参数 第二个参数表示的是 表示的是从什么位置开始找

25:32.040 --> 25:36.520
比方说我只从这里开始找 0 1 2 3 下标为3的这个位置

25:37.240 --> 25:40.360
下标为3的这个位置开始找 那么他只找这一部分

25:40.600 --> 25:44.040
那这一部分是不是不存在 保存看一下 Force 不存在

25:44.680 --> 25:46.680
就这么个意思啊 非常非常简单

25:47.160 --> 25:52.600
这个意思我打个住是什么啊 从数组下标3的位置

25:53.160 --> 25:55.160
开始寻找 寻找

25:56.600 --> 26:03.640
目标是67 看能不能找到 他比较的时候是用严格相等来比较的啊 比较是用严格相等来比较

26:03.720 --> 26:06.360
也就是说这个地方如果你写个制服串 能找到吗

26:07.160 --> 26:10.280
如果这里哪怕 哪怕我不写这个3 能找到吗

26:11.000 --> 26:13.560
就找不到 他是用严格相等来比较的

26:14.360 --> 26:18.440
说一下这个啊 那么另外的有一个问题啊 大家看一下

26:19.240 --> 26:23.240
那比方说这个数组里边 他存的是一些对象 一些对象

26:23.640 --> 26:26.040
一个对象 x1 y等于2

26:26.840 --> 26:29.400
另外一个对象 x3 y等于4

26:30.120 --> 26:33.640
咱们去找 从个数字里面去找 看能不能找到我们想要的东西

26:35.400 --> 26:38.040
console log AR includes

26:38.520 --> 26:39.160
include

26:39.480 --> 26:43.880
找啥呢 找一个对象 x等于1 y等于2 看能不能找到这个对象啊

26:44.920 --> 26:45.640
能不能找到了

26:46.520 --> 26:49.160
大家想一想能不能找到了啊 去找这个对象

26:50.280 --> 26:56.680
看一下结果能不能找到了 force 能不能找到 为什么 因为他比较的时候这个对象啊这个比较

26:57.320 --> 27:02.120
他没法比较看没 他没法比较 因为比较的时候他一定不相等 因为他比较的是地址

27:02.440 --> 27:05.720
比较的是地址 所以说这个地方一定不相等

27:06.440 --> 27:12.280
好 这是关于对象怎么办 没办法 目前只能用循环了 当然可以利用后边 我们学习到一些函数

27:13.000 --> 27:14.280
好 这是关于include

27:14.280 --> 27:19.960
include 目前还处于试验性功能 将来可能会这个对象的雕用方式可能会有些改变

27:20.840 --> 27:23.640
好 下面交引 把一个数组连成一个字不串

27:24.280 --> 27:28.760
里边传一个分割符 对吧 我们之前讲过的 这里不说了 不说了 交引

27:29.720 --> 27:32.840
这些都是我们非常非常常见的函数

27:32.840 --> 27:37.080
snice 抽取数组组的一段元素组成一个新数组

27:37.800 --> 27:42.040
不说了 这些东西都不会改变原来的东西的 不会改变原来的数组

27:42.600 --> 27:45.960
好 下面这个突出军 突出军没什么说的 没什么说的

27:46.520 --> 27:49.800
好 下面这个indexerve 很那时indexerve说过的 对吧

27:50.360 --> 27:54.440
查找某个元素的下标 和查找某个元素最后一次出现的下标

27:54.840 --> 27:57.640
一个是第一次出现的下标 一个是最后一次出现的下标

27:58.120 --> 28:00.840
如果没有找到 返回负一 这两个

28:01.880 --> 28:05.560
好 接下来还有 还有很多 还有超级多 我们一个挨着看

28:06.920 --> 28:10.600
下面这些方法真的是超级厉害 真的是超级厉害的方法

28:11.320 --> 28:12.840
好 第一个for each

28:13.560 --> 28:19.800
for each 是什么呢 for each这个函数 它是用来循环数组的 便利数组

28:20.200 --> 28:25.880
它用来循环的 好 这个函数本身它不返回任何东西 返回 它主要是用来便利的

28:26.200 --> 28:28.040
我们之前便利数组用的是什么

28:28.920 --> 28:35.080
之前便利数组 是不是用的是for循环和for硬循环 对吧 for硬循环 也叫做for一起循环

28:35.560 --> 28:41.480
实际上呢 用这个函数啊 这是ES5立表出来的新函数 用这个函数可以更加方便的

28:42.280 --> 28:45.720
便利数组 所以说这个函数呢 可以可以这样说吧

28:46.680 --> 28:48.520
自从ES5出来之后

28:49.560 --> 28:55.640
我写真 就是我自己在做项目写代码的时候 没有不是搜刻的时候 搜刻的时候我可能会写for循环

28:56.360 --> 29:01.480
我自己在写代码的时候 我再也没有用过for硬环了 真的 真的我没有用过for硬环了

29:02.200 --> 29:05.960
很少很少使用了 基本上我要便利一个数组全是用for一起

29:06.840 --> 29:09.400
好 怎么用的了这个for一起 它是这样子用的

29:10.600 --> 29:11.160
看一下啊

29:13.160 --> 29:14.600
好 比方说啊一个数组

29:16.040 --> 29:17.160
随便写个啊 随便写个

29:17.960 --> 29:23.480
我要便利这个数组 以前我要直接写个for硬环 对吧 那么大家可以用for硬环啊 之后可以用for硬环

29:23.880 --> 29:28.840
那么后来呢 我就不再用for循环了 我用的是什么呢 用的是这个for一起这个函数

29:29.320 --> 29:31.240
这个函数 这个函数来便利数组

29:31.800 --> 29:34.280
这个函数里边 它要传一个函数进去

29:35.160 --> 29:40.680
不陌生了吗 我们要传一个函数作为参数传进去 没问题吧 好 传一个函数进去

29:41.240 --> 29:43.240
这个函数呢 它支持三个参数

29:44.200 --> 29:46.040
第一个参数呢 是数组的某一项

29:46.920 --> 29:50.120
它会它会自动帮你便利这个数组 自动帮你便利

29:50.440 --> 29:52.920
就是第一项拿出来 作为第一个参数传进来

29:52.920 --> 29:55.720
item 表示数组的其中一项 当然名字里可以随便去

29:56.280 --> 30:00.520
第二个参数呢 表示数组的下标 第三个参数呢 表示整个数组本身

30:01.080 --> 30:01.880
整个数组本身

30:02.920 --> 30:05.320
好 我们来输出一下 输出一下 item

30:06.520 --> 30:08.680
a 你看一下这个函数会运行多少次

30:09.080 --> 30:13.400
这个函数不是我写的一次 只会运行一次 我是把这个函数作为参数传进去了

30:14.360 --> 30:18.520
它在帮你进行便利的过程中 它会不断的去调用你传递的函数

30:19.160 --> 30:20.120
好 保存看一下啊

30:21.240 --> 30:25.000
看一下这个函数 我们写的这个传递这个函数进去 你看是不是运行了多次

30:25.320 --> 30:29.160
对吧 运行了多次 第一次把第一项拿进来 传给你

30:29.480 --> 30:34.920
把下标传给你 看到没 第二次呢 把第二项拿进来 下标传给你 第三个函数就是整个数组

30:35.880 --> 30:39.960
你看 是不是完成了便利了 就完成整个数组的便利了 当然当你

30:40.520 --> 30:44.840
不需要 你不需要每次都把三个三个写全 因为有的时候呢 你只需要得到

30:45.320 --> 30:49.800
数组的每一项就行了 对吧 你就不需要这个下标了 你需要下标的时候 你写第二个参数

30:50.200 --> 30:54.360
它会传给你的 你没有这个参数 它就传给你 你也获取不到 对吧 也无所谓的

30:55.160 --> 30:57.560
那这样子是不是在便利数组了 保存你看一下

30:58.440 --> 31:06.200
这是便利数组 啊 以后我们便利数组啊 我可能会更多的选择用这种方式 而不再去写负循环了啊 我讨厌负循环

31:07.880 --> 31:10.280
好 这是关于负一起啊 负一起

31:11.320 --> 31:14.360
好 下一个啊 下一个 我记录一下啊 记录一下

31:15.000 --> 31:16.360
记住了的 这是便利数组

31:17.240 --> 31:17.880
便利数组

31:19.160 --> 31:19.880
好 下一个

31:20.600 --> 31:21.080
every

31:21.800 --> 31:22.200
every

31:22.600 --> 31:30.040
它指的是什么意思呢 他是在判断 是否这个数组里边所有的元素都满足条件

31:31.160 --> 31:37.080
是不是所有的元素都满足条件 非常强大的一个函数 是否是 是否

31:38.280 --> 31:38.760
所有

31:39.240 --> 31:46.680
所有什么元素都满足条件 必须要所有满都满足 一个不满足都不行

31:47.240 --> 31:48.680
啊 比方说啊 看一下every

31:49.080 --> 31:53.000
比方说咱们数组里边记录的是考试的分数啊 考试的分数

31:53.960 --> 32:06.470
啊 随便写 随便写啊 这里90分嘛啊 比方说我们这里记录 记录的是一个班级的考数分数 但是这里边也可以可能是对象啊 无所谓

32:07.110 --> 32:09.590
好 怎么来判断 他是不是啊 我们现在要判断

32:10.230 --> 32:16.550
判断啥呢 判断是否所有同学都几个 是不是都几个了

32:17.270 --> 32:20.150
一个没几个 没几个都不行啊 怎么判断呢

32:20.870 --> 32:24.870
我们不用去写循环 最简单 他里边不是有个every吗

32:25.830 --> 32:27.750
every 这里边传啥呢

32:28.630 --> 32:32.390
条件 条件是啥呢 条件就是函数

32:33.190 --> 32:36.150
啊 你告诉他一个怎么来判断 是否满足条件的函数

32:37.110 --> 32:44.230
这个函数里边呢 他会给传你什么呢 传你item 传给你 把下标传给你 会把整个数组传给你

32:44.710 --> 32:49.270
跟之前是一样的 他会传这三个东西给你 当然如果你用不到的话 你可以只写一个

32:49.990 --> 32:54.310
我们现在用不到这个下标 用不到这个整个数组 所以说我们只需要这个数组的每一项

32:54.630 --> 32:57.990
他会把数组的每一项传给你 什么叫做满足条件

32:58.870 --> 33:03.830
满足条件返回 to 不满足就返回 force 我们以前自己写回到函数的时候 是不是写过了

33:04.230 --> 33:12.950
对吧 写过了 那么这里的条件是啥呢 怎么让满足条件呢 及格就大于等于 news 呗 对吧 满足这个条件 那么这个同学就及格了

33:13.750 --> 33:19.990
好 如果所有同学都及格的话 那么他整个整个这个表达是啊 我把它写出来嘛 result

33:21.510 --> 33:21.830
如果

33:23.190 --> 33:29.030
所有的同学都及格了 那么他就委屈 否则的话 如果有一个条件不满足 他就为 force 看一下吧

33:31.110 --> 33:32.950
用这个函数可以非常轻松的得到

33:34.230 --> 33:40.790
是否所有的都满足条件去啊 表示所有同学都及格了 那如果有一个不及格 比方说他一个是55

33:41.590 --> 33:41.910
force

33:43.110 --> 33:45.910
能理解吗啊 非常简单啊 这是 every

33:47.030 --> 33:49.990
下面这个 some啊 some 表示的是

33:50.710 --> 33:57.830
给every差不多啊 他的含义逻辑含义不太一样 表示的是只要有一个元素满足条满足条件返回去

33:58.230 --> 33:59.270
否则的话返回 force

34:00.150 --> 34:05.110
好 他变成这么一个意思的啊 一般条件告诉他 那么他来帮你判定剩下的东西

34:06.150 --> 34:09.430
好 比方说啊 那么现在我要判断的是啥呢 现在我要判断的

34:10.150 --> 34:14.710
判断是否至少有一个同学及格

34:16.070 --> 34:21.670
好 那么咱们来呗 直接输出啊 我就直接输出了 比较拉适嘛 直接输出 好 输出 every

34:22.870 --> 34:29.110
avery 好的 不是every上啊上 好 里边说传函数 对吧 传函数 是不是一样的

34:29.750 --> 34:32.630
一样的啊 他有三个参数 这里只需要用到一个

34:33.990 --> 34:40.630
条件都是一样的 什么叫几个 大约等于60啊 只要有一个满足这个条件就ok 保存看一下

34:42.070 --> 34:47.430
two 好 如果全部都不及格了 比方说是三十七 二十五啊 四十八

34:47.910 --> 34:52.630
三十三十 保存看一下 是不是 force 都没有就是

34:53.430 --> 34:55.190
全部都没有几个啊 全部都没有几个

34:56.150 --> 35:05.430
能理解吧 这是关于sum 就非常强大的一函数 可以帮助我们应付各种各样的数组的处理场景 就不用至于写循环了

35:06.070 --> 35:13.670
这个是是否至少有一个元素满足条件 这是关于sum

35:15.510 --> 35:21.510
好 下面这个 哇 下面这个超级强大 filter filter 表示是过滤啊 过滤

35:22.070 --> 35:26.390
那么他会返回一个新数组啊 这些全是存含数啊 他不会影响之前的数组的

35:27.030 --> 35:32.950
返回一个新的数组 这个新的数组里边包含的是什么呢 包含的是满足条件的

35:33.750 --> 35:38.150
像啊 满足条件的就包含了新数组里边去 他最后返回一个新数组

35:38.950 --> 35:42.950
好 那么以前我们是不是写过的 我们以前是不是写过这个filter

35:44.230 --> 35:50.070
一样的一样的啊 就是这么个意思 filter 表示过滤啊

35:50.950 --> 35:56.070
得到满足条件的元素 组成的新数组

35:57.030 --> 36:07.030
好 看一下吧 咱们再复制一个啊 还是这个数组随便吧啊 随便啊 77 88好 就这个吧得到

36:08.310 --> 36:10.390
得到所有其格的分数

36:11.750 --> 36:12.150
好来

36:13.110 --> 36:14.150
啊

36:15.030 --> 36:21.670
filter啊 filter 是不是要传个含数进来 你他怎么他怎么知道哪个条件满足了 哪个条件不满足了 对吧 你要

36:21.990 --> 36:30.470
你要帮他判断什么叫做满足条件 什么叫做条件啊 当然了这个item就表示数组的每一项啊 当然这里面还有三个参数啊

36:30.950 --> 36:32.950
如果你需要的话还可以还可以得到下标

36:33.670 --> 36:39.030
好 比方说啊 我们这里什么样满足条件呢 item大于等于60就是满足条件啊 满足条件的

36:39.350 --> 36:45.590
它会返回一个新的数组好 整个表达数得到一个新的数组看一下啊 new array得到一个新的数组

36:46.950 --> 36:50.710
输出啊 这些函数我们以后会反来不去用 长进多的很

36:51.830 --> 36:56.310
不再会去自己写写代码去搞定了啊 输出啊 看一下

36:57.670 --> 37:02.550
有了这些函数支持过以后数组处理起来非常的方便啊 77 88 你看

37:03.190 --> 37:05.510
它不会改变原来的数组啊 一看原来的数组

37:05.990 --> 37:11.750
原来的数组是没变的啊 不会改动原来的数组 都是纯的函数 它没有对原来的东西造成任何影响

37:12.870 --> 37:14.950
好吧 这是关于filter啊 filter

37:15.990 --> 37:22.870
好 fan的啊 fan的啊 这些呢是实验性的方法啊fan的和fan的应那个时候是实验性的方法 我介绍一下吧

37:23.110 --> 37:25.670
介绍一下 也很好用 主要是太好用了

37:26.390 --> 37:26.790
fan的

37:27.430 --> 37:28.870
它是查找

37:29.510 --> 37:33.830
啊 查找第一个满足条件的元素

37:34.390 --> 37:43.750
返回元素本身 返回的就不是下标了啊 之前的应那个时候的应那个时候呢 返回的是下标 那么这个fan的呢 返回的就不是下标了 返回的是元素本身

37:44.230 --> 37:45.510
如果没有找到

37:46.230 --> 37:48.150
返回 on the fan的啊

37:49.430 --> 37:50.950
on the fan fan的

37:52.390 --> 37:53.270
哎 写错了啊

37:54.230 --> 37:56.310
好 看一下啊 这个函数它怎么玩的

37:57.830 --> 38:02.710
啊 比方说啊 我要找啥呢 找找到就是

38:03.750 --> 38:06.630
啊 这样子 我们这里呢 写对象啊 写对象

38:07.270 --> 38:10.390
我们来一个复杂的场景 也不算复杂的场景的 on the

38:11.910 --> 38:18.070
啊 a 小a同学 然后呢年龄随便啊 然后呢给他一个分数分数呢

38:18.870 --> 38:22.950
55分啊 这是第一个 第一个学生啊 第一个学生

38:24.230 --> 38:26.710
好 第二个学生啊 第二个学生

38:27.430 --> 38:31.670
第二个学生呢 年龄12分数呢 65分

38:33.990 --> 38:40.230
啊 第三个学生 第三个学生 c啊 年龄22 85分啊 比方说啊 有这么一个数组

38:40.710 --> 38:42.790
好 接下来呢 我们来找什么得到

38:43.910 --> 38:44.870
啊

38:45.510 --> 38:50.390
分数啊 就是及格的学生啊 学生

38:51.990 --> 38:53.830
找第一个啊 找第一个

38:54.870 --> 38:59.990
如果要找所有怎么办 如果要找所有及格的学生怎么办 你们思考一下啊 我们先找第一个

39:00.550 --> 39:03.910
好 第一个 a r r fend啊 fend

39:04.870 --> 39:11.430
是不是可以找啦 对吧 满足条件的学生啊 这里边要写啥 写函数 什么叫做条件 你要告诉他

39:12.150 --> 39:15.030
好 来呗 他会把数组一项一项传进来

39:15.430 --> 39:21.190
好 你这里不要再给我来个什么item大于等于60啊 不要来了 item现在是什么 现在不是数字了

39:21.510 --> 39:27.510
每一项是一个对象 是一个对象 我们要找的是什么呢 什么样满足条件的 是item的

39:28.070 --> 39:32.070
score分数要大于等于60 item是个对象啊

39:32.550 --> 39:36.710
它的分数大于等于60 看一下这个条件 满足这个条件的 看有没有找到

39:37.430 --> 39:39.510
results 输出啊 咱们输出

39:40.470 --> 39:42.150
啊 输出

39:42.950 --> 39:52.060
看一下 看一下结果啊 贼耗用这些东西 贼耗用 你看 找到是不是学生b 对吧 学生b 他第一个

39:52.540 --> 39:54.780
及格的学生找到了 找到就停滞寻找

39:55.500 --> 39:58.460
好 这就是查照问题 我们就不用再去自己写代码了

39:59.020 --> 40:03.980
好 因为他又回调函数 所以说我们可以应对各种各样的场景 我只要把条件给他就行了

40:04.540 --> 40:07.980
好 比方说我们要找90分以上的 90分以上的

40:08.700 --> 40:18.060
找一下 是没有undefend的 undefend的 这就是犯的 他犯的是找单个对象啊 找的是单个 单个结果 那如果要得到所有呢

40:19.180 --> 40:20.180
要得到所有呢

40:21.900 --> 40:26.380
得到几个的学生 所有 怎么办 是不是刚刚学过了 什么

40:26.940 --> 40:34.140
filter 筛选呗 对吧 筛选 条件是不是一样的啊 条件都是一样的 进行筛选就完事了

40:35.900 --> 40:37.020
好 来输出啊

40:38.540 --> 40:40.780
result 啊 这里是60

40:42.220 --> 40:45.180
啊 这里是60 好 看一下啊 通过这个

40:45.900 --> 40:50.060
filter 就可以得到所有的满足条件的学生啊 你看一下

40:51.020 --> 40:55.420
是吧 没问题吧 所有满足条件的学生都得到了得到了

40:56.060 --> 40:59.420
好 这是关于这个fend fend

41:00.220 --> 41:06.380
好 下一个 fend index 表示满足条件的所引 他跟那个index很像

41:06.940 --> 41:13.100
跟那个index很像 这两个函数其实还可以指定 还可以指定那个从哪里开始寻找

41:14.060 --> 41:18.300
还可以指定从哪里开始寻找 你看 我看一下啊

41:20.140 --> 41:22.220
哦 没有没有 哦 他没有没 我记错了

41:23.020 --> 41:28.620
当前 对对对 他没有 他没有 他没有指定可以从哪里开始寻找 他必须要找完 他整个数字里面找

41:29.100 --> 41:31.900
跟那个index很像啊 这个fend index

41:32.540 --> 41:37.260
只不过呢 他是可以传回调函数的 index只能传一个值 他得来进行相等比较

41:37.820 --> 41:40.380
fend index 查找

41:42.620 --> 41:51.260
第一个满足条件的元素 返回元素的下标 返回的是下标 如果没有找到呢 返回负一

41:51.900 --> 41:59.980
如果没有找到 返回负一 跟那个index很像 但是那又不太一样 为什么不太一样呢 比方说我要找到第一个学生的下标

42:02.380 --> 42:07.660
比方说啊 我要得到几个的学生找第一个的下标

42:09.420 --> 42:13.100
好 你用index的时候你怎么找 你没法找啊 第一个

42:13.900 --> 42:18.860
的下标 你用index的时候能找吗 没法找啊 比方说啊 你用index的时候

42:20.060 --> 42:24.140
index的时候 你这里填啥 请问你填啥 你给我填个啥 填60

42:25.100 --> 42:32.140
你填啥 如果你填个60的话 他怎么来比较呢 他是把第一个对象 等不等于60

42:32.380 --> 42:39.420
对象怎么能跟数字比较呢 是不是一定为force 对吧 所以这种没法找 你必须要写个函数 index的时候他又不只是函数

42:39.580 --> 42:45.260
所以说我们这里可以用fend index 这里呢 我们可以写函数就好办了 返回什么

42:45.660 --> 42:49.180
item.score 是不是大于等于60

42:49.900 --> 42:51.900
就这么个意思啊

42:52.780 --> 42:58.060
然后得到下标啊 得到下标 index 如果没找到的话 返回负一

43:01.060 --> 43:08.680
保存看一下啊 你看得到的结果是1啊 表示下标我1的这个学生呢就已经满中条件了

43:09.400 --> 43:12.840
啊 这这么个函数啊 好下一个下一个map

43:13.480 --> 43:13.720
map

43:14.600 --> 43:20.680
啊 这些什么kiss啊 这些东西 就是我们之前讲过 object成那个函数了啊 讲过的map

43:21.640 --> 43:22.920
好 看一下啊map

43:25.590 --> 43:32.390
map呢 他表示的是映射啊 映射 他指的是将数组的每一项

43:33.350 --> 43:38.950
映射成为另外一项啊 另外一项

43:39.670 --> 43:42.550
什么意思呢 比方说啊 比方说

43:46.230 --> 43:47.590
比方说我有这么一个数组

43:48.630 --> 43:49.030
啊

43:50.150 --> 43:53.590
我这里在代码里面写吧 这个map还说特别特别强大

43:54.630 --> 43:57.190
以后呢 可以解决好多好多种常见的问题

43:58.550 --> 44:04.150
啊 一个数组 记录的是分数 对吧 记录的分数55 66啊

44:05.270 --> 44:10.870
22 33 44 88啊 随便吧 我要得到一个新数组

44:11.670 --> 44:20.980
得到一个新数组 新数组啊 新数组什么样呢 新数组的每一项是一个对象

44:22.180 --> 44:24.180
好 继续写啊 对象中

44:25.140 --> 44:26.740
包含两个数项

44:27.380 --> 44:30.020
一个数项是啥呢 一个是姓名name

44:30.740 --> 44:34.740
一个是score分数啊 分数就跟这边对应啊 就跟这边对应

44:35.380 --> 44:38.500
这就叫做映射 这就叫做映射

44:39.220 --> 44:44.820
我从一个原来的数组来产生一个新数组 长度肯定是一样的 长度绝对是一样的

44:45.220 --> 44:49.540
只是它的内形变了 它原来的每一个是数字 那么新的数组每一个是对象

44:49.780 --> 44:54.100
那么对新的数组里边每一项是根据原数组的每一项生成出来

44:54.500 --> 44:55.540
比方说这个55

44:56.020 --> 44:58.020
55的话还会映射成什么呢

44:58.500 --> 45:03.860
55它就会映射成为一个对象 这个对象里边name表示的是

45:05.860 --> 45:07.540
学生1

45:07.940 --> 45:08.420
学生1

45:09.380 --> 45:11.300
那个就是成绩了

45:11.940 --> 45:13.780
55它就会映射成为这个东西

45:14.340 --> 45:15.060
你看这个意思吧

45:15.540 --> 45:16.740
好 66

45:17.700 --> 45:18.260
66

45:20.260 --> 45:21.060
那么这里呢

45:21.780 --> 45:22.660
会得到一个新的

45:27.500 --> 45:29.740
得到一个新的就是新的对象

45:30.300 --> 45:32.220
name是学生2

45:32.220 --> 45:33.100
学生2

45:33.500 --> 45:36.380
score是66

45:37.020 --> 45:38.060
要完成这么一个功能

45:38.780 --> 45:41.660
把每一个映射的结果装到新数组里边返回

45:42.460 --> 45:45.260
这个时候用map寒数 特别特别方便

45:45.820 --> 45:47.820
map里边传一个寒数进来

45:48.380 --> 45:50.700
这个寒数还是一样的 它会把数组的每一项告诉你

45:50.860 --> 45:52.300
每一项数字会告诉你

45:52.620 --> 45:53.980
然后会把下标告诉你

45:54.300 --> 45:55.500
会把整个数组也告诉你

45:55.500 --> 45:56.700
但是我们不需要那么多

45:57.500 --> 45:59.020
只需要一个这个东西和下标

45:59.580 --> 46:00.700
好 我返回啥呢

46:00.940 --> 46:02.940
返回的是一个映射的结果

46:03.180 --> 46:04.380
你把这一项给力了

46:04.380 --> 46:05.420
它把这一项给力了

46:06.300 --> 46:07.260
把这一项

46:08.300 --> 46:09.900
你要映射成为一个啥

46:10.220 --> 46:11.020
映射成为啥

46:11.820 --> 46:14.220
映射成为不就是一个映射一个对象吗

46:14.700 --> 46:15.740
我映射一个对象

46:16.060 --> 46:17.740
把这个东西映射成为一个对象

46:18.220 --> 46:19.180
名字等于啥呢

46:19.180 --> 46:20.300
名字等于学生

46:21.100 --> 46:22.140
一个字符串

46:22.540 --> 46:23.580
拼接啥呢

46:23.900 --> 46:25.180
拼接i加1

46:25.180 --> 46:26.220
i从0开始

46:26.220 --> 46:27.180
下标从0开始

46:28.220 --> 46:28.860
第一个学生

46:28.860 --> 46:30.220
i的是0的话

46:30.220 --> 46:31.100
它的下标是0的话

46:31.100 --> 46:32.460
那么学生就是1

46:32.460 --> 46:33.340
它的下标是1的话

46:33.340 --> 46:33.900
学生就是2

46:34.860 --> 46:35.740
那边等于这个

46:35.980 --> 46:37.180
成绩了等于item

46:37.340 --> 46:38.540
item就是数组的每一项

46:39.500 --> 46:42.220
于是这个函刷就会返回一个新的对象

46:42.220 --> 46:42.780
new array

46:43.420 --> 46:44.780
这个新的对象我们来看一下

46:44.780 --> 46:46.460
特别特别强大这个函数

46:47.420 --> 46:48.140
new array

46:49.180 --> 46:49.900
保存看一下

46:53.260 --> 46:53.900
没运气

46:55.180 --> 46:55.980
运行出来

46:57.740 --> 46:58.300
看一下

46:58.860 --> 46:59.420
你看

46:59.580 --> 47:00.540
是不是映射出来了

47:00.540 --> 47:01.420
一个新的数组

47:01.420 --> 47:03.180
新的数组里边每一个就是个对象了

47:03.500 --> 47:04.540
每个就是个对象了

47:05.100 --> 47:05.580
看没

47:05.820 --> 47:07.100
非常非常舒服

47:07.100 --> 47:08.140
非常非常舒服

47:08.140 --> 47:08.940
那比方说

47:08.940 --> 47:10.220
我们要用这个新数组了

47:10.220 --> 47:11.020
再来映射

47:11.180 --> 47:13.020
再来映射一个学生的新名数组

47:13.820 --> 47:17.260
得到一个学生的新名数组

47:17.420 --> 47:18.140
怎么办呢

47:18.140 --> 47:19.580
我们利用这个新数组

47:19.740 --> 47:20.540
又来用它

47:21.180 --> 47:21.820
比方说

47:21.820 --> 47:22.700
我们重新给它复制

47:23.020 --> 47:23.580
new array

47:24.540 --> 47:26.620
等于它自己重新映射

47:26.620 --> 47:27.340
重新映射

47:27.900 --> 47:28.540
就是map

47:29.180 --> 47:29.580
map

47:31.900 --> 47:32.620
我写啥

47:34.140 --> 47:34.620
item

47:36.780 --> 47:37.020
好

47:37.020 --> 47:37.580
那么这里呢

47:37.580 --> 47:38.620
每一项是啥类型

47:38.620 --> 47:39.500
每一项是不是数字

47:40.780 --> 47:41.260
想一想

47:41.260 --> 47:42.300
现在这个数组呢

47:42.300 --> 47:43.260
每一项是数字吗

47:43.820 --> 47:44.860
它不是数字

47:45.420 --> 47:46.460
它每一项不是数字

47:46.460 --> 47:47.500
它是一个对象

47:47.500 --> 47:49.100
我们要取出一个对象的名字

47:49.100 --> 47:49.500
对吧

47:49.820 --> 47:50.460
返回啥

47:50.460 --> 47:51.340
这个对象的name

47:52.300 --> 47:54.060
我要把这一项

47:54.060 --> 47:54.700
这个对象

47:54.700 --> 47:56.060
每一项的对象

47:56.060 --> 47:57.260
映射成为一个字符串

47:57.260 --> 47:58.620
Name数先取出来

47:58.620 --> 47:58.860
好

47:58.860 --> 47:59.420
看一下

47:59.420 --> 48:00.460
重新给它复制

48:00.460 --> 48:01.500
重新给它复制

48:01.900 --> 48:02.060
好

48:02.060 --> 48:02.620
你看一下

48:02.620 --> 48:04.220
得到是不是一个字符串数组了

48:04.220 --> 48:05.820
就特别特别强大

48:06.220 --> 48:06.780
而且呢

48:06.780 --> 48:07.500
你想一想

48:07.500 --> 48:09.020
整个这个表达是

48:09.740 --> 48:10.860
把它看成一个整体

48:11.420 --> 48:12.220
是不是一个数组

48:12.220 --> 48:12.940
一个新的数组

48:12.940 --> 48:13.260
你看

48:13.260 --> 48:14.860
把这个新的数组复制给它嘛

48:14.860 --> 48:15.340
对吧

48:15.340 --> 48:17.100
整个这个表达是一个新的数组

48:17.100 --> 48:17.980
把它复制给它

48:17.980 --> 48:18.460
好

48:18.460 --> 48:20.220
那么既然它是一个新的数组

48:21.180 --> 48:22.780
我们是不是可以

48:23.340 --> 48:24.380
甚至把这个方过来

48:25.420 --> 48:26.140
你看

48:26.140 --> 48:27.900
先映射成为这个

48:27.900 --> 48:29.180
再映射成为这个

48:30.700 --> 48:31.420
看一下

48:31.420 --> 48:32.620
所以仍然可以得到结果

48:33.020 --> 48:33.420
对吧

48:33.420 --> 48:34.220
也可以

48:34.220 --> 48:34.860
也可以

48:35.900 --> 48:36.060
好

48:36.060 --> 48:37.260
这里这是map

48:37.260 --> 48:38.940
map我们以后用了非常非常多

48:40.860 --> 48:41.260
好

48:41.260 --> 48:41.820
下面这个

48:41.820 --> 48:42.460
下面这个

48:43.260 --> 48:44.300
reduce

48:44.300 --> 48:45.180
这个稍微复杂一点

48:45.740 --> 48:47.100
这个表示的是统计

48:48.380 --> 48:48.780
统计

48:50.700 --> 48:51.660
这个reduce

48:52.780 --> 48:53.740
reduce

48:53.740 --> 48:54.780
表示的是统计

48:55.420 --> 48:56.620
也叫做累计

48:56.620 --> 48:57.580
累计

48:57.580 --> 48:58.380
就是有的时候

48:58.380 --> 49:00.540
求合啊求急啊

49:00.540 --> 49:01.180
这些东西

49:01.180 --> 49:02.060
我们都可以用它

49:02.060 --> 49:02.860
但是这个函数呢

49:02.860 --> 49:05.100
我们以后还会有很多的

49:05.100 --> 49:06.460
很神奇的运用场景

49:07.020 --> 49:08.140
它会怎么样呢

49:08.140 --> 49:09.340
它是这样子

49:09.340 --> 49:10.620
不要拿一个数组给它

49:12.060 --> 49:13.340
你拿一个数组给它

49:13.340 --> 49:14.300
随便拿个数组给它嘛

49:16.540 --> 49:17.580
它会这样子来处理

49:23.900 --> 49:28.140
它会先把这个数组的前两项拿给你

49:29.260 --> 49:30.140
调用一个函数

49:31.660 --> 49:32.140
它会把

49:32.140 --> 49:33.740
首先要有一个函数

49:33.740 --> 49:35.100
这个函数有两个参数

49:35.820 --> 49:36.380
两个参数

49:36.860 --> 49:38.540
它会把前两项拿给你

49:39.100 --> 49:40.380
把32传给a

49:40.780 --> 49:42.060
56呢传给b

49:42.380 --> 49:43.420
然后调用这个函数

49:44.700 --> 49:46.540
然后你这个函数会返回一个结果

49:46.540 --> 49:47.100
比方说

49:47.100 --> 49:48.540
比方说你返回的是a加b

49:48.940 --> 49:50.220
比方说你返回的是a加b

49:50.700 --> 49:51.500
那它会怎么样呢

49:51.500 --> 49:52.380
它会这样来处理

49:53.260 --> 49:54.460
32传给a

49:54.460 --> 49:55.340
56传给b

49:55.340 --> 49:56.540
那你返回的是a加b

49:56.540 --> 49:57.100
我算了

49:57.100 --> 49:57.980
写小一点数字吧

49:57.980 --> 49:58.860
我这算不出来

50:02.780 --> 50:03.500
把1传给a

50:03.500 --> 50:04.300
3传给b

50:04.300 --> 50:05.020
返回a加b

50:05.020 --> 50:05.900
返回多少

50:05.900 --> 50:06.620
返回是4

50:06.620 --> 50:07.100
对吧

50:07.100 --> 50:07.580
好

50:07.580 --> 50:08.860
它接下来这样来处理

50:08.860 --> 50:09.900
把4传给a

50:11.900 --> 50:13.900
这个相加的结果4传给a

50:13.900 --> 50:15.180
然后把这个4传给b

50:15.740 --> 50:16.620
比方说这里写1嘛

50:17.180 --> 50:18.220
把这个1传给b

50:18.540 --> 50:19.580
那么4传给a

50:20.780 --> 50:21.420
1传给b

50:21.660 --> 50:23.020
就把相加的结果传给a

50:23.020 --> 50:23.820
把1传给b

50:23.820 --> 50:24.060
好

50:24.060 --> 50:24.620
相加

50:24.620 --> 50:25.580
两个又相加又返回

50:25.580 --> 50:26.540
是不是得到5

50:26.540 --> 50:27.180
对吧

50:27.180 --> 50:28.620
当这里面你可以随便写的

50:28.620 --> 50:29.340
你可以随便写

50:29.340 --> 50:30.220
不一定要相加的

50:30.700 --> 50:31.580
好得到5

50:31.580 --> 50:32.860
然后它又把5传给a

50:33.660 --> 50:34.380
然后呢

50:34.380 --> 50:35.260
又把什么

50:35.260 --> 50:36.300
2传给b

50:37.500 --> 50:38.460
相加结果是不是7

50:39.420 --> 50:40.620
然后又把7传给a

50:41.660 --> 50:42.460
5传给b

50:42.860 --> 50:44.060
相加结果是不是12

50:44.060 --> 50:44.540
好

50:44.540 --> 50:45.900
又把12传给a

50:46.700 --> 50:47.660
6传给b

50:47.660 --> 50:48.940
相加结果就是18

50:49.660 --> 50:50.460
我们可以用它

50:50.460 --> 50:51.180
利用这个东西

50:51.260 --> 50:52.380
利用这种现象

50:52.380 --> 50:53.740
来完成球合

50:54.540 --> 50:55.580
来完成球合

50:55.580 --> 50:56.540
当然呢

50:56.540 --> 50:57.500
当然

50:57.500 --> 50:59.340
我们也可以做一些球籍

50:59.340 --> 51:00.780
或者是其他东西

51:00.780 --> 51:02.140
它总之用来统计

51:02.140 --> 51:03.660
就可以使用它

51:04.380 --> 51:04.940
好吧

51:04.940 --> 51:05.660
我们来看一下

51:07.660 --> 51:08.380
TES10

51:09.420 --> 51:10.700
我们先了解一下这个函数

51:10.700 --> 51:11.100
先了解

51:11.100 --> 51:11.740
大概了解

51:11.740 --> 51:12.380
我们以后呢

51:14.060 --> 51:15.260
还有一些巧妙的用法

51:16.060 --> 51:16.140
好

51:16.140 --> 51:16.860
这里有个数

51:16.860 --> 51:17.340
数组

51:19.100 --> 51:19.740
随便

51:19.740 --> 51:19.980
2

51:19.980 --> 51:20.220
3

51:21.340 --> 51:21.740
5

51:21.740 --> 51:21.900
1

51:23.420 --> 51:23.980
55

51:23.980 --> 51:24.860
随便吧

51:24.860 --> 51:26.540
比方说对这个数组球合

51:26.540 --> 51:27.660
怎么球合呢

51:27.660 --> 51:28.620
我就可以这样子写

51:29.260 --> 51:29.980
AR

51:30.860 --> 51:31.420
reduce

51:31.980 --> 51:32.540
reduce

51:33.100 --> 51:34.380
这里面写个函数

51:34.380 --> 51:35.740
这个函数有两个参数

51:35.740 --> 51:37.420
s嘛

51:37.420 --> 51:38.300
s

51:38.300 --> 51:38.620
item

51:39.340 --> 51:40.060
前面呢

51:40.060 --> 51:40.700
第一个参数呢

51:40.700 --> 51:41.900
是累计的结果

51:41.900 --> 51:42.860
是累计的结果

51:43.500 --> 51:43.580
好

51:43.580 --> 51:44.620
累计的结果就是

51:44.620 --> 51:46.300
它先把前两项给力

51:46.300 --> 51:46.780
s

51:46.780 --> 51:47.020
2

51:47.580 --> 51:48.460
item是3

51:48.460 --> 51:49.660
比方说咱们输出嘛

51:49.660 --> 51:49.980
输出

51:50.940 --> 51:51.500
s

51:52.300 --> 51:52.940
item

51:52.940 --> 51:54.380
把这两个参数输出

51:54.380 --> 51:56.460
然后返回s加上item

51:57.260 --> 51:57.500
好

51:57.500 --> 51:57.980
看一下啊

52:01.460 --> 52:01.620
好

52:01.620 --> 52:02.660
你看一下得到的结果

52:02.660 --> 52:03.460
它运行了几次

52:03.460 --> 52:05.140
运行了四次对吧

52:05.140 --> 52:06.340
先把2,3给力

52:06.340 --> 52:06.900
对吧

52:06.900 --> 52:07.860
把2和

52:07.860 --> 52:08.820
把3给力

52:08.820 --> 52:09.780
然后输出结果

52:10.580 --> 52:11.060
然后呢

52:11.060 --> 52:12.180
就得到2和3嘛

52:12.180 --> 52:14.020
然后把2和3的结果相加

52:14.020 --> 52:15.220
相加等于解

52:15.220 --> 52:15.860
等于5

52:15.860 --> 52:16.420
对吧

52:16.420 --> 52:16.580
好

52:16.580 --> 52:18.180
又把5传给s

52:18.180 --> 52:19.860
又把4传给item

52:19.860 --> 52:20.500
看没有

52:20.500 --> 52:21.780
又把5传给s

52:21.780 --> 52:22.660
4传给item

52:22.980 --> 52:23.300
好

52:23.300 --> 52:23.700
然后呢

52:23.700 --> 52:25.300
又相加5加4等于9

52:25.300 --> 52:25.860
对吧

52:25.860 --> 52:26.580
等于9

52:26.580 --> 52:28.100
又把9传给s

52:28.100 --> 52:30.020
又把1传给item

52:30.020 --> 52:30.980
9,1

52:30.980 --> 52:32.100
相加的结果呢

52:32.100 --> 52:32.980
等于10

52:32.980 --> 52:34.660
又把10传给s

52:34.660 --> 52:36.020
最后一项55

52:36.020 --> 52:37.300
传给item

52:37.300 --> 52:38.100
那么就是

52:38.660 --> 52:40.100
相加结果就是10和55

52:40.100 --> 52:40.580
对吧

52:40.580 --> 52:41.300
最后呢

52:41.300 --> 52:42.820
累计出来就是65

52:42.820 --> 52:43.060
好

52:43.060 --> 52:43.460
最后呢

52:43.460 --> 52:44.740
它返回的结果就是最终

52:44.740 --> 52:46.180
最终最后一次返回的结果

52:47.060 --> 52:48.180
整个表达是返回的结果

52:48.180 --> 52:49.300
就是最后一次

52:49.300 --> 52:50.660
调用这个函数返回的结果

52:51.300 --> 52:51.780
保存

52:51.780 --> 52:52.420
输出看一下

52:53.060 --> 52:53.700
输出看一下

52:54.740 --> 52:55.940
你看球合

52:55.940 --> 52:57.940
从未如此简单

52:57.940 --> 52:58.980
如此方便

52:58.980 --> 53:00.260
不用去学学循环了

53:00.260 --> 53:02.100
不用去定义什么变量来

53:02.100 --> 53:04.100
自己来自己手动进行累计

53:04.100 --> 53:04.500
不用了

53:05.540 --> 53:05.700
好

53:05.700 --> 53:06.980
但是有一个问题

53:06.980 --> 53:08.020
那如果

53:08.020 --> 53:09.620
这个输出只有一箱怎么办

53:10.580 --> 53:11.780
如果只有一箱怎么办

53:12.740 --> 53:14.020
如果只有一箱的话

53:14.020 --> 53:16.100
你看一下这个函数还会不会运行

53:16.100 --> 53:18.020
咱们来看一下这个函数会不会运行

53:18.020 --> 53:18.500
s

53:18.500 --> 53:18.820
item

53:20.100 --> 53:20.820
保存看一下

53:21.460 --> 53:22.420
这个函数有没有运行

53:23.220 --> 53:24.500
这个函数它没有运行

53:24.900 --> 53:26.340
它是没有运行这个函数的

53:26.340 --> 53:27.780
它直接把这一项给力了

53:28.180 --> 53:28.820
直接给力了

53:29.460 --> 53:29.620
好

53:29.620 --> 53:30.500
如果没有了

53:30.500 --> 53:31.460
一箱都没有了

53:32.500 --> 53:33.460
我们这里再输出吧

53:34.900 --> 53:35.620
这是回调

53:38.420 --> 53:39.540
如果一箱都没有了

53:39.540 --> 53:40.180
还要爆错

53:40.180 --> 53:40.900
它要爆错

53:41.940 --> 53:44.180
但是为了应对这样的场景

53:44.660 --> 53:45.940
它支持第二个函数

53:45.940 --> 53:46.340
你看

53:46.340 --> 53:47.540
这是第一个参数

53:47.540 --> 53:48.980
第一个参数是一个函数

53:49.620 --> 53:50.820
这个reduce这个函数

53:50.820 --> 53:52.260
第一个参数是一个函数

53:52.260 --> 53:53.300
它支持第二个函数

53:53.380 --> 53:54.180
就是默认值

53:54.740 --> 53:56.340
默认值叫做初始值

53:56.740 --> 53:58.500
有了第二个参数过后不一样了

53:58.980 --> 53:59.460
不一样了

53:59.460 --> 53:59.940
你看

53:59.940 --> 54:01.700
如果数组的一项都没有的话

54:02.260 --> 54:03.780
如果数组一项都没有的话

54:04.660 --> 54:05.540
它会输出0

54:05.940 --> 54:07.060
它会输出这个默认值

54:07.060 --> 54:08.260
这个回调函数不运行

54:08.580 --> 54:09.140
不运行

54:09.140 --> 54:10.420
它会输出这个默认值

54:10.980 --> 54:12.340
如果只有一项的话

54:13.540 --> 54:13.860
你看

54:13.860 --> 54:15.540
它会运行一次回调

54:15.540 --> 54:16.340
跟之前不一样了

54:16.340 --> 54:17.460
跟之前是第一次运行

54:17.460 --> 54:18.740
就是把你前两项给力

54:18.740 --> 54:19.220
对吧

54:19.220 --> 54:20.900
那现在有了初始值之后呢

54:20.900 --> 54:21.460
它会把

54:21.780 --> 54:22.500
它会把怎么

54:23.060 --> 54:25.220
把这个初始值传给s

54:25.220 --> 54:26.580
把这个第一项传给e

54:26.580 --> 54:27.780
那后边都全一样了

54:27.780 --> 54:28.660
后边全一样了

54:29.140 --> 54:30.020
原来的意思吧

54:30.020 --> 54:31.140
如果有两项的话

54:31.140 --> 54:32.660
它回调函数会运行两次

54:32.660 --> 54:33.060
你看

54:34.100 --> 54:34.900
会运行两次

54:34.900 --> 54:36.420
这是有了初始值的情况

54:36.980 --> 54:37.940
有了初始值的话

54:37.940 --> 54:38.580
有点不一样

54:39.700 --> 54:40.980
这是关于reduce

54:40.980 --> 54:41.780
reduce

54:41.780 --> 54:42.820
关于统计函数

54:44.020 --> 54:44.420
好了

54:44.420 --> 54:45.380
二位里边还有啥呢

54:46.500 --> 54:47.140
好就没啥了

54:47.140 --> 54:47.700
就没啥了

54:48.260 --> 54:48.820
没啥了

54:49.380 --> 54:50.660
这就是二位里边

54:50.660 --> 54:51.620
这这么一些函数

54:51.620 --> 54:51.940
你看

54:51.940 --> 54:52.580
多不多

54:52.580 --> 54:52.980
很多

54:52.980 --> 54:54.980
但是这些功能非常非常强大

54:54.980 --> 54:56.580
非常非常强大

54:56.580 --> 54:57.140
而且呢

54:57.140 --> 54:59.380
我们可以利用这里边有些函数

54:59.380 --> 55:00.500
可以利用起来

55:00.500 --> 55:03.460
来实现一些特别的代码格式

55:03.460 --> 55:04.100
我们来看一下

55:04.820 --> 55:05.620
我们这里说一下

55:05.620 --> 55:06.740
这个链式编程

55:08.100 --> 55:09.060
链式编程

55:10.020 --> 55:11.060
什么样链式编程

55:11.780 --> 55:13.380
就是每一步

55:13.380 --> 55:14.340
每一个表达式

55:14.820 --> 55:16.180
你看是这样说

55:16.180 --> 55:16.660
每一个

55:17.940 --> 55:20.660
每一个函数调用

55:22.100 --> 55:24.500
返回的内形一致

55:25.060 --> 55:26.020
返回的内形一致

55:26.020 --> 55:27.620
就可以形成链式编程

55:27.620 --> 55:28.100
比方说

55:28.100 --> 55:28.740
咱们举个例子

55:32.220 --> 55:33.260
二十二还是分数

55:33.260 --> 55:34.300
还是分数

55:34.300 --> 55:35.660
三十三四四五十五

55:35.660 --> 55:36.140
六十六

55:36.780 --> 55:37.100
六十六

55:38.220 --> 55:39.180
七十七

55:39.180 --> 55:39.500
八十八

55:42.060 --> 55:43.100
比方说

55:44.380 --> 55:45.020
咱们呢

55:45.020 --> 55:48.220
要做这么一个事情

55:49.500 --> 55:51.020
先对数组

55:51.740 --> 55:53.660
进行随机排序

55:54.540 --> 55:56.060
对数组进行随机排序

55:57.020 --> 55:57.820
然后呢

55:59.100 --> 55:59.740
第二步

55:59.740 --> 56:00.140
然后

56:01.020 --> 56:01.900
筛选调

56:03.100 --> 56:03.420
就是

56:05.340 --> 56:05.980
只取

56:06.940 --> 56:08.060
及格的学生

56:09.020 --> 56:09.820
及格的分数

56:11.020 --> 56:11.740
及格的分数

56:12.460 --> 56:13.020
然后呢

56:13.740 --> 56:15.900
得到每个学生对象

56:16.460 --> 56:18.220
得到一个学生对象的数组

56:18.220 --> 56:19.260
学生对象的数组

56:19.260 --> 56:20.300
就包含学生姓名

56:21.740 --> 56:23.980
每个学生对象

56:24.940 --> 56:27.900
包含姓名和分数

56:27.900 --> 56:28.780
当学生有姓名的话

56:28.780 --> 56:30.780
就用学生一学生二这样来处理

56:31.580 --> 56:32.540
好看这个怎么做

56:32.540 --> 56:33.500
是不是要做三件事

56:34.220 --> 56:34.620
好

56:34.620 --> 56:35.740
做三件事呢

56:35.740 --> 56:37.820
我们没有必要把它写成三条语句

56:37.820 --> 56:38.780
你看着我怎么做

56:39.820 --> 56:40.380
先sort

56:41.580 --> 56:43.020
先sort排序嘛

56:43.020 --> 56:43.580
对不对

56:43.580 --> 56:44.060
排序嘛

56:45.180 --> 56:45.740
两个嘛

56:45.740 --> 56:46.620
a和b拿过来

56:46.620 --> 56:47.580
我来帮你排序

56:48.300 --> 56:48.620
好

56:49.340 --> 56:50.300
随机排序

56:50.460 --> 56:51.100
随机排序生姓

56:51.100 --> 56:52.140
我不要参数了

56:52.140 --> 56:52.380
对吧

56:52.380 --> 56:53.420
要啥参数呢

56:53.420 --> 56:54.300
要啥自行车呢

56:54.860 --> 56:55.420
不要了

56:55.420 --> 56:56.300
不要了

56:56.300 --> 56:57.580
减去0.5对吧

56:57.580 --> 56:57.980
打乱

56:57.980 --> 56:58.700
打乱这个顺序

56:59.420 --> 57:00.780
整个表达式

57:00.780 --> 57:03.900
返回的是一个排序过后的数组

57:05.180 --> 57:05.900
整个表达式

57:05.900 --> 57:07.420
返回的是个排序过后的数组

57:07.420 --> 57:08.940
那这个表达式是不是个数组

57:09.580 --> 57:10.220
是不是数组

57:10.860 --> 57:11.580
是数组呗

57:11.580 --> 57:13.020
它返回的是排序过后的数组

57:13.020 --> 57:13.820
它仍然是数组

57:14.540 --> 57:15.020
因此呢

57:15.020 --> 57:17.340
我们可以继续对这个表达式

57:17.340 --> 57:19.660
使用数组里面的方法

57:20.220 --> 57:21.180
比方说第二步做什么

57:21.980 --> 57:23.180
只取几个的学生

57:23.180 --> 57:24.140
是不是fielder

57:24.140 --> 57:24.540
筛选

57:25.660 --> 57:26.060
筛选

57:26.700 --> 57:27.820
只要及格的学生

57:28.460 --> 57:29.580
返回的是item

57:29.580 --> 57:30.460
大于等于60

57:31.100 --> 57:31.980
只要及格的学生

57:32.540 --> 57:34.940
你看先排序再筛选

57:34.940 --> 57:35.100
好

57:35.100 --> 57:35.900
筛选完了过后

57:35.900 --> 57:37.020
是不是还是一个数组

57:37.580 --> 57:38.940
得到的是筛选的结果

57:38.940 --> 57:40.300
一个新的数组

57:40.300 --> 57:41.180
筛选的结果

57:41.180 --> 57:43.820
所以我们可以对这个结果继续操作

57:43.820 --> 57:44.300
对吧

57:44.300 --> 57:44.860
map

57:44.860 --> 57:45.260
硬设

57:46.140 --> 57:47.020
硬设

57:47.020 --> 57:48.540
将这个数组里面每一项

57:48.540 --> 57:49.580
每一项是个分数

57:49.820 --> 57:50.940
硬设成为一个对象

57:50.940 --> 57:51.580
一个对象

57:51.580 --> 57:52.380
我们还需要个下标

57:53.900 --> 57:55.020
还需要个下标

57:55.020 --> 57:55.260
好

57:55.260 --> 57:56.060
返回的是什么呢

57:56.060 --> 57:57.260
返回的是学生姓名

58:01.100 --> 58:03.020
学生i加1

58:03.580 --> 58:04.060
加1

58:04.780 --> 58:05.660
这样的拼结

58:05.660 --> 58:06.700
无所谓的

58:06.700 --> 58:06.940
好

58:06.940 --> 58:07.660
学生的分数

58:08.140 --> 58:08.540
item

58:09.900 --> 58:10.220
你看

58:11.180 --> 58:13.500
整个形成了一条语句了

58:13.500 --> 58:14.220
虽然我换了

58:14.220 --> 58:15.500
但他们是一条语句

58:15.500 --> 58:16.620
最后得到结果

58:17.260 --> 58:18.220
我就避免了

58:18.300 --> 58:19.820
刀出去写这些变量

58:19.820 --> 58:21.100
没有必要去写这些变量

58:21.100 --> 58:22.300
写三条语句

58:22.300 --> 58:23.340
一条语句全部搞定

58:24.220 --> 58:24.780
就完成了

58:25.500 --> 58:26.060
又些印象

58:27.500 --> 58:27.900
你看一下

58:28.620 --> 58:29.180
得到结果

58:29.740 --> 58:30.940
顺序是随机的

58:31.580 --> 58:32.460
随机的顺序

58:32.460 --> 58:33.980
你看每一次得到结果了

58:33.980 --> 58:35.500
它的顺序的不太一样

58:35.500 --> 58:36.460
并且三选掉了

58:36.460 --> 58:37.500
就是只保留了

58:37.500 --> 58:38.460
就是及格的学生

58:39.820 --> 58:40.140
你看

58:40.860 --> 58:41.420
就搞定了

58:42.460 --> 58:42.940
没问题吧

58:43.820 --> 58:44.300
没问题

58:45.100 --> 58:45.500
这是

58:46.060 --> 58:47.180
练识编程

58:47.260 --> 58:48.380
它有个前提条件

58:48.380 --> 58:49.820
每一步返回的结果是

58:49.820 --> 58:50.860
内存是一致的

58:50.860 --> 58:52.140
它这个返回的数组

58:52.140 --> 58:52.540
对吧

58:52.540 --> 58:54.460
然后这一块返回的还是数组

58:54.460 --> 58:55.740
然后这一块返回的

58:56.300 --> 58:56.940
还是数组

58:57.500 --> 58:57.980
还是数组

58:57.980 --> 58:59.100
所以说后面我们还可以

58:59.100 --> 59:00.060
还可以继续处理

59:00.060 --> 59:01.180
还可以继续处理

59:01.980 --> 59:02.380
OK

59:02.780 --> 59:03.900
这是关于这一块

59:06.780 --> 59:07.740
数组这一块就完了

59:07.740 --> 59:08.300
就没了

59:08.300 --> 59:09.020
作业

59:09.020 --> 59:09.660
作业

59:09.660 --> 59:10.380
这一块

59:10.380 --> 59:11.660
我们要规定一些作业

59:12.940 --> 59:13.500
作业的话

59:13.500 --> 59:15.420
我这里把视频简了一下

59:15.500 --> 59:15.980
简单一下

59:15.980 --> 59:17.580
我这里复制了一下作业

59:17.580 --> 59:18.540
然后我们这里

59:19.100 --> 59:20.220
作业写下来

59:21.340 --> 59:21.980
这么一个东西

59:24.220 --> 59:25.420
有一个数组

59:25.420 --> 59:26.860
你要做的事情是

59:26.860 --> 59:28.940
去掉数组中所有的复数

59:29.580 --> 59:32.380
然后对每一项平方

59:32.380 --> 59:33.340
每一项变成

59:33.340 --> 59:35.260
就是原来的数字的平方

59:35.260 --> 59:36.940
然后再对每一项翻倍

59:36.940 --> 59:37.820
乘以二

59:37.820 --> 59:39.100
然后再求合

59:40.380 --> 59:40.780
条件

59:41.420 --> 59:43.340
不许使用循环

59:44.060 --> 59:45.020
不许使用循环

59:45.420 --> 59:47.020
必须要用数组的函数来完成

59:47.980 --> 59:48.300
好吧

59:48.940 --> 59:49.660
做一遍

59:49.660 --> 59:50.540
做一遍

59:50.540 --> 59:52.220
然后再来看我的作业讲解

59:52.780 --> 59:53.580
好吧

59:53.580 --> 59:55.660
这是关于这一张解

59:55.660 --> 59:57.180
其实你也有

59:57.180 --> 59:57.820
这一

59:57.820 --> 59:58.780
没有什么难的

59:58.780 --> 59:59.900
真的是没有什么难的

59:59.900 --> 01:00:02.300
你只要把这个数组的那些方法过一遍

01:00:02.300 --> 01:00:04.060
你就知道怎么去做了

01:00:04.060 --> 01:00:04.300
好吧

01:00:04.300 --> 01:00:05.500
我下期课来讲

