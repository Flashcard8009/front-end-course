WEBVTT

00:00.000 --> 00:03.000
数学运算符

00:03.000 --> 00:14.700
就一个一个来呗

00:14.700 --> 00:17.700
首先是算数运算符

00:17.700 --> 00:20.700
它也叫做数学运算符

00:20.700 --> 00:22.700
就加减成熟 就这些玩意儿

00:22.700 --> 00:24.700
数学运算符

00:24.700 --> 00:27.700
如果不考虑面试题的话

00:27.700 --> 00:30.700
那这个东西就非常简单了

00:30.700 --> 00:33.700
只考虑我们平常开发的话

00:33.700 --> 00:35.700
几分钟就讲完了

00:35.700 --> 00:36.700
有哪些呢

00:36.700 --> 00:38.700
我们这个罗列一下

00:38.700 --> 00:40.700
有这么一些

00:40.700 --> 00:42.700
直接写吧

00:42.700 --> 00:43.700
罗列一下

00:43.700 --> 00:45.700
第一个是加

00:45.700 --> 00:48.700
我就一起写了吧 加减成熟

00:48.700 --> 00:49.700
这么四个

00:49.700 --> 00:50.700
注意这个符号

00:50.700 --> 00:52.700
这个符号是除号

00:52.700 --> 00:53.700
这个符号是除号

00:53.700 --> 00:55.700
我这里把它放到代码格式里边吧

00:55.700 --> 00:59.520
加减成熟是四个

00:59.520 --> 01:01.520
然后呢 还有哪些呢

01:01.520 --> 01:03.520
还有就是

01:03.520 --> 01:04.520
加和减

01:04.520 --> 01:05.520
为什么单独列出来了

01:05.520 --> 01:07.520
因为它是放到数字前

01:07.520 --> 01:08.520
是正数和复数

01:08.520 --> 01:10.520
这样子也是一种

01:10.520 --> 01:11.520
还有什么呢

01:11.520 --> 01:13.520
还有就是

01:13.520 --> 01:16.520
求余数

01:16.520 --> 01:17.520
还有什么呢

01:17.520 --> 01:19.520
还有就是

01:19.520 --> 01:20.520
想想

01:20.520 --> 01:22.520
加加减减

01:22.520 --> 01:23.520
这个比较复杂一点

01:23.520 --> 01:24.520
加加减减

01:24.520 --> 01:25.520
后面我会专门哪一节课

01:25.520 --> 01:26.520
这节课完了之后

01:26.520 --> 01:28.520
我会专门哪一节课来讲加加减减

01:28.520 --> 01:30.520
这节课我们先不讲

01:30.520 --> 01:32.520
下节课

01:32.520 --> 01:34.520
讨论

01:34.520 --> 01:35.520
这节课先不讲

01:35.520 --> 01:37.520
然后还有啥呢

01:37.520 --> 01:39.520
加

01:39.520 --> 01:41.520
加减成熟加减

01:41.520 --> 01:43.520
还有两个乘号

01:43.520 --> 01:46.520
这个表示指数

01:46.520 --> 01:48.520
就没了

01:48.520 --> 01:49.520
数学运算符就这么一些了

01:49.520 --> 01:50.520
数一下几个

01:50.520 --> 01:53.520
一二三四五六七八九十

01:53.520 --> 01:54.520
一共十个

01:54.520 --> 01:55.520
对了 我印象中是

01:55.520 --> 01:57.520
数学运算符就十个

01:57.520 --> 01:58.520
好 我一个个来吧

01:58.520 --> 01:59.520
先说基本用法

01:59.520 --> 02:00.520
基本用法

02:00.520 --> 02:02.520
一个是加减成熟

02:02.520 --> 02:03.520
没啥好说的

02:03.520 --> 02:05.520
我们先来看一下吧

02:05.520 --> 02:07.520
加减成熟

02:07.520 --> 02:09.520
test

02:09.520 --> 02:12.520
我们直接在网站里面

02:12.520 --> 02:14.520
直接在控制台里面写了

02:14.520 --> 02:15.520
直接写

02:15.520 --> 02:17.520
右键运行出来

02:17.520 --> 02:19.520
这个没啥好说的

02:19.520 --> 02:20.520
我们就直接写了

02:20.520 --> 02:24.150
刷新

02:24.150 --> 02:25.150
加法呗

02:25.150 --> 02:26.150
就是一加二

02:26.150 --> 02:27.150
你看得予三

02:27.150 --> 02:28.150
没啥好说的

02:28.150 --> 02:30.150
或者是用变量相加

02:30.150 --> 02:32.150
A比方说等于3

02:32.150 --> 02:33.150
B等于5

02:33.150 --> 02:35.150
然后两个变量相加

02:35.150 --> 02:36.150
A加B

02:36.150 --> 02:37.150
A加B

02:37.150 --> 02:38.150
你看 说等于8

02:38.150 --> 02:39.150
对不对

02:39.150 --> 02:40.150
没啥好说的

02:40.150 --> 02:41.150
非常非常简单

02:41.150 --> 02:42.150
这是加号

02:42.150 --> 02:44.150
那么减法了是不是一样的

02:44.150 --> 02:46.150
以减1等于0

02:46.150 --> 02:48.150
然后乘法了

02:48.150 --> 02:49.150
二乘以3

02:49.150 --> 02:51.150
乘法是个新号

02:51.150 --> 02:52.150
二乘以3等于6

02:52.150 --> 02:53.150
没啥好说的

02:53.150 --> 02:54.150
非常非常简单

02:54.150 --> 02:57.150
比方说富二乘以3.5

02:57.150 --> 02:58.150
随便写

02:58.150 --> 02:59.150
就是富7

02:59.150 --> 03:00.150
富7

03:00.150 --> 03:01.150
很简单

03:01.150 --> 03:02.150
没啥好说的

03:02.150 --> 03:03.150
清空

03:03.150 --> 03:04.150
好 除法呢

03:04.150 --> 03:07.150
除法就是二除以3

03:07.150 --> 03:08.150
二除以3就这个玩意

03:08.150 --> 03:09.150
是这个玩意

03:09.150 --> 03:11.150
四除以5就这个玩意

03:11.150 --> 03:12.150
就这个玩意

03:12.150 --> 03:13.150
好 这里呢

03:13.150 --> 03:15.150
我们有一个点

03:15.150 --> 03:17.150
有个细节来说一下

03:17.150 --> 03:18.150
我们就说

03:18.150 --> 03:19.150
先说细节

03:19.150 --> 03:20.150
就是细节

03:20.150 --> 03:22.150
有很多很多细节

03:22.150 --> 03:24.150
这里面很多很多细节

03:24.150 --> 03:26.150
在数学运算过程中

03:26.150 --> 03:28.150
小数运算

03:28.150 --> 03:31.150
小数运算

03:32.150 --> 03:34.150
是不精确的

03:34.150 --> 03:37.740
是不精确的

03:37.740 --> 03:39.740
计算机里边小数运算

03:39.740 --> 03:40.740
在任何语言里边

03:40.740 --> 03:41.740
都有这个问题

03:41.740 --> 03:42.740
都有这个问题

03:42.740 --> 03:43.740
这个问题到底是怎么发生呢

03:43.740 --> 03:45.740
我后边打算做一节

03:45.740 --> 03:46.740
扩展课程

03:46.740 --> 03:48.740
有兴趣的同学能了解一下

03:48.740 --> 03:50.740
当然那个东西是比较复杂的

03:50.740 --> 03:51.740
比较复杂的

03:51.740 --> 03:53.740
跟计算机存储数据有关系

03:53.740 --> 03:55.740
小数的存储呢

03:55.740 --> 03:57.740
在阶矢里面存储的时候

03:57.740 --> 03:58.740
是有些不一样的

03:58.740 --> 03:59.740
其实阶矢是存储数字呢

03:59.740 --> 04:01.740
它有一个统一的存储方案

04:01.740 --> 04:02.740
在有些语言里边

04:03.740 --> 04:05.740
它小数的存储跟整数的存储

04:05.740 --> 04:06.740
是不一样的

04:06.740 --> 04:07.740
它是不一样的

04:07.740 --> 04:08.740
但是在阶矢里面是一样的

04:08.740 --> 04:10.740
它都是按照小数的存储方案

04:10.740 --> 04:11.740
来进行存储

04:11.740 --> 04:12.740
因此呢

04:12.740 --> 04:14.740
阶矢里面数字的运算

04:14.740 --> 04:15.740
我们可以直接说

04:15.740 --> 04:17.740
阶矢里面的数字运算

04:17.740 --> 04:18.740
是不精确的

04:18.740 --> 04:19.740
在别的语言里边

04:19.740 --> 04:20.740
我们就可以说

04:20.740 --> 04:21.740
小数运算是不精确的

04:21.740 --> 04:22.740
比方说

04:22.740 --> 04:23.740
这几个例子吧

04:23.740 --> 04:24.740
几个例子

04:24.740 --> 04:25.740
比方说这里呢

04:25.740 --> 04:26.740
5.3

04:26.740 --> 04:27.740
减缺5.2

04:27.740 --> 04:28.740
你看一下

04:28.740 --> 04:30.740
本来应该是等于0.1的

04:30.740 --> 04:31.740
对吧

04:31.740 --> 04:32.740
等于0.1

04:32.740 --> 04:33.740
它等于这个玩意

04:33.740 --> 04:34.740
看了没

04:34.740 --> 04:35.740
比方说5.4

04:35.740 --> 04:36.740
减缺5.3

04:36.740 --> 04:37.740
它等于这个玩意

04:37.740 --> 04:38.740
看没

04:38.740 --> 04:39.740
运算是不精确的

04:39.740 --> 04:41.740
它的运算不精确

04:41.740 --> 04:42.740
那么这种不精确

04:42.740 --> 04:43.740
它其实影响很小

04:43.740 --> 04:44.740
非常非常小

04:44.740 --> 04:45.740
你看

04:45.740 --> 04:46.740
它一精确到很多很多位了

04:46.740 --> 04:47.740
对吧

04:47.740 --> 04:49.740
那么是基本上一个进士值

04:49.740 --> 04:50.740
一个进士值

04:50.740 --> 04:51.740
这没办法

04:51.740 --> 04:52.740
没办法

04:52.740 --> 04:54.740
如果你要去做一个精确运算的话

04:54.740 --> 04:56.740
你需要获得一些额外的代价

04:56.740 --> 04:58.740
你需要付出一些额外的代价

04:58.740 --> 04:59.740
所以说

04:59.740 --> 05:00.740
你要跟你做这样的事情

05:00.740 --> 05:01.740
它就保持它的不精确

05:01.740 --> 05:02.740
我们后边呢

05:02.740 --> 05:04.740
会专门来解扩展课程来讲

05:04.740 --> 05:05.740
它为什么不精确

05:05.740 --> 05:07.740
到底是什么原因导致的

05:07.740 --> 05:08.740
这是关于

05:08.740 --> 05:09.740
第一个细节

05:09.740 --> 05:10.740
第一个细节

05:10.740 --> 05:12.740
数字运算是不精确的

05:12.740 --> 05:14.740
第二个细节呢

05:14.740 --> 05:15.740
第一个细节

05:15.740 --> 05:16.740
我说一下

05:16.740 --> 05:18.740
就是关于这个

05:18.740 --> 05:20.740
就是

05:20.740 --> 05:21.740
除数为0

05:21.740 --> 05:23.740
除数为0

05:23.740 --> 05:25.740
除数为0

05:25.740 --> 05:26.740
什么意思呢

05:26.740 --> 05:27.740
就这个玩意

05:27.740 --> 05:29.740
1除10

05:29.740 --> 05:31.740
那么当除数为0的时候呢

05:31.740 --> 05:32.740
它这个时候呢

05:32.740 --> 05:33.740
得到了一个结果

05:33.740 --> 05:34.740
你想啊

05:34.740 --> 05:36.740
除数为0是不是无穷大

05:36.740 --> 05:37.740
对吧

05:37.740 --> 05:39.740
计算机里面是没法表示无穷大的

05:39.740 --> 05:41.740
没法表示无穷大的个数

05:41.740 --> 05:42.740
于是呢

05:42.740 --> 05:43.740
它用一个关键字来表示

05:43.740 --> 05:44.740
叫做infinity

05:44.740 --> 05:46.740
就表示无穷大的意思

05:46.740 --> 05:47.740
这个单词呢

05:47.740 --> 05:48.740
就表示无穷大的意思

05:48.740 --> 05:49.740
除数为0的时候

05:49.740 --> 05:51.740
如果被除数

05:51.740 --> 05:53.740
如果被除数

05:53.740 --> 05:55.740
是正数

05:56.740 --> 05:58.740
正数得到结果

05:58.740 --> 06:00.740
无穷infinity

06:00.740 --> 06:02.740
infinity

06:02.740 --> 06:04.740
得到结果正无穷

06:04.740 --> 06:06.740
这个表示的是正无穷的意思

06:06.740 --> 06:08.740
它不是一个字不串哦

06:08.740 --> 06:09.740
注意

06:09.740 --> 06:10.740
它不是一个字不串

06:10.740 --> 06:12.740
它仍然是一个数字

06:12.740 --> 06:14.740
它仍然是一个数字

06:14.740 --> 06:15.740
好

06:15.740 --> 06:16.740
我们来看一下吧

06:16.740 --> 06:17.740
看一下

06:17.740 --> 06:19.740
比方说我们Type

06:19.740 --> 06:20.740
Type有两种用法

06:20.740 --> 06:22.740
一种是直接加个空格

06:22.740 --> 06:23.740
然后写上的东西

06:23.740 --> 06:24.740
infinity

06:24.740 --> 06:25.740
得到结果内情

06:25.740 --> 06:26.740
是不是Number

06:26.740 --> 06:27.740
这是一种用法

06:27.740 --> 06:28.740
Type我们之前

06:28.740 --> 06:29.740
还没有说对吧

06:29.740 --> 06:30.740
还有另外一种用法

06:30.740 --> 06:31.740
就把它当成函数调用

06:31.740 --> 06:32.740
给它两个小括号

06:32.740 --> 06:34.740
小括号里边写上infinity

06:34.740 --> 06:35.740
是不是一样的

06:35.740 --> 06:36.740
infinity

06:36.740 --> 06:37.740
你看

06:37.740 --> 06:39.740
正无穷仍然是数字

06:39.740 --> 06:40.740
它仍然是数字内心

06:40.740 --> 06:41.740
它是一个特殊的字

06:41.740 --> 06:42.740
因为计算机里边

06:42.740 --> 06:44.740
它没法表示正无穷

06:44.740 --> 06:46.740
正无穷这东西怎么表示呢

06:46.740 --> 06:47.740
计算机的存住空间

06:47.740 --> 06:48.740
就那么大

06:48.740 --> 06:50.740
它不可能存一个无限的数字

06:50.740 --> 06:51.740
存不了的

06:51.740 --> 06:52.740
所以说它就用一个

06:52.740 --> 06:55.740
特殊的字符来表示infinity

06:55.740 --> 06:56.740
它仍然是数字内心

06:56.740 --> 06:58.740
比方说我们这样子写也可以

06:58.740 --> 06:59.740
Type 1除以0

06:59.740 --> 07:00.740
看一下内箱

07:00.740 --> 07:02.740
看一下这个表达式的内箱

07:02.740 --> 07:03.740
是Number

07:03.740 --> 07:04.740
这里顺便说一句

07:04.740 --> 07:06.740
如果你这样子写的话

07:06.740 --> 07:08.740
如果你这样子写的话有问题

07:08.740 --> 07:10.740
为什么有问题呢

07:10.740 --> 07:12.740
这样子写为什么会有问题呢

07:12.740 --> 07:13.740
因为你这样子写的话

07:13.740 --> 07:14.740
它认为是这样子

07:14.740 --> 07:16.740
把这个表达式

07:16.740 --> 07:18.740
把这个表达式

07:18.740 --> 07:20.740
除以0

07:20.740 --> 07:22.740
它只是把这个表达式除以0

07:22.740 --> 07:23.740
那么得到不一样的结果

07:23.740 --> 07:24.740
得到的是NAN

07:24.740 --> 07:26.740
我们一会再说NAN

07:26.740 --> 07:28.740
一会再说NAN

07:28.740 --> 07:32.740
这是关于infinity

07:32.740 --> 07:35.740
如果

07:35.740 --> 07:37.740
倍除数

07:37.740 --> 07:40.740
倍除数是负数

07:40.740 --> 07:41.740
如果是负数

07:41.740 --> 07:43.740
得到的结果

07:43.740 --> 07:44.740
是什么呢

07:44.740 --> 07:46.740
负的infinity

07:46.740 --> 07:48.740
infinity是个无穷

07:48.740 --> 07:51.740
符号叫做负无穷

07:51.740 --> 07:53.740
负无穷

07:53.740 --> 07:55.740
咱们来看一下

07:55.740 --> 07:56.740
如果这里是负数

07:56.740 --> 07:58.740
负1除以0

07:58.740 --> 08:00.740
你看负的infinity

08:00.740 --> 08:01.740
当然它是不是数字

08:01.740 --> 08:02.740
它还是个数字

08:02.740 --> 08:03.740
它还是个数字

08:03.740 --> 08:06.740
Type 5负的infinity

08:06.740 --> 08:08.740
你看内箱还是数字

08:08.740 --> 08:09.740
只是一个特殊的数字

08:09.740 --> 08:11.740
表示的是负无穷大

08:11.740 --> 08:13.740
负无穷大

08:13.740 --> 08:14.740
那么咱们再来看一下

08:14.740 --> 08:16.740
0除以0呢

08:16.740 --> 08:17.740
0除以0

08:17.740 --> 08:18.740
看是啥呢

08:18.740 --> 08:20.740
它得到的结果是NAN

08:20.740 --> 08:22.740
咱们记一笔

08:22.740 --> 08:28.740
如果倍除数是0

08:28.740 --> 08:31.740
得到结果NAN

08:31.740 --> 08:33.740
NAN它也是一个数字

08:33.740 --> 08:38.740
表示的是not a number

08:38.740 --> 08:41.740
表示的是非数字

08:41.740 --> 08:44.740
是在数字的领域里边

08:44.740 --> 08:45.740
不是一个数字

08:45.740 --> 08:46.740
它没有超数字

08:46.740 --> 08:48.740
整个大的范畴

08:48.740 --> 08:50.740
这个地方就很怪

08:50.740 --> 08:52.740
感觉上NAN not a number

08:52.740 --> 08:53.740
不是数字

08:53.740 --> 08:54.740
说好了不是数字

08:54.740 --> 08:56.740
但是它说的不是数字

08:56.740 --> 08:58.740
指的是不是一个正常的数字

08:58.740 --> 08:59.740
没法求

08:59.740 --> 09:01.740
这个东西没法求出结果

09:01.740 --> 09:02.740
not a number

09:02.740 --> 09:03.740
表示非数字

09:03.740 --> 09:05.740
但是非数字仍然是一个数字

09:05.740 --> 09:06.740
大家看一下

09:06.740 --> 09:08.740
非数字仍然是一个数字

09:08.740 --> 09:11.740
我们比较说Type NAN

09:11.740 --> 09:12.740
你看

09:12.740 --> 09:13.740
内箱是不是还是number

09:13.740 --> 09:15.740
也就是说数字里边

09:15.740 --> 09:16.740
是有三个特殊值的

09:16.740 --> 09:17.740
正无穷

09:17.740 --> 09:19.740
负无穷和NAN

09:19.740 --> 09:23.740
比方说0除10就是个NAN

09:23.740 --> 09:25.740
刚才我们看到这么一个东西

09:25.740 --> 09:27.740
Type 1除10

09:27.740 --> 09:29.740
为什么也是NAN呢

09:29.740 --> 09:30.740
因为它是这样理解的

09:30.740 --> 09:31.740
它是指的是

09:31.740 --> 09:33.740
把这个表达式除10

09:33.740 --> 09:35.740
而这个表达式的结果是啥呢

09:35.740 --> 09:37.740
Type 1的表达式的结果是啥呢

09:37.740 --> 09:39.740
是一个制服串

09:39.740 --> 09:41.740
我们顺便记一笔

09:41.740 --> 09:43.740
Type

09:43.740 --> 09:44.740
这也是个函数

09:44.740 --> 09:45.740
它是个函数

09:45.740 --> 09:46.740
怎么这个函数呢

09:46.740 --> 09:47.740
它有一种特殊的语法

09:47.740 --> 09:49.740
就是你可以直接加空格写

09:49.740 --> 09:52.740
一般函数的话都要加小扩号的

09:52.740 --> 09:53.740
这个函数呢

09:53.740 --> 09:55.740
返回结果

09:55.740 --> 09:56.740
返回结果

09:56.740 --> 09:58.740
就是返回值

09:58.740 --> 10:00.740
返回内形

10:00.740 --> 10:01.740
返回内形

10:01.740 --> 10:02.740
返回制服串

10:02.740 --> 10:03.740
返回stune

10:03.740 --> 10:04.740
它是个制服串

10:04.740 --> 10:05.740
那你想

10:05.740 --> 10:07.740
一个制服串处于数字怎么处呢

10:07.740 --> 10:08.740
是不是没法处

10:08.740 --> 10:09.740
对不对

10:09.740 --> 10:11.740
这个制服串是没法处于一个数字的

10:11.740 --> 10:13.740
所以得到结果NAN

10:13.740 --> 10:14.740
咱们来看一下

10:14.740 --> 10:17.740
比方说Type 1处于1

10:17.740 --> 10:18.740
你怎么理解这句话呢

10:18.740 --> 10:21.740
你可以先把Type 1算出来

10:21.740 --> 10:23.740
这个表达式算出来得到结果是什么

10:23.740 --> 10:25.740
一个制服串Number

10:25.740 --> 10:27.740
把这个Number去处于1

10:27.740 --> 10:28.740
你说等于什么

10:28.740 --> 10:29.740
你告诉我等于什么

10:29.740 --> 10:31.740
如果要算的话等于啥

10:31.740 --> 10:32.740
没法算

10:32.740 --> 10:33.740
它没法算

10:33.740 --> 10:35.740
所以说得到结果是NAN

10:35.740 --> 10:38.740
这是除数为0的情况

10:38.740 --> 10:40.740
有很多很多的细节

10:40.740 --> 10:42.740
两边的事情都可能会考到的

10:42.740 --> 10:44.740
好

10:44.740 --> 10:46.740
这是加渐成熟

10:46.740 --> 10:48.740
然后前面加正号加富号

10:48.740 --> 10:49.740
这个没啥好说的吧

10:49.740 --> 10:50.740
正号富号

10:50.740 --> 10:52.740
表示正数还是富数

10:52.740 --> 10:53.740
比较正义

10:53.740 --> 10:54.740
正义就是1

10:54.740 --> 10:57.740
富1就是富1

10:57.740 --> 10:59.740
没啥好说的

10:59.740 --> 11:01.740
前面加富号

11:01.740 --> 11:04.740
下边这个是求于

11:04.740 --> 11:05.740
求于数

11:05.740 --> 11:06.740
什么叫求于数呢

11:06.740 --> 11:08.740
叫求于运算幅

11:08.740 --> 11:10.740
这里我顺便说一下

11:10.740 --> 11:11.740
第三个点

11:11.740 --> 11:13.740
是关于求于

11:13.740 --> 11:16.740
求于数

11:16.740 --> 11:17.740
求于

11:17.740 --> 11:19.740
这个运算幅是个百分号

11:19.740 --> 11:21.740
百分号叫做求于运算幅

11:21.740 --> 11:22.740
就是有的教程里面

11:22.740 --> 11:25.740
把它叫做求模

11:25.740 --> 11:27.740
有的教程

11:27.740 --> 11:30.740
称之为求模

11:30.740 --> 11:33.740
其实求模和求于是有区别的

11:33.740 --> 11:35.740
他们是有一些细微的区别的

11:35.740 --> 11:37.740
只不过对于我们来说

11:37.740 --> 11:39.740
绝大部分时候

11:39.740 --> 11:41.740
可以说99%的时候

11:41.740 --> 11:42.740
他们都没有啥区别

11:42.740 --> 11:43.740
所以说我们可以认为

11:43.740 --> 11:44.740
这两个是一样的

11:44.740 --> 11:45.740
实际上是不一样的

11:45.740 --> 11:47.740
我这里还是严格区分一下

11:47.740 --> 11:48.740
它叫做求于

11:48.740 --> 11:50.740
那么关于什么叫求模的话

11:50.740 --> 11:52.740
后面有个扩展特成

11:52.740 --> 11:53.740
大家去了解一下就行了

11:53.740 --> 11:54.740
关于什么是求模

11:54.740 --> 11:56.740
其实也不难

11:56.740 --> 11:58.740
那么我们称之为求于

11:58.740 --> 11:59.740
就是于数

11:59.740 --> 12:02.740
比方说5除1,2的于数是多少呢

12:02.740 --> 12:04.740
如果要整除的话

12:04.740 --> 12:06.740
除于2的于数是多少呢

12:06.740 --> 12:08.740
是不是2于上1

12:08.740 --> 12:10.740
它的伤势2

12:10.740 --> 12:12.740
然后于1

12:12.740 --> 12:14.740
如果你直接这样相处的话

12:14.740 --> 12:16.740
就等于2.5

12:16.740 --> 12:18.740
那么如果你使用

12:18.740 --> 12:20.740
求于运算符的话

12:20.740 --> 12:21.740
得到结果是什么

12:21.740 --> 12:22.740
就是于数1

12:22.740 --> 12:23.740
那明白吧

12:23.740 --> 12:24.740
没问题吧

12:24.740 --> 12:25.740
表示于数1

12:25.740 --> 12:27.740
这个玩意还蛮有用的

12:27.740 --> 12:28.740
后边我们做一些东西的时候

12:28.740 --> 12:29.740
做些效果的时候

12:29.740 --> 12:30.740
还蛮有用的

12:30.740 --> 12:33.740
比方说

12:34.740 --> 12:35.740
咱们呢

12:35.740 --> 12:36.740
我们再写一个

12:36.740 --> 12:38.740
10除1

12:38.740 --> 12:40.740
2的于数

12:40.740 --> 12:41.740
你看下面已经出来了

12:41.740 --> 12:42.740
对吧

12:42.740 --> 12:43.740
都已经出来了

12:43.740 --> 12:44.740
2的于数是多少呢

12:44.740 --> 12:45.740
于0

12:45.740 --> 12:46.740
为什么于0呢

12:46.740 --> 12:47.740
它的伤势多少

12:47.740 --> 12:48.740
伤势就是5

12:48.740 --> 12:49.740
对吧

12:49.740 --> 12:50.740
伤势5是不是刚好除进

12:50.740 --> 12:51.740
对不对

12:51.740 --> 12:52.740
那么就于数为0

12:52.740 --> 12:53.740
于数为0

12:53.740 --> 12:54.740
就这么简单

12:54.740 --> 12:55.740
可不可以写小数呢

12:55.740 --> 12:56.740
可以写小数

12:56.740 --> 12:58.740
但是不建议大家去写这个小数

12:58.740 --> 13:00.740
不建议大家去写这个小数

13:00.740 --> 13:01.740
写这个小数

13:01.740 --> 13:03.740
反而容易造成混乱

13:03.740 --> 13:04.740
容易造成混乱

13:04.740 --> 13:05.740
写小数的过后

13:05.740 --> 13:06.740
还会造成一些问题

13:06.740 --> 13:07.740
就是不精确

13:07.740 --> 13:08.740
结果不精确

13:08.740 --> 13:11.740
那么除以2.2的于数是多少呢

13:11.740 --> 13:12.740
除以2.2的于数

13:12.740 --> 13:13.740
你要这样子算

13:13.740 --> 13:14.740
你要这样子算

13:14.740 --> 13:16.740
那么它的伤势多少呢

13:16.740 --> 13:18.740
伤势多少

13:18.740 --> 13:20.740
伤势4

13:20.740 --> 13:21.740
伤势4

13:21.740 --> 13:22.740
那么4的话

13:22.740 --> 13:23.740
4乘以2.2

13:23.740 --> 13:24.740
多少

13:24.740 --> 13:25.740
8.8

13:25.740 --> 13:26.740
8.8

13:26.740 --> 13:27.740
5的话就多了

13:27.740 --> 13:28.740
4乘以2.2

13:28.740 --> 13:29.740
就是8.8

13:29.740 --> 13:30.740
10减去8.8

13:30.740 --> 13:31.740
就是1.2

13:31.740 --> 13:32.740
应该等于1.2

13:32.740 --> 13:34.740
但是小数的运算呢

13:34.740 --> 13:35.740
它是不精确的

13:35.740 --> 13:36.740
它有可能会造成不精确

13:36.740 --> 13:38.740
但不一定是每次都不精确

13:38.740 --> 13:40.740
有的时候又是精确的

13:40.740 --> 13:41.740
所以说这一块呢

13:41.740 --> 13:42.740
如果想了解的话

13:42.740 --> 13:43.740
去看一下

13:43.740 --> 13:44.740
关于计算机的

13:44.740 --> 13:46.740
就是小数的存处方式

13:46.740 --> 13:48.740
我后面有一个扩展课程

13:48.740 --> 13:49.740
那么应该是1.2

13:49.740 --> 13:50.740
你看现在是不是也得有1.2

13:50.740 --> 13:52.740
通常不要用求于去求

13:52.740 --> 13:53.740
什么小数

13:53.740 --> 13:55.740
通常不要去加入小数

13:55.740 --> 13:56.740
这是求于

13:56.740 --> 13:57.740
求于的时候

13:57.740 --> 13:58.740
有个细节

13:58.740 --> 13:59.740
为什么把它归到细节里边呢

13:59.740 --> 14:01.740
因为它这里有个细节

14:01.740 --> 14:03.740
就是背处数

14:03.740 --> 14:06.740
就是于数

14:06.740 --> 14:09.740
于数的符号

14:09.740 --> 14:11.740
就是它是正数还是复数

14:11.740 --> 14:12.740
取决于

14:12.740 --> 14:13.740
应该说

14:13.740 --> 14:15.740
于背处数

14:15.740 --> 14:17.740
背处数相同

14:17.740 --> 14:19.740
于背处数相同

14:19.740 --> 14:20.740
什么意思呢

14:20.740 --> 14:21.740
比方说

14:21.740 --> 14:23.740
10除13

14:23.740 --> 14:24.740
除13的于数

14:24.740 --> 14:25.740
多少 1 对吧

14:25.740 --> 14:26.740
1

14:26.740 --> 14:27.740
如果是复10除13的于数呢

14:27.740 --> 14:29.740
它就是复1

14:29.740 --> 14:31.740
跟处数没有任何关系

14:31.740 --> 14:33.740
比方说10除13的于数

14:33.740 --> 14:34.740
还是1

14:34.740 --> 14:35.740
跟处数没有任何关系

14:35.740 --> 14:37.740
如果你想了解更多

14:37.740 --> 14:39.740
为什么是这样子的话

14:39.740 --> 14:40.740
看一下扩展课程

14:40.740 --> 14:42.740
关于求模和求于的区别

14:42.740 --> 14:44.740
求模就不一样了

14:44.740 --> 14:45.740
然后10

14:45.740 --> 14:46.740
除1

14:46.740 --> 14:47.740
比方说复10

14:47.740 --> 14:48.740
除1 复3

14:48.740 --> 14:49.740
还是复数

14:49.740 --> 14:51.740
它只跟背处数有关系

14:51.740 --> 14:53.740
只跟背处数有关系

14:53.740 --> 14:55.740
这个东西我们也不这么用

14:55.740 --> 14:57.740
就怕面试题的时候会考到

14:57.740 --> 14:58.740
就怕面试题会考到

14:58.740 --> 15:00.740
所以说我这里也把出来说一下

15:00.740 --> 15:01.740
这是关于求于

15:01.740 --> 15:02.740
很简单

15:02.740 --> 15:03.740
加加简简

15:03.740 --> 15:05.740
我们下几个讨论

15:05.740 --> 15:07.740
第五个指数

15:07.740 --> 15:09.740
指数

15:09.740 --> 15:11.740
指数其实没有啥细节

15:11.740 --> 15:12.740
就指数

15:12.740 --> 15:14.740
指数的话指的是这样子

15:14.740 --> 15:16.740
比方说

15:16.740 --> 15:18.740
5

15:18.740 --> 15:20.740
5的平方

15:20.740 --> 15:21.740
能看懂吗

15:21.740 --> 15:23.740
5的平方

15:23.740 --> 15:24.740
25

15:24.740 --> 15:25.740
3次方

15:25.740 --> 15:26.740
125

15:26.740 --> 15:27.740
这就是指数

15:27.740 --> 15:28.740
没啥说的吧

15:28.740 --> 15:30.740
应该没啥说的吧

15:30.740 --> 15:32.740
比方说复的平方

15:32.740 --> 15:35.740
看一下什么错

15:35.740 --> 15:39.740
明白了

15:39.740 --> 15:40.740
它指的是

15:40.740 --> 15:42.740
就是前边有复号

15:42.740 --> 15:44.740
它有一个优先级的问题

15:44.740 --> 15:45.740
因为我们知道

15:45.740 --> 15:47.740
在数学运算的时候有优先级

15:47.740 --> 15:49.740
惩罚

15:49.740 --> 15:50.740
这个不要求指数

15:50.740 --> 15:52.740
应该叫做求B

15:52.740 --> 15:54.740
B

15:54.740 --> 15:56.740
B运算

15:56.740 --> 15:58.740
仰B等B

15:58.740 --> 16:00.740
B运算

16:00.740 --> 16:02.740
这个不叫求指数

16:02.740 --> 16:03.740
叫B运算

16:03.740 --> 16:04.740
指数是这个玩意

16:04.740 --> 16:05.740
B运算

16:05.740 --> 16:06.740
在B运算的时候

16:06.740 --> 16:08.740
B运算的优先级很高

16:08.740 --> 16:09.740
而这个复号

16:09.740 --> 16:11.740
前面这个符号的优先级也很高

16:11.740 --> 16:12.740
它说你这样写代码

16:12.740 --> 16:13.740
容易造成奇异

16:13.740 --> 16:14.740
非常容易造成奇异

16:14.740 --> 16:15.740
所以说它不允许你这样子写

16:15.740 --> 16:16.740
它不知道

16:16.740 --> 16:17.740
它分不清楚了

16:17.740 --> 16:19.740
它现在应该先求B

16:19.740 --> 16:21.740
5的2次方求R

16:21.740 --> 16:22.740
再加复号

16:22.740 --> 16:23.740
还是说

16:23.740 --> 16:25.740
你先把这个复5进行2次方

16:25.740 --> 16:26.740
它分不清楚了

16:26.740 --> 16:27.740
所以说

16:27.740 --> 16:29.740
它要让你加上小扩号

16:29.740 --> 16:30.740
加上小扩号

16:30.740 --> 16:32.740
这个单词的意思就是小扩号的意思

16:32.740 --> 16:33.740
扩号运算符

16:33.740 --> 16:34.740
好

16:34.740 --> 16:35.740
那么我们这里可以这样子写

16:35.740 --> 16:39.740
复5的平方

16:39.740 --> 16:40.740
25

16:40.740 --> 16:43.740
加上复5的3次方

16:43.740 --> 16:44.740
3次方

16:44.740 --> 16:45.740
125

16:45.740 --> 16:46.740
复了125

16:46.740 --> 16:47.740
我们在数学里边

16:47.740 --> 16:48.740
是不是也是用小扩号

16:48.740 --> 16:49.740
来改变优先级

16:49.740 --> 16:50.740
算啥再算啥

16:50.740 --> 16:51.740
就这么简单

16:51.740 --> 16:53.740
是不是说完了

16:53.740 --> 16:54.740
就说完了

16:54.740 --> 16:56.740
如果不考虑面试题

16:56.740 --> 16:57.740
OK

16:57.740 --> 16:59.740
咱们只需要知道这些就行了

16:59.740 --> 17:00.740
够了

17:00.740 --> 17:02.740
知道这些就够了

17:02.740 --> 17:03.740
还有一个东西

17:03.740 --> 17:04.740
还有一个东西

17:04.740 --> 17:05.740
说到NAN

17:05.740 --> 17:07.740
说到NAN的话

17:07.740 --> 17:09.740
我们这里有一个

17:09.740 --> 17:11.740
就是有一个

17:11.740 --> 17:13.740
函数

17:13.740 --> 17:15.740
有一个函数要说一下

17:15.740 --> 17:18.740
意思NAN函数

17:19.740 --> 17:20.740
这个函数

17:20.740 --> 17:21.740
该函数

17:21.740 --> 17:24.740
用于判断一个数据

17:24.740 --> 17:26.740
是否是NAN

17:26.740 --> 17:27.740
这个函数

17:27.740 --> 17:28.740
了解一下这个函数

17:28.740 --> 17:30.740
这个函数可以判断一个数据

17:30.740 --> 17:31.740
是不是NAN

17:31.740 --> 17:32.740
刚才没说到

17:32.740 --> 17:33.740
把补充一下

17:33.740 --> 17:35.740
意思NAN

17:35.740 --> 17:36.740
你看这个函数

17:36.740 --> 17:37.740
然后调用的时候

17:37.740 --> 17:38.740
传一个Lumber进来

17:38.740 --> 17:39.740
比方说传一个NAN进来

17:39.740 --> 17:41.740
直接把NAN

17:41.740 --> 17:42.740
字面量传进来

17:42.740 --> 17:43.740
返回

17:43.740 --> 17:44.740
得到结果就是布尔

17:44.740 --> 17:45.740
对吧

17:45.740 --> 17:47.740
这个函数返回的内形是布尔

17:47.740 --> 17:49.740
返回布尔

17:49.740 --> 17:50.740
布林

17:50.740 --> 17:51.740
返回的内形是一个布尔

17:51.740 --> 17:52.740
是和否

17:52.740 --> 17:53.740
是不是NAN

17:53.740 --> 17:54.740
意思

17:54.740 --> 17:55.740
以后你看到一个函数

17:55.740 --> 17:56.740
是以意思开头的

17:56.740 --> 17:57.740
往往返回的东西

17:57.740 --> 17:58.740
都是一个布尔

17:58.740 --> 17:59.740
比方说

17:59.740 --> 18:01.740
零除以零

18:01.740 --> 18:02.740
是不是NAN

18:02.740 --> 18:03.740
你看是True

18:03.740 --> 18:05.740
然后呢

18:05.740 --> 18:06.740
一除以零

18:06.740 --> 18:07.740
是不是NAN

18:07.740 --> 18:08.740
是Force

18:08.740 --> 18:09.740
明白吧

18:09.740 --> 18:10.740
OK

18:10.740 --> 18:12.740
这是关于这个函数说一下

18:12.740 --> 18:13.740
既然说到这个函数的话

18:13.740 --> 18:14.740
还有另外一个函数

18:14.740 --> 18:16.740
我也一起说一下吧

18:16.740 --> 18:17.740
这是关于这个函数

18:17.740 --> 18:18.740
意思

18:18.740 --> 18:19.740
finite

18:19.740 --> 18:20.740
函数

18:20.740 --> 18:21.740
该函数呢

18:21.740 --> 18:24.740
用于判断一个数据

18:24.740 --> 18:26.740
是否是有限的

18:26.740 --> 18:28.740
返回布尔

18:28.740 --> 18:30.740
函数文以后会

18:30.740 --> 18:31.740
详细的讲

18:31.740 --> 18:33.740
我们先了解它怎么用就行了

18:33.740 --> 18:34.740
返回的也是个布尔

18:34.740 --> 18:35.740
就是意思

18:35.740 --> 18:36.740
finite

18:36.740 --> 18:37.740
finite

18:37.740 --> 18:38.740
是不是有限的

18:38.740 --> 18:39.740
infinite

18:39.740 --> 18:40.740
就表示的是infinity

18:40.740 --> 18:41.740
表示的是无限的

18:41.740 --> 18:42.740
加那个IN

18:42.740 --> 18:43.740
表示无限的

18:43.740 --> 18:45.740
finite表示有限的

18:45.740 --> 18:46.740
比方说

18:46.740 --> 18:47.740
一个E

18:47.740 --> 18:48.740
是不是有限的

18:48.740 --> 18:49.740
有限的数字

18:49.740 --> 18:51.740
比方说1.5有限的数字

18:51.740 --> 18:53.740
如果是一个

18:53.740 --> 18:54.740
给它一个infinity

18:54.740 --> 18:55.740
是不是无限的

18:55.740 --> 18:56.740
返回的就是Force

18:56.740 --> 18:58.740
这个数字对的不是有限的

18:58.740 --> 19:00.740
给它一个Fu的infinity

19:00.740 --> 19:01.740
也是Force

19:01.740 --> 19:02.740
它不是有限数据

19:02.740 --> 19:05.740
当然这里面可以使用表达式

19:05.740 --> 19:07.740
表达式可以放到任何

19:07.740 --> 19:08.740
需要数据的地方

19:08.740 --> 19:10.740
比方说一除以零

19:10.740 --> 19:11.740
Force

19:11.740 --> 19:12.740
Force

19:13.740 --> 19:16.740
那么如果这里面填NAN

19:16.740 --> 19:17.740
NAN

19:17.740 --> 19:18.740
你们已经看到结果了

19:18.740 --> 19:19.740
NAN

19:19.740 --> 19:20.740
非数字

19:20.740 --> 19:21.740
它也认为是

19:21.740 --> 19:23.740
也认为是就是无限的

19:23.740 --> 19:25.740
因为不存在的数字

19:25.740 --> 19:26.740
不存在的数字

19:26.740 --> 19:28.740
它也认为是Force

19:28.740 --> 19:30.740
了解一下关于这个函数

19:30.740 --> 19:31.740
它判断的是一个数字

19:31.740 --> 19:33.740
是不是有限的数字

19:33.740 --> 19:35.740
有限的数字

19:35.740 --> 19:36.740
好

19:36.740 --> 19:37.740
那么这一些

19:37.740 --> 19:38.740
都是我们需要掌握的

19:38.740 --> 19:39.740
需要掌握的

19:39.740 --> 19:40.740
就这么一些了

19:40.740 --> 19:41.740
数学运算符

19:41.740 --> 19:43.740
绝大部分这些数学运算符

19:43.740 --> 19:44.740
算数运算

19:44.740 --> 19:47.740
都是数字跟数字之间进行运算

19:47.740 --> 19:49.740
而不会有其他什么妖儿子

19:49.740 --> 19:51.740
但是面试的时候

19:51.740 --> 19:52.740
它会问到很多

19:52.740 --> 19:54.740
其他的乱七八糟的东西

19:54.740 --> 19:55.740
所以面试的时候

19:55.740 --> 19:56.740
问的最多是啥呢

19:56.740 --> 19:58.740
问的最多的就是内想

19:58.740 --> 19:59.740
关于内想

19:59.740 --> 20:02.950
就是

20:02.950 --> 20:04.950
其他内想

20:04.950 --> 20:07.950
使用算数运算

20:07.950 --> 20:09.950
其他内想使用算数运算的时候

20:09.950 --> 20:11.950
乱七八糟的规则就来了

20:11.950 --> 20:12.950
各种来啦

20:12.950 --> 20:13.950
好

20:13.950 --> 20:14.950
这里来我们一个个说

20:14.950 --> 20:15.950
一个个说

20:15.950 --> 20:16.950
首先是

20:16.950 --> 20:18.950
除加号之外的

20:18.950 --> 20:21.950
加号之外的

20:21.950 --> 20:22.950
包括我们下节课要讲的

20:22.950 --> 20:24.950
加加和前键

20:24.950 --> 20:26.950
除加号之外的

20:26.950 --> 20:29.950
就是算数运算符

20:29.950 --> 20:31.950
这地种情况

20:31.950 --> 20:34.950
除加号之外的算数运算符

20:34.950 --> 20:36.950
那么如果遇到了其他内想

20:36.950 --> 20:37.950
比方说制符创

20:37.950 --> 20:39.950
制符创成义一个制符创

20:39.950 --> 20:40.950
该怎么来算

20:40.950 --> 20:41.950
该怎么来算

20:41.950 --> 20:42.950
怎么来算呢

20:42.950 --> 20:45.950
如果是将原式内想

20:45.950 --> 20:47.950
原式内想

20:47.950 --> 20:50.950
转换为数字内想

20:50.950 --> 20:53.950
然后进行运算

20:53.950 --> 20:54.950
将原式内想

20:54.950 --> 20:55.950
转换为数字内想

20:55.950 --> 20:57.950
然后进行运算

20:57.950 --> 20:58.950
这种转换是自动的

20:58.950 --> 20:59.950
是自动转换

20:59.950 --> 21:00.950
你不需要管

21:00.950 --> 21:02.950
自动完成转换

21:02.950 --> 21:03.950
完成转换

21:03.950 --> 21:04.950
我们只要了解

21:04.950 --> 21:06.950
它的转换规则就行了

21:06.950 --> 21:08.950
首先是原式内想有哪些

21:08.950 --> 21:09.950
是布尔

21:09.950 --> 21:11.950
布尔布利

21:11.950 --> 21:13.950
布尔内想

21:13.950 --> 21:14.950
布尔内想的话

21:14.950 --> 21:16.950
就是q转换成什么呢

21:16.950 --> 21:18.950
转换成1

21:18.950 --> 21:22.950
force转换成0

21:22.950 --> 21:24.950
保存看一下

21:24.950 --> 21:27.950
如果是q加上q

21:27.950 --> 21:28.950
应该多少

21:28.950 --> 21:29.950
你看结果已经出来了

21:29.950 --> 21:30.950
就是2

21:30.950 --> 21:34.950
如果是q加上force

21:34.950 --> 21:36.950
结果是多少呢

21:36.950 --> 21:37.950
就是1

21:37.950 --> 21:40.950
如果是force乘1去

21:40.950 --> 21:41.950
就是0

21:41.950 --> 21:42.950
0乘1

21:42.950 --> 21:43.950
对不对

21:43.950 --> 21:44.950
就按照这样的轨道来算

21:44.950 --> 21:46.950
它在进行算数运算的时候

21:46.950 --> 21:48.950
如果有其他内想

21:48.950 --> 21:50.950
除加号之外

21:50.950 --> 21:52.950
我这里为什么要举个加号的例子呢

21:52.950 --> 21:53.950
不应该举加号的例子

21:53.950 --> 21:56.950
比方说我们这种q

21:56.950 --> 22:00.950
q除以3

22:00.950 --> 22:03.950
q除以3的余数

22:03.950 --> 22:04.950
是多少

22:04.950 --> 22:06.950
就是1除以3的余数

22:06.950 --> 22:07.950
相当于3

22:07.950 --> 22:09.950
相当于3为0

22:09.950 --> 22:11.950
余数为1

22:11.950 --> 22:12.950
3为0

22:12.950 --> 22:13.950
余数为1

22:13.950 --> 22:15.950
得到结果就是1

22:15.950 --> 22:17.950
force除以3的余数

22:17.950 --> 22:18.950
是不是就0

22:18.950 --> 22:19.950
3为0

22:19.950 --> 22:20.950
余数也为0

22:20.950 --> 22:22.950
明白这个意思吗

22:22.950 --> 22:23.950
就是把

22:23.950 --> 22:24.950
如果是布尔的话

22:24.950 --> 22:25.950
就把布尔

22:25.950 --> 22:26.950
转换成数字

22:26.950 --> 22:28.950
然后进行运算

22:28.950 --> 22:29.950
再看

22:29.950 --> 22:30.950
当然数字就不管了

22:30.950 --> 22:31.950
数字当然就正常的

22:31.950 --> 22:33.950
算数运算

22:33.950 --> 22:34.950
因为算数运算

22:34.950 --> 22:35.950
肯定是跟数字相关的

22:35.950 --> 22:36.950
如果你不是数字的话

22:36.950 --> 22:37.950
没办法

22:37.950 --> 22:38.950
没办法

22:38.950 --> 22:39.950
比方说我们还可以这样子写

22:39.950 --> 22:41.950
加上q

22:41.950 --> 22:42.950
加上q

22:42.950 --> 22:44.950
你看是不是转成数字了

22:44.950 --> 22:45.950
有的时候

22:45.950 --> 22:47.950
我们也可以在一个东西前面

22:47.950 --> 22:48.950
写个加号

22:48.950 --> 22:49.950
写一个加号

22:49.950 --> 22:51.950
来表示的是

22:51.950 --> 22:53.950
把这个东西转换成数字

22:53.950 --> 22:54.950
转换成数字

22:54.950 --> 22:56.950
比方说

22:56.950 --> 22:58.950
我们这里写一个script

22:58.950 --> 22:59.950
有个变量

22:59.950 --> 23:00.950
一个变量

23:00.950 --> 23:01.950
b

23:01.950 --> 23:02.950
q

23:02.950 --> 23:04.950
这个变量里面存了一些东西

23:04.950 --> 23:06.950
我想把它转换成数字

23:06.950 --> 23:08.950
转换成数字再重新存回来

23:08.950 --> 23:09.950
怎么转呢

23:09.950 --> 23:10.950
非常简单

23:10.950 --> 23:12.950
前面写个符号加号

23:12.950 --> 23:13.950
加上个b

23:13.950 --> 23:15.950
因为这是个数学运算

23:15.950 --> 23:17.950
这是个数学运算

23:17.950 --> 23:18.950
这个不是加

23:18.950 --> 23:19.950
这个不是加

23:19.950 --> 23:21.950
这个是正数

23:21.950 --> 23:23.950
这是个数学运算

23:23.950 --> 23:24.950
所以说前面写个加号

23:24.950 --> 23:25.950
表示的是

23:25.950 --> 23:26.950
把它转换成数字

23:26.950 --> 23:27.950
因为数学运算

23:27.950 --> 23:28.950
它只能转换成数字

23:28.950 --> 23:29.950
才能进行运算

23:29.950 --> 23:30.950
所以这样子

23:30.950 --> 23:31.950
就达到了

23:31.950 --> 23:32.950
把b这个变量

23:32.950 --> 23:33.950
转换成数字的目的了

23:33.950 --> 23:35.950
这也是我们在开发的时候

23:35.950 --> 23:36.950
一种常见的做法

23:36.950 --> 23:38.950
这个东西想要了解一下

23:38.950 --> 23:39.950
我们来输出这个b

23:39.950 --> 23:42.950
然后再输出type b

23:42.950 --> 23:43.950
保存

23:43.950 --> 23:44.950
看一下

23:44.950 --> 23:45.950
你看一

23:45.950 --> 23:46.950
number

23:46.950 --> 23:47.950
好

23:47.950 --> 23:48.950
这是第一个点

23:48.950 --> 23:50.950
再使用

23:50.950 --> 23:52.950
就是其他的类型

23:52.950 --> 23:53.950
其他的类型

23:53.950 --> 23:54.950
除数字之外的其他类型

23:54.950 --> 23:56.950
再使用算数运算的时候

23:56.950 --> 23:57.950
它只能把它转换成数字

23:57.950 --> 23:58.950
但是加号出来

23:58.950 --> 24:00.950
加号我们单独的讨论

24:00.950 --> 24:01.950
好

24:01.950 --> 24:02.950
然后字无串

24:02.950 --> 24:03.950
好

24:03.950 --> 24:05.950
字无串怎么转换了

24:05.950 --> 24:07.950
这里的情况就比较多了

24:07.950 --> 24:08.950
这里的情况就比较多了

24:08.950 --> 24:10.950
看一下吧

24:10.950 --> 24:12.950
如果我前面写个加号

24:12.950 --> 24:13.950
后面写上一个字无串

24:13.950 --> 24:14.950
如果写个123

24:14.950 --> 24:16.950
看一下转换的结果就是123

24:16.950 --> 24:18.950
就是个数字123

24:18.950 --> 24:19.950
如果前面写个加号

24:19.950 --> 24:20.950
后面写个abc

24:20.950 --> 24:22.950
转换的结果NAN

24:22.950 --> 24:23.950
NAN

24:23.950 --> 24:24.950
然后再写个加号

24:24.950 --> 24:27.950
后面的字无串写上1.2.3.4

24:27.950 --> 24:30.950
转换的结果是NAN

24:31.950 --> 24:33.950
如果前面写个加号

24:33.950 --> 24:34.950
然后abc

24:34.950 --> 24:37.950
转换的结果是NAN

24:37.950 --> 24:38.950
能看明白吧

24:38.950 --> 24:39.950
什么意思呢

24:39.950 --> 24:40.950
字无串的话

24:40.950 --> 24:42.950
如果字无串

24:42.950 --> 24:47.950
字无串内部是一个正确的数字

24:47.950 --> 24:48.950
一个正确的数字

24:48.950 --> 24:51.950
直接变为数字

24:51.950 --> 24:54.950
如果不是一个

24:54.950 --> 24:56.950
如果是一个非数字

24:56.950 --> 24:58.950
就是不是数字

24:58.950 --> 25:03.950
得到NAN

25:03.950 --> 25:05.950
就是字无串的转换方式

25:05.950 --> 25:08.950
那么现在我们来看一下

25:08.950 --> 25:11.950
现在我们来看一下

25:11.950 --> 25:12.950
有的时候的面试题

25:12.950 --> 25:14.950
可能会这样子问

25:14.950 --> 25:15.950
他问你

25:15.950 --> 25:17.950
这里我写的就是

25:17.950 --> 25:18.950
写的是这个东西

25:18.950 --> 25:20.950
inferity

25:20.950 --> 25:21.950
那么转换的是啥呢

25:21.950 --> 25:23.950
结果

25:23.950 --> 25:25.950
转换的仍然是inferity

25:25.950 --> 25:26.950
所以说这个地方

25:26.950 --> 25:27.950
要特殊一点

25:27.950 --> 25:28.950
如果你写的是inferity

25:28.950 --> 25:29.950
因为inferity是一种

25:29.950 --> 25:31.950
正确的数字输写方式

25:31.950 --> 25:32.950
负的inferity

25:32.950 --> 25:35.950
转换的结果就是负的inferity

25:35.950 --> 25:36.950
说一下

25:36.950 --> 25:40.950
就是能识别inferity

25:40.950 --> 25:42.950
因为这个inferity的这种邪法

25:42.950 --> 25:45.950
它也是一个正确的邪法

25:45.950 --> 25:47.950
那能不能识别表达式呢

25:47.950 --> 25:49.950
能不能在字无串里面

25:49.950 --> 25:50.950
识别表达式呢

25:50.950 --> 25:51.950
因为面试题

25:51.950 --> 25:54.950
它老是会这样子来考理

25:54.950 --> 25:55.950
一处一山

25:55.950 --> 25:56.950
能不能识别表达式

25:56.950 --> 25:57.950
它不能识别表达式

25:57.950 --> 25:58.950
它不能识别表达式

25:58.950 --> 25:59.950
无法识别

25:59.950 --> 26:00.950
因为这里面写的

26:00.950 --> 26:01.950
就不是表达式的

26:01.950 --> 26:02.950
这里面是字符串的内容

26:02.950 --> 26:04.950
你不能把这里当成表达式

26:04.950 --> 26:05.950
不要告诉我

26:05.950 --> 26:06.950
说之前不是说

26:06.950 --> 26:07.950
表达式可以出现在

26:07.950 --> 26:08.950
任何数据的地方

26:08.950 --> 26:09.950
但是这里是字符串

26:09.950 --> 26:10.950
内部的内容

26:10.950 --> 26:11.950
就是一个普通文本

26:11.950 --> 26:13.950
它不是表达式

26:13.950 --> 26:15.950
不能

26:15.950 --> 26:19.950
不能把字符串内部的东西

26:19.950 --> 26:21.950
当做表达式

26:21.950 --> 26:23.950
为什么我特别提醒这个

26:23.950 --> 26:24.950
之前有革面势力考过

26:24.950 --> 26:25.950
考过这个内设东西

26:25.950 --> 26:27.950
我们后边会专门讲面试题

26:27.950 --> 26:29.950
会讲很多很多的面试题

26:29.950 --> 26:31.950
我现在先了解知识

26:31.950 --> 26:33.950
这是关于字符串的转换

26:33.950 --> 26:35.950
这里既然说到了NAN

26:35.950 --> 26:36.950
这里说到了NAN

26:36.950 --> 26:38.950
我们就顺便说一下

26:38.950 --> 26:41.950
NAN和任何

26:41.950 --> 26:42.950
虽然它是数字

26:42.950 --> 26:44.950
虽然是数字

26:44.950 --> 26:48.950
但它和任何数字

26:48.950 --> 26:51.950
做任何运算

26:51.950 --> 26:54.950
得到的结果

26:54.950 --> 26:57.950
都是NAN

26:57.950 --> 26:58.950
你想吧

26:58.950 --> 26:59.950
它都不是一个数字的

26:59.950 --> 27:00.950
它都没法用数字来表示的

27:00.950 --> 27:01.950
虽然它是数字内想

27:01.950 --> 27:03.950
在这个数字的范畴之内

27:03.950 --> 27:05.950
但它不是一个正常的数字

27:05.950 --> 27:07.950
它就没法做任何的正常运算

27:07.950 --> 27:09.950
所以说运算的结果都是NAN

27:09.950 --> 27:13.950
比方说NAN加1NAN

27:13.950 --> 27:16.950
NAN乘以10NAN

27:16.950 --> 27:18.950
没法进行运算

27:18.950 --> 27:20.950
好吧

27:20.950 --> 27:22.950
那么我们现在再解释一下

27:22.950 --> 27:23.950
之前的这个

27:23.950 --> 27:25.950
为什么是NAN

27:25.950 --> 27:26.950
来吧

27:26.950 --> 27:27.950
我们再解释一下

27:27.950 --> 27:29.950
它怎么运算的

27:29.950 --> 27:30.950
先算这一部分

27:30.950 --> 27:32.950
它先算的是这一部分

27:32.950 --> 27:33.950
好

27:33.950 --> 27:34.950
这一部分算出来的结果是啥呢

27:34.950 --> 27:36.950
是不是一个字符串Lumber

27:36.950 --> 27:37.950
对吧

27:37.950 --> 27:38.950
一个字符串Lumber

27:38.950 --> 27:39.950
我们刚才说了

27:39.950 --> 27:40.950
Type of得到的结果

27:40.950 --> 27:41.950
这个函数的运算结果是Lumber

27:41.950 --> 27:42.950
好

27:42.950 --> 27:43.950
一个字符串Lumber

27:43.950 --> 27:45.950
字符串Lumber除以0

27:45.950 --> 27:46.950
除以0

27:46.950 --> 27:48.950
是不是先把它转换成数字

27:48.950 --> 27:49.950
对吧

27:49.950 --> 27:50.950
先把这个字符串转换成数字

27:50.950 --> 27:52.950
转换的结果是啥呢

27:52.950 --> 27:54.950
这个字符串转换的数字结果是啥呢

27:54.950 --> 27:56.950
是不是就是NAN

27:56.950 --> 27:58.950
NAN除以0

27:58.950 --> 27:59.950
是不是还是NAN

27:59.950 --> 28:00.950
对吧

28:00.950 --> 28:01.950
跟任何数进行运算

28:01.950 --> 28:02.950
都是NAN

28:02.950 --> 28:04.950
不要认为这个东西就是Infinity

28:04.950 --> 28:05.950
好

28:05.950 --> 28:06.950
这是关于

28:06.950 --> 28:08.950
字符串这一点

28:08.950 --> 28:09.950
字符串这一点

28:09.950 --> 28:11.950
好 接下来是

28:11.950 --> 28:13.950
是下面这个

28:13.950 --> 28:15.950
一个说吧

28:17.950 --> 28:19.950
这是一个

28:19.950 --> 28:21.950
下面再来一个

28:21.950 --> 28:22.950
然后是

28:22.950 --> 28:24.950
NOW

28:24.950 --> 28:26.950
NOW转换成数字

28:26.950 --> 28:28.950
转换的结果就直接是0

28:28.950 --> 28:29.950
直接是0

28:29.950 --> 28:32.950
转换的数字结果就直接是0

28:32.950 --> 28:33.950
保存看一下

28:33.950 --> 28:35.950
我们这里加上一个正NOW

28:35.950 --> 28:36.950
这样转换

28:36.950 --> 28:37.950
你看 结果是0

28:37.950 --> 28:38.950
你加一个富NOW

28:38.950 --> 28:39.950
结果

28:39.950 --> 28:40.950
0和富0

28:40.950 --> 28:42.950
0里边还有两种

28:42.950 --> 28:43.950
一种是0 正0

28:43.950 --> 28:44.950
一种是富0

28:44.950 --> 28:45.950
富0

28:45.950 --> 28:46.950
总之NOW转换的结果是0

28:46.950 --> 28:47.950
加上一个富号

28:47.950 --> 28:48.950
就变成富0了

28:48.950 --> 28:49.950
对吧

28:49.950 --> 28:50.950
变成富0了

28:50.950 --> 28:51.950
零有两种

28:51.950 --> 28:52.950
在JS里边有两种

28:52.950 --> 28:53.950
一种是正0

28:53.950 --> 28:54.950
一种是富0

28:54.950 --> 28:55.950
不过运算出来的结果都是一样的

28:55.950 --> 28:57.950
这是JS设计上的一个问题

28:57.950 --> 28:59.950
它设计上的一个问题

28:59.950 --> 29:00.950
它没有考虑清楚

29:00.950 --> 29:01.950
很多语言里面

29:01.950 --> 29:02.950
它不存在这个东西

29:02.950 --> 29:03.950
不存在这个东西

29:03.950 --> 29:05.950
这是个历史一个问题

29:05.950 --> 29:06.950
好

29:06.950 --> 29:08.950
然后Undefend

29:08.950 --> 29:10.950
Undefend

29:10.950 --> 29:12.950
Undefend转换的结果

29:12.950 --> 29:15.950
是NAN

29:15.950 --> 29:17.950
Undefend转换的结果是NAN

29:17.950 --> 29:18.950
就这两个是不一样的

29:18.950 --> 29:19.950
是不一样的

29:19.950 --> 29:20.950
咱们来看一下

29:20.950 --> 29:23.950
比方说Undefend

29:23.950 --> 29:26.950
乘以5

29:26.950 --> 29:27.950
为什么是NAN

29:27.950 --> 29:28.950
因为这个东西

29:28.950 --> 29:29.950
转换成数字

29:29.950 --> 29:30.950
它要进行数学运算

29:30.950 --> 29:31.950
它只能把它转换成数字

29:31.950 --> 29:32.950
转换成数字过后

29:32.950 --> 29:33.950
它是NAN

29:33.950 --> 29:35.950
所以说乘以5过后

29:35.950 --> 29:36.950
是NAN

29:36.950 --> 29:37.950
如果你是NOW的话

29:37.950 --> 29:39.950
乘以5是多少呢

29:39.950 --> 29:40.950
是不是0

29:40.950 --> 29:41.950
对吧

29:41.950 --> 29:42.950
就是0

29:42.950 --> 29:43.950
OK

29:43.950 --> 29:44.950
这就是

29:44.950 --> 29:45.950
这就是那个

29:48.950 --> 29:49.950
这就是那个

29:49.950 --> 29:50.950
这里的做法

29:50.950 --> 29:52.950
这里的转换方式

29:52.950 --> 29:53.950
好

29:53.950 --> 29:54.950
这里我们只讨论了

29:54.950 --> 29:56.950
原始内详

29:56.950 --> 29:58.950
然后是对象怎么办

29:58.950 --> 29:59.950
编事情

29:59.950 --> 30:00.950
你不要小瞧编事情

30:00.950 --> 30:02.950
它会各种恶心力

30:02.950 --> 30:03.950
尽管我们自己写代码

30:03.950 --> 30:04.950
不会这样去写

30:04.950 --> 30:05.950
对吧

30:05.950 --> 30:06.950
谁会这样去写代码的

30:06.950 --> 30:08.950
但是也不一定

30:08.950 --> 30:09.950
有的时候我们得到一个变量

30:09.950 --> 30:10.950
它的值

30:10.950 --> 30:11.950
我们可能不知道

30:11.950 --> 30:12.950
它是不是Undefend

30:12.950 --> 30:13.950
我们就用去进行乘

30:13.950 --> 30:15.950
进行这样子数学运算了

30:15.950 --> 30:17.950
可能会得到这个NNN

30:17.950 --> 30:19.950
就可能会得到这个结果

30:19.950 --> 30:21.950
那如果是对象呢

30:21.950 --> 30:24.950
将对象内详

30:24.950 --> 30:26.950
先

30:26.950 --> 30:28.950
转换为

30:28.950 --> 30:30.950
制服错的内详

30:30.950 --> 30:32.950
将对象内详

30:32.950 --> 30:33.950
先转换成制服错的内详

30:33.950 --> 30:34.950
我们先暂时这样理解

30:34.950 --> 30:35.950
实际上

30:35.950 --> 30:36.950
这里边还有很多细节

30:36.950 --> 30:37.950
我们需要

30:37.950 --> 30:38.950
后边学到一些指使过后

30:38.950 --> 30:39.950
才能知道

30:39.950 --> 30:40.950
但是现在我们指使有限

30:40.950 --> 30:42.950
所以说先暂时这样理解

30:42.950 --> 30:44.950
先把它转换成制服错的内详

30:44.950 --> 30:46.950
然后

30:46.950 --> 30:48.950
看能否

30:48.950 --> 30:50.950
然后就是这样子

30:50.950 --> 30:52.950
然后再将

30:52.950 --> 30:54.950
该制服错

30:54.950 --> 30:56.950
转换为

30:56.950 --> 30:58.950
数字内详

30:58.950 --> 30:59.950
因为制服错转数字内详

30:59.950 --> 31:00.950
我们学过的对吧

31:00.950 --> 31:01.950
学过的

31:01.950 --> 31:02.950
所以说

31:02.950 --> 31:04.950
它是按照这样的方式来转换

31:04.950 --> 31:06.950
由于对象内详

31:06.950 --> 31:08.950
转换制服错过后

31:08.950 --> 31:09.950
它的一个固定的格式

31:09.950 --> 31:10.950
它是这个制服错

31:10.950 --> 31:11.950
固定格式

31:12.950 --> 31:13.950
Objects

31:13.950 --> 31:14.950
Objects

31:14.950 --> 31:16.950
它这么一个固定格式

31:16.950 --> 31:17.950
我们来看一下吧

31:17.950 --> 31:18.950
看一下

31:19.950 --> 31:21.950
把它转成制服错的内详

31:21.950 --> 31:22.950
看一下

31:24.950 --> 31:25.950
我们看一下

31:25.950 --> 31:26.950
怎么看的问题是在控制台里边

31:26.950 --> 31:28.950
我们在控制台里边好像不太容易看到

31:28.950 --> 31:30.950
我们在这里打印出来

31:30.950 --> 31:31.950
用Document to the right

31:31.950 --> 31:32.950
这样打印出来

31:32.950 --> 31:33.950
控制台不太容易看到

31:33.950 --> 31:35.950
因为控制台打印出来过后

31:35.950 --> 31:36.950
它会变成一种对象的格式

31:36.950 --> 31:37.950
可以让你操作的

31:37.950 --> 31:39.950
我们之前看到过

31:40.950 --> 31:42.950
在控制台里边打印出一个对象的话

31:42.950 --> 31:44.950
那么它就是直接可以操作的东西

31:44.950 --> 31:45.950
是这种东西

31:45.950 --> 31:47.950
看不到它的制服错的形式

31:47.950 --> 31:48.950
我们来这样子

31:48.950 --> 31:49.950
用Document to the right

31:49.950 --> 31:51.950
可以看到一个对象的制服错格式

31:52.950 --> 31:54.950
我们这里写个对象

31:54.950 --> 31:55.950
比方说

31:55.950 --> 31:56.950
内随便写个

31:56.950 --> 31:57.950
随便写个

31:57.950 --> 31:58.950
随便写

31:58.950 --> 31:59.950
写写

31:59.950 --> 32:00.950
保存

32:00.950 --> 32:01.950
看一下

32:01.950 --> 32:03.950
这是它的制服错格式

32:03.950 --> 32:04.950
看

32:04.950 --> 32:05.950
我刚才写的

32:05.950 --> 32:06.950
这是对象的制服错格式

32:06.950 --> 32:08.950
至于它为什么是这种格式

32:08.950 --> 32:09.950
它有没有可能会变化

32:09.950 --> 32:11.950
我们以后的课程学校才知道

32:11.950 --> 32:13.950
我们先暂时这样认为

32:13.950 --> 32:15.950
先暂时这样认为

32:15.950 --> 32:17.950
对象的转换成制服错

32:17.950 --> 32:18.950
就是这种格式

32:18.950 --> 32:20.950
然后再把这个东西变成数字

32:20.950 --> 32:22.950
你觉得这个制服错变成数字是啥

32:22.950 --> 32:23.950
是不是NAN

32:23.950 --> 32:24.950
能转成数字吗

32:24.950 --> 32:26.950
是不是转不出来

32:26.950 --> 32:27.950
对吧

32:27.950 --> 32:28.950
对象的转成数字就变成NNN了

32:28.950 --> 32:29.950
所以说

32:29.950 --> 32:31.950
我们目前可以暂时的

32:31.950 --> 32:32.950
这样记忆

32:32.950 --> 32:34.950
对象内形

32:34.950 --> 32:36.950
就是NAN

32:36.950 --> 32:38.950
跟加号之外的算数运算符

32:38.950 --> 32:39.950
进行运算的时候

32:39.950 --> 32:40.950
就是NAN

32:40.950 --> 32:41.950
但是你要知道

32:41.950 --> 32:42.950
它里面是一个过程的

32:42.950 --> 32:44.950
先转成制服错

32:44.950 --> 32:45.950
再转成数字

32:45.950 --> 32:46.950
好

32:46.950 --> 32:48.950
因此我们在这里面

32:48.950 --> 32:49.950
写个对象

32:49.950 --> 32:51.950
写个对象

32:51.950 --> 32:52.950
比方说

32:52.950 --> 32:53.950
定个边量吧

32:53.950 --> 32:54.950
OB界

32:54.950 --> 32:55.950
它是一个空对象

32:55.950 --> 32:56.950
空对象

32:56.950 --> 32:57.950
然后给这个对象

32:57.950 --> 32:58.950
呈一个5

32:58.950 --> 32:59.950
你看是不是NAN

32:59.950 --> 33:00.950
为什么

33:00.950 --> 33:01.950
因为对象

33:01.950 --> 33:03.950
转换成制服错变成这个样子

33:03.950 --> 33:04.950
这个制服错变成数字

33:04.950 --> 33:05.950
是NAN

33:05.950 --> 33:06.950
NAN乘以5

33:06.950 --> 33:07.950
是不是NAN

33:07.950 --> 33:08.950
对不对

33:08.950 --> 33:10.950
当然OB界除以5

33:10.950 --> 33:11.950
也是N

33:11.950 --> 33:12.950
也是这个

33:12.950 --> 33:14.950
NAN

33:14.950 --> 33:16.950
没问题吧

33:16.950 --> 33:17.950
没问题

33:17.950 --> 33:18.950
但是大家看一下

33:18.950 --> 33:20.950
我如果这样子写

33:20.950 --> 33:24.350
这样子写

33:24.350 --> 33:26.350
它会爆错

33:26.350 --> 33:28.350
它为什么会爆错呢

33:28.350 --> 33:29.350
因为它这个时候

33:29.350 --> 33:32.350
理解这个代码有起义

33:32.350 --> 33:33.350
它怎么理解这个代码的呢

33:33.350 --> 33:35.350
它是这样理解的

33:35.350 --> 33:36.350
看着

33:36.350 --> 33:38.660
像这些辨识体

33:38.660 --> 33:40.660
经常会考这些乱七八糟的玩意

33:40.660 --> 33:41.660
就是解释

33:41.660 --> 33:43.660
它太过于灵活了

33:43.660 --> 33:44.660
因为解释

33:44.660 --> 33:47.660
它是可以允许不写分号的

33:47.660 --> 33:49.660
它是可以允许不写分号的

33:49.660 --> 33:52.660
你这样子写了之后

33:52.660 --> 33:53.660
它认为是啥意思呢

33:53.660 --> 33:54.660
你看

33:54.660 --> 33:55.660
它这里就爆错了

33:55.660 --> 33:56.660
语法错误

33:56.660 --> 33:58.660
它认为是啥意思呢

33:58.660 --> 33:59.660
它认为

33:59.660 --> 34:00.660
这是一个代码框

34:00.660 --> 34:02.660
它没有把它当成对象

34:02.660 --> 34:03.660
它没有把它当成对象

34:03.660 --> 34:04.660
它认为

34:04.660 --> 34:05.660
这一块是代码框

34:05.660 --> 34:06.660
因为代码框

34:06.660 --> 34:07.660
它也是用两个大块号

34:07.660 --> 34:09.660
我们后边学习流程控制之后

34:09.660 --> 34:12.660
我们就会接触到代码框

34:12.660 --> 34:14.660
代码框有什么用的

34:14.660 --> 34:15.660
代码框目前没有什么用

34:15.660 --> 34:17.660
在ES6里面有一些用处

34:17.660 --> 34:19.660
但是现在目前没有啥用

34:19.660 --> 34:20.660
没啥用

34:20.660 --> 34:22.660
也就是说代码框是什么东西

34:22.660 --> 34:23.660
我给大家看一下

34:23.660 --> 34:24.660
代码框是这么个东西

34:24.660 --> 34:25.660
比方说这里

34:25.660 --> 34:27.660
我们可以写一些语句

34:27.660 --> 34:28.660
A等于2

34:28.660 --> 34:29.660
3

34:29.660 --> 34:30.660
B等于4

34:30.660 --> 34:31.660
没啥用

34:31.660 --> 34:32.660
没啥用

34:32.660 --> 34:33.660
就是把这一块

34:33.660 --> 34:35.660
把这一块包起来

34:35.660 --> 34:37.660
目前我们对于我们来用处的

34:37.660 --> 34:39.660
对于我们来说

34:39.660 --> 34:40.660
用处可能就在于

34:40.660 --> 34:41.660
它可以产生一个折叠符号

34:41.660 --> 34:43.660
可以把这一块折叠起来

34:43.660 --> 34:44.660
其他没有啥用处了

34:44.660 --> 34:45.660
没有啥用处了

34:45.660 --> 34:46.660
就表示这一块代码框

34:46.660 --> 34:47.660
它不是对象

34:47.660 --> 34:48.660
这种写法它就不是对象了

34:48.660 --> 34:50.660
这里面写的是一条条的语句

34:50.660 --> 34:51.660
对象里边要写什么

34:51.660 --> 34:52.660
要写属性了

34:52.660 --> 34:53.660
格式都不一样

34:53.660 --> 34:54.660
这是个代码框

34:54.660 --> 34:55.660
你可以换行

34:55.660 --> 34:56.660
可以不换行

34:56.660 --> 34:58.660
代码框完了之后

34:58.660 --> 35:00.660
代码框完了之后

35:00.660 --> 35:02.660
你又写了一个乘武

35:03.660 --> 35:04.660
相当于是它

35:04.660 --> 35:05.660
它这样理解的

35:05.660 --> 35:06.660
前面有个代码框

35:06.660 --> 35:08.660
后面有个乘武

35:08.660 --> 35:09.660
这个语法不满足要求

35:09.660 --> 35:11.660
它就没有把它理解成为

35:11.660 --> 35:12.660
对象

35:12.660 --> 35:13.660
把对象来乘义武

35:13.660 --> 35:15.660
因为谁会去这样子写

35:15.660 --> 35:16.660
兄弟

35:16.660 --> 35:18.660
谁会把对象拿出来去乘义武

35:18.660 --> 35:19.660
没有人这么去干的

35:19.660 --> 35:20.660
对吧

35:20.660 --> 35:21.660
没有人这么去干的

35:21.660 --> 35:22.660
所以它现在爆错了

35:22.660 --> 35:23.660
现在爆错了

35:23.660 --> 35:25.660
就这种写法会爆错

35:25.660 --> 35:26.660
因此我们要怎么来

35:26.660 --> 35:28.660
才能告诉这个浏览器

35:28.660 --> 35:29.660
我就是要这么干

35:29.660 --> 35:30.660
你别管

35:30.660 --> 35:31.660
我就说这么干我疯了

35:31.660 --> 35:32.660
反正我就说这么干

35:32.660 --> 35:33.660
怎么办呢

35:33.660 --> 35:35.660
给它加上一个小扩号

35:35.660 --> 35:37.660
左右加上小扩号过后

35:37.660 --> 35:40.660
它就认为小扩号里面是个表达式

35:40.660 --> 35:42.660
小扩号里面是一个表达式

35:42.660 --> 35:45.660
那么这里面就当成一个表达式来处理

35:45.660 --> 35:48.660
那么就表示的是一个对象乘义武了

35:48.660 --> 35:50.660
当然得到的结果还是NNN

35:50.660 --> 35:51.660
你看这个意思

35:51.660 --> 35:52.660
就这些东西

35:52.660 --> 35:55.660
面试题非常非常容易考

35:55.660 --> 35:57.660
非常非常容易考

35:57.660 --> 35:58.660
就运算符这里

35:58.660 --> 35:59.660
因为介绍它的语言

35:59.660 --> 36:00.660
这个语言特性

36:00.660 --> 36:01.660
它决定了

36:01.660 --> 36:02.660
这种非常非常灵活

36:02.660 --> 36:04.660
你说灵活是好事吗

36:04.660 --> 36:06.660
双刃剑

36:06.660 --> 36:07.660
你说这个东西有啥用呢

36:07.660 --> 36:09.660
可能将来有那么一些用处

36:09.660 --> 36:11.660
在一些特殊的地方有那么一些用处

36:11.660 --> 36:13.660
但是那绝大部分时候是没啥用的

36:13.660 --> 36:15.660
它跟我们带来的什么牺牲呢

36:15.660 --> 36:18.660
就是容易让我们产生一些非常错

36:18.660 --> 36:19.660
非常恶心的代码

36:19.660 --> 36:22.660
或者是甚至错误的代码

36:22.660 --> 36:24.660
这一块我们聊了关于

36:24.660 --> 36:26.660
除夹号之外的

36:26.660 --> 36:27.660
所有的算数运算符

36:27.660 --> 36:28.660
它的规则

36:28.660 --> 36:29.660
如果有其他类型的话

36:29.660 --> 36:30.660
怎么办

36:30.660 --> 36:32.660
总之目标就是转换成数字

36:32.660 --> 36:35.660
好 接下来我们来看夹号

36:35.660 --> 36:37.660
夹号运算符

36:37.660 --> 36:42.510
夹号运算符呢

36:42.510 --> 36:44.510
要分情况

36:44.510 --> 36:45.510
分情况

36:45.510 --> 36:46.510
什么情况呢

36:46.510 --> 36:48.510
就是

36:48.510 --> 36:50.510
分成三种情况吧

36:50.510 --> 36:51.510
一种就是制符串

36:51.510 --> 36:54.950
夹号

36:55.950 --> 36:57.950
夹号一边

36:58.950 --> 36:59.950
有制符串

36:59.950 --> 37:01.950
有制符串数据

37:01.950 --> 37:04.950
那么如果其中一边有制符串的话

37:04.950 --> 37:07.950
整个含义都变了

37:07.950 --> 37:09.950
含义变为

37:09.950 --> 37:11.950
制符串拼接

37:11.950 --> 37:13.950
含义变成了制符串拼接

37:13.950 --> 37:15.950
就不再是什么数学运算了

37:15.950 --> 37:17.950
不再是算数运算了

37:17.950 --> 37:19.950
变成了制符串拼接

37:19.950 --> 37:21.950
比方说

37:21.950 --> 37:23.950
abc

37:23.950 --> 37:25.950
加上

37:25.950 --> 37:27.950
就是

37:27.950 --> 37:29.950
def

37:29.950 --> 37:31.950
得到结果是abcdef

37:31.950 --> 37:33.950
两个制符串拼接

37:33.950 --> 37:35.950
比方说

37:35.950 --> 37:37.950
1加上2

37:37.950 --> 37:39.950
得到结果是12

37:39.950 --> 37:40.950
不能读12

37:40.950 --> 37:42.950
12叫做数字读法

37:42.950 --> 37:43.950
这叫制符串

37:43.950 --> 37:45.950
制符串的话得到结果是12

37:45.950 --> 37:47.950
放大一点

37:47.950 --> 37:48.950
没问题吧

37:48.950 --> 37:50.950
只要有一边出现制符串

37:50.950 --> 37:52.950
它一定是制符串拼接

37:53.950 --> 37:55.950
好 再来

37:55.950 --> 37:57.950
如果一边是1

37:57.950 --> 37:59.950
一边是2

37:59.950 --> 38:01.950
得到结果

38:01.950 --> 38:03.950
还是制符串拼接

38:03.950 --> 38:04.950
还是制符串拼接

38:04.950 --> 38:06.950
把这个2转换成制符串

38:06.950 --> 38:08.950
那么这里有种情况

38:08.950 --> 38:10.950
有种情况就是什么

38:10.950 --> 38:12.950
加好一边有制符串

38:12.950 --> 38:13.950
有种情况就是

38:13.950 --> 38:15.950
如果两边都有制符串没问题

38:15.950 --> 38:16.950
两个制符串拼接

38:16.950 --> 38:18.950
如果只有一边有制符串

38:18.950 --> 38:20.950
另一边是另外别的类型

38:20.950 --> 38:23.950
将另一边的

38:23.950 --> 38:25.950
其他类型

38:25.950 --> 38:27.950
转换为制符串

38:27.950 --> 38:29.950
又要转换了

38:29.950 --> 38:31.950
怎么转换呢

38:31.950 --> 38:32.950
数字

38:32.950 --> 38:33.950
一个个说吧

38:33.950 --> 38:34.950
数字类型

38:34.950 --> 38:37.950
就是直接变成数字制符串

38:37.950 --> 38:39.950
数字制符串

38:39.950 --> 38:41.950
数字类型直接变成数字制符串

38:41.950 --> 38:42.950
比方说

38:42.950 --> 38:43.950
这里

38:43.950 --> 38:44.950
一个1

38:44.950 --> 38:46.950
一个-3

38:46.950 --> 38:48.950
加上abc

38:48.950 --> 38:49.950
看一下结果

38:49.950 --> 38:50.950
你看

38:50.950 --> 38:51.950
先把这个数字

38:51.950 --> 38:52.950
转换成制符串

38:52.950 --> 38:53.950
变成-3的制符串

38:53.950 --> 38:55.950
拼接上abc

38:55.950 --> 38:56.950
如果是

38:56.950 --> 39:00.950
-3.14拼接abc

39:00.950 --> 39:01.950
看一下

39:01.950 --> 39:02.950
对吧

39:02.950 --> 39:03.950
没问题吧

39:03.950 --> 39:05.950
就是-3.14拼接abc

39:05.950 --> 39:06.950
就这么简单

39:06.950 --> 39:07.950
数字类型很简单

39:07.950 --> 39:08.950
直接转成制符串就行了

39:08.950 --> 39:09.950
每一个点都不复杂

39:09.950 --> 39:10.950
每一个点都很简单

39:10.950 --> 39:11.950
就是

39:11.950 --> 39:13.950
这细节特别特别多

39:13.950 --> 39:14.950
我建议大家

39:14.950 --> 39:16.950
先有这么一个印象

39:16.950 --> 39:17.950
先不要说

39:17.950 --> 39:18.950
我这里怎么那么恼火

39:18.950 --> 39:19.950
我要把这种全部背下来

39:19.950 --> 39:20.950
很头痛

39:20.950 --> 39:22.950
先有这么一个印象

39:22.950 --> 39:24.950
以后你学完前端之后

39:24.950 --> 39:25.950
出去面试了

39:25.950 --> 39:26.950
回过头来

39:26.950 --> 39:27.950
一定要看一下这块

39:27.950 --> 39:28.950
这块面试的时候

39:28.950 --> 39:30.950
非常非常密集

39:30.950 --> 39:31.950
考的东西特别特别多

39:31.950 --> 39:32.950
运算符这一块

39:32.950 --> 39:33.950
我也不知道为什么会考

39:33.950 --> 39:34.950
你问他们去

39:34.950 --> 39:36.950
其实这一块东西

39:36.950 --> 39:38.950
我们有的是遇到了

39:38.950 --> 39:39.950
遇到了问题

39:39.950 --> 39:40.950
你知道有这么一个东西存在

39:40.950 --> 39:41.950
你忘了都没关系

39:41.950 --> 39:42.950
说实话

39:42.950 --> 39:43.950
我给大家说实话

39:43.950 --> 39:44.950
我经常忘

39:44.950 --> 39:45.950
我经常忘

39:45.950 --> 39:46.950
我上节这节和之前

39:46.950 --> 39:48.950
我还专门复习了一下

39:48.950 --> 39:49.950
真的

39:49.950 --> 39:51.950
谁平时这样去用

39:51.950 --> 39:52.950
很少

39:52.950 --> 39:53.950
但是这个拼接还是比较常用的

39:53.950 --> 39:54.950
拼接还是比较常用的

39:54.950 --> 39:55.950
就前面这些东西

39:55.950 --> 39:56.950
什么对翼箱

39:56.950 --> 39:57.950
转换这些

39:57.950 --> 39:58.950
哪谁去用

39:58.950 --> 39:59.950
很少很少去用

39:59.950 --> 40:00.950
有这么个印象就行了

40:00.950 --> 40:02.950
以后要做面试之前

40:02.950 --> 40:03.950
一定要来复习一下

40:03.950 --> 40:04.950
一定要来复习一下

40:04.950 --> 40:06.950
因为面试的时候特别爱考

40:08.950 --> 40:09.950
但是支付串

40:09.950 --> 40:10.950
支付串拼接这一块

40:10.950 --> 40:11.950
还是蛮常见的

40:11.950 --> 40:12.950
支付串拼接

40:12.950 --> 40:13.950
因为我想

40:13.950 --> 40:14.950
我们的网页里边

40:14.950 --> 40:15.950
经常要用到各种支付串

40:15.950 --> 40:16.950
有的时候

40:16.950 --> 40:17.950
我们要拼接支付串

40:17.950 --> 40:18.950
我们需要拼接的

40:18.950 --> 40:20.950
需要用这种方式拼接的

40:20.950 --> 40:22.950
数字变成数字支付串

40:22.950 --> 40:26.950
如果是布尔变成

40:26.950 --> 40:28.950
布尔支付串

40:28.950 --> 40:30.950
布尔支付串

40:30.950 --> 40:31.950
这没啥说的

40:31.950 --> 40:32.950
初就变成初

40:32.950 --> 40:34.950
force就变成force

40:34.950 --> 40:35.950
比方说

40:35.950 --> 40:40.900
qabc

40:40.900 --> 40:41.900
就变成了qabc

40:41.900 --> 40:44.900
force加上123

40:44.900 --> 40:46.900
就变成了force123

40:46.900 --> 40:47.900
这个没啥好说的

40:47.900 --> 40:49.900
只要有一边有支付串

40:49.900 --> 40:50.900
它又一定要把前面

40:50.900 --> 40:51.900
转成了支付串

40:51.900 --> 40:52.900
另一边转成支付串

40:52.900 --> 40:53.900
好

40:53.900 --> 40:54.900
如果一边不是支付串

40:54.900 --> 40:56.900
那就是之前说的

40:56.900 --> 40:57.900
转成了数字

40:57.900 --> 40:58.900
转成了数字

40:58.900 --> 40:59.900
我说的是

40:59.900 --> 41:00.900
一边有支付串的情况

41:00.900 --> 41:02.900
转成了支付串

41:02.900 --> 41:03.900
只要有支付串

41:03.900 --> 41:04.900
记住

41:04.900 --> 41:05.900
只要有支付串

41:05.900 --> 41:06.900
它就表示拼接

41:06.900 --> 41:09.900
那就一定要是两个支付串

41:09.900 --> 41:11.900
然后再来

41:11.900 --> 41:13.900
布尔还有它

41:13.900 --> 41:14.900
还有NOW

41:14.900 --> 41:15.900
NOW转成支付串

41:15.900 --> 41:16.900
是怎么支付串呢

41:16.900 --> 41:19.900
是NOW支付串

41:20.900 --> 41:22.900
就这个玩意

41:22.900 --> 41:23.900
就直接写

41:23.900 --> 41:24.900
就直接写

41:24.900 --> 41:25.900
NOW

41:25.900 --> 41:26.900
就直接是NOW

41:26.900 --> 41:28.900
保证看一下

41:28.900 --> 41:30.900
NOW拼接上啥呢

41:30.900 --> 41:31.900
一个1

41:31.900 --> 41:33.900
你看就NOW1

41:33.900 --> 41:36.900
NOW拼接上一个空支付串呢

41:36.900 --> 41:37.900
是一样的

41:37.900 --> 41:38.900
空支付串

41:38.900 --> 41:39.900
它总是支付串

41:39.900 --> 41:40.900
对吧

41:40.900 --> 41:41.900
它总会是支付串

41:41.900 --> 41:42.900
所以说

41:42.900 --> 41:44.900
它又要转成支付串

41:44.900 --> 41:46.900
把它转成NOW支付串

41:46.900 --> 41:47.900
再拼接一个空支付串

41:47.900 --> 41:48.900
就啥都没有

41:48.900 --> 41:49.900
啥都不拼接

41:49.900 --> 41:51.900
它仍然是一个支付串

41:51.900 --> 41:52.900
所以说拼接结果还是NOW

41:52.900 --> 41:54.900
还是NOW

41:54.900 --> 41:55.900
你要这个意思吧

41:55.900 --> 41:56.900
非常简单

41:56.900 --> 41:57.900
那再来

41:57.900 --> 41:59.900
NOW加NOW

41:59.900 --> 42:00.900
讲过没

42:00.900 --> 42:02.900
是讲过的

42:02.900 --> 42:03.900
讲过的

42:03.900 --> 42:04.900
两个都是

42:04.900 --> 42:06.900
就是要进行数学运算

42:06.900 --> 42:08.900
算数运算的时候

42:08.900 --> 42:10.900
那么

42:10.900 --> 42:12.900
把它转成数字

42:12.900 --> 42:14.900
把它转成数字进行算数运算

42:14.900 --> 42:15.900
之前

42:15.900 --> 42:16.900
虽然我讲的时候

42:16.900 --> 42:17.900
是加号除外

42:17.900 --> 42:18.900
但是除开这几种

42:18.900 --> 42:19.900
特殊情况的时候

42:19.900 --> 42:22.900
也可以应用前面的规则

42:22.900 --> 42:23.900
因为这一边

42:23.900 --> 42:24.900
没有支付串

42:24.900 --> 42:25.900
没有支付串

42:25.900 --> 42:27.900
所以说进行数学运算

42:27.900 --> 42:28.900
好

42:28.900 --> 42:29.900
然后Undefend

42:29.900 --> 42:30.900
Undefend

42:30.900 --> 42:31.900
你们猜

42:31.900 --> 42:32.900
应该是啥

42:32.900 --> 42:33.900
转成支付串

42:33.900 --> 42:35.900
Undefend

42:35.900 --> 42:37.900
看一下

42:37.900 --> 42:38.900
Undefend

42:38.900 --> 42:39.900
拼接支付串

42:39.900 --> 42:40.900
Undefend

42:40.900 --> 42:41.900
Undefend

42:41.900 --> 42:42.900
拼接支付串

42:42.900 --> 42:43.900
Undefend

42:43.900 --> 42:44.900
看没

42:44.900 --> 42:45.900
好

42:45.900 --> 42:46.900
然后是对象

42:46.900 --> 42:47.900
对象

42:47.900 --> 42:49.900
对象转成支付串

42:49.900 --> 42:50.900
是啥

42:50.900 --> 42:52.900
对象转成支付串是啥

42:52.900 --> 42:53.900
说过的

42:53.900 --> 42:57.220
objects

42:57.220 --> 42:58.220
objects

42:58.220 --> 42:59.220
看没

42:59.220 --> 43:00.220
对象转支付串

43:00.220 --> 43:02.220
对象转支付串

43:02.220 --> 43:03.220
保存

43:03.220 --> 43:04.220
看一下

43:05.220 --> 43:06.220
对象

43:06.220 --> 43:07.220
扩起来

43:07.220 --> 43:08.220
一个对象

43:08.220 --> 43:10.220
拼接上一个支付串

43:10.220 --> 43:11.220
一个支付串

43:11.220 --> 43:12.220
看一下

43:12.220 --> 43:13.220
123

43:13.220 --> 43:14.220
看一下

43:14.220 --> 43:15.220
变这个样子

43:15.220 --> 43:16.220
对吧

43:16.220 --> 43:17.220
把对象转成支付串

43:17.220 --> 43:18.220
这个东西

43:18.220 --> 43:19.220
这个东西

43:19.220 --> 43:20.220
拼接上123

43:20.220 --> 43:21.220
甭管你是啥对象

43:21.220 --> 43:22.220
出来都是个东西

43:23.220 --> 43:24.220
这这一块

43:25.220 --> 43:26.220
这第一种情况

43:26.220 --> 43:27.220
加号一边有支付串

43:27.220 --> 43:29.220
还一边为支付串拼接

43:31.220 --> 43:33.220
加号另外的情况就是

43:33.220 --> 43:34.220
加号

43:34.220 --> 43:35.220
两边

43:35.220 --> 43:36.220
都没有支付串

43:36.220 --> 43:37.220
都没有支付串

43:37.220 --> 43:38.220
那就是数字

43:38.220 --> 43:39.220
数字运算了

43:39.220 --> 43:40.220
跟前面一样了

43:40.220 --> 43:41.220
但一边

43:41.220 --> 43:42.220
某一边

43:42.220 --> 43:44.220
有对象

43:44.220 --> 43:45.220
有对象

43:46.220 --> 43:47.220
然后怎么办

43:47.220 --> 43:48.220
这个时候怎么办

43:48.220 --> 43:49.220
将对象

43:49.220 --> 43:51.220
转为

43:51.220 --> 43:52.220
转换为支付串

43:53.220 --> 43:55.220
然后按照

43:55.220 --> 43:57.220
按照规则1

43:57.220 --> 43:59.220
按照上面的规则

44:00.220 --> 44:01.220
进行

44:01.220 --> 44:02.220
对象这一块又特殊了

44:02.220 --> 44:03.220
它又特殊了

44:03.220 --> 44:05.220
就是一边有对象

44:05.220 --> 44:06.220
两边都没有支付串

44:06.220 --> 44:07.220
但是一边有对象

44:07.220 --> 44:08.220
它怎么办

44:08.220 --> 44:09.220
它是把对象转成支付串

44:09.220 --> 44:11.220
然后按照上面的规则进行

44:11.220 --> 44:12.220
来吧

44:14.850 --> 44:15.850
一边其中有对象

44:15.850 --> 44:17.850
比方说这里是个数字

44:17.850 --> 44:18.850
你可以看到

44:18.850 --> 44:20.850
神奇的事情又来了

44:20.850 --> 44:21.850
这两边都没有支付串

44:21.850 --> 44:22.850
对吧

44:22.850 --> 44:23.850
按理说是不应该拼接的

44:23.850 --> 44:24.850
但是有对象不一样

44:24.850 --> 44:25.850
有对象的话

44:25.850 --> 44:26.850
它会把对象

44:26.850 --> 44:27.850
转换成支付串

44:27.850 --> 44:28.850
转换成支付串

44:28.850 --> 44:30.850
目前只能这样理解

44:30.850 --> 44:31.850
但是还不是一定的

44:31.850 --> 44:32.850
还不是一定的

44:32.850 --> 44:33.850
它把对象

44:33.850 --> 44:34.850
转换成支付串

44:34.850 --> 44:35.850
然后按照支付串拼接

44:35.850 --> 44:36.850
我们以后

44:36.850 --> 44:37.850
学生更多知识过后

44:37.850 --> 44:38.850
就知道了

44:38.850 --> 44:39.850
为什么对象

44:39.850 --> 44:40.850
这里是这样处理的

44:40.850 --> 44:41.850
那么得到结果

44:41.850 --> 44:42.850
就是这个玩意

44:42.850 --> 44:44.850
有啥用的

44:44.850 --> 44:45.850
暖用没有

44:45.850 --> 44:46.850
这东西暖用没有

44:46.850 --> 44:48.850
这就是为了应付面试

44:48.850 --> 44:49.850
为了应付面试

44:49.850 --> 44:50.850
但支付串拼接有用

44:50.850 --> 44:51.850
就是两个支付串拼接

44:51.850 --> 44:53.850
支付串跟数字进行拼接

44:53.850 --> 44:55.850
这个相当有用

44:55.850 --> 44:56.850
相当有用

44:56.850 --> 44:57.850
但是像这些东西

44:57.850 --> 44:58.850
什么对象这里

44:58.850 --> 44:59.850
进行算数运算

44:59.850 --> 45:01.850
没有任何用

45:01.850 --> 45:04.850
就是为了应付面试的

45:04.850 --> 45:05.850
以后面试之前

45:05.850 --> 45:06.850
先有个印象

45:06.850 --> 45:07.850
以后面试之前

45:07.850 --> 45:09.850
来复习一下就完事了

45:09.850 --> 45:12.850
都是加号

45:12.850 --> 45:13.850
那么其他的情况

45:13.850 --> 45:14.850
就没了

45:14.850 --> 45:15.850
其他的情况

45:15.850 --> 45:16.850
就这么长情况了

45:16.850 --> 45:17.850
就是数学运算了

45:17.850 --> 45:18.850
数学运算跟前面

45:18.850 --> 45:19.850
是不是一样的

45:19.850 --> 45:21.850
其他情况

45:21.850 --> 45:22.850
其他情况

45:22.850 --> 45:27.850
和上面的数学运算

45:27.850 --> 45:29.850
一致

45:29.850 --> 45:30.850
把它装成数字

45:30.850 --> 45:32.850
来进行运算

45:32.850 --> 45:33.850
好了

45:33.850 --> 45:34.850
这就是我们这一节

45:34.850 --> 45:36.850
可要讲的关于数字

45:36.850 --> 45:37.850
数学运算服

45:37.850 --> 45:38.850
关于数学运算服

45:38.850 --> 45:40.850
就这么一些东西

45:40.850 --> 45:42.850
没啥问题了吧

45:42.850 --> 45:45.850
我们来做个练习

45:45.850 --> 45:46.850
左边多了一个文件

45:46.850 --> 45:48.850
因为我这个视频剪辑过的

45:48.850 --> 45:49.850
我把这个练习引寫好了

45:49.850 --> 45:52.850
我们来看一下这个练习

45:52.850 --> 45:53.850
我们来说出

45:53.850 --> 45:55.850
下边的输出结果是什么

45:55.850 --> 45:57.850
下边的输出结果是啥

45:57.850 --> 45:58.850
一个个来呗

45:58.850 --> 46:00.850
第一个很简单

46:00.850 --> 46:01.850
这个没啥好说的

46:01.850 --> 46:03.850
这个输出结果是啥呢

46:03.850 --> 46:05.850
输出结果是

46:05.850 --> 46:06.850
注意优先级

46:06.850 --> 46:09.850
先算加减乘除求鱼

46:09.850 --> 46:11.850
先算成法除法求鱼

46:11.850 --> 46:13.850
这些优先级都比较高的

46:13.850 --> 46:14.850
先算这些

46:14.850 --> 46:16.850
二乘以三等于六

46:16.850 --> 46:18.850
一加上六等于七

46:18.850 --> 46:20.850
这个没啥好说的

46:20.850 --> 46:22.850
第二个是求鱼

46:22.850 --> 46:24.850
求鱼优先级跟除法优先级

46:24.850 --> 46:26.850
成法优先级是一样的

46:26.850 --> 46:27.850
它要先算的

46:27.850 --> 46:29.850
三除一二的鱼数多少呢

46:29.850 --> 46:31.850
三除一二的鱼数是不是一

46:31.850 --> 46:33.850
三为一

46:33.850 --> 46:35.850
鱼数为一

46:35.850 --> 46:37.850
然后一加一等于二

46:37.850 --> 46:39.850
前两个是七和二

46:40.850 --> 46:42.850
下面这个注意优先级

46:42.850 --> 46:43.850
注意优先级

46:43.850 --> 46:44.850
先算啥

46:44.850 --> 46:45.850
先算这个东西

46:45.850 --> 46:47.850
这个东西等于多少

46:47.850 --> 46:48.850
一

46:48.850 --> 46:50.850
把整个这一块看成是一

46:50.850 --> 46:53.850
字符串拼接一

46:53.850 --> 46:55.850
应该用字符串拼接

46:55.850 --> 46:57.850
而不是算数一算

46:57.850 --> 46:58.850
字符串

46:58.850 --> 47:00.850
加号一点出现了字符串

47:00.850 --> 47:02.850
所以说这边应该是拼接

47:02.850 --> 47:03.850
拼接啥呢

47:03.850 --> 47:05.850
拼接上这个表达是一

47:05.850 --> 47:07.850
拼接上这个表达是一

47:08.850 --> 47:10.850
字符串拼接一

47:10.850 --> 47:11.850
能理解吧

47:12.850 --> 47:13.850
这边的结果

47:13.850 --> 47:14.850
你可以先把这边算出来

47:14.850 --> 47:15.850
算出来的结果是多少

47:15.850 --> 47:16.850
就是一

47:16.850 --> 47:17.850
相当于是字符串拼接一

47:17.850 --> 47:18.850
对吧

47:18.850 --> 47:19.850
得到结果就是

47:19.850 --> 47:20.850
字符串拼接一

47:20.850 --> 47:21.850
好

47:21.850 --> 47:22.850
下面这个

47:22.850 --> 47:23.850
好

47:23.850 --> 47:25.850
下面这个注意看优先级

47:25.850 --> 47:26.850
先这个优先级很高的

47:26.850 --> 47:27.850
非常非常高的

47:27.850 --> 47:29.850
比那个就是什么

47:29.850 --> 47:30.850
比那个就是

47:30.850 --> 47:32.850
惩罚处罚优先级都还要高

47:32.850 --> 47:34.850
所以说先要算这个

47:34.850 --> 47:35.850
好先算这个的时候

47:35.850 --> 47:36.850
你看

47:36.850 --> 47:37.850
不是加号

47:37.850 --> 47:38.850
是正数

47:38.850 --> 47:39.850
正数

47:39.850 --> 47:40.850
那么是不是要

47:40.850 --> 47:41.850
算这个时候

47:41.850 --> 47:42.850
是不是要把那个

47:42.850 --> 47:43.850
再放大一点

47:44.850 --> 47:45.850
算这个的时候

47:45.850 --> 47:46.850
是不是要把它个

47:46.850 --> 47:48.850
字符串转换成数字

47:48.850 --> 47:49.850
转成数字

47:49.850 --> 47:50.850
这里有点忘了说了

47:51.850 --> 47:52.850
忘了说了

47:52.850 --> 47:53.850
就是字符串转数字

47:54.850 --> 47:56.850
如果字符串

47:56.850 --> 47:58.850
是一个空字符串

47:58.850 --> 48:00.850
什么叫空字符串呢

48:01.850 --> 48:02.850
指的是

48:02.850 --> 48:03.850
没有任何内容

48:03.850 --> 48:04.850
包括空格

48:04.850 --> 48:05.850
空格都没有

48:05.850 --> 48:07.850
没有任何内容

48:07.850 --> 48:08.850
没有任何内容

48:08.850 --> 48:10.850
那么这样的一个字符串就是空字符串

48:10.850 --> 48:12.850
这就是个空字符串

48:12.850 --> 48:13.850
那么这个时候

48:13.850 --> 48:15.850
它转换的结果是啥呢

48:15.850 --> 48:16.850
转换的结果

48:16.850 --> 48:18.850
转换为您

48:18.850 --> 48:19.850
好

48:19.850 --> 48:20.850
如果有空格

48:20.850 --> 48:21.850
再来记一笔

48:21.850 --> 48:23.850
就字符串转换

48:23.850 --> 48:24.850
它的规则比较复杂

48:24.850 --> 48:25.850
比较繁硕

48:25.850 --> 48:26.850
不能说复杂

48:26.850 --> 48:27.850
字符串转换时

48:28.850 --> 48:31.850
会忽略前后空格

48:31.850 --> 48:33.850
会忽略掉

48:33.850 --> 48:35.850
这个字符串里面的前后空格

48:35.850 --> 48:36.850
都会忽略掉

48:36.850 --> 48:37.850
就当不存在一样

48:37.850 --> 48:38.850
哪怕你写的空格

48:38.850 --> 48:40.850
直接给你忽略掉了

48:40.850 --> 48:41.850
忽略掉过后

48:41.850 --> 48:42.850
是不是有空字符串了

48:42.850 --> 48:44.850
比方说咱们举个例子

48:44.850 --> 48:45.850
如果你是一个空字符串

48:45.850 --> 48:46.850
那肯定是您

48:46.850 --> 48:47.850
这是规则

48:47.850 --> 48:49.850
如果这个字符串里面有空格

48:49.850 --> 48:50.850
它会忽略掉

48:50.850 --> 48:52.850
这个字符串前后的空格

48:52.850 --> 48:54.850
就是文字前面的空格

48:54.850 --> 48:55.850
文字后面的空格

48:55.850 --> 48:56.850
那这个字符串里面

48:56.850 --> 48:57.850
没有任何文字

48:57.850 --> 48:58.850
那么所有的空格

48:58.850 --> 48:59.850
全部被忽略了

48:59.850 --> 49:00.850
那么忽略过后

49:00.850 --> 49:02.850
是不是还是一个空字符串

49:04.850 --> 49:05.850
比方说

49:05.850 --> 49:06.850
这里边如果写了个空格

49:06.850 --> 49:07.850
写了个E

49:07.850 --> 49:08.850
转换结果为E

49:08.850 --> 49:10.850
前后空格忽略

49:10.850 --> 49:11.850
这个字符串里面

49:11.850 --> 49:13.850
如果写了一个E

49:13.850 --> 49:14.850
空格E

49:14.850 --> 49:15.850
那么就是NAN

49:15.850 --> 49:17.850
中间的空格不会忽略掉

49:17.850 --> 49:18.850
中间的空格不会忽略

49:18.850 --> 49:19.850
那么它现在转换的是啥

49:19.850 --> 49:20.850
转换的是E

49:20.850 --> 49:21.850
空格空格E

49:21.850 --> 49:22.850
那怎么转换呢

49:22.850 --> 49:23.850
空格是啥呢

49:23.850 --> 49:24.850
它不知道

49:24.850 --> 49:25.850
所以转换出来是NAN

49:25.850 --> 49:26.850
转换不了

49:26.850 --> 49:27.850
如果这个字符串里面

49:27.850 --> 49:28.850
写成空格A

49:28.850 --> 49:29.850
写成空格

49:29.850 --> 49:31.850
转换结果NAN

49:31.850 --> 49:32.850
如果把空格E

49:32.850 --> 49:33.850
去掉A

49:33.850 --> 49:35.850
是一个不是数字

49:35.850 --> 49:36.850
转换不了

49:36.850 --> 49:38.850
这个规则比较繁硕

49:38.850 --> 49:39.850
说一下这里

49:39.850 --> 49:41.850
那么现在看这

49:41.850 --> 49:42.850
这个玩意儿

49:42.850 --> 49:43.850
先运行它

49:43.850 --> 49:44.850
先运行这个表达式

49:44.850 --> 49:46.850
这个表达式出来的结果是啥

49:46.850 --> 49:47.850
是不是NAN

49:47.850 --> 49:48.850
对吧

49:48.850 --> 49:49.850
再运行这个

49:49.850 --> 49:50.850
出来的结果是啥

49:50.850 --> 49:51.850
E

49:51.850 --> 49:52.850
0加E是不是E

49:52.850 --> 49:53.850
对吧

49:53.850 --> 49:54.850
OK 这里是E

49:54.850 --> 49:55.850
数字E

49:56.850 --> 49:57.850
再看这个

49:57.850 --> 49:58.850
再看这个

49:58.850 --> 50:00.850
特别有意思

50:01.850 --> 50:02.850
先看这一部分

50:02.850 --> 50:03.850
先运行它

50:03.850 --> 50:04.850
它的优先级高

50:04.850 --> 50:05.850
先运行它

50:05.850 --> 50:07.850
振富的优先级是很高的

50:07.850 --> 50:08.850
先运行它

50:08.850 --> 50:09.850
那么运行它的时候

50:09.850 --> 50:10.850
转换成什么

50:10.850 --> 50:12.850
转换的数字还是字符串

50:12.850 --> 50:13.850
有一些朋友说

50:13.850 --> 50:14.850
应该转换成字符串

50:14.850 --> 50:15.850
因为这边有字符串

50:15.850 --> 50:17.850
但是现在还没有看到它

50:17.850 --> 50:18.850
它的优先级已经高了

50:18.850 --> 50:19.850
已经很高了

50:19.850 --> 50:21.850
所以说要先算它

50:21.850 --> 50:22.850
要先算它

50:22.850 --> 50:23.850
那么转换成字符串

50:23.850 --> 50:24.850
对吧

50:24.850 --> 50:25.850
转换成字符串

50:25.850 --> 50:26.850
转换成字符串的时候

50:26.850 --> 50:27.850
怎么转换

50:27.850 --> 50:28.850
是不是变成

50:28.850 --> 50:29.850
不解个车

50:30.850 --> 50:31.850
转换成什么

50:31.850 --> 50:32.850
转换成数字

50:32.850 --> 50:33.850
转换成数字是不是NAN

50:33.850 --> 50:34.850
我们讲过了

50:34.850 --> 50:35.850
对吧

50:35.850 --> 50:36.850
没问题吧

50:37.850 --> 50:39.850
一个对象转换的数字是NAN

50:40.850 --> 50:42.850
NAN在拼接上这个

50:42.850 --> 50:43.850
字符串是什么

50:43.850 --> 50:45.850
就是NAN

50:46.850 --> 50:47.850
没问题吧

50:48.850 --> 50:49.850
下面这个

50:50.850 --> 50:51.850
100除1

50:52.850 --> 50:53.850
返回

50:54.850 --> 50:56.850
这个是NAN

50:57.850 --> 50:58.850
下面这个

50:58.850 --> 51:00.850
除1是的余数

51:00.850 --> 51:01.850
除1是能除净

51:01.850 --> 51:02.850
能除净

51:02.850 --> 51:04.850
100除1是能除净的

51:04.850 --> 51:05.850
25没

51:05.850 --> 51:06.850
25没

51:06.850 --> 51:07.850
余数为0

51:07.850 --> 51:08.850
余数为0

51:08.850 --> 51:09.850
这个表达是算出来了

51:09.850 --> 51:10.850
这个表达算出来了

51:10.850 --> 51:11.850
过后再看这个

51:11.850 --> 51:13.850
0除10

51:13.850 --> 51:14.850
说过的

51:14.850 --> 51:16.850
NAN

51:16.850 --> 51:18.850
NAN

51:20.850 --> 51:21.850
下面这个

51:22.850 --> 51:23.850
这个能两个浪

51:23.850 --> 51:24.850
两个浪

51:24.850 --> 51:25.850
转换成数字

51:25.850 --> 51:26.850
他们是数学运算

51:26.850 --> 51:27.850
转换成数字

51:27.850 --> 51:28.850
是不是2个0

51:28.850 --> 51:29.850
对吧

51:29.850 --> 51:30.850
2个0

51:30.850 --> 51:31.850
2个0相处

51:31.850 --> 51:32.850
NAN

51:32.850 --> 51:33.850
NAN

51:34.850 --> 51:35.850
好

51:35.850 --> 51:36.850
然后下面这个

51:36.850 --> 51:37.850
下面这个

51:37.850 --> 51:38.850
2个加号

51:38.850 --> 51:39.850
从左到右进行运算

51:39.850 --> 51:41.850
他们优先级一样

51:41.850 --> 51:43.850
从左到右进行运算

51:43.850 --> 51:44.850
先是这一部分

51:45.850 --> 51:47.850
这一部分是进行数学运算

51:47.850 --> 51:48.850
没有制服串

51:48.850 --> 51:49.850
没有制服串

51:49.850 --> 51:50.850
数学运算

51:50.850 --> 51:51.850
但是有对象

51:51.850 --> 51:52.850
有对象

51:52.850 --> 51:53.850
一边有对象

51:53.850 --> 51:54.850
所以说

51:54.850 --> 51:56.850
它会把对象转换成啥

51:56.850 --> 51:58.850
它会把对象转换成制服串

51:58.850 --> 51:59.850
OB几个次

51:59.850 --> 52:00.850
OB几个次

52:00.850 --> 52:01.850
然后

52:01.850 --> 52:02.850
S是啥

52:02.850 --> 52:03.850
S是undefend

52:03.850 --> 52:04.850
对吧

52:04.850 --> 52:05.850
没有复制

52:05.850 --> 52:06.850
undefend

52:06.850 --> 52:07.850
那么这两个拼接是啥

52:07.850 --> 52:08.850
拼接是啥

52:08.850 --> 52:10.850
拼接出来是不是undefend

52:11.850 --> 52:12.850
undefend

52:12.850 --> 52:13.850
OB几个次

52:13.850 --> 52:15.850
在拼接上123

52:15.850 --> 52:16.850
是不是这个玩意

52:16.850 --> 52:17.850
就这个玩意了

52:18.850 --> 52:19.850
OK

52:19.850 --> 52:20.850
那是这里

52:20.850 --> 52:21.850
这是这一块

52:21.850 --> 52:22.850
这里的都到结果

52:22.850 --> 52:23.850
这个

52:23.850 --> 52:24.850
好

52:24.850 --> 52:25.850
下面这个

52:26.850 --> 52:27.850
首先把这个1

52:27.850 --> 52:28.850
和它相加

52:28.850 --> 52:29.850
没有乘号

52:29.850 --> 52:30.850
没有除号

52:30.850 --> 52:31.850
先把1和它相加

52:31.850 --> 52:32.850
得到的是啥

52:32.850 --> 52:33.850
制服串1

52:33.850 --> 52:34.850
对吧

52:34.850 --> 52:36.850
一个表达是一个表达是看

52:36.850 --> 52:37.850
一个表达是一个表达是看

52:37.850 --> 52:39.850
千万不要整体一下出来

52:39.850 --> 52:40.850
一下出不来的

52:40.850 --> 52:42.850
它都是一步一步进行运算的

52:42.850 --> 52:43.850
它出来制服串1

52:43.850 --> 52:45.850
然后在拼接上2

52:45.850 --> 52:46.850
你看这一部分

52:46.850 --> 52:47.850
这个表达是

52:47.850 --> 52:48.850
这个表达是算出来是啥

52:48.850 --> 52:49.850
制服串

52:49.850 --> 52:50.850
一边有制服串是不是拼接

52:50.850 --> 52:51.850
只要出现了制服串

52:51.850 --> 52:52.850
就一定是拼接

52:52.850 --> 52:53.850
用的是加号

52:53.850 --> 52:54.850
就一定是拼接

52:54.850 --> 52:55.850
拼接的时候

52:55.850 --> 52:57.850
我们就可以把它拼接成为什么

52:57.850 --> 52:58.850
1 2

52:58.850 --> 53:00.850
拼接成为1 2

53:00.850 --> 53:01.850
这里拼接成1 2

53:01.850 --> 53:02.850
然后再拼接3

53:02.850 --> 53:03.850
是不是1 2 3

53:03.850 --> 53:04.850
对不对

53:04.850 --> 53:05.850
制服串1 2 3

53:05.850 --> 53:07.850
制服串1 2 3

53:07.850 --> 53:08.850
制服串1 2 3

53:08.850 --> 53:09.850
好

53:09.850 --> 53:10.850
下面这个

53:11.850 --> 53:12.850
数学运算

53:12.850 --> 53:13.850
对吧

53:13.850 --> 53:14.850
数学运算

53:14.850 --> 53:15.850
好

53:15.850 --> 53:16.850
数学运算

53:16.850 --> 53:17.850
这个东西是不是转换成

53:17.850 --> 53:18.850
NAN

53:18.850 --> 53:19.850
好

53:19.850 --> 53:20.850
NAN

53:20.850 --> 53:21.850
这个LOW转成啥

53:21.850 --> 53:22.850
转换成0

53:22.850 --> 53:23.850
NAN

53:23.850 --> 53:24.850
N跟0

53:24.850 --> 53:26.850
来进行运算

53:26.850 --> 53:27.850
得到结果是啥呢

53:28.850 --> 53:30.850
NAN跟0进行运算

53:30.850 --> 53:31.850
得到的结果是啥呢

53:31.850 --> 53:33.850
是不是NAN

53:33.850 --> 53:35.850
NAN跟任何东西进行运算

53:35.850 --> 53:37.850
得到的结果都是NAN

53:37.850 --> 53:38.850
好

53:38.850 --> 53:39.850
下面这个

53:40.850 --> 53:41.850
一不小心要做错

53:41.850 --> 53:42.850
下面这个

53:42.850 --> 53:44.850
注意前面是个加号

53:44.850 --> 53:45.850
这是个正号

53:45.850 --> 53:46.850
它的优先级很高的

53:46.850 --> 53:47.850
它先要算这个

53:47.850 --> 53:49.850
算这个东西得到的结果是啥

53:49.850 --> 53:50.850
是0对吧

53:50.850 --> 53:51.850
0加上100

53:52.850 --> 53:53.850
100

53:53.850 --> 53:54.850
好

53:54.850 --> 53:55.850
看一下呗

53:55.850 --> 53:56.850
看一下运行结果

53:56.850 --> 54:01.310
也不是2

54:01.310 --> 54:02.310
好

54:02.310 --> 54:03.310
看一下

54:03.310 --> 54:04.310
7211

54:04.310 --> 54:05.310
7211

54:05.310 --> 54:06.310
注意

54:06.310 --> 54:07.310
这个是字母串

54:07.310 --> 54:08.310
这个是字母串

54:08.310 --> 54:09.310
你看字母串的颜色

54:09.310 --> 54:10.310
看颜色是啥

54:10.310 --> 54:11.310
颜色是黑色对吧

54:11.310 --> 54:12.310
是黑色

54:12.310 --> 54:13.310
好

54:13.310 --> 54:14.310
下面这个

54:14.310 --> 54:15.310
3个NAN

54:15.310 --> 54:16.310
3个NAN

54:16.310 --> 54:18.310
NAN

54:18.310 --> 54:19.310
NAN

54:19.310 --> 54:20.310
第一个是字母串

54:20.310 --> 54:21.310
第一个是字母串

54:21.310 --> 54:22.310
我这里

54:22.310 --> 54:23.310
我这里写错了

54:23.310 --> 54:24.310
这里是字母串

54:24.310 --> 54:25.310
这里写错了

54:25.310 --> 54:27.310
这个地方转发出来是NAN

54:27.310 --> 54:28.310
NAN

54:28.310 --> 54:29.310
字母串拼接得到的结果是

54:29.310 --> 54:31.310
字母串的NAN

54:31.310 --> 54:32.310
我这里写错了

54:32.310 --> 54:33.310
对了

54:33.310 --> 54:34.310
这里应该是字母串的NAN

54:34.310 --> 54:36.310
刚才少写了一个字母串

54:36.310 --> 54:38.310
NANNAN

54:38.310 --> 54:40.310
下面两个就是正常的数字了

54:40.310 --> 54:41.310
下面两个是正常的数字

54:41.310 --> 54:42.310
看颜色呗

54:42.310 --> 54:44.310
颜色就是字母串

54:44.310 --> 54:45.310
好

54:45.310 --> 54:46.310
再下面这个

54:46.310 --> 54:47.310
ONDFAN的OBGX123

54:47.310 --> 54:48.310
看没

54:48.310 --> 54:49.310
字母串

54:49.310 --> 54:50.310
ONDFAN的OBGX123

54:50.310 --> 54:52.310
下面的字母串123

54:52.310 --> 54:54.310
字母串黑色的123

54:54.310 --> 54:56.310
下面这个NAN100

54:56.310 --> 54:58.310
NAN100

54:58.310 --> 55:00.310
把这个联系题搞定

55:00.310 --> 55:01.310
彻底理解

55:01.310 --> 55:02.310
你如果把这个联系题搞定了

55:02.310 --> 55:04.310
基本上就是

55:04.310 --> 55:05.310
考虑运算符这一块

55:05.310 --> 55:06.310
特别是

55:06.310 --> 55:07.310
至少数学运算

55:07.310 --> 55:08.310
算数运算这一块

55:08.310 --> 55:09.310
当然我还没讲完

55:09.310 --> 55:11.310
算数运算还个家家闲见

55:11.310 --> 55:13.310
至少这一块东西考不到底了

55:14.310 --> 55:15.310
OK

55:15.310 --> 55:16.310
有了算数运算过后

55:16.310 --> 55:18.310
咱们来做两个作业题

55:18.310 --> 55:19.310
做两个作业题

55:19.310 --> 55:21.310
作业

55:21.310 --> 55:22.310
作业

55:22.310 --> 55:23.310
一定要做

55:23.310 --> 55:24.310
作业一定要做

55:24.310 --> 55:25.310
别看它简单

55:25.310 --> 55:26.310
第一个作业题

55:26.310 --> 55:28.310
大家做作业的话

55:28.310 --> 55:29.310
我就肯定是给你们

55:29.310 --> 55:30.310
规定的作业都是

55:30.310 --> 55:31.310
我们以后

55:31.310 --> 55:32.310
起代码经常用到的

55:32.310 --> 55:34.310
一些代码格式

55:34.310 --> 55:35.310
不太会出现

55:35.310 --> 55:36.310
这种就是那些

55:36.310 --> 55:37.310
面试题的时候的那种

55:37.310 --> 55:39.310
代码形式

55:39.310 --> 55:40.310
第一个题就是

55:40.310 --> 55:42.310
温度转换器

55:42.310 --> 55:43.310
温度转换器

55:43.310 --> 55:44.310
什么意思呢

55:44.310 --> 55:45.310
就是

55:45.310 --> 55:47.310
设置一个变量

55:47.310 --> 55:48.310
一个变量

55:48.310 --> 55:50.310
保存设施温度

55:50.310 --> 55:52.310
设施温度

55:52.310 --> 55:53.310
然后

55:53.310 --> 55:54.310
将其

55:54.310 --> 55:56.310
转换为

55:56.310 --> 55:57.310
转换为

55:57.310 --> 55:58.310
华氏温度

55:58.310 --> 55:59.310
因为我们知道温度

55:59.310 --> 56:00.310
有两种表示方式

56:00.310 --> 56:01.310
一种是设施温度

56:01.310 --> 56:02.310
设施温度用什么来表示

56:02.310 --> 56:03.310
用C来表示

56:03.310 --> 56:04.310
对吧

56:04.310 --> 56:05.310
C

56:05.310 --> 56:07.310
将其转换为华氏温度

56:07.310 --> 56:09.310
华氏温度

56:09.310 --> 56:10.310
华氏温度

56:10.310 --> 56:11.310
我们用F来表示

56:11.310 --> 56:12.310
这里有个公式

56:12.310 --> 56:13.310
大家看一下

56:13.310 --> 56:14.310
公式我给你写出来

56:14.310 --> 56:15.310
华氏温度等于

56:15.310 --> 56:17.310
等于

56:17.310 --> 56:19.310
五分之九

56:19.310 --> 56:20.310
五分之九

56:20.310 --> 56:21.310
乘以设施温度

56:21.310 --> 56:22.310
加上一个32

56:22.310 --> 56:23.310
这是

56:23.310 --> 56:24.310
华氏温度的计算公式

56:24.310 --> 56:25.310
的第一道题

56:26.310 --> 56:28.310
输出的时候

56:28.310 --> 56:29.310
尽量用一种

56:29.310 --> 56:30.310
友好的格式输出

56:30.310 --> 56:32.310
第二道题

56:33.310 --> 56:35.310
是关于

56:35.310 --> 56:37.310
利息

56:37.310 --> 56:39.310
利息计算器

56:39.310 --> 56:40.310
因为我们现在

56:40.310 --> 56:41.310
刚刚学习的

56:41.310 --> 56:42.310
数学运算

56:42.310 --> 56:43.310
练习一下

56:43.310 --> 56:44.310
当然我们现在

56:44.310 --> 56:45.310
目前只能做一些

56:45.310 --> 56:46.310
简单的数学运算

56:46.310 --> 56:47.310
利息计算器

56:47.310 --> 56:48.310
也很简单

56:48.310 --> 56:50.310
就是设施

56:50.310 --> 56:51.310
辨量

56:51.310 --> 56:52.310
分别存放

56:52.310 --> 56:53.310
什么了

56:53.310 --> 56:54.310
本金

56:54.310 --> 56:56.310
分别存放本金

56:56.310 --> 56:57.310
就是

56:57.310 --> 56:59.310
粤数

56:59.310 --> 57:01.310
存放的是粤数

57:01.310 --> 57:02.310
然后再存放

57:02.310 --> 57:03.310
你要存多少个月

57:03.310 --> 57:04.310
存多少个月

57:04.310 --> 57:05.310
粤数

57:05.310 --> 57:06.310
然后是

57:06.310 --> 57:08.310
连利率

57:09.310 --> 57:10.310
存放点

57:10.310 --> 57:11.310
本金粤数连利率

57:11.310 --> 57:13.310
然后计算

57:13.310 --> 57:15.310
计算利息

57:15.310 --> 57:17.310
计算利息

57:17.310 --> 57:18.310
这两个

57:18.310 --> 57:20.310
这两个就是

57:21.310 --> 57:22.310
小题

57:22.310 --> 57:23.310
因为这两个题

57:23.310 --> 57:24.310
都很简单

57:24.310 --> 57:25.310
所以说我就会在这里

57:25.310 --> 57:26.310
直接讲了

57:26.310 --> 57:27.310
当然你们要先做

57:27.310 --> 57:28.310
一定要先做一遍过后

57:28.310 --> 57:29.310
再来听我讲

57:29.310 --> 57:30.310
再来听我讲

57:33.310 --> 57:34.310
要不然我还是

57:34.310 --> 57:35.310
单独开解课

57:35.310 --> 57:36.310
算了算了

57:36.310 --> 57:37.310
我还是单独开解课

57:37.310 --> 57:38.310
我们说好的对吧

57:38.310 --> 57:39.310
说好的单独开解课

57:39.310 --> 57:40.310
OK

57:40.310 --> 57:41.310
那我单独开解课

57:41.310 --> 57:42.310
来讲吧

57:42.310 --> 57:43.310
OK这是关于

57:43.310 --> 57:44.310
这一块

57:44.310 --> 57:45.310
直接课

57:45.310 --> 57:46.310
算数运算符

57:46.310 --> 57:47.310
还有两个

57:47.310 --> 57:48.310
两个我们放到

57:48.310 --> 57:49.310
后面的口层来讲

