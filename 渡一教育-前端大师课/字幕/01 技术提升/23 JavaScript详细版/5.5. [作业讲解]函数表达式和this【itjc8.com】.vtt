WEBVTT

00:00.000 --> 00:15.770
来讲一下这套题

00:16.030 --> 00:23.190
第一道题我已经做好了 建立一个介石 然后把之前的改造成单对向模式

00:23.450 --> 00:28.830
这里我已经做好了 开门弄过来了 这个没啥说的 你们直接复制三天过来就完成了

00:29.090 --> 00:32.410
就是有些地方 该用Zs的地方 把它加上 就在这

00:32.670 --> 00:39.590
好像记得只有这里吧 只有这里 得到某年某月的天数 我这里加上个Zs点

00:40.090 --> 00:47.030
其他都没啥了啊 当然你可以先测试一下 你可以一个一个的再测试一下 怎么测试呢 其实你可以用这种方式

00:48.550 --> 00:54.430
test 这里边呢 我们啊 这里script 引用这个介石

00:57.230 --> 01:06.670
用comment 别的 别的方形 好在这里边直接可以直接测试啊 在这里边直接测试买方形是第二啥啥啥啊 直接测试一下就完成了

01:07.390 --> 01:10.990
好吧啊 这个不说了啊 地道题不说了 好 接下来

01:11.750 --> 01:22.060
呃 第二题啊 我先把这个页面打开吧 方便我们后边测试 好 第二题啊

01:23.140 --> 01:29.780
第二题有难度 第二题写出来了 公后的第三题第四题第五题就全部全部出来了啊

01:30.260 --> 01:32.980
所以说你关键是你第二题一开始要有一个思路

01:33.980 --> 01:38.580
写一个函数 为数主呢 排序啊 生序排序啊 生序排序

01:39.300 --> 01:46.580
要考虑到这个数组的所有可能 就是它有可能是任何数组啊 有可能是一个什么制服数换数组啊 有可能是一个什么

01:47.140 --> 01:48.260
呃 那个啥呢

01:50.660 --> 01:56.660
呃 那个啥 对向数组啊 对向数组 有可能是任何情况都要考虑进去 那怎么办呢

01:57.220 --> 02:04.260
好 我们这里先把个函数写出来啊 这个函数的名字啊 给他取个名字叫做sort啊 sort

02:05.220 --> 02:12.100
表示什么意思呢 表示给数组排序啊 给数组排序 你是不是要给我一个数组 这个没啥说的吧 对吧 你要给我一个数组

02:12.740 --> 02:20.340
好 打住是啊 这是为数组排序啊 给指定的数组啊 生序排序

02:21.700 --> 02:29.860
好 怎么排序呢 我按照我们以前的写法 怎么写 是不是跟冒泡排序 对吧 这个以前写过的啊 冒泡排序

02:30.260 --> 02:37.540
好 来呗啊 冒泡排序 我现在不讲了啊 如果是 如果是没有 如果是直播上课的时候 或者是

02:38.260 --> 02:47.620
线瞎的时候呢 我可能会再讲一次 但是现在是视频课程 之前的东西全在的啊 全部都在 你可以 如果你忘了怎么去排序的话啊 你可以去看一下

02:48.420 --> 02:52.660
i等于1啊 小于呢 长度啊 小于长度

02:53.940 --> 02:54.500
i加加

02:54.900 --> 03:05.620
这个i呢 就表示的是第几次啊 第几次排序 然后呢 里边写个循环借借呢 从几开始呢 从明开始借小于

03:06.180 --> 03:09.220
认识解i啊认识解i借加加

03:10.020 --> 03:13.780
好 比较什么呢 好 现在就是比较比较啥呢 比较

03:14.580 --> 03:15.140
这个数字

03:16.260 --> 03:16.420
和

03:17.780 --> 03:18.340
这个数字

03:19.620 --> 03:23.940
比较这两个数字啊 比较这两个数据啊 不是数字 不一定是数字 对吧

03:24.340 --> 03:29.700
比较这两个数据 看谁大谁小 以前我们咋比较的呢 以前是这样比较的 AR借

03:30.660 --> 03:36.820
然后呢 大于 AR 就前边的比后边大 怎么办呢 交换啊 这里是交换

03:37.460 --> 03:39.620
好 交换的代码呢 是一样的啊 Temp

03:40.500 --> 03:44.580
先保存过来 然后呢 给他复制为之后的那个字

03:45.780 --> 03:50.340
然后呢 把之后的那个字呢 在复制为之前保存的字 OK 就交换了

03:51.300 --> 03:57.060
好 现在我们来测试一下啊 测试一下 如果是一个普通数组的话 如果是一个数字数组的话 是不正确的

03:57.620 --> 03:59.940
好 给他个数组 随便写个啊 随便写个

04:03.740 --> 04:07.900
随便写个啊 保存 看一下啊 看一下这个输出是不正确的

04:08.380 --> 04:10.860
然后这里我们要把他输出啊 一个输出

04:11.980 --> 04:13.900
输出 然后把这个输出放过来

04:14.380 --> 04:19.660
放过来 对他进行排序 排序完了过后呢 对他进行输出啊 log 对不对

04:20.060 --> 04:20.620
console log

04:22.220 --> 04:22.940
输出

04:23.580 --> 04:24.380
好 保存看一下

04:25.740 --> 04:28.860
好 没问题 你看 正确的生去排序

04:29.500 --> 04:31.100
好 对数字没问题

04:32.220 --> 04:33.660
但是如果不是数字呢

04:34.860 --> 04:37.340
如果这里边不是数字 是一个对象怎么办

04:38.140 --> 04:44.620
比方说 我这个对象啊对象数组对象数组里边呢 有姓名对吧 姓名啊

04:45.180 --> 04:45.660
长三

04:46.620 --> 04:51.340
然后呢 年龄 年龄 十八岁 体重位置

04:52.300 --> 04:56.540
体重60公斤吧 60公斤 好的 第一个对象啊 第一个对象

04:56.780 --> 04:58.620
然后呢 还有第二个对象啊 我们一次写

04:59.420 --> 05:01.660
第二个对象 第三个对象 我们一次写

05:03.100 --> 05:05.260
好 假设了这是个对象数组里怎么办呢

05:05.660 --> 05:06.620
他又怎么排序呢

05:07.100 --> 05:09.420
比方说啊 我们换个名字啊 你是

05:12.140 --> 05:12.620
你是

05:13.500 --> 05:13.980
王五

05:14.940 --> 05:18.540
好 然后这里年龄了15岁啊 20岁

05:19.100 --> 05:23.100
啊 体重了啊 70公斤啊 比方说这里呢

05:26.140 --> 05:32.800
65公斤啊 好 比方说这是个对象数组 那现在还能排序吗 你告诉我 现在还能排序吗

05:33.600 --> 05:36.800
是不能排序了 不能排序的根源在哪

05:38.000 --> 05:40.000
想一想 无法排序的根源在哪

05:41.120 --> 05:41.600
是不是在这

05:42.560 --> 05:46.000
你用大语符号 是不是只能比较数字

05:47.360 --> 05:49.200
对象怎么来用这个符号呢

05:49.600 --> 05:53.120
之前我们是不是说过 对象呢 你要转换成数字才能进行比较

05:53.680 --> 05:58.320
转换成数字呢 怎么转呢 你要么先转换成制服错了对吧 转换成object车

05:58.880 --> 06:00.880
然后呢 再转换成数字就是NAN

06:01.440 --> 06:03.680
NAN跟任何东西比较都是NAN

06:04.320 --> 06:05.680
所以是不是这里出了问题

06:06.240 --> 06:07.120
是不是这里出了问题

06:07.760 --> 06:10.240
没法比较了啊 他没法比较了

06:11.120 --> 06:15.920
因此呢 现在我们要完成这个排序函数 要把它做成一个通用的排序函数

06:16.560 --> 06:23.280
差一个东西 就是比较大小 你只要告诉我了比较大小怎么比较 那我是不是就可以排序了

06:23.920 --> 06:26.720
对不对 你只要告诉我了怎么来比较大小

06:27.360 --> 06:31.200
谁大谁小 你把这个东西告诉我了 其他的是不是一样的

06:31.600 --> 06:34.800
你管你是什么数字啊 制服错了还是对象无所谓

06:35.280 --> 06:38.800
都是冒泡排序的算法一样的 交换了也是一样的

06:39.520 --> 06:42.640
我现在差的差 差的就是比较大小

06:44.400 --> 06:48.240
于是呢 我就可以这样子想 关键点来了 关键点来了

06:49.520 --> 06:55.120
我可以这样子想 你给我一个参数 这个参数的名字呢 叫做Compare

06:57.680 --> 06:59.440
好 这个参数是什么类型呢

07:01.200 --> 07:02.000
这个参数呢

07:02.960 --> 07:05.360
怎么Compare 是一个方形

07:06.480 --> 07:07.200
是一个方形

07:08.640 --> 07:12.560
是一个就是函数 这是一个函数参数 我给大家打算注释

07:13.280 --> 07:15.680
这个参数Compare 它是一个函数

07:16.880 --> 07:19.280
它用来做什么呢 用来比较大小

07:19.760 --> 07:26.560
比较大小 我到时候呢会给你两个数字 会给你两个元素 把数组里边两个元素给力

07:26.720 --> 07:28.880
你来帮我比较大小

07:29.840 --> 07:30.800
这就是你要做的事

07:31.520 --> 07:34.400
我把两个元素给力 你来告诉我谁大谁小

07:34.800 --> 07:38.560
我自己没法分辨啊 没法分辨 你来告诉我谁大谁小

07:39.520 --> 07:40.960
好 我们这里在主持里边规定

07:42.160 --> 07:46.400
该函数有两个参数 注意啊 我这里打的注释是谁

07:46.720 --> 07:49.840
是这个函数 你给我传的这个函数 它有两个参数

07:50.240 --> 07:52.720
为什么有两个参数呢 因为到时候呢 我会把这个

07:53.360 --> 07:55.760
给力 把两个数字给力 你来帮我比较大小

07:55.840 --> 07:59.280
我比较不了 我不知道你是什么数组 我比较不了 你来帮我比较

07:59.920 --> 08:06.640
有两个参数 呃 代表着数组的两个元素 代表数组中的两个元素

08:07.360 --> 08:12.400
通过这个函数呢 可以比较大小 啊 并且呢 该函数返回什么呢

08:12.960 --> 08:16.320
返回 呃 一个数字啊 一个数字

08:17.120 --> 08:20.240
如果是正数啊 我们这样规定啊 这样的规定

08:20.800 --> 08:27.200
如果是正数 则啊 第一个元素比第二个元素大

08:27.920 --> 08:33.440
元素大 如果是零 则相等啊 则相等

08:34.240 --> 08:37.520
如果是负数 则什么呢 则啊

08:38.880 --> 08:44.560
第一个元素比第二个元素小啊 这个注释有点多啊 有点多

08:44.560 --> 08:47.840
我主要是通过这个注释呢 给大家说明啊 说清楚

08:48.400 --> 08:51.920
主要是给大家说清楚啊 这个东西 他到底是什么意思

08:53.440 --> 08:57.440
给大家说清楚 再说一点啊 这是一个函数

08:58.400 --> 09:04.480
这个函数呢 你要传进来啊 你要传 作为参数传给我 因为我不知道怎么比较大小 你要告诉我

09:05.120 --> 09:09.440
这个函数你去来 就是雕用者来传递啊 雕用者来传递

09:09.440 --> 09:13.040
而且呢 这个函数呢 有两个参数 我到时候会把两个数字给你

09:13.760 --> 09:17.680
你来帮我比较大小 比较完了过后 你要告诉我一个结果 谁大谁小

09:18.320 --> 09:22.640
那么怎么告诉呢 我这里规定啊 这里规定通过一个数字来告诉 返回一个数字

09:23.040 --> 09:28.080
如果你是正数 那么第一个元素比第二个元素大 如果是零呢 相等 如果是复数呢

09:28.560 --> 09:33.280
第一个元素比第二个元素小 好 咱们先不去动这个函数 这个函数我们先不动

09:33.520 --> 09:38.880
我们先看一下怎么来用这个函数 假设已经写好了啊 假设我们已经写好了 怎么来用呢

09:40.480 --> 09:43.680
排序 数组扔进去啊 数组扔进去

09:44.640 --> 09:47.200
好 扔进去过后 第一个参数还不够啊 还不够

09:48.080 --> 09:50.800
还要传一个参数啊 还需要传一个参数

09:51.600 --> 09:57.600
第二个参数呢 传的是什么呢 传的就是如何来比较大小了啊 什么内形呢 是一个函数

09:58.400 --> 10:04.720
不要认为函数感觉就好像很特殊的样子 函数是一样的啊 函数是一样的 你直接传的就完事了

10:05.360 --> 10:09.200
第二个参数传一个函数进来 这个函数有两个参数 a和b

10:10.320 --> 10:14.320
啊 我会 到时候呢 我会告诉你这两个参数的值啊 我会告诉你

10:14.800 --> 10:18.880
你来帮我看一下 a和b 谁大谁小 因为我不知道你是什么数组

10:19.440 --> 10:24.400
但是你雕用的时候是不是一定清楚你是什么数组啊 你雕用的时候都不清楚谁清楚了

10:24.640 --> 10:28.400
对吧 你用这个函数的时候一定清楚这是一个什么数组

10:28.880 --> 10:31.440
好 你来帮我 你来告诉我啊 你来告诉我

10:32.400 --> 10:34.320
谁大谁小啊 谁大谁小

10:35.200 --> 10:38.400
怎么来告诉我呢 好如果a比b大

10:39.040 --> 10:44.240
那么你就返回正数 如果相等返回0 如果a比b小就返回复数

10:44.800 --> 10:48.320
啊 都是规定啊 我们自行约定这么一个规则

10:49.120 --> 10:50.880
好 那么这里呢 我们就按照这个规则来写

10:51.600 --> 10:58.400
好 a和b 是什么呢 是两个对象 对吧 两个对象 好 那么这里也要理清楚 你要到底要怎么排序 你想怎么排序

10:59.120 --> 11:06.080
你想打排序呢 啊 比方说我我希望的是啊 我希望的是按照年龄来排序 ok 我就可以这样写

11:08.000 --> 11:08.480
如果

11:09.440 --> 11:13.440
a级啊 就是ar.a级啊 如果年龄

11:14.640 --> 11:16.880
如果a的年龄啊 a的年龄

11:17.520 --> 11:19.760
大于了b的年龄 是不是a比b大

11:20.240 --> 11:22.880
a比b大是不是该返回复数了啊 返回复一

11:23.440 --> 11:28.000
对吧 lc 如果a的年龄啊 跟b的年龄相同

11:28.560 --> 11:31.440
那么返回啥 返回0 对吧 返回0

11:32.000 --> 11:35.520
好 else呢 就是a的年龄比b的年龄大 返回什么 返回1

11:36.160 --> 11:40.960
对吧 比较大小的事情我来帮你做 我来帮你做比较大小

11:41.520 --> 11:45.040
啊 剩下的怎么排序的去排序 因为排序的关键点就在于比较大小

11:45.440 --> 11:50.640
那我现在帮你来比较大小 你看这个意思吧 好 我们先说怎么用啊 怎么用这个函数

11:51.360 --> 11:56.720
好 这样的写法呢 有点太繁树了 对吧 你既然是按照年龄来比较大小 我看一下我能不能这样子写

11:57.920 --> 12:00.720
减去b的年龄可不可以啊

12:01.600 --> 12:09.440
能不能这样子写啊 我写反了 对吧 写反了啊 应该是b的年龄 减去a的年龄啊 b的年龄 减去a的年龄

12:10.560 --> 12:18.000
写反了啊 好 那么这样子写什么意思呢 嗯 如果你想啊 如果他的年龄比他大 是不是得到函数 对吧 满足条件嘛

12:18.320 --> 12:24.640
如果两个年龄相等 是不是得到0 啊 如果他的年龄比他的小 是不是得到复数 对吧 得到复数啊

12:25.680 --> 12:26.320
好

12:27.280 --> 12:32.240
哎 我们是不是 应该 应该这样 应该怎么说啊 应该是

12:33.360 --> 12:33.680
啊

12:34.880 --> 12:44.000
第一个元素 第一个元素比第二个元素大啊 然后我写反了 写反了 应该是a的年龄啊 减去b的年龄啊 写反了啊 写这里写反了

12:44.320 --> 12:52.320
第一个元素比第二个元素大是准数啊 这个是准数啊 这个是准数啊 下面也写反了啊 下面也写反了 这个是1这个是复一

12:53.280 --> 13:06.720
啊 总之呢 你按照要求把它做出来 你看这样的写是不是可以啊 a的年龄比b的年龄大 那么得到准数 减出来就是准数啊 两个相等 减出来就是0啊 第一个比第二小 减出来就是复数啊 所以说我们可以用更加简单的写法这样子写

13:07.520 --> 13:11.120
啊 你看我们用的时候就很轻松了 我们只需要告诉他怎么来比较大小

13:12.400 --> 13:18.320
好 这两个参数是谁给我的呢 是这个调用这个函数的时候 他来调 他来给我的这两个参数

13:18.960 --> 13:27.280
好 接下来我们看这边怎么写 这边 这边要比较这两个东西的大小 但是我不知道怎么比较 哎 但是有这个东西哦

13:27.840 --> 13:34.960
有他这个东西 他是不是可以比较 哎 他就可以比较了 好 那么我们这怎么比较了 我怎么比较了

13:35.440 --> 13:40.590
哈 就是compare啊 compare compare

13:41.390 --> 13:45.150
好 把两个数传 两个东西传进去 第一个东西

13:45.870 --> 13:52.830
第二个东西 对吧 我把这两个东西来传进去 调用这个函数 让你来帮我比较大小

13:53.630 --> 14:00.990
我给力 你来帮我比较大小 因为他一定会传一个函数进来 我这里调用函数 传了函数进来是不是能调用 对吧 能调用吧

14:01.710 --> 14:07.790
我就把调用这个函数 把两个参数传进去 好 你来帮我一下 我这里不知道该怎么比较大小了 你来帮我一下

14:08.110 --> 14:13.310
你来帮我比较这两个数的大小 好 你会返回一个结果 对吧 这个函数一个返回值

14:13.790 --> 14:19.470
它会返回一个结果 如果返回了结果大于0 说明什么意思

14:21.070 --> 14:24.510
如果这个函数的返回结果大于0 我们 我们之前规定了的

14:25.150 --> 14:28.990
大于0表示什么意思 表示是正数 就意味着第一个比第二个大

14:29.870 --> 14:35.390
第一个比第二个大 是不是要交换了 是不是要交换 对吧 是不是要交换了 交换就完事了

14:36.430 --> 14:40.510
就写完了 就写完了 看一下保存

14:41.470 --> 14:48.750
看一下 是不是按连细排序了 对吧 好 将来有一天我们要按体重排序

14:51.780 --> 14:59.300
按体重排序 你看 是不是就非常灵活了 我们不用去改动这个函数 这个函数已经写完了 我们可以反复的使用这个函数

15:00.180 --> 15:00.980
按体重排序

15:02.260 --> 15:03.700
看一下 按体重排序了

15:04.500 --> 15:11.460
按新名排序 新名的话是字不错比较大小 对吧 字不错本来就可以比较大小 所以说我们这里判断一下

15:11.860 --> 15:19.300
A点内A点内 这里不能相见了 不然的话 它会把字不错转变成为 转变成什么 转变成数字

15:20.020 --> 15:23.620
如果这里呢 返回什么 返回1 返回1

15:25.620 --> 15:30.820
l是一副呢 A点内 如果相等 如果相等 返回0

15:32.660 --> 15:37.780
返回0 else 返回负一 负一 保存看一下

15:38.420 --> 15:44.660
我们就可以根据各种情况来进行排序了 张三 李四 王五 排序了吗

15:46.100 --> 15:53.060
两个两个的信 我看一下 我用abc来看一下 bcd吧 BAD看一下

15:55.220 --> 16:02.180
bad abd ok 排序了啊 中文的他是用编码啊 中文的编码我不太清楚啊 中文的编码我不太清楚

16:03.220 --> 16:05.060
好 总之他肯定是按照编码来排序的

16:05.780 --> 16:15.460
好 这个排序了 对吧 好 那么我比方说啊 我们各种各样奇葩的需求 我们还想按照年龄加上体中来排序

16:16.740 --> 16:32.100
ad ag 加上ad weight 减去什么 B.ag 加上B.weight 是吧 我们可以用各种各样的方式来定义如何来比较大小 你只需要告诉他如何比较大小 他就能帮你排序

16:32.980 --> 16:41.380
啊 保存看一下啊 体重加连你加连你来排序 这是78 这是85 对吧 这是也是85

16:42.420 --> 16:45.060
啊 看没 各种排序长性都可以满足了

16:46.180 --> 16:52.820
好 为了让这个函数使用起来更加方便 我们可以这样子写 第二参数呢你可以不传 不传的话 我就按照

16:53.460 --> 16:59.460
大于等于符号来排序啊 就按照大于等于符号来排序 就是两个相减的结果来进行排序啊 你可以不传递

17:00.020 --> 17:06.660
好 所以说呢 我们这里可以把它写得再完善 完善一点啊 就这里先判断一下啊 如果compare

17:07.540 --> 17:10.660
没有值啊 你没给我传东西啊 没给我传东西

17:12.020 --> 17:18.900
只要你没给我传东西就是为undefend 对吧 为undefend 没有给我传这个参数好 我来给他复制一个默认值

17:19.540 --> 17:22.980
给他一个默认值 默认只能写个函数吧 写个函数

17:23.780 --> 17:32.420
给他个默认 默认函数 好 那么我就直接比较大小了啊 直接比较大小了啊 那么这里比较一下啊 a大于b 返回1

17:33.860 --> 17:37.540
lcf 我这里为什么不用a减 b呢 是因为他有可能是支不错啊

17:38.580 --> 17:46.340
支不错的话 以相减的话 就会把两个支不错变成数字啊 这是不是我希望 希望看到的啊 如果想等的话 得到0

17:46.900 --> 17:48.260
lc呢 得到复一

17:48.980 --> 17:49.620
得到复一

17:50.980 --> 17:55.140
我就给他一个默认值 如果你不传递 我就用默认的方式来进行排序 就是比较大小

17:56.340 --> 18:04.340
好 你看一下 这样子不通用了 如果你是一个对象啊 你是个对象 ok 你可以给我传这个喊传这个东西 传第二个参数作为喊

18:05.140 --> 18:08.500
作为参数啊 你可以可以给我传递 就像刚才那样子

18:09.940 --> 18:11.780
方个型 a b

18:12.500 --> 18:14.500
返回的是什么

18:15.860 --> 18:22.740
返回的是 a 点 a 击减 b 点 a击啊 如果是对象的话 你可以给我传递啊 可以给我传递

18:23.540 --> 18:27.140
如果你不是对象的话 就是一个普通的数组的话 ok 你可以不传递

18:32.340 --> 18:36.020
你可以不传递啊 比方说啊 my functions sort

18:37.220 --> 18:40.020
ar啊 保存看一下啊

18:40.660 --> 18:46.020
你看你可以不传递 不传递的话 我用默认的比较方式 你没有传第二个参数 那么第二个参数为 undefined

18:46.260 --> 18:48.580
我会给他复制一个默认的函数啊 默认值

18:49.220 --> 18:55.540
看没 我就很灵活的来处理这个东西了 而且变成通用了 好像有一天我想导序排序怎么办

18:56.180 --> 18:57.460
要导序排序怎么办

18:58.340 --> 19:05.860
好 要导序排序的话 是不是给一个函数就完事了 给一个函数 a和b 对吧 a和b

19:07.620 --> 19:15.940
给个函数 a和b 就是给个函数 我来帮你比较大小 之前的返回的是什么 a减 b 对吧 现在我们返回b减 a 是不是刚好相反的

19:16.500 --> 19:22.100
对不对 这刚好相反 b减 a就完事了啊 这导序排序啊 导序排序

19:22.900 --> 19:25.700
好 保存看一下啊 看一下你看是不是导序排序了

19:27.540 --> 19:32.660
好 这样子一来呢 我们整个这个函数啊 就变得非常非常灵活和通用了

19:33.300 --> 19:41.540
原来这意思吧 好吧 这可以干脆这样子吧 干脆啊 算了 算了 我就这样子写吧 直接写到这个 测试一下啊 测试一下

19:41.860 --> 19:54.260
把这带马注释掉了啊 算了 我本来我刚才想的是把这带马删掉啊 看得乱七八糟的 因为这里本来就是写着函数啊 这些都是测试带嘛 这算了 放在这吧 免得你们有的时候想看一下测试带嘛 可以看得到

19:55.140 --> 20:00.420
好吧 好 这是关于这个函数啊 好好去理解消化一下啊 好好去消化一下

20:01.860 --> 20:07.780
好 接下来下一个 你只要把第一个搞清楚了 那么后边的权一样啊 都一样类似

20:08.340 --> 20:14.660
至少是类似的 第三个 写一个函数 按照指定的条件 对某个数组进行筛选

20:15.220 --> 20:18.180
filter啊 filter 看一下啊

20:19.540 --> 20:23.490
这个函数 按照指定的条件

20:25.090 --> 20:35.810
呃 我前面我前面我前面的写法怎么这样子写啊 不好意思啊 前面的写法呢 应该是这样子写啊 其实刚才那种写法呢 我我自己写习惯了啊 写习惯了

20:36.290 --> 20:39.330
这种这种语法也可以啊 也可以 它是个语法堂

20:39.890 --> 20:45.730
它是一个语法堂 说到这里顺便说一下吧啊 它是一个语法堂啊 你可以这样子写也可以

20:46.450 --> 20:47.330
也可以这样子写

20:48.290 --> 20:54.450
一模一样的啊 效果是完全一样的 就这种写法呢就更加简洁啊 这是也是六里边的写法

20:55.090 --> 21:03.250
这个很简单啊 就是个语法堂 可以这样子写的啊 下面filter啊 filter 好 filter呢 这个函数呢

21:03.970 --> 21:13.250
啊 这个函数 呃 它是按照指定的条件对某个数组进行筛选 首先我们搞清楚什么意思啊 什么意思呢 就是说啊 如果我给他一个数组

21:14.050 --> 21:16.850
啊 比方说我要得到这个数组中所有的击数

21:17.570 --> 21:24.690
那么经过这个函数之后呢 他得到一个新的数组啊 新的数组不会改动原数组啊 得到一个新的数组就是315

21:26.370 --> 21:30.850
就这么个意思啊 就这个意思 当然他不一定是击数啊 有可能得到所有的数数

21:31.810 --> 21:33.090
说不好啊 说不好

21:34.050 --> 21:41.170
OK 好了 那么我们现在知道这个函数的功能了啊 知道这个函数的功能了 好 接下来呢 我们现在实现这个函数

21:41.650 --> 21:49.010
这个函数里边要传哪些东西呢 肯定有参数对吧 肯定是有参数的 那么要传哪些东西呢 是不是要传一个什么

21:49.890 --> 21:57.410
数组要给我吧 对吧 数组要给我 好 我来进行筛选啊 我来进行筛选啊 怎么来进行筛选呢

21:57.650 --> 21:57.970
啊

21:59.370 --> 22:01.730
筛选数组啊 筛选数组

22:02.650 --> 22:11.890
好 怎么来进行筛选呢 是不是要判断不不 要循环 把数组的每一项一个一个拿出来 对吧 把数组的每一项一个一个拿出来 看一下是否满足条件啊

22:12.770 --> 22:13.770
便利数组

22:15.010 --> 22:22.330
看每一项啊 每一项是否满足条件啊 看每一项是否满足条件

22:23.250 --> 22:29.770
好了 那怎么来判便利了 便利很简单 对吧 循环被i小于数组的长度啊 i加加

22:31.570 --> 22:31.770
好

22:32.730 --> 22:42.650
一项一项拿出来看 判断一下 看一下哪一项满是否满足条件 这一项是否满足条件啊 看一下这一项是否满足条件

22:44.010 --> 22:51.850
好了 那这一项到底满不满足条件了啊 如果满足条件干嘛 如果满足条件的话 我这里定一个新数组

22:53.210 --> 23:04.530
定一个新数组 如果你满足条件 我就把你这一项加到新数组里边去 我们之前学学习过了 对吧 数组里面有一个铺席啊 把这个数组这一项加进去

23:05.970 --> 23:14.050
满足条件 我就把它加到新数组里边去 好这个循环运行完了之后 这个新数组里边是不是保存了所有满足条件的 对吧 返回

23:14.650 --> 23:16.290
返回什么 返回这个新数组

23:17.130 --> 23:24.210
数组能不能返回 什么东西都可以返回 无所谓 甚至以后我们还会看到可以返回 还可以返回函数 都可以返回

23:25.610 --> 23:31.250
没问题吧 啊 这个格式没问题吧 现在这个格式理解啊 你这个格式都不理解 你不要谈后边的

23:32.330 --> 23:33.930
好 那么这里关键是

23:34.850 --> 23:39.690
我怎么知道它满足啥条件的 有些人说基数 凭什么是基数呢 不一定是基数啊

23:40.370 --> 23:48.330
有可能是数数呢 有可能是一个 这是个堆箱的数组 一个堆箱里边某个属性要满足某个条件的 情况是无数个情况

23:48.730 --> 23:56.130
它有无数种情况 所以说你这里不能做任何假设条件 这个数组是什么数组 不能做任何假设 这是个通用的函数

23:57.050 --> 24:04.170
那条件是啥 条件就变成了一个函数 啊 给他取个名字叫callback 啊 叫回掉函数

24:04.890 --> 24:15.170
啊 好 打个注释啊 打个注释 后边呢 我就直接说了啊 说就是呢 有现在的我们刚开始结束回掉函数呢 一开始不太适应啊 所以说我们这里呢

24:15.690 --> 24:17.770
多打注释啊 这个callback

24:19.130 --> 24:22.810
表示什么意思呢 表示的是一个回掉函数啊 回掉函数

24:24.050 --> 24:30.930
接收几个参数呢 我觉得这里呢 给他两个参数吧啊 尽量给他多一些东西啊 接收两个参数

24:31.730 --> 24:37.170
分别表示啊 分别表示啊 数组的某一项

24:39.250 --> 24:48.170
啊 和其下标啊 我把下标和这一项的数据都给你啊 都给你 你来帮我判断一下啊 返回什么 返回一个步

24:49.690 --> 24:55.170
如果满足条件啊 如果满足条件你帮我返回一个处 如果不满足条件你返回一个force

24:56.130 --> 24:59.010
啊 满足条件 返回

24:59.850 --> 25:02.690
去 否则 返回force

25:03.810 --> 25:10.530
所以说我们这里需要个函数 我这里没办法知道他到底满不满足条件 但是呢 我通过函数知道

25:11.410 --> 25:17.890
好 我调用这个函数 我会把这个什么传进去了啊 什么传进去了 把这调用这个函数 我会把这个

25:18.890 --> 25:20.130
当前这一项给你

25:21.010 --> 25:24.530
然后呢 把这个下标也给你 你来帮我判断一下

25:25.690 --> 25:32.970
到底满不满足条件 这个函数返回一个不 返回一个布尔 由于这个函数返回处就表示满足条件 好 夹到新数组里边去

25:33.650 --> 25:40.410
看来会把写成这种格式 回掉函数以后是非常非常常见的一种应用啊 一开始不太适应 慢慢 慢慢理解

25:41.490 --> 25:45.850
慢慢下去 下去了 慢慢消化 好 到时候用的时候怎么用呢 看着啊

25:46.810 --> 25:47.090
看着

25:48.770 --> 25:50.250
这里呢 有个数组啊 有个数组

25:51.850 --> 25:52.970
随便写吧 随便写

25:54.090 --> 25:58.890
好 比方说我得到的数组里边 所谓的基数啊 得到所谓的基数啊 得到一个新数组

25:59.490 --> 26:02.610
新数组里边啊 怎么办啊 我们用my func形式

26:03.330 --> 26:04.090
filter啊

26:05.010 --> 26:06.730
数组传进去 原来的数组传进去

26:07.770 --> 26:11.850
然后呢 接下来是这一个就是方形啊 有这个方形 callback

26:12.850 --> 26:18.930
好 这个函数呢 就是这里要写个函数啊 它要传两个东西进来 一个是数组的其中一项

26:19.450 --> 26:25.130
这是参数 这个参数的名字的 我是当然可以可以随便命名啊 但是我尽量的命名成为

26:25.850 --> 26:32.170
容易看得理解的item呢 我们通常表示其中一项啊 数组的某一项 然后呢一个下标index

26:33.850 --> 26:38.010
好 咱们来输出一下这个函数啊 这个函数呢 不用输出了啊 我们就判断这个

26:38.730 --> 26:45.450
数字是否是几数 对吧 它会把数字告诉我 你看 它会把每一项的数字告诉我传进来

26:46.170 --> 26:54.930
那么我来判断一下这个数字是否是几数 是否是几数 这个下标呢 我们用不到对吧 用不到 你传吧 你随便传啊 你随便传 反正我又不用的

26:55.250 --> 27:01.810
这个下标呢 我们暂时用不到啊 返回是怎么了 返回的是 它处要的余数是不是等于0啊 不等于0

27:02.850 --> 27:06.330
如果这个条件满足 说明是几数 是几数 返回处

27:07.330 --> 27:11.370
返回处 那么表示这一项满足条件 你把它加到几数组 给我返回

27:13.750 --> 27:17.790
log6而已 好 保存 看一下啊

27:19.510 --> 27:21.350
你看 是不是得到了几数的数组

27:22.190 --> 27:28.430
而且很灵活 真的是非常非常灵活 比方说我要得到下标为几数的项

27:29.510 --> 27:36.750
而不是几数项 而是下标为几数的项 下标这是0 这是1 这是2 这是3 我要得到1 3

27:37.350 --> 27:42.390
5 7 下标为几数的项 那怎么办呢 我就把第二个参数用进来

27:43.030 --> 27:46.030
因为第二个参数他他会给我 对吧 他会给我这要第二个参数

27:46.910 --> 27:52.110
第二个参数他会给我的 所以我直接拿进来就行了啊 拿进来就行了 好 那么我们这里呢

27:53.590 --> 27:56.750
得到了是吗 因这个是除以二的余数不等于0 得到了

27:57.510 --> 27:58.830
i等于几数的 哎

27:59.590 --> 28:02.710
i等于几数的这些数字 数字 保存

28:03.590 --> 28:10.510
得到了就是632 441 对吧 632 441 他就能适应各种情况

28:11.590 --> 28:15.030
比方说 我们要得到是否是数数 对吧 是否是数数

28:15.950 --> 28:21.310
好 那么我们这里方个形什么 我们只判断不需要下标了 只判断这个东西是不是数数

28:22.990 --> 28:27.750
返回啥 返回之前不是有写过数数在吗 对吧 买方个形式 is pre

28:28.470 --> 28:35.470
啊 把item给你 你来帮我判断 是不是数数 那么这样一来 他是数数的话 他就会返回去 表示满足条件

28:35.990 --> 28:37.990
保存看一下 得到了全是数数

28:38.670 --> 28:44.230
看没 甚至我们还可以伤心病狂的怎么样 直接把这个函数写到这

28:45.990 --> 28:48.670
啊 你不是要函数吗 这就是个函数啊 我把这个函数给你

28:50.230 --> 28:55.350
到时候你那边去调用这个函数 我直接把函数传给你 保存你看 仍然可以

28:56.230 --> 29:01.910
就这里可以玩出很多的花样了啊 就不是像我们以前代码就是很很实版

29:03.030 --> 29:06.070
他只能玩满足一种情况 那么现在有了毁掉函数过后

29:06.470 --> 29:13.670
我们不太清楚的一些操作就有些操作呢 我们在实现这个函数过程中 我不太清楚 因为我这里要考虑到各种情况

29:14.230 --> 29:19.990
这里有些情况是无限的啊 有无数种情况 我不太清楚该去该去进行什么样的操作 ok

29:20.310 --> 29:26.790
你给我传个函数进来 你来帮我操作 我这里我这里就是负责在适当的时候去调用这个函数

29:27.510 --> 29:34.630
啊 我这里只负责在适当的时候呢 去调用这个函数 比较在循环里边 是吧 多次调用这个函数来比较大小

29:34.790 --> 29:36.950
啊 不来比较适逢满足条件

29:37.830 --> 29:39.270
你看就又写好了这个filter

29:40.390 --> 29:42.790
好好去体会啊 这一块非常非常重要

29:43.990 --> 29:49.830
好 第四个 写一个函数 按照指定的条件 得到数主动 第一个满足条件的元素 该取名为范德

29:50.950 --> 29:56.790
啊 那么后边呢 我们都清楚了啊 前两个你清楚过后边的我们就清楚了 给我个数组

29:57.750 --> 29:59.670
给你给我一个毁掉函数

30:01.030 --> 30:07.030
我来做什么呢 你来帮我看一下适逢满足条件啊 跟上面是一样的 你来帮我看一下适逢满足条件

30:09.750 --> 30:13.430
第一个啊 这是什么 从指定的

30:14.230 --> 30:23.910
数主中查找第一个满足条件的元素啊 查找第一个满足条件的元素

30:24.550 --> 30:27.350
好 这是个数主没这么说的 对吧 这个呢 就是

30:28.550 --> 30:33.670
这个一个毁掉函数啊 毁掉函数 跟上面是一样的啊 跟上面是一样的 接受两个参数

30:34.790 --> 30:36.550
啊 接受两个参数一样的啊

30:37.670 --> 30:42.790
分别为数主的某一项和下标 然后呢 返回个布尔 如果满足条件返回处 不管条件返回force

30:43.110 --> 30:48.790
我之所以这样做 是因为我这个函数里边 我不清楚他那一项到底要满足什么样的条件 我不清楚

30:49.030 --> 30:50.790
ok 你来帮我判断他是不是满足条件

30:51.750 --> 30:53.910
好 那具体做法呢 就是循环

30:56.820 --> 31:02.420
循环 如果你这一块连4循环那一块都没搞定 还数组都没搞定 你就在学这一块 那肯定是云的

31:02.660 --> 31:04.660
你首先前面条件的搞定数组和循环

31:05.620 --> 31:07.540
好 那是哀佳佳

31:08.420 --> 31:11.220
好 循环数组的每一项 对吧 循环数组的每一项

31:11.620 --> 31:19.060
如果我发现你这一项满足条件 我调一个函数 他来帮我判断是不是满足条件 我把这一项给力 我把下标给力

31:19.780 --> 31:25.220
你来帮我判断是不是满足条件 如果满足条件是不是找到了 找到了直接把这一项返回

31:25.780 --> 31:32.260
找到就不要找了 因为我找到了是吗 找到第一个满足条件的元素 找到了过后就直接返回

31:34.020 --> 31:39.780
如果整个数组看完了过后 都没有找到满足条件的 我返回二级范的 我这里注射里面要跟他说明

31:40.580 --> 31:44.100
如果没有就返回安迪范的 如果没有找到

31:45.380 --> 31:52.020
就返回安迪范的 当然了 你既然返回安迪范的 你是不是可以不用写这句话

31:52.820 --> 31:57.380
你既然返回安迪范的 是不是连这句话都不用写 对吧 他默认就返回的是安迪范的

31:58.820 --> 32:03.940
好 这个函数就写完了 看一下吧 看一下 还是这个数组啊

32:04.660 --> 32:11.620
得到就是查到的元素 我要去查找 Fand

32:13.620 --> 32:18.580
埋放形式 Fand 数组扔进去 扔进去 好 找谁呢

32:19.540 --> 32:21.780
找谁呢 一把一个元素告诉我

32:22.740 --> 32:28.100
我帮你 我帮你来判断这个元素是不是满足条件 我找第一个能被十三整除的吧

32:29.060 --> 32:36.420
不知道有没有啊 不知道有没有啊 我找第一个能被十三整除的 就是 return item除以十三的余数 是不是等于0

32:37.620 --> 32:43.460
去找 找这个元素 你看 以后的查照问题 是不是我们就不用再重新写了啊 直接用这个函数就完事了

32:44.020 --> 32:48.900
输出 输出什么 各种查照条件我们都可以用 对吧 都可以用

32:50.100 --> 32:55.060
输出看 看一下是 没找到 对吧 没找到 OK 那我找一下第一个数数

32:55.620 --> 33:01.460
第一个数数埋放形式 is prime 把这个函数传给他 他来帮我判断 是不是满足条件 因为这个函数

33:01.780 --> 33:04.900
返回的本来就是布尔 对吧 返回的就是布尔 是不是数数

33:05.700 --> 33:09.380
好 把这个函数给他 保存看一下 第一个数数是二十三

33:10.100 --> 33:12.180
看没有 我们就可以利用这个函数来找

33:12.740 --> 33:15.860
来搞定查照问题 你看函数是不是很舒服

33:17.220 --> 33:20.420
虽然你写起来可能会恼火 但是你以后拥起来可舒服了

33:20.980 --> 33:25.940
我们就不用再去以后查照问题 我们就可以使用它了 他可以满足各种场景的查照

33:26.820 --> 33:30.420
因为查照问题的关键点在什么 关键点在于

33:30.900 --> 33:38.740
就是是否满足条件 是否满足条件不知道 他情况坦很多 OK 你用回调函数给我 其他的事情我帮你搞定

33:40.500 --> 33:46.340
好 下一个啊 写一个函数 按照指定的条件 找到数数 做满足条件的元素数量

33:47.300 --> 33:52.500
我希望大家能够 现在能够不听我讲就能够写出来了 我希望大家能够写出来了

33:53.940 --> 33:55.700
好 给他注释 给他复制过来啊

34:00.600 --> 34:05.160
好 数量 好 数量的话是一样的 对吧 这些参数都是一样的

34:05.640 --> 34:08.120
无非定一个变量呗 换个名字啊 called

34:09.320 --> 34:13.080
定一个变量呗 定一个变量就是累计嘛 number

34:13.800 --> 34:17.720
从零开始没找到一个满足条件的 number 加加

34:18.280 --> 34:25.800
加加 最后反而回这个number 对吧 这就是这就是求计数 计数 看一下一共有多少个

34:26.840 --> 34:29.400
好 保存 又写完了啊 就写完了

34:30.680 --> 34:34.950
好 看一下啊 这个例子 好 number

34:36.230 --> 34:40.230
然后my方形式fan的 数组扔进去 来看一下

34:41.110 --> 34:43.910
看一下那个 就是数数有多少个

34:45.510 --> 34:49.190
你看以前要做这种事 这种题很麻烦 对吧 现在很简单的

34:49.830 --> 34:55.270
数组给你 然后数数的函数 判断数数的函数给你 那你再帮我判断啊 有多少个

34:55.830 --> 35:04.390
输出 怎么23个了 怎么可能是23个了 不太可能啊 我看这里哪里写错了啊 哪里写错了

35:05.270 --> 35:11.270
呃 输出的是这个 啊 调整的是fan的啊 调整应该是court啊 court

35:12.230 --> 35:19.190
保存 看一下 三个 那三个数数 这搞定了 对吧 这种 我们既然出了这么多道题

35:19.750 --> 35:25.910
说明啥呢 说明这种做法以后非常非常常见 你得会写啊 你得会写 这是毁掉函数

35:26.550 --> 35:29.990
什么情况下用毁掉函数 就是当你写一个函数的时候

35:30.950 --> 35:34.150
你在完成这个函数功能的时候 有些东西你是未知的

35:35.030 --> 35:40.710
未知的是不是一定是参数 但是这个参数呢 他不是具体的数据 他是要做一件事 你到底要做什么事

35:40.870 --> 35:47.190
我不知道啊 你看 我要数有多少个的时候 我要判断他是否满足条件 判断满足条件是不是一件事

35:48.070 --> 35:54.470
这件事情我不知道 那参数不就是函数吗 函数就是做一件事 一个功能

35:55.270 --> 36:01.910
判断是否满足条件这个功能 我是缺失的 因此呢 你要告诉我一个函数 你来帮我判断

36:02.790 --> 36:06.470
啊 数组我是缺失的 所以说你要有个参数 你给我传递个数组

36:07.430 --> 36:11.750
参数就是未知条件 这里也是一样 我要从数组里面去找找东西

36:12.230 --> 36:17.830
那满不满足条件呢 这又是一件事 一个功能 这个功能我是缺失的 我不知道什么叫条件

36:18.310 --> 36:19.590
因此呢 你来帮我来做

36:20.230 --> 36:29.590
看没 好 三选 三选也设置到满足条件 ok 那么你来帮我看一下是否满足条件 我不知道 不知道怎么来判断

36:30.310 --> 36:32.550
排序 排序的关键点在于比较

36:33.190 --> 36:38.790
我不知道 怎么比较两个大小 他不一定是数字 所以说你来帮我比较 你把结果告诉我

36:39.190 --> 36:44.230
那么我通过这个函数的反回事来来进行判定 你看 全是这样的湿度 看不看

36:44.790 --> 36:46.550
这样子呢 我们就可以写出丰富的

36:47.510 --> 36:49.590
函数 并且这些函数都是通用的

36:50.230 --> 36:54.870
可以满足各种各样的场景 你想一想 如果没有回掉函数 很多函数我得把它写死

36:55.670 --> 36:58.190
比方说数字的排序 我得写一个

36:58.670 --> 37:01.990
直补刷的排序写一个 对象的排序 我没法写 写都没法写

37:02.510 --> 37:08.310
因为对象的比较大小 太情况太多了 你怎么知道对象比较里边 他比较哪个属性的大小

37:08.710 --> 37:10.430
他怎么去比较的 你根本就不知道

37:11.030 --> 37:17.790
导讯了我还得写一个 对吧 我就要写很多很多的函数 但是一旦有了回掉函数过后 我就可以写出一些通用的函数

37:18.510 --> 37:19.710
这就是回掉函数的好处

37:22.110 --> 37:27.430
回掉函数以后还有很多很多的应用场景 很多的应用场景不用去备 但是你要体会得到

37:27.750 --> 37:31.830
你只要能够下去把这些函数全部重新写一遍 全部重新写一遍 不要偷懒

37:32.750 --> 37:39.310
你重新写一遍过后你就能逐渐体会到原来回掉函数 它的作用是这个 因为它不知道这件事情

37:39.670 --> 37:42.230
所以说你要通过参数传给我 因为它

37:42.910 --> 37:46.750
因为参数是什么 参数就是位置条件吧 对吧 我不知道 所以说你要传给我

37:47.390 --> 37:53.230
由于我不知道的东西是一个功能 是功能不知道 所以说这个参数的类型是一个函数

37:53.230 --> 37:58.430
好好去理一下啊 好 这是这些课啊 讲一讲作业

