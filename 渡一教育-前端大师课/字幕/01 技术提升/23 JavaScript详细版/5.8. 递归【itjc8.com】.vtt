WEBVTT

00:00.000 --> 00:17.180
在函数的应用里边有一个非常酷炫的技巧

00:17.180 --> 00:18.860
就是帝规

00:18.860 --> 00:23.100
好 帝规这个东西对于初学者来说

00:23.100 --> 00:25.100
它可能不是那么好理解

00:25.100 --> 00:28.220
我希望通过这几课我尽量给你解释清楚

00:28.220 --> 00:30.460
但是我就算给你解释清楚了

00:30.460 --> 00:35.340
你可能在实际的开发中也不太会去想到使用帝规

00:35.340 --> 00:38.460
没关系 一开始你先有这么一个印象

00:38.460 --> 00:40.140
你先了解帝规是怎么回事

00:40.140 --> 00:42.700
它的代码格式大概是什么样子

00:42.700 --> 00:45.020
然后后边学习的深入

00:45.020 --> 00:48.220
随着你开发经验的增加

00:48.220 --> 00:51.500
你自然慢慢的就会熟悉这个帝规了

00:51.500 --> 00:53.340
需要一个过程

00:53.340 --> 00:56.700
这里我们首先来看一个例子

00:56.700 --> 00:59.100
看它到底一个怎么样的酷炫法

00:59.100 --> 01:04.770
我们来看一个飞波拉气树里

01:04.770 --> 01:07.730
这里我们写这么一个代码

01:07.730 --> 01:10.770
就是我们之前好像是做过这么一个作业

01:10.770 --> 01:16.130
求飞波拉气树列Dn贵的值

01:16.130 --> 01:18.610
给你一个N也帮它求值

01:18.610 --> 01:21.330
那么这个东西我们首先了解

01:21.330 --> 01:22.370
什么叫飞波拉气树列

01:22.370 --> 01:25.010
就是第一位是1 第二位是1

01:25.010 --> 01:33.330
1 2 3 5 8 13 21

01:33.330 --> 01:35.890
这样一个树列后面就不写了

01:35.890 --> 01:37.250
就是一个飞波拉气树列

01:37.330 --> 01:38.450
它有个什么样的特点

01:38.450 --> 01:39.810
你能看出来吗

01:39.810 --> 01:42.770
它前量位固定为1

01:42.770 --> 01:44.770
然后后边的位数

01:44.770 --> 01:47.090
它是前面两位的相加之和

01:47.090 --> 01:50.130
看50等于2加3之和

01:50.130 --> 01:52.210
8等于3加5之和

01:52.210 --> 01:54.690
13等于5加8之和

01:54.690 --> 01:56.930
它是有这么一个特点

01:56.930 --> 02:00.850
因此我们比方说写这么一个函数

02:00.850 --> 02:02.530
Fn这个函数

02:02.530 --> 02:03.730
它用来求什么呢

02:03.730 --> 02:06.770
它用来求飞波拉气树列的Dn位

02:07.090 --> 02:10.130
那比方说假设我们这个函数已经写好了

02:10.130 --> 02:11.490
那到时候我们怎么用呢

02:11.490 --> 02:12.450
我们就输出

02:12.450 --> 02:15.490
比方说我要求飞波拉气树列第7位的值

02:15.490 --> 02:16.530
是不是就这样写

02:16.530 --> 02:19.250
输出飞波拉气树列第7位的值

02:19.250 --> 02:20.930
这个函数名字尽量简化一点

02:20.930 --> 02:22.130
方便我们理解

02:22.130 --> 02:24.690
然后我们这里

02:24.690 --> 02:25.890
怎么来求呢

02:25.890 --> 02:27.490
我们现在不要讲太多

02:27.490 --> 02:30.450
我们就看以前数学里面的公式是什么样子

02:30.450 --> 02:32.370
如果按照数学里边的话

02:32.370 --> 02:34.370
有个函数Fn

02:34.370 --> 02:35.890
按照数学里边的话

02:35.890 --> 02:37.090
有个函数F1

02:37.090 --> 02:39.090
数学里边是不是也有函数

02:39.090 --> 02:39.890
F1呢

02:39.890 --> 02:41.410
是不是一定等于1

02:41.410 --> 02:41.810
对不对

02:41.810 --> 02:43.090
一定等于1

02:43.090 --> 02:44.690
还有F2

02:44.690 --> 02:47.650
第二位的值是不是也是一定等于1

02:47.650 --> 02:48.210
对吧

02:48.210 --> 02:50.130
前两位固定为1

02:50.130 --> 02:51.890
所以说这个函数根据这个公式

02:51.890 --> 02:53.490
我们就直接算出来了

02:53.490 --> 02:55.570
如果n等于1

02:55.570 --> 02:57.650
或者说n等于2

02:57.650 --> 02:59.090
这两种情况下

02:59.090 --> 03:00.770
我就直接返回1

03:00.770 --> 03:02.050
没问题吧

03:02.050 --> 03:04.090
如果你是第一位或者是第二位的话

03:04.250 --> 03:05.770
我得到的值就是1

03:05.770 --> 03:07.770
前两位固定为1

03:07.770 --> 03:11.370
然后其他位就是n大于2的时候

03:11.370 --> 03:12.810
n大于2的时候

03:12.810 --> 03:14.970
那么它的值是这样子的

03:14.970 --> 03:17.050
你看一下是不是这个道理

03:17.050 --> 03:20.090
F3应该等于啥

03:20.090 --> 03:22.010
所以应该等于F2

03:22.010 --> 03:23.690
第二位的数字

03:23.690 --> 03:26.090
加上第一位的数字

03:26.090 --> 03:30.090
再来F5是不是应该等于

03:30.090 --> 03:32.090
第四位的数字

03:32.090 --> 03:34.330
加上第三位的数字

03:34.330 --> 03:36.090
对吧没问题吧

03:36.090 --> 03:36.410
好

03:36.410 --> 03:38.010
那么我们可以推荣出

03:38.010 --> 03:40.170
Fn只要n大于2的话

03:40.170 --> 03:42.970
那么就应该等于Fn-1

03:42.970 --> 03:45.930
加上Fn-2

03:45.930 --> 03:46.810
是不是这样子

03:46.810 --> 03:47.210
对吧

03:47.210 --> 03:48.410
把这个表达式的结果

03:48.410 --> 03:51.210
把表达式的值作为参数传进去

03:51.210 --> 03:53.610
我们就直接可以这样写

03:53.610 --> 03:54.970
直接来就行了

03:54.970 --> 03:56.490
直接返回啥

03:56.490 --> 03:58.410
Fn的值等于Fn-1

03:58.410 --> 04:00.010
加上Fn-2

04:00.010 --> 04:01.210
完了

04:01.290 --> 04:02.090
就没了

04:02.090 --> 04:04.090
我们直接这样子写出来就完事了

04:04.090 --> 04:05.290
咱们来看一下

04:05.290 --> 04:06.090
是不是真的可以

04:06.090 --> 04:07.130
我们点击

04:07.130 --> 04:08.090
运行出来

04:10.090 --> 04:10.890
看一下

04:10.890 --> 04:12.250
是不是得到13

04:12.250 --> 04:13.770
第七位的值是不是13

04:13.770 --> 04:16.330
看一下123456713

04:16.330 --> 04:19.450
然后第八位的值

04:19.450 --> 04:20.650
是21

04:20.650 --> 04:22.170
你看一下是不是21

04:22.170 --> 04:23.210
就完了

04:23.210 --> 04:25.290
你看这个代码恐怖恐怖

04:25.290 --> 04:26.170
极其的恐怖

04:26.170 --> 04:27.530
极其的酷炫

04:27.530 --> 04:28.730
短短几行代码

04:28.730 --> 04:30.250
没有用任何循环

04:30.330 --> 04:31.850
没有用任何什么数组

04:31.850 --> 04:33.690
直接就求出来它的值

04:33.690 --> 04:34.810
这就是地规

04:34.810 --> 04:35.850
地规是什么呢

04:35.850 --> 04:37.770
就是在函数内部

04:37.770 --> 04:39.050
直接

04:39.050 --> 04:40.890
这类是直接调用

04:40.890 --> 04:43.530
直接或间接调用自身

04:43.530 --> 04:44.570
就是地规

04:44.570 --> 04:45.690
什么叫地规

04:45.690 --> 04:50.970
就是直接或函数内部

04:50.970 --> 04:56.650
函数直接或间接

04:56.650 --> 04:59.610
间接调用自身

04:59.690 --> 05:01.370
这就是地规

05:01.370 --> 05:02.650
那么这里就是直接调用

05:02.650 --> 05:03.770
对吧

05:03.770 --> 05:05.530
那么地规好像说

05:05.530 --> 05:06.970
怎么这么神奇的代码

05:06.970 --> 05:08.170
这么短的代码就能实现功能

05:08.170 --> 05:10.490
它是不是介绍给你做了什么

05:10.490 --> 05:11.850
特殊的处理

05:11.850 --> 05:13.290
没有任何的魔法

05:13.290 --> 05:14.810
没有任何的特殊处理

05:14.810 --> 05:16.330
一切都正常执行

05:16.330 --> 05:18.330
它就能得到正确结构

05:18.330 --> 05:20.170
那么为什么能得到正确结构呢

05:20.170 --> 05:21.850
这是很多初学地规的人

05:21.850 --> 05:23.050
一开始结束地规的人

05:23.050 --> 05:24.650
感觉很迷茫的地方

05:24.650 --> 05:26.010
很难理解这个什么样

05:26.010 --> 05:27.770
自身调用自身

05:28.090 --> 05:30.090
我要解释这个现象的话

05:30.090 --> 05:32.650
得说不少的东西

05:32.650 --> 05:34.650
那么我们来再来说

05:34.650 --> 05:36.490
如果你要理解这个现象的话

05:36.490 --> 05:37.930
你必须要去理解

05:37.930 --> 05:40.410
这么一个东西叫做

05:40.410 --> 05:43.530
执行站

05:43.530 --> 05:44.890
什么叫执行站呢

05:44.890 --> 05:46.890
我们后边间接部分

05:46.890 --> 05:49.210
还会讲到这个执行站

05:49.210 --> 05:53.290
我们这里先初步的认识一下

05:53.290 --> 05:57.770
无论任何代码的执行

05:57.770 --> 05:58.890
包括我们的权具代码

05:58.890 --> 05:59.850
什么叫权具代码

05:59.850 --> 06:01.770
现象这个直接输出是不是权具代码

06:01.770 --> 06:02.410
对吧

06:02.410 --> 06:04.170
任何代码的执行

06:04.170 --> 06:05.610
任何代码的执行

06:05.610 --> 06:09.050
都必须有一个执行环境

06:09.050 --> 06:11.210
这个环境里面提供了

06:11.210 --> 06:14.570
这个执行代码所需要的一些信息

06:14.570 --> 06:22.170
执行环境为代码的执行提供支持

06:22.250 --> 06:23.770
然后怎么来理解这个执行环境呢

06:23.770 --> 06:25.210
我们先初步理解一下

06:25.210 --> 06:27.690
因为我们目前还没有讲到执行上下文

06:27.690 --> 06:29.050
那是进阶部分的知识

06:29.050 --> 06:33.050
因此我们现阶段的理解执行环境呢

06:33.050 --> 06:34.410
我们就大概的理解一下

06:34.410 --> 06:35.290
就是一个环境

06:35.290 --> 06:37.050
你可以把它想象成一块内存

06:37.050 --> 06:38.890
一个环境就是一块内存

06:38.890 --> 06:40.250
这一块内存里面

06:40.250 --> 06:42.810
为执行代码提供一些支持

06:42.810 --> 06:43.850
我们后边会讲

06:43.850 --> 06:44.810
小细的讲

06:44.810 --> 06:48.490
执行环境呢

06:48.810 --> 06:53.130
是放到执行站中

06:54.410 --> 06:56.570
执行环境是放到一个执行站

06:56.570 --> 06:57.850
执行站是什么东西呢

06:57.850 --> 07:00.170
你可以又把它想象成一块大的内存

07:00.170 --> 07:01.450
这个大的内存里面

07:01.450 --> 07:03.050
放一个一个的执行环境

07:03.050 --> 07:04.330
明白这个意思吧

07:04.330 --> 07:06.570
我们一块来举例子会详细的说

07:06.570 --> 07:11.690
然后每个函数的调用

07:11.690 --> 07:16.890
都需要创建一个函数的执行环境

07:17.210 --> 07:20.250
函数调用结束

07:20.250 --> 07:23.770
执行环境销毁

07:23.770 --> 07:27.050
执行环境销毁

07:27.050 --> 07:28.650
是这么一回事

07:28.650 --> 07:32.730
接下来我们用一个例子来帮助你理解这个过程

07:32.730 --> 07:34.330
如果你一看文字的话

07:34.330 --> 07:36.410
肯定是很蒙的执行站

07:36.410 --> 07:40.740
看一下咱们先举一个例子

07:40.740 --> 07:44.180
一会我们再来解释这个地规是怎么运作的

07:44.180 --> 07:45.540
其实没有什么特殊的

07:45.540 --> 07:46.900
一切都正常运行

07:47.140 --> 07:49.940
比方说咱们这里有一个函数A

07:49.940 --> 07:50.980
函数A

07:50.980 --> 07:51.700
它干嘛呢

07:51.700 --> 07:52.820
它输出一个A

07:52.820 --> 07:54.100
输出一个A

07:54.100 --> 07:57.460
然后输出一个A

07:57.460 --> 08:00.020
然后执行一个函数B

08:00.020 --> 08:03.060
然后再输出一个A

08:03.060 --> 08:04.500
A over

08:04.500 --> 08:05.540
执行完了

08:05.540 --> 08:07.380
然后我们再来

08:07.380 --> 08:10.100
当然我们要做的不是看它的结果

08:10.100 --> 08:11.380
结果没它好看的

08:11.380 --> 08:13.220
主要是理解它的执行过程

08:13.220 --> 08:15.940
执行函数C

08:15.940 --> 08:18.660
然后这个B开始

08:18.660 --> 08:20.180
这个B结束

08:20.180 --> 08:22.580
然后有个函数C

08:22.580 --> 08:25.140
有个函数C

08:25.140 --> 08:29.380
然后这里C结束

08:29.380 --> 08:33.220
然后这里有一个直接输出

08:33.220 --> 08:37.060
Global全局开始

08:37.060 --> 08:39.620
然后雕用函数A

08:39.620 --> 08:42.820
然后全局结束

08:42.820 --> 08:43.940
Global over

08:44.100 --> 08:46.020
我们来看一下这段代码

08:46.020 --> 08:48.820
这段代码它到底是怎么执行的

08:48.820 --> 08:50.580
这里面有三个函数ABC

08:50.580 --> 08:52.980
以及有这里输出语句雕用A

08:52.980 --> 08:54.580
然后再输出语句

08:54.580 --> 08:54.980
好

08:54.980 --> 08:57.700
首先我们准备好一个执行站

08:57.700 --> 08:59.540
这个执行站就是一块内存空间

08:59.540 --> 09:01.380
你就把它想象成一块内存空间

09:01.380 --> 09:02.420
它叫做执行站

09:02.420 --> 09:04.260
我们后面还会详细的讲这个东西

09:04.260 --> 09:06.020
叫做Costac

09:06.020 --> 09:07.140
执行站用来干嘛呢

09:07.140 --> 09:09.380
它用来装执行环境的

09:09.380 --> 09:11.060
每一个执行环境就是一块内存

09:11.060 --> 09:12.660
这个内存里面提供了一些东西

09:12.740 --> 09:13.860
这东西到底是啥

09:13.860 --> 09:14.900
我们先别管

09:14.900 --> 09:16.020
提供了一些东西

09:16.020 --> 09:19.140
然后为执行提供支持

09:19.140 --> 09:22.500
没有执行环境是执行不了代码的

09:22.500 --> 09:25.540
执行代码的话必须要有执行环境

09:25.540 --> 09:25.860
好

09:25.860 --> 09:28.820
首先遇到了是一个全局环境

09:28.820 --> 09:30.340
什么叫全局环境

09:30.340 --> 09:31.780
就是没有放到函数里面的

09:31.780 --> 09:34.260
直接输写的代码就是全局环境

09:34.260 --> 09:35.060
我们之前说过

09:35.060 --> 09:36.020
怎么叫全局代码

09:36.020 --> 09:36.420
对吧

09:36.420 --> 09:37.700
或者叫全局变量

09:37.700 --> 09:38.980
那么它都是放到

09:38.980 --> 09:40.020
不是放到函数里面的

09:40.020 --> 09:41.140
直接输写的

09:41.220 --> 09:42.100
就是全局环境

09:43.220 --> 09:45.460
没有环境是无法执行代码的

09:45.460 --> 09:46.500
它必须要有环境

09:48.100 --> 09:50.820
那么首先创建了一个全局环境

09:50.820 --> 09:52.340
全局环境创建好了之后

09:52.340 --> 09:55.220
接下来在全局代码里面有哪些

09:55.220 --> 09:56.580
这些当然是一个变量A

09:56.580 --> 09:57.140
变量B

09:57.140 --> 09:57.620
变量C

09:57.620 --> 09:57.780
对吧

09:57.780 --> 09:59.300
他们指向的是一个函数

09:59.300 --> 10:00.260
我们之前说过

10:00.260 --> 10:02.180
函数它本质上也是个对象

10:02.180 --> 10:03.620
那么这里相当于一个变量A

10:03.620 --> 10:04.980
指向一个函数对象

10:04.980 --> 10:05.620
一个变量B

10:05.620 --> 10:06.660
指向一个函数对象

10:06.660 --> 10:07.300
一个变量C

10:07.300 --> 10:08.580
指向一个函数对象

10:08.580 --> 10:09.860
这个东西我们没啥好说的

10:09.860 --> 10:10.740
接下来我们看这

10:11.620 --> 10:12.180
看这

10:12.580 --> 10:14.180
console.log

10:14.820 --> 10:16.020
是不是在调用函数

10:16.020 --> 10:17.540
这个是不是别人写好的函数

10:17.540 --> 10:18.100
对吧

10:18.100 --> 10:19.700
别人写好的函数在调用

10:19.700 --> 10:20.340
对不对

10:20.340 --> 10:20.740
好

10:20.740 --> 10:23.620
每一次遇到调用函数

10:23.940 --> 10:26.900
马上创建一个新的执行环境

10:27.220 --> 10:28.100
调用函数

10:28.100 --> 10:29.140
一看到的调用函数

10:29.140 --> 10:30.580
马上创建一个新的执行环境

10:31.140 --> 10:33.860
于是创建一个新的执行环境

10:33.860 --> 10:34.420
叫啥

10:34.420 --> 10:36.420
叫做console.log

10:38.180 --> 10:39.700
创建那么一个新的执行环境

10:39.780 --> 10:40.660
console.log

10:41.780 --> 10:42.260
好

10:42.260 --> 10:44.500
然后去开始执行这个函数

10:44.500 --> 10:45.060
注意

10:45.060 --> 10:46.660
在执行站里边

10:46.660 --> 10:48.660
它始终执行的是啥

10:48.660 --> 10:51.380
它始终执行的都是站的最顶部

10:51.860 --> 10:53.620
这个站是一个数据结构

10:53.620 --> 10:55.140
它每次加入一个新的东西

10:55.140 --> 10:56.980
它永远是加到最顶部的

10:56.980 --> 10:58.020
移出的时候

10:58.020 --> 10:59.860
永远也是移出最顶部的

10:59.860 --> 11:00.900
就像一个杯子

11:00.900 --> 11:02.500
往里边放倒水

11:02.500 --> 11:03.060
倒了水

11:03.060 --> 11:04.020
倒了东西

11:04.020 --> 11:06.020
放的东西是不是在一定的最顶部

11:06.020 --> 11:06.900
你倒出来的时候

11:06.900 --> 11:08.340
一定是从最顶部开始

11:08.340 --> 11:09.140
一个个拿出来

11:09.860 --> 11:11.220
这就是一站的这么一种结构

11:12.180 --> 11:15.060
那么现在我们调用console.log这个函数

11:15.060 --> 11:16.980
它实际上是在站里边

11:16.980 --> 11:18.580
加入了一个执行环境

11:18.580 --> 11:20.180
就是console.log这个执行环境

11:20.820 --> 11:22.900
然后现在站里边是不是顶部

11:22.900 --> 11:23.700
已经是这个东西了

11:24.260 --> 11:26.900
于是现在开始去执行这个函数

11:27.380 --> 11:28.340
输出是一个什么

11:28.340 --> 11:29.780
输出一个globobigin

11:29.780 --> 11:31.220
输出一个globobigin

11:31.700 --> 11:33.780
于是它输出了globobigin

11:34.660 --> 11:34.820
好

11:34.820 --> 11:35.860
输出完之后

11:35.860 --> 11:37.220
这个函数是不是调用结束了

11:37.700 --> 11:38.980
调用结束之后

11:40.420 --> 11:41.460
执行站里边

11:41.460 --> 11:42.820
这个执行环境被销毁

11:44.020 --> 11:46.020
然后又推回到全聚环境

11:46.020 --> 11:46.980
你看是不是推回来了

11:47.860 --> 11:49.460
推回到全聚环境

11:49.460 --> 11:50.740
继续执行

11:51.700 --> 11:53.540
之前执行到哪现在又继续执行

11:54.020 --> 11:55.140
好之前在这对吧

11:55.140 --> 11:56.500
好然后呢又运行a

11:57.060 --> 11:58.660
是不是又在调用函数啊

11:59.220 --> 12:00.580
又在调用函数

12:00.900 --> 12:03.060
好是不是这个是又要建立全聚

12:03.060 --> 12:04.900
又要建立函数环境对吧

12:04.900 --> 12:05.700
a的环境

12:07.460 --> 12:08.340
函数a

12:09.540 --> 12:10.660
函数a的环境

12:11.700 --> 12:12.580
啊的环境

12:13.460 --> 12:15.460
好然后呢现在呢

12:15.460 --> 12:16.580
开始去执行a

12:16.580 --> 12:17.940
为什么开始执行a了

12:17.940 --> 12:20.340
因为现在站的顶部是环境

12:20.340 --> 12:21.700
是函数a的环境

12:21.700 --> 12:24.580
所以它永远执行的是站的最顶部

12:25.140 --> 12:27.380
好现在转而去执行函数a了

12:28.340 --> 12:31.380
啊然后函数a里边是不是输出abigin对吧

12:31.380 --> 12:33.220
那么这里是不是又要创建一个环境

12:33.220 --> 12:35.140
又要创建一个console logo环境

12:35.700 --> 12:36.420
console

12:37.940 --> 12:38.340
啊

12:38.820 --> 12:40.180
就很吃惊对吧

12:40.180 --> 12:40.820
那代码

12:40.820 --> 12:42.580
哇他这里边做了这么多事情啊

12:42.580 --> 12:43.860
代码执行速度太快了

12:43.860 --> 12:45.540
他实际上做了很多很多的事

12:45.940 --> 12:48.500
好又创建了一个环境console.log

12:48.500 --> 12:50.420
是不是又输出一个abigin对吧

12:50.420 --> 12:52.180
于是呢输出abigin

12:52.820 --> 12:54.980
好输出完之后这个环境是不是结束了

12:55.220 --> 12:56.660
console.log结束了

12:56.900 --> 12:59.380
又回到什么回到函数a的环境

12:59.380 --> 13:01.380
函数a的环境里面是不是到这句话了

13:01.860 --> 13:04.420
执行啥执行b啊执行b

13:04.900 --> 13:07.140
好于是又创建一个执行环境

13:07.380 --> 13:09.220
就是函数b的环境

13:10.100 --> 13:11.620
函数b的环境

13:11.940 --> 13:13.700
好现在转而去执行b了

13:13.700 --> 13:15.540
看没转而去执行b

13:15.780 --> 13:18.580
好执行b的时候第一句话说输出b

13:18.580 --> 13:19.220
b begin

13:19.220 --> 13:20.500
是不是又要创建一个环境对吧

13:20.500 --> 13:22.820
console.log又在上面输出一个b begin

13:22.820 --> 13:23.860
然后又把销毁掉

13:23.860 --> 13:25.060
啊这个我就不写了啊

13:25.060 --> 13:26.980
直接输出b begin

13:28.100 --> 13:29.940
好然后呢接下来又调用c

13:29.940 --> 13:31.380
是不是又要创建一个环境

13:31.620 --> 13:34.260
只要遇到了函数调用马上要创建环境

13:34.420 --> 13:36.180
刚才的console.log我没写了啊

13:36.180 --> 13:36.900
这个很简单

13:36.900 --> 13:38.420
我们直接想想就行了

13:39.060 --> 13:40.340
函数c的环境

13:40.900 --> 13:42.500
你看这就形成了一个执行站

13:42.820 --> 13:44.500
函数c又去执行它

13:44.500 --> 13:46.500
又输出啥c begin对吧

13:46.500 --> 13:47.620
c begin

13:48.580 --> 13:49.620
又输出它

13:49.780 --> 13:51.540
然后又输出什么c over

13:51.780 --> 13:54.820
啊c over对吧

13:54.980 --> 13:56.500
好c是不是执行完了

13:56.660 --> 13:58.580
这两句话一输出是不是c执行完了

13:58.740 --> 14:01.380
好c执行完了过后c的环境被销毁

14:01.780 --> 14:03.220
又回到b的环境

14:03.220 --> 14:04.900
看没它是一层一层进入

14:04.900 --> 14:06.020
一层的退回来的

14:06.180 --> 14:07.780
又回到b的环境

14:08.020 --> 14:09.620
回到b的环境刚才在运行这个对吧

14:09.620 --> 14:10.500
这个运行完了

14:10.500 --> 14:13.060
好接下来运行这个输出什么b over

14:13.540 --> 14:14.900
输出b over

14:15.540 --> 14:17.060
好所以b又运行完了

14:17.300 --> 14:18.820
好b这个函数运行完了

14:18.820 --> 14:20.260
那么它的环境消失

14:20.340 --> 14:21.140
环境没了

14:21.140 --> 14:22.900
又退回到a的环境

14:23.060 --> 14:24.420
好a的环境里边

14:25.300 --> 14:27.060
看这啊a的环境里边这里

14:27.140 --> 14:28.980
是不是结束了啊调用结束了

14:28.980 --> 14:30.980
又输出什么a over

14:30.980 --> 14:32.420
啊a over

14:32.980 --> 14:34.820
好然后a是不是也调用结束了

14:34.980 --> 14:36.420
好a的环境又消灰

14:36.420 --> 14:38.660
又退回到全局环境

14:38.660 --> 14:40.260
啊又退回到全局环境

14:40.500 --> 14:43.540
好全局环境里边是不是这句话就运行结束了

14:43.540 --> 14:45.940
最后全局环境里边输出global over

14:46.100 --> 14:47.860
啊global over

14:48.580 --> 14:49.620
输出这么一个东西

14:49.620 --> 14:51.940
好最后呢全局环境是不是也结束了

14:51.940 --> 14:53.460
好整个程序结束

14:54.100 --> 14:56.740
执行站里边已经没有任何环境可以执行了

14:56.740 --> 14:58.500
啊已经没有任何东西可以执行了

14:58.500 --> 15:00.420
因此呢它这个执行站就结束了

15:00.740 --> 15:01.620
明白这个意思吧

15:01.620 --> 15:03.620
这就是一个程序它执行的过程

15:04.340 --> 15:06.340
每次调用一个函数

15:06.340 --> 15:09.060
它都会创建一个执行环境

15:10.340 --> 15:11.700
好那么我们最后看一下吧

15:11.700 --> 15:12.820
既然都写了看一下吧

15:12.820 --> 15:14.340
那这个东西没啥好看的啊

15:14.340 --> 15:15.620
这个输出的结构呢

15:15.620 --> 15:17.060
大家应该都知道输出什么

15:17.060 --> 15:18.420
啊这个东西没啥好看的

15:18.420 --> 15:19.460
就这么一个结果啊

15:21.060 --> 15:23.300
啊这是关于它的执行环境啊

15:23.300 --> 15:24.820
以及它的函数调用过程

15:24.820 --> 15:26.260
然后呢我们再回到这的

15:26.740 --> 15:27.780
非波拉系苏联

15:28.580 --> 15:30.660
再看一下这个东西是什么样来执行的啊

15:30.820 --> 15:32.740
我这里呢写一个写一个五

15:32.740 --> 15:35.220
啊写一个五来帮大家理解啊

15:35.220 --> 15:37.060
当然第五呢就是输出的是

15:37.060 --> 15:38.020
输出的是五对吧

15:38.020 --> 15:39.860
输出的是五第五位嘛就是五

15:39.860 --> 15:41.940
11235嘛第五位就是五

15:41.940 --> 15:42.980
因此呢我们这里呢

15:43.940 --> 15:45.940
看一下这个地规它是怎么运行的啊

15:45.940 --> 15:47.060
运行的过程是什么样子

15:47.540 --> 15:49.460
好我们还是用这个地方来画图啊

15:49.460 --> 15:50.340
还是用它的画图

15:51.060 --> 15:52.180
首先呢我们调

15:52.180 --> 15:53.540
我们是一个全军环境对吧

15:54.980 --> 15:55.620
全军环境

15:56.980 --> 15:57.780
好然后呢

15:58.660 --> 16:00.260
全军环境里边输出一个啥啊

16:00.740 --> 16:02.740
输出一个F5对不对

16:02.740 --> 16:03.940
是不是要调用函数F5

16:04.580 --> 16:05.940
这里是不是要调用函数F5

16:06.180 --> 16:09.540
好那就先要把F5算出来才能输出嘛

16:09.540 --> 16:11.220
好F5这里呢我们

16:12.180 --> 16:12.740
这样子来画

16:13.860 --> 16:15.060
这个时候执行的环境是啥

16:15.700 --> 16:16.980
我这里要把它画小一点啊

16:17.780 --> 16:18.660
不然以后画不下

16:21.620 --> 16:22.180
小一点啊

16:22.740 --> 16:24.420
这里是一个函数F对吧

16:24.820 --> 16:26.980
参数呢多少参数是五

16:27.620 --> 16:29.540
参数是五是这么一个环境啊

16:30.100 --> 16:30.500
函数

16:30.980 --> 16:32.820
哪个函数F这个函数

16:33.380 --> 16:34.420
函数环境是F

16:34.820 --> 16:35.700
然后呢参数是五

16:36.180 --> 16:36.980
好创建这么一个环境

16:36.980 --> 16:38.500
于是呢开始执行这个函数对吧

16:38.740 --> 16:39.460
开始执行了

16:39.860 --> 16:42.580
好执行判断N是不是等于1呢

16:42.580 --> 16:44.180
不等于N是不是等于2呢

16:44.180 --> 16:44.820
不等于

16:45.140 --> 16:45.940
是不是运行到这

16:47.380 --> 16:48.100
是不是运行到这

16:48.580 --> 16:50.260
好运行到这这里要返回一个啥

16:50.500 --> 16:52.020
返回一个表达式的结果

16:52.020 --> 16:53.540
那是不是要把那个表达式算出来

16:53.940 --> 16:54.580
肯定要算嘛

16:54.580 --> 16:56.420
算出来结果才能返回嘛对不对

16:56.740 --> 16:57.940
好我们这里先记录一下啊

16:58.420 --> 16:59.220
记录一下这里

16:59.620 --> 17:01.940
要算什么就是N等于5的时候

17:01.940 --> 17:02.820
它要算什么呢

17:02.820 --> 17:04.100
它要算的是F

17:04.820 --> 17:06.740
FN-1就是等于4嘛

17:06.980 --> 17:07.700
加上啥

17:07.700 --> 17:09.700
FN-2就等于3嘛对不对

17:10.020 --> 17:11.060
它要返回的是啥

17:11.060 --> 17:12.660
返回的是F

17:14.660 --> 17:15.220
这样子说吧

17:15.940 --> 17:17.380
我们N等于5的时候

17:17.860 --> 17:19.220
它要返回的是什么呢

17:19.220 --> 17:22.820
返回的是F4加上F3对不对

17:22.820 --> 17:23.860
它要返回这个东西

17:24.180 --> 17:25.220
返回这个表达式的词

17:25.700 --> 17:27.140
好那么这个是不是函数调用

17:27.540 --> 17:29.300
它是不是要把表达式算出来对不对

17:29.300 --> 17:30.660
是不是要开始算F4

17:30.980 --> 17:32.500
好又遇到一些函数调用

17:32.500 --> 17:34.180
只要看到函数调用

17:34.180 --> 17:35.700
只要你看到函数调用

17:35.700 --> 17:36.900
马上要反应过来

17:37.380 --> 17:38.980
它有一个执行环境产生的

17:39.380 --> 17:40.740
那哪怕是调用自己

17:41.300 --> 17:42.500
你调用自己是不是

17:42.820 --> 17:45.060
它能不能重复使用这个环境肯定不行

17:45.060 --> 17:45.940
肯定不行

17:45.940 --> 17:47.140
只要你调用函数

17:47.140 --> 17:48.660
马上要产生一个新的环境

17:48.660 --> 17:50.180
哪怕是自己无所谓

17:50.180 --> 17:50.900
哪都一样

17:51.380 --> 17:52.980
好又产生一块内存空间

17:52.980 --> 17:54.500
那内存空间是不一样的啊

17:54.500 --> 17:56.020
参数是多少参数是4

17:56.740 --> 17:57.620
它算这个

17:57.620 --> 17:57.940
对不对

17:57.940 --> 17:58.660
它算这个

17:58.660 --> 18:00.580
于是到现在去转而执行啥

18:00.580 --> 18:01.940
转而执行F4了

18:01.940 --> 18:03.860
也就是现在这个F5执行结束没有

18:04.420 --> 18:05.620
F5执行结束没有

18:05.620 --> 18:07.700
你看这个环境都还在这都没消毁对吧

18:07.700 --> 18:09.300
执行结束它一定消毁了

18:09.300 --> 18:10.340
肯定没有结束

18:10.340 --> 18:12.420
因为它要算F5它必须要算F4

18:12.900 --> 18:14.260
它必须要算这个东西

18:14.260 --> 18:15.620
F4又是一次函数调用

18:15.620 --> 18:17.140
于是它创建的一个环境

18:17.140 --> 18:17.860
参数为4

18:18.900 --> 18:20.260
那么又来重新执行一个代码

18:20.260 --> 18:21.460
对吧重新执行一个代码

18:23.060 --> 18:24.580
因为一个新的环境产生了

18:24.740 --> 18:26.180
它重新执行这个函数代码

18:26.180 --> 18:27.460
现在N等于4了

18:27.460 --> 18:29.060
F5刚才那个要停在这

18:30.340 --> 18:30.900
再说一次

18:30.900 --> 18:32.260
虽然是同一个函数

18:32.260 --> 18:34.900
但是每一次执行它的环境是不一样的

18:34.900 --> 18:35.620
它的N

18:35.620 --> 18:37.780
那么参数的N的值也不一样对吧

18:37.780 --> 18:39.300
它整个环境是不一样的

18:40.180 --> 18:41.540
那么虽然是同一个代码

18:42.820 --> 18:45.220
然后这里执行F4的时候

18:45.220 --> 18:47.700
4等于1不等于2不等于

18:47.700 --> 18:48.100
对吧

18:48.100 --> 18:48.660
不等于

18:49.540 --> 18:51.460
不等于的时候又是不是又执行到这

18:51.460 --> 18:51.860
对不对

18:51.860 --> 18:52.500
F4呢

18:52.500 --> 18:54.020
还有执行到这等于啥呢

18:54.180 --> 18:55.540
等于F3

18:56.820 --> 18:58.900
F3加上F2

18:58.900 --> 18:59.460
对不对

19:00.020 --> 19:02.020
好是不是现在要计算这个表达4的值

19:02.020 --> 19:03.220
才能把F4算出来

19:03.220 --> 19:05.060
把F4算出来过后呢

19:05.060 --> 19:06.580
F4这个函数才能结束

19:06.580 --> 19:09.060
结束之后呢才能推回到F5

19:09.060 --> 19:10.740
才能推回到F5

19:10.740 --> 19:12.260
F5刚才执行到这对吧

19:12.260 --> 19:13.140
那个环境

19:13.140 --> 19:16.260
在F5这个环境中参数的值为5

19:16.260 --> 19:18.500
在F4这个环境中参数的值为4

19:18.500 --> 19:20.500
才能推回到F5去执行

19:20.500 --> 19:21.300
把这个算出来

19:21.300 --> 19:22.020
明白这个意思吧

19:22.820 --> 19:24.340
所以说这里呢

19:25.460 --> 19:26.740
要算F3的值

19:26.740 --> 19:26.980
对吧

19:26.980 --> 19:28.180
要算F3的值

19:28.180 --> 19:29.780
于是是不是又要调用环境

19:29.780 --> 19:30.100
对吧

19:30.100 --> 19:32.180
又要产生一个新的执行环境

19:32.180 --> 19:33.060
于是呢

19:33.060 --> 19:33.940
又产生一个

19:33.940 --> 19:34.660
看到没

19:34.660 --> 19:35.780
这就是低规的方式

19:36.660 --> 19:37.380
产数为3

19:38.020 --> 19:38.660
产数为3

19:39.700 --> 19:39.940
好

19:40.500 --> 19:41.540
然后呢这里

19:41.540 --> 19:42.820
是不是要算F3

19:42.820 --> 19:43.220
对不对

19:43.940 --> 19:44.900
又要算F3

19:45.620 --> 19:46.980
F3的话你看一下

19:47.940 --> 19:49.780
n变成3了

19:49.780 --> 19:50.660
n等于1不等于

19:50.660 --> 19:51.460
n等于2不等于

19:51.540 --> 19:52.420
是不是又来

19:52.420 --> 19:52.820
对不对

19:52.820 --> 19:53.300
又来

19:54.020 --> 19:55.940
我这里好像写的数字有点大

19:55.940 --> 19:56.980
解释性也比较慢

19:56.980 --> 19:57.380
没关系

19:57.380 --> 19:58.020
我们慢慢说

19:58.820 --> 20:01.300
等于F2加上F1

20:01.300 --> 20:01.620
对不对

20:02.260 --> 20:02.420
好

20:02.420 --> 20:03.700
是不是又遇到环境调用了

20:03.700 --> 20:04.580
又要去算啥

20:04.580 --> 20:04.980
F2

20:06.260 --> 20:07.380
又要去算F2

20:08.420 --> 20:09.140
产数为2

20:09.860 --> 20:10.260
算这个

20:10.820 --> 20:10.980
好

20:10.980 --> 20:12.020
算这个的时候呢

20:12.020 --> 20:12.980
它是不是F2

20:12.980 --> 20:14.260
就是直接可以算出来

20:14.260 --> 20:14.500
对吧

20:14.500 --> 20:14.900
n嘛

20:14.900 --> 20:15.540
n等于2嘛

20:16.100 --> 20:16.580
2呢

20:17.380 --> 20:18.260
满着这个条件

20:18.260 --> 20:19.220
所以说返回1

20:19.220 --> 20:19.620
是吧

20:19.620 --> 20:21.060
把F2算出来了

20:21.060 --> 20:21.380
对不对

20:21.860 --> 20:23.220
它把F2算出来了

20:24.180 --> 20:26.100
F2是不是调用结束了

20:26.100 --> 20:27.140
已经算出来一个值了

20:27.140 --> 20:27.540
对吧

20:27.540 --> 20:28.420
算出来一个值

20:28.420 --> 20:29.380
表达是已经算出来了

20:29.380 --> 20:30.900
F2调用结束

20:30.900 --> 20:32.260
又回到F3这里

20:33.060 --> 20:33.940
回到F3这里

20:33.940 --> 20:35.220
刚才在运行它嘛

20:35.220 --> 20:35.940
运行了F2

20:35.940 --> 20:36.660
是不是算出来了

20:36.660 --> 20:37.140
等于多少

20:37.140 --> 20:37.620
等于1

20:38.260 --> 20:38.420
好

20:38.420 --> 20:39.140
现在接下来

20:39.140 --> 20:40.340
这个表达是还没完

20:40.340 --> 20:41.620
又加上什么F1

20:42.100 --> 20:43.460
又加上F1的时候

20:43.460 --> 20:44.660
是不是又要产生执行环境

20:45.380 --> 20:46.340
又产生执行环境

20:46.820 --> 20:47.620
产数为1

20:48.180 --> 20:48.500
看没

20:49.140 --> 20:49.860
产数为1

20:50.340 --> 20:51.460
那么1是不是满足条件

20:51.460 --> 20:51.940
返回1

20:52.420 --> 20:52.820
然后呢

20:53.300 --> 20:54.580
1是不是运行完了

20:55.220 --> 20:56.340
产数为1的这个环境

20:56.340 --> 20:56.900
运行完了

20:56.900 --> 20:58.340
还说环境销毁

20:58.340 --> 20:59.460
然后又回到什么

20:59.460 --> 21:00.340
又回到F3

21:00.820 --> 21:01.220
然后呢

21:01.220 --> 21:02.100
把这个算出来

21:02.100 --> 21:02.660
多少

21:02.660 --> 21:03.220
是不是1

21:03.860 --> 21:04.020
好

21:04.020 --> 21:04.980
这个表达是出来了

21:05.460 --> 21:06.020
1加1

21:06.020 --> 21:06.580
等于多少

21:06.580 --> 21:07.220
等于2

21:07.220 --> 21:07.860
对不对

21:07.860 --> 21:08.820
F3是不是算出来了

21:09.380 --> 21:10.420
F3算出来的过后

21:10.420 --> 21:10.580
这个

21:11.540 --> 21:12.500
执行是不是结束了

21:13.220 --> 21:14.260
它返回了嘛

21:14.260 --> 21:15.380
F3它就返回

21:15.380 --> 21:15.780
什么

21:15.780 --> 21:16.820
返回1加1

21:16.820 --> 21:17.220
等于2

21:17.700 --> 21:18.900
所以说F3运行结束

21:19.380 --> 21:20.740
运行结束之后

21:20.740 --> 21:22.180
那么这个环境是不是销毁了

21:22.740 --> 21:23.140
对吧

21:23.140 --> 21:24.020
环境销毁了

21:25.700 --> 21:26.260
环境销毁了

21:26.260 --> 21:27.380
又推回到F4

21:27.940 --> 21:29.620
F4这里F3是不是算出来了

21:29.620 --> 21:30.260
这不等于2

21:31.380 --> 21:32.660
好继续算F4

21:32.660 --> 21:33.780
F4还没有运行完

21:33.780 --> 21:34.340
继续运行

21:34.820 --> 21:36.580
F4这一块2加上F2

21:36.580 --> 21:37.860
是不是又要产生一个执行环境

21:38.180 --> 21:38.660
对吧

21:38.660 --> 21:39.860
又要产生一个执行环境

21:40.420 --> 21:41.220
承述了为多少

21:41.220 --> 21:41.620
为2

21:42.100 --> 21:42.980
刚才看到了

21:42.980 --> 21:43.620
n等于1

21:43.620 --> 21:44.420
或者n等于2

21:44.420 --> 21:45.540
是直接算出来的结果

21:45.540 --> 21:45.940
对吧

21:45.940 --> 21:46.500
就是1

21:46.900 --> 21:47.700
于是这个环境

21:47.700 --> 21:48.580
马上运行结束了

21:48.980 --> 21:50.100
它得到结果为1

21:50.100 --> 21:51.540
好又推回到F4

21:51.540 --> 21:53.060
F4这里是不是算出来了

21:53.060 --> 21:54.100
算出结果为1

21:54.740 --> 21:55.140
对吧

21:55.140 --> 21:56.660
那么2加1等于多少

21:56.660 --> 21:57.060
3

21:57.060 --> 21:58.980
那么这样子F4也算出来了

21:58.980 --> 22:00.420
那么F4运行结束

22:01.540 --> 22:02.580
又回到F5

22:02.580 --> 22:04.340
F5 F4这里是不是3

22:04.340 --> 22:05.140
对不对

22:05.140 --> 22:05.620
就是3

22:06.260 --> 22:06.820
没有这意思

22:07.300 --> 22:07.540
好

22:07.540 --> 22:08.820
接下来再算F3

22:09.380 --> 22:10.100
是不是一样的

22:11.300 --> 22:13.140
又要产生一个执行环境了

22:13.140 --> 22:14.420
等于F2

22:14.980 --> 22:17.460
F2加上F1

22:18.420 --> 22:19.220
加上F1

22:19.220 --> 22:19.940
那么这个东西

22:19.940 --> 22:21.380
大家下来自于去离了

22:21.380 --> 22:22.900
那肯定要产生一个执行环境

22:22.900 --> 22:23.220
算了

22:23.220 --> 22:24.260
我就说到这来了

22:24.260 --> 22:24.740
把他写完

22:26.340 --> 22:26.580
好

22:26.580 --> 22:29.220
这里我们得到参数为多少了

22:29.220 --> 22:29.780
为3

22:29.780 --> 22:30.180
对不对

22:30.180 --> 22:30.580
为3

22:30.580 --> 22:31.060
好

22:31.060 --> 22:32.340
他又要去调用F2

22:32.340 --> 22:33.380
又产生一个环境

22:33.940 --> 22:34.660
参数为2

22:35.060 --> 22:35.940
好参数为2

22:35.940 --> 22:36.980
然后这个是不是算出来了

22:36.980 --> 22:37.540
等于多少

22:37.540 --> 22:38.020
等于1

22:38.580 --> 22:39.220
也就是说回

22:39.620 --> 22:40.740
他这个函数执行完了

22:40.740 --> 22:41.620
消费环境

22:41.620 --> 22:42.820
又回到F3这里

22:42.820 --> 22:43.940
把它算出来1

22:43.940 --> 22:44.580
那么同地

22:44.580 --> 22:45.780
把它算出来1

22:45.780 --> 22:46.900
F3是不是算出来了

22:47.060 --> 22:47.620
等于2

22:48.100 --> 22:48.580
等于2

22:48.580 --> 22:49.540
那么F3结束

22:50.100 --> 22:51.300
然后这边就等于2了

22:52.100 --> 22:53.940
最后F5得到的结果就是

22:53.940 --> 22:55.300
3加2等于5

22:55.940 --> 22:56.740
退回来

22:57.860 --> 22:58.900
到了全局环境了

22:58.900 --> 22:59.940
全局环境就输出啥

22:59.940 --> 23:00.580
输出5

23:00.580 --> 23:01.700
最后全局环境结束

23:03.220 --> 23:04.660
整个过程在内存里边

23:04.660 --> 23:05.780
它就是这样来运作的

23:06.340 --> 23:08.020
因此它能够正常执行

23:08.020 --> 23:09.620
并且没有任何什么特殊的

23:10.020 --> 23:10.740
就是调用

23:10.740 --> 23:11.700
调用就产生一个环境

23:12.100 --> 23:13.620
大家可能疑惑在哪呢

23:13.620 --> 23:15.140
大家可能会老是在想

23:15.620 --> 23:17.380
什么变量冲突这些东西

23:17.380 --> 23:18.580
你不要想这些东西

23:18.580 --> 23:20.740
函数这些参数啊这些东西

23:20.740 --> 23:22.340
函数内部的变量啊参数

23:22.340 --> 23:24.260
它只有在运行的时候才有效

23:24.260 --> 23:25.860
你没有运行它是没无效的

23:26.180 --> 23:28.500
而你每一次运行都是一个新的环境

23:29.060 --> 23:30.180
哪怕是同一个函数

23:30.180 --> 23:31.860
你每一次运行都是一个新的环境

23:32.180 --> 23:33.060
明白这个意思吧

23:33.060 --> 23:34.340
新的环境运行完了过后

23:34.340 --> 23:35.220
再退回来

23:35.220 --> 23:36.580
继续执行之前的环境

23:37.140 --> 23:38.020
它是这么回事

23:38.500 --> 23:39.860
所以说大家可能晕的是这一点

23:40.340 --> 23:42.340
所以说我告诉你们这一点之后呢

23:42.820 --> 23:44.180
通过这么详细的讲解

23:44.260 --> 23:45.780
告诉你们这个特点之后

23:46.260 --> 23:48.740
那么你就不会产生

23:48.740 --> 23:52.420
至少在这个程序程序层面

23:52.420 --> 23:53.700
你不会产生疑惑了

23:53.700 --> 23:55.060
它能够正常执行

23:55.060 --> 23:56.100
可以调用自身

23:56.100 --> 23:57.460
并且能够正常执行

23:59.220 --> 24:01.140
那么我们也就是说什么呢

24:01.140 --> 24:02.820
也就是说我们以后啊

24:04.020 --> 24:05.380
在遇到这种问题的时候

24:05.380 --> 24:07.860
当我们能够分析出这种结构的时候呢

24:08.180 --> 24:09.700
我们直接输血流向了

24:09.700 --> 24:11.140
不用担心程序执行不了

24:11.140 --> 24:12.260
它一定能正常执行

24:13.220 --> 24:14.340
好 再举个例子

24:15.140 --> 24:16.660
所以说我们写地规的时候

24:16.660 --> 24:18.660
你只要理解了它的程序执行过程

24:18.660 --> 24:20.500
你心中不会有这个疑惑了

24:20.500 --> 24:23.140
程序到底能不能正常执行这个疑惑

24:23.780 --> 24:25.060
没有这个疑惑之后呢

24:25.060 --> 24:27.380
你写地规的话就轻松很多了

24:27.380 --> 24:29.300
你就按照它的逻辑来写就行了

24:29.300 --> 24:30.580
大胆的写放心

24:30.580 --> 24:31.700
它一定是没问题的

24:31.700 --> 24:32.740
只要它逻辑没问题

24:32.740 --> 24:33.700
它就一定没问题

24:33.700 --> 24:35.140
好 比方说再来一个例子

24:36.100 --> 24:37.860
也是地规里边的一个常见例子

24:37.860 --> 24:38.500
叫阶层

24:39.700 --> 24:40.420
阶层

24:40.660 --> 24:41.140
阶层

24:43.560 --> 24:44.680
阶层是啥呢

24:47.880 --> 24:48.440
是这样子

24:49.320 --> 24:50.680
还是用个函数F嘛

24:52.120 --> 24:53.080
求啥呢

24:53.080 --> 24:54.840
求n的阶层

24:55.640 --> 24:56.440
n的阶层

24:57.960 --> 25:00.680
阶层其实我们在数学里边记住记住这个

25:00.680 --> 25:01.640
n感叹号

25:01.640 --> 25:02.440
我这里说一下

25:03.720 --> 25:05.560
比方说5的阶层等于啥呢

25:05.560 --> 25:08.520
5×4×3×2×1

25:08.520 --> 25:09.240
这就是5的阶层

25:09.240 --> 25:10.280
明白了 明白这个意思吧

25:10.680 --> 25:11.080
对不对

25:11.080 --> 25:11.560
没问题吧

25:12.360 --> 25:13.000
好 那么

25:13.960 --> 25:15.320
阶层怎么来算呢

25:16.040 --> 25:17.160
阶层怎么算呢

25:18.760 --> 25:19.320
是这样子

25:20.440 --> 25:21.880
阶层如果把fn

25:22.920 --> 25:24.280
当作是阶层的话

25:24.280 --> 25:26.280
那么f1等于多少

25:26.920 --> 25:27.480
等于多少

25:29.080 --> 25:30.600
f1是不是一定等于1

25:30.600 --> 25:31.080
对不对

25:31.080 --> 25:31.880
一定等于1

25:32.360 --> 25:33.240
分好写习惯了

25:33.880 --> 25:35.080
f1一定等于1

25:35.080 --> 25:35.320
对吧

25:36.200 --> 25:37.720
一直加上一定等于1嘛

25:37.720 --> 25:40.120
f3到2的阶层等于多少

25:41.080 --> 25:44.360
是不是等于2×1f1

25:45.640 --> 25:46.200
没问题吧

25:48.300 --> 25:49.980
f3的阶层等于多少

25:51.260 --> 25:52.860
3×1f2

25:53.980 --> 25:54.460
没问题吧

25:55.180 --> 25:56.220
5的阶层多少

25:56.220 --> 25:59.100
5的阶层等于5×14的阶层

26:00.380 --> 26:01.020
是不是f4

26:02.700 --> 26:03.340
出来了

26:03.340 --> 26:04.460
不用写什么循环

26:05.020 --> 26:06.780
n等于1的时候返回1

26:07.420 --> 26:09.500
否则的话返回n×1

26:09.980 --> 26:11.260
n×1f

26:11.660 --> 26:13.660
n×1

26:14.300 --> 26:14.780
完了

26:15.740 --> 26:16.940
阶层就算出来了

26:16.940 --> 26:17.900
没有任何循环

26:18.140 --> 26:19.420
短暖的几行代码

26:19.420 --> 26:20.780
而且特别好理解

26:20.780 --> 26:22.460
这个代码特别特别好理解

26:23.020 --> 26:24.620
虽然说你看上去

26:24.620 --> 26:26.060
怎么调自用自身调用自身

26:26.060 --> 26:27.340
但是经过我这么一解释

26:27.340 --> 26:28.220
是不是能够理解

26:28.380 --> 26:29.820
自身调用自身是没有问题的

26:29.820 --> 26:30.780
没有任何问题的

26:31.580 --> 26:32.780
那么纯粹说

26:32.780 --> 26:33.900
逻辑上来理解

26:33.900 --> 26:35.020
极其理好理解

26:35.020 --> 26:35.580
接什么

26:35.580 --> 26:36.620
n等于1

26:36.620 --> 26:38.140
那肯定是接成的只是1

26:38.140 --> 26:39.020
否则的话阶层等于

26:39.020 --> 26:39.820
它自身成立

26:39.820 --> 26:40.940
它下面一个数的阶层

26:41.980 --> 26:42.780
非常好理解

26:42.780 --> 26:43.900
比方说5的阶层

26:43.900 --> 26:45.340
5×1×4×3×2

26:45.340 --> 26:46.460
来新算一下

26:47.180 --> 26:47.980
看一下

26:49.100 --> 26:50.220
120对吧

26:50.220 --> 26:51.020
120

26:51.500 --> 26:52.380
这就出来了

26:52.540 --> 26:53.340
没问题吧

26:53.660 --> 26:55.180
这就是低规

26:56.140 --> 26:57.740
但是重低规的时候

26:57.740 --> 26:58.940
一定要小心

26:58.940 --> 27:00.060
一定要小心

27:00.060 --> 27:00.860
就是

27:01.660 --> 27:02.940
用低规的时候

27:03.420 --> 27:05.980
要避免无限低规

27:06.460 --> 27:07.820
什么叫无限低规呢

27:07.820 --> 27:10.540
就是你没有给中指条件

27:10.700 --> 27:11.980
就是低规的中指条件

27:11.980 --> 27:13.340
它就会造成无限低规

27:13.740 --> 27:14.620
像这种情况

27:15.100 --> 27:15.820
像这里

27:17.100 --> 27:17.980
这里的话

27:18.380 --> 27:20.220
如果你没有写这个条件

27:20.780 --> 27:21.740
很恐怖

27:22.060 --> 27:22.540
很恐怖

27:22.540 --> 27:23.820
它就是无限低规了

27:24.140 --> 27:25.420
它永远算不出来

27:25.420 --> 27:27.180
这个函数调用永远不会结束

27:27.180 --> 27:28.300
它没有一个结束点

27:28.620 --> 27:29.580
比方说

27:29.580 --> 27:30.940
你这里f5

27:31.100 --> 27:31.740
f3

27:32.220 --> 27:33.100
它等于多少呢

27:33.340 --> 27:36.140
等于n3×f2

27:36.140 --> 27:36.540
对不对

27:36.540 --> 27:37.820
它现在去执行f2

27:37.820 --> 27:39.420
要把f2的值算出来

27:39.420 --> 27:39.900
对不对

27:39.980 --> 27:41.340
它要把f2的值算出来

27:41.340 --> 27:42.940
f2又等于啥呢

27:42.940 --> 27:45.500
等于2×f1

27:45.820 --> 27:46.380
对吧

27:46.380 --> 27:47.660
然后f1呢

27:47.660 --> 27:50.780
又等于1×f0

27:51.020 --> 27:51.580
好

27:51.820 --> 27:52.700
f0呢

27:52.700 --> 27:53.980
因为你没有中指对吧

27:53.980 --> 27:58.060
你没有中指等于0×f

27:58.220 --> 27:58.700
什么了

27:58.700 --> 27:59.740
f-1

28:00.060 --> 28:00.460
对不对

28:00.460 --> 28:01.500
它要算-1了

28:01.500 --> 28:02.860
是不是永远不会结束了

28:03.420 --> 28:05.340
这个调用它永远无法结束

28:05.660 --> 28:05.900
对吧

28:05.900 --> 28:07.020
所以说你一定要设置

28:07.020 --> 28:08.220
注意中指条件

28:08.220 --> 28:09.740
就是你要心里面要清楚

28:09.820 --> 28:11.740
它什么时候要结束

28:13.180 --> 28:13.740
所以说

28:13.740 --> 28:14.380
如果你

28:14.380 --> 28:15.740
如果无线

28:15.740 --> 28:16.860
就这里不中指的话

28:16.860 --> 28:18.300
会得到一个什么样的结果呢

28:18.460 --> 28:19.020
有的同学说

28:19.020 --> 28:20.700
就相当于是无线循环

28:20.700 --> 28:21.580
类似

28:21.580 --> 28:23.580
类似于出现无线循环

28:23.580 --> 28:25.580
但是比无线循环的

28:25.740 --> 28:26.780
还是有些不同

28:26.780 --> 28:28.140
相比出来还是有些不同

28:28.140 --> 28:28.940
咱们来看一下

28:28.940 --> 28:29.980
说一下这个问题

28:32.500 --> 28:34.100
无线循环它一会一直卡住

28:34.100 --> 28:35.300
这里会一直卡住

28:35.620 --> 28:36.500
但是地位不回

28:36.500 --> 28:37.300
它爆错了

28:38.260 --> 28:39.140
再来看

28:39.300 --> 28:40.100
它说什么

28:41.700 --> 28:42.900
最大的什么

28:42.900 --> 28:44.500
Costac size

28:45.380 --> 28:46.740
Costac什么东西

28:47.380 --> 28:48.340
执行站

28:48.340 --> 28:49.380
执行站

28:50.260 --> 28:51.300
Costac size

28:51.300 --> 28:52.020
什么东西

28:52.020 --> 28:52.820
尺寸

28:52.820 --> 28:53.700
一个seed

28:53.700 --> 28:54.580
溢出

28:54.820 --> 28:55.860
这里我说一下

28:56.900 --> 28:57.860
执行站

28:58.580 --> 28:59.540
执行站

29:00.180 --> 29:02.900
有固定的

29:02.900 --> 29:04.740
就是大小

29:05.540 --> 29:06.900
它有一些固定的大小

29:06.900 --> 29:09.140
应该说相对固定的大小

29:09.140 --> 29:10.500
总之它不是无线大的

29:10.580 --> 29:11.780
执行站的内存空间

29:11.780 --> 29:12.660
不是无线大的

29:13.140 --> 29:17.700
如果执行环境太多

29:18.820 --> 29:22.660
执行站无法容纳的话

29:23.460 --> 29:24.740
会爆错

29:24.740 --> 29:25.620
会爆错

29:26.580 --> 29:27.540
这个错不就是这个

29:28.500 --> 29:30.740
执行站已经融不下这个东西了

29:30.740 --> 29:31.460
已经融不下了

29:31.460 --> 29:32.260
一看不断的交融

29:32.260 --> 29:33.300
不断的交融

29:33.300 --> 29:34.580
已经融不下了

29:35.300 --> 29:35.540
好

29:35.540 --> 29:36.420
那么我们

29:36.580 --> 29:37.460
经过之前的分析

29:37.460 --> 29:37.860
对吧

29:37.860 --> 29:38.980
那你想这个道理

29:39.140 --> 29:40.500
一个函数没有运行完

29:40.500 --> 29:41.540
它就掉另一个函数

29:41.540 --> 29:42.900
而另一个函数又要掉另一个函数

29:42.900 --> 29:43.540
又没有运行完

29:43.540 --> 29:44.500
它要掉另一个函数

29:44.500 --> 29:46.020
什么一直掉一直掉

29:46.020 --> 29:46.500
对吧

29:47.380 --> 29:48.500
这个执行站是

29:48.500 --> 29:50.500
再大的执行站能撑不下这个东西

29:50.500 --> 29:50.820
对吧

29:50.820 --> 29:52.660
所以说它会叫做站溢出

29:52.660 --> 29:54.020
我们把它叫做站溢出

29:54.020 --> 29:54.660
于是呢

29:55.380 --> 29:56.180
发生了错误

29:56.660 --> 29:58.500
因此无线地规会导致什么

29:58.500 --> 30:00.260
无线地规会导致

30:01.380 --> 30:05.860
无线地规会导致执行站溢出

30:05.860 --> 30:06.900
溢出

30:06.900 --> 30:07.780
就是装不下了对吧

30:07.780 --> 30:08.420
像水一样

30:08.500 --> 30:09.380
装不下了就溢出了

30:09.380 --> 30:10.500
对不对

30:10.500 --> 30:11.620
它会包错

30:11.620 --> 30:12.660
它会包错

30:13.540 --> 30:15.460
那么这个东西跟无线循环

30:15.460 --> 30:16.900
有什么样的区别呢

30:16.900 --> 30:17.940
它跟无线循环

30:17.940 --> 30:18.900
有什么样的区别呢

30:18.900 --> 30:20.100
大家看一下

30:20.100 --> 30:21.540
咱们来看一个无线循环

30:23.620 --> 30:28.250
无线循环和无线地规

30:29.930 --> 30:31.210
这两个是不一样的

30:31.210 --> 30:32.490
我这里把写成正确的

30:34.410 --> 30:35.450
比方说

30:35.450 --> 30:37.370
这里有两组代码

30:37.370 --> 30:38.170
我们来看一下

30:38.170 --> 30:38.810
分别来看一下

30:38.890 --> 30:40.490
第一组是无线循环

30:40.490 --> 30:42.410
WildQ

30:44.090 --> 30:46.890
每一次循环了

30:46.890 --> 30:47.530
干嘛了

30:47.530 --> 30:48.330
啥都不做吧

30:48.330 --> 30:49.130
就啥都不做

30:49.130 --> 30:50.010
就输出一个吧

30:50.010 --> 30:51.690
就输出一个1

30:52.810 --> 30:53.370
好吧

30:53.370 --> 30:54.010
输出一个1

30:54.650 --> 30:55.050
没问题吧

30:55.930 --> 30:56.650
OK

30:56.650 --> 30:57.530
那咱们看一下

30:57.530 --> 30:58.250
这个无线循环

30:59.530 --> 30:59.850
运行

31:03.750 --> 31:06.070
无线循环会不会包错呢

31:07.190 --> 31:08.070
它不会包错

31:08.070 --> 31:09.270
它会导致一面卡死

31:09.270 --> 31:09.590
对吧

31:09.590 --> 31:09.990
一面卡死

31:09.990 --> 31:10.870
它一直在处理

31:10.870 --> 31:11.190
对吧

31:11.270 --> 31:11.910
一直在做事情

31:11.910 --> 31:12.710
一直在做事情

31:12.710 --> 31:13.750
它不会爆错

31:13.750 --> 31:15.270
为什么它不会爆错呢

31:15.270 --> 31:16.390
因为无线循环

31:16.390 --> 31:17.110
我们这里记一笔

31:19.290 --> 31:20.490
对比无线循环

31:22.890 --> 31:23.290
循环

31:24.570 --> 31:25.770
无线循环

31:25.770 --> 31:26.570
就是死循环

31:27.690 --> 31:28.570
死循环

31:32.410 --> 31:34.250
它一直等不到结果

31:34.250 --> 31:35.370
它不会爆错的

31:35.370 --> 31:36.250
它等不到响应

31:37.690 --> 31:40.490
它说死循环不会爆错

31:40.490 --> 31:41.290
它不会爆错

31:41.930 --> 31:45.370
也不会导致战役出

31:46.330 --> 31:46.810
为什么呢

31:47.450 --> 31:47.930
一看一下

31:52.570 --> 31:52.970
这里

31:53.530 --> 31:55.210
执行站里面是不是就一个东西

31:55.850 --> 31:56.810
就一个拳击环境

31:57.370 --> 31:57.930
还有啥呢

31:58.410 --> 32:00.010
执行站里面是不是就一个拳击环境

32:00.330 --> 32:00.650
对吧

32:01.210 --> 32:03.130
有人说那我把它放到寒树里面行不行

32:03.130 --> 32:03.770
那行

32:03.770 --> 32:05.210
那就多一个寒树环境没

32:05.610 --> 32:06.410
是不是就两个环境

32:07.050 --> 32:07.290
对吧

32:08.170 --> 32:09.370
就两个环境还有啥呢

32:09.850 --> 32:10.890
是没它其他东西的

32:13.050 --> 32:13.770
没它其他东西的

32:14.730 --> 32:15.370
不是扛手

32:15.850 --> 32:16.410
调用A嘛

32:16.410 --> 32:16.810
对不对

32:17.130 --> 32:18.170
所以还是一样的

32:18.170 --> 32:20.330
只有一个拳击环境和一个寒树环境

32:20.330 --> 32:22.010
这个寒树环境永远无法销毁

32:22.010 --> 32:22.330
对吧

32:22.330 --> 32:23.850
因为这个寒树结束不了

32:23.850 --> 32:24.970
它结束不了这个寒树

32:24.970 --> 32:25.930
它永远无法销毁

32:26.490 --> 32:26.890
但是

32:28.170 --> 32:28.730
但是

32:28.730 --> 32:30.250
它顶多导致页面卡住

32:30.250 --> 32:31.210
它站会不会溢出

32:31.210 --> 32:32.170
内存会不会溢出

32:32.730 --> 32:34.250
内存占用的很少很少

32:34.250 --> 32:35.210
根本就不会溢出

32:35.610 --> 32:36.490
那有人说

32:36.490 --> 32:37.370
那我这样子呢

32:38.010 --> 32:38.650
我这样子

32:38.650 --> 32:39.530
我这里定个变量

32:39.850 --> 32:40.330
变量

32:41.530 --> 32:43.130
那这样子每次循环不是一个变量吗

32:43.210 --> 32:44.490
它是不是内存就溢出了

32:44.490 --> 32:45.290
不会的

32:45.290 --> 32:46.570
变量它会提升的

32:46.570 --> 32:47.690
它会提升到这儿

32:47.690 --> 32:48.490
能溢出吗

32:48.490 --> 32:49.530
它也溢出不了啊

32:50.010 --> 32:50.890
也溢出不了啊

32:51.530 --> 32:52.810
所以只有一个变量

32:52.810 --> 32:53.210
对不对

32:53.210 --> 32:55.050
无限循环它不会导致内存

32:55.050 --> 32:56.090
内存溢出的

32:56.090 --> 32:57.130
是不会的

32:57.130 --> 32:58.490
这是无限循环

32:58.490 --> 33:00.330
但是无限低规是不是有可能

33:00.330 --> 33:01.050
对不对

33:01.050 --> 33:02.490
无限低规就有可能会导

33:02.490 --> 33:04.570
它就会导致内存溢出

33:04.570 --> 33:06.490
比方说A里面要直接调用A

33:06.490 --> 33:07.450
我都啥都不管了

33:08.330 --> 33:09.130
一调用A

33:09.130 --> 33:10.970
那这个环境是不是无限往上叠

33:10.970 --> 33:11.530
对吧

33:11.610 --> 33:12.650
运行A的时候

33:12.650 --> 33:14.250
它要创建新的环境A

33:14.250 --> 33:14.490
好

33:14.490 --> 33:15.530
运行新的A的时候

33:15.530 --> 33:17.050
它又要创建新的环境A

33:17.050 --> 33:19.290
前面的A就是销毁不了

33:19.290 --> 33:19.770
对吧

33:19.770 --> 33:20.650
那这样子呢

33:20.650 --> 33:22.010
它会创建一个

33:22.010 --> 33:22.650
这样子的

33:22.650 --> 33:23.530
它倒不会卡死啊

33:23.530 --> 33:24.090
倒不会卡死

33:24.090 --> 33:25.210
因为它直接爆缩了

33:25.210 --> 33:26.650
它内存溢出了对吧

33:26.650 --> 33:27.130
啊

33:27.850 --> 33:28.730
你知道这个意思吗

33:28.730 --> 33:29.690
这无限环

33:29.690 --> 33:33.290
无限使循环和无限低规

33:33.290 --> 33:35.370
它的区别啊

33:36.730 --> 33:37.930
无限低规

33:37.930 --> 33:39.770
会导致战役出

33:39.770 --> 33:40.410
啊

33:40.410 --> 33:40.970
战役出

33:42.410 --> 33:42.730
好吧

33:42.730 --> 33:44.170
这是关于低规

33:44.170 --> 33:44.330
啊

33:44.330 --> 33:45.210
和区别

33:45.210 --> 33:46.330
这可能面试题会问啊

33:47.130 --> 33:47.370
好

33:47.370 --> 33:48.730
今天我们再来一个例子啊

33:48.730 --> 33:50.330
再来一个稍微复杂点的例子

33:50.330 --> 33:51.130
我们可以看到

33:51.130 --> 33:53.770
低规再解决一些非常复杂问题的时候

33:54.330 --> 33:55.290
有多么的恐怖

33:56.170 --> 33:57.850
这真的是超级超级恐怖

33:58.570 --> 33:58.730
啊

33:58.730 --> 33:59.850
这个叫做汉诺塔

34:03.640 --> 34:04.920
汉诺塔呢是个小游戏啊

34:04.920 --> 34:06.200
不知道不知道大家玩过没有

34:06.200 --> 34:06.360
哎

34:06.360 --> 34:06.760
我之前

34:07.320 --> 34:08.360
我之前公开课

34:08.360 --> 34:09.720
做过这么一个小游戏

34:09.720 --> 34:10.360
给大家看一下吧

34:11.240 --> 34:11.320
啊

34:11.320 --> 34:11.960
当然我现在

34:11.960 --> 34:12.760
我们现在还做不了啊

34:12.760 --> 34:13.720
现在在页面上

34:13.800 --> 34:15.000
还没有学习到页面上

34:15.000 --> 34:16.040
所以说现在还做不了

34:16.040 --> 34:16.440
但是呢

34:16.440 --> 34:17.240
我们可以看一下啊

34:17.240 --> 34:19.000
理解一下这个游戏的逻辑

34:20.600 --> 34:21.000
在哪呢

34:21.560 --> 34:22.200
汉诺塔啊

34:22.200 --> 34:22.520
在这

34:24.940 --> 34:25.100
啊

34:25.100 --> 34:25.980
就这么一个东西啊

34:25.980 --> 34:26.860
就这么一个东西

34:26.860 --> 34:27.980
你要干嘛呢

34:27.980 --> 34:28.700
你要把这个

34:29.180 --> 34:30.140
就这个玩意儿啊

34:30.620 --> 34:30.940
不

34:30.940 --> 34:31.740
就整个这一块

34:32.140 --> 34:33.340
整个这一块移动到

34:33.340 --> 34:34.220
第三根柱子

34:34.220 --> 34:34.620
啊

34:34.620 --> 34:35.820
移动到第三根柱子

34:35.820 --> 34:37.580
规则是小的呢

34:37.580 --> 34:38.620
可以放到大的上面

34:39.100 --> 34:39.900
那怎么移动呢

34:41.340 --> 34:42.300
我这个地方

34:42.300 --> 34:43.740
我这里少写电吧

34:43.740 --> 34:44.140
少写电

34:44.140 --> 34:45.100
这个太多了

34:45.100 --> 34:45.660
太多了

34:46.220 --> 34:47.580
我们把这个介石改一下

34:47.580 --> 34:48.460
啊之前写的介石

34:49.020 --> 34:49.500
呃

34:50.300 --> 34:51.340
改成三二一嘛

34:51.820 --> 34:52.300
三二一

34:55.020 --> 34:55.660
好看一下啊

34:56.460 --> 34:57.020
然后移面

34:57.580 --> 34:57.980
刷新

34:58.540 --> 34:58.780
啊

34:58.780 --> 34:59.260
只有三个

34:59.260 --> 35:00.300
只有三个就好理解了

35:00.300 --> 35:00.540
对吧

35:01.260 --> 35:02.940
先把这个往左边移

35:02.940 --> 35:03.660
移过来

35:03.660 --> 35:05.180
然后这个往右边移过来

35:05.180 --> 35:05.660
然后把这个

35:06.140 --> 35:06.940
往这边移动

35:07.180 --> 35:07.660
然后这个

35:08.060 --> 35:08.620
移过来

35:08.860 --> 35:09.660
然后这个移过来

35:09.660 --> 35:10.300
这个移过来

35:10.620 --> 35:10.700
啊

35:10.700 --> 35:11.260
这个移过来

35:12.140 --> 35:12.780
啊就完成了

35:12.780 --> 35:13.180
对吧

35:13.180 --> 35:13.660
就完成了

35:14.220 --> 35:14.300
啊

35:14.300 --> 35:14.860
这个游戏呢

35:14.860 --> 35:16.140
我小时候还特别喜欢

35:16.540 --> 35:17.340
小时候是在那种

35:17.340 --> 35:18.540
掌上的游戏机啊

35:18.540 --> 35:19.100
很小的

35:19.420 --> 35:20.620
然后上面有个汉诺塔

35:21.180 --> 35:22.140
这个叫什么

35:22.140 --> 35:23.020
文曲星

35:23.020 --> 35:23.900
一个学习机

35:23.900 --> 35:24.860
上面有个汉诺塔

35:25.020 --> 35:26.060
一个异志游戏嘛

35:26.300 --> 35:27.500
小时候玩的好多关啊

35:27.500 --> 35:28.060
好多关啊

35:28.060 --> 35:28.940
后来后来发现

35:28.940 --> 35:29.820
后来为什么不玩

35:29.820 --> 35:30.460
不玩了呢

35:30.460 --> 35:31.740
因为发现它有规律啊

35:31.740 --> 35:32.860
就没什么意思的啊

35:32.860 --> 35:33.660
无论多少

35:33.660 --> 35:34.780
它都能找到规律

35:34.780 --> 35:36.140
然后呢可以把它放过去

35:36.780 --> 35:38.380
好接下来我们要干嘛啊

35:38.380 --> 35:39.420
说一下我们接下来干嘛

35:39.420 --> 35:40.540
肯定不是做介面啊

35:40.540 --> 35:41.740
介面我们现在做不了

35:41.740 --> 35:42.140
但是呢

35:42.140 --> 35:43.420
我们可以写它的逻辑

35:44.380 --> 35:46.140
假设一个函数

35:46.140 --> 35:46.940
给它取个名字

35:46.940 --> 35:47.580
汉诺塔嘛

35:47.580 --> 35:48.220
汉诺嘛

35:48.220 --> 35:48.700
对吧

35:48.700 --> 35:49.180
汉诺

35:50.460 --> 35:51.660
这个这个函数呢

35:51.660 --> 35:52.700
有四个参数

35:53.580 --> 35:54.060
A

35:54.620 --> 35:55.100
B

35:55.580 --> 35:56.140
C

35:56.540 --> 35:57.020
N

35:57.660 --> 35:58.540
啥意思呢

35:58.780 --> 35:59.420
看着啊

35:59.420 --> 35:59.980
一会呢

35:59.980 --> 36:02.220
我们会告诉它每一个柱子的名字

36:02.220 --> 36:03.660
一个每个柱子的编号

36:03.820 --> 36:05.420
它这里能用变量来接收啊

36:05.420 --> 36:06.460
用变量来接收

36:06.780 --> 36:08.140
每一个柱子的编号

36:08.460 --> 36:09.340
比方说啊

36:09.340 --> 36:10.860
我们以后直接调用汉诺

36:12.060 --> 36:12.780
汉诺塔

36:12.940 --> 36:14.060
比方说我们告诉它

36:14.060 --> 36:15.500
第一个柱子的编号是A

36:15.740 --> 36:15.980
啊

36:15.980 --> 36:17.580
保证这个变量里边啊

36:17.580 --> 36:18.300
编号1嘛

36:18.300 --> 36:19.340
我们这里用N1

36:19.340 --> 36:19.820
就是

36:20.300 --> 36:20.780
编号

36:21.340 --> 36:22.060
Number1嘛

36:23.740 --> 36:25.260
编号用N0对吧

36:25.260 --> 36:26.060
Number2

36:26.060 --> 36:26.940
Number3

36:27.980 --> 36:29.020
Number2

36:29.020 --> 36:29.900
三个柱子对吧

36:29.900 --> 36:30.780
三个柱子有编号

36:30.780 --> 36:31.740
我这里输出编号

36:32.300 --> 36:33.020
A

36:33.020 --> 36:33.580
B

36:34.300 --> 36:34.460
C

36:35.260 --> 36:36.300
三个柱子

36:36.300 --> 36:39.180
我的目标是要把编号1的东西

36:39.180 --> 36:40.540
编号1上面的

36:40.540 --> 36:42.380
就是这个小块啊

36:42.460 --> 36:44.140
把编号1上面的这个小块

36:44.140 --> 36:45.100
一开始的

36:45.100 --> 36:46.540
编号1上面的这个小块

36:46.540 --> 36:47.500
移动到哪呢

36:47.500 --> 36:48.780
移动到编号3

36:48.780 --> 36:49.420
通

36:49.420 --> 36:50.780
编号2这个柱子呢

36:50.780 --> 36:52.140
是用来辅助的啊

36:52.140 --> 36:53.580
汉诺塔一共就三个柱子

36:53.580 --> 36:54.060
啊

36:54.060 --> 36:55.580
编号2这个柱子是用来辅助的

36:55.580 --> 36:57.180
一会我调用的时候就这样调用

36:57.180 --> 36:58.060
A,B,C

36:58.060 --> 36:59.340
柱子的编号

36:59.340 --> 37:00.460
然后呢

37:00.460 --> 37:03.660
把现在的A这个柱子上的数量啊

37:03.660 --> 37:05.500
就是A这个柱子上的数量

37:05.500 --> 37:06.540
告诉它

37:06.540 --> 37:07.660
比方说

37:07.660 --> 37:08.940
告诉它1

37:08.940 --> 37:09.340
啊

37:09.340 --> 37:10.380
告诉它1的时候

37:10.380 --> 37:11.820
它应该要输出啥呢

37:11.900 --> 37:13.820
它应该要输出这么一个结果

37:14.540 --> 37:15.820
它应该要输出

37:15.820 --> 37:16.860
什么

37:16.860 --> 37:17.980
A

37:17.980 --> 37:19.180
到

37:19.180 --> 37:20.220
C

37:20.220 --> 37:21.020
啊A到C

37:21.020 --> 37:21.980
它就应该这样输出

37:21.980 --> 37:23.660
把A移动到C

37:23.660 --> 37:24.700
你要是意思吧

37:24.700 --> 37:26.300
如果告诉它有两个

37:26.300 --> 37:27.500
啊如果告诉它有两个

37:27.500 --> 37:28.460
那么两个的情况

37:28.460 --> 37:29.500
咱们看一下啊

37:29.500 --> 37:31.500
两个的情况该怎么来移动

37:31.500 --> 37:35.800
好两个的情况的话

37:35.800 --> 37:37.240
好两个的情况的话

37:37.240 --> 37:38.200
应该怎么移动了

37:38.200 --> 37:41.160
是不是A到B

37:41.160 --> 37:42.680
啊A到B

37:42.760 --> 37:44.200
然后A到C

37:44.200 --> 37:45.800
然后再B到C

37:45.800 --> 37:46.360
对吧

37:46.360 --> 37:47.720
那么它就应该输出

37:47.720 --> 37:48.760
啊

37:48.760 --> 37:50.520
这是一个的情况

37:50.520 --> 37:51.880
这是两个的情况

37:51.880 --> 37:53.240
那应该怎么输出呢

37:53.240 --> 37:54.920
A到

37:54.920 --> 37:55.800
哎

37:55.800 --> 37:57.160
A到

37:57.160 --> 37:59.080
啊B

37:59.080 --> 38:00.600
然后呢

38:00.600 --> 38:01.480
是吧

38:01.480 --> 38:02.280
B

38:02.280 --> 38:04.520
B到

38:04.520 --> 38:06.120
啊对不对

38:06.120 --> 38:07.240
A到B

38:07.240 --> 38:08.760
我头都晕了

38:08.760 --> 38:09.560
到了啊

38:09.560 --> 38:10.920
A到B

38:11.000 --> 38:12.920
然后呢A到C

38:12.920 --> 38:13.960
啊A

38:16.600 --> 38:17.720
到什么

38:17.720 --> 38:18.520
C

38:18.520 --> 38:19.480
然后呢

38:19.480 --> 38:20.520
两个的情况

38:20.520 --> 38:21.880
再呢B到C

38:21.880 --> 38:22.520
对吧

38:22.520 --> 38:23.080
B到C

38:24.200 --> 38:25.000
没问题吧

38:25.000 --> 38:25.480
对吧

38:25.480 --> 38:27.560
编号唯一的到编号3

38:27.560 --> 38:28.760
啊的第一个情况

38:28.760 --> 38:29.800
那直接过去就行了

38:29.800 --> 38:30.840
不需要辅助了

38:30.840 --> 38:33.160
好如果是两个两个块了

38:33.160 --> 38:35.160
它就是编号1到编号2

38:35.160 --> 38:36.520
编号1到编号3

38:36.520 --> 38:38.040
编号2到编号3

38:38.040 --> 38:38.680
对吧

38:38.680 --> 38:40.120
它应该是这么种情况

38:40.120 --> 38:40.600
好

38:40.680 --> 38:42.600
那么接下来我们来找找规律

38:42.600 --> 38:43.960
来找找规律

38:43.960 --> 38:45.960
那如果是三个呢

38:45.960 --> 38:50.140
那如果是三个呢

38:50.140 --> 38:51.420
想一想

38:51.420 --> 38:53.260
三个又是什么情况

38:53.260 --> 39:00.010
啊三个又是什么情况

39:00.010 --> 39:01.450
三个是啥情况呢

39:01.450 --> 39:02.730
看着啊

39:02.730 --> 39:03.930
三个

39:03.930 --> 39:04.890
很恐怖啊

39:04.890 --> 39:06.170
真的是非常恐怖

39:06.170 --> 39:08.490
我们这里把它比较做做f1嘛

39:08.490 --> 39:10.090
啊f1

39:10.090 --> 39:10.730
f1

39:10.730 --> 39:12.170
f1的移动方式很简单

39:12.170 --> 39:13.530
A到C就完事了

39:13.530 --> 39:15.130
f2的移动方式

39:15.130 --> 39:16.250
也很简单啊

39:16.250 --> 39:17.130
就这个到这个

39:17.690 --> 39:18.250
这样子

39:18.250 --> 39:19.690
这样子来处理

39:19.690 --> 39:20.650
f3的

39:20.650 --> 39:22.490
fn的情况呢

39:22.490 --> 39:23.530
或者f3的情况

39:23.530 --> 39:25.210
我们看f3的情况

39:25.210 --> 39:25.930
f3的情况呢

39:25.930 --> 39:27.770
我们可以这样子来想

39:27.770 --> 39:30.730
你把这一块想成一个整体

39:30.730 --> 39:32.890
你把这一块想成一个整体

39:32.890 --> 39:36.090
先把整个这一坨移动到哪

39:36.090 --> 39:36.890
移动到这一块

39:36.890 --> 39:37.210
对吧

39:37.210 --> 39:38.810
移动到这

39:38.810 --> 39:41.610
然后再把这个东西移动到

39:41.610 --> 39:42.330
这对吧

39:42.330 --> 39:43.450
移动到这

39:43.450 --> 39:44.250
然后再把这个的

39:44.250 --> 39:46.250
这一坨又移动过去

39:46.330 --> 39:47.530
你把这个意思吧

39:47.530 --> 39:48.170
啊

39:48.170 --> 39:50.090
那么我们可以这样子来理解啊

39:50.090 --> 39:51.530
比方说第一个情况

39:51.530 --> 39:54.090
传了什么abc

39:54.090 --> 39:54.890
对不对

39:54.890 --> 39:56.570
或者就abc嘛

39:56.570 --> 39:57.530
abc1

39:57.530 --> 39:58.730
那么它直接是A到C

39:58.730 --> 39:59.450
对不对

39:59.450 --> 40:00.410
二的情况呢

40:00.410 --> 40:01.930
其实就已经是这个规律了

40:01.930 --> 40:03.850
二的情况就已经是这个规律了

40:03.850 --> 40:04.010
好

40:04.010 --> 40:06.010
二的情况我们再来重新分析一下啊

40:06.010 --> 40:07.690
再重新分析一下二的情况

40:08.890 --> 40:09.130
好

40:09.130 --> 40:09.610
二的情况

40:10.650 --> 40:11.130
看一下啊

40:12.810 --> 40:14.250
重新分析一下二的情况

40:14.250 --> 40:16.090
二的情况是怎么回事呢

40:16.170 --> 40:17.130
有两根柱子的

40:17.130 --> 40:18.170
有两个块了

40:18.170 --> 40:19.130
那怎么移动呢

40:19.130 --> 40:20.330
我是这样子移动的

40:20.330 --> 40:22.090
一个就是直接A到C

40:22.090 --> 40:23.210
怎么移动呢

40:23.210 --> 40:24.890
我是先把这个

40:26.410 --> 40:27.290
上边的这个

40:28.090 --> 40:29.450
移动到这对吧

40:29.450 --> 40:30.970
上边的这个移动到这

40:30.970 --> 40:33.130
也就说我们先把这一个移动到这

40:33.850 --> 40:34.730
没问题吧

40:34.730 --> 40:35.290
把这个东西

40:36.490 --> 40:37.130
对的啊

40:37.130 --> 40:38.970
把这个东西A移动到B

40:38.970 --> 40:41.210
那么我们可不可以认为是这样子

40:41.210 --> 40:42.010
先干嘛呢

40:43.290 --> 40:43.930
先是

40:44.570 --> 40:45.850
把A这个柱子

40:46.330 --> 40:47.130
移动到哪呢

40:47.130 --> 40:49.050
经过C这个柱子

40:49.050 --> 40:49.850
移动到B

40:51.290 --> 40:51.690
一个

40:53.690 --> 40:54.250
没问题吧

40:55.450 --> 40:57.130
先第一步做这么一件事

40:58.570 --> 40:59.610
把A这个柱子

41:00.570 --> 41:01.530
这是A这个柱子

41:01.530 --> 41:02.490
这是B这是C

41:03.130 --> 41:04.010
我要移动到B

41:04.010 --> 41:06.730
我要通过C移动到B

41:06.730 --> 41:07.290
对吧

41:07.290 --> 41:08.890
把这个东西移动到B

41:09.770 --> 41:11.130
刚才是移动到C嘛

41:11.130 --> 41:11.930
对吧

41:11.930 --> 41:12.570
移动到C

41:12.570 --> 41:13.290
那么现在呢

41:13.290 --> 41:15.450
我先把上边的这个东西

41:15.530 --> 41:17.770
A这个东西移动到B

41:17.770 --> 41:18.970
经过C这个柱子

41:18.970 --> 41:20.730
C这个柱子作为辅助移动到B

41:22.010 --> 41:22.250
好

41:22.250 --> 41:23.050
先做这么一件事

41:23.610 --> 41:24.730
那么数量是多少呢

41:24.730 --> 41:25.210
数量是一

41:25.210 --> 41:26.090
因为一共有两个嘛

41:26.090 --> 41:27.290
它上面只有一个对不对

41:27.290 --> 41:28.170
上面也只有一个

41:29.290 --> 41:31.130
我们先把上面这一种东西移动到这

41:31.850 --> 41:32.490
好

41:32.490 --> 41:33.610
移动过去之后

41:34.170 --> 41:35.530
移动过去之后再干嘛呢

41:35.850 --> 41:36.410
再干嘛呢

41:36.890 --> 41:38.970
是不是在A到

41:39.690 --> 41:41.210
什么A到C

41:42.090 --> 41:42.970
没问题吧

41:42.970 --> 41:43.930
在A到C

41:44.010 --> 41:45.450
再把它直接移动到C

41:46.650 --> 41:46.890
好

41:46.890 --> 41:48.010
然后再干嘛呢

41:49.450 --> 41:50.890
这边是不是刚才有一个对吧

41:50.890 --> 41:52.010
刚才有一坨对不对

41:52.010 --> 41:52.650
在这里

41:52.650 --> 41:52.890
好

41:52.890 --> 41:54.810
然后再把它移动到它

41:55.370 --> 41:55.610
好

41:55.610 --> 41:57.210
然后再把它把什么

41:57.770 --> 41:59.290
B这个柱子上的东西

41:59.290 --> 42:00.890
经过A移动到了

42:00.890 --> 42:01.530
移动到C

42:02.650 --> 42:02.970
一个

42:04.890 --> 42:05.210
看一下

42:05.770 --> 42:06.490
是不是这样子

42:06.490 --> 42:07.290
是不是这个逻辑

42:07.290 --> 42:08.650
逻辑是不是这个逻辑

42:08.650 --> 42:10.010
你看一下这个运行出来

42:10.010 --> 42:11.130
这个运行出来是不是

42:11.130 --> 42:13.050
它运行的结构就是A到C嘛

42:13.050 --> 42:13.530
对不对

42:13.610 --> 42:14.730
那么这个运行的结构呢

42:14.730 --> 42:15.850
是不是就是A到B

42:15.850 --> 42:16.250
对不对

42:16.970 --> 42:17.450
没问题吧

42:18.010 --> 42:20.330
这个运行的结构是不是A到B

42:20.970 --> 42:22.330
你把一个函数传进去嘛

42:22.330 --> 42:23.450
A传到A

42:23.450 --> 42:24.250
C传到B

42:24.250 --> 42:25.050
B传到C

42:25.050 --> 42:26.330
那么B传到C是不是就

42:26.330 --> 42:27.530
这里输出就是A到B

42:28.170 --> 42:28.410
好

42:28.410 --> 42:31.690
那这里输出是不是就是A到B到什么

42:31.690 --> 42:32.250
B到C

42:32.810 --> 42:33.690
那是不是A到B

42:33.690 --> 42:34.890
A到C B到C

42:34.890 --> 42:35.530
是不是出来了

42:36.650 --> 42:36.890
好

42:36.890 --> 42:38.090
这是两个柱子

42:38.090 --> 42:39.130
两个块儿

42:39.130 --> 42:40.650
那么三个块儿呢

42:40.650 --> 42:41.850
是一样的道理了

42:42.730 --> 42:44.090
三个块儿是一样的道理

42:44.890 --> 42:45.130
好

42:45.130 --> 42:46.010
看一下啊

42:46.010 --> 42:46.570
三个块儿

42:49.800 --> 42:50.440
三个块儿呢

42:50.440 --> 42:51.000
是这样子

42:51.720 --> 42:53.400
先把上面这一块儿呢

42:53.400 --> 42:54.520
想成一个整体

42:54.520 --> 42:56.200
想办法把它移到这边

42:56.200 --> 42:56.600
对吧

42:56.600 --> 42:58.120
把这个整体移到这边

42:58.840 --> 43:00.040
所以后边就好简单了

43:00.920 --> 43:02.040
把这个整体移到这边

43:03.960 --> 43:04.040
好

43:04.040 --> 43:05.720
我们这样子把一面缩小一下

43:06.520 --> 43:07.320
这样的便于分析

43:08.920 --> 43:09.480
好

43:09.480 --> 43:09.960
F

43:09.960 --> 43:11.960
这个情况就是还是不一样的

43:12.040 --> 43:12.520
F

43:12.520 --> 43:13.320
A

43:13.320 --> 43:14.360
C

43:14.360 --> 43:15.480
B

43:15.480 --> 43:16.120
2

43:16.120 --> 43:16.520
对不对

43:17.240 --> 43:18.680
把上面两个柱子

43:18.680 --> 43:19.800
把上面两个柱子

43:19.800 --> 43:20.360
这个东西

43:21.000 --> 43:21.640
移动到哪

43:21.640 --> 43:22.280
移动到B

43:22.280 --> 43:22.680
对吧

43:22.680 --> 43:23.560
把A移动到B

43:23.560 --> 43:25.160
经过C来进行辅助

43:25.160 --> 43:26.040
把A移动到B

43:26.600 --> 43:26.680
好

43:26.680 --> 43:27.480
那你去移动吧

43:27.480 --> 43:28.680
总之你把完成就行了

43:29.080 --> 43:30.200
我不管你怎么去完成

43:30.200 --> 43:31.480
把完成就行了

43:31.480 --> 43:31.960
然后呢

43:31.960 --> 43:33.720
假设已经全部移过来了

43:33.720 --> 43:35.240
假设这一块儿已经全部移过来了

43:35.240 --> 43:36.200
那咱们移一次嘛

43:36.200 --> 43:37.400
最终的结果就是这样子

43:37.800 --> 43:38.360
就这样子

43:40.360 --> 43:41.000
对吧

43:41.000 --> 43:41.720
全部移过来了

43:41.960 --> 43:43.560
那么剩下的事情是不是一样了

43:43.560 --> 43:44.360
对吧

43:44.360 --> 43:44.920
一样了

43:44.920 --> 43:46.520
什么A到C

43:46.520 --> 43:47.560
然后呢

43:47.560 --> 43:48.360
就A到C

43:49.240 --> 43:49.960
然后呢

43:49.960 --> 43:51.480
再把B上面移过来对吧

43:51.480 --> 43:52.520
再把B上面移过来

43:55.510 --> 43:56.310
F

43:56.310 --> 43:57.190
怎么B

43:58.390 --> 44:00.390
要通过A这个柱子移动到C

44:01.830 --> 44:02.710
移动几个两个

44:05.380 --> 44:06.660
还用继续说吗

44:06.660 --> 44:07.540
还需要继续说

44:08.740 --> 44:09.780
不用继续举例了吧

44:10.500 --> 44:11.460
这里是啥

44:11.460 --> 44:12.100
N

44:12.100 --> 44:12.740
这里是啥

44:12.740 --> 44:13.940
N-1

44:13.940 --> 44:14.420
这里是啥

44:15.380 --> 44:16.260
N-1

44:17.620 --> 44:19.300
特别特别恐怖

44:19.300 --> 44:20.260
这个代码

44:20.260 --> 44:21.060
好看一下

44:22.900 --> 44:24.100
你看我们这里可以这样子写

44:27.210 --> 44:28.810
如果N等于1

44:29.450 --> 44:30.650
非常简单

44:30.650 --> 44:32.170
直接返回是吗

44:32.170 --> 44:32.810
直接返回

44:35.450 --> 44:36.970
Number1这个柱子的编号

44:37.450 --> 44:38.250
移动到哪

44:38.250 --> 44:38.810
移动到

44:41.130 --> 44:42.810
Number2这个柱子的编号

44:42.810 --> 44:44.330
Number3这个柱子的编号

44:44.330 --> 44:45.530
直接移动就完成了

44:45.690 --> 44:46.650
如果是一个柱子的话

44:46.650 --> 44:47.210
对吧

44:47.210 --> 44:50.250
直接这个编号移动到这个编号

44:51.290 --> 44:52.090
好

44:52.090 --> 44:54.890
其他情况分三步完成

44:54.890 --> 44:56.010
分三步

44:56.010 --> 44:56.810
不是绝腾

44:56.810 --> 44:57.290
直接输出

44:57.290 --> 44:58.490
输出

44:58.490 --> 44:58.890
console

45:00.490 --> 45:01.130
log

45:01.130 --> 45:01.530
输出

45:04.330 --> 45:04.570
好

45:05.370 --> 45:05.850
L

45:07.210 --> 45:08.410
如果N不等于1

45:08.410 --> 45:09.530
就是大于1的情况

45:09.530 --> 45:10.010
干嘛呢

45:10.010 --> 45:10.730
所以分三步

45:11.450 --> 45:12.170
复制过来

45:12.170 --> 45:12.890
这些复制过来

45:14.490 --> 45:15.050
分三步

45:16.250 --> 45:16.730
判诺

45:17.850 --> 45:18.330
这里呢

45:19.050 --> 45:19.690
A是啥

45:19.690 --> 45:20.970
A4就是Number1嘛

45:21.770 --> 45:22.570
C是啥

45:22.570 --> 45:23.690
Number3

45:23.690 --> 45:24.250
B是啥

45:24.250 --> 45:24.650
Number2

45:25.930 --> 45:26.490
N-1

45:27.210 --> 45:27.450
好

45:27.450 --> 45:27.930
这里

45:27.930 --> 45:28.410
判诺

45:29.290 --> 45:29.850
这里是啥

45:29.850 --> 45:30.330
B是啥

45:30.330 --> 45:31.290
Number2

45:31.290 --> 45:31.850
A是啥

45:31.850 --> 45:32.570
Number1

45:32.570 --> 45:33.530
C是啥

45:33.530 --> 45:34.010
Number3

45:34.570 --> 45:35.130
N-1

45:35.770 --> 45:36.090
好

45:36.090 --> 45:37.210
然后这边

45:37.210 --> 45:37.930
直接输出

45:37.930 --> 45:38.970
Number1到NumberC

45:38.970 --> 45:39.290
对吧

45:39.290 --> 45:40.410
Number1到NumberC

45:40.410 --> 45:41.210
Number3

45:41.210 --> 45:41.770
输出

45:41.770 --> 45:42.170
log

45:45.420 --> 45:46.220
Number1

45:47.020 --> 45:50.140
到Number3

45:50.140 --> 45:51.020
写完了

45:51.900 --> 45:52.620
就写完了

45:53.660 --> 45:55.260
这么复杂的一个东西

45:55.260 --> 45:56.780
几句代码全部写完

45:56.780 --> 45:58.780
这就是地轨它恐怖的地方

45:58.780 --> 46:00.060
它喧的地方

46:00.060 --> 46:00.700
好

46:00.700 --> 46:01.260
咱们来看一下

46:01.260 --> 46:02.460
两根柱子

46:02.460 --> 46:04.060
是不是我们要找到结果

46:05.740 --> 46:05.980
好

46:05.980 --> 46:06.300
看一下

46:08.300 --> 46:09.580
刚才给你不应该关

46:09.580 --> 46:10.140
不应该关

46:10.140 --> 46:10.540
留着吧

46:10.540 --> 46:11.420
我们一会测试

46:11.420 --> 46:12.140
好

46:12.140 --> 46:12.780
两个柱子

46:12.780 --> 46:13.420
看着

46:13.420 --> 46:14.780
得到的结果是啥

46:14.780 --> 46:16.140
A到B

46:16.380 --> 46:17.260
A到C

46:17.260 --> 46:18.300
B到C

46:18.300 --> 46:19.340
看一下

46:19.340 --> 46:19.980
A到B

46:21.020 --> 46:21.660
A到C

46:23.340 --> 46:24.700
然后是什么

46:24.700 --> 46:25.260
B到C

46:26.860 --> 46:27.260
等一下

46:27.260 --> 46:27.660
有问题

46:27.660 --> 46:28.620
有问题

46:28.620 --> 46:29.180
我看一下

46:31.740 --> 46:32.780
刚才应该分析到有问题

46:32.780 --> 46:34.060
刚才哪个地方分析到有问题

46:36.860 --> 46:37.500
两根柱子

46:37.980 --> 46:38.540
独根柱子

46:39.580 --> 46:40.220
是什么呢

46:40.220 --> 46:43.340
是把上面这个A通过C

46:43.340 --> 46:43.980
移动到B

46:44.460 --> 46:45.020
移动到B

46:45.980 --> 46:46.460
哦

46:46.460 --> 46:47.580
这是三根柱子

46:47.580 --> 46:48.540
我这里是两根柱子

46:49.340 --> 46:49.980
两根柱子

46:50.940 --> 46:51.580
看一下

46:51.580 --> 46:52.140
两根柱子

46:52.140 --> 46:52.460
看一下

46:55.700 --> 46:56.340
两根柱子

46:56.980 --> 46:57.620
不一样的

46:57.620 --> 46:58.100
不一样的

46:59.060 --> 46:59.140
好

46:59.140 --> 47:00.020
两根柱子

47:00.020 --> 47:00.820
我这边怎么说的

47:00.820 --> 47:01.380
你就怎么移动

47:01.380 --> 47:02.100
对吧

47:02.100 --> 47:03.220
两根柱子

47:03.220 --> 47:03.780
A到B

47:03.780 --> 47:04.340
A到C

47:04.340 --> 47:04.980
B到C

47:04.980 --> 47:05.460
A到B

47:06.340 --> 47:07.220
是吧

47:07.220 --> 47:07.780
A到B

47:07.780 --> 47:08.420
A到C

47:08.420 --> 47:09.300
A到B

47:09.300 --> 47:10.340
A到C

47:10.340 --> 47:10.900
B到C

47:10.900 --> 47:11.300
是完了

47:11.940 --> 47:12.900
两根柱子就完了

47:12.900 --> 47:13.140
好

47:13.140 --> 47:13.700
三根柱子

47:14.900 --> 47:15.700
保存

47:15.700 --> 47:15.860
好

47:15.860 --> 47:16.180
这边

47:16.820 --> 47:17.140
看一下

47:17.140 --> 47:17.540
三根柱子

47:18.420 --> 47:18.740
这边

47:18.740 --> 47:19.220
我们还会改

47:20.420 --> 47:20.900
三根柱子

47:20.900 --> 47:21.700
这传一个三就行了

47:22.340 --> 47:22.740
保存

47:23.300 --> 47:23.620
好

47:23.620 --> 47:24.340
它这样移动的

47:24.340 --> 47:24.820
A到C

47:24.820 --> 47:25.220
A到B

47:25.220 --> 47:25.700
C到B

47:26.260 --> 47:27.380
A C A B C B

47:28.020 --> 47:32.340
A C A B C B C B

47:33.540 --> 47:33.780
好

47:33.780 --> 47:34.100
你看

47:34.980 --> 47:35.700
然后呢

47:35.700 --> 47:37.300
A C B A B C

47:37.300 --> 47:38.500
A C B A B C

47:39.060 --> 47:42.020
A C B A B C

47:42.820 --> 47:43.220
然后呢

47:43.220 --> 47:43.860
最后

47:43.860 --> 47:44.260
A C

47:45.220 --> 47:45.860
对吧

47:45.860 --> 47:46.900
这就移动完了

47:47.460 --> 47:48.180
这就是地规

47:48.180 --> 47:49.060
它强大的地方

47:49.060 --> 47:50.180
你不用去细想

47:50.180 --> 47:51.460
这个程序到底是怎么执行的

47:51.460 --> 47:52.980
我们之前已经讲过了执行站

47:52.980 --> 47:54.180
它是可以正常执行的

47:54.180 --> 47:54.660
OK

47:54.660 --> 47:55.860
那你就搞定就行了

47:55.860 --> 47:56.820
它又没有终止条件

47:56.820 --> 47:57.860
终止条件就是这个

47:57.860 --> 47:58.340
对吧

47:58.340 --> 47:59.140
终止条件就是这个

47:59.140 --> 48:00.580
它也不会导致无限地规

48:00.580 --> 48:02.180
那么这就很恐怖了

48:02.980 --> 48:03.460
你可以

48:04.020 --> 48:04.740
用地规

48:04.740 --> 48:06.340
可以写出一个非常复杂的程序

48:06.340 --> 48:06.980
可以解决

48:06.980 --> 48:08.100
用几个代码就解决了

48:08.580 --> 48:09.860
这是关于地规

48:11.140 --> 48:11.940
最后呢

48:11.940 --> 48:12.980
我补充一个知识

48:12.980 --> 48:14.180
补充一个知识

48:14.660 --> 48:16.340
就是关于伪地规

48:17.140 --> 48:17.940
伪地规

48:19.300 --> 48:20.580
这个了解就行了

48:20.580 --> 48:21.540
了解就行了

48:21.540 --> 48:22.420
伪地规

48:23.220 --> 48:24.260
它什么意思呢

48:24.260 --> 48:25.060
它指的是

48:25.940 --> 48:28.740
如果一个函数

48:28.740 --> 48:30.900
最后一条指形语句

48:30.900 --> 48:32.740
最后一条语句

48:35.380 --> 48:38.260
是雕用另外一个函数

48:38.260 --> 48:39.300
是雕用函数

48:39.780 --> 48:41.300
最后一条语句是雕用函数

48:41.300 --> 48:42.180
比方说像这里

48:43.140 --> 48:44.500
这里最后一条语句

48:44.500 --> 48:45.620
这个函数指形过后

48:45.620 --> 48:46.820
除了n等于1的情况

48:46.820 --> 48:47.220
对吧

48:47.220 --> 48:48.500
n大于1的情况下

48:48.500 --> 48:49.380
它是不是最后一条语句

48:49.380 --> 48:50.180
是雕用函数

48:50.180 --> 48:50.500
对吧

48:50.500 --> 48:51.220
是雕用函数

48:52.340 --> 48:54.260
最后一条语句是雕用函数

48:54.260 --> 48:58.740
并且雕用函数

48:58.740 --> 48:59.700
不是

48:59.700 --> 49:02.820
不是表达式的一部分

49:04.020 --> 49:05.940
则该函数

49:07.940 --> 49:10.500
称之为伪地规

49:11.460 --> 49:12.580
伪地规

49:12.580 --> 49:14.180
看一下我们之前写的代码

49:14.180 --> 49:15.300
是不是伪地规

49:15.300 --> 49:16.180
它不是伪地规

49:18.260 --> 49:20.020
看下这一块

49:20.580 --> 49:22.420
这一块倒是一个伪地规

49:22.420 --> 49:23.620
这一块是一个伪地规

49:23.620 --> 49:26.020
它最后一个表达式是一个函数

49:26.020 --> 49:27.460
而且这个函数本身

49:27.460 --> 49:29.380
不是一个表达式的一部分

49:29.380 --> 49:30.420
比方说这里

49:30.420 --> 49:31.540
这里是不是一个伪地规

49:31.540 --> 49:32.180
这里就不是

49:32.740 --> 49:33.620
这里就不是

49:33.620 --> 49:35.620
它最后一行是一个函数雕用函数字身

49:35.620 --> 49:36.180
对吧

49:36.180 --> 49:37.780
但是它是一个表达式的一部分

49:37.780 --> 49:38.100
你看

49:38.100 --> 49:39.620
这是整个表达式的一部分

49:39.700 --> 49:40.660
它不是一个伪地规

49:40.660 --> 49:41.460
那这样子写的话

49:41.460 --> 49:42.500
就是一个伪地规

49:42.500 --> 49:43.460
明白这个意思吧

49:43.460 --> 49:45.300
最后一行

49:45.300 --> 49:46.980
它一定是一个函数雕用

49:46.980 --> 49:48.100
就是雕用自己

49:48.100 --> 49:51.140
并且它不是表达式的一部分

49:51.140 --> 49:52.420
那么这个情况

49:52.420 --> 49:54.340
就是一个伪地规

49:55.540 --> 49:57.220
那么伪地规有什么特点呢

49:57.220 --> 49:58.980
伪地规它是有特殊的

49:58.980 --> 50:02.980
某些语言或执行环境

50:03.780 --> 50:08.420
会对伪地规进行优化

50:10.020 --> 50:17.460
防止它们会立即销毁当前函数

50:17.460 --> 50:20.260
它会立即销毁当前函数

50:20.260 --> 50:25.860
避免执行站空间被占用

50:25.860 --> 50:27.460
也就是很多语言它都有执行站的

50:27.460 --> 50:28.900
不光是介石

50:28.900 --> 50:30.820
避免执行站空间被占用

50:30.820 --> 50:31.620
那么这样子

50:31.620 --> 50:35.140
哪怕可能你写了一个很多成绩的地规

50:35.140 --> 50:37.380
它执行站空间都非常非常少

50:37.380 --> 50:38.740
占用的非常非常少

50:38.820 --> 50:39.860
它会怎么优化呢

50:39.860 --> 50:40.740
举个例子

50:42.020 --> 50:43.460
比方说这一块

50:43.460 --> 50:45.540
这个阶层

50:45.540 --> 50:46.420
它不是一个伪地规

50:46.420 --> 50:46.580
对吧

50:46.580 --> 50:48.180
它不是一个伪地规

50:48.180 --> 50:49.860
因为它会是这样子写的

50:49.860 --> 50:53.540
我们现在把它编成一个伪地规的形式

50:53.540 --> 50:54.660
看一下这个伪地规呢

50:54.660 --> 50:55.700
该怎么来写

50:55.700 --> 50:57.300
就是伪地规还一定要保证

50:57.300 --> 50:58.820
它最后一行的函数雕用

50:58.820 --> 51:00.340
一定不能是一个

51:01.860 --> 51:04.420
函数在表达式的这种情况

51:04.420 --> 51:05.300
你可以函数雕用

51:05.300 --> 51:07.860
但是你不能是表达式的一部分

51:07.940 --> 51:09.140
表达式的一部分的话

51:09.140 --> 51:12.260
它没有办法进行伪地规优化

51:12.260 --> 51:12.420
好

51:12.420 --> 51:13.300
我们来看一下

51:13.300 --> 51:15.220
这个东西怎么来把它变成伪地规

51:15.220 --> 51:15.940
我们可以这样做

51:17.780 --> 51:19.860
我们这里再加个函数

51:19.860 --> 51:20.820
我说先写吧

51:20.820 --> 51:21.620
先写了再说

51:22.740 --> 51:24.340
这里反而会透透

51:25.380 --> 51:27.140
这里换一个表达式

51:28.180 --> 51:29.860
fn-1

51:30.500 --> 51:31.220
就是伪地规的

51:31.220 --> 51:34.100
它代码理解上就没有那么好理解了

51:34.100 --> 51:35.460
就没有那么好理解了

51:35.460 --> 51:37.700
但是它能够优化

51:37.780 --> 51:38.660
它能够优化

51:39.780 --> 51:40.740
n-1

51:40.740 --> 51:41.460
透透

51:42.500 --> 51:43.460
这样子可以的

51:43.460 --> 51:44.260
可以的

51:44.260 --> 51:44.820
看一下

51:48.840 --> 51:49.480
等一下

51:49.480 --> 51:50.760
哪个地方写错了

51:50.760 --> 51:52.040
这里还差一个函数

51:52.040 --> 51:52.280
对吧

51:52.280 --> 51:53.240
差一个函数

51:53.240 --> 51:53.880
5的阶层

51:54.920 --> 51:56.280
5的阶层120

51:56.280 --> 51:57.240
是可以的

51:57.240 --> 51:58.520
那这个什么意思呢

51:58.520 --> 51:59.240
它是这样子

51:59.240 --> 52:01.160
它现在的做法就不太一样了

52:02.200 --> 52:03.480
因为我要用伪地规

52:03.480 --> 52:05.000
我要保证最后一句话

52:05.720 --> 52:07.000
程序的最后一句话

52:07.000 --> 52:08.520
它是一个函数雕用

52:08.520 --> 52:09.560
但是这个函数雕用

52:09.560 --> 52:11.000
它不能是一个表达式的一部分

52:11.000 --> 52:12.600
你这里不能去加一个什么东西

52:12.600 --> 52:13.400
乘一个东西

52:13.400 --> 52:14.280
什么东西不行

52:14.280 --> 52:14.920
是不行的

52:15.640 --> 52:17.320
它只能是一个纯粹的函数雕用

52:18.040 --> 52:18.120
好

52:18.120 --> 52:19.480
咱们来先理解一下

52:19.480 --> 52:20.680
这个为什么是可以的

52:20.680 --> 52:21.640
是可以的

52:21.640 --> 52:23.160
它第二个参数是什么意思呢

52:23.160 --> 52:24.680
第二参数是哪层的结果

52:25.240 --> 52:26.440
就是不断的哪层

52:26.440 --> 52:27.080
不断的哪层

52:27.080 --> 52:27.480
对吧

52:27.480 --> 52:30.120
5的阶层是不是不断的哪层

52:30.120 --> 52:30.680
对吧

52:30.680 --> 52:31.880
5×1是

52:31.880 --> 52:33.400
然后把这个5×1是呢

52:33.400 --> 52:34.280
再去跟什么

52:34.280 --> 52:36.040
5×1三相乘

52:36.040 --> 52:36.920
然后再去跟

52:37.000 --> 52:37.560
不

52:37.560 --> 52:39.480
把这个5×14的结果

52:39.480 --> 52:40.760
把这个5×14的结果

52:40.760 --> 52:42.520
结果再去跟啥相乘

52:42.520 --> 52:43.640
跟3相乘

52:43.640 --> 52:43.880
对吧

52:43.880 --> 52:45.240
它是用按这种方式来看的

52:45.720 --> 52:46.360
你要这个意思吧

52:47.480 --> 52:48.200
然后呢

52:48.200 --> 52:49.720
把前面这一坨乘出来过后

52:49.720 --> 52:51.160
再去跟2相乘

52:51.160 --> 52:52.840
然后把前面这一坨乘出来过后

52:52.840 --> 52:53.240
最后呢

52:53.240 --> 52:54.680
去跟1相乘

52:54.680 --> 52:55.960
是这么个意思

52:55.960 --> 52:57.400
它现在是用这种逻辑来做的

52:58.120 --> 52:59.800
逻辑现在都不太一样了

52:59.800 --> 53:00.920
因为它为了实现伪定

53:00.920 --> 53:02.280
必须要去牺牲一部分

53:03.480 --> 53:04.520
就是用一部分代价来

53:05.240 --> 53:06.120
作为交换

53:06.200 --> 53:06.760
怎么代价呢

53:06.760 --> 53:08.440
就是程序的可理解性

53:08.440 --> 53:10.440
现在就没有刚才那么好理解了

53:10.440 --> 53:12.040
我们来说一下这个地方

53:12.040 --> 53:13.240
比方说

53:13.240 --> 53:15.800
目前我传的是F51对吧

53:15.800 --> 53:17.080
F51

53:17.080 --> 53:17.640
好看着

53:17.640 --> 53:18.760
它是目前是这样子算的

53:20.600 --> 53:21.400
它等于啥呢

53:21.400 --> 53:25.960
是不是等于F45对不对

53:25.960 --> 53:26.920
它反回的是啥

53:26.920 --> 53:28.040
反回的是n-1

53:28.040 --> 53:28.920
n乘以偷拓

53:28.920 --> 53:30.600
偷拓是1对不对

53:30.600 --> 53:31.960
等于F45

53:33.640 --> 53:34.120
一开始呢

53:34.120 --> 53:35.080
这个1没问题吧

53:35.080 --> 53:35.560
放在这

53:35.720 --> 53:36.760
就把5放进去

53:36.760 --> 53:38.600
5是目前的累成结果

53:39.400 --> 53:39.720
然后呢

53:39.720 --> 53:41.080
又求4的阶层

53:41.080 --> 53:42.280
4的阶层等于啥

53:42.280 --> 53:44.680
等于5成义

53:44.680 --> 53:45.320
5成义

53:45.320 --> 53:47.080
就是5之前的累计结果

53:47.080 --> 53:47.880
乘以4

53:47.880 --> 53:49.320
之前的累计结果乘以4

53:49.960 --> 53:50.600
然后呢

53:50.600 --> 53:51.720
求什么4的阶层

53:51.720 --> 53:52.120
对吧

53:52.120 --> 53:52.920
45

53:52.920 --> 53:53.720
把之前的

53:53.720 --> 53:55.240
之前累成的结果告诉你

53:55.240 --> 53:56.120
它等于啥呢

53:56.120 --> 53:58.360
等于F3乘以20

53:58.840 --> 53:59.160
对不对

53:59.960 --> 54:01.080
那么相当于是啥呢

54:01.080 --> 54:01.720
相当于是

54:02.600 --> 54:03.720
求3的阶层

54:04.680 --> 54:07.160
再加上一个累计

54:07.160 --> 54:08.520
之前的累计只20

54:08.520 --> 54:09.320
比方说5的阶层

54:09.320 --> 54:11.880
5乘以4乘以3乘以2乘以1

54:11.880 --> 54:13.240
就没思想那么好理解了

54:13.960 --> 54:15.080
先求啥呢

54:15.080 --> 54:16.120
先求的是5

54:16.120 --> 54:16.360
对吧

54:16.360 --> 54:17.320
累计的结果是5

54:17.320 --> 54:18.280
1乘以5等于5嘛

54:18.920 --> 54:20.520
然后把5去乘以什么

54:20.520 --> 54:21.160
4的阶层

54:21.320 --> 54:21.800
对吧

54:21.800 --> 54:22.600
4的阶层

54:22.600 --> 54:23.000
看

54:23.000 --> 54:24.920
把5去乘以4的阶层

54:24.920 --> 54:25.720
是这么个意思

54:25.720 --> 54:27.640
把1去乘以5的阶层

54:27.640 --> 54:28.760
是这么个意思

54:28.760 --> 54:29.960
5去乘以4的阶层

54:30.680 --> 54:33.160
然后5去乘以4的阶层

54:33.160 --> 54:34.200
等于啥呢

54:34.200 --> 54:35.400
等于

54:35.400 --> 54:37.720
20乘以3的阶层

54:37.720 --> 54:38.760
因为把5乘以4

54:38.760 --> 54:40.120
就把这一部分乘起来

54:40.120 --> 54:40.520
对吧

54:40.520 --> 54:42.200
把之前的累计结果

54:42.200 --> 54:43.720
乘以现在这个数

54:43.720 --> 54:45.400
它这样子导致来的

54:45.400 --> 54:47.000
把这一部分乘起来

54:47.000 --> 54:48.520
然后乘以3的阶层

54:48.520 --> 54:49.320
看没有

54:49.320 --> 54:50.440
然后呢

54:50.440 --> 54:52.120
这里是

54:52.120 --> 54:54.440
3的阶层

54:54.440 --> 54:55.880
之前的累计结果是20

54:55.880 --> 54:57.000
然后又等于什么呢

54:57.000 --> 54:59.000
2的阶层乘以60

54:59.640 --> 55:00.360
没问题吧

55:00.360 --> 55:02.760
又是把之前的累计结果20

55:02.760 --> 55:04.200
又去乘以现在这个数3

55:04.200 --> 55:05.320
把这一部分求出来

55:05.320 --> 55:07.320
然后又去乘以这一部分的阶层

55:07.320 --> 55:10.120
然后F260

55:10.120 --> 55:11.240
又等于啥呢

55:11.240 --> 55:13.080
它又等于

55:13.080 --> 55:15.480
F1120

55:15.480 --> 55:16.120
对吧

55:16.120 --> 55:18.280
那又是把前面这部分乘起来

55:18.280 --> 55:21.160
用2去乘以之前的累计结果

55:21.160 --> 55:23.240
60

55:23.240 --> 55:23.800
然后呢

55:23.800 --> 55:25.240
又去乘以1的阶层

55:25.240 --> 55:26.920
1的阶层就是解除条件了

55:26.920 --> 55:27.480
解除条件

55:27.560 --> 55:30.040
直接把之前的累计结果返回就行了

55:30.040 --> 55:31.720
它是用这么一种模式来做

55:31.720 --> 55:33.320
当然你可不可以再封装一下

55:33.320 --> 55:34.920
再写个函数把封装一下

55:34.920 --> 55:36.760
这个地方我们把换一个名字

55:36.760 --> 55:37.720
F helper

55:37.720 --> 55:38.600
你这样子

55:38.600 --> 55:40.040
调用的时候很不方便

55:40.040 --> 55:41.880
调用的时候要传个1就很不方便

55:41.880 --> 55:43.400
我们可以把封装一下

55:43.400 --> 55:43.800
然后呢

55:43.800 --> 55:45.800
这边写一个Fn

55:45.800 --> 55:46.840
这里返回啥呢

55:46.840 --> 55:48.680
F helper

55:48.680 --> 55:50.920
n-1

55:50.920 --> 55:52.280
来呗

55:52.280 --> 55:53.720
n1对吧

55:53.720 --> 55:54.280
返回这个

55:54.280 --> 55:56.440
那么我们这里就可以直接写5了

55:56.520 --> 55:58.040
可以把稍微封装一下

55:58.040 --> 55:59.640
封装一下

55:59.640 --> 56:01.240
为什么要这样子写呢

56:01.240 --> 56:01.880
这样子写了

56:01.880 --> 56:03.720
它有一个伪地规的优化

56:03.720 --> 56:05.560
你看一下它怎么来优化的

56:05.560 --> 56:06.840
比方说就F5

56:06.840 --> 56:08.280
就F5

56:08.280 --> 56:09.560
那么我们来看一下执行站

56:09.560 --> 56:11.880
首先它是一个全聚的全聚环境

56:11.880 --> 56:13.960
然后运行什么F5

56:13.960 --> 56:15.880
我们这里先这样子吧

56:15.880 --> 56:17.800
F helper

56:17.800 --> 56:19.080
F helper

56:19.080 --> 56:20.120
或者就F5吧

56:20.120 --> 56:21.080
无所谓

56:21.080 --> 56:22.520
F5

56:22.520 --> 56:23.640
这是个辅助函数

56:23.640 --> 56:24.440
它是个辅助函数

56:24.440 --> 56:25.080
它无所谓的

56:25.080 --> 56:26.360
它有没有都无所谓

56:26.840 --> 56:27.480
F5呢

56:27.480 --> 56:28.520
我们这里运行一个

56:30.360 --> 56:33.480
环境就是F5

56:33.480 --> 56:35.480
F5这个环境

56:35.480 --> 56:37.080
接下来

56:37.080 --> 56:39.720
那么它里面就得到军运行啥

56:39.720 --> 56:41.880
运行F helper

56:41.880 --> 56:43.400
其实它这个地方也是一个优化

56:43.400 --> 56:44.280
它也会优化的

56:45.880 --> 56:47.080
在最后一行

56:47.080 --> 56:48.760
如果是调用自身的函数的话

56:48.760 --> 56:49.960
叫做伪地规

56:49.960 --> 56:50.600
最后一行

56:50.600 --> 56:51.800
如果是调用别的函数

56:51.800 --> 56:53.000
也不代表它室内的话

56:53.000 --> 56:54.360
叫做伪调用

56:54.360 --> 56:56.200
叫做伪调用

56:56.280 --> 56:57.160
这样子意思吧

56:57.160 --> 56:58.760
那这样子说吧

57:00.040 --> 57:02.120
如果函数的最后一条是调用函数

57:02.120 --> 57:02.840
而调用函数呢

57:02.840 --> 57:03.960
不是表达世界一部分

57:03.960 --> 57:04.920
这该函数的

57:04.920 --> 57:07.080
这种这该语句

57:07.080 --> 57:08.360
该语句

57:08.360 --> 57:10.920
称为伪调用

57:10.920 --> 57:12.200
伪调用

57:13.400 --> 57:18.360
如果伪调用是调用自身

57:18.360 --> 57:20.520
是调用自身函数

57:20.520 --> 57:23.400
则称为伪地规

57:23.400 --> 57:24.360
伪地规

57:24.360 --> 57:25.560
那么其实伪调用

57:25.640 --> 57:27.400
都会进行伪调用

57:28.840 --> 57:30.280
伪调用会进行伪调用

57:30.840 --> 57:31.160
好

57:31.160 --> 57:32.280
咱们来看这边

57:32.280 --> 57:33.320
再回过头来看这边

57:34.360 --> 57:35.720
这里其实也会伪调

57:35.720 --> 57:36.760
也会伪调

57:36.760 --> 57:37.320
好

57:37.320 --> 57:38.040
fn

57:38.920 --> 57:41.000
他发现了函数的最后一句

57:41.000 --> 57:41.880
是调用一个函数

57:41.880 --> 57:42.200
对吧

57:42.200 --> 57:43.880
他只有调用函数没别的了

57:43.880 --> 57:44.760
他就把函数调用

57:44.760 --> 57:45.320
结果返回

57:45.320 --> 57:46.360
他就没别的了

57:46.360 --> 57:47.720
于是他会做这么一件事

57:47.720 --> 57:48.920
进行伪调用

57:49.240 --> 57:50.440
直接把这个

57:50.440 --> 57:51.640
一看一下

57:51.640 --> 57:53.000
本来是应该是这样子

57:53.000 --> 57:54.040
本来应该是

57:54.040 --> 57:55.480
创建一个执行环境

57:55.480 --> 57:56.680
fhelper

57:56.680 --> 57:58.680
然后把五传进去

57:58.680 --> 57:59.320
一传进去

57:59.320 --> 57:59.720
对吧

57:59.720 --> 58:01.480
本来是应该做这件事的

58:01.480 --> 58:04.120
但是他发现这是一个伪调用

58:04.120 --> 58:05.240
伪调用

58:05.240 --> 58:06.360
于是他认为

58:06.360 --> 58:07.560
他是这么想的

58:07.560 --> 58:09.400
你这个函数运行结束过后

58:09.400 --> 58:10.360
这个函数已经没有

58:10.360 --> 58:11.960
任何其他事情可以做了

58:11.960 --> 58:12.920
是这样的逻辑吧

58:13.640 --> 58:15.160
你这个函数如果运行完了

58:15.160 --> 58:17.000
那你这个函数还有其他事情可以做吗

58:17.000 --> 58:18.280
是没有任何事情可以做了

58:18.280 --> 58:19.560
他直接把这个函数的结果返回

58:19.560 --> 58:20.360
就完事了

58:20.360 --> 58:22.040
所以说他直接就把这个函数

58:22.040 --> 58:22.680
销毁掉了

58:23.320 --> 58:24.120
把这个放上来

58:24.680 --> 58:25.960
他直接给你销毁掉

58:26.520 --> 58:27.400
是这么个意思

58:27.400 --> 58:28.440
那么5

58:28.440 --> 58:29.080
5

58:29.080 --> 58:29.640
1

58:29.640 --> 58:30.600
这个函数调用5

58:30.600 --> 58:31.240
1对吧

58:31.240 --> 58:32.440
那么他会运行啥

58:32.440 --> 58:34.280
运行4

58:34.280 --> 58:34.920
5

58:34.920 --> 58:35.960
他会运行这个

58:37.320 --> 58:37.560
4

58:37.560 --> 58:37.720
5

58:38.920 --> 58:40.200
他会运行这个

58:40.200 --> 58:41.640
本来应该是这样子的

58:41.640 --> 58:42.680
但他发现了

58:42.680 --> 58:43.880
这个函数调用已经是

58:43.880 --> 58:44.760
最后一条语句了

58:44.760 --> 58:46.360
并且他不再表达是里边

58:46.360 --> 58:47.480
他这个函数运行完了过后

58:47.480 --> 58:49.080
不需要经过任何运运算

58:49.080 --> 58:51.240
不需要经过任何后续的运算

58:51.240 --> 58:52.680
他已经是最后一条语句了

58:52.680 --> 58:53.560
于是他觉得

58:54.200 --> 58:55.080
可以优化

58:55.080 --> 58:56.920
于是上面的环境直接消失

58:56.920 --> 58:58.680
你直接把这个结构返回就行了

58:58.680 --> 58:59.880
直接把这个结构返回

58:59.880 --> 59:01.000
就完事了

59:01.000 --> 59:01.320
好

59:01.320 --> 59:01.960
4 5

59:01.960 --> 59:03.000
他又变成了什么

59:03.000 --> 59:04.040
3

59:04.040 --> 59:05.160
3

59:05.160 --> 59:05.720
20

59:05.720 --> 59:06.280
对吧

59:06.280 --> 59:06.680
好

59:06.680 --> 59:07.720
他同样的道理

59:07.720 --> 59:08.760
这个消失

59:08.760 --> 59:09.560
你看執行站

59:09.560 --> 59:10.760
他就非常干净了

59:10.760 --> 59:12.760
他不会出现一大堆執行站出来

59:12.760 --> 59:14.680
这个意思吧

59:14.680 --> 59:17.240
这就是伪地规和伪调用的优化

59:17.240 --> 59:18.680
伪调用都会优化的

59:19.480 --> 59:20.440
但是遗憾的是

59:21.560 --> 59:22.760
有一所遗憾的是

59:25.000 --> 59:26.120
在浏览器

59:26.120 --> 59:28.120
浏览器执行环境中

59:29.000 --> 59:31.480
环境中

59:32.840 --> 59:33.800
伪地规

59:33.800 --> 59:35.000
伪地规

59:35.640 --> 59:36.760
就是伪调用

59:37.720 --> 59:38.680
没有优化

59:38.680 --> 59:40.120
他没有优化的

59:40.120 --> 59:41.320
浏览器执行环境里面

59:41.320 --> 59:42.680
哪怕现在的v8引擎

59:43.160 --> 59:44.200
他是没有优化的

59:44.200 --> 59:44.920
没有优化的

59:44.920 --> 59:45.640
伪调用的

59:46.680 --> 59:48.280
但是在漏的环境中有

59:48.280 --> 59:49.640
以后你们会选漏的

59:49.640 --> 59:53.400
但在漏的届世环境中

59:54.840 --> 59:55.320
有

59:55.640 --> 59:56.200
优化

59:56.680 --> 59:57.400
所以现在

59:57.400 --> 59:58.840
在浏览器环境里面

59:58.840 --> 59:59.640
你写这些代码

59:59.640 --> 01:00:00.680
其实无所谓

01:00:00.920 --> 01:00:01.640
无所谓

01:00:01.640 --> 01:00:02.680
你要不要优化

01:00:02.680 --> 01:00:03.480
都无所谓

01:00:03.480 --> 01:00:04.280
那你可以优化吧

01:00:04.280 --> 01:00:05.080
你能优化的话

01:00:05.080 --> 01:00:05.800
就尽量优化

01:00:05.800 --> 01:00:06.920
但是我觉得无所谓了

01:00:06.920 --> 01:00:08.200
因为你优化过后的代码

01:00:08.200 --> 01:00:09.720
反而不太容易理解

01:00:09.720 --> 01:00:10.760
当然你要优化可以

01:00:10.760 --> 01:00:11.880
你可以这样的想

01:00:11.880 --> 01:00:12.680
他将来

01:00:12.680 --> 01:00:13.640
说不定将来有一天

01:00:13.640 --> 01:00:14.200
就可以

01:00:14.200 --> 01:00:15.720
他就对他进行优化了

01:00:16.360 --> 01:00:17.720
到时候那里代码就不用改了

01:00:17.720 --> 01:00:18.600
就可以直接执行

01:00:19.640 --> 01:00:20.440
这是关于这个

01:00:21.720 --> 01:00:22.760
伪地规优化

01:00:22.760 --> 01:00:23.640
了解一下就行了

01:00:24.120 --> 01:00:25.480
OK这是关于地规这一块

01:00:25.480 --> 01:00:26.200
地规这一块

01:00:26.200 --> 01:00:27.480
它在解决一些特别

01:00:27.480 --> 01:00:28.680
复杂的问题的时候

01:00:28.680 --> 01:00:29.400
它提供了一种

01:00:29.400 --> 01:00:30.600
非常巧妙的办法

01:00:31.160 --> 01:00:32.520
我们在实际开发中

01:00:32.520 --> 01:00:33.560
有的时候

01:00:33.560 --> 01:00:34.840
会有使用地规

01:00:34.840 --> 01:00:36.120
什么时候呢

01:00:36.120 --> 01:00:37.320
特别是这种时候

01:00:37.320 --> 01:00:38.200
就是你要

01:00:38.920 --> 01:00:40.840
特别是在文件处理的时候

01:00:40.840 --> 01:00:42.280
你要获取一个文

01:00:42.280 --> 01:00:43.080
你要获取一个

01:00:43.080 --> 01:00:44.120
比方说你要获取

01:00:44.120 --> 01:00:45.800
以后里面学到服务器端

01:00:45.800 --> 01:00:46.920
你要获取地盘的

01:00:48.040 --> 01:00:49.640
地盘的

01:00:50.200 --> 01:00:52.120
占用空间大小

01:00:52.680 --> 01:00:53.480
这个地盘占用了

01:00:53.480 --> 01:00:54.520
多少空间

01:00:54.520 --> 01:00:55.160
比方说以后

01:00:55.160 --> 01:00:56.280
你们要做这件事

01:00:56.840 --> 01:00:58.280
那你怎么做呢

01:00:58.280 --> 01:00:59.160
首先告诉你

01:00:59.640 --> 01:01:00.520
他没有给你提供

01:01:00.520 --> 01:01:01.880
某一个盘的占用空间

01:01:01.880 --> 01:01:02.760
他只给你提供了

01:01:02.760 --> 01:01:04.200
一个文件的占用空间

01:01:04.680 --> 01:01:06.120
那你就要把第一盘下面的

01:01:06.120 --> 01:01:07.080
所有文件夹

01:01:07.080 --> 01:01:08.200
纸文件夹找到

01:01:08.200 --> 01:01:08.840
这个可以找

01:01:09.480 --> 01:01:10.920
把它的纸文件夹找到

01:01:10.920 --> 01:01:11.400
对吧

01:01:11.400 --> 01:01:12.920
以及它的纸文件找到

01:01:12.920 --> 01:01:13.560
是吧

01:01:13.560 --> 01:01:14.680
我给大家提供一个思路

01:01:14.680 --> 01:01:16.680
找到纸文件

01:01:19.800 --> 01:01:21.160
占用空间求和

01:01:21.880 --> 01:01:23.000
占用空间求和

01:01:24.440 --> 01:01:26.280
空间求和

01:01:27.080 --> 01:01:27.560
好

01:01:27.560 --> 01:01:29.960
然后再找到纸文件夹

01:01:31.560 --> 01:01:32.600
纸文件夹

01:01:32.600 --> 01:01:33.240
然后干嘛呢

01:01:33.240 --> 01:01:34.200
有很多的纸文件夹

01:01:34.200 --> 01:01:34.760
对吧

01:01:34.760 --> 01:01:37.080
循环纸文件夹

01:01:38.440 --> 01:01:40.440
地盘里面所有的纸文件夹

01:01:40.440 --> 01:01:41.960
每次循环干嘛呢

01:01:41.960 --> 01:01:44.840
每次循环求该

01:01:45.800 --> 01:01:47.800
该文件夹的

01:01:49.240 --> 01:01:50.040
占用空间

01:01:52.040 --> 01:01:52.600
好

01:01:52.680 --> 01:01:55.080
如果把某一个文件夹的占用空间

01:01:55.080 --> 01:01:55.960
认为是f

01:01:56.760 --> 01:01:57.720
Directory

01:01:57.720 --> 01:01:58.920
你给我一个文件夹

01:01:59.480 --> 01:02:00.600
这是个文件夹

01:02:00.600 --> 01:02:01.640
文件夹的路径

01:02:01.640 --> 01:02:03.880
那么我来求这个文件夹占用的空间

01:02:03.880 --> 01:02:04.920
那么做什么事情呢

01:02:04.920 --> 01:02:05.960
找到纸文件

01:02:05.960 --> 01:02:07.320
占用空间求和

01:02:07.320 --> 01:02:08.440
有很多纸文件嘛

01:02:08.440 --> 01:02:09.000
这些文件

01:02:09.000 --> 01:02:10.360
我们都可以得到它的占用空间

01:02:10.360 --> 01:02:11.560
把这些占用空间求和

01:02:12.200 --> 01:02:12.680
然后呢

01:02:12.680 --> 01:02:14.600
再找到它里面的纸文件夹

01:02:14.600 --> 01:02:16.040
代码里面是没法直接获取

01:02:16.040 --> 01:02:17.400
文件夹的占用空间的

01:02:17.400 --> 01:02:18.920
它必须要只能获取占用文件的

01:02:19.400 --> 01:02:20.520
找到纸文件夹

01:02:20.600 --> 01:02:21.800
然后循环纸文件夹

01:02:22.680 --> 01:02:23.720
有很多的文件夹嘛

01:02:23.720 --> 01:02:24.280
每次循环

01:02:24.280 --> 01:02:25.880
它求该文件夹的占用空间

01:02:26.440 --> 01:02:27.480
那么怎么来求

01:02:28.040 --> 01:02:28.920
每次循环

01:02:28.920 --> 01:02:29.320
做啥

01:02:31.000 --> 01:02:31.320
f

01:02:32.600 --> 01:02:33.240
文件夹

01:02:34.600 --> 01:02:36.040
文件夹路径

01:02:36.600 --> 01:02:37.080
对吧

01:02:37.080 --> 01:02:38.120
又来重新调问这个

01:02:38.520 --> 01:02:39.400
这就是地规

01:02:40.520 --> 01:02:41.640
像这些这种场景的

01:02:41.640 --> 01:02:43.480
我们会使用到这个地规

01:02:43.480 --> 01:02:44.280
就是有些场景的

01:02:44.280 --> 01:02:46.120
它会提供一种非常巧妙的办法

01:02:47.640 --> 01:02:48.120
好吧

01:02:48.120 --> 01:02:49.720
那就没啥了

01:02:49.720 --> 01:02:50.600
把地规讲一下

