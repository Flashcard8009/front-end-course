WEBVTT

00:00.000 --> 00:14.820
这一张呢 咱们来讲函数

00:15.840 --> 00:20.960
函数啊 它可以算是GS里面最重要的一块功能了

00:21.460 --> 00:24.020
好像我讲每一集都很重要是吧

00:24.800 --> 00:27.620
是这样子没办法啊 因为这些都是基础知识

00:28.120 --> 00:32.980
GS里面如果不支持函数的话 可以说GS义务世数

00:33.240 --> 00:34.520
基本上没有什么用

00:35.040 --> 00:37.340
正是因为它有强大的函数功能

00:37.600 --> 00:42.200
所以说我们整个程序呢 无论我们写多么庞大的程序呢 我们都可以把它进行减化

00:43.480 --> 00:46.040
函数到底是什么东西 它有什么用呢

00:46.560 --> 00:52.700
我们第五章呢 主要研究函数啊 整个这个章节呢 会讲很多相关跟函数相关的内容

00:52.960 --> 00:57.560
但是呢 很遗憾 这个章节都讲不完 因为太多了 函数东西太多了

00:57.820 --> 01:00.880
我们后边呢 就是会有一个进阶课程啊

01:01.140 --> 01:03.700
也是在这个课程里边啊 也是在这个课程里边

01:03.900 --> 01:08.000
就到后边呢 有有有几个章节呢 是关于函数进阶部分的知识啊

01:08.260 --> 01:13.640
我们学习到之后呢 就可以清楚的了解函数的本 函数的一些方面面的所有东西都可以了解了

01:14.160 --> 01:14.920
都可以了解了

01:15.680 --> 01:20.280
嗯 这这个章节呢 只是讲函数最基本的使用方式

01:20.800 --> 01:24.640
但是呢 你别小看它啊 就算是这个章节呢 他也有难度

01:25.160 --> 01:31.560
这应该算是咱们在做具体的页面效果之前 最后一个章节了啊 最后一个有难度的东西了

01:32.060 --> 01:37.380
那么这个章节学完了过后呢 我们就可以直接进入页面的学习了啊 在页面上怎么去做各种效果

01:37.900 --> 01:43.060
好 所以说不要导在黎明前啊 咱们最后一块呢 难关一定要把它度过去

01:43.500 --> 01:50.020
那么做 度过的方式是一样的 就是你认真听课 听完了之后呢 有作业 一定要把作业全部做一次

01:50.020 --> 01:53.940
做一次过后呢 再听作业讲解 只要你能够独立的把这些作业做完

01:54.540 --> 01:58.580
啊 你听到讲解过后再重新去做啊 把一步会的再重新做一遍 写一遍

01:59.200 --> 02:05.840
直到你能够自己独立的把它完成 只要你能独立的把它完成 ok 那么你这个地方了就高中了

02:06.400 --> 02:09.440
所以我们不用去追求进度啊 大家学习的时候不用去

02:10.200 --> 02:17.240
刻意的去追求速度 但一定要把它学踏实了 以前边学的越踏实 后面就会减少越就会减少很多的负担

02:17.880 --> 02:22.320
好吧 这几课 第几课非常非常重要 函数语法

02:23.120 --> 02:26.920
首先我来解释一下为什么需要函数 比方说举个例子啊

02:27.860 --> 02:28.980
好 这里有个页面

02:30.100 --> 02:31.780
这个页面上呢 我们写个代码

02:35.180 --> 02:39.900
有了函数过后 很多复杂的功能我们都可以做了 函数就是来解决复杂功能的

02:40.620 --> 02:46.980
啊 这里有个代码啊 我们先写这个非常简单的代码 就随便输出呗 就随便乱输出啊 输出一些东西

02:47.460 --> 02:49.820
好 输出一个分割符啊 输出一个分割符

02:50.860 --> 02:51.420
分割符

02:52.180 --> 02:55.180
就是分割一下啊 分割一下 好看一点 然后呢

02:56.160 --> 03:01.360
然后呢 我们在这里再输出一个其他东西啊 随便写一些啊 随便写一些啊 随便写一些

03:02.080 --> 03:05.760
好 写了一些过后呢 我们又写一个分割符啊 又输出一个分割符

03:06.800 --> 03:12.760
好 然后呢 我们又输出一些东西啊 又输出一些数据啊 比方说输出什么一个对象啊 随便写

03:13.440 --> 03:13.840
随便写

03:15.160 --> 03:21.680
可能你都不知道我要干嘛的啊 没事啊 随便写一些啊 再输出一些东西 然后呢 再输出一个分割符

03:22.600 --> 03:25.120
好 我这里要说的什么问题呢 咱们来运行看一下

03:27.930 --> 03:30.690
看一下啊

03:32.090 --> 03:36.970
刷新啊 我要说出说的是什么问题呢 我要说的是这个关于这个分割符

03:37.850 --> 03:42.810
就这个东西 那么大家看一下啊 这一括的代码是不是在重复

03:43.530 --> 03:47.890
在重复的运行啊 先运行他他的功能跟他的功能是不是一样的

03:48.410 --> 03:50.650
完全一样的 这就是重复代码

03:51.330 --> 03:55.570
重复代码会带来什么样的问题呢 会导致程序难以维护

03:56.310 --> 04:02.310
咱们从程序里边有很多种不好的邪法 其中一种最坏的邪法就是重复代码

04:03.910 --> 04:11.590
重复代码会带来什么问题的 让程序让程序难以维护 什么叫难以维护呢

04:12.710 --> 04:14.710
意思就是难以修改

04:15.430 --> 04:20.430
比方说我们这个代码呢 现在重复了三次对吧 那假设将来有一天啊 将来有一天我们要

04:20.870 --> 04:24.390
写了很多的分割符 要进行分割 那么可能重复了一百次

04:25.010 --> 04:31.410
好 突然有一天 他告诉你分割符呢 你不要这样子写了 你给我用新号写 你是不是要封

04:32.010 --> 04:36.410
是不是要封掉 那么假设我们程序里边不止一个接式文件

04:37.050 --> 04:41.890
可能有十几个接式文件 里边都用了用了这个分割符 那么一到是不是到处要改

04:42.690 --> 04:46.410
让整个程序难以维护 哪怕做一个很小的修改

04:47.010 --> 04:51.730
加一个 太少了 加两个 你是不是到处要改 全部要改一遍

04:52.470 --> 04:55.470
导致程序难以维护 这就是重复代码的问题

04:56.270 --> 05:01.230
那么函数用来做什么事情呢 函数最大的功能就是函数主要用于

05:03.070 --> 05:05.070
减少重复代码

05:06.110 --> 05:08.110
减少重复代码

05:08.950 --> 05:15.430
那么函数其实还有很多的其他的优势啊 我们以后呢 讲 讲到函数的具体 具体邪法之后呢 慢慢说

05:16.030 --> 05:19.230
他 但是他主要的功能就是为了减少重复代码

05:20.210 --> 05:26.530
好 那么函数怎么来写呢 如何来减少重复代码 如何来写一个函数呢 首先说第一个 与法

05:27.730 --> 05:35.410
创建函数 创建函数 跟变量是一样的 函数要先创建之后呢 才能使用啊 先有一个函数才能使用

05:36.210 --> 05:43.210
那么也叫做定义函数 创建函数也叫做定义函数 定义声明 都是一个意思 创建一个函数

05:44.010 --> 05:47.050
定义一个函数 声明一个函数 说的都是一个意思

05:48.030 --> 05:52.430
好 怎么来创建一个函数呢 看着啊 用这种方式

05:53.750 --> 06:04.150
用关键字方式 关键字方式 然后后边写上一个函数的名字 函数的名字呢 你可以认为啊 你可以认为呢 就是一个变量的名字啊 你可以这样子想

06:04.910 --> 06:09.590
就是我们自己命名的一个名字 当然呢 他是一个合法的标志符 对吧 所以说你要命

06:09.770 --> 06:17.730
你要符合命名规范 什么小陀封命名法 不能以数字开头等等等等 总之那是一个函数的名字

06:18.370 --> 06:23.050
然后两个小括号 两个大括号 这里边呢 写的是什么呢 写的是函数体

06:24.410 --> 06:29.490
函数体 那就完了 这就是一个函数的创建定义 非常非常简单

06:30.410 --> 06:33.690
只是大家写的时候呢 一定要把这个名字要命名好

06:34.670 --> 06:40.590
这个函数体是什么东西呢 就是代码块 什么代码都可以往里边写 啥代码都可以往里边写

06:41.310 --> 06:47.510
好 咱们来看一下啊 那么现在呢 我发现这个代码在重复对吧 在重复 ok 我这里呢就写个函数

06:48.430 --> 06:56.190
方形 写个函数 方形的单词的意思就是函数的意思 好 创建一个函数 这个函数呢给大家取个名字

06:57.110 --> 07:00.070
prinz print splitter

07:00.890 --> 07:08.650
啊 该取个好听的名字啊 print 表示什么意思呢 表示打印对吧 打印 splitter 表示分割的意思啊分割者

07:09.130 --> 07:12.330
分割符的意思啊 两个小括号 两个大括号

07:13.250 --> 07:18.250
大括号里边写啥呢 大括号里边就写函数的功能 一个函数就是一块功能

07:19.170 --> 07:24.130
就好必说一个函数的相当于啥呢 相当于是一家里面买了一个微波炉对吧 他就带有各种各样的功能

07:25.110 --> 07:31.590
好 就是这么一个函数就写好了 然后函数体里边呢 我们就把这个代码就放到函数体里边

07:32.270 --> 07:41.070
放进来 这个函数的功能是什么呢 这个函数的功能是输出一个分割符 看没 输出一个分割符 就写完了这个函数

07:41.950 --> 07:46.750
好 接下来我们把这些代重复代码就去掉了啊 就去掉重复代码 咱们来运行看一下

07:47.210 --> 07:55.210
看一下有没有分割符 有没有分割符出来 刷新看一下 有没有分割符啊 是不是没有

07:56.010 --> 08:00.650
没有打印啊 没有打印分割符 这是为什么呢 是因为函数呢

08:01.290 --> 08:09.410
它相当于是多了一个东西啊 多了一个东西里面 但是呢你没有用它 就好必说你家里买 家里边买了一个微波炉对吧 对吧

08:09.770 --> 08:15.610
但是呢你从来不去用 是不是买的跟没买是一样的 对吧 现在呢只是告诉你程序里边呢

08:15.830 --> 08:23.470
有了这么一个功能啊 可以打印一个分割符 但是呢你得去用它啊 你得去用它 在合适的位置去用它

08:23.910 --> 08:31.230
函数是不会直接执行的啊 函数这里边代码不会执行 它不会直接执行 只是告诉你呢有这么一个功能

08:31.750 --> 08:35.870
有这么一个功能 个功能的名字叫叫做print splitter splitter

08:37.350 --> 08:44.190
你要去用它的时候 它才会真正的去运行这里边的代码啊 这个代码不会直接运行的啊 所以说第一个点啊

08:46.310 --> 08:48.870
函数中的代码 函数体的代码

08:50.430 --> 08:56.670
不会直接运行啊 不会直接运行 那么它怎么什么时候运行的 必须要

08:57.750 --> 09:01.710
手动啊 手动 雕用函数

09:02.950 --> 09:11.590
才能运行其中的代码啊 是这么个意思啊 只有你去手动雕用的时候呢 它才会去运行这里边代码

09:12.090 --> 09:15.690
所以说 接下来我们来看另一个问题 如何雕用函数

09:17.210 --> 09:21.810
什么叫雕用函数 就好必须说你买了个微波炉 你按那个开关 要去用它了 这是雕用

09:23.010 --> 09:27.410
雕用函数什么意思呢 雕用函数的意思就是运行函数体

09:28.130 --> 09:32.410
运行函数体就这么个意思 把函数体无论它有多少代码运行的一遍 就是雕用

09:32.970 --> 09:41.010
好 雕用怎么写呢 雕用的写法非常非常简单啊 就是函数名 函数名两个小口号完了 这是雕用

09:41.810 --> 09:42.610
啊 这个雕用函数

09:43.650 --> 09:49.450
没问题吧 好 你看一下这个东西 这个东西是不是我们之前经常会写 对吧 经常会写

09:49.730 --> 09:56.730
一个前面一个名字 两个小口号 对吧 两个小口号 有的时候呢 小口号里边还可以放东西 咱们先不看什么放东西的东西啊

09:57.050 --> 10:00.450
先不看放东西 我们先直接写两个小口号 这就是雕用

10:01.250 --> 10:07.570
好 咱们来啊 这个函数它不会运行 对吧 我们要去雕用它才会运行 好这个时候 比方说啊这个地方

10:07.870 --> 10:14.790
我要输出一个分割符 我就不用这种方式来输出了 不用它这种方式来输出了 我们直接怎么样呢 直接雕用这个函数

10:15.110 --> 10:18.510
print splitter 把函数名找到 然后两个小口号完了

10:19.630 --> 10:23.670
好 你看这里啊 这里分割符啊 分割符 你看

10:24.710 --> 10:29.590
保存啊 这个位置打印了一个分割符 这个位置打印了一个分割符 这个位置打印了一个分割符

10:29.790 --> 10:34.670
就相当于是把这个代码运行一遍啊运行一遍 无论你这边这里边有多少代码运行一遍

10:35.410 --> 10:38.450
你看这意思啊 看一下啊 你看分割符是不是出来了

10:39.290 --> 10:44.890
哎 这样子一来 你看将来我们要改成新号 是不是很简单了 只需要去动这个函数就完事了

10:45.930 --> 10:49.050
外面的代码需不需要动 它不需要动 你看 保存

10:50.010 --> 10:51.970
这变成新号了 而且全部是统一格式

10:52.890 --> 10:57.970
你看吧 他就他就减少了重复代码 在这个位置呢 就基本上消灭了重复代码

10:58.850 --> 11:03.250
好 这就是雕用函数 函数只有在雕用的时候才会运行

11:03.550 --> 11:06.590
没有雕用 他不会运行的 他是不会运行的

11:07.470 --> 11:12.510
好 这是关于函数的最基本最基本的用法 一个是声明一个是雕用

11:13.390 --> 11:18.750
如果函数没有声明你去雕用 行不行呢 那肯定要抱错啊 肯定要抱错 保存看一下

11:19.750 --> 11:27.470
他说这个函数呢 没有定义啊 没有定义 跟那个变量是一样的啊 跟变量的规则是一样的 你得定义过后呢 才能去雕用

11:28.590 --> 11:33.150
好了 那你可以想象到 以后呢 我们这里有很多的重复代码 就是很多复杂的代码

11:33.350 --> 11:34.870
是不是我们可以把它放在函数里边

11:36.110 --> 11:41.590
在实当的位置呢 在实当的位置 我要用的时候 去雕用一时就完事了 只需要把函数的名字写出来

11:41.910 --> 11:49.030
因此呢 你函数的名字一定要取好啊 如果你取个abc 哪里到时候用的时候 就不知道什么意思了啊 就不知道什么意思了

11:49.510 --> 11:50.710
啊 你看写好了

11:51.830 --> 11:54.750
好 这是函数的声明和雕用

11:55.470 --> 12:02.050
然后呢 这里边有些细节啊 有些细节我要说一下 既然来说函数里边的一些细节

12:02.870 --> 12:08.430
呃 就是关于 第一个是关于函数提升 函数提升

12:10.550 --> 12:12.550
函数提升是什么意思呢 指的是

12:13.510 --> 12:15.150
通过字面量

12:15.950 --> 12:21.270
声明的函数 什么叫做字面量声明函数 这种写法就是字面量声明函数

12:22.230 --> 12:27.110
直接写方式写关键字 然后呢 函数名两个小过号一个大过号 这就是函数字面量

12:27.470 --> 12:31.790
以后呢 我们还会学习其他的声明方式啊 现在呢 我们先学习字面量声明

12:32.550 --> 12:39.670
通过字面量声明的函数 会提升到 提升到脚本脚本快的

12:40.670 --> 12:41.390
脚本快的

12:44.430 --> 12:49.150
顶部 跟变量一样啊 跟变量一样 会提升到脚本快的顶部

12:49.990 --> 12:55.150
什么意思呢 就是说 如果你这个函数写到下面来 写到这儿来

12:57.150 --> 12:57.870
能不能运行呢

12:58.810 --> 13:03.650
能不能运行 好像说就不能运行了 对吧 好像说不能运行了 为什么呢 因为

13:04.210 --> 13:08.930
以运行这个函数的时候 他这个函数还没有声明 对吧 还没有声明 应该是找不到这个函数

13:09.490 --> 13:12.730
但是我们来看一下 保存 你看一下这边刷新

13:13.450 --> 13:19.130
是不是还是可以运行 还是可以运行 说明了咋了 说明了就是这个函数的提升

13:20.170 --> 13:24.530
函数 通过这样的方式来说明了函数 它会被提升到脚本快的顶部

13:25.230 --> 13:31.470
会被提升到脚本快的顶部 因此呢 你函数无论你声明到哪都无所谓 都无所谓

13:32.030 --> 13:36.390
无所谓的 但是如果你出了脚本快就不行了啊 比方说下面还有一个脚本快

13:37.710 --> 13:43.390
好 这个脚本快里边声明了这个函数 在这个脚本快里边声明了这个函数 那上面能用吗

13:44.310 --> 13:50.550
是不是不能用了 不能用了 因为他只会提升到这一块的顶部 单码从上到下执行 执行他的时候还没有函数

13:51.050 --> 13:53.250
保存 看一下 他说函数不存在了

13:54.170 --> 13:58.090
明了这个意思吧 那么换一句话说 如果这个脚本快在上面呢

13:59.090 --> 14:06.290
如果这个脚本快在上面的可不可以呢 现在可不可以呢 现在就可以了 现在可以了 因为单码从上到下运行 运行到这句话的时候呢

14:06.850 --> 14:13.810
运行到这句话的时候 那么就会什么了 有了这个函数了 对吧 有了这个函数 下面调用了就可以调用了 现在就可以了

14:15.050 --> 14:20.530
能理解吧 非常简单啊 这是关于函数这一块的声明 跟变量是一样的啊 跟变量是一样的

14:21.530 --> 14:33.330
好 再来一个 就是通过字面量声明的函数 什么叫字面量声明的函数 就是这个啊 直接书写的函数 直接创建的函数

14:34.290 --> 14:41.930
会成为全局对象的属性啊 会成为全局对象的属性

14:42.730 --> 14:49.770
这个变量是不是一样的啊 跟变量也是一样的 好 比方说啊 咱们写了这个函数 对吧 写了这个函数 咱们来看一下啊

14:50.350 --> 14:55.350
温度对象里边 看一下这个属性存不存在 print splitter 你看

14:56.630 --> 15:03.630
这个属性是不是存在的啊 打印这个属性 打印这个属性的时候 你看得到的是一个函数 看他就把函数的这个格式打印出来了

15:04.430 --> 15:13.470
得到的是一个函数 也就是温度对象里边 全局对象里边会多了多了这么一个属性啊 跟那个是一样的啊 跟那个就是变量是一样的啊 是一样的

15:13.970 --> 15:22.170
然后再来啊 通过啊 这就不是函数提升的啊 应该说其他吧 其他特点

15:23.690 --> 15:30.410
其他特点啊 通过什么呢 通过type 啊 type 函数名

15:31.690 --> 15:35.610
得到的结果是什么呢 是一个制服创的方形

15:36.490 --> 15:41.850
咱们之前说引用类型 对吧 引用类型里边有有对象 还有一个就是函数

15:42.830 --> 15:47.630
通过type of 把函数名传进去 得到了是方形 比方说咱们在这里

15:48.750 --> 15:58.550
type of print splitter 你看一下 是不是方形 对吧 它的类型是方形 表示它是一个函数 方形的就是函数的意思

15:58.910 --> 16:05.190
方形这个单词呢 还有功能的意思 其实函数呢 就代表的一块功能啊 一个功能 你可以轻松的去使用这个功能

16:06.170 --> 16:15.690
好了 这是函数的一些特点啊 想想啊 想想 还有什么特点呢 函数 还有一个这个重要特点 就是关于函数的作用预

16:17.330 --> 16:18.290
函数内部

16:19.330 --> 16:21.650
声明的变量 声明的变量

16:24.190 --> 16:31.190
有极动情况 如果不使用挖 如果不使用挖声明 就是你直接给它复制 不使用挖

16:32.170 --> 16:36.370
和全局变量一致 和全局变量一致

16:37.930 --> 16:42.610
表示给什么 给温斗 给全局对象

16:43.890 --> 16:50.090
添加属性 表示给全局对象添加属性 好 比方说啊 咱们要换个叶面了

16:51.130 --> 16:58.010
换个叶面来举例子 好 比方说咱们这一个函数啊 有个方形 一个函数 test 啥都没有啊

16:58.470 --> 17:02.350
里边定义了个变量 但是变量了没有写发啊 没有写发我直接给它复制

17:03.190 --> 17:09.310
直接给它复制 好 相当于是啥呢 相当于是这个复制呢 就是给温斗对象的

17:09.750 --> 17:14.150
相当于是给温斗对象就全局对象 它的属性复制啊 相当于是这个

17:14.790 --> 17:17.590
好 咱们来看一下啊 来看一下 理解一下这个这一块的知识

17:18.630 --> 17:23.750
好 首先让我们来检查一下啊 我们打印出啊 打印出温斗对象里边现在有没有哎

17:24.350 --> 17:25.550
温斗 有没有哎

17:26.530 --> 17:32.850
有没有哎 是不是没有 现在没有这个属性哎 看没 现在没有 为什么 因为这个函数还没有运行

17:33.450 --> 17:39.050
还没有运行 然后呢 现在我去运行一次这个函数啊 运行一次这个函数 你看一下

17:39.770 --> 17:41.850
运行了之后 看一下

17:43.450 --> 17:53.450
温斗哎 你看是不是变成三了啊 说明这个哎这个属性了 函数里边这个变量了 复制在哪了 复制在全局对象里边啊 是一样的啊 是一样的

17:53.550 --> 17:59.310
但是你要先运行啊 你的运行 你不运行的话 那这个函数写的啊 这个代码等于白写啊 没有运行

18:00.110 --> 18:02.270
当然可以运行多次啊 运行多次是一样的

18:04.110 --> 18:09.990
好 这是第一点 好 如果使用了瓦声明 好 不一样了啊 不一样的地方来了

18:11.110 --> 18:21.270
之前全局变量使用瓦声明 我们说过 他会提升对吧 提升到脚奔块的顶部 还会怎么样呢 还会成为温斗的一个属性啊 还会成为温斗的一个属性

18:21.690 --> 18:32.090
但是呢 如果函数内部使用瓦声明啊 使用了瓦声明 通常情况下啊 我们声明的变量都要用瓦啊 都要用这个瓦关键字 一般不要这样子写

18:32.530 --> 18:38.890
不要这样子写 这样写的话 附着在温斗游墙上面去了啊 如果使用瓦声明的话 在函数里边

18:40.170 --> 18:49.450
变量提升到函数的顶部啊 提升到所在函数的顶部啊 所在函数的顶部

18:49.630 --> 18:56.150
什么意思呢 就是说啊 就是说什么了 就是说这里呢 我可以写个瓦

18:57.270 --> 19:02.110
可以写个瓦 他会提升吗 会提升 提升到哪儿呢 是不是提升到这儿呢

19:03.030 --> 19:10.350
不是啊 他这个声明啊 声明这个a 他不是提升到这儿 而是提升到哪儿呢 提升到函数的顶部

19:10.750 --> 19:17.270
所以说在函数里边输出a 输出这个a 变量a 可不可以 可以 因为他这样子写的话就相当于是这样子写

19:17.690 --> 19:21.770
声明一个a 然后把a复指为3 相当于是这样子写 那输出啥

19:22.570 --> 19:26.250
这代表输出啥 输出安迪范的 对吧 输出安迪范的

19:27.650 --> 19:34.250
因为他刚刚开始声明了没有指嘛 输出安迪范的 他不会爆错啊 他是不会爆错的 那如果没有这个变量a 你看一下

19:34.610 --> 19:40.130
如果没有这个变量a 我们来看一下 保存 他要爆错 他说a没有定义啊 没有定义

19:40.910 --> 19:51.070
你看这个意思吧 也就是他会有提升啊 这个变量会有提升 但是他提升到是函数的顶部 提升到函数顶部 那么就意味着啥呢 就意味着

19:52.910 --> 19:56.150
函数外部 函数外部

19:57.070 --> 20:02.310
不可以使用该变量 函数的外部是不能使用该变量的

20:03.310 --> 20:06.270
保存看一下啊 咱们的外部去打印这个a

20:07.050 --> 20:10.210
看一下打印这个a 存在吗 保存啊

20:11.170 --> 20:21.090
他说a is not defined 在外面打印的时候他要爆错 直接爆错 他外面是找不到这个a的 所以说函数了这一块 他是有一个就是

20:22.570 --> 20:30.890
一个封闭的空间啊 你可以把他想象成一个封闭的空间 这个空间里边定义的变量 他只在这个空间中有效啊 这个非常非常重要啊 大家要注意

20:31.710 --> 20:38.110
啊 因为GS里边作用域呢 就两块 一个是全局的 一个是函数内部的 就这个两块

20:38.750 --> 20:41.390
函数中声明的变量

20:42.710 --> 20:45.590
仅能在函数中使用

20:46.830 --> 20:53.510
在外部无效啊 在外部无效 也就意味着啥呢 如果你在外部定义一个一模一样的变量 a

20:54.490 --> 21:02.570
从不冲突 他不冲突啊 他不冲突 比方说啊 我这里定一个a等于5 把里边的a等于3 然后a减减

21:03.090 --> 21:05.730
a减减 然后我们调用这个函数 输出这个a

21:06.730 --> 21:11.850
输出啥了 输出啥了 输出了45 输出了45 看一下

21:12.650 --> 21:17.290
看没输出了15 没问题吧 应该没问题啊 输出了15

21:18.270 --> 21:22.830
你说外面这个a呢 跟里边这个a 都是生命的变量 对吧 都是生命的变量

21:23.630 --> 21:29.510
不冲突 里边的是里边的 外边的是外边的啊 没关系的啊 没有关系的

21:30.390 --> 21:35.350
好 这是关于函数这一块啊 它的一个就是会发生的一些变化啊 一些变化

21:35.750 --> 21:42.390
说这一块呢 主要的啊 主要我要说的就是 一个是函数它自身提升 提升到函数自身提升到顶部

21:42.830 --> 21:46.510
另外一个呢 是函数里边的变量 跟外边的变量它不影响啊

21:47.010 --> 21:49.650
里边呢 是里边的变量 外边是外边的变量

21:50.370 --> 21:55.970
好吧 外边是不能用里边的啊 其实里边是可以用用外边的啊 我们单独打击客来说

21:56.330 --> 22:02.770
那是叫做函数作用语 我们单独打击客来讲啊 现在别管 现在只需要记住 外边是不能用函数里边的东西

22:04.090 --> 22:06.610
好 这是关于第一块啊 第一块支持

22:08.650 --> 22:09.730
好 然后我们继续看

22:11.530 --> 22:12.890
如果一个函数

22:13.670 --> 22:16.390
仅仅是这样写的话 它没有什么意义

22:17.150 --> 22:18.150
它没有啥意义

22:19.350 --> 22:22.310
为什么没有啥意义呢 比方说我举个例子

22:24.430 --> 22:28.030
我们做这么一件事

22:32.470 --> 22:32.990
做什么事呢

22:34.070 --> 22:36.750
求一个数组

22:37.730 --> 22:42.330
之和 或者这样子啊 判断一个数

22:43.890 --> 22:48.170
是不是击数啊 判断一个数字是不是击数

22:49.210 --> 22:50.330
好 那么这样子来

22:52.050 --> 22:56.210
方形 我们写个函数啊 这个函数作用是判断一个数是不是击数

22:56.850 --> 23:01.730
好 这个函数的该取个名字 意思啊 把名字该写标准一点啊 意思表示是不是

23:02.450 --> 23:02.970
击数了

23:03.710 --> 23:06.270
aud od 表示是不是击数

23:07.110 --> 23:09.870
写个函数 比方说啊 我们写个数字 n

23:11.550 --> 23:12.750
随便写个 随便写个

23:14.710 --> 23:19.710
console 这样子吧 判断一下 n 除以二的余数 如果等于零

23:20.390 --> 23:22.990
那么我们输出不是击数

23:23.550 --> 23:24.110
不是击数

23:25.470 --> 23:28.110
然后 else 输出是击数

23:30.430 --> 23:30.990
是击数

23:34.720 --> 23:39.040
那么现在呢 我们去调用这个函数啊 不调用的话 他不会运行的啊 调用这个函数

23:39.920 --> 23:40.840
好 保存

23:42.240 --> 23:50.800
打开看一下啊 好 他打印出来了是击数 没什么问题 对吧 没什么问题 因为这个这个数字确实是击数

23:51.720 --> 23:55.040
那么将来有一天 大家看啊 事情开始变化了

23:56.000 --> 24:03.040
将来有一天 我要 我要得到啊 我们这里还是凭借一下吧 n 是不是击数啊 凭借一下

24:04.020 --> 24:07.900
将来有一天 我要看的数字不是这个数字啊

24:08.900 --> 24:11.380
看的数字他不是这个数字 那怎么办呢

24:12.380 --> 24:17.420
比如说 那有些同学说 那简单呀 我把这里改一下就行了 那么大家想没想到一个问题

24:17.780 --> 24:22.100
这个函数是不是要一直要不断的修改啊 要不断的修改 对吧

24:22.980 --> 24:25.060
他这样这个挺麻烦的啊 他要不断的修改

24:25.780 --> 24:29.220
有的时候呢 我们可能来自于一个用户输入 那这里是不是又要修改

24:29.800 --> 24:33.240
那改了改去 我跟我写到外面有啥区别了 这么没啥区别了

24:34.160 --> 24:39.160
好 那么假设再有一天我要做什么呢 我要有一个数组啊 我一个数组

24:40.680 --> 24:48.080
一个数组 这个数组里边呢 啊 比方说一个数组啊 这个数组里边呢 存了一些数字啊 随便写一些数字啊

24:50.080 --> 24:51.840
我要做一个件事 就是

24:52.700 --> 24:53.900
变立这个数组

24:55.660 --> 25:03.380
如果这个数组的其中一项是基数 就输出它是基数 如果它不是基数 就输出它不是基数啊 我们要做这么一件事

25:04.660 --> 25:09.740
那你看这个函数能用吗 这个函数是不是用不了 因为他把个数字固定了 定死了

25:10.340 --> 25:16.940
那你怎么办了 你是不是要把数组 数组写进去 对吧 数组写进去 又来循环来进行判断

25:17.400 --> 25:24.600
那跟你其他外面有啥区别呢 这样子一来 这个函数它就不能通用了 函数它具有一个什么特点呢 就是通用性

25:25.000 --> 25:31.560
你这里可以用 另外一个地方也可以用 什么都可以用啊 只要你跟判断基数有关 我都可以用 他有个通用性

25:32.240 --> 25:36.520
那这里就不能通用了 所以说 接下来我介绍一个知识 叫做参数

25:37.920 --> 25:38.320
参数

25:39.920 --> 25:42.400
参数是什么意思呢 参数表示

25:42.500 --> 25:51.300
参数是函数运行的位置条件 位置条件 需要雕用者

25:52.260 --> 25:56.900
高值的数据 高值的数据 这就是参数 什么意思

25:57.700 --> 26:01.100
好 我们来再来分析一下这个函数 这个函数的作用是啥

26:01.940 --> 26:10.300
作用是输出一个数 是不是基数 它是输出一个数 是不是基数 它的功能是这样子

26:10.840 --> 26:19.080
那么它要 比方说你把你自己当成一个函数 你就是这个函数 你的功能就是输出一个数 是不是基数 你告诉我 是不是基数

26:19.960 --> 26:22.280
来 你来告诉我 你能不能告诉我

26:23.840 --> 26:27.000
你差什么条件没 是不是差了一个条件 差什么条件

26:27.760 --> 26:34.520
你要输出一个数 是不是基数 你是不是 我得把数字告诉你啊 我给你一个数字 你来告诉我 是不是基数

26:35.100 --> 26:44.220
就好比说你要用微波鲁 你就按一下开完就完了嘛 你是不是在调时间啊 你得把时间告诉他 他不知道他怎么知道你要打几分钟了 对吧 他不知道

26:44.900 --> 26:50.740
这也是一样啊 他是一个功能 这个功能他有一些位置条件啊 比方说啊 比方说

26:51.340 --> 26:56.220
考试 对吧 考试的就是个功能啊 你去做卷子来来 马上给我做个卷子 做吧

26:57.260 --> 26:57.900
做 马上做

26:58.740 --> 27:01.300
你没法做 你为什么没 为什么没法做

27:01.960 --> 27:08.600
我没有给你卷子 你怎么做吗 你是不是没法做 你是不是少了一些东西了 对吧 少了一些条件 这里是一样的

27:09.160 --> 27:15.160
我要写一个函数 这个函数代表的一个功能 但是呢 你执行这个功能的时候 少了东西 少了东西

27:15.640 --> 27:19.000
这东西就是参数 你要判断一个数 是不是基数

27:19.760 --> 27:26.720
你要把这个数字给我 我才能判断 这就是参数 参数 参数写到哪儿了 参数写到这

27:26.860 --> 27:40.660
参数可以有多个 可以有多个 随便多好个 参数二 你想写几个 写几个

27:41.540 --> 27:51.620
就是创建函数的时候 创建函数的时候 参数就写到这 参数 参数就是个标志符 跟变量差不多 跟变量差不多 大家注意 大家要注意一下

27:52.200 --> 28:02.200
就是 这里参数的作用域 就是参数的有效范围 在函数体中

28:03.320 --> 28:08.320
只有在函数体中有效 除了这个函数体就用不了了 你不要跑到函数体外边去用这个参数

28:08.960 --> 28:12.120
在函数体里边你可以把这个参数当成变量来使用

28:13.160 --> 28:19.480
好 咱们来看一下 这里呢 你要给我一个数字 我来判断是不是基数 好 我这里就写个参数

28:20.220 --> 28:25.580
判断一个数字是不是基数 我这里就不写这个数字了 你把这个数字告诉我

28:26.380 --> 28:30.300
我来帮你判断是不是基数 你把这个数字告诉我就玩笑了

28:31.340 --> 28:36.820
好 怎么来告诉他呢 怎么来告诉他 你看这里边用这个参数 是不是跟变量的用法是一样的

28:37.820 --> 28:43.540
跟变量的用法一样的 你不要在前面给我写个VAAR 不需要声明的 参数是不需要声明的

28:44.520 --> 28:50.040
好 另外一个问题 我怎么来告诉他这个参数是什么

28:50.840 --> 28:53.840
高速是什么时候告诉我 是我要用他的时候高速

28:55.040 --> 29:00.360
比方说你微波鲁买回来过后他就知道每次打饭 打菜是多少时间吗 他不知道

29:00.920 --> 29:06.000
你要用的时候告诉他 这一次我打三分钟 第一次 第二次呢我打四分钟

29:06.400 --> 29:11.600
你要告诉他 每次用他的时候 就雕用函数的时候 把参数传进去

29:11.900 --> 29:19.060
第二用函数的时候 把参数传进去 你不是需要一个东西吗 ok 你再帮我判断三是不是基数

29:20.340 --> 29:25.180
这样子一来 就把这个数据传递给了这个数据 就好像是变量复制一样

29:25.820 --> 29:32.180
把这个值复制给了他 然后运行一次 然后运行完了过后 又等待下一次雕用

29:32.820 --> 29:36.100
就像微波鲁打完了过后 下一次又可以用 可以重复使用

29:36.880 --> 29:43.400
比方说 下一次122这里传100 看一下 我们雕用了两次 对吧 雕用了两次

29:45.280 --> 29:49.800
看一下 看一下结果 你看就运行了两次 三次基数 一百不是基数

29:50.600 --> 29:58.800
你看现在这个函数是不是可以通用了 通用性就好很多了 有了参数过后通用性好了很多 那么怎么执行的呢 他是这样执行的

29:59.620 --> 30:05.260
看着啊 程序运行 这是一个函数声明 不管他 管的不管他

30:06.420 --> 30:13.460
即将往后看 看到这 哎 再雕用函数了 对吧 再雕用函数了 好这个时候呢 他会把怎么样呢

30:14.020 --> 30:21.300
他会把三传给这个n 等于三了 现在啊 等于三了 然后开始执行这里边东西 三除二的余数

30:22.000 --> 30:31.240
不等于零 对吧 运行 else 输出三四级数 好 程序这个函数运行结束 n 消失 n 直接消失 不见了

30:31.880 --> 30:38.000
没了 好 接下来 这就再把运行完了啊 然后又运 又运行 23 行的代码

30:38.640 --> 30:44.920
又运行 23 行的代码 是不是 又来一次 又把100传给这个n 又把100传给这个n

30:45.320 --> 30:49.200
好 然后又来啊 又来 传给这个n 过后呢

30:50.180 --> 30:59.620
n 除二的余数 不等于零 对吧 不等于零 等于零 对吧 输出100不是级数 他是这么执行的 他是这么执行的

31:01.660 --> 31:03.980
好 如果你不传递会怎么样

31:05.780 --> 31:14.140
不传递 有人说不传递用上一次的值 不可能的 不可能的 上一次的值 上一次运行完了就直接没了 所有东西全部没了

31:15.120 --> 31:22.080
函数运行完了过后 就像微部鲁一样 运行完了过后就直接断电了 啥都没了 啥都没了 你下一次用全部再重新来一次

31:23.120 --> 31:29.560
所以说 你这里不传递会怎么样呢 这里记忆比 不传递 雕用的时候是这样雕用的 函数明

31:30.680 --> 31:34.120
这个是参数 传进去 有的时候我们可以这样子

31:35.200 --> 31:39.640
有一种教法 这里叫做行参 行参 叫做行事参数

31:40.420 --> 31:44.980
这里叫做行参 就是函数声明的时候写的参数 就是一种说法而已

31:45.540 --> 31:51.740
函数声明的参数 我们把它叫行参 行参是有名字的 函数雕用的参数呢 这里是时参

31:53.620 --> 31:58.300
时参可以是字面量 可以是一个表达式 可以是个变量 随便

31:59.260 --> 32:03.020
好 这里说一下

32:03.360 --> 32:16.120
如果时参没有传递 没有传递 则对应的行参为undefend

32:18.920 --> 32:23.120
好 比方说 咱们在函数里边把这个n打印出来 把这个n打印出来

32:23.520 --> 32:27.800
不用打印了 这里就本来就要打印 对吧 本来就要打印 好 比方说 第二个

32:28.160 --> 32:31.280
没有该传时参 对吧 没有该传时参 OK 保存看一下

32:32.260 --> 32:36.140
是不undefend的 对吧 undefend的 他是为什么认为undefend是只击数了

32:36.940 --> 32:39.220
你想呗 undefend的是不是NAN

32:40.140 --> 32:43.100
NAN跟任何数字相乘 是不是还是NAN

32:44.300 --> 32:47.580
相处 相处 求予都是一样的 还是NAN

32:48.140 --> 32:53.820
NAN跟任何数字比较 是不是 都为force 都为force 所以说运行

32:54.320 --> 32:56.800
AOS 就是它是实际数 实际数

32:57.360 --> 33:02.600
undefend 不传时参 时参如果没有传递 那么就是undefend

33:03.640 --> 33:08.000
好 时参这一块可以写任何东西 可以写任何东西 比方说能不能写表达式

33:08.560 --> 33:14.040
当然可以写表达式 什么意思 把这个表达式的计算结果传给这个N

33:14.440 --> 33:16.840
是一样的 相当于把N复制为这个

33:17.560 --> 33:18.960
是一样的 对吧 一样的

33:20.400 --> 33:21.280
这个没什么好说的

33:22.260 --> 33:26.260
你其实你看一下我们之前写的propt 这个东西

33:28.460 --> 33:34.300
这个玩意儿 你看一下是什么 是不是就是参数 对吧 提示语句 就是参数

33:34.660 --> 33:39.180
这个玩意儿就是参数 看没 好 包括我们之前用的是什么console.log

33:39.580 --> 33:43.380
log就是一个函数 它是放到对象里面的函数 我们之后会说

33:44.420 --> 33:47.820
那么这是就是一个函数 这里面是不是就是参数 对吧 就是参数

33:48.800 --> 33:49.280
没问题吧

33:50.080 --> 33:53.480
好 这就是函数参数 关于函数参数

33:55.120 --> 33:56.800
调用的时候可以传参数进去

33:58.240 --> 34:05.280
好 然后我们再来看 再来看 这是函数参数 能理解吧 没问题吧 表示的是函数运行需要的

34:06.040 --> 34:10.920
位置条 位置信息 你要告诉他 那再比方说 再比方说 咱们再来举个例子

34:13.400 --> 34:16.920
写一个函数 输出两个数

34:18.160 --> 34:21.840
相加的和 相加加的结果吧

34:23.080 --> 34:26.120
有这么一个函数 它要输出两个数相加的结果

34:27.400 --> 34:33.040
好 怎么做呢 好 写个函数呗 给他取个名字上 上 取个名字

34:33.560 --> 34:37.440
好 需不需要参数 他需不需要参数 那你就这样子想

34:38.380 --> 34:43.060
你就是这个函数 我现在让你把两个数相加 来 告诉我他的指示多少

34:43.740 --> 34:46.420
来马上回答我 两个数相加的指示多少

34:47.300 --> 34:50.700
你没法回答 为啥 是不是你要我要告诉你两个数啊

34:51.300 --> 34:55.100
你要做这件事 是不是有位置信息 对吧 这些位置信息就是参数

34:56.180 --> 35:00.220
两个数相加你要告诉我两个数 对吧 两个参数 告诉我两个数

35:00.700 --> 35:04.940
那告诉我两个数过后 那就简单了 我就输出a加b a加b

35:05.800 --> 35:10.440
就完了 对吧 非常简单啊 无非就再给他拼接一下呗 再给他拼接一下呗

35:12.920 --> 35:15.560
相加之合啊 这样子吧 我用模板支付创来拼接

35:18.840 --> 35:24.240
a加上b等于 a加b

35:25.320 --> 35:27.080
这样拼接出来 方便一点

35:27.920 --> 35:33.960
好 这是个函数 好 有了这个函数过后你看我们后边啊 后边就非常简单了啊 非常简单了

35:34.180 --> 35:37.860
我要把三合五相加 调用这个函数就完事了 看一下

35:40.900 --> 35:47.580
把三合五相加你看得到 结果三三加五等于八啊 好 如果以后呢 我们再加一个啊 再加一个 随便写啊

35:49.460 --> 35:53.700
保存 你看一下啊 所以相加都到结果了 对吧 有问题吧

35:54.500 --> 35:59.820
好 如果你扫传一个参数怎么办 如果你扫传了一个参数 你看b就变成undefend了

36:00.200 --> 36:04.880
他就变成undefend了 那就是a拼接undefend的你看呗

36:05.520 --> 36:10.920
你看呗 a拼接undefend的 再拼接a加b a加b就是n a n对吧 n a n

36:11.960 --> 36:15.400
所以说你没传 传输传扫了 他就会变成undefend的

36:15.880 --> 36:20.640
有时候要说能不能多传一点呢 当然可以多传一点 多传一点没用 没用

36:21.080 --> 36:27.880
没用 你得不到对吧 你在这个函数里面得不到 他是一对应的 这个对应a这个对应b 后边他没有对应了 你得不到

36:28.860 --> 36:31.900
好 保存 看一下啊 你得不到的 后面两个参数

36:33.820 --> 36:41.980
好 这是关于函数参数啊 咱们多举一些例子啊 让大家彻底理解 好 前面这个东西呢 我们还可以继续来做文章

36:43.300 --> 36:46.380
好 比方说啊 咱们来做个例子 有一个数组

36:48.620 --> 36:52.140
好 一个数组 好 这数组里边有一些数字啊 有些数字

36:52.560 --> 37:01.240
啊 我要干嘛呢 我要输出这个数字里边 输出里边 每一个数字是不是几书

37:02.880 --> 37:05.320
好 怎么来输出呢 我们首先

37:06.120 --> 37:15.720
搞清楚 这里是不是有一个函数啊 他就能能够做这件事啊 我们写好函数之后啊 把函数测试写好之后 我们就没有必要去看他的函数题了啊

37:16.040 --> 37:20.200
不要你每次调用函数的时候 你都要去想一想 他里边咋写的 那我问你吧

37:20.620 --> 37:27.420
这个玩意是个函数 你知不知道他里边 你知不知道他里边咋写的 这个函数里边是怎么写的 他的函数体是怎么写的 你知不知道

37:28.300 --> 37:32.060
你肯定不知道吗 你肯定不知道他里边咋写的 但是妨不妨碍你使用他

37:33.220 --> 37:39.620
是不是不妨碍 我们只需要知道这个函数什么功能就行了 对吧 他又要不要传参数 传什么参数 知道就这就行了

37:40.260 --> 37:50.180
不需要知道他里边咋写的 所以我们自己写的函数也一样啊 你写了函数之后 你不用去管他里边咋写的 你只要写的没问题啊 测试好了没问题 当然你要边写边测

37:50.900 --> 37:56.740
测试好了过后没问题 ok 你把关起来 折起来 你不用去看他了 好 这个函数的作用就是

37:57.620 --> 38:03.700
他是几数 他就输出 他是几数 他不是几数 他就输出 他不是几数 那剩下的事情就很简单了 徐环数组呗

38:05.340 --> 38:09.620
哎小于numbers 点names 哎佳佳 徐环数组

38:10.580 --> 38:11.220
然后怎么样呢

38:12.940 --> 38:19.420
雕用函数 把数组的每一项扔进去 你看 通过表达式啊 把这个表达式的纸扔进去

38:20.120 --> 38:26.920
剩下的事情交给他搞定 他一定能搞定的 因为我们之前测试过 他一定能搞定 你看 这个是不是更加通用了 他可以用到各种场景

38:27.920 --> 38:32.560
好 看一下啊 你看 数字里面每一项数字都可以判断 是不是几数了

38:33.560 --> 38:38.480
没问题吧 ok 啊 这是关于函数的函数 咱们再来一个啊 多来一个

38:39.640 --> 38:40.120
多来几个

38:41.960 --> 38:43.120
嗯 再比方说啊

38:44.880 --> 38:46.320
那我眼睛怎么有点花呀

38:46.820 --> 38:51.260
嗯 好 现在呢 有一个函数啊 就是

38:52.500 --> 38:56.020
对一个数组求和 对一个数组求和

38:57.180 --> 38:58.100
好 写这么一个函数

38:58.980 --> 39:04.900
方形 写这么一个函数 好 函数 我们给他取个名字啊 some 求和嘛

39:06.340 --> 39:08.420
erate 数组的和

39:09.820 --> 39:10.460
有没有参数

39:11.580 --> 39:12.460
告诉我 有没有参数

39:13.440 --> 39:17.600
来吧 你把自己当成这个函数 来给我数组求和 告诉我何是多少

39:18.720 --> 39:22.720
告诉我何是多少 你没法求对吧 你要告诉他啥啊

39:23.360 --> 39:28.600
你是不是告诉他这个数组啊 你把数组告诉他呗 对吧 你把个数组告诉他

39:29.120 --> 39:34.520
那么他来帮助你求和 好 那么这里把数组只要通过参数告诉他了 那就简单了

39:34.920 --> 39:39.720
好 那么求和呗 把他当成数组来使用啊 定一个变量 some 对吧 等于0

39:40.540 --> 39:45.420
循环 i 等于0 i 小于 ar 点 lence 啊 i 加加

39:46.340 --> 39:46.740
哎 加加

39:48.300 --> 39:55.020
好 然后呢 some 加等于 ar i 对吧 求和写了很多遍了 最后输出啊

39:56.060 --> 40:00.140
和为多少呢 凭借一下上啊 凭借一下上

40:01.060 --> 40:03.980
没问题吧啊 对数组求和 完事

40:05.620 --> 40:07.820
好了 那么我们来用一下啊 看一下怎么用

40:08.800 --> 40:17.080
用一下 some ar 它里边要传一个什么呢 传一个数组进去对吧 传一个参数数组进去 你只要是数组就行

40:17.400 --> 40:24.680
甭管这数字在变量里边还是在一个对象的属性里边还是在什么地方 无所谓 还是字面量都无所谓 你只要给他一个数组就完事了

40:25.280 --> 40:26.800
啊 给他的数组来吧 求和

40:28.520 --> 40:31.160
把这个数组给你啊 求和 看一下

40:32.440 --> 40:35.760
你看 大家应该能体会到这个喊数会带来多少的方便 你看没有

40:36.420 --> 40:42.060
其实是好 以后呢 我再要求和 是不是 我不用再重新写了 不用每次都重新写一遍啊

40:42.700 --> 40:45.860
重新来个数组呗 重新来个数组啊来求和

40:47.300 --> 40:47.780
你看一下

40:48.780 --> 40:53.380
这个可以可以反复的使用 看没 而且整个代码是不是更加容易阅读了

40:54.100 --> 40:59.820
你看那个秘密啊 sound array啊 sound array 表示的是数组的和

41:00.480 --> 41:08.720
数组给他 求和 数组给他 求和 更加容易阅读了 那么这个变量 这个时参啊 这个参数可以放到变量里边 随便啊 随便

41:11.320 --> 41:16.280
可以放到变量里边 把变量传进去 可不可以 当然可以 没有任何问题

41:17.080 --> 41:23.160
这个变量的名字呢 甚至可以跟参数的名字重复 都无所谓 因为它里边不会影响外边的 外边也不会影响里边

41:24.280 --> 41:26.920
它无所谓的 它是独立的啊 它跟它没有什么关系

41:27.860 --> 41:31.180
没有这意思吧 ok 那就求和呗 对吧

41:32.180 --> 41:37.660
啊 有了函数过后了 很多功能啊 我们都没有必要重复去写了 对吧 都没有必要重复去写了

41:39.580 --> 41:43.580
好 再比方说啊 再比方说 嗯 我们这样子啊

41:50.080 --> 41:53.640
方可行 这里做这么一做 做这么一件事啊

41:54.620 --> 41:59.740
呃 什么呢 将指定的数据啊 将这样子

42:00.660 --> 42:03.260
删除数据莫为

42:04.660 --> 42:05.940
呃 莫为的

42:07.380 --> 42:12.620
指定数量的数据啊 删除一个数据 莫为指定数量的数据

42:14.140 --> 42:16.700
Denet Erie 删除数据

42:17.500 --> 42:21.940
你要告诉我什么东西 来 想一想 参数要告诉我什么东西 我才能删

42:22.920 --> 42:26.280
你是不是得把数组告诉我 对吧 还要告诉我啥

42:27.640 --> 42:32.840
还要告诉我啥 是不是你要三的数量 对吧 你要三的数量 比方说你要三莫为三个数据

42:32.840 --> 42:39.160
要把莫为三个数据删掉 然后你是不是要告诉我删除了数量 对吧 删除了数据 数量 囊本

42:40.280 --> 42:46.000
啊 你告诉我这两个就行了 把这个数组里边莫为删除这么多箱

42:46.980 --> 42:50.300
怎么写的 所以以前写过了splice 对吧 splice

42:51.420 --> 42:56.220
下标从哪个位置开始删 那么这里呢 我们可以写复数啊 复数

42:57.140 --> 43:02.780
从复数 因为我们知道复数呢 表示什么意思呢 复一呢 表示最后一项 复二呢 表示到处第二项

43:03.420 --> 43:06.020
所以说复的number 从这一项开始删

43:08.740 --> 43:09.340
这样开始删

43:10.700 --> 43:15.700
好 三几项呢 三几项是不是三number 项 对吧 三number number 项

43:16.300 --> 43:17.660
好 就完了 对吧 就完了

43:18.660 --> 43:22.180
好 咱们再试一下啊 第一次二位啊 这里给他一个数组

43:23.740 --> 43:28.140
一二三四五啊 三几项呢 三三项 看一下啊

43:29.420 --> 43:33.860
哦 我这里没输出 对吧 没有输出 看不到效果 好 这里呢 我们这样子吧 定一个变量

43:34.780 --> 43:36.580
numbers 等于这个数组

43:39.300 --> 43:44.900
输出保存进去 好 把这个变量扔进去啊 变量扔进去 看一下啊 最后呢 我们输出这个变量

43:45.760 --> 43:46.400
输出这个变量

43:48.240 --> 43:48.560
看一下

43:53.880 --> 43:56.640
你看 是不是摩尾三项删掉了 对吧 删掉了

43:58.080 --> 43:59.200
哎 注意哦

44:00.840 --> 44:02.720
这个地方啊 说明了一个啥问题

44:04.480 --> 44:09.840
这个东西 传递给这个东西 传递的是啥 传递的是地址 看到没

44:10.720 --> 44:15.040
啊 跟变量是一样的 没啥区别 就是把他复制给他 是不是复制的是地址

44:15.460 --> 44:20.300
因此他的地址 跟他的地址 是不是指向同一块内存空间了 指向同一个数组

44:20.860 --> 44:24.940
当这里边 他被改变的时候 是不是 他也跟着变了 他也跟着变了

44:25.380 --> 44:29.980
这叫引用传递 引用传递 传递的是地址 当然 数组是有这种情况

44:30.700 --> 44:33.620
这个对象是不是也有这个问题啊 对吧 也有这种情况

44:34.340 --> 44:35.060
也有这种情况

44:36.260 --> 44:36.500
好吧

44:37.740 --> 44:41.380
ok啊 这是关于 关于就是参数

44:43.100 --> 44:44.620
好 参数讲完了过后

44:45.660 --> 44:48.940
除了参数之外 函数还有一个东西 也非常非常重要

44:49.900 --> 44:50.620
咱们再来一个例子

44:52.180 --> 44:52.620
贴手寺

44:54.500 --> 44:55.020
好 看着啊

44:55.900 --> 45:01.780
我们之前呢 写了这么一个东西 就是求和 对吧 求和 好 再把复制过来

45:03.940 --> 45:06.900
嗯 判断是不是基数啊 判断是不是基数

45:09.340 --> 45:09.860
拿过来啊

45:11.620 --> 45:14.860
再把这个函数拿过来 现在呢 我们要做这么一个东西

45:15.060 --> 45:15.660
这么个例子

45:16.660 --> 45:17.140
有个数组

45:19.460 --> 45:19.980
有个数组

45:24.250 --> 45:24.770
随便写啊

45:27.010 --> 45:27.850
我要说什么呢

45:28.370 --> 45:34.850
做一个我们之前经常写的一个例子 就是输出数组中所有的

45:35.610 --> 45:36.050
基数

45:37.090 --> 45:42.450
要利用这个函数 假设 有些同学觉得 基数这一块有必要写个函数吗 当然没有必要

45:42.610 --> 45:47.850
当然没有必要 我是只是举例子 假设判断基数很复杂 假设判断基数很复杂

45:48.330 --> 45:51.730
好 我现在要做什么呢 输出数组中所谓的基数

45:52.770 --> 45:59.090
好 那么这个时候我要利用这个函数啊 来输出 那现在能能做到吗 你会发现很难做到

46:00.010 --> 46:03.970
很难做到 因为这个函数他又写死了

46:05.170 --> 46:09.690
他认为是基数 我叫输出啊 是基数的话 我就输出他是基数

46:10.250 --> 46:14.210
嗯 他不是基数的话 我就输出他不是基数 他认为是这样做的

46:14.670 --> 46:20.750
但是实际上我们不一定是这样做的 他是基数我们可能什么都不输出 他不是基数我们也可能什么都不输出

46:21.470 --> 46:23.310
就是他判断出来的结果过后

46:24.630 --> 46:26.870
做的剩下的事情不太一样

46:27.870 --> 46:30.030
如果你是基数我可能求和

46:30.750 --> 46:33.710
如果你是基数我可能要输出 如果你不是基数可能什么都不做

46:34.310 --> 46:39.870
就是他的结果了 就是拿到这个结果之后了 他有可能做的不太一样啊 做的不太一样

46:40.750 --> 46:41.630
就好比是啥呢

46:42.590 --> 46:43.310
好比是啥呢

46:45.190 --> 46:47.870
好比是你的微波炉 我再拿微波炉来举例子

46:48.830 --> 46:50.150
他给你打完饭之后

46:51.270 --> 46:55.870
他会比方说有一个微波炉啊 他功能很高级

46:56.910 --> 47:00.030
他给你打完饭之后呢 会自动往里边放盐放辣椒油

47:01.430 --> 47:01.950
放孜然

47:03.150 --> 47:04.470
放什么 放芥末

47:05.110 --> 47:08.790
那你想买这个 而且这个功能还不能关 这个功能是必须要给你加的

47:09.350 --> 47:12.790
这个微波炉还有用吗 你觉得他还有用吗 他是不是没用了

47:13.450 --> 47:17.610
你凭什么要制作主张呢 我这里判断出来的是不是基数

47:18.130 --> 47:24.290
你告诉我是不是基数就完了 你凭什么要制作组装器输出呢 谁让你输出的 没有人让你输出啊

47:24.770 --> 47:25.650
你干嘛要输出呢

47:26.490 --> 47:29.650
就是这个函数呢 他做了一些他不该做的事情

47:30.450 --> 47:34.610
导致的这个函数的通用性还是不够 还是不太够

47:35.050 --> 47:40.530
有说有些场地下面还是用不了他 我希望的是这个函数 凡是跟判断基础有关的都可以用

47:40.910 --> 47:44.310
但是呢 这里又麻烦了啊 我循环 循环这个数组

47:45.950 --> 47:47.550
i小于numbers 点links

47:49.510 --> 47:49.990
i加加

47:51.550 --> 47:54.510
好 那么我调用这个函数又麻烦了

47:55.310 --> 48:02.270
我把数据给你 你帮我来判断一下是不是基数就完事了 你谁让你输出的 我来搞定后面的事情

48:03.070 --> 48:04.270
好 那么这个东西怎么办

48:05.470 --> 48:09.870
也就是说我们的微波炉里边 我只希望他干嘛 加热

48:10.990 --> 48:15.390
剩下的事情 什么洗碗这些事情 需不需要你干 不需要你干 这是我的事情啊

48:15.870 --> 48:21.870
总有别的人帮我干这件事情 你不用去管 你帮我加热就完事了 不要去制作组绢做任何其他事情

48:22.390 --> 48:25.470
加热过后呢 你给我一个啥 你给我一个

48:26.190 --> 48:28.430
就是加热之后的菜就完事了

48:29.630 --> 48:31.390
比方说我让你把两个数相加

48:32.510 --> 48:37.710
相加完了过后 你把这个数字给我就行了 我要不要输出我来决定

48:38.490 --> 48:42.410
把这个数字拿到过后 我要做什么其他操作 我来决定 你不要去制作组绢

48:43.290 --> 48:46.690
好 那么这个东西叫啥呢 叫做反归值

48:49.180 --> 48:49.900
反归值

48:51.140 --> 48:54.300
什么叫反归值呢 就是函数运行后

48:55.860 --> 49:01.820
得到的结果 这个结果不是输出的结果 它不是输出的结果 是这个运行后得到的结果

49:02.660 --> 49:05.420
雕用函数时 雕用函数时

49:06.100 --> 49:07.460
雕用表达式

49:08.580 --> 49:08.980
的值

49:09.860 --> 49:12.980
就是函数的反归值

49:14.420 --> 49:14.860
什么意思

49:15.660 --> 49:16.140
什么意思

49:16.700 --> 49:22.540
就是说我这里判断出来了 它不是基础 对吧 不是基础 我这样写

49:22.900 --> 49:23.780
return force

49:24.660 --> 49:29.180
表示什么意思 反回force 反回一个数据 反回什么数据呢 force

49:30.380 --> 49:32.900
好 这样这里我得到的是一个基础

49:33.460 --> 49:36.460
好 我不去做任何输出 反回force

49:36.940 --> 49:37.700
反回force

49:38.600 --> 49:40.800
表示 反回去 反回去

49:42.360 --> 49:44.920
return 关键字是return 反回去

49:45.800 --> 49:46.960
那么就意味着什么呢

49:47.680 --> 49:51.360
函数雕用的时候 你看这个雕用函数是不是表达式

49:52.040 --> 49:53.200
雕用函数是表达式吧

49:53.920 --> 49:56.400
表达式的值就是这里的反归值

49:56.840 --> 49:59.880
比方说它是一个基础 ok 这个表达式反归的就是去

50:00.760 --> 50:02.880
它不是一个基础 它反归的就是force

50:03.320 --> 50:04.760
好 因此呢 我们在这里看

50:05.500 --> 50:06.500
这个表达是什么类型

50:06.900 --> 50:10.220
是不是布尔 对吧 它要么是true 要么是force 那是不是可以判断了

50:11.660 --> 50:12.380
是不是可以判断了

50:14.020 --> 50:17.460
是不是可以这样子写 可不可以 可以 判断是个表达式的值嘛

50:18.020 --> 50:20.780
表达式雕用函数之后 它如果是true

50:21.740 --> 50:22.660
表示是基础

50:23.340 --> 50:24.180
是基础怎么办呢

50:25.340 --> 50:27.340
输出 输出这个基础

50:28.140 --> 50:28.660
把它输出

50:31.420 --> 50:32.020
看一下

50:33.660 --> 50:36.060
然后你看 就把基础全部输出了

50:36.700 --> 50:39.740
好 那么现在 我们以后要求合 是不是

50:40.180 --> 50:40.700
求合

50:41.860 --> 50:45.340
要把基础相将加求合来呗 如果它是基础

50:46.300 --> 50:48.140
加等于 什么 求合

50:48.740 --> 50:49.540
纳姆斯埃

50:50.380 --> 50:51.540
最后输出 上

50:51.980 --> 50:52.580
你看 是不是

50:52.980 --> 50:53.820
通用了现在

50:54.740 --> 50:56.940
它又可以求合 又可以是基础 为什么呢

50:57.060 --> 51:01.380
因为这个函数里边 它并不处理接下来的事情 接下来的事情交给你来处理

51:01.380 --> 51:03.820
我只是在帮你判断 是不是基础

51:04.300 --> 51:05.700
只是在帮你判断 是不是基础

51:06.980 --> 51:08.100
它就更加通用了

51:08.500 --> 51:11.540
它只说它最核心的事情 就是判断 是不是基础

51:11.820 --> 51:13.860
其他的事情不该它管 它就一概不管

51:14.020 --> 51:15.740
它只是把判断的结果告诉你

51:16.540 --> 51:17.100
你看这意思吧

51:17.420 --> 51:19.700
它把这个结果告诉你 通过return

51:20.020 --> 51:21.500
把这个结果返回给你

51:22.620 --> 51:25.540
那么结果返回过后 这个函数调用者

51:25.780 --> 51:27.740
调用的表达是得到了就是这个结果

51:28.740 --> 51:31.100
好 我们再回忆一下 咱们之前有个函数叫propt

51:31.980 --> 51:32.820
我当时说了什么

51:33.540 --> 51:35.020
这个表达是返回的是什么

51:35.480 --> 51:36.480
返回的是致富串

51:37.920 --> 51:38.960
为什么返回的是致富串

51:39.120 --> 51:41.200
因为这个函数里边写了一个return

51:41.600 --> 51:44.440
它给了你用户的输入 给力的就是致富串

51:44.720 --> 51:46.560
所以说你能够再用变量来获取

51:47.680 --> 51:48.640
可以用变量来获取

51:49.680 --> 51:50.280
原来这意思吧

51:50.840 --> 51:51.640
那么这里也是一样

51:51.640 --> 51:53.920
当然 如果你这个代码看着有点头晕的话

51:53.920 --> 51:55.840
你可以先用一个变量把它保存一下

51:56.240 --> 51:56.920
判断结果

51:57.680 --> 51:58.760
先把我保存一下

51:58.920 --> 52:01.440
然后来在这里判断一下这个结果是真的还是假

52:01.960 --> 52:03.640
当然没有这个必要

52:04.260 --> 52:05.180
这是个表达是吗

52:05.180 --> 52:06.540
你直接把它放在里面也是一样的

52:08.180 --> 52:08.860
你看这个意思吧

52:09.700 --> 52:11.780
这就是return返回

52:12.300 --> 52:14.340
return的关键字还有一些别的用处

52:16.780 --> 52:25.300
return会直接结束整个函数的运行

52:25.980 --> 52:27.780
会直接结束整个函数的运行

52:28.260 --> 52:30.660
只要函数运行到return这个关键字

52:31.140 --> 52:32.180
运行到这个语句

52:32.260 --> 52:33.540
整个函数直接结束

52:33.820 --> 52:34.540
直接结束

52:35.380 --> 52:37.380
比方说咱们这里还一个代码

52:37.700 --> 52:38.380
还有一句代码

52:38.380 --> 52:39.620
假设还一句代码

52:39.900 --> 52:40.540
你想一想

52:40.700 --> 52:41.740
这个代码能运行吗

52:42.140 --> 52:42.820
能运行吗

52:43.340 --> 52:44.860
它永远不可能运行的

52:45.180 --> 52:47.140
你看有没有输说没有输出

52:47.300 --> 52:48.660
它多次运行到这个函数

52:48.660 --> 52:49.940
但是它没有输出这个代码

52:50.500 --> 52:51.340
为什么没有输出

52:51.460 --> 52:54.380
因为前边一定要么进EF要么进L

52:54.380 --> 52:55.540
它一定运行到return

52:55.700 --> 52:58.340
return的话会直接结束整个函数的运行

52:58.580 --> 53:00.020
遇到return就直接结束了

53:01.220 --> 53:02.220
所以说

53:03.660 --> 53:05.060
这个代码能不能这样子写

53:07.180 --> 53:08.020
能不能这样子写

53:10.210 --> 53:10.810
可不可以

53:11.770 --> 53:12.290
想一想

53:13.770 --> 53:14.570
可不可以这样写

53:15.290 --> 53:16.330
是不是可以这样写

53:16.690 --> 53:17.530
如果

53:17.970 --> 53:19.090
它是一个偶数

53:19.450 --> 53:21.090
返回了force不是结束吗

53:21.170 --> 53:21.890
返回force

53:22.810 --> 53:23.970
是不是后面不运行的

53:24.250 --> 53:24.970
不运行的

53:25.490 --> 53:27.090
如果进不了这个判断

53:27.730 --> 53:28.930
运行这个返回处

53:30.370 --> 53:32.090
有的时候公司里要求

53:32.370 --> 53:34.610
在函数里边写这种格式的时候

53:34.610 --> 53:35.530
这种类似格式的时候

53:35.530 --> 53:36.690
不允许你写l是

53:36.810 --> 53:38.650
因为这个l是看上去很繁琐

53:39.290 --> 53:41.890
当然有些公司他有这个要求

53:42.050 --> 53:43.170
看公司的具体要求

53:44.050 --> 53:46.890
return它会导致函数直接结束

53:47.930 --> 53:49.930
也就是说return还有一个

53:49.930 --> 53:51.330
就是有的时候return

53:51.850 --> 53:54.650
后面如果不跟任何数据

53:55.010 --> 53:56.170
不跟任何数据

53:56.850 --> 53:57.570
返回什么

53:57.890 --> 53:59.050
返回undefend

53:59.730 --> 54:01.050
它也会导致程序结束

54:01.050 --> 54:02.170
就是不是程序结束

54:02.330 --> 54:03.530
函数运行结束

54:03.930 --> 54:05.170
它返回的是undefend

54:05.670 --> 54:08.670
只是这一次函数运行结束

54:08.670 --> 54:09.830
下一次又重新来

54:10.110 --> 54:12.670
比如说这里我们返回的是undefend

54:13.670 --> 54:15.550
一样的这里就返回undefend

54:16.030 --> 54:16.470
就完事了

54:17.910 --> 54:18.990
还有一个点

54:19.310 --> 54:23.030
就是如果函数中

54:23.470 --> 54:26.910
没有书写return

54:28.190 --> 54:29.870
则该函数

54:30.510 --> 54:32.630
该函数会在

54:32.970 --> 54:38.330
莫为自动returnundefend

54:38.890 --> 54:40.090
也就是说一个函数

54:40.250 --> 54:42.890
它如果你没有自己手动书写返回

54:42.890 --> 54:44.170
没有手动返回

54:44.330 --> 54:46.850
那么这个函数它会自动返回一个undefend

54:47.330 --> 54:49.250
这就是为什么

54:49.690 --> 54:51.290
console.log

54:51.450 --> 54:53.450
这个表达是undefend的

54:54.290 --> 54:58.130
你看我们在书写console.log

54:58.130 --> 54:58.970
随便输出一个值

54:58.970 --> 55:00.130
对吧输出一个值

55:00.370 --> 55:01.490
这是它输出的值

55:01.550 --> 55:03.550
这是这个表达式的返回结果

55:03.750 --> 55:05.630
整个这个表达式是函数调用

55:05.630 --> 55:06.750
在调用函数

55:06.750 --> 55:07.950
调用这个node函数

55:07.950 --> 55:09.190
给它传了一个参数

55:09.430 --> 55:11.790
这个函数它没有返回结果

55:11.790 --> 55:12.830
它是undefend

55:13.270 --> 55:15.310
说明这个函数里边它没有写return

55:15.310 --> 55:17.310
或者是它写了一个returnundefend

55:17.630 --> 55:19.470
或者是它写了一个return分号

55:20.350 --> 55:22.230
都会导致返回undefend

55:23.310 --> 55:25.230
这就是函数的返回值

55:26.830 --> 55:28.630
了解到函数的返回之过后

55:28.630 --> 55:29.710
我们再来一些练习

55:30.690 --> 55:31.690
比方说

55:32.890 --> 55:33.610
比方说

55:34.090 --> 55:36.450
咱们对一个数组求和

55:37.650 --> 55:38.610
数组求和

55:38.890 --> 55:40.290
那么现在你会怎么写了

55:42.130 --> 55:43.890
我们把之前对数组求和拿过来

55:46.520 --> 55:47.600
现在你会怎么写了

55:48.280 --> 55:50.400
这不是一个很好的写法

55:50.960 --> 55:54.080
因为它又把这个和拉来输出了

55:54.080 --> 55:55.240
谁让你输出了

55:55.240 --> 55:56.240
不要化蛇天主

55:56.240 --> 55:57.120
谁让你输出的

55:57.400 --> 55:58.520
不要去输出

55:58.760 --> 56:00.120
因为你一旦输出的话

56:00.140 --> 56:01.580
麻烦又来了

56:01.740 --> 56:03.220
比方说我们这里

56:03.620 --> 56:05.540
比方说这里有三个数组

56:06.820 --> 56:07.980
Number 1

56:08.220 --> 56:09.220
Number 1

56:09.340 --> 56:10.780
一个数组

56:11.660 --> 56:12.740
两个数组吧

56:12.740 --> 56:13.540
两个数组

56:14.740 --> 56:15.580
两个数组

56:17.140 --> 56:17.980
Number 2

56:18.260 --> 56:19.420
我现在要做的是

56:19.540 --> 56:21.940
把两个数组的所有和相加

56:22.660 --> 56:24.500
把两个数组的求和结果相加

56:25.380 --> 56:26.340
到底怎么弄了

56:26.340 --> 56:27.540
这个函数又不能用了

56:27.700 --> 56:29.180
因为这个函数它又以为

56:29.640 --> 56:30.640
求和之后是输出

56:30.640 --> 56:31.760
谁让你输出了

56:32.200 --> 56:32.880
干嘛

56:33.080 --> 56:33.960
返回

56:35.160 --> 56:36.920
把这个求和结果返回

56:37.360 --> 56:38.640
这样才是正确的做法

56:38.920 --> 56:40.120
那么这个函数就通用了

56:40.120 --> 56:40.520
看到没

56:40.520 --> 56:41.120
通用了

56:41.120 --> 56:41.800
你看着

56:41.800 --> 56:43.400
我要输出这两个

56:43.640 --> 56:44.640
两个相加的结果

56:44.640 --> 56:45.520
直接来了

56:45.520 --> 56:46.400
你看我怎么写

56:46.960 --> 56:48.680
Sum of array

56:49.240 --> 56:50.320
Number 1

56:50.480 --> 56:51.080
你看一下

56:51.080 --> 56:51.800
调用这个函数

56:51.800 --> 56:54.200
是不是得到第一个数组的和

56:54.200 --> 56:54.760
对吧

56:54.760 --> 56:56.360
返回的结果就是一个数字

56:56.640 --> 56:58.000
返回的结果就是一个数字

56:58.020 --> 56:59.380
因为他把这个东西返回了

56:59.620 --> 57:00.900
返回的结果就是数字

57:00.900 --> 57:03.420
其实你没有必要去关心函数里边怎么写的

57:03.420 --> 57:04.700
你只要看他的名字

57:04.700 --> 57:05.420
他就是求和

57:05.420 --> 57:06.620
他肯定要得到一个结果

57:07.140 --> 57:08.460
他肯定要会给我一个结果

57:08.460 --> 57:10.140
如果没有给我结果是他的问题

57:10.140 --> 57:11.020
跟我没关系

57:11.500 --> 57:12.460
是别人的问题

57:12.580 --> 57:14.420
就是以后你们的公司里边写代码的时候

57:14.740 --> 57:15.540
往往是

57:15.540 --> 57:16.300
有可能是

57:16.300 --> 57:18.060
你写的函数别人在用

57:18.380 --> 57:19.860
别人的写的函数你在用

57:19.860 --> 57:21.340
可能会出现这么一种情况

57:21.580 --> 57:23.260
那么你去用别人的函数的时候

57:23.260 --> 57:25.700
你没有必要把他的函数全部读一遍

57:25.700 --> 57:27.900
你只需要看他的什么功能就行了

57:28.740 --> 57:31.100
如果他用的时候跟他的功能

57:31.100 --> 57:32.140
描述不一样

57:32.540 --> 57:33.180
描述不一样

57:33.180 --> 57:34.140
他肯定是他的问题

57:35.140 --> 57:36.900
如果你没有按照他的描述来使用

57:36.900 --> 57:37.780
那是你的问题

57:39.780 --> 57:43.540
相当于是你买了一个微波炉

57:43.540 --> 57:44.820
你把它当洗一万劲用

57:44.820 --> 57:46.340
那出的问题肯定是你自己的问题

57:46.980 --> 57:48.620
如果你是正常的使用微波炉

57:48.620 --> 57:49.660
出的问题是他的问题

57:51.740 --> 57:52.860
你又正常用就行了

57:53.420 --> 57:55.100
你看我把第一个函数的核

57:55.100 --> 57:56.540
第一个数组的核拿出来

57:56.540 --> 57:57.900
加上第二个数组的核

57:58.660 --> 57:59.220
看一下

58:01.930 --> 58:03.050
你看一下有了函数过后

58:03.050 --> 58:04.770
是不是方便非常非常多了

58:04.770 --> 58:05.370
对吧

58:05.370 --> 58:06.650
要不要输出

58:06.650 --> 58:08.050
拿到这个结构过后干嘛

58:08.050 --> 58:09.130
你不要管

58:09.130 --> 58:10.130
你这个函数

58:10.970 --> 58:11.690
你不要管

58:11.690 --> 58:12.650
我来处理

58:12.650 --> 58:13.450
我来处理

58:14.090 --> 58:14.970
这是个例子

58:14.970 --> 58:15.930
再来个例子

58:15.930 --> 58:17.210
函数这一块很重要

58:17.210 --> 58:19.130
特别是我们第一节课就非常非常重要

58:19.130 --> 58:20.850
因此多来一些练习

58:22.570 --> 58:24.210
判断一个数

58:24.210 --> 58:25.730
是不是数数

58:26.710 --> 58:29.990
以前折磨的你们预先预始的这个题

58:29.990 --> 58:31.630
现在有了函数过后

58:31.630 --> 58:33.150
告诉你你这辈子

58:34.430 --> 58:36.670
有没有为别人拼过命的

58:36.670 --> 58:37.790
你这辈子

58:38.310 --> 58:40.310
只需要写这一次就行了

58:40.310 --> 58:41.750
只需要写这一次就行了

58:42.150 --> 58:42.950
我发誓

58:43.430 --> 58:44.310
再也不写了

58:44.310 --> 58:45.950
当然我每一届给学生讲的时候

58:45.950 --> 58:46.510
我都发誓

58:46.510 --> 58:47.870
下一届我又得重新写

58:48.750 --> 58:50.510
好只需要写这一次就行了

58:50.510 --> 58:51.270
方形

58:51.270 --> 58:52.190
isprime

58:52.190 --> 58:53.350
isprime

58:53.350 --> 58:54.750
给我一个数字n

58:54.890 --> 58:56.810
我来判断他是不是数数

58:56.810 --> 58:58.970
数字n是不是数数呢

58:58.970 --> 59:00.170
是不是一个查照问题

59:00.170 --> 59:00.410
对吧

59:00.410 --> 59:01.290
isprime

59:01.290 --> 59:02.010
forced

59:02.010 --> 59:03.530
forced

59:03.530 --> 59:04.170
好

59:04.890 --> 59:05.650
然后循环

59:05.650 --> 59:06.090
对吧

59:06.090 --> 59:06.610
循环

59:06.610 --> 59:07.490
i等于2

59:07.490 --> 59:09.290
i小于n-1

59:09.290 --> 59:09.890
n-1

59:09.890 --> 59:10.730
i加加

59:11.730 --> 59:15.050
如果发现n除以i的余数等于0

59:15.050 --> 59:15.890
如果能整出

59:15.890 --> 59:16.890
说明什么

59:16.890 --> 59:17.610
找到了

59:17.610 --> 59:18.170
对吧

59:18.170 --> 59:19.250
找到了

59:19.250 --> 59:20.250
break

59:20.250 --> 59:20.410
好

59:20.410 --> 59:21.530
最后来判断

59:21.530 --> 59:24.690
如果isprime的找到了

59:24.710 --> 59:26.150
如果找到了

59:26.150 --> 59:26.830
是什么

59:26.830 --> 59:27.990
他就不是数数

59:27.990 --> 59:29.670
return false

59:29.670 --> 59:30.670
我不是输出

59:30.670 --> 59:31.270
不是输出

59:31.270 --> 59:33.070
我是告诉你结果

59:33.070 --> 59:35.270
判断的结果就是不是输出

59:35.270 --> 59:36.150
else

59:36.150 --> 59:37.990
就return true

59:37.990 --> 59:38.670
return true

59:38.670 --> 59:40.750
当然这里还要判断一个就是什么

59:40.750 --> 59:41.310
什么

59:41.310 --> 59:46.110
就是n小于1的情况

59:46.110 --> 59:47.270
小于2的情况

59:47.270 --> 59:49.110
小于2他也不是输出

59:49.110 --> 59:50.150
你看我就用返回了

59:51.950 --> 59:53.670
而且这个代码还可以优化

59:55.150 --> 59:56.230
你看着

59:56.230 --> 59:57.630
我这里找到了吧

59:57.630 --> 59:58.870
是不是找到了

59:58.870 --> 01:00:00.990
找到了过后

01:00:00.990 --> 01:00:02.830
是不是一定不是数数

01:00:02.830 --> 01:00:03.790
对吧

01:00:03.790 --> 01:00:06.190
找到过后是不是一定不是数数

01:00:06.190 --> 01:00:08.790
找到有额外的数字能整出他

01:00:08.790 --> 01:00:09.910
所以他不是数数

01:00:09.910 --> 01:00:10.950
直接返回 false

01:00:10.950 --> 01:00:11.750
直接返回

01:00:11.750 --> 01:00:13.470
后边的代码全部不运行了

01:00:13.470 --> 01:00:15.270
一个不运行了

01:00:15.270 --> 01:00:16.030
换句话说

01:00:16.030 --> 01:00:17.710
除了这个for寻还

01:00:17.710 --> 01:00:19.790
除了这个for寻还

01:00:19.790 --> 01:00:20.990
都还没有返回 false

01:00:20.990 --> 01:00:22.110
是不是一定是

01:00:22.110 --> 01:00:23.390
输出

01:00:23.450 --> 01:00:25.450
这个变量不要了

01:00:25.450 --> 01:00:26.730
变成这样子

01:00:26.730 --> 01:00:27.730
当然你最后

01:00:27.730 --> 01:00:29.730
最后还可以先判断一下

01:00:29.730 --> 01:00:31.490
判断一下就是小于2的情况

01:00:31.490 --> 01:00:34.650
如果n小于2return false

01:00:34.650 --> 01:00:36.490
不是数数

01:00:36.490 --> 01:00:38.250
如果n小于2

01:00:38.250 --> 01:00:39.170
直接结束

01:00:39.170 --> 01:00:40.890
函数直接结束

01:00:40.890 --> 01:00:42.730
如果没有结束运行寻还

01:00:42.730 --> 01:00:44.490
那就是大于等于2的情况

01:00:44.490 --> 01:00:45.610
运行寻还

01:00:45.610 --> 01:00:47.290
运行寻还的时候

01:00:47.290 --> 01:00:49.370
如果找到了一个额外的数字能整出他

01:00:49.370 --> 01:00:50.570
返回 false

01:00:50.570 --> 01:00:51.570
不是数数

01:00:51.590 --> 01:00:53.590
如果除了寻还都还没有结束

01:00:53.590 --> 01:00:55.150
说明他没有进这个义父

01:00:55.150 --> 01:00:55.870
进了这个义父

01:00:55.870 --> 01:00:58.350
他一定不会运行三十七行了

01:00:58.350 --> 01:00:58.950
进了这个义父

01:00:58.950 --> 01:01:00.350
一定不会运行三十七行

01:01:00.350 --> 01:01:01.550
所以运行到三十七行

01:01:01.550 --> 01:01:02.390
一定是没有找到

01:01:02.390 --> 01:01:03.830
没有找到返回处

01:01:03.830 --> 01:01:04.830
返回处

01:01:06.150 --> 01:01:08.350
函数一直不断有写完了

01:01:08.350 --> 01:01:09.150
接下来

01:01:09.150 --> 01:01:11.230
神奇的事情

01:01:11.230 --> 01:01:13.830
让这个世界变得很美好的事情发生了

01:01:16.150 --> 01:01:18.150
看着

01:01:18.150 --> 01:01:20.150
随便写

01:01:20.150 --> 01:01:21.150
瞎写

01:01:22.030 --> 01:01:30.500
输出这个输出里面所有的输出

01:01:30.500 --> 01:01:31.300
看着

01:01:31.300 --> 01:01:31.900
我不说话

01:01:31.900 --> 01:01:43.240
你们用心去体会

01:01:43.240 --> 01:01:44.160
告诉我是不是写完了

01:01:46.160 --> 01:01:47.440
告诉我是不是写完了

01:01:47.440 --> 01:01:48.560
还有谁

01:01:48.560 --> 01:01:49.640
还有啥

01:01:49.640 --> 01:01:54.450
是不是写完了

01:01:54.450 --> 01:01:55.410
输出这个输出里面

01:01:55.410 --> 01:01:56.090
所谓的输出

01:01:57.690 --> 01:01:58.130
没问题吧

01:01:59.450 --> 01:02:04.110
所有的输出相加

01:02:04.110 --> 01:02:05.310
所谓的输出相加

01:02:07.310 --> 01:02:08.750
你告诉我这个代码

01:02:08.750 --> 01:02:10.150
这个代码好阅读

01:02:10.170 --> 01:02:12.970
Pran的代码的意思就是输出的意思

01:02:12.970 --> 01:02:14.370
意思Pran是不是输出

01:02:14.370 --> 01:02:15.730
你告诉我这个代码好阅读

01:02:15.730 --> 01:02:17.850
还是之前的代码好阅读

01:02:17.850 --> 01:02:19.850
我都不说什么

01:02:19.850 --> 01:02:21.610
什么解决重复代码的问题了

01:02:21.610 --> 01:02:23.090
都不说这些问题了

01:02:23.090 --> 01:02:24.010
我就告诉你

01:02:24.010 --> 01:02:24.850
好不好阅读吧

01:02:24.850 --> 01:02:25.810
你就说好不好阅读

01:02:26.730 --> 01:02:27.810
贼好阅读

01:02:28.810 --> 01:02:30.530
循环输足

01:02:30.530 --> 01:02:31.650
一个个拿出来看

01:02:31.650 --> 01:02:33.250
看一下是不是输出

01:02:34.130 --> 01:02:35.370
太优雅了

01:02:35.370 --> 01:02:37.490
太优雅了

01:02:37.630 --> 01:02:39.630
我这里夹得啥玩意儿

01:02:41.390 --> 01:02:42.630
如果是输出的话

01:02:42.630 --> 01:02:45.910
把它夹到囚核里面

01:02:46.590 --> 01:02:46.950
保存

01:02:49.070 --> 01:02:52.030
以后判断输出还劳活吗

01:02:52.030 --> 01:02:53.030
不劳活了吧

01:02:53.030 --> 01:02:53.870
有了函数过后

01:02:53.870 --> 01:02:55.430
让函数来解决这个问题

01:02:55.430 --> 01:02:57.950
函数只需要写一次就行了

01:02:57.950 --> 01:02:58.830
以后再也不用写了

01:03:00.430 --> 01:03:01.870
这就是函数的好处

01:03:01.870 --> 01:03:03.550
它不仅能解决重复代码

01:03:03.550 --> 01:03:05.030
还可以让我们的程序结构

01:03:05.030 --> 01:03:06.390
变得非常非常清晰

01:03:07.550 --> 01:03:08.950
容易阅读容易维护

01:03:10.270 --> 01:03:11.270
好了这就是函数

01:03:12.550 --> 01:03:13.870
函数的参数和返回值

01:03:15.190 --> 01:03:16.190
好最后一块

01:03:16.190 --> 01:03:17.990
最后一块给大家说一下这个

01:03:18.870 --> 01:03:20.550
函数的一个注释

01:03:20.550 --> 01:03:22.070
其实也不叫函数的注释

01:03:22.070 --> 01:03:23.270
叫做文档注释

01:03:25.110 --> 01:03:27.830
文档注释它也是一种注释

01:03:27.830 --> 01:03:30.270
咱们之前说过丹行注释

01:03:30.270 --> 01:03:31.310
多行注释

01:03:32.110 --> 01:03:33.470
还有个文档注释

01:03:33.470 --> 01:03:36.310
文档注释是一个写杠两个星号

01:03:36.330 --> 01:03:38.210
然后以星号写杠结尾

01:03:39.130 --> 01:03:41.010
通常为了格式标准的话

01:03:41.010 --> 01:03:42.410
中间也会写星号

01:03:42.410 --> 01:03:43.570
中间也会写星号

01:03:44.170 --> 01:03:44.930
中间也会写

01:03:46.770 --> 01:03:47.810
巴克当里面打不出来

01:03:47.810 --> 01:03:50.930
在这里中间也会写星号

01:03:50.930 --> 01:03:51.890
这就是文档注释

01:03:52.890 --> 01:03:54.610
在介石里边文档注释

01:03:54.610 --> 01:03:55.770
可以注释变量

01:03:55.770 --> 01:03:57.210
也可以注释函数

01:03:57.210 --> 01:03:58.490
文档注释有个好处

01:03:58.490 --> 01:03:59.370
什么好处

01:03:59.370 --> 01:04:00.050
给大家看一下

01:04:01.930 --> 01:04:02.850
关于文档注释

01:04:04.170 --> 01:04:04.610
看着

01:04:05.590 --> 01:04:06.510
我定一个变量

01:04:06.510 --> 01:04:07.310
定一个变量

01:04:09.110 --> 01:04:11.750
比方说写个数组

01:04:12.390 --> 01:04:14.230
前面我该打一个文档注释

01:04:15.230 --> 01:04:16.310
一个星号一个结束

01:04:17.470 --> 01:04:18.910
接下来我们来写这个星号

01:04:19.590 --> 01:04:21.510
这个该写个注释

01:04:22.390 --> 01:04:23.410
Num

01:04:23.410 --> 01:04:24.110
表示什么意思

01:04:24.110 --> 01:04:25.670
表示一个数字的数组

01:04:25.670 --> 01:04:27.110
一个数字的数组

01:04:28.390 --> 01:04:30.110
接下来我们用鼠标指的Num

01:04:31.590 --> 01:04:33.190
我们用打出Num

01:04:33.190 --> 01:04:33.990
你看

01:04:34.010 --> 01:04:35.450
当我们打出Num的时候

01:04:35.450 --> 01:04:36.410
它是不是有提示

01:04:36.410 --> 01:04:37.090
对吧

01:04:37.090 --> 01:04:38.850
文档注释它的好处在于

01:04:38.850 --> 01:04:39.690
你用它的时候

01:04:39.690 --> 01:04:40.530
它就会提示

01:04:41.290 --> 01:04:43.330
我们通常可以利用文档注释

01:04:43.330 --> 01:04:45.210
给函数进行打注释

01:04:45.210 --> 01:04:46.290
这样子的好处在于

01:04:46.290 --> 01:04:47.570
如果我们函数写得多了

01:04:47.570 --> 01:04:49.730
以后我们会写很多很多函数的

01:04:49.730 --> 01:04:52.850
一个页面里边函数的数量可能要上百个

01:04:52.850 --> 01:04:56.130
那你可能会忘记了函数的名字是啥

01:04:56.130 --> 01:04:57.290
这些函数的意识是啥

01:04:57.290 --> 01:04:58.490
可能就忘记了

01:04:58.490 --> 01:05:00.730
所以说我们一般会给函数的

01:05:00.730 --> 01:05:02.370
打上文档注释

01:05:02.430 --> 01:05:05.110
好 我们来看一下函数打上文档注释

01:05:06.590 --> 01:05:08.430
方形 比方说

01:05:08.430 --> 01:05:12.110
咱们写个函数上 求合

01:05:12.110 --> 01:05:14.110
两个数相加求合 返回

01:05:14.110 --> 01:05:15.990
直接返回A加B

01:05:15.990 --> 01:05:17.790
把这个表达式的结果返回

01:05:17.790 --> 01:05:19.630
虽然是一个很简单的函数

01:05:19.630 --> 01:05:21.430
主要是来说一下文档注释

01:05:21.430 --> 01:05:22.550
文档注释写哪了

01:05:22.550 --> 01:05:23.950
写这个函数上边

01:05:23.950 --> 01:05:25.990
一个写杠 两个新号

01:05:25.990 --> 01:05:28.950
直接写 直接回车

01:05:28.950 --> 01:05:31.070
然后一个新号

01:05:31.090 --> 01:05:34.450
一个新号 一个写杠结束

01:05:34.450 --> 01:05:36.250
好 写上文档注释

01:05:36.250 --> 01:05:37.930
这里写上函数的含义

01:05:37.930 --> 01:05:39.770
是什么 求合

01:05:39.770 --> 01:05:41.370
两个数求合

01:05:41.370 --> 01:05:43.530
两个数求合

01:05:43.530 --> 01:05:44.730
好 看一下

01:05:44.730 --> 01:05:46.690
咱们到时候用这个函数的时候

01:05:46.690 --> 01:05:47.730
你看一下

01:05:47.730 --> 01:05:49.250
用这个函数的时候

01:05:49.250 --> 01:05:50.650
这里

01:05:50.650 --> 01:05:52.370
你看 它现在提示你

01:05:52.370 --> 01:05:54.450
这个函数的意识是两个数求合

01:05:54.450 --> 01:05:57.130
我们之后就可以看这个提示就知道了

01:05:57.130 --> 01:05:58.250
不用去看这个函数代码

01:05:58.250 --> 01:06:00.970
只看这个提示就知道这个函数是什么意思了

01:06:01.710 --> 01:06:02.670
好 接下来

01:06:02.670 --> 01:06:05.070
这两个参数也可以打注释

01:06:05.070 --> 01:06:06.590
参数怎么打注释呢

01:06:06.590 --> 01:06:07.590
这样子写

01:06:07.590 --> 01:06:08.550
我记得

01:06:08.550 --> 01:06:09.550
我记得这里

01:06:09.550 --> 01:06:10.910
VSCO是有插件的

01:06:10.910 --> 01:06:13.470
可以瞬间打出来的

01:06:13.470 --> 01:06:15.750
好像要单独建一个介石文件

01:06:15.750 --> 01:06:16.830
我们来试一下

01:06:16.830 --> 01:06:18.030
单独建一个介石文件

01:06:18.030 --> 01:06:21.150
把它变成介石

01:06:23.470 --> 01:06:25.270
把它变成介石文件

01:06:25.270 --> 01:06:26.510
把它变成介石文件过后

01:06:26.510 --> 01:06:28.230
它可以自动出来

01:06:28.230 --> 01:06:29.430
因为一般来说

01:06:29.430 --> 01:06:30.870
我们在写代码的时候

01:06:30.890 --> 01:06:32.610
不太会直接在页面上写介石

01:06:32.610 --> 01:06:35.010
一般会单独去写介石文件

01:06:35.010 --> 01:06:36.410
介石文件里边打两个新号

01:06:36.410 --> 01:06:36.970
你看一回车

01:06:36.970 --> 01:06:38.170
它自动出来了

01:06:38.170 --> 01:06:39.690
自动出来了

01:06:39.690 --> 01:06:41.410
上边写函数的注释

01:06:41.410 --> 01:06:43.050
就是求合

01:06:43.050 --> 01:06:44.850
两个数求合

01:06:44.850 --> 01:06:46.130
下边是一个指令

01:06:46.130 --> 01:06:47.570
这个指令它不会运行的

01:06:47.570 --> 01:06:48.410
都没有什么意义

01:06:48.410 --> 01:06:49.650
它主要是

01:06:49.650 --> 01:06:50.530
标识一下

01:06:50.530 --> 01:06:53.370
这个地方是给A这个参数打上一个注释

01:06:53.370 --> 01:06:54.250
这个新号

01:06:54.250 --> 01:06:56.290
大功号里边写个新号表什么意思呢

01:06:56.290 --> 01:06:57.770
表示A的内行

01:06:57.770 --> 01:06:58.970
可以是任意内行

01:06:58.970 --> 01:07:00.730
就是你该传任何数据都可以

01:07:00.790 --> 01:07:02.110
它没有验证的

01:07:02.110 --> 01:07:03.510
当然那里可以告诉它

01:07:03.510 --> 01:07:05.790
这里必须要是个number内行

01:07:05.790 --> 01:07:07.270
这里必须要是个number

01:07:07.270 --> 01:07:08.750
主要是起个提示的作用

01:07:08.750 --> 01:07:09.870
它不会运行的

01:07:09.870 --> 01:07:11.030
这些代码都不会运行的

01:07:11.030 --> 01:07:12.430
这是注释

01:07:12.430 --> 01:07:13.990
然后我们再来看一下

01:07:13.990 --> 01:07:14.350
上

01:07:16.510 --> 01:07:17.710
看一下

01:07:17.710 --> 01:07:18.510
上

01:07:18.510 --> 01:07:19.470
你看

01:07:19.470 --> 01:07:20.510
它就告诉你

01:07:20.510 --> 01:07:22.070
两个数求合

01:07:22.070 --> 01:07:23.750
然后其中有两个参数

01:07:23.750 --> 01:07:25.270
A和B

01:07:25.270 --> 01:07:25.390
好

01:07:25.390 --> 01:07:26.590
我们继续写

01:07:26.590 --> 01:07:27.550
小过号你看

01:07:27.550 --> 01:07:30.070
它第一个参数

01:07:30.070 --> 01:07:31.610
它告诉你是一个number内行

01:07:31.610 --> 01:07:32.370
那么你传的

01:07:32.370 --> 01:07:33.930
传数据的时候是不是就知道了

01:07:33.930 --> 01:07:35.210
不要传其他数据

01:07:35.210 --> 01:07:36.330
传一个数字

01:07:36.330 --> 01:07:38.450
它是对数字求合

01:07:38.450 --> 01:07:40.570
我们也可以给参数写上数字

01:07:40.570 --> 01:07:42.810
第一个数字

01:07:42.810 --> 01:07:45.090
这是第二个数字

01:07:45.090 --> 01:07:48.250
看一下

01:07:48.250 --> 01:07:48.850
第一个数字

01:07:48.850 --> 01:07:49.570
你看

01:07:49.570 --> 01:07:51.610
它就提示你第一个数字

01:07:51.610 --> 01:07:52.330
兜号你看

01:07:52.330 --> 01:07:54.130
它就提示你第二个数字

01:07:54.130 --> 01:07:55.610
它就提个提示作用

01:07:55.610 --> 01:07:58.290
非常方便

01:07:58.290 --> 01:07:59.370
然后呢

01:07:59.370 --> 01:08:00.930
返回内行

01:08:00.950 --> 01:08:02.510
返回的东西是什么呢

01:08:02.510 --> 01:08:04.430
我们也可以写返回内行

01:08:04.430 --> 01:08:05.230
A

01:08:05.230 --> 01:08:07.630
returns

01:08:07.630 --> 01:08:08.870
返回什么呢

01:08:08.870 --> 01:08:11.110
返回的内行是number

01:08:11.110 --> 01:08:12.190
返回的内行是number

01:08:12.190 --> 01:08:13.990
当然这些都是提示

01:08:13.990 --> 01:08:15.790
仅提个提示的作用

01:08:15.790 --> 01:08:18.470
代码怎么写还是看你的代码

01:08:18.470 --> 01:08:20.910
只是提个提示的作用

01:08:20.910 --> 01:08:22.830
相加的结果

01:08:22.830 --> 01:08:24.470
返回的是相加的结果

01:08:24.470 --> 01:08:25.430
咱们再来看一下

01:08:25.430 --> 01:08:26.750
这个上指着它

01:08:26.750 --> 01:08:28.030
它告诉你看

01:08:28.030 --> 01:08:29.470
返回的是相加的结果

01:08:29.470 --> 01:08:30.810
通过看这个

01:08:30.810 --> 01:08:31.810
通过文档注释

01:08:31.810 --> 01:08:34.090
我们就可以详细的告诉

01:08:34.090 --> 01:08:35.170
函数的调用者

01:08:35.170 --> 01:08:36.650
就调用这个函数的人

01:08:36.650 --> 01:08:38.250
他就知道怎么去调用了

01:08:38.250 --> 01:08:39.050
我传一个数字

01:08:39.050 --> 01:08:39.570
传两个数字

01:08:39.570 --> 01:08:41.210
然后得到相加的结果

01:08:41.210 --> 01:08:42.490
当我们传的时候

01:08:42.490 --> 01:08:43.650
我们就非常清楚了

01:08:43.650 --> 01:08:43.970
你看

01:08:43.970 --> 01:08:44.730
它就会告诉你

01:08:44.730 --> 01:08:46.530
得到了是相加的结果

01:08:46.530 --> 01:08:47.650
得到了是一个number

01:08:47.650 --> 01:08:48.450
得到了是一个number

01:08:48.450 --> 01:08:49.490
你看冒号后面

01:08:49.490 --> 01:08:50.130
它就会提示你

01:08:50.130 --> 01:08:51.930
它是个number

01:08:51.930 --> 01:08:53.050
那么既然它是个number

01:08:53.050 --> 01:08:54.570
那我能不能用个辩量来接收

01:08:54.570 --> 01:08:56.970
肯定是可以的

01:08:56.970 --> 01:08:58.210
这就是一个文档注释

01:08:58.210 --> 01:08:59.050
非常简单

01:08:59.190 --> 01:09:01.670
主要是起一个注释的作用

01:09:01.670 --> 01:09:02.750
一般来我们把它写到

01:09:02.750 --> 01:09:04.030
单独的借识文件里边

01:09:04.030 --> 01:09:05.750
文档注释会自动出来

01:09:05.750 --> 01:09:06.630
以写一个写杠

01:09:06.630 --> 01:09:08.550
我们再来一次

01:09:08.550 --> 01:09:10.550
随便写个函数

01:09:10.550 --> 01:09:11.910
easeprime

01:09:11.910 --> 01:09:13.710
我再来使用一下注释

01:09:13.710 --> 01:09:14.590
这里边我就不写了

01:09:14.590 --> 01:09:15.470
啥都不写

01:09:15.470 --> 01:09:17.310
主要是写一下文档注释

01:09:17.310 --> 01:09:18.710
写到函数上面

01:09:18.710 --> 01:09:20.390
文档注释

01:09:20.390 --> 01:09:21.830
判断一个数

01:09:21.830 --> 01:09:23.190
判断一个数

01:09:23.190 --> 01:09:25.630
是不是数数

01:09:25.630 --> 01:09:27.590
这里传进来一个什么

01:09:27.650 --> 01:09:29.810
传进来一个number

01:09:29.810 --> 01:09:30.610
n

01:09:30.610 --> 01:09:31.890
它的意思是什么

01:09:31.890 --> 01:09:34.650
要判断的数

01:09:34.650 --> 01:09:35.730
返回的是什么

01:09:35.730 --> 01:09:36.690
returns

01:09:36.690 --> 01:09:38.930
返回的是一个布尔

01:09:38.930 --> 01:09:40.930
返回的是个布尔

01:09:40.930 --> 01:09:42.090
返回的是什么意思

01:09:42.090 --> 01:09:46.390
是否是数数

01:09:46.390 --> 01:09:48.190
然后我们指着这个函数

01:09:48.190 --> 01:09:50.310
你看它就会告诉你

01:09:50.310 --> 01:09:52.030
传一个number进来

01:09:52.030 --> 01:09:54.310
返回的是一个布尔

01:09:54.310 --> 01:09:56.070
当然我这个函数少都没返回

01:09:56.070 --> 01:09:57.910
返回的实际上是Nd

01:09:57.970 --> 01:09:59.290
返回的实际上是Nd

01:09:59.290 --> 01:10:01.610
但是通过注释我们就可以

01:10:01.610 --> 01:10:03.210
就可以在使用的时候

01:10:03.210 --> 01:10:04.650
更加清楚函数的功能

01:10:07.850 --> 01:10:08.250
好了

01:10:08.250 --> 01:10:09.610
咱们这节课讲完了

01:10:09.610 --> 01:10:10.410
时间又练长

01:10:10.410 --> 01:10:11.610
东西有点多

01:10:11.610 --> 01:10:13.730
很正常函数这一块一开始

01:10:13.730 --> 01:10:16.530
这个语法是最积处这一块

01:10:16.530 --> 01:10:17.570
这一块东西是最积处

01:10:17.570 --> 01:10:19.130
最重要的这一块

01:10:19.130 --> 01:10:20.530
因此我们作业比较多

01:10:20.530 --> 01:10:21.530
作业很多

01:10:22.810 --> 01:10:24.330
这些作业分为两块

01:10:24.330 --> 01:10:25.810
一个是通用函数编写

01:10:25.810 --> 01:10:26.890
一个是函数使用

01:10:26.910 --> 01:10:27.950
什么意思呢

01:10:27.950 --> 01:10:28.990
通用函数编写的

01:10:28.990 --> 01:10:31.110
我让你去新建一个介式文件

01:10:32.110 --> 01:10:33.670
编写一下函数

01:10:33.670 --> 01:10:34.630
这些函数以后

01:10:34.630 --> 01:10:35.910
你们只写一次就行了

01:10:35.910 --> 01:10:37.270
哪怕以后你们到工作中

01:10:37.270 --> 01:10:38.310
要用到类似功能

01:10:38.310 --> 01:10:40.510
你们都可以用这些函数

01:10:40.510 --> 01:10:41.110
建议大家

01:10:41.110 --> 01:10:42.870
建议大家用这种方式

01:10:42.870 --> 01:10:44.070
建一个文件夹

01:10:44.070 --> 01:10:45.590
扛门

01:10:45.590 --> 01:10:46.350
公共的

01:10:46.350 --> 01:10:47.670
公共的文件夹

01:10:47.670 --> 01:10:49.670
这里边写上一些介式文件

01:10:49.670 --> 01:10:50.190
比方说

01:10:50.190 --> 01:10:52.230
我们这里写个介式文件

01:10:52.230 --> 01:10:52.990
介式文件

01:10:54.430 --> 01:10:55.590
写一个

01:10:55.650 --> 01:10:56.370
散弹文件

01:10:56.370 --> 01:10:57.650
比方说这里

01:10:57.650 --> 01:10:59.690
麦方形

01:10:59.690 --> 01:11:00.770
我的函数

01:11:00.770 --> 01:11:02.130
点介式

01:11:02.130 --> 01:11:03.650
写了这么一个介式文件

01:11:03.650 --> 01:11:04.730
然后在这里边写

01:11:04.730 --> 01:11:05.490
这一个个的函数

01:11:05.490 --> 01:11:07.570
全部写到这个介式文件里边

01:11:07.570 --> 01:11:08.850
一个函数写完了之后

01:11:08.850 --> 01:11:09.930
你去测试一下

01:11:09.930 --> 01:11:11.330
一定要去测试一下

01:11:11.330 --> 01:11:13.730
比方说你这里新建一个页面去测试一下

01:11:13.730 --> 01:11:14.610
Test

01:11:14.610 --> 01:11:15.170
停了

01:11:15.170 --> 01:11:16.050
去测试一下

01:11:16.050 --> 01:11:16.650
怎么测试呢

01:11:16.650 --> 01:11:17.450
比方说

01:11:17.450 --> 01:11:18.370
咱们来写个函数

01:11:18.370 --> 01:11:20.210
判断一个数是不是击数

01:11:20.210 --> 01:11:21.810
判断一个数是不是击数

01:11:21.810 --> 01:11:23.210
写一个函数

01:11:23.210 --> 01:11:24.450
意思二

01:11:24.470 --> 01:11:25.550
传一个数字n进来

01:11:25.550 --> 01:11:27.950
我来判断那个数字n是不是击数

01:11:27.950 --> 01:11:28.870
判断一下

01:11:28.870 --> 01:11:29.950
n除一二的余数

01:11:29.950 --> 01:11:30.830
如果不等于0

01:11:30.830 --> 01:11:32.310
是不是击数

01:11:32.310 --> 01:11:32.790
对吧

01:11:32.790 --> 01:11:34.310
是击数

01:11:34.310 --> 01:11:37.070
L是不是不是击数

01:11:37.070 --> 01:11:37.430
对吧

01:11:37.430 --> 01:11:38.390
不是击数

01:11:38.390 --> 01:11:41.430
当然这个代码是可以减化的

01:11:41.430 --> 01:11:42.830
如果你在公司里面写这个代码

01:11:42.830 --> 01:11:43.750
可能要被骂

01:11:43.750 --> 01:11:44.950
可能要被骂

01:11:44.950 --> 01:11:46.070
因为你们现在初学

01:11:46.070 --> 01:11:47.470
所以说我写的那种代码

01:11:47.470 --> 01:11:48.710
你们看得懂一点

01:11:48.710 --> 01:11:50.190
实际上是可以减化的

01:11:50.190 --> 01:11:52.670
怎么减化

01:11:52.670 --> 01:11:54.350
这个表达是为真

01:11:54.410 --> 01:11:55.690
返回真

01:11:55.690 --> 01:11:57.050
这个表达是为假

01:11:57.050 --> 01:11:57.890
返回假

01:11:57.890 --> 01:11:59.610
那你直接把这个表达是返回

01:11:59.610 --> 01:12:00.490
我就不玩了

01:12:00.490 --> 01:12:01.210
对吧

01:12:01.210 --> 01:12:04.210
直接把这个表达是直接返回就完事了

01:12:04.210 --> 01:12:06.330
就完事了

01:12:06.330 --> 01:12:08.610
这么写是最好的

01:12:08.610 --> 01:12:10.090
其实你觉得好像

01:12:10.090 --> 01:12:11.850
你不是说代码要容易理解吗

01:12:11.850 --> 01:12:13.170
要写的容易理解吗

01:12:13.170 --> 01:12:14.410
这个很容易理解

01:12:14.410 --> 01:12:15.930
返回这个表达是的结果

01:12:15.930 --> 01:12:16.770
返回啥呢

01:12:16.770 --> 01:12:17.810
返回的是

01:12:17.810 --> 01:12:20.970
它是不是除一二不等于0

01:12:20.970 --> 01:12:24.100
不等于0就是击数

01:12:24.100 --> 01:12:26.080
打算注射打算文章注射

01:12:26.080 --> 01:12:29.720
这里是要判断的数字

01:12:29.720 --> 01:12:30.920
判断的数字

01:12:30.920 --> 01:12:34.000
然后这里是判断一个数

01:12:34.000 --> 01:12:36.360
是不是击数

01:12:36.360 --> 01:12:38.240
这个数字是number

01:12:38.240 --> 01:12:40.560
当然你把尽量写全一点

01:12:40.560 --> 01:12:43.200
可能我到时候在讲解作业的时候难得写了

01:12:43.200 --> 01:12:44.560
但是你写的时候

01:12:44.560 --> 01:12:45.760
尽量写全一点

01:12:45.760 --> 01:12:49.920
returns反过来是一个不理

01:12:49.920 --> 01:12:51.200
是否是

01:12:51.220 --> 01:12:54.180
这样子就没必要再写四逢四极数了

01:12:54.180 --> 01:12:55.940
因为看这个意思就看出来了

01:12:55.940 --> 01:12:56.780
这个函数就写完了

01:12:56.780 --> 01:12:58.900
后面的函数你一次写就完事了

01:12:58.900 --> 01:12:59.700
一次写

01:12:59.700 --> 01:13:01.620
写了函数之后你要去测试一下

01:13:01.620 --> 01:13:02.620
一定要去测试一下

01:13:02.620 --> 01:13:03.700
不要写了半天都

01:13:03.700 --> 01:13:05.500
你都不知道自己写多一没有

01:13:05.500 --> 01:13:06.100
找个页面

01:13:06.100 --> 01:13:08.420
随便找个页面去测试一下

01:13:08.420 --> 01:13:09.020
怎么测试呢

01:13:09.020 --> 01:13:11.460
引用wibe的css介石文件

01:13:11.460 --> 01:13:12.780
返回上级目录

01:13:12.780 --> 01:13:14.020
再返回上级目录

01:13:14.020 --> 01:13:15.140
common

01:13:15.140 --> 01:13:16.580
把介石引用进展

01:13:16.580 --> 01:13:18.980
引用进展过后是不是就可以用这个函数了

01:13:18.980 --> 01:13:20.780
这个函数就可以使用了

01:13:20.800 --> 01:13:21.480
可以使用了

01:13:21.480 --> 01:13:22.520
意思二的

01:13:22.520 --> 01:13:25.700
随便写个吧

01:13:25.700 --> 01:13:26.300
log

01:13:26.300 --> 01:13:28.060
意思二

01:13:28.060 --> 01:13:29.300
传一个三进去

01:13:29.300 --> 01:13:31.020
看一下输出的结果是不是true

01:13:31.020 --> 01:13:34.650
应该输出true

01:13:34.650 --> 01:13:35.370
输出的是true

01:13:35.370 --> 01:13:36.690
看函数交用成功

01:13:36.690 --> 01:13:38.250
输出了true

01:13:38.250 --> 01:13:39.850
以后我们就准备好这么一个

01:13:39.850 --> 01:13:41.250
这个介石文件就可以通用了

01:13:41.250 --> 01:13:43.130
以后做什么项目都可以用这个介石文件了

01:13:43.130 --> 01:13:45.810
很多函数只需要写一次就行了

01:13:45.810 --> 01:13:48.050
咱们下节课写作业讲解的时候

01:13:48.050 --> 01:13:49.610
可能还会写一次

01:13:49.610 --> 01:13:51.090
什么判断一个数是不是数

01:13:51.090 --> 01:13:52.090
是不是数

01:13:52.150 --> 01:13:53.390
那么写来之后了

01:13:53.390 --> 01:13:55.110
我们就统一的用这个介石了

01:13:55.110 --> 01:13:57.030
以后反而是要判断数数的地方了

01:13:57.030 --> 01:13:57.910
都是用这个介石

01:13:57.910 --> 01:13:59.110
有方便很多了

01:13:59.110 --> 01:13:59.950
好吧

01:13:59.950 --> 01:14:01.510
把这个作业完成

01:14:01.510 --> 01:14:02.910
这是第一部分

01:14:02.910 --> 01:14:04.230
第二部分是函数使用

01:14:04.230 --> 01:14:05.870
这一部分就不要写到介石里边了

01:14:05.870 --> 01:14:07.030
就不要写到这个介石里边了

01:14:07.030 --> 01:14:08.270
就是测试一下

01:14:08.270 --> 01:14:11.030
利用之前的那些介石里边的函数

01:14:11.030 --> 01:14:14.110
看一下能不能实现一些很复杂的功能

01:14:14.110 --> 01:14:15.190
你会发现这样子

01:14:15.190 --> 01:14:17.390
有了函数的支持过后了

01:14:17.390 --> 01:14:19.630
很多功能变得非常非常简单了

01:14:19.630 --> 01:14:20.230
好吧

01:14:20.230 --> 01:14:20.830
去写一下

01:14:20.830 --> 01:14:21.630
把这个作业完成

01:14:21.650 --> 01:14:22.370
先做第一部分

01:14:22.370 --> 01:14:24.050
再做第二部分

01:14:24.050 --> 01:14:24.170
好

01:14:24.170 --> 01:14:25.890
我们下节课来讲解这个作业

01:14:25.890 --> 01:14:26.490
函数这一块

01:14:26.490 --> 01:14:28.450
我们先一定要把它练扎实了

01:14:28.450 --> 01:14:31.330
然后我们再讲后边函数的一些

01:14:31.330 --> 01:14:32.410
进阶的东西

01:14:32.410 --> 01:14:33.890
先把基础练扎实

01:14:33.890 --> 01:14:34.610
练扎实过后了

01:14:34.610 --> 01:14:36.090
我们再往后边讲解

01:14:36.090 --> 01:14:36.330
好了

