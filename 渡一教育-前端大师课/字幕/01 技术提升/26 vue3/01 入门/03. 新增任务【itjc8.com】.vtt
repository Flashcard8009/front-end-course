WEBVTT

00:00.110 --> 00:04.110
好 来吧 我们这几颗开始就来做这个安定了

00:04.110 --> 00:07.110
工程已经搭建好了 在这

00:07.110 --> 00:11.110
就在这吧 就放在这吧

00:11.110 --> 00:15.110
然后现在我们这几颗要做新增任务

00:15.110 --> 00:18.110
那么我们这里的工程已经是个初始工程了

00:18.110 --> 00:22.810
咱们把运行出来

00:22.810 --> 00:25.810
运行出来 目前是这么一个界面

00:25.810 --> 00:28.810
把它该删的东西全部该删掉

00:28.810 --> 00:32.810
像这个index的CSS 留在这吧 因为一会我们也有样式

00:32.810 --> 00:36.810
然后这是根主键 根主键这里面

00:36.810 --> 00:40.810
引用了一些二-sets 这个东西该删掉

00:40.810 --> 00:44.810
component删掉 这个玩意就该去掉

00:44.810 --> 00:48.810
就这样吧 一个空的DIV

00:48.810 --> 00:52.810
然后这边我们把这个东西都去掉

00:52.810 --> 00:55.810
好了 就这么一个东西 空的工程 完全是空的

00:55.810 --> 00:58.810
我们首先要把界面打倒进去

00:58.810 --> 01:00.810
因为我们只有一个组件

01:00.810 --> 01:03.810
我们这个项目比较简单 只有一个组件

01:03.810 --> 01:06.810
我们主要是通过这个组件 让大家认识到

01:06.810 --> 01:10.810
completion API 给我们的开发 大家要有哪些改变

01:10.810 --> 01:13.810
我们这里的客间里面有一个静态页面

01:13.810 --> 01:16.810
大家可以看一下

01:16.810 --> 01:19.810
就这么一个静态页面 没有功能

01:19.810 --> 01:23.810
点了过后也没有什么反应

01:24.810 --> 01:27.810
也就是说我们CSS不用理解了

01:27.810 --> 01:30.810
包括这里有两张图片 是CSS里面用到的

01:30.810 --> 01:35.810
这两张图片 其实一个就是亏选中

01:35.810 --> 01:39.810
这个是图片 一个是为选中 一个是选中的

01:39.810 --> 01:43.810
界面就是图片 资源和CSS不用理解了

01:43.810 --> 01:47.810
因为这些东西跟我们学习VU3

01:47.810 --> 01:50.810
也没有什么关系 浪费时间在这里做的

01:50.810 --> 01:53.810
我们这里就把这两个文件 一个文件夹一个文件

01:53.810 --> 01:56.810
拷贝过来 拷贝到这

01:56.810 --> 01:59.810
然后CSS就把CSS的复制一下

01:59.810 --> 02:02.810
粘贴到这个音的时候CSS里面去

02:02.810 --> 02:05.810
OK 把CSS加进去

02:05.810 --> 02:09.810
然后我们可以看到 这边背景颜色都出来了

02:09.810 --> 02:11.810
背景颜色出来了

02:11.810 --> 02:15.810
然后我们的静态页面里面 其实就引用一个CSS

02:15.810 --> 02:18.810
那么CSS已经在Made.js里面引用了

02:18.810 --> 02:19.810
我们左右都不管了

02:19.810 --> 02:22.810
然后我们的静态页面里面还有一个DIV

02:22.810 --> 02:24.810
就整个是个DIV

02:24.810 --> 02:27.810
然后我们把DIV放过来

02:27.810 --> 02:30.810
放到这里面去

02:30.810 --> 02:32.810
Template里面去 就静态页面

02:32.810 --> 02:35.810
这个DIV 我从静态页面拷贝过来的话

02:35.810 --> 02:37.810
它这里有个DataV把它去掉

02:37.810 --> 02:42.180
好了 保存 咱们再看一下界面

02:42.180 --> 02:44.180
你看我们这些界面 是不是静态页面就出来了

02:44.180 --> 02:46.180
对吧 界面出来了

02:46.180 --> 02:48.180
然后我们来实现功能 重点来了

02:48.180 --> 02:51.180
我们主要是在这里面去实现功能

02:51.180 --> 02:55.180
那么这里我们要去实现一个Tedun垫射功能的

02:55.180 --> 02:58.180
首先遇到一个问题就是 数据哪来

02:58.180 --> 03:01.180
又保存到哪去 是不是遇到这么一个问题

03:01.180 --> 03:03.180
那么我这里的处理方式

03:03.180 --> 03:06.180
当然你可以保存到远程 写个服务器

03:06.180 --> 03:09.180
然后通过API上传门到服务器那边去

03:09.180 --> 03:11.180
从服务器那边获取任务列表

03:11.180 --> 03:13.180
那么这里我们不用做那么复杂

03:13.180 --> 03:15.180
也不用去写什么服务器

03:15.180 --> 03:18.180
就一个非常简单的 把它保存到本地的

03:18.180 --> 03:20.180
Local Storage那边去

03:20.180 --> 03:24.180
所以说我们这里可以先写这么一个

03:24.180 --> 03:26.180
建设文件夹吧,Utube 打一个工具

03:26.180 --> 03:29.180
这里面提供一个介石文件 叫做Tedun

03:29.180 --> 03:33.180
当然目前跟comparation API没有什么关系

03:33.180 --> 03:36.180
就是用我们以前H5的知识

03:37.180 --> 03:40.180
来 把它保存到我们的Local Storage那边去

03:40.180 --> 03:42.180
这里面提供一些方法

03:42.180 --> 03:44.180
比方说一个方法

03:44.180 --> 03:47.180
这个方法就是废棋

03:47.180 --> 03:51.180
通过这个方法可以获取整个任务列表

03:51.180 --> 03:55.180
获取目前所有的任务

03:55.180 --> 03:57.180
那么这里你可以通过远程获取

03:57.180 --> 03:59.180
我这里就从Local Storage那边获取

03:59.180 --> 04:01.180
那么怎么写呢?非常简单

04:01.180 --> 04:03.180
从Local Storage那边

04:03.180 --> 04:05.180
Local Storage那边GetItem

04:05.180 --> 04:07.180
对吧?把keyz给它

04:07.180 --> 04:09.180
这个不用解释了吧

04:09.180 --> 04:10.180
那么这个keyz是啥呢?

04:10.180 --> 04:12.180
我们这里可以定一个常量吧

04:13.180 --> 04:17.180
比方说Local key

04:17.180 --> 04:19.180
再加一个字幕刷

04:19.180 --> 04:22.180
比方说to do mvc

04:22.180 --> 04:24.180
把keyz给它

04:24.180 --> 04:26.180
然后从Local Storage那边去

04:26.180 --> 04:29.180
获取这个任务的数数

04:29.180 --> 04:31.180
到时候我们保存到Local Storage

04:31.180 --> 04:33.180
也是保存了一个数数

04:33.180 --> 04:35.180
那么这里拿到这个值

04:36.180 --> 04:38.180
result

04:38.180 --> 04:41.180
如果说这个result有值的话

04:41.180 --> 04:42.180
很简单

04:42.180 --> 04:43.180
我们直接返回

04:43.180 --> 04:44.180
接受

04:44.180 --> 04:45.180
pause

04:45.180 --> 04:46.180
对吧?

04:46.180 --> 04:48.180
解析为一个对象

04:48.180 --> 04:49.180
返回就可以了

04:49.180 --> 04:51.180
如果说它没有值的话

04:51.180 --> 04:52.180
我们就返回一个空数组

04:52.180 --> 04:53.180
非常简单,对不对?

04:53.180 --> 04:55.180
这个没问题吧?

04:55.180 --> 04:56.180
不用掩饰了吧

04:56.180 --> 04:58.180
这是获取目前从Local Storage

04:58.180 --> 05:00.180
获取目前所有的任务

05:00.180 --> 05:02.180
那么除了获取之外

05:02.180 --> 05:04.180
我们可能还会需要保存

05:04.180 --> 05:06.180
把这些方法提供好

05:06.180 --> 05:07.180
sale

05:07.180 --> 05:09.180
保存一个

05:09.180 --> 05:10.180
保存

05:10.180 --> 05:12.180
给我一个就是数组

05:12.180 --> 05:16.140
to do

05:16.140 --> 05:17.140
这to do是什么呢?

05:17.140 --> 05:19.140
就是任务列表

05:19.140 --> 05:21.140
就是一个数组

05:21.140 --> 05:23.140
然后保存

05:23.140 --> 05:26.140
所有任务

05:26.140 --> 05:28.140
那么这个函数也非常简单

05:28.140 --> 05:30.140
我们就把它存到Local Storage

05:30.140 --> 05:32.140
去set item

05:32.140 --> 05:35.140
keyz还是用这个keyz

05:35.140 --> 05:37.140
这也是开发的

05:38.140 --> 05:40.140
像这种硬编码的地方

05:40.140 --> 05:41.140
就可以保存到一个编辖里边

05:41.140 --> 05:42.140
到时候改的话

05:42.140 --> 05:43.140
一起就改了

05:43.140 --> 05:45.140
好,值呢?就是这个

05:45.140 --> 05:48.140
用keyz是giv

05:48.140 --> 05:50.140
把to do传进去

05:50.140 --> 05:51.140
再去保存了

05:51.140 --> 05:52.140
非常简单,对不对?

05:52.140 --> 05:55.140
提供这么两个方法

05:55.140 --> 05:56.140
好了,那么现在

05:56.140 --> 05:58.140
我们回到这个app里边去

05:58.140 --> 06:00.140
我们这个页面中

06:00.140 --> 06:04.140
肯定要用到所有的任务

06:04.140 --> 06:05.140
对不对?

06:05.140 --> 06:06.140
这是毫无疑问的

06:06.140 --> 06:08.140
我们用既然使用complete API

06:08.140 --> 06:10.140
那么这里写个C type函数

06:10.140 --> 06:12.140
我们肯定会用到

06:12.140 --> 06:15.140
就是利用这个complete API的时候

06:15.140 --> 06:16.140
你始终要想

06:16.140 --> 06:18.140
我们这个页面上要用到什么东西

06:18.140 --> 06:20.140
用到哪些数据,哪些方法

06:20.140 --> 06:22.140
哪些生命周期函数

06:22.140 --> 06:23.140
哪些计算属性

06:23.140 --> 06:25.140
始终想到这么一些问题

06:25.140 --> 06:27.140
那么我们这里肯定会用到

06:27.140 --> 06:29.140
任务列表

06:29.140 --> 06:30.140
对不对?

06:30.140 --> 06:31.140
而且这个任务列表

06:31.140 --> 06:33.140
是不是应该具有响应式的?

06:33.140 --> 06:35.140
任务列表数据多了一个

06:35.140 --> 06:37.140
那我是不是应该

06:37.140 --> 06:39.140
在页面上就会多一个

06:39.140 --> 06:40.140
对不对?

06:40.140 --> 06:41.140
任务列表里边少了一个

06:41.140 --> 06:43.140
是不是页面上也会真的少一个

06:43.140 --> 06:45.140
因此它是具有响应式的

06:45.140 --> 06:47.140
所以说这里毫无疑问

06:47.140 --> 06:49.140
我们应该是用一个什么呢

06:49.140 --> 06:51.140
来做响应式呢,用Rave

06:51.140 --> 06:53.140
通过U里面导入Rave

06:53.140 --> 06:55.140
来做这个响应式

06:55.140 --> 06:57.140
我们这里能可以把这个导入进来

06:57.140 --> 06:58.140
把这个

06:58.140 --> 07:00.140
全部导入吧

07:00.140 --> 07:02.140
local to do storage

07:03.140 --> 07:05.140
from ut

07:07.140 --> 07:09.140
to do storage,导入进来

07:09.140 --> 07:11.140
后居名为GS的话

07:11.140 --> 07:12.140
那么就可以不用写了

07:12.140 --> 07:13.140
可以上Rave

07:13.140 --> 07:15.140
我们通过

07:15.140 --> 07:16.140
Rave

07:16.140 --> 07:17.140
一个初始值

07:17.140 --> 07:18.140
来得到一个变量

07:18.140 --> 07:20.140
得到一个响应式数据

07:20.140 --> 07:22.140
叫做什么呢?to do

07:22.140 --> 07:23.140
Rave

07:23.140 --> 07:24.140
注意命名

07:24.140 --> 07:25.140
我们之前说过

07:25.140 --> 07:26.140
上一课说过

07:26.140 --> 07:28.140
如果说是一个

07:28.140 --> 07:29.140
Rave产生的一个

07:29.140 --> 07:30.140
响应数据的话

07:30.140 --> 07:32.140
我们尽量以Rave的结尾来命名

07:32.140 --> 07:33.140
因为它有一个

07:33.140 --> 07:34.140
不然的话

07:34.140 --> 07:36.140
有的时候不注意到的话

07:36.140 --> 07:38.140
可能少写一个点value

07:38.140 --> 07:40.140
有的声誉多写一个点value

07:40.140 --> 07:41.140
注意一下

07:41.140 --> 07:43.140
那么它的初始值是什么

07:43.140 --> 07:45.140
任务列表的初始值

07:45.140 --> 07:47.140
这个韩数只会运行一次

07:47.140 --> 07:48.140
你有想

07:48.140 --> 07:49.140
在最开始的时候

07:49.140 --> 07:51.140
咱们的任务列表应该从哪来

07:51.140 --> 07:53.140
它的初始值是什么

07:53.140 --> 07:55.140
是不是要调用这个韩数啊

07:55.140 --> 07:57.140
说要调用这个韩数来得到

07:57.140 --> 07:59.140
目前的任务列表

07:59.140 --> 08:01.140
它返回的是一个数组

08:01.140 --> 08:02.140
对不对

08:02.140 --> 08:03.140
没问题吧

08:03.140 --> 08:04.140
那么这里呢

08:04.140 --> 08:06.140
我们是不是可以这样子写

08:06.140 --> 08:08.140
把它通过这个

08:08.140 --> 08:10.140
to do storage

08:10.140 --> 08:12.140
fetch

08:12.140 --> 08:13.140
调用这个韩数

08:13.140 --> 08:14.140
是不是返回一个数组

08:14.140 --> 08:16.140
那么返回的这个数组

08:16.140 --> 08:20.140
作为任务列表的初始值

08:20.140 --> 08:22.140
没什么意思吧

08:22.140 --> 08:23.140
好

08:23.140 --> 08:24.140
那么这样子写的过后了

08:24.140 --> 08:26.140
我们先不着急返回

08:26.140 --> 08:27.140
返回的都不着急

08:27.140 --> 08:28.140
那么这样子

08:28.140 --> 08:30.140
得到一个可以享用的数据

08:30.140 --> 08:32.140
对不对

08:32.140 --> 08:33.140
没问题吧

08:33.140 --> 08:34.140
好

08:34.140 --> 08:35.140
那么比方说

08:35.140 --> 08:37.140
我们在这里随便写个地方

08:37.140 --> 08:38.140
就在上面吧

08:38.140 --> 08:39.140
写个A期

08:39.140 --> 08:40.140
A期的话

08:40.140 --> 08:42.140
我们得到它的长度

08:42.140 --> 08:44.140
点儿

08:44.140 --> 08:47.140
点儿links

08:47.140 --> 08:48.140
好

08:48.140 --> 08:50.140
咱们来看一下

08:50.140 --> 08:52.140
刷新

08:52.140 --> 08:53.140
搞错了

08:53.140 --> 08:56.140
倒是这里没返回是吧

08:56.140 --> 08:57.140
再返回

08:57.140 --> 08:59.140
return

08:59.140 --> 09:01.140
to do storage

09:01.140 --> 09:03.140
你看一开始是什么0

09:03.140 --> 09:04.140
对吧

09:04.140 --> 09:05.140
那么现在呢

09:05.140 --> 09:07.140
我们如果说往里边加一下

09:07.140 --> 09:09.140
这里没有

09:09.140 --> 09:11.140
我再把它重新保存到

09:11.140 --> 09:12.140
window里边

09:12.140 --> 09:16.660
便于测试

09:16.660 --> 09:17.660
那么window里边

09:17.660 --> 09:18.660
是不是多了一个to do storage

09:18.660 --> 09:19.660
对吧

09:19.660 --> 09:20.660
好

09:20.660 --> 09:21.660
那么我们现在保存一下

09:21.660 --> 09:22.660
往里边加一下

09:22.660 --> 09:23.660
注意

09:23.660 --> 09:24.660
这里是一个对象

09:24.660 --> 09:25.660
对不对

09:25.660 --> 09:26.660
要通过它的value

09:26.660 --> 09:27.660
value是一个数组

09:27.660 --> 09:29.660
它实际上这里

09:29.660 --> 09:31.660
由于你是数组

09:31.660 --> 09:32.660
或者是其他对象的时候

09:32.660 --> 09:33.660
它还有一个特殊处理

09:33.660 --> 09:34.660
它会把它变成

09:34.660 --> 09:35.660
继续变成一个代理

09:35.660 --> 09:36.660
这些东西

09:36.660 --> 09:38.660
在下一个阶段再详细说

09:38.660 --> 09:39.660
我们这里

09:39.660 --> 09:41.660
就直接value

09:41.660 --> 09:42.660
push

09:42.660 --> 09:43.660
往里边加一下

09:43.660 --> 09:44.660
随便加个数字

09:44.660 --> 09:45.660
2

09:45.660 --> 09:46.660
是不是长度变1了

09:46.660 --> 09:47.660
对吧

09:47.660 --> 09:48.660
它是具有享用式的

09:48.660 --> 09:49.660
加一个3

09:49.660 --> 09:52.660
是不是长度变2了

09:52.660 --> 09:55.660
就这么个意思

09:55.660 --> 09:57.660
好 功能完了吗

09:57.660 --> 09:58.660
还没完

09:58.660 --> 09:59.660
现在我们还没有做

09:59.660 --> 10:00.660
这个新增

10:00.660 --> 10:01.660
不着急

10:01.660 --> 10:02.660
我们先把任务列表

10:02.660 --> 10:04.660
这一块搞定

10:04.660 --> 10:05.660
那么这个列表

10:05.660 --> 10:06.660
它这个数组

10:06.660 --> 10:07.660
既然响应是

10:07.660 --> 10:09.660
它一旦变化了

10:09.660 --> 10:10.660
注意听

10:10.660 --> 10:11.660
我有新知识

10:11.660 --> 10:12.660
它一旦变化了

10:12.660 --> 10:13.660
我们是不是

10:13.660 --> 10:14.660
还有一些别的事情

10:14.660 --> 10:15.660
要做

10:15.660 --> 10:16.660
还有什么事情

10:16.660 --> 10:17.660
要做

10:18.660 --> 10:19.660
还有什么事情

10:19.660 --> 10:21.660
它如果数据变化了

10:21.660 --> 10:22.660
我是不是

10:22.660 --> 10:24.660
应该把它重新保存到

10:24.660 --> 10:26.660
和Storage里边去

10:26.660 --> 10:27.660
对不对

10:27.660 --> 10:29.660
那我们如何来

10:29.660 --> 10:30.660
监控它

10:30.660 --> 10:32.660
适逢变化呢

10:32.660 --> 10:33.660
怎么监控呢

10:33.660 --> 10:34.660
看着

10:34.660 --> 10:36.660
在comparation API里边

10:36.660 --> 10:37.660
它可以提供了

10:37.660 --> 10:38.660
一个函数

10:38.660 --> 10:39.660
除了Ref之外

10:39.660 --> 10:40.660
我们会陆续

10:40.660 --> 10:42.660
写一些comparation API里面的

10:42.660 --> 10:43.660
一些相关函数

10:43.660 --> 10:44.660
还给它提供一个函数

10:44.660 --> 10:48.660
叫做ward effect

10:49.660 --> 10:50.660
什么

10:50.660 --> 10:52.660
监控副作用

10:52.660 --> 10:54.660
这好像不说人话了是吧

10:54.660 --> 10:55.660
其实它就是

10:55.660 --> 10:56.660
直接写

10:56.660 --> 10:57.660
就这样用的

10:57.660 --> 10:59.660
然后写了就明白了

11:00.660 --> 11:01.660
它是一个函数

11:01.660 --> 11:03.660
然后它的参数里边

11:03.660 --> 11:05.660
再传一个函数进去

11:07.660 --> 11:08.660
然后这个函数里边

11:08.660 --> 11:09.660
做啥呢

11:09.660 --> 11:10.660
随便的做啥

11:10.660 --> 11:11.660
比方我们现在

11:11.660 --> 11:12.660
做这么一件事

11:12.660 --> 11:14.660
我们通过to do

11:14.660 --> 11:16.660
to do is

11:16.660 --> 11:18.660
to do storage

11:18.660 --> 11:19.660
然后save保存

11:19.660 --> 11:20.660
保存什么呢

11:21.660 --> 11:23.660
to do is

11:23.660 --> 11:24.660
这啥意思呢

11:24.660 --> 11:25.660
看着啊

11:25.660 --> 11:26.660
给它解释一下

11:27.660 --> 11:29.660
这个函数里边

11:29.660 --> 11:31.660
它只要用到了

11:31.660 --> 11:32.660
想应识数据

11:32.660 --> 11:33.660
你看这个玩意儿

11:33.660 --> 11:34.660
是不是想应识数据

11:34.660 --> 11:36.660
那么它这个函数里边

11:36.660 --> 11:38.660
只要用到了想应识数据

11:38.660 --> 11:39.660
那么这些想应识数据

11:39.660 --> 11:41.660
就会自动

11:41.660 --> 11:43.660
被作为依赖

11:43.660 --> 11:44.660
说明我这个函数

11:44.660 --> 11:45.660
用到了这个想应数据

11:45.660 --> 11:46.660
那么比如说

11:46.660 --> 11:47.660
我这个函数

11:47.660 --> 11:49.660
要依赖这个想应识数据

11:49.660 --> 11:50.660
我们一步步来啊

11:50.660 --> 11:51.660
这个人听懂吗

11:51.660 --> 11:52.660
我这个函数里边

11:52.660 --> 11:54.660
用到了这个想应识数据

11:54.660 --> 11:55.660
说明我这个函数

11:55.660 --> 11:57.660
依赖想应数据

11:57.660 --> 11:58.660
因为我们都知道

11:58.660 --> 11:59.660
唯有里边

11:59.660 --> 12:00.660
它有依赖收集

12:00.660 --> 12:02.660
它能自动收集依赖

12:02.660 --> 12:04.660
将来这个想应识数据

12:04.660 --> 12:05.660
一旦变化

12:05.660 --> 12:07.660
它会自动重新运行

12:07.660 --> 12:08.660
一次这个函数

12:08.660 --> 12:10.660
就这么简单

12:10.660 --> 12:11.660
那么现在呢

12:11.660 --> 12:12.660
我们

12:12.660 --> 12:13.660
比方我们刚才

12:13.660 --> 12:14.660
往这个数据里边加一项

12:14.660 --> 12:16.660
是不是导致这个想应识数据变化了

12:16.660 --> 12:17.660
那么变化之后

12:17.660 --> 12:20.660
它会自动的重新运行这个函数

12:20.660 --> 12:21.660
原谅的意思吧

12:21.660 --> 12:23.660
那么这个函数就自动运行了

12:23.660 --> 12:24.660
自动运行它是不是又保

12:24.660 --> 12:25.660
就把保存保存

12:25.660 --> 12:27.660
到那个local storage里边去了

12:27.660 --> 12:29.660
那么有了这个东西过后

12:29.660 --> 12:30.660
我们再来看一下

12:30.660 --> 12:31.660
小心啊

12:31.660 --> 12:32.660
一开始是零

12:32.660 --> 12:33.660
现在呢

12:33.660 --> 12:35.660
我们通过to do is rift

12:35.660 --> 12:36.660
the value

12:36.660 --> 12:37.660
the push

12:37.660 --> 12:39.660
一个e

12:39.660 --> 12:40.660
一回车

12:40.660 --> 12:42.660
好咱们来看一下local storage

12:42.660 --> 12:43.660
找到这个application

12:43.660 --> 12:45.660
那么这里一个local storage

12:45.660 --> 12:46.660
你看一下

12:46.660 --> 12:48.660
t值为to do mvc

12:48.660 --> 12:50.660
它的value值是不是个数组

12:50.660 --> 12:51.660
一

12:51.660 --> 12:52.660
看没

12:52.660 --> 12:53.660
然后我们再加一个

12:53.660 --> 12:55.660
push一个2

12:55.660 --> 12:57.660
看一下local storage

12:57.660 --> 12:59.660
这变成了一个字不算

12:59.660 --> 13:00.660
一二

13:00.660 --> 13:01.660
没问题吧

13:01.660 --> 13:02.660
所以说呢

13:02.660 --> 13:03.660
有了这个东西

13:03.660 --> 13:04.660
是不是可以监控

13:04.660 --> 13:06.660
这个to do is的变化

13:06.660 --> 13:08.660
这是这一块

13:08.660 --> 13:09.660
那么这个to do is列表

13:09.660 --> 13:10.660
这一块

13:10.660 --> 13:12.660
就整个任务列表

13:12.660 --> 13:14.660
数据以及监控数据变化

13:14.660 --> 13:15.660
这件事情

13:15.660 --> 13:17.660
是不是就聚合在一起了

13:17.660 --> 13:18.660
对吧

13:18.660 --> 13:20.660
我们要按照以前的做法的话

13:20.660 --> 13:21.660
用配置式的话

13:21.660 --> 13:23.660
那是不是还在data里面写一个

13:23.660 --> 13:25.660
还在walt里面写一个

13:25.660 --> 13:26.660
现在没必要了

13:26.660 --> 13:28.660
它自动完成了

13:28.660 --> 13:29.660
聚合在一起了

13:29.660 --> 13:30.660
在一个函数里面聚合

13:30.660 --> 13:31.660
好

13:31.660 --> 13:32.660
那么这个既然聚合了

13:32.660 --> 13:35.660
我们是不是可以单独提出去

13:35.660 --> 13:37.660
提成一个模块来做

13:37.660 --> 13:38.660
好

13:38.660 --> 13:39.660
那么比方说我们在src里面

13:39.660 --> 13:40.660
新建个文件夹

13:40.660 --> 13:42.660
有个干系名为comparation

13:42.660 --> 13:43.660
好

13:43.660 --> 13:45.660
组合式API

13:45.660 --> 13:46.660
我们要辅助

13:46.660 --> 13:47.660
我们的组建里面

13:47.660 --> 13:49.660
完成各式各样的操作

13:49.660 --> 13:51.660
那么这里边我们新建一个文件

13:51.660 --> 13:53.660
叫做to use

13:53.660 --> 13:56.660
to do list

13:56.660 --> 13:57.660
好

13:57.660 --> 13:59.660
这边我们就导出一个函数

13:59.660 --> 14:01.660
函数名字叫做use

14:01.660 --> 14:04.660
使用to do list

14:04.660 --> 14:06.660
你调用这个函数

14:06.660 --> 14:07.660
我就给你一些

14:07.660 --> 14:09.660
我们整个任务列表

14:09.660 --> 14:10.660
然后这个函数内部

14:10.660 --> 14:12.660
会自动的去完成监控

14:12.660 --> 14:13.660
对吧

14:13.660 --> 14:15.660
那么就把我们要用到的东西

14:15.660 --> 14:16.660
就全部得到了

14:16.660 --> 14:18.660
我们这里把这两个代码

14:18.660 --> 14:19.660
复制一下

14:19.660 --> 14:20.660
粘贴过来

14:20.660 --> 14:25.170
然后把这个也粘贴过来

14:25.170 --> 14:27.170
这个玩意是我要测试的

14:27.170 --> 14:28.170
我放在这

14:28.170 --> 14:29.170
好

14:29.170 --> 14:30.170
这边就删除掉了

14:30.170 --> 14:31.170
好

14:31.170 --> 14:32.170
于是这边我们是不是

14:32.170 --> 14:33.170
只需要去导入什么

14:33.170 --> 14:35.170
use to do list

14:35.170 --> 14:36.170
pro

14:36.170 --> 14:38.170
comparation

14:38.170 --> 14:40.170
use to do list

14:40.170 --> 14:41.170
好

14:41.170 --> 14:42.170
然后这边

14:42.170 --> 14:43.170
我们是不是

14:43.170 --> 14:46.170
调用这个函数

14:46.170 --> 14:48.170
然后它就会返回给我们什么呢

14:48.170 --> 14:50.170
返回给我们

14:50.170 --> 14:52.170
to do list

14:52.170 --> 14:53.170
当然你直接把

14:53.170 --> 14:54.170
to do list返回也行

14:54.170 --> 14:56.170
只不过我们习惯上

14:56.170 --> 14:57.170
因为有可能

14:57.170 --> 14:58.170
我们这里的贵返回

14:58.170 --> 14:59.170
多个东西

14:59.170 --> 15:00.170
习惯上把它做一个对象

15:00.170 --> 15:02.170
后边我们还会写

15:02.170 --> 15:04.170
很多这样的一个解释

15:04.170 --> 15:06.170
那些解释可能返回得多一点

15:06.170 --> 15:07.170
因为这个地方

15:07.170 --> 15:08.170
也只有返回这个

15:08.170 --> 15:10.170
目前只有返回这个

15:10.170 --> 15:12.170
但是我们还是

15:12.170 --> 15:13.170
同意一下

15:13.170 --> 15:14.170
都返回一个对象

15:14.170 --> 15:15.170
对象里面包含各种

15:15.170 --> 15:16.170
我们要用的数据

15:16.170 --> 15:18.170
只不过这里只有一个而已

15:18.170 --> 15:19.170
好 那么这边

15:19.170 --> 15:21.170
是不是可以拿到

15:21.170 --> 15:24.170
我们这里可以解构吗

15:24.170 --> 15:25.170
可以解构

15:25.170 --> 15:27.170
或者是不用解构了

15:27.170 --> 15:29.170
拿到吧

15:29.170 --> 15:33.740
to do list

15:33.740 --> 15:34.740
那么这里边

15:34.740 --> 15:36.740
我们把这个to do is rift

15:36.740 --> 15:37.740
是不是等于

15:37.740 --> 15:39.740
to do list

15:39.740 --> 15:41.740
to do is rift

15:41.740 --> 15:42.740
对吧

15:42.740 --> 15:44.740
那么现在我们来再看一下

15:44.740 --> 15:46.740
诶 这里报错了

15:46.740 --> 15:48.740
看一下什么错误

15:48.740 --> 15:51.740
它说404没有找到

15:51.740 --> 15:54.740
这边的路清

15:54.740 --> 15:55.740
有些变化

15:55.740 --> 15:57.740
返回上级目的

15:57.740 --> 15:59.740
好 你看

15:59.740 --> 16:00.740
目前是2

16:00.740 --> 16:01.740
看到没 因为我们之前

16:01.740 --> 16:02.740
保存过了两个

16:02.740 --> 16:03.740
我们再再加一个吧

16:03.740 --> 16:05.740
to do is rift

16:05.740 --> 16:07.740
value push 3

16:07.740 --> 16:08.740
这边三项了

16:08.740 --> 16:10.740
然后看一下这边

16:10.740 --> 16:11.740
如果说听到这

16:11.740 --> 16:13.740
有点晕晕呼呼的

16:13.740 --> 16:14.740
同学 你可以赶快

16:14.740 --> 16:15.740
跟着我做一遍

16:15.740 --> 16:16.740
别等了 这些效果

16:16.740 --> 16:17.740
你一定要跟着做的

16:17.740 --> 16:19.740
不然的话我就白讲了

16:19.740 --> 16:20.740
我们把抽离出去

16:20.740 --> 16:21.740
对吧

16:21.740 --> 16:22.740
那么这边

16:22.740 --> 16:23.740
诶 这边

16:23.740 --> 16:24.740
那么这边

16:24.740 --> 16:25.740
跑下去

16:25.740 --> 16:26.740
这边

16:26.740 --> 16:27.740
那么这边其实

16:27.740 --> 16:28.740
你还可以解构

16:28.740 --> 16:29.740
对吧

16:29.740 --> 16:31.740
这里可以解构

16:31.740 --> 16:33.740
to do is rift

16:33.740 --> 16:34.740
那么这边

16:34.740 --> 16:37.740
就可以用数学属性了

16:37.740 --> 16:39.740
没问题吧

16:39.740 --> 16:40.740
好 那么现在呢

16:40.740 --> 16:41.740
我们就搞定了什么

16:41.740 --> 16:42.740
你看一个函数

16:42.740 --> 16:43.740
它就高度聚合了

16:43.740 --> 16:45.740
聚合了所有的

16:45.740 --> 16:47.740
关于完整列表的功能

16:47.740 --> 16:49.740
我提供一个完整列表

16:49.740 --> 16:50.740
它的初始者呢

16:50.740 --> 16:51.740
就来自原多哥Storage

16:51.740 --> 16:52.740
然后呢

16:52.740 --> 16:53.740
我也会自动去监控

16:53.740 --> 16:55.740
这个完整列表的变化

16:55.740 --> 16:56.740
只要一变化了

16:56.740 --> 16:57.740
那么我就会

16:57.740 --> 16:58.740
重新保存

16:58.740 --> 16:59.740
这个函数就会重新运行

16:59.740 --> 17:00.740
对吧

17:00.740 --> 17:01.740
通过这个watcherfix

17:02.740 --> 17:03.740
好 这是这一块

17:03.740 --> 17:04.740
那么这个地方

17:04.740 --> 17:05.740
主要是用来测试的

17:05.740 --> 17:07.740
以后我们会把它删掉

17:09.740 --> 17:10.740
接下来

17:10.740 --> 17:11.740
我们来做新增

17:11.740 --> 17:12.740
因为新增呢

17:12.740 --> 17:13.740
它跟这个

17:13.740 --> 17:14.740
这个地方有没有关系了

17:14.740 --> 17:15.740
对吧

17:15.740 --> 17:16.740
它至少没有直接的关系

17:16.740 --> 17:17.740
新增呢

17:17.740 --> 17:19.740
就是我们要新增一个东西

17:19.740 --> 17:21.740
好 我们可以用类似的诗路

17:21.740 --> 17:23.740
来写一个新增的节词

17:24.740 --> 17:25.740
我们就用use

17:25.740 --> 17:27.740
我们通常命名上

17:27.740 --> 17:29.740
按照react hook的命名

17:29.740 --> 17:30.740
当然有些人

17:30.740 --> 17:32.740
没有接触react没关系

17:32.740 --> 17:33.740
就是react

17:33.740 --> 17:34.740
有跟这个东西

17:34.740 --> 17:35.740
差不多的东西

17:35.740 --> 17:36.740
功能

17:36.740 --> 17:37.740
那么它的命名

17:37.740 --> 17:39.740
一般是要求用use开头

17:39.740 --> 17:41.740
我们就沿用这个习惯

17:41.740 --> 17:42.740
use

17:43.740 --> 17:44.740
new

17:44.740 --> 17:45.740
to do

17:46.740 --> 17:47.740
那么这里呢

17:47.740 --> 17:48.740
我也是一样

17:48.740 --> 17:50.740
提供一个函数

17:50.740 --> 17:51.740
use方形

17:51.740 --> 17:53.740
use new

17:53.740 --> 17:54.740
to do

17:54.740 --> 17:56.740
这个函数干嘛呢

17:56.740 --> 17:57.740
它就提供

17:57.740 --> 17:59.740
我们界面上需要用到的

17:59.740 --> 18:02.740
各种跟新增相关的

18:02.740 --> 18:03.740
数据啊 方法啊

18:03.740 --> 18:04.740
这些东西

18:04.740 --> 18:05.740
它就提供出来

18:05.740 --> 18:06.740
那么它至少呢

18:06.740 --> 18:08.740
我们想一想啊

18:08.740 --> 18:09.740
其实你不用看界面

18:09.740 --> 18:10.740
你都可以想象得到

18:10.740 --> 18:12.740
你要新增一个任务

18:14.740 --> 18:16.740
需要用到数据吗

18:16.740 --> 18:17.740
你至少得有个文本花嘛

18:17.740 --> 18:18.740
对吧 我们的页面上

18:18.740 --> 18:20.740
不得有个文本花吗

18:20.740 --> 18:21.740
那么这个文本花

18:21.740 --> 18:22.740
是不是要有个vmode

18:22.740 --> 18:24.740
来绑定一个数据

18:24.740 --> 18:26.740
那这里是不是要用到一个数据

18:26.740 --> 18:27.740
对吧

18:27.740 --> 18:28.740
那因此呢

18:28.740 --> 18:29.740
我们这里倒入啊

18:29.740 --> 18:30.740
而且这个数据

18:30.740 --> 18:32.740
肯定是相应似的嘛

18:32.740 --> 18:34.740
那么比方说这里啊

18:34.740 --> 18:35.740
我们的界面上

18:35.740 --> 18:37.740
这个文本花肯定有一个vmode

18:37.740 --> 18:38.740
对不对

18:38.740 --> 18:40.740
来绑定一个相应似数据

18:40.740 --> 18:41.740
没问题吧

18:41.740 --> 18:42.740
我们这里呢

18:42.740 --> 18:44.740
应该提供一个相应数据

18:44.740 --> 18:45.740
我们这里呢

18:45.740 --> 18:46.740
通过rave

18:46.740 --> 18:47.740
这个数据呢

18:47.740 --> 18:48.740
一开始呢

18:48.740 --> 18:49.740
一开始就是空置不串嘛

18:49.740 --> 18:50.740
啥都没有

18:50.740 --> 18:51.740
文本花啥都没有

18:51.740 --> 18:53.740
所以说一开始是空置不串

18:53.740 --> 18:55.740
我们就给它保存到

18:55.740 --> 18:57.740
保存到这个就是

18:57.740 --> 18:59.740
new to do

18:59.740 --> 19:01.740
其实它这里写的

19:01.740 --> 19:03.740
就是一个to do的title

19:03.740 --> 19:04.740
一个标题

19:04.740 --> 19:05.740
任务的标题

19:05.740 --> 19:07.740
那么就是new to do

19:07.740 --> 19:08.740
rave嘛

19:08.740 --> 19:09.740
然后我们拿着写标题了

19:09.740 --> 19:10.740
rave

19:11.740 --> 19:12.740
这个标什么意思

19:12.740 --> 19:13.740
打个注释啊

19:13.740 --> 19:16.740
表示新任务的标题

19:16.740 --> 19:18.740
它是个相应数据

19:18.740 --> 19:19.740
那么自然而然

19:19.740 --> 19:20.740
最后呢

19:20.740 --> 19:21.740
我们会把它返回去

19:21.740 --> 19:22.740
返回回去

19:22.740 --> 19:24.740
new to do rave

19:25.740 --> 19:26.740
好

19:26.740 --> 19:27.740
然后呢

19:27.740 --> 19:28.740
到这边

19:28.740 --> 19:34.670
别跳

19:34.670 --> 19:35.670
到这边来

19:35.670 --> 19:36.670
然后呢

19:36.670 --> 19:38.670
我们在这个setup里边

19:39.670 --> 19:40.670
我们是不是又可以

19:40.670 --> 19:41.670
用同样的方式

19:41.670 --> 19:42.670
保留进来

19:42.670 --> 19:43.670
use

19:44.670 --> 19:46.670
new to do

19:47.670 --> 19:48.670
completion

19:48.670 --> 19:50.670
use new to do

19:50.670 --> 19:51.670
好

19:51.670 --> 19:52.670
那么这边来

19:54.670 --> 19:55.670
其实我们这里

19:55.670 --> 19:56.670
就直接这样了

19:56.670 --> 19:57.670
可以这样

19:57.670 --> 19:58.670
直接这样

19:58.670 --> 19:59.670
直接展开对不对

19:59.670 --> 20:00.670
是不是可以这样

20:00.670 --> 20:01.670
调用这个函数

20:01.670 --> 20:02.670
这个函数返回啥

20:02.670 --> 20:03.670
返回的是不是一个对象

20:03.670 --> 20:04.670
对象里边

20:04.670 --> 20:06.670
有我们需要用到的东西

20:06.670 --> 20:07.670
对吧

20:07.670 --> 20:08.670
那么我们这里直接

20:08.670 --> 20:09.670
把对象展开

20:09.670 --> 20:10.670
是不是得到

20:10.670 --> 20:11.670
我们需要用到的东西

20:11.670 --> 20:12.670
能理解吧

20:12.670 --> 20:13.670
好

20:13.670 --> 20:14.670
那么现在只要这样子一写

20:14.670 --> 20:15.670
那么页面上

20:15.670 --> 20:16.670
是不是可以自然而然

20:16.670 --> 20:17.670
它就多了一个什么

20:17.670 --> 20:19.670
new to do rave

20:19.670 --> 20:20.670
好

20:20.670 --> 20:21.670
因此呢

20:21.670 --> 20:22.670
我们在这里

20:22.670 --> 20:23.670
是不是可以绑定

20:23.670 --> 20:24.670
vmode

20:24.670 --> 20:26.670
new to do rave

20:26.670 --> 20:27.670
好

20:27.670 --> 20:28.670
一看一下

20:28.670 --> 20:29.670
没有抱错

20:29.670 --> 20:30.670
对吧

20:30.670 --> 20:31.670
是不是没问题

20:31.670 --> 20:32.670
对吧

20:32.670 --> 20:33.670
一切绑定

20:33.670 --> 20:34.670
就是这一块

20:34.670 --> 20:35.670
好

20:35.670 --> 20:36.670
那么这里

20:36.670 --> 20:37.670
其实我们在

20:37.670 --> 20:38.670
新增任务的时候

20:38.670 --> 20:39.670
大家想一想

20:39.670 --> 20:41.670
我们不仅仅是要

20:41.670 --> 20:43.670
提供一个可以绑定的数据

20:43.670 --> 20:45.670
是不是还要提供一个

20:45.670 --> 20:46.670
新增任务的方法

20:46.670 --> 20:48.670
比方说他要按回车键

20:48.670 --> 20:49.670
不管他用什么

20:49.670 --> 20:51.670
触发事件的方式

20:51.670 --> 20:52.670
总之他最终

20:52.670 --> 20:53.670
肯定要运行一个

20:53.670 --> 20:54.670
新增任务的方法

20:54.670 --> 20:55.670
因为我们既然是在

20:55.670 --> 20:57.670
聚合新增任务的功能

20:57.670 --> 20:58.670
我们就把新增任务的功能

20:58.670 --> 20:59.670
写完

21:00.670 --> 21:01.670
那么这里边

21:01.670 --> 21:02.670
除了一个新增任务的数据之外

21:02.670 --> 21:03.670
还提供一个方法

21:03.670 --> 21:05.670
那么我们就写个方法呗

21:05.670 --> 21:08.670
add to do

21:08.670 --> 21:09.670
对吧

21:09.670 --> 21:12.670
新增一个任务的方法

21:12.670 --> 21:16.670
这是新增一个任务

21:16.670 --> 21:18.670
那么调用这个方法的时候

21:18.670 --> 21:20.670
要做什么事情呢

21:20.670 --> 21:21.670
要做啥事情

21:21.670 --> 21:23.670
是不是要把

21:23.670 --> 21:25.670
像之前的列表

21:25.670 --> 21:26.670
就是之前的那个

21:26.670 --> 21:27.670
to do是review里边

21:27.670 --> 21:29.670
是不是像这里边

21:29.670 --> 21:31.670
去扑洗一个新的任务

21:31.670 --> 21:32.670
那么任务的标题是什么

21:32.670 --> 21:34.670
任务标题不就是这个玩意吗

21:34.670 --> 21:35.670
一文闷框框一改变

21:35.670 --> 21:36.670
那么这是想用的数据

21:36.670 --> 21:38.670
它是不是自然而然就变了

21:38.670 --> 21:39.670
对吧

21:39.670 --> 21:40.670
我们把它输出一下

21:40.670 --> 21:41.670
输出一下这个

21:41.670 --> 21:42.670
new to do

21:42.670 --> 21:44.670
review.value

21:44.670 --> 21:45.670
这是个review

21:45.670 --> 21:47.670
所以说一定要用.value

21:47.670 --> 21:48.670
没问题吧

21:48.670 --> 21:49.670
好

21:49.670 --> 21:50.670
然后我们在这

21:50.670 --> 21:51.670
在这

21:51.670 --> 21:52.670
给它注册个事件

21:52.670 --> 21:53.670
给这个文闷框

21:53.670 --> 21:54.670
注册个什么事件呢

21:54.670 --> 21:56.670
给它注册一个key up事件吧

21:56.670 --> 21:57.670
当键盘抬起的时候

21:57.670 --> 21:58.670
抬起什么键呢

21:58.670 --> 22:00.670
我们给它给修饰服

22:00.670 --> 22:01.670
抬起一个inter件

22:01.670 --> 22:02.670
对吧

22:02.670 --> 22:04.670
就是我们按下回车键

22:04.670 --> 22:05.670
抬起回车键的时候

22:05.670 --> 22:06.670
我们调用一个函数

22:06.670 --> 22:08.670
因为这边的导出

22:08.670 --> 22:09.670
返回了一个

22:09.670 --> 22:10.670
这个也要返回

22:10.670 --> 22:11.670
方法也要返回

22:11.670 --> 22:12.670
一个想用数据

22:12.670 --> 22:13.670
有个方法

22:13.670 --> 22:14.670
那么这两个

22:14.670 --> 22:15.670
这两个东西呢在这边

22:15.670 --> 22:16.670
一解构

22:16.670 --> 22:18.670
是不是全部都返回了

22:18.670 --> 22:19.670
那么这边是不是

22:19.670 --> 22:20.670
可以用这个方法

22:20.670 --> 22:21.670
对吧

22:21.670 --> 22:23.670
我们这里可以用这个use

22:23.670 --> 22:26.670
ad to do

22:26.670 --> 22:27.670
好保存

22:27.670 --> 22:28.670
这边保存

22:28.670 --> 22:29.670
我们来看一下

22:29.670 --> 22:30.670
能不能输出

22:30.670 --> 22:34.880
一回车

22:34.880 --> 22:36.880
空置五串

22:36.880 --> 22:37.880
写了一东西

22:37.880 --> 22:38.880
一回车是不是输出了

22:38.880 --> 22:40.880
表体输出了

22:40.880 --> 22:41.880
特别

22:41.880 --> 22:42.880
我们就把这些功能

22:42.880 --> 22:43.880
聚合到这边了

22:43.880 --> 22:44.880
以后要维护

22:44.880 --> 22:45.880
这个功能的时候

22:45.880 --> 22:46.880
我们是不是直接可以

22:46.880 --> 22:47.880
非常快速的定位到这儿

22:47.880 --> 22:49.880
就比较像以前那样子

22:49.880 --> 22:50.880
分散的配置

22:50.880 --> 22:51.880
到处去找

22:51.880 --> 22:52.880
对吧

22:52.880 --> 22:53.880
这些功能全是分散的

22:53.880 --> 22:55.880
现在我们高度聚合在一起

22:55.880 --> 22:56.880
那么现在我们就去

22:56.880 --> 22:57.880
完成这个方法

22:57.880 --> 22:58.880
ad to do

22:58.880 --> 23:00.880
添加一个任务的时候

23:00.880 --> 23:01.880
我怎么来弄呢

23:01.880 --> 23:03.880
我们就可以这样

23:03.880 --> 23:05.880
我们首先一个变量

23:05.880 --> 23:06.880
保存一下

23:06.880 --> 23:07.880
valid

23:07.880 --> 23:11.320
这只是个任务的表体

23:11.320 --> 23:12.320
对吧

23:12.320 --> 23:14.320
这个东西肯定是有

23:14.320 --> 23:15.320
没有值的话

23:15.320 --> 23:16.320
那么它就是没有值的

23:16.320 --> 23:17.320
它有值的话

23:17.320 --> 23:19.320
我们把它用一个去

23:19.320 --> 23:21.320
去掉守卫空格

23:21.320 --> 23:22.320
守卫空格不要

23:22.320 --> 23:23.320
那么这样子

23:23.320 --> 23:24.320
就是稍微控制一下

23:24.320 --> 23:26.320
这个当然看得懂吧

23:26.320 --> 23:27.320
它只要填了东西

23:27.320 --> 23:28.320
填了东西的话

23:28.320 --> 23:29.320
我就把守卫空格

23:29.320 --> 23:30.320
给它去掉

23:30.320 --> 23:31.320
反馈

23:31.320 --> 23:33.320
那么如果说你啥东西都没填

23:33.320 --> 23:34.320
就去掉守卫空格之后

23:34.320 --> 23:35.320
啥东西就没填

23:36.320 --> 23:38.320
我就啥都不做

23:38.320 --> 23:39.320
啥都不做

23:39.320 --> 23:40.320
如果说你填了过后来

23:40.320 --> 23:41.320
我们要做什么事情呢

23:41.320 --> 23:43.320
我们是不是要做行政

23:43.320 --> 23:44.320
我们再输出一下

23:44.320 --> 23:45.320
慢一点

23:45.320 --> 23:46.320
不着急

23:46.320 --> 23:47.320
这个东西大家一开始

23:47.320 --> 23:49.320
可能还不太习惯

23:50.320 --> 23:51.320
我们再来看

23:53.320 --> 23:54.320
是不是啥都没有

23:54.320 --> 23:55.320
没有输出

23:55.320 --> 23:56.320
这里就return了

23:56.320 --> 23:58.320
因为我这里是去掉守卫空格

23:58.320 --> 23:59.320
啥都没有

23:59.320 --> 24:00.320
然后写了一些东西

24:00.320 --> 24:01.320
回车

24:01.320 --> 24:02.320
你看

24:02.320 --> 24:03.320
是不是这个东西

24:03.320 --> 24:04.320
对吧

24:04.320 --> 24:06.320
那么现在我要做的事情是啥

24:06.320 --> 24:07.320
在这里

24:07.320 --> 24:08.320
要做啥事

24:09.320 --> 24:13.320
生成一个任务对象

24:13.320 --> 24:15.320
每个任务是一个对象

24:16.320 --> 24:18.320
它至少包含一个标题

24:18.320 --> 24:19.320
一个什么

24:19.320 --> 24:20.320
当前的完成状态

24:20.320 --> 24:21.320
有没有完成

24:21.320 --> 24:23.320
生成一个任务对象

24:23.320 --> 24:26.320
将其加入到

24:26.320 --> 24:30.320
任务列表中

24:30.320 --> 24:31.320
一步一步来

24:31.320 --> 24:32.320
不着急

24:32.320 --> 24:34.320
首先我们来生成一个任务对象

24:34.320 --> 24:36.320
我们这里可以

24:36.320 --> 24:37.320
生成一个就是

24:39.320 --> 24:42.700
对象有一个title

24:42.700 --> 24:43.700
对象的任务标题

24:43.700 --> 24:44.700
标题是什么

24:44.700 --> 24:45.700
标题是一个白色

24:45.700 --> 24:46.700
对吧

24:46.700 --> 24:48.700
任务的是否完成

24:48.700 --> 24:49.700
我们用一个属性

24:49.700 --> 24:53.700
Completed

24:53.700 --> 24:54.700
咱这些对面

24:59.140 --> 25:00.140
完了

25:01.140 --> 25:02.140
我做单词了

25:04.140 --> 25:10.140
Completed

25:19.590 --> 25:21.590
Completed

25:21.590 --> 25:22.590
拿错了

25:30.590 --> 25:31.590
对了

25:32.590 --> 25:33.590
为什么他给我说错了

25:34.590 --> 25:35.590
对了

25:35.590 --> 25:39.590
Completed

25:39.590 --> 25:40.590
形容词

25:40.590 --> 25:41.590
可以的

25:41.590 --> 25:43.590
Completed

25:43.590 --> 25:44.590
那么一开始任务

25:44.590 --> 25:45.590
肯定是没有完成的

25:45.590 --> 25:46.590
新增的任务

25:46.590 --> 25:47.590
肯定是没有完成的

25:47.590 --> 25:49.590
所以说我直接写forged

25:49.590 --> 25:51.590
任务是否完成

25:53.590 --> 25:54.590
其实这里

25:54.590 --> 25:56.590
我最好给他一个id

25:56.590 --> 25:57.590
给他一个唯一编号

25:57.590 --> 25:58.590
每个任务

25:58.590 --> 25:59.590
一个唯一编号

25:59.590 --> 26:00.590
对象的话

26:00.590 --> 26:01.590
如果说标题相同的话

26:01.590 --> 26:02.590
那哪个任务实际

26:02.590 --> 26:03.590
哪个任务

26:03.590 --> 26:04.590
那就搞不清楚了

26:04.590 --> 26:05.590
所以说我们最好给他一个

26:05.590 --> 26:06.590
唯一编号

26:06.590 --> 26:07.590
那么这个唯一编号

26:07.590 --> 26:09.590
我怎么弄呢

26:09.590 --> 26:10.590
我在这

26:10.590 --> 26:11.590
我在这

26:11.590 --> 26:15.420
再导出一个函数

26:15.420 --> 26:17.420
生成一个唯一编号

26:17.420 --> 26:19.420
generate

26:19.420 --> 26:20.420
id

26:21.420 --> 26:23.420
这是生成一个唯一编号

26:23.420 --> 26:25.420
生成一个任务的

26:25.420 --> 26:27.420
唯一编号

26:28.420 --> 26:29.420
那么这个唯一编号

26:29.420 --> 26:30.420
怎么做呢

26:30.420 --> 26:31.420
我打算就这样做

26:31.420 --> 26:33.420
就是用时间戳

26:33.420 --> 26:34.420
加上一个

26:34.420 --> 26:35.420
视为水积数

26:37.420 --> 26:39.420
来生成一个唯一编号

26:39.420 --> 26:40.420
那么时间戳很简单

26:40.420 --> 26:41.420
对吧

26:41.420 --> 26:42.420
就是一个dates

26:42.420 --> 26:43.420
nau

26:43.420 --> 26:44.420
不就是个时间戳吗

26:44.420 --> 26:45.420
那么关键是

26:45.420 --> 26:46.420
这个视为水积数怎么弄呢

26:46.420 --> 26:47.420
视为水积数

26:47.420 --> 26:48.420
我简单一点

26:48.420 --> 26:49.420
可以这样再弄

26:50.420 --> 26:51.420
我可以这样

26:51.420 --> 26:52.420
大家知道

26:52.420 --> 26:53.420
这个mess

26:53.420 --> 26:54.420
delratum

26:54.420 --> 26:56.420
生成一个0-1之间的水积数

26:56.420 --> 26:57.420
你看一下

26:57.420 --> 26:58.420
0-1之间的水积数

26:58.420 --> 26:59.420
然后我把它

26:59.420 --> 27:00.420
这个数字

27:00.420 --> 27:01.420
把它的图计

27:01.420 --> 27:02.420
转换成一个

27:03.420 --> 27:05.420
一个16进资的

27:06.420 --> 27:07.420
16进资的支付串

27:08.420 --> 27:09.420
那么它的

27:09.420 --> 27:10.420
因为总数部分就是0

27:10.420 --> 27:11.420
对吧

27:11.420 --> 27:12.420
小数部分

27:12.420 --> 27:13.420
它就变成16进资的

27:13.420 --> 27:14.420
还没

27:14.420 --> 27:16.420
好 那么我们只要用支付串

27:16.420 --> 27:17.420
结取

27:17.420 --> 27:18.420
是不是结取这个视为就行了

27:18.420 --> 27:20.420
然后我们用这种方式

27:20.420 --> 27:21.420
简单一点

27:21.420 --> 27:22.420
substream

27:22.420 --> 27:23.420
这是我之前测试过的

27:23.420 --> 27:24.420
OK

27:25.420 --> 27:26.420
从第三位开始取

27:26.420 --> 27:27.420
从这个位置开始取

27:27.420 --> 27:28.420
取视为

27:28.420 --> 27:29.420
那么就得到这个东西了

27:29.420 --> 27:31.420
好 所以说我这里

27:31.420 --> 27:32.420
把东西拼接一下

27:32.420 --> 27:33.420
拼接一下

27:33.420 --> 27:34.420
那么就这样子

27:34.420 --> 27:35.420
有这么一个函数

27:35.420 --> 27:36.420
这个函数

27:36.420 --> 27:37.420
就生成一个

27:37.420 --> 27:38.420
时间戳

27:38.420 --> 27:39.420
加上视为水积数

27:39.420 --> 27:40.420
就得到这么一个

27:40.420 --> 27:41.420
水积的支付串

27:41.420 --> 27:43.420
来作为任务的编号

27:43.420 --> 27:45.420
好了 有了这么一个函数过后

27:45.420 --> 27:46.420
回到这

27:46.420 --> 27:47.420
回到这来

27:47.420 --> 27:48.420
我们是不是又可以导入

27:50.420 --> 27:51.420
from

27:52.420 --> 27:53.420
这个UTO

27:54.420 --> 27:55.420
to do storage

27:55.420 --> 27:57.420
里面有一个generateid

27:57.420 --> 27:58.420
调用这个函数

27:58.420 --> 28:00.420
得到一个水积编号

28:00.420 --> 28:01.420
那么新增一个任务的时候

28:01.420 --> 28:02.420
一个新的任务的编号

28:02.420 --> 28:04.420
我就给它一个

28:04.420 --> 28:05.420
id

28:05.420 --> 28:06.420
生成一个唯一的id

28:06.420 --> 28:07.420
当然这个东西

28:07.420 --> 28:08.420
是不是也有可能会重复

28:08.420 --> 28:09.420
比方说

28:09.420 --> 28:11.420
运气太倍了

28:11.420 --> 28:13.420
我的操作速度非常快

28:13.420 --> 28:14.420
然后

28:14.420 --> 28:16.420
在物差小于一毫秒

28:16.420 --> 28:17.420
那么于是

28:17.420 --> 28:19.420
时间戳是一样的

28:19.420 --> 28:20.420
而且

28:20.420 --> 28:22.420
又特别特别的寸

28:22.420 --> 28:23.420
导致呢

28:23.420 --> 28:24.420
水积数又完全一样

28:24.420 --> 28:26.420
那么就导致id一样

28:26.420 --> 28:27.420
不过这种情况

28:27.420 --> 28:28.420
我们不考虑了

28:30.420 --> 28:31.420
那么这里呢

28:31.420 --> 28:32.420
我们就得到一个新的任务对象

28:32.420 --> 28:33.420
对吧

28:33.420 --> 28:34.420
我们这里输出一下

28:35.420 --> 28:36.420
好像我们试一下

28:37.420 --> 28:38.420
这边我们

28:38.420 --> 28:39.420
随便写个

28:39.420 --> 28:40.420
开会

28:41.420 --> 28:42.420
你们以后

28:42.420 --> 28:43.420
到了公司里面

28:43.420 --> 28:44.420
先要开会

28:46.420 --> 28:47.420
你看

28:47.420 --> 28:48.420
一个新的任务对象

28:48.420 --> 28:49.420
什么生成出来了

28:49.420 --> 28:50.420
没有完成id

28:50.420 --> 28:51.420
然后的title

28:52.420 --> 28:53.420
好 这个事情

28:53.420 --> 28:54.420
是不是做完了

28:54.420 --> 28:55.420
那么接下来

28:55.420 --> 28:56.420
我还要做一件事

28:56.420 --> 28:58.420
就是把这个任务

28:58.420 --> 29:00.420
加入到任务列表中

29:01.420 --> 29:02.420
那问题来了

29:02.420 --> 29:04.420
我这里在哪去找任务列表呢

29:05.420 --> 29:06.420
在哪去找任务列表

29:06.420 --> 29:08.420
我这里能不能得到任务列表

29:08.420 --> 29:09.420
是不是拿不到

29:09.420 --> 29:10.420
我的任务列表在哪呢

29:10.420 --> 29:12.420
是在另外一个聚合里边

29:12.420 --> 29:13.420
对吧

29:13.420 --> 29:14.420
说在另外一个组合里边

29:14.420 --> 29:15.420
这个函数里边

29:15.420 --> 29:16.420
这里是有任务列表

29:16.420 --> 29:17.420
我这里有

29:17.420 --> 29:18.420
又没有

29:20.420 --> 29:21.420
这个其实就是

29:21.420 --> 29:23.420
我之前说的那个

29:23.420 --> 29:24.420
有mixin

29:24.420 --> 29:25.420
最麻烦的问题

29:26.420 --> 29:27.420
mixin之间

29:27.420 --> 29:29.420
它倒是可以混合

29:29.420 --> 29:30.420
不知道大家用过没有

29:30.420 --> 29:31.420
没用过的话

29:31.420 --> 29:32.420
就可以忽略这一段

29:32.420 --> 29:33.420
用过的同学

29:33.420 --> 29:34.420
就可以听一听

29:35.420 --> 29:36.420
mixin

29:37.420 --> 29:38.420
它可以混合

29:39.420 --> 29:40.420
好像是可以打到

29:40.420 --> 29:41.420
把它

29:41.420 --> 29:43.420
把功能聚合的目的

29:44.420 --> 29:45.420
但是这些聚合之间

29:45.420 --> 29:46.420
是没有层次关系的

29:48.420 --> 29:49.420
一个聚合里边

29:49.420 --> 29:50.420
没办法去用

29:50.420 --> 29:51.420
另一个聚合里边的东西

29:51.420 --> 29:52.420
很麻烦的用起来

29:54.420 --> 29:55.420
所以说它只能是

29:55.420 --> 29:56.420
扁平化的

29:57.420 --> 29:58.420
用心去体会

29:59.420 --> 30:00.420
它是扁平化的

30:00.420 --> 30:01.420
就我这个聚合

30:01.420 --> 30:02.420
跟另一个聚合没关系

30:02.420 --> 30:03.420
比方说现在有两个聚合

30:03.420 --> 30:04.420
对吧

30:04.420 --> 30:05.420
use to do this

30:05.420 --> 30:06.420
use这个

30:06.420 --> 30:07.420
两个聚合之间是没有关系的

30:07.420 --> 30:09.420
用mixin的话

30:10.420 --> 30:11.420
但是用comparation

30:11.420 --> 30:12.420
一篇就可以

30:12.420 --> 30:13.420
因为它就是一个

30:13.420 --> 30:14.420
普通的函数

30:14.420 --> 30:16.420
它是不是可以传参数

30:17.420 --> 30:18.420
我不是要用到

30:18.420 --> 30:19.420
to do this

30:19.420 --> 30:20.420
对吧

30:20.420 --> 30:21.420
这个任务列表吗

30:21.420 --> 30:22.420
你把个任务列表

30:23.420 --> 30:24.420
你把这个leaf传给我

30:25.420 --> 30:26.420
那么只要你传给我的过后

30:26.420 --> 30:27.420
我这里是不是可以加了

30:28.420 --> 30:29.420
your value

30:30.420 --> 30:31.420
to do

30:31.420 --> 30:32.420
不就完了吗

30:32.420 --> 30:33.420
对吧

30:33.420 --> 30:34.420
那么关于这个任务

30:34.420 --> 30:35.420
监控过

30:35.420 --> 30:36.420
改变过后

30:36.420 --> 30:37.420
又怎么去保存

30:37.420 --> 30:38.420
跟我没关系

30:38.420 --> 30:39.420
我只管加

30:40.420 --> 30:41.420
保存的是是你的事

30:41.420 --> 30:42.420
你自己去完成

30:42.420 --> 30:44.420
就是高度聚合的好处

30:44.420 --> 30:45.420
该我做的事

30:45.420 --> 30:46.420
我一样不少的做完

30:47.420 --> 30:48.420
那么这边也是

30:48.420 --> 30:49.420
新增的时候

30:49.420 --> 30:50.420
我一样不少的做完

30:50.420 --> 30:51.420
其他的事我不管

30:52.420 --> 30:53.420
那么到这边来

30:53.420 --> 30:54.420
你看

30:54.420 --> 30:55.420
我这边是不是

30:55.420 --> 30:56.420
只要把传过去

30:56.420 --> 30:57.420
这就是leaf

30:58.420 --> 30:59.420
我把上面这个去

30:59.420 --> 31:02.500
这个不需要

31:02.500 --> 31:03.500
是不是可以了

31:06.500 --> 31:07.500
那么目前

31:07.500 --> 31:08.500
我暂时还用不到这个

31:08.500 --> 31:09.500
我页面上

31:09.500 --> 31:10.500
还暂时用不到这个

31:10.500 --> 31:11.500
所以我把这个去了

31:11.500 --> 31:12.500
我们这里导出这个

31:13.500 --> 31:14.500
好

31:14.500 --> 31:17.640
我们来看一下

31:17.640 --> 31:18.640
这里

31:18.640 --> 31:19.640
我们写个abc

31:19.640 --> 31:20.640
一回车

31:20.640 --> 31:21.640
一回车过后

31:21.640 --> 31:22.640
我们看一下comble

31:22.640 --> 31:23.640
application

31:23.640 --> 31:24.640
一边是不是多了一下

31:25.640 --> 31:27.640
我们再写一个

31:27.640 --> 31:28.640
注意多一下

31:28.640 --> 31:29.640
看没

31:30.640 --> 31:32.640
我这里把清空一下

31:32.640 --> 31:34.640
因为前面有些测试数据

31:34.640 --> 31:35.640
我们再来

31:36.640 --> 31:37.640
开会

31:38.640 --> 31:39.640
然后吃饭

31:41.640 --> 31:42.640
是不是两项了

31:43.640 --> 31:44.640
我不清空了吗

31:45.640 --> 31:47.640
内存里边还有

31:47.640 --> 31:48.640
我把重新清空一下

31:48.640 --> 31:49.640
订了一遍

31:49.640 --> 31:50.640
再重新刷新一下

31:51.640 --> 31:52.640
目前是个空速度

31:53.640 --> 31:54.640
然后呢

31:54.640 --> 31:55.640
吃饭

31:55.640 --> 31:58.140
然后呢

31:58.140 --> 31:59.140
睡觉

32:00.140 --> 32:02.140
然后把斗斗

32:03.140 --> 32:04.140
说有三个对象

32:05.140 --> 32:06.140
好

32:06.140 --> 32:08.140
这里还有点不太完善的地方

32:08.140 --> 32:09.140
就是在于这

32:09.140 --> 32:11.140
这我

32:11.140 --> 32:12.140
每次新增完了过后

32:12.140 --> 32:13.140
新增成功了之后

32:13.140 --> 32:15.140
我打算把这个闷矿清空

32:15.140 --> 32:17.140
所以说我这里其实

32:17.140 --> 32:18.140
本质上是什么呢

32:18.140 --> 32:19.140
本质上就是说

32:19.140 --> 32:20.140
我新增一个任务过后

32:20.140 --> 32:22.140
它要回到一个空置不串

32:22.140 --> 32:23.140
就这么个意思

32:23.140 --> 32:24.140
所以说我这里

32:24.140 --> 32:25.140
非常简单

32:26.140 --> 32:27.140
注意啊

32:27.140 --> 32:28.140
你只要看到这个

32:28.140 --> 32:29.140
就是命名的好处

32:29.140 --> 32:30.140
你只要看到这个

32:30.140 --> 32:32.140
在这些函数里边

32:32.140 --> 32:33.140
一定要加上

32:33.140 --> 32:34.140
在模板里边

32:34.140 --> 32:35.140
你管的不用管

32:35.140 --> 32:36.140
因为为什么

32:36.140 --> 32:37.140
就上里头说的

32:38.140 --> 32:39.140
模板里边

32:39.140 --> 32:40.140
它又是有特殊处理的

32:42.140 --> 32:44.140
你只要到代理就像

32:44.140 --> 32:45.140
你只要是通过代理

32:45.140 --> 32:46.140
就像它问的话

32:46.140 --> 32:47.140
它是有特殊处理的

32:48.140 --> 32:49.140
所以说这里呢

32:49.140 --> 32:50.140
我们通过这个

32:50.140 --> 32:51.140
复制为空

32:52.140 --> 32:54.140
因为它说数据是响应似的

32:54.140 --> 32:55.140
数据相关的东西

32:55.140 --> 32:56.140
它一定会跟着变化

32:57.140 --> 32:58.140
咱们再来看

32:59.140 --> 33:00.140
看看

33:01.140 --> 33:02.140
有了

33:02.140 --> 33:03.140
那么这里清空了

33:03.140 --> 33:05.140
是不是现在我们就

33:05.140 --> 33:06.140
虽然这个图

33:06.140 --> 33:07.140
组件很复杂

33:07.140 --> 33:08.140
东西很多

33:08.140 --> 33:09.140
但是我们一块一块

33:09.140 --> 33:10.140
可以把它一块一块做

33:10.140 --> 33:11.140
它不用分散到

33:11.140 --> 33:12.140
不同的配置里边

33:12.140 --> 33:13.140
实际上有了

33:13.140 --> 33:14.140
comparation API过后

33:14.140 --> 33:15.140
其他的配置

33:15.140 --> 33:16.140
都可以不需要了

33:16.140 --> 33:17.140
都不需要了

33:17.140 --> 33:18.140
除了这个配置

33:18.140 --> 33:19.140
Propos

33:19.140 --> 33:20.140
Propos的话

33:20.140 --> 33:21.140
还得声明一下

33:21.140 --> 33:22.140
其他配置都不需要

33:22.140 --> 33:23.140
明儿的意思吧

33:24.140 --> 33:25.140
那么这里呢

33:25.140 --> 33:26.140
我们就把这里

33:26.140 --> 33:28.140
新增的功能做完了

33:28.140 --> 33:29.140
有些人说

33:29.140 --> 33:30.140
新增的列表里

33:30.140 --> 33:31.140
看不见

33:31.140 --> 33:32.140
跟新增无关

33:32.140 --> 33:34.140
这边显示东西的

33:34.140 --> 33:35.140
需要的数据

33:35.140 --> 33:37.140
需要的方法等等

33:37.140 --> 33:38.140
跟新增无关

33:38.140 --> 33:39.140
我们只管

33:39.140 --> 33:40.140
把新增做完就行了

33:40.140 --> 33:41.140
那么现在

33:41.140 --> 33:42.140
我们在复杂组件里

33:42.140 --> 33:44.140
是不是也可以进一步细分

33:44.140 --> 33:45.140
就是我们现在

33:45.140 --> 33:46.140
有了comparation API之后

33:46.140 --> 33:48.140
我们对组件的划分

33:48.140 --> 33:49.140
不光是

33:49.140 --> 33:51.140
组件就不是最小单位了

33:51.140 --> 33:53.140
而是我们的comparation API

33:53.140 --> 33:54.140
是最小单位

33:54.140 --> 33:55.140
它可以进一步细分

33:55.140 --> 33:57.140
在组件内部进行细分

33:57.140 --> 33:58.140
而且多个组件之间

33:58.140 --> 33:59.140
如果说出现了

33:59.140 --> 34:01.140
相同的这种功能性

34:01.140 --> 34:02.140
那么我们可以

34:02.140 --> 34:03.140
进行复用

34:03.140 --> 34:04.140
你看这些东西

34:04.140 --> 34:05.140
如果说

34:05.140 --> 34:07.140
另一个新增任务

34:07.140 --> 34:09.140
它也要用到这个功能的话

34:09.140 --> 34:10.140
你可以杂绮用就行了

34:10.140 --> 34:12.140
只是介面不一样而已

34:12.140 --> 34:13.140
看没

34:13.140 --> 34:14.140
大家可以好好体会一下

34:14.140 --> 34:15.140
那么这一刻

34:15.140 --> 34:17.140
我们就讲到这了

34:17.140 --> 34:18.140
大家下去

34:18.140 --> 34:19.140
一定要跟着做

34:19.140 --> 34:20.140
一定要跟着做

34:20.140 --> 34:22.140
你不跟着做的话

34:22.140 --> 34:23.140
我就讲了半天

34:23.140 --> 34:24.140
等于白讲

34:24.140 --> 34:25.140
好 这是新增任务

34:25.140 --> 34:26.140
把它做了

