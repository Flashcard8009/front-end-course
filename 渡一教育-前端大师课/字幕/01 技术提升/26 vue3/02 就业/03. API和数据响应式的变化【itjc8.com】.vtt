WEBVTT

00:00.050 --> 00:04.450
OK 这节课呢 从终点谈一下这两道面试题

00:05.410 --> 00:08.930
特别是第二道面试题啊 也要好好地理解清楚 我跟你说

00:09.650 --> 00:11.730
因为这个玩意儿呢 是在面试中

00:12.770 --> 00:17.170
90%都可能会遇到温刀的问题啊 这是个非常基本的问题

00:18.050 --> 00:24.290
呃 第一道面试题呢 有可能会问到啊 但是就这个温刀的话就算比较偏的了啊

00:24.690 --> 00:27.490
他考虑一些设计的理念在里边

00:27.970 --> 00:34.050
呃 因为我觉得呢 他可能会遇到啊 所以说我把第一个面试题讲一讲吧 中文平时开发呢也没有多少关系

00:34.370 --> 00:40.210
啊 顺便呢 再讲一讲 他有些app的一些变化啊 其实app变化了之前也体验过了

00:41.010 --> 00:46.370
第一个问题呢 就是说5u3里边 他为啥要把那个构造函数用的好好的啊

00:47.090 --> 00:51.730
你留的不好吗 还兼容对不对 兼容5u2嘛 5u26一个5u

00:52.690 --> 00:58.610
以前不就是这样做的吗 6一个5u对吧 构造函数嘛 他为什么要把他去掉呢 去掉就不兼容了呀

00:59.490 --> 01:04.130
那是这是为什么呢 我们一个说 首先他遇到一个棘手的问题 就这么一个问题

01:05.010 --> 01:07.490
这个问题呢 你们开发一般不会遇到啊

01:08.050 --> 01:13.810
但是有的时候呢 因为5u是做一个框架嘛 他要考虑各种各样的情况 这种情况呢 有一些

01:14.530 --> 01:20.210
极端的情况就可能会遇到 怎么情况呢 就是在一个页面中啊 他有多个5u应用

01:21.170 --> 01:21.810
有意思吧

01:22.450 --> 01:25.650
然后我们平时一个页面中 6一个5u应用对吧 6一个5u就完了

01:26.130 --> 01:29.010
但是有的时候呢 页面中可能有多个5u应用 比较这里一个div

01:29.570 --> 01:32.210
id为f1 就第二个divf2

01:32.690 --> 01:36.930
第一个5u应用了 要控制这一块 第二个5u应用了 要挂载到这一块

01:37.570 --> 01:43.250
那么以前咋写的呢 以前我们就这样写的啊 6一个5u bla bla bla 配置啊 然后呢

01:44.050 --> 01:45.810
mount挂载到这个地方

01:46.290 --> 01:51.570
然后再另外一个5u应用 然后mount到这个地方 对吧 好像是没啥问题

01:53.170 --> 01:57.410
但是一旦涉及到了使用插件

01:58.370 --> 02:02.530
或者是一些全局的组件 或者是一些全局的混合

02:03.170 --> 02:05.570
或者是一些全局的指令

02:07.010 --> 02:07.890
就遇到问题了

02:08.450 --> 02:12.850
因为我们以前使用插件咋使用的勾造函数点

02:13.330 --> 02:13.970
点儿use

02:15.090 --> 02:16.690
那么你想一想这个玩意儿

02:17.090 --> 02:20.050
他知道你觉得他会影响到哪些应用

02:21.090 --> 02:22.930
以前我们只有一个应用那无所谓

02:23.490 --> 02:27.490
但是有两个应用或者多个应用的时候 他是不是会影响到所有的应用啊

02:27.810 --> 02:30.530
因为他并不知道你这样 你这行代吧 他怎么知道

02:31.250 --> 02:33.330
你想用到哪个应用 他不知道的

02:34.050 --> 02:37.650
所以说他就用到所有的5u应用全部有这些插件了

02:38.530 --> 02:40.210
那么是不是影响范围太广了

02:40.530 --> 02:45.010
那有可能我这个第一个应用里边 我不需要插件 第二个应用才需要插件

02:45.010 --> 02:46.050
那怎么办呢 没办法

02:46.370 --> 02:47.650
以前是没办法了

02:48.130 --> 02:49.490
你除非去改他的元代吧

02:50.290 --> 02:52.130
Megson也是全局的混合

02:52.690 --> 02:54.690
说影响的范围有点广了

02:55.650 --> 02:56.930
还有这个全局的组件

02:57.890 --> 02:59.970
他也会影响 他也会受到影响

03:00.770 --> 03:04.450
那么这种情况比较极端啊 但是呢有可能会遇到

03:04.690 --> 03:07.810
他如果说闻到这个面试题呢 他就说看一下你

03:08.530 --> 03:09.890
理解得细不细致

03:10.690 --> 03:14.450
那么遇到这个问题的5u2就没办法了

03:14.450 --> 03:16.050
就有一个比较头痛的问题

03:16.050 --> 03:18.930
这是他的设计缺陷 他设计的时候呢就没有

03:19.490 --> 03:21.970
没有考 就是没有为这个多个应用啊

03:22.450 --> 03:23.730
就考虑到这个问题啊

03:25.090 --> 03:28.370
然后在5u3那边呢 他就解决这个问题了啊

03:28.850 --> 03:30.930
5u3那边他就把勾招函数直接给你干掉了

03:31.410 --> 03:33.570
没有了 当然说勾招函数都没有了

03:33.570 --> 03:35.810
勾招函数里边这些函数自然没有了 对吧

03:35.810 --> 03:38.370
这东西至少在勾招函数里边不存在了

03:39.330 --> 03:45.010
那么跑到哪去了呢 跑到5u应用实力里边去了

03:45.730 --> 03:48.130
我们在5u3里边还记得吗 以前我们是这么做的

03:48.690 --> 03:50.770
在入门阶段我们是通过create app

03:51.890 --> 03:55.330
传一个根主键进去 再创建一个应用 对吧

03:55.330 --> 03:56.530
这就是一个5u应用

03:56.930 --> 04:00.130
然后通过这个5u应用呢 我们在这里边呢

04:00.130 --> 04:02.530
就可以通过他里边提供的一些方法啊

04:02.530 --> 04:04.850
那么可以通过这个地址啊 大家可以看一下

04:05.810 --> 04:09.010
application就是5u应用里边的api 对吧

04:09.010 --> 04:12.370
components这个config就相当于是以前的这个

04:13.250 --> 04:16.130
5u叫config 平时我们也很少用的

04:16.130 --> 04:19.490
dirty注册全局的那个指定

04:19.970 --> 04:22.530
全局的混合挂载到某个组件

04:22.530 --> 04:24.610
挂载到某个页面区域 对吧

04:25.890 --> 04:28.930
这个是新增的啊 就是类似于以前的provide

04:30.050 --> 04:32.690
amount反挂载 对吧

04:33.170 --> 04:35.890
取消化载 又是我们就是用插线啊

04:35.890 --> 04:38.290
其实这两个能不能用得上啊 就这个东西

04:38.850 --> 04:41.410
这个 可能会用到这个

04:41.410 --> 04:44.370
就这么开这个components 对吧

04:45.090 --> 04:47.410
就是说呢 他现在的把他的api啊

04:47.410 --> 04:51.250
把这5u的那个构造函数的api提到哪去了呢

04:51.250 --> 04:52.690
提到实地里边去了

04:52.690 --> 04:54.370
5u应用实地里边去了

04:54.370 --> 04:56.530
那么从这个单码结构上你就可以看得出

04:57.970 --> 04:59.730
我 而且是链式编程 对吧

04:59.730 --> 05:01.250
为什么是链式编程呢 他是这样子

05:02.210 --> 05:05.410
你通过一个create view 得到的是一个app

05:05.410 --> 05:09.730
create view app 根主键

05:11.090 --> 05:12.690
得到的是一个app 对吧

05:12.690 --> 05:15.330
app里边一个函数叫use 对吧

05:15.330 --> 05:16.530
使用一些插件

05:16.530 --> 05:18.210
好 使用的插件过来 他返回了什么呢

05:18.210 --> 05:19.250
返回了还是这个app

05:19.250 --> 05:20.930
所以说我们可以链式编程啊

05:20.930 --> 05:21.890
然后调问他的make-sync

05:21.890 --> 05:23.090
make-sync返回了还是app

05:23.090 --> 05:25.010
又继续调问他的components

05:25.010 --> 05:26.130
那么这样子什么意思呢

05:26.130 --> 05:29.410
这句话 创建一个5u应用

05:30.370 --> 05:31.730
使用某一些插件

05:31.730 --> 05:33.970
那么这些插件只会影响这个应用

05:33.970 --> 05:35.570
因为它是通过实力来调用的

05:36.450 --> 05:37.090
好 然后呢

05:37.730 --> 05:39.810
混合一些配置

05:40.450 --> 05:42.530
当然现在呢有了components API了过后了

05:42.530 --> 05:43.730
也很少用这个make-sync的

05:44.850 --> 05:46.610
基本上要快要推出历史舞台了

05:47.490 --> 05:48.690
那么混合一东西

05:49.730 --> 05:52.370
在这个应用里边混合一些配置

05:52.370 --> 05:54.370
然后呢在全局注册一些组件

05:54.370 --> 05:57.010
也是只影响这个应用

05:57.730 --> 05:58.050
对不对

05:58.770 --> 06:00.130
它影响范围是有限的

06:00.850 --> 06:02.610
然后呢最后呢把这个应用挂载到

06:03.250 --> 06:03.730
这个地方

06:04.290 --> 06:05.970
以前18个老现在可以办到了

06:05.970 --> 06:08.290
那么第二个应用呢我什么都不做

06:08.290 --> 06:10.370
那么没有全局的插件

06:10.370 --> 06:11.330
也没有全局的混合

06:11.330 --> 06:12.450
也没有全局的组件

06:12.450 --> 06:13.650
那么直接挂得到f2

06:14.130 --> 06:15.090
调根组件就完事了

06:15.650 --> 06:16.130
对不对

06:16.130 --> 06:17.250
那么现在呢就用

06:17.250 --> 06:17.970
这种模式是吧

06:17.970 --> 06:18.450
是不是把它

06:19.730 --> 06:22.370
把这种影响范围广的这些app

06:22.370 --> 06:23.650
提到实力里边去了

06:23.650 --> 06:23.970
对吧

06:24.690 --> 06:26.290
就这么一个重大区别

06:27.250 --> 06:29.090
那么第一道面试题是不是可以回答了

06:29.090 --> 06:31.090
为什么五右三区掉了五右构造函数

06:31.090 --> 06:32.290
我下面一个参考答案

06:32.290 --> 06:33.170
大家可以看一下啊

06:33.170 --> 06:33.890
我给大家读一下

06:35.170 --> 06:37.250
因为五右二的全局构造函数

06:37.250 --> 06:38.370
带来了很多问题

06:39.490 --> 06:40.850
第一个问题就是我们刚才讲的

06:41.970 --> 06:44.130
第二用构造函数的静态方法

06:44.770 --> 06:46.050
因为它是属于构造函数的

06:46.050 --> 06:48.290
构造函数它是跨越所有的应用的

06:48.290 --> 06:48.850
对吧

06:48.850 --> 06:50.610
所有的应用都要用这个构造函数

06:50.610 --> 06:52.210
那么就会导致这个构造函数

06:52.210 --> 06:53.010
里边的静态方法

06:53.650 --> 06:55.730
它会影响到所有的五右应用

06:56.850 --> 06:57.890
不利于隔离

06:57.890 --> 06:59.810
当然这种情况遇到少一点

06:59.810 --> 07:01.250
但是我要把它说一下

07:01.250 --> 07:02.690
因为毕竟可能会有面试题

07:03.490 --> 07:05.490
然后还有什么好处

07:05.490 --> 07:06.450
还有什么问题呢

07:07.010 --> 07:08.690
就是五右二的构造函数

07:08.690 --> 07:10.210
它集成了太多的功能了

07:10.210 --> 07:10.850
你不觉得吧

07:11.570 --> 07:13.010
六一个五右里边有多少功能

07:13.490 --> 07:13.890
对不对

07:13.890 --> 07:15.250
所以构造函数里边都要完成

07:15.250 --> 07:16.530
还包括它的静态方法

07:16.530 --> 07:17.890
静态方法就是我们刚才看到的

07:17.890 --> 07:19.490
UZ、MX这些东西

07:20.050 --> 07:21.330
它集成了太多的功能了

07:21.330 --> 07:23.170
几乎我们五右的所有功能

07:23.170 --> 07:24.450
是不是都要通过它来创建的

07:25.170 --> 07:26.690
那么就不利于缺席

07:27.330 --> 07:29.010
尽管那里可能一个应用非常小

07:29.570 --> 07:30.610
它用不到这么多功能

07:31.250 --> 07:33.730
但是由于把整个构造函数导入进来了

07:33.730 --> 07:37.250
它就导致了打包的结果非常非常大

07:38.530 --> 07:39.650
之前我们在入门阶段

07:39.650 --> 07:41.250
你可以看到五右三的打包结果

07:41.250 --> 07:42.130
是不是要小一些

07:42.130 --> 07:42.930
为什么呢

07:42.930 --> 07:45.650
因为五右三不再有构造函数了

07:46.210 --> 07:47.490
它把我们要用的功能

07:47.490 --> 07:49.330
都是通过普通函数导出

07:49.330 --> 07:50.610
你看这是create app

07:50.610 --> 07:52.610
当时我们导入的时候是怎么导入的

07:53.570 --> 07:54.690
是这样导入的对吧

07:54.690 --> 07:57.730
是不是居民导入create app

07:57.730 --> 07:59.730
变成一个普通函数导入了

07:59.730 --> 08:01.570
是这样子写的

08:01.570 --> 08:04.610
那么这样子可以充分利用缺席

08:04.610 --> 08:05.730
用到的函数

08:05.730 --> 08:09.890
我们就到打包结果里边

08:09.890 --> 08:11.810
没有用到的就不进行打包

08:11.810 --> 08:13.090
就这么一回事

08:13.090 --> 08:14.610
它可以优化打包体积

08:14.610 --> 08:16.290
这个就要回答到

08:16.290 --> 08:18.290
还有第三个点就是

08:18.290 --> 08:20.290
就是设计上的了

08:21.170 --> 08:21.970
五右二呢

08:21.970 --> 08:24.450
实际上这里设计的是比较混乱的

08:24.450 --> 08:26.530
不知道大家有没有这个印象啊

08:26.530 --> 08:28.530
你们刚刚开始学习五右二的时候

08:28.530 --> 08:31.010
老师已经给你们掩饰过这么一个东西

08:31.730 --> 08:32.690
六一个五右

08:36.980 --> 08:38.660
把这个vm打印出来看了一下

08:38.660 --> 08:39.220
对吧

08:39.220 --> 08:41.140
这个vm里边有什么有什么

08:41.140 --> 08:42.420
dollar sets

08:42.420 --> 08:43.700
dollar mounts

08:43.700 --> 08:45.220
dollar什么

08:45.220 --> 08:46.180
那个dnet

08:46.180 --> 08:47.620
一大堆dollar

08:47.620 --> 08:48.340
一大堆

08:48.340 --> 08:49.940
还有什么下滑线的对吧

08:49.940 --> 08:51.460
还有什么配置data的

08:51.460 --> 08:52.660
会提取到这里面

08:52.820 --> 08:54.180
它像不像一个组件啊

08:55.060 --> 08:56.420
是不是整一像一个组件啊

08:56.420 --> 08:58.020
还有什么dollar data对吧

08:58.020 --> 08:59.060
一大堆

08:59.060 --> 09:00.180
它特别像一个组件

09:02.180 --> 09:02.500
那么

09:03.300 --> 09:05.060
实际上它是不是一个组件呢

09:05.060 --> 09:06.260
它又是一个组件

09:06.260 --> 09:08.260
同时它又代表的是一个五右应用

09:08.900 --> 09:09.620
是不是有点混乱

09:09.620 --> 09:11.140
这两个概念是没有区分开的

09:11.140 --> 09:13.380
在五右里边根本就没把两个概念区分开

09:14.340 --> 09:15.380
我们在五右二里边

09:15.380 --> 09:17.060
通过六一个五右创建的对象

09:17.060 --> 09:18.660
它既是一个五右应用

09:18.660 --> 09:20.020
它控制一面的一个区域

09:20.020 --> 09:20.340
对吧

09:20.980 --> 09:22.340
表示一个五右应用产生了

09:22.900 --> 09:23.860
然后同时呢

09:23.860 --> 09:26.500
同时呢又是一个特殊的五右组件

09:26.500 --> 09:28.020
这个组件里边还要配置什么

09:28.020 --> 09:29.300
配置这个eL对不对

09:30.180 --> 09:31.620
当时我们是不是还说到

09:31.620 --> 09:32.900
这个eL呢

09:32.900 --> 09:34.260
可以在这个这里边配置

09:34.260 --> 09:35.940
但是呢组件里边就不能用这个了

09:35.940 --> 09:36.580
对吧

09:36.580 --> 09:38.340
因为我们觉得组件跟它很像

09:39.540 --> 09:40.660
在这里边配置的时候

09:40.660 --> 09:41.700
data是一个对象

09:41.700 --> 09:43.300
组件里边data得是一个函数

09:43.300 --> 09:43.860
对不对

09:43.860 --> 09:45.140
所以当时是这样说的啊

09:46.260 --> 09:46.500
那么

09:47.220 --> 09:50.180
说明了之前就根本没有把这两个概念区分开

09:50.180 --> 09:51.460
这是设计上的混乱

09:51.940 --> 09:54.260
在五右三里边上就必须要把这个解决了

09:54.260 --> 09:56.260
它就把两个概念全部去完全区分开了

09:56.260 --> 09:58.260
那么现在就非常非常清晰了

09:59.620 --> 10:02.100
我们通过挂载到一面一个区域的时候

10:02.100 --> 10:02.900
通过谁来挂载

10:02.900 --> 10:05.300
通过的是一个五右应用

10:05.300 --> 10:07.220
它不是一个特殊组件的

10:07.220 --> 10:08.500
它不但是一个特殊组件的

10:08.500 --> 10:10.580
也就是通过crazy app创建的东西的

10:10.580 --> 10:11.700
根本就不会有这些东西的

10:12.340 --> 10:12.900
不会有了

10:13.700 --> 10:14.900
我们可以当上

10:14.900 --> 10:16.020
我们刚才也可以看到啊

10:17.060 --> 10:19.220
通过crazy app创建的对象里面

10:19.220 --> 10:20.980
只有这么一些函数

10:21.060 --> 10:21.940
其他都没了

10:21.940 --> 10:22.420
对吧

10:22.420 --> 10:23.460
来控制选举的

10:24.020 --> 10:25.220
它并不是一个组件

10:25.220 --> 10:26.180
以前还有四个组件

10:26.180 --> 10:27.220
又是一个不由应用

10:27.220 --> 10:27.860
就很混乱

10:28.580 --> 10:29.060
原来的意思

10:30.180 --> 10:30.420
好

10:30.420 --> 10:30.740
这是

10:31.540 --> 10:32.100
这一块啊

10:33.700 --> 10:35.460
你把这三点能够回答上来

10:35.460 --> 10:36.100
那么面试题

10:36.100 --> 10:36.900
第一个都面试题了

10:36.900 --> 10:37.620
基本上就OK了

10:40.020 --> 10:40.340
好

10:40.340 --> 10:42.100
然后呢是第二个呢

10:42.100 --> 10:43.700
第二个地方不产生面试题啊

10:43.700 --> 10:45.140
是跟我们平时开发相关的

10:45.140 --> 10:46.660
我顺便提一下啊

10:46.660 --> 10:48.260
第一个点的就是五右实力啊

10:48.260 --> 10:49.460
现在组件实力啊

10:49.460 --> 10:50.260
现在我们的组件

10:50.340 --> 10:51.780
我们之前打印过的对吧

10:51.780 --> 10:53.460
组件里面会打印z

10:53.460 --> 10:54.340
我们再打印一下吧

10:55.140 --> 10:56.340
随便找个地方啊

10:56.340 --> 10:57.060
这credit对吧

10:58.740 --> 10:59.620
再打印z

11:00.500 --> 11:01.220
可以看到呢

11:07.820 --> 11:09.980
Mt.Rondev

11:11.660 --> 11:12.220
打开啊

11:12.940 --> 11:14.220
可以看到这个z是啥呢

11:14.220 --> 11:15.420
就是一个组件实力对吧

11:15.420 --> 11:16.220
就是一个组件实力

11:16.220 --> 11:17.100
它是一个proxy

11:17.740 --> 11:19.340
这是一个比较大的变化啊

11:19.340 --> 11:21.260
组件实力呢变成一个proxy的

11:21.260 --> 11:22.300
就你访问了什么东西呢

11:22.300 --> 11:23.260
新过这个proxy

11:23.260 --> 11:23.980
他跟你提过

11:24.540 --> 11:26.540
那么这个组件实力里边啊

11:26.540 --> 11:28.140
这个组件实力要一定要区分开啊

11:28.140 --> 11:29.100
跟这个create app

11:29.100 --> 11:30.220
返回了这个实力

11:30.220 --> 11:31.340
不是一个东西啊

11:31.340 --> 11:32.460
那种东西叫做运用啊

11:32.460 --> 11:34.060
返回的是组件运用

11:34.060 --> 11:36.860
组件实力里边提供了哪些属性和方法呢

11:36.860 --> 11:37.740
跟过去差不多

11:38.460 --> 11:39.980
比过去要少一些了

11:39.980 --> 11:42.220
首先你那些下滑线的东西也看不见了

11:42.220 --> 11:43.180
之前我演示过啊

11:43.180 --> 11:43.900
不再重复了

11:44.380 --> 11:45.500
那么属性有这么一些

11:45.500 --> 11:46.300
这就可以看一下啊

11:46.860 --> 11:48.220
体验熟的对吧

11:48.220 --> 11:48.780
体验熟的

11:48.780 --> 11:49.900
平时我们用了哪些呢

11:49.900 --> 11:51.100
好像也没用到啥

11:51.100 --> 11:52.860
对吧这里面可能会用到parent

11:52.940 --> 11:54.060
表示它的副组件

11:54.060 --> 11:55.420
现在也不会用到啥了

11:55.420 --> 11:56.140
snot呢

11:56.140 --> 11:59.020
就这个组件的相当于是直组件啊

11:59.020 --> 12:00.620
它的就是插槽里边东西

12:01.420 --> 12:02.540
好方法呢

12:02.540 --> 12:04.060
我们可能看一下方法吧

12:04.700 --> 12:05.980
instance properties

12:05.980 --> 12:08.460
啊组件的属性

12:08.460 --> 12:09.660
组件实力的属性

12:09.660 --> 12:10.860
组件实力的方法

12:10.860 --> 12:12.220
那么实力的方法里边呢

12:12.220 --> 12:12.780
有watch

12:14.060 --> 12:15.020
没啥说了吧

12:15.020 --> 12:16.620
amd我们用了比较多的对吧

12:17.260 --> 12:18.060
触发一个实际

12:18.060 --> 12:18.780
跟以前一样的啊

12:18.780 --> 12:19.660
完全一样tick

12:20.540 --> 12:21.500
跟以前一样的啊

12:21.900 --> 12:22.620
强制刷新

12:23.340 --> 12:24.220
都跟以前一样的

12:24.700 --> 12:26.540
大家发现没是不是少了很多啊

12:26.540 --> 12:28.060
以前的我们的组件实力里边

12:28.060 --> 12:29.180
是一大堆东西啊

12:29.180 --> 12:29.980
超级多的东西

12:30.700 --> 12:31.900
有什么有多热符号

12:31.900 --> 12:32.940
有下滑线都可以用

12:32.940 --> 12:34.460
但是现在有了proxy过后

12:34.460 --> 12:36.380
因为它把组件变成了proxy

12:36.380 --> 12:38.060
你去访问以前不应该访问的东西

12:38.060 --> 12:39.180
它就给什么都不给你

12:39.180 --> 12:40.380
不要问你去访问这个属性

12:40.940 --> 12:42.620
因为你是通过这个proxy访问的

12:43.500 --> 12:44.460
你访问的是谁

12:44.460 --> 12:45.180
你访问的是谁

12:45.180 --> 12:45.900
哎呦

12:46.940 --> 12:48.140
你访问的是这个proxy

12:49.260 --> 12:50.700
现在我们通过历史去访问的话

12:50.700 --> 12:51.740
访问的是proxy对吧

12:52.460 --> 12:53.900
那么这个下滑线的东西呢

12:53.900 --> 12:54.620
你可以认为这样

12:54.620 --> 12:55.580
你可以这样子想

12:55.580 --> 12:56.860
它里边实际上是有的

12:56.860 --> 12:57.980
但它不给力

12:57.980 --> 12:58.460
对吧

12:58.460 --> 12:59.660
proxy它不给力

12:59.660 --> 13:01.180
它认为你不应该用这个东西

13:01.900 --> 13:03.020
以前是普通对象

13:03.020 --> 13:03.900
它里边有啥的

13:04.300 --> 13:05.100
你都可以用

13:05.100 --> 13:06.620
尽管它先前继续说

13:06.620 --> 13:07.740
不要用不要用这个东西

13:07.740 --> 13:08.780
是我们内部的东西啊

13:08.780 --> 13:09.980
下滑线开头的

13:09.980 --> 13:11.740
但是那你就有可能会去用

13:12.220 --> 13:12.940
原来的意思吧

13:12.940 --> 13:14.780
说现在的干脆给你用个proxy

13:15.660 --> 13:16.780
那么有一个proxy过后呢

13:16.780 --> 13:18.060
你调用它根本不给力

13:19.180 --> 13:20.460
你只能调用这里边

13:20.460 --> 13:21.020
列表里边

13:21.500 --> 13:23.180
这里说到了属性和方向

13:23.580 --> 13:24.460
原来的意思吧

13:24.460 --> 13:25.420
那么这里呢就是

13:26.460 --> 13:27.420
这一块的变动啊

13:27.980 --> 13:29.340
就算它们没有啥

13:29.820 --> 13:31.260
我们常用的跟以前是一样的

13:32.300 --> 13:32.620
好

13:32.620 --> 13:33.580
接下来就是要回答

13:33.580 --> 13:34.860
第二个面试题的啊

13:34.860 --> 13:37.420
谈谈你对5u3数据响应式的理解

13:37.820 --> 13:40.060
因为大家的可能通过各种渠道啊

13:40.060 --> 13:41.420
都知道5u3呢

13:41.420 --> 13:42.940
它对数据的响应式呢

13:42.940 --> 13:43.900
做了重大的变化

13:44.540 --> 13:46.060
就是我们以前呢

13:46.060 --> 13:47.020
5u2的时候

13:47.020 --> 13:48.460
数据响应式是通过

13:48.460 --> 13:50.540
opg是define property完成的

13:50.700 --> 13:52.380
但是5u3是通过proxy完成的

13:52.860 --> 13:54.620
好我们来在这里详细说一说啊

13:54.620 --> 13:56.460
它到底怎么变化的

13:56.460 --> 13:57.340
它有什么好处

13:59.340 --> 14:00.460
5u2呢5u3

14:00.940 --> 14:03.260
其实呢它们完成数据响应式啊

14:03.260 --> 14:04.860
都是在相同的生命周期

14:05.340 --> 14:06.300
哪个生命周期呢

14:06.300 --> 14:07.420
给大家回顾一下啊

14:07.420 --> 14:08.300
给大家一声一旺

14:16.580 --> 14:17.300
在哪呢在这

14:18.340 --> 14:19.780
5u10例啊往下走

14:20.740 --> 14:29.200
injection注入reactivity响应式

14:29.600 --> 14:31.200
在这一步完成数据响应式的

14:31.200 --> 14:32.720
也就是说在生命周期含述

14:32.720 --> 14:34.320
before created之后

14:34.800 --> 14:37.600
created之前完成了数据响应式

14:37.600 --> 14:38.640
那么这个时候呢

14:38.640 --> 14:39.920
到created的喊数里边

14:39.920 --> 14:40.800
勾字喊数里边

14:40.800 --> 14:42.880
我们就可以改动数据了

14:42.880 --> 14:43.280
对吧

14:43.280 --> 14:45.280
改动数据它是能够收到数据响应式的

14:46.080 --> 14:46.720
多少点意思啊

14:48.160 --> 14:48.480
好

14:49.280 --> 14:51.280
那么5u3跟5u2是一样的

14:51.360 --> 14:53.520
也是在这个阶段完成数据响应式的

14:53.520 --> 14:55.520
怎么还能够做做法是不一样的

14:55.520 --> 14:56.960
这做法什么不一样呢

14:56.960 --> 14:58.000
我们看一下5u2

14:58.000 --> 14:58.960
5u2呢

14:58.960 --> 15:00.560
就比较暴力了一点了啊

15:00.560 --> 15:01.280
就是

15:02.160 --> 15:03.040
比方说这个data

15:03.040 --> 15:04.080
比较反复的这个data

15:04.080 --> 15:05.440
我要完成数据响应式

15:05.440 --> 15:06.400
它怎么完成呢

15:07.280 --> 15:08.320
循环辩理

15:08.720 --> 15:09.840
而且是地规辩理

15:09.840 --> 15:11.840
甭管一个对象掏的有多深

15:12.400 --> 15:12.960
地规辩理

15:12.960 --> 15:14.240
所有的属性全部要辩理出来

15:14.880 --> 15:17.520
对每一个属性使用OBG的DefineProperty

15:17.520 --> 15:19.520
重新定义一次

15:20.320 --> 15:20.800
对吧

15:20.880 --> 15:22.960
不然的话不不不重新定义的话

15:22.960 --> 15:24.160
里边就没有get a set

15:25.600 --> 15:26.080
对不对

15:26.080 --> 15:27.760
那么这样子才能完成数据响应式

15:27.760 --> 15:28.640
那么想一想

15:28.640 --> 15:29.760
如果说这个对象很大

15:30.720 --> 15:31.920
都还是一个组件的

15:32.640 --> 15:34.560
如果说我有1000个组件

15:34.560 --> 15:37.840
每个组件里面属性有10个吧

15:37.840 --> 15:38.400
不多吧

15:38.400 --> 15:39.040
平均10个

15:40.080 --> 15:41.680
那么我们就有一万个

15:42.160 --> 15:43.280
所以要便利一万次

15:44.000 --> 15:44.640
对吧

15:44.640 --> 15:48.800
还如果说数据比较深的话

15:48.800 --> 15:50.000
那还更加恐怖

15:51.280 --> 15:53.120
那么便利是不是非常非常多

15:53.760 --> 15:56.160
在初始的时候便利属性非常非常多

15:56.160 --> 15:57.840
那么会严重的脱裂效率

15:57.840 --> 15:58.960
而且这样的问题

15:58.960 --> 16:00.320
还有很多很多的问题

16:00.320 --> 16:02.000
因为我次在一开始便利的

16:02.000 --> 16:03.120
后边就不再便利的

16:03.120 --> 16:04.240
就是到神明周期含书

16:04.240 --> 16:04.960
这个过了过后

16:05.920 --> 16:07.680
后边我如果说我加了一个属性

16:07.680 --> 16:08.400
它能坚定到吗

16:08.400 --> 16:09.520
它坚定不到

16:09.520 --> 16:10.880
因为对于这个新的属性

16:10.880 --> 16:12.800
它已经完成了这个阶段了

16:12.800 --> 16:13.520
所以说呢

16:13.520 --> 16:14.480
后边再加属性

16:14.480 --> 16:15.840
它是坚定不到的

16:15.840 --> 16:16.400
因此呢

16:16.400 --> 16:17.120
5u里边

16:18.480 --> 16:20.320
是不是有些东西是得不到数据

16:21.280 --> 16:21.840
记得吗

16:21.840 --> 16:22.880
5u2里边

16:22.880 --> 16:24.160
所以说它可以提供了什么呢

16:24.160 --> 16:25.200
提供了这个

16:25.200 --> 16:26.000
set对吧

16:26.960 --> 16:28.800
当你要听新增属性的时候

16:28.800 --> 16:30.240
还要让你去调用这个方法

16:31.920 --> 16:32.400
对不对

16:32.400 --> 16:34.160
你看一下5u3里边还有这个方法

16:38.500 --> 16:39.380
你看一下啊

16:39.380 --> 16:40.340
就要set

16:40.340 --> 16:41.780
你看下有一个这个方法

16:43.380 --> 16:43.940
刷新

16:43.940 --> 16:44.900
说undefend

16:44.900 --> 16:46.180
不存在这个方法了

16:46.180 --> 16:47.380
不需要了

16:47.380 --> 16:48.500
没有意义的这个方法

16:48.500 --> 16:50.340
这个方法本来就是以前没办法

16:51.380 --> 16:53.220
才出此下车

16:53.300 --> 16:54.100
现在有办法了

16:54.100 --> 16:55.140
就不需要一个东西了

16:55.140 --> 16:55.700
那么同时

16:55.700 --> 16:57.060
你们看API稳当里边

16:57.860 --> 16:58.580
它的什么呢

16:58.580 --> 16:59.060
它的那个

17:01.140 --> 17:02.180
instance methods里边

17:02.180 --> 17:03.140
有没有set

17:03.140 --> 17:04.020
set方法

17:04.020 --> 17:04.820
没有

17:04.820 --> 17:06.420
以前三处属性还要什么呢

17:06.980 --> 17:08.980
三处属性是不是还得调用这个z

17:10.260 --> 17:11.860
delete来三处属性

17:11.860 --> 17:13.300
三处某个对象的某个属性

17:13.300 --> 17:13.860
对吧

17:13.860 --> 17:14.980
因为你只有调用方法

17:14.980 --> 17:16.660
它才能收到通知

17:16.660 --> 17:18.020
才能完成数据想像式

17:18.740 --> 17:19.700
但现在不需要了

17:20.420 --> 17:21.140
为什么呢

17:21.140 --> 17:22.260
因为5u3

17:22.340 --> 17:24.020
使用的是es6的proxy

17:25.540 --> 17:26.580
效率又高

17:27.140 --> 17:28.740
因为proxy本身效率又比它高

17:28.740 --> 17:29.380
对吧

17:29.380 --> 17:30.420
我们在讲es6的时候

17:30.420 --> 17:31.460
讲过这个proxy

17:31.460 --> 17:32.420
效率本身就比它高

17:34.180 --> 17:35.140
而且呢

17:35.140 --> 17:36.580
它不用去便利属性的

17:37.140 --> 17:38.180
5u3怎么做的

17:38.180 --> 17:40.100
在那个完成数据想像式的

17:40.100 --> 17:40.900
神明周期里边

17:41.940 --> 17:43.300
现在我们要完成数据想像式的

17:43.780 --> 17:44.420
对吧

17:44.420 --> 17:46.180
以这个对象哪怕大过天

17:47.300 --> 17:48.020
一一个

17:48.020 --> 17:49.860
我们就夸张一一个属性

17:49.860 --> 17:50.820
没关系

17:50.900 --> 17:52.420
瞬间完成数据想像式

17:52.420 --> 17:53.780
怎么瞬间完成6一个proxy

17:53.780 --> 17:54.260
完了

17:55.620 --> 17:57.220
我就给你6一个proxy

17:57.220 --> 17:58.100
想啥都不用做

17:58.900 --> 17:59.780
为什么呢

17:59.780 --> 18:00.820
因为proxy

18:00.820 --> 18:02.180
代理对象是动态的

18:02.180 --> 18:04.740
当以后要用到哪个属性的时候

18:05.300 --> 18:07.220
比方说

18:07.220 --> 18:08.180
我6了一个proxy

18:10.980 --> 18:12.260
用了一个proxy

18:12.260 --> 18:12.820
代理谁呢

18:12.820 --> 18:13.540
代理这个data

18:13.540 --> 18:13.860
对吧

18:13.860 --> 18:14.580
代理这个对象

18:15.140 --> 18:15.380
好

18:15.380 --> 18:17.060
那么这里是不是代理的配置

18:17.060 --> 18:18.340
配置里边是不是可以写

18:18.340 --> 18:18.740
gait

18:19.460 --> 18:20.100
是不是可以写

18:21.620 --> 18:22.420
set

18:22.420 --> 18:23.380
对不对

18:23.380 --> 18:24.820
当然一个参数没写了

18:26.260 --> 18:26.900
懂我意思吗

18:26.900 --> 18:28.900
当你要去通过这个代理对象

18:28.900 --> 18:30.500
比方说我们这里代理对象是p

18:31.060 --> 18:32.340
那就是代理对象

18:32.340 --> 18:33.540
那么我们到时候访问的时候

18:33.540 --> 18:34.900
是不是通过代理对象访问的

18:34.900 --> 18:35.860
然后p.name

18:36.580 --> 18:37.380
访问他的时候

18:37.380 --> 18:38.420
是不是会运行gait

18:38.420 --> 18:39.700
这个时候才会运行gait

18:40.420 --> 18:40.740
对吧

18:40.740 --> 18:41.540
这个时候运行gait

18:41.540 --> 18:42.340
那么从gait里面

18:42.340 --> 18:44.420
就达到原始对象里面的name

18:44.420 --> 18:44.820
给力

18:44.820 --> 18:45.220
拿到什么

18:45.220 --> 18:45.860
拿到molika

18:46.500 --> 18:46.900
对吧

18:46.900 --> 18:47.380
molika

18:48.180 --> 18:48.500
好

18:48.500 --> 18:49.860
那么p.a

18:49.860 --> 18:50.180
那么

18:50.820 --> 18:52.100
当我们调用代理对象的A级的时候

18:52.100 --> 18:53.380
代理对象这个时候去读取

18:53.380 --> 18:54.660
原始对象的A级

18:54.660 --> 18:55.940
拿到17

18:55.940 --> 18:57.220
给力

18:57.220 --> 18:57.860
对不对

18:57.860 --> 18:59.780
当然你去设置他的属性的时候

18:59.780 --> 19:01.060
他也会运行set

19:01.060 --> 19:02.340
触发重新渲染

19:02.340 --> 19:03.380
对吧

19:03.380 --> 19:04.260
是这么一回事了

19:04.260 --> 19:06.180
现在就直接返回代理对象

19:06.180 --> 19:07.460
你到时候用哪个属性的时候

19:07.460 --> 19:08.740
我就去读了一个

19:08.740 --> 19:10.020
是不是动态的了

19:10.020 --> 19:10.580
对不对

19:10.580 --> 19:11.300
用多少读多少

19:11.300 --> 19:12.580
是动态的读取的

19:12.580 --> 19:14.100
而不是以前一个个个便利出来

19:14.100 --> 19:15.140
然后再different property

19:16.420 --> 19:17.460
不一样了

19:17.460 --> 19:18.980
那如果说代理对象我要去读什么

19:18.980 --> 19:20.500
我要去读addr呢

19:21.460 --> 19:22.340
那他怎么办呢

19:22.340 --> 19:24.100
他给你返回的又是一个代理

19:24.100 --> 19:26.900
返回的是一个addr的proxy

19:26.900 --> 19:27.620
一个代理

19:29.860 --> 19:30.660
懂我意思吧

19:30.660 --> 19:31.700
他返回的又是个新代理

19:31.700 --> 19:32.980
这都是动态返回的

19:32.980 --> 19:34.820
你读的时候才会返回

19:34.820 --> 19:35.380
没有读的时候

19:35.380 --> 19:37.780
他就根本不会去便利它

19:37.780 --> 19:38.340
所以说

19:38.340 --> 19:40.100
这一步的速度是极快的

19:44.540 --> 19:45.820
这一步的速度是极快的

19:45.820 --> 19:47.580
就是产生一个代理对象没了

19:49.180 --> 19:49.820
懂我意思吧

19:51.020 --> 19:52.380
后续都是动态的

19:52.540 --> 19:53.900
说说我们这个面试题怎么回答

19:54.780 --> 19:57.740
谈谈你对5u3的数据详意识的理解

19:58.380 --> 20:00.300
5u3不再使用这种方式了

20:00.300 --> 20:01.420
而是使用proxy

20:01.420 --> 20:03.980
proxy它本身的效率就比它高

20:04.860 --> 20:06.140
因为它是更加偏底层的

20:06.140 --> 20:07.980
直接从内存里面读取数据

20:07.980 --> 20:08.460
对吧

20:08.460 --> 20:09.900
通过反射拿数据

20:09.900 --> 20:10.620
效率更高

20:11.180 --> 20:12.300
而且它不用去

20:12.300 --> 20:14.060
地规便利所有的属性了

20:14.060 --> 20:15.020
直接得到一个proxy

20:16.220 --> 20:17.420
所以说在5u3中

20:17.420 --> 20:19.660
对数据的访问是动态的

20:19.660 --> 20:20.540
你访问哪一个

20:20.540 --> 20:21.340
我给你哪一个

20:22.060 --> 20:22.940
访问的是对象

20:22.940 --> 20:23.980
我就给你一个新的proxy

20:24.620 --> 20:25.580
访问的是普通的数据

20:25.580 --> 20:26.540
像我就直接把字给你

20:28.620 --> 20:29.740
那么这有极大的提升了

20:29.740 --> 20:31.420
组建在初始阶段的效率

20:32.620 --> 20:34.780
那么以前在512里面白平

20:34.780 --> 20:35.100
对吧

20:35.100 --> 20:35.740
一开始白平

20:36.380 --> 20:37.980
是因为它要去对各种图件

20:37.980 --> 20:38.940
完成数据详细

20:38.940 --> 20:40.620
这个是还是要耗时间的

20:41.820 --> 20:43.580
这有一部分因素在几的

20:43.980 --> 20:44.700
那么这样子的

20:44.700 --> 20:46.460
至少把这个问题解决了

20:47.020 --> 20:48.380
同时由于proxy

20:48.620 --> 20:50.140
它可以监听到很多行为

20:51.100 --> 20:52.300
我们以前学过proxy

20:52.300 --> 20:53.100
可以监听到哪些

20:53.100 --> 20:54.300
新增属性能不能监听到

20:54.300 --> 20:55.340
你访问任何属性

20:55.340 --> 20:56.380
哪怕属性不存在

20:56.380 --> 20:57.180
它都可以监听到

20:57.820 --> 20:58.300
对吧

20:58.300 --> 21:00.540
所以新增属性是可以监听到的

21:01.660 --> 21:03.020
那么同时呢

21:03.020 --> 21:05.580
三处属性用delete来三处属性

21:05.580 --> 21:06.860
当时我们现在要三处属性

21:07.580 --> 21:08.860
delete3就行了

21:08.860 --> 21:10.060
比方说3t两内

21:11.020 --> 21:11.740
3就行了

21:11.740 --> 21:12.540
它能监听到的

21:12.540 --> 21:13.180
因为为什么呢

21:13.180 --> 21:14.220
因为它这里边可以

21:14.220 --> 21:15.340
有这么一个勾字函数

21:15.340 --> 21:16.780
delete property

21:16.780 --> 21:18.060
它就会运行这个函数

21:18.060 --> 21:18.380
对吧

21:18.380 --> 21:19.900
有以前学过的proxy里边

21:19.980 --> 21:21.020
它就会触发这个函数

21:21.740 --> 21:23.100
它可以监听到所有东西

21:23.100 --> 21:23.660
那么现在

21:24.300 --> 21:25.500
以前obj这个设

21:25.500 --> 21:26.540
delete property

21:26.540 --> 21:27.580
是不是监听不到这些东西

21:28.300 --> 21:28.620
对吧

21:29.340 --> 21:29.900
监听不到

21:30.540 --> 21:32.380
新增属性和三处属性

21:32.380 --> 21:33.100
都可以监听到了

21:33.100 --> 21:34.620
所以说在5.6.3中呢

21:34.620 --> 21:35.660
新增成员

21:35.660 --> 21:36.620
三处成员

21:36.620 --> 21:37.340
直接用就行了

21:37.340 --> 21:38.140
直接来就行了

21:38.140 --> 21:39.180
全都能监听到

21:39.180 --> 21:40.620
包括索因访问等等

21:40.620 --> 21:42.380
军可以触发重新宣的

21:42.380 --> 21:43.420
都是可以享用时的

21:44.300 --> 21:45.420
这些在5.6.2里边

21:45.420 --> 21:46.220
根本做不到的

21:46.220 --> 21:47.500
所以5.6.2才没办法

21:47.500 --> 21:48.860
给你提供一个set函数

21:48.860 --> 21:49.820
给你提供一个delete

21:50.780 --> 21:51.660
那么现在呢

21:51.660 --> 21:53.100
就不用这种非常兜的方式了

21:54.380 --> 21:55.740
这就是这几个问题

21:56.620 --> 21:57.660
给大家讲清楚

21:58.300 --> 21:59.260
那么这两个面试题

21:59.260 --> 21:59.980
是不是又可以做了

22:01.340 --> 22:02.380
咱们这个阶段

22:02.380 --> 22:03.260
就业这个阶段

22:03.980 --> 22:06.300
一方面是讲各种场景的面试题

22:08.540 --> 22:09.500
同时加深大家

22:09.500 --> 22:11.020
对这一块的知识的理解

22:13.020 --> 22:13.820
第二层面

22:13.820 --> 22:14.780
有可能会讲一些

22:16.780 --> 22:17.340
平时

22:18.460 --> 22:19.340
我们在入门阶段

22:19.340 --> 22:20.300
没有用到的知识

22:20.780 --> 22:22.220
但是平时开发中要用的知识

22:22.220 --> 22:23.820
我们也会在就业阶段进行讲解

22:24.300 --> 22:24.620
好了

22:25.260 --> 22:25.420
好

22:25.420 --> 22:26.220
这是这些可能内容

