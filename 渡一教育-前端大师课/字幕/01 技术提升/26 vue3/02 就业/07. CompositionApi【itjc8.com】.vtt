WEBVTT

00:00.430 --> 00:04.230
好 这一课我们再来聊一聊这个Completion API

00:04.230 --> 00:06.230
其实在入门阶段啊

00:06.230 --> 00:08.230
咱们把Completion API大体上

00:08.230 --> 00:10.230
80%的功能都已经了解过了

00:10.230 --> 00:11.630
其实有些东西呢

00:11.630 --> 00:14.230
它是属于想用式API的

00:14.230 --> 00:15.430
就上几课的内容

00:15.430 --> 00:16.230
对吧

00:16.230 --> 00:17.930
Completion API呢

00:17.930 --> 00:20.430
我们这一课再来进一步聊一聊啊

00:20.430 --> 00:23.430
聊一聊它的一些其他的一些知识点

00:23.430 --> 00:26.630
顺便呢我们来做一道面试题

00:26.630 --> 00:28.730
然后呢来做一个效果啊

00:28.730 --> 00:30.130
先给大家看一下效果吧

00:30.230 --> 00:35.590
这几课我们也需要完成一个效果在这

00:35.590 --> 00:36.790
运行出来啊

00:36.790 --> 00:41.120
Roundale

00:41.120 --> 00:42.420
就这么一个效果

00:42.420 --> 00:44.320
这是因为现在2020年嘛

00:44.320 --> 00:45.020
还没过完

00:45.020 --> 00:48.220
所以说在一个统计一下2019年的GDP

00:48.220 --> 00:49.320
下边呢可以更改啊

00:49.320 --> 00:52.020
比方说我们这里改成30

00:52.020 --> 00:53.820
你看上面也可以跟着变

00:53.820 --> 00:57.020
中国24啊跟着变啊就这么个意思

00:57.020 --> 01:00.020
这是这几课怎么样完成的效果啊

01:00.020 --> 01:01.920
好来吧

01:02.020 --> 01:04.320
我们先把这个Completion API的一些

01:04.320 --> 01:06.820
其他的情况啊给大家说一下

01:06.820 --> 01:08.320
然后呢我们来做一道面试题

01:08.320 --> 01:09.620
然后完成个效果

01:09.620 --> 01:10.820
第一个setup函数

01:12.220 --> 01:16.220
跟那个上节课的讲的想用式API不同

01:16.220 --> 01:17.620
因为我们说想用式API呢

01:17.620 --> 01:19.420
它是可以脱离组件存在的

01:19.420 --> 01:21.220
它是抽离出去的

01:21.220 --> 01:22.320
Completion API呢

01:22.320 --> 01:25.120
它跟组件呢是有深度绑定的啊

01:25.120 --> 01:26.220
它里面提供了很多函数

01:26.220 --> 01:27.620
跟组件有深度绑定

01:27.620 --> 01:29.720
它不能脱离组件而存在

01:29.720 --> 01:31.620
其中的一个就是setup函数

01:31.620 --> 01:32.820
那么这个函数啊大家知道

01:32.820 --> 01:33.920
它是配置到哪的呢

01:33.920 --> 01:35.720
是配置到组件里边的

01:35.720 --> 01:37.620
你不能单独写出去吧

01:37.620 --> 01:39.820
这个函数呢实际上它是有两个参数的

01:39.820 --> 01:41.620
在入门阶段呢我们没有用到

01:41.620 --> 01:44.220
但是呢在就业阶段我们之前也提到过

01:44.220 --> 01:45.520
对吧有两个参数

01:45.520 --> 01:47.720
一个是probs一个是context

01:47.720 --> 01:49.720
那么这个函数什么时候运行呢

01:49.720 --> 01:51.120
它是在属性啊

01:51.120 --> 01:52.520
我们不是使用一个组件吗

01:52.520 --> 01:53.720
比方这个组件啊

01:53.720 --> 01:55.520
咱们用它的时候咋用呢

01:55.520 --> 01:56.720
咱们多了一个

01:58.320 --> 01:59.220
用它的时候

02:00.220 --> 02:01.320
不是我们写了一个什么

02:01.320 --> 02:03.020
我们写了一个等一下我来关一下

02:07.720 --> 02:09.620
用它的时候我们不是这样子写吗

02:10.520 --> 02:13.020
组件然后会给它传一些属性的吧

02:14.020 --> 02:15.220
所以给它传一些属性

02:16.020 --> 02:17.520
那么这样子呢它会

02:17.820 --> 02:19.320
创建这个组件的实力

02:19.920 --> 02:21.820
然后把这个属性给它注入进去

02:21.820 --> 02:22.420
对吧

02:22.520 --> 02:24.420
当它把属性注入过后呢

02:24.420 --> 02:26.720
它就会运行这个setup函数

02:27.720 --> 02:28.920
实际上了这个时候啊

02:29.020 --> 02:30.020
时间点更早

02:30.120 --> 02:32.120
这个时候连组件实力都没有

02:32.320 --> 02:34.920
因此呢你在setup函数里边去使用Z

02:35.020 --> 02:35.920
指向的是人

02:35.920 --> 02:37.020
指向的是undefined

02:37.520 --> 02:38.320
它没有Z

02:38.420 --> 02:39.820
这个时候连组件实力都没有

02:40.320 --> 02:41.820
它就是把属性搞定了过后

02:41.820 --> 02:43.020
它就会运行这个函数

02:43.020 --> 02:44.520
它运行的时间非常早

02:45.020 --> 02:46.020
而且呢这个函数呢

02:46.020 --> 02:47.320
它只会运行一次

02:48.320 --> 02:50.220
一个组件它只会运行一次

02:50.420 --> 02:52.020
然后这里我用了两次组件

02:52.020 --> 02:52.720
它会运行几次的

02:52.720 --> 02:54.020
它就会运行两次对吧

02:54.020 --> 02:55.120
对同一个组件而言

02:55.120 --> 02:56.320
它就会运行一次

02:56.820 --> 02:58.020
它不会反复运行

02:58.620 --> 02:59.620
这是setup函数

03:00.420 --> 03:01.920
那么在setup函数里边呢

03:01.920 --> 03:03.120
它有两个参数一个probs

03:03.120 --> 03:04.120
这个没什么好说的

03:04.120 --> 03:05.120
通过这个对象呢

03:05.120 --> 03:06.720
就可以得到所谓的属性值

03:07.520 --> 03:08.120
另外一个呢

03:08.120 --> 03:09.120
还有这个context

03:09.620 --> 03:11.820
context里边提供了一些

03:12.220 --> 03:14.820
少量的成员共你使用

03:15.020 --> 03:15.820
哪些成员呢

03:15.820 --> 03:16.820
我们看一下下面啊

03:17.520 --> 03:19.420
其实跟vue2里边是一样的啊

03:19.520 --> 03:21.420
一个是attrs

03:21.820 --> 03:22.620
那么这个玩意呢

03:22.620 --> 03:24.520
就等同于vue2的这个

03:25.420 --> 03:27.620
sort等于vue2的这个东西

03:27.720 --> 03:30.020
mx等于vue2的这个东西

03:30.520 --> 03:32.220
所以说呢这些东西完全就够用了

03:32.320 --> 03:33.720
就是咱们setup函数

03:34.020 --> 03:35.020
很简单

03:35.620 --> 03:36.720
好然后去看下面

03:37.520 --> 03:38.920
因为在setup函数里边呢

03:38.920 --> 03:41.520
我们可能会用到一些生命周期的

03:41.920 --> 03:43.120
一些钩子函数

03:43.720 --> 03:46.120
而我们现在不再使用以前的option api

03:46.120 --> 03:47.720
就配置式的api的方式了

03:47.920 --> 03:48.320
所以说呢

03:48.320 --> 03:50.220
它会在completion api里边呢

03:50.220 --> 03:51.820
给它提供了一些生命周期函数

03:51.820 --> 03:52.720
在共你使用

03:52.820 --> 03:54.020
下边有一张表格

03:54.720 --> 03:56.020
这个表格其实一看就看懂了

03:56.720 --> 03:57.520
来吧看一下吧

03:57.920 --> 04:00.420
vue2跟vue3的option api的对比

04:00.520 --> 04:02.820
以及呢跟vue3的completion api的对比

04:03.220 --> 04:05.520
vue2里边不是有这么一些生命周期函数吗

04:05.520 --> 04:07.220
那么就对应的vue3里边

04:07.220 --> 04:09.520
你看对应过来是不是差不多的一样的

04:10.020 --> 04:12.320
那么这里我有几个点要需要说明一下啊

04:13.120 --> 04:16.220
一个点的是vue2里边有这两个生命周期函数

04:16.320 --> 04:17.420
vue3里边也有

04:18.020 --> 04:20.020
但是如果说你使用completion api

04:20.020 --> 04:22.720
就在setup里边去写这些生命周期函数的话

04:23.320 --> 04:25.220
那么就不再需要这两个了

04:25.520 --> 04:26.220
想想为什么

04:27.520 --> 04:28.120
想想为什么

04:28.920 --> 04:32.520
这两个玩意是不是跟那个数据享用是相关的

04:32.920 --> 04:33.320
对不对

04:33.720 --> 04:34.420
before create

04:35.720 --> 04:38.320
这个生命周期函数里边的数据还没有完成响应是

04:39.220 --> 04:40.320
这个呢created

04:40.620 --> 04:42.920
这个时候数据呢已经完成了响应式了

04:42.920 --> 04:44.920
对吧这是vue2里边的这个情况

04:45.120 --> 04:47.220
那么在vue3里面completion api里边

04:47.320 --> 04:49.320
数据响应是是不是你单独去做的

04:49.620 --> 04:51.020
你导入一个函数导入rate

04:51.520 --> 04:52.720
导入那个还记得吗

04:53.420 --> 04:54.120
导入那个rate

04:54.520 --> 04:55.920
导入这个reactive

04:56.420 --> 04:58.620
对吧通过这些去完成数据响应式的

04:58.620 --> 05:00.120
它已经完全抽离数据了

05:00.320 --> 05:02.420
所以说有没有数据响应是取决力代码

05:02.520 --> 05:03.620
要不要用到这些东西

05:04.620 --> 05:07.220
因此这两个生命周期函数没有没有任何意义的

05:07.520 --> 05:09.720
那么就好比说我们以前在created里边

05:09.920 --> 05:12.420
去一步加载一些数据

05:12.520 --> 05:13.620
那么这个时候怎么写呢

05:13.620 --> 05:15.520
直接放到谁他函数里面加载就完成了

05:15.620 --> 05:17.220
直接在这里边去一步加载就完成了

05:17.220 --> 05:19.520
以后我们会以后我们做那个效果的时候呢

05:19.520 --> 05:21.220
会给大家掩饰到

05:22.220 --> 05:22.920
好就这一块

05:23.720 --> 05:24.820
然后我们继续往下看

05:25.020 --> 05:27.120
生命周期函数里边你看这些东西都一样的

05:27.120 --> 05:27.920
这东西都一样的

05:27.920 --> 05:29.520
它就变了一个函数名

05:30.920 --> 05:31.820
导入那就完事了

05:32.320 --> 05:33.320
那么这东西一样的

05:33.420 --> 05:35.120
下面这两个呢有了更改

05:35.720 --> 05:36.520
一个是呢

05:36.520 --> 05:38.920
以前的生命周期函数befall destroy

05:39.120 --> 05:40.020
和destroy的

05:40.020 --> 05:41.420
就是逐渐销毁之前

05:41.420 --> 05:42.620
逐渐销毁之后

05:42.720 --> 05:44.620
那么这两个函数的名字呢

05:44.720 --> 05:45.620
改动了啊

05:45.620 --> 05:46.220
改成了什么呢

05:46.220 --> 05:47.120
改成了这个玩意

05:47.420 --> 05:48.320
befall amount

05:49.020 --> 05:49.920
和amounted

05:50.920 --> 05:51.620
原来的意思吧

05:51.620 --> 05:52.220
这个很简单

05:52.220 --> 05:54.020
就这两个生命周期函数不存在了

05:54.920 --> 05:57.820
后边又新增了两个生命周期函数

05:57.820 --> 05:58.920
一个是render tracked

05:59.120 --> 06:00.520
一个是render trigger的

06:01.220 --> 06:02.320
那么这两个生命周期函数呢

06:02.320 --> 06:04.820
平时99%的情况里都用不到

06:05.420 --> 06:06.220
但是有的时候呢

06:06.220 --> 06:08.020
调试一些组件的时候呢

06:08.020 --> 06:09.320
可能会有点用啊

06:09.920 --> 06:11.020
说一下这两个函数吧

06:11.220 --> 06:12.720
这两个生命周期函数

06:12.720 --> 06:13.920
我这里呢有个工程

06:15.220 --> 06:15.820
在这儿啊

06:16.220 --> 06:16.920
工程打开

06:17.320 --> 06:20.820
就是一个非常干净的工程

06:22.120 --> 06:22.620
打开啊

06:24.520 --> 06:25.620
就是一个原式工程

06:25.920 --> 06:28.820
那么我们在这里边去找到这个component

06:28.820 --> 06:29.320
到这

06:30.120 --> 06:30.720
那么这里边

06:30.720 --> 06:32.720
我们可以注册两个生命周期函数

06:32.720 --> 06:34.320
可以使用component API

06:34.320 --> 06:35.220
也可以使用啊

06:35.220 --> 06:36.120
以前配置式的

06:36.120 --> 06:37.420
比方说没用配置式的啊

06:37.520 --> 06:38.320
叫做什么呢

06:38.320 --> 06:39.120
叫做

06:40.320 --> 06:41.220
叫做那个

06:42.320 --> 06:43.220
render tracked

06:45.300 --> 06:46.600
render tracked

06:48.000 --> 06:48.700
这个函数呢

06:48.700 --> 06:49.700
还有一个参数

06:51.970 --> 06:53.370
我们来输出一下这个参数

06:54.670 --> 06:55.470
好保存

06:55.570 --> 06:57.570
接下来我们来看一下右键检查

06:59.170 --> 07:00.570
你看是不是输出两个对象

07:00.770 --> 07:01.870
这个参数是一个对象

07:02.370 --> 07:03.370
那么这个函数啊

07:03.370 --> 07:05.470
首先这个生命周期函数什么时候运行了

07:06.170 --> 07:06.770
啥时候运行了

07:06.770 --> 07:07.470
它是这样子

07:08.370 --> 07:09.670
我们的模板啊

07:10.270 --> 07:11.470
这是我们的模板代码

07:11.870 --> 07:14.570
模板会不会生成一个render函数啊

07:15.570 --> 07:16.070
对不对

07:16.070 --> 07:16.770
预编译嘛

07:16.770 --> 07:17.570
模板预编译

07:17.570 --> 07:19.370
它会编译成为一个render函数

07:20.270 --> 07:21.570
那么这个render函数里面

07:21.570 --> 07:23.470
是不是会创建虚拟节点

07:23.870 --> 07:24.170
对吧

07:24.170 --> 07:25.770
会创建各种虚拟节点啊

07:25.770 --> 07:26.770
create vlo的

07:27.270 --> 07:28.570
创建各种虚拟节点

07:29.070 --> 07:29.670
那么这个虚

07:29.670 --> 07:31.170
创建虚拟节点的过程中

07:31.170 --> 07:32.570
是不是会用到一些

07:33.470 --> 07:34.770
享用式的数据

07:35.470 --> 07:37.270
比如说这里cult

07:37.470 --> 07:40.070
那么这里是不是会用到context

07:40.270 --> 07:40.770
cult

07:41.070 --> 07:41.370
对不对

07:41.370 --> 07:42.870
会用到这些享用式数据

07:43.270 --> 07:44.370
那么就表示说

07:44.370 --> 07:46.570
我在渲染模板的时候

07:46.970 --> 07:48.870
在生成这个虚拟节点的时候

07:49.170 --> 07:50.870
是不是会依赖这些数据啊

07:50.870 --> 07:52.170
这叫收集依赖

07:53.870 --> 07:54.570
是不是讲过了

07:55.270 --> 07:56.970
它会一个收集依赖的过程

07:57.370 --> 07:58.670
那么当有一天

07:58.670 --> 08:00.470
这些享用式数据变化的时候

08:00.570 --> 08:02.070
它就会重新运行

08:02.370 --> 08:03.470
这个Render函数

08:04.070 --> 08:05.770
这是个收集依赖的过程

08:06.570 --> 08:08.470
那么这个函数什么时候触犯了

08:08.770 --> 08:10.670
它只要收集到了一个依赖

08:10.670 --> 08:11.870
它就会触犯一次

08:12.270 --> 08:13.370
然后比方说你看这里

08:13.770 --> 08:15.370
我们在渲染模板的过程中

08:15.370 --> 08:16.370
它收集到哪些依赖了

08:16.370 --> 08:17.470
收集到这个message

08:17.670 --> 08:18.070
对吧

08:18.070 --> 08:18.670
收集到什么

08:18.670 --> 08:19.670
还收集到这个cult

08:20.170 --> 08:21.270
是收集到两个依赖

08:21.270 --> 08:22.870
因此它触犯了两次

08:23.070 --> 08:23.970
每一次呢

08:23.970 --> 08:25.470
你看就输出一个结果

08:26.270 --> 08:27.170
那么到底

08:27.570 --> 08:29.570
我每一次运行这个函数的时候

08:30.070 --> 08:31.870
它到底收集到哪个依赖

08:31.870 --> 08:34.070
我们可以通过这个事件参数e拿到

08:34.070 --> 08:35.570
你看这个事件参数e里面

08:35.570 --> 08:37.170
这个evax不用管

08:37.370 --> 08:39.170
我们看一下这个talkit

08:40.170 --> 08:41.170
它收集到什么依赖呢

08:41.170 --> 08:42.770
我们这里会用到message对吧

08:42.770 --> 08:43.870
那么它收集到这个对象

08:43.870 --> 08:45.170
就是我的属性对象

08:45.370 --> 08:46.570
属性对象里边有个属性

08:46.570 --> 08:47.370
就message

08:47.670 --> 08:47.970
对吧

08:47.970 --> 08:48.970
整个属性对象

08:49.470 --> 08:50.870
属性对象里边哪个属性呢

08:50.870 --> 08:52.070
message这个属性

08:52.570 --> 08:53.870
怎么是收集到它依赖呢

08:53.870 --> 08:54.370
get

08:54.470 --> 08:56.070
就是获取这个属性

08:56.270 --> 08:58.470
导致了我渲染模板的时候

08:58.570 --> 08:59.970
收集到了它的依赖

09:00.670 --> 09:01.370
懂这个意思吗

09:01.370 --> 09:02.570
然后再看下边的这个

09:03.070 --> 09:03.770
下边这个呢

09:03.770 --> 09:05.170
我们talkit是一个对象

09:05.570 --> 09:06.870
这个talkit里面相当于是什么

09:06.870 --> 09:07.770
相当于这个data

09:08.470 --> 09:08.870
对不对

09:08.870 --> 09:09.570
相当于它

09:09.970 --> 09:10.170
好

09:10.170 --> 09:10.770
然后呢

09:10.770 --> 09:12.770
我们这里属性是什么cult

09:13.070 --> 09:13.270
对吧

09:13.270 --> 09:14.770
收集到了它这个属性的依赖

09:15.570 --> 09:16.670
通过get的方式

09:16.870 --> 09:18.170
读取属性的方式

09:18.470 --> 09:19.870
获得了这个属性的依赖

09:20.170 --> 09:20.370
对吧

09:20.370 --> 09:21.970
这就是RenderTrack在函数

09:22.370 --> 09:24.070
那么这个东西有的时候调试的时候

09:24.070 --> 09:24.870
可能有点用

09:25.470 --> 09:26.070
我调试的时候

09:26.070 --> 09:27.570
我看一下这个模板里边有哪些东西

09:27.570 --> 09:28.770
我也一带收集到了

09:28.770 --> 09:30.470
那么这个时候可以通过它来调试

09:30.670 --> 09:31.970
平时呢一般没啥用

09:32.570 --> 09:37.470
还有另外一个函数叫做叫做RenderTrigger的

09:37.470 --> 09:38.170
发现了

09:40.040 --> 09:40.840
我说这一下啊

09:41.440 --> 09:42.140
这个函数

09:42.340 --> 09:42.940
那么同样的

09:42.940 --> 09:44.340
它也有一个实验参数1

09:44.340 --> 09:45.240
我们可以看一下

09:46.040 --> 09:47.740
RenderTrigger实验参数1

09:48.540 --> 09:48.840
好

09:50.440 --> 09:50.840
刷新

09:51.640 --> 09:53.140
目前是没有输出对吧

09:53.140 --> 09:54.940
那么这个函数是什么时候运行的

09:54.940 --> 09:55.940
这个函数是

09:56.640 --> 09:59.340
当某一个依赖被更改了之后

09:59.440 --> 10:02.140
导致了我们的页面重新渲染

10:02.340 --> 10:05.140
导致我们的主件重新渲染的时候

10:05.740 --> 10:07.140
那么它就会触发这个函数

10:07.540 --> 10:09.140
比方说这里一个Cult对吧

10:09.140 --> 10:10.240
我点一下Cult++

10:12.340 --> 10:12.840
点一下

10:13.340 --> 10:14.540
你看是不是触发这个函数

10:14.540 --> 10:15.940
叫RenderTrigger

10:17.140 --> 10:18.540
它触发了几次一次

10:18.640 --> 10:19.440
因为目前呢

10:19.440 --> 10:20.440
我们修改了几个依赖

10:20.440 --> 10:21.640
修改了一个依赖

10:22.240 --> 10:23.040
哪个依赖呢

10:23.040 --> 10:23.940
Cult这个依赖

10:24.440 --> 10:25.840
新的值是1

10:26.040 --> 10:27.640
旧的值是0

10:29.640 --> 10:32.140
目标对象就是这个对象

10:32.740 --> 10:33.940
目标对象就是这个对象

10:34.140 --> 10:35.840
它里边一个Cult1对吧

10:36.840 --> 10:39.040
方式是set设置属性

10:39.640 --> 10:41.740
导致它的模板重新渲染

10:42.240 --> 10:43.340
也就是说我们有的时候

10:43.340 --> 10:45.040
如果说一个主件比较复杂

10:45.240 --> 10:46.840
它某一天出了一些问题

10:46.940 --> 10:49.240
我也不知道是哪一个数据变化

10:49.240 --> 10:50.040
导致它出了问题

10:50.040 --> 10:51.040
我们就可以通过它

10:51.640 --> 10:53.040
通过它来进行调试一下

10:53.040 --> 10:54.640
把这个参数1输出

10:54.940 --> 10:55.640
输出过后

10:55.640 --> 10:56.440
我们就可以调试

10:56.440 --> 10:56.940
调试知道

10:56.940 --> 10:58.740
到底是哪个属性变化

10:58.840 --> 11:00.640
导致了模板重新渲染

11:01.140 --> 11:02.540
平时用处不到

11:03.440 --> 11:05.640
那么这里为什么它又输出了这两次呢

11:05.640 --> 11:06.840
因为模板重新渲染

11:06.840 --> 11:09.140
重新渲染是不是要重新收集一代

11:09.340 --> 11:10.540
它又触发了这个

11:11.240 --> 11:12.240
这就是这两个函数

11:12.240 --> 11:13.140
给大家说一下

11:14.640 --> 11:16.940
这是生命周期勾指函数

11:18.040 --> 11:20.240
康复了一些API

11:20.240 --> 11:21.740
平时我们用的也就是这些的

11:22.440 --> 11:24.440
当然还有一些小的API

11:25.540 --> 11:26.340
后边再说吧

11:26.340 --> 11:27.440
后边再给大家补充

11:27.540 --> 11:28.340
那么目前的

11:28.640 --> 11:30.540
举下大部分情况下我用到这些就够了

11:30.640 --> 11:32.940
就是一些生命周期勾指函数加上一个setup

11:33.040 --> 11:34.440
这就是completion API

11:35.240 --> 11:35.540
好

11:35.540 --> 11:37.440
那么最后我们看一下这个面试体的答案

11:38.240 --> 11:42.040
completion API相比于option API有哪些优势呢

11:42.440 --> 11:43.840
一旦回答的时候呢

11:44.640 --> 11:47.040
只要能够从这两方面回答都没问题

11:47.840 --> 11:48.640
一个是

11:49.140 --> 11:51.540
之前在入门阶段给大家讲过的

11:51.640 --> 11:52.840
也让大家体会过的

11:53.440 --> 11:57.640
就是我们可以有更好的逻辑附用和代码组织

11:57.740 --> 11:58.940
代码组织不用说了

11:59.140 --> 12:00.840
把很多代码的聚合在一起的

12:00.940 --> 12:03.240
共同相似的代码聚合在一起的

12:03.440 --> 12:05.540
它的有哪些享用数据

12:05.640 --> 12:08.340
有哪些生命周期函数

12:08.440 --> 12:09.440
有哪些

12:11.440 --> 12:13.540
观察数据变化过后要出做的事情

12:14.040 --> 12:15.040
都把它放到一起了

12:15.540 --> 12:17.040
有利于代码的组织

12:17.140 --> 12:18.640
那么逻辑附用就是

12:19.140 --> 12:20.440
我们的力度更细了

12:21.040 --> 12:22.940
我们以前控制组建的力度

12:23.340 --> 12:24.140
就这个力度

12:26.700 --> 12:29.100
是不是最小力度就是组建级别

12:29.400 --> 12:30.300
没发展小了

12:30.800 --> 12:32.300
但是有的conversation API过后

12:32.400 --> 12:33.700
我们的力度是不是更细了

12:34.000 --> 12:36.400
它可以精准到组建里边的某一些

12:36.600 --> 12:37.600
功能逻辑

12:37.800 --> 12:40.200
那么这些功能逻辑有可能不同的组建之间

12:40.300 --> 12:41.800
他们有相同的功能逻辑

12:42.000 --> 12:43.000
我们就可以附用

12:44.300 --> 12:45.600
那么以后我们做效果的时候

12:46.000 --> 12:47.400
可以给大家体会到了

12:48.500 --> 12:50.000
那么从这是一个方面

12:50.100 --> 12:52.900
另一个方面是更好的类型推导

12:53.900 --> 12:55.900
这个东西跟TypeScript有关系

12:56.200 --> 12:57.800
因为我们知道这个TypeScript

12:57.900 --> 12:58.600
有东西没学

12:58.700 --> 12:59.300
有东西学了

12:59.400 --> 13:00.700
没关系听一听就行了

13:01.000 --> 13:02.000
就是TypeScript

13:02.100 --> 13:03.500
它要完成类型推导

13:03.900 --> 13:05.900
它就必须要知道

13:08.100 --> 13:10.000
就是它的类型要能够预测

13:10.500 --> 13:11.800
像过去5u2

13:11.900 --> 13:14.700
为什么很难跟TypeScript结合呢

13:15.000 --> 13:17.900
是因为5u2里边有很多神奇的东西

13:18.300 --> 13:19.700
比方说这个Z10的指向

13:19.800 --> 13:20.600
莫名其妙了

13:20.700 --> 13:23.900
明明是在这个Message里边

13:24.000 --> 13:26.300
在这里Z10应该指向这个对象

13:26.600 --> 13:27.800
结果它指向谁呢

13:28.000 --> 13:30.000
指向的是那个组建实力

13:30.100 --> 13:30.900
就很奇怪

13:31.000 --> 13:32.700
它奇奇怪怪的Z10指向

13:33.400 --> 13:36.700
导致了很难进行类型推导

13:37.500 --> 13:38.800
比方说这就是一个普通的对象

13:38.900 --> 13:40.000
这个普通的对象里边

13:40.100 --> 13:40.700
你看啊

13:40.800 --> 13:42.800
我如果说注册一个生命追求函数

13:43.100 --> 13:44.000
汪底的

13:44.700 --> 13:45.800
注册生命追求函数

13:46.000 --> 13:48.200
TypeScript并不知道这个函数有哪些参数

13:48.700 --> 13:50.200
也不知道这个函数应该反悔什么

13:50.500 --> 13:51.500
也不知道这个对象里边

13:51.600 --> 13:52.700
是不是应该有这个函数

13:52.800 --> 13:53.700
它很难推到的

13:54.000 --> 13:55.200
这个东西你学了TypeScript

13:55.300 --> 13:56.100
你自然明白了

13:56.700 --> 14:00.100
而我们在新的Completion API里边

14:00.300 --> 14:02.000
它每一个生命追求函数

14:02.700 --> 14:05.000
都是一个突破通设函数

14:05.300 --> 14:07.200
它又传入了参数有反悔的结果

14:07.900 --> 14:09.500
那么像这些函数呢

14:10.400 --> 14:13.300
它就更加利于TypeScript的推导

14:14.300 --> 14:15.500
你从这两个方面回答

14:15.500 --> 14:16.400
就没什么问题了

14:17.200 --> 14:19.000
这是关于这个理论性的东西

14:19.600 --> 14:20.700
接下来搞定了

14:20.800 --> 14:21.500
这东西关掉

14:22.400 --> 14:25.400
我们再来做一个Completion API的练习

14:25.600 --> 14:28.000
其实我们平时用Completion API的时候

14:28.100 --> 14:29.600
更多的时候用的是它

14:29.700 --> 14:30.300
它的什么

14:30.400 --> 14:32.500
它的那个想用式API

14:32.600 --> 14:32.800
对吧

14:32.800 --> 14:33.500
用的最多的

14:33.900 --> 14:35.400
只是我们通过一个Type函数

14:35.400 --> 14:37.000
把它放到里边去

14:37.400 --> 14:38.100
仅此而已

14:38.600 --> 14:39.100
来吧

14:39.100 --> 14:39.900
我们来做一次

14:40.500 --> 14:42.800
这些课倒是用不到什么生命追求函数

14:42.800 --> 14:44.700
我们主要是通过这些课的练习

14:44.900 --> 14:48.000
让大家更加熟悉这个Completion API

14:48.700 --> 14:49.200
好来吧

14:49.200 --> 14:50.500
我们这里新建一个工程

14:52.470 --> 14:54.070
npm init read

14:55.570 --> 14:57.570
当然你用那个vue click也可以

14:59.170 --> 15:01.370
工程名字就建立一个叫demo吧

15:03.870 --> 15:04.270
好了

15:06.170 --> 15:07.370
然后进入这个demo

15:08.970 --> 15:09.770
安装一下一带

15:13.830 --> 15:15.930
把这些乱起八糟的删了

15:17.230 --> 15:18.030
这个玩意干删了

15:18.530 --> 15:19.030
删了

15:19.530 --> 15:20.430
删了用不到

15:21.430 --> 15:22.430
这个fc是干删了

15:23.230 --> 15:24.230
这个玩意干删了

15:26.030 --> 15:27.230
好了就放这吧

15:28.030 --> 15:29.830
css干删了

15:30.430 --> 15:30.930
没什么用

15:32.430 --> 15:32.830
删了

15:33.630 --> 15:34.030
好了

15:34.430 --> 15:36.630
那么接着运行出来npm装定

15:38.330 --> 15:39.230
怎么这么多的窗口

15:40.830 --> 15:41.530
这是啥

15:43.760 --> 15:44.360
这个关掉

15:46.260 --> 15:46.960
好打开

15:48.360 --> 15:49.360
好目前这个样子啊

15:49.360 --> 15:50.460
图片显示不出来

15:50.460 --> 15:50.960
没关系

15:51.960 --> 15:53.960
我们的目标呢是要完成这个样子

15:54.860 --> 15:56.160
那么这里边我们慢慢做

15:56.160 --> 15:57.260
有一些东西呢

15:57.860 --> 15:59.960
可能还会大家可能会接触到一些新的东西

16:00.560 --> 16:01.460
1.2来啊

16:02.360 --> 16:04.060
首先呢这里有一个数据的问题

16:04.060 --> 16:05.560
就是我数据从哪里来

16:06.260 --> 16:08.160
这个数据呢一般从服务器去获取

16:08.160 --> 16:08.560
对吧

16:08.560 --> 16:10.060
那么这里呢我们可以模拟一下

16:10.460 --> 16:11.960
我们在app组建里边呢

16:12.160 --> 16:14.460
我们去从服务器获取数据

16:14.760 --> 16:16.260
那么从服务器怎么来获取呢

16:16.260 --> 16:17.560
我们比方说我们这导入

16:18.260 --> 16:19.260
哎不不用导入啊

16:19.460 --> 16:21.060
直接写个setup函数

16:22.560 --> 16:23.560
那么在这个函数里边

16:23.560 --> 16:24.860
我们从服务器获取数据

16:24.860 --> 16:26.260
也就是一步获取数据

16:26.460 --> 16:27.860
以前的我们是写到哪的

16:27.860 --> 16:28.860
是不是写到creted

16:28.860 --> 16:29.760
对吧或者是

16:30.160 --> 16:31.160
mongy的里边

16:31.260 --> 16:31.760
对不对

16:32.560 --> 16:33.460
啊是不是写到这的

16:33.560 --> 16:34.160
那么现在呢

16:34.160 --> 16:35.960
我们直接可以写到这个setup函数

16:35.960 --> 16:37.160
你直接写到setup函数呢

16:37.160 --> 16:39.760
就类似于以前写到creted里边

16:40.260 --> 16:41.060
懂这个意思吗

16:41.160 --> 16:42.660
那么这里呢我们可以用fetch

16:43.260 --> 16:45.660
哎从某一个地方去获取这个数据啊

16:45.660 --> 16:47.060
比方说我们从哪里获取呢

16:47.060 --> 16:47.960
从API

16:48.260 --> 16:48.960
呃

16:49.660 --> 16:51.260
然后GDP点接上

16:51.460 --> 16:52.260
从这里获取

16:52.960 --> 16:54.660
当然现在呢我们没有服务器啊

16:54.660 --> 16:56.360
当然都拿不到任何东西啊

16:56.360 --> 16:57.660
我们先把写出来再说

16:58.060 --> 16:59.660
那么只如果说我们从这里获取的话

16:59.660 --> 17:00.460
是不是可以拿到假设

17:00.460 --> 17:01.560
我们可以拿到数据对吧

17:01.560 --> 17:02.960
假设服务器已经存在了

17:03.260 --> 17:05.260
因为你们以后在公司里面开发的时候

17:05.360 --> 17:06.960
当你开发这个客户端的时候

17:06.960 --> 17:08.160
可能服务器都还没有写

17:08.460 --> 17:10.160
那么这个时候你得想些想些办法

17:10.160 --> 17:10.960
来模拟数据

17:10.960 --> 17:12.060
我们以后来模拟一个

17:12.460 --> 17:14.660
好那么这里从这里去获取数据对吧

17:14.660 --> 17:16.160
那么这是一个一步函数

17:16.260 --> 17:17.060
那怎么办呢

17:17.260 --> 17:18.260
按照以前的话

17:18.260 --> 17:19.860
如果说写虧地的函数的话

17:19.860 --> 17:20.760
我们以前咋写的

17:21.360 --> 17:23.860
说在这里加上一个什么而sync对不对

17:23.960 --> 17:25.060
那么现在这个setup函数

17:25.060 --> 17:26.460
能够加上这个而sync吗

17:27.460 --> 17:28.160
你不要讲

17:28.860 --> 17:30.160
尽管他可以加

17:30.360 --> 17:31.360
但是你不要讲

17:32.060 --> 17:33.460
你加这个而sync之后呢

17:33.460 --> 17:35.260
这个setup函数返回了啥呀

17:35.360 --> 17:37.160
所以返回了一定是promise

17:38.960 --> 17:41.460
哎返回promise又是什么情况呢

17:41.760 --> 17:44.560
那是咱们之前给大家说过一个组件啊

17:44.560 --> 17:45.960
叫做setspence组件

17:46.560 --> 17:49.360
这个组件目前还没有标准还没有定下来

17:49.860 --> 17:51.060
等他定下来之后了

17:51.060 --> 17:52.660
我再说一下这个setup函数

17:52.660 --> 17:53.860
如何把它写成一步的

17:54.160 --> 17:56.360
那么目前大家不要这样做啊

17:56.560 --> 17:58.260
这样做的话返回的是一个promise

17:58.260 --> 18:00.460
保证了这个渲染的时候要出问题的

18:00.660 --> 18:01.760
等他以后

18:02.460 --> 18:04.460
标准定下来之后给他补充

18:04.960 --> 18:06.560
好这里我们点一下

18:06.660 --> 18:09.060
那么现在这个setup函数不能是一步的

18:09.660 --> 18:10.460
那怎么办呢

18:11.260 --> 18:14.160
哎我们这里呢就可以用这种方式变方形

18:14.760 --> 18:16.960
你在这里边写一个一步还是不完了吗

18:17.260 --> 18:19.360
不要说fetch tdp

18:20.360 --> 18:20.960
erthink

18:21.560 --> 18:22.760
写个一步还不完了吗

18:23.460 --> 18:25.060
然后呢这里怎么弄呢

18:25.060 --> 18:27.360
是不是费得到这个数据对吧

18:27.460 --> 18:28.660
哎然后我们把写完啊

18:28.660 --> 18:29.060
z

18:30.360 --> 18:32.460
解析成接胜格式啊

18:32.460 --> 18:33.660
然后await等待

18:33.660 --> 18:34.560
返回的结果呢

18:34.560 --> 18:35.960
把返回的结果保存到哪呢

18:35.960 --> 18:37.360
保存到一个响应数

18:37.560 --> 18:38.860
响应式数据里边

18:38.960 --> 18:40.160
不要那么再导致一个啊

18:40.560 --> 18:41.060
ref

18:45.940 --> 18:46.340
ref

18:47.140 --> 18:49.340
好我们这里首先建议一个响应式数据

18:49.440 --> 18:50.340
比方说gdp

18:51.140 --> 18:51.540
ref

18:52.240 --> 18:53.440
默认是一个空数组

18:53.740 --> 18:55.640
因为我们这里有有很多国家的

18:55.640 --> 18:58.640
每个国家有不同的gdp数值

18:58.940 --> 19:00.540
那么这里我们先用一个空数组

19:00.740 --> 19:02.340
然后从服务器去获取这个数据

19:02.340 --> 19:03.940
获取完了过后来给他复制对吧

19:03.940 --> 19:05.940
gdp 表白6不要忘记表白6啊

19:06.940 --> 19:07.540
没问题吧

19:07.840 --> 19:09.540
啊当然那你也可以按照我们之前的那种

19:09.540 --> 19:11.740
那种做法啊每个写上rafe也可以

19:13.140 --> 19:13.540
好

19:13.940 --> 19:14.540
写完了之后呢

19:14.540 --> 19:15.940
我们最后把这个gdp

19:16.640 --> 19:17.140
返回

19:18.440 --> 19:19.440
这返回就完事了

19:20.140 --> 19:21.140
啊不要让我们在这里啊

19:21.140 --> 19:23.640
用个H1元数啊输出一下gdp

19:25.240 --> 19:25.740
好

19:26.740 --> 19:27.840
目前的情况呢

19:28.440 --> 19:30.740
对等一下这是个动态数据

19:31.840 --> 19:34.440
保存啊目前是个空数组对不对

19:34.740 --> 19:36.840
啊不过了目前得到这个数据啊

19:36.840 --> 19:39.940
因为404找不到这个服务器地址

19:40.240 --> 19:41.140
我们以后再说

19:42.640 --> 19:44.340
好这这这这这种写法

19:44.540 --> 19:46.040
那么啊还没还没调用对吧

19:46.040 --> 19:48.240
vdp 调用一下

19:48.840 --> 19:50.940
对因为这个setup函数只运行一次嘛

19:50.940 --> 19:51.940
运行就完事了

19:52.440 --> 19:53.140
非常简单

19:54.040 --> 19:55.140
好那么现在呢

19:55.140 --> 19:57.340
这里是又在setup函数里面直接写

19:57.340 --> 19:59.240
也可以用什么呢也可以用amount

19:59.240 --> 20:01.740
就等他界面加载完成之后

20:02.140 --> 20:03.440
界面已经出来之后呢

20:03.440 --> 20:05.540
我再去做这个事也可以

20:05.940 --> 20:07.440
啊那么怎么写呢amount的

20:07.440 --> 20:08.740
传进就不完了

20:09.440 --> 20:11.640
对不对啊也可以写个立名函数吧

20:11.640 --> 20:12.140
写到这

20:12.840 --> 20:14.040
对吧也可以写到这

20:14.140 --> 20:14.840
I think

20:18.060 --> 20:18.860
都是一样的

20:19.560 --> 20:22.560
啊你们自己去定啊到底放amount里面

20:22.560 --> 20:24.060
还是像以前的样子啊

20:24.060 --> 20:25.460
在crate里面就完成

20:25.460 --> 20:27.560
那么这里呢我们再用这种写法

20:31.390 --> 20:33.090
好这是获取数据

20:33.090 --> 20:34.990
那么现在我们的货数据没有对不对

20:34.990 --> 20:36.790
那么现在我们想办法把数据搞定

20:36.890 --> 20:37.890
那么怎么搞定呢

20:39.490 --> 20:41.390
我们可以约现在的服务器还没有吧

20:41.390 --> 20:42.090
比方在公司里面

20:42.090 --> 20:43.790
连开发的时候服务器都还没有写完

20:43.790 --> 20:45.290
那么这个时候会涉及到一个

20:46.090 --> 20:47.590
前后端连调的问题

20:47.590 --> 20:48.390
那么连调的时候

20:48.490 --> 20:49.690
你可以用什么mock.js

20:49.890 --> 20:51.190
对吧来模拟数据

20:51.390 --> 20:54.290
也可以呢用一种非常简单的方式来模拟数据

20:54.390 --> 20:55.390
我是来找模拟的呢

20:55.390 --> 20:56.690
我觉得这里就写了一个接生

20:56.890 --> 20:57.490
接生文件

20:57.790 --> 20:59.190
就写了这么一个接生文件

20:59.490 --> 21:00.590
然后呢用一个

21:00.690 --> 21:03.190
用我们那个vscode的leaf server查件

21:03.790 --> 21:05.490
vscode不是一个leaf server查件吗

21:05.490 --> 21:06.790
对不对啊你看啊

21:07.090 --> 21:08.290
咱们的这里央视素材里面

21:08.290 --> 21:09.290
我先随便打开一个

21:09.290 --> 21:10.890
你看这不就是个leaf server

21:11.090 --> 21:12.090
搭建出来的吗对吧

21:12.190 --> 21:13.790
这点击右键我也是leaf server

21:13.990 --> 21:15.190
那么通过那个leaf server呢

21:15.190 --> 21:17.490
他是把整个工程当成一个静态目录

21:17.490 --> 21:19.190
那么这里呢我们就可以直接找到

21:19.590 --> 21:20.790
客间里边的什么

21:23.190 --> 21:24.790
gdp调接生

21:25.690 --> 21:26.690
就说可以发文道了

21:26.890 --> 21:27.890
模拟嘛对吧

21:27.890 --> 21:30.790
当然在线上环境在生产环境里面肯定是不行的

21:30.890 --> 21:33.790
但是生产环境到了生产环境服务器是不是已经有了

21:33.990 --> 21:35.290
对不对服务器肯定是有了

21:35.290 --> 21:38.090
所以说你这里代码的照样是能够正常运行

21:38.190 --> 21:39.290
我们现在只是模拟

21:39.690 --> 21:41.790
好那么现在我们需要需要做的一件事呢

21:41.790 --> 21:42.790
就是写个代理

21:43.690 --> 21:45.690
一个开发服务器的代理

21:45.690 --> 21:47.190
当他请求这样的地址的时候呢

21:47.190 --> 21:49.090
我拿去请求这个地址

21:49.490 --> 21:50.990
就这么简单好来吧

21:51.390 --> 21:53.690
点击右键新建一个文件啊

21:53.690 --> 21:55.590
之前说过建立个什么vite

21:55.690 --> 21:57.090
叫config叫js

21:57.990 --> 21:59.690
好那么这里边我们去写上个代理

21:59.690 --> 22:02.090
其实你可以参考一下这个vite的官方文道

22:04.590 --> 22:06.290
呃这好像给他看过了啊

22:06.790 --> 22:07.790
vite

22:09.190 --> 22:09.990
是这个vite

22:10.990 --> 22:11.590
啊下面

22:12.390 --> 22:13.590
呃在哪呢

22:13.690 --> 22:14.390
deaf server

22:14.790 --> 22:15.690
复制一下吧

22:17.820 --> 22:19.720
其实跟vipark配置是一样的啊

22:19.720 --> 22:21.420
其实他内部呢都是使用那个插线

22:21.420 --> 22:22.920
叫adbvproxymadeware

22:23.920 --> 22:24.620
好来吧

22:24.620 --> 22:27.320
当他请求以API开头的时候呢

22:27.320 --> 22:28.020
我们把它

22:28.320 --> 22:29.620
转跳到哪呢

22:30.020 --> 22:31.420
转跳到

22:32.220 --> 22:32.920
这个位置吧

22:33.920 --> 22:35.120
把他转跳到这个位置

22:36.520 --> 22:36.920
对吧

22:37.620 --> 22:39.020
好然后呢我们这里

22:39.420 --> 22:41.420
rewrite啊把这个pass重写一下

22:41.420 --> 22:42.820
把这个API去掉

22:43.320 --> 22:45.420
把API去掉替换成一个控制武划

22:45.620 --> 22:46.220
那么这样子呢

22:46.220 --> 22:48.020
我们当我们去请求这个地址的时候

22:48.320 --> 22:48.920
你看啊

22:49.020 --> 22:51.020
当我们去请求这个API gdp

22:51.020 --> 22:52.020
就要接受的时候

22:52.020 --> 22:53.220
他实际上是请求了他

22:53.820 --> 22:54.820
请求了这个地址

22:55.820 --> 22:56.620
这个地址

22:56.920 --> 22:57.620
然后了

23:01.850 --> 23:03.450
他实际上因为这里有中文嘛

23:03.450 --> 23:04.950
他说他进了编码

23:05.150 --> 23:07.550
呃请求这个地址后边的

23:07.750 --> 23:08.650
API

23:09.050 --> 23:09.650
gdp

23:09.650 --> 23:10.350
就要接受

23:11.150 --> 23:12.950
但是呢我们这里把API这个路径了

23:12.950 --> 23:13.850
给他重写了

23:14.050 --> 23:15.350
给他替换为一个控制武划

23:15.350 --> 23:16.850
就相当于说请求这个路径了

23:17.250 --> 23:17.850
懂了意思吗

23:17.850 --> 23:19.050
那么这样子呢你看一下

23:19.450 --> 23:20.650
最后不就是这个玩意吗

23:21.050 --> 23:22.050
啊就这个玩意

23:22.150 --> 23:23.050
是不是能请求到了

23:23.550 --> 23:23.850
好

23:23.850 --> 23:25.650
咱们来试一下

23:26.050 --> 23:27.150
保存啊

23:27.150 --> 23:28.250
这配置改了过后呢

23:28.250 --> 23:29.350
我们重新运行一下

23:29.650 --> 23:30.750
npm装定

23:33.690 --> 23:35.090
啊现在变成3d你要了

23:35.490 --> 23:35.990
来吧

23:36.390 --> 23:36.690
你看

23:36.690 --> 23:38.490
就得到拿到拿到这个结果了

23:39.790 --> 23:40.390
啊你看

23:40.790 --> 23:41.890
我们看一下类似work

23:41.990 --> 23:42.490
刷新

23:43.790 --> 23:44.790
就可以拿到结果了

23:44.990 --> 23:45.390
对吧

23:45.390 --> 23:47.290
那么将来在生产环境里边呢

23:47.290 --> 23:48.490
这些东西就失销了

23:48.490 --> 23:49.190
失销了过后呢

23:49.190 --> 23:50.390
就得到正常的数据了

23:50.790 --> 23:52.090
好这是拿到数据

23:53.090 --> 23:53.790
没问题吧

23:54.190 --> 23:55.290
好拿到数据过后呢

23:55.290 --> 23:57.290
我们接下来要考虑的是这里边

23:58.790 --> 23:59.290
呃

23:59.790 --> 24:00.790
这个页面啊

24:01.090 --> 24:02.290
这个页面里边呢

24:02.290 --> 24:04.290
首先我们先不考虑这个区域

24:04.590 --> 24:05.690
先不考虑这个区域

24:06.090 --> 24:08.290
先把这个页面的整体样式给他做了

24:08.490 --> 24:09.790
那么整体样式在哪呢

24:09.790 --> 24:10.290
在这

24:10.790 --> 24:12.490
啊这个样式素材这里

24:13.190 --> 24:13.890
呀就在这

24:13.990 --> 24:14.890
好我们把这个

24:15.290 --> 24:16.390
武办拿过来

24:16.990 --> 24:17.690
复制一下

24:18.390 --> 24:19.890
粘贴到这里

24:21.690 --> 24:22.390
好然后呢

24:22.390 --> 24:23.190
这边样式呢

24:23.190 --> 24:23.990
给他张开过来

24:25.690 --> 24:26.190
复制

24:27.690 --> 24:28.690
cc scout

24:29.390 --> 24:30.090
他接过来

24:31.290 --> 24:32.190
啊其实没啥

24:32.490 --> 24:33.790
要你给你看下面呢

24:33.790 --> 24:35.390
我们打开看一下

24:35.890 --> 24:38.790
下面的就是你有两个有有多个文门框

24:38.990 --> 24:40.590
那么到底有几个文门框呢

24:41.090 --> 24:42.790
是不是有多少个gdp数据

24:42.790 --> 24:43.890
我就要生成多少个

24:44.090 --> 24:45.290
那么也就说这个df

24:45.290 --> 24:46.890
那是不是要循环生成出来的

24:47.190 --> 24:48.190
那怎么来循环生成

24:48.190 --> 24:49.590
我们可以用v4

24:50.290 --> 24:51.390
啊循环

24:51.990 --> 24:53.090
印什么呢

24:53.290 --> 24:53.890
那个

24:55.690 --> 24:56.490
印这个

24:59.060 --> 24:59.860
啊gdp

25:02.000 --> 25:03.700
好每循环一次呢

25:03.700 --> 25:05.000
生成这里生成啥

25:05.400 --> 25:07.200
这里不是就生成这个item

25:07.200 --> 25:07.800
item是啊

25:07.800 --> 25:08.400
就这个

25:09.600 --> 25:10.200
conquit

25:10.200 --> 25:11.500
对吧数据里面的conquit

25:11.700 --> 25:14.100
好我们得到item.conquit

25:14.300 --> 25:15.700
不要忘记了给他一个key

25:17.000 --> 25:17.700
key值

25:17.800 --> 25:19.600
key值的话我们这里没有id

25:19.600 --> 25:21.600
没有id的话就用这个国家名称嘛

25:21.600 --> 25:22.800
因为国家名称呢

25:22.800 --> 25:24.500
在排行里边也不可能重复

25:24.500 --> 25:24.900
对吧

25:24.900 --> 25:26.500
所以我们给他一个国家名称

25:27.000 --> 25:27.800
就是conquit

25:28.900 --> 25:31.200
好然后呢这个这个地方是要有个vmode

25:31.200 --> 25:33.000
双向绑定绑定谁呢

25:33.000 --> 25:35.800
绑定这个item.value

25:36.700 --> 25:38.100
对对绑定这个

25:38.800 --> 25:40.900
那么这样子是不是循环生成了一些文门框

25:40.900 --> 25:41.600
看一下吧

25:43.100 --> 25:44.400
哦这里是镜台一面

25:45.200 --> 25:46.300
你看是不是出来了

25:47.100 --> 25:47.700
是不是出来了

25:47.800 --> 25:50.800
那么这里可以更改每一个对象里边的这个value属性

25:51.500 --> 25:52.200
没问题吧

25:53.000 --> 25:54.300
好那么接下来就是这里的

25:54.600 --> 25:56.900
这里呢我们需要有两种方式

25:57.000 --> 25:58.800
用不同的组件

25:59.600 --> 26:01.200
来表现这个数据

26:01.800 --> 26:04.000
你看这是典型的一个场景

26:04.600 --> 26:07.100
就是completion API特别适用的场景

26:07.400 --> 26:08.900
就是我们有不同的组件

26:08.900 --> 26:09.900
这是一个组件

26:10.300 --> 26:12.100
他又说我把它做成一个组件行不行

26:12.400 --> 26:13.300
其实也可以

26:13.400 --> 26:15.000
不过呢你这样子呢代码呢

26:15.800 --> 26:18.000
呃就就是力度就不够细

26:19.000 --> 26:21.100
因为这样因为每个组件他的样式啊

26:21.100 --> 26:24.000
可能他的交互逻辑都可能不太一样啊

26:24.400 --> 26:26.300
不过这两个组件长得倒是挺相似的

26:26.400 --> 26:27.900
但是没有必要把做成一个组件

26:28.000 --> 26:30.300
我们我们现在呢有了completion API过后呢

26:30.400 --> 26:32.100
有更加细腻度的控制

26:32.100 --> 26:33.800
因此呢可以把它做成不同的组件

26:33.800 --> 26:35.100
但是它里边的功能

26:35.800 --> 26:38.000
它里边的功能是不是类似的

26:38.200 --> 26:41.000
有一些类似的功能和界面逻辑

26:41.300 --> 26:42.400
那么这个逻辑呢

26:42.400 --> 26:45.400
我们可以把通过completion API把抽离出去

26:45.700 --> 26:46.300
懂了意思吗

26:46.300 --> 26:48.700
所以说我们组件上我们设置两个组件

26:48.700 --> 26:50.100
一个呢是

26:50.300 --> 26:51.100
821

26:52.940 --> 26:53.940
一个是822

26:54.840 --> 26:56.440
啊是这么两个组件

26:56.740 --> 26:58.940
那么ipley本来这里就是第一个放821

26:58.940 --> 26:59.740
一个放822

26:59.740 --> 27:00.840
那么这里导致一下

27:01.440 --> 27:02.040
821

27:04.040 --> 27:04.840
component

27:05.240 --> 27:05.840
821

27:07.140 --> 27:08.140
然后呢一个822

27:10.440 --> 27:11.240
好来吧

27:11.840 --> 27:13.440
註册一下component

27:14.940 --> 27:15.540
821

27:18.250 --> 27:19.850
好那么这里边就很简单了

27:19.950 --> 27:21.350
821这里呢我们就使用

27:23.750 --> 27:24.750
821

27:25.950 --> 27:27.150
下面呢就使用822

27:29.370 --> 27:31.470
对吧把两个组件放到这就行了

27:31.970 --> 27:33.870
那么这两个组件肯定需要一些数据

27:33.870 --> 27:34.770
它需要什么数据呢

27:34.770 --> 27:36.470
无非就是把一个gdp数据要给它

27:36.970 --> 27:37.370
对不对

27:37.570 --> 27:38.970
我们gdp不是个数组吗

27:38.970 --> 27:39.970
把数组给它

27:40.070 --> 27:40.870
那么这里呢比较多

27:40.870 --> 27:42.970
我们这里绑定一个数据啊gdp

27:43.570 --> 27:44.270
啊gdp

27:44.270 --> 27:45.070
要绑定进去

27:45.870 --> 27:46.970
那么也就是说呢

27:46.970 --> 27:48.770
在821也好822也好

27:48.770 --> 27:50.170
里边是不是有一个属向

27:50.170 --> 27:52.170
要去接收一个gdp

27:52.370 --> 27:52.670
对吧

27:52.670 --> 27:53.770
所以我们这里写一下啊

27:54.770 --> 27:56.170
呃声明一下

27:56.170 --> 27:57.270
声明一下probs

27:58.070 --> 27:59.670
我们这里有个gdp这个数据呢

27:59.670 --> 28:00.670
需要接收一下

28:01.670 --> 28:02.270
好其他

28:02.270 --> 28:02.870
其他还有啥呢

28:02.870 --> 28:04.270
其他就是我们写界面了

28:04.270 --> 28:05.370
来帮我们写界面

28:07.540 --> 28:09.240
好这里821的界面呢

28:09.240 --> 28:10.640
我们直接复制过来啊

28:12.040 --> 28:12.840
821

28:13.940 --> 28:14.440
放这

28:15.040 --> 28:16.540
他的央视呢

28:16.640 --> 28:17.440
复制一下

28:20.620 --> 28:21.320
821

28:22.320 --> 28:23.020
sculpt

28:25.090 --> 28:26.890
老陈好822呢

28:26.890 --> 28:27.990
也跟它复制一下

28:29.790 --> 28:30.490
样式啊

28:30.490 --> 28:32.590
这些界面的结构呢

28:32.590 --> 28:33.290
都不太一样

28:35.390 --> 28:35.990
822

28:37.490 --> 28:38.990
好他的样式放过来

28:43.360 --> 28:43.960
sculpt

28:46.200 --> 28:46.700
好了

28:47.000 --> 28:48.200
那么目前的这两个组件

28:48.200 --> 28:49.300
没有任何的功能

28:49.500 --> 28:51.000
它只是提供了一个静态的

28:51.400 --> 28:52.500
样式看一下吧

28:53.700 --> 28:54.400
说出来了

28:54.600 --> 28:55.000
对吧

28:55.100 --> 28:56.000
样式出来了

28:56.500 --> 28:57.300
那么接下来呢

28:57.300 --> 28:59.200
我们要开发这两个组件的功能

29:00.200 --> 29:00.400
来吧

29:00.400 --> 29:01.700
我们来看一下这两个组件

29:01.800 --> 29:02.800
首先看一下821

29:02.800 --> 29:03.700
再看一下822

29:03.700 --> 29:04.700
把它分割一下

29:04.700 --> 29:05.900
大家看得更加清楚一点

29:07.400 --> 29:08.600
你看他有逻辑吧

29:10.300 --> 29:11.300
821里边呢

29:11.300 --> 29:13.300
他是说不断生成这个DIV

29:13.300 --> 29:13.900
对吧

29:14.700 --> 29:15.400
名字

29:16.600 --> 29:17.000
然后呢

29:17.000 --> 29:17.800
他的纸

29:18.600 --> 29:19.300
关键在这

29:19.300 --> 29:20.800
你看这里一个DIV

29:21.100 --> 29:22.500
这个DIV里边呢

29:22.600 --> 29:23.800
有个背景颜色

29:24.800 --> 29:25.800
背景颜色就是这个东西

29:25.800 --> 29:26.600
就是这个条

29:26.700 --> 29:27.200
看呗

29:27.400 --> 29:28.100
是不是这个条

29:28.500 --> 29:29.800
它的背景颜色

29:30.100 --> 29:31.300
以及它的宽度

29:31.300 --> 29:31.600
是吧

29:31.600 --> 29:33.600
在这里动态的编写

29:33.900 --> 29:35.100
因为为啥要动态的编写

29:35.100 --> 29:35.500
你看

29:37.790 --> 29:39.590
看它的宽度是不是不断变化的

29:39.990 --> 29:41.390
而每一个条的颜色

29:41.390 --> 29:42.390
是不是可能不一样

29:42.990 --> 29:43.490
对不对

29:43.690 --> 29:44.890
是不是这里有这么一个逻辑

29:45.190 --> 29:45.490
然后呢

29:45.490 --> 29:46.690
后面是一个数值

29:46.790 --> 29:48.390
也就是这一块是不是要循环生成

29:49.090 --> 29:50.190
然后再看这一块

29:51.190 --> 29:51.690
这一块呢

29:51.690 --> 29:52.490
是不是名字

29:52.490 --> 29:53.290
火加名字

29:53.390 --> 29:53.690
然后呢

29:53.690 --> 29:54.590
后面的数值

29:54.790 --> 29:56.590
接下来后面是不是拥有一个背景颜色

29:56.690 --> 29:57.590
和一个宽度

29:58.090 --> 29:58.590
对不对

30:00.700 --> 30:01.200
看到没

30:01.200 --> 30:02.900
是不是有相似的地方

30:03.700 --> 30:04.200
而且呢

30:04.200 --> 30:04.900
这两个宽度呢

30:04.900 --> 30:05.600
可能不太一样

30:05.600 --> 30:06.400
比较的美国

30:06.500 --> 30:07.300
美国左边呢

30:07.300 --> 30:09.600
是821那是400

30:09.800 --> 30:11.200
那么可能在右边又不一样

30:11.200 --> 30:11.800
你看这边

30:12.000 --> 30:12.800
最终效果里边

30:12.900 --> 30:14.100
美国的这个条

30:14.700 --> 30:15.400
它左边

30:15.400 --> 30:16.600
你看是400的宽度

30:16.700 --> 30:17.400
然后右边呢

30:17.400 --> 30:18.600
是不是宽度更多一点

30:19.000 --> 30:19.300
对吧

30:19.300 --> 30:19.700
600

30:20.500 --> 30:21.100
看到没

30:21.900 --> 30:22.800
现在我们怎么来玩

30:22.800 --> 30:23.300
这个事呢

30:23.300 --> 30:23.800
问题是

30:24.100 --> 30:24.800
怎么来玩

30:26.400 --> 30:27.300
我们可以

30:28.300 --> 30:30.600
用一点抽象思维去

30:31.000 --> 30:31.900
分析一下

30:32.900 --> 30:34.700
就是无论是这个逐渐

30:35.300 --> 30:36.600
还是这个逐渐

30:37.100 --> 30:40.100
我们只要能够给他一个同样的数据

30:40.800 --> 30:42.300
他就能够选择眷览出来

30:42.700 --> 30:43.600
什么数据呢

30:43.600 --> 30:44.500
就这么一个数据

30:44.800 --> 30:45.400
看着啊

30:46.300 --> 30:47.400
我要给他一个数组

30:49.610 --> 30:51.510
这个数组里边每一项是个对象

30:52.410 --> 30:54.210
对象里边就记录了一个国家的

30:54.310 --> 30:55.110
目前的

30:55.410 --> 30:56.510
界面情况

30:57.810 --> 30:58.310
比方说

30:58.310 --> 30:58.910
concrete

31:00.110 --> 31:00.610
美国

31:02.110 --> 31:02.710
value

31:03.710 --> 31:05.810
二十二十一点四二八

31:06.310 --> 31:07.310
那么有了这两个数据过后

31:07.310 --> 31:08.510
这个东西是不可以显示的

31:09.510 --> 31:10.910
这个玩意儿是不可以显示的

31:11.410 --> 31:11.910
对不对

31:12.210 --> 31:12.710
然后呢

31:12.710 --> 31:13.310
还有什么呢

31:13.410 --> 31:14.410
还有一个size

31:14.810 --> 31:15.510
尺寸

31:16.310 --> 31:17.410
就这个玩意儿尺寸

31:17.710 --> 31:18.710
比方尺寸400

31:19.910 --> 31:20.910
然后还有什么玩意儿呢

31:20.910 --> 31:21.810
还有一个颜色

31:22.210 --> 31:22.710
卡了

31:23.510 --> 31:24.910
比方说随便写个

31:26.410 --> 31:27.210
懂了意思吗

31:27.910 --> 31:29.510
如果说我有这么一个数据

31:29.810 --> 31:31.210
每个数据里边每一项是这种

31:31.210 --> 31:32.510
这种格式的数据

31:33.110 --> 31:34.210
拿到这个数据过后

31:34.210 --> 31:36.110
这个界面是不是特别特别简单

31:37.210 --> 31:38.410
直接出来了对吧

31:38.510 --> 31:39.610
是不是特别特别简单

31:40.810 --> 31:42.110
那么这边你再看一下

31:42.110 --> 31:44.110
这种数据是不是这边也可以

31:45.010 --> 31:45.810
也需要的

31:45.910 --> 31:47.110
这边有了这个数据过后

31:47.110 --> 31:48.910
是不是也可以把它显示出来

31:49.410 --> 31:51.410
因此这一部分是公共的逻辑

31:51.410 --> 31:52.510
它是有附用的

31:53.210 --> 31:53.610
因此呢

31:53.610 --> 31:55.210
我们这里可以可以干嘛呢

31:55.510 --> 31:58.410
我就可以写一个completion api

31:58.610 --> 31:59.710
我在src里面

31:59.710 --> 32:02.110
新建个文件家叫completion

32:03.610 --> 32:04.210
然后呢

32:04.610 --> 32:07.610
新建个文件叫做use gdp

32:08.910 --> 32:09.310
对吧

32:09.910 --> 32:10.410
js

32:10.810 --> 32:12.410
好写上这么一个js文件

32:12.610 --> 32:14.310
这个js呢导出一个函数

32:16.110 --> 32:16.710
他们写

32:18.410 --> 32:19.010
他们写

32:20.010 --> 32:21.610
use gdp

32:24.800 --> 32:25.800
这个函数干嘛呢

32:25.900 --> 32:28.400
这个函数反而回的就是一个响应式数据

32:28.600 --> 32:30.800
比方说我们这里呢有一个barce

32:31.000 --> 32:31.900
得到一个barce

32:33.800 --> 32:35.800
barce那么这里首先用个riff吧

32:37.800 --> 32:38.000
对

32:40.940 --> 32:42.240
默认的是一个空数组

32:44.250 --> 32:45.650
当然它是个响应式数据啊

32:45.650 --> 32:46.750
因此它会变化的

32:46.850 --> 32:47.650
把它导出去

32:48.550 --> 32:50.550
最终这个barce里边就是这种格式

32:51.350 --> 32:52.050
懂我意思吧

32:52.150 --> 32:55.350
那么这种这个这个函数提供给bar1

32:55.350 --> 32:56.850
是不是可以用 bar2

32:56.850 --> 32:57.850
是不是也可以用

32:58.050 --> 33:01.250
这就是在completion api里边的逻辑抽离

33:01.750 --> 33:03.550
它力度更细了

33:05.150 --> 33:05.250
好

33:05.250 --> 33:06.750
那么我们来分析一下啊

33:06.750 --> 33:08.950
这里边这个函数需不需要参数呢

33:10.550 --> 33:11.750
需要参数呢

33:12.750 --> 33:13.450
你琢磨一样

33:14.450 --> 33:15.850
我要拿到这个数据是不是

33:15.850 --> 33:18.650
是不是你要得把gdp的原始数据给我

33:19.350 --> 33:20.950
是不是得把原始数据给我

33:21.350 --> 33:21.650
对吧

33:21.650 --> 33:22.650
那么我们给他吧

33:22.950 --> 33:23.850
接受一个参数啊

33:23.850 --> 33:25.250
gdp的原始数据

33:26.450 --> 33:27.650
那么这个这个团样呢

33:27.650 --> 33:30.050
肯定是一个肯定得是一个响应式数据

33:30.250 --> 33:32.250
你可以用一个什么riff呢

33:32.350 --> 33:33.850
来表示它是一个响应式数据啊

33:33.850 --> 33:35.650
总之可以给我封装成riff给我

33:35.850 --> 33:37.150
我内部的全是riff

33:37.750 --> 33:38.850
外边的给我的时候呢

33:38.850 --> 33:39.850
我通过一个命名啊

33:39.850 --> 33:42.050
riff通过这个命名告诉你

33:42.250 --> 33:43.050
你传的时候呢

33:43.050 --> 33:43.450
注意啊

33:43.450 --> 33:44.850
你不能传一个普通数据

33:44.850 --> 33:45.950
一定是响应式的

33:46.450 --> 33:46.750
对不对

33:46.750 --> 33:47.950
你得把响应式数据给我

33:47.950 --> 33:49.050
因为它变了过后

33:49.050 --> 33:51.450
它一变是不是这里边很多东西都要跟着变

33:51.950 --> 33:52.250
对吧

33:52.250 --> 33:53.850
所以说你再给我一个响应式数据

33:54.650 --> 33:55.050
好

33:55.250 --> 33:55.750
另外呢

33:55.750 --> 33:57.250
还需不需要别的参数呢

33:59.650 --> 34:00.750
还需不需要别的参数呢

34:02.550 --> 34:03.250
那你看啊

34:03.550 --> 34:04.650
你不需要别的参数的话

34:04.650 --> 34:06.750
那么倒是个size算起来就有问题

34:07.550 --> 34:08.350
有啥问题啊

34:09.050 --> 34:10.650
你看这边不是400吗

34:10.950 --> 34:11.950
这边不是600吗

34:11.950 --> 34:13.350
凭什么他是400他是600

34:14.850 --> 34:16.550
是不是有一个最大宽度啊

34:17.150 --> 34:18.250
到时候我要变化的时候

34:18.250 --> 34:19.350
按比例来变化

34:19.350 --> 34:21.850
比方说下面中国我会写成24

34:22.550 --> 34:24.650
你看是不是他他的姪妹变得他

34:25.250 --> 34:26.250
宽度变短了

34:26.750 --> 34:27.450
没什么意思吧

34:27.450 --> 34:27.950
所以说呢

34:27.950 --> 34:28.750
我们这里呢

34:28.750 --> 34:30.650
需要告诉我一个最大宽度

34:30.650 --> 34:32.350
到时候我要把每一个地方呢

34:32.350 --> 34:33.550
按一个比例来算

34:34.150 --> 34:34.650
来吧

34:35.450 --> 34:36.850
说得到一个max

34:37.950 --> 34:38.750
max是什么

34:39.850 --> 34:40.450
size

34:40.850 --> 34:41.750
最大的宽

34:41.850 --> 34:42.750
最大的尺寸

34:42.850 --> 34:44.450
比方左边的最大尺寸是400

34:44.850 --> 34:46.450
右边的最大尺寸就600

34:46.750 --> 34:47.450
懂了意思吧

34:48.050 --> 34:49.850
啊你把这两个数据给我啊

34:49.850 --> 34:51.350
这个数据不需要想认识

34:51.650 --> 34:52.350
固定就行了

34:52.850 --> 34:54.050
你把这两个数据给我

34:54.050 --> 34:54.950
我就能算了

34:55.150 --> 34:55.650
剩下的事情

34:55.650 --> 34:56.950
我就帮你搞定一大堆

34:56.950 --> 34:58.250
那天就瞎想认识数据

34:58.250 --> 34:59.650
最后给把它返回给你

34:59.850 --> 35:00.450
就完事了

35:02.350 --> 35:02.750
好

35:03.050 --> 35:04.350
那么有了这个函数过后

35:04.350 --> 35:05.550
假设已经写完了啊

35:05.550 --> 35:07.250
那821里边是不是特别简单

35:07.350 --> 35:08.250
821里边怎么用

35:08.350 --> 35:09.250
就setup函数

35:11.970 --> 35:12.670
然后怎么用呢

35:12.870 --> 35:13.870
返回的时候

35:14.270 --> 35:15.870
我又调用那个use

35:17.070 --> 35:17.670
gdp

35:25.760 --> 35:27.060
use gdp

35:27.960 --> 35:28.460
from

35:29.960 --> 35:31.360
completion

35:31.760 --> 35:32.660
use gdp

35:34.570 --> 35:36.170
好他不是需要参数吗

35:36.270 --> 35:37.270
一个个来啊

35:37.370 --> 35:38.470
第一个参数

35:39.070 --> 35:39.870
来自于哪

35:39.970 --> 35:40.770
什么来自于

35:40.870 --> 35:42.370
就是来自于属性里边

35:42.370 --> 35:44.270
跟我们传过来的这个dp

35:44.270 --> 35:44.670
对吧

35:44.770 --> 35:45.770
那么属性怎么来用

35:45.770 --> 35:46.970
是不是这里一个props

35:47.970 --> 35:48.770
那这里怎么传

35:49.270 --> 35:49.970
props

35:50.170 --> 35:50.670
第2

35:50.970 --> 35:51.670
gdp

35:53.780 --> 35:54.680
就可以这样做

35:55.880 --> 35:56.880
那么这样子呢

35:56.880 --> 35:57.880
第二个参数是什么

35:57.980 --> 35:58.880
第二个参数

35:59.080 --> 36:00.480
对啊这里有一些问题

36:00.580 --> 36:01.080
不到底

36:01.480 --> 36:02.480
max size

36:02.580 --> 36:03.480
最大尺寸

36:03.480 --> 36:05.680
那么这里呢821的最大尺寸呢是

36:05.980 --> 36:06.680
宽度为5半

36:06.680 --> 36:07.880
因为还要考虑到这边

36:07.980 --> 36:09.080
还要考虑到这个文字

36:09.080 --> 36:10.080
占用一个宽度

36:10.080 --> 36:11.280
说到这个821的宽度呢

36:11.280 --> 36:12.880
我就给它设设成4把

36:14.480 --> 36:14.880
好

36:14.980 --> 36:15.880
那么剩下的事情

36:15.880 --> 36:17.180
交给这个函数了

36:17.480 --> 36:18.680
你给我去搞定

36:18.880 --> 36:21.280
总之呢你最后给我返回一个响应式数据

36:21.280 --> 36:22.080
就是个boss

36:22.480 --> 36:23.080
就这个玩意儿

36:23.080 --> 36:24.080
响应式数据

36:24.880 --> 36:25.080
好

36:25.080 --> 36:25.880
那么最后呢

36:25.880 --> 36:28.880
我就是循环这个响应式数据v4

36:29.480 --> 36:29.880
对不对

36:30.880 --> 36:32.680
item in boss

36:33.080 --> 36:35.080
顺便的给它绑一个key嘛

36:36.280 --> 36:37.680
那么响应式数据格式啊

36:37.680 --> 36:39.080
就还是用这个conquit

36:39.080 --> 36:40.080
作为这个key

36:40.880 --> 36:42.280
item country

36:43.080 --> 36:44.380
好那么这边一个个来

36:46.350 --> 36:48.050
这个地方写上conquit

36:48.250 --> 36:50.050
那么这个style呢

36:50.250 --> 36:50.850
绑定

36:54.360 --> 36:54.960
有对象

36:55.560 --> 36:56.160
有对象

36:58.720 --> 36:59.020
啊

36:59.020 --> 37:00.620
这这个背景颜色呢

37:00.620 --> 37:02.720
就是item.color

37:04.530 --> 37:05.330
宽度呢

37:05.330 --> 37:08.530
就是item.size

37:08.630 --> 37:09.930
拼接上px

37:10.830 --> 37:11.430
没问题吧

37:11.730 --> 37:13.130
绑定成一个动态数据

37:13.530 --> 37:14.530
好value呢

37:14.530 --> 37:15.530
value就是这

37:16.930 --> 37:19.330
就是item.value

37:20.530 --> 37:22.530
好是不是可以是不是循环这个数据

37:22.530 --> 37:23.130
就完事了

37:23.630 --> 37:23.930
对不对

37:23.930 --> 37:24.930
那么下面不要了

37:27.410 --> 37:27.810
好

37:28.810 --> 37:29.410
看一下目前

37:30.010 --> 37:30.710
目前有东西吗

37:30.710 --> 37:31.610
没有任何东西

37:32.110 --> 37:33.410
为啥没有任何东西呢

37:33.810 --> 37:34.410
为啥呢

37:35.410 --> 37:36.310
因为现在没数据嘛

37:36.310 --> 37:36.610
对吧

37:36.610 --> 37:37.710
因为返回的数据呢

37:37.710 --> 37:39.210
这个响应式数据是个空数

37:40.110 --> 37:41.010
那么接下来

37:41.710 --> 37:42.710
我们要做的事

37:44.210 --> 37:46.810
就是要根据这个数据

37:47.610 --> 37:48.810
来得到一个

37:49.510 --> 37:51.310
最终的这个boss数据

37:52.310 --> 37:53.410
那怎么来得到呢

37:53.510 --> 37:53.910
你看啊

37:53.910 --> 37:55.610
这里是不是一个计算属性啊

37:56.510 --> 37:57.110
想一想

37:57.310 --> 37:58.610
是不是一个计算属性

38:00.210 --> 38:00.910
怎么计算

38:00.910 --> 38:02.310
就是我通过这个数据

38:02.310 --> 38:03.410
原式的数据

38:05.110 --> 38:06.610
这里可能稍微对同意们来说

38:06.610 --> 38:08.010
稍微可能有点复杂啊

38:08.210 --> 38:08.710
注意听

38:10.310 --> 38:11.710
原式的数据是这个样子

38:14.520 --> 38:15.120
country

38:16.520 --> 38:16.920
value

38:16.920 --> 38:17.320
对吧

38:17.420 --> 38:18.020
每一个数据

38:18.020 --> 38:18.620
只有一个

38:18.620 --> 38:19.420
只有一个

38:20.020 --> 38:20.620
两个属性

38:20.620 --> 38:21.420
一个是country

38:21.420 --> 38:22.220
一个是value

38:22.820 --> 38:23.720
现在我要把它变成这个

38:23.720 --> 38:25.020
一个加两个属性上

38:25.120 --> 38:26.220
返回一个新的数据

38:26.520 --> 38:27.320
那么这个新的数据

38:27.320 --> 38:28.420
是一个响应式数据

38:28.920 --> 38:30.320
那是不是一个计算属性

38:30.320 --> 38:30.720
对吧

38:30.720 --> 38:32.120
所以说我们把这个ref改一下

38:32.120 --> 38:32.720
改成什么

38:32.720 --> 38:33.420
computing

38:35.720 --> 38:36.320
注意听啊

38:36.320 --> 38:38.420
这里我们会有会反复进行重构

38:38.520 --> 38:39.920
来顺便说一下

38:39.920 --> 38:41.520
在使用completion API的时候

38:41.520 --> 38:43.720
有些小的细节问题

38:44.820 --> 38:46.520
把它变成一个计算属性

38:46.920 --> 38:48.020
根据谁来计算

38:48.020 --> 38:50.020
是不是根据这个GDP来计算

38:50.920 --> 38:51.320
对不对

38:51.320 --> 38:52.320
是根据他来计算

38:53.920 --> 38:54.420
来吧

38:54.620 --> 38:55.620
那他怎么来计算

38:55.920 --> 38:57.120
他不是一个数据吗

38:59.120 --> 38:59.720
一个个来

38:59.720 --> 39:00.320
一个问题

39:00.320 --> 39:00.920
一个问题来

39:01.520 --> 39:02.520
那么这个玩意

39:02.920 --> 39:03.720
我们刚才说了

39:03.720 --> 39:05.620
他应该是一个响应式数据

39:08.400 --> 39:09.900
所以我们这里写的是一个ref

39:10.300 --> 39:10.700
对吧

39:11.100 --> 39:12.500
但是这边传的给

39:12.500 --> 39:14.100
传给他的是一个ref吗

39:15.200 --> 39:15.900
并不是

39:16.600 --> 39:18.100
就是一个数据

39:18.700 --> 39:19.800
传给他就是一个数据

39:20.100 --> 39:21.400
那么这样的数据呢

39:21.600 --> 39:23.000
他变化了过后

39:23.500 --> 39:24.400
这边是无法

39:24.400 --> 39:26.600
无法无法记录的

39:27.000 --> 39:27.800
啥意思啊

39:28.500 --> 39:29.700
到底是啥意思啊

39:29.700 --> 39:30.900
这里一个小的细节问题

39:30.900 --> 39:31.500
我这里不说

39:31.500 --> 39:32.600
你们以后开发东西

39:32.600 --> 39:33.700
一定会遇到这样的问题

39:34.200 --> 39:35.400
比方说这里把个ref去掉

39:35.400 --> 39:37.400
免得看着看着感想大家

39:38.200 --> 39:39.100
那么这个GDP

39:39.100 --> 39:39.700
我们打印出来

39:39.700 --> 39:40.900
看他是一个啥

39:43.390 --> 39:43.790
刷新

39:48.460 --> 39:49.760
你看到他是个proxy

39:49.960 --> 39:50.460
对吧

39:50.460 --> 39:51.760
为什么是一个proxy呢

39:52.960 --> 39:53.960
因为他是一个数据

39:53.960 --> 39:55.360
数据在读取的时候

39:55.360 --> 39:56.260
我们之前说过

39:56.860 --> 39:57.860
维尤山的

39:58.360 --> 39:59.460
这种响应式啊

39:59.860 --> 40:00.960
他把对象里边的所有东西

40:00.960 --> 40:02.660
全部深度变成一个proxy

40:02.860 --> 40:04.960
但是原始只类型除外

40:05.460 --> 40:06.460
那么这里呢

40:06.460 --> 40:07.460
他是一个数据

40:07.460 --> 40:08.460
数据也是个proxy

40:08.460 --> 40:09.960
但是尽管他是个proxy

40:11.460 --> 40:12.960
这个数据的变化

40:12.960 --> 40:14.960
如果说你这里直接这样子写

40:14.960 --> 40:16.460
用什么GDP

40:16.460 --> 40:17.460
MAP

40:17.960 --> 40:21.020
我都不去加任何数据

40:21.020 --> 40:22.020
我就把MAP一下

40:23.020 --> 40:24.020
如果说你直接这样子写

40:24.520 --> 40:25.520
我们来看一下

40:26.020 --> 40:27.520
他到时候变化过后

40:27.520 --> 40:29.020
computed会不会运行

40:30.020 --> 40:31.020
computed

40:34.870 --> 40:35.870
好

40:35.870 --> 40:36.870
来看一下

40:37.370 --> 40:37.870
好

40:39.870 --> 40:40.870
是不是运行到一次

40:40.870 --> 40:41.870
computed

40:41.870 --> 40:43.870
为什么会运行一次呢

40:43.870 --> 40:44.870
慢慢来啊

40:47.000 --> 40:49.000
这里去调用这个GDP

40:49.000 --> 40:50.000
是不是一开始

40:51.000 --> 40:52.000
得到这个响应式数据

40:52.000 --> 40:53.500
一开始这里有没有运行

40:53.500 --> 40:54.500
没有运行

40:55.500 --> 40:57.000
然后我们在界面中

40:57.000 --> 40:58.000
无办理边

40:58.000 --> 40:59.500
是不是使用到了这个bar

41:01.000 --> 41:02.000
用到了他

41:02.000 --> 41:03.000
那么用到了他的时候

41:03.000 --> 41:04.500
是不是要开始计算了

41:04.500 --> 41:05.000
因此呢

41:05.000 --> 41:06.500
触发了一次computed

41:07.500 --> 41:09.000
由于我们的数据

41:09.000 --> 41:10.500
是一步加载的

41:10.500 --> 41:12.500
因此一开始这个

41:12.500 --> 41:14.500
一开始这个数据是空的

41:14.500 --> 41:15.500
看没

41:15.500 --> 41:16.500
数据是不是空的

41:17.500 --> 41:19.500
但是一步加载很快完成了

41:19.500 --> 41:20.500
那么这个时候

41:20.500 --> 41:21.500
数据有值了

41:21.500 --> 41:23.500
他的值是不是变了

41:23.500 --> 41:25.500
他的值变了过后

41:25.500 --> 41:27.500
为什么没有重新计算呢

41:28.500 --> 41:29.500
这就很奇怪了

41:29.500 --> 41:31.500
他为什么没有重新计算呢

41:33.500 --> 41:34.500
这就是涉及到

41:34.500 --> 41:35.500
我们刚才说的问题

41:36.500 --> 41:37.500
就是这个玩意儿

41:38.500 --> 41:40.500
就是我们这个computed

41:40.500 --> 41:41.500
要重新计算

41:41.500 --> 41:43.500
取决于他的依赖

41:44.500 --> 41:45.500
如果说你直接

41:45.500 --> 41:46.500
把这个属性里边的东西

41:46.500 --> 41:48.500
直接给我传过来

41:48.500 --> 41:49.500
属性变化

41:49.500 --> 41:51.500
那么你从这个代码里边看

41:51.500 --> 41:52.500
你看一下

41:52.500 --> 41:53.500
能看出这个地方

41:53.500 --> 41:54.500
跟属性有依赖吗

41:55.500 --> 41:56.500
是不是看不出来

41:56.500 --> 41:57.500
看不出来

41:57.500 --> 41:59.500
任何跟属性有依赖的地方

42:00.500 --> 42:01.500
懂我的意思吧

42:01.500 --> 42:03.500
就属性他变了过后

42:03.500 --> 42:05.500
他这里不会变的

42:06.500 --> 42:07.500
不会变的

42:07.500 --> 42:08.500
除非说什么

42:08.500 --> 42:10.500
除非这个GDP里边东西变了

42:10.500 --> 42:12.500
那么可能会变化

42:12.500 --> 42:14.500
那么但是这里属性变化了

42:14.500 --> 42:15.500
他并不会变

42:15.500 --> 42:17.500
因为他这里没有跟属性产生依赖

42:18.500 --> 42:19.500
懂我的意思吧

42:20.500 --> 42:21.500
那怎么办呢

42:22.500 --> 42:23.500
我们换一种写法

42:24.500 --> 42:25.500
我们不传这个GDP

42:25.500 --> 42:26.500
传一个属性过去

42:26.500 --> 42:27.500
把整个属性传过去

42:27.500 --> 42:28.500
看行不行

42:32.580 --> 42:33.580
那么这里应该怎么写

42:35.580 --> 42:36.580
那么这样子写行不行

42:36.580 --> 42:37.580
这样写就可以了

42:37.580 --> 42:39.580
因为你看这个compute

42:39.580 --> 42:40.580
跟谁依赖

42:40.580 --> 42:41.580
跟这个属性依赖

42:41.580 --> 42:42.580
那么属性里边的

42:42.580 --> 42:43.580
这个属性变化了

42:43.580 --> 42:45.580
这个属性被重新复制了

42:45.580 --> 42:46.580
那么这个compute

42:46.580 --> 42:47.580
得要重新计算

42:47.580 --> 42:48.580
保存

42:48.580 --> 42:49.580
你看一下

42:49.580 --> 42:51.580
是运行的两支compute的

42:51.580 --> 42:52.580
那么这里数据是不是出来了

42:52.580 --> 42:53.580
警官这里

42:53.580 --> 42:55.580
还有两个有些数据是缺失的

42:56.580 --> 42:58.580
这个地方有点复杂

42:58.580 --> 43:00.580
一定要好好的理解清楚

43:00.580 --> 43:02.580
以后你写代码的时候

43:02.580 --> 43:03.580
遇到这种场景要出问题的

43:04.580 --> 43:06.580
那么现在

43:06.580 --> 43:07.580
但是这样子写的

43:07.580 --> 43:08.580
又太恶心了

43:08.580 --> 43:09.580
因为我这个地方

43:10.580 --> 43:12.580
提取出了一个函数

43:12.580 --> 43:13.580
这个函数你干嘛

43:13.580 --> 43:14.580
把整个属性给我了

43:14.580 --> 43:15.580
你只需要给我GDP

43:15.580 --> 43:16.580
去属性就行了

43:16.580 --> 43:18.580
那么我们又回到

43:18.580 --> 43:19.580
最初的情况

43:19.580 --> 43:22.580
我希望它这个GDP

43:22.580 --> 43:23.580
是一个rave

43:25.580 --> 43:27.580
我希望GDP是一个rave

43:28.580 --> 43:29.580
那怎么办

43:29.580 --> 43:30.580
那又怎么办

43:33.020 --> 43:35.020
那么这里应该是这样子写

43:38.020 --> 43:39.020
那这里怎么玩的

43:39.020 --> 43:41.020
就这里可以这样子

43:42.020 --> 43:44.020
我在这里去构建一个GDP

43:45.020 --> 43:46.020
来自于哪呢

43:46.020 --> 43:47.020
来自于computed

44:00.250 --> 44:02.250
这个computed来自于哪呢

44:02.250 --> 44:03.250
probs.gdp

44:04.250 --> 44:05.250
你看这个逻辑

44:05.250 --> 44:06.250
还这个逻辑关系

44:06.250 --> 44:07.250
这是一个计算属性

44:07.250 --> 44:08.250
因为我们知道计算属性

44:08.250 --> 44:09.250
它一定是个rave

44:09.250 --> 44:10.250
一定是一个rave

44:10.250 --> 44:11.250
那么这个计算属性

44:11.250 --> 44:12.250
依赖谁

44:12.250 --> 44:13.250
是不是依赖属性

44:13.250 --> 44:14.250
里边的这个东西

44:14.250 --> 44:15.250
那么将来属性变化了

44:15.250 --> 44:17.250
它是不是要重新计算

44:17.250 --> 44:18.250
那么这个玩意

44:18.250 --> 44:19.250
是一个响应数据

44:19.250 --> 44:20.250
扔过去

44:20.250 --> 44:21.250
那么它变化了

44:21.250 --> 44:22.250
它依赖它

44:22.250 --> 44:23.250
那么就变成这样的

44:23.250 --> 44:24.250
依赖关系了

44:25.250 --> 44:27.250
我们的这个GDP

44:27.250 --> 44:28.250
这个for是依赖谁

44:28.250 --> 44:30.250
依赖这个GDPrave

44:30.250 --> 44:31.250
这个GDPrave

44:31.250 --> 44:32.250
依赖谁

44:32.250 --> 44:34.250
依赖probs.gdp

44:34.250 --> 44:36.250
到时候这个属性变化了

44:36.250 --> 44:38.250
是不是它会重新计算

44:38.250 --> 44:39.250
它会重新计算

44:39.250 --> 44:40.250
它就会重新计算

44:40.250 --> 44:42.250
变成这样的依赖关系了

44:42.250 --> 44:43.250
懂我的意思吗

44:43.250 --> 44:45.250
那么这样子的就可以了

44:45.250 --> 44:46.250
依赖

44:46.250 --> 44:48.250
这里会有一些小的麻烦

44:48.250 --> 44:49.250
大家要注意一下

44:50.250 --> 44:51.250
好

44:51.250 --> 44:52.250
那么现在我们来看一下

44:52.250 --> 44:53.250
是不是运行了两次

44:53.250 --> 44:54.250
computing的

44:55.250 --> 44:56.250
小心

44:56.250 --> 44:57.250
我把它删掉了

44:57.250 --> 44:58.250
输出

44:58.250 --> 44:59.250
computing

45:00.250 --> 45:01.250
运行了两次

45:01.250 --> 45:02.250
两次就正确了

45:02.250 --> 45:03.250
因为一开始是空输出

45:03.250 --> 45:04.250
后来呢

45:04.250 --> 45:05.250
意不加载完成过后有值了

45:05.250 --> 45:07.250
它又会重新计算一次

45:08.250 --> 45:09.250
好

45:09.250 --> 45:10.250
接下来回到这个问题

45:10.250 --> 45:11.250
又来

45:12.250 --> 45:13.250
那么我这里用map

45:13.250 --> 45:15.250
返回的是远方不动的返回

45:15.250 --> 45:16.250
远载对象

45:16.250 --> 45:17.250
那肯定不行了

45:17.250 --> 45:18.250
我们要返回的是什么对象

45:18.250 --> 45:19.250
我们要返回的

45:22.390 --> 45:23.390
远载对象展开

45:23.390 --> 45:24.390
是不是还要加两个属性

45:24.390 --> 45:26.390
一个是什么size属性

45:26.390 --> 45:28.390
一个是color属性

45:31.390 --> 45:32.390
一个是size

45:32.390 --> 45:33.390
一个个来

45:34.390 --> 45:35.390
首先是color

45:35.390 --> 45:36.390
那么这个颜色呢

45:36.390 --> 45:37.390
我这里不是随机的

45:37.390 --> 45:39.390
我是有一个颜色的数组

45:39.390 --> 45:40.390
我这个颜色数组

45:40.390 --> 45:42.390
好像没有拿出来

45:42.390 --> 45:43.390
我早要之前干了

45:44.390 --> 45:46.390
颜色的数组

45:46.390 --> 45:47.390
在这

45:48.390 --> 45:49.390
复制一下

45:50.390 --> 45:51.390
就这么一个数组

45:51.390 --> 45:52.390
我要从这个数组里面

45:52.390 --> 45:54.390
随便去取一项

45:54.390 --> 45:56.390
做一个颜色放这

45:56.390 --> 45:57.390
我咋取呢

45:57.390 --> 45:58.390
我就可以用这种方式取的

45:58.390 --> 45:59.390
用下标

45:59.390 --> 46:01.390
就是原来这个数组里面

46:01.390 --> 46:02.390
某一项

46:02.390 --> 46:03.390
通过这个下标

46:03.390 --> 46:04.390
从这里面去取

46:04.390 --> 46:05.390
那怎么取呢

46:05.390 --> 46:06.390
因为我这里是五个

46:06.390 --> 46:07.390
那么这个数据

46:07.390 --> 46:08.390
我不能假设为五个

46:08.390 --> 46:09.390
有可能有六个

46:09.390 --> 46:10.390
有可能有二十个

46:10.390 --> 46:11.390
说不准

46:11.390 --> 46:12.390
所以我这里呢就跟这样子

46:12.390 --> 46:13.390
colors

46:14.390 --> 46:15.390
i 处义

46:15.390 --> 46:16.390
colors.links

46:16.390 --> 46:17.390
懂了意思吗

46:18.390 --> 46:19.390
这啥意思

46:20.390 --> 46:21.390
我这里第一项

46:22.390 --> 46:23.390
处于它的

46:23.390 --> 46:24.390
colors的长度

46:25.390 --> 46:26.390
那么零处于五

46:26.390 --> 46:27.390
零处于五

46:28.390 --> 46:29.390
取这个

46:29.390 --> 46:30.390
取这个下标

46:30.390 --> 46:31.390
至于零

46:31.390 --> 46:32.390
零处于五的余数就是零

46:32.390 --> 46:33.390
取这个

46:34.390 --> 46:36.390
那么把第一个颜色复制过去了

46:36.390 --> 46:37.390
i 处于一的时候

46:37.390 --> 46:38.390
i 处于一的时候

46:38.390 --> 46:39.390
取

46:40.390 --> 46:41.390
一处于五的余数

46:41.390 --> 46:42.390
是不是还是一

46:42.390 --> 46:43.390
那么也就是说

46:43.390 --> 46:44.390
小于五的情况下

46:44.390 --> 46:46.390
是不是零一二三四

46:46.390 --> 46:47.390
对不对

46:47.390 --> 46:48.390
一是它的颜色

46:48.390 --> 46:49.390
那么如果说

46:49.390 --> 46:50.390
定六个呢

46:50.390 --> 46:51.390
定六个下标数是五

46:51.390 --> 46:52.390
下标是五

46:52.390 --> 46:53.390
五处于五的余数

46:53.390 --> 46:54.390
是不是还是零

46:54.390 --> 46:55.390
又回到零了

46:55.390 --> 46:56.390
那么就是

46:56.390 --> 46:57.390
我的这个下标呢就是这样子

46:57.390 --> 46:58.390
我甭管你这个数组

46:58.390 --> 46:59.390
给我有多少项

47:00.390 --> 47:01.390
我的颜色呢就是

47:01.390 --> 47:02.390
零一二三四

47:02.390 --> 47:03.390
零一二三四

47:03.390 --> 47:04.390
零一二三四

47:04.390 --> 47:05.390
就这么个意思

47:05.390 --> 47:06.390
就有很多的手段

47:06.390 --> 47:07.390
来控制这个东西

47:07.390 --> 47:10.390
好然后 size 尺寸

47:10.390 --> 47:12.390
尺寸又怎么算的呢

47:13.390 --> 47:14.390
尺寸

47:14.390 --> 47:15.390
这里有个最大的尺寸

47:15.390 --> 47:17.390
那尺寸咋算

47:17.390 --> 47:19.390
比方说美国

47:19.390 --> 47:20.390
尺寸咋算

47:20.390 --> 47:24.830
它这个条的尺寸咋算呢

47:24.830 --> 47:25.830
那么我们这里

47:25.830 --> 47:26.830
应该是用这种算法

47:27.830 --> 47:28.830
看着

47:29.830 --> 47:30.830
我要从这个数组中

47:30.830 --> 47:32.830
取出一个最大的

47:33.830 --> 47:34.830
最大的值

47:34.830 --> 47:35.830
比方说目前是中国

47:39.230 --> 47:40.230
取出最大的值

47:40.230 --> 47:41.230
比方说这里24

47:41.230 --> 47:42.230
比方说24嘛

47:43.230 --> 47:45.230
好那么我就

47:45.230 --> 47:46.230
最大的值取出来了

47:46.230 --> 47:47.230
然后最大的宽度

47:47.230 --> 47:48.230
是多少呢

47:48.230 --> 47:49.230
400

47:49.230 --> 47:51.740
然后接下来

47:51.740 --> 47:52.740
我一个个循环

47:52.740 --> 47:54.740
先看一下美国

47:54.740 --> 47:56.740
美国的这个条的长度

47:56.740 --> 47:57.740
是多少呢

47:57.740 --> 47:58.740
我们设为一个x

47:59.740 --> 48:00.740
那么应该就是

48:00.740 --> 48:02.740
美国的条的长度

48:02.740 --> 48:05.740
比上最大的值

48:05.740 --> 48:07.740
应该等于

48:07.740 --> 48:08.740
美国的

48:08.740 --> 48:10.740
美国的目前的值

48:10.740 --> 48:11.740
21

48:11.740 --> 48:12.740
比上最大的值

48:12.740 --> 48:13.740
应该等于

48:13.740 --> 48:15.740
美国这个条的长度

48:15.740 --> 48:17.740
比上最大的长度

48:17.740 --> 48:18.740
是不是这个逻辑

48:18.740 --> 48:19.740
那么也就是说

48:19.740 --> 48:20.740
这个长度

48:20.740 --> 48:21.740
应该怎么算呢

48:21.740 --> 48:22.740
再乘一个400

48:22.740 --> 48:24.740
对吧

48:24.740 --> 48:25.740
应该这样子

48:26.740 --> 48:27.740
那么这个东西怎么来算

48:27.740 --> 48:28.740
就是当前的值

48:28.740 --> 48:29.740
比上最大的值

48:29.740 --> 48:31.740
再乘一个最大长度

48:31.740 --> 48:33.740
最大的尺寸就玩笑了

48:33.740 --> 48:34.740
所以说最大尺寸

48:34.740 --> 48:35.740
我们目前是

48:35.740 --> 48:36.740
已知的是参数

48:36.740 --> 48:37.740
那么最大的值

48:37.740 --> 48:38.740
是不是要算一下

48:38.740 --> 48:39.740
好来吧

48:39.740 --> 48:40.740
来算一个最大的值

48:40.740 --> 48:41.740
那么是不是又是个

48:41.740 --> 48:42.740
计算属性

48:42.740 --> 48:43.740
来算一下

48:44.740 --> 48:47.740
const max value

48:47.740 --> 48:48.740
最大的值

48:48.740 --> 48:49.740
等于多少呢

48:49.740 --> 48:50.740
等于computed

48:53.940 --> 48:54.940
来算一下吧

48:54.940 --> 48:55.940
如果说gdp

48:55.940 --> 48:57.940
ref their value

48:57.940 --> 48:58.940
这个数组

48:58.940 --> 48:59.940
这个数组的长度

48:59.940 --> 49:00.940
有值

49:00.940 --> 49:01.940
那么说明这个数组

49:01.940 --> 49:02.940
肯定有东西

49:02.940 --> 49:03.940
有东西的话怎么算

49:03.940 --> 49:04.940
return

49:05.940 --> 49:08.940
mas max

49:08.940 --> 49:09.940
取最大值

49:09.940 --> 49:10.940
这个东西没什么好说的

49:10.940 --> 49:11.940
然后就是gdp

49:11.940 --> 49:12.940
ref their value

49:12.940 --> 49:13.940
然后map

49:18.090 --> 49:19.090
就是把

49:19.090 --> 49:20.090
这个里面

49:20.090 --> 49:21.090
它原来的

49:21.090 --> 49:22.090
原来数据里面

49:22.090 --> 49:23.090
所谓的value提出来

49:23.090 --> 49:24.090
形成一个数组

49:25.090 --> 49:26.090
形成这么一个数组

49:27.090 --> 49:28.090
24

49:28.090 --> 49:29.090
24

49:29.090 --> 49:30.090
10

49:30.090 --> 49:31.090
对吧

49:31.090 --> 49:32.090
形成这么一个数组

49:32.090 --> 49:33.090
但是从一个数组里面

49:33.090 --> 49:34.090
取最大值

49:34.090 --> 49:35.090
非常简单

49:35.090 --> 49:36.090
这是这一块

49:36.090 --> 49:37.090
好

49:37.090 --> 49:38.090
如果说它的ness

49:38.090 --> 49:39.090
等于0

49:39.090 --> 49:40.090
那么表示的

49:40.090 --> 49:41.090
没数据

49:41.090 --> 49:42.090
没数据的话就是0

49:42.090 --> 49:43.090
max value

49:43.090 --> 49:44.090
那么是不是写出

49:44.090 --> 49:45.090
这么一个计算属性

49:45.090 --> 49:46.090
好

49:46.090 --> 49:47.090
有了这个计算属性过后

49:47.090 --> 49:48.090
那么这个size怎么算

49:48.090 --> 49:50.090
size是不是等于

49:50.090 --> 49:52.090
当前的值

49:52.090 --> 49:58.810
除以max value

49:58.810 --> 49:59.810
对吧

49:59.810 --> 50:00.810
所以这是ref

50:00.810 --> 50:01.810
这是ref

50:01.810 --> 50:05.810
然后要乘以max size

50:06.810 --> 50:08.810
所以得到一个

50:08.810 --> 50:10.810
一个bar的数组了

50:10.810 --> 50:11.810
保存

50:11.810 --> 50:12.810
你看一下

50:12.810 --> 50:17.020
长度没问题吧

50:17.020 --> 50:19.020
数据没问题吧

50:19.020 --> 50:20.020
所以都没问题

50:20.020 --> 50:21.020
这边我们先在这

50:21.020 --> 50:22.020
一会再说

50:22.020 --> 50:23.020
说没问题了

50:23.020 --> 50:24.020
然后接下来

50:24.020 --> 50:25.020
我们来改一下数据

50:25.020 --> 50:26.020
比方说没有国改成11

50:26.020 --> 50:27.020
对吧

50:27.020 --> 50:28.020
它不会重新计算

50:28.020 --> 50:29.020
这个东西改了

50:29.020 --> 50:30.020
是不是

50:30.020 --> 50:32.650
这个玩意改了

50:32.650 --> 50:34.650
这个小意思数据改了

50:34.650 --> 50:35.650
它一改

50:35.650 --> 50:37.650
是不是这边属性变动了

50:37.650 --> 50:38.650
属性变动

50:38.650 --> 50:39.650
这个计算属性变动了

50:39.650 --> 50:40.650
这个计算属性变动了

50:40.650 --> 50:42.650
一连串的

50:42.650 --> 50:43.650
是不是导致它变动了

50:43.650 --> 50:44.650
它变动了

50:44.650 --> 50:45.650
对不对

50:45.650 --> 50:46.650
这些都是详细数据

50:46.650 --> 50:48.650
所以改了过后就全部改了

50:48.650 --> 50:50.650
好好去体会一下

50:50.650 --> 50:54.180
完没

50:54.180 --> 50:55.180
没完

50:55.180 --> 50:59.960
这动画咋办

50:59.960 --> 51:02.270
这动画咋办

51:02.270 --> 51:04.270
这动画不是CSS动画

51:04.270 --> 51:06.270
而是GS动画

51:06.270 --> 51:07.270
啥意思呢

51:07.270 --> 51:08.270
这动画啥意思

51:08.270 --> 51:11.270
你好想想这动画啥意思

51:11.270 --> 51:13.270
这动画的意思就是说

51:13.270 --> 51:14.270
我这个玩意

51:14.270 --> 51:16.270
我这就是文boss数据

51:16.270 --> 51:17.270
对吧

51:17.270 --> 51:18.270
就这个玩意数据

51:18.270 --> 51:19.270
这就是文的数据

51:19.270 --> 51:20.270
boss这个数据

51:21.270 --> 51:24.270
这个数据不是瞬间变化的

51:24.270 --> 51:26.270
它不是说一开始

51:26.270 --> 51:28.270
数据长度为0

51:28.270 --> 51:30.270
然后通常就变成这个样子

51:30.270 --> 51:31.270
然后改成11

51:31.270 --> 51:32.270
它马上就变成这个样子

51:32.270 --> 51:33.270
如果说这样子变动

51:33.270 --> 51:34.270
数据是这样子变动的话

51:34.270 --> 51:35.270
那么界面

51:35.270 --> 51:37.270
它自然而然就瞬间变化了

51:37.270 --> 51:38.270
因为界面始终

51:38.270 --> 51:40.270
是根据数据宣传出来的

51:40.270 --> 51:41.270
对吧

51:41.270 --> 51:42.270
因为我这里不好用

51:42.270 --> 51:43.270
CSS3

51:43.270 --> 51:44.270
为什么不好用

51:44.270 --> 51:45.270
因为这个数据

51:45.270 --> 51:47.270
这个是网页内容的变化

51:47.270 --> 51:48.270
它怎么用CSS3

51:48.270 --> 51:49.270
你看我把它改成11

51:49.270 --> 51:52.270
它是从21逐渐变到11的

51:52.270 --> 51:54.270
看没

51:54.270 --> 51:55.270
那怎么办

51:55.270 --> 51:57.270
所以说我们这里要想个办法

51:57.270 --> 52:00.270
让它的数据变化是平滑的

52:00.270 --> 52:02.270
比方说我要把它变成21

52:02.270 --> 52:03.270
那么我怎么变呢

52:03.270 --> 52:05.270
我不是说马上把它复制为21

52:05.270 --> 52:07.270
我先把它复制为11.5

52:07.270 --> 52:09.270
然后复制为11.6

52:09.270 --> 52:10.270
复制为11.7

52:10.270 --> 52:12.270
最终复制到21

52:12.270 --> 52:14.270
对 我们要完成这件事

52:14.270 --> 52:16.270
那么这件事有咋做呢

52:16.270 --> 52:20.100
这件事有咋做呢

52:20.100 --> 52:23.100
我们先把这个代码格式

52:23.100 --> 52:24.100
给它写出来

52:24.100 --> 52:26.100
我们再来研究怎么来做

52:26.100 --> 52:28.100
代码格式是啥呢

52:28.100 --> 52:30.100
就是这个玩意啊

52:30.100 --> 52:32.100
它不能再这么做了

52:32.100 --> 52:34.100
不能再这么写了

52:34.100 --> 52:36.100
因为如果说你这样子写的话

52:36.100 --> 52:38.100
数据一定是瞬间变化

52:38.100 --> 52:40.100
你看没事重新计算

52:40.100 --> 52:42.100
瞬间变成一个新的值

52:42.100 --> 52:44.100
不能再这么写了

52:44.100 --> 52:46.100
那怎么写呢

52:46.100 --> 52:48.100
我们把这个变量的名字

52:48.100 --> 52:50.100
给它改一下

52:50.100 --> 52:51.100
给它改成什么呢

52:51.100 --> 52:53.100
Bars target

52:53.100 --> 52:55.980
啥意思

52:55.980 --> 53:01.980
就是最新的条的

53:01.980 --> 53:07.980
就是条的最新状态

53:07.980 --> 53:09.980
它最终是应该是这个状态

53:09.980 --> 53:11.980
目标是这个目标

53:11.980 --> 53:13.980
但是变化的时候呢

53:13.980 --> 53:15.980
不能瞬间变成这个状态

53:15.980 --> 53:16.980
得一步一步变

53:16.980 --> 53:18.980
所以说我们还需要一个数据

53:18.980 --> 53:20.980
就是Bars

53:20.980 --> 53:22.980
把Ref加上

53:22.980 --> 53:28.410
Bars,Ref

53:28.410 --> 53:30.410
一个空数

53:30.410 --> 53:32.410
啥意思

53:32.410 --> 53:35.410
每一次它变化的时候

53:35.410 --> 53:38.410
是不是我们最终的目标值变了

53:38.410 --> 53:40.410
我要把它

53:40.410 --> 53:42.410
从当前的状态

53:42.410 --> 53:45.410
变到这个目标值

53:45.410 --> 53:47.410
懂我的意思吗

53:47.410 --> 53:49.410
我要把它

53:49.410 --> 53:50.410
从当前状态

53:50.410 --> 53:52.410
变到这个目标值

53:52.410 --> 53:53.410
用啥

53:53.410 --> 53:56.410
用WatchEffect

53:56.410 --> 53:58.410
是不是用它

53:58.410 --> 54:00.410
对不对

54:00.410 --> 54:01.410
当它

54:01.410 --> 54:02.410
我在这里边会

54:02.410 --> 54:05.410
也就是说在这里边我们要干嘛呢

54:05.410 --> 54:13.410
将Bars从当前状态变化到

54:13.410 --> 54:17.410
目标Bars target

54:17.410 --> 54:19.410
因为这里边会用到这个Bars target

54:19.410 --> 54:21.410
是不是只要它一变

54:21.410 --> 54:23.410
它也会跟这边

54:23.410 --> 54:25.410
对不对

54:25.410 --> 54:27.410
懂我的意思吗

54:27.410 --> 54:34.430
喝喝水

54:34.430 --> 54:37.430
当然我们也可以用什么呢

54:37.430 --> 54:41.260
也可以用Watch

54:41.260 --> 54:43.260
观察什么呢

54:43.260 --> 54:45.260
可以用Watch

54:45.260 --> 54:47.260
Watch,观察什么

54:47.260 --> 54:50.260
观察Bars target

54:50.260 --> 54:52.260
观察它的变化

54:52.260 --> 54:54.260
当它变了过后

54:55.260 --> 54:57.260
我们一样的

54:57.260 --> 55:02.260
从Bars变化到Bars target

55:02.260 --> 55:03.260
对吧

55:03.260 --> 55:05.260
将这个

55:05.260 --> 55:08.260
将它变化到这趴

55:08.260 --> 55:10.260
不能瞬间变化

55:10.260 --> 55:11.260
那么这里呢

55:11.260 --> 55:12.260
我们可以加上一个第三个参数

55:12.260 --> 55:13.260
Deep

55:13.260 --> 55:14.260
Q

55:14.260 --> 55:16.260
跟过去一样的深度观察

55:16.260 --> 55:18.260
因为它是一个宿主嘛

55:19.260 --> 55:21.260
好,来吧

55:21.260 --> 55:23.260
怎么弄

55:23.260 --> 55:24.260
它要变化了

55:24.260 --> 55:25.260
它是不是要一个个循环

55:25.260 --> 55:26.260
这里边有很多印象

55:26.260 --> 55:27.260
这是个宿主

55:27.260 --> 55:28.260
它是个Ref

55:28.260 --> 55:29.260
它是个宿主

55:29.260 --> 55:30.260
那么是不是要循环它

55:30.260 --> 55:32.260
Let's i等于0

55:32.260 --> 55:35.260
i小于Bars target

55:35.260 --> 55:37.260
Your value, your length

55:37.260 --> 55:39.260
是循环这个宿主

55:39.260 --> 55:41.260
一个一个看

55:41.260 --> 55:42.260
首先看一下

55:42.260 --> 55:43.260
比方说

55:43.260 --> 55:44.260
一开始是什么情况

55:44.260 --> 55:47.260
一开始我Bars是空的

55:47.260 --> 55:48.260
对不对

55:48.260 --> 55:49.260
是空的

55:49.260 --> 55:52.260
然后后边Bars target

55:52.260 --> 55:54.260
变成了这个东西

55:54.260 --> 55:55.260
后边还有一些数

55:55.260 --> 55:56.260
那么

55:56.260 --> 55:57.260
是不是一项一项看

55:57.260 --> 55:58.260
首先看一下

55:58.260 --> 55:59.260
循环它

55:59.260 --> 56:00.260
循环到第一项

56:00.260 --> 56:02.260
看一下它有没有第一项

56:02.260 --> 56:03.260
没有的话

56:03.260 --> 56:05.260
给它复制个第一项不就完了吗

56:05.260 --> 56:07.260
因为现在用了Proxy过后

56:07.260 --> 56:08.260
你随便针对这个

56:08.260 --> 56:09.260
所应的复制

56:09.260 --> 56:11.260
也是带有响应式的

56:11.260 --> 56:12.260
判断一下吧

56:12.260 --> 56:14.260
判断一下这个Bars

56:14.260 --> 56:16.260
Your value

56:16.260 --> 56:18.260
是不是有值的

56:18.260 --> 56:19.260
如果说它没有值的话

56:19.260 --> 56:21.260
给它复一个值

56:21.260 --> 56:22.260
Your value

56:22.260 --> 56:24.260
复什么值

56:24.260 --> 56:26.950
复什么值

56:26.950 --> 56:27.950
有什么东西

56:27.950 --> 56:28.950
我就复这个值没

56:28.950 --> 56:31.840
复这个值没

56:31.840 --> 56:32.840
把这一项放过去

56:32.840 --> 56:33.840
那放过去就是瞬间变化了

56:33.840 --> 56:35.840
你不能瞬间变化

56:35.840 --> 56:37.840
应该是放一个初始值

56:37.840 --> 56:38.840
初始值是什么

56:38.840 --> 56:41.840
首先把这个Bars target

56:41.840 --> 56:43.840
Your value

56:43.840 --> 56:44.840
展开

56:44.840 --> 56:46.840
就把这里面的属性展开

56:46.840 --> 56:48.840
这一项一项想展开

56:48.840 --> 56:49.840
展开过后

56:49.840 --> 56:50.840
我要把它的Size

56:50.840 --> 56:52.840
Q改成0

56:52.840 --> 56:53.840
对不对

56:53.840 --> 56:55.840
Value值

56:55.840 --> 56:56.840
Q改成0

56:56.840 --> 56:57.840
这个Value值和Size

56:57.840 --> 56:59.840
它会逐渐变化

56:59.840 --> 57:01.840
不是瞬间变化过去的

57:01.840 --> 57:02.840
你看

57:02.840 --> 57:03.840
它一开始是空数组

57:03.840 --> 57:04.840
然后它变化了

57:04.840 --> 57:06.840
它一开始也是空数组

57:06.840 --> 57:07.840
都被数据

57:07.840 --> 57:09.840
然后它变化了

57:09.840 --> 57:10.840
于是Wart运行了

57:10.840 --> 57:11.840
对吧

57:11.840 --> 57:12.840
运行了过后

57:12.840 --> 57:14.840
Bars是不是也会跟着变

57:14.840 --> 57:15.840
它首先变成什么了

57:15.840 --> 57:17.840
变成这个样子

57:17.840 --> 57:21.430
对不对

57:21.430 --> 57:23.430
变成这个0

57:23.430 --> 57:24.430
这里也是0

57:24.430 --> 57:26.430
那么接下来要做的事情是

57:26.430 --> 57:27.430
当然如果说

57:27.430 --> 57:28.430
原来就有值

57:28.430 --> 57:29.430
原来有值

57:29.430 --> 57:31.430
原来是10101

57:31.430 --> 57:32.430
然后这里是10

57:32.430 --> 57:35.430
然后现在变化成11400

57:35.430 --> 57:37.430
比方要变化成这个样子

57:37.430 --> 57:38.430
那么这个时候呢

57:38.430 --> 57:40.430
逻辑跟下面的

57:40.430 --> 57:42.430
是一样的

57:42.430 --> 57:46.830
逐渐变化

57:46.830 --> 57:47.830
什么意思

57:47.830 --> 57:49.830
就是要把这个Bars

57:49.830 --> 57:51.830
Value i

57:51.830 --> 57:53.830
逐渐

57:53.830 --> 57:55.830
就终的属性

57:55.830 --> 57:56.830
它一开始没有值

57:56.830 --> 57:57.830
没有值的话给它复制

57:57.830 --> 57:58.830
总归它到了这里

57:58.830 --> 57:59.830
是不是一定有值的

57:59.830 --> 58:00.830
有一个对象了

58:00.830 --> 58:02.830
要把这个对象里边的属性

58:02.830 --> 58:07.830
逐步变化到Bars

58:07.830 --> 58:10.830
Value i

58:10.830 --> 58:11.830
不就要做这么件事吗

58:11.830 --> 58:12.830
你好好看一下

58:12.830 --> 58:14.830
是不是要做这么件事

58:14.830 --> 58:15.830
这点复杂

58:15.830 --> 58:16.830
有点复杂

58:16.830 --> 58:18.830
我已经是精力在讲了

58:19.830 --> 58:20.830
好

58:20.830 --> 58:21.830
然后呢

58:21.830 --> 58:22.830
现在关键是怎么变呢

58:22.830 --> 58:23.830
怎么逐步变化的

58:23.830 --> 58:24.830
你可以自己写函数

58:24.830 --> 58:26.830
也可以用一些第三方库

58:26.830 --> 58:27.830
那么这里呢

58:27.830 --> 58:29.830
我给大家用一个第三方库吧

58:29.830 --> 58:33.140
用个第三方库

58:33.140 --> 58:34.140
用啥库呢

58:34.140 --> 58:35.140
用这个

58:35.140 --> 58:40.140
i叫做G-Sup

58:40.140 --> 58:42.140
这个玩意是专门做这种事情的

58:42.140 --> 58:44.140
它可以把一个元素的属性

58:44.140 --> 58:45.140
来进行变化

58:45.140 --> 58:46.140
也可以变化一个对象

58:46.140 --> 58:47.140
都可以

58:47.140 --> 58:49.140
来看一下这个第三方库

58:49.140 --> 58:52.900
第三方库挺有意思的

58:52.900 --> 58:53.900
好

58:53.900 --> 58:54.900
咱们来看一下

58:54.900 --> 58:55.900
这个第三方库

58:55.900 --> 58:57.900
跟股一无没有任何关系

58:58.900 --> 58:59.900
比方这里倒入

59:00.900 --> 59:01.900
G-Sup

59:01.900 --> 59:02.900
G-Sup

59:02.900 --> 59:03.900
它里边

59:03.900 --> 59:05.900
我就不说它具体的其他用法了

59:05.900 --> 59:06.900
这都不重要

59:06.900 --> 59:07.900
大家可以去摆度一下

59:07.900 --> 59:08.900
就知道了

59:08.900 --> 59:09.900
然后

59:10.900 --> 59:11.900
比方这里一个对象

59:11.900 --> 59:13.900
obj

59:13.900 --> 59:15.900
caught等于0

59:15.900 --> 59:16.900
然后呢

59:16.900 --> 59:17.900
obj

59:17.900 --> 59:19.900
就是要变化这个obj

59:19.900 --> 59:20.900
怎么来变化呢

59:20.900 --> 59:21.900
后面是一些配置

59:21.900 --> 59:24.900
把这个caught变化到100

59:24.900 --> 59:25.900
然后呢

59:25.900 --> 59:26.900
duration

59:26.900 --> 59:27.900
就是我们的变化时间

59:27.900 --> 59:28.900
是一秒钟

59:28.900 --> 59:30.900
把这个obj

59:30.900 --> 59:31.900
两秒钟

59:31.900 --> 59:32.900
三秒钟

59:32.900 --> 59:33.900
三秒钟之内

59:33.900 --> 59:35.900
把这个对象的caught属性

59:35.900 --> 59:36.900
从0变成100

59:36.900 --> 59:39.900
从它原来的值变成新的值100

59:39.900 --> 59:41.900
然后每一次变化

59:41.900 --> 59:42.900
我们这里可以触发一个

59:42.900 --> 59:43.900
update的函数

59:43.900 --> 59:44.900
这个函数

59:44.900 --> 59:45.900
每一次变化的时候

59:45.900 --> 59:46.900
我们输出一下

59:46.900 --> 59:47.900
这个obj

59:47.900 --> 59:48.900
就obj

59:48.900 --> 59:49.900
输出一下

59:49.900 --> 59:50.900
好

59:50.900 --> 59:51.900
保存

59:51.900 --> 59:52.900
你看一下这边

59:52.900 --> 59:53.900
点击右键

59:54.900 --> 59:55.900
发音

59:56.900 --> 59:57.900
看呗

59:57.900 --> 59:59.900
是不是3秒钟完成变化

59:59.900 --> 01:00:01.900
对不对

01:00:01.900 --> 01:00:02.900
那么跟这里的需求

01:00:02.900 --> 01:00:03.900
是不是一样的

01:00:03.900 --> 01:00:04.900
跟这边的需求

01:00:04.900 --> 01:00:05.900
是不是一样的

01:00:05.900 --> 01:00:07.900
我要把这个对象

01:00:07.900 --> 01:00:08.900
它的值

01:00:08.900 --> 01:00:09.900
逐渐变化成

01:00:09.900 --> 01:00:10.900
这个对象的值

01:00:10.900 --> 01:00:11.900
对不对

01:00:11.900 --> 01:00:12.900
要怎么弄

01:00:13.900 --> 01:00:14.900
倒入进来

01:00:14.900 --> 01:00:15.900
倒入进来

01:00:15.900 --> 01:00:21.860
好

01:00:21.860 --> 01:00:22.860
然后呢

01:00:22.860 --> 01:00:34.140
这个台湾拿过来

01:00:34.140 --> 01:00:35.140
变化

01:00:35.140 --> 01:00:36.140
变化谁

01:00:36.140 --> 01:00:37.140
变化 false

01:00:37.140 --> 01:00:38.140
因为它都是响应数数去吧

01:00:38.140 --> 01:00:39.140
现在5u3里面响应数

01:00:39.140 --> 01:00:41.140
全是深度的响应数

01:00:41.140 --> 01:00:43.140
无论你套多少层都是响应数

01:00:43.140 --> 01:00:44.140
把这个对象

01:00:45.140 --> 01:00:46.140
响应数对象

01:00:46.140 --> 01:00:47.140
它的属性

01:00:48.140 --> 01:00:49.140
变成什么

01:00:49.140 --> 01:00:51.140
变成了变成这个样子

01:00:51.140 --> 01:00:52.140
变成展开

01:00:52.140 --> 01:00:53.140
bar

01:00:53.140 --> 01:00:54.140
pocket

01:00:54.140 --> 01:00:55.140
value

01:00:55.140 --> 01:00:56.140
对吧

01:00:56.140 --> 01:00:57.140
变成这个对象的属性

01:00:57.140 --> 01:00:58.140
然后呢

01:00:58.140 --> 01:01:00.140
再配置一个delete

01:01:00.140 --> 01:01:02.140
delete是一秒钟

01:01:03.140 --> 01:01:04.140
一秒钟之内

01:01:04.140 --> 01:01:05.140
把这个对象的这些属性

01:01:05.140 --> 01:01:06.140
变成这个玩意

01:01:07.140 --> 01:01:09.140
就是要做这么一件事

01:01:09.140 --> 01:01:10.140
好

01:01:10.140 --> 01:01:13.470
来看一下吧

01:01:13.470 --> 01:01:14.470
刷新

01:01:14.470 --> 01:01:15.470
你看

01:01:15.470 --> 01:01:16.470
是不是有变化了

01:01:16.470 --> 01:01:17.470
然后美国

01:01:17.470 --> 01:01:18.470
这里一改

01:01:18.470 --> 01:01:19.470
这里一改了过后

01:01:19.470 --> 01:01:21.470
topic是不改了

01:01:21.470 --> 01:01:22.470
topic改了过后

01:01:22.470 --> 01:01:23.470
忘记是不是运行了

01:01:23.470 --> 01:01:24.470
运行是不是重新变化

01:01:24.470 --> 01:01:25.470
对吧

01:01:26.470 --> 01:01:27.470
24

01:01:28.470 --> 01:01:29.470
就这么个意思

01:01:31.470 --> 01:01:32.470
那么注意啊

01:01:32.470 --> 01:01:33.470
我们一看一下

01:01:33.470 --> 01:01:34.470
我们整个这个函数

01:01:34.470 --> 01:01:35.470
整个这个函数

01:01:35.470 --> 01:01:37.470
有没有关心界面

01:01:37.470 --> 01:01:39.470
它完全没有关心界面

01:01:39.470 --> 01:01:41.470
都是算的逻辑

01:01:41.470 --> 01:01:43.470
全部算的是数据逻辑

01:01:43.470 --> 01:01:44.470
看没

01:01:44.470 --> 01:01:46.470
整个过程全是数据逻辑

01:01:46.470 --> 01:01:47.470
就是它研究的是

01:01:47.470 --> 01:01:48.470
我这个数据

01:01:48.470 --> 01:01:49.470
目前的数据有这两个数据

01:01:49.470 --> 01:01:50.470
我如何通过这两个数据

01:01:50.470 --> 01:01:52.470
来计算出这些数据

01:01:52.470 --> 01:01:53.470
那么就如何来进行

01:01:53.470 --> 01:01:55.470
逐渐的变化

01:01:55.470 --> 01:01:56.470
而且这些数据

01:01:56.470 --> 01:01:57.470
全是想意识的

01:01:57.470 --> 01:01:58.470
最后把这个想意识

01:01:58.470 --> 01:01:59.470
扔过去

01:01:59.470 --> 01:02:00.470
那么这个想意识

01:02:00.470 --> 01:02:02.470
数据内部如何来变化

01:02:02.470 --> 01:02:03.470
它已经全部完成了

01:02:03.470 --> 01:02:05.470
这个功能抽离出去了

01:02:05.470 --> 01:02:06.470
那么这个功能抽离

01:02:06.470 --> 01:02:08.470
抽出了过程的这个82

01:02:08.470 --> 01:02:10.470
你会发现它怎样简单

01:02:10.470 --> 01:02:11.470
非常非常简单

01:02:11.470 --> 01:02:12.470
你看吧

01:02:12.470 --> 01:02:13.470
81

01:02:13.470 --> 01:02:17.640
81复制过来

01:02:17.640 --> 01:02:18.640
复制过来

01:02:18.640 --> 01:02:21.340
就完了

01:02:21.340 --> 01:02:22.340
就没了

01:02:22.340 --> 01:02:24.340
82就没了

01:02:24.340 --> 01:02:27.780
你看一下82

01:02:27.780 --> 01:02:29.780
我写错了吗

01:02:29.780 --> 01:02:31.780
这里写个600

01:02:31.780 --> 01:02:35.280
保存

01:02:35.280 --> 01:02:37.280
82好像有问题

01:02:37.280 --> 01:02:41.380
检查

01:02:41.380 --> 01:02:42.380
82这边还没写

01:02:42.380 --> 01:02:43.380
这边还没写

01:02:43.380 --> 01:02:44.380
写个微波

01:02:44.380 --> 01:02:46.380
Item in GDP

01:02:46.380 --> 01:02:48.380
Key

01:02:48.380 --> 01:02:50.380
Item country

01:02:50.380 --> 01:02:52.380
这里是

01:02:52.380 --> 01:02:54.380
Country

01:02:54.380 --> 01:02:56.380
Country

01:02:56.380 --> 01:02:57.380
这里是Value

01:02:57.380 --> 01:03:01.140
这边是一样的

01:03:01.140 --> 01:03:03.140
Style是一样的

01:03:03.140 --> 01:03:11.490
这里是Item color

01:03:11.490 --> 01:03:14.490
这里是

01:03:14.490 --> 01:03:16.490
Item size

01:03:16.490 --> 01:03:17.490
拼接上

01:03:17.490 --> 01:03:19.490
拼接上

01:03:19.490 --> 01:03:21.490
刷新

01:03:21.490 --> 01:03:23.490
有问题

01:03:23.490 --> 01:03:26.490
应该是这

01:03:26.490 --> 01:03:30.120
82

01:03:30.120 --> 01:03:31.120
就出来了

01:03:31.120 --> 01:03:33.120
这就是这么一个效果

01:03:33.120 --> 01:03:35.120
其实这个效果

01:03:35.120 --> 01:03:37.120
也没有什么多少新知识

01:03:37.120 --> 01:03:39.120
主要是给大家看一下

01:03:39.120 --> 01:03:40.120
有的时候

01:03:40.120 --> 01:03:41.120
在Completion API里面

01:03:41.120 --> 01:03:42.120
可能要根据

01:03:42.120 --> 01:03:43.120
主要是在这

01:03:43.120 --> 01:03:45.120
根据属性来进行

01:03:45.120 --> 01:03:47.120
某种依赖的话

01:03:47.120 --> 01:03:48.120
就有些小英识数据

01:03:48.120 --> 01:03:49.120
是依赖某个属性的话

01:03:49.120 --> 01:03:51.120
应该怎么去处理

01:03:51.120 --> 01:03:52.120
你不能说

01:03:52.120 --> 01:03:53.120
你直接把属性

01:03:53.120 --> 01:03:55.120
读出来传过去

01:03:55.120 --> 01:03:56.120
那么这样子

01:03:56.120 --> 01:03:58.120
就会失去对属性的依赖

01:03:58.120 --> 01:04:00.120
它是依赖属性中的

01:04:00.120 --> 01:04:01.120
某一个职责

01:04:01.120 --> 01:04:02.120
相当于是

01:04:02.120 --> 01:04:04.120
你把解构出来了

01:04:04.120 --> 01:04:05.120
相当于是在这里

01:04:05.120 --> 01:04:06.120
把解构出来

01:04:06.120 --> 01:04:08.120
直接传过去

01:04:08.120 --> 01:04:09.120
这样子肯定要出问题的

01:04:09.120 --> 01:04:10.120
你不能这样做的

01:04:10.120 --> 01:04:11.120
你就这样想

01:04:11.120 --> 01:04:12.120
把你解构出来

01:04:12.120 --> 01:04:13.120
那万一是

01:04:13.120 --> 01:04:14.120
它是一个制服串的

01:04:14.120 --> 01:04:15.120
它是一个数字呢

01:04:15.120 --> 01:04:16.120
你解构出来

01:04:16.120 --> 01:04:17.120
不就是一个存数字

01:04:17.120 --> 01:04:18.120
一个存制服串的吗

01:04:18.120 --> 01:04:19.120
它就没有想用识了

01:04:19.120 --> 01:04:20.120
那么这个地方

01:04:20.120 --> 01:04:21.120
应该怎么来处理

01:04:21.120 --> 01:04:22.120
可以用这种方式来处理

01:04:23.120 --> 01:04:25.120
或者其实也可以用这个

01:04:25.120 --> 01:04:27.120
用那个toRef

01:04:28.120 --> 01:04:29.120
toRef

01:04:29.120 --> 01:04:30.120
对吧

01:04:30.120 --> 01:04:31.120
toRef

01:04:31.120 --> 01:04:34.820
用这个还是来处理

01:04:34.820 --> 01:04:35.820
把哪个对象

01:04:35.820 --> 01:04:37.820
把这个props对象

01:04:37.820 --> 01:04:38.820
哪个属性呢

01:04:38.820 --> 01:04:40.820
那个GDP这个属性

01:04:40.820 --> 01:04:41.820
变成什么呢

01:04:41.820 --> 01:04:42.820
变成一个Ref

01:04:42.820 --> 01:04:44.820
放过去

01:04:44.820 --> 01:04:45.820
对不对

01:04:45.820 --> 01:04:46.820
过来我们直接在这里写

01:04:46.820 --> 01:04:48.820
这样子也可以

01:04:48.820 --> 01:04:49.820
看一下吧

01:04:49.820 --> 01:04:50.820
刷新

01:04:50.820 --> 01:04:51.820
是不是也是一样的

01:04:51.820 --> 01:04:52.820
也是可以的

01:04:56.820 --> 01:04:57.820
好

01:04:57.820 --> 01:04:58.820
这就是这一颗东西

01:04:58.820 --> 01:04:59.820
还是把这个一样的

01:04:59.820 --> 01:05:00.820
把这个效果做一下

01:05:00.820 --> 01:05:01.820
这个效果可能会

01:05:01.820 --> 01:05:02.820
一开始做的话

01:05:02.820 --> 01:05:03.820
有点不适应

01:05:03.820 --> 01:05:05.820
就特别是属性这一块

01:05:05.820 --> 01:05:06.820
有点搞不清楚

01:05:06.820 --> 01:05:07.820
好好去梳理一下

01:05:07.820 --> 01:05:08.820
因为这个地方呢

01:05:08.820 --> 01:05:09.820
有的时候遇到了

01:05:09.820 --> 01:05:10.820
你还挺麻烦的

01:05:10.820 --> 01:05:11.820
你不清楚的话

01:05:11.820 --> 01:05:12.820
还是挺麻烦的

01:05:12.820 --> 01:05:13.820
好

01:05:13.820 --> 01:05:14.820
这就是这一颗

01:05:14.820 --> 01:05:15.820
把comperation API

01:05:15.820 --> 01:05:16.820
就全部讲完了

