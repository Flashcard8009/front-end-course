WEBVTT

00:00.300 --> 00:06.220
好 截至目前呢 咱们对无忧3的绝大部分变动啊 都基本上就讲过了

00:07.020 --> 00:10.900
呃 剩下的一个方式 一个东西呢 就是关于共享数据的

00:11.420 --> 00:16.460
因为我们知道在无忧2里面 我们使用共享数据一般使用啥呀 一般使用无忧

00:16.740 --> 00:18.140
无忧x 对吧 无忧x

00:19.020 --> 00:20.620
呃 使用无忧x呢

00:21.620 --> 00:24.020
倒是处理共享数据没啥问题啊

00:24.980 --> 00:28.460
但是呢 在以前无忧2的时候啊 用无忧x这种方案呢

00:29.260 --> 00:33.820
有的时候呢 特别是在一些中小项目的时候 会显得稍险笨重

00:34.620 --> 00:35.420
因为它毕竟

00:36.740 --> 00:39.380
编写起来比较复杂 对吧 要什么action

00:40.020 --> 00:41.020
还有什么martation

00:41.580 --> 00:49.180
还有什么还有getter 对吧 这些东西 编写的呢 会稍险有些复杂 而且他这个库呢 本身他也没有那么轻量了

00:50.220 --> 00:56.860
在无忧3之后呢 由于他把那个享用式API啊 完全的脱离组建了

00:57.340 --> 01:03.300
所以说在无忧3里边呢 做共享数据会多了一些方案 甚至网上有一些帖子说

01:03.820 --> 01:07.460
有了无忧3之后呢 无忧x呢就好像完全被淘汰了

01:08.220 --> 01:12.660
其实我个人觉得还不能这样说吧 因为无忧x呢他也有一些自己

01:14.100 --> 01:14.980
不可替代的地方

01:15.700 --> 01:21.060
但是呢 我们毕竟到了无忧3过后呢 我们有了多种方案来实现共享数据

01:21.380 --> 01:24.780
其实无忧2的时候也有一些方案啊 当时官方稳当里面也说到了

01:25.180 --> 01:28.060
如果说一些简单的系统的话 你完全没有必要使用无忧x

01:28.900 --> 01:34.300
咱们来看一下无忧3里边吧 我们无忧3里边实现共享数据呢 有哪些方案

01:34.740 --> 01:39.300
我这里呢给大家列举了三种方案 其实你们将来到公司里边

01:40.140 --> 01:42.700
是不是在三种方案选一呢 也不一定

01:43.660 --> 01:44.060
啊 因为他

01:44.700 --> 01:49.940
极度的灵活 就是如果说你不使用无忧x的话 那么他的共享数据方案极度的灵活

01:50.380 --> 01:55.860
你可以这样写也可以那样子写 完全由你自己控制 因为他响应式系统一分开 很多东西

01:56.540 --> 02:05.260
写起来呢 就是千变万化了 我这里呢列举了三种方案的 除了无忧x之外呢 另外两种呢 就是我个人觉得啊

02:05.860 --> 02:12.060
可能呢 你将来那里面到公司呢 可能会遇到这两种方案 但将来具体会遇到什么样的方案 我也说不准

02:12.980 --> 02:15.620
那么具体的公司呢 有具体的规范啊

02:16.500 --> 02:23.780
我们一个个来 首先是vx 那么这个东西呢 要适应vv3的话 你需要安装vx的新版本 也就是

02:24.460 --> 02:30.980
是这个版本 好 我们今天呢 我们无论是哪一种方案啊 我们实现的效果呢 都是一样的 就这个效果

02:31.620 --> 02:36.020
打开看一下啊 np 安装

02:37.380 --> 02:38.980
一个非常非常简单的效果

02:40.740 --> 02:42.300
一个home 啊 首页

02:43.260 --> 02:44.060
一个登录业

02:45.060 --> 02:48.460
哎 然后我们登录啊 登录了帐号密码了 我这个全是魔力的啊

02:49.340 --> 02:57.620
实际上没有跟服务器打交互 没有跟服务器有交互 我们只是一个魔力 而这边123123啊 一回车登录

02:58.620 --> 03:04.380
对 这就是个共享数据的方案 因为共享数据的话 往往发生在这个全局的登录用户上

03:04.900 --> 03:08.780
啊 如果说我们刷新页面的话 那么这里呢会还原这个登录的

03:09.740 --> 03:13.540
情况恢复的登录 这能不能可以点退出 然后退出登录

03:14.380 --> 03:18.980
啊 就这么一个场景啊 非常简单的一个效果 我们用三种方案分别去实现一下

03:19.940 --> 03:23.300
然后呢 我们首先看一下地懂方案 就是使用vux

03:24.780 --> 03:25.860
在这啊 这是一个

03:27.340 --> 03:30.980
除了共享数据之外 其他地方都写好的一个工程 好 咱们把它

03:31.660 --> 03:35.140
先不着急运行啊 首先我们看一下 运行出来吧 先看一下这个工程

03:37.550 --> 03:41.310
运行出来 看一下这个工程 这个工程里面呢 就是用了vux

03:42.430 --> 03:47.670
看一下吧 我们看一下这里面带嘛 没点街市 没什么好说的啊 使用了一个vux

03:47.670 --> 03:49.910
router 那个router里面呢 我们看一下router里面

03:51.190 --> 03:56.590
就创建一个router吧 之前讲过了对不对 然后呢路由配置这一块呢 有两个页面

03:57.350 --> 04:02.950
首页是这个组件啊 我这里没有用异部组件啊 要用异部组件也可以 那么这里呢

04:02.990 --> 04:08.950
login的登录页呢 是这个组件 在哪呢 在这个vux在这里边 一个home组件

04:10.030 --> 04:11.030
有一个登录组件

04:12.070 --> 04:19.270
登录组件我们里边看一下啊 慢慢看一下 央视这些东西不用看了啊 账号 账号呢 绑定一个享应数数据

04:21.790 --> 04:26.350
是不是享应数数据 对吧 密码绑定一个享应数数据login password

04:27.350 --> 04:31.950
好 其他的一个一个按钮啊 这个按钮呢

04:32.710 --> 04:40.830
为什么我这样子写呢 因为这个按钮呢 将来呢 正在登录中的时候呢 他这个是不能用的啊 要把这个东西设为去 那么目前呢 我这里功能还没有做

04:41.710 --> 04:46.230
如果说是不能用的 如果说目前正在登录中 要有防止重复提交嘛

04:46.830 --> 04:54.070
如果正在登录中呢 那个这个按钮的文字呢 显示login 如果是不在登录中呢 显示登录两个字啊 你看一下这边

04:55.070 --> 04:57.470
登录 注意看这个按钮的文字啊

04:59.230 --> 05:05.270
你看 这里有这么一个效果啊 只不过呢 我目前是把写实的啊 将来呢 这个地方呢 要换成一个动态的数据

05:06.150 --> 05:13.270
好 这登录页面 对吧 没问题吧 非常简单啊 然后呢 我们这里store这个文件夹是空的

05:13.990 --> 05:18.590
哦 这个 这个文件夹还有东西啊 我们一会再说 有这么一个有这么一个文件夹API

05:19.590 --> 05:25.830
这个是不是要跟服务器交互 对吧 我们登录要设计到服务器嘛 不过呢 我这里没有服务器啊 所以说我这里

05:26.390 --> 05:28.670
做了一个简单的模拟 你看一下 我们的

05:29.230 --> 05:36.030
做了一个模拟啊 首先我写了个辅助函数啊 模拟嘛 就是延迟一段时间 这个函数已经见了很多次了啊 不用再重复的说了

05:36.790 --> 05:44.590
啊 简单为写了三个方法 一个login 登录 你给我传一个账号 一个传一个密码 然后来登录 那么这里边全是模拟的啊 全是假的

05:45.150 --> 05:49.590
真正的 真正的情况了 将来你要把这个地方替换到 替换掉 就是你要把他

05:50.230 --> 05:55.950
发送到服务器 对吧 让服务器来判断到底有没有登录成功 我这里就简单的做了一下 只要账号等于

05:56.550 --> 06:05.230
密码等于123123啊 先延迟一秒钟 然后呢 账号等于这个密码等于这个 那么我就认为登录成功了 登录成功了 我就给你勾兼一个用户对象啊

06:06.430 --> 06:12.990
login id 用户的名字呢 是管理员 好 我就把它保存到 保存到哪呢 local storage 里面

06:13.950 --> 06:22.670
这个没问题吧 其实这就模拟什么呢 模拟服务器那边登录成功过后给你发一个cookie 对不对 那么你这边把保存到cookie里面 我这把保存到

06:22.670 --> 06:25.870
login storage 啊一样的道理 最后把这个用户对象返回

06:26.910 --> 06:34.030
如果说没有登录成功的话 我就返回啦 对吧 将来我这就全是模拟的啊 将来跟真正的情况了 要跟服务器去交互

06:34.750 --> 06:41.950
好 登出的话 我这里呢 就模拟了一下 延迟一秒钟啊 然后呢 我这里把这个login storage移除

06:42.910 --> 06:48.590
啊 然后互玩慢 我们登录场景不就是这么几个三个吗 最核心的就这么三个

06:49.230 --> 06:54.510
啊 就是说我已经登录过了 已经登录过了 下一次在刷新页面的时候呢 我要恢复这个登录

06:55.150 --> 07:02.190
那我不需要再重新登录了 那怎么办呢 我这里就是延迟一秒钟啊 当然这个东西一般是服务器发送请求的

07:02.670 --> 07:05.070
好 延迟一秒钟 延迟一秒钟过后呢 这边

07:06.030 --> 07:17.790
给财腾啊 就是从login storage里边拿到这个用户啊 看一下有没有登之前登入过的 好 登入过的话 那么我就如果登入成功了 我就把它解析出来 返回就行了

07:18.350 --> 07:25.070
啊 否则的话 如果说没有登入过的话 我就返回来了 好 看一下啊 这三个很说非常简单 就模拟一下 好 这是API

07:26.910 --> 07:34.110
那么这个工程里边就差一个工厂数据了 对吧 其他都都已经完成了 就差一个工厂数据了 那么这个app.viu里边很简单啊 有个home

07:35.550 --> 07:38.390
就是菜单 有个home 连接到这儿

07:39.470 --> 07:44.630
然后呢 后边呢 有几种情况 如果说现在正在登录中 那么他就应该显示login

07:45.430 --> 07:49.270
目前呢 我这里是写实的啊 将来会替换掉 正在登录中我要显示login

07:50.030 --> 08:01.270
如果说没有正在登录中 那就我就看一下你登录没有 如果说你已经登录过了 我就给你显示一个用户名 显示一个A元素啊 退出点接元素 还有时间啊 我将来会来做这个时间

08:01.990 --> 08:14.190
如果说你现在 现在没有在登录中 同时呢 又没有登录成功啊 目前没有登录 那么我就显示一个菜单啊 连接挑转到登录页面 对吧 就几种情况 非常简单 你没有什么代码

08:16.190 --> 08:24.910
好 再看一下这个文件讲 这个文件讲就是我们以前学习viu2的时候 学习了个viux 对吧 那个viux里边

08:25.910 --> 08:27.430
启动一个数据模块

08:28.710 --> 08:30.470
跟过去的写法是一看完全一样的

08:31.790 --> 08:34.110
开启命名空间 默认的状态

08:34.910 --> 08:41.230
当前的登录 当前登录的用户闹 默认为闹 当前是否在登录中 默认为force

08:42.230 --> 08:45.550
那么数据的变化有两种 一种是设置当前登录的用户

08:47.110 --> 08:49.790
一种是设置当前是否在登录中

08:50.790 --> 08:59.950
你看这个代码很好理解 对吧 那么有副作用的操作呢 有三个 一个是登录 登录的时候呢 你给我一个登录id 啊 账号密码

09:00.990 --> 09:06.470
我先呢 把它设置为正在登录中 然后呢 调用APN里边的方法罗品去登录

09:07.510 --> 09:13.070
拿到结果啊 不管你是登录成功还是登录失败啊 我就去设置拿到的结果

09:13.750 --> 09:16.790
成功的话就是用户对象 失败的话就是那

09:17.590 --> 09:22.150
然后再把了正在登录中设置为force 非常简单的吧 然后呢 登出

09:23.190 --> 09:33.390
就注销 注销的话也是一样 先设置这个楼顶啊 然后呢 调用这个APN里面的注销 注销 然后管了过后再把设置为脑 再把楼顶设置为force

09:34.550 --> 09:43.590
户外卖也是一样 设置楼顶 然后呢 调用这个户外卖得到一个用户啊 甭管是有没有登录 把设置进去 然后呢 把楼顶设为force

09:44.590 --> 09:45.350
那非常简单

09:46.950 --> 09:51.310
好 那么一个来啊 我们现在有了这个数据模块之后 在viu3里边

09:52.350 --> 09:55.030
如何来创建一个仓库呢

09:56.310 --> 10:01.990
哎 viu3创建仓库了会有一些稍许的变化啊 首先我们安装一下这个viux

10:03.270 --> 10:03.710
安装一下

10:04.750 --> 10:05.030
停止

10:06.230 --> 10:13.310
在viu3里边呢 安装viux呢 你要安装住它的最新版本啊 目前呢 这个viux呢 还在beta版本啊 还没有完全定下来

10:13.830 --> 10:16.710
那么目前我们这里安装的时候呢 也需要安装这个viux

10:17.790 --> 10:18.150
next

10:19.270 --> 10:20.070
好 安装一下

10:21.590 --> 10:23.870
好 安装完了啊 现在我们再启动起来

10:24.950 --> 10:25.590
装的

10:27.350 --> 10:29.670
启动起来 好 启动起来之后呢

10:30.790 --> 10:36.470
我们这里要需要创建仓库了 过去是不是这样做的 对吧 然后仓库里边有多个数据模块 然后这里只有一个

10:36.990 --> 10:39.510
那么最后呢 我们要写个音那个时候的ts

10:40.390 --> 10:46.230
把这个仓库呢 导出去 对吧 把所有的数据模块加加进来 导出去 那么这里我们先加在这个数据模块啊

10:49.510 --> 10:50.070
老给你用的

10:50.830 --> 10:53.430
好 以前咋做的 以前是要导入这个viux啊

10:54.030 --> 10:54.430
viux

10:54.950 --> 10:56.350
是吧 怎么viux

10:57.030 --> 11:04.270
但是不好意思 现在这个构造函数没了啊 这个构造函数已经没了 现在跟那个viu3一样 跟那个viurouter一样

11:04.790 --> 11:11.230
你要用居民导出的函数来创建一个仓库 叫什么居民导出函数呢 叫create log

11:12.550 --> 11:13.150
你要使用它

11:14.030 --> 11:20.710
来创建这么一个仓库 那么什么来创建啊 不是create log啊 是create store

11:21.270 --> 11:23.990
要使用这个函数来创建一个仓库 来吧 来创建

11:24.550 --> 11:33.190
创建一个仓库 那么这里边有些配置啊 配置的方式呢 跟以前 跟以前那个viux 这里的配置是一样的

11:33.750 --> 11:34.230
是一样的

11:34.710 --> 11:41.670
懂了吧 那么这里我要怎么配置呢 就是modules 对吧 模块有哪些模块呢 我这里只有一个模块啊 挪紧由这

11:42.190 --> 11:43.190
对吧 就创建了一个仓库

11:44.070 --> 11:48.990
是不是非常简单 那么把这个仓库导出就完事了 export default导出就完事了

11:50.150 --> 11:54.310
这就是创建一个仓库 那么创建了仓库之后以前咋做的 是不是要在

11:55.590 --> 12:02.350
创建viu应用程序的时候 要去使用这个仓库啊 对不对 使用插件嘛 那么现在的使用方式呢

12:02.830 --> 12:09.030
要就在这 使用使动 把使动导入进来

12:10.510 --> 12:10.990
使动

12:11.950 --> 12:14.750
是吧 导入这个使动

12:16.150 --> 12:17.750
啊 就ok的啊 导入进来

12:19.790 --> 12:23.670
就写完了 那么这样子的仓库就到了这个viu工程里边去了

12:24.510 --> 12:26.830
是吧 它会影响到这个viu应用

12:27.710 --> 12:36.510
那么现在呢 我们现在关心的是 有了这个仓库应用进去过后呢 我们在浏览器里边是否能够像过去的样子啊

12:37.070 --> 12:39.790
通过调试工具 能够看到这个仓库呢

12:42.670 --> 12:43.310
说小一点啊

12:44.670 --> 12:52.750
啊 是这样子啊 目前呢 viu删出来过后呢 它就目前这个时间点啊 我讲课这个时间点 它的调试工具啊 就是viu dev tools

12:53.070 --> 12:59.950
这个玩意呢 它还目前还是个beta版本啊 功能还极其的弱 里边还没有集成viu x

13:00.670 --> 13:06.990
所以说呢 如果说你用以前的那个调试工具 viu2的调试工具 你是是调试不了的啊 你是打不开的

13:07.310 --> 13:11.630
那你必须要安装那个最新版本的dev tools 那么在哪里安装呢 在这

13:12.590 --> 13:19.630
呃 谷歌热烂器得先在科学上网啊 谷歌热烂器里边有一个有一个扩展程序 然后点击

13:22.910 --> 13:31.300
这个啊 网上商店啊 网上商店进去过后呢 去搜一下这个dev tools

13:33.570 --> 13:36.210
dev tools 你再把viu2的这个dev tools先卸载掉

13:38.930 --> 13:42.210
viu dev tools

13:43.730 --> 13:49.140
去搜一下啊 说一下过后呢 你看这里有两个的吧 这是viu2的

13:49.860 --> 13:54.100
啊 就目前正式正式版本啊 但是呢 viu3 它是调试不了的

13:54.500 --> 13:58.100
那么上面这个beta版本呢 它是viu3的 能够适用viu3

13:58.820 --> 14:04.100
对吧 你把这个安装一下 但是这个网上呢 里边还没有去能够集成那个viux啊

14:05.220 --> 14:12.100
还在等一等啊 可能要等一段时间 至少得等viux 它正式发布吧 还要等这些工具啊 这些玩具要跟上

14:12.820 --> 14:18.500
好了 那么现在呢 我们看一下这个viu3的调试工具啊 进去看 他只能看到一个组件 组件结构

14:19.220 --> 14:22.660
每一个组件他的结构啊 里边呢有一些

14:23.460 --> 14:28.020
呃 什么比方logging这个组件啊logging这个页面的组件 那么他这个setup呢 他是能看到的

14:28.820 --> 14:30.100
他是什么类型啊 一个rave

14:30.900 --> 14:36.500
对吧 setup他返回的东西 但是呢你那个viux的东西也看不到了啊 目前是看不到的

14:37.140 --> 14:42.100
是这么一个情况啊 所以说viux呢 目前呢你是不是很好调试的啊 不是很好调试

14:43.460 --> 14:47.460
但是呢 你安装了viux的过后呢 你会发现空置还给输出了这么一些东西

14:47.940 --> 14:53.220
呃 所以说目前在beta版本呢 这个调试 这个这个玩意啊 是这个调试工具给你输出的

14:53.780 --> 14:56.740
这是个调试工具给你输出的 那没有办法啊 他正在

14:57.140 --> 15:03.300
这个调试工具还没有开发完啊 正在开发中 他目前在做了一些测试啊 这个玩意啊 你不用去管他吧 你不去买他

15:04.980 --> 15:08.100
好 这是关于这一块啊

15:10.340 --> 15:14.180
好 这关于这一块 好 那么使用了这个仓库之后呢 我们这里

15:14.820 --> 15:16.340
一开始要干嘛呀

15:16.580 --> 15:22.420
一开始按照我们过去的做法 是不是要得雕容一次忽然卖 对不对 是不是得触发一次忽然卖

15:23.140 --> 15:23.780
没跑到去了

15:25.620 --> 15:27.540
触发一次忽然卖 因为一面一开始

15:28.020 --> 15:32.500
夹仔过后 我就要恢复他的登录状态 对不对 是不是一开始去触发一下他

15:32.820 --> 15:36.740
来吧 我来触发一下 怎么触发的非常简单 跟过去一样的啊dsp

15:37.140 --> 15:37.860
触发X吗

15:38.660 --> 15:43.540
logging user啊 什么who am i

15:44.740 --> 15:45.860
对触发一下多少

15:46.900 --> 15:53.140
啊 保存 但这里看不到什么效果啊 看不到什么效果 总之触发了 那如果说你现在没有没有这个调词工具啊

15:53.620 --> 15:57.220
呃 你看不到每一次状态的变化 那你可以沾持这样子吧

15:57.860 --> 16:04.420
暂时在仓库里边呢 因为我们知道啊 在viewx里边呢 他可以可以使用一些插件的啊 比方说我们使用这个插件可以是logger

16:04.900 --> 16:06.820
我们在这里配置一下啊 plugins

16:07.780 --> 16:10.580
插件 我们配置一个插件啊可以是logger

16:11.540 --> 16:12.340
创建一个

16:14.260 --> 16:18.260
日子 好 那么这样子呢 到处可以在控制台里面看 稍微看一下

16:20.340 --> 16:24.740
那你看 控制台里边还告诉你 你触发了这个x logging user who am i

16:25.060 --> 16:26.260
对吧 呃

16:27.380 --> 16:28.580
payloader为undefined

16:29.140 --> 16:34.180
内容是这个 触发这个x 然后呢 x里边呢 他去触发了multiation

16:35.060 --> 16:39.060
首先把这个loading啊设作一举 对不对 首先把这个loading设作一举

16:39.780 --> 16:42.420
然后呢 再去设置这个互安卖 这是user

16:42.660 --> 16:43.380
这是user呢

16:44.420 --> 16:46.100
logging user 呃 user为now

16:47.220 --> 16:53.860
然后呢 再去设置loading loading为force 对吧 还会发生这么一些状态变化啊 你可以暂时先用这个方式来调试一下

16:55.460 --> 16:56.660
好了 这是关于

16:57.700 --> 17:03.060
viewx啊 怎么来安装 安装到现在的view3里边去 那么现在我们就开始实现它的功能了啊

17:03.460 --> 17:06.180
首先到这边来logging这边来吧

17:06.740 --> 17:07.140
登录

17:07.860 --> 17:11.620
登录这一块的话 我们来想一想啊 在viewx里边

17:13.920 --> 17:14.480
我们这里

17:15.840 --> 17:21.360
点击这个按钮之后 或者这个风表单提交的时候 提交这个风表单的时候

17:21.920 --> 17:24.800
是不是要完成登录啊 那么这里呢 我们是不是要导出一个函数

17:26.560 --> 17:27.840
handle submit

17:28.640 --> 17:30.080
有这么一个函数啊 导出

17:30.800 --> 17:32.960
啊 当然可以让 这是一个异部函数

17:33.200 --> 17:34.720
因为我们要做一些异部处理

17:35.280 --> 17:36.560
好 那么这里呢 我们可以

17:37.360 --> 17:37.920
submit

17:39.760 --> 17:40.800
组织它的默认行为

17:42.160 --> 17:44.640
然后调一个函数啊 handle submit

17:45.120 --> 17:48.240
当然我这 因为要调这个函数 所以说得把这个函数发过来

17:48.880 --> 17:52.000
是吧 我们写这么一个函数 那么这个函数里边做啥呢

17:52.800 --> 17:55.280
这个函数里边做啥 无非就是去触发

17:55.840 --> 17:56.880
仓库里边的I个型

17:57.840 --> 17:59.680
哪个I个型 这不触发这个I个型logging

18:00.240 --> 18:01.440
对吧 那怎么来触发

18:02.160 --> 18:05.440
我们现在 以前要触发怎么触发 是不是用this storm

18:05.680 --> 18:07.840
so this part对吧 但是不好意思

18:08.080 --> 18:12.400
你现在仍然可以用啊 在其他的配置就是option api里边 仍然可以使用这种方式

18:12.800 --> 18:13.440
但是呢

18:13.840 --> 18:14.400
在

18:14.640 --> 18:16.960
comparation api里边 你是说没有这次了

18:17.360 --> 18:19.040
这时候已经没了 那怎么办呢

18:19.520 --> 18:20.800
他给你使用了这种方式

18:22.320 --> 18:26.320
在wix里边呢 给你导出了一个函数叫做use storm

18:27.600 --> 18:28.320
使用仓库

18:29.280 --> 18:31.600
这个函数有什么用呢 就给你返回一个仓库对象

18:32.080 --> 18:34.160
所以说你这里能可以拿到这个仓库 a storm

18:36.160 --> 18:37.840
拿这个 从我这个use storm

18:38.560 --> 18:41.920
拿这个仓库对象 那么这边呢 就不是这一次了啊 就直接试试动

18:42.240 --> 18:42.720
dispatch

18:43.200 --> 18:46.240
触发什么I个型的 触发logging user

18:48.240 --> 18:49.680
就是logging这个I个型

18:50.960 --> 18:52.480
payload了呢 payload了就是一个对象呢

18:52.880 --> 18:55.120
对象里边两个属性 一个是logging id

18:55.440 --> 18:56.640
对吧logging id呢 用什么呢

18:56.960 --> 18:59.680
等于目前的logging id 点by就不要忘记了 它是个rid

19:00.720 --> 19:02.400
然后logging password

19:03.840 --> 19:05.440
logging password

19:07.040 --> 19:08.320
对吧就dispatch一下

19:09.200 --> 19:13.200
那么这个dispatch呢 我们知道啊 它 wix等待它 它会返回一个结果

19:14.320 --> 19:16.320
你看这个dispatch是不是会返回一个结果

19:16.880 --> 19:18.960
返回一个用户 登录成功了就返回load

19:18.960 --> 19:21.600
就是一个用户对象 登录失败就返回load

19:21.680 --> 19:23.280
那么我们可以判断一下这个user

19:23.280 --> 19:25.280
是有没有值 有值的话是登录成功

19:25.760 --> 19:29.840
登录成功怎么办呢 登录成功我就挑转到那个首页吧

19:30.240 --> 19:33.040
那这里需要挑转 挑转的话那么就顺便说一下

19:33.040 --> 19:36.640
Rotor里边在completion API里边怎么挑转

19:36.640 --> 19:39.280
以前打挑转的是不是zrotor

19:39.280 --> 19:41.120
但是不好意思 这里又没有zr

19:41.840 --> 19:45.840
如果说以前要获取这个路由的信息的话 是不是zrot

19:46.400 --> 19:48.400
对吧 跟以前 这是以前的做法

19:48.400 --> 19:50.320
那现在没有这个东西zr怎么办呢

19:50.320 --> 19:52.800
在completion API里边 那里就要使用这个

19:53.760 --> 19:56.640
wotor里边 使用什么呢

19:56.640 --> 19:58.640
它有一个useRotor

19:58.640 --> 20:00.640
也有一个useRot

20:00.640 --> 20:02.640
懂了吧 不用解释了吧

20:02.640 --> 20:05.280
那么我们要得到Rotor的话就很简单

20:05.280 --> 20:08.160
Rotor useRotor

20:08.160 --> 20:10.160
就拿到这个Rotor

20:10.160 --> 20:11.280
拿到这个Rotor过后呢

20:11.280 --> 20:13.280
我们再通过Rotor push

20:13.280 --> 20:15.280
挑转到首页 对吧 登录成功

20:15.280 --> 20:19.300
挑转到首页

20:19.300 --> 20:22.260
如果说登录失败呢 我这里就简单一下

20:22.260 --> 20:24.260
就简单处理一下

20:24.740 --> 20:28.260
帐号密码 帐号或密码错误

20:30.260 --> 20:32.260
我们就完成了一个简单的登录

20:32.260 --> 20:34.260
好 来试一下吧

20:36.260 --> 20:38.260
这边刷新

20:40.260 --> 20:42.260
首先帐号这一块

20:42.260 --> 20:44.260
我们写上一个错误的吧

20:44.260 --> 20:46.260
密码写上一个错误的

20:46.260 --> 20:48.260
回测

20:48.260 --> 20:50.260
帐号密码错误

20:50.260 --> 20:52.260
然后呢 我们这里写上正确的呢

20:52.260 --> 20:54.260
Rotor密

20:54.260 --> 20:56.260
123

20:56.260 --> 20:58.260
登录

20:58.260 --> 21:00.260
是不是到首页了 登录成功了

21:00.260 --> 21:02.260
就这么简单

21:02.260 --> 21:04.260
好 那么接下来我们再慢慢做

21:04.260 --> 21:06.260
首先在这里

21:06.260 --> 21:08.260
在这里的一个楼顶状态

21:08.260 --> 21:10.260
就是是否正在登录中

21:10.260 --> 21:12.260
因为我们的仓库里边是不是有这个状态啊

21:12.260 --> 21:14.260
是否正在登录中

21:14.260 --> 21:16.260
是否正在夹载中

21:16.260 --> 21:18.260
那么我们也就说

21:18.260 --> 21:20.260
我们这里要用到仓库里边的状态

21:20.260 --> 21:22.260
怎么用呢 其实也很简单

21:22.260 --> 21:24.260
我们以前咋用的 是不是写个计算属性

21:24.260 --> 21:26.260
那现在写个计算属性不完了嘛 对吧

21:26.260 --> 21:28.260
你这里写个楼顶

21:28.260 --> 21:30.260
计算属性嘛 计算属性能用啥呢

21:34.260 --> 21:36.260
然后呢来自于Stone仓库的State

21:36.260 --> 21:38.260
跟以前写法一样啊

21:38.260 --> 21:40.260
State什么login user

21:40.260 --> 21:42.260
那个什么楼顶

21:42.260 --> 21:44.260
送来自于这儿

21:44.260 --> 21:46.260
写个计算属性完事

21:46.260 --> 21:48.260
那么有了个楼顶过后呢

21:48.260 --> 21:50.950
可以放过来

21:50.950 --> 21:51.950
如果说正在夹载中

21:51.950 --> 21:52.950
那么它就是disable的

21:52.950 --> 21:54.950
这个按钮是不能用的

21:54.950 --> 21:56.950
如果说正在夹载中的话

21:56.950 --> 21:57.950
我就显示login

21:57.950 --> 21:58.950
否则的话显示登录

21:58.950 --> 22:03.610
保存啊 你看一下

22:03.610 --> 22:04.610
耳朵密

22:04.610 --> 22:06.610
1 2 3 1 2 3 回车

22:06.610 --> 22:07.610
你看这里

22:07.610 --> 22:09.610
所以楼顶状态的

22:09.610 --> 22:11.610
那么登录其实就做完了

22:11.610 --> 22:12.610
就没啥了

22:12.610 --> 22:13.610
非常简单的吧

22:13.610 --> 22:15.610
很多地方跟过去是一样的

22:15.610 --> 22:17.610
然后我们再回到这儿

22:17.610 --> 22:18.610
app这里

22:18.610 --> 22:19.610
那么这里也是一样的

22:19.610 --> 22:21.610
这里我们需要用到两个仓库状态

22:21.610 --> 22:22.610
一个是login

22:22.610 --> 22:23.610
是否正在登录中

22:23.610 --> 22:24.610
一个是当前登录的对象

22:24.610 --> 22:25.610
用户对象

22:25.610 --> 22:26.610
那么这样子一来了

22:26.610 --> 22:28.610
我们就可以在这里写个脚本

22:28.610 --> 22:32.240
script

22:32.240 --> 22:35.740
setup函数

22:35.740 --> 22:36.740
返回咱呢

22:36.740 --> 22:38.740
我们返回两个仓库里面的状态

22:38.740 --> 22:40.740
首先我要用到的仓库

22:40.740 --> 22:42.740
所以说有一个

22:42.740 --> 22:45.740
from viewx

22:45.740 --> 22:49.740
use store

22:49.740 --> 22:52.740
然后再导入

22:52.740 --> 22:54.740
view

22:54.740 --> 22:55.740
导入什么呢

22:55.740 --> 22:56.740
导入computed

22:56.740 --> 22:59.120
来吧

22:59.120 --> 23:00.120
我们这里需要两个状态

23:00.120 --> 23:02.120
一个是loading

23:02.120 --> 23:03.120
正在加载中

23:03.120 --> 23:06.120
这边用个computed

23:06.120 --> 23:08.120
然后来自于仓库

23:08.120 --> 23:10.120
所以把仓库拿到

23:10.120 --> 23:12.120
store

23:12.120 --> 23:13.120
use store

23:13.120 --> 23:16.880
store state

23:16.880 --> 23:18.880
login user

23:18.880 --> 23:19.880
loading

23:19.880 --> 23:20.880
然后还有一个状态

23:20.880 --> 23:22.880
就是当前的登录用户

23:22.880 --> 23:23.880
user

23:23.880 --> 23:26.880
login user

23:26.880 --> 23:28.880
把这两个状态拿到

23:28.880 --> 23:29.880
就完事了

23:29.880 --> 23:31.880
那么这边呢

23:31.880 --> 23:33.880
什么情况下我要显示loading

23:33.880 --> 23:36.880
是不是这个loading为初的时候就显示loading

23:36.880 --> 23:37.880
lc是个loading不为初

23:37.880 --> 23:39.880
v4是没有正在加载中

23:39.880 --> 23:41.880
那么我看一下用户对象有没有

23:41.880 --> 23:42.880
有用户对象的话

23:42.880 --> 23:45.880
我这里就显示用户对象的名字

23:45.880 --> 23:47.880
非常简单

23:47.880 --> 23:48.880
那么没有用户对象的话

23:48.880 --> 23:50.880
我就显示这个

23:50.880 --> 23:51.880
非常简单

23:51.880 --> 23:52.880
保存啊你看一下

23:52.880 --> 23:53.880
刷新

23:53.880 --> 23:54.880
你看loading对吧

23:54.880 --> 23:56.880
显示出来当前的登录

23:56.880 --> 23:57.880
登录好的用户

23:57.880 --> 23:59.880
就这么简单

23:59.880 --> 24:00.880
然后点退出退出的话

24:00.880 --> 24:02.880
我们注册一个时间吧

24:02.880 --> 24:04.880
注册一个函数

24:04.880 --> 24:05.880
handle

24:05.880 --> 24:08.880
login out

24:08.880 --> 24:10.880
退出

24:10.880 --> 24:13.880
这边呢我们可以用个sync

24:13.880 --> 24:16.880
把他盘回

24:16.880 --> 24:18.880
那么这边我们写上

24:18.880 --> 24:19.880
click

24:19.880 --> 24:20.880
prevent

24:20.880 --> 24:21.880
组织他的默认行为

24:21.880 --> 24:22.880
因为他是个超链接吗

24:22.880 --> 24:24.880
一点就被挑转一面了

24:24.880 --> 24:26.880
放过去

24:26.880 --> 24:27.880
那么这边的杂写呢

24:27.880 --> 24:28.880
也非常简单

24:28.880 --> 24:29.880
storn

24:29.880 --> 24:30.880
dispatch

24:30.880 --> 24:32.880
login user

24:32.880 --> 24:34.880
login out

24:34.880 --> 24:36.880
触发这个一个新

24:36.880 --> 24:38.880
触发这个login out

24:38.880 --> 24:40.880
这个一个新

24:40.880 --> 24:42.880
没什么毛病吧

24:42.880 --> 24:43.880
保存

24:43.880 --> 24:44.880
就是等待

24:44.880 --> 24:46.880
好触发完了过后

24:46.880 --> 24:49.880
然后我们把挑转的登录页面

24:49.880 --> 24:51.880
要用老rotor

24:51.880 --> 24:57.470
viewrotor

24:57.470 --> 24:59.470
可以看到其实跟以前的

24:59.470 --> 25:00.470
也没有啥区别

25:00.470 --> 25:02.470
没有太多区别

25:02.470 --> 25:06.850
就过去对象的时候不一样

25:06.850 --> 25:09.160
rotor

25:09.160 --> 25:12.160
然后rotor push

25:12.160 --> 25:15.980
到登录页面

25:15.980 --> 25:17.980
好了就完了

25:17.980 --> 25:19.980
来吧我们来试一下

25:19.980 --> 25:23.870
点退出

25:23.870 --> 25:25.870
就完了

25:25.870 --> 25:27.870
这就是用views

25:27.870 --> 25:29.870
来做这个共享数据

25:29.870 --> 25:31.870
没毛病吧

25:31.870 --> 25:32.870
views

25:32.870 --> 25:34.870
其实变动了就两个

25:34.870 --> 25:37.870
一个是放线仓库用crazy store

25:37.870 --> 25:38.870
一个是呢

25:38.870 --> 25:40.870
在completion API里面

25:40.870 --> 25:41.870
你要获得仓库对象

25:41.870 --> 25:43.870
你要使用use store

25:43.870 --> 25:45.870
来获得仓库对象

25:45.870 --> 25:47.870
包括你要使用rotor的时候

25:47.870 --> 25:49.870
要使用viewsrotor

25:49.870 --> 25:51.870
来获取这个仓库对象

25:51.870 --> 25:53.870
那个路由对象

25:53.870 --> 25:56.570
好这都是这种方案

25:56.570 --> 25:57.570
好下一个

25:57.570 --> 26:01.610
后边两种方案呢

26:01.610 --> 26:02.610
就跟views呢

26:02.610 --> 26:04.610
没有什么关系了

26:04.610 --> 26:06.610
就是我们自己熟悉了

26:06.610 --> 26:10.610
因为我们在使用views的时候呢

26:10.610 --> 26:11.610
更多的时候

26:11.610 --> 26:12.610
是使用这个views的

26:12.610 --> 26:14.610
共享数据的功能

26:14.610 --> 26:16.610
但是在views3里面的

26:16.610 --> 26:18.610
共享数据会变得极其简单

26:18.610 --> 26:20.610
因为它的想应式系统啊

26:20.610 --> 26:21.610
是跟这个对

26:21.610 --> 26:23.610
是跟那个

26:23.610 --> 26:25.610
组件是完全抽离的

26:25.610 --> 26:27.610
是没有一毛钱关系的

26:27.610 --> 26:28.610
想应式是想应式

26:28.610 --> 26:29.610
组件里面呢

26:29.610 --> 26:31.610
它无非就可能会用到一些

26:31.610 --> 26:32.610
想应式数据

26:32.610 --> 26:33.610
对不对

26:33.610 --> 26:34.610
之前我们讲过的

26:34.610 --> 26:35.610
所以在views3里面

26:35.610 --> 26:36.610
你要实现一个

26:36.610 --> 26:37.610
全局的数据共享

26:37.610 --> 26:38.610
极其简单

26:38.610 --> 26:40.610
你就购建一些想应式数据

26:40.610 --> 26:41.610
完了

26:41.610 --> 26:42.610
你要全局共享

26:42.610 --> 26:43.610
那就想应式数据

26:43.610 --> 26:44.610
只有一份

26:44.610 --> 26:46.610
就极其简单

26:46.610 --> 26:47.610
不要弄

26:47.610 --> 26:48.610
看一下这个图啊

26:48.610 --> 26:50.610
蓝色的是组件数

26:50.610 --> 26:52.610
我们做了很多很多

26:52.610 --> 26:53.610
乱七八糟的共享数据

26:53.610 --> 26:54.610
比方说这个是

26:54.610 --> 26:55.610
有一些新闻类别

26:55.610 --> 26:57.610
它是一些共享数据

26:57.610 --> 26:58.610
比方说一个

26:59.610 --> 27:01.610
这个地方是那个

27:02.610 --> 27:03.610
登入状态吧

27:03.610 --> 27:04.610
共享数据

27:04.610 --> 27:06.610
然后新闻共享数据

27:06.610 --> 27:08.610
对吧

27:08.610 --> 27:10.610
用户的类别共享数据

27:10.610 --> 27:12.610
就一大堆共享数据

27:12.610 --> 27:13.610
有一个共享数据

27:13.610 --> 27:14.610
你可以写个模块

27:14.610 --> 27:16.610
那个模块专来导出一些共享数据

27:16.610 --> 27:17.610
那组件里面随便用

27:17.610 --> 27:19.610
想用哪个用哪个

27:19.610 --> 27:21.610
就变成这种模式了

27:21.610 --> 27:23.610
它还不是一个单一的

27:23.610 --> 27:24.610
状态数

27:24.610 --> 27:26.610
你看views是一个单一的状态数

27:26.610 --> 27:27.610
那么这个玩意

27:27.610 --> 27:28.610
做成一个单一的状态数

27:28.610 --> 27:30.610
一把共享数据合并一下

27:30.610 --> 27:32.610
放到一个更高层的对象里面

27:32.610 --> 27:33.610
就做成一个状态数

27:33.610 --> 27:35.610
你可以不用一个单一的状态数

27:35.610 --> 27:36.610
一把分开

27:36.610 --> 27:37.610
一块是一块

27:37.610 --> 27:38.610
你要用到哪个自己去

27:38.610 --> 27:40.610
每个组件非常的明活

27:40.610 --> 27:41.610
我可以用这个共享数据

27:41.610 --> 27:42.610
我也可以用这个共享数据

27:42.610 --> 27:43.610
对吧

27:43.610 --> 27:44.610
想用哪个用哪个

27:44.610 --> 27:45.610
这是你从一个

27:45.610 --> 27:47.610
概念上去理解

27:47.610 --> 27:49.610
那么我们在具体的写的时候

27:49.610 --> 27:50.610
可以怎么写呢

27:50.610 --> 27:51.610
这里一个工程

27:51.610 --> 27:54.110
global state

27:54.110 --> 27:55.110
这个工程

27:55.110 --> 27:57.110
我把这个就把你点掉了

27:58.110 --> 27:59.110
好

27:59.110 --> 28:00.110
我们打开这个工程

28:00.110 --> 28:04.380
npm装

28:04.380 --> 28:05.380
对

28:05.380 --> 28:07.380
这个工程全部来做自己写

28:07.380 --> 28:08.380
不用views

28:08.380 --> 28:09.380
因为发现并不复杂

28:10.380 --> 28:11.380
非常的简单

28:12.380 --> 28:13.380
还是一样的界面

28:13.380 --> 28:14.380
还是一样的功能

28:14.380 --> 28:15.380
不过呢

28:15.380 --> 28:17.380
这里边就没有安装views的

28:17.380 --> 28:18.380
一切跟这些东西都一样

28:18.380 --> 28:19.380
这个玩意一样

28:19.380 --> 28:20.380
如同的一对一样

28:20.380 --> 28:21.380
实际上有一个文件

28:21.380 --> 28:22.380
是空的

28:22.380 --> 28:23.380
我们就需要在这里面写

28:23.380 --> 28:25.380
这个两个页面也完全一样

28:25.380 --> 28:26.380
没有什么区别

28:26.380 --> 28:27.380
这些东西完全一样

28:27.380 --> 28:28.380
都一样

28:28.380 --> 28:29.380
就是没有views的

28:30.380 --> 28:31.380
那么我们怎么来

28:31.380 --> 28:32.380
做一个共享数据呢

28:32.380 --> 28:34.380
你看下面我又要试一代码

28:35.380 --> 28:37.380
比方说我们在仓库里边

28:37.380 --> 28:38.380
去建立一个模块

28:38.380 --> 28:40.380
叫做views login user

28:40.380 --> 28:41.380
表示这个模块

28:41.380 --> 28:43.380
就是来提供共享数据的

28:43.380 --> 28:44.380
views login user

28:44.380 --> 28:45.380
什么共享数据呢

28:45.380 --> 28:47.380
就是我们来提供

28:47.380 --> 28:49.380
当前登陆用户的共享数据

28:49.380 --> 28:50.380
哪个用户登陆了

28:50.380 --> 28:52.380
适合是正在登陆中

28:52.380 --> 28:53.380
提供这么一个共享数据

28:54.380 --> 28:55.380
那么这个模

28:55.380 --> 28:56.380
比方说你还有一些

28:56.380 --> 28:57.380
别的共享数据

28:58.380 --> 28:59.380
每个模块一个共享数据

28:59.380 --> 29:00.380
对吧

29:00.380 --> 29:02.380
共享数据其实特别简单

29:02.380 --> 29:04.380
就是一个享用数据

29:04.380 --> 29:06.380
比方说我就简单举个例子

29:07.380 --> 29:08.380
你用一个ref

29:08.380 --> 29:09.380
或者是reactive

29:09.380 --> 29:10.380
reactive都可以

29:10.380 --> 29:11.380
无所谓

29:11.380 --> 29:12.380
反正是个享用数据就行了

29:13.380 --> 29:14.380
比方说你这里

29:14.380 --> 29:15.380
你用一个reactive

29:16.380 --> 29:18.380
然后呢这边我给他一个对象吧

29:18.380 --> 29:19.380
就当前用户嘛

29:19.380 --> 29:20.380
vallow

29:20.380 --> 29:21.380
然后呢

29:21.380 --> 29:23.380
那个就是他的loading

29:24.380 --> 29:25.380
vforce

29:25.380 --> 29:26.380
你看那个反回来

29:26.380 --> 29:27.380
不就是个共享数据吧

29:27.380 --> 29:28.380
以为这个东西是

29:28.380 --> 29:29.380
直接写到模块的权局的

29:29.380 --> 29:30.380
对吧

29:30.380 --> 29:31.380
那么这个模块只运行一次

29:31.380 --> 29:32.380
因为有缓存吗

29:32.380 --> 29:33.380
模块它只运行一次

29:33.380 --> 29:34.380
那么这样的数据

29:34.380 --> 29:35.380
是不是一个单粒啊

29:37.380 --> 29:38.380
这个数据不就是个单粒吗

29:39.380 --> 29:40.380
就这么简单

29:40.380 --> 29:41.380
整个系统里面

29:41.380 --> 29:43.380
只有一个这样的数据

29:44.380 --> 29:45.380
懂我这意思吧

29:46.380 --> 29:47.380
那就变成这个样子了

29:49.890 --> 29:50.890
好那么这个数据呢

29:50.890 --> 29:51.890
我们把这个代码

29:51.890 --> 29:52.890
直接复制过来就可以

29:53.890 --> 29:54.890
给大家一秒数

29:54.890 --> 29:55.890
就这么几行态了

29:55.890 --> 29:56.890
一秒数就看懂了

29:58.890 --> 29:59.890
我们要导入API吗

29:59.890 --> 30:00.890
你看啊

30:00.890 --> 30:01.890
我这里就构建了一个

30:01.890 --> 30:03.890
全局的单粒的响应式数据

30:03.890 --> 30:04.890
对吧

30:04.890 --> 30:05.890
这个代码只运行一次

30:05.890 --> 30:06.890
于是构建了一个全局的

30:06.890 --> 30:08.890
响应式数据

30:08.890 --> 30:09.890
那么不同的

30:09.890 --> 30:10.890
哪怕别的逐渐要用它

30:10.890 --> 30:11.890
那么用的都是同一个

30:11.890 --> 30:12.890
响应式数据

30:12.890 --> 30:13.890
对吧

30:13.890 --> 30:14.890
这个数据一变

30:14.890 --> 30:15.890
一代这个数据的模块

30:15.890 --> 30:16.890
一代这个数据的逐渐

30:16.890 --> 30:17.890
它都会变

30:17.890 --> 30:18.890
机器的简单

30:19.890 --> 30:20.890
好

30:20.890 --> 30:21.890
然后但是这个数据呢

30:21.890 --> 30:23.890
我不直接提供给外面使用

30:23.890 --> 30:24.890
为什么不提供给外面使用呢

30:24.890 --> 30:25.890
因为给外面使用了

30:25.890 --> 30:27.890
也不是说不行

30:27.890 --> 30:28.890
只是呢

30:28.890 --> 30:30.890
不太满足我们的那种

30:30.890 --> 30:31.890
思想对吧

30:31.890 --> 30:32.890
外面是属于一改

30:32.890 --> 30:33.890
都不属于自己的数据

30:33.890 --> 30:34.890
因为提供给外面

30:34.890 --> 30:35.890
外面是不是可以改

30:35.890 --> 30:36.890
外面是不是可以通过

30:36.890 --> 30:37.890
这个State去改

30:37.890 --> 30:38.890
改它的优势

30:38.890 --> 30:39.890
改它的楼顶

30:39.890 --> 30:40.890
如果说你可以

30:40.890 --> 30:41.890
认为这样子如果没问题的话

30:41.890 --> 30:42.890
那你就不需要

30:42.890 --> 30:43.890
做任何处理

30:43.890 --> 30:44.890
导出就完事了

30:44.890 --> 30:45.890
但是呢

30:45.890 --> 30:47.890
我觉得还是要沿用一下

30:47.890 --> 30:48.890
vux的思想

30:48.890 --> 30:49.890
就是外面不能改

30:49.890 --> 30:50.890
外面要改的话

30:50.890 --> 30:52.890
只能通过我提供的方法去改

30:53.890 --> 30:54.890
这样子呢

30:54.890 --> 30:57.890
不容易导致数据出问题

30:57.890 --> 30:58.890
不然你改一下

30:58.890 --> 30:59.890
我改一下改到后面

30:59.890 --> 31:00.890
这个数据都不知道

31:00.890 --> 31:01.890
什么样子了

31:01.890 --> 31:02.890
所以说呢

31:02.890 --> 31:03.890
我这里把它封装一下

31:03.890 --> 31:04.890
就封装了一个rid only

31:04.890 --> 31:05.890
学过了对吧

31:05.890 --> 31:06.890
把这个State

31:06.890 --> 31:07.890
用rid only封装一下

31:07.890 --> 31:08.890
导出去

31:08.890 --> 31:09.890
导出去过后呢

31:09.890 --> 31:10.890
外面是不是只能

31:10.890 --> 31:11.890
读不能改了

31:11.890 --> 31:13.890
就这么简单

31:13.890 --> 31:14.890
我这个模块

31:14.890 --> 31:15.890
内部可以使用它来改

31:15.890 --> 31:16.890
但是呢

31:16.890 --> 31:17.890
外面只能

31:17.890 --> 31:18.890
用这个rid only的数据

31:18.890 --> 31:20.890
它只能读不能改

31:20.890 --> 31:21.890
对不对

31:21.890 --> 31:22.890
封装一下

31:22.890 --> 31:23.890
换个名字

31:24.890 --> 31:25.890
封装一下

31:25.890 --> 31:26.890
扔出去

31:26.890 --> 31:27.890
当然你也可以

31:27.890 --> 31:29.890
标准你也可以在这里

31:29.890 --> 31:30.890
使用一个trips

31:30.890 --> 31:31.890
讲过了对吧

31:31.890 --> 31:32.890
把再封装一下

31:32.890 --> 31:33.890
这样子的外面

31:33.890 --> 31:34.890
是不是不仅可以

31:34.890 --> 31:35.890
不能改

31:35.890 --> 31:37.890
而且还可以进行解构

31:37.890 --> 31:38.890
对不对

31:38.890 --> 31:39.890
我们知道

31:39.890 --> 31:40.890
如果说你先用

31:40.890 --> 31:41.890
那个想用数据reactive

31:41.890 --> 31:42.890
的话你解构

31:42.890 --> 31:43.890
或者一展开

31:43.890 --> 31:44.890
那想用数就没了

31:45.890 --> 31:47.890
那么你可以加一个trips

31:47.890 --> 31:48.890
那么这个东西

31:48.890 --> 31:49.890
到底要不要加trips

31:50.890 --> 31:51.890
看里面以后

31:51.890 --> 31:52.890
自己的公司要求

31:52.890 --> 31:54.890
因为553我之前也说过

31:54.890 --> 31:56.890
这一块是有一些

31:56.890 --> 31:57.890
新制负担的

31:58.890 --> 31:59.890
有的时候有ref

31:59.890 --> 32:01.890
这个玩意到底是不是ref

32:01.890 --> 32:02.890
这个玩意到底

32:02.890 --> 32:03.890
要不要del-value

32:03.890 --> 32:04.890
有一些新制负担

32:04.890 --> 32:05.890
这需要一些

32:05.890 --> 32:06.890
开发规范去约束

32:06.890 --> 32:07.890
那么开发规范

32:07.890 --> 32:08.890
到底什么样子

32:08.890 --> 32:09.890
553刚出来

32:09.890 --> 32:10.890
每个公司

32:10.890 --> 32:11.890
也可能不一样

32:11.890 --> 32:12.890
也说不准到底

32:12.890 --> 32:13.890
应该有什么样子好

32:14.890 --> 32:15.890
那么这里

32:15.890 --> 32:17.890
比较说我这不弄

32:17.890 --> 32:18.890
好

32:18.890 --> 32:20.890
然后我既然不能改

32:20.890 --> 32:21.890
这个仓库

32:21.890 --> 32:22.890
我到底该怎么改

32:22.890 --> 32:23.890
比较说我要做一些操作

32:23.890 --> 32:25.890
要导致登录用户的变化

32:25.890 --> 32:26.890
那我只能通过

32:26.890 --> 32:27.890
调用方法去改

32:27.890 --> 32:28.890
于是那我导出三个方法

32:28.890 --> 32:30.890
locking out

32:30.890 --> 32:31.890
互按慢

32:31.890 --> 32:32.890
一看就看懂了

32:32.890 --> 32:33.890
一看就看懂了

32:33.890 --> 32:34.890
登录的时候

32:34.890 --> 32:35.890
先把社会去

32:36.890 --> 32:37.890
然后了

32:39.890 --> 32:40.890
设置登录用户

32:42.890 --> 32:43.890
这里应该是U字

32:44.890 --> 32:45.890
设置登录用户

32:49.350 --> 32:50.350
然后设置楼顶

32:50.350 --> 32:51.350
这里也是一样

32:51.350 --> 32:52.350
楼顶

32:53.350 --> 32:54.350
设置登录用户

32:54.350 --> 32:55.350
这里楼顶

32:56.350 --> 32:57.350
是不是提供这三个方法

32:57.350 --> 32:59.350
也就是外面这个模块的使用者

33:00.350 --> 33:02.350
使用这一块共享数据

33:02.350 --> 33:03.350
共享数据给力

33:04.350 --> 33:05.350
可能对共享数据

33:05.350 --> 33:06.350
进行的操作也给力

33:07.350 --> 33:09.350
我这里就没有区分

33:09.350 --> 33:11.350
什么有付作用和没有付作用

33:11.350 --> 33:12.350
完全没有区分了

33:12.350 --> 33:13.350
非常简单

33:13.350 --> 33:14.350
导致完事了

33:14.350 --> 33:15.350
是不是很好理解

33:16.350 --> 33:17.350
这个东西我

33:17.350 --> 33:20.350
这个玩意比那个Vilx好敌得多

33:20.350 --> 33:21.350
那么怎么用呢

33:21.350 --> 33:23.350
用法也极其简单

33:23.350 --> 33:24.350
我们到这个login里面去

33:25.350 --> 33:26.350
随便哪一个地方

33:26.350 --> 33:28.350
比如说MediaJS

33:28.350 --> 33:29.350
一开始的时候

33:29.350 --> 33:30.350
一开始的时候

33:30.350 --> 33:31.350
我们要调用这个互按麦

33:31.350 --> 33:32.350
对吧一开始的调用互按麦

33:33.350 --> 33:34.350
调用就完事了

33:34.350 --> 33:35.350
你看

33:35.350 --> 33:37.350
from store

33:38.350 --> 33:40.350
比方说我要调用这个

33:40.350 --> 33:41.350
login优色

33:41.350 --> 33:42.350
里面不是有一个

33:42.350 --> 33:43.350
互按麦吗

33:44.350 --> 33:45.350
调用就完事了

33:45.350 --> 33:47.350
一开始调用就完事了

33:47.350 --> 33:48.350
想用数据

33:48.350 --> 33:50.350
跟那个组件有没有什么关系的

33:50.350 --> 33:51.350
直接调用就完事了

33:51.350 --> 33:52.350
对吧

33:52.350 --> 33:53.350
它可以完成

33:53.350 --> 33:54.350
恢复登录状态

33:56.350 --> 33:58.350
然后到这个App组件里面来

33:58.350 --> 33:59.350
比方这个地方

33:59.350 --> 34:01.350
我到底要不要显示这个玩意呢

34:01.350 --> 34:03.350
那么是不是又可以在这里去使用

34:03.350 --> 34:04.350
这个数据完事了

34:06.350 --> 34:08.350
你看啊导入进来

34:08.350 --> 34:11.180
导入这个

34:12.180 --> 34:13.180
from

34:14.180 --> 34:15.180
store

34:16.180 --> 34:17.180
store

34:17.180 --> 34:18.180
login优色

34:18.180 --> 34:19.180
那么这里边

34:19.180 --> 34:20.180
我们要使用那个仓库数据

34:20.180 --> 34:21.180
对吧

34:21.180 --> 34:22.180
仓库数据是什么仓库数据呢

34:22.180 --> 34:24.180
我们一个是要登出

34:24.180 --> 34:25.180
login out

34:25.180 --> 34:26.180
还有一个就是

34:26.180 --> 34:27.180
login优色store

34:28.180 --> 34:29.180
那么这里呢

34:29.180 --> 34:31.180
setup还说直接返回就完事了

34:31.180 --> 34:32.180
return

34:32.180 --> 34:33.180
login out

34:35.180 --> 34:36.180
login优色store

34:36.180 --> 34:37.180
直接返回去完事了

34:37.180 --> 34:38.180
好了

34:38.180 --> 34:39.180
这边来吧

34:39.180 --> 34:40.180
你注意啊

34:40.180 --> 34:41.180
这个往下

34:41.180 --> 34:42.180
由于我在这边

34:42.180 --> 34:43.180
没有用to raves

34:43.180 --> 34:44.180
没有用to raves

34:44.180 --> 34:46.180
所以说你这里不能解构啊

34:46.180 --> 34:48.180
你解构就完蛋了啊

34:48.180 --> 34:49.180
就没有想像式了

34:50.180 --> 34:51.180
好那么这边

34:51.180 --> 34:52.180
来吧

34:52.180 --> 34:54.180
首先这个loading状态来自于哪呢

34:54.180 --> 34:56.180
来自于login优色store

34:56.180 --> 34:57.180
里边的loading

34:57.180 --> 34:58.180
对吧

34:58.180 --> 34:59.180
是不是来自于这

34:59.180 --> 35:00.180
然后这个玩意来自于哪呢

35:00.180 --> 35:03.180
login优色store.user

35:03.180 --> 35:04.180
对不对

35:04.180 --> 35:05.180
用户名是啥呀

35:05.180 --> 35:08.180
login优色store.user.name

35:08.180 --> 35:10.180
那退出怎么办呢

35:10.180 --> 35:11.180
click

35:11.180 --> 35:12.180
prevent

35:13.180 --> 35:15.180
等于什么login out

35:16.180 --> 35:17.180
当然了

35:17.180 --> 35:18.180
你登出过后

35:18.180 --> 35:19.180
你还调转页面

35:19.180 --> 35:20.180
你还可以再封装一下啊

35:20.180 --> 35:21.180
再封装一下吧

35:21.180 --> 35:22.180
handle

35:22.180 --> 35:24.180
login out

35:24.180 --> 35:27.680
跟之前一样啊

35:27.680 --> 35:28.680
await

35:28.680 --> 35:29.680
login out

35:30.680 --> 35:31.680
然后呢

35:31.680 --> 35:32.680
退出rotor

35:32.680 --> 35:33.680
对吧

35:33.680 --> 35:34.680
还要用rotor import

35:34.680 --> 35:36.680
use rotor

35:36.680 --> 35:38.680
vue rotor

35:38.680 --> 35:44.070
拿到rotor来说

35:44.070 --> 35:45.070
use rotor

35:46.070 --> 35:47.070
那么这个rotor

35:47.070 --> 35:50.020
put it

35:50.020 --> 35:51.020
到login里面

35:52.020 --> 35:54.020
把这个返回

35:54.020 --> 35:55.020
封装一下

35:56.020 --> 35:57.020
退出

35:57.020 --> 35:58.020
没问题吧

35:58.020 --> 35:59.020
然后这个地方呢

35:59.020 --> 36:00.020
哎呀

36:00.020 --> 36:01.020
就这个样子

36:01.020 --> 36:02.020
好 那么这个地方就写完了

36:02.020 --> 36:03.020
说极其简单

36:04.020 --> 36:05.020
好 刷新

36:06.020 --> 36:08.020
一样 说极其简单

36:09.020 --> 36:10.020
好 接下来

36:10.020 --> 36:11.020
到login里面来

36:11.020 --> 36:12.020
登录

36:12.020 --> 36:13.020
那登录咋登录呢

36:13.020 --> 36:15.020
一样的呗

36:15.020 --> 36:17.020
登录的要用到啥

36:17.020 --> 36:18.020
你就把方法

36:18.020 --> 36:19.020
状态的一些东西

36:19.020 --> 36:20.020
导入进来就完事了

36:21.020 --> 36:23.020
上节目录

36:23.020 --> 36:25.020
storm

36:25.020 --> 36:26.020
login user

36:26.020 --> 36:28.020
这只是一个共产数据

36:28.020 --> 36:30.020
多个共产数据分开模块不同的

36:30.020 --> 36:31.020
不同的模块写就行了

36:31.020 --> 36:32.020
就像这个图一样

36:33.020 --> 36:34.020
共产数据一个共产数据

36:34.020 --> 36:35.020
可以写成一个模块

36:35.020 --> 36:36.020
哪个主页要用了

36:36.020 --> 36:37.020
哪个自己去用

36:38.020 --> 36:39.020
好 那么这边

36:39.020 --> 36:41.020
我们可以导入这个什么

36:41.020 --> 36:42.020
登录

36:42.020 --> 36:43.020
我们不是要登录吗

36:43.020 --> 36:44.020
登录 导入进来

36:44.020 --> 36:45.020
那么这边我们给他

36:46.020 --> 36:47.020
还有个什么

36:47.020 --> 36:48.020
还有个状态我们也需要

36:48.020 --> 36:50.020
login user

36:50.020 --> 36:51.020
storm也需要

36:51.020 --> 36:52.020
因为这个地方呢

36:52.020 --> 36:53.020
我们需要他的loading状态

36:55.020 --> 36:58.100
loading

36:58.100 --> 37:00.740
loading

37:00.740 --> 37:01.740
好 把这个玩意导出

37:04.820 --> 37:05.820
然后login呢

37:05.820 --> 37:06.820
我们需要封装一个函数

37:07.820 --> 37:09.820
handle submit

37:13.280 --> 37:16.550
sync

37:16.550 --> 37:17.550
首先等待

37:17.550 --> 37:18.550
login

37:19.550 --> 37:20.550
这个函数

37:20.550 --> 37:21.550
这个函数要传两个东西

37:21.550 --> 37:22.550
一个login id

37:22.550 --> 37:23.550
一个login password

37:24.550 --> 37:25.550
对

37:26.550 --> 37:27.550
好 登录

37:28.550 --> 37:29.550
登录完了过后

37:29.550 --> 37:30.550
我判断一下

37:30.550 --> 37:32.550
判断一下登录有没有成功

37:32.550 --> 37:33.550
怎么判断呢

37:33.550 --> 37:34.550
因为这个函数我当时没有返回

37:34.550 --> 37:36.550
我这边没有返回

37:36.550 --> 37:37.550
login没有返回

37:37.550 --> 37:38.550
因为登录完了过后

37:38.550 --> 37:39.550
他改变的是自己的内部状态

37:39.550 --> 37:40.550
对吧

37:40.550 --> 37:41.550
所以说我可以判断这个

37:41.550 --> 37:43.550
login user store里边

37:43.550 --> 37:44.550
他的这个

37:44.550 --> 37:45.550
user有没有值

37:45.550 --> 37:47.550
有值的话就没登录成功了

37:47.550 --> 37:48.550
登录成功了过后

37:48.550 --> 37:49.550
我们反倒首页

37:50.550 --> 37:51.550
还是一样

37:51.550 --> 37:54.550
倒入UseRouter

38:03.550 --> 38:05.550
倒首页RouterPush

38:08.550 --> 38:09.550
没有登录成功了

38:09.550 --> 38:10.550
失败了

38:10.550 --> 38:11.550
我们还是Ernace

38:11.550 --> 38:12.550
帐号密码错误

38:12.550 --> 38:13.550
密码错误

38:14.550 --> 38:16.550
把handle submit返回

38:17.550 --> 38:18.550
机器都简单

38:18.550 --> 38:19.550
就是一个普通的函数

38:19.550 --> 38:20.550
一个普通的对象

38:20.550 --> 38:21.550
直接用就行了

38:24.120 --> 38:25.120
submit

38:25.120 --> 38:26.120
prevent

38:27.120 --> 38:30.010
好了就写完了

38:31.010 --> 38:32.010
有个登录

38:32.010 --> 38:33.010
登录的通了

38:33.010 --> 38:34.010
来试一下吧

38:36.010 --> 38:37.010
随便乱写

38:37.010 --> 38:38.010
肯定是不行的

38:38.010 --> 38:39.010
大密码错误

38:39.010 --> 38:40.010
然后呢

38:40.010 --> 38:41.010
二的命

38:41.010 --> 38:42.010
一二三一二三

38:43.010 --> 38:44.010
你看

38:44.010 --> 38:45.010
是不是可以刷新

38:46.010 --> 38:47.010
对吧没问题吧

38:47.010 --> 38:48.010
推出

38:49.010 --> 38:50.010
都没问题

38:50.010 --> 38:52.010
这种方式就是

38:52.010 --> 38:53.010
用共享数据

38:53.010 --> 38:54.010
就自己手写

38:54.010 --> 38:56.010
全局共享数据的方式

38:56.010 --> 38:57.010
一个共享数据

38:57.010 --> 38:58.010
那就是一个模块

38:58.010 --> 38:59.010
但这种方式呢

38:59.010 --> 39:01.010
会有一点小问题

39:01.010 --> 39:02.010
什么问题呢

39:03.010 --> 39:05.010
如果说你这个

39:05.010 --> 39:07.010
工程里边有多个

39:07.010 --> 39:08.010
无诱应用的话

39:08.010 --> 39:09.010
比较这是一个嘛

39:09.010 --> 39:10.010
对不对

39:10.010 --> 39:12.010
如果说有多个的话

39:12.010 --> 39:13.010
那么这个共享数据

39:13.010 --> 39:14.010
是不是在多个

39:14.010 --> 39:15.010
无诱之间

39:15.010 --> 39:16.010
无诱应用之间共享了

39:17.010 --> 39:18.010
那如果说你希望这样

39:18.010 --> 39:19.010
那就没啥问题

39:19.010 --> 39:21.010
你不希望这样

39:22.010 --> 39:23.010
然后这个无诱应用

39:23.010 --> 39:25.010
是一套登录用户

39:25.010 --> 39:26.010
另外一个无诱应用呢

39:26.010 --> 39:28.010
又是另外一套登录用户

39:28.010 --> 39:30.010
那你这个数据就不能共享了

39:31.010 --> 39:32.010
那怎么办呢

39:32.010 --> 39:33.010
我们就是有的时候呢

39:33.010 --> 39:34.010
可能会需要

39:34.010 --> 39:35.010
有多个无诱应用

39:35.010 --> 39:37.010
我们可能会需要

39:37.010 --> 39:39.010
把不同的那个数据呢

39:39.010 --> 39:41.010
放到不同的无诱应用里边去

39:41.010 --> 39:43.010
在一个无诱应用里边共享

39:43.010 --> 39:44.010
它不跨越

39:44.010 --> 39:45.010
懂这意思吧

39:45.010 --> 39:46.010
它可以跨越

39:46.010 --> 39:47.010
也可以不跨越

39:48.010 --> 39:49.010
那这个东西怎么办呢

39:50.010 --> 39:52.010
我们就可以用到另外一种方式

39:52.010 --> 39:53.010
这以另外一种方式呢

39:53.010 --> 39:55.010
也是在那个

39:55.010 --> 39:57.010
你们将来公司里边

39:57.010 --> 39:58.010
有可能会用到的

39:58.010 --> 39:59.010
共享数据的方式

39:59.010 --> 40:00.010
所以说我一打出来

40:00.010 --> 40:01.010
讲你讲

40:01.010 --> 40:02.010
Provide Inject

40:03.010 --> 40:05.010
提供和注入共享数据

40:05.010 --> 40:06.010
所以这个玩意儿

40:06.010 --> 40:07.010
大家并不陌生

40:07.010 --> 40:08.010
因为在vue2的时候

40:08.010 --> 40:09.010
它本身有这个东西

40:10.010 --> 40:11.010
vue2的时候

40:11.010 --> 40:12.010
我们是不是

40:12.010 --> 40:13.010
有这么一个配置

40:13.010 --> 40:14.010
在组建里边

40:14.010 --> 40:15.010
我们可以配置一个Provide

40:16.010 --> 40:17.010
提供一个数据

40:17.010 --> 40:18.010
那么这个是个对象

40:18.010 --> 40:19.010
提供多个数据

40:20.010 --> 40:21.010
然后在纸组建

40:21.010 --> 40:23.010
后代组建里边

40:23.010 --> 40:25.010
这个组建里边

40:25.010 --> 40:26.010
提供了一个数据

40:26.010 --> 40:27.010
821

40:27.010 --> 40:28.010
这个组建提供了一个数据

40:28.010 --> 40:30.010
vue2在配置里边

40:30.010 --> 40:31.010
组建配置里边就可以写

40:32.010 --> 40:33.010
然后在他们的

40:33.010 --> 40:34.010
后代组建里边

40:34.010 --> 40:35.010
不要让它

40:35.010 --> 40:36.010
即使它的后代组建

40:36.010 --> 40:38.010
也是它的后代组建

40:38.010 --> 40:40.010
那么它就可以使用

40:41.010 --> 40:42.010
任意使用这些数据

40:42.010 --> 40:43.010
怎么使用呢

40:43.010 --> 40:44.010
它需要一个配置

40:44.010 --> 40:45.010
要应借个注入

40:45.010 --> 40:47.010
注入之前的提供的数据

40:47.010 --> 40:48.010
注入哪两个呢

40:48.010 --> 40:49.010
一个是-

40:49.010 --> 40:50.010
一个是-

40:50.010 --> 40:51.010
也要用到哪个

40:51.010 --> 40:52.010
就注入哪个

40:52.010 --> 40:53.010
注入了过后

40:53.010 --> 40:54.010
那么在这个组建里边

40:54.010 --> 40:55.010
就可以使用什么呢

40:55.010 --> 40:56.010
就可以使用这个

40:56.010 --> 40:58.010
this

40:58.010 --> 40:59.010
什么-

40:59.010 --> 41:00.010
所以等于

41:00.010 --> 41:01.010
等于什么呢

41:01.010 --> 41:02.010
等于2

41:02.010 --> 41:03.010
然后this

41:03.010 --> 41:04.010
bar就等于1

41:04.010 --> 41:05.010
等于2的意思吧

41:05.010 --> 41:06.010
它就可以使用这个数据

41:06.010 --> 41:07.010
这是vue2的功能

41:07.010 --> 41:09.010
vue3的功能

41:09.010 --> 41:10.010
也没有变

41:10.010 --> 41:11.010
也就是vue3

41:11.010 --> 41:13.010
它本身是支持

41:13.010 --> 41:14.010
option API的

41:14.010 --> 41:15.010
支持配置的

41:15.010 --> 41:16.010
所谓过程的配置

41:16.010 --> 41:17.010
在vue3里面也能用

41:17.010 --> 41:18.010
但是vue3

41:18.010 --> 41:19.010
你不得不考虑一个点

41:19.010 --> 41:21.010
就是它有completion API

41:21.010 --> 41:22.010
那么completion API里边

41:22.010 --> 41:23.010
是没有z的

41:24.010 --> 41:26.010
也不会使用配置的方式

41:26.010 --> 41:27.010
来注入数据

41:27.010 --> 41:29.010
那么在completion API里边

41:29.010 --> 41:30.010
那怎么办呢

41:30.010 --> 41:31.010
在vue3里边呢

41:31.010 --> 41:32.010
它又

41:32.010 --> 41:33.010
除了支持这个配置之外

41:33.010 --> 41:35.010
它还提供了两个方法

41:35.010 --> 41:36.010
这两个方法

41:36.010 --> 41:38.010
也是属于completion API的

41:38.010 --> 41:39.010
之前讲completion API的时候

41:39.010 --> 41:40.010
没有讲这两个方法

41:40.010 --> 41:42.010
我们拿到这些课来讲

41:43.010 --> 41:44.010
就是在completion API的时候

41:44.010 --> 41:45.010
比方这个组建

41:45.010 --> 41:46.010
这个组建也好

41:46.010 --> 41:47.010
这个组建也好

41:47.010 --> 41:48.010
它可以通过一个方法

41:48.010 --> 41:49.010
provide的方法

41:49.010 --> 41:50.010
提供一个数据

41:50.010 --> 41:51.010
第一个参数传key

41:51.010 --> 41:52.010
第二个参数呢

41:52.010 --> 41:54.010
传递提供的数据

41:54.010 --> 41:55.010
一般来说

41:55.010 --> 41:56.010
我们要提供一个

41:56.010 --> 41:57.010
响应式数据

41:57.010 --> 41:58.010
因为响应式数据

41:58.010 --> 41:59.010
它变了过后呢

41:59.010 --> 42:00.010
你会跟着变

42:00.010 --> 42:01.010
对吧

42:01.010 --> 42:02.010
那组建会跟着刷新

42:02.010 --> 42:03.010
那么在植组建

42:03.010 --> 42:04.010
后代组建里边

42:04.010 --> 42:05.010
通过应借个证

42:05.010 --> 42:07.010
去使用相应的数据

42:08.010 --> 42:09.010
咱们来演示一下

42:09.010 --> 42:10.010
这种场景吧

42:11.010 --> 42:13.010
咱们找到另外一个工程

42:17.500 --> 42:18.500
找到这个工程

42:18.500 --> 42:19.500
其他都一样

42:19.500 --> 42:20.500
其他都完全一样

42:20.500 --> 42:21.500
现在我们到

42:21.500 --> 42:22.500
比方说

42:22.500 --> 42:23.500
照这个跟组建里边

42:23.500 --> 42:24.500
去提供一个数据吧

42:25.500 --> 42:26.500
script

42:26.500 --> 42:27.500
提供一个数据

42:27.500 --> 42:28.500
setup函数

42:31.380 --> 42:32.380
这边导入

42:34.380 --> 42:35.380
导入什么呢

42:35.380 --> 42:36.380
导入那个view

42:36.380 --> 42:38.380
里边的一个provide

42:39.380 --> 42:40.380
有这么一个方法

42:40.380 --> 42:41.380
好我们在这个

42:41.380 --> 42:42.380
跟组建里边

42:42.380 --> 42:43.380
提供一个数据

42:43.380 --> 42:44.380
provide

42:44.380 --> 42:46.380
key就传那个

42:46.380 --> 42:47.380
值呢

42:47.380 --> 42:48.380
比方说

42:48.380 --> 42:49.380
现在不用那个相应的数据

42:49.380 --> 42:50.380
就传一个e

42:51.380 --> 42:52.380
然后呢

42:52.380 --> 42:53.380
它的后代组建

42:53.380 --> 42:54.380
比方说后代组建

42:54.380 --> 42:55.380
我这里没有什么后代组建

42:55.380 --> 42:56.380
就是

42:56.380 --> 43:00.590
home里边

43:00.590 --> 43:01.590
script

43:02.590 --> 43:03.590
它有个setup函数

43:03.590 --> 43:04.590
那么它就可以使用

43:04.590 --> 43:05.590
应借个证

43:05.590 --> 43:06.590
去得到这个数据

43:07.590 --> 43:08.590
应借个证

43:12.590 --> 43:13.590
那么我们这里通过

43:13.590 --> 43:14.590
应借个证

43:14.590 --> 43:15.590
拿这个数据

43:15.590 --> 43:16.590
把key传进去

43:16.590 --> 43:17.590
key是什么呢

43:18.590 --> 43:20.590
输出一下

43:21.590 --> 43:22.590
看一下能不能输出

43:22.590 --> 43:23.590
接下来

43:23.590 --> 43:24.590
我们把它运行出来

43:27.160 --> 43:28.160
mtm装

43:29.160 --> 43:33.070
点击右键

43:35.070 --> 43:36.070
你看

43:36.070 --> 43:37.070
把e打到了

43:37.070 --> 43:38.070
当然这个e

43:38.070 --> 43:39.070
呢

43:39.070 --> 43:40.070
只是一个那个

43:40.070 --> 43:41.070
普通的数据

43:41.070 --> 43:42.070
它并不具有相应式

43:42.070 --> 43:43.070
也就是说

43:43.070 --> 43:44.070
这边要变的话

43:44.070 --> 43:45.070
这边也没法变

43:45.070 --> 43:46.070
它本身不是相应式数据

43:46.070 --> 43:47.070
那么

43:47.070 --> 43:48.070
通常情况下

43:48.070 --> 43:49.070
我们会提供一个

43:49.070 --> 43:50.070
相应式数据

43:50.070 --> 43:51.070
比方说

43:51.070 --> 43:52.070
比方这里

43:52.070 --> 43:53.070
我们一个

43:54.070 --> 43:55.070
data

43:56.070 --> 43:57.070
review

43:59.640 --> 44:00.640
e

44:00.640 --> 44:01.640
把data传进去

44:01.640 --> 44:02.640
那么将来data一变

44:02.640 --> 44:03.640
在这边data一变

44:03.640 --> 44:05.640
那么后边也会跟这边

44:05.640 --> 44:06.640
这里不掩饰了

44:06.640 --> 44:07.640
那么这边

44:07.640 --> 44:08.640
我们输出一下

44:08.640 --> 44:09.640
刷新

44:09.640 --> 44:10.640
你看不就是个相应式数据吗

44:10.640 --> 44:11.640
总之你提供什么

44:11.640 --> 44:12.640
它后边得到什么

44:12.640 --> 44:13.640
就这么简单

44:13.640 --> 44:15.640
这就是在comparation API里边

44:15.640 --> 44:16.640
使用provide和应借个证

44:16.640 --> 44:17.640
是不用配置的方式的

44:17.640 --> 44:18.640
对不对

44:18.640 --> 44:19.640
这样子

44:19.640 --> 44:21.640
更加能够配合comparation API

44:21.640 --> 44:23.640
因为comparation API是要把

44:23.640 --> 44:24.640
一个复杂组建里边

44:24.640 --> 44:25.640
不同的功能聚合在一起

44:25.640 --> 44:27.640
那么不同的功能里边

44:27.640 --> 44:28.640
可能要注入不同的数据

44:28.640 --> 44:29.640
对吧

44:29.640 --> 44:30.640
他们就可以通过这个

44:30.640 --> 44:31.640
函数据注入

44:31.640 --> 44:32.640
就这么一个情况

44:33.640 --> 44:34.640
好

44:34.640 --> 44:35.640
无忧商除了这个地方

44:35.640 --> 44:37.640
有改动之外

44:37.640 --> 44:39.640
就是新增的一个功能

44:39.640 --> 44:41.640
针对comparation API的

44:41.640 --> 44:42.640
它有的时候还会想

44:42.640 --> 44:43.640
就是有的时候

44:43.640 --> 44:44.640
我们可能整个组建

44:44.640 --> 44:46.640
就整个无诱应用

44:46.640 --> 44:49.640
都会使用到一些数据

44:49.640 --> 44:50.640
那么这个时候

44:51.640 --> 44:52.640
这个时候

44:52.640 --> 44:54.640
它可以把数据

44:54.640 --> 44:56.640
注入到整个应用里边

44:56.640 --> 44:57.640
对不对

44:57.640 --> 44:58.640
它就不是注入到

44:58.640 --> 45:00.640
某一个组建里边去了

45:00.640 --> 45:01.640
它注入到整个应用

45:02.640 --> 45:03.640
那么在无诱商里边

45:03.640 --> 45:04.640
是它的新增的功能

45:04.640 --> 45:05.640
它怎么做呢

45:05.640 --> 45:06.640
非常简单

45:06.640 --> 45:08.640
在crease app的时候

45:08.640 --> 45:09.640
我们只在这里

45:09.640 --> 45:10.640
就可以通过这个

45:11.640 --> 45:12.640
无诱实力

45:12.640 --> 45:14.640
无诱应用实力这个对象

45:14.640 --> 45:15.640
它提供了一个方法叫provide

45:15.640 --> 45:16.640
那么这个提供的数据

45:16.640 --> 45:18.640
就是针对整个应用的

45:19.640 --> 45:20.640
比方说我们这里有个代码

45:20.640 --> 45:22.640
提供了一个数据付

45:22.640 --> 45:23.640
这个

45:23.640 --> 45:24.640
一个bar

45:24.640 --> 45:25.640
这个

45:25.640 --> 45:26.640
那么就相当于是

45:26.640 --> 45:27.640
给整个无诱应用

45:27.640 --> 45:28.640
提供了两个数据

45:28.640 --> 45:29.640
一个是付

45:29.640 --> 45:30.640
一个是bar

45:30.640 --> 45:32.640
然后后边的所有组建

45:32.640 --> 45:33.640
包括根组建

45:33.640 --> 45:34.640
都可以随意的

45:34.640 --> 45:35.640
通过应借的

45:35.640 --> 45:36.640
去使用这个数据

45:36.640 --> 45:37.640
比方说我们来举个例子

45:37.640 --> 45:38.640
Made.js里边

45:38.640 --> 45:39.640
我们这里就来吧

45:41.640 --> 45:42.640
再来一个provide

45:42.640 --> 45:46.140
provide

45:46.140 --> 45:47.140
付

45:47.140 --> 45:49.140
再来个Rave吧

45:52.350 --> 45:53.350
Rave1

45:53.350 --> 45:55.350
然后再来一个provide

45:55.350 --> 45:56.350
bar

45:57.350 --> 45:59.350
Rave2

45:59.350 --> 46:00.350
比方说我们这里写了

46:00.350 --> 46:01.350
这样子写了

46:01.350 --> 46:02.350
然后我们根组建里边

46:02.350 --> 46:03.350
你看

46:03.350 --> 46:04.350
根组建里边

46:04.350 --> 46:05.350
我们这里不提供了

46:05.350 --> 46:06.350
我们用应借个字

46:07.350 --> 46:09.350
好 这边我们使用应借个字

46:10.350 --> 46:11.350
付

46:12.350 --> 46:13.350
我们这里输出data

46:15.350 --> 46:16.350
这是根组建

46:16.350 --> 46:17.350
app

46:18.350 --> 46:19.350
然后到植组建

46:19.350 --> 46:20.350
后面里边

46:21.350 --> 46:23.790
这是植组建

46:24.790 --> 46:25.790
看一下能不能正确的

46:25.790 --> 46:26.790
拿到这个数据

46:27.790 --> 46:28.790
保存

46:28.790 --> 46:29.790
刷新

46:29.790 --> 46:30.790
你看是不是拿到了

46:30.790 --> 46:31.790
app里边是拿到这个数据了

46:31.790 --> 46:32.790
对不对

46:33.790 --> 46:35.790
后面是拿到这个数据了

46:35.790 --> 46:36.790
V2

46:36.790 --> 46:38.790
那么在整个无用应用里边

46:38.790 --> 46:39.790
去提供数据

46:39.790 --> 46:41.790
那么数据是共享数据了

46:41.790 --> 46:42.790
那么植组建

46:42.790 --> 46:43.790
后代组建里边

46:43.790 --> 46:44.790
包括根组建

46:44.790 --> 46:45.790
所有的组建都可以拿到这个数据

46:46.790 --> 46:47.790
而且他们数据只有一份

46:47.790 --> 46:48.790
都是这个数据

46:48.790 --> 46:49.790
另外意思

46:49.790 --> 46:50.790
我们就可以充分地

46:50.790 --> 46:51.790
利用这一点

46:52.790 --> 46:53.790
在整个

46:53.790 --> 46:54.790
在某一个无用应用的

46:55.790 --> 46:57.790
某一个无用应用里边

46:57.790 --> 46:58.790
去提供数据

46:59.790 --> 47:01.790
好那么具体怎么做呢

47:01.790 --> 47:02.790
具体的做法

47:02.790 --> 47:03.790
就写法就前期百怪了

47:03.790 --> 47:04.790
我这里提供

47:04.790 --> 47:05.790
其中一种参考的写法

47:06.790 --> 47:07.790
我这里是这样子写的

47:07.790 --> 47:08.790
只做一个参考

47:09.790 --> 47:10.790
我这里

47:11.790 --> 47:12.790
我帮他单码复制一下

47:12.790 --> 47:13.790
我在stone里边

47:13.790 --> 47:15.790
去新建一个叫做还是一样

47:15.790 --> 47:16.790
YouSlockingUser

47:16.790 --> 47:18.790
但如果说有别的共享数据的话

47:18.790 --> 47:20.790
你去新建一些别的模块

47:21.790 --> 47:24.790
好比较多我这个里边写啥呢

47:25.790 --> 47:26.790
把这个复制一下

47:26.790 --> 47:31.060
我就导出两个东西

47:31.060 --> 47:33.060
一个是提供

47:33.060 --> 47:35.060
提供仓庚数据

47:35.060 --> 47:37.060
你给我传一个无用实力进来

47:38.060 --> 47:39.060
传啥的无用实力

47:39.060 --> 47:40.060
就是这个东西

47:40.060 --> 47:41.060
你把这个无用实力

47:41.060 --> 47:43.060
这里不是有一个

47:44.060 --> 47:45.060
得到这么一个APP

47:45.060 --> 47:47.060
对吧你把这个APP给我传进来

47:47.060 --> 47:48.060
里边那是吧

47:48.060 --> 47:49.060
APP给我传进来

47:49.060 --> 47:50.060
APP给我传进来

47:50.060 --> 47:51.060
那么我通过调问这个方法

47:51.060 --> 47:53.060
我以后再在这边去写

47:54.060 --> 47:55.060
把这传进来

47:55.060 --> 47:56.060
传进来过后我这边

47:56.060 --> 47:57.060
无非你看下面

47:57.060 --> 47:59.060
这些东西可以先不着急看

47:59.060 --> 48:01.060
我在这里就可以通过provide

48:01.060 --> 48:03.060
把一个keyz传进去

48:03.060 --> 48:04.060
一个keyz

48:04.060 --> 48:07.060
然后给你提供一个对象

48:07.060 --> 48:09.060
给你提供一个对象

48:09.060 --> 48:10.060
也就是说我在这里

48:10.060 --> 48:11.060
通过这个方法

48:11.060 --> 48:12.060
调问这个方法

48:12.060 --> 48:15.060
我就可以为某一个无用应用

48:15.060 --> 48:16.060
提供一个数据

48:16.060 --> 48:17.060
那么不同的无用应用

48:17.060 --> 48:18.060
一个传不同的APP进来

48:18.060 --> 48:19.060
那么提供的是

48:19.060 --> 48:21.060
可以试一些不同的数据

48:21.060 --> 48:22.060
懂的意思吧

48:22.060 --> 48:23.060
那么这个keyz

48:23.060 --> 48:24.060
我们一个看

48:24.060 --> 48:25.060
不着急慢慢看

48:25.060 --> 48:26.060
这个keyz是什么呢

48:26.060 --> 48:28.060
这个keyz可以是制服券

48:28.060 --> 48:30.060
它其实也可以是一个symbol

48:30.060 --> 48:32.060
那么推荐大家使用symbol

48:32.060 --> 48:34.060
因为symbol是不会重复的

48:34.060 --> 48:35.060
对不对keyz呢

48:35.060 --> 48:36.060
写着写着可能会重复

48:36.060 --> 48:38.060
symbol是不会重复的

48:38.060 --> 48:39.060
我们使用符号

48:39.060 --> 48:42.060
在内部去生成一个keyz

48:42.060 --> 48:44.060
那里看keyz传进去了

48:44.060 --> 48:46.060
那么这个提供了一个对象

48:46.060 --> 48:47.060
一个普通对象

48:47.060 --> 48:50.060
这个对象里边有哪些东西呢

48:50.060 --> 48:51.060
有一个状态

48:51.060 --> 48:52.060
这个状态是指读的

48:52.060 --> 48:53.060
对吧

48:53.060 --> 48:55.060
你也可以用twirft来防止

48:55.060 --> 48:58.060
它可能会出现的结构和展开

48:58.060 --> 49:00.060
我们一个status

49:00.060 --> 49:01.060
这个status跟之前一样

49:01.060 --> 49:02.060
是一个享用式数据

49:02.060 --> 49:04.060
那么跟之前不一样的是

49:04.060 --> 49:05.060
它不是全局的

49:05.060 --> 49:06.060
它是每调用一次方法

49:06.060 --> 49:09.060
给你生成一个状态

49:09.060 --> 49:10.060
那么就相当于是

49:10.060 --> 49:11.060
一个无用应用

49:11.060 --> 49:13.060
一个状态

49:13.060 --> 49:14.060
那么对外的话

49:14.060 --> 49:16.060
提供一个指读的

49:16.060 --> 49:18.060
这个对象里边有一个status

49:18.060 --> 49:19.060
然后提供了三个方法

49:19.060 --> 49:20.060
locking out

49:20.060 --> 49:21.060
互外慢

49:21.060 --> 49:22.060
对吧

49:22.060 --> 49:23.060
三个方法放进来

49:23.060 --> 49:24.060
那么三个方法

49:24.060 --> 49:25.060
也非常简单

49:25.060 --> 49:27.060
把这个地方改一下

49:27.060 --> 49:30.060
推出

49:30.060 --> 49:32.060
跟之前的写法是不一样的

49:32.060 --> 49:34.060
提供了三个方法

49:34.060 --> 49:37.060
那么就把这东西提供出去

49:37.060 --> 49:39.060
然后除了这个地方之外

49:39.060 --> 49:41.060
我们还提供了一个

49:41.060 --> 49:44.060
导出了另外一个喊声叫useStone

49:44.060 --> 49:46.700
useStone的时候

49:46.700 --> 49:47.700
其实这里面非常简单

49:47.700 --> 49:48.700
就是一个应借个者

49:48.700 --> 49:49.700
注入一个数据

49:49.700 --> 49:50.700
对吧

49:50.700 --> 49:52.700
注入一个想用式数据

49:52.700 --> 49:54.700
那么这个key值传进来

49:54.700 --> 49:55.700
同样的key嘛

49:55.700 --> 49:56.700
我这里提供数据

49:56.700 --> 49:57.700
这里通过这个方法

49:57.700 --> 49:58.700
可以提供数据

49:58.700 --> 50:00.700
通过这个方法可以注入数据

50:00.700 --> 50:01.700
可以使用数据

50:01.700 --> 50:02.700
把这个key值传进来

50:02.700 --> 50:03.700
封装一下

50:03.700 --> 50:04.700
那么这个应借个程来

50:04.700 --> 50:06.700
实际上是有第二个参数

50:06.700 --> 50:07.700
你可以给它提供一个默认值

50:07.700 --> 50:09.700
如果说这个数据不存在的话

50:09.700 --> 50:10.700
那么它的默认值是啥

50:10.700 --> 50:12.700
可以给它提供一个默认值

50:12.700 --> 50:13.700
你可以传进来

50:13.700 --> 50:14.700
默认为大

50:14.700 --> 50:16.700
好是不是就提供了这么两个方法

50:16.700 --> 50:17.700
对不对

50:17.700 --> 50:19.700
这就是这个模块的写法

50:19.700 --> 50:21.700
那么现在目前的模块写好了

50:21.700 --> 50:22.700
但是我们在媒体监视里面

50:22.700 --> 50:23.700
是不是还没有用它

50:23.700 --> 50:24.700
对不对

50:24.700 --> 50:25.700
是不是还没有用它

50:25.700 --> 50:26.700
那我怎么来用呢

50:26.700 --> 50:27.700
我可以用这种模式

50:27.700 --> 50:30.700
因为我们这里有可能会有多个模块

50:30.700 --> 50:31.700
对不对

50:31.700 --> 50:32.700
是不是有可能会有多个

50:32.700 --> 50:33.700
多个的个共享数据模块

50:33.700 --> 50:35.700
那么我这里可以写个index

50:35.700 --> 50:37.700
为了再进一步封装一下

50:37.700 --> 50:38.700
那么假设这里有多个

50:38.700 --> 50:39.700
共享模块的话

50:39.700 --> 50:40.700
我们在store index

50:40.700 --> 50:41.700
这个里边

50:41.700 --> 50:43.700
就可以这样子写

50:44.700 --> 50:46.700
你看导入这个use login user

50:46.700 --> 50:48.700
然后把它这个provide store

50:48.700 --> 50:49.700
给它改一下名字

50:49.700 --> 50:50.700
因为不同的模块

50:50.700 --> 50:51.700
它可能都有这个方法

50:51.700 --> 50:52.700
名字可能有冲突

50:52.700 --> 50:54.700
比方说我还有个共享的新闻

50:54.700 --> 50:56.700
那么共享新闻也导入

50:56.700 --> 50:57.700
它有个provide store

50:57.700 --> 50:59.700
也可以把它换一个名字

50:59.700 --> 51:01.700
总之那么把所有的那些共享模块

51:01.700 --> 51:03.700
提供共享数据的那个模块

51:03.700 --> 51:04.700
导入进来

51:04.700 --> 51:05.700
就是导

51:05.700 --> 51:07.700
提供的共享数据的方法导入进来

51:07.700 --> 51:08.700
然后这里提供一个统一的方法

51:08.700 --> 51:09.700
provide store

51:09.700 --> 51:11.700
你给我一个app

51:11.700 --> 51:12.700
我就是重新调用一下

51:12.700 --> 51:13.700
这些方法就完成了

51:13.700 --> 51:14.700
对不对

51:14.700 --> 51:15.700
那么这样子呢

51:15.700 --> 51:17.700
我们将来在Media.js里边

51:17.700 --> 51:18.700
只需要调用它

51:18.700 --> 51:22.700
就把整个该注入的数据

51:22.700 --> 51:23.700
全部注入进去了

51:23.700 --> 51:24.700
该提供的数据

51:24.700 --> 51:25.700
全部提供进去了

51:25.700 --> 51:26.700
就这么个意思

51:26.700 --> 51:28.700
把封装一下

51:28.700 --> 51:30.700
然后在Media.js里边

51:30.700 --> 51:31.700
这些东西都是我自己

51:31.700 --> 51:32.700
感觉上的写法

51:32.700 --> 51:33.700
将来你们到公司里面

51:33.700 --> 51:34.700
是不是这样子写

51:34.700 --> 51:36.700
现在谁也说不好

51:36.700 --> 51:38.700
然后在这边来的话

51:38.700 --> 51:39.700
那就非常简单了

51:39.700 --> 51:41.700
我这里就需要去写一个

51:41.700 --> 51:47.710
保住一个store

51:47.710 --> 51:49.710
这个store里面提供了

51:49.710 --> 51:50.710
其实它提供的就是一个方法

51:50.710 --> 51:54.150
provide store

51:54.150 --> 52:00.800
那么这边得到一个app

52:00.800 --> 52:02.800
然后调用这个方法

52:02.800 --> 52:03.800
provide store

52:03.800 --> 52:05.800
把app传进去

52:05.800 --> 52:08.800
然后最后app mount

52:08.800 --> 52:10.800
就应用

52:10.800 --> 52:12.800
这个地方就是提供

52:12.800 --> 52:14.800
所有共享数据

52:14.800 --> 52:16.800
在这个无用应用里面

52:16.800 --> 52:18.800
提供所有的共享数据

52:18.800 --> 52:19.800
好了

52:19.800 --> 52:20.800
是不是这样子一调用

52:20.800 --> 52:22.800
就相当于是在无用里面

52:22.800 --> 52:24.800
就提供了所有的共享数据了

52:24.800 --> 52:25.800
我看现在调试器

52:25.800 --> 52:27.800
能调出来吗

52:27.800 --> 52:29.800
这个provide能不能调出来

52:29.800 --> 52:30.800
试一下吧

52:30.800 --> 52:33.800
好像是不太行

52:33.800 --> 52:34.800
看一下这里调试器

52:34.800 --> 52:36.800
能不能看到这个工具

52:36.800 --> 52:38.800
能不能看到它提供的数据

52:38.800 --> 52:42.110
好像是不行

52:42.110 --> 52:46.550
好像是不行

52:46.550 --> 52:48.550
看不到

52:48.550 --> 52:50.550
看不到算了

52:50.550 --> 52:52.550
总之现在数据提供进去了

52:52.550 --> 52:53.550
那么剩下的事情

52:53.550 --> 52:55.550
是不是就在不同的组件里面

52:55.550 --> 52:56.550
你要用什么数据

52:56.550 --> 52:58.550
拿数据就完事了

52:58.550 --> 53:00.550
拿个组件要用共享数据

53:00.550 --> 53:01.550
拿就行了

53:01.550 --> 53:02.550
比如说我们一个个来

53:02.550 --> 53:04.550
在app这个组件里面

53:04.550 --> 53:05.550
在这个组件里面

53:05.550 --> 53:06.550
我们要拿一些共享数据

53:06.550 --> 53:08.550
那么怎么拿呢

53:08.550 --> 53:10.550
我可以在这个地方拿

53:10.550 --> 53:13.550
在那个store

53:13.550 --> 53:15.550
比如说拿U snoken user

53:16.550 --> 53:18.550
我们这里是不是可以使用

53:22.550 --> 53:24.550
去拿这个数据

53:24.550 --> 53:26.550
因为这个方法其实很简单

53:26.550 --> 53:28.550
就是一个引解个词

53:28.550 --> 53:29.550
相当于是在这里写个引解个词

53:29.550 --> 53:31.550
帮你封装一下

53:31.550 --> 53:33.550
没有默认只一个拿到就行了

53:33.550 --> 53:38.530
拿到这个store

53:38.530 --> 53:39.530
那么这个store里面有啥呢

53:39.530 --> 53:40.530
之前注入了啥

53:40.530 --> 53:42.530
之前提供的啥就是有啥

53:42.530 --> 53:43.530
之前提供的啥呢

53:43.530 --> 53:44.530
提供的是一个对象

53:44.530 --> 53:45.530
对象里面有stats

53:45.530 --> 53:47.530
有这个这些东西

53:47.530 --> 53:49.530
那么我们把这个store

53:49.530 --> 53:51.530
返回

53:51.530 --> 53:52.530
或者是把它展开

53:52.530 --> 53:53.530
因为这个地方展开了

53:53.530 --> 53:54.530
我没有展开这个

53:54.530 --> 53:55.530
我展开的是这个东西

53:55.530 --> 53:56.530
那无所谓

53:56.530 --> 54:00.480
好 那咱们把它展开

54:05.240 --> 54:06.240
好 返回了

54:06.240 --> 54:07.240
然后返回过后呢

54:07.240 --> 54:09.240
这边loading怎么办呢

54:09.240 --> 54:11.240
loading是不是nats with stats

54:11.240 --> 54:13.240
nats with stats

54:13.240 --> 54:15.240
dear loading

54:15.240 --> 54:16.240
对吧

54:16.240 --> 54:18.240
用户名的stats

54:18.240 --> 54:20.240
dear user

54:20.240 --> 54:22.240
这边的就是stats

54:22.240 --> 54:23.240
dear user

54:23.240 --> 54:24.240
dear name

54:24.240 --> 54:25.240
好

54:25.240 --> 54:26.240
那么退出呢

54:26.240 --> 54:28.240
退出还是得封装一下

54:28.240 --> 54:29.240
由于我在封装好

54:29.240 --> 54:32.240
还是把它拿过来吧

54:32.240 --> 54:34.240
store

54:34.240 --> 54:36.240
这个把store展开

54:36.240 --> 54:38.240
好 我这里还需要一个封装

54:38.240 --> 54:40.240
还说handle

54:40.240 --> 54:41.240
我把它复制过来吧

54:41.240 --> 54:43.240
反正附近都是同样的代码

54:43.240 --> 54:48.860
handle logging out

54:48.860 --> 54:49.860
处理退出

54:49.860 --> 54:50.860
退出的话

54:50.860 --> 54:51.860
我等待的是什么呢

54:51.860 --> 54:53.860
等待的是store里面的logging out

54:53.860 --> 54:54.860
等待它

54:54.860 --> 54:58.680
然后我还需要一个rotor

54:58.680 --> 55:00.680
复制一下

55:00.680 --> 55:02.680
一样的 把这个东西返回

55:02.680 --> 55:04.680
退出的时候是不是点击

55:04.680 --> 55:06.680
click

55:06.680 --> 55:08.680
prevents

55:08.680 --> 55:10.680
handle

55:10.680 --> 55:12.680
logging out

55:12.680 --> 55:14.680
退出

55:14.680 --> 55:15.680
其他还有啥呢

55:15.680 --> 55:16.680
没啥了

55:16.680 --> 55:17.680
没啥了

55:17.680 --> 55:18.680
没啥了

55:18.680 --> 55:19.680
好 咱们来看一下吧

55:19.680 --> 55:21.680
刷新

55:23.680 --> 55:24.680
刷新

55:24.680 --> 55:29.270
怎么出来什么情况了

55:29.270 --> 55:31.710
我看一下

55:31.710 --> 55:33.710
loading

55:33.710 --> 55:35.710
一开始没有调用那个who am I

55:35.710 --> 55:36.710
一开始没有调用who am I

55:36.710 --> 55:38.710
那么我就在根主键里面调用一下吧

55:38.710 --> 55:40.710
我就在根主键里面调用一下

55:40.710 --> 55:41.710
就在这里调用

55:41.710 --> 55:43.710
一开始Stone里面

55:43.710 --> 55:45.710
我们调用这个who

55:45.710 --> 55:46.710
I'm I

55:46.710 --> 55:48.710
对吧 调用一下就完成

55:48.710 --> 55:50.710
好 保存

55:50.710 --> 55:51.710
你看

55:51.710 --> 55:53.710
User is not defined

55:53.710 --> 55:57.280
这个地方

55:58.280 --> 56:00.280
没有导入这个API里面的东西

56:07.810 --> 56:08.810
好 刷新

56:08.810 --> 56:09.810
loading

56:09.810 --> 56:10.810
一开始没有动度

56:10.810 --> 56:11.810
对吧

56:11.810 --> 56:13.810
好 到这个地方来

56:13.810 --> 56:15.810
loading这个地方来

56:16.810 --> 56:18.810
好 这个页面也是一样

56:18.810 --> 56:19.810
也是一样

56:19.810 --> 56:20.810
我们把这个单码

56:20.810 --> 56:21.810
之前的loading直接复制过来吧

56:21.810 --> 56:22.810
复制过来

56:22.810 --> 56:24.810
我们改一改就行了

56:24.810 --> 56:29.310
复制过来

56:29.310 --> 56:30.310
好 来吧 改一改

56:31.310 --> 56:32.310
View

56:32.310 --> 56:33.310
一个个来

56:33.310 --> 56:35.310
这两个东西一样的

56:35.310 --> 56:36.310
Rotar一样的

56:36.310 --> 56:38.310
那么现在仓库里面不一样了

56:38.310 --> 56:40.310
仓库里面我们使用Use,Login,User

56:40.310 --> 56:42.310
那么这一边我们得到了是一个

56:42.310 --> 56:44.310
我们只需要得到这个东西

56:44.310 --> 56:46.310
Use,Stone

56:46.310 --> 56:47.310
对吧

56:47.310 --> 56:49.310
那么这边我们得拿到这个Stone

56:49.310 --> 56:51.310
Use,Stone

56:51.310 --> 56:53.880
好

56:53.880 --> 56:54.880
Handle上面提交

56:54.880 --> 56:55.880
处理提交的时候

56:55.880 --> 56:56.880
我们要调用Login

56:56.880 --> 56:57.880
那么Login在哪呢

56:57.880 --> 56:58.880
Stone点Login

56:58.880 --> 56:59.880
对吧

56:59.880 --> 57:00.880
Login ID点

57:00.880 --> 57:01.880
一样的

57:01.880 --> 57:02.880
等待

57:02.880 --> 57:03.880
等待完了过后

57:03.880 --> 57:05.880
我们来看一下Stone里面的State点User

57:05.880 --> 57:06.880
是不是有值

57:06.880 --> 57:08.880
有值的话东路成功

57:08.880 --> 57:10.880
否则的话东路失败

57:10.880 --> 57:11.880
对吧

57:11.880 --> 57:12.880
非常简单

57:12.880 --> 57:14.880
那么这个Handle上面彼此返回

57:14.880 --> 57:16.880
然后状态我们返回Stone

57:17.880 --> 57:19.880
就把这个地方不变

57:19.880 --> 57:20.880
属性名不变

57:20.880 --> 57:22.880
就把Stone点State返回

57:22.880 --> 57:23.880
对吧

57:23.880 --> 57:25.880
那么上面都一样了

57:25.880 --> 57:26.880
就这么简单

57:26.880 --> 57:28.880
就做完了

57:28.880 --> 57:29.880
好

57:29.880 --> 57:30.880
来

57:30.880 --> 57:31.880
我们来刷新一下

57:31.880 --> 57:34.880
2.min 123 123

57:34.880 --> 57:36.880
是一样的

57:36.880 --> 57:37.880
刷新

57:37.880 --> 57:39.880
推出

57:39.880 --> 57:41.880
推出的时候有一个Router

57:41.880 --> 57:43.880
推出的时候有个问题

57:43.880 --> 57:45.880
推出的时候

57:45.880 --> 57:47.880
Router没有写

57:47.880 --> 57:48.880
Router

57:48.880 --> 57:54.300
Use Router

57:54.300 --> 57:55.300
重新来

57:55.300 --> 57:58.810
2.min 123 123

57:58.810 --> 57:59.810
后

57:59.810 --> 58:00.810
推出

58:00.810 --> 58:01.810
好

58:01.810 --> 58:02.810
准备问题了

58:02.810 --> 58:03.810
这就是这种模式

58:03.810 --> 58:05.810
Provide Inject的模式

58:05.810 --> 58:07.810
那么现在减要三种模式的

58:07.810 --> 58:09.810
一个是Wilkes

58:09.810 --> 58:10.810
一个是很重量级的

58:10.810 --> 58:11.810
一个是GlobalState

58:11.810 --> 58:13.810
一个是Provide Inject

58:13.810 --> 58:14.810
那么这三种模式

58:14.810 --> 58:18.250
我们最后来做一个对比

58:18.250 --> 58:19.250
来看一下

58:19.250 --> 58:20.250
首先是

58:20.250 --> 58:21.250
组建数据共享

58:21.250 --> 58:22.250
那么

58:22.250 --> 58:23.250
如果说你只是要

58:23.250 --> 58:24.250
做共享数据的话

58:24.250 --> 58:25.250
这三种都可以

58:25.250 --> 58:26.250
你随便选一种

58:26.250 --> 58:28.250
没有哪种是不能做共享数据的

58:28.250 --> 58:30.250
他们都是为了做共享数据的

58:30.250 --> 58:31.250
对吧

58:31.250 --> 58:32.250
那么

58:32.250 --> 58:33.250
还有一个问题

58:33.250 --> 58:34.250
能不能脱离

58:34.250 --> 58:35.250
组建存在的

58:35.250 --> 58:36.250
这个共享数据

58:36.250 --> 58:37.250
能不能脱离

58:37.250 --> 58:38.250
组建存在的

58:38.250 --> 58:39.250
Wilkes是可以的

58:39.250 --> 58:40.250
对不对

58:40.250 --> 58:41.250
是可以脱离

58:41.250 --> 58:42.250
组建存在的

58:42.250 --> 58:43.250
因为我们知道

58:43.250 --> 58:45.250
你看Wilkes的时候

58:45.250 --> 58:46.250
在这个地方

58:46.250 --> 58:47.250
在这个地方

58:47.250 --> 58:48.250
在这个地方

58:48.250 --> 58:50.250
在这个

58:50.250 --> 58:52.250
Made.js里边

58:52.250 --> 58:53.250
你看

58:53.250 --> 58:54.250
我是不是

58:54.250 --> 58:55.250
这里个地方

58:55.250 --> 58:56.250
直接一个Dispatch

58:56.250 --> 58:57.250
都可以

58:57.250 --> 58:58.250
是不是可以

58:58.250 --> 58:59.250
仓库本来

58:59.250 --> 59:00.250
是可以脱离

59:00.250 --> 59:01.250
组建存在的

59:01.250 --> 59:02.250
那么GlobalState

59:02.250 --> 59:03.250
是享用数据

59:03.250 --> 59:04.250
全局的享用数据

59:04.250 --> 59:05.250
它本来是可以

59:05.250 --> 59:06.250
脱离组建存在

59:06.250 --> 59:08.250
但是Provide.in介绍是不行的

59:08.250 --> 59:09.250
为什么呢

59:09.250 --> 59:10.250
因为

59:10.250 --> 59:12.250
它是跟应用绑定在一起的

59:12.250 --> 59:14.250
跟应用是深度绑近的

59:14.250 --> 59:15.250
所以说

59:15.250 --> 59:16.250
它这个东西不能脱离

59:16.250 --> 59:17.250
组建存在

59:17.250 --> 59:18.250
为什么呢

59:18.250 --> 59:19.250
因为在这个地方

59:19.250 --> 59:20.250
Provide.in介绍

59:20.250 --> 59:21.250
这种模式里边

59:21.250 --> 59:22.250
它的仓库

59:22.250 --> 59:23.250
创建的仓库

59:23.250 --> 59:24.250
是必须要跟Wilkes

59:24.250 --> 59:26.250
应用绑定在一起的

59:26.250 --> 59:28.250
而且这两个函数

59:28.250 --> 59:29.250
这个什么

59:29.250 --> 59:31.250
Provide.in介绍

59:31.250 --> 59:32.250
这个英介绍函数

59:32.250 --> 59:34.250
是只能在组建里面使用的

59:34.250 --> 59:36.250
它不能在外面使用的

59:36.250 --> 59:37.250
比方说你

59:37.250 --> 59:38.250
你想在外面

59:38.250 --> 59:39.250
Made.js里边

59:39.250 --> 59:40.250
我想一开始就去

59:40.250 --> 59:41.250
调用一下互外卖

59:41.250 --> 59:42.250
行不行呢

59:42.250 --> 59:43.250
我们来试一下吧

59:43.250 --> 59:44.250
我们在这里

59:44.250 --> 59:45.250
Import

59:45.250 --> 59:46.250
From

59:46.250 --> 59:47.250
Use

59:47.250 --> 59:48.250
放那个什么

59:48.250 --> 59:49.250
From

59:49.250 --> 59:50.250
叫些个

59:50.250 --> 59:51.250
Stone

59:51.250 --> 59:52.250
Use

59:52.250 --> 59:53.250
Knock

59:53.250 --> 59:54.250
User

59:54.250 --> 59:55.250
这里我们使用Use

59:55.250 --> 59:56.250
Stone

59:56.250 --> 59:57.250
我们来看一下

59:57.250 --> 59:58.250
在这里可不可以呢

59:58.250 --> 59:59.250
UseStone

59:59.250 --> 01:00:00.250
然后点击

01:00:00.250 --> 01:00:02.250
调用那个

01:00:02.250 --> 01:00:03.250
Who am I

01:00:03.250 --> 01:00:07.030
调用一下

01:00:07.030 --> 01:00:08.030
看一下行不行

01:00:08.030 --> 01:00:11.430
放心

01:00:11.430 --> 01:00:12.430
你看

01:00:13.430 --> 01:00:14.430
Connect with the property

01:00:14.430 --> 01:00:15.430
Who am I

01:00:19.730 --> 01:00:20.730
调用那个

01:00:20.730 --> 01:00:21.730
对

01:00:21.730 --> 01:00:22.730
而且现在是出问题了对不对

01:00:22.730 --> 01:00:23.730
出了什么问题

01:00:23.730 --> 01:00:24.730
因为这个时候

01:00:24.730 --> 01:00:26.730
它的组建都还没有加载完成

01:00:27.730 --> 01:00:29.730
Provide.Stone

01:00:29.730 --> 01:00:30.730
这个

01:00:30.730 --> 01:00:31.730
它提供的数据

01:00:31.730 --> 01:00:33.730
只是在这个应用里边的

01:00:33.730 --> 01:00:34.730
对吧

01:00:34.730 --> 01:00:35.730
因为我们提供的数据

01:00:35.730 --> 01:00:36.730
Provide.Stone

01:00:36.730 --> 01:00:37.730
你看

01:00:37.730 --> 01:00:38.730
Provide.Stone

01:00:39.730 --> 01:00:41.730
是在应用里边去提供这个数据的

01:00:41.730 --> 01:00:43.730
除了这个应用是不是没了

01:00:43.730 --> 01:00:45.730
所以它不能脱离这个应用和组建存在

01:00:45.730 --> 01:00:46.730
原来的意思吧

01:00:46.730 --> 01:00:48.730
说这种方式是不行的

01:00:48.730 --> 01:00:49.730
所以说我们当时在调用一个

01:00:49.730 --> 01:00:50.730
Who am I的时候

01:00:50.730 --> 01:00:51.730
是在根组建里边去调用的

01:00:51.730 --> 01:00:53.730
懂得的意思吧

01:00:53.730 --> 01:00:55.730
就这个地方

01:00:55.730 --> 01:00:56.730
这地方是不一样的

01:00:56.730 --> 01:00:57.730
还有调式工具支持

01:00:57.730 --> 01:00:58.730
Wilkes

01:00:58.730 --> 01:00:59.730
现在还不支持

01:00:59.730 --> 01:01:01.730
因为现在还在Beta版本

01:01:01.730 --> 01:01:02.730
将来

01:01:02.730 --> 01:01:03.730
学着那个

01:01:03.730 --> 01:01:04.730
测试版的发布

01:01:04.730 --> 01:01:05.730
以及呢

01:01:06.730 --> 01:01:07.730
调试工具的更新

01:01:07.730 --> 01:01:09.730
那么肯定是要集成那个Wilkes

01:01:09.730 --> 01:01:11.730
调试工具肯定是要做相应的

01:01:11.730 --> 01:01:13.730
肯定是要能够调试的

01:01:13.730 --> 01:01:14.730
比方说什么

01:01:14.730 --> 01:01:15.730
时间旅行

01:01:15.730 --> 01:01:17.730
回到之前那个状态

01:01:17.730 --> 01:01:19.730
还可以通过那个调试工具

01:01:19.730 --> 01:01:20.730
看到每一步的状态

01:01:20.730 --> 01:01:22.730
那么这些东西都可以通过调试工具

01:01:22.730 --> 01:01:23.730
一些工具箱

01:01:23.730 --> 01:01:24.730
去可以

01:01:24.730 --> 01:01:26.730
非常方便的进行调试

01:01:26.730 --> 01:01:28.730
但是我们自己写的Global States

01:01:28.730 --> 01:01:29.730
我想一想

01:01:29.730 --> 01:01:30.730
它不是很好做

01:01:30.730 --> 01:01:32.730
因为这个东西写的太灵活了

01:01:32.730 --> 01:01:34.730
非常非常灵活

01:01:34.730 --> 01:01:37.730
它不知道哪个地方是提供了共享数据

01:01:37.730 --> 01:01:39.730
所以这个玩意它不是很好做

01:01:39.730 --> 01:01:40.730
所以这个东西

01:01:40.730 --> 01:01:41.730
我觉得将来是很难

01:01:41.730 --> 01:01:43.730
有调试工具去支持它的

01:01:43.730 --> 01:01:45.730
有第二种方式

01:01:45.730 --> 01:01:47.730
那么Provide和Inject这种方式

01:01:47.730 --> 01:01:49.730
我觉得将来是可以

01:01:49.730 --> 01:01:50.730
调试工具是可以支持的

01:01:50.730 --> 01:01:51.730
因为调试工具

01:01:51.730 --> 01:01:52.730
它可以知道某一个

01:01:52.730 --> 01:01:54.730
5U应用里边

01:01:54.730 --> 01:01:55.730
在某一个5U应用里边

01:01:55.730 --> 01:01:57.730
那么这个5U应用里边

01:01:57.730 --> 01:01:58.730
它Provide的

01:01:58.730 --> 01:01:59.730
就是提供了哪些数据

01:01:59.730 --> 01:02:00.730
通过Provide

01:02:00.730 --> 01:02:01.730
提供了哪些拳击数据

01:02:01.730 --> 01:02:02.730
对吧

01:02:02.730 --> 01:02:03.730
它是可以知道的

01:02:03.730 --> 01:02:04.730
但是这个东西

01:02:04.730 --> 01:02:06.730
它应该是能够用调试工具来去支持的

01:02:06.730 --> 01:02:08.730
理论上是可以的

01:02:08.730 --> 01:02:09.730
但是它到底做不做

01:02:09.730 --> 01:02:11.730
那就不知道了

01:02:11.730 --> 01:02:12.730
然后是状态数

01:02:12.730 --> 01:02:13.730
我们知道Vx

01:02:13.730 --> 01:02:14.730
它是做了一个整个的状态数

01:02:14.730 --> 01:02:15.730
对吧

01:02:15.730 --> 01:02:16.730
有一个

01:02:16.730 --> 01:02:19.730
通过一个Stone里边的State

01:02:19.730 --> 01:02:20.730
通过这个

01:02:20.730 --> 01:02:21.730
Z

01:02:21.730 --> 01:02:22.730
Stone里边的State

01:02:22.730 --> 01:02:24.730
是不是拿到整个

01:02:24.730 --> 01:02:25.730
应用里边的所有状态

01:02:25.730 --> 01:02:27.730
全部封装到这里边去了

01:02:27.730 --> 01:02:28.730
那么我们后边

01:02:28.730 --> 01:02:30.730
这两个就要自行决定的

01:02:30.730 --> 01:02:32.730
它要不要有状态数理自行决定

01:02:32.730 --> 01:02:34.730
那么我们这里做的

01:02:34.730 --> 01:02:35.730
就没有状态数

01:02:35.730 --> 01:02:36.730
它是分开的

01:02:36.730 --> 01:02:38.730
它没有把它合并到一个

01:02:38.730 --> 01:02:39.730
完整的对象里边去

01:02:39.730 --> 01:02:40.730
当然你可不可以把合并到

01:02:40.730 --> 01:02:41.730
完整的对象里面去

01:02:41.730 --> 01:02:42.730
当然是可以

01:02:42.730 --> 01:02:43.730
只是我这里没有这样做

01:02:43.730 --> 01:02:44.730
就自行决定

01:02:44.730 --> 01:02:46.730
要不要把生成一个状态数

01:02:46.730 --> 01:02:47.730
还是把它分开

01:02:47.730 --> 01:02:49.730
一个地方就是个共产数据

01:02:49.730 --> 01:02:50.730
好

01:02:50.730 --> 01:02:51.730
然后量级

01:02:51.730 --> 01:02:52.730
就是Vx肯定是重量级的

01:02:52.730 --> 01:02:54.730
这两个是比较轻量级的

01:02:54.730 --> 01:02:55.730
完全没有用它

01:02:55.730 --> 01:02:56.730
写得很少的代码

01:02:56.730 --> 01:02:58.730
就可以实现了共产数据了

01:02:58.730 --> 01:03:00.730
总之就是这么一个情况

01:03:00.730 --> 01:03:01.730
情况就是这么一个情况

01:03:01.730 --> 01:03:02.730
将来呢

01:03:02.730 --> 01:03:03.730
根据不同的需要呢

01:03:03.730 --> 01:03:04.730
在自行选择

01:03:04.730 --> 01:03:05.730
我觉得吧

01:03:06.730 --> 01:03:08.730
以后那种中小型项目

01:03:08.730 --> 01:03:10.730
完全没有必要去上那个Vx

01:03:10.730 --> 01:03:11.730
可能

01:03:11.730 --> 01:03:12.730
很有可能

01:03:12.730 --> 01:03:13.730
我觉得

01:03:13.730 --> 01:03:14.730
我现在也说不准

01:03:14.730 --> 01:03:15.730
觉得呢

01:03:15.730 --> 01:03:17.730
可能provide in 介绍成了

01:03:17.730 --> 01:03:19.730
可能要稍微用的多一点

01:03:19.730 --> 01:03:20.730
为什么呢

01:03:20.730 --> 01:03:21.730
因为它毕竟

01:03:21.730 --> 01:03:23.730
可以跟那个调试工具来结合

01:03:23.730 --> 01:03:25.730
所以它可能用的

01:03:25.730 --> 01:03:27.730
稍微的多一点

01:03:27.730 --> 01:03:30.550
其他都没啥

01:03:30.550 --> 01:03:32.550
好了那么这就是

01:03:32.550 --> 01:03:35.550
Viu3里面的共产数据方案

01:03:35.550 --> 01:03:36.550
好了

01:03:36.550 --> 01:03:37.550
至此呢

01:03:37.550 --> 01:03:38.550
我觉得Viu3呢

01:03:38.550 --> 01:03:39.550
要讲的东西啊

01:03:39.550 --> 01:03:41.550
就是目前我们要讲的东西

01:03:41.550 --> 01:03:42.550
也差不多到这了

01:03:42.550 --> 01:03:43.550
其实还有一些

01:03:43.550 --> 01:03:45.550
细致末节的改动

01:03:45.550 --> 01:03:46.550
那么那些

01:03:46.550 --> 01:03:47.550
细致末节的改动

01:03:47.550 --> 01:03:48.550
一是比较简单

01:03:48.550 --> 01:03:50.550
二是呢和内容还比较多

01:03:50.550 --> 01:03:51.550
第三呢

01:03:51.550 --> 01:03:52.550
是你们不太有可能遇得到

01:03:52.550 --> 01:03:54.550
如果说你们将来遇到了过后呢

01:03:54.550 --> 01:03:55.550
反正咱们有群

01:03:55.550 --> 01:03:56.550
问一问老师

01:03:56.550 --> 01:03:57.550
到时候呢

01:03:57.550 --> 01:03:58.550
老师搞不定的话

01:03:58.550 --> 01:04:00.550
我就自然回来问我

01:04:00.550 --> 01:04:01.550
我到时候给你

01:04:01.550 --> 01:04:02.550
一些链接

01:04:02.550 --> 01:04:03.550
将来

01:04:04.550 --> 01:04:05.550
Viu3的那个

01:04:05.550 --> 01:04:07.550
官方中文文档也会逐步的完善

01:04:07.550 --> 01:04:08.550
所以说

01:04:08.550 --> 01:04:09.550
那些改动呢

01:04:09.550 --> 01:04:10.550
我觉得都不成问题

01:04:10.550 --> 01:04:11.550
遇到了过后

01:04:11.550 --> 01:04:12.550
我们再去解学呗

01:04:12.550 --> 01:04:13.550
因为如果说

01:04:13.550 --> 01:04:14.550
屏幕直续的去讲的话

01:04:14.550 --> 01:04:15.550
东西太多了

01:04:15.550 --> 01:04:17.550
讲了也没什么意义

01:04:17.550 --> 01:04:19.550
这些东西面试也不会问到的

01:04:19.550 --> 01:04:20.550
所以我们把重点的

01:04:20.550 --> 01:04:21.550
Viu3的重点变动

01:04:21.550 --> 01:04:22.550
讲了就可以了

01:04:22.550 --> 01:04:23.550
OK了

01:04:23.550 --> 01:04:24.550
这就是Viu3里边的东西

