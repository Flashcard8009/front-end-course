WEBVTT

00:00.050 --> 00:05.050
第二节课我们来学习Collection对象身上的一些方法

00:05.050 --> 00:07.050
先来解释一下Collection

00:07.050 --> 00:10.050
Collection它翻译过来就是一个集合

00:10.050 --> 00:12.050
这个集合要解释一下

00:12.050 --> 00:15.050
这个集合就像我们的数组它是不是集合

00:15.050 --> 00:17.050
它绝对是一个集合

00:17.050 --> 00:20.050
然后另外还有一些有序的一些对象

00:20.050 --> 00:22.050
它也是一个集合

00:22.050 --> 00:26.050
以及像我们从页面当中所获取到的一些当我们对象

00:26.050 --> 00:28.050
它其实也是一个集合

00:28.050 --> 00:31.050
那个是有一个真正的一个当我们对象

00:31.050 --> 00:33.050
叫HTML Collection

00:33.050 --> 00:34.050
它是一个对象

00:34.050 --> 00:37.050
所以Collection当中所包含数组

00:37.050 --> 00:38.050
知道吗

00:38.050 --> 00:40.050
所以这里头你会见到很多的一些方法

00:40.050 --> 00:42.050
它还是数组身上的

00:42.050 --> 00:43.050
你可不要奇怪

00:43.050 --> 00:44.050
那数组不是上边已经讲了

00:44.050 --> 00:46.050
为什么不放到那里头

00:46.050 --> 00:48.050
就是因为现在它说的是一个集合

00:48.050 --> 00:50.050
这些方法不光适用于数组

00:50.050 --> 00:53.050
在一些有序的对象当中也是适用了

00:53.050 --> 00:55.050
我们就挨个来说

00:55.050 --> 00:58.050
首先第一个就是一个Count By

00:58.050 --> 01:00.740
Count By

01:00.740 --> 01:01.740
这个方法啥意思

01:01.740 --> 01:04.740
这个方法是按照一定的规则

01:04.740 --> 01:06.740
去统计数量

01:06.740 --> 01:08.740
它的规则是什么

01:08.740 --> 01:11.740
我们在这只能是先把题目写出来之后

01:11.740 --> 01:13.740
我们看一下结果

01:13.740 --> 01:15.740
再通过结果去解释

01:15.740 --> 01:17.740
来在这直接去调这个方法

01:17.740 --> 01:19.740
传上一个餐

01:19.740 --> 01:22.740
我就拿到它的官方网站的例子

01:22.740 --> 01:24.740
传这个餐

01:24.740 --> 01:26.740
这个是第一个参数

01:26.740 --> 01:28.740
我要统计的这么一个数组

01:28.740 --> 01:30.740
数组也是一个集合对象

01:30.740 --> 01:32.740
然后第二个参数是什么

01:32.740 --> 01:34.740
你要统计哪一个

01:34.740 --> 01:36.740
我给上一个Lens

01:36.740 --> 01:39.740
那就代表现在我要统计的是

01:39.740 --> 01:41.740
这里头的Lens

01:41.740 --> 01:43.740
当然这个Lens并不是说

01:43.740 --> 01:45.740
这个数组它的一个Lens

01:45.740 --> 01:47.740
是每一个数据的Lens

01:47.740 --> 01:49.740
我们先来看一下结果

01:49.740 --> 01:51.740
打开控制台

01:51.740 --> 01:53.740
来在这刷新一下

01:53.740 --> 01:54.740
好有一个结果

01:54.740 --> 01:56.740
是不是打印出来的这么一个东西

01:56.740 --> 01:57.740
我估计就是说

01:57.740 --> 01:59.740
第一次咱们去看见这个东西之后

01:59.740 --> 02:00.740
是蒙的

02:00.740 --> 02:01.740
不知道啥意思

02:01.740 --> 02:03.740
我来解释一下

02:03.740 --> 02:04.740
首先我们先来看

02:04.740 --> 02:05.740
这是一个对象

02:05.740 --> 02:06.740
对象当中

02:06.740 --> 02:07.740
K

02:07.740 --> 02:08.740
K是一个3

02:08.740 --> 02:09.740
K啥意思

02:09.740 --> 02:10.740
K表示说

02:10.740 --> 02:13.740
它现在循环的一个次数

02:13.740 --> 02:14.740
啥意思

02:14.740 --> 02:15.740
循环谁的次数

02:15.740 --> 02:16.740
循环Lens

02:16.740 --> 02:17.740
也就是你看

02:17.740 --> 02:18.740
第一个数据

02:18.740 --> 02:19.740
它的Lens是解是3

02:19.740 --> 02:20.740
所以说在这

02:20.740 --> 02:22.740
对象当中就要有一个3

02:22.740 --> 02:24.740
对应的一个K

02:24.740 --> 02:25.740
它的Value是解

02:25.740 --> 02:26.740
是一个2

02:26.740 --> 02:27.740
那2怎么来的

02:27.740 --> 02:30.740
因为现在我这里头一看

02:30.740 --> 02:31.740
Lens为3的数据

02:31.740 --> 02:33.740
有两条1跟2

02:33.740 --> 02:34.740
是不是

02:34.740 --> 02:36.740
所以说它的值就是一个2了

02:36.740 --> 02:37.740
所以你看

02:37.740 --> 02:39.740
K跟Value是这么去统计的

02:39.740 --> 02:40.740
那到5的话

02:40.740 --> 02:41.740
那就表示现在3

02:41.740 --> 02:42.740
那我们的2

02:42.740 --> 02:43.740
它也是3

02:43.740 --> 02:45.740
所以说就包含在这个里头了

02:45.740 --> 02:46.740
在一个对象当中

02:46.740 --> 02:47.740
你是没有办法

02:47.740 --> 02:50.740
给上一个重名的K的

02:50.740 --> 02:51.740
那就到它了

02:51.740 --> 02:52.740
到它之后

02:52.740 --> 02:53.740
它的Lens是解是5

02:53.740 --> 02:55.740
所以K是5

02:55.740 --> 02:56.740
Value是1

02:56.740 --> 02:58.740
因为目前这个数据当中

02:58.740 --> 02:59.740
仅仅只有一条数据

02:59.740 --> 03:00.740
它的Lens为5

03:00.740 --> 03:01.740
所以你看

03:01.740 --> 03:03.740
这个统计结果就出来了

03:03.740 --> 03:04.740
解之完之后

03:04.740 --> 03:05.740
大家就明白了

03:05.740 --> 03:06.740
好

03:06.740 --> 03:07.740
那继续往下

03:07.740 --> 03:10.740
跟它还有一个类似的一个方法

03:10.740 --> 03:13.740
这个方法叫GroupBy

03:13.740 --> 03:19.850
这个GroupBy跟它其实是差不多的

03:19.850 --> 03:20.850
但是就是

03:20.850 --> 03:21.850
他们的区别在哪里了

03:21.850 --> 03:23.850
在于Value

03:23.850 --> 03:25.850
GroupBy它的一个结果

03:25.850 --> 03:26.850
我在这标一下

03:26.850 --> 03:28.850
它的结果当中

03:28.850 --> 03:30.850
K也是一个数字

03:30.850 --> 03:32.850
但是它的Value跟上面不一样

03:32.850 --> 03:34.850
上面的Value是

03:34.850 --> 03:36.850
统计出来数据的一个次数

03:36.850 --> 03:38.850
然后这个Value是啥

03:38.850 --> 03:41.850
就是我统计到的那个数据

03:41.850 --> 03:42.850
知道吧

03:42.850 --> 03:44.850
它都有哪些

03:44.850 --> 03:45.850
来 我们看一下这个结果

03:45.850 --> 03:47.850
在这我们刷新一下

03:47.850 --> 03:49.850
弹出了两个结果

03:49.850 --> 03:50.850
一个是1 2

03:50.850 --> 03:51.850
然后一个是3

03:51.850 --> 03:54.850
我把它

03:54.850 --> 04:00.310
GroupBy

04:00.310 --> 04:02.310
怎么复制呢

04:02.310 --> 04:05.310
3 这样吧

04:05.310 --> 04:06.310
放到这

04:06.310 --> 04:08.310
然后这个是3

04:08.310 --> 04:12.330
放到这

04:12.330 --> 04:13.330
好

04:13.330 --> 04:14.330
这个时候咱们来看一下

04:14.330 --> 04:15.330
你看

04:15.330 --> 04:17.330
这个K跟上面是一模一样的

04:17.330 --> 04:18.330
但是这个Value

04:18.330 --> 04:19.330
是不是就不一样了

04:19.330 --> 04:20.330
而这个Value是啥

04:20.330 --> 04:22.330
3所对应的数据

04:22.330 --> 04:24.330
认死为3的数据

04:24.330 --> 04:25.330
它跟它

04:25.330 --> 04:27.330
所以把它俩放在集合当中

04:27.330 --> 04:29.330
然后无所对应的数据

04:29.330 --> 04:30.330
就是一个3

04:30.330 --> 04:32.330
所以说把它单独的拎出来

04:32.330 --> 04:33.330
好

04:33.330 --> 04:36.330
这个就是两个统计次数的一个方法

04:36.330 --> 04:38.330
好 继续往下吧

04:38.330 --> 04:39.330
继续往下的话

04:39.330 --> 04:41.330
然后咱们说

04:41.330 --> 04:42.330
Each for each

04:42.330 --> 04:43.330
不用说了

04:43.330 --> 04:44.330
循环

04:44.330 --> 04:46.330
我们原生瑞身上也有

04:46.330 --> 04:47.330
然后Each right

04:47.330 --> 04:48.330
跟for each right

04:48.330 --> 04:50.330
就是从倒着来

04:50.330 --> 04:51.330
这个是正着来

04:51.330 --> 04:53.330
它是倒着来

04:53.330 --> 04:55.330
这个Avery跟原生的Avery方法

04:55.330 --> 04:56.330
是一样的

04:56.330 --> 04:57.330
还有Fuelter

04:57.330 --> 04:58.330
是不是也是有

04:58.330 --> 04:59.330
在原生身上

04:59.330 --> 05:01.330
然后以及Fan的

05:01.330 --> 05:02.330
还有Fan的Last

05:02.330 --> 05:03.330
这些都有

05:03.330 --> 05:05.330
这个是找

05:05.330 --> 05:06.330
所以它是正着找

05:06.330 --> 05:08.330
这个是倒着找

05:08.330 --> 05:09.330
好

05:09.330 --> 05:10.330
然后FlightMap

05:10.330 --> 05:11.330
从这开始

05:11.330 --> 05:12.330
这三个

05:12.330 --> 05:13.330
这三个

05:13.330 --> 05:14.330
就是说

05:14.330 --> 05:15.330
这一个在原生的

05:15.330 --> 05:17.330
瑞身上也是有的

05:17.330 --> 05:18.330
FlightMap

05:18.330 --> 05:19.330
你们去看

05:19.330 --> 05:20.330
然后这个地铺

05:20.330 --> 05:22.330
其实我们在上节课有说过

05:22.330 --> 05:23.330
是不是

05:23.330 --> 05:24.330
加了一个地铺

05:24.330 --> 05:25.330
其实就是一个地规

05:25.330 --> 05:26.330
然后一直往里头找

05:26.330 --> 05:28.330
然后再加上这个

05:28.330 --> 05:29.330
其实就是说

05:29.330 --> 05:30.330
我们地规的一个次数

05:30.330 --> 05:31.330
可以给上一个

05:31.330 --> 05:32.330
值

05:32.330 --> 05:33.330
就是不要让它走

05:33.330 --> 05:34.330
全部走

05:34.330 --> 05:35.330
你想让它走几层

05:35.330 --> 05:36.330
就走几层

05:36.330 --> 05:37.330
就是这个意思

05:37.330 --> 05:39.330
所以其实Lowdash当中的这些方法

05:39.330 --> 05:40.330
他们其实

05:40.330 --> 05:41.330
是有规律

05:41.330 --> 05:42.330
可言的

05:43.330 --> 05:44.330
再往下

05:44.330 --> 05:45.330
for each

05:45.330 --> 05:46.330
上面已经说过了

05:46.330 --> 05:47.330
再往下

05:47.330 --> 05:48.330
这group by也说过

05:48.330 --> 05:50.330
然后就是inclose

05:50.330 --> 05:52.330
这个inclose

05:52.330 --> 05:53.330
这个inclose

05:53.330 --> 05:55.330
它其实在我们的原生当中

05:55.330 --> 05:56.330
也是有的

05:56.330 --> 05:57.330
我们就不再去说了

05:57.330 --> 05:58.330
好

05:58.330 --> 05:59.330
然后接下来

05:59.330 --> 06:00.330
这个就没有了

06:00.330 --> 06:01.330
inclose

06:01.330 --> 06:03.330
下面的kby

06:03.330 --> 06:04.330
我们一会去说

06:04.330 --> 06:06.330
我们先说一下

06:08.330 --> 06:09.330
错了

06:09.330 --> 06:16.290
InvokeMap

06:16.290 --> 06:18.290
InvokeMap

06:18.290 --> 06:20.290
它到底是什么作用

06:20.290 --> 06:21.290
它的意思

06:21.290 --> 06:22.290
就是说

06:22.290 --> 06:23.290
我们使用第二个参数

06:23.290 --> 06:24.290
去处理

06:24.290 --> 06:25.290
或者说处理集合

06:25.290 --> 06:26.290
然后

06:26.290 --> 06:28.290
返回处理后的一个结果

06:28.290 --> 06:30.290
我们就直接console.log

06:30.290 --> 06:38.570
点InvokeMap

06:38.570 --> 06:41.140
好

06:41.140 --> 06:42.140
这个里头

06:42.140 --> 06:43.140
我们传上几个数组

06:43.140 --> 06:45.140
这个是517

06:45.140 --> 06:46.140
是吧

06:46.140 --> 06:47.140
然后

06:47.140 --> 06:48.140
第二个

06:48.140 --> 06:50.140
当然这个是一个二维的数组

06:50.140 --> 06:53.220
二维的

06:53.220 --> 06:54.220
然后

06:54.220 --> 06:55.220
这个是

06:57.220 --> 06:59.220
321

06:59.220 --> 07:00.220
二维的一个数组

07:00.220 --> 07:01.220
OK

07:01.220 --> 07:02.220
行

07:02.220 --> 07:03.220
InvokeMap

07:03.220 --> 07:04.220
它的作用

07:04.220 --> 07:05.220
是拿我们的

07:05.220 --> 07:06.220
第二个参数

07:06.220 --> 07:07.220
去处理

07:07.220 --> 07:08.220
处理什么

07:08.220 --> 07:09.220
处理我们的

07:09.220 --> 07:10.220
第一个参数

07:10.220 --> 07:11.220
那第二个参数是什么

07:11.220 --> 07:12.220
比如说

07:12.220 --> 07:13.220
我们给上一个字

07:13.220 --> 07:14.220
叫什么

07:14.220 --> 07:15.220
叫salt

07:15.220 --> 07:16.220
那salt

07:16.220 --> 07:17.220
啥意思

07:17.220 --> 07:19.220
是不是就是排序的意思

07:19.220 --> 07:20.220
那其实

07:20.220 --> 07:21.220
就是说

07:21.220 --> 07:23.220
把它们进行一个排序

07:23.220 --> 07:24.220
那我们来看一下结果

07:24.220 --> 07:25.220
刷新一下

07:25.220 --> 07:26.220
好

07:26.220 --> 07:27.220
点开

07:27.220 --> 07:28.220
你看

07:28.220 --> 07:29.220
这是不是变成了一个

07:29.220 --> 07:30.220
157

07:30.220 --> 07:31.220
第一个

07:31.220 --> 07:32.220
第二个

07:32.220 --> 07:33.220
是不是123

07:33.220 --> 07:34.220
你看

07:34.220 --> 07:35.220
这个不就是排序

07:36.220 --> 07:37.220
所以就是

07:37.220 --> 07:39.220
利用第二个参数

07:39.220 --> 07:40.220
去处理我们的

07:40.220 --> 07:41.220
这个数组

07:41.220 --> 07:43.220
或者说处理这个集合

07:43.220 --> 07:44.220
然后还有

07:44.220 --> 07:45.220
还有另外一个方法

07:45.220 --> 07:46.220
官方当中

07:46.220 --> 07:47.220
还有这么一个方法

07:47.220 --> 07:48.220
那这个方法是啥呢

07:48.220 --> 07:49.220
这个方法

07:49.220 --> 07:50.220
现在我们只需要

07:50.220 --> 07:51.220
不是一个二维数组

07:51.220 --> 07:52.220
一维的数组

07:52.220 --> 07:53.220
123

07:53.220 --> 07:54.220
然后

07:54.220 --> 07:55.220
456

07:55.220 --> 07:56.220
OK

07:56.220 --> 07:57.220
接下来

07:57.220 --> 07:58.220
它的第二个参数

07:58.220 --> 07:59.220
是这么一个东西

07:59.220 --> 08:00.220
就是stream

08:00.220 --> 08:01.220
stream对象

08:01.220 --> 08:02.220
然后呢

08:02.220 --> 08:03.220
它的原型身上

08:03.220 --> 08:04.220
有一个方法叫split

08:04.220 --> 08:06.220
这个是干嘛

08:06.220 --> 08:07.220
是用来

08:07.220 --> 08:08.220
把它们进行一个拆分

08:08.220 --> 08:09.220
拆分成什么的

08:09.220 --> 08:10.220
拆分成一个数组

08:10.220 --> 08:11.220
知道吧

08:11.220 --> 08:12.220
然后接下来

08:12.220 --> 08:14.220
它还有接收第三个参数

08:14.220 --> 08:15.220
那我们先来看

08:15.220 --> 08:16.220
这个结果

08:16.220 --> 08:17.220
刷新一下

08:17.220 --> 08:18.220
这个结果是什么

08:18.220 --> 08:19.220
是这个

08:19.220 --> 08:20.220
123

08:20.220 --> 08:22.660
它们是一个数组

08:22.660 --> 08:23.660
然后

08:23.660 --> 08:24.660
456

08:24.660 --> 08:25.660
又是一个数组

08:25.660 --> 08:26.660
放到这

08:26.660 --> 08:27.660
好

08:27.660 --> 08:28.660
来解释一下

08:28.660 --> 08:29.660
这缺了一个

08:29.660 --> 08:30.660
扩号

08:30.660 --> 08:31.660
解释一下

08:31.660 --> 08:32.660
那这个是什么意思

08:32.660 --> 08:34.660
它总共有三个参数

08:34.660 --> 08:35.660
三个参数的意思

08:35.660 --> 08:36.660
就是说

08:36.660 --> 08:37.660
你看我们那个

08:37.660 --> 08:38.660
还是不变的

08:38.660 --> 08:39.660
它的原意是不变

08:39.660 --> 08:40.660
就是拿第二个参数

08:40.660 --> 08:42.660
去处理我们的

08:42.660 --> 08:43.660
第一个参数

08:43.660 --> 08:44.660
然后你传了

08:44.660 --> 08:45.660
第三个参数

08:45.660 --> 08:46.660
OK

08:46.660 --> 08:47.660
那就是说

08:47.660 --> 08:48.660
这个第二个方法

08:48.660 --> 08:49.660
它需要去接收参数

08:49.660 --> 08:50.660
那就是

08:50.660 --> 08:51.660
接收什么参数

08:51.660 --> 08:52.660
你把它当作

08:52.660 --> 08:53.660
第三个参数

08:53.660 --> 08:54.660
这样的话

08:54.660 --> 08:55.660
它调用的时候

08:55.660 --> 08:56.660
会把这个值

08:56.660 --> 08:57.660
作为一个参数

08:57.660 --> 08:58.660
丢到这个方法

08:58.660 --> 08:59.660
再去处理

08:59.660 --> 09:00.660
第一个参数

09:00.660 --> 09:01.660
就是这么一个逻辑

09:01.660 --> 09:02.660
好

09:02.660 --> 09:04.660
这个就是一个invoke-map

09:06.660 --> 09:07.660
往下说

09:07.660 --> 09:09.660
然后就是一个k-by了

09:09.660 --> 09:14.310
那这个k-by

09:14.310 --> 09:15.310
k-by它的一个作用

09:15.310 --> 09:17.310
是创建一个对象

09:17.310 --> 09:18.310
然后

09:18.310 --> 09:19.310
里面的k

09:19.310 --> 09:21.310
是由第二个参数

09:21.310 --> 09:22.310
来决定的

09:22.310 --> 09:23.310
然后

09:23.310 --> 09:24.310
value是

09:24.310 --> 09:25.310
原数组当中

09:25.310 --> 09:27.310
对应的那条数据

09:27.310 --> 09:28.310
好

09:28.310 --> 09:29.310
这个东西

09:29.310 --> 09:30.310
我们需要去用一下

09:31.310 --> 09:32.310
这个例子

09:32.310 --> 09:33.310
来拿这个东西

09:33.310 --> 09:34.310
我们console一下

09:34.310 --> 09:35.310
算生命个变量

09:36.310 --> 09:37.310
result

09:37.310 --> 09:38.310
等于什么

09:38.310 --> 09:41.310
直接去调k-by这个方法

09:41.310 --> 09:43.750
然后

09:44.750 --> 09:45.750
这个当作第一个参数

09:45.750 --> 09:46.750
然后

09:46.750 --> 09:47.750
第二个参数

09:47.750 --> 09:48.750
注意第二个参数

09:48.750 --> 09:49.750
给上一个方法

09:49.750 --> 09:50.750
faction

09:50.750 --> 09:51.750
接收什么

09:51.750 --> 09:52.750
接收一个o

09:52.750 --> 09:53.750
其实第二个参数

09:53.750 --> 09:54.750
就是一个迭代器的

09:54.750 --> 09:55.750
这么一个方法

09:55.750 --> 09:56.750
那就是说

09:56.750 --> 09:57.750
会把瑞当中

09:57.750 --> 09:58.750
每一条数据

09:58.750 --> 10:00.750
都丢到这个方法当中

10:00.750 --> 10:01.750
进行一个迭代

10:01.750 --> 10:03.750
然后这个方法当中

10:03.750 --> 10:04.750
你要return一个数据

10:04.750 --> 10:05.750
什么数据

10:05.750 --> 10:06.750
stream

10:06.750 --> 10:07.750
stream身上有一个方法

10:07.750 --> 10:08.750
from

10:08.750 --> 10:09.750
charcode

10:09.750 --> 10:10.750
这个方法

10:10.750 --> 10:11.750
然后把谁丢进去

10:11.750 --> 10:12.750
把old

10:12.750 --> 10:13.750
code丢进来

10:13.750 --> 10:14.750
好

10:14.750 --> 10:15.750
解释一下

10:15.750 --> 10:16.750
这个方法

10:16.750 --> 10:17.750
调了一下stream身上的

10:17.750 --> 10:18.750
这个方法

10:18.750 --> 10:19.750
这个方法是干嘛

10:19.750 --> 10:20.750
就是说

10:20.750 --> 10:21.750
把我们的这个字符串

10:21.750 --> 10:23.750
解析成一个unico

10:23.750 --> 10:24.750
从那个unico代码

10:24.750 --> 10:26.750
给它解析成一个什么

10:26.750 --> 10:28.750
解析成一个真正的一个字符

10:28.750 --> 10:29.750
那么

10:29.750 --> 10:30.750
code的

10:30.750 --> 10:31.750
官方给的这个例子

10:31.750 --> 10:32.750
code的其实对应的

10:32.750 --> 10:33.750
就是一个unico的

10:33.750 --> 10:35.750
一个字符

10:35.750 --> 10:37.750
所对应的一个unico的

10:37.750 --> 10:38.750
那个码值

10:38.750 --> 10:39.750
明白吗

10:39.750 --> 10:40.750
所以你看

10:40.750 --> 10:41.750
这样的话

10:41.750 --> 10:42.750
刚才咱们说

10:42.750 --> 10:43.750
它的第二个参数是啥

10:43.750 --> 10:44.750
它的k

10:44.750 --> 10:46.750
我们这个结果的k

10:46.750 --> 10:48.750
其实就是第二个参数

10:48.750 --> 10:50.750
然后k所对应的一个值

10:50.750 --> 10:51.750
是啥

10:51.750 --> 10:53.750
就是你解析出来的这个东西

10:53.750 --> 10:55.750
在元数组当中

10:55.750 --> 10:56.750
哪一条数据

10:56.750 --> 10:58.750
当中你就把这条数据

10:58.750 --> 11:00.750
作为它的一个value

11:00.750 --> 11:06.110
我们来看一下console

11:06.110 --> 11:07.110
con-slog

11:07.110 --> 11:12.790
这个result

11:12.790 --> 11:14.790
在这我们刷新走着

11:14.790 --> 11:15.790
好点开

11:15.790 --> 11:16.790
看到没

11:16.790 --> 11:18.790
是不是现在97对应的一个字符

11:18.790 --> 11:19.790
那就是一个a

11:19.790 --> 11:20.790
那你看

11:20.790 --> 11:21.790
a就作为一个k

11:21.790 --> 11:22.790
那a

11:22.790 --> 11:23.790
它是不是

11:23.790 --> 11:24.790
这条数据当中

11:24.790 --> 11:25.790
所以说你看

11:25.790 --> 11:26.790
它的value其实就是

11:26.790 --> 11:28.790
d0条数据

11:28.790 --> 11:29.790
然后这个100

11:29.790 --> 11:30.790
对应的是d

11:30.790 --> 11:31.790
d你看

11:31.790 --> 11:32.790
它所在的数据

11:32.790 --> 11:33.790
也就是这个code的

11:33.790 --> 11:34.790
所在数据

11:34.790 --> 11:35.790
是不是

11:35.790 --> 11:37.790
所以d是k

11:37.790 --> 11:38.790
然后这条数据

11:38.790 --> 11:39.790
就是它的一个value

11:39.790 --> 11:40.790
这个其实就是一个

11:40.790 --> 11:42.790
k-bite的这么一个方法

11:42.790 --> 11:45.300
那这个方法

11:45.300 --> 11:47.300
其实我们还可以

11:47.300 --> 11:49.300
再来一个console

11:49.300 --> 11:50.300
log什么

11:50.300 --> 11:51.300
直接点k-bite

11:51.300 --> 11:53.300
然后这个时候

11:55.300 --> 11:56.300
这个是不会变的

11:56.300 --> 11:57.300
第二个

11:57.300 --> 11:59.300
我们可以给上一个di

11:59.300 --> 12:00.300
这个di

12:00.300 --> 12:01.300
啥意思

12:01.300 --> 12:02.300
其实也就是说

12:02.300 --> 12:03.300
去我的数据当中

12:03.300 --> 12:05.300
去取di

12:05.300 --> 12:06.300
数据

12:06.300 --> 12:07.300
它的一个value

12:07.300 --> 12:08.300
那就是left

12:08.300 --> 12:09.300
跟right

12:09.300 --> 12:10.300
所以说

12:10.300 --> 12:11.300
这个对象

12:11.300 --> 12:12.300
生成出来的对象

12:12.300 --> 12:13.300
他们的k

12:13.300 --> 12:14.300
是啥

12:14.300 --> 12:15.300
是left跟right

12:15.300 --> 12:16.300
那它的value

12:16.300 --> 12:17.300
是不会变的

12:17.300 --> 12:18.300
就是它们所在的

12:18.300 --> 12:19.300
那条数据

12:19.300 --> 12:20.300
来刷新一下

12:20.300 --> 12:21.300
点击

12:21.300 --> 12:22.300
你看是不是left

12:22.300 --> 12:23.300
对应的就是97的那条

12:23.300 --> 12:24.300
right对应的就是

12:24.300 --> 12:25.300
100的那条

12:25.300 --> 12:26.300
好

12:26.300 --> 12:28.300
这个就是k-bite

12:30.670 --> 12:31.670
然后我们再来

12:31.670 --> 12:32.670
回到api当中

12:32.670 --> 12:33.670
k-bite说完之后

12:33.670 --> 12:35.670
是一个map这个方法

12:35.670 --> 12:36.670
在我们的原生

12:36.670 --> 12:38.670
right身上是有的

12:38.670 --> 12:39.670
到时候你去参考

12:39.670 --> 12:40.670
他们身上的那个方法

12:40.670 --> 12:41.670
好吧

12:41.670 --> 12:42.670
然后接下来

12:42.670 --> 12:43.670
就是outbite

12:43.670 --> 12:45.670
那outbite

12:45.670 --> 12:47.670
它其实是用来排序的

12:47.670 --> 12:48.670
outbite

12:48.670 --> 12:49.670
以及还有一个soutbite

12:49.670 --> 12:50.670
这两个

12:50.670 --> 12:53.670
我们一堆说一下outbite

12:53.670 --> 12:55.670
用来做排序的

12:55.670 --> 12:56.670
那这个数据

12:56.670 --> 12:57.670
我们还得用一下

12:57.670 --> 13:03.300
人家这个官方的排序

13:03.300 --> 13:05.300
直接cancelogue

13:09.020 --> 13:11.020
outbite

13:11.020 --> 13:12.020
调一下这个方法

13:13.020 --> 13:14.020
来

13:14.020 --> 13:15.020
接收三个参数

13:15.020 --> 13:16.020
第一个参数

13:16.020 --> 13:18.020
你要排序的是谁

13:18.020 --> 13:19.020
Youters

13:19.020 --> 13:20.020
排序的是他

13:20.020 --> 13:22.020
然后第二个参数

13:22.020 --> 13:24.020
你以谁为准进行排序

13:24.020 --> 13:26.020
那我就用他的属性

13:26.020 --> 13:27.020
一个属性

13:27.020 --> 13:28.020
叫H的这条属性

13:28.020 --> 13:29.020
进行一个排序

13:29.020 --> 13:30.020
然后

13:30.020 --> 13:31.020
这个排序有生序

13:31.020 --> 13:32.020
还有降序

13:32.020 --> 13:33.020
降序

13:33.020 --> 13:34.020
你用哪个方法

13:34.020 --> 13:36.020
ASC对应的是什么

13:36.020 --> 13:37.020
生序

13:37.020 --> 13:38.020
排

13:38.020 --> 13:39.020
知道吧

13:39.020 --> 13:40.020
我们先来看一下

13:40.020 --> 13:41.020
来

13:41.020 --> 13:42.020
结果在这刷新一下

13:42.020 --> 13:43.020
点开

13:43.020 --> 13:44.020
之后是不是说

13:44.020 --> 13:45.020
3434448

13:45.020 --> 13:46.020
你看看是吧

13:46.020 --> 13:47.020
按照什么

13:47.020 --> 13:48.020
按照H的

13:48.020 --> 13:49.020
这条属性的值

13:49.020 --> 13:50.020
进行一个排序

13:50.020 --> 13:51.020
然后另外一个

13:51.020 --> 13:52.020
我们可以选择

13:52.020 --> 13:53.020
User当中

13:53.020 --> 13:54.020
User

13:54.020 --> 13:55.020
User当中

13:55.020 --> 13:56.020
US1

13:56.020 --> 13:57.020
按照他来排序

13:57.020 --> 13:58.020
什么序

13:58.020 --> 13:59.020
降序

13:59.020 --> 14:00.020
DESC

14:00.020 --> 14:01.020
这个是降序

14:01.020 --> 14:02.020
再来看刷新一下

14:02.020 --> 14:03.020
这个时候

14:03.020 --> 14:04.020
你看

14:04.020 --> 14:05.020
是不是前两个

14:05.020 --> 14:06.020
是相等的

14:06.020 --> 14:07.020
这一支

14:07.020 --> 14:08.020
它其实就不是一个

14:08.020 --> 14:09.020
DESC

14:09.020 --> 14:10.020
或者说D减的

14:10.020 --> 14:12.530
这么一个顺序

14:12.530 --> 14:13.530
这个

14:13.530 --> 14:14.530
奥德败

14:14.530 --> 14:16.530
跟他相对应的

14:16.530 --> 14:17.530
一个方法叫

14:17.530 --> 14:18.530
SaltBuy

14:18.530 --> 14:19.530
SaltBuy

14:19.530 --> 14:20.530
这个SaltBuy

14:20.530 --> 14:21.530
它也是用来排序的

14:21.530 --> 14:22.530
但是

14:22.530 --> 14:23.530
它的区别在哪里

14:23.530 --> 14:24.530
区别就是

14:24.530 --> 14:25.530
SaltBuy

14:25.530 --> 14:26.530
它只能够

14:26.530 --> 14:27.530
进行生序的排

14:27.530 --> 14:28.530
来

14:28.530 --> 14:31.350
console.log

14:31.350 --> 14:32.350
log什么

14:32.350 --> 14:33.350
log

14:33.350 --> 14:36.860
SaltBuy

14:36.860 --> 14:37.860
我把

14:37.860 --> 14:38.860
还是以User

14:38.860 --> 14:39.860
为准

14:39.860 --> 14:41.860
然后接上了Faction

14:41.860 --> 14:42.860
第二个

14:42.860 --> 14:43.860
它是一个Faction

14:43.860 --> 14:44.860
怎么一个参数

14:44.860 --> 14:46.860
其实跟我们原生的Salt

14:46.860 --> 14:47.860
差不多

14:47.860 --> 14:48.860
Return

14:48.860 --> 14:49.860
Return什么呢

14:49.860 --> 14:50.860
Return

14:50.860 --> 14:53.360
O.User

14:53.360 --> 14:54.360
来看一下

14:54.360 --> 14:55.360
来刷新一下

14:55.360 --> 14:56.360
其实你看

14:56.360 --> 14:57.360
用User去排序的话

14:57.360 --> 14:58.360
排的是啥

14:58.360 --> 14:59.360
排的就是他们这里头

14:59.360 --> 15:00.360
字符

15:00.360 --> 15:02.360
所对应的Unicle马直

15:02.360 --> 15:03.360
看到吗

15:03.360 --> 15:04.360
好

15:04.360 --> 15:05.360
你看他这个马直

15:05.360 --> 15:07.360
绝对是比F要小

15:07.360 --> 15:09.360
所以他排在了前边

15:09.360 --> 15:10.360
然后他排在了后边

15:10.360 --> 15:12.360
这个就是SaltBuy

15:12.360 --> 15:13.360
SaltBuy

15:13.360 --> 15:14.360
其实跟我们的

15:14.360 --> 15:15.360
原生Salt

15:15.360 --> 15:16.360
是一模一样的

15:16.360 --> 15:17.360
好

15:17.360 --> 15:19.360
两种排序的方式

15:19.360 --> 15:21.360
说完这个之后

15:21.360 --> 15:22.360
再往下来

15:22.360 --> 15:23.360
这个东西

15:23.360 --> 15:24.360
它是用来分

15:24.360 --> 15:25.360
分什么

15:25.360 --> 15:26.360
拆分数组的

15:26.360 --> 15:28.360
它能够把这个数组

15:28.360 --> 15:29.360
给你拆分成

15:29.360 --> 15:30.360
一个二维的一个数组

15:30.360 --> 15:31.360
我们看一下

15:31.360 --> 15:32.360
这个方法

15:33.360 --> 15:35.360
这不能是分好

15:35.360 --> 15:36.360
这应该是斗好

15:36.360 --> 15:41.530
那我还得用人家的

15:41.530 --> 15:42.530
这个例子

15:44.530 --> 15:46.530
直接console.log

15:46.530 --> 15:49.350
log

15:49.350 --> 15:50.350
我们直接去调它

15:50.350 --> 15:52.980
好

15:52.980 --> 15:53.980
这个里头

15:53.980 --> 15:55.980
我们要拆数据

15:55.980 --> 15:56.980
你知道吧

15:56.980 --> 15:58.980
它会拆成一个

15:58.980 --> 15:59.980
二维的数组

15:59.980 --> 16:00.980
怎么去拆

16:00.980 --> 16:02.980
把相同类型的

16:02.980 --> 16:03.980
或者说

16:03.980 --> 16:04.980
或者说相同属性的

16:04.980 --> 16:05.980
反正他们按照一定规则

16:05.980 --> 16:06.980
反正这两条数据

16:06.980 --> 16:07.980
它是一样的

16:07.980 --> 16:08.980
OK

16:08.980 --> 16:10.980
把它俩放在一个数据

16:10.980 --> 16:11.980
当中

16:11.980 --> 16:12.980
一个集合当中

16:12.980 --> 16:13.980
然后另外那些

16:13.980 --> 16:14.980
在单独的放在

16:14.980 --> 16:15.980
另外的一个集合当中

16:15.980 --> 16:16.980
懂吧

16:16.980 --> 16:17.980
来我们看一下

16:17.980 --> 16:18.980
第一个参数

16:18.980 --> 16:19.980
就是你要对谁

16:19.980 --> 16:20.980
进行一个拆分

16:20.980 --> 16:21.980
就是他

16:21.980 --> 16:23.980
他是一个集合

16:23.980 --> 16:24.980
然后

16:24.980 --> 16:25.980
第二个参数

16:25.980 --> 16:26.980
就是你要拆分的

16:26.980 --> 16:27.980
一种形式

16:27.980 --> 16:28.980
你按照什么去拆

16:28.980 --> 16:29.980
它也是一个faction

16:29.980 --> 16:30.980
然后这接收一个参数

16:30.980 --> 16:31.980
其实也是一个

16:31.980 --> 16:32.980
迭代器

16:32.980 --> 16:33.980
你知道吧

16:33.980 --> 16:34.980
然后return

16:34.980 --> 16:35.980
O点

16:35.980 --> 16:36.980
active

16:36.980 --> 16:37.980
每一条数据当中

16:37.980 --> 16:38.980
是不是有一个active

16:38.980 --> 16:39.980
这条参数

16:39.980 --> 16:40.980
其实

16:40.980 --> 16:42.980
它拆分的一句是啥

16:42.980 --> 16:43.980
它的一个值

16:43.980 --> 16:44.980
也就是把active

16:44.980 --> 16:46.980
值相等的放在一起

16:46.980 --> 16:47.980
不等的

16:47.980 --> 16:48.980
在单独的放在一起

16:48.980 --> 16:49.980
再来看一下

16:49.980 --> 16:50.980
我们去点开

16:50.980 --> 16:51.980
这个时候

16:51.980 --> 16:52.980
第一个当中是不是一个处

16:52.980 --> 16:53.980
active为处

16:53.980 --> 16:54.980
第二个当中

16:54.980 --> 16:55.980
你看active

16:55.980 --> 16:56.980
false false

16:56.980 --> 16:57.980
两人是不是放在了一堆了

16:57.980 --> 16:59.980
这个就是拆分

16:59.980 --> 17:00.980
拆分成了一个

17:00.980 --> 17:02.980
二维的一个数组

17:02.980 --> 17:03.980
然后再来

17:03.980 --> 17:04.980
我们还可以

17:04.980 --> 17:05.980
再变的花样来

17:06.980 --> 17:07.980
变什么花样

17:07.980 --> 17:08.980
就是

17:08.980 --> 17:09.980
这个参数

17:09.980 --> 17:10.980
我们可以

17:10.980 --> 17:11.980
不给上一个函数

17:11.980 --> 17:12.980
我们给上一个对象

17:12.980 --> 17:13.980
对象也是OK的

17:13.980 --> 17:14.980
然后

17:14.980 --> 17:15.980
H

17:15.980 --> 17:17.980
我就给上一个

17:17.980 --> 17:18.980
数据

17:18.980 --> 17:19.980
这个数据

17:19.980 --> 17:20.980
它其实是用来

17:20.980 --> 17:21.980
在我的原数据

17:21.980 --> 17:23.980
进行一个查找

17:23.980 --> 17:24.980
然后查找

17:24.980 --> 17:25.980
到之后

17:25.980 --> 17:26.980
就以这个为准

17:26.980 --> 17:27.980
进行一个拆分

17:27.980 --> 17:28.980
你看

17:28.980 --> 17:29.980
H为一

17:29.980 --> 17:30.980
是不是说

17:30.980 --> 17:31.980
指的是这条数据

17:31.980 --> 17:32.980
也就是说

17:32.980 --> 17:36.550
这条数据

17:36.550 --> 17:37.550
这条数据

17:37.550 --> 17:38.550
我们给的这个规则

17:38.550 --> 17:39.550
是找到了这条数据

17:39.550 --> 17:40.550
也就是

17:40.550 --> 17:41.550
这条数据

17:41.550 --> 17:42.550
单独放在一起

17:42.550 --> 17:43.550
它的

17:43.550 --> 17:44.550
它们

17:44.550 --> 17:45.550
合并放在一起

17:45.550 --> 17:46.550
再来看

17:46.550 --> 17:47.550
刷新一下

17:47.550 --> 17:48.550
走

17:48.550 --> 17:49.550
是不是

17:49.550 --> 17:50.550
E为False的这个

17:50.550 --> 17:51.550
然后

17:51.550 --> 17:52.550
这个第二个集合当中

17:52.550 --> 17:53.550
你看是不是那两条

17:53.550 --> 17:55.550
除去的那个规则

17:55.550 --> 17:57.550
就是这么一个意思

17:57.550 --> 17:58.550
好

17:58.550 --> 17:59.550
那关于这个

17:59.550 --> 18:00.550
拆分二维数组

18:00.550 --> 18:01.550
咱们就说到这

18:01.550 --> 18:02.550
往下

18:02.550 --> 18:03.550
Reduce

18:03.550 --> 18:04.550
Reduce

18:04.550 --> 18:05.550
跟我们原生

18:05.550 --> 18:06.550
而瑞身上的

18:06.550 --> 18:07.550
Reduce是一模一样的

18:07.550 --> 18:08.550
就不再去说了

18:08.550 --> 18:09.550
还有一集

18:09.550 --> 18:10.550
ReduceRise

18:10.550 --> 18:11.550
也是一样的

18:11.550 --> 18:12.550
都有

18:12.550 --> 18:13.550
往下走

18:13.550 --> 18:14.550
我们说到

18:14.550 --> 18:15.550
Redact

18:15.550 --> 18:16.550
Redact

18:16.550 --> 18:17.550
它是干嘛

18:17.550 --> 18:18.550
它其实

18:18.550 --> 18:19.550
Filter

18:19.550 --> 18:20.550
知道吧

18:20.550 --> 18:21.550
Filter那个方法

18:21.550 --> 18:22.550
虽然说我们没有写

18:22.550 --> 18:23.550
没有写

18:23.550 --> 18:24.550
对吧

18:24.550 --> 18:25.550
没有讲

18:25.550 --> 18:26.550
它应该是知道的

18:26.550 --> 18:27.550
就是用来过滤这个数组的

18:27.550 --> 18:28.550
就是

18:28.550 --> 18:29.550
把什么

18:29.550 --> 18:30.550
把我们的集合当中

18:30.550 --> 18:31.550
条件为真

18:31.550 --> 18:32.550
当然这个条件

18:32.550 --> 18:33.550
至于条件怎么给

18:33.550 --> 18:35.550
这就随心所欲了

18:35.550 --> 18:36.550
满足为处的话

18:36.550 --> 18:37.550
那就把它过滤掉

18:37.550 --> 18:38.550
这个方法

18:38.550 --> 18:39.550
刚好跟它是相反的

18:39.550 --> 18:40.550
就是说

18:41.550 --> 18:42.550
那我就跟你相反

18:42.550 --> 18:43.550
过滤为假的就行了

18:43.550 --> 18:44.550
来

18:44.550 --> 18:45.550
Redact

18:45.550 --> 18:48.760
还用一下

18:48.760 --> 18:49.760
人家的变量

18:49.760 --> 18:50.760
User

18:50.760 --> 18:51.760
放到这

18:51.760 --> 18:54.070
在这我们直接

18:54.070 --> 18:56.070
console.log

18:57.070 --> 18:58.070
它里头

18:58.070 --> 18:59.070
第二个参数

18:59.070 --> 19:01.070
就是可以有多种形式

19:01.070 --> 19:02.070
来

19:02.070 --> 19:04.700
Redact

19:04.700 --> 19:05.700
第一个参数

19:05.700 --> 19:07.700
就是你要去过滤的

19:07.700 --> 19:08.700
数组

19:08.700 --> 19:09.700
或者说集合

19:09.700 --> 19:10.700
User

19:10.700 --> 19:11.700
然后第二个参数

19:11.700 --> 19:13.700
就是你要过滤的一个规则

19:14.700 --> 19:15.700
那我们在这

19:15.700 --> 19:16.700
给上一个方法

19:16.700 --> 19:17.700
给上一个函数

19:17.700 --> 19:18.700
然后这个函数当中

19:18.700 --> 19:19.700
我们直接return

19:22.700 --> 19:24.700
我们先来看这个结果

19:24.700 --> 19:26.700
在这咱们走着

19:26.700 --> 19:31.490
console又错了

19:31.490 --> 19:32.490
刷新一下

19:32.490 --> 19:33.490
点击

19:33.490 --> 19:34.490
点击之后

19:34.490 --> 19:35.490
这个里头

19:35.490 --> 19:36.490
有一个false

19:36.490 --> 19:37.490
看到吗

19:37.490 --> 19:38.490
那什么意思

19:38.490 --> 19:39.490
其实就是说

19:40.490 --> 19:41.490
跟它

19:41.490 --> 19:42.490
我们

19:42.490 --> 19:43.490
filter

19:43.490 --> 19:44.490
它是为处

19:44.490 --> 19:45.490
给它过滤掉

19:45.490 --> 19:47.490
把false给它过滤掉

19:47.490 --> 19:48.490
懂吗

19:48.490 --> 19:49.490
随说

19:49.490 --> 19:50.490
圣的内容

19:50.490 --> 19:52.490
就是这个

19:52.490 --> 19:53.490
跟我们的filter

19:53.490 --> 19:54.490
是相反的

19:54.490 --> 19:55.490
来

19:55.490 --> 19:56.490
继续

19:56.490 --> 19:57.490
再来

19:57.490 --> 19:58.490
这个东西

19:58.490 --> 19:59.490
就是演示一下

19:59.490 --> 20:00.490
就知道了

20:00.490 --> 20:01.490
然后第二种形式

20:01.490 --> 20:02.490
就是

20:02.490 --> 20:03.490
这个里头

20:03.490 --> 20:04.490
我们可以放对象

20:04.490 --> 20:06.490
并不是要放什么

20:06.490 --> 20:08.490
放函数了

20:08.490 --> 20:11.380
然后

20:11.380 --> 20:12.380
对象

20:12.380 --> 20:13.380
怎么去放

20:13.380 --> 20:14.380
放这个

20:14.380 --> 20:16.380
放一个h

20:16.380 --> 20:19.380
为36

20:19.380 --> 20:20.380
然后

20:20.380 --> 20:21.380
active

20:21.380 --> 20:25.140
为2

20:25.140 --> 20:26.140
active为2

20:26.140 --> 20:27.140
好

20:27.140 --> 20:28.140
这时候

20:28.140 --> 20:29.140
我们再来看

20:29.140 --> 20:30.140
刷新一下

20:30.140 --> 20:33.220
这个结果

20:33.220 --> 20:34.220
是啥

20:34.220 --> 20:35.220
第2个

20:35.220 --> 20:36.220
等一下

20:36.220 --> 20:38.220
这有点乱

20:38.220 --> 20:40.220
应该是点开它

20:40.220 --> 20:42.220
点开它

20:44.220 --> 20:45.220
其实

20:45.220 --> 20:46.220
不对

20:46.220 --> 20:48.850
72

20:48.850 --> 20:52.700
为2

20:52.700 --> 20:58.700
h为

20:58.700 --> 20:59.700
30

20:59.700 --> 21:01.700
这个好像有一些问题

21:01.700 --> 21:02.700
等一下

21:02.700 --> 21:04.700
我先把它注释掉

21:04.700 --> 21:05.700
刷新一下

21:05.700 --> 21:10.100
这个怎么弹出来了

21:10.100 --> 21:11.100
两个呢

21:11.100 --> 21:13.790
users

21:13.790 --> 21:15.790
h为36

21:15.790 --> 21:16.790
active为2

21:16.790 --> 21:18.790
把它过滤掉

21:18.790 --> 21:19.790
这个时候

21:19.790 --> 21:20.790
结果怎么

21:20.790 --> 21:29.290
会有两条呢

21:29.290 --> 21:30.290
users

21:30.290 --> 21:31.290
黑

21:31.290 --> 21:38.340
reject

21:38.340 --> 21:39.340
稍等一下

21:39.340 --> 21:40.340
我先

21:40.340 --> 21:41.340
这个

21:41.340 --> 21:43.340
再来一个

21:43.340 --> 21:45.340
reject

21:45.340 --> 21:46.340
这

21:46.340 --> 21:47.340
users

21:47.340 --> 21:48.340
我们的这个参数

21:48.340 --> 21:49.340
使用这个

21:49.340 --> 21:57.260
使用数组

21:57.260 --> 21:58.260
点

21:58.260 --> 22:08.900
user

22:08.900 --> 22:09.900
我先看一下

22:09.900 --> 22:10.900
这个对不对

22:10.900 --> 22:11.900
刷新一下

22:11.900 --> 22:12.900
点开

22:12.900 --> 22:14.900
它倒是对着呢

22:14.900 --> 22:17.900
把这条给它过滤掉

22:17.900 --> 22:19.900
过滤掉

22:19.900 --> 22:20.900
过滤掉

22:20.900 --> 22:22.900
但是这个方法倒是有问题

22:22.900 --> 22:23.900
这样吧

22:23.900 --> 22:24.900
咱这个方法先留着

22:24.900 --> 22:25.900
一会我下去看一下

22:26.900 --> 22:27.900
看一下

22:27.900 --> 22:28.900
是哪块出问题了

22:28.900 --> 22:29.900
那这个呢

22:29.900 --> 22:30.900
就是说

22:30.900 --> 22:31.900
我们的user

22:31.900 --> 22:32.900
当中呢去找

22:32.900 --> 22:33.900
找找

22:33.900 --> 22:34.900
从这个users

22:34.900 --> 22:35.900
当中呢找

22:35.900 --> 22:36.900
这是k

22:36.900 --> 22:37.900
这是value

22:37.900 --> 22:38.900
就是找这条

22:38.900 --> 22:39.900
那么找到它了

22:39.900 --> 22:40.900
然后呢就把它

22:40.900 --> 22:41.900
给它过滤掉了

22:41.900 --> 22:42.900
懂吗

22:42.900 --> 22:43.900
好

22:43.900 --> 22:44.900
然后呢

22:44.900 --> 22:45.900
还有另外一种写法呢

22:45.900 --> 22:46.900
就是

22:46.900 --> 22:47.900
这里头呢

22:47.900 --> 22:48.900
我直接就是数组也不给了

22:48.900 --> 22:49.900
直接给上一个自付串了

22:49.900 --> 22:50.900
自付串呢

22:50.900 --> 22:51.900
就是一个h

22:51.900 --> 22:52.900
然后呢

22:52.900 --> 22:53.900
再来看刷新一下

22:53.900 --> 22:54.900
h

22:54.900 --> 22:55.900
它都找到了之后呢

22:55.900 --> 22:57.900
全部给它过滤掉了

22:57.900 --> 22:58.900
好

22:58.900 --> 22:59.900
那这个剩上这个呢

22:59.900 --> 23:00.900
咱们下节课再去说吧

23:00.900 --> 23:02.900
不耽误时间啊

23:02.900 --> 23:03.900
然后呢再来

23:03.900 --> 23:05.900
这个方法啊

23:05.900 --> 23:06.900
继续往下呢

23:06.900 --> 23:08.900
就是这个

23:08.900 --> 23:09.900
那这个是干嘛

23:09.900 --> 23:10.900
这个呢是随机数啊

23:10.900 --> 23:12.900
这个呢其实是很重要的

23:12.900 --> 23:13.900
因为我们其实

23:13.900 --> 23:15.900
经常会用到这个随机数啊

23:15.900 --> 23:16.900
那这个随机数呢

23:16.900 --> 23:18.900
其实就是在这儿

23:18.900 --> 23:19.900
我们使用这个方法呢

23:19.900 --> 23:21.900
就能够从我们的数据当中呢

23:21.900 --> 23:23.900
随机的去取出来一条数据

23:23.900 --> 23:26.900
来先写上一些数据

23:26.900 --> 23:30.590
比如说这几个数据

23:30.590 --> 23:31.590
那丢进来之后呢

23:31.590 --> 23:32.590
我们在这儿看啊

23:32.590 --> 23:33.590
来刷新一下

23:33.590 --> 23:35.590
这次呢唯一

23:35.590 --> 23:36.590
然后呢刷新

23:36.590 --> 23:38.590
每次呢其实都是不一样的

23:38.590 --> 23:39.590
因为它是一个随机

23:39.590 --> 23:40.590
你知道吧

23:40.590 --> 23:41.590
然后这个呢是

23:41.590 --> 23:43.590
每一次的随机都是不一样的

23:43.590 --> 23:44.590
好随机

23:44.590 --> 23:45.590
然后呢再来这个方法呢

23:45.590 --> 23:47.590
它还有很多一些

23:47.590 --> 23:48.590
相应

23:48.590 --> 23:50.590
相应配置的一些参数啊

23:50.590 --> 23:51.590
比如说这个size呢

23:51.590 --> 23:52.590
这个size呢

23:52.590 --> 23:53.590
其实啥意思啊

23:53.590 --> 23:54.590
就是说

23:54.590 --> 23:56.590
我们现在默认情况下

23:56.590 --> 23:58.590
它只能随机出来一个数据

23:58.590 --> 23:59.590
那在这儿呢

23:59.590 --> 24:01.590
我要再给它来上一个参数

24:01.590 --> 24:02.590
比如说是

24:02.590 --> 24:03.590
比如说是3

24:03.590 --> 24:05.590
那它就能够给我一下随机

24:05.590 --> 24:10.570
出来3条数据

24:10.570 --> 24:11.570
来刷新走

24:11.570 --> 24:12.570
你看

24:12.570 --> 24:13.570
是不是3条数据啊

24:13.570 --> 24:14.570
然后每一次

24:14.570 --> 24:16.570
它都是一个随机的啊

24:16.570 --> 24:18.570
这是size

24:18.570 --> 24:19.570
size有了之后

24:19.570 --> 24:20.570
接着呢

24:20.570 --> 24:22.570
往下就是一个随机排序了啊

24:22.570 --> 24:23.570
这个呢

24:23.570 --> 24:25.570
还是比较重要的啊

24:26.570 --> 24:28.570
在我们写这个页面的时候呢

24:28.570 --> 24:29.570
有的时候呢

24:29.570 --> 24:30.570
很多的一些功能

24:30.570 --> 24:31.570
效果呢

24:31.570 --> 24:33.570
都是需要用到一个随机去排序的

24:33.570 --> 24:34.570
这么一个效果

24:34.570 --> 24:35.570
那我们来看一下

24:35.570 --> 24:41.060
console.log

24:41.060 --> 24:42.060
这个里头

24:42.060 --> 24:45.060
我们还传上这个值

24:45.060 --> 24:48.060
看一下它的结果啊

24:48.060 --> 24:49.060
来刷新

24:49.060 --> 24:50.060
你看

24:50.060 --> 24:51.060
这里头数据

24:51.060 --> 24:52.060
他们的一个排序的情况

24:52.060 --> 24:54.060
就是一个随机的

24:54.060 --> 24:55.060
每一次呢

24:55.060 --> 24:56.060
基本上都是不一样的

24:56.060 --> 24:57.060
好

24:57.060 --> 24:59.060
这个呢就是关于随机啊

24:59.060 --> 25:00.060
随机完了之后呢

25:00.060 --> 25:01.060
接下来呢

25:01.060 --> 25:02.060
有一个size

25:02.060 --> 25:03.060
size呢

25:03.060 --> 25:04.060
它其实是用来获取

25:04.060 --> 25:06.060
我们集合它的一个长度啊

25:06.060 --> 25:08.060
这个呢倒是很简单啊

25:08.060 --> 25:10.060
我们在这儿简单说一下

25:10.060 --> 25:11.060
size

25:11.060 --> 25:15.780
console.log

25:16.780 --> 25:20.430
size

25:20.430 --> 25:21.430
然后这个里头呢

25:21.430 --> 25:24.430
我们给它传上一些集合

25:24.430 --> 25:25.430
第一个

25:25.430 --> 25:27.430
比如说我传上这个集合

25:27.430 --> 25:29.430
它是一个数组

25:29.430 --> 25:31.430
反回的就是这个数组

25:31.430 --> 25:33.430
所对应的一个length值

25:33.430 --> 25:38.280
是不是就是一个5啊

25:38.280 --> 25:39.280
好

25:39.280 --> 25:40.280
再来比如说

25:40.280 --> 25:42.280
我们现在传上一个

25:42.280 --> 25:43.280
这种

25:43.280 --> 25:44.280
传上一个对象是吧

25:44.280 --> 25:45.280
这个对象呢

25:45.280 --> 25:46.280
是a是唯一

25:46.280 --> 25:48.280
然后呢b为2

25:48.280 --> 25:49.280
好这个时候呢

25:49.280 --> 25:50.280
它呢

25:50.280 --> 25:51.280
是数组吗

25:51.280 --> 25:52.280
不是啊

25:52.280 --> 25:53.280
这时候一定要注意了

25:53.280 --> 25:54.280
它是一个对象

25:54.280 --> 25:55.280
然后呢

25:55.280 --> 25:56.280
是对象的话

25:56.280 --> 25:57.280
它统计出来的

25:57.280 --> 25:58.280
是什么呢

25:58.280 --> 26:00.280
就是你可没举的数

26:00.280 --> 26:01.280
那个属性

26:01.280 --> 26:02.280
那这儿呢

26:02.280 --> 26:03.280
就是两个

26:03.280 --> 26:04.280
所以说呢

26:04.280 --> 26:05.280
它的一个结果呢

26:05.280 --> 26:06.280
就是一个2

26:06.280 --> 26:07.280
然后还有

26:07.280 --> 26:09.280
我们的这个东西

26:09.280 --> 26:10.280
自伏串

26:10.280 --> 26:11.280
比如说

26:11.280 --> 26:12.280
开门

26:12.280 --> 26:13.280
那这个自伏串呢

26:13.280 --> 26:14.280
我们再来看

26:14.280 --> 26:15.280
刷新一下

26:15.280 --> 26:16.280
它的一个结果呢

26:16.280 --> 26:17.280
就是一个6

26:17.280 --> 26:18.280
那它取到的就是

26:18.280 --> 26:19.280
自伏串

26:19.280 --> 26:20.280
它的一个长度

26:20.280 --> 26:21.280
好

26:21.280 --> 26:22.280
这是size

26:22.280 --> 26:23.280
这个方法

26:23.280 --> 26:24.280
size

26:24.280 --> 26:25.280
这个方法说完之后呢

26:25.280 --> 26:26.280
那sum

26:26.280 --> 26:27.280
sum这个方法呢

26:27.280 --> 26:28.280
在我们的原生对象当中呢

26:28.280 --> 26:29.280
也是有的

26:29.280 --> 26:30.280
已经说完了

26:30.280 --> 26:31.280
所以说呢

26:31.280 --> 26:32.280
我们第二节

26:32.280 --> 26:33.280
可关于collection

26:33.280 --> 26:34.280
身上的这些方法

26:34.280 --> 26:35.280
就说到这里

