WEBVTT

00:00.370 --> 00:02.370
那继续往下学习

00:02.370 --> 00:04.370
然后在这咱补一个东西

00:04.370 --> 00:05.370
这个给忘了

00:05.370 --> 00:07.370
就是我们在上上节课讲

00:07.370 --> 00:09.370
这个collection这个方法的时候

00:09.370 --> 00:11.370
这个reject出了点问题

00:11.370 --> 00:13.370
然后我说在下节课先把这个问题

00:13.370 --> 00:14.370
给它解决了

00:14.370 --> 00:16.370
后来也给落下了

00:16.370 --> 00:19.370
那我们就放到这节课去给它补一下

00:19.370 --> 00:20.370
好不好

00:20.370 --> 00:21.370
来看一下这个reject

00:21.370 --> 00:22.370
那这个reject呢

00:22.370 --> 00:24.370
我们上次出问题

00:24.370 --> 00:25.370
问题出现在哪里呢

00:25.370 --> 00:27.370
就出现在这一条

00:27.370 --> 00:28.370
因为是什么呢

00:29.370 --> 00:30.370
这条压根

00:30.370 --> 00:32.370
就是当时我写的是一个什么呢

00:32.370 --> 00:33.370
写的是一个处

00:33.370 --> 00:34.370
所以说就是

00:34.370 --> 00:36.370
它跟这个匹配不到

00:36.370 --> 00:37.370
所以它找不到

00:37.370 --> 00:38.370
找不到之后呢

00:38.370 --> 00:40.370
就两条都给咱们返回了

00:40.370 --> 00:41.370
知道吧

00:41.370 --> 00:43.370
那问题就出现在这

00:43.370 --> 00:45.370
在这咱们再简单的去说一下

00:45.370 --> 00:46.370
这个reject

00:46.370 --> 00:47.370
这个reject呢

00:47.370 --> 00:48.370
跟fuse是一样的

00:48.370 --> 00:49.370
用来过滤数据

00:49.370 --> 00:50.370
但是跟fuse

00:50.370 --> 00:52.370
刚好是相反的

00:52.370 --> 00:54.370
它过滤的就是一个假的

00:54.370 --> 00:55.370
fuse过滤的是真的

00:55.370 --> 00:56.370
来咱们试一下

00:56.370 --> 00:57.370
那第一个

00:57.370 --> 00:59.370
你看我们给上一个faction

00:59.370 --> 01:01.370
return了一个odactive

01:01.370 --> 01:03.370
active只有当为处的时候

01:03.370 --> 01:04.370
这个呢

01:04.370 --> 01:05.370
条件是不是才成立

01:05.370 --> 01:06.370
那为处的话

01:06.370 --> 01:07.370
是不是这条

01:07.370 --> 01:08.370
对吧

01:08.370 --> 01:09.370
但是呢

01:09.370 --> 01:11.370
就是它是刚好跟fuse是相反的

01:11.370 --> 01:12.370
所以说呢

01:12.370 --> 01:14.370
它找到过滤掉的是哪一条

01:14.370 --> 01:15.370
就是这条

01:15.370 --> 01:16.370
懂吗

01:16.370 --> 01:17.370
然后呢

01:17.370 --> 01:18.370
再来你看

01:18.370 --> 01:19.370
那这个呢

01:19.370 --> 01:20.370
其实就说

01:20.370 --> 01:21.370
第二个数据呢

01:21.370 --> 01:22.370
为对象

01:22.370 --> 01:23.370
这个对象呢

01:23.370 --> 01:24.370
我们看在这呢

01:24.370 --> 01:25.370
是不是能够找到

01:25.370 --> 01:26.370
那找到了之后呢

01:26.370 --> 01:27.370
是这个

01:27.370 --> 01:29.370
刚好是不跟它相反

01:29.370 --> 01:30.370
然后这个呢

01:30.370 --> 01:31.370
也是一样的

01:31.370 --> 01:32.370
那这种写法呢

01:32.370 --> 01:33.370
其实就是一个

01:33.370 --> 01:34.370
这是k

01:34.370 --> 01:35.370
这是一个value

01:35.370 --> 01:36.370
知道吧

01:36.370 --> 01:37.370
然后k是user

01:37.370 --> 01:38.370
然后value呢

01:38.370 --> 01:39.370
是这个frate的

01:39.370 --> 01:40.370
但是呢

01:40.370 --> 01:41.370
取取反

01:41.370 --> 01:42.370
取反取到谁

01:42.370 --> 01:43.370
取到它了

01:43.370 --> 01:44.370
然后这个呢

01:44.370 --> 01:45.370
H

01:45.370 --> 01:46.370
那就是说

01:46.370 --> 01:47.370
现在这个数据当中

01:47.370 --> 01:48.370
有没有H的

01:48.370 --> 01:49.370
这条属性

01:49.370 --> 01:50.370
那你看

01:50.370 --> 01:51.370
两个都有

01:51.370 --> 01:52.370
那不要取反

01:52.370 --> 01:53.370
是不是都没有

01:53.370 --> 01:54.370
得出的一个结果

01:54.370 --> 01:55.370
就是一个空

01:55.370 --> 01:56.370
好

01:56.370 --> 01:57.370
然后呢

01:57.370 --> 01:58.370
回到咱们

01:58.370 --> 01:59.370
这节课的内容

01:59.370 --> 02:00.370
我们说一下浪

02:00.370 --> 02:01.370
这个方法

02:01.370 --> 02:02.370
那这个浪

02:02.370 --> 02:03.370
这个方法呢

02:03.370 --> 02:04.370
其实也没有

02:04.370 --> 02:05.370
太好的一个翻译

02:05.370 --> 02:06.370
它其实翻译过来呢

02:06.370 --> 02:07.370
是language

02:07.370 --> 02:08.370
就是一个语言

02:08.370 --> 02:09.370
但是呢

02:09.370 --> 02:10.370
就是

02:10.370 --> 02:11.370
这个里头呢

02:11.370 --> 02:12.370
这些方法

02:12.370 --> 02:14.370
它确实是跟我们

02:14.370 --> 02:15.370
就是

02:15.370 --> 02:16.370
比如说这个

02:16.370 --> 02:17.370
检测数据类型

02:17.370 --> 02:18.370
那其实就是

02:18.370 --> 02:19.370
跟语言是相关的

02:19.370 --> 02:20.370
所以这个东西

02:20.370 --> 02:21.370
勉勉勉抢

02:21.370 --> 02:22.370
可以认为是

02:22.370 --> 02:23.370
关于这个浪

02:23.370 --> 02:24.370
这个语言身上

02:24.370 --> 02:25.370
这个对象呢

02:25.370 --> 02:26.370
是

02:26.370 --> 02:28.370
不是我们原生的对象

02:28.370 --> 02:29.370
这是人家自己定义的

02:29.370 --> 02:30.370
这么一个对象

02:30.370 --> 02:31.370
好

02:31.370 --> 02:32.370
我们接下来呢

02:32.370 --> 02:33.370
就花一些时间

02:33.370 --> 02:34.370
来看一下

02:34.370 --> 02:35.370
他身上的这些方法

02:35.370 --> 02:36.370
那挨个来说

02:36.370 --> 02:37.370
第一个呢

02:37.370 --> 02:38.370
就是这个

02:39.370 --> 02:40.370
来

02:41.370 --> 02:42.370
这个方法

02:42.370 --> 02:43.370
那这个方法

02:43.370 --> 02:44.370
他是啥呢

02:44.370 --> 02:45.370
这个方法

02:45.370 --> 02:46.370
他其实是用来

02:46.370 --> 02:47.370
转

02:47.370 --> 02:48.370
转什么呢

02:48.370 --> 02:49.370
转数组的

02:49.370 --> 02:50.370
而且呢

02:50.370 --> 02:51.370
它是一个强制

02:51.370 --> 02:52.370
转数组

02:52.370 --> 02:53.370
强制转数组呢

02:53.370 --> 02:54.370
什么乱七八糟的

02:54.370 --> 02:55.370
我通通的

02:55.370 --> 02:56.370
都能够把你

02:56.370 --> 02:57.370
转成数组

02:57.370 --> 02:58.370
我不管那些乱七八糟的

02:58.370 --> 02:59.370
知道吧

02:59.370 --> 03:01.370
好那咱们来看一下

03:01.370 --> 03:02.370
强制转数组

03:02.370 --> 03:06.700
那我就直接cancelogue

03:06.700 --> 03:07.700
然后掉一下

03:07.700 --> 03:08.700
这个方法

03:08.700 --> 03:09.700
他里头呢

03:09.700 --> 03:10.700
咱传一些

03:10.700 --> 03:11.700
乱七八糟的一些东西

03:11.700 --> 03:12.700
你比如说

03:12.700 --> 03:13.700
我们传上一个a

03:13.700 --> 03:14.700
是不是好

03:14.700 --> 03:15.700
那这个a

03:15.700 --> 03:16.700
传完之后

03:16.700 --> 03:17.700
我打开页面

03:17.700 --> 03:18.700
控制台

03:18.700 --> 03:19.700
看一下结果

03:19.700 --> 03:20.700
刷新一下

03:20.700 --> 03:21.700
这呢

03:21.700 --> 03:22.700
就是一个数组

03:22.700 --> 03:23.700
里头呢

03:23.700 --> 03:24.700
放了一个数据

03:24.700 --> 03:25.700
比如说

03:25.700 --> 03:26.700
我们再给上一个

03:26.700 --> 03:27.700
这个对象

03:27.700 --> 03:28.700
这个对象

03:28.700 --> 03:29.700
a等于一个1

03:29.700 --> 03:30.700
然后呢b

03:30.700 --> 03:31.700
等于一个2

03:31.700 --> 03:32.700
那那我问你

03:32.700 --> 03:33.700
他怎么转成一个数组

03:33.700 --> 03:34.700
是不是很疑惑

03:34.700 --> 03:35.700
来走着

03:35.700 --> 03:36.700
他怎么变呢

03:36.700 --> 03:38.700
直接干干脆脆

03:38.700 --> 03:39.700
给外边

03:39.700 --> 03:40.700
给你加上一个中扩号

03:40.700 --> 03:41.700
不就行了吗

03:41.700 --> 03:43.700
你不就是一个数组了吗

03:43.700 --> 03:44.700
把你作为

03:44.700 --> 03:45.700
我的第零条数据

03:45.700 --> 03:46.700
你就是一个数组了

03:46.700 --> 03:48.700
所以他是强制转数组

03:48.700 --> 03:49.700
这个转法呢

03:49.700 --> 03:50.700
很粗暴

03:50.700 --> 03:51.700
直接把数据

03:51.700 --> 03:53.700
外边加上一个中扩号

03:53.700 --> 03:54.700
就ok了

03:54.700 --> 03:56.700
这是第一个

03:56.700 --> 03:58.700
剩下那些咱就不演示了

03:58.700 --> 03:59.700
然后呢

03:59.700 --> 04:00.700
接下来呢

04:00.700 --> 04:01.700
这一坨呢

04:01.700 --> 04:02.700
就是关于这个拷贝的

04:02.700 --> 04:04.700
那这个拷贝呢

04:04.700 --> 04:05.700
他是分为这个

04:05.700 --> 04:06.700
深拷贝

04:06.700 --> 04:07.700
还有浅拷贝

04:07.700 --> 04:08.700
这个呢

04:08.700 --> 04:09.700
其实在我们的

04:09.700 --> 04:10.700
原生的那个gsc

04:10.700 --> 04:11.700
当中呢是有讲的

04:11.700 --> 04:12.700
那人家已经

04:12.700 --> 04:13.700
帮咱们封装了

04:13.700 --> 04:14.700
一些方法了

04:14.700 --> 04:15.700
那在这呢

04:15.700 --> 04:16.700
咱们就演示一下

04:16.700 --> 04:17.700
这个方法

04:17.700 --> 04:18.700
好吧

04:18.700 --> 04:19.700
一个来说

04:19.700 --> 04:20.700
那先来说一下

04:20.700 --> 04:21.700
第一个呢

04:21.700 --> 04:22.700
就是clone

04:22.700 --> 04:23.700
它声明一个obj1

04:23.700 --> 04:25.700
等于一个对象

04:25.700 --> 04:26.700
然后这个对象当中

04:26.700 --> 04:28.700
a等于一个1

04:28.700 --> 04:29.700
b

04:30.700 --> 04:31.700
a等于一个1

04:31.700 --> 04:32.700
然后b呢

04:32.700 --> 04:33.700
是一个对象

04:33.700 --> 04:34.700
然后c呢

04:34.700 --> 04:36.700
等于一个2

04:37.700 --> 04:38.700
好

04:39.700 --> 04:41.700
再来obj2

04:41.700 --> 04:42.700
那他等于什么呢

04:42.700 --> 04:44.700
我调这个方法

04:44.700 --> 04:46.700
把obj1丢进去

04:46.700 --> 04:47.700
也就是说

04:47.700 --> 04:48.700
我现在

04:48.700 --> 04:49.700
把obj1呢

04:49.700 --> 04:50.700
给我拷贝一下

04:50.700 --> 04:51.700
拷贝完了之后呢

04:51.700 --> 04:53.700
我们cancelogue

04:53.700 --> 04:54.700
obj1

04:54.700 --> 04:55.700
obj2

04:55.700 --> 04:56.700
看一下他俩

04:56.700 --> 04:57.700
是一样的吗

04:58.700 --> 04:59.700
走

04:59.700 --> 05:00.700
好

05:00.700 --> 05:01.700
点开

05:01.700 --> 05:02.700
点开

05:02.700 --> 05:03.700
两个呢

05:03.700 --> 05:04.700
是一模一样的

05:04.700 --> 05:05.700
然后这个b当中呢

05:05.700 --> 05:06.700
放的就是一个c

05:09.700 --> 05:10.700
打了个喷嚏

05:11.700 --> 05:12.700
好

05:12.700 --> 05:13.700
那你看

05:13.700 --> 05:14.700
他俩是不是

05:14.700 --> 05:15.700
长的是一模一样的

05:15.700 --> 05:16.700
那好

05:16.700 --> 05:17.700
接下来呢

05:17.700 --> 05:18.700
我要做一件事情

05:18.700 --> 05:19.700
什么事情呢

05:19.700 --> 05:20.700
obj2点

05:20.700 --> 05:21.700
里头是不是有一个c

05:21.700 --> 05:22.700
我把这个值呢

05:22.700 --> 05:23.700
给他改了

05:23.700 --> 05:24.700
改成一个3

05:24.700 --> 05:25.700
然后呢

05:25.700 --> 05:26.700
逗号

05:26.700 --> 05:27.700
注意这个语法呢

05:27.700 --> 05:28.700
是通顺的

05:28.700 --> 05:29.700
cancelogue

05:29.700 --> 05:30.700
log什么呢

05:30.700 --> 05:31.700
obj1

05:31.700 --> 05:32.700
然后呢obj2

05:32.700 --> 05:33.700
中间加了一个逗号

05:33.700 --> 05:34.700
目的呢

05:34.700 --> 05:35.700
就是说

05:35.700 --> 05:36.700
把他俩能够写在一行

05:36.700 --> 05:37.700
你不愿意加的话

05:37.700 --> 05:38.700
换个行也是ok的

05:38.700 --> 05:39.700
好吧

05:39.700 --> 05:40.700
我在这呢

05:40.700 --> 05:41.700
多跟大家说一个方法

05:41.700 --> 05:42.700
是不是

05:42.700 --> 05:43.700
其实这个呢

05:43.700 --> 05:44.700
是逗号运算服

05:44.700 --> 05:45.700
他的一个作用

05:45.700 --> 05:46.700
来

05:46.700 --> 05:47.700
在这了

05:47.700 --> 05:48.700
刷新

05:48.700 --> 05:49.700
刷新完之后呢

05:49.700 --> 05:50.700
b是不是

05:50.700 --> 05:51.700
b里头的c

05:51.700 --> 05:52.700
变成了一个3

05:52.700 --> 05:53.700
这呢

05:53.700 --> 05:54.700
也变成了一个3

05:54.700 --> 05:55.700
你看

05:55.700 --> 05:56.700
那也就是我改了一个

05:56.700 --> 05:57.700
两个都变了

05:57.700 --> 05:58.700
这个呢

05:58.700 --> 05:59.700
叫啥

05:59.700 --> 06:00.700
叫钱拷贝

06:00.700 --> 06:01.700
其实就是说

06:01.700 --> 06:02.700
他直接把这个b的值

06:02.700 --> 06:03.700
复制过来了

06:03.700 --> 06:04.700
因为这个对象呢

06:04.700 --> 06:05.700
他是一个引用的地址

06:05.700 --> 06:06.700
你复制过来之后呢

06:06.700 --> 06:08.700
他其实你就复制了一个地址

06:08.700 --> 06:10.700
并没有复制真正的一个值

06:10.700 --> 06:11.700
那你改完

06:11.700 --> 06:12.700
你甭管在谁身上改

06:12.700 --> 06:13.700
改完之后呢

06:13.700 --> 06:14.700
他们都会变

06:14.700 --> 06:15.700
这是钱拷贝

06:15.700 --> 06:16.700
然后呢

06:16.700 --> 06:17.700
深拷贝呢

06:17.700 --> 06:18.700
深拷贝的这个方法呢

06:18.700 --> 06:20.700
是clone deep

06:20.700 --> 06:21.700
加了一个deep

06:21.700 --> 06:22.700
就是深的意思

06:22.700 --> 06:23.700
好

06:23.700 --> 06:24.700
然后这呢

06:24.700 --> 06:26.700
咱声明一个obj3

06:26.700 --> 06:28.700
obj3

06:28.700 --> 06:29.700
那他等于什么呢

06:29.700 --> 06:31.700
我直接去调的一个方法

06:31.700 --> 06:33.700
clone deep

06:33.700 --> 06:35.700
d

06:35.700 --> 06:36.700
eep

06:36.700 --> 06:37.700
好

06:37.700 --> 06:39.700
把谁丢进来了

06:39.700 --> 06:40.700
把obj

06:40.700 --> 06:41.700
obj1

06:41.700 --> 06:42.700
把他丢进来

06:42.700 --> 06:43.700
丢进来之后呢

06:43.700 --> 06:44.700
接着呢

06:44.700 --> 06:46.700
就是obj3.b.c

06:46.700 --> 06:47.700
这个时候呢

06:47.700 --> 06:48.700
等一下

06:48.700 --> 06:49.700
等于多少呢

06:49.700 --> 06:50.700
等于一个4

06:50.700 --> 06:51.700
接下来

06:51.700 --> 06:52.700
我们再concelogue

06:52.700 --> 06:53.700
obj1

06:53.700 --> 06:55.700
以及obj3

06:55.700 --> 06:57.700
看一下这两个东西

06:57.700 --> 06:58.700
在这

06:58.700 --> 06:59.700
刷新一下

06:59.700 --> 07:00.700
好

07:00.700 --> 07:01.700
我点开一个

07:01.700 --> 07:02.700
再点开一个

07:02.700 --> 07:03.700
你看

07:03.700 --> 07:04.700
这个c呢

07:04.700 --> 07:05.700
是3

07:05.700 --> 07:06.700
这个c呢

07:06.700 --> 07:07.700
是4

07:07.700 --> 07:08.700
他俩没有关系了吧

07:08.700 --> 07:09.700
其实也就是

07:09.700 --> 07:10.700
深拷贝

07:10.700 --> 07:11.700
把这个值拷贝了

07:11.700 --> 07:12.700
并不是拷贝了

07:12.700 --> 07:13.700
整个对象

07:13.700 --> 07:14.700
深拷贝

07:14.700 --> 07:15.700
好

07:15.700 --> 07:16.700
往下吧

07:16.700 --> 07:17.700
wis

07:17.700 --> 07:18.700
是不是

07:18.700 --> 07:20.700
加了一个什么的比较器啊

07:20.700 --> 07:21.700
这个呢

07:21.700 --> 07:23.700
咱们就不再去说了啊

07:24.700 --> 07:25.700
好

07:25.700 --> 07:26.700
再往下

07:26.700 --> 07:30.170
这个方法

07:30.170 --> 07:31.170
那这个方法呢

07:31.170 --> 07:33.170
它是用来干嘛呢

07:33.170 --> 07:35.800
这个方法呢

07:35.800 --> 07:36.800
它是用来通过

07:36.800 --> 07:37.800
第二个参数

07:37.800 --> 07:38.800
来检测我们的

07:38.800 --> 07:40.800
对象的属性的值

07:40.800 --> 07:43.800
是不是满足某一个条件

07:43.800 --> 07:45.800
比如说obj

07:46.800 --> 07:48.800
等于一个a

07:48.800 --> 07:51.300
加上一个引号吧

07:51.300 --> 07:52.300
a等于一个1

07:52.300 --> 07:53.300
然后呢

07:53.300 --> 07:54.300
这个b呢

07:54.300 --> 07:55.300
a

07:56.300 --> 07:57.300
a等于1

07:58.300 --> 07:59.300
然后b呢

07:59.300 --> 08:00.300
等上一个2

08:02.300 --> 08:03.300
这是一个对象

08:03.300 --> 08:04.300
然后

08:04.300 --> 08:05.300
调

08:05.300 --> 08:07.300
这个方法console.log

08:10.190 --> 08:11.190
直接去调

08:11.190 --> 08:12.190
它里头呢

08:12.190 --> 08:13.190
接收参数

08:13.190 --> 08:14.190
是吧

08:14.190 --> 08:15.190
那第一个参数

08:15.190 --> 08:16.190
就是你要比较的

08:16.190 --> 08:17.190
那个原对象

08:17.190 --> 08:18.190
那就是obj

08:18.190 --> 08:19.190
然后呢

08:19.190 --> 08:20.190
第二个呢

08:20.190 --> 08:21.190
就是一个对象了

08:21.190 --> 08:22.190
这个对象当中呢

08:22.190 --> 08:24.190
根据我们的

08:24.190 --> 08:26.190
它其实是给

08:26.190 --> 08:28.190
这个对象当中呢

08:28.190 --> 08:29.190
我们找

08:29.190 --> 08:30.190
找到比如说

08:30.190 --> 08:31.190
你要对比的是b

08:31.190 --> 08:32.190
是不是

08:32.190 --> 08:33.190
它还是以k跟y6的

08:33.190 --> 08:34.190
这种形式

08:34.190 --> 08:35.190
只不过呢

08:35.190 --> 08:36.190
就是它的一个值呢

08:36.190 --> 08:37.190
就是一个检测的一个条件

08:37.190 --> 08:38.190
那这个b

08:38.190 --> 08:39.190
我要检测

08:39.190 --> 08:40.190
是不是按照什么去检测呢

08:40.190 --> 08:41.190
我给上一个faction

08:41.190 --> 08:42.190
然后呢

08:42.190 --> 08:43.190
传上一个n吧

08:43.190 --> 08:44.190
换一个

08:44.190 --> 08:45.190
传上一个n

08:45.190 --> 08:46.190
然后接下来呢

08:46.190 --> 08:47.190
干嘛

08:47.190 --> 08:48.190
我就return

08:48.190 --> 08:49.190
return什么呢

08:49.190 --> 08:50.190
这个n

08:50.190 --> 08:51.190
是否大于1

08:51.190 --> 08:52.190
那其实这个时候呢

08:52.190 --> 08:53.190
表示的意思是啥呀

08:53.190 --> 08:54.190
表

08:55.190 --> 08:56.190
我做了什么

08:58.190 --> 09:01.400
collection

09:01.400 --> 09:02.400
我做的什么

09:02.400 --> 09:03.400
好吧

09:03.400 --> 09:05.400
我好像是把它关掉了

09:05.400 --> 09:13.980
第四个

09:13.980 --> 09:15.980
我好像是把它关掉了啊

09:15.980 --> 09:17.980
来咱们继续说啊

09:17.980 --> 09:19.980
那他这么做的意义

09:19.980 --> 09:20.980
是在在哪里呢

09:20.980 --> 09:21.980
就是说啊

09:21.980 --> 09:22.980
你看我要去

09:22.980 --> 09:24.980
去检测我的b

09:24.980 --> 09:25.980
所以说呢

09:25.980 --> 09:26.980
这个对象当中呢

09:26.980 --> 09:27.980
就有一个k叫b

09:27.980 --> 09:28.980
然后怎么去检测呢

09:28.980 --> 09:29.980
就是它的值

09:29.980 --> 09:30.980
一个faction

09:30.980 --> 09:31.980
那就检测

09:31.980 --> 09:32.980
现在传的n呢

09:32.980 --> 09:33.980
其实就说

09:33.980 --> 09:35.980
把b对应的这个value值传进来

09:35.980 --> 09:36.980
传进来呢

09:36.980 --> 09:37.980
我就判断一下

09:37.980 --> 09:38.980
看看它是否大于一个1

09:38.980 --> 09:39.980
是不是

09:39.980 --> 09:40.980
来在这呢

09:40.980 --> 09:41.980
我们看一下

09:41.980 --> 09:42.980
刷新

09:42.980 --> 09:43.980
这个结果呢

09:43.980 --> 09:44.980
是一个什么呢

09:44.980 --> 09:45.980
是一个true

09:45.980 --> 09:46.980
就表示现在这个条件

09:46.980 --> 09:47.980
它是满足的啊

09:47.980 --> 09:48.980
这个呢

09:48.980 --> 09:49.980
就是conforms2

09:49.980 --> 09:50.980
它的一个作用

09:50.980 --> 09:51.980
然后呢

09:51.980 --> 09:52.980
假设说这呢

09:52.980 --> 09:53.980
给上一个2

09:53.980 --> 09:54.980
2的话

09:54.980 --> 09:55.980
再一看

09:55.980 --> 09:56.980
刷新

09:56.980 --> 09:57.980
是不是得出的结果呢

09:57.980 --> 09:58.980
是啥

09:58.980 --> 09:59.980
其实是等于2的

09:59.980 --> 10:00.980
好

10:00.980 --> 10:02.980
这个呢就是拿第2个参数呢

10:02.980 --> 10:04.980
来检测我们对象当中

10:04.980 --> 10:05.980
属性的值

10:05.980 --> 10:07.980
是否满足条件

10:07.980 --> 10:09.980
继续往下

10:09.980 --> 10:13.300
eq

10:13.300 --> 10:16.380
eq这个方法

10:16.380 --> 10:18.380
eq这个方法呢

10:18.380 --> 10:20.380
它是用来比较两个值

10:20.380 --> 10:21.380
是否相等的

10:21.380 --> 10:23.380
这个方法倒是非常的简单啊

10:23.380 --> 10:24.380
不过呢

10:24.380 --> 10:25.380
就是这个方法

10:25.380 --> 10:26.380
人家去做了一些改良啊

10:26.380 --> 10:27.380
eq

10:28.380 --> 10:29.380
传上一个12

10:29.380 --> 10:30.380
再传上一个12

10:30.380 --> 10:31.380
这个结果

10:31.380 --> 10:32.380
肯定是一个处吧

10:32.380 --> 10:33.380
刷新

10:33.380 --> 10:34.380
复制一下

10:34.380 --> 10:35.380
放到这

10:35.380 --> 10:37.820
再来

10:37.820 --> 10:38.820
两个对象

10:38.820 --> 10:39.820
这个对象啊

10:39.820 --> 10:40.820
里头放的a

10:40.820 --> 10:41.820
等于一个e

10:41.820 --> 10:42.820
然后呢

10:42.820 --> 10:43.820
这个对象

10:43.820 --> 10:44.820
放的就是a

10:44.820 --> 10:45.820
等于一个e

10:45.820 --> 10:46.820
它俩一样吗

10:46.820 --> 10:47.820
一样吗

10:47.820 --> 10:48.820
刷新

10:48.820 --> 10:49.820
早着

10:49.820 --> 10:50.820
必然不一样

10:50.820 --> 10:51.820
是一个false

10:51.820 --> 10:52.820
为啥呢

10:52.820 --> 10:53.820
对象你别看

10:53.820 --> 10:54.820
它长的是一模一样的

10:54.820 --> 10:55.820
但是对象当中呢

10:55.820 --> 10:56.820
是引用的地址

10:56.820 --> 10:57.820
它能一样吗

10:57.820 --> 10:58.820
它不一样

10:58.820 --> 11:00.820
这个不要迷糊了啊

11:00.820 --> 11:01.820
来

11:01.820 --> 11:02.820
这个方法呢

11:02.820 --> 11:03.820
其实是

11:03.820 --> 11:05.820
跟这个es6当中新增的

11:05.820 --> 11:07.820
一个object.es

11:07.820 --> 11:08.820
is

11:08.820 --> 11:10.820
那个方法是一模一样的

11:10.820 --> 11:12.820
它做了一下修正

11:12.820 --> 11:13.820
做了一下改良

11:13.820 --> 11:14.820
什么改良了

11:14.820 --> 11:15.820
就是在原来

11:15.820 --> 11:16.820
我们说

11:16.820 --> 11:17.820
讲这个

11:17.820 --> 11:19.820
这个数字的时候

11:19.820 --> 11:20.820
数字类型

11:20.820 --> 11:21.820
我们原生ts

11:21.820 --> 11:22.820
数字类型的时候

11:22.820 --> 11:23.820
是不是说过这个奇葩呀

11:23.820 --> 11:24.820
是吧

11:24.820 --> 11:25.820
nn

11:25.820 --> 11:27.820
它自己跟自己都不相等

11:27.820 --> 11:28.820
它自己都看不上自己

11:28.820 --> 11:29.820
是不是

11:29.820 --> 11:30.820
我们去拿它俩

11:30.820 --> 11:31.820
去进行个对比

11:31.820 --> 11:32.820
得出的一个结果呢

11:32.820 --> 11:33.820
始终是一个false

11:33.820 --> 11:34.820
而这个方法呢

11:34.820 --> 11:35.820
就修正了

11:35.820 --> 11:36.820
刷新一下

11:36.820 --> 11:37.820
你看得出的一个结果呢

11:37.820 --> 11:38.820
就是一个处

11:38.820 --> 11:39.820
懂吗

11:39.820 --> 11:40.820
就是让它变得正常一点

11:40.820 --> 11:41.820
不要那么奇葩了啊

11:41.820 --> 11:42.820
这个呢

11:42.820 --> 11:43.820
就是eq

11:43.820 --> 11:44.820
这个方法

11:44.820 --> 11:45.820
再往下

11:45.820 --> 11:47.820
那接下来呢

11:47.820 --> 11:48.820
就是比较了

11:48.820 --> 11:49.820
这个gt

11:49.820 --> 11:50.820
gt这个方法呢

11:50.820 --> 11:51.820
其实简单啊

11:51.820 --> 11:52.820
它的作用

11:52.820 --> 11:53.820
是用来比较

11:53.820 --> 11:54.820
两个数字

11:54.820 --> 11:55.820
那我们看一下

11:55.820 --> 11:56.820
点gt

11:56.820 --> 11:58.820
我给上一个3

11:58.820 --> 11:59.820
给上一个1

11:59.820 --> 12:00.820
那它做的事情是

12:00.820 --> 12:01.820
拿第1个参数

12:01.820 --> 12:02.820
跟第2个参数呢

12:02.820 --> 12:03.820
进行一个对比

12:03.820 --> 12:04.820
看看第1个参数

12:04.820 --> 12:05.820
是否

12:05.820 --> 12:07.820
大于第2个参数

12:07.820 --> 12:08.820
来结果

12:08.820 --> 12:09.820
刷新

12:09.820 --> 12:10.820
表示3

12:10.820 --> 12:11.820
大于1

12:11.820 --> 12:12.820
然后

12:12.820 --> 12:13.820
如果说

12:13.820 --> 12:14.820
给上一个3呢

12:14.820 --> 12:15.820
来刷新

12:15.820 --> 12:16.820
很明显

12:16.820 --> 12:17.820
它是一个false嘛

12:17.820 --> 12:18.820
因为3等于3

12:18.820 --> 12:19.820
它并不大于3

12:19.820 --> 12:20.820
这个呢

12:20.820 --> 12:21.820
就是一个gt

12:21.820 --> 12:22.820
非常的简单

12:22.820 --> 12:23.820
来

12:23.820 --> 12:24.820
那gt呢

12:24.820 --> 12:25.820
这块呢

12:25.820 --> 12:26.820
我们就不再去说了

12:26.820 --> 12:27.820
接下来呢

12:27.820 --> 12:28.820
是不是

12:28.820 --> 12:29.820
这个呢

12:29.820 --> 12:30.820
就是大于或等于

12:30.820 --> 12:31.820
大于等于

12:31.820 --> 12:32.820
然后以及

12:32.820 --> 12:33.820
跟它对应的一个方法

12:33.820 --> 12:34.820
叫lt

12:34.820 --> 12:35.820
lt在哪里

12:35.820 --> 12:36.820
在这

12:36.820 --> 12:37.820
lt以及lte

12:37.820 --> 12:38.820
这是小于

12:38.820 --> 12:40.820
这是小于等于

12:41.820 --> 12:42.820
好

12:42.820 --> 12:43.820
这些方法呢

12:43.820 --> 12:44.820
就算是已经说完了

12:44.820 --> 12:45.820
说完之后呢

12:45.820 --> 12:46.820
接下来就开始

12:46.820 --> 12:47.820
你会看到很多ase

12:47.820 --> 12:48.820
是不是

12:48.820 --> 12:49.820
到哪了

12:49.820 --> 12:50.820
从这开始

12:50.820 --> 12:54.020
一直倒

12:54.020 --> 12:55.020
到这个地方

12:55.020 --> 12:56.020
这么多

12:56.020 --> 12:57.020
到这

12:57.020 --> 12:58.020
你看这么一长串

12:58.020 --> 12:59.020
一堆

12:59.020 --> 13:00.020
它是用来干吗呢

13:00.020 --> 13:01.020
它是用来检测

13:01.020 --> 13:03.020
数据类型的

13:03.020 --> 13:04.020
只不过呢

13:04.020 --> 13:05.020
Loudesh呢

13:05.020 --> 13:06.020
把这个判断数据类型

13:06.020 --> 13:07.020
做的更加的方式

13:07.020 --> 13:08.020
而且呢

13:08.020 --> 13:10.020
还更加的精准了

13:10.020 --> 13:12.020
它其实怎么去精准呢

13:12.020 --> 13:13.020
它其实用的方法呢

13:13.020 --> 13:14.020
其实就是

13:14.020 --> 13:16.020
我们的这个原生GS当中

13:16.020 --> 13:18.020
咱们之前已经说过

13:18.020 --> 13:19.020
也学过

13:19.020 --> 13:20.020
就是通过这个to stream

13:20.020 --> 13:21.020
这个方法

13:21.020 --> 13:22.020
去判断数据类型

13:22.020 --> 13:23.020
是不是得出的数据类型

13:23.020 --> 13:25.020
绝对是一个精准的数据啊

13:25.020 --> 13:26.020
那总共这么多啊

13:26.020 --> 13:27.020
在这呢

13:27.020 --> 13:28.020
我就不再去

13:28.020 --> 13:29.020
说了

13:29.020 --> 13:31.020
我们掩饰几个就ok了

13:31.020 --> 13:32.020
好不好

13:32.020 --> 13:33.020
比如说这个s3

13:33.020 --> 13:34.020
那它呢

13:34.020 --> 13:35.020
就是用来检测

13:35.020 --> 13:36.020
现在我的这个数据呢

13:36.020 --> 13:42.640
到底是不是一个数组

13:42.640 --> 13:43.640
s3

13:43.640 --> 13:45.640
我们传上一个

13:45.640 --> 13:46.640
正经的一个数组

13:46.640 --> 13:48.640
123

13:48.640 --> 13:49.640
这个结果呢

13:49.640 --> 13:50.640
肯定是一个什么

13:50.640 --> 13:51.640
处

13:51.640 --> 13:52.640
是吧

13:52.640 --> 13:53.640
处啊

13:53.640 --> 13:55.640
复制一下

13:55.640 --> 13:56.640
放到这

13:56.640 --> 13:57.640
然后呢

13:57.640 --> 13:58.640
接着再来

13:58.640 --> 13:59.640
咱给上一个

13:59.640 --> 14:00.640
不正经的一个数组

14:00.640 --> 14:01.640
比如说

14:01.640 --> 14:02.640
我们给上这么一个东西

14:02.640 --> 14:06.640
document.body.children

14:06.640 --> 14:07.640
那这个是个啥

14:07.640 --> 14:08.640
这个呢

14:08.640 --> 14:10.640
是我获取到我们的这个

14:10.640 --> 14:11.640
页面当中的这个

14:11.640 --> 14:12.640
节点 body这个节点

14:12.640 --> 14:13.640
然后呢

14:13.640 --> 14:14.640
取到他所有的

14:14.640 --> 14:15.640
紫元素是吧

14:15.640 --> 14:16.640
好再来看看刷新

14:16.640 --> 14:17.640
他的结果是啥

14:17.640 --> 14:18.640
是一个false

14:18.640 --> 14:19.640
在之前

14:19.640 --> 14:20.640
其实这个东西呢

14:20.640 --> 14:21.640
是啥

14:21.640 --> 14:22.640
他取到的是一堆的

14:22.640 --> 14:23.640
紫元素

14:23.640 --> 14:24.640
一堆紫元素啊

14:24.640 --> 14:25.640
我们拿拿到之后呢

14:25.640 --> 14:26.640
他跟数组

14:26.640 --> 14:27.640
是不是一模一样啊

14:27.640 --> 14:29.640
他其实是一个什么的

14:29.640 --> 14:30.640
数组

14:30.640 --> 14:31.640
类数组呢

14:31.640 --> 14:32.640
准确来讲呢

14:32.640 --> 14:33.640
他是一个什么呢

14:33.640 --> 14:36.640
html collection集合对象

14:36.640 --> 14:38.640
这在document里头呢

14:38.640 --> 14:39.640
你是能够查到

14:39.640 --> 14:41.640
相应的一些信息的啊

14:41.640 --> 14:42.640
所以说呢

14:42.640 --> 14:43.640
你看这样的话

14:43.640 --> 14:44.640
我们去检测

14:44.640 --> 14:45.640
他就不是一个

14:45.640 --> 14:46.640
正经的数组

14:46.640 --> 14:47.640
所以给他返回的一个结果呢

14:47.640 --> 14:49.640
就是一个false

14:49.640 --> 14:50.640
好

14:50.640 --> 14:51.640
再来

14:51.640 --> 14:52.640
再来咱换一个

14:52.640 --> 14:53.640
换一个

14:53.640 --> 14:54.640
换一个对象吧

14:54.640 --> 14:57.270
as object

14:57.270 --> 14:59.270
这个用来检测检测

14:59.270 --> 15:00.270
我的数据呢

15:00.270 --> 15:01.270
对象是不是

15:01.270 --> 15:02.270
那我们给上一个

15:02.270 --> 15:03.270
正经的对象

15:03.270 --> 15:04.270
来刷新看一下结果

15:04.270 --> 15:05.270
刷新就是一个处

15:05.270 --> 15:11.100
嘿

15:11.100 --> 15:12.100
然后再来

15:12.100 --> 15:13.100
给上一个什么呢

15:13.100 --> 15:14.100
难

15:14.100 --> 15:15.100
这个难呢

15:15.100 --> 15:17.100
我们在原生ts当中呢

15:17.100 --> 15:19.100
我们通过这个type off检测的时候呢

15:19.100 --> 15:21.100
他返回的一个结果呢

15:21.100 --> 15:22.100
是不是也是一个object

15:22.100 --> 15:23.100
那我们在这

15:23.100 --> 15:24.100
再来看刷新一下

15:24.100 --> 15:25.100
这里

15:25.100 --> 15:26.100
就把这个问题呢

15:26.100 --> 15:27.100
给他修正了

15:27.100 --> 15:28.100
就是一个false

15:28.100 --> 15:29.100
他呢

15:29.100 --> 15:30.100
不是一个对象啊

15:30.100 --> 15:31.100
所以说呢

15:31.100 --> 15:32.100
返回的结果

15:32.100 --> 15:33.100
就是一个false

15:33.100 --> 15:34.100
这个呢

15:34.100 --> 15:36.100
非常非常的精准啊

15:36.100 --> 15:37.100
剩下的东西呢

15:37.100 --> 15:39.100
我们就不再去说了

15:39.100 --> 15:40.100
到时候大家自己呢

15:40.100 --> 15:41.100
去了解一下就行了啊

15:41.100 --> 15:43.100
其实我们通过这个

15:43.100 --> 15:45.100
字面词就能够去看出来

15:45.100 --> 15:46.100
asfaction

15:46.100 --> 15:47.100
是不是用来检测

15:47.100 --> 15:50.100
他是不是一个函数呀

15:50.100 --> 15:51.100
好

15:51.100 --> 15:52.100
那往下

15:52.100 --> 15:53.100
往下到哪里呢

15:53.100 --> 15:54.100
到这开始

15:54.100 --> 15:55.100
从这儿

15:55.100 --> 15:56.100
到哪里呢

15:56.100 --> 15:57.100
到这儿

15:57.100 --> 15:58.100
那to看到吗

15:58.100 --> 15:59.100
to啥意思啊

15:59.100 --> 16:00.100
就是用来

16:00.100 --> 16:01.100
转换的

16:01.100 --> 16:02.100
其实这个to street

16:02.100 --> 16:03.100
to to array

16:03.100 --> 16:04.100
所以呢

16:04.100 --> 16:05.100
他们都是用来

16:05.100 --> 16:06.100
把我们的参数

16:06.100 --> 16:07.100
转换成一个数组

16:07.100 --> 16:08.100
然后这个呢

16:08.100 --> 16:09.100
to street

16:09.100 --> 16:10.100
是不是很多很多

16:10.100 --> 16:11.100
就这个呢

16:11.100 --> 16:12.100
我们在原生的

16:12.100 --> 16:13.100
原生ts当中呢

16:13.100 --> 16:14.100
也是有学倒过的啊

16:14.100 --> 16:15.100
在这呢

16:15.100 --> 16:16.100
咱们就演示几个吧

16:16.100 --> 16:19.540
比如说这个to array

16:19.540 --> 16:20.540
to array呢

16:20.540 --> 16:21.540
它是用来

16:21.540 --> 16:22.540
转换数组的

16:22.540 --> 16:32.810
来a等于一个e

16:32.810 --> 16:34.810
然后再来上一个b

16:34.810 --> 16:35.810
等于一个

16:35.810 --> 16:39.310
等于一个2

16:39.310 --> 16:40.310
我们看一下啊

16:40.310 --> 16:41.310
这个呢

16:41.310 --> 16:42.310
如何能够转换一个数组啊

16:42.310 --> 16:44.310
再看刷新

16:44.310 --> 16:45.310
刷新之后呢

16:45.310 --> 16:46.310
他会把所有的数据

16:46.310 --> 16:47.310
给他取出来

16:47.310 --> 16:48.310
也就是value

16:48.310 --> 16:49.310
给他取出来

16:49.310 --> 16:50.310
然后呢

16:50.310 --> 16:51.310
放到一个数组当中

16:51.310 --> 16:52.310
注意啊

16:52.310 --> 16:53.310
我们在课程一开始的时候

16:53.310 --> 16:55.310
说过了一个什么的

16:55.310 --> 16:56.310
这个

16:56.310 --> 16:57.310
这个东西呢

16:57.310 --> 16:58.310
他是用来

16:58.310 --> 16:59.310
强制转换数组

16:59.310 --> 17:00.310
强制转换数组呢

17:00.310 --> 17:01.310
很暴力

17:01.310 --> 17:02.310
他直接呢

17:02.310 --> 17:03.310
在外边加上了

17:03.310 --> 17:04.310
一个中扩号

17:04.310 --> 17:06.310
甭管你传的是什么数据

17:06.310 --> 17:07.310
他都会当作

17:07.310 --> 17:08.310
第一个数据

17:08.310 --> 17:09.310
是吧

17:09.310 --> 17:10.310
而这个呢

17:10.310 --> 17:11.310
跟他是不一样的

17:11.310 --> 17:12.310
你知道吧

17:12.310 --> 17:13.310
这个对象呢

17:13.310 --> 17:14.310
他仅仅是把这个

17:14.310 --> 17:16.310
value值给他拿了出来啊

17:16.310 --> 17:17.310
然后再来

17:17.310 --> 17:20.310
还有我们传上一个

17:20.310 --> 17:22.310
ABC

17:22.310 --> 17:23.310
这是一个字不算

17:23.310 --> 17:25.310
再来刷新走着

17:25.310 --> 17:28.310
变成了数组的ABC

17:28.310 --> 17:30.620
再给上一个

17:30.620 --> 17:31.620
那

17:32.620 --> 17:33.620
那这个呢

17:33.620 --> 17:34.620
我们看啊

17:34.620 --> 17:35.620
刷新

17:35.620 --> 17:36.620
就是一个空

17:36.620 --> 17:37.620
他转不了了

17:37.620 --> 17:38.620
所以说呢

17:38.620 --> 17:39.620
就是一个空

17:39.620 --> 17:40.620
他不会像我们的

17:40.620 --> 17:41.620
那个方法

17:41.620 --> 17:42.620
给他加上

17:42.620 --> 17:43.620
变成这个的

17:43.620 --> 17:44.620
行

17:44.620 --> 17:45.620
他不会啊

17:45.620 --> 17:46.620
好

17:46.620 --> 17:47.620
那这样的话

17:47.620 --> 17:50.620
就是关于这个浪身上的

17:50.620 --> 17:51.620
这些方法呢

17:51.620 --> 17:52.620
我们就算是

17:52.620 --> 17:53.620
已经说完了

17:53.620 --> 17:54.620
然后呢

17:54.620 --> 17:55.620
这个mess

17:55.620 --> 17:56.620
跟这个number

17:56.620 --> 17:57.620
这个对象呢

17:57.620 --> 17:59.620
我们就不再去说了

17:59.620 --> 18:00.620
因为他的

18:00.620 --> 18:01.620
这个里头的

18:01.620 --> 18:02.620
这些方法呢

18:02.620 --> 18:03.620
都是mess对象

18:03.620 --> 18:04.620
跟number身上

18:04.620 --> 18:05.620
对象的

18:05.620 --> 18:06.620
原生的那些方法

18:06.620 --> 18:07.620
所以说呢

18:07.620 --> 18:08.620
咱没必要去花一些时间

18:08.620 --> 18:09.620
再去介绍他了

18:09.620 --> 18:10.620
行

18:10.620 --> 18:11.620
这节课呢

18:11.620 --> 18:12.620
去说一下这个object

18:12.620 --> 18:13.620
那这节课呢

18:13.620 --> 18:14.620
咱们就说到这里

