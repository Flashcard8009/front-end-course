WEBVTT

00:01.000 --> 00:03.000
下面我们接着来说

00:03.000 --> 00:06.000
这节课咱们要说的是Faction

00:06.000 --> 00:09.000
关于Date里头仅仅只有一个方法

00:09.000 --> 00:12.000
这个方法就是用来获取当前的一个时间点

00:12.000 --> 00:14.000
就是一个No

00:14.000 --> 00:17.000
你去试一下就知道什么意思了

00:17.000 --> 00:19.000
我们这节课主要去说一下Faction

00:19.000 --> 00:21.000
Faction当中也是

00:21.000 --> 00:24.000
它给我们扩展了很多的一些方法

00:24.000 --> 00:26.000
我们来详细的去说一下

00:26.000 --> 00:29.000
这个Faction当中首先咱要去说的一下

00:29.000 --> 00:30.000
是这个Bend

00:30.000 --> 00:33.000
其他的一些其实都是用的比较窄的

00:33.000 --> 00:36.000
Bend的这个方法

00:36.000 --> 00:38.000
它是用来绑定函数的

00:38.000 --> 00:40.000
跟call play等等那些

00:40.000 --> 00:42.000
跟他们还不一样

00:42.000 --> 00:43.000
那些是调用

00:43.000 --> 00:44.000
这个是绑定

00:44.000 --> 00:46.000
然后Faction对象身上

00:46.000 --> 00:48.000
是有这个对象的

00:48.000 --> 00:49.000
有这个方法的

00:49.000 --> 00:50.000
你到时候去看一下

00:50.000 --> 00:52.000
它原生的那个方法就行了

00:52.000 --> 00:55.000
然后往下就是说一个这个

00:55.000 --> 00:57.000
这个方法它是用来做什么

00:57.000 --> 01:00.000
做颗里化的函数

01:00.000 --> 01:03.000
那这个东西颗里化以及后边还有一个

01:03.000 --> 01:07.000
颗里化还有这个防斗函数

01:07.000 --> 01:10.000
以及还有这个截流

01:10.000 --> 01:12.000
截流函数

01:12.000 --> 01:15.000
这不是截流

01:15.000 --> 01:18.000
截流好像不在这

01:18.000 --> 01:21.000
截流从这到吧

01:21.000 --> 01:22.000
在这呢

01:22.000 --> 01:24.000
这是截流

01:24.000 --> 01:28.000
然后他们其实都是用来做性能优化的

01:28.000 --> 01:29.000
所以这个东西

01:29.000 --> 01:32.000
就是他其实是属于我们函数当中的一些概念

01:32.000 --> 01:34.000
那人家这个low dash

01:34.000 --> 01:36.000
其实是帮咱们去封装了一下

01:36.000 --> 01:37.000
有兴趣的同学

01:37.000 --> 01:38.000
你们可以去查一下

01:38.000 --> 01:40.000
它的原码

01:40.000 --> 01:41.000
然后你看一下

01:41.000 --> 01:43.000
它到底是如何去封装

01:43.000 --> 01:44.000
什么的颗里化

01:44.000 --> 01:46.000
还有截流跟防斗的

01:46.000 --> 01:47.000
我们在这就不去说了

01:47.000 --> 01:48.000
这些

01:48.000 --> 01:50.000
其实你用到的时候

01:50.000 --> 01:53.000
你就会明白了

01:53.000 --> 01:54.000
再往下

01:54.000 --> 01:57.000
再往下咱们说一个diff

01:57.000 --> 01:59.000
diff说这个

01:59.000 --> 02:02.000
diff它是推迟调用faction

02:02.000 --> 02:04.000
这个东西倒是有一些用处

02:04.000 --> 02:05.000
我们来看一下

02:05.000 --> 02:08.000
那在这就是我首先

02:08.000 --> 02:11.000
先直接去调一下这个方法

02:11.000 --> 02:13.000
diff

02:13.000 --> 02:14.000
怎么去调呢

02:14.000 --> 02:16.000
给上一个faction

02:16.000 --> 02:19.000
然后faction接受一个参数叫text

02:19.000 --> 02:22.000
这个里头我们cancelogue

02:22.000 --> 02:23.000
cancelogue什么呢

02:23.000 --> 02:27.570
canceloguetext

02:27.570 --> 02:28.570
好

02:28.570 --> 02:29.570
然后接下来

02:29.570 --> 02:31.570
就是这个参数

02:31.570 --> 02:34.570
它是作为我们的这个实参

02:34.570 --> 02:35.570
实参是放在哪里

02:35.570 --> 02:37.570
放在这里

02:37.570 --> 02:38.570
最后

02:38.570 --> 02:40.570
比如说这是第2次

02:40.570 --> 02:44.570
第2次试见循环

02:44.570 --> 02:45.570
好

02:45.570 --> 02:46.570
然后在下边

02:46.570 --> 02:47.570
我跟着来上一个cancelogue

02:47.570 --> 02:52.570
这个是第1次试见循环

02:53.570 --> 02:55.570
这个方法到底是用来干嘛的

02:55.570 --> 02:58.570
它其实是用来延迟执行

02:58.570 --> 02:59.570
我们的这个方法的

02:59.570 --> 03:00.570
然后我们在这

03:00.570 --> 03:01.570
大家先想一想

03:01.570 --> 03:04.570
这个cancelogue是按什么顺序

03:04.570 --> 03:06.570
打印出来的呢

03:06.570 --> 03:08.570
它先出来还是它先出来

03:08.570 --> 03:09.570
还是说它先出来

03:09.570 --> 03:10.570
它先出来

03:10.570 --> 03:11.570
我们在这打开一面

03:11.570 --> 03:12.570
控制台调出来

03:12.570 --> 03:13.570
来看一下

03:13.570 --> 03:14.570
其实是第1次

03:14.570 --> 03:15.570
先来第2次再来

03:15.570 --> 03:16.570
是不是

03:16.570 --> 03:18.570
也就说这个cancelogue先发生

03:18.570 --> 03:20.570
然后这个是不是再次发生

03:20.570 --> 03:22.570
其实这种是不是不太符合

03:22.570 --> 03:23.570
我们之前所讲的

03:23.570 --> 03:25.570
解词所执行的一个顺序

03:25.570 --> 03:28.570
比如说我们在这cancelogue

03:28.570 --> 03:29.570
一个什么

03:29.570 --> 03:30.570
log1

03:30.570 --> 03:31.570
我问你

03:31.570 --> 03:32.570
1跟它谁先谈

03:32.570 --> 03:34.570
必然是它先打印

03:34.570 --> 03:35.570
然后它才能够打印

03:35.570 --> 03:36.570
是不是

03:36.570 --> 03:37.570
但是就是

03:37.570 --> 03:38.570
这种形式

03:38.570 --> 03:39.570
它其实并没有打印

03:39.570 --> 03:40.570
这是为啥

03:40.570 --> 03:42.570
这是由于试见循环期制

03:42.570 --> 03:44.570
这个试见循环期制

03:44.570 --> 03:45.570
就是说

03:45.570 --> 03:46.570
这个方法

03:46.570 --> 03:47.570
它会放在了第2次

03:47.570 --> 03:48.570
试见循环的时候

03:48.570 --> 03:49.570
才会去执行它

03:49.570 --> 03:50.570
也就是说

03:50.570 --> 03:51.570
这个方法什么时候走

03:51.570 --> 03:53.570
就是我们的script标签当中

03:53.570 --> 03:56.570
所有同步的代码都走完了

03:56.570 --> 03:57.570
接下来第2次

03:57.570 --> 03:59.570
接下来才走它

03:59.570 --> 04:01.570
这个就是一个延迟执行

04:01.570 --> 04:03.570
它也是有一些用处的

04:03.570 --> 04:04.570
比如说我们的

04:04.570 --> 04:05.570
塞塞3当中

04:05.570 --> 04:07.570
塞塞3当中

04:07.570 --> 04:08.570
我们如果说动态的

04:08.570 --> 04:09.570
去通过transition

04:09.570 --> 04:11.570
让某一些属性去过渡

04:11.570 --> 04:13.570
假设说

04:13.570 --> 04:14.570
添加过渡的transition

04:14.570 --> 04:15.570
还有一集

04:15.570 --> 04:17.570
我们过渡的属性

04:17.570 --> 04:19.570
都要通过我们的GS完成

04:19.570 --> 04:20.570
这个时候是不是说

04:20.570 --> 04:21.570
你先去添

04:21.570 --> 04:22.570
在这假设说

04:22.570 --> 04:23.570
你先添一个transition

04:23.570 --> 04:25.570
然后接下来直接让它的left

04:25.570 --> 04:27.570
只等于一个20

04:27.570 --> 04:28.570
其实这个时候

04:28.570 --> 04:30.570
它是没有一个过渡的情况的

04:30.570 --> 04:32.570
因为你们都是同时发生的

04:32.570 --> 04:33.570
懂吧

04:33.570 --> 04:35.570
你想要让它动的话

04:35.570 --> 04:37.570
只能是先添上

04:37.570 --> 04:38.570
完了之后

04:38.570 --> 04:40.570
再让它动

04:40.570 --> 04:42.570
所以它有一个先后的顺序

04:42.570 --> 04:44.570
这个就是需要

04:44.570 --> 04:45.570
我们通过这种形式

04:45.570 --> 04:47.570
就能够去解决这个问题

04:47.570 --> 04:48.570
好吧

04:48.570 --> 04:50.570
这个就是推迟调用函数

04:50.570 --> 04:52.570
在第二次事件循环的时候

04:52.570 --> 04:53.570
再去用它

04:53.570 --> 04:54.570
然后往下走

04:54.570 --> 04:56.570
就是一个delay

04:56.570 --> 04:57.570
这个delay

04:57.570 --> 04:58.570
它其实就是一个

04:58.570 --> 05:00.570
延迟执行的一个方法

05:00.570 --> 05:01.570
它其实就是一个定时器

05:01.570 --> 05:02.570
它的一个语法

05:02.570 --> 05:04.570
跟上面是一样的

05:04.570 --> 05:06.570
我们在这没有标是吧

05:06.570 --> 05:10.220
diff

05:10.220 --> 05:12.220
然后这个是delay

05:12.220 --> 05:17.460
它的语法跟上面

05:17.460 --> 05:19.460
是一模一样的

05:19.460 --> 05:22.460
然后这个传实际的一个参数

05:22.460 --> 05:25.460
要放在一个数字的后面

05:25.460 --> 05:26.460
这个后面

05:26.460 --> 05:27.460
我们比如说

05:27.460 --> 05:29.460
这是延迟

05:29.460 --> 05:37.030
延迟

05:37.030 --> 05:39.030
1秒执行

05:39.030 --> 05:41.030
在这我们concelogue

05:46.840 --> 05:47.840
logo什么呢

05:47.840 --> 05:49.840
就logo text

05:49.840 --> 05:50.840
来看一下

05:50.840 --> 05:52.840
来刷新一下

05:52.840 --> 05:53.840
过1秒钟

05:53.840 --> 05:54.840
然后打印出来了

05:54.840 --> 05:55.840
是吧

05:55.840 --> 05:56.840
延迟1秒执行

05:56.840 --> 05:58.840
它其实就是一个定时器

05:58.840 --> 06:00.840
就是一个延迟执行的

06:00.840 --> 06:01.840
这么一个定时器

06:01.840 --> 06:03.840
好往下走

06:03.840 --> 06:04.840
往下走

06:04.840 --> 06:05.840
到这个方法

06:05.840 --> 06:06.840
这个方法

06:06.840 --> 06:07.840
它是用来干嘛

06:07.840 --> 06:08.840
它是调用的时候

06:08.840 --> 06:10.840
让我们的函数的参数

06:10.840 --> 06:11.840
进行一个翻转

06:11.840 --> 06:14.840
本身是从左往右的顺序

06:14.840 --> 06:16.840
然后当我们去使用这个方法的时候

06:16.840 --> 06:17.840
函数的一个参数

06:17.840 --> 06:19.840
就会变成一个从右往左的

06:19.840 --> 06:20.840
这么一个顺序了

06:20.840 --> 06:21.840
来看一下它

06:21.840 --> 06:23.840
这我需要去声明一个函数

06:23.840 --> 06:27.860
叫ifaction

06:27.860 --> 06:30.860
faction一个ifn1

06:30.860 --> 06:31.860
ifn1当中

06:31.860 --> 06:32.860
我们直接去concelogue

06:32.860 --> 06:33.860
logo什么的

06:33.860 --> 06:35.860
logo arguments

06:35.860 --> 06:36.860
目的就是为了

06:36.860 --> 06:38.860
让大家能够看到

06:38.860 --> 06:39.860
在调用的时候

06:39.860 --> 06:41.860
我们传的一个参数

06:41.860 --> 06:43.860
它的一个实际的顺序

06:43.860 --> 06:44.860
然后这个方法

06:44.860 --> 06:46.860
是一个很普通的一个方法

06:46.860 --> 06:47.860
然后我再改造一下它

06:47.860 --> 06:48.860
它等于什么

06:48.860 --> 06:51.860
等于我要去调这个方法

06:51.860 --> 06:54.860
把fn1传进去

06:54.860 --> 06:55.860
把它改造一下

06:55.860 --> 06:56.860
改造完之后

06:56.860 --> 06:59.860
再重新丢给我的fn1

06:59.860 --> 07:00.860
知道吧

07:00.860 --> 07:01.860
然后接下来

07:01.860 --> 07:03.860
我们再去调它fn1

07:03.860 --> 07:05.860
直接调一个123

07:05.860 --> 07:07.860
我们来看一下

07:07.860 --> 07:08.860
控制台当中走着

07:08.860 --> 07:09.860
好

07:09.860 --> 07:10.860
我们看到这个arguments

07:10.860 --> 07:13.860
它的顺序是不是321

07:13.860 --> 07:17.860
刚好是把我们函数的参数

07:17.860 --> 07:18.860
它的一个调用的顺序

07:18.860 --> 07:20.860
给它翻转了一下

07:20.860 --> 07:23.860
那往下就是还有一个

07:23.860 --> 07:25.860
取反的这么一个函数

07:26.860 --> 07:32.130
取反是它

07:32.130 --> 07:35.130
这是这取反

07:35.130 --> 07:37.130
取反是什么意思呢

07:37.130 --> 07:39.130
就是把真的变成假的

07:39.130 --> 07:40.130
黑的变成白的

07:40.130 --> 07:41.130
好

07:41.130 --> 07:42.130
这个就是一个取反

07:42.130 --> 07:46.130
这个取反来faction一个fn2

07:46.130 --> 07:48.130
然后在这我直接return

07:48.130 --> 07:49.130
return什么

07:49.130 --> 07:50.130
一个n磨上一个几

07:50.130 --> 07:51.130
磨上一个2

07:51.130 --> 07:53.130
然后等于一个0

07:53.130 --> 07:54.130
好

07:54.130 --> 07:55.130
这是一个条件

07:55.130 --> 07:56.130
返回的一个值

07:56.130 --> 07:57.130
那我问一下n磨上2

07:57.130 --> 07:58.130
等于0

07:58.130 --> 07:59.130
是不是偶数

07:59.130 --> 08:01.130
像2468等等

08:01.130 --> 08:02.130
能够被整除

08:02.130 --> 08:03.130
能够被整除的话

08:03.130 --> 08:05.130
那是不是渔数

08:05.130 --> 08:06.130
就为0

08:06.130 --> 08:08.130
这个就是我们n

08:08.130 --> 08:10.130
都是一个什么的偶数

08:10.130 --> 08:11.130
是不是

08:11.130 --> 08:12.130
好

08:12.130 --> 08:13.130
然后接下来

08:13.130 --> 08:15.130
console.log

08:15.130 --> 08:16.130
那个什么

08:16.130 --> 08:17.130
我们要调一个方法

08:17.130 --> 08:19.130
这个方法是filter

08:19.130 --> 08:20.130
这个filter

08:20.130 --> 08:21.130
跟我们原生的方法

08:21.130 --> 08:22.130
是一样的

08:22.130 --> 08:23.130
它用来过滤

08:23.130 --> 08:24.130
是不是

08:24.130 --> 08:25.130
然后一个数组

08:25.130 --> 08:28.130
4456

08:28.130 --> 08:29.130
好

08:29.130 --> 08:30.130
总共6个数据

08:30.130 --> 08:31.130
好

08:31.130 --> 08:32.130
然后filter

08:32.130 --> 08:33.130
把这个数据

08:33.130 --> 08:34.130
给它过滤了

08:34.130 --> 08:35.130
那过滤

08:35.130 --> 08:36.130
是不是

08:36.130 --> 08:37.130
我要按一个过滤的

08:37.130 --> 08:38.130
一个方法去过滤

08:38.130 --> 08:39.130
什么方法去过滤

08:39.130 --> 08:40.130
就是第2个参数

08:40.130 --> 08:41.130
然后第2个参数

08:41.130 --> 08:43.130
就是我们要给的

08:43.130 --> 08:44.130
这个

08:44.130 --> 08:46.130
方法

08:46.130 --> 08:47.130
给进来

08:47.130 --> 08:48.130
就是取反了这么一个

08:48.130 --> 08:49.130
函数

08:49.130 --> 08:50.130
好

08:50.130 --> 08:51.130
然后把什么传进来

08:51.130 --> 08:52.130
把fn2传进来

08:52.130 --> 08:53.130
也就是说

08:53.130 --> 08:54.130
现在我的filter

08:54.130 --> 08:55.130
是过滤

08:55.130 --> 08:57.130
然后他的一个过滤的条件

08:57.130 --> 08:58.130
或说过滤的一个形式

08:58.130 --> 09:00.130
就是取反了这种形式

09:00.130 --> 09:01.130
这个函数

09:01.130 --> 09:02.130
本身是

09:02.130 --> 09:04.130
只有当2468

09:04.130 --> 09:05.130
也就是偶数的时候

09:05.130 --> 09:06.130
才能够满足条件

09:06.130 --> 09:07.130
是不是

09:07.130 --> 09:08.130
你看他一取反

09:08.130 --> 09:09.130
是不是说

09:09.130 --> 09:10.130
变成一个几数了

09:10.130 --> 09:12.130
我们来看一下这个条件

09:12.130 --> 09:13.130
看一下这个结果

09:13.130 --> 09:14.130
刷清一下

09:16.130 --> 09:17.130
n

09:17.130 --> 09:18.130
这个n我们有丢

09:18.130 --> 09:20.130
刷清

09:20.130 --> 09:21.130
好

09:21.130 --> 09:22.130
看到没有

09:22.130 --> 09:23.130
一个结果

09:23.130 --> 09:24.130
是一个135

09:24.130 --> 09:26.130
那是不是就取了一个反

09:26.130 --> 09:28.130
本身是246

09:28.130 --> 09:29.130
对吧

09:29.130 --> 09:30.130
246

09:30.130 --> 09:32.130
然后取了一个反

09:32.130 --> 09:33.130
变成了

09:33.130 --> 09:34.130
也就是这个条件

09:34.130 --> 09:35.130
他取了一个反

09:35.130 --> 09:37.130
变成了一个135

09:37.130 --> 09:38.130
好

09:38.130 --> 09:39.130
继续再说

09:39.130 --> 09:40.130
另外一个方法

09:41.130 --> 09:42.130
另外一个方法

09:42.130 --> 09:43.130
是什么

09:43.130 --> 09:44.130
是wans

09:44.130 --> 09:45.130
这个方法

09:45.130 --> 09:46.130
wans这个方法

09:46.130 --> 09:48.130
它是保证了

09:48.130 --> 09:49.130
我们的函数

09:49.130 --> 09:50.130
只能够被调用一次

09:50.130 --> 09:51.130
也就是

09:51.130 --> 09:52.130
能够执行一遍

09:52.130 --> 09:53.130
执行一遍之后

09:53.130 --> 09:54.130
就失效了

09:54.130 --> 09:55.130
其实跟我们的解释

09:55.130 --> 09:56.130
跟我们的

09:56.130 --> 09:57.130
函数当中

09:57.130 --> 09:59.130
那个方法是一模一样的

09:59.130 --> 10:01.500
wans

10:01.500 --> 10:03.500
这生命一个方法

10:04.500 --> 10:05.500
faction

10:05.500 --> 10:06.500
然后fn3

10:07.500 --> 10:08.500
这个fn3

10:08.500 --> 10:10.500
我们console.log

10:10.500 --> 10:17.310
log一个fn3

10:17.310 --> 10:18.310
然后接下来

10:18.310 --> 10:19.310
我在生命一个辨量

10:19.310 --> 10:21.310
newfn3

10:21.310 --> 10:22.310
它等于什么

10:22.310 --> 10:24.310
等于我调一下

10:24.310 --> 10:25.310
wans这个方法

10:25.310 --> 10:27.310
把fn3给它丢进来

10:27.310 --> 10:28.310
这个时候

10:28.310 --> 10:30.310
就把函数给它改造了

10:30.310 --> 10:31.310
改成什么

10:31.310 --> 10:32.310
改成了函数

10:32.310 --> 10:34.310
它只能够执行一次

10:34.310 --> 10:35.310
也就是他们的生命

10:35.310 --> 10:36.310
只有一次

10:36.310 --> 10:37.310
是吧

10:37.310 --> 10:38.310
只有一次

10:38.310 --> 10:39.310
当你调完之后

10:39.310 --> 10:40.310
它就挂了

10:40.310 --> 10:41.310
我就在下边

10:41.310 --> 10:42.310
newfn3

10:42.310 --> 10:43.310
然后执行一下

10:43.310 --> 10:44.310
我们看一下

10:44.310 --> 10:45.310
页面当中

10:45.310 --> 10:46.310
打印出来的fn3

10:46.310 --> 10:47.310
刷新一下

10:47.310 --> 10:48.310
有没有

10:48.310 --> 10:49.310
有

10:49.310 --> 10:50.310
然后接着

10:50.310 --> 10:51.310
再来

10:51.310 --> 10:52.310
假设说

10:52.310 --> 10:53.310
这个东西

10:53.310 --> 10:54.310
我再执行一下

10:54.310 --> 10:56.310
只能够打印出一次

10:56.310 --> 10:58.310
然后就没有了

10:58.310 --> 10:59.310
函数

10:59.310 --> 11:00.310
当它执行完之后

11:00.310 --> 11:02.310
它的生命就结束了

11:02.310 --> 11:03.310
完成了使命了

11:03.310 --> 11:04.310
好吧

11:04.310 --> 11:05.310
行

11:05.310 --> 11:06.310
关于faction当中

11:06.310 --> 11:07.310
咱们就说这么多

11:07.310 --> 11:08.310
剩下的那些东西

11:08.310 --> 11:09.310
大家自己去看一下

11:09.310 --> 11:10.310
你看一下人家的

11:10.310 --> 11:12.310
这个API的一个说明

11:12.310 --> 11:13.310
以及再来看一下

11:13.310 --> 11:14.310
Lease就OK了

11:14.310 --> 11:15.310
好吧

11:15.310 --> 11:16.310
这节课

11:16.310 --> 11:17.310
我们说到这里

