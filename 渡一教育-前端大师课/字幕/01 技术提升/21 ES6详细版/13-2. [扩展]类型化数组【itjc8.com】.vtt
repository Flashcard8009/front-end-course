WEBVTT

00:00.690 --> 00:04.090
接下来几节课呢 可能都是扩展课程

00:05.090 --> 00:10.090
嗯 这几节扩展课程呢 如果大家有兴趣看的话啊 那么一定要连着看

00:10.290 --> 00:15.890
就是从头到尾看一遍啊 不要在中间选择看 因为呢 这几节课程呢 都是有联系的

00:16.690 --> 00:21.890
我们这几节课呢 继续来讨论ES6给数组的一些增强的功能

00:22.490 --> 00:27.290
其中有一个比较冷门的知识点 我把作为扩展课程 叫做内形花数组

00:28.690 --> 00:30.490
那么这个东西是做什么用的呢

00:31.090 --> 00:38.090
我要解释这个东西做什么用的 我都要花一些时间来解释一些前置知识 不然的话 大家不是很明白

00:39.090 --> 00:44.890
我们要了解什么样的前置知识呢 就是数字存处的 就是计算机里面 怎么去存处数字的

00:45.990 --> 00:51.790
这几个点呢 大家都需要理解 理解了之后呢 才能去理解 还为什么会出现内形花数组

00:52.390 --> 00:59.990
好 为个来啊 首先大家要必须要理解的是计算机 他只能使用固定的位数

01:00.690 --> 01:06.490
来存处数字 这是他意思呢 这个什么叫固定的位数呢 首先我们要了解这个东西

01:06.890 --> 01:13.090
什么叫位数呢 因为我们计算机里面存处的数据啊 他是用二净之的方式来存处的

01:13.790 --> 01:25.790
每一个二净之位呢 就表示一位 比方说计算机里面一位 他就能存放两个数字 零和一对吧 两位呢就能存放零零零一零

01:26.190 --> 01:36.390
对不对 计算机里面他必须要使用固定的位数来存处数字 这又是啥意思呢 就比方说我们要存处一个数字一

01:37.190 --> 01:42.590
他在计算机里面是怎么存处的 他不是说就是存出一个一 他不是这样存处的 他可能是这样存处的

01:43.790 --> 01:50.990
前面是个零零零零零零零零零零零零零零零零零零零零零零零零零零零零零一 他可能是这样存处的

01:51.990 --> 02:01.990
你看他用了多少位啊 是不是用了16位 是不是用了16位来存处数字 对吧 如果说存处二呢 他可能会这样存处 可能啊不是不是一定的

02:03.190 --> 02:10.190
存处二呢 他可能这样存处 别人的意思吗 也就是说不管你存处的数字是小

02:11.090 --> 02:17.190
还是大 他在计算机里面占用的空间是一定的 所以说这一点他说明了什么呢

02:17.690 --> 02:27.990
无论存处的数字是大 是小 在内存中占用的空间是固定的

02:29.090 --> 02:34.690
比如说我存处的数字是零 好像就是没有占什么空间一样的 没有任何区别

02:35.490 --> 02:38.690
那么计算机他为什么要使用这种方式来存处数字呢

02:39.290 --> 02:44.290
啊 这有跟那个什么 跟计算机组成原理 甚至跟编译原理有关系的

02:44.690 --> 02:51.290
就是计算机呢 他要读取数据 他是一块一块读的啊 每一块读一点每一块读一点对吧

02:51.590 --> 02:54.490
那么他之后就要知道这一块跟上

02:55.090 --> 02:59.490
就是每一块之间他是没有一个东西来分割的 他不知道这是一块那是一块

03:00.090 --> 03:04.690
比方说我们最初计算机里面计算机里面啊 他的里面全是这种

03:08.590 --> 03:13.790
那里告诉我他这里存了几个数字呢 一告诉他怎么分 就是分斗号就让我们中文断句一样

03:14.690 --> 03:19.690
分斗号他就知道怎么分了 他不知道 他不知道这里面存了几个数字

03:20.290 --> 03:26.690
所以说呢 你就必须要告诉他我存一个数字有多少位 比方说一个数字有八位

03:26.890 --> 03:32.090
他就这样读 第一个数字是什么呢 第一个数字是这个 我看我看云了

03:32.690 --> 03:38.990
第一个数字是第一个数字啊 第二个数字啊 第二个数字呢又读八位啊

03:39.190 --> 03:41.990
这第二个数字 第三个数字呢 又读八位

03:42.490 --> 03:44.990
就是第三个数字 明白这意思吗 河北就不写了啊

03:45.990 --> 03:49.790
所以说他必为什么必须要用固定的位数来存出数字

03:49.990 --> 03:53.990
因为他不知道数字与数字之间的分割在哪里 他不知道

03:54.690 --> 03:58.190
所以说他必须要用固定的位数来读 一是读多少位 一是读多少位

03:58.590 --> 04:02.790
这是第一个点要理解的 计算机他是用固定的位数来存出数字的

04:03.690 --> 04:07.690
那么这样子呢 就分化出来了很多种存储方案 有八位的

04:08.190 --> 04:11.890
有十六位的 有三十二位的 等等等等

04:12.890 --> 04:17.290
那么N位的无符号整数能表示的数字是

04:17.490 --> 04:21.690
二的N次方个取之范围是0到2的N次方减1

04:21.890 --> 04:24.690
这个怎么理解呢 我给大家写个例子

04:25.090 --> 04:28.690
比方说 举个例子 比方说计算机能用八位

04:30.290 --> 04:36.290
用八位的无符号 什么叫无符号 就只管正数 不要管复数

04:36.490 --> 04:43.290
不管复数 八位的无符号整数 它能够表示的数字有哪些呢

04:43.890 --> 04:49.090
我们先说不说八位吗 我们先说四位 四位呢 无符号整数有哪些呢

04:49.690 --> 04:55.490
0000 四位都多了 那就三位嘛 三位

04:56.290 --> 05:03.890
0000 两位嘛 哪能写 哪能写 0000 100 11

05:04.290 --> 05:09.090
是不是一共有四个 对不对 是不是四个 4个是不是2的2次方个

05:09.590 --> 05:18.790
那么三位呢 三位没看一下啊 0000 00100 0010 0010

05:19.490 --> 05:26.590
呃 还有什么 10010 1110 1111属于下一几个呗 是8个

05:27.090 --> 05:33.090
为什么是8个 2的3次方格 所以说N位的无符号整数能表示多少个数字呢

05:33.090 --> 05:38.090
它只表示整数 不表示小数 不管

05:38.090 --> 05:40.690
而且腹数不管 因为是无符号

05:40.690 --> 05:44.090
这个有没有符号就表示的是 是不是能表示腹数

05:44.090 --> 05:46.290
无符号的话就不能表示腹数

05:46.290 --> 05:49.290
而且现在只管整数 只管整数

05:49.290 --> 05:52.690
那么整数它是能表示多少个呢 二的 n 次方格

05:52.690 --> 05:57.290
取值范围是多少呢 取值范围那里看呗

05:57.290 --> 06:00.690
三位的无符号数 取值范围是不是零 零到多少

06:01.290 --> 06:04.290
零到 有些同学说是八 这个东西是七

06:04.290 --> 06:08.690
这个地方是七 零到七 没了意思吗

06:08.690 --> 06:10.690
一共有多少个吗 一共有八个 对不对

06:10.690 --> 06:15.090
八个数字 有八个数字包含零 是不是最多只能到七

06:15.090 --> 06:19.890
因此它的取值范围是多少 零的二的 n 次方减1

06:19.890 --> 06:24.090
没了意思吗 它最大能够表示二的 n 次方减1

06:24.090 --> 06:27.890
那么也就是说 这个东西同时说明了这个什么道理呢

06:28.090 --> 06:33.490
一个整数 一个数字 你给它的位数越多

06:33.490 --> 06:37.290
那么它能表示的数字范围就越多 越大

06:37.290 --> 06:42.490
能够表示的最大数字也越大 同时占用的内存空间也越多

06:42.490 --> 06:46.090
所以说明这个道理 对吧 OK 这是三位的

06:46.090 --> 06:50.290
就是 n 位的无符号整数 能够表示的数字的个数

06:50.290 --> 06:53.090
以及它的取值范围

06:53.090 --> 06:56.290
那么什么叫做有符号呢 就是n 位的有符号整数

06:56.290 --> 06:59.090
就是什么情况了 有符号整数其实很简单

06:59.090 --> 07:02.690
它就把整个二进字的第一位作为符号位

07:02.690 --> 07:07.090
用后边的位数来存储数字 比方三位 三位无符号整数

07:07.090 --> 07:10.720
三位有符号整数

07:10.720 --> 07:13.520
那么它存储的 它也能存储八个 也能

07:13.520 --> 07:17.120
它一共就这么些位数 对吧 它一共只有这么多种可能

07:17.120 --> 07:19.420
是不是一共也只能存储八种数字

07:19.420 --> 07:23.920
但是它用第一位来表示符号 依旧表示复数

07:23.920 --> 07:25.820
第一位是理论 就表示证书

07:25.820 --> 07:29.420
所以第一位它不参与具体数字的存储

07:29.420 --> 07:31.220
是不是它这样子的话

07:31.220 --> 07:35.220
它只有后边的部分才存储数字 对吧 具体的数字

07:35.220 --> 07:39.120
第一位来表示符号 它多了一个符号位

07:39.120 --> 07:41.820
所以这样子它就能表示复数了

07:41.820 --> 07:44.220
因此呢 你想这个道理

07:44.220 --> 07:48.220
比方说一共能表示八个数字

07:48.220 --> 07:52.320
它如果能只表示证书的话 是不是0到7

07:52.320 --> 07:55.020
如果它既能表示证书 又能表示复数的话

07:55.020 --> 07:57.420
是不是还要把一些数字往复数上分

07:57.420 --> 08:00.620
那么就是多少呢 它就是能表示的数字是

08:00.620 --> 08:06.920
复4 到多少呢 到3 你数一下是不是一共八个

08:06.920 --> 08:09.720
复4 复3 复2 复1 四个

08:09.720 --> 08:12.420
一共1 2 3 4个 对吧

08:12.420 --> 08:14.720
所以一共能表示八个 因为它只 不管怎么样

08:14.720 --> 08:17.620
它只能表示八个 它表示的数字的个数呢

08:17.620 --> 08:19.620
是没有变化的 二的 n 次方个

08:19.620 --> 08:21.920
为什么没变化呢 因为只有这么多种情况

08:21.920 --> 08:24.920
你只有3位嘛 所以说只能有这么多种情况

08:24.920 --> 08:28.220
但是它要往数字上分一半 对不对

08:28.220 --> 08:31.520
那么包含0 它就出现这么一种情况

08:31.520 --> 08:36.620
复的多少呢 复的2的 n-1 次方

08:36.620 --> 08:38.620
2的 n-1 次方 1是3位

08:38.620 --> 08:42.120
那么就是复的2的2 次方就是复4

08:42.120 --> 08:46.220
要减1 因为它就少了一位来表示数字了

08:46.220 --> 08:48.720
那么证书呢 因为它包含0

08:48.720 --> 08:52.020
所以说要减1 2的 n-1 次方减1

08:52.020 --> 08:53.720
就是这么个意思

08:53.820 --> 08:56.520
这是n 位的有符号整数

08:56.520 --> 08:59.420
能表示的取之范围 以及它的数字个数

09:00.620 --> 09:04.620
好 那么前面都讨论的是整数 小数怎么办呢

09:04.620 --> 09:06.620
在计算机里边小数的存储呢

09:06.620 --> 09:09.820
它使用的是伏点数存储法

09:09.820 --> 09:13.220
那么伏点数存储法又是什么样的存储方式呢

09:13.220 --> 09:15.120
它是这样子的 我大概跟大家说一说

09:15.120 --> 09:18.320
因为这里要展开的话东西太多了

09:18.320 --> 09:21.220
还有什么补码呀 繁码之类的东西

09:21.320 --> 09:23.320
还有位移 这些东西

09:23.320 --> 09:25.820
我们就说一下简单的表示方式

09:25.820 --> 09:28.320
伏点数的表示法呢

09:28.320 --> 09:30.820
它可以表示整数 又可以表示小数

09:30.820 --> 09:33.320
那么它到底是怎么来表示的呢

09:33.320 --> 09:35.420
它是把任何一个数字

09:35.420 --> 09:37.320
把它变成这么一种格式

09:37.320 --> 09:41.320
任何一个数字变为这么一种格式

09:43.020 --> 09:48.420
1. 啥啥啥啥啥啥啥啥啥啥啥

09:48.620 --> 09:56.380
然后乘以10的n次方

09:57.380 --> 09:58.380
是不是任何一个数字

09:58.380 --> 10:01.880
这是不是我们在数学里面学的科学技术法

10:01.880 --> 10:05.380
对吧 任何一个数字是不是都可以转换成这种格式

10:05.380 --> 10:07.980
对不对 无论是你是整数也好

10:07.980 --> 10:10.180
还是这个小数也好

10:10.180 --> 10:11.880
是不是都可以转换成这种格式

10:11.880 --> 10:13.380
这科学技术法

10:13.380 --> 10:16.780
于是呢 这个底数是不是固定的

10:16.780 --> 10:19.280
一定是10的n多好次方

10:19.280 --> 10:20.580
那么变化的是什么呢

10:20.580 --> 10:22.480
变化的是这个n指数

10:22.480 --> 10:25.280
已经呢 这一部分

10:25.280 --> 10:30.180
我们把这一部分的数字叫做精度

10:30.180 --> 10:34.480
那么这一部分的数字叫做指数

10:34.480 --> 10:37.080
那么在计算机里面怎么来存出一个小数呢

10:37.080 --> 10:39.680
它首先把小数转换成这种格式

10:39.680 --> 10:41.880
它自动转换的内部

10:41.880 --> 10:44.180
把它转换成这种格式来进行存出

10:44.180 --> 10:47.180
那么存的时候是不是这一位固定的不用管

10:47.180 --> 10:49.280
那么只需要管这一位就行了

10:49.280 --> 10:51.580
对吧 是不是只需要管这一位就行了

10:51.580 --> 10:53.780
这一个部分 对不对

10:53.780 --> 10:55.980
那么来管这一个部分

10:55.980 --> 10:57.580
好 这一个部分怎么来写呢

10:57.580 --> 11:00.780
它就第一个 第一个位数

11:00.780 --> 11:06.340
比方说我们这里是二净字

11:06.340 --> 11:07.940
这里是二净字

11:07.940 --> 11:09.740
我们后面不写了

11:09.740 --> 11:12.240
第一个位来表示符号

11:12.240 --> 11:13.340
0表示正数

11:13.340 --> 11:14.740
1表示复数

11:14.740 --> 11:17.240
这个是符号位

11:17.340 --> 11:19.740
然后中间哪一部分出来呢

11:19.740 --> 11:21.840
来表示指数

11:21.840 --> 11:23.840
就是把指数存在这

11:23.840 --> 11:27.740
这个指数的存处叫睫马

11:27.740 --> 11:31.240
以后我们可以看到 睫马

11:31.240 --> 11:32.140
是这么个意思

11:32.140 --> 11:34.540
那么剩下的来存出伪数

11:34.540 --> 11:35.540
伪数是什么呢

11:35.540 --> 11:38.240
就是这里的有效数字

11:38.240 --> 11:40.040
它是用这种方式来存的

11:40.040 --> 11:41.340
分成三个部分

11:41.340 --> 11:45.540
就是符号 睫马和伪数

11:45.640 --> 11:47.240
那么这样子具体的存处

11:47.240 --> 11:48.540
又有两种方式

11:48.540 --> 11:50.740
一是32位伏点数

11:50.740 --> 11:52.240
什么叫32位伏点数呢

11:52.240 --> 11:54.140
就是我存出一个小数也好

11:54.140 --> 11:54.940
整数也好

11:54.940 --> 11:56.940
一共要花费32位

11:56.940 --> 11:58.440
不管你的数字是大是小

11:58.440 --> 11:59.440
都要花费32位

11:59.440 --> 12:00.540
哪怕你是0

12:00.540 --> 12:02.340
我都要花费32位

12:02.340 --> 12:03.240
那么这种数字

12:03.240 --> 12:06.640
称为单净度伏点数

12:06.640 --> 12:07.540
它是怎么表示的呢

12:07.540 --> 12:09.440
它是用1位表示符号

12:09.440 --> 12:10.840
8位表示睫马

12:10.840 --> 12:12.840
23位表示伪数

12:12.840 --> 12:14.240
它就这么一回事

12:14.240 --> 12:16.740
它就说第一位表示符号

12:16.740 --> 12:18.040
后面8位

12:18.040 --> 12:23.540
12345678

12:23.540 --> 12:25.640
这一部分表示睫马

12:25.640 --> 12:27.640
然后后面23位表示伪数

12:27.640 --> 12:31.240
1234567899412445456

12:34.240 --> 12:36.240
一个32位的伏点数

12:36.240 --> 12:37.540
它就这么一种格式

12:37.540 --> 12:40.540
这一部分是符号位

12:40.540 --> 12:42.240
第二部分是睫马

12:42.240 --> 12:44.520
甚至增加了23位 一共加起了32位

12:44.760 --> 12:47.160
甚至23位的表示尾数 尾数就是

12:47.520 --> 12:49.360
精度 就是有效数字那一部分

12:49.600 --> 12:50.880
这32位的浮电数

12:51.800 --> 12:55.120
那么 还有另外一种表示方式 叫六十四位的浮电数

12:55.360 --> 12:57.040
它称为双精度浮电数

12:57.400 --> 13:01.400
它是用一位表示符号 11位表示肩 五十二位表示尾数

13:02.880 --> 13:05.360
那么这两种方案都是国际标准

13:05.360 --> 13:09.040
一般的任何的计算机语言 它会选择其中一种

13:09.120 --> 13:13.320
来作为小数的 就是浮电数的表示方式

13:14.600 --> 13:17.240
不过有些语言的 还有不少的语言

13:17.240 --> 13:20.440
它都选择两种都有 有32位的 也有64位的

13:21.000 --> 13:21.680
这么个意思

13:22.840 --> 13:25.960
通过我们刚才的解释 大家也可以发现

13:27.120 --> 13:30.600
浮电数它表示的尾数越多

13:30.880 --> 13:34.760
是不是表示的指数部分就 尾数越多

13:35.280 --> 13:38.080
同时表示的尾数部分就越多 对吧

13:38.280 --> 13:43.840
说明了 双精度浮电数能够表示的数字取之范围

13:43.840 --> 13:45.360
是不是比32位要更大

13:45.880 --> 13:51.680
并且双精度浮电数它能够表示的有效数字

13:51.680 --> 13:53.680
是不是更多 什么叫有效数字

13:53.960 --> 13:55.800
就是说你的小数点后边

13:55.800 --> 13:59.080
就是你一共有多少个数字 比较说你33.1

13:59.520 --> 14:02.480
33.1 那么这个是一共有几个有效数字的

14:02.480 --> 14:05.440
4个 对吧 是不是有4个有效数字

14:05.760 --> 14:07.280
33.1 对不对

14:07.760 --> 14:08.760
有4个有效数字

14:08.760 --> 14:11.920
另外 比方说你1点这样子 这样子写

14:11.920 --> 14:13.240
是不是有多少个有效数字

14:13.240 --> 14:16.840
1 2 3 4 5 6 7 8 9 对吧 有9个有效数字

14:16.840 --> 14:18.920
就这么个意思 它是这么个意思

14:19.920 --> 14:24.120
就是你的精度越高 64位 就是位数越多

14:24.120 --> 14:25.680
那么它表示的尾数就越大

14:25.680 --> 14:29.240
说明它的有效数字越高 并且它尖码越多

14:29.240 --> 14:32.640
那么就表示它能够得到的指数就越高

14:32.640 --> 14:34.520
能够表示的数字范围就越大

14:35.000 --> 14:36.000
是这么个意思

14:36.000 --> 14:39.000
但是当然了 它浪费的内存空间 不是浪费嘛

14:39.000 --> 14:41.080
就是占用的存存收空间就越多

14:41.880 --> 14:45.680
这里有一个小的知识

14:45.680 --> 14:48.880
在介石语言里边 你一般不会遇到

14:48.880 --> 14:50.760
因为它只会有一种数据内容

14:50.760 --> 14:51.560
我们以后会说

14:52.920 --> 14:55.160
你在其他语言里边 一般来说

14:55.160 --> 15:00.000
如果说你的有效数字超过了7位

15:00.000 --> 15:01.360
超过了7位

15:01.360 --> 15:04.440
那么你建议你使用 64位浮炼数

15:04.440 --> 15:05.800
就是双净度的

15:05.800 --> 15:07.440
如果说你低于7位的话

15:07.440 --> 15:10.160
我们一般就使用那个32位的

15:10.160 --> 15:11.160
没有这意思吗

15:12.520 --> 15:15.120
这是关于那个浮炼数的表示法

15:15.120 --> 15:17.800
好 前面都是一些常识

15:17.800 --> 15:19.480
那么接下来我们看一下最后一个点

15:20.840 --> 15:23.920
就是介石中所有的数字

15:25.200 --> 15:29.200
均使用双净度浮炼数标存

15:29.200 --> 15:30.560
也就是说介石

15:30.560 --> 15:32.480
它没有这些乱七八糟的存存方案

15:32.480 --> 15:35.240
它只有一种就是64位浮炼数

15:35.240 --> 15:37.240
它整数也是用它存的

15:37.240 --> 15:39.040
小数也是用它存的

15:39.040 --> 15:41.440
零也是用它存的

15:41.440 --> 15:44.240
介石只有一种数据内容

15:44.240 --> 15:45.880
就是Lumber

15:45.880 --> 15:49.960
而Lumber就是一个64位的浮炼数

15:49.960 --> 15:51.800
这是我们的一些前置知识

15:51.800 --> 15:55.080
现在我们再回过头来看一下

15:55.080 --> 15:59.030
为什么需要内形化数组

15:59.030 --> 16:02.530
再来说内形化数组

16:02.530 --> 16:03.730
为什么需要它呢

16:03.770 --> 16:06.730
是因为之前介石的数字

16:06.730 --> 16:07.930
长期以来

16:07.930 --> 16:10.130
只有一种数字内形

16:10.130 --> 16:12.530
使用64位的浮炼数来存处

16:12.530 --> 16:14.690
这样子在某些时候

16:14.690 --> 16:17.490
特别是存处很多数字的时候

16:17.490 --> 16:19.570
就会造成内存空间的浪费

16:20.890 --> 16:21.850
怎么意思呢

16:21.850 --> 16:22.730
比较说我一个数组

16:23.610 --> 16:25.250
存了100个零

16:25.250 --> 16:27.010
存了100个零

16:27.010 --> 16:28.890
那里告诉我占了多少位

16:30.850 --> 16:32.330
来 存了100个零

16:33.810 --> 16:35.170
一个数组里面存了100个零

16:35.170 --> 16:36.410
它占了多少位呢

16:36.410 --> 16:37.530
要不然说是零位

16:37.530 --> 16:38.970
它不可能对吧

16:38.970 --> 16:40.770
它一定是每一个数字

16:40.770 --> 16:42.050
它一定占64位

16:42.050 --> 16:45.810
是不是6400位

16:45.810 --> 16:46.090
对吧

16:46.090 --> 16:47.130
所以6400位

16:48.130 --> 16:49.290
对不对

16:49.290 --> 16:50.730
占用了6400位

16:52.090 --> 16:53.050
然后6400位

16:53.050 --> 16:54.650
占用了多少内存空间呢

16:54.650 --> 16:56.290
因为v是最小单位

16:56.290 --> 16:56.930
我们看一下

16:58.410 --> 16:59.770
一个字节呢

16:59.770 --> 17:00.690
就是一bit

17:00.690 --> 17:02.890
一字节等于8位

17:03.890 --> 17:04.570
8位

17:04.570 --> 17:05.330
v is bit

17:06.170 --> 17:07.290
一字节等于8位

17:07.290 --> 17:09.610
字节是计算机存取数据的

17:09.610 --> 17:10.450
最小单位

17:10.450 --> 17:11.890
它不可能按v来存取

17:11.890 --> 17:13.210
它效率太低了

17:13.210 --> 17:15.890
它是8个位的来

17:15.890 --> 17:19.010
读取数据和写数据

17:19.010 --> 17:20.490
它是字节是最小单位

17:21.610 --> 17:23.370
一个字节等于8位

17:23.370 --> 17:28.290
然后一kb等于1024个字节

17:29.210 --> 17:31.690
然后一照1024kb

17:31.850 --> 17:32.610
后边不写了

17:32.610 --> 17:34.970
一gb等于1024nb

17:34.970 --> 17:35.210
好

17:35.210 --> 17:36.410
咱们来看一下吧

17:36.410 --> 17:37.530
你占用了多少呢

17:37.530 --> 17:41.330
我们用标准6400位

17:41.330 --> 17:45.170
多少个字节除以800个字节

17:45.170 --> 17:47.490
800个字节都快要接近1kb了

17:47.490 --> 17:48.170
对吧

17:48.170 --> 17:50.290
是不是快要接近1kb了

17:50.290 --> 17:52.050
你就存了100个理容

17:52.050 --> 17:55.210
你要占用这么多内存空间

17:55.210 --> 17:56.370
没有这个必要

17:56.370 --> 17:57.610
没有这个必要

17:57.610 --> 17:58.490
所以说呢

17:59.530 --> 18:00.650
在很多时候

18:00.690 --> 18:02.130
我们在有些场景下边

18:02.130 --> 18:02.970
我们可能要

18:03.970 --> 18:07.050
就是要特别在意内存空间的使用

18:08.050 --> 18:10.650
因此我们用传统的那种数据

18:10.650 --> 18:11.850
来存储的话

18:11.850 --> 18:13.450
会非常大的

18:13.450 --> 18:15.450
造成内存空间非常大的浪费

18:16.730 --> 18:19.210
所以说为了解决这样的问题

18:19.210 --> 18:21.650
解释就出来了内存化数据

18:22.170 --> 18:23.250
那么内存化数据

18:23.250 --> 18:24.930
它一句话来解释

18:24.930 --> 18:27.010
内存化数据起什么作用呢

18:27.050 --> 18:31.130
它是用于优化多个数据

18:31.130 --> 18:33.130
数字的存储

18:33.970 --> 18:35.770
它是用于优化多个数字的存储

18:35.770 --> 18:37.890
也就是我们这几课学的内存化数据

18:37.890 --> 18:39.690
只针对数字

18:39.690 --> 18:41.810
不存在什么其他什么对象的存储

18:42.330 --> 18:43.090
还有什么呢

18:43.090 --> 18:44.770
就是布尔

18:44.770 --> 18:45.450
芝福串

18:45.450 --> 18:45.930
不存在

18:45.930 --> 18:47.130
只是针对数字

18:47.770 --> 18:49.050
因为我们有的时候

18:49.050 --> 18:51.730
有些数字根本就没有必要

18:51.730 --> 18:53.370
去用64位来用

18:53.370 --> 18:54.130
比方说有些数字

18:54.130 --> 18:57.410
它要么可能就10亿的一范围的数字

18:57.410 --> 18:58.050
对吧

18:58.050 --> 19:00.410
那么我们用那么多位够来存储干嘛了

19:00.410 --> 19:02.530
浪费了内存空间

19:02.530 --> 19:04.810
所以说它出来这么一个内存化数据

19:04.810 --> 19:07.570
内存化数据里边它分为很多种

19:07.570 --> 19:08.970
它具体分为

19:10.250 --> 19:12.050
这么一些

19:12.050 --> 19:13.930
int8

19:13.930 --> 19:15.850
int8而为

19:15.850 --> 19:16.610
int什么意思

19:16.610 --> 19:17.290
整数

19:17.290 --> 19:18.010
8什么意思

19:18.010 --> 19:19.290
占8位

19:19.290 --> 19:24.650
就是8位有符号整数

19:24.650 --> 19:25.450
那么你想一想

19:25.450 --> 19:28.410
8位的有符号整数取之范围是多少

19:28.410 --> 19:32.570
是不是-2的四次方

19:32.570 --> 19:34.530
-2的七次方是多少

19:34.530 --> 19:37.010
-126

19:37.010 --> 19:37.930
到多少

19:37.930 --> 19:40.130
到125

19:40.130 --> 19:41.490
它存出的有效

19:41.490 --> 19:42.610
它只能存出的数字

19:42.610 --> 19:44.890
只能是-126到125

19:44.890 --> 19:45.410
对吧

19:45.410 --> 19:48.810
这是8位的有符号整数

19:48.810 --> 19:54.010
然后又分为int8而为

19:54.010 --> 19:57.450
前面加个u表示的是无符号

19:57.450 --> 19:58.370
因为英文里边

19:58.370 --> 20:01.050
un表示的是相反

20:01.050 --> 20:02.890
无符号的话

20:02.890 --> 20:06.890
就是8位无符号整数

20:06.890 --> 20:08.170
它的取之范围是多少

20:08.170 --> 20:09.450
是不是0

20:09.450 --> 20:11.090
0到多少

20:11.090 --> 20:14.090
到255

20:14.090 --> 20:18.650
然后它还包含了int6而为

20:19.490 --> 20:21.050
你懂的

20:21.050 --> 20:21.290
对吧

20:21.290 --> 20:21.930
不写了

20:21.930 --> 20:25.770
他们uint16而为

20:25.770 --> 20:27.050
不写了

20:27.050 --> 20:28.570
然后是什么

20:28.570 --> 20:33.090
int32而为

20:33.090 --> 20:39.290
uint32而为

20:39.290 --> 20:41.570
明白的意思吗

20:41.570 --> 20:42.690
后面不写了

20:42.690 --> 20:44.610
也就是我们的内形化数组

20:44.610 --> 20:46.450
它分为了这么一些

20:46.450 --> 20:48.170
这么一些内形化数组

20:48.330 --> 20:49.650
每一种内形化数组

20:49.650 --> 20:51.770
它里边只能存出数字

20:51.770 --> 20:52.970
只能存出数字

20:52.970 --> 20:54.650
它不可能存出其他东西的

20:54.650 --> 20:55.810
它每一个位置

20:55.810 --> 20:57.330
数组里面每一个位置

20:57.330 --> 20:59.290
占用的内存空间

20:59.290 --> 21:00.330
是固定的

21:00.330 --> 21:01.290
int8而为

21:01.290 --> 21:05.410
它的每一个元素占用的是8位的内存空间

21:05.410 --> 21:07.210
uint8而为

21:07.210 --> 21:08.890
它表示的是也是8位

21:08.890 --> 21:09.930
int16而为

21:09.930 --> 21:11.570
表示的是每一个元素

21:11.570 --> 21:12.930
占用16位的内存空间

21:12.930 --> 21:14.370
是这么个意思

21:14.370 --> 21:17.410
接下来我们来看一下例子

21:17.450 --> 21:19.450
这样我们开始来写代码

21:19.450 --> 21:20.690
首先第一个

21:20.690 --> 21:22.730
如何来创建一个数组

21:22.730 --> 21:24.610
特别简单

21:24.610 --> 21:26.130
看着

21:26.130 --> 21:31.330
比方说我们要创建一个8位的int8而为

21:31.330 --> 21:33.730
那么来吧

21:33.730 --> 21:39.090
就6一个int8而为

21:39.090 --> 21:40.570
就完了

21:40.570 --> 21:41.890
这就是个勾到函数

21:41.890 --> 21:43.170
你直接6它就行了

21:43.170 --> 21:45.330
那么这里边可以有两种方式

21:45.330 --> 21:46.530
就极动方式

21:46.570 --> 21:50.210
第一个就是写上它的长度

21:50.210 --> 21:51.930
数组的长度

21:51.930 --> 21:56.570
比方说数组的长度为10

21:56.570 --> 21:58.130
咱们来输出一下这个而为

21:58.130 --> 22:00.010
保存

22:00.010 --> 22:01.330
输出下个而为

22:01.330 --> 22:03.610
看一下

22:03.610 --> 22:05.330
点击右键 检查

22:05.330 --> 22:06.130
空残

22:06.130 --> 22:07.010
你看

22:07.010 --> 22:08.650
是不是每一项

22:08.650 --> 22:09.530
给你存的一些东西

22:09.530 --> 22:09.810
对吧

22:09.810 --> 22:10.410
存的是什么

22:10.410 --> 22:11.290
存的是0

22:11.290 --> 22:12.290
存的是0

22:12.290 --> 22:14.570
也就是它不存在像以前的那个数组

22:14.570 --> 22:16.370
以前我们再对比一下

22:17.370 --> 22:18.530
然后再来一个

22:18.530 --> 22:20.650
而为

22:20.650 --> 22:21.690
就普通数组

22:21.690 --> 22:23.330
普通数组给它长度为10

22:23.330 --> 22:24.570
我们来输出

22:24.570 --> 22:25.850
输出

22:25.850 --> 22:26.570
你会发现

22:26.570 --> 22:28.330
它这个数组

22:28.330 --> 22:29.450
它没有下标

22:29.450 --> 22:29.770
对吧

22:29.770 --> 22:30.610
没有下标

22:30.610 --> 22:31.090
为什么

22:31.090 --> 22:32.090
它是个蓄松数组

22:32.090 --> 22:32.370
对不对

22:32.370 --> 22:33.930
它只是规定了长度为10

22:33.930 --> 22:35.210
它里边没东西

22:35.210 --> 22:36.770
但是这里边不存在

22:36.770 --> 22:38.890
这里边它是考虑的是内存空间

22:38.890 --> 22:39.610
所以说

22:39.610 --> 22:41.850
它会对内存空间进行初始化

22:41.850 --> 22:43.610
初始化的话全是0

22:43.610 --> 22:44.930
对这一块内存

22:44.970 --> 22:46.610
初始化过后了全是0

22:46.610 --> 22:48.210
所以它不存在说这里边没东西

22:48.210 --> 22:50.050
这里边存出了全是0

22:50.050 --> 22:50.850
长度为多少

22:50.850 --> 22:52.330
长度为10

22:52.330 --> 22:53.370
没有意思吗

22:53.370 --> 22:53.530
好

22:53.530 --> 22:55.210
那么你可以想象一下

22:55.210 --> 22:56.530
这个东西

22:56.530 --> 22:59.090
它占了多少内存空间

22:59.090 --> 23:00.730
占了多少个字节

23:00.730 --> 23:02.450
你想一想

23:02.450 --> 23:03.730
你想呗

23:03.730 --> 23:06.690
数组里边每一个元素

23:06.690 --> 23:08.530
每一个元素占多少位

23:08.530 --> 23:09.530
占8位

23:09.530 --> 23:10.810
8位不就是一个字节吗

23:10.810 --> 23:12.850
你说每一个元素占一个字节

23:12.850 --> 23:14.210
你跟它长度为10

23:14.250 --> 23:15.810
是不是占了10个字节

23:15.810 --> 23:16.570
对吧

23:16.570 --> 23:17.850
占了10个字节

23:17.850 --> 23:22.130
并我们还可以用代码来看出这一点

23:22.130 --> 23:24.250
这个数组里边有一些属性

23:24.250 --> 23:25.690
我还是在这里记录一下吧

23:27.010 --> 23:27.770
第一个

23:27.770 --> 23:29.330
如何创建数组

23:29.330 --> 23:30.450
如何创建数组

23:33.660 --> 23:35.500
这些都是内存化数组

23:35.500 --> 23:38.340
就是6一个勾兆函数

23:40.300 --> 23:42.540
数组勾兆函数

23:44.180 --> 23:45.180
这里边写长度

23:45.740 --> 23:47.260
这是第1种方式

23:47.260 --> 23:50.660
那么这里我们创建好了数组之后

23:50.660 --> 23:52.660
我们可以

23:54.100 --> 23:55.020
第二步

23:55.020 --> 23:56.540
得到长度

23:56.540 --> 24:00.410
得到长度有两种方式

24:00.410 --> 24:01.810
就是数组

24:01.810 --> 24:03.450
都是说的内存化数组

24:03.450 --> 24:04.890
不是以前的普通数组

24:04.890 --> 24:08.050
这是得到元素数量

24:08.050 --> 24:09.970
得到元素数量

24:09.970 --> 24:11.650
就是数组里边有多少个数字

24:11.650 --> 24:12.890
这么个意思

24:12.890 --> 24:13.890
另外一个

24:13.890 --> 24:15.450
是数组

24:15.970 --> 24:16.490
第二

24:16.490 --> 24:18.170
byte-nense

24:18.170 --> 24:19.810
这是得到

24:21.850 --> 24:23.930
占用的字节空间

24:23.930 --> 24:27.850
占用的字节数

24:27.850 --> 24:29.490
你占用了多少个字节

24:29.490 --> 24:30.730
这有两个长度

24:30.730 --> 24:34.170
一个是nense

24:34.170 --> 24:37.570
一个是byte-nense

24:37.570 --> 24:39.090
这两个不一样的

24:39.090 --> 24:39.610
保存

24:39.610 --> 24:40.290
你看一下

24:42.570 --> 24:43.090
对了

24:43.090 --> 24:43.650
没问题

24:43.650 --> 24:44.130
好

24:44.170 --> 24:46.450
第一个表示数组里边元素各数

24:46.450 --> 24:47.410
有多少个元素

24:47.410 --> 24:48.170
有10个

24:48.170 --> 24:49.370
占用多少的内存空间

24:49.370 --> 24:51.770
一共占用10个字节

24:51.770 --> 24:52.730
是这么个意思

24:52.730 --> 24:53.730
为什么现在是一样的

24:53.730 --> 24:54.890
因为因此把每一个元素

24:54.890 --> 24:56.050
刚好占用一个字节

24:56.050 --> 24:57.210
比方说你这里用的是

24:57.210 --> 24:58.130
因此三二

24:58.130 --> 25:00.010
你看一下就不一样了

25:00.010 --> 25:00.610
你看

25:01.770 --> 25:03.530
一共有10个元素

25:03.530 --> 25:05.330
但是占用的字节是40个

25:05.330 --> 25:06.090
为什么了

25:06.090 --> 25:07.730
因为一个占用32位

25:07.730 --> 25:09.450
32位就是4个8

25:09.450 --> 25:10.650
就是4个字节

25:10.650 --> 25:11.490
没了意思吗

25:11.490 --> 25:12.690
这两个属性

25:12.730 --> 25:13.890
一个表示的是

25:13.890 --> 25:15.170
数组本身的长度

25:15.170 --> 25:16.850
一个表示字节数

25:18.970 --> 25:20.010
那么这个数组

25:20.010 --> 25:21.810
我们刚才看到其中第一种

25:21.810 --> 25:22.810
创建数组的方式

25:22.810 --> 25:24.130
就给它一个长度

25:24.130 --> 25:25.450
那么我们能不能像之前

25:25.450 --> 25:27.250
那个普通数组那样子

25:28.250 --> 25:29.770
我们不仅可以创建

25:29.770 --> 25:30.850
给它一个长度

25:30.850 --> 25:33.450
而且我们可以初始化里边的元素了

25:33.450 --> 25:34.930
当然可以

25:34.930 --> 25:37.090
但是你肯定不能用这种方式

25:37.090 --> 25:38.610
这种方式肯定是不行的

25:38.610 --> 25:38.930
为什么

25:38.930 --> 25:39.930
这是用普通数组

25:39.930 --> 25:40.170
对吧

25:40.170 --> 25:42.210
不是内存化数组

25:42.250 --> 25:43.370
哪里要用什么方式

25:43.370 --> 25:44.610
要用这种方式

25:44.610 --> 25:45.810
不能用这种方式

25:45.810 --> 25:47.570
不能用也不能用这种

25:47.570 --> 25:48.890
把元素裸裂掉这

25:48.890 --> 25:49.890
因为我之前说过

25:49.890 --> 25:51.970
我记得我上节课的时候就说过

25:51.970 --> 25:52.770
因为这种方式

25:52.770 --> 25:54.530
用一个第一种方式造成起义

25:54.530 --> 25:55.730
比方说你只有一个元素

25:55.730 --> 25:57.690
那这个东西到底是元素还是长度了

25:57.690 --> 25:58.330
对不对

25:58.330 --> 26:00.330
所以说它秉弃了以前的那种

26:00.330 --> 26:02.530
容易产生起义的方式

26:02.530 --> 26:03.730
主要而使用什么

26:03.730 --> 26:05.010
就是我们上节课接触的

26:06.290 --> 26:07.810
使用二

26:07.810 --> 26:10.090
那么把我们的元素裸裂在这

26:10.210 --> 26:13.090
比方说我们3 5 6 7

26:13.090 --> 26:13.930
OK

26:13.930 --> 26:15.450
一共4个元素

26:15.450 --> 26:17.730
产生一个内存化数组

26:17.730 --> 26:19.170
因此3 2的内存化数组

26:19.170 --> 26:19.610
保存

26:19.610 --> 26:20.890
咱们看一下

26:20.890 --> 26:22.570
我们把数组输出

26:22.570 --> 26:23.090
输出

26:23.090 --> 26:23.970
2 2

26:23.970 --> 26:24.330
保存

26:24.330 --> 26:25.210
看一下吧

26:25.210 --> 26:25.490
你看

26:25.490 --> 26:27.010
一般是不是3 5 6 7

26:27.010 --> 26:27.650
对不对

26:27.650 --> 26:30.650
所以说这是创建内存化数组的第二种方式

26:30.650 --> 26:31.450
使用

26:31.450 --> 26:32.530
数组勾造函数

26:34.050 --> 26:35.410
勾造函数

26:35.410 --> 26:35.770
第二

26:35.770 --> 26:36.210
什么呢

26:36.210 --> 26:37.690
OF

26:37.690 --> 26:38.170
元素

26:39.170 --> 26:41.610
哪些元素写到这就完成了

26:41.610 --> 26:44.610
这第二种创建内存化数组的方式

26:44.610 --> 26:44.930
好

26:44.930 --> 26:47.170
那么既然现在我们可以填充元素了

26:47.170 --> 26:48.330
现在我们来看一下

26:48.330 --> 26:49.850
如果我使用的是

26:49.850 --> 26:50.810
印尺8

26:50.810 --> 26:52.370
就是占8位

26:52.370 --> 26:54.330
因为我们知道8位的话

26:54.330 --> 26:57.090
它的取值范围是-125

26:57.090 --> 26:58.290
126

26:58.290 --> 27:00.530
到-125

27:00.530 --> 27:02.850
所以说这里面存储这个区间的数字

27:02.850 --> 27:03.890
都是没有问题的

27:03.890 --> 27:05.890
如果说你的存储数字比较大

27:05.890 --> 27:07.090
比方说我这里

27:07.170 --> 27:08.730
存储的是126

27:08.730 --> 27:10.410
是不是超过这个数字了

27:10.410 --> 27:11.810
那么它会怎么样呢

27:11.810 --> 27:12.530
保存

27:12.530 --> 27:13.370
你看一下

27:14.930 --> 27:15.490
哦

27:15.490 --> 27:16.130
这里

27:16.130 --> 27:16.650
这里

27:16.650 --> 27:17.530
这里

27:17.530 --> 27:18.610
这里

27:18.610 --> 27:19.450
这里是那个

27:19.450 --> 27:20.450
负责128

27:20.450 --> 27:21.650
我这怎么回事

27:21.650 --> 27:24.610
负责228到127

27:24.610 --> 27:25.330
127

27:25.330 --> 27:26.450
是这样子的

27:26.450 --> 27:27.850
我这些记错了

27:27.850 --> 27:28.690
2到7次方

27:28.690 --> 27:29.690
2到8次方

27:29.690 --> 27:31.810
2到7次方128

27:31.810 --> 27:32.450
好

27:32.450 --> 27:35.410
那么这里我们写个128

27:35.490 --> 27:36.450
因为它正数的话

27:36.450 --> 27:37.570
只能存到127

27:37.570 --> 27:38.050
对吧

27:38.050 --> 27:38.970
那么它会怎么样呢

27:38.970 --> 27:39.810
我们来看一下

27:39.810 --> 27:41.250
它会导致E出

27:41.250 --> 27:43.130
本来我们存的是128的

27:43.130 --> 27:44.490
它结果把它看成了一个

27:44.490 --> 27:46.210
本来我们存的是多少

27:46.210 --> 27:47.090
128的

27:47.090 --> 27:49.090
它把它看成的是负责128

27:49.090 --> 27:50.490
那么也就是说我们的数字

27:50.490 --> 27:51.530
本来存的是一个数字

27:51.530 --> 27:52.610
它变成了另外一个数字

27:52.610 --> 27:53.170
为什么

27:53.170 --> 27:55.970
它有些位数被丢弃掉了

27:55.970 --> 27:57.490
或者叫E出了

27:57.490 --> 27:58.570
E出了

27:58.570 --> 27:59.370
它其实怎么回事呢

27:59.370 --> 28:01.290
128就像再往前进一

28:01.290 --> 28:03.090
它就导致了第一位

28:03.090 --> 28:04.370
变成了比南市零

28:04.370 --> 28:05.130
变成了E

28:05.170 --> 28:07.290
变成E它就变成负数了

28:07.290 --> 28:09.050
总之我们的存出的数据

28:09.050 --> 28:11.170
数字它就会出现问题

28:11.170 --> 28:14.450
因此你选择了什么样的长度

28:14.450 --> 28:16.770
你只能存出那个长度的数字

28:16.770 --> 28:18.770
你只能存出那个范围内的数字

28:18.770 --> 28:21.450
你不能存出范围之外的数字

28:21.450 --> 28:22.930
不然的话

28:22.930 --> 28:26.010
结果可能会造成差异

28:26.010 --> 28:27.770
那比方说负数也是

28:27.770 --> 28:29.610
我们该存的是负的

28:29.610 --> 28:30.850
最多只能到128

28:30.850 --> 28:31.050
对吧

28:31.050 --> 28:32.570
我们该存一个负的128

28:32.570 --> 28:33.850
你看一下没问题的

28:33.850 --> 28:35.090
负的128没问题

28:35.250 --> 28:37.410
那么负的129

28:37.410 --> 28:38.690
你看呀

28:38.690 --> 28:40.290
变成了127

28:40.290 --> 28:40.890
对吧

28:40.890 --> 28:41.890
就会出现问题

28:41.890 --> 28:43.450
所以说大家一定要注意一点

28:43.450 --> 28:45.370
那如果说你超出更多的数字的话

28:45.370 --> 28:47.290
那肯定就变得很奇怪了

28:47.290 --> 28:48.690
变成42了

28:48.690 --> 28:51.010
总之它每一个数字只能是

28:51.010 --> 28:53.930
只能是这个取值范围之内

28:53.930 --> 28:55.330
大家一定要注意

28:55.330 --> 28:56.290
所以大家选择

28:56.290 --> 28:57.730
到底要选择哪一个类型

28:57.730 --> 29:01.650
关键取决于你这个数字中有可能

29:01.650 --> 29:04.650
就是有可能存出的数字它的范围

29:04.770 --> 29:08.050
比方说我们要存出一个连凝

29:08.650 --> 29:09.130
对吧

29:09.130 --> 29:11.010
连凝的一个数组

29:11.010 --> 29:12.610
连凝的话

29:12.610 --> 29:15.810
它又什么样的数字不要好了

29:15.810 --> 29:16.850
又什么样的数字了

29:16.850 --> 29:18.210
连凝它不可能是负数

29:18.210 --> 29:18.770
对不对

29:18.770 --> 29:19.530
不可能是负数

29:19.530 --> 29:22.890
所以说我们一定不用去选择有符号的

29:22.890 --> 29:24.690
直接选择无符号的

29:24.690 --> 29:25.850
而连凝的话

29:25.850 --> 29:27.210
它又有这么一个特点

29:27.210 --> 29:28.290
连凝什么特点呢

29:28.290 --> 29:31.050
就是连凝它不可能是

29:31.050 --> 29:33.730
不可能是超过200岁300岁

29:33.770 --> 29:36.530
所以说我们只需要选择最小的8就行了

29:36.530 --> 29:38.210
是不是可以用这种方式来存出

29:38.210 --> 29:38.730
对吧

29:41.930 --> 29:43.290
留一个

29:45.290 --> 29:46.330
这是小写的

29:46.330 --> 29:47.330
我说怎么回事

29:47.330 --> 29:48.530
是小写的

29:49.370 --> 29:50.810
好 这边我这里写错了

29:50.810 --> 29:52.050
小写的

29:52.050 --> 29:53.170
这里是小写的

29:53.170 --> 29:55.090
代表有过后就是小写的了

29:56.370 --> 29:57.370
也许我们连凝的话

29:57.370 --> 29:58.570
就可以完全可以选择

29:58.570 --> 30:00.090
u int 8 array

30:00.090 --> 30:01.370
瞄的意思吗

30:01.370 --> 30:02.970
大家注意一下

30:03.050 --> 30:05.810
这是第二种数组的创建方式

30:05.810 --> 30:07.330
类型化数组

30:07.330 --> 30:08.130
还有别的

30:08.130 --> 30:10.410
还有第三种

30:10.410 --> 30:12.130
第三种是使用静态方法

30:12.130 --> 30:13.410
数组构造函数

30:14.610 --> 30:15.530
第二 弗朗

30:15.530 --> 30:18.690
那么这里是可谍带对象

30:18.690 --> 30:20.290
也就是我们的数是来自于哪呢

30:20.290 --> 30:22.370
是来自于一个可谍带对象

30:22.370 --> 30:23.650
这种方式跟那个数组

30:23.650 --> 30:25.770
是不是普通数组是不是一样的

30:25.770 --> 30:26.810
不举例了

30:26.810 --> 30:28.650
可谍带对象放在这就行了

30:28.650 --> 30:30.130
它是可以进行转换的

30:30.130 --> 30:31.610
把一个伪数组内数组

30:31.610 --> 30:33.530
或者是一些其他可谍带对象

30:33.530 --> 30:36.930
转换成一个类型化相应的类型化数组

30:36.930 --> 30:40.770
还有一种方式是使用数组构造函数的时候

30:40.770 --> 30:41.970
数组构造函数

30:43.810 --> 30:48.570
这里传入一个其他类型化数组

30:48.570 --> 30:49.530
其他类型化数组

30:49.530 --> 30:50.770
这什么意思呢

30:50.770 --> 30:51.650
给大家看一下这个例子

30:53.090 --> 30:53.770
copy 2

30:55.850 --> 30:57.250
第一步我们做这么一件事

30:57.250 --> 30:59.450
先创建这么一个类型化数组

31:00.090 --> 31:03.010
六一个int 8 array

31:03.010 --> 31:04.810
或者说我们这样子

31:08.170 --> 31:09.290
这里边放一些数字

31:14.090 --> 31:16.410
然后我们想把这个数组复制一下

31:16.410 --> 31:17.650
产生一个新的数组

31:18.250 --> 31:21.490
我们这里就可以使用这样子的方式

31:24.010 --> 31:25.690
把之前的数组放进来

31:25.690 --> 31:27.610
这样子也可以创建一个数组

31:28.210 --> 31:30.090
这两个数组肯定是不一样的

31:30.090 --> 31:31.210
肯定是两个数组

31:31.450 --> 31:34.050
它只是把里边的元素给你做了一个复制

31:34.450 --> 31:36.170
两个数组的长度也一样

31:37.010 --> 31:40.650
然后这两个数组的内容也一样

31:40.650 --> 31:43.010
只是这两个数组本身它不是一个数组

31:43.010 --> 31:44.690
这有点就是因为它们是对象

31:44.690 --> 31:45.850
数组本身是对象

31:45.850 --> 31:47.050
它是一个引用类型

31:47.570 --> 31:47.970
看一下

31:48.810 --> 31:50.330
你看它们不是一个数组

31:50.330 --> 31:51.850
但是里边的东西是一样的

31:52.210 --> 31:52.650
不要这意思

31:53.530 --> 31:54.410
这是关于这一点

31:54.770 --> 31:55.730
来复制数组了

31:56.450 --> 31:57.330
但是这一点的话

31:57.330 --> 31:58.210
大家要注意的是

31:59.490 --> 32:03.210
如果说你第一个类型化数组是32位的

32:04.130 --> 32:05.170
是32位的

32:05.530 --> 32:07.250
第二个类型化数组是8位的

32:07.250 --> 32:09.050
那么本来是没有什么问题的

32:09.050 --> 32:11.210
如果说里边纯错的东西没有什么问题

32:11.210 --> 32:13.530
但是说如果你说里边的数字32位

32:13.530 --> 32:14.610
因为它装的比较大

32:15.250 --> 32:16.370
它装的数字比较大

32:16.370 --> 32:17.170
你看一下

32:17.170 --> 32:20.010
32位可以装这种2的16

32:20.010 --> 32:21.210
是很大的一个数字

32:21.730 --> 32:24.210
好像是6535好像是多少

32:25.090 --> 32:25.730
最大的数字

32:25.730 --> 32:26.970
你看这个数字能存下的

32:26.970 --> 32:27.330
对吧

32:27.330 --> 32:28.250
是能存下的

32:28.250 --> 32:32.130
但是到了8位的数组里边是存不下了

32:32.130 --> 32:32.610
存不下了

32:32.610 --> 32:34.810
过后它也会导致产生误差

32:34.810 --> 32:37.370
但因为它有些位数就抛弃掉了

32:37.370 --> 32:39.730
它只管它腰的那些位数有小了

32:39.730 --> 32:40.570
你要那意思吗

32:40.810 --> 32:42.850
所以说这个地方大家要注意一下

32:42.850 --> 32:44.610
就是高位的

32:44.610 --> 32:47.810
就是数字往低位的存储的时候

32:47.810 --> 32:48.770
大家要注意一下

32:49.370 --> 32:49.650
好

32:49.650 --> 32:50.490
剩下的事情

32:50.810 --> 32:52.690
其他的用法跟数组一致

32:54.250 --> 32:56.930
其他的用法的用法

32:56.930 --> 32:58.890
跟数组一致

32:59.690 --> 33:01.010
跟普通数组一致

33:02.720 --> 33:04.640
数组一致

33:05.320 --> 33:05.600
好

33:05.600 --> 33:06.240
看一下吧

33:06.760 --> 33:08.600
我们这里有再来一个例子

33:10.200 --> 33:10.720
其他用法

33:10.720 --> 33:12.320
我就大概说一下就行了

33:14.880 --> 33:16.320
比方说我们这里有个数组

33:16.840 --> 33:17.640
AR

33:17.640 --> 33:19.200
那么我们可以对它做什么了

33:19.200 --> 33:20.360
可以对它进行修改

33:20.360 --> 33:22.640
比方说下标唯一修改成什么了

33:22.640 --> 33:23.640
修改成100

33:23.760 --> 33:24.840
你可输出一看一下

33:24.840 --> 33:26.480
省这样的用法跟其他数组是一

33:26.480 --> 33:27.800
跟普通数组是一样的

33:27.800 --> 33:28.720
所以说这一块

33:29.360 --> 33:30.760
就这样就很简单了

33:32.200 --> 33:33.040
你看一下

33:33.040 --> 33:34.200
就改成100了

33:34.200 --> 33:36.400
并且我们要可以输出

33:36.400 --> 33:36.880
得了

33:36.880 --> 33:38.040
既然它可以复制

33:38.040 --> 33:38.920
肯定可以获取

33:38.920 --> 33:39.360
对吧

33:39.360 --> 33:39.960
AR1

33:39.960 --> 33:40.840
没问题的

33:41.600 --> 33:42.360
输出100

33:42.360 --> 33:44.080
还可以进行循环

33:44.080 --> 33:44.880
425

33:44.880 --> 33:46.160
循环

33:46.560 --> 33:47.360
输出

33:47.360 --> 33:48.640
这里有item

33:49.160 --> 33:50.360
这里有AR2

33:50.960 --> 33:51.280
好

33:51.280 --> 33:53.160
这里我们输出item

33:53.480 --> 33:54.120
你看

33:54.320 --> 33:55.640
这会把全部迭代出来

33:55.640 --> 33:56.440
循环出来

33:57.440 --> 33:59.000
这剩下的用法都一样

33:59.000 --> 34:01.280
只剩下一些点要注意

34:01.280 --> 34:02.480
有一些点要注意

34:02.480 --> 34:03.480
但是

34:05.160 --> 34:05.800
但是

34:06.400 --> 34:07.200
哪些点要注意呢

34:07.200 --> 34:07.800
第一个

34:08.440 --> 34:11.600
就是不能增加

34:12.200 --> 34:14.040
和删除数据

34:14.640 --> 34:16.120
不能增加和删除数据

34:16.120 --> 34:19.400
因为内型化数组的长度是固定的

34:19.560 --> 34:22.240
内型化数组的长度固定

34:22.280 --> 34:23.960
它占用的内存空间是固定的

34:26.120 --> 34:26.880
比方说

34:26.880 --> 34:28.680
你要往这里边加一项

34:28.680 --> 34:29.960
比方说我们这里有几项

34:29.960 --> 34:30.520
有四项

34:30.520 --> 34:30.880
对吧

34:30.880 --> 34:31.440
OK

34:31.440 --> 34:32.720
我给它下标为4

34:32.960 --> 34:34.360
下标本来是0到3的

34:34.360 --> 34:35.360
我给它下标为4

34:35.360 --> 34:36.680
付一个值1000

34:36.920 --> 34:38.240
我们来输出AR2

34:38.480 --> 34:39.200
你看一下

34:39.840 --> 34:40.560
有效果吗

34:40.560 --> 34:41.440
没有任何效果

34:41.440 --> 34:43.400
没有把1000个给它加进去

34:43.400 --> 34:43.960
对吧

34:44.760 --> 34:46.360
同样的它不能删除数据

34:47.240 --> 34:49.040
这里边能不能删除了AR2

34:49.040 --> 34:50.560
像输出里边有个splus

34:50.560 --> 34:51.280
这里边没有

34:51.280 --> 34:52.000
删不掉

34:52.000 --> 34:53.080
删不掉数据

34:53.440 --> 34:54.040
不要这意思吧

34:54.040 --> 34:55.800
有些人会说能不能这样子删

34:55.800 --> 34:56.800
AR2

34:56.800 --> 34:57.520
0

34:57.520 --> 34:58.480
能不能这样子删

34:58.480 --> 34:59.040
保存

34:59.040 --> 34:59.800
你看一下

34:59.800 --> 35:01.200
我们这里输出

35:01.200 --> 35:02.040
输出

35:02.040 --> 35:03.880
AR2

35:03.880 --> 35:04.680
保存

35:04.680 --> 35:05.160
你看

35:05.160 --> 35:05.960
能不能删掉

35:05.960 --> 35:06.640
删不掉

35:06.640 --> 35:07.000
对吧

35:07.000 --> 35:08.320
0还是在这

35:08.320 --> 35:09.000
对不对

35:09.000 --> 35:10.680
所以说它不能删除数据

35:10.680 --> 35:11.920
也不能增加数据

35:11.920 --> 35:12.800
是无效的

35:13.160 --> 35:13.920
无效

35:13.920 --> 35:15.600
这个代码也是无效的

35:16.120 --> 35:18.920
它这里边还要给你提供了一些方法

35:18.920 --> 35:20.760
就是另外一个我们要注意的

35:20.800 --> 35:25.480
就是一些返回数组的方法

35:26.120 --> 35:30.200
返回的数组是同类形化

35:30.800 --> 35:33.320
同类形化的新数据

35:33.320 --> 35:34.200
什么意思呢

35:34.200 --> 35:36.000
就是说比方说我们这里

35:36.800 --> 35:37.640
把这个注释掉

35:39.520 --> 35:41.600
这个数据里边不是有map方法

35:41.600 --> 35:41.920
对吧

35:41.920 --> 35:43.080
它这里边也有map

35:43.640 --> 35:44.200
map方法

35:44.200 --> 35:45.320
比方说我们把每个数字

35:46.400 --> 35:46.920
乘12

35:46.920 --> 35:48.040
我这里写小一点

35:48.040 --> 35:49.000
乘12

35:49.000 --> 35:49.680
item

35:49.680 --> 35:50.360
乘12

35:50.360 --> 35:51.840
这样子是不是得到一个新数据

35:52.560 --> 35:53.760
得到一个新数据

35:53.760 --> 35:55.000
那么这个新数据

35:55.000 --> 35:56.600
它也是类型化数据

35:56.600 --> 35:58.200
它并不是一个普通数据

35:58.200 --> 35:59.320
我们输出看一下

35:59.320 --> 36:01.840
这个新数据是不是还是int32而锐

36:02.840 --> 36:03.960
它不影响原数据

36:03.960 --> 36:04.920
它得到的一个新数据

36:04.920 --> 36:06.840
还是同样的类型化数据

36:07.360 --> 36:09.240
它自己用的是int32而锐

36:09.240 --> 36:11.400
返回的也是int32而锐

36:11.640 --> 36:12.400
没了意思吗

36:13.040 --> 36:15.000
不过大家注意算的时候

36:15.000 --> 36:16.280
不要溢出就行了

36:16.280 --> 36:16.800
不要溢出

36:16.800 --> 36:17.760
比方说我们这里

36:18.040 --> 36:20.280
我记得好像是int32的话

36:20.280 --> 36:21.480
32位

36:21.600 --> 36:22.640
我32位很大

36:23.160 --> 36:23.920
32位很大

36:23.920 --> 36:24.760
我们比较说用8

36:25.160 --> 36:25.920
8好算一点

36:26.640 --> 36:28.640
比方说我们这里用了125

36:28.920 --> 36:29.640
125

36:29.640 --> 36:30.600
那么这样子的话

36:30.600 --> 36:31.400
你得到的新数据

36:31.400 --> 36:32.520
第一项是不是出问题了

36:32.800 --> 36:33.640
你125乘1

36:33.640 --> 36:35.120
2是不是超出了这个范围了

36:35.760 --> 36:37.040
你看第一项是不是出问题了

36:37.760 --> 36:38.440
大家注意一下

36:39.440 --> 36:40.200
其他就没啥了

36:40.720 --> 36:41.520
就说我们这一刻

36:41.520 --> 36:42.880
介绍的类型化数据

36:43.040 --> 36:46.120
它其实最终的用法跟数据比较类似

36:46.240 --> 36:48.480
只不过它跟数据的最大差别在于

36:49.440 --> 36:50.400
它的长度固定

36:51.200 --> 36:52.760
占用的类传空间固定

36:53.360 --> 36:55.080
而且每一位占用的类传空间

36:55.520 --> 36:56.320
占多少位

36:56.320 --> 36:57.720
是可以确定的

36:58.160 --> 36:58.920
可以确定的

36:59.280 --> 37:02.160
并且我们可以根据实际的情况

37:02.160 --> 37:05.080
来选择合适的类型化数组

37:05.080 --> 37:06.920
来存储我们需要存储的数字

37:06.920 --> 37:09.080
这样子可以节约类传空间

37:10.280 --> 37:13.360
当然类型化数组还不仅仅是有这么一点功能

37:13.360 --> 37:14.520
它还有更多的功能

37:14.520 --> 37:17.160
那么更多的功能还需要我们学习一些新的知识

37:17.440 --> 37:18.960
不过我们这些课就到这里了

