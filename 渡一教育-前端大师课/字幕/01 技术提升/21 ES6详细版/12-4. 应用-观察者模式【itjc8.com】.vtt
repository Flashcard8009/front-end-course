WEBVTT

00:00.620 --> 00:04.320
好 接下来几节课呢 我给大家讲一讲这些代理呢

00:04.320 --> 00:06.120
它的一些有趣的应用

00:06.120 --> 00:11.020
首先呢 它的应用场景里面呢 可能最有用的应用的话

00:11.020 --> 00:12.620
就是一种观察者模式

00:12.620 --> 00:14.820
观察者模式是一种怎么样的模式呢

00:14.820 --> 00:20.620
就是有一个对象是观察者

00:20.620 --> 00:25.120
观察者 他用于 他用于干嘛呢

00:25.120 --> 00:28.220
用于观察另外一个对象的

00:28.420 --> 00:33.220
另外一个对象的属性值变化

00:33.220 --> 00:39.220
当属性值变化后 会收到一个通知

00:39.220 --> 00:42.220
会收到一个通知 可能会做一些事

00:42.220 --> 00:45.220
做一些事 这就是观察者模式

00:45.220 --> 00:49.220
怎么说呢 其实就是类似于代理

00:49.220 --> 00:51.220
这个东西把它变成观察者就完成了

00:51.220 --> 00:54.220
观察者 他观察啥 观察这个对象

00:54.220 --> 00:57.220
那么到手里打交道的话 就是跟观察者打交道

00:57.220 --> 00:58.220
就这么个意思

00:58.220 --> 01:00.220
其实这个东西呢 有很多的实现

01:00.220 --> 01:02.220
我提供给大家一种实现方式

01:02.220 --> 01:04.220
首先呢 我给大家提供的一种实现方式呢

01:04.220 --> 01:07.220
是没有学习代理之前 就是没有代理之前

01:07.220 --> 01:10.220
我们可以利用Object Define Property

01:10.220 --> 01:13.220
它里面不是可以定义那个Gate和Set吗

01:13.220 --> 01:15.220
对吧 来实现这么一种模式

01:15.220 --> 01:18.220
举个例子 比方说Test1

01:18.220 --> 01:22.220
Test1里面呢 我们这里有一个DIV

01:22.220 --> 01:26.220
给它取个容器嘛 扛天了

01:26.220 --> 01:31.220
这个DIV里面呢 要渲染用户的姓名和年龄

01:31.220 --> 01:33.220
我们之前是不是回顾的时候写过的

01:33.220 --> 01:36.220
我们换一种写法 这是写法上我们换一种

01:36.220 --> 01:39.220
现在呢 我们定义这么一个函数

01:39.220 --> 01:42.220
叫做Observer

01:42.220 --> 01:44.220
我给它写个简单的一种模式

01:44.220 --> 01:49.220
表示什么意思 表示

01:49.220 --> 01:53.220
表示什么意思 创建一个观察者

01:53.220 --> 01:56.220
创建一个观察者 那么它返回的就是什么呢

01:56.220 --> 01:59.220
返回的就是一个观察者

01:59.220 --> 02:02.220
或者就是大小写吧

02:02.220 --> 02:04.220
不然的话 感觉像构造函数一样

02:04.220 --> 02:06.220
一调用这个函数呢 它就会得到一个观察者

02:06.220 --> 02:08.220
那么就相当于是代理

02:08.220 --> 02:10.220
那么这里返回什么 这里给我传什么呢

02:10.220 --> 02:12.220
传的是目标对象

02:12.220 --> 02:15.220
我会观察目标对象里面的属性变化

02:15.220 --> 02:18.220
然后呢 把这些属性的渲染

02:18.220 --> 02:20.220
通过P元数 比方说通过P元数渲染到这

02:20.220 --> 02:22.220
比方说目标对象里面有两个属性

02:22.220 --> 02:24.220
A和B 对吧

02:24.220 --> 02:26.220
那么我们这里就显示

02:26.220 --> 02:29.220
SpanA 然后呢

02:29.220 --> 02:31.220
A等于1 这样的显示

02:31.220 --> 02:34.220
P元数SpanB 然后呢

02:34.220 --> 02:37.220
Span2 比方说就这样子

02:37.220 --> 02:40.220
好 那么这样子我们怎么写呢

02:40.220 --> 02:42.220
怎么写呢 我要返回一个观察者

02:42.220 --> 02:44.220
是不是我要得到一个新的对象

02:44.220 --> 02:47.220
就是OB 一个新的对象

02:47.220 --> 02:49.220
那么我要往对象里面加属性

02:49.220 --> 02:51.220
它的属性要跟它一样

02:51.220 --> 02:52.220
它里面有哪些属性

02:52.220 --> 02:53.220
我这里面就有哪些属性

02:53.220 --> 02:55.220
那么怎么来加这个属性呢

02:55.220 --> 02:56.220
我们可以用这种方式

02:56.220 --> 02:58.220
我们可以得到talkit对象里面的

02:58.220 --> 03:01.220
所有的属性名

03:01.220 --> 03:04.220
可以通过objects keys 对吧

03:04.220 --> 03:06.220
是不是可以到所有的属性名

03:06.220 --> 03:08.220
Props

03:08.220 --> 03:09.220
拿到这些属性名过后

03:09.220 --> 03:10.220
是不是可以循环

03:10.220 --> 03:12.220
循环这些属性名

03:12.220 --> 03:14.220
Prop

03:14.220 --> 03:16.220
talkitProps

03:16.220 --> 03:17.220
是不是可以循环这些属性名

03:17.220 --> 03:19.220
好 每一次循环

03:19.220 --> 03:21.220
这个属性是不是把它加到这里面

03:21.220 --> 03:23.220
对吧 加到这里面

03:23.220 --> 03:24.220
那么怎么做呢

03:24.220 --> 03:27.220
我们当然最简单的就是这样子加

03:27.220 --> 03:30.220
这样子加 等于talkitProps

03:30.220 --> 03:32.220
但是这样子用一做的话

03:32.220 --> 03:34.220
就不能实现观察者的效果了

03:34.220 --> 03:36.220
我们希望得到一个什么样的效果呢

03:36.220 --> 03:37.220
我们希望的是

03:37.220 --> 03:38.220
我以后给它复制

03:38.220 --> 03:40.220
给某一个属性复制的时候

03:40.220 --> 03:41.220
我能收到通知

03:41.220 --> 03:43.220
那么以这样子写的过后

03:43.220 --> 03:44.220
我们到时候怎么用

03:44.220 --> 03:46.220
比方说我们得到一个OB界

03:46.220 --> 03:48.220
通过Observer

03:48.220 --> 03:49.220
把它传一个对象进去

03:49.220 --> 03:51.220
A等于1 B等于2

03:51.220 --> 03:52.220
B等于2

03:52.220 --> 03:53.220
那么到时候

03:53.220 --> 03:55.220
OB界里面是不是也有个A

03:55.220 --> 03:57.220
是不是OB界里面也有个B

03:57.220 --> 03:58.220
对不对

03:58.220 --> 04:00.220
对吧 是不是也有个A有一个B

04:00.220 --> 04:02.220
但是我给OB界里面的A和B复制

04:02.220 --> 04:03.220
这里能收到通知吗

04:03.220 --> 04:04.220
这个对象

04:04.220 --> 04:05.220
因为我得到A和B

04:05.220 --> 04:06.220
就是这个对象里面的A和B

04:06.220 --> 04:08.220
这个对象是不知道外面给它复制的

04:08.220 --> 04:10.220
所以说我们这里还不能这样做

04:10.220 --> 04:11.220
怎么做呢

04:11.220 --> 04:13.220
我们这里要用这种方式

04:13.220 --> 04:14.220
以前的那种方式

04:14.220 --> 04:16.220
object define property

04:16.220 --> 04:17.220
定义一个属性

04:17.220 --> 04:18.220
对象是OB

04:18.220 --> 04:20.220
属性名是prob

04:20.220 --> 04:21.220
描述符

04:21.220 --> 04:22.220
描述符是啥呢

04:22.220 --> 04:25.220
描述符有一个get

04:25.220 --> 04:27.220
当我们获取这个属性的时候

04:27.220 --> 04:28.220
我返回的是什么呢

04:28.220 --> 04:30.220
返回的是target prop

04:30.220 --> 04:33.220
当我们设置这个属性的时候

04:33.220 --> 04:35.220
当我们设置这个属性的时候

04:35.220 --> 04:37.220
我们肯定是要把属性的值

04:37.220 --> 04:39.220
放到target里面

04:39.220 --> 04:41.220
但是这样的一来的话

04:41.220 --> 04:43.220
我们是不是就有一种机制了

04:43.220 --> 04:44.220
我们可以

04:44.220 --> 04:46.220
我们知道什么时候你给我复了值

04:46.220 --> 04:48.220
什么时候你在读取我的值

04:48.220 --> 04:50.220
当你在给我复制的时候我干嘛呢

04:50.220 --> 04:52.220
我除了要把这个值放进去之外

04:52.220 --> 04:54.220
我是不是还要给div重新渲染

04:54.220 --> 04:55.220
对吧

04:55.220 --> 04:57.220
这里面我们写个rander函数

04:57.220 --> 04:59.220
写个rander函数来重新渲染

04:59.220 --> 05:01.220
rander

05:01.220 --> 05:03.220
这个rander函数

05:03.220 --> 05:04.220
我们这里调用一次

05:04.220 --> 05:05.220
重新渲染

05:05.220 --> 05:06.220
rander函数做什么呢

05:06.220 --> 05:07.220
rander函数做的事情很简单

05:07.220 --> 05:09.220
就得到这个div

05:09.220 --> 05:11.220
比如说我们得到一个div

05:11.220 --> 05:13.220
div等于

05:14.220 --> 05:15.220
documents

05:15.220 --> 05:16.220
get elements 把id

05:16.220 --> 05:18.220
container

05:18.220 --> 05:20.220
这个容器得到这个div

05:20.220 --> 05:21.220
渲染的时候我们干嘛呢

05:21.220 --> 05:23.220
给div的initm复制

05:23.220 --> 05:25.220
比方说我们怎么复制呢

05:25.220 --> 05:26.220
就这样子去吧

05:26.220 --> 05:28.220
一个p元数

05:28.220 --> 05:29.220
一个p元数

05:29.220 --> 05:31.220
p元数里边

05:31.220 --> 05:32.220
是不是有一些属性

05:32.220 --> 05:33.220
对吧

05:33.220 --> 05:34.220
有一些属性

05:34.220 --> 05:36.220
属性的话

05:36.220 --> 05:37.220
我这里关键是不知道

05:37.220 --> 05:38.220
它有哪些属性

05:38.220 --> 05:39.220
那我这样吧

05:39.220 --> 05:41.220
我这里循环它的所有属性

05:41.220 --> 05:42.220
循环它的所有属性

05:42.220 --> 05:44.220
我们这里写这么一个字幕串

05:45.220 --> 05:46.220
写这么一个字幕串

05:46.220 --> 05:47.220
一天没有

05:47.220 --> 05:49.220
然后来循环

05:49.220 --> 05:50.220
for all

05:50.220 --> 05:51.220
循环什么

05:51.220 --> 05:52.220
ob

05:52.220 --> 05:53.220
就是ob的

05:53.220 --> 05:55.220
或者是talkit都行

05:55.220 --> 05:56.220
都行

05:56.220 --> 05:58.220
我们循环ob的

05:58.220 --> 06:00.220
所有的属性

06:00.220 --> 06:02.220
object

06:02.220 --> 06:04.220
所有的属性

06:04.220 --> 06:05.220
然后kiss

06:05.220 --> 06:07.220
拿到它的所有的属性

06:07.220 --> 06:08.220
ob

06:08.220 --> 06:10.220
然后观察到的所有属性

06:10.220 --> 06:11.220
然后呢

06:11.220 --> 06:13.220
是不是每次拿到一个属性名

06:13.220 --> 06:15.220
接下来我们在atm里面拼接一段

06:15.220 --> 06:16.220
拼接一段

06:16.220 --> 06:17.220
拼接一段啥呢

06:17.220 --> 06:19.220
拼接一段就是p元数

06:19.220 --> 06:21.220
就是拼接到那一段p元数

06:21.220 --> 06:24.220
这个p元数里边有两个十变元数

06:24.220 --> 06:25.220
两个十变元数

06:25.220 --> 06:27.220
一个十变元数里边的显示属性名

06:27.220 --> 06:30.220
一个十变元数的显示属性值

06:30.220 --> 06:31.220
属性名呢

06:32.220 --> 06:34.220
拼接属性名是不是prob

06:34.220 --> 06:35.220
属性值呢

06:36.220 --> 06:37.220
ob

06:37.220 --> 06:38.220
ob

06:38.220 --> 06:39.220
对吧

06:39.220 --> 06:40.220
然后拼接好了过后

06:40.220 --> 06:41.220
我们把这个atm

06:41.220 --> 06:44.220
复制给div

06:44.220 --> 06:46.220
div的inner atm

06:46.220 --> 06:47.220
复制

06:47.220 --> 06:48.220
对吧

06:48.220 --> 06:51.220
那么这里最开始也可以渲染一次

06:51.220 --> 06:53.220
就做出来一个观察者模式的

06:53.220 --> 06:55.220
你看咱们再来理一下

06:55.220 --> 06:58.220
我们通过调用这个函数得到一个新的对象

06:58.220 --> 06:59.220
这个新的对象里面的属性

06:59.220 --> 07:00.220
跟原来对象一模一样

07:00.220 --> 07:01.220
但是不同的是

07:01.220 --> 07:03.220
新的对象是一个观察者

07:03.220 --> 07:05.220
当你给新的对象复制的时候

07:05.220 --> 07:06.220
你看我这里

07:06.220 --> 07:08.220
我这里还没返回

07:08.220 --> 07:09.220
要返回这个ob

07:10.220 --> 07:11.220
那么返回的ob

07:11.220 --> 07:12.220
是不是得到了个新的对象

07:12.220 --> 07:13.220
这个新的对象里面

07:13.220 --> 07:14.220
每一个属性

07:14.220 --> 07:16.220
它都定义了get和set

07:16.220 --> 07:18.220
当你在读它的属性值的时候

07:18.220 --> 07:20.220
当你在读它的属性值的时候

07:20.220 --> 07:23.220
我就把目标对象的属性值给递

07:23.220 --> 07:25.220
当你在复制的时候

07:25.220 --> 07:27.220
我除了要给目标对象复制之外

07:27.220 --> 07:28.220
我还要渲染一次

07:28.220 --> 07:30.220
也可以先复制再渲染都行

07:30.220 --> 07:31.220
这无所谓

07:31.220 --> 07:32.220
先复制再渲染

07:32.220 --> 07:33.220
因为你属性值变了

07:33.220 --> 07:34.220
我页面上要跟着变

07:34.220 --> 07:35.220
对吧

07:35.220 --> 07:36.220
也就是我通过这个例子

07:36.220 --> 07:37.220
来告诉大家

07:37.220 --> 07:38.220
我的观察者

07:38.220 --> 07:39.220
就得到这个新的对象

07:39.220 --> 07:40.220
你给它属性复制的时候

07:40.220 --> 07:41.220
没有那么简单

07:41.220 --> 07:43.220
它是会受到通知的

07:43.220 --> 07:45.220
因为它在观察这个属性

07:45.220 --> 07:46.220
变化

07:46.220 --> 07:47.220
它会受到通知

07:47.220 --> 07:48.220
就这么个意思

07:48.220 --> 07:49.220
好 咱们来看一下吧

07:51.220 --> 07:52.220
这里爆错了

07:52.220 --> 07:54.220
probs is not a terrible

07:55.220 --> 07:56.220
我看一下

07:57.220 --> 07:59.220
我们这里循环prob

07:59.220 --> 08:00.220
这是个方法

08:00.220 --> 08:01.220
方法

08:01.220 --> 08:03.220
得到talkies对象的所有属性名

08:07.220 --> 08:09.220
我没有那个

08:09.220 --> 08:10.220
没有渲染的

08:10.220 --> 08:11.220
一开始没有渲染的

08:11.220 --> 08:12.220
我看一下吧

08:12.220 --> 08:13.220
输出atm

08:15.220 --> 08:16.220
空的

08:16.220 --> 08:17.220
它是空的

08:17.220 --> 08:18.220
我看一下

08:19.220 --> 08:21.220
它说这里为什么是空的呢

08:23.220 --> 08:26.220
ob界定义一个probs

08:26.220 --> 08:29.220
好 我们在这里输出一下ob界

08:29.220 --> 08:30.220
ob

08:30.220 --> 08:31.220
看一下哪里

08:31.220 --> 08:32.220
哪里我写错了

08:32.220 --> 08:34.220
有这两个属性了

08:34.220 --> 08:35.220
明白了

08:35.220 --> 08:36.220
这两个属性呢

08:36.220 --> 08:38.220
默认了它是不能被便利的

08:38.220 --> 08:39.220
不能没一句的

08:39.220 --> 08:40.220
所以说你要配置一下enumber robot

08:40.220 --> 08:42.220
把它配置为q

08:42.220 --> 08:43.220
可以没一句

08:44.220 --> 08:45.220
我们之前讲过了 对吧

08:45.220 --> 08:46.220
你看一下

08:46.220 --> 08:48.220
一开始是不是输出了a1 b2

08:48.220 --> 08:49.220
我们这里加个帽号

08:49.220 --> 08:50.220
加个帽号

08:51.220 --> 08:52.220
a1 b2

08:52.220 --> 08:54.220
现在我们看一下我们的

08:54.220 --> 08:55.220
这个对象

08:55.220 --> 08:56.220
我们这个对象

08:56.220 --> 08:58.220
我们这个对象用一个

08:58.220 --> 08:59.220
用一个就是

09:00.220 --> 09:01.220
talkies来表示吧

09:01.220 --> 09:03.220
把这个对象放到talkies里面

09:04.220 --> 09:05.220
talkies

09:05.220 --> 09:06.220
把talkies放进来

09:07.220 --> 09:08.220
好 看一下

09:08.220 --> 09:09.220
我们的talkies

09:09.220 --> 09:10.220
你看 是不是这样子

09:10.220 --> 09:12.220
但是我们以后的修改对象

09:12.220 --> 09:13.220
不要直接使用talkies

09:13.220 --> 09:14.220
而使用我们的观察者

09:14.220 --> 09:16.220
观察者是在ob界里面

09:16.220 --> 09:17.220
保存在这儿的

09:17.220 --> 09:19.220
好 我们修改ob界的a属性

09:19.220 --> 09:20.220
把它变成10

09:20.220 --> 09:21.220
你看 这样也修改

09:21.220 --> 09:22.220
不仅页面上变了

09:22.220 --> 09:23.220
我们的目标对象

09:23.220 --> 09:24.220
talkies是不是也跟着变了

09:24.220 --> 09:25.220
对吧 也跟着变了

09:25.220 --> 09:27.220
那么这样子的保证目标对象

09:27.220 --> 09:29.220
跟我们的页面上保持一致的

09:29.220 --> 09:31.220
这是以前的实现方式

09:31.220 --> 09:32.220
以前我们使用obj

09:32.220 --> 09:34.220
define property来实现

09:35.220 --> 09:36.220
那么这种实现方式

09:36.220 --> 09:37.220
有没有什么缺陷呢

09:37.220 --> 09:39.220
当然有一个很大的缺陷

09:39.220 --> 09:41.220
它搞出来了两个对象

09:41.220 --> 09:43.220
我们的观察者是不是一个对象

09:43.220 --> 09:45.220
对吧 观察者本身是一个对象

09:45.220 --> 09:46.220
你看ob界

09:46.220 --> 09:48.220
观察者本身是一个对象

09:48.220 --> 09:50.220
它里面有a属性和b属性

09:50.220 --> 09:51.220
那我们的talkies

09:51.220 --> 09:53.220
是不是也是一个对象

09:53.220 --> 09:54.220
搞出了两个对象

09:54.220 --> 09:55.220
虽然说我们在这里

09:55.220 --> 09:57.220
严格控制两个对象的属性

09:57.220 --> 09:58.220
是一样的

09:58.220 --> 09:59.220
但是保不起有一天

09:59.220 --> 10:01.220
你往talkies里面加一个属性

10:02.220 --> 10:04.220
一往talkies里面加一个属性

10:04.220 --> 10:05.220
它还能收到消息吗

10:05.220 --> 10:07.220
它以后对这个新增的属性

10:07.220 --> 10:08.220
来进行操作还能收到消息吗

10:08.220 --> 10:10.220
不要加一个属性C等于1

10:10.220 --> 10:12.220
那么现在呢

10:12.220 --> 10:14.220
我们如果说对这个

10:14.220 --> 10:16.220
对这个ob界的C

10:16.220 --> 10:17.220
复制为10

10:17.220 --> 10:19.220
有消息吗 是没有消息

10:19.220 --> 10:20.220
因为

10:20.220 --> 10:21.220
这个观察者

10:21.220 --> 10:22.220
他只观察了一开始

10:22.220 --> 10:23.220
这个对象的情况

10:23.220 --> 10:25.220
没有观察后面的情况

10:25.220 --> 10:26.220
再说了

10:26.220 --> 10:27.220
你搞出两个对象

10:27.220 --> 10:28.220
是不是造成内存空间的浪费

10:28.220 --> 10:30.220
对吧 因为我只需要一个的

10:30.220 --> 10:31.220
为了实现这种效果

10:31.220 --> 10:32.220
你搞出另外一个对象

10:32.220 --> 10:34.220
造成内存空间的浪费

10:34.220 --> 10:35.220
为什么以前没办法

10:35.220 --> 10:36.220
以前呢

10:36.220 --> 10:37.220
就是因为我们没法参与

10:37.220 --> 10:38.220
它底层的实现

10:38.220 --> 10:40.220
当真正给底层的东西复制的时候

10:40.220 --> 10:42.220
我们是收不到通知的

10:42.220 --> 10:44.220
我们只能用这种模式

10:44.220 --> 10:46.220
但是那代理出来过后就不一样了

10:46.220 --> 10:47.220
代理出来过后

10:47.220 --> 10:48.220
我们可以非常轻松的

10:48.220 --> 10:49.220
创建一个代理

10:49.220 --> 10:50.220
因为代理的

10:50.220 --> 10:51.220
它并不占用那个

10:51.220 --> 10:52.220
额外的内存空间

10:52.220 --> 10:54.220
这就是以前对象的代理

10:54.220 --> 10:56.220
一个代理复制

10:56.220 --> 10:57.220
就是给以前对象的复制

10:57.220 --> 10:59.220
它就不像我们刚才的样子

10:59.220 --> 11:00.220
给这个观察者复制

11:00.220 --> 11:02.220
就真的是给观察者复制

11:02.220 --> 11:04.220
对吧 是这么个意思

11:04.220 --> 11:05.220
那么现在呢

11:05.220 --> 11:06.220
我们用代理来实现一遍

11:06.220 --> 11:07.220
同样的道理

11:07.220 --> 11:08.220
得到DIV

11:08.220 --> 11:10.220
Render的这些东西都没有变化

11:10.220 --> 11:11.220
都没有变化

11:11.220 --> 11:13.220
Render的都没有变化

11:13.220 --> 11:14.220
那么这里呢

11:14.220 --> 11:15.220
我们就

11:15.220 --> 11:16.220
Render无非就是循环的时候

11:16.220 --> 11:18.220
循环talking什么

11:18.220 --> 11:19.220
对吧 这些都没有变化

11:19.220 --> 11:20.220
那么只是在这

11:20.220 --> 11:22.220
只是在这一块

11:22.220 --> 11:24.220
这一块我们使用代理

11:24.220 --> 11:25.220
那么我们这里怎么做

11:25.220 --> 11:27.220
怎么写呢 看着

11:27.220 --> 11:28.220
我们这里直接创建一个代理

11:28.220 --> 11:29.220
proxy

11:29.220 --> 11:31.220
反而回到就是这个代理

11:31.220 --> 11:33.220
proxy怎么来的

11:33.220 --> 11:34.220
六一个proxy

11:34.220 --> 11:36.220
目标对象talking

11:36.220 --> 11:37.220
里边配置

11:37.220 --> 11:39.220
重写它的底层实现

11:39.220 --> 11:41.220
当我们set的时候

11:41.220 --> 11:44.220
prob value

11:44.220 --> 11:45.220
你给我的是什么

11:45.220 --> 11:46.220
给我的是目标对象

11:46.220 --> 11:48.220
目标的属性 目标的值

11:48.220 --> 11:49.220
我干嘛呢

11:49.220 --> 11:50.220
我干嘛呢

11:50.220 --> 11:51.220
当你复制的时候

11:51.220 --> 11:52.220
复制的时候

11:52.220 --> 11:53.220
我先对它真正的复制

11:53.220 --> 11:54.220
reflect

11:54.220 --> 11:55.220
set

11:55.220 --> 11:56.220
talking 你看一样的

11:56.220 --> 11:57.220
prob

11:57.220 --> 11:58.220
prob

11:58.220 --> 11:59.220
就是我当我写这个代码的时候

11:59.220 --> 12:00.220
产生完全一样

12:00.220 --> 12:01.220
对吧

12:01.220 --> 12:02.220
就说明我真的要用它底层的功能

12:02.220 --> 12:03.220
用完了之后

12:03.220 --> 12:05.220
我还有件额外的事情要做

12:05.220 --> 12:06.220
Render

12:06.220 --> 12:08.220
set get的时候

12:08.220 --> 12:09.220
当我们get的时候

12:09.220 --> 12:10.220
那么这里呢

12:10.220 --> 12:11.220
talking

12:11.220 --> 12:13.220
prob

12:13.220 --> 12:14.220
这里的反回是什么

12:14.220 --> 12:17.220
反回的就是reflect

12:17.220 --> 12:18.220
get

12:18.220 --> 12:19.220
写起来既简单

12:19.220 --> 12:20.220
而且又好理解

12:20.220 --> 12:21.220
功能又强大

12:21.220 --> 12:23.220
又不浪费内存空间

12:23.220 --> 12:24.220
因为代理它本身

12:24.220 --> 12:25.220
不占用内存空间

12:25.220 --> 12:27.220
它就是来做一些事的

12:27.220 --> 12:28.220
来帮你做一些事的

12:28.220 --> 12:29.220
它比本身

12:29.220 --> 12:30.220
它比里面不存出

12:30.220 --> 12:31.220
什么A和B的属性

12:31.220 --> 12:32.220
不存出的

12:32.220 --> 12:33.220
明白的意思吗

12:33.220 --> 12:34.220
本身它要说

12:34.220 --> 12:36.220
它这个对象都很牵强

12:36.220 --> 12:37.220
因为它就是在

12:37.220 --> 12:38.220
原来的目标对象外面

12:38.220 --> 12:39.220
掏了一层

12:39.220 --> 12:41.220
就是掏了一层就是

12:41.220 --> 12:42.220
那个叫啥

12:42.220 --> 12:43.220
应该叫啥呢

12:43.220 --> 12:44.220
它啥都不是

12:44.220 --> 12:46.220
它就是来控制一些东西的

12:46.220 --> 12:48.220
那么创建一个代理

12:48.220 --> 12:49.220
好 那么就完了

12:49.220 --> 12:50.220
一个随便给我什么属性复制

12:50.220 --> 12:52.220
我一定会经过这个设程函数

12:52.220 --> 12:53.220
那么我就完成复制

12:53.220 --> 12:54.220
完成复制

12:54.220 --> 12:55.220
然后我再重新骗了

12:55.220 --> 12:56.220
你给我复制

12:56.220 --> 12:57.220
读取我的属性职务

12:57.220 --> 12:58.220
一定会经过这个函数

12:58.220 --> 12:59.220
最后我们反

12:59.220 --> 13:00.220
然后代理就完了

13:00.220 --> 13:02.220
好 接下来我们再来看

13:02.220 --> 13:03.220
TES-2里边的

13:03.220 --> 13:05.220
一是代码变简单了

13:05.220 --> 13:07.220
二是它功能变强大了

13:08.220 --> 13:09.220
OB

13:11.220 --> 13:12.220
这里是

13:12.220 --> 13:13.220
用那个吧

13:13.220 --> 13:14.220
用Target

13:16.220 --> 13:17.220
好 来吧

13:17.220 --> 13:19.220
你看A和B等于1和2

13:19.220 --> 13:21.220
那么现在我们通过代理

13:21.220 --> 13:22.220
OB界

13:23.220 --> 13:25.220
那么里边加一个属性

13:25.220 --> 13:26.220
加一个属性

13:26.220 --> 13:27.220
比方10

13:27.220 --> 13:28.220
你看 是不是抽到通知了

13:28.220 --> 13:29.220
为什么

13:29.220 --> 13:30.220
因为我不像以前那样子

13:30.220 --> 13:31.220
是针

13:31.220 --> 13:33.220
针对每一个属性去定义

13:33.220 --> 13:34.220
对吧

13:34.220 --> 13:35.220
我这里一加

13:35.220 --> 13:36.220
我哪怕用普通的方式来加属性

13:36.220 --> 13:37.220
因为这是底层实现

13:37.220 --> 13:38.220
你看

13:38.220 --> 13:40.220
这个复制语句以前能干涉吗

13:40.220 --> 13:42.220
是不是干涉不了这种复制语句

13:42.220 --> 13:43.220
一个新增属性

13:43.220 --> 13:44.220
这不是

13:44.220 --> 13:45.220
通过这种复制语句

13:45.220 --> 13:46.220
一个新增属性里能干涉吗

13:46.220 --> 13:47.220
就是干涉不了

13:47.220 --> 13:48.220
这是底层实现

13:48.220 --> 13:50.220
但是它通过反射

13:50.220 --> 13:51.220
代理是不是可以

13:51.220 --> 13:53.220
可以补货到底层实现

13:53.220 --> 13:54.220
对吧

13:54.220 --> 13:55.220
可以补货到底层实现

13:55.220 --> 13:56.220
你甭管你底层实现是啥

13:56.220 --> 13:58.220
你只要给我复制了

13:58.220 --> 13:59.220
我管你是什么情况

13:59.220 --> 14:01.220
我就一定会监测到这个底层实现

14:01.220 --> 14:03.220
那么底层实现里面

14:03.220 --> 14:04.220
我先去做这件事情

14:04.220 --> 14:05.220
然后重新宣传

14:05.220 --> 14:07.220
代理它强大的地方

14:08.220 --> 14:10.220
实际上我给大家举这个例子

14:10.220 --> 14:11.220
是有对应的

14:11.220 --> 14:12.220
你们今后

14:12.220 --> 14:14.220
我不知道你们现在有没有学习过

14:14.220 --> 14:15.220
无忧

14:15.220 --> 14:16.220
因为我录一个课程

14:16.220 --> 14:17.220
我给大家说一下

14:17.220 --> 14:18.220
我一定是要保证

14:18.220 --> 14:20.220
我一定是假设这个课程

14:20.220 --> 14:23.220
你们了解的是这个最低的知识

14:23.220 --> 14:24.220
就是什么意思呢

14:24.220 --> 14:26.220
就是这个课程

14:26.220 --> 14:28.220
是最少最少需要什么知识

14:28.220 --> 14:30.220
我就假设你们指挥这些知识

14:30.220 --> 14:32.220
我不知道你们有没有学过无忧

14:32.220 --> 14:34.220
其实无忧里面它的原理

14:34.220 --> 14:36.220
它就是按照这样的方式来做的

14:36.220 --> 14:39.220
以前没有这个proxy

14:39.220 --> 14:40.220
所以它以前没办法

14:40.220 --> 14:42.220
以前要使用这种方式

14:42.220 --> 14:44.220
就是那个define property的方式

14:44.220 --> 14:46.220
但是在新版本里面

14:46.220 --> 14:47.220
193.0之后

14:47.220 --> 14:49.220
它会把它换成proxy的方式

14:49.220 --> 14:50.220
这种方式太优秀了

14:50.220 --> 14:52.220
比它的东西优秀太多了

14:52.220 --> 14:53.220
而且下节课

14:53.220 --> 14:54.220
你还会看到

14:54.220 --> 14:55.220
它还有一些别的

14:55.220 --> 14:56.220
更加好玩的东西

14:56.220 --> 14:57.220
这是观察者模式

