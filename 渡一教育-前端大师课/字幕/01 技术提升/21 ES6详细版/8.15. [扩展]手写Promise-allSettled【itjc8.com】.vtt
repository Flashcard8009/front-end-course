WEBVTT

00:00.180 --> 00:04.780
这些可能我们来实现另外一个Promise的静态方法叫做All Settled

00:05.560 --> 00:07.600
这个方法跟All的区别在哪呢

00:07.860 --> 00:11.440
就这个方法它返回的Promise一定成功

00:11.700 --> 00:12.720
它不可能失败的

00:13.480 --> 00:15.280
比方说我们现在有个Promise1

00:15.540 --> 00:17.340
它10毫秒之后它失败

00:17.840 --> 00:20.660
然后还有个234和5都是成功的

00:20.920 --> 00:23.980
那么我这个Promise如果说是All的话

00:24.240 --> 00:25.780
它一定失败了 因为它失败了

00:26.040 --> 00:27.320
任何一个失败它都会失败

00:27.820 --> 00:29.620
但是PromiseAll Settled的什么意思呢

00:30.020 --> 00:31.920
表示只要所有的

00:32.680 --> 00:33.460
已决

00:33.720 --> 00:35.500
Settled的就是已决的意思

00:35.760 --> 00:36.280
只要你

00:36.780 --> 00:38.580
OK了就行 有结果就行

00:39.340 --> 00:40.380
Settled就是

00:40.640 --> 00:44.460
反正一切承安落定了 对吧 成功也可以失败也可以

00:44.720 --> 00:46.520
只要你有结果就行

00:47.020 --> 00:49.320
那么它会把所有的结果来进行汇总

00:49.840 --> 00:50.860
我们来运行看一下

00:52.140 --> 00:52.660
一会发现

00:52.920 --> 00:55.480
你看每一个得到结果是一个对象

00:55.980 --> 00:57.780
失败的时候 它的状态是一个阶梯的

00:58.500 --> 00:59.780
然后它的原因

01:00.040 --> 01:00.800
对吧 然后

01:01.060 --> 01:02.860
成功的时候 状态是否废了的

01:03.360 --> 01:04.140
它的数据

01:04.640 --> 01:05.660
它一定会总起来

01:05.920 --> 01:08.740
因为这个Promise是永远不可能失败的 它可能挂起

01:09.000 --> 01:11.560
对吧 只要有一个Promise没有已决

01:11.820 --> 01:13.340
这里一秒钟

01:13.600 --> 01:15.640
这四个是不是很快就结束了

01:15.900 --> 01:17.440
它没有结束 那么它就是挂起

01:17.700 --> 01:19.740
那等到一秒钟之后那么成功

01:20.520 --> 01:21.280
看一下

01:22.060 --> 01:23.840
一秒钟之后你看才会成功

01:24.360 --> 01:25.120
就这么一个逻辑

01:25.380 --> 01:26.920
好 我们来实现这个进展方法

01:28.080 --> 01:29.060
这个进展方法

01:29.580 --> 01:30.600
很好实现

01:31.120 --> 01:32.400
需要一点想象力

01:32.900 --> 01:33.920
它代码并不复杂

01:35.200 --> 01:38.020
我这里写出是 你们想象一下

01:38.280 --> 01:39.300
该怎么去实现

01:41.620 --> 01:42.900
这是个自信器

01:43.160 --> 01:43.940
这个迭代器

01:44.440 --> 01:45.460
好 这是

01:46.240 --> 01:47.780
所有等待

01:48.280 --> 01:49.060
所有的

01:50.840 --> 01:51.620
Promise

01:52.380 --> 01:54.180
有结果之后

01:55.700 --> 01:57.240
该方法

01:57.760 --> 01:58.780
返回的

01:59.000 --> 01:59.760
Promise

02:01.040 --> 02:01.540
完成

02:02.560 --> 02:03.080
并且

02:03.340 --> 02:05.900
按照顺序 还是一样 按照顺序

02:06.420 --> 02:06.920
将

02:07.180 --> 02:08.200
所有结果

02:08.460 --> 02:08.960
贵重

02:09.740 --> 02:10.760
贵重出来就是这么一个玩意

02:12.040 --> 02:13.320
这个函数怎么实现呢

02:13.580 --> 02:15.380
其他的代码跟O是不是差不多

02:15.640 --> 02:18.440
如果发现你跟O差不多的话你可以想一想

02:18.700 --> 02:20.240
能不能就利用这个O

02:20.500 --> 02:21.260
来去完成

02:22.540 --> 02:23.560
实际上是可以的

02:23.820 --> 02:27.400
我给大家写一遍 写了过后呢 你们好多人应该恍然大悟了

02:28.120 --> 02:29.920
我这边呢 去准备好一个数组

02:30.420 --> 02:32.220
就是PS

02:32.480 --> 02:34.020
这个数组里边装什么呢

02:34.780 --> 02:37.280
我把这里边的Promise给它改一下

02:37.540 --> 02:38.360
稍微改一下

02:38.620 --> 02:39.900
然后装到这个数组里边去

02:41.720 --> 02:42.500
Promise

02:43.020 --> 02:45.060
怎么改呢 你看 我就这样改

02:47.100 --> 02:49.140
添加一个Promise 往里边装一个Promise

02:49.400 --> 02:50.940
但是装的不是直接装那个P

02:51.460 --> 02:53.240
而是通过P的另一方法

02:56.410 --> 02:58.970
然后这是成功的数据

02:59.730 --> 03:01.270
这是失败的原因

03:01.570 --> 03:05.650
一想一想

03:06.150 --> 03:07.690
我这个Promise调用Z

03:08.210 --> 03:10.770
是不是不管它是成功还是失败

03:11.270 --> 03:13.850
都会运 要么运行这个函数 要么运行这个函数

03:14.110 --> 03:16.650
我只要保证这两个函数不要爆错

03:17.170 --> 03:18.950
是不是只要保证这两个函数不要爆错

03:19.210 --> 03:20.750
那么这个Promise返回了

03:21.010 --> 03:22.290
它一定是成功的

03:22.550 --> 03:23.310
是不是这个逻辑

03:26.510 --> 03:27.950
这个Promise是不是一定成功的

03:28.590 --> 03:31.530
所以说呢 我这里往这个数组里边加的所有的Promise

03:31.790 --> 03:33.590
按照这种逻辑的话 它一定成功的

03:34.590 --> 03:37.750
那么成功之后就是无非就是成功之后的数据是什么

03:38.390 --> 03:39.430
数据是咋呢

03:40.190 --> 03:42.470
我这里直接我都拦了写return语去吧

03:42.630 --> 03:43.630
返回了就是一个对象

03:44.030 --> 03:45.430
用小货号扩一下

03:45.710 --> 03:47.230
扩一下的好处

03:47.390 --> 03:48.870
就是让它不要有奇异

03:49.150 --> 03:50.190
表示这是一个对象

03:50.430 --> 03:51.470
一个表达是一个对象

03:51.790 --> 03:52.530
这对象里边有两

03:52.750 --> 03:53.470
如果说你成功了

03:53.710 --> 03:54.790
这对象里边有两个属性

03:55.030 --> 03:56.430
一个属性叫Status

03:57.190 --> 03:57.830
Rejected

03:58.110 --> 03:59.990
当然我这里可以直接使用上面的长量

04:00.230 --> 04:00.750
Rejected

04:01.550 --> 04:02.990
好

04:03.230 --> 04:04.790
如果拿到

04:05.310 --> 04:06.790
不 它是Fulfilled的

04:07.030 --> 04:08.230
成功的是有Fulfilled的

04:09.390 --> 04:11.030
然后它的数据是什么呢

04:11.190 --> 04:11.790
就是Value

04:12.550 --> 04:13.310
这成功的

04:13.830 --> 04:15.630
好失败的是不是也一样的道理

04:16.510 --> 04:17.230
失败的时候呢

04:17.350 --> 04:18.190
它的Status

04:19.750 --> 04:20.430
是什么

04:20.550 --> 04:21.430
是那个Rejected

04:22.470 --> 04:23.230
Rejected

04:24.270 --> 04:24.670
好

04:25.230 --> 04:26.310
数据呢是Value

04:27.270 --> 04:29.310
对吧 原因呢是Value

04:30.750 --> 04:31.790
为什么保证什么呢

04:32.030 --> 04:34.590
我要往这个数据一项一项加一个新的ProMess

04:34.590 --> 04:36.630
这个新的ProMess是通过它来产生的

04:36.910 --> 04:37.790
它有可能失败

04:37.790 --> 04:39.870
但是这个新的ProMess是绝不可能失败的

04:41.590 --> 04:41.990
对不对

04:41.990 --> 04:44.310
那么这样子是不是就形成了一个ProMess的数据了

04:45.070 --> 04:46.230
那么这个ProMess的数据里边

04:46.230 --> 04:49.190
每一个ProMess只可能成功不可能失败

04:49.470 --> 04:52.310
而成功之后返回这么一个对象

04:52.430 --> 04:53.630
它的数据是这么一个对象

04:53.630 --> 04:54.470
失败的时候呢

04:55.310 --> 04:56.550
它也是成功的

04:56.550 --> 04:57.830
成功的数据是这么一个对象

04:58.310 --> 05:00.630
那么我只需要把这个数据

05:01.390 --> 05:02.830
调用Z

05:03.310 --> 05:03.710
对不对

05:03.710 --> 05:05.990
调用那个MyProMess

05:05.990 --> 05:08.350
然后把这个数据返进去

05:08.350 --> 05:09.070
是不是完成了

05:09.910 --> 05:10.990
因为O的话

05:11.430 --> 05:12.790
O这个东西它是不是

05:13.510 --> 05:14.630
它本来可能会失败

05:14.630 --> 05:17.150
但是由于这里边的ProMess是不可能失败的

05:17.150 --> 05:18.110
所有都必须要成功

05:18.110 --> 05:19.110
所以说O的方法

05:19.390 --> 05:20.790
返回的ProMess一定成功

05:21.030 --> 05:21.710
而且数据呢

05:21.710 --> 05:23.150
就是我这里给它返回的数据

05:23.150 --> 05:24.710
就算让这种节奏返回的

05:24.710 --> 05:25.630
就小痕了

05:25.950 --> 05:27.350
你们好好去理一下

05:27.430 --> 05:28.950
没有必要去写一大堆单

05:29.270 --> 05:30.750
因此我把这里的换成Mine

05:31.430 --> 05:32.350
得到的效果呢

05:32.350 --> 05:33.470
是完全一样的

05:36.030 --> 05:37.430
OK 我们再运行一下

05:38.270 --> 05:39.190
一秒钟之后

05:39.590 --> 05:40.510
是不是得到这个东西

05:41.590 --> 05:42.550
不对

05:42.550 --> 05:43.830
我这里还没改

05:43.950 --> 05:45.270
把这里改成BrandProMess

05:46.710 --> 05:47.710
这里有个错误

05:48.310 --> 05:48.830
对

05:48.950 --> 05:52.230
这个P它有可能它不是一个ProMess

05:52.230 --> 05:52.510
对吧

05:52.510 --> 05:54.110
所以说我们这里的应该用什么

05:54.110 --> 05:56.190
用MyProMess Result

05:56.510 --> 05:57.470
把它包一下

05:58.390 --> 05:58.830
对不对

05:59.390 --> 06:00.270
好 再运行

06:01.710 --> 06:02.190
你看

06:02.470 --> 06:03.550
是完全一样的结果

06:03.750 --> 06:04.070
OK啊

06:04.070 --> 06:07.310
这就是这个Ostotr如何去实现

