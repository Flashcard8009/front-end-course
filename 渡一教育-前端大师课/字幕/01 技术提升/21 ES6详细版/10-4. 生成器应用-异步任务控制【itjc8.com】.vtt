WEBVTT

00:01.010 --> 00:04.510
这一刻我们对生存器做一个应用上的讲解

00:04.510 --> 00:06.210
就是来做这么一个例子

00:06.210 --> 00:08.510
这个例子其实也蛮实用的

00:08.510 --> 00:11.510
包括你们后边学那个reaction的时候

00:11.510 --> 00:13.310
也会看到这样的类似的

00:13.310 --> 00:15.310
特别是在做圆骂分析的时候

00:15.310 --> 00:16.810
实际上reaction就是我讲的

00:16.810 --> 00:18.410
我在做圆骂分析的时候

00:18.410 --> 00:19.810
也会遇到类似的代码

00:19.810 --> 00:21.910
所以这个代码具有代表性

00:22.910 --> 00:25.110
而且生存器这一块的应用

00:25.110 --> 00:27.210
我们除了在reaction里面

00:27.210 --> 00:28.910
就目前来讲

00:29.010 --> 00:32.010
除了在reaction里面用到了这个东西之外

00:32.010 --> 00:34.210
其他的时候几乎是很少使用的

00:34.210 --> 00:36.110
所以我们就把这个例子好好说一下

00:37.910 --> 00:39.310
这个例子是什么回事呢

00:39.310 --> 00:41.210
是它是有个背景

00:41.210 --> 00:42.810
就说ES6出来之后

00:42.810 --> 00:45.610
它不是提出来这么一个叫做promise

00:45.610 --> 00:46.210
对吧

00:46.210 --> 00:49.010
要提供了一种统一的异部处理方式

00:49.010 --> 00:51.310
但是ES6它是没有出

00:51.310 --> 00:54.210
sync和awade关键字的

00:54.210 --> 00:56.310
这两个关键字它是没有出的

00:56.310 --> 00:58.510
那是ES7里面出来了

00:58.610 --> 01:00.510
这里边就有个空档期

01:00.510 --> 01:02.910
就是promise API出来过后

01:02.910 --> 01:07.110
但是ES7那边提案还成为正式标准之前

01:07.110 --> 01:08.710
这段时间咋办

01:08.710 --> 01:09.810
不活了吗

01:09.810 --> 01:11.010
我要用promise

01:11.010 --> 01:13.410
但是那个东西用起来也挺麻烦的

01:13.410 --> 01:16.310
Zen,Cache也挺麻烦的

01:16.310 --> 01:17.310
那这个东西怎么办呢

01:17.310 --> 01:18.310
不活了

01:18.310 --> 01:20.710
所以说这个问题需要解决

01:20.710 --> 01:24.610
就是在sync和awade关键字出来之前

01:24.610 --> 01:25.610
需要解决

01:25.610 --> 01:28.110
那么有些聪明的人就可以发现

01:28.710 --> 01:30.210
它不是出来个生成器吗

01:30.210 --> 01:32.710
我可以用生成器来解决这个问题

01:32.710 --> 01:35.010
于是它做出来这么一个东西

01:35.010 --> 01:37.010
就是说它写了一个函数

01:37.010 --> 01:38.610
我们这里可叫写函数

01:38.610 --> 01:41.310
它写的函数叫做wrong

01:41.310 --> 01:42.610
或者叫wrong async

01:42.610 --> 01:46.410
就是运行一些异部代

01:46.410 --> 01:48.710
比方就是叫wrong

01:48.710 --> 01:51.610
那wrong这个函数里边传啥呢

01:51.610 --> 01:55.210
传的是一个生成器函数

01:55.210 --> 01:57.410
给我传一个生成器函数

01:57.410 --> 01:59.210
表示你要运行的任务

01:59.210 --> 02:01.310
当然那里可以把函数提出去

02:01.310 --> 02:03.810
提出去比方说task

02:03.810 --> 02:06.810
就是我们的任务

02:06.810 --> 02:07.810
这是个生成器函数

02:07.810 --> 02:10.210
你完全可以提出去

02:10.210 --> 02:11.310
就个例子

02:11.310 --> 02:13.910
那么把这个task函数传进来

02:13.910 --> 02:14.510
明白这个意思吗

02:14.510 --> 02:16.210
当然也可以把传个地名函数

02:16.210 --> 02:17.610
直接放到这也行

02:17.610 --> 02:20.210
就是说我这里写这么一个生成器函数

02:20.210 --> 02:22.210
那么这个函数

02:22.210 --> 02:25.610
作为参数放到一个wrong函数里边

02:25.610 --> 02:26.610
我现在说的是

02:26.610 --> 02:29.010
就是它希望达成的效果

02:29.010 --> 02:31.410
来解决这个promise不好用的问题

02:31.410 --> 02:33.210
那么这里边就可以写异部代码了

02:33.210 --> 02:34.410
这里边咋写呢

02:34.410 --> 02:35.810
如果说你是同步代码的话

02:35.810 --> 02:36.710
没问题

02:36.710 --> 02:39.410
比方说这一个随便写个e有的

02:39.410 --> 02:39.910
e

02:39.910 --> 02:41.010
那么这样子呢

02:41.010 --> 02:42.910
这个d就是1

02:42.910 --> 02:44.610
d是1

02:44.610 --> 02:46.510
它希望达成这么一个效果

02:46.510 --> 02:48.610
然后如果说你写了异部代码

02:48.610 --> 02:49.610
比方说我们之前讲了个

02:49.610 --> 02:50.610
Fetch API的时候

02:50.610 --> 02:52.110
不是有这么一个地址吗

02:52.110 --> 02:52.910
请求测试地址

02:52.910 --> 02:53.610
来吧

02:53.610 --> 02:59.960
我们用Fetch API去请求这个地址

02:59.960 --> 03:00.960
复制

03:00.960 --> 03:01.860
粘过来

03:01.860 --> 03:04.260
那么由于现在没有awaiter关键字

03:04.260 --> 03:06.460
所以说我们可以用e有的

03:06.460 --> 03:08.260
它希望达成这么一个效果

03:08.260 --> 03:09.160
那么这样子呢

03:09.160 --> 03:10.860
就可以得到这个promise

03:10.860 --> 03:13.460
resolve之后的它的状态数据

03:13.460 --> 03:15.260
等到它promise完成之后

03:15.260 --> 03:17.060
它会把的状态数据放到这

03:17.060 --> 03:17.560
然后呢

03:17.560 --> 03:18.760
我们这里还不可以用

03:18.760 --> 03:20.260
就是result

03:20.260 --> 03:21.460
然后e有的

03:21.460 --> 03:24.160
resp.json

03:24.160 --> 03:25.560
相当于就是

03:25.560 --> 03:27.160
就是那个

03:27.160 --> 03:28.560
assync.awaiter

03:28.560 --> 03:29.860
相当于是这么一个道理的

03:29.860 --> 03:32.060
输出result

03:32.060 --> 03:33.060
其实assync.awaiter

03:33.060 --> 03:35.160
就是基于这样的灵感

03:35.160 --> 03:37.560
也就是弄出来了

03:37.560 --> 03:39.260
它就是希望实现这么一个效果

03:39.260 --> 03:41.360
那最终就看就是这里输

03:41.360 --> 03:43.460
比方说这里输出d

03:43.460 --> 03:44.160
输出d

03:44.160 --> 03:45.260
那么就输出e

03:45.260 --> 03:46.360
那么这里输出result

03:46.360 --> 03:48.060
就输出服输反回的数据

03:48.060 --> 03:50.360
来实现类似的效果

03:50.360 --> 03:52.660
那如果说你要完成这个效果的话

03:52.660 --> 03:53.860
该怎么来做呢

03:53.860 --> 03:56.060
就是你要去实现这个wrong函数

03:56.060 --> 03:58.060
这一刻咱们就在实现这个wrong函数

03:58.060 --> 03:59.660
呆码不多

03:59.660 --> 04:02.660
但是感觉上可能会有点少

04:02.660 --> 04:04.360
wrong函数里边有个参数

04:04.360 --> 04:05.560
参数是什么呢

04:05.560 --> 04:07.060
是不是一个生成器函数

04:07.060 --> 04:09.260
你要给我传一个生成器函数进来

04:09.260 --> 04:09.860
对吧

04:09.860 --> 04:11.960
你要给我传一个生成器函数进来

04:11.960 --> 04:15.460
那么我们比方说叫做generator funk

04:15.460 --> 04:17.060
这是一个生成器函数

04:17.060 --> 04:18.860
你把生成器函数传给我

04:18.860 --> 04:19.360
OK

04:19.360 --> 04:22.160
我来帮助你控制

04:22.160 --> 04:23.760
函数内部的执行

04:23.760 --> 04:24.560
因为为什么呢

04:24.560 --> 04:26.560
因为生成器函数一调用

04:26.560 --> 04:28.960
是不是可以拿到一个生成器

04:28.960 --> 04:29.960
生成器函数一调用

04:29.960 --> 04:31.460
是不是可以拿到一个生成器

04:31.460 --> 04:32.060
对吧

04:32.060 --> 04:33.660
而生成器是不是可以控制

04:33.660 --> 04:35.960
生成器函数内部的执行

04:35.960 --> 04:36.460
对不对

04:36.460 --> 04:38.860
来达到这样最终的目的

04:38.860 --> 04:39.260
好

04:39.260 --> 04:40.460
来吧比方说

04:40.460 --> 04:42.160
这是一个生成器拿到过后

04:42.160 --> 04:43.960
但是这个函数会运行吗

04:43.960 --> 04:45.160
因为这个把这个函数传进来了

04:45.160 --> 04:45.460
对吧

04:45.460 --> 04:47.260
把这个task函数传过来了

04:47.260 --> 04:48.460
那么这个函数会运行吗

04:48.460 --> 04:49.660
它是不是不会运行

04:49.660 --> 04:51.160
因为它这里边的都是

04:51.160 --> 04:53.060
每一次迭代的数据给它

04:53.060 --> 04:54.560
把每一次迭代的数据给它

04:54.560 --> 04:55.960
所以它本身是不会运行的

04:55.960 --> 04:57.260
因为你没有迭代

04:57.260 --> 04:59.860
所以说我希望把它的函数运行起来

04:59.860 --> 05:02.060
因此我这里一开始调用一次

05:02.060 --> 05:03.160
对吧

05:03.160 --> 05:04.760
就是启动

05:04.760 --> 05:06.960
启动任务

05:06.960 --> 05:09.560
就是开始把这个函数运行起来

05:09.560 --> 05:10.960
就是开始迭代

05:10.960 --> 05:15.480
实际上实际上的意思就是开始迭代

05:15.480 --> 05:16.780
但是只迭代一次吗

05:16.780 --> 05:18.080
肯定不止

05:18.080 --> 05:20.180
我鬼知道这个函数里面有多少个e有的

05:20.180 --> 05:20.680
对不对

05:20.680 --> 05:21.780
那肯定要不断的迭代

05:21.780 --> 05:23.180
不断的迭代

05:23.180 --> 05:24.880
总之启动任务还是迭代

05:24.880 --> 05:25.080
好

05:25.080 --> 05:27.680
每一次迭代是不是得有个结果

05:27.680 --> 05:29.480
它会把这个结果数据给我

05:29.480 --> 05:29.780
对吧

05:29.780 --> 05:31.180
所以说我们来接受一下

05:31.180 --> 05:32.380
result

05:32.380 --> 05:34.080
是不是得到每一次迭代的结果

05:34.080 --> 05:35.180
你看第1次迭代的e

05:35.180 --> 05:36.980
那是e是不是负责给result

05:36.980 --> 05:38.680
然后result是一个对象

05:38.680 --> 05:40.480
它里面有一个value属性为e

05:40.480 --> 05:43.080
当属性为force

05:43.080 --> 05:45.280
那么它会得到一个迭代的数据

05:45.280 --> 05:47.980
启动任务得到迭代的数据

05:47.980 --> 05:49.680
迭代数据

05:49.680 --> 05:49.880
好

05:49.880 --> 05:51.080
那么接下来要做啥呢

05:51.080 --> 05:53.480
接下来我们要处理这个数据了

05:53.480 --> 05:55.280
因为我鬼知道你给我的数据是啥

05:55.280 --> 05:56.880
有可能是给我一个字不错

05:56.880 --> 05:58.480
有可能给我一个数字

05:58.480 --> 05:59.280
有可能呢

05:59.280 --> 06:00.780
给我一个promise

06:00.780 --> 06:01.080
对吧

06:01.080 --> 06:03.280
它是不是也有可能给我一个promise对象

06:03.280 --> 06:05.080
我不知道你这个数据是啥

06:05.080 --> 06:05.980
根据不同的数据

06:05.980 --> 06:07.480
我肯定要做不同的处理

06:07.480 --> 06:09.180
因此我这里为了方便我们处理

06:09.180 --> 06:10.680
我们再写个函数

06:10.680 --> 06:12.180
比方说

06:12.180 --> 06:14.180
handle result

06:14.180 --> 06:16.480
处理result

06:16.480 --> 06:18.780
这个函数的作用是

06:18.780 --> 06:22.280
对result进行处理

06:22.280 --> 06:23.380
进行处理

06:23.380 --> 06:25.280
那么你一开始得到了result

06:25.280 --> 06:27.680
是不是一开始要调用一次handle result

06:27.680 --> 06:29.080
对吧

06:29.080 --> 06:29.980
那么调用这个函数

06:29.980 --> 06:31.480
对result进行处理

06:31.480 --> 06:31.680
好

06:31.680 --> 06:33.280
那么接下来我们再看这个函数里面

06:33.280 --> 06:34.380
怎么对result

06:34.380 --> 06:35.480
这个启动

06:35.480 --> 06:37.380
就迭代的数据进行处理

06:37.380 --> 06:38.680
我们这个只能写完了之后

06:38.680 --> 06:40.480
才能看到效果

06:40.480 --> 06:42.680
我边写的时候

06:42.680 --> 06:43.780
边得讲解

06:43.780 --> 06:45.380
就是启动任务明白吧

06:45.380 --> 06:46.180
启动任务

06:46.180 --> 06:47.280
启动任务过后

06:47.280 --> 06:48.080
它就开始迭代了

06:48.480 --> 06:48.980
是不是迭代了

06:48.980 --> 06:50.780
拿到第一次迭代的结果

06:50.780 --> 06:51.780
拿到结果之后

06:51.780 --> 06:53.880
是不是要对这个结果进行处理

06:53.880 --> 06:54.280
对吧

06:54.280 --> 06:55.380
要进行处理

06:55.380 --> 06:56.480
那么怎么来处理

06:56.480 --> 06:57.780
其实首先有一个逻辑

06:57.780 --> 07:01.280
就是看一下迭代有没有完成

07:01.280 --> 07:02.780
如果说迭代都完了

07:02.780 --> 07:04.680
这个函数就已经执行完了

07:04.680 --> 07:05.780
那还处理吗

07:05.780 --> 07:06.580
还处理啥

07:06.580 --> 07:07.780
这个函数都执行完了

07:07.780 --> 07:08.680
还处理啥

07:08.680 --> 07:11.080
不处理了

07:11.080 --> 07:12.980
迭代完成

07:12.980 --> 07:14.280
不处理

07:14.280 --> 07:15.780
不做任何处理

07:15.780 --> 07:17.980
如果说迭代还没有完成

07:18.180 --> 07:18.980
做什么呢

07:18.980 --> 07:20.380
分为两种情况

07:22.180 --> 07:24.480
迭代没有完成

07:24.480 --> 07:25.680
分为两种情况

07:26.880 --> 07:28.280
两种情况

07:28.280 --> 07:30.180
哪两种情况呢

07:30.180 --> 07:32.480
第一种就是情况一

07:32.480 --> 07:34.780
就是迭代的数据

07:34.780 --> 07:38.180
迭代的数据是一个Promise

07:39.180 --> 07:40.580
情况二

07:40.580 --> 07:45.080
迭代的数据是其他数据

07:45.080 --> 07:46.980
因为Promise是一个异步的场景

07:46.980 --> 07:47.480
对吧

07:47.480 --> 07:49.980
所以说我们要考虑到这个情况

07:49.980 --> 07:50.980
分开处理

07:50.980 --> 07:51.580
怎么来判断

07:51.580 --> 07:53.380
它迭代的数据是不是一个Promise

07:53.380 --> 07:55.280
你首先要搞清楚迭代的数据在哪

07:55.280 --> 07:57.780
迭代的数据是不是在Result的Value里边

07:57.780 --> 08:00.180
那么我们可以通过这种简单的方式来判断

08:00.180 --> 08:02.480
Value如果说它有一个任方法

08:02.480 --> 08:04.580
或者说我们加上一个Type 5

08:04.580 --> 08:06.180
Type 5

08:06.180 --> 08:07.180
Value的任

08:07.180 --> 08:08.580
如果说是一个函数

08:08.580 --> 08:10.780
因为Promise里边不是一个任方法

08:10.780 --> 08:12.380
Promise里边不是一个任方法

08:12.380 --> 08:13.880
我们通过一个特征来判断

08:13.880 --> 08:15.180
如果说它是一个函数的话

08:15.180 --> 08:18.980
OK 我认为你是一个Promise对象

08:18.980 --> 08:20.180
你是一个Promise对象

08:20.180 --> 08:21.780
我们就用这种方式

08:21.780 --> 08:22.580
就用这种方式

08:24.480 --> 08:27.380
那么这是迭代的数据是一个Promise对象

08:29.580 --> 08:31.680
Ales是一个普通数据

08:31.680 --> 08:34.580
迭代的数据是其他的数据

08:34.580 --> 08:36.580
我们把它分成两种情况来看一下

08:36.580 --> 08:38.980
怎么进一后去处理

08:38.980 --> 08:42.580
如果说你迭代的数据是其他数据的话

08:42.580 --> 08:43.980
这个很简单

08:44.080 --> 08:45.380
我们怎么处理呢

08:45.380 --> 08:48.180
我们是不是让它进一步迭代

08:48.180 --> 08:49.580
不能有永远停在这

08:49.580 --> 08:50.780
第一次迭代完了停在这

08:50.780 --> 08:51.780
也不能永远停在这

08:51.780 --> 08:53.180
还在往后续进行

08:53.180 --> 08:55.180
是要进行下一次迭代

08:55.180 --> 08:56.980
直接进行

08:56.980 --> 09:01.180
直接进行下一次迭代

09:01.180 --> 09:03.280
那么下一次迭代怎么迭代

09:03.280 --> 09:06.080
是不是Dialog Generator的Legs方法

09:06.080 --> 09:07.280
要不要传参数

09:07.280 --> 09:08.480
这个参数你要搞清楚

09:08.480 --> 09:10.180
这个参数给谁的

09:10.180 --> 09:11.780
是不是给这边的

09:11.780 --> 09:13.380
有可能他要要这个数据

09:13.480 --> 09:15.280
要这个这边的数据

09:15.280 --> 09:16.380
管他管他的

09:16.380 --> 09:17.880
他既然写来我就给他吧

09:17.880 --> 09:18.780
那么这个数据在哪

09:18.780 --> 09:19.480
拿这个数据

09:19.480 --> 09:21.780
这个数据是不是在Result的Value里边

09:21.780 --> 09:22.780
对吧

09:22.780 --> 09:23.980
那么我们就简单的

09:23.980 --> 09:26.780
把我之前得到的迭代数据在传给你

09:26.780 --> 09:28.380
在传给你进行下一次迭代

09:28.380 --> 09:29.180
那么下一次迭代

09:29.180 --> 09:31.780
是不是要重新更新这个Result的结果

09:31.780 --> 09:32.080
对吧

09:32.080 --> 09:33.580
重新更新Result

09:35.080 --> 09:37.080
这个态法就不是很好理解了

09:37.080 --> 09:39.180
是不是如果说你迭代的数据

09:39.180 --> 09:39.780
是其他数据的话

09:39.780 --> 09:41.780
直接进行下一次迭代就完事了

09:41.780 --> 09:43.580
那么直接把数据给这个Result

09:43.580 --> 09:45.680
然后再调用这个Handle

09:45.680 --> 09:47.080
这是个低规的过程

09:47.080 --> 09:48.380
再调用这个HandleResult

09:48.380 --> 09:51.480
基因再处理再处理下一个数据

09:51.480 --> 09:53.680
那么现在搞定了同步代码的情况

09:53.680 --> 09:55.080
比方说这里没有异步

09:55.080 --> 09:56.180
比方说没有异步

09:56.180 --> 09:57.580
你看一下吧

09:57.580 --> 09:58.180
没有异步

09:58.180 --> 10:02.180
那么我们这里输出一个A

10:02.180 --> 10:04.180
一有的ABC

10:04.180 --> 10:05.580
输出A

10:05.580 --> 10:06.280
没有异步

10:06.280 --> 10:10.330
咱们来看一下

10:10.330 --> 10:12.030
运行

10:12.030 --> 10:13.030
检查

10:13.030 --> 10:14.030
控制台

10:14.130 --> 10:15.930
你看是不是输出了一和ABC

10:15.930 --> 10:16.530
对吧

10:16.530 --> 10:19.230
你看我们如何把这个任务传进去

10:19.230 --> 10:20.230
这个任务传进去

10:20.230 --> 10:22.030
是不是就把这个任务执行掉了

10:22.030 --> 10:22.430
对吧

10:22.430 --> 10:23.130
它怎么执行的

10:23.130 --> 10:26.030
它其实就是在内部产生一个生成器

10:26.030 --> 10:29.030
然后首先让它第一次启动起来

10:29.030 --> 10:29.730
得到一个结果

10:29.730 --> 10:31.230
然后它不断的处理结果

10:31.230 --> 10:32.230
处理的结果在过程中

10:32.230 --> 10:34.030
如果看到它是一个普通数据的话

10:34.030 --> 10:35.930
那么马上进行下一次迭代

10:35.930 --> 10:36.830
又拿到一个去

10:36.830 --> 10:39.530
把这上一次的结果传给下一次

10:39.530 --> 10:40.830
那么这样子一来一传递

10:40.830 --> 10:42.730
是不是把上一次得到的结果

10:42.730 --> 10:44.030
一传给下一次

10:44.030 --> 10:45.630
是不是第一就变成一了

10:45.630 --> 10:46.330
然后运行

10:46.330 --> 10:47.230
又得到ABC

10:47.230 --> 10:48.330
ABC又传给下一次

10:48.330 --> 10:49.330
是不是得到A了

10:49.330 --> 10:50.730
直到整个结束

10:50.730 --> 10:53.430
直到整个结束就不再处理了

10:53.430 --> 10:53.630
对吧

10:53.630 --> 10:54.830
这是同步的情况

10:54.830 --> 10:56.430
同步的情况来说的话

10:56.430 --> 10:57.930
相对的好理解

10:57.930 --> 10:59.830
那么一步实际上是一样的

10:59.830 --> 11:01.930
如果说你迭代的数据是一个Promise的话

11:01.930 --> 11:04.030
那我不能立即去做这件事情了

11:04.030 --> 11:06.230
我不能立即进行下一次迭代了

11:06.230 --> 11:06.830
要等

11:06.830 --> 11:08.130
等什么呢

11:08.130 --> 11:10.530
等待Promise完成

11:10.530 --> 11:16.530
Promise完成后再进行下一次迭代

11:16.530 --> 11:19.230
就是说如果说Promise一天都没完成

11:19.230 --> 11:19.530
ok

11:19.530 --> 11:21.630
那我一天都不会调用这个代码

11:21.630 --> 11:22.530
不调用这个代码

11:22.530 --> 11:25.230
是不是就一直不会进行下一次迭代

11:25.230 --> 11:26.930
那是不是就代码就一直卡在这

11:26.930 --> 11:27.230
对吧

11:27.230 --> 11:28.830
就一直卡在某一个地方

11:28.830 --> 11:32.790
比方说在这里废弃

11:32.790 --> 11:33.090
对吧

11:33.090 --> 11:34.190
你给我的是个Promise

11:34.190 --> 11:34.390
ok

11:34.390 --> 11:35.490
你Promise一天不结束

11:35.490 --> 11:36.690
我代码就一天卡在这

11:36.690 --> 11:37.590
你什么时候结束了

11:37.590 --> 11:38.790
我什么时候就调用Legs

11:38.790 --> 11:40.590
它就用这种方式来实现的

11:40.590 --> 11:41.990
那么等呗

11:42.090 --> 11:42.690
Promise在哪

11:42.690 --> 11:44.490
是不是在Results.Value里边

11:44.490 --> 11:44.990
对吧

11:44.990 --> 11:47.190
Value里边它有个Zen函数

11:47.190 --> 11:48.390
那么我们调用Zen

11:48.390 --> 11:50.790
Zen里边等你完成了之后

11:50.790 --> 11:52.290
等你完成了之后

11:52.290 --> 11:54.690
是不是会给我一个完成的数据

11:54.690 --> 11:55.590
等你完成之后

11:55.590 --> 11:56.990
会给我一个完成的数据

11:56.990 --> 11:58.490
那么等你完成了之后

11:58.490 --> 11:58.890
ok

11:58.890 --> 12:01.190
我这个时候才进行下一次迭代

12:01.190 --> 12:01.690
下一次迭代

12:01.690 --> 12:04.290
我们直接把个代码复制进来

12:04.290 --> 12:07.090
但是这个数据我给你的就不是

12:07.090 --> 12:08.890
因为这个东西是Promise对吧

12:08.890 --> 12:11.490
我要给你这个完成后的状态数据

12:11.590 --> 12:14.090
就是我给他什么数据完全我可以控制的

12:14.090 --> 12:14.790
我要给你什么数据

12:14.790 --> 12:15.690
我想给你什么数据

12:15.690 --> 12:16.590
给你什么数据

12:16.590 --> 12:18.790
那么我把完成后的数据给你

12:18.790 --> 12:19.990
对吧

12:19.990 --> 12:21.790
我们用这种方式来完成

12:21.790 --> 12:21.990
好

12:21.990 --> 12:23.690
如果说你遇到错误了

12:23.690 --> 12:24.990
如果说你遇到错误了

12:24.990 --> 12:26.790
那么我们还可以进行处理

12:26.790 --> 12:27.690
我们怎么办呢

12:27.690 --> 12:30.490
我们用GeneratorStrope

12:32.290 --> 12:32.690
对吧

12:32.690 --> 12:33.990
抛出一个错误

12:33.990 --> 12:34.990
对不对

12:34.990 --> 12:36.790
可以抛出一个错误

12:36.790 --> 12:39.590
在这里边在那里边抛出一个错误

12:39.590 --> 12:40.490
抛出一个错误

12:40.490 --> 12:42.190
不要把Error抛出

12:42.190 --> 12:43.390
Error错误抛出

12:43.390 --> 12:45.490
然后还是一样的

12:45.490 --> 12:46.390
Full the result

12:46.390 --> 12:48.790
然后Handle result

12:48.790 --> 12:49.290
对吧

12:49.290 --> 12:50.690
是不是一样的道理

12:50.690 --> 12:52.090
我们就不看错误的情况

12:52.090 --> 12:54.890
我们先把这个东西理解清楚再说

12:54.890 --> 12:56.690
把这个东西理解清楚

12:56.690 --> 12:57.990
好就没问题了吧

12:57.990 --> 12:58.990
那就写完了

12:58.990 --> 12:59.490
就写完了

12:59.490 --> 13:00.390
你看一下

13:00.390 --> 13:02.690
现在我们把Round这个函数折起来

13:02.690 --> 13:03.990
那么这个是个通用的

13:03.990 --> 13:05.690
不是说光位这个函数服务的

13:05.690 --> 13:07.290
它是个通用的

13:07.290 --> 13:08.790
任何的异部处理的

13:08.790 --> 13:10.090
我们都可以用这种模式

13:10.090 --> 13:11.190
都可以调用这个Round函数

13:11.190 --> 13:14.090
把生存器函数传进去

13:14.090 --> 13:15.390
那么就可以使用这种模式了

13:15.390 --> 13:16.790
你看是不是达成了跟

13:16.790 --> 13:18.290
而位置的一样的效果

13:18.290 --> 13:19.490
你看一下吧

13:19.490 --> 13:20.390
刷新

13:20.390 --> 13:22.790
你看是不是任何人可以得到这个数据

13:22.790 --> 13:24.090
是在这里输出的

13:24.090 --> 13:26.890
可以达到跟而位置一样的效果

13:26.890 --> 13:28.190
就是生存器

13:28.190 --> 13:31.690
它的比较特别的地方

13:31.690 --> 13:34.490
这就是生存器的任务处理

13:34.490 --> 13:35.490
异部任务处理

13:35.490 --> 13:38.090
这个玩意你可能现在听一听

13:38.090 --> 13:40.390
我后边我记得我讲React的时候

13:40.390 --> 13:41.890
还给大家复习了一遍

13:41.890 --> 13:42.890
关于生存器

13:42.890 --> 13:43.590
生存器迭代器

13:43.590 --> 13:45.390
我都给大家复习了一遍

13:45.390 --> 13:47.390
防止你忘记了

13:47.390 --> 13:48.190
因为这个东西

13:48.190 --> 13:50.390
目前就目前的前端环境里边

13:50.390 --> 13:52.290
而延生存器和迭代器

13:52.290 --> 13:55.590
你平时写来是真语不知道

13:55.590 --> 13:57.890
但是一到React的时候

13:57.890 --> 13:59.890
就会大量遇到

13:59.890 --> 14:02.290
所以说必须得讲

14:02.290 --> 14:04.290
后边我会给大家复习一遍

14:04.290 --> 14:05.490
不用担心

14:05.490 --> 14:07.190
那么生存器这个章节

14:07.290 --> 14:08.390
就到此结束了

14:08.390 --> 14:09.690
所以感觉很困难

14:09.690 --> 14:12.390
不过目前的

14:12.390 --> 14:15.390
所有最难的知识全部结束了

14:15.390 --> 14:17.490
异部处理和迭代器生存器全部结束了

14:17.490 --> 14:20.590
后边都是非常轻松的一些知识

14:20.590 --> 14:21.090
好吧

14:21.090 --> 14:21.590
OK

14:21.590 --> 14:23.290
这是关于这一张的内容

