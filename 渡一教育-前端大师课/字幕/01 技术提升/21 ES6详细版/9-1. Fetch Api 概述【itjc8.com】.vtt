WEBVTT

00:01.140 --> 00:04.140
好 这一趟节呢 咱们来学习这个Fetch API

00:04.140 --> 00:08.140
呃 首先跟大家说明啊 这个Fetch API呢

00:08.140 --> 00:11.140
它并不是ES6里边的知识

00:11.140 --> 00:15.140
呃 但是呢 它用到了ES6里边的异部处理

00:15.140 --> 00:19.140
所以说呢 我们授课的时候呢 往往就是在异部处理之后啊

00:19.140 --> 00:22.140
就是Promise API之学习了之后呢

00:22.140 --> 00:24.140
我们会添加这一块的知识

00:24.140 --> 00:27.140
因为你们在学习atm 5 API的时候呢

00:27.140 --> 00:30.140
呃 没有办法学习这个Fetch API

00:30.140 --> 00:33.140
因为它涉及到Promise的知识 没有这意思吗

00:33.140 --> 00:35.140
所以说呢 这一块呢 虽然不是说

00:35.140 --> 00:37.140
它虽然不是ES6的知识

00:37.140 --> 00:41.140
但是呢 由于呢 它紧密的跟ES6里边的异部处理啊

00:41.140 --> 00:45.140
就是Promise API呃 就是联系的很紧密

00:45.140 --> 00:48.140
所以说呢 我们往往呢 会来这里进行介绍

00:48.140 --> 00:51.140
好吧 嗯 这节课呢 我们简单的说起去啊

00:51.140 --> 00:53.140
要不了多少时间 几分钟的时间

00:53.140 --> 00:56.140
就是对 Fetch API呢 做一个简单的介绍

00:56.140 --> 00:59.140
呃 首先呢 因为因为我平时呢

00:59.140 --> 01:03.140
听学生讲这个 说一些概念的时候呢

01:03.140 --> 01:07.140
老是容易把这个Fetch API呢 理解的有偏差

01:07.140 --> 01:09.140
所以说呢 我花几分钟的时间啊

01:09.140 --> 01:10.140
给大家做个介绍

01:10.140 --> 01:13.140
呃 为什么要出现这个Fetch API呢

01:13.140 --> 01:16.140
啊 就是为什么要出现一套全新的API来

01:16.140 --> 01:18.140
呃 做这个网络请求呢

01:18.140 --> 01:20.140
啊 就是Fetch API做什么呢

01:20.140 --> 01:22.140
它就是做阿迦克斯请求的

01:22.140 --> 01:25.140
是因为我们过去呢 用传统的方式来实现

01:25.140 --> 01:28.140
阿迦克斯请求呢 遇到了一些问题

01:28.140 --> 01:31.140
我们过去呢 使用的是Atema ATDP Request

01:31.140 --> 01:33.140
这个对象 对吧 这个构造函数

01:33.140 --> 01:36.140
使用的是它来实现阿迦克斯请求的

01:36.140 --> 01:38.140
那么大家呢 也应该有说体会

01:38.140 --> 01:40.140
用这个玩意去实现阿迦克斯请求

01:40.140 --> 01:42.140
是不是特别特别繁琐

01:43.140 --> 01:45.140
对吧 我们除非呢 一般情况下呢

01:45.140 --> 01:48.140
都会去自己去封装一个函数

01:48.140 --> 01:51.140
或者是封装一个对象

01:51.140 --> 01:53.140
来解决这样的 这种繁琐的问题

01:53.140 --> 01:55.140
比方说浏览期兼容问题啊

01:55.140 --> 01:57.140
各种各样的问题

01:57.140 --> 02:00.140
呃 它到底具体的问题出现在哪呢

02:00.140 --> 02:02.140
第一个啊 它的问题 第一个

02:02.140 --> 02:04.140
呃 所有的功能呢

02:04.140 --> 02:06.140
它全部集中在同一个对象上

02:06.140 --> 02:09.140
就是我们以前要做一个阿迦克斯请求

02:09.140 --> 02:11.140
创建一个ATDP Request对象 对吧

02:11.140 --> 02:13.140
创建一个对象过后呢 什么

02:13.140 --> 02:17.140
配置请求头啊 配置请求方式啊

02:17.140 --> 02:18.140
等等等等

02:18.140 --> 02:21.140
是不是全部都集中在一个对象上面

02:21.140 --> 02:25.140
对吧 如果说请求的场景比较简单的话

02:25.140 --> 02:27.140
倒是也没啥问题

02:27.140 --> 02:29.140
如果说请求的场景呢 稍微以变化

02:29.140 --> 02:31.140
稍微以复杂一点的话

02:31.140 --> 02:33.140
因为它都全部在一个对象上面

02:33.140 --> 02:35.140
那么协谐的就非常非常的繁数

02:35.140 --> 02:37.140
不利于代码的分割

02:37.140 --> 02:39.140
像我们以后呢 做大型项目里边

02:39.140 --> 02:41.140
功能越来越复杂 场景越来越多变

02:41.140 --> 02:43.140
越来越要求灵活度

02:43.140 --> 02:45.140
所以我们往往会把不同的功能的

02:45.140 --> 02:47.140
分成一个一个的小块

02:47.140 --> 02:50.140
因此呢 它把全部集中在一个对象上面

02:50.140 --> 02:51.140
不利于功能的分割

02:51.140 --> 02:53.140
说这也是它为什么

02:53.140 --> 02:57.140
我们需要对它进行封装的一个重要的原因

02:57.140 --> 03:00.140
像我们以前呢 做阿里克斯请求

03:00.140 --> 03:03.140
几乎是不太用原生的解释去写阿里克斯

03:03.140 --> 03:05.140
对吧 一般都是用解垮类

03:05.140 --> 03:07.140
当然解垮类呢 它本身底层也是用的是

03:07.140 --> 03:09.140
这个对象

03:09.140 --> 03:11.140
怎么用起来 要方便了很多

03:11.140 --> 03:15.140
说明这个APM它本身是存在很大的问题的

03:15.140 --> 03:17.140
因为它全部集中在一个对象上面

03:17.140 --> 03:21.140
容易写出了混乱不易维护的代码

03:21.140 --> 03:22.140
第二个问题呢

03:22.140 --> 03:24.140
就是最严重的问题

03:24.140 --> 03:26.140
就是因为ES6出来之后呢

03:26.140 --> 03:28.140
它推出来这个Promise API

03:28.140 --> 03:30.140
这是ES6出来过后

03:30.140 --> 03:32.140
那么推出来这个东西过后呢

03:32.140 --> 03:35.140
而阿里克斯呢 就是一个典型的异步场景

03:35.140 --> 03:39.140
因为Promise API它本身就是在解决异步的代码

03:39.140 --> 03:42.140
这种千套的调用的混乱的

03:42.140 --> 03:44.140
本来就是在解决异步场景的

03:45.140 --> 03:47.140
但是呢 过去呢

03:47.140 --> 03:49.140
它没有这个Promise API

03:49.140 --> 03:51.140
因为过去都是使用了回调模式

03:51.140 --> 03:53.140
或者是事件驱动模式的吧

03:53.140 --> 03:56.140
给它注册一个事件 给它写个回调函数

03:56.140 --> 03:59.140
来当我们某个条件满足的时候呢

03:59.140 --> 04:01.140
去运行对应的函数

04:01.140 --> 04:02.140
都是使用的是这种模式

04:02.140 --> 04:04.140
因此呢 这个原来的

04:04.140 --> 04:05.140
阿里克斯请求呢

04:05.140 --> 04:09.140
我们也采用了就是传统的事件驱动模式

04:09.140 --> 04:10.140
那到现在呢

04:10.140 --> 04:13.140
我们有了这个Promise API之后呢

04:13.140 --> 04:15.140
有了这个东西之后呢

04:15.140 --> 04:16.140
我们就希望呢

04:16.140 --> 04:19.140
我们能不能你这个APN呢

04:19.140 --> 04:21.140
给我返回一个Promise呢

04:21.140 --> 04:22.140
但是呢 它以前呢

04:22.140 --> 04:24.140
有一道兼容性问题

04:24.140 --> 04:26.140
它就没有对它进行更改

04:26.140 --> 04:27.140
没有对它进行更改

04:27.140 --> 04:28.140
实际上这一块呢

04:28.140 --> 04:29.140
Jquery还做的比较好

04:29.140 --> 04:30.140
Jquery呢

04:30.140 --> 04:32.140
它已经把它的就是那些

04:32.140 --> 04:33.140
阿里克斯请求呢

04:33.140 --> 04:35.140
基本上都是返回的是Promise的

04:35.140 --> 04:36.140
返回的都是Promise的

04:36.140 --> 04:37.140
但是呢

04:37.140 --> 04:39.140
浏览器端的就是这个

04:39.140 --> 04:41.140
XML

04:41.140 --> 04:42.140
ATDP Requests的对象呢

04:42.140 --> 04:44.140
它仍然是用传统的模式

04:44.140 --> 04:46.140
来解决这个异布场景的

04:46.140 --> 04:47.140
所以说呢

04:47.140 --> 04:48.140
我们要 如果说要

04:48.140 --> 04:49.140
适配这个Promise API的话

04:49.140 --> 04:50.140
我们才得自己封装

04:50.140 --> 04:51.140
你看

04:51.140 --> 04:52.140
我们在上一张节

04:52.140 --> 04:54.140
我们封装了个阿里克斯函数

04:54.140 --> 04:55.140
是不是我们自己封装的意思

04:55.140 --> 04:56.140
对吧

04:56.140 --> 04:58.140
如果你不封装的话

04:58.140 --> 04:59.140
你要去直接使用它的话

04:59.140 --> 05:01.140
那你还是得使用事件驱动

05:01.140 --> 05:02.140
没有办法

05:02.140 --> 05:03.140
没有那意思吗

05:03.140 --> 05:05.140
好 这是关于这个

05:05.140 --> 05:06.140
它以前的一些问题

05:06.140 --> 05:08.140
那么基于这些问题的话

05:08.140 --> 05:10.140
那个浏览器

05:10.140 --> 05:12.140
浏览器的标准

05:12.140 --> 05:14.140
NTM5出来之后呢

05:14.140 --> 05:16.140
它就对这一块的API进行的改进

05:16.140 --> 05:18.140
它就出来了一块新的

05:18.140 --> 05:20.140
API来解决

05:20.140 --> 05:22.140
以前传统的API的问题

05:22.140 --> 05:24.140
好 首先第1个

05:24.140 --> 05:25.140
我们看一下

05:25.140 --> 05:27.140
非捷API的这么一个特点

05:27.140 --> 05:28.140
第1个就是

05:28.140 --> 05:29.140
它并非呢

05:29.140 --> 05:30.140
是取代阿里克斯

05:30.140 --> 05:31.140
这一点很重要

05:31.140 --> 05:33.140
这是概念上的理解问题

05:33.140 --> 05:34.140
很多同学认为

05:34.140 --> 05:35.140
我们

05:35.140 --> 05:37.140
我说我这里要写一个阿里克斯

05:38.140 --> 05:40.140
写阿里克斯就不如用

05:40.140 --> 05:41.140
非捷API

05:41.140 --> 05:42.140
那么说这句话的同学呢

05:42.140 --> 05:43.140
他就没有搞清楚

05:43.140 --> 05:44.140
非捷API呢

05:44.140 --> 05:46.140
他其实实际上也是阿里克斯

05:46.140 --> 05:47.140
因为阿里克斯呢

05:47.140 --> 05:48.140
是一套

05:48.140 --> 05:50.140
可以说是一套标准吧

05:50.140 --> 05:51.140
就是浏览器

05:51.140 --> 05:53.140
在不刷新页面的情况下

05:53.140 --> 05:55.140
通过浏览器的执行引擎

05:55.140 --> 05:57.140
通过网络

05:57.140 --> 05:58.140
网络模块

05:58.140 --> 05:59.140
网络通信模块

05:59.140 --> 06:01.140
跟服务器之间发生交互

06:01.140 --> 06:03.140
这就是阿里克斯对本质的东西

06:03.140 --> 06:05.140
他并没有说

06:05.140 --> 06:07.140
必须要使用哪个对象来解决

06:07.140 --> 06:08.140
就是阿里克斯

06:08.140 --> 06:09.140
不是的

06:09.140 --> 06:10.140
我们以前呢

06:10.140 --> 06:12.140
使用的是这种模式来

06:12.140 --> 06:13.140
实现阿里克斯

06:13.140 --> 06:14.140
所以说呢

06:14.140 --> 06:15.140
我们阿里克斯呢

06:15.140 --> 06:16.140
它只是一个概念

06:16.140 --> 06:17.140
它只是说

06:17.140 --> 06:18.140
我怎么样在浏览

06:18.140 --> 06:19.140
就是我在浏览器里边

06:19.140 --> 06:20.140
跟服务器之间

06:20.140 --> 06:21.140
要完成通信

06:21.140 --> 06:23.140
它只是这么一个概念

06:23.140 --> 06:25.140
然后我们以前

06:25.140 --> 06:26.140
用的这个对象呢

06:26.140 --> 06:27.140
它只是阿里克斯

06:27.140 --> 06:28.140
一种实现

06:28.140 --> 06:29.140
就是说我要真正把它

06:29.140 --> 06:30.140
实现

06:30.140 --> 06:31.140
实现跟服务器

06:31.140 --> 06:32.140
实现的通信

06:32.140 --> 06:33.140
该怎么去写代吗

06:33.140 --> 06:35.140
该怎么去实现这个阿里克斯

06:35.140 --> 06:37.140
它指的是一种实现

06:37.140 --> 06:38.140
那么现在呢

06:38.140 --> 06:39.140
除了废棘API之后呢

06:39.140 --> 06:40.140
那么我们现在

06:40.140 --> 06:42.140
阿里克斯是不是有两种实现了

06:42.140 --> 06:43.140
一种是使用

06:43.140 --> 06:45.140
以前的那种方式

06:45.140 --> 06:47.140
第二呢是使用这种方式

06:47.140 --> 06:48.140
它不是说取代阿里克斯

06:48.140 --> 06:49.140
阿里克斯是个概念

06:49.140 --> 06:51.140
它没有取代的

06:52.140 --> 06:54.140
那么它只是对阿里克斯的

06:54.140 --> 06:56.140
实现它的API层面

06:56.140 --> 06:58.140
进行的改进

06:58.140 --> 07:00.140
这是第一个要搞清楚的问题

07:00.140 --> 07:01.140
第二个点呢

07:01.140 --> 07:02.140
在废棘API里面

07:02.140 --> 07:04.140
我们在后续介绍的过程中呢

07:04.140 --> 07:05.140
你会发现

07:05.140 --> 07:06.140
废棘API里面呢

07:06.140 --> 07:09.140
它有非常精细的功能分割

07:09.140 --> 07:10.140
它的头部

07:10.140 --> 07:11.140
比方我们

07:11.140 --> 07:12.140
请头部信息

07:12.140 --> 07:13.140
请求头

07:13.140 --> 07:14.140
想应头

07:14.140 --> 07:15.140
还有什么呢

07:15.140 --> 07:16.140
请求信息

07:16.140 --> 07:17.140
想应信息

07:17.140 --> 07:18.140
它们都分布到

07:18.140 --> 07:21.140
不同的对象里面来进行处理的

07:21.140 --> 07:22.140
就是我要得到

07:22.140 --> 07:23.140
创建一个头部

07:23.140 --> 07:24.140
请求头部

07:24.140 --> 07:25.140
那么我们要去

07:25.140 --> 07:26.140
创建一个别的对象

07:26.140 --> 07:27.140
明白的意思吗

07:27.140 --> 07:28.140
它就是个

07:28.140 --> 07:29.140
更加精细的功能分割

07:29.140 --> 07:30.140
那么更加利于

07:30.140 --> 07:31.140
实现一些

07:31.140 --> 07:33.140
复杂的artic是场景

07:33.140 --> 07:34.140
比方说

07:34.140 --> 07:35.140
我们有些请求头

07:35.140 --> 07:36.140
我们可能要通用

07:36.140 --> 07:37.140
对吧 要通用

07:37.140 --> 07:38.140
OK 我就创建一个对象

07:38.140 --> 07:39.140
这个对象

07:39.140 --> 07:40.140
到处可以用

07:40.140 --> 07:41.140
明白的意思吗

07:41.140 --> 07:42.140
我们到处介绍的时候

07:42.140 --> 07:43.140
大家就能够

07:43.140 --> 07:45.140
非常清楚地看到这一点了

07:45.140 --> 07:46.140
第三个特点呢

07:46.140 --> 07:47.140
它使用的

07:47.140 --> 07:48.140
最重要的特点

07:48.140 --> 07:50.140
它使用的是PromiseAPI

07:50.140 --> 07:53.140
因为它跟ES6完全契合

07:53.140 --> 07:54.140
因此

07:54.140 --> 07:55.140
它就更加利于

07:55.140 --> 07:56.140
一不代码的书写

07:56.140 --> 07:58.140
而且我们可以用

07:58.140 --> 08:00.140
ES7的AsyncAwait

08:00.140 --> 08:01.140
对吧

08:01.140 --> 08:02.140
ES7特别是Await

08:02.140 --> 08:04.140
它是专门针对PromiseAPI的

08:04.140 --> 08:05.140
因此我们到时候

08:05.140 --> 08:06.140
用一不场景的话

08:06.140 --> 08:08.140
更加适合使用

08:08.140 --> 08:09.140
FakeAPI

08:09.140 --> 08:10.140
我们不用封装了

08:10.140 --> 08:11.140
就用它这个

08:11.140 --> 08:13.140
都已经完全够用了

08:13.140 --> 08:15.140
第四个呢

08:15.140 --> 08:16.140
FakeAPI

08:16.140 --> 08:17.140
它并非是ES6的内容

08:17.140 --> 08:19.140
这是我要特别强调的

08:19.140 --> 08:20.140
ES6

08:20.140 --> 08:22.140
ES6里面是有一个FakeAPI

08:22.140 --> 08:23.140
不是的

08:23.140 --> 08:24.140
它不是ES6的内容

08:24.140 --> 08:26.140
它属于ATM5新增的

08:27.140 --> 08:29.140
那么这里有几个概念

08:29.140 --> 08:30.140
大家要搞清楚

08:30.140 --> 08:31.140
就拿起个概念

08:31.140 --> 08:32.140
一个是ES6

08:32.140 --> 08:33.140
一个是ATM5

08:33.140 --> 08:34.140
一个是FakeAPI

08:34.140 --> 08:36.140
那么一个是FakeAPI

08:36.140 --> 08:37.140
就这么几个概念

08:37.140 --> 08:38.140
它们的之间的关系

08:38.140 --> 08:39.140
到底是什么

08:39.140 --> 08:41.140
我这里给大家画张图

08:42.140 --> 08:44.140
我这里给大家建一个PBT

08:44.140 --> 08:46.140
画一张图给大家描述一下

08:46.140 --> 08:47.140
其实这种图

08:47.140 --> 08:48.140
我记得我以前画过的

08:48.140 --> 08:49.140
因为我说过

08:49.140 --> 08:50.140
ES

08:50.140 --> 08:51.140
ES是什么呢

08:51.140 --> 08:52.140
ES

08:52.140 --> 08:54.140
它是一个语言标准

08:55.140 --> 08:56.140
光有标准没有实现

08:56.140 --> 08:58.140
这个语言是跑不起来的

08:58.140 --> 09:00.140
所以说它需要在各种环境里边

09:00.140 --> 09:03.140
不同的厂商去把这个语言实现

09:03.140 --> 09:04.140
比方说在瀏覽器里边

09:04.140 --> 09:06.140
像谷歌瀏覽器

09:06.140 --> 09:08.140
它都把这个标准实现了

09:08.140 --> 09:09.140
明白我的意思吗

09:09.140 --> 09:10.140
所以说ES5

09:10.140 --> 09:11.140
ES

09:11.140 --> 09:13.140
它是一个标准

09:13.140 --> 09:16.450
它是一套语言标准

09:16.450 --> 09:17.450
语言标准

09:17.450 --> 09:20.450
它需要在各种环境里边去实现

09:20.450 --> 09:21.450
像我们之前介绍的

09:21.450 --> 09:23.450
什么符号

09:23.450 --> 09:25.450
对象 函数 这些正能表达

09:25.450 --> 09:28.450
是 这些都属于语言标准一边的东西

09:28.450 --> 09:30.450
那么它可以运用在各种环境

09:30.450 --> 09:31.450
比方说

09:31.450 --> 09:32.450
瀏覽器环境

09:32.450 --> 09:33.450
比方说服务器环境

09:33.450 --> 09:34.450
你们以后要学习

09:34.450 --> 09:36.450
比方说手机端环境

09:36.450 --> 09:38.450
比方说什么桌面应用端环境

09:38.450 --> 09:39.450
它可以运用在不同的环境

09:39.450 --> 09:41.450
都可以使用同一套语言

09:41.450 --> 09:43.450
都用同一种方式来说话

09:43.450 --> 09:45.450
这是语言标准

09:45.450 --> 09:47.450
那么我们目前学习的是瀏覽器环境

09:47.450 --> 09:48.450
对吧

09:48.450 --> 09:49.450
瀏覽器环境呢

09:49.450 --> 09:52.450
它就用到了这个对套语言标准

09:53.450 --> 09:55.450
瀏覽器环境

09:55.450 --> 09:58.450
它就用到了这一套语言标准

09:58.450 --> 10:00.450
所以我们瀏覽器环境用的是

10:00.450 --> 10:02.450
用的是这套语言来说话

10:02.450 --> 10:04.450
瀏覽器里边用的这个语言呢

10:04.450 --> 10:05.450
就是夜市语言

10:05.450 --> 10:06.450
但是瀏覽器里边

10:06.450 --> 10:08.450
毕竟有一些特殊的东西

10:08.450 --> 10:10.450
光有这个语言还不够

10:10.450 --> 10:11.450
于是瀏覽器里边

10:11.450 --> 10:13.450
就基于这个语言呢

10:13.450 --> 10:15.450
又开发了一些API

10:15.450 --> 10:17.450
比方说什么DOM

10:17.450 --> 10:18.450
DOM操作对吧

10:18.450 --> 10:19.450
Document对象

10:19.450 --> 10:20.450
Window对象

10:20.450 --> 10:21.450
各种事件对不对

10:21.450 --> 10:24.450
这些都属于瀏覽器环境里边的东西

10:24.450 --> 10:26.450
那么我们把这个瀏覽器环境呢

10:26.450 --> 10:28.450
就是瀏覽器环境

10:28.450 --> 10:30.450
瀏覽器环境下面的这些东西呢

10:30.450 --> 10:33.450
叫把它统称为WebAPI

10:33.450 --> 10:34.450
瀏覽器

10:34.450 --> 10:35.450
那么这里边有哪些呢

10:35.450 --> 10:36.450
那这里边就多了

10:36.450 --> 10:37.450
像什么DOM啊

10:37.450 --> 10:38.450
很多对象

10:38.450 --> 10:40.450
很多事件啊方法对吧

10:40.450 --> 10:43.450
它并没有说改变这个语言的标准

10:43.450 --> 10:44.450
这个语言的标准

10:44.450 --> 10:45.450
还是用了这套标准

10:45.450 --> 10:47.450
它能够适配这个语言标准

10:47.450 --> 10:49.450
只不过它给你新增了一些对象

10:49.450 --> 10:50.450
新增了一些方法

10:51.450 --> 10:52.450
那么起

10:52.450 --> 10:53.450
那么什么叫ATM5呢

10:53.450 --> 10:55.450
ATM5这个版本呢

10:56.450 --> 10:57.450
它是一个版本号

10:57.450 --> 10:58.450
ATM5呢

10:58.450 --> 10:59.450
它是一个版本号

10:59.450 --> 11:00.450
因为API呢

11:00.450 --> 11:02.450
它不断地更新对吧

11:02.450 --> 11:03.450
更新换单

11:03.450 --> 11:04.450
那么ATM5这个API呢

11:04.450 --> 11:06.450
它指的是就是最新

11:06.450 --> 11:07.450
就是目前呢

11:07.450 --> 11:09.450
我们用的最新的这一代的API

11:09.450 --> 11:10.450
它是一个版本号

11:10.450 --> 11:12.450
是WebAPI的版本号

11:12.450 --> 11:14.450
那么在这个版本下边呢

11:14.450 --> 11:16.450
它里边给你新增了很多东西

11:16.450 --> 11:18.450
在瀏覽器环境里边

11:18.450 --> 11:20.450
你比方说什么

11:20.450 --> 11:22.450
像这些东西都是新增的

11:22.450 --> 11:24.450
那么其中有一个东西呢

11:24.450 --> 11:25.450
新增了一个东西呢

11:25.450 --> 11:28.450
就是新增了很多东西

11:28.450 --> 11:30.450
其中有一个东西呢

11:30.450 --> 11:31.450
就包含

11:31.450 --> 11:32.450
包含什么

11:32.450 --> 11:34.450
就是肺起API

11:34.450 --> 11:36.450
所以我们肺起API在这

11:36.450 --> 11:37.450
没了意思吗

11:37.450 --> 11:38.450
我们的肺起API在这

11:38.450 --> 11:40.450
是在瀏覽器环境里边

11:40.450 --> 11:41.450
给你新增的API

11:41.450 --> 11:43.450
因此它不属于ES6的内容

11:43.450 --> 11:45.450
ES6它只管

11:45.450 --> 11:46.450
只管什么呢

11:46.450 --> 11:48.450
只管语言标准

11:48.450 --> 11:50.450
它只管语言标准

11:50.450 --> 11:52.450
ES它只管语言标准

11:52.450 --> 11:54.450
因此它不考虑各种环境里边

11:54.450 --> 11:55.450
什么样

11:55.450 --> 11:56.450
各种环境里边

11:56.450 --> 11:57.450
你没有自己的标准

11:57.450 --> 11:59.450
你自己去设计

11:59.450 --> 12:01.450
所以说我们学习的肺起API

12:01.450 --> 12:03.450
它是属于瀏覽器环境的

12:03.450 --> 12:04.450
这也说明了啥呢

12:04.450 --> 12:06.450
将来你们要学习瘦的环境

12:06.450 --> 12:08.450
要学习手机端环境

12:08.450 --> 12:09.450
那么比方说

12:09.450 --> 12:10.450
你要学到瘦的环境里边

12:10.450 --> 12:12.450
你是不是心里面要翻个

12:12.450 --> 12:14.450
至少得得有一个疑问

12:14.450 --> 12:16.450
肺起能不能在服务器

12:16.450 --> 12:17.450
能不能在服务器那边使用呢

12:17.450 --> 12:19.450
到时候我们肯定会讲

12:19.450 --> 12:20.450
是不能使用的

12:20.450 --> 12:21.450
不能使用的

12:21.450 --> 12:22.450
因为服务器环境里边

12:22.450 --> 12:24.450
它虽然用的是同一套语言标准

12:24.450 --> 12:26.450
但是它里边的

12:26.450 --> 12:27.450
它里边的API

12:27.450 --> 12:29.450
跟你新增的API里边

12:29.450 --> 12:30.450
是不包含肺起的

12:30.450 --> 12:31.450
所以说肺起的API

12:31.450 --> 12:33.450
它只是在瀏覽器环境里边

12:33.450 --> 12:34.450
可以使用

12:34.450 --> 12:35.450
没人意识吗

12:35.450 --> 12:36.450
这里给大家说清楚

12:36.450 --> 12:37.450
我干脆

12:37.450 --> 12:39.450
我也不放了

12:39.450 --> 12:40.450
放到笔记里边了

12:40.450 --> 12:41.450
大家看一下这个图

12:41.450 --> 12:43.450
很好理解

12:43.450 --> 12:44.450
最后呢

12:44.450 --> 12:45.450
我们说一下这一块

12:45.450 --> 12:46.450
学习这一个章节

12:46.450 --> 12:47.450
需要你掌握

12:47.450 --> 12:49.450
网络通信的知识

12:49.450 --> 12:50.450
咱们读一些教育里边

12:50.450 --> 12:52.450
有一个课程就是网络通信

12:52.450 --> 12:54.450
应该你们已经学习过了

12:54.450 --> 12:56.450
你要需要掌握这一块的知识

12:56.450 --> 12:57.450
至少得得知道什么叫

12:57.450 --> 12:58.450
ATP协议

12:58.450 --> 12:59.450
你得知道什么叫

12:59.450 --> 13:01.450
请求头请求体

13:01.450 --> 13:03.450
响应头响应体

13:03.450 --> 13:04.450
你得知道什么

13:04.450 --> 13:06.450
叫那个

13:06.450 --> 13:08.450
就是消息码

13:08.450 --> 13:10.450
200消息码表示什么

13:10.450 --> 13:11.450
404表示什么

13:11.450 --> 13:12.450
500表示什么

13:12.450 --> 13:14.450
你要知道这边一些

13:14.450 --> 13:16.450
基本的网络通信知识

13:16.450 --> 13:17.450
因为我们这一章节

13:17.450 --> 13:19.450
毕竟是讲网络通信的API

13:19.450 --> 13:21.450
所以说你得

13:21.450 --> 13:23.450
有这个网络通信的知识

13:23.450 --> 13:25.450
如果说你

13:25.450 --> 13:26.450
当然我觉得这一块知识

13:26.450 --> 13:27.450
你不太可能

13:27.450 --> 13:28.450
因为平时要用ATP

13:28.450 --> 13:29.450
都需要这一块知识

13:29.450 --> 13:31.450
包括你要调试网络

13:31.450 --> 13:33.450
代码的错误的话

13:33.450 --> 13:35.450
你肯定也要在瀏覽器里边

13:35.450 --> 13:38.450
使用网络模块来进行调试

13:38.450 --> 13:39.450
所以说这一块

13:39.450 --> 13:41.450
你们应该忘不了

13:41.450 --> 13:42.450
如果说你这一块已经忘了

13:42.450 --> 13:43.450
那么你再回过头去

13:43.450 --> 13:45.450
看一下那一块的知识

13:45.450 --> 13:46.450
最后我说一下

13:46.450 --> 13:47.450
这个章节

13:47.450 --> 13:48.450
如果说

13:48.450 --> 13:50.450
假如说你没有学习过网络通信

13:50.450 --> 13:51.450
你都不知道

13:51.450 --> 13:53.450
阿迪克斯到底是啥

13:53.450 --> 13:55.450
那么这一块章节

13:55.450 --> 13:57.450
你目前只能略过

13:57.450 --> 13:59.450
略过这个章节

13:59.450 --> 14:00.450
那么将来你学了

14:00.450 --> 14:02.450
学了就是网络通信之后

14:02.450 --> 14:03.450
你再回过头来看一看

14:03.450 --> 14:05.450
这一个章节的东西

14:05.450 --> 14:06.450
当然这个章节不看

14:06.450 --> 14:07.450
会不会影响到

14:07.450 --> 14:08.450
后续的学习呢

14:08.450 --> 14:09.450
不会

14:09.450 --> 14:10.450
因为我们整个课程

14:10.450 --> 14:12.450
是讲的是一业式

14:12.450 --> 14:14.450
我们这里只是穿插了一个章节

14:14.450 --> 14:16.450
主要是让大家知道

14:16.450 --> 14:18.450
有这么一个废棋API存在

14:18.450 --> 14:20.450
并且你要知道

14:20.450 --> 14:23.450
我们以后在用Promise API的时候

14:23.450 --> 14:26.450
大部分场景

14:26.450 --> 14:28.450
都是在废棋API这里

14:28.450 --> 14:30.450
所以说为了讲解这个东西

14:30.450 --> 14:32.450
给大家穿插一个章节

14:32.450 --> 14:33.450
如果你不学这个章节的话

14:33.450 --> 14:34.450
对后边的一业式学习

14:34.450 --> 14:35.450
没有任何影响

14:35.450 --> 14:36.450
好吧

14:36.450 --> 14:38.450
这里给大家说明一下

14:38.450 --> 14:39.450
这是这里头的内容

