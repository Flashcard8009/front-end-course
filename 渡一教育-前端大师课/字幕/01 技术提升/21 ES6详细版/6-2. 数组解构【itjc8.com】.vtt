WEBVTT

00:00.430 --> 00:03.430
上节课我们讲了对象解构

00:03.430 --> 00:05.430
当时还忘了讲一个点

00:05.430 --> 00:06.430
我们这节课就把它补充进去

00:06.430 --> 00:09.430
一会讲速度解构的时候把它补充进去

00:09.430 --> 00:11.430
这节课我们讲速度的解构

00:11.430 --> 00:14.430
其实不仅是对象可以把它分解出来

00:14.430 --> 00:17.430
速度里边的东西也可以分解出来

00:17.430 --> 00:20.430
这里咱们来举这么一个例子

00:20.430 --> 00:22.430
看速度怎么去分解

00:22.430 --> 00:26.430
首先你要知道速度还本质上的还是对象

00:26.430 --> 00:27.430
它还是一个对象

00:27.430 --> 00:29.430
比方说我们这里一个数组

00:29.430 --> 00:30.430
Numbers

00:30.430 --> 00:31.430
一个数组

00:31.430 --> 00:33.430
比方说随便写一些吧

00:33.430 --> 00:36.430
我们就写字母串

00:36.430 --> 00:40.430
A B C D

00:40.430 --> 00:42.430
有这么四个字母串

00:42.430 --> 00:44.430
然后我们输出一下这个数组吧

00:44.430 --> 00:45.430
输出一下

00:45.430 --> 00:46.430
保存

00:46.430 --> 00:47.430
然后把它一面运出来

00:47.430 --> 00:48.430
你看一下这个数组

00:48.430 --> 00:50.430
其他本质上就是一个对象

00:50.430 --> 00:52.430
这个东西它在你们

00:52.430 --> 00:54.430
基础课程里边都学习过了

00:54.430 --> 00:56.430
你看数组展开过后

00:56.430 --> 00:58.430
属性0

00:58.430 --> 01:00.430
属性0是一个字母串

01:00.430 --> 01:01.430
属性1

01:01.430 --> 01:02.430
属性2

01:02.430 --> 01:03.430
属性3

01:03.430 --> 01:04.430
还有一个属性nance

01:04.430 --> 01:05.430
你看它不就是个对象

01:05.430 --> 01:07.430
所以说你要解构数组的话

01:07.430 --> 01:10.430
你可以按照跟对象一样的方式来解构

01:10.430 --> 01:12.430
比方说我们怎么来解构呢

01:12.430 --> 01:14.430
我们这样解构

01:14.430 --> 01:15.430
Numbers

01:15.430 --> 01:16.430
把它当成对象来解构

01:16.430 --> 01:17.430
怎么解构

01:17.430 --> 01:18.430
我们这里写上0

01:18.430 --> 01:19.430
只不过0

01:19.430 --> 01:21.430
它不能作为辩量名

01:21.430 --> 01:23.430
因为它不是一个合法的标志符

01:23.430 --> 01:25.430
它不能作为辩量名

01:25.430 --> 01:27.430
我们给它换一个辩量名字

01:27.430 --> 01:29.430
辩量名字给它取名为

01:31.430 --> 01:32.430
第1项

01:33.430 --> 01:34.430
n1

01:34.430 --> 01:35.430
1

01:35.430 --> 01:36.430
属性1

01:36.430 --> 01:38.430
给它取名一个辩量名n2

01:38.430 --> 01:40.430
我们输出n1n2

01:40.430 --> 01:41.430
n1n2

01:41.430 --> 01:42.430
输出一下

01:42.430 --> 01:43.430
你看不就是a和b

01:43.430 --> 01:45.430
就是数组的前量项

01:45.430 --> 01:47.430
当然我们这里还可以写个3

01:47.430 --> 01:48.430
下标为3

01:48.430 --> 01:50.430
是不是就把d-fus给它了

01:50.430 --> 01:51.430
a和d

01:51.430 --> 01:53.430
就是你认识到数组的本质的话

01:53.430 --> 01:55.430
解构数组是非常简单的

01:55.430 --> 01:56.430
但是呢

01:56.430 --> 01:57.430
es6呢

01:57.430 --> 01:58.430
它觉得这样子都还麻烦

01:58.430 --> 01:59.430
于是呢

01:59.430 --> 02:01.430
它跟我们出来又来了一个

02:01.430 --> 02:03.430
非常清新拖熟的解构吧

02:03.430 --> 02:04.430
解构方式

02:04.430 --> 02:05.430
它怎么解构呢

02:05.430 --> 02:06.430
它这样解构

02:06.430 --> 02:07.430
你看

02:07.430 --> 02:08.430
上面的代码

02:08.430 --> 02:10.430
跟下面的代码完全等效

02:10.430 --> 02:11.430
你写两个综扩号

02:11.430 --> 02:13.430
表示你这里的解构数组

02:13.430 --> 02:15.430
当然你也可以先定一辆量

02:15.430 --> 02:16.430
然后再分开解构

02:16.430 --> 02:17.430
我们都写一下吧

02:17.430 --> 02:18.430
我们先定一辆量

02:18.430 --> 02:19.430
然后再分开解构

02:19.430 --> 02:20.430
再定一辆量

02:20.430 --> 02:21.430
也不能定一场量了

02:21.430 --> 02:22.430
场量的话

02:22.430 --> 02:23.430
定义的时候就必须复制

02:23.430 --> 02:25.430
比方N1N2

02:25.430 --> 02:26.430
然后呢

02:26.430 --> 02:27.430
我们来解构吧

02:27.430 --> 02:29.430
解构这样解构

02:29.430 --> 02:30.430
对象呢

02:30.430 --> 02:31.430
我们是用大国号解构

02:31.430 --> 02:32.430
那么数组呢

02:32.430 --> 02:33.430
我们是用综扩号

02:33.430 --> 02:35.430
我们要得到数组的前辆

02:35.430 --> 02:37.430
第一项复给N1

02:37.430 --> 02:38.430
第二项复给N2

02:38.430 --> 02:39.430
它就这样子的

02:39.430 --> 02:40.430
它就不是同名属性了

02:40.430 --> 02:41.430
你写的综扩号过后

02:41.430 --> 02:43.430
它就是按照顺序

02:43.430 --> 02:44.430
把数组的值

02:44.430 --> 02:45.430
一次复给变量

02:45.430 --> 02:46.430
你看

02:46.430 --> 02:47.430
是变成这样子的

02:47.430 --> 02:48.430
一样的

02:48.430 --> 02:49.430
对吧

02:49.430 --> 02:51.430
当然你可以完全可以把它写到一起

02:51.430 --> 02:52.430
这个时候呢

02:52.430 --> 02:54.430
我们都是把它写到一起的

02:54.430 --> 02:57.430
N1N2

02:57.430 --> 02:59.430
特别方便

02:59.430 --> 03:01.430
就把前辆相复给复制给变量

03:01.430 --> 03:04.430
N2的值就等于N2B

03:04.430 --> 03:05.430
那如果说

03:05.430 --> 03:06.430
我们要得到

03:06.430 --> 03:08.430
第一项和最后一项的值呢

03:08.430 --> 03:09.430
就第四项的值呢

03:09.430 --> 03:11.430
下边尾三的值呢

03:11.430 --> 03:12.430
那怎么办呢

03:12.430 --> 03:14.430
我们中间就空

03:14.430 --> 03:15.430
就流空

03:15.430 --> 03:16.430
比方说

03:16.430 --> 03:17.430
第一项复制给N1

03:17.430 --> 03:19.430
第二项不管它

03:19.430 --> 03:20.430
第三项我不管它

03:20.430 --> 03:24.430
第四项复制给N4

03:24.430 --> 03:25.430
我们换一个吧

03:25.430 --> 03:28.430
换一个就是文件

03:28.430 --> 03:30.430
中间可看

03:30.430 --> 03:31.430
看着啊

03:31.430 --> 03:33.430
我们第一项复制给N1

03:33.430 --> 03:34.430
第二项流空

03:34.430 --> 03:35.430
第三项流空

03:35.430 --> 03:38.430
第四项复制给N4

03:38.430 --> 03:39.430
你看一下

03:39.430 --> 03:40.430
这样子得到的结果呢

03:40.430 --> 03:42.430
就是A和D

03:42.430 --> 03:43.430
当然那如果说

03:43.430 --> 03:45.430
你给它写到一个不存在的

03:45.430 --> 03:47.430
比方说还有一个N5

03:47.430 --> 03:48.430
N5应该是什么

03:48.430 --> 03:49.430
你觉得应该是什么

03:49.430 --> 03:50.430
Undefend对吧

03:50.430 --> 03:51.430
就是Undefend

03:51.430 --> 03:52.430
能不能复摩认值

03:52.430 --> 03:53.430
当然可以

03:53.430 --> 03:54.430
当然可以

03:54.430 --> 03:56.430
你可以复任何的摩认值

03:56.430 --> 03:57.430
是一样的

03:57.430 --> 03:58.430
是一样的

03:58.430 --> 04:01.430
都是数组的结构对吧

04:01.430 --> 04:02.430
然后呢

04:02.430 --> 04:04.430
数组结构里边呢

04:04.430 --> 04:06.430
也可以进行千套的结构

04:06.430 --> 04:07.430
比方说有千套的数组

04:07.430 --> 04:09.430
或者说千套的对象都行

04:09.430 --> 04:10.430
比方说吧

04:10.430 --> 04:11.430
我举个例子

04:11.430 --> 04:12.430
N10里边呢

04:12.430 --> 04:13.430
还有里边

04:13.430 --> 04:14.430
最后一项

04:14.430 --> 04:15.430
第五项呢

04:15.430 --> 04:17.430
是一个千套的数组

04:17.430 --> 04:18.430
又是一个数组

04:19.430 --> 04:20.430
一

04:20.430 --> 04:21.430
二

04:21.430 --> 04:22.430
三

04:22.430 --> 04:23.430
四

04:23.430 --> 04:24.430
整个数组有几项

04:24.430 --> 04:25.430
整个数组有五项

04:25.430 --> 04:26.430
第1项

04:26.430 --> 04:27.430
第2项

04:27.430 --> 04:28.430
第3项

04:28.430 --> 04:29.430
第4项

04:29.430 --> 04:30.430
第5项

04:30.430 --> 04:31.430
它本身又是个数组

04:31.430 --> 04:32.430
那么比方说

04:32.430 --> 04:33.430
我们要得到这个数

04:33.430 --> 04:34.430
第5

04:34.430 --> 04:35.430
这个数组里边

04:35.430 --> 04:36.430
打出是

04:36.430 --> 04:38.430
得到Nambers

04:38.430 --> 04:40.430
第5项

04:40.430 --> 04:41.430
也就是下标

04:41.430 --> 04:44.430
为4的

04:44.430 --> 04:46.430
数组中的

04:46.430 --> 04:47.430
第

04:47.430 --> 04:48.430
下标

04:48.430 --> 04:50.430
为

04:50.430 --> 04:51.430
2的

04:51.430 --> 04:53.430
数据

04:53.430 --> 04:54.430
放到

04:54.430 --> 04:55.430
变量

04:55.430 --> 04:56.430
N中

04:56.430 --> 04:57.430
我们比方说

04:57.430 --> 04:58.430
要做这么一件事

04:58.430 --> 05:00.430
我们要得到Nambers

05:00.430 --> 05:01.430
下标为4

05:01.430 --> 05:02.430
也就是第5项

05:02.430 --> 05:03.430
第5项

05:03.430 --> 05:04.430
然后它里边

05:04.430 --> 05:05.430
下标为2

05:05.430 --> 05:06.430
就第三项的数据

05:06.430 --> 05:07.430
就把这个东西

05:07.430 --> 05:08.430
放到变量N中

05:08.430 --> 05:09.430
那怎么做呢

05:09.430 --> 05:10.430
我们看着

05:10.430 --> 05:12.430
我们这样的写

05:12.430 --> 05:13.430
第5项怎么写呢

05:13.430 --> 05:14.430
从Nambers里面解构

05:14.430 --> 05:15.430
第5项

05:15.430 --> 05:16.430
前面第1项流空

05:16.430 --> 05:17.430
前面条件里的

05:17.430 --> 05:18.430
指导数有几项

05:18.430 --> 05:19.430
第1项流空

05:19.430 --> 05:20.430
第2项流空

05:20.430 --> 05:21.430
第3项流空

05:21.430 --> 05:22.430
第4项流空

05:22.430 --> 05:24.430
这就是第5项了

05:24.430 --> 05:25.430
第5项了

05:25.430 --> 05:26.430
本身又是个数组

05:26.430 --> 05:27.430
你继续解构

05:27.430 --> 05:28.430
在这里继续解构

05:28.430 --> 05:29.430
解构完了过后

05:29.430 --> 05:30.430
这个解构出来

05:30.430 --> 05:31.430
你要取第几项

05:31.430 --> 05:32.430
下标为第3项

05:32.430 --> 05:33.430
第1项流空

05:33.430 --> 05:34.430
第2项流空

05:34.430 --> 05:35.430
第3项为N

05:35.430 --> 05:36.430
你写一下

05:36.430 --> 05:37.430
输出一下

05:37.430 --> 05:38.430
N

05:38.430 --> 05:39.430
你看N就等于

05:39.430 --> 05:40.430
多少

05:40.430 --> 05:41.430
N就等于N

05:41.430 --> 05:42.430
等于N

05:42.430 --> 05:43.430
下标为N

05:43.430 --> 05:45.430
你可以这样子写

05:45.430 --> 05:46.430
没问题吧

05:46.430 --> 05:47.430
如果说

05:47.430 --> 05:49.430
这里边还有对相怎么办

05:49.430 --> 05:50.430
比方说

05:50.430 --> 05:51.430
最后一项

05:51.430 --> 05:52.430
它是一个对相

05:52.430 --> 05:54.430
它是一个对相

05:54.430 --> 05:55.430
这个对相里边

05:55.430 --> 05:57.430
又有A等于1

05:57.430 --> 05:58.430
B等于2

05:58.430 --> 06:00.430
是一样的

06:00.430 --> 06:01.430
比方说

06:01.430 --> 06:02.430
我们要得到

06:02.430 --> 06:05.430
得到Nambers

06:05.430 --> 06:07.430
下标

06:07.430 --> 06:10.430
下标为

06:10.430 --> 06:12.430
4的数组

06:12.430 --> 06:14.430
数项A

06:14.430 --> 06:16.430
负值给

06:16.430 --> 06:18.430
辨量

06:18.430 --> 06:19.430
辨量大写的A

06:19.430 --> 06:20.430
要换个名字

06:20.430 --> 06:21.430
换个名字

06:21.430 --> 06:22.430
我们先去辨量A

06:22.430 --> 06:23.430
负值给辨量A

06:23.430 --> 06:24.430
先同一个名字

06:24.430 --> 06:26.430
那怎么来解构呢

06:26.430 --> 06:27.430
你看着

06:27.430 --> 06:28.430
怎么来解构

06:28.430 --> 06:29.430
解构

06:29.430 --> 06:30.430
它是一个数组

06:30.430 --> 06:31.430
我们肯定要用

06:31.430 --> 06:32.430
数组的方式来解构

06:32.430 --> 06:33.430
取刷最后一项

06:33.430 --> 06:34.430
最后一项

06:34.430 --> 06:35.430
第1项流空

06:35.430 --> 06:36.430
第2项

06:36.430 --> 06:37.430
第3项

06:37.430 --> 06:38.430
第5项

06:38.430 --> 06:39.430
是一个对相

06:39.430 --> 06:40.430
要用对相的解构方式

06:40.430 --> 06:41.430
把对相解开

06:41.430 --> 06:42.430
对相是不是用

06:42.430 --> 06:43.430
大过号来解构

06:43.430 --> 06:44.430
对吧

06:44.430 --> 06:45.430
用大过号

06:45.430 --> 06:46.430
把这个地方解开

06:46.430 --> 06:47.430
解开里面取什么

06:47.430 --> 06:48.430
数项A

06:48.430 --> 06:49.430
就这样

06:49.430 --> 06:50.430
输出A

06:50.430 --> 06:51.430
当然这种解放

06:51.430 --> 06:52.430
我们平时开发

06:52.430 --> 06:53.430
用的少一点

06:53.430 --> 06:54.430
只是通过这种

06:54.430 --> 06:55.430
我给大家讲这个语法

06:55.430 --> 06:56.430
是不是输出A

06:56.430 --> 06:57.430
对吧

06:57.430 --> 06:58.430
输出A这个数项

06:58.430 --> 06:59.430
好

06:59.430 --> 07:00.430
如果说你要换成

07:00.430 --> 07:01.430
大写的辨量A

07:01.430 --> 07:03.430
换成大写的辨量A

07:03.430 --> 07:04.430
你是不是

07:04.430 --> 07:05.430
一样的

07:05.430 --> 07:06.430
一样的

07:06.430 --> 07:07.430
大写的辨量A

07:07.430 --> 07:08.430
那么小写的A

07:08.430 --> 07:09.430
不存在了

07:09.430 --> 07:10.430
小写的A不存在了

07:10.430 --> 07:11.430
变成大写的A了

07:11.430 --> 07:12.430
就这么简单

07:12.430 --> 07:13.430
哪有复杂的

07:13.430 --> 07:14.430
对不对

07:14.430 --> 07:15.430
好

07:15.430 --> 07:16.430
就这个

07:16.430 --> 07:18.430
然后我再说一下

07:18.430 --> 07:19.430
能不能这样子写呢

07:19.430 --> 07:20.430
你看着

07:20.430 --> 07:21.430
这个写法很灵活的

07:21.430 --> 07:23.430
能不能这样子写呢

07:23.430 --> 07:24.430
Number 4

07:24.430 --> 07:25.430
下标为4

07:25.430 --> 07:26.430
能不能这样子写

07:26.430 --> 07:27.430
然后我们在这里写上

07:27.430 --> 07:28.430
一个A

07:28.430 --> 07:29.430
能不能这样子写

07:29.430 --> 07:31.430
也可以有什么问题呢

07:31.430 --> 07:32.430
你看一下

07:32.430 --> 07:33.430
右边

07:33.430 --> 07:34.430
右边是不是

07:34.430 --> 07:35.430
把这个对相读出来了

07:35.430 --> 07:36.430
对吧

07:36.430 --> 07:37.430
这个表达是

07:37.430 --> 07:38.430
出来了

07:38.430 --> 07:39.430
咱们把这个对相

07:39.430 --> 07:40.430
右边是可以防表达式的

07:40.430 --> 07:41.430
任何表达式都可以

07:41.430 --> 07:42.430
只要你是数组

07:42.430 --> 07:43.430
只要你是对象

07:43.430 --> 07:44.430
那么前面就可以

07:44.430 --> 07:45.430
进行相应的结构

07:45.430 --> 07:46.430
那么我们后边

07:46.430 --> 07:47.430
能不能是不是

07:47.430 --> 07:48.430
可以放那个

07:48.430 --> 07:49.430
表达式

07:49.430 --> 07:50.430
我们把一个第4项

07:50.430 --> 07:51.430
下标为4的

07:51.430 --> 07:52.430
读出来就第5项

07:52.430 --> 07:53.430
读出来是不是个对象

07:53.430 --> 07:54.430
然后我们用对象的方式

07:54.430 --> 07:55.430
把对象解开

07:55.430 --> 07:57.430
读出他的属性A

07:57.430 --> 07:59.430
就是方式有很灵活的方式

07:59.430 --> 08:01.430
这就是数组的结构

08:01.430 --> 08:02.430
好

08:02.430 --> 08:03.430
那么这里呢

08:03.430 --> 08:04.430
我刚才说

08:04.430 --> 08:05.430
要补充一个点

08:05.430 --> 08:06.430
补充一个点是什么呢

08:07.430 --> 08:09.430
生于象的结构

08:09.430 --> 08:10.430
对于生于象的结构

08:10.430 --> 08:12.430
那么这里再补充一个

08:12.430 --> 08:13.430
之前呢

08:13.430 --> 08:14.430
我们比较说

08:14.430 --> 08:15.430
写了一个对象

08:15.430 --> 08:17.430
我们把之前的对象拿过来吧

08:17.430 --> 08:19.430
之前的对象拿过来

08:20.430 --> 08:23.430
我们要做这么一件事

08:23.430 --> 08:26.430
关闭到右侧

08:26.430 --> 08:28.430
比方我们要做这么一件事

08:28.430 --> 08:30.430
解构出

08:30.430 --> 08:32.430
Name

08:32.430 --> 08:34.430
把Name放到变量里面

08:34.430 --> 08:35.430
变到Name里面

08:35.430 --> 08:40.430
然后生于的所有属性

08:40.430 --> 08:43.430
放到一个新的对象中

08:43.430 --> 08:45.430
放到一个新的对象中

08:45.430 --> 08:49.430
变量名为OB界

08:49.430 --> 08:51.430
就是我们最重要的结构就是

08:51.430 --> 08:53.430
Name属性为啥呢

08:53.430 --> 08:55.430
为Kevin

08:55.430 --> 08:56.430
其他的OB界为啥呢

08:56.430 --> 08:57.430
为这么一个对象

08:57.430 --> 08:59.430
对象里面A级等于11

08:59.430 --> 09:01.430
SX等于男

09:01.430 --> 09:02.430
然后呢

09:02.430 --> 09:03.430
而最实又是个对象

09:03.430 --> 09:04.430
它就是没有Name属性值

09:04.430 --> 09:05.430
原来的意思吧

09:05.430 --> 09:07.430
我们要得到这么一个东西

09:07.430 --> 09:08.430
那怎么做呢

09:08.430 --> 09:10.430
看着我们可以这样子来写

09:10.430 --> 09:11.430
结构

09:11.430 --> 09:13.430
Name属性

09:13.430 --> 09:15.430
把它赌到变量Name里面

09:15.430 --> 09:16.430
那么剩下的

09:16.430 --> 09:17.430
剩下怎么办呢

09:17.430 --> 09:19.430
用展开运算符

09:19.430 --> 09:20.430
三个点

09:20.430 --> 09:21.430
展开运算符

09:21.430 --> 09:22.430
因为上一课为什么没说呢

09:22.430 --> 09:23.430
因为我好像

09:23.430 --> 09:24.430
我感觉是

09:24.430 --> 09:25.430
展开运算符那一块讲了

09:25.430 --> 09:27.430
但是后来想不对一下

09:27.430 --> 09:28.430
那个时候还没有讲结构

09:28.430 --> 09:30.430
我这里把它补充进来

09:30.430 --> 09:31.430
用展开运算符

09:31.430 --> 09:33.430
后面写上变量名OB界

09:33.430 --> 09:34.430
这样子的就是什么意思呢

09:34.430 --> 09:35.430
它就是

09:35.430 --> 09:37.430
把U字里面的Name属性

09:37.430 --> 09:38.430
提出来放到这里

09:38.430 --> 09:39.430
然后呢

09:39.430 --> 09:40.430
把剩下的所有属性

09:40.430 --> 09:41.430
组装成一个对象

09:41.430 --> 09:42.430
放到OB界里面

09:42.430 --> 09:43.430
就形成这么一个结构

09:43.430 --> 09:44.430
Name

09:44.430 --> 09:45.430
OB界

09:45.430 --> 09:46.430
看一下吧

09:46.430 --> 09:47.430
你看Names

09:47.430 --> 09:48.430
OB界里面

09:48.430 --> 09:49.430
除了Name属性的

09:49.430 --> 09:50.430
所有生育的东西

09:50.430 --> 09:52.430
就是解构生育象

09:52.430 --> 09:53.430
用展开运算符

09:53.430 --> 09:54.430
那么展开运算符

09:54.430 --> 09:55.430
在这个位置

09:55.430 --> 09:56.430
它起一个收集的作用

09:56.430 --> 09:57.430
它收集什么

09:57.430 --> 09:59.430
收集生育的信息

09:59.430 --> 10:01.430
就这么个意思

10:02.430 --> 10:03.430
那对于数组而言

10:03.430 --> 10:04.430
其实是一样的

10:04.430 --> 10:05.430
比方说我们这里

10:05.430 --> 10:06.430
再来一个数组

10:08.430 --> 10:09.430
Lambors吧

10:09.430 --> 10:10.430
Lambors

10:10.430 --> 10:11.430
为什么要写字无错呢

10:11.430 --> 10:12.430
我也不知道

10:14.430 --> 10:15.430
写上这么一个数字

10:15.430 --> 10:16.430
我们希望

10:16.430 --> 10:18.430
解构出这个数组的

10:18.430 --> 10:20.430
前两项

10:20.430 --> 10:21.430
然后呢

10:21.430 --> 10:22.430
再把这个数组的

10:22.430 --> 10:23.430
生育的东西

10:23.430 --> 10:24.430
放到一个新数组里面

10:24.430 --> 10:25.430
就是得到

10:25.430 --> 10:26.430
数组

10:26.430 --> 10:27.430
数组

10:27.430 --> 10:29.430
前两项

10:29.430 --> 10:30.430
分别放到

10:30.430 --> 10:32.430
放到变量

10:32.430 --> 10:34.430
A和B中

10:34.430 --> 10:36.430
然后生育的

10:36.430 --> 10:38.430
所有数据

10:38.430 --> 10:40.430
放到数组

10:41.430 --> 10:42.430
放到数组Lambors

10:42.430 --> 10:43.430
怎么办

10:43.430 --> 10:44.430
放到这里面

10:44.430 --> 10:45.430
那怎么做呢

10:45.430 --> 10:46.430
数组解构

10:46.430 --> 10:47.430
数组解构

10:47.430 --> 10:48.430
来吧

10:50.430 --> 10:51.430
Lambors

10:52.430 --> 10:53.430
那么我们把

10:53.430 --> 10:55.430
第一项放到A里面

10:55.430 --> 10:56.430
第一项放到A里面

10:56.430 --> 10:58.430
第二项放到B里面

10:58.430 --> 10:59.430
生育的项

10:59.430 --> 11:00.430
展开渔少安符

11:00.430 --> 11:01.430
放到Lambors里面

11:01.430 --> 11:02.430
一句话就写完了

11:02.430 --> 11:03.430
AB

11:03.430 --> 11:04.430
Lambors

11:05.430 --> 11:06.430
输出

11:06.430 --> 11:07.430
看一下

11:09.430 --> 11:10.430
写错了吗

11:12.430 --> 11:14.430
他说Lambors is not defend

11:14.430 --> 11:15.430
这写错了

11:15.430 --> 11:16.430
名字写错了

11:17.430 --> 11:18.430
你看

11:18.430 --> 11:19.430
前两项解构出来

11:19.430 --> 11:20.430
生育的放到数组里面

11:20.430 --> 11:21.430
对不对

11:21.430 --> 11:22.430
但有些东西说

11:22.430 --> 11:23.430
那我能不能这样子呢

11:23.430 --> 11:25.430
我把中间的这一块

11:26.430 --> 11:27.430
中间的这一块

11:27.430 --> 11:28.430
拿出来

11:28.430 --> 11:30.430
然后前边放一个数组

11:30.430 --> 11:31.430
后边放一个数组

11:31.430 --> 11:32.430
可不可以呢

11:32.430 --> 11:33.430
那咱们来试一下呗

11:33.430 --> 11:34.430
再试一下

11:35.430 --> 11:36.430
来吧

11:36.430 --> 11:37.430
就是什么意思呢

11:38.430 --> 11:39.430
把数组

11:39.430 --> 11:40.430
我们就直接先写吧

11:40.430 --> 11:41.430
先写写出来

11:42.430 --> 11:44.430
就前边那是一个生育项

11:44.430 --> 11:45.430
不要说前边

11:45.430 --> 11:46.430
是一个生育项

11:46.430 --> 11:47.430
Lambors

11:47.430 --> 11:48.430
一

11:48.430 --> 11:50.430
中间是一个A

11:50.430 --> 11:51.430
后边那是一个生育项

11:51.430 --> 11:52.430
Lambors

11:52.430 --> 11:53.430
二

11:53.430 --> 11:54.430
看一下行不行吧

11:54.430 --> 11:55.430
你觉得行不行

11:55.430 --> 11:56.430
那么我们这里输出Lambors

11:56.430 --> 11:57.430
一

11:57.430 --> 11:58.430
A

11:58.430 --> 11:59.430
和Lambors

12:00.430 --> 12:01.430
来看一下

12:01.430 --> 12:02.430
它什么

12:02.430 --> 12:03.430
Rest element

12:03.430 --> 12:05.430
Must be last element

12:05.430 --> 12:06.430
就是个生育的

12:06.430 --> 12:07.430
生育项的解构呢

12:07.430 --> 12:09.430
还必须是最后一个

12:09.430 --> 12:10.430
也就不可能

12:10.430 --> 12:11.430
不可能有多个

12:11.430 --> 12:12.430
为什么呢

12:12.430 --> 12:13.430
它怎么知道

12:13.430 --> 12:14.430
前面要解构两个

12:14.430 --> 12:15.430
放到这个数组里面了

12:15.430 --> 12:16.430
它要把中间这个放到A了

12:16.430 --> 12:17.430
它不知道

12:17.430 --> 12:18.430
对吧

12:18.430 --> 12:19.430
它不知道的

12:19.430 --> 12:20.430
所以说这个逻辑上说不通

12:20.430 --> 12:21.430
不能用这种方式

12:22.430 --> 12:24.430
这是关于解构这一块

12:24.430 --> 12:25.430
其实这一块

12:25.430 --> 12:26.430
以前的代码能不能实现的

12:26.430 --> 12:27.430
也可以实现

12:27.430 --> 12:28.430
只不过呢

12:28.430 --> 12:29.430
特别特别的麻烦

12:29.430 --> 12:30.430
以前代码得怎么写呢

12:30.430 --> 12:32.430
以前代码得这样子写

12:32.430 --> 12:33.430
A等于Lambors

12:33.430 --> 12:34.430
Lambors 0

12:34.430 --> 12:35.430
对吧

12:35.430 --> 12:36.430
然后呢

12:36.430 --> 12:38.430
B等于Lambors

12:38.430 --> 12:39.430
E

12:39.430 --> 12:40.430
然后Lambors

12:40.430 --> 12:42.430
等于什么Lambors

12:42.430 --> 12:43.430
Sness

12:43.430 --> 12:44.430
R

12:44.430 --> 12:45.430
对不对

12:45.430 --> 12:46.430
以前是不是得这么写

12:46.430 --> 12:47.430
这么写的时候效果是一样的

12:47.430 --> 12:48.430
对吧

12:48.430 --> 12:49.430
效果是完全一样的

12:49.430 --> 12:50.430
现在用解构的方式

12:50.430 --> 12:51.430
是不是心疼很多了

12:51.430 --> 12:52.430
对吧

12:52.430 --> 12:53.430
好

12:53.430 --> 12:54.430
这是关于这一块

12:54.430 --> 12:55.430
这一块

12:55.430 --> 12:56.430
然后呢

12:56.430 --> 12:57.430
我们这里呢

12:57.430 --> 12:59.430
说一道很有意思的例子

12:59.430 --> 13:00.430
也不是一道题

13:00.430 --> 13:01.430
就是一个很有意思的例子

13:01.430 --> 13:02.430
就是说

13:02.430 --> 13:04.430
我们如果说

13:04.430 --> 13:06.430
想要交换两个变量

13:06.430 --> 13:07.430
A

13:08.430 --> 13:09.430
等于B

13:09.430 --> 13:10.430
B等于2

13:10.430 --> 13:11.430
我们想交换两个变量

13:11.430 --> 13:12.430
以前怎么写的

13:12.430 --> 13:13.430
是不是要借助第三个变量

13:13.430 --> 13:14.430
或者说

13:14.430 --> 13:15.430
你用一些取消的办法

13:15.430 --> 13:16.430
都可以实现

13:16.430 --> 13:18.430
那么现在学到解构之后呢

13:18.430 --> 13:19.430
我们还有一种实现办法

13:19.430 --> 13:20.430
还有什么实现办法呢

13:20.430 --> 13:22.430
我们这里要用列子

13:22.430 --> 13:24.430
既然交换肯定要改变量的名

13:24.430 --> 13:25.430
变量的值

13:25.430 --> 13:26.430
好

13:26.430 --> 13:28.430
我们现在还有这种实现方式

13:28.430 --> 13:29.430
看着啊

13:29.430 --> 13:33.660
怎么实现

13:33.660 --> 13:34.660
这样子去

13:34.660 --> 13:35.660
为什么现在不加括号了

13:35.660 --> 13:36.660
因为

13:36.660 --> 13:37.660
它是中括号

13:37.660 --> 13:38.660
中括号的话

13:38.660 --> 13:41.660
它只能把它整个理解成语句

13:41.660 --> 13:42.660
那么我们输出

13:42.660 --> 13:43.660
A和B

13:43.660 --> 13:44.660
一看

13:44.660 --> 13:45.660
两个变量就交换了

13:45.660 --> 13:46.660
A等于2

13:46.660 --> 13:47.660
B等于1

13:47.660 --> 13:48.660
看没

13:48.660 --> 13:49.660
怎么回事呢

13:49.660 --> 13:50.660
我们来分析一下啊

13:50.660 --> 13:51.660
这样

13:51.660 --> 13:52.660
我们首先

13:52.660 --> 13:53.660
右边看右边

13:53.660 --> 13:54.660
右边是我们组成了一个输出

13:54.660 --> 13:55.660
对吧

13:55.660 --> 13:56.660
是不是组成了一个输出

13:56.660 --> 13:57.660
把A和B组成了一个输出

13:57.660 --> 13:58.660
组成了一个输出

13:58.660 --> 13:59.660
输出的里边是不是

13:59.660 --> 14:00.660
这里是1

14:00.660 --> 14:01.660
这里是2

14:01.660 --> 14:02.660
对吧

14:02.660 --> 14:03.660
是不是形成这么一个输出

14:03.660 --> 14:04.660
没问题吧

14:04.660 --> 14:05.660
对不对

14:05.660 --> 14:06.660
我们是不是形成了这么一个输出

14:06.660 --> 14:08.660
然后左边来进行解构

14:08.660 --> 14:09.660
把这个输出里边的

14:09.660 --> 14:10.660
值

14:10.660 --> 14:11.660
第一个向负值给B

14:11.660 --> 14:13.660
第二个向负值给A

14:13.660 --> 14:14.660
就完成了

14:14.660 --> 14:15.660
就这么简单

14:15.660 --> 14:16.660
一下就完成了

14:16.660 --> 14:17.660
那么明白吧

14:17.660 --> 14:18.660
我们先把A和B

14:18.660 --> 14:19.660
组成一个输出

14:19.660 --> 14:20.660
然后把这个输出解构

14:20.660 --> 14:21.660
解构出来呢

14:21.660 --> 14:23.660
用反方向来进行放置

14:23.660 --> 14:24.660
把他们第一项放负值给B

14:24.660 --> 14:26.660
第二项放负值给A

14:26.660 --> 14:27.660
由于输出的

14:27.660 --> 14:28.660
以前的第一项是A

14:28.660 --> 14:30.660
那么B就变成A了

14:30.660 --> 14:31.660
第二项以前是B

14:31.660 --> 14:33.660
A就变成B了

14:33.660 --> 14:34.660
用这种方式呢

14:34.660 --> 14:35.660
也可以实现

14:35.660 --> 14:36.660
其中实现两个

14:36.660 --> 14:37.660
辩量的交换

14:37.660 --> 14:38.660
好了

14:38.660 --> 14:39.660
最后呢

14:39.660 --> 14:40.660
我们能讲一讲那个

14:40.660 --> 14:41.660
开道题吧

14:41.660 --> 14:42.660
开道题

14:42.660 --> 14:43.660
主要上来练习一下

14:43.660 --> 14:44.660
其实我们实际开发中

14:44.660 --> 14:46.660
不会遇到这么复杂的解构

14:46.660 --> 14:47.660
这都是比较

14:47.660 --> 14:48.660
非常非常简单的解构

14:48.660 --> 14:50.660
那我们来看一下这道题吧

14:50.660 --> 14:51.660
这里有个对象

14:51.660 --> 14:52.660
文章

14:52.660 --> 14:53.660
文章标题

14:53.660 --> 14:54.660
文章内容

14:54.660 --> 14:55.660
这是文章的评论

14:55.660 --> 14:56.660
评论有很多

14:56.660 --> 14:57.660
所以说它是一个数组

14:57.660 --> 14:58.660
好 数组里边呢

14:58.660 --> 14:59.660
我们有两个对象

14:59.660 --> 15:00.660
有两个对象

15:00.660 --> 15:01.660
每一条评论就是个对象

15:01.660 --> 15:02.660
评论里面呢

15:02.660 --> 15:03.660
又有一些东西

15:03.660 --> 15:04.660
每一个评论里面呢

15:04.660 --> 15:05.660
有评论内容

15:05.660 --> 15:07.660
有评论的用户是谁评论的

15:07.660 --> 15:08.660
用户的又是个对象

15:08.660 --> 15:09.660
用户有ID

15:09.660 --> 15:10.660
有Name

15:10.660 --> 15:12.660
好 那么这里呢

15:12.660 --> 15:13.660
contents

15:13.660 --> 15:14.660
评论2

15:14.660 --> 15:15.660
也是一条评论

15:15.660 --> 15:16.660
用户的ID

15:16.660 --> 15:17.660
用户的Name

15:17.660 --> 15:19.660
那么现在要求你做什么呢

15:19.660 --> 15:20.660
要求你解构出

15:20.660 --> 15:22.660
第二条评论的

15:22.660 --> 15:23.660
用户名和评论内容

15:23.660 --> 15:24.660
就是我们要解构出

15:24.660 --> 15:25.660
这么两个东西

15:25.660 --> 15:27.660
一个是Name

15:27.660 --> 15:28.660
是什么呢

15:28.660 --> 15:29.660
一个是Name

15:29.660 --> 15:30.660
是

15:31.660 --> 15:32.660
用户名2

15:32.660 --> 15:33.660
对吧

15:33.660 --> 15:34.660
我们把一个用户的名字

15:34.660 --> 15:35.660
要解构出来

15:35.660 --> 15:36.660
然后呢

15:36.660 --> 15:37.660
内容是评论2

15:37.660 --> 15:38.660
就是我们要得到

15:38.660 --> 15:39.660
这么两个辩量

15:39.660 --> 15:40.660
那怎么来动动呢

15:40.660 --> 15:42.660
来吧 解构呗

15:42.660 --> 15:44.660
首先整个这个article

15:44.660 --> 15:46.660
是不是一个对象

15:46.660 --> 15:47.660
对吧

15:47.660 --> 15:48.660
是不是一个article

15:48.660 --> 15:49.660
是不是个对象

15:49.660 --> 15:50.660
诶 这个对象

15:50.660 --> 15:51.660
里边呢

15:51.660 --> 15:52.660
是不是可以进行解构

15:52.660 --> 15:53.660
对这个对象解构

15:53.660 --> 15:54.660
我们解构啥

15:54.660 --> 15:55.660
是不是解构comments

15:55.660 --> 15:56.660
这个属性

15:56.660 --> 15:57.660
但是我们要的

15:57.660 --> 15:58.660
并不是这个属性本身

15:58.660 --> 15:59.660
我们是要

15:59.660 --> 16:00.660
它里边的东西

16:00.660 --> 16:01.660
诶 这个comments

16:01.660 --> 16:02.660
是啥呢

16:02.660 --> 16:03.660
是不是一个数组

16:03.660 --> 16:04.660
OK 我们对这个数组

16:04.660 --> 16:05.660
进一步进行解构

16:05.660 --> 16:06.660
对吧

16:06.660 --> 16:07.660
我们之前说

16:07.660 --> 16:08.660
如果说它这个对象的话

16:08.660 --> 16:09.660
我们可以写大括号

16:09.660 --> 16:10.660
对它进行解构

16:10.660 --> 16:11.660
那么现在它是数组

16:11.660 --> 16:12.660
是不是用中括号

16:12.660 --> 16:13.660
进行解构

16:13.660 --> 16:15.660
对这个comments进一步解构

16:15.660 --> 16:16.660
它这个数组里面有两项

16:16.660 --> 16:17.660
我们要得到

16:17.660 --> 16:18.660
第二项

16:18.660 --> 16:19.660
是不是第一项有空

16:19.660 --> 16:21.660
那么第二项是什么呢

16:21.660 --> 16:22.660
第二项是一个对象

16:22.660 --> 16:23.660
我们要

16:23.660 --> 16:24.660
是不是在对这个对象进一步解构

16:24.660 --> 16:25.660
对吧

16:25.660 --> 16:27.660
对这个对象进一步解构

16:27.660 --> 16:28.660
好 这个对象里边

16:28.660 --> 16:30.660
我们要解构出contents

16:30.660 --> 16:32.660
解构出contents

16:32.660 --> 16:33.660
好

16:33.660 --> 16:34.660
然后呢

16:34.660 --> 16:35.660
我们还要解构出什么呢

16:35.660 --> 16:36.660
用户

16:36.660 --> 16:38.660
就由着属性里边的name属性

16:38.660 --> 16:39.660
所以说我们这里

16:39.660 --> 16:41.660
是不是对由着属性进一步解构

16:41.660 --> 16:42.660
解构出name属性

16:42.660 --> 16:43.660
那你看一下这个代码

16:43.660 --> 16:44.660
我们

16:44.660 --> 16:45.660
读

16:45.660 --> 16:46.660
有的同学可能觉得

16:46.660 --> 16:47.660
读啊这个代码

16:47.660 --> 16:48.660
其实很好读

16:49.660 --> 16:50.660
我要

16:50.660 --> 16:52.660
我要把对象里边取出什么呢

16:52.660 --> 16:53.660
它是个对象

16:53.660 --> 16:55.660
我要从comments属性里边

16:55.660 --> 16:59.660
取出数组的第二项的东西里边的contents

16:59.660 --> 17:01.660
并且对象里边

17:01.660 --> 17:04.660
我们要从u热对象里边的取出name

17:04.660 --> 17:05.660
对吧

17:05.660 --> 17:06.660
它形成这么一种结构了

17:06.660 --> 17:09.660
我们这里输出contents name

17:09.660 --> 17:10.660
好 保存

17:10.660 --> 17:11.660
你看

17:11.660 --> 17:12.660
我们作业题

17:12.660 --> 17:13.660
运行这个

17:13.660 --> 17:16.620
诶

17:16.620 --> 17:17.620
看远那么干嘛

17:17.620 --> 17:18.620
检查

17:19.620 --> 17:20.620
你看是哪道了

17:20.620 --> 17:21.620
对吧

17:21.620 --> 17:23.620
评论2用户名

17:24.620 --> 17:25.620
那问题吧

17:25.620 --> 17:26.620
这就是解构

17:26.620 --> 17:29.620
当然平时我们写代码的时候

17:29.620 --> 17:31.620
不太会写这么复杂的结构

17:31.620 --> 17:34.620
但这种写法有很多

17:34.620 --> 17:35.620
比方说有同学说

17:35.620 --> 17:36.620
看着很恼火

17:36.620 --> 17:37.620
然后我们能不能这样子写呢

17:37.620 --> 17:38.620
看着

17:39.620 --> 17:42.620
artic comments

17:42.620 --> 17:44.620
在这里直接进行解构数组

17:44.620 --> 17:45.620
可不可以呢

17:45.620 --> 17:46.620
第一项

17:46.620 --> 17:48.620
保证把后边的复制过来

17:48.620 --> 17:51.620
contents user name

17:51.620 --> 17:52.620
这样子写可不可以呢

17:52.620 --> 17:53.620
也没问题

17:53.620 --> 17:54.620
也没问题

17:54.620 --> 17:55.620
因为我们这里

17:55.620 --> 17:56.620
是不是直接达到数组了

17:56.620 --> 17:58.620
然后直接对数组进行解构

17:58.620 --> 18:00.620
那比方说我们还可以写

18:00.620 --> 18:01.620
怎么写都行

18:01.620 --> 18:03.620
你只要理解它的原理

18:03.620 --> 18:04.620
比方说

18:04.620 --> 18:05.620
我们这样子写

18:06.620 --> 18:09.620
article comments

18:09.620 --> 18:11.620
取它的下标为1

18:11.620 --> 18:12.620
是不是第二项

18:12.620 --> 18:13.620
第二项是不是个对象

18:13.620 --> 18:16.620
直接在这里解构对象

18:16.620 --> 18:19.620
contents user name

18:19.620 --> 18:20.620
是不是也可以

18:20.620 --> 18:21.620
对吧

18:21.620 --> 18:23.620
有很多很多写法都可以写

18:23.620 --> 18:24.620
没问题吧

18:24.620 --> 18:26.620
这东西不要看着简单

18:26.620 --> 18:27.620
你下来还是要去练一下

18:27.620 --> 18:28.620
就是我们这些例子

18:28.620 --> 18:29.620
特别这个作业题

18:29.620 --> 18:31.620
你好好去练一下

18:31.620 --> 18:32.620
感受一下这种结构的

18:32.620 --> 18:34.620
这种语法格式

18:34.620 --> 18:36.620
这就是数组结构

18:36.620 --> 18:37.620
就补充了一下

18:37.620 --> 18:38.620
上级课没提到的就是

18:38.620 --> 18:39.620
生鱼

18:39.620 --> 18:40.620
生鱼的就是

18:40.620 --> 18:42.620
生鱼箱的收集

18:42.620 --> 18:43.620
OK

18:43.620 --> 18:45.620
这是关于数组的结构

