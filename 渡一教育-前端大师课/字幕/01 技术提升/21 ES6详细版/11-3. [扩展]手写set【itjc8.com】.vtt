WEBVTT

00:00.500 --> 00:04.500
这些课呢 我带大家手写一下这个set集合

00:04.500 --> 00:06.500
就我们自己用介式实现

00:06.500 --> 00:08.500
就哪怕ES6没有给我们提供set集合

00:08.500 --> 00:10.500
我们其实呢 自己也可以实现的

00:10.500 --> 00:13.500
只不过呢 我们这些课写 手写的set呢

00:13.500 --> 00:15.500
要说跟它那个浏览器里面

00:15.500 --> 00:17.500
给我们提供的这个set来对比的话

00:17.500 --> 00:19.500
那肯定不一样

00:19.500 --> 00:22.500
为什么呢 因为浏览器在实现ES标准的时候呢

00:22.500 --> 00:24.500
它是能够调容底层资源的

00:24.500 --> 00:26.500
就是它能直接操作内存的

00:26.500 --> 00:28.500
它的效率呢 肯定要比我们高一些

00:28.500 --> 00:31.500
只不过呢 我们通过这个圆骂分析

00:31.500 --> 00:33.500
比如说我们手写圆骂呢

00:33.500 --> 00:35.500
能够开拓大家的视野

00:35.500 --> 00:37.500
给大家提供一些程序上的思维

00:37.500 --> 00:39.500
仅仅是起这么一个作用

00:39.500 --> 00:42.500
大概要跟那个底层浏览器里边写的set

00:42.500 --> 00:44.500
肯定是不一样的

00:44.500 --> 00:46.500
这里呢 我们手写个set

00:46.500 --> 00:49.500
功能实现 功能肯定要全部实现

00:49.500 --> 00:51.500
给它取个名字叫myset

00:51.500 --> 00:54.500
能够实现一样的功能

00:54.500 --> 00:56.500
我们这里呢 建立一个页面

00:56.500 --> 00:58.500
比较test

00:58.500 --> 01:00.500
来测试一下我们的set集合

01:00.500 --> 01:06.500
script 这里myset

01:06.500 --> 01:08.500
好 接下来我们来测试一下

01:08.500 --> 01:10.500
首先呢 我们知道

01:10.500 --> 01:12.500
这个set集合呢 它是个构造函数

01:12.500 --> 01:14.500
因此呢 我们可以用ES5的方式

01:14.500 --> 01:16.500
来书写构造函数

01:16.500 --> 01:18.500
但是呢 为了练习

01:18.500 --> 01:20.500
我们本门客学习的类

01:20.500 --> 01:22.500
所以说 我们仍然使用

01:22.500 --> 01:24.500
ES6的方式来书写构造函数

01:24.500 --> 01:26.500
你用ES5其实是一样的

01:26.500 --> 01:28.500
好 这里呢 取名为myset

01:28.500 --> 01:30.500
myset

01:30.500 --> 01:32.500
好 接下来它有个构造函数

01:32.500 --> 01:34.500
这个构造函数里边呢

01:34.500 --> 01:38.500
是不是有可能有参数 有可能没有参数

01:38.500 --> 01:40.500
像我们之前写的 比方说

01:40.500 --> 01:42.500
s new一个myset

01:42.500 --> 01:44.500
那这里是不是 我们之前写set的时候

01:44.500 --> 01:46.500
是不是这里可以传 可以不传

01:46.500 --> 01:48.500
不传的话 就是一个空的set集合

01:48.500 --> 01:50.500
传的话 就是

01:50.500 --> 01:52.500
我给我传一个什么

01:52.500 --> 01:54.500
给我传一个可迭代的对象

01:54.500 --> 01:56.500
我就可以把对象里面

01:56.500 --> 01:58.500
每一次迭代的结果 要集合里面去

01:58.500 --> 02:00.500
好 那么这里该怎么写呢

02:00.500 --> 02:02.500
其实很简单 我们这里呢

02:02.500 --> 02:04.500
就给它写个参数

02:04.500 --> 02:06.500
这个参数呢 你可以传 可以不传

02:06.500 --> 02:08.500
那么这个参数怎么来

02:08.500 --> 02:10.500
实现可以传 可以不传呢

02:10.500 --> 02:12.500
是不是可以给它个默认值

02:12.500 --> 02:14.500
默认值的话 我就给了一个空数组

02:14.500 --> 02:16.500
你给我传 那过后呢 我就用你传递的

02:16.500 --> 02:18.500
你没有给我传的 我就是用空数组

02:18.500 --> 02:20.500
对吧 就是用空数组

02:20.500 --> 02:22.500
这关于这一块

02:22.500 --> 02:24.500
这样子呢 我在构造寒兽里边

02:24.500 --> 02:26.500
是不是它这里得到了一定是一个

02:26.500 --> 02:28.500
可迭代的对象啊 对吧

02:28.500 --> 02:30.500
当然它前面条件 还要给我传一个可迭代的对象

02:30.500 --> 02:32.500
如果说它不给我传一个可迭代的对象的话

02:32.500 --> 02:34.500
我给它报错就完成了

02:34.500 --> 02:36.500
比方说我们要实现的这样的功能

02:36.500 --> 02:38.500
那么比方说一开始要验证

02:38.500 --> 02:40.500
是否

02:40.500 --> 02:42.500
是可迭代的

02:42.500 --> 02:44.500
对象 怎么来验证呢

02:44.500 --> 02:46.500
其实特别简单 我们就用这种方式

02:46.500 --> 02:48.500
判断一下

02:48.500 --> 02:50.500
因为可迭代对象

02:50.500 --> 02:52.500
它有这么一个特点

02:52.500 --> 02:54.500
它里边一定有一个符号

02:54.500 --> 02:56.500
知名符号属性

02:56.500 --> 02:58.500
并且它的类型是一个函数

02:58.500 --> 03:00.500
所以可迭代对象一定是有这么一个特点

03:00.500 --> 03:02.500
如果说我发现

03:02.500 --> 03:04.500
你这个东西呢

03:04.500 --> 03:06.500
它不是一个函数

03:06.500 --> 03:08.500
或者说这个属性没有

03:08.500 --> 03:10.500
这个成员没有 比方说是undefined

03:10.500 --> 03:12.500
总之它不是一个函数

03:12.500 --> 03:14.500
那么我们这里是不是可以报错

03:14.500 --> 03:16.500
报一个type error

03:16.500 --> 03:19.870
你提供的

03:19.870 --> 03:21.870
提供的

03:21.870 --> 03:23.870
就是参数

03:23.870 --> 03:25.870
不是一个

03:25.870 --> 03:27.870
可迭代的对象

03:27.870 --> 03:29.870
或者说我们把那个给它写出来

03:29.870 --> 03:31.870
也行 就是把它的参数

03:31.870 --> 03:33.870
给它写出来也行

03:33.870 --> 03:35.870
你提供的

03:35.870 --> 03:37.870
这里

03:37.870 --> 03:39.870
不是一个可迭代对象

03:39.870 --> 03:41.870
就这么回事

03:41.870 --> 03:43.870
这里就可以进行验证了

03:43.870 --> 03:45.870
那么这样子一来的话

03:45.870 --> 03:47.870
就不行了

03:47.870 --> 03:51.380
看一下

03:51.380 --> 03:53.380
你提供的22不是一个可迭代的对象

03:53.380 --> 03:55.380
对吧

03:55.380 --> 03:57.380
那我们看一下set 是不是这样做的呢

03:57.380 --> 03:59.380
我们看一下set 留一个set

03:59.380 --> 04:01.380
保存

04:01.380 --> 04:03.380
也是一样的

04:03.380 --> 04:05.380
Number 22 is not attribable

04:05.380 --> 04:07.380
它只不过用英文写的

04:07.380 --> 04:09.380
它无法读取属项 symbol iterator

04:09.380 --> 04:11.380
对吧

04:11.380 --> 04:13.380
那么这个验证写完了

04:13.380 --> 04:15.380
接下来呢

04:15.380 --> 04:17.380
结果的话已经爆错了

04:17.380 --> 04:19.380
没有爆错了 它说明已经通过了验证

04:19.380 --> 04:21.380
验证这样通过了过后

04:21.380 --> 04:23.380
我们要做的事情就是

04:23.380 --> 04:25.380
迭代可迭代对象

04:25.380 --> 04:27.380
然后把它每一个迭代项

04:27.380 --> 04:29.380
放到我们的set 里面去

04:29.380 --> 04:31.380
那么这里怎么来迭代呢

04:31.380 --> 04:33.380
既然它是一个可迭代对象

04:33.380 --> 04:35.380
是不是我们可以用 forov 循环

04:35.380 --> 04:37.380
forov 循环来循环它

04:37.380 --> 04:39.380
iterator

04:39.380 --> 04:41.380
它既然可迭代

04:41.380 --> 04:43.380
我们就可以用 forov 循环来迭代它

04:43.380 --> 04:45.380
那么我们把这个结果

04:45.380 --> 04:47.380
夹到我们的set 里面去

04:47.380 --> 04:49.380
夹的话用什么呢

04:49.380 --> 04:51.380
set 里面它不是提供了一个方法吗

04:51.380 --> 04:53.380
叫add 对吧

04:53.380 --> 04:55.380
提供了这么一个方法

04:55.380 --> 04:57.380
所以说我们可以利用这个方法来

04:57.380 --> 04:59.380
往它里面夹

04:59.380 --> 05:01.380
那么这个方法我这里先写到这吧

05:01.380 --> 05:03.380
delta

05:03.380 --> 05:05.380
那么我们这里就调用 zs.add

05:05.380 --> 05:07.380
把这个item 夹进去

05:07.380 --> 05:09.380
就完事了 要做的事情就这么简单

05:09.380 --> 05:11.380
也就是说我们现在

05:11.380 --> 05:13.380
转到这个add 方法上面

05:13.380 --> 05:15.380
其实我通过讲这个圆码

05:15.380 --> 05:17.380
是给它提供一些思路

05:17.380 --> 05:19.380
就是你遇到一些问题的时候

05:19.380 --> 05:21.380
该怎么去写

05:21.380 --> 05:23.380
那么这个add 方法怎么实现呢

05:23.380 --> 05:25.380
这个add 方法实现起来也很简单

05:25.380 --> 05:27.380
就是说我这个set 里面要装一些东西

05:27.380 --> 05:29.380
那我得有一个东西来装它吧

05:29.380 --> 05:31.380
对不对 那么我们在内部

05:31.380 --> 05:33.380
使用一个数组来装它

05:33.380 --> 05:35.380
来装这个东西

05:35.380 --> 05:37.380
在内部使用一个数组

05:37.380 --> 05:39.380
那么我们这里比方说

05:39.380 --> 05:41.380
下滑线 加上下滑线的意思呢

05:41.380 --> 05:43.380
就是说你外边的人就不要去使用了

05:43.380 --> 05:45.380
当然你可以用符号属性

05:45.380 --> 05:47.380
外面的人就彻底用不了了

05:47.380 --> 05:49.380
总之当外面的人不要去使用它

05:49.380 --> 05:51.380
我就是内部使用的

05:51.380 --> 05:53.380
我再说一次 我这个写的呢

05:53.380 --> 05:55.380
跟那个

05:55.380 --> 05:57.380
它官方提供的那个set 肯定不一样的

05:57.380 --> 05:59.380
因为官方是可以直接操作内存的

05:59.380 --> 06:01.380
在这里边可以写那个底层代码

06:01.380 --> 06:03.380
c1nc++代码是可以直接操作内存的

06:03.380 --> 06:05.380
我这里没法

06:05.380 --> 06:07.380
我这里只能用js 来写

06:07.380 --> 06:09.380
浏览器环境里面是没法直接操作底层的

06:09.380 --> 06:11.380
好 那么现在呢

06:11.380 --> 06:13.380
我们add是什么

06:13.380 --> 06:15.380
add方法其实很简单

06:15.380 --> 06:17.380
就是往这个data里面

06:17.380 --> 06:19.380
铺写一下

06:19.380 --> 06:21.380
铺写一下就完事了

06:21.380 --> 06:23.380
扔进去就完事了

06:23.380 --> 06:25.380
这只不过有个前提条件

06:25.380 --> 06:26.380
什么前提条件呢

06:26.380 --> 06:28.380
就是由于我这个set里边呢

06:28.380 --> 06:30.380
由于我这个set里边呢

06:30.380 --> 06:32.380
它是不能有重复的数据

06:32.380 --> 06:34.380
所以说我这里要判断一下

06:34.380 --> 06:37.750
如果说

06:37.750 --> 06:39.750
我这里边没有

06:39.750 --> 06:41.750
不包含

06:41.750 --> 06:43.750
不就是

06:43.750 --> 06:45.750
包含从

06:45.750 --> 06:46.750
这样说吧

06:46.750 --> 06:48.750
不包含

06:48.750 --> 06:50.750
data 就是我这个

06:50.750 --> 06:52.750
数组里边没有data

06:52.750 --> 06:53.750
ok 我才往里边加

06:53.750 --> 06:55.750
有data的话是不是不假

06:55.750 --> 06:56.750
就不假就完事了

06:56.750 --> 06:57.750
那么这里呢

06:57.750 --> 06:59.750
又把这个问题又转换成这个玩意儿了

06:59.750 --> 07:00.750
这个玩意儿是什么呢

07:00.750 --> 07:01.750
就是set里边的

07:01.750 --> 07:03.750
不是一个函数吗 叫hice

07:03.750 --> 07:05.750
又把问题转换成它了

07:05.750 --> 07:08.750
就可以调用这个z点hice还是数

07:08.750 --> 07:11.750
如果说你没有

07:11.750 --> 07:12.750
那么我才往里边加

07:12.750 --> 07:13.750
就这么简单

07:13.750 --> 07:14.750
这个ad方法就写完了

07:14.750 --> 07:16.750
所以说现在问题又变成这个了

07:16.750 --> 07:18.750
是不是变成这个了

07:18.750 --> 07:19.750
又变成这个了

07:19.750 --> 07:22.750
你是否拥有某个东西

07:22.750 --> 07:23.750
是否拥有某个东西

07:23.750 --> 07:24.750
那么我们要判断

07:24.750 --> 07:25.750
是否拥有

07:25.750 --> 07:27.750
是不是就是一个典型的查照问题

07:27.750 --> 07:28.750
循环啥

07:28.750 --> 07:29.750
是不是就循环

07:29.750 --> 07:30.750
我们用for all

07:30.750 --> 07:31.750
循环什么呢

07:31.750 --> 07:33.750
循环我们这里边有的东西

07:33.750 --> 07:34.750
是不是一个一个拿出来看

07:34.750 --> 07:35.750
对吧 因为它是个数组

07:35.750 --> 07:36.750
它可以叠带

07:36.750 --> 07:37.750
它一个个拿出来看

07:37.750 --> 07:39.750
看一下这个东西

07:39.750 --> 07:41.750
是不是跟它是一样的

07:41.750 --> 07:42.750
那么怎么来判断

07:42.750 --> 07:43.750
是不是一样的呢

07:43.750 --> 07:44.750
我们之前说过

07:44.750 --> 07:46.750
set里边判断的它比较特殊

07:46.750 --> 07:48.750
它到底方式是用objects

07:48.750 --> 07:49.750
一直来判断

07:49.750 --> 07:50.750
但是呢

07:50.750 --> 07:52.750
对于证明和复灵

07:52.750 --> 07:53.750
又做了单独处理

07:53.750 --> 07:54.750
所以说为了

07:54.750 --> 07:55.750
重用这里的代码

07:55.750 --> 07:57.750
我们再写一个函数

07:57.750 --> 07:59.750
一扩

07:59.750 --> 08:01.750
两个东西是不是一样的

08:01.750 --> 08:02.750
你给我传一个什么呢

08:02.750 --> 08:03.750
传一个就是

08:03.750 --> 08:04.750
第一个数据

08:04.750 --> 08:05.750
第二个数据

08:05.750 --> 08:06.750
我来帮你判断

08:06.750 --> 08:08.750
两个数据是不是一样的

08:08.750 --> 08:10.750
判断两个数据

08:10.750 --> 08:12.750
是否相等

08:12.750 --> 08:13.750
相等

08:13.750 --> 08:14.750
那么它怎么判断的呢

08:14.750 --> 08:16.750
它这样子判断的

08:16.750 --> 08:18.750
如果说

08:18.750 --> 08:21.750
data1它是

08:21.750 --> 08:22.750
它等

08:22.750 --> 08:25.750
就是它是等于0的

08:25.750 --> 08:27.750
data2又等于0

08:27.750 --> 08:29.750
那么我就认为两个相等

08:29.750 --> 08:32.750
如果说data1等于0

08:32.750 --> 08:36.750
并且data2等于0

08:36.750 --> 08:37.750
那么我就认为

08:37.750 --> 08:39.750
只有这两个都是0的情况下

08:39.750 --> 08:40.750
都是0的情况下

08:40.750 --> 08:42.750
我才认为

08:42.750 --> 08:44.750
因为用严格相等的话

08:44.750 --> 08:46.750
证明和复灵是一样的

08:46.750 --> 08:48.750
所以说你这里不用去管证明和复灵

08:48.750 --> 08:49.750
不管它是证明

08:49.750 --> 08:50.750
还是它是复灵

08:50.750 --> 08:51.750
还是它是复灵

08:51.750 --> 08:52.750
它是证明

08:52.750 --> 08:53.750
那么只要它等于0

08:53.750 --> 08:54.750
那么我就认为

08:54.750 --> 08:55.750
它们两个相等

08:55.750 --> 08:56.750
其他的情况

08:56.750 --> 08:59.750
我就使用objects一直来判断

08:59.750 --> 09:01.750
就使用objects一直来判断

09:01.750 --> 09:03.750
它就用这种方式来判断的

09:03.750 --> 09:05.750
这是1是1过

09:05.750 --> 09:06.750
那么这样子写

09:06.750 --> 09:07.750
这个方法写出来之后

09:07.750 --> 09:08.750
我们这里就好办了

09:08.750 --> 09:10.750
我这里只需要判断一下

09:10.750 --> 09:12.750
如果说

09:12.750 --> 09:16.190
我们这里z是1过

09:16.190 --> 09:17.190
判断一下

09:17.190 --> 09:19.190
如果说data跟item是一样的

09:19.190 --> 09:20.190
如果说是一样的

09:20.190 --> 09:22.190
是不是hiz就返回q

09:22.190 --> 09:24.190
否则的话就返回force

09:24.190 --> 09:25.190
循环完了没找到一样的

09:25.190 --> 09:27.190
那么就返回force

09:27.190 --> 09:28.190
就是hiz

09:28.190 --> 09:30.190
你看这几个关键方法就写完了

09:30.190 --> 09:32.190
ad方法一代hiz

09:32.190 --> 09:34.190
它够造函数的一代add

09:34.190 --> 09:36.190
你看一下这个结构

09:36.190 --> 09:37.190
这也是一个典型的

09:37.190 --> 09:39.190
书写程序的一个顺序

09:39.190 --> 09:41.190
书写程序有很多顺序

09:41.190 --> 09:43.190
然后这东西就是一种顺序

09:43.190 --> 09:45.190
我先从一个入口点入手

09:45.190 --> 09:46.190
发现了一个问题

09:46.190 --> 09:47.190
我缺失一个东西

09:47.190 --> 09:49.190
OK 我去加这么一个东西

09:49.190 --> 09:50.190
而写这个东西的时候

09:50.190 --> 09:51.190
又发现缺失一个东西

09:51.190 --> 09:52.190
我去加它

09:52.190 --> 09:53.190
而写它的时候又发现缺失一个

09:53.190 --> 09:54.190
我去加它

09:54.190 --> 09:56.190
就一层一层过来的

09:56.190 --> 09:57.190
那么现在我们

09:57.190 --> 09:59.190
其实已经可以看到

09:59.190 --> 10:01.190
已经可以看到

10:01.190 --> 10:02.190
myset

10:02.190 --> 10:03.190
就这个玩意儿

10:03.190 --> 10:05.190
能不能有效呢

10:05.190 --> 10:08.190
当然这里不能这样子写了

10:08.190 --> 10:10.190
比方说我们给它写一些

10:10.190 --> 10:12.190
写一些数据吧

10:12.190 --> 10:15.190
那么这里我们输出s

10:15.190 --> 10:16.190
你看

10:16.190 --> 10:17.190
是不是它内部的集合里面

10:17.190 --> 10:18.190
就有这个数据了

10:18.190 --> 10:21.190
如果说我输出重复的

10:21.190 --> 10:23.190
输出重复的数据

10:23.190 --> 10:24.190
后面也写个35

10:24.190 --> 10:25.190
保存

10:25.190 --> 10:28.190
你看是不是还是去重了

10:28.190 --> 10:29.190
因为它每

10:29.190 --> 10:30.190
因为这个调用构造寒数的时候

10:30.190 --> 10:32.190
它相当于往里面加

10:32.190 --> 10:33.190
调用add方法加

10:33.190 --> 10:34.190
而加的时候呢

10:34.190 --> 10:35.190
加的时候呢

10:35.190 --> 10:36.190
是不是判断了的

10:36.190 --> 10:37.190
对吧 判断了的

10:37.190 --> 10:38.190
所以说它不会有重复的

10:38.190 --> 10:39.190
同样的道理

10:39.190 --> 10:40.190
我们可以利用

10:40.190 --> 10:42.190
这个s里面的add方法

10:42.190 --> 10:43.190
往里面添加数据

10:43.190 --> 10:44.190
add

10:44.190 --> 10:46.190
比方说我们给它添加一个66

10:46.190 --> 10:48.190
或者说现在添加一个66

10:48.190 --> 10:50.190
然后再添加一个7

10:50.190 --> 10:52.190
你会发现7是无效的

10:52.190 --> 10:54.190
再让我们看

10:54.190 --> 10:56.190
7是不是只有一个

10:56.190 --> 10:57.190
66多了一个

10:57.190 --> 10:58.190
就这么个意思

10:58.190 --> 10:59.190
这是add

10:59.190 --> 11:00.190
当然我们也可以

11:00.190 --> 11:01.190
通过hass的判断

11:01.190 --> 11:02.190
它里面有没有

11:02.190 --> 11:04.190
那它里面还有啥呢

11:04.190 --> 11:05.190
是不是还有dnet

11:05.190 --> 11:06.190
dnet

11:06.190 --> 11:07.190
你要删除一个数据

11:07.190 --> 11:09.190
对吧 是不是要删除一个数据

11:09.190 --> 11:11.190
好 那么删除一个数据的话

11:11.190 --> 11:12.190
我们怎么删

11:12.190 --> 11:14.190
是不是也得循环匹配

11:14.190 --> 11:15.190
对吧 也得循环匹配

11:15.190 --> 11:17.190
OK 我们这里用 for 循环

11:17.190 --> 11:18.190
为什么用for 循环呢

11:18.190 --> 11:19.190
因为最终我们是在

11:19.190 --> 11:20.190
删数组里面的东西

11:20.190 --> 11:22.190
我们用for 循环

11:22.190 --> 11:23.190
循环啥呢

11:23.190 --> 11:27.190
循环这个就是

11:28.190 --> 11:30.190
data

11:30.190 --> 11:32.190
一项一项拿出来看

11:32.190 --> 11:33.190
一项一项拿出来看

11:33.190 --> 11:34.190
如果发现

11:34.190 --> 11:36.190
this is equal

11:36.190 --> 11:37.190
你看是不是在重用代码

11:37.190 --> 11:38.190
判断两个相不相等

11:38.190 --> 11:40.190
这个东西跟我们的数据

11:40.190 --> 11:42.190
是相等的 是不是要删除

11:42.190 --> 11:44.190
对吧 要删除

11:44.190 --> 11:46.190
删除怎么删呢

11:46.190 --> 11:47.190
怎么删

11:47.190 --> 11:48.190
是不是就利用下标i

11:48.190 --> 11:49.190
重数组里面删除

11:49.190 --> 11:50.190
就完事了

11:50.190 --> 11:51.190
data

11:51.190 --> 11:53.190
splice

11:53.190 --> 11:55.190
用下标i 删一项

11:55.190 --> 11:56.190
就完事了

11:56.190 --> 11:57.190
没问题吧

11:57.190 --> 11:58.190
就splice

11:58.190 --> 12:00.190
然后既然删除成功了

12:00.190 --> 12:01.190
我就返回去

12:01.190 --> 12:02.190
否则的话

12:02.190 --> 12:03.190
如果整个循环完了

12:03.190 --> 12:04.190
都没有删除成功

12:04.190 --> 12:05.190
我就返回force

12:05.190 --> 12:06.190
就delete的方法

12:06.190 --> 12:08.190
delete的方法也写好了

12:08.190 --> 12:09.190
比方说

12:09.190 --> 12:11.190
s.delete

12:11.190 --> 12:13.190
三一个六

12:13.190 --> 12:14.190
保存

12:14.190 --> 12:16.190
那里看一下

12:16.190 --> 12:17.190
六是不是没了

12:17.190 --> 12:18.190
六就没了

12:18.190 --> 12:21.190
OK 这是关于delete

12:21.190 --> 12:22.190
然后再来

12:22.190 --> 12:25.190
我们不是里面还有clear吗

12:25.190 --> 12:26.190
clear

12:26.190 --> 12:27.190
清空

12:27.190 --> 12:28.190
把整个清空

12:28.190 --> 12:29.190
整个清空去特别简单

12:29.190 --> 12:30.190
就把数组清空就完事了

12:30.190 --> 12:31.190
对吧

12:31.190 --> 12:32.190
把数组清空就完事了

12:32.190 --> 12:33.190
this

12:33.190 --> 12:35.190
下发现data是nance等于0

12:35.190 --> 12:36.190
就完了

12:36.190 --> 12:37.190
这就清空了

12:37.190 --> 12:38.190
就清空了

12:38.190 --> 12:39.190
特别简单

12:39.190 --> 12:40.190
比方说我们这里

12:40.190 --> 12:41.190
s.delete

12:41.190 --> 12:42.190
清空

12:42.190 --> 12:43.190
保存

12:43.190 --> 12:44.190
你看一下

12:44.190 --> 12:45.190
它数组里面

12:45.190 --> 12:46.190
内部的数组就没了

12:46.190 --> 12:47.190
那么至此

12:47.190 --> 12:49.190
才把它的核心API寫下完了

12:49.190 --> 12:50.190
但是同时

12:50.190 --> 12:51.190
你要知道

12:51.190 --> 12:52.190
这个对象

12:52.190 --> 12:53.190
它是一个可迭带的

12:53.190 --> 12:54.190
就是我这个set成的

12:54.190 --> 12:55.190
要能够迭带

12:55.190 --> 12:56.190
比方说我们这里写的

12:56.190 --> 12:57.190
这么多乱七八糟的玩意儿

12:57.190 --> 12:58.190
对吧

12:58.190 --> 12:59.190
我得把一个循环出来

12:59.190 --> 13:00.190
我要辨历它

13:00.190 --> 13:01.190
那我咋辨历呢

13:01.190 --> 13:02.190
item s

13:02.190 --> 13:03.190
我得辨历它

13:03.190 --> 13:04.190
你现在能辨历吗

13:04.190 --> 13:05.190
现在肯定不能辨历

13:05.190 --> 13:06.190
为什么呢

13:06.190 --> 13:08.190
因为它不是一个可迭带对象

13:08.190 --> 13:10.190
意思是not iterable

13:10.190 --> 13:12.190
那么怎么把它变成可迭带对象呢

13:12.190 --> 13:13.190
其实也特别简单

13:13.190 --> 13:14.190
我只需要在构造函数里面

13:14.190 --> 13:15.190
圆形上

13:15.190 --> 13:16.190
因为这里的方法

13:16.190 --> 13:17.190
是不是都在圆形上

13:17.190 --> 13:18.190
再加一个成员

13:18.190 --> 13:20.190
symbol

13:20.190 --> 13:21.190
ator

13:21.190 --> 13:22.190
对吧

13:22.190 --> 13:23.190
再加一个成员方法

13:23.190 --> 13:24.190
那么这个方法干嘛呢

13:24.190 --> 13:26.190
这个方法是不是就反回一个

13:26.190 --> 13:27.190
反回一个啥

13:27.190 --> 13:29.190
反回一个迭带器

13:29.190 --> 13:30.190
那么这个方法

13:30.190 --> 13:31.190
是不是一个迭带器

13:31.190 --> 13:32.190
创建方法

13:32.190 --> 13:33.190
迭带器

13:33.190 --> 13:34.190
创建方法

13:34.190 --> 13:36.190
换句话说

13:36.190 --> 13:38.190
这个方法是不是个生成器

13:40.190 --> 13:41.190
这个信号

13:41.190 --> 13:43.190
应该写到方法名前面

13:43.190 --> 13:45.190
是不是应该是个生成器

13:45.190 --> 13:47.190
生成器不就是反回一个

13:47.190 --> 13:48.190
生成器

13:48.190 --> 13:49.190
生成器函数

13:49.190 --> 13:50.190
不就是反回

13:50.190 --> 13:51.190
它是一个生成器函数

13:51.190 --> 13:52.190
它不就反回一个生成器吗

13:52.190 --> 13:54.190
生成器不就是迭带器吗

13:54.190 --> 13:56.190
那么生成器里面干嘛

13:56.190 --> 13:57.190
是每一次

13:57.190 --> 13:59.190
它一个迭带结果就行了

13:59.190 --> 14:00.190
迭带结果是啥

14:00.190 --> 14:01.190
迭带结果不就是

14:01.190 --> 14:02.190
数组里面的结果吗

14:02.190 --> 14:03.190
对吧

14:03.190 --> 14:04.190
所以说我这里咋写

14:04.190 --> 14:05.190
就循环数组

14:05.190 --> 14:07.190
这也是

14:07.190 --> 14:08.190
对吧

14:08.190 --> 14:09.190
循环数组

14:09.190 --> 14:10.190
然后干嘛

14:10.190 --> 14:11.190
然后干嘛

14:11.190 --> 14:13.190
yield item

14:13.190 --> 14:14.190
对吧

14:14.190 --> 14:15.190
是不是这样子

14:15.190 --> 14:16.190
就完事了

14:16.190 --> 14:17.190
就完事了

14:17.190 --> 14:18.190
对吧

14:18.190 --> 14:19.190
这就是它的生成器

14:19.190 --> 14:20.190
那么这样你自己来的话

14:20.190 --> 14:21.190
它是不是可以迭带了

14:21.190 --> 14:22.190
你看一下

14:22.190 --> 14:23.190
是不是迭带出来了

14:23.190 --> 14:24.190
对吧

14:24.190 --> 14:26.190
把变成生成器就完事了

14:26.190 --> 14:27.190
好

14:27.190 --> 14:28.190
再来一个

14:28.190 --> 14:29.190
里面还不是还有一个

14:29.190 --> 14:30.190
for一起函数吗

14:30.190 --> 14:31.190
for一起

14:31.190 --> 14:32.190
不是还给我传一个

14:32.190 --> 14:33.190
callback

14:33.190 --> 14:34.190
callback

14:34.190 --> 14:36.190
for一起函数

14:36.190 --> 14:37.190
for一起函数干嘛

14:37.190 --> 14:39.190
是不是也是在循环数组

14:39.190 --> 14:40.190
每循环一项

14:40.190 --> 14:42.190
每循环到数组的一项

14:42.190 --> 14:43.190
是不是调用那个callback函数

14:43.190 --> 14:44.190
调用一次

14:44.190 --> 14:45.190
它里面不有三个参数吗

14:45.190 --> 14:47.190
第一个参数是每一项的值

14:47.190 --> 14:48.190
第二个参数是每一项的下标

14:48.190 --> 14:49.190
但是它没有下标

14:49.190 --> 14:51.190
没有下标还是传值

14:51.190 --> 14:52.190
第三个是本身

14:52.190 --> 14:53.190
本身是啥

14:53.190 --> 14:54.190
this

14:55.190 --> 14:56.190
是不是就写完了

14:56.190 --> 14:57.190
对吧

14:57.190 --> 14:58.190
就写完了

14:59.190 --> 15:00.190
这就是

15:01.190 --> 15:03.190
for一起

15:03.190 --> 15:05.190
for一起这个函数

15:06.190 --> 15:07.190
好了

15:07.190 --> 15:08.190
没啥问题吧

15:08.190 --> 15:09.190
没啥问题吧

15:09.190 --> 15:10.190
咱们来看一下吧

15:10.190 --> 15:11.190
用for一起来循环一次

15:11.190 --> 15:12.190
来变定一次

15:13.190 --> 15:14.190
s.for一起

15:15.190 --> 15:16.190
那么item

15:17.190 --> 15:18.190
三个都写吧

15:18.190 --> 15:19.190
item

15:22.020 --> 15:23.020
这样子

15:23.020 --> 15:24.020
argument1

15:24.020 --> 15:25.020
argument2

15:25.020 --> 15:26.020
argument3

15:26.020 --> 15:27.020
我们再输出

15:27.020 --> 15:29.020
a1,a2,a3

15:29.020 --> 15:30.020
保存

15:30.020 --> 15:31.020
你看一下

15:31.020 --> 15:33.020
这里是不是得到了一样的效果

15:34.020 --> 15:35.020
这就是myset

15:35.020 --> 15:36.020
如果说你要手动实现的话

15:36.020 --> 15:38.020
你在内部去维护一个数组

15:38.020 --> 15:40.020
然后把它封装一下

15:40.020 --> 15:42.020
你可以认为es6

15:42.020 --> 15:43.020
其实在这一块

15:43.020 --> 15:45.020
就是让你使用一些

15:45.020 --> 15:47.020
不重复的数据集合

15:47.020 --> 15:48.020
更加方便而已

15:48.020 --> 15:49.020
你要自己写的话

15:49.020 --> 15:50.020
你是能写出来的

15:51.020 --> 15:52.020
这是关于myset

15:52.020 --> 15:53.020
就讲完了

