WEBVTT

00:00.110 --> 00:04.610
好了 同学们 至此呢 我们已经完成了整个Promise 额价规范

00:05.110 --> 00:10.110
如果说将来面试的时候 让你熟写一个Promise 表示它提

00:10.110 --> 00:13.110
就是让你熟写一个Promise 写到这儿就够了

00:13.110 --> 00:16.110
只写一个Promise 额价规范就可以了

00:16.110 --> 00:20.110
那么剩下的还有什么Catch啊Family啊 还有一些静态方法

00:20.110 --> 00:23.110
我们可以不写 除非它有特别的要求

00:24.110 --> 00:28.110
一般来说 面试提到时候 要么就考察力熟写Promise

00:28.110 --> 00:31.110
但是如果说考察力熟写Promise的话 这个要求是比较高的

00:32.110 --> 00:35.110
但是如果说同学们能够把我这样的一个代码写出来

00:35.110 --> 00:38.110
我告诉同学们 好不夸张的说 如果说满分是100分

00:38.110 --> 00:39.110
你们可以达到120

00:40.110 --> 00:43.110
整个面试的所有的人员中 你就是最亮的仔

00:44.110 --> 00:46.110
这个代码的质量是非常高的

00:47.110 --> 00:50.110
但是有可能面试的时候 不让你熟写Promise

00:50.110 --> 00:52.110
这不需要你写的太复杂了

00:52.110 --> 00:55.110
可能会让你去写一些什么Catch啊Family啊

00:55.110 --> 00:58.110
还有一些静态方法 那我们依次来给大家讲解一下

00:59.110 --> 01:02.110
那么这些方法呢 他不是A加规范的

01:02.110 --> 01:04.110
所以说让你单独的去写这些方法的时候

01:04.110 --> 01:06.110
你可以针对

01:07.110 --> 01:10.110
你可以直接针对这个官方的Promise来进行熟写

01:10.110 --> 01:13.110
那比方说你要写这个Catch方法 你怎么写呢

01:13.110 --> 01:16.110
PromisePrototypeCatch

01:16.110 --> 01:19.110
就把重新改成另外一个函数 就实现就完事了

01:20.110 --> 01:22.110
OK 这就是你具体的写的位置

01:22.110 --> 01:24.110
当然因为我们这边使用的是

01:24.110 --> 01:26.110
已经写好了我们自己的Promise

01:26.110 --> 01:28.110
所以我们这边可以怎么写呢

01:28.110 --> 01:30.110
可以写MyPromisePrototype

01:32.110 --> 01:34.110
然后给它加上一个Catch方法

01:35.110 --> 01:36.110
当然可以在这里写

01:36.110 --> 01:38.110
也可以利用ES6的语法

01:39.110 --> 01:41.110
我再重称一次 如果说面试的时候

01:41.110 --> 01:42.110
让你单独的去写Catch

01:43.110 --> 01:45.110
你直接把这里换成官方的Promise就可以了

01:46.110 --> 01:49.110
因为我这里呢 就要完整的实现一个我自己的Promise

01:49.110 --> 01:51.110
所以说我这里接着我的写 懂的意思吧

01:51.110 --> 01:53.110
以后在面试的时候 你直接使用官方的

01:54.110 --> 01:57.110
前提条件 事实上他要让你单独的去写Catch

01:58.110 --> 02:00.110
好 那因为我们这里呢

02:00.110 --> 02:03.110
使用的是在我们自己的Promise上进行扩展

02:03.110 --> 02:06.110
因此我可以充分的利用ES6的语法

02:06.110 --> 02:08.110
ES6的语法是不是可以在这里写

02:08.110 --> 02:10.110
原型方法 对吧

02:10.110 --> 02:11.110
来写个Catch

02:11.110 --> 02:14.110
哇 开启方法 那简单的简直是令人发指

02:15.110 --> 02:16.110
有多令人发指呢

02:16.110 --> 02:18.110
因为我们之前是不是讲过

02:18.110 --> 02:20.110
Catch实际上本知就是这

02:21.110 --> 02:23.110
它只是扫传了一个Unfulfill的

02:23.110 --> 02:25.110
它只处理那个失败

02:25.110 --> 02:30.110
所以说 仅处理失败的场景

02:31.110 --> 02:33.110
这里呢 怎么写呢

02:33.110 --> 02:34.110
就一句话就写完了

02:34.110 --> 02:35.110
当然官方的也是一样

02:35.110 --> 02:37.110
你直接调用它的任意方法就完事了

02:38.110 --> 02:39.110
第一个参数传达了

02:40.110 --> 02:41.110
第二个参数呢

02:41.110 --> 02:43.110
Unrejected就完了

02:43.110 --> 02:44.110
就这么简单

02:44.110 --> 02:46.110
是不是非常简单

02:46.110 --> 02:48.110
你就重复使用这个任意就完事了

02:48.110 --> 02:50.110
开启就写完了

02:50.110 --> 02:51.110
是不是很简单

02:51.110 --> 02:53.110
好 然后接下来是一个方法是finally

02:53.110 --> 02:54.110
可能有一种人不太清楚

02:54.110 --> 02:55.110
这个finally的方法

02:55.110 --> 02:56.110
我来说一下

02:56.110 --> 02:58.110
finally的方法是这样

02:58.110 --> 03:01.110
它表示的是任何

03:01.110 --> 03:07.110
就是无论是什么结果都会运行

03:08.110 --> 03:09.110
啥意思

03:09.110 --> 03:11.110
比方说我这里写一个Promise

03:11.110 --> 03:13.110
6一个Promise

03:15.110 --> 03:17.110
这里的表我们就Result吧

03:17.110 --> 03:18.110
Result1

03:19.110 --> 03:21.110
然后我们去调用finally

03:21.110 --> 03:23.110
它里面只传一个回调函数

03:23.110 --> 03:25.110
而且这个回调函数还没有参数

03:26.110 --> 03:27.110
也没有返回结果

03:27.110 --> 03:28.110
返回结果反正也不认的

03:29.110 --> 03:31.110
这里传一个函数

03:31.110 --> 03:33.110
这个函数是无论如何都会运行的

03:33.110 --> 03:34.110
finally

03:36.110 --> 03:37.110
finally

03:37.110 --> 03:38.110
我们输出一下

03:38.110 --> 03:40.110
那等一会我们再去打印一下

03:40.110 --> 03:42.110
打印一下Promise

03:43.110 --> 03:44.110
输出一下Promise

03:44.110 --> 03:45.110
看它的状态

03:45.110 --> 03:46.110
我们运行

03:47.110 --> 03:48.110
因为发现了

03:48.110 --> 03:49.110
首先有这么一个特点

03:49.110 --> 03:51.110
反正你成功之后有没有运行

03:51.110 --> 03:52.110
有运行

03:52.110 --> 03:53.110
然后如果说失败呢

03:54.110 --> 03:56.110
失败之后有没有运行呢

03:56.110 --> 03:57.110
也有运行

03:57.110 --> 03:59.110
它无论如何都会运行的

03:59.110 --> 04:00.110
那么这种情况

04:00.110 --> 04:01.110
我们虽然用的比较少

04:01.110 --> 04:02.110
但是我们要制造一点

04:02.110 --> 04:03.110
了解点

04:03.110 --> 04:04.110
首先它不是PromiseA加规范

04:04.110 --> 04:05.110
A加规范已经讲完了

04:05.110 --> 04:07.110
后边都是ES6

04:07.110 --> 04:09.110
给我们新增的一些东西

04:09.110 --> 04:10.110
我们把它实现

04:10.110 --> 04:11.110
好 反正这个方法

04:11.110 --> 04:12.110
它无论如何都会运行

04:12.110 --> 04:13.110
还有这么一个特点

04:13.110 --> 04:15.110
就是我们讲的时候

04:15.110 --> 04:16.110
这个作用的时候

04:16.110 --> 04:17.110
大家可以想一想

04:17.110 --> 04:18.110
怎么去写

04:19.110 --> 04:21.110
充分地利用我们现有的东西

04:21.110 --> 04:23.110
然后还有个什么情况呢

04:23.110 --> 04:24.110
你会发现

04:24.110 --> 04:26.110
比方说我们Result

04:26.110 --> 04:30.320
你会发现Fanley

04:30.320 --> 04:31.320
他也会

04:31.320 --> 04:32.320
我这里写错了

04:32.320 --> 04:34.320
应该写PromiseA

04:34.320 --> 04:38.020
我们看PromiseA到底是什么

04:38.020 --> 04:40.020
你会发现PromiseA

04:40.020 --> 04:42.020
他也会跟正方法一样

04:42.020 --> 04:44.020
也会返回一个新的PromiseA

04:44.020 --> 04:46.020
只不过他不太一样的地方

04:46.020 --> 04:48.020
就是这个新的PromiseA

04:48.020 --> 04:51.020
这状态跟旧的是完全一致的

04:51.020 --> 04:53.020
看来是完全一致的

04:53.020 --> 04:55.020
也就是说什么意思呢

04:55.020 --> 04:57.020
就是说你这个PromiseA

04:57.020 --> 04:58.020
完成了成功的数据是1

04:58.020 --> 05:00.020
那么他的也是成功的

05:00.020 --> 05:01.020
也是数据是1

05:01.020 --> 05:04.020
跟你这里的直系没有任何关系

05:04.020 --> 05:05.020
你这里如果说

05:05.020 --> 05:06.020
我这里返回一个123

05:06.020 --> 05:07.020
那你看

05:07.020 --> 05:09.020
它还是没变化

05:09.020 --> 05:11.020
因为它不需要你这个返回结果

05:11.020 --> 05:12.020
懂了意思吗

05:12.020 --> 05:14.020
它变成这样的一个模式

05:14.020 --> 05:15.020
那如果说失败呢

05:15.020 --> 05:17.020
就借个

05:17.020 --> 05:19.020
1 那么这里PromiseA

05:19.020 --> 05:21.020
它也是失败的

05:21.020 --> 05:22.020
因为我这里没有

05:22.020 --> 05:23.020
针对PromiseA进行失败的处理

05:23.020 --> 05:25.020
它有一个警告没关系

05:25.020 --> 05:26.020
那么我看到PromiseA

05:26.020 --> 05:27.020
它也有一个失败

05:27.020 --> 05:28.020
它也是失败的

05:28.020 --> 05:30.020
原因也是1

05:30.020 --> 05:31.020
懂了意思吗

05:31.020 --> 05:32.020
那我这边虽然

05:32.020 --> 05:33.020
这边虽然执行的过程中

05:33.020 --> 05:34.020
没有问题

05:34.020 --> 05:35.020
但是你还是失败的

05:35.020 --> 05:36.020
就有点像穿透

05:36.020 --> 05:39.020
就是它本身不改变状态

05:39.020 --> 05:40.020
但是有一种情况之外

05:40.020 --> 05:41.020
就是它如果说

05:41.020 --> 05:44.020
抛出了一个错误

05:44.020 --> 05:46.020
那么数据变成它的错误了

05:46.020 --> 05:47.020
你可以想一想

05:47.020 --> 05:48.020
它是一个什么样的逻辑

05:48.020 --> 05:49.020
其实这个逻辑

05:49.020 --> 05:50.020
一想通了

05:50.020 --> 05:51.020
发现这个太简单了

05:51.020 --> 05:52.020
这个逻辑

05:52.020 --> 05:54.020
如果说你看

05:54.020 --> 05:55.020
如果说它是成功的

05:55.020 --> 05:56.020
那么成功

05:56.020 --> 05:57.020
如果说里边

05:57.020 --> 05:58.020
抛了一个错误的话

05:58.020 --> 05:59.020
那么你觉得

05:59.020 --> 06:00.020
它仍然会失败

06:00.020 --> 06:02.020
仍然是1 2 3

06:02.020 --> 06:04.020
好像不太容易想得到

06:04.020 --> 06:05.020
它到底是一个

06:05.020 --> 06:06.020
什么的逻辑

06:06.020 --> 06:07.020
好像挺复杂的样子

06:07.020 --> 06:08.020
其实它这里贼简单

06:08.020 --> 06:12.970
好 翻了你

06:12.970 --> 06:13.970
它传一个什么

06:13.970 --> 06:14.970
传一个毁掉函数

06:14.970 --> 06:15.970
那么我们就该取个名叫

06:15.970 --> 06:16.970
Unsettled

06:16.970 --> 06:17.970
就是你只要以决

06:17.970 --> 06:19.970
不管你是成功还是失败

06:19.970 --> 06:20.970
我都会处理

06:20.970 --> 06:22.970
就都会运行这个函数

06:22.970 --> 06:24.970
这是

06:24.970 --> 06:26.970
这也是传的一个函数

06:26.970 --> 06:27.970
这个函数它不需要

06:27.970 --> 06:28.970
这个返回结果

06:28.970 --> 06:29.970
你反复返回

06:29.970 --> 06:30.970
都无所谓

06:30.970 --> 06:31.970
反正我也不用的

06:31.970 --> 06:32.970
这就是什么呢

06:32.970 --> 06:36.970
无论成功还是失败

06:36.970 --> 06:39.970
都会执行毁掉

06:39.970 --> 06:41.970
它是这么一个逻辑

06:41.970 --> 06:43.970
那你想一想

06:43.970 --> 06:44.970
其实我把个单码

06:44.970 --> 06:45.970
写出来一篇

06:45.970 --> 06:46.970
你明白了

06:46.970 --> 06:47.970
你想一想

06:47.970 --> 06:48.970
无论成

06:48.970 --> 06:49.970
这个函数

06:49.970 --> 06:50.970
它无论成功还是失败

06:50.970 --> 06:51.970
它都会执行

06:51.970 --> 06:52.970
而且它也会

06:52.970 --> 06:55.970
这个函数本身也会返回Promise

06:55.970 --> 06:58.970
是不是就是这么一个逻辑

06:58.970 --> 07:03.690
是不是就是这么一个逻辑

07:03.690 --> 07:04.690
我调入另一方法

07:04.690 --> 07:06.690
同时注册成功和失败

07:06.690 --> 07:07.690
都是它

07:07.690 --> 07:08.690
你成功之后运行它

07:08.690 --> 07:09.690
失败之后也运行它

07:09.690 --> 07:10.690
是不是就这么逻辑

07:10.690 --> 07:12.690
那么这个逻辑写出来

07:12.690 --> 07:14.690
首先它返回Promise没问题吧

07:14.690 --> 07:16.690
然后无论成功还是失败

07:16.690 --> 07:17.690
都会执行没问题吧

07:17.690 --> 07:19.690
这个没问题了

07:19.690 --> 07:20.690
但是有一些小的问题

07:20.690 --> 07:21.690
什么问题呢

07:21.690 --> 07:23.690
如果说你这样子写的话

07:23.690 --> 07:25.690
那么会导致什么呢

07:25.690 --> 07:26.690
会导致这边成功之后

07:26.690 --> 07:27.690
它的数据会传过来

07:27.690 --> 07:28.690
对不对

07:28.690 --> 07:29.690
这个数据是会传过来的

07:29.690 --> 07:30.690
但是你看这边的数据

07:30.690 --> 07:32.690
是没有传过来的

07:32.690 --> 07:34.690
让你一看

07:34.690 --> 07:35.690
它会把数据传过来

07:35.690 --> 07:36.690
失败的时候也是

07:36.690 --> 07:38.690
它会把原因传过来

07:38.690 --> 07:39.690
它会有这么一个逻辑

07:39.690 --> 07:40.690
那么这里发现

07:40.690 --> 07:41.690
我这个函数

07:41.690 --> 07:43.690
好像接受不到这个函数

07:43.690 --> 07:44.690
而且这个函数

07:44.690 --> 07:46.690
它返回结果是无效的

07:47.690 --> 07:49.690
它不会改变这里的成功

07:49.690 --> 07:50.690
那么如果说

07:50.690 --> 07:51.690
我直接这样子写的话

07:51.690 --> 07:52.690
肯定不行

07:52.690 --> 07:53.690
它怎么写呢

07:53.690 --> 07:55.690
有点想象力

07:55.690 --> 07:59.130
我这样子写

08:00.130 --> 08:02.130
我给你套一个函数

08:02.130 --> 08:05.130
我这个函数返回啥呢

08:05.130 --> 08:07.130
就返回这个data

08:07.130 --> 08:08.130
对吧

08:08.130 --> 08:09.130
你给我传的是什么

08:09.130 --> 08:10.130
你成功了

08:10.130 --> 08:11.130
然后我就运行这个函数

08:11.130 --> 08:12.130
这个函数执行期间

08:12.130 --> 08:13.130
没有问题

08:13.130 --> 08:14.130
我同志给你返回这个data

08:14.130 --> 08:16.130
然后再返回data

08:17.130 --> 08:19.130
然后再返回data之前

08:19.130 --> 08:21.130
我运行一下你这个Anzett

08:22.130 --> 08:23.130
所以就完了

08:23.130 --> 08:24.130
把包一下

08:24.130 --> 08:25.130
是不是这个逻辑

08:26.130 --> 08:28.130
好 如果说你失败了呢

08:29.130 --> 08:30.130
如果说你失败了

08:30.130 --> 08:31.130
这个Ryzen

08:32.130 --> 08:33.130
Ryzen

08:33.130 --> 08:34.130
Ryzen咋写

08:34.130 --> 08:35.130
Ryzen

08:35.130 --> 08:36.130
失败的原因

08:36.130 --> 08:37.130
你失败了

08:37.130 --> 08:39.130
我还是要运行这个

08:39.130 --> 08:40.130
我不可以给你传任何函数

08:40.130 --> 08:42.130
所以说那边就收不到函数了

08:42.130 --> 08:43.130
对吧

08:43.130 --> 08:45.130
然后我抛出一个

08:45.130 --> 08:46.130
错误

08:46.130 --> 08:47.130
Ryzen

08:48.130 --> 08:49.130
没了

08:49.130 --> 08:51.130
他就是给你包了一下

08:51.130 --> 08:53.130
有点想象力

08:53.130 --> 08:54.130
就完事了

08:54.130 --> 08:55.130
因此呢

08:55.130 --> 08:56.130
你会发现我这里

08:56.130 --> 08:57.130
把它换成by promise

08:57.130 --> 08:58.130
一样没有任何问题

09:00.760 --> 09:01.760
好 你看

09:02.760 --> 09:03.760
对吧

09:03.760 --> 09:04.760
Value是1

09:04.760 --> 09:05.760
Vanity

09:05.760 --> 09:06.760
Defend

09:06.760 --> 09:07.760
收不到这个函数

09:07.760 --> 09:08.760
而且这里返回的是无效的

09:08.760 --> 09:10.760
但是如果说这里包错

09:10.760 --> 09:11.760
那就没法了

09:11.760 --> 09:12.760
123

09:12.760 --> 09:13.760
是不是跟刚才就一样了

09:14.760 --> 09:15.760
有些个体的Value

09:15.760 --> 09:16.760
123

09:16.760 --> 09:17.760
为什么包错就不行了

09:17.760 --> 09:18.760
你看这个逻辑吗

09:18.760 --> 09:20.760
它如果说本来是成功的

09:20.760 --> 09:21.760
但是你这里

09:21.760 --> 09:23.760
运行期间包错了

09:23.760 --> 09:24.760
那么就会导致我这个函数

09:24.760 --> 09:25.760
包错

09:25.760 --> 09:26.760
我这个函数包错了

09:26.760 --> 09:27.760
那么这个返回的Promise

09:27.760 --> 09:28.760
那肯定是

09:28.760 --> 09:29.760
也是被拒绝的

09:29.760 --> 09:30.760
对吧

09:30.760 --> 09:31.760
那同样道理

09:31.760 --> 09:32.760
这里也是一样

09:32.760 --> 09:33.760
这里一样

09:33.760 --> 09:34.760
如果说我这里包错了

09:34.760 --> 09:35.760
那么同样的

09:35.760 --> 09:36.760
它会改变那个错误的数据

09:36.760 --> 09:37.760
如果说这里没有包错

09:37.760 --> 09:38.760
那么它会跟着

09:38.760 --> 09:40.760
把之前那个错误包出来

09:40.760 --> 09:41.760
这就是一个逻辑

09:41.760 --> 09:42.760
你可以去跟那个

09:42.760 --> 09:44.760
官方的Promise比较一下

09:44.760 --> 09:45.760
就非常简单

09:45.760 --> 09:47.760
这两个函数就写完了

09:47.760 --> 09:48.760
搬到你

09:48.760 --> 09:49.760
就会发现

09:50.760 --> 09:51.760
A加规范也实现

09:51.760 --> 09:53.760
剩下的东西都比较简单了

09:53.760 --> 09:55.760
无论是直接跟着官方的写

09:55.760 --> 09:56.760
还是我实现我们自己的

09:56.760 --> 09:57.760
都是这个写法

09:57.760 --> 10:00.760
官方的写法也是这样的写法

10:00.760 --> 10:01.760
无非那你写到位置

10:01.760 --> 10:02.760
那你不是在这个位置

10:02.760 --> 10:03.760
那你就写到位置

10:03.760 --> 10:04.760
Promise

10:04.760 --> 10:05.760
Prototype

10:05.760 --> 10:06.760
Catch

10:06.760 --> 10:08.760
Catch怎么写呢

10:08.760 --> 10:10.760
Return

10:10.760 --> 10:11.760
Return

10:11.760 --> 10:12.760
Return

10:12.760 --> 10:13.760
是一样的

10:13.760 --> 10:14.760
都是一样的

10:14.760 --> 10:15.760
一用之前的认方法

10:15.760 --> 10:17.760
反正你写法也是一样的

10:17.760 --> 10:19.760
ok 这就是那一个

10:19.760 --> 10:20.760
这两个函数的实现

