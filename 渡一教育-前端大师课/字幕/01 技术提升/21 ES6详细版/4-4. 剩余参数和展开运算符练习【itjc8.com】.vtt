WEBVTT

00:01.140 --> 00:03.700
这节课先不讲新知识

00:03.700 --> 00:05.540
把之前的知识巩固一下

00:05.540 --> 00:07.540
特别是这一张

00:07.540 --> 00:11.700
关于胜于参数以及展开运串符这一块

00:11.700 --> 00:14.980
因为默认值前面的东西都还比较简单

00:14.980 --> 00:17.140
展开运串符和胜于参数这一块

00:17.140 --> 00:20.980
就跟我们以前的鞋法上就区别表达

00:20.980 --> 00:22.900
就是我们把练习一下

00:22.900 --> 00:25.700
来吧 我们这里做两个练习

00:25.700 --> 00:29.540
首先我们做这么一个页面

00:30.100 --> 00:31.540
这个是换个名字吧

00:31.540 --> 00:34.180
一个是求最大值和最小值

00:34.180 --> 00:35.940
有这么一个页面

00:35.940 --> 00:39.220
然后呢 新建的节识

00:39.220 --> 00:42.740
做一个非常简单的练习

00:43.940 --> 00:44.740
来吧

00:49.940 --> 00:51.380
好 比方说啊

00:51.380 --> 00:55.060
我相信很多同学都应该自己能够写出来

00:55.060 --> 00:58.580
比方说呢 我们这里有这么一个数组

00:59.860 --> 01:02.420
这个数组里边有很多的数字

01:02.420 --> 01:03.460
很多数字

01:03.460 --> 01:05.380
我们就写个真实的例子吧

01:05.380 --> 01:07.060
比方说这里有个DIV

01:07.060 --> 01:10.500
DIV里边有一些input元素

01:10.500 --> 01:12.820
有一些p元素

01:12.820 --> 01:13.940
有10个嘛

01:13.940 --> 01:16.500
每个p元素下面有一个input元素

01:16.500 --> 01:18.500
内型的是number

01:18.500 --> 01:21.620
这么一个input元素

01:21.620 --> 01:23.460
好 我们运行出来看一下

01:24.980 --> 01:25.860
运行出来

01:26.900 --> 01:27.940
好 你看啊

01:28.020 --> 01:30.340
那么这里不是有很多的input元素吗

01:30.340 --> 01:30.820
对吧

01:30.820 --> 01:32.100
好 那么下边呢

01:32.100 --> 01:34.660
我们给他再给他一个value值得了

01:34.660 --> 01:36.580
再给他一个value值

01:36.580 --> 01:42.140
um value了等于0

01:42.140 --> 01:43.180
好了啊

01:43.180 --> 01:43.820
你看看

01:43.820 --> 01:45.020
好 没问题吧

01:45.020 --> 01:46.220
好 那么接下来呢

01:46.220 --> 01:47.900
我们在下边呢

01:47.900 --> 01:49.420
有一个按钮

01:49.420 --> 01:51.100
有一个这么一个按钮

01:52.060 --> 01:53.820
好 现在呢

01:53.820 --> 01:55.420
我们就计算

01:55.420 --> 01:57.260
就计算嘛

01:57.260 --> 01:58.780
点击按钮的时候呢

01:58.780 --> 02:00.780
我们希望能够导到一个效果

02:00.780 --> 02:01.980
就在下面那显

02:01.980 --> 02:03.020
就在这边那显

02:03.020 --> 02:04.140
就在这吧

02:04.140 --> 02:07.100
显示目前你所有的文本框里边的

02:07.100 --> 02:08.540
最大值和最小值

02:08.540 --> 02:10.940
这里边有这么一个

02:10.940 --> 02:13.180
两个H2元素吧

02:13.180 --> 02:18.140
这是最大值

02:18.140 --> 02:20.060
里面一个span

02:20.060 --> 02:21.500
给他个id

02:21.500 --> 02:25.580
max span max

02:25.580 --> 02:27.500
好 那么后下边呢

02:27.580 --> 02:33.420
就有一个最小值span min

02:33.420 --> 02:35.500
就做这么一个简单的例子

02:35.500 --> 02:36.620
懂我的意思吧

02:36.620 --> 02:39.500
点击计算就可以把这里算出来

02:39.500 --> 02:41.580
好 我们把这个方向有点嘛

02:41.580 --> 02:44.940
拿过来啊

02:44.940 --> 02:47.740
看清楚一点

02:47.740 --> 02:50.140
好 就这样吧

02:50.140 --> 02:52.060
好 那么现在我们来写借识

02:52.060 --> 02:54.380
那么我们这里首先要写一个函数

02:54.380 --> 02:57.420
这个函数呢能够把文本框里边的

02:57.420 --> 03:00.780
所有值呢放到一个数组里边去

03:00.780 --> 03:02.540
我们就这里写个函数

03:02.540 --> 03:04.380
get values

03:04.380 --> 03:07.180
得到文本框里边所有的数字

03:07.180 --> 03:08.940
把它放到一个数组里边去

03:08.940 --> 03:10.060
那这个怎么写呢

03:10.060 --> 03:13.180
document to queries negative all

03:13.180 --> 03:15.340
是不是用css选择器

03:15.340 --> 03:18.540
来选中所有的input元素

03:18.540 --> 03:19.740
对吧 这里是不是选中了

03:19.740 --> 03:21.740
所有的input元素

03:21.740 --> 03:23.420
input

03:23.420 --> 03:24.140
好 接下来呢

03:24.140 --> 03:25.740
我们是不是可以循环它

03:25.740 --> 03:27.340
对不对

03:27.340 --> 03:29.340
for each

03:29.340 --> 03:31.180
for each来进行循环

03:31.180 --> 03:34.460
好 那么每一个input元素

03:34.460 --> 03:36.300
每一个 我们或者用那个吧

03:36.300 --> 03:38.860
我就担心里面没有学过这个for each

03:38.860 --> 03:44.140
i等于0 i小于input length

03:44.140 --> 03:46.540
i加加

03:46.540 --> 03:50.140
每一次循环是不是可以拿到一个input元素

03:50.140 --> 03:53.100
对吧 那么把它的value值是不是给取出来啊

03:53.100 --> 03:54.620
这个没问题吧

03:54.700 --> 03:55.740
拿到一个input元素

03:55.740 --> 03:56.860
把它value值取出来

03:56.860 --> 03:57.740
然后呢

03:57.740 --> 04:00.300
把它这个value值转换成数字

04:00.300 --> 04:03.340
转换成数字放到数组里边去

04:03.340 --> 04:06.140
所以说我们这里得写这么一个数组

04:06.140 --> 04:07.740
lambers

04:07.740 --> 04:08.860
有这么一个数组

04:08.860 --> 04:10.060
每运行一次

04:10.060 --> 04:11.980
我们把lambers的数组里边的

04:11.980 --> 04:13.980
push一个加一下

04:13.980 --> 04:15.260
加什么呢

04:15.260 --> 04:16.300
就加这个东西

04:16.300 --> 04:17.820
前面加个加号什么意思

04:17.820 --> 04:19.580
就是把它转换成数字

04:19.580 --> 04:19.980
当然呢

04:19.980 --> 04:21.820
也可以用有很多种方式

04:22.220 --> 04:23.260
push int

04:23.260 --> 04:24.460
push float

04:24.460 --> 04:25.580
或者是number

04:25.580 --> 04:28.380
那构造函数都可以搞定这件事情

04:28.380 --> 04:30.060
好 numbers

04:30.060 --> 04:30.620
接下来呢

04:30.620 --> 04:31.580
我们输出一下

04:32.700 --> 04:33.820
numbers

04:33.820 --> 04:34.620
看一下

04:34.620 --> 04:35.980
保存

04:35.980 --> 04:36.940
这边

04:36.940 --> 04:37.900
点击检查

04:37.900 --> 04:38.940
控制台

04:38.940 --> 04:39.420
来

04:39.420 --> 04:40.540
怎么回事

04:41.500 --> 04:43.900
输出的get values

04:43.900 --> 04:45.900
输出这个调整函数的结果

04:45.900 --> 04:47.180
你看是不是得到一个数组了

04:47.180 --> 04:48.140
对吧

04:48.140 --> 04:48.540
好

04:48.540 --> 04:49.820
就是这个函数

04:49.980 --> 04:51.260
只要调整它就可以得到

04:51.260 --> 04:52.620
所有文门框里边的数

04:55.180 --> 04:57.020
所有文门框里边的数字

04:57.020 --> 04:58.140
形成的数组

04:59.020 --> 05:01.340
好那么接下来给按钮注册点击事件

05:01.340 --> 05:03.900
我们用document query selector

05:03.900 --> 05:06.300
找到这个按钮

05:06.300 --> 05:07.020
button

05:07.900 --> 05:09.020
找到这个按钮

05:09.020 --> 05:10.700
然后呢给它注册

05:10.700 --> 05:11.900
点击事件

05:12.380 --> 05:13.740
第一天onclick

05:14.860 --> 05:16.140
好点击的时候

05:16.140 --> 05:17.420
我们要干嘛呢

05:17.500 --> 05:20.300
我们要计算出最大值和最小值

05:20.300 --> 05:21.660
然后显示到这

05:21.660 --> 05:23.260
所以说我们这里又涉及到一个问题

05:24.140 --> 05:25.500
你给我一个数组

05:25.500 --> 05:27.660
我需要把最大值和最小值

05:27.660 --> 05:28.860
要计算出来

05:28.860 --> 05:30.300
那数组很容易得到

05:30.300 --> 05:31.900
比方说这里数组怎么得到

05:31.900 --> 05:32.860
numbers

05:32.860 --> 05:34.060
get values

05:34.060 --> 05:34.540
对吧

05:34.540 --> 05:35.740
是不是得到

05:36.780 --> 05:38.700
文门框中的

05:39.820 --> 05:42.940
框中的所有数字

05:42.940 --> 05:44.860
形成的数组

05:44.860 --> 05:45.660
是不是很容易得到

05:46.300 --> 05:47.420
那么关键是

05:47.420 --> 05:48.620
我们要怎么样得到

05:48.620 --> 05:50.620
根据一个数组来求最大值最小值呢

05:50.620 --> 05:52.460
好我们这里又写个函数

05:53.180 --> 05:55.820
get max得到最大值

05:56.380 --> 05:57.900
你给我一个数组

05:57.900 --> 05:59.500
我来帮你得到一个最大值

06:00.140 --> 06:01.020
再来一个函数

06:01.660 --> 06:02.380
get me

06:03.020 --> 06:04.140
你给我一个数组

06:04.140 --> 06:05.420
我要得到最小值

06:06.700 --> 06:08.380
或者说我们不写函数就在这里写吧

06:08.380 --> 06:09.660
因为这个单码其实没多少

06:10.300 --> 06:11.980
那么我们怎么来写这个东西呢

06:12.700 --> 06:16.220
我们知道在这个max对箱里边

06:16.220 --> 06:19.660
就是get里面本来生购门提供了一个函数

06:19.660 --> 06:20.940
叫做max

06:20.940 --> 06:21.900
还记得吗

06:21.900 --> 06:23.260
有这么一个函数

06:23.260 --> 06:25.020
这个函数呢

06:25.020 --> 06:27.660
它的用法就是说

06:27.660 --> 06:29.660
你给它一些数字

06:29.660 --> 06:31.660
它就能够求出最大值最小值

06:31.660 --> 06:32.700
我们来看一下吧

06:33.260 --> 06:34.780
max

06:34.780 --> 06:35.500
max

06:35.500 --> 06:36.700
你给它一些数字

06:36.700 --> 06:38.220
它的参数是这样传令的

06:38.220 --> 06:40.140
你看是不是可以求出最大值

06:41.100 --> 06:43.020
那么同样的另外一个函数

06:43.020 --> 06:44.460
就是另这个函数

06:44.460 --> 06:45.500
你给它一个

06:45.500 --> 06:47.580
这一些数字它能求出最小值

06:47.580 --> 06:50.300
但是关键是它传的不是数组

06:50.300 --> 06:51.500
它传的是什么

06:51.500 --> 06:53.420
传的是那种罗利的方式

06:53.420 --> 06:55.020
把所有的参数传进去

06:55.900 --> 06:59.020
但是就是以前我们没有学习剩余参数之前

06:59.020 --> 07:00.060
我们得怎么做呢

07:00.060 --> 07:01.660
我们是不是得这样做啊

07:01.660 --> 07:02.220
max

07:02.220 --> 07:04.380
然后呢用什么apply对吧

07:05.020 --> 07:06.140
用apply

07:06.140 --> 07:08.060
然后呢z绑定z

07:08.060 --> 07:09.420
z绑定啥呢

07:09.580 --> 07:12.700
z绑定的就是那个

07:12.700 --> 07:14.300
low

07:14.300 --> 07:15.980
然后呢其他的参数呢

07:15.980 --> 07:17.500
其他参数形成的数组呢

07:17.500 --> 07:18.780
把lambers传进去

07:18.780 --> 07:19.340
对吧

07:19.340 --> 07:21.020
用这种方式来传数组

07:21.020 --> 07:22.620
我们这里有个数组

07:22.620 --> 07:24.220
但是它要的不是数组

07:24.220 --> 07:25.980
它要的是罗列的参数

07:25.980 --> 07:27.340
所以说呢我们这样子

07:27.340 --> 07:29.900
用apply这种方式把数组给它

07:29.900 --> 07:31.020
那么apply这个函数呢

07:31.020 --> 07:32.620
它会把数组里边的东西呢

07:32.620 --> 07:34.300
依次作为参数传过去

07:34.300 --> 07:36.300
这是apply这个函数它的作用

07:37.180 --> 07:39.180
但是现在我们学了剩余参数过后

07:39.180 --> 07:40.220
还需不需要这样做

07:40.220 --> 07:41.340
就不需要了

07:41.340 --> 07:42.060
我们怎么办

07:42.060 --> 07:43.820
是不是展开运算幅

07:43.820 --> 07:46.700
把这个lambers展开就玩笑了

07:46.700 --> 07:47.100
对不对

07:47.100 --> 07:48.940
这就求出了最大值

07:48.940 --> 07:49.660
最大值呢

07:49.660 --> 07:51.420
我们把它放到哪呢

07:51.420 --> 07:53.820
放到这个spanmax里边

07:55.340 --> 07:56.940
我们spanmax

07:56.940 --> 07:59.740
点inertext

08:00.940 --> 08:01.580
等于这个

08:02.460 --> 08:03.820
同样的spanmin

08:04.460 --> 08:05.660
点inertext

08:05.660 --> 08:07.020
是不是等于最小字

08:07.020 --> 08:07.340
对吧

08:07.900 --> 08:08.220
好

08:08.300 --> 08:08.700
保存

08:10.460 --> 08:10.940
这里呢

08:10.940 --> 08:11.740
我们看一下

08:11.740 --> 08:12.540
点击计算

08:12.540 --> 08:13.260
两个出来了

08:13.260 --> 08:14.540
我们随便改一下吧

08:16.380 --> 08:17.340
这里也随便改一下

08:18.300 --> 08:19.020
5

08:19.020 --> 08:19.740
6

08:19.740 --> 08:19.980
7

08:21.020 --> 08:22.380
这里随便写一个

08:22.380 --> 08:22.460
2

08:23.100 --> 08:24.380
随便写一个复数吧

08:25.180 --> 08:25.900
随便写一个

08:30.430 --> 08:30.670
2

08:31.790 --> 08:32.110
11

08:32.110 --> 08:32.750
好

08:32.750 --> 08:33.230
点击

08:33.230 --> 08:34.750
你看是不是算出来了

08:34.750 --> 08:35.630
对不对

08:35.630 --> 08:37.310
这就是一个这么一个例子

08:37.310 --> 08:38.190
就是有的时候呢

08:38.190 --> 08:40.350
有一些系统给我们的函数呢

08:40.350 --> 08:42.430
它需要是罗列参数

08:42.430 --> 08:43.870
参数是罗列的

08:43.870 --> 08:44.830
那么这里呢

08:44.830 --> 08:46.510
你在用它的时候呢

08:46.510 --> 08:47.710
你就可以把这个

08:47.710 --> 08:48.990
数组里边的东西呢

08:48.990 --> 08:49.630
给它展开

08:49.630 --> 08:50.350
给它传进去

08:52.270 --> 08:53.630
其实我们说到这的话

08:53.630 --> 08:55.070
我再多说一句

08:55.070 --> 08:56.270
再多说一句

08:56.270 --> 08:57.550
就是说有的时候呢

08:57.550 --> 08:59.470
咱们写一个函数呢

08:59.470 --> 09:00.190
可能

09:01.230 --> 09:02.350
它的参数

09:02.350 --> 09:03.950
不是用的圣语参数

09:03.950 --> 09:05.710
但是我们传辑的时候呢

09:05.710 --> 09:06.830
依然可以使用

09:06.830 --> 09:08.750
展开运算幅传进去

09:08.830 --> 09:09.950
就是这些东西呢

09:09.950 --> 09:10.750
需要大家呢

09:10.750 --> 09:11.950
很灵活的运用

09:11.950 --> 09:13.230
我们再看一个另外一个例子

09:15.230 --> 09:15.710
这个例子呢

09:15.710 --> 09:17.150
就没有什么实际意义了

09:17.950 --> 09:19.550
我就说明一个问题就行了

09:23.740 --> 09:24.700
Test

09:27.180 --> 09:28.060
这个例子呢

09:28.060 --> 09:28.780
是这样子

09:28.780 --> 09:29.900
就是说我这里呢

09:31.980 --> 09:32.460
我这里呢

09:32.460 --> 09:33.580
有这么一个函数

09:33.580 --> 09:34.300
Test

09:34.300 --> 09:36.220
它要传三个参数ABC

09:36.940 --> 09:38.300
它要做什么事情呢

09:39.980 --> 09:41.500
我就把三个三个参数

09:42.460 --> 09:44.140
我没有什么事情可做

09:44.140 --> 09:45.740
我主要是给大家说一下

09:45.740 --> 09:46.860
传辑参数

09:46.860 --> 09:48.380
那我们怎么来用这个函数呢

09:48.380 --> 09:49.260
是不是这样子用

09:49.260 --> 09:49.500
是吧

09:49.500 --> 09:50.700
随便写个东西

09:50.700 --> 09:51.740
就这样子用进去

09:51.740 --> 09:53.100
这样子来用这个函数啊

09:53.100 --> 09:53.500
对不对

09:53.500 --> 09:54.620
这个没问题吧

09:54.620 --> 09:55.340
你看一下

09:57.660 --> 09:57.980
你看

09:58.780 --> 09:59.900
这样子来用这个函数

09:59.900 --> 10:00.860
是不是没问题

10:00.860 --> 10:01.340
哎

10:01.340 --> 10:02.300
这有的时候呢

10:02.300 --> 10:03.740
我们可能得到的参数呢

10:03.740 --> 10:05.660
是在一个数组里边

10:05.660 --> 10:07.100
比方说我们这里有一个数组

10:09.180 --> 10:10.300
一个数组随便写一些吧

10:10.460 --> 10:13.580
随便写个

10:13.580 --> 10:14.780
一个数组有三项

10:14.780 --> 10:16.700
我们希望把这个数组的第一项呢

10:16.700 --> 10:17.580
作为参数1

10:17.580 --> 10:18.940
第二项作为参数2

10:18.940 --> 10:20.540
第三项作为参数3

10:20.540 --> 10:22.380
那么我们要写的话

10:22.380 --> 10:23.980
以前是不是又得这样子Apply

10:23.980 --> 10:24.300
对吧

10:24.300 --> 10:25.820
又得用Apply的那种方式

10:25.820 --> 10:26.940
那么现在不用了

10:26.940 --> 10:28.620
我们仍然可以把这个数组

10:28.620 --> 10:29.900
展开传进去

10:29.900 --> 10:30.780
所以也可以

10:31.420 --> 10:31.740
对吧

10:31.740 --> 10:33.020
所以也可以啊

10:33.020 --> 10:34.220
展开过去相当于是吧

10:34.220 --> 10:35.740
第一项作为第一个参数第二

10:35.740 --> 10:37.340
是一样的对不对

10:37.340 --> 10:37.580
好

10:37.580 --> 10:38.380
你看一下

10:38.380 --> 10:39.100
是不是一样的

10:39.180 --> 10:41.820
也就是展开运算幅

10:41.820 --> 10:43.020
和生与参数

10:43.020 --> 10:45.340
他们并不是说要成对出现

10:45.340 --> 10:47.020
大家要消除这个误解

10:47.020 --> 10:48.220
展开就是展开

10:48.220 --> 10:50.700
就是把一个东西展开就完了

10:50.700 --> 10:53.100
它不管那边是不是用的生与参数

10:53.100 --> 10:55.340
总之展开来传进去玩事

10:55.340 --> 10:56.700
而生与参数呢

10:56.700 --> 10:58.700
它已经展开运算幅没有什么关系

10:58.700 --> 11:00.860
生与参数就是能用来搜集的

11:00.860 --> 11:02.060
它出现的最后

11:02.060 --> 11:02.940
你给我多少个

11:02.940 --> 11:04.620
我就把手机到一个数组里边去

11:04.620 --> 11:06.220
这两个要分开来看待

11:07.740 --> 11:09.020
我们这里再来个例子

11:09.100 --> 11:10.300
就是关于科理化

11:12.300 --> 11:13.100
关于科理化

11:13.100 --> 11:14.380
我又直接写到一面上得了

11:16.620 --> 11:17.660
这什么意思呢

11:17.660 --> 11:18.780
就是我们以

11:18.780 --> 11:20.540
不知道大家应该学过科理化吧

11:20.540 --> 11:21.020
学到这儿

11:21.020 --> 11:21.980
应该学过科理化

11:23.020 --> 11:24.540
就是说有这么一个函数

11:24.540 --> 11:25.820
科理化函数

11:25.820 --> 11:27.500
它又起这么一个作用

11:27.500 --> 11:29.900
比方说我们这里有这么一个函数

11:29.900 --> 11:30.780
叫做

11:33.820 --> 11:34.540
ADD吧

11:34.540 --> 11:36.700
就是cal计算

11:36.700 --> 11:38.220
进行的数学运算

11:38.220 --> 11:39.660
这个数学运算里边

11:39.660 --> 11:41.260
有这么四个函数

11:41.260 --> 11:43.260
ABCD

11:45.100 --> 11:45.820
四个函数

11:45.820 --> 11:46.700
ABCD

11:46.700 --> 11:48.140
我这里要算啥呢

11:48.140 --> 11:49.660
我这里要算的是

11:50.540 --> 11:53.180
A加B乘以C

11:53.900 --> 11:56.700
然后再减去D

11:57.180 --> 11:58.300
要算这个东西

11:58.300 --> 11:59.580
就随便举个例子

11:59.580 --> 12:00.700
这是一个计算函数

12:01.180 --> 12:02.540
那么我们这个假设

12:02.540 --> 12:04.540
这个函数要经常使用

12:04.540 --> 12:06.140
经常使用这个函数

12:06.140 --> 12:07.900
而且有一段时间

12:07.900 --> 12:09.420
我们在使用这个函数的时候

12:09.420 --> 12:10.460
发现一个问题

12:10.460 --> 12:13.500
我们往往给它的前面几个

12:13.500 --> 12:16.460
前面两三个函数都差不多

12:16.460 --> 12:17.580
比方说我们这里要得到

12:17.580 --> 12:18.460
这样的结果

12:18.460 --> 12:19.820
cal比方说5

12:21.420 --> 12:25.180
就1 2 3 4

12:25.180 --> 12:25.900
比方说啊

12:25.900 --> 12:26.540
举个例子吧

12:27.260 --> 12:28.700
这里是4 5

12:30.380 --> 12:31.020
5 6

12:32.060 --> 12:32.860
6 7

12:32.860 --> 12:33.980
我们举这么一个例子

12:34.620 --> 12:35.100
看一下吧

12:36.700 --> 12:37.260
这里运行

12:40.830 --> 12:41.390
你看一下

12:41.470 --> 12:42.270
我们现在要解决一个

12:42.270 --> 12:42.990
什么样的问题

12:44.590 --> 12:45.870
那么现在计算出来

12:45.870 --> 12:46.430
是没问题的

12:46.430 --> 12:47.950
这个数字你自己去验证

12:47.950 --> 12:49.310
肯定是没问题的

12:49.310 --> 12:49.950
只不过呢

12:49.950 --> 12:50.510
我们觉得

12:51.150 --> 12:53.230
假设我们在这一段时间内

12:53.230 --> 12:55.470
它的前面两个参数

12:55.470 --> 12:56.750
你看一下是不是一样的

12:57.390 --> 12:57.710
对吧

12:58.190 --> 12:59.550
前面两个参数是不是一样的

13:00.430 --> 13:01.470
前面两个参数一样的

13:01.470 --> 13:02.510
但是我们每次掉落的

13:02.510 --> 13:03.390
都得把它写一遍

13:03.390 --> 13:04.190
是不是挺麻烦的

13:04.670 --> 13:05.070
对不对

13:05.470 --> 13:06.190
挺麻烦的

13:06.590 --> 13:08.510
那么我们有没有更好的办法

13:08.510 --> 13:09.790
来解决这个问题呢

13:09.790 --> 13:10.830
我们就假设

13:10.990 --> 13:12.430
我们有这么一个函数

13:12.910 --> 13:13.630
叫做可瑞

13:15.390 --> 13:16.350
可瑞这么一个函数

13:16.910 --> 13:17.870
这个函数呢

13:18.110 --> 13:19.150
它有这么一个作用

13:19.550 --> 13:20.270
什么作用呢

13:20.270 --> 13:22.670
就是你给它传递一个函数进去

13:23.870 --> 13:26.590
然后呢给它传递一些参数进去

13:27.870 --> 13:28.750
比方说1和2

13:29.150 --> 13:29.630
就是说

13:30.350 --> 13:31.070
它到时候呢

13:31.070 --> 13:32.270
要执行这个函数

13:32.270 --> 13:33.390
前两个参数呢

13:33.390 --> 13:34.190
固定下来

13:34.510 --> 13:34.910
于是呢

13:34.910 --> 13:36.430
它会返回一个新的函数

13:37.550 --> 13:38.190
New Cal

13:39.230 --> 13:40.510
那么这个新的函数呢

13:40.590 --> 13:42.590
只需要搞定生育的参数就行了

13:43.550 --> 13:45.150
那么我前两个参数不用传了

13:45.630 --> 13:46.670
不用传了

13:47.150 --> 13:49.230
只需要传不足的参数

13:49.230 --> 13:50.110
只需要传那个

13:50.110 --> 13:52.030
你不够的参数给传进去就行了

13:52.430 --> 13:54.350
假设有这么一个可瑞这个函数

13:54.350 --> 13:55.630
它能搞定这件事情

13:55.630 --> 13:56.670
我给你一个函数

13:56.670 --> 13:58.190
然后给你固定一些参数

13:58.670 --> 13:59.710
前两个参数固定

13:59.710 --> 14:00.430
后面的参数呢

14:00.430 --> 14:00.990
我只

14:00.990 --> 14:02.270
它返回一个新的函数

14:02.270 --> 14:03.150
后面的参数呢

14:04.030 --> 14:04.830
后面再传递

14:05.710 --> 14:06.350
就是3

14:06.670 --> 14:08.030
就是这个相当于是什么

14:08.190 --> 14:11.390
1加上2乘以3减4

14:11.390 --> 14:12.350
这个相当于是

14:13.310 --> 14:15.710
1加上2乘以4减5

14:15.710 --> 14:16.030
对吧

14:16.030 --> 14:17.390
我们只需要传递

14:17.390 --> 14:18.990
变化的一部分就行了

14:18.990 --> 14:22.350
1加上2乘以5减6

14:23.310 --> 14:23.870
这就是

14:24.990 --> 14:28.270
1加上2乘以6减7

14:29.550 --> 14:30.190
没有意思吧

14:30.830 --> 14:31.790
我们要比方说

14:31.790 --> 14:32.430
要写着

14:32.430 --> 14:34.270
当然我现在运行肯定要抱错

14:34.270 --> 14:34.590
因为

14:35.470 --> 14:36.910
它说可瑞是not defend

14:37.070 --> 14:38.510
这个可瑞是不存在的

14:38.510 --> 14:40.030
那么我们要写这么一个

14:40.030 --> 14:40.830
可瑞这个东西

14:40.830 --> 14:41.790
该怎么来写呢

14:42.590 --> 14:43.790
该怎么来写呢

14:43.790 --> 14:45.230
我们再说一下

14:45.230 --> 14:47.230
这个可瑞还有一些别的用法

14:47.230 --> 14:47.950
比方说

14:47.950 --> 14:49.310
我们如果说在这里

14:49.310 --> 14:50.110
New Cal

14:50.990 --> 14:52.030
去调用它

14:52.030 --> 14:52.750
调用它呢

14:53.230 --> 14:54.430
但是我只传了一个

14:55.150 --> 14:56.350
比方说我只传了一个8

14:57.630 --> 14:58.430
只传了一个8

14:58.430 --> 14:58.910
你看着

15:00.110 --> 15:01.230
那么它这样子呢

15:01.230 --> 15:02.670
参数是不是还是不够

15:02.670 --> 15:04.270
之前固定了两个

15:04.270 --> 15:04.750
然后呢

15:04.750 --> 15:05.710
你这里呢

15:05.710 --> 15:06.510
又去调用它

15:06.510 --> 15:07.310
又传了一个

15:07.310 --> 15:08.350
是不是还差一个

15:08.350 --> 15:08.830
对吧

15:08.830 --> 15:09.950
这个函数是不是

15:09.950 --> 15:11.150
还差一个参数

15:11.150 --> 15:11.710
对不对

15:11.710 --> 15:13.390
所以还差一个参数

15:13.390 --> 15:14.110
因此呢

15:14.110 --> 15:15.550
这里参数还是不够

15:15.550 --> 15:16.910
参数不够的情况下

15:16.910 --> 15:18.750
它又返回一个新的函数

15:20.270 --> 15:21.390
又返回一个新的函数

15:21.390 --> 15:22.590
New Cal 2

15:23.150 --> 15:24.670
它又返回一个新的函数

15:24.670 --> 15:25.790
那么下面我们去

15:25.790 --> 15:27.070
如果说去调用这个

15:27.070 --> 15:29.390
New Cal 2的情况下呢

15:29.390 --> 15:31.070
只需要给它传一个参数也够了

15:31.070 --> 15:31.870
然后传一个9

15:32.670 --> 15:33.390
那么这样子呢

15:33.390 --> 15:34.430
得到的结构就是

15:34.510 --> 15:37.630
1加2乘以8-9

15:38.350 --> 15:39.470
好看一下就来吧

15:39.470 --> 15:40.350
好看一下

15:40.350 --> 15:41.950
把这个科瑞理解一下

15:41.950 --> 15:43.550
我相信你们应该是学过的

15:47.580 --> 15:48.540
没学过也没关系

15:49.420 --> 15:50.380
通过看这个例子

15:50.380 --> 15:51.100
你就能理解

15:51.740 --> 15:53.740
它是用来固定一些参数

15:54.940 --> 15:56.700
得到一个新的函数

15:59.100 --> 15:59.660
说一下吧

16:00.300 --> 16:00.860
科瑞

16:00.860 --> 16:02.060
叫做科理化

16:03.420 --> 16:06.620
用于固定一些

16:07.180 --> 16:09.100
固定某个函数的

16:10.140 --> 16:12.860
前面的参数

16:14.700 --> 16:17.020
得到一个新的函数

16:18.140 --> 16:19.420
新的函数

16:20.620 --> 16:21.580
调用时

16:23.100 --> 16:25.820
接收生于的参数

16:25.820 --> 16:27.500
就是还有哪一参数不足

16:27.500 --> 16:28.140
给它接收到

16:29.100 --> 16:29.660
对不对

16:29.660 --> 16:30.220
好看一下

16:30.860 --> 16:31.660
那如果说假设

16:31.660 --> 16:34.060
我们现在要写这么一个科瑞这个函数

16:34.620 --> 16:35.980
那么以前呢

16:35.980 --> 16:37.340
如果你们学过科瑞

16:37.340 --> 16:39.180
学过这个函数怎么去书写的话

16:39.260 --> 16:40.380
你会发现以前的

16:40.380 --> 16:41.180
等于用一些

16:41.180 --> 16:42.460
用 argument 来实现

16:42.460 --> 16:42.940
对吧

16:42.940 --> 16:44.540
我也不知道它给我传了哪些参数

16:44.540 --> 16:46.140
因为这里的参数是不是不固定的

16:46.540 --> 16:48.140
那么现在不用了

16:48.140 --> 16:49.420
现在我们学到生于参数

16:49.420 --> 16:50.940
也会看到生于参数

16:50.940 --> 16:52.060
写起来非常简单

16:54.460 --> 16:56.140
你看科瑞的格式是不是这样的格式

16:56.860 --> 16:58.380
第一个参数是不是接收一个函数

16:58.860 --> 16:59.180
对吧

16:59.660 --> 17:00.380
后边的参数

17:00.380 --> 17:01.660
我不知道它要固定几个

17:02.060 --> 17:03.420
我也不知道它要固定几个参数

17:03.420 --> 17:03.980
所以说我用

17:04.300 --> 17:06.220
用生于参数放到 arguments 里边

17:06.220 --> 17:07.820
那么后边你不管传了几个

17:07.820 --> 17:09.020
是不是放到这个数组里边来了

17:09.500 --> 17:09.900
对不对

17:10.780 --> 17:11.260
好

17:11.260 --> 17:13.020
那么这个科瑞返回什么呢

17:13.020 --> 17:14.540
是返回一个新的函数

17:16.460 --> 17:17.900
它返回了是不是一个新的函数

17:17.900 --> 17:18.780
这是一个高階函数

17:18.780 --> 17:19.260
看没

17:19.260 --> 17:21.420
你传了一个函数进去

17:21.420 --> 17:23.020
它给你返回一个新的函数

17:23.020 --> 17:24.940
你看这些是不是函数

17:24.940 --> 17:26.140
返回一个新的函数

17:26.140 --> 17:28.060
这个新的函数有几个参数呢

17:28.060 --> 17:29.340
是不是也不知道啊

17:30.300 --> 17:31.340
你看这个新的函数

17:31.340 --> 17:32.380
它有几个函数

17:32.380 --> 17:33.340
你看这里写了两个

17:33.340 --> 17:34.220
这里又写了一个

17:34.220 --> 17:34.700
对吧

17:34.700 --> 17:35.740
所以也不知道

17:36.060 --> 17:38.700
我们这里给它写个 sub arguments

17:40.540 --> 17:40.860
好

17:40.860 --> 17:41.660
那么接下来的

17:41.660 --> 17:43.740
我们看新的函数里边怎么来处理

17:44.460 --> 17:45.580
怎么来处理呢

17:45.580 --> 17:47.820
这个新的函数要干嘛呢

17:47.820 --> 17:48.780
新的函数呢

17:48.780 --> 17:51.260
如果说你给它传递了参数数量

17:51.260 --> 17:55.020
跟之前的这个参数数量加起来够了

17:56.220 --> 17:57.340
如果说这两个参数

17:58.220 --> 17:59.260
它的数量够了

18:00.220 --> 18:02.140
那么说明了怎么呢

18:02.140 --> 18:03.100
说明了我这个函数

18:03.100 --> 18:04.540
是不是要去执行它

18:04.620 --> 18:05.820
然后把参数给它传进去

18:06.460 --> 18:07.100
是这个意思吧

18:07.660 --> 18:08.540
我要去执行它

18:09.740 --> 18:11.340
然后来把这个参数给它传进去

18:11.340 --> 18:12.140
再看一下啊

18:12.140 --> 18:13.900
我这里是不是固定了几个

18:13.900 --> 18:15.260
我也不知道固定了几个

18:15.260 --> 18:16.940
然后来这一边又传进了一些

18:16.940 --> 18:17.500
对吧

18:17.500 --> 18:20.300
如果说两个参数的数量加起来够了

18:20.300 --> 18:23.020
就跟这个函数要的参数数量够了

18:23.020 --> 18:24.940
那么我们是不是就执行这个函数

18:24.940 --> 18:26.380
所以从我们这里判断

18:26.380 --> 18:28.620
我要把这两个数组拼起来

18:29.340 --> 18:30.780
把这两个数组拼起来

18:31.340 --> 18:32.060
怎么拼呢

18:32.140 --> 18:35.020
我们就可以用arguess

18:37.260 --> 18:37.980
给这个玩意儿

18:37.980 --> 18:39.180
给这个玩意儿

18:39.180 --> 18:41.900
是不是使用那个concast来进行拼接

18:41.900 --> 18:42.540
对吧

18:42.540 --> 18:43.900
concast来进行拼接

18:45.020 --> 18:46.460
那么它会返回一个新的数数

18:46.460 --> 18:48.220
或者是我们用这种方式

18:48.860 --> 18:49.980
或者是用这种方式

18:50.860 --> 18:51.740
等于什么呢

18:51.740 --> 18:54.380
等于它之前的arguess

18:54.380 --> 18:55.420
它里边的东西

18:55.420 --> 18:56.940
然后subarguess

18:57.980 --> 18:59.100
这两个是不是都是数组

18:59.580 --> 18:59.980
对吧

18:59.980 --> 19:01.500
我们皮数组是不是可以这样拼

19:02.300 --> 19:02.860
没问题吧

19:02.860 --> 19:03.820
能不能理解

19:03.820 --> 19:04.780
我们拼数组的话

19:04.780 --> 19:05.660
能不能这样拼

19:05.660 --> 19:06.460
是不是可以这样拼

19:07.340 --> 19:07.820
没问题吧

19:08.700 --> 19:10.220
是不是可以这样的拼接

19:10.220 --> 19:12.940
我们把这个数组里边的东西展开

19:12.940 --> 19:14.540
这个数组里边的东西再展开

19:14.540 --> 19:16.060
然后形成了一个新的数组

19:16.060 --> 19:17.980
然后把新的数组复制到这

19:17.980 --> 19:18.300
对吧

19:18.300 --> 19:19.180
复制到这个arguess

19:20.780 --> 19:21.100
好

19:21.100 --> 19:22.220
那么我们现在判断一下

19:22.220 --> 19:23.180
参数够不够呢

19:23.820 --> 19:25.500
如果说这个arguess

19:26.540 --> 19:27.260
the length

19:27.980 --> 19:30.620
这个参数的数量跟什么相等了

19:30.700 --> 19:33.660
跟这个函数形参相等了

19:33.660 --> 19:34.700
说明什么呢

19:34.700 --> 19:35.500
参数够了

19:36.860 --> 19:38.300
或者说如果大于了这个值

19:38.300 --> 19:39.740
大于等于了这个值

19:39.740 --> 19:41.500
是不是参数的数量够了

19:41.500 --> 19:43.340
我这里拼出来的

19:43.340 --> 19:45.340
你这一次给我的参数

19:46.460 --> 19:51.020
和我跟我之前的参数够了

19:52.220 --> 19:53.980
我们这里用换一个新的数数吧

19:53.980 --> 19:54.780
换一个新的数数

19:57.020 --> 19:57.980
arguess

19:58.700 --> 20:02.700
就是说我们这里的参数的数量展开

20:02.700 --> 20:04.060
这里的参数的展开

20:04.060 --> 20:05.500
然后得到一个新的数组

20:05.500 --> 20:07.100
那么这个新的数组呢

20:07.660 --> 20:11.900
它的参数的数量跟着我们这个函数

20:12.460 --> 20:13.100
点认识

20:13.100 --> 20:14.940
它需要的形参的数量

20:15.740 --> 20:16.780
大于等于了

20:16.780 --> 20:18.460
那么说明参数已经够了

20:18.460 --> 20:19.500
参数够了怎么办

20:19.500 --> 20:20.860
是不是执行这个函数

20:21.660 --> 20:23.980
你这里传列一个函数进来

20:23.980 --> 20:25.420
我们是不是执行这个函数

20:25.420 --> 20:27.660
然后把所有的参数全部给力

20:27.740 --> 20:28.780
那么怎么给你

20:28.780 --> 20:31.100
我这里是有一个参数数组对吧

20:31.100 --> 20:32.380
是不是有一个参数数组

20:32.380 --> 20:34.780
OK我这里把这个数组展开

20:34.780 --> 20:35.820
是把一个数组展开

20:35.820 --> 20:37.420
就全部把参数挪力给力了

20:37.420 --> 20:38.700
对吧就这么简单

20:39.420 --> 20:41.180
简单吧是不是就非常简单

20:41.180 --> 20:42.940
如果说这个函数有返回结果的话

20:42.940 --> 20:43.740
我这里也返回

20:44.940 --> 20:46.940
我把这个我把执行这个函数的返回结果

20:46.940 --> 20:47.980
给你返回

20:47.980 --> 20:49.340
就是参数够了的情况

20:49.340 --> 20:49.900
那你看一下

20:49.900 --> 20:51.420
如果说没有下面两行的话

20:51.420 --> 20:52.780
那么前面就已经可以搞定了

20:53.500 --> 20:54.780
你看356

20:55.420 --> 20:56.620
看来是不是可以搞定了

20:58.620 --> 20:59.340
没问题吧

20:59.340 --> 21:00.060
你好好看一下

21:01.660 --> 21:04.140
好那么如果说你参数不够了

21:07.100 --> 21:08.780
如果说你参数不够呢

21:10.140 --> 21:13.500
参数不够参数不够是不是要继续固定

21:13.500 --> 21:14.780
对吧继续固定

21:14.780 --> 21:16.380
之前是不是固定了两个

21:16.380 --> 21:18.380
对吧这个arctius里面是不是固定了两个

21:18.380 --> 21:19.580
放到这个数组里面去了

21:20.060 --> 21:22.380
这个数组里面是不是有相当于是固定的参数

21:22.380 --> 21:25.180
对吧这个数组里面相当于是固定的参数

21:25.260 --> 21:26.540
那么现在呢

21:26.540 --> 21:28.860
我们拼接完了过后形成一个新的数组

21:28.860 --> 21:30.540
这个新的数组还是不够

21:30.540 --> 21:31.740
还要继续固定

21:31.740 --> 21:32.460
那怎么办呢

21:33.500 --> 21:34.220
那怎么办呢

21:35.580 --> 21:37.820
一再重新去调整个creep玩了吗

21:38.380 --> 21:39.660
creep就是在固定的吗

21:39.660 --> 21:41.020
这个函数不就是在固定的吗

21:41.980 --> 21:43.180
把这个函数传进去

21:43.180 --> 21:44.700
还是这个函数没变

21:44.700 --> 21:46.860
只不过参数了以前固定了两个对吧

21:46.860 --> 21:49.020
现在我把arctius传进去

21:49.820 --> 21:52.380
arctius传进去是不是继续固定

21:52.380 --> 21:53.900
那这里是不是又要用到展开

21:54.380 --> 21:57.740
因为这边是用的是圣语参数

21:57.740 --> 21:59.500
它要搜集很多个对吧

21:59.500 --> 22:01.740
那如果说你整个把这个数组写进去的话

22:01.740 --> 22:04.460
那么它就把这个数组放到这个数组的第一箱去了

22:04.460 --> 22:06.940
所以说这里还是要展开一次传进进去

22:06.940 --> 22:08.300
它们它会进行搜集

22:08.300 --> 22:09.580
搜集到这个数组里面

22:09.580 --> 22:10.780
对吧继续固定

22:12.860 --> 22:13.980
保存看一下吧

22:14.460 --> 22:15.820
这不是正传了对不对

22:16.940 --> 22:17.740
你看一下

22:17.740 --> 22:19.660
一加上二乘一八二乘一八多少

22:19.660 --> 22:21.420
二八十六十七十七研究

22:22.860 --> 22:23.660
就没问题了

22:23.820 --> 22:25.180
这就是curry这种写法

22:25.740 --> 22:27.020
如果说这一块

22:27.020 --> 22:27.820
这一块

22:27.820 --> 22:29.500
如果我给大家有些我先说一下

22:30.220 --> 22:31.980
如果说你听不懂这一块

22:32.620 --> 22:33.660
那么说明了

22:33.660 --> 22:36.300
你可能之前没有接触过科理化

22:37.180 --> 22:38.460
没有写过科理化

22:38.460 --> 22:39.420
那么没有听懂

22:39.900 --> 22:40.620
没有关系

22:42.220 --> 22:44.940
这一块我只是为了讲这个展开运算符

22:44.940 --> 22:46.460
因为我觉得科理化这一块

22:47.020 --> 22:48.940
如果你之前学过这个科理化的话

22:48.940 --> 22:51.020
你学这个展开运算符来这里用起来

22:51.020 --> 22:53.180
你会发现比以前要方便很多

22:54.060 --> 22:56.220
如果说你没有学过科理化了

22:56.220 --> 22:59.020
你可以通过百度的手段

22:59.020 --> 22:59.340
对吧

22:59.340 --> 23:00.860
去看一下科理化是怎么回事

23:01.580 --> 23:02.700
去了解一下科理化

23:02.700 --> 23:03.900
那么它没有再

23:03.900 --> 23:05.980
再就是没有用展开运算符的时候

23:05.980 --> 23:06.700
是怎么写的

23:06.700 --> 23:08.220
然后再回过头来看这一块

23:08.940 --> 23:10.620
用展开运算符怎么写

23:10.620 --> 23:11.820
你瞬间就明白了

23:11.820 --> 23:13.740
展开运算符和收集

23:13.740 --> 23:15.020
收集差出的运算符

23:15.020 --> 23:16.940
都能给我们开发提供的很大的便利

23:17.740 --> 23:17.820
好

23:17.820 --> 23:18.780
这是关于这一块

23:20.620 --> 23:21.180
向美了

23:21.180 --> 23:22.700
做这么几个小的练习

23:22.780 --> 23:24.860
然后给大家讲一下这个展开运算符

23:24.860 --> 23:27.900
它的能给我们开发的带来一些方便

