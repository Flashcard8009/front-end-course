WEBVTT

00:00.750 --> 00:04.350
好 这个章节咱们来讲解构

00:04.350 --> 00:10.950
解构可以算是ES6里边也是用的非常非常普遍的一种语法

00:10.950 --> 00:15.550
通过这种语法我们可以非常方便的从一个对象里边

00:15.550 --> 00:18.750
或者是从一个数组里边来提取一些数据

00:18.750 --> 00:20.750
并把它保存到变量里边

00:20.750 --> 00:27.350
解构这个语法它的用处用的地方大概有两种

00:27.350 --> 00:29.350
一种是对于对象的解构

00:29.350 --> 00:31.350
一种是对于数组的解构

00:31.350 --> 00:32.750
我们分成两节后来讲

00:32.750 --> 00:34.550
其实东西都非常非常简单

00:34.550 --> 00:37.750
你只要学习的一个 另一个一听 你明白了

00:37.750 --> 00:39.750
这张东西并不多

00:39.750 --> 00:43.150
我们这节课首先来讲解对象的解构

00:43.150 --> 00:45.750
那么首先我们来认识一下什么叫解构呢

00:45.750 --> 00:52.750
解构其实就是使用ES6的一种语法规则

00:52.750 --> 00:56.550
将一个对象或数组

00:56.750 --> 01:02.350
一个对象会数组的某个属性提取到

01:02.350 --> 01:05.550
一个某个变量中

01:05.550 --> 01:07.550
就这么个意思 就起这么一个作用

01:07.550 --> 01:11.050
它其实你要说没有解构

01:11.050 --> 01:13.550
能不能解代吗 当然可以 没有任何问题

01:13.550 --> 01:15.750
只是说解构了能够非常方便的

01:15.750 --> 01:17.750
能够帮助我们来书写一些代码

01:17.750 --> 01:19.750
比方说几个例子

01:19.750 --> 01:22.050
咱们以前有这么一个对象

01:22.050 --> 01:24.550
比方说我们有这么一个U字

01:25.550 --> 01:27.550
对象里面有一些属性

01:27.550 --> 01:33.550
连零 性别 等等等等

01:33.550 --> 01:35.550
有这么一些属性

01:35.550 --> 01:37.550
好 再来一个

01:37.550 --> 01:39.550
Province

01:39.550 --> 01:41.550
再来一个Advice

01:41.550 --> 01:44.550
主子 主子的话来一个Province

01:44.550 --> 01:46.550
一个四川

01:49.550 --> 01:51.550
然后来一个City

01:51.550 --> 01:53.550
City 程度

01:53.550 --> 01:55.550
比方说有这么一个对象

01:55.550 --> 01:58.550
那么有的时候我们这个对象里面有很多属性

01:58.550 --> 02:00.550
可能我们后面要操作这个对象的话

02:00.550 --> 02:01.550
不是那么方便

02:01.550 --> 02:03.550
比方说我们要读取这个对象的一些属性

02:03.550 --> 02:06.550
该怎么读 是不是用User 底耳什么

02:06.550 --> 02:09.550
那如果说代码写得多的话

02:09.550 --> 02:12.550
比方说我们要经常用到用户的年龄

02:12.550 --> 02:14.550
用户的年龄 要到处要用

02:14.550 --> 02:17.550
是不是我们始终要多写这么一段代

02:17.550 --> 02:20.550
始终要一个对象名 底耳什么

02:20.550 --> 02:22.550
包括什么性名 性别这些属性

02:22.550 --> 02:23.550
我们到处都要用的话

02:23.550 --> 02:25.550
那么这样子书写起来

02:25.550 --> 02:27.550
感觉有些麻烦 仅此而已

02:27.550 --> 02:30.550
所以说解构可以帮助我们做这个事情

02:30.550 --> 02:32.550
那如果没有解构我们以前咋做呢

02:32.550 --> 02:34.550
以前我们是不是得这样子写

02:34.550 --> 02:36.550
以前我们得这样子写

02:36.550 --> 02:38.550
只不过把它换成Var 对吧

02:38.550 --> 02:40.550
我们得这样子写

02:40.550 --> 02:42.550
先把它保存到变量里边

02:42.550 --> 02:45.550
然后我们再去使用这个变量

02:45.550 --> 02:46.550
我们以前得这么写

02:46.550 --> 02:48.550
其实这种写法没有任何问题

02:48.550 --> 02:50.550
只不过写起来又比较麻烦

02:50.550 --> 02:52.550
多写一句话呗

02:52.550 --> 02:53.550
如果说属性多了

02:53.550 --> 02:56.550
你还要写什么Name等于User.Name

02:56.550 --> 02:57.550
对吧

02:57.550 --> 02:59.550
你还要写什么

02:59.550 --> 03:02.550
还要写Sex等于User.Sex

03:02.550 --> 03:03.550
对不对

03:03.550 --> 03:05.550
是不是要写的东西很多

03:05.550 --> 03:07.550
那么解构其实就是来解决这个问题的

03:07.550 --> 03:11.550
它可以把一个对象的属性分解出来

03:11.550 --> 03:13.550
放到一个变量里边

03:13.550 --> 03:15.550
那么解构怎么写呢

03:15.550 --> 03:16.550
给它取个例子

03:16.550 --> 03:19.550
比方说我们这里有三个同名属性

03:19.550 --> 03:21.550
Name,Age,Sex

03:21.550 --> 03:23.550
四个吧

03:23.550 --> 03:25.550
有四个同名属性

03:25.550 --> 03:28.550
我们希望这四个同名属性

03:28.550 --> 03:31.550
就对应到对象里边的同名属性

03:31.550 --> 03:33.550
也就是说我们要做啥呢

03:33.550 --> 03:34.550
我们要做的事情

03:34.550 --> 03:35.550
其实就是这件事情

03:35.550 --> 03:37.550
我们把它写一遍

03:37.550 --> 03:42.550
Name等于Name,Age,Sex,Age

03:42.550 --> 03:44.550
四个变量对吧

03:44.550 --> 03:46.550
然后我们这样子复辞

03:46.550 --> 03:48.550
Name等于User.Name,Age

03:48.550 --> 03:50.550
等于User.Age

03:50.550 --> 03:51.550
然后呢

03:51.550 --> 03:55.550
Sex等于User.Sex,Adress

03:55.550 --> 03:57.550
等于User.Adress

03:57.550 --> 03:58.550
就是我们要实现

03:58.550 --> 03:59.550
上面在代码的效果

03:59.550 --> 04:01.550
以前我们只能这样子出写

04:01.550 --> 04:03.550
只能一句话一句话的写

04:03.550 --> 04:05.550
那么现在有了解构之后

04:05.550 --> 04:06.550
你看着

04:06.550 --> 04:08.550
我们用实现一个完全

04:08.550 --> 04:10.550
一样没有任何区别的功能

04:10.550 --> 04:11.550
你看我们现在怎么写

04:11.550 --> 04:13.550
我们现在这样子写

04:13.550 --> 04:16.550
直接来解构

04:16.550 --> 04:17.550
直接解构

04:17.550 --> 04:19.550
后边放对象

04:19.550 --> 04:20.550
就是复辞符号

04:20.550 --> 04:21.550
后边放对象

04:21.550 --> 04:22.550
前边放啥呢

04:22.550 --> 04:24.550
前边就放我们的变量

04:24.550 --> 04:30.550
Name,Age,Sex,Adress

04:30.550 --> 04:32.550
前边我们就放我们的变量

04:32.550 --> 04:33.550
好

04:33.550 --> 04:34.550
这个代码写完了之后

04:34.550 --> 04:36.550
它这里爆错了

04:36.550 --> 04:38.550
解构其实就是这样的语法

04:38.550 --> 04:39.550
后边放对象

04:39.550 --> 04:43.550
前边你把对象的属性分解出来

04:43.550 --> 04:44.550
那么这里的变量

04:44.550 --> 04:45.550
它就会去找对象里面

04:45.550 --> 04:46.550
对应的属性

04:46.550 --> 04:47.550
你把这句代码

04:47.550 --> 04:48.550
对照上面的代码

04:48.550 --> 04:49.550
是一样的效果

04:49.550 --> 04:50.550
是完全一样的效果

04:50.550 --> 04:52.550
其实它的意思就是什么呢

04:52.550 --> 04:55.550
我这里要把User的Name属性

04:55.550 --> 04:56.550
读出来

04:56.550 --> 04:58.550
放到同名的变量Name里边

04:58.550 --> 05:00.550
我要把User的Age属性

05:00.550 --> 05:01.550
读出来

05:01.550 --> 05:03.550
放到同名的变量Age里边

05:03.550 --> 05:04.550
就这么个意思

05:04.550 --> 05:06.550
跟上面代码作用完全一样

05:06.550 --> 05:07.550
为什么这里会爆错呢

05:07.550 --> 05:08.550
因为它认为

05:08.550 --> 05:10.550
你这个两个大过号

05:10.550 --> 05:12.550
它理解成为啥呢

05:12.550 --> 05:14.550
它理解成为了一个对象

05:14.550 --> 05:15.550
它理解成为了

05:15.550 --> 05:18.550
这个代码是一个对象

05:18.550 --> 05:20.550
一个对象字面量

05:20.550 --> 05:22.550
左边不是副字符号

05:22.550 --> 05:24.550
左边不是不能放对象字面量

05:24.550 --> 05:26.550
它认为这是一条语句

05:26.550 --> 05:28.550
然后这是一条语句

05:28.550 --> 05:30.550
它认为这条语句左边确实变量

05:30.550 --> 05:32.550
它认为现在的语法是这样子的

05:32.550 --> 05:33.550
是这样的语法

05:33.550 --> 05:35.550
所以它这里认为语法错了

05:35.550 --> 05:36.550
那么我们希望

05:36.550 --> 05:39.550
它要把这个东西看成一个整体

05:39.550 --> 05:40.550
我们希望那个浏览器

05:40.550 --> 05:42.550
把这个东西看成一个整体

05:42.550 --> 05:43.550
不可分割的整体

05:43.550 --> 05:44.550
是一个解构语句

05:44.550 --> 05:45.550
右边是对象

05:45.550 --> 05:46.550
左边是两个大过号

05:46.550 --> 05:50.550
这两个大过号表示的是解构的意思

05:50.550 --> 05:52.550
我们希望把它看成一个整体怎么办

05:52.550 --> 05:55.550
你只要跟它加成一个扩号就行了

05:55.550 --> 05:56.550
加成一个小扩号

05:56.550 --> 05:57.550
因为这种现象

05:57.550 --> 05:58.550
我们是不是用了很多了

05:58.550 --> 05:59.550
对不对

05:59.550 --> 06:00.550
加成小扩号过后

06:00.550 --> 06:02.550
它会把整个看成一个表达式

06:02.550 --> 06:03.550
那么现在它就认为

06:03.550 --> 06:04.550
它就理解了

06:04.550 --> 06:06.550
你这里是要做解构

06:06.550 --> 06:07.550
你要把对象里面的东西

06:07.550 --> 06:08.550
解构出来

06:08.550 --> 06:09.550
分解出来

06:09.550 --> 06:11.550
放到同名的变量里面

06:11.550 --> 06:12.550
那么现在我们输出

06:13.550 --> 06:15.550
来输出看一下

06:15.550 --> 06:16.550
保存

06:16.550 --> 06:17.550
我们看一下这边

06:17.550 --> 06:18.550
你看

06:18.550 --> 06:19.550
是不是得到了

06:19.550 --> 06:20.550
对吧

06:20.550 --> 06:23.550
我们之后就可以轻松的去使用

06:23.550 --> 06:26.550
这个变量里面的数据了

06:26.550 --> 06:28.550
不用每次去u的点

06:28.550 --> 06:29.550
写下比较麻烦

06:29.550 --> 06:30.550
就写这么一个作用

06:30.550 --> 06:31.550
就是从对象里面

06:31.550 --> 06:33.550
分解的一些东西出来

06:33.550 --> 06:35.550
而且解构还可以把

06:35.550 --> 06:38.550
这两条语句进行合并输写

06:38.550 --> 06:39.550
看着

06:39.550 --> 06:41.550
这两条语句进行合并输写

06:41.550 --> 06:44.550
比方说我们这里先是先定义变量

06:44.550 --> 06:46.550
然后再解构

06:46.550 --> 06:49.550
把解构出来的东西放到对应的变量

06:49.550 --> 06:51.550
对应的变量的值里面

06:51.550 --> 06:53.550
我们这两条语句可以一起输写

06:53.550 --> 06:54.550
怎么输写呢

06:54.550 --> 06:55.550
就这样子写

06:56.550 --> 06:57.550
就这样子写就完了

06:57.550 --> 06:59.550
这样子写的过后

06:59.550 --> 07:00.550
它的意思就是

07:00.550 --> 07:03.550
它的意思跟上面的意思完全一样

07:03.550 --> 07:05.550
或者说跟这里的含义

07:05.550 --> 07:06.550
是完全一样的

07:06.550 --> 07:08.550
它是一个语法堂

07:08.550 --> 07:09.550
它只是方便理解代

07:09.550 --> 07:10.550
它是做什么呢

07:10.550 --> 07:13.550
它是先定义4个变量

07:13.550 --> 07:17.550
然后从对象中

07:17.550 --> 07:23.550
读取同名属性放到变量中

07:23.550 --> 07:24.550
放到变量中

07:24.550 --> 07:26.550
它就丢起这么一个作用

07:26.550 --> 07:27.550
这是结构

07:28.550 --> 07:31.550
但是你千万不能这样子写

07:34.890 --> 07:36.890
你千万不能这样子写

07:36.890 --> 07:37.890
你千万不能这样子写

07:37.890 --> 07:38.890
这样子写的话要出问题的

07:38.890 --> 07:40.890
你看

07:40.890 --> 07:42.890
就语法错误了

07:42.890 --> 07:43.890
情况这里没有提示

07:43.890 --> 07:44.890
但是这是一个语法错误

07:44.890 --> 07:46.890
千万不能这样子写

07:46.890 --> 07:47.890
这样子写没有什么意义

07:47.890 --> 07:48.890
对吧

07:48.890 --> 07:49.890
你既然要解构

07:49.890 --> 07:50.890
一定要给它个东西

07:50.890 --> 07:51.890
它才能分解

07:51.890 --> 07:52.890
一定要给它个东西

07:52.890 --> 07:54.890
这是解构的语法

07:54.890 --> 07:55.890
就是方便我们写代

07:55.890 --> 07:56.890
其他没啥了

07:57.890 --> 07:59.890
然后我接下来看一下

07:59.890 --> 08:02.890
它这里边的一些小的细节

08:03.890 --> 08:04.890
第二个就是说

08:04.890 --> 08:06.890
在解构的时候

08:06.890 --> 08:07.890
有的时候可能解构不出来

08:07.890 --> 08:09.890
没有同名属性

08:09.890 --> 08:10.890
没有同名属性

08:10.890 --> 08:11.890
这个时候会怎么样

08:11.890 --> 08:12.890
会有一个undefend

08:12.890 --> 08:14.890
比方说我要解构一个abc

08:15.890 --> 08:17.890
那么这里abc这个属性

08:17.890 --> 08:18.890
是不是没有

08:18.890 --> 08:19.890
这个对象里边是没有这个属性

08:19.890 --> 08:21.890
那么这个变量有没有呢

08:21.890 --> 08:23.890
它是先定义变量

08:23.890 --> 08:24.890
先定义变量

08:24.890 --> 08:25.890
所以说

08:25.890 --> 08:27.890
它变量一定是存在的

08:27.890 --> 08:28.890
我们输出变量

08:28.890 --> 08:29.890
它并不会爆错

08:29.890 --> 08:30.890
但是它没有读到东西

08:30.890 --> 08:31.890
没读到东西的时候

08:31.890 --> 08:33.890
相当于是你这里做了个什么事

08:33.890 --> 08:36.890
相当于是你先定义了一个abc

08:37.890 --> 08:38.890
相当于是看上面的

08:38.890 --> 08:39.890
看上面的吧

08:39.890 --> 08:41.890
相当于是你前面定义了一个abc

08:41.890 --> 08:42.890
对吧

08:42.890 --> 08:43.890
那是不是undefend

08:43.890 --> 08:44.890
那肯定是undefend

08:44.890 --> 08:45.890
对不对

08:45.890 --> 08:46.890
那么这样子

08:46.890 --> 08:47.890
就读不到东西

08:47.890 --> 08:48.890
读不到东西的话

08:48.890 --> 08:49.890
就是undefend

08:49.890 --> 08:50.890
同样的

08:50.890 --> 08:52.890
不是说前面只能用net

08:52.890 --> 08:53.890
用const

08:53.890 --> 08:55.890
那么就表示你定义了变量的是不可变的

08:55.890 --> 08:57.890
如果你用net

08:57.890 --> 08:58.890
你定义了变量的是可变的

08:58.890 --> 09:00.890
就这么一个意思

09:00.890 --> 09:02.890
跟之前的并没有什么本质的区别

09:02.890 --> 09:03.890
好

09:03.890 --> 09:04.890
那么现在我们看一下

09:04.890 --> 09:05.890
如果说你有的时候

09:05.890 --> 09:06.890
在解构的时候

09:06.890 --> 09:08.890
找不到同名的属性

09:08.890 --> 09:09.890
那么这个时候

09:09.890 --> 09:12.890
你可能会希望有一个默认值

09:12.890 --> 09:14.890
那么如何在解构中使用默认值呢

09:14.890 --> 09:16.890
解构中使用默认值的语法

09:16.890 --> 09:17.890
非常简单

09:17.890 --> 09:19.890
就是属性名

09:19.890 --> 09:22.890
我们这里把它写在一个代码区域里边

09:22.890 --> 09:26.520
就是一个属性名

09:26.520 --> 09:27.520
属性名

09:27.520 --> 09:30.520
注意前边写上属性名

09:30.520 --> 09:31.520
也就是

09:31.520 --> 09:32.520
或者说是变量名

09:32.520 --> 09:33.520
对吧

09:33.520 --> 09:34.520
变量名

09:34.520 --> 09:36.520
同名变量

09:36.520 --> 09:37.520
什么叫同名变量

09:37.520 --> 09:39.520
跟属性名一样的变量

09:39.520 --> 09:41.520
然后如果说找不到这样的属性的话

09:41.520 --> 09:42.520
你给它一个默认值

09:42.520 --> 09:43.520
后面直接写上等号

09:43.520 --> 09:45.520
后面写上默认值

09:45.520 --> 09:46.520
就是这样的语法

09:46.520 --> 09:47.520
你看一下吧

09:47.520 --> 09:49.520
咱们比方说这里

09:49.520 --> 09:50.520
abc

09:50.520 --> 09:52.520
这个属性的可能

09:52.520 --> 09:53.520
对象里面没有

09:53.520 --> 09:54.520
没有的话

09:54.520 --> 09:55.520
给它附默认值

09:55.520 --> 09:56.520
像这种情况

09:56.520 --> 09:57.520
有很多

09:57.520 --> 09:59.520
比方说你用阿迦克斯请求

09:59.520 --> 10:00.520
从服务器拿到一个对象

10:00.520 --> 10:02.520
这个对象里面有的时候

10:02.520 --> 10:03.520
就是

10:03.520 --> 10:04.520
比方说有错误的时候

10:04.520 --> 10:06.520
有一个error数相

10:06.520 --> 10:07.520
没有错误的时候

10:07.520 --> 10:08.520
也没有error数相

10:08.520 --> 10:09.520
那么到底

10:09.520 --> 10:10.520
那么我们要解构的时候

10:10.520 --> 10:11.520
我也不知道

10:11.520 --> 10:12.520
它有没有error数相

10:12.520 --> 10:13.520
那我还是给它解构出来吧

10:13.520 --> 10:15.520
为了避免它

10:15.520 --> 10:16.520
不是undefend

10:16.520 --> 10:17.520
我们可以给它附置一个默认值

10:17.520 --> 10:18.520
那么这里呢

10:18.520 --> 10:19.520
怎么写呢

10:19.520 --> 10:20.520
是不是写个等号

10:20.520 --> 10:21.520
默认值

10:21.520 --> 10:22.520
比方说默认值123

10:22.520 --> 10:23.520
这样子呢

10:23.520 --> 10:24.520
如果说解构不到这个东西

10:24.520 --> 10:26.520
它就会有123这个默认值

10:26.520 --> 10:27.520
对吧

10:27.520 --> 10:28.520
当然解构到了过后

10:28.520 --> 10:29.520
如果说能拿到同名属性

10:29.520 --> 10:31.520
那肯定是用同名属性的值

10:31.520 --> 10:33.520
这个很简单

10:34.520 --> 10:35.520
好那么下面

10:35.520 --> 10:36.520
再下面一个

10:36.520 --> 10:37.520
看一个细节

10:37.520 --> 10:38.520
就是如果说

10:38.520 --> 10:40.520
你解构的属性名

10:40.520 --> 10:41.520
跟变量名不一样

10:41.520 --> 10:42.520
怎么办呢

10:42.520 --> 10:44.520
如果说你解构的属性名

10:44.520 --> 10:45.520
跟变量名不一样的话

10:45.520 --> 10:46.520
那么又要使用

10:46.520 --> 10:47.520
一种别的语法

10:47.520 --> 10:49.520
这样的语法

10:49.520 --> 10:51.520
那么如果说变量名

10:51.520 --> 10:52.520
跟属性名不一样

10:52.520 --> 10:53.520
就是属性名

10:53.520 --> 10:54.520
写前边

10:54.520 --> 10:55.520
冒号

10:55.520 --> 10:56.520
变量名

10:56.520 --> 10:57.520
写后边

10:57.520 --> 10:58.520
你这样写

10:58.520 --> 11:00.520
这样写就可以了

11:00.520 --> 11:01.520
好咱们看一下吧

11:01.520 --> 11:04.220
这就复制一个

11:05.220 --> 11:06.220
比方说

11:06.220 --> 11:07.220
再来

11:08.220 --> 11:09.220
我们这里

11:09.220 --> 11:12.220
比方说我要解构一个

11:12.220 --> 11:14.220
解构一个

11:16.220 --> 11:17.220
什么呢

11:17.220 --> 11:19.220
我们这个性别吧

11:19.220 --> 11:20.220
性别

11:20.220 --> 11:21.220
我们有个变量的名字

11:21.220 --> 11:23.220
它不叫做sex

11:23.220 --> 11:24.220
不叫做sex

11:24.220 --> 11:25.220
它叫做gender

11:25.220 --> 11:26.220
也是性别的意思

11:26.220 --> 11:27.220
叫做gender

11:27.220 --> 11:29.220
那么我想给它换一个名字

11:29.220 --> 11:30.220
你看一下

11:30.220 --> 11:31.220
就这样写

11:31.220 --> 11:32.220
那么这个是什么意思呢

11:33.220 --> 11:35.220
就表示先定义

11:35.220 --> 11:36.220
先定义

11:36.220 --> 11:37.220
四个变量

11:37.220 --> 11:38.220
哪四个变量

11:38.220 --> 11:40.220
分别是name

11:40.220 --> 11:42.220
分别是name

11:42.220 --> 11:43.220
age

11:43.220 --> 11:44.220
什么

11:44.220 --> 11:45.220
gender

11:45.220 --> 11:46.220
advice

11:46.220 --> 11:48.220
它是这么四个变量

11:48.220 --> 11:49.220
然后

11:50.220 --> 11:51.220
再从

11:51.220 --> 11:52.220
对象

11:52.220 --> 11:54.220
游热中

11:54.220 --> 11:55.220
读取

11:55.220 --> 11:56.220
同名

11:56.220 --> 11:57.220
属相

11:57.220 --> 11:58.220
复制

11:58.220 --> 11:59.220
那么其中

11:59.220 --> 12:00.220
其中

12:00.220 --> 12:02.220
gender比较例外

12:02.220 --> 12:03.220
gender

12:03.220 --> 12:04.220
它没有同名属相

12:04.220 --> 12:05.220
其中

12:05.220 --> 12:06.220
gender

12:06.220 --> 12:08.220
读取的是sex属相

12:08.220 --> 12:09.220
就这么个意思

12:09.220 --> 12:10.220
把sex属相

12:10.220 --> 12:11.220
冒号

12:11.220 --> 12:13.220
复制给gender

12:13.220 --> 12:14.220
那么这样子

12:14.220 --> 12:16.220
我们输出这句话会怎么样呢

12:16.220 --> 12:17.220
你觉得会怎么样

12:17.220 --> 12:18.220
会怎么样

12:18.220 --> 12:19.220
这会爆出

12:19.220 --> 12:21.220
sex is not defend

12:21.220 --> 12:22.220
有没有这个sex变量

12:22.220 --> 12:23.220
没有

12:23.220 --> 12:24.220
这里不是变量

12:24.220 --> 12:25.220
是结构的属性名

12:25.220 --> 12:26.220
没有这个变量

12:26.220 --> 12:27.220
你要用什么

12:27.220 --> 12:28.220
gender

12:29.220 --> 12:30.220
没有这个意思吗

12:30.220 --> 12:31.220
就完了

12:31.220 --> 12:32.220
就这么个意思

12:32.220 --> 12:34.220
如果说

12:34.220 --> 12:35.220
有人说

12:35.220 --> 12:37.220
如果说我既要用别名

12:37.220 --> 12:39.220
既要用

12:39.220 --> 12:41.220
非同名属性

12:41.220 --> 12:42.220
结构

12:42.220 --> 12:43.220
又要同时使用

12:43.220 --> 12:44.220
默认字怎么办

12:44.220 --> 12:45.220
你后边写就行了

12:45.220 --> 12:46.220
你后边写就行了

12:46.220 --> 12:47.220
后边写一下

12:47.220 --> 12:48.220
默认字就行了

12:48.220 --> 12:49.220
当然现在不会用到

12:49.220 --> 12:50.220
默认字的

12:50.220 --> 12:51.220
因为它结构出来

12:51.220 --> 12:52.220
有这个属相

12:52.220 --> 12:53.220
如果没有这个属性的话

12:53.220 --> 12:54.220
那么gender

12:54.220 --> 12:55.220
就会使用

12:55.220 --> 12:56.220
默认字

12:57.220 --> 13:00.980
不要默认字为难

13:00.980 --> 13:01.980
看没

13:01.980 --> 13:02.980
这就是

13:02.980 --> 13:03.980
这个结构

13:03.980 --> 13:04.980
结构

13:05.980 --> 13:07.980
其他的就没它了

13:07.980 --> 13:08.980
我最后再说一点

13:08.980 --> 13:10.980
一个小的地方

13:11.980 --> 13:12.980
有的时候

13:12.980 --> 13:13.980
我们结构的时候

13:13.980 --> 13:15.980
可能有这么一个需求

13:15.980 --> 13:17.980
我们要结构的东西

13:17.980 --> 13:18.980
比较深

13:18.980 --> 13:19.980
我们这里要读什么

13:19.980 --> 13:21.980
我们可能要读这个东西

13:21.980 --> 13:22.980
结构出

13:23.980 --> 13:25.980
结构出游热中的

13:25.980 --> 13:26.980
什么

13:26.980 --> 13:28.980
游热中的那个

13:28.980 --> 13:29.980
Name

13:29.980 --> 13:31.980
还有Promise

13:31.980 --> 13:32.980
我解构的

13:32.980 --> 13:33.980
我要得到的不是二岁

13:33.980 --> 13:35.980
是我要得到Promise

13:35.980 --> 13:36.980
那这个东西怎么办

13:36.980 --> 13:37.980
怎么来结构这两个东西

13:37.980 --> 13:40.980
你要用什么就结构什么

13:40.980 --> 13:41.980
而且我大家注意

13:41.980 --> 13:42.980
还有一个点

13:42.980 --> 13:43.980
要大家注意的就是

13:43.980 --> 13:46.980
结构了不会影响原始对象

13:46.980 --> 13:47.980
结构

13:47.980 --> 13:49.980
不会

13:49.980 --> 13:51.980
不会对原

13:51.980 --> 13:53.980
被结构的目标

13:53.980 --> 13:56.980
造成任何影响

13:56.980 --> 13:57.980
因为结构的时候

13:57.980 --> 13:58.980
不是说

13:58.980 --> 14:00.980
你就把对象给它拆散

14:00.980 --> 14:01.980
对象还是对象

14:01.980 --> 14:02.980
我们只是把东西提取出来

14:02.980 --> 14:03.980
放到边量里边

14:03.980 --> 14:04.980
比方说

14:04.980 --> 14:05.980
我们现在要做这么一件事

14:05.980 --> 14:07.980
结构出Name和Promise

14:07.980 --> 14:08.980
怎么办

14:08.980 --> 14:09.980
我们知道

14:09.980 --> 14:10.980
结构而追实是很简单的

14:10.980 --> 14:11.980
对吧

14:11.980 --> 14:12.980
比方说我们用Const

14:12.980 --> 14:14.980
结构而追实是很简单的

14:14.980 --> 14:15.980
怎么结构呢

14:15.980 --> 14:17.980
就是Name而追实

14:17.980 --> 14:19.980
很轻松就可以结构出来

14:19.980 --> 14:20.980
那如果说

14:20.980 --> 14:21.980
我们要结构的是

14:21.980 --> 14:23.980
追实里边的Promise

14:23.980 --> 14:24.980
那怎么办

14:24.980 --> 14:25.980
那怎么办

14:25.980 --> 14:26.980
你这样子写

14:26.980 --> 14:27.980
看着

14:29.980 --> 14:30.980
而追实里边

14:30.980 --> 14:31.980
我们再加个冒号

14:31.980 --> 14:32.980
但是这个时候

14:32.980 --> 14:33.980
就不是别名了

14:33.980 --> 14:34.980
我们后面

14:34.980 --> 14:35.980
继续写两个大号号

14:35.980 --> 14:37.980
对它进一步结构

14:37.980 --> 14:38.980
对这个而追实

14:38.980 --> 14:39.980
进一步结构

14:39.980 --> 14:40.980
你不要写它Promise

14:40.980 --> 14:41.980
就这么写

14:43.980 --> 14:44.980
这样子写的过后

14:44.980 --> 14:45.980
我们来看一下

14:45.980 --> 14:46.980
如果说我们输出

14:46.980 --> 14:48.980
这些东西肯定没了

14:48.980 --> 14:49.980
这些边量肯定不存在了

14:49.980 --> 14:50.980
那么现在关键问题是

14:50.980 --> 14:52.980
而追实这个东西存不存在

14:52.980 --> 14:54.980
我们把这三个东西输出来

14:54.980 --> 14:55.980
答应出来

14:55.980 --> 14:56.980
它告诉你

14:56.980 --> 14:57.980
而追实 is not defend

14:57.980 --> 14:58.980
也就是这个地方

14:58.980 --> 14:59.980
它不会把而追实

14:59.980 --> 15:00.980
当成辩量

15:00.980 --> 15:01.980
你后面写了两个大号号

15:01.980 --> 15:02.980
它会对而追实

15:02.980 --> 15:04.980
进一步结构

15:04.980 --> 15:05.980
它是做这么一件事

15:05.980 --> 15:06.980
它不会把它

15:06.980 --> 15:07.980
复制到相应的辩量

15:07.980 --> 15:09.980
它是把它进一步结构

15:09.980 --> 15:10.980
所以说这个时候

15:10.980 --> 15:12.980
结构定义

15:12.980 --> 15:13.980
它是先定义了

15:13.980 --> 15:14.980
两个辩量

15:15.980 --> 15:16.980
Name

15:16.980 --> 15:17.980
Promise

15:18.980 --> 15:19.980
后面我不说了

15:19.980 --> 15:22.980
然后再结构

15:22.980 --> 15:23.980
怎么结构呢

15:23.980 --> 15:25.980
把User的Name属性

15:25.980 --> 15:26.980
拿出来

15:26.980 --> 15:27.980
放到Name辩量里边

15:27.980 --> 15:29.980
把User的而追实

15:29.980 --> 15:30.980
Promise属性

15:30.980 --> 15:31.980
拿出来

15:31.980 --> 15:33.980
放到辩量Promise里边

15:33.980 --> 15:35.980
这对对象的进一步结构

15:35.980 --> 15:36.980
那如果说

15:36.980 --> 15:37.980
后面还有对象

15:37.980 --> 15:38.980
如果说

15:38.980 --> 15:39.980
我们还要对这个对象进一步结构

15:39.980 --> 15:40.980
你又接着写

15:40.980 --> 15:41.980
就这么一个意思

15:41.980 --> 15:42.980
就这么一个意思

15:42.980 --> 15:44.980
这就是深层次的结构

15:44.980 --> 15:46.980
就结构出来两个辩量

15:46.980 --> 15:47.980
没问题吧

15:47.980 --> 15:48.980
这是结构

15:48.980 --> 15:49.980
结构的语法

15:49.980 --> 15:51.980
在很多时候操作一些

15:51.980 --> 15:53.980
属性非常非常多的对象的时候

15:53.980 --> 15:55.980
我们要经常用这些属性的时候

15:55.980 --> 15:56.980
把结构成辩量

15:56.980 --> 15:57.980
特别特别舒服

15:57.980 --> 15:59.980
特别特别方便

15:59.980 --> 16:00.980
这是关于

16:00.980 --> 16:01.980
结构的对象

16:01.980 --> 16:03.980
结构了这么一种语法

