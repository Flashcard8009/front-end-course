WEBVTT

00:00.690 --> 00:04.990
上级课我们学习了内的最基本的使用方式

00:04.990 --> 00:09.990
然后这些课咱们来看一下内里面的一些其他的语法

00:09.990 --> 00:13.690
也是ES6或者是ES7里面给你提供的一些语法

00:13.690 --> 00:18.690
我们一个个说 首先第一个可计算的成员名

00:18.690 --> 00:19.690
啥意思呢

00:19.690 --> 00:23.690
就说我们有的时候写的这么一个内

00:23.690 --> 00:26.690
比方说我们就把上级课的内拿过来得

00:26.690 --> 00:29.690
就把上级课的内拿过来得了

00:29.690 --> 00:33.690
写上这么一个内 举个例子 咱们就下举个例子

00:33.690 --> 00:35.690
把语法说清楚就行了

00:35.690 --> 00:37.690
比方说我们这一里

00:37.690 --> 00:41.690
这个我们写的一个固定的名字 有一个方法Print

00:41.690 --> 00:43.690
但是有的时候我们可能会希望说

00:43.690 --> 00:46.690
这个方法的名字我是不确定的

00:46.690 --> 00:48.690
我也不知道它叫什么名字

00:48.690 --> 00:50.690
可能它的名字来自于另外一个辨量

00:50.690 --> 00:53.690
比方说有这么一个辨量

00:53.690 --> 00:57.690
就是PrintName这个辨量

00:57.690 --> 00:59.690
它是一个字不错Print

00:59.690 --> 01:02.690
那么我希望把这个辨量的值

01:02.690 --> 01:03.690
我也不知道这个值哪来的

01:03.690 --> 01:05.690
总之我希望把这个辨量的值

01:05.690 --> 01:06.690
作为这个方法的名字

01:06.690 --> 01:08.690
以前是很好做的 对吧

01:08.690 --> 01:09.690
以前咋写的

01:09.690 --> 01:11.690
以前AnimalPrototype

01:11.690 --> 01:14.690
然后PrintName不就完了吗

01:14.690 --> 01:16.690
用一个属性表达式

01:16.690 --> 01:17.690
属性表达式

01:17.690 --> 01:18.690
这样子是不是就可以复制了

01:18.690 --> 01:20.690
复制为一个函数

01:20.690 --> 01:21.690
但是现在怎么写呢

01:21.690 --> 01:25.690
现在的语法肯定是要比以前更加方便

01:25.690 --> 01:26.690
怎么写呢

01:26.690 --> 01:28.690
就利用ES6里面给我们提供的

01:28.690 --> 01:31.690
可计算的属性表达式

01:31.690 --> 01:32.690
我们之前学过的怎么写的

01:32.690 --> 01:33.690
就是两个大过号

01:33.690 --> 01:36.690
中货号PrintName

01:36.690 --> 01:38.690
PrintName

01:38.690 --> 01:39.690
你看一下吧

01:39.690 --> 01:41.690
这样子写就可以了

01:41.690 --> 01:43.690
这样子它就是把这个辨量的名字

01:43.690 --> 01:45.690
或者说这里边写任何一个表达式

01:45.690 --> 01:46.690
都可以

01:46.690 --> 01:47.690
写一个表达式

01:47.690 --> 01:48.690
把这个表达式的值

01:48.690 --> 01:50.690
作为它的成员名字

01:50.690 --> 01:51.690
当然如果说

01:51.690 --> 01:52.690
这里边的话就更简单了

01:52.690 --> 01:54.690
就准备要跟你以前写法是一样的

01:54.690 --> 01:55.690
主要说这

01:55.690 --> 01:56.690
你要的意思吗

01:56.690 --> 01:58.690
所以说现在我们如果说

01:58.690 --> 02:01.690
要去调用这个方法的话

02:01.690 --> 02:02.690
你可以这样调用

02:02.690 --> 02:06.190
你可以这样调用

02:06.190 --> 02:07.190
看着吧

02:08.190 --> 02:10.190
这里就不是PrintName了

02:10.190 --> 02:12.190
当然调用PrintName也可以

02:12.190 --> 02:13.190
但是如果你这样子写的话

02:13.190 --> 02:14.190
你就是假设

02:14.190 --> 02:16.190
已经知道了这个辨量里面的值了

02:16.190 --> 02:17.190
哪有什么意义呢

02:17.190 --> 02:18.190
对不对

02:18.190 --> 02:19.190
哪就没有什么意义的

02:19.190 --> 02:21.190
就是我们不知道这个辨量的值是什么

02:21.190 --> 02:23.190
那么我们怎么去调用呢

02:23.190 --> 02:24.190
现在肯定是没问题的

02:24.190 --> 02:25.190
你看输出了对吧

02:25.190 --> 02:26.190
输出了这个结果了

02:26.190 --> 02:28.190
那如果说你不知道这个辨量的值

02:28.190 --> 02:29.190
怎么做呢

02:29.190 --> 02:30.190
一样的吗对不对

02:30.190 --> 02:32.190
一样的PrintName

02:32.190 --> 02:33.190
是不是一样的

02:33.190 --> 02:35.190
用这种方式来调用

02:35.190 --> 02:36.190
把这个辨量的值

02:36.190 --> 02:37.190
作为它的属性名

02:37.190 --> 02:38.190
放到这儿

02:38.190 --> 02:39.190
使用这个属性

02:39.190 --> 02:40.190
那么这个属性

02:40.190 --> 02:41.190
它自然是一个方法

02:41.190 --> 02:42.190
那么调用它就完事了

02:42.190 --> 02:43.190
你看一下

02:44.190 --> 02:45.190
这是第一个

02:45.190 --> 02:46.190
第一个

02:46.190 --> 02:47.190
这个一说就明白了

02:47.190 --> 02:48.190
这是可以

02:48.190 --> 02:51.190
这是可计算的成员名

02:51.190 --> 02:53.190
第二个是

02:53.190 --> 02:55.190
getter和setter

02:55.190 --> 02:56.190
这个什么意思呢

02:56.190 --> 02:57.190
这个是呢

02:57.190 --> 02:58.190
对应到以前

02:58.190 --> 03:00.190
也是无里边里面学习的

03:00.190 --> 03:01.190
这个东西叫做Objects

03:01.190 --> 03:04.190
define property

03:04.190 --> 03:05.190
对吧

03:05.190 --> 03:06.190
是不是用这个东西

03:06.190 --> 03:07.190
以前的用这个东西

03:07.190 --> 03:08.190
可定义对吧

03:08.190 --> 03:09.190
可定义什么

03:09.190 --> 03:14.190
某个对象成员

03:14.190 --> 03:18.190
属性的读取和设置

03:18.190 --> 03:19.190
对不对

03:19.190 --> 03:20.190
是不是可以定义这个东西

03:20.190 --> 03:23.190
定义某个对象成员的属性和设置

03:23.190 --> 03:25.190
那么以前是不是略显麻烦一点

03:25.190 --> 03:28.190
我们用getter和setter略显麻烦

03:28.190 --> 03:29.190
那么现在我们怎么用呢

03:29.190 --> 03:33.190
如果说你要做成一个类似的效果

03:33.190 --> 03:34.190
你要做成一个类似的效果

03:34.190 --> 03:36.190
比方说这个年龄

03:36.190 --> 03:38.190
年龄这一块

03:38.190 --> 03:39.190
年龄这一块

03:39.190 --> 03:41.190
我们希望

03:41.190 --> 03:42.190
就是说

03:42.190 --> 03:43.190
它这个年龄

03:43.190 --> 03:44.190
你控制一下

03:44.190 --> 03:46.190
你不能是负数

03:46.190 --> 03:48.190
年龄不能是负数

03:48.190 --> 03:49.190
动物的年龄

03:49.190 --> 03:50.190
它给你1000岁

03:50.190 --> 03:51.190
比方说乌龟

03:51.190 --> 03:53.190
活的比较久一点

03:53.190 --> 03:55.190
活的比较久一点

03:55.190 --> 03:56.190
我给你1000岁

03:56.190 --> 03:58.190
你也不能是负数

03:58.190 --> 04:01.190
所以说我们最好是把年龄的设置

04:01.190 --> 04:05.190
和读取把它做成两个函数

04:05.190 --> 04:06.190
比方说我们这里

04:06.190 --> 04:07.190
写上一个

04:07.190 --> 04:09.190
写上两个方法

04:09.190 --> 04:11.190
set age

04:11.190 --> 04:12.190
对不对

04:12.190 --> 04:14.190
set age

04:14.190 --> 04:16.190
给我一个年龄

04:16.190 --> 04:18.190
你给我传一个年龄进来

04:18.190 --> 04:19.190
判断一下吧

04:19.190 --> 04:20.190
判断一下

04:20.190 --> 04:22.190
如果年龄小于年

04:22.190 --> 04:24.190
那么我就把年龄设为年

04:24.190 --> 04:25.190
不能太小

04:25.190 --> 04:26.190
lc

04:26.190 --> 04:28.190
年龄如果说大于1000

04:28.190 --> 04:30.190
那么我就设为1000

04:30.190 --> 04:31.190
1000是够了

04:31.190 --> 04:32.190
什么都够了

04:32.190 --> 04:34.190
然后我再给年龄复制

04:34.190 --> 04:36.190
比方说我们有一个属性

04:36.190 --> 04:37.190
叫做下滑线

04:37.190 --> 04:39.190
我们给它设置一个特殊的属性名

04:39.190 --> 04:40.190
那么我们最后

04:40.190 --> 04:42.190
把这个 age

04:42.190 --> 04:44.190
设置为什么 age

04:44.190 --> 04:45.190
对吧

04:45.190 --> 04:47.190
我们用函数就可以控制了

04:47.190 --> 04:49.190
可以控制它年龄的设置

04:49.190 --> 04:50.190
对不对

04:50.190 --> 04:51.190
那么这里设置年龄的时候

04:51.190 --> 04:52.190
我们是不是可以利用

04:52.190 --> 04:53.190
res

04:53.190 --> 04:54.190
set age来设置年龄

04:54.190 --> 04:55.190
对吧

04:55.190 --> 04:56.190
把这个年龄传进去

04:56.190 --> 04:57.190
能看懂吗

04:57.190 --> 04:58.190
这个代码

04:58.190 --> 04:59.190
能看懂吗

04:59.190 --> 05:00.190
看一下

05:00.190 --> 05:01.190
能不能看懂

05:02.190 --> 05:03.190
那么这里set age

05:03.190 --> 05:04.190
把年龄放进去了

05:04.190 --> 05:05.190
对吧

05:05.190 --> 05:06.190
是不是把年龄放进去了

05:06.190 --> 05:07.190
你给我传的参数

05:07.190 --> 05:08.190
年龄

05:08.190 --> 05:09.190
我把年龄就放进去了

05:09.190 --> 05:10.190
对不对

05:10.190 --> 05:11.190
放进去过后

05:11.190 --> 05:13.190
你是不是可以设置年龄

05:13.190 --> 05:14.190
对吧

05:14.190 --> 05:15.190
可以设置年龄

05:15.190 --> 05:17.190
你通过这个函数来设置年龄

05:17.190 --> 05:18.190
就可以保证

05:18.190 --> 05:20.190
这个年龄的始终在

05:20.190 --> 05:22.190
有效的值范围内

05:22.190 --> 05:23.190
好

05:23.190 --> 05:24.190
如果说你要读取年龄的话

05:24.190 --> 05:26.190
我也不让你直接读取

05:26.190 --> 05:28.190
我经过一段代码

05:28.190 --> 05:30.190
比如说我要年龄

05:30.190 --> 05:31.190
后边

05:31.190 --> 05:33.190
也比方说

05:33.190 --> 05:34.190
我在年龄后边

05:34.190 --> 05:36.190
加上一个中文

05:36.190 --> 05:37.190
中文多少多少税

05:37.190 --> 05:38.190
多少多少税

05:38.190 --> 05:39.190
那么我们可以控制的

05:39.190 --> 05:40.190
达到控制的目的

05:40.190 --> 05:42.190
get age

05:42.190 --> 05:43.190
得到年龄

05:43.190 --> 05:44.190
得到年龄我返回什么

05:44.190 --> 05:46.190
返回的就是一个年龄

05:46.190 --> 05:47.190
Z

05:47.190 --> 05:48.190
下滑线年龄

05:48.190 --> 05:49.190
因为保存了这个属性里面的

05:49.190 --> 05:50.190
你看

05:50.190 --> 05:51.190
我复制的时候

05:51.190 --> 05:52.190
是保存了这个属性里面的

05:52.190 --> 05:53.190
年龄等于什么

05:53.190 --> 05:55.190
等于一个

05:55.190 --> 05:57.190
在拼接上一个税

05:58.190 --> 06:00.190
你看一下吧

06:00.190 --> 06:01.190
看一下

06:01.190 --> 06:02.190
看一下个代码

06:02.190 --> 06:03.190
好好看一下

06:03.190 --> 06:04.190
那么之后

06:04.190 --> 06:05.190
我们要设置年龄

06:05.190 --> 06:06.190
是不是不要去直接

06:06.190 --> 06:07.190
给这个 age 复制

06:07.190 --> 06:10.190
而去雕用这个函数

06:10.190 --> 06:12.190
来完成给年龄复制

06:12.190 --> 06:14.190
我要得到年龄

06:14.190 --> 06:17.190
雕用这个函数来得到年龄

06:17.190 --> 06:18.190
你看这个是吧

06:18.190 --> 06:20.190
好咱们来看一下吧

06:20.190 --> 06:21.190
来看一下

06:21.190 --> 06:22.190
比方我们把它放到

06:22.190 --> 06:23.190
温度理想里面

06:23.190 --> 06:24.190
用挖

06:24.190 --> 06:25.190
挖的话就放到

06:25.190 --> 06:26.190
温度理想里面了

06:26.190 --> 06:27.190
看一下吧

06:27.190 --> 06:28.190
那么现在

06:28.190 --> 06:30.190
我们就不要给这个年龄

06:30.190 --> 06:31.190
直接复制了

06:31.190 --> 06:32.190
应该是吗

06:32.190 --> 06:33.190
应该set age

06:33.190 --> 06:34.190
比方说我们这里

06:34.190 --> 06:37.190
set age 为复的一半

06:37.190 --> 06:38.190
那么这样子

06:38.190 --> 06:39.190
我们看一下这个对象

06:39.190 --> 06:40.190
那么他的年龄

06:40.190 --> 06:41.190
是不是年龄

06:41.190 --> 06:42.190
对吧

06:42.190 --> 06:43.190
他一定不能是复数

06:43.190 --> 06:44.190
看没

06:44.190 --> 06:45.190
年龄一定是年

06:45.190 --> 06:46.190
好

06:46.190 --> 06:47.190
然后呢

06:47.190 --> 06:48.190
为什么我要给他下法宪

06:48.190 --> 06:49.190
当然不给下法宪也可以

06:49.190 --> 06:50.190
就是说

06:50.190 --> 06:51.190
我给下法宪的目的呢

06:51.190 --> 06:53.190
因为我们通常命名上

06:53.190 --> 06:55.190
就是不希望外面的人

06:55.190 --> 06:56.190
直接使用的东西

06:56.190 --> 06:57.190
我们一般会前面

06:57.190 --> 06:58.190
加上一个下法宪

06:58.190 --> 06:59.190
或者一些特殊制服

06:59.190 --> 07:00.190
告诉他

07:00.190 --> 07:01.190
提醒他

07:01.190 --> 07:02.190
这一些是一些特殊的属性

07:02.190 --> 07:03.190
你不要直接用

07:03.190 --> 07:04.190
你不要直接用

07:04.190 --> 07:06.190
这些系统保留了的一些属性

07:06.190 --> 07:07.190
是这么个意思

07:07.190 --> 07:09.190
那么我要得到年龄

07:09.190 --> 07:11.190
get age

07:11.190 --> 07:13.190
那么你看一下

07:13.190 --> 07:15.190
是不是得到一个制服串年龄

07:15.190 --> 07:16.190
对吧

07:16.190 --> 07:18.190
我们这样set age 100

07:18.190 --> 07:21.190
那么get age

07:21.190 --> 07:22.190
是不是得到100岁

07:22.190 --> 07:23.190
对吧

07:23.190 --> 07:26.190
就是我们对一个属性的复值

07:26.190 --> 07:28.190
和对属性值的读取

07:28.190 --> 07:29.190
有的时候呢

07:29.190 --> 07:32.190
可能会进行一些限制

07:32.190 --> 07:34.190
会经过一些代码来进行处理

07:34.190 --> 07:35.190
那么这种情况下

07:35.190 --> 07:38.190
如果你使用一个普通的属性的话

07:38.190 --> 07:39.190
也是控制不了的

07:39.190 --> 07:41.190
比方说你使用普通属性的轨道

07:41.190 --> 07:42.190
还给它复什么值

07:42.190 --> 07:43.190
它还可以给它复制一个布置

07:43.190 --> 07:44.190
对吧

07:44.190 --> 07:46.190
那么你用函数是不是可以判断了

07:46.190 --> 07:47.190
对不对

07:47.190 --> 07:48.190
判断它是不是一个数字

07:48.190 --> 07:49.190
s数不是数字

07:49.190 --> 07:50.190
还可以给它报错

07:50.190 --> 07:51.190
对吧

07:51.190 --> 07:52.190
比方说我们这里还可以判断

07:52.190 --> 07:57.190
如果type age

07:57.190 --> 07:59.190
不等于什么 number

07:59.190 --> 08:00.190
它不是一个数字

08:00.190 --> 08:01.190
s row

08:01.190 --> 08:02.190
什么

08:02.190 --> 08:04.190
new error

08:04.190 --> 08:06.190
type error

08:06.190 --> 08:10.190
就是 age property

08:10.190 --> 08:13.190
must be a number

08:13.190 --> 08:14.190
那么这样子一来

08:14.190 --> 08:16.190
你给它连连复值的时候

08:16.190 --> 08:17.190
set age

08:17.190 --> 08:19.190
比方说你给它复这个字无错

08:19.190 --> 08:20.190
大家看

08:20.190 --> 08:22.190
age property must be a number

08:22.190 --> 08:23.190
这边报错了

08:23.190 --> 08:24.190
马上就提示你

08:24.190 --> 08:25.190
这里可能它会有问题

08:25.190 --> 08:26.190
对吧

08:26.190 --> 08:27.190
我们像希望对一个属性的复值

08:27.190 --> 08:29.190
和读取进行控制

08:29.190 --> 08:32.190
那么就可以使用这种

08:32.190 --> 08:34.190
把写成函数的模式

08:34.190 --> 08:35.190
实际上这个代码

08:35.190 --> 08:36.190
如果你学过java

08:36.190 --> 08:37.190
你可以换到这个代码

08:37.190 --> 08:38.190
就是java代码

08:38.190 --> 08:39.190
java就是全是这样做的

08:39.190 --> 08:40.190
java的属性

08:40.190 --> 08:42.190
你是绝对不能在外面直接访问的

08:42.190 --> 08:43.190
全部要变成函数

08:43.190 --> 08:45.190
得到属性值get

08:45.190 --> 08:47.190
复值属性值get

08:47.190 --> 08:49.190
而且这两个函数

08:49.190 --> 08:50.190
你会发现

08:50.190 --> 08:51.190
他们还有共同一个特点

08:51.190 --> 08:53.190
就是你读取属性值的时候

08:53.190 --> 08:55.190
是不需要参数的

08:55.190 --> 08:56.190
读一个属性值

08:56.190 --> 08:57.190
你不需要任何参数

08:57.190 --> 08:59.190
而复值属性值的时候

08:59.190 --> 09:00.190
是单参函数

09:00.190 --> 09:01.190
就是你有一个参数

09:01.190 --> 09:03.190
就是你给我什么值

09:03.190 --> 09:04.190
我要把它复值进去

09:04.190 --> 09:05.190
能看懂吗

09:05.190 --> 09:06.190
这个代码

09:06.190 --> 09:08.190
那没问题吧

09:08.190 --> 09:10.190
那么这样子一来的话

09:10.190 --> 09:12.190
倒是没有什么问题

09:12.190 --> 09:13.190
我就已经说完了

09:13.190 --> 09:14.190
其实就是要达到这样的目的

09:14.190 --> 09:16.190
但是这样子一来的话

09:16.190 --> 09:18.190
我们感觉上

09:18.190 --> 09:20.190
它就不像一个属性了

09:20.190 --> 09:21.190
你看它意思

09:21.190 --> 09:23.190
就是说你这个对象

09:23.190 --> 09:25.190
我这里要复值连

09:25.190 --> 09:26.190
给复连连复值

09:26.190 --> 09:27.190
我在调用函数

09:27.190 --> 09:28.190
它不像是一个属性了

09:28.190 --> 09:30.190
因为属性是怎么复值的

09:30.190 --> 09:32.190
属性是不是这样的复值的

09:32.190 --> 09:33.190
从语法的角度来说

09:33.190 --> 09:35.190
它不像是一个属性了

09:35.190 --> 09:36.190
我要获得一个属性值

09:36.190 --> 09:37.190
要用getAgg

09:37.190 --> 09:38.190
它就不像一个属性了

09:38.190 --> 09:39.190
我获取属性值

09:39.190 --> 09:40.190
应该怎么获取

09:40.190 --> 09:41.190
是不是这样子获取

09:41.190 --> 09:42.190
对吧

09:42.190 --> 09:43.190
它不像一个属性了

09:43.190 --> 09:45.190
在有一些

09:45.190 --> 09:47.190
就是对人

09:47.190 --> 09:48.190
有一些语言里边

09:48.190 --> 09:49.190
它对这种

09:49.190 --> 09:50.190
语法的要求

09:50.190 --> 09:52.190
就是特别特别的

09:52.190 --> 09:53.190
那种强迫正式的

09:53.190 --> 09:54.190
那种完美倾向

09:54.190 --> 09:55.190
你说你是一个属性

09:55.190 --> 09:56.190
你就复值

09:56.190 --> 09:57.190
就看上去

09:57.190 --> 09:58.190
复值和读取值

09:58.190 --> 10:00.190
看上去那也得像一个属性

10:00.190 --> 10:01.190
但是我们又希望

10:01.190 --> 10:02.190
对这个属性进行控制

10:02.190 --> 10:03.190
那怎么办呢

10:03.190 --> 10:04.190
这个时候呢

10:04.190 --> 10:05.190
你就可以利用

10:05.190 --> 10:06.190
ES5里边的

10:06.190 --> 10:07.190
define property里边

10:07.190 --> 10:08.190
是不是可以

10:08.190 --> 10:09.190
控制

10:09.190 --> 10:10.190
当然你要

10:10.190 --> 10:11.190
前提要学这个

10:11.190 --> 10:13.190
你要学习这个东西

10:13.190 --> 10:14.190
之前的ES5课程

10:14.190 --> 10:16.190
里边肯定是有讲的

10:16.190 --> 10:17.190
那么可以通过

10:17.190 --> 10:18.190
它是不是来

10:18.190 --> 10:19.190
给一个属性

10:19.190 --> 10:20.190
设置那个

10:20.190 --> 10:22.190
读取器和复值器

10:22.190 --> 10:23.190
对吧

10:23.190 --> 10:24.190
那如果说你在一个内应里边

10:24.190 --> 10:25.190
你也想

10:25.190 --> 10:26.190
拿到同样的功能

10:26.190 --> 10:27.190
怎么办呢

10:28.190 --> 10:29.190
没了

10:30.190 --> 10:31.190
变一下

10:32.190 --> 10:33.190
那么这样子一来了

10:33.190 --> 10:34.190
什么意思

10:37.190 --> 10:39.190
为A级属性

10:41.190 --> 10:42.190
就是创建

10:42.190 --> 10:44.190
一个A级属性

10:44.190 --> 10:46.190
并给它

10:46.190 --> 10:47.190
加上

10:48.190 --> 10:49.190
getter

10:49.190 --> 10:50.190
就是当你

10:50.190 --> 10:51.190
读取属性的时候

10:51.190 --> 10:53.190
读取该属性时

10:55.190 --> 10:57.190
会运行该函数

10:58.190 --> 10:59.190
好

10:59.190 --> 11:00.190
下面呢

11:00.190 --> 11:01.190
是

11:01.190 --> 11:02.190
创建

11:02.190 --> 11:03.190
当然前提要你得学习的

11:03.190 --> 11:04.190
objects define property

11:04.190 --> 11:05.190
如果你忘了

11:05.190 --> 11:06.190
赶快去看一下

11:06.190 --> 11:08.190
创建一个A级属性

11:08.190 --> 11:09.190
并给它

11:09.190 --> 11:10.190
加上

11:10.190 --> 11:11.190
setter

11:12.190 --> 11:14.190
给该属性

11:14.190 --> 11:16.190
复值时

11:16.190 --> 11:18.190
会运行该函数

11:19.190 --> 11:20.190
在内应里边

11:20.190 --> 11:21.190
你可以做出

11:21.190 --> 11:22.190
做出这么一个

11:22.190 --> 11:23.190
就是

11:23.190 --> 11:24.190
我们把它叫做

11:24.190 --> 11:25.190
叫什么呢

11:25.190 --> 11:26.190
读取器

11:26.190 --> 11:27.190
是要复值器

11:27.190 --> 11:29.190
叫统称为访问器

11:29.190 --> 11:30.190
读取属性

11:30.190 --> 11:31.190
它会运行这个函数

11:31.190 --> 11:32.190
设置属性

11:32.190 --> 11:33.190
它会运行这个函数

11:33.190 --> 11:34.190
那么这样子一来

11:34.190 --> 11:35.190
我们

11:35.190 --> 11:36.190
对象里边

11:36.190 --> 11:37.190
就多了一个属性

11:37.190 --> 11:39.190
多了啥属性呢

11:39.190 --> 11:40.190
就多了一个A级属性

11:40.190 --> 11:41.190
并且呢

11:41.190 --> 11:42.190
你可以直接

11:42.190 --> 11:43.190
把它当成属性来使用

11:43.190 --> 11:45.190
一个A级复值

11:46.190 --> 11:47.190
一个A级复值

11:47.190 --> 11:48.190
直接复值就完事了

11:48.190 --> 11:49.190
直接复值就完事了

11:49.190 --> 11:50.190
给A级直接复值

11:51.190 --> 11:52.190
你看看

11:52.190 --> 11:53.190
直接复值就完事了

11:53.190 --> 11:54.190
复值的时候

11:54.190 --> 11:55.190
它就会运行这个函数

11:55.190 --> 11:56.190
就会运行这个函数

11:56.190 --> 11:57.190
比方说

11:57.190 --> 11:58.190
你看一下吧

11:58.190 --> 11:59.190
我们来看一下A

11:59.190 --> 12:01.190
A这个对象

12:01.190 --> 12:02.190
你看一下A这个对象

12:02.190 --> 12:03.190
里边是不是有个A级属性

12:03.190 --> 12:04.190
主要它这个属性

12:04.190 --> 12:05.190
不是在圆形上

12:05.190 --> 12:06.190
没有

12:06.190 --> 12:07.190
你这样子写的话

12:07.190 --> 12:08.190
注意啊

12:08.190 --> 12:10.190
使用getter setter

12:10.190 --> 12:13.190
使用getter和setter

12:13.190 --> 12:16.190
控制的属性

12:16.190 --> 12:18.190
不在圆形上

12:18.190 --> 12:19.190
这个东西肯定是

12:19.190 --> 12:20.190
不在圆形上的

12:20.190 --> 12:22.190
你只要之前

12:22.190 --> 12:23.190
前几条件你再知道这个

12:23.190 --> 12:24.190
也知道这个

12:24.190 --> 12:25.190
当然知道它

12:25.190 --> 12:26.190
肯定不会在圆形上

12:26.190 --> 12:27.190
我们不会在圆形上

12:27.190 --> 12:28.190
去做这样的操作

12:28.190 --> 12:29.190
一般不会

12:29.190 --> 12:31.190
那么它是在实力上面的

12:31.190 --> 12:32.190
对象普通的

12:32.190 --> 12:33.190
普通对象上面的

12:33.190 --> 12:34.190
那么这样子一来

12:34.190 --> 12:35.190
你看一下

12:35.190 --> 12:36.190
我们如果说

12:36.190 --> 12:38.190
给这个A级复值复一百

12:38.190 --> 12:39.190
那么实际上

12:39.190 --> 12:40.190
这样子一复值

12:40.190 --> 12:42.190
它会运行啥呢

12:42.190 --> 12:44.190
它会运行这个函数

12:44.190 --> 12:45.190
那么我们在A.A级

12:45.190 --> 12:46.190
那么读去它的时候

12:46.190 --> 12:48.190
你看得到是不是零碎

12:48.190 --> 12:49.190
读这个属性值的时候

12:49.190 --> 12:50.190
它会运行这个函数

12:50.190 --> 12:51.190
把这个函数的反挥结果

12:51.190 --> 12:52.190
当成属性值

12:52.190 --> 12:53.190
对吧

12:54.190 --> 12:55.190
是不是一样的

12:55.190 --> 12:56.190
那么当然

12:56.190 --> 12:57.190
你也可以直写一个

12:57.190 --> 12:58.190
比方说你直写

12:58.190 --> 13:01.190
get不写set

13:01.190 --> 13:02.190
那么它只能读

13:02.190 --> 13:03.190
它不能复值

13:03.190 --> 13:05.190
它只能读不能复值

13:05.190 --> 13:06.190
同样的

13:06.190 --> 13:07.190
如果你它不太可能

13:07.190 --> 13:09.190
只能设置不能读

13:09.190 --> 13:10.190
不太可能

13:10.190 --> 13:11.190
通常我们就只能读

13:11.190 --> 13:12.190
不能设置

13:12.190 --> 13:13.190
如果你两个都写的话

13:13.190 --> 13:14.190
就是既能复值

13:14.190 --> 13:16.190
也能读取

13:16.190 --> 13:17.190
这就是一个

13:17.190 --> 13:18.190
访问器属性

13:18.190 --> 13:19.190
就建立好了

13:19.190 --> 13:20.190
看没

13:20.190 --> 13:21.190
而且格式注意

13:21.190 --> 13:22.190
这个是不能给餐的

13:22.190 --> 13:24.190
你能聊

13:24.190 --> 13:25.190
聊到你这里

13:25.190 --> 13:27.190
a.a级等于一百

13:27.190 --> 13:28.190
一千

13:28.190 --> 13:29.190
那么相当于是吧

13:29.190 --> 13:30.190
相当于是调用什么

13:30.190 --> 13:32.190
相当于是a.

13:32.190 --> 13:33.190
什么

13:33.190 --> 13:35.190
调用这个set a级函数

13:35.190 --> 13:36.190
给它传了一千

13:36.190 --> 13:37.190
相当于是这个

13:37.190 --> 13:38.190
没了意思吗

13:38.190 --> 13:39.190
它相当于是调用这个函数

13:39.190 --> 13:40.190
给它传了一千

13:41.190 --> 13:42.190
没了意思

13:42.190 --> 13:43.190
这就是

13:43.190 --> 13:44.190
在内里边

13:44.190 --> 13:46.190
它用一种特殊的语法

13:46.190 --> 13:47.190
非常非常方便的

13:47.190 --> 13:48.190
就可以实现这么一个

13:48.190 --> 13:49.190
getter和setter

13:49.190 --> 13:51.190
以前还得用这个东西

13:51.190 --> 13:52.190
定义挺麻烦的

13:52.190 --> 13:53.190
那么现在不用了

13:55.190 --> 13:56.190
这是关于这一块

13:57.190 --> 13:58.190
其实如果说

13:58.190 --> 13:59.190
你要把它变成

13:59.190 --> 14:00.190
s5的代码的话

14:00.190 --> 14:01.190
实际上是什么呢

14:01.190 --> 14:02.190
实际上是在这

14:03.190 --> 14:05.190
就是object

14:05.190 --> 14:07.190
defand property

14:07.190 --> 14:08.190
然后对象

14:08.190 --> 14:09.190
z

14:09.190 --> 14:10.190
属性名

14:10.190 --> 14:11.190
A级

14:11.190 --> 14:12.190
对不对

14:12.190 --> 14:13.190
这里不要写什么

14:14.190 --> 14:15.190
set

14:15.190 --> 14:16.190
set函数

14:17.190 --> 14:18.190
set函数

14:18.190 --> 14:19.190
然后

14:20.190 --> 14:21.190
把个代码写进来

14:21.190 --> 14:22.190
然后get寒数

14:23.190 --> 14:24.190
代码写进来

14:24.190 --> 14:25.190
实际上相当于是这种写法

14:25.190 --> 14:27.190
这种写法略显麻烦

14:27.190 --> 14:28.190
这种写法

14:28.190 --> 14:29.190
就更加舒服了

14:29.190 --> 14:30.190
看上去

14:30.190 --> 14:32.190
这是关于这一块

14:33.190 --> 14:35.190
下面叫静态成员

14:35.190 --> 14:36.190
叫啥意思呢

14:36.190 --> 14:37.190
有的时候

14:37.190 --> 14:38.190
我们可能

14:38.190 --> 14:40.190
希望给构造寒数本身

14:40.190 --> 14:42.190
因为寒数本身也是对象

14:42.190 --> 14:44.190
寒数的本身

14:44.190 --> 14:45.190
它也是对象

14:46.190 --> 14:48.190
我们希望给寒数本身

14:48.190 --> 14:49.190
加上一些成员

14:49.190 --> 14:51.190
那么这个地方

14:51.190 --> 14:52.190
我们就

14:52.190 --> 14:53.190
随便来一个吧

14:54.190 --> 14:55.190
比方说我们以前

14:55.190 --> 14:57.190
希望给这个animal

14:57.190 --> 14:58.190
本身加上一些成员

14:58.190 --> 14:59.190
我们就随便写一个吧

14:59.190 --> 15:00.190
随便写一个

15:00.190 --> 15:02.190
那么这种成员呢

15:02.190 --> 15:04.190
不知道你们以前

15:04.190 --> 15:05.190
老师有没有给你说

15:05.190 --> 15:06.190
这种成员

15:06.190 --> 15:07.190
其实在介石里面

15:07.190 --> 15:08.190
我们就把它叫做静态成员

15:08.190 --> 15:10.190
给构造寒数

15:10.190 --> 15:11.190
本身加上的成员

15:11.190 --> 15:12.190
就是静态成员

15:12.190 --> 15:13.190
就是

15:13.190 --> 15:16.190
构造寒数本身的成员

15:16.190 --> 15:17.190
而不是

15:17.190 --> 15:18.190
通过构造寒数

15:18.190 --> 15:19.190
创建了对象的成员

15:19.190 --> 15:21.190
像这个东西

15:21.190 --> 15:22.190
是通过构造寒数

15:22.190 --> 15:23.190
创建了对象对吧

15:23.190 --> 15:24.190
对象里面有些东西

15:24.190 --> 15:26.190
这些东西叫做实力成员

15:26.190 --> 15:27.190
就对象里面的成员

15:27.190 --> 15:29.190
这个东西也算是实力成员

15:29.190 --> 15:30.190
元宵上面的方法

15:30.190 --> 15:31.190
也算是实力成员

15:31.190 --> 15:32.190
但是构造寒数

15:32.190 --> 15:34.190
本身的成员

15:34.190 --> 15:36.190
那么是

15:36.190 --> 15:37.190
静态成员

15:37.190 --> 15:39.190
我给大家画个图吧

15:39.190 --> 15:41.190
还是画个图得了

15:42.190 --> 15:44.190
我们来看一下

15:44.190 --> 15:45.190
这里

15:45.190 --> 15:48.190
我们建立一个PBT

15:48.190 --> 15:52.910
画个图

15:52.910 --> 15:55.910
这里是寒数

15:55.910 --> 15:57.910
这是构造寒数

15:57.910 --> 15:59.910
寒数里面说有元宵

15:59.910 --> 16:00.910
对吧

16:00.910 --> 16:03.910
构造寒数的元宵

16:03.910 --> 16:04.910
元宵

16:04.910 --> 16:06.910
那么我们这里

16:06.910 --> 16:07.910
元宵是不通过

16:07.910 --> 16:08.910
property访问

16:08.910 --> 16:10.910
portotype访问

16:10.910 --> 16:15.630
这里写个文字

16:15.630 --> 16:17.630
这是prototype

16:17.630 --> 16:18.630
通过这个属性来访问

16:18.630 --> 16:19.630
对吧

16:19.630 --> 16:21.630
访问一个构造寒数的元宵

16:21.630 --> 16:22.630
然后我们通过构造寒数

16:22.630 --> 16:24.630
可以创建一个对象

16:24.630 --> 16:27.630
通过构造寒数来创建一个对象

16:27.630 --> 16:28.630
也就是说我们这里有个箭头

16:28.630 --> 16:29.630
画一下

16:30.630 --> 16:31.630
逻辑理理

16:31.630 --> 16:32.630
因为这是基本知识

16:32.630 --> 16:34.630
但是这里也是容易比较糟

16:34.630 --> 16:35.630
比较糟的一个点

16:35.630 --> 16:37.630
我给大家画一下图

16:37.630 --> 16:39.630
我们通过六一个构造寒数

16:39.630 --> 16:41.630
通过六一个构造寒数

16:41.630 --> 16:42.630
比方这里是animal

16:42.630 --> 16:43.630
那么通过六一个animal

16:43.630 --> 16:44.630
创建了一个对象

16:44.630 --> 16:45.630
对吧

16:45.630 --> 16:47.630
通过构造寒数

16:47.630 --> 16:49.630
创建的对象

16:49.630 --> 16:50.630
对不对

16:50.630 --> 16:52.630
这个对象里边

16:52.630 --> 16:54.630
它里边的成员叫做实力成员

16:54.630 --> 16:56.630
就这些成员

16:56.630 --> 16:57.630
你通过六animal

16:57.630 --> 16:58.630
是不是在运行这些代码

16:58.630 --> 16:59.630
这个Z指向的是谁

16:59.630 --> 17:01.630
Z是不是指向了他

17:01.630 --> 17:02.630
对吧

17:02.630 --> 17:03.630
那么这里边的成员

17:03.630 --> 17:06.630
是叫做实力成员

17:06.630 --> 17:09.630
这里边叫做实力成员

17:09.630 --> 17:14.970
换个颜色

17:14.970 --> 17:16.970
换个啥颜色呢

17:16.970 --> 17:17.970
实力成员

17:17.970 --> 17:19.970
这里边是实力成员

17:19.970 --> 17:20.970
明白了意思吧

17:20.970 --> 17:21.970
而且呢

17:21.970 --> 17:22.970
这个成员

17:22.970 --> 17:24.970
它是不是一个隐氏圆形

17:24.970 --> 17:26.970
它会有一个隐氏圆形

17:26.970 --> 17:27.970
隐氏圆形会指向谁

17:27.970 --> 17:28.970
是不是指向他

17:28.970 --> 17:29.970
对不对

17:29.970 --> 17:31.970
它有一个隐氏圆形

17:31.970 --> 17:33.970
就是

17:33.970 --> 17:35.970
两个下滑线proto

17:35.970 --> 17:36.970
是不是指向他

17:36.970 --> 17:38.970
那么这里边的成员

17:38.970 --> 17:41.970
我们也把它叫做实力成员

17:41.970 --> 17:44.970
因为都是通过这个对象

17:44.970 --> 17:46.970
的方式来访问的

17:46.970 --> 17:49.970
这里边的成员也叫做实力成员

17:49.970 --> 17:50.970
也叫实力成员

17:50.970 --> 17:51.970
有的时候呢

17:51.970 --> 17:52.970
为了区分了

17:52.970 --> 17:54.970
也可以把它叫做圆形成员

17:54.970 --> 17:55.970
对象本身的成员

17:55.970 --> 17:57.970
总之他们统称为实力成员

17:57.970 --> 17:58.970
就通过你看一下

17:58.970 --> 17:59.970
这个A里边

17:59.970 --> 18:00.970
这个A里边

18:00.970 --> 18:01.970
哪些成员

18:01.970 --> 18:02.970
Type

18:02.970 --> 18:03.970
实力成员

18:03.970 --> 18:04.970
实力成员

18:04.970 --> 18:05.970
实力成员

18:05.970 --> 18:07.970
圆形上面

18:07.970 --> 18:08.970
Print实力成员

18:08.970 --> 18:09.970
对吧

18:09.970 --> 18:10.970
这些都是实力成员

18:10.970 --> 18:12.970
而这个勾造函数

18:12.970 --> 18:14.970
本身就是Animo里边的东西

18:14.970 --> 18:15.970
Animo

18:15.970 --> 18:16.970
Animo

18:16.970 --> 18:17.970
这个里边的东西

18:17.970 --> 18:19.970
我们用console.dnr来访问

18:19.970 --> 18:20.970
Animo

18:20.970 --> 18:22.970
因为函数本身它也是对象

18:22.970 --> 18:23.970
对吧

18:23.970 --> 18:24.970
函数本身也是对象

18:24.970 --> 18:25.970
这里边的成员

18:25.970 --> 18:27.970
比方说什么nance

18:27.970 --> 18:28.970
arguments

18:28.970 --> 18:29.970
name

18:29.970 --> 18:30.970
这些东西

18:30.970 --> 18:32.970
这些叫做静态成员

18:32.970 --> 18:34.970
就直接放到函数里边了

18:34.970 --> 18:35.970
是要静态成员

18:35.970 --> 18:36.970
我想这个东西

18:36.970 --> 18:37.970
应该

18:37.970 --> 18:38.970
我都讲成这样子了

18:38.970 --> 18:39.970
应该搞清楚了吧

18:39.970 --> 18:41.970
这个东西叫做静态成员

18:41.970 --> 18:42.970
这个静态成员

18:42.970 --> 18:44.970
你是不能通过对象来访问的

18:44.970 --> 18:46.970
不管你有没有对象

18:46.970 --> 18:47.970
我都可以直接通过

18:47.970 --> 18:48.970
勾造函数来访问

18:48.970 --> 18:50.970
这叫静态成员

18:50.970 --> 18:51.970
以后你看到什么静态成员

18:51.970 --> 18:52.970
你就知道

18:52.970 --> 18:53.970
什么意思呢

18:53.970 --> 18:54.970
就是说

18:54.970 --> 18:55.970
我这里直接写的

18:55.970 --> 18:57.970
写到勾造函数里边了

18:57.970 --> 18:58.970
这叫静态成员

18:58.970 --> 18:59.970
那么你用的时候

18:59.970 --> 19:00.970
你看看我们这里保存

19:00.970 --> 19:03.970
那么现在看一下Animo

19:03.970 --> 19:04.970
Animo

19:07.970 --> 19:08.970
看一下

19:08.970 --> 19:09.970
这是多一个abc

19:09.970 --> 19:10.970
那么这个abc

19:10.970 --> 19:11.970
能不能通过a来访问

19:11.970 --> 19:12.970
肯定不行

19:12.970 --> 19:13.970
肯定不行

19:13.970 --> 19:14.970
这个东西的

19:14.970 --> 19:15.970
你看一下这个图吧

19:15.970 --> 19:17.970
a里边能访问实力成员

19:17.970 --> 19:19.970
原性上的实力成员都可以

19:19.970 --> 19:20.970
但是你访问不到静态成员

19:20.970 --> 19:21.970
静态成员只能通过

19:21.970 --> 19:22.970
勾造函数

19:22.970 --> 19:24.970
函数本身来访问

19:24.970 --> 19:26.970
搞清楚

19:26.970 --> 19:27.970
那么如果说

19:27.970 --> 19:31.970
你要加一些静态成员的话

19:31.970 --> 19:32.970
比方说

19:32.970 --> 19:34.970
还是给他举个例子吧

19:34.970 --> 19:35.970
什么情况下

19:35.970 --> 19:39.970
会使用到静态成员呢

19:39.970 --> 19:40.970
我举个例子

19:40.970 --> 19:42.970
随便举个例子

19:43.970 --> 19:44.970
我举个例子

19:44.970 --> 19:46.970
比方说吧

19:46.970 --> 19:50.970
我们有做一个

19:50.970 --> 19:53.970
做一个棋子内的游戏

19:53.970 --> 19:55.970
比方说中国象棋的游戏

19:55.970 --> 19:56.970
举个例子

19:56.970 --> 19:58.970
举一个中国象棋的游戏

19:58.970 --> 19:59.970
比方说我们要建立一个内叫

19:59.970 --> 20:00.970
切式

20:00.970 --> 20:01.970
叫棋子

20:01.970 --> 20:02.970
棋子

20:02.970 --> 20:04.970
每一个棋子有什么呢

20:04.970 --> 20:05.970
有一些属性对吧

20:05.970 --> 20:07.970
也给我一个棋子的名称

20:07.970 --> 20:08.970
对不对

20:08.970 --> 20:11.970
给我棋子的

20:11.970 --> 20:12.970
就是

20:12.970 --> 20:13.970
是哪个

20:13.970 --> 20:14.970
红方还是黑方

20:14.970 --> 20:16.970
棋子名称就是什么码

20:16.970 --> 20:18.970
你不只了解象棋规则都没事

20:18.970 --> 20:19.970
就看一下这么一个内就行了

20:19.970 --> 20:21.970
这是一个棋子内

20:21.970 --> 20:22.970
通过它可以创建一个棋子

20:22.970 --> 20:24.970
给我个棋子名称就得了

20:24.970 --> 20:26.970
我就写简单一点

20:26.970 --> 20:28.970
棋子名称

20:28.970 --> 20:29.970
那么就完了

20:29.970 --> 20:30.970
我其他方法也没有

20:30.970 --> 20:31.970
那么我们比方说

20:31.970 --> 20:34.970
要创建三个棋子

20:34.970 --> 20:35.970
切式1

20:35.970 --> 20:36.970
6一个切式

20:36.970 --> 20:39.970
比方说码

20:39.970 --> 20:40.970
然后呢

20:40.970 --> 20:41.970
切式2

20:41.970 --> 20:43.970
切式3

20:43.970 --> 20:45.970
这是

20:45.970 --> 20:46.970
G

20:46.970 --> 20:48.970
G咋写呢

20:48.970 --> 20:50.970
就车嘛

20:50.970 --> 20:52.970
这里是那个

20:52.970 --> 20:53.970
将

20:53.970 --> 20:57.600
我们创建三个棋子对吧

20:57.600 --> 20:59.600
我们发现了

20:59.600 --> 21:01.600
在我们的游戏里面

21:01.600 --> 21:02.600
每一个棋子

21:02.600 --> 21:03.600
它都有一个宽膏

21:03.600 --> 21:05.600
在页面上显示的时候

21:05.600 --> 21:06.600
它会形成一个当图片

21:06.600 --> 21:08.600
形成的DIV会显示一个宽膏

21:08.600 --> 21:10.600
而且每一个棋子的宽膏

21:10.600 --> 21:11.600
是不是一样的

21:12.600 --> 21:14.600
都是一样的

21:14.600 --> 21:15.600
它没有什么区别

21:15.600 --> 21:17.600
那如果说我们在这里

21:17.600 --> 21:19.600
直接复制Z15

21:19.600 --> 21:20.600
可不可以呢

21:20.600 --> 21:21.600
当然可以

21:21.600 --> 21:22.600
当然可以

21:22.600 --> 21:23.600
但是呢你会发现

21:23.600 --> 21:24.600
这个有点怪

21:24.600 --> 21:26.600
因为所有的棋子都是

21:26.600 --> 21:27.600
都是要有宽膏

21:27.600 --> 21:28.600
都是5050

21:28.600 --> 21:30.600
它没有变化

21:30.600 --> 21:31.600
那如果有一天

21:31.600 --> 21:33.600
我要获得棋子的宽膏

21:33.600 --> 21:34.600
你想一想

21:34.600 --> 21:36.600
如果你这样子写代

21:36.600 --> 21:37.600
我是不是得

21:37.600 --> 21:38.600
先创建一个棋子

21:38.600 --> 21:40.600
我才能获得宽膏

21:41.600 --> 21:42.600
你想一想的道理

21:42.600 --> 21:43.600
我要获取宽膏

21:43.600 --> 21:44.600
我是不是得有一个棋子

21:44.600 --> 21:46.600
我才能获取宽膏

21:46.600 --> 21:48.600
因为我们目前那个代码的

21:48.600 --> 21:49.600
逻辑是什么呢

21:49.600 --> 21:50.600
逻辑是

21:50.600 --> 21:52.600
每一个棋子

21:52.600 --> 21:53.600
它有宽膏

21:53.600 --> 21:55.600
所以说你得有一个棋子

21:55.600 --> 21:56.600
创建一个棋子

21:56.600 --> 21:57.600
才能获取宽膏

21:57.600 --> 21:58.600
但是实际上

21:58.600 --> 21:59.600
我们的游戏里面

21:59.600 --> 22:00.600
不是这样子的

22:00.600 --> 22:01.600
不是说

22:01.600 --> 22:02.600
每一个具体的棋子

22:02.600 --> 22:04.600
有各自的宽膏

22:04.600 --> 22:05.600
你看一下我们这里

22:05.600 --> 22:06.600
如果说创建100个棋子

22:06.600 --> 22:07.600
是不是每一个对象里面

22:07.600 --> 22:08.600
都有一个宽膏

22:08.600 --> 22:09.600
宽度和高度

22:09.600 --> 22:11.600
就会形成这种结构

22:12.600 --> 22:13.600
如果说我们这里

22:13.600 --> 22:15.600
创建很多个棋子

22:15.600 --> 22:17.600
棋子1,棋子2,棋子3,棋子4

22:17.600 --> 22:18.600
每一个棋子里面

22:18.600 --> 22:19.600
是不是都有两个属性

22:19.600 --> 22:20.600
宽度,高度

22:20.600 --> 22:22.600
是不是都是一样的

22:23.600 --> 22:25.600
我们如果有多个棋子的话

22:25.600 --> 22:26.600
那么每一个棋子

22:26.600 --> 22:27.600
是不是都有一些宽度

22:27.600 --> 22:28.600
和高度的这样的属性

22:28.600 --> 22:29.600
在里面

22:29.600 --> 22:31.600
它不仅仅浪费内存空间

22:31.600 --> 22:32.600
那么简单

22:32.600 --> 22:33.600
而且我们写代码的时候

22:33.600 --> 22:34.600
都会遇到一些困惑

22:34.600 --> 22:35.600
比方说我游的时候

22:35.600 --> 22:37.600
要生成一个面板

22:37.600 --> 22:38.600
棋盘

22:38.600 --> 22:40.600
棋盘我可能是8×8

22:40.600 --> 22:42.600
或者是9×10之类的

22:42.600 --> 22:43.600
我要去计算

22:43.600 --> 22:44.600
棋盘宽度是多少呢

22:44.600 --> 22:46.600
应该是每一个棋子乘19

22:46.600 --> 22:48.600
加上每一个棋子乘10

22:48.600 --> 22:49.600
宽高

22:49.600 --> 22:50.600
是不是可以让这样设置

22:50.600 --> 22:51.600
于是我要需要

22:51.600 --> 22:53.600
得到每一个棋子的宽度

22:53.600 --> 22:54.600
高度

22:54.600 --> 22:55.600
但是呢

22:55.600 --> 22:56.600
由于我们的宽度

22:56.600 --> 22:58.600
高度在具体的棋子里面

22:58.600 --> 22:59.600
我这里要莫名其妙的

22:59.600 --> 23:00.600
我本来只是要

23:00.600 --> 23:01.600
创建一个棋盘

23:01.600 --> 23:02.600
棋盘的宽高的

23:02.600 --> 23:03.600
我莫名其妙的

23:03.600 --> 23:05.600
我要去创建一个棋子

23:05.600 --> 23:06.600
我创建棋子干嘛呢

23:06.600 --> 23:07.600
我只需要知道

23:07.600 --> 23:08.600
宽高就行了

23:08.600 --> 23:09.600
因为每一个棋子

23:09.600 --> 23:10.600
宽高是一样的

23:10.600 --> 23:11.600
干嘛要让我去

23:11.600 --> 23:12.600
创建一个棋子呢

23:12.600 --> 23:13.600
是不是觉得有点怪呀

23:13.600 --> 23:15.600
是不是觉得有点怪

23:15.600 --> 23:17.600
能听懂这个意思吗

23:17.600 --> 23:18.600
因此呢

23:18.600 --> 23:19.600
像这种属性

23:19.600 --> 23:20.600
就不应该作为

23:20.600 --> 23:21.600
实力属性

23:21.600 --> 23:22.600
就是说我不应该

23:22.600 --> 23:23.600
有了棋子

23:23.600 --> 23:24.600
我才有宽高

23:24.600 --> 23:25.600
没有棋子

23:25.600 --> 23:26.600
宽高也是定下来的

23:26.600 --> 23:27.600
我就应该把它

23:27.600 --> 23:28.600
作为静态属性

23:28.600 --> 23:29.600
就应该是不是

23:29.600 --> 23:30.600
放到这

23:30.600 --> 23:31.600
宽度50

23:31.600 --> 23:33.600
高度50

23:33.600 --> 23:35.600
那么这样子一来的话

23:35.600 --> 23:36.600
我要获取宽高

23:36.600 --> 23:38.600
根本就不需要棋子存在

23:38.600 --> 23:40.600
你管理是什么棋子

23:40.600 --> 23:42.600
所有的宽高度都是一样的

23:42.600 --> 23:44.600
没了意思吗

23:44.600 --> 23:45.600
这样的逻辑

23:45.600 --> 23:46.600
是不是更加合理一点

23:46.600 --> 23:47.600
对吧

23:47.600 --> 23:49.600
是更加合理一点

23:49.600 --> 23:51.600
那么这就是静态属性

23:51.600 --> 23:53.600
有的时候就会有用

23:53.600 --> 23:54.600
它不依赖具体的对象

23:54.600 --> 23:56.600
它是跟这个内意相关的

23:56.600 --> 23:59.600
跟这个函数本身相关的

23:59.600 --> 24:01.600
那么静态属性的

24:01.600 --> 24:02.600
以前我们是不是

24:02.600 --> 24:03.600
对这种邪法

24:03.600 --> 24:04.600
那么这种邪法呢

24:04.600 --> 24:05.600
不好

24:05.600 --> 24:07.600
它又跟这个东西分开了

24:07.600 --> 24:08.600
是不是又分开了

24:08.600 --> 24:09.600
写了

24:09.600 --> 24:10.600
不要分开写

24:10.600 --> 24:11.600
它们是一个整体

24:11.600 --> 24:12.600
那么一页是6里边

24:12.600 --> 24:13.600
它告诉你

24:13.600 --> 24:15.600
从静态成员

24:15.600 --> 24:16.600
应该写到哪呢

24:16.600 --> 24:18.600
也要写到内里边

24:18.600 --> 24:19.600
怎么写呢

24:19.600 --> 24:20.600
非常简单

24:20.600 --> 24:22.600
使用

24:22.600 --> 24:26.600
Static关键字定义的成员

24:26.600 --> 24:30.600
G静态成员

24:30.600 --> 24:31.600
就这么简单

24:31.600 --> 24:33.600
比如说我们这个静态成员呢

24:33.600 --> 24:34.600
比方的宽度高度

24:35.600 --> 24:38.600
Static就是静态的意思

24:38.600 --> 24:39.600
50

24:39.600 --> 24:40.600
Static

24:40.600 --> 24:41.600
Height

24:41.600 --> 24:42.600
50

24:42.600 --> 24:43.600
就这样子

24:43.600 --> 24:45.600
你看是不是又写到内里边去了

24:45.600 --> 24:46.600
它是一个整体

24:46.600 --> 24:47.600
看没

24:47.600 --> 24:49.600
那么现在的效果是完全一样的

24:49.600 --> 24:51.600
跟刚才那种邪法是完全一样的

24:51.600 --> 24:52.600
你看50成50

24:52.600 --> 24:53.600
然后我们打印出来

24:53.600 --> 24:54.600
DR

24:54.600 --> 24:55.600
什么呢

24:55.600 --> 24:57.600
Chase

24:57.600 --> 24:58.600
你看

24:58.600 --> 25:00.600
内里边是不是有一个Height

25:00.600 --> 25:01.600
Width

25:01.600 --> 25:02.600
而且对象里边是肯定没有的

25:02.600 --> 25:03.600
肯定是没有的

25:04.600 --> 25:05.600
原来的意思

25:05.600 --> 25:07.600
静态成员的书写方式

25:07.600 --> 25:09.600
当然不仅是属性

25:09.600 --> 25:12.600
不仅是属性

25:12.600 --> 25:14.600
方法也可以

25:14.600 --> 25:15.600
方法也可以

25:15.600 --> 25:17.600
比方说master的

25:17.600 --> 25:19.600
方法也可以

25:19.600 --> 25:21.600
我们看一下吧

25:21.600 --> 25:23.600
方法也可以

25:23.600 --> 25:24.600
master

25:24.600 --> 25:25.600
方法是不是也定义到

25:25.600 --> 25:26.600
构造函数里边去了

25:26.600 --> 25:27.600
那么要调用这个方法

25:27.600 --> 25:28.600
怎么调用呢

25:28.600 --> 25:29.600
是不是要这样调用

25:29.600 --> 25:30.600
Chase

25:30.600 --> 25:31.600
master

25:31.600 --> 25:33.600
这样去调用

25:33.600 --> 25:34.600
没问题吧

25:34.600 --> 25:36.600
应该没问题吧

25:36.600 --> 25:39.600
这是关于静态的成员

25:39.600 --> 25:42.600
写到构造函数里边了

25:42.600 --> 25:44.600
好 下一个

25:44.600 --> 25:47.600
下一个叫做自断初始画器

25:47.600 --> 25:49.600
什么意思呢

25:49.600 --> 25:50.600
自断初始画器

25:50.600 --> 25:52.600
这一块知识是ES7的

25:52.600 --> 25:54.600
ES6它没有提供这个东西

25:54.600 --> 25:55.600
是ES7的

25:55.600 --> 25:56.600
你看一下

25:56.600 --> 25:58.600
这里就叫做自断初始画器

25:58.600 --> 26:00.600
就是你写了这么一个成员

26:00.600 --> 26:02.600
直接使用个等号

26:02.600 --> 26:04.600
直接给它复制

26:04.600 --> 26:05.600
也就是ES6里边

26:05.600 --> 26:07.600
是不支持这个语法的

26:07.600 --> 26:08.600
ES6里边可以写静态方法

26:08.600 --> 26:10.600
但是你要写静态属性

26:10.600 --> 26:11.600
好像没招

26:11.600 --> 26:12.600
没招

26:12.600 --> 26:13.600
但是ES7可以了

26:13.600 --> 26:14.600
因为ES7提供了

26:14.600 --> 26:15.600
静态

26:15.600 --> 26:17.600
提供了属性初始画器

26:17.600 --> 26:18.600
就是你写成员的时候

26:18.600 --> 26:20.600
你可以直接给它复制

26:20.600 --> 26:22.600
可以直接给它复制

26:22.600 --> 26:24.600
比方说我们举个例子

26:24.600 --> 26:25.600
再来一个例子

26:25.600 --> 26:26.600
就是说

26:26.600 --> 26:29.600
我们这里写上这么一个内

26:29.600 --> 26:31.600
写上这么一个内

26:31.600 --> 26:34.600
叫做啥呢

26:34.600 --> 26:36.600
叫做Person

26:36.600 --> 26:37.600
叫做Test

26:37.600 --> 26:39.600
就写随便写个内

26:39.600 --> 26:40.600
就是有的时候

26:40.600 --> 26:41.600
我们有些属性

26:41.600 --> 26:43.600
它本身具有默认值

26:43.600 --> 26:45.600
本身就具有默认值

26:45.600 --> 26:47.600
也不需要在构造函数里边

26:47.600 --> 26:49.600
对它进行初始画

26:49.600 --> 26:51.600
比方说我们构造函数里边

26:51.600 --> 26:52.600
构造函数里边

26:52.600 --> 26:53.600
它就有一个属性

26:53.600 --> 26:55.600
A等于1

26:55.600 --> 26:57.600
B等于2

26:57.600 --> 26:58.600
Z是C等于3

26:58.600 --> 26:59.600
比方说有这么三个属性

26:59.600 --> 27:00.600
你不需要给我传参数

27:00.600 --> 27:02.600
我直接给它复制就完事了

27:02.600 --> 27:04.600
那么像这样的属性的话

27:04.600 --> 27:07.600
你可以利用ES7的这种语法

27:07.600 --> 27:09.600
你可以利用ES7的

27:09.600 --> 27:12.600
制断初始画期的这么一种语法

27:12.600 --> 27:13.600
来书写

27:13.600 --> 27:15.600
那么怎么来书写呢

27:15.600 --> 27:17.600
就是你像这种有直接

27:17.600 --> 27:19.600
复制的这么一个制断

27:19.600 --> 27:21.600
它不来自于任何参数

27:21.600 --> 27:22.600
它直接复制的制断

27:22.600 --> 27:23.600
你直接写到这

27:25.600 --> 27:26.600
B等于2

27:26.600 --> 27:28.600
分号可写可不写

27:29.600 --> 27:30.600
分号要写没问题

27:30.600 --> 27:31.600
不写也可以

27:31.600 --> 27:33.600
那么现在这样子

27:33.600 --> 27:35.600
就相当于是这种写法

27:35.600 --> 27:36.600
它会自动的

27:36.600 --> 27:37.600
你可以理解为

27:37.600 --> 27:38.600
它会自动的把它帮到

27:38.600 --> 27:39.600
构造函数里边去

27:39.600 --> 27:41.600
那么现在构造函数可以不用写了

27:41.600 --> 27:43.600
可以不用写了

27:43.600 --> 27:44.600
你如果不写构造函数的话

27:44.600 --> 27:46.600
你相当于是构造函数里面

27:46.600 --> 27:47.600
啥都没有

27:47.600 --> 27:48.600
可以不写

27:48.600 --> 27:50.600
那么现在我们来看一下

27:50.600 --> 27:52.600
T6一个Test

27:52.600 --> 27:53.600
输出T

27:53.600 --> 27:55.600
那么它的里边就有一些

27:55.600 --> 27:56.600
实力成员ABC

27:56.600 --> 27:57.600
对吧

27:57.600 --> 27:58.600
因为我没有加Static

27:58.600 --> 28:00.600
加一个

28:00.600 --> 28:02.600
那么看一下吧

28:02.600 --> 28:04.600
这个T输出过后

28:04.600 --> 28:06.600
是不是里面有个B属性和C属性

28:06.600 --> 28:07.600
对吧

28:07.600 --> 28:09.600
它就变成它的实力成员了

28:09.600 --> 28:11.600
所以它不是在元凶上面

28:11.600 --> 28:13.600
它不是在元凶上面

28:13.600 --> 28:14.600
它不是在元凶上面

28:14.600 --> 28:15.600
是在这里

28:15.600 --> 28:17.600
是在对象里边的

28:17.600 --> 28:18.600
那么这个A跑哪去了

28:18.600 --> 28:19.600
A有一次

28:19.600 --> 28:20.600
我们刚才讲的是静态成员

28:20.600 --> 28:22.600
它在Test.A里边

28:22.600 --> 28:24.600
Test.A里边

28:24.600 --> 28:26.600
那么这就是自断出手啊

28:26.600 --> 28:28.600
这个东西对于一些

28:28.600 --> 28:29.600
本身就是固定的值

28:29.600 --> 28:30.600
有些成员

28:30.600 --> 28:32.600
或者说一些成员一开始

28:32.600 --> 28:33.600
直接有个默认值

28:33.600 --> 28:35.600
那么用这种语法是非常舒服的

28:35.600 --> 28:37.600
但是你不要去管兼容性问题

28:37.600 --> 28:39.600
如果说你的浏览器那边

28:39.600 --> 28:40.600
出现了兼容性问题的话

28:40.600 --> 28:42.600
你把浏览器升级到最新版本

28:42.600 --> 28:44.600
谷歌浏览器升级到最新版本就完事了

28:44.600 --> 28:45.600
如果兼容性问题

28:45.600 --> 28:46.600
以后我们会有一个东西

28:46.600 --> 28:48.600
要做bable来解决这个问题

28:48.600 --> 28:49.600
我们以后会讲它的时候

28:49.600 --> 28:50.600
再具体的说

28:50.600 --> 28:51.600
现在就大胆用就行了

28:51.600 --> 28:52.600
就是有的时候

28:52.600 --> 28:54.600
有些属性有固定的值

28:54.600 --> 28:55.600
或者是初识化的时候

28:55.600 --> 28:56.600
那么你就可以直接写到这儿

28:56.600 --> 28:58.600
其实它最终呢

28:58.600 --> 29:00.600
它最终呢都是在

29:00.600 --> 29:02.600
创建这个Test的时候

29:02.600 --> 29:04.600
在构造函数里边

29:04.600 --> 29:06.600
自动给你完成复制的

29:06.600 --> 29:07.600
只是写的时候呢

29:07.600 --> 29:09.600
你可以这样子写

29:09.600 --> 29:10.600
那意思吗

29:10.600 --> 29:12.600
比方说构造函数里边

29:12.600 --> 29:13.600
consultator

29:13.600 --> 29:14.600
我们再加一句话

29:14.600 --> 29:15.600
Z是D

29:15.600 --> 29:16.600
D等于什么呢

29:16.600 --> 29:17.600
B加C

29:17.600 --> 29:18.600
Z是B

29:18.600 --> 29:19.600
加Z是C

29:19.600 --> 29:20.600
比方说这是大面试体

29:20.600 --> 29:22.600
它问你输出了D是多少

29:22.600 --> 29:23.600
D是多少呢

29:23.600 --> 29:24.600
D就是5

29:24.600 --> 29:25.600
就是5

29:25.600 --> 29:26.600
看一下吧

29:26.600 --> 29:27.600
D是5

29:27.600 --> 29:28.600
也就是说

29:28.600 --> 29:29.600
它相当于是把这两句话

29:29.600 --> 29:30.600
给你放到这儿

29:30.600 --> 29:31.600
相当于是把这两句话

29:31.600 --> 29:32.600
放到这儿

29:32.600 --> 29:34.600
Z是B

29:34.600 --> 29:36.600
Z是C

29:36.600 --> 29:37.600
V是C

29:37.600 --> 29:38.600
非常简单

29:38.600 --> 29:39.600
就是这个语法上那里

29:39.600 --> 29:40.600
可以这样子写而已

29:40.600 --> 29:42.600
就叫属性初识化期

29:42.600 --> 29:44.600
这是ES7给你提供的东西

29:44.600 --> 29:45.600
好

29:45.600 --> 29:47.600
那么你要理解

29:47.600 --> 29:49.600
非常特别注意的一点就是

29:49.600 --> 29:52.600
注意

29:52.600 --> 29:55.600
使用Static

29:55.600 --> 29:57.600
注意这么两个点

29:57.600 --> 30:03.600
使用Static的初识化期

30:03.600 --> 30:07.600
属性自断初识化期

30:07.600 --> 30:09.600
添加的是静态成员

30:09.600 --> 30:10.600
这个没什么好说的

30:10.600 --> 30:12.600
这个我们刚才就看到过了

30:12.600 --> 30:14.600
另外一个就是

30:14.600 --> 30:17.600
没有使用Static的

30:17.600 --> 30:21.600
自断初识化期

30:21.600 --> 30:24.600
添加的成员

30:24.600 --> 30:28.600
位于对象上

30:28.600 --> 30:30.600
位于这个构造函数

30:30.600 --> 30:31.600
创建在对象上面

30:31.600 --> 30:33.600
特别特别注意这一点

30:33.600 --> 30:36.600
因为为什么要特别注意这一点呢

30:36.600 --> 30:39.600
是因为有这么一个东西存在

30:39.600 --> 30:40.600
就是说以后

30:40.600 --> 30:43.600
我们可能会看到这么一种写法

30:43.600 --> 30:45.600
看着

30:45.600 --> 30:47.600
可能会看到这么一种写法

30:47.600 --> 30:50.600
就是我们使用属性初识化期

30:50.600 --> 30:51.600
而自断初识化期

30:51.600 --> 30:53.600
我们写了这么一个方法

30:53.600 --> 30:55.600
不要说我们这里写个

30:55.600 --> 30:57.600
抗刷个什么

30:57.600 --> 30:58.600
抗刷个什么里面

30:58.600 --> 31:00.600
我们就ZSA等于123

31:00.600 --> 31:03.600
然后我们这里写的这么一个方法

31:03.600 --> 31:04.600
叫做Print

31:04.600 --> 31:05.600
这个方法呢

31:05.600 --> 31:06.600
本来正常应该是这样写的

31:06.600 --> 31:08.600
我们输出A

31:08.600 --> 31:10.600
本来应该是这么写的

31:10.600 --> 31:11.600
你看一下吧

31:11.600 --> 31:13.600
我们调用这个T点Print

31:13.600 --> 31:16.600
输出这么一个A

31:16.600 --> 31:17.600
有的时候

31:17.600 --> 31:19.600
我们为了绑定方法里边的Z

31:19.600 --> 31:21.600
为了绑定Z是

31:21.600 --> 31:23.600
Z是始终指向当前的对象

31:23.600 --> 31:25.600
为了实现这么一个效果

31:25.600 --> 31:27.600
因为我担心

31:27.600 --> 31:30.600
将来别人可能这么来做

31:30.600 --> 31:31.600
这样来做

31:31.600 --> 31:32.600
直接调用P

31:32.600 --> 31:33.600
那么Z是不是Pian

31:33.600 --> 31:35.600
Z是不是完了

31:35.600 --> 31:36.600
对不对

31:36.600 --> 31:37.600
Z是不是完了

31:37.600 --> 31:38.600
在严格模式下面

31:38.600 --> 31:40.600
Z是不是Undefend

31:40.600 --> 31:41.600
它不再指向Window

31:41.600 --> 31:42.600
它指向的是Undefend

31:43.600 --> 31:44.600
因为我们说过

31:44.600 --> 31:45.600
内里边的代码

31:45.600 --> 31:47.600
全部都在严格模式下边

31:47.600 --> 31:49.600
所以它包了一个Undefend里边

31:49.600 --> 31:50.600
是没有A这个属性的

31:50.600 --> 31:51.600
它打印不出来A

31:51.600 --> 31:53.600
Z是指向出了问题

31:53.600 --> 31:55.600
那么我们如果说担心这一点

31:55.600 --> 31:56.600
当然

31:56.600 --> 31:57.600
肯定不会

31:57.600 --> 31:59.600
我们担心到其实不是这一点

31:59.600 --> 32:00.600
以后在一些特殊场地下面

32:00.600 --> 32:02.600
Z可能会出现一些问题

32:02.600 --> 32:04.600
于是我们可能会这样子写

32:04.600 --> 32:09.770
这个写法是怎么意思呢

32:09.770 --> 32:12.770
利用了制断初始画器

32:12.770 --> 32:14.770
Print我们把它复制为一个

32:14.770 --> 32:16.770
剑头函数

32:16.770 --> 32:18.770
剑头函数在内里边

32:18.770 --> 32:20.770
它绑定的

32:20.770 --> 32:22.770
我们这里单独记彼

32:22.770 --> 32:26.910
剑头函数

32:26.910 --> 32:28.910
剑头函数

32:28.910 --> 32:30.910
在

32:30.910 --> 32:32.910
属性

32:32.910 --> 32:34.910
在制断初始

32:34.910 --> 32:36.910
初始画器

32:36.910 --> 32:38.910
位置上

32:38.910 --> 32:40.910
指向

32:40.910 --> 32:42.910
当前对象

32:42.910 --> 32:44.910
也就是说Z

32:44.910 --> 32:46.910
它指向的是当前对象

32:46.910 --> 32:48.910
为什么Z是指向的当前对象呢

32:48.910 --> 32:50.910
因为我们刚才说过

32:50.910 --> 32:52.910
制断初始画器

32:52.910 --> 32:54.910
相当于是在

32:54.910 --> 32:58.910
构造函数前边写上了这么一句话

32:58.910 --> 33:00.910
写上了这么一句话

33:00.910 --> 33:02.910
那里看一下

33:02.910 --> 33:04.910
这个位置的Z是不是就是当前对象

33:04.910 --> 33:05.910
对不对

33:05.910 --> 33:06.910
是不是就当前对象

33:06.910 --> 33:08.910
所以通过这种方式

33:08.910 --> 33:09.910
可以绑定Z

33:09.910 --> 33:10.910
它属一遍怎么玩

33:10.910 --> 33:12.910
Z是使用指向当前对象

33:12.910 --> 33:14.910
你看一下Z是等于123

33:14.910 --> 33:16.910
那么我们来

33:16.910 --> 33:18.910
我来一些画样出来

33:18.910 --> 33:20.910
P,T,Print

33:20.910 --> 33:22.910
这样调用,你看一下

33:22.910 --> 33:24.910
还是123,没有爆错

33:24.910 --> 33:26.910
因为我们知道

33:26.910 --> 33:28.910
剑头函数,它内部是没有Z的

33:28.910 --> 33:30.910
它一定是指向了外层Z

33:30.910 --> 33:32.910
就运行定义剑头函数的位置Z

33:32.910 --> 33:34.910
那么这个时候Z是指向的是当前对象

33:34.910 --> 33:36.910
但是你一定要注意

33:36.910 --> 33:38.910
这样子一来

33:38.910 --> 33:40.910
跟之前是有区别的

33:40.910 --> 33:42.910
有什么区别呢

33:42.910 --> 33:44.910
之前的Print

33:44.910 --> 33:46.910
就正常写的Print是在圆形上边

33:46.910 --> 33:48.910
但是现在的Print

33:48.910 --> 33:50.910
再不再圆形了

33:50.910 --> 33:52.910
它不再圆形了

33:52.910 --> 33:54.910
它在对象里边

33:54.910 --> 33:56.910
也就是现在的Print

33:56.910 --> 33:58.910
通过TES创建的对象

33:58.910 --> 34:00.910
每一个都有一个Print

34:00.910 --> 34:02.910
不要说我们这样子写

34:02.910 --> 34:04.910
T,T2

34:04.910 --> 34:06.910
然后我们这里输出T1的Print

34:06.910 --> 34:08.910
是不是等于T2的Print呢

34:08.910 --> 34:10.910
FORCE不一样

34:10.910 --> 34:12.910
每一个对象有自己的Print

34:12.910 --> 34:14.910
因为它单码的实际上是这样子写的

34:14.910 --> 34:16.910
每一式创建一个对象

34:16.910 --> 34:18.910
是不是新建了一个Print的属性

34:18.910 --> 34:20.910
就像这个A一样

34:20.910 --> 34:22.910
每一个对象有一个自己的A

34:22.910 --> 34:24.910
每一个对象有一个自己的Print

34:24.910 --> 34:26.910
它会浪费内存空间

34:26.910 --> 34:28.910
但是它的好处在于绑定了Z

34:28.910 --> 34:30.910
以后有的时候会出现这种用法

34:30.910 --> 34:32.910
不说这种用法是错的

34:32.910 --> 34:34.910
有的时候会出现这种用法

34:34.910 --> 34:36.910
就是我们不是特别在乎它的内存空间

34:36.910 --> 34:38.910
占用,因为我们可能用内的对象

34:38.910 --> 34:40.910
并不多,可能就那么一两个

34:40.910 --> 34:42.910
不是很在乎它的内存空间占用

34:42.910 --> 34:44.910
但是你要知道

34:44.910 --> 34:46.910
它会占用额外的内存空间

34:46.910 --> 34:48.910
因为每个对象有一个

34:48.910 --> 34:50.910
它不是在原象上表

34:50.910 --> 34:52.910
注意这一点

34:52.910 --> 34:54.910
这是关于属性初始化汽车一块

34:54.910 --> 34:56.910
下面这个内表达式

34:56.910 --> 34:58.910
就什么意思呢

34:58.910 --> 35:00.910
就是说内它由于本质上是一个

35:00.910 --> 35:02.910
构造函数,本质上在介石底层

35:02.910 --> 35:04.910
它会把它转换成函数

35:04.910 --> 35:06.910
因此它也是可以写表达式的

35:06.910 --> 35:08.910
表达式我们看一下怎么写吧

35:08.910 --> 35:12.610
比方说这里有一个内

35:12.610 --> 35:14.610
我们这里写这么一个内

35:14.610 --> 35:16.610
我们把它写成一个表达式的格式

35:20.610 --> 35:22.610
我们写上一个内可以这样写

35:22.610 --> 35:24.610
那么就相当于

35:24.610 --> 35:26.610
这是一个匿名内对吧

35:26.610 --> 35:28.610
没有名字,匿名内

35:28.610 --> 35:30.610
因为表达式我们也不需要名字

35:30.610 --> 35:32.610
当然你写名字也可以

35:32.610 --> 35:34.610
比方说这里我们不需要名字

35:34.610 --> 35:36.610
写上这么一个匿名内

35:36.610 --> 35:38.610
它没有名字

35:38.610 --> 35:40.610
那么我们把整个内的负质给A

35:40.610 --> 35:42.610
那么这一块就是一个表达式

35:42.610 --> 35:44.610
内表达式

35:44.610 --> 35:46.610
当然这里边写法是完全一样的

35:46.610 --> 35:48.610
完全一样的

35:48.610 --> 35:50.610
比方说我们写一个之段初始化汽车B等于2

35:50.610 --> 35:52.610
那么我们看一下吧

35:52.610 --> 35:54.610
6一个A

35:54.610 --> 35:56.610
我们输出A

35:56.610 --> 35:58.610
你看一下,一样的道理

35:58.610 --> 36:00.610
一样的道理

36:00.610 --> 36:02.610
这就是内表达式

36:02.610 --> 36:04.610
有的时候,一个函数调用过后

36:04.610 --> 36:06.610
它可以返回一个内

36:06.610 --> 36:08.610
所以说内跟函数本质一样

36:08.610 --> 36:10.610
它也是GS的一等公铭

36:10.610 --> 36:12.610
你可以把一个内

36:12.610 --> 36:14.610
当作是一个参数传递

36:14.610 --> 36:16.610
也可以把一个内

36:16.610 --> 36:18.610
当成是一个返回值

36:18.610 --> 36:20.610
都可以,可以实现很多灵活的运用

36:20.610 --> 36:22.610
因为内的本质上

36:22.610 --> 36:24.610
在GS里面就是函数

36:24.610 --> 36:26.610
这是个内表达式

36:28.610 --> 36:30.610
好,最后一个是一些扩展知识

36:30.610 --> 36:32.610
如果说你对扩展知识不是很感冒的话

36:32.610 --> 36:34.610
你可以不听

36:34.610 --> 36:36.610
因为这一块东西

36:36.610 --> 36:38.610
它是ES7的东西

36:38.610 --> 36:40.610
第二个它还没有成为正式标准

36:40.610 --> 36:42.610
叫装饰器

36:42.610 --> 36:44.610
叫Decorator

36:48.610 --> 36:50.610
叫装饰器

36:50.610 --> 36:52.610
目前还没有成为正式标准

36:52.610 --> 36:54.610
因此我们这一块讲的时候

36:54.610 --> 36:56.610
点到极值即可

36:56.610 --> 36:58.610
因为将来

36:58.610 --> 37:00.610
可能会发生比较大的改动

37:00.610 --> 37:02.610
这一块标准

37:02.610 --> 37:04.610
大家了解一下就行了

37:04.610 --> 37:06.610
装饰器它是来做什么事的呢

37:06.610 --> 37:08.610
它是来

37:08.610 --> 37:10.610
做这么一件事的

37:10.610 --> 37:12.610
我们举个例子吧

37:12.610 --> 37:14.610
举个例子

37:14.610 --> 37:18.050
比方说吧

37:18.050 --> 37:20.050
我们这里有个类

37:20.050 --> 37:22.050
Test

37:22.050 --> 37:26.050
它里面有这么一个方法

37:26.050 --> 37:30.580
举个例子

37:30.580 --> 37:32.580
那么这个方法

37:32.580 --> 37:34.580
我们这里就书书

37:34.580 --> 37:36.580
Print方法

37:36.580 --> 37:38.580
这个方法

37:38.580 --> 37:40.580
我这里没有写构造寒书

37:40.580 --> 37:42.580
不说没有写它就没有

37:42.580 --> 37:44.580
它有只是它里边没代码而已

37:44.580 --> 37:46.580
没有写构造寒书

37:46.580 --> 37:48.580
没有写构造期就相当于写了这么一个东西

37:48.580 --> 37:50.580
你可以不写的

37:50.580 --> 37:52.580
比方说我有的时候

37:52.580 --> 37:54.580
有些寒书我们写了

37:54.580 --> 37:56.580
有些内容写了之后

37:56.580 --> 37:58.580
它在某一些方法

37:58.580 --> 38:00.580
我们不再使用了

38:00.580 --> 38:02.580
那么这个时候

38:02.580 --> 38:04.580
我们通常怎么办呢

38:04.580 --> 38:06.580
我们不太可能说

38:06.580 --> 38:08.580
为了让别人觉得低一点

38:08.580 --> 38:10.580
觉得不可能把它删了

38:10.580 --> 38:12.580
为什么因为纠的系统里边

38:12.580 --> 38:14.580
可能还在用这个方法

38:14.580 --> 38:16.580
之前用这个内的系统就爆错了

38:16.580 --> 38:18.580
你不能删

38:18.580 --> 38:20.580
但是我们又想给它一个提示

38:20.580 --> 38:22.580
给它一个提示

38:22.580 --> 38:24.580
然后提示它这个方法

38:24.580 --> 38:26.580
已经出了问题了

38:26.580 --> 38:28.580
那么这个提示

38:28.580 --> 38:30.580
是不是可以在这里边加上一句

38:30.580 --> 38:32.580
加上一句不然回来

38:32.580 --> 38:34.580
我们加上一个

38:36.580 --> 38:38.580
Prince方法

38:38.580 --> 38:40.580
以过时

38:40.580 --> 38:42.580
可以加上这么一句话

38:42.580 --> 38:44.580
这一块是扩展之声

38:44.580 --> 38:46.580
你爱听就听一下

38:46.580 --> 38:48.580
但是这样子一来

38:48.580 --> 38:50.580
如果说我们这段的需求

38:50.580 --> 38:52.580
经常都会发生

38:52.580 --> 38:54.580
我们写了二十几个类

38:54.580 --> 38:56.580
那么经常我们都可能要做这件事情

38:56.580 --> 38:58.580
有的时候我觉得这个方法过时了

38:58.580 --> 39:00.580
标记一下

39:00.580 --> 39:02.580
然后有一天我发现

39:02.580 --> 39:04.580
它没有过时又可以用了

39:04.580 --> 39:06.580
你把它取消掉

39:06.580 --> 39:08.580
那么这样子通过改动代码的方式

39:08.580 --> 39:10.580
你通过改动这个函数体的方式来执行

39:10.580 --> 39:12.580
太low了

39:12.580 --> 39:14.580
而且太麻烦了

39:14.580 --> 39:16.580
而且太容易出问题了

39:16.580 --> 39:18.580
改的可能就写错了

39:18.580 --> 39:20.580
不要去改动函数

39:20.580 --> 39:22.580
那么怎么办呢

39:23.580 --> 39:26.580
横切关注点的问题

39:26.580 --> 39:28.580
关注点

39:28.580 --> 39:30.580
就是有一些功能

39:30.580 --> 39:32.580
比方说什么日式记录

39:32.580 --> 39:34.580
全线控制

39:34.580 --> 39:36.580
比方说方法有没有过时

39:36.580 --> 39:38.580
有一些功能它是不是功能

39:38.580 --> 39:40.580
它是功能它具有通用性

39:40.580 --> 39:42.580
它跟每一个内里边的

39:42.580 --> 39:44.580
具体的功能无关

39:44.580 --> 39:46.580
你看方法有没有过时

39:46.580 --> 39:48.580
跟内里边打印功能

39:48.580 --> 39:50.580
有没有什么关系

39:50.580 --> 39:54.580
那么它是单独抽离出来的一块功能

39:54.580 --> 39:57.580
那么最于一个横切关注点的问题

39:57.580 --> 40:00.580
最合适的就是使用装饰器

40:00.580 --> 40:01.580
就是什么意思呢

40:01.580 --> 40:03.580
我在这里做一个标记

40:03.580 --> 40:05.580
标记

40:05.580 --> 40:07.580
已过期

40:07.580 --> 40:09.580
是不是这样子最舒服

40:09.580 --> 40:11.580
标记下一个方法已经过期了

40:11.580 --> 40:13.580
如果说它有一天

40:13.580 --> 40:14.580
它没有过期了

40:14.580 --> 40:16.580
我把标记取消掉就完了

40:16.580 --> 40:18.580
就做标记有效了

40:18.580 --> 40:19.580
这就是装饰器

40:19.580 --> 40:22.580
装饰器的语法是一个eater

40:22.580 --> 40:24.580
后边写上装饰器的名称

40:24.580 --> 40:27.580
比方说我们这里的要过期了

40:27.580 --> 40:28.580
过期我看一下

40:28.580 --> 40:30.580
我查一下单词吧

40:30.580 --> 40:31.580
这单词啊

40:31.580 --> 40:33.580
我的英语啊

40:35.580 --> 40:39.530
过期

40:39.530 --> 40:40.530
Expire

40:40.530 --> 40:41.530
我们就用这个吧

40:41.530 --> 40:42.530
Expire

40:42.530 --> 40:44.530
或者是

40:44.530 --> 40:45.530
就是吧

40:45.530 --> 40:46.530
Expire

40:46.530 --> 40:49.530
好像你平时我记得是一个

40:49.530 --> 40:51.530
有另外一个单词

40:51.530 --> 40:53.530
过时

40:53.530 --> 40:55.530
Obsnate

40:55.530 --> 40:57.530
就这个单词

40:57.530 --> 40:59.530
标记一下就完事了

40:59.530 --> 41:01.530
标记一下就完事了

41:01.530 --> 41:03.530
那么怎么标记呢

41:03.530 --> 41:05.530
你看他这里告诉你的

41:05.530 --> 41:07.530
是一个未来版本中要更改的功能

41:07.530 --> 41:10.530
他说你现在尽量不要用

41:10.530 --> 41:12.530
但是实际上是可以用的

41:12.530 --> 41:14.530
实际上在榴弹器那边是可以用的

41:14.530 --> 41:16.530
那么这个方法呢

41:16.530 --> 41:18.530
这个标记

41:18.530 --> 41:19.530
肯定要报错

41:19.530 --> 41:20.530
现在肯定要出问题

41:20.530 --> 41:21.530
为什么呢

41:21.530 --> 41:23.530
因为这个标记是你自己定义的

41:23.530 --> 41:24.530
有这个标记吗

41:24.530 --> 41:25.530
不存在

41:25.530 --> 41:26.530
那么装饰器

41:26.530 --> 41:27.530
实际上是什么呢

41:27.530 --> 41:30.530
装饰器的本质是一个函数

41:30.530 --> 41:32.530
装饰器的本质

41:32.530 --> 41:34.530
是一个函数

41:34.530 --> 41:36.530
也说你这里的写的这个东西呢

41:36.530 --> 41:37.530
实际上是一个函数

41:37.530 --> 41:38.530
Instagram你要写这么一个函数

41:38.530 --> 41:40.530
叫Obsnate

41:40.530 --> 41:42.530
这个函数呢有三个参数

41:42.530 --> 41:45.530
第一个参数呢是内名

41:45.530 --> 41:47.530
就是内本身

41:47.530 --> 41:48.530
内本身

41:48.530 --> 41:49.530
就是Toget

41:49.530 --> 41:50.530
我们通常用Toget

41:50.530 --> 41:51.530
内本身

41:51.530 --> 41:54.530
第二个参数呢是成员的名字

41:54.530 --> 41:56.530
我们通常把它叫方法名字

41:56.530 --> 41:58.530
Message.name

41:58.530 --> 41:59.530
方法名字

41:59.530 --> 42:01.530
第三个参数呢

42:01.530 --> 42:04.530
第三个参数是那个方法的

42:04.530 --> 42:07.530
叫做Descriptor

42:07.530 --> 42:08.530
Descriptor是什么呢

42:08.530 --> 42:09.530
就是方法的这个东西

42:09.530 --> 42:12.530
我们平时用Object Define Property的时候

42:12.530 --> 42:14.530
不是第一个参数是什么对象

42:14.530 --> 42:15.530
这个参数是什么

42:15.530 --> 42:16.530
属性名对不对

42:16.530 --> 42:18.530
第三个参数就是Descriptor

42:18.530 --> 42:20.530
那么他会把这个属性的Descriptor

42:20.530 --> 42:21.530
传给你

42:21.530 --> 42:22.530
来看一下

42:22.530 --> 42:23.530
我们这里输出一下

42:23.530 --> 42:24.530
Toget

42:24.530 --> 42:27.530
Message.name

42:27.530 --> 42:29.530
Descriptor

42:29.530 --> 42:31.530
好我写完了

42:31.530 --> 42:33.530
但是呢我很想给你们看一下效果

42:33.530 --> 42:36.530
但是呢很影响看不到

42:36.530 --> 42:37.530
因为目前呢

42:37.530 --> 42:38.530
这个装饰器呢

42:38.530 --> 42:40.530
还没有成为正式的标准

42:40.530 --> 42:41.530
所以说呢浏览器

42:41.530 --> 42:42.530
它是不会给你支持的

42:42.530 --> 42:43.530
你看不到的

42:43.530 --> 42:44.530
它要爆错的

42:44.530 --> 42:46.530
你看这里我们看一下吧

42:46.530 --> 42:47.530
它爆错的

42:47.530 --> 42:48.530
语法错误

42:48.530 --> 42:49.530
这个地方语法错误

42:49.530 --> 42:51.530
它不支持

42:51.530 --> 42:52.530
以后呢我们

42:52.530 --> 42:54.530
学了这个TypeScript的时候呢

42:54.530 --> 42:56.530
我们有办法让它支持

42:56.530 --> 42:58.530
但是现阶段我们做不到

42:58.530 --> 42:59.530
现在我们以后呢

42:59.530 --> 43:00.530
用Bebop呢

43:00.530 --> 43:01.530
也可以让它支持

43:01.530 --> 43:03.530
但是现阶段做不到

43:03.530 --> 43:04.530
我这一段呢

43:04.530 --> 43:05.530
我只是告诉大家

43:05.530 --> 43:06.530
有这么一个东西

43:06.530 --> 43:08.530
那么我这里就手动的告诉你

43:08.530 --> 43:09.530
因为以后呢

43:09.530 --> 43:10.530
我们讲TypeScript

43:10.530 --> 43:11.530
TypeScript的时候

43:11.530 --> 43:12.530
还会详细讲这个东西

43:12.530 --> 43:14.530
所以我现在就手动的告诉你

43:14.530 --> 43:15.530
这个玩意呢

43:15.530 --> 43:16.530
它会输出什么呢

43:16.530 --> 43:17.530
Target呢

43:17.530 --> 43:19.530
它会输出这个Test

43:19.530 --> 43:20.530
方形

43:20.530 --> 43:22.530
Test

43:22.530 --> 43:23.530
然后呢

43:23.530 --> 43:24.530
MessageName会输出什么呢

43:24.530 --> 43:26.530
会输出Print

43:26.530 --> 43:27.530
支付串

43:27.530 --> 43:29.530
这个输出会输出什么呢

43:29.530 --> 43:30.530
会输出一个对象

43:30.530 --> 43:31.530
这个Values是什么呢

43:31.530 --> 43:33.530
Values是一个函数

43:33.530 --> 43:34.530
函数

43:34.530 --> 43:35.530
Print

43:35.530 --> 43:36.530
有这么一个函数

43:36.530 --> 43:37.530
等等等等

43:37.530 --> 43:39.530
还有些其他的

43:39.530 --> 43:40.530
对吧

43:40.530 --> 43:41.530
还有些其他的属性

43:42.530 --> 43:44.530
Descript

43:44.530 --> 43:45.530
那么我们利用这个地方呢

43:45.530 --> 43:47.530
我们就可以做一些事情了

43:47.530 --> 43:48.530
做什么事情呢

43:48.530 --> 43:50.530
我们就可以用这个Descript

43:50.530 --> 43:51.530
它里边

43:51.530 --> 43:52.530
Descript

43:52.530 --> 43:53.530
它里边不是一个Values吗

43:53.530 --> 43:54.530
好

43:54.530 --> 43:57.530
我们把Values给它改一下

43:57.530 --> 43:58.530
改一下

43:58.530 --> 44:00.530
它不是要接受一些参数吗

44:00.530 --> 44:01.530
OK

44:01.530 --> 44:02.530
我不管你接受什么参数

44:02.530 --> 44:03.530
因为我也不一定是

44:03.530 --> 44:05.530
只是用来修饰它的

44:05.530 --> 44:06.530
我可以用来修饰任何方法

44:06.530 --> 44:08.530
都可以把它变成过期

44:08.530 --> 44:09.530
你说掉用这个方法

44:09.530 --> 44:10.530
你给我传的什么参数

44:10.530 --> 44:11.530
无所谓

44:11.530 --> 44:13.530
我们先把这个Values

44:13.530 --> 44:15.530
先把这个Values

44:15.530 --> 44:18.530
先把这个Values保存一下

44:18.530 --> 44:22.530
先把这个Values保存一下

44:22.530 --> 44:23.530
const

44:23.530 --> 44:24.530
old

44:24.530 --> 44:25.530
funk

44:25.530 --> 44:26.530
原来的函数

44:26.530 --> 44:28.530
就是把Print原来的函数

44:28.530 --> 44:30.530
保存到这

44:30.530 --> 44:31.530
然后我们重新给它复制

44:31.530 --> 44:33.530
复制为一个新的函数

44:33.530 --> 44:34.530
这个新的函数一开始

44:34.530 --> 44:38.530
先输出一个Wo

44:38.530 --> 44:39.530
哪个方法已经过期了

44:39.530 --> 44:40.530
哪个方法

44:40.530 --> 44:42.530
是不是Messon的Name

44:42.530 --> 44:43.530
Messon的Name方法

44:43.530 --> 44:45.530
已过时

44:45.530 --> 44:47.530
是不是已经过时了

44:47.530 --> 44:48.530
然后我再去

44:48.530 --> 44:50.530
但是过时的不是说不能用

44:50.530 --> 44:51.530
要兼容就系统

44:51.530 --> 44:52.530
我只是提示你已经过时了

44:52.530 --> 44:54.530
然后我再去掉用函数

44:54.530 --> 44:55.530
funk

44:55.530 --> 44:56.530
oldfunk

44:56.530 --> 44:57.530
但是掉的时候

44:57.530 --> 44:58.530
不要忘记了

44:58.530 --> 44:59.530
绑计Zs

44:59.530 --> 45:00.530
通过Zs的掉用

45:00.530 --> 45:01.530
不能直接掉用

45:01.530 --> 45:02.530
要用什么

45:02.530 --> 45:07.530
用扣

45:07.530 --> 45:08.530
或者说

45:08.530 --> 45:11.530
用Apply

45:11.530 --> 45:12.530
掉用

45:12.530 --> 45:13.530
Zs是什么

45:13.530 --> 45:14.530
那当前对象是什么

45:14.530 --> 45:15.530
当前对象就是Zs

45:15.530 --> 45:17.530
因为你掉用这个函数的时候

45:17.530 --> 45:18.530
是不是Zs就指向了

45:18.530 --> 45:20.530
指向的是当前对象

45:20.530 --> 45:21.530
Zs

45:21.530 --> 45:22.530
然后其他的函数

45:22.530 --> 45:23.530
形成的数组

45:23.530 --> 45:26.530
其他参照形成的数组就是Oculus

45:26.530 --> 45:27.530
我们用这种方式来掉用

45:27.530 --> 45:28.530
那么这样子

45:28.530 --> 45:30.530
我真的好想给你们看一下这个效果

45:30.530 --> 45:32.530
这样子就非常方便了

45:32.530 --> 45:33.530
以后有任何函数过期

45:33.530 --> 45:35.530
我们都可以加上这个装饰器

45:35.530 --> 45:36.530
但是很遗憾

45:36.530 --> 45:37.530
我们目前看不到

45:37.530 --> 45:38.530
没关系

45:38.530 --> 45:39.530
你有这么一个印象

45:39.530 --> 45:40.530
知道ES7里面

45:40.530 --> 45:41.530
提供了这么一个功能

45:41.530 --> 45:42.530
可以横切关注点

45:42.530 --> 45:44.530
有这么个印象就很不错了

45:44.530 --> 45:45.530
我们后边讲到

45:45.530 --> 45:46.530
Bible

45:46.530 --> 45:49.530
讲到那个TypeScript的时候

45:49.530 --> 45:50.530
还会说到这个东西

45:50.530 --> 45:51.530
有这么个印象就行了

45:51.530 --> 45:54.530
到时候就不是扩展课程了

45:54.530 --> 45:55.530
这是关于这一块

45:55.530 --> 45:56.530
装饰器

45:56.530 --> 45:57.530
我们说一下就行了

45:57.530 --> 45:58.530
有这么个印象就行了

45:58.530 --> 45:59.530
其他的没啥了

45:59.530 --> 46:00.530
那么这里可能

46:00.530 --> 46:01.530
我们就介绍了

46:01.530 --> 46:02.530
更多的内里边

46:02.530 --> 46:04.530
提供的一些与法支持

46:04.530 --> 46:05.530
那么大家会发现

46:06.530 --> 46:07.530
他的主要目的

46:07.530 --> 46:08.530
就是让我们的

46:08.530 --> 46:09.530
整个面向对向的书写量

46:09.530 --> 46:10.530
更加流畅

46:10.530 --> 46:11.530
更加便捷

46:12.530 --> 46:13.530
这是这一块的知识

46:13.530 --> 46:14.530
每一个点

46:14.530 --> 46:16.530
除了装饰器这一块

46:16.530 --> 46:17.530
除了这一块之外

46:17.530 --> 46:18.530
每个点

46:18.530 --> 46:19.530
按照课程上的代码

46:19.530 --> 46:20.530
就写一遍

46:20.530 --> 46:21.530
甭管了一个代码

46:21.530 --> 46:22.530
有没有什么意义

46:22.530 --> 46:23.530
写一遍就会有印象

46:23.530 --> 46:24.530
好吧

46:24.530 --> 46:25.530
这是关于这一块

