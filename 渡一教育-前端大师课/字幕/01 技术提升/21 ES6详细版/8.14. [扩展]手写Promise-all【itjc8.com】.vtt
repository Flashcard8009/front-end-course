WEBVTT

00:00.110 --> 00:03.390
好 这节课咱们来实现Promise的另外一个静态方法

00:03.390 --> 00:04.590
叫做Or

00:04.590 --> 00:09.510
Or这个静态方法里边可以传一个什么 传一个宿主 对吧

00:09.510 --> 00:12.430
虽然说它可以传宿主 其实呢

00:12.430 --> 00:15.430
它不仅仅可以传宿主 还可以传什么呀

00:15.430 --> 00:17.870
还可以传迭代器

00:17.870 --> 00:21.150
就是Aterator 迭代器

00:21.150 --> 00:24.030
前边的面试题呢 大家学过了迭代器 对吧

00:24.030 --> 00:27.670
其实宿主呢也是一种迭代 是迭代器的一种

00:27.710 --> 00:32.830
迭代器一个特点是什么 可以使用ForOf循环来循环它

00:32.830 --> 00:35.430
但是呢 你不能使用For循环啊

00:35.430 --> 00:38.670
因为迭代器它不一定有下标的 懂得意思吗

00:38.670 --> 00:42.990
你不能使用For循环 而宿主呢是一种迭代器

00:42.990 --> 00:47.350
只不过宿主它支持For循环 它包括伪宿主

00:47.350 --> 00:51.030
伪宿主也是迭代器 那么它支持For循环

00:51.030 --> 00:53.910
但是呢 不是所有的迭代器都支持For循环的

00:53.910 --> 00:56.950
它得到这么一个迭代器 就这里边可以传迭代器的

00:56.950 --> 01:01.110
虽然我们经常反对都是宿主 但是呢我们要把它想象成迭代器

01:01.110 --> 01:04.510
这是面试题 你能不能拿高分的一个点

01:04.510 --> 01:08.030
就写这个O方法的时候 注意啊

01:08.030 --> 01:10.990
所以说你到时候写这个O方法 那么这里传的一个宿主

01:10.990 --> 01:14.030
哎 你要变立它 你能不能用For循环变立 不能

01:14.030 --> 01:16.750
因为它不一定传的是宿主 它可能传的是别的迭代器

01:16.750 --> 01:19.630
它可能没有下标 到时候面试的时候

01:19.630 --> 01:22.590
你就写的是For二五循环 那么面试完问题

01:22.590 --> 01:24.950
你为什么要用For二五啊 为什么不用用For循环啊

01:24.950 --> 01:27.750
你就告诉它 因为这里它传的是迭代器

01:27.750 --> 01:30.950
迭代器是不能用For循环来循环它的

01:30.950 --> 01:33.750
这是一个考点 同样要记住

01:33.750 --> 01:37.990
好 那么现在呢我们知道O方法不用解释了吧

01:37.990 --> 01:40.630
它就是什么意思呢 就这里边传了很多东西

01:40.630 --> 01:43.950
传了很多的Promise 你留一个Promise 里面

01:43.950 --> 01:49.190
你留很多个Promise Pro一 Pro二啊 传了很多个Promise

01:49.190 --> 01:53.110
它比这个函数 它会返回一个新的Promise

01:53.270 --> 01:56.790
这个新的Promise 什么时候完成 成功

01:56.790 --> 02:02.550
必须要这里边的所有的Promise 全部成功之后它才成功

02:02.550 --> 02:04.470
那么比方说 第一个Promise成功之后

02:04.470 --> 02:08.070
数据是1 第二个Promise 数据是12 第三个Promise 数据是3

02:08.070 --> 02:12.590
那么它成功之后呢 它这里得到了是一个宿主

02:12.590 --> 02:16.230
这个Data是一个宿主 这个Data的纸呢就应该是

02:16.230 --> 02:19.830
一 二 三 懂的意思吗

02:19.830 --> 02:21.550
好 那如果说这个宿主里面传的是

02:21.630 --> 02:25.310
还有一个没有传Promise 没有传Promise的话

02:25.310 --> 02:27.670
它里边会给你进行处理 怎么处理呢

02:27.670 --> 02:31.350
它就把它变成Promise Resolve 4 懂的意思吗

02:31.350 --> 02:32.630
就用这种方式来处理的

02:32.630 --> 02:35.910
所以这里边变成了一 二 三 四

02:35.910 --> 02:39.350
这就是这么一个逻辑 必须要全部成功

02:39.350 --> 02:42.150
我这个才成功 那什么时候失败呢

02:42.150 --> 02:45.030
只要有任何一个Promise失败了

02:45.030 --> 02:48.110
哪个先失败 那么我这边反正就是失败了

02:48.110 --> 02:51.030
只要有任何一个Promise失败 那我就这就失败了

02:51.030 --> 02:52.470
那失败的原因是什么呢

02:52.470 --> 02:56.230
就是第一个Promise失败的原因 比方说它先失败了

02:56.230 --> 02:59.870
那它失败的原因是Resolve 2 那么这里边

02:59.870 --> 03:05.510
那么Resolve就变成了Resolve 2 懂的意思吗

03:05.510 --> 03:08.270
就这么一个逻辑 好 咱们来写这个逻辑

03:08.270 --> 03:12.070
Promise这个Or方法也是面试的时候比较容易考到的

03:12.070 --> 03:14.990
写一个Or方法 但我再一次啊

03:14.990 --> 03:18.590
罗利巴说这个元老师太啰说了 再一次重生啊

03:18.590 --> 03:20.070
如果说面试让你写Or方法

03:20.070 --> 03:22.350
没有让你前面去实现自己的Promise

03:22.350 --> 03:24.270
你该怎么写 应该在这里写啊

03:24.270 --> 03:26.510
Or方法 懂不懂意思吧

03:26.510 --> 03:29.270
这个不要怪我罗利巴说

03:29.270 --> 03:31.190
我就生化同学们没搞清楚啊

03:31.190 --> 03:34.790
到时候写的不知道在哪里写 我就有点郁闷了

03:34.790 --> 03:39.100
好 那么这边呢 我就得到一个参数啊

03:39.100 --> 03:42.660
这是一个Aterator

03:42.660 --> 03:46.700
这里是一个Aterator 怎么来订呢

03:46.700 --> 03:48.820
我只能这样订吧

03:48.820 --> 03:52.980
这是一个得到所有的Promise

03:52.980 --> 03:58.940
就是得到一个新的Promise

03:58.940 --> 04:12.740
该Promise的状态取决于Promise的执行

04:12.740 --> 04:14.980
这个玩意我就不过都打中诗了

04:14.980 --> 04:18.780
它是一个迭代器 还是多写一下吧

04:18.940 --> 04:25.500
是一个迭代器 包含多个Promise

04:25.500 --> 04:35.640
全部Promise成功 则返回的Promise成功

04:35.640 --> 04:44.240
数据为所有Promise成功的数据

04:44.240 --> 04:45.800
就这里面的数据是1234

04:45.800 --> 04:47.680
那成功的数据1234

04:47.840 --> 04:53.200
并且数据的数据

04:53.200 --> 04:56.160
它不是按照谁先完成 谁就是第一个 不是的

04:56.160 --> 04:57.320
它是按照数组的数据

04:57.320 --> 04:59.760
不要说你它先完成 它的数据是3

04:59.760 --> 05:02.040
不好意思 三还是在这儿

05:02.040 --> 05:08.880
懂的意思吧 并且数据是按照传入的数据

05:08.880 --> 05:11.320
然后排列

05:11.320 --> 05:16.880
那么只要有一个Promise失败

05:16.880 --> 05:20.560
则返回的Promise失败

05:20.560 --> 05:26.920
原因是第一个失败的Promise的原因

05:26.920 --> 05:30.040
这是它的核心逻辑 我把数据打全一点

05:30.040 --> 05:32.000
好了 来实现吧

05:32.000 --> 05:33.720
Return 现在啥都不要想

05:33.720 --> 05:35.240
你给我返回一个Promise再说

05:35.240 --> 05:36.920
当然我这里要返回的是MyPromise

05:36.920 --> 05:39.920
我再一次罗里巴说了再重生一次

05:40.120 --> 05:42.920
你们那边如果说让你单独实现恶方法的时候

05:42.920 --> 05:45.000
这里返回的也不要说一个MyPromise

05:45.000 --> 05:47.120
我就怕同学们照抄我的天呐

05:47.120 --> 05:48.800
照抄的话就很尴尬了

05:48.800 --> 05:50.600
到时候要返回官方的

05:51.960 --> 05:53.880
好 那么现在我返回Promise了

05:54.600 --> 05:57.640
接下来呢 怎么来处理呢

05:59.160 --> 06:01.400
首先我肯 这个要不要循环

06:01.400 --> 06:03.560
那肯定要循环啊 对不对

06:03.560 --> 06:04.760
那么我们循环一个

06:05.360 --> 06:07.120
循环每一个Promise

06:07.560 --> 06:09.360
用FoO5循环 一定要用FoO5

06:10.680 --> 06:12.040
现在我们是不是

06:12.040 --> 06:15.600
因为我们先假设他所有的都能成功

06:15.600 --> 06:17.440
那成功的时候我是不是要给他

06:17.440 --> 06:19.760
最终我要给他Return 5一个东西 对吧

06:19.760 --> 06:21.280
Return 5一个什么东西呢

06:21.280 --> 06:25.280
Return 5一个数组

06:26.280 --> 06:28.320
最终我要给他Return 5一个数组

06:28.320 --> 06:30.360
我叫调入Return 5方法给他一个数组

06:30.360 --> 06:32.280
那比方说有四个 就是1 2 3 4

06:32.280 --> 06:34.120
我要把它传进去

06:34.120 --> 06:35.960
那么我这里是不是要准备好一个数组

06:37.160 --> 06:38.440
对不对 那么我这里呢

06:38.440 --> 06:41.400
Results 准备好一个数组

06:41.400 --> 06:43.640
来接收每一个Promise

06:43.640 --> 06:46.440
成功之后的这么一个结果

06:46.440 --> 06:47.440
这个没问题吧

06:48.960 --> 06:51.120
好 那么现在大家思考一个问题

06:52.320 --> 06:53.800
两个问题其实

06:53.800 --> 06:55.040
第一个问题是

06:55.040 --> 06:58.640
我如何保证这个数组是有序的在排列

06:58.640 --> 06:59.880
什么叫有序的排列

06:59.880 --> 07:02.640
就第一个Promise完成之后

07:02.640 --> 07:05.720
我往这个数组 往这个数组里边加一下

07:05.840 --> 07:07.360
第二Promise完成之后

07:07.360 --> 07:09.240
我数组里边加一下

07:09.240 --> 07:11.440
你千万不能这样子写

07:11.440 --> 07:13.800
在每一个Promise你完成了

07:13.800 --> 07:16.080
你完成了 我就往那个数组里边Results

07:16.080 --> 07:17.160
Push一个Data

07:19.040 --> 07:20.040
你千万不能这样子写

07:20.040 --> 07:20.760
为什么呢

07:20.760 --> 07:23.120
因为你不知道哪一个先完成

07:23.120 --> 07:24.320
那万一三先完成了

07:24.320 --> 07:25.480
那就三就变成了第一个了

07:25.480 --> 07:26.400
三就变成第一个了

07:26.400 --> 07:28.120
我要保证有序

07:28.120 --> 07:29.320
这是第一个问题

07:29.320 --> 07:31.200
同样要去好几次思考

07:31.200 --> 07:32.600
第二个问题是什么呢

07:32.600 --> 07:35.400
我如何知道

07:35.440 --> 07:38.760
什么时候所有的Promise都完成了

07:38.760 --> 07:41.240
这个我如何知道

07:42.520 --> 07:44.320
是不是这里有好几个问题

07:46.040 --> 07:49.000
好 朋友们不知道自己有没有什么方案

07:49.000 --> 07:51.080
我这里给大家提供一种方案

07:51.080 --> 07:52.720
我这里写上了一个辨量

07:54.000 --> 07:55.440
叫做Code

07:57.160 --> 08:00.480
这个表示什么Promise的技术

08:01.480 --> 08:02.560
如果说用复讯环的话

08:02.560 --> 08:03.360
当有下标的话

08:03.360 --> 08:05.040
我就肯定比较容易知道了

08:05.080 --> 08:06.480
而且数组还有一个属性类似

08:06.480 --> 08:07.680
但是由于它是一个迭代器

08:07.680 --> 08:09.480
它不一定有类似属性

08:09.480 --> 08:10.880
更加不能用复讯环

08:10.880 --> 08:13.280
所以说我们这里要用个辨量技术

08:13.280 --> 08:14.960
一开始数字是多少呢

08:14.960 --> 08:16.680
数字是零 对吧

08:16.680 --> 08:18.520
一开始数字是零

08:18.520 --> 08:21.040
那么每询环一次

08:21.040 --> 08:22.800
我这个数字是不是要加加

08:24.760 --> 08:26.520
是不是要加加 对吧

08:27.680 --> 08:29.840
每一次询环数字加加嘛

08:29.840 --> 08:30.960
好 联想一想

08:30.960 --> 08:33.000
那询环结束之后

08:33.760 --> 08:35.040
我说不说别的

08:35.040 --> 08:37.640
这个Code是不是就是Promise的种数

08:38.880 --> 08:39.840
那肯定是嘛

08:39.840 --> 08:40.920
那比方说我们这里

08:40.920 --> 08:42.920
换成我们自己写的Promise

08:44.920 --> 08:45.480
来试一下

08:48.960 --> 08:50.800
这里没有这些东西

08:50.800 --> 08:52.480
那我就这里就直接写个

08:52.480 --> 08:55.600
myPromiseResult1

08:56.320 --> 08:58.120
然后这里Result2

08:58.920 --> 09:00.080
Result3

09:00.080 --> 09:01.400
好 那么这里

09:02.400 --> 09:03.640
好 我们来看一下

09:03.640 --> 09:04.800
一共有四个 对不对

09:05.800 --> 09:07.560
那这里是不是得到

09:07.560 --> 09:09.080
可以得到它的种数啊

09:09.080 --> 09:10.560
就是Promise的种数

09:10.560 --> 09:12.840
那么我们慢慢从零开始一个个G

09:14.200 --> 09:15.680
然后除了种数之外呢

09:15.680 --> 09:16.840
我们还需要一个辨量

09:18.200 --> 09:21.760
就是要得到这个Promise的完成数量

09:21.760 --> 09:25.120
就ForFilledCode

09:25.120 --> 09:26.160
它也是从零开始

09:27.200 --> 09:29.760
以完成的数量

09:29.800 --> 09:32.000
哪些Promise是已经完成的

09:32.000 --> 09:34.080
那么这个数量我怎么来记述呢

09:34.080 --> 09:36.640
是不是我只有等到这个Promise完成之后

09:37.800 --> 09:38.640
对不对

09:38.640 --> 09:40.480
你完成了一个

09:40.480 --> 09:42.400
那我就可以计个数了

09:42.400 --> 09:44.080
forFilledCode加加

09:46.800 --> 09:47.960
以完成的数量

09:48.920 --> 09:50.240
接下来让我们来输出一下

09:52.240 --> 09:53.080
forFilledCode

09:54.000 --> 09:54.440
运行

09:58.280 --> 09:58.560
运行

10:01.280 --> 10:03.400
运行怎么没消息呢

10:05.840 --> 10:06.280
前边

10:07.400 --> 10:09.560
Count加加

10:09.560 --> 10:10.880
我这里打断点了啊

10:10.880 --> 10:11.600
我看一下

10:11.600 --> 10:13.600
为什么他都没谈出来消息

10:18.910 --> 10:20.270
他都没有运行啊

10:20.270 --> 10:21.550
没有运行到这句话吗

10:22.910 --> 10:24.350
没有运行到这句话

10:25.790 --> 10:29.120
这有点神奇啊

10:29.120 --> 10:31.080
我们这里打个断点呢

10:33.000 --> 10:33.280
再来

10:36.350 --> 10:37.150
终于运行过来了

10:38.550 --> 10:39.790
好运行到这

10:39.790 --> 10:40.750
运行到这

10:40.750 --> 10:41.270
零

10:41.750 --> 10:42.270
零

10:43.110 --> 10:43.950
运行到这

10:44.550 --> 10:46.070
后边就没运行了啊

10:46.990 --> 10:48.310
我再来再来再试一下

10:48.950 --> 10:49.830
这是什么问题啊

10:51.350 --> 10:52.270
我一步步来啊

10:52.270 --> 10:52.910
运行到这

10:53.750 --> 10:56.910
这个加加现在变成了一没问题

10:56.910 --> 10:58.750
加加变成了二没问题

10:59.630 --> 11:00.470
变成了三

11:01.750 --> 11:02.590
三没问题

11:03.350 --> 11:04.110
再变成

11:05.110 --> 11:07.710
变成了四没问题

11:12.910 --> 11:14.590
这里出了问题

11:14.590 --> 11:16.030
这他没出了问题

11:16.030 --> 11:17.110
他应该给我爆错了

11:17.110 --> 11:18.270
他为什么没爆错了

11:18.270 --> 11:19.230
我知道这里有问题

11:19.230 --> 11:20.310
我知道这里有问题

11:20.310 --> 11:21.750
他为什么没有爆错啊

11:21.750 --> 11:23.430
这个我想来研究一下

11:23.430 --> 11:25.270
他为什么正常应该要爆错了

11:25.790 --> 11:26.670
为什么问题呢

11:26.670 --> 11:27.310
就是在这

11:28.070 --> 11:30.430
这一个四他不是promise

11:31.150 --> 11:31.750
那怎么办

11:31.750 --> 11:33.350
像这种不是promise怎么办

11:33.350 --> 11:33.990
我说过

11:33.990 --> 11:35.510
你就把它当成promise

11:35.550 --> 11:36.030
怎么办了

11:36.030 --> 11:37.510
就用result把包一下

11:38.070 --> 11:39.310
所以针对这个屁啊

11:39.310 --> 11:40.470
我先二话不说

11:40.470 --> 11:42.550
我先给他来一个mypromise

11:42.910 --> 11:43.990
result我再说

11:44.750 --> 11:45.070
对吧

11:45.070 --> 11:46.430
我先给他包一下再说

11:47.270 --> 11:47.830
那么你看一下

11:47.830 --> 11:49.150
我们之前是实现了result

11:49.430 --> 11:50.430
如果说你给我传的

11:50.430 --> 11:51.430
就是一个promise的话

11:51.430 --> 11:52.670
我直接把自身返回了

11:53.190 --> 11:53.670
对不对

11:53.950 --> 11:55.310
如果说其他情况的话

11:55.310 --> 11:56.270
我给你返回一个promise

11:56.270 --> 11:57.750
总之他返回的就是promise了

11:58.630 --> 12:00.030
因此给他包一下就没问题了

12:00.550 --> 12:00.790
好

12:00.790 --> 12:01.430
咱们来看吧

12:01.430 --> 12:02.950
但是他应该要爆错了才对啊

12:03.230 --> 12:04.790
那么现在得到了是四零

12:04.870 --> 12:05.070
好

12:05.070 --> 12:06.070
首先解释这个现象

12:06.590 --> 12:08.270
他为什么得到是四和零的

12:08.830 --> 12:10.190
不是这里全部都完成了吗

12:10.190 --> 12:10.350
对吧

12:10.350 --> 12:11.670
四个promise全部都完成了

12:11.670 --> 12:13.310
为什么得到是四和零的

12:13.950 --> 12:15.590
因为这个家是放到哪的

12:15.590 --> 12:16.550
是放到任里边的

12:16.550 --> 12:17.430
它是不是一部的

12:17.910 --> 12:19.390
它说放到无一队的里边执行

12:19.590 --> 12:20.710
因此执行这个代码的时候

12:20.710 --> 12:22.190
这个任也是不是还没有执行啊

12:22.830 --> 12:23.030
对吧

12:23.030 --> 12:23.790
是这个逻辑吗

12:24.590 --> 12:26.230
所以说我们这个focal

12:26.430 --> 12:27.830
这个地方在这里打印

12:27.830 --> 12:28.630
比方说

12:28.870 --> 12:30.830
for field code

12:31.390 --> 12:32.230
你完成了数量

12:32.950 --> 12:34.230
换句话说

12:34.230 --> 12:35.950
我还要说明什么道理呢

12:36.790 --> 12:38.150
代码运行到这儿

12:38.150 --> 12:40.110
是不是总数都已经确定好了

12:40.710 --> 12:42.070
你看这个航达码都运行到对吧

12:42.070 --> 12:43.550
说明循环早就结束了

12:43.550 --> 12:45.230
因为代码运行到这儿的时候

12:45.230 --> 12:45.990
循环已经结束了

12:45.990 --> 12:47.110
因为它在无一队的里边

12:47.110 --> 12:48.950
这个时候总数就已经出来了

12:49.550 --> 12:50.590
你没完成一个

12:50.590 --> 12:51.310
它加加

12:51.310 --> 12:52.470
然后我怎么来知道

12:52.470 --> 12:53.870
是不是最后一个呢

12:53.870 --> 12:55.590
是不是我这里判断一下

12:55.870 --> 12:57.070
for field code

12:57.470 --> 12:59.390
加了之后是不是等于靠着

12:59.830 --> 13:01.270
如果想等于说明啥

13:01.270 --> 13:05.270
说明当前是最后一个promise

13:05.270 --> 13:08.270
最后一个promise完成了

13:08.270 --> 13:10.270
那我们这里输出一下

13:10.270 --> 13:12.270
全部完成了

13:13.270 --> 13:14.270
ok 我们运行

13:15.270 --> 13:16.270
好 你看是不是全部完成了

13:16.270 --> 13:17.270
就在这里

13:17.270 --> 13:19.270
因此在这个位置我们使用什么

13:19.270 --> 13:20.270
使用于做

13:21.270 --> 13:22.270
是不是告诉他

13:22.270 --> 13:23.270
你全部都完

13:23.270 --> 13:24.270
全部都完成了

13:24.270 --> 13:25.270
是不是我这个promise也完成了

13:25.270 --> 13:27.270
因为一个order逻辑就是

13:27.270 --> 13:28.270
全部成功之后

13:28.270 --> 13:30.270
那我的也跟着成功了

13:30.270 --> 13:32.270
好 那么这里result

13:32.270 --> 13:33.270
好 别的不说

13:33.270 --> 13:35.270
我们看一下能不能正确的result

13:35.270 --> 13:36.270
成功

13:39.030 --> 13:40.030
这个没问题了

13:40.030 --> 13:41.030
对吧

13:41.030 --> 13:43.030
ok 那接下来就是数据了

13:43.030 --> 13:45.030
我传什么数据进去

13:45.030 --> 13:46.030
我传到什么数据

13:46.030 --> 13:47.030
肯定是传的是result

13:47.030 --> 13:48.030
这个毫无疑问

13:49.030 --> 13:51.030
这边我们要把result打印出来

13:51.030 --> 13:53.790
result

13:54.790 --> 13:55.790
运行

13:56.790 --> 13:57.790
打印出来是空的

13:57.790 --> 13:58.790
因为这个数字是空数字

13:58.790 --> 13:59.790
里边啥都没有

13:59.790 --> 14:01.790
好 传的是result

14:01.790 --> 14:02.790
那么现在呢

14:02.790 --> 14:04.790
result里边是没有值的

14:04.790 --> 14:06.790
那我怎么来给他复制呢

14:07.790 --> 14:08.790
刚刚之前是不是说过

14:08.790 --> 14:09.790
这个data

14:09.790 --> 14:11.790
表示我目前这个promise

14:11.790 --> 14:12.790
已经完成了

14:12.790 --> 14:13.790
它的数据是data

14:13.790 --> 14:15.790
但是我不能用poohy

14:15.790 --> 14:16.790
因为用poohy的话

14:16.790 --> 14:18.790
那么会导致顺序不对

14:19.790 --> 14:20.790
result

14:21.790 --> 14:22.790
我不能用poohy

14:22.790 --> 14:23.790
为什么现在不爆错了

14:23.790 --> 14:24.790
那问题是

14:24.790 --> 14:25.790
那边这个问题

14:25.790 --> 14:27.790
为什么不爆错了

14:28.790 --> 14:29.790
这个很糟糕

14:30.790 --> 14:31.790
刚才用的是这个

14:31.790 --> 14:32.790
这个都没有这个变量

14:32.790 --> 14:33.790
没有这个变量

14:33.790 --> 14:34.790
它应该给我爆错了

14:34.790 --> 14:35.790
结果不给我爆错

14:35.790 --> 14:36.790
是什么情况这是

14:40.790 --> 14:41.790
也不

14:41.790 --> 14:43.790
我明白了

14:43.790 --> 14:44.790
我明白了

14:44.790 --> 14:45.790
为什么不爆错

14:45.790 --> 14:46.790
是因为我那边开启掉了

14:46.790 --> 14:47.790
我那个promise里面

14:47.790 --> 14:49.790
没有在空置台打印错误

14:49.790 --> 14:50.790
我是把它开启掉了

14:50.790 --> 14:51.790
所以说

14:51.790 --> 14:52.790
如果说你要把这个

14:52.790 --> 14:53.790
做得完善一点的话

14:53.790 --> 14:54.790
在这个wrong里面

14:55.790 --> 14:56.790
如果说发现了错误

14:57.790 --> 14:58.790
我顺便

14:58.790 --> 14:59.790
除了result之外

14:59.790 --> 15:01.790
我顺便拿一个error

15:01.790 --> 15:03.790
打印一下这个错误

15:03.790 --> 15:04.790
现在我就知道了

15:04.790 --> 15:05.790
哪些

15:06.790 --> 15:07.790
错误是什么情况了

15:07.790 --> 15:08.790
当然也可以在

15:08.790 --> 15:09.790
不仅在这

15:09.790 --> 15:10.790
在勾到器里面

15:10.790 --> 15:11.790
这里有一个开启

15:11.790 --> 15:13.790
那么我们这里error

15:13.790 --> 15:14.790
console

15:14.790 --> 15:16.790
error打印错误

15:17.790 --> 15:18.790
就做这么一个处理完事了

15:18.790 --> 15:19.790
我说怎么回事

15:20.790 --> 15:22.790
不爆错误太奇怪了

15:22.790 --> 15:23.790
被开启掉了

15:24.790 --> 15:25.790
好

15:25.790 --> 15:26.790
那么现在回到这

15:27.790 --> 15:28.790
现在呢

15:28.790 --> 15:29.790
我们不能用poohi

15:29.790 --> 15:30.790
因为用poohi的话

15:30.790 --> 15:31.790
会导致

15:31.790 --> 15:32.790
我们把换成results

15:33.790 --> 15:34.790
它有可能会出现

15:34.790 --> 15:35.790
一种情况

15:35.790 --> 15:36.790
它就是

15:38.790 --> 15:39.790
没问题了吧

15:39.790 --> 15:40.790
现在应该没问题了

15:42.790 --> 15:43.790
它还有哪一样

15:43.790 --> 15:44.790
250行

15:45.790 --> 15:46.790
250行

15:47.790 --> 15:48.790
这里是data

15:51.620 --> 15:52.620
那么现在看上去

15:52.620 --> 15:53.620
好像没问题吧

15:53.620 --> 15:54.620
1234排列正确的

15:54.620 --> 15:56.620
那如说是这种情况

15:56.620 --> 15:57.620
比方说pro

15:58.620 --> 15:59.620
pro1

15:59.620 --> 16:00.620
又一个promise

16:02.620 --> 16:03.620
用的是mypromise

16:04.620 --> 16:05.620
我要等待一会

16:05.620 --> 16:06.620
不是马上

16:06.620 --> 16:07.620
我等待

16:07.620 --> 16:08.620
10毫秒吧

16:08.620 --> 16:09.620
然后我再完成1

16:11.620 --> 16:12.620
那么这样子的话

16:12.620 --> 16:13.620
我把pro1传进去的话

16:13.620 --> 16:14.620
那它肯定不是

16:14.620 --> 16:15.620
第一个完成的

16:15.620 --> 16:16.620
肯定不是

16:17.620 --> 16:18.620
第一个完成的

16:18.620 --> 16:19.620
应该是2

16:19.620 --> 16:20.620
然后是3

16:20.620 --> 16:21.620
然后是4

16:21.620 --> 16:22.620
然后是它

16:22.620 --> 16:23.620
那么结果就出现了

16:23.620 --> 16:24.620
这样的一个2 3 4 1

16:24.620 --> 16:25.620
那不是我们想要的

16:25.620 --> 16:26.620
所以说我们

16:26.620 --> 16:27.620
继续

16:27.620 --> 16:28.620
那怎么做呢

16:29.620 --> 16:30.620
就逻辑很简单

16:30.620 --> 16:31.620
怎么逻辑

16:31.620 --> 16:33.620
就看循环到第几次

16:33.620 --> 16:34.620
你第一次循环

16:34.620 --> 16:36.620
那么你这个pro1是完成之后

16:36.620 --> 16:37.620
你就给

16:37.620 --> 16:38.620
应该给数组的

16:38.620 --> 16:39.620
第一项复制

16:39.620 --> 16:40.620
你第二次循环

16:40.620 --> 16:41.620
就应该给数组的

16:41.620 --> 16:42.620
第二项复制

16:42.620 --> 16:43.620
对吧

16:43.620 --> 16:44.620
所以说我这里写个辩量

16:45.620 --> 16:46.620
所以一定要用net

16:46.620 --> 16:47.620
一定要用net

16:47.620 --> 16:48.620
不然用var的话

16:48.620 --> 16:49.620
那么这个辩量

16:49.620 --> 16:50.620
又会提到顶部了

16:50.620 --> 16:51.620
就提到一个函数的顶部

16:51.620 --> 16:52.620
又会变成一个

16:52.620 --> 16:54.620
典型的必包问题

16:54.620 --> 16:55.620
那么这个辩量

16:55.620 --> 16:56.620
会导致每个promise

16:56.620 --> 16:57.620
共用这个辩量

16:58.620 --> 16:59.620
那到时候认的时候

16:59.620 --> 17:00.620
那个辩量都已经是

17:00.620 --> 17:01.620
一个固定的值了

17:01.620 --> 17:02.620
对吧

17:02.620 --> 17:03.620
都一定是一个固定的值了

17:03.620 --> 17:04.620
所以说我们这个辩量

17:04.620 --> 17:05.620
一定要写到个

17:05.620 --> 17:06.620
误寻环里边

17:06.620 --> 17:07.620
保证这个辩量

17:07.620 --> 17:08.620
只在单式

17:08.620 --> 17:09.620
误寻环中生效

17:09.620 --> 17:10.620
我们知道

17:10.620 --> 17:11.620
es6有一个

17:11.620 --> 17:12.620
块儿局作用域

17:12.620 --> 17:13.620
对吧

17:13.620 --> 17:14.620
那么用net之后

17:14.620 --> 17:15.620
这个辩量

17:15.620 --> 17:17.620
是只作用于这个块儿的

17:17.620 --> 17:18.620
每一次循环

17:18.620 --> 17:19.620
这个i都不一样

17:19.620 --> 17:21.620
那么这个i等于什么

17:21.620 --> 17:22.620
等于靠

17:22.620 --> 17:24.620
这句话要提前写

17:26.620 --> 17:27.620
要写到这儿

17:28.620 --> 17:29.620
写到这儿

17:29.620 --> 17:31.620
这样子的每一次

17:31.620 --> 17:32.620
你看第一个promise

17:32.620 --> 17:33.620
完成之后

17:33.620 --> 17:34.620
我们输出一下这个i

17:37.440 --> 17:38.440
对吧 是不是

17:40.440 --> 17:41.440
第一次完成

17:41.440 --> 17:42.440
是不是先完成的是

17:42.440 --> 17:43.440
第二个

17:43.440 --> 17:44.440
第三个 第四个

17:44.440 --> 17:45.440
然后最后完成的是第零个

17:45.440 --> 17:46.440
那么这个i

17:46.440 --> 17:47.440
是不是就记录了

17:47.440 --> 17:48.440
每一个promise

17:48.440 --> 17:49.440
它对应的下标

17:49.440 --> 17:50.440
对不对

17:50.440 --> 17:51.440
你看我们完成的顺序是

17:51.440 --> 17:53.440
二 三 四

17:53.440 --> 17:55.440
下标为一到先完成

17:55.440 --> 17:56.440
下标为二的再完成

17:56.440 --> 17:57.440
下标为三再完成

17:57.440 --> 17:58.440
然后最后完成的是

17:58.440 --> 17:59.440
下标为零

17:59.440 --> 18:00.440
那么这样子

18:00.440 --> 18:01.440
输出一二三零

18:01.440 --> 18:02.440
是没有问题的

18:02.440 --> 18:03.440
是对应好了的

18:04.440 --> 18:05.440
如果说

18:05.440 --> 18:06.440
它不是这样的输出

18:06.440 --> 18:07.440
比方说我真的用了

18:07.440 --> 18:08.440
那里看一下

18:08.440 --> 18:09.440
那管它

18:09.440 --> 18:11.440
它全部都是输出一样的

18:11.440 --> 18:12.440
而且它对应关系就没了

18:12.440 --> 18:13.440
所以我们这里

18:13.440 --> 18:14.440
一定要用net

18:14.440 --> 18:16.440
然后把当前的下标

18:16.440 --> 18:17.440
保存一下

18:17.440 --> 18:18.440
靠什么

18:18.440 --> 18:19.440
就每一次循环

18:19.440 --> 18:20.440
也可以充当一个下标

18:20.440 --> 18:21.440
对吧

18:21.440 --> 18:22.440
把它保存一下

18:22.440 --> 18:23.440
OK

18:23.440 --> 18:24.440
那么这样子一来的话

18:24.440 --> 18:25.440
我这里是不是简单了

18:25.440 --> 18:27.440
就变成了什么results

18:27.440 --> 18:28.440
i等于什么

18:28.440 --> 18:29.440
等于data

18:30.440 --> 18:31.440
那我们现在再看一下

18:31.440 --> 18:32.440
运行

18:33.440 --> 18:34.440
是不是一二三十

18:34.440 --> 18:35.440
排得好了

18:35.440 --> 18:36.440
OK

18:36.440 --> 18:37.440
那么成功的情况

18:37.440 --> 18:38.440
就已经搞定了

18:39.440 --> 18:40.440
就已经搞定了

18:40.440 --> 18:41.440
还有啥呀

18:41.440 --> 18:42.440
你这个每一个promise

18:42.440 --> 18:43.440
完成的时候

18:43.440 --> 18:44.440
我寄个数

18:44.440 --> 18:45.440
如果说数量到达

18:45.440 --> 18:46.440
一定数量之后

18:46.440 --> 18:47.440
那我就认为

18:47.440 --> 18:48.440
所有的都全部完成了

18:48.440 --> 18:49.440
全部完成我就结束了

18:49.440 --> 18:50.440
结束的时候

18:50.440 --> 18:51.440
我把这种数据给你传过来

18:51.440 --> 18:52.440
这个数据

18:52.440 --> 18:53.440
我要保证它的顺序

18:53.440 --> 18:54.440
每个promise

18:54.440 --> 18:56.440
要对应一个i

18:56.440 --> 18:57.440
就是它的下标

18:57.440 --> 18:58.440
每个promise在整个

18:58.440 --> 19:00.440
这个迭代器里面的下标

19:00.440 --> 19:01.440
对应好了之后

19:01.440 --> 19:02.440
我只要你完成

19:02.440 --> 19:03.440
反正个下标

19:03.440 --> 19:04.440
在这个块地中间里面

19:04.440 --> 19:05.440
是不会变的

19:05.440 --> 19:06.440
那么只要你完成

19:06.440 --> 19:07.440
我就用这个下标

19:07.440 --> 19:08.440
给它复制

19:08.440 --> 19:09.440
对吧

19:09.440 --> 19:10.440
我不管你是什么时候完成

19:10.440 --> 19:11.440
反正这个i不会变

19:12.440 --> 19:13.440
OK 那么这个地方

19:13.440 --> 19:14.440
搞定了之后

19:14.440 --> 19:15.440
那拒绝怎么办

19:16.440 --> 19:18.440
拒绝极其简单

19:18.440 --> 19:19.440
因为拒绝的逻辑是什么

19:19.440 --> 19:20.440
只要有任何一个人

19:20.440 --> 19:21.440
你任何一个promise失败

19:21.440 --> 19:22.440
到我就失败了

19:24.440 --> 19:25.440
任何一个

19:25.440 --> 19:26.440
对是不是要对

19:26.440 --> 19:28.440
每一个promise注册拒绝处理

19:28.440 --> 19:29.440
就写一句话

19:30.440 --> 19:31.440
完了

19:32.440 --> 19:33.440
为什么呢

19:33.440 --> 19:34.440
比方说

19:34.440 --> 19:35.440
第二个promise

19:35.440 --> 19:36.440
比方说

19:36.440 --> 19:37.440
第一个promise失败了

19:38.440 --> 19:39.440
第一个promise

19:39.440 --> 19:40.440
前面三个都成功了

19:40.440 --> 19:41.440
比方说

19:41.440 --> 19:42.440
这里这个

19:44.440 --> 19:45.440
那么这个成功了

19:45.440 --> 19:46.440
这个成功了

19:46.440 --> 19:47.440
那么他们都记住了

19:47.440 --> 19:48.440
记得三个了

19:48.440 --> 19:49.440
对吧

19:49.440 --> 19:50.440
还差一个

19:50.440 --> 19:51.440
超秒之后

19:51.440 --> 19:52.440
一失败了

19:52.440 --> 19:53.440
那么一失败是不是要掉用这个

19:53.440 --> 19:54.440
掉用这个是不是

19:54.440 --> 19:55.440
导致这个失败了

19:56.440 --> 19:58.440
那一个同学说那两个失败怎么办

19:58.440 --> 19:59.440
两个失败没事

19:59.440 --> 20:00.440
因为这个锐这个成了

20:00.440 --> 20:01.440
它只会掉用一次

20:02.440 --> 20:03.440
第二次掉用是无效的

20:03.440 --> 20:04.440
所以就保证了

20:04.440 --> 20:06.440
最先掉用的

20:06.440 --> 20:07.440
省效

20:07.440 --> 20:08.440
后续就掉用了就无效了

20:08.440 --> 20:09.440
反正都失败了

20:09.440 --> 20:10.440
对吧 你数据也不能改

20:10.440 --> 20:11.440
那么这样子呢

20:11.440 --> 20:14.200
你看一下

20:14.200 --> 20:16.200
好 我们看一下失败的

20:16.200 --> 20:17.200
输出

20:18.200 --> 20:19.200
失败

20:22.410 --> 20:23.410
失败

20:24.410 --> 20:25.410
看一下 是不是没问题

20:25.410 --> 20:26.410
对吧

20:26.410 --> 20:27.410
那么失败就搞定了

20:27.410 --> 20:28.410
就非常简单

20:29.410 --> 20:31.410
那么这个地方完了之后

20:31.410 --> 20:32.410
其实这里还有一个逻辑

20:32.410 --> 20:33.410
什么逻辑呢

20:33.410 --> 20:36.410
就是如果说你传的是一个空数组

20:37.410 --> 20:38.410
数组是空的

20:39.410 --> 20:40.410
那么什么叫空的

20:40.410 --> 20:41.410
就是它等于零

20:41.410 --> 20:43.410
如果说它等于零

20:43.410 --> 20:45.410
那么这种情况下

20:45.410 --> 20:46.410
你会发现这个评论

20:46.410 --> 20:47.410
就永远完成不了了

20:47.410 --> 20:48.410
因为它进不了循环

20:49.410 --> 20:50.410
懂了意思吧

20:50.410 --> 20:52.410
不要说我这里传了一个空数组

20:54.410 --> 20:55.410
这种情况

20:56.410 --> 20:57.410
发现这个评论

20:57.410 --> 20:58.410
永远都成功不了

20:58.410 --> 20:59.410
永远都失败不了

20:59.410 --> 21:00.410
那么这种情况

21:00.410 --> 21:01.410
官方是怎么处理的呢

21:01.410 --> 21:02.410
你可以查看MDN稳当

21:02.410 --> 21:03.410
它的处理方式呢

21:03.410 --> 21:05.410
如果说你传的那个是零

21:05.410 --> 21:07.410
直接转动

21:07.410 --> 21:08.410
转动什么

21:08.410 --> 21:09.410
一个空数组

21:11.410 --> 21:12.410
直接转动一个空数组

21:12.410 --> 21:14.410
就是它的处理方式

21:15.410 --> 21:16.410
还有一种什么情况呢

21:16.410 --> 21:17.410
还有一种就是在整个执行过程中

21:17.410 --> 21:18.410
爆了错

21:19.410 --> 21:20.410
是爆错

21:20.410 --> 21:22.410
比方说你传了一个什么

21:22.410 --> 21:23.410
传了一个辣物进去

21:23.410 --> 21:25.410
那么这些都会导致爆错的

21:25.410 --> 21:26.410
它都不是一个迭代器

21:27.410 --> 21:28.410
那么像这种情况

21:28.410 --> 21:29.410
爆错的情况

21:29.410 --> 21:30.410
那么直接锐建个车

21:30.410 --> 21:32.410
那就觉得这就是错误的原因

21:32.410 --> 21:34.410
所以我们这里直接把它拆开启一下

21:34.410 --> 21:37.420
好

21:37.420 --> 21:38.420
比如说爆了错

21:38.420 --> 21:39.420
爆了错怎么办呢

21:39.420 --> 21:40.420
就是锐建个车

21:44.380 --> 21:45.380
好

21:45.380 --> 21:46.380
我们来看一下

21:46.380 --> 21:47.380
运行

21:47.380 --> 21:48.380
失败

21:48.380 --> 21:49.380
这是错误的原因

21:51.750 --> 21:52.750
等等

21:52.750 --> 21:53.750
我这里还是要扛兽

21:54.750 --> 21:55.750
误一下

21:55.750 --> 21:59.340
失败

22:01.340 --> 22:02.340
好

22:02.340 --> 22:04.340
那么这就是Promise All的

22:04.340 --> 22:05.340
整个的实现

22:05.340 --> 22:06.340
代码解释不多

22:06.340 --> 22:07.340
你把个逻辑理讯就行了

22:07.340 --> 22:08.340
关键逻辑在哪呢

22:08.340 --> 22:09.340
关键逻辑就是

22:09.340 --> 22:10.340
你一定要有一个技术

22:10.340 --> 22:11.340
总数是多少

22:11.340 --> 22:12.340
以完成有多少

22:12.340 --> 22:13.340
不然的话你就不知道

22:13.340 --> 22:15.340
是不是已经是最后一个完成

22:15.340 --> 22:16.340
只有最后一个完成

22:16.340 --> 22:18.340
我才认为整个Promise完成

22:19.340 --> 22:20.340
还有一个关键点在哪呢

22:20.340 --> 22:22.340
就是它的排列顺序

22:22.340 --> 22:23.340
结果的排列顺序

22:23.340 --> 22:24.340
要跟这个迭代器里面的顺序

22:24.340 --> 22:25.340
要保持一致

22:25.340 --> 22:26.340
所以说我用

22:26.340 --> 22:27.340
在循环的时候用一个

22:27.340 --> 22:29.340
在循环体里边的

22:29.340 --> 22:30.340
变两i

22:30.340 --> 22:31.340
保证它的作用语

22:31.340 --> 22:32.340
只作用于这个循环体

22:32.340 --> 22:34.340
每一次循环都是一个新的i

22:34.340 --> 22:35.340
让每一个Promise

22:35.340 --> 22:38.340
每一个Promise去对应到这个i

22:38.340 --> 22:40.340
这样子不管它什么时候完成

22:40.340 --> 22:41.340
那么它的i指

22:41.340 --> 22:43.340
它都是对应到下标的指

22:43.340 --> 22:44.340
它不会变化

22:44.340 --> 22:46.340
把这两个关键点抓住

22:46.340 --> 22:48.340
代码就比较容易写出来了

22:48.340 --> 22:50.340
这是关于All的写法

