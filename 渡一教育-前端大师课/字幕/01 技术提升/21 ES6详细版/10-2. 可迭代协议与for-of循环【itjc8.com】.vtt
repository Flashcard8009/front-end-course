WEBVTT

00:00.750 --> 00:03.750
好了 上一课我们了解了什么叫迭代器

00:03.750 --> 00:05.750
我们做一下回顾吧

00:05.750 --> 00:08.750
什么叫迭代器 attractor

00:08.750 --> 00:11.750
它是一个具有next方法的对象

00:11.750 --> 00:13.750
这个对象的next方法一调用过后

00:13.750 --> 00:15.750
它就会得到一个下一个数据

00:15.750 --> 00:17.750
并且有一个属性 对吧

00:17.750 --> 00:20.750
可以表示是不是已经迭代完成了

00:20.750 --> 00:22.750
然后 什么叫做迭代器创建函数

00:22.750 --> 00:24.750
叫attractor

00:24.750 --> 00:27.750
就是来返回一个迭代器的函数

00:27.750 --> 00:29.750
这是咱们上一课的知识

00:29.750 --> 00:31.750
我们来学习迭代器协议

00:31.750 --> 00:33.750
实际上我们学习迭代器

00:33.750 --> 00:35.750
很重要的一个目的

00:35.750 --> 00:37.750
就是为了学习迭代器协议

00:37.750 --> 00:39.750
因为你没有学习迭代器的话

00:39.750 --> 00:41.750
你不知道迭代器协议到底我在说啥

00:41.750 --> 00:44.750
所以说有这么一个商业节课作为铺垫

00:44.750 --> 00:47.750
迭代器协议这一块是非常重要的那种

00:47.750 --> 00:49.750
什么叫迭代器协议呢

00:49.750 --> 00:50.750
我们上一课的东西

00:50.750 --> 00:52.750
当你看我们跟s6有关系吗

00:52.750 --> 00:54.750
没有任何关系 对吧

00:54.750 --> 00:57.750
跟s6有啥关系 全都是自己写的代码

00:57.750 --> 00:59.750
那么这节课呢

00:59.750 --> 01:01.750
就跟es6来关联起来了

01:01.750 --> 01:03.750
看什么叫可迭代协议

01:03.750 --> 01:05.750
es6规定

01:05.750 --> 01:08.750
如果说有一个对象

01:08.750 --> 01:10.750
它具有一个属性

01:10.750 --> 01:12.750
这个属性的是一个符号属性

01:12.750 --> 01:13.750
我们之前学过了 对吧

01:13.750 --> 01:14.750
学过了一个符号属性

01:14.750 --> 01:15.750
当时我还说了一个符号

01:15.750 --> 01:16.750
我们后边会讲

01:16.750 --> 01:18.750
是一个知名符号

01:18.750 --> 01:20.750
叫做symbolattractor

01:20.750 --> 01:22.750
attractor是不是迭代器

01:22.750 --> 01:25.750
有这么一个知名符号属性

01:25.750 --> 01:27.750
并且呢 这个属性的值

01:27.750 --> 01:28.750
是一个啥呢

01:28.750 --> 01:31.750
是一个迭代器创建函数

01:31.750 --> 01:33.750
你如果说满足这两个条件

01:33.750 --> 01:34.750
ok 你这个对象

01:34.750 --> 01:36.750
我就认为是可迭代的

01:36.750 --> 01:38.750
那么至于它可迭代有什么意义

01:38.750 --> 01:39.750
我们先别管

01:39.750 --> 01:41.750
我们先看它的定义

01:41.750 --> 01:42.750
什么样的对象

01:42.750 --> 01:44.750
它表示可迭代对象

01:44.750 --> 01:46.750
是可迭代的 叫做attorable

01:46.750 --> 01:47.750
attorable 后面加个able

01:47.750 --> 01:48.750
什么意思

01:48.750 --> 01:50.750
就表示有什么样的能力 对吧

01:50.750 --> 01:52.750
它是可以被迭代的能力的

01:52.750 --> 01:54.750
有这么样的能力

01:54.750 --> 01:55.750
所以是一个对象

01:55.750 --> 01:57.750
如果说它具有这么一个属性

01:57.750 --> 01:59.750
并且呢 这个属性值

01:59.750 --> 02:01.750
是一个迭代器创建函数

02:01.750 --> 02:03.750
那么这个对象就是可以迭代的

02:03.750 --> 02:07.640
举个例子 比方说

02:10.640 --> 02:11.640
你先别管

02:11.640 --> 02:13.640
可迭代对象有什么意义

02:13.640 --> 02:14.640
先别管

02:14.640 --> 02:15.640
我们先认识一下

02:15.640 --> 02:17.640
什么叫做可迭代对象

02:17.640 --> 02:20.640
比方说我们这里有个ob界对象

02:20.640 --> 02:21.640
这个对象里边

02:21.640 --> 02:22.640
有一个属性

02:22.640 --> 02:25.640
它是symbolattractor

02:26.640 --> 02:27.640
有这么一个属性

02:27.640 --> 02:30.640
这个属性是一个迭代器创建函数

02:30.640 --> 02:32.640
也就是说我这里返回的是一个

02:32.640 --> 02:34.640
返回的是一个迭代器

02:34.640 --> 02:36.640
返回的是一个迭代器

02:36.640 --> 02:38.640
那么这样的一个对象

02:38.640 --> 02:40.640
它就是一个可迭代对象

02:40.640 --> 02:41.640
就这么简单

02:41.640 --> 02:42.640
没别的了

02:45.640 --> 02:48.640
比方说随便下写一个对象

02:48.640 --> 02:49.640
那么这个对象

02:49.640 --> 02:51.640
它就是一个可迭代对象

02:51.640 --> 02:53.640
就是可迭代对象

02:53.640 --> 02:54.640
为什么呢

02:54.640 --> 02:55.640
因为这个对象里边

02:55.640 --> 02:56.640
它有一个属性

02:56.640 --> 02:58.640
是知名符号symbolattractor

02:58.640 --> 03:00.640
一定要是这个属性名

03:00.640 --> 03:02.640
它的是一个符号属性

03:02.640 --> 03:04.640
并且它必须是一个

03:04.640 --> 03:06.640
迭代器创建函数

03:06.640 --> 03:08.640
必须是一个迭代器创建函数

03:08.640 --> 03:10.640
你看是不是一个创建函数

03:10.640 --> 03:12.640
这个函数它返回了一个迭代器

03:12.640 --> 03:13.640
你看是不是迭代器

03:13.640 --> 03:15.640
它有一个那个设方法

03:15.640 --> 03:18.640
那么这个对象叫做可迭代对象

03:18.640 --> 03:20.640
你首先搞清楚

03:20.640 --> 03:22.640
什么叫做可迭代对象

03:22.640 --> 03:23.640
那么接着我们来思考一个问题

03:24.640 --> 03:25.640
如何来直小一个对象

03:25.640 --> 03:27.640
是不是可迭代的

03:27.640 --> 03:28.640
就是说这个对象

03:28.640 --> 03:29.640
它是不是可迭代对象

03:29.640 --> 03:30.640
又看啥

03:30.640 --> 03:32.640
看一下它有没有这个符号属性

03:32.640 --> 03:33.640
对吧

03:33.640 --> 03:34.640
然后看一下这个符号属性

03:34.640 --> 03:35.640
是不是一个函数

03:35.640 --> 03:37.640
不就完了吗

03:37.640 --> 03:38.640
如果是满足这个条件的话

03:38.640 --> 03:40.640
它就是一个可迭代对象

03:40.640 --> 03:41.640
那么我们来看一下

03:41.640 --> 03:42.640
我们其实呢

03:42.640 --> 03:43.640
数组呢

03:43.640 --> 03:45.640
就是一个可迭代对象

03:45.640 --> 03:47.640
咱们在这里

03:47.640 --> 03:48.640
看一下吧

03:48.640 --> 03:49.640
test2

03:51.640 --> 03:52.640
我们这里写个数组

03:53.640 --> 03:54.640
在es6里边

03:54.640 --> 03:56.640
它把数组就把它做成一个可迭代对象了

03:57.640 --> 03:58.640
以前还没有这个概念

03:58.640 --> 04:00.640
不要我们随便下写个数组

04:00.640 --> 04:01.640
我们来看一下

04:01.640 --> 04:03.640
这个数组里边有啥东西

04:03.640 --> 04:04.640
把数组说出来

04:05.640 --> 04:06.640
运行

04:06.640 --> 04:09.950
右键 检查

04:09.950 --> 04:10.950
控制台

04:10.950 --> 04:12.950
咱们来看一下这个数组

04:12.950 --> 04:13.950
展开

04:13.950 --> 04:14.950
数组里面的这些属性

04:14.950 --> 04:15.950
对吧

04:15.950 --> 04:16.950
没有这个符号属性

04:16.950 --> 04:18.950
咱们往后边找

04:18.950 --> 04:19.950
影视圆形

04:19.950 --> 04:20.950
找圆形上边

04:20.950 --> 04:21.950
往下

04:21.950 --> 04:22.950
有很多方法

04:23.950 --> 04:24.950
看这

04:24.950 --> 04:25.950
这是啥

04:25.950 --> 04:26.950
这是啥

04:26.950 --> 04:27.950
是不是一个

04:27.950 --> 04:28.950
symbol符号属性

04:28.950 --> 04:29.950
atorator

04:29.950 --> 04:30.950
对吧

04:30.950 --> 04:31.950
而且它是一个函数

04:31.950 --> 04:32.950
说明啥

04:32.950 --> 04:33.950
说明这个数组

04:33.950 --> 04:36.950
本身就是一个可迭代对象

04:36.950 --> 04:38.950
数组就是个可迭代对象

04:38.950 --> 04:40.950
那么我们来验证一下吧

04:40.950 --> 04:42.950
既然是一个可迭代对象的话

04:42.950 --> 04:45.950
那么你一定有一个符号属性

04:45.950 --> 04:46.950
symbol

04:46.950 --> 04:47.950
atorator

04:47.950 --> 04:48.950
知名符号属性

04:48.950 --> 04:49.950
那么这个属性

04:49.950 --> 04:51.950
它一定是一个函数

04:51.950 --> 04:52.950
那是不是可以调用这个函数

04:52.950 --> 04:53.950
调用这个函数

04:53.950 --> 04:55.950
它是不是一定返回一个迭代器

04:55.950 --> 04:56.950
对吧

04:56.950 --> 04:57.950
一定返回一个迭代器

04:57.950 --> 04:58.950
atorator

04:58.950 --> 04:59.950
是不是一定

04:59.950 --> 05:01.950
这个代码是不是一定得运行成功

05:01.950 --> 05:03.950
是不是得一定得运行成功

05:03.950 --> 05:04.950
好

05:04.950 --> 05:05.950
是不是没问题吧

05:05.950 --> 05:06.950
那看一下有没有报错吗

05:06.950 --> 05:07.950
是不是没报错

05:07.950 --> 05:08.950
好没报错

05:08.950 --> 05:10.950
那么这个东西得到的是啥

05:10.950 --> 05:11.950
因为这个玩意

05:11.950 --> 05:12.950
是一个迭代器

05:12.950 --> 05:13.950
创建函数

05:13.950 --> 05:14.950
那么一调用它

05:14.950 --> 05:15.950
是不是得到一个迭代器

05:15.950 --> 05:16.950
那么迭代谁的

05:16.950 --> 05:17.950
是不是迭代数组的

05:17.950 --> 05:18.950
来吧

05:18.950 --> 05:19.950
atorator

05:19.950 --> 05:20.950
这个变量

05:20.950 --> 05:21.950
atorator

05:21.950 --> 05:22.950
然后next

05:22.950 --> 05:23.950
你看

05:24.950 --> 05:25.950
你看

05:25.950 --> 05:26.950
是不是在迭代

05:26.950 --> 05:27.950
对吧

05:27.950 --> 05:28.950
是不是在迭代

05:28.950 --> 05:29.950
跟我们之前

05:29.950 --> 05:30.950
上杰克自己写的迭代数组

05:30.950 --> 05:32.950
迭代器是一样的

05:32.950 --> 05:33.950
所以你不用自己写了

05:33.950 --> 05:35.950
为什么我们

05:35.950 --> 05:36.950
上杰克的东西

05:36.950 --> 05:37.950
平时开发用不到了

05:37.950 --> 05:38.950
因为他给你写好了

05:38.950 --> 05:39.950
已经给你写好了

05:39.950 --> 05:41.950
数组它本身是一个

05:41.950 --> 05:42.950
可迭代对象

05:42.950 --> 05:43.950
因此

05:43.950 --> 05:44.950
它给你提供了迭代器

05:44.950 --> 05:45.950
一定要用它

05:45.950 --> 05:46.950
就得到迭代器

05:46.950 --> 05:48.950
你不用自己重新去写了

05:48.950 --> 05:49.950
原来的意思

05:49.950 --> 05:50.950
你看

05:50.950 --> 05:51.950
我们这里可以通过

05:51.950 --> 05:52.950
它来进行迭代

05:52.950 --> 05:54.950
就这么个意思

05:54.950 --> 05:56.950
那么不仅仅是数组

05:56.950 --> 05:58.950
还有很多那一数组

05:58.950 --> 05:59.950
伪数组

05:59.950 --> 06:00.950
它也给你做成了

06:00.950 --> 06:01.950
就是

06:01.950 --> 06:02.950
可迭代对象

06:02.950 --> 06:03.950
比方说在

06:03.950 --> 06:04.950
现在下面说的

06:04.950 --> 06:06.950
就不是ES6的内容了

06:06.950 --> 06:07.950
就是那个Web IPI了

06:07.950 --> 06:09.950
比方说动物对象

06:09.950 --> 06:10.950
我们要得到很多

06:10.950 --> 06:11.950
动物对象的一些集合

06:11.950 --> 06:12.950
对不对

06:12.950 --> 06:14.950
咱们比方说有10个DIV

06:14.950 --> 06:15.950
那么这里

06:15.950 --> 06:17.950
我们换个页面吧

06:18.950 --> 06:19.950
换个页面

06:20.950 --> 06:21.950
Type 3

06:22.950 --> 06:23.950
咱们来看一下

06:24.950 --> 06:26.950
我们在这里有10个DIV

06:28.950 --> 06:29.950
10个

06:29.950 --> 06:30.950
这里我们通过

06:30.950 --> 06:31.950
query is negative

06:31.950 --> 06:32.950
得到所有的DIV

06:34.950 --> 06:35.950
Document is

06:35.950 --> 06:36.950
query is negative

06:38.950 --> 06:39.950
得到所有的DIV

06:39.950 --> 06:40.950
那么这个东西得到的

06:40.950 --> 06:41.950
是不是一个内数组

06:41.950 --> 06:42.950
这个DIV

06:42.950 --> 06:43.950
这个变量得

06:43.950 --> 06:44.950
是不是一个真正的数组

06:44.950 --> 06:45.950
对吧

06:45.950 --> 06:46.950
那么我们

06:46.950 --> 06:47.950
它是不是数组呢

06:47.950 --> 06:48.950
我们到时

06:48.950 --> 06:49.950
现在到时不是很care

06:49.950 --> 06:50.950
我们关键care的是什么呢

06:50.950 --> 06:51.950
我们关心的是

06:51.950 --> 06:53.950
它是不是一个可迭代对象

06:53.950 --> 06:55.950
它满不满足可迭代的协议

06:55.950 --> 06:56.950
什么叫协议呢

06:56.950 --> 06:57.950
其实就是规定

06:57.950 --> 06:59.950
你满不满足这个规定

06:59.950 --> 07:00.950
你满足这个规定

07:00.950 --> 07:01.950
OK 那就是可迭代对象

07:01.950 --> 07:03.950
好 咱们往原型上面找

07:03.950 --> 07:04.950
看一下

07:04.950 --> 07:05.950
看一下有没有这个symbol

07:05.950 --> 07:06.950
actrator呢

07:06.950 --> 07:07.950
有没有 是不是有

07:07.950 --> 07:08.950
说明啥

07:08.950 --> 07:10.950
说明这个动物对象的集合

07:10.950 --> 07:11.950
这个伪数组

07:11.950 --> 07:13.950
是不是也是一个可迭代对象

07:13.950 --> 07:14.950
对吧

07:14.950 --> 07:15.950
既然它是个可迭代对象

07:15.950 --> 07:16.950
是不是我们又可以这样玩了

07:16.950 --> 07:18.950
什么actrator

07:18.950 --> 07:20.950
symbol

07:20.950 --> 07:21.950
actrator

07:21.950 --> 07:22.950
是不是一调用它

07:22.950 --> 07:24.950
就可以得到一个什么

07:24.950 --> 07:25.950
是不是可以得到一个

07:25.950 --> 07:27.950
我们把个div这样写吧

07:27.950 --> 07:28.950
这样写div

07:28.950 --> 07:29.950
乘以10

07:29.950 --> 07:31.950
里边内容的是个多了

07:31.950 --> 07:32.950
咱们呢

07:32.950 --> 07:33.950
是不是可以调用它

07:33.950 --> 07:34.950
是不是可以得到一个迭代器

07:34.950 --> 07:35.950
actrator

07:35.950 --> 07:36.950
对吧

07:36.950 --> 07:37.950
好 来吧

07:37.950 --> 07:38.950
来玩一玩

07:38.950 --> 07:39.950
接下来看一下

07:40.950 --> 07:41.950
那么actrator

07:41.950 --> 07:42.950
next

07:42.950 --> 07:43.950
调用

07:43.950 --> 07:44.950
拿到下一个

07:44.950 --> 07:46.950
是不是Value值是一个什么

07:46.950 --> 07:47.950
Value值是不是一个div

07:47.950 --> 07:48.950
对吧

07:48.950 --> 07:49.950
Value值就是第一个div

07:49.950 --> 07:50.950
看没

07:50.950 --> 07:51.950
forced

07:51.950 --> 07:52.950
当为forced

07:52.950 --> 07:53.950
看没

07:53.950 --> 07:54.950
那个是Value值

07:54.950 --> 07:55.950
下个div

07:55.950 --> 07:56.950
下个div

07:56.950 --> 07:57.950
下个div

07:57.950 --> 07:58.950
是不是仍然可以迭代

07:58.950 --> 07:59.950
对吧

07:59.950 --> 08:01.950
总之只要有一个对象

08:01.950 --> 08:03.950
它具有这样的一个属性

08:03.950 --> 08:05.950
而且它是个迭代器

08:05.950 --> 08:06.950
创建函数

08:06.950 --> 08:07.950
返回了一个迭代器

08:07.950 --> 08:08.950
那么这个对象

08:08.950 --> 08:09.950
就是一个可迭代对象

08:09.950 --> 08:10.950
那么

08:10.950 --> 08:11.950
我们发现的数组

08:11.950 --> 08:12.950
它是个可迭代对象

08:12.950 --> 08:13.950
而且这些伪术组

08:13.950 --> 08:14.950
很多都是可迭代对象

08:14.950 --> 08:16.950
甚至我们自己写的一个对象

08:16.950 --> 08:18.950
都可以把它做成一个可迭代对象

08:18.950 --> 08:19.950
对吧

08:19.950 --> 08:20.950
我们现在认识清楚

08:20.950 --> 08:21.950
什么叫做可迭代对象

08:21.950 --> 08:23.950
那么接下来下一个问题

08:23.950 --> 08:24.950
思考

08:24.950 --> 08:27.950
如何辨历一个可迭代对象呢

08:27.950 --> 08:28.950
你这个可迭代对象

08:28.950 --> 08:30.950
不是会给我一个迭代器吗

08:30.950 --> 08:31.950
我要把这个迭代器

08:31.950 --> 08:33.950
拿全部迭代出来

08:33.950 --> 08:35.950
辨历就是全部拿到

08:35.950 --> 08:36.950
对吧

08:36.950 --> 08:37.950
全部迭代出来

08:37.950 --> 08:38.950
那么该怎么来辨历呢

08:38.950 --> 08:40.950
就是上节考咱们学过了

08:40.950 --> 08:41.950
我给大家写过了

08:41.950 --> 08:42.950
如何去辨历

08:42.950 --> 08:44.950
用迭代器来进行辨历

08:44.950 --> 08:46.950
那么这就后面再来一次吧

08:46.950 --> 08:47.950
那我们来写一个

08:47.950 --> 08:48.950
比方数组里边

08:48.950 --> 08:49.950
你不是给了我一个迭代器吗

08:49.950 --> 08:51.950
我就不用自己去写什么

08:51.950 --> 08:52.950
函数来创建迭代器了

08:52.950 --> 08:53.950
你给都给了我了

08:53.950 --> 08:54.950
我就用这个迭代器

08:54.950 --> 08:55.950
来迭代数组

08:55.950 --> 08:56.950
怎么迭代呢

08:56.950 --> 08:57.950
来吧

08:57.950 --> 08:58.950
atorator

08:58.950 --> 09:01.950
是不是先要调用这个next

09:01.950 --> 09:02.950
对吧

09:02.950 --> 09:03.950
所以拿到一个数据

09:03.950 --> 09:04.950
哎

09:04.950 --> 09:05.950
拿到

09:05.950 --> 09:06.950
不能用抗尸

09:06.950 --> 09:07.950
要改的

09:07.950 --> 09:08.950
所以拿到这个数据

09:08.950 --> 09:09.950
用item

09:09.950 --> 09:10.950
拿这个数据

09:11.950 --> 09:12.950
先下来啊

09:12.950 --> 09:14.950
调用这个迭代器

09:14.950 --> 09:15.950
创建函数

09:15.950 --> 09:17.950
那么是不是拿到一个迭代器

09:17.950 --> 09:18.950
拿到迭代器过后呢

09:18.950 --> 09:19.950
调用next

09:19.950 --> 09:21.950
是不是拿到一个结果

09:21.950 --> 09:22.950
拿到一个结果

09:22.950 --> 09:23.950
我们用reald

09:23.950 --> 09:25.950
拿到一个结果

09:25.950 --> 09:26.950
拿到结果之后呢

09:26.950 --> 09:28.950
是不是可以进行外国循环

09:28.950 --> 09:30.950
如果说你这个结果里边

09:30.950 --> 09:31.950
没有结束

09:31.950 --> 09:32.950
没有结束的话

09:32.950 --> 09:34.950
我是不是就可以把数据拿出来了

09:34.950 --> 09:35.950
从这个结果里边

09:35.950 --> 09:36.950
把数据拿出来

09:36.950 --> 09:37.950
item

09:37.950 --> 09:38.950
对吧

09:38.950 --> 09:39.950
输出这个数据

09:39.950 --> 09:40.950
没问题吧

09:41.950 --> 09:42.950
把数据拿出来

09:42.950 --> 09:43.950
取出数据

09:44.950 --> 09:45.950
取出数据

09:45.950 --> 09:47.950
因为你没有迭代结束

09:47.950 --> 09:48.950
所以说我可以把数据取出来

09:48.950 --> 09:49.950
好

09:49.950 --> 09:50.950
那么进行下一次迭代

09:50.950 --> 09:51.950
对吧

09:51.950 --> 09:52.950
下一次迭代

09:52.950 --> 09:53.950
好

09:53.950 --> 09:54.950
再来写

09:54.950 --> 09:55.950
我们是不是下一次迭代

09:55.950 --> 09:57.950
就是reald重新复制

09:57.950 --> 09:58.950
复制为什么呢

09:58.950 --> 10:00.950
又复制为item

10:00.950 --> 10:01.950
next

10:01.950 --> 10:02.950
对吧

10:02.950 --> 10:03.950
就这样写

10:03.950 --> 10:04.950
就这样写

10:04.950 --> 10:05.950
没问题吧

10:05.950 --> 10:06.950
就下一次迭代

10:06.950 --> 10:07.950
好

10:07.950 --> 10:08.950
咱们来看一下吧

10:08.950 --> 10:09.950
拿出来了

10:09.950 --> 10:10.950
这边

10:11.950 --> 10:12.950
test2

10:14.950 --> 10:15.950
这个地方

10:15.950 --> 10:16.950
这个地方写的是y6

10:16.950 --> 10:18.950
取出数据是y6属性

10:18.950 --> 10:19.950
是不是可以拿出来了

10:19.950 --> 10:21.950
57236

10:21.950 --> 10:22.950
全部拿出来了

10:23.950 --> 10:24.950
好好看一下

10:24.950 --> 10:26.950
我建议大家现在可以暂停视频了

10:26.950 --> 10:27.950
你自己去写一遍

10:27.950 --> 10:28.950
自己去写一遍

10:28.950 --> 10:29.950
写了一遍之后

10:29.950 --> 10:30.950
你会发现

10:30.950 --> 10:32.950
这是一种通用的模式

10:33.950 --> 10:34.950
在这里

10:34.950 --> 10:35.950
我要把它便利

10:35.950 --> 10:36.950
所谓的div

10:36.950 --> 10:37.950
一样的

10:37.950 --> 10:38.950
对吧

10:38.950 --> 10:39.950
是不是拿到

10:39.950 --> 10:40.950
首先拿到这个item

10:40.950 --> 10:41.950
对不对

10:41.950 --> 10:42.950
是不是拿到这个item

10:42.950 --> 10:43.950
拿到item过后

10:43.950 --> 10:44.950
是不是掉到next

10:44.950 --> 10:46.950
拿到它的下一个

10:46.950 --> 10:47.950
下一个有没有结束呢

10:47.950 --> 10:49.950
如果说没有结束

10:49.950 --> 10:50.950
没有结束的话

10:50.950 --> 10:51.950
把数据取出来

10:51.950 --> 10:53.950
我当然取出来过后要干嘛

10:53.950 --> 10:54.950
你随便做

10:54.950 --> 10:55.950
随便做

10:55.950 --> 10:56.950
然后下一次迭代

10:56.950 --> 10:58.950
它的模式是完全统一的

10:58.950 --> 10:59.950
你看一下

10:59.950 --> 11:01.950
是不是拿到便利的所谓的div了

11:01.950 --> 11:03.950
便利的所谓的div

11:03.950 --> 11:05.950
没问题吧

11:05.950 --> 11:07.950
那么它既然它的模式

11:07.950 --> 11:09.950
是完全统一的话

11:09.950 --> 11:10.950
于是es6里面

11:10.950 --> 11:12.950
给我们出来了一个循环

11:12.950 --> 11:13.950
一个新的循环

11:13.950 --> 11:15.950
叫做for2u循环

11:15.950 --> 11:17.950
这个循环就专门用来干这个事的

11:17.950 --> 11:19.950
它让我们写的代码

11:19.950 --> 11:20.950
更加简洁了

11:20.950 --> 11:21.950
它做什么事呢

11:21.950 --> 11:23.950
for2u循环专门用于

11:23.950 --> 11:25.950
便利可谍在对象

11:25.950 --> 11:26.950
它的格式如下

11:26.950 --> 11:27.950
下面这个格式

11:27.950 --> 11:28.950
来吧看一下吧

11:28.950 --> 11:29.950
这个格式

11:30.950 --> 11:31.950
你只要把你

11:31.950 --> 11:32.950
可谍在对象

11:32.950 --> 11:33.950
放到这

11:33.950 --> 11:34.950
就完事了

11:34.950 --> 11:35.950
生产的事情它做什么呢

11:35.950 --> 11:36.950
它就是

11:36.950 --> 11:38.950
调用这个可谍在对象的

11:38.950 --> 11:39.950
什么Nex

11:39.950 --> 11:41.950
就调用了可谍在对象的

11:41.950 --> 11:42.950
就是

11:42.950 --> 11:44.950
叠带器创建函数

11:44.950 --> 11:45.950
然后拿到叠带器

11:45.950 --> 11:47.950
然后调用叠带器的Nex

11:47.950 --> 11:48.950
只要没有叠带结束

11:48.950 --> 11:49.950
它就继续循环

11:49.950 --> 11:50.950
每一次循环了

11:50.950 --> 11:51.950
把叠带器里面的数据取出来

11:51.950 --> 11:53.950
放到这个item里面

11:53.950 --> 11:56.950
如果说我们来对比一下的话

11:56.950 --> 11:57.950
看一下上面那个代码

11:57.950 --> 11:58.950
所以说为什么要让你们

11:58.950 --> 12:00.950
把上面代码写一遍呢

12:00.950 --> 12:02.950
来对比一下for2u循环

12:02.950 --> 12:03.950
for2u

12:04.950 --> 12:05.950
for循环

12:05.950 --> 12:07.950
那么这里的item

12:07.950 --> 12:09.950
for2u 这里写个关键字for2u

12:09.950 --> 12:10.950
后面是叠带对象

12:10.950 --> 12:11.950
叠带对象是ar

12:11.950 --> 12:13.950
我们这里输出item

12:13.950 --> 12:15.950
下不要这个代码

12:15.950 --> 12:17.950
就相当于是

12:17.950 --> 12:19.950
这一坨代码

12:19.950 --> 12:21.950
效果是完全一样的

12:21.950 --> 12:23.950
就是说你可以自己手动写

12:23.950 --> 12:24.950
没问题

12:24.950 --> 12:26.950
也可以使用for2u

12:26.950 --> 12:27.950
余法堂

12:27.950 --> 12:29.950
来快速的实现一个

12:29.950 --> 12:31.950
叠带器的便利

12:31.950 --> 12:32.950
那你看一下现在是

12:32.950 --> 12:34.950
就对比上面一个代码

12:34.950 --> 12:35.950
你看变量名字

12:35.950 --> 12:36.950
我都是非常有讲究的

12:36.950 --> 12:37.950
这里的item

12:37.950 --> 12:39.950
就对应到这里的item

12:39.950 --> 12:40.950
你把上面一个代码

12:40.950 --> 12:41.950
谁要看懂

12:41.950 --> 12:42.950
看懂过对比下面一个代码

12:42.950 --> 12:44.950
完全一样

12:44.950 --> 12:46.950
它就是在做这件事情

12:46.950 --> 12:48.950
你只要你给我的是

12:48.950 --> 12:49.950
一个可叠带对象

12:49.950 --> 12:51.950
ok 我就可以循环

12:51.950 --> 12:52.950
我就可以循环

12:52.950 --> 12:54.950
可以进行循环

12:54.950 --> 12:55.950
所以说你不要认为

12:55.950 --> 12:57.950
for2u一定是循环数组

12:57.950 --> 12:59.950
只要你是可叠带对象

12:59.950 --> 13:00.950
那么你就可以循环

13:00.950 --> 13:02.950
那么这里的变量名随便写

13:02.950 --> 13:03.950
这比前面的关键字

13:03.950 --> 13:04.950
你可以用Const

13:04.950 --> 13:05.950
一般都是用Const

13:05.950 --> 13:06.950
你可以用内字

13:06.950 --> 13:07.950
无所谓

13:07.950 --> 13:09.950
对比上面

13:09.950 --> 13:10.950
对比上面

13:10.950 --> 13:11.950
一样的

13:12.950 --> 13:13.950
没问题吧

13:13.950 --> 13:14.950
那么现在我们再看一下

13:14.950 --> 13:15.950
这里输出

13:15.950 --> 13:17.950
是一样的

13:17.950 --> 13:18.950
一样的效果

13:18.950 --> 13:19.950
那么这边

13:19.950 --> 13:22.390
来

13:22.390 --> 13:24.390
for2u循环

13:24.390 --> 13:25.390
那么这里item

13:25.390 --> 13:27.390
这里是divis

13:27.390 --> 13:30.390
这里输出item

13:30.390 --> 13:32.390
这就是for2u循环

13:32.390 --> 13:34.390
来看一下吧

13:34.390 --> 13:35.390
是不是一样的

13:35.390 --> 13:36.390
完全一样的

13:36.390 --> 13:37.390
跟上面的代码

13:37.390 --> 13:38.390
没有任何区别

13:38.390 --> 13:39.390
下面只是一个愚法堂而已

13:39.390 --> 13:42.390
只是一个愚法堂而已

13:42.390 --> 13:44.390
这就是可叠带

13:44.390 --> 13:46.390
叠带系列和for2u循环

13:46.390 --> 13:48.390
那么我们既然说

13:48.390 --> 13:49.390
for2u循环

13:49.390 --> 13:50.390
它循环的是

13:50.390 --> 13:51.390
只要是可叠带对象就行

13:51.390 --> 13:53.390
那么我们自己写的对象行不行

13:53.390 --> 13:54.390
没问题

13:54.390 --> 13:55.390
一定要问题都没有

13:55.390 --> 13:56.390
比方说

13:56.390 --> 13:58.390
咱们写这么一个

13:58.390 --> 13:59.390
有意思的东西

13:59.390 --> 14:00.390
我这个对象里面

14:00.390 --> 14:02.390
提供了这么两个

14:02.390 --> 14:03.390
数项

14:03.390 --> 14:05.390
a等于1

14:05.390 --> 14:07.390
b等于2

14:07.390 --> 14:09.390
提供一些数项

14:10.390 --> 14:12.390
然后我这个

14:12.390 --> 14:14.390
我这里写了这么一个东西

14:14.390 --> 14:15.390
写了这么一个东西

14:15.390 --> 14:16.390
说明啥说明这个对象

14:16.390 --> 14:17.390
是不是可叠的对象

14:17.390 --> 14:19.390
它返回了一个叠带器

14:19.390 --> 14:20.390
返回了叠带器的时候

14:20.390 --> 14:21.390
每次掉入next

14:21.390 --> 14:22.390
只要你掉入next

14:22.390 --> 14:24.390
我就会给你一个下一个数据

14:24.390 --> 14:26.390
给你下一个数据

14:26.390 --> 14:27.390
那么现在如果说

14:27.390 --> 14:28.390
我啥都没变

14:28.390 --> 14:29.390
要不要用follow循环

14:29.390 --> 14:30.390
会怎么样呢

14:30.390 --> 14:31.390
能不能循环

14:31.390 --> 14:32.390
首先能不能循环它

14:32.390 --> 14:35.390
能不能去循环对象

14:35.390 --> 14:37.390
能不能循环

14:37.390 --> 14:39.390
如果说你没有写这个的话

14:39.390 --> 14:40.390
肯定是不能循环的

14:40.390 --> 14:41.390
这个是毫无疑问的

14:41.390 --> 14:42.390
看吧

14:43.390 --> 14:44.390
你看

14:44.390 --> 14:45.390
他可以给你报一个错

14:45.390 --> 14:46.390
他说

14:46.390 --> 14:49.390
obj is not atrobal

14:49.390 --> 14:50.390
什么意思

14:50.390 --> 14:51.390
atrobal什么意思

14:51.390 --> 14:52.390
可叠带的

14:52.390 --> 14:54.390
它不是一个可叠带对象

14:54.390 --> 14:55.390
因为什么呢

14:55.390 --> 14:56.390
因为这个obj里面

14:56.390 --> 14:57.390
它没有满足可叠带协议

14:57.390 --> 14:59.390
那如果说你干满足了

14:59.390 --> 15:00.390
ok 那就它就没问题了

15:00.390 --> 15:01.390
它就没问题了

15:01.390 --> 15:03.390
那它怎么循环

15:03.390 --> 15:05.390
它就去得到这个叠带期

15:05.390 --> 15:06.390
每一次循环

15:06.390 --> 15:07.390
调用一下next

15:07.390 --> 15:09.390
把数据扔进去

15:09.390 --> 15:10.390
然后输出

15:10.390 --> 15:12.390
直到这个叠带结束

15:12.390 --> 15:13.390
保存

15:13.390 --> 15:15.390
但是呢我们现在出一个问题就是

15:15.390 --> 15:17.390
这个叠带你看卡死了

15:17.390 --> 15:18.390
这个叠带是不是永远不会结束

15:18.390 --> 15:19.390
因为我们当时

15:19.390 --> 15:20.390
涉及的是force

15:20.390 --> 15:21.390
但是你可以看到

15:21.390 --> 15:22.390
它输出的是不是1

15:22.390 --> 15:23.390
不断的输出1

15:23.390 --> 15:24.390
输出了3000多次的

15:24.390 --> 15:25.390
还是卡着

15:25.390 --> 15:26.390
它输出1

15:26.390 --> 15:27.390
对吧

15:27.390 --> 15:28.390
这个没问题吧

15:28.390 --> 15:29.390
关了

15:29.390 --> 15:30.390
卡死了

15:31.390 --> 15:32.390
那如果说我们这里

15:32.390 --> 15:33.390
要把它做成一个

15:33.390 --> 15:34.390
真正可以就是

15:34.390 --> 15:35.390
要结束的

15:35.390 --> 15:36.390
根据你的需要

15:36.390 --> 15:37.390
自己去做

15:37.390 --> 15:38.390
比方说我要这里

15:38.390 --> 15:40.390
我希望它这里每一项

15:40.390 --> 15:43.390
得到的是一个属性名和属性值

15:43.390 --> 15:44.390
比方说我这里

15:44.390 --> 15:45.390
希望输出的是什么呢

15:45.390 --> 15:47.390
希望输出的是这个

15:47.390 --> 15:49.390
就是propname

15:49.390 --> 15:51.390
propname是a

15:51.390 --> 15:54.390
propvalue是1

15:55.390 --> 15:56.390
propvalue是1

15:56.390 --> 15:57.390
那么第二次循环

15:57.390 --> 15:58.390
propname是b

15:58.390 --> 16:00.390
propvalue是2

16:00.390 --> 16:02.390
比方说我们希望得到这么一个东西

16:02.390 --> 16:03.390
希望得到这么一个东西

16:03.390 --> 16:04.390
那么这种情况下

16:04.390 --> 16:05.390
该怎么做呢

16:06.390 --> 16:07.390
怎么做呢

16:07.390 --> 16:08.390
你看吧

16:08.390 --> 16:09.390
我们就可以这样来吧

16:09.390 --> 16:10.390
我们首先得到这个

16:10.390 --> 16:11.390
得到这个对象的

16:11.390 --> 16:13.390
所有的属性名

16:13.390 --> 16:14.390
这个可以得到吧

16:14.390 --> 16:16.390
object

16:16.390 --> 16:17.390
什么

16:17.390 --> 16:18.390
tease

16:18.390 --> 16:19.390
对不对

16:19.390 --> 16:20.390
得到一个数组

16:20.390 --> 16:21.390
得到这个对象里边

16:21.390 --> 16:23.390
所有的属性的名字

16:23.390 --> 16:25.390
的一个数组

16:25.390 --> 16:26.390
那么对象是

16:26.390 --> 16:27.390
对象就是this

16:27.390 --> 16:28.390
没问题吧

16:29.390 --> 16:30.390
然后

16:30.390 --> 16:33.390
我们这里得到所有的属性名

16:33.390 --> 16:34.390
propname

16:34.390 --> 16:36.390
kiss

16:36.390 --> 16:38.390
我们输出

16:38.390 --> 16:39.390
kiss

16:39.390 --> 16:40.390
来看一下吧

16:40.390 --> 16:41.390
你看

16:41.390 --> 16:43.390
这里没运行

16:43.390 --> 16:44.390
没运行

16:44.390 --> 16:49.330
端为处

16:49.330 --> 16:50.330
你看

16:50.330 --> 16:51.330
这里是不是得到一个

16:51.330 --> 16:52.330
a和b的数组了

16:52.330 --> 16:53.330
对吧

16:53.330 --> 16:54.330
在这里

16:54.330 --> 16:55.330
它这里输出了

16:55.330 --> 16:56.330
说明什么

16:56.330 --> 16:58.330
它一定调用了这个方法

16:58.330 --> 16:59.330
不然的话

16:59.330 --> 17:00.330
这个代码它不会输出的

17:00.330 --> 17:01.330
对吧

17:01.330 --> 17:02.330
那么我们这里得到

17:02.330 --> 17:03.330
所有的属性的名字了

17:03.330 --> 17:04.330
那么形成了一个数组

17:04.330 --> 17:05.330
ok

17:05.330 --> 17:06.330
我们这里

17:06.330 --> 17:07.330
用一个下标

17:07.330 --> 17:08.330
用一个变量

17:08.330 --> 17:09.330
用下标

17:09.330 --> 17:10.330
跟之前的做法

17:10.330 --> 17:11.330
是不是一样的

17:11.330 --> 17:12.330
用一个下标

17:12.330 --> 17:13.330
i等于0

17:13.330 --> 17:15.330
每次掉那个时候

17:15.330 --> 17:16.330
干嘛呢

17:16.330 --> 17:17.330
我们就生成一个对象

17:17.330 --> 17:18.330
生成一个对象

17:18.330 --> 17:20.330
它的value值是什么呢

17:20.330 --> 17:22.330
value值是一个对象

17:22.330 --> 17:24.330
这个对象的属性名

17:24.330 --> 17:25.330
propname

17:25.330 --> 17:26.330
我们最终要得到

17:26.330 --> 17:27.330
是这么一个东西对吧

17:27.330 --> 17:28.330
得到这么一个东西

17:28.330 --> 17:30.330
它的属性名是啥呢

17:30.330 --> 17:31.330
属性名是不是从

17:31.330 --> 17:32.330
kiss里面去取

17:32.330 --> 17:33.330
用i去取

17:33.330 --> 17:34.330
对吧

17:34.330 --> 17:35.330
所以通过这个东西去取

17:35.330 --> 17:37.330
propname

17:37.330 --> 17:39.330
propvalue呢

17:39.330 --> 17:40.330
propvalue

17:40.330 --> 17:41.330
它的值是什么呢

17:41.330 --> 17:42.330
它的值

17:42.330 --> 17:43.330
这是属性名

17:43.330 --> 17:44.330
那么它的值

17:44.330 --> 17:45.330
是不是要

17:45.330 --> 17:46.330
我们这样

17:46.330 --> 17:47.330
分开写

17:47.330 --> 17:48.330
不然的话

17:48.330 --> 17:49.330
propname

17:49.330 --> 17:50.330
等于什么呢

17:50.330 --> 17:51.330
kissi

17:51.330 --> 17:52.330
对吧

17:52.330 --> 17:53.330
我们把对象里面的

17:53.330 --> 17:54.330
这个数组里面

17:54.330 --> 17:55.330
它不是记录了

17:55.330 --> 17:56.330
很多属性名吗

17:56.330 --> 17:57.330
把属性名取出来

17:57.330 --> 17:58.330
放在这

17:58.330 --> 17:59.330
然后属性值呢

17:59.330 --> 18:01.330
propvalue

18:01.330 --> 18:02.330
属性值呢

18:02.330 --> 18:03.330
就是

18:03.330 --> 18:05.330
那个z

18:05.330 --> 18:06.330
不能

18:06.330 --> 18:08.330
这里不能用z

18:08.330 --> 18:09.330
这里

18:09.330 --> 18:11.330
要用那个

18:11.330 --> 18:12.330
我看看

18:12.330 --> 18:13.330
因为这里用z的话

18:13.330 --> 18:14.330
表示的是这个对象

18:14.330 --> 18:15.330
这个对象

18:15.330 --> 18:16.330
那么我们这里

18:16.330 --> 18:17.330
用箭头还输吧

18:17.330 --> 18:19.330
用箭头还输的

18:19.330 --> 18:22.700
用箭头还输

18:22.700 --> 18:23.700
那么这里呢

18:23.700 --> 18:24.700
就可以用z了

18:25.700 --> 18:26.700
就等于z

18:26.700 --> 18:27.700
什么呢

18:27.700 --> 18:28.700
propname

18:28.700 --> 18:29.700
对吧

18:29.700 --> 18:30.700
通过属性名

18:30.700 --> 18:31.700
去把属性值取出来

18:31.700 --> 18:32.700
ok

18:32.700 --> 18:33.700
那么就是属性名

18:33.700 --> 18:35.700
属性值不就放这吧

18:35.700 --> 18:36.700
对不对

18:36.700 --> 18:37.700
那么是否结束呢

18:37.700 --> 18:38.700
那关键是

18:38.700 --> 18:39.700
i是不是有

18:39.700 --> 18:40.700
超出数组下标

18:40.700 --> 18:41.700
对吧

18:41.700 --> 18:42.700
是不是结束

18:42.700 --> 18:43.700
i是不是大于等于

18:43.700 --> 18:44.700
kissi

18:45.700 --> 18:46.700
对不对

18:46.700 --> 18:47.700
就写完了

18:47.700 --> 18:48.700
于是呢

18:48.700 --> 18:49.700
我们就写了

18:49.700 --> 18:50.700
制定了一个对象的

18:50.700 --> 18:51.700
一个

18:51.700 --> 18:52.700
我们就自己

18:52.700 --> 18:53.700
定义了一个

18:53.700 --> 18:54.700
可谍的对象

18:54.700 --> 18:55.700
接下来我们看一下吧

18:56.700 --> 18:57.700
那什么

18:57.700 --> 18:59.700
results undefined is not

19:00.700 --> 19:01.700
哪里写错了

19:02.700 --> 19:03.700
这里没返回

19:03.700 --> 19:04.700
没返回

19:04.700 --> 19:06.700
还要加加对吧

19:06.700 --> 19:07.700
还要返回这个results

19:08.700 --> 19:09.700
老孙

19:09.700 --> 19:10.700
你看

19:10.700 --> 19:11.700
是不是这样子

19:11.700 --> 19:12.700
我们用for2不循环

19:12.700 --> 19:13.700
你看多神奇

19:13.700 --> 19:14.700
我们现在用for2不循环

19:14.700 --> 19:15.700
循环的对象

19:15.700 --> 19:16.700
居然可以循环

19:16.700 --> 19:17.700
而且可以拿到

19:17.700 --> 19:18.700
这样一个东西

19:18.700 --> 19:19.700
为什么

19:19.700 --> 19:20.700
就是它的原理

19:20.700 --> 19:21.700
因为for2不循环

19:21.700 --> 19:23.700
其实让它就使用的是

19:23.700 --> 19:24.700
迭代器

19:24.700 --> 19:25.700
它内部就在用迭代器

19:25.700 --> 19:26.700
不断地去调用next

19:26.700 --> 19:27.700
你给它什么东西

19:27.700 --> 19:29.700
一个value给它什么东西

19:29.700 --> 19:30.700
那么这个item就是什么东西

19:30.700 --> 19:32.700
你value给它一个对象

19:32.700 --> 19:33.700
ok

19:33.700 --> 19:34.700
那么这里的item就是个对象

19:35.700 --> 19:37.700
那么自己完全可以控制了

19:37.700 --> 19:38.700
那么这样子

19:38.700 --> 19:39.700
这样子一来

19:39.700 --> 19:40.700
我们就可以

19:40.700 --> 19:42.700
不仅限于数组了

19:42.700 --> 19:43.700
任何可以迭代的东西

19:43.700 --> 19:44.700
是不是都可以拿去

19:44.700 --> 19:45.700
用for2不循环

19:45.700 --> 19:46.700
它的应用

19:46.700 --> 19:48.700
用途就非常非常宽广了

19:48.700 --> 19:49.700
就不是说仅限于

19:49.700 --> 19:50.700
要用一个数组

19:50.700 --> 19:52.700
才能去循环它

19:52.700 --> 19:53.700
这样的意思吗

19:53.700 --> 19:56.700
这就是关于可迭代协议

19:56.700 --> 19:57.700
和for2不循环

19:58.700 --> 19:59.700
然后最后

19:59.700 --> 20:00.700
我们补充一个支持点

20:01.700 --> 20:03.700
就是关于展开运算幅

20:03.700 --> 20:04.700
和可迭代对象

20:04.700 --> 20:07.700
因为我们之前讲过展开运算幅

20:07.700 --> 20:09.700
实际上的展开运算幅

20:09.700 --> 20:10.700
展开的是啥呢

20:10.700 --> 20:13.700
展开的是可迭代对象

20:13.700 --> 20:15.700
因为我们之前是展开的是数组

20:15.700 --> 20:16.700
对吧

20:16.700 --> 20:17.700
展开的是数组

20:17.700 --> 20:19.700
实际上只要是可迭代对象

20:19.700 --> 20:20.700
我们都可以展开

20:20.700 --> 20:22.700
ES7里边有新增的

20:22.700 --> 20:24.700
可以展开普通对象也可以

20:24.700 --> 20:25.700
只要你是可迭代对象

20:25.700 --> 20:26.700
你都可以展开

20:27.700 --> 20:28.700
那么什么意思呢

20:28.700 --> 20:29.700
什么意思呢

20:29.700 --> 20:30.700
接下来我们看一下吧

20:31.700 --> 20:32.700
看个例子

20:32.700 --> 20:33.700
试点

20:38.640 --> 20:40.640
看一个非常非常有意思的例子

20:40.640 --> 20:41.640
我们就把这个

20:41.640 --> 20:43.640
刚才TES1这个代码拿过来

20:43.640 --> 20:47.230
这个玩意儿

20:47.230 --> 20:48.230
是不是一个可迭代对象

20:48.230 --> 20:50.230
它是不是一个可迭代对象

20:50.230 --> 20:51.230
是吧

20:51.230 --> 20:52.230
对不对

20:52.230 --> 20:53.230
看着

21:00.020 --> 21:01.020
好

21:01.020 --> 21:02.020
非常神奇

21:02.020 --> 21:08.050
看到没

21:08.050 --> 21:10.050
我们最终得到了一个数组

21:10.050 --> 21:11.050
数组里边

21:11.050 --> 21:12.050
是不是

21:12.050 --> 21:13.050
就是把这个迭代器

21:13.050 --> 21:15.050
你的每一个迭代结果拿到了

21:15.050 --> 21:16.050
对吧

21:16.050 --> 21:17.050
实际上

21:17.050 --> 21:18.050
你看这里

21:18.050 --> 21:19.050
如果说它不是一个可迭代对象

21:19.050 --> 21:20.050
这样子写实不行了

21:20.050 --> 21:21.050
你对象展开

21:21.050 --> 21:22.050
你只能展开到对象里边

21:22.050 --> 21:24.050
你不能展开到数组里边

21:24.050 --> 21:25.050
这样子

21:25.050 --> 21:27.050
OBG车一直拿到车

21:27.050 --> 21:28.050
它告诉你

21:28.050 --> 21:30.050
它不是个可迭代对象

21:30.050 --> 21:31.050
你展开

21:31.050 --> 21:32.050
你把它写成数

21:32.050 --> 21:33.050
对象可以

21:33.050 --> 21:34.050
相当于是

21:34.050 --> 21:35.050
复制对象属性

21:35.050 --> 21:36.050
对吧

21:36.050 --> 21:37.050
你把它写成对象

21:37.050 --> 21:38.050
这样的没问题

21:38.050 --> 21:39.050
这样子是没问题的

21:39.050 --> 21:40.050
但是

21:40.050 --> 21:41.050
如果说你把它

21:41.050 --> 21:42.050
对象里边的东西

21:42.050 --> 21:43.050
展开到数组里边

21:43.050 --> 21:44.050
它就出问题了

21:44.050 --> 21:45.050
但是一旦

21:45.050 --> 21:46.050
它是一个可迭代对象

21:46.050 --> 21:47.050
就不一样了

21:47.050 --> 21:48.050
那么展开因算幅

21:48.050 --> 21:49.050
是可以作用于

21:49.050 --> 21:50.050
可迭代对象的

21:50.050 --> 21:51.050
它怎么作用的

21:51.050 --> 21:52.050
其实就很简单

21:52.050 --> 21:53.050
就把这个可迭代对象的

21:53.050 --> 21:54.050
迭代器拿到

21:54.050 --> 21:55.050
一个一个拿出来

21:55.050 --> 21:56.050
一个一个拿出来

21:56.050 --> 21:57.050
就往这个数组里边扔

21:57.050 --> 21:59.050
就往这个地方扔

21:59.050 --> 22:00.050
就完事了

22:00.050 --> 22:01.050
甚至我们在

22:01.050 --> 22:02.050
含述的时候

22:02.050 --> 22:03.050
我们在

22:03.050 --> 22:04.050
调用含述的时候

22:04.050 --> 22:05.050
也可以使用这种方式

22:05.050 --> 22:06.050
比如说

22:06.050 --> 22:07.050
我们有个含述

22:07.050 --> 22:08.050
Test

22:09.050 --> 22:10.050
有两个参数

22:10.050 --> 22:11.050
A和B

22:12.050 --> 22:13.050
输出A和B

22:14.050 --> 22:15.050
那么我们调用

22:15.050 --> 22:16.050
含述的时候

22:16.050 --> 22:17.050
我们可以这样的写

22:17.050 --> 22:18.050
点点点

22:19.050 --> 22:20.050
你看一下

22:20.050 --> 22:21.050
调用含述的时候

22:21.050 --> 22:22.050
你看

22:22.050 --> 22:23.050
是不是输出了

22:23.050 --> 22:24.050
参数A

22:24.050 --> 22:25.050
参数A是这个

22:25.050 --> 22:26.050
参数B是这个

22:26.050 --> 22:27.050
对吧

22:27.050 --> 22:28.050
它怎么来的

22:28.050 --> 22:29.050
它就是

22:29.050 --> 22:30.050
把这个对象

22:30.050 --> 22:31.050
它把它的迭代器拿到

22:31.050 --> 22:32.050
然后呢

22:32.050 --> 22:33.050
调用迭代器

22:33.050 --> 22:34.050
直到不能调用为止

22:34.050 --> 22:35.050
对吧

22:35.050 --> 22:36.050
直到迭代结束为止

22:36.050 --> 22:37.050
那么它就把

22:37.050 --> 22:38.050
每一次迭代的结果

22:38.050 --> 22:39.050
给你展开

22:39.050 --> 22:40.050
放到这儿了

22:41.050 --> 22:42.050
明白的意思吗

22:42.050 --> 22:43.050
这就是展开运算服了

22:43.050 --> 22:44.050
实际上还可以作用

22:44.050 --> 22:45.050
与

22:45.050 --> 22:46.050
可迭代对象的

22:47.050 --> 22:48.050
这个给大家提一句

22:49.050 --> 22:50.050
这个东西

22:50.050 --> 22:51.050
是不是就跟ES6联系起来

22:51.050 --> 22:52.050
现在

22:52.050 --> 22:53.050
对吧

22:53.050 --> 22:54.050
一开始呢

22:54.050 --> 22:55.050
我们上节可能讲的迭代器

22:55.050 --> 22:56.050
只是一些概念性的东西

22:56.050 --> 22:57.050
教你们怎么去写

22:57.050 --> 22:58.050
教你们怎么去认识它

22:58.050 --> 22:59.050
那么这节可能

22:59.050 --> 23:00.050
就跟ES6关联起来了

23:00.050 --> 23:01.050
特别是

23:01.050 --> 23:02.050
FOR25循环

23:02.050 --> 23:03.050
因为我们后边

23:03.050 --> 23:05.050
几乎很多时候

23:05.050 --> 23:07.050
都要去用到FOR25循环

23:07.050 --> 23:08.050
就是

23:08.050 --> 23:09.050
我们要去循环一个

23:09.050 --> 23:10.050
便利一个

23:10.050 --> 23:11.050
就迭代一个东西

23:11.050 --> 23:12.050
或者便利一个东西

23:12.050 --> 23:13.050
我管它是不是宿主

23:13.050 --> 23:14.050
管它那么多呢

23:14.050 --> 23:15.050
它是宿主

23:15.050 --> 23:16.050
还是伪宿主

23:16.050 --> 23:17.050
伪宿主内宿主

23:17.050 --> 23:18.050
无所谓

23:18.050 --> 23:19.050
只要你是可迭代的

23:19.050 --> 23:20.050
我就可以便利你

23:20.050 --> 23:21.050
我就可以按照你的

23:21.050 --> 23:23.050
规范来进行便利

23:23.050 --> 23:24.050
好吧

23:24.050 --> 23:25.050
这是关于

23:25.050 --> 23:26.050
FOR25循环

23:26.050 --> 23:27.050
以及迭代器

