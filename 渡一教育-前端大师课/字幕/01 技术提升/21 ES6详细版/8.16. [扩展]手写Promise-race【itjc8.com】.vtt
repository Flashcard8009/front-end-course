WEBVTT

00:00.300 --> 00:04.140
好了 同学们 我们这节课呢来实现Race 方法

00:04.400 --> 00:07.480
这个Race 方法呢 简单介绍一下

00:07.980 --> 00:11.820
就好像赛跑一样 我不管你是成功还是失败

00:12.340 --> 00:15.140
我只看第一个到达终点的人

00:16.180 --> 00:19.760
第一个到达终点 无论是什么样的结果 就第一个有结果的

00:20.020 --> 00:21.540
你成功了 那我就跟着成功

00:21.800 --> 00:26.660
你失败了 我就跟着失败 成功的数据跟你一样 失败的原因也跟你一样

00:27.120 --> 00:28.960
比方说这里有三个Promise

00:29.220 --> 00:33.820
第一个 第二个 第一个等待一秒钟之后失败 第二个等待500毫秒之后成功

00:34.080 --> 00:37.920
第三个就是一个数字 当然我们知道这个玩意会被包装成一个Promise

00:38.440 --> 00:41.500
那么我们返回的Promise是成功还是失败呢 通过Race

00:43.040 --> 00:45.600
那肯定是成功 为什么 因为它是最先成功的 对吧

00:45.860 --> 00:49.440
这个Promise就是一个已完成的Promise 它数据是5 所以说

00:49.700 --> 00:51.240
我们这里呢 会得到这个数据

00:51.500 --> 00:53.540
5 打印一下 成功

00:56.580 --> 00:57.620
然后这里是失败

01:01.310 --> 01:02.070
好运行啊

01:03.610 --> 01:05.910
成功 对吧 那怎么说把这个5去掉

01:06.170 --> 01:10.530
那自然而然 它先完成 它是成功的 那我这个Promise就是成功的

01:12.310 --> 01:14.370
那如果把它变成1500毫秒

01:14.630 --> 01:15.130
再来

01:16.670 --> 01:17.430
那就失败

01:18.470 --> 01:19.750
看到没 就这么简单

01:20.250 --> 01:23.830
那这个函数怎么写呢 从下面可以发挥自己的聪明材质

01:25.370 --> 01:28.950
这边是传入一个Promise 当然也是一个迭代器

01:31.310 --> 01:31.870
好 来吧

01:33.910 --> 01:35.970
这边是Aterator

01:37.510 --> 01:39.030
这里是表示什么意思呢

01:41.350 --> 01:43.910
返回的Promise与

01:44.670 --> 01:47.230
第1个有结果的一致

01:50.840 --> 01:53.400
好了 那么这个函数呢 怎么实现呢

01:53.920 --> 01:56.740
那太简单了 那简单的利人法子

01:57.240 --> 02:01.340
怎么个简单法呢 你看我就循环便利这个这些Promise

02:02.060 --> 02:04.620
当然我这里要返回一个Promise

02:05.380 --> 02:05.900
Return

02:06.920 --> 02:07.420
New

02:07.680 --> 02:08.720
MyPromise

02:10.000 --> 02:13.060
好 这边我就循环迭代这个Promise

02:13.580 --> 02:17.160
然后每循环一次对这个Promise说 你如果说成功了

02:17.420 --> 02:18.700
那我就跟着成功了

02:18.960 --> 02:21.000
你失败了 我就跟着失败了

02:21.520 --> 02:24.080
那如果说成功了两个呢 没关系

02:24.080 --> 02:25.620
因为它只认第1次掉用的

02:25.860 --> 02:29.960
对吧 这个锐 这个锐 这个锐 只有第1次掉用有效 后续掉用就无效了

02:30.900 --> 02:32.400
完了 没了

02:32.740 --> 02:33.460
就写完了

02:34.000 --> 02:37.940
好 咱们来试一下啊 我们把它换成MyPromise

02:39.580 --> 02:40.900
换成MyPromise 试一下

02:42.820 --> 02:44.500
当然我还是要做这么一件事啊

02:44.760 --> 02:47.420
MyPromise Result

02:51.200 --> 02:51.920
好 运行

02:53.240 --> 02:56.560
对吧 是不是完全一样的对吧 我们再把它换成500

02:57.800 --> 03:00.400
500毫秒之后成功 然后再把它加一个5

03:01.260 --> 03:04.580
就成功了 完全一样的

03:04.860 --> 03:08.740
那一通那传统组组组怎么样 那传统组组组组的话进不了循环

03:08.740 --> 03:10.540
进不了循环这个Promise永远等待

03:11.260 --> 03:13.260
这就是官方 官方就是这样子做的啊

03:13.580 --> 03:15.900
所以说一定要去参考那个MDN稳当

03:16.220 --> 03:18.540
他是怎么说的 我就怎么做啊 我不会乱来的

03:19.140 --> 03:20.740
OK 那么这就是实现了

03:21.420 --> 03:21.920
Result

03:22.860 --> 03:24.700
好 其实到这儿了 我们Promise

03:25.020 --> 03:27.580
其实还有一个API啊 这个API叫做Ending

03:27.860 --> 03:28.860
这个API我不实现了

03:29.080 --> 03:31.880
为什么呢 因为目前还在试验阶段 将来有可能会变

03:32.400 --> 03:34.000
目前还没有成为正式标准

03:34.440 --> 03:37.560
所以说呢 我们到这儿了 就把Promise所有的静态方法

03:38.000 --> 03:42.200
包括PromiseA加规范 包括它的实力方法对吧 还翻了离开去 全部实现了

03:43.040 --> 03:44.880
你们以后在面试的时候 他不会

03:45.400 --> 03:49.640
考虑的 让你把所有的全部写出来 那这个时间有点长啊 他可能

03:50.000 --> 03:51.280
没有那么多时间能力写

03:51.840 --> 03:56.200
但是呢 他可能会怎么去考虑通常情况下 他会考虑写单个方法

03:56.480 --> 03:58.080
一个时候实现一个哦 这是比较多的

03:58.960 --> 04:03.480
这个 你看后边方法的比较简单 对吧 它可能稍微有点难度的话 就让你去实现一个哦

04:04.600 --> 04:09.560
不会让你去写这个A加 但也有可能会让你去写这个A加规范 那写出来

04:09.800 --> 04:13.080
你把我这套写出来 这个质量是非常高的

04:14.080 --> 04:18.480
好了 那么 支持呢 如果同学们到这儿 能够理解我们之前讲的所有内容的话

04:18.840 --> 04:22.600
那你对Promise的了解 不仅对Promise的了解非常非常透彻了

04:23.040 --> 04:27.680
同时 你的编程能力和程序思维能力也上升了一个台阶

04:28.660 --> 04:34.500
OK 同学们 那么Promise的讲解到此结束了 将来如果说有一些新的API的话 我再考虑去加一个课程

04:35.420 --> 04:39.100
其实后边加一些API的话 同学们都可以自己尝试着自己实现了 并不复杂

