WEBVTT

00:00.880 --> 00:04.320
本章给大家介绍一下ES6里面

00:04.320 --> 00:08.620
它对制服串和动作表达式的一些细微的变动

00:08.620 --> 00:13.160
首先这节课给大家讲的是关于这个Ulicode的支持

00:13.160 --> 00:15.560
什么意思呢 我首先给大家看一段代码

00:15.560 --> 00:18.000
这段代码特别特别有意思

00:18.000 --> 00:21.520
你看到这个代码里面 我这里定义了一个制服串

00:21.520 --> 00:23.400
这个制服串里面只有一个字

00:23.400 --> 00:26.000
这个字里的读啥 我也不知道这个读啥

00:26.000 --> 00:29.000
好像读极了 好像是读极

00:29.160 --> 00:33.040
是一个古汉字 现在没有怎么用了

00:33.040 --> 00:34.800
就是一些生辟字

00:34.800 --> 00:37.240
那么现在我做这么一件事

00:37.240 --> 00:39.760
我输出一下TexterDiliance

00:39.760 --> 00:41.920
然后制服串长度

00:41.920 --> 00:45.350
制服串长度

00:45.350 --> 00:47.670
长度

00:47.670 --> 00:49.070
长度

00:49.070 --> 00:51.190
咱们来看一下吧 输出什么样

00:51.190 --> 00:55.300
这里右键运行出来看一下

00:55.300 --> 00:57.260
看一下控制台

00:57.260 --> 00:59.980
他告诉我 这个制服串长度为2

00:59.980 --> 01:01.660
这不很神奇吗 对吧

01:01.700 --> 01:03.380
长度怎么会是2呢

01:03.380 --> 01:05.460
然后我们再来看一下

01:05.460 --> 01:08.180
看一下 证则去测试

01:08.180 --> 01:11.660
使用证则测试

01:11.660 --> 01:13.260
我们写什么样的证则测试呢

01:13.260 --> 01:14.940
我们写这么一个证则表达试

01:14.940 --> 01:17.540
这个证则表达试是开始结束

01:17.540 --> 01:20.580
中间是任意制服 匹配任意一个制服

01:20.580 --> 01:21.980
那你这里不是单个制服吗

01:21.980 --> 01:23.940
对吧 我们来看一下能不能匹配

01:23.940 --> 01:27.780
点TestTexter传进去

01:27.780 --> 01:29.900
我们匹配一下 看一下能不能匹配

01:29.940 --> 01:33.140
保存啊 他告诉我匹配不能匹配

01:33.140 --> 01:36.700
证则测试是Force

01:36.700 --> 01:38.740
那么这个东西到底是怎么回事呢

01:38.740 --> 01:40.780
其实这个要说到文字编码

01:40.780 --> 01:43.700
其实文字编码是一块满身的知识

01:43.700 --> 01:45.780
它要了解你不仅要了解历史

01:45.780 --> 01:51.020
还要了解一些甚至是一些算法

01:51.020 --> 01:52.300
我这里简单说一下吧

01:52.300 --> 01:56.380
因为这个完全已经超出了本门课的范畴了

01:56.380 --> 01:57.340
我这里简单说一下

01:57.340 --> 02:00.620
保证大家能理解它到底是怎么发生这个问题的

02:00.620 --> 02:04.380
是因为我们在介石

02:04.380 --> 02:06.220
我们当时说这个地结合的时候

02:06.220 --> 02:09.100
说到介石在10年之间是没有发生变动的

02:09.100 --> 02:14.020
对吧 那么这10年是在1999年出的是3.0版本

02:14.020 --> 02:15.500
也是3.0版本

02:15.500 --> 02:18.340
那么那个时候其实不要说互联网了

02:18.340 --> 02:21.100
连电脑的普及率都不高

02:21.100 --> 02:22.300
在全世界范围内

02:22.300 --> 02:25.060
当然发达国家可能会普及率稍微高一点

02:25.060 --> 02:26.540
但是在全世界范围内

02:26.540 --> 02:28.180
普及率并不高

02:28.180 --> 02:31.700
而且那个时候计算机的资源是比较宝贵的

02:31.700 --> 02:36.100
我记得那个时候的内存好像就几兆吧

02:36.100 --> 02:37.300
就是多少

02:37.300 --> 02:39.500
多少兆啊

02:39.500 --> 02:40.980
16兆内存

02:40.980 --> 02:42.340
32兆内存

02:42.340 --> 02:42.820
对吧

02:42.820 --> 02:45.100
还有128兆内存都算比较大的了

02:45.100 --> 02:45.820
说那个时候

02:45.820 --> 02:47.900
自己计算机的资源很宝贵

02:47.900 --> 02:50.060
因此要在计算机上

02:50.060 --> 02:51.300
包括内存也好

02:51.300 --> 02:51.940
硬盘也好

02:51.940 --> 02:52.940
都比较宝贵

02:52.940 --> 02:55.660
因此要在计算机上存出一些文字

02:55.700 --> 02:56.940
文字不是要编码嘛

02:56.940 --> 02:57.380
对吧

02:57.380 --> 03:00.020
他要把文字转变成一个数字的编码

03:00.020 --> 03:02.380
那么他要确定一个文字

03:02.380 --> 03:05.420
他要转成多少多大的数字

03:05.420 --> 03:06.540
比方这个数字越大

03:06.540 --> 03:08.300
你是不是占用的空间就越大啊

03:08.300 --> 03:08.940
对吧

03:08.940 --> 03:10.540
于是当时有这么一个编码

03:10.540 --> 03:12.780
叫做Ulicode的编码

03:12.780 --> 03:13.780
Ulicode的编码

03:13.780 --> 03:16.060
Ulicode的编码还经过了很多代的发展

03:16.060 --> 03:19.500
到现在已经变得跟之前不太一样了

03:19.500 --> 03:20.460
最早的时候

03:20.460 --> 03:22.260
那个时候Ulicode的编码

03:22.260 --> 03:23.660
它是指定16位

03:24.660 --> 03:25.460
早期

03:27.260 --> 03:33.060
早期由于存储空间宝贵

03:33.060 --> 03:37.060
Ulicode的使用16位

03:38.460 --> 03:43.660
16位二净字来存储文字

03:43.660 --> 03:46.260
对文字来进行16位的编码

03:46.260 --> 03:48.860
因此我们这里用一种简单的说法

03:49.060 --> 03:52.860
就把16位的二净字叫做一个马元

03:55.260 --> 04:06.060
我们将一个16位的二净字编码的编码

04:06.060 --> 04:08.860
叫做一个马元

04:10.260 --> 04:11.860
我这个是简单解释

04:11.860 --> 04:13.740
你要说他真正的意识

04:13.740 --> 04:16.660
详细的解释已经超出了本门课的范畴了

04:16.660 --> 04:20.260
我只是说他为什么会出这个问题

04:20.260 --> 04:21.660
他的名字叫做Code

04:21.660 --> 04:25.460
Ulicode叫做马元

04:25.460 --> 04:27.460
它是这么来称呼

04:27.460 --> 04:29.060
但是16位二净字

04:29.060 --> 04:32.460
你想16位二净字能表示多少个文字

04:32.460 --> 04:33.660
有没有这个概念

04:33.660 --> 04:35.460
16位的二净字表示多少个文字

04:35.460 --> 04:38.460
那就是二的16次方

04:38.460 --> 04:39.260
你看看

04:39.260 --> 04:40.060
二的16次方

04:40.060 --> 04:41.660
是不是能表示这么多文字

04:41.660 --> 04:42.560
6万多文字

04:42.560 --> 04:43.660
你觉得6万多文字

04:43.660 --> 04:46.060
对于全世界的文字来说够吗

04:46.060 --> 04:48.260
是不是完全不够

04:48.260 --> 04:49.360
完全不够

04:49.360 --> 04:56.660
因此后来Ulicode出来了一个扩展级

04:56.660 --> 05:02.660
后来由于技术的发展Ulicode

05:02.660 --> 05:04.560
就是空间不再那么宝贵了

05:04.560 --> 05:05.560
空间越来越大了

05:05.560 --> 05:06.860
就完全够了

05:06.860 --> 05:09.560
那么电脑的普及率

05:09.560 --> 05:11.360
互联网的普及率越来越高

05:11.360 --> 05:14.660
更多的国家需要把文字放到Ulicode的编码里边

05:14.660 --> 05:20.160
所以Ulicode对文字编码进行了扩展

05:20.160 --> 05:23.860
我们知道一个马元表示的是16位的二净字

05:23.860 --> 05:25.960
那么它对文字扩展的过后

05:25.960 --> 05:28.160
它扩展到了32位

05:28.160 --> 05:30.560
将某些文字

05:30.560 --> 05:31.860
注意哦 不是全部文字哦

05:31.860 --> 05:36.860
是某些文字扩展到了32位

05:36.860 --> 05:40.060
也就是说占用两个马元

05:40.060 --> 05:42.260
应该知道我现在要说什么意思了吧

05:42.260 --> 05:48.060
占用两个马元

05:48.060 --> 05:55.460
并且将某个文字对应的二净字

05:55.460 --> 06:00.460
数字叫做马点

06:00.460 --> 06:04.460
它的名字叫做CodePoint

06:04.460 --> 06:06.860
也就是说马点跟马元是什么关系呢

06:06.860 --> 06:09.060
马元是最小单位

06:09.060 --> 06:10.860
一个文字它转换成二净字之后

06:10.860 --> 06:13.260
它对应的数字它可能占用一个马点

06:13.260 --> 06:14.460
一个马元

06:14.460 --> 06:16.760
一个马点可能占用一个马元

06:16.760 --> 06:18.160
有可能占用两个马元

06:18.160 --> 06:19.360
对吧 马点是什么

06:19.360 --> 06:20.260
就是对应那个数字

06:20.260 --> 06:21.060
就是刚表

06:21.060 --> 06:22.060
一个数字对应一个文字

06:22.060 --> 06:23.260
一个数字对应一个文字

06:23.260 --> 06:24.960
有些数字它要占用两个马元

06:24.960 --> 06:26.360
就要占用32位

06:26.360 --> 06:27.960
有些数字只需要占用16位

06:27.960 --> 06:30.060
就是以前已经做好的文字

06:30.060 --> 06:31.360
那么新出来的文字

06:31.360 --> 06:32.260
它装不下了

06:32.260 --> 06:32.760
对吧 装不下了

06:32.760 --> 06:34.860
它就多放一个12位来存储

06:34.860 --> 06:36.960
所以说现在我们能存储的文字

06:36.960 --> 06:37.960
就比较多了

06:37.960 --> 06:38.960
不是说翻倍了

06:39.060 --> 06:40.460
不说到了32位

06:40.460 --> 06:41.960
翻倍了变成多少了

06:41.960 --> 06:43.060
变成12万多文字了

06:43.060 --> 06:45.660
那不是是2的32次方

06:45.660 --> 06:47.260
兄弟 2的32次方

06:47.260 --> 06:47.760
你看一下

06:48.960 --> 06:50.760
是这么多文字现在可以

06:50.760 --> 06:51.760
现在可以表达这么多文字

06:51.760 --> 06:52.760
是完全够的

06:52.760 --> 06:54.260
是完全够的

06:54.260 --> 06:55.360
由于现在的文字

06:55.360 --> 06:56.460
某一些文字

06:56.460 --> 06:58.260
它要占用两个马元

06:58.260 --> 07:00.460
有些文字的占用两个马点

07:00.460 --> 07:03.060
就有些文字的它的马点

07:03.060 --> 07:04.460
它要占用两个马元

07:04.460 --> 07:05.360
有些文字的马点

07:05.360 --> 07:07.760
它占用一个马元

07:07.760 --> 07:08.860
就说不准

07:08.860 --> 07:11.660
但是呢既然是由于它10年没有更新

07:11.660 --> 07:13.660
你说恐怖这个事情

07:13.660 --> 07:14.160
因此呢

07:14.160 --> 07:16.760
它长期以来都是字

07:16.760 --> 07:19.160
它都认为一个马点就是一个马元

07:19.160 --> 07:20.360
一个马点就是一个马元

07:20.360 --> 07:21.660
它是这样子认为的

07:21.660 --> 07:22.360
因此呢

07:22.360 --> 07:24.360
它在对曲智幅上长度的时候

07:24.360 --> 07:27.160
它是根据马元来取的

07:27.160 --> 07:27.960
你要这个意思吧

07:27.960 --> 07:28.960
你像这个文字

07:28.960 --> 07:30.960
它实际上是占用了两个马元

07:33.060 --> 07:36.160
占用了两个马元

07:36.160 --> 07:37.360
也就是它是32位的

07:38.860 --> 07:40.060
它是32位的

07:40.060 --> 07:40.560
因此呢

07:40.560 --> 07:41.860
既然是它认为这个

07:41.860 --> 07:43.560
它在读这个字部说长度的时候

07:43.560 --> 07:45.860
它是按照马元的

07:45.860 --> 07:47.360
马元的多少来读的

07:47.360 --> 07:49.160
它认为一个马元就是一个文字

07:49.160 --> 07:49.660
因此呢

07:49.660 --> 07:52.360
它导致了它这里会输出二

07:52.360 --> 07:52.860
并且呢

07:52.860 --> 07:54.760
在征则表达是里边

07:54.760 --> 07:55.760
它匹配的时候

07:55.760 --> 07:57.860
也是按照马元来匹配的

07:57.860 --> 07:59.960
而不是按照马点来匹配的

07:59.960 --> 08:00.760
明白的意思吗

08:00.760 --> 08:01.960
所以说它这里匹配不上

08:01.960 --> 08:04.360
因为它认为这个字部说有两个文字

08:04.360 --> 08:04.760
结果呢

08:04.760 --> 08:05.560
你只匹配一个

08:05.560 --> 08:06.660
所以说你匹配不上

08:06.660 --> 08:07.860
你说开始字部的开始

08:07.860 --> 08:08.660
里面有一个文字

08:08.660 --> 08:09.360
然后就结束

08:09.360 --> 08:11.160
但是它认为这个字部说有两个文字

08:11.160 --> 08:12.560
因为它读到了有两个马元

08:12.560 --> 08:14.160
它是32位的

08:14.160 --> 08:15.460
所以说它出了这个问题

08:15.460 --> 08:17.760
这是一个非常非常细节的问题

08:17.760 --> 08:19.760
我之前有同学在工作中

08:19.760 --> 08:22.660
遇到一个这个神奇的问题

08:22.660 --> 08:24.160
他说这十多搞不清楚怎么回事

08:24.160 --> 08:26.560
就是这个原因

08:26.560 --> 08:27.660
那么这个时候呢

08:27.660 --> 08:28.560
在ES6里面

08:28.560 --> 08:29.760
它出现了一个困扰

08:29.760 --> 08:31.460
在ES6里边

08:31.460 --> 08:32.960
它能不能改动这个属性呢

08:32.960 --> 08:34.360
让它不要去读马元了

08:34.360 --> 08:35.860
而去读马点有多少个

08:35.860 --> 08:37.060
它能不能去改动呢

08:37.060 --> 08:37.960
它是可以改动的

08:37.960 --> 08:40.160
它不敢改动

08:40.160 --> 08:40.960
为什么呢

08:40.960 --> 08:43.960
因为以前的很多的旧系统都是

08:43.960 --> 08:46.760
它不能保证以前的旧系统

08:46.760 --> 08:47.560
只去兼容

08:47.560 --> 08:48.960
它要兼容以前的旧系统

08:48.960 --> 08:50.360
那怎么办呢

08:50.360 --> 08:51.560
你如果说把这个改了

08:51.560 --> 08:53.160
以前的旧系统的布尔了

08:53.160 --> 08:55.060
那很多鸡依赞于这个长度的

08:55.060 --> 08:56.560
是不是全部要出问题

08:56.560 --> 08:57.460
所以它为了兼容

08:57.460 --> 08:59.360
它不敢去改动这个属性

08:59.360 --> 08:59.860
但是呢

08:59.860 --> 09:00.660
它为了折冲

09:00.660 --> 09:01.660
它折冲了一下

09:01.660 --> 09:04.760
它给你出来了一个方法

09:04.760 --> 09:06.960
来帮助你的解决这个问题

09:06.960 --> 09:08.160
就是这个能识属性呢

09:08.160 --> 09:09.060
我们现在呢

09:09.060 --> 09:10.860
哪怕是已经到了s6了

09:10.860 --> 09:12.160
你看得到了还是2

09:12.160 --> 09:13.560
还是没有变化

09:13.560 --> 09:14.160
并且呢

09:14.160 --> 09:15.360
我们以前呢

09:15.360 --> 09:17.460
这字幕创里边不是有这么一个方法吗

09:17.460 --> 09:18.660
哎哎哎

09:18.660 --> 09:19.760
在字幕创里边不是有这么

09:19.760 --> 09:20.760
哎哎哎

09:20.760 --> 09:21.560
怎么回事

09:21.560 --> 09:23.460
哦点错了啊

09:23.460 --> 09:24.960
字幕创里边不是有这么一个方法吗

09:24.960 --> 09:26.360
就是

09:26.360 --> 09:27.360
得到第一个马

09:27.360 --> 09:30.060
得到第一个马元

09:30.060 --> 09:31.160
不是有这么一个方法

09:31.160 --> 09:33.160
就是叫做text

09:33.160 --> 09:34.000
叫做

09:35.000 --> 09:36.000
对吧

09:38.000 --> 09:38.800
这里传明

09:38.800 --> 09:41.900
就是下标为你那个制服的马元

09:41.900 --> 09:43.500
它这里是读的是马元啊

09:43.500 --> 09:45.200
因为我们这里不是有两个马元吗

09:45.200 --> 09:47.900
对第一个马元的数字是多少

09:49.200 --> 09:51.200
那么第二个马元的数字是多少

09:51.200 --> 09:51.800
你看

09:51.800 --> 09:53.600
你就会明显的发现了

09:53.600 --> 09:56.400
它是两个16位的数字

09:57.600 --> 09:59.800
换成实境字就不是16位了

09:59.800 --> 10:01.000
16位的二净字

10:01.000 --> 10:02.500
16位的二净字我们刚才看了

10:02.500 --> 10:03.500
是6万多对吧

10:03.600 --> 10:05.400
它得到5万多5万多对吧

10:05.400 --> 10:06.400
是不是两个马元

10:06.400 --> 10:08.200
它得到的是两个马元

10:08.200 --> 10:09.000
这是以前的

10:09.000 --> 10:10.000
以前的东西啊

10:10.000 --> 10:10.800
那么现在呢

10:10.800 --> 10:12.200
在es6里边呢

10:13.700 --> 10:14.600
es6

10:15.800 --> 10:19.800
为了解决为了解决这个困扰

10:22.100 --> 10:23.000
提供了

10:23.800 --> 10:26.900
就是为制服创提供了

10:27.700 --> 10:28.200
方法

10:28.200 --> 10:28.900
什么方法呢

10:28.900 --> 10:29.700
就这个方法

10:29.700 --> 10:30.600
叫做

10:30.600 --> 10:34.000
char code point

10:34.000 --> 10:35.000
code point什么意思

10:35.000 --> 10:36.000
就是马点

10:36.000 --> 10:37.000
得到马

10:37.000 --> 10:39.000
code point at

10:39.000 --> 10:40.000
你看这个

10:42.000 --> 10:43.200
得到第一个

10:43.200 --> 10:46.310
第一个马点

10:46.310 --> 10:48.110
得到第一个马点

10:49.610 --> 10:50.910
code point at

10:50.910 --> 10:51.510
就这个

10:51.510 --> 10:52.510
code point at

10:52.510 --> 10:54.310
code point at

10:55.310 --> 10:56.210
提供这个方法

10:56.210 --> 10:57.010
那么是

10:57.010 --> 10:59.610
根据制服创

10:59.710 --> 11:01.710
马元的位置

11:01.710 --> 11:02.510
得到

11:02.510 --> 11:03.310
起

11:03.310 --> 11:04.610
马点

11:04.610 --> 11:05.610
它能够得到的马点

11:05.610 --> 11:07.010
以前是很难得到的

11:07.010 --> 11:08.410
你以前得在自己处理

11:08.410 --> 11:09.010
很麻烦的

11:09.010 --> 11:09.910
非常非常麻烦

11:09.910 --> 11:11.010
要对这个制服创编码

11:11.010 --> 11:12.110
要非常深入的认识

11:12.110 --> 11:14.010
你才能自己去写这个代码

11:14.010 --> 11:14.310
当然了

11:14.310 --> 11:15.310
现在那就不用了

11:15.310 --> 11:15.910
现在提供了

11:15.910 --> 11:17.110
这么一个方法就不用了

11:17.110 --> 11:17.710
那么比方说

11:17.710 --> 11:18.610
我们这里写零

11:18.610 --> 11:19.510
什么意思呢

11:19.510 --> 11:21.410
就是得到马元

11:21.410 --> 11:22.710
也不是有两个马元吗

11:22.710 --> 11:23.110
对吧

11:23.110 --> 11:23.910
你看两个马元

11:23.910 --> 11:24.910
第一个马元是这个

11:24.910 --> 11:25.810
第一个马元是这个

11:25.810 --> 11:29.210
得到第一个马元的马点

11:29.210 --> 11:30.510
因为它占用了两个马元

11:30.510 --> 11:31.610
第一个马元的马点

11:31.610 --> 11:34.010
是不是可以把两个马元连接起来

11:34.010 --> 11:35.510
保存你看一下

11:35.510 --> 11:39.610
第一个马点是不是得到这个文字的

11:39.610 --> 11:40.310
整个字

11:40.310 --> 11:41.410
整个就是编码了

11:41.410 --> 11:41.710
对吧

11:41.710 --> 11:43.810
它把两个马元联合起来了

11:43.810 --> 11:45.910
明白这个意思吗

11:45.910 --> 11:47.210
下面这一代码

11:47.210 --> 11:49.410
就是你可以这样理解

11:49.410 --> 11:51.810
我们这里把这个文字复制一下

11:51.810 --> 11:53.310
这个东西相当于是啥呢

11:53.310 --> 11:54.810
相当于是

11:54.810 --> 11:56.310
5 3 6 2

11:56.310 --> 12:00.010
我们把它换成16进字

12:00.010 --> 12:04.010
2 3 16进字

12:04.010 --> 12:05.510
把这个数字换成16进字

12:05.510 --> 12:08.210
看着我这里

12:08.210 --> 12:10.910
你看一下第8 4 2

12:10.910 --> 12:12.210
它相当于这个文字

12:12.210 --> 12:13.910
相当于是两个马元

12:13.910 --> 12:15.710
一个马元就是4位的16进字

12:15.710 --> 12:16.610
4位的16进字

12:16.610 --> 12:18.710
是不是就是16位的2进字

12:18.710 --> 12:19.910
1位的16进字

12:19.910 --> 12:20.710
这个是常识啊

12:20.710 --> 12:21.510
兄弟们

12:21.510 --> 12:23.110
1位的16进字

12:23.110 --> 12:25.310
是不是4位的2进字

12:25.310 --> 12:26.110
对吧

12:26.110 --> 12:26.810
4位的2进字

12:26.810 --> 12:28.210
你说按吗

12:28.210 --> 12:29.310
你说按吗

12:29.310 --> 12:30.410
2进字4位

12:30.410 --> 12:31.410
4位是多少

12:31.410 --> 12:32.910
4位的是不是就是16

12:32.910 --> 12:33.210
对吧

12:33.210 --> 12:34.510
刚好是16进字

12:34.510 --> 12:35.610
一个16进字

12:35.610 --> 12:38.510
就相当于是4位的2进字

12:38.510 --> 12:40.110
那么4位的16进字

12:40.110 --> 12:43.010
是不是相当于是16位的2进字

12:43.010 --> 12:43.410
对吧

12:43.410 --> 12:44.710
它是有两个马元

12:44.710 --> 12:47.410
一个马元

12:47.410 --> 12:49.010
另一个马元

12:49.010 --> 12:49.510
对吧

12:49.510 --> 12:50.510
是不是这个东西

12:50.510 --> 12:51.710
它就相当于是这个

12:51.710 --> 12:54.210
相当于是这个

12:54.210 --> 12:54.910
那么相当于是

12:54.910 --> 12:55.710
它有两个马元

12:55.710 --> 12:56.510
那么下面这句话

12:56.510 --> 12:57.610
按吗是什么意思呢

12:57.610 --> 12:59.410
它是得到第一个马元

12:59.410 --> 13:00.310
你这里写的是0

13:00.310 --> 13:02.110
它得到的是第一个马元

13:02.110 --> 13:03.510
那么第一个马元拿出来看

13:03.510 --> 13:04.410
哎不对啊

13:04.410 --> 13:06.310
这个文字它不仅

13:06.310 --> 13:07.310
它一看就知道了

13:07.310 --> 13:08.010
它怎么知道的

13:08.010 --> 13:09.210
你就别管了

13:09.210 --> 13:10.810
它一看这个数字就知道了

13:10.810 --> 13:11.610
这个数字呢

13:11.610 --> 13:13.110
它肯定是占用了两个马元

13:13.110 --> 13:14.110
占用了不是一个

13:14.110 --> 13:15.610
因此它会把下一个马元

13:15.610 --> 13:16.410
也取出来

13:16.410 --> 13:17.810
两个联合起来

13:17.810 --> 13:18.910
形成一个马点

13:18.910 --> 13:20.210
然后把马点给你

13:20.210 --> 13:21.310
马点的数字给你

13:21.310 --> 13:22.310
是这么一回事

13:22.310 --> 13:23.810
不要的意思吗

13:23.810 --> 13:24.910
那么同样的道理呢

13:25.010 --> 13:26.110
如果说你这里

13:26.110 --> 13:27.810
得到第二个马点呢

13:27.810 --> 13:29.710
能不能得到第二个马点呢

13:29.710 --> 13:31.610
如果说你这里写1

13:31.610 --> 13:32.310
这意思是什么意思呢

13:32.310 --> 13:33.510
它把这个数字拿出来

13:33.510 --> 13:34.310
然后看这个数字

13:34.310 --> 13:35.410
哎这个数字

13:35.410 --> 13:36.610
是不是之前那个数字

13:36.610 --> 13:37.710
之前那个文字的一半

13:37.710 --> 13:38.410
对吧

13:38.410 --> 13:40.710
但是它不知道是文字的一半啊

13:40.710 --> 13:41.510
它看第一个

13:41.510 --> 13:43.010
它看这个文字的第一个马元

13:43.010 --> 13:44.610
它知道还没完

13:44.610 --> 13:45.610
但它看第二个马元

13:45.610 --> 13:46.410
它不知道还没完

13:46.410 --> 13:48.210
它认为就是一个普通的马点

13:48.210 --> 13:49.110
那么它会

13:49.110 --> 13:50.710
缘风不动的输出

13:50.710 --> 13:52.710
会缘风不动的输出

13:52.710 --> 13:53.510
我们把这个取掉

13:53.510 --> 13:55.210
你看看对比一下吗

13:55.210 --> 13:55.710
你看

13:55.710 --> 13:57.310
第二个是不是缘风不动的输出

13:57.310 --> 13:57.710
对吧

13:57.710 --> 13:59.510
它提供了这么一个东西

13:59.510 --> 14:00.510
提供这么个东西

14:00.510 --> 14:01.410
它提供这么一个东西

14:01.410 --> 14:02.610
有啥用的

14:02.610 --> 14:03.710
有啥用的

14:03.710 --> 14:04.810
你看着啊

14:04.810 --> 14:06.510
它有了这么一个东西之后

14:06.510 --> 14:08.710
我们就可以利用这个玩意

14:08.710 --> 14:10.710
来判断一个文字

14:10.710 --> 14:12.610
它到底是

14:12.610 --> 14:15.710
占32位还是16位

14:15.710 --> 14:17.410
就可以判断了

14:17.410 --> 14:18.910
我们写个函数

14:18.910 --> 14:19.610
写个函数

14:19.610 --> 14:21.010
比方说

14:21.010 --> 14:21.910
这个函数呢

14:21.910 --> 14:22.910
该取个名字叫做

14:22.910 --> 14:24.110
意思

14:24.110 --> 14:26.810
32bit

14:26.810 --> 14:28.310
你给我一个

14:28.310 --> 14:29.910
你给我一个文字

14:29.910 --> 14:31.510
text

14:31.510 --> 14:34.110
character

14:34.110 --> 14:36.710
你给我这个文字

14:36.710 --> 14:37.410
我呢

14:37.410 --> 14:38.610
能够判断这个

14:38.610 --> 14:39.610
这个制服串

14:39.610 --> 14:42.610
判断制服串

14:42.610 --> 14:45.910
判断制服串

14:45.910 --> 14:48.810
是32位

14:48.810 --> 14:50.310
还是16位

14:50.310 --> 14:51.510
是不是可以判断了

14:51.910 --> 14:52.810
可以判断了

14:52.810 --> 14:53.510
那么如果说

14:53.510 --> 14:54.310
我们这里判断的话

14:54.310 --> 14:55.110
怎么写呢

14:55.110 --> 14:56.610
是不是就可以利用这个函数

14:56.610 --> 14:58.710
codepointat0

14:58.710 --> 14:59.410
对吧

14:59.410 --> 15:00.710
是不是得到它的

15:00.710 --> 15:01.810
第一个马源

15:01.810 --> 15:03.210
它得到了马点

15:03.210 --> 15:06.310
看这个马点是不是大于多少

15:06.310 --> 15:08.610
大于16进制的

15:08.610 --> 15:08.910
对吧

15:08.910 --> 15:10.010
是大于什么

15:10.010 --> 15:11.810
16进制的最大值

15:11.810 --> 15:13.010
16进的最大值是多少

15:13.010 --> 15:15.310
你可以直接这样写

15:15.310 --> 15:16.810
这不是16进制开头吗

15:16.810 --> 15:17.510
对不对

15:17.510 --> 15:19.910
那么FFFF

15:19.910 --> 15:20.710
是不是4个F

15:20.710 --> 15:22.710
4个F是不是16进制的

15:22.710 --> 15:24.010
4个16进制

15:24.010 --> 15:26.010
就是16位的2进制的最大值

15:26.010 --> 15:26.710
对吧

15:26.710 --> 15:27.910
如果说它大于了

15:27.910 --> 15:28.710
这个最大值

15:28.710 --> 15:30.210
是不是它是一个啥

15:30.210 --> 15:31.510
它是一个32位的

15:31.510 --> 15:33.010
它超出了16位了

15:33.010 --> 15:33.510
对吧

15:33.510 --> 15:35.210
是不是这个马点超出了16位

15:35.210 --> 15:36.410
是不是32位的

15:36.410 --> 15:37.510
对不对

15:37.510 --> 15:38.510
如果大于了

15:38.510 --> 15:39.710
那我们这里写一下吧

15:39.710 --> 15:40.410
大概都是

15:40.410 --> 15:42.710
如果马点

15:42.710 --> 15:47.110
大于了16位2进制的最大值

15:47.110 --> 15:48.510
就是2进制的16位

15:48.510 --> 15:49.710
都已经装不下它了

15:49.710 --> 15:51.310
它的马点已经超出了这个值了

15:51.310 --> 15:54.910
则其是32位的

15:54.910 --> 15:55.210
对吧

15:55.210 --> 15:57.010
我们是不是可以用这种方式来判断了

15:57.010 --> 15:58.210
判断一个文字

15:58.210 --> 15:59.410
是不是

15:59.410 --> 16:02.910
是不是这个就是32位的

16:02.910 --> 16:06.960
比方说我们来输出一下

16:06.960 --> 16:08.260
输出一下

16:08.260 --> 16:09.760
这个东西

16:13.260 --> 16:13.760
这个吧

16:13.760 --> 16:16.660
1是32 bit

16:16.660 --> 16:18.360
把它放进去

16:18.360 --> 16:24.160
那么前面写上

16:26.460 --> 16:31.660
是否是32位的

16:31.660 --> 16:32.060
好

16:32.060 --> 16:34.260
看一下吧

16:34.260 --> 16:35.060
保存

16:35.060 --> 16:35.760
你看一下

16:35.760 --> 16:36.360
是不是32位的

16:36.360 --> 16:37.360
是true对吧

16:37.360 --> 16:37.960
是true

16:37.960 --> 16:39.060
那么我们再利用这个函数

16:39.060 --> 16:39.860
再看一下

16:39.860 --> 16:41.560
32 bit

16:41.560 --> 16:43.860
那么这里随便写一个A数字A

16:43.860 --> 16:44.560
是不是force

16:44.560 --> 16:44.860
对吧

16:44.860 --> 16:45.760
它不是32位的

16:45.760 --> 16:46.660
它是16位的

16:46.660 --> 16:47.060
对不对

16:47.060 --> 16:48.660
我们是不是可以写出这么一个函数

16:48.660 --> 16:50.260
有了这么一个函数支持过后

16:50.260 --> 16:51.860
我们可以自行写函数

16:51.860 --> 16:53.160
来得到一个字无串

16:53.160 --> 16:55.760
按照马点的计算方式

16:55.860 --> 16:56.960
它的真实长度

17:00.170 --> 17:07.170
方式就是get length of code point

17:07.870 --> 17:08.870
得到一个字无串

17:08.870 --> 17:10.470
马点的真实长度

17:10.970 --> 17:11.670
str

17:17.390 --> 17:19.190
得到一个字无串

17:19.190 --> 17:22.490
马点的真实长度

17:22.490 --> 17:24.390
就是有它有多少个马点

17:24.390 --> 17:25.290
我不管马源了

17:25.290 --> 17:26.590
我按马点来算

17:26.590 --> 17:27.190
对吧

17:27.190 --> 17:28.190
按马点来算

17:28.190 --> 17:29.190
看它的真实长度

17:29.190 --> 17:29.490
来吧

17:29.590 --> 17:31.090
我们怎么来写

17:31.090 --> 17:32.490
我们这样子写

17:32.490 --> 17:33.990
循环这个字无串

17:33.990 --> 17:35.690
我现在用那个什么

17:35.690 --> 17:38.290
用那个就是内彩方式来循环了

17:38.290 --> 17:39.490
循环这个字无串

17:39.490 --> 17:40.590
那这里循环的是啥

17:40.590 --> 17:41.990
是不是循环的马源

17:41.990 --> 17:45.590
拿到每一个马源

17:45.590 --> 17:45.890
对不对

17:45.890 --> 17:46.890
是不是拿到每一个马源

17:46.890 --> 17:49.090
这个i是不是在锁印马源

17:49.090 --> 17:53.590
i在锁印马源

17:53.590 --> 17:53.890
对不对

17:53.890 --> 17:55.390
是在锁印马源

17:55.390 --> 17:56.990
那么我们通过

17:56.990 --> 17:58.790
i它既然在锁印马源

17:58.890 --> 18:00.590
我们是不是可以利用这个

18:00.590 --> 18:02.590
就是Chocodate对吧

18:02.590 --> 18:03.590
Chocodate

18:03.590 --> 18:05.190
我们判断一下

18:05.190 --> 18:06.490
它是这个马源

18:06.490 --> 18:11.190
它是不是32位的

18:11.190 --> 18:12.590
它是不是32位的

18:12.590 --> 18:14.090
那么我们也可以利用这个东西

18:14.090 --> 18:15.990
Chocodate来判断

18:15.990 --> 18:16.590
来判断

18:17.890 --> 18:18.990
怎么判断呢

18:18.990 --> 18:19.990
我想想啊

18:19.990 --> 18:20.890
怎么判断呢

18:20.890 --> 18:22.590
你给我的

18:22.590 --> 18:24.090
要不然再给我个下标嘛

18:24.090 --> 18:24.990
给我个下标

18:24.990 --> 18:26.190
i等于你

18:26.190 --> 18:27.790
我们这里取i

18:28.790 --> 18:29.690
我们看一下

18:29.690 --> 18:32.890
你给我取的这个方法莫认之一

18:32.890 --> 18:34.290
大家还没有学过是吧

18:34.290 --> 18:36.590
那我们这里32位的

18:36.590 --> 18:38.090
我们从零开始

18:38.090 --> 18:38.890
我们这个要传进去

18:38.890 --> 18:39.990
这个i表什么意思呢

18:39.990 --> 18:41.790
表示指定的下标位置

18:41.790 --> 18:43.190
指定的马源位置

18:43.190 --> 18:44.990
它是不是32位的

18:44.990 --> 18:46.190
没啥意思吗

18:46.190 --> 18:47.290
比方说这个制服串

18:47.290 --> 18:48.990
我看从零这个制服位置

18:48.990 --> 18:50.290
从零这个马源位置

18:50.290 --> 18:51.390
它是不是32位的

18:51.390 --> 18:52.590
那么我们刚才看到了

18:52.590 --> 18:53.490
从零这个马源位置

18:53.490 --> 18:54.890
因为它占两个马源

18:54.890 --> 18:56.490
所以它是32位的

18:56.590 --> 18:57.490
好 那么这里呢

18:57.490 --> 18:58.790
i在索引马源

18:58.790 --> 19:00.090
好好看 阅读一下啊

19:00.090 --> 19:01.090
在索引马源

19:01.090 --> 19:01.890
那么我们这里呢

19:01.890 --> 19:02.790
判断一下

19:02.790 --> 19:05.690
意思32 bit

19:05.690 --> 19:07.090
如果说

19:07.090 --> 19:09.590
你的当前这个制服串

19:09.590 --> 19:11.090
在这个位置

19:11.090 --> 19:13.890
是你占用两个马源

19:13.890 --> 19:15.290
当前制服串

19:15.290 --> 19:17.890
在i这个位置

19:17.890 --> 19:20.790
占用了两个马源

19:20.790 --> 19:22.190
是不是占用了两个马源

19:22.190 --> 19:23.490
那么下一次循环

19:23.490 --> 19:24.690
是不是不进行了

19:24.690 --> 19:25.090
对吧

19:25.090 --> 19:26.790
下一次循环我们是不进行了

19:26.790 --> 19:28.290
那么我们直接挨一挨挨

19:28.290 --> 19:28.790
然后呢

19:28.790 --> 19:30.890
我们在这里进行一下统计

19:30.890 --> 19:33.090
从零开始

19:33.090 --> 19:34.290
从零开始

19:34.290 --> 19:35.590
来进行统计

19:35.590 --> 19:38.090
如果说每一次

19:38.090 --> 19:39.990
每一次我们内加加

19:39.990 --> 19:41.490
来 我们来阅读一下这个代码

19:41.490 --> 19:43.590
最后我们返回这个内

19:43.590 --> 19:44.790
阅读一下这个代码

19:44.790 --> 19:46.390
我们来统计这个制服串长度

19:46.390 --> 19:46.890
一开始呢

19:46.890 --> 19:47.890
把它设定为0

19:47.890 --> 19:48.890
然后循环制服串

19:48.890 --> 19:50.290
一个马源一个马源拿出来看

19:50.290 --> 19:51.190
因为它是循环的

19:51.190 --> 19:52.090
一定是马源

19:52.090 --> 19:52.690
这个内是呢

19:52.690 --> 19:54.190
读的是马源的数量

19:54.190 --> 19:56.090
好 那么我们看这个位置的马源

19:56.090 --> 19:57.590
是不是32位呢

19:57.590 --> 19:59.190
如果说32位的话

19:59.190 --> 20:01.290
我下一个位置就不看了

20:01.290 --> 20:02.190
也就是说我这个嫩了

20:02.190 --> 20:03.490
是不是少加一次

20:03.490 --> 20:04.090
对吧

20:04.090 --> 20:04.990
我挨加加

20:04.990 --> 20:06.490
是不是把下一个位置就不看了

20:06.490 --> 20:07.290
对吧

20:07.290 --> 20:07.790
你看吧

20:07.790 --> 20:08.590
我们比方说

20:10.390 --> 20:14.040
比方说这个文字啊

20:14.040 --> 20:16.140
比方说这个A B

20:16.140 --> 20:17.640
这个文字A A A

20:17.640 --> 20:18.840
比方说这个制服串啊

20:18.840 --> 20:21.040
这个制服串长度是多少

20:21.040 --> 20:23.640
来 说长度是多少

20:23.640 --> 20:26.040
一个 两个 三个 四个

20:26.040 --> 20:27.040
五个 六个

20:27.040 --> 20:28.140
是不是长度为6

20:28.140 --> 20:29.940
好 第一次循环看它

20:29.940 --> 20:30.940
那么我们内

20:30.940 --> 20:32.540
内开始是0对吧

20:32.540 --> 20:33.740
我们一开始看它

20:33.740 --> 20:35.440
它是不是占32位的

20:35.440 --> 20:36.440
不是对吧

20:36.440 --> 20:37.840
不是是不是进不了判断

20:37.840 --> 20:39.340
这里的判断是不是进不去

20:39.340 --> 20:40.840
进不去是不是嫩加1

20:40.840 --> 20:41.240
对吧

20:41.240 --> 20:42.140
没问题吧

20:42.140 --> 20:43.940
好 下一个

20:43.940 --> 20:45.540
好 下一个

20:45.540 --> 20:46.840
那么下一个A等于1了

20:46.840 --> 20:47.740
对吧

20:47.740 --> 20:48.940
A是不是等于1了

20:48.940 --> 20:49.840
取它这个

20:49.840 --> 20:50.840
这个是不是32位的

20:50.840 --> 20:51.340
也不是

20:51.340 --> 20:52.040
也不是的话

20:52.040 --> 20:53.840
你看判断进不去

20:53.840 --> 20:54.740
变成2

20:54.740 --> 20:55.540
这个没问题吧

20:56.040 --> 20:56.540
然后呢

20:56.540 --> 20:57.540
我们再看这一个

20:57.540 --> 20:59.140
A等于2了

20:59.140 --> 21:01.140
下一只循环A加加A等于2

21:01.140 --> 21:02.340
A等于2的看这一个

21:02.340 --> 21:03.740
这个是不是32位的

21:03.740 --> 21:04.940
它是一个32位的

21:04.940 --> 21:05.440
看没

21:05.440 --> 21:06.940
那么我们通过这个函数

21:06.940 --> 21:09.040
让它在制服串里边指定位置

21:09.040 --> 21:09.840
看这个位置

21:09.840 --> 21:11.840
是不是32位的

21:11.840 --> 21:13.840
那么看到了它是一个32位的

21:13.840 --> 21:15.640
32位的话怎么办

21:15.640 --> 21:17.440
A加加

21:17.440 --> 21:18.540
变成3

21:18.540 --> 21:19.240
然后呢

21:19.240 --> 21:20.240
嫩加加

21:20.240 --> 21:22.140
它要算只算一个嘛

21:22.140 --> 21:22.740
变成3

21:22.740 --> 21:24.340
由于我这里进行的A加加

21:24.340 --> 21:25.040
那么下一只循环

21:25.040 --> 21:26.240
是不是又要进行A加加

21:26.240 --> 21:27.140
是不是加两次

21:27.140 --> 21:28.240
因为挑过了一次

21:28.240 --> 21:28.740
看到没

21:28.740 --> 21:30.240
那就变成4了

21:30.240 --> 21:31.040
变成4

21:31.040 --> 21:31.740
变成多少了

21:31.740 --> 21:32.440
0

21:32.440 --> 21:33.240
1

21:33.240 --> 21:33.440
2

21:33.440 --> 21:34.140
3

21:34.140 --> 21:34.440
4

21:34.440 --> 21:35.240
是不是看它了

21:35.240 --> 21:35.640
对吧

21:35.640 --> 21:36.040
看它了

21:36.040 --> 21:37.240
然后它加1

21:37.240 --> 21:38.240
4

21:38.240 --> 21:39.540
然后它加1

21:39.540 --> 21:40.140
5

21:40.140 --> 21:40.540
对吧

21:40.540 --> 21:41.640
然后结束循环

21:41.640 --> 21:42.840
是不是长度为5

21:42.840 --> 21:43.440
就是我

21:43.440 --> 21:44.440
我这里A加加的目的

21:44.440 --> 21:45.940
就是为了挑过下一个

21:45.940 --> 21:47.140
挑过下一个

21:47.140 --> 21:47.440
好

21:47.440 --> 21:48.140
保存啊

21:48.140 --> 21:49.440
我们有了这么一个就是

21:49.440 --> 21:50.040
函数过后了

21:50.040 --> 21:51.140
我们就可以得到

21:51.140 --> 21:52.640
制服串的真实长度了

21:52.640 --> 21:53.140
比方说

21:53.140 --> 21:54.440
我们这里呢

21:54.440 --> 21:55.840
就这个

21:55.840 --> 21:57.040
就这个制服串吧

21:57.040 --> 21:57.440
啊

21:59.240 --> 21:59.940
啊

21:59.940 --> 22:01.740
的马点

22:01.740 --> 22:03.040
长度

22:03.040 --> 22:04.240
嗯

22:04.240 --> 22:05.840
长度

22:05.840 --> 22:06.240
好

22:06.240 --> 22:08.540
那么我们这里使用这个函数

22:08.540 --> 22:12.140
get length of code point

22:12.140 --> 22:13.140
那么这里就是吧

22:13.140 --> 22:14.440
复制过来啊

22:14.440 --> 22:16.640
看一下这个制服串的马点的长度

22:16.640 --> 22:16.940
好

22:16.940 --> 22:17.440
保存啊

22:17.440 --> 22:18.540
我们看一下

22:18.540 --> 22:19.540
是不是得到5了

22:19.540 --> 22:19.740
对吧

22:19.740 --> 22:20.440
这个东西呢

22:20.440 --> 22:22.240
我们可以自行封装

22:22.240 --> 22:23.040
你看这意思吧

22:23.040 --> 22:25.040
这是一个非常非常细微的知识啊

22:25.040 --> 22:26.640
一般情况下你们都遇不到的

22:26.640 --> 22:27.640
一般情况下都遇不到

22:27.640 --> 22:28.040
只是呢

22:28.040 --> 22:28.640
有的时候呢

22:28.640 --> 22:30.740
遇到这个很关键的现象了

22:30.740 --> 22:32.340
你如果不知道这个知识的话

22:32.340 --> 22:33.840
你是很难解决的

22:33.840 --> 22:34.240
好吧

22:34.240 --> 22:35.340
这是关于这一块

22:35.340 --> 22:35.940
另外呢

22:35.940 --> 22:37.540
关于郑哲表达是这一块呢

22:37.540 --> 22:39.140
他也是给你提供了处理的啊

22:39.140 --> 22:40.640
你看郑哲表达是测试通不过

22:40.640 --> 22:41.240
这个很简单

22:41.240 --> 22:42.740
他给你做了这么一个处理

22:42.740 --> 22:43.140
啊

22:43.140 --> 22:43.640
同时

22:45.540 --> 22:46.240
es6

22:47.940 --> 22:49.940
为郑哲啊

22:50.040 --> 22:50.640
郑哲

22:53.320 --> 22:55.620
为郑哲表达是

22:56.020 --> 22:58.720
添加了一个flag

22:58.720 --> 22:58.920
对吧

22:58.920 --> 23:00.920
我们知道郑哲表达是里面是可以添加flag的

23:00.920 --> 23:02.020
比方说全局匹配啊

23:02.020 --> 23:02.620
在这里对吧

23:02.620 --> 23:03.820
写个g对不对

23:03.820 --> 23:05.420
那么这个添加的一个flag什么

23:05.420 --> 23:06.520
这个什么flag呢

23:06.520 --> 23:07.920
就是u啊

23:08.620 --> 23:12.020
如果添加了该配置

23:12.620 --> 23:16.720
则匹配时使用马点匹配

23:17.720 --> 23:19.720
而不是使用马原来匹配了啊

23:19.720 --> 23:21.120
这个以前匹配的是马原

23:21.120 --> 23:22.420
那么强强那个u过后呢

23:22.420 --> 23:23.920
匹配的是马点啊

23:23.920 --> 23:24.820
匹配的是马点

23:24.820 --> 23:25.620
那么马点的话

23:25.620 --> 23:26.820
是不是只有一个字符

23:26.820 --> 23:27.620
对吧

23:27.620 --> 23:28.320
就有一个字符

23:28.320 --> 23:29.620
那么匹配就通过了

23:29.620 --> 23:31.220
就这么简单啊

23:31.220 --> 23:33.220
那么就讲这两个东西

23:33.220 --> 23:34.520
就已经可以解决

23:34.520 --> 23:36.720
本身这个问题遇到的场景呢

23:36.720 --> 23:37.720
就非常非常少

23:37.720 --> 23:39.320
讲了这两个东西过后呢

23:39.320 --> 23:41.920
基本上就涵盖了这个出现这个问题的

23:42.820 --> 23:43.620
解决办法了啊

23:43.620 --> 23:44.720
就涵盖完了

23:44.720 --> 23:44.920
好吧

23:44.920 --> 23:47.720
我就讲一讲这个Ulicode的支持啊

23:47.720 --> 23:49.020
那么他提供了一个方法

23:49.020 --> 23:50.520
一个郑哲表达式的u啊

23:50.520 --> 23:51.520
够了

23:51.520 --> 23:51.820
好吧

23:51.820 --> 23:52.820
这是关于这一块啊

