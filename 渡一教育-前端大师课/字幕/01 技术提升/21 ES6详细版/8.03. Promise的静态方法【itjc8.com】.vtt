WEBVTT

00:00.880 --> 00:09.880
我上课的时候举的那个登革的例子都是开玩笑

00:09.880 --> 00:15.880
都是为这个把这个知识给大家讲得透彻一点 讲得有趣一点

00:15.880 --> 00:17.880
这并不代表它是真的啊

00:17.880 --> 00:20.880
因为我这课呢还是要给大家说清楚

00:20.880 --> 00:24.880
也并不代表我的价值观

00:24.880 --> 00:26.880
反正就是举例子 下举例子

00:26.880 --> 00:27.880
大家声明清楚

00:27.880 --> 00:29.880
别拿这个来说事

00:31.880 --> 00:33.880
声明清楚了 我们就可以接着来登革了

00:33.880 --> 00:35.880
登革是个连续剧

00:35.880 --> 00:37.880
他又遇到新闻的问题了

00:37.880 --> 00:39.880
之前表白呢 可能成功了

00:39.880 --> 00:41.880
已经开始在一起过日子了

00:41.880 --> 00:43.880
这个时候呢 登少出门

00:43.880 --> 00:45.880
他给登革交代了几个任务

00:45.880 --> 00:47.880
今天让你把饭就做了

00:47.880 --> 00:48.880
衣服洗了

00:48.880 --> 00:50.880
然后呢 卫生给他打烧了

00:50.880 --> 00:52.880
就这么三件事

00:52.880 --> 00:53.880
那么这三件事呢

00:53.880 --> 00:55.880
不需要登革亲自去做

00:55.880 --> 00:56.880
但是你要去操作一下

00:56.880 --> 00:57.880
比方说你做饭的时候

00:57.880 --> 00:59.880
谁还亲自做饭啊

00:59.880 --> 01:00.880
都交给电饭宝对吧

01:00.880 --> 01:02.880
洗衣服呢是交给洗衣机

01:02.880 --> 01:04.880
打烧卫生的交给扫地契轮

01:05.880 --> 01:07.880
但是你要去操作对不对

01:07.880 --> 01:09.880
而且呢他去完成这些事呢

01:09.880 --> 01:11.880
需要一段时间

01:12.880 --> 01:14.880
登少呢他就要求啊

01:14.880 --> 01:16.880
你把这些事做了

01:16.880 --> 01:17.880
全部成了呢

01:17.880 --> 01:19.880
你给我汇报一下啊

01:19.880 --> 01:21.880
都成了 没问题了

01:21.880 --> 01:22.880
如果说有失败了

01:22.880 --> 01:24.880
你要给我汇报一下

01:24.880 --> 01:25.880
到底怎么回事

01:25.880 --> 01:26.880
你为什么干不成

01:26.880 --> 01:28.880
对吧 回来要不要汇键盘

01:28.880 --> 01:30.880
这些事情呢要汇报一下

01:31.880 --> 01:33.880
那么登革在做这个事的时候呢

01:33.880 --> 01:35.880
他就有两种选择

01:36.880 --> 01:38.880
第一种呢就像以前表白的样子

01:38.880 --> 01:40.880
前面那件事完了之后

01:40.880 --> 01:42.880
我再去做后面的那件事

01:43.880 --> 01:45.880
那么在这个例子里边

01:45.880 --> 01:46.880
显然不合适

01:47.880 --> 01:48.880
然后你开做电饭

01:48.880 --> 01:49.880
就是做饭的时候

01:49.880 --> 01:50.880
你把电饭帽打开

01:50.880 --> 01:52.880
他要做一个小时

01:52.880 --> 01:54.880
你就在那里等一个小时啊

01:54.880 --> 01:55.880
没必要吧

01:55.880 --> 01:56.880
对吧 让他去做

01:56.880 --> 01:59.880
然后呢你就自己去做别的事

01:59.880 --> 02:01.880
比方说打开洗衣机

02:01.880 --> 02:02.880
把衣服扔进去

02:02.880 --> 02:04.880
然后呢他打开扫地机去了

02:04.880 --> 02:06.880
让他去干活

02:06.880 --> 02:08.880
最后呢在收结果我就完事了

02:08.880 --> 02:10.880
因此在这一次

02:10.880 --> 02:12.880
跟之前的表白那个场景

02:12.880 --> 02:13.880
不一样吗

02:13.880 --> 02:14.880
这一次呢

02:14.880 --> 02:16.880
登革了他决定

02:16.880 --> 02:18.880
为了最大程度的节约时间

02:18.880 --> 02:20.880
他把这些任务呢同时进行

02:20.880 --> 02:22.880
最终的把结果汇总

02:22.880 --> 02:24.880
比方说你做饭

02:24.880 --> 02:26.880
按了过后你就不管了

02:26.880 --> 02:28.880
洗衣机衣服扔进去

02:28.880 --> 02:29.880
不管了扫地机了

02:29.880 --> 02:31.880
打开之后不管了

02:31.880 --> 02:33.880
让这些他们自己去做

02:33.880 --> 02:34.880
做完了之后呢

02:34.880 --> 02:36.880
他总会有个回馈嘛

02:36.880 --> 02:38.880
不要说他做了一个小时成功了

02:38.880 --> 02:39.880
他做了一个半小时失败了

02:39.880 --> 02:41.880
他做了两个小时成功了

02:41.880 --> 02:43.880
那么所有的任务加起来

02:43.880 --> 02:45.880
也就是两个小时

02:45.880 --> 02:46.880
懂的意思吧

02:46.880 --> 02:47.880
同时进行

02:48.880 --> 02:49.880
完事之后呢

02:49.880 --> 02:51.880
我们把最终的结果来汇总

02:51.880 --> 02:53.880
两个小时过后都完了

02:53.880 --> 02:54.880
对吧

02:54.880 --> 02:56.880
那你第一个成功了

02:56.880 --> 02:57.880
第二个失败了

02:57.880 --> 02:58.880
第三个成功了

02:58.880 --> 02:59.880
那么这样子呢

02:59.880 --> 03:01.880
就把它做一个汇总消息

03:01.880 --> 03:03.880
其实这个汇总

03:03.880 --> 03:06.880
也可以把它看成是一个任务

03:06.880 --> 03:07.880
对吧

03:07.880 --> 03:09.880
他要等其他的任务

03:09.880 --> 03:10.880
都完成之后

03:10.880 --> 03:12.880
那么这个任务才能完成

03:12.880 --> 03:14.880
这就是汇总

03:14.880 --> 03:16.880
从大一把的场面来表示的话

03:16.880 --> 03:18.880
下面有一段伟代嘛

03:18.880 --> 03:19.880
比方说这里写了三个函数

03:19.880 --> 03:20.880
一个是cook

03:20.880 --> 03:22.880
做饭

03:22.880 --> 03:23.880
你仔细看一下吧

03:23.880 --> 03:24.880
这个函数也没什么复杂的

03:24.880 --> 03:25.880
把回一个promise

03:25.880 --> 03:26.880
对吧

03:26.880 --> 03:27.880
一个任务

03:27.880 --> 03:29.880
然后等了两秒钟之后

03:29.880 --> 03:30.880
有可能翻译ok

03:30.880 --> 03:33.880
有可能的失败

03:33.880 --> 03:34.880
洗衣服一样的

03:34.880 --> 03:36.880
等了

03:36.880 --> 03:37.880
2点5秒

03:37.880 --> 03:38.880
有可能成功

03:38.880 --> 03:40.880
有可能失败

03:40.880 --> 03:42.880
打烧卫生一样的

03:42.880 --> 03:43.880
等了

03:43.880 --> 03:44.880
我这里多等一会吧

03:44.880 --> 03:46.880
等了3秒钟

03:46.880 --> 03:48.880
那么他有可能成功

03:48.880 --> 03:50.880
有可能失败

03:50.880 --> 03:51.880
我就写了这么三个函数

03:51.880 --> 03:53.880
那么接下来的要求是

03:53.880 --> 03:57.880
你如何利用这三个函数

03:57.880 --> 04:00.880
让这些任务同时进行

04:00.880 --> 04:02.880
然后最终呢

04:02.880 --> 04:05.880
又可以汇总成一个结果

04:05.880 --> 04:06.880
其实同时运行

04:06.880 --> 04:07.880
他并不难

04:07.880 --> 04:08.880
我们来看一下

04:08.880 --> 04:09.880
同时运行

04:09.880 --> 04:10.880
这些任务他并不难

04:10.880 --> 04:12.880
我们来写个介绍

04:12.880 --> 04:14.880
把这三个函数扔进来

04:14.880 --> 04:16.880
我这里把他择定一下

04:16.880 --> 04:17.880
不用去看他怎么去实现的

04:17.880 --> 04:19.880
总之三个函数就是三个任务

04:19.880 --> 04:21.880
那同时运行非常简单

04:21.880 --> 04:22.880
第一个函数调用他

04:22.880 --> 04:24.880
第二个函数调用他

04:24.880 --> 04:26.880
不就同时进行了吗

04:26.880 --> 04:28.880
我又没有说

04:28.880 --> 04:30.880
第一个函数的后续处理中

04:30.880 --> 04:31.880
去调用下一个

04:31.880 --> 04:33.880
输入

04:33.880 --> 04:35.880
不就同时进行了吗

04:35.880 --> 04:36.880
运行你看

04:36.880 --> 04:38.880
就同时进行了

04:38.880 --> 04:40.880
有些失败了

04:40.880 --> 04:41.880
有些成功了

04:41.880 --> 04:42.880
对不对

04:42.880 --> 04:43.880
这不是同心

04:43.880 --> 04:44.880
那如果说要穿行怎么办

04:44.880 --> 04:45.880
就让你之前表白

04:45.880 --> 04:46.880
上一个结束之后

04:46.880 --> 04:47.880
再运行下一个

04:47.880 --> 04:48.880
大概怎么写

04:48.880 --> 04:49.880
比方先做完

04:49.880 --> 04:51.880
做完完了过后

04:51.880 --> 04:54.880
后续处理呢

04:54.880 --> 04:56.880
我再去什么洗衣服

04:56.880 --> 04:57.880
对吧

04:57.880 --> 04:59.880
后续处理我调用卧型

04:59.880 --> 05:00.880
这样子有些同学看不懂了

05:00.880 --> 05:03.880
这样子就能看懂了

05:03.880 --> 05:04.880
那返回吗

05:04.880 --> 05:05.880
那函数是不是返回

05:05.880 --> 05:08.880
可以直接这样子写

05:08.880 --> 05:09.880
对吧

05:09.880 --> 05:10.880
你做完做成功了

05:10.880 --> 05:12.880
然后我就去洗衣服返回个Promise

05:12.880 --> 05:13.880
好

05:13.880 --> 05:15.880
如果我洗衣服写完了之后

05:15.880 --> 05:17.880
我再去打扫卫生

05:17.880 --> 05:18.880
对吧

05:18.880 --> 05:20.880
这不就是穿行吗

05:20.880 --> 05:22.880
就是穿行

05:22.880 --> 05:23.880
你看

05:23.880 --> 05:24.880
先做饭

05:24.880 --> 05:26.880
做饭完了过后再洗衣服

05:26.880 --> 05:28.880
洗衣服完了之后呢

05:28.880 --> 05:30.880
再打开扫地机去哪

05:30.880 --> 05:32.880
扫地机去哪

05:32.880 --> 05:34.880
失败了

05:34.880 --> 05:35.880
这就是穿行

05:35.880 --> 05:36.880
同时进行的就非常简单

05:36.880 --> 05:37.880
我不用再后续处理

05:37.880 --> 05:38.880
处理

05:38.880 --> 05:39.880
我直接就调用

05:39.880 --> 05:40.880
先去做饭

05:40.880 --> 05:41.880
再去洗衣服

05:41.880 --> 05:43.880
再直接打扫卫生

05:43.880 --> 05:45.880
那至于做饭的后续处理

05:45.880 --> 05:46.880
我这里没管

05:46.880 --> 05:48.880
洗衣服的后续处理我这里没管

05:48.880 --> 05:50.880
打扫卫生的后续处理我没管

05:50.880 --> 05:53.880
这样子符合要求吗

05:53.880 --> 05:54.880
这样子呢

05:54.880 --> 05:57.880
倒是可以让他们同时进行

05:57.880 --> 05:59.880
但是我怎么汇总呢

05:59.880 --> 06:00.880
问题是

06:00.880 --> 06:02.880
我在哪里写汇总代码呢

06:02.880 --> 06:04.880
请问你你帮我写一下

06:04.880 --> 06:06.880
我在哪里写汇总代码

06:06.880 --> 06:08.880
你说在这里写

06:08.880 --> 06:09.880
这里写你咋写

06:09.880 --> 06:10.880
你怎么知道

06:10.880 --> 06:12.880
这个时候你怎么知道他成功呢

06:12.880 --> 06:13.880
他什么时候成功

06:13.880 --> 06:14.880
他什么时候成功

06:14.880 --> 06:15.880
他什么时候成功

06:15.880 --> 06:16.880
哪个成功时候失败

06:16.880 --> 06:17.880
所以都不知道

06:17.880 --> 06:21.880
那你说我在这里写可以吗

06:21.880 --> 06:23.880
我在这里写的话

06:23.880 --> 06:24.880
我只能说

06:24.880 --> 06:27.880
我知道做饭成功了

06:27.880 --> 06:29.880
做饭失败了

06:29.880 --> 06:30.880
但是其他任务呢

06:30.880 --> 06:31.880
成功还是失败

06:31.880 --> 06:32.880
我也不清楚了

06:32.880 --> 06:33.880
对吧

06:33.880 --> 06:34.880
所以这个代码的

06:34.880 --> 06:35.880
就造成了一些麻烦

06:35.880 --> 06:37.880
那么这些麻烦怎么解决呢

06:37.880 --> 06:38.880
就咱们这些课学的知识

06:38.880 --> 06:39.880
叫静态方法

06:39.880 --> 06:40.880
静态方法呢

06:40.880 --> 06:42.880
这一块知识特别简单

06:42.880 --> 06:44.880
前面的东西理解过后了

06:44.880 --> 06:46.880
这个静态方法就是其实很轻松的

06:46.880 --> 06:47.880
就是Promise

06:47.880 --> 06:48.880
它是个构造函数

06:48.880 --> 06:50.880
它给我们提供了一些静态方法

06:50.880 --> 06:51.880
什么叫静态方法

06:51.880 --> 06:52.880
就通过Promise函数

06:52.880 --> 06:54.880
可以直接调用的方法叫静态方法

06:54.880 --> 06:55.880
我们之前也讲过

06:55.880 --> 06:56.880
对吧

06:56.880 --> 06:57.880
这就是个静态方法

06:57.880 --> 06:59.880
那么他有哪些静态方法呢

06:59.880 --> 07:00.880
给大家看一下

07:00.880 --> 07:01.880
第一个静态方法

07:01.880 --> 07:03.880
表示的是

07:03.880 --> 07:05.880
直接返回一个完成状态的任务

07:05.880 --> 07:06.880
啥

07:06.880 --> 07:07.880
意思呢

07:07.880 --> 07:08.880
我给大家看

07:08.880 --> 07:09.880
先看一个解释

07:09.880 --> 07:10.880
就是说

07:10.880 --> 07:11.880
这个Promise

07:11.880 --> 07:12.880
你调用这个Result

07:12.880 --> 07:14.880
里边随便写个数据

07:14.880 --> 07:15.880
任务完成之后

07:15.880 --> 07:16.880
不是有个数据吗

07:16.880 --> 07:17.880
你直接写个数据

07:17.880 --> 07:19.880
他就会返回一个任务

07:19.880 --> 07:20.880
这个任务呢

07:20.880 --> 07:22.880
他就直接就是完成状态

07:22.880 --> 07:24.880
就这么简单

07:24.880 --> 07:26.880
这种写法就相当于是

07:26.880 --> 07:27.880
去砸写的呢

07:27.880 --> 07:28.880
就相当于是

07:28.880 --> 07:29.880
你这样子写的

07:29.880 --> 07:30.880
你有一个Promise

07:30.880 --> 07:34.880
然后呢

07:34.880 --> 07:35.880
然后呢

07:35.880 --> 07:36.880
调用他的Result

07:39.880 --> 07:40.880
就这么简单

07:40.880 --> 07:42.880
就相当于是这句话

07:42.880 --> 07:43.880
其实这个函数

07:43.880 --> 07:44.880
还本来实现的方式

07:44.880 --> 07:45.880
就是这样子实现的

07:45.880 --> 07:46.880
所以说呢

07:46.880 --> 07:47.880
没什么好说的

07:47.880 --> 07:48.880
对吧

07:48.880 --> 07:49.880
他就给你提供

07:49.880 --> 07:50.880
这样子写的方便一点

07:50.880 --> 07:52.880
他说这个方法有啥用呢

07:52.880 --> 07:53.880
其实这个方法

07:53.880 --> 07:54.880
对我们平时开发来说

07:54.880 --> 07:55.880
没什么用

07:55.880 --> 07:57.880
有的时候就做一些测试

07:57.880 --> 07:58.880
或者更加

07:58.880 --> 07:59.880
更多的是出现在

07:59.880 --> 08:00.880
面试题里边

08:00.880 --> 08:01.880
以后呢

08:01.880 --> 08:03.880
你们学到一些框架

08:03.880 --> 08:04.880
如果说

08:04.880 --> 08:05.880
就像是深入的

08:05.880 --> 08:06.880
去理解一些框架的原码的话

08:06.880 --> 08:07.880
有些框架

08:07.880 --> 08:08.880
第三方库

08:08.880 --> 08:10.880
他们的原码里边有用的

08:10.880 --> 08:11.880
我这里呢

08:11.880 --> 08:12.880
不去详细展开了

08:12.880 --> 08:13.880
总之跟你们

08:13.880 --> 08:15.880
平时写的按码关系不大的

08:15.880 --> 08:17.880
要不然你成为一个

08:17.880 --> 08:20.880
资深的前段开发工程师的话

08:20.880 --> 08:21.880
可能跟你

08:21.880 --> 08:23.880
关系就比较多了

08:23.880 --> 08:24.880
在现在的关系里面

08:24.880 --> 08:25.880
没什么关系

08:26.880 --> 08:27.880
就是这么一个东西

08:27.880 --> 08:29.880
然后呢

08:29.880 --> 08:30.880
这个方法就相反

08:30.880 --> 08:31.880
它反而回到

08:31.880 --> 08:32.880
是一个拒绝状态的任务

08:32.880 --> 08:34.880
就是失败状态的任务

08:34.880 --> 08:35.880
那么就比方说

08:35.880 --> 08:37.880
这里写个reject

08:37.880 --> 08:38.880
里边写个

08:38.880 --> 08:40.880
里面就是失败的原因

08:40.880 --> 08:42.880
它就会反回一个promise

08:42.880 --> 08:43.880
它是

08:43.880 --> 08:45.880
它直接就是拒绝状态

08:45.880 --> 08:46.880
然后的原因就是

08:46.880 --> 08:47.880
对吧 传的什么就是什么

08:47.880 --> 08:48.880
非常简单啊

08:48.880 --> 08:50.880
你这里边就是相当于是

08:50.880 --> 08:51.880
相当于是

08:51.880 --> 08:52.880
这句话就相当于是什么呢

08:52.880 --> 08:54.880
就像是new的一个promise

08:54.880 --> 08:56.880
result reject

08:56.880 --> 08:58.880
我们这里reject

08:58.880 --> 09:01.880
就相当于是这样写的

09:01.880 --> 09:03.880
是一样的对不对

09:03.880 --> 09:04.880
好 这是前两个

09:04.880 --> 09:05.880
静态方法

09:05.880 --> 09:06.880
这两个静态方法

09:06.880 --> 09:07.880
以后我们去做一些

09:07.880 --> 09:08.880
演示的时候

09:08.880 --> 09:09.880
可以用小剂

09:09.880 --> 09:10.880
非常简单

09:10.880 --> 09:12.880
就直接反回个promise

09:12.880 --> 09:15.880
后边四个是需要我们

09:15.880 --> 09:16.880
需要一点理解的

09:16.880 --> 09:17.880
因为后边四个东西

09:17.880 --> 09:18.880
细节其实蛮多的

09:18.880 --> 09:20.880
但是我们不需要记

09:20.880 --> 09:21.880
要去理解

09:21.880 --> 09:22.880
理解清楚了过后

09:22.880 --> 09:24.880
你只要理解了这个

09:24.880 --> 09:25.880
这些方法的含义

09:25.880 --> 09:27.880
你把含义理解清楚了

09:27.880 --> 09:28.880
那么它一细解

09:28.880 --> 09:30.880
你都可以通过逻辑去推

09:30.880 --> 09:32.880
比方说这个方法叫

09:32.880 --> 09:33.880
or

09:33.880 --> 09:34.880
里边传一个什么

09:34.880 --> 09:35.880
传一个任务数组

09:35.880 --> 09:36.880
啥意思啊

09:36.880 --> 09:37.880
比方说我可以这样写

09:37.880 --> 09:38.880
promise or

09:38.880 --> 09:39.880
里边传的是什么

09:39.880 --> 09:40.880
是一个数组

09:42.880 --> 09:43.880
数组的每一项是什么

09:43.880 --> 09:45.880
每一项就是个promise

09:45.880 --> 09:47.880
比方说我是不是可以这样写

09:47.880 --> 09:50.880
promise result

09:50.880 --> 09:51.880
那你看这个

09:51.880 --> 09:52.880
是不是第一

09:52.880 --> 09:53.880
数组的第一项

09:53.880 --> 09:54.880
第一项是不是给它

09:54.880 --> 09:56.880
是一个promise

09:56.880 --> 09:57.880
那当然说

09:57.880 --> 09:58.880
有些人必须

09:58.880 --> 09:59.880
我也不知道为什么

09:59.880 --> 10:00.880
必须要变量

10:00.880 --> 10:01.880
它不用变量

10:01.880 --> 10:03.880
它就是代码就看不懂了

10:05.880 --> 10:06.880
一定要用这种方式

10:06.880 --> 10:08.880
把变量再放过来

10:08.880 --> 10:11.880
我都不知道有啥区别

10:11.880 --> 10:12.880
总之这是个promise

10:12.880 --> 10:13.880
我刚才演示过的

10:13.880 --> 10:15.880
一个是个完成的promise

10:15.880 --> 10:17.880
当然你是不是可以有拒绝的呢

10:17.880 --> 10:18.880
也可以有拒绝的

10:18.880 --> 10:19.880
对不对

10:19.880 --> 10:21.880
promise results

10:22.880 --> 10:23.880
这也是不是

10:23.880 --> 10:25.880
数组的第二项

10:25.880 --> 10:26.880
连这个都看不懂

10:26.880 --> 10:27.880
它一定要把这个数组

10:27.880 --> 10:30.880
放到一个变量里面

10:30.880 --> 10:32.880
然后把数组再传过来

10:32.880 --> 10:34.880
我也不知道有啥区别

10:34.880 --> 10:36.880
反正就是给它一个数组

10:36.880 --> 10:37.880
怎么给无所谓的

10:37.880 --> 10:39.880
它每一项你怎么写无所谓的

10:39.880 --> 10:41.880
总之得是promise

10:41.880 --> 10:42.880
没一项

10:42.880 --> 10:43.880
一样嘛

10:43.880 --> 10:45.880
总之你给它传一些promise

10:45.880 --> 10:48.880
数组里面会有些promise

10:48.880 --> 10:49.880
传进去

10:49.880 --> 10:50.880
这个all这个方法

10:50.880 --> 10:52.880
它会返回一个新的任务

10:52.880 --> 10:53.880
就这个玩意

10:53.880 --> 10:55.880
它会得到一个新的任务

10:55.880 --> 10:56.880
关键我们要找的

10:56.880 --> 10:57.880
就是这个任务

10:57.880 --> 10:59.880
啥时候是挂起

10:59.880 --> 11:00.880
啥时候是完成

11:00.880 --> 11:02.880
啥时候是失败

11:03.880 --> 11:04.880
all是什么意思

11:04.880 --> 11:05.880
全部

11:05.880 --> 11:07.880
一个都不能少

11:09.880 --> 11:12.880
你所有的任务必须要全部成功

11:12.880 --> 11:13.880
我就成功

11:13.880 --> 11:14.880
就这个数组里面有很多任务

11:14.880 --> 11:15.880
对吧

11:15.880 --> 11:16.880
一起去做

11:16.880 --> 11:17.880
一起去弄

11:17.880 --> 11:19.880
然后你只剩下

11:19.880 --> 11:20.880
全部成功了

11:20.880 --> 11:21.880
那我就成功了

11:21.880 --> 11:22.880
比较说

11:22.880 --> 11:24.880
我这里写个123

11:25.880 --> 11:26.880
三个任务

11:26.880 --> 11:28.880
是不是我们都是完成的状态

11:28.880 --> 11:29.880
对吧

11:29.880 --> 11:30.880
我给它传了三个任务

11:30.880 --> 11:31.880
三个任务都是完成的

11:31.880 --> 11:32.880
那么这个promise

11:32.880 --> 11:33.880
就是完成的

11:33.880 --> 11:34.880
结果这么简单

11:35.880 --> 11:36.880
好 你看

11:41.830 --> 11:42.830
一秒钟之后

11:42.830 --> 11:43.830
说说一下

11:45.830 --> 11:46.830
那为什么刚才都是平顶

11:46.830 --> 11:47.830
我之后再说

11:48.830 --> 11:49.830
是不是完成的

11:49.830 --> 11:51.830
完成的数据

11:51.830 --> 11:52.830
它为什么是一个数组呢

11:52.830 --> 11:54.830
你想这个道理

11:54.830 --> 11:55.830
一个都不能少

11:56.830 --> 11:57.830
所以要等每一个任务权

11:57.830 --> 11:58.830
所有的任务全部完成

11:58.830 --> 11:59.830
完成的过后

11:59.830 --> 12:00.830
肯定不止一个数据

12:00.830 --> 12:01.830
是不是有很多数据

12:02.830 --> 12:03.830
它有一个

12:03.830 --> 12:04.830
它有一个

12:04.830 --> 12:05.830
它有一个

12:05.830 --> 12:06.830
那么它就把这些数据

12:06.830 --> 12:07.830
合并成为一个数据

12:07.830 --> 12:08.830
所以说

12:08.830 --> 12:09.830
如果说你

12:09.830 --> 12:10.830
针对这个promise做后续处理

12:10.830 --> 12:11.830
你该怎么写

12:11.830 --> 12:13.830
z 做后续处理

12:13.830 --> 12:14.830
result

12:14.830 --> 12:15.830
那么这个result

12:15.830 --> 12:17.830
不就是这个数据吗

12:18.830 --> 12:19.830
这个result

12:19.830 --> 12:20.830
就是把

12:20.830 --> 12:21.830
这里面的所有的promise

12:21.830 --> 12:22.830
完成之后

12:22.830 --> 12:23.830
所有的完成的相关数据

12:23.830 --> 12:24.830
汇总之后得到的结果

12:28.460 --> 12:29.460
是不是

12:29.460 --> 12:31.460
它一叫一个不能少

12:31.460 --> 12:32.460
我就是全部

12:32.460 --> 12:33.460
一个不能少

12:33.460 --> 12:34.460
全部都必须成功

12:34.460 --> 12:35.460
那我就成功

12:36.460 --> 12:37.460
那如果说

12:37.460 --> 12:38.460
这里面的promise

12:38.460 --> 12:40.460
有其中一个promise是刮旗

12:40.460 --> 12:41.460
它既没有成功

12:41.460 --> 12:42.460
又没有失败

12:42.460 --> 12:43.460
那是这种情况

12:43.460 --> 12:44.460
像这个promise

12:44.460 --> 12:45.460
是不是一直刮旗的

12:46.460 --> 12:47.460
对不对

12:47.460 --> 12:48.460
那么像这种情况

12:48.460 --> 12:49.460
那么请问这个pro

12:49.460 --> 12:50.460
什么状态

12:51.460 --> 12:52.460
那肯定就是刮旗

12:52.460 --> 12:53.460
你看现在这个

12:53.460 --> 12:54.460
回掉还算

12:54.460 --> 12:55.460
不能运行吗

12:55.460 --> 12:56.460
不能运行

12:56.460 --> 12:57.460
然后我们再看一下

12:58.460 --> 13:00.460
什么叫一个不能少

13:01.460 --> 13:02.460
你自己体会一下

13:03.460 --> 13:04.460
一秒钟之后

13:04.460 --> 13:05.460
我们输出一下

13:05.460 --> 13:06.460
这个promise的状态

13:07.460 --> 13:08.460
是平底

13:08.460 --> 13:09.460
对吧

13:09.460 --> 13:10.460
它必须要全部成功

13:10.460 --> 13:11.460
它才能成功

13:11.460 --> 13:12.460
一刻的刮旗

13:12.460 --> 13:13.460
它就刮旗

13:14.460 --> 13:16.460
那什么时候失败呢

13:16.460 --> 13:17.460
只要有一个失败

13:17.460 --> 13:18.460
它就失败

13:19.460 --> 13:20.460
那比方说吧

13:20.460 --> 13:21.460
我这里呢

13:21.460 --> 13:22.460
把其中一个失败

13:22.460 --> 13:24.460
那么这个promise是什么状态

13:25.460 --> 13:26.460
这个promise

13:26.460 --> 13:27.460
它就是失败

13:27.460 --> 13:30.030
好

13:30.030 --> 13:31.030
你看是不是这个结构体的

13:31.030 --> 13:32.030
数据是什么

13:32.030 --> 13:33.030
数据是2

13:33.030 --> 13:34.030
哎

13:34.030 --> 13:35.030
它可能提到怪了

13:35.030 --> 13:36.030
那你成功的时候

13:36.030 --> 13:37.030
不是把数据汇总了吗

13:37.030 --> 13:38.030
失败的时候

13:38.030 --> 13:39.030
为什么不汇总啊

13:39.030 --> 13:41.030
你自己想那个逻辑吧

13:42.030 --> 13:44.030
只要有一个失败

13:44.030 --> 13:45.030
我就失败了

13:45.030 --> 13:46.030
啥意思

13:46.030 --> 13:47.030
比方说

13:47.030 --> 13:48.030
有10个人

13:49.030 --> 13:51.030
短跑白蜜

13:52.030 --> 13:54.030
只要有一个人摔倒了

13:54.030 --> 13:56.030
整个任务结束了

13:56.030 --> 13:57.030
不再玩了

13:57.030 --> 13:58.030
玩不下去

13:58.030 --> 13:59.030
不用玩了

13:59.030 --> 14:01.030
那我就表现一个记录员

14:01.030 --> 14:02.030
他就看

14:02.030 --> 14:03.030
所有的成功了

14:03.030 --> 14:05.030
我就把每个人的用史记录下来

14:05.030 --> 14:07.030
只要有一个人失败了

14:07.030 --> 14:08.030
我转身就是

14:08.030 --> 14:10.030
那比方说跑到中途

14:10.030 --> 14:11.030
有一个人摔倒了

14:11.030 --> 14:13.030
说有一个任务失败了

14:13.030 --> 14:14.030
他转身就走了

14:14.030 --> 14:15.030
那么剩下的人

14:15.030 --> 14:16.030
可能还没跑完

14:16.030 --> 14:17.030
他看不看

14:17.030 --> 14:18.030
看都不看了

14:18.030 --> 14:19.030
说他怎么汇总

14:19.030 --> 14:20.030
他没法汇总

14:20.030 --> 14:22.030
他只知道失败的那个人

14:22.030 --> 14:24.030
他能够100%确定的是

14:24.030 --> 14:26.030
失败的那个人的失败原因

14:26.030 --> 14:27.030
是二

14:27.030 --> 14:28.030
其他的人

14:28.030 --> 14:29.030
不知道

14:29.030 --> 14:31.030
因为我这里写的是任务立即完成

14:31.030 --> 14:32.030
对吧

14:32.030 --> 14:33.030
但是你给的任务

14:33.030 --> 14:34.030
他不一定是立即完成的

14:34.030 --> 14:35.030
他可能是正在挂起的

14:35.030 --> 14:36.030
他也说不清楚

14:36.030 --> 14:37.030
所以说他只能去

14:37.030 --> 14:38.030
他失败的时候

14:38.030 --> 14:39.030
他只清楚

14:39.030 --> 14:41.030
失败的那一个的原因

14:41.030 --> 14:43.030
看到一个失败了就OK了

14:43.030 --> 14:44.030
就走了

14:44.030 --> 14:45.030
这就是

14:45.030 --> 14:46.030
为什么失败的时候

14:46.030 --> 14:47.030
只有一个数据

14:47.030 --> 14:49.030
说这个东西要通过

14:50.030 --> 14:52.030
通过正常的逻辑去推

14:52.030 --> 14:53.030
你去背是没用的

14:53.030 --> 14:54.030
背不住的

14:55.030 --> 14:56.030
就是All

14:57.030 --> 14:58.030
然后Endy

14:58.030 --> 15:00.030
以后我们会举一些实际的例子

15:00.030 --> 15:01.030
Endy

15:01.030 --> 15:02.030
反而回一个

15:02.030 --> 15:03.030
也是一样

15:03.030 --> 15:04.030
反而回一个任务

15:05.030 --> 15:06.030
他什么意思呢

15:06.030 --> 15:08.030
他指的是

15:08.030 --> 15:10.030
只要有一个成功

15:10.030 --> 15:11.030
是不是相反的

15:11.030 --> 15:12.030
或是所有的

15:12.030 --> 15:13.030
Endy表示任何一个

15:13.030 --> 15:15.030
只要有任何一个成功了

15:15.030 --> 15:18.030
那我这个新的任务就成功了

15:19.030 --> 15:20.030
让大家想一想

15:22.030 --> 15:24.030
开动里面的脑袋想一想

15:25.030 --> 15:26.030
这个任务

15:26.030 --> 15:28.030
他一秒钟之后

15:28.030 --> 15:29.030
他是成功还是失败

15:31.030 --> 15:32.030
是不是成功了

15:32.030 --> 15:33.030
为什么Endy

15:33.030 --> 15:34.030
只要有一个

15:34.030 --> 15:36.030
我不需要全部

15:36.030 --> 15:37.030
我只要一个就行了

15:37.030 --> 15:38.030
若水三千

15:38.030 --> 15:40.030
我只取一票

15:40.030 --> 15:41.030
对不对

15:42.030 --> 15:43.030
那么这里

15:43.030 --> 15:45.030
只需要有一个任务成功就行了

15:45.030 --> 15:46.030
这里成功了

15:46.030 --> 15:47.030
两个

15:47.030 --> 15:48.030
抽出有余了

15:48.030 --> 15:49.030
我只要一个

15:49.030 --> 15:51.030
一个成功就OK

15:51.030 --> 15:52.030
那么这是第一个问题

15:52.030 --> 15:53.030
他一定是成功了

15:53.030 --> 15:54.030
这好我一问

15:54.030 --> 15:55.030
那么关键是

15:55.030 --> 15:57.030
他成功的数据是啥

15:58.030 --> 15:59.030
你告诉我

15:59.030 --> 16:02.030
是一个数据

16:02.030 --> 16:04.030
还是多个数据

16:04.030 --> 16:05.030
多个数据是数据

16:05.030 --> 16:07.030
是一个数据还是数据

16:08.030 --> 16:09.030
按逻辑来说

16:09.030 --> 16:10.030
是不是应该是

16:12.030 --> 16:13.030
一个数据

16:13.030 --> 16:14.030
为什么

16:14.030 --> 16:16.030
Endy就是任何一个成功就行了

16:16.030 --> 16:17.030
也就是说

16:17.030 --> 16:18.030
他成功了之后

16:18.030 --> 16:19.030
其他就不用看了

16:19.030 --> 16:20.030
是不是只得到一个

16:20.030 --> 16:21.030
能确定的

16:21.030 --> 16:23.030
就是成功的数据

16:23.030 --> 16:24.030
谁先成功

16:24.030 --> 16:25.030
他也不一定知道

16:25.030 --> 16:26.030
我这边写的

16:26.030 --> 16:27.030
就是按照顺序

16:27.030 --> 16:28.030
他是先成功了

16:28.030 --> 16:29.030
所以得到的数据

16:29.030 --> 16:30.030
应该是一

16:44.030 --> 16:45.030
好吧

16:45.030 --> 16:46.030
这个地方

16:46.030 --> 16:47.030
我给大家说一下

16:47.030 --> 16:48.030
这个函数是存在的

16:48.030 --> 16:49.030
他说这个函数不存在

16:49.030 --> 16:51.030
这个函数是存在的

16:51.030 --> 16:52.030
出现这个错误的原因

16:52.030 --> 16:53.030
是因为我这边

16:53.030 --> 16:54.030
漏的版本有点低

16:54.030 --> 16:55.030
因为我这边

16:55.030 --> 16:56.030
用这个装扣的运行

16:56.030 --> 16:57.030
他不是在

16:57.030 --> 16:58.030
浏览器环境里面运行的

16:58.030 --> 16:59.030
是漏的环境里面运行的

16:59.030 --> 17:01.030
我说漏的环境版本有点低

17:01.030 --> 17:03.030
他这个函数还没有

17:03.030 --> 17:04.030
我把它换到浏览器

17:04.030 --> 17:05.030
浏览器里面没问题了

17:06.030 --> 17:10.580
是不是得到2

17:11.580 --> 17:12.580
Fulfill的1

17:12.580 --> 17:13.580
对吧

17:13.580 --> 17:14.580
完成1

17:14.580 --> 17:15.580
是不是有一个完成了

17:15.580 --> 17:16.580
首先他完成

17:16.580 --> 17:17.580
那得到的结果就是1

17:17.580 --> 17:18.580
在实际情况里面

17:18.580 --> 17:20.580
我这里用的是

17:20.580 --> 17:21.580
马上就得到的是

17:21.580 --> 17:23.580
一个完成的Promise

17:23.580 --> 17:24.580
完成的任务

17:24.580 --> 17:25.580
在实际情况里面

17:25.580 --> 17:26.580
这些任务都需要

17:26.580 --> 17:27.580
经过一段时间

17:28.580 --> 17:29.580
关于这个点

17:30.580 --> 17:31.580
这是N

17:31.580 --> 17:32.580
然后下

17:32.580 --> 17:33.580
那么什么时候失败呢

17:34.580 --> 17:35.580
全部任务失败

17:35.580 --> 17:36.580
什么跟上面的

17:36.580 --> 17:37.580
刚好相反

17:37.580 --> 17:38.580
全部任务失败

17:38.580 --> 17:39.580
就失败

17:39.580 --> 17:40.580
没有一个任务完成

17:40.580 --> 17:41.580
那就失败了

17:41.580 --> 17:42.580
然后这里

17:42.580 --> 17:43.580
全部都是被拒绝的

17:45.580 --> 17:46.580
是不是全部都失败了

17:46.580 --> 17:47.580
那么情况

17:47.580 --> 17:48.580
全部都失败了

17:48.580 --> 17:49.580
他肯定失败了

17:50.580 --> 17:51.580
相关原因

17:51.580 --> 17:52.580
是单个数据

17:52.580 --> 17:53.580
还是多个

17:55.580 --> 17:56.580
是不是多个了

17:57.580 --> 17:58.580
因为他能够确定的是

17:58.580 --> 17:59.580
全部任务都失败了

17:59.580 --> 18:00.580
他失败的时候

18:00.580 --> 18:01.580
他一定是

18:01.580 --> 18:02.580
全部任务都失败

18:02.580 --> 18:03.580
所以他会把

18:03.580 --> 18:04.580
全部任务失败的原因

18:04.580 --> 18:07.020
都汇走

18:07.020 --> 18:08.020
把浏览器里面

18:11.420 --> 18:12.420
这边

18:13.420 --> 18:14.420
这里已经

18:14.420 --> 18:15.420
刷新

18:18.420 --> 18:22.460
你看

18:22.460 --> 18:23.460
你看

18:23.460 --> 18:24.460
是不是得到的

18:24.460 --> 18:25.460
是一个输出

18:25.460 --> 18:26.460
对吧

18:26.460 --> 18:27.460
他封装到一个对象里面了

18:27.460 --> 18:28.460
我们来看一下

18:28.460 --> 18:30.460
这边我们用Catch

18:32.460 --> 18:33.460
Catch

18:33.460 --> 18:35.460
看一下打印下这个Rateout

18:36.460 --> 18:37.460
就只能到浏览器

18:38.460 --> 18:39.460
这个环境里面

18:39.460 --> 18:40.460
现在没有

18:43.480 --> 18:44.480
打印一下

18:47.750 --> 18:49.750
我在打印出来是啥

18:51.750 --> 18:52.750
Catch

18:53.750 --> 18:54.750
Cancel

18:55.750 --> 18:56.750
Cancel

18:57.750 --> 18:58.750
失败

18:58.750 --> 19:01.640
这样打印一下

19:07.360 --> 19:09.360
他得到的是个对象

19:09.360 --> 19:10.360
对象里面有个属性

19:10.360 --> 19:11.360
叫Arrest

19:12.360 --> 19:14.360
他有一些错误消息

19:14.360 --> 19:15.360
错误消息就是

19:15.360 --> 19:16.360
他给封装了一下

19:16.360 --> 19:17.360
所以我们要得到

19:17.360 --> 19:18.360
所谓的错误

19:18.360 --> 19:19.360
要得到他的点Arrest

19:20.360 --> 19:21.360
好

19:21.360 --> 19:22.360
这样子

19:22.360 --> 19:23.360
浏览器里面

19:26.890 --> 19:27.890
你看失败

19:27.890 --> 19:28.890
失败

19:28.890 --> 19:29.890
好

19:29.890 --> 19:30.890
这是关于Ani

19:30.890 --> 19:31.890
好

19:31.890 --> 19:32.890
看一下有没有别的函数呢

19:33.890 --> 19:35.890
还有AllSettled

19:36.890 --> 19:37.890
这个也是什么意思呢

19:37.890 --> 19:38.890
他也是一样

19:38.890 --> 19:39.890
返回一个新的任务

19:39.890 --> 19:41.890
给他传一个数字

19:41.890 --> 19:42.890
他表示说

19:43.890 --> 19:44.890
全部

19:44.890 --> 19:45.890
我不一定要全部成功

19:45.890 --> 19:47.890
反正全部都得

19:47.890 --> 19:48.890
有结果

19:48.890 --> 19:49.890
什么要有结果

19:49.890 --> 19:50.890
以绝

19:50.890 --> 19:51.890
什么要以绝

19:51.890 --> 19:52.890
还记得吗

19:52.890 --> 19:53.890
啥叫以绝

20:03.240 --> 20:05.240
我上一节课的那个课件

20:05.240 --> 20:06.240
已经删掉了

20:06.240 --> 20:07.240
就是那张图

20:08.240 --> 20:09.240
还是吧

20:09.240 --> 20:10.240
找一下吧

20:10.240 --> 20:11.240
我找一下上级课的那个图

20:12.240 --> 20:14.740
再

20:14.740 --> 20:19.870
接视

20:20.870 --> 20:21.870
课面是基础

20:22.870 --> 20:25.500
就这个图

20:26.500 --> 20:29.140
看到没

20:29.140 --> 20:30.140
就这个图

20:30.140 --> 20:31.140
只要你是以绝

20:31.140 --> 20:32.140
就是表示有了结果

20:32.140 --> 20:33.140
你不一定是成功

20:33.140 --> 20:34.140
有可能失败

20:34.140 --> 20:35.140
有可能成功

20:35.140 --> 20:36.140
无所谓

20:36.140 --> 20:37.140
只要你有结果

20:37.140 --> 20:38.140
你不是挂起就行了

20:39.140 --> 20:40.140
任务书中

20:40.140 --> 20:42.140
所有任务只要有了结果

20:43.140 --> 20:45.140
那么我这个新的课面

20:45.140 --> 20:46.140
就成功

20:47.140 --> 20:48.140
这种情况下

20:48.140 --> 20:49.140
是不可能有失败的

20:50.140 --> 20:51.140
你想想这个道理

20:51.140 --> 20:52.140
有没有可能

20:52.140 --> 20:53.140
这个逻辑下

20:53.140 --> 20:54.140
有没有可能

20:54.140 --> 20:55.140
这个失败

20:55.140 --> 20:56.140
它不可能失败的

20:56.140 --> 20:57.140
无所谓

20:57.140 --> 20:58.140
我不管你

20:58.140 --> 20:59.140
这里边课面是成功

20:59.140 --> 21:00.140
还是失败

21:00.140 --> 21:01.140
无所谓

21:01.140 --> 21:02.140
全部只要有了结果

21:02.140 --> 21:03.140
我就成功了

21:03.140 --> 21:04.140
那如果说一直没有结果了

21:04.140 --> 21:05.140
一直没有结果

21:05.140 --> 21:06.140
它就挂起

21:06.140 --> 21:07.140
它只有两种状态

21:07.140 --> 21:08.140
挂起和成功

21:08.140 --> 21:09.140
它不可能有失败的

21:09.140 --> 21:10.140
比方说

21:10.140 --> 21:11.140
给他看一下吧

21:11.140 --> 21:12.140
比如说

21:12.140 --> 21:13.140
有些成功

21:13.140 --> 21:14.140
有些失败了

21:14.140 --> 21:16.140
然后我们这里用的是All-Settled

21:16.140 --> 21:17.140
首先看一下

21:17.140 --> 21:18.140
它最终的状态

21:21.340 --> 21:22.340
是不是

21:22.340 --> 21:23.340
它成功了

21:23.340 --> 21:24.340
它的数据有点意思

21:25.340 --> 21:26.340
它也是贿重

21:26.340 --> 21:28.340
它跟All也是一样

21:28.340 --> 21:29.340
All它只管成功了

21:29.340 --> 21:30.340
所以属于说

21:30.340 --> 21:32.340
只把成功了来贿重

21:32.340 --> 21:33.340
但是All-Settled

21:33.340 --> 21:34.340
Settled的什么意思

21:34.340 --> 21:35.340
就是以绝的意思

21:35.340 --> 21:36.340
我只要保证

21:36.340 --> 21:37.340
所有的完成

21:37.340 --> 21:38.340
就是有结果就行了

21:38.340 --> 21:39.340
那么这个结果

21:39.340 --> 21:41.340
是有可能有成功

21:41.340 --> 21:42.340
有可能有失败

21:42.340 --> 21:43.340
所以它贿重的信心

21:43.340 --> 21:44.340
要比较详细一点

21:44.340 --> 21:45.340
比方说

21:45.340 --> 21:46.340
它对应什么

21:46.340 --> 21:47.340
它对应的是

21:47.340 --> 21:48.340
第一个Promise

21:48.340 --> 21:50.340
它就对应这个结果

21:50.340 --> 21:51.340
它的状态是

21:51.340 --> 21:53.340
第一个Promise的状态是

21:53.340 --> 21:54.340
完成了

21:54.340 --> 21:55.340
值是1

21:55.340 --> 21:58.340
第二个Promise的状态是拒绝的

21:59.340 --> 22:01.340
然后原因是2

22:01.340 --> 22:02.340
第三个Promise的状态

22:02.340 --> 22:03.340
是完成的

22:03.340 --> 22:04.340
值为3

22:04.340 --> 22:05.340
自己就对到了看一下

22:05.340 --> 22:06.340
是不是这个道理

22:06.340 --> 22:07.340
所以它得到了

22:07.340 --> 22:08.340
还是一个贿重结果

22:08.340 --> 22:09.340
数据

22:09.340 --> 22:10.340
然后这个贿重结果

22:10.340 --> 22:11.340
比较详细

22:11.340 --> 22:12.340
每一个是一个对象

22:12.340 --> 22:13.340
它这个对象就告诉你

22:13.340 --> 22:15.340
它这个Promise

22:16.340 --> 22:17.340
每一个Promise

22:17.340 --> 22:19.340
它最后的情况是什么

22:19.340 --> 22:20.340
它都有结果了

22:20.340 --> 22:21.340
如果说

22:21.340 --> 22:22.340
其中一个Promise

22:22.340 --> 22:23.340
一直是挂起的话

22:23.340 --> 22:24.340
那么它就一直挂起

22:25.340 --> 22:26.340
这就是All settled

22:27.340 --> 22:28.340
再下一个Arrest

22:28.340 --> 22:32.340
Arrest的话就是比赛

22:33.340 --> 22:36.340
看谁先有结果

22:36.340 --> 22:37.340
我不管你是成功

22:37.340 --> 22:38.340
还是失败

22:38.340 --> 22:40.340
只要你有结果

22:40.340 --> 22:42.340
我的结果就跟你一样

22:42.340 --> 22:43.340
叫Arrest

22:44.340 --> 22:46.340
看谁先有结果

22:46.340 --> 22:47.340
那么由于这里

22:47.340 --> 22:49.340
我们作为所有的Promise

22:49.340 --> 22:51.340
都是立即完成的

22:51.340 --> 22:52.340
立即结束的

22:52.340 --> 22:53.340
所以说这是成功的

22:53.340 --> 22:54.340
这是失败的

22:54.340 --> 22:55.340
这是成功的

22:55.340 --> 22:56.340
那么它就会按照顺序

22:56.340 --> 22:57.340
第一个是成功的

22:57.340 --> 22:59.340
那么这个就是成功的

22:59.340 --> 23:00.340
明儿的意思

23:00.340 --> 23:01.340
我们来看一下

23:02.340 --> 23:03.340
第一个是成功的

23:03.340 --> 23:04.340
那么最终它就

23:04.340 --> 23:06.340
这个Promise就是成功的

23:06.340 --> 23:07.340
第一个的数据是1

23:07.340 --> 23:09.340
那么它就数据就是1

23:09.340 --> 23:10.340
对不对

23:10.340 --> 23:12.340
当然我这边都是立即完成的

23:12.340 --> 23:13.340
所以它取第一个

23:13.340 --> 23:14.340
但是实际情况下

23:14.340 --> 23:16.340
这里边Promise完成的时间

23:16.340 --> 23:17.340
是不确定的

23:17.340 --> 23:18.340
对吧

23:18.340 --> 23:19.340
有可能它需要一秒钟完成

23:19.340 --> 23:21.340
有可能它需要三秒钟

23:21.340 --> 23:22.340
有可能它就立即完成了

23:22.340 --> 23:23.340
那么就取的是它

23:24.340 --> 23:25.340
谁先完成

23:25.340 --> 23:26.340
竞赛

23:26.340 --> 23:27.340
谁先有结果

23:27.340 --> 23:28.340
就用谁的

23:29.340 --> 23:30.340
那么如果说

23:30.340 --> 23:31.340
不要说它

23:31.340 --> 23:33.340
第一个是先失败

23:33.340 --> 23:35.340
那么它就失败了

23:37.660 --> 23:38.660
它就失败了

23:38.660 --> 23:40.660
原因跟它的失败原因是一样的

23:41.660 --> 23:42.660
就谁先成功

23:42.660 --> 23:43.660
它就成功

23:43.660 --> 23:44.660
数据跟它成功的一样

23:44.660 --> 23:45.660
谁先失败

23:45.660 --> 23:46.660
它就失败

23:48.660 --> 23:49.660
就这么个意思

23:49.660 --> 23:50.660
就找第一个有结果的

23:50.660 --> 23:52.660
这就是瑞士竞赛

23:52.660 --> 23:54.660
这就是Promise里边的

23:54.660 --> 23:55.660
所有静态方法

23:55.660 --> 23:57.660
那么平时我们用的话

23:57.660 --> 23:58.660
灵活运用

23:58.660 --> 23:59.660
其实我们平时

23:59.660 --> 24:00.660
静态方法都用的不多

24:00.660 --> 24:01.660
有的时候会用的

24:01.660 --> 24:02.660
下面有一个

24:02.660 --> 24:03.660
有些练习体

24:03.660 --> 24:04.660
我们把练习体做了之后

24:04.660 --> 24:05.660
再来看登革的一个例子

24:08.660 --> 24:09.660
这里有一个函数

24:09.660 --> 24:10.660
这个函数的作用

24:10.660 --> 24:12.660
当然这个函数是我魔力的

24:12.660 --> 24:14.660
魔力的一个网络通信

24:14.660 --> 24:16.660
说你给我一个页码

24:16.660 --> 24:18.660
我就能从网络中

24:18.660 --> 24:20.660
获取这个页码的一些学生数据

24:20.660 --> 24:22.660
好,咱们来用一下吧

24:22.660 --> 24:23.660
这个函数你自己有兴趣的话

24:23.660 --> 24:24.660
可以看一下

24:24.660 --> 24:26.660
就写了一些魔力的数据

24:26.660 --> 24:27.660
没兴趣的话你不用看

24:27.660 --> 24:28.660
无所谓的

24:28.660 --> 24:30.660
用的其实也是学过的知识

24:30.660 --> 24:31.660
只是有点照而已

24:31.660 --> 24:32.660
比方说传一个仪

24:32.660 --> 24:34.660
表示获取第一页的学生

24:34.660 --> 24:35.660
它给你返回了啥

24:35.660 --> 24:36.660
返回的是Promise

24:36.660 --> 24:38.660
因为它这个注释已经打得很清楚了

24:38.660 --> 24:40.660
返回了Promise你应该怎么用

24:41.660 --> 24:42.660
所以后续处理

24:42.660 --> 24:44.660
你给我获取学生

24:44.660 --> 24:46.660
那么这是一个任务

24:46.660 --> 24:47.660
这个任务完成之后

24:47.660 --> 24:49.660
是否拿到一些学生数据

24:49.660 --> 24:54.660
比如输出一下学生数据

24:57.660 --> 24:58.660
运行

25:01.480 --> 25:02.480
它自己需要一段时间

25:02.480 --> 25:03.480
它这里爆错了

25:03.480 --> 25:04.480
说明啥

25:04.480 --> 25:05.480
它告诉你网络错误

25:05.480 --> 25:06.480
获取第一页数据失败

25:06.480 --> 25:07.480
它就有可能会有错误

25:07.480 --> 25:09.480
其实我都是魔力的

25:09.480 --> 25:11.480
我用一个随技术来魔力

25:12.480 --> 25:13.480
不要到这边

25:13.480 --> 25:14.480
我就给它注册两个吧

25:17.480 --> 25:19.480
那到底是什么原因失败的

25:19.480 --> 25:20.480
一个说一下

25:25.580 --> 25:26.580
等到一段时间

25:26.580 --> 25:28.580
是不是拿到一个数据

25:28.580 --> 25:29.580
这个数据里面

25:29.580 --> 25:30.580
其实学生我做的很简单

25:30.580 --> 25:31.580
一个是学生编号

25:31.580 --> 25:32.580
ID

25:32.580 --> 25:33.580
一个是学生的姓名

25:33.580 --> 25:34.580
我去用这种方式

25:35.580 --> 25:36.580
反正是魔力

25:36.580 --> 25:38.580
魔力一个网络通信

25:38.580 --> 25:39.580
有这么一个任务

25:40.580 --> 25:41.580
得到一个学生

25:41.580 --> 25:42.580
然后

25:43.580 --> 25:45.580
就是可以去获取某一页的学生

25:45.580 --> 25:47.580
成功就拿到学生的数据

25:47.580 --> 25:49.580
失败就拿到失败的原因

25:49.580 --> 25:50.580
明白吧

25:50.580 --> 25:51.580
这是这个函数

25:52.580 --> 25:54.580
接下来我要利用这个函数

25:54.580 --> 25:55.580
来做一些练习

25:56.580 --> 25:57.580
第一个练习

25:58.580 --> 25:59.580
你们可以自己尝试去做一下

26:00.580 --> 26:02.580
获取一到十页的学生

26:02.580 --> 26:04.580
结果有十页的学生都要获取

26:05.580 --> 26:07.580
那么最终获取到了过后

26:07.580 --> 26:10.580
按照顺序合并成余的数据

26:11.580 --> 26:12.580
任何一页的数据

26:13.580 --> 26:14.580
获取出现错误

26:14.580 --> 26:16.580
则任务不再继续

26:16.580 --> 26:17.580
打印错误消息

26:17.580 --> 26:18.580
这啥意思

26:19.580 --> 26:21.580
就是说我这边我可能一下子

26:21.580 --> 26:23.580
不要一页一页的拿

26:23.580 --> 26:24.580
我一下子去拿十页的学生

26:24.580 --> 26:25.580
要同时

26:26.580 --> 26:30.580
二三四五六七八九十

26:30.580 --> 26:31.580
我同时

26:32.580 --> 26:34.580
从网络上去拿十页的学生

26:35.580 --> 26:37.580
所以我一开始要调问几次

26:37.580 --> 26:38.580
是不是十次

26:38.580 --> 26:39.580
对不对

26:39.580 --> 26:41.580
那么比方说中途有某一页错了

26:42.580 --> 26:43.580
这拿第五页的时候错了

26:44.580 --> 26:46.580
那么剩下的数据不要了

26:47.580 --> 26:48.580
任务不再继续

26:48.580 --> 26:49.580
无所谓的不要了

26:50.580 --> 26:52.580
我就打印错误消息就完事了

26:54.580 --> 26:55.580
那这到底怎么做呢

26:56.580 --> 26:57.580
我就问你

26:57.580 --> 26:58.580
这是几个静态方法

26:58.580 --> 26:59.580
你觉得使用哪一个

27:00.580 --> 27:03.540
那一个个看吧

27:03.540 --> 27:04.540
这几个不要

27:04.540 --> 27:05.540
这两个就不用看了

27:06.540 --> 27:07.540
首先是O

27:08.540 --> 27:09.540
O是什么意思

27:09.540 --> 27:10.540
全一个都不能少

27:11.540 --> 27:13.540
这个玩意儿是不是一个都不能少

27:14.540 --> 27:15.540
你甭管他后面干啥吗

27:16.540 --> 27:18.540
我要获取十页这个任务

27:18.540 --> 27:19.540
是不是一个都不能少

27:19.540 --> 27:20.540
必须要全部都打到

27:20.540 --> 27:21.540
全部都要成功

27:21.540 --> 27:22.540
对吧一个都不能失败

27:22.540 --> 27:24.540
失败一个我就没法继续了

27:24.540 --> 27:25.540
是不是就应该使用O

27:25.540 --> 27:26.540
那我们就是用B

27:27.540 --> 27:28.540
PromiseO

27:28.540 --> 27:29.540
这里边传啥

27:29.540 --> 27:31.540
是吧传一个任务数据

27:31.540 --> 27:33.540
我们这里是不是有很多任务

27:33.540 --> 27:34.540
要获取十页

27:34.540 --> 27:35.540
那么就传一个任务数据

27:35.540 --> 27:37.540
但是个任务数据怎么写呢

27:38.540 --> 27:40.540
我给大家推荐的一种解法

27:40.540 --> 27:42.540
第一种解法就是你拿一个数组

27:43.540 --> 27:44.540
十页

27:48.060 --> 27:49.060
这个解法

27:49.060 --> 27:50.060
你懂得这个

27:50.060 --> 27:52.060
我掉了这个函数十次

27:53.060 --> 27:54.060
5

27:54.060 --> 27:55.060
6

27:55.060 --> 27:56.060
7

27:56.060 --> 27:57.060
8

27:57.060 --> 27:59.060
现在用这种最笨的解法

27:59.060 --> 28:01.060
最笨的解法也是最好理解的

28:01.060 --> 28:02.060
所以每掉了一个函数

28:02.060 --> 28:03.060
这个反回的就是什么

28:03.060 --> 28:04.060
反回的就是个PromiseO

28:04.060 --> 28:06.060
如果说你连这个都看不懂

28:07.060 --> 28:08.060
那我就没办法了

28:08.060 --> 28:09.060
那你可能只能这样子写了

28:10.060 --> 28:12.060
因为有些同学我也不知道

28:12.060 --> 28:13.060
他一定要用辩量

28:13.060 --> 28:14.060
不用辩量

28:14.060 --> 28:15.060
他脑袋是蒙的

28:17.060 --> 28:18.060
拿到第一个Promise

28:18.060 --> 28:19.060
拿到第二个Promise

28:20.060 --> 28:21.060
这里写P

28:23.060 --> 28:24.060
这里写P写这

28:24.060 --> 28:25.060
然后一共写10个

28:26.060 --> 28:27.060
这里写P

28:28.060 --> 28:29.060
那我就不讲了

28:29.060 --> 28:30.060
这种解法

28:30.060 --> 28:31.060
如果说你一定要用这种解法

28:31.060 --> 28:32.060
就去写

28:33.060 --> 28:34.060
这里我们得到一个数组

28:34.060 --> 28:35.060
是不是数组全进来

28:36.060 --> 28:37.060
我也不知道这个是任务

28:37.060 --> 28:38.060
每个任务

28:38.060 --> 28:39.060
是不是说第一个任务

28:39.060 --> 28:40.060
就一定先完成

28:40.060 --> 28:41.060
那也不一定

28:41.060 --> 28:42.060
你看我这里

28:42.060 --> 28:43.060
为了说明这一点

28:43.060 --> 28:44.060
我都把每个任务

28:44.060 --> 28:45.060
等待的时间都是水积的

28:46.060 --> 28:47.060
我都不知道他什么时候玩

28:48.060 --> 28:49.060
所以说不一定是哪个先完成

28:50.060 --> 28:51.060
但是他最终汇总的结果

28:51.060 --> 28:53.060
一定是按照这个数据去来汇总

28:54.060 --> 28:55.060
这个玩意是不是一个Promise

28:56.060 --> 28:57.060
那么对这个Promise进行后续处理

28:58.060 --> 29:00.060
如果说这个Promise成功了

29:01.060 --> 29:02.060
说明啥

29:02.060 --> 29:03.060
同学们说明啥

29:03.060 --> 29:05.060
说明是不是所有任务都成功了

29:05.060 --> 29:06.060
那么换而言之

29:06.060 --> 29:08.060
如果说这个Promise失败了

29:08.060 --> 29:09.060
是不是只能说明

29:09.060 --> 29:11.060
至少其中一个失败了

29:11.060 --> 29:12.060
其他是不是失败

29:12.060 --> 29:13.060
我不知道

29:14.060 --> 29:15.060
那你看一下吧

29:18.910 --> 29:19.910
过去是不是有一个失败了

29:19.910 --> 29:20.910
第三页数据失败了

29:20.910 --> 29:22.910
那么这个事情是不是没做了

29:22.910 --> 29:23.910
不用做了

29:24.910 --> 29:25.910
再来看

29:28.350 --> 29:29.350
第五页数据有失败了

29:29.350 --> 29:30.350
我把机率调低一点

29:30.350 --> 29:31.350
机率有点高

29:32.350 --> 29:33.350
失败的机率

29:33.350 --> 29:34.350
再来

29:34.350 --> 29:35.350
十个

29:38.050 --> 29:39.050
你看

29:39.050 --> 29:40.050
最终汇总的结果

29:40.050 --> 29:41.050
你看个Results

29:42.050 --> 29:43.050
一个很大的数据

29:43.050 --> 29:45.050
这是第一个任务完成的

29:46.050 --> 29:48.050
这是第二个任务完成的数据

29:49.050 --> 29:51.050
第三个任务完成的数据

29:51.050 --> 29:53.050
第四个任务完成的数据

29:53.050 --> 29:54.050
它的格式就是这样子

29:55.050 --> 29:56.050
它的汇总结果是这样子

29:56.050 --> 29:57.050
是一个数据

29:57.050 --> 29:59.050
第一个任务完成的数据

29:59.050 --> 30:01.050
是不是一个数据

30:01.050 --> 30:02.050
一个学生

30:03.050 --> 30:04.050
第二个任务完成的数据

30:04.050 --> 30:05.050
是不是有很多学生

30:06.050 --> 30:07.050
第三个任务完成的数据

30:07.050 --> 30:09.050
是不是拨取到第三页的学生

30:10.050 --> 30:12.050
那么我要按顺序

30:12.050 --> 30:14.050
就是我要把这个数据展开

30:14.050 --> 30:15.050
是不是要把里面

30:15.050 --> 30:16.050
每一个数据展开

30:16.050 --> 30:18.050
我再给大家介绍一个方法

30:19.050 --> 30:20.050
要把数据展开

30:20.050 --> 30:21.050
要把这种格式的东西展开

30:21.050 --> 30:22.050
其实非常简单

30:23.050 --> 30:24.050
不要看一下吧

30:24.050 --> 30:25.050
比方说我有个数据

30:25.050 --> 30:26.050
这个数据里面

30:26.050 --> 30:27.050
第一项又是一个数据

30:28.050 --> 30:29.050
第二项又是一个数据

30:30.050 --> 30:32.050
第三项又是一个数据

30:33.050 --> 30:34.050
我要把这个还要展开

30:34.050 --> 30:35.050
其实就把这个

30:35.050 --> 30:36.050
调用这个数据的一个方法

30:36.050 --> 30:37.050
叫flat

30:38.050 --> 30:40.050
反而回来就是有一个展开的数据

30:40.050 --> 30:41.050
有这么一个API

30:41.050 --> 30:43.050
之前没有讲

30:43.050 --> 30:44.050
我随便说一下

30:44.050 --> 30:45.050
它就把这个数据里边

30:45.050 --> 30:47.050
它的指数组展开

30:48.050 --> 30:49.050
所以说我们这边

30:50.050 --> 30:51.050
要做了什么事情

30:52.050 --> 30:53.050
完

30:53.050 --> 30:56.190
好看一下

31:00.230 --> 31:01.230
你看是不是得到了

31:01.230 --> 31:02.230
按顺序

31:04.230 --> 31:05.230
这个按顺序

31:05.230 --> 31:06.230
它不是说它一定是

31:06.230 --> 31:07.230
它先完成

31:07.230 --> 31:08.230
它再完成

31:08.230 --> 31:09.230
它再完成

31:09.230 --> 31:10.230
不是的

31:10.230 --> 31:11.230
它又可能是它先完成

31:11.230 --> 31:12.230
然后它再完成

31:13.230 --> 31:14.230
然后它再完成

31:14.230 --> 31:15.230
但是它最终会种的时候

31:15.230 --> 31:16.230
它一定会按照

31:16.230 --> 31:18.230
你给它传入的顺序来进行会种

31:18.230 --> 31:19.230
它会自动给你

31:19.230 --> 31:21.230
按照传入的顺序来会种

31:21.230 --> 31:22.230
这个不用担心

31:23.230 --> 31:24.230
好 这是地道题

31:24.230 --> 31:25.230
地道题就是这里写的

31:25.230 --> 31:26.230
有点恶心 对吧

31:26.230 --> 31:27.230
所以说我写单版的话

31:27.230 --> 31:28.230
我肯定不可以用这种写

31:28.230 --> 31:29.230
那如果说我过去

31:29.230 --> 31:30.230
一到一百页了

31:30.230 --> 31:31.230
那你又咋办了

31:31.230 --> 31:32.230
所以从来就开始想到

31:32.230 --> 31:33.230
是不是用循环

31:34.230 --> 31:35.230
每一次循环往里边加一个

31:36.230 --> 31:37.230
除了用循环之外

31:38.230 --> 31:39.230
还可以用这种方式来写

31:41.740 --> 31:42.740
不是有实业吗

31:43.740 --> 31:44.740
创连一个实则数据

31:45.740 --> 31:46.740
然后用一个feel

31:47.740 --> 31:48.740
随便feel一个东西

31:48.740 --> 31:50.740
把我们数据的每一项填充一个东西

31:50.740 --> 31:51.740
你自己看

31:53.740 --> 31:54.740
6一个

31:54.740 --> 31:55.740
6一个

31:55.740 --> 31:56.740
2A

31:56.740 --> 31:57.740
10个feel

31:58.740 --> 31:59.740
每一项填充

31:59.740 --> 32:00.740
随便填充一个

32:00.740 --> 32:01.740
全程一个e随便

32:01.740 --> 32:02.740
那么是不是得到10个e的数据

32:03.740 --> 32:04.740
那么对这个数据

32:04.740 --> 32:05.740
再使用map

32:05.740 --> 32:06.740
映射

32:06.740 --> 32:07.740
对吧 映射是不是

32:07.740 --> 32:08.740
这就要传个函数

32:10.740 --> 32:11.740
函数的第一项

32:11.740 --> 32:12.740
是不是数据了每一个

32:12.740 --> 32:13.740
每一项的值

32:14.740 --> 32:15.740
函数的第二个函数

32:15.740 --> 32:16.740
是不是下标

32:17.740 --> 32:18.740
返回啥

32:19.740 --> 32:20.740
返回

32:21.740 --> 32:22.740
i加e

32:22.740 --> 32:23.740
下标加e

32:23.740 --> 32:25.740
你看什么得到1到10的数据

32:27.740 --> 32:28.740
地口不需要它每一项

32:28.740 --> 32:29.740
每一项实则无所谓

32:29.740 --> 32:30.740
我只是把下标加e

32:30.740 --> 32:31.740
作为它数据的项

32:32.740 --> 32:33.740
那么你看第一项

32:33.740 --> 32:35.740
是不是表示页码1

32:35.740 --> 32:36.740
第二项表示页码2

32:37.740 --> 32:38.740
对吧

32:38.740 --> 32:39.740
那么这个玩意

32:39.740 --> 32:45.820
你看我这里可以这样写

32:46.820 --> 32:47.820
这个玩意

32:47.820 --> 32:48.820
是不是就这个数据

32:49.820 --> 32:50.820
就这样的一个数据

32:50.820 --> 32:51.820
针对这个数据

32:51.820 --> 32:52.820
我在干嘛

32:52.820 --> 32:53.820
在用map

32:53.820 --> 32:54.820
映射

32:54.820 --> 32:55.820
再去继续映射

32:57.820 --> 32:59.820
其实我这里都不用两次映射

32:59.820 --> 33:01.820
其实就在这里可以映射

33:01.820 --> 33:02.820
这个i加e

33:02.820 --> 33:04.820
其实就已经是下标加e了

33:05.820 --> 33:06.820
数据的第一项

33:06.820 --> 33:07.820
就是1

33:07.820 --> 33:08.820
数据的第二项就是

33:08.820 --> 33:09.820
如果说你是在看不懂的话

33:09.820 --> 33:10.820
我就再来一次映射

33:10.820 --> 33:12.820
对这个数据再来一次映射

33:12.820 --> 33:13.820
那么就是

33:13.820 --> 33:15.820
每一项我就把它当成一个页码

33:16.820 --> 33:17.820
返回了是什么

33:18.820 --> 33:20.820
这样子的一个数据返回的

33:20.820 --> 33:21.820
是不是就是个Promise的数据

33:22.820 --> 33:27.290
这样子倒是不是一个Promise的数据

33:28.290 --> 33:29.290
Promise也是对象

33:29.290 --> 33:30.290
你不要把它讲得那么神奇

33:32.290 --> 33:33.290
给我一个页码

33:34.290 --> 33:35.290
返回的是

33:35.290 --> 33:36.290
这个函数的返回结果

33:37.290 --> 33:38.290
这个函数的返回结果不就是Promise

33:39.290 --> 33:40.290
于是把每一个数字

33:40.290 --> 33:41.290
映射成一个Promise

33:44.050 --> 33:45.050
当然你其实

33:45.050 --> 33:46.050
这两个map

33:46.050 --> 33:47.050
也没有必要

33:47.050 --> 33:48.050
你其实就在这里

33:48.050 --> 33:49.050
fetch students

33:49.050 --> 33:50.050
把这里i加e加

33:51.050 --> 33:53.740
那里就说说

33:53.740 --> 33:54.740
我要有100个学生

33:57.740 --> 33:58.740
喜欢都不用写

33:58.740 --> 33:59.740
效果是完全一样的

34:08.360 --> 34:09.360
这是第一题

34:10.360 --> 34:13.440
把这个保留着

34:14.440 --> 34:15.440
下一道题

34:15.440 --> 34:17.440
获取一道实业的学生

34:18.440 --> 34:19.440
不用写了

34:19.440 --> 34:21.440
然后按照页码的顺序

34:21.440 --> 34:23.440
合并成一个数据

34:23.440 --> 34:27.030
一样的

34:28.030 --> 34:30.030
如果某些页码的数据

34:30.030 --> 34:31.030
获取失败

34:31.030 --> 34:33.030
就不加入该数据即可

34:34.030 --> 34:35.030
是不是跟之前不一样了

34:35.030 --> 34:36.030
跟之前用的

34:36.030 --> 34:38.030
只要有一个失败

34:39.030 --> 34:40.030
任务都没了

34:40.030 --> 34:41.030
就直接打印失败原因

34:41.030 --> 34:42.030
就完事了

34:43.030 --> 34:44.030
但是现在不是

34:44.030 --> 34:45.030
你失败

34:45.030 --> 34:46.030
失失败里的

34:46.030 --> 34:47.030
我就是那一页不要了

34:47.030 --> 34:48.030
然后你第五页失败了

34:48.030 --> 34:49.030
我第五页不要了

34:50.030 --> 34:51.030
我就合并的时候

34:51.030 --> 34:52.030
就1234

34:54.030 --> 34:56.030
如果说第三和五页

34:56.030 --> 34:57.030
都失败了

34:57.030 --> 34:58.030
那就124

34:58.030 --> 34:59.030
678

34:59.030 --> 35:00.030
90

35:00.030 --> 35:01.030
我就这样子

35:01.030 --> 35:02.030
不需要你失败了

35:02.030 --> 35:03.030
无所谓

35:03.030 --> 35:04.030
那你看一下

35:04.030 --> 35:05.030
用哪一个

35:06.030 --> 35:08.030
就失败的无所谓

35:08.030 --> 35:09.030
就是你只要有结果

35:09.030 --> 35:10.030
我就行

35:10.030 --> 35:12.030
是不是 all settled

35:12.030 --> 35:13.030
对吧

35:14.030 --> 35:15.030
只要你输出里面

35:15.030 --> 35:16.030
全部任务

35:16.030 --> 35:17.030
已决就行

35:17.030 --> 35:18.030
你不能说

35:18.030 --> 35:19.030
一个任务都还没完

35:19.030 --> 35:20.030
你就结束了

35:20.030 --> 35:21.030
不行

35:21.030 --> 35:22.030
所有的都在结束

35:22.030 --> 35:23.030
都得有结果

35:23.030 --> 35:24.030
你可能失败了

35:24.030 --> 35:25.030
你可能成功了

35:25.030 --> 35:26.030
无所谓

35:26.030 --> 35:27.030
我只需要成功的

35:27.030 --> 35:29.030
所以说我们这里就可以用 promise

35:29.030 --> 35:31.030
all settled

35:31.030 --> 35:33.030
把个数据传进去

35:33.030 --> 35:34.030
这么多人传进去

35:34.030 --> 35:35.030
好

35:35.030 --> 35:37.030
那么我看一下结果

35:38.030 --> 35:39.030
我这里不用开启了

35:39.030 --> 35:41.030
因为这个玩意是不可能失败的

35:41.030 --> 35:42.030
刚才说过了

35:42.030 --> 35:43.030
这种情况是不可能失败的

35:44.030 --> 35:46.030
所以说我这里看结果就行了

35:46.030 --> 35:47.030
看Ridals的结果

35:49.790 --> 35:50.790
你可能中间有失败

35:50.790 --> 35:51.790
有可能中间有成功

35:51.790 --> 35:52.790
无所谓

35:55.170 --> 35:56.170
你看

35:56.170 --> 35:57.170
Status

35:57.170 --> 35:58.170
他第一个成功了

35:58.170 --> 36:00.170
得到了一个数组

36:00.170 --> 36:01.170
学生对象的数组

36:01.170 --> 36:03.170
第二个成功了

36:03.170 --> 36:04.170
得到学生对象的数组

36:04.170 --> 36:05.170
第三个成功了

36:05.170 --> 36:06.170
第四个也成功了

36:06.170 --> 36:07.170
第五个

36:07.170 --> 36:08.170
这个是第几个

36:08.170 --> 36:09.170
第六页失败了

36:09.170 --> 36:10.170
第七个成功了

36:10.170 --> 36:11.170
第八个成功了

36:11.170 --> 36:12.170
所以说是不是我们这里

36:12.170 --> 36:13.170
只需要成功的

36:13.170 --> 36:14.170
失败了我管都不管

36:14.170 --> 36:15.170
我只需要成功的

36:15.170 --> 36:16.170
那怎么办

36:16.170 --> 36:17.170
哎呀

36:17.170 --> 36:18.170
我们之前学过的一些

36:18.170 --> 36:19.170
输出ape拿出来用

36:20.170 --> 36:21.170
Ridals

36:22.170 --> 36:23.170
So filter

36:23.170 --> 36:24.170
对这个对象

36:24.170 --> 36:26.170
这些过滤 filter

36:26.170 --> 36:27.170
什么了

36:27.170 --> 36:29.170
我只要

36:29.170 --> 36:31.170
我只要那个成功的

36:31.170 --> 36:32.170
就他的Status

36:32.170 --> 36:33.170
是不是要等于

36:33.170 --> 36:34.170
Fulfill的

36:35.170 --> 36:36.170
Fulfill的比较成功

36:36.170 --> 36:37.170
对吧

36:37.170 --> 36:38.170
这个是比较失败

36:38.170 --> 36:39.170
我只要成功的

36:40.170 --> 36:41.170
这样是不是

36:41.170 --> 36:42.170
是不是返回一个新数组

36:42.170 --> 36:43.170
这个新数组

36:43.170 --> 36:44.170
是不是就只有成功的

36:45.170 --> 36:46.170
然后我针对这个新数组

36:47.170 --> 36:48.170
我在那卖

36:49.170 --> 36:50.170
我们先来看

36:50.170 --> 36:51.170
一步一步来

36:51.170 --> 36:52.170
可能

36:52.170 --> 36:53.170
稍微快一点

36:53.170 --> 36:54.170
就有点着不住了

36:55.170 --> 36:56.170
输出一下

36:56.170 --> 36:57.170
那么这里我把失败

36:57.170 --> 36:58.170
机率调高一点

36:59.170 --> 37:00.170
0.3

37:00.170 --> 37:02.170
可能会导致大面积的失败

37:04.170 --> 37:05.170
那么这样子一过滤

37:05.170 --> 37:07.170
你看这个Ridals里边

37:08.170 --> 37:09.170
是不是只有成功的

37:09.170 --> 37:13.170
1 2 3 4 5 6 7

37:13.170 --> 37:14.170
只有7个对吧

37:14.170 --> 37:15.170
有3个失败了

37:15.170 --> 37:16.170
0.3还是

37:17.170 --> 37:18.170
蠻合适的

37:18.170 --> 37:19.170
30%的机率

37:20.170 --> 37:21.170
所以只有7个

37:21.170 --> 37:22.170
我就只拿到成功的

37:22.170 --> 37:23.170
我拿到成功的时候

37:23.170 --> 37:24.170
我不要这个对象

37:24.170 --> 37:26.170
我要它里边的数组

37:26.170 --> 37:27.170
对吧

37:27.170 --> 37:28.170
所以说我来个硬设

37:28.170 --> 37:29.170
这是一个数组

37:29.170 --> 37:30.170
我继续硬设它

37:31.170 --> 37:33.170
把每一项item

37:33.170 --> 37:34.170
每一项我只要什么

37:34.170 --> 37:35.170
只要它等buy value

37:37.170 --> 37:38.170
其他个属性我不要了

37:39.170 --> 37:40.170
我只要它的value

37:40.170 --> 37:41.170
你看一下这样得到的结果

37:46.680 --> 37:48.680
那你看是不是又形成了弄格式了

37:49.680 --> 37:50.680
是不是又形成了格式了

37:50.680 --> 37:53.680
为什么不是从1开始

37:54.680 --> 37:55.680
因为它第一页失败了

37:56.680 --> 37:58.680
对这个动作是我们再来flat

37:58.680 --> 37:59.680
拍片

37:59.680 --> 38:01.680
flat的意思就是平面的意思

38:01.680 --> 38:03.680
把这种有深度的数组结构

38:03.680 --> 38:05.680
拍片形成一维数组

38:07.680 --> 38:09.680
这不就是这道题的结果吗

38:12.680 --> 38:13.680
有些页码是缺失的

38:13.680 --> 38:14.680
比较低六页

38:14.680 --> 38:15.680
低六页

38:15.680 --> 38:16.680
六开头的就没有

38:16.680 --> 38:18.680
九开头的就没有

38:18.680 --> 38:21.680
这就是这道题用all settled

38:22.680 --> 38:23.680
下一道题

38:23.680 --> 38:24.680
或许依照实验的学生

38:24.680 --> 38:25.680
你们可以都可以

38:25.680 --> 38:27.680
自己先尝试着做一下

38:28.680 --> 38:29.680
或许依照实验的学生

38:29.680 --> 38:32.680
打印注意先获取到的数据

38:34.680 --> 38:35.680
注意它的描述

38:37.680 --> 38:39.680
如果全部都获取失败

38:39.680 --> 38:40.680
这打印所有的错误消息

38:41.680 --> 38:42.680
你觉得是哪一个

38:45.310 --> 38:47.310
咱们要打印注意先获取到的数据

38:49.310 --> 38:50.310
就是我只要那个

38:51.310 --> 38:52.310
第一个成功的

38:53.310 --> 38:55.690
所以any

38:56.690 --> 38:57.690
任意一成功

38:57.690 --> 38:58.690
不管你是哪一个

38:58.690 --> 38:59.690
只要你成功了

38:59.690 --> 39:00.690
我就OK了

39:00.690 --> 39:02.690
我就把你打印出来

39:03.690 --> 39:04.690
全部失败了

39:04.690 --> 39:06.690
我就打印所有的错误消息

39:06.690 --> 39:07.690
所以说我这里

39:08.690 --> 39:10.690
Promise any

39:12.690 --> 39:14.690
如果说我这边成功了

39:14.690 --> 39:16.690
说明有一个学生

39:16.690 --> 39:17.690
有一个学生获取到了

39:17.690 --> 39:19.690
那我就打印这个学生

39:19.690 --> 39:21.690
打印最先获取到的数据就完事了

39:22.690 --> 39:23.690
让我看一下

39:23.690 --> 39:25.690
只要有一个成功

39:25.690 --> 39:29.130
哎呀他又遇到这个问题

39:30.130 --> 39:32.130
我看一下我在这边直接印

39:32.130 --> 39:37.380
做的啊

39:44.900 --> 39:45.900
不行你这个load里边

39:45.900 --> 39:47.900
还没有这个any方法

39:47.900 --> 39:48.900
那我只能

39:49.900 --> 39:51.900
这玩意只能在浏览器里面印

39:53.900 --> 39:55.900
我怎么又跑到电器体内

39:55.900 --> 39:56.900
去写了

39:57.900 --> 40:01.600
我只能在浏览器里面印

40:13.380 --> 40:14.380
知道是吧

40:14.380 --> 40:16.380
发现第二页先成功

40:17.380 --> 40:18.380
那么得到第二页的

40:18.380 --> 40:19.380
那不一定的啊

40:19.380 --> 40:21.380
哪一页先成功不一定的

40:21.380 --> 40:23.380
那现在是第三页先成功

40:23.380 --> 40:24.380
再刷新

40:24.380 --> 40:25.380
那现在是第一页先成功

40:25.380 --> 40:26.380
这说不准了

40:27.380 --> 40:29.380
哪个人物先成功不说不准

40:29.380 --> 40:30.380
但反正无所谓

40:30.380 --> 40:31.380
只要哪个先成功

40:31.380 --> 40:33.380
我就打印哪一个的成功消息

40:34.380 --> 40:35.380
什么情况下我会失败

40:35.380 --> 40:37.380
就全部都失败了

40:37.380 --> 40:38.380
我就会失败

40:38.380 --> 40:40.380
那么我就打印失败的消息

40:41.380 --> 40:42.380
什么时候我们全部会失败

40:42.380 --> 40:43.380
就全部失败了

40:43.380 --> 40:44.380
不要说我这里

40:44.380 --> 40:45.380
就夸张一点小鱼

40:45.380 --> 40:47.380
是不是有一定失败

40:47.380 --> 40:48.380
那么这种情况下

40:48.380 --> 40:50.380
它一定是全部失败

40:50.380 --> 40:51.380
你看我一直在等

40:51.380 --> 40:52.380
等所有人完成

40:52.380 --> 40:53.380
我发现全部都失败了

40:53.380 --> 40:54.380
全部都失败的时候

40:54.380 --> 40:55.380
我们打印一下

40:55.380 --> 40:57.380
它的一边的Azure

40:57.380 --> 40:58.380
有一个属性

40:58.380 --> 40:59.380
这项目看到过了

41:00.380 --> 41:01.380
这个属性

41:01.380 --> 41:02.380
就可以拿到所有的错误消息

41:05.380 --> 41:06.380
这是个数组

41:06.380 --> 41:07.380
这是个数组

41:09.380 --> 41:10.380
第一个错误消息

41:10.380 --> 41:11.380
第二个错误消息

41:12.380 --> 41:13.380
OK 这是这道题

41:15.380 --> 41:16.380
好 下一道题

41:17.380 --> 41:19.380
扩取一到十页的学生

41:19.380 --> 41:21.380
输出最先得到的结果

41:22.380 --> 41:23.380
有结果输出结果

41:23.380 --> 41:24.380
有错误输出错误

41:24.380 --> 41:25.380
这是啥意思

41:26.380 --> 41:27.380
这就是Race

41:29.380 --> 41:30.380
反正有结果

41:30.380 --> 41:31.380
我就想我不管你是成功还是失败

41:31.380 --> 41:34.380
就第一个有结果的那个任务

41:34.380 --> 41:35.380
一到十页

41:35.380 --> 41:36.380
我是拿第一页的数据

41:36.380 --> 41:37.380
拿第二的数据

41:37.380 --> 41:38.380
谁先回来

41:38.380 --> 41:40.380
不管你是拿到还是没拿到

41:40.380 --> 41:41.380
你回来了

41:42.380 --> 41:44.380
我就看一下你怎么是什么情况

41:45.380 --> 41:46.380
其他的不管

41:46.380 --> 41:47.380
所以这里也很简单

41:47.380 --> 41:48.380
Promise

41:56.950 --> 41:57.950
第一个的数据

41:58.950 --> 42:00.950
还有就是第一个的错误消息

42:01.950 --> 42:02.950
就用这样子写

42:02.950 --> 42:03.950
都行

42:04.950 --> 42:05.950
这边我们要记得调低一点

42:06.950 --> 42:07.950
0.3

42:08.950 --> 42:09.950
我也不知道

42:09.950 --> 42:10.950
我现在我也不知道

42:10.950 --> 42:11.950
第一个到底是成功还是失败

42:11.950 --> 42:12.950
反正就是第一个有结果的

42:13.950 --> 42:15.950
第一个有结果的说明啥

42:15.950 --> 42:16.950
说明是第十页

42:16.950 --> 42:19.950
第十页率先有结果

42:19.950 --> 42:21.950
它结果只失败的

42:21.950 --> 42:22.950
那我就运行到这个

42:23.950 --> 42:24.950
再来一次

42:25.950 --> 42:27.950
这是第三页率先有结果

42:27.950 --> 42:29.950
第三页的结果是成功的

42:29.950 --> 42:30.950
我就拿到第三页

42:31.950 --> 42:32.950
那么这种情况

42:32.950 --> 42:33.950
如果说什么情况

42:33.950 --> 42:34.950
我们会用这种的

42:35.950 --> 42:37.950
在目前这个场景下面

42:37.950 --> 42:38.950
好像也不会用到这种方式

42:39.950 --> 42:40.950
就举了这么个例子

42:40.950 --> 42:41.950
好

42:41.950 --> 42:42.950
最后我给大家看一下

42:42.950 --> 42:43.950
邓哥的解决办法

42:45.950 --> 42:46.950
我们前面不是说邓哥

42:46.950 --> 42:47.950
有这么三个函数吗

42:47.950 --> 42:48.950
邓哥的解决办法

42:48.950 --> 42:49.950
就是这么一套蛋

42:50.950 --> 42:54.290
不能这样子写对吧

42:54.290 --> 42:55.290
要怎么写

42:55.290 --> 42:56.290
这样子写

42:56.290 --> 42:59.660
它不就是要一个结果吗

42:59.660 --> 43:00.660
不管它

43:00.660 --> 43:01.660
不管全部成功

43:01.660 --> 43:02.660
还是全部失败

43:02.660 --> 43:03.660
还是有些成功

43:03.660 --> 43:04.660
有些失败

43:04.660 --> 43:05.660
我就要汇总的一个结果

43:05.660 --> 43:07.660
所以说这里最适合用 all settled

43:07.660 --> 43:08.660
只要你有结果就行

43:08.660 --> 43:10.660
因为我要给邓扫汇报

43:11.660 --> 43:12.660
那么拿几个 promise

43:12.660 --> 43:13.660
第一个调用这个函数

43:13.660 --> 43:14.660
是不是拿到一个 promise

43:14.660 --> 43:15.660
调这个函数

43:15.660 --> 43:16.660
是不是拿到一个 promise

43:16.660 --> 43:17.660
调这个函数

43:17.660 --> 43:18.660
是不是拿到一个 promise

43:18.660 --> 43:19.660
这三个 promise

43:19.660 --> 43:20.660
都去做吧

43:21.660 --> 43:22.660
如果说

43:22.660 --> 43:23.660
反正就是我最重要

43:23.660 --> 43:24.660
汇总成一个结果

43:24.660 --> 43:26.660
你们都有结果了之后

43:27.660 --> 43:28.660
下面大妈

43:28.660 --> 43:29.660
如果看不懂的话

43:29.660 --> 43:30.660
我来一步一步来看

43:30.660 --> 43:31.660
你们都有结果了

43:31.660 --> 43:33.660
我们来看一下这个 result

43:39.300 --> 43:40.300
是不是前两个都有出了问题

43:40.300 --> 43:41.300
最后一个成功了

43:43.300 --> 43:44.300
对不对

43:45.300 --> 43:46.300
再来看运行

43:47.300 --> 43:48.300
那输不准的

43:48.300 --> 43:49.300
我用我用了水机

43:50.300 --> 43:51.300
第一个成功了

43:51.300 --> 43:52.300
后面两个都出了问题

43:52.300 --> 43:53.300
对吧

43:53.300 --> 43:54.300
不管出什么问题

43:54.300 --> 43:55.300
反正就是汇报一下

43:55.300 --> 43:56.300
给邓扫汇报

43:56.300 --> 43:57.300
怎么汇报呢

43:58.300 --> 43:59.300
当然就是这就无所谓了

43:59.300 --> 44:00.300
其实你只要能看懂

44:00.300 --> 44:01.300
这个就无所谓了

44:01.300 --> 44:03.300
我这边用了一种方式

44:03.300 --> 44:04.300
就是说

44:05.300 --> 44:06.300
我把他形成

44:06.300 --> 44:07.300
把这个玩意变成一个制服串

44:08.300 --> 44:10.300
如果说你是成功的

44:10.300 --> 44:11.300
我就得到他的 value

44:12.300 --> 44:13.300
如果说你是失败的

44:13.300 --> 44:14.300
我就得到他的 reason

44:14.300 --> 44:15.300
然后呢

44:15.300 --> 44:16.300
得到这么一个制服串输出

44:16.300 --> 44:18.300
说我这里咋写的呢 result

44:18.300 --> 44:19.300
field

44:19.300 --> 44:20.300
没办法

44:21.300 --> 44:22.300
把每一个对象

44:23.300 --> 44:24.300
给你做一个三目运算

44:24.300 --> 44:27.300
如果说他的 standard是等于 fulfilled

44:29.300 --> 44:30.300
fulfilled

44:30.300 --> 44:32.300
表示如果说你的任务成功的

44:32.300 --> 44:34.300
成功的话我就拿你的 value

44:35.300 --> 44:36.300
如果说你是失败的

44:36.300 --> 44:37.300
我就拿你的 reason

44:39.300 --> 44:40.300
总会有一个数

44:40.300 --> 44:41.300
有一个数据

44:42.300 --> 44:43.300
那我们来看一下

44:43.300 --> 44:44.300
说这个结果输出

44:44.300 --> 44:48.190
是否拿到一个制服串的数据

44:49.190 --> 44:50.190
对吧

44:50.190 --> 44:51.190
拿到一个制服串的数据

44:51.190 --> 44:52.190
然后呢

44:52.190 --> 44:53.190
我把这个制服串的数据

44:53.190 --> 44:54.190
用交易连接起来

44:55.190 --> 44:56.190
有一个分号连接吧

44:56.190 --> 44:57.190
我就是起来这么端来

44:57.190 --> 44:58.190
你自己看

44:59.190 --> 45:01.950
没什么好说的

45:02.950 --> 45:03.950
map

45:03.950 --> 45:04.950
要么就得到他的 value

45:04.950 --> 45:05.950
要么把他的 reason

45:06.950 --> 45:07.950
然后呢

45:07.950 --> 45:08.950
用分号连接

45:08.950 --> 45:09.950
最后把这个得到的制服

45:09.950 --> 45:10.950
最终的那个制服串

45:10.950 --> 45:11.950
打印出来

45:11.950 --> 45:13.950
就是可以登上汇报的结果

45:16.950 --> 45:17.950
你会

45:17.950 --> 45:18.950
同这个汇报结果

45:18.950 --> 45:19.950
可以看出

45:19.950 --> 45:21.950
这做法好像出了问题

45:21.950 --> 45:23.950
衣服好像没问题了

45:23.950 --> 45:24.950
继续玩到有问题

45:26.950 --> 45:27.950
这就是咱们

45:28.950 --> 45:29.950
这几个东西

45:29.950 --> 45:30.950
整体还是比较简单的

45:30.950 --> 45:31.950
就是

45:32.950 --> 45:33.950
做一些

45:34.950 --> 45:35.950
有了一些信态方法

45:35.950 --> 45:37.950
可以对咱们对多任务的场景

45:37.950 --> 45:40.950
有了一些控制能力

45:41.950 --> 45:42.950
这是这几个内容

45:42.950 --> 45:44.950
大家下去把这个作业题

45:44.950 --> 45:45.950
好好去梳理一下

45:46.950 --> 45:47.950
你可以自己写不出来

45:47.950 --> 45:48.950
然后听到我讲解之后

45:48.950 --> 45:49.950
你要能写出来

45:50.950 --> 45:51.950
然后把这个笨歌的例子

45:51.950 --> 45:52.950
也好好去体会一下

45:53.950 --> 45:54.950
这就可就到这了

