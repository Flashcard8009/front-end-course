WEBVTT

00:00.620 --> 00:03.020
这些课咱们再来看一个例子

00:03.020 --> 00:05.020
就是凡凡夫的去举起这些例子

00:05.020 --> 00:08.020
就告诉张总同学们能够体会在里的作用

00:08.020 --> 00:10.820
他能够干涉底层的实现的现在

00:10.820 --> 00:14.420
就是说这些课的例子是可验证的函数参数

00:14.420 --> 00:16.420
不知道大家平时写代码的时候

00:16.420 --> 00:18.420
有没有留意过这么一个问题

00:18.420 --> 00:20.420
就是说我们写这么一个函数的

00:20.420 --> 00:22.420
有的时候写一些函数

00:22.420 --> 00:26.220
这个函数它对参数的内容是有要求的

00:26.220 --> 00:28.820
比方说 求和

00:29.020 --> 00:32.020
你给我传两个数字 我给你返回一个A加B

00:32.020 --> 00:34.020
就这么一个简单的例子

00:34.020 --> 00:37.020
其实这个地址如果说你只是关系它的核心功能的话

00:37.020 --> 00:39.020
OK 那就没问题了 A加B

00:39.020 --> 00:41.020
那如果说你给我传的

00:41.020 --> 00:44.020
我本来的意思是两个数字相加

00:44.020 --> 00:47.020
结果你可能给我传两个支付刷进来

00:47.020 --> 00:49.020
那是不是你参数的内型就有问题

00:49.020 --> 00:50.020
那我还是在相加

00:50.020 --> 00:52.020
那加出来可能就不是你想要的结果了

00:52.020 --> 00:55.020
比方说你从页面上取出来的一个E

00:55.020 --> 00:57.020
又从另外一个元素里面取出来一个2

00:57.220 --> 01:00.220
那么1和2相加本来应该等于3的

01:00.220 --> 01:03.220
但是你两个由于是支付刷就变成了13

01:03.220 --> 01:05.220
就是13 对不对

01:05.220 --> 01:07.220
就是遇到很多这样的场景

01:07.220 --> 01:09.220
就是我们一个函数里面的参数

01:09.220 --> 01:11.220
它有内型 对内型有要求

01:11.220 --> 01:13.220
那么这种例子我们以前能不能实现

01:13.220 --> 01:15.220
其实以前也可以实现

01:15.220 --> 01:17.220
不过以前那种时间方式

01:17.220 --> 01:19.220
我一会给大家写一遍

01:19.220 --> 01:22.220
我们这里只考虑用单理来实现

01:22.220 --> 01:24.220
因为单理 函数调用

01:24.220 --> 01:26.220
它是一个底层的东西

01:26.420 --> 01:28.420
就是反射里面它有对应的API

01:28.420 --> 01:30.420
那么代理就可以重写这样的API

01:30.420 --> 01:32.420
比方说我们写一个函数

01:32.420 --> 01:34.420
叫做Vanity

01:46.420 --> 01:49.420
就是得到一个函数可验证的函数

01:49.420 --> 01:51.420
你给我传一个函数进来

01:51.420 --> 01:53.420
你给我传一个函数进来

01:53.420 --> 01:55.420
那么你再给我传一下它的内型的

01:55.420 --> 01:57.420
有哪些内型

01:57.420 --> 01:59.420
就是taps

01:59.420 --> 02:01.420
到时候我们怎么用呢 就这样子用

02:01.420 --> 02:03.420
validate function 把这个上传进去

02:03.420 --> 02:05.420
每个函数是什么类型呢 我这样传

02:05.420 --> 02:07.420
第一个函数是number

02:07.420 --> 02:09.420
第二个函数呢 也得是number

02:09.420 --> 02:11.420
就这么个意思 它会给我一个新的函数

02:11.420 --> 02:13.420
就要上proxy

02:13.420 --> 02:15.420
那么到时候调用的时候呢

02:15.420 --> 02:17.420
我们调用新的函数

02:17.420 --> 02:19.420
比方说该传一个1

02:19.420 --> 02:21.420
该再传一个2 这样它会包错

02:21.420 --> 02:23.420
就这么个意思

02:23.420 --> 02:25.420
输出

02:25.420 --> 02:27.420
比方说这里

02:27.420 --> 02:29.420
本来如果说你不验证的话 就是一个正常输出

02:29.420 --> 02:31.420
当然有些人说我在这里不能验证吗

02:31.420 --> 02:33.420
但是你这样子在这里验证的话

02:33.420 --> 02:35.420
以后其他函数怎么办呢 是不是又得重新验证

02:35.420 --> 02:37.420
那么我这里就写出一个通用的东西

02:37.420 --> 02:39.420
你可以通过它来得到一个新的函数

02:39.420 --> 02:41.420
那么把内型传进去完成了

02:41.420 --> 02:43.420
当然我这里写的比较简单

02:43.420 --> 02:45.420
其实你还要考虑更多的场景

02:45.420 --> 02:47.420
比方说它有可能一个参数有极重情况

02:47.420 --> 02:49.420
你都要写进去 无所谓

02:49.420 --> 02:51.420
那么这里我们怎么来实现呢

02:51.420 --> 02:53.420
其实就是创建一个代理

02:53.420 --> 02:55.420
另一个proxy

02:55.420 --> 02:57.420
代理谁 代理函数

02:57.420 --> 02:59.420
代理函数怎么代理呢 不一样的

02:59.420 --> 03:01.420
函数不就是对象吗

03:01.420 --> 03:03.420
你还记得吗 反射里面不是有一个方法

03:03.420 --> 03:05.420
叫apply吗 对不对

03:05.420 --> 03:07.420
反射里面不是有一个方法叫apply吗

03:07.420 --> 03:09.420
它传递这么一些东西

03:09.420 --> 03:11.420
Zis之类的东西

03:11.420 --> 03:13.420
甚至我们还可以验证Zis

03:13.420 --> 03:15.420
对不对

03:15.420 --> 03:17.420
它传递这么一些东西

03:17.420 --> 03:19.420
那么我们这里如果说啥都不做的话

03:19.420 --> 03:21.420
就很简单reflect

03:21.420 --> 03:23.420
调用底层的就行了

03:23.420 --> 03:25.420
apply target传进去

03:25.420 --> 03:27.420
Zis arguments传进去

03:27.420 --> 03:29.420
调用底层就完事了

03:31.420 --> 03:33.420
没问题吧 咱们无非就是

03:33.420 --> 03:35.420
做这么一件事

03:35.420 --> 03:37.420
现在呢

03:37.420 --> 03:39.420
在调用底层实现之前

03:39.420 --> 03:41.420
我们是不是可以对它进行验证

03:41.420 --> 03:43.420
这是我们的参数

03:43.420 --> 03:45.420
这是我们的内型

03:45.420 --> 03:47.420
taps

03:47.420 --> 03:49.420
for each

03:49.420 --> 03:51.420
t

03:51.420 --> 03:52.420
t

03:52.420 --> 03:54.420
t是内型

03:54.420 --> 03:55.420
s是下标

03:55.420 --> 03:57.420
那么我们找出对应参数列表里面的

03:57.420 --> 03:59.420
对应的下标

03:59.420 --> 04:01.420
找出参数

04:01.420 --> 04:03.420
对应的下标的参数

04:03.420 --> 04:04.420
那么判断一下

04:04.420 --> 04:06.420
tap参数

04:06.420 --> 04:08.420
是不是等于

04:08.420 --> 04:10.420
等于这个内型呢

04:10.420 --> 04:12.420
你给我传了一些内型 对吧

04:12.420 --> 04:14.420
对应的参数是不是对应

04:14.420 --> 04:15.420
等内型

04:15.420 --> 04:16.420
如果只要有一个不相等

04:16.420 --> 04:18.420
这里还不能用for each

04:18.420 --> 04:19.420
不然这里套在函数里面

04:19.420 --> 04:20.420
包出都还不好包

04:20.420 --> 04:22.420
都还不好包

04:22.420 --> 04:24.420
实际上也可以包出

04:24.420 --> 04:25.420
直接在包出就得了

04:25.420 --> 04:27.420
s6 type error

04:27.420 --> 04:29.420
来吧 包一个错误

04:29.420 --> 04:31.420
可以 没问题的

04:31.420 --> 04:33.420
报个错误

04:33.420 --> 04:34.420
什么呢

04:34.420 --> 04:37.420
参数 哪个参数

04:37.420 --> 04:39.420
这个参数

04:39.420 --> 04:41.420
或者说第几个参数

04:41.420 --> 04:43.420
第几个呢

04:43.420 --> 04:44.420
i加1

04:44.420 --> 04:46.420
i从0开始

04:46.420 --> 04:49.420
这个参数 这个值

04:49.420 --> 04:51.420
不满足内形

04:51.420 --> 04:52.420
哪个内形呢

04:52.420 --> 04:54.420
t

04:54.420 --> 04:55.420
你看一下吧

04:55.420 --> 04:56.420
我们是不是就写出来这么一个代理

04:56.420 --> 04:58.420
每次在调用这个函数的时候

04:58.420 --> 05:00.420
因为我们只通过代理在调用

05:00.420 --> 05:02.420
那么调用这个函数的时候

05:02.420 --> 05:04.420
它就会运行这个代理

05:04.420 --> 05:06.420
没问题吧

05:06.420 --> 05:07.420
这里就包出了

05:07.420 --> 05:09.420
包出当然就不会直接往后运行了

05:09.420 --> 05:13.760
好 咱们再看一下吧

05:13.760 --> 05:15.760
这里 检查

05:15.760 --> 05:17.760
你看 是不是

05:17.760 --> 05:19.760
包出 some proxy

05:19.760 --> 05:21.760
哦 这里没返回

05:21.760 --> 05:22.760
这里没返回 这个喊

05:22.760 --> 05:23.760
还是没返回 要把个返回

05:23.760 --> 05:24.760
proxy

05:24.760 --> 05:26.760
好 包出

05:26.760 --> 05:28.760
这是 onDefend

05:28.760 --> 05:29.760
这里输出 onDefend

05:29.760 --> 05:30.760
它没有包错 是吧

05:30.760 --> 05:31.760
我们再输出一下

05:31.760 --> 05:34.760
输出t和i

05:34.760 --> 05:37.760
number0和1

05:37.760 --> 05:38.760
这个没问题

05:38.760 --> 05:40.760
再输出一下arc

05:40.760 --> 05:42.760
再输出一下arc

05:42.760 --> 05:44.760
ti

05:44.760 --> 05:46.760
看一下 哪里出了问题

05:46.760 --> 05:51.760
arc是输出了1 number0

05:51.760 --> 05:54.760
好 那么这里的type

05:54.760 --> 05:55.760
哦 这里是不等于 是吧

05:55.760 --> 05:57.760
应该说不等于 不是等于

05:57.760 --> 05:58.760
不等于才包出

05:58.760 --> 05:59.760
好 包出

05:59.760 --> 06:00.760
你看 是不是包出了

06:00.760 --> 06:01.760
第一个参数

06:01.760 --> 06:03.760
1不满足内行

06:03.760 --> 06:04.760
number

06:04.760 --> 06:06.760
第一个参数

06:06.760 --> 06:08.760
是不满足内行

06:08.760 --> 06:10.760
就实现了一个通用验证的功能

06:10.760 --> 06:11.760
注意哦 它是通用的

06:11.760 --> 06:13.760
以后其他寒数也可以这样用

06:13.760 --> 06:14.760
只要一调用它

06:14.760 --> 06:15.760
把寒数传进去

06:15.760 --> 06:17.760
把每个参数的内行传进去

06:17.760 --> 06:18.760
那么得到一个新的寒数

06:18.760 --> 06:20.760
你之后去用那个新的寒数代理就行了

06:20.760 --> 06:23.760
而且这种做法是没有浪费内存空间的

06:23.760 --> 06:25.760
它并没有给你搞出一个新的寒数出来

06:25.760 --> 06:27.760
你看上去好像是一个新的寒数

06:27.760 --> 06:28.760
实际上不是的

06:28.760 --> 06:30.760
它没有搞出一个新的寒数

06:30.760 --> 06:31.760
它只是个代理

06:31.760 --> 06:32.760
只是个特殊的东西

06:32.760 --> 06:35.760
内存空间里边还是只存了以前的寒数

06:35.760 --> 06:37.760
没有这个意思吗

06:37.760 --> 06:38.760
好 这是这个

06:38.760 --> 06:40.760
实现了一个就是通用的验证

06:41.760 --> 06:43.760
那么这个东西其实以前也能实现

06:43.760 --> 06:45.760
包括上级课说得够寒数

06:45.760 --> 06:47.760
其实以前要做的话也能实现

06:47.760 --> 06:49.760
如果以前的时间方案没有那么好

06:49.760 --> 06:50.760
比方说以前我们怎么实现了

06:50.760 --> 06:52.760
以前还是用同样的方法

06:52.760 --> 06:53.760
用的时候导还是这样子用

06:53.760 --> 06:55.760
看一下以前怎么实现

06:55.760 --> 06:57.760
以前我们就得这样子实现

06:57.760 --> 07:00.760
我这里给它返回一个新的寒数

07:00.760 --> 07:01.760
返回一个新的寒数

07:01.760 --> 07:06.760
接收一些参数

07:06.760 --> 07:09.760
这个新的寒数先去验证一下

07:09.760 --> 07:11.760
验证一下参数是不正确的

07:11.760 --> 07:13.760
先去验证一下参数是不正确的

07:13.760 --> 07:15.760
如果是这里验证通过了

07:15.760 --> 07:17.760
没有爆错 没问题了

07:17.760 --> 07:18.760
OK 我再去运行

07:18.760 --> 07:20.760
你给我了这个寒数

07:20.760 --> 07:21.760
Funk

07:21.760 --> 07:22.760
再去运行这个寒数

07:22.760 --> 07:23.760
Funk

07:23.760 --> 07:25.760
那么把我的参数传进去

07:25.760 --> 07:26.760
实际上这个

07:26.760 --> 07:28.760
以前的这种做法也可以

07:28.760 --> 07:30.760
返回

07:30.760 --> 07:31.760
对吧

07:31.760 --> 07:33.760
当然

07:33.760 --> 07:35.760
没问题

07:35.760 --> 07:37.760
刚才我们这里还要返回

07:37.760 --> 07:38.760
这里还没写

07:38.760 --> 07:40.760
这里要把它返回

07:40.760 --> 07:43.760
它的返回值跟它的返回值一样

07:43.760 --> 07:46.760
那么这里是不是也是一样的

07:46.760 --> 07:48.760
这样的写法也是可以的

07:48.760 --> 07:49.760
也是可以的

07:49.760 --> 07:50.760
我们是用高阶寒数

07:50.760 --> 07:51.760
你给我一个寒数

07:51.760 --> 07:52.760
我给你返回一个新的寒数

07:52.760 --> 07:53.760
只不过这种做法

07:53.760 --> 07:54.760
为什么不好呢

07:54.760 --> 07:55.760
因为它有了一个新的寒数

07:55.760 --> 07:57.760
是增加了内存开销

07:57.760 --> 07:59.760
那么这一边是没有的

07:59.760 --> 08:00.760
没有新的寒数的

08:00.760 --> 08:01.760
它只是一个代理

08:01.760 --> 08:02.760
代理不是新的东西

08:02.760 --> 08:03.760
所以说

08:03.760 --> 08:05.760
虽然说这个第二种方式

08:05.760 --> 08:07.760
也可以实现同样的效果

08:07.760 --> 08:08.760
但是

08:08.760 --> 08:10.760
它就是没有地种方式好

08:10.760 --> 08:11.760
没有用代理好

08:11.760 --> 08:13.760
你看正确的值

08:13.760 --> 08:14.760
没问题

08:14.760 --> 08:15.760
两种方式都可以

08:15.760 --> 08:18.760
正确的值也没问题

08:18.760 --> 08:20.760
你看这里

08:20.760 --> 08:21.760
这边也没问题

08:21.760 --> 08:22.760
对吧

08:22.760 --> 08:23.760
一边问题

08:23.760 --> 08:24.760
但是用代理

08:24.760 --> 08:26.760
肯定是最好的

08:26.760 --> 08:28.760
这就是关于这么一个例子

08:28.760 --> 08:30.760
我相信以后

08:30.760 --> 08:32.760
随着支持ES6的

08:32.760 --> 08:34.760
流量器越来越普遍

08:34.760 --> 08:35.760
而现在丢半半的流量器

08:35.760 --> 08:37.760
越来越慢慢被淘汰

08:37.760 --> 08:39.760
那么代理肯定是在ES6里面

08:39.760 --> 08:41.760
做一个重要的一块内容

08:41.760 --> 08:43.760
可以大方一彩

08:43.760 --> 08:44.760
这一张

08:44.760 --> 08:45.760
咱们代理于反射

08:45.760 --> 08:46.760
就讲到这了

08:46.760 --> 08:47.760
其实你了解这一张

08:47.760 --> 08:48.760
特别简单

08:48.760 --> 08:49.760
你只要把反射搞清楚了

08:49.760 --> 08:51.760
你代理自然搞清楚了

08:51.760 --> 08:53.760
它可以重写反射的那边东西

08:53.760 --> 08:55.760
这是关于代理和反射

