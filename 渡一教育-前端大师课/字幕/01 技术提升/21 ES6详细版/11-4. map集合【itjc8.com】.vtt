WEBVTT

00:00.560 --> 00:03.840
这就开始我们来讲这个map集合

00:03.840 --> 00:07.600
map集合 讲之前 我说要补充点知识

00:07.600 --> 00:11.280
就是之前讲set集合的时候 我一个地方忘了说了

00:11.280 --> 00:14.520
就是set集合里边它有一个属性

00:14.520 --> 00:18.840
有一个属性叫做size属性

00:18.840 --> 00:21.480
那么这个属性它是指的是什么意思呢

00:21.480 --> 00:26.440
就是获取set集合中的元素数量

00:26.440 --> 00:29.840
有多少个数据了现在 我忘了说这个了

00:30.000 --> 00:32.280
给它看一下吧 看一下就行了

00:32.280 --> 00:33.520
对 很简单

00:33.520 --> 00:38.480
这个size属性 我们在这里下面输出一句话

00:38.480 --> 00:42.160
总数 总数为 为多少呢

00:42.160 --> 00:45.520
就是se.size 就是属性值

00:45.520 --> 00:48.080
保存一下 咱们运行出来看一下

00:48.080 --> 00:52.240
特别简单 点右键检查

00:52.240 --> 00:55.560
这里呢 总数为4 对吧 总数为4

00:55.560 --> 00:58.000
而且这个size属性大家要发现

00:58.000 --> 01:00.640
它这个东西你是不能复职的

01:00.800 --> 01:02.240
比方说我们给

01:02.240 --> 01:05.480
像输出的n次属性你是可以复职的 对吧

01:05.480 --> 01:08.160
这个size属性你是不能复职的 你复职没用

01:08.160 --> 01:09.720
你看 复职没用

01:09.720 --> 01:11.400
就说明它是一个止读的

01:11.400 --> 01:12.760
size属性是一个止读的

01:12.760 --> 01:17.640
你无法复职 size属性 止读属性

01:17.640 --> 01:21.640
无法复职 无法重新复职

01:21.640 --> 01:23.120
那么这个玩意它到底是啥呢

01:23.120 --> 01:25.240
其实我如果说把这个set打印出来的话

01:25.240 --> 01:27.520
大家可以看得更清楚

01:27.520 --> 01:33.120
输出 size 输出个se

01:33.120 --> 01:34.760
好 那么咱们把这个set输出

01:34.760 --> 01:35.680
输出过后给你看一下

01:35.680 --> 01:37.240
它里面不是一个size属性吗

01:37.240 --> 01:40.480
这个size属性后面有三个点 见过没

01:40.480 --> 01:41.960
见过没 这个玩意是啥

01:41.960 --> 01:43.800
它下面已经给你提示了 对吧

01:43.800 --> 01:46.040
啥 它怎么让你点击过后

01:46.040 --> 01:49.800
它就会调用属性的getter

01:49.800 --> 01:51.240
是不是一个getter

01:51.240 --> 01:53.320
就是一个访问器属性 对吧

01:53.320 --> 01:54.680
是一个访问器属性

01:54.680 --> 01:57.120
所以说这个属性它是动态的读取

01:57.120 --> 01:58.880
它里面有多少个元素的

01:58.880 --> 02:01.120
点击过它 它才会计算

02:01.120 --> 02:03.840
那如果说你听了我们之前讲的

02:03.840 --> 02:06.160
就上一颗讲的那个手写set的话

02:06.160 --> 02:08.000
如果说你要把size属性实现的话

02:08.000 --> 02:08.760
也非常简单

02:08.760 --> 02:10.200
如果说没听的话就算了

02:10.200 --> 02:13.240
因为扩展课程的话是可听可不听的

02:13.240 --> 02:15.880
好 那么这里我们如果说你要手写

02:15.880 --> 02:17.920
就是把实现的话 size

02:17.920 --> 02:19.000
那么应该怎么实现

02:19.000 --> 02:21.200
是不是get size 对吧

02:21.240 --> 02:23.200
是不是要这样子实现

02:23.200 --> 02:25.680
get size

02:25.680 --> 02:27.880
诶 咋写的 这样子写的

02:27.880 --> 02:28.720
get size

02:28.720 --> 02:29.640
那么这里返回咋

02:29.640 --> 02:32.520
直接返回 this data.nance

02:32.520 --> 02:33.840
对吧 就完事了

02:33.840 --> 02:36.080
那么你不写set

02:36.080 --> 02:37.080
因为它只读的

02:37.080 --> 02:39.840
对吧 就可以实现一模一样的效果

02:39.840 --> 02:44.000
OK 这是关于之前给大家补充一点

02:44.000 --> 02:47.960
好 接下来我们来讲这个map集合

02:47.960 --> 02:50.720
es6除了增加了set集合之外

02:50.760 --> 02:52.200
它还考虑到一种场景

02:52.200 --> 02:55.480
就是坚值队的存处

02:55.480 --> 02:58.080
map集合就是专门用于

02:58.080 --> 03:05.440
用于存处多个坚值队数据

03:05.440 --> 03:07.600
比方说我们的消息头

03:07.600 --> 03:11.000
对吧 请求想用头里边

03:11.000 --> 03:12.520
不是有很多坚值队吗

03:12.520 --> 03:13.120
对吧

03:13.120 --> 03:14.720
那么这些坚值队数据

03:14.720 --> 03:17.160
就可以存放到map集合里边

03:17.160 --> 03:19.000
它专门来做这件事情的

03:19.000 --> 03:20.120
其实坚值队数据

03:20.120 --> 03:22.840
我们以前是用怎么来存处的

03:22.840 --> 03:24.440
没有map之前

03:24.440 --> 03:25.880
是用对象来存处的

03:25.880 --> 03:26.480
对吧

03:26.480 --> 03:31.120
在map出现之前

03:31.120 --> 03:35.200
我们使用的是对象的方式

03:35.200 --> 03:38.000
来存处坚值队

03:38.000 --> 03:39.280
好 坚是什么呢

03:39.280 --> 03:42.800
坚就是属性名

03:42.800 --> 03:45.240
坚是属性名

03:45.240 --> 03:47.920
值呢 就是属性值

03:47.920 --> 03:48.320
对吧

03:48.360 --> 03:49.400
回忆一下

03:49.400 --> 03:50.560
对象里边是不是坚

03:50.560 --> 03:52.080
我们就可以认为它是属性名

03:52.080 --> 03:54.520
值呢 就是属性值

03:54.520 --> 03:55.000
对吧

03:55.000 --> 03:56.320
可以用这样的方式来存处

03:56.320 --> 03:56.880
这样子的

03:56.880 --> 03:58.720
因为坚值队的数据集合

03:58.720 --> 03:59.960
有这么一个特点

03:59.960 --> 04:03.040
坚值队的数据集合的特点

04:03.040 --> 04:06.640
坚值队数据集合的特点

04:06.640 --> 04:07.360
就是什么

04:07.360 --> 04:11.320
坚不可重复

04:11.320 --> 04:12.120
对不对

04:12.120 --> 04:13.640
坚持不可重复的

04:13.640 --> 04:15.680
我们以前没有map集合之前

04:15.680 --> 04:17.000
是用对象来存处的

04:17.080 --> 04:18.720
但是对象存处建队的话

04:18.720 --> 04:22.000
会如果说用对象来存处一个集合的话

04:22.000 --> 04:23.680
会出现那么一个问题

04:23.680 --> 04:27.160
对象使用对象存处

04:27.160 --> 04:29.280
存处有以下问题

04:29.280 --> 04:30.880
这下面的问题

04:30.880 --> 04:31.920
我一个个说

04:31.920 --> 04:32.920
这些问题

04:32.920 --> 04:34.920
它在某些场景下面就不是问题

04:34.920 --> 04:36.800
所以说你大胆的使用对象就行了

04:36.800 --> 04:39.560
在某些场景下面它就是一个问题了

04:39.560 --> 04:40.400
我们先说完

04:40.400 --> 04:41.880
大家再来看

04:41.880 --> 04:42.880
用对象来存处的话

04:42.880 --> 04:44.120
有哪些问题呢

04:44.160 --> 04:45.520
第一个问题就是

04:45.520 --> 04:50.040
建名只能是字符串

04:50.040 --> 04:51.240
那么现在多了一个符号了

04:51.240 --> 04:51.600
对吧

04:51.600 --> 04:52.960
无非再多一个符号

04:52.960 --> 04:54.880
或符号吗

04:54.880 --> 04:55.800
以前还没有符号

04:55.800 --> 04:57.720
以前只能是字符串

04:57.720 --> 04:58.680
因为坚是啥

04:58.680 --> 05:00.200
坚就是属性的名字

05:00.200 --> 05:00.920
坚值队吗

05:00.920 --> 05:01.320
对吧

05:01.320 --> 05:02.040
坚值队是啥

05:02.040 --> 05:04.240
坚值队就是key

05:04.240 --> 05:05.320
叫做key

05:05.320 --> 05:06.240
value

05:06.240 --> 05:07.080
key是件

05:07.080 --> 05:08.200
value是值

05:08.200 --> 05:09.320
pair

05:09.320 --> 05:10.960
坚值队

05:10.960 --> 05:12.960
比方说我们班上有很多学生

05:13.000 --> 05:13.840
学生的件是啥呢

05:13.840 --> 05:15.000
可以是学号

05:15.000 --> 05:16.120
学生的值是啥呢

05:16.120 --> 05:17.680
就是学生的一个对象

05:17.680 --> 05:19.280
一个学生信息

05:19.280 --> 05:21.520
坚值队以前能用对象来存处的话

05:21.520 --> 05:22.960
件只能是属性名

05:22.960 --> 05:25.600
如果说你要用其他的类型来作为件的话

05:25.600 --> 05:27.680
它都会把它转换成字符串

05:27.680 --> 05:28.760
再来存处

05:28.760 --> 05:29.000
对吧

05:29.000 --> 05:31.440
这是之前的对象的存处的一些问题

05:31.440 --> 05:32.880
那么另外一个问题

05:32.880 --> 05:33.800
就是

05:33.800 --> 05:41.440
获取数据的数量不方便

05:41.440 --> 05:42.520
无法非常方便的

05:42.560 --> 05:43.440
获取数据的数量

05:43.440 --> 05:45.360
就比方说我对象里面存了很多数据

05:45.360 --> 05:45.560
对吧

05:45.560 --> 05:46.680
都是用属性名

05:46.680 --> 05:47.120
属性值

05:47.120 --> 05:48.720
属性名属性值来存处的

05:48.720 --> 05:50.920
那么一共存了多少个数据呢

05:50.920 --> 05:52.720
你是不是一下子反应不过来

05:52.720 --> 05:52.960
对吧

05:52.960 --> 05:54.480
一下子没法一下子拿到

05:54.480 --> 05:55.560
你要通过什么

05:55.560 --> 05:57.240
object车叫keys

05:57.240 --> 05:57.440
对吧

05:57.440 --> 05:59.000
拿到它所有的件

05:59.000 --> 06:02.800
所有的就是属性的属性的数组

06:02.800 --> 06:04.280
然后再求数组的长度

06:04.280 --> 06:06.320
你在用这种方式才能知道

06:06.320 --> 06:08.400
它里面有多少个属性

06:08.400 --> 06:09.400
获取数据的数量

06:09.400 --> 06:10.680
其实就获取啥

06:10.720 --> 06:12.680
或许它里面有多少个属性

06:12.680 --> 06:15.480
你倒是能够解决件

06:15.480 --> 06:16.480
件是不可能重复的

06:16.480 --> 06:16.760
对吧

06:16.760 --> 06:17.760
用对象来存处的话

06:17.760 --> 06:19.440
因为属性名是唯一的

06:19.440 --> 06:21.560
所以说件倒是不能重复的

06:21.560 --> 06:22.920
它是不可能重复的

06:22.920 --> 06:24.840
但是它只能是支付串

06:24.840 --> 06:26.320
就会造成一些问题

06:27.320 --> 06:28.800
然后还有什么问题呢

06:28.800 --> 06:31.880
用对象来存处的话

06:31.880 --> 06:33.720
还有这么一些问题

06:33.720 --> 06:38.080
就是属性名

06:38.080 --> 06:39.720
就件的名字

06:39.760 --> 06:46.080
建名容易跟圆形上的

06:46.080 --> 06:49.320
圆形上的名称冲突

06:49.320 --> 06:51.480
你知道对象它是有圆形链的

06:51.480 --> 06:51.960
对不对

06:51.960 --> 06:52.960
它是有圆形链的

06:52.960 --> 06:53.200
OK

06:53.200 --> 06:56.240
那我去用一个属性名的话

06:56.240 --> 06:57.320
那么比较一个属性名

06:57.320 --> 06:58.080
是一个关键字

06:58.080 --> 07:00.080
或者是圆形链上的一个特有的方法

07:00.080 --> 07:03.240
它就会导致圆形链上的东西被覆盖掉

07:03.240 --> 07:05.000
都会造成这些问题

07:05.000 --> 07:06.440
都会造成这些问题

07:06.440 --> 07:07.600
那么以前用对象

07:07.600 --> 07:08.280
以前没办法

07:08.280 --> 07:09.280
只能用对象存处

07:09.280 --> 07:12.600
除非我们自己去手动的去实现一个Map集合

07:12.600 --> 07:13.320
可不可以实现

07:13.320 --> 07:14.240
我们后面有一些课

07:14.240 --> 07:16.400
专门来讲手动如何来实现Map

07:16.400 --> 07:19.960
能实现只不过比较麻烦一点

07:19.960 --> 07:23.160
于是ES6就专门来给我们提供了一个集合

07:23.160 --> 07:25.400
就是Map集合来解决这样的问题

07:25.400 --> 07:28.880
以后我们到底是用对象来存处建制队

07:28.880 --> 07:30.640
还是用Map来存处建制队

07:30.640 --> 07:31.600
是这样子的

07:31.600 --> 07:34.440
如果说你看到一个东西

07:34.440 --> 07:36.120
它是一个完整的东西

07:36.120 --> 07:38.440
它构成了一个完整的整体

07:38.640 --> 07:41.040
那么它用对象来存处

07:41.040 --> 07:42.720
比方说一个人

07:42.720 --> 07:44.920
一个人的信息是不是有很多建制队

07:44.920 --> 07:46.240
新民 新民的子

07:46.240 --> 07:47.640
年龄 年龄的子

07:47.640 --> 07:48.560
新别 新民的子

07:48.560 --> 07:49.680
是不是有很多建制队

07:49.680 --> 07:50.960
但是这些信息

07:50.960 --> 07:53.960
共同来描述一个完整的整体

07:53.960 --> 07:55.120
少一个都不行

07:55.120 --> 07:57.960
少一个人的信息是不完整的

07:57.960 --> 07:59.440
明白我的意思吗

07:59.440 --> 08:04.200
而且这个信息是不能够属意的添加和删除的

08:04.200 --> 08:07.120
那么这种情况下适合对象

08:07.160 --> 08:09.120
因为它表达的是一个完整的整体

08:10.160 --> 08:10.600
能听懂吗

08:10.600 --> 08:11.520
这个需要大家理解

08:12.720 --> 08:14.240
另外一种情况就是说

08:14.240 --> 08:16.200
我有一些数据

08:16.200 --> 08:17.600
那么这些数据是建制队

08:17.600 --> 08:19.760
但是我又可能会随意的增加

08:19.760 --> 08:21.720
随意的删除

08:21.720 --> 08:24.920
少一个了我整个还是没问题的

08:24.920 --> 08:26.320
多一个了整个也没问题

08:26.320 --> 08:29.120
那么这种情况下就适合用Map

08:29.120 --> 08:30.160
比方说什么呢

08:30.160 --> 08:33.440
比方说咱们的字典

08:33.440 --> 08:35.640
字典里边比方说它的一个

08:37.600 --> 08:39.520
一个拼音下面对应很多文字

08:39.520 --> 08:39.840
对吧

08:39.840 --> 08:41.000
这就是个建制队

08:41.000 --> 08:41.480
建制什么

08:41.480 --> 08:42.760
建制就是它的拼音

08:42.760 --> 08:44.200
文字就是后面的一个数据

08:44.200 --> 08:44.360
对吧

08:44.360 --> 08:45.560
就是个建制队

08:45.560 --> 08:48.040
那么你少一个拼音它还是一个字典

08:48.040 --> 08:49.800
你多一个拼音你还是个字典

08:49.800 --> 08:50.520
对吧

08:50.520 --> 08:52.040
它不存在说什么

08:52.040 --> 08:52.880
你少了一个

08:52.880 --> 08:54.640
感觉就是完全没法用了

08:54.640 --> 08:56.320
不存在这样的问题

08:56.320 --> 08:57.080
再比方说

08:57.080 --> 08:58.760
像什么消息头里边

08:58.760 --> 08:59.880
琴球头里边

08:59.880 --> 09:01.000
不是有很多现在对吗

09:01.000 --> 09:02.600
那这里边可以多一些

09:02.600 --> 09:03.640
可以自己定义一些

09:03.640 --> 09:04.520
可以自己加一些

09:04.520 --> 09:05.480
可以随意删除一些

09:05.480 --> 09:06.320
修改一些

09:06.360 --> 09:08.600
那么这些就比较适合

09:08.600 --> 09:10.920
它更加像一个集合

09:10.920 --> 09:11.760
因为集合是什么

09:11.760 --> 09:13.320
就可以加东西

09:13.320 --> 09:14.280
然后可以删除东西

09:14.280 --> 09:14.640
对吧

09:14.640 --> 09:15.800
这才像一个集合

09:15.800 --> 09:16.080
对吧

09:16.080 --> 09:17.600
它更加像一个集合

09:17.600 --> 09:20.080
那么就可以使用Map来存处

09:20.080 --> 09:21.920
这是什么时候使用

09:21.920 --> 09:22.640
使用对象

09:22.640 --> 09:24.520
什么时候使用Map

09:24.520 --> 09:25.360
那么以前没办法

09:25.360 --> 09:26.440
以前只能使用对象

09:26.440 --> 09:27.720
那现在多了一个Map了

09:27.720 --> 09:30.960
就可以在我们需要存处建制队集合的时候

09:30.960 --> 09:34.040
使用Map会更加方便一点

09:34.040 --> 09:34.200
好

09:34.200 --> 09:34.760
咱们来看一下

09:34.800 --> 09:36.800
Map怎么来使用

09:36.800 --> 09:37.720
第一个

09:37.720 --> 09:40.760
如何创建Map

09:40.760 --> 09:41.360
如何创建

09:41.360 --> 09:42.720
我们一个个说

09:42.720 --> 09:45.080
创建Map使用这种方式

09:45.080 --> 09:46.960
六一个Map构造函数

09:46.960 --> 09:49.160
那么这样子就创建了一个

09:49.160 --> 09:54.360
创建一个空的Map

09:54.360 --> 09:56.480
其实这个单词又很有意思

09:56.480 --> 09:57.400
你要说如果说

09:57.400 --> 09:59.560
用我们中文来解释的话

09:59.560 --> 10:00.640
set是啥意思

10:00.640 --> 10:02.160
set不是设置吗

10:02.160 --> 10:04.280
为什么设置变成一个集合

10:04.280 --> 10:06.040
因为set它还有一个意思

10:06.040 --> 10:08.600
它还有一堆的意思

10:08.600 --> 10:11.320
比方说我这里有一堆书

10:11.320 --> 10:13.120
set a book

10:13.120 --> 10:14.160
一堆书

10:14.160 --> 10:15.600
那么它里边还包含了一种

10:15.600 --> 10:16.520
不重复的干

10:16.520 --> 10:18.040
不重复的含义在里边

10:18.040 --> 10:19.560
就是用中文的话

10:19.560 --> 10:21.680
就没有对应的词汇

10:21.680 --> 10:23.880
那么Map除了有地图的意思

10:23.880 --> 10:24.960
还有什么意思呢

10:24.960 --> 10:26.280
还有一个就是映射

10:26.280 --> 10:27.400
你看我们之前的数组里边

10:27.400 --> 10:28.560
不是一个Map方法吗

10:28.560 --> 10:29.520
不就是映射吗

10:29.520 --> 10:30.080
对不对

10:30.080 --> 10:32.280
从一个东西映射到另一个东西

10:32.320 --> 10:34.480
那么映射其实就是包含了一种

10:34.480 --> 10:35.960
建置队的映射

10:35.960 --> 10:37.280
从一个唯一的一个键

10:37.280 --> 10:39.080
比方说ID就映射到一个对象

10:39.080 --> 10:40.880
或者是映射到一些其他信息

10:40.880 --> 10:42.360
那就是建置队

10:42.360 --> 10:45.600
因此Map在这里有一个映射的意思

10:45.600 --> 10:47.280
那么这里可以通过6一个Map

10:47.280 --> 10:48.640
创建一个空的Map

10:48.640 --> 10:49.720
就里边没数据

10:49.720 --> 10:51.520
来我们来看一下吧

10:51.520 --> 10:56.150
test

10:56.150 --> 10:57.990
好 这里我们6一个Map

10:57.990 --> 10:58.390
对吧

10:58.390 --> 11:00.950
6一个Map 保存到

11:00.990 --> 11:04.310
mp1

11:04.310 --> 11:07.710
输出Map1

11:07.710 --> 11:10.540
运营出来

11:10.540 --> 11:11.340
检查

11:11.340 --> 11:12.420
看一下

11:12.420 --> 11:13.780
就创建了一个Map对象

11:13.780 --> 11:15.860
特别简单

11:15.860 --> 11:16.220
好

11:16.220 --> 11:18.020
然后接下来我们再继续看

11:18.020 --> 11:19.060
那么我们如果说

11:19.060 --> 11:20.940
不想创建一个空的Map对象

11:20.940 --> 11:22.100
我们想创建一个

11:22.100 --> 11:24.900
就是里边一开始有包含内容的

11:24.900 --> 11:25.780
这么一个Map对象

11:25.780 --> 11:26.860
那怎么创建的

11:26.860 --> 11:30.420
那这里边也要写上这么一个

11:30.420 --> 11:32.060
atorator

11:32.060 --> 11:33.260
atorable

11:33.380 --> 11:35.220
跟那个set是不是差不多的

11:35.220 --> 11:38.300
创建一个具有

11:38.300 --> 11:43.860
初始内容的Map

11:43.860 --> 11:45.100
一个集合

11:45.100 --> 11:47.140
然后初始内容试杂了

11:47.140 --> 11:52.140
初始内容来自于

11:52.140 --> 11:54.820
可迭代对象

11:54.820 --> 11:59.380
每一次迭代的结果

11:59.380 --> 12:03.660
但是他要求

12:03.660 --> 12:07.180
每一次迭代的结果

12:07.180 --> 12:10.460
必须是一个

12:10.460 --> 12:11.020
嗯

12:11.020 --> 12:13.300
这东西叫做

12:13.300 --> 12:14.900
必须是一个数组

12:14.900 --> 12:19.260
必须是一个长度为2的数组

12:19.260 --> 12:23.780
数组第一项表示键

12:23.780 --> 12:28.020
数组的第二项表示值

12:28.060 --> 12:29.420
因为他现在是兼职对

12:29.420 --> 12:31.420
每一个数据他有两个部分

12:31.420 --> 12:32.580
一个是键

12:32.580 --> 12:34.180
一个是值

12:34.180 --> 12:35.300
表示值

12:35.300 --> 12:36.900
因此他要求你这样做

12:36.900 --> 12:37.980
啥意思啊

12:37.980 --> 12:38.780
这啥意思

12:38.780 --> 12:39.740
你看着啊

12:39.740 --> 12:41.780
如果说我去创建一个Map的时候

12:41.780 --> 12:43.060
给他像set那样子

12:43.060 --> 12:43.700
给他一个数组

12:43.700 --> 12:44.660
他要蒙的

12:44.660 --> 12:45.900
他一下就蒙掉了

12:45.900 --> 12:47.420
你看我给他一个3

12:47.420 --> 12:48.260
356

12:48.260 --> 12:49.260
随便写个吧

12:49.260 --> 12:50.260
好保存啊

12:50.260 --> 12:50.740
你看一下

12:52.740 --> 12:54.340
他说他呢

12:54.340 --> 12:57.460
他说你这个给他的就是

12:57.540 --> 12:59.700
attractor

12:59.700 --> 13:00.860
这个3呢

13:00.860 --> 13:03.460
他也他无法对这个3呢

13:03.460 --> 13:04.940
是无法进行迭代的

13:04.940 --> 13:06.180
是啥意思呢

13:06.180 --> 13:08.540
就是他要求了你给他这个数组

13:08.540 --> 13:10.020
你给他的是一个可迭代的东西

13:10.020 --> 13:11.900
那我给他那个数组是不是可以迭代的

13:11.900 --> 13:12.020
好

13:12.020 --> 13:13.900
那么他就一项一项取出来看

13:13.900 --> 13:15.860
他先把这个3取出来

13:15.860 --> 13:17.620
那么3取出来就蒙了

13:17.620 --> 13:19.700
我这个拿到这个3过后呢

13:19.700 --> 13:20.300
我要把

13:20.300 --> 13:22.220
因为他每一项是个键子队

13:22.220 --> 13:23.420
有键有值

13:23.420 --> 13:24.420
那么光拿到一个3

13:24.420 --> 13:26.700
我知道这个3是键还是值呢

13:26.700 --> 13:28.060
那如果它是键的话

13:28.060 --> 13:29.260
它值是啥

13:29.260 --> 13:29.980
如果它是值的话

13:29.980 --> 13:30.660
它键是啥

13:30.660 --> 13:31.860
是不是就蒙了

13:31.860 --> 13:32.260
对吧

13:32.260 --> 13:33.700
他就搞不清楚了

13:33.700 --> 13:34.980
所以说他内部的实现

13:34.980 --> 13:36.380
是这样子的实现的

13:36.380 --> 13:38.940
他先把他每一项拿出来

13:38.940 --> 13:41.340
而且要求他每一项呢

13:41.340 --> 13:43.500
也是一个可迭代的对象

13:43.500 --> 13:45.620
那么他第一次迭代的东西就是键

13:45.620 --> 13:47.180
第二次迭代的东西就是值

13:47.180 --> 13:48.100
所以说我们通常呢

13:48.100 --> 13:49.700
是把他每一项写成一个数组

13:50.980 --> 13:51.540
比方说啊

13:53.660 --> 13:54.620
哎

13:54.620 --> 13:55.460
这是键

13:55.460 --> 13:56.660
这是值

13:56.660 --> 13:57.220
第二项

13:58.580 --> 13:59.500
这是键

13:59.500 --> 14:00.660
这是值

14:00.660 --> 14:01.260
第三项

14:02.900 --> 14:03.980
这是键

14:03.980 --> 14:04.740
这是值

14:04.740 --> 14:06.020
明白这个意思吗

14:06.020 --> 14:06.740
啊

14:06.740 --> 14:08.140
你要这么去传递

14:08.140 --> 14:08.340
好

14:08.340 --> 14:09.300
这么去传递过后

14:09.300 --> 14:09.780
我们看一下

14:10.780 --> 14:11.940
他就映射出来了

14:11.940 --> 14:12.660
他映射出来了

14:12.660 --> 14:13.380
键是A

14:13.380 --> 14:15.700
他第一项是键为A

14:15.700 --> 14:16.580
值为3

14:16.580 --> 14:18.340
第二项是键为B

14:18.340 --> 14:19.860
值为4

14:19.860 --> 14:21.460
第三项是键为C

14:21.460 --> 14:22.540
值为5

14:22.540 --> 14:23.460
对吧

14:23.460 --> 14:25.420
他就这样给显示出来了

14:25.420 --> 14:27.060
没问题吧

14:27.060 --> 14:28.540
要这样子传递啊

14:28.540 --> 14:30.020
他读的时候是怎么读的啊

14:30.020 --> 14:31.020
我再说一次他怎么读的

14:31.020 --> 14:32.420
他是这样子来读的

14:32.420 --> 14:35.660
他首先便利给他的这个可迭代对象

14:35.660 --> 14:37.260
进行迭代

14:37.260 --> 14:37.500
好

14:37.500 --> 14:38.420
每一次迭代呢

14:38.420 --> 14:40.900
就是就是映射中的一项

14:40.900 --> 14:42.460
他要形成映射

14:42.460 --> 14:43.060
比方说啊

14:43.060 --> 14:44.340
他目前是空的映射

14:44.340 --> 14:44.660
对吧

14:44.660 --> 14:45.420
空的映射

14:45.420 --> 14:47.020
他最终会形成什么映射

14:47.020 --> 14:47.380
A

14:47.380 --> 14:48.700
映射为3B

14:48.700 --> 14:50.260
映射为4C

14:50.260 --> 14:51.420
映射为5

14:51.420 --> 14:52.540
他形成这么一个映射

14:52.580 --> 14:53.300
这是第一项

14:53.300 --> 14:53.820
这是第二项

14:53.820 --> 14:54.580
这是第三项

14:54.580 --> 14:54.900
对吧

14:54.900 --> 14:56.820
他这样子形成这么一种结果

14:56.820 --> 14:58.620
那他怎么来形成这个结果的呢

14:58.620 --> 15:00.940
他首先的迭代这个数组

15:00.940 --> 15:04.340
把数组的第一把数组的第一项拿出来

15:04.340 --> 15:04.780
拿出来

15:04.780 --> 15:05.780
当然不一定是数组啊

15:05.780 --> 15:07.380
只要是可迭代的就行

15:07.380 --> 15:07.540
好

15:07.540 --> 15:08.220
拿出来

15:08.220 --> 15:10.260
那么看一下他是不是能迭代

15:10.260 --> 15:11.460
如果说他不能迭代的话

15:11.460 --> 15:12.980
那么直接爆错

15:12.980 --> 15:14.260
好像刚才那样子直接爆错

15:14.260 --> 15:16.460
刚才我们是不是直接把第一项给他写个3

15:16.460 --> 15:17.460
那3是不能迭代的

15:17.460 --> 15:18.700
所以他直接爆错

15:18.700 --> 15:20.020
如果说他可以迭代的话

15:20.020 --> 15:20.860
他怎么迭代的

15:20.900 --> 15:23.660
他把他第一次迭代的结果

15:23.660 --> 15:24.060
是不是

15:24.060 --> 15:27.540
第一次迭代的结果作为剑

15:27.540 --> 15:30.940
第二次迭代的结果作为值

15:30.940 --> 15:32.620
看看他是这样子来做的

15:32.620 --> 15:32.940
好

15:32.940 --> 15:33.260
然后呢

15:33.260 --> 15:34.740
又拿数组的下一项

15:34.740 --> 15:36.380
又把这一项进行迭代

15:36.380 --> 15:38.300
迭代第一次迭代的结果作为剑

15:38.300 --> 15:39.660
第二次迭代的结果作为值

15:39.660 --> 15:41.740
然后内部是这样子实现的

15:41.740 --> 15:42.220
原来的意思吧

15:42.220 --> 15:43.340
所以说这里边呢

15:43.340 --> 15:45.900
虽然说这里边也不要求你是数组

15:45.900 --> 15:46.300
但是呢

15:46.300 --> 15:48.460
你必须要是可以迭代的

15:48.460 --> 15:49.740
必须要是可以迭代的

15:49.780 --> 15:51.380
至少能要能够迭代两次

15:51.380 --> 15:53.060
所以说我这里写的简单一点

15:53.060 --> 15:55.900
就是要求的长度为二的数组

15:55.900 --> 15:57.540
我这里写的比较简单一点

15:57.540 --> 15:58.020
但是

15:58.020 --> 15:59.180
因为不好描述

15:59.180 --> 16:01.500
所以说我这里口述给大家说清楚

16:03.060 --> 16:05.420
这是关于初始化一个Map

16:05.900 --> 16:06.660
初始化一个Map

16:07.860 --> 16:08.020
好

16:08.020 --> 16:09.020
那么接下来我们再看

16:09.020 --> 16:10.780
如何来进行后续操作

16:10.780 --> 16:13.180
如何进行后续操作

16:13.180 --> 16:15.060
我们之后要操作这些Map

16:15.060 --> 16:15.980
怎么来操作呢

16:15.980 --> 16:18.260
他提供了这么一些方法

16:18.300 --> 16:19.740
第一个方法就是

16:19.740 --> 16:21.380
size

16:21.380 --> 16:22.980
跟那个set是一样的

16:22.980 --> 16:24.420
获取的指读书信

16:26.020 --> 16:29.500
获取当前Map中键的数量

16:31.300 --> 16:33.740
获取当前Map中键的数量

16:33.740 --> 16:33.940
好

16:33.940 --> 16:35.020
来吧

16:35.020 --> 16:35.980
我们这里输出

16:37.100 --> 16:38.900
npe.

16:38.900 --> 16:40.980
这就是总数

16:43.060 --> 16:44.500
npe.size

16:45.900 --> 16:47.060
保存

16:47.060 --> 16:48.580
你看这种数为三

16:48.580 --> 16:48.980
对吧

16:48.980 --> 16:50.060
一共有三项

16:51.060 --> 16:52.100
这是size属性

16:52.100 --> 16:52.980
当然同样的

16:52.980 --> 16:54.420
指读属性不能复制的

16:55.220 --> 16:55.460
好

16:55.460 --> 16:57.260
接下来再下一个

16:58.580 --> 17:00.060
就是add

17:00.060 --> 17:01.100
不是add

17:01.100 --> 17:02.900
set

17:04.220 --> 17:05.300
这个方法

17:05.300 --> 17:06.340
它是这样子的

17:06.340 --> 17:07.940
就是设置

17:07.940 --> 17:09.340
我们这是个方法

17:10.140 --> 17:10.980
这是键

17:11.820 --> 17:12.540
直

17:13.700 --> 17:16.460
设置一个键值队

17:17.500 --> 17:18.900
设置一个键值队

17:18.900 --> 17:21.220
就是键可以是任何类型

17:21.220 --> 17:22.580
键和值

17:22.580 --> 17:25.300
可以是任何类型

17:25.300 --> 17:26.620
那么这个对象就有区别了

17:26.620 --> 17:26.940
对吧

17:26.940 --> 17:27.820
对象的键是什么

17:27.820 --> 17:28.820
属性名

17:28.820 --> 17:30.660
属性名的它自然是指辅创

17:30.660 --> 17:33.460
那么这里的键是可以是任何类型的

17:33.460 --> 17:34.380
这就是set

17:34.380 --> 17:34.540
好

17:34.540 --> 17:35.860
咱们来看一下吧

17:35.860 --> 17:37.500
比方说我们npe

17:37.500 --> 17:38.260
可以点一个

17:38.260 --> 17:39.260
可以用set

17:39.260 --> 17:40.300
set里边比方说键

17:40.300 --> 17:42.060
我可以写上一个3

17:42.060 --> 17:42.860
一个数字

17:42.860 --> 17:43.500
值呢

17:43.500 --> 17:44.260
可以写上一个

17:44.260 --> 17:44.980
随便写个

17:44.980 --> 17:46.100
也写个数字

17:46.100 --> 17:46.900
没问题的

17:46.940 --> 17:47.740
没问题的

17:47.740 --> 17:49.620
咱们在下面输出

17:49.620 --> 17:50.580
下面输出

17:51.580 --> 17:52.340
保存

17:52.340 --> 17:53.260
你看一下

17:53.260 --> 17:54.660
所以多了一个3

17:54.660 --> 17:55.380
硬设到

17:55.380 --> 17:56.620
是6456

17:56.620 --> 17:57.100
对吧

17:57.100 --> 17:58.980
那么除了第一个是

17:58.980 --> 18:00.700
是那个就是数字之外

18:00.700 --> 18:02.220
我们还可以写个对象

18:02.220 --> 18:03.500
任何类型都可以

18:03.500 --> 18:04.860
任何类型都可以做一件

18:04.860 --> 18:05.460
你看

18:05.460 --> 18:06.780
把对象做一件

18:06.780 --> 18:07.900
然后然后指是这个

18:07.900 --> 18:10.140
当然指那也可以是任何类型

18:10.140 --> 18:12.180
这样子是不是灵活很多

18:12.180 --> 18:12.420
好

18:12.420 --> 18:14.020
这是关于set

18:14.020 --> 18:15.140
那么这里边有些细节

18:15.140 --> 18:15.900
大家要注意

18:17.100 --> 18:17.860
第一个细节

18:18.340 --> 18:20.860
就是因为在set里边

18:20.860 --> 18:21.820
在map里边

18:21.820 --> 18:23.700
键是不能重复的

18:23.700 --> 18:25.340
键是不能重复的

18:25.340 --> 18:26.620
如果说

18:26.620 --> 18:30.990
如果键不存在

18:30.990 --> 18:32.350
不存在

18:32.350 --> 18:35.230
则添加一项

18:35.790 --> 18:36.910
则添加一项

18:36.910 --> 18:37.830
你看刚才的场景

18:37.830 --> 18:39.190
是不是键是不存在的

18:39.190 --> 18:40.270
那你之前的键

18:40.270 --> 18:41.150
你有这个键吗

18:41.150 --> 18:41.750
是不是没有

18:41.750 --> 18:42.190
对吧

18:42.190 --> 18:42.870
是不存在的

18:42.870 --> 18:43.270
不存在

18:43.270 --> 18:43.590
OK

18:43.590 --> 18:44.590
我们添加一项

18:44.590 --> 18:46.630
因此你这里是不是多了一项

18:46.630 --> 18:47.950
多了一项

18:48.710 --> 18:48.950
好

18:48.950 --> 18:51.630
如果说键已经存在的话

18:51.630 --> 18:54.270
如果键已存在

18:54.270 --> 18:55.550
它不像set那样子

18:55.550 --> 18:56.470
就什么都不做

18:56.470 --> 18:56.990
对吧

18:56.990 --> 18:58.550
它有件事情要做

18:58.550 --> 19:01.790
则修改它的值

19:01.790 --> 19:03.750
它把它之前的值覆盖掉

19:03.750 --> 19:04.590
如果键已经存在

19:04.590 --> 19:05.590
它修改它的值

19:05.590 --> 19:06.150
所以说

19:06.150 --> 19:08.350
它为什么它的函数没有用add

19:08.350 --> 19:09.390
add表示增加

19:09.390 --> 19:10.030
对吧

19:10.030 --> 19:12.590
那么它这个没有用add

19:12.590 --> 19:14.190
说明它不一定增加

19:14.190 --> 19:15.190
不一定增加

19:15.190 --> 19:16.070
它是set

19:16.070 --> 19:17.990
它有可能会做修改

19:18.070 --> 19:18.710
它是set

19:18.710 --> 19:19.710
进行修改

19:19.710 --> 19:20.750
如果键已经存在

19:20.750 --> 19:21.550
就修改它的值

19:21.550 --> 19:22.790
那比方说我们在这里

19:22.790 --> 19:24.390
mp1set

19:24.390 --> 19:25.670
比方说a

19:25.670 --> 19:26.470
把这个a

19:26.470 --> 19:27.470
设置成为什么

19:27.470 --> 19:29.110
设置成为abc

19:29.110 --> 19:30.030
你看一下

19:30.030 --> 19:31.710
保存

19:31.710 --> 19:33.150
那你看a是变成abc了

19:33.150 --> 19:33.510
对吧

19:33.510 --> 19:34.990
第一项被修改掉了

19:34.990 --> 19:35.550
a在哪

19:35.550 --> 19:37.190
所以一开始我们给它复制了3

19:37.190 --> 19:38.550
到现在变成abc了

19:38.550 --> 19:38.790
对吧

19:38.790 --> 19:40.750
这是修改

19:40.750 --> 19:40.950
好

19:40.950 --> 19:42.230
那么这里呢

19:42.230 --> 19:43.190
要说一点

19:43.190 --> 19:45.670
它怎么来判断

19:45.670 --> 19:47.150
键是不是已经存在的

19:47.190 --> 19:48.550
它存在肯定要比较

19:48.550 --> 19:49.750
比较之前的键

19:49.750 --> 19:50.030
对吧

19:50.030 --> 19:51.710
跟它之前的键是不是相等

19:51.710 --> 19:52.750
它怎么来比较的

19:52.750 --> 19:54.470
比较键的方式

19:54.470 --> 19:59.630
比较键的方式和set

19:59.630 --> 20:00.470
相同

20:00.470 --> 20:02.110
就set是一样的

20:02.110 --> 20:02.830
set怎么比较

20:02.830 --> 20:03.830
它就怎么比较的

20:03.830 --> 20:05.910
所以说就是object是意思

20:05.910 --> 20:06.150
对吧

20:06.150 --> 20:08.430
但是正临和负临表示一样的

20:08.430 --> 20:09.590
是这么回事

20:09.590 --> 20:10.590
所以说你在这里

20:10.590 --> 20:12.310
如果说你在这里的

20:12.310 --> 20:13.870
再写这么一个

20:13.870 --> 20:16.430
再写这么一个字

20:17.430 --> 20:18.430
那么请问

20:19.670 --> 20:20.870
这个map里边

20:20.870 --> 20:22.670
最终会输出多少个数量

20:22.670 --> 20:26.180
数量是多少

20:26.180 --> 20:26.740
数量是多少

20:27.940 --> 20:28.380
来吧

20:28.380 --> 20:29.540
这里有三个

20:29.540 --> 20:30.420
对吧

20:30.420 --> 20:32.660
这里是不是加了一个四个

20:32.660 --> 20:32.820
好

20:32.820 --> 20:34.420
这里没有加修改了

20:34.420 --> 20:34.820
对吧

20:34.820 --> 20:36.060
还是四个

20:36.060 --> 20:37.460
这里是修改还是加呢

20:40.060 --> 20:40.780
修改还是加呢

20:41.820 --> 20:42.820
是不是还是加

20:42.820 --> 20:43.100
对吧

20:43.100 --> 20:44.260
一共有五个

20:44.260 --> 20:45.980
最终结果是五个

20:45.980 --> 20:46.540
为什么呢

20:46.580 --> 20:47.740
因为这两个对象

20:47.740 --> 20:49.420
看上去是一样的

20:49.420 --> 20:51.220
但是有些他们用的是对象

20:51.220 --> 20:52.340
对象以比较出来

20:52.340 --> 20:53.380
结果是什么

20:53.380 --> 20:54.340
比较的是地址

20:54.340 --> 20:54.620
对吧

20:54.620 --> 20:55.620
地址肯定是不一样的

20:55.620 --> 20:56.620
两个新的对象

20:56.620 --> 20:57.660
地址是不一样的

20:57.660 --> 20:59.220
所以说他认为是两个键

20:59.220 --> 21:01.220
如果说你要用对象做键的话

21:01.220 --> 21:02.620
我们往往是

21:02.620 --> 21:04.660
往往是这样子

21:04.660 --> 21:06.220
比较说我们用OB接

21:06.220 --> 21:07.140
用同一个地址

21:07.140 --> 21:08.340
那么这个地方

21:08.340 --> 21:10.940
它就会是长度为四了

21:10.940 --> 21:12.420
总数就为四

21:12.420 --> 21:13.420
没了意思吗

21:13.420 --> 21:14.820
总之你要知道两个键

21:14.820 --> 21:16.140
是不是相等的

21:16.260 --> 21:17.100
这是关于set

21:18.700 --> 21:20.300
好接下来我们来看

21:21.140 --> 21:21.940
还有就是get

21:23.620 --> 21:25.020
既然有set就有get

21:25.020 --> 21:28.620
get就是根据一个键

21:28.620 --> 21:29.900
得到一个值

21:31.460 --> 21:32.460
得到对应的值

21:33.660 --> 21:34.620
这个很简单

21:34.620 --> 21:36.420
你给它的键是从里边去找

21:36.420 --> 21:37.740
找到对应的值

21:37.740 --> 21:40.220
比方说我们这里输出

21:41.620 --> 21:42.140
get

21:42.860 --> 21:43.860
get什么呢

21:43.860 --> 21:44.740
get

21:45.740 --> 21:46.740
A

21:48.220 --> 21:49.220
get

21:49.220 --> 21:49.740
好

21:49.740 --> 21:50.900
那么比方说我们在这里

21:50.900 --> 21:53.060
map1.get

21:53.060 --> 21:54.060
A

21:54.060 --> 21:55.620
看一下A的值是多少

21:55.620 --> 21:57.660
说A的值是不是ABC

21:57.660 --> 21:58.020
对吧

21:58.020 --> 21:58.740
ABC

21:58.740 --> 21:59.540
就这么简单

21:59.540 --> 22:00.340
就是get

22:00.340 --> 22:02.860
那如果说你给它传了一个不存在的键

22:02.860 --> 22:04.060
自然而然是得到的是

22:04.060 --> 22:04.900
on-defend

22:04.900 --> 22:06.060
对吧

22:06.060 --> 22:07.820
这是关于这个get

22:08.660 --> 22:08.900
好

22:08.900 --> 22:09.900
那有同学说

22:09.900 --> 22:10.900
那么想想这个问题

22:10.900 --> 22:12.020
这个问题该怎么回答

22:13.180 --> 22:14.420
如果说map你不要有

22:14.420 --> 22:16.220
两个相同的键

22:16.220 --> 22:18.380
那你get的时候传了一个键进去

22:18.380 --> 22:19.860
比方说你用两个键都是A

22:19.860 --> 22:20.860
你传了一个A进去

22:20.860 --> 22:21.820
它得到了值是啥

22:21.820 --> 22:22.620
到底是第1个A的

22:22.620 --> 22:23.660
还有第2个A的

22:24.980 --> 22:27.530
回答一下这个问题

22:27.530 --> 22:28.930
来回答一下这个问题

22:30.050 --> 22:32.050
这个问题的本身就是个问题

22:32.050 --> 22:32.650
对吧

22:32.650 --> 22:34.290
因为map里边

22:34.290 --> 22:36.370
有没有可能出现相同的键

22:36.370 --> 22:38.170
是绝对不可能的

22:38.170 --> 22:41.170
因为键值对键不可重复

22:41.170 --> 22:42.730
如果说你在加数据的时候

22:42.730 --> 22:44.090
出现了相同的键的话

22:44.170 --> 22:45.010
它一定是后边的

22:45.010 --> 22:46.650
覆盖前面的值

22:46.650 --> 22:48.970
它不可能出现两个相同的键的

22:48.970 --> 22:50.770
这是关于这一块

22:50.770 --> 22:52.290
接下来我们看它的API

22:52.290 --> 22:54.130
还有个hass

22:54.130 --> 22:55.290
同样的道理

22:55.290 --> 22:56.370
hass

22:56.370 --> 22:57.130
是什么呢

22:57.130 --> 23:01.050
是判断某个键

23:01.050 --> 23:02.530
是否存在

23:02.530 --> 23:04.250
就判断键

23:04.250 --> 23:07.090
因为键才是最关键的东西

23:07.090 --> 23:08.170
值是可以重复的

23:08.170 --> 23:09.370
值重复无所谓

23:09.370 --> 23:10.290
随便你怎么重复

23:10.290 --> 23:12.570
键是不能重复的

23:12.570 --> 23:13.730
那么这里呢

23:13.810 --> 23:15.090
看一下hass

23:15.090 --> 23:18.210
是不是hass

23:18.210 --> 23:19.090
那么这里

23:19.090 --> 23:20.370
hass

23:20.370 --> 23:23.210
返回一个true或者是force

23:23.210 --> 23:24.170
那么如果不存在的话

23:24.170 --> 23:25.330
就返回force

23:25.330 --> 23:26.290
特别简单

23:26.290 --> 23:28.850
判断某个键是否存在

23:28.850 --> 23:29.770
还有呢

23:29.770 --> 23:32.090
还有是denet

23:32.090 --> 23:33.850
同样的是传一个键进去

23:33.850 --> 23:34.450
它是什么

23:34.450 --> 23:38.690
删除指定的键

23:38.690 --> 23:39.770
但删除成功就返回true

23:39.770 --> 23:41.690
删除不成功就返回force

23:41.690 --> 23:44.250
比方说咱们就在这里删除

23:44.250 --> 23:47.810
map1

23:47.810 --> 23:49.210
denet

23:49.210 --> 23:51.490
我们删除一个键

23:51.490 --> 23:52.810
删除就变成true了

23:52.810 --> 23:54.010
我们看一下map1

23:54.010 --> 23:55.650
是不是这个键就没了

23:55.650 --> 23:56.290
对就没了

23:56.290 --> 23:57.250
就这么简单

23:57.250 --> 23:59.370
如果说删除denet

23:59.370 --> 24:01.290
删除一个随便写一个

24:01.290 --> 24:02.170
返回force

24:02.170 --> 24:03.410
然后就什么都没做

24:03.410 --> 24:03.810
对吧

24:03.810 --> 24:05.290
就是这个

24:05.290 --> 24:06.010
删除

24:06.010 --> 24:06.530
那么同样的

24:06.530 --> 24:09.650
它还给我们提供了一个clear

24:09.690 --> 24:13.410
清空map

24:13.410 --> 24:15.090
咱们看一下clear怎么做

24:15.090 --> 24:18.210
map1 clear

24:18.210 --> 24:19.810
那么再看map1

24:19.810 --> 24:20.890
说了就没东西了

24:20.890 --> 24:22.570
就没东西了

24:22.570 --> 24:24.210
这就是size里面

24:24.210 --> 24:27.450
map里面如何来进行后续操作

24:27.450 --> 24:28.570
那么同样的对比一下

24:28.570 --> 24:30.650
跟之前的set进行的对比

24:30.650 --> 24:31.970
其实都是差不多的

24:31.970 --> 24:32.290
对吧

24:32.290 --> 24:33.370
都是差不多的

24:33.370 --> 24:35.290
那么为了要继续继续的看

24:35.290 --> 24:38.250
如何与输组进行互相转换呢

24:38.250 --> 24:39.490
我们来看一下

24:39.530 --> 24:41.810
如何来跟输组进行互相转换

24:42.930 --> 24:44.850
3和输组

24:45.610 --> 24:47.930
输组互相转换

24:48.450 --> 24:49.250
好来吧

24:50.050 --> 24:51.250
我们这里有一个map

24:51.250 --> 24:52.850
我们再新开一个

24:52.850 --> 24:53.650
新开一个

24:54.410 --> 24:55.330
有这么一个map

24:55.330 --> 24:56.290
我现在呢

24:56.290 --> 24:57.730
首先输组转成map

24:57.730 --> 24:58.370
是不是很简单

24:58.370 --> 24:58.890
就这样子

24:58.890 --> 24:59.170
对吧

24:59.170 --> 25:00.370
就把它转成map了

25:00.370 --> 25:01.410
那么我们要把它转为

25:01.410 --> 25:02.770
输组对应的格式

25:02.770 --> 25:05.370
比方说转成对应的格式

25:06.370 --> 25:08.370
比方说输组里面有些重复的

25:08.450 --> 25:09.770
有些重复的建设队

25:10.610 --> 25:11.810
有些重复的建设队

25:12.170 --> 25:12.930
C

25:13.250 --> 25:15.210
C为10

25:16.210 --> 25:18.610
那么我们现在要把它转换成为输组

25:18.610 --> 25:19.730
那怎么转换呢

25:19.730 --> 25:22.170
因为map本身也是可以迭代的

25:22.530 --> 25:23.610
你看一下map

25:23.810 --> 25:24.410
我们

25:24.610 --> 25:25.330
音音出来

25:25.330 --> 25:26.370
你看一下map本身

25:26.370 --> 25:27.610
它也是可以迭代的

25:28.610 --> 25:29.450
map本身

25:32.450 --> 25:33.290
那么这里

25:33.930 --> 25:34.850
下面看

25:34.850 --> 25:36.570
symbol attuator

25:36.570 --> 25:37.010
对吧

25:37.010 --> 25:38.290
它也是可以迭代的

25:38.370 --> 25:40.090
因此我们只需要去

25:40.090 --> 25:40.650
干嘛

25:41.450 --> 25:42.810
展开运输案幅

25:42.810 --> 25:43.770
展开就行了

25:43.770 --> 25:45.770
那就会把每一次迭代的结果

25:45.770 --> 25:46.770
放到输组里边

25:46.770 --> 25:47.730
那么我们来看一下

25:47.730 --> 25:49.090
它每一次迭代的结果

25:49.090 --> 25:49.810
是啥呢

25:49.810 --> 25:50.490
我们看一下

25:50.490 --> 25:51.410
通过这个输组里面

25:51.410 --> 25:52.610
就可以看到很清楚了

25:52.610 --> 25:53.970
它的每一次迭代结果

25:54.530 --> 25:55.490
你觉得是啥

25:55.490 --> 25:56.410
你觉得应该是啥

25:56.410 --> 25:57.450
按照我记得来说

25:58.330 --> 25:59.690
这个map的每一次迭代结果

25:59.690 --> 26:00.970
不就是这个玩意吗

26:00.970 --> 26:01.890
还能是啥呢

26:01.890 --> 26:03.050
它不就是这个玩意吗

26:03.050 --> 26:04.170
你看一下

26:04.170 --> 26:05.210
它每一次迭代的结果

26:05.210 --> 26:06.210
不就是这个玩意吗

26:06.210 --> 26:06.770
对吧

26:06.770 --> 26:07.410
输组里面

26:07.410 --> 26:09.890
每一项又是长度为二的输组

26:09.890 --> 26:10.450
对吧

26:10.450 --> 26:11.290
它只能是这个玩意

26:11.290 --> 26:12.330
还能是啥呢

26:12.330 --> 26:13.650
这就是它转换的输组

26:13.650 --> 26:14.530
特别简单

26:14.530 --> 26:17.210
当然它由于它是可以迭代的

26:17.210 --> 26:18.850
我就不具体说了

26:18.850 --> 26:20.650
因为我们之前sets说过一次的

26:20.650 --> 26:22.330
所以这里跟sets一样

26:23.530 --> 26:24.490
和sets一样

26:24.930 --> 26:25.890
和sets一样

26:26.330 --> 26:27.370
那么这样

26:27.370 --> 26:28.850
另外一个就是变力

26:28.850 --> 26:29.730
变力

26:29.930 --> 26:31.490
变力的话有两种方式

26:32.010 --> 26:35.010
一种是使用for25循环

26:36.010 --> 26:37.250
for25循环

26:37.530 --> 26:38.970
那么每一次变力

26:39.410 --> 26:40.250
变力

26:41.090 --> 26:44.090
每次迭代得到的是一个什么

26:44.090 --> 26:46.530
长度为二的输组

26:46.530 --> 26:48.050
就是for25循环

26:48.050 --> 26:50.490
每次迭代的得到的是一个长度为二的输组

26:50.490 --> 26:51.130
那么看一下

26:55.770 --> 26:57.730
每一次迭代输出item

26:58.250 --> 26:58.810
你看一下

26:58.810 --> 27:00.930
每次迭代是不是就是一个长度为二的输组

27:00.930 --> 27:01.530
对吧

27:02.010 --> 27:02.970
它还能是啥呢

27:02.970 --> 27:05.050
当然你是不是可以在这里进行解构

27:05.690 --> 27:07.050
能不能在这里进行解构

27:07.970 --> 27:08.330
来吧

27:08.330 --> 27:09.210
在这里减一解构

27:09.210 --> 27:10.450
我们之前说过解构

27:10.450 --> 27:11.330
key value

27:11.330 --> 27:12.410
是不是可以解构出来

27:12.410 --> 27:13.010
对吧

27:13.610 --> 27:14.170
key value

27:14.170 --> 27:14.610
你看

27:14.610 --> 27:16.730
输出a3c5b4

27:16.730 --> 27:17.210
对吧

27:17.210 --> 27:18.410
是不是可以在这里解构

27:18.930 --> 27:20.610
当然你不解构的话

27:20.610 --> 27:21.690
我们之前学过解构

27:21.690 --> 27:22.330
不解构的话

27:22.330 --> 27:24.490
是不是也可以用item.key

27:25.210 --> 27:26.890
然后这里叫item.

27:27.890 --> 27:28.490
别乱说

27:29.010 --> 27:29.690
别乱说

27:29.690 --> 27:30.570
item0

27:31.570 --> 27:32.450
item1

27:32.450 --> 27:32.850
对吧

27:32.850 --> 27:33.650
这是个输组

27:33.650 --> 27:33.890
对吧

27:33.890 --> 27:35.250
item每一项是个输组

27:35.250 --> 27:36.130
那么取出来的输组

27:36.170 --> 27:37.090
第一项就是键

27:37.090 --> 27:38.090
第二项就是纸

27:38.090 --> 27:39.090
当然我们解构了

27:39.090 --> 27:39.930
更加方便一点

27:39.930 --> 27:41.250
key value

27:41.610 --> 27:42.210
对不对

27:42.210 --> 27:42.970
没问题吧

27:43.130 --> 27:43.610
OK

27:43.610 --> 27:46.290
这是关于它的贩利

27:46.290 --> 27:47.250
for25便利

27:47.490 --> 27:49.450
那么如果说它不用for25便利

27:49.450 --> 27:51.010
用它的for1型也可以

27:51.010 --> 27:52.130
for1型便利

27:52.130 --> 27:53.410
那么通过毁掉

27:54.050 --> 27:56.330
通过毁掉函数便利

27:57.090 --> 27:58.330
那么通过毁掉函数便利

27:58.330 --> 27:59.130
它就有三个参数

27:59.130 --> 27:59.490
对吧

27:59.490 --> 28:00.690
第参数1

28:00.690 --> 28:04.010
参数1就是每一项的纸

28:04.850 --> 28:05.930
参数2

28:06.170 --> 28:08.290
是每一项的键

28:09.090 --> 28:10.210
参数3

28:10.450 --> 28:12.410
就是map本身

28:13.570 --> 28:14.970
格式也是三个参数

28:14.970 --> 28:15.570
一样的

28:15.570 --> 28:15.850
好

28:15.850 --> 28:16.370
咱们来看一下

28:18.210 --> 28:21.490
我们可以用map for each

28:21.690 --> 28:22.650
来进行便利

28:22.650 --> 28:23.530
有三个参数

28:23.530 --> 28:24.650
当然你要用几个

28:24.650 --> 28:25.250
就写几个

28:26.090 --> 28:27.730
第一个参数是它的值

28:27.730 --> 28:28.250
value

28:28.250 --> 28:29.090
这个参数是键

28:29.090 --> 28:31.970
第三个参数是它的map本身

28:33.010 --> 28:34.370
输出key

28:36.170 --> 28:36.810
value

28:36.810 --> 28:37.530
key

28:37.850 --> 28:38.450
map

28:39.010 --> 28:39.970
保存

28:40.210 --> 28:40.850
你看看

28:43.490 --> 28:44.570
这里MP

28:46.530 --> 28:47.010
你看看

28:47.010 --> 28:47.810
是不是一样的

28:47.810 --> 28:48.370
对吧

28:49.290 --> 28:50.570
直键

28:50.570 --> 28:51.450
直键

28:51.450 --> 28:52.370
map本身

28:53.450 --> 28:53.690
好

28:53.690 --> 28:54.050
就没了

28:54.050 --> 28:54.930
就没了

28:55.170 --> 28:56.530
一个用起来

28:56.530 --> 28:57.850
非常简单

28:57.850 --> 28:59.570
灵活的这么一个map

28:59.570 --> 29:00.730
map集合

29:00.730 --> 29:01.370
那么之后

29:01.370 --> 29:03.450
我们要存处什么一些键字队的话

29:03.450 --> 29:05.610
我们就完全可以使用它来进行存处了

29:05.690 --> 29:07.090
它专门给我们做了一个

29:07.090 --> 29:08.010
其实以前

29:08.010 --> 29:08.890
我记得

29:08.890 --> 29:10.450
我记得哪个第三方库

29:10.450 --> 29:11.890
它里边给我们做了一个map

29:11.890 --> 29:13.290
当时是自己利用

29:13.290 --> 29:15.330
现在当时的介石自己写了一个

29:15.330 --> 29:16.410
其实我们也会自己

29:16.410 --> 29:17.290
后边的游戏课

29:17.290 --> 29:19.330
我们也会教大家如何来自己写

29:19.330 --> 29:20.570
写它

29:20.570 --> 29:22.450
当然还是前点条件

29:22.450 --> 29:23.690
我们到时候再说吧

29:23.690 --> 29:25.890
再说手写map的时候再说

29:26.890 --> 29:27.050
好

29:27.050 --> 29:28.930
这是关于map集合的这些API

