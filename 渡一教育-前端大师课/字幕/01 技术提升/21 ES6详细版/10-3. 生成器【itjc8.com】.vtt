WEBVTT

00:01.200 --> 00:03.200
生成器

00:03.200 --> 00:07.200
生成器是本章的一个非常重要的知识

00:07.200 --> 00:11.200
这节课完了之后我还会讲一些例子

00:11.200 --> 00:15.200
讲生成器该怎么去在实际开发中进行应用

00:15.200 --> 00:19.200
另外这一节课的时间可能会比较长一点

00:19.200 --> 00:21.200
因为它是一个整体的知识我也不太好拆分

00:21.200 --> 00:25.200
所以说大家如果说看内容的话可以分段来看

00:25.200 --> 00:27.200
开一段休息一下跟着老师做一做

00:27.200 --> 00:29.200
然后再继续往后看

00:29.200 --> 00:33.200
它的内容复杂度难度可能比较高

00:33.200 --> 00:37.200
我个人认为的话应该是ES6课程里面

00:37.200 --> 00:39.200
难度最高的一节课了

00:39.200 --> 00:42.200
所以说第一希望大家引起重视

00:42.200 --> 00:43.200
它很重要

00:43.200 --> 00:45.200
第二它难度比较高

00:45.200 --> 00:46.200
一定要认真听

00:46.200 --> 00:49.200
而且尽量的多看几遍慢慢消化

00:49.200 --> 00:51.200
不要一口气把它吃完

00:51.200 --> 00:55.200
生成器它这里严重依赖之前我们讲的

00:55.200 --> 00:56.200
迭代器

00:56.200 --> 00:59.200
所以说你的前提条件得把迭代器搞清楚

01:00.200 --> 01:02.200
这个玩意其实很多初学者

01:02.200 --> 01:05.200
就特别是第一次接触生成器的人

01:05.200 --> 01:08.200
都会感觉到特别特别恶心

01:08.200 --> 01:10.200
怎么会有这么一个玩意

01:10.200 --> 01:12.200
但是有少量的同学

01:12.200 --> 01:14.200
他给我的反馈恰好相反

01:14.200 --> 01:16.200
他觉得这个玩意太舒服了

01:16.200 --> 01:17.200
太新奇了

01:17.200 --> 01:21.200
实际上这个生成器没有大家想象的

01:21.200 --> 01:22.200
那么的恶心

01:22.200 --> 01:24.200
也没有大家想象的那么的强大

01:24.200 --> 01:28.200
它在特定的场所可以解决一些问题

01:28.200 --> 01:31.200
特别是以后我们学习reactor的时候

01:31.200 --> 01:35.200
里边有一个地方就要大量的拥挡生成器

01:35.200 --> 01:38.200
如果说你对生成器这一块掌握的越牢靠

01:38.200 --> 01:40.200
那么到时候学reactor的时候

01:40.200 --> 01:41.200
学到那一块

01:41.200 --> 01:42.200
那一块是个很重要的知识

01:42.200 --> 01:44.200
不要认为那一块是个小知识

01:44.200 --> 01:45.200
是个很重要的知识

01:45.200 --> 01:47.200
那么学习reactor那一块的话

01:47.200 --> 01:48.200
就会非常的顺畅

01:48.200 --> 01:50.200
目前前端领域的话

01:50.200 --> 01:52.200
生成器这一块

01:52.200 --> 01:55.200
我观察到现象没有大规模的应用

01:55.200 --> 02:00.200
应用的最多的就是reactor那个地方

02:00.200 --> 02:03.200
不过我觉得这个生成器是大有可为的

02:03.200 --> 02:05.200
它里边的就是那种

02:05.200 --> 02:07.200
这种特殊的函数处理方式

02:07.200 --> 02:11.200
可以在某些场面发挥它的特殊作用

02:11.200 --> 02:13.200
所以说大家好好学一下

02:13.200 --> 02:16.200
说不准哪一天生成器就活了

02:16.200 --> 02:18.200
生成器是也是六推出的

02:18.200 --> 02:20.200
它推出这个东西的目的

02:20.200 --> 02:22.200
最初的目的非常单纯

02:22.200 --> 02:25.200
它认为我们之前写迭代器

02:25.200 --> 02:27.200
你们之前不是讲了两节课吗

02:27.200 --> 02:29.200
写迭代器最老火的是什么

02:29.200 --> 02:31.200
是自己去实现个迭代器

02:31.200 --> 02:34.200
其实迭代器拥起来没有那么老火

02:34.200 --> 02:35.200
拥起来就掉到那个时候

02:35.200 --> 02:36.200
方法就完了

02:36.200 --> 02:37.200
有啥老火的呢

02:37.200 --> 02:39.200
迭代器不就是掉到那个时候

02:39.200 --> 02:41.200
那个时候不断的交易就完事了

02:41.200 --> 02:43.200
不要拿到一个迭代器

02:43.200 --> 02:46.200
掉到那个时候得到下一个

02:46.200 --> 02:47.200
这没有什么好说的

02:47.200 --> 02:49.200
另外拂二不循环

02:49.200 --> 02:50.200
他要求可迭代对象

02:50.200 --> 02:52.200
这个东西也跟我们没关系

02:52.200 --> 02:53.200
你只要是一个可迭代对象

02:53.200 --> 02:54.200
我就迭代就完事了

02:54.200 --> 02:56.200
最老火的在哪呢

02:56.200 --> 02:58.200
最老火的在我们自己写迭代器

02:58.200 --> 02:59.200
对吧

02:59.200 --> 03:00.200
是不是我们自己要写一个

03:00.200 --> 03:01.200
自己去实现一个

03:01.200 --> 03:03.200
是不是这个地方老火

03:03.200 --> 03:05.200
因此生成器的出现了

03:05.200 --> 03:07.200
它是为了解决这样的问题的

03:07.200 --> 03:09.200
就是我们书写一个迭代器

03:09.200 --> 03:11.200
就像我们之前书写一个

03:11.200 --> 03:13.200
一个书主的迭代器

03:13.200 --> 03:15.200
一个书主的迭代器

03:16.200 --> 03:18.200
就这么简单的一个迭代器

03:18.200 --> 03:20.200
你看我们都写出这是啥

03:20.200 --> 03:22.200
很不好阅读的代码对吧

03:22.200 --> 03:23.200
因此它是为了解决

03:23.200 --> 03:24.200
这样的问题出现的

03:24.200 --> 03:26.200
它把迭代器这个协议

03:26.200 --> 03:27.200
搞定了之后

03:27.200 --> 03:29.200
我觉得这个这些写起来太恶心了

03:29.200 --> 03:31.200
于是搞出了这么一个生成器

03:31.200 --> 03:32.200
这么一个东西

03:32.200 --> 03:34.200
它是为最初的目的是

03:34.200 --> 03:36.200
为了帮助你更加方便的

03:36.200 --> 03:38.200
去书写迭代器

03:38.200 --> 03:41.200
以及迭代器创建函书

03:41.200 --> 03:43.200
因此生成器

03:43.200 --> 03:45.200
本职上你会看到

03:45.200 --> 03:47.200
生成器跟迭代器之间有很多的关联

03:47.200 --> 03:49.200
但是后来他一做的话

03:49.200 --> 03:51.200
他发现如果生成器还可以

03:51.200 --> 03:52.200
握出这么多的花样

03:52.200 --> 03:55.200
于是他开始增强了生成器的一些功能

03:55.200 --> 03:57.200
因此生成器本职

03:57.200 --> 03:59.200
跟迭代器有很强烈的关联

03:59.200 --> 04:01.200
并且他自己有自己特别的地方

04:01.200 --> 04:03.200
所以说我先把生成器

04:03.200 --> 04:05.200
跟迭代器的关系给大家讲一讲

04:05.200 --> 04:07.200
因为这一张本身的名字

04:07.200 --> 04:09.200
也是迭代器和生成器

04:09.200 --> 04:10.200
不要怪我啰嗦

04:10.200 --> 04:12.200
我主要是慢一点讲的

04:12.200 --> 04:14.200
都是为了让你们更加容易理解

04:14.200 --> 04:16.200
好 接下来我们来看一下

04:16.200 --> 04:18.200
什么是生成器

04:18.200 --> 04:22.220
什么是生成器

04:22.220 --> 04:24.220
什么是生成器

04:24.220 --> 04:30.590
生成器是一个

04:30.590 --> 04:32.590
通过构造函书

04:32.590 --> 04:34.590
哪个构造函书呢

04:34.590 --> 04:35.590
函书

04:35.590 --> 04:37.590
generator

04:37.590 --> 04:39.590
通过这个构造函书

04:39.590 --> 04:41.590
创建了对象

04:41.590 --> 04:42.590
这就是生成器

04:42.590 --> 04:44.590
但是很遗憾的是

04:44.590 --> 04:46.590
当然我们是不能创建的

04:46.590 --> 04:48.590
你希望想去留一个generator

04:48.590 --> 04:50.590
他会告诉你generator是不存在的

04:50.590 --> 04:52.590
但是实际上它是存在的

04:52.590 --> 04:53.590
它只能内部使用

04:53.590 --> 04:55.590
接着是引擎内部使用

04:55.590 --> 04:57.590
它通过这个构造函书generator

04:57.590 --> 04:58.590
创建了对象

04:58.590 --> 04:59.590
原来的意思吗

04:59.590 --> 05:01.590
这就是一个生成器

05:01.590 --> 05:03.590
然后生成器它有这么一个特点

05:03.590 --> 05:05.590
生成器

05:05.590 --> 05:09.590
既是一个迭代器

05:09.590 --> 05:10.590
说明什么

05:10.590 --> 05:11.590
说明了生成器里边

05:11.590 --> 05:13.590
有一个next的方法

05:13.590 --> 05:15.590
所以迭代器的特征是什么

05:15.590 --> 05:17.590
特征里边就是有next的方法

05:17.590 --> 05:19.590
因此生成器它里边一定有那个方法

05:19.590 --> 05:21.590
因为它是一个迭代器

05:21.590 --> 05:29.290
同时又是一个可迭代对象

05:29.290 --> 05:30.290
这又说明什么

05:30.290 --> 05:32.290
如果你拿到一个生成器

05:32.290 --> 05:34.290
我们认识一个东西

05:34.290 --> 05:35.290
都是从慢慢去认识的

05:35.290 --> 05:37.290
先从一个角度去看

05:37.290 --> 05:38.290
再从一个角度去看

05:38.290 --> 05:40.290
慢慢的就把这个东西认识清楚了

05:40.290 --> 05:41.290
慢慢来不着急

05:41.290 --> 05:43.290
它既是一个迭代器

05:43.290 --> 05:45.290
说明它里边肯定有那个设方法

05:45.290 --> 05:47.290
它同时又是个可迭代对象

05:47.290 --> 05:48.290
说明什么

05:48.290 --> 05:50.290
说明它里边一定有个知名符号

05:50.290 --> 05:52.290
simpleator

05:52.290 --> 05:53.290
一定是有

05:53.290 --> 05:55.290
这个符号一定是

05:55.290 --> 05:56.290
一个迭代器

05:56.290 --> 05:57.290
一个迭代器创建函数

05:57.290 --> 05:59.290
雕像过后得到一个迭代器

05:59.290 --> 06:00.290
同时说明什么

06:00.290 --> 06:01.290
说明它生成器

06:01.290 --> 06:03.290
一定可以用于FORF循环

06:03.290 --> 06:05.290
是不是说明这些问题

06:05.290 --> 06:07.290
这就是个生成器

06:07.290 --> 06:09.290
但是我们现在这个纳曼的是

06:09.290 --> 06:12.290
生成器你是不能

06:12.290 --> 06:13.290
创建的

06:13.290 --> 06:14.290
那我们学个干嘛呢

06:14.290 --> 06:16.290
我也不能创建一个生成器

06:16.290 --> 06:17.290
那我们研究半天

06:17.290 --> 06:18.290
研究啥

06:18.290 --> 06:20.290
它是这么回事

06:20.290 --> 06:21.290
如何

06:21.290 --> 06:22.290
就是第二个问题

06:22.290 --> 06:25.290
如何创建生成器

06:25.290 --> 06:28.920
我们用问题来描述吧

06:28.920 --> 06:29.920
好

06:29.920 --> 06:30.920
第一个是什么是生成器

06:30.920 --> 06:32.920
第二个是如何创建生成器

06:32.920 --> 06:33.920
好

06:33.920 --> 06:34.920
怎么来创建个生成器呢

06:34.920 --> 06:36.920
我们不能用构造寒式来创建

06:36.920 --> 06:37.920
那怎么来创建呢

06:37.920 --> 06:40.920
生成器的创建

06:40.920 --> 06:42.920
必须使用

06:42.920 --> 06:45.920
生成器寒数

06:45.920 --> 06:47.920
我们把它叫做

06:47.920 --> 06:49.920
generator

06:49.920 --> 06:51.920
generator去生成器的意思

06:51.920 --> 06:52.920
方形

06:52.920 --> 06:55.920
必须要通过生成器寒数来创建

06:55.920 --> 06:57.920
也就是说你要得到一个生成器

06:57.920 --> 06:58.920
你必须要通过生成器寒数

06:58.920 --> 06:59.920
跑不了了

06:59.920 --> 07:00.920
为什么呢

07:00.920 --> 07:01.920
因为它不准利用构造寒数

07:01.920 --> 07:03.920
这是它内部使用的

07:03.920 --> 07:04.920
那么

07:04.920 --> 07:06.920
这个生成器寒数会在内部

07:06.920 --> 07:07.920
它会调用

07:07.920 --> 07:09.920
它会帮你去创建一个生成器对象

07:09.920 --> 07:10.920
然后给你

07:11.920 --> 07:13.920
那么生成器寒数如何输写呢

07:13.920 --> 07:14.920
如何

07:14.920 --> 07:16.920
这一刻就用这个问题来

07:16.920 --> 07:18.920
来讲解这一刻的知识

07:19.920 --> 07:20.920
慢慢认识

07:20.920 --> 07:21.920
不着急

07:22.920 --> 07:23.920
如何

07:24.920 --> 07:28.920
创建一个生成器寒数呢

07:28.920 --> 07:29.920
你看

07:29.920 --> 07:30.920
这些问题都是连着的

07:30.920 --> 07:32.920
生成器我们简单的认识了一下

07:32.920 --> 07:33.920
它又是什么东西

07:33.920 --> 07:34.920
然后呢

07:34.920 --> 07:35.920
它怎么来得到呢

07:35.920 --> 07:36.920
你必须要通过生成器寒数

07:36.920 --> 07:39.920
它怎么来输写一个生成器寒数呢

07:39.920 --> 07:41.920
如何输写一个生成器寒数呢

07:41.920 --> 07:42.920
非常简单

07:42.920 --> 07:43.920
怎么输写

07:44.920 --> 07:47.920
你只需要在寒数的

07:47.920 --> 07:48.920
方可形关键字

07:48.920 --> 07:49.920
后边

07:49.920 --> 07:52.920
或者是寒数的名称前边

07:52.920 --> 07:53.920
加上一个新号

07:55.920 --> 07:57.920
那么这个寒数

07:57.920 --> 07:59.920
就是一个生成器寒数

07:59.920 --> 08:01.920
它就不再是一个普通寒数了

08:01.920 --> 08:04.920
这是一个生成器寒数

08:04.920 --> 08:06.920
该寒数

08:06.920 --> 08:08.920
一定100%没有例外的情况

08:08.920 --> 08:11.920
一定返回一个生成器

08:11.920 --> 08:13.920
你哪怕你别一句代码都不写

08:13.920 --> 08:14.920
它一定返回一个生成器

08:14.920 --> 08:16.920
有点类似我们之前讲

08:16.920 --> 08:17.920
一步处理

08:17.920 --> 08:18.920
用那个什么

08:18.920 --> 08:19.920
夹上个

08:19.920 --> 08:20.920
关键字

08:20.920 --> 08:22.920
它就一定返回一个Promise

08:22.920 --> 08:23.920
那么这个也是一样

08:23.920 --> 08:24.920
你夹上一个新号

08:24.920 --> 08:26.920
它一定返回个生成器

08:26.920 --> 08:28.920
开始想了

08:28.920 --> 08:29.920
我既加一个新号

08:29.920 --> 08:30.920
又加一个

08:30.920 --> 08:32.920
它能返回啥呢

08:32.920 --> 08:33.920
不准

08:33.920 --> 08:34.920
它不准你这样讲

08:34.920 --> 08:36.920
你要么就是个生成器寒数

08:36.920 --> 08:37.920
要么就是一个

08:37.920 --> 08:38.920
生可易不寒数

08:38.920 --> 08:39.920
你不能两个都加

08:39.920 --> 08:41.920
不能两个都加的

08:41.920 --> 08:42.920
这就是生成器寒数

08:42.920 --> 08:43.920
当然这个新号你可以放这

08:43.920 --> 08:44.920
也可以放这

08:44.920 --> 08:46.920
随便放哪无所谓

08:46.920 --> 08:47.920
总之那里面

08:47.920 --> 08:48.920
方形关键字

08:48.920 --> 08:49.920
后面放个新号

08:49.920 --> 08:50.920
或者是名字前面

08:50.920 --> 08:51.920
都行

08:51.920 --> 08:52.920
有的时候

08:52.920 --> 08:53.920
寒数它没有名字

08:53.920 --> 08:54.920
没有名字

08:54.920 --> 08:55.920
比方利民寒数

08:55.920 --> 08:56.920
你去这样子写

08:56.920 --> 08:57.920
有的时候

08:57.920 --> 08:58.920
有些寒数

08:58.920 --> 09:00.920
它没有方形关键字

09:00.920 --> 09:02.920
哪些寒数没有方形关键字

09:02.920 --> 09:03.920
比方说一个对象里面的

09:03.920 --> 09:04.920
一个方法

09:04.920 --> 09:06.920
对象里面的一个方法

09:06.920 --> 09:07.920
一个方形关键字

09:07.920 --> 09:08.920
那么这个时候

09:08.920 --> 09:09.920
你把新号写名字前面

09:09.920 --> 09:12.230
明白吧

09:12.230 --> 09:13.230
就特别简单

09:13.230 --> 09:14.230
特别简单

09:14.230 --> 09:15.230
这就是生成器寒数

09:16.230 --> 09:17.230
好

09:17.230 --> 09:18.230
来

09:18.230 --> 09:19.230
我们现在知道了

09:19.230 --> 09:20.230
这么一些简单的信息

09:20.230 --> 09:21.230
过后

09:21.230 --> 09:22.230
我们就可以看一下例子了

09:22.230 --> 09:27.080
TES1

09:27.080 --> 09:28.080
看一下

09:28.080 --> 09:29.080
我们这也肯定要

09:29.080 --> 09:30.080
举很多例子

09:31.080 --> 09:32.080
我们这里

09:32.080 --> 09:34.080
就写这么一个寒数

09:35.080 --> 09:36.080
写这么一个寒数

09:36.080 --> 09:37.080
就TES

09:38.080 --> 09:39.080
一句话没写

09:39.080 --> 09:40.080
寒数里面

09:40.080 --> 09:41.080
一句话没写

09:41.080 --> 09:42.080
没有写反回之

09:42.080 --> 09:43.080
一句话啥都没有

09:43.080 --> 09:44.080
但是

09:44.080 --> 09:45.080
我们就给它加了个新号

09:45.080 --> 09:46.080
说明啥呢

09:46.080 --> 09:47.080
说明它是个生成器寒数

09:47.080 --> 09:48.080
来

09:48.080 --> 09:49.080
我们调用这个寒数

09:49.080 --> 09:50.080
调用这个寒数得到的是啥

09:50.080 --> 09:51.080
得到的是啥

09:51.080 --> 09:52.080
你告诉我

09:52.080 --> 09:53.080
得到的是字部串吗

09:53.080 --> 09:54.080
undefine吗

09:54.080 --> 09:55.080
还是数字

09:55.080 --> 09:56.080
还得到的是啥

09:56.080 --> 09:58.080
得到了一定是一个生成器

09:58.080 --> 09:59.080
相当不用想

09:59.080 --> 10:00.080
加了这个新号

10:00.080 --> 10:01.080
因为你是个生成器寒数

10:01.080 --> 10:02.080
它一定得到了

10:02.080 --> 10:03.080
是个生成器

10:03.080 --> 10:04.080
Generator

10:04.080 --> 10:05.080
好

10:05.080 --> 10:06.080
然后呢

10:06.080 --> 10:07.080
我们把Generator输出

10:07.080 --> 10:08.080
Generator

10:08.080 --> 10:09.080
看一下到底是啥

10:09.080 --> 10:10.080
啥呢

10:10.080 --> 10:11.080
里面好奇

10:11.080 --> 10:12.080
里面有没有好奇心

10:12.080 --> 10:13.080
里面好奇

10:13.080 --> 10:14.080
这里面有啥东西

10:14.080 --> 10:15.080
因为我们之前说了

10:15.080 --> 10:16.080
生成器寒数

10:16.080 --> 10:17.080
是一个迭代器

10:17.080 --> 10:18.080
一定好奇

10:18.080 --> 10:19.080
它里面有没有那个时候方法

10:19.080 --> 10:21.080
同时又是个可迭代对象

10:21.080 --> 10:22.080
那一定好奇

10:22.080 --> 10:24.080
它里面有没有那个知名符号

10:24.080 --> 10:25.080
好

10:25.080 --> 10:26.080
来吧

10:26.080 --> 10:28.080
我们就看了一关键信息就行了

10:28.080 --> 10:30.970
好

10:30.970 --> 10:31.970
你看

10:31.970 --> 10:32.970
打开

10:32.970 --> 10:33.970
展开

10:33.970 --> 10:35.970
我的那个时候方法去哪了

10:35.970 --> 10:36.970
原型里面找

10:36.970 --> 10:37.970
原型呢

10:37.970 --> 10:38.970
再找

10:38.970 --> 10:39.970
next

10:39.970 --> 10:41.970
是不是有next的方法

10:41.970 --> 10:42.970
说明啥

10:42.970 --> 10:43.970
说明它一定是一个迭代器

10:43.970 --> 10:44.970
对吧

10:44.970 --> 10:46.970
它一定是个迭代器

10:46.970 --> 10:47.970
没问题吧

10:47.970 --> 10:48.970
得到了一定是个迭代器

10:48.970 --> 10:50.970
这么气的本质上就是个迭代器

10:50.970 --> 10:51.970
当然你可以看到

10:51.970 --> 10:52.970
它还加了很多的功能

10:52.970 --> 10:54.970
它不仅仅是有这么简单的功能

10:54.970 --> 10:55.970
还有一些别的功能

10:55.970 --> 10:56.970
都在这里面

10:56.970 --> 10:58.970
但是它至少

10:58.970 --> 10:59.970
它是个迭代器

10:59.970 --> 11:00.970
对不对

11:00.970 --> 11:01.970
知名符号

11:01.970 --> 11:02.970
知名符号

11:02.970 --> 11:03.970
你看这里

11:03.970 --> 11:04.970
不就知名符号吗

11:04.970 --> 11:05.970
simple editor

11:05.970 --> 11:06.970
对吧

11:06.970 --> 11:07.970
说明它是一个什么

11:07.970 --> 11:09.970
是一个可迭代对象

11:09.970 --> 11:10.970
可迭代对象

11:10.970 --> 11:11.970
当然你现在去迭代它

11:11.970 --> 11:12.970
你去调用它的next

11:12.970 --> 11:13.970
能不能调用next

11:13.970 --> 11:15.970
当然一点问题都没有

11:15.970 --> 11:16.970
当然一点问题都没有

11:16.970 --> 11:17.970
比方说我们这里

11:17.970 --> 11:18.970
调用generator

11:18.970 --> 11:19.970
generator

11:19.970 --> 11:20.970
点next

11:20.970 --> 11:21.970
调用又省了

11:21.970 --> 11:22.970
大胆的用

11:22.970 --> 11:23.970
它说当为处

11:23.970 --> 11:24.970
已经迭代完成了

11:24.970 --> 11:25.970
只为undefend

11:25.970 --> 11:26.970
其实是

11:26.970 --> 11:27.970
为什么是这样子

11:27.970 --> 11:28.970
你先别管

11:28.970 --> 11:29.970
先别管

11:29.970 --> 11:30.970
至少你至少可以用

11:30.970 --> 11:31.970
能不能用for二五循环

11:31.970 --> 11:32.970
来吧

11:32.970 --> 11:33.970
用for二五循环

11:34.970 --> 11:35.970
const

11:35.970 --> 11:36.970
itle

11:37.970 --> 11:38.970
generator

11:38.970 --> 11:39.970
对吧

11:39.970 --> 11:40.970
就是我们得到的生成器

11:40.970 --> 11:42.970
通过生成器函数

11:42.970 --> 11:43.970
可以得到一个生成器

11:43.970 --> 11:44.970
这是得到生成器的

11:44.970 --> 11:45.970
唯一途径

11:45.970 --> 11:46.970
没有别的途径的

11:46.970 --> 11:47.970
因为你不能自己

11:47.970 --> 11:48.970
你不能用那个

11:48.970 --> 11:49.970
扣到函数

11:50.970 --> 11:51.970
能不能循环

11:51.970 --> 11:52.970
没爆错吗

11:52.970 --> 11:53.970
是不是可以循环

11:53.970 --> 11:54.970
对吧

11:54.970 --> 11:55.970
如果说它不能循环的话

11:55.970 --> 11:56.970
它会爆错

11:56.970 --> 11:57.970
它告诉你这个东西

11:57.970 --> 11:58.970
是不能被迭代的

11:58.970 --> 12:00.970
它不是一个可迭代对象

12:00.970 --> 12:01.970
说明了啥

12:01.970 --> 12:02.970
说明它是一个可迭代对象

12:02.970 --> 12:03.970
对吧

12:03.970 --> 12:04.970
它是用来迭代的

12:04.970 --> 12:05.970
生成器得到了

12:05.970 --> 12:06.970
生成器函数得到的结果

12:06.970 --> 12:07.970
一定是用来迭代的

12:08.970 --> 12:09.970
这毫无疑问

12:09.970 --> 12:11.970
那么现在我们把目光放到这

12:11.970 --> 12:13.970
放到这

12:13.970 --> 12:15.970
那么这里干嘛呢

12:15.970 --> 12:17.970
这里边是啥东西呢

12:17.970 --> 12:18.970
好

12:18.970 --> 12:20.970
现在我们把目光放到这

12:20.970 --> 12:24.970
就是生成器函数

12:24.970 --> 12:25.970
因为我们外边

12:25.970 --> 12:26.970
其实已经很清楚了

12:26.970 --> 12:27.970
外边

12:27.970 --> 12:28.970
就是得到

12:28.970 --> 12:29.970
调整个函数得到了

12:29.970 --> 12:30.970
一定是个生成器

12:30.970 --> 12:31.970
管理一边写啥代

12:31.970 --> 12:32.970
它得到一定是个生成器

12:32.970 --> 12:33.970
那么生成器

12:33.970 --> 12:34.970
由于它本质是迭代器

12:34.970 --> 12:35.970
就是用来迭代的对吧

12:35.970 --> 12:36.970
那个时候那个时候那个时候

12:36.970 --> 12:37.970
迭代

12:37.970 --> 12:38.970
就是用那个时候

12:38.970 --> 12:39.970
方法来迭代的

12:39.970 --> 12:40.970
其实没啥东西

12:40.970 --> 12:42.970
关键是这个函数里边

12:42.970 --> 12:44.970
很多朋友搞不清楚

12:44.970 --> 12:46.970
是在这个函数里边搞不清楚

12:46.970 --> 12:47.970
好

12:47.970 --> 12:48.970
生成器函数

12:48.970 --> 12:52.970
内部是如何执行的

12:52.970 --> 12:54.970
这是这结构的终点

12:55.970 --> 12:56.970
它内部是怎么执行的

12:56.970 --> 12:57.970
我们首先看一个

12:57.970 --> 12:58.970
非常奇怪的现象

12:58.970 --> 12:59.970
我在这个函数内部

12:59.970 --> 13:00.970
输出一句话

13:00.970 --> 13:01.970
123

13:01.970 --> 13:02.970
随便瞎写一句话

13:02.970 --> 13:03.970
你会发现这个123

13:03.970 --> 13:04.970
没有输出

13:04.970 --> 13:05.970
123呢

13:05.970 --> 13:06.970
123跑哪去了

13:06.970 --> 13:07.970
没有

13:07.970 --> 13:09.970
没有这个123

13:09.970 --> 13:10.970
为什么没有这个123

13:10.970 --> 13:11.970
因为这句话

13:11.970 --> 13:12.970
根本就没有运行

13:12.970 --> 13:13.970
这个函数体

13:13.970 --> 13:14.970
根本就没有运行

13:14.970 --> 13:15.970
你不在调用函数吗

13:15.970 --> 13:16.970
所以说这个物解

13:16.970 --> 13:17.970
大家一定要消除

13:17.970 --> 13:18.970
就是什么

13:18.970 --> 13:20.970
这是一个生成器函数

13:20.970 --> 13:21.970
你调用函数

13:21.970 --> 13:23.970
只是给你简单的

13:23.970 --> 13:25.970
得到一个生成器而已

13:25.970 --> 13:26.970
根本就没有运行

13:26.970 --> 13:28.970
这个函数里边的任何代码

13:28.970 --> 13:29.970
你这里写的一万行代码

13:29.970 --> 13:30.970
它都不会运行

13:30.970 --> 13:31.970
它只是简单的

13:31.970 --> 13:32.970
给你一个生成器

13:32.970 --> 13:33.970
这个物解一定要消除

13:33.970 --> 13:35.970
不说你调用函数

13:35.970 --> 13:36.970
它就给你运行函数

13:36.970 --> 13:38.970
不是的

13:38.970 --> 13:39.970
它只是简单的

13:39.970 --> 13:40.970
得到一个生成器

13:40.970 --> 13:41.970
那么这个函数的

13:41.970 --> 13:42.970
作用是什么呢

13:42.970 --> 13:43.970
这里边怎么运行呢

13:43.970 --> 13:46.970
它是这么考虑的

13:46.970 --> 13:48.970
你得到生成器要干吗

13:48.970 --> 13:49.970
得到生成器干吗

13:49.970 --> 13:50.970
是不是迭代

13:50.970 --> 13:51.970
拿到下一个数据

13:51.970 --> 13:52.970
拿到下一个数据

13:52.970 --> 13:53.970
拿到下一个数据

13:53.970 --> 13:55.970
那么这个函数里边

13:55.970 --> 13:57.970
是给生成器

13:57.970 --> 14:01.970
提供迭代数据的

14:01.970 --> 14:02.970
我们之前说

14:02.970 --> 14:04.970
为什么要有生成器

14:04.970 --> 14:05.970
最初的目的是

14:05.970 --> 14:08.970
为了简化迭代器的编辑

14:08.970 --> 14:10.970
迭代器编辑太麻烦了

14:10.970 --> 14:12.970
写写太恶心了

14:12.970 --> 14:13.970
每次要返回一个对象

14:13.970 --> 14:15.970
写一大堆东西

14:15.970 --> 14:16.970
因此它为了简化编写

14:16.970 --> 14:18.970
搞出这么一个生成器

14:18.970 --> 14:19.970
因此这个生成器

14:19.970 --> 14:20.970
函数内部

14:20.970 --> 14:22.970
它就是为了

14:22.970 --> 14:23.970
给生成器

14:23.970 --> 14:27.970
每一次迭代提供数据的

14:27.970 --> 14:29.970
生成

14:29.970 --> 14:30.970
先到这吧

14:30.970 --> 14:33.970
生成器函数内部

14:33.970 --> 14:37.970
是为了给生成器的

14:37.970 --> 14:41.970
每次迭代提供数据的

14:41.970 --> 14:42.970
你把这一点理解了

14:42.970 --> 14:43.970
你就彻底

14:43.970 --> 14:44.970
你至少你彻底理解了

14:44.970 --> 14:46.970
这里边为什么不运行

14:46.970 --> 14:48.970
因为现在迭代了吗

14:48.970 --> 14:49.970
这里我写这么一句话

14:49.970 --> 14:51.970
我现在迭代了吗

14:51.970 --> 14:53.970
这个生成器我这里迭代了吗

14:53.970 --> 14:55.970
是没有迭代

14:55.970 --> 14:56.970
迭代是什么

14:56.970 --> 14:57.970
就掉那个是

14:57.970 --> 14:58.970
哪一个数据出来

14:58.970 --> 14:59.970
一个数据拿出来

14:59.970 --> 15:01.970
是掉那个是来迭代的

15:01.970 --> 15:02.970
我这里迭代了吗

15:02.970 --> 15:03.970
没有迭代

15:03.970 --> 15:04.970
所以它不运行

15:04.970 --> 15:05.970
那么也就是换句话说

15:05.970 --> 15:06.970
这个代码要什么时候运行

15:06.970 --> 15:08.970
要迭代过后才运行

15:08.970 --> 15:11.970
因为这里的函数代码的目的是什么

15:11.970 --> 15:13.970
目的是给它迭代提供数据的

15:13.970 --> 15:14.970
你不是迭代编写时间

15:14.970 --> 15:15.970
还麻烦吗

15:15.970 --> 15:17.970
我就来解决这样的问题

15:17.970 --> 15:19.970
它怎么来提供数据呢

15:19.970 --> 15:21.970
它是这样子

15:21.970 --> 15:25.970
每一次使用

15:25.970 --> 15:27.970
每次调用

15:27.970 --> 15:30.970
生成器的next方法

15:30.970 --> 15:31.970
因为它是迭代器

15:31.970 --> 15:32.970
它有个next方法

15:32.970 --> 15:34.970
每一次调用它的迭代方法

15:34.970 --> 15:35.970
next

15:35.970 --> 15:41.970
将导致生成器函数运行

15:41.970 --> 15:44.970
到下一个

15:44.970 --> 15:48.970
一有的关键字位置

15:48.970 --> 15:49.970
啥意思

15:49.970 --> 15:50.970
这啥意思

15:50.970 --> 15:52.970
什么叫一有的关键字位置

15:52.970 --> 15:53.970
看着

15:53.970 --> 15:55.970
一有的是一个新的关键字

15:55.970 --> 15:56.970
这个新的关键字

15:56.970 --> 15:59.970
只能在生成器内部使用

15:59.970 --> 16:01.970
先把我们先把技巧的

16:01.970 --> 16:02.970
一起来解释

16:02.970 --> 16:04.970
一有的是一个关键字

16:04.970 --> 16:12.970
该关键字只能在生成器函数内部使用

16:12.970 --> 16:14.970
表达

16:14.970 --> 16:17.970
表达一个意思叫做产生

16:17.970 --> 16:18.970
产生的意思

16:18.970 --> 16:19.970
具体什么意思呢

16:19.970 --> 16:23.970
产生一个迭代数据的意思

16:23.970 --> 16:25.970
产生一个迭代数据的意思

16:25.970 --> 16:27.970
就表达这么一个意思

16:27.970 --> 16:29.970
产生一个迭代数据

16:29.970 --> 16:30.970
生成器内部不就是为了

16:30.970 --> 16:32.970
生成器提供迭代数据吗

16:32.970 --> 16:33.970
你拿一个数据

16:33.970 --> 16:34.970
我给第一次给你啥

16:34.970 --> 16:35.970
第二次给你啥

16:35.970 --> 16:36.970
第三次给你啥

16:36.970 --> 16:38.970
它就是用一个新的关键字

16:38.970 --> 16:40.970
来产生迭代数据的

16:40.970 --> 16:42.970
接下来我们看一下

16:42.970 --> 16:43.970
也就是说一开始

16:43.970 --> 16:44.970
它并不会执行

16:44.970 --> 16:46.970
并不会执行这个函数

16:46.970 --> 16:47.970
什么时候执行呢

16:47.970 --> 16:48.970
调用next

16:48.970 --> 16:50.970
调用next的执行

16:50.970 --> 16:52.970
调用next的执行

16:52.970 --> 16:53.970
它怎么执行呢

16:53.970 --> 16:55.970
它会执行到下一个eO的位置

16:55.970 --> 16:56.970
那我这里有没有eO的

16:56.970 --> 16:58.970
没有eO的 它执行完了

16:58.970 --> 17:01.970
那么我们现在写这么一个eO的

17:01.970 --> 17:03.970
毕竟eO的后面我还可以给数据

17:03.970 --> 17:05.970
你不是产生数据吗

17:05.970 --> 17:06.970
产生一个迭代数据

17:06.970 --> 17:09.970
OK 我可以产生一个2

17:09.970 --> 17:10.970
就产生一个1

17:10.970 --> 17:12.970
可以产生一个1

17:12.970 --> 17:15.970
然后呢

17:15.970 --> 17:18.970
第一次运行

17:18.970 --> 17:21.970
好 下面我们输出

17:21.970 --> 17:23.970
第二次运行

17:23.970 --> 17:28.470
然后我们eO的2

17:28.470 --> 17:30.470
好 然后呢

17:30.470 --> 17:32.470
这是第三次运行

17:32.470 --> 17:33.470
三次运行

17:33.470 --> 17:34.470
好 就行了

17:34.470 --> 17:36.470
我们就写这么一个一点代

17:36.470 --> 17:37.470
好 接下来我们看一个函数

17:37.470 --> 17:38.470
怎么运行的

17:38.470 --> 17:41.470
特别有意思

17:41.470 --> 17:43.470
调用这个函数运行吗

17:43.470 --> 17:44.470
在这里

17:44.470 --> 17:45.470
调用这个函数运行吗

17:45.470 --> 17:46.470
不动

17:46.470 --> 17:47.470
为什么不动

17:47.470 --> 17:49.470
因为这里是为了谁服务的

17:49.470 --> 17:52.470
为了生成器的迭代服务的

17:52.470 --> 17:53.470
你现在都没迭代

17:53.470 --> 17:54.470
我不会运行的

17:54.470 --> 17:55.470
我只是给你一个生成器

17:55.470 --> 17:57.470
好 那么现在是不是开始迭代了

17:57.470 --> 17:58.470
对吧

17:58.470 --> 17:59.470
是不是开始迭代了

17:59.470 --> 18:01.470
我们现在不在这儿写吧

18:01.470 --> 18:02.470
不在这儿写

18:02.470 --> 18:07.620
那么我们在网页里面看

18:07.620 --> 18:09.620
一开始不啥都没输出

18:09.620 --> 18:10.620
对吧 因为没迭代

18:10.620 --> 18:11.620
你没迭代

18:11.620 --> 18:12.620
我输出啥呀

18:12.620 --> 18:14.620
好 接下来我们开始迭代

18:14.620 --> 18:15.620
GenerateNex

18:15.620 --> 18:16.620
调用这个Nex的方法 迭代

18:16.620 --> 18:17.620
迭代的时候

18:17.620 --> 18:18.620
是不是要开始运行的

18:18.620 --> 18:19.620
因为这里边就是给它

18:19.620 --> 18:20.620
铁共迭代数据的

18:20.620 --> 18:21.620
因为我们调用Nex

18:21.620 --> 18:23.620
是不是希望得到一个

18:23.620 --> 18:24.620
得到下一个数据

18:24.620 --> 18:26.620
对吧 有y6值 有dump

18:26.620 --> 18:27.620
有这两个数据

18:27.620 --> 18:28.620
是不是要希望得到这个

18:28.620 --> 18:30.620
OK 那么它就会怎么做呢

18:30.620 --> 18:31.620
它就会运行这个函数

18:31.620 --> 18:33.620
从 因为现在的

18:33.620 --> 18:34.620
函数的最开始

18:34.620 --> 18:36.620
就从最开始开始运行

18:36.620 --> 18:37.620
运行这句话

18:37.620 --> 18:38.620
就输出了这个东西

18:38.620 --> 18:41.620
然后运行到下一个eO的停止

18:41.620 --> 18:43.620
因为这个eO的啥意思

18:43.620 --> 18:45.620
eO的就是产生了一个迭代数据了

18:45.620 --> 18:46.620
产生的数据是啥

18:46.620 --> 18:47.620
数据是1

18:47.620 --> 18:48.620
对吧 那是不是

18:48.620 --> 18:50.620
这个数据已经得到了

18:50.620 --> 18:52.620
你现在 那么我现在就停在这儿了

18:52.620 --> 18:54.620
等待你下一次迭代了

18:54.620 --> 18:55.620
我已经停在这儿了

18:55.620 --> 18:56.620
就产生一个数据1

18:56.620 --> 18:58.620
因此这句话运行了之后

18:58.620 --> 19:00.620
你会发现 第一次运行输出了

19:00.620 --> 19:02.620
并且Nex得到一个结果

19:02.620 --> 19:03.620
y6值是不是e

19:03.620 --> 19:04.620
这个e哪来的

19:04.620 --> 19:05.620
是不是这来的

19:05.620 --> 19:08.620
因为这里它只管产生数据

19:08.620 --> 19:09.620
只管产生数据

19:09.620 --> 19:10.620
产生每一次迭代的数据

19:10.620 --> 19:12.620
你不是生存器要迭代数据

19:12.620 --> 19:13.620
需要数据吗

19:13.620 --> 19:14.620
你调用下一个的时候

19:14.620 --> 19:15.620
我给你产生一个数据

19:15.620 --> 19:16.620
给你

19:16.620 --> 19:17.620
这个数据给谁了

19:17.620 --> 19:18.620
给这个生存器的

19:18.620 --> 19:20.620
生存器不是拿数据吗

19:20.620 --> 19:22.620
就拿到这个数据

19:23.620 --> 19:24.620
当为force

19:24.620 --> 19:26.620
它为什么当为force

19:26.620 --> 19:27.620
为什么当为force

19:27.620 --> 19:29.620
因为这个函数还没运行完

19:29.620 --> 19:30.620
这个函数还没运行完

19:30.620 --> 19:32.620
它当一定为force

19:32.620 --> 19:34.620
当这个数据

19:34.620 --> 19:35.620
什么时候维促呢

19:35.620 --> 19:36.620
就是函数运行完维促

19:36.620 --> 19:38.620
我们一会儿就可以看到了

19:38.620 --> 19:40.620
好 再来

19:40.620 --> 19:41.620
所以这个地方

19:41.620 --> 19:42.620
我们记笔记都是吃药的

19:42.620 --> 19:44.620
主要是要理解

19:44.620 --> 19:46.620
要理解 它的那种想法和思路

19:46.620 --> 19:49.620
它其实这些东西都是符合逻辑的

19:49.620 --> 19:51.620
你如果不理解它的内在逻辑的话

19:51.620 --> 19:53.620
你要去背的话很难背得住的

19:53.620 --> 19:55.620
好 接下来我们再来调用一次

19:55.620 --> 19:57.620
我们现在又拿下一个数据

19:57.620 --> 19:58.620
你想这个道理

19:58.620 --> 20:00.620
这是第一个数据

20:00.620 --> 20:02.620
拿下一个数据是不是接着运行

20:02.620 --> 20:04.620
是不是接着往后有运行

20:04.620 --> 20:05.620
是不是运行到这儿又停了

20:05.620 --> 20:07.620
是不是下一个数据已经拿到了

20:07.620 --> 20:09.620
一有的是产生一个数据

20:09.620 --> 20:11.620
也不是已经产生了个数据吗

20:11.620 --> 20:12.620
不是拿到了吗

20:12.620 --> 20:14.620
所以说我们再调用那个数据

20:14.620 --> 20:16.620
第二次运行

20:16.620 --> 20:18.620
然后到这儿产生了数据

20:18.620 --> 20:20.620
产生了数据

20:20.620 --> 20:21.620
我们得到的数据结果

20:21.620 --> 20:23.620
Value为二 当为Force

20:23.620 --> 20:24.620
看呗

20:24.620 --> 20:27.620
好 然后我们再调用Next

20:27.620 --> 20:28.620
是不是又接着开始看

20:28.620 --> 20:29.620
又拿下一个数据

20:29.620 --> 20:31.620
又输出这句话

20:31.620 --> 20:32.620
下一个数据呢

20:32.620 --> 20:34.620
是不是还说运行完了

20:34.620 --> 20:35.620
还说运行完了

20:35.620 --> 20:36.620
那没有下一个数据了

20:36.620 --> 20:37.620
没有意义的了

20:37.620 --> 20:38.620
还是都运行完了

20:38.620 --> 20:41.620
所以说你觉得下一个人应该是啥

20:41.620 --> 20:43.620
输出第三次运行

20:43.620 --> 20:45.620
Value on Defend

20:45.620 --> 20:47.620
Done为True

20:47.620 --> 20:48.620
Done这个属性

20:48.620 --> 20:49.620
为什么什么时候为True

20:49.620 --> 20:50.620
函数运行完了

20:50.620 --> 20:52.620
它就为True

20:52.620 --> 20:53.620
对吧

20:53.620 --> 20:54.620
函数运行完了

20:54.620 --> 20:55.620
因为你想一个道理

20:55.620 --> 20:57.620
我这个函数里面是给你产生数据的

20:57.620 --> 20:59.620
我这个函数都运行完了

20:59.620 --> 21:01.620
但是一定没有新的数据给你的

21:01.620 --> 21:03.620
我不可能说

21:03.620 --> 21:04.620
函数都运行完了

21:04.620 --> 21:05.620
我再回过头来去执行

21:05.620 --> 21:06.620
那不可能

21:06.620 --> 21:08.620
这结束就结束了

21:08.620 --> 21:10.620
就永远不会再运行了

21:10.620 --> 21:12.620
所以说永远不会给你新的数据了

21:12.620 --> 21:13.620
所以说Done就为True

21:13.620 --> 21:15.620
是不是这个逻辑

21:15.620 --> 21:16.620
这是有逻辑的

21:16.620 --> 21:18.620
这不是说也史规定的

21:18.620 --> 21:20.620
我喝个水

21:20.620 --> 21:23.820
那么大家可以看到

21:23.820 --> 21:26.820
这个生成器有一个非常有意识的点

21:26.820 --> 21:27.820
特能就是

21:27.820 --> 21:28.820
这个生成器在外面

21:28.820 --> 21:29.820
是不是控制了

21:29.820 --> 21:32.820
感觉上是不是控制了函数的执行

21:32.820 --> 21:34.820
分端执行这个函数

21:34.820 --> 21:36.820
是不是感觉有这么一种感觉在这里边了

21:36.820 --> 21:38.820
我每一次调用生成器的那个执行段

21:38.820 --> 21:40.820
生成器的那个执行段

21:40.820 --> 21:42.820
其实它本质上非常简单

21:42.820 --> 21:44.820
它就是提供了一个愚法堂

21:44.820 --> 21:46.820
这个愚法堂就是在函数内部

21:46.820 --> 21:49.820
让你方便的来产生迭代数据

21:49.820 --> 21:51.820
这个产生一个迭代数据1

21:51.820 --> 21:52.820
产生一个迭代数据2

21:52.820 --> 21:54.820
那么第一次调到那个时候

21:54.820 --> 21:55.820
就得到第一个迭代数据

21:55.820 --> 21:56.820
第二次调到那个时候

21:56.820 --> 21:57.820
就得到第二个迭代数据

21:57.820 --> 21:58.820
对吧

21:58.820 --> 22:00.820
它是主要是起这么一个作用

22:00.820 --> 22:02.820
那么基于这一点的话

22:02.820 --> 22:05.820
我们把之前那个迭代器的一块

22:05.820 --> 22:06.820
就是数组的迭代

22:06.820 --> 22:07.820
我们来写一下

22:07.820 --> 22:12.160
来练习一下

22:12.160 --> 22:14.160
我们这里来复制一下

22:14.160 --> 22:16.160
之前我们写的迭代器

22:16.160 --> 22:18.160
不是写得挺麻烦的吗

22:18.160 --> 22:21.160
你看我们这里为了写这个迭代器

22:21.160 --> 22:24.160
我来重新来一个

22:24.160 --> 22:26.160
你看我这里还写了一个迭代器

22:26.160 --> 22:28.160
创建迭代器创建函数对吧

22:28.160 --> 22:30.160
对的挺麻烦的对不对

22:30.160 --> 22:31.160
是不是挺麻烦的

22:31.160 --> 22:32.160
我还去做这么一些弄

22:32.160 --> 22:34.160
还瞎表弯的东西发到处理

22:34.160 --> 22:36.160
你看着我现在用生成器来做

22:36.160 --> 22:38.160
你看多夸张这个事情

22:38.160 --> 22:39.160
那么这个是一个

22:39.160 --> 22:42.160
我就把它写成一个生成器函数

22:42.160 --> 22:43.160
生成器函数

22:43.160 --> 22:44.160
生成器函数返回来

22:44.160 --> 22:45.160
不就是个迭代器吗

22:45.160 --> 22:46.160
因为生成器就是迭代器

22:46.160 --> 22:48.160
你给我传个数组进来

22:48.160 --> 22:50.160
由于它是一个生成器函数

22:50.160 --> 22:51.160
别的我先不说

22:51.160 --> 22:52.160
别的我先不写

22:52.160 --> 22:55.160
它返回的是不是一定是一个生成器

22:55.160 --> 22:56.160
对吧

22:56.160 --> 22:57.160
是不是一定是个生成器

22:57.160 --> 22:58.160
生成器是不是就是迭代器

22:58.160 --> 23:00.160
它返回的一定是个迭代器

23:00.160 --> 23:02.160
这些东西是不是一定用那个方法

23:02.160 --> 23:03.160
对吧

23:03.160 --> 23:04.160
好那么我就在想

23:04.160 --> 23:06.160
那这里边你第一次迭代我给你啥

23:06.160 --> 23:07.160
第二次迭代给你啥

23:07.160 --> 23:08.160
你就看这个数组

23:08.160 --> 23:10.160
第一次迭代给你数组的第一项

23:10.160 --> 23:11.160
第二次迭代给你的数组

23:11.160 --> 23:12.160
第二项

23:12.160 --> 23:13.160
把数组迭代完就完事了

23:13.160 --> 23:16.660
那怎么办

23:16.660 --> 23:18.660
你看吧

23:18.660 --> 23:19.660
循环这个数组

23:19.660 --> 23:20.660
对吧

23:20.660 --> 23:21.660
数组是不是可以循环

23:21.660 --> 23:23.660
每次循环

23:23.660 --> 23:24.660
有的Item

23:24.660 --> 23:25.660
写完了

23:25.660 --> 23:26.660
我就写完了

23:26.660 --> 23:28.660
是不是方便了这个

23:28.660 --> 23:30.660
迭代器的编写

23:30.660 --> 23:31.660
对吧

23:31.660 --> 23:33.660
我们不用去构建什么

23:33.660 --> 23:34.660
Value属性

23:34.660 --> 23:35.660
当属性那些东西

23:35.660 --> 23:36.660
它全部帮你搞定了

23:36.660 --> 23:37.660
你只需要考虑

23:37.660 --> 23:39.660
每一次迭代

23:39.660 --> 23:40.660
我给你啥东西

23:40.660 --> 23:41.660
就完事了

23:41.660 --> 23:42.660
你看吧

23:42.660 --> 23:43.660
你第一次迭代

23:43.660 --> 23:44.660
我们看吧

23:44.660 --> 23:45.660
就这个

23:45.660 --> 23:47.660
Item 1

23:47.660 --> 23:48.660
你看这个道理

23:48.660 --> 23:50.660
你想的道理

23:50.660 --> 23:54.300
你细品

23:54.300 --> 23:55.300
Item 1

23:55.300 --> 23:56.300
点那个是

23:56.300 --> 23:58.300
你看

23:58.300 --> 23:59.300
点那个是

23:59.300 --> 24:00.300
那么点那个是

24:00.300 --> 24:01.300
Item 1

24:01.300 --> 24:02.300
点那个是

24:02.300 --> 24:03.300
它是个生成器

24:03.300 --> 24:04.300
那它是不是要运行

24:04.300 --> 24:05.300
这个生成器韩束

24:05.300 --> 24:06.300
对吧

24:06.300 --> 24:07.300
那么是不是进入

24:07.300 --> 24:08.300
第一次循环

24:08.300 --> 24:09.300
进入第一次循环

24:09.300 --> 24:10.300
第一次循环

24:10.300 --> 24:11.300
是不是产生了

24:11.300 --> 24:12.300
数组的第一项

24:12.300 --> 24:13.300
是不是停了

24:13.300 --> 24:14.300
停了

24:14.300 --> 24:15.300
因为得到数据

24:15.300 --> 24:16.300
产生了数组的第一项

24:16.300 --> 24:17.300
百里为一

24:17.300 --> 24:18.300
可没有

24:18.300 --> 24:19.300
百里为一

24:19.300 --> 24:20.300
好

24:20.300 --> 24:22.300
你下一次再调用那个 next

24:22.300 --> 24:23.300
是不是又继续运行

24:23.300 --> 24:25.300
又得到数组的

24:25.300 --> 24:26.300
又继续循环

24:26.300 --> 24:27.300
得到数组的第二项

24:27.300 --> 24:29.300
再调用一次

24:29.300 --> 24:30.300
得到数组的第三项

24:30.300 --> 24:31.300
第四项

24:31.300 --> 24:32.300
第五项

24:32.300 --> 24:33.300
再调用

24:33.300 --> 24:34.300
没了

24:34.300 --> 24:35.300
因为循环结束了

24:35.300 --> 24:36.300
这个韩束结束了

24:36.300 --> 24:37.300
后面不会再有新的数据给地了

24:37.300 --> 24:38.300
没了意思吗

24:38.300 --> 24:39.300
你看吧

24:39.300 --> 24:40.300
变成生成器

24:40.300 --> 24:41.300
特别好写

24:41.300 --> 24:42.300
特别特别好写

24:42.300 --> 24:43.300
来吧

24:43.300 --> 24:44.300
我们再来一些例子

24:44.300 --> 24:47.180
特色山

24:49.180 --> 24:50.180
我们之前还写过啥

24:51.180 --> 24:52.180
飞布拉奇树林

24:52.180 --> 24:53.180
来吧

24:53.180 --> 24:54.180
来吧

24:54.180 --> 24:55.180
飞布拉奇树林

24:56.180 --> 24:57.180
你看飞布拉奇树林

24:57.180 --> 24:58.180
我们又怎么写

24:58.180 --> 24:59.180
各种例子

25:00.180 --> 25:01.180
飞布拉奇树林

25:01.180 --> 25:02.180
产生一个飞布拉奇树林的

25:02.180 --> 25:03.180
就是迭代器

25:03.180 --> 25:04.180
那既然是一个迭代器

25:04.180 --> 25:05.180
创建韩束

25:05.180 --> 25:06.180
因为生成器

25:06.180 --> 25:07.180
韩束本质上

25:07.180 --> 25:08.180
就是一个迭代器

25:08.180 --> 25:09.180
创建韩束

25:09.180 --> 25:10.180
要返回迭代器

25:10.180 --> 25:11.180
返回的生成器

25:11.180 --> 25:12.180
就是个迭代器

25:12.180 --> 25:13.180
来吧

25:13.180 --> 25:14.180
我就把它变成一个

25:14.180 --> 25:15.180
生成器得了

25:15.180 --> 25:16.180
那么我现在考虑的问题

25:16.180 --> 25:17.180
就不是考虑什么

25:17.180 --> 25:18.180
雕用那个手法

25:18.180 --> 25:19.180
那些东西

25:19.180 --> 25:20.180
不用考虑这个东西了

25:20.180 --> 25:21.180
我就考虑

25:21.180 --> 25:22.180
我怎么给你迭代数据

25:22.180 --> 25:23.180
我怎么给你数据

25:24.180 --> 25:25.180
我怎么去给你数据

25:26.180 --> 25:27.180
那么我这里怎么给你呢

25:27.180 --> 25:28.180
你看我这样子写

25:29.180 --> 25:30.180
这样子写

25:30.180 --> 25:31.180
因为这个飞布拉奇树林

25:31.180 --> 25:32.180
是无限的

25:32.180 --> 25:33.180
所以说我写个死循环

25:33.180 --> 25:35.180
直接写个死循环

25:35.180 --> 25:36.180
无限给力

25:36.180 --> 25:37.180
无限给力

25:38.180 --> 25:39.180
判断一下

25:39.180 --> 25:40.180
如果N小于

25:41.180 --> 25:42.180
等于前两位

25:42.180 --> 25:43.180
对吧

25:43.180 --> 25:44.180
是不是前两位

25:44.180 --> 25:45.180
前两位怎么办

25:45.180 --> 25:46.180
一有的

25:46.180 --> 25:47.180
一

25:48.180 --> 25:50.180
我给力的数据就是一

25:50.180 --> 25:51.180
飞布拉奇树林前两位

25:51.180 --> 25:52.180
不就是一吗

25:52.180 --> 25:53.180
对不对

25:53.180 --> 25:54.180
最后不要忘记N加加

25:54.180 --> 25:55.180
N加加

25:56.180 --> 25:57.180
如果说

25:57.180 --> 25:59.180
如果说他给力的不是前两位

25:59.180 --> 26:01.180
给力的不是前两位

26:01.180 --> 26:02.180
是第三位

26:02.180 --> 26:03.180
第四位 第五位

26:03.180 --> 26:04.180
那么怎么办呢

26:05.180 --> 26:06.180
怎么办呢

26:06.180 --> 26:07.180
是不是我一有的

26:07.180 --> 26:08.180
有了啥

26:09.180 --> 26:10.180
一

26:11.180 --> 26:12.180
加上

26:13.180 --> 26:14.180
飞布2

26:14.180 --> 26:15.180
对吧

26:15.180 --> 26:16.180
然后不要忘记了

26:16.180 --> 26:18.180
还是跟之前一样

26:18.180 --> 26:20.180
飞布2

26:20.180 --> 26:21.180
要等于飞布1

26:21.180 --> 26:22.180
重新负下纸

26:23.180 --> 26:24.180
重新负下纸

26:25.180 --> 26:26.180
这里就660

26:26.180 --> 26:27.180
我们先用个边量

26:27.180 --> 26:28.180
660 保存一下

26:29.180 --> 26:30.180
保存一下

26:33.200 --> 26:34.200
那么先负下纸

26:34.200 --> 26:36.200
然后要把飞布1

26:36.200 --> 26:37.200
等于660

26:37.200 --> 26:38.200
对吧

26:38.200 --> 26:39.200
不要忘记做这么一件事

26:39.200 --> 26:40.200
就完了

26:40.200 --> 26:42.200
你看现在是不是写起来

26:42.200 --> 26:43.200
代码简洁了

26:43.200 --> 26:44.200
非常非常多

26:45.200 --> 26:46.200
你看一下

26:47.200 --> 26:48.200
是不是简洁了非常多

26:49.200 --> 26:50.200
怎么理解这个代码呢

26:50.200 --> 26:51.200
你看

26:51.200 --> 26:53.200
第一我们生存器

26:53.200 --> 26:54.200
我们运行出来

26:54.200 --> 26:56.770
你看怎么理解的代码

26:56.770 --> 26:57.770
我先看一下这么准确

26:58.770 --> 26:59.770
写了一会儿

26:59.770 --> 27:00.770
到处是错的

27:00.770 --> 27:01.770
1

27:01.770 --> 27:02.770
1

27:02.770 --> 27:03.770
2

27:03.770 --> 27:04.770
3

27:04.770 --> 27:05.770
5

27:05.770 --> 27:06.770
不用看了

27:06.770 --> 27:07.770
怎么理解呢

27:07.770 --> 27:08.770
理想

27:08.770 --> 27:09.770
我这个函数一开始

27:09.770 --> 27:10.770
运不运行

27:10.770 --> 27:11.770
不运行

27:11.770 --> 27:12.770
我只是得到一个生存器而已

27:12.770 --> 27:13.770
那么现在呢

27:13.770 --> 27:15.770
我调每一次调用这个

27:15.770 --> 27:16.770
每一次迭代

27:16.770 --> 27:17.770
它是不是要给我数据啊

27:17.770 --> 27:18.770
那么来吧

27:18.770 --> 27:19.770
那给我数据吧

27:19.770 --> 27:20.770
我就看

27:20.770 --> 27:21.770
第一是循环

27:21.770 --> 27:22.770
那么n小于等于2

27:22.770 --> 27:23.770
那我就给你

27:23.770 --> 27:24.770
给你一个数据1

27:24.770 --> 27:25.770
对吧

27:25.770 --> 27:26.770
给你一个数据1

27:26.770 --> 27:28.770
你是第一次就得到1

27:28.770 --> 27:29.770
然后呢

27:29.770 --> 27:30.770
你如果说不想要下一个数据了

27:30.770 --> 27:32.770
那就是他就一直卡着不动了

27:32.770 --> 27:33.770
不管了

27:33.770 --> 27:34.770
你要调用那个时候

27:34.770 --> 27:35.770
才会继续运行

27:35.770 --> 27:37.770
好你又想拿下一个数据

27:37.770 --> 27:38.770
ok

27:38.770 --> 27:39.770
那你之前给了你1打

27:39.770 --> 27:40.770
我继续运行

27:40.770 --> 27:41.770
n加加

27:42.770 --> 27:43.770
n又小于2

27:43.770 --> 27:44.770
对吧

27:44.770 --> 27:45.770
n又小于等于2

27:45.770 --> 27:46.770
然后呢

27:46.770 --> 27:47.770
是不是这里又有的1

27:47.770 --> 27:48.770
第二次也还是1

27:48.770 --> 27:49.770
对吧

27:49.770 --> 27:50.770
然后呢

27:50.770 --> 27:51.770
我们如果说

27:51.770 --> 27:52.770
我们又调用这个那个是

27:52.770 --> 27:53.770
ok

27:53.770 --> 27:54.770
我们又继续运行

27:54.770 --> 27:55.770
n加加

27:55.770 --> 27:56.770
又下一次循环

27:56.770 --> 27:57.770
现在这个判断进不去了

27:57.770 --> 27:58.770
是吧

27:58.770 --> 27:59.770
进入这里

27:59.770 --> 28:00.770
对吧

28:00.770 --> 28:01.770
我给你

28:01.770 --> 28:02.770
这两个指向加的结果

28:02.770 --> 28:03.770
对吧

28:03.770 --> 28:04.770
就是我就考虑

28:04.770 --> 28:05.770
我每一次怎么给你数据就行了

28:05.770 --> 28:06.770
其他的什么

28:06.770 --> 28:07.770
创建对象啊

28:07.770 --> 28:08.770
创建Y6属性

28:08.770 --> 28:09.770
当属性的那种

28:09.770 --> 28:10.770
我们不用考虑

28:10.770 --> 28:12.770
结束了就一定是

28:12.770 --> 28:14.770
这个就是一定是没东西的

28:14.770 --> 28:15.770
不可迭代了

28:15.770 --> 28:16.770
如果你还说没有结束

28:16.770 --> 28:18.770
说明说你后面还有可能有东西

28:18.770 --> 28:19.770
对吧

28:19.770 --> 28:20.770
就这么个逻辑

28:20.770 --> 28:22.770
所以我们生成性的目的呢

28:22.770 --> 28:24.770
就是为了让我们迭代起书写的

28:24.770 --> 28:27.770
变得更加的简单和容易

28:27.770 --> 28:28.770
只是这个语法

28:28.770 --> 28:29.770
大家要多体会一下

28:29.770 --> 28:30.770
Y6的

28:30.770 --> 28:31.770
Y6的什么

28:31.770 --> 28:33.770
产生产生一个数据

28:33.770 --> 28:34.770
产生一个数据

28:34.770 --> 28:35.770
一定要注意

28:35.770 --> 28:36.770
既然它产生的数据

28:36.770 --> 28:37.770
产生数据给谁的

28:37.770 --> 28:39.770
给的是生成性那个

28:39.770 --> 28:40.770
因为那个是不就是要

28:40.770 --> 28:41.770
拿这个下一个数据吗

28:41.770 --> 28:43.770
Y6的不就是产生下一个数据吗

28:43.770 --> 28:45.770
那肯定是交给的那个是

28:47.770 --> 28:48.770
那么如果说

28:48.770 --> 28:50.770
你一下这个最核心的点的话

28:50.770 --> 28:52.770
生成性的就差不多了

28:52.770 --> 28:53.770
至少呢

28:53.770 --> 28:55.770
80%的核心点你就学完了

28:55.770 --> 28:56.770
那接下来呢

28:56.770 --> 28:57.770
我们来看一下

28:57.770 --> 28:59.770
生成性的一些细节

29:00.770 --> 29:02.770
有哪些需要注意的细节

29:03.770 --> 29:06.770
有哪些需要注意的细节

29:06.770 --> 29:08.770
它细节比较多

29:08.770 --> 29:09.770
第一个

29:09.770 --> 29:10.770
一个个说吧

29:10.770 --> 29:11.770
第一个

29:11.770 --> 29:14.770
生成器函数

29:14.770 --> 29:16.770
可以有返回值的

29:16.770 --> 29:18.770
可以有返回值

29:19.770 --> 29:22.770
返回值出现在

29:22.770 --> 29:26.770
第一次当为

29:26.770 --> 29:30.770
确实的Value属性中

29:30.770 --> 29:31.770
其实真的

29:31.770 --> 29:32.770
我觉得像这些笔记

29:32.770 --> 29:34.770
大家真的不用去使心运辈

29:34.770 --> 29:35.770
甚至呢

29:35.770 --> 29:36.770
我有的时候觉得这些笔记

29:36.770 --> 29:37.770
你都不用去回过头来看

29:37.770 --> 29:39.770
你看了都不知道我来说啥

29:39.770 --> 29:40.770
关键是理解

29:40.770 --> 29:41.770
你理解了过后呢

29:41.770 --> 29:43.770
你就很难忘记了

29:43.770 --> 29:47.590
我们看一下吧

29:47.590 --> 29:48.590
把这个地方

29:48.590 --> 29:49.590
扣皮个

29:49.590 --> 29:51.590
这啥意思呢

29:51.590 --> 29:53.590
这些东西都是讲道理的

29:53.590 --> 29:54.590
都是讲道理的

29:54.590 --> 29:56.590
这里可以return

29:56.590 --> 29:57.590
return一个实

29:57.590 --> 29:58.590
你千万不要过

29:58.590 --> 30:00.590
用最容易翻出的点

30:00.590 --> 30:02.590
你认为这个东西等于实

30:02.590 --> 30:04.590
那就往上开大了

30:04.590 --> 30:06.590
讲完完全得有完将了

30:06.590 --> 30:09.290
这个return

30:09.290 --> 30:11.290
怎么看下return有什么样的效果

30:11.290 --> 30:12.290
好来吧

30:12.290 --> 30:13.290
接到return

30:13.290 --> 30:15.290
调用next

30:15.290 --> 30:16.290
第一次是不是得到

30:16.290 --> 30:18.290
Value为1

30:18.290 --> 30:19.290
当为force

30:19.290 --> 30:20.290
还没有结束

30:20.290 --> 30:21.290
还没有结束

30:21.290 --> 30:22.290
因为这个函数没有结束

30:22.290 --> 30:23.290
后面还有可能有东西

30:23.290 --> 30:24.290
对不对

30:24.290 --> 30:25.290
后面再调用

30:25.290 --> 30:26.290
是不是Value为2

30:26.290 --> 30:27.290
当为force

30:27.290 --> 30:28.290
现在卡在哪

30:28.290 --> 30:29.290
卡在这

30:29.290 --> 30:30.290
当为force

30:30.290 --> 30:31.290
对不对

30:31.290 --> 30:32.290
好

30:32.290 --> 30:33.290
然后现在再调用

30:33.290 --> 30:35.290
第三次运行

30:35.290 --> 30:36.290
当为

30:36.290 --> 30:37.290
第三次运行

30:37.290 --> 30:38.290
是不是已经把函数运行结束了

30:38.290 --> 30:39.290
因为函数return了

30:39.290 --> 30:40.290
对吧

30:40.290 --> 30:41.290
是不是函数结束了

30:41.290 --> 30:42.290
函数结束了

30:42.290 --> 30:43.290
它当一定为q

30:43.290 --> 30:44.290
当一定为q

30:44.290 --> 30:47.290
那么以前Value为undefend

30:47.290 --> 30:48.290
看到没

30:48.290 --> 30:49.290
Value是不是Value为undefend

30:49.290 --> 30:50.290
现在Value等于实

30:50.290 --> 30:51.290
对吧

30:51.290 --> 30:52.290
那么为什么等于实

30:52.290 --> 30:54.290
是因为我们这里return了实

30:54.290 --> 30:56.290
就这么个e

30:56.290 --> 30:57.290
这个return

30:57.290 --> 30:58.290
它是这么个e

30:58.290 --> 30:59.290
就是你结束

30:59.290 --> 31:01.290
就迭代结束的那一次

31:01.290 --> 31:03.290
第一次迭代结束的时候

31:03.290 --> 31:04.290
它的指示是

31:04.290 --> 31:05.290
Value为实

31:05.290 --> 31:06.290
就迭代结束了

31:06.290 --> 31:07.290
指的是这么个意思

31:07.290 --> 31:08.290
你想的那个道理

31:08.290 --> 31:09.290
迭代结束

31:09.290 --> 31:11.290
return是不是结束函数

31:11.290 --> 31:13.290
return是结束函数

31:13.290 --> 31:14.290
函数结束了

31:14.290 --> 31:15.290
是不是迭代结束了

31:15.290 --> 31:16.290
那么

31:16.290 --> 31:17.290
函数结束的时候

31:17.290 --> 31:18.290
你给它一个指

31:18.290 --> 31:19.290
是不是迭代结束的时候的指

31:19.290 --> 31:21.290
这个逻辑是通的

31:21.290 --> 31:22.290
是通的

31:22.290 --> 31:24.290
但是你要注意的一个点就是

31:24.290 --> 31:26.290
如果说你再继续调用

31:26.290 --> 31:27.290
再继续调用那个时候

31:27.290 --> 31:29.290
那么它的指能为undefend

31:29.290 --> 31:30.290
也就是它这个Value指能

31:30.290 --> 31:32.290
它只是在第一次结束的时候有效

31:32.290 --> 31:34.290
后面就没有意义了

31:34.290 --> 31:36.290
后面就没有意义了

31:36.290 --> 31:38.290
明白这个意思吧

31:38.290 --> 31:39.290
后面没有任何意义了

31:39.290 --> 31:41.290
好 这是关于return返回值

31:41.290 --> 31:42.290
返回值

31:42.290 --> 31:44.290
有的时候你可能会

31:44.290 --> 31:46.290
想提前结束迭代

31:46.290 --> 31:47.290
迭代提前结束

31:47.290 --> 31:48.290
就说你可能

31:48.290 --> 31:50.290
根据某些条件

31:50.290 --> 31:51.290
根据某些条件

31:51.290 --> 31:52.290
我可能会提前

31:52.290 --> 31:54.290
不想再给你数据了

31:54.290 --> 31:56.290
提前结束迭代

31:56.290 --> 31:57.290
OK

31:57.290 --> 31:58.290
那么你下次调用那个时候

31:58.290 --> 31:59.290
我直接给你return

31:59.290 --> 32:02.920
对吧 返回去玩手了

32:02.920 --> 32:03.920
好 这是关于这个

32:03.920 --> 32:04.920
好 第二个

32:04.920 --> 32:06.920
第二个就特别有意思了

32:06.920 --> 32:07.920
也是生存器喊出

32:07.920 --> 32:09.920
真正强大的地方

32:09.920 --> 32:11.920
它做了这么一件事

32:11.920 --> 32:13.920
生存器

32:13.920 --> 32:14.920
调用

32:14.920 --> 32:16.920
就调用生存器

32:16.920 --> 32:19.920
调用生存器的

32:19.920 --> 32:21.920
那个方法是

32:21.920 --> 32:25.920
可以传递参数

32:25.920 --> 32:26.920
见过没

32:26.920 --> 32:27.920
没见过吧

32:27.920 --> 32:28.920
生存器里边

32:28.920 --> 32:29.920
我们调用的都是

32:29.920 --> 32:30.920
直接那个是无参的调用

32:30.920 --> 32:31.920
对吧

32:31.920 --> 32:33.920
当然迭代器

32:33.920 --> 32:34.920
它并没有要求

32:34.920 --> 32:35.920
你说你这里不能传参数

32:35.920 --> 32:37.920
也没有要求说你这里必须传参数

32:37.920 --> 32:39.920
都没有要求你爱传不传

32:39.920 --> 32:41.920
平时我们以前写的迭代器

32:41.920 --> 32:42.920
传的也没用

32:42.920 --> 32:43.920
它也没用的

32:43.920 --> 32:44.920
那么这个地方

32:44.920 --> 32:45.920
那个是它可以传参数

32:45.920 --> 32:48.920
这是生存器它特有的东西

32:48.920 --> 32:50.920
那参数是啥意思呢

32:50.920 --> 32:51.920
它啥意思呢

32:51.920 --> 32:53.920
你想这个道理

32:53.920 --> 32:54.920
我要那个是啥意思

32:54.920 --> 32:56.920
那个是方法啥意思

32:56.920 --> 32:58.920
我要得到下一个对吧

32:58.920 --> 33:00.920
那有可能你要得到下一个

33:00.920 --> 33:01.920
是不是需要一些信息

33:01.920 --> 33:03.920
你没有不知道的信息

33:03.920 --> 33:04.920
你为了给我

33:04.920 --> 33:05.920
你为了给我下一个数据

33:05.920 --> 33:06.920
是不是你有一些东西

33:06.920 --> 33:08.920
你可能需要知道

33:08.920 --> 33:11.920
OK 那么我可以通过参数来告诉你

33:11.920 --> 33:14.920
你需要的一些缺失的信息

33:14.920 --> 33:15.920
是这么一个意思

33:15.920 --> 33:16.920
它可以传参数

33:16.920 --> 33:17.920
因此呢

33:17.920 --> 33:18.920
这个传递的参数

33:18.920 --> 33:19.920
可以交给谁呢

33:19.920 --> 33:21.920
传递的参数

33:21.920 --> 33:26.920
会交给EO的表达式的返回制

33:26.920 --> 33:28.920
它会交给这

33:28.920 --> 33:29.920
啥意思

33:30.920 --> 33:31.920
这啥意思

33:31.920 --> 33:35.420
咱们来看一个例子

33:35.420 --> 33:38.930
把这个去掉

33:38.930 --> 33:40.930
这个人应该都认识熟了

33:40.930 --> 33:41.930
前面的

33:41.930 --> 33:45.780
我们这里

33:49.780 --> 33:55.460
就是info

33:55.460 --> 33:56.460
OK

33:56.460 --> 33:58.460
我们这里

33:58.460 --> 34:02.460
输出info

34:02.460 --> 34:04.460
输出info

34:04.460 --> 34:05.460
OK

34:05.460 --> 34:06.460
好

34:06.460 --> 34:07.460
我们来看一下

34:07.460 --> 34:10.410
现在呢

34:10.410 --> 34:12.410
我们有这么一个生存器函数

34:12.410 --> 34:13.410
我想把它运行出来

34:13.410 --> 34:19.410
看着

34:19.410 --> 34:21.410
有这么一个生存器函数

34:21.410 --> 34:22.410
然后呢

34:22.410 --> 34:23.410
我们得到一个生存器

34:23.410 --> 34:25.410
那么我们可以对它进行迭代了

34:25.410 --> 34:26.410
生存器函数内部

34:26.410 --> 34:28.410
可以给我迭代的信息

34:28.410 --> 34:30.410
第一次调用

34:30.410 --> 34:31.410
第一次调用

34:31.410 --> 34:32.410
那个时候呢

34:32.410 --> 34:33.410
是不是得到了

34:33.410 --> 34:34.410
是啥

34:34.410 --> 34:35.410
得到了是E

34:35.410 --> 34:36.410
这个没问题吧

34:36.410 --> 34:38.410
得到的是EO的E

34:38.410 --> 34:39.410
预讯到这

34:39.410 --> 34:41.410
是不是给我了一个E

34:41.410 --> 34:42.410
OK

34:42.410 --> 34:44.410
没问题的

34:44.410 --> 34:46.410
那么接下来

34:46.410 --> 34:48.410
当我下一次

34:48.410 --> 34:49.410
你看着啊

34:49.410 --> 34:50.410
看着逻辑

34:50.410 --> 34:52.410
当我下一次得到

34:52.410 --> 34:53.410
调用那个时候

34:53.410 --> 34:55.410
是不是我希望拿后续的数据

34:55.410 --> 34:56.410
对不对

34:56.410 --> 34:58.410
是不是希望拿后续的数据

34:58.410 --> 35:00.410
然后我们看一下生存器函数里边

35:00.410 --> 35:02.410
当我需要拿

35:02.410 --> 35:04.410
后续的数据的时候

35:04.410 --> 35:05.410
比方说

35:05.410 --> 35:06.410
举个例子

35:06.410 --> 35:08.410
我们这里呢

35:09.410 --> 35:10.410
嗯

35:10.410 --> 35:12.410
加上Info

35:12.410 --> 35:15.410
比方说我写成这样的带嘛

35:15.410 --> 35:16.410
我们刚才卡在哪

35:16.410 --> 35:17.410
是不是卡在这

35:17.410 --> 35:18.410
他把第一次

35:18.410 --> 35:19.410
迭代的数据

35:19.410 --> 35:20.410
已经给我们了

35:20.410 --> 35:21.410
是不是给我们了一个

35:21.410 --> 35:22.410
再来一次

35:22.410 --> 35:23.410
是不是给我们了一个E

35:23.410 --> 35:24.410
然后呢

35:24.410 --> 35:25.410
我们现在接下来

35:25.410 --> 35:26.410
要调用那个

35:26.410 --> 35:27.410
调那个那个者

35:27.410 --> 35:28.410
你看那个逻辑

35:28.410 --> 35:30.410
主要是关注这个逻辑

35:30.410 --> 35:31.410
我们是不是要得到

35:31.410 --> 35:32.410
下一个数据

35:32.410 --> 35:34.410
下个数据是不是在这

35:34.410 --> 35:35.410
是要继续运行

35:35.410 --> 35:36.410
继续运行

35:36.410 --> 35:38.410
把下一个数据给他

35:38.410 --> 35:39.410
但是你会发现

35:39.410 --> 35:40.410
一个道理

35:40.410 --> 35:41.410
一个现象没有

35:41.410 --> 35:42.410
下一个数据

35:42.410 --> 35:43.410
是不是一带一个东西

35:43.410 --> 35:45.410
叫做Info

35:45.410 --> 35:46.410
就是我要算出

35:46.410 --> 35:47.410
下一个数据

35:47.410 --> 35:49.410
是不是我缺失一个信息

35:49.410 --> 35:50.410
缺失了一个数据

35:50.410 --> 35:52.410
叫做Info这个数据

35:52.410 --> 35:53.410
这个数据

35:53.410 --> 35:54.410
这个数据是啥

35:54.410 --> 35:55.410
我是缺失的

35:55.410 --> 35:56.410
千万不要认为

35:56.410 --> 35:57.410
这个数据是1

35:57.410 --> 35:58.410
你看这个

35:58.410 --> 35:59.410
如果说

35:59.410 --> 36:00.410
你要认为一个info是1的话

36:00.410 --> 36:01.410
应该这样子写才是1

36:01.410 --> 36:02.410
对吧

36:02.410 --> 36:03.410
这才是一个正常的复制

36:03.410 --> 36:04.410
但是你写到1

36:04.410 --> 36:05.410
有的一切都不一样了

36:05.410 --> 36:09.410
那么你至少从代码层面来看

36:09.410 --> 36:10.410
我们要下一个数据

36:10.410 --> 36:11.410
是不是要一带这个info

36:11.410 --> 36:12.410
但是info

36:12.410 --> 36:13.410
我不知道是多少

36:13.410 --> 36:15.410
那你是不是得告诉我

36:15.410 --> 36:16.410
对吧

36:16.410 --> 36:17.410
因为我下一个数据的算

36:17.410 --> 36:18.410
然后计算出了下一个数据

36:18.410 --> 36:20.410
是不是你得告诉我

36:20.410 --> 36:22.410
因此我在这里

36:22.410 --> 36:23.410
得到下一个数据

36:23.410 --> 36:25.410
他是不是缺失了一个信息

36:25.410 --> 36:26.410
我来这里跟他

36:26.410 --> 36:27.410
告诉他一个信息

36:27.410 --> 36:28.410
比方说告诉他5

36:28.410 --> 36:29.410
这个是参数

36:29.410 --> 36:31.410
这个参数会传递给谁呢

36:31.410 --> 36:32.410
你看一下

36:32.410 --> 36:33.410
上一次卡在这了

36:33.410 --> 36:34.410
对吧

36:34.410 --> 36:35.410
还没有运行完

36:35.410 --> 36:36.410
还没有复制

36:36.410 --> 36:37.410
上一次卡在这了

36:37.410 --> 36:38.410
那么这个时候

36:38.410 --> 36:39.410
我在调用的时候

36:39.410 --> 36:40.410
传了一个5进去

36:40.410 --> 36:41.410
是不是要继续运行

36:41.410 --> 36:43.410
我要得到下一个数据了

36:43.410 --> 36:44.410
对吧

36:44.410 --> 36:45.410
你代码要启动继续运行

36:45.410 --> 36:48.410
那么他就会把这个5传递给

36:48.410 --> 36:49.410
这个info

36:49.410 --> 36:50.410
有整个表达式的值

36:50.410 --> 36:52.410
就变成了5

36:52.410 --> 36:53.410
传递的参数

36:53.410 --> 36:57.410
会交给eo的表达式的返回值

36:57.410 --> 36:59.410
传递的参数这个5

36:59.410 --> 37:02.410
会交给eo的表达式

37:02.410 --> 37:03.410
传到这

37:03.410 --> 37:04.410
那么还有继续运行

37:04.410 --> 37:05.410
这里输出多少

37:05.410 --> 37:06.410
输出5

37:06.410 --> 37:07.410
对吧

37:07.410 --> 37:08.410
然后呢

37:08.410 --> 37:09.410
这里eo的多少

37:09.410 --> 37:10.410
2加5等于7

37:10.410 --> 37:11.410
对吧

37:11.410 --> 37:12.410
他就把7

37:12.410 --> 37:13.410
下一个值就是7

37:13.410 --> 37:14.410
就传回来了

37:14.410 --> 37:15.410
你看

37:15.410 --> 37:16.410
输出5

37:16.410 --> 37:17.410
来的有值为7

37:17.410 --> 37:18.410
对吧

37:18.410 --> 37:19.410
那么现在卡在哪

37:19.410 --> 37:20.410
是不是卡在这

37:20.410 --> 37:21.410
是不是卡在这

37:21.410 --> 37:22.410
对不对

37:22.410 --> 37:23.410
好

37:23.410 --> 37:24.410
那么现在呢

37:24.410 --> 37:25.410
我们比方说

37:25.410 --> 37:26.410
eo交用那个式

37:26.410 --> 37:27.410
但是我每个传参数

37:27.410 --> 37:28.410
每个传参数

37:28.410 --> 37:29.410
相当于是undefined

37:29.410 --> 37:30.410
对吧

37:30.410 --> 37:31.410
那么这样子一来的话

37:31.410 --> 37:32.410
他就继续运行

37:33.410 --> 37:34.410
然后输出undefined

37:34.410 --> 37:35.410
他就结束了

37:36.410 --> 37:37.410
undefined

37:37.410 --> 37:38.410
然后呢

37:38.410 --> 37:39.410
undefined

37:39.410 --> 37:40.410
对吧

37:40.410 --> 37:41.410
结束了

37:41.410 --> 37:42.410
这就是那个式的传参

37:42.410 --> 37:43.410
你看就是生成器

37:43.410 --> 37:45.410
和生成函数内部

37:45.410 --> 37:47.410
是不是可以不断的交互的

37:47.410 --> 37:48.410
通过eo的

37:48.410 --> 37:49.410
他可以在函数内部

37:49.410 --> 37:51.410
把值传递给生成器的

37:51.410 --> 37:52.410
下一个数据

37:52.410 --> 37:53.410
你不是要下一个数据吗

37:53.410 --> 37:54.410
OK

37:54.410 --> 37:55.410
我给你

37:55.410 --> 37:57.410
但是我也要数据

37:57.410 --> 37:59.410
你不要光是我给你一数据

37:59.410 --> 38:01.410
我有的时候也要数据

38:01.410 --> 38:02.410
你在调那个式的时候

38:02.410 --> 38:04.410
你把数据传给我

38:04.410 --> 38:05.410
这样的意思吗

38:05.410 --> 38:07.410
是这么个意思

38:07.410 --> 38:08.410
这么个意思

38:09.410 --> 38:11.410
另外也基于这个特点

38:11.410 --> 38:14.410
所以说第一次调用

38:15.410 --> 38:17.410
第一次调用

38:17.410 --> 38:19.410
那个方法是

38:20.410 --> 38:22.410
传参

38:22.410 --> 38:24.410
没有任何意义

38:25.410 --> 38:26.410
没有任何意义

38:26.410 --> 38:27.410
什么意思呢

38:27.410 --> 38:28.410
就说你第一次调用

38:28.410 --> 38:30.410
这个generator的那个式的时候

38:30.410 --> 38:32.410
你这个传参数是没有任何意义的

38:32.410 --> 38:33.410
为什么呢

38:33.410 --> 38:35.410
因为第一次调用的时候

38:35.410 --> 38:37.410
是从函数据一开始的时候运行

38:37.410 --> 38:39.410
比方说前面还有些代码

38:39.410 --> 38:41.410
函数开始

38:42.410 --> 38:44.410
从函数据一开始的时候开始运行

38:44.410 --> 38:46.410
那么这个时候连eo的都没有

38:46.410 --> 38:47.410
哪有eo的

38:47.410 --> 38:48.410
没有eo的

38:48.410 --> 38:49.410
所以从那里把这个数据给谁呢

38:49.410 --> 38:51.410
我们也不知道给谁

38:51.410 --> 38:52.410
所以第一次调用那个时候

38:52.410 --> 38:54.410
传参没有任何意义

38:54.410 --> 38:56.410
从第二次开始就有意义了

38:56.410 --> 38:58.410
第二次传参的时候

38:58.410 --> 38:59.410
第一次卡在这

38:59.410 --> 39:00.410
第一次运行完了

39:00.410 --> 39:01.410
是不是卡在这

39:01.410 --> 39:02.410
把eo交给他了

39:02.410 --> 39:03.410
就卡在这了

39:03.410 --> 39:04.410
第二次调用的时候

39:04.410 --> 39:05.410
把传参数据来

39:05.410 --> 39:06.410
是不是接着运行

39:06.410 --> 39:07.410
接着运行就把

39:07.410 --> 39:08.410
这个表拉式的值

39:08.410 --> 39:09.410
就变成参数的值了

39:09.410 --> 39:10.410
然后复制给他

39:10.410 --> 39:11.410
然后接着运行

39:11.410 --> 39:12.410
然后卡在这

39:12.410 --> 39:13.410
对吧

39:13.410 --> 39:14.410
是这么个意思

39:14.410 --> 39:15.410
因此到最开始

39:15.410 --> 39:17.410
调用是没有任何意义的

39:17.410 --> 39:18.410
这是关于

39:18.410 --> 39:19.410
这个就是

39:19.410 --> 39:20.410
那个式的方法

39:20.410 --> 39:22.410
你不要可以传参这么一个细节

39:24.410 --> 39:25.410
下一个

39:26.410 --> 39:29.230
就是生存器里边

39:29.230 --> 39:30.230
还给你提供了一些别的方法

39:33.800 --> 39:34.800
回头说

39:34.800 --> 39:35.800
单独开一个吧

39:35.800 --> 39:38.800
生存器的其他API

39:38.800 --> 39:39.800
就是生存器

39:39.800 --> 39:40.800
我们之前看到过

39:40.800 --> 39:41.800
生存器里边

39:41.800 --> 39:42.800
我们把输出

39:42.800 --> 39:43.800
接到return

39:43.800 --> 39:47.780
输出

39:49.780 --> 39:50.780
接到return

39:50.780 --> 39:51.780
输出过后

39:51.780 --> 39:52.780
你可以看到

39:52.780 --> 39:53.780
这里边其实

39:53.780 --> 39:54.780
还有一些其他方法的

39:54.780 --> 39:55.780
它不光是有next

39:55.780 --> 39:56.780
还有一个什么

39:56.780 --> 39:57.780
return

39:57.780 --> 39:58.780
还有一个straw

39:58.780 --> 39:59.780
我就讲一下这两个函数

39:59.780 --> 40:00.780
这两个方法

40:00.780 --> 40:01.780
这两个方法特别有意思

40:01.780 --> 40:02.780
第一个其他的API

40:02.780 --> 40:04.780
一个是return方法

40:05.780 --> 40:06.780
这个方法干嘛用的呢

40:06.780 --> 40:10.780
这个方法是用生存器来控制

40:10.780 --> 40:12.780
生存器函数内部

40:12.780 --> 40:14.780
提前结束的方法

40:14.780 --> 40:16.780
调用该方法

40:16.780 --> 40:17.780
然后我们平时

40:17.780 --> 40:19.780
可能目前用不到

40:19.780 --> 40:20.780
就了解一下吧

40:20.780 --> 40:21.780
调用该方法

40:21.780 --> 40:25.780
可以提前结束生存器

40:26.780 --> 40:29.780
可以结束生存器函数

40:29.780 --> 40:31.780
让整个迭代过程结束

40:31.780 --> 40:33.780
从而提前

40:33.780 --> 40:38.780
提前让整个迭代过程结束

40:40.780 --> 40:43.790
比方说

40:43.790 --> 40:45.790
我们这里就写几个简单的TES

40:45.790 --> 40:46.790
就这里就

40:46.790 --> 40:47.790
一二的

40:47.790 --> 40:49.790
一二三

40:49.790 --> 40:51.790
就一二三

40:51.790 --> 40:52.790
好来吧

40:52.790 --> 40:53.790
我们这里得到个生存器

40:53.790 --> 40:54.790
看着

40:54.790 --> 40:55.790
我们在这里

40:56.790 --> 40:58.790
一面上来写

40:59.790 --> 41:00.790
接下来的

41:00.790 --> 41:01.790
我们用generator

41:01.790 --> 41:02.790
调用那个时候

41:03.790 --> 41:04.790
当为force

41:04.790 --> 41:05.790
没问题吧

41:05.790 --> 41:06.790
运行到这

41:06.790 --> 41:07.790
那么接下来

41:07.790 --> 41:08.790
我们看一下

41:08.790 --> 41:09.790
我们用generator

41:09.790 --> 41:10.790
接下来我们用return

41:10.790 --> 41:12.790
调用return的方法

41:12.790 --> 41:13.790
这里比方说

41:13.790 --> 41:14.790
我们啥都不传吧

41:14.790 --> 41:15.790
你看

41:15.790 --> 41:16.790
是不是直接就结束了

41:16.790 --> 41:17.790
整个迭代过程直接结束了

41:17.790 --> 41:18.790
当为true

41:19.790 --> 41:21.790
然后我们后面再调用那个时候

41:21.790 --> 41:22.790
是不是就没了

41:23.790 --> 41:24.790
之前的卡在这

41:24.790 --> 41:25.790
因为卡在这的时候

41:25.790 --> 41:26.790
我们调用return

41:26.790 --> 41:27.790
是不是提前结束了

41:27.790 --> 41:28.790
就这么个意思

41:28.790 --> 41:31.790
当然return里面还可以传参数

41:31.790 --> 41:33.790
那么传参数的就是你的白六字

41:33.790 --> 41:34.790
这个没什么好说的

41:35.790 --> 41:36.790
return

41:36.790 --> 41:37.790
接下来我们再看下一个

41:37.790 --> 41:38.790
下一个方法

41:38.790 --> 41:39.790
throw

41:41.790 --> 41:42.790
这是调用该方法

41:44.790 --> 41:45.790
该方法

41:45.790 --> 41:48.790
可以在生存器中

41:48.790 --> 41:51.790
产生一个错误

41:52.790 --> 41:53.790
产生一个错误

41:53.790 --> 41:54.790
比方说

41:54.790 --> 41:55.790
我们还是来吧

41:55.790 --> 41:56.790
还是在这

41:56.790 --> 41:58.790
我们这里调用next

41:58.790 --> 42:00.790
我们这里调用next

42:00.790 --> 42:01.790
是不是拿到e

42:01.790 --> 42:02.790
看一下

42:02.790 --> 42:03.790
第一次拿到e

42:03.790 --> 42:04.790
是不是卡在这

42:04.790 --> 42:05.790
卡在这

42:05.790 --> 42:07.790
接下来我们在这

42:07.790 --> 42:08.790
又来

42:08.790 --> 42:09.790
generator

42:09.790 --> 42:10.790
我们这里调用一个slow

42:11.790 --> 42:13.790
创建一个就是六一个arrow

42:13.790 --> 42:15.790
创建一个就是错误

42:15.790 --> 42:16.790
随便写个错误

42:16.790 --> 42:17.790
那么这样一来

42:17.790 --> 42:19.790
我们是不是拨出一个错误

42:19.790 --> 42:21.790
那么这个错误会在哪里拨出呢

42:21.790 --> 42:23.790
它不是在这句话拨出

42:23.790 --> 42:25.790
而是在生存器内部

42:25.790 --> 42:26.790
之前不卡在这吗

42:27.790 --> 42:28.790
它等待你下一次点带

42:28.790 --> 42:29.790
你下一次点带的时候

42:29.790 --> 42:30.790
给它拨了一个错误

42:30.790 --> 42:31.790
它就在这里拨了一个错误

42:31.790 --> 42:32.790
于是呢

42:32.790 --> 42:33.790
这里拨了一个错误

42:33.790 --> 42:34.790
你看

42:34.790 --> 42:35.790
是不是在这里拨了一个错误

42:35.790 --> 42:37.790
这里代表明明没有错误

42:37.790 --> 42:38.790
但是是到外边的控制

42:38.790 --> 42:39.790
下一次点带的时候

42:39.790 --> 42:40.790
它出了一个错误

42:40.790 --> 42:41.790
就是slow

42:42.790 --> 42:43.790
没问题吧

42:43.790 --> 42:45.790
好 这是关于这一个点

42:47.790 --> 42:48.790
另外还有一个点

42:48.790 --> 42:49.790
还有一个点

42:49.790 --> 42:50.790
刚才在细节里边

42:54.790 --> 42:55.790
在生存器函数内部

42:56.790 --> 42:59.790
生存器函数内部

42:59.790 --> 43:02.790
可以调用其他生存器函数

43:05.790 --> 43:07.790
但是要注意

43:08.790 --> 43:10.790
加上新号

43:11.790 --> 43:12.790
加上新号

43:12.790 --> 43:13.790
什么意思呢

43:13.790 --> 43:14.790
看着

43:14.790 --> 43:15.790
我们比方说

43:15.790 --> 43:17.790
还是以这个地方为例

43:17.790 --> 43:18.790
比方TES1函数

43:18.790 --> 43:19.790
TES函数吗

43:20.790 --> 43:22.790
那么前边还有个TES函数

43:23.790 --> 43:25.790
T1函数

43:25.790 --> 43:27.790
它也是个生存器函数

43:27.790 --> 43:28.790
它也是个生存器函数

43:29.790 --> 43:31.790
我们这里EO的A

43:31.790 --> 43:33.790
然后EO的B

43:34.790 --> 43:35.790
然后再来一个

43:37.790 --> 43:38.790
就一个吧

43:38.790 --> 43:39.790
就一个就行了

43:39.790 --> 43:40.790
那么在TES函数里边

43:40.790 --> 43:41.790
我们比方说

43:41.790 --> 43:43.790
在一开始去调用T1

43:43.790 --> 43:44.790
调用T1

43:44.790 --> 43:46.790
那么在调用T1的时候

43:46.790 --> 43:48.790
有极重调用方式

43:48.790 --> 43:50.790
它有极重调用方式

43:50.790 --> 43:51.790
首先我们来说一下

43:51.790 --> 43:53.790
极重调用方式的区别

43:53.790 --> 43:55.790
第一种调用方式

43:58.420 --> 44:02.400
想一想

44:02.400 --> 44:03.400
想一想

44:03.400 --> 44:04.400
好好想一想

44:05.400 --> 44:07.400
这种调用方式

44:07.400 --> 44:11.030
我们来看一下

44:11.030 --> 44:13.030
这种调用方式是啥意思呢

44:13.030 --> 44:14.030
Generator

44:14.030 --> 44:15.030
调那个时候

44:15.030 --> 44:16.030
首先你这个那个时候

44:16.030 --> 44:18.030
能不能得到A

44:18.030 --> 44:20.030
能不能得到A

44:20.030 --> 44:22.030
你想想一个道理

44:23.030 --> 44:24.030
肯定是得不到的

44:24.030 --> 44:25.030
得到的是E

44:25.030 --> 44:26.030
为什么呢

44:26.030 --> 44:27.030
我们说过

44:28.030 --> 44:30.030
调用生成器函数

44:30.030 --> 44:31.030
会不会导致

44:31.030 --> 44:33.030
它里边的代码执行

44:34.030 --> 44:35.030
不会

44:35.030 --> 44:36.030
它只是简单的

44:36.030 --> 44:38.030
给你返回一个生成器对象

44:38.030 --> 44:39.030
而且你根本就没有

44:39.030 --> 44:41.030
接受这个生成器对象

44:41.030 --> 44:42.030
哪怕你接受了

44:42.030 --> 44:43.030
你没有用你等于0

44:43.030 --> 44:44.030
对吧

44:44.030 --> 44:45.030
你只是给你

44:45.030 --> 44:46.030
产生那个生成器对象

44:46.030 --> 44:47.030
你没有用生成器

44:47.030 --> 44:48.030
去去迭代

44:48.030 --> 44:49.030
所以说这些代码

44:49.030 --> 44:50.030
根本就不会执行的

44:50.030 --> 44:52.030
这是一种错误的调用方式

44:52.030 --> 44:54.030
第二种错误的调用方式

44:54.030 --> 44:55.030
也不是错误

44:55.030 --> 44:57.030
就是给你想要的效果

44:57.030 --> 44:58.030
肯定是不一样的

44:59.030 --> 45:00.030
是用这种方式来调用

45:01.030 --> 45:03.030
这种方式调用也是错误的

45:03.030 --> 45:04.030
为什么呢

45:04.030 --> 45:06.030
但是跟刚才的情况还不一样

45:07.030 --> 45:08.030
你看一下

45:08.030 --> 45:09.030
这一次Generator next

45:09.030 --> 45:10.030
得到的是啥

45:10.030 --> 45:11.030
你想这个道理

45:11.030 --> 45:12.030
你这一次调用那个

45:12.030 --> 45:14.030
是不是把这个东西

45:14.030 --> 45:15.030
运行的结果

45:15.030 --> 45:16.030
作为第一次

45:16.030 --> 45:18.030
叠加的数据给它了

45:18.030 --> 45:19.030
那么这个东西运行的结果

45:19.030 --> 45:20.030
是啥

45:20.030 --> 45:21.030
这东西运行的结果

45:21.030 --> 45:22.030
是不是生成器

45:22.030 --> 45:23.030
因此你这样的调用

45:23.030 --> 45:24.030
得到的是什么

45:24.030 --> 45:25.030
Value得到的是什么

45:25.030 --> 45:26.030
Value得到的是一个生成器

45:27.030 --> 45:28.030
生成器对象

45:28.030 --> 45:29.030
你是不是这个函数

45:29.030 --> 45:30.030
得到的是个生成器对象

45:30.030 --> 45:32.030
你把个生成器对象给它了

45:32.030 --> 45:34.030
变成第一次调用的结果

45:34.030 --> 45:36.030
也不是我们想要的

45:36.030 --> 45:37.030
我们想要的是啥

45:37.030 --> 45:38.030
我们想要的是

45:38.030 --> 45:40.030
在这个生成器函数的

45:40.030 --> 45:41.030
迭代过程中

45:41.030 --> 45:42.030
我们希望用

45:42.030 --> 45:44.030
去使用其他函数的

45:44.030 --> 45:46.030
迭代的过程

45:46.030 --> 45:48.030
重用别人的迭代过程

45:48.030 --> 45:49.030
那么我们应该做什么

45:49.030 --> 45:50.030
应该在这后边

45:50.030 --> 45:52.030
他要求加上个新号

45:52.030 --> 45:53.030
加上个新号

45:53.030 --> 45:54.030
是什么意思呢

45:54.030 --> 45:56.030
就是说你这个函数的内部

45:56.030 --> 45:58.030
也会参与我的迭代

45:58.030 --> 45:59.030
也会参与我的迭代

45:59.030 --> 46:01.030
就是它伸入到这个函数内部

46:01.030 --> 46:02.030
去运行

46:02.030 --> 46:03.030
然后去迭代

46:04.030 --> 46:05.030
明白了意思吗

46:05.030 --> 46:06.030
那么这样加了新号过后

46:06.030 --> 46:08.030
相当于是把你这个函数代码

46:08.030 --> 46:09.030
直接copy过来了

46:09.030 --> 46:10.030
你可以这样理解

46:10.030 --> 46:11.030
可以这样理解

46:11.030 --> 46:13.030
相当于把这个函数代码

46:13.030 --> 46:14.030
直接copy过来了

46:15.030 --> 46:16.030
那么这样子的

46:16.030 --> 46:17.030
就才是我们想要的

46:17.030 --> 46:18.030
第十得到的A

46:18.030 --> 46:19.030
第二十得到的B

46:19.030 --> 46:20.030
三是1 2 3

46:20.030 --> 46:22.030
这是关于生存器函数之间的

46:22.030 --> 46:23.030
相互调用

46:24.030 --> 46:26.030
那么知识部分

46:26.030 --> 46:28.030
就这么一些了

46:28.030 --> 46:29.030
生存器就这么一些了

46:29.030 --> 46:31.030
它之所以觉得绕

46:31.030 --> 46:34.030
是因为它的那种函数的执行方式

46:34.030 --> 46:36.030
跟我们过去区别太大了

46:36.030 --> 46:38.030
过去那我们调用函数

46:38.030 --> 46:39.030
它就全部执行完了

46:39.030 --> 46:40.030
那么现在它不是的

46:40.030 --> 46:41.030
它函数的执行

46:41.030 --> 46:43.030
要受到生存器来控制

46:44.030 --> 46:45.030
那么出现这种

46:45.030 --> 46:47.030
出现了这么一种

46:47.030 --> 46:49.030
新型的这么一种API

46:49.030 --> 46:51.030
或者叫愚法堂之后

46:51.030 --> 46:53.030
我们就可以玩一些东西出来了

46:53.030 --> 46:55.030
咱们后边两节课

46:55.030 --> 46:57.030
给大家讲一些暗地

46:57.030 --> 46:59.030
用这个生存器去完成一些暗地

46:59.030 --> 47:00.030
特别有意思

