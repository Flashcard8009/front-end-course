WEBVTT

00:00.690 --> 00:03.690
这节课呢 给大家说一下啊 这个就是

00:04.690 --> 00:06.690
要解决的另外一个问题

00:07.690 --> 00:12.690
ES6其实出来过后呢 很多时候就是解决过去的遗留了一些老问题

00:12.690 --> 00:14.690
比方说过去还有这么一个问题

00:15.690 --> 00:17.690
就有的时候呢 函数呢 他有两个用途

00:18.690 --> 00:22.690
什么两个用途呢 就是函数他既可以作为构造函数来创建一个对象

00:23.690 --> 00:25.690
又可以当成一个普通函数来调用

00:26.690 --> 00:28.690
其中比较容易发生困扰的地方在这

00:29.690 --> 00:34.690
看着啊 比方说我们这里呢 有这么一个函数叫做

00:36.690 --> 00:39.690
创建一个人 你给我传一些参数 比方说

00:43.690 --> 00:46.690
然后呢 我这里给他当前的对象里边的属性复制

00:46.690 --> 00:48.690
这个没问题吧 这代码 很简单

00:52.690 --> 00:53.690
然后再来一个吧

00:54.690 --> 00:56.690
他的全名全名就是

00:57.690 --> 00:59.690
first name 加上一个空格

01:00.690 --> 01:01.690
来吧 我们用那个什么

01:02.690 --> 01:03.690
ES6的模板字无算

01:04.690 --> 01:06.690
来自于first name 加上空格

01:07.690 --> 01:08.690
那生理

01:09.690 --> 01:11.690
好 这里呢 我们就写了这么一个函数

01:12.690 --> 01:13.690
这个函数呢

01:14.690 --> 01:16.690
你有两种调用办法

01:16.690 --> 01:17.690
哪两种调用办法呢

01:18.690 --> 01:19.690
一者呢 我们是使用

01:20.690 --> 01:23.690
六一个person 给他传一个就是

01:24.690 --> 01:26.690
哪一种调用是有效的呢

01:28.690 --> 01:32.260
好 所以这是一种调用办法

01:33.260 --> 01:35.260
另外 我们把这输出 皮子输出

01:36.260 --> 01:38.260
然后另外一种呢 我们是用这种方式

01:39.260 --> 01:40.260
就当成一个普通函数来调用

01:41.260 --> 01:42.260
再来一个

01:43.260 --> 01:44.260
person

01:45.260 --> 01:48.260
那么你觉得这个函数呢 哪一种调用是有效的呢

01:49.260 --> 01:51.260
你觉得哪一种调用是有效的呢

01:52.260 --> 01:53.260
看一下吧

01:54.260 --> 01:55.260
我们这里运行出来

01:56.260 --> 01:57.260
那肯定是只有第一种有效

01:58.260 --> 01:59.260
第二种是无效的 对吧

02:00.260 --> 02:01.260
第二种是无效的

02:02.260 --> 02:03.260
你看一下 第二种输出出来 是不是 undefend

02:04.260 --> 02:05.260
对吧 你说有的时候呢

02:06.260 --> 02:08.260
我们特别是在写一个构造函数的时候

02:09.260 --> 02:10.260
那么由于呢

02:11.260 --> 02:12.260
介石里面的函数呢

02:13.260 --> 02:15.260
原本就是有两种用途的 两种用法

02:16.260 --> 02:17.260
导致呢 有的时候呢

02:18.260 --> 02:19.260
可能别人乱用

02:20.260 --> 02:22.260
它本来应该是用构造函数的方式来调用

02:23.260 --> 02:24.260
好去用这种方式来调用

02:25.260 --> 02:26.260
普通函数的方式来调用

02:27.260 --> 02:28.260
而导致了这种这里的问题

02:29.260 --> 02:30.260
因为一旦把它当成一个普通函数来调用

02:31.260 --> 02:32.260
Z是不是出问题了 对吧

02:33.260 --> 02:34.260
Z变成什么了

02:35.260 --> 02:36.260
Z变成window对象了

02:37.260 --> 02:38.260
你看 这个window对象里面

02:39.260 --> 02:40.260
它出来了一个first name 你看没有

02:41.260 --> 02:42.260
它把它加到window对象里面去了

02:43.260 --> 02:44.260
这是我们不希望看到的

02:45.260 --> 02:47.260
所以说我们当我们写一个构造函数的时候呢

02:48.260 --> 02:49.260
我们往往需要

02:50.260 --> 02:52.260
如果说在一个非常严格的模式下边

02:53.260 --> 02:55.260
你到底是不是使用6来创建

02:56.260 --> 02:57.260
来调用函数

02:58.260 --> 03:00.260
我们需要在函数内部进行判断

03:01.260 --> 03:08.260
判断就是是否是使用6的方式来调用的函数

03:09.260 --> 03:11.260
那么有些构造 其实绝大部分构造函数

03:12.260 --> 03:14.260
都必须要要求使用6的方式来调用函数

03:15.260 --> 03:17.260
但是由于介石里边 它没有这样的控制

03:18.260 --> 03:19.260
所以说你没办法 你只能判断

03:20.260 --> 03:21.260
那么以前怎么判断的呢

03:21.260 --> 03:23.260
过去的判断方式 大家看一下

03:24.260 --> 03:27.590
过去的判断方式

03:28.590 --> 03:29.590
怎么判断呢 它就判断z

03:30.590 --> 03:33.590
z instancy

03:34.590 --> 03:37.590
就是你看一个z的指向 是不是person

03:39.590 --> 03:41.590
它的圆形链上是不是有person

03:42.590 --> 03:43.590
如果说z instancy

03:44.590 --> 03:45.590
这个判断出来的结果为假

03:46.590 --> 03:47.590
就是它没有person的话

03:48.590 --> 03:49.590
我们是不是要爆错了

03:49.590 --> 03:52.590
对 throw new exception

03:53.590 --> 03:54.590
by by error

03:55.590 --> 04:01.590
就是该函数没有使用6来创建来调用

04:02.590 --> 04:03.590
或者说必须要使用6来调用

04:04.590 --> 04:05.590
只不过爆一个错误

04:06.590 --> 04:07.590
那么这样子一来的话 你看第二个是不是就爆错了

04:08.590 --> 04:09.590
就是过去的方式 过去的用于判断的方式

04:10.590 --> 04:11.590
它判断的是z

04:12.590 --> 04:16.590
是用z这个指向来间接的推断

04:17.590 --> 04:18.590
因为你用了6之后

04:19.590 --> 04:22.590
z一定是新建的一个对象

04:23.590 --> 04:25.590
它的圆形链上是person

04:26.590 --> 04:27.590
它用这种方式来判断

04:28.590 --> 04:29.590
这种方式不是很完美

04:30.590 --> 04:31.590
为什么说不是很完美

04:32.590 --> 04:33.590
它有可能别人这样子使用的话

04:34.590 --> 04:35.590
就有可能会绕开

04:36.590 --> 04:37.590
比方说用person

04:38.590 --> 04:40.590
用call

04:42.590 --> 04:43.590
然后z

04:43.590 --> 04:50.590
给它强行绑定一个person

04:51.590 --> 04:53.590
强行绑定一个person

04:54.590 --> 04:57.590
然后在这里再传递而外的参数

04:58.590 --> 04:59.590
圆

05:03.900 --> 05:04.900
是不是就有可能会绕开这样子

05:05.900 --> 05:07.900
因为我给它强行的绑定了一个z

05:08.900 --> 05:09.900
强行的绑定了一个z

05:10.900 --> 05:11.900
你看

05:12.900 --> 05:13.900
是不是就会绕开这样的

05:14.900 --> 05:15.900
绕开这样的调用

05:15.900 --> 05:16.900
它仍然没有用6

05:17.900 --> 05:18.900
你看整个调用是不是仍然没用

05:18.900 --> 05:20.900
我们就这里传pe

05:21.900 --> 05:23.900
是不是整个调用仍然没有用6

05:23.900 --> 05:25.900
我们只是该绑定了一个z

05:27.900 --> 05:28.900
这句话抱错了

05:28.900 --> 05:29.900
把这句话注射掉

05:30.900 --> 05:32.900
你看 是不是还是得到了undefend

05:33.900 --> 05:34.900
所以仍然可以绕开

05:35.900 --> 05:37.900
所以说这种判断不是很完美

05:37.900 --> 05:39.900
但是过去是没有什么办法的

05:39.900 --> 05:41.900
因为过去从语法上来讲

05:41.900 --> 05:43.900
它就不知道到底是用6创建的

05:43.900 --> 05:45.900
还是没有使用6创建的

05:45.900 --> 05:46.900
但是现在可以了

05:47.900 --> 05:49.900
es6提供了一种模式

05:49.900 --> 05:56.900
es6提供了一个特殊的API

05:58.900 --> 06:03.900
可以使用该API在函数内部

06:03.900 --> 06:15.900
判断该函数是否使用了6来调用

06:15.900 --> 06:17.900
因为函数有两种调用方式

06:17.900 --> 06:19.900
那么它到底是用哪种调用方式来调用的

06:19.900 --> 06:20.900
我们就可以判断了

06:20.900 --> 06:22.900
那么这个新的API是什么呢

06:22.900 --> 06:24.900
这个新的API是这样的写的

06:24.900 --> 06:27.900
叫做6.target

06:28.900 --> 06:31.900
那么它指向的是什么意思呢

06:31.900 --> 06:32.900
它这个东西得到的是什么呢

06:33.900 --> 06:36.900
该表达是得到的是

06:38.900 --> 06:45.900
如果没有使用6来调用函数

06:46.900 --> 06:49.900
函数则返回到

06:50.900 --> 06:52.900
返回NG犯的

06:53.900 --> 06:55.900
如果你没有使用6来调用函数的话

06:55.900 --> 06:57.900
那么它知道的就是NG犯的

06:57.900 --> 06:59.900
如果你使用了6

06:59.900 --> 07:01.900
如果使用6

07:02.900 --> 07:04.900
调用函数

07:04.900 --> 07:06.900
则得到的是

07:06.900 --> 07:11.900
6关键字后面的函数

07:12.900 --> 07:14.900
就是得到的是函数本身

07:14.900 --> 07:16.900
6关键字后面的函数本身

07:17.900 --> 07:18.900
什么意思

07:18.900 --> 07:19.900
我们给大家举个例子

07:19.900 --> 07:20.900
你看着

07:20.900 --> 07:22.900
我们在这里输出一下

07:23.900 --> 07:24.900
我们在这里输出一下

07:25.900 --> 07:26.900
我们把这个注释掉

07:26.900 --> 07:27.900
过去的方式注释掉

07:27.900 --> 07:29.900
我们在这里直接输出

07:29.900 --> 07:30.900
输出什么呢

07:31.900 --> 07:32.900
你看一下

07:32.900 --> 07:34.900
我们用第1种方式

07:34.900 --> 07:36.900
用第1种方式来调用

07:36.900 --> 07:37.900
是不是使用了6

07:37.900 --> 07:38.900
你看它会输出什么

07:38.900 --> 07:39.900
然后第2种方式

07:39.900 --> 07:40.900
是不是没有使用6

07:40.900 --> 07:41.900
看它会输出什么

07:41.900 --> 07:43.900
第3种方式是不是也没有使用6

07:43.900 --> 07:44.900
它可能输出什么

07:44.900 --> 07:45.900
保存

07:45.900 --> 07:46.900
让它看一下

07:46.900 --> 07:48.900
我们这里就不输出了

07:48.900 --> 07:50.900
我们这里先不到底输出这个

07:50.900 --> 07:51.900
这个先不输出

07:53.900 --> 07:54.900
一共会输出3次

07:54.900 --> 07:56.900
3次调用这个函数

07:56.900 --> 07:57.900
是不是会输出3次

07:57.900 --> 07:58.900
你看一下

07:58.900 --> 07:59.900
第一次输出啥

07:59.900 --> 08:01.900
第一次是不是用6来调用的

08:01.900 --> 08:02.900
对吧

08:02.900 --> 08:03.900
用6来调用的

08:03.900 --> 08:04.900
它会在函数的执行过程中

08:04.900 --> 08:05.900
这个6点Togiz

08:05.900 --> 08:06.900
会输出啥呢

08:06.900 --> 08:08.900
是不是会输出Person本身

08:08.900 --> 08:09.900
对吧

08:09.900 --> 08:11.900
这个Togiz就是Person本身

08:11.900 --> 08:12.900
你看一下

08:12.900 --> 08:14.900
是不是Person本身

08:14.900 --> 08:15.900
为什么是Person本身呢

08:15.900 --> 08:16.900
就相当于是

08:16.900 --> 08:18.900
你这6后边6的4啥

08:18.900 --> 08:19.900
它就指向啥

08:19.900 --> 08:20.900
6的是Person

08:20.900 --> 08:21.900
OK

08:21.900 --> 08:22.900
那么这个运行过程中

08:22.900 --> 08:23.900
6点Togiz

08:23.900 --> 08:24.900
它指的是Person

08:24.900 --> 08:25.900
对吧

08:25.900 --> 08:26.900
是不是只讲Person本身

08:26.900 --> 08:27.900
好

08:27.900 --> 08:28.900
那么下面

08:28.900 --> 08:29.900
没有使用6

08:29.900 --> 08:30.900
不管你用什么Core

08:30.900 --> 08:31.900
Apply

08:31.900 --> 08:32.900
无所谓

08:32.900 --> 08:33.900
你只要没有使用6

08:33.900 --> 08:34.900
它指向的是Undefend

08:34.900 --> 08:35.900
那么这样

08:35.900 --> 08:37.900
是不是就可以完美的去判断

08:37.900 --> 08:38.900
你又没有使用6了

08:38.900 --> 08:39.900
对不对

08:39.900 --> 08:40.900
好

08:40.900 --> 08:41.900
如果说

08:41.900 --> 08:42.900
我们这里判断

08:42.900 --> 08:43.900
如果说

08:43.900 --> 08:44.900
那么这里

08:44.900 --> 08:46.900
如果说6点Togiz

08:46.900 --> 08:47.900
不等于

08:47.900 --> 08:49.900
或者说等于Undefend

08:49.900 --> 08:51.900
那么是不是没有使用6

08:51.900 --> 08:52.900
对吧

08:52.900 --> 08:54.900
我们把错误拨出去玩一玩

08:54.900 --> 08:55.900
好

08:55.900 --> 08:56.900
那么这样一来

08:56.900 --> 08:57.900
这句话

08:57.900 --> 08:59.900
下面这句话是不是爆错了

08:59.900 --> 09:01.900
这句话是不是爆错了

09:01.900 --> 09:02.900
来看一下

09:02.900 --> 09:03.900
对吧

09:03.900 --> 09:04.900
这句话爆错了

09:04.900 --> 09:05.900
然后

09:05.900 --> 09:06.900
下面

09:06.900 --> 09:07.900
如果说把这个注释掉

09:07.900 --> 09:08.900
下面这个玩意

09:08.900 --> 09:09.900
是不是也爆错了

09:09.900 --> 09:10.900
对不对

09:10.900 --> 09:11.900
这样子

09:11.900 --> 09:12.900
就可以完美的判断了

09:12.900 --> 09:13.900
就讲这个东西

09:13.900 --> 09:14.900
非常非常简单

09:14.900 --> 09:15.900
也很使用

09:15.900 --> 09:16.900
就是有的时候

09:16.900 --> 09:17.900
你在写一些

09:17.900 --> 09:19.900
内部协作

09:19.900 --> 09:21.900
内部协作比较多

09:21.900 --> 09:23.900
比较频繁的一个系统里边

09:23.900 --> 09:24.900
你可能写了一个构造函数

09:24.900 --> 09:25.900
你担心别人

09:25.900 --> 09:27.900
乱用这个构造函数

09:27.900 --> 09:28.900
造成严重的问题

09:28.900 --> 09:29.900
所以说你就可以在

09:29.900 --> 09:30.900
函数内部

09:30.900 --> 09:32.900
通过这种方式来进行判定

09:32.900 --> 09:34.900
这种是一种完美的方式

09:34.900 --> 09:35.900
判定的方式

09:35.900 --> 09:36.900
因为它判定的是

09:36.900 --> 09:38.900
语法上里有没有使用6

09:38.900 --> 09:39.900
而不是通过

09:39.900 --> 09:41.900
历史指向来间接的推断

09:41.900 --> 09:43.900
那个是有点缺陷的

09:43.900 --> 09:44.900
明白的意思吗

09:44.900 --> 09:45.900
这就是

09:45.900 --> 09:46.900
我这期课要讲的东西

09:46.900 --> 09:47.900
非常简单的功能

09:47.900 --> 09:48.900
也非常使用

