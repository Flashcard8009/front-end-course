WEBVTT

00:00.690 --> 00:04.690
好 这些课呢 开始呢 我们就要可能花几节课的时间啊

00:04.690 --> 00:11.690
来讲解ES6里边 它对于这个面向对象的语法改进

00:11.690 --> 00:13.690
因为它增加了很多很多东西啊

00:13.690 --> 00:16.690
所以说 我们一节课呢 可能讲不完 我慢慢来讲 不着急

00:16.690 --> 00:22.690
首先呢 我跟大家说一下 以前呢 这也是能不能实现面向对象的开发呢

00:22.690 --> 00:24.690
没问题 可以实现

00:24.690 --> 00:28.690
以前我们怎么实现的呢 是书写 构造函数 对吧

00:28.690 --> 00:31.690
我们知道函数呢 它有多种用途 它有两种用途

00:31.690 --> 00:33.690
一种呢 是当中普通函数来的要用

00:33.690 --> 00:36.690
另外一种呢 是当成构造函数来的要用

00:36.690 --> 00:40.690
诶 我们以前呢 就是书写构造函数来建立一个模板

00:40.690 --> 00:42.690
诶 来创建一个对象

00:42.690 --> 00:45.690
那么我们以前咋写的呢 我们首先给大家看一下啊

00:45.690 --> 00:46.690
我们以前的写法

00:46.690 --> 00:51.690
嗯 比方说啊 我们这里呢 写这么一个构造函数叫做animal

00:51.690 --> 00:53.690
啥意思呢 动物

00:53.690 --> 00:56.690
诶 你给我传递这么一些参数进来

00:56.690 --> 01:04.690
用来说动物的类型 动物的名字 动物的联名 动物的性别

01:04.690 --> 01:06.690
OK 你给我传这么一些东西进来啊

01:06.690 --> 01:09.690
好 那么我这里呢 给它是一些属性复制

01:09.690 --> 01:10.690
this type 等于 type

01:10.690 --> 01:13.690
this name 等于 name

01:13.690 --> 01:15.690
this age

01:15.690 --> 01:17.690
诶

01:17.690 --> 01:20.690
this six

01:20.690 --> 01:25.690
好 然后呢 我给动物呢 还可以加上一些方法 对吧

01:25.690 --> 01:26.690
加上一些行为

01:26.690 --> 01:27.690
那么这些方法呢

01:27.690 --> 01:31.690
我们通常是为了避免内存空间的过多开销

01:31.690 --> 01:32.690
我们是把加到哪儿呢

01:32.690 --> 01:34.690
是加到圆形上面的

01:34.690 --> 01:36.690
这些基础就是啊 你不要再丢了啊

01:36.690 --> 01:38.690
成功的课程里面都是讲的啊

01:38.690 --> 01:40.690
并且作为工艺课讲的

01:40.690 --> 01:42.690
比方说 我们这里呢

01:42.690 --> 01:43.690
那加啥方法呢

01:43.690 --> 01:45.690
给它加一个就是print嘛

01:45.690 --> 01:46.690
print方法

01:46.690 --> 01:48.690
就打印 把这个动物的信息打印出来

01:48.690 --> 01:50.690
咱们打印一下吧

01:50.690 --> 01:52.690
打印一下 咱们输出吧

01:52.690 --> 01:54.690
我们这里呢 就有模板制度受得了

01:54.690 --> 01:56.690
模板制度受得了

01:56.690 --> 01:58.690
就是动物的名称

01:58.690 --> 02:00.690
诶 名称

02:00.690 --> 02:06.690
诶 然后名称来一个就是

02:06.690 --> 02:08.690
this type

02:08.690 --> 02:10.690
对吧 这是内想的啊

02:10.690 --> 02:12.690
种类 动物的种类

02:12.690 --> 02:14.690
this type 四个嘛

02:14.690 --> 02:16.690
嗯 这是动物的名字

02:16.690 --> 02:18.690
你给这个宠物取个名

02:18.690 --> 02:20.690
名字

02:21.690 --> 02:23.690
dir

02:23.690 --> 02:25.690
然后呢 这里呢 是

02:25.690 --> 02:27.690
种动物的年龄

02:27.690 --> 02:29.690
this type age

02:29.690 --> 02:33.060
这是那个动物的

02:33.060 --> 02:35.060
性别

02:35.060 --> 02:37.060
this type 6

02:37.060 --> 02:39.060
6是 就这样吧

02:39.060 --> 02:40.060
就这样

02:40.060 --> 02:41.060
好 那么我们就把这个

02:41.060 --> 02:43.060
构造函数写好了

02:43.060 --> 02:45.060
好 咱们来用一下吧 用一下

02:45.060 --> 02:48.060
这里呢 创建这么一个animal

02:48.060 --> 02:50.060
new 一个animal

02:50.060 --> 02:52.060
那么是不是要传辑几个参数进去

02:52.060 --> 02:54.060
对吧 比方说狗

02:54.060 --> 02:56.060
它种类是一条狗

02:56.060 --> 02:58.060
然后呢 名字叫妄裁

02:58.060 --> 03:00.060
年龄呢 三岁

03:00.060 --> 03:02.060
性别的话

03:02.060 --> 03:04.060
蓝

03:04.060 --> 03:06.060
应该用功和母 是吧

03:06.060 --> 03:08.060
好 那么怎么呢 可以调用它里面的函数

03:08.060 --> 03:09.060
print

03:09.060 --> 03:11.060
好 咱们来看一下啊

03:11.060 --> 03:12.060
运营出来

03:12.060 --> 03:16.780
好 控制台里边啊

03:16.780 --> 03:18.780
把它输出了什么 输出了这些信息

03:18.780 --> 03:19.780
对吧

03:19.780 --> 03:21.780
那么现在就做成了这么一个构造函数

03:21.780 --> 03:22.780
并且呢 可以用它

03:22.780 --> 03:25.780
可以方便的来创建一个动物

03:25.780 --> 03:27.780
但是这种邪法好不好呢

03:27.780 --> 03:30.780
这种邪法呢 它容易出现几个问题

03:30.780 --> 03:32.780
什么问题呢 我们来看一下这几个问题啊

03:32.780 --> 03:34.780
使用传统的构造函数的话

03:34.780 --> 03:36.780
容易出现下面三个问题

03:36.780 --> 03:37.780
第一个问题呢

03:37.780 --> 03:40.780
属性和圆形方法

03:40.780 --> 03:42.780
它定义是分开的

03:42.780 --> 03:44.780
降低的可图性 什么意思呢

03:44.780 --> 03:45.780
也就是这一块

03:45.780 --> 03:47.780
我们是不是在给它加属性啊

03:47.780 --> 03:49.780
给它创建了一个新的堆箱

03:49.780 --> 03:51.780
这个新的堆箱里边说给它加属性

03:51.780 --> 03:52.780
那么这个东西呢

03:52.780 --> 03:53.780
我们把它叫做什么呢

03:53.780 --> 03:55.780
叫做构造函数 对不对

03:55.780 --> 03:57.780
我们把它叫做构造函数

03:57.780 --> 03:59.780
也把它叫做构造器

03:59.780 --> 04:01.780
下面呢 我们下面呢

04:01.780 --> 04:03.780
有可能给它加一些方法

04:03.780 --> 04:05.780
这些方法呢 是加到圆形上面的

04:05.780 --> 04:07.780
是吧 是不是定义

04:07.780 --> 04:09.780
实力方法 对吧

04:09.780 --> 04:11.780
加到圆形上面的

04:11.780 --> 04:13.780
也通常来把它叫做圆形方法

04:13.780 --> 04:15.780
圆形方法

04:15.780 --> 04:16.780
那么这两个东西呢

04:16.780 --> 04:18.780
其实你仔细看一下

04:18.780 --> 04:20.780
这一段代码呢

04:20.780 --> 04:22.780
实际上它们表达的是同一个意思

04:22.780 --> 04:23.780
发现没有

04:23.780 --> 04:24.780
表达什么意思呢

04:24.780 --> 04:26.780
都是给这个动物里边

04:26.780 --> 04:28.780
加一些成员 是不是这个意思啊

04:28.780 --> 04:29.780
这是个动物

04:29.780 --> 04:31.780
动物里边有这么一些成员

04:31.780 --> 04:32.780
还有这么一些成员

04:32.780 --> 04:34.780
是不是都加了一些成员进去

04:34.780 --> 04:35.780
动物里边有这些属性

04:35.780 --> 04:36.780
也有这个方法

04:36.780 --> 04:38.780
是不是表达的同一个意思啊

04:38.780 --> 04:40.780
它们应该成为一个整体

04:40.780 --> 04:41.780
从逻辑上说

04:41.780 --> 04:42.780
是不是应该是个整体

04:42.780 --> 04:44.780
但是我们现在的做法

04:44.780 --> 04:46.780
是不是把它分开的呀

04:46.780 --> 04:47.780
那如果说

04:47.780 --> 04:49.780
就可能会存在这样的代码

04:49.780 --> 04:50.780
以中间还有一把

04:50.780 --> 04:51.780
以前行别的代码

04:51.780 --> 04:53.780
可不可以这样子写

04:53.780 --> 04:55.780
中间存在别的代码

04:55.780 --> 04:57.780
以前行

04:57.780 --> 04:58.780
比方说

04:58.780 --> 04:59.780
可不可以这样子写呢

04:59.780 --> 05:00.780
是不是没问题的

05:00.780 --> 05:01.780
以前的做法是没问题的

05:01.780 --> 05:02.780
那么就有可能

05:02.780 --> 05:03.780
你写着写着

05:03.780 --> 05:05.780
就把这两块代码分开了

05:05.780 --> 05:06.780
但是呢 从逻辑上来说

05:06.780 --> 05:07.780
这两个代码

05:07.780 --> 05:08.780
是不是一个整体

05:08.780 --> 05:10.780
而且我告诉你

05:10.780 --> 05:12.780
在面向对象的世界里边

05:12.780 --> 05:14.780
它把这整个

05:14.780 --> 05:16.780
这一坨东西叫做一个内

05:16.780 --> 05:18.780
在面向对象中

05:18.780 --> 05:21.780
面向对象中

05:21.780 --> 05:23.780
将

05:23.780 --> 05:26.780
将下面

05:26.780 --> 05:29.780
对一个对象的

05:29.780 --> 05:32.780
所有成员的定义

05:32.780 --> 05:35.780
统称为内

05:35.780 --> 05:36.780
统称为内

05:36.780 --> 05:37.780
内这个概念呢

05:37.780 --> 05:38.780
实际上不是说

05:38.780 --> 05:40.780
什么也是U里边出来了

05:40.780 --> 05:42.780
生就是面向对象

05:42.780 --> 05:44.780
这个

05:44.780 --> 05:46.780
实际上世界里边

05:46.780 --> 05:47.780
存在的这么一个概念

05:47.780 --> 05:48.780
就是说

05:48.780 --> 05:50.780
我有一个内别的东西

05:50.780 --> 05:51.780
我这个内别东西呢

05:51.780 --> 05:52.780
有一些属性

05:52.780 --> 05:53.780
有一些方法

05:53.780 --> 05:55.780
我有一个动物

05:55.780 --> 05:56.780
动物里边呢

05:56.780 --> 05:57.780
它有一些属性

05:57.780 --> 05:58.780
有一些方法

05:58.780 --> 05:59.780
明不明白意思吗

05:59.780 --> 06:01.780
它把它统称为一个内

06:01.780 --> 06:02.780
这个东西呢

06:02.780 --> 06:03.780
从逻辑上来说

06:03.780 --> 06:04.780
应该是一个整体

06:04.780 --> 06:05.780
但是呢

06:05.780 --> 06:06.780
我们以前的做法是把它分开的

06:06.780 --> 06:07.780
这样从一发角度来说

06:07.780 --> 06:08.780
不好

06:08.780 --> 06:09.780
为什么不好呢

06:09.780 --> 06:10.780
为什么会出现这么一个现象呢

06:10.780 --> 06:11.780
是因为

06:11.780 --> 06:12.780
这也是语言

06:12.780 --> 06:14.780
它本来一开始做的时候

06:14.780 --> 06:16.780
压格就没有考虑到面向对象

06:16.780 --> 06:18.780
它做了对象了

06:18.780 --> 06:19.780
但是呢

06:19.780 --> 06:20.780
它没有去

06:20.780 --> 06:21.780
过多的去考虑用

06:21.780 --> 06:22.780
面向对象的方式来开发

06:22.780 --> 06:23.780
因为它知道

06:23.780 --> 06:24.780
当当时

06:24.780 --> 06:25.780
他们设计这个语言的时候呢

06:25.780 --> 06:26.780
仅仅是为了

06:26.780 --> 06:29.780
做一些页面上的小的效果

06:29.780 --> 06:31.780
压格没有必要使用

06:31.780 --> 06:32.780
面向对象的模式来开发

06:32.780 --> 06:33.780
但是后来呢

06:33.780 --> 06:35.780
我们代码越写越多

06:35.780 --> 06:36.780
设计到系统呢

06:36.780 --> 06:37.780
越来越复杂

06:37.780 --> 06:38.780
所以说需要面向对象

06:38.780 --> 06:39.780
那怎么办呢

06:39.780 --> 06:40.780
很多的开发者

06:40.780 --> 06:41.780
就开始研究

06:41.780 --> 06:44.780
怎么去模拟一个对象出来

06:44.780 --> 06:46.780
面向对象的那种做法出来

06:46.780 --> 06:47.780
于是形成了现代的做法

06:47.780 --> 06:49.780
对吧 是不是挺麻烦的

06:49.780 --> 06:51.780
这是这个问题

06:51.780 --> 06:52.780
好 第二个问题

06:52.780 --> 06:53.780
我来看一下

06:53.780 --> 06:54.780
第二个问题呢

06:54.780 --> 06:55.780
圆形成员

06:55.780 --> 06:57.780
是可以被眉聚的

06:57.780 --> 06:58.780
这啥意思呢

06:58.780 --> 07:00.780
圆形成员可以被眉聚

07:00.780 --> 07:01.780
你看一下这个对象

07:01.780 --> 07:02.780
这个对象

07:02.780 --> 07:03.780
这个对象呢

07:03.780 --> 07:04.780
我们有的时候呢

07:04.780 --> 07:06.780
可能要得到它的所有的成员

07:06.780 --> 07:07.780
对吧 所有的属性

07:07.780 --> 07:09.780
我们可能就会对它进行循环

07:09.780 --> 07:10.780
诶 用一个什么

07:10.780 --> 07:11.780
循环呢

07:11.780 --> 07:12.780
否硬循环

07:12.780 --> 07:13.780
对吧

07:13.780 --> 07:14.780
我们这里循环

07:14.780 --> 07:15.780
它每一个属性

07:15.780 --> 07:16.780
循环A的每一个属性

07:16.780 --> 07:17.780
然后呢

07:17.780 --> 07:18.780
我们输出它的属性名

07:18.780 --> 07:19.780
我们来看一下

07:19.780 --> 07:21.780
它里边可以输出哪些东西啊

07:21.780 --> 07:22.780
你看我们输出了

07:22.780 --> 07:24.780
Type name age 6

07:24.780 --> 07:26.780
还输出了什么print

07:26.780 --> 07:27.780
而实际上呢

07:27.780 --> 07:29.780
我们绝大部分时候

07:29.780 --> 07:31.780
我们在辩立一个

07:31.780 --> 07:33.780
对象的成员的时候

07:33.780 --> 07:34.780
是不希望

07:34.780 --> 07:36.780
辩立它圆形上面的东西的

07:36.780 --> 07:37.780
是不希望的

07:37.780 --> 07:39.780
我们只希望

07:39.780 --> 07:40.780
辩立它这个成员

07:40.780 --> 07:42.780
本身已有的东西

07:42.780 --> 07:45.780
不希望辩立它圆形上的东西

07:45.780 --> 07:46.780
对不对

07:46.780 --> 07:47.780
那能不能控制呢

07:47.780 --> 07:48.780
能控制

07:48.780 --> 07:49.780
只不过呢

07:49.780 --> 07:50.780
稍险麻烦

07:50.780 --> 07:51.780
我们之后呢

07:51.780 --> 07:52.780
会有一些课

07:52.780 --> 07:53.780
来专门来讲

07:53.780 --> 07:54.780
这个As5

07:54.780 --> 07:55.780
模拟As6

07:55.780 --> 07:56.780
这个内的实现

07:56.780 --> 07:57.780
我们会出到这个问题

07:57.780 --> 07:58.780
怎么去控制

07:58.780 --> 07:59.780
那么现在呢

07:59.780 --> 08:00.780
不管

08:00.780 --> 08:01.780
只知道合一媒举

08:01.780 --> 08:02.780
合一媒举

08:02.780 --> 08:03.780
但是呢

08:03.780 --> 08:04.780
我们是不希望

08:04.780 --> 08:05.780
有这么个现象出现

08:05.780 --> 08:06.780
都是这个问题

08:06.780 --> 08:07.780
第三个问题呢

08:07.780 --> 08:09.780
在默认的情况下

08:09.780 --> 08:10.780
勾造函数

08:10.780 --> 08:11.780
虽然说我们写的勾造

08:11.780 --> 08:12.780
是勾造函数

08:12.780 --> 08:14.780
看上去像勾造函数

08:14.780 --> 08:15.780
但是在我们使用的时候

08:15.780 --> 08:16.780
能不能当成

08:16.780 --> 08:17.780
普通函数来使用呢

08:17.780 --> 08:18.780
是不是也可以啊

08:18.780 --> 08:19.780
你这样子使用

08:19.780 --> 08:20.780
是不是也可以

08:20.780 --> 08:21.780
对吧

08:21.780 --> 08:22.780
但是呢

08:22.780 --> 08:23.780
后面就爆出了

08:23.780 --> 08:24.780
它这个地方

08:24.780 --> 08:25.780
因为返回的是undefend

08:25.780 --> 08:26.780
对吧

08:26.780 --> 08:27.780
这个函数

08:27.780 --> 08:28.780
它没有返回值

08:28.780 --> 08:29.780
返回的是undefend

08:29.780 --> 08:30.780
可以把它当成普通函数

08:30.780 --> 08:31.780
来使用

08:31.780 --> 08:32.780
当然呢

08:32.780 --> 08:33.780
你可以说

08:34.780 --> 08:35.780
对吧

08:35.780 --> 08:36.780
加一点单码

08:36.780 --> 08:37.780
来控制一下

08:37.780 --> 08:38.780
来判断一下

08:38.780 --> 08:39.780
但是呢

08:39.780 --> 08:40.780
毕竟是不方便

08:40.780 --> 08:41.780
因为我们这里说

08:41.780 --> 08:42.780
默认情况下呢

08:42.780 --> 08:43.780
它可以当成普通函数

08:43.780 --> 08:44.780
使用

08:44.780 --> 08:45.780
那么这些问题呢

08:45.780 --> 08:46.780
在ES6里面

08:46.780 --> 08:48.780
都是需要解决的

08:48.780 --> 08:49.780
于是呢

08:49.780 --> 08:50.780
ES6里面

08:50.780 --> 08:51.780
做了很大的感情

08:51.780 --> 08:53.780
对这一块东西

08:53.780 --> 08:54.780
于是它做了什么感情呢

08:54.780 --> 08:55.780
我们来实现一个

08:55.780 --> 08:56.780
一模一样的功能

08:56.780 --> 08:57.780
来看一下

08:57.780 --> 08:58.780
在ES6里面

08:58.780 --> 09:00.780
要书写一个勾造函数

09:00.780 --> 09:01.780
或者说

09:01.780 --> 09:02.780
更确切的说

09:02.780 --> 09:03.780
类

09:03.780 --> 09:04.780
这个类里面

09:04.780 --> 09:05.780
有勾造器

09:05.780 --> 09:06.780
有什么呢

09:06.780 --> 09:07.780
有各种圆形方法

09:07.780 --> 09:08.780
那么要书写一个类的话

09:08.780 --> 09:10.780
在ES6里面

09:10.780 --> 09:11.780
该怎么来写

09:11.780 --> 09:12.780
我们再说一次

09:12.780 --> 09:13.780
这个东西

09:13.780 --> 09:14.780
统称为一个类

09:14.780 --> 09:15.780
好

09:15.780 --> 09:16.780
那么我们在

09:16.780 --> 09:17.780
这里新鲜的文件

09:17.780 --> 09:18.780
或者我们这里

09:18.780 --> 09:23.060
复制一下吧

09:23.060 --> 09:24.060
复制这个就行了

09:24.060 --> 09:25.060
这个呢

09:25.060 --> 09:26.060
我们

09:26.060 --> 09:27.060
给它

09:27.060 --> 09:28.060
换个名字

09:28.060 --> 09:29.060
换个名字叫做

09:29.060 --> 09:34.060
old constructor

09:34.060 --> 09:35.060
我们这里

09:35.060 --> 09:36.060
把英这个时候改一下

09:36.060 --> 09:37.060
好

09:37.060 --> 09:38.060
改成什么呢

09:38.060 --> 09:39.060
我们来对照起来写

09:39.060 --> 09:41.060
一边对照之前的代码

09:41.060 --> 09:42.060
一边来

09:42.060 --> 09:44.060
我们来写新的代码

09:44.060 --> 09:47.060
这里我们切分一下

09:47.060 --> 09:48.060
OK

09:48.060 --> 09:49.060
好

09:49.060 --> 09:50.060
那么我们现在来写

09:50.060 --> 09:51.060
ES6里面怎么写呢

09:51.060 --> 09:52.060
ES6里面是这样写的

09:52.060 --> 09:54.060
你要建一个类

09:54.060 --> 09:55.060
因为ES5里面

09:55.060 --> 09:56.060
是没有类这个概念的

09:56.060 --> 09:57.060
对吧

09:57.060 --> 09:58.060
我们都用勾造函数

09:58.060 --> 09:59.060
来创建对象的

09:59.060 --> 10:00.060
我们的重原方法

10:00.060 --> 10:01.060
就是方法

10:01.060 --> 10:02.060
原型方法是分开写的

10:02.060 --> 10:03.060
但是在ES6里面

10:03.060 --> 10:04.060
它把这个类的概念

10:04.060 --> 10:06.060
实际化的到这个语言里面了

10:06.060 --> 10:07.060
因此我们在语言里面

10:07.060 --> 10:09.060
就可以使用类的语法

10:09.060 --> 10:10.060
叫做class

10:10.060 --> 10:11.060
class

10:11.060 --> 10:12.060
class

10:12.060 --> 10:13.060
它是个关键字

10:13.060 --> 10:15.060
表示我要定义一个类

10:15.060 --> 10:17.060
后面来写上类的名称

10:17.060 --> 10:18.060
类的名称相当于什么呢

10:18.060 --> 10:19.060
相当于就是

10:19.060 --> 10:20.060
勾造函数的名称

10:20.060 --> 10:21.060
我们这里写

10:21.060 --> 10:22.060
indim

10:22.060 --> 10:23.060
然后写上什么

10:23.060 --> 10:25.060
两个大括号

10:25.060 --> 10:28.060
这个大括号里边写啥呢

10:28.060 --> 10:29.060
大括号里边

10:29.060 --> 10:31.060
你可以写上一个

10:31.060 --> 10:32.060
关键字

10:32.060 --> 10:33.060
叫做constructor

10:33.060 --> 10:34.060
注意啊

10:34.060 --> 10:35.060
你看蓝色的

10:35.060 --> 10:36.060
它是一个关键字

10:36.060 --> 10:38.060
以后你命名

10:38.060 --> 10:39.060
你不能命名为class

10:39.060 --> 10:40.060
命名为constructor

10:40.060 --> 10:42.060
现在已经是关键字了

10:42.060 --> 10:44.060
那么constructor相当于什么呢

10:44.060 --> 10:46.060
相对它的勾造器

10:46.060 --> 10:47.060
这个类的勾造器

10:47.060 --> 10:48.060
这是一个类

10:48.060 --> 10:49.060
这是类的名称

10:49.060 --> 10:51.060
其实它对应到ES5里面

10:51.060 --> 10:53.060
就相当于是一个勾造函数

10:53.060 --> 10:55.060
这是类的名称

10:55.060 --> 10:57.060
那么它的勾造器怎么写呢

10:57.060 --> 10:58.060
勾造器是一个函数

10:58.060 --> 10:59.060
那么这个勾造器

10:59.060 --> 11:01.060
使用constructor关键字

11:01.060 --> 11:02.060
它的函数

11:02.060 --> 11:03.060
OK

11:03.060 --> 11:04.060
我们把这个代码

11:04.060 --> 11:05.060
我们把这个代码

11:05.060 --> 11:06.060
复制过来

11:06.060 --> 11:07.060
就这样子写

11:07.060 --> 11:09.060
那么这一段代码

11:09.060 --> 11:10.060
就相当于是

11:10.060 --> 11:12.060
有点类似于这段代码

11:12.060 --> 11:14.060
相当于是这段代码

11:14.060 --> 11:15.060
好

11:15.060 --> 11:17.060
然后它里边的圆形方法怎么写呢

11:17.060 --> 11:18.060
圆形方法

11:18.060 --> 11:20.060
我们不再使用这种方式了

11:20.060 --> 11:21.060
不再使用这种方式了

11:21.060 --> 11:22.060
而是怎么写呢

11:22.060 --> 11:24.060
而是在这里直接写print

11:24.060 --> 11:27.060
并且使用这种模式来写

11:27.060 --> 11:28.060
就有点像什么呢

11:28.060 --> 11:29.060
我们之前讲的

11:29.060 --> 11:31.060
在右里边的方法数写

11:31.060 --> 11:32.060
对吧

11:32.060 --> 11:34.060
不用去写什么方个型了

11:34.060 --> 11:35.060
方个型关键字不用写了

11:35.060 --> 11:37.060
你直接写上方法名字

11:37.060 --> 11:38.060
后边是参数列表

11:38.060 --> 11:39.060
后边是方法题

11:39.060 --> 11:41.060
好 那么我们这里直接写过来

11:41.060 --> 11:42.060
那么我们来对比一下

11:42.060 --> 11:44.060
光从语言的层面来对比一下

11:44.060 --> 11:46.060
你看 这两个是一样的功能哦

11:46.060 --> 11:47.060
这两个是一样的功能

11:47.060 --> 11:49.060
那左边代码是不是看上去

11:49.060 --> 11:51.060
更加像一个整体啊

11:51.060 --> 11:52.060
对吧

11:52.060 --> 11:54.060
这是我们的类的勾造函数

11:54.060 --> 11:55.060
勾造器

11:55.060 --> 11:57.060
这是我们类里边的各种成员

11:57.060 --> 11:59.060
哪些圆形方法

11:59.060 --> 12:00.060
那么如果说方法1

12:00.060 --> 12:01.060
方法2你直接写到这儿

12:01.060 --> 12:03.060
方法2你直接写就行了

12:03.060 --> 12:05.060
有什么参数写有什么参数

12:05.060 --> 12:07.060
好 那么可以实现一样的功能

12:07.060 --> 12:09.060
但是呢我们从语法角度来说

12:09.060 --> 12:11.060
这个逻辑是不是更加合理一点

12:11.060 --> 12:12.060
它本身就是一个整体

12:12.060 --> 12:13.060
对吧

12:13.060 --> 12:15.060
那么用一下试一下呗

12:15.060 --> 12:17.060
我们这里复制三天过来

12:17.060 --> 12:18.060
用一下试一下

12:18.060 --> 12:19.060
好 我们看一下

12:19.060 --> 12:20.060
是不是一样的

12:20.060 --> 12:22.060
完全一样的

12:22.060 --> 12:24.060
而且呢我们去打印一下

12:24.060 --> 12:25.060
这个A

12:25.060 --> 12:26.060
把A打印出来

12:26.060 --> 12:27.060
你会看到呢

12:27.060 --> 12:29.060
它已经帮你搞定了很多事情了

12:29.060 --> 12:31.060
你看我们这是我们的属性对吧

12:31.060 --> 12:32.060
对象里面的属性

12:32.060 --> 12:35.060
并且呢圆形上边是不是有个Print

12:35.060 --> 12:36.060
它会自动的把这个

12:36.060 --> 12:38.060
这些方法的放到圆形里边

12:38.060 --> 12:40.060
因此呢我不用再去用

12:40.060 --> 12:42.060
以前老的那种方式啊

12:42.060 --> 12:43.060
去操纵它的圆形

12:43.060 --> 12:45.060
在圆形里边去加方法

12:45.060 --> 12:46.060
你的所有的方法

12:46.060 --> 12:48.060
全部在圆形里边

12:48.060 --> 12:50.060
这就是写到这类里边的

12:50.060 --> 12:51.060
除了这个勾造器里边

12:51.060 --> 12:53.060
外面写的这些东西

12:53.060 --> 12:55.060
全是在圆形上面

12:55.060 --> 12:57.060
这就是ES6里边的

12:57.060 --> 12:59.060
内的语法

12:59.060 --> 13:00.060
能看明白吗

13:00.060 --> 13:02.060
应该没有什么问题吧

13:02.060 --> 13:04.060
对比右边代码

13:04.060 --> 13:05.060
好 然后呢

13:05.060 --> 13:06.060
我们来看一下

13:06.060 --> 13:07.060
它是否能够解决

13:07.060 --> 13:09.060
之前我们说到

13:09.060 --> 13:10.060
ES5里边的那种

13:10.060 --> 13:11.060
勾造器的写法

13:11.060 --> 13:12.060
它的问题呢

13:12.060 --> 13:14.060
我们的一个看啊

13:14.060 --> 13:15.060
第一个问题

13:15.060 --> 13:16.060
说什么呢

13:16.060 --> 13:19.060
说圆形的分离

13:19.060 --> 13:20.060
对吧 降级的可读性

13:20.060 --> 13:22.060
圆形方法和属性分离

13:22.060 --> 13:23.060
那么现在分离了吗

13:23.060 --> 13:24.060
变成一个整体了

13:24.060 --> 13:25.060
它们都属于

13:25.060 --> 13:27.060
同一个类里边的

13:27.060 --> 13:28.060
一个类型

13:28.060 --> 13:29.060
类什么 类就是类型啊

13:29.060 --> 13:30.060
你多了一个类型

13:30.060 --> 13:31.060
多了一个什么类型

13:31.060 --> 13:32.060
多了一个animal类型

13:32.060 --> 13:34.060
多了一条狗的类型

13:34.060 --> 13:35.060
那么我们可以通过这个类型

13:35.060 --> 13:37.060
去创建各种各样的动物了

13:37.060 --> 13:39.060
对吧

13:39.060 --> 13:40.060
不是狗

13:40.060 --> 13:41.060
是动物

13:41.060 --> 13:42.060
多了一个类型动物

13:42.060 --> 13:43.060
这就是类

13:43.060 --> 13:44.060
那么它把它聚合到

13:44.060 --> 13:45.060
一个类里边了

13:45.060 --> 13:46.060
看上去呢

13:46.060 --> 13:47.060
更加像一个整体

13:47.060 --> 13:48.060
第一个问题解决了

13:48.060 --> 13:49.060
第二个问题

13:49.060 --> 13:50.060
圆形成员

13:50.060 --> 13:51.060
能不能每一句呢

13:51.060 --> 13:52.060
它自动的把

13:52.060 --> 13:53.060
圆形成员

13:53.060 --> 13:54.060
设置为不能每一句的

13:54.060 --> 13:55.060
所以说我们这里

13:55.060 --> 13:56.060
使用拨印

13:56.060 --> 13:59.060
去循环它的所有的

13:59.060 --> 14:01.060
成员的时候呢

14:01.060 --> 14:02.060
我们输出

14:02.060 --> 14:04.060
因为看到只有

14:04.060 --> 14:06.060
什么属性对吧

14:06.060 --> 14:07.060
只有在这里边

14:07.060 --> 14:08.060
加的这些东西

14:08.060 --> 14:09.060
这是我们需要的

14:09.060 --> 14:10.060
因为我们很多时候

14:10.060 --> 14:12.060
去便利一个对象的时候呢

14:12.060 --> 14:13.060
我便利它

14:13.060 --> 14:14.060
圆形上面的东西

14:14.060 --> 14:15.060
一般没有什么意义

14:15.060 --> 14:16.060
所以说它

14:16.060 --> 14:17.060
根据实际情况

14:17.060 --> 14:19.060
它把圆形上面的东西

14:19.060 --> 14:20.060
全部给你屏蔽了

14:20.060 --> 14:21.060
你在循环的时候

14:21.060 --> 14:22.060
根本就循环不了

14:22.060 --> 14:23.060
它圆形上面的东西

14:23.060 --> 14:24.060
看到没有

14:24.060 --> 14:25.060
它圆形上面的东西

14:25.060 --> 14:26.060
是不能便利的

14:26.060 --> 14:28.060
好 第三个情况呢

14:28.060 --> 14:29.060
构造函数

14:29.060 --> 14:30.060
它能不能当成

14:30.060 --> 14:31.060
普通函数来使用呢

14:31.060 --> 14:32.060
因为我们知道

14:32.060 --> 14:33.060
这个animal实际上

14:33.060 --> 14:34.060
所以说我们这里

14:34.060 --> 14:35.060
为什么说

14:35.060 --> 14:36.060
它是语法堂呢

14:36.060 --> 14:37.060
它最底底层实际上

14:37.060 --> 14:38.060
并没有发生

14:38.060 --> 14:39.060
太大的变化

14:39.060 --> 14:40.060
只是给你提供

14:40.060 --> 14:41.060
那种新的语法

14:41.060 --> 14:42.060
让你写起来了

14:42.060 --> 14:43.060
更加像一个

14:43.060 --> 14:45.060
连向对象的输写方式

14:45.060 --> 14:46.060
因为很多

14:46.060 --> 14:47.060
连向对象的语言

14:47.060 --> 14:48.060
都是这么写的

14:48.060 --> 14:49.060
如果你接触过

14:49.060 --> 14:50.060
接下来你就知道了

14:50.060 --> 14:51.060
大部分连向对象的语言

14:51.060 --> 14:52.060
它的写法

14:52.060 --> 14:54.060
大致上都是这么写的

14:54.060 --> 14:55.060
好 那么现在呢

14:55.060 --> 14:56.060
我们一个问题就是

14:56.060 --> 14:57.060
之前的构造函数

14:57.060 --> 14:58.060
它可以当成

14:58.060 --> 14:59.060
普通函数来调用

14:59.060 --> 15:00.060
那么现在这个animal

15:00.060 --> 15:01.060
它能不能当成

15:01.060 --> 15:02.060
普通函数调用呢

15:02.060 --> 15:04.060
我们把这个溜去掉

15:04.060 --> 15:05.060
你看一下

15:05.060 --> 15:06.060
就爆错了

15:06.060 --> 15:07.060
爆出来哪一行

15:07.060 --> 15:08.060
它爆出来这一行

15:08.060 --> 15:09.060
这一行爆错了

15:09.060 --> 15:10.060
这一行爆出来

15:10.060 --> 15:11.060
什么错呢

15:11.060 --> 15:12.060
它说class

15:12.060 --> 15:13.060
nate constructor

15:13.060 --> 15:15.060
nate 构造器 animal

15:15.060 --> 15:17.060
它是不能

15:18.060 --> 15:19.060
被调用

15:19.060 --> 15:20.060
怎么情况下调用呢

15:20.060 --> 15:22.060
缺失关键至溜的

15:22.060 --> 15:23.060
情况下被调用的

15:23.060 --> 15:25.060
就这么个意思

15:25.060 --> 15:26.060
所以说呢

15:26.060 --> 15:28.060
在我们es6里边

15:28.060 --> 15:29.060
它有更加严格的

15:29.060 --> 15:30.060
语法环境

15:30.060 --> 15:31.060
所以说

15:31.060 --> 15:32.060
你在使用nate的时候

15:32.060 --> 15:34.060
你必须按照nate

15:34.060 --> 15:35.060
连向对象的输写方式

15:35.060 --> 15:36.060
来使用

15:36.060 --> 15:37.060
而不应该使用普通

15:37.060 --> 15:39.060
当成普通还需要调用

15:39.060 --> 15:40.060
其实就把这个

15:40.060 --> 15:42.060
三个问题解决了

15:42.060 --> 15:43.060
好 这一刻呢

15:43.060 --> 15:44.060
我们就要说的东西

15:44.060 --> 15:45.060
其实不多

15:45.060 --> 15:46.060
就这么一些东西

15:46.060 --> 15:47.060
后边的一些

15:47.060 --> 15:48.060
后边的课程里面

15:48.060 --> 15:49.060
还会讲解

15:49.060 --> 15:50.060
那么我们来看一下

15:50.060 --> 15:51.060
nate里边的特点

15:51.060 --> 15:53.060
关注一下它里边的细节

15:53.060 --> 15:54.060
第一个的细节呢

15:54.060 --> 15:55.060
就是nate的声明

15:55.060 --> 15:56.060
它是不会被提升的

15:56.060 --> 15:57.060
所以说你像

15:57.060 --> 15:58.060
定一个nate之后

15:58.060 --> 15:59.060
你要在温斗对象里面

15:59.060 --> 16:00.060
去找到它

16:00.060 --> 16:01.060
那不好意思 找不到

16:01.060 --> 16:03.060
这是第一个

16:03.060 --> 16:04.060
animal

16:04.060 --> 16:05.060
是不是找不到

16:05.060 --> 16:06.060
animal找不到

16:06.060 --> 16:07.060
好 另外一个呢

16:07.060 --> 16:08.060
就是说

16:08.060 --> 16:09.060
它由于不会提升

16:09.060 --> 16:10.060
它跟那个nate

16:10.060 --> 16:11.060
和counter一样

16:11.060 --> 16:13.060
存在暂时性死去

16:13.060 --> 16:14.060
那是怎么意思呢

16:14.060 --> 16:15.060
就是说

16:15.060 --> 16:16.060
在声明内之前

16:16.060 --> 16:17.060
去使用的话

16:17.060 --> 16:19.060
那么你是不能用的

16:19.060 --> 16:20.060
比方说

16:20.060 --> 16:21.060
比方说

16:21.060 --> 16:22.060
我们这个代码

16:22.060 --> 16:23.060
放到前面

16:24.060 --> 16:25.060
放到前面

16:25.060 --> 16:26.060
2嘛

16:27.060 --> 16:28.060
好 保存

16:28.060 --> 16:29.060
那么你看一下

16:29.060 --> 16:30.060
是告诉你

16:30.060 --> 16:31.060
跟那个nate

16:31.060 --> 16:32.060
counter是不一样的

16:32.060 --> 16:33.060
它说

16:33.060 --> 16:34.060
你不能在

16:34.060 --> 16:35.060
除死化之前

16:35.060 --> 16:37.060
去使用这个东西

16:37.060 --> 16:38.060
对吧

16:38.060 --> 16:39.060
是不是不能使用

16:39.060 --> 16:40.060
对吧

16:40.060 --> 16:41.060
那么为什么又这样子呢

16:41.060 --> 16:42.060
它也是跟很多的

16:42.060 --> 16:43.060
面向对象语言

16:43.060 --> 16:44.060
它的那种

16:44.060 --> 16:45.060
设计事路暖保持一致

16:45.060 --> 16:47.060
nate一定要先定义

16:47.060 --> 16:48.060
再使用

16:48.060 --> 16:49.060
那么这一块

16:49.060 --> 16:50.060
就先定义再使用

16:51.060 --> 16:52.060
好 那么这是

16:52.060 --> 16:53.060
这个第一个特点

16:53.060 --> 16:54.060
第二个特点就是

16:54.060 --> 16:56.060
nate里边的所有代码

16:56.060 --> 16:57.060
包括你什么呢

16:57.060 --> 16:59.060
构造函数里边

16:59.060 --> 17:01.060
包括你的死力方法里边

17:01.060 --> 17:03.060
对元雄方法里边

17:03.060 --> 17:04.060
它们都是在

17:04.060 --> 17:06.060
严格模式下执行的

17:06.060 --> 17:07.060
它自动给你

17:07.060 --> 17:08.060
加上严格模式

17:08.060 --> 17:09.060
你跑不了的

17:10.060 --> 17:11.060
第三个呢

17:11.060 --> 17:12.060
是nate里边的

17:12.060 --> 17:13.060
所有方法

17:13.060 --> 17:14.060
都是不可没举的

17:14.060 --> 17:15.060
我们刚才说了

17:15.060 --> 17:16.060
然后呢

17:16.060 --> 17:17.060
第四个

17:17.060 --> 17:18.060
第四个很有意思

17:18.060 --> 17:19.060
第四个说的是

17:19.060 --> 17:20.060
nate所有方法

17:20.060 --> 17:22.060
内部都无

17:22.060 --> 17:25.060
nate所有方法

17:25.060 --> 17:26.060
应该是这样说

17:26.060 --> 17:27.060
多了两个字

17:27.060 --> 17:28.060
nate所有方法

17:28.060 --> 17:29.060
都无法被当作

17:29.060 --> 17:31.060
构造函数使用

17:31.060 --> 17:32.060
怎么意思呢

17:32.060 --> 17:33.060
怎么意思呢

17:34.060 --> 17:35.060
它就是

17:35.060 --> 17:36.060
怕你用这种形式去写

17:36.060 --> 17:37.060
你看着

17:37.060 --> 17:39.060
它怕你用这种形式去写

17:39.060 --> 17:43.260
以前是不是可以

17:43.260 --> 17:44.260
你告诉我

17:44.260 --> 17:45.260
以前绝对是可以的

17:45.260 --> 17:46.260
因为

17:46.260 --> 17:47.260
我们知道

17:47.260 --> 17:48.260
以前的解释函数

17:48.260 --> 17:49.260
都有两种用途

17:49.260 --> 17:50.260
要么呢

17:50.260 --> 17:51.260
可以被担

17:51.260 --> 17:52.260
可以

17:52.260 --> 17:53.260
普通调用

17:53.260 --> 17:54.260
也可以把它当成

17:54.260 --> 17:55.260
构造函数来调用

17:55.260 --> 17:56.260
所有函数都是这样子

17:56.260 --> 17:57.260
不是说你给了一个

17:57.260 --> 17:58.260
大写字母a

17:58.260 --> 17:59.260
大写字母

17:59.260 --> 18:00.260
手字母

18:00.260 --> 18:01.260
那么它又是构造函数了

18:01.260 --> 18:03.260
那只是命名上的规范而已

18:03.260 --> 18:04.260
但是呢

18:04.260 --> 18:05.260
现在不行了

18:05.260 --> 18:06.260
现在如果你这样子写的话

18:06.260 --> 18:07.260
你看

18:07.260 --> 18:08.260
爆出

18:08.260 --> 18:09.260
它说

18:09.260 --> 18:10.260
adprint is not constructor

18:10.260 --> 18:11.260
它说你这个玩意

18:11.260 --> 18:12.260
它不是一个构造函数

18:12.260 --> 18:13.260
你不能这样调用

18:13.260 --> 18:14.260
以前是可以的

18:14.260 --> 18:16.260
以前任何方法都可以

18:16.260 --> 18:17.260
当然这

18:17.260 --> 18:18.260
这种调用方法

18:18.260 --> 18:20.260
是不是一定是有问题的

18:20.260 --> 18:21.260
谁会这样

18:21.260 --> 18:22.260
谁会疯了吧

18:22.260 --> 18:23.260
你把一个构造函数

18:23.260 --> 18:25.260
放到一个对象的

18:25.260 --> 18:27.260
原型上面去

18:27.260 --> 18:28.260
不是疯了吗

18:28.260 --> 18:29.260
谁会这样去做呢

18:29.260 --> 18:30.260
所以说

18:30.260 --> 18:31.260
它不会让你去

18:31.260 --> 18:32.260
有这样的

18:32.260 --> 18:34.260
错误的操作

18:34.260 --> 18:35.260
最后一条

18:35.260 --> 18:36.260
构造函数必须使用

18:36.260 --> 18:37.260
6来调用

18:37.260 --> 18:38.260
就是我们刚才说的

18:38.260 --> 18:39.260
你这里一定是要使用

18:39.260 --> 18:40.260
6来调用的构造函数

18:40.260 --> 18:41.260
因为它是一个内

18:41.260 --> 18:42.260
它只能通过6

18:42.260 --> 18:44.260
来创建一个对象

18:44.260 --> 18:46.260
那么最终达到的效果

18:46.260 --> 18:47.260
其实你会发现

18:47.260 --> 18:49.260
跟这边的效果

18:49.260 --> 18:50.260
追踪了对象的效果

18:50.260 --> 18:52.260
结构了原型链

18:52.260 --> 18:54.260
实际上是一样的

18:54.260 --> 18:57.260
所以说它是一个愚法堂

18:57.260 --> 18:58.260
因此我们有了

18:58.260 --> 18:59.260
也是6里边

18:59.260 --> 19:01.260
这种内的愚法之后

19:01.260 --> 19:03.260
我们之后就应该

19:03.260 --> 19:04.260
特别是在

19:04.260 --> 19:06.260
编写构造函数的时候

19:06.260 --> 19:07.260
就应该尽量的

19:07.260 --> 19:08.260
使用class来做海法

19:08.260 --> 19:10.260
而不应该再去使用

19:10.260 --> 19:13.260
以前那种老的方式来做海法了

19:13.260 --> 19:15.260
这种方式的各个层面

19:15.260 --> 19:17.260
都碾压以前的老的

19:17.260 --> 19:18.260
旧的这种方式

19:18.260 --> 19:19.260
那也就是说兼容性问题

19:19.260 --> 19:20.260
兼容性问题的话

19:20.260 --> 19:21.260
以后我们学了一些东西

19:21.260 --> 19:22.260
会解决

19:22.260 --> 19:23.260
放心

19:23.260 --> 19:24.260
所以那件大胆的使用

19:24.260 --> 19:25.260
力来做海法

19:25.260 --> 19:26.260
好了

19:26.260 --> 19:27.260
下来大家去练习一下

19:27.260 --> 19:29.260
就写这么一个animate

19:29.260 --> 19:31.260
然后写上这么一些层面

19:31.260 --> 19:32.260
随便写一些

19:32.260 --> 19:33.260
练习它的愚法就行了

19:33.260 --> 19:34.260
好了

19:34.260 --> 19:35.260
这是这几课

19:35.260 --> 19:36.260
给大家先开个头

