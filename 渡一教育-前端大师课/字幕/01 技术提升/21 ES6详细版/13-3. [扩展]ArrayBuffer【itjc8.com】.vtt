WEBVTT

00:00.820 --> 00:05.820
这两天有点感冒啊 所以说 大家听我的声音是不是更加有词性了一点点

00:07.820 --> 00:16.820
咳嗽 流鼻涕 我坚持一下啊 大家也理解一下啊 可能声音呢 没有那么的就是有惊奇声

00:18.520 --> 00:25.620
这一刻呢 咱们来学习Array Buffer 这个Array Buffer呢 跟我们上一课学习的类型化数主有什么关联的

00:26.320 --> 00:30.420
本身呢 Array Buffer呢 跟那个类型化数主是没有多少关联的

00:30.720 --> 00:37.620
不过呢 我们认识它之后呢 我们可以利用类型化数主对它进行一些操作 Array Buffer 是什么东西呢

00:39.720 --> 00:44.920
Buffer呢 它叫做一个缓冲区啊 一个缓冲区 其实你不用去理解什么缓冲区什么意思

00:45.220 --> 00:49.320
这个东西其实很简单 它做什么用的呢 它就是一个对象

00:50.420 --> 00:54.620
用于存储一块固定

00:55.620 --> 00:58.120
类存大小的数据

00:59.420 --> 01:00.820
它就是来存出一些数据的

01:01.820 --> 01:04.620
像我们之前说什么编量啊 这些东西都是来存出数据的 对吧

01:05.120 --> 01:09.420
那么Array Buffer 给我们编量那种方式来存出数据 有什么样的区别呢

01:10.220 --> 01:15.620
Array Buffer呢 它对存出的数据呢 它可以进行更加精确的控制

01:16.220 --> 01:21.420
而且呢 Array Buffer呢 它主要的最大的区别是一块固定类存大小的数据

01:22.020 --> 01:26.820
也就是说我们在创建一个Array Buffer的时候呢 可以给它指定类存的大小

01:27.920 --> 01:30.820
它怎么来创建一个Array Buffer呢 我们来看一下啊

01:32.120 --> 01:37.220
创建一个Array Buffer使用这种方式 六一个 因为它是个构造函数啊 Array Buffer

01:37.920 --> 01:41.920
参数只有一个 参数是什么呢 参数就是字结束

01:42.720 --> 01:49.120
就没了 就是说我这个类存空间里边有多少个字结束 你给我传进来 比方说啊 举个例子

01:50.120 --> 01:54.120
太捨一 咱们呢 这里写这么一个代码

01:56.120 --> 02:00.520
这里呢 我们写一个BF Buffer 六一个Array Buffer

02:02.120 --> 02:07.920
这里边填啥呢 就填字结束 比方说10个字结就没了 这就是个Array Buffer

02:08.320 --> 02:13.320
就表示了一个什么呢 就表示创建了一个 创建了一个

02:13.920 --> 02:20.920
拥于存储10个字结 一共多少位啊 问一下一共多少位 一个字结8位

02:21.520 --> 02:26.320
10个字结了就80位 对吧 拥于存储10个字结的类存空间

02:27.320 --> 02:31.320
创建了一个拥于存储10个字结的类存空间 咱们来看一下 它打印出来是什么东西

02:33.120 --> 02:39.120
它打印出来呢 其实就是一个Array Buffer的对象啊 这个对象用来干嘛的 这个对象用来存储10个字结的空间

02:39.520 --> 02:46.520
展开之后呢 你会发现它里面有一些内置属性 是不是有点熟悉 印则8 Array 印则16 Array 这些东西呢 无所谓

02:46.920 --> 02:52.720
它就是给你展现几种形式啊 为了让你更加方便的看到 在调试的时候呢 能够看到

02:53.320 --> 02:58.520
这里边到底存了什么 怎么样的数据 你看 是不是全部初识化为0 对不对 内存空间里边

02:58.920 --> 03:04.720
10个字结嘛 是不是印则8 Array 长度为10 对吧 一共有10个 把它换成印则16了

03:05.120 --> 03:11.520
也是长度为5 减半嘛 对不对 这些端都不用去看 它里边呢 有一个属性 大家注意一下 就是属性

03:13.120 --> 03:23.720
sorry 属性就是Batnance 就是字结的数量 它没有Nence属性 它是Batnance 因为它只管字结 不管你每个字结是什么意识 它不管

03:23.920 --> 03:32.120
它就是来存出各种数据的 这东西有什么用呢 我们后边的课程会说有什么用啊 这些课我们只学习它的一些相关的操作

03:33.120 --> 03:34.120
里边的一个属性

03:36.920 --> 03:50.520
可以通过属性 什么属性 Batnance得到字结数 这个字结数是固定的 你不可能增加 也不可能减少 你在创建的时候就已经把字结数固定死了

03:51.120 --> 03:52.920
就这么个意思 就是Array Buffer

03:54.920 --> 03:59.320
它里边还提供了一个方法 这个方法在圆形上面 叫什么方法 叫snice

03:59.920 --> 04:05.320
snice跟数组里边的方法差不多 都表示的是分割出一个新的数组出来

04:05.720 --> 04:13.320
那么这个地方表示分割出一个新的Array Buffer出来 那么这个地方我们来写一个比方Bf2 Bf Snice

04:15.020 --> 04:20.520
这里边传两个参数 第一个参数是B传的 第一个参数也可以不传 不传的话 那么

04:21.320 --> 04:26.320
两个Array Buffer 它的长度 长度就是一样的 你看没有 都是长度为10

04:27.320 --> 04:32.320
长度为10 都是一样的 它相当于是什么呢 相当于是把第一个Array Buffer里边内存的数据

04:32.720 --> 04:38.920
复制到第二个就是复制 产生一个新的Array Buffer 每一个Array Buffer 脑袋里面就想

04:39.320 --> 04:45.120
每一个Buffer 就是一块内存空间 这个内存空间里面存了一些数据 它的长度是固定的

04:45.520 --> 04:46.320
就这么个意思

04:47.120 --> 04:53.720
好 那么这里边可以传参数 一个是起始的字结数和只结束的字结位置

04:54.120 --> 05:00.520
比方说我这里传一个三 结束的呢 为五 那么这样子什么意思呢 这样子表示的是

05:01.020 --> 05:08.820
把第一个Array Buffer里边的字结从第四个字结开始 因为是下标位从零开始 从第四个字结开始

05:09.620 --> 05:17.620
取到多少个字结呢 取到第五个字结 而第六个字结 取到第六个字结 但是呢 最后一个取不到 也就是第六个字结是取不到的 那么就是去

05:17.720 --> 05:25.520
四和五 那么把第四个字结和第五个字结的东西取出来 形成一个新的Array Buffer 返回

05:26.720 --> 05:32.220
那么得到结构是什么呢 得到结构就是长度为二的Array Buffer 保存看一下

05:33.320 --> 05:38.320
什么长度为二的Array Buffer 对吧 就没了 Array Buffer里边的API就这么两个

05:38.620 --> 05:51.620
一个是长度 一个是snice方法 这里再记一笔吧 可以通过方法snice得到新的Array Buffer

05:53.620 --> 06:00.620
Array Buffer本身的API就完了 那么这里边的数据我们该怎么来操作它呢 就是我们怎么来去改这里边的数据

06:01.520 --> 06:09.520
以及怎么来去读这里边的数据呢 我们要读和改这里边的数据呢 他不能使用Array Buffer本身要用别的方式

06:09.520 --> 06:21.520
好 接下来看一下啊 读写Array Buffer Array Buffer 他用两种方式可以读写Array Buffer 第一种方式呢 是使用

06:22.820 --> 06:30.520
使用data view 第二种方式呢 是使用内形化数主 最重要的我们是要学习第二种

06:30.720 --> 06:37.920
第一种呢 我们作为了解就行了 因为data view呢 用这种方式读写Array Buffer 可不可以读 可以读 可不可以写 可以写 但是呢

06:38.520 --> 06:47.720
有不少的缺陷 容易产生错误 好 比方说 我们用第一种方式使用data view来读写Array Buffer 好 咱们来看一下啊

06:49.220 --> 06:54.820
我们这里就不记笔记了啊 因为这里比较是一道比较多的API 我们就在这里直接用API了

06:55.220 --> 07:02.620
比方说我们这里创建了一个Array Buffer 好 我们要对这个Array Buffer进行读写 那怎么办呢 OK 我们来创建一个data view

07:03.220 --> 07:10.420
我们用dv 或者就写个view data view叫做数据试图 就是通过一个窗口 当然不是个一个可实化的窗口啊

07:10.920 --> 07:15.220
就是一种概念上的窗口 我们通过这个窗口来去操作这个Array Buffer

07:15.820 --> 07:23.020
好 那么这里创建一个data view data view里边要传这么几个参数 第一个参数是必须要传的 就是要传一个Array Buffer

07:24.020 --> 07:30.220
那么什么意思呢 就是我去通过它来去操作这个Array Buffer啊 就这么个意思

07:31.020 --> 07:40.620
好 那么这个怎么来操作呢 很简单 view里边它又提供了一些方法啊 一些属性 我先把view打印出来看一下啊 这个view打印出来看一下

07:42.420 --> 07:45.420
test2 它里边提供了一些属性

07:46.420 --> 07:57.820
相信啊 首先是个backnance backnance是什么意思呢 就表示我操作了这个 就是我操作了这Array Buffer里边的数据就是字节长度

07:58.220 --> 08:05.620
长度为10 因为Array Buffer的长度为10 对吧 还有个buffer属上就指的是Array Buffer本身 就是你操作的是哪一个Array Buffer

08:06.620 --> 08:11.020
操作了这个内存本身 那么这一块呢表示的是data view里边的长度为10

08:11.420 --> 08:18.620
这一块就很奇怪 你里边不是有这个buffer对象吗 你这个buffer对象里边的不是有一个backnance吗

08:19.220 --> 08:28.220
那跟我的backnance不一样的吗 对吧 有什么区别呢 目前呢是没有什么区别 但是呢他们的含义确实是有区别的

08:28.620 --> 08:34.220
为什么有区别呢 因为我们在创建data view的时候呢 还可以传更多的参数

08:35.020 --> 08:37.420
后边还可以传啥呢 后边还可以传这么一个

08:39.620 --> 08:48.020
第一个参数的后边的第一个参数是传的是偏一辆 什么意思呢 就是有的时候呢 我们可能会操作这个Array Buffer

08:48.420 --> 08:55.420
我不是对它完整的操作 不是对整个Array Buffer操作 我们可能是只是对这块内存区的某一个部分进行操作

08:56.140 --> 09:02.260
那么这样子的话 你可以传后边的参数 后边的参数呢 我们第一个就是偏一辆 什么意思呢

09:02.460 --> 09:11.260
就是说比方说你传一个零 就指的是我要操作这个Array Buffer 我要从它的零个字节开始来操作 是这么个意思

09:11.860 --> 09:18.260
你传一个一 那么就是从它下标为一的那个字节 就是从第二个字节开始操作

09:18.820 --> 09:21.940
刚才是第一个 现在是第二个字节开始操作 是这么个意思

09:22.460 --> 09:30.060
那么这样子一来的话 这两个东西就不一样了 你看一下 好 保存啊 你看 那么这个data view你看 它的nance是不是9

09:30.540 --> 09:38.780
为什么呢 因为我们的Array Buffer它有10个字节 但是我们是从它第二个字节开始在操作 也说只操作这一部分

09:39.580 --> 09:42.220
明白这个意思吗 这个data view它只操作这一部分

09:42.780 --> 09:47.180
所以说data view的本身的字节能够操作的字节长度是9

09:48.060 --> 09:52.300
后边还有一个属性叫bate offset offset就比较偏一辆 偏一辆是什么一

09:53.020 --> 09:59.380
偏一辆是什么一 就是往前偏一了多少 偏一了一个 对吧 偏一了一个操作后边了 是这么个意思啊

10:00.540 --> 10:08.620
那么这里如果我写个3了 写个3呢 你看一下 它是长度为7 对吧 它的字能够操作的字结束为7 偏一辆为3

10:09.180 --> 10:14.220
好 那么这里呢 就是从这里 前面三个略掉 是操作后边了 是这么个意思

10:16.140 --> 10:22.340
好 那么这是第二个参数 还有第三个参数 第三个参数是什么意思呢 第三个参数呢 你想个道理

10:22.700 --> 10:28.780
前面的第一个是Array Buffer 第二个是offset 第三个呢 就是你要操作的数量 比方我们这里写个4

10:29.580 --> 10:33.940
什么意思呢 我偏一辆为3 长度为4 就这么个意思

10:34.620 --> 10:38.780
你看一下 那么data为6 它能操作的字结束就是4 偏一辆为3

10:39.900 --> 10:49.580
你看一下这边 那么你说前面呢 我们偏一三个 操作后边 后边的操作几个呢 只操作这一部分 其他的不管 只操作这一部分 长度为4

10:50.860 --> 10:57.980
大家用这一个啊 构造函数的时候呢 千万注意的就是 什么呢 这个偏 这后边的就是偏一辆啊 长度啊

10:58.100 --> 11:05.300
你不要超过它的范围 比方说你早点偏一辆为1000 长度为1000 你看一下 是不是 它就爆错了invalid

11:06.060 --> 11:12.020
无效的data view lens 它说你这个是无效的长度 你大家注意一下啊

11:12.940 --> 11:13.940
好 这是关于这一块

11:15.380 --> 11:18.740
好 那么data view创建好了之后呢 接下来我们来怎么来操作

11:19.380 --> 11:22.180
不是为了操作Array Buffer里边的数据吗 是吧 我们怎么来

11:22.980 --> 11:29.140
写数据 怎么来读数据呢 主要就是写和读 那么怎么来写和读呢 就是非常简单

11:29.900 --> 11:35.060
它里边提供了一些方法 写数据的话 全是以set开头

11:36.140 --> 11:40.180
读数据的话 全是以get开头 好 比方说我们写数据啊

11:41.340 --> 11:42.980
写数据的话 我们用set

11:43.900 --> 11:45.500
set的话 我们这里看一下 你看一下

11:46.260 --> 11:52.140
明白这个意思吗 是不是有这么一些 对吧 有这么一些的方式呢 可以写写数据

11:52.500 --> 12:00.700
没有问题吧 所以有这么一些方式可以写数据 哦 上一级课的内形化数据还少了两个东西啊 一个是float32 一个是float64

12:01.580 --> 12:07.820
啊 上一级课的内形化数据还少了 还少了两个啊 Float32而类

12:09.340 --> 12:15.900
还有就是float64而类 还少了两个啊 这两个其实用法都是一样的啊 补充进去就行了

12:16.620 --> 12:20.380
就是关于32位的浮电数和64位的浮电数啊

12:20.940 --> 12:26.540
那么这个data5u来设置数据的时候呢 它也有相应的方式来设置 比方说我们设置一个硬扯8

12:28.380 --> 12:33.220
好 那么设置的方设置里边呢 它要传这么两个参数 一个是偏营量 一个是

12:34.140 --> 12:39.980
它的值 偏营量是什么呢 值得是针对5u 就是data5u 就是这个数据仕图

12:40.580 --> 12:45.220
针对它的偏营量 比方说我们这里写个1 然后呢 数字呢写个3

12:45.820 --> 12:49.460
好 这是什么意思啊 我们把打印出来 5u 这是什么意思

12:50.620 --> 12:58.100
看着啊 它的意思呢指的是这个 因为这个首先你要搞清楚这个data 5u 操作的是哪一段数据 操作是哪一段呢

12:58.900 --> 12:59.900
偏营量为3

13:00.780 --> 13:02.380
长度为4 是不是 操作了这一段

13:02.980 --> 13:09.500
好 那么data5u它只关心这一段 那么现在我们设置数据的时候 偏营量为1 这里又是个偏营量

13:09.780 --> 13:13.140
这个偏营量呢指的是针对这个data5u的偏营量

13:13.540 --> 13:17.140
也就是说 在这个基础上的偏营量为1 那么从第二个开始设置

13:17.500 --> 13:23.140
就从这里设置 设置多少 设置为3 知道这么个意思啊 把这个位置设置为3

13:24.540 --> 13:30.340
那么读数据呢也是一样的 读数据 will get int8

13:31.220 --> 13:35.620
get int8 那么这里只需要传一个偏营量就行了 偏营量比方说也传一个1

13:36.260 --> 13:40.620
那么什么意思呢 就读到偏营量为1的那个位置的数据3 明白的意思吗

13:41.780 --> 13:43.860
这是偏营量 这是具体的数字

13:45.700 --> 13:54.020
好 没问题吧 好 那么有些东西就觉得很好奇了啊 我这里的设置的是 如果说这里设置的是 int8 那我设置的是 int16呢

13:55.020 --> 13:57.180
我设置的是 int16呢 保存看一下吧

13:58.180 --> 14:06.460
啊 你看一下 我看一下buffer啊 设置了 int16啊 你看一下 int16 是不是前面全部是补零 对吧 要占16位 对不对

14:06.860 --> 14:16.540
那么在这个 int8 二位 就是buffer里面 int8 二位里面 每一个字节你看啊 前面 我们是设置的这一部分 对吧 本来我们偏营量写的是1 应该是设置的

14:17.740 --> 14:23.420
应该是设 我们设置的这一部分 本来呢 应该设置的是这个位置 偏营量为1吗

14:23.980 --> 14:30.020
但是由于我们是使用的是 int16 那么是不是它一设置 它会导致这两个位置都发生变化

14:30.780 --> 14:38.220
对吧 因为它占16位嘛 对不对 它是不是导致这两个位置都发生变化 那么第1个位置全部是零 第2个位置呢 全部就是3

14:38.940 --> 14:47.540
16位嘛 就前面8个零 然后后面再7个零 然后1个3 对吧 前面8个零 是不是这个表示零了 后面7个零一个3 是不是这个位置表示3了

14:48.180 --> 14:54.940
对不对 所以当我们使用偏营量为1来取的话 这个地方取出来是0 因为我们取的时候是用印尺8的方式来取的

14:55.140 --> 14:58.860
它只取8位 那么偏营量为1 那么这个位置不是取出来是0

14:59.380 --> 15:05.340
那如果说这里呢 用偏营量就取16的话 那么取出来的正确了 就是这个地方大家注意一下

15:05.780 --> 15:11.100
这也是为什么data5又用的比较少的原因 因为data5又它用意混着用

15:11.700 --> 15:15.060
就是我们用8位的来设置数据 结果呢 我们用16位来取

15:15.460 --> 15:20.340
或者说我们用16位来设置数据 我们用8位来取 那么可能会造成了一些混乱

15:20.860 --> 15:29.420
所以这就是为什么用data5又用的少一点 但是data5又呢 它能耐久用 它专门用于什么呢 通常使用data5又

15:30.700 --> 15:35.700
通常是这样子 会在需要混用

15:36.980 --> 15:42.820
多种存储格式使使用data5又

15:43.780 --> 15:49.780
就是我们使用data5又还是有原因的 就是我们有的时候就是要这样子 就是有这样的需求 ok 那我们就可以使用data5

15:50.580 --> 15:57.660
但更多的时候呢 我们希望的是我存的是什么多少位 我取的时候就用多少位来取啊 这样子比较符合逻辑

15:58.060 --> 16:03.860
所以说呢 我们更更多的时候呢 如果说要操作array buffer了 是使用的是内形化数组

16:04.740 --> 16:08.340
好 我们看一下第二种方式啊 用内形化数组来操作array buffer

16:10.750 --> 16:11.550
好 看一下

16:12.750 --> 16:18.910
这里呢 我们用上级课的指使呢 来创建这么一个内形数组 ar 6 一个 比方说啊 int

16:20.190 --> 16:26.350
8 array 创建一个长度为十的int array 我们输出一下这个int这个内形化数组

16:27.190 --> 16:30.230
其实在我们创建了每一个内形化数组之后呢

16:30.910 --> 16:34.630
你会发现这个内形化数组里边有一个属性 叫做buffer

16:36.310 --> 16:39.270
看到没 对吧 好 我给他记一笔

16:40.670 --> 16:45.630
实际上 每一个内形化数组 内形化数组

16:46.790 --> 16:50.150
都对应一个array buffer

16:51.670 --> 16:56.230
因为内形化数组用来干嘛的 就是来用精细的操作内存数据的

16:56.230 --> 16:58.870
而array buffer就是专门来保存内存数据的

16:59.190 --> 17:04.710
所以说呢 每一个内形化数组呢 他会对应一个array buffer来保存他里面的数据 他会对应一个array buffer

17:05.630 --> 17:09.110
如果没有手动指定

17:09.790 --> 17:11.670
手动指定array buffer

17:13.310 --> 17:14.390
内形化数组

17:15.310 --> 17:22.030
创建时 会新建一个array buffer 这就是为什么我们刚才那个代码

17:22.510 --> 17:26.350
虽然说我们 我没有手动创建array buffer 对吧 你没有要指定

17:26.710 --> 17:32.470
那么这个内形化数组里边呢 他会包含一个array buffer 你看是包含那个array buffer 它自己里创建一个新的

17:33.470 --> 17:40.070
那么这样子一来呢 就会导致你每一个内形化数组是不是都会创建一个新的array buffer 都会有一个新的内存空间 对吧

17:41.310 --> 17:48.710
也同时说明了什么呢 我们创建内形化数组的时候 是可以传递array buffer的

17:49.430 --> 17:56.790
因此内形化数组的创建了我们多了一种方式 就是说 我们这里呢 可以给他指定同一个array buffer

17:57.510 --> 17:58.710
给他指定一个array buffer

17:59.550 --> 18:03.790
比方说 我们这里有10个字节的array buffer 10个字节

18:04.830 --> 18:11.910
的内存 好 那么我们把这个array buffer直接传进来 这样做是可以的 那么这样子呢 一来呢 我们再输出一下

18:12.390 --> 18:20.550
array 这个内形化数组里边一个buffer 主象是不是等于我们的就是array buffer 输出一下啊 因为发现两个是q

18:21.430 --> 18:26.830
说明上了 说明这一个内形化数组操作的内存是哪个内存 是这个array buffer的内存

18:27.670 --> 18:31.790
那么这样子一来的话 我们有的时候呢 就可以利用多个内形化数组

18:33.930 --> 18:37.530
多个内形化数组来操作同一块内存 这样做是可以的

18:38.330 --> 18:43.050
咱们来看一下啊 而两个内形化数组虽然不一样

18:43.970 --> 18:49.690
这两个内形化数组肯定不一样 都是两个不同的对象嘛 对吧 但是两个内形化数组操作的内存空间是一样的

18:51.410 --> 18:53.890
好 你看一下 第一个为force 第二个为true

18:54.890 --> 18:57.730
两个内形化数组本身不一样 它操作的内存空间是一样的

18:58.770 --> 19:02.050
不要那意思吗 好 那具体怎么操作呢

19:03.130 --> 19:06.250
其实操作的办法特别特别简单 我们来看一下吧

19:07.730 --> 19:12.810
我就这样子负质就完成了 这里负质为10 你看一下

19:13.770 --> 19:15.490
我们再然后再输出啊 输出

19:16.450 --> 19:18.570
二位一啊 输出

19:21.690 --> 19:24.850
二位二 好 保存 咱们来看一下啊

19:25.690 --> 19:28.690
你会发现 我改的是第一个数组的

19:29.210 --> 19:33.210
把它改成10 但是由于这两个数组操作的是同一块内存空间

19:33.610 --> 19:39.970
所以说当第一个数组里面把感成10了 过后呢 它buffer也跟着变了 它操作的buffer是不是第一个位置变成10了

19:40.410 --> 19:43.650
对吧 变成10了 好因此16这边呢 也是一样

19:44.530 --> 19:49.610
它操作的也是同一块内存空间 那么这一块内存空间变成10了 它的内存空间也自然而然变成10了

19:50.290 --> 19:55.090
明白这意思吗 这就是说它们两个数组操作了而为buffer是同一个

19:55.450 --> 20:01.370
只不过大部分时候呢 我们一般就用一个数字去操作它就行了 不太会用两个数字来操作它 不然的话

20:02.250 --> 20:07.730
就容易导致跟那个那个跟那个delta 5又一样的 容易产生混乱了 对吧 我们通常用一个数字去操作它

20:08.050 --> 20:11.850
要么用硬尺16 要么用硬尺8 好 比方说我们看一下硬尺16

20:13.850 --> 20:14.770
好 再来看一下啊

20:15.770 --> 20:23.690
我们来看一下硬尺16 我们创建了10个字节的内存 但是呢 我们用操作的数类型化数组呢 是硬尺16的方式来操作的

20:24.050 --> 20:29.010
比方说 我们把它的 呃 第一个位置啊 数组的

20:30.130 --> 20:35.170
第一个位置 设置为一板 好 我们来输出

20:36.530 --> 20:39.910
ar 啊 来看一下啊

20:41.310 --> 20:43.310
检查 控制台 刷新

20:44.310 --> 20:46.110
好 现在我们看到数组很简单的吧

20:46.310 --> 20:50.390
它第一位一板 那么大家想一想 第一位占多少个字节啊

20:51.350 --> 20:57.470
占多少个字节 是不是占两个字节 因为16位嘛 对吧 每一个每一个元素占两个字节

20:57.910 --> 21:07.630
那么arebuff里边呢 arebuff里边 它 你看一下 arebuff里边也说它这里呢 是不是占了两个字节 这两个字节呢来表示一个16位

21:08.030 --> 21:11.910
是这么个意思啊 他是这么个意思 两个字节表示一个16位

21:12.390 --> 21:19.310
啊 好 那如果说我可要传的数字比较大 那他真正的需要多位来保存 比方说啊 我们这里传一个二三四四

21:20.110 --> 21:25.510
来保存啊 那么这里是存在下的 对吧 这里是存在下的 因为它每一个元素呢 有二三四四

21:25.830 --> 21:30.550
但是在buff里边 你看它对应到英词八的格式 每一个只有一个字节的格式 是不是把分隔开了

21:30.910 --> 21:35.950
对吧 把分隔开了四十九变成这个 那么这两个组合起来了 他对应到

21:36.790 --> 21:43.590
16位里边就比较像二三四四 因为这里是一个字节 对吧 两个字节 这里呢 就是直接是两个字节了 能看懂吗

21:44.030 --> 21:51.710
这里是英词八而为 一个元素表示的是一个字节 那么他这里的二三四是这个数字 他需要两个字节来存储

21:51.950 --> 21:58.390
他一个字节存储不下 一个字节最多只能存储到多少 127 对吧 他需要两个字节来存储

21:58.710 --> 22:02.790
那么他就这里就把它分成了两个字节 这两个字节组合起来的数据呢

22:03.430 --> 22:06.990
两个字节表示二三四四 那是这么个意思 也就是说你用

22:07.710 --> 22:16.750
耳瑞也一定要清楚啊 你用英词十六这种内形化数组来操作而为buff的时候呢 你是两个字节两个字节在操作

22:17.270 --> 22:26.030
要那意思吗 同样道理你用英词三二这种方式内形化数组来操作而为buff的时候呢 你是四个字节 四个字节在操作

22:26.550 --> 22:27.550
就主要说明这个

22:27.550 --> 22:33.790
操作的两个字节 是这么个意思

22:34.750 --> 22:41.950
那么剩下的东西都是一样的啊 你要复制 你要取之 你数组还不方便嘛 对不对 他跟内存里本来的东西是完全对应的

22:42.590 --> 22:46.390
这就是如何使用内形化数组来操作而为buff

22:48.430 --> 22:53.110
好 那么至此呢 我们学到现在都不知道他有什么用对吧 这个东西叫什么用呢 这个玩意儿

22:53.110 --> 23:02.070
学这么多操作内存的方式 感觉上很底层很高端的样子具体有什么用呢 咱们下节开始呢来讲一些他的应用 好吧

