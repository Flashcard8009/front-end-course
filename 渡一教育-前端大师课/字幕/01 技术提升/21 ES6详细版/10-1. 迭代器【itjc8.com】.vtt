WEBVTT

00:00.690 --> 00:04.890
好 咱们这一张呢 学习叠带器和生成器

00:04.890 --> 00:06.690
我之前说过

00:06.690 --> 00:11.090
ES6里边有两个比较难度比较高的章节

00:11.090 --> 00:12.690
一个是异部处理

00:12.690 --> 00:14.690
一个是叠带器和生成器

00:14.690 --> 00:17.690
后边还有前边的没有什么难度了

00:17.690 --> 00:25.090
这两个章节呢 我希望大家对有些比较模糊的课呢多看几遍

00:25.090 --> 00:27.890
而且这两个章节呢 还蛮重要的

00:28.090 --> 00:31.690
它会影响到我们后边的一些学习

00:31.690 --> 00:34.690
特别是异部处理的一块 后边到处要用

00:34.690 --> 00:37.890
而叠带器和生成器这一块东西呢

00:37.890 --> 00:40.090
你说它不重要吧

00:40.090 --> 00:44.090
我们后边也不怎么会自己去写这个代码

00:44.090 --> 00:45.490
但是你要说它不重要

00:45.490 --> 00:47.490
很多东西你理解不了

00:47.490 --> 00:49.490
你不学习它 你理解不了

00:49.490 --> 00:51.890
包括你们以后学习React的时候

00:51.890 --> 00:54.090
还会用到生成器这边的知识

00:54.090 --> 00:55.690
而且你要学习生成器的话

00:55.690 --> 00:57.490
你又必须要学习叠带器

00:57.490 --> 01:00.890
就是这些乱七八糟的东西 你得必须要把它学完

01:00.890 --> 01:02.890
说了这么多就这么有意思

01:02.890 --> 01:05.290
尽管它很困难 尽管我们学了之后

01:05.290 --> 01:07.690
好像平时的写代码也不怎么会用到

01:07.690 --> 01:11.690
但是它仍然非常的重要

01:11.690 --> 01:15.290
好 这结构我们来讲这个叠带器

01:15.290 --> 01:16.890
为什么说这个章节难呢

01:16.890 --> 01:19.690
因为它抽象

01:19.690 --> 01:21.490
我们首先讲叠带器的时候

01:21.490 --> 01:26.090
给大家介绍一些关于叠带器的背景知识

01:26.090 --> 01:30.690
这一块知识你能够吸收多少就尽量吸收

01:30.690 --> 01:33.490
我不可能把一些思想性的东西

01:33.490 --> 01:36.290
通过描述就让你彻底的理解

01:36.290 --> 01:38.090
我尽量的给你解释清楚

01:38.090 --> 01:40.290
能吸收多少的就尽量吸收

01:40.290 --> 01:42.490
如果你实在是吸收不了

01:42.490 --> 01:44.890
背景知识你多多少的肯定会吸收一点

01:44.890 --> 01:46.290
如果说你实在吸收不了

01:46.290 --> 01:47.090
OK 没关系

01:47.090 --> 01:48.290
你看后边的代码

01:48.290 --> 01:50.490
我们后边会讲一些代码层面的东西

01:50.490 --> 01:52.090
因为对于初学者而言的话

01:52.090 --> 01:55.190
代码层面的东西反而是比较容易理解的

01:55.190 --> 01:57.590
而反而那种概念

01:57.590 --> 01:59.490
还有什么思想的东西

01:59.490 --> 02:01.190
反而不太容易理解

02:01.190 --> 02:03.790
没关系 需要过程 这是正常的

02:03.790 --> 02:06.090
我给大家介绍一下背景知识

02:06.090 --> 02:09.190
首先有这么一个词叫做叠带

02:09.190 --> 02:10.890
叠带啥意思呢

02:10.890 --> 02:13.890
叠带的意思它就是从一个数据集合中

02:13.890 --> 02:15.290
比方说我们有很多数据

02:15.290 --> 02:16.690
比方说一个数组

02:16.690 --> 02:18.690
我们代码层面来讲就是一个数组

02:18.690 --> 02:20.190
但是我们现在讲的是

02:20.190 --> 02:21.990
就是一个高度抽象的东西

02:21.990 --> 02:23.090
它不一定有数组

02:23.090 --> 02:23.790
不一定是个数组

02:23.790 --> 02:25.190
就是一大堆东西

02:25.190 --> 02:27.190
有一些数据它成一坨了

02:27.190 --> 02:28.790
就是一坨数据中

02:28.790 --> 02:30.090
按照一定的数据

02:30.090 --> 02:32.990
不断的把这个数据一个一个拿出来的过程

02:32.990 --> 02:34.290
就叫做叠带

02:34.290 --> 02:36.290
以后我一说叠带啥意思呢

02:36.290 --> 02:37.890
就是把一堆数据

02:37.890 --> 02:40.290
把它的东西一个个拿出来就叫做叠带

02:40.290 --> 02:41.290
先拿一个

02:41.290 --> 02:42.890
然后再拿一个

02:42.890 --> 02:44.190
你不要去想代

02:44.190 --> 02:45.390
不要去想代

02:45.390 --> 02:48.290
因为这是高度抽象的概念

02:48.290 --> 02:50.190
这是叠带的意思

02:50.190 --> 02:52.490
那我们之前也接触过

02:53.690 --> 02:54.590
在代码层面

02:54.590 --> 02:56.390
我们写过什么循环

02:56.390 --> 02:56.590
对吧

02:56.590 --> 02:57.990
我们当时叫做变利

02:57.990 --> 03:00.090
有的时候我们又把它称为叠带

03:00.090 --> 03:03.090
那叠带这个词和变利这个词

03:03.090 --> 03:05.290
看上去感觉上差不多

03:05.290 --> 03:07.090
它们有什么样的区别呢

03:07.090 --> 03:09.490
它们的区别是非常微妙的

03:09.490 --> 03:11.590
我这一块我今天给大家解释清楚

03:11.590 --> 03:12.890
都是概念层面的东西

03:12.890 --> 03:14.890
不涉及到任何代码

03:14.890 --> 03:17.190
叠带的强调的是

03:17.190 --> 03:19.390
我是在一次取数据

03:19.390 --> 03:20.590
我先做一件事

03:20.590 --> 03:21.590
先取一个

03:21.590 --> 03:23.090
然后再取一个

03:23.090 --> 03:25.790
我不一定知道我要取多少

03:25.790 --> 03:26.990
我到底要取多少数据

03:26.990 --> 03:27.790
我不知道

03:27.790 --> 03:29.890
不一定知道

03:29.890 --> 03:31.390
我也不能保证了

03:31.390 --> 03:34.390
我最终需要把所谓的数据取完

03:34.390 --> 03:36.490
我连数据的镜头在哪都不知道

03:36.490 --> 03:38.090
我连这个容器里面有多少数据

03:38.090 --> 03:39.490
我都不知道

03:39.490 --> 03:41.690
我也不保证把这个数据要全部取完

03:41.690 --> 03:42.490
就是叠带

03:42.490 --> 03:47.890
它强调的是一次取数据这个动作

03:47.890 --> 03:52.490
而变利强调的是要把整个数据全部拿出来

03:52.490 --> 03:54.690
一个一个看完

03:54.690 --> 03:56.790
它强调的是一个完整性

03:56.790 --> 03:59.290
这就是变利和叠带的区别

03:59.290 --> 04:00.990
能体会到吗

04:00.990 --> 04:02.590
变利就是说我有一堆数据

04:02.590 --> 04:04.290
我不管数据多少个

04:04.290 --> 04:05.990
我有一千个有一万个

04:05.990 --> 04:09.090
我得把全部一个一个取出来看完

04:09.090 --> 04:12.390
但是叠带它不一定保证把它看完

04:12.390 --> 04:13.990
我也不能保证取多少

04:13.990 --> 04:17.190
我总之看一个刷一个看一个刷一个

04:17.190 --> 04:18.990
其实叠带这个词呢

04:18.990 --> 04:20.390
你要说它特别抽象

04:20.390 --> 04:23.890
把咱们现实生活中的也有例子

04:23.890 --> 04:27.990
其实你们应该听说过这么一个车叫做什么

04:27.990 --> 04:31.390
叫做产品叠带

04:31.390 --> 04:32.990
我们这个公司有个产品

04:32.990 --> 04:36.490
我们通过几代的叠带

04:36.490 --> 04:37.990
把它做成了现任这个样子

04:37.990 --> 04:39.590
产品叠带

04:39.590 --> 04:41.390
产品叠带的啥意思呢

04:41.390 --> 04:42.790
就我们现实生活中

04:42.790 --> 04:45.390
我们比方说我开了一家公司

04:45.490 --> 04:47.290
我要去做一个产品

04:47.290 --> 04:50.190
这个产品因为这个市场是变化的

04:50.190 --> 04:51.890
社会是在变化的

04:51.890 --> 04:54.590
这个产品它要能够满足市场需求

04:54.590 --> 04:56.290
它也得不断变化

04:56.290 --> 04:58.390
这个产品最终成什么样子

04:58.390 --> 05:00.790
谁知道我都不知道

05:00.790 --> 05:02.790
我当老板的产品经济

05:02.790 --> 05:04.190
没有一个人知道这个产品

05:04.190 --> 05:06.790
最终一定是什么样子

05:06.790 --> 05:08.490
但是我不知道最终的样子

05:08.490 --> 05:09.790
我能不能做这个产品呢

05:09.790 --> 05:10.790
我可以做

05:10.790 --> 05:13.390
我先给它做一个出版出来

05:13.390 --> 05:15.190
先做一个第一版出来

05:15.190 --> 05:16.190
第一个版本出来

05:16.190 --> 05:17.790
把这个产品做出来

05:17.790 --> 05:19.490
做出来市场反应不错

05:19.490 --> 05:20.790
但是那又有一些缺陷

05:20.790 --> 05:22.790
OK 我再去做第二个版本

05:22.790 --> 05:23.690
你看这个过程呢

05:23.690 --> 05:25.990
感觉上是不是就是一个叠带的过程

05:25.990 --> 05:28.890
我第一个版本拿出来了过后

05:28.890 --> 05:30.790
接下来我拿下一个版本

05:30.790 --> 05:33.390
就是一个一个做一个一个拿

05:33.390 --> 05:35.090
注意中它有多少个版本出来

05:35.090 --> 05:36.490
我都不知道

05:36.490 --> 05:38.090
这就是一个叠带的过程

05:38.090 --> 05:39.190
能体会这个意思吗

05:39.190 --> 05:40.190
它就不像便利

05:40.190 --> 05:41.290
便利我一定清楚

05:41.290 --> 05:43.590
我最终一定要把它全部拿到

05:43.590 --> 05:45.190
但是那叠带了未来的事情

05:45.190 --> 05:46.390
我不知道

05:46.390 --> 05:48.190
剩下的东西在未来的时间

05:48.190 --> 05:50.390
我不知道是什么东西

05:50.390 --> 05:51.890
就是这个产品

05:51.890 --> 05:52.990
我只能做一个看一个

05:52.990 --> 05:53.790
做一个看一个

05:53.790 --> 05:54.390
做一个看一个

05:54.390 --> 05:55.690
不断的改进

05:55.690 --> 05:57.090
这是叠带

05:57.090 --> 05:58.890
叠带它强调的是

05:58.890 --> 06:00.790
一个一个拿出来看

06:00.790 --> 06:01.790
它不强调

06:01.790 --> 06:02.890
它有多少个数据

06:02.890 --> 06:03.590
也不强调

06:03.590 --> 06:05.390
我最终要不要把它数据取完

06:05.390 --> 06:06.390
总之我拿一个算一个

06:06.390 --> 06:07.690
拿一个算一个

06:07.690 --> 06:08.890
没了意思吗

06:08.890 --> 06:11.190
我尽量用通数的方式给你们讲

06:11.490 --> 06:13.490
这是叠带

06:13.490 --> 06:15.290
你应该有多多少少有这种

06:15.290 --> 06:16.290
有这种感觉了吧

06:16.290 --> 06:16.690
对吧

06:16.690 --> 06:18.090
有这种感觉了

06:18.090 --> 06:19.690
接下来越来越抽象了

06:19.690 --> 06:21.690
叠带器

06:21.690 --> 06:24.090
那就开始涉及到计算机语言层面了

06:24.090 --> 06:27.290
就计算机事件里面的概念了

06:27.290 --> 06:28.790
叠带器是什么呢

06:28.790 --> 06:30.890
既然我们有这么一个叠带的动作

06:30.890 --> 06:32.390
就是把一个东西拿出来

06:32.390 --> 06:33.690
拿一个东西

06:33.690 --> 06:34.590
再拿下一个

06:34.590 --> 06:36.090
再去拿下一个

06:36.090 --> 06:37.890
那么既然有这么一个动作

06:37.890 --> 06:40.090
那么针对各种各样的场景

06:40.090 --> 06:42.990
我们是不是都有可能会对它进行叠带

06:42.990 --> 06:44.690
比方说我们有一个数组

06:44.690 --> 06:46.090
我需要把数组里边一个东西拿

06:46.090 --> 06:47.090
一个一个拿出来看

06:47.090 --> 06:47.590
对吧

06:47.590 --> 06:49.490
或者是我有一个伪数组

06:49.490 --> 06:50.490
它不是一个真正的数组

06:50.490 --> 06:52.790
我也可能会需要把它一个一个拿出来看

06:52.790 --> 06:54.790
当然在计算机的其他语言里边

06:54.790 --> 06:56.590
比方说C语言啊

06:56.590 --> 06:58.090
其他的还有什么练表啊

06:58.090 --> 06:59.790
其他的乱七八糟的数据结构

06:59.790 --> 07:00.190
总之呢

07:00.190 --> 07:01.690
它都表达了一个意思

07:01.690 --> 07:03.390
不同管理是什么玩意

07:03.390 --> 07:04.690
我都表达了一个意思

07:04.690 --> 07:05.490
什么意思呢

07:05.490 --> 07:07.690
就说我有一堆数据

07:07.690 --> 07:09.490
我得一个一个拿出来

07:09.490 --> 07:11.590
那么这个拿的过程呢

07:11.590 --> 07:13.790
我们可能为了避免重复代码

07:13.790 --> 07:16.090
或者是为了减少它的复杂度

07:16.090 --> 07:18.090
我们需要把它拿拿数据的过程

07:18.090 --> 07:19.290
给它抽象一下

07:19.290 --> 07:20.890
给它进行封装一下

07:20.890 --> 07:24.090
那么封装的结果就是叠带期

07:24.090 --> 07:25.490
叠带期解决什么问题呢

07:25.490 --> 07:27.790
叠带期就是我我用一个东西啊

07:27.790 --> 07:29.690
这个东西就帮你一个一个去拿数据

07:29.690 --> 07:30.690
一个一个去拿数据

07:30.690 --> 07:32.790
这就是叠带期啊

07:32.790 --> 07:35.090
你可以认为啊就就是一个人啊

07:35.090 --> 07:36.690
他从仓库里边一个个拿数据

07:36.690 --> 07:39.390
他不管你你只需要跟那个人打交道就行了

07:39.390 --> 07:42.190
你只需要跟这个叠带期打交道就行了

07:42.190 --> 07:45.190
你不用去直接去管仓库里边有什么东西啊

07:45.190 --> 07:46.890
你让他拿下一个他就可以拿下一个

07:46.890 --> 07:48.690
他再拿下一个他就可以再拿下一个

07:48.690 --> 07:49.890
就这么个意思

07:49.890 --> 07:50.890
就叠带期呢

07:50.890 --> 07:53.290
还是对叠带过程的封装

07:53.290 --> 07:55.490
就是对那种一个拿一个拿一个

07:55.490 --> 07:58.690
然后再拿下一个这个动作的进行封装啊

07:58.690 --> 08:00.190
在不同的语言里边呢

08:00.190 --> 08:00.790
叠带期呢

08:00.790 --> 08:02.490
它表现形式不太一样啊

08:02.490 --> 08:03.990
多多少少会有一些差异

08:03.990 --> 08:05.990
但是通常了一个叠带期呢

08:05.990 --> 08:06.690
最终的结果呢

08:06.690 --> 08:09.890
他都是一个对象啊都是一个对象啊

08:09.890 --> 08:10.990
就是叠带期啊

08:10.990 --> 08:14.690
他就是帮你一个一个去拿数据的东西啊

08:14.690 --> 08:16.990
现在不要去想什么循环这些东西啊

08:16.990 --> 08:19.490
现在有的人说那用循环不搞定了吗

08:19.490 --> 08:21.090
你看用循环跟用叠带期

08:21.090 --> 08:24.090
他们两个是有区别的区别在哪呢

08:24.090 --> 08:26.590
用循环你是不是要直接去循环仓库

08:26.590 --> 08:28.890
就是就是一个数据

08:28.890 --> 08:31.090
要去循环这个数据集对吧

08:31.090 --> 08:34.390
说明你呢对这个数据集是已知的

08:34.390 --> 08:35.990
就是你知道这个数据集存在

08:35.990 --> 08:38.090
我要去操作这个数据集

08:38.090 --> 08:40.090
而有了叠带期过后呢

08:40.090 --> 08:43.790
由于拿数据这个动作交给叠带期去完成了

08:43.790 --> 08:45.290
他给你封装了一下

08:45.290 --> 08:47.790
那么你只需要去操作叠带期就行了

08:47.790 --> 08:49.990
我们一会儿写代码就可以看到了啊

08:49.990 --> 08:51.890
所以他们多多少少是有一些差别的啊

08:51.890 --> 08:53.490
如果说你现在觉得很模糊

08:53.490 --> 08:54.790
你们肯定很模糊啊

08:54.790 --> 08:55.490
没关系

08:55.490 --> 08:57.390
一会儿我们写出代码过后再做一下对比

08:58.590 --> 09:00.790
好接下来我们看叠带模式

09:00.790 --> 09:02.590
叠带模式呢是一种设计模式

09:03.990 --> 09:07.190
它是用于统一整个叠带过程啊

09:07.190 --> 09:09.090
实际上它就是在统一叠带期的

09:09.090 --> 09:12.990
它说叠带期呢应该具备一个什么样的接口啊

09:12.990 --> 09:14.290
它规定了叠带期呢

09:14.290 --> 09:16.890
里边应该有什么的有什么样的能力呢

09:16.890 --> 09:18.290
你既然是一个叠带期

09:18.290 --> 09:20.090
你既然要能够取一个有取数据

09:20.090 --> 09:23.590
那么你必须要至少拥有两个能力

09:23.590 --> 09:26.590
第一个我通过叠带期应该知道

09:26.590 --> 09:28.890
应该可以得到下一个数据的能力

09:28.890 --> 09:30.990
叠带期的目的就是一个个拿数据嘛

09:30.990 --> 09:32.190
我拿了一个数据过后呢

09:32.190 --> 09:34.590
我要看一下下一个数据是啥

09:34.590 --> 09:34.790
对吧

09:34.790 --> 09:36.390
它必须要有这么一个能力

09:36.390 --> 09:38.690
拿到下一个数据的能力

09:38.690 --> 09:40.990
第二个呢是它要能够判断

09:40.990 --> 09:43.790
是不是还有下一个数据啊

09:43.790 --> 09:45.790
就是这么个作用

09:45.790 --> 09:48.790
叠带模式它就规定了这么一个东西

09:48.790 --> 09:49.190
ok啊

09:49.190 --> 09:51.190
这是一些背景支持

09:51.190 --> 09:52.190
听完了之后呢

09:52.190 --> 09:54.690
可能有些同学觉得还是很模糊

09:54.690 --> 09:55.790
没关系

09:55.790 --> 09:58.390
咱们终点在后边待马

09:58.390 --> 10:00.690
我们在后边待马的过程中呢

10:00.690 --> 10:03.390
会不断的去回忆这些知识

10:03.390 --> 10:06.890
让大家对这些知识有更加深刻的理解

10:06.890 --> 10:07.090
好

10:07.090 --> 10:07.490
现在呢

10:07.490 --> 10:09.690
我们终于开始进入这个待马层面

10:09.690 --> 10:13.290
就是在JS或者说ES里边

10:13.290 --> 10:16.890
它里边的叠带期是长什么样子

10:16.890 --> 10:18.690
它里边也有以前没有

10:18.690 --> 10:19.990
以前没有这个东西

10:19.990 --> 10:20.990
那么现在呢

10:20.990 --> 10:22.990
以前你能不能自己写呢

10:22.990 --> 10:24.290
可以自己写啊

10:24.290 --> 10:24.990
现在呢

10:24.990 --> 10:26.290
这个ES里边呢

10:26.290 --> 10:28.690
强调了这个叠带期的这么一个概念

10:28.690 --> 10:30.190
实际上叠带期的这一块呢

10:30.190 --> 10:32.290
我们这些可能还是得自己熟写啊

10:32.290 --> 10:34.190
还是得自己熟写

10:34.190 --> 10:35.490
那么JS里边

10:35.490 --> 10:38.590
它规定的是这么一个东西叫做叠带期

10:38.590 --> 10:39.890
JS规定

10:39.890 --> 10:42.690
如果一个对象

10:42.690 --> 10:46.190
具有next方法

10:46.190 --> 10:47.790
它具有这个方法

10:47.790 --> 10:49.690
并且

10:49.690 --> 10:51.090
该方法

10:51.090 --> 10:54.090
返回一个对象

10:54.090 --> 11:00.060
该对象的格式如下

11:00.060 --> 11:03.760
我们先进入过后了

11:03.760 --> 11:06.160
然后再给大家解释

11:06.160 --> 11:07.960
值

11:07.960 --> 11:10.960
档

11:10.960 --> 11:13.760
是否

11:13.760 --> 11:16.060
叠带完成

11:16.060 --> 11:17.360
啥意思呢

11:17.360 --> 11:19.260
就说JS规定啊

11:19.260 --> 11:21.060
如果说一个对象

11:21.060 --> 11:22.660
它具有next方法

11:22.660 --> 11:23.160
啥意思

11:23.160 --> 11:29.880
我们变起来吧变看啊

11:29.880 --> 11:30.680
这一块

11:30.680 --> 11:31.780
咱们比方说

11:31.780 --> 11:32.980
对了

11:32.980 --> 11:34.980
咱们比方说有这么一个对象

11:34.980 --> 11:35.880
对象里边呢

11:35.880 --> 11:38.380
具有一个next的方法

11:38.380 --> 11:39.680
具有next的方法

11:39.680 --> 11:40.680
并且呢

11:40.680 --> 11:41.680
这个方法呢

11:41.680 --> 11:43.580
它返回一个对象

11:43.580 --> 11:44.880
它要返回一个对象

11:44.880 --> 11:45.580
无关的一个方法

11:45.580 --> 11:46.380
里边做了啥

11:46.380 --> 11:47.480
这前面写了啥东西

11:47.480 --> 11:48.080
无所谓

11:48.080 --> 11:49.780
只要调用这个方法之后呢

11:49.780 --> 11:51.480
它会返回这么一个对象

11:51.480 --> 11:52.880
这个对象呢

11:52.880 --> 11:53.980
它有两个属性

11:53.980 --> 11:55.780
一个是value值

11:55.780 --> 11:56.680
啥啥啥

11:56.680 --> 11:58.780
一个是当这个属性啥啥啥

11:58.780 --> 12:00.680
只要你满足这样的格式

12:00.680 --> 12:02.480
只要你这个对象满足这样的格式

12:02.480 --> 12:03.080
ok

12:03.080 --> 12:06.080
你这个对象就是一个迭代器

12:06.080 --> 12:07.080
则

12:07.080 --> 12:08.180
认为

12:08.180 --> 12:11.380
该对象是一个迭代器

12:11.380 --> 12:12.480
是个迭代器

12:12.480 --> 12:13.080
看这

12:13.080 --> 12:13.780
看这

12:13.780 --> 12:14.780
这个对象就是个迭代器

12:14.780 --> 12:15.480
为什么呢

12:15.480 --> 12:17.680
因为这个对象里边有一个next方法

12:17.680 --> 12:18.280
这个方法呢

12:18.280 --> 12:20.580
它返回了这么一种格式的对象

12:20.580 --> 12:20.980
ok

12:20.980 --> 12:21.980
那么这个东西

12:21.980 --> 12:22.880
这个东西啊

12:22.880 --> 12:24.580
就是迭代器

12:24.580 --> 12:26.080
没啥意思吗

12:26.080 --> 12:27.080
啊

12:28.980 --> 12:31.580
这个next方法是什么含义呢

12:31.580 --> 12:32.680
这个含义是什么呢

12:32.680 --> 12:35.880
一般你光是了解它的格式有什么意义呢

12:35.880 --> 12:37.380
我们要把它用起来对吧

12:37.380 --> 12:39.580
所以你要了解这些方法的含义

12:39.580 --> 12:40.580
那个是什么

12:40.580 --> 12:41.880
下一个

12:41.880 --> 12:42.180
啊

12:42.180 --> 12:44.080
我们来了解这个

12:44.080 --> 12:46.790
含义啊

12:46.790 --> 12:48.790
next方法

12:48.790 --> 12:51.090
next方法

12:51.090 --> 12:51.790
啊

12:51.790 --> 12:55.590
是用于得到下一个数据

12:55.590 --> 12:58.490
用于得到下一个数据

12:58.490 --> 12:58.790
好

12:58.790 --> 13:00.490
那么这是这个方法的含义

13:00.490 --> 13:01.890
因为我们知道它是个迭代器

13:01.890 --> 13:02.990
迭代器的作用是什么

13:02.990 --> 13:04.690
是不是一个数据一个数据拿出来看

13:04.690 --> 13:05.290
对吧

13:05.290 --> 13:06.190
调用那个方法

13:06.190 --> 13:07.990
它就会得到下一个数据

13:07.990 --> 13:09.990
也就是说我们返回了这个东西

13:09.990 --> 13:11.390
是不是就是下一个数据

13:11.390 --> 13:11.990
对吧

13:11.990 --> 13:12.890
下一个数据

13:12.890 --> 13:12.990
好

13:12.990 --> 13:15.190
那么返回了这个对象里边是什么呢

13:15.190 --> 13:15.790
啊

13:15.790 --> 13:18.190
返回的对象

13:18.190 --> 13:19.590
它是不是不是有两个数据吗

13:19.590 --> 13:20.890
一个是value数据

13:20.890 --> 13:22.390
value数据表示什么意思呢

13:22.390 --> 13:27.090
表示下一个数据的值啊

13:27.090 --> 13:29.390
表示的是下一个数据的值

13:29.390 --> 13:30.990
比方说下一个数据是一个对象

13:30.990 --> 13:32.790
可以把对象就放进来

13:32.790 --> 13:33.890
下个数据是一个数字

13:33.890 --> 13:37.190
可以把数字放到这个value数据里边来

13:37.190 --> 13:37.390
好

13:37.390 --> 13:39.690
那么下面还有一个数据要当

13:39.690 --> 13:39.790
啊

13:39.790 --> 13:40.990
当

13:40.990 --> 13:41.990
当是什么意思呢

13:41.990 --> 13:43.590
它是个布尔类型啊

13:43.590 --> 13:44.790
布尔类型啊

13:44.790 --> 13:46.590
不理啊

13:46.590 --> 13:48.790
它是表示的是

13:48.790 --> 13:50.690
是否

13:50.690 --> 13:52.890
迭代完成

13:52.890 --> 13:53.190
啊

13:53.190 --> 13:55.490
是否迭代完成

13:55.490 --> 13:56.690
就当这个数据

13:56.690 --> 13:58.390
比方说后边已经没数据了啊

13:58.390 --> 13:59.790
我这次取了数据之后

13:59.790 --> 14:01.190
后边已经没有数据了

14:01.190 --> 14:03.790
那么就表示已经取完了啊

14:03.790 --> 14:05.490
数据已经取完了

14:05.490 --> 14:05.990
ok

14:05.990 --> 14:08.190
那么这就是当的作用啊

14:09.390 --> 14:09.790
好

14:09.790 --> 14:11.490
那么我这里呢

14:11.490 --> 14:13.390
看是不是解释清楚了

14:13.390 --> 14:14.290
这个玩意是啥

14:14.290 --> 14:15.590
就是个迭代器

14:15.590 --> 14:16.390
为什么是迭代器

14:16.390 --> 14:17.790
因为它里边有个那个方法

14:17.790 --> 14:18.890
这个方法什么意思

14:18.890 --> 14:21.490
调用它能得到下一个数据

14:21.490 --> 14:22.790
因为迭代器的目的

14:22.790 --> 14:23.990
就是得到下一个数据

14:23.990 --> 14:24.590
对吧

14:24.590 --> 14:25.990
就得到下一个数据

14:25.990 --> 14:27.890
好那么这个下一个数据的格式是什么呢

14:27.890 --> 14:28.790
它是一个对象

14:28.790 --> 14:30.290
对象里面一个by6属性

14:30.290 --> 14:31.790
by6属性表示下一个数据

14:31.790 --> 14:33.790
数据的真正的数据

14:33.790 --> 14:35.290
真正的数据放到这

14:35.290 --> 14:36.790
然后当这个属性是一个布尔

14:36.790 --> 14:37.690
要么为q

14:37.690 --> 14:38.890
要么为force

14:38.890 --> 14:40.290
那么表达的是什么意思呢

14:40.290 --> 14:41.590
表达的是

14:41.590 --> 14:43.390
我是否后边还有

14:43.390 --> 14:45.790
就是我是不是已经迭代完成

14:45.790 --> 14:46.390
啊

14:46.390 --> 14:48.090
如果是完成了就把设为q

14:48.090 --> 14:49.390
如果是没有迭代完成

14:49.390 --> 14:51.790
就把它设为force

14:51.790 --> 14:52.990
没什么

14:52.990 --> 14:54.690
好这是关于迭代器

14:54.690 --> 14:55.690
在大一码层面

14:55.690 --> 14:56.990
在GS大一码层面

14:56.990 --> 14:58.090
它的规定

14:58.090 --> 14:59.390
你前边的不能理解

14:59.390 --> 14:59.890
ok

14:59.890 --> 15:02.190
但是你这一块你得理解

15:02.190 --> 15:03.490
迭代器干嘛用的

15:03.490 --> 15:04.690
一个个拿数据的

15:04.690 --> 15:05.590
怎么能拿出去

15:05.590 --> 15:08.190
调用那个时候就拿出去

15:08.190 --> 15:08.690
好

15:08.690 --> 15:10.590
这是关于迭代器的它的

15:10.590 --> 15:13.190
就是对象格式

15:13.190 --> 15:13.590
好

15:13.590 --> 15:14.190
接下来呢

15:14.190 --> 15:17.290
我们来写一个有实际意义的例子

15:17.290 --> 15:18.990
因为我们知道迭代的过程

15:18.990 --> 15:21.390
不就是从一堆数据里面一个一个取吗

15:21.390 --> 15:21.990
对吧

15:21.990 --> 15:22.790
好ok

15:22.890 --> 15:25.790
我们就用一个非常简单的一个场景

15:25.790 --> 15:27.290
就是一个数组

15:27.290 --> 15:27.990
一个数组

15:27.990 --> 15:30.890
我们从数组里边不断的去取数据

15:30.890 --> 15:31.790
就是个迭代的过程

15:31.790 --> 15:32.190
对吧

15:32.190 --> 15:33.790
我们来看一下用迭代器

15:33.790 --> 15:34.690
来怎么来操作

15:34.690 --> 15:35.390
用循环

15:35.390 --> 15:37.190
大家都知道该怎么去操作

15:37.190 --> 15:38.190
非常简单

15:38.190 --> 15:39.990
我们来先写个循环吧

15:39.990 --> 15:41.190
一个数据

15:41.190 --> 15:41.590
啊

15:41.590 --> 15:42.990
一

15:42.990 --> 15:43.890
它里边数据啊

15:43.890 --> 15:45.390
一二三四五啊

15:45.390 --> 15:45.990
五个数据

15:47.290 --> 15:48.690
用循环是怎么写的

15:48.690 --> 15:50.290
循环看一下

15:50.290 --> 15:50.990
哎对吧

15:50.990 --> 15:52.990
二是不这样在循环便利

15:52.990 --> 15:53.590
对吧

15:53.590 --> 15:54.490
那么循环呢

15:54.490 --> 15:56.090
也能够一个一个把它取出来

15:56.090 --> 15:58.990
也也能够去完成它的迭代过程

15:58.990 --> 16:00.690
但是呢

16:00.690 --> 16:03.490
循环有一个不太好的地方就是

16:03.490 --> 16:04.690
你在循环里边

16:04.690 --> 16:07.290
是不是一定要去关心这个仓库啊

16:07.290 --> 16:08.790
这个数据数据级

16:08.790 --> 16:09.490
对吧

16:09.490 --> 16:10.490
你看你在循环里边

16:10.490 --> 16:11.890
是不是要用到这个数据

16:11.890 --> 16:12.090
对吧

16:12.090 --> 16:13.990
这个二二是不是要用到他

16:13.990 --> 16:14.190
对吧

16:14.190 --> 16:14.890
循环的过程

16:14.890 --> 16:18.590
整个是直接跟这个数据级打交的打交道

16:18.590 --> 16:19.090
啊

16:20.990 --> 16:21.890
是什么问题

16:21.890 --> 16:23.390
但是一旦说

16:23.390 --> 16:24.790
我们的数据级

16:24.790 --> 16:26.990
它不一定是一个帧数组

16:26.990 --> 16:27.790
那么你这里

16:27.790 --> 16:28.490
是不是有的时候

16:28.490 --> 16:29.790
我们要把它转换的帧数组

16:29.790 --> 16:30.990
要进行判判断一下

16:30.990 --> 16:31.490
对吧

16:31.490 --> 16:32.290
要做一些处理

16:32.290 --> 16:32.990
对不对

16:32.990 --> 16:33.590
因为你不知道

16:33.590 --> 16:35.790
个数据级到底是什么样的类型

16:35.790 --> 16:36.590
但是如果说

16:36.590 --> 16:38.490
你把它换成迭代器的模式

16:38.490 --> 16:39.590
就不存在这个问题

16:39.590 --> 16:40.890
因为有迭代器

16:40.890 --> 16:42.090
就是加入了一个第三方

16:42.090 --> 16:43.690
你想可以是这样的想象啊

16:43.690 --> 16:44.290
这个数据呢

16:44.290 --> 16:45.690
是一个仓库

16:45.690 --> 16:47.690
你用这个循环的模式的话

16:47.690 --> 16:52.590
你是直接亲自跑到仓库里边去取数据啊

16:52.590 --> 16:55.290
如果说你用迭代器的话

16:55.290 --> 16:57.890
那么现在将来又是多加了一个人

16:57.890 --> 16:59.590
他在帮你管理仓库

16:59.590 --> 17:02.390
你不不去跟仓库直接打交道

17:02.390 --> 17:03.690
你是跟那个迭代器

17:03.690 --> 17:04.790
一三个人啊

17:04.790 --> 17:07.290
专门仓库的管理员打交道啊

17:07.290 --> 17:08.290
你让他给拿下一个

17:08.290 --> 17:09.190
他就给拿下一个

17:09.190 --> 17:10.790
你不用去管他是怎么拿的

17:10.790 --> 17:11.890
他从哪里拿的

17:11.890 --> 17:13.490
那个仓库里边是怎么情况

17:13.490 --> 17:14.390
你都不用管

17:14.390 --> 17:17.190
你只管用他一个一个往下面拿数据就行了

17:17.190 --> 17:18.990
就是他们细微的差别

17:18.990 --> 17:20.190
这是循环啊

17:20.190 --> 17:20.690
那么现在呢

17:20.690 --> 17:23.190
我们用迭代器来写一下

17:23.190 --> 17:23.890
迭代器的话

17:23.890 --> 17:25.990
我们写个对象啊

17:25.990 --> 17:27.790
叫做atorator

17:27.790 --> 17:29.990
atorator啊

17:29.990 --> 17:30.590
这个单词呢

17:30.590 --> 17:31.890
就是迭代器的意思

17:31.890 --> 17:32.790
迭代器是什么东西

17:32.790 --> 17:33.990
是不是就是一个对象

17:33.990 --> 17:34.390
对吧

17:34.390 --> 17:36.190
不就是个对象吗

17:36.190 --> 17:37.090
那么这个对象里边

17:37.090 --> 17:38.890
是不是要提供一个那个式的方法

17:38.890 --> 17:39.190
对吧

17:39.190 --> 17:40.090
那个式方法

17:40.090 --> 17:41.690
这个方法要返回什么

17:41.690 --> 17:43.990
返回的是

17:43.990 --> 17:44.590
一个对象

17:44.590 --> 17:45.790
这个对象里边有两个属

17:45.790 --> 17:47.590
一个value

17:47.590 --> 17:48.590
先打个问号吧

17:48.590 --> 17:50.490
一个是当啊

17:50.490 --> 17:52.490
打个问号啊

17:52.490 --> 17:53.790
也就是说我们只要搞定

17:53.790 --> 17:55.290
温耗位置是不是就完了

17:55.290 --> 17:56.890
就这个迭代器有写好了

17:56.890 --> 17:58.690
那么这个温耗位置怎么搞定的

17:58.690 --> 18:01.590
这个迭代器的作用是用来迭代什么呢

18:01.590 --> 18:03.890
该迭代器就是这个仓库管理员

18:03.890 --> 18:05.790
他用来就是迭代啊

18:05.790 --> 18:08.890
用于迭代数组ARR的

18:08.890 --> 18:10.090
他是用来迭代这个东西的

18:10.090 --> 18:11.890
你看迭代器怎么写啊

18:11.890 --> 18:13.890
那么他的value值啊

18:13.890 --> 18:14.890
他的value值是什么呢

18:14.890 --> 18:15.790
你要保证啊

18:15.790 --> 18:17.390
每一次调用next

18:17.390 --> 18:18.590
他要去取下一项

18:18.590 --> 18:19.590
每一次调用next

18:19.590 --> 18:20.690
就去取下一项

18:20.690 --> 18:21.490
对吧

18:21.490 --> 18:22.090
是不是要这样

18:22.090 --> 18:23.290
要保证这一点

18:23.290 --> 18:23.890
因此呢

18:23.890 --> 18:25.590
我们这个迭代器里边呢

18:25.590 --> 18:28.390
我们可以给他加一个属性吧

18:28.390 --> 18:29.790
比方说加一个属性下标

18:29.790 --> 18:30.490
i

18:30.490 --> 18:31.990
i代云零

18:31.990 --> 18:33.590
i代云零

18:33.590 --> 18:34.990
i代云零

18:34.990 --> 18:35.790
就表示我们

18:35.790 --> 18:37.690
当前啊

18:37.690 --> 18:39.690
当前的数组下标

18:39.690 --> 18:42.090
当前的数组下标

18:42.190 --> 18:43.290
有把这些事情

18:43.290 --> 18:45.090
把取仓库里边

18:45.090 --> 18:46.390
从仓库里边怎么去取

18:46.390 --> 18:48.990
把这些事情全部交给迭代器去完成

18:48.990 --> 18:52.590
而不用外边的人关心啊

18:52.590 --> 18:54.890
迭代器里边不是只能有那个方法啊

18:54.890 --> 18:56.590
你可以有其他的别的东西啊

18:56.590 --> 18:58.290
不是我只能有那个方法啊

18:58.290 --> 18:59.290
你可以有别的东西

18:59.290 --> 19:01.790
你可以帮你帮你辅助实现的

19:01.790 --> 19:03.990
好那么这个value值是啥呢

19:03.990 --> 19:05.390
这个value值

19:05.390 --> 19:07.290
value值是不是就是呢

19:07.290 --> 19:08.590
来自于

19:08.590 --> 19:08.990
哎

19:08.990 --> 19:09.990
这个就是

19:09.990 --> 19:10.390
啊

19:10.390 --> 19:12.590
ar

19:12.590 --> 19:13.190
什么

19:13.190 --> 19:14.090
z是点

19:14.090 --> 19:14.890
i

19:14.890 --> 19:15.790
对不对

19:15.790 --> 19:16.690
是不是通过 i

19:16.690 --> 19:19.490
通过这个下标去从数组里边取一项出来

19:19.490 --> 19:19.990
对吧

19:19.990 --> 19:21.190
能看懂吗

19:21.190 --> 19:21.790
啊

19:21.790 --> 19:22.490
这个表示

19:22.490 --> 19:24.290
当前的数组下标一开始是零嘛

19:24.290 --> 19:24.490
对吧

19:24.490 --> 19:25.990
一开始肯定是取第一个

19:25.990 --> 19:26.790
因此呢

19:26.790 --> 19:27.790
把取出来

19:27.790 --> 19:29.790
好取出来之后是不是得加一

19:29.790 --> 19:30.190
对吧

19:30.190 --> 19:31.090
是不是得加一

19:31.090 --> 19:33.690
那么我们可以再加加写后边啊

19:33.690 --> 19:34.290
加一

19:34.290 --> 19:35.090
或者说呢

19:35.090 --> 19:38.290
我们如果说你要看的就是

19:38.290 --> 19:39.990
清楚一点的话我们这样子写吧

19:39.990 --> 19:40.690
啊

19:40.690 --> 19:41.990
先把它放到一个对象里边

19:41.990 --> 19:42.490
然后呢

19:42.490 --> 19:43.090
z是点

19:43.090 --> 19:44.190
i加加啊

19:44.190 --> 19:44.590
然后呢

19:44.590 --> 19:45.690
反回 result

19:45.690 --> 19:45.990
对吧

19:45.990 --> 19:46.690
总之你最终

19:46.690 --> 19:47.990
你只要保证

19:47.990 --> 19:48.190
啊

19:48.190 --> 19:48.890
你只要保证

19:48.890 --> 19:49.490
反回这个

19:49.490 --> 19:51.290
反回这样的一个格式的对象就行了

19:51.290 --> 19:53.790
我们把那个方法再改善一下

19:53.790 --> 19:55.190
你看懂吗

19:55.190 --> 19:55.690
好

19:55.690 --> 19:56.990
当是什么意思呢

19:56.990 --> 19:58.990
当就是是不是已经取完了

19:58.990 --> 19:59.790
是不是已经取完了

19:59.790 --> 20:00.690
已经没数据了

20:00.690 --> 20:02.090
就是当啊

20:02.090 --> 20:03.290
当这个属性就表示

20:03.290 --> 20:05.390
是不是已经没数据了啊

20:05.390 --> 20:06.690
一般那个当的数

20:06.690 --> 20:07.490
当这里呢

20:07.490 --> 20:09.690
一般这个属性什么时候为q呢

20:09.690 --> 20:12.290
就是已经取不到数据了啊

20:12.290 --> 20:13.490
比方在数组这里

20:13.490 --> 20:15.290
数组这里就是下标越界

20:15.290 --> 20:17.190
下标越界他就取不到数据了

20:17.190 --> 20:17.690
对吧

20:17.690 --> 20:18.690
就表示已经取完了

20:18.690 --> 20:20.790
音节再完成了啊

20:20.790 --> 20:20.890
好

20:20.890 --> 20:22.790
那么当什么时候为q呢

20:22.790 --> 20:24.790
就是说这个i啊

20:24.790 --> 20:27.590
他已经大于等于了什么

20:27.590 --> 20:31.990
大于等于了数组的最大下标

20:31.990 --> 20:35.690
ar.nince-1

20:35.690 --> 20:36.290
啊

20:36.290 --> 20:37.490
对不对

20:37.490 --> 20:39.590
大于等于了数组的nince

20:39.590 --> 20:40.190
对吧

20:40.190 --> 20:41.290
是不是这样子的话

20:41.290 --> 20:42.890
他就是不是下标越界了

20:42.890 --> 20:45.290
下标越界是不是表示已经没数据了

20:45.290 --> 20:46.090
表示没数据

20:46.090 --> 20:48.690
他就表示已经取完了

20:48.690 --> 20:50.590
这个点子其实就写完了

20:50.590 --> 20:51.390
好看一下吧

20:51.390 --> 20:54.090
能不能理解理解一下这个代码啊

20:54.090 --> 20:54.690
这个代码呢

20:54.690 --> 20:56.390
跟你们以前写的那种循环的东西

20:56.390 --> 20:57.690
都完全不一样啊

20:57.690 --> 20:58.390
完全不一样

20:58.390 --> 20:59.690
所以说特别的抽象

20:59.690 --> 21:01.890
不是那么容易一下子转变的过来

21:02.390 --> 21:02.590
啊

21:03.790 --> 21:03.990
好

21:03.990 --> 21:05.190
这样子写完了过后

21:05.190 --> 21:06.890
他有个好处在什么呢

21:06.890 --> 21:08.390
好处在于

21:08.390 --> 21:10.590
虽然说这里变得麻烦一点啊

21:10.590 --> 21:11.490
这里确实麻烦

21:11.490 --> 21:12.690
跟以前循环都舒服

21:12.690 --> 21:13.290
对不对

21:13.290 --> 21:14.190
直接跟他打交道

21:14.190 --> 21:15.790
直接循环他就不完了吗

21:15.790 --> 21:17.090
但是现在呢

21:17.090 --> 21:17.890
以这样子写的话

21:17.890 --> 21:19.590
反而感觉更加麻烦了啊

21:19.590 --> 21:20.690
感觉更加麻烦了

21:20.690 --> 21:21.390
但是

21:22.190 --> 21:23.690
你这样子写了之后

21:23.690 --> 21:25.190
有个好处在于

21:25.190 --> 21:26.790
一旦你写完了

21:26.790 --> 21:28.490
我后续的操作

21:28.490 --> 21:29.090
比较重的后续

21:29.090 --> 21:29.890
这里边有很多数据

21:29.890 --> 21:31.390
我们要不断的去迭代他

21:31.390 --> 21:32.990
我们后续的操作

21:32.990 --> 21:34.890
还需要用循环吗

21:34.890 --> 21:36.490
不是要不要用循环

21:36.490 --> 21:38.990
还需要去关心这个玩意吗

21:38.990 --> 21:40.090
还需要去关心这个玩意

21:40.090 --> 21:40.890
不需要了

21:40.890 --> 21:43.390
我们只跟他打交道就行了

21:43.390 --> 21:45.490
只跟他打交道就完事了

21:45.490 --> 21:47.890
因为他就相当于是一个仓库的管理员

21:47.890 --> 21:50.890
他就来帮我们一个一个去取数据

21:50.890 --> 21:52.190
能体会到吗

21:52.190 --> 21:54.090
这就是迭代器的作用

21:54.090 --> 21:57.590
迭代器就是他来帮你去取数据

21:57.590 --> 22:00.690
你不用去直接跟数据打交道

22:00.690 --> 22:03.690
他抽象了整个取数据的过程

22:03.690 --> 22:04.390
来吧

22:04.390 --> 22:06.190
我们来看一下怎么来取数据

22:06.190 --> 22:07.190
Actorator

22:07.190 --> 22:09.190
是不是里面有个含书叫Next

22:09.190 --> 22:09.390
对吧

22:09.390 --> 22:11.690
我们只交用这个方法就完事了

22:11.690 --> 22:12.590
是不是雕用一次

22:12.590 --> 22:13.790
他能拿到下一个数据

22:13.790 --> 22:14.990
我们把输出

22:14.990 --> 22:16.990
把这个玩意输出

22:16.990 --> 22:21.100
看一下吧

22:21.100 --> 22:24.230
来看一下

22:24.230 --> 22:25.430
控制台

22:25.430 --> 22:27.930
你看是不是第一次得到的是Value1

22:27.930 --> 22:28.930
Dunway Force

22:28.930 --> 22:29.530
对吧

22:29.530 --> 22:31.930
然后我们再雕用一次

22:31.930 --> 22:34.130
Actorator

22:34.130 --> 22:35.830
优点来Negas

22:35.830 --> 22:37.430
所以得到了是Value2

22:37.430 --> 22:38.530
Dunway Force

22:38.530 --> 22:40.230
然后再雕用一次Value3

22:40.230 --> 22:41.230
是不是Dunway Force

22:41.230 --> 22:41.630
对吧

22:41.630 --> 22:42.830
他就起这么一个作用

22:42.830 --> 22:45.730
就是你通过他就直接去跟仓

22:45.730 --> 22:48.830
跟那个跟那个迭代器打交道就行了

22:48.830 --> 22:51.930
你要拿数据找迭代器

22:51.930 --> 22:53.930
数据是不是拿完了找迭代器

22:53.930 --> 22:56.030
你不用去直接跟数据仓库打交道

22:56.030 --> 22:57.130
他就把那个抽

22:57.130 --> 23:00.730
他就把这个取数据的过程给你封装了

23:00.730 --> 23:01.730
能体会到这个意思吗

23:01.730 --> 23:03.530
他就是迭代器的作用

23:03.530 --> 23:06.230
再雕用那个是Value4

23:06.230 --> 23:06.630
对吧

23:06.630 --> 23:08.430
再雕用那个是Value5

23:08.430 --> 23:09.430
现在都还没完成

23:09.430 --> 23:09.930
对吧

23:09.930 --> 23:12.430
然后我们再雕用那个是没数据了

23:12.430 --> 23:12.630
对吧

23:12.630 --> 23:13.230
没数据了

23:13.230 --> 23:14.630
Dunway Q

23:14.630 --> 23:15.630
对不对

23:15.630 --> 23:17.530
他就变成这么一种模式了

23:17.530 --> 23:20.030
虽然说我们写这个迭代器的过程

23:20.030 --> 23:21.730
感觉上有点绕

23:21.730 --> 23:22.930
有点噁心

23:22.930 --> 23:24.730
但是我们一旦写完了

23:24.730 --> 23:26.430
我们要用这个数据的时候

23:26.430 --> 23:29.630
要取这个数据的时候就非常舒服了

23:29.630 --> 23:32.130
因为我们不用去跟直接跟仓库打交道

23:32.230 --> 23:33.330
你看一下啊

23:33.330 --> 23:35.930
现在的跟循环有个很大的区别就是

23:35.930 --> 23:38.430
我想迭代几次就迭代几次

23:38.430 --> 23:39.730
他非常灵活

23:39.730 --> 23:42.330
比如说我针对同一个仓库

23:42.330 --> 23:43.130
针对同一个仓库

23:43.130 --> 23:45.030
我们就使用这个迭代器

23:45.030 --> 23:46.430
我们针对同一个仓库

23:46.430 --> 23:47.730
我想迭代三次

23:47.730 --> 23:49.530
我就雕用三个那个是对吧

23:49.530 --> 23:50.330
我想迭代四次

23:50.330 --> 23:51.830
我就雕用四个那个是

23:51.830 --> 23:54.830
我就可以属意的灵活的进行处理的

23:54.830 --> 23:56.530
你要用下一个数据就雕用一次

23:56.530 --> 23:58.030
用下一个数据就雕用一次

23:58.030 --> 24:00.730
这就有一点像现实生活中的那个产品迭代

24:00.730 --> 24:02.530
我先拿到第一

24:04.530 --> 24:06.130
先拿到第一代产品

24:06.130 --> 24:07.930
我用完了过后产品过

24:07.930 --> 24:08.830
ok了ok

24:08.830 --> 24:11.530
我现在再雕用一次拿到下一个产品

24:11.530 --> 24:11.930
对吧

24:11.930 --> 24:14.130
他就有一点像这种模式了

24:14.130 --> 24:16.530
能体会到这个意思了

24:16.530 --> 24:17.630
有点模糊是吧

24:17.630 --> 24:18.630
有点模糊没关系

24:18.630 --> 24:21.630
你就按照这个跟着我的试录走

24:21.630 --> 24:22.430
那么现在呢

24:22.430 --> 24:23.630
我们再来看一下

24:23.630 --> 24:25.630
如果说你要用迭代器

24:27.130 --> 24:28.230
把这个数据里边

24:28.230 --> 24:30.330
当然你根本就不知道数据

24:30.330 --> 24:32.130
根本就不知道数据

24:32.130 --> 24:33.230
不知道这个数据存在

24:33.230 --> 24:34.630
你只知道有这么一个迭代器

24:34.630 --> 24:37.930
他能够帮你一块一块去取数据

24:37.930 --> 24:39.330
那么我们想想

24:39.330 --> 24:41.630
如果说我现在想做这么一件事

24:41.630 --> 24:44.130
把这个迭代器的数据全部取完

24:45.330 --> 24:48.730
让迭代器不断的取出

24:48.730 --> 24:50.530
下一个数据

24:50.530 --> 24:56.030
直到没有数据为止

24:56.030 --> 24:58.330
就是直到迭代结束

24:58.330 --> 25:00.130
那么如果说你要写出这么一个功能的话

25:00.230 --> 25:01.430
该怎么写了

25:01.430 --> 25:02.730
你想想呗

25:02.730 --> 25:04.030
该怎么写

25:04.030 --> 25:05.530
其实非常简单

25:05.530 --> 25:07.630
你这里不是有个迭代器吗

25:07.630 --> 25:08.530
你调它的那个时候

25:08.530 --> 25:10.930
不是就拿到一个数据了吗

25:10.930 --> 25:12.130
对不对

25:12.130 --> 25:13.330
是不是拿到一个数据了

25:13.330 --> 25:14.030
对吧

25:14.030 --> 25:15.430
拿到下一个数据

25:15.430 --> 25:17.730
ok 你这个时候判断一下吧

25:17.730 --> 25:19.730
这个数据是不是已经完成了

25:19.730 --> 25:21.130
当

25:21.130 --> 25:23.530
如果它没有完成

25:23.530 --> 25:24.930
没有完成怎么办

25:24.930 --> 25:27.030
你是不是把这个数据就拿出来了

25:27.030 --> 25:28.330
data.value

25:28.330 --> 25:28.830
对不对

25:28.930 --> 25:30.130
因为我们刚才看到的

25:30.130 --> 25:31.930
它每次是不是得到这么一个对象

25:31.930 --> 25:32.930
调那个时候

25:32.930 --> 25:34.230
是不是得到这么一个对象

25:34.230 --> 25:35.030
有value属性

25:35.030 --> 25:36.030
有当属性

25:36.030 --> 25:37.930
如果说它已经

25:37.930 --> 25:39.430
它只要没有完成

25:39.430 --> 25:40.230
只要没完成

25:40.230 --> 25:41.630
说明你这里的数据

25:41.630 --> 25:43.830
只要没有迭代完成

25:43.830 --> 25:44.730
判断一下吧

25:44.730 --> 25:48.030
只要没有迭代完成

25:48.030 --> 25:51.830
则取出数据

25:51.830 --> 25:52.630
取出数据

25:52.630 --> 25:53.430
你看这里就是

25:53.430 --> 25:54.330
是不是把数据取出来

25:54.330 --> 25:54.930
输出了

25:54.930 --> 25:55.330
对吧

25:55.330 --> 25:56.230
取出数据

25:56.230 --> 26:01.830
然后进行下一次迭代

26:01.830 --> 26:02.830
然后我们这里

26:02.830 --> 26:04.630
是不是重新给data.fuzzer

26:04.630 --> 26:06.930
iterator.next

26:06.930 --> 26:07.630
重新复制

26:07.630 --> 26:07.930
对吧

26:07.930 --> 26:08.930
进行下一次迭代

26:08.930 --> 26:09.930
那么下一次迭代完成过

26:09.930 --> 26:11.130
是不是又进入yout群怀

26:11.130 --> 26:12.930
看它是不是已经完成了

26:12.930 --> 26:14.230
是不是已经迭代完成了

26:14.230 --> 26:15.130
如果没有迭代完成

26:15.130 --> 26:15.530
ok

26:15.530 --> 26:16.730
那么说明这里还有数据

26:16.730 --> 26:18.030
ok 把数据拿出来

26:18.030 --> 26:19.330
然后再进行下一次迭代

26:19.330 --> 26:21.230
那么直到迭代完成为止

26:21.230 --> 26:22.130
最后我们输出

26:22.130 --> 26:22.830
群怀结束之后

26:22.830 --> 26:23.730
我们输出

26:23.730 --> 26:25.930
迭代完成

26:26.930 --> 26:28.230
好

26:28.230 --> 26:28.730
保存

26:28.730 --> 26:29.330
看一下吧

26:29.330 --> 26:30.930
你看是不是输出了

26:30.930 --> 26:31.530
1235

26:31.530 --> 26:32.230
迭代完成

26:32.230 --> 26:32.730
对吧

26:32.730 --> 26:33.730
就用这种方式

26:33.730 --> 26:36.130
虽然说这种方式

26:36.130 --> 26:37.030
可能大家看起来

26:37.030 --> 26:38.430
还不如以前的

26:38.430 --> 26:38.930
复群怀

26:38.930 --> 26:40.130
复群怀更加好理解

26:40.130 --> 26:41.030
但是你要知道

26:41.030 --> 26:42.430
它里边的一个重要区别在那

26:42.430 --> 26:43.630
重要区别就是我们

26:43.630 --> 26:44.730
刚才不断的强调的

26:44.730 --> 26:46.130
你看整个循环过程

26:46.130 --> 26:46.930
有没有用到数据

26:46.930 --> 26:48.430
有没有用到这个数据

26:48.430 --> 26:51.730
它是把这个数据的

26:51.730 --> 26:53.530
就是把我们的数据

26:53.930 --> 26:55.930
跟我们的

26:55.930 --> 26:57.630
就是取数据

26:57.630 --> 26:59.030
是不是把它割裂了

26:59.030 --> 26:59.530
对吧

26:59.530 --> 27:01.130
把这两个字是不是分开了

27:01.130 --> 27:02.730
为什么它能够分开

27:02.730 --> 27:04.230
为什么能够把这个地方

27:04.230 --> 27:05.430
解除偶和

27:05.430 --> 27:07.130
是因为迭代器的存在

27:07.130 --> 27:08.930
它来里边去封装了

27:08.930 --> 27:10.930
对这个仓库里边的使用

27:10.930 --> 27:13.230
而不用我们在用的时候

27:13.230 --> 27:15.130
就不用去关心仓库本身了

27:15.130 --> 27:17.830
它封装了取数据的过程

27:17.830 --> 27:19.530
先把这个东西理解

27:19.530 --> 27:21.130
不是说这个东西一定好

27:21.130 --> 27:22.530
不是说以后我们学到

27:22.530 --> 27:23.530
这个是不是到到处以后

27:23.530 --> 27:24.730
就不用缝循环了

27:24.730 --> 27:25.630
全部要用它了

27:25.630 --> 27:26.930
不是的

27:26.930 --> 27:29.430
我们这里因为我们现在要讲迭代器

27:29.430 --> 27:30.730
所以说我要把他的理念

27:30.730 --> 27:31.930
给大家讲出来

27:31.930 --> 27:33.430
遇到那种特别复杂的

27:33.430 --> 27:34.230
取数据的过程

27:34.230 --> 27:35.530
我们就可以封装迭代器

27:35.530 --> 27:37.030
否则的话通常情况下

27:37.030 --> 27:39.430
我们是不需要自行去封装迭代器的

27:39.430 --> 27:40.630
那为什么要讲迭代器

27:40.630 --> 27:43.130
是因为要为后边的知识做准备

27:43.130 --> 27:46.330
所以你一定要理解这个东西

27:46.330 --> 27:48.230
接下来我们再来看

27:48.230 --> 27:49.630
其实像我们这里

27:49.630 --> 27:51.130
对这个数据的操作是不是

27:51.130 --> 27:53.930
通过迭代器来完成的

27:53.930 --> 27:54.330
对吧

27:54.330 --> 27:55.430
通过这个迭代器

27:55.430 --> 27:56.230
那么这个迭代器

27:56.230 --> 27:57.830
我们是直接写的

27:57.830 --> 27:59.930
这样子写的不好的地方在于什么

27:59.930 --> 28:01.930
以后如果说我们换了一个数组

28:01.930 --> 28:04.030
比方数组一边换成一个别的数组

28:04.030 --> 28:05.230
有两个数组

28:05.230 --> 28:06.630
我们是不是要写两个迭代器

28:06.630 --> 28:08.230
比方说我们还有比方说

28:08.230 --> 28:09.730
现在看另外一个例子

28:09.730 --> 28:10.830
就多举几个例子

28:10.830 --> 28:12.130
其实迭代器有支持我们

28:12.130 --> 28:13.530
这也和你讲完了

28:13.530 --> 28:15.130
我们就多看几个例子

28:15.130 --> 28:18.230
那么这里有个数组一有一个数组二

28:18.230 --> 28:20.330
那么我们要对数组一进行迭代

28:20.330 --> 28:22.230
数组二也要进行迭代

28:22.230 --> 28:27.600
比方说6 7 8 9

28:27.600 --> 28:28.800
要对数组一进行迭代

28:28.800 --> 28:30.100
要对数组二进行迭代

28:30.100 --> 28:32.200
那么我们是不是要写两个迭代器

28:32.200 --> 28:33.200
而这两个迭代器的代码

28:33.200 --> 28:34.500
是不是都差不多的

28:34.500 --> 28:34.900
OK

28:34.900 --> 28:36.000
那么既然这样子的话

28:36.000 --> 28:38.000
如果我写两个迭代器的话

28:38.000 --> 28:39.300
会导致很多重复代码

28:39.300 --> 28:40.400
因此我们这里

28:40.400 --> 28:41.600
往往会这样子写

28:41.600 --> 28:44.000
写出这么一个函数

28:44.000 --> 28:51.100
叫做Gateatorator

28:51.200 --> 28:55.200
或者是我们把它叫做Creatorator

28:55.200 --> 28:56.900
那么这个函数它的用处是什么

28:56.900 --> 28:58.300
它给我一个数组

28:58.300 --> 29:00.000
你给我一个数组

29:00.000 --> 29:01.400
那么我会根据这个数组

29:01.400 --> 29:04.000
来帮你创建一个迭代器返回

29:04.000 --> 29:08.100
那么这个函数就叫做迭代器创建函数

29:08.100 --> 29:11.700
它叫做迭代器创建函数

29:11.700 --> 29:16.700
我们通常把它称之为atorator

29:16.700 --> 29:18.000
就是ator的什么意思

29:18.000 --> 29:19.400
就迭代器 creator

29:19.400 --> 29:20.500
就是创建者

29:20.600 --> 29:22.900
它是用来创建一个迭代器的

29:22.900 --> 29:23.800
那么这个函数里边

29:23.800 --> 29:25.000
还需要给它一个数组

29:25.000 --> 29:26.000
你甭管是什么数组

29:26.000 --> 29:26.600
你给我

29:26.600 --> 29:27.900
我就可以帮你进行迭代

29:27.900 --> 29:28.700
那我怎么迭代呢

29:28.700 --> 29:29.800
我们是不是把下面代码

29:29.800 --> 29:31.600
直接拿过来就完事了

29:31.600 --> 29:33.100
是不是直接拿过来就完事了

29:33.100 --> 29:34.700
就这么简单

29:34.700 --> 29:36.000
创建一个迭代器

29:36.000 --> 29:38.300
那么这个下标i

29:38.300 --> 29:39.700
那就没必要放这了

29:39.700 --> 29:40.300
没必要放这了

29:40.300 --> 29:41.900
我们可以放到函数里边

29:41.900 --> 29:43.900
定一个下标i

29:43.900 --> 29:45.500
i的云零

29:45.500 --> 29:47.100
当前的速度下标放到这

29:47.100 --> 29:48.700
那么这里就不需要属性了

29:48.700 --> 29:50.500
那么这里就直接使用i

29:50.500 --> 29:51.800
直接使用i

29:51.800 --> 29:53.800
这里i加加

29:53.800 --> 29:54.200
对吧

29:54.200 --> 29:55.400
所以写成这样子

29:55.400 --> 29:56.600
这样子的函数

29:56.600 --> 29:59.500
它就会帮我们创建一个迭代器

29:59.500 --> 30:01.000
这样子的就更加通用了

30:01.000 --> 30:02.600
任何数组我们都可以使用它

30:02.600 --> 30:05.400
都可以使用这个函数来得到迭代器

30:05.400 --> 30:06.500
好 接下来我们来看一下吧

30:09.500 --> 30:11.400
现在我们比方说

30:11.400 --> 30:13.500
我们可以得到两个迭代器

30:13.500 --> 30:16.200
一个是ator1

30:16.200 --> 30:19.200
我们可以用createatorare1

30:19.200 --> 30:20.100
传进去

30:20.100 --> 30:21.200
然后我们再来一个

30:21.200 --> 30:23.800
再来一个ator2

30:23.800 --> 30:25.400
ator2are2传进去

30:25.400 --> 30:26.900
是不是可以得到两个迭代器了

30:26.900 --> 30:27.300
对吧

30:27.300 --> 30:28.700
通过函数返回指

30:28.700 --> 30:30.200
是不是可以得到两个迭代器

30:30.200 --> 30:30.400
对吧

30:30.400 --> 30:31.100
我们来看一下吧

30:31.100 --> 30:31.700
这两个迭代器

30:31.700 --> 30:32.800
我们分别用一下

30:32.800 --> 30:33.500
来感受一下

30:35.500 --> 30:35.700
好

30:35.700 --> 30:37.700
这个ator1next

30:39.000 --> 30:39.700
你看

30:39.700 --> 30:40.600
ator1next

30:40.600 --> 30:41.900
是不是一个个取出来了

30:41.900 --> 30:42.600
对吧

30:42.600 --> 30:44.200
取不到数据为止

30:44.200 --> 30:44.900
对不对

30:44.900 --> 30:45.600
没问题吧

30:45.600 --> 30:48.600
我们可以通过一个函数来创建一个迭代器

30:48.600 --> 30:50.600
为什么要给大家取这个例子呢

30:50.600 --> 30:51.400
这个例子呢

30:51.400 --> 30:53.000
首先就是要带大家认识

30:53.000 --> 30:54.600
有个东西叫做迭代器

30:54.600 --> 30:55.600
创建函数

30:55.600 --> 30:58.600
这个函数它可以帮你返回这么一个迭代器

30:59.600 --> 31:01.600
先看个眼熟

31:01.600 --> 31:03.600
先认识一下这个东西

31:03.600 --> 31:04.600
这些代码

31:04.600 --> 31:06.600
像是一个函数

31:06.600 --> 31:07.600
这个函数

31:07.600 --> 31:09.600
它可以帮你返回这么一个迭代器

31:11.600 --> 31:12.600
先看个眼熟

31:12.600 --> 31:14.600
先认识一下这个东西

31:14.600 --> 31:15.600
这些代码下来

31:15.600 --> 31:16.600
大家都要去写一次

31:16.600 --> 31:18.600
甭管你感觉有用没用

31:18.600 --> 31:19.600
有用没用

31:19.600 --> 31:20.600
你学到后边就知道了

31:21.600 --> 31:22.600
这是关于这一块

31:23.600 --> 31:24.100
好

31:24.100 --> 31:24.600
今天我们再来看

31:24.600 --> 31:27.600
再来看一个比较使用的一个例子

31:28.600 --> 31:30.600
比方说我们有这么一个例子

31:34.600 --> 31:35.600
这个例子呢

31:35.600 --> 31:36.600
是这样子的

31:38.600 --> 31:41.600
我需要就是一次得到

31:41.600 --> 31:43.600
一次得到

31:43.600 --> 31:46.600
飞波拉气数列

31:46.600 --> 31:47.600
飞波拉气数列什么意思

31:47.600 --> 31:49.600
就是前两位

31:49.600 --> 31:51.600
后一位等于前两位之合

31:51.600 --> 31:53.600
飞波拉气数列

31:53.600 --> 31:56.600
前面N位的值

31:56.600 --> 31:58.600
N位的值

31:58.600 --> 32:00.600
我需要一次得到

32:00.600 --> 32:02.600
飞波拉气数列前面N位的值

32:03.600 --> 32:04.600
好

32:04.600 --> 32:06.600
那么这种场景下边

32:06.600 --> 32:08.600
这种场景下边

32:08.600 --> 32:10.600
如果说你用以前的思维的话

32:10.600 --> 32:12.600
可能会使用一个数组

32:12.600 --> 32:13.600
你给我传一个N进来

32:13.600 --> 32:14.600
我给你构建这么一个

32:14.600 --> 32:15.600
长度的数组

32:15.600 --> 32:17.600
我把飞波拉气数列

32:17.600 --> 32:18.600
该解释一下

32:18.600 --> 32:19.600
第一位是1

32:19.600 --> 32:20.600
第二位是1

32:20.600 --> 32:21.600
前两位固定为1

32:21.600 --> 32:22.600
第三位是2

32:22.600 --> 32:23.600
2是怎么来的

32:23.600 --> 32:24.600
前两位相加

32:24.600 --> 32:26.600
第四位是3

32:26.600 --> 32:27.600
前两位相加

32:27.600 --> 32:29.600
第四位是5

32:29.600 --> 32:30.600
前两位相加

32:30.600 --> 32:31.600
第六位相加

32:31.600 --> 32:33.600
前两位相加

32:33.600 --> 32:35.600
前两位相加

32:35.600 --> 32:37.600
第七位相加

32:37.600 --> 32:39.600
前两位相加

32:39.600 --> 32:40.600
然后13

32:40.600 --> 32:42.600
前两位相加

32:42.600 --> 32:43.600
没问题吧

32:43.600 --> 32:44.600
飞波拉气数列

32:44.600 --> 32:46.600
可以无限延伸下去

32:46.600 --> 32:48.600
可以无限延伸

32:48.600 --> 32:49.600
那么

32:49.600 --> 32:51.600
如果说按照以前的做法的话

32:51.600 --> 32:52.600
你可能会写这么一个数组

32:52.600 --> 32:53.600
长度为N

32:53.600 --> 32:54.600
你写个函数

32:54.600 --> 32:55.600
你把N传给我

32:55.600 --> 32:57.600
我给你构建这么一个数组

32:57.600 --> 32:58.600
然后把飞波拉气数列

32:58.600 --> 32:59.600
全部传进去

32:59.600 --> 33:00.600
但是数组这样的

33:00.600 --> 33:02.600
不好的地方在什么呢

33:02.600 --> 33:04.600
不好的地方在这里

33:04.600 --> 33:05.600
有的时候

33:05.600 --> 33:07.600
我可能不能确定

33:07.600 --> 33:08.600
我到底要用多少位

33:08.600 --> 33:10.600
有的时候我确实不能确定

33:10.600 --> 33:12.600
有可能我用10位就够了

33:12.600 --> 33:14.600
有可能我要用1万位

33:14.600 --> 33:16.600
我不能确定我到底要用多少

33:16.600 --> 33:17.600
我用多少算多少

33:17.600 --> 33:19.600
这个时候数字就麻烦了

33:19.600 --> 33:21.600
那数组到底创建一个

33:21.600 --> 33:22.600
多长长度的数组

33:22.600 --> 33:24.600
我要给它加多少数据进去了

33:24.600 --> 33:25.600
就不要麻烦了

33:25.600 --> 33:26.600
因为你不

33:26.600 --> 33:27.600
外面的用的人

33:27.600 --> 33:28.600
他不知道他自己要用多少

33:28.600 --> 33:30.600
有可能会出现这种情况

33:30.600 --> 33:32.600
就像我们要用的数据

33:32.600 --> 33:33.600
就是我们迭代的过程

33:33.600 --> 33:34.600
我们就是说过

33:34.600 --> 33:35.600
迭代的过程

33:35.600 --> 33:36.600
它是不关心

33:36.600 --> 33:37.600
后面还有多少数据的

33:37.600 --> 33:38.600
不关心的

33:38.600 --> 33:39.600
我只是拿一个用一个

33:39.600 --> 33:40.600
拿一个用一个

33:40.600 --> 33:41.600
他关心的是这个

33:41.600 --> 33:43.600
那你数组的话你不能不关心

33:43.600 --> 33:44.600
你要把数据给他

33:44.600 --> 33:45.600
对不对

33:45.600 --> 33:47.600
那这个地方就有点麻烦了

33:47.600 --> 33:48.600
那数组

33:48.600 --> 33:49.600
如果说你要考虑到

33:49.600 --> 33:50.600
就是各种场景的话

33:50.600 --> 33:51.600
你要创建一个

33:51.600 --> 33:53.600
非常非常长的数组

33:53.600 --> 33:54.600
保证它够用

33:54.600 --> 33:55.600
但是实际上用的时候

33:55.600 --> 33:56.600
还用不到那么多

33:56.600 --> 33:57.600
但是那你数组

33:57.600 --> 33:58.600
又必须要保证它够用

33:58.600 --> 33:59.600
那么这种场景

33:59.600 --> 34:02.600
就特别适合使用迭代器

34:02.600 --> 34:03.600
因为迭代器

34:03.600 --> 34:05.600
它不关心

34:05.600 --> 34:07.600
我只管取下一个就行了

34:07.600 --> 34:08.600
我只管取下一个

34:08.600 --> 34:09.600
我不管后边还有多少

34:09.600 --> 34:10.600
你看一下

34:10.600 --> 34:11.600
我在这种场景下边

34:11.600 --> 34:14.600
我怎么来使用迭代器

34:14.600 --> 34:16.600
接下来我们写这么一个函数

34:16.600 --> 34:18.600
叫做crate

34:18.600 --> 34:19.600
crate

34:19.600 --> 34:20.600
fable

34:20.600 --> 34:21.600
iterator

34:21.600 --> 34:23.600
创建一个fable

34:23.600 --> 34:25.600
垃圾数列的迭代器

34:25.600 --> 34:27.600
创建一个fable

34:27.600 --> 34:29.600
垃圾数列的迭代器

34:29.600 --> 34:31.600
你把这个例子看懂了过后

34:31.600 --> 34:33.600
你觉得迭代器是有用的

34:33.600 --> 34:34.600
迭代器

34:35.600 --> 34:37.600
接下来我们看一下

34:37.600 --> 34:38.600
既然它要创建一个迭代器

34:38.600 --> 34:40.600
是不是一定得返回一个对象

34:40.600 --> 34:42.600
对象里边一定有一个那个方法

34:42.600 --> 34:43.600
那个什么方法里边

34:43.600 --> 34:44.600
一定有返回一个对象

34:44.600 --> 34:45.600
白六指

34:45.600 --> 34:46.600
是啥

34:46.600 --> 34:48.600
然后还就是

34:48.600 --> 34:49.600
适逢完成

34:49.600 --> 34:50.600
那么你想

34:50.600 --> 34:51.600
fable垃圾数列

34:51.600 --> 34:53.600
是不是一个无线的数列

34:53.600 --> 34:55.600
可以无线延伸下去的数列

34:55.600 --> 34:57.600
那么适逢完成了

34:57.600 --> 34:59.600
永远都不会完成

34:59.600 --> 35:02.600
它是一个无线延伸下去的数列

35:02.600 --> 35:03.600
你看一下

35:03.600 --> 35:04.600
那么这个迭代器

35:04.600 --> 35:06.600
你偏别看别的

35:06.600 --> 35:09.600
光是看这个属性当为force

35:09.600 --> 35:11.600
你知道这个迭代器不简单了

35:11.600 --> 35:13.600
这个迭代器说明是

35:13.600 --> 35:14.600
是不是可以无线延伸的

35:14.600 --> 35:16.600
可以无线的去取下一个数据

35:16.600 --> 35:17.600
对吧

35:17.600 --> 35:18.600
当是什么意思

35:18.600 --> 35:19.600
表示迭代完成

35:19.600 --> 35:20.600
没有东西了

35:20.600 --> 35:21.600
那么当我一直

35:21.600 --> 35:22.600
永远为force

35:22.600 --> 35:23.600
是不是一直有下一个

35:23.600 --> 35:24.600
一直有下一个

35:24.600 --> 35:26.600
这个东西能用数组做吗

35:26.600 --> 35:27.600
数组能做到吗

35:27.600 --> 35:29.600
数组是做不到

35:29.600 --> 35:30.600
你能够创建一个

35:30.600 --> 35:32.600
无线延伸的数组吗

35:32.600 --> 35:33.600
你创建不了吧

35:33.600 --> 35:36.600
数组总有一个就是长度的

35:36.600 --> 35:39.600
它长度不能是一个无线纸

35:39.600 --> 35:40.600
但是迭代器可以

35:40.600 --> 35:42.600
因为迭代器它不关心

35:42.600 --> 35:43.600
后面还有多少数据

35:43.600 --> 35:44.600
它不关心

35:44.600 --> 35:46.600
我只关心我取下一个就行了

35:46.600 --> 35:47.600
我只要能够想办法

35:47.600 --> 35:48.600
把下一个拿到就行了

35:48.600 --> 35:50.600
你看之前用到的数据

35:50.600 --> 35:51.600
是因为我要取

35:51.600 --> 35:53.600
我要去对数组进行迭代

35:53.600 --> 35:54.600
所以说我用到的数据

35:54.600 --> 35:56.600
那么你看迭代器里面

35:56.600 --> 35:58.600
其实它根本就没有关心

35:58.600 --> 35:59.600
这个数据

35:59.600 --> 36:00.600
还有多少数据

36:00.600 --> 36:01.600
我根本就不care

36:01.600 --> 36:02.600
我需要去care

36:02.600 --> 36:03.600
数据到下一个就行了

36:03.600 --> 36:04.600
拿下一个

36:04.600 --> 36:05.600
拿下一个

36:05.600 --> 36:06.600
那么就是这个道理

36:06.600 --> 36:08.600
那么由于迭代器数据是无线的

36:08.600 --> 36:09.600
ok 我就无线拿

36:09.600 --> 36:10.600
拿完一个

36:10.600 --> 36:11.600
你只要还需要

36:11.600 --> 36:12.600
我就给你拿下一个

36:12.600 --> 36:14.600
那么下一个是啥呢

36:14.600 --> 36:15.600
下一个是啥呢

36:15.600 --> 36:16.600
那么我现在呢

36:16.600 --> 36:17.600
我们就记录一下吧

36:17.600 --> 36:18.600
记录一下

36:18.600 --> 36:19.600
我们这个地方的迷流值

36:19.600 --> 36:21.600
有当前这个值

36:21.600 --> 36:22.600
当前这个值

36:22.600 --> 36:23.600
我们这样子来记录

36:23.600 --> 36:25.600
我们这里定义两个变量

36:25.600 --> 36:26.600
两个变量

36:26.600 --> 36:27.600
一个是prime1

36:27.600 --> 36:30.600
前第一位

36:31.600 --> 36:32.600
prime2

36:33.600 --> 36:34.600
定义这么两个变量

36:34.600 --> 36:35.600
分别表示

36:35.600 --> 36:36.600
当前的

36:37.600 --> 36:38.600
当前位置的

36:39.600 --> 36:41.600
前一位

36:42.600 --> 36:44.600
和前二位

36:45.600 --> 36:46.600
啥意思呢

36:46.600 --> 36:47.600
比方说

36:47.600 --> 36:48.600
当前的位置是

36:48.600 --> 36:49.600
当前的到这个位置的

36:49.600 --> 36:50.600
对吧

36:50.600 --> 36:51.600
要从这个位置取数据了

36:52.600 --> 36:53.600
那么前面取的是什么呢

36:53.600 --> 36:55.600
前面的第一位是3

36:55.600 --> 36:56.600
第二位是2

36:56.600 --> 36:57.600
就记录这个东西

36:57.600 --> 36:58.600
没了意思吗

36:59.600 --> 37:01.600
我就记录他之前的那一位

37:01.600 --> 37:03.600
和在前面的那一位

37:03.600 --> 37:04.600
对不对

37:04.600 --> 37:05.600
好 那么迷流值

37:05.600 --> 37:06.600
是不是特别简单

37:06.600 --> 37:07.600
迷流值是应该等于什么呢

37:07.600 --> 37:09.600
迷流值是不等于prime1

37:09.600 --> 37:10.600
加上prime2

37:10.600 --> 37:11.600
对吧

37:11.600 --> 37:12.600
前两位之合吗

37:12.600 --> 37:13.600
是不是当前的value

37:14.600 --> 37:15.600
那么这样一加完了过后呢

37:15.600 --> 37:17.600
你还得处理一下

37:17.600 --> 37:19.600
还有一件事情要做

37:19.600 --> 37:20.600
还有什么事情的

37:20.600 --> 37:21.600
你是不是要把这两个变量改一下

37:21.600 --> 37:22.600
对吧

37:22.600 --> 37:24.600
你把当前的值改成这个了

37:24.600 --> 37:25.600
那么prime1

37:25.600 --> 37:27.600
需要变成prime2

37:28.600 --> 37:30.600
是不是变成prime1

37:30.600 --> 37:32.600
那么prime1变成

37:32.600 --> 37:34.600
当前的迷流值

37:34.600 --> 37:35.600
对不对

37:35.600 --> 37:36.600
是不是这样子来做的

37:38.600 --> 37:40.600
没问题吧

37:40.600 --> 37:41.600
没问题吧

37:41.600 --> 37:43.600
我给大家画个头吧

37:43.600 --> 37:44.600
给大家画个头

37:45.600 --> 37:49.060
比方说

37:49.060 --> 37:51.060
我们就从第三位开始算

37:51.060 --> 37:52.060
第三位开始算

37:52.060 --> 37:54.700
我们比方说

37:54.700 --> 37:55.700
假设

37:55.700 --> 37:56.700
从第三位开始算

37:56.700 --> 37:58.700
前两位为1

37:58.700 --> 37:59.700
前两位为1

37:59.700 --> 38:01.700
从第三位开始算

38:01.700 --> 38:04.140
来吧

38:05.140 --> 38:07.140
我们这里是prime1

38:07.140 --> 38:09.140
这是1

38:09.140 --> 38:11.140
1

38:11.140 --> 38:12.140
现在我们到这了

38:12.140 --> 38:13.140
到这了

38:13.140 --> 38:15.140
我们要取这一位

38:15.140 --> 38:17.140
取下一位就是取这了

38:17.140 --> 38:19.140
那么现在prime1

38:19.140 --> 38:20.140
在这

38:20.140 --> 38:22.140
prime1在这

38:22.140 --> 38:25.140
然后prime2在这

38:25.140 --> 38:27.140
那么这个位置的值是啥

38:27.140 --> 38:29.140
是不是prime1加上prime2

38:29.140 --> 38:30.140
是不是变成这个位置

38:31.140 --> 38:32.140
变成2

38:33.140 --> 38:34.140
那么到时候

38:34.140 --> 38:36.140
以后还要取下一位

38:36.140 --> 38:38.140
是不是你要把prime1变到这

38:38.140 --> 38:39.140
对吧

38:39.140 --> 38:40.140
把迷流值负责给他

38:40.140 --> 38:41.140
你看

38:42.140 --> 38:44.140
迷流值负责给他

38:44.140 --> 38:45.140
prime1变到这

38:45.140 --> 38:46.140
那么prime2变到这

38:46.140 --> 38:47.140
对吧

38:47.140 --> 38:48.140
是不是我们要之前

38:48.140 --> 38:50.140
把prime1负责给prime2

38:50.140 --> 38:52.140
prime1负责给prime2

38:52.140 --> 38:53.140
变成这个样子

38:53.140 --> 38:54.140
这样子的话

38:54.140 --> 38:56.140
下一次再取数据的时候

38:56.140 --> 38:57.140
下一次再取数据的时候

38:57.140 --> 38:59.140
是不是还是他加上他

38:59.140 --> 39:00.140
多少

39:00.140 --> 39:02.140
然后又变过来

39:02.140 --> 39:03.140
prime1

39:03.140 --> 39:04.140
prime2

39:04.140 --> 39:05.140
然后下一次再取数据的时候

39:05.140 --> 39:06.140
是不是变到他

39:06.140 --> 39:07.140
对不对

39:07.140 --> 39:08.140
变到5

39:08.140 --> 39:09.140
那么又变过来

39:09.140 --> 39:10.140
对吧

39:10.140 --> 39:11.140
就是这么一个原理

39:11.140 --> 39:12.140
就是这么一个原理

39:12.140 --> 39:13.140
这个意思

39:13.140 --> 39:14.140
当然前面条件

39:14.140 --> 39:15.140
我这里

39:15.140 --> 39:17.140
是假设从第三位开始取

39:17.140 --> 39:19.140
假设从第三位开始取

39:19.140 --> 39:20.140
而实际上取的时候

39:20.140 --> 39:22.140
是从第一位开始取的

39:22.140 --> 39:24.140
实际上是从第一位开始取的

39:24.140 --> 39:25.140
所以说

39:25.140 --> 39:26.140
我们这里一块

39:26.140 --> 39:27.140
我们要判断

39:27.140 --> 39:28.140
是不是前两位

39:28.140 --> 39:29.140
我们要判断一下

39:29.140 --> 39:30.140
是不是前两位

39:30.140 --> 39:32.140
比方说我们再写个变量

39:32.140 --> 39:36.140
是不是前两位

39:36.140 --> 39:39.140
前两位

39:39.140 --> 39:42.140
一开始为处

39:42.140 --> 39:45.140
是否

39:45.140 --> 39:47.140
就是取到第几位了

39:47.140 --> 39:48.140
取到第几位了

39:48.140 --> 39:49.140
我们用个变量

39:49.140 --> 39:50.140
取到第几位了

39:50.140 --> 39:52.830
用个变量

39:52.830 --> 39:53.830
n

39:53.830 --> 39:54.830
n等于

39:54.830 --> 39:56.830
n等于1

39:56.830 --> 39:58.830
n等于1

39:58.830 --> 39:59.830
n等于1

39:59.830 --> 40:02.830
当前是第几位

40:02.830 --> 40:04.830
第几位

40:04.830 --> 40:07.830
如果说当前n

40:07.830 --> 40:08.830
我们这个白六字

40:08.830 --> 40:09.830
可以判断一下

40:09.830 --> 40:10.830
这个白六字

40:10.830 --> 40:15.100
我们这里可以判断一下

40:15.100 --> 40:16.100
n

40:16.100 --> 40:19.100
如果说当前的n小于

40:19.100 --> 40:20.100
等于2

40:20.100 --> 40:22.100
如果当前的n小于等于2

40:22.100 --> 40:23.100
是不是前两位

40:23.100 --> 40:24.100
前两位的话

40:24.100 --> 40:26.100
白六字固定为1

40:26.100 --> 40:27.100
白六字固定为1

40:27.100 --> 40:28.100
好

40:28.100 --> 40:29.100
如果说不是前两位的话

40:29.100 --> 40:30.100
白六字才等于

40:30.100 --> 40:34.100
prev1加上prev2

40:34.100 --> 40:35.100
对吧

40:35.100 --> 40:36.100
白六字才等于这个

40:36.100 --> 40:37.100
好

40:37.100 --> 40:38.100
那么我们把一个白六字放进来

40:38.100 --> 40:39.100
每一次完了过后

40:39.100 --> 40:40.100
n加加

40:40.100 --> 40:41.100
每一次完了过后

40:41.100 --> 40:42.100
n加加

40:42.100 --> 40:44.100
用来表示第几位

40:44.100 --> 40:45.100
对吧

40:45.100 --> 40:46.100
就写出这么一个代码

40:46.100 --> 40:47.100
你甭管的代码

40:47.100 --> 40:48.100
看上去那么恶心

40:48.100 --> 40:49.100
那么复杂

40:49.100 --> 40:50.100
但它至少完成了一件事

40:50.100 --> 40:51.100
它做什么呢

40:51.100 --> 40:53.100
它产生了这么一个迭代器

40:53.100 --> 40:54.100
这个迭代器

40:54.100 --> 40:55.100
可以不断的去取出

40:55.100 --> 40:56.100
非布拉奇书里的

40:56.100 --> 40:57.100
下一位

40:57.100 --> 40:59.100
而且它是可以无限取的

40:59.100 --> 41:00.100
看一下吧

41:00.100 --> 41:02.100
我们这里得到这个迭代器

41:02.100 --> 41:03.100
iterator

41:03.100 --> 41:05.100
create feeboiterator

41:05.100 --> 41:06.100
来吧

41:06.100 --> 41:07.100
我们看一下

41:08.100 --> 41:10.100
它跟数值就不一样了

41:10.100 --> 41:11.100
你写

41:11.100 --> 41:13.100
现在有这么一个迭代器

41:13.100 --> 41:14.100
那么现在我不用关系

41:14.100 --> 41:15.100
它怎么取的

41:15.100 --> 41:17.100
我只要一调用那个方法

41:17.100 --> 41:18.100
下一个

41:18.100 --> 41:19.100
我取下一个

41:19.100 --> 41:20.100
取下一个

41:20.100 --> 41:21.100
取下一个

41:21.100 --> 41:22.100
取下一个

41:22.100 --> 41:23.100
取下一个

41:23.100 --> 41:24.100
你想想这个道理

41:24.100 --> 41:25.100
是不是可以无限取下去

41:25.100 --> 41:26.100
我想用多少

41:26.100 --> 41:27.100
对吧

41:27.100 --> 41:28.100
我要用多少

41:28.100 --> 41:29.100
用多少

41:29.100 --> 41:30.100
可以无限取下去

41:30.100 --> 41:31.100
那么数组能办到吗

41:31.100 --> 41:32.100
数组里根本就

41:32.100 --> 41:33.100
数组里就必须要知道

41:33.100 --> 41:34.100
它到底要用多少

41:34.100 --> 41:35.100
我可以拿多少

41:35.100 --> 41:36.100
对吧

41:36.100 --> 41:37.100
那么它每一次取的

41:37.100 --> 41:38.100
是不是动态的

41:38.100 --> 41:39.100
去拿下一个数据的

41:39.100 --> 41:40.100
这才

41:40.100 --> 41:41.100
这是迭代器才能办到的事情

41:41.100 --> 41:43.100
数组是很难办到的

41:43.100 --> 41:45.100
这是迭代器的优势

41:45.100 --> 41:46.100
有的时候

41:46.100 --> 41:47.100
面试的时候

41:47.100 --> 41:48.100
可能会问你

41:48.100 --> 41:51.100
我要创建一个无限长的数据

41:51.100 --> 41:53.100
我要去取一个无限长的数据

41:53.100 --> 41:54.100
或者是一个量级

41:54.100 --> 41:55.100
非常非常大的数据

41:55.100 --> 41:57.100
我要一次把矩形迭代

41:57.100 --> 41:58.100
用什么好

41:58.100 --> 41:59.100
用迭代器最好

41:59.100 --> 42:00.100
因为数组的话

42:00.100 --> 42:01.100
它就必须要把所有数据

42:01.100 --> 42:02.100
给装进去

42:02.100 --> 42:03.100
然后你去用

42:03.100 --> 42:04.100
我这个不需要装

42:04.100 --> 42:05.100
你只管取下一个就行了

42:05.100 --> 42:06.100
对吧

42:06.100 --> 42:07.100
迭代器的最核心思想

42:07.100 --> 42:08.100
就是取下一个

42:08.100 --> 42:09.100
取下一个

42:09.100 --> 42:10.100
还有没有

42:10.100 --> 42:11.100
还有没有

42:11.100 --> 42:12.100
就这个思想

42:12.100 --> 42:14.100
它内部的实现

42:14.100 --> 42:15.100
多种多样

42:15.100 --> 42:16.100
但是它最终出来的对象

42:16.100 --> 42:17.100
一定是一样的

42:17.100 --> 42:19.100
一定是有个那个式的方法

42:19.100 --> 42:20.100
一定是一个那个式的方法

42:20.100 --> 42:22.100
方法一定会返回一个对象

42:22.100 --> 42:23.100
对对象里边

42:24.100 --> 42:25.100
它里边怎么取的

42:25.100 --> 42:26.100
你别管

42:26.100 --> 42:27.100
是不是这样的

42:27.100 --> 42:28.100
就封装了取数据的过程

42:28.100 --> 42:29.100
对吧

42:29.100 --> 42:30.100
迭代器它就是

42:30.100 --> 42:31.100
封装取数据的过程

42:31.100 --> 42:32.100
你别管它怎么取的

42:32.100 --> 42:34.100
你需要数据就问它要

42:34.100 --> 42:36.100
它一定会给你拿下一个

42:36.100 --> 42:37.100
没有了

42:37.100 --> 42:38.100
它就会告诉你没有了

42:38.100 --> 42:39.100
那么原来的意思

42:39.100 --> 42:41.100
就是迭代器的作用

42:42.100 --> 42:43.100
这几课

42:43.100 --> 42:44.100
知识就讲完了

42:44.100 --> 42:46.100
而且讲了三个例子

42:46.100 --> 42:47.100
这三个例子

42:47.100 --> 42:49.100
大家下去练习一下

42:49.100 --> 42:51.100
体会一下迭代器

42:51.100 --> 42:53.100
它跟循环的区别

42:53.100 --> 42:54.100
以及迭代器

42:54.100 --> 42:56.100
它跟我们以前的数组

42:56.100 --> 42:57.100
类便利的区别

42:57.100 --> 42:58.100
好好去体会一下

42:58.100 --> 42:59.100
好吧

42:59.100 --> 43:00.100
这关于迭代器

