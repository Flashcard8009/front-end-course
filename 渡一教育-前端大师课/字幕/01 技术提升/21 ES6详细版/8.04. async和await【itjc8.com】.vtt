WEBVTT

00:00.820 --> 00:04.620
支持咱们Promise这一块东西又学完了

00:04.620 --> 00:09.540
Promise这个东西它其实大家也体验到了

00:09.540 --> 00:13.420
它并没有消除毁掉 它毁掉是没有消除的

00:13.420 --> 00:16.620
你看我们Promise里面咱们怎么写的

00:16.620 --> 00:21.260
Promise 溜了一个Promise 然后这里面写了一堂东西

00:21.260 --> 00:23.580
这里面是不是有毁掉 是不是有毁掉函数

00:23.580 --> 00:26.540
然后后面我们Zin方法里面说一个毁掉函数

00:26.540 --> 00:29.820
它其实没有消除毁掉 但它消除了什么呢

00:30.020 --> 00:34.980
它有两个作用 第一个作用是消除了毁掉地域

00:34.980 --> 00:37.620
它不用毁掉 毁掉函毁掉了 对吧

00:37.620 --> 00:43.140
它可以使用链式编程 让整个毁掉函数有序的进行

00:43.140 --> 00:45.900
这是它第一个好处 第二个好处就是

00:45.900 --> 00:51.140
我们以后的所有的异部场景其实都可以使用Promise来完成

00:51.140 --> 00:55.980
那么就统一了 不管你是公司也好还是个人也好

00:55.980 --> 00:58.580
张三也好 李四也好 咱们处理毁掉

00:58.620 --> 01:02.540
要处理这个异部场景 都把它变成一个异部任务

01:02.540 --> 01:05.900
这样子我们就把异部的处理统一得起来

01:05.900 --> 01:09.300
统一有什么好处呢 这节课看一下

01:09.300 --> 01:13.540
统一之后的好处在于官方这个时候就可以出面了

01:13.540 --> 01:18.740
既然大家都用了这种方式来处理异部 好

01:18.740 --> 01:22.300
我就给你出一个新的语法 注意啊

01:22.300 --> 01:25.260
只有官方才能出新语法

01:25.260 --> 01:28.060
你像写个函数 写个对象谁不会呢

01:28.100 --> 01:31.100
我们也可以写 对吧 你不是官方你可以写

01:31.100 --> 01:34.020
像Promise最早的时候是不是个A加规范

01:34.020 --> 01:36.220
最早的时候产生了一个社区规范

01:36.220 --> 01:39.740
它就不是官方搞的 它无非就是让你去做一个对象

01:39.740 --> 01:44.500
然后做一个对象里边有哪些方法给你规定好

01:44.500 --> 01:48.540
像一些对象 函数这些东西不一定官方来搞

01:48.540 --> 01:55.380
民间也可以搞出来 但是只有语法必须要官方规定

01:55.420 --> 01:58.620
比方说什么关键制 护循环 外护循环

01:58.620 --> 02:01.860
这些就必须要官方规定 你民间是搞不出来这个东西的

02:01.860 --> 02:08.900
那么这个东西 由于我们的异部处理统一的起来

02:08.900 --> 02:12.700
统一之后的好处在于 你既然大家都使用Promise

02:12.700 --> 02:17.020
好 我给你出一个新的语法 让你写Promise也好

02:17.020 --> 02:21.660
让你去处理Promise也好 变得更加简单

02:21.660 --> 02:24.060
那么这个语法就是我们这里可以学的

02:24.180 --> 02:26.700
这个语法可以真正的消除毁掉

02:26.700 --> 02:29.020
它不是说消除所有场景的毁掉

02:29.020 --> 02:31.500
指的是消除异部场景里边的毁掉

02:31.500 --> 02:36.140
它真的可以消除了 我们来看一下

02:36.140 --> 02:41.340
由Promise之后 异部的任务有了一种统一的处理方式

02:41.340 --> 02:44.340
那么ES官方就对它进一步进行的优化

02:44.340 --> 02:47.620
ES7 就是ES2016

02:47.620 --> 02:50.340
2016年出的 它就出了两个关键制

02:50.340 --> 02:54.740
一个是Essink 它的全称叫做Essincorice

02:54.740 --> 02:59.620
表示的是异部的Earweight 表示等待

02:59.620 --> 03:01.180
就出了这么两个关键制

03:01.180 --> 03:05.220
这两个关键制让我们可以更加优雅的来表达Promise

03:05.220 --> 03:07.380
给大家看一下吧 我们再分开学一下

03:07.380 --> 03:10.300
非常简单 你把Promise理解清楚了过后

03:10.300 --> 03:15.060
Essincorice和Earweight就并不复杂了

03:16.060 --> 03:20.180
好 第一个是Essinc 表示的是Essincorice

03:20.180 --> 03:24.340
它是用来干嘛的呢 它是用来修饰函数的

03:24.340 --> 03:28.020
就是它写的地方也不能乱写 也不能随便找个地方写

03:28.020 --> 03:31.860
它必须要标注在函数前边 比方说像这种场景

03:31.860 --> 03:34.140
你看 前边是用了一个Essinc 对吧

03:34.140 --> 03:36.340
当然我们也有的时候是一个匿名函数

03:36.340 --> 03:38.420
比方说我们是一个箭头函数

03:38.420 --> 03:40.460
那箭头函数可不可以用Essincorice可以

03:40.460 --> 03:41.860
标注在前面就可以了

03:41.860 --> 03:44.540
那么这就是一个异部的箭头函数

03:44.540 --> 03:47.540
比方说有的时候我们写一个就是函数表达式

03:47.580 --> 03:50.380
其实本质上跟箭头函数也是差不多的

03:50.380 --> 03:52.260
那么也可以标注在前面

03:52.260 --> 03:54.260
那有的时候我们写个立即执行函数了

03:54.260 --> 03:59.220
比方说像这种立即执行函数 对吧

03:59.220 --> 04:02.020
那么前边也可以标注一个Essincorice

04:02.020 --> 04:03.540
有的时候我们立即执行函数

04:03.540 --> 04:05.220
它不一定是普通函数形式

04:05.220 --> 04:06.860
它又可能是箭头函数

04:06.860 --> 04:08.940
箭头函数它本质上跟这个也有什么区别呢

04:08.940 --> 04:11.540
它除了Ritz指向有一些细节上的区别

04:11.540 --> 04:13.700
本质上它还是个函数表达式 对吧

04:13.700 --> 04:14.740
这也是一个函数

04:14.740 --> 04:17.460
那么前边也可以标记为Essincorice

04:17.500 --> 04:19.700
总之它用来修饰函数

04:19.700 --> 04:23.300
各种函数前边它都可以去标注这个Essincorice

04:24.180 --> 04:27.140
那么这个Essincorice标注到函数前边有什么作用呢

04:27.140 --> 04:31.420
它就表明了这个函数百分之一千亿万

04:31.420 --> 04:33.220
它一定用返回Promise

04:33.220 --> 04:34.540
我来看一下吧

04:34.540 --> 04:38.380
我们这里面去写一个解释

04:38.380 --> 04:40.220
那么这个解释我们就写个方法

04:40.220 --> 04:42.860
这个方法我啥都没有

04:42.860 --> 04:44.820
那如果说我啥都不写的话

04:44.820 --> 04:46.540
我们雕用这个方法返回的是啥

04:46.740 --> 04:48.820
它返回的那就是undefined 对吧

04:48.820 --> 04:50.500
因为它没有用Return

04:50.500 --> 04:51.900
这个没问题吧

04:51.900 --> 04:55.140
但是我只要在这个函数前边标记了Essincorice

04:55.140 --> 04:57.820
这个函数它一定返回Promise

04:58.580 --> 05:00.180
哪怕这个函数里面一行带法都没有

05:00.180 --> 05:01.460
它一定返回Promise

05:01.460 --> 05:02.980
你看是不是Promise

05:02.980 --> 05:04.380
对吧 它就这么简单

05:04.380 --> 05:07.020
它表明这个函数它一定返回Promise

05:07.020 --> 05:09.140
那么这个函数里边

05:09.140 --> 05:11.260
如果说你用了Return

05:12.300 --> 05:14.620
后面也跟了一个表达式或者值

05:14.740 --> 05:17.340
这个函数里边我们现在没有用Return 对吧

05:17.340 --> 05:18.980
没有Return就相当于是

05:18.980 --> 05:21.180
你就Return了一个undefined 对不对

05:21.180 --> 05:22.700
那么这个Return

05:22.700 --> 05:24.780
就是返回的东西变成了什么了

05:24.780 --> 05:26.300
如果说你没有标记这个Essincorice

05:26.300 --> 05:27.620
那你返回的是啥

05:27.620 --> 05:28.740
那就是啥

05:28.740 --> 05:30.500
但是你标记了这个Essincorice

05:30.500 --> 05:32.460
这个函数它的返回值

05:32.460 --> 05:36.660
表示的是Promise完成之后的数据

05:38.060 --> 05:40.740
这当土一定老在里边一定要记下来

05:40.740 --> 05:42.380
完成状态是不是有个相关数据

05:42.380 --> 05:44.140
失败状态是不是有个相关原因

05:44.700 --> 05:47.980
那么这个就相当于是完成之后的相关数据

05:48.700 --> 05:50.460
那么现在我们来看一下Promise是不是

05:51.140 --> 05:52.300
返回的是一个Promise

05:52.300 --> 05:53.980
它的数据就undefined

05:53.980 --> 05:55.700
当你不写的话跟写不写都是一样

05:56.460 --> 05:57.860
那如果说你返回一个123

05:57.860 --> 06:01.260
那么完成它的Promise的状态就是123

06:01.260 --> 06:02.300
简不简单

06:02.300 --> 06:03.460
特别简单 对吧

06:03.460 --> 06:04.140
那么这样子

06:05.140 --> 06:08.980
这个函数的代码就相当于是这样子写的

06:08.980 --> 06:10.340
一模一样的

06:10.340 --> 06:13.100
就相当于是你Return了一个NewPromise

06:13.140 --> 06:15.660
然后这里用了一个Resolve

06:15.660 --> 06:17.740
这个Resolve里边写了一个123

06:19.100 --> 06:21.900
下面的代码是不是要麻烦一些写起来

06:21.900 --> 06:22.060
对吧

06:22.060 --> 06:24.220
上面的代码是不是写起来要舒服一些

06:24.220 --> 06:24.980
要简单一些

06:25.660 --> 06:26.860
就能这么回事

06:26.860 --> 06:30.180
所以不用太过于纠结

06:30.180 --> 06:32.180
这个玩意其实挺简单的

06:32.180 --> 06:35.580
有些人觉得有些之前可能接触过这些关键字

06:35.580 --> 06:36.500
觉得它挺难吃

06:36.500 --> 06:38.420
因为你Promise没有了解清楚

06:38.420 --> 06:41.100
你Promise了解清楚就特别简单

06:41.140 --> 06:42.020
你看这个意思

06:42.020 --> 06:43.540
它其实就是一个语法堂

06:47.260 --> 06:48.060
语法堂

06:48.060 --> 06:48.940
怎么叫语法堂呢

06:48.940 --> 06:53.180
就是它并没有带来功能性的变化

06:53.180 --> 06:55.020
实质性质的变化并没有

06:55.020 --> 06:56.900
它其实利用以前的技术

06:56.900 --> 06:59.380
让你写起来更加舒服一点

06:59.380 --> 07:00.340
就像吃糖一样

07:00.340 --> 07:00.900
对吧

07:00.900 --> 07:02.380
吃糖没有什么营养

07:02.380 --> 07:03.900
但是能让你舒服

07:03.900 --> 07:05.140
就是这么一个东西

07:05.140 --> 07:06.580
语法堂

07:06.580 --> 07:09.940
那这就是这个Essink关键字的作用

07:09.980 --> 07:11.620
那里看我这里写了个方法

07:11.620 --> 07:12.540
调用这个方法之后

07:12.540 --> 07:13.580
这个方法返回的是什么

07:13.580 --> 07:14.900
返回的是个Promise

07:14.900 --> 07:16.860
那你要怎么再用这个方法呢

07:16.860 --> 07:17.740
看你怎么用

07:17.740 --> 07:20.620
就是相当于是你怎么去用Promise了

07:20.620 --> 07:22.180
你调用这个方法是不是可以用Zin

07:23.580 --> 07:24.500
是不是可以用Zin

07:25.340 --> 07:26.300
用Data

07:27.900 --> 07:28.820
输出Data

07:28.820 --> 07:30.660
是不是输出的就是E23

07:32.970 --> 07:34.050
你看是不是输出E23

07:34.050 --> 07:35.170
它反过来就是Promise

07:35.170 --> 07:35.970
Promise该怎么用

07:35.970 --> 07:36.970
它就这么用

07:36.970 --> 07:37.930
就这么简单

07:39.290 --> 07:40.130
那你看

07:40.170 --> 07:42.530
那如果说这个方法里边

07:42.530 --> 07:44.330
它又返回了一个Promise呢

07:44.970 --> 07:46.970
如果说这里边返回的是

07:47.810 --> 07:49.090
表面我用了一个Promise

07:52.020 --> 07:52.700
Visual

07:52.700 --> 07:54.260
我这里SetTimeout

07:56.180 --> 07:57.300
一秒钟之后

07:57.300 --> 07:57.980
Visual

07:58.780 --> 07:59.380
E23

07:59.860 --> 08:00.700
那里看

08:00.700 --> 08:02.780
这个方法它返回的是一个Promise

08:02.780 --> 08:03.220
对吧

08:03.820 --> 08:05.300
它又标击为Essink

08:06.100 --> 08:07.980
按照逻辑来讲的话

08:08.500 --> 08:09.700
它应该是怎么回事呢

08:09.700 --> 08:11.020
应该是这个方法

08:11.020 --> 08:12.860
它返回了一个Promise

08:13.460 --> 08:14.460
然后呢

08:14.460 --> 08:16.060
这个Promise的数据呢

08:16.060 --> 08:17.140
又是一个Promise

08:17.140 --> 08:17.340
对吧

08:17.340 --> 08:18.820
因为它ReturnedPromise

08:18.820 --> 08:19.780
Returned是啥

08:19.780 --> 08:21.620
那么这个Promise的数据就是啥

08:21.620 --> 08:22.420
那它的数据呢

08:22.420 --> 08:24.140
就应该也是一个Promise

08:24.140 --> 08:25.660
按你说应该是这个逻辑

08:25.660 --> 08:26.860
实际上不是的

08:26.860 --> 08:27.540
像这种情况

08:27.540 --> 08:29.340
还会给你进行一个特殊处理

08:29.340 --> 08:31.820
如果说你这个函数返回的是一个Promise

08:31.820 --> 08:34.020
那么就相当于是你没有标击这种

08:34.580 --> 08:35.500
你看了吧

08:35.500 --> 08:37.380
你标击跟每个标击是一样的

08:37.700 --> 08:39.380
因为标击这个返回的就是Promise

08:39.380 --> 08:39.780
对吧

08:39.820 --> 08:41.220
你没有标击的话

08:41.220 --> 08:42.420
返回来还是Promise

08:42.980 --> 08:45.060
所以说这个相当于是你没有标击

08:45.060 --> 08:46.740
但是你标击上也没事

08:47.180 --> 08:47.860
标击过后了

08:47.860 --> 08:49.260
它其实就是这个Promise

08:49.260 --> 08:49.860
拿到的

08:50.460 --> 08:50.860
因此呢

08:50.860 --> 08:52.260
我们这里调了这个函数呢

08:52.260 --> 08:53.460
Z

08:53.460 --> 08:55.260
那么它一秒钟之后

08:55.260 --> 08:57.780
它就会输出123

08:58.140 --> 08:58.340
对吧

08:58.340 --> 08:59.420
一秒钟之后完成吧

08:59.420 --> 09:00.900
完成之后它就预讯这个函数

09:00.900 --> 09:01.660
输出123

09:01.940 --> 09:03.020
那道理是一样

09:04.140 --> 09:05.700
它就相当于没有标击

09:05.700 --> 09:06.980
就这么一种情况

09:06.980 --> 09:08.180
那我这里再解释

09:08.180 --> 09:09.060
更加准确一点

09:09.060 --> 09:09.700
那就是说

09:09.700 --> 09:11.340
如果说你返回的是一个Promise

09:11.340 --> 09:12.980
你看这个返回的是不是Promise

09:12.980 --> 09:16.100
那么这个函数得到了Promise

09:16.100 --> 09:18.500
它的状态和数据跟它保持一致

09:18.740 --> 09:19.900
其实你这样理解

09:19.900 --> 09:21.860
相当于是你没有写这个二思绪

09:22.740 --> 09:22.980
好

09:22.980 --> 09:24.780
这是关于这一点

09:24.780 --> 09:25.860
一个小的细节

09:25.860 --> 09:28.020
另外如果说你这个函数

09:28.020 --> 09:29.500
执行过程中爆出了

09:29.740 --> 09:30.940
那比方说我这里

09:30.940 --> 09:34.060
我这个势力里边是直接抛了一个错误

09:34.260 --> 09:35.860
那有可能我不是抛了错误

09:35.860 --> 09:37.300
是直接本身代码爆出

09:37.340 --> 09:39.540
比方说我这里写了一个数据

09:39.540 --> 09:42.100
然后我去雕用这个数据的

09:42.700 --> 09:43.740
偷师军方法

09:46.380 --> 09:48.900
拉我是不能没有这个偷师军方法的

09:48.900 --> 09:50.380
所以说我运行这个函数的时候

09:50.580 --> 09:51.900
我给它注册两个毁掉

09:51.900 --> 09:53.500
一个是成功之后的毁掉

09:53.500 --> 09:55.140
一个是失败之后的毁掉

09:55.260 --> 09:57.340
成功的时候我反而回123

09:57.620 --> 09:58.660
失败的时候

10:00.020 --> 10:01.260
我输出这个错误

10:01.940 --> 10:03.140
那么你看看它看一下

10:03.140 --> 10:04.420
它会运行哪个毁掉的

10:04.420 --> 10:06.260
它解释出运行失败的一个毁掉

10:06.740 --> 10:09.540
它这个函数执行过程中如果说爆了错

10:09.540 --> 10:10.580
那么相当于是

10:10.580 --> 10:12.500
因为这个函数返回的一定是Promise

10:12.620 --> 10:13.140
对吧

10:13.580 --> 10:15.980
那么就相当于是个Promise怎么样

10:15.980 --> 10:16.820
失败了

10:17.620 --> 10:18.500
好我们来看一下

10:19.420 --> 10:20.580
是不是预讯到这个

10:21.060 --> 10:22.940
那么如果我们再看得更加清楚一点

10:22.940 --> 10:25.300
就是我们把输出一下M函数的返回结果

10:25.500 --> 10:26.540
你看返回的是哪

10:26.700 --> 10:28.340
返回的是一个Promise

10:28.340 --> 10:29.860
这个Promise是rejected

10:29.940 --> 10:30.820
表示失败了

10:31.260 --> 10:32.820
那么后边是一个失败的

10:33.380 --> 10:34.820
失败的原因

10:34.820 --> 10:35.980
就是抛出这个错误

10:36.940 --> 10:37.420
对吧

10:37.620 --> 10:39.340
那么这就是这种场景

10:39.340 --> 10:40.980
它总之这个函数返回的是Promise

10:40.980 --> 10:41.580
要么成功

10:41.580 --> 10:42.900
成功就是正常执行完

10:42.900 --> 10:45.620
然后return的结果就是成功之后的数据

10:46.020 --> 10:47.500
那么还用就是失败

10:47.500 --> 10:48.180
失败的话

10:48.180 --> 10:51.300
那就是它中间如果说爆了错

10:51.300 --> 10:51.980
它就失败了

10:52.580 --> 10:53.980
这是个Ersync关键字

10:57.290 --> 10:58.770
然后下面这个Erwit

10:59.330 --> 11:00.690
Erwit什么意思呢

11:00.690 --> 11:04.370
它表示等待某一个Promise完成

11:04.850 --> 11:06.930
注意这个Erwit关键字

11:06.970 --> 11:09.170
它必须要写到函数里边

11:09.370 --> 11:10.610
你说你不能这样子写

11:10.610 --> 11:11.530
然后这个

11:11.530 --> 11:12.530
这是一个Promise

11:12.530 --> 11:12.770
对吧

11:12.770 --> 11:13.970
返回了一个Promise

11:14.170 --> 11:15.850
我这里就这样子写

11:17.210 --> 11:18.690
那么我们调用这个函数

11:20.250 --> 11:22.890
我们在前边你是不能这样子写的

11:24.090 --> 11:24.530
为什么

11:24.530 --> 11:25.850
因为Erwit这个关键字

11:25.850 --> 11:26.930
它这样写要爆错的

11:26.930 --> 11:27.410
你看

11:28.810 --> 11:30.370
告诉你语法错误

11:30.370 --> 11:31.890
你看这个错误是不是语法错误

11:31.930 --> 11:32.410
对吧

11:32.690 --> 11:33.490
syntext

11:34.210 --> 11:37.530
它说Erwit is only valid in Ersync function

11:37.730 --> 11:38.570
它表示这意思

11:38.570 --> 11:40.970
表示Erwit必须要在一个函数里边

11:40.970 --> 11:43.370
而且这个函数还必须要是Ersync的

11:43.370 --> 11:44.850
表计为Ersync的函数

11:46.050 --> 11:47.490
也就是说这个代码

11:47.490 --> 11:48.850
如果说你要运行这个代码

11:48.850 --> 11:51.210
你就必须要写到一个函数里边

11:54.970 --> 11:56.410
必须要写到一个函数里边

11:56.410 --> 11:59.170
将来我可能过了一两年之后

11:59.170 --> 12:00.290
现在正在讨论

12:00.290 --> 12:02.450
要不要把这个Erwit升到紧急代码

12:02.450 --> 12:04.050
就不在函数里边也可以用

12:04.370 --> 12:05.690
当然大家都希望这样做

12:05.690 --> 12:08.730
但是目前因为一些细节上的原因

12:09.250 --> 12:10.370
这样做还有一点冒险

12:10.370 --> 12:12.450
所以说目前还正在讨论阶段

12:12.450 --> 12:13.370
可能过了一两年

12:13.370 --> 12:14.610
它就可以的这样子写

12:14.610 --> 12:15.490
现在还不行

12:16.090 --> 12:17.450
必须要放到函数里边

12:17.450 --> 12:20.730
而且这个函数还必须要标记为Ersync

12:21.410 --> 12:22.370
就这么个意思

12:23.170 --> 12:25.250
那么现在我们去调用这个tese函数

12:25.690 --> 12:27.010
那么首先你看这个tese函数

12:27.010 --> 12:27.930
标记了 Ersync过了

12:27.930 --> 12:29.330
它是不是也返回Programmage

12:29.570 --> 12:30.130
对吧

12:31.170 --> 12:33.730
那么这个函数里边我们可以等待

12:34.770 --> 12:36.690
这个Promage

12:37.690 --> 12:38.290
明白了意思吗

12:38.290 --> 12:39.490
这个Erwit什么意思

12:39.490 --> 12:43.250
它表示的是等待某一个Promage完成

12:43.250 --> 12:45.890
那你看m这个函数返回的是不是Promage

12:46.370 --> 12:46.930
对吧

12:47.570 --> 12:50.690
Promage完成之后整个这个表达是

12:51.090 --> 12:52.450
它会得到一个什么呢

12:53.170 --> 12:55.090
它会得到一个数据

12:55.370 --> 12:57.090
当你要接受的话

12:57.090 --> 12:57.690
你就可以接受

12:57.690 --> 12:59.050
不需要的话就不需要

12:59.970 --> 13:01.050
这个数据是什么

13:01.050 --> 13:03.490
就是这个Promage完成后的结果

13:04.770 --> 13:05.530
明白了意思吧

13:05.850 --> 13:07.050
好比方说我这样子写

13:07.290 --> 13:09.850
比如说我写个要

13:10.290 --> 13:10.850
要要

13:11.530 --> 13:12.770
这是不是一个Promage

13:13.770 --> 13:15.050
那么这个Erwit什么意思

13:15.050 --> 13:16.650
等待这个Promage完成

13:16.650 --> 13:17.890
关键什么时候完成

13:17.890 --> 13:19.170
立即完成就完成

13:19.610 --> 13:20.770
离一连之后完成

13:20.770 --> 13:21.650
那我也得等

13:21.850 --> 13:22.970
反正等待完成

13:23.610 --> 13:25.250
等待完成过后

13:26.050 --> 13:29.570
这个整个表达是返回的是完成之后的数据

13:29.570 --> 13:31.090
你完成之后的数据是要要

13:31.090 --> 13:32.970
那么还要把要要复制给Data

13:33.530 --> 13:35.130
那么这里边我觉得舒服Data

13:35.410 --> 13:36.050
看一下吧

13:37.890 --> 13:38.410
好你看

13:38.530 --> 13:39.090
是要要

13:39.970 --> 13:40.450
对不对

13:40.970 --> 13:41.130
好

13:41.130 --> 13:42.810
那么我们就调用这个M函数了

13:43.330 --> 13:44.170
那大家想一下

13:44.370 --> 13:45.890
这个我们会输出什么样的结果

13:47.810 --> 13:48.530
那你去看吧

13:48.530 --> 13:51.210
M函数是不是返回的是什么Promage

13:52.170 --> 13:52.610
对不对

13:52.810 --> 13:54.050
那么这个Promage完成之后

13:54.050 --> 13:54.810
返回的是什么呢

13:55.050 --> 13:55.690
123

13:57.410 --> 13:57.890
对不对

13:58.370 --> 13:59.730
那么这里是不是得到123

14:00.730 --> 14:02.370
其实这个代码呢

14:02.370 --> 14:04.130
就相当于是怎么写的呢

14:04.930 --> 14:06.410
就相当于是这样子写的

14:08.370 --> 14:08.930
M

14:09.370 --> 14:09.890
Z

14:10.610 --> 14:12.810
等它完成之后输出它的纸

14:12.810 --> 14:14.210
是不是就这个代码

14:14.650 --> 14:15.010
对不对

14:15.010 --> 14:15.770
是不是就这个代码

14:15.770 --> 14:16.770
其实是一样的

14:17.650 --> 14:19.250
它只是用了而威者语法

14:19.250 --> 14:20.810
是不是把回调给我消除掉了

14:20.810 --> 14:22.530
你不用去用回调的模式了

14:22.890 --> 14:24.850
这样代码是不是看上去更加舒服一点

14:25.010 --> 14:26.690
等待这个Promage完成

14:26.690 --> 14:28.610
完成之后的数据放到边疆里边

14:30.010 --> 14:32.050
那么这样看上去舒服很多

14:33.210 --> 14:34.810
那么这样给大家解释一下

14:34.970 --> 14:36.210
为什么它要说

14:36.210 --> 14:38.610
这个而威者必须要放到而sync里边

14:38.810 --> 14:39.530
喊数里边

14:39.650 --> 14:40.890
为什么会这样子呢

14:41.490 --> 14:42.650
大家想一想这个道理

14:43.010 --> 14:45.050
其实这个跟现实上逻辑是挂钩的

14:45.850 --> 14:47.090
你有两个任务

14:48.370 --> 14:51.410
你要等待第一个任务完成之后

14:51.410 --> 14:53.610
我才能继续进行这个任务

14:54.090 --> 14:55.810
那么第一个任务是异步的

14:56.890 --> 14:58.090
第一个任务是一个Promage

14:58.090 --> 14:59.090
是一个异步任务

14:59.290 --> 15:00.170
那么我请问你

15:00.170 --> 15:01.530
它是不是一个异步任务

15:02.730 --> 15:03.850
是不是也是一个异步任务

15:03.850 --> 15:04.690
就跟我们之前说的

15:04.690 --> 15:06.210
学到的练习编程是一样的

15:06.850 --> 15:07.810
后续任务

15:07.810 --> 15:09.330
它也是一个异步任务

15:09.450 --> 15:11.330
我还要等待前一个任务完成之后

15:11.330 --> 15:12.650
我才能继续进行下去

15:12.770 --> 15:15.410
那我本身也需要等待一段时间

15:15.690 --> 15:16.210
对吧

15:16.690 --> 15:18.570
然后表达觉得实际的例子

15:18.570 --> 15:19.930
这里让我用一个Delay

15:25.830 --> 15:26.470
You're ready吗

15:26.470 --> 15:28.230
你给我传一个等待时间

15:28.350 --> 15:29.670
那么这边我就

15:29.950 --> 15:30.630
反回了什么

15:30.630 --> 15:32.190
反回一个Promage

15:32.190 --> 15:33.390
我用传统的方式

15:36.430 --> 15:37.550
这个函数要汇写

15:37.990 --> 15:38.950
Delay这个函数

15:39.350 --> 15:40.150
SetTimeout

15:41.630 --> 15:42.350
You're ready

15:42.350 --> 15:43.430
是不是之前写过的

15:43.830 --> 15:44.470
Ready go

15:45.990 --> 15:47.750
这个函数我就没有用二十个标记

15:47.750 --> 15:48.630
因为这个地方

15:48.750 --> 15:51.030
SetTimeout本身是毁掉模式

15:51.030 --> 15:51.670
这个玩意儿

15:51.670 --> 15:52.070
它

15:52.230 --> 15:54.110
那既然有了Promage过后

15:54.110 --> 15:55.310
SetTimeout像这种函数

15:55.310 --> 15:57.230
它为什么不可以做成Promage的这种形式

15:57.230 --> 15:58.750
还要使用毁掉了

15:58.750 --> 15:59.390
它不敢

15:59.390 --> 16:00.590
它不是说它不想

16:00.590 --> 16:01.470
它不敢

16:01.630 --> 16:03.350
因为它这一改的话

16:03.350 --> 16:05.150
以前的代码好多都要出问题

16:05.430 --> 16:07.870
它考虑以前的代码的兼容性

16:07.870 --> 16:08.670
它不敢改

16:08.990 --> 16:09.790
所以说这一块

16:10.310 --> 16:12.070
我们自己封装一下就完成了

16:12.070 --> 16:14.150
把SetTimeout封装成Delay函数

16:14.670 --> 16:15.430
延迟

16:16.030 --> 16:17.150
它反回来就是个Promage

16:17.750 --> 16:19.070
等待一段时间过后

16:19.070 --> 16:20.110
Promage完成了

16:21.390 --> 16:22.310
有了这个函数之后

16:22.310 --> 16:25.190
你看我们怎么来使用这个而位置来调用它

16:25.710 --> 16:26.470
我们可以等待

16:26.470 --> 16:28.590
比方说我们之前要咋写

16:28.590 --> 16:30.110
之前我们可能是这样子写的

16:30.830 --> 16:34.070
delay比方说等待一秒钟

16:34.470 --> 16:36.830
然后我们去执行某一个东西

16:40.030 --> 16:41.630
执行某个东西

16:42.990 --> 16:44.430
以前我们是不是得这样子写

16:45.910 --> 16:46.750
是不是有毁掉

16:48.150 --> 16:48.670
印象

16:50.510 --> 16:52.230
你看是不是等了一秒钟执行某个东西

16:52.230 --> 16:53.070
这个很简单吗

16:53.870 --> 16:55.030
可不可以这样做可以

16:55.030 --> 16:56.430
但是有了而位置之后

16:56.430 --> 16:58.910
就有了而sync和而位置关键值之后

16:58.910 --> 16:59.750
我们可以这样子

17:00.790 --> 17:02.150
我再新开一个任务

17:02.150 --> 17:05.070
这个任务就是等待一秒钟之后去执行这个东西

17:05.070 --> 17:06.830
就把这件事封装到函数里边

17:07.310 --> 17:09.150
我就delay用Delay

17:10.070 --> 17:10.950
等待一秒钟

17:11.870 --> 17:13.150
它反回来是不是一个Promage

17:13.990 --> 17:14.830
那我等待它

17:15.190 --> 17:15.950
等它完成

17:16.670 --> 17:18.910
这个时候我不需要完成之后的数据

17:18.910 --> 17:20.310
你看完成之后是没有数据的

17:20.830 --> 17:22.550
我这个地方完成之后没有数据

17:22.550 --> 17:23.110
我也不需要

17:23.110 --> 17:24.150
不需要的话就直接等

17:25.270 --> 17:26.190
等它完成

17:26.750 --> 17:29.070
完成之后我们再输出

17:29.830 --> 17:31.310
执行某个东西

17:31.990 --> 17:33.230
像我是完全一样的

17:33.230 --> 17:35.470
那里看上面代码看上去舒服了

17:35.470 --> 17:36.870
还是下面一个代码看上去舒服

17:37.390 --> 17:38.750
下面代码是没有回掉的

17:38.750 --> 17:39.550
说舒服很多

17:40.270 --> 17:42.550
但是唯一的美中部主的地方

17:42.550 --> 17:44.430
就是我们必须要把它放到一个函数里边

17:46.230 --> 17:48.430
因为我要去等待它完成

17:48.430 --> 17:49.910
那我本身也是个一部任务

17:49.910 --> 17:50.150
对吧

17:50.150 --> 17:51.150
这个逻辑是通的

17:51.790 --> 17:54.270
有的时候我们有的时候我觉得这个函数

17:54.910 --> 17:56.870
就是为了写一个而会设

17:56.870 --> 17:57.910
我什么称一个函数

17:57.950 --> 17:59.470
那有的时候我们可能会这样的写

17:59.470 --> 18:01.190
把它写成一个立即实行函数

18:05.590 --> 18:07.030
把它写成一个立即实行函数

18:09.860 --> 18:10.620
效果是一样的

18:12.950 --> 18:14.790
当然了你也可以使用箭头函数

18:18.250 --> 18:18.970
效果是一样的

18:20.330 --> 18:21.530
这就是而为者

18:23.290 --> 18:25.730
那么这是而为者的基本用法

18:27.810 --> 18:29.290
有一些细节给大家说一下

18:31.130 --> 18:33.650
而为者也可以等待其他数据

18:33.650 --> 18:35.290
比方说你等待的不是Promise

18:37.290 --> 18:38.850
那么这个就相当于是什么呢

18:38.850 --> 18:40.850
比方说你这里等待的是一

18:41.850 --> 18:43.210
比方说我这里举个例子

18:46.480 --> 18:47.120
数数data

18:47.640 --> 18:48.320
那么数数什么呢

18:48.320 --> 18:49.760
它数数肯定结果也是一

18:50.240 --> 18:52.200
这就代表就相当于是什么呢

18:52.200 --> 18:53.920
如果说你等待的不是Promise

18:54.880 --> 18:56.760
那么它会给你变成Promise

18:56.760 --> 18:57.360
它怎么变

18:57.800 --> 18:58.880
就是你这里不是Promise

18:58.880 --> 19:01.400
它就把你这里的表达是这个结果

19:01.400 --> 19:02.280
比方结果是一

19:02.720 --> 19:03.800
它就给你变成这个样子

19:06.560 --> 19:08.760
总之而为者等待的一定是Promise

19:08.760 --> 19:10.200
如果说你写的不是Promise

19:10.200 --> 19:11.320
它就变成这种格式

19:11.320 --> 19:12.280
把你写的东西放这

19:13.960 --> 19:15.400
所以说最终还是Promise

19:16.120 --> 19:16.800
这是一个细节

19:17.320 --> 19:18.600
另外一个细节的就是说

19:19.000 --> 19:20.480
这个Promise它不一定是成功

19:20.480 --> 19:21.440
有可能会失败

19:21.840 --> 19:23.480
那如果说它失败了

19:24.960 --> 19:26.640
我这就代码它就会爆出

19:27.560 --> 19:28.840
它就会抛出一个异常

19:29.920 --> 19:30.720
举个例子吧

19:30.720 --> 19:32.160
比方说我这里不一定是成功

19:32.160 --> 19:33.200
我又可能会失败

19:33.200 --> 19:34.600
那我就表达写失败

19:35.760 --> 19:36.720
那么这就代码了

19:36.720 --> 19:37.960
它就会得到一个异常

19:38.800 --> 19:39.320
一秒钟

19:39.320 --> 19:40.920
一秒钟之后它就会抛出一个异常

19:43.420 --> 19:44.740
你看是不是得到一个异常

19:44.940 --> 19:46.940
那么如果说你要处理失败的话

19:47.060 --> 19:48.180
以前得怎么写

19:48.180 --> 19:49.380
以前是不是得这样的写

19:49.860 --> 19:50.940
我订了

19:51.780 --> 19:54.420
然后成功之后干嘛

19:54.420 --> 19:56.140
我输出成功

19:56.380 --> 19:58.340
然后失败之后干嘛

19:58.740 --> 20:00.060
我输出失败原因

20:00.060 --> 20:01.540
或者是输出失败

20:02.060 --> 20:04.140
我以前是不是要用回调的解释代码

20:04.140 --> 20:05.580
那你看现在是怎么写法

20:05.580 --> 20:06.420
新的写法

20:06.740 --> 20:07.660
新的写法的话

20:07.660 --> 20:09.260
它有为它这里会抛出异常

20:09.260 --> 20:12.380
所以说我们可以利用那个基础部分学习的

20:12.380 --> 20:13.180
try catch

20:14.460 --> 20:15.700
这是成功的代码

20:15.860 --> 20:17.060
如果说执行过程中

20:17.060 --> 20:17.980
这句话爆错了

20:17.980 --> 20:18.820
是跑出了异常

20:18.820 --> 20:19.780
我们可以开启

20:19.780 --> 20:21.500
让它转而运行这里的代码

20:24.550 --> 20:25.830
这就是失败的原因

20:25.830 --> 20:27.150
你需要的话就用

20:27.350 --> 20:28.350
我这里不需要

20:28.350 --> 20:29.270
打赢失败

20:29.270 --> 20:30.750
这里直接打赢成功

20:34.470 --> 20:36.030
就写成这么一种格式

20:36.670 --> 20:37.470
你看上面的格式

20:37.470 --> 20:38.630
看上去是不是舒服很多

20:38.630 --> 20:39.630
没有回调嘛

20:39.910 --> 20:40.550
对不对

20:42.430 --> 20:43.070
失败

20:43.630 --> 20:45.910
反正这就是await它的处理方式

20:46.910 --> 20:48.270
这就是这里的内容

20:48.270 --> 20:49.790
其实内容不多

20:50.510 --> 20:51.590
就两个关键字

20:51.950 --> 20:54.070
它其实就是在promise基础上

20:54.350 --> 20:55.950
让你进一步代码写上去

20:55.950 --> 20:56.990
更加舒服一点

20:58.390 --> 20:59.590
现在我们回到

21:00.110 --> 21:01.670
最开始学习promise的问题

21:01.670 --> 21:02.750
又是邓哥的问题了

21:03.350 --> 21:04.870
好告诉大家邓哥呢

21:05.950 --> 21:06.990
你们小瞧他了

21:08.110 --> 21:10.070
他的女生可不止只有4个

21:10.150 --> 21:11.590
他的女生可能是40个

21:12.590 --> 21:13.950
可能是400个

21:15.750 --> 21:17.150
邓哥还是很厉害的人

21:17.710 --> 21:19.510
那么现在这种情况怎么办呢

21:19.990 --> 21:21.630
刚才之前4个女生

21:21.630 --> 21:23.030
我们都要写一大堆代码

21:23.230 --> 21:25.190
那40个是不是写的更多

21:26.190 --> 21:27.470
你看我们现在用这几个

21:27.470 --> 21:28.550
而圣河和卫州

21:28.670 --> 21:30.110
非常舒服的结局

21:31.150 --> 21:33.110
那么邓哥为了方便

21:33.110 --> 21:34.310
添写这个表白代码

21:34.310 --> 21:35.470
所以他决定能把这个

21:35.470 --> 21:36.630
40位女生的名字

21:36.630 --> 21:37.790
放到一个书楼里边

21:38.230 --> 21:39.470
叫做beauty girls

21:40.430 --> 21:40.990
美丽

21:40.990 --> 21:41.910
这边全是

21:42.550 --> 21:43.550
他的女生的名字

21:44.430 --> 21:45.550
用小板记一下

21:46.190 --> 21:46.950
然后呢

21:47.150 --> 21:49.110
他决定循环这个书楼

21:50.190 --> 21:51.270
一个一个表白

21:51.430 --> 21:52.750
失败了就表白下一个

21:52.750 --> 21:54.070
成功了就停止

21:54.470 --> 21:55.830
那么这个代码怎么写呢

21:56.070 --> 21:58.510
我把之前的代码给他从头写一遍

22:00.390 --> 22:01.110
好复制

22:01.790 --> 22:03.350
把这个代码写过来

22:03.510 --> 22:05.550
这就是一个最终完美的解决办法

22:06.230 --> 22:07.870
你看这个代码最终写出来

22:07.870 --> 22:08.670
就非常舒服了

22:08.790 --> 22:10.870
总之这是个女生的名字书

22:11.110 --> 22:11.990
全是字幕刷书书

22:11.990 --> 22:12.750
谁生存的

22:13.070 --> 22:13.870
好扔这

22:14.030 --> 22:15.390
然后这是我们之前的函书

22:15.390 --> 22:16.150
send message

22:16.750 --> 22:17.790
发送表白短信

22:18.430 --> 22:20.430
不便返回的是promise

22:20.430 --> 22:22.350
前面要不要比较标记而生

22:22.350 --> 22:22.870
可不用了

22:22.870 --> 22:24.270
因为他返回的就是promise

22:24.750 --> 22:25.790
以标记而生的目的

22:25.790 --> 22:27.110
不就是让他返回promise吗

22:27.470 --> 22:29.030
你这里返回的本身就promise

22:29.190 --> 22:29.830
所以说不用了

22:30.590 --> 22:32.910
好 接下来我们就接着之前的写

22:34.590 --> 22:35.470
那么现在怎么写

22:35.470 --> 22:37.670
如果说你用传统的那个promise写

22:37.670 --> 22:38.510
还是麻烦

22:38.670 --> 22:39.430
能不能写的

22:39.430 --> 22:40.910
其实可以写大家

22:41.350 --> 22:42.230
有兴趣的同学

22:42.230 --> 22:43.750
现在还可以想象怎么写

22:43.750 --> 22:45.270
还是有点麻烦的

22:45.790 --> 22:46.430
能写

22:46.430 --> 22:47.030
肯定是能写

22:47.030 --> 22:48.030
能用循环来写

22:48.430 --> 22:50.430
现在我们用而生可和而未成的话

22:50.430 --> 22:51.510
非常地舒服

22:52.310 --> 22:53.150
你看怎么写

22:53.150 --> 22:54.750
首先我写个立即指引函书

22:55.510 --> 22:56.870
这个函书肯定是一个

22:56.950 --> 22:58.390
异步函书而生可函书

22:58.750 --> 22:59.950
比如说我们说异步函书

22:59.950 --> 23:00.910
他指的是就是

23:01.150 --> 23:02.790
这个函书返回的是promise

23:03.550 --> 23:04.390
就是一个异步函书

23:04.390 --> 23:05.750
像这个玩意就是个异步函书

23:05.750 --> 23:06.070
对吧

23:06.070 --> 23:07.470
他不一定是标记的而生可

23:07.470 --> 23:08.630
他只要返回promise

23:09.390 --> 23:10.510
他就是个异步函书

23:11.230 --> 23:12.590
由于而生可标记之后

23:12.590 --> 23:13.870
他一定返回promise

23:13.870 --> 23:15.190
说而生可标记过后的函书

23:15.190 --> 23:16.150
一定是异步函书

23:17.430 --> 23:18.350
这么个逻辑

23:19.590 --> 23:20.990
为什么把他写成一个异步函书

23:20.990 --> 23:22.230
因为他里边要用而未成

23:22.750 --> 23:23.470
他说怎么写

23:24.910 --> 23:26.190
他不是有很多女生吗

23:27.110 --> 23:27.950
我就循环

23:28.430 --> 23:29.390
用for over循环

23:30.390 --> 23:33.830
循环每一个女生的名字

23:35.430 --> 23:36.150
beauty

23:36.990 --> 23:37.630
girls

23:41.580 --> 23:42.620
我们这里输出

23:43.300 --> 23:44.220
这些女生的名字

23:45.660 --> 23:47.700
你看是不是循环得到所有的女生名字了

23:48.700 --> 23:49.580
接下来

23:52.250 --> 23:55.010
在对每一个学生

23:55.010 --> 23:56.650
我们去send a message

23:56.930 --> 23:57.890
发送消息

23:58.650 --> 23:59.730
把名字传进去

24:00.250 --> 24:02.290
对每一个女生发送消息

24:03.090 --> 24:03.490
对吧

24:04.690 --> 24:06.530
那如果说你直接这样子写的话

24:06.530 --> 24:07.850
他就同时发送消息了

24:08.410 --> 24:10.170
第一次循环发送的消息

24:10.170 --> 24:10.890
他不会等的

24:10.890 --> 24:11.170
对吧

24:11.170 --> 24:12.050
不会等那个消息

24:12.730 --> 24:13.890
不会等这个任务完成

24:13.890 --> 24:15.370
他马上就运输下一个循环

24:15.370 --> 24:16.290
又发送了一个消息

24:16.810 --> 24:18.410
他不会等那个任务完成

24:18.850 --> 24:20.570
所以他瞬间就发送了很多消息

24:20.570 --> 24:21.010
对吧

24:21.010 --> 24:21.490
然后呢

24:22.130 --> 24:23.330
最终一起收到回复

24:24.290 --> 24:25.490
那这样子显然不合适

24:25.490 --> 24:26.690
我要一个一个的话

24:26.690 --> 24:27.370
那怎么办

24:27.370 --> 24:29.890
我就可以在for循环里边去写await

24:31.090 --> 24:32.210
每一次循环

24:32.210 --> 24:33.890
你别着急进行下一支循环

24:33.890 --> 24:35.050
你先把这个代码等了

24:35.050 --> 24:35.810
等一下再说

24:36.370 --> 24:37.170
等他什么了

24:37.170 --> 24:39.290
等他那个promise完成

24:39.290 --> 24:40.250
这是不是promise

24:40.930 --> 24:41.930
完成之后

24:41.930 --> 24:43.090
之前是怎么做的

24:43.330 --> 24:44.050
用Zing对吧

24:44.050 --> 24:45.010
现在不用认了

24:45.570 --> 24:46.690
完成之后了

24:46.690 --> 24:49.610
他会返回一个完成之后的数据

24:50.570 --> 24:52.530
完成之后不是有数据吗

24:52.530 --> 24:53.170
那这个数据

24:53.170 --> 24:54.530
我们按照我们之前的写法

24:54.530 --> 24:55.810
完成之后的数据是什么

24:55.810 --> 24:57.730
一个支付串表示女生的回复

24:57.730 --> 24:58.410
失败之后了

24:58.410 --> 25:00.330
也会有个支付串表示女生的回复

25:00.330 --> 25:00.890
好

25:00.890 --> 25:03.610
完成之后我们会拿到一个回复

25:05.090 --> 25:06.130
我们就输出

25:12.700 --> 25:13.380
对吧

25:13.380 --> 25:15.060
那么再输出一个

25:15.220 --> 25:16.220
要办成功

25:17.820 --> 25:19.700
现在我们来运行看一下

25:21.500 --> 25:23.620
第一个你看是不是一个一个进行

25:23.620 --> 25:24.820
一个一个进行

25:25.820 --> 25:27.900
那为什么进行一个没有进行到下一个

25:27.900 --> 25:29.700
是因为第一个就失败了

25:29.700 --> 25:30.660
失败会怎么样

25:30.660 --> 25:31.500
之前说了

25:31.900 --> 25:33.180
而威者等待的时候

25:33.180 --> 25:34.500
如果说发生了失败

25:35.140 --> 25:36.940
他就会抛出一个异常

25:37.140 --> 25:38.500
这就代码就爆错了

25:38.500 --> 25:39.100
爆错的话

25:39.100 --> 25:41.380
等个代码是不是不会融入后织

25:41.380 --> 25:41.940
行吗

25:42.540 --> 25:42.820
好

25:42.820 --> 25:45.060
那么如果说我们这里是不是要去处理

25:45.060 --> 25:45.740
这个错误

25:45.780 --> 25:47.020
我们可以用串开

25:49.340 --> 25:51.180
上边是没有爆错的情况

25:51.180 --> 25:52.340
没有爆错是不是成功了

25:52.340 --> 25:54.300
成功之后拿到成功的消息

25:54.780 --> 25:55.780
输出成功的消息

25:55.780 --> 25:56.740
让表白成功

25:57.580 --> 25:58.100
好

25:58.100 --> 26:00.780
如果说失败了

26:00.940 --> 26:01.380
失败了

26:01.380 --> 26:03.300
他是不是会给我一个失败的原因

26:03.300 --> 26:04.660
失败的原因是什么了

26:04.660 --> 26:06.860
是不是也是一个回复支付串

26:08.220 --> 26:08.500
对吧

26:08.500 --> 26:09.300
那么我们这里可以说

26:09.300 --> 26:11.180
可以接也可以接受到一个Replay

26:12.060 --> 26:12.740
回复

26:12.980 --> 26:14.300
那么输出一下回复

26:14.860 --> 26:15.940
这里我们输出一下

26:16.420 --> 26:17.660
表白失败

26:18.780 --> 26:18.940
好

26:18.940 --> 26:20.180
我们看一下一个

26:21.020 --> 26:21.660
第一个

26:22.300 --> 26:23.180
这个表白失败

26:23.180 --> 26:24.500
第二个也是表白失败

26:24.500 --> 26:25.780
第三个表白失败

26:25.780 --> 26:27.420
就是一直往后都表白失败

26:28.100 --> 26:28.540
对吧

26:28.540 --> 26:29.180
表白失败

26:29.180 --> 26:29.420
好

26:29.420 --> 26:30.420
这表白成功了

26:30.420 --> 26:31.540
这里说有还有bug

26:31.540 --> 26:32.260
什么bug

26:32.260 --> 26:33.620
就表白成功之后

26:33.620 --> 26:36.300
我们不需要进一步表白了

26:36.300 --> 26:37.580
不需要继续表白了

26:38.260 --> 26:39.060
那怎么办

26:39.340 --> 26:40.020
很简单吧

26:40.020 --> 26:40.940
这里是循环

26:40.940 --> 26:41.500
对吧

26:41.620 --> 26:43.740
表白成功之后退出循环

26:44.460 --> 26:45.780
好

26:45.780 --> 26:46.740
咱们就再看一下

26:46.740 --> 26:47.300
运行

26:51.260 --> 26:53.220
就不再往后面继续表白了

26:53.220 --> 26:53.860
失败

26:53.860 --> 26:54.580
失败了

26:54.580 --> 26:55.460
过后就继续循环

26:55.460 --> 26:55.900
对吧

26:56.740 --> 26:57.260
失败

26:58.180 --> 26:58.700
失败

26:59.940 --> 27:00.460
表白成功

27:00.460 --> 27:01.380
是不是不再继续了

27:02.260 --> 27:04.420
这个代码看上去是不是舒服太多了

27:05.020 --> 27:06.140
它没有回掉

27:06.140 --> 27:07.780
整个过程一看有回掉吗

27:07.780 --> 27:08.540
没有回掉

27:08.820 --> 27:09.700
它变成了一种

27:10.580 --> 27:12.700
注意传统的那种代码输解方式

27:12.700 --> 27:13.740
非常的清晰

27:14.700 --> 27:17.340
要循环所有的女孩名字

27:18.420 --> 27:19.660
一次发送短信

27:19.660 --> 27:20.900
每一次发送点要等

27:20.900 --> 27:21.420
还不着急

27:21.420 --> 27:22.220
进行下一次循环

27:22.220 --> 27:22.900
等一下

27:23.380 --> 27:24.060
但表白成功了

27:24.060 --> 27:24.380
也失败

27:24.380 --> 27:25.300
成功了过后

27:25.300 --> 27:26.660
我就输出成功的水

27:26.660 --> 27:27.260
回复消息

27:27.260 --> 27:27.820
然后输出

27:27.820 --> 27:29.020
然后结束循环

27:29.020 --> 27:29.820
不再继续了

27:30.260 --> 27:30.940
失败的

27:30.940 --> 27:31.740
如果说失败了

27:31.860 --> 27:33.460
转而进入失败的处理

27:33.460 --> 27:34.700
处理过后继续循环

27:35.500 --> 27:35.980
对吧

27:35.980 --> 27:38.460
这个代码逻辑很容易理解

27:39.900 --> 27:40.100
好

27:40.100 --> 27:42.500
那如果说我们如果说全部都失败

27:42.780 --> 27:44.180
全部都失败过后

27:44.180 --> 27:45.780
那我们可能还要输出一句

27:46.540 --> 27:47.380
总结性的话

27:47.380 --> 27:48.220
那这个又怎么办

27:48.220 --> 27:49.220
那这个处理的方式

27:49.220 --> 27:49.980
跟过去

27:51.020 --> 27:52.180
解释基础里边

27:52.340 --> 27:53.580
相当于是一个查罩问题

27:53.580 --> 27:53.820
对吧

27:53.820 --> 27:56.900
循环查罩每一个女孩的回复结果

27:57.060 --> 27:57.460
看一下

27:58.340 --> 27:59.060
如果说

28:00.020 --> 28:01.220
只要有一个成功了

28:01.220 --> 28:02.020
那就成功了

28:03.740 --> 28:04.420
所有的失败

28:04.420 --> 28:05.020
那就失败了

28:05.020 --> 28:06.220
所以我们就用一个flag

28:06.340 --> 28:07.620
用一个变量的玩意

28:07.820 --> 28:08.500
就是

28:10.580 --> 28:11.300
success

28:11.300 --> 28:12.180
是不是成功了

28:12.220 --> 28:13.340
默认是没有成功

28:13.780 --> 28:15.060
只要有一个成功了

28:15.060 --> 28:16.020
你就把它设置为

28:16.020 --> 28:16.500
q

28:17.140 --> 28:17.540
对不对

28:18.180 --> 28:20.300
那如果说循环结束过后都没有成功

28:20.900 --> 28:21.740
就一直是失败

28:21.740 --> 28:22.420
一直是失败

28:22.420 --> 28:23.740
那么这个代码就不会运行

28:24.100 --> 28:26.300
这是非常非常基础的这个变成问题

28:27.140 --> 28:28.220
相当于是个查罩问题

28:29.100 --> 28:30.260
要先把它设置为force

28:30.580 --> 28:31.860
成功之后就把它设为q

28:32.380 --> 28:33.420
如果都没有成功了

28:33.420 --> 28:34.660
最终还是不还是force

28:34.660 --> 28:35.940
所以说除了循环之后

28:36.460 --> 28:37.060
除了循环之后

28:37.060 --> 28:38.180
我们判断一下这个变量

28:38.500 --> 28:40.060
如果说这个变量还是force

28:40.660 --> 28:41.820
还是没有成功

28:42.580 --> 28:43.340
这感叹号啥意思

28:43.340 --> 28:43.780
感叹号

28:43.780 --> 28:45.140
感叹号就是没有的意思

28:45.980 --> 28:47.060
不是没有

28:47.060 --> 28:48.420
就这个感叹号

28:48.420 --> 28:49.220
否定的意思

28:49.940 --> 28:51.500
但是不说还是没有成功

28:51.500 --> 28:52.620
他们最后就输出

28:52.980 --> 28:53.460
邓哥

28:54.500 --> 28:54.980
朱丁

28:55.380 --> 28:55.860
朱丁

28:56.100 --> 28:56.540
什么意思

28:56.540 --> 28:57.620
十个都不行

28:57.620 --> 28:58.300
那就没办法

29:00.410 --> 29:01.970
那我们就不用一个个等了

29:01.970 --> 29:02.490
就成功了

29:02.490 --> 29:03.770
那这句话是没有输出

29:04.770 --> 29:05.810
我们这里也停止

29:06.690 --> 29:08.370
我们把名字改少一点吧

29:09.050 --> 29:10.850
就两个吧

29:14.820 --> 29:15.300
再运行

29:18.510 --> 29:19.470
这里是不是输出了

29:20.310 --> 29:21.630
你看像这个代码

29:21.630 --> 29:23.750
看上去有清爽很多

29:23.750 --> 29:25.510
整个过程没有毁掉

29:25.790 --> 29:27.830
这就是而sync和而未成的

29:27.830 --> 29:28.670
给我们开发

29:29.230 --> 29:30.430
Promise的异部长运

29:30.430 --> 29:31.830
带来了一些好处

29:33.190 --> 29:34.070
那么整个一步

29:34.070 --> 29:35.230
我们就学习完了

29:35.230 --> 29:36.910
然后最后我们还有一节课

29:36.910 --> 29:38.790
就专门来讲这一块的面试题

29:40.270 --> 29:41.270
我们先来做一下

29:41.270 --> 29:42.750
本节课的练习题

29:44.070 --> 29:45.430
练习题有两道题

29:46.350 --> 29:46.950
第一道题

29:47.710 --> 29:48.510
他告诉你

29:48.870 --> 29:50.430
有一个函数已经给你写好了

29:50.430 --> 29:51.430
这个函数里边咋写的

29:51.430 --> 29:52.390
你现在不用管

29:52.670 --> 29:54.990
因为这是你们后边课程要学的

29:54.990 --> 29:56.390
现在还有一点超纲

29:56.390 --> 29:57.950
但是这个函数已经写好了

29:57.950 --> 29:58.950
注释也可以打好了

29:58.950 --> 29:59.990
你要知道怎么去用

30:01.110 --> 30:02.070
这个函数

30:02.070 --> 30:05.110
它是远程获取王者荣耀

30:05.110 --> 30:06.590
所有的英雄数据

30:06.590 --> 30:07.550
你要知道它怎么用

30:09.110 --> 30:10.590
看一下这个函数标记的是啥

30:11.510 --> 30:12.750
标记的是不是而sync

30:14.230 --> 30:15.750
那么这个函数返回什么类型

30:17.910 --> 30:18.670
返回什么类型

30:19.190 --> 30:21.230
返回了它一定是promise

30:22.230 --> 30:23.590
只要你看到一个函数标记

30:23.590 --> 30:24.030
要sync

30:24.030 --> 30:25.910
看都不用去看它有函数里边的东西

30:25.910 --> 30:27.390
它返回了一定是promise

30:28.150 --> 30:28.950
一个异部人物

30:29.950 --> 30:30.950
以来调问这个函数过后

30:30.950 --> 30:31.670
它返回了啥

30:31.670 --> 30:32.390
返回了promise

30:32.390 --> 30:33.470
那是你不可以用zin

30:34.190 --> 30:35.950
成功之后是不是可以拿到一个东西

30:36.470 --> 30:37.710
拿到一个相关的数据

30:37.710 --> 30:37.950
对吧

30:37.950 --> 30:38.910
我们输出一下数据

30:38.910 --> 30:39.550
来看一下

30:39.550 --> 30:41.150
有成功之后这个数据是啥

30:42.150 --> 30:42.830
我们运行

30:42.830 --> 30:43.310
看一下吧

30:44.190 --> 30:45.150
OK, we did level 3

30:50.980 --> 30:52.420
是不是得到一个数据

30:53.420 --> 30:53.660
对吧

30:53.660 --> 30:54.820
成功之后得到一个数据

30:54.820 --> 30:55.340
这个数据

30:56.340 --> 30:58.100
是所有的王者荣耀的英雄

30:59.220 --> 31:00.420
每个英雄是一个对象

31:01.620 --> 31:03.460
那是不是你后面可以接着处理的

31:03.820 --> 31:04.140
对吧

31:04.740 --> 31:06.380
当然你除了用这种方式

31:06.380 --> 31:07.940
是不是还可以用我们自己和学习的

31:08.900 --> 31:10.660
sync的方式

31:11.540 --> 31:12.740
写个立即字印函数吧

31:13.940 --> 31:14.860
我们调问这个方法

31:14.860 --> 31:15.820
它返回了promise

31:15.820 --> 31:17.660
promise是可以等待的位置

31:17.660 --> 31:18.220
等待它

31:19.220 --> 31:20.860
等待它完了过后

31:20.860 --> 31:24.020
成功之后是不是可能拿到成功之后的数据

31:24.660 --> 31:25.940
如果说你要处理失败的话

31:25.940 --> 31:27.060
你就用拆开

31:27.660 --> 31:28.940
这里不需要处理失败

31:28.940 --> 31:30.540
让我们这里刷新一下

31:31.180 --> 31:32.500
说还是可以拿到那个数据

31:32.500 --> 31:33.100
看到没

31:33.820 --> 31:35.660
那么下面这种解法

31:35.660 --> 31:37.540
它就没有那个zint里面的回调

31:37.540 --> 31:38.420
其实这种解法

31:38.420 --> 31:39.780
它也是一个语法堂

31:39.780 --> 31:41.380
它最终还是Killings用的是zint

31:42.900 --> 31:44.740
就写起来我们也要写的舒服一点

31:45.660 --> 31:46.900
我们这里输出了

31:46.900 --> 31:48.100
得到所有的英雄数据了

31:48.140 --> 31:49.580
那么我借的我们的要求是

31:50.420 --> 31:52.260
把它显示到这个UL里边

31:52.700 --> 31:53.820
我们拿到这个UL

31:57.300 --> 31:57.940
Documents

31:58.740 --> 31:59.900
Killings by ID

32:00.820 --> 32:01.500
Your list

32:03.180 --> 32:04.260
好 我们这里要做啥

32:04.260 --> 32:05.300
哎呀 老问题了

32:06.300 --> 32:08.540
我要生成 每个英雄生成一个Li

32:09.020 --> 32:10.540
这个英雄是一个数组吧

32:11.420 --> 32:11.980
对不对

32:12.300 --> 32:13.620
每个英雄是一个对啥

32:13.620 --> 32:14.580
是一个对象吧

32:15.100 --> 32:15.780
这个对象

32:16.420 --> 32:17.980
那我们每个英雄把对

32:17.980 --> 32:19.820
把每个英雄的对象变成啥

32:20.260 --> 32:21.540
变成一个Li

32:23.060 --> 32:24.060
不就做这个事吗

32:25.060 --> 32:26.260
Li里边的内容呢

32:26.260 --> 32:28.460
我只需要拼接英雄的名字

32:28.460 --> 32:29.340
Dinjal-Clinic

32:30.620 --> 32:31.740
做过很多次了对吧

32:31.740 --> 32:33.060
就不再反复了说了

32:33.340 --> 32:34.940
于是呢会拿到一个新数组

32:35.140 --> 32:36.420
这个新数组的每一项呢

32:36.420 --> 32:37.660
是一个Li元数

32:44.810 --> 32:45.330
刷刷

32:45.730 --> 32:46.970
它说Documents

32:47.770 --> 32:48.330
Get

32:48.330 --> 32:49.170
哦 这写错了

32:50.770 --> 32:51.210
相信

32:53.580 --> 32:56.420
GetElement by ID

32:56.780 --> 32:57.860
哪里写的有问题

32:57.860 --> 32:59.420
哦 这里没有写分

33:02.130 --> 33:04.050
你看是不是拿到一个新的数组

33:04.330 --> 33:05.370
这个新的数组

33:05.370 --> 33:07.930
把每一个英雄对象变成一个Li支付串

33:08.250 --> 33:09.650
然后呢我们接下来用什么呢

33:09.650 --> 33:11.050
用交易把这个数

33:11.250 --> 33:12.450
把这个数组拼印一下

33:13.930 --> 33:14.330
相信

33:14.330 --> 33:16.130
所以拿到这么一个支付串了

33:16.130 --> 33:18.330
把这个支付串使用Inner

33:18.650 --> 33:19.330
AT秒

33:19.850 --> 33:20.650
扶持过去

33:21.050 --> 33:21.730
写完了

33:22.730 --> 33:23.250
相信

33:24.090 --> 33:25.290
就拿到所有的英雄了

33:25.730 --> 33:26.130
对

33:26.570 --> 33:28.570
好 这是第一道题

33:29.210 --> 33:29.890
大家可以问

33:29.890 --> 33:31.610
但是听着每一道题有讲解之前

33:31.610 --> 33:32.810
你们可以尝试做一下

33:34.210 --> 33:35.090
好 第二题

33:38.090 --> 33:38.810
第二题呢

33:38.810 --> 33:39.970
第一个问题

33:39.970 --> 33:41.170
让你完成D内函数

33:41.170 --> 33:42.650
这个函数是我们之前做过的

33:42.850 --> 33:44.050
而且我们刚刚才写过的

33:44.130 --> 33:44.690
你们自己写

33:44.850 --> 33:45.570
我这里不讲

33:48.020 --> 33:49.380
直接扛屁过来了

33:49.540 --> 33:50.500
这个没什么好说的

33:52.710 --> 33:53.590
这个函数要回血

33:53.910 --> 33:56.670
其实这个函数就是封装这些摊帽子

33:56.830 --> 33:58.070
而这些摊帽子这种形式呢

33:58.070 --> 33:59.750
变成Promise这种形式

34:00.230 --> 34:01.630
这个函数等待一段时间

34:01.630 --> 34:02.590
还返回一个Promise

34:02.950 --> 34:05.110
之前的是Ctm是等待一段时间

34:05.110 --> 34:06.230
然后运行一个回凋

34:06.230 --> 34:06.750
对吧

34:06.750 --> 34:07.710
现在是等待

34:08.070 --> 34:08.870
返回一个Promise

34:08.870 --> 34:10.350
这个Promise等待一段时间之后

34:10.350 --> 34:11.230
它会自动完成

34:12.590 --> 34:13.350
没什么好说的

34:13.830 --> 34:15.470
然后利用这个Delay函数

34:15.470 --> 34:16.430
让你做这么一件事

34:16.950 --> 34:18.030
等待三次

34:18.390 --> 34:19.070
看下面

34:19.070 --> 34:20.030
先等待一秒

34:20.030 --> 34:21.230
然后输出一个OK

34:21.230 --> 34:22.110
再等待一秒

34:22.110 --> 34:23.190
再输出一个OK

34:23.190 --> 34:24.070
再等待一秒

34:24.070 --> 34:24.870
输出一个OK

34:26.150 --> 34:26.630
怎么写

34:26.630 --> 34:28.430
你们自己去想办法写一下

34:30.070 --> 34:30.870
好好了没

34:30.870 --> 34:31.550
好我看一下

34:31.550 --> 34:32.550
不知道里面是怎么写的

34:33.630 --> 34:34.990
这里又可以有两种写法

34:34.990 --> 34:37.950
一种就是用Promise的API来写

34:38.230 --> 34:39.510
等待一秒钟

34:39.750 --> 34:41.430
Zin输出什么

34:43.110 --> 34:43.750
OK

34:44.150 --> 34:44.790
对吧

34:45.390 --> 34:46.110
然后呢

34:46.110 --> 34:47.230
返回下一个任务

34:47.230 --> 34:48.430
又等待一秒钟

34:50.510 --> 34:51.710
又等待一秒钟

34:53.310 --> 34:54.070
然后

34:54.910 --> 34:55.750
输出

34:56.070 --> 34:56.670
OK

34:57.350 --> 34:58.670
再等待一秒钟

35:01.070 --> 35:01.830
然后

35:02.510 --> 35:04.150
就是一个任务接一个任务

35:04.150 --> 35:05.190
软件事变成

35:06.070 --> 35:06.550
这种写法

35:06.550 --> 35:07.750
其实要比那个

35:07.750 --> 35:09.430
用回调很肯定要好

35:09.430 --> 35:10.590
它没有回调地位

35:10.590 --> 35:11.950
它没有一个回调套一个回调

35:11.950 --> 35:12.430
对吧

35:12.750 --> 35:14.150
这样子肯定要舒服的多

35:14.710 --> 35:15.390
一秒钟

35:16.550 --> 35:17.150
我这里

35:18.030 --> 35:19.270
我这里用这种接个写

35:19.270 --> 35:20.230
有这种

35:20.790 --> 35:21.390
好看

35:22.110 --> 35:23.070
等待一秒钟

35:23.350 --> 35:23.950
OK

35:23.950 --> 35:24.670
再等待一秒钟

35:24.670 --> 35:25.030
OK

35:25.030 --> 35:25.630
再等待一秒钟

35:25.630 --> 35:26.110
OK

35:26.110 --> 35:26.870
好结束了

35:27.870 --> 35:30.110
我们也可以利用这几课学习的东西

35:30.110 --> 35:31.470
那学习要更加舒服了

35:31.470 --> 35:32.190
你看

35:32.190 --> 35:33.270
我用而为之

35:33.870 --> 35:34.430
不信

35:43.150 --> 35:44.710
这是个一步寒说

35:44.710 --> 35:46.990
我在这里面直接写个循环就完了

35:46.990 --> 35:47.870
循环几次

35:47.870 --> 35:48.630
循环三次

35:50.630 --> 35:51.110
对不对

35:51.110 --> 35:52.390
不是要输出三个OK吗

35:52.390 --> 35:53.990
每一次循环

35:53.990 --> 35:54.470
干嘛

35:55.590 --> 35:56.590
等待

35:58.550 --> 35:59.550
一秒钟

36:00.070 --> 36:00.990
输出

36:00.990 --> 36:01.470
OK

36:01.470 --> 36:02.990
那你看这个代码拿个舒服

36:04.470 --> 36:05.710
肯定上面的舒服太多了

36:05.710 --> 36:05.990
对吧

36:07.910 --> 36:08.470
循环三次

36:08.470 --> 36:08.910
OK

36:08.910 --> 36:09.350
OK

36:09.350 --> 36:09.950
OK

36:09.950 --> 36:10.870
效果是完全一样的

36:10.870 --> 36:11.790
然后循环结束了

36:12.510 --> 36:13.790
而且这样子特别好维护

36:13.790 --> 36:14.950
比较说我要等待

36:14.950 --> 36:16.070
我要做实试

36:16.070 --> 36:16.630
这样的事

36:16.630 --> 36:17.950
我就感觉实就完手了

36:19.390 --> 36:20.390
其实下面的代码呢

36:20.390 --> 36:21.350
也可以用循环

36:22.430 --> 36:23.990
只是有点麻烦而已

36:24.670 --> 36:25.390
有点麻烦

36:26.030 --> 36:28.070
我用这种其实也比较方便一点

36:30.610 --> 36:31.090
OK

36:31.090 --> 36:32.010
那

36:33.530 --> 36:34.330
有没有同学知道

36:34.370 --> 36:35.890
像一个东西怎么来用循环形

36:36.370 --> 36:37.410
你们可以自己想想办法

36:38.770 --> 36:39.330
想不出来

36:39.330 --> 36:39.930
没事

36:39.930 --> 36:40.730
反正我们有了

36:40.730 --> 36:42.210
而胜亡而危险之后

36:42.210 --> 36:43.610
我们又可以用上面的写法

36:43.610 --> 36:44.370
更加舒服

36:44.370 --> 36:44.890
好

36:44.890 --> 36:46.330
那么我们Promise的学习呢

36:46.330 --> 36:48.010
异部任务的学习就结束了

36:48.010 --> 36:49.210
我们花了不少的时间

36:49.930 --> 36:51.050
来学这个东西

36:51.050 --> 36:52.210
因为这个东西特别重要

36:52.210 --> 36:53.730
一时面试期特别特别好

36:53.730 --> 36:54.730
考试题很密集

36:55.570 --> 36:56.050
另外呢

36:56.050 --> 36:56.610
就是

36:57.130 --> 36:59.010
这本身也是一个比较有难度的地方

36:59.890 --> 37:01.210
前端有难度的地方

37:01.210 --> 37:02.090
其实不读

37:02.610 --> 37:03.810
这算是一块

37:05.170 --> 37:05.650
另外呢

37:05.650 --> 37:07.930
就他其实跟我们以后开发了

37:07.930 --> 37:08.810
影响了

37:08.810 --> 37:10.170
倒不是特别大

37:10.170 --> 37:10.650
我跟你们说

37:10.650 --> 37:12.810
以后开发对你们的影响是啥

37:12.810 --> 37:13.930
第一门影响就是这个

37:14.850 --> 37:15.650
其实就是第一级

37:17.690 --> 37:18.810
高速里有一个函数

37:18.810 --> 37:20.210
他标记为而生的

37:20.210 --> 37:21.210
你要知道去怎么

37:21.210 --> 37:23.090
就是他是一个异部函数

37:23.090 --> 37:24.250
不管他标没标记而生的

37:24.250 --> 37:26.130
反正他反而或者是Promise

37:26.130 --> 37:27.930
他能拿到有一些远程的数据

37:29.250 --> 37:30.650
我们需要用这个函数

37:32.090 --> 37:34.130
去过去到远程数据

37:34.170 --> 37:34.850
就是这样过去

37:34.850 --> 37:36.970
其实跟我们以后经常会写这种办法

37:37.810 --> 37:39.730
其他长期有没有用到Promise的时候

37:39.730 --> 37:41.370
也有不读

37:41.930 --> 37:43.130
最常见的长期就是这个

37:43.730 --> 37:45.330
但如果说你这一块紧急

37:45.330 --> 37:48.370
就把这块东西安不就斑的背下来

37:48.370 --> 37:49.010
也不行

37:49.010 --> 37:49.450
因为

37:51.130 --> 37:52.530
反正一会有很多隐患

37:52.530 --> 37:53.930
所以我们花点时间把他学了

37:53.930 --> 37:54.890
反正万多都得学到

37:54.890 --> 37:56.490
这个坑必须要买过去的

37:56.490 --> 37:57.330
我们加油吧

37:57.770 --> 37:58.890
把这些课的作业完成

37:59.090 --> 38:00.130
后边我们会拿一些课

38:00.130 --> 38:01.610
专门来讲Promise面词题

38:01.610 --> 38:02.130
一定要看

38:03.010 --> 38:04.330
好 这以后的内容就到这了

38:04.330 --> 38:04.730
拜拜

