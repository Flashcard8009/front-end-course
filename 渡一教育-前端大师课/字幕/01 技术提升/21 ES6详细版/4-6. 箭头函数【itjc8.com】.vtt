WEBVTT

00:00.940 --> 00:05.580
好了 那么现在我们终于学习到了箭头寒书了

00:05.580 --> 00:11.100
箭头寒书应该可以说是ES6里边最成功的改进了

00:11.100 --> 00:18.940
它能解决了介石里边多年以来存在的Ryze指向的问题

00:18.940 --> 00:22.700
我们知道Ry 我们再复习一下 复习回顾一下

00:22.700 --> 00:28.590
Ryze指向

00:28.590 --> 00:32.350
我们介石里边Ryze的指向有哪些情况呢

00:32.510 --> 00:36.750
它是不是取决于函数是怎么调用的呀 对不对

00:36.750 --> 00:42.190
它取决于函数是怎么调用 那么如果说通过对象调用函数

00:42.190 --> 00:45.390
那么Ryze指向谁 是不是指向对象 对吧

00:45.390 --> 00:48.510
你哪个对象调用函数 那么Ryze就指向哪个对象

00:48.510 --> 00:50.910
好 这是第一个 第二个呢

00:50.910 --> 00:55.390
如果说你直接调用的函数 调用函数

00:55.390 --> 00:59.550
那么Ryze指向谁呢 Ryze指向全局对象

00:59.710 --> 01:03.790
在浏览器环境里边就是Windows 对吧

01:03.790 --> 01:09.310
如果是New通过New调用函数

01:09.310 --> 01:15.790
Ryze指向新创建的对象 这个没什么好说的

01:15.790 --> 01:23.710
如果通过Apply 然后Core 还有什么band等

01:23.870 --> 01:35.870
调用函数 Ryze指向 指向的是指定的数据

01:35.870 --> 01:38.750
一个指定Ryze是什么 它就是什么 对吧

01:38.750 --> 01:46.030
还有一个就是 如果是事件函数

01:46.030 --> 01:51.230
Ryze指向谁呢 指向的是事件元

01:51.310 --> 01:53.470
就是注册事件那个东西

01:53.470 --> 01:56.030
理解谁注册的事件 那么Ryze就指向谁

01:56.030 --> 01:59.950
Ryze的指向呢 无非就是这么几种情况

01:59.950 --> 02:04.510
Ryze的指向也是初学者对于接也是感觉比较绕的地方

02:04.510 --> 02:06.190
感觉比较混乱的地方

02:06.190 --> 02:07.950
不管它是哪一种情况呢

02:07.950 --> 02:10.750
其实Ryze到底指向谁

02:10.750 --> 02:13.710
是不是取决于你这个函数是怎么用的呀

02:13.710 --> 02:16.030
它跟你怎么定义的没有什么关系

02:16.030 --> 02:17.790
你怎么去用这个函数

02:17.870 --> 02:21.310
那么它决定的 Ryze指向谁

02:21.310 --> 02:23.150
好 那么这样子一来呢

02:23.150 --> 02:26.430
在某些时候呢 会出一些问题

02:26.430 --> 02:28.190
你们开发到现在的话

02:28.190 --> 02:31.550
应该一定是见过这样的问题了

02:31.550 --> 02:33.150
我们来一个对象吧

02:33.150 --> 02:36.270
这个对象里边有这么一个属性 叫做Cort

02:36.270 --> 02:38.910
有这么一个属性 肝灵

02:38.910 --> 02:41.150
然后呢 这里边有个start函数

02:41.150 --> 02:43.070
有这么一个属性 start

02:43.070 --> 02:44.510
就是启动一个计时器

02:44.510 --> 02:46.990
把这个Cort不断不断增加

02:47.150 --> 02:48.990
那么来吧 启动一个计时器

02:48.990 --> 02:51.740
set interval

02:51.740 --> 02:52.700
来吧

02:52.700 --> 02:54.540
好 那么这里边呢

02:54.540 --> 02:58.140
一秒钟 每隔一秒钟

02:58.140 --> 02:58.780
干嘛呢

02:58.780 --> 02:59.420
Cort增加

02:59.420 --> 03:00.220
那怎么增加呢

03:00.220 --> 03:01.900
一不再是用Ryze的Cort嘛

03:01.900 --> 03:03.180
对不对 是吧

03:03.180 --> 03:04.380
是不是在这样子写

03:04.380 --> 03:05.900
你不能直接写Cort

03:05.900 --> 03:07.020
它又不是辨量

03:07.020 --> 03:08.860
它哪来的Cort呢

03:08.860 --> 03:10.220
你肯定要通过这个对象

03:10.220 --> 03:11.020
这个对象呢

03:11.020 --> 03:13.020
我们可能想当然的认为

03:13.020 --> 03:14.140
这个Ryze呢

03:14.140 --> 03:15.260
就指向的是这个对象

03:15.260 --> 03:16.860
因为我写到这个函数里面了吧

03:16.860 --> 03:17.580
因为到时候呢

03:17.580 --> 03:19.100
这个函数它一定是这样调用的

03:19.100 --> 03:19.980
start 对吧

03:19.980 --> 03:21.260
是不是这样调用的

03:21.260 --> 03:23.580
这个函数的start是不是这样调用的

03:23.580 --> 03:25.020
而这样调用函数的话

03:25.020 --> 03:26.460
那么这个函数内部的Ryze

03:26.460 --> 03:28.140
是不是指向的是obj 对吧

03:28.140 --> 03:30.700
那这里的Ryze是不是指向的是什么

03:30.700 --> 03:32.220
指向的是obj 对吧

03:32.220 --> 03:34.460
因为你通过是这个对象来调用的

03:34.460 --> 03:35.660
好 那么我们在这里呢

03:35.660 --> 03:37.580
使用Ryze这个对象里面的Cort加加

03:37.580 --> 03:39.100
然后把它Cort输出

03:39.100 --> 03:40.620
thisCort

03:40.620 --> 03:41.820
来吧 我们来看一下

03:41.820 --> 03:44.620
它能不能达到我们想要的效果

03:44.620 --> 03:45.980
这个名言人一看

03:46.060 --> 03:47.900
就知道这个地方要出问题

03:47.900 --> 03:50.140
来吧 看一下 通知菜

03:50.140 --> 03:51.740
是不是全是

03:51.740 --> 03:53.180
啥呀

03:53.180 --> 03:54.300
全是啥呀

03:54.300 --> 03:56.060
所以全是NAN

03:56.060 --> 03:57.740
为什么全是NAN呢

03:57.740 --> 04:00.300
就是Ryze的指向出了问题

04:00.300 --> 04:01.580
因为在这里的话

04:01.580 --> 04:03.340
Ryze的指向倒是没有什么问题

04:03.340 --> 04:04.060
你看一下在这里

04:04.060 --> 04:06.140
我们输出一下Ryze

04:06.140 --> 04:07.100
是没有什么问题的

04:07.100 --> 04:09.340
但在这里的Ryze出了问题

04:09.340 --> 04:12.380
这两个地方的Ryze是不一样的

04:12.380 --> 04:13.580
我们来看一下吧

04:13.580 --> 04:15.260
你看第一个Ryze是不是没问题

04:15.420 --> 04:16.700
对吧 是个对象

04:16.700 --> 04:18.460
你看 因为我们是通过OB借

04:18.460 --> 04:19.660
第二Start来调用的

04:19.660 --> 04:21.020
那么这个Start函数里边

04:21.020 --> 04:22.460
Ryze它指向的是

04:22.460 --> 04:23.900
通过哪个对象调用的

04:23.900 --> 04:25.020
它就指向哪个对象

04:25.020 --> 04:26.940
所以这里的Ryze指向没问题

04:26.940 --> 04:28.780
但是这个函数里面的Ryze指向

04:28.780 --> 04:29.580
就出问题了

04:29.580 --> 04:31.020
因为这个函数是在借

04:31.020 --> 04:32.540
是引擎内部调用的

04:32.540 --> 04:35.020
它是直接调用这个函数

04:35.020 --> 04:38.620
它的内部是直接调用的这个函数

04:38.620 --> 04:41.020
所以说这里的Ryze指向的是全举温度

04:41.020 --> 04:42.620
它是适用于这种情况

04:42.620 --> 04:44.140
直接调用函数

04:44.620 --> 04:45.660
其中一个计时器

04:45.660 --> 04:47.340
每隔一段时间调用这个函数

04:47.340 --> 04:48.060
谁调用的

04:48.060 --> 04:50.620
是借是引擎在内部调用的

04:50.620 --> 04:52.140
那么它是直接调用这个函数的

04:52.140 --> 04:54.140
因此这里的Ryze是不是指向Window

04:54.140 --> 04:55.020
对吧

04:55.020 --> 04:56.380
那么这里的Ryze出了问题

04:56.380 --> 04:57.580
所以说你这里想讲

04:57.580 --> 04:59.820
在Window里面的Cost里面加上加加

04:59.820 --> 05:01.740
Window里面Cost是不是Undefined

05:01.740 --> 05:04.380
Undefined的加加是不是等于NAN

05:04.380 --> 05:06.220
对吧 是不是出了这样的问题

05:06.220 --> 05:07.740
那么像这种类似的问题

05:07.740 --> 05:09.980
很多 超级超级多

05:09.980 --> 05:12.620
比方说我们这里假设

05:12.700 --> 05:14.300
还有一个事件

05:14.300 --> 05:16.060
叫做RigEvent

05:16.060 --> 05:18.540
我们可能这里写了这么一个函数

05:18.540 --> 05:21.100
这个函数是用于给DOM注册事件的

05:21.100 --> 05:22.620
我们这里比方说

05:22.620 --> 05:24.540
我们给Window做这个事件

05:24.540 --> 05:27.180
WindowUnclick注册这个事件

05:27.180 --> 05:30.140
我们在这个事件里面想输出Zis的Cost

05:30.140 --> 05:31.660
是不是也会出问题

05:31.660 --> 05:32.220
对吧

05:32.220 --> 05:33.980
好 保存 我们来看一下

05:33.980 --> 05:35.580
点击

05:35.580 --> 05:37.020
点击

05:37.020 --> 05:38.860
Window点击

05:38.860 --> 05:40.460
没有注册 对吧

05:40.460 --> 05:40.980
没有注册

05:40.980 --> 05:42.980
OB界RigEvent

05:42.980 --> 05:44.340
给Window注册事件

05:44.340 --> 05:46.900
好 保存

05:46.900 --> 05:48.820
然后我们点击

05:48.820 --> 05:50.340
你看 是不是得到Undefined

05:50.340 --> 05:51.140
对吧

05:51.140 --> 05:52.180
明明这里有值得

05:52.180 --> 05:53.300
但是得到Undefined

05:53.300 --> 05:55.380
也就是说这里的函数是不是事件

05:55.380 --> 05:56.020
对不对

05:56.020 --> 05:58.740
事件的话Zis指向的是世界元

05:58.740 --> 05:59.620
世界元是谁

05:59.620 --> 06:01.220
是Window

06:01.220 --> 06:02.980
看到没有 是不是遇到了这些问题

06:02.980 --> 06:05.140
那么这些问题以前是怎么解决的呢

06:05.140 --> 06:07.380
以前那么是这样子来处理的

06:07.380 --> 06:08.980
那么我们是利用B包

06:08.980 --> 06:10.500
你再调用这个函数的时候

06:10.500 --> 06:12.420
这个函数内部是Zis是没有问题的

06:12.420 --> 06:14.020
所以说我们可以把Zis

06:14.020 --> 06:17.540
保存到一个变量里面去

06:17.540 --> 06:20.900
然后这边使用这个变量来控制Zis

06:20.900 --> 06:22.420
而不是用Zis关键字了

06:22.420 --> 06:24.980
因为Zis关键字它是多变的

06:24.980 --> 06:27.220
它在每一个函数里面都可能不太一样

06:27.220 --> 06:28.020
它是多变的

06:28.020 --> 06:31.940
所以说我们把它换一个名字

06:31.940 --> 06:33.540
是不是要用这种形式

06:33.540 --> 06:34.740
对不对

06:34.740 --> 06:36.100
以前得用这种形式

06:36.100 --> 06:37.380
那么现在就没问题了 对吧

06:37.380 --> 06:38.660
包括我们点击

06:38.740 --> 06:40.900
点击 看是不是输出 多输出了一个

06:42.100 --> 06:44.580
但是这样的代码写下耳部耳型呢

06:44.580 --> 06:46.900
我反正觉得是挺耳型的

06:46.900 --> 06:47.940
到处都是

06:47.940 --> 06:49.140
后来你会发现了

06:49.140 --> 06:51.460
这里如果说千套的层次再多了

06:51.460 --> 06:53.060
你会发现了这里要写Zis

06:53.060 --> 06:54.660
那么下一个层次要绑进Zis

06:54.660 --> 06:55.700
要写Rat

06:55.700 --> 06:57.940
Rat过后还不够 下面再写

06:57.940 --> 06:58.660
还要绑进的话

06:58.660 --> 07:00.020
要写下发现Rat

07:00.020 --> 07:00.500
对吧

07:00.500 --> 07:01.380
写的越来越多

07:01.380 --> 07:03.380
越来越耳型的代码

07:03.380 --> 07:05.220
那么为了解决这个问题呢

07:05.220 --> 07:07.060
当然这个是原因之一

07:07.060 --> 07:08.100
为了解决这个问题

07:08.100 --> 07:10.900
以及让我们某些时候写函数

07:10.900 --> 07:12.740
变得更加的简洁了

07:12.740 --> 07:15.140
ES6出来了箭头函数

07:15.140 --> 07:17.060
箭头函数就可以非常非常

07:17.060 --> 07:18.660
好的解决这个问题

07:18.660 --> 07:20.260
那么箭头函数是怎么写的呢

07:20.260 --> 07:21.300
我们首先来

07:21.300 --> 07:23.060
说一下箭头函数的使用语法

07:23.060 --> 07:24.180
首先第一个点

07:24.180 --> 07:25.380
就是箭头函数

07:26.980 --> 07:31.060
箭头函数是一个函数表达式

07:32.580 --> 07:36.580
这句话里边涵盖了很多很多的信息

07:36.580 --> 07:38.660
将我们什么时候是函数表达式呢

07:38.660 --> 07:39.940
你看一下这里

07:39.940 --> 07:41.540
是不是函数表达式

07:41.540 --> 07:43.860
这个地方是不是函数表达式

07:43.860 --> 07:44.900
对吧

07:44.900 --> 07:47.380
我们有的时候写一些立即执行函数

07:48.980 --> 07:51.140
这个玩意是不是一个函数表达式

07:51.140 --> 07:52.420
对吧

07:52.420 --> 07:54.340
我们有的时候写一个变量

07:54.340 --> 07:54.900
就是funk

07:55.780 --> 07:57.620
那么这个地方是不是一个函数表达式

07:58.260 --> 07:59.220
对吧

07:59.220 --> 08:00.260
这是不是函数表达式

08:01.380 --> 08:01.860
没问题吧

08:02.820 --> 08:06.740
那么他这如果说你这样子写函数的话

08:06.740 --> 08:08.420
比方说你这样子写函数的话

08:08.980 --> 08:10.660
那么这个东西是不是函数表达式的

08:10.660 --> 08:11.380
他就不是了

08:12.020 --> 08:13.940
他是一个普通的函数声明

08:13.940 --> 08:16.020
普通的函数声明是不是会提升到window里边

08:16.020 --> 08:16.260
对吧

08:16.260 --> 08:16.980
会提升

08:16.980 --> 08:18.580
但是表达式是不会提升的

08:18.580 --> 08:20.420
所以首先大家明确一点

08:20.420 --> 08:22.740
箭头函数是一个函数表达式

08:23.780 --> 08:24.980
理论上来讲

08:24.980 --> 08:27.380
任何使用函数表达式的地方

08:27.380 --> 08:29.380
都可以提缓成箭头函数

08:29.380 --> 08:29.860
理论上

08:30.580 --> 08:33.540
任何使用函数表达式

08:33.540 --> 08:34.580
换句话说

08:36.020 --> 08:37.940
任何时候使用逆名函数

08:37.940 --> 08:39.460
因为使用逆名函数的时候

08:39.460 --> 08:40.580
一定是函数表达式

08:40.580 --> 08:40.980
对吧

08:40.980 --> 08:42.340
一定是函数表达式

08:42.340 --> 08:44.020
任何使用逆名函数的时候

08:44.020 --> 08:45.620
都可以使用箭头函数

08:45.620 --> 08:50.500
任何使用函数表达式的场景

08:50.500 --> 08:53.060
都可以使用箭头函数

08:53.700 --> 08:54.340
理论上

08:54.340 --> 08:55.860
当然以后我们说一下细节

08:56.660 --> 08:58.500
那么箭头函数具体怎么写呢

08:58.580 --> 09:00.100
就是它的写法很简单

09:00.100 --> 09:01.860
它的完整写法是这样子

09:03.780 --> 09:04.660
完整语法

09:08.090 --> 09:09.130
它是这样子的

09:09.130 --> 09:10.250
两个小货号

09:10.250 --> 09:11.530
注意是英文的

09:11.530 --> 09:12.570
然后写参数

09:12.570 --> 09:15.770
参数1参数2

09:15.770 --> 09:17.530
什么什么其他参数

09:17.530 --> 09:18.810
I怎么写怎么写

09:18.810 --> 09:19.770
然后的一个箭头

09:19.770 --> 09:20.970
箭头是一个等号

09:20.970 --> 09:22.170
一个大语符号

09:23.370 --> 09:24.890
然后两个大货号

09:24.890 --> 09:26.650
这里边写上函数题

09:27.290 --> 09:29.930
这是他箭头函数的写法

09:30.010 --> 09:33.370
是比之前的函数表达式写下来要简洁一些的

09:33.370 --> 09:33.930
对不对

09:33.930 --> 09:35.850
从语法上看要简洁一些的

09:35.850 --> 09:37.610
因为它少了一个方形关键字

09:38.250 --> 09:39.130
好那么这边呢

09:39.130 --> 09:40.330
我们来看一下啊

09:40.330 --> 09:42.170
我们就把这个这个地方

09:42.170 --> 09:43.210
这是不是函数表达式

09:43.210 --> 09:44.890
来写成箭头函数

09:44.890 --> 09:45.770
来我们来写一下

09:46.330 --> 09:47.770
怎么写方可行去掉

09:48.490 --> 09:50.010
两个小货号里面写参数

09:50.010 --> 09:50.970
没有参数就不写呗

09:51.690 --> 09:52.330
一个箭头

09:53.050 --> 09:53.690
一个箭头

09:55.290 --> 09:55.770
你看一下

09:57.050 --> 09:58.010
好那么这里呢

09:58.010 --> 09:58.490
去掉

09:59.450 --> 10:00.250
方可行去掉

10:00.250 --> 10:01.530
这里写个箭头

10:04.120 --> 10:04.600
你看一下

10:05.160 --> 10:05.800
是不是写好了

10:05.800 --> 10:06.200
对吧

10:06.200 --> 10:07.640
这就替换成了一个箭头函数

10:07.640 --> 10:08.360
就这么简单

10:08.360 --> 10:09.480
你约度复杂啊

10:09.480 --> 10:10.360
就这么简单

10:10.360 --> 10:11.480
小货号里面写参数

10:11.480 --> 10:12.440
然后一个箭头

10:12.440 --> 10:13.160
中间的空格呢

10:13.160 --> 10:14.760
是为了格式化好看一点啊

10:14.760 --> 10:16.360
如果说你不不写空格的话

10:16.360 --> 10:17.400
也完全无所谓

10:17.400 --> 10:19.240
两个大货号表示里边写函数题

10:19.800 --> 10:20.360
没问题吧

10:21.160 --> 10:21.480
好

10:21.480 --> 10:23.640
你会发现一个神奇的现象

10:23.640 --> 10:25.240
当这样子写了之后

10:25.240 --> 10:25.880
你会发现

10:27.640 --> 10:28.840
我们看一下啊

10:29.000 --> 10:30.440
this code 加加没有写

10:30.440 --> 10:31.560
this code 加加

10:33.400 --> 10:34.600
当这样子写了过后

10:34.600 --> 10:35.240
你会发现

10:35.480 --> 10:36.280
没问题了

10:37.000 --> 10:37.960
没问题了

10:37.960 --> 10:38.680
你看到没

10:38.680 --> 10:39.560
没问题了

10:39.560 --> 10:41.080
那么为什么没有问题呢

10:41.080 --> 10:41.720
就是以后

10:41.720 --> 10:42.120
以后呢

10:42.120 --> 10:43.800
我们要讲的箭头函数的一个

10:43.800 --> 10:45.320
非常非常重要的功能

10:45.320 --> 10:46.760
就在线的函数细节里面

10:46.760 --> 10:47.880
我们以后要讲的啊

10:47.880 --> 10:48.440
那么这里呢

10:48.440 --> 10:49.880
我先提前给大家说了

10:49.880 --> 10:51.080
第一个细节就是

10:51.080 --> 10:52.520
箭头函数的Z

10:53.400 --> 10:58.200
箭头函数的函数体中的Z

10:59.080 --> 11:02.120
取决于箭头函数

11:03.400 --> 11:04.440
声明的

11:05.320 --> 11:06.520
就定义的位置

11:07.800 --> 11:08.760
定义的位置

11:09.880 --> 11:11.320
的Z是指向

11:12.200 --> 11:12.520
而

11:13.160 --> 11:15.560
与如何调用

11:15.560 --> 11:16.040
无关

11:16.760 --> 11:18.040
如何调用箭头函数

11:18.040 --> 11:19.000
是没有任何关系的

11:19.560 --> 11:20.760
也就是这个函数

11:20.760 --> 11:21.560
这个我们是不是

11:21.560 --> 11:22.280
给它传了一个函数

11:22.280 --> 11:22.920
没问题吧

11:22.920 --> 11:24.360
传的是一个函数

11:24.360 --> 11:25.560
它到时候怎么调用呢

11:25.560 --> 11:27.000
它到时候一定是直接调用的

11:27.000 --> 11:28.520
这是戒是引擎内部做的

11:28.680 --> 11:29.880
它一定是直接调用的

11:29.880 --> 11:31.240
这里我们刚传了一个函数

11:31.240 --> 11:31.560
对吧

11:31.560 --> 11:32.680
这个函数是什么

11:32.680 --> 11:33.880
事件函数

11:33.880 --> 11:34.680
那么这个事件函数

11:34.680 --> 11:36.040
到时候它会在某些时候

11:36.040 --> 11:37.240
事件触发的时候调用

11:38.120 --> 11:41.000
但是由于我们使用的是箭头函数

11:41.000 --> 11:42.360
箭头函数的Z

11:42.360 --> 11:43.560
它有个规则就是

11:43.560 --> 11:46.040
它取决于你声明箭头函数

11:46.040 --> 11:47.080
这个位置的Z

11:47.080 --> 11:48.200
也就是取决于什么呢

11:48.200 --> 11:49.720
你把这个箭头函数去掉

11:49.720 --> 11:51.160
这个地方的Z是啥

11:51.160 --> 11:52.360
箭头函数里边的Z

11:52.360 --> 11:53.480
它一定是啥

11:53.480 --> 11:54.440
不管你怎么调用

11:54.440 --> 11:55.480
你用通过对象调用

11:55.480 --> 11:56.280
你直接调用

11:56.280 --> 11:57.000
得无所谓

11:57.080 --> 11:59.080
它的Z就已经定下来了

11:59.080 --> 11:59.880
那么这里的Z

11:59.880 --> 12:00.920
你可以明显的感觉到

12:00.920 --> 12:01.800
这些Z是什么

12:01.800 --> 12:02.440
这些Z

12:02.440 --> 12:04.200
START是通过OBG调用的

12:04.200 --> 12:05.240
所以说这里的Z

12:05.240 --> 12:05.960
指向的是谁

12:05.960 --> 12:07.720
指向的就是OBG对象

12:07.720 --> 12:09.320
所以说在这里写箭头函数

12:09.320 --> 12:10.120
它的里边的Z

12:10.120 --> 12:12.600
就指向的是OBG对象

12:12.600 --> 12:13.640
那么这里是同样的

12:13.640 --> 12:13.960
对吧

12:13.960 --> 12:14.600
这里是同样的

12:14.600 --> 12:15.880
你把箭头函数去掉

12:15.880 --> 12:17.320
那么这里的Z是啥呢

12:17.320 --> 12:18.680
这里的Z是不是

12:18.680 --> 12:20.920
也是通过OBG调用的函数

12:20.920 --> 12:21.560
那么这个Z

12:21.560 --> 12:22.680
是不是指向了OBG

12:22.680 --> 12:23.000
对吧

12:23.000 --> 12:24.440
那么你来这里写箭头函数

12:24.440 --> 12:25.640
那么箭头函数里边的Z

12:25.720 --> 12:26.920
它一定指向OBG

12:27.960 --> 12:28.520
没了意思吗

12:29.320 --> 12:31.080
所以说箭头函数

12:31.080 --> 12:32.280
它里边的Z

12:32.280 --> 12:33.640
它指向谁呢

12:33.640 --> 12:35.240
它是指

12:35.240 --> 12:36.040
指向的是

12:36.040 --> 12:37.640
它书写位置的

12:37.640 --> 12:38.760
书写的位置

12:39.400 --> 12:40.920
所使用的Z

12:41.320 --> 12:43.160
而根底怎么去调用它

12:43.160 --> 12:44.200
没有任何关系

12:45.000 --> 12:45.560
所以说这里

12:46.200 --> 12:47.320
是不是就搞定Z的

12:47.320 --> 12:48.280
指向问题了

12:48.280 --> 12:48.680
对不对

12:49.640 --> 12:50.120
好

12:50.120 --> 12:50.680
接下来

12:50.680 --> 12:51.880
我再给大家看一个例子

12:52.520 --> 12:53.720
看大家是不是

12:53.720 --> 12:55.160
对这一块搞清楚了

12:56.200 --> 12:57.800
比方说吧

12:57.800 --> 12:59.320
我们看一下这个例子

13:00.840 --> 13:01.880
这个例子是啥呢

13:01.880 --> 13:02.840
就这里有函数

13:03.880 --> 13:04.600
就Test

13:05.160 --> 13:05.880
Test函数

13:06.600 --> 13:07.640
这个函数呢

13:07.640 --> 13:08.440
我们如果说

13:08.440 --> 13:09.960
用一个普通函数

13:09.960 --> 13:10.520
我们这里

13:10.520 --> 13:11.480
就Print什么

13:11.480 --> 13:12.040
打印

13:12.040 --> 13:13.240
打印当前的Cort

13:14.600 --> 13:15.560
Z的Cort

13:16.120 --> 13:18.760
用普通函数是没有什么问题的

13:18.760 --> 13:20.360
比方说我们这里OBG

13:20.360 --> 13:20.680
Print

13:21.720 --> 13:22.280
A

13:22.280 --> 13:22.920
我们来看一下

13:24.040 --> 13:24.680
打印出来

13:25.640 --> 13:26.280
我们先不

13:26.280 --> 13:27.320
这些东西不启动吗

13:27.320 --> 13:28.200
不启动

13:28.200 --> 13:29.000
就Print

13:29.000 --> 13:30.280
打印出来零

13:30.280 --> 13:30.600
对吧

13:30.600 --> 13:31.800
是不是没有问题的

13:31.800 --> 13:32.520
有些同学呢

13:32.520 --> 13:33.800
开始在这样子想

13:33.800 --> 13:35.160
他想把它写得完善一点

13:35.160 --> 13:35.960
但是这个想法

13:35.960 --> 13:37.000
是肯定是没错的

13:38.280 --> 13:39.480
这是我见到了

13:40.520 --> 13:42.360
好些同学这么做过

13:42.360 --> 13:44.280
所以说我单独把他拿出来说一下

13:45.000 --> 13:46.200
他学到函数过后

13:46.200 --> 13:46.600
觉得

13:47.880 --> 13:49.000
你这样子函数调用

13:49.000 --> 13:50.040
确实是没有问题的

13:50.040 --> 13:51.480
因为你是通过对象调用

13:51.480 --> 13:53.000
那么这个函数内部的Z

13:53.000 --> 13:54.440
他取决于你是怎么调用的

13:54.440 --> 13:55.480
这是一个普通函数

13:55.480 --> 13:56.520
不是建筒函数

13:56.520 --> 13:57.160
所以Z

13:57.160 --> 13:59.400
他一定是指向你调用了对象

13:59.400 --> 14:00.360
哪个对象来调用的

14:00.360 --> 14:01.400
Z就指向谁

14:01.400 --> 14:02.920
这个是本身是没问题的

14:02.920 --> 14:04.200
但是他继续想

14:04.200 --> 14:05.080
他说如果说

14:05.080 --> 14:06.280
你没有这样调用函数

14:06.280 --> 14:07.400
你可能会这样子写

14:08.440 --> 14:09.880
你可能会这样子写

14:09.880 --> 14:11.720
把这个函数的负责给另外一个变量

14:12.760 --> 14:13.880
然后去调用这个变量

14:14.760 --> 14:15.880
通过这种方式来调用

14:16.520 --> 14:17.080
没了意思吧

14:17.080 --> 14:19.000
他通过这种方式来调用这个函数

14:19.000 --> 14:19.720
好保存

14:19.720 --> 14:20.360
我们来看一下

14:21.000 --> 14:22.120
Z是不是NG的

14:22.120 --> 14:22.600
对吧

14:23.080 --> 14:23.640
不是

14:23.640 --> 14:24.680
Cortis不是NG犯了

14:24.680 --> 14:26.120
那么这个时候Z是指向谁

14:26.120 --> 14:27.720
是不是直接调用函数

14:27.720 --> 14:28.760
Z是指向什么

14:28.760 --> 14:29.800
指向Window

14:29.800 --> 14:30.200
对吧

14:30.200 --> 14:31.320
他指向的是Window

14:32.040 --> 14:32.920
那么这一块

14:32.920 --> 14:34.360
他为了处理这个问题

14:34.360 --> 14:36.120
于是他就把这个地方

14:36.120 --> 14:37.480
写成了一个建筒函数

14:38.280 --> 14:39.320
他觉得建筒函数

14:39.320 --> 14:40.840
应该可以解决这样的问题

14:40.840 --> 14:41.000
好

14:41.000 --> 14:41.640
咱们来试一下

14:41.640 --> 14:43.400
建筒函数能不能解决这个问题

14:43.400 --> 14:43.800
保存

14:43.800 --> 14:44.600
你看还是

14:44.600 --> 14:45.480
还是NG犯

14:45.480 --> 14:45.720
好

14:45.720 --> 14:47.240
那么这个时候我们把去

14:47.240 --> 14:48.360
输出一下Z

14:48.360 --> 14:49.720
看一下到底是啥

14:49.720 --> 14:51.480
你会发现他还是Window

14:51.480 --> 14:52.440
那么是怎么回事呢

14:52.760 --> 14:53.960
首先我们解释原因

14:55.400 --> 14:56.040
怎么回事呢

14:56.600 --> 14:57.560
我们刚才说了

14:57.560 --> 14:58.920
建筒函数呢

14:58.920 --> 15:01.560
它里边的Z是取决于

15:01.560 --> 15:04.280
你声明建筒函数这个位置的Z

15:04.920 --> 15:05.960
取决于这个

15:05.960 --> 15:07.080
那么你就相当于是

15:07.080 --> 15:09.000
你把这个建筒函数给它去掉

15:09.000 --> 15:10.760
你看一下这个地方的Z是啥

15:11.880 --> 15:12.840
你想一想

15:12.840 --> 15:14.680
这个地方的Z是这个OB界吗

15:15.560 --> 15:16.840
是这个OB界吗

15:16.840 --> 15:17.640
是不是不是啊

15:18.360 --> 15:20.120
我们说Z是应该写到哪

15:20.120 --> 15:21.720
是不是写到函数里边

15:21.800 --> 15:23.720
如果Z是它不在函数里边

15:23.720 --> 15:25.080
这个时候Z在不在函数里边

15:25.080 --> 15:25.880
还在对象里边

15:25.880 --> 15:26.680
还没在函数里边

15:27.240 --> 15:28.280
它没有在函数里边

15:28.760 --> 15:31.080
那么如果说Z它没有在函数里边

15:31.080 --> 15:31.960
Z指向谁

15:32.440 --> 15:34.440
是不是指向的是Window对象啊

15:35.240 --> 15:36.120
所以说这个时候

15:36.120 --> 15:38.360
你哪怕在这里给它写了一个建筒函数

15:38.360 --> 15:39.320
你绑定了谁

15:39.320 --> 15:41.320
绑定了建筒函数会绑定Z

15:41.320 --> 15:42.200
会固定Z

15:42.520 --> 15:44.040
那么Z固定到谁了

15:44.040 --> 15:44.840
固定到Window了

15:45.320 --> 15:46.280
你无论怎么用

15:46.280 --> 15:48.040
哪怕你现在本来一开始

15:48.040 --> 15:49.640
这种写法都是可以的

15:49.640 --> 15:50.920
现在这种写法都不行了

15:51.000 --> 15:52.840
因为这种写法里边仍然是Window

15:54.040 --> 15:55.240
想法是好的

15:55.240 --> 15:57.000
但是你在这里写建筒函数

15:57.000 --> 15:58.040
实际上是不合适的

15:58.920 --> 16:00.520
那么这个问题怎么解决呢

16:00.520 --> 16:02.040
这个问题我们通常不解决

16:02.760 --> 16:03.880
为什么说不解决呢

16:03.880 --> 16:04.920
那你回忆一下

16:04.920 --> 16:06.680
我们在开发中什么情况下

16:06.680 --> 16:07.640
遇到这样的问题

16:08.440 --> 16:09.400
你好好回忆一下

16:09.400 --> 16:10.040
你不要撒谎

16:10.040 --> 16:10.840
你好好回忆一下

16:11.400 --> 16:12.520
是不是几乎没有

16:13.160 --> 16:15.400
我们遇到了最多的问题是

16:15.400 --> 16:17.240
在函数里边套函数

16:17.240 --> 16:18.680
出现了Z是指向问题

16:19.160 --> 16:20.120
而不是存在

16:20.120 --> 16:21.640
不存在说这种类型的问题

16:21.640 --> 16:22.440
所以说这种问题

16:22.440 --> 16:23.320
我们一般不解决

16:23.960 --> 16:24.760
建筒函数

16:24.760 --> 16:26.200
它出现了也不是为了解决

16:26.200 --> 16:26.840
这样的问题的

16:27.720 --> 16:28.440
因为这个东西

16:28.440 --> 16:29.800
它本身就不成为问题

16:30.360 --> 16:32.600
我们通常这个问题是在函数里边套函数

16:32.600 --> 16:33.640
出现了Z是指向问题

16:34.920 --> 16:36.920
建筒函数在这里发挥了它的作用

16:37.640 --> 16:38.200
原来这个意思

16:38.760 --> 16:42.760
这是关于建筒函数的Z是指向

16:43.720 --> 16:44.680
好那么接下来

16:44.680 --> 16:47.480
我们要继续说回到建筒函数的语法这一块

16:48.440 --> 16:50.120
建筒函数这个语法这里

16:50.120 --> 16:51.640
它其实还可以简写

16:52.200 --> 16:53.240
还可以简写的

16:54.360 --> 16:57.640
也就是说如果参数只有一个

16:58.280 --> 17:00.280
如果你说你只有一个参数

17:00.280 --> 17:02.600
可以省略小货号

17:04.520 --> 17:05.320
那么我们写一下

17:05.720 --> 17:06.280
它的语法

17:06.760 --> 17:08.120
如果说你参数只有一个

17:08.120 --> 17:09.560
那么直接就是一个参数

17:09.960 --> 17:11.160
一个箭头

17:11.160 --> 17:12.520
然后两个大货号就完了

17:13.240 --> 17:15.160
你可以省略掉小货号

17:16.040 --> 17:17.480
参数外面的小货号是可以省略的

17:17.480 --> 17:18.680
但是前例条件

17:18.680 --> 17:19.880
参数是必须只有

17:19.880 --> 17:21.720
如果说你只写一个参数的话

17:21.720 --> 17:22.440
你可以省略

17:22.440 --> 17:23.640
如果说你要写多个参数的话

17:23.640 --> 17:24.680
你是不能省略的

17:24.680 --> 17:27.000
或者说你没有参数的情况下是不能省略的

17:27.560 --> 17:29.640
好直接来我们来看一个下面这个例子

17:32.040 --> 17:32.520
比方说

17:33.800 --> 17:35.000
我有这么一个函数

17:35.000 --> 17:36.520
我们现在就不关注Z了

17:36.520 --> 17:38.920
建筒函数它不仅仅是可以解决Z的问题

17:38.920 --> 17:41.240
还可以让我们的输写函数更加的方便

17:41.960 --> 17:43.800
比方说我们这里有这么一个Print函数

17:44.680 --> 17:46.520
我们这里使用箭头函数

17:46.520 --> 17:47.560
你给我一个数字

17:47.560 --> 17:48.920
我把它打印出来

17:48.920 --> 17:50.280
就做这么一个简单的事情

17:50.920 --> 17:52.600
这里你给我一个数字

17:52.600 --> 17:53.000
Number

17:55.640 --> 17:57.240
我来把它打印出来

17:57.240 --> 17:58.360
打印Consult

17:59.480 --> 18:02.600
给我的数字是Number

18:03.160 --> 18:04.440
就写这么一个函数

18:04.440 --> 18:04.840
你看一下

18:04.840 --> 18:05.880
是不是只有一个参数

18:06.440 --> 18:08.040
只有一个参数的情况下

18:08.040 --> 18:09.720
我是不是可以省略掉小货号

18:10.360 --> 18:10.680
对不对

18:11.640 --> 18:12.280
好

18:12.280 --> 18:13.800
然后我们来调用一下Print

18:13.800 --> 18:14.920
给它一个2

18:15.960 --> 18:16.600
好保存

18:16.600 --> 18:17.400
你看一下

18:17.400 --> 18:18.600
所以正常数出了

18:18.600 --> 18:19.160
对吧

18:19.160 --> 18:20.600
这就是一个函数

18:21.960 --> 18:22.520
没有意思吧

18:22.520 --> 18:23.960
你要习惯一下

18:23.960 --> 18:25.800
要习惯一下这个箭头函数的格式

18:25.800 --> 18:26.680
这是参数

18:26.680 --> 18:27.480
这是函数体

18:27.480 --> 18:28.600
它省略的方式

18:29.240 --> 18:30.040
不需要写方式

18:31.000 --> 18:33.320
这是关于箭头函数的另一种输写方式

18:34.600 --> 18:38.200
如果说箭头函数

18:39.160 --> 18:45.720
只有一条返回语句

18:46.840 --> 18:52.920
可以省略大货号和return关键制

18:53.480 --> 18:54.200
什么意思呢

18:54.200 --> 18:54.680
看一下

18:56.440 --> 18:58.120
这里前面参数

18:58.120 --> 18:58.840
参数不说了

18:59.480 --> 19:01.800
后边如果说返回值

19:01.800 --> 19:04.280
只有一条语句返回

19:04.280 --> 19:06.360
那么直接把返回值数学到着急完事了

19:06.360 --> 19:07.560
是不是更加简洁了

19:08.520 --> 19:09.720
这里来给大家举个例子

19:11.560 --> 19:13.000
比方说吧

19:13.000 --> 19:16.760
我们这里要判断一个数是不是击数

19:19.320 --> 19:20.120
is old

19:20.760 --> 19:22.600
是判断一个数是不是击数

19:22.600 --> 19:24.600
那么我们以前的写法怎么写呢

19:25.400 --> 19:26.680
是给我一个数字

19:26.680 --> 19:27.400
对吧

19:27.400 --> 19:29.720
然后我返回这个数字

19:29.720 --> 19:30.840
除以2

19:30.840 --> 19:32.280
是不是不等于0

19:32.280 --> 19:33.720
不等于0又是击数

19:33.720 --> 19:34.280
对不对

19:34.280 --> 19:35.400
是不是这样写的

19:35.400 --> 19:36.920
判断一个数是不是击数

19:37.640 --> 19:39.960
判断一个数是不是击数

19:41.240 --> 19:41.480
好

19:41.480 --> 19:43.000
那么现在用箭头函数来写

19:43.000 --> 19:43.960
你看一下怎么写

19:43.960 --> 19:45.880
首先我给大家写一下完整的写法

19:46.440 --> 19:47.960
如果完整的写法就这样子

19:47.960 --> 19:48.440
number

19:49.320 --> 19:50.200
然后return

19:51.160 --> 19:52.360
是不是要简洁一些了

19:52.360 --> 19:53.320
对不对

19:53.320 --> 19:54.120
还不够

19:54.920 --> 19:57.400
他发现由于你是一个参数

19:57.400 --> 19:58.680
是不是可以省略掉

19:59.240 --> 20:01.400
可以省略掉小货号

20:02.920 --> 20:03.720
再来一种写法

20:04.200 --> 20:05.160
如果你是一个参数

20:05.160 --> 20:06.120
是不是可以省略小货号

20:06.120 --> 20:06.840
刚才说了对吧

20:07.320 --> 20:09.320
那么如果说你只有一条语句

20:09.320 --> 20:11.560
并且这条语句是直接返回的

20:11.560 --> 20:12.040
ok

20:12.040 --> 20:14.280
我就直接给你把返回值放到这

20:14.280 --> 20:14.840
就完事了

20:15.800 --> 20:16.200
没了

20:17.880 --> 20:18.600
那么这东西

20:18.600 --> 20:20.680
这东西一开始肯定是不太适应的

20:21.240 --> 20:21.880
慢慢适应

20:21.880 --> 20:22.520
慢慢适应

20:22.520 --> 20:23.720
以后看那种格式

20:23.720 --> 20:25.160
你发现这里没有大货号

20:25.560 --> 20:26.440
没有大货号的话

20:26.440 --> 20:27.320
这是参数

20:27.320 --> 20:29.400
这是函数返回的东西

20:29.400 --> 20:30.120
返回怎么呢

20:30.120 --> 20:31.240
看一下他是不是不等于0

20:31.240 --> 20:32.280
那就判断是不是击数

20:32.840 --> 20:33.160
好

20:33.160 --> 20:34.120
咱们来看一下

20:34.120 --> 20:35.480
输出1是Od

20:37.800 --> 20:38.920
4

20:38.920 --> 20:40.040
随便写两个

20:40.040 --> 20:40.680
保存

20:40.680 --> 20:41.240
你看一下

20:41.240 --> 20:41.960
2 Force

20:41.960 --> 20:43.000
正常的没问题

20:43.000 --> 20:43.480
对吧

20:44.040 --> 20:45.080
说更加简洁了

20:45.080 --> 20:46.120
当然前提条件

20:46.120 --> 20:47.480
只有一条语句

20:47.480 --> 20:48.280
如果你写了多

20:48.280 --> 20:49.240
要写多条语句

20:49.240 --> 20:51.160
前面还要经过一些运算之类的

20:51.160 --> 20:53.080
那你只能用大货号写函数提

20:53.080 --> 20:54.840
老老实实写Return

20:54.840 --> 20:56.600
但是如果说你只有一条语句

20:56.600 --> 20:58.280
而且这条语句就是返回的结果

20:58.280 --> 20:58.760
那么

20:58.760 --> 21:00.040
你又可以直接这样子写

21:00.040 --> 21:01.400
直接把这个结果返回

21:02.440 --> 21:04.360
那么这个读起来也很好读

21:04.360 --> 21:05.160
怎么读呢

21:05.240 --> 21:07.320
你给我一个这个东西

21:07.320 --> 21:08.200
我给你

21:08.200 --> 21:09.240
你看箭头

21:09.240 --> 21:10.200
你给我它

21:10.200 --> 21:11.240
我就给你它

21:11.240 --> 21:12.920
我把它的结果给你

21:12.920 --> 21:13.960
所以也很好读

21:13.960 --> 21:14.840
也很好阅读

21:14.840 --> 21:15.480
你给我它

21:15.480 --> 21:17.080
我就把它的结果给你

21:17.080 --> 21:17.480
对吧

21:17.480 --> 21:18.840
这是箭头函数

21:18.840 --> 21:20.440
给我一个东西参数

21:20.440 --> 21:21.880
我输出一个东西返回值

21:23.480 --> 21:23.640
好

21:23.640 --> 21:24.360
那么这样子

21:24.360 --> 21:26.040
然而我们去掉大货号的时候

21:26.040 --> 21:27.480
会有一个小的细节

21:27.480 --> 21:28.120
小的细节

21:28.120 --> 21:28.840
就是说

21:28.840 --> 21:31.240
如果说你要返回一个对象的话

21:32.600 --> 21:33.800
你要返回一个对象的话

21:33.880 --> 21:35.400
因为对象它也是个大国号

21:35.400 --> 21:35.960
对不对

21:35.960 --> 21:36.760
那么这个时候

21:36.760 --> 21:37.960
要遇到一点点问题

21:37.960 --> 21:39.160
我们这里再复制一个

21:42.300 --> 21:43.260
比方说啥呢

21:43.260 --> 21:44.140
比方说我们

21:45.180 --> 21:46.060
给

21:46.060 --> 21:47.260
写这么一个函数

21:47.260 --> 21:48.300
上

21:48.300 --> 21:49.820
你给我两个参数a和b

21:50.860 --> 21:52.380
如果说我只给你求和的话

21:52.380 --> 21:53.260
那就直接这样子写

21:53.260 --> 21:53.820
是不是就完了

21:54.460 --> 21:55.180
能看懂吗

21:55.180 --> 21:56.540
你给我两个参数a和b

21:56.540 --> 21:57.980
我给你一个结果a加b

21:59.260 --> 22:01.260
那如果说我要给你一个对象

22:01.260 --> 22:01.740
怎么办呢

22:01.740 --> 22:03.180
比方说我要给你这么一个对象

22:04.140 --> 22:06.060
对象里边写上a

22:06.060 --> 22:07.500
a的值就是a

22:07.500 --> 22:09.100
b的值就是b

22:09.100 --> 22:11.500
之后求和上了只能是a加b

22:11.500 --> 22:12.780
我要给你这么一个对象

22:12.780 --> 22:13.980
它有三个属性

22:13.980 --> 22:14.700
第一个数字

22:14.700 --> 22:15.580
第二个数字

22:15.580 --> 22:16.700
最后求和的结果

22:17.340 --> 22:18.940
那么我们要这样子写怎么写

22:18.940 --> 22:20.380
现在是不是爆错了

22:20.380 --> 22:21.420
为什么爆错了

22:21.420 --> 22:22.220
因为现在呢

22:22.220 --> 22:23.900
他把这个大货号理解成为什么了

22:23.900 --> 22:25.260
理解成为了函数题

22:25.900 --> 22:27.740
他认为你这里写了个函数题

22:27.740 --> 22:29.500
那么函数题里面哪能写这个东西

22:29.500 --> 22:31.020
就像语法错误对吧

22:31.020 --> 22:33.020
你在街市里面能直接写这个东西吗

22:33.740 --> 22:35.740
就相当于是啥呢

22:35.740 --> 22:37.260
就相当于是在函数里边

22:37.260 --> 22:39.500
函数里边你写了什么玩意呢

22:39.500 --> 22:40.380
你写了这个东西

22:40.380 --> 22:40.940
这是啥呀

22:41.500 --> 22:41.980
对吧

22:41.980 --> 22:43.580
他把它理解成函数题了

22:43.580 --> 22:45.020
那如果说你要这样子写的话

22:45.020 --> 22:46.140
完整的写法是什么呢

22:46.140 --> 22:48.140
完整的写法就是return一个对象

22:48.140 --> 22:48.780
这样子写

22:48.780 --> 22:49.100
对吧

22:49.660 --> 22:50.380
是吧这样子写

22:51.020 --> 22:53.420
那么现在就没有用到它的减写模式

22:53.420 --> 22:55.340
因为我们这里不就是一条语句吗

22:55.340 --> 22:56.860
只有一条返回语句

22:56.860 --> 22:58.380
我们不应该可以减写吗

22:58.380 --> 22:59.340
那减写怎么办呢

22:59.340 --> 23:00.140
其实非常简单

23:00.940 --> 23:02.620
减写的方式是这样子

23:02.700 --> 23:05.500
你把这个两个大扣号用一个小扣号扩起来

23:05.500 --> 23:06.300
因为我们知道

23:06.300 --> 23:07.500
用小扣号扩起来之后

23:07.500 --> 23:08.700
它就变成一个表达式了

23:08.700 --> 23:09.180
对吧

23:09.180 --> 23:10.300
那么这一块他告诉他

23:10.300 --> 23:11.340
这是一个表达式

23:11.340 --> 23:12.940
这个表达式呢是一个对象

23:12.940 --> 23:15.420
那么现在他就能理解了

23:15.420 --> 23:17.580
我后面就直接跟的是一个东西

23:17.580 --> 23:18.460
这个东西是什么呢

23:18.460 --> 23:19.820
这个东西是一个对象

23:21.340 --> 23:22.780
你不要直接去书写大扣号

23:22.780 --> 23:24.700
不然的话他会理解成函数题

23:24.700 --> 23:26.380
那么这样子我们看一下

23:26.380 --> 23:28.300
输出上三和四

23:28.300 --> 23:29.180
三和五

23:29.180 --> 23:29.740
保存

23:30.300 --> 23:31.580
你看是不是得到一个结果

23:31.660 --> 23:32.780
A等于3B等于5

23:32.780 --> 23:33.260
上等于8

23:34.700 --> 23:35.100
没问题吧

23:35.820 --> 23:37.260
这就是关于这个小的细节

23:37.260 --> 23:37.980
大家注意一下

23:39.420 --> 23:40.540
那么有了箭头函数过后

23:40.540 --> 23:42.460
我们之后书写函数

23:42.460 --> 23:43.980
是不是变得非常非常棒

23:43.980 --> 23:45.100
特别是书写什么

23:45.100 --> 23:46.940
书写的一些函数表达式的时候

23:46.940 --> 23:48.300
是不是变得特别特别方便了

23:49.180 --> 23:50.300
但是我们接下来

23:50.300 --> 23:52.300
要看一下箭头函数的一些细节

23:53.260 --> 23:54.860
对细节把握好了之后

23:54.860 --> 23:56.300
你才能够去灵活的

23:56.300 --> 23:57.820
去应用箭头函数

23:58.620 --> 23:59.500
我们一个个看

23:59.500 --> 24:00.540
刚才说了

24:00.620 --> 24:03.180
这个箭头函数里边是没有

24:03.180 --> 24:05.020
就是没有

24:05.980 --> 24:08.300
箭头函数里边的Ris是指向的是

24:08.300 --> 24:10.140
函数定义位置的Ris

24:10.140 --> 24:12.060
实际上它真实的情况是什么呢

24:12.060 --> 24:13.180
真实的情况是这个

24:14.940 --> 24:16.380
箭头函数中

24:17.260 --> 24:19.580
没有自己的Ris

24:20.620 --> 24:21.420
argument

24:22.780 --> 24:23.820
怎么new点

24:24.060 --> 24:25.020
new点target

24:26.220 --> 24:27.660
箭头函数里面都没有

24:27.660 --> 24:29.260
可以有的时候有些书籍

24:29.260 --> 24:30.460
或者教程里面会告诉你

24:30.620 --> 24:32.460
箭头函数中不存在这个东西

24:33.020 --> 24:34.300
箭头函数中不存在

24:35.820 --> 24:36.780
不存在这些东西

24:37.580 --> 24:40.060
你要在这里边去用什么Ris

24:40.060 --> 24:41.180
argument

24:41.180 --> 24:43.100
new点target怎么之前学习的

24:43.100 --> 24:43.420
对吧

24:44.140 --> 24:45.180
你要用这个东西

24:45.180 --> 24:46.380
如果去使用了

24:46.380 --> 24:47.420
如果使用了

24:48.300 --> 24:49.660
则使用的是

24:50.780 --> 24:51.420
Y层

24:52.300 --> 24:54.380
就是函数Y层的

24:56.380 --> 24:58.780
对应的Ris

24:59.260 --> 24:59.980
argument

25:01.260 --> 25:02.700
new点target

25:04.540 --> 25:05.660
也就是箭头函数里面

25:05.660 --> 25:07.180
实际上是不存在这个玩意的

25:07.180 --> 25:08.140
不存在Ris的

25:09.020 --> 25:10.620
也就是我们刚才这里

25:10.620 --> 25:12.060
为什么Ris能够生效

25:12.060 --> 25:14.300
因为箭头函数里面根本就没有Ris

25:14.300 --> 25:15.660
你这里用的Ris是

25:15.660 --> 25:16.860
实际上是外面的Ris

25:16.860 --> 25:18.140
它不是这个函数里面的Ris

25:18.140 --> 25:19.260
这个函数里面没有Ris

25:20.380 --> 25:22.540
所以说但是我们平时说的时候

25:23.180 --> 25:24.060
为了让大家好理解

25:24.060 --> 25:25.420
我们就说箭头函数呢

25:25.420 --> 25:27.020
它跟别的函数一样也有Ris

25:27.020 --> 25:27.980
只不过它的Ris呢

25:27.980 --> 25:29.980
指向的是外面函数的Ris

25:30.140 --> 25:31.980
实际上箭头函数里面根本就没有Ris

25:32.780 --> 25:33.420
你要这意思吗

25:34.540 --> 25:35.180
根本就没有

25:35.660 --> 25:37.260
也就是说不管你在这里边去

25:37.260 --> 25:39.020
击掏了多少个箭头函数

25:40.380 --> 25:41.260
不管你在这里边去

25:41.260 --> 25:42.620
击掏了多少个箭头函数

25:43.020 --> 25:43.900
都没有意义

25:43.900 --> 25:45.020
因为这个函数里边

25:45.660 --> 25:46.620
都没有Ris

25:46.620 --> 25:47.420
它里边Ris没有

25:47.420 --> 25:48.940
你看这个函数函数没有Ris

25:48.940 --> 25:50.140
那如果你这里使用Ris

25:50.140 --> 25:50.940
使用的是啥

25:50.940 --> 25:51.980
使用的是外面的

25:51.980 --> 25:53.580
外面这个也是个箭头函数

25:53.580 --> 25:55.260
外面箭头函数也没有Ris

25:55.260 --> 25:56.220
那Ris使用的是

25:56.220 --> 25:57.180
使用的是这里的Ris

25:58.300 --> 25:58.780
你要这意思吗

25:58.780 --> 25:59.660
这是个普通函数

25:59.740 --> 26:00.940
普通函数里边有Ris

26:01.660 --> 26:02.220
你要这意思吧

26:06.060 --> 26:06.780
那么比方说

26:06.780 --> 26:07.980
我就再举个例子

26:07.980 --> 26:09.020
再随便举个例子

26:10.380 --> 26:11.180
比方说

26:11.180 --> 26:13.020
我们写这么一个

26:13.980 --> 26:15.180
Funk一个函数

26:15.180 --> 26:16.780
直接把它写成一个箭头函数

26:16.780 --> 26:18.060
那么我们在这里输出Ris

26:19.660 --> 26:20.700
输出Ris

26:20.700 --> 26:22.060
那么直接去运行这个Funk

26:22.060 --> 26:23.740
那么这个Ris输出为啥

26:24.220 --> 26:25.420
你告诉我这个Ris输出啥

26:26.460 --> 26:28.380
箭头函数里边是没有Ris的

26:28.540 --> 26:30.140
它里边的Ris就是外面的Ris

26:30.140 --> 26:31.740
外面的Ris是Wendel

26:31.740 --> 26:32.220
对吧

26:32.780 --> 26:33.500
是Wendel对象

26:35.500 --> 26:36.060
没问题吧

26:37.500 --> 26:38.380
没问题吧

26:38.380 --> 26:39.100
没问题

26:39.100 --> 26:39.980
好那么接下来

26:39.980 --> 26:40.540
我们再来

26:40.540 --> 26:40.940
再来

26:41.820 --> 26:42.860
如果说我们这样子写

26:45.400 --> 26:46.360
要给它绕一绕

26:46.360 --> 26:47.480
绕一绕

26:47.480 --> 26:48.040
Message

26:48.680 --> 26:48.920
Funk

26:49.720 --> 26:51.720
我们用OBG去调用Message

26:53.160 --> 26:53.960
调用Message

26:54.520 --> 26:55.400
我给你们看到了

26:55.400 --> 26:56.600
为什么给你看到了

26:56.600 --> 26:58.120
那么这个Ris输出啥

26:58.120 --> 26:59.080
这个还是Wendel

26:59.080 --> 26:59.960
怎么来看的

27:00.040 --> 27:00.920
你看一下吧

27:00.920 --> 27:02.520
我们按照如果说一个

27:02.520 --> 27:03.800
正常的函数的话

27:03.800 --> 27:06.440
那么它用对象去调用函数

27:06.440 --> 27:07.880
那么这个函数里边

27:07.880 --> 27:10.360
是不是Ris要指向这个对象本身

27:10.360 --> 27:12.040
但是我们由于使用的是箭头函数

27:12.040 --> 27:13.080
箭头函数函数函数函数函数函数

27:13.080 --> 27:14.520
根本就没有

27:14.520 --> 27:15.480
它没有Ris

27:16.040 --> 27:17.000
它不存在说什么

27:17.000 --> 27:17.880
你要怎么调用

27:17.880 --> 27:19.240
我Ris有指向谁

27:19.240 --> 27:20.120
你要有Apply

27:20.120 --> 27:20.680
绑定

27:20.680 --> 27:21.880
我Ris就指向谁

27:21.880 --> 27:23.000
根本就没有Ris

27:23.400 --> 27:24.440
它没有Ris怎么办

27:24.440 --> 27:25.480
它只能从外面去找

27:25.960 --> 27:26.600
外面去找

27:26.600 --> 27:28.120
外面的Ris还是Wendel

27:28.120 --> 27:28.520
对吧

27:29.240 --> 27:31.400
所以说它根本原因是这么个原因

27:31.400 --> 27:32.200
是这么个原因

27:32.840 --> 27:34.440
这是关于Ris

27:34.440 --> 27:35.080
它的指向

27:35.960 --> 27:36.600
那么同样的

27:36.600 --> 27:37.880
它没有Argument

27:37.880 --> 27:39.080
没有6点Target

27:39.080 --> 27:40.040
这些东西都没有

27:40.040 --> 27:41.720
那比方说我们这里要去输出

27:41.720 --> 27:43.720
输出什么Argument

27:45.080 --> 27:45.560
有吗

27:48.120 --> 27:49.800
我们6点Target就不举例了

27:49.800 --> 27:50.520
拿着去写

27:51.080 --> 27:52.120
就看一下Argument

27:52.120 --> 27:52.920
有没有吗

27:52.920 --> 27:53.640
是没有

27:54.360 --> 27:54.840
没有

27:54.840 --> 27:56.280
哪怕我这里该闯的一些参数

27:56.280 --> 27:56.760
没有

27:56.760 --> 27:57.800
它没有Argument

27:58.280 --> 27:58.840
没有

27:58.840 --> 28:00.360
那么Argument它只想的是外层的

28:00.360 --> 28:01.560
外层的是Windel环境

28:01.560 --> 28:02.120
全球环境

28:02.120 --> 28:03.160
哪有Argument

28:03.160 --> 28:03.720
没有

28:03.720 --> 28:05.320
现在还说没有这些东西

28:05.320 --> 28:05.880
不要这意思吧

28:06.920 --> 28:07.720
那么比方说

28:07.720 --> 28:09.400
如果说我们这样子写了

28:09.400 --> 28:11.000
Masked是一个正常的函数

28:11.000 --> 28:12.040
它是个正常的函数

28:12.760 --> 28:14.440
那么这个函数里边有一个Funk

28:15.960 --> 28:17.400
我们把个写进来

28:18.120 --> 28:18.760
写进来

28:18.760 --> 28:21.000
那么这里输出的是

28:21.560 --> 28:22.760
这些有意出面是题

28:22.760 --> 28:24.040
虽然平时我们开发

28:24.040 --> 28:25.000
都不太用到这些东西

28:25.560 --> 28:26.520
虽然平时我们开发

28:26.520 --> 28:27.720
不太用到这些东西

28:27.960 --> 28:29.320
那么输出这个东西

28:29.320 --> 28:31.320
它问你这个输出啥

28:32.840 --> 28:34.120
虽然这里的Z史输出啥

28:35.800 --> 28:36.280
输出啥

28:37.000 --> 28:38.280
你看这里来调用这个Funk

28:38.680 --> 28:39.720
我们这里调用Masked

28:39.720 --> 28:40.840
都要传那个参数进去

28:40.840 --> 28:41.960
那么这里Z史输出啥

28:42.920 --> 28:43.560
输出啥

28:43.560 --> 28:44.760
现在还说没有Z史

28:44.760 --> 28:45.400
根本就没有

28:45.400 --> 28:46.680
它就往外面找

28:46.680 --> 28:47.720
外面是个普通函数

28:48.280 --> 28:49.960
普通函数你是这样调用的

28:49.960 --> 28:51.320
那么它自然的Z史指向

28:51.320 --> 28:52.120
指向的是OB界

28:52.120 --> 28:53.480
所以说这个Z史毫无疑问

28:53.480 --> 28:54.440
输出OB界

28:54.440 --> 28:55.240
OB界有一个对象

28:57.720 --> 28:58.680
这是一个OB界对象

28:59.640 --> 29:00.760
那么下面这个

29:00.760 --> 29:02.120
有意思的是下面这个

29:02.120 --> 29:04.280
下面这个Orcimint数数啥呢

29:04.280 --> 29:05.160
按你说的话

29:05.160 --> 29:05.880
这是一个函数

29:05.880 --> 29:07.800
Orcimint应该是怎么去调用这个函数的

29:07.800 --> 29:08.200
对吧

29:08.200 --> 29:09.480
然后给它一些参数

29:09.480 --> 29:10.440
那么这里Orcimint

29:10.440 --> 29:11.960
输出的是这个函数的参数

29:11.960 --> 29:13.080
但是很遗憾

29:13.080 --> 29:15.640
减头函数是根本就没有Orcimint的

29:15.640 --> 29:16.680
它只能从外面找

29:16.680 --> 29:17.560
那么这个Orcimint

29:17.560 --> 29:18.200
得到的是啥

29:18.200 --> 29:19.720
得到的是外面函数的参数

29:19.720 --> 29:20.360
到这个

29:20.360 --> 29:21.320
那么这个函数

29:21.320 --> 29:22.680
就给它一个234

29:22.680 --> 29:25.320
因此这个参数里面是包含了234的

29:27.400 --> 29:28.600
理解一下

29:28.600 --> 29:29.560
就减头函数

29:29.720 --> 29:31.800
它其实你可以这样子想象

29:31.800 --> 29:33.240
减头函数它的出现了

29:33.240 --> 29:34.440
就是为了让你去怎么用

29:34.440 --> 29:36.280
就是临时用一下

29:36.280 --> 29:38.200
写一些函数临时用一下

29:38.200 --> 29:39.720
用了就把它扔了

29:39.720 --> 29:40.280
用了就甩

29:41.320 --> 29:43.640
所以它出现是这么一个目的

29:43.640 --> 29:46.600
所以它不要在减头函数里面

29:46.600 --> 29:48.360
轻易去使用Orcimint

29:48.360 --> 29:49.880
或者说你要去使用可以

29:49.880 --> 29:50.760
但是你得清楚它

29:50.760 --> 29:52.200
Orcimint是谁

29:52.200 --> 29:54.200
它本身是没有Orcimint的

29:54.200 --> 29:55.800
Zis我们之前强调过了

29:55.800 --> 29:56.760
它指向的是外称

29:57.880 --> 29:59.080
如果外面还是减头函数的话

29:59.160 --> 30:00.200
继续往外面找

30:00.200 --> 30:01.640
因为减头函数本身没有Zis

30:03.160 --> 30:04.520
好 这是这个注意细节

30:04.520 --> 30:05.320
第二注意细节

30:06.040 --> 30:08.040
减头函数没有圆形

30:09.000 --> 30:10.440
它是没有圆形的

30:10.440 --> 30:13.160
都是临时性用一下就扔的东西

30:13.160 --> 30:14.440
它不会给你加圆形的

30:15.640 --> 30:16.760
所以说减头函数的

30:16.760 --> 30:18.520
要从运行数据上来看

30:18.520 --> 30:20.200
和对内存空间的占用上来看

30:20.200 --> 30:21.480
减头函数的占用内存空间

30:21.480 --> 30:22.920
是非常非常少的

30:22.920 --> 30:23.640
我们来看一下吧

30:23.640 --> 30:25.320
随便写个函数就是Funk

30:25.320 --> 30:26.280
我们来输出一下这个Funk

30:29.530 --> 30:30.490
Funk

30:30.570 --> 30:32.090
然后再输出Funk点Prototype

30:32.650 --> 30:33.210
好 输出

30:34.650 --> 30:36.490
Prototype是Undefend

30:37.210 --> 30:39.930
没有 根本就没有函数元箱

30:39.930 --> 30:40.810
好 我们用Consult

30:41.690 --> 30:42.170
Consult

30:42.730 --> 30:43.370
DIR

30:44.010 --> 30:45.210
来输出一下Funk

30:45.210 --> 30:46.410
因为函数本身是对象

30:46.410 --> 30:47.690
对吧 我们来看一下这个对象

30:48.650 --> 30:49.370
看一下这个对象

30:49.370 --> 30:49.690
里边

30:50.890 --> 30:52.890
里边有什么Arguments

30:52.890 --> 30:53.450
这些东西

30:54.330 --> 30:55.050
一个CPC

30:55.050 --> 30:55.930
一个CPC

30:55.930 --> 30:57.370
你看这些是不是全部爆错了

30:57.370 --> 30:57.770
对吧

30:57.770 --> 30:58.810
你得不到Arguments

30:58.810 --> 30:59.770
拿不到Color

31:00.250 --> 31:01.370
它只有一个名字Funk

31:01.370 --> 31:01.770
没了

31:02.410 --> 31:02.810
没了

31:02.810 --> 31:03.690
有个隐私元型

31:03.690 --> 31:04.730
但它没有Prototype

31:04.730 --> 31:05.370
没有圆形

31:05.930 --> 31:07.450
隐私元型是所有对象都有的

31:08.170 --> 31:09.450
但是它没有圆形

31:09.770 --> 31:10.010
对吧

31:11.450 --> 31:12.010
由于

31:12.650 --> 31:14.170
间头函数没有圆形

31:14.170 --> 31:14.970
所以呢

31:14.970 --> 31:17.210
间头函数不能

31:17.930 --> 31:20.010
作为勾兆函数使用

31:21.450 --> 31:22.170
当然也没有

31:22.730 --> 31:23.530
没有这样的人

31:24.410 --> 31:25.370
这样神经病吧

31:25.370 --> 31:27.370
你把间头函数当成勾兆函数去使用

31:27.370 --> 31:28.410
你不能去丢一个Funk

31:29.130 --> 31:30.010
你不能这样去做

31:30.650 --> 31:31.050
你看一下

31:31.050 --> 31:31.610
是不是爆错了

31:32.570 --> 31:32.970
它说

31:32.970 --> 31:34.010
它不是一个勾兆函数

31:34.010 --> 31:35.530
间头函数不可能是勾兆函数的

31:35.530 --> 31:36.410
它圆形都没有

31:36.890 --> 31:37.690
因为我们知道

31:37.690 --> 31:39.130
勾兆函数它的作用就是

31:39.130 --> 31:40.410
以生成的一个听的对象

31:40.410 --> 31:41.610
它有一条圆形链对吧

31:41.610 --> 31:43.210
它指向那个函数的圆形

31:43.210 --> 31:44.410
但是它圆形都没有

31:44.410 --> 31:45.770
哪能用于勾兆函数呢

31:45.770 --> 31:46.410
不可以

31:46.410 --> 31:46.810
不能

31:48.090 --> 31:49.610
这就是间头函数的使用细节

31:50.250 --> 31:51.690
那么这些使用细节

31:51.690 --> 31:54.090
就决定了间头函数的应用场景

31:54.810 --> 31:55.610
什么应用场景呢

31:56.170 --> 31:56.490
就是

31:59.370 --> 32:00.650
使用的函数

32:01.210 --> 32:02.330
函字性使用的函数

32:02.330 --> 32:03.210
我并不会去

32:03.210 --> 32:04.730
并不会去刻意调用它

32:05.530 --> 32:06.090
并非

32:07.450 --> 32:10.890
并不会刻意调用它

32:10.890 --> 32:11.770
这是地动场景

32:13.770 --> 32:14.570
写个函数

32:14.570 --> 32:15.770
这个函数就是凌识用一下

32:15.770 --> 32:17.130
并不会刻意去调用它

32:17.130 --> 32:17.930
像什么函数呢

32:17.930 --> 32:18.410
比方说

32:19.130 --> 32:19.610
比如

32:19.610 --> 32:20.810
下面一个比如

32:22.730 --> 32:23.370
事件

32:23.370 --> 32:24.730
事件处理函数

32:24.730 --> 32:25.530
事件处理函数

32:25.530 --> 32:27.610
你可以给它写一个函数名称吗

32:27.690 --> 32:28.650
通常不会吧

32:28.650 --> 32:29.130
对吧

32:29.130 --> 32:30.330
就是我告诉它

32:30.330 --> 32:31.290
发生某年少的时候

32:31.290 --> 32:32.570
来去运行这个函数

32:32.570 --> 32:34.970
我也自己也不会去调用它

32:34.970 --> 32:35.370
对吧

32:35.370 --> 32:36.410
就事件处理函数

32:36.410 --> 32:37.850
可以使用间头函数

32:37.850 --> 32:39.450
当然你要注意它里面的认识

32:39.450 --> 32:40.170
会变化

32:40.170 --> 32:40.970
它里面没有

32:40.970 --> 32:42.010
它没有自己的认识

32:42.890 --> 32:43.530
另外一个

32:43.530 --> 32:45.290
事件处理函数

32:45.290 --> 32:46.330
还有什么呢

32:46.330 --> 32:47.210
还有就是那个

32:47.210 --> 32:47.690
一一步

32:48.410 --> 32:49.450
处理函数

32:49.450 --> 32:50.650
像set time out

32:50.650 --> 32:51.370
set interval

32:51.930 --> 32:52.970
大胆的去使用

32:52.970 --> 32:54.090
间头函数

32:54.090 --> 32:56.810
因为你从来不会在set interval里面使用它

32:56.890 --> 32:58.170
它里面那个温度对象

32:58.170 --> 32:59.530
Z指向的温度对象吧

32:59.530 --> 33:00.010
不会吧

33:00.650 --> 33:02.650
你在set interval里面会不会使用Z啊

33:04.010 --> 33:05.930
哪怕你想使用Z

33:05.930 --> 33:07.050
往往是这样的场景

33:07.770 --> 33:08.810
往往是这样的场景

33:08.810 --> 33:10.730
你希望使用的是这个对象的Z

33:10.730 --> 33:12.490
而不是set interval里面的Z

33:12.490 --> 33:15.050
所以这里用间头函数是非常非常合适的

33:15.050 --> 33:17.930
并且在VSCode里面有个代码段生成工具

33:17.930 --> 33:18.810
你写上

33:18.810 --> 33:20.170
set interval按两下

33:20.170 --> 33:20.570
按一下

33:22.810 --> 33:23.210
按两下

33:23.210 --> 33:23.850
太不见

33:23.850 --> 33:24.970
它会一生存的就是

33:24.970 --> 33:26.330
间头函数的格式

33:26.410 --> 33:27.290
因为这里边的Z是

33:27.290 --> 33:29.370
我们就是希望它指向的外层Z

33:29.370 --> 33:31.690
我不会用它里边真正的Z

33:32.490 --> 33:33.050
对吧

33:33.050 --> 33:34.010
一步处理函数

33:34.650 --> 33:35.530
像这种情况

33:36.570 --> 33:37.290
还有什么呢

33:37.290 --> 33:38.570
还有一些就是

33:38.570 --> 33:40.250
零实性的函数

33:40.250 --> 33:41.690
其他零实性的函数

33:43.530 --> 33:44.570
就是你写了一下

33:44.570 --> 33:46.010
马上就把它调用一下

33:46.010 --> 33:46.570
就完事了

33:47.530 --> 33:49.450
这是这种应用场景

33:49.450 --> 33:51.210
第二种应用场景的就是

33:51.290 --> 33:52.570
为了绑定

33:53.290 --> 33:56.730
外层Z的函数

33:56.730 --> 33:57.770
像这种函数

33:57.770 --> 33:59.530
它要绑定外层的Z

34:00.090 --> 34:02.250
那么我们也可以为了实现这个效果

34:02.250 --> 34:03.210
去使用

34:03.210 --> 34:04.330
间头函数

34:04.330 --> 34:05.210
因为间头函数里边

34:05.210 --> 34:05.770
它没有Z

34:05.770 --> 34:07.450
它一定使用了是外面的Z

34:08.250 --> 34:08.490
好

34:08.490 --> 34:09.290
第三种我要

34:09.290 --> 34:10.970
因为我们都举过例子

34:10.970 --> 34:12.490
第三种我要可以说一下

34:12.490 --> 34:12.970
就是

34:14.010 --> 34:14.890
数组中

34:16.490 --> 34:20.650
数组中的回调函数

34:20.730 --> 34:22.650
我们通常都会使用

34:22.650 --> 34:24.570
数组方法中的回调函数

34:24.570 --> 34:26.970
通常都会使用间头函数

34:26.970 --> 34:28.730
这样子主要是为了简洁

34:30.010 --> 34:31.130
不要第三个特点

34:31.130 --> 34:31.930
三个应用场景是

34:33.610 --> 34:36.010
在不影响

34:37.610 --> 34:39.530
其他代码的情况下

34:40.890 --> 34:42.970
保持代码的简洁

34:42.970 --> 34:44.170
像这种场景呢

34:44.170 --> 34:46.090
我们也可以使用间头函数

34:46.090 --> 34:46.730
因为间头函数

34:46.730 --> 34:48.410
凶起来非常的简洁

34:48.410 --> 34:49.770
也不是为了使用Z

34:49.770 --> 34:51.370
也不是为了使用什么

34:54.970 --> 34:56.490
主要是不是为了使用Z

34:56.490 --> 34:57.450
不是为了绑定Z

34:57.450 --> 34:58.810
只是为了保持代码的简洁

34:58.810 --> 35:00.490
有的时候我们也会使用

35:01.210 --> 35:02.090
间头函数

35:02.090 --> 35:04.730
这种最常见的

35:04.730 --> 35:05.930
最常见的

35:05.930 --> 35:08.090
就是数组方法中的回调函数

35:08.730 --> 35:08.890
好

35:08.890 --> 35:09.530
我们来看一下吧

35:12.820 --> 35:13.620
我们这里有个数组

35:14.660 --> 35:15.220
numbers

35:16.340 --> 35:16.900
有个数组

35:16.900 --> 35:17.540
随便写一些吧

35:18.340 --> 35:19.860
我们数组里边不是有很多方法吗

35:20.500 --> 35:21.620
比方说什么方法

35:22.260 --> 35:22.820
map

35:22.820 --> 35:23.300
对吧

35:23.300 --> 35:24.020
硬设

35:24.020 --> 35:26.500
把一个数组硬设成为一个新的数组

35:26.500 --> 35:28.500
比方说把所有的数字乘以2

35:28.500 --> 35:29.380
以前咋写的

35:29.380 --> 35:30.020
是不是要这样写

35:30.660 --> 35:31.380
方形

35:31.380 --> 35:32.500
你给我一个number

35:32.500 --> 35:32.900
对吧

35:32.900 --> 35:34.980
我给你返回一个number乘以2

35:35.620 --> 35:36.580
是不是挺麻烦的

35:36.580 --> 35:38.180
我们这里得到一个结果吧

35:38.180 --> 35:38.660
result

35:40.500 --> 35:41.460
输出result

35:42.260 --> 35:42.820
看一下吧

35:43.460 --> 35:44.100
没什么好说的

35:44.740 --> 35:45.780
是不是很麻烦

35:45.780 --> 35:46.020
好

35:46.020 --> 35:46.980
那么现在呢

35:46.980 --> 35:49.460
我们有了间头函数过来看一下

35:49.460 --> 35:49.780
来吧

35:50.420 --> 35:51.220
你给我一个数字

35:52.180 --> 35:53.060
我给你什么呢

35:53.060 --> 35:54.260
我给你满不满足条件

35:54.820 --> 35:55.780
是不是满足条件

35:55.780 --> 35:56.820
条件是

35:56.820 --> 35:58.180
给你一个新的数字

35:58.180 --> 35:58.820
那么乘以2

35:59.380 --> 36:00.020
是不是写完了

36:01.300 --> 36:02.900
间头函数是不是特别简洁

36:03.220 --> 36:03.460
对吧

36:04.020 --> 36:05.300
是不是写的是间头函数了

36:05.300 --> 36:05.460
好

36:05.460 --> 36:07.540
那么这个整个整体是一个数组

36:07.540 --> 36:07.780
对吧

36:07.780 --> 36:08.420
我们又可以来

36:08.420 --> 36:09.140
比方说factor

36:10.260 --> 36:11.140
factor

36:11.140 --> 36:12.900
我们要去掉什么呢

36:12.900 --> 36:13.620
去掉

36:13.620 --> 36:14.980
我们先去掉吧

36:14.980 --> 36:16.340
先去掉技术

36:18.260 --> 36:19.380
先去掉技术

36:19.380 --> 36:20.340
factor

36:20.420 --> 36:20.820
factor

36:20.820 --> 36:21.780
我们以前咋写的

36:21.780 --> 36:23.220
是不是给我一个数字

36:23.220 --> 36:24.820
我给你返回是不是正确的

36:24.820 --> 36:25.380
对吧

36:25.380 --> 36:26.180
是不是

36:26.180 --> 36:27.060
we true还是 false

36:27.060 --> 36:27.620
we true的话

36:27.620 --> 36:28.180
保留

36:28.180 --> 36:29.300
we false的话

36:29.300 --> 36:30.020
移除

36:30.020 --> 36:30.660
那么这里呢

36:30.660 --> 36:31.940
我们就可以用间头函数

36:31.940 --> 36:33.380
你给我一个数字

36:33.380 --> 36:34.980
这个数字到底要不要保留呢

36:34.980 --> 36:36.260
那么除以2

36:36.260 --> 36:36.820
不等于0

36:38.100 --> 36:39.300
只保留技术

36:39.300 --> 36:40.100
去掉技术吧

36:40.100 --> 36:41.460
那就保留偶数

36:41.460 --> 36:42.340
只保留偶数

36:42.820 --> 36:43.220
来看

36:43.220 --> 36:44.020
我们换个行

36:44.020 --> 36:44.580
那这样蛋吧

36:44.580 --> 36:45.300
是不是特别简洁

36:46.580 --> 36:47.380
来看一下

36:47.380 --> 36:48.580
是不是只保留偶数

36:48.580 --> 36:49.220
只保留偶数

36:49.220 --> 36:49.460
好像

36:50.660 --> 36:51.780
只保留偶数

36:51.780 --> 36:53.060
好像只有一个78是吧

36:53.060 --> 36:54.020
那只保留技术

36:55.620 --> 36:56.420
只保留技术

36:56.420 --> 36:57.140
是不是少了一个

36:57.860 --> 36:58.180
对吧

37:00.020 --> 37:00.660
那么比方说

37:00.660 --> 37:01.700
我们再求和

37:01.700 --> 37:02.660
再求和

37:02.660 --> 37:03.860
reduce

37:03.860 --> 37:04.660
求和的话

37:04.660 --> 37:05.700
以前咋写的

37:05.700 --> 37:07.220
是方形ab

37:07.220 --> 37:07.860
对吧

37:07.860 --> 37:08.260
ab

37:08.260 --> 37:10.500
然后返回什么a加b

37:10.500 --> 37:10.980
对吧

37:10.980 --> 37:11.860
是这样写的

37:11.860 --> 37:13.220
有了间头函数过后

37:13.220 --> 37:13.620
你看一下

37:14.660 --> 37:15.220
两个拆数

37:15.220 --> 37:15.860
a和b

37:15.860 --> 37:18.980
间头a加b

37:18.980 --> 37:19.940
读起来非常好读

37:19.940 --> 37:20.580
而且

37:20.580 --> 37:21.540
当然你现在不习惯

37:21.620 --> 37:23.220
觉得好像很难理解

37:23.220 --> 37:23.460
一样

37:23.460 --> 37:24.740
其实很好读的

37:24.740 --> 37:26.020
feel什么呢

37:26.020 --> 37:26.500
过滤

37:26.500 --> 37:26.900
对吧

37:26.900 --> 37:27.940
按照条件过滤

37:27.940 --> 37:28.820
你给我一个数字

37:28.820 --> 37:29.460
满不满条件

37:29.460 --> 37:30.500
条件就是

37:30.500 --> 37:31.700
是不是击数

37:31.700 --> 37:33.780
除了不等于你就是击数

37:33.780 --> 37:35.140
保留那些是击数的

37:37.060 --> 37:37.300
对

37:37.300 --> 37:38.420
保留是击数的

37:38.420 --> 37:39.620
然后硬设

37:39.620 --> 37:41.460
江源亮的数字乘以2

37:41.460 --> 37:43.060
是不是非常好读啊

37:43.060 --> 37:43.540
求

37:43.540 --> 37:44.900
然后然后我们累计

37:44.900 --> 37:45.700
累计的话

37:45.700 --> 37:47.700
把两个把数字相加

37:47.700 --> 37:48.100
求和

37:49.300 --> 37:50.340
最后就是求和的结果

37:52.100 --> 37:53.140
间头函数以后

37:53.140 --> 37:54.580
我们会经常使用

37:54.580 --> 37:55.540
所以说这节课

37:55.540 --> 37:57.220
咱们在课堂上

37:57.220 --> 37:58.500
举的例子呢

37:58.500 --> 37:59.540
大家下去呢

37:59.540 --> 38:01.460
一定要好好去消化

38:01.460 --> 38:02.820
尽量的去每个例子

38:02.820 --> 38:04.020
自己去写一下

38:04.020 --> 38:04.420
而且呢

38:04.420 --> 38:05.460
甚至可以自己去想写

38:05.460 --> 38:06.260
例子出来

38:06.260 --> 38:07.380
去书写一下

38:07.380 --> 38:08.100
以后呢我们

38:10.260 --> 38:11.060
间头函数呢

38:11.060 --> 38:12.420
在很多场地都会用到

38:12.420 --> 38:13.300
就像我们刚才说的

38:13.300 --> 38:14.020
这些场景

38:14.020 --> 38:15.140
都会用到间头函数

38:15.140 --> 38:16.980
所以一定要非常非常熟悉

38:16.980 --> 38:17.700
但是有一个地方

38:17.700 --> 38:18.900
是不会用间头函数的

38:18.900 --> 38:19.540
什么地方呢

38:21.560 --> 38:22.200
就这个地方

38:23.880 --> 38:25.080
对象的属性

38:25.080 --> 38:26.680
我们是不会用间头函数的

38:26.680 --> 38:27.640
为什么不会用

38:27.640 --> 38:28.680
我们之前已经说过了

38:29.640 --> 38:30.760
它会导致一个问题

38:30.760 --> 38:31.080
对吧

38:32.360 --> 38:33.880
除非你有特别特别的需求

38:34.600 --> 38:35.080
不然的话

38:35.080 --> 38:36.440
用间头函数会导致一个问题

38:36.440 --> 38:37.400
它会指向外称的

38:37.400 --> 38:37.960
Z

38:38.520 --> 38:39.800
如果说你直接写的对象的话

38:39.800 --> 38:41.000
它就指向的是Windows

38:41.880 --> 38:42.440
好吧

38:42.440 --> 38:42.600
好

38:42.600 --> 38:44.520
这关于间头函数的这些东西

38:45.560 --> 38:45.800
好

38:45.800 --> 38:47.000
那么这函数这一张呢

38:47.000 --> 38:48.440
咱们就到此结束了

38:48.440 --> 38:49.640
最重要的就是间头函数

38:49.640 --> 38:50.040
小大家好

38:50.040 --> 38:50.600
去练一下

