WEBVTT

00:00.940 --> 00:04.740
好了 同学们 我们到现在呢 我们一切都准备好了

00:04.740 --> 00:09.540
我们可以通过result和reject来改变promise的状态

00:09.540 --> 00:15.540
也可以通过这种方法来给promise增加一些执行函数

00:15.540 --> 00:18.340
那么这些函数呢 会放到一个队列里面

00:18.340 --> 00:20.540
这个队列里面 你看 就是一个数组

00:20.540 --> 00:24.940
将来实际成熟之后 我们会循环遍地这个队列

00:24.940 --> 00:29.940
然后呢 一次拿出来每一个执行器 我们一次去处理它

00:29.940 --> 00:32.940
一切都准备好了 就差最后一步了

00:32.940 --> 00:36.940
所以我们这些可能就来实现这个方法

00:36.940 --> 00:41.940
处理一个运行一个执行器 运行一个处理器

00:41.940 --> 00:44.940
那么这个方法里面呢 我们一旦实现好了

00:44.940 --> 00:48.940
我们整个promiseA加规范就全部实现了

00:48.940 --> 00:50.940
好 我们来实现这个方法

00:50.940 --> 00:52.940
这个方法里面有个参数叫Handler

00:52.940 --> 00:55.940
这个Handler是什么呢 其实就是这里的对象

00:55.940 --> 00:57.940
对不对 每一个对象

00:57.940 --> 01:02.940
那么通过循环遍地的方式 一次给它传过来

01:02.940 --> 01:05.940
那么这个对象拿到之后 我们要做什么事情呢

01:05.940 --> 01:08.940
首先我们回忆一下 任方法

01:08.940 --> 01:12.940
这个对象里面是不是包含了任方法传递的函数啊

01:12.940 --> 01:15.940
对吧 我们这个函数是不是就传过来的

01:15.940 --> 01:18.940
那么这个函数我们知道 是要放到一个V队列里面执行

01:18.940 --> 01:20.940
所以说呢 整个的处理过程

01:20.940 --> 01:23.940
我们是否会把它放到V队列里面去进行处理

01:23.940 --> 01:26.940
而V队列呢 我们之前是不是写过这么一个函数

01:26.940 --> 01:28.940
叫做Rom Microtask

01:28.940 --> 01:30.940
那么我们现在利用这个函数

01:30.940 --> 01:33.940
找到这个Rom Microtask

01:33.940 --> 01:35.940
然后我们这里边给它传一个函数进去

01:35.940 --> 01:37.940
也就是我们现在把这个函数呢

01:37.940 --> 01:42.940
就把整个处理过程放到一个V队列里面

01:42.940 --> 01:44.940
然后这个函数里面做什么事情呢

01:44.940 --> 01:46.940
我们现在来分析它的逻辑

01:46.940 --> 01:49.940
那么比方说 我目前的状态

01:49.940 --> 01:54.940
我现在把这个地方 把这个地方打印放这儿吧

01:55.940 --> 01:56.940
放这儿

01:58.940 --> 02:00.940
我们输出一下

02:00.940 --> 02:04.770
输出一下这个Handle

02:04.770 --> 02:05.770
好 运行啊

02:05.770 --> 02:08.770
那么现在我们输出了四次 对吧

02:08.770 --> 02:15.640
我们再来输出一下我们当前的状态

02:15.640 --> 02:19.640
当前的状态是this state

02:19.640 --> 02:20.640
好 我们运行一下

02:20.640 --> 02:23.640
你看一下我们目前的状态是fulfilled的

02:23.640 --> 02:24.640
为什么是fulfilled的呢

02:24.640 --> 02:26.640
是因为我这里用了result

02:26.640 --> 02:28.640
当然如果说我这里改成了reject

02:28.640 --> 02:30.640
它自然就变了 变成了reject

02:30.640 --> 02:32.640
那么这是我们目前的状态

02:32.640 --> 02:34.640
然后这里有一个handle

02:34.640 --> 02:35.640
handle是一个对象

02:35.640 --> 02:37.640
对象里面也有一个状态

02:37.640 --> 02:39.640
那么这个状态是什么意思呢

02:39.640 --> 02:41.640
表示的是当什么什么的时候

02:41.640 --> 02:43.640
我要执行这个函数

02:43.640 --> 02:44.640
对不对

02:44.640 --> 02:45.640
那么这里会有一个逻辑

02:45.640 --> 02:48.640
就是如果说我这个状态跟这个状态不一致

02:48.640 --> 02:50.640
那这个函数值不止小

02:50.640 --> 02:51.640
是不止小

02:51.640 --> 02:53.640
因为它需要的是这个状态

02:53.640 --> 02:55.640
但是我们目前是这个状态

02:55.640 --> 02:56.640
就状态不一致

02:56.640 --> 02:58.640
不一致的话就什么也不做

02:58.640 --> 03:00.640
对吧 这个好理解 对不对

03:00.640 --> 03:01.640
好 咱们来看一下

03:01.640 --> 03:04.640
所以说这里可以首先解说这么一个判断

03:04.640 --> 03:07.640
如果说我们目前的状态

03:07.640 --> 03:10.640
不等于handle里面的状态

03:10.640 --> 03:13.640
那么这个时候我们就啥也不做

03:13.640 --> 03:14.640
状态不匹配

03:14.640 --> 03:16.640
就你传了 传没传函数 传了

03:16.640 --> 03:18.640
但是由于我们状态不匹配

03:18.640 --> 03:21.640
你说的是要失败之后运行

03:21.640 --> 03:22.640
你要成功之后运行

03:22.640 --> 03:24.640
但是我们目前是失败的

03:24.640 --> 03:26.640
所以就传了 跟没传一样

03:26.640 --> 03:28.640
那么这里表示的是

03:28.640 --> 03:31.640
状态不一致

03:31.640 --> 03:34.640
这个函数达不到执行的条件

03:34.640 --> 03:36.640
所以说不处理

03:36.640 --> 03:38.640
不做任何处理

03:38.640 --> 03:39.640
这是这种情况

03:39.640 --> 03:40.640
那么这种情况

03:40.640 --> 03:41.640
我们把筛选出去之后

03:41.640 --> 03:42.640
我们再来看

03:42.640 --> 03:44.640
还剩下哪些handle了

03:44.640 --> 03:45.640
是不是就筛选掉了一些了

03:45.640 --> 03:46.640
我们只剩下什么了

03:46.640 --> 03:48.640
状态保持一致的

03:48.640 --> 03:49.640
看没

03:49.640 --> 03:51.640
好 状态保持一致的情况下

03:51.640 --> 03:53.640
一看是不是还有一种情况

03:53.640 --> 03:56.640
就是它传的不是函数

03:56.640 --> 03:57.640
它传的可能是nd半的

03:57.640 --> 03:58.640
比较像这儿

03:58.640 --> 03:59.640
它第二参数没传

03:59.640 --> 04:00.640
第二参数没传

04:00.640 --> 04:02.640
相当于是传了一个nd半的

04:02.640 --> 04:03.640
那么也有可能

04:03.640 --> 04:04.640
第二参数传了

04:04.640 --> 04:05.640
传的是mao

04:05.640 --> 04:06.640
或者传的是123

04:06.640 --> 04:07.640
传的是一个制服串

04:07.640 --> 04:08.640
传的是一个对象

04:08.640 --> 04:10.640
总之不是一个正常的函数

04:10.640 --> 04:11.640
懂了意思吧

04:11.640 --> 04:13.640
那么这些都是无效的传递

04:13.640 --> 04:14.640
所以说我们这里

04:14.640 --> 04:16.640
还要判断这种情况

04:16.640 --> 04:18.640
好 这里我们判断一下

04:18.640 --> 04:21.640
如果说你给我传的函数

04:21.640 --> 04:23.640
状态一致了 没问题了

04:23.640 --> 04:24.640
那状态一致

04:24.640 --> 04:26.640
但是你给我传的xqt

04:26.640 --> 04:27.640
它不是一个函数

04:27.640 --> 04:29.640
怎么来看它是不是函数呢

04:29.640 --> 04:30.640
太可恶了

04:30.640 --> 04:33.640
是不是等于方形

04:33.640 --> 04:36.950
如果说你不是一个函数

04:36.950 --> 04:40.950
这就是传递的处理

04:40.950 --> 04:43.950
后续处理

04:43.950 --> 04:45.950
并非一个函数

04:45.950 --> 04:46.950
那么它不是函数

04:46.950 --> 04:48.950
大家回顾一下

04:48.950 --> 04:49.950
要好好回顾一下

04:49.950 --> 04:51.950
它是怎么处理的

04:51.950 --> 04:52.950
它是不处理吗

04:52.950 --> 04:54.950
还是会做一些处理

04:54.950 --> 04:57.950
它如果传的不是函数

04:57.950 --> 04:59.950
如果说前边的知识

04:59.950 --> 05:01.950
学的比较细的同学

05:01.950 --> 05:03.950
应该能够回忆得起来

05:03.950 --> 05:05.950
当你有一些参数

05:05.950 --> 05:06.950
是无效的参数

05:06.950 --> 05:07.950
或者是你没有传递

05:07.950 --> 05:09.950
就是我们之前说的什么

05:09.950 --> 05:12.950
之前说的状态穿透

05:12.950 --> 05:13.950
比方说这里

05:13.950 --> 05:14.950
反回一个promise2

05:14.950 --> 05:16.950
任方法会反回一个新的promise

05:16.950 --> 05:18.950
我们说这个promise的状态

05:18.950 --> 05:19.950
是什么呢

05:19.950 --> 05:22.950
如果说它失败了

05:22.950 --> 05:26.950
但是我没有失败的处理

05:26.950 --> 05:28.950
那么它的状态

05:28.950 --> 05:31.950
跟它保持完全一致

05:31.950 --> 05:33.950
它这个状态已经确定了

05:33.950 --> 05:35.950
无论是成功还是失败

05:35.950 --> 05:38.950
但是它找不到相关的处理

05:38.950 --> 05:39.950
这种找不到什么情况

05:39.950 --> 05:40.950
你没有传

05:40.950 --> 05:42.950
或者是你传的不是一个函数

05:42.950 --> 05:44.950
都是没有相关处理

05:44.950 --> 05:45.950
那么这种情况下

05:45.950 --> 05:46.950
我们要穿透

05:46.950 --> 05:47.950
它的状态是什么

05:47.950 --> 05:48.950
它就是什么

05:48.950 --> 05:50.950
它成功它就成功

05:50.950 --> 05:51.950
它的数据是什么

05:51.950 --> 05:52.950
它就失败

05:52.950 --> 05:53.950
它就失败

05:53.950 --> 05:54.950
它的失败原因是什么

05:54.950 --> 05:55.950
它就失败

05:55.950 --> 05:56.950
懂了意思吧

05:56.950 --> 05:58.950
那我们这里也是一样的逻辑

05:58.950 --> 06:00.950
如果说你够传的处理函数

06:00.950 --> 06:02.950
处理其他不是一个函数

06:02.950 --> 06:03.950
不是函数的话

06:03.950 --> 06:06.950
那么我这个promise是什么状态

06:06.950 --> 06:08.950
你也跟着是什么状态

06:08.950 --> 06:09.950
如果说我成功了

06:09.950 --> 06:11.950
你要调这个result

06:11.950 --> 06:13.950
如果说我失败了

06:13.950 --> 06:14.950
你要调这个result

06:14.950 --> 06:15.950
所以说这里

06:15.950 --> 06:17.950
我们就直接用个三目运算服务

06:17.950 --> 06:19.950
如果说我的状态

06:19.950 --> 06:20.950
是什么

06:20.950 --> 06:22.950
是full field

06:22.950 --> 06:26.970
如果说我这个状态是这个

06:26.970 --> 06:27.970
我成功了

06:27.970 --> 06:29.970
如果说我成功了的话

06:29.970 --> 06:32.970
我要调用handle的result

06:32.970 --> 06:33.970
调用这个

06:33.970 --> 06:35.970
那么数据是什么呢

06:35.970 --> 06:36.970
就是我的数据

06:36.970 --> 06:38.970
叫做状态穿透

06:38.970 --> 06:40.970
如果说我失败了

06:40.970 --> 06:42.970
那么我就要调用handle

06:42.970 --> 06:44.970
dirty jigs

06:44.970 --> 06:46.970
好

06:46.970 --> 06:48.970
然后我给它数据是什么呢

06:49.970 --> 06:52.970
这就是处理这么一种情况

06:52.970 --> 06:53.970
好

06:53.970 --> 06:54.970
那咱们来试一下

06:54.970 --> 06:56.970
试一下看是不是真的是这样

06:56.970 --> 06:57.970
比方说

06:57.970 --> 07:00.970
我们这里把这个组织掉

07:00.970 --> 07:02.970
现在我们一秒

07:02.970 --> 07:04.970
也就是一段时间之后

07:04.970 --> 07:06.970
一秒钟之后

07:06.970 --> 07:07.970
一秒钟之后

07:07.970 --> 07:09.970
这个promise失败了

07:09.970 --> 07:10.970
那么失败

07:10.970 --> 07:11.970
它又没有失败的处理函数

07:11.970 --> 07:12.970
没有

07:12.970 --> 07:14.970
那么它正反回的promise

07:14.970 --> 07:15.970
也会跟着失败

07:15.970 --> 07:16.970
失败的原因

07:16.970 --> 07:17.970
跟这里的原因是一样的

07:17.970 --> 07:19.970
那我们来试一下

07:19.970 --> 07:20.970
我通过一段时间

07:20.970 --> 07:21.970
比方说我们这里

07:21.970 --> 07:24.970
在它冒着之后

07:24.970 --> 07:25.970
两秒钟

07:25.970 --> 07:26.970
或者一千五万秒

07:26.970 --> 07:27.970
一千五万毫秒

07:27.970 --> 07:29.970
然后我们输出promise二

07:29.970 --> 07:30.970
一

07:30.970 --> 07:32.970
promise一和promise二

07:32.970 --> 07:35.970
看一下两个状态是不是一致的

07:35.970 --> 07:37.970
一点五秒之后

07:37.970 --> 07:38.970
你看

07:38.970 --> 07:40.970
两个promise的状态

07:40.970 --> 07:41.970
是不是都是为解决体的

07:41.970 --> 07:42.970
对吧

07:42.970 --> 07:43.970
只都是一

07:43.970 --> 07:44.970
特别问题吧

07:44.970 --> 07:46.970
所以这要状态的穿透

07:46.970 --> 07:47.970
那么同样的道理

07:47.970 --> 07:48.970
如果说我没有

07:48.970 --> 07:50.970
连成功都没有传统

07:50.970 --> 07:51.970
这里如果说成功了

07:51.970 --> 07:52.970
宇宙

07:52.970 --> 07:53.970
我这里成功了

07:53.970 --> 07:56.970
但是我这里没有处理成功的函数

07:56.970 --> 07:57.970
对吧

07:57.970 --> 07:58.970
然后我们来再试一下

07:58.970 --> 08:01.790
你看

08:01.790 --> 08:02.790
是不是两个状态都是成功的

08:02.790 --> 08:03.790
对吧

08:03.790 --> 08:05.790
这就是我们想要的一个结果

08:05.790 --> 08:06.790
懂了意思吗

08:06.790 --> 08:07.790
好

08:07.790 --> 08:12.150
把这个注射掉

08:12.150 --> 08:13.150
再取消注射

08:13.150 --> 08:17.450
好

08:17.450 --> 08:18.450
现在我们回到这

08:18.450 --> 08:19.450
继续来编写

08:19.450 --> 08:20.450
这个邏輯

08:20.450 --> 08:21.450
现在我们什么情况呢

08:21.450 --> 08:23.450
现在我们的情况就是

08:23.450 --> 08:24.450
一秒钟之后

08:24.450 --> 08:26.450
现在的状态要处理的

08:26.450 --> 08:27.450
而进行处理的

08:27.450 --> 08:29.450
然后我们这里搞定了什么呢

08:29.450 --> 08:31.450
搞定了就是

08:32.450 --> 08:33.450
处理

08:33.450 --> 08:35.450
它处理器不是一个函数的情况

08:35.450 --> 08:36.450
对吧

08:36.450 --> 08:37.450
这种情况我们搞定了

08:38.450 --> 08:40.450
传练到后续处理并非一个函数

08:40.450 --> 08:41.450
那么我们看一下

08:41.450 --> 08:42.450
剩下还有什么情况

08:43.450 --> 08:45.950
行

08:46.950 --> 08:47.950
好

08:47.950 --> 08:48.950
剩下的就是一个正常的函数了

08:48.950 --> 08:49.950
对吧

08:49.950 --> 08:50.950
状态也一致

08:50.950 --> 08:51.950
也是一个正常的函数

08:51.950 --> 08:52.950
那么这个时候怎么处理呢

08:52.950 --> 08:54.950
是不是要执行这个函数

08:55.950 --> 08:56.950
对不对

08:56.950 --> 08:58.950
而且我们知道之前怎么说的

08:58.950 --> 09:00.950
我们这个Promise的状态

09:00.950 --> 09:01.950
应该取决于什么呢

09:01.950 --> 09:03.950
取决于这边的执行的函数

09:03.950 --> 09:05.950
比方说我们这里有个data

09:05.950 --> 09:08.650
输出data

09:08.650 --> 09:10.650
返回一个1

09:10.650 --> 09:11.650
返回一个123

09:11.650 --> 09:12.650
比方说

09:12.650 --> 09:14.650
我们这里有Riddle

09:15.650 --> 09:16.650
我们运行看一下

09:17.650 --> 09:18.650
好

09:18.650 --> 09:19.650
那么这里我们传递了两个

09:19.650 --> 09:20.650
对不对

09:20.650 --> 09:21.650
下面还有

09:21.650 --> 09:22.650
下面还有一个A2

09:22.650 --> 09:23.650
这是

09:23.650 --> 09:24.650
这是第一个

09:25.650 --> 09:26.650
好

09:26.650 --> 09:27.650
那么我们来看一下

09:27.650 --> 09:28.650
比方说我们现在不考虑这个吧

09:28.650 --> 09:32.220
我们就考虑上面的这个

09:32.220 --> 09:33.220
状态一致

09:33.220 --> 09:34.220
传的也是函数

09:34.220 --> 09:35.220
那么现在我们干嘛

09:35.220 --> 09:37.220
是不是要执行这个函数

09:37.220 --> 09:39.220
这个函数的返回结果

09:39.220 --> 09:40.220
这个函数如果说

09:40.220 --> 09:41.220
执行过程中没有爆错

09:41.220 --> 09:43.220
那么它就是成功的

09:43.220 --> 09:44.220
它的数据是什么呢

09:44.220 --> 09:46.220
数据就是这个返回结果

09:46.220 --> 09:47.220
如果说执行的过程中

09:47.220 --> 09:48.220
爆了错

09:48.220 --> 09:49.220
那么它就是失败的

09:49.220 --> 09:50.220
那么它的数据

09:50.220 --> 09:51.220
失败的原因

09:51.220 --> 09:52.220
就是爆了错误

09:52.220 --> 09:53.220
因此

09:53.220 --> 09:54.220
我们这边

09:54.220 --> 09:55.220
回到这

09:55.220 --> 09:57.220
逻辑是应该是什么呢

09:57.220 --> 10:01.220
通过揣开起来执行

10:01.220 --> 10:03.220
这个handle

10:03.220 --> 10:05.220
excutor

10:05.220 --> 10:06.220
那么这里有个小细节

10:06.220 --> 10:07.220
如果说你这样调用的话

10:07.220 --> 10:10.220
那么会导致这个函数的内部

10:10.220 --> 10:11.220
就这个函数的内部

10:11.220 --> 10:12.220
Z是会指向它

10:12.220 --> 10:14.220
这个是不太合适的

10:14.220 --> 10:15.220
我希望就是

10:15.220 --> 10:17.220
怎么处理呢这个地方

10:17.220 --> 10:18.220
其实你可以这样子

10:18.220 --> 10:19.220
其实你可以非常简单的

10:19.220 --> 10:21.220
在这里做一个结构

10:21.220 --> 10:22.220
excutor

10:22.220 --> 10:23.220
它一共就这么一些嘛

10:23.220 --> 10:24.220
excutor state

10:24.220 --> 10:25.220
result

10:25.220 --> 10:26.220
reject

10:26.220 --> 10:27.220
对吧

10:27.220 --> 10:28.220
一共就这么四个属性

10:28.220 --> 10:29.220
然后我们这里

10:29.220 --> 10:30.220
后边我们就直接

10:30.220 --> 10:31.220
通过这个

10:31.220 --> 10:32.220
不需要那个底了

10:32.220 --> 10:34.220
把这个底去掉

10:34.220 --> 10:35.220
这是没问题吧

10:35.220 --> 10:36.220
很简单

10:36.220 --> 10:37.220
然后我们这里是不是

10:37.220 --> 10:38.220
可以直接调用

10:38.220 --> 10:39.220
excutor

10:39.220 --> 10:40.220
直接调用

10:40.220 --> 10:42.220
这个Z的指向就没问题了

10:42.220 --> 10:43.220
好 调用它

10:43.220 --> 10:44.220
调用它的时候

10:44.220 --> 10:46.220
我们需要传什么参数呢

10:46.220 --> 10:47.220
那你看

10:47.220 --> 10:48.220
我们这个函数

10:48.220 --> 10:49.220
是不是有个参数啊

10:49.220 --> 10:50.220
无论是失败的

10:50.220 --> 10:51.220
处理函数

10:51.220 --> 10:52.220
还是成功的处理函数

10:52.220 --> 10:53.220
是不是有个参数

10:53.220 --> 10:55.220
这个参数是不是要传递进来

10:55.220 --> 10:56.220
这是它的参数是什么

10:56.220 --> 10:57.220
是不是有当前的

10:57.220 --> 10:58.220
promise的value

10:58.220 --> 10:59.220
它的值

10:59.220 --> 11:00.220
对不对

11:00.220 --> 11:01.220
所以传参数是固定的

11:01.220 --> 11:02.220
传递什么呢

11:02.220 --> 11:04.220
传递的是this

11:04.220 --> 11:05.220
value

11:05.220 --> 11:06.220
传递的是这个

11:06.220 --> 11:07.220
对吧

11:07.220 --> 11:09.220
好 参数传进去

11:09.220 --> 11:11.220
然后去执行它

11:11.220 --> 11:13.220
如果说执行的期间有错

11:13.220 --> 11:15.220
有错怎么样呢

11:15.220 --> 11:16.220
是不是我就要拒绝

11:16.220 --> 11:17.220
对不对

11:17.220 --> 11:18.220
调用这个reject

11:18.220 --> 11:20.220
调用这个reject

11:20.220 --> 11:22.220
拒绝那个promise

11:23.220 --> 11:26.220
拒绝对象就是我的原因

11:26.220 --> 11:29.220
这个逻辑就通了

11:29.220 --> 11:31.220
好 咱们来试一下

11:31.220 --> 11:33.220
现在我们到这边来

11:33.220 --> 11:34.220
比方说我这里result

11:34.220 --> 11:35.220
成功了

11:35.220 --> 11:36.220
成功了是不是要执行它

11:36.220 --> 11:37.220
那它执行的过程中

11:37.220 --> 11:38.220
如果说产生了错误

11:38.220 --> 11:41.220
我们就跑出一个abc

11:41.220 --> 11:42.220
那我们来看一下

11:42.220 --> 11:44.220
promise2的状态

11:44.220 --> 11:45.220
我们等一会

11:45.220 --> 11:48.220
因为我等promise1完成之后

11:48.220 --> 11:50.220
然后这个玩意到一部队列

11:50.220 --> 11:53.220
然后再去执行这个函数

11:53.220 --> 11:54.220
然后说promise2

11:54.220 --> 11:55.220
我要等一会再答应

11:55.220 --> 11:58.220
然后等个50毫秒吧

11:58.220 --> 11:59.220
然后再答应

11:59.220 --> 12:00.220
答应什么呢

12:00.220 --> 12:01.220
promise2

12:01.220 --> 12:03.220
那么我们预议器的状态

12:03.220 --> 12:04.220
应该是失败的

12:04.220 --> 12:05.220
对吧

12:05.220 --> 12:06.220
promise1成功了

12:06.220 --> 12:07.220
但是promise2的

12:07.220 --> 12:08.220
后续处理过程中

12:08.220 --> 12:09.220
出现了问题

12:09.220 --> 12:10.220
那么promise2失败

12:10.220 --> 12:11.220
失败的原因

12:11.220 --> 12:13.220
应该就是这个abc

12:13.220 --> 12:15.220
看看这个逻辑是不是搞定的

12:15.220 --> 12:16.220
这是这一会

12:16.220 --> 12:18.220
这是失败的逻辑

12:18.220 --> 12:19.220
那么失败的逻辑

12:19.220 --> 12:21.220
搞定了之后我把这些折一折

12:21.220 --> 12:22.220
避免我们干的

12:22.220 --> 12:23.220
手要干的

12:23.220 --> 12:25.220
把这些折一折折起来

12:25.220 --> 12:26.220
好我回到这

12:26.220 --> 12:28.220
那么如果说没有失败

12:28.220 --> 12:30.220
正常执行成功了怎么办

12:30.220 --> 12:31.220
那成功的情况

12:31.220 --> 12:33.220
我们这里跑错了

12:33.220 --> 12:34.220
那就正常执行

12:34.220 --> 12:35.220
没有问题

12:35.220 --> 12:36.220
那我是不是说

12:36.220 --> 12:37.220
互相的反而回结果

12:37.220 --> 12:38.220
对不对

12:38.220 --> 12:39.220
好那我们这里

12:39.220 --> 12:40.220
是不是要拿到它的反而回结果

12:44.220 --> 12:45.220
这个反而回结果

12:45.220 --> 12:46.220
我们怎么样呢

12:46.220 --> 12:47.220
我们首先

12:47.220 --> 12:48.220
因为它执行过程中

12:48.220 --> 12:49.220
也有爆错

12:49.220 --> 12:50.220
所以说我们要做什么

12:50.220 --> 12:51.220
要result

12:51.220 --> 12:52.220
对不对

12:52.220 --> 12:54.220
是不是我们要让这个promise完成

12:54.220 --> 12:55.220
完成之后

12:55.220 --> 12:56.220
它的数据是什么呢

12:56.220 --> 12:57.220
就是这个函数的反回结果

12:57.220 --> 12:59.220
我们把这个函数的反回结果

12:59.220 --> 13:00.220
作为它这个的数据

13:00.220 --> 13:01.220
让它result

13:01.220 --> 13:02.220
就使用这个数据

13:02.220 --> 13:04.220
好咱们站来看一下

13:04.220 --> 13:05.220
那么现在呢

13:05.220 --> 13:06.220
我们没有爆错

13:06.220 --> 13:07.220
是不是fulfill的value

13:07.220 --> 13:08.220
123

13:08.220 --> 13:09.220
这里都没有问题了

13:09.220 --> 13:10.220
对不对

13:10.220 --> 13:11.220
promise2是一个

13:11.220 --> 13:12.220
它是一个promise

13:12.220 --> 13:13.220
它的状态是fulfill

13:13.220 --> 13:14.220
123

13:14.220 --> 13:15.220
都没有问题了

13:15.220 --> 13:17.220
其实现在还有个小细节

13:17.220 --> 13:18.220
什么小细节呢

13:18.220 --> 13:19.220
就是如果说我这里

13:19.220 --> 13:20.220
返回的是什么

13:20.220 --> 13:21.220
返回的不是数字

13:21.220 --> 13:23.220
返回的是一个promise

13:23.220 --> 13:25.220
我又返回的是一个promise

13:27.220 --> 13:28.220
那么这个promise的状态

13:28.220 --> 13:30.220
比方说result

13:33.220 --> 13:35.220
比方说像这种情况

13:35.220 --> 13:36.220
那么这种情况呢

13:36.220 --> 13:38.220
如果说你返回的是promise

13:38.220 --> 13:41.220
那么它的状态和数据

13:41.220 --> 13:43.220
跟它保持完全一致

13:44.220 --> 13:45.220
就像我们说过的

13:45.220 --> 13:46.220
如果说你返回的是

13:46.220 --> 13:47.220
一个特殊情况

13:47.220 --> 13:48.220
是promise

13:48.220 --> 13:49.220
那么这个promise

13:49.220 --> 13:50.220
是什么情况

13:50.220 --> 13:51.220
它就是什么情况

13:51.220 --> 13:52.220
保持完全一致

13:53.220 --> 13:54.220
因此呢

13:54.220 --> 13:55.220
我们在这里呢

13:55.220 --> 13:56.220
又会有一个逻辑

13:56.220 --> 13:57.220
就是你如果说你返回的结果

13:57.220 --> 13:58.220
是promise

13:58.220 --> 13:59.220
那么这里的问题来了

13:59.220 --> 14:00.220
我如何来判断

14:00.220 --> 14:01.220
它是不是一个promise

14:02.220 --> 14:03.220
这里呢

14:03.220 --> 14:06.220
也不算知识点吧

14:06.220 --> 14:08.220
就是这么一个情况

14:08.220 --> 14:09.220
给大家说明一下

14:09.220 --> 14:10.220
我们有的时候

14:10.220 --> 14:11.220
会在函数里边

14:11.220 --> 14:12.220
特别是你写一些

14:12.220 --> 14:13.220
第三方库

14:13.220 --> 14:14.220
或者是写一些框架

14:14.220 --> 14:16.220
当然这些一些高阶的编程

14:16.220 --> 14:18.220
如果说写这些东西的时候

14:18.220 --> 14:19.220
很有可能

14:19.220 --> 14:20.220
会遇到

14:20.220 --> 14:21.220
要判断一个东西

14:21.220 --> 14:22.220
是不是promise

14:22.220 --> 14:24.220
我给大家写一下

14:24.220 --> 14:25.220
其实非常简单

14:26.220 --> 14:27.220
如何来判断一个东西

14:27.220 --> 14:28.220
是不是promise

14:28.220 --> 14:30.220
我们做一个简单的判断就行了

14:30.220 --> 14:31.220
不用去判断

14:31.220 --> 14:32.220
它是什么构造函数

14:32.220 --> 14:33.220
有些人说

14:33.220 --> 14:34.220
那我们能不能判断

14:34.220 --> 14:35.220
这个instance

14:35.220 --> 14:36.220
不要这样去做

14:36.220 --> 14:37.220
首先为什么

14:37.220 --> 14:38.220
不要去这样做

14:38.220 --> 14:40.220
因为promise这个东西

14:40.220 --> 14:41.220
我们认为

14:41.220 --> 14:42.220
只要满足promise

14:42.220 --> 14:43.220
A加规范就可以了

14:44.220 --> 14:45.220
你不一定

14:45.220 --> 14:47.220
一定得是ES6的promise

14:47.220 --> 14:48.220
你更加不要说

14:48.220 --> 14:50.220
我们可以自己写个promise

14:50.220 --> 14:52.220
最好不要用这种方式来判断

14:52.220 --> 14:53.220
那么怎么来判断呢

14:53.220 --> 14:55.220
promise A加规范规定

14:55.220 --> 14:57.220
promise一定得是一个对象

14:57.220 --> 14:59.220
所以说obj必须要有指

14:59.220 --> 15:02.220
同时obj必须要是一个object

15:02.220 --> 15:03.220
必须是个对象

15:03.220 --> 15:05.220
A加规范规定的

15:05.220 --> 15:06.220
然后

15:06.220 --> 15:08.220
它不仅要是一个对象

15:08.220 --> 15:10.220
而且它必须要喊一个任方法

15:10.220 --> 15:13.220
说obj type

15:13.220 --> 15:14.220
obj叫任

15:14.220 --> 15:16.220
它必须要得是一个什么

15:16.220 --> 15:18.220
得是一个函数

15:18.220 --> 15:20.220
它必须要有个任方法

15:20.220 --> 15:21.220
那么剩下的事情

15:21.220 --> 15:22.220
我们就不做判定了

15:22.220 --> 15:24.220
说只要满足这个要求

15:24.220 --> 15:26.220
那么它就是一个promise

15:26.220 --> 15:28.220
我们认为就这样

15:28.220 --> 15:29.220
好

15:29.220 --> 15:30.220
那么这里有可能

15:30.220 --> 15:32.220
会返回

15:32.220 --> 15:34.220
就是返回处的情况

15:34.220 --> 15:35.220
它肯定是一致的

15:35.220 --> 15:36.220
就是有可能

15:36.220 --> 15:37.220
如果说是force的情况

15:37.220 --> 15:38.220
它不是promise的话

15:38.220 --> 15:40.220
它有可能会返回一些

15:40.220 --> 15:41.220
比方说这里是undefine

15:41.220 --> 15:42.220
它就直接返回undefine了

15:42.220 --> 15:43.220
对吧

15:43.220 --> 15:44.220
那么这里呢

15:44.220 --> 15:45.220
这里倒是会返

15:45.220 --> 15:47.220
这里如果说为q

15:47.220 --> 15:50.220
但是这里为force

15:50.220 --> 15:52.220
这里如果说是undefine的话

15:52.220 --> 15:53.220
它就可能返回undefine

15:53.220 --> 15:55.220
那么这里如果说是0的话

15:55.220 --> 15:56.220
它就会返回0

15:56.220 --> 15:57.220
这不是我们想要的

15:57.220 --> 15:58.220
我们希望它返回的

15:58.220 --> 15:59.220
永远是true和force

15:59.220 --> 16:00.220
那么这里有个小技巧

16:00.220 --> 16:02.220
加两个感叹号

16:02.220 --> 16:03.220
是吧

16:03.220 --> 16:04.220
先取反再取反

16:04.220 --> 16:05.220
是反反得正

16:05.220 --> 16:06.220
对吧

16:06.220 --> 16:07.220
通过这种方式

16:07.220 --> 16:09.220
把它转换成布尔的一些

16:09.220 --> 16:10.220
那么这个方法

16:10.220 --> 16:11.220
做什么事情

16:14.220 --> 16:17.220
判断一个数据

16:17.220 --> 16:19.220
是否是promise

16:19.220 --> 16:21.220
对象

16:21.220 --> 16:22.220
好

16:22.220 --> 16:23.220
那么有了这个函数之后

16:23.220 --> 16:24.220
我们再回到这

16:24.220 --> 16:28.230
我们现在是否判断

16:28.230 --> 16:30.230
ispromiseresult

16:30.230 --> 16:32.230
如果说它是一个promise

16:32.230 --> 16:33.230
我们之前分析过

16:33.230 --> 16:34.230
就你返回的这个东西

16:34.230 --> 16:36.230
它是promise

16:36.230 --> 16:37.230
那我这个promise的状态

16:37.230 --> 16:38.230
要给你保持一致

16:38.230 --> 16:39.230
那怎么弄呢

16:39.230 --> 16:40.230
是不是

16:40.230 --> 16:42.230
我就result

16:42.230 --> 16:43.230
ispromise

16:43.230 --> 16:44.230
那肯定有这函数

16:44.230 --> 16:45.230
对吧

16:45.230 --> 16:47.230
那么你如果说成功了

16:47.230 --> 16:48.230
你就帮我运行一下

16:48.230 --> 16:49.230
我的result

16:49.230 --> 16:50.230
你如果说失败了

16:50.230 --> 16:51.230
就帮我运行一下

16:51.230 --> 16:52.230
我的result

16:52.230 --> 16:53.230
是不是可以了

16:53.230 --> 16:54.230
你成功了

16:54.230 --> 16:55.230
我自然就掉入result

16:55.230 --> 16:56.230
我就成功了

16:56.230 --> 16:57.230
你失败了

16:57.230 --> 16:58.230
我就掉入result

16:58.230 --> 16:59.230
这个邏輯就通了

16:59.230 --> 17:00.230
那当然

17:00.230 --> 17:02.230
如果说你不是promise的话

17:02.230 --> 17:04.230
那么我就正常的result

17:04.230 --> 17:05.230
执行因为爆错

17:05.230 --> 17:06.230
对吧

17:06.230 --> 17:07.230
正常的result

17:07.230 --> 17:09.230
现在我们来看一下

17:09.230 --> 17:11.230
现在我们返回的是一个promise

17:11.230 --> 17:12.230
运行

17:12.230 --> 17:13.230
是吧

17:13.230 --> 17:14.230
我这里

17:14.230 --> 17:15.230
它成功了

17:15.230 --> 17:16.230
我也成功了

17:16.230 --> 17:18.610
那如果它失败了呢

17:18.610 --> 17:20.610
我也失败了

17:20.610 --> 17:21.610
好了

17:21.610 --> 17:22.610
同学们

17:22.610 --> 17:23.610
至此

17:23.610 --> 17:24.610
我们就完成了

17:24.610 --> 17:25.610
整个promise

17:25.610 --> 17:26.610
A下规范

17:26.610 --> 17:28.610
通过这么一百多航代

17:28.610 --> 17:30.610
就完成这个规范了

17:30.610 --> 17:31.610
你可以尽情的去

17:31.610 --> 17:32.610
反复的去测试

17:32.610 --> 17:33.610
是没问题的

17:33.610 --> 17:34.610
然后

17:34.610 --> 17:35.610
当然如果说

17:35.610 --> 17:36.610
我这里面也测试到

17:36.610 --> 17:37.610
如果说

17:37.610 --> 17:38.610
如果说我没测试到

17:38.610 --> 17:39.610
有一些问题的话

17:39.610 --> 17:40.610
欢迎同学们

17:40.610 --> 17:41.610
在咱们的仓库里面

17:41.610 --> 17:42.610
给老师指出

17:42.610 --> 17:43.610
好

17:43.610 --> 17:44.610
那么现在呢

17:44.610 --> 17:45.610
我们来测试一下

17:45.610 --> 17:46.610
我们因为我们玩

17:46.610 --> 17:48.610
满足了promise A下规范

17:48.610 --> 17:49.610
promise A下规范

17:49.610 --> 17:50.610
有个什么样的特点

17:50.610 --> 17:52.610
就是可以互操作

17:52.610 --> 17:54.610
什么叫互操作

17:54.610 --> 17:55.610
就是我可以使用

17:55.610 --> 17:56.610
官方的promise

17:56.610 --> 17:57.610
和我自己写的promise

17:57.610 --> 17:58.610
可以相互操作

17:58.610 --> 17:59.610
都没问题

17:59.610 --> 18:00.610
好

18:00.610 --> 18:01.610
咱们来试一下

18:01.610 --> 18:02.610
比方说

18:02.610 --> 18:03.610
pro

18:04.610 --> 18:05.610
它是来自于

18:05.610 --> 18:07.610
我的promise

18:07.610 --> 18:09.610
result

18:11.610 --> 18:12.610
好

18:12.610 --> 18:13.610
然后我们使用result

18:15.610 --> 18:16.610
比方完成

18:16.610 --> 18:17.610
接下来

18:17.610 --> 18:19.610
我们用promise A

18:19.610 --> 18:21.610
调用另一方法

18:21.610 --> 18:23.610
然后我们都要data

18:23.610 --> 18:25.610
data我们输出一下data

18:25.610 --> 18:26.610
那么就应该输出1

18:26.610 --> 18:27.610
对不对

18:27.610 --> 18:28.610
这个肯定是没问题的

18:28.610 --> 18:29.610
对吧

18:29.610 --> 18:30.610
其他测试

18:30.610 --> 18:31.610
让你们自己去做

18:31.610 --> 18:32.610
好

18:32.610 --> 18:33.610
这个没问题

18:33.610 --> 18:34.610
然后我在这边

18:34.610 --> 18:35.610
去返回一个

18:35.610 --> 18:36.610
6

18:36.610 --> 18:37.610
官方的promise

18:39.610 --> 18:40.610
去做

18:40.610 --> 18:42.920
好

18:42.920 --> 18:43.920
我们输出一下

18:43.920 --> 18:45.920
我们result一下

18:45.920 --> 18:46.920
那个2

18:46.920 --> 18:47.920
好

18:47.920 --> 18:48.920
接下来

18:48.920 --> 18:49.920
z

18:49.920 --> 18:51.920
我们再来输出一下data

18:51.920 --> 18:52.920
你看

18:52.920 --> 18:53.920
如果说能够互相操作的话

18:53.920 --> 18:54.920
那么就应该

18:54.920 --> 18:55.920
有这么一个现象

18:55.920 --> 18:56.920
我这个promise完成了

18:56.920 --> 18:57.920
完成的数据是什么

18:57.920 --> 18:58.920
1

18:58.920 --> 18:59.920
那么这里应该输出1

18:59.920 --> 19:00.920
这个没问题

19:00.920 --> 19:01.920
对吧

19:01.920 --> 19:02.920
官方的promise

19:02.920 --> 19:04.920
这官方的promise呢

19:04.920 --> 19:06.920
因为他返回的是promise

19:06.920 --> 19:07.920
所以说

19:07.920 --> 19:08.920
我这个任方法返回的是什么

19:08.920 --> 19:09.920
返回的是

19:09.920 --> 19:11.920
我们自己的够多喊数对吧

19:11.920 --> 19:13.920
我们任方法返回的是我的promise

19:13.920 --> 19:14.920
对吧

19:14.920 --> 19:15.920
我自己写了个promise

19:15.920 --> 19:17.920
喊数的对象

19:17.920 --> 19:19.920
那么我这个对象的状态

19:19.920 --> 19:20.920
应该跟个官方的promise的状态

19:20.920 --> 19:21.920
要保持一次对吧

19:21.920 --> 19:23.920
因为这里result了2

19:23.920 --> 19:25.920
那么我这个任反回的promise

19:25.920 --> 19:26.920
也该是result5

19:26.920 --> 19:27.920
所以说这里应该输出2

19:27.920 --> 19:29.920
那如果说能够互操作的话

19:29.920 --> 19:31.920
那么这里肯定是没问题的

19:31.920 --> 19:32.920
因为发现没问题

19:32.920 --> 19:33.920
那么来改一下

19:33.920 --> 19:34.920
我先用官方的

19:34.920 --> 19:37.920
再用我自己的

19:37.920 --> 19:39.920
看一下有没有问题

19:39.920 --> 19:40.920
有发现也没问题

19:40.920 --> 19:41.920
就是我们的写的东西

19:41.920 --> 19:43.920
可以跟官方的互相操作

19:43.920 --> 19:44.920
因为他们都符合

19:44.920 --> 19:46.920
promise A加规范都没问题

19:46.920 --> 19:47.920
好

19:47.920 --> 19:48.920
我们再来看一下

19:48.920 --> 19:49.920
既然我们符合A加规范

19:49.920 --> 19:51.920
那么我们在使用

19:51.920 --> 19:52.920
而sync关键制的时候

19:52.920 --> 19:53.920
应该也没问题

19:53.920 --> 19:54.920
好

19:54.920 --> 19:55.920
咱们来试一下

19:55.920 --> 19:59.300
现在我们再写一个

19:59.300 --> 20:01.300
delay函数吧

20:01.300 --> 20:03.860
你写过很多次了

20:03.860 --> 20:04.860
对吧 这种函数

20:04.860 --> 20:05.860
delay函数

20:05.860 --> 20:06.860
delation

20:06.860 --> 20:07.860
然后我这里反回

20:07.860 --> 20:09.860
new my promise

20:09.860 --> 20:11.860
result

20:11.860 --> 20:12.860
result

20:12.860 --> 20:14.860
我say time out

20:14.860 --> 20:17.300
多少时间了

20:17.300 --> 20:18.300
delation

20:18.300 --> 20:20.300
这个时间完成之后

20:20.300 --> 20:21.300
result

20:21.300 --> 20:23.300
这是我自己的写的my promise

20:23.300 --> 20:24.300
我们看一下

20:24.300 --> 20:25.300
而sync

20:25.300 --> 20:26.300
而wait关键制

20:26.300 --> 20:27.300
能不能等待这样的一个东西呢

20:27.300 --> 20:28.300
wait

20:28.300 --> 20:30.300
delay

20:30.300 --> 20:31.300
2000

20:32.300 --> 20:35.620
好 我们输出一下

20:35.620 --> 20:36.620
我现在输出一下

20:36.620 --> 20:38.620
start

20:38.620 --> 20:39.620
运行

20:39.620 --> 20:41.620
start

20:41.620 --> 20:42.620
2秒钟之后

20:42.620 --> 20:43.620
OK

20:43.620 --> 20:44.620
而wait关键制

20:44.620 --> 20:45.620
也能识别

20:45.620 --> 20:46.620
我们自己写的promise

20:46.620 --> 20:47.620
为什么能识别

20:47.620 --> 20:48.620
只要你能符合A加规范

20:48.620 --> 20:50.620
那么它就没问题

20:50.620 --> 20:51.620
所以我们

20:51.620 --> 20:52.620
你可以下来

20:52.620 --> 20:53.620
可以同学们

20:53.620 --> 20:54.620
可以多去做一些测试

20:54.620 --> 20:55.620
是没问题的

20:55.620 --> 20:56.620
那有些人说

20:56.620 --> 20:57.620
那我这个promise里边

20:57.620 --> 20:58.620
还没有写

20:58.620 --> 20:59.620
什么看起方法

20:59.620 --> 21:00.620
还没有 对吧

21:00.620 --> 21:01.620
还有什么fantasy

21:01.620 --> 21:02.620
方法还没有

21:02.620 --> 21:03.620
还有一些静态方法

21:03.620 --> 21:04.620
什么or

21:04.620 --> 21:05.620
res

21:05.620 --> 21:06.620
这些方法都没有

21:06.620 --> 21:07.620
注意这些方法

21:07.620 --> 21:09.620
不是promise A加规范的

21:09.620 --> 21:10.620
A加规范就规定了

21:10.620 --> 21:11.620
你必须要有个任何方法

21:11.620 --> 21:12.620
他详细的说了

21:12.620 --> 21:13.620
这个任何方法

21:13.620 --> 21:14.620
应该怎么来处理

21:14.620 --> 21:15.620
有几个参数

21:15.620 --> 21:16.620
每个参数

21:16.620 --> 21:17.620
应该长什么样子

21:17.620 --> 21:18.620
你具体处理

21:18.620 --> 21:19.620
该怎么去处理

21:19.620 --> 21:20.620
所以你把任何方法

21:20.620 --> 21:21.620
实现了

21:21.620 --> 21:22.620
就实现了promise A加规范

21:22.620 --> 21:23.620
那么剩下了什么

21:23.620 --> 21:24.620
or

21:24.620 --> 21:25.620
还要那些东西

21:25.620 --> 21:26.620
小事

21:26.620 --> 21:27.620
真是小事

21:27.620 --> 21:28.620
最复杂的

21:28.620 --> 21:29.620
我们已经搞定了

21:29.620 --> 21:30.620
其他都是小事

21:30.620 --> 21:31.620
我们慢慢把其他东西

21:31.620 --> 21:32.620
一点点实现

21:32.620 --> 21:33.620
因为发现其他东西

21:33.620 --> 21:34.620
实现就非常简单了

21:34.620 --> 21:35.620
OK

21:35.620 --> 21:36.620
那么我们这几颗

21:36.620 --> 21:38.620
就算高于断落了

