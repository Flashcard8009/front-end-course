WEBVTT

00:00.110 --> 00:03.550
好 那么我们现在开始来写这个promise

00:03.550 --> 00:05.950
我们写promise实际上写的是什么呢

00:05.950 --> 00:07.950
其实写的就是一个构造器

00:07.950 --> 00:09.550
对吧 我们通过一个new

00:09.550 --> 00:11.870
然后能通过这个构造器promise呢

00:11.870 --> 00:13.390
然后给它传一个参数啊

00:13.390 --> 00:14.990
就能创建这么一个promise

00:14.990 --> 00:16.590
对吧 这是我们的创建方式

00:16.590 --> 00:18.830
然后我们这里可能就先来写这个构造器

00:18.830 --> 00:21.630
我们完全可以使用esnew给我们提供的class

00:21.630 --> 00:23.470
来写完成这个构造器的书写

00:23.470 --> 00:26.910
然后名字呢我们就给它取名为mypromise

00:26.910 --> 00:28.270
好 因为它是个构造器啊

00:28.270 --> 00:29.950
所以说我们需要学个constructor

00:30.030 --> 00:31.070
那么这个constructor呢

00:31.070 --> 00:32.030
里边有没有参数呢

00:32.030 --> 00:34.750
你会发现它是需要传递一个参数的对吧

00:34.750 --> 00:36.110
那么这个参数是啥呢

00:36.110 --> 00:38.750
其实就是promise本身就是一个任务

00:38.750 --> 00:39.790
那这个参数是什么呢

00:39.790 --> 00:41.150
参数是一个函数

00:41.150 --> 00:42.110
这个函数呢

00:42.110 --> 00:44.350
它表示的是任务的执行过程

00:44.350 --> 00:46.110
它描述了这个任务一开始做什么

00:46.110 --> 00:47.390
再做什么对吧

00:47.390 --> 00:50.030
我们这里呢给它取个名字叫做excutor

00:50.910 --> 00:52.110
excutor什么意思呢

00:52.110 --> 00:54.430
就执行器啊 然后打个注释

00:55.310 --> 00:58.350
这是创建一个promise

00:59.310 --> 01:00.830
然后呢这个这个地方是什么呢

01:00.830 --> 01:02.110
它是一个函数方式

01:03.230 --> 01:06.990
然后呢它是表示任务执行器

01:07.870 --> 01:09.630
调用这个函数它就会执行任务

01:09.630 --> 01:11.950
然后我们通过之前学些promise

01:11.950 --> 01:12.750
我们应该知道

01:12.750 --> 01:14.430
这个函数是不是同步执行的

01:14.430 --> 01:16.030
立即执行对吧

01:16.030 --> 01:19.150
这里这个函数立即执行

01:20.830 --> 01:21.550
立即执行

01:22.990 --> 01:23.550
好 OK

01:23.550 --> 01:26.510
那么这就是一个基本的结构就出来了

01:26.510 --> 01:27.870
那么这个函数要立即执行

01:27.950 --> 01:28.830
那怎么来执行呢

01:28.830 --> 01:30.030
是不是通过这种方式啊

01:30.030 --> 01:31.630
调用它是不是就完事了

01:31.630 --> 01:32.910
一定要用这个函数

01:32.910 --> 01:34.510
那么这个函数要不要传参数呢

01:34.510 --> 01:35.870
你看一下这个函数有没有参数

01:35.870 --> 01:37.230
是不是有两个参数啊

01:37.230 --> 01:38.270
这两个参数是什么

01:38.270 --> 01:39.070
又是一个函数

01:39.070 --> 01:40.670
一个result一个reject

01:40.670 --> 01:41.790
对不对 是不是有两个参数

01:42.350 --> 01:44.830
那么我们这里呢需要给它传递两个参数

01:44.830 --> 01:46.270
一个是result一个是reject

01:46.830 --> 01:48.110
那么如何来传递呢

01:48.110 --> 01:49.310
当然我们可以在这里呢

01:49.310 --> 01:50.830
去协谅函数一个是result

01:52.110 --> 01:52.830
result函数

01:52.830 --> 01:54.430
不要定义两个函数

01:54.430 --> 01:55.710
然后呢一个是reject

01:55.710 --> 01:57.310
通过这种方式给它传递进去

01:57.310 --> 01:58.350
但是这样子做的话

01:58.350 --> 01:59.870
会把这里代码写得很乱

01:59.870 --> 02:01.150
所以说我这边呢

02:01.150 --> 02:03.710
就打算这里新开两个

02:03.710 --> 02:05.630
在原型上给它开两个函数

02:05.630 --> 02:06.510
因为这两个函数呢

02:06.510 --> 02:07.790
我不希望用户调用

02:09.870 --> 02:11.710
我这个函数会把它传进来对吧

02:11.710 --> 02:13.230
所以说我这里不希望用户调用

02:13.230 --> 02:14.350
因此呢我这里

02:14.350 --> 02:16.750
从命名上给它加上一个下滑线

02:16.750 --> 02:18.030
这也是无忧的

02:18.030 --> 02:19.310
既然无忧啊或者一些

02:19.310 --> 02:20.670
别的第三方库的一些做法

02:20.670 --> 02:21.790
一些私有的东西呢

02:21.790 --> 02:24.670
我把它写成一个下滑线开头

02:24.670 --> 02:26.270
然后这里呢我写个result函数

02:27.550 --> 02:29.390
然后还有一个就是reject函数

02:31.150 --> 02:31.710
reject

02:32.990 --> 02:35.070
这两个函数我打算一个注释啊

02:35.070 --> 02:36.030
这个函数是做什么呢

02:36.030 --> 02:37.710
因为我们代码最后可能比较多啊

02:37.710 --> 02:39.310
其实也就200多行吧

02:39.310 --> 02:40.190
也不是很多

02:40.910 --> 02:42.590
所以还不止200多行

02:42.590 --> 02:43.790
因为还有静态方法

02:43.790 --> 02:45.470
我们还是把注释打好

02:45.470 --> 02:46.430
这个函数是做什么呢

02:46.430 --> 02:51.550
就是标记当前任务完成

02:51.550 --> 02:51.950
对吧

02:51.950 --> 02:52.990
一调这个函数

02:52.990 --> 02:53.950
相当于是调这个

02:53.950 --> 02:55.470
调这个函数相当于是调这个

02:55.470 --> 02:57.150
那么就标记当前任务完成

02:57.230 --> 02:58.750
然后这里呢就是标记

02:58.750 --> 03:00.750
当前任务失败

03:00.750 --> 03:00.990
对吧

03:00.990 --> 03:02.430
就做这么一个作用

03:02.430 --> 03:02.590
好

03:02.590 --> 03:03.710
我们再来看一下啊

03:03.710 --> 03:05.870
这两个函数有没有参数啊

03:06.590 --> 03:07.550
那肯定有参数

03:07.550 --> 03:07.870
为什么呢

03:07.870 --> 03:08.990
因为我调这个函数的时候

03:08.990 --> 03:09.870
result的时候

03:09.870 --> 03:10.830
我是不是要给它传

03:10.830 --> 03:11.870
可以给它传参数对吧

03:12.830 --> 03:13.550
调这个函数

03:13.550 --> 03:14.350
也可以不传

03:14.350 --> 03:14.830
也可以传

03:14.830 --> 03:15.230
不传的话

03:15.230 --> 03:16.910
相当于是传的是N一半

03:16.910 --> 03:17.390
对不对

03:17.390 --> 03:18.270
是不是可以传参数

03:18.270 --> 03:20.190
因此这两个函数都是有参数的

03:20.190 --> 03:20.830
这两个参数呢

03:20.830 --> 03:22.750
我们分别给它命名为data

03:22.750 --> 03:22.990
对吧

03:22.990 --> 03:23.950
任务完成的时候

03:23.950 --> 03:26.350
是不是可以有一个参数数是

03:27.470 --> 03:30.110
内情是ndata表示的是什么意思呢

03:30.110 --> 03:34.030
表示任务完成的相关数据

03:34.910 --> 03:35.870
然后这边呢

03:35.870 --> 03:37.710
它也会有一个参数叫result

03:37.710 --> 03:39.550
就是任务失败的时候的相关数据

03:43.390 --> 03:44.350
那么这里呢就是result

03:45.710 --> 03:47.710
任务失败的相关数据

03:48.990 --> 03:49.310
对不对

03:50.430 --> 03:50.750
好

03:50.750 --> 03:52.350
那么我们把这个结构写出来了

03:52.350 --> 03:54.430
这两个函数各有参数

03:54.430 --> 03:54.670
好了

03:54.670 --> 03:55.790
有了这两个函数之后呢

03:55.870 --> 03:59.790
我这边在调用这个任务描述函数的时候

03:59.790 --> 04:00.830
调用它的时候

04:00.830 --> 04:02.190
那我是不是把这两个函数给

04:02.190 --> 04:02.990
它就完成了

04:02.990 --> 04:03.310
对吧

04:03.310 --> 04:04.030
我这里不要用

04:04.030 --> 04:04.750
但是我给你

04:04.750 --> 04:06.030
你任何时候都可以调用

04:06.030 --> 04:06.510
一调用

04:06.510 --> 04:07.310
那我这个

04:07.310 --> 04:07.950
调用这个

04:07.950 --> 04:08.670
任务就完成了

04:08.670 --> 04:09.710
调这个任务就失败了

04:09.710 --> 04:10.350
所以说我这里呢

04:10.350 --> 04:13.470
可以通过这个zresult

04:14.270 --> 04:15.550
是把函数就传给它了

04:15.550 --> 04:17.950
zresult就传给它了

04:17.950 --> 04:20.190
就这个基本逻辑就出来了

04:20.190 --> 04:21.870
那么比方说我这里函数里边

04:22.510 --> 04:23.630
输出一个

04:23.630 --> 04:23.950
完成

04:25.630 --> 04:26.350
这里呢

04:26.350 --> 04:27.950
我输出一个失败

04:28.910 --> 04:29.310
然后呢

04:29.310 --> 04:30.750
我还可以把打印出来

04:30.750 --> 04:30.990
对吧

04:31.790 --> 04:32.110
接下来

04:33.710 --> 04:34.430
这里的失败呢

04:34.430 --> 04:35.710
我就是打印这个zresult

04:37.150 --> 04:37.550
写错了

04:39.230 --> 04:39.550
好

04:39.550 --> 04:41.070
那这个基本结构出来之后呢

04:41.070 --> 04:42.110
我们来试一下

04:42.110 --> 04:43.790
我们把它变成我们的myresult

04:45.070 --> 04:45.950
mypromise

04:46.590 --> 04:46.750
好

04:46.750 --> 04:48.030
我们先调用zresult

04:48.030 --> 04:48.590
看一下

04:48.590 --> 04:50.110
我调用这个函数的时候

04:50.110 --> 04:51.070
因为我这里传

04:51.150 --> 04:51.790
传递的是它

04:51.790 --> 04:52.190
对吧

04:52.190 --> 04:53.470
所以我调这个函数的时候呢

04:53.470 --> 04:54.590
实际上调的是谁

04:54.590 --> 04:56.270
实际上调的就是这个

04:57.070 --> 04:57.550
对吧

04:57.550 --> 04:59.150
然后传递到一个123

04:59.150 --> 05:00.030
那么这个123呢

05:00.030 --> 05:01.470
实际上传给谁啊

05:01.470 --> 05:02.510
就传给这个data

05:03.390 --> 05:03.630
对吧

05:03.630 --> 05:04.270
我们来试一下

05:04.830 --> 05:06.670
然后我们就用那个code runner

05:06.670 --> 05:08.190
然后直接调用

05:08.190 --> 05:08.670
是不是

05:08.670 --> 05:09.390
就输出了这个

05:09.390 --> 05:09.790
说明啥

05:09.790 --> 05:11.310
说明我们这里调的Zresult

05:11.310 --> 05:12.030
确实是这个

05:12.990 --> 05:13.310
OK

05:13.310 --> 05:14.430
我们就写到这了

05:14.430 --> 05:15.630
然后写到这有没有什么问题呢

05:15.630 --> 05:16.990
其实还是有些问题的

05:16.990 --> 05:18.830
因为我这个函数里边呢

05:18.830 --> 05:19.230
肯定

05:19.870 --> 05:20.670
你可以想象

05:20.750 --> 05:21.390
这个函数里边

05:21.390 --> 05:23.390
我们一个promise完成了

05:23.390 --> 05:24.510
我们要做什么事情

05:25.710 --> 05:26.430
promise完成了

05:26.430 --> 05:26.830
有的人说

05:26.830 --> 05:28.750
promise完成了是不是要调用Zin啊

05:28.750 --> 05:29.550
那不一定

05:29.550 --> 05:30.350
因为我这里可能

05:30.910 --> 05:33.710
可能任何都没有调用Zin对吧

05:33.710 --> 05:35.470
就这没有直接的关系

05:35.470 --> 05:36.990
有一些关系没有直接的关系

05:36.990 --> 05:38.750
promise完成过后做什么呢

05:38.750 --> 05:39.550
我们回忆一下

05:40.350 --> 05:42.190
我们之前讲promise的时候

05:42.190 --> 05:43.150
所以两个階段

05:43.150 --> 05:43.870
三个状态

05:44.670 --> 05:45.630
一开始状态是什么

05:45.630 --> 05:46.510
pending

05:46.510 --> 05:47.870
完成之后的状态是什么

05:47.870 --> 05:48.830
完成状态是什么

05:48.830 --> 05:49.710
ffield

05:50.430 --> 05:51.390
失败的状态是什么

05:51.390 --> 05:52.270
rejecting的

05:52.270 --> 05:52.510
对吧

05:52.510 --> 05:52.990
所以说

05:52.990 --> 05:54.670
我们无论是完成也好

05:54.670 --> 05:55.630
还是失败也好

05:55.630 --> 05:57.710
实际上是要改变状态的

05:57.710 --> 05:58.190
因此呢

05:58.190 --> 05:59.870
我们完成实际上是做什么

05:59.870 --> 06:00.670
改变状态

06:02.590 --> 06:03.470
和数据

06:03.470 --> 06:03.790
对吧

06:03.790 --> 06:05.470
我们成功之后是不是有个数据

06:05.470 --> 06:06.590
把数据改了

06:06.590 --> 06:08.190
然后失败的时候改什么呢

06:08.190 --> 06:08.590
改变

06:10.750 --> 06:13.550
也是改变状态和数据

06:13.550 --> 06:13.710
对吧

06:13.710 --> 06:15.550
这个数据就是失败的原因

06:15.550 --> 06:17.150
是不是都要做这么一件事啊

06:17.150 --> 06:19.150
因此我们这里肯定要改变状态和数据

06:19.950 --> 06:22.510
那我们状态和数据在哪里去改变呢

06:22.510 --> 06:23.550
其实非常简单

06:23.550 --> 06:25.070
我就给每一个promise

06:25.070 --> 06:26.270
设置一些属性

06:26.270 --> 06:27.070
设置两个属性

06:27.070 --> 06:27.870
一个是状态

06:27.870 --> 06:28.710
我们用个下方线

06:28.710 --> 06:29.710
set

06:29.710 --> 06:31.310
这个属性一开始是什么

06:31.310 --> 06:31.950
pending

06:31.950 --> 06:32.510
对吧

06:32.510 --> 06:33.550
这叫状态

06:34.750 --> 06:35.310
还有一个属性呢

06:35.310 --> 06:37.230
就是value

06:37.230 --> 06:39.070
这是一开始是undefined

06:39.070 --> 06:39.790
这是数据

06:41.150 --> 06:42.190
其实我们要改什么呢

06:43.950 --> 06:44.510
要改什么呢

06:44.510 --> 06:46.270
其实不就是改这两个东西吗

06:46.270 --> 06:47.230
如果说你成功了

06:47.230 --> 06:48.110
我改什么

06:48.110 --> 06:49.550
是不是要改这个this

06:50.110 --> 06:50.510
set

06:51.310 --> 06:52.350
把它变为什么

06:52.350 --> 06:53.630
变为fulfilled

06:54.750 --> 06:55.310
对吧

06:55.310 --> 06:56.270
变这个

06:56.270 --> 06:57.950
然后再把这个数据

06:57.950 --> 06:59.390
value变成什么data

07:00.270 --> 07:01.390
那我失败的时候呢

07:02.110 --> 07:03.230
是不是要做这么一件事

07:03.230 --> 07:04.350
变成regality

07:05.870 --> 07:06.350
然后呢

07:06.350 --> 07:06.830
数据呢

07:07.550 --> 07:08.350
失败的原因呢

07:08.350 --> 07:08.990
就是这个regin

07:09.550 --> 07:10.430
是不是要做这么一件事

07:10.990 --> 07:11.230
好

07:11.230 --> 07:12.030
这个逻辑没问题吧

07:12.510 --> 07:12.830
好

07:12.830 --> 07:13.550
那么没有没问题的话

07:13.550 --> 07:14.910
我们再来运行一下

07:14.910 --> 07:15.550
那么这个时候呢

07:15.550 --> 07:16.670
你会发现它爆错了

07:18.430 --> 07:19.390
它为什么爆错呢

07:19.470 --> 07:20.030
它说这个

07:20.510 --> 07:22.670
无法读取state of undefined

07:23.230 --> 07:24.670
从undefined里面读属性

07:24.670 --> 07:25.790
state是读不到的

07:25.790 --> 07:26.750
为什么读不到呢

07:26.750 --> 07:28.190
随于这个this是undefined

07:28.670 --> 07:30.110
那为什么this是undefined呢

07:30.110 --> 07:31.390
我们说this的指向啊

07:32.670 --> 07:33.790
因为我们调这个result

07:34.590 --> 07:35.390
调这个result

07:35.390 --> 07:36.030
实际上调什么呢

07:36.030 --> 07:36.990
调的只有这个result

07:37.470 --> 07:38.110
对吧

07:38.110 --> 07:39.310
那么这个result里面

07:39.310 --> 07:39.870
用到了this

07:39.870 --> 07:40.830
那this的指向

07:40.830 --> 07:41.710
指向谁呢

07:41.710 --> 07:42.190
我们说

07:42.190 --> 07:43.470
this的指向学于什么

07:43.470 --> 07:44.910
学于如何调用它

07:44.910 --> 07:45.870
那我这里怎么调用呢

07:45.870 --> 07:46.750
是不是直接调用的

07:47.470 --> 07:48.110
直接调用它

07:48.110 --> 07:48.750
this指向谁

07:49.230 --> 07:50.350
按理说应该指向

07:50.350 --> 07:51.070
权距变量

07:51.070 --> 07:52.430
但是由于我使用了

07:52.430 --> 07:53.390
es6的class

07:53.950 --> 07:54.670
然后又导致呢

07:54.670 --> 07:55.950
它是在严格模式下边

07:55.950 --> 07:56.670
严格模式下边

07:56.670 --> 07:57.390
测这个result

07:57.390 --> 07:58.350
指向的是undefined

07:58.910 --> 07:59.630
因此又导致了

07:59.630 --> 08:00.510
这样的问题

08:00.510 --> 08:01.150
那怎么办呢

08:01.150 --> 08:01.950
我希望是什么

08:01.950 --> 08:03.310
希望这个result指向什么

08:03.310 --> 08:04.910
指向当前的promise对象

08:05.710 --> 08:07.630
那我在传的时候可以这样子

08:07.630 --> 08:08.590
加上一个band

08:08.590 --> 08:09.870
是不是就可以搞定了

08:09.870 --> 08:10.190
对吧

08:10.190 --> 08:10.830
band.is

08:11.550 --> 08:12.350
那么这样子的

08:12.350 --> 08:13.790
它band的方法

08:13.790 --> 08:15.070
会返回一个新的函数

08:15.070 --> 08:16.030
这个新的函数呢

08:16.510 --> 08:18.190
就是绑进了result的函数

08:19.070 --> 08:20.350
那么这边也是一样

08:21.070 --> 08:21.950
band的认识

08:22.750 --> 08:24.190
这里的result是什么

08:24.190 --> 08:25.470
这里的result就是

08:25.470 --> 08:26.670
当前的promise

08:26.670 --> 08:28.270
当前新创建的promise

08:28.270 --> 08:28.830
对吧

08:28.830 --> 08:30.990
然后我把这个函数绑进了result

08:30.990 --> 08:32.030
那么之后调用的函数

08:32.030 --> 08:33.150
无论你怎么调用它

08:33.150 --> 08:34.350
它result的都是指向

08:35.390 --> 08:36.270
新的promise

08:36.270 --> 08:37.550
那么我现在再看一下

08:39.390 --> 08:40.270
所以没爆错了

08:40.270 --> 08:41.390
好咱们来试一下

08:41.390 --> 08:42.830
我们这里得到一个promise

08:44.750 --> 08:45.630
输出这个promise

08:46.270 --> 08:46.430
好

08:46.430 --> 08:47.230
没有些迷想

08:48.190 --> 08:49.710
我们把这个运行干脆

08:50.670 --> 08:51.310
关到

08:51.310 --> 08:52.510
可以换到另外一个地方吗

08:53.550 --> 08:54.190
哎这个玩意儿

08:55.390 --> 08:56.030
能换吗

08:57.710 --> 08:58.030
等一下

08:58.030 --> 08:58.430
我试一下

08:59.230 --> 09:00.510
将一到一路车

09:00.510 --> 09:00.910
哎

09:00.910 --> 09:01.870
得这样子输付一些

09:03.470 --> 09:04.030
那现在呢

09:04.030 --> 09:04.350
你看

09:04.350 --> 09:05.470
我们现在是不是完成了

09:05.470 --> 09:06.430
result123

09:06.430 --> 09:07.710
那么就fulfill的

09:07.710 --> 09:08.030
值呢

09:08.030 --> 09:08.750
就是123

09:08.750 --> 09:09.630
那如果说我用

09:09.630 --> 09:10.590
用那个regate车呢

09:12.430 --> 09:13.790
那它装上就是regate的

09:13.790 --> 09:14.190
对吧

09:14.190 --> 09:14.830
123

09:14.830 --> 09:15.070
好

09:15.070 --> 09:15.310
OK

09:15.310 --> 09:16.190
这一块就完成了

09:16.910 --> 09:17.550
那么写到这呢

09:17.550 --> 09:19.470
其实我们可以进一步优化我们的程序

09:20.030 --> 09:21.310
首先第一个优化点

09:21.310 --> 09:22.350
就是我们这些状态

09:22.350 --> 09:23.070
我们目前用的是

09:23.070 --> 09:24.190
制物串的处理方式

09:24.190 --> 09:25.070
你看这里是制物串

09:25.070 --> 09:26.030
这里是制物串

09:26.030 --> 09:26.910
那么这种到处

09:26.910 --> 09:28.430
那么我们就会发现

09:28.430 --> 09:29.310
我们在单码里面

09:29.310 --> 09:31.550
可能这些制物串分布在很多地方

09:31.550 --> 09:31.950
以后呢

09:31.950 --> 09:33.150
我们将来的判断啊

09:33.150 --> 09:33.950
判断它的状态

09:33.950 --> 09:35.150
各种状态的处理的

09:35.150 --> 09:36.910
我们都可能会用到这种制物串

09:36.910 --> 09:38.350
是不是会反复使用

09:38.350 --> 09:40.190
那么这种制物串会反复出现的话

09:40.190 --> 09:42.510
那么会造成一些很难维护的

09:42.510 --> 09:43.070
一个问题

09:43.070 --> 09:43.870
将来我如果说

09:43.950 --> 09:45.950
我们把状态的名字想变一下

09:45.950 --> 09:47.310
其实Promise这个

09:47.310 --> 09:48.510
ES6的Promise

09:48.510 --> 09:50.030
它的状态名字都变过一次

09:50.030 --> 09:51.710
一开始完成的状态名字

09:51.710 --> 09:52.670
叫做Razor

09:52.670 --> 09:54.670
后来变成了Fulfill

09:54.670 --> 09:56.110
将来要改变状态名字

09:56.110 --> 09:56.910
是不知道到处感

09:56.910 --> 09:57.950
所以我们一般来说

09:57.950 --> 09:59.230
对这里的做法呢

09:59.230 --> 10:00.670
一个优秀的代码呢

10:00.670 --> 10:02.350
我们可以把它变成一个常量

10:02.350 --> 10:04.110
用常量来代替这个制物串

10:04.110 --> 10:04.990
那我们可以把常量

10:04.990 --> 10:06.430
常量写到线上边

10:06.430 --> 10:10.830
就是记录Promise的三种状态

10:10.830 --> 10:12.190
就一共有只有三种状态

10:12.190 --> 10:13.070
那么我们这里呢

10:13.150 --> 10:14.110
常量的写法呢

10:14.110 --> 10:15.070
我们一般来说

10:16.030 --> 10:17.950
我说的常量不是这个Const

10:17.950 --> 10:19.950
只得是它真正的是常量

10:19.950 --> 10:21.950
真正的永远不会改变的这种东西

10:22.990 --> 10:24.190
我们就写Pendy

10:24.190 --> 10:25.710
那么就写Pendy

10:25.710 --> 10:26.670
用这种模式来写

10:26.670 --> 10:28.190
这种模式其实也很常见的

10:29.150 --> 10:30.670
还有一个就是Fulfill的

10:32.030 --> 10:33.790
把它变成Fulfill的

10:35.630 --> 10:37.550
好 然后还有一个就是Rajigth的

10:38.750 --> 10:39.710
写成Rajigth

10:40.430 --> 10:41.150
好 那么这里呢

10:41.150 --> 10:42.510
我们就可以用这个常量

10:42.510 --> 10:44.270
来替代这个制物串了

10:44.270 --> 10:45.550
这样子写出来 优雅的多

10:46.030 --> 10:47.550
其实大传在考验

10:47.550 --> 10:48.590
考虑这些东西的时候

10:49.070 --> 10:50.190
一方面在考虑

10:50.190 --> 10:51.390
也有你的逻辑思维能力

10:51.390 --> 10:52.910
另一方面也在考验你的代码

10:53.470 --> 10:54.030
处理能力

10:54.030 --> 10:54.910
你想把这种

10:54.910 --> 10:56.350
这些代码把它处理好了之后

10:57.310 --> 10:58.110
写出来

10:58.110 --> 10:59.150
真的很吓人的

10:59.150 --> 11:00.030
说实话

11:00.030 --> 11:01.550
要不会把面试完吓到的

11:01.550 --> 11:02.910
如果你真的能够把

11:02.910 --> 11:04.350
我这些Promise手写的

11:04.910 --> 11:06.110
东西试透

11:06.110 --> 11:07.870
然后面试真的能够把写出来的话

11:07.870 --> 11:08.830
真的会很吓人的

11:09.550 --> 11:10.910
好 这也是一个优化点

11:11.390 --> 11:12.750
然后这个优化点完了之后

11:12.750 --> 11:14.430
你会发现这一块有重复代吗

11:15.470 --> 11:17.230
其实你会发现改变状态

11:19.630 --> 11:20.750
无论是Rajigth也好

11:20.750 --> 11:21.870
还是Rajigth也好

11:21.870 --> 11:22.990
他们都会在改变状态

11:22.990 --> 11:23.470
对不对

11:23.470 --> 11:24.110
所以说我们可以把

11:24.110 --> 11:25.470
改变状态的这个行为

11:25.470 --> 11:26.270
抽离出去

11:26.270 --> 11:27.470
形成一个单独的函数

11:27.470 --> 11:27.790
因此呢

11:27.790 --> 11:29.230
我在这里呢写上一个Change

11:29.230 --> 11:30.110
Status

11:30.110 --> 11:30.430
State

11:31.390 --> 11:32.670
你告诉我一个新的状态

11:33.630 --> 11:34.830
还有一个就是新的数据

11:35.310 --> 11:37.070
OK 那我就帮你改变状态

11:37.070 --> 11:37.950
好 那么这里呢就是

11:38.910 --> 11:40.270
更改状态

11:40.270 --> 11:41.470
更改任务状态

11:42.750 --> 11:44.750
好 那么第一个参数状态呢

11:44.750 --> 11:45.950
肯定是一个字母串

11:45.950 --> 11:46.350
对吧

11:46.350 --> 11:47.390
状态是一个字母串

11:48.110 --> 11:50.110
这是新状态

11:50.750 --> 11:52.750
那么这里呢就是相关数据

11:53.950 --> 11:54.750
成功了

11:55.950 --> 11:56.750
这是N1

11:56.750 --> 11:57.950
任何数据都可以

11:58.750 --> 11:59.550
相关数据

12:00.750 --> 12:01.950
你成功之后啊

12:01.950 --> 12:02.750
你这个数据呢

12:02.750 --> 12:04.750
就是成功的数据

12:04.750 --> 12:05.950
你失败的话

12:05.950 --> 12:06.830
就是失败的原因

12:06.830 --> 12:07.550
反正就是

12:07.950 --> 12:08.990
通用它来传递

12:08.990 --> 12:09.710
那么我们这里呢

12:09.710 --> 12:10.270
要做的事情

12:10.270 --> 12:10.910
其实很简单

12:10.910 --> 12:12.030
是不是就调用Z

12:12.030 --> 12:14.030
ChangeState

12:14.030 --> 12:14.910
把新的状态是什么呢

12:14.910 --> 12:15.630
新的状态就是

12:15.630 --> 12:16.990
这个因为你成功了

12:16.990 --> 12:18.110
所以新的状态是什么

12:18.110 --> 12:18.750
Fullfield

12:19.550 --> 12:20.350
我们用长量

12:21.790 --> 12:22.670
然后呢

12:22.670 --> 12:24.190
那个值呢

12:24.750 --> 12:25.550
值是什么呢

12:25.550 --> 12:26.830
值的就是Data

12:27.630 --> 12:28.670
所以一句话就写完了

12:28.670 --> 12:29.790
那么同样的到这边

12:29.790 --> 12:30.830
也是一句话就写完了

12:31.550 --> 12:33.470
那么这里的就变成Reason

12:33.470 --> 12:34.270
失败了

12:34.270 --> 12:35.070
而Rejected

12:37.330 --> 12:37.810
是吧

12:37.810 --> 12:38.450
就写完了

12:39.650 --> 12:41.250
好那么这个改变状态的话

12:41.250 --> 12:41.970
做什么事情呢

12:41.970 --> 12:43.330
就把刚才的办法写一遍遍

12:44.450 --> 12:46.930
当前的状态是变了变成NewState

12:46.930 --> 12:47.250
然后呢

12:47.250 --> 12:48.850
把当前的什么Value也变了

12:48.850 --> 12:51.090
变成什么变成那个改掉

12:51.090 --> 12:51.730
是不是完事了

12:52.450 --> 12:53.490
好咱们再试一下啊

12:53.490 --> 12:55.170
你会看到效果仍然是一样的

12:56.290 --> 12:57.730
你看变成拒绝了

12:57.730 --> 12:58.770
然后我们调用Result

13:02.420 --> 13:04.020
好变成完成了

13:04.820 --> 13:05.220
对吧

13:05.860 --> 13:06.100
OK

13:07.380 --> 13:08.820
好这一块就完成了

13:08.820 --> 13:09.780
好完成之后呢

13:09.780 --> 13:11.060
我们再来研究啊

13:11.140 --> 13:12.420
这里有没有问题呢

13:12.420 --> 13:13.620
肯定是有问题的

13:13.620 --> 13:14.260
因为我们说过

13:14.260 --> 13:15.540
Promise的状态更改

13:15.540 --> 13:16.180
是不能

13:16.180 --> 13:18.260
就是一旦确定下来是不能改的

13:18.260 --> 13:19.380
这个状态是不能改的

13:20.500 --> 13:21.300
比方说我们现在

13:21.300 --> 13:22.100
如果说这样子的话

13:22.100 --> 13:22.660
你会发现

13:22.660 --> 13:24.020
那状态改了两次

13:24.020 --> 13:25.140
第一次变成Result

13:25.140 --> 13:26.420
后来又变成Rejected

13:27.060 --> 13:27.380
对吧

13:27.380 --> 13:27.940
拒绝也变了

13:28.500 --> 13:30.100
那么状态是不能更改的

13:30.100 --> 13:31.460
所以说我们在改变状态的时候

13:31.460 --> 13:32.340
是不是要做过一个判断

13:32.900 --> 13:33.620
做什么判断呢

13:33.620 --> 13:34.180
判断一下

13:34.980 --> 13:36.980
如果说你当前的状态

13:36.980 --> 13:40.020
已经不等于平顶了

13:41.940 --> 13:42.660
说明什么

13:42.660 --> 13:45.780
说明目前状态已经更改

13:46.420 --> 13:47.540
状态已经被改了

13:47.540 --> 13:48.820
那么以后别

13:48.820 --> 13:50.260
以这一次调用这个签计State

13:50.260 --> 13:50.660
说明说

13:51.220 --> 13:53.140
已经一定不是第一次雕用了

13:53.140 --> 13:54.820
之前已经把状态改过了

13:54.820 --> 13:56.340
那么这个时候我就什么都不干

13:56.900 --> 13:57.620
啥也不干

13:57.620 --> 13:58.580
就写这么一个判断

13:58.580 --> 13:59.620
是不是就完成了

13:59.620 --> 14:00.500
那这个判断出来了

14:00.500 --> 14:01.140
过后我们再来看

14:02.340 --> 14:03.860
是不是只有第一个成功了

14:03.860 --> 14:04.420
改变状态

14:04.420 --> 14:05.700
那后续的是不是都失败了

14:05.700 --> 14:06.500
那后续如果说

14:06.500 --> 14:08.740
我这里改成其他的

14:08.740 --> 14:10.340
哪怕是同一个状态的不同数据

14:10.500 --> 14:11.060
也会失败

14:11.700 --> 14:12.580
为什么呢

14:12.580 --> 14:13.940
是不是跟Promise是一样的

14:14.580 --> 14:15.060
为什么呢

14:15.060 --> 14:16.420
就因为经过这么一个判断

14:16.420 --> 14:18.100
一个判断就会搞定之间的事

14:19.140 --> 14:20.180
好 这里是关了

14:21.300 --> 14:22.500
好 咱们继续

14:22.500 --> 14:23.460
还有什么问题呢

14:23.460 --> 14:24.340
就是如果说

14:24.340 --> 14:25.700
我们在Promise的执行过程中

14:25.700 --> 14:26.820
如说爆出了

14:26.820 --> 14:27.300
1 2 3

14:29.140 --> 14:30.180
到这里有没有处理的

14:30.180 --> 14:31.140
肯定是没有处理

14:31.140 --> 14:33.460
当然我们知道Promise的执行期间

14:33.460 --> 14:34.500
在这些执行期间

14:34.500 --> 14:35.220
一旦爆出

14:35.220 --> 14:36.580
是不是状态就自动变成了什么

14:37.220 --> 14:37.540
失败

14:38.020 --> 14:39.380
那怎么再处理这个事呢

14:39.460 --> 14:40.580
其实非常简单

14:40.580 --> 14:42.820
我就直接把这个函数在执行过程中

14:42.820 --> 14:43.780
看看有没有错误

14:43.780 --> 14:44.500
只要有错误

14:44.500 --> 14:46.980
我就直接帮你调用这个锐介的车

14:46.980 --> 14:47.780
那怎么来处理呢

14:47.780 --> 14:48.660
是不是在这里

14:48.660 --> 14:50.500
在执行这个函数的过程中

14:52.100 --> 14:53.140
你在执行这个函数

14:53.140 --> 14:54.340
我用一个串把它包起来

14:55.060 --> 14:56.180
只要你执行过程中

14:56.180 --> 14:57.460
不管你是发现了什么错误

14:57.460 --> 14:58.580
只要你爆了错误

14:58.580 --> 14:59.540
那我这里干嘛呀

14:59.540 --> 15:01.460
我这里就直接调用这个锐介的车

15:01.940 --> 15:03.140
帮你调用

15:03.140 --> 15:03.940
调用什么呢

15:03.940 --> 15:04.820
错误的原因是什么

15:04.820 --> 15:05.940
不就是错误对象吗

15:06.980 --> 15:07.620
好 保存

15:07.620 --> 15:08.260
你现在看一下

15:09.460 --> 15:10.100
运行

15:10.820 --> 15:12.180
你看 是不是被拒绝了

15:12.180 --> 15:12.900
然后呢

15:12.900 --> 15:13.700
数据是什么

15:13.700 --> 15:15.060
数据是123

15:15.060 --> 15:16.020
因为我抛出来是123

15:16.020 --> 15:17.540
当然你抛出来是别的的话

15:17.540 --> 15:18.900
它就是别的

15:20.260 --> 15:20.820
运行

15:22.340 --> 15:24.340
状态被拒绝

15:24.340 --> 15:24.980
然后呢

15:24.980 --> 15:26.740
据的原因呢

15:26.740 --> 15:27.540
就这个原因

15:27.540 --> 15:29.140
一个AIR对象

15:29.620 --> 15:31.380
就通过这么一个单码就可以处理

15:31.940 --> 15:34.340
OK 那咱们这里可能就写到这吧

15:34.340 --> 15:35.380
我们这里可实现了什么呢

15:35.380 --> 15:36.100
实现了

15:36.740 --> 15:38.180
Promise给它记录状态

15:38.180 --> 15:39.220
和记录相关数据

15:39.780 --> 15:40.180
然后呢

15:40.180 --> 15:41.540
也实现了对那个

15:42.340 --> 15:42.900
构造器

15:42.900 --> 15:44.740
对这个执行器的调用

15:44.740 --> 15:45.540
而且调用过程中

15:45.540 --> 15:46.980
我们可以监控它有错误

15:46.980 --> 15:47.540
有错误的话

15:47.540 --> 15:48.900
我直接把它变成拒绝态

15:49.380 --> 15:50.500
然后我们会发现呢

15:50.500 --> 15:51.620
无论是为作伍也好

15:51.620 --> 15:52.500
还是为借车也好

15:52.500 --> 15:53.540
他们的本质工作

15:53.540 --> 15:54.660
其实没有做啥事

15:54.660 --> 15:56.260
只是改变状态而已

15:56.260 --> 15:57.460
只是把状态给它更改

15:58.100 --> 15:59.140
好 更改状态的时候呢

15:59.140 --> 16:00.260
我们做了一个判断

16:00.260 --> 16:01.220
判断一下这个状态

16:01.220 --> 16:02.500
是不是已经被更改过了

16:02.500 --> 16:04.900
更改过了我就不再去重复更改

16:04.900 --> 16:05.540
没有更改过

16:05.540 --> 16:07.060
我就把光台更改了就行了

16:07.620 --> 16:08.580
OK 那么做一会儿

16:08.580 --> 16:09.540
我们准备完成了

16:09.540 --> 16:10.980
好 同学们可以先跟着我做

16:10.980 --> 16:12.020
把它写到这么一块

16:12.020 --> 16:12.900
体会一下一个代码

16:12.900 --> 16:13.780
到底是什么含义

