WEBVTT

00:00.370 --> 00:03.370
在这个章节 就是对象这个章节

00:03.370 --> 00:07.370
如果说ES6做了什么非常大的改动的话

00:07.370 --> 00:11.370
那么就是对面向对象的全面支持

00:11.370 --> 00:14.370
ES6里面新增了不少的语法

00:14.370 --> 00:17.370
然后呢 让我们在写代码的时候

00:17.370 --> 00:21.370
能够更加轻松地使用面向对象的示威模式给你开发

00:21.370 --> 00:24.370
那么这节课呢 我首先跟大家介绍一下

00:24.370 --> 00:27.370
关于面向对象的一些概念和支持

00:27.370 --> 00:31.370
实际上面向对象呢 它首先不要误解

00:31.370 --> 00:34.370
它不是针对某个语言的

00:34.370 --> 00:37.370
不是说 这个面向对象语言是怎么写的

00:37.370 --> 00:40.370
不是这样子说的 说法就有问题

00:40.370 --> 00:44.370
因为面向对象呢 它是一种程序思想

00:44.370 --> 00:47.370
编程思想

00:47.370 --> 00:50.370
所以说它已经上升到一个思想层面了

00:50.370 --> 00:53.370
它跟具体的语言没有任何关系

00:53.370 --> 00:56.370
跟具体的语言无关

00:56.370 --> 00:59.370
我们说面向对象呢 在写代码的时候呢

00:59.370 --> 01:02.370
我们只是用这个面向对象的这种思想

01:02.370 --> 01:05.370
来进行编程 是这么个意思

01:05.370 --> 01:08.370
像如果一个语言 它能够支持

01:08.370 --> 01:11.370
面向对象的这种示威编程的话

01:11.370 --> 01:14.370
我们认为这个语言呢 是支持面向对象的

01:14.370 --> 01:17.370
是一门面向对象的语言

01:17.370 --> 01:19.370
那我们学习的节课语言

01:19.370 --> 01:22.370
它到底是不是面向对象语言呢 它是

01:22.370 --> 01:25.370
只不过呢 它以前用面向对象来

01:25.370 --> 01:28.370
书写代码的话 没有那么的方便

01:28.370 --> 01:30.370
仅此而已 不过它确实可以使用

01:30.370 --> 01:32.370
面向对象的思维来编程

01:32.370 --> 01:35.370
那么面向对象的思维 它到底是一种

01:35.370 --> 01:38.370
什么样的思维呢 这可能是很多同学都没有搞清楚的一点

01:38.370 --> 01:41.370
我们经常用面向对象和

01:41.370 --> 01:44.370
面向过程来去做对比

01:44.370 --> 01:47.370
对比面向过程

01:47.370 --> 01:50.370
那么 它到底是一个怎么回事呢

01:50.370 --> 01:53.370
这样子的 如果你是面向过程的话

01:53.370 --> 01:57.370
面向过程 它的思考的切入点

01:57.370 --> 02:01.370
是什么呢 是功能的步骤

02:01.370 --> 02:04.370
是功能的步骤

02:04.370 --> 02:06.370
也就是说 我们再简化一下这句话

02:06.370 --> 02:09.370
就说 思考的切入点 它是功能

02:09.370 --> 02:12.370
就是我这个程序里面有哪些功能

02:12.370 --> 02:14.370
第一步做什么 第二步做什么

02:14.370 --> 02:16.370
这是它思维的切入点

02:16.370 --> 02:19.370
不是说面向过程这种思维

02:19.370 --> 02:22.370
里面不能有对象 不过有些人老是会认为

02:22.370 --> 02:24.370
我这里边写了对象的

02:24.370 --> 02:26.370
我就是用面向对象的思维再做开发

02:26.370 --> 02:29.370
那是不一样的 它是切入点不一样

02:29.370 --> 02:31.370
面向过程里面仍然可以有对象

02:31.370 --> 02:34.370
比方说最典型的面向过程的语言 就是什么

02:34.370 --> 02:36.370
C语言 对吧 C语言里面

02:36.370 --> 02:39.370
能不能写出一个类似于对象的结构呢 是可以的

02:39.370 --> 02:43.370
写什么 是结构 对吧 写结构题

02:43.370 --> 02:45.370
结构就类似于对象

02:45.370 --> 02:47.370
它不是说它不能有对象

02:47.370 --> 02:50.370
而是说它的思考的切入点是功能的步骤

02:50.370 --> 02:53.370
它是从这个角度来思考程序的

02:53.370 --> 02:55.370
而面向对象里面

02:55.370 --> 02:57.370
面向对象这个思维的话

02:57.370 --> 02:59.370
它的切入点不一样

02:59.370 --> 03:07.130
思考的切入点是对象的划分

03:07.130 --> 03:08.130
也就是用面向对象的

03:08.130 --> 03:10.130
它不是说面向对象这个思维里面

03:10.130 --> 03:12.130
它不能有步骤

03:12.130 --> 03:14.130
那不能有步骤的功能肯定没法实现

03:14.130 --> 03:16.130
只不过它思考的切入点呢

03:16.130 --> 03:18.130
它不是步骤 而是对象的划分

03:18.130 --> 03:19.130
这样子说起来呢

03:19.130 --> 03:22.130
可能大家还是觉得比较的抽象

03:22.130 --> 03:24.130
那么我给大家举个例子吧

03:24.130 --> 03:27.130
比方说 咱们杜伊布经常用这个例子

03:27.130 --> 03:31.130
叫做大象装冰箱这个例子

03:31.130 --> 03:33.130
这不是个小品里面吧

03:33.130 --> 03:34.130
咱们本山大叔说

03:34.130 --> 03:36.130
大象装冰箱总共分几步呢

03:36.130 --> 03:40.130
是不是第一步 把冰箱门打开

03:40.130 --> 03:41.130
第二步呢 大象放进去

03:41.130 --> 03:43.130
第三步呢 冰箱门关上

03:43.130 --> 03:45.130
就这么一个例子

03:45.130 --> 03:46.130
那么这个例子呢

03:46.130 --> 03:48.130
你看刚才的描述

03:48.130 --> 03:50.130
其实就是一种面向过程的

03:50.130 --> 03:51.130
这么一种思维

03:51.130 --> 03:52.130
那如果说

03:52.130 --> 03:54.130
你用这种思维来写程序的话

03:54.130 --> 03:55.130
你写出来的程序呢

03:55.130 --> 03:56.130
大概是这个样子

03:56.130 --> 03:57.130
我给大家写一下啊

03:57.130 --> 03:59.130
就随便瞎写一些伟代嘛

03:59.130 --> 04:01.130
那么你可能会这样子写

04:01.130 --> 04:02.130
方形

04:02.130 --> 04:04.130
或者说你都不用方个形的

04:04.130 --> 04:05.130
你打个注写

04:05.130 --> 04:09.130
第一步 冰箱门打开

04:09.130 --> 04:10.130
然后呢

04:10.130 --> 04:11.130
你这里去写一些代码

04:11.130 --> 04:12.130
冰箱门打开

04:12.130 --> 04:13.130
怎么去打开冰箱门

04:13.130 --> 04:14.130
然后第二步呢

04:14.130 --> 04:16.130
大象装进去

04:16.130 --> 04:17.130
然后呢

04:17.130 --> 04:18.130
第三步呢

04:18.130 --> 04:19.130
是什么呢

04:19.130 --> 04:21.130
冰箱门关上

04:21.130 --> 04:25.130
如果说你在面向过程的写法上

04:25.130 --> 04:27.130
可能会写相应的一些函数

04:27.130 --> 04:28.130
冰箱门打开

04:28.130 --> 04:30.130
我们这里写这么一个函数

04:30.130 --> 04:31.130
叫做

04:31.130 --> 04:33.130
open

04:33.130 --> 04:34.130
open

04:34.130 --> 04:35.130
frag

04:35.130 --> 04:36.130
对吧

04:36.130 --> 04:38.130
frag 是这样写吧

04:38.130 --> 04:39.130
冰箱门打开

04:39.130 --> 04:40.130
然后呢

04:40.130 --> 04:41.130
这里调用一下

04:41.130 --> 04:42.130
openfrag

04:42.130 --> 04:43.130
其实我们有的时候开发成语

04:43.130 --> 04:44.130
不就是这样开发的吗

04:44.130 --> 04:45.130
对不对

04:45.130 --> 04:47.130
大象装进去

04:47.130 --> 04:48.130
就是

04:48.130 --> 04:51.130
elephant

04:51.130 --> 04:52.130
in

04:52.130 --> 04:53.130
大象装进去

04:53.130 --> 04:54.130
然后呢

04:54.130 --> 04:56.130
我们这里调用elephantin

04:56.130 --> 04:57.130
大象装进去

04:57.130 --> 04:58.130
然后呢

04:58.130 --> 04:59.130
冰箱门关上

04:59.130 --> 05:00.130
我们又写个函数

05:00.130 --> 05:01.130
当然我这个函数里边啥都没写

05:01.130 --> 05:02.130
就是举这么个例子

05:02.130 --> 05:04.130
closefrag

05:04.130 --> 05:05.130
那么这里调用

05:05.130 --> 05:06.130
closefrag

05:06.130 --> 05:07.130
对吧

05:07.130 --> 05:08.130
这就是一种典型的

05:08.130 --> 05:10.130
面向过程的思维

05:10.130 --> 05:11.130
当然这种思维

05:11.130 --> 05:12.130
不是说它错

05:12.130 --> 05:13.130
不是说

05:13.130 --> 05:14.130
面向对象一定好

05:14.130 --> 05:15.130
面向过程呢

05:15.130 --> 05:16.130
就一定差

05:16.130 --> 05:18.130
不是这么个意思

05:18.130 --> 05:19.130
只不过呢

05:19.130 --> 05:21.130
在面对不同的场景

05:21.130 --> 05:22.130
面对不同的

05:22.130 --> 05:24.130
复杂度的程序里边

05:24.130 --> 05:25.130
我们

05:25.130 --> 05:27.130
他们各有各的优势

05:27.130 --> 05:28.130
面向过程呢

05:28.130 --> 05:29.130
可能比较适合

05:29.130 --> 05:30.130
做那种

05:30.130 --> 05:32.130
精小

05:32.130 --> 05:33.130
就是

05:33.130 --> 05:35.130
比较小的模块

05:35.130 --> 05:36.130
一个小的功能

05:36.130 --> 05:37.130
使用面向过程

05:37.130 --> 05:39.130
其实做起来是非常不错的

05:40.130 --> 05:41.130
面向对象呢

05:41.130 --> 05:43.130
它特别适合应付那种

05:43.130 --> 05:44.130
大中型项目

05:44.130 --> 05:45.130
复杂的项目

05:45.130 --> 05:46.130
联系非常多的项目

05:46.130 --> 05:47.130
而且要经常维护

05:47.130 --> 05:49.130
经常修改的项目

05:49.130 --> 05:50.130
所以说面向对象呢

05:50.130 --> 05:52.130
它更加能够

05:52.130 --> 05:54.130
应付大型的工程

05:54.130 --> 05:56.130
而我们现在前端呢

05:56.130 --> 05:57.130
工程的复杂度

05:57.130 --> 05:58.130
越来越高

05:58.130 --> 05:59.130
所以说呢

05:59.130 --> 06:00.130
面向对象呢

06:00.130 --> 06:02.130
从所谓有的如此重要

06:02.130 --> 06:03.130
因此呢

06:03.130 --> 06:04.130
在ES6里面

06:04.130 --> 06:06.130
它做了不少的

06:06.130 --> 06:07.130
语法

06:07.130 --> 06:08.130
新增了不少的语法

06:08.130 --> 06:09.130
面向对象呢

06:09.130 --> 06:11.130
进行了支持

06:11.130 --> 06:12.130
好吧

06:12.130 --> 06:13.130
那么我们如果说

06:13.130 --> 06:14.130
刚才这个程序

06:14.130 --> 06:15.130
如果说你用一个

06:15.130 --> 06:17.130
面向对象的方式来开发

06:17.130 --> 06:18.130
咱们来对比一下啊

06:18.130 --> 06:19.130
如果说来用

06:19.130 --> 06:20.130
面向对象的方式来开发

06:20.130 --> 06:21.130
我会怎么写呢

06:21.130 --> 06:22.130
我的思考切入点

06:22.130 --> 06:23.130
我根本就不是

06:23.130 --> 06:24.130
第一步做什么

06:24.130 --> 06:25.130
第二步做什么

06:25.130 --> 06:26.130
而我思考的切入点

06:26.130 --> 06:27.130
是什么呢

06:27.130 --> 06:28.130
我这个程序里边

06:28.130 --> 06:29.130
有哪些对象

06:29.130 --> 06:30.130
一看一下名词

06:30.130 --> 06:31.130
对吧

06:31.130 --> 06:32.130
我们一般

06:32.130 --> 06:33.130
找对象的话

06:33.130 --> 06:34.130
就找什么

06:34.130 --> 06:35.130
找名词

06:35.130 --> 06:36.130
就一个需求描述里面

06:36.130 --> 06:37.130
它的名词

06:37.130 --> 06:38.130
它是不是有两个名词

06:38.130 --> 06:39.130
一个大象

06:39.130 --> 06:40.130
一个冰箱

06:40.130 --> 06:41.130
我们就写上

06:41.130 --> 06:43.130
两个构造函数

06:43.130 --> 06:44.130
一个是大象

06:44.130 --> 06:45.130
ELEPHANT

06:45.130 --> 06:46.130
对吧

06:46.130 --> 06:47.130
这是面向对象的

06:47.130 --> 06:48.130
思考的切入方式

06:48.130 --> 06:49.130
当然大象

06:49.130 --> 06:50.130
还有一些属性

06:50.130 --> 06:51.130
对吧

06:51.130 --> 06:52.130
我们还可以给属性负责

06:52.130 --> 06:53.130
大象呢

06:53.130 --> 06:54.130
还有一些方法

06:54.130 --> 06:55.130
对不对

06:55.130 --> 06:56.130
还有一些方法

06:56.130 --> 06:57.130
那么可以

06:57.130 --> 06:58.130
把这些东西加进去

06:58.130 --> 06:59.130
我就不写了

06:59.130 --> 07:00.130
然后大象

07:00.130 --> 07:01.130
不写到这了

07:01.130 --> 07:03.130
然后大象还可以叫

07:03.130 --> 07:04.130
还可以什么

07:04.130 --> 07:05.130
吃东西

07:05.130 --> 07:06.130
还可以就是喝水

07:06.130 --> 07:07.130
真的

07:07.130 --> 07:08.130
这是面向对象的

07:08.130 --> 07:09.130
思维方式

07:09.130 --> 07:10.130
我根本就一开始

07:10.130 --> 07:11.130
根本就不去考虑什么

07:11.130 --> 07:12.130
不去考虑

07:12.130 --> 07:13.130
它第一步做啥

07:13.130 --> 07:14.130
第二步做啥

07:14.130 --> 07:15.130
考虑不考虑这一点

07:15.130 --> 07:16.130
我就考虑它里边

07:16.130 --> 07:17.130
有哪些对象

07:17.130 --> 07:18.130
每个对象里边

07:18.130 --> 07:19.130
有哪些属性

07:19.130 --> 07:20.130
有哪些方法

07:20.130 --> 07:21.130
然后还有个什么

07:21.130 --> 07:22.130
还有一个冰箱

07:22.130 --> 07:23.130
对吧

07:23.130 --> 07:24.130
FRAGE

07:24.130 --> 07:25.130
冰箱

07:25.130 --> 07:26.130
那么冰箱

07:26.130 --> 07:27.130
在我们的系统里边

07:27.130 --> 07:29.130
就非常的

07:29.130 --> 07:31.130
大象的构造函数

07:31.130 --> 07:32.130
这是冰箱的构造函数

07:32.130 --> 07:33.130
冰箱在我们的系统里边

07:33.130 --> 07:35.130
它就有一些方法了

07:35.130 --> 07:36.130
冰箱

07:36.130 --> 07:37.130
好

07:37.130 --> 07:38.130
比方说

07:38.130 --> 07:39.130
冰箱里边有些方法

07:39.130 --> 07:40.130
冰箱我们可以

07:40.130 --> 07:41.130
原形上加一个方法

07:41.130 --> 07:42.130
有哪些方法

07:42.130 --> 07:43.130
Open door

07:43.130 --> 07:44.130
对吧

07:44.130 --> 07:45.130
打开冰箱门

07:45.130 --> 07:46.130
它是一个方法

07:46.130 --> 07:47.130
我们就不写了

07:47.130 --> 07:49.130
然后冰箱还有什么方法

07:49.130 --> 07:50.130
就是我不去考虑

07:50.130 --> 07:51.130
它第一步做啥

07:51.130 --> 07:52.130
第二步做啥

07:52.130 --> 07:53.130
我们先把对象的

07:53.130 --> 07:54.130
一些花粉

07:54.130 --> 07:55.130
Close door

07:55.130 --> 07:56.130
对吧

07:56.130 --> 07:58.130
冰箱门关上

07:58.130 --> 07:59.130
然后还有什么

07:59.130 --> 08:01.130
往冰箱里边装一件东西

08:01.130 --> 08:02.130
对不对

08:02.130 --> 08:03.130
我们在这里

08:03.130 --> 08:06.130
就是装一些东西

08:06.130 --> 08:07.130
就是

08:07.130 --> 08:08.130
用个什么

08:08.130 --> 08:09.130
就意

08:09.130 --> 08:10.130
就意嘛

08:10.130 --> 08:12.130
往冰箱里边装一件东西

08:12.130 --> 08:13.130
装点东西

08:13.130 --> 08:14.130
那么装东西的时候

08:14.130 --> 08:15.130
你是不是少给我一个东西

08:15.130 --> 08:16.130
对吧

08:16.130 --> 08:17.130
something

08:17.130 --> 08:18.130
你给我一件东西

08:18.130 --> 08:20.130
我就把它装到冰箱里边去

08:20.130 --> 08:21.130
对吧

08:21.130 --> 08:22.130
冰箱里边去提供了

08:22.130 --> 08:23.130
这么一些方法

08:23.130 --> 08:24.130
明白这意思吗

08:24.130 --> 08:25.130
你看一下

08:25.130 --> 08:26.130
面向对象的示威

08:26.130 --> 08:27.130
你看一下我现在的功能

08:27.130 --> 08:28.130
只能执行吗

08:28.130 --> 08:29.130
一句话都不能执行

08:29.130 --> 08:30.130
因为我都没有必要用

08:30.130 --> 08:31.130
但是我已经把功能

08:31.130 --> 08:32.130
全部描述完了

08:32.130 --> 08:33.130
通过对象的方式

08:33.130 --> 08:34.130
把功能描述完了

08:34.130 --> 08:35.130
然后接下来

08:35.130 --> 08:36.130
我要去玩的这件事

08:36.130 --> 08:37.130
就非常简单了

08:37.130 --> 08:38.130
第一步做什么呢

08:38.130 --> 08:39.130
你说面向对象里边

08:39.130 --> 08:40.130
能不能有步骤

08:40.130 --> 08:41.130
肯定能有步骤

08:41.130 --> 08:42.130
但是它一定切入点

08:42.130 --> 08:43.130
一定不是步骤

08:43.130 --> 08:44.130
一定是对象

08:44.130 --> 08:45.130
是这么个意思

08:45.130 --> 08:46.130
我相信我这样说

08:46.130 --> 08:47.130
大家明白了吧

08:47.130 --> 08:49.130
那么比较第一步做什么呢

08:49.130 --> 08:51.130
冰箱门打开

08:51.130 --> 08:52.130
对吧

08:52.130 --> 08:53.130
打开

08:53.130 --> 08:54.130
那么是不是我们得有一个冰箱

08:54.130 --> 08:55.130
ok 我自己建个冰箱

08:55.130 --> 08:56.130
frag

08:56.130 --> 08:58.130
new一个frag

08:58.130 --> 08:59.130
创建一个冰箱

08:59.130 --> 09:00.130
然后干嘛呢

09:00.130 --> 09:01.130
冰箱门打开

09:01.130 --> 09:02.130
open door

09:02.130 --> 09:03.130
对吧

09:03.130 --> 09:04.130
你看一下

09:04.130 --> 09:05.130
这是面向对象的开发方式

09:05.130 --> 09:06.130
第二步呢

09:06.130 --> 09:07.130
是什么呢

09:07.130 --> 09:09.130
大象装进去

09:09.130 --> 09:11.130
大象装进去

09:11.130 --> 09:12.130
大象装进去怎么呢

09:12.130 --> 09:13.130
我是不是得一个大象

09:13.130 --> 09:14.130
animate

09:14.130 --> 09:16.130
new element

09:16.130 --> 09:17.130
anifant

09:17.130 --> 09:18.130
然后呢

09:18.130 --> 09:19.130
是不是把大象装进去

09:19.130 --> 09:20.130
刚才的frag里面

09:20.130 --> 09:21.130
不是一个函数吗

09:21.130 --> 09:22.130
就引

09:22.130 --> 09:23.130
装进去

09:23.130 --> 09:24.130
那么这里传什么

09:24.130 --> 09:25.130
传一个大象

09:25.130 --> 09:26.130
把大象传进去

09:26.130 --> 09:28.130
把大象装到冰箱里面去

09:28.130 --> 09:29.130
然后呢

09:29.130 --> 09:30.130
第三步

09:30.130 --> 09:31.130
做什么呢

09:31.130 --> 09:32.130
第三步

09:32.130 --> 09:34.130
是不是把冰箱门关上

09:34.130 --> 09:36.130
对不对

09:36.130 --> 09:38.130
关上

09:38.130 --> 09:40.130
好 那么这里呢

09:40.130 --> 09:42.130
我们就frag

09:42.130 --> 09:43.130
closed door

09:43.130 --> 09:44.130
看没

09:44.130 --> 09:45.130
是不是仍然有步骤啊

09:45.130 --> 09:46.130
只不过它思考的

09:46.130 --> 09:47.130
切入点不一样

09:47.130 --> 09:48.130
那么我们对比一下

09:48.130 --> 09:49.130
这两套程序

09:49.130 --> 09:50.130
你会发现

09:50.130 --> 09:51.130
在小的系统里边

09:51.130 --> 09:52.130
你看一下面向过程的代码

09:52.130 --> 09:54.130
是不是更加精简啊

09:54.130 --> 09:55.130
对不对

09:55.130 --> 09:56.130
更加的精简

09:56.130 --> 09:57.130
所以说面向对象

09:57.130 --> 09:58.130
它不说一定好

09:58.130 --> 09:59.130
在一些小的系统里边

09:59.130 --> 10:01.130
反而它没有面向过程的那种方式

10:01.130 --> 10:03.130
来的方便

10:03.130 --> 10:04.130
面向对象的呢

10:04.130 --> 10:05.130
你会发现

10:05.130 --> 10:06.130
它多写了很多的代码

10:06.130 --> 10:07.130
对吧

10:07.130 --> 10:08.130
是这么个意思

10:08.130 --> 10:09.130
不过呢

10:09.130 --> 10:10.130
如果说你在大型系统里边

10:10.130 --> 10:11.130
也要考虑可维护性

10:11.130 --> 10:12.130
可扩展性

10:12.130 --> 10:13.130
那么

10:13.130 --> 10:14.130
面向对象

10:14.130 --> 10:15.130
肯定是要忧郁面向过程的

10:15.130 --> 10:16.130
为什么呢

10:16.130 --> 10:17.130
你看一下啊

10:17.130 --> 10:18.130
我们这里分化了

10:18.130 --> 10:19.130
两个对象出来

10:19.130 --> 10:20.130
那么将来有一天

10:20.130 --> 10:21.130
如果说

10:21.130 --> 10:22.130
这个冰箱

10:22.130 --> 10:24.130
它不仅要装大象装别的

10:24.130 --> 10:25.130
是不是这个程序

10:25.130 --> 10:26.130
已经具备这样的功能了

10:26.130 --> 10:27.130
你看

10:27.130 --> 10:28.130
这个是不是已经可以装别的东西了

10:28.130 --> 10:29.130
诶

10:29.130 --> 10:30.130
冰箱门打开

10:30.130 --> 10:31.130
冰箱门关上

10:31.130 --> 10:32.130
功能就与军具备了

10:32.130 --> 10:33.130
诶

10:33.130 --> 10:34.130
你可以去随意的

10:34.130 --> 10:35.130
去组合这些对象的功能

10:35.130 --> 10:36.130
而并且来说

10:36.130 --> 10:37.130
我们可以装一个东西的时候呢

10:37.130 --> 10:38.130
就已经可以把

10:38.130 --> 10:39.130
这些过程写进去了

10:39.130 --> 10:40.130
比方说这里

10:40.130 --> 10:41.130
啊

10:41.130 --> 10:42.130
装东西是不是

10:42.130 --> 10:43.130
首先Open Door

10:43.130 --> 10:44.130
对吧

10:44.130 --> 10:45.130
打开门

10:45.130 --> 10:46.130
然后呢

10:46.130 --> 10:47.130
把东西装进去

10:47.130 --> 10:48.130
啊

10:48.130 --> 10:49.130
装东西完了过后

10:49.130 --> 10:50.130
是不是啊

10:50.130 --> 10:51.130
Close Door

10:51.130 --> 10:52.130
对吧

10:52.130 --> 10:53.130
关闭这个门

10:53.130 --> 10:54.130
那么这样子一来了

10:54.130 --> 10:55.130
这些写好的函数

10:55.130 --> 10:56.130
啊

10:56.130 --> 10:57.130
直接利用这个写好的函数

10:57.130 --> 10:58.130
啊

10:58.130 --> 10:59.130
Fridge

10:59.130 --> 11:00.130
啊

11:00.130 --> 11:01.130
把东西装进去

11:01.130 --> 11:02.130
完事了

11:02.130 --> 11:03.130
Fridge

11:03.130 --> 11:04.130
啊

11:04.130 --> 11:05.130
Joy

11:05.130 --> 11:06.130
啊

11:06.130 --> 11:07.130
然后留一个Elephant

11:07.130 --> 11:08.130
对吧

11:08.130 --> 11:09.130
是不是可以这样做了

11:09.130 --> 11:10.130
啊

11:10.130 --> 11:11.130
就是面向对象的功能了

11:11.130 --> 11:13.130
它更加容易组合和拆分

11:13.130 --> 11:15.130
更加容易进行单元测试

11:15.130 --> 11:16.130
因此呢

11:16.130 --> 11:17.130
它更加利于

11:17.130 --> 11:18.130
书写大型的项目

11:18.130 --> 11:19.130
啊

11:19.130 --> 11:20.130
更加容易应对大型的项目

11:20.130 --> 11:21.130
啊

11:21.130 --> 11:22.130
这就是面向过程的

11:22.130 --> 11:23.130
一些

11:23.130 --> 11:24.130
简单的知识

11:24.130 --> 11:25.130
给它介绍一下

11:25.130 --> 11:26.130
那么介绍这些知识的目的

11:26.130 --> 11:27.130
啊

11:27.130 --> 11:28.130
是为了告诉大家

11:28.130 --> 11:29.130
啊

11:29.130 --> 11:30.130
后边我们学习ES6

11:30.130 --> 11:31.130
会学习一些新的语法

11:31.130 --> 11:32.130
来应付面向对象的场景

11:32.130 --> 11:33.130
之前单码的没能写

11:33.130 --> 11:34.130
能写

11:34.130 --> 11:35.130
只是比较麻烦

11:35.130 --> 11:36.130
好吧

11:36.130 --> 11:37.130
我们先把这个

11:37.130 --> 11:38.130
面向对象的思维

11:38.130 --> 11:39.130
给它介绍一下

