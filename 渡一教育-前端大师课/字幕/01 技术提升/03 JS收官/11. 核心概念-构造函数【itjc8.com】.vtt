WEBVTT

00:00.000 --> 00:05.000
好 我们这节课呢 来聊一个比较重要的概念 叫做各兆函数

00:05.000 --> 00:11.000
我们现在从一个例子开始吧 我们再说回到数据的表达

00:11.000 --> 00:18.000
就我们之前很早的时候就复习过数据的表达 就是我们要在程序表达一个数据

00:18.000 --> 00:23.000
那比方说现在我们有这么一个数据 就是一个用户或者是一个人

00:23.000 --> 00:29.000
我们该怎么来表达呢 我们知道肯定是用一个对象 对吧 比方说我们用一个person来表达一个人

00:30.000 --> 00:38.000
好 我们就写个对象 我这里有这么一些数据 人的姓比方邓

00:38.000 --> 00:53.380
那是名字 序名 然后再来一个全称 全称叫邓序名 是吧 姓名

00:53.380 --> 00:59.380
那这一块能不能拼接一下 当然可以 但是你能不能这样子写

01:01.380 --> 01:09.380
你能不能这样子写 不行哈 你这样子写相当于是什么呢 相当于是你用的是变量

01:09.380 --> 01:15.380
哪有这个变量啊 没有这个变量啊 哪有这个变量 这是属性还不是变量

01:15.380 --> 01:18.380
那那一图是怎么写的 那能不能这样子写呢

01:20.380 --> 01:24.380
person 第二段是你 我们输出一下person

01:25.380 --> 01:32.380
person 你看呀 他直接一报错了 他说 这个错误还是挺常见的

01:32.380 --> 01:40.380
看large rate of property 无法读取属性 什么属性呢 first name of undefined

01:40.380 --> 01:45.380
无法读取undefined的属性 first name 他说了半天说的啥意思

01:45.380 --> 01:51.380
就是你要读这个first name 但是他是undefined 回忆一下我们之前学的知识

01:52.380 --> 01:59.380
他为什么是undefined 你不是干扶植了吗 不是个对象吗 为什么是undefined

02:00.380 --> 02:07.380
就是因为这个代码你得分开看 所以说之前为什么我不断的强调先运行这个

02:07.380 --> 02:12.380
是不是先把对象做出来 做出来之后再给他扶植

02:12.380 --> 02:16.380
那么在做的过程中是不是这里还没有植啊 所以他是undefined

02:17.380 --> 02:22.380
那你咋写的不行 你用变量的没有这个变量 你用属性他没法直接读取属性

02:22.380 --> 02:27.380
你用对象呢 又也不行 因为对象他没有这两个属性

02:27.380 --> 02:32.380
说你不能这样子写啊 你只能这样子写 瞪瞧

02:32.380 --> 02:39.380
或者说你可以这样子写 我先把这个对象弄出来 弄出来之后呢再给他加一个属性

02:39.380 --> 02:49.010
Person,Folian 这个加上 这样子是可以的 这样就没问题了

02:49.010 --> 02:56.010
Folian 等于加一个属性 反正就是有这么一些属性嘛 就是有这么一些属性

02:56.010 --> 03:02.010
我就用这种方式吧 还有什么呢 比方说这个人里边他有一个函数

03:02.010 --> 03:08.010
诶 属性是可以是函数的啊 为什么不能呢 既然是里边函数可以放到任何位置

03:09.010 --> 03:13.010
函数是不是可以给一个变量负责 是不是可以这样子

03:13.010 --> 03:18.010
我们上一课是不是写过了 那怎么能给一个属性负责 为什么不行

03:18.010 --> 03:25.010
这是数据啊 数据可以放任何地方 好 因此呢 只不过那个数据呢

03:25.010 --> 03:30.010
它是一个函数而已 函数本身也是数据 所以说你这里是不是可以写个函数

03:30.010 --> 03:36.010
比方说要写个什么函数 打招呼 say hi 那么它是一个函数方形

03:37.010 --> 03:42.010
像这种啊 它有一个特殊的教法 叫做方法 或者对象方法

03:44.010 --> 03:49.010
我们通常把它简称为方法 就是如果说 当然它本质是一样的啊

03:50.010 --> 03:54.010
就说这个属性呢 它的值是一个函数 我们通常把这个属性叫做方法

03:55.010 --> 03:57.010
好 那么这个函数那我不要那么就输出

03:58.010 --> 04:05.010
输出 诶 那个我的名字叫做 评计一下啊 叫做啥

04:06.010 --> 04:10.010
叫做啥 叫做那个person.fully

04:11.010 --> 04:15.010
好 有些同学又要问了 诶 袁老师啊 你这行不行啊 你这

04:16.010 --> 04:20.010
你这里刚才不是叫暴戳嘛 对吧 这里是不是undefend要暴戳嘛

04:20.010 --> 04:25.010
你这么能写到这呢 搞清楚哈 我这里是函数

04:25.010 --> 04:32.010
我这里是函数 现在运行吧 现在运行吧 我现在运行 他会不会输出这句话啊

04:33.010 --> 04:39.010
函数要什么时候运行 是吧 雕用的时候运行 而雕用的时候 是不是这个东西已经有值了

04:40.010 --> 04:44.010
person已经复职完成了 对吧 把这个东西已经复职过去了 比方说什么时候雕用

04:45.010 --> 04:50.010
比方说这个时候雕用 person.say hi 是不是这样雕用 为什么这样雕用

04:50.010 --> 04:55.010
你看前表达式嘛 对相嘛 这是对相 对相里面这个属性 这个属性是不是函数

04:55.010 --> 04:59.010
那么这个表达式是不是函数 这个表达式是不是就是这个函数啊

05:00.010 --> 05:04.010
这个表达式就是这个函数 然后加上两个好过号 是不是雕用它

05:04.010 --> 05:08.010
那雕用它了 这个时候它才会运行这句话 那运行这句话的时候

05:08.010 --> 05:13.010
这个person是不是已经有值了 我刚才之前也学过 函数里面是不是可以用外边东西

05:13.010 --> 05:17.010
外边是什么 外边定义的 person 是不是可以用外边的 没问题吧

05:18.010 --> 05:22.010
对吧 那么现在就可以打招呼了 我的名字叫特区

05:22.010 --> 05:27.010
OK 我们搞了半天 我就做出来这么一个对相 就是这一坨代码

05:28.010 --> 05:32.010
没问题吧 好好看一下这个代码 这个代码得理解啊 这个代码并不复杂

05:33.010 --> 05:38.010
好 你如果说感觉有点不稳的话 你最好自己跟着写一遍

05:38.010 --> 05:43.010
最好都跟着写一遍吧 写一遍 对吧 再写个对相出来

05:44.010 --> 05:47.010
然后再弄一个全名 然后再写一个方法

05:48.010 --> 05:51.010
当然那方法能不能这样子写呢 就是我把它写下面

05:53.010 --> 05:58.010
对吧 这样子 person 点属性给它复制为一个方法

05:58.010 --> 06:00.010
可不可以的 当然可以啊 为什么不喜欢

06:01.010 --> 06:03.010
然后person 点say hi

06:04.010 --> 06:06.010
这也可以啊 没问题啊

06:07.010 --> 06:12.010
总之就是弄出来 这一坨代码就弄一个人出来了 对吧

06:13.010 --> 06:18.010
我们用一个数据来表达了一个人 这个人里边有三个属性 一个方法

06:19.010 --> 06:24.010
好 那我要说什么问题呢 这样做什么问题 这样做没什么问题

06:25.010 --> 06:28.010
或者说问题不大 但是如果说你考虑到

06:28.010 --> 06:32.010
我们程序里边不只有一个凳格 还有什么 还有成格

06:32.010 --> 06:41.010
还有脑袁 应该叫进格 还有什么呢 还有谢老师 还有韩老师

06:41.010 --> 06:47.010
还有莫莉卡 还有很多很多的人 那怎么弄呢 比方一个班的学生有这么多人

06:48.010 --> 06:52.010
那我们每一次来一个这么一大坨代码 我才创建一个人 行不行 当然可以

06:52.010 --> 06:54.010
只要你就不觉得烦 那当然可以啊

06:55.010 --> 06:59.010
每一次来这么一大坨代码 我来创建一个人 是不是很烦啊

07:00.010 --> 07:04.010
而且很多代码是不是在一样的 你看每个人的打招呼是不是一样的

07:05.010 --> 07:07.010
每个人的 full name 是不是都是这样的 这样的写法

07:08.010 --> 07:13.010
那我们应该怎么做啊 我们根据之前的知识 像这种重复大量重复性的代码

07:13.010 --> 07:17.010
我应该怎么做 是不是把它提成一个函数啊 对吧

07:17.010 --> 07:22.010
于是我就在写了这么一个函数叫 create 创建 这个函数的命名

07:23.010 --> 07:27.010
慢慢的跟着老师学习命名规范

07:28.010 --> 07:32.010
create 创建 创建什么呢 创建一个 person

07:33.010 --> 07:38.010
是吧 脱风的迷法 创建一个 person 函数名字就知道他要干什么了

07:39.010 --> 07:43.010
好 然后接下来写函数 这个函数里边 你要告诉我啥些东西

07:43.010 --> 07:47.010
我就可以帮你创建一个人的 你只需要告诉我 first name

07:48.010 --> 07:53.010
名字和信 是不是就可以创一个名一个信 对吧

07:53.010 --> 07:57.010
你把这两个告诉我 你要不要告诉我这个 不需要啊

07:57.010 --> 07:59.010
我这两个东西就可以直接生成这个了

07:59.010 --> 08:02.010
所以不需要你告诉我全命 我自己给你帮你生成

08:02.010 --> 08:06.010
好 打招呼需不需要告诉我 这个函数是不是需要告诉我 不需要啊

08:07.010 --> 08:09.010
对吧 我自己给你写好 都是一样的嘛

08:09.010 --> 08:11.010
所以你只需要告诉我 first name 和 last name

08:11.010 --> 08:14.010
我就可以帮你创建一个人 我怎么创建的

08:14.010 --> 08:18.010
我就把这个代码直接复制粘贴过来 对吧

08:19.010 --> 08:22.010
变成一个什么 变成换一个名字吧 换一个obj吧

08:28.160 --> 08:32.160
好 然后呢 把这个 first name 变成啥 变成这个变量 对吧

08:33.160 --> 08:37.160
它的信是这个 名呢 是这个 你别看两个一样啊

08:37.160 --> 08:40.160
但是含义是不一样的 这叫属性名 这叫属性值

08:40.160 --> 08:43.160
属性的值是数据 来自于哪儿 来自于参数

08:44.160 --> 08:47.160
来自于参数 放过来 来自于参数 放过来

08:48.160 --> 08:50.160
懂了意思吧 好 然后呢 给它 full name 复制

08:50.160 --> 08:54.160
full name 的话就来自于这两个相加 对不对

08:55.160 --> 08:59.160
当然这里呢 因为它这两个变量 这两个参数也是这个值

08:59.160 --> 09:02.160
所以说你这里完全可以减一些一下 都可以啊

09:02.160 --> 09:05.160
这个邪法有很多的 不要把程序学死了

09:06.160 --> 09:08.160
是不是可以 因为这里有参数嘛 参数里边是不是有

09:08.160 --> 09:10.160
那么其实这里 full name 呢 也可以放这儿

09:12.160 --> 09:14.160
为什么呢 这里就没问题了

09:14.160 --> 09:16.160
因为之前是没有这两个变量 对吧

09:16.160 --> 09:19.160
现在有的 对吧 有两个参数了 就可以直接拿过来用

09:20.160 --> 09:23.160
都行 好 然后打招呼的时候呢

09:23.160 --> 09:26.160
我的名字叫做啥 啥 对吧 就完了

09:27.160 --> 09:33.160
好 创建好对象之后呢 你还要怎么样 你还要把对象返回

09:33.160 --> 09:36.160
去把对象返回啊 不然的话别人怎么拿到了

09:37.160 --> 09:42.160
有了这个函数之后啊 我们后边创建人就变得非常简单了

09:42.160 --> 09:45.160
我怎么创建 我就来一个 craze person

09:46.160 --> 09:54.160
姓传进去 名传进去 序名 就完了 是不是就创建一个人的

09:54.160 --> 09:57.160
因为这个函数它会返回 对吧 把对象返回

09:57.160 --> 10:00.160
当然我们知道 根据值类型和引用类型

10:00.160 --> 10:03.160
那么它返回的是一个地址 对吧 一个对象的地址

10:03.160 --> 10:05.160
然后把地址保存到这儿

10:06.160 --> 10:09.160
所以可以了 好 那我们来看一下啊

10:09.160 --> 10:11.160
这个person里边它就会自动的拥有

10:11.160 --> 10:13.160
我们来输出一下这个person

10:14.160 --> 10:16.160
你看是不是自动拥有了 first name

10:16.160 --> 10:20.160
那是 name for name say hi 全部都有了

10:20.160 --> 10:22.160
然后呢 我们它里边既然有打招呼

10:22.160 --> 10:25.160
我们可以让它打个招呼 say hi

10:25.160 --> 10:31.050
是不是可以了 这样子做是不是好的多

10:31.050 --> 10:33.050
我们通过一个函数来帮我们来创建对象

10:33.050 --> 10:37.050
其实本质是一样的 就是我们少写了很多代

10:37.050 --> 10:41.050
把这个函数来专门来帮我们创建对象

10:41.050 --> 10:43.050
创建好对象过后来我们接受一下

10:43.050 --> 10:45.050
然后后面就可以用这个对象

10:45.050 --> 10:47.050
它里边各种属性啊 方法啊 都没有写好了

10:47.050 --> 10:49.050
那之后我们要创建其他的人

10:49.050 --> 10:52.050
比方说我们再来创建person1

10:52.050 --> 10:57.620
再来创建一个Molica

10:58.620 --> 11:00.620
我不要包入Molica的全名了

11:00.620 --> 11:03.620
我就帮成哥吧 基层

11:03.620 --> 11:08.910
好 没看 一下就创建好了另外一个人了

11:08.910 --> 11:10.910
是不是非常方便

11:10.910 --> 11:12.910
person2 say hi 打个招呼

11:13.910 --> 11:15.910
是不是可以了

11:15.910 --> 11:17.910
这就是这么一个函数

11:17.910 --> 11:18.910
也就是说我们现在的程序里边

11:18.910 --> 11:20.910
我们需要有这么一个对象

11:20.910 --> 11:22.910
来帮我们来创 有这么一个函数

11:22.910 --> 11:24.910
来帮我们来创建一个对象

11:24.910 --> 11:26.910
可以让我们创建对象的工作

11:26.910 --> 11:28.910
变得更加简单

11:28.910 --> 11:30.910
那么这个对象里边

11:30.910 --> 11:34.910
其实还可以进行简化

11:34.910 --> 11:36.910
还可以进行简化

11:36.910 --> 11:38.910
我们先把对象写成这种格式

11:38.910 --> 11:40.910
先写成这种格式

11:40.910 --> 11:42.910
obj.lastname

11:42.910 --> 11:44.910
obj.lastname

11:44.910 --> 11:46.910
等一下就知道为什么要写成这种格式了

11:46.910 --> 11:48.910
forname.firstname.lastname

11:48.910 --> 11:50.910
好 那么这里就是先来一个空对象

11:50.910 --> 11:52.910
然后我往对象里边加属性

11:52.910 --> 11:54.910
可不可以 当然是一样的 有什么区别呢

11:54.910 --> 11:56.910
是一样的 然后再加一个方法

11:56.910 --> 12:01.290
好 接下来我告诉大家

12:01.290 --> 12:05.290
这个函数还可以简化

12:05.290 --> 12:06.290
怎么简化呢

12:06.290 --> 12:08.290
在解释里边

12:08.290 --> 12:12.290
专门提供了一种写法

12:12.290 --> 12:15.290
可以帮我们更加方便的

12:15.290 --> 12:16.290
来创建对象

12:16.290 --> 12:18.290
还是专门用来创建对象的

12:18.290 --> 12:20.290
那么这种函数叫做

12:20.290 --> 12:24.290
构造函数

12:24.290 --> 12:26.290
构造函数做什么事的

12:26.290 --> 12:27.290
就是来帮我们创建对象的

12:27.290 --> 12:29.290
就是跟这个函数一模一样的功能

12:29.290 --> 12:31.290
有人说不喜欢构造函数

12:31.290 --> 12:32.290
我就喜欢用这种方式

12:32.290 --> 12:33.290
可不可以 可以

12:33.290 --> 12:35.290
没有问题

12:35.290 --> 12:38.290
但是我们开发习惯上

12:38.290 --> 12:41.290
如果说来帮我们创建一个对象的东西

12:41.290 --> 12:45.290
我们通常把它做成一个构造函数

12:45.290 --> 12:49.290
那么怎么把它做成构造函数呢

12:49.290 --> 12:52.600
非常简单

12:52.600 --> 12:55.600
第一步你去掉

12:55.600 --> 12:58.600
去掉这个什么crate的单词

12:58.600 --> 13:00.600
然后你不去掉也可以

13:00.600 --> 13:02.600
只是我们习惯上去掉

13:02.600 --> 13:05.600
直接把这个函数的名字写成你

13:05.600 --> 13:06.600
就是这个对象的名字

13:06.600 --> 13:07.600
对象是一个person

13:07.600 --> 13:08.600
一个人 对吧

13:08.600 --> 13:09.600
我们就写个person

13:09.600 --> 13:12.600
同时手字母大写

13:12.600 --> 13:15.600
这个叫做大妥封命名

13:15.600 --> 13:16.600
就是我们一般的妥封命名法

13:16.600 --> 13:17.600
都是手字母小写 对吧

13:17.600 --> 13:18.600
我们这里手字母大写

13:18.600 --> 13:21.600
把它变成大妥封命名

13:21.600 --> 13:23.600
好 然后里边

13:23.600 --> 13:26.600
第一句话直接可以去掉

13:26.600 --> 13:28.600
它会自动给你加上

13:28.600 --> 13:30.600
你可以省略掉

13:30.600 --> 13:33.600
最后一句return省略掉

13:33.600 --> 13:35.600
中间这个位置

13:35.600 --> 13:38.600
把这个ob界替换成z

13:38.600 --> 13:40.600
就可以了

13:40.600 --> 13:42.600
把ob界的地方替换成z

13:42.600 --> 13:45.600
这里也是z就可以了

13:45.600 --> 13:46.600
那么z是什么呢

13:46.600 --> 13:47.600
z是一个关键字

13:48.600 --> 13:50.600
这个z我们后面

13:50.600 --> 13:51.600
还会单独开一节课来讲

13:51.600 --> 13:53.600
我们这里只需要知道

13:53.600 --> 13:54.600
它在做这么一件事

13:54.600 --> 13:58.300
z表示这个

13:58.300 --> 14:00.300
不是要创建一个人吗

14:00.300 --> 14:01.300
我就给你生成一个人

14:01.300 --> 14:02.300
就是这个人

14:02.300 --> 14:05.300
这个人的first name 等于这个

14:05.300 --> 14:07.300
这个人的last name 等于这个

14:07.300 --> 14:08.300
就把它理解为这个

14:08.300 --> 14:09.300
对吧

14:09.300 --> 14:10.300
在不同的语境下边

14:10.300 --> 14:12.300
那么这个它只带的不一样

14:12.300 --> 14:13.300
那么在这里

14:13.300 --> 14:14.300
你就可以理解成这个代

14:14.300 --> 14:16.300
先把z是复制为空对象

14:16.300 --> 14:18.300
最后你就可以

14:18.300 --> 14:20.300
往这个空对象里面加东西

14:20.300 --> 14:21.300
然后加属性

14:21.300 --> 14:22.300
加方法随便加

14:22.300 --> 14:23.300
加完了过后

14:23.300 --> 14:25.300
它会自动的把z反回

14:25.300 --> 14:27.300
这就是个构造函数

14:27.300 --> 14:29.300
你看这个颜色都变了

14:29.300 --> 14:32.300
这就是个典型的构造函数

14:32.300 --> 14:33.300
能理解吗

14:33.300 --> 14:34.300
好

14:34.300 --> 14:36.300
那么这个构造函数怎么用呢

14:36.300 --> 14:38.300
你就不能直接来调用了

14:38.300 --> 14:40.300
你就不能用这种方式的

14:40.300 --> 14:41.300
构造函数要怎么用

14:41.300 --> 14:44.300
要在前边加上一个new

14:44.300 --> 14:49.060
要是这样的写法

14:49.060 --> 14:51.060
这就是规范

14:51.060 --> 14:52.060
固定了一些法

14:52.060 --> 14:54.060
能不能不加6了可以

14:54.060 --> 14:55.060
你不加6的话

14:55.060 --> 14:57.060
你就没有把它当成构造函数

14:57.060 --> 14:59.060
虽然它自己当成构造函数了

14:59.060 --> 15:02.060
我说我是一个构造函数

15:02.060 --> 15:05.060
结果你还是把它当成普通函数

15:05.060 --> 15:07.060
对不对

15:07.060 --> 15:10.060
那个邓哥说

15:10.060 --> 15:13.060
请教我的全名邓旭明

15:13.060 --> 15:15.060
我们说好的邓哥

15:15.060 --> 15:17.060
叫我全名邓旭明呀

15:17.060 --> 15:18.060
没问题邓哥

15:18.060 --> 15:20.060
他虽然把自己当成构造函数

15:20.060 --> 15:22.060
但是你没有把它当成构造函数来用

15:22.060 --> 15:24.060
那就是普通函数

15:24.060 --> 15:26.060
普通函数那就肯定是要出问题了

15:26.060 --> 15:28.060
所以说他既然自己把它当成构造函数

15:28.060 --> 15:30.060
并且从名字上就告诉你

15:30.060 --> 15:31.060
我的手这么大些

15:31.060 --> 15:33.060
你看着这是个构造函数

15:33.060 --> 15:34.060
你应该怎么用

15:34.060 --> 15:38.060
你应该把用6来调用

15:38.060 --> 15:39.060
懂了意思吧

15:39.060 --> 15:40.060
用6来调用

15:40.060 --> 15:41.060
好

15:41.060 --> 15:42.060
我们来看一下

15:42.060 --> 15:44.060
效果是完全一样的

15:44.060 --> 15:46.060
效果是完全一样的

15:46.060 --> 15:47.060
构造函数怎么理解

15:47.060 --> 15:48.060
一定不复杂

15:48.060 --> 15:49.060
你就把它理解为

15:49.060 --> 15:51.060
你只要通过6来调用函数

15:51.060 --> 15:52.060
那就把它当成构造函数了

15:52.060 --> 15:54.060
那构造函数的第一句话就是这个

15:54.060 --> 15:55.060
最后一句话就是这个

15:55.060 --> 15:57.060
那中间你随便写上

15:57.060 --> 15:59.060
反正给你提供了一个对象叫这次

15:59.060 --> 16:01.060
这个这次就可以随便加东西

16:01.060 --> 16:03.060
加完了过后自动返回

16:03.060 --> 16:04.060
就完了

16:04.060 --> 16:06.060
这就是构造函数

16:06.060 --> 16:07.060
复杂吗

16:07.060 --> 16:08.060
不复杂吧

16:08.060 --> 16:10.060
这复杂在哪了

16:10.060 --> 16:11.060
对不对

16:11.060 --> 16:12.060
我不喜欢构造函数

16:12.060 --> 16:13.060
我就喜欢之前的那种方式

16:13.060 --> 16:14.060
那你就写一遍

16:14.060 --> 16:15.060
但是我们这里讲

16:15.060 --> 16:16.060
肯定要把构造函数讲到

16:17.060 --> 16:19.060
之后我们在开发过程中

16:19.060 --> 16:20.060
创建什么对象呢

16:20.060 --> 16:22.060
我们都尽量使用构造函数来创建

16:23.060 --> 16:25.060
好 那么有了构造函数过后

16:25.060 --> 16:27.060
我要给大家说一个

16:27.060 --> 16:30.060
特别特别重要的一个现象

16:30.060 --> 16:32.060
这个现象听好了

16:32.060 --> 16:34.060
做文的 符号做文

16:34.060 --> 16:35.060
叫什么呢

16:35.060 --> 16:36.060
介石

16:37.060 --> 16:38.060
构造函数用来做什么的

16:38.060 --> 16:39.060
是不是创建对象的

16:39.060 --> 16:41.060
专门用来创建对象的

16:42.060 --> 16:44.060
那么介石

16:44.060 --> 16:45.060
所有的对象

16:46.060 --> 16:47.060
是所有的

16:48.060 --> 16:50.060
都是通过

16:50.060 --> 16:52.060
构造函数产生的

16:54.060 --> 16:55.060
符号做文啊

16:56.060 --> 16:57.060
吓到没

16:57.060 --> 16:58.060
有没有被吓到

16:58.060 --> 17:00.060
介石里面所有的对象

17:00.060 --> 17:02.060
都是通过构造函数产生的

17:02.060 --> 17:03.060
没有例外

17:04.060 --> 17:06.060
那我们来验证一下吧

17:06.060 --> 17:08.060
我们刚才那个Person

17:08.060 --> 17:09.060
这个玩意是不是对象

17:09.060 --> 17:10.060
是对象吗

17:10.060 --> 17:12.060
它是不是通过构造函数产生的

17:13.060 --> 17:14.060
是吗

17:14.060 --> 17:16.060
是不是通过构造函数产生的

17:17.060 --> 17:18.060
有东西刚才说了

17:18.060 --> 17:19.060
哪里这个肯定不对

17:19.060 --> 17:20.060
然后你告诉我

17:20.060 --> 17:22.060
我这个对象

17:22.060 --> 17:24.060
是通过构造函数产生的吗

17:24.060 --> 17:25.060
这是不是对象

17:25.060 --> 17:26.060
OBG是不是对象

17:26.060 --> 17:27.060
是啊

17:27.060 --> 17:28.060
它是通过构造函数产生的吗

17:28.060 --> 17:29.060
是

17:30.060 --> 17:31.060
为什么说是呢

17:32.060 --> 17:33.060
因为你这个代码呀

17:33.060 --> 17:36.060
叫做愚法堂

17:36.060 --> 17:37.060
什么叫愚法堂

17:37.060 --> 17:38.060
给你一颗糖果

17:38.060 --> 17:39.060
让你舒服一点

17:39.060 --> 17:40.060
本质商的

17:40.060 --> 17:41.060
没有营养

17:42.060 --> 17:43.060
那么一个愚法堂

17:43.060 --> 17:45.060
它本质商是啥东西呢

17:45.060 --> 17:46.060
就这个代码

17:46.060 --> 17:47.060
这个代码本质商是

17:47.060 --> 17:48.060
这下边有个代码

17:49.060 --> 17:50.060
OBG

17:50.060 --> 17:51.060
6一个Objects

17:52.060 --> 17:54.060
创建一个空对象

17:55.060 --> 17:57.500
空对象

17:57.500 --> 17:58.500
这个玩意是不是构造函数

17:58.500 --> 17:59.500
你看

17:59.500 --> 18:00.500
你用6的雕像是不是构造函数

18:00.500 --> 18:01.500
它就是构造函数

18:01.500 --> 18:02.500
只不过它里边是

18:02.500 --> 18:03.500
没有参数

18:03.500 --> 18:04.500
没有参数

18:04.500 --> 18:05.500
可以创建一个空对象

18:05.500 --> 18:06.500
然后呢

18:07.500 --> 18:09.500
变成了A等于1

18:09.500 --> 18:10.500
OBG B等于2

18:10.500 --> 18:12.500
OBG B等于2

18:12.500 --> 18:14.500
这个代码就来做这个事

18:14.500 --> 18:16.500
说你写的时候是这个代码

18:17.500 --> 18:18.500
实际上它是这个代码

18:19.500 --> 18:20.500
知道吧

18:20.500 --> 18:21.500
它是一个

18:21.500 --> 18:23.500
通过构造函数创建的对象

18:23.500 --> 18:24.500
解释清楚了吧

18:24.500 --> 18:25.500
那么也就说

18:25.500 --> 18:26.500
我们以后看到了

18:26.500 --> 18:27.500
什么

18:27.500 --> 18:29.500
只要看到一个对象的大颅号

18:29.500 --> 18:31.500
它一定是新

18:31.500 --> 18:32.500
六什么意思

18:32.500 --> 18:33.500
新来一个对象

18:33.500 --> 18:34.500
来一个新的对象

18:35.500 --> 18:37.500
新创建的一个对象

18:37.500 --> 18:38.500
好比说这边

18:38.500 --> 18:39.500
新创建的一个人

18:39.500 --> 18:40.500
新创建的一个人

18:41.500 --> 18:42.500
怎么这个OBG

18:42.500 --> 18:43.500
这个程度是给你写好的

18:43.500 --> 18:44.500
我们来看一下

18:44.500 --> 18:45.500
OBG

18:45.500 --> 18:46.500
你看是不是这样子

18:46.500 --> 18:47.500
A等于B等于2

18:49.500 --> 18:50.500
好一方面说

18:50.500 --> 18:51.500
那不对

18:51.500 --> 18:52.500
你不是说

18:52.500 --> 18:54.500
那个数组也是对象吗

18:55.500 --> 18:56.500
数组这个对象

18:56.500 --> 18:57.500
你怎么解释呢

18:58.500 --> 18:59.500
1

18:59.500 --> 19:00.500
2

19:00.500 --> 19:01.500
3

19:01.500 --> 19:02.500
4

19:02.500 --> 19:03.500
那你怎么解释这个

19:03.500 --> 19:04.500
这个也是

19:04.500 --> 19:05.500
数组也是对象

19:05.500 --> 19:06.500
它没有用6

19:06.500 --> 19:08.500
这也是愚法堂

19:08.500 --> 19:09.500
它的本质是这样子的

19:09.500 --> 19:10.500
6

19:10.500 --> 19:11.500
1

19:12.500 --> 19:14.500
创建一个数组

19:16.500 --> 19:17.500
其实这里面

19:17.500 --> 19:18.500
可以直接写数组

19:18.500 --> 19:19.500
每一项了

19:19.500 --> 19:20.500
123

19:21.500 --> 19:22.500
我看一下

19:22.500 --> 19:23.500
是不是可以

19:23.500 --> 19:24.500
对了

19:24.500 --> 19:25.500
可以写123

19:25.500 --> 19:26.500
好我们来看一下

19:26.500 --> 19:27.500
AR

19:28.500 --> 19:29.500
123

19:29.500 --> 19:30.500
那么就告诉

19:30.500 --> 19:31.500
创建一个数组

19:31.500 --> 19:32.500
它有参数

19:32.500 --> 19:33.500
它可以写

19:33.500 --> 19:34.500
数组每一项的

19:34.500 --> 19:35.500
第一项为1

19:35.500 --> 19:36.500
第二项为2

19:36.500 --> 19:37.500
第二三

19:37.500 --> 19:38.500
以这种写法

19:38.500 --> 19:39.500
等同于这种写法

19:40.500 --> 19:41.500
懂的意思吧

19:41.500 --> 19:42.500
说一说

19:42.500 --> 19:43.500
再来看这句话

19:45.500 --> 19:47.500
所有的对象

19:47.500 --> 19:48.500
都是通过

19:48.500 --> 19:50.500
勾造寒树产生的

19:50.500 --> 19:51.500
勾造寒树

19:51.500 --> 19:52.500
专门来做这个事

19:52.500 --> 19:53.500
专门来创建对象的

19:53.500 --> 19:54.500
因此介绍里面

19:54.500 --> 19:55.500
全部都是

19:55.500 --> 19:56.500
通过勾造寒树产生的

19:57.500 --> 19:58.500
还有一问吗

19:59.500 --> 20:00.500
如果说你前边

20:00.500 --> 20:02.500
听得特别特别认真

20:02.500 --> 20:04.500
笔记做得特别特别好

20:04.500 --> 20:06.500
应该有很少一部分同学

20:06.500 --> 20:08.500
首先给这部分同学点个赞

20:10.500 --> 20:11.500
当然你没有注意到

20:11.500 --> 20:12.500
也没有关系

20:12.500 --> 20:13.500
听我讲

20:13.500 --> 20:14.500
如果说你听得特别好

20:14.500 --> 20:16.500
你可能还有一个疑问

20:16.500 --> 20:18.500
原来是之前不是说

20:18.500 --> 20:20.500
咱们介石里面有两种类型

20:20.500 --> 20:21.500
一种叫原始类型

20:21.500 --> 20:22.500
什么支付串

20:22.500 --> 20:23.500
普利

20:23.500 --> 20:24.500
数字

20:24.500 --> 20:25.500
叫原始类型

20:25.500 --> 20:26.500
还有一种类型

20:26.500 --> 20:27.500
叫对象类型

20:28.500 --> 20:29.500
原始当初还说

20:29.500 --> 20:30.500
对象类型里边

20:30.500 --> 20:31.500
分为普通对象

20:31.500 --> 20:33.810
普通对象

20:34.810 --> 20:35.810
然后呢

20:35.810 --> 20:36.810
数主

20:37.810 --> 20:38.810
还有什么

20:38.810 --> 20:39.810
还有寒树

20:39.810 --> 20:40.810
说寒树本身

20:40.810 --> 20:41.810
它也是一个对象

20:43.810 --> 20:44.810
那这种怎么解释呢

20:45.810 --> 20:46.810
你这么解释

20:46.810 --> 20:47.810
不要问我这一个寒树

20:51.950 --> 20:53.950
或者就直接定一个寒树

20:53.950 --> 20:54.950
M吧

20:54.950 --> 20:55.950
那你怎么解释这个

20:56.950 --> 20:57.950
寒树也是对象

20:57.950 --> 20:58.950
这个玩意也是个对象

20:59.950 --> 21:00.950
那这个对象

21:01.950 --> 21:02.950
它是

21:03.950 --> 21:04.950
怎么来理解呢

21:04.950 --> 21:05.950
它怎么来弄6来创建的

21:05.950 --> 21:07.950
它也是用6来创建的

21:08.950 --> 21:09.950
比方说我们这里求一个

21:09.950 --> 21:10.950
一个核求和暗树

21:11.950 --> 21:12.950
A B

21:12.950 --> 21:13.950
对吧

21:13.950 --> 21:14.950
A加B

21:16.950 --> 21:17.950
寒树本身也是对象的

21:18.950 --> 21:19.950
这个我们后边还会说

21:21.950 --> 21:22.950
现在我们先简单了解一下

21:22.950 --> 21:23.950
你知道这个寒树

21:23.950 --> 21:24.950
它本身也是用6来创建的

21:25.950 --> 21:26.950
我们来看一下这个寒树

21:26.950 --> 21:27.950
这个寒树没什么好说的

21:28.950 --> 21:29.950
12

21:29.950 --> 21:30.950
它肯定输出3

21:30.950 --> 21:31.950
好

21:31.950 --> 21:32.950
那我们现在用6的方式

21:32.950 --> 21:33.950
来创建一个寒树

21:33.950 --> 21:34.950
只不过我们这种邪法

21:34.950 --> 21:35.950
太反人类了

21:35.950 --> 21:36.950
我们平时不写

21:36.950 --> 21:38.950
但实际上就是通过

21:38.950 --> 21:39.950
这种方式来创建

21:43.800 --> 21:44.800
6一个方式

21:44.800 --> 21:45.800
寒树是通过

21:45.800 --> 21:46.800
这个构造寒树创建的

21:48.800 --> 21:50.800
通过它来创建一个寒树

21:51.800 --> 21:52.800
第一个参数

21:52.800 --> 21:54.800
就是寒树的参数1

21:54.800 --> 21:55.800
寒树的参数2

21:56.800 --> 21:57.800
寒树的寒树体是A

21:57.800 --> 21:58.800
Return A加D

21:59.800 --> 22:02.500
看没

22:02.500 --> 22:03.500
这个上

22:03.500 --> 22:04.500
是不是还是一个寒树

22:05.500 --> 22:06.500
还是可以输出3

22:07.500 --> 22:08.500
任何东西

22:08.500 --> 22:09.500
只要是对象

22:09.500 --> 22:11.500
它一定是通过6来创建的

22:11.500 --> 22:12.500
只不过寒树这一块

22:12.500 --> 22:13.500
我们后面还会详细说

22:14.500 --> 22:15.500
了解一下

22:15.500 --> 22:16.500
只不过这种邪法

22:16.500 --> 22:17.500
太反人类了

22:17.500 --> 22:19.500
通常都用这种邪法

22:20.500 --> 22:21.500
懂了意思吧

22:21.500 --> 22:22.500
这一点给大家提到

22:23.500 --> 22:24.500
好了那么接下来

22:24.500 --> 22:25.500
我们来做一个练习题

22:25.500 --> 22:26.500
练习题

22:26.500 --> 22:27.500
今天的练习题

22:27.500 --> 22:29.500
同学们先不要自己做

22:29.500 --> 22:30.500
你自己没法做

22:30.500 --> 22:31.500
听老师讲

22:31.500 --> 22:32.500
讲完了过后

22:32.500 --> 22:33.500
自己跟着老师做出来

22:34.500 --> 22:35.500
利用构造寒树

22:35.500 --> 22:36.500
创建一副破牌

22:37.500 --> 22:40.940
好那么这里的边

22:40.940 --> 22:41.940
其实我可以把它分为

22:41.940 --> 22:42.940
两个对象

22:42.940 --> 22:43.940
这里边有两个对象

22:43.940 --> 22:44.940
一个叫做Dec

22:46.940 --> 22:47.940
Dec什么意思

22:47.940 --> 22:49.940
叫做一副破刻牌

22:50.940 --> 22:51.940
一副破刻牌

22:53.940 --> 22:54.940
这副字写错了是吧

22:57.310 --> 22:58.310
好还有一个poker

23:00.310 --> 23:01.310
这个表示什么意思呢

23:01.310 --> 23:03.310
表示一张破刻牌

23:04.310 --> 23:06.690
一张破刻牌

23:06.690 --> 23:07.690
它也是对象

23:07.690 --> 23:08.690
为什么破刻牌有点数

23:08.690 --> 23:09.690
有花色

23:10.690 --> 23:11.690
对不对

23:11.690 --> 23:12.690
这是一张破刻牌

23:13.690 --> 23:14.690
还有一副破刻牌里边

23:14.690 --> 23:15.690
是不是包含很多张

23:15.690 --> 23:16.690
对吧

23:16.690 --> 23:17.690
我们先来一个个写

23:17.690 --> 23:19.690
先来写一张破刻牌

23:20.690 --> 23:21.690
那么这个题的需求

23:21.690 --> 23:22.690
我没有详细的说

23:22.690 --> 23:23.690
因为要说的话

23:23.690 --> 23:24.690
说一大段

23:24.690 --> 23:25.690
难得看

23:25.690 --> 23:26.690
跟着老师写就行了

23:26.690 --> 23:28.690
我们先来写一个构造寒树

23:28.690 --> 23:30.690
来帮我们创建一张破刻牌

23:30.690 --> 23:31.690
我们怎么写呢

23:31.690 --> 23:32.690
方形

23:32.690 --> 23:33.690
poker

23:34.690 --> 23:35.690
破刻牌

23:35.690 --> 23:36.690
破刻牌里边

23:36.690 --> 23:37.690
我们

23:37.690 --> 23:38.690
因为破刻牌

23:38.690 --> 23:39.690
我要知道哪些信息

23:39.690 --> 23:41.690
要告诉我点数

23:41.690 --> 23:42.690
对吧

23:43.690 --> 23:44.690
number

23:44.690 --> 23:45.690
点数

23:45.690 --> 23:47.690
还要告诉我什么花色

23:47.690 --> 23:48.690
卡通

23:48.690 --> 23:49.690
那我规定一下吧

23:49.690 --> 23:50.690
你怎么来传给我呢

23:51.690 --> 23:52.690
这是

23:52.690 --> 23:53.690
创建

23:54.690 --> 23:55.690
一张

23:55.690 --> 23:56.690
破刻牌

23:56.690 --> 23:59.060
好 这是点数

23:59.060 --> 24:01.060
点数你给我一个数字就行了

24:01.060 --> 24:03.060
那么就是一

24:03.060 --> 24:04.060
就是一

24:04.060 --> 24:05.060
然后呢

24:05.060 --> 24:06.060
一是内推

24:06.060 --> 24:07.060
二就是二

24:07.060 --> 24:08.060
三就是三

24:08.060 --> 24:09.060
十一

24:09.060 --> 24:10.060
十一

24:10.060 --> 24:11.060
表示什么勾

24:12.060 --> 24:13.060
然后十二呢

24:13.060 --> 24:14.060
表示

24:15.060 --> 24:16.060
圈

24:16.060 --> 24:17.060
然后十三呢

24:17.060 --> 24:18.060
表示k

24:18.060 --> 24:19.060
十四呢

24:19.060 --> 24:21.060
表示小王

24:22.060 --> 24:23.060
十五呢

24:23.060 --> 24:24.060
表示大王

24:25.060 --> 24:27.440
没问题吧

24:27.440 --> 24:28.440
好

24:28.440 --> 24:29.440
那么卡呢

24:29.440 --> 24:30.440
也是一个数字

24:31.440 --> 24:32.440
花色也是一个数字

24:32.440 --> 24:33.440
花色的数字呢

24:33.440 --> 24:34.440
一表示

24:35.440 --> 24:36.440
黑桃

24:36.440 --> 24:38.440
二表示红桃

24:39.440 --> 24:40.440
红桃

24:41.440 --> 24:43.440
三表示梅花

24:48.070 --> 24:50.070
四表示方片

24:52.830 --> 24:54.830
好 你可以把这两个属性给我

24:54.830 --> 24:55.830
于是我这里要做的事情

24:55.830 --> 24:56.830
是不是就是跟刚才一样

24:56.830 --> 24:57.830
riss

24:57.830 --> 24:58.830
因为帮你创建好的一个新对象了

24:58.830 --> 24:59.830
对吧

24:59.830 --> 25:00.830
放到riss里面

25:00.830 --> 25:01.830
你往riss里面加属性就行了

25:01.830 --> 25:02.830
number

25:02.830 --> 25:03.830
等于

25:03.830 --> 25:04.830
number

25:04.830 --> 25:05.830
然后riss color

25:05.830 --> 25:06.830
等于color

25:07.830 --> 25:10.140
好

25:10.140 --> 25:11.140
然后我们来

25:11.140 --> 25:12.140
试着创建一下

25:12.140 --> 25:13.140
我们来一个

25:13.140 --> 25:14.140
pe

25:14.140 --> 25:15.140
来创建一个颇颇牌

25:15.140 --> 25:16.140
leupoker

25:16.140 --> 25:17.140
e

25:17.140 --> 25:18.140
e

25:18.140 --> 25:19.140
那应该就是黑桃间

25:19.140 --> 25:20.140
对吧

25:20.140 --> 25:21.140
我们来输出一下

25:21.140 --> 25:22.140
pe

25:22.140 --> 25:24.710
是吧

25:24.710 --> 25:25.710
number等于1

25:25.710 --> 25:26.710
color等于1

25:26.710 --> 25:27.710
所以产生这么个对象

25:27.710 --> 25:28.710
好 这个对象里边呢

25:28.710 --> 25:29.710
我们还想

25:29.710 --> 25:31.710
到时候打印这个颇颇牌的时候

25:31.710 --> 25:32.710
用这种方式打印

25:32.710 --> 25:33.710
有点

25:33.710 --> 25:34.710
不直观

25:34.710 --> 25:35.710
对吧

25:35.710 --> 25:36.710
我们注意好了

25:36.710 --> 25:37.710
换一种方式打印

25:37.710 --> 25:38.710
比方说我要方片

25:38.710 --> 25:39.710
黑桃

25:39.710 --> 25:40.710
黑桃1

25:40.710 --> 25:41.710
那我就想把它打印成这个样子

25:42.710 --> 25:43.710
黑

25:44.710 --> 25:45.710
黑桃

25:45.710 --> 25:48.150
1

25:48.150 --> 25:50.150
1就是间对不对

25:50.150 --> 25:51.150
对吧

25:51.150 --> 25:52.150
我想把它打印成这个样子

25:52.150 --> 25:53.150
就更好一点

25:53.150 --> 25:55.150
因此我在这个颇颇牌里边

25:55.150 --> 25:56.150
加一个函数

25:56.150 --> 25:57.150
加一个方法

25:57.150 --> 25:58.150
叫做print

25:58.150 --> 25:59.150
打印

26:00.150 --> 26:01.150
打印的时候

26:01.150 --> 26:02.150
我怎么打印呢

26:02.150 --> 26:04.150
我想把它打印成为

26:04.150 --> 26:05.150
刚才那个样子

26:05.150 --> 26:06.150
刚才那个样子

26:06.150 --> 26:07.150
是不是有两个部分组成

26:08.150 --> 26:09.150
对吧

26:09.150 --> 26:10.150
看一下

26:11.150 --> 26:12.150
是不是两个部分组成

26:12.150 --> 26:14.150
一个部分是花色

26:14.150 --> 26:16.150
一个部分是点数

26:16.150 --> 26:17.150
对吧

26:17.150 --> 26:18.150
先把花色确定

26:18.150 --> 26:20.150
然后再打印点数

26:20.150 --> 26:22.150
这里有个小的说明

26:22.150 --> 26:24.150
小王和大王是不确定

26:24.150 --> 26:26.150
是不需要花色的

26:26.150 --> 26:28.150
我这里先排除小王大王

26:28.150 --> 26:29.150
好

26:29.150 --> 26:31.150
如果说Race Color

26:32.150 --> 26:34.150
就是那个

26:34.150 --> 26:35.150
不是Color

26:35.150 --> 26:36.150
Number

26:37.150 --> 26:38.150
是不是这个

26:38.150 --> 26:40.150
这个数字等于

26:41.150 --> 26:42.150
14

26:42.150 --> 26:43.150
我打印什么呢

26:43.150 --> 26:44.150
我就打印

26:45.150 --> 26:46.150
小王

26:46.150 --> 26:49.850
打印两个字就行了

26:49.850 --> 26:50.850
小王

26:50.850 --> 26:52.850
或者是打印一个英文

26:53.850 --> 26:54.850
打印完了过后

26:54.850 --> 26:55.850
我其实这里

26:55.850 --> 26:56.850
我就可以结束了

26:56.850 --> 26:57.850
因为小王只有这种情况

26:57.850 --> 26:58.850
对吧

26:58.850 --> 26:59.850
没有其他情况了

26:59.850 --> 27:00.850
打印这个

27:00.850 --> 27:01.850
小王打印完就结束了

27:01.850 --> 27:02.850
Rator

27:02.850 --> 27:03.850
我们在海水边

27:03.850 --> 27:04.850
经常会这样的写

27:04.850 --> 27:05.850
就是我就难得

27:05.850 --> 27:06.850
去用EF

27:06.850 --> 27:07.850
L是EF

27:07.850 --> 27:08.850
后面我们可以直接写

27:08.850 --> 27:09.850
EF

27:09.850 --> 27:10.850
对吧

27:10.850 --> 27:11.850
这个是Number

27:11.850 --> 27:12.850
等于

27:12.850 --> 27:13.850
15

27:13.850 --> 27:14.850
好

27:14.850 --> 27:15.850
同学们

27:15.850 --> 27:16.850
如果说这个代码

27:16.850 --> 27:17.850
控制不住了

27:17.850 --> 27:18.850
你就赶快跟着写一下

27:18.850 --> 27:19.850
你不要等我写完了

27:19.850 --> 27:20.850
你再写

27:20.850 --> 27:21.850
赶快

27:21.850 --> 27:22.850
有点晕了

27:22.850 --> 27:23.850
或者控制不住的时候

27:23.850 --> 27:24.850
就跟着写

27:27.220 --> 27:28.220
好

27:28.220 --> 27:29.220
你看

27:29.220 --> 27:30.220
14的时候打印小王

27:30.220 --> 27:31.220
然后15的时候

27:31.220 --> 27:32.220
打印大王

27:32.220 --> 27:33.220
打印完了就结束了

27:33.220 --> 27:34.220
不就是打印吗

27:34.220 --> 27:35.220
打印完就结束了

27:35.220 --> 27:37.220
这是小王和大王的情况

27:37.220 --> 27:38.220
这样的写法的好处

27:38.220 --> 27:39.220
在于

27:39.220 --> 27:40.220
如果说你不写Rator

27:40.220 --> 27:41.220
只不想可以

27:41.220 --> 27:42.220
写到前面的衣服

27:42.220 --> 27:44.220
然后这里要包到L时里面

27:44.220 --> 27:46.220
如果说你写的Rator

27:46.220 --> 27:47.220
反正这个函数

27:47.220 --> 27:48.220
到了下边

27:48.220 --> 27:49.220
如果他进到前面的衣服

27:49.220 --> 27:50.220
肯定就结束了

27:50.220 --> 27:51.220
对吧

27:51.220 --> 27:52.220
后面就不会运行了

27:52.220 --> 27:53.220
所以后面我们可以

27:53.220 --> 27:54.220
少写个L时

27:54.220 --> 27:55.220
然后这里

27:55.220 --> 27:56.220
我们也不用再写L时了

27:56.220 --> 27:57.220
我们就直接往后面写

27:57.220 --> 27:58.220
对吧

27:58.220 --> 27:59.220
其他情况

27:59.220 --> 28:00.220
直接在这里写

28:00.220 --> 28:01.220
因为前面进去了

28:01.220 --> 28:02.220
就已经结束了

28:02.220 --> 28:03.220
都在函数里面

28:03.220 --> 28:04.220
有这么一个好处

28:04.220 --> 28:05.220
Rator后面

28:05.220 --> 28:06.220
可以不跟东西

28:06.220 --> 28:07.220
可以不写东西的

28:07.220 --> 28:08.220
不是说一定要写个东西

28:08.220 --> 28:09.220
不写东西

28:09.220 --> 28:10.220
就相当于是写到

28:10.220 --> 28:11.220
因为我这个函数

28:11.220 --> 28:12.220
是不需要返回的

28:12.220 --> 28:14.220
我打印完就结束了

28:14.220 --> 28:15.220
我们看其他情况

28:15.220 --> 28:18.220
就不是小王也不是大王

28:18.220 --> 28:20.220
不是小王也不是大王

28:20.220 --> 28:21.220
那么就正常的数字了

28:21.220 --> 28:22.220
正常数字

28:22.220 --> 28:24.220
我们先打印花色

28:24.220 --> 28:25.220
对吧

28:25.220 --> 28:26.220
先打印花色

28:26.220 --> 28:27.220
好

28:27.220 --> 28:28.220
我们来写个Color

28:28.220 --> 28:29.220
一个字不错

28:29.220 --> 28:31.220
那么这个花色到底是啥呢

28:31.220 --> 28:33.220
是不是我要判断

28:33.220 --> 28:36.220
如果说你这个

28:36.220 --> 28:38.220
你这个什么呢

28:38.220 --> 28:39.220
Z

28:39.220 --> 28:40.220
Color

28:40.220 --> 28:41.220
这是属性的Color

28:41.220 --> 28:42.220
这是变量

28:42.220 --> 28:43.220
这是属性

28:43.220 --> 28:45.220
不重出的

28:45.220 --> 28:47.220
这个Color等于1

28:47.220 --> 28:48.220
我怎么样呢

28:48.220 --> 28:49.220
我就把这个Color

28:49.220 --> 28:51.220
复制为黑桃

28:51.220 --> 28:53.730
是吧

28:53.730 --> 28:54.730
LCF

28:54.730 --> 28:57.730
Z是Color等于2

28:57.730 --> 28:59.730
是不是我就把这个Color

28:59.730 --> 29:01.730
复制为红桃

29:02.730 --> 29:03.730
LCF

29:03.730 --> 29:06.730
这个Color等于3

29:06.730 --> 29:08.730
我就把这个Color

29:08.730 --> 29:11.730
复制为梅花

29:11.730 --> 29:12.730
其他情况

29:12.730 --> 29:13.730
我就把Color

29:13.730 --> 29:15.730
复制为红桃

29:15.730 --> 29:18.870
是不是可以这样子

29:18.870 --> 29:19.870
那么这样子

29:19.870 --> 29:20.870
这个变量里面

29:20.870 --> 29:21.870
是不是保存了

29:21.870 --> 29:22.870
我们要打印的

29:22.870 --> 29:23.870
花色

29:23.870 --> 29:24.870
我们来输出一下

29:24.870 --> 29:26.870
输出一下Color

29:26.870 --> 29:28.870
接下来我们现在

29:28.870 --> 29:30.870
现在我们来看一下Print

29:30.870 --> 29:32.870
第二用PE的Print

29:32.870 --> 29:35.870
看看能不能把花色打印出来了

29:35.870 --> 29:37.870
是不是黑桃就打印出来了

29:37.870 --> 29:38.870
看没

29:38.870 --> 29:39.870
黑桃就打印出来了

29:39.870 --> 29:41.870
而且就是经过了这么一套流程

29:41.870 --> 29:42.870
就把黑桃打印出来了

29:42.870 --> 29:44.870
但这个代码其实有点优种

29:44.870 --> 29:46.870
这代码其实还有

29:46.870 --> 29:47.870
还可以减化

29:47.870 --> 29:48.870
怎么减化呢

29:48.870 --> 29:50.870
这需要一些技巧了

29:51.870 --> 29:52.870
怎么减化

29:52.870 --> 29:53.870
我可以这样子写

29:53.870 --> 29:55.870
我定义一个数组

29:55.870 --> 29:56.870
Color

29:56.870 --> 29:58.870
一个数组

29:58.870 --> 30:02.440
数组里面

30:02.440 --> 30:03.440
黑桃

30:03.440 --> 30:04.440
放过来

30:05.440 --> 30:06.440
黑桃

30:07.440 --> 30:08.440
直接写吧

30:09.440 --> 30:10.440
红

30:10.440 --> 30:11.440
红桃

30:12.440 --> 30:15.070
美花

30:18.580 --> 30:19.580
方片

30:22.340 --> 30:23.340
那你想一想

30:23.340 --> 30:24.340
如果说有这么一个数组之后

30:24.340 --> 30:26.340
你想一想的道理

30:27.340 --> 30:30.340
如果说我这个数相等于1

30:30.340 --> 30:32.340
我是不是取数组的第一项

30:32.340 --> 30:33.340
数性等于2

30:33.340 --> 30:35.340
我是不是取数组的第二项

30:35.340 --> 30:36.340
数性等于3

30:36.340 --> 30:38.340
我是不是取数组的第三项

30:39.340 --> 30:40.340
是吧

30:40.340 --> 30:41.340
数数等于4

30:41.340 --> 30:42.340
我是不是取数组的第四项

30:43.340 --> 30:44.340
也就是咋的

30:44.340 --> 30:46.340
咋的更直观的总结

30:47.340 --> 30:49.340
就是Z是Color

30:49.340 --> 30:50.340
然后第几

30:50.340 --> 30:52.340
后边取数组的哪个下标

30:53.340 --> 30:55.340
这个等于1取数组的哪个下标

30:55.340 --> 30:56.340
是不是取0

30:56.340 --> 30:58.340
等于2是不是取1

30:58.340 --> 31:00.340
等于3是不是取2

31:00.340 --> 31:01.340
后边还有写吗

31:01.340 --> 31:04.350
不写了吧

31:04.350 --> 31:06.350
那我这个地方该取哪一个

31:06.350 --> 31:09.350
是不是这个数组的哪一项

31:09.350 --> 31:10.350
哪一项

31:10.350 --> 31:12.350
Z是Color写1

31:12.350 --> 31:14.350
是不是可以了

31:14.350 --> 31:15.350
就这个表达是吧

31:16.350 --> 31:18.350
它为1那就简易就等于0

31:18.350 --> 31:19.350
它为2简易的等于1

31:19.350 --> 31:20.350
是吧

31:20.350 --> 31:21.350
把这个当成下标去取

31:21.350 --> 31:22.350
取出来不就是花色吗

31:23.350 --> 31:25.350
这样代表是不是看上更加简洁

31:26.350 --> 31:27.350
这些小技巧

31:29.350 --> 31:30.350
好那么现在花色就取出来了

31:30.350 --> 31:31.350
对吧

31:31.350 --> 31:32.350
这是花色

31:33.350 --> 31:35.350
得到花色

31:35.350 --> 31:36.350
花色在哪

31:36.350 --> 31:37.350
在卡到里边一会要用

31:37.350 --> 31:39.350
那么现在还除了花色之外

31:39.350 --> 31:40.350
是不是还有什么

31:40.350 --> 31:41.350
还有那个

31:42.350 --> 31:43.350
这个

31:43.350 --> 31:45.350
这个叫它点数对吧

31:45.350 --> 31:47.350
点数是不是也可以

31:47.350 --> 31:49.350
也用这种方式来写

31:49.350 --> 31:51.350
Numbers

31:51.350 --> 31:53.350
Numbers是哪些呢

31:53.350 --> 31:55.350
A就是肩

31:55.350 --> 31:56.350
2

31:56.350 --> 31:57.350
3

31:57.350 --> 31:58.350
4

31:58.350 --> 31:59.350
5

31:59.350 --> 32:01.350
6

32:01.350 --> 32:03.350
7

32:03.350 --> 32:05.350
8

32:05.350 --> 32:07.350
9

32:07.350 --> 32:11.110
10

32:11.110 --> 32:13.110
然后是

32:13.110 --> 32:14.110
勾

32:14.110 --> 32:15.110
圈

32:17.110 --> 32:18.110
这点数

32:18.110 --> 32:20.110
这点数除了大王小王之外

32:20.110 --> 32:21.110
就点数

32:21.110 --> 32:22.110
大王小王我们已经处理的

32:22.110 --> 32:24.110
就在这你处理的

32:24.110 --> 32:26.110
好那么我取哪个点数呢

32:26.110 --> 32:27.110
是不是一样的

32:27.110 --> 32:29.110
去点数Numbers

32:29.110 --> 32:30.110
等于它们呢

32:30.110 --> 32:32.110
等于Numbers

32:33.110 --> 32:35.110
Z是Numbers-1

32:35.110 --> 32:36.110
对吧

32:37.110 --> 32:38.110
我1的时候是不是取出了

32:38.110 --> 32:39.110
第0项

32:39.110 --> 32:40.110
我2的时候是不是取出了

32:40.110 --> 32:41.110
第1项

32:41.110 --> 32:42.110
对吧

32:42.110 --> 32:43.110
我2的时候是不是取这个

32:43.110 --> 32:45.110
我2的时候是不是取这个

32:45.110 --> 32:47.110
好点数花色都取出来了

32:47.110 --> 32:48.110
那我们来打印一下

32:48.110 --> 32:49.110
无非就是点

32:49.110 --> 32:53.680
花色拼接点数嘛

32:53.680 --> 32:55.680
是不是就打印出来了

32:55.680 --> 32:57.680
对吧

32:57.680 --> 32:58.680
好

32:58.680 --> 32:59.680
这个你看

32:59.680 --> 33:01.680
如果说没有构造寒数

33:01.680 --> 33:02.680
那我每一张牌

33:02.680 --> 33:03.680
我是不是都要写这个Printer

33:03.680 --> 33:04.680
每一张牌都要写这个Printer

33:04.680 --> 33:06.680
那它写的太麻烦了

33:06.680 --> 33:07.680
那有了这个构造寒数

33:07.680 --> 33:08.680
不管这个构造寒数

33:08.680 --> 33:09.680
底表有多麻烦

33:09.680 --> 33:11.680
但是这个单码我只写一次

33:11.680 --> 33:13.680
再麻烦我只写一次

33:13.680 --> 33:15.680
写完一次之后

33:15.680 --> 33:17.680
那我是不是后面就非常简单的

33:17.680 --> 33:18.680
创建

33:18.680 --> 33:19.680
黑桃

33:19.680 --> 33:20.680
监

33:20.680 --> 33:21.680
再来一个

33:22.680 --> 33:24.680
创建

33:27.680 --> 33:32.400
黑桃2

33:32.400 --> 33:33.400
所以黑桃2

33:33.400 --> 33:34.400
后面是不是就很简单的

33:34.400 --> 33:35.400
对吧

33:35.400 --> 33:36.400
寒数就是这样子

33:36.400 --> 33:38.400
寒数写的时候再复杂无所谓

33:38.400 --> 33:40.400
反正就复杂一次

33:40.400 --> 33:41.400
麻烦一次

33:41.400 --> 33:43.400
写好了过后面就很舒服了

33:43.400 --> 33:44.400
对吧

33:44.400 --> 33:46.400
这就创建了一张普克牌

33:46.400 --> 33:47.400
对吧

33:47.400 --> 33:49.400
只要一六poker传进去

33:49.400 --> 33:50.400
就创建了一个对象了

33:50.400 --> 33:51.400
那么一个对象里边

33:51.400 --> 33:53.400
还带了一个寒数

33:53.400 --> 33:55.400
这个寒数可以调用它

33:55.400 --> 33:56.400
好吧

33:56.400 --> 33:57.400
这一块单码先写出来

33:57.400 --> 33:58.400
先写出来

33:58.400 --> 33:59.400
不要往后听了

33:59.400 --> 34:01.400
接下来我们来搞定

34:01.400 --> 34:02.400
一副普克牌

34:02.400 --> 34:03.400
好

34:03.400 --> 34:04.400
我们这里写个寒数

34:04.400 --> 34:05.400
叫deck

34:05.400 --> 34:06.400
这是一副普克牌

34:06.400 --> 34:07.400
因为我们知道

34:07.400 --> 34:09.400
一副普克牌有哪些

34:09.400 --> 34:11.400
是有很多的张组成的

34:11.400 --> 34:13.400
很多的普克组成的

34:13.400 --> 34:15.400
就是一叠普克牌

34:15.400 --> 34:21.020
一叠普克牌

34:21.020 --> 34:23.020
它是有很多张普克牌组成的

34:23.020 --> 34:24.020
那么到底有多少张

34:24.020 --> 34:26.020
是不是非常明确

34:26.020 --> 34:27.020
有四张黑桃间

34:27.020 --> 34:28.020
有四张间

34:28.020 --> 34:29.020
有四张二

34:29.020 --> 34:30.020
四张三

34:30.020 --> 34:31.020
四张四

34:31.020 --> 34:33.020
有一个好像是五十四张

34:33.020 --> 34:34.020
反正是有很多当组成的

34:34.020 --> 34:35.020
那你需不需要参数

34:35.020 --> 34:36.020
不需要

34:37.020 --> 34:38.020
不需要参数

34:38.020 --> 34:40.020
我在这个构造寒数理标

34:40.020 --> 34:41.020
我就可以把整个普克牌

34:41.020 --> 34:42.020
给你构建好

34:42.020 --> 34:43.020
那我怎么来构建呢

34:44.020 --> 34:47.020
我就是无分往Z

34:47.020 --> 34:48.020
往里边加一个

34:48.020 --> 34:49.020
叫做pocus

34:49.020 --> 34:50.020
对吧

34:50.020 --> 34:51.020
加一个数组

34:51.020 --> 34:52.020
说一个数组

34:53.020 --> 34:55.020
这是个普克牌的数组

34:56.020 --> 34:58.020
如果说这一块代码

34:58.020 --> 34:59.020
搞不清楚

34:59.020 --> 35:01.020
那我们就先来创建

35:01.020 --> 35:02.020
在外边来创建一个普克牌

35:02.020 --> 35:03.020
五十四张普克牌

35:03.020 --> 35:04.020
那怎么来创建呢

35:05.020 --> 35:08.530
我是不是要定一个变量pocus

35:12.890 --> 35:13.890
循环

35:14.890 --> 35:16.890
先来一个点数的循环

35:16.890 --> 35:18.890
从1循环到哪

35:18.890 --> 35:20.890
循环到13

35:21.890 --> 35:22.890
点数的循环

35:23.890 --> 35:25.890
i等于1就是

35:25.890 --> 35:26.890
i等于2就是2

35:26.890 --> 35:27.890
一直到13

35:27.890 --> 35:29.890
小王大王最后来动

35:30.890 --> 35:31.890
好

35:31.890 --> 35:33.890
每一个点数是不是有四张

35:33.890 --> 35:34.890
对吧

35:34.890 --> 35:36.890
每个点数是不是有四张

35:36.890 --> 35:37.890
那我们来创建四张呗

35:37.890 --> 35:39.890
p1等于6一个

35:40.890 --> 35:41.890
6一个啥

35:41.890 --> 35:42.890
pocus

35:42.890 --> 35:43.890
点数是多少

35:43.890 --> 35:45.890
点数也不就是i吗

35:46.890 --> 35:47.890
i等于1的时候走一遍

35:47.890 --> 35:49.890
i等于2的时候走一遍

35:49.890 --> 35:50.890
花色呢

35:50.890 --> 35:52.890
1 2 3 4

35:52.890 --> 35:54.890
2 3 4

35:54.890 --> 35:55.890
对吧

35:55.890 --> 35:56.890
是不是四个花色

35:56.890 --> 36:00.890
p2 p3 p4

36:00.890 --> 36:03.840
这样没问题吧

36:03.840 --> 36:05.840
然后把每一张普克牌

36:05.840 --> 36:06.840
加到这个数组里面去

36:06.840 --> 36:07.840
对吧

36:07.840 --> 36:08.840
我们要在数组里面保存

36:08.840 --> 36:09.840
p1

36:10.840 --> 36:11.840
其实可以连写

36:11.840 --> 36:13.840
p2 p3 p4

36:14.840 --> 36:15.840
或者是你把分开写吧

36:15.840 --> 36:17.840
创建一张加一张也行

36:17.840 --> 36:19.840
pocus p1

36:20.840 --> 36:21.840
然后呢

36:22.840 --> 36:31.300
这是p2

36:32.300 --> 36:34.300
p3 p4

36:34.300 --> 36:36.300
创建一张加一张

36:36.300 --> 36:37.300
创建一张加一张

36:38.300 --> 36:39.300
没问题吧

36:39.300 --> 36:40.300
那这样子循环结束之后

36:40.300 --> 36:41.300
你看这个pocus数组里面

36:41.300 --> 36:43.300
是不是有很多张普克牌了

36:43.300 --> 36:45.300
第一个是个pocus

36:45.300 --> 36:46.300
对吧

36:46.300 --> 36:47.300
还有一个属性Number

36:47.300 --> 36:48.300
一个属性Color

36:48.300 --> 36:49.300
一个Print

36:49.300 --> 36:50.300
第二个也是个

36:51.300 --> 36:52.300
对象

36:52.300 --> 36:54.300
每个普克牌就是对象

36:54.300 --> 36:56.670
对不对

36:56.670 --> 36:57.670
没问题吧

36:57.670 --> 36:58.670
但是这样子写你不觉得

36:58.670 --> 36:59.670
太恶心了吗

36:59.670 --> 37:00.670
太凡说了吗

37:00.670 --> 37:01.670
你看这个地方

37:01.670 --> 37:02.670
是不是也在重复啊

37:02.670 --> 37:03.670
创建一个花色

37:03.670 --> 37:06.670
创建数字为i

37:06.670 --> 37:07.670
花色为1

37:07.670 --> 37:08.670
创建数字为i

37:08.670 --> 37:09.670
花色为2

37:09.670 --> 37:10.670
数字为3

37:10.670 --> 37:11.670
花色为3

37:11.670 --> 37:12.670
花色为4

37:12.670 --> 37:13.670
那里面我再写个循环

37:13.670 --> 37:14.670
不就完了吗

37:14.670 --> 37:15.670
一看到

37:15.670 --> 37:16.670
一看到那个

37:16.670 --> 37:17.670
千套循环

37:17.670 --> 37:18.670
腿都要发抖

37:19.670 --> 37:21.670
那你就不要看千套循环

37:22.670 --> 37:23.670
其实没有任何区别的

37:23.670 --> 37:24.670
就是说

37:24.670 --> 37:25.670
它不是说有什么

37:25.670 --> 37:26.670
特别的特殊的规则

37:26.670 --> 37:28.670
一点特殊的规则都没有

37:28.670 --> 37:30.670
一点特殊的规则都没有

37:30.670 --> 37:31.670
那就来就行了

37:31.670 --> 37:32.670
你这里

37:32.670 --> 37:33.670
不就是你看

37:33.670 --> 37:34.670
你单看这个单码

37:34.670 --> 37:35.670
单看这个单码

37:35.670 --> 37:36.670
是不是可以用循环解决

37:36.670 --> 37:37.670
那就有写呗

37:37.670 --> 37:38.670
写循环呗

37:38.670 --> 37:39.670
只不过这里不能

37:39.670 --> 37:40.670
不能再用i了

37:40.670 --> 37:41.670
为什么

37:41.670 --> 37:42.670
因为这里已经有i了

37:42.670 --> 37:43.670
对吧

37:43.670 --> 37:44.670
在同一个中央域里边

37:44.670 --> 37:45.670
造成了名字冲突

37:45.670 --> 37:46.670
你换一个名字呗

37:46.670 --> 37:47.670
从1循环到解

37:47.670 --> 37:48.670
循环到4

37:48.670 --> 37:49.670
你把它写完

37:49.670 --> 37:50.670
让它解

37:50.670 --> 37:51.670
循环到4

37:51.670 --> 37:52.670
你不要看前面的

37:53.670 --> 37:54.670
有单看这个单码

37:55.670 --> 37:56.670
单看这个单码

37:56.670 --> 37:58.670
是不是很容易用循环来提取

37:58.670 --> 37:59.670
对吧

37:59.670 --> 38:00.670
那这里放成什么

38:00.670 --> 38:01.670
关成接

38:01.670 --> 38:02.670
对吧

38:02.670 --> 38:03.670
从1变到4

38:03.670 --> 38:04.670
1运行4

38:04.670 --> 38:05.670
2运行4

38:05.670 --> 38:06.670
3运行4

38:06.670 --> 38:07.670
然后

38:07.670 --> 38:08.670
放到一个变量里边

38:08.670 --> 38:09.670
然后把一个变量

38:09.670 --> 38:10.670
头殼

38:10.670 --> 38:13.180
出息

38:13.180 --> 38:14.180
就解决了吗

38:14.180 --> 38:15.180
单看这个单码

38:15.180 --> 38:16.180
是不是就很容易解决

38:16.180 --> 38:17.180
对吧

38:17.180 --> 38:20.180
千套并没有任何的特殊

38:20.180 --> 38:21.180
不要说

38:21.180 --> 38:23.180
一层千套有什么特殊规则

38:23.180 --> 38:24.180
二层千套有什么特殊规则

38:24.180 --> 38:26.180
没有任何特殊规则

38:26.180 --> 38:27.180
它不就是走一遍吗

38:27.180 --> 38:28.180
idol1的时候

38:28.180 --> 38:29.180
把这个单码走一遍

38:29.180 --> 38:30.180
管理这个是什么单码

38:30.180 --> 38:31.180
反正走一遍

38:32.180 --> 38:33.180
idol2的时候

38:33.180 --> 38:34.180
把这个单码走一遍

38:34.180 --> 38:35.180
这个单码可以是判断

38:35.180 --> 38:36.180
可以是循环

38:36.180 --> 38:37.180
可以是正常流程

38:37.180 --> 38:38.180
都可以

38:39.180 --> 38:40.180
完了

38:40.180 --> 38:41.180
没了

38:42.180 --> 38:43.180
是不是

38:43.180 --> 38:44.180
就创建了随着铺个牌了

38:44.180 --> 38:45.180
然后了

38:45.180 --> 38:46.180
还有两张大小王

38:46.180 --> 38:47.180
对吧

38:47.180 --> 38:48.180
那就是pocus

38:48.180 --> 38:49.180
再来铺洗一个

38:49.180 --> 38:50.180
当然了

38:50.180 --> 38:52.180
我们这个单码其实可以减化的

38:52.180 --> 38:53.180
我这里是不是

38:53.180 --> 38:54.180
把它保存到变量里面

38:54.180 --> 38:55.180
再放进去

38:55.180 --> 38:56.180
那么根据我们之前学的知识

38:56.180 --> 38:57.180
这里可以放变量

38:57.180 --> 38:58.180
可以放字面量

38:58.180 --> 38:59.180
可以放表达式

38:59.180 --> 39:00.180
可以直接这样子写

39:00.180 --> 39:01.180
更加减化单码

39:02.180 --> 39:03.180
创建一个对象

39:03.180 --> 39:04.180
把这个对象

39:04.180 --> 39:05.180
放到这个数组里面去

39:05.180 --> 39:06.180
那这里也是一样

39:06.180 --> 39:07.180
还有两张大小王

39:08.180 --> 39:09.180
你看现在创建对象

39:09.180 --> 39:11.180
是不是变得特别简单了

39:11.180 --> 39:12.180
大小王

39:12.180 --> 39:16.620
小王的话是十四

39:17.620 --> 39:19.620
花色无所谓

39:20.620 --> 39:22.620
反正大小王跟花色无关的

39:24.620 --> 39:25.620
大王

39:25.620 --> 39:28.930
你看最后是不是大小王了

39:29.930 --> 39:31.930
那么数组里创建好了

39:32.930 --> 39:34.930
好那么现在回到这

39:34.930 --> 39:36.930
你先把这个单码写一遍

39:36.930 --> 39:39.500
写一遍再说

39:39.500 --> 39:40.500
好

39:40.500 --> 39:41.500
那么接下来

39:41.500 --> 39:42.500
我们希望把这个过程

39:42.500 --> 39:44.500
也封装成一个

39:44.500 --> 39:45.500
因为我们认为

39:45.500 --> 39:47.500
这个玩意就是一叠破个牌

39:47.500 --> 39:48.500
那么我们希望

39:48.500 --> 39:49.500
如果说我们的

39:49.500 --> 39:51.500
我有很多叠破个牌

39:51.500 --> 39:52.500
那这个单码

39:52.500 --> 39:53.500
是不是又来很多次

39:53.500 --> 39:54.500
所以说我们干脆

39:54.500 --> 39:55.500
把这个玩意也封装成一个

39:55.500 --> 39:56.500
勾到函数

39:56.500 --> 39:58.500
就是一叠破个牌

39:58.500 --> 39:59.500
一叠破个牌不就是一个数组吗

39:59.500 --> 40:00.500
我就把这个流程

40:00.500 --> 40:01.500
帮你走一遍

40:01.500 --> 40:02.500
这样子以后

40:02.500 --> 40:03.500
你创建一叠破个牌

40:03.500 --> 40:04.500
非常简单

40:04.500 --> 40:05.500
你调用一下6就可以了

40:05.500 --> 40:10.730
因此我在这

40:10.730 --> 40:11.730
就把这个Pocus

40:12.730 --> 40:14.730
换成ZSPocus

40:14.730 --> 40:15.730
就完了

40:16.730 --> 40:17.730
之后就

40:17.730 --> 40:18.730
创建了一叠破个牌了

40:18.730 --> 40:19.730
那之后我要

40:19.730 --> 40:20.730
创建一叠破个牌

40:20.730 --> 40:21.730
太简单了

40:22.730 --> 40:23.730
Dec

40:23.730 --> 40:24.730
6一个Dec

40:24.730 --> 40:25.730
注意大家而且

40:26.730 --> 40:27.730
Dec

40:28.730 --> 40:29.730
我们输出一下

40:30.730 --> 40:33.040
Dec

40:33.040 --> 40:34.040
你看

40:34.040 --> 40:35.040
Dec就是个对象

40:35.040 --> 40:36.040
它是一个一叠破个牌

40:36.040 --> 40:37.040
它里面有个属性叫Pocus

40:37.040 --> 40:38.040
表示这一叠里面

40:38.040 --> 40:40.040
包含了哪些破个牌

40:41.040 --> 40:42.040
形成这么一个结构了

40:43.040 --> 40:44.040
相当于是Dec是什么东西

40:44.040 --> 40:46.040
Dec它也是一个对象

40:46.040 --> 40:48.040
这个对象里面有个属性叫Pocus

40:48.040 --> 40:49.040
它是一个数组

40:49.040 --> 40:50.040
这里面就是很多的破个牌

40:50.040 --> 40:51.040
第一张

40:51.040 --> 40:52.040
第二张

40:53.040 --> 40:54.040
除此之外

40:55.040 --> 40:56.040
Dec一叠破个牌

40:56.040 --> 40:57.040
它也有一个函数

40:58.040 --> 40:59.040
加一个函数

40:59.040 --> 41:00.040
Print

41:00.040 --> 41:01.040
也是打印

41:03.040 --> 41:04.040
也有一个函数

41:04.040 --> 41:05.040
它打印什么

41:05.040 --> 41:07.040
打印我这一叠破个牌里面的

41:07.040 --> 41:08.040
所有的张

41:08.040 --> 41:09.040
每一张再打出来打印

41:09.040 --> 41:10.040
这件事是不是很简单

41:10.040 --> 41:12.040
我们的循环便利的数组

41:12.040 --> 41:13.040
每一项

41:14.040 --> 41:15.040
ZSPocus

41:16.040 --> 41:18.040
你把这个成语写出来了过后

41:19.040 --> 41:20.040
基本上会构造函数

41:20.040 --> 41:21.040
基本上会构造函数

41:21.040 --> 41:22.040
包括我们的对象

41:22.040 --> 41:24.040
这一块又更深刻的理解

41:25.040 --> 41:26.040
是不是循环这个数组

41:28.040 --> 41:29.040
是不是可以拿到数组的每一项

41:31.040 --> 41:32.040
拿到数组的每一项

41:32.040 --> 41:33.040
每一项是个啥

41:33.040 --> 41:34.040
不就是个破个牌吗

41:35.040 --> 41:36.040
每个破个牌里面

41:36.040 --> 41:37.040
是不是有个Print方法

41:38.040 --> 41:39.040
这边有一个Print

41:39.040 --> 41:40.040
我们就调用

41:40.040 --> 41:41.040
P.Print

41:42.040 --> 41:43.040
打印整结破个牌

41:43.040 --> 41:44.040
什么意思

41:44.040 --> 41:45.040
就是把一张一张

41:45.040 --> 41:46.040
拿出来打印

41:47.040 --> 41:48.040
就这样写完了

41:49.040 --> 41:50.040
后面就舒服了

41:50.040 --> 41:51.040
你看我一叠破个牌

41:51.040 --> 41:53.040
又可以调用P.Print

41:53.040 --> 41:54.040
他又会帮我

41:54.040 --> 41:55.040
把整个破个牌打印出来

41:56.040 --> 41:59.700
就可以打印出来了

42:00.700 --> 42:01.700
有问题吧

42:03.700 --> 42:04.700
然后这里

42:04.700 --> 42:05.700
其实你还可以这样写

42:05.700 --> 42:06.700
简写

42:06.700 --> 42:07.700
这是个表达式

42:07.700 --> 42:08.700
表达式都可以替换

42:08.700 --> 42:09.700
这里的变量

42:10.700 --> 42:11.700
反正前面是一个对象

42:11.700 --> 42:13.700
对象里面一个属性Print

42:14.700 --> 42:15.700
效果一样

42:16.700 --> 42:17.700
这就是我们想要的最懂效果

42:18.700 --> 42:19.700
那么这样的程序写出来

42:19.700 --> 42:20.700
尽管很多同学说

42:20.700 --> 42:21.700
这个程序

42:21.700 --> 42:22.700
我不用够多寒序写

42:22.700 --> 42:23.700
确实能写

42:23.700 --> 42:24.700
但是你体会一下

42:24.700 --> 42:25.700
这个勾造还是我们带来的

42:25.700 --> 42:26.700
优势在哪

42:27.700 --> 42:28.700
创建对象

42:28.700 --> 42:29.700
虽然说我们这一块

42:29.700 --> 42:30.700
写了很多代码

42:31.700 --> 42:33.700
但是代码你随便都要写的

42:33.700 --> 42:34.700
你不写到寒序里面

42:34.700 --> 42:35.700
你要写到外边

42:35.700 --> 42:36.700
总规定都要写

42:37.700 --> 42:39.700
但这样子以后可方便了

42:40.700 --> 42:41.700
以后我要创建

42:41.700 --> 42:42.700
比方说后边一段代码

42:43.700 --> 42:44.700
写了一段时间

42:44.700 --> 42:46.700
我突然又要创建一副破个牌

42:46.700 --> 42:47.700
我又来一次就完事了

42:47.700 --> 42:48.700
非常简单

42:49.700 --> 42:50.700
我就不用再把之前的流程

42:50.700 --> 42:52.700
又全部重新写一遍

42:52.700 --> 42:53.700
这就是寒序的作用

42:54.700 --> 42:57.460
比方前面没了

42:57.460 --> 42:59.460
后边我又要创建一个碟破个牌

42:59.460 --> 43:00.460
只要你创建一碟破个牌

43:00.460 --> 43:01.460
是不是掉了它

43:01.460 --> 43:02.460
就直接创建了

43:02.460 --> 43:04.460
有的时候我不想创建一碟

43:04.460 --> 43:05.460
我只想创建临时的一张

43:05.460 --> 43:06.460
就给掉了它

43:07.460 --> 43:08.460
对不对

43:08.460 --> 43:09.460
所以勾造寒序的作用是什么

43:10.460 --> 43:11.460
帮我们来生成对象

43:12.460 --> 43:13.460
这个对象里面各种信息

43:13.460 --> 43:14.460
你只需要给我提供

43:14.460 --> 43:16.460
最少的必要的信息就可以了

43:17.460 --> 43:18.460
那么剩下的事情

43:18.460 --> 43:19.460
我全部帮你搞定

43:19.460 --> 43:21.460
虽然我们在写寒序的过程中

43:22.460 --> 43:23.460
花了一点时间

43:23.460 --> 43:24.460
但是以后啊

43:24.460 --> 43:25.460
可方便

43:25.460 --> 43:27.460
同学们要明白这么一个概念

43:30.150 --> 43:33.150
就是雕用寒序的次数

43:34.150 --> 43:36.150
远远大于

43:37.150 --> 43:39.150
生命寒序的次数

43:40.150 --> 43:41.150
为啥呢

43:41.150 --> 43:42.150
因为生命寒序只需要一次

43:43.150 --> 43:44.150
它就是复杂上天了

43:44.150 --> 43:45.150
它也只需要做一次

43:46.150 --> 43:48.150
你雕用的次数要做多少次

43:48.150 --> 43:49.150
你比方说吧

43:50.150 --> 43:51.150
我不知道同学们

43:51.150 --> 43:52.150
雕用这个雕用多少次

43:52.150 --> 43:54.150
少说也有几十次上百次

43:54.150 --> 43:56.150
这个寒序写了几次呢

43:57.150 --> 43:59.150
浏览器只是给你写了一次

43:59.150 --> 44:01.150
只给你写了一次这个寒序

44:01.150 --> 44:02.150
你说

44:02.150 --> 44:04.150
它写的就算再复杂

44:04.150 --> 44:05.150
比方说它写了三个小时

44:05.150 --> 44:06.150
把这个寒序写完

44:07.150 --> 44:09.150
那我们雕用它需要花多少时间

44:10.150 --> 44:11.150
只要一个人

44:11.150 --> 44:12.150
雕用它

44:12.150 --> 44:13.150
雕用这个寒序

44:13.150 --> 44:14.150
每次花一秒钟

44:15.150 --> 44:17.150
那一个人雕用了一千次

44:17.150 --> 44:18.150
就是说一千秒

44:19.150 --> 44:21.150
世界上用这个寒序的有多少人

44:21.150 --> 44:23.150
少说也有几十万人吧

44:23.150 --> 44:24.150
那你就看这个时间

44:24.150 --> 44:25.150
而且这个时间

44:25.150 --> 44:26.150
可以预期的将来

44:26.150 --> 44:27.150
还不断的增加

44:27.150 --> 44:29.150
所以雕用寒序的次数

44:29.150 --> 44:31.150
要远远大于生命寒序的次数

44:31.150 --> 44:33.150
这其实也给我们提到个型

44:33.150 --> 44:35.150
我们在生命寒序的时候

44:35.150 --> 44:37.150
一定要多考虑雕用的人

44:37.150 --> 44:39.150
雕用的越方便越好

44:40.150 --> 44:42.150
功能越完善越好

44:43.150 --> 44:44.150
所以我们在写寒序的时候

44:44.150 --> 44:46.150
一定要使用的时候

44:46.150 --> 44:47.150
越方便越好

44:49.150 --> 44:51.150
就把这道题好好练一下

44:51.150 --> 44:52.150
把这道题好好体会一下

44:52.150 --> 44:54.150
这道题你认识清楚了

44:54.150 --> 44:56.150
那你对构造寒序

44:56.150 --> 44:57.150
对对象

44:58.150 --> 44:59.150
以及对寒序

44:59.150 --> 45:01.150
都会有非常深刻的人士

45:02.150 --> 45:03.150
这这道题

