WEBVTT

00:00.880 --> 00:06.380
哎呀 好了 我们有困难的地方基本上就过了

00:06.380 --> 00:11.080
现在呢 到了非常轻松愉悦的一个环节了 就是标准库

00:11.080 --> 00:13.780
标准库是最简单的了 知道吧

00:13.780 --> 00:18.480
有些人觉得标准库难是因为他想导师想去背他

00:18.480 --> 00:21.980
想把这些东西背下来 也背下来绝对难 我都背不下来

00:21.980 --> 00:24.880
那里的难度太高了 不要去背 一个都不要去背

00:24.880 --> 00:26.880
以后我可以跟你说怎么来学习这一块

00:27.180 --> 00:30.780
首先我解释一下 什么叫做标准库

00:30.780 --> 00:35.180
首先我要解释一下 什么叫做库 什么叫做库

00:35.180 --> 00:39.180
库呢 它的英文单词叫做Niberary

00:39.180 --> 00:43.180
我写对面了 这样写啊

00:43.180 --> 00:47.380
对 就是库 就是图书馆的意思啊

00:47.380 --> 00:50.980
那么库是怎么玩的呢 它其实就是一大堆的API

00:50.980 --> 00:54.880
一大堆API 那什么叫做API呢

00:54.880 --> 01:02.880
叫做Application Program Interface

01:02.880 --> 01:05.880
叫做应用程序编程接口

01:06.880 --> 01:10.880
应用程序编程接口

01:10.880 --> 01:13.880
说的挺专业的是吧 其实这一块极其简单

01:13.880 --> 01:17.880
什么叫API API就是给你写好了一个函数

01:17.880 --> 01:21.380
告诉你怎么用 给你写好的那个函数就是API

01:21.380 --> 01:23.880
给你弄了一个对象 告诉你这个对象怎么用

01:23.880 --> 01:27.880
那个对象就是API 有时候你以后到公司里边说

01:27.880 --> 01:31.880
老邓 过来我这一块你要做这么一个功能

01:31.880 --> 01:34.880
我给你写了API你可以用 那说到API啥意思

01:34.880 --> 01:38.880
就是给你写了一些函数 写了一些对象

01:38.880 --> 01:42.880
你可以直接用 可以方便你开发的 这就是API

01:42.880 --> 01:45.880
那么什么叫库呢 就是一大堆的API

01:45.880 --> 01:48.880
有的时候我们说一大堆API也可以

01:48.880 --> 01:52.880
但是显得不专业 我给你一个库

01:52.880 --> 01:55.880
你可以使用 那么这个库就是里边有大堆的API

01:55.880 --> 01:58.880
可以非常方便来做各种各样的事情

01:58.880 --> 02:01.880
给你写好了一些东西可以直接用的 就是库

02:01.880 --> 02:06.880
那什么叫做标准库呢 这个标准又怎么理解呢

02:06.880 --> 02:09.880
这个标准就相当于是

02:09.880 --> 02:13.880
我就说我不去做 要做了具体的人去做

02:13.880 --> 02:16.880
这啥意思啊 就个例子吧

02:16.880 --> 02:21.880
比方说成哥 咱们成哥 成哥跟邓哥关系很好

02:21.880 --> 02:23.880
他们的家住的也比较近

02:23.880 --> 02:26.880
那成哥经常就跑到邓哥家里面去穿门

02:26.880 --> 02:28.880
然后一敲门 闹闹闹

02:28.880 --> 02:31.880
这个时候灯少一开门 这石柜你怎么才来

02:31.880 --> 02:35.880
这个时候让他屋里边去 老邓 过来

02:35.880 --> 02:39.880
你中午出去买点东西 咱们家成哥过来了

02:39.880 --> 02:43.880
买啥呀 去买点

02:43.880 --> 02:48.880
蒸羊糕 蒸熊掌 烧花鸭 烧鹿眼 疼疼疼

02:49.880 --> 02:52.880
这是什么 这叫定义标准

02:52.880 --> 02:55.880
我们中午吃啥 吃啥呢 我就逼逼

02:55.880 --> 02:58.880
我不说 我也不做 你去做

02:58.880 --> 03:01.880
我只是说 说就是标准

03:01.880 --> 03:05.880
比方说像这个介石里边 他告诉你

03:05.880 --> 03:09.880
说我们应该有这么一个对象

03:09.880 --> 03:12.880
这个对象呢 里边应该有这么一个方法

03:12.880 --> 03:15.880
这就是标准 他就说

03:15.880 --> 03:17.880
那么邓哥现在就出门了 对吧

03:17.880 --> 03:19.880
身上拿一百块钱 出门去买菜

03:19.880 --> 03:22.880
买菜中午回来做饭 等等等等对吧

03:22.880 --> 03:25.880
那么这叫实现标准 按照他的要求去

03:25.880 --> 03:28.880
把他实现 这叫实现标准

03:28.880 --> 03:31.880
什么叫标准库 标准库就是官方说

03:31.880 --> 03:34.880
我这里应该有这么一个东西

03:34.880 --> 03:38.880
有这么一个寒朔 这个寒朔里边

03:38.880 --> 03:41.880
有这么一个寒朔 这个寒朔

03:41.880 --> 03:44.880
应该给我返回 这么一个东西

03:44.880 --> 03:47.880
这就是定义标准 谁去实现呢

03:47.880 --> 03:50.880
浏览期去实现 包括我们的努德介石

03:50.880 --> 03:53.880
努德环境里边 他也会去实现这个标准

03:53.880 --> 03:56.880
这叫标准库 官方出的说

03:56.880 --> 03:58.880
我们这里边应该有哪些东西

03:58.880 --> 04:00.880
我们介石里边应该有哪些对象

04:00.880 --> 04:02.880
应该有哪些方法 这就是标准

04:02.880 --> 04:05.880
解释清楚了吧 这就是标准库

04:05.880 --> 04:08.880
标准库里边有很多 我们一个一个说

04:08.880 --> 04:12.880
那么听这种课 同学们记住

04:12.880 --> 04:16.880
脑袋里边一定不要去想太多

04:16.880 --> 04:20.880
也不要去背东西特别多 你看这个东西

04:20.880 --> 04:23.880
东西特别特别多 你不要去背

04:23.880 --> 04:26.880
一背的话 本来很轻松愉悦的事情

04:26.880 --> 04:29.880
就变得很复杂了 你把这个事情搞得

04:29.880 --> 04:32.880
那么这一块应该是怎么一种感觉呢

04:32.880 --> 04:34.880
就是我这里会给你一个一个介绍

04:34.880 --> 04:37.880
哪些我们比较常见的都挪得到这了

04:37.880 --> 04:39.880
一个个介绍 介绍这个寒朔怎么用

04:39.880 --> 04:41.880
这个寒朔啥意思 一个个介绍

04:42.880 --> 04:44.880
你不要去背 一背就非常枯燥了

04:44.880 --> 04:48.880
应该怎么学这一块 应该敲个二郎腿

04:48.880 --> 04:51.880
然后泡杯咖啡 像听相声一样

04:51.880 --> 04:54.880
听袁老师表演 看袁老师表演就行了

04:54.880 --> 04:57.880
一看 这个寒朔还有点意思

04:57.880 --> 05:00.880
这个寒朔还不错 这个寒朔还可以

05:00.880 --> 05:03.880
应该是保证这么一种非常非常轻松

05:03.880 --> 05:07.880
一点压力都没有的状态来听

05:07.880 --> 05:10.880
那么这个东西就背不住怎么办

05:10.880 --> 05:12.880
当你背了 不要去背啊

05:12.880 --> 05:16.880
这个文档干嘛的 像查字典那样去查询

05:16.880 --> 05:19.880
就像里面学中文 学英文 不有个词典吗

05:19.880 --> 05:23.880
中文字典 汉语字典 英文词典 英汉词典

05:23.880 --> 05:27.880
你去背这个英汉词典吗 你去背这个中文字典吗

05:27.880 --> 05:29.880
没有人去干这种事情 应该做什么

05:29.880 --> 05:30.880
应该查约

05:30.880 --> 05:33.880
我之前听袁老师讲 好像有了那个印象

05:33.880 --> 05:35.880
好像能做这一件事

05:35.880 --> 05:37.880
我去查一查具体怎么做的呀

05:37.880 --> 05:40.880
用到的时候就去查询

05:40.880 --> 05:43.880
你查个 有些常用的 你查个两三次

05:43.880 --> 05:46.880
自然而然就记住了 不需要你刻意的去记

05:46.880 --> 05:48.880
不常用的忘了就忘了嘛

05:48.880 --> 05:51.880
袁老师像这些东西 不查官方文道

05:51.880 --> 05:53.880
好多也忘了差不多了

05:53.880 --> 05:55.880
我十年开发经验啊 同学们

05:55.880 --> 05:57.880
我都记不住了 还不是说你们了

05:57.880 --> 06:00.880
不要去记这个东西 永远不要去记

06:00.880 --> 06:03.880
所以就非常轻松的听袁老师表演就行了

06:03.880 --> 06:05.880
袁老师就在这里一个个说

06:05.880 --> 06:08.880
你也不用去想他 这个玩意应该怎么来用

06:08.880 --> 06:10.880
不用去想这种问题

06:10.880 --> 06:11.880
又听一听就可以了

06:11.880 --> 06:13.880
然后我们后边有作业

06:13.880 --> 06:16.880
有很多作业 作业作业的过程中

06:16.880 --> 06:18.880
就来把电信我们经常会用到的方法

06:18.880 --> 06:20.880
好吧 所以说听一听

06:20.880 --> 06:23.880
我们这节课讲标准库里边

06:23.880 --> 06:25.880
有一个东西叫做包装内

06:25.880 --> 06:27.880
内是什么意思 够造函书吗

06:27.880 --> 06:29.880
什么叫包装内呢

06:29.880 --> 06:31.880
就是这么一个意思

06:31.880 --> 06:34.880
如果说你尝试着把原始内形

06:34.880 --> 06:37.880
当做对象来使用 原始内形是不是对象

06:37.880 --> 06:40.880
不是吗 原始内形怎么可能是对象呢

06:40.880 --> 06:42.880
比方说像一个数字

06:42.880 --> 06:44.880
它里边不可能有什么属性的

06:44.880 --> 06:45.880
也不可能有什么方法的

06:45.880 --> 06:46.880
它都不是对象 对吧

06:46.880 --> 06:48.880
它都没有什么原型的 啥都没有

06:48.880 --> 06:50.880
它是个原始内形

06:50.880 --> 06:52.880
但是你尝试着把它当成对象来使用

06:52.880 --> 06:56.880
比方说你这里写了这么一个东西

06:56.880 --> 06:58.880
这里有个变量

06:58.880 --> 07:00.880
A等于1

07:00.880 --> 07:02.880
然后你调用它里边的一个方法

07:03.880 --> 07:06.880
你居然发现它居然可以

07:06.880 --> 07:08.880
你是一个原始内形哪来的方法呢

07:08.880 --> 07:10.880
连原形都没有 对吧

07:10.880 --> 07:12.880
哪来的方法呢

07:12.880 --> 07:13.880
那么是这样子的

07:13.880 --> 07:16.880
当你尝试着把原始内形当做对象使用的时候

07:16.880 --> 07:18.880
介石会自动的

07:18.880 --> 07:22.880
把它转换成一个包装内的实力

07:22.880 --> 07:23.880
这啥意思

07:23.880 --> 07:26.880
比方说你看 这里是一个数字

07:26.880 --> 07:29.880
这个数字它是一个原始内形

07:29.880 --> 07:31.880
但是介石标准库里边

07:31.880 --> 07:34.880
说我们应该有这么一个

07:34.880 --> 07:37.880
对应的构造函数 叫做Lumber

07:38.880 --> 07:39.880
是不是一个函数

07:39.880 --> 07:41.880
应该有这么一个构造函数

07:41.880 --> 07:44.880
当你想把它当成对象使用的时候

07:44.880 --> 07:45.880
比方说要这里

07:45.880 --> 07:46.880
把它当成对象来使用

07:46.880 --> 07:49.880
那它就帮你去溜了一个Lumber

07:49.880 --> 07:51.880
然后把原始内形放进去

07:51.880 --> 07:54.880
作为参数来产生一个对象

07:54.880 --> 07:56.880
然后对象里边你看

07:56.880 --> 07:58.880
它不就有突丝军了吗

07:58.880 --> 07:59.880
不就有突丝军了吗

07:59.880 --> 08:00.880
是这么个意思

08:00.880 --> 08:02.880
包括制服串也是

08:02.880 --> 08:04.880
制服串里边一个构造函数叫Stream

08:04.880 --> 08:05.880
那么一个Stream

08:05.880 --> 08:06.880
如果说你把制服串

08:06.880 --> 08:08.880
比方说一个制服串ABC

08:08.880 --> 08:10.880
我想去做一件事

08:10.880 --> 08:11.880
制服串点练书

08:11.880 --> 08:12.880
制服串又不是对象

08:12.880 --> 08:14.880
哪来的属性练书呢

08:14.880 --> 08:18.880
那么它会把它做成一个包装内形

08:18.880 --> 08:20.880
溜一个制服串

08:20.880 --> 08:23.880
把S传进去来形成这么一个对象

08:23.880 --> 08:25.880
对象里边它自然就有练书

08:26.880 --> 08:28.880
而且还把每个制服用下标来标记

08:28.880 --> 08:30.880
你可以通过0来取到第1个制服

08:30.880 --> 08:32.880
通过1来取到第2个制服

08:32.880 --> 08:33.880
就像数组那样子

08:33.880 --> 08:34.880
它不是数组

08:35.880 --> 08:36.880
就这么个意思

08:37.880 --> 08:39.880
这个Number

08:39.880 --> 08:41.880
它就是包装内

08:41.880 --> 08:42.880
就这么个意思

08:42.880 --> 08:43.880
非常简单

08:43.880 --> 08:44.880
前边写出大杂词了

08:44.880 --> 08:46.880
后边学习非常简单

08:46.880 --> 08:47.880
那么我们就来说一下

08:47.880 --> 08:48.880
这个包装内它里边给你提供了

08:48.880 --> 08:49.880
哪些方法

08:49.880 --> 08:52.880
哪些属性可以用

08:53.880 --> 08:55.880
这点的布令就算了

08:55.880 --> 08:57.880
布令我们实在是用不到了

08:57.880 --> 08:58.880
我们就平时用的比较多的

08:58.880 --> 09:00.880
就是Number和Stream它的包装内

09:01.880 --> 09:03.880
它的一个看

09:03.880 --> 09:04.880
第一个看Number

09:04.880 --> 09:05.880
我们看一下文档怎么看

09:06.880 --> 09:07.880
这里有个超链接

09:07.880 --> 09:08.880
这个链接的就是官方链接

09:08.880 --> 09:09.880
链接到哪呢

09:09.880 --> 09:11.880
链接到MDN

09:11.880 --> 09:12.880
以后里面查的东西

09:12.880 --> 09:14.880
不要去查一段其他的网站

09:14.880 --> 09:15.880
去查MDN

09:15.880 --> 09:16.880
这里边就告诉你

09:16.880 --> 09:17.880
Number这个包装内

09:17.880 --> 09:18.880
里边给你提供了哪些东西

09:18.880 --> 09:19.880
你看属性

09:19.880 --> 09:20.880
方法

09:20.880 --> 09:22.880
还有基层关系

09:22.880 --> 09:23.880
一大堆

09:23.880 --> 09:24.880
但是一般的情况下

09:24.880 --> 09:26.880
你也不需要去看照

09:26.880 --> 09:28.880
你看我的就行了

09:28.880 --> 09:29.880
我这有一个表格

09:29.880 --> 09:30.880
列出来

09:30.880 --> 09:32.880
我们平时开发中比较常见的一些

09:32.880 --> 09:34.880
我们可能会用到了一些东西

09:34.880 --> 09:36.880
但是我写的没有那么详细

09:36.880 --> 09:38.880
写的非常粗略

09:38.880 --> 09:39.880
如果说你要看详细的话

09:39.880 --> 09:40.880
你看左边比较

09:40.880 --> 09:41.880
第一个NN

09:41.880 --> 09:42.880
你要看左边

09:42.880 --> 09:44.880
你就按出Control键点进去

09:44.880 --> 09:46.880
它就有官方的详细的解释

09:46.880 --> 09:47.880
我调一下

09:47.880 --> 09:51.450
官方的详细解释

09:51.450 --> 09:53.450
就这么个意思

09:53.450 --> 09:55.450
你要看详细的用法

09:55.450 --> 09:56.450
或者一些比较特别的用法

09:56.450 --> 09:57.450
你就去看里边

09:58.450 --> 09:59.450
如果说平时开发中

09:59.450 --> 10:01.450
用不到一些特别的用法

10:01.450 --> 10:02.450
看一下这些提示

10:02.450 --> 10:03.450
你基本上知道怎么用了

10:03.450 --> 10:05.450
好,咱们来快速过一遍

10:05.450 --> 10:07.450
首先是你要学会看这个文档

10:07.450 --> 10:08.450
这个APS什么意思

10:08.450 --> 10:09.450
说过了,就提供了一些对象

10:09.450 --> 10:11.450
一些属性一些方法

10:11.450 --> 10:13.450
第一个NAN

10:13.450 --> 10:15.450
这一个其实告诉了很多信息

10:15.450 --> 10:17.450
这种协发就告诉了很多信息

10:17.450 --> 10:18.450
这个Number是啥

10:18.450 --> 10:20.450
一个构造函数

10:20.450 --> 10:22.450
那么NAN是什么意思

10:22.450 --> 10:24.450
就是这个函数里面有个属性

10:24.450 --> 10:26.450
属性叫做NAN

10:26.450 --> 10:28.450
它表示一个数学章并不存在的数字

10:28.450 --> 10:29.450
就是NAN

10:29.450 --> 10:30.450
平时我们写的NAN

10:30.450 --> 10:32.450
其实用的就是Number里面的NAN

10:32.450 --> 10:33.450
就是这个意思

10:33.450 --> 10:34.450
说一下就完事了

10:34.450 --> 10:35.450
所以说Number

10:35.450 --> 10:37.450
我们来看一下个Number里面的NAN

10:37.450 --> 10:41.820
Number里面的NAN

10:41.820 --> 10:44.820
就是我们自己写的NAN

10:44.820 --> 10:45.820
可以直接写

10:45.820 --> 10:46.820
实际上是一样的

10:46.820 --> 10:48.820
这是给大家说一下

10:48.820 --> 10:49.820
实际上在Number里面

10:49.820 --> 10:51.820
Number里面的NAN

10:51.820 --> 10:53.820
好,你看下面这个Number

10:53.820 --> 10:54.820
一是NAN

10:54.820 --> 10:56.820
那么这个有了一个小货号

10:56.820 --> 10:57.820
说明啥

10:57.820 --> 10:59.820
说明它是一个函数

10:59.820 --> 11:01.820
这种直接写到函数里面的函数

11:01.820 --> 11:03.820
你看,这是一个函数

11:03.820 --> 11:04.820
这也是个函数

11:04.820 --> 11:06.820
把这个函数直接写到函数里面的

11:06.820 --> 11:07.820
这叫静态函数

11:07.820 --> 11:09.820
或者叫静态方法

11:09.820 --> 11:14.800
叫静态方法

11:14.800 --> 11:15.800
静态方法

11:15.800 --> 11:16.800
要学会看文档

11:16.800 --> 11:17.800
因为文档里面经常会出现一些

11:17.800 --> 11:18.800
专用名词

11:18.800 --> 11:19.800
你要知道什么意思

11:19.800 --> 11:21.800
静态方法什么意思呢

11:21.800 --> 11:22.800
比方说我们这里的一个函数

11:22.800 --> 11:23.800
S

11:23.800 --> 11:26.800
然后S里面加了一个函数

11:26.800 --> 11:28.800
这也是一个函数

11:28.800 --> 11:30.800
那么这个ABC

11:30.800 --> 11:33.800
就表示S的静态方法

11:33.800 --> 11:35.800
与之对应的

11:35.800 --> 11:36.800
还有另外一个

11:36.800 --> 11:37.800
叫实力方法

11:37.800 --> 11:39.800
那么比方说还是这个S

11:39.800 --> 11:40.800
那么同样的

11:40.800 --> 11:42.800
我给它圆形上

11:42.800 --> 11:43.800
加了一个ABC

11:43.800 --> 11:44.800
那么这个ABC

11:44.800 --> 11:47.800
是要通过6一个S来调用的

11:47.800 --> 11:49.800
6S过后才能调用这个ABC

11:49.800 --> 11:50.800
是吧

11:50.800 --> 11:51.800
那你可以把它保存到

11:51.800 --> 11:52.800
边量里面

11:52.800 --> 11:53.800
通过边量去调用

11:53.800 --> 11:54.800
一样的

11:54.800 --> 11:56.800
那么这个叫做实力方法

11:56.800 --> 11:58.800
通过它的实力去调用的

11:58.800 --> 12:01.800
要区分出实力方法

12:01.800 --> 12:04.800
或者要实力成员

12:04.800 --> 12:05.800
实力方法

12:05.800 --> 12:06.800
要知道这两个名词

12:06.800 --> 12:07.800
是什么意思

12:08.800 --> 12:10.800
那么现在我们来看这

12:10.800 --> 12:11.800
你看这样子写的

12:11.800 --> 12:12.800
Number

12:12.800 --> 12:13.800
D,R,E,N,N,N

12:13.800 --> 12:15.800
这里明显是一个静态方法

12:15.800 --> 12:17.800
这里是一个静态属性

12:17.800 --> 12:18.800
那么也就说

12:18.800 --> 12:19.800
这个函数干嘛

12:19.800 --> 12:21.800
它是判断传入的值

12:21.800 --> 12:22.800
是否是N,N,N

12:22.800 --> 12:24.800
那就是判断N,N,N的

12:24.800 --> 12:25.800
比方说

12:25.800 --> 12:29.800
我有一个0除10

12:29.800 --> 12:31.800
我要看N是不是N,N

12:31.800 --> 12:32.800
我怎么来判断呢

12:32.800 --> 12:34.800
我就可以通过Number

12:34.800 --> 12:36.800
E,N,N

12:36.800 --> 12:37.800
把N传进去

12:37.800 --> 12:38.800
它如果是N,N,N

12:38.800 --> 12:39.800
它就返回处

12:39.800 --> 12:40.800
不是N,N,N就返回Force

12:40.800 --> 12:42.800
它就说要判断N,N,N的

12:42.800 --> 12:44.800
它为什么我不能直接

12:44.800 --> 12:46.800
通过等号来判断呢

12:46.800 --> 12:48.800
因为这个等号比较坑

12:48.800 --> 12:50.800
N,N跟任何数字相

12:50.800 --> 12:52.800
跟任何东西比较都是Force

12:52.800 --> 12:53.800
它比较坑

12:53.800 --> 12:54.800
所以说要用E,N,N

12:54.800 --> 12:57.800
来判断就其他那个作用

12:57.800 --> 13:00.800
这一块其实可以直接输

13:00.800 --> 13:02.800
可以直接输写为E是N,N,N

13:02.800 --> 13:04.800
就是部加前面那个Number

13:04.800 --> 13:05.800
也可以

13:05.800 --> 13:07.800
E是N,N

13:07.800 --> 13:09.800
这样子也可以

13:09.800 --> 13:10.800
没问题的

13:10.800 --> 13:11.800
为什么呢

13:11.800 --> 13:13.800
因为它给你搞了这么一个东西

13:13.800 --> 13:14.800
不是一个全具对象吗

13:14.800 --> 13:15.800
温豆

13:15.800 --> 13:17.800
它给你一边加了一个E是N,N

13:17.800 --> 13:18.800
我们知道全具对象里边的

13:18.800 --> 13:19.800
所有东西

13:19.800 --> 13:21.800
是不是可以直接使用的

13:21.800 --> 13:22.800
是吧

13:22.800 --> 13:23.800
这个E是N,N,N

13:23.800 --> 13:25.800
其实就跟那个Number里边的E是N,N

13:25.800 --> 13:30.710
是一样的

13:30.710 --> 13:32.710
那它可能给你封装了一下

13:32.710 --> 13:34.710
这个我还真没关注

13:34.710 --> 13:36.710
这个反车了

13:36.710 --> 13:38.710
但是它功能是完全一样的

13:38.710 --> 13:39.710
功能是完全一样

13:39.710 --> 13:41.710
它可能给你封装了一次

13:41.710 --> 13:42.710
那么现在就是这两个

13:42.710 --> 13:44.710
函数的功能是完全一样的

13:44.710 --> 13:45.710
所以说你在

13:45.710 --> 13:46.710
你直接使用这个E是N,N

13:46.710 --> 13:48.710
和Number里边的E是N,N

13:48.710 --> 13:50.710
是一样的

13:50.710 --> 13:52.710
那是一样的

13:52.710 --> 13:53.710
接下来E是N,T

13:53.710 --> 13:55.710
它判断传入的值

13:55.710 --> 13:57.710
是不是整数

13:57.710 --> 13:59.710
那么来试一下吧

13:59.710 --> 14:01.710
Number里边有一个

14:01.710 --> 14:03.710
E是Integer

14:03.710 --> 14:05.710
E

14:05.710 --> 14:07.710
是不是一个整数

14:07.710 --> 14:09.710
那传入一个1.23

14:09.710 --> 14:10.710
就不是整数

14:10.710 --> 14:12.710
那传入一个1.0

14:12.710 --> 14:13.710
也是整数

14:13.710 --> 14:15.710
也是可以省略的

14:15.710 --> 14:16.710
就这么个意思

14:16.710 --> 14:17.710
它判断整数的

14:17.710 --> 14:18.710
不要去想有什么用

14:18.710 --> 14:20.710
不要去想这个问题

14:20.710 --> 14:22.710
你直接那个

14:22.710 --> 14:23.710
看就行了

14:24.710 --> 14:25.710
喝点咖啡

14:25.710 --> 14:26.710
泡点茶

14:26.710 --> 14:27.710
那么观看就行了

14:27.710 --> 14:28.710
PoseInt

14:28.710 --> 14:29.710
这个玩意儿有些同学

14:29.710 --> 14:30.710
应该知道

14:30.710 --> 14:32.710
它是把传入的值

14:32.710 --> 14:34.710
转换为整数的形式

14:34.710 --> 14:35.710
返回

14:35.710 --> 14:36.710
它不是判断

14:36.710 --> 14:37.710
它是转换

14:37.710 --> 14:38.710
比方说你给我

14:38.710 --> 14:41.710
传入一个PoseInt

14:41.710 --> 14:42.710
PoseInt

14:42.710 --> 14:44.710
你给我传入一个1.3

14:44.710 --> 14:45.710
不要传入一个制服串

14:45.710 --> 14:47.710
它会给你返回一个数字

14:47.710 --> 14:48.710
1的

14:48.710 --> 14:50.710
它不是四捨五入

14:50.710 --> 14:52.710
它不是四捨五入

14:52.710 --> 14:55.710
它是直接去掉小数

14:55.710 --> 14:56.710
去掉小数

14:56.710 --> 14:57.710
直接返回整数

14:57.710 --> 14:58.710
PoseInt

14:58.710 --> 15:00.710
转换成一个整数返回

15:00.710 --> 15:01.710
那么如果说

15:01.710 --> 15:03.710
你传入的是一个制服串

15:03.710 --> 15:05.710
比方说1.2.3

15:05.710 --> 15:07.710
ABCD,EFG

15:07.710 --> 15:08.710
那么这个东西

15:08.710 --> 15:09.710
它也能转换的

15:09.710 --> 15:10.710
它一直独一直独

15:10.710 --> 15:11.710
独到第1个

15:11.710 --> 15:13.710
不是数字为止

15:13.710 --> 15:15.710
转换出来就是1.2.3

15:15.710 --> 15:16.710
PoseInt

15:17.710 --> 15:18.710
如果说你给它

15:18.710 --> 15:19.710
传入的前边有东西

15:19.710 --> 15:21.710
前面是一些非数字

15:21.710 --> 15:22.710
没招了

15:22.710 --> 15:24.710
它发现第1个非数字

15:24.710 --> 15:25.710
第1个没发转换

15:25.710 --> 15:26.710
那就转换不了了

15:26.710 --> 15:29.710
就PoseInt

15:29.710 --> 15:31.710
还有一个对PoseInt

15:31.710 --> 15:32.710
PoseInt

15:32.710 --> 15:35.710
它在Windows里面也有PoseInt

15:35.710 --> 15:36.710
那么这个玩意

15:36.710 --> 15:41.220
跟Number的PoseInt是一样的

15:41.220 --> 15:42.220
这两个玩意是一样的

15:42.220 --> 15:43.220
所以说你就是PoseInt

15:43.220 --> 15:45.220
你可以直接使用的

15:45.220 --> 15:46.220
可以直接使用

15:46.220 --> 15:47.220
没问题的

15:47.220 --> 15:49.220
还有另外一个就是PoseFloat

15:49.220 --> 15:50.220
转换成小数

15:50.220 --> 15:52.220
比方说1.3

15:52.220 --> 15:55.220
那么得到结果就是1.3

15:55.220 --> 15:57.220
就转换成小数了

15:57.220 --> 15:59.220
非常简单

15:59.220 --> 16:00.220
每一个都非常简单

16:00.220 --> 16:01.220
不要去借

16:01.220 --> 16:02.220
那么PoseFloat

16:02.220 --> 16:03.220
也可以直接使用

16:03.220 --> 16:04.220
因为Windows里面

16:04.220 --> 16:06.220
也有一个PoseFloat

16:06.220 --> 16:07.220
接下来看下边

16:07.220 --> 16:08.220
你看

16:08.220 --> 16:11.220
NumberPrototypeToFixed

16:11.220 --> 16:13.220
你先看这个文档里面

16:13.220 --> 16:14.220
这句话表达了啥

16:14.220 --> 16:16.220
表达它是一个实力方法

16:16.220 --> 16:18.220
所以说这个实力方法

16:18.220 --> 16:19.220
你能不能这样子用

16:19.220 --> 16:21.220
根据你学过的知识

16:21.220 --> 16:23.220
这样子用ToFixed

16:23.220 --> 16:24.220
你不能

16:24.220 --> 16:25.220
根本就没有这个方法

16:25.220 --> 16:26.220
它在哪呢

16:26.220 --> 16:28.220
在具体的数字里面

16:28.220 --> 16:29.220
比方说一个N

16:29.220 --> 16:31.220
3它是一个Number的实力

16:31.220 --> 16:32.220
它是一个Number的实力

16:32.220 --> 16:35.220
那么通过这个NToFixed

16:35.220 --> 16:36.220
是这么用的

16:36.220 --> 16:39.220
要能够看懂文档

16:39.220 --> 16:40.220
看懂文档之后

16:40.220 --> 16:42.220
就是你们小学的时候

16:42.220 --> 16:44.220
不是学那个拼音

16:44.220 --> 16:45.220
发音

16:45.220 --> 16:49.220
学那个汉语字典

16:49.220 --> 16:50.220
那么你其实学的

16:50.220 --> 16:51.220
你只要学会了

16:51.220 --> 16:52.220
怎么查阅

16:52.220 --> 16:53.220
剩下的事情就不用管了

16:53.220 --> 16:54.220
老师没有必要

16:54.220 --> 16:55.220
把那个字典

16:55.220 --> 16:56.220
翻到字典的第一篇

16:56.220 --> 16:57.220
我来教你第1个字

16:57.220 --> 16:58.220
第2个字

16:58.220 --> 16:59.220
它没有必要去这样讲

16:59.220 --> 17:00.220
要疯了吧

17:00.220 --> 17:01.220
那这样讲可能你

17:01.220 --> 17:02.220
现在都还得学汉字

17:02.220 --> 17:03.220
没有必要

17:03.220 --> 17:04.220
所以我们只需要

17:04.220 --> 17:05.220
知道怎么查阅就行了

17:05.220 --> 17:06.220
你看它这里

17:06.220 --> 17:08.220
告诉你是一个圆形方法

17:08.220 --> 17:09.220
那么你又必须要

17:09.220 --> 17:10.220
在实力上去调用

17:10.220 --> 17:12.220
它告诉你什么意思呢

17:12.220 --> 17:14.220
将当前数字保留

17:14.220 --> 17:16.220
指定的位移数的小数返回

17:16.220 --> 17:18.220
传入小数的位数

17:18.220 --> 17:20.220
如果说你要具体看怎么用

17:20.220 --> 17:22.220
它详细的各种用法你点进去

17:22.220 --> 17:24.220
其实我们大部分时候

17:24.220 --> 17:26.220
只需要知道基本用法就可以了

17:26.220 --> 17:27.220
比方那么这个n

17:27.220 --> 17:28.220
这个n要给它

17:28.220 --> 17:31.220
前一个3.1415926

17:31.220 --> 17:33.220
那么现在我们对这个n

17:33.220 --> 17:34.220
直向取两位小数

17:34.220 --> 17:36.220
那么就to face

17:36.220 --> 17:38.220
后面就传入一个2

17:38.220 --> 17:40.220
那就是3.14

17:40.220 --> 17:42.220
有没有四手五入啊

17:42.220 --> 17:43.220
没有四手五入啊

17:43.220 --> 17:47.220
比方3.146

17:47.220 --> 17:49.220
n to face

17:49.220 --> 17:51.220
2

17:51.220 --> 17:53.220
还真有四手五入吗

17:53.220 --> 17:54.220
那原来你看这些东西

17:54.220 --> 17:55.220
原来是记不住对吧

17:55.220 --> 17:57.220
原来是故意给你展示一个错误

17:57.220 --> 17:59.220
告诉你这个玩意是记不住的

17:59.220 --> 18:00.220
你看那就看

18:00.220 --> 18:02.220
详细的官方文章怎么说了

18:06.620 --> 18:07.620
我看一下啊

18:07.620 --> 18:09.620
该数字会在必要时进行

18:09.620 --> 18:10.620
四手五入

18:10.620 --> 18:11.620
OK

18:11.620 --> 18:13.620
那就确实有四手五入

18:13.620 --> 18:15.620
对吧官方文章说的有

18:15.620 --> 18:17.620
是记不住的

18:18.620 --> 18:19.620
比如说有的时候

18:19.620 --> 18:21.620
你这个数字n

18:21.620 --> 18:23.620
比如说3

18:23.620 --> 18:25.620
那我如果说这种情况下

18:25.620 --> 18:26.620
我要解去两个小数呢

18:26.620 --> 18:28.620
那就变成3.00

18:28.620 --> 18:29.620
它返回的是什么呢

18:29.620 --> 18:30.620
返回的是一个制服串

18:30.620 --> 18:31.620
你看到没

18:31.620 --> 18:33.620
返回的是一个制服串

18:33.620 --> 18:34.620
这是to fix的

18:34.620 --> 18:36.620
还有一个to stream

18:36.620 --> 18:37.620
将当前的数字

18:37.620 --> 18:38.620
转换成制服串

18:38.620 --> 18:39.620
返回

18:39.620 --> 18:40.620
这个to stream

18:40.620 --> 18:41.620
它跟那个object

18:41.620 --> 18:42.620
里面的to stream

18:42.620 --> 18:43.620
是不一样的

18:43.620 --> 18:44.620
它重写过的

18:44.620 --> 18:45.620
我不用解释什么叫重写吧

18:45.620 --> 18:47.620
它在元秀上面给你重新加了一个

18:47.620 --> 18:48.620
对吧

18:48.620 --> 18:50.620
它就没有用object的一个东西

18:50.620 --> 18:51.620
那么这个玩意呢

18:51.620 --> 18:52.620
可以转换成

18:52.620 --> 18:54.620
把数字转换成制服串

18:54.620 --> 18:55.620
这个是很简单的

18:55.620 --> 18:57.620
比如说我们n.to stream

18:58.620 --> 18:59.620
是不是

18:59.620 --> 19:00.620
转换成制服串了

19:00.620 --> 19:01.620
3

19:01.620 --> 19:02.620
对吧

19:02.620 --> 19:03.620
这个玩意有一个

19:03.620 --> 19:04.620
比较有意识的特点

19:04.620 --> 19:05.620
它是这里边可以传参数的

19:05.620 --> 19:06.620
可以传进字

19:06.620 --> 19:07.620
比方说

19:07.620 --> 19:08.620
我们这个3

19:08.620 --> 19:10.620
我们可以通过to stream

19:10.620 --> 19:11.620
它传一个2

19:11.620 --> 19:12.620
表示用2进字的方式

19:12.620 --> 19:13.620
来展示3

19:13.620 --> 19:14.620
那就得到了是1 1

19:14.620 --> 19:15.620
对吧

19:15.620 --> 19:16.620
2进字1 1等于3

19:16.620 --> 19:18.620
如果说n等于

19:18.620 --> 19:20.620
随便写个比较大的数字

19:20.620 --> 19:21.620
那么n.to stream

19:21.620 --> 19:26.180
我给它写一个2

19:26.180 --> 19:27.180
那就是这种情况

19:27.180 --> 19:29.180
如果说用16进字来展示

19:30.180 --> 19:31.180
它就是8614

19:31.180 --> 19:33.180
用32进字来展示

19:33.180 --> 19:34.180
就是这个

19:34.180 --> 19:35.180
因为它一共

19:35.180 --> 19:36.180
最多可以取到36

19:36.180 --> 19:37.180
为什么36

19:37.180 --> 19:38.180
36是不是刚好是

19:38.180 --> 19:39.180
10个数字

19:39.180 --> 19:41.180
加上26个字母

19:41.180 --> 19:43.180
它就最多36进字

19:43.180 --> 19:44.180
就是这个to stream

19:44.180 --> 19:45.180
就完事了

19:46.180 --> 19:47.180
没了

19:47.180 --> 19:48.180
没了

19:48.180 --> 19:50.180
然后呢

19:50.180 --> 19:51.180
下面

19:51.180 --> 19:52.180
s stream

19:52.180 --> 19:53.180
字母创

19:53.180 --> 19:54.180
听一听就行了

19:54.180 --> 19:55.180
这是完整的文档

19:55.180 --> 19:56.180
在这

19:56.180 --> 19:57.180
它有很多的方法

19:57.180 --> 19:58.180
字母创里边方法特别多

19:58.180 --> 19:59.180
我们来看一下吧

19:59.180 --> 20:01.180
第一个静态方法

20:01.180 --> 20:02.180
from charcode

20:02.180 --> 20:04.180
根据编码值得到一个字符

20:04.180 --> 20:06.180
传入一个或多个编码值

20:06.180 --> 20:07.180
这是啥意思

20:07.180 --> 20:09.180
就是这里有一个小知识

20:09.180 --> 20:11.180
同学们可能不太清楚

20:11.180 --> 20:13.180
就是咱们字

20:13.180 --> 20:14.180
一个程度好像

20:14.180 --> 20:15.180
提到过

20:15.180 --> 20:16.180
这个编码

20:16.180 --> 20:18.180
就是咱们的计算机里边的

20:18.180 --> 20:19.180
文字这些东西

20:19.180 --> 20:21.180
它实际上是存处不了的

20:21.180 --> 20:22.180
它需要编号

20:22.180 --> 20:23.180
给文字编号

20:23.180 --> 20:26.180
因为计算机只能处理数字

20:26.180 --> 20:27.180
其他玩意处理不了

20:27.180 --> 20:28.180
像字符创这个东西

20:28.180 --> 20:29.180
它要编号

20:29.180 --> 20:31.180
比方说像那个中文串

20:31.180 --> 20:32.180
它怎么来编号呢

20:32.180 --> 20:33.180
表一编号

20:33.180 --> 20:34.180
12345678

20:34.180 --> 20:36.180
以后看到12345678

20:36.180 --> 20:38.180
表示一个字符串

20:38.180 --> 20:39.180
表示一个串

20:39.180 --> 20:40.180
这个字

20:40.180 --> 20:41.180
这么个意思叫编号

20:41.180 --> 20:42.180
叫编码

20:42.180 --> 20:44.180
那么这个编码呢

20:44.180 --> 20:45.180
有一些标准

20:45.180 --> 20:47.180
有很多很多的标准

20:47.180 --> 20:49.180
目前比较常见的标准是

20:49.180 --> 20:50.180
Ask

20:50.180 --> 20:51.180
这个呢

20:51.180 --> 20:53.180
它只编码了英文数字

20:53.180 --> 20:54.180
和英文字母

20:54.180 --> 20:56.180
和一些简单的英文符号

20:56.180 --> 20:57.180
它只编码了这些

20:57.180 --> 20:58.180
其他的非英文的

20:58.180 --> 21:00.180
它就识别不了了

21:00.180 --> 21:01.180
它就没有编码

21:01.180 --> 21:03.180
将来一个字点编码一样

21:03.180 --> 21:04.180
编号一样

21:04.180 --> 21:06.180
那么还有一个叫Ulicode

21:06.180 --> 21:08.180
Ulicode叫万国码

21:08.180 --> 21:09.180
那么它是编码

21:09.180 --> 21:11.180
这个全世界所有的文字

21:11.180 --> 21:13.180
它都有数字对应

21:13.180 --> 21:15.180
还有一个东西叫UTF-8

21:15.180 --> 21:16.180
UTF-8呢

21:16.180 --> 21:18.180
是Ulicode的一种变种

21:18.180 --> 21:19.180
你可以这样去理解

21:19.180 --> 21:21.180
那么它也是编码

21:21.180 --> 21:22.180
全世界的东西

21:22.180 --> 21:24.180
只不过它的占用的空间更少一些

21:24.180 --> 21:25.180
了解就行了

21:25.180 --> 21:27.180
那么这里呢

21:27.180 --> 21:28.180
这个函数是什么意思呢

21:28.180 --> 21:29.180
叫Stream

21:29.180 --> 21:30.180
一个静态方法

21:30.180 --> 21:32.180
叫From Charcode

21:32.180 --> 21:33.180
这里边可以传编号的

21:33.180 --> 21:35.180
97

21:35.180 --> 21:37.180
编号97的这个字符

21:37.180 --> 21:38.180
是啥呢

21:38.180 --> 21:39.180
是A

21:39.180 --> 21:40.180
A的编号

21:40.180 --> 21:41.180
小写的A

21:41.180 --> 21:43.180
编号就是97

21:43.180 --> 21:45.180
就这么个意思

21:45.180 --> 21:46.180
那98是啥呢

21:46.180 --> 21:47.180
98是B

21:47.180 --> 21:48.180
99是啥呢

21:48.180 --> 21:50.180
99是C

21:50.180 --> 21:52.180
那Z是啥呢

21:52.180 --> 21:53.180
那不就是97

21:53.180 --> 21:54.180
加上26吗

21:54.180 --> 21:55.180
26个英文字母

21:55.180 --> 21:56.180
还要减1

21:56.180 --> 21:58.180
因为它去除自身

21:58.180 --> 21:59.180
对吧

21:59.180 --> 22:00.180
是不是Z

22:00.180 --> 22:01.180
就这么个意思

22:01.180 --> 22:03.180
它可以通过一个数字

22:03.180 --> 22:05.180
来得到

22:06.180 --> 22:07.180
一个字符

22:07.180 --> 22:08.180
对吧

22:08.180 --> 22:09.180
根据编码来得到字符

22:09.180 --> 22:10.180
叫From Charcode

22:11.180 --> 22:12.180
有意思吧

22:12.180 --> 22:13.180
好

22:13.180 --> 22:14.180
这个玩意

22:14.180 --> 22:15.180
这是一个实力成员

22:15.180 --> 22:16.180
对吧

22:16.180 --> 22:17.180
实力成员

22:17.180 --> 22:20.180
得到字符创的长度

22:20.180 --> 22:21.180
这个玩意是得到

22:21.180 --> 22:22.180
字符创的长度

22:22.180 --> 22:23.180
也就是说我们

22:23.180 --> 22:25.180
因为它是实力成员

22:25.180 --> 22:26.180
所以说s.nl

22:26.180 --> 22:28.180
要通过实力去访问

22:28.180 --> 22:29.180
对吧

22:29.180 --> 22:30.180
实力成员

22:30.180 --> 22:31.180
好

22:31.180 --> 22:32.180
再下一个

22:32.180 --> 22:33.180
得到某个下标的

22:33.180 --> 22:34.180
字符编码

22:34.180 --> 22:35.180
你看它是不是

22:35.180 --> 22:37.180
是静态的还是实力的

22:37.180 --> 22:38.180
是实力成员

22:38.180 --> 22:39.180
实力方法

22:39.180 --> 22:40.180
这是一个方法

22:40.180 --> 22:41.180
Charcode

22:41.180 --> 22:42.180
Char是什么

22:42.180 --> 22:43.180
字符

22:43.180 --> 22:44.180
Code是编码

22:45.180 --> 22:47.180
Alt是在哪里

22:47.180 --> 22:50.180
在某一个字符的编码

22:50.180 --> 22:51.180
什么意思呢

22:51.180 --> 22:52.180
看一下吧

22:52.180 --> 22:53.180
比方说这个字符创

22:53.180 --> 22:54.180
我想知道

22:54.180 --> 22:55.180
第二个字符的编码是多少

22:55.180 --> 23:00.180
s.charcode.

23:00.180 --> 23:01.180
传入一个

23:01.180 --> 23:02.180
一是什么下标

23:02.180 --> 23:03.180
对吧

23:04.180 --> 23:05.180
看一下

23:05.180 --> 23:06.180
这个字符创里面

23:06.180 --> 23:07.180
第二个字符

23:07.180 --> 23:08.180
它的编码是多少

23:08.180 --> 23:10.180
编码是98

23:10.180 --> 23:11.180
可以得到某一个字符创

23:11.180 --> 23:14.180
里面某一个字符的编码

23:14.180 --> 23:15.180
include

23:15.180 --> 23:16.180
判断

23:16.180 --> 23:17.180
当前字符创

23:17.180 --> 23:18.180
是否包含某个指创

23:18.180 --> 23:19.180
非常简单

23:19.180 --> 23:20.180
它也是实力的

23:20.180 --> 23:22.180
后面好多都是实力的了

23:22.180 --> 23:23.180
比方说s.nl

23:23.180 --> 23:24.180
是一个字符创

23:24.180 --> 23:25.180
我来看一下

23:25.180 --> 23:26.180
这个字符创里面

23:26.180 --> 23:27.180
include

23:27.180 --> 23:29.180
是不是包含

23:29.180 --> 23:31.180
DFD的

23:31.180 --> 23:33.500
DFD

23:33.500 --> 23:34.500
它反回去

23:34.500 --> 23:35.500
就表示包含

23:35.500 --> 23:36.500
反回forged表示不包含

23:36.500 --> 23:38.500
那这个就是forged

23:38.500 --> 23:39.500
判断

23:39.500 --> 23:40.500
这个字符创里面

23:40.500 --> 23:42.500
是否包含某一个字符创

23:42.500 --> 23:43.500
include

23:43.500 --> 23:44.500
index

23:44.500 --> 23:45.500
它不仅可以判断

23:45.500 --> 23:46.500
它有没有包含

23:46.500 --> 23:49.500
还可以得到它的下标位置

23:49.500 --> 23:50.500
这是什么意思呢

23:50.500 --> 23:51.500
比方说

23:51.500 --> 23:52.500
我有一个字符创

23:52.500 --> 23:54.500
ABCDEFG

23:54.500 --> 23:55.500
ABC

23:55.500 --> 23:56.500
好

23:56.500 --> 23:57.500
那么这个字符创

23:57.500 --> 23:58.500
我可以使用index

23:58.500 --> 24:01.500
得到A的

24:01.500 --> 24:02.500
我想知道

24:02.500 --> 24:03.500
在这个字符创里面存不存在

24:03.500 --> 24:04.500
存在的话

24:04.500 --> 24:06.500
我得到一个下标

24:06.500 --> 24:07.500
下标是0

24:07.500 --> 24:08.500
有这个字符

24:08.500 --> 24:09.500
在这个字符创里面

24:09.500 --> 24:10.500
出现的位置

24:10.500 --> 24:12.500
是下标0这个位置

24:12.500 --> 24:14.500
就第一次出现的位置

24:14.500 --> 24:15.500
那怎么说

24:15.500 --> 24:16.500
没找到呢

24:16.500 --> 24:18.500
没找到就是附1

24:18.500 --> 24:19.500
index

24:19.500 --> 24:20.500
女子对应的

24:20.500 --> 24:22.500
还有一个last index

24:22.500 --> 24:25.500
它是找最后一个出现的位置

24:25.500 --> 24:26.500
比方说

24:26.500 --> 24:27.500
最后一个出现的位置

24:27.500 --> 24:28.500
第一个出现的位置

24:28.500 --> 24:29.500
是0

24:29.500 --> 24:30.500
最后一个出现的位置

24:30.500 --> 24:31.500
是7

24:31.500 --> 24:32.500
得到这么一个东西

24:32.500 --> 24:35.500
得到它的下标

24:35.500 --> 24:36.500
不要去想有什么用

24:36.500 --> 24:37.500
听一听

24:37.500 --> 24:38.500
有这个意思

24:38.500 --> 24:39.500
可以

24:39.500 --> 24:40.500
不错

24:40.500 --> 24:41.500
index

24:41.500 --> 24:42.500
判断某个字符创

24:42.500 --> 24:45.500
是否以指定的字符创结束

24:45.500 --> 24:46.500
比方说

24:46.500 --> 24:48.500
有一个字符创

24:50.500 --> 24:51.500
我想看一下

24:51.500 --> 24:52.500
这个字符创是不是

24:52.500 --> 24:53.500
一点结束的

24:53.500 --> 24:55.500
那么index

24:55.500 --> 24:57.500
传入一个点

24:57.500 --> 24:58.500
它返回去

24:58.500 --> 25:00.500
就表示一点结束了

25:00.500 --> 25:01.500
返回force就不是

25:01.500 --> 25:02.500
那就不是一点结束

25:02.500 --> 25:03.500
对吧

25:03.500 --> 25:04.500
我看一下

25:04.500 --> 25:05.500
是不是以兜号结束呢

25:05.500 --> 25:06.500
就force

25:06.500 --> 25:07.500
对吧

25:07.500 --> 25:08.500
就是index

25:08.500 --> 25:09.500
那么你女子对应的

25:09.500 --> 25:11.500
还有一个start

25:11.500 --> 25:12.500
start

25:12.500 --> 25:14.500
是不是以什么开头

25:14.500 --> 25:15.500
对吧

25:15.500 --> 25:16.500
是不是以兜号开头呢

25:16.500 --> 25:17.500
不是

25:17.500 --> 25:19.500
那是不是以a开头呢

25:19.500 --> 25:20.500
是

25:20.500 --> 25:22.500
就取这么一个作用

25:22.500 --> 25:24.500
pan start

25:24.500 --> 25:26.500
这个玩意有点意思

25:26.500 --> 25:28.500
它是将当前字符创

25:28.500 --> 25:29.500
已经填充

25:29.500 --> 25:30.500
pan是填充的意思

25:30.500 --> 25:31.500
将pan顶

25:31.500 --> 25:32.500
是不是填充

25:32.500 --> 25:34.500
填充到指定的位数

25:34.500 --> 25:36.500
返回填充后的字符创

25:36.500 --> 25:39.810
好比方说

25:39.810 --> 25:41.810
这里有一个字符创等于

25:41.810 --> 25:42.810
1

25:42.810 --> 25:43.810
我想

25:44.810 --> 25:47.810
把它填充到两位pan start

25:49.810 --> 25:51.810
填充到两位

25:51.810 --> 25:52.810
不够两位呢

25:52.810 --> 25:54.810
就用0来填充

25:54.810 --> 25:56.810
那么它就会在左边

25:56.810 --> 25:57.810
pan start

25:57.810 --> 25:58.810
在开始位置

25:58.810 --> 25:59.810
看一下有没有两位

25:59.810 --> 26:00.810
没有两位在开始位置

26:00.810 --> 26:01.810
不断的填充0

26:01.810 --> 26:03.810
直到达到两位变成01

26:03.810 --> 26:05.810
这种东西对有的时候

26:05.810 --> 26:06.810
我们做一些格式化

26:06.810 --> 26:08.810
特别像日期时间的格式化

26:08.810 --> 26:09.810
特别有用

26:09.810 --> 26:10.810
比方说

26:10.810 --> 26:12.810
我这里有个数字表示的

26:12.810 --> 26:13.810
当时的小时

26:13.810 --> 26:14.810
小时呢

26:14.810 --> 26:16.810
今天早上8点我就写了8

26:16.810 --> 26:18.810
但是我在显示的时候

26:18.810 --> 26:20.810
我可能要显示08

26:20.810 --> 26:21.810
对吧

26:21.810 --> 26:22.810
我要显示08

26:22.810 --> 26:23.810
那么这里我怎么来显示呢

26:23.810 --> 26:25.810
我就H2

26:25.810 --> 26:27.810
我就H2Stream

26:27.810 --> 26:29.810
把它转换成字幕串

26:29.810 --> 26:30.810
对吧

26:30.810 --> 26:31.810
先把它转换成字幕串

26:31.810 --> 26:32.810
字幕串里面不就有一个方法

26:32.810 --> 26:34.810
叫pan start

26:34.810 --> 26:35.810
能看懂吗

26:35.810 --> 26:36.810
这是连写

26:36.810 --> 26:37.810
这个表达是得到的

26:37.810 --> 26:38.810
是一个字幕串

26:38.810 --> 26:39.810
字幕串里面一个函数

26:39.810 --> 26:40.810
叫pan start

26:40.810 --> 26:42.810
那么填充两位

26:42.810 --> 26:44.810
不够的位置就补充0

26:44.810 --> 26:45.810
那么不够的就是08

26:45.810 --> 26:46.810
那如果说

26:46.810 --> 26:49.810
是等于16呢

26:49.810 --> 26:51.810
那它就没有做任何处理

26:51.810 --> 26:53.810
短线已经有两位了

26:53.810 --> 26:54.810
就是pan start

26:54.810 --> 26:55.810
那么还有一个对应的

26:55.810 --> 26:57.810
对应的叫pan end

26:57.810 --> 26:58.810
这么意思呢

26:58.810 --> 26:59.810
就是在墨尾填充

26:59.810 --> 27:00.810
一个是在前边填充

27:00.810 --> 27:01.810
一个是在墨尾填充

27:01.810 --> 27:03.810
那就不举例了

27:03.810 --> 27:05.810
split叫分割

27:05.810 --> 27:06.810
它可以把字幕串呢

27:06.810 --> 27:07.810
按照某一个规则

27:07.810 --> 27:09.810
来分割成数组返回

27:09.810 --> 27:10.810
这什么意思呢

27:10.810 --> 27:11.810
比方说我有一个字幕串

27:11.810 --> 27:13.810
A空格B

27:13.810 --> 27:15.810
空格C

27:15.810 --> 27:19.810
A斗号B斗号CD

27:19.810 --> 27:21.810
那么我可以通过split

27:21.810 --> 27:22.810
叫split

27:22.810 --> 27:23.810
split就分割的意思

27:23.810 --> 27:24.810
你把它传入一个斗号

27:24.810 --> 27:26.810
它就会按照斗号来分割

27:26.810 --> 27:27.810
这个字幕串

27:27.810 --> 27:29.810
把它分割成了一个数组

27:29.810 --> 27:31.810
它返回一个数组

27:31.810 --> 27:32.810
你看数组的每一项

27:32.810 --> 27:34.810
就是按照斗号来分割出来的

27:34.810 --> 27:35.810
懂的意思吧

27:35.810 --> 27:37.810
就这么个意思

27:37.810 --> 27:38.810
非常简单的

27:38.810 --> 27:39.810
这是split

27:39.810 --> 27:40.810
substream

27:40.810 --> 27:42.810
获取指字幕串

27:42.810 --> 27:44.810
它会传入两个指

27:44.810 --> 27:45.810
一个是开始位置

27:45.810 --> 27:46.810
一个是结束位置

27:46.810 --> 27:48.810
比方说有一个字幕串

27:48.810 --> 27:50.810
等于ABCD

27:50.810 --> 27:52.810
EFG

27:52.810 --> 27:54.810
Ssubstream

27:54.810 --> 27:55.810
有两个

27:55.810 --> 27:57.810
一个是Ssubstr

27:57.810 --> 27:59.810
一个是Ssubstream

27:59.810 --> 28:01.810
有两个东西都可以

28:01.810 --> 28:03.810
都可以做类似的事情

28:03.810 --> 28:04.810
这个玩意

28:04.810 --> 28:05.810
我刚才看到一下

28:05.810 --> 28:06.810
官方稳当

28:06.810 --> 28:08.810
他说已经不建议你使用了

28:08.810 --> 28:10.810
将来可能会删除这个方法

28:10.810 --> 28:11.810
不建议你使用了

28:11.810 --> 28:12.810
让你建议你使用这个

28:12.810 --> 28:13.810
所以我们之后都使用这个

28:13.810 --> 28:15.810
其实我以前还挺喜欢这个的

28:15.810 --> 28:17.810
那我们就使用这个

28:17.810 --> 28:19.810
传入两个位置

28:19.810 --> 28:21.810
比方说传入1

28:21.810 --> 28:22.810
3

28:22.810 --> 28:23.810
这是啥意思

28:23.810 --> 28:24.810
这是从这个字幕串的

28:24.810 --> 28:26.810
第一个位置开始取到哪

28:26.810 --> 28:27.810
取到第三个位置

28:27.810 --> 28:28.810
下标1开始

28:28.810 --> 28:29.810
1

28:29.810 --> 28:30.810
2

28:30.810 --> 28:31.810
3

28:31.810 --> 28:32.810
第三个位置取不到

28:32.810 --> 28:34.810
它是一个B区间

28:34.810 --> 28:35.810
不是开区间

28:35.810 --> 28:36.810
它是一个B区间

28:36.810 --> 28:37.810
叫什么呢

28:37.810 --> 28:38.810
反正就这个位置取不到

28:38.810 --> 28:39.810
第三个位置取不到

28:39.810 --> 28:40.810
只能去这两个

28:40.810 --> 28:42.810
所以得到的是BC

28:42.810 --> 28:43.810
就这么意思

28:43.810 --> 28:44.810
这是结束位置

28:44.810 --> 28:45.810
这是开始位置

28:45.810 --> 28:47.810
结束位置取不到的

28:47.810 --> 28:48.810
这是substream

28:49.810 --> 28:52.810
去掉守卫空白

28:52.810 --> 28:58.040
字幕说的两端

28:59.040 --> 29:00.040
从字幕串的两端

29:00.040 --> 29:01.040
删除空白字幕

29:01.040 --> 29:02.040
返回新字幕串

29:02.040 --> 29:04.040
来看一下

29:04.040 --> 29:06.040
S里边我给它写一个

29:06.040 --> 29:08.040
空格空格空格ABC

29:08.040 --> 29:12.120
空格空格空格

29:12.120 --> 29:13.120
那就得到这么一个字幕串

29:13.120 --> 29:15.120
然后我通过tune

29:15.120 --> 29:16.120
这个方法

29:16.120 --> 29:17.120
它会返回一个新字幕串

29:17.120 --> 29:18.120
返回了字幕串

29:18.120 --> 29:19.120
守卫的空白给你去掉了

29:19.120 --> 29:20.120
那么这个东西

29:20.120 --> 29:21.120
其实有好处的

29:21.120 --> 29:22.120
比方说用户

29:22.120 --> 29:23.120
经常在网页上去

29:23.120 --> 29:25.120
输入什么用户名啊密码

29:25.120 --> 29:27.120
或者是填一些邮箱

29:27.120 --> 29:28.120
可能有些用户

29:28.120 --> 29:29.120
手抖了一下对吧

29:29.120 --> 29:30.120
在填的时候

29:30.120 --> 29:32.120
前面给它敲了几个空格

29:32.120 --> 29:33.120
那么这些空格对我们来说

29:33.120 --> 29:34.120
是毫无意义的

29:34.120 --> 29:36.120
那么可能会去掉守卫空格

29:36.120 --> 29:38.120
然后再来进行处理

29:38.120 --> 29:39.120
叫tune

29:39.120 --> 29:40.120
它不会去掉中间的空格

29:40.120 --> 29:41.120
中间的空格是有意义的

29:41.120 --> 29:43.120
它不会去掉的

29:43.120 --> 29:44.120
还有一个是tune start

29:44.120 --> 29:47.120
它只去除开始的空格

29:47.120 --> 29:48.120
tune end

29:48.120 --> 29:50.120
只去掉末尾的空格

29:50.120 --> 29:52.120
其实严格来说

29:52.120 --> 29:53.120
不只是空格

29:53.120 --> 29:55.120
叫空白制服

29:55.120 --> 29:56.120
包括回车

29:56.120 --> 29:57.120
包括那个

29:57.120 --> 29:58.120
制表服

29:58.120 --> 29:59.120
都是空白制服

29:59.120 --> 30:00.120
就是没有东西的制服

30:00.120 --> 30:02.120
都会给你去掉

30:02.120 --> 30:03.120
to uppercase

30:03.120 --> 30:04.120
表示呢

30:04.120 --> 30:06.120
得到这个制服串的大写形式

30:06.120 --> 30:08.120
这个只是适用于

30:08.120 --> 30:09.120
英文字母

30:09.120 --> 30:10.120
abc

30:10.120 --> 30:13.120
s2 uppercase

30:13.120 --> 30:15.120
这个还是会返回一个新制服串

30:15.120 --> 30:18.120
然后得到一个大写的结果

30:18.120 --> 30:21.120
那如果说你的制服串是大写的呢

30:22.120 --> 30:25.120
那么通过调用to lowercase

30:26.120 --> 30:28.120
会把它转换成小写

30:28.120 --> 30:30.120
就这么个东西

30:30.120 --> 30:31.120
没了

30:31.120 --> 30:33.120
制服串我们常见的就这么一些了

30:33.120 --> 30:34.120
不用去记

30:34.120 --> 30:35.120
一个都不要去记

30:35.120 --> 30:37.120
听着还舒服吧

30:37.120 --> 30:38.120
还可以吧

30:38.120 --> 30:39.120
每个都能理解吗

30:39.120 --> 30:40.120
听着时候能理解吗

30:40.120 --> 30:41.120
听着就忘

30:41.120 --> 30:42.120
马上就忘

30:42.120 --> 30:44.120
我再多记它一秒

30:44.120 --> 30:45.120
我是孙子

30:45.120 --> 30:46.120
我不要去记它

30:46.120 --> 30:48.120
接下来我们再多练习题

30:48.120 --> 30:50.120
像这些东西一定是在

30:50.120 --> 30:52.120
做效果做功能的时候

30:52.120 --> 30:54.120
经常用到了你就记得住了

30:54.120 --> 30:56.120
没有经常用到你就是记不住

30:56.120 --> 30:58.120
正常的很

30:58.120 --> 31:00.120
好我们来看第一题

31:01.120 --> 31:03.120
生成一个a到z的制服串

31:03.120 --> 31:05.120
那这个玩意儿呢

31:05.120 --> 31:07.120
我还是复制一下

31:13.970 --> 31:14.970
生成一个a到z的制服串

31:14.970 --> 31:15.970
那这个玩意儿

31:15.970 --> 31:16.970
我们如果说

31:16.970 --> 31:18.970
这样子写可不可以呢

31:18.970 --> 31:21.970
ab

31:21.970 --> 31:23.970
不对不对不对

31:23.970 --> 31:25.970
abcdefg

31:25.970 --> 31:26.970
有提示

31:26.970 --> 31:27.970
这个type-line

31:27.970 --> 31:28.970
它有提示

31:28.970 --> 31:30.970
它知道你可能要做什么

31:30.970 --> 31:31.970
所以说给你写出来了

31:31.970 --> 31:33.970
可不可以可以

31:33.970 --> 31:34.970
怎么不可以呢

31:34.970 --> 31:35.970
可以

31:35.970 --> 31:36.970
但是呢

31:36.970 --> 31:37.970
这个代码呢

31:37.970 --> 31:38.970
看上去有点傻乎乎的

31:38.970 --> 31:40.970
其实也还好吧

31:40.970 --> 31:42.970
但是我们能不能想办法

31:42.970 --> 31:44.970
用一个循环来做呢

31:44.970 --> 31:45.970
能不能想办法

31:45.970 --> 31:46.970
用一个循环来做呢

31:46.970 --> 31:47.970
其实是可以的

31:47.970 --> 31:48.970
因为我们知道

31:48.970 --> 31:49.970
每一个字母是不是有编码

31:49.970 --> 31:50.970
对吧

31:50.970 --> 31:51.970
a是多好编码

31:51.970 --> 31:52.970
是90c

31:52.970 --> 31:53.970
大家觉得我记不住

31:53.970 --> 31:54.970
90c怎么办了

31:54.970 --> 31:55.970
那你就这样子写呗

31:55.970 --> 31:56.970
你看我们的文档里边

31:56.970 --> 31:58.970
不是有一个这个东西吗

31:58.970 --> 32:00.970
得到某个下边的制服编码

32:00.970 --> 32:01.970
它可以得到编码的

32:01.970 --> 32:02.970
你就看一下吧

32:02.970 --> 32:04.970
我就看一下

32:04.970 --> 32:06.970
chocodate

32:06.970 --> 32:07.970
我就写个b

32:07.970 --> 32:08.970
这个字母说吧

32:08.970 --> 32:10.970
它chocodate

32:10.970 --> 32:11.970
0对吧

32:11.970 --> 32:12.970
第一个位置的编码是多少

32:12.970 --> 32:13.970
98

32:13.970 --> 32:15.970
那a的编码呢

32:16.970 --> 32:17.970
97对吧

32:17.970 --> 32:19.970
那z的编码呢

32:21.970 --> 32:22.970
122

32:22.970 --> 32:23.970
对吧

32:23.970 --> 32:24.970
97到122

32:24.970 --> 32:25.970
所以我只需要

32:25.970 --> 32:26.970
是不是需要写个循环

32:26.970 --> 32:29.970
97到122的循环就可以了

32:30.970 --> 32:32.970
a等于97

32:32.970 --> 32:35.970
a小于等于122

32:35.970 --> 32:37.970
a加加

32:37.970 --> 32:38.970
每一循环一次

32:38.970 --> 32:40.970
是不是生成了一个数字

32:40.970 --> 32:41.970
对吧

32:41.970 --> 32:42.970
是不是生成一个数字

32:42.970 --> 32:43.970
我现在只需要把这个数字

32:43.970 --> 32:45.970
反向在转成制服

32:45.970 --> 32:46.970
是不是就可以了

32:46.970 --> 32:47.970
那怎么转成制服了

32:47.970 --> 32:48.970
我也忘了

32:48.970 --> 32:49.970
我都忘了

32:49.970 --> 32:50.970
老呗

32:50.970 --> 32:52.970
根据编码得到一个制服

32:52.970 --> 32:54.970
这不就这个玩意吗

32:54.970 --> 32:56.970
忘了具体要怎么穿参数字

32:56.970 --> 32:57.970
怎么做

32:57.970 --> 32:58.970
点进去看呗

32:58.970 --> 32:59.970
文档里面给你说的

32:59.970 --> 33:01.970
清清楚楚怎么去做的

33:01.970 --> 33:02.970
你看

33:02.970 --> 33:04.970
怎么写的

33:04.970 --> 33:05.970
656667

33:05.970 --> 33:07.970
它可以返回大写的abc

33:07.970 --> 33:08.970
你说穿一个可以

33:08.970 --> 33:09.970
穿两个可以

33:09.970 --> 33:10.970
穿多个可以

33:10.970 --> 33:11.970
它还可以支持

33:11.970 --> 33:12.970
其他静制

33:12.970 --> 33:13.970
比方这里16静制

33:13.970 --> 33:15.970
形式也可以支持

33:15.970 --> 33:16.970
我们就不管了

33:16.970 --> 33:17.970
我们就使静制就可以了

33:17.970 --> 33:18.970
那么我们这里

33:18.970 --> 33:20.970
就可以使用那个

33:20.970 --> 33:21.970
Street from Charcode

33:21.970 --> 33:23.970
其实这里也会提醒你

33:23.970 --> 33:25.970
只不过它提醒的是英文

33:25.970 --> 33:28.970
一直在它

33:28.970 --> 33:29.970
它都没有提示嘛

33:29.970 --> 33:30.970
那就写进去吧

33:30.970 --> 33:31.970
把i写进去

33:31.970 --> 33:34.970
是不是就拿到一个制服了

33:34.970 --> 33:36.970
说说一下这个制服

33:36.970 --> 33:38.970
不就是abcd就出来了吗

33:38.970 --> 33:39.970
那我只需要把这个制服

33:39.970 --> 33:40.970
拼接到s里面

33:40.970 --> 33:41.970
对吧

33:41.970 --> 33:44.970
说s加等于c

33:44.970 --> 33:46.970
如果这个玩意看不懂

33:46.970 --> 33:47.970
你就写s

33:47.970 --> 33:49.970
把原章的s

33:49.970 --> 33:50.970
摸尾在拼接上

33:50.970 --> 33:51.970
一个这个东西

33:51.970 --> 33:52.970
所以不断的拼接

33:52.970 --> 33:54.970
不断的先拼接a再拼接b

33:54.970 --> 33:55.970
再拼接c

33:55.970 --> 33:56.970
拼接完了过

33:56.970 --> 33:57.970
就输出s

33:57.970 --> 33:59.970
不就完了吗

33:59.970 --> 34:01.970
当然这个单码还可以简化

34:01.970 --> 34:02.970
就这一块

34:02.970 --> 34:04.970
其实没有必要去写个变量

34:04.970 --> 34:05.970
首先这一块

34:05.970 --> 34:08.970
就可以简化成加等于

34:08.970 --> 34:09.970
然后这个玩意

34:09.970 --> 34:11.970
是没有写个变量的必要了

34:11.970 --> 34:13.970
因为它就用一次

34:13.970 --> 34:15.970
所以表达是拼接进去

34:16.970 --> 34:17.970
运行

34:18.970 --> 34:19.970
一样的结果

34:19.970 --> 34:20.970
其实这一块

34:20.970 --> 34:21.970
我们还可以优化程序

34:21.970 --> 34:23.970
你看这里写的97122

34:23.970 --> 34:25.970
一下看不出来

34:26.970 --> 34:28.970
这个974就代表a

34:28.970 --> 34:29.970
120就代表z

34:29.970 --> 34:30.970
一下子看不出来

34:30.970 --> 34:31.970
其实这一块

34:31.970 --> 34:33.970
我们也可以是这样子来写

34:33.970 --> 34:34.970
怎么写呢

34:39.970 --> 34:41.970
这样子是不是得到a的编码

34:41.970 --> 34:43.970
a的纸一开始

34:44.970 --> 34:46.970
到z的编码

34:49.970 --> 34:50.970
是不是可以

34:50.970 --> 34:51.970
这表达是吗

34:51.970 --> 34:52.970
对吧

34:52.970 --> 34:53.970
这里相当于是放了一个120

34:53.970 --> 34:54.970
不过代码看上去

34:54.970 --> 34:55.970
更加容易理解

34:55.970 --> 34:57.970
那就是从a循环到z

34:57.970 --> 34:58.970
对吧

34:58.970 --> 34:59.970
一看就明白了

35:00.970 --> 35:01.970
懂了吧

35:01.970 --> 35:02.970
就这么意思

35:02.970 --> 35:03.970
这第2道题

35:03.970 --> 35:04.970
好 第2道题

35:04.970 --> 35:05.970
加下面的字无处的

35:05.970 --> 35:07.970
分割成一个单词数组

35:08.970 --> 35:09.970
那就是

35:09.970 --> 35:10.970
是不是我们刚才

35:10.970 --> 35:12.970
好像音乐在哪里写的

35:12.970 --> 35:13.970
对吧

35:13.970 --> 35:14.970
来找一找呗

35:14.970 --> 35:15.970
哪里呢

35:15.970 --> 35:16.970
在这儿

35:16.970 --> 35:17.970
像这种做法

35:17.970 --> 35:19.970
我们经常都在做

35:19.970 --> 35:20.970
给同学们看一下

35:20.970 --> 35:23.970
袁老师的书签

35:30.440 --> 35:31.440
这里边保存了

35:31.440 --> 35:33.440
各种各样的官方文档

35:33.440 --> 35:34.440
一大堆

35:34.440 --> 35:35.440
我去记他

35:35.440 --> 35:36.440
我一个都不去记

35:36.440 --> 35:37.440
多记他一分钟

35:37.440 --> 35:38.440
我是孙子

35:38.440 --> 35:39.440
我开发的时候

35:39.440 --> 35:40.440
经常用的

35:40.440 --> 35:41.440
我不需要去翻语

35:41.440 --> 35:42.440
对吧

35:42.440 --> 35:43.440
经常用的

35:43.440 --> 35:44.440
我自然人都记住了

35:44.440 --> 35:45.440
没有同学到现在

35:45.440 --> 35:46.440
记不住那个var

35:46.440 --> 35:48.440
没有同学记不住这个单词吧

35:48.440 --> 35:50.440
没有同学记不住这个方式

35:50.440 --> 35:52.440
那如果说你记不住的话

35:52.440 --> 35:53.440
之前的作业

35:53.440 --> 35:54.440
我就不知道你是

35:54.440 --> 35:55.440
砸了 混过来的

35:56.440 --> 35:57.440
为什么你记得说

35:57.440 --> 35:58.440
是你靠背的吧

35:58.440 --> 35:59.440
不是你靠经常写

35:59.440 --> 36:00.440
就记住了

36:01.440 --> 36:03.440
说这里不需要记

36:03.440 --> 36:04.440
那遇到不常用怎么办

36:04.440 --> 36:05.440
有的时候就去查

36:05.440 --> 36:06.440
多查了几次

36:06.440 --> 36:08.440
就发现他就比较常用了

36:08.440 --> 36:09.440
自然人就记住了

36:10.440 --> 36:12.440
做开发不需要去记

36:12.440 --> 36:14.440
面试怎么办

36:14.440 --> 36:15.440
如果说你们以后

36:15.440 --> 36:16.440
公司

36:17.440 --> 36:18.440
他考虑API

36:20.440 --> 36:21.440
而且考虑不是那种

36:21.440 --> 36:22.440
常用的API

36:22.440 --> 36:24.440
他有的如果考虑的是常用的

36:24.440 --> 36:25.440
那毫无疑问

36:25.440 --> 36:26.440
他是没问题的

36:26.440 --> 36:27.440
他首先看你

36:27.440 --> 36:28.440
代码量足不足够

36:28.440 --> 36:29.440
对吧

36:29.440 --> 36:30.440
不是看你记忆力好不好

36:30.440 --> 36:31.440
是看你

36:31.440 --> 36:33.440
平时写代码写得多不多

36:33.440 --> 36:34.440
写得多的话

36:34.440 --> 36:35.440
自然人就记住了

36:35.440 --> 36:36.440
他通过这种方式

36:36.440 --> 36:38.440
来考察你平时在做什么

36:39.440 --> 36:41.440
考察常用的没问题

36:41.440 --> 36:42.440
如果说公司里面

36:42.440 --> 36:43.440
去考察了一些

36:43.440 --> 36:44.440
不常用的API

36:45.440 --> 36:47.440
这家公司你赶紧跑

36:47.440 --> 36:48.440
这个公司脑袋有问题

36:49.440 --> 36:50.440
不太正常

36:50.440 --> 36:51.440
知道吧

36:52.440 --> 36:53.440
所以说你不用去担心这个

36:53.440 --> 36:55.440
真儿八经以后你做开发

36:55.440 --> 36:57.440
你的网页是这个样子的

36:57.440 --> 36:59.440
全打开的是各种官方文档

37:00.440 --> 37:01.440
有些不常用的API

37:01.440 --> 37:02.440
随时查阅

37:03.440 --> 37:04.440
这个标签也是

37:04.440 --> 37:05.440
放不下的一大堆

37:05.440 --> 37:06.440
正常的狠

37:07.440 --> 37:08.440
好 那么现在这个

37:08.440 --> 37:09.440
我们要去做分割

37:09.440 --> 37:10.440
对吧

37:10.440 --> 37:11.440
我们看到的split

37:11.440 --> 37:12.440
就不只有分割了吗

37:12.440 --> 37:13.440
我们刚才

37:13.440 --> 37:14.440
就是这样做的

37:14.440 --> 37:15.440
它是一个实力方法

37:15.440 --> 37:16.440
对吧 首先告诉你

37:16.440 --> 37:17.440
它是一个实力方法

37:17.440 --> 37:18.440
那你该怎么用的

37:18.440 --> 37:20.440
肯定是通过一个实力

37:20.440 --> 37:21.440
这个字幕上的实力去调用

37:21.440 --> 37:22.440
实不列制

37:22.440 --> 37:24.440
那里面传的是一个分割符

37:24.440 --> 37:26.440
按什么分割呢 按斗毫分割

37:26.440 --> 37:27.440
它返回的是什么呢

37:27.440 --> 37:29.440
返回的就是一个数组

37:29.440 --> 37:33.670
你看

37:33.670 --> 37:37.110
所以返回一个数组

37:37.110 --> 37:39.110
好 但是个返回的

37:39.110 --> 37:41.110
不是按斗毫分割

37:41.110 --> 37:43.110
单词数组按空格来分割

37:43.110 --> 37:45.110
所以返回了单词的数组

37:45.110 --> 37:47.110
对吧 那么这个单词数组

37:47.110 --> 37:48.110
那我还说了

37:48.110 --> 37:50.110
要去掉每一项的

37:51.110 --> 37:52.110
逗号

37:53.110 --> 37:54.110
和

37:55.110 --> 37:56.110
这个符号

37:56.110 --> 37:58.110
那这个东西怎么做呢

37:58.110 --> 38:01.110
去掉每一项的逗号和底儿

38:01.110 --> 38:02.110
有一个函数

38:02.110 --> 38:04.110
在这里面没讲到

38:04.110 --> 38:05.110
有一个函数

38:05.110 --> 38:06.110
我在这里写上吧

38:06.110 --> 38:07.110
有个函数

38:07.110 --> 38:08.110
叫做stream

38:09.110 --> 38:12.110
prototype replace

38:12.110 --> 38:13.110
哦

38:14.110 --> 38:15.110
它可以

38:16.110 --> 38:22.110
替换制服圈儿中的某一个

38:22.110 --> 38:23.110
某

38:24.110 --> 38:26.110
替换制服冲测东的所有

38:27.110 --> 38:29.110
对应制服为

38:31.110 --> 38:35.320
为新制服

38:35.320 --> 38:37.320
那么这里呢是一个超链接

38:37.320 --> 38:41.020
我看一下这超链接地址市场

38:41.020 --> 38:43.020
复制一下

38:43.020 --> 38:44.020
这个

38:45.020 --> 38:46.020
复制一下吧

38:46.020 --> 38:48.020
这里应该是replace

38:49.020 --> 38:50.020
就这个

38:54.890 --> 38:55.890
这个超链接

38:56.890 --> 38:58.890
好 那么这个函数怎么用呢

38:58.890 --> 38:59.890
我们来试一下吧

38:59.890 --> 39:00.890
这个函数

39:01.890 --> 39:02.890
比方说一个制服圈儿

39:02.890 --> 39:04.890
制服圈儿里面ABSAE

39:04.890 --> 39:05.890
有很多的A

39:05.890 --> 39:08.890
我想把A那替换成replace all

39:08.890 --> 39:09.890
还有一个replace

39:09.890 --> 39:11.890
replace后面讲政治表达式的时候再说

39:12.890 --> 39:14.890
我想把所有的A替换成

39:14.890 --> 39:15.890
逗号

39:15.890 --> 39:19.580
它会返回一个新制服圈

39:19.580 --> 39:21.580
它不会改原来的

39:21.580 --> 39:22.580
不会改原来的

39:22.580 --> 39:23.580
它会返回一个新制服圈

39:23.580 --> 39:25.580
所有A的位置变成逗号了

39:25.580 --> 39:26.580
就起着那个作用

39:26.580 --> 39:27.580
好 那么现在呢

39:27.580 --> 39:28.580
我有一个数组了

39:28.580 --> 39:29.580
对吧

39:29.580 --> 39:30.580
这个数组里面每一项

39:30.580 --> 39:31.580
它可能有逗号 有可能没有

39:31.580 --> 39:33.580
有可能有一个 有可能有多个

39:33.580 --> 39:34.580
都说不准

39:34.580 --> 39:35.580
还有一些句号

39:35.580 --> 39:36.580
对吧

39:36.580 --> 39:37.580
那我怎么弄呢

39:37.580 --> 39:38.580
我要把它得到

39:38.580 --> 39:40.580
每一项的逗号和句号去掉

39:40.580 --> 39:41.580
来看着啊

39:41.580 --> 39:43.580
我就循环这个数组

39:45.580 --> 39:46.580
循环这个数组

39:46.580 --> 39:48.580
是不是可以拿到数组的每一项

39:48.580 --> 39:49.580
replace

39:49.580 --> 39:50.580
你看一下

39:50.580 --> 39:51.580
拿到数组的每一项

39:51.580 --> 39:53.580
然后每一项是不是个制服圈

39:53.580 --> 39:54.580
那每一个制服圈

39:54.580 --> 39:56.580
是不是有个函数叫replace all

39:57.580 --> 39:58.580
我把什么来替换

39:58.580 --> 40:01.580
我把逗号来替换成一个空制服

40:01.580 --> 40:03.580
不是空格哈

40:03.580 --> 40:04.580
啥都没有

40:04.580 --> 40:06.580
那相当于是把逗号去掉了

40:06.580 --> 40:07.580
对吧 它会返

40:08.580 --> 40:11.790
replace all

40:11.790 --> 40:13.790
这个玩意只能在浏览器里面运行

40:13.790 --> 40:14.790
这道题

40:14.790 --> 40:16.790
你们要放到浏览器里面运行

40:16.790 --> 40:18.790
代码可以写到这个文件里面

40:19.790 --> 40:20.790
你看

40:20.790 --> 40:22.790
是不是逗号没了

40:22.790 --> 40:23.790
具号还在

40:23.790 --> 40:24.790
逗号没了对吧

40:24.790 --> 40:26.790
那每一项你看这个表达是

40:26.790 --> 40:27.790
返回了是不是

40:27.790 --> 40:29.790
返回了新制服圈

40:29.790 --> 40:31.790
是不是就把逗号去掉了

40:31.790 --> 40:33.790
那我还要去掉具号怎么办呢

40:33.790 --> 40:36.790
那你又在这个制服圈的基础上

40:36.790 --> 40:38.790
再去去掉具号

40:38.790 --> 40:39.790
你就这样写呗

40:39.790 --> 40:40.790
再来一个

40:40.790 --> 40:42.790
连着写就关事了

40:42.790 --> 40:44.790
因为我这个漏的版本可能有点低

40:44.790 --> 40:45.790
可能是这个原因

40:45.790 --> 40:47.790
漏的里面还没有支持这个方法

40:47.790 --> 40:52.510
这个方法是新方法

40:52.510 --> 40:53.510
又说怕减容性问题

40:53.510 --> 40:55.510
当浏览器以后遇到脑浏览器怎么办

40:55.510 --> 40:57.510
减容性问题现在不该考虑

40:57.510 --> 40:58.510
不是你考虑的时候

40:58.510 --> 41:00.510
将来我们工程化的时候

41:00.510 --> 41:01.510
会告诉你怎么解决减容性

41:01.510 --> 41:03.510
你现在大胆的写

41:03.510 --> 41:05.510
你看逗号和具号是不是都去掉了

41:07.510 --> 41:10.510
先把这个制服圈去掉逗号

41:10.510 --> 41:11.510
得到一个新制服圈

41:11.510 --> 41:12.510
这是个表达式

41:12.510 --> 41:13.510
这是个新制服圈

41:13.510 --> 41:16.510
这个新制服圈再来去掉具号

41:16.510 --> 41:18.510
又得到一个新制服圈

41:18.510 --> 41:19.510
然后输出

41:19.510 --> 41:21.510
然后我现在要做的是什么呢

41:21.510 --> 41:23.510
我做的事情就是

41:23.510 --> 41:26.510
给重新给它的这一项复制

41:26.510 --> 41:27.510
对吧

41:27.510 --> 41:28.510
给输出的这一项复制

41:28.510 --> 41:31.510
复制为这个新制服圈

41:31.510 --> 41:32.510
就完事了

41:32.510 --> 41:33.510
好

41:33.510 --> 41:34.510
我们来看一下

41:34.510 --> 41:37.590
放过来

41:37.590 --> 41:38.590
好

41:38.590 --> 41:40.590
接下来我们来看一下这个results

41:41.590 --> 41:43.590
你看所有的制服圈里面

41:43.590 --> 41:45.590
是不是就没有逗号和具号了

41:45.590 --> 41:46.590
就这么个意思

41:46.590 --> 41:49.590
是去掉replace all

41:50.590 --> 41:51.590
好

41:52.590 --> 41:53.590
其实还有一个replace

41:53.590 --> 41:54.590
给你们说一下吧

41:54.590 --> 41:55.590
这个replace

41:55.590 --> 41:56.590
这个环境是支持的

41:56.590 --> 41:58.590
replace它只能去掉第1个

41:58.590 --> 42:00.590
它不能去掉所有的

42:00.590 --> 42:01.590
如果说遇到

42:01.590 --> 42:03.590
但这里边没有这种情况

42:03.590 --> 42:05.590
如果说遇到了多个

42:05.590 --> 42:07.590
就是某一个圈里边有多个具号

42:07.590 --> 42:08.590
多个都好的话

42:08.590 --> 42:10.590
那就只能去掉第1个了

42:10.590 --> 42:11.590
那这里没有这种情况

42:11.590 --> 42:12.590
所以说这里的replace

42:12.590 --> 42:13.590
也可以解决

42:14.590 --> 42:15.590
第三题

42:16.590 --> 42:17.590
得到下边制服圈中

42:17.590 --> 42:20.590
第1个i和最后一个i之间的

42:20.590 --> 42:21.590
指寸

42:21.590 --> 42:22.590
第1个i在哪呢

42:22.590 --> 42:23.590
第1个i

42:23.590 --> 42:24.590
在这是吧

42:24.590 --> 42:25.590
最后一个i在哪呢

42:25.590 --> 42:26.590
在这

42:26.590 --> 42:28.590
那我要得到之间的指寸

42:28.590 --> 42:29.590
我要得到这么一个东西

42:30.590 --> 42:32.590
那得到指寸

42:32.590 --> 42:33.590
在哪里呢

42:33.590 --> 42:34.590
我们找一找

42:34.590 --> 42:35.590
得到指寸

42:35.590 --> 42:36.590
是不是这个substream

42:37.590 --> 42:38.590
对吧

42:38.590 --> 42:39.590
它要传入两个参数

42:39.590 --> 42:40.590
第1个参数呢

42:40.590 --> 42:41.590
就是骑士位置

42:41.590 --> 42:43.590
然后第2个参数呢

42:43.590 --> 42:44.590
是结束位置

42:45.590 --> 42:46.590
那我是不是要得

42:46.590 --> 42:48.590
先来得到骑士位置在哪

42:48.590 --> 42:49.590
那骑士位置在哪

42:49.590 --> 42:50.590
我又怎么得到呢

42:50.590 --> 42:51.590
就第1个i在哪

42:51.590 --> 42:52.590
骑士位置在哪

42:52.590 --> 42:53.590
是不是我们又找API

42:53.590 --> 42:55.590
sv有个index

42:55.590 --> 42:56.590
那是index

42:56.590 --> 42:58.590
第1个骑士位置的坐标

42:58.590 --> 43:00.590
最后一个位置的坐标

43:00.590 --> 43:01.590
对吧

43:01.590 --> 43:02.590
所以说我们这里呢

43:02.590 --> 43:03.590
要做这么几个处理

43:03.590 --> 43:04.590
首先呢

43:04.590 --> 43:05.590
我们要得到start

43:06.590 --> 43:07.590
骑士位置的坐标

43:07.590 --> 43:08.590
怎么来得到呢

43:08.590 --> 43:10.590
str index

43:11.590 --> 43:13.590
看i第1个坐标在哪

43:13.590 --> 43:15.590
来输出一下start

43:17.590 --> 43:18.590
骑

43:18.590 --> 43:19.590
对吧

43:19.590 --> 43:20.590
i在这个位置

43:21.590 --> 43:22.590
好

43:22.590 --> 43:23.590
最后一个坐标

43:23.590 --> 43:24.590
end

43:24.590 --> 43:25.590
str index

43:26.590 --> 43:27.590
last index

43:31.590 --> 43:32.590
对不对

43:32.590 --> 43:34.590
那么骑士坐标和

43:34.590 --> 43:35.590
结束标都得到了

43:36.590 --> 43:38.590
7221

43:38.590 --> 43:39.590
然后呢

43:39.590 --> 43:40.590
接下来我们来

43:40.590 --> 43:41.590
结去指数就行了

43:41.590 --> 43:42.590
result

43:43.590 --> 43:45.590
str substr

43:45.590 --> 43:47.590
骑士位置start

43:47.590 --> 43:48.590
结束位置end

43:48.590 --> 43:49.590
它结束位置是取不到的

43:49.590 --> 43:50.590
然后我们来看一下

43:50.590 --> 43:54.160
取出来的结果

43:54.160 --> 43:55.160
不会出来了吗

43:55.160 --> 43:56.160
但是第1个i

43:56.160 --> 43:57.160
如果说你不需要第1个i

43:57.160 --> 43:59.160
那么就是骑士位置加1

43:59.160 --> 44:00.160
从这里开始去

44:00.160 --> 44:01.160
对吧

44:01.160 --> 44:02.160
从骑士位置加1

44:02.160 --> 44:03.160
开始从这里开始去

44:04.160 --> 44:05.160
如果说你不需要第1个i

44:05.160 --> 44:06.160
最后一个肯定没有i

44:06.160 --> 44:07.160
因为它最后一个位置

44:07.160 --> 44:08.160
取不到

44:10.160 --> 44:11.160
好

44:11.160 --> 44:12.160
然后呢 这里就

44:12.160 --> 44:13.160
就下完了

44:15.160 --> 44:16.160
这是第3题

44:16.160 --> 44:17.160
第4题

44:18.160 --> 44:19.160
第4题有意思

44:19.160 --> 44:21.160
将下边的RGB格式

44:21.160 --> 44:22.160
转换成Hex格式

44:22.160 --> 44:24.160
就是16金字的格式

44:24.160 --> 44:25.160
就这种邪法

44:27.160 --> 44:28.160
就这种邪法

44:29.160 --> 44:30.160
好 那这里就怎么转换了

44:30.160 --> 44:31.160
你看

44:31.160 --> 44:32.160
那我肯定

44:32.160 --> 44:33.160
这个玩意肯定不要了

44:33.160 --> 44:34.160
对吧

44:34.160 --> 44:35.160
我只要这里面

44:35.160 --> 44:36.160
3个数字是啥

44:36.160 --> 44:37.160
说到第1步

44:37.160 --> 44:39.160
你要取出的3个数字

44:40.160 --> 44:43.160
取出3个数字

44:44.160 --> 44:45.160
来取呗

44:45.160 --> 44:47.160
有的人可以用Substream来取

44:47.160 --> 44:48.160
也可以呢

44:49.160 --> 44:50.160
用这种方式

44:50.160 --> 44:51.160
你看着

44:51.160 --> 44:52.160
我们看袁老师怎么来取

44:52.160 --> 44:53.160
我这样子来取

44:53.160 --> 44:54.160
RGB

44:54.160 --> 44:56.160
我先Replace

44:56.160 --> 44:57.160
我就不用O嘛

44:57.160 --> 44:58.160
因为这个环境

44:58.160 --> 44:59.160
它不支持O

44:59.160 --> 45:00.160
你看一下你们那边

45:00.160 --> 45:01.160
安装了Note的环境

45:01.160 --> 45:02.160
是不是支持O的

45:02.160 --> 45:03.160
支持O的话就OK

45:03.160 --> 45:05.160
我这个环境不支持

45:07.160 --> 45:09.160
我替换RGB

45:10.160 --> 45:11.160
为什么呢

45:11.160 --> 45:12.160
为空置不错

45:12.160 --> 45:13.160
我先把RGB去掉

45:14.160 --> 45:15.160
你看我们来输出

45:15.160 --> 45:17.160
我先把个字幕串处理一下

45:17.160 --> 45:18.160
就变成这样子

45:18.160 --> 45:20.160
RGB是不是去掉了

45:20.160 --> 45:21.160
删除了

45:21.160 --> 45:23.160
然后我再进一步进行替换

45:23.160 --> 45:26.160
把这个左边的小货号取掉

45:26.160 --> 45:28.160
再把右边的小货号取掉

45:28.160 --> 45:33.390
是不是就剩这个东西了

45:33.390 --> 45:34.390
然后我对这个字幕串

45:34.390 --> 45:36.390
这是不是又是一个字幕串啊

45:36.390 --> 45:37.390
可以接动往后写

45:37.390 --> 45:39.390
这叫练试编程

45:39.390 --> 45:40.390
就前面得到一个字幕串

45:40.390 --> 45:42.390
然后根据这个字幕串里面有方法

45:42.390 --> 45:43.390
又得到一个字幕串

45:43.390 --> 45:44.390
然后根据这个字幕串

45:44.390 --> 45:45.390
继续往后边得到

45:45.390 --> 45:46.390
好

45:46.390 --> 45:47.390
这个字幕串呢

45:47.390 --> 45:49.390
又可以通过split

45:50.390 --> 45:51.390
来去掉什么呢

45:51.390 --> 45:53.390
来用都有号来进行分割

45:53.390 --> 45:55.390
那这样就产生了一个数组

45:56.390 --> 45:57.390
看到没

45:57.390 --> 45:58.390
是不是一个数组

45:59.390 --> 46:00.390
对吧

46:00.390 --> 46:01.390
好了

46:01.390 --> 46:03.390
于是呢我就先得到一个数组

46:03.390 --> 46:04.390
parts

46:05.390 --> 46:06.390
得到的那个数组

46:06.390 --> 46:07.390
然后取出数组的

46:07.390 --> 46:09.390
第一项不就是红吗

46:09.390 --> 46:10.390
parts

46:11.390 --> 46:12.390
第一项

46:12.390 --> 46:14.390
然后同理得到第二项

46:14.390 --> 46:15.390
第三项

46:17.390 --> 46:18.390
RG

46:20.390 --> 46:21.390
B

46:22.390 --> 46:23.390
RG

46:23.390 --> 46:24.390
GB

46:24.390 --> 46:25.390
好我们来看一下

46:25.390 --> 46:26.390
这三个数字

46:28.390 --> 46:29.390
不这是三个字幕串

46:29.390 --> 46:31.390
这三个字幕串不是数字

46:31.390 --> 46:32.390
那么接下来呢

46:32.390 --> 46:33.390
我们还要做什么呢

46:33.390 --> 46:34.390
因为它不是数字

46:34.390 --> 46:35.390
它是字幕串

46:35.390 --> 46:37.390
我们还要把它转换成

46:37.390 --> 46:38.390
数字用什么转换呢

46:38.390 --> 46:39.390
用PoseInt

46:40.390 --> 46:42.390
可以用PoseInt来进行转换

46:43.390 --> 46:44.390
那么同样的道理

46:44.390 --> 46:46.390
下面是不是也可以加上PoseInt

46:47.390 --> 46:50.660
好再来输出

46:51.660 --> 46:52.660
那就是三个数字的

46:52.660 --> 46:53.660
这就是三个数字的

46:53.660 --> 46:55.660
为什么我要把它转成数字呢

46:55.660 --> 46:56.660
因为数字里边

46:56.660 --> 46:57.660
是不是可以转进字

46:57.660 --> 46:59.660
这个玩意儿是16进字的格式

46:59.660 --> 47:00.660
第一个253

47:00.660 --> 47:02.660
是不是可以转成16进字

47:02.660 --> 47:03.660
好来输出一下

47:03.660 --> 47:05.660
R转成16进字怎么转

47:05.660 --> 47:06.660
你忘了怎么转成16进字

47:06.660 --> 47:07.660
你就插一下文档

47:07.660 --> 47:08.660
跟数字相关的

47:08.660 --> 47:09.660
对吧

47:09.660 --> 47:10.660
数字转成

47:10.660 --> 47:11.660
图示键

47:11.660 --> 47:12.660
纯入进字

47:12.660 --> 47:13.660
好了

47:13.660 --> 47:14.660
于是我们在这里

47:14.660 --> 47:15.660
RtoStream

47:15.660 --> 47:16.660
纯入16

47:17.660 --> 47:19.660
其实我们也可以在这里直接写

47:19.660 --> 47:20.660
知道吧

47:20.660 --> 47:22.660
是不是这里前面的表达

47:22.660 --> 47:23.660
是得到的是一个数字

47:23.660 --> 47:25.660
那数字不是有方法吗

47:25.660 --> 47:26.660
对吧

47:26.660 --> 47:27.660
ToStream 16

47:30.170 --> 47:32.170
这样子的我们就可以得到R

47:33.170 --> 47:34.170
RGB

47:35.170 --> 47:37.170
就是三个16进字的

47:37.170 --> 47:38.170
然后我们把它拼接起来

47:38.170 --> 47:39.170
对不对

47:40.170 --> 47:42.170
一个几号在拼接上

47:42.170 --> 47:43.170
R在拼接上

47:43.170 --> 47:45.170
G在拼接上B

47:46.170 --> 47:47.170
输出Result

47:49.170 --> 47:50.170
对吧

47:50.170 --> 47:51.170
我就可以把这个玩意

47:51.170 --> 47:52.170
转换成16进字的

47:52.170 --> 47:53.170
那我们还可以改

47:53.170 --> 47:54.170
还可以改动的

47:54.170 --> 47:55.170
比方说3

47:55.170 --> 47:56.170
你看如果说你

47:56.170 --> 47:57.170
用Substream来做的话

47:57.170 --> 47:58.170
那这里一改动的话

47:58.170 --> 47:59.170
就可以出问题了

47:59.170 --> 48:00.170
对吧

48:00.170 --> 48:01.170
一看这里可以改动的

48:02.170 --> 48:04.170
我们把它写成255

48:04.170 --> 48:05.170
255

48:05.170 --> 48:06.170
255

48:06.170 --> 48:08.170
那就刚好是FF

48:09.170 --> 48:10.170
这道题还挺有意思的

48:10.170 --> 48:11.170
好

48:11.170 --> 48:12.170
第五题

48:12.170 --> 48:14.170
把这个制服创变成

48:14.170 --> 48:15.170
脱风力迷法

48:15.170 --> 48:16.170
啥意思呢

48:16.170 --> 48:18.170
我要把这个玩意变成

48:18.170 --> 48:19.170
这个玩意

48:19.170 --> 48:21.170
那这个玩意又咋变了

48:21.170 --> 48:22.170
又咋变了

48:22.170 --> 48:23.170
首先

48:23.170 --> 48:25.170
它我们可以把这个制服创

48:25.170 --> 48:27.170
用那个空格来分割

48:27.170 --> 48:28.170
对不对

48:28.170 --> 48:29.170
所以用空格来分割

48:29.170 --> 48:30.170
分割出来是不是

48:30.170 --> 48:31.170
成一个数组

48:32.170 --> 48:33.170
对吧

48:34.170 --> 48:35.170
好

48:35.170 --> 48:36.170
然后我们这里

48:36.170 --> 48:37.170
就可以循环这个数组

48:39.670 --> 48:40.670
来说说

48:40.670 --> 48:41.670
你看一下是不是数组

48:45.330 --> 48:46.330
数组

48:46.330 --> 48:48.330
然后接下来我们来循环这个数组

48:48.330 --> 48:52.660
每一次循环

48:52.660 --> 48:53.660
我把这个数组的

48:53.660 --> 48:55.660
是不是可以拿到它的每一项

48:55.660 --> 48:56.660
对不对

48:56.660 --> 48:57.660
我们拿个辫量来接受一下

48:58.660 --> 48:59.660
数数S

48:59.660 --> 49:00.660
是不是可以拿到

49:00.660 --> 49:02.660
每一项是一个制服创

49:02.660 --> 49:04.660
我要把这个制服创怎么处理呢

49:05.660 --> 49:06.660
我要把这个制服创的

49:06.660 --> 49:07.660
第一个字母大些

49:07.660 --> 49:08.660
那怎么来获取

49:08.660 --> 49:09.660
第一个字母

49:12.620 --> 49:13.620
不就完了吗

49:13.620 --> 49:15.620
这不就是获取第一个字母吗

49:16.620 --> 49:17.620
对吧

49:17.620 --> 49:18.620
获取每个字母创的

49:18.620 --> 49:19.620
第一个字母

49:19.620 --> 49:20.620
然后干嘛把它大些

49:20.620 --> 49:22.620
to uppercase

49:23.620 --> 49:24.620
对吧

49:24.620 --> 49:25.620
这个前面的字母创

49:25.620 --> 49:26.620
就是第一个字母

49:26.620 --> 49:27.620
调用了个字母创的表方法

49:27.620 --> 49:28.620
把它变成大些

49:29.620 --> 49:30.620
然后再拼接上

49:30.620 --> 49:31.620
生鱼的字母

49:32.620 --> 49:33.620
生鱼的字母是不是

49:33.620 --> 49:34.620
我们也要用解去

49:34.620 --> 49:35.620
substream

49:36.620 --> 49:37.620
从第几个位置开始取

49:37.620 --> 49:39.620
从第2个位置开始取

49:39.620 --> 49:40.620
是不是从下表尾1开始取

49:40.620 --> 49:42.620
第2个参数是可以不传的

49:42.620 --> 49:44.620
第2个参数是可以不传

49:44.620 --> 49:45.620
不传的话

49:45.620 --> 49:46.620
它就解去到末尾

49:48.620 --> 49:49.620
再来打印一下s

49:50.620 --> 49:51.620
每一次处理过后

49:51.620 --> 49:52.620
就变成这样子了

49:53.620 --> 49:54.620
但是第1个单词

49:54.620 --> 49:55.620
我们是不处理的

49:56.620 --> 49:57.620
是不是第1个单词不处理

49:58.620 --> 49:59.620
对吧

49:59.620 --> 50:00.620
所以说这种情况的

50:00.620 --> 50:01.620
下表的处理的情况

50:01.620 --> 50:02.620
只发生了什么

50:02.620 --> 50:04.620
i大于0的情况

50:04.620 --> 50:05.620
就下标

50:05.620 --> 50:09.630
就是数组的下标大于0

50:09.630 --> 50:10.630
所以说第1个单词

50:10.630 --> 50:11.630
我们就不处理

50:11.630 --> 50:12.630
第1个单词还是小写

50:13.630 --> 50:14.630
那接下来怎么做

50:14.630 --> 50:15.630
还有我说吗

50:15.630 --> 50:16.630
你定一个变量

50:16.630 --> 50:17.630
一个空置不串

50:17.630 --> 50:18.630
每一次的循环

50:18.630 --> 50:20.630
你把它拼接进去

50:22.630 --> 50:24.630
把下面的这三个东西拼接进去

50:24.630 --> 50:25.630
不就完了吗

50:26.630 --> 50:28.630
就变成陀佛秘密法了

50:29.630 --> 50:32.140
然后这些

50:32.140 --> 50:35.140
what is your name

50:36.140 --> 50:37.140
就变成这样子了

50:39.140 --> 50:40.140
还是挺有意思的

50:41.140 --> 50:42.140
就没了

50:42.140 --> 50:43.140
下来过后

50:43.140 --> 50:44.140
就把这些念习题

50:44.140 --> 50:45.140
做一做

50:46.140 --> 50:47.140
就可以了

50:47.140 --> 50:48.140
再重申一次

50:48.140 --> 50:49.140
不要去背着app

50:49.140 --> 50:50.140
要学会查文档

50:50.140 --> 50:52.140
要融入从文档里面

50:52.140 --> 50:53.140
看出信息

50:53.140 --> 50:54.140
这是静态方法

50:54.140 --> 50:56.140
这是圆形成员

50:56.140 --> 50:57.140
静态方法该怎么来用

50:57.140 --> 50:59.140
圆形成员该怎么来用

50:59.140 --> 51:01.140
这个你要搞清楚

51:01.140 --> 51:03.140
这是最重要的

51:03.140 --> 51:04.140
这个搞清楚

51:04.140 --> 51:05.140
我剩下的具体的

51:05.140 --> 51:06.140
每个方法表示什么意思

51:06.140 --> 51:07.140
他要怎么传参数

51:07.140 --> 51:08.140
他返回什么

51:09.140 --> 51:10.140
看文档

51:10.140 --> 51:11.140
这文档的处理的描述一下

51:11.140 --> 51:12.140
如果说你

51:12.140 --> 51:13.140
这个处理的描述

51:13.140 --> 51:14.140
让你想不起来

51:14.140 --> 51:15.140
怎么用的话

51:15.140 --> 51:16.140
点进去看

51:16.140 --> 51:17.140
它里面有各种例子

51:17.140 --> 51:19.140
这就是这一块东西

