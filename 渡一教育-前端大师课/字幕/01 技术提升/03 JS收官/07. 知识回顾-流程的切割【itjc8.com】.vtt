WEBVTT

00:00.750 --> 00:03.710
好 咱们继续复习

00:03.710 --> 00:06.590
前面我们学习了数据的流程

00:06.590 --> 00:09.590
也就是处理数据嘛 对吧

00:09.590 --> 00:12.310
把数据一会儿放这儿 一会儿拿出来运算

00:12.310 --> 00:16.190
一会儿呢 我们通过流程加一些判断分支

00:16.190 --> 00:20.630
然后我们可能通过流程加一些循环 绕个圈圈

00:20.630 --> 00:24.030
这些都是属于流程的控制

00:24.030 --> 00:26.670
然后我们这些可能来复习什么呢 复习函数

00:26.670 --> 00:28.430
函数的本质是什么呢

00:28.590 --> 00:31.870
本质就是对流程进行切割

00:31.870 --> 00:33.750
那这个怎么理解呢

00:33.750 --> 00:35.470
我们来看一下下面这张图

00:35.470 --> 00:38.350
比方说现在我们有个流程 一个圈圈

00:38.350 --> 00:40.790
我这里有不同的形状 简化一下

00:40.790 --> 00:45.390
就是每一个形状 每一个颜色它就是一个流程

00:45.390 --> 00:46.990
那么每一个流程里边呢

00:46.990 --> 00:48.150
比方那个圈圈里边呢

00:48.150 --> 00:52.910
它可能有循环 有判断 有输出等等等等等等

00:52.910 --> 00:56.430
有复值 有运算 反正就是一套流程嘛

00:56.510 --> 00:58.670
我们一个完整的程序呢

00:58.670 --> 01:01.950
其实是有很多很多的流程组成的

01:01.950 --> 01:05.630
大家前面我们学过的那个做过一个作业啊

01:05.630 --> 01:08.230
就是那个健康计算器还记得吗

01:08.230 --> 01:10.430
健康计算器

01:11.550 --> 01:14.110
就我们先算那个BMI 对吧

01:14.110 --> 01:15.070
算出来过后了

01:15.070 --> 01:18.310
然后根据BMI的判断是否健康

01:18.310 --> 01:20.430
就是这么一套流程对吧

01:20.430 --> 01:22.430
我们可以从这个简单的例子里边呢

01:22.430 --> 01:23.630
我们可以看出啊

01:23.630 --> 01:24.990
其实一个完整的程序呢

01:24.990 --> 01:27.550
它就是有很多的流程组成的

01:27.550 --> 01:28.590
前面这个流程呢

01:28.590 --> 01:30.430
我们先计算出一个结果

01:30.430 --> 01:31.630
然后根据这个结果呢

01:31.630 --> 01:33.470
然后再进行后边的流程

01:33.470 --> 01:34.150
对吧

01:34.150 --> 01:35.230
先算BMI

01:35.230 --> 01:38.910
然后看它是不是在20到25之间

01:38.910 --> 01:40.430
如果是的话就健康

01:40.430 --> 01:42.430
小于20就偏瘦

01:42.430 --> 01:44.590
大于25就偏胖

01:44.590 --> 01:46.230
那就这个流程

01:46.230 --> 01:48.230
其实我们这是一个简单的程序

01:48.230 --> 01:49.230
那复杂的程序呢

01:49.230 --> 01:51.430
它无非就是流程多了一点嘛

01:51.430 --> 01:52.150
对吧

01:52.190 --> 01:53.550
每个流程呢

01:53.550 --> 01:56.030
处理的过程复杂了一些

01:56.030 --> 01:57.030
无非就这样嘛

01:57.030 --> 02:00.190
它还是有很多很多流程组成的

02:00.190 --> 02:01.710
那么我们在这张图里边呢

02:01.710 --> 02:02.390
就可以看到啊

02:02.390 --> 02:03.830
左边这个框框里边

02:03.830 --> 02:05.070
就是一套完整的程序

02:05.070 --> 02:05.590
这个程序呢

02:05.590 --> 02:07.430
有很多很多流程组成的

02:07.430 --> 02:09.590
从上到下就来走

02:09.590 --> 02:10.710
那这样子一来的话

02:10.710 --> 02:12.310
它会把整个程序呢

02:12.310 --> 02:14.830
第一变得特别复杂

02:14.830 --> 02:15.670
因为流程一多了

02:15.670 --> 02:17.030
它肯定复杂了嘛

02:17.030 --> 02:17.430
对不对

02:17.430 --> 02:19.390
如果说将来我要改这个程序

02:19.390 --> 02:21.350
我要改其中某一个环节的话

02:21.390 --> 02:22.550
我都在单一码里边

02:22.550 --> 02:24.070
因为我这个图看的比较清楚

02:25.070 --> 02:27.350
比方我要改这个三角形

02:27.350 --> 02:29.110
我在这改了就完事了

02:29.110 --> 02:30.590
但是在实际的单一码里边呢

02:30.590 --> 02:31.590
却密密麻麻的单一码

02:31.590 --> 02:33.110
我都不知道在哪里去改

02:33.110 --> 02:34.030
那改了这个流程

02:34.030 --> 02:36.430
会不会对后边的流程造成影响

02:36.430 --> 02:36.830
啊

02:36.830 --> 02:39.310
有很多很多的位置因素在里边

02:39.310 --> 02:40.870
这就是系统变复杂了

02:42.150 --> 02:44.270
那么我们怎么来进行简化呢

02:44.270 --> 02:46.710
我们函数就是来做这个事

02:46.710 --> 02:48.270
函数的作用是什么呢

02:48.270 --> 02:49.630
函数的作用就在于

02:49.670 --> 02:51.510
它能够切割流程

02:54.230 --> 02:57.110
它在于它能够切割流程

02:57.110 --> 02:59.710
就是把一些流程切出去

02:59.710 --> 03:01.390
哪些流程切出去呢

03:02.390 --> 03:03.710
两个部分

03:03.710 --> 03:04.510
一个部分呢

03:04.510 --> 03:06.510
是一些流程它比较复杂

03:06.510 --> 03:07.230
那么这一块

03:07.230 --> 03:09.710
如果说把它揉到整个主流程里边呢

03:09.710 --> 03:11.390
就会把主流程变得特别复杂

03:12.390 --> 03:13.350
还有一些情况呢

03:13.350 --> 03:15.630
就是某一些流程它是在重复的

03:15.630 --> 03:16.630
比方说像这个流程

03:17.870 --> 03:18.710
对吧

03:18.710 --> 03:19.390
像这个流程

03:19.790 --> 03:20.630
是不是在重复啊

03:21.270 --> 03:21.750
对不对

03:21.750 --> 03:23.550
有很多重复的流程

03:23.550 --> 03:24.790
那么这些重复的流程

03:24.790 --> 03:26.110
导致我们的代码里边

03:26.110 --> 03:28.670
就造成了很多的重复代码

03:28.670 --> 03:29.870
那么这些重复代码呢

03:29.870 --> 03:31.550
也可以把它切出去

03:31.550 --> 03:33.470
所以说函数的作用有两个

03:33.470 --> 03:34.070
它第一个呢

03:34.070 --> 03:35.790
就减少重复代码

03:35.790 --> 03:37.270
咱们软件开发里边呢

03:37.270 --> 03:41.550
有一个原则叫做转

03:41.550 --> 03:42.350
转什么意思呢

03:42.350 --> 03:48.870
叫don't repeat yourself

03:48.870 --> 03:50.390
不要老是在重复

03:50.390 --> 03:51.510
重复的代码呢

03:51.510 --> 03:53.190
是非常非常糟糕的

03:53.190 --> 03:54.470
为什么从重复的代码糟糕

03:54.470 --> 03:58.030
它部分就是多花了一些时间

03:58.030 --> 03:58.550
瞧一瞧

03:58.550 --> 03:59.670
或者是复制粘贴

03:59.670 --> 04:01.150
也没有糟糕

04:01.150 --> 04:01.750
哪去啊

04:02.870 --> 04:03.510
不是的

04:04.510 --> 04:06.390
重复的代码会带来很多的问题

04:06.390 --> 04:08.390
第一个就是整个代码不好看

04:08.390 --> 04:09.670
所以说不好阅读

04:09.670 --> 04:10.310
对吧

04:10.310 --> 04:12.950
这个有很多重复的

04:12.950 --> 04:14.790
让整个代码量变得庞大

04:14.790 --> 04:15.710
这是小问题

04:15.710 --> 04:17.590
主要的问题在于它不好维护

04:18.550 --> 04:19.910
比方说我们之前

04:19.910 --> 04:21.110
就这个流程在重复

04:21.110 --> 04:21.510
对吧

04:21.510 --> 04:23.430
那有一天我要修改这个玩意儿

04:23.430 --> 04:24.230
我一修改它

04:24.230 --> 04:25.190
我是不是要得修改它

04:25.990 --> 04:28.350
比方说我之前发现这个地方写错了

04:28.350 --> 04:29.150
或者写的不好

04:29.150 --> 04:30.390
我们要优化一下

04:30.390 --> 04:32.510
那一优化是不是要优化两个地方

04:32.510 --> 04:34.710
那这套流程里边只有两个地方

04:34.710 --> 04:36.910
有没有可能有10个地方

04:36.910 --> 04:38.710
有没有可能有100个地方

04:38.710 --> 04:41.230
而且还分散在不同的戒业式文件里边

04:41.230 --> 04:42.430
那到时候就麻烦了

04:42.430 --> 04:44.430
这个时候就麻烦了

04:44.430 --> 04:45.950
所以说我们切割流程的

04:45.990 --> 04:48.790
它是有效于能够减少重复代码

04:48.790 --> 04:51.430
来一是避免重复

04:51.430 --> 04:54.510
二是为了提升咱们程序的可维护性

04:55.750 --> 04:57.110
这是一个方面

04:57.110 --> 04:58.270
除了这个方面之外

04:58.270 --> 05:01.590
还可以有效的降低整体的复杂度

05:01.590 --> 05:02.590
好 我们来看一下

05:02.590 --> 05:04.910
我们提出去会怎么样

05:04.910 --> 05:07.590
我们发现这个流程一是复杂

05:07.590 --> 05:09.030
二它在重复

05:09.030 --> 05:11.830
所以说我们把这个流程单独的提出去

05:11.830 --> 05:14.350
就形成了一个寒树生命

05:14.350 --> 05:15.990
寒树就在做这个事

05:15.990 --> 05:16.750
把一套流程

05:16.750 --> 05:18.150
你要反正要走这个流程

05:18.150 --> 05:19.830
我把这个流程形成一个寒树

05:19.830 --> 05:20.750
这叫寒树生命

05:22.110 --> 05:22.790
好

05:22.790 --> 05:24.670
然后有了这个寒树之后

05:24.670 --> 05:26.030
我们再去走这个流程的时候

05:26.030 --> 05:29.070
就会发现整个流程变得极其的简单

05:29.070 --> 05:31.230
现在前面不变

05:31.230 --> 05:34.430
到了这我就直接拿一个寒树调用

05:34.430 --> 05:36.110
你看我这里画了个电话

05:36.110 --> 05:37.310
这电话啥意思

05:37.310 --> 05:39.750
我们寒树调用了有单只要的call

05:39.750 --> 05:41.430
我去用个电话来代替

05:41.430 --> 05:44.390
但是这个call跟这个打电话是两把事

05:44.390 --> 05:47.230
这个call有打电话的意思

05:47.230 --> 05:48.630
也有调用的意思

05:48.630 --> 05:51.350
使用它就这么个意思

05:51.350 --> 05:53.830
那么这个寒树调用了其实就是

05:53.830 --> 05:56.150
告诉他打个电话通知一下

05:56.150 --> 05:57.950
来你把这个流程走一遍

05:57.950 --> 06:00.030
他就把这个流程走了一遍

06:00.030 --> 06:03.070
然后接着后边有什么方框

06:03.070 --> 06:04.670
这个多边形

06:04.670 --> 06:07.630
然后又到了下面又要重复这个流程了

06:07.630 --> 06:09.430
我又把个电话通知一下这个寒树

06:09.430 --> 06:11.310
把这个流程走一遍

06:11.310 --> 06:12.910
就起这么个作用

06:12.910 --> 06:14.350
于是这样子过后

06:14.350 --> 06:15.870
不仅是没有重复代码了

06:15.870 --> 06:17.470
将来我们说要修改这

06:17.470 --> 06:20.190
我是不是在寒树里面把修改就完事了

06:20.190 --> 06:22.270
这意思没有重复代码了

06:22.270 --> 06:25.270
第二个是它可以有效降低整体复杂度

06:25.270 --> 06:27.190
你看这个玩意儿是不是变得很简单了

06:27.190 --> 06:29.190
它就没有那么复杂

06:29.190 --> 06:30.670
这就是寒树的作用

06:30.670 --> 06:33.310
一张图给你划清楚

06:33.310 --> 06:34.630
那么我们接下来看一下

06:34.630 --> 06:36.950
其实主要还是为了这些客的作业

06:36.950 --> 06:38.470
作业是很关键的

06:38.470 --> 06:41.070
咱们接下来看后边了

06:41.110 --> 06:44.350
寒树的一些常见的问题

06:44.350 --> 06:46.390
就同学们在学习寒树这一块

06:46.390 --> 06:47.390
发现了一些常见问题

06:47.390 --> 06:47.990
贡献的问题

06:47.990 --> 06:49.790
我把统一来说一说

06:49.790 --> 06:51.630
然后我们就开始作业

06:51.630 --> 06:53.070
好 第一个问题

06:53.070 --> 06:56.790
说应该如何去理解寒树的参数

06:56.790 --> 06:58.430
返回值寒树体

06:58.430 --> 07:00.470
有些人在这一块搞不清楚

07:00.470 --> 07:03.190
那么其实这一块其实挺简单的

07:03.190 --> 07:06.230
我们就把寒树想象成这个样子

07:06.230 --> 07:09.430
它有几个耳朵有一个尾巴

07:09.510 --> 07:11.550
这个耳朵不一定是两个

07:11.550 --> 07:12.190
不一定是两个

07:12.190 --> 07:12.950
也有可能没有

07:12.950 --> 07:13.790
也有可能有一个

07:13.790 --> 07:14.430
有可能有两个

07:14.430 --> 07:15.870
有可能有多个

07:15.870 --> 07:18.510
那么这个耳朵就相当于是参数

07:18.510 --> 07:20.750
这个尾巴只有一个

07:20.750 --> 07:23.070
尾巴始终只有一个

07:23.070 --> 07:24.750
尾巴就相当于是返回值

07:24.750 --> 07:26.630
中间这一块就是寒树体

07:26.630 --> 07:29.270
这个寒树体就相当于是

07:29.270 --> 07:30.430
这里边的东西

07:30.430 --> 07:33.190
这里边的流程就是寒树体

07:33.190 --> 07:35.510
好 我们往上看一下

07:35.510 --> 07:38.670
那怎么来理解这个参数呢

07:38.670 --> 07:39.950
这个参数又是什么意思呢

07:39.950 --> 07:42.590
这个返回值又是什么意思呢

07:42.590 --> 07:44.230
这个参数就是说

07:44.230 --> 07:45.470
你要走不是要

07:45.470 --> 07:46.750
你要走这个流程吗

07:46.750 --> 07:47.350
对吧

07:47.350 --> 07:51.270
你要走这个流程所需要的必要的信息

07:51.270 --> 07:53.030
这就叫参数

07:53.030 --> 07:54.390
我举个例子

07:54.390 --> 07:58.830
比方说

07:58.830 --> 08:04.070
哪一个寒树求和

08:04.070 --> 08:07.230
我现在要求和

08:07.230 --> 08:09.390
A加B得到一个结果

08:09.470 --> 08:11.510
大家之前都是接触我的

08:11.510 --> 08:14.110
那么这个参数表的什么意思呢

08:14.110 --> 08:15.670
就是我现在要求和

08:15.670 --> 08:16.790
把两个数求和

08:16.790 --> 08:19.190
你是不是得给我两个数

08:19.190 --> 08:20.150
你不给我两个数

08:20.150 --> 08:20.710
那能到哪里

08:20.710 --> 08:22.550
这个流程走不了

08:22.550 --> 08:23.750
所以走不了这个流程

08:23.750 --> 08:25.550
因此你不给我两个数

08:25.550 --> 08:26.150
怎么求和呢

08:26.150 --> 08:27.550
当然这个寒树没多少意义

08:27.550 --> 08:28.950
因为一个求和完全没有必要

08:28.950 --> 08:29.830
把寒树寒树

08:29.830 --> 08:31.150
我就说这个意思

08:31.150 --> 08:32.950
就是你要做这个事

08:32.950 --> 08:35.190
你得给我一些必要的信息

08:35.190 --> 08:36.910
不然我怎么做呢

08:36.910 --> 08:39.350
对不对

08:39.510 --> 08:41.070
再比如说我上同学

08:41.070 --> 08:41.910
哎小张

08:41.910 --> 08:44.870
来你来回答一个问题

08:44.870 --> 08:46.190
你咋回答

08:46.190 --> 08:47.310
你没法回答呀

08:47.310 --> 08:48.390
比方说你就是一个寒树

08:48.390 --> 08:51.630
叫Answer

08:51.630 --> 08:53.590
Answer

08:53.590 --> 08:54.390
完了

08:54.390 --> 08:55.230
我不在单码里面写

08:55.230 --> 08:56.590
我都不知道这个单字咋写了

08:56.590 --> 08:58.310
是这样写吧

08:58.310 --> 08:59.070
回答

08:59.070 --> 09:00.510
比方说回答一个问题

09:00.510 --> 09:02.630
比方说写个寒树

09:02.630 --> 09:03.630
那你得问啊

09:03.630 --> 09:04.350
兄弟

09:04.350 --> 09:05.270
你得问我呀

09:05.270 --> 09:06.590
你得把问题给我呀

09:06.590 --> 09:07.430
你不给我问题

09:07.430 --> 09:09.030
我怎么回答呢

09:09.070 --> 09:10.790
所以说参数是什么意思

09:10.790 --> 09:13.030
参数就是

09:13.030 --> 09:14.590
呃

09:14.590 --> 09:15.430
那个

09:15.430 --> 09:16.990
你要做这件事

09:16.990 --> 09:19.270
他所需要的必要的信息

09:19.270 --> 09:22.470
不然的话你没法做这个事啊

09:22.470 --> 09:24.350
再比如说你们玩的手机

09:24.350 --> 09:26.750
手机上你把音量调大一点

09:26.750 --> 09:27.630
啊

09:27.630 --> 09:29.670
亮度调大一点

09:29.670 --> 09:30.670
手机怎么能帮你调

09:30.670 --> 09:31.510
可以帮你调

09:31.510 --> 09:33.630
你把手机抢上成一个寒树吗

09:33.630 --> 09:35.710
但是你得告诉他调量到多少是吧

09:35.710 --> 09:37.430
你得用手划一下

09:37.470 --> 09:39.190
调量到80 90

09:39.190 --> 09:41.470
声音调量50 60

09:41.470 --> 09:42.830
那不就是参数吗

09:42.830 --> 09:44.230
你得把一些信息告诉他

09:44.230 --> 09:45.710
不然他怎么帮你调呢

09:45.710 --> 09:47.070
这就是参数

09:47.070 --> 09:47.670
懂了意思吧

09:47.670 --> 09:50.390
参数表示你要接下来要做这件事

09:50.390 --> 09:54.430
你需要的一些必要的信息就是参数

09:54.430 --> 09:56.070
参数呢可以没有

09:56.070 --> 09:57.190
也可以有一个

09:57.190 --> 09:58.470
也可以有多个

09:58.470 --> 10:02.590
那么关键取决于你要做什么事

10:02.590 --> 10:04.510
好比方说哈

10:04.510 --> 10:07.390
我们刚才写了一个上寒数对吧

10:07.430 --> 10:08.670
这个求和

10:08.670 --> 10:10.590
好那我们这里是两个数求和

10:10.590 --> 10:11.750
是不是要给两个参数

10:11.750 --> 10:12.790
那三个数求和呢

10:12.790 --> 10:14.630
是不是要给我三个参数

10:14.630 --> 10:15.950
对不对

10:15.950 --> 10:16.350
好

10:16.350 --> 10:18.310
那如果说我这个函数的意思

10:18.310 --> 10:19.070
就是我要做的事

10:19.070 --> 10:20.430
不是说两个数求和

10:20.430 --> 10:22.790
我是要把一加三求和

10:22.790 --> 10:23.950
那你给我参数吗

10:23.950 --> 10:25.310
你不给我参数就行了

10:25.310 --> 10:27.870
因为我知道就是把一加上三

10:27.870 --> 10:28.070
对吧

10:28.070 --> 10:29.790
他就不需要参数了

10:29.790 --> 10:32.750
所以说参数他到底有多少

10:32.750 --> 10:35.270
完全取决于你要做这件事

10:35.270 --> 10:36.950
到底要做啥

10:36.990 --> 10:39.470
因为不同的还是就是不同的流程

10:39.470 --> 10:41.350
不同的流程做不同的事

10:41.350 --> 10:43.470
你做的事不一样

10:43.470 --> 10:45.990
那就是参数肯定不一样

10:45.990 --> 10:47.390
参数呢我们就是说

10:47.390 --> 10:48.630
未知的信息

10:48.630 --> 10:49.430
我要做这件事

10:49.430 --> 10:51.630
有些未知的东西要告诉我

10:51.630 --> 10:53.990
这要参数

10:53.990 --> 10:56.030
那什么叫反回之呢

10:56.030 --> 10:59.230
反回之就是这件事做的完了之后的结果

10:59.230 --> 11:00.670
我要告诉你一个结果

11:00.670 --> 11:01.990
比方两个数求和

11:01.990 --> 11:03.550
那求和的结果是什么

11:03.550 --> 11:04.510
我要通过一个履剧

11:05.470 --> 11:06.990
把这个反回出来

11:06.990 --> 11:08.670
就是这件事反回的结果

11:08.670 --> 11:09.870
也就是说

11:09.870 --> 11:11.830
我就像一台生产线一样

11:11.830 --> 11:12.830
大家有没有感觉

11:12.830 --> 11:13.790
一个生产线

11:13.790 --> 11:15.870
我把信息传过来了

11:15.870 --> 11:17.870
然后经过框枪

11:17.870 --> 11:20.790
中间一串流程就生成了一个结果

11:20.790 --> 11:21.630
结果拿去

11:21.630 --> 11:23.150
你要把这个结果拿去干嘛

11:23.150 --> 11:24.030
用随便你

11:24.030 --> 11:25.830
反正我就把结果给你的

11:25.830 --> 11:28.310
这就是反回之

11:28.310 --> 11:30.870
那么到底一个函数有没有反回之呢

11:31.030 --> 11:35.190
它也要取决于函数的作用

11:35.190 --> 11:36.670
它到底要做啥

11:36.670 --> 11:38.630
比方说我们这个求和函数

11:38.630 --> 11:40.510
我现在有反回之对吧

11:40.510 --> 11:42.390
那如果说我这个函数的意思就是

11:42.390 --> 11:44.590
求和之后输出

11:44.590 --> 11:45.630
那需要反回之吗

11:45.630 --> 11:46.470
你不需要反回之

11:46.470 --> 11:48.230
那我就直接输出了

11:48.230 --> 11:50.350
我就直接输出了

11:50.350 --> 11:53.070
那关键是这个函数的函意是什么

11:53.070 --> 11:54.750
它函意是我要得到一个结果

11:54.750 --> 11:56.270
那就要做一个反回之

11:56.270 --> 11:57.310
那如果说函意是

11:57.310 --> 11:58.030
我不得要结果

11:58.030 --> 11:59.790
我就是把个结果输出就完事了

11:59.830 --> 12:01.910
那就不需要反回之

12:01.910 --> 12:03.590
就好必须说一个自动化流程

12:03.590 --> 12:05.350
比方说你家里边有个手机进行人

12:05.350 --> 12:06.950
他扫完了自己回去了

12:06.950 --> 12:08.230
他不需要告诉你什么

12:08.230 --> 12:09.830
他什么都不需要告诉你

12:09.830 --> 12:11.230
他就直接回去了

12:11.230 --> 12:12.670
就完事了

12:12.670 --> 12:15.910
这就是反回之

12:15.910 --> 12:17.590
那么函数体的就很简单了

12:17.590 --> 12:19.310
就是你给了我参数

12:19.310 --> 12:20.710
然后我就狂猖狂猖

12:20.710 --> 12:21.990
一个自动的生产线

12:21.990 --> 12:23.190
就把一个流程走一遍

12:23.190 --> 12:25.070
然后产生一个反回结果给你

12:25.070 --> 12:25.750
给你反回

12:25.750 --> 12:26.950
你挨怎么用

12:26.950 --> 12:28.910
怎么用

12:29.470 --> 12:31.550
这就是函数的这三个信息

12:31.550 --> 12:33.270
参数反回之和函数体

12:33.270 --> 12:34.230
那么这里有一句话

12:34.230 --> 12:35.750
大家特别重要

12:35.750 --> 12:37.950
函数的参数反回之

12:37.950 --> 12:41.350
它只取决于函数的作用

12:41.350 --> 12:43.510
与函数体无关

12:43.510 --> 12:44.390
一定要知道

12:44.390 --> 12:47.150
它与函数体是没有关系的

12:47.150 --> 12:48.510
那怎么理解了

12:48.510 --> 12:49.870
那里怎么理解了

12:49.870 --> 12:52.710
比方说我有个球盒函数

12:52.710 --> 12:53.550
放个心

12:53.550 --> 12:55.470
有个球盒

12:55.470 --> 12:57.150
这个函数的作用就是

12:57.150 --> 12:58.630
这个函数的作用是什么

12:58.710 --> 13:01.470
把A和B的核

13:01.470 --> 13:02.270
得到一个结果

13:02.270 --> 13:04.590
得到A和B的结果

13:04.590 --> 13:05.710
对不对

13:05.710 --> 13:07.590
这就是函数的作用

13:07.590 --> 13:10.910
那么至于你里边咋写无所谓

13:10.910 --> 13:12.310
是不是现在参数已经知道了

13:12.310 --> 13:13.030
有两个参数

13:13.030 --> 13:13.710
对吧

13:13.710 --> 13:15.230
比方说这个函数

13:15.230 --> 13:17.350
我知道它是对两个数球盒

13:17.350 --> 13:18.270
然后得到一个结果

13:18.270 --> 13:19.510
那我们参数是不是明确了

13:19.510 --> 13:22.110
就两个参数

13:22.110 --> 13:23.310
那反而回直是不是明确了

13:23.310 --> 13:25.830
反而回直就是这两个数的核

13:25.830 --> 13:27.550
至于它里边怎么

13:27.590 --> 13:29.190
那个自动化生产线

13:29.190 --> 13:30.390
那个流程怎么走

13:30.390 --> 13:32.390
属于一边里怎么走

13:32.390 --> 13:33.310
我们之前是不是写过

13:33.310 --> 13:35.150
这么一个完美球盒函数

13:35.150 --> 13:35.430
对吧

13:35.430 --> 13:36.590
你可以是完美的球盒

13:36.590 --> 13:38.390
可以判断它各种类型

13:38.390 --> 13:39.390
然后做转换

13:39.390 --> 13:40.430
也可以不完美

13:40.430 --> 13:41.310
直接A加B

13:41.310 --> 13:42.150
也可以呢

13:45.150 --> 13:46.070
什么了

13:46.070 --> 13:47.590
球盒还能做啥

13:47.590 --> 13:49.830
也玩不出什么新花样了

13:49.830 --> 13:51.070
球盒比较简单

13:51.070 --> 13:52.230
反正就是中间的流程

13:52.230 --> 13:53.670
无论你怎么去实现

13:53.670 --> 13:53.990
无所谓

13:53.990 --> 13:56.710
你只要满足这个含义就行了

13:56.750 --> 13:58.110
动力是吧

13:58.110 --> 13:59.350
就这个意思

13:59.350 --> 14:01.350
跟那个含书体没有关系

14:01.350 --> 14:03.630
就好比说你用家里边的家用电器

14:03.630 --> 14:05.550
你用家里边冰箱微波炉

14:05.550 --> 14:07.390
找机器人洗衣机

14:07.390 --> 14:08.470
电饭宝

14:08.470 --> 14:09.430
你需要把它拆开

14:09.430 --> 14:10.990
看里边的线路构成了

14:10.990 --> 14:12.310
不需要吧

14:12.310 --> 14:13.710
你只需要知道

14:13.710 --> 14:14.710
你只需要知道

14:14.710 --> 14:15.710
它怎么用就行了

14:15.710 --> 14:15.910
对吧

14:15.910 --> 14:17.790
我要给它输入哪些参数

14:17.790 --> 14:18.430
比较电饭宝

14:18.430 --> 14:19.430
你要调个时间

14:19.430 --> 14:20.310
这就是参数

14:20.310 --> 14:21.590
它才能工作

14:21.590 --> 14:23.110
调个内型的

14:23.110 --> 14:24.470
你是煮饭

14:24.470 --> 14:26.510
还是包轴之类的

14:26.550 --> 14:27.790
你是不是要给它一些参数

14:27.790 --> 14:28.710
然后它就可以工作了

14:28.710 --> 14:29.070
工作了

14:29.070 --> 14:31.550
然后给人的结果就是重新的饭

14:31.550 --> 14:32.950
至于中间怎么走

14:32.950 --> 14:34.430
每个电饭宝是不是不一样

14:34.430 --> 14:35.510
不同品牌的

14:35.510 --> 14:36.350
不同价位的

14:36.350 --> 14:37.150
是不是都不一样

14:37.150 --> 14:38.870
整个中间的过程是不一样的

14:38.870 --> 14:40.070
那无所谓

14:40.070 --> 14:40.390
那无所谓

14:40.390 --> 14:41.510
反正也给我一个结果

14:41.510 --> 14:42.630
我只认这个结果好

14:42.630 --> 14:43.670
还是不好就完事了

14:45.470 --> 14:47.230
所以说参数是什么

14:47.230 --> 14:48.350
返回值是什么

14:48.350 --> 14:49.630
只取决于含书的作用

14:49.630 --> 14:51.110
你是个电饭宝

14:51.110 --> 14:54.110
你就应该能够调时间调内型

14:54.110 --> 14:54.990
对吧

14:54.990 --> 14:55.510
你返回值

14:55.510 --> 14:58.430
就是应该得到一个烹饪的结果

14:58.430 --> 15:00.390
至于这么过程跟我什么关系

15:01.710 --> 15:04.070
这就是这个点

15:04.070 --> 15:05.390
什么叫参数返回值

15:05.390 --> 15:06.510
含书题

15:06.510 --> 15:07.070
好

15:07.070 --> 15:08.350
有些同学有这么一个问题

15:08.350 --> 15:09.630
就说我为什么

15:09.630 --> 15:12.110
李伯原老师说学了含书之后

15:12.110 --> 15:13.750
同学们之前应该接触我含书

15:13.750 --> 15:15.510
前面看了诚哥的课程

15:15.510 --> 15:17.390
本来是一个含书

15:17.390 --> 15:18.430
每个这个含书的时候

15:18.430 --> 15:19.990
我还开开心心的

15:19.990 --> 15:20.590
对吧

15:20.590 --> 15:21.390
不梦跳跳的

15:21.390 --> 15:22.550
之前的护循环

15:22.550 --> 15:24.830
循环有点坑坑

15:24.910 --> 15:26.230
有点坑

15:26.230 --> 15:26.950
有点难度

15:26.950 --> 15:28.790
但是我也过去了

15:28.790 --> 15:29.910
到含书这儿

15:29.910 --> 15:31.910
明明说含书是为了简化程序的

15:31.910 --> 15:32.790
我怎么感觉不到

15:32.790 --> 15:35.110
我感觉程序变得复杂了

15:35.110 --> 15:39.470
这是一个还不少的同学有这样的一个问题

15:39.470 --> 15:40.790
是这样子

15:40.790 --> 15:42.070
含书是用来做什么

15:42.070 --> 15:43.630
是用来切割流程的

15:43.630 --> 15:44.190
对吧

15:44.190 --> 15:46.830
它是让某一段复杂的流程变得简单

15:46.830 --> 15:47.790
你看这个复杂流程

15:47.790 --> 15:49.910
左边那个复杂流程是不是变得简单了

15:49.910 --> 15:50.150
对吧

15:50.150 --> 15:51.150
整个右边那个是简单的

15:51.150 --> 15:53.430
从图就可以看得出变得简单了

15:53.430 --> 15:55.670
但为什么同学还不会变得复杂呢

15:55.670 --> 15:57.710
极有可能的原因

15:58.710 --> 16:00.670
是你的程序变简单了

16:00.670 --> 16:02.830
但是你的思想变复杂了

16:02.830 --> 16:04.310
思想复杂变重了

16:05.310 --> 16:05.990
为什么呢

16:05.990 --> 16:08.990
我给你演示一下同学们是怎么想的

16:10.870 --> 16:12.510
我在这里调用含书

16:12.990 --> 16:14.350
同学们老大就在想

16:14.350 --> 16:18.590
我在调用含书的时候

16:18.590 --> 16:20.910
它会先经过这个步骤

16:20.950 --> 16:22.350
再经过这个步骤

16:22.350 --> 16:23.870
再经过这个步骤

16:23.870 --> 16:25.230
然后又到下面这个

16:25.230 --> 16:26.310
又到下面这个

16:26.310 --> 16:27.750
好这里又诗一次含书

16:27.750 --> 16:29.390
它又会经过这个步骤

16:29.390 --> 16:30.710
又会经过这个步骤

16:30.710 --> 16:31.990
又会经过这个步骤

16:33.350 --> 16:34.390
那完了

16:34.390 --> 16:34.910
那完了呀

16:36.710 --> 16:37.870
图变得简单了没

16:37.870 --> 16:38.790
程序变简单了没

16:38.790 --> 16:39.750
简单了

16:39.750 --> 16:41.030
但你的思想还是没变

16:41.030 --> 16:42.550
你思想还是这个思想啊

16:42.550 --> 16:44.150
你是思想

16:44.150 --> 16:45.790
一想法说还是个想法

16:45.790 --> 16:47.270
你还是把整个流程全部

16:47.270 --> 16:48.230
你的头脑里边是不是

16:48.230 --> 16:49.750
还是把整个流程走了一遍

16:49.790 --> 16:51.990
而且既然你把整个流程走了一遍

16:51.990 --> 16:53.870
你的思想负担还是错

16:53.870 --> 16:55.710
而且你再走这个流程过程中

16:55.710 --> 16:57.510
还由于有含书调用

16:57.510 --> 16:59.750
你还在想这个含书的参数传递

16:59.750 --> 17:01.110
返回结果

17:01.110 --> 17:02.150
对吧

17:02.150 --> 17:03.270
你还在想这个问题

17:03.270 --> 17:04.030
所以说实际上

17:04.030 --> 17:05.670
思想负担反而变重了

17:07.310 --> 17:08.230
还有一个什么情况

17:08.230 --> 17:10.310
就是你在写这个含书的时候

17:10.310 --> 17:11.830
我本来这个流程

17:11.830 --> 17:13.190
这个含书里边的流程很简单

17:13.190 --> 17:13.670
就三步

17:13.670 --> 17:14.110
对吧

17:14.110 --> 17:15.150
这个这个这个

17:15.150 --> 17:16.710
但是同学们想的可不知

17:16.710 --> 17:17.750
不是这样想的

17:17.750 --> 17:19.150
同学们想的是这样子

17:19.590 --> 17:21.270
我写这个含书的时候

17:21.270 --> 17:23.670
它应该是先进行这个

17:23.670 --> 17:24.470
然后到这儿

17:24.470 --> 17:25.790
然后再进行这个

17:25.790 --> 17:26.750
然后再进行这个

17:26.750 --> 17:27.550
再进行这个

17:27.550 --> 17:28.510
这个完了之后

17:28.510 --> 17:29.510
后边还有

17:29.510 --> 17:30.190
进行这个

17:30.190 --> 17:30.990
进行这个

17:30.990 --> 17:32.630
然后再来进行这个

17:32.630 --> 17:33.990
你又把这个流程走了一遍

17:36.470 --> 17:37.390
你写含书的时候

17:37.390 --> 17:38.550
你把这个流程走了一遍

17:38.550 --> 17:39.430
你调用含书的时候

17:39.430 --> 17:41.030
又把整个流程走了一遍

17:41.030 --> 17:42.990
那你负担中才乖了

17:42.990 --> 17:43.990
你肯定负担中了

17:45.190 --> 17:47.190
所以说你不能这样子玩

17:47.190 --> 17:48.390
我们写含书的目的

17:48.390 --> 17:50.230
就是不要让你这样子玩了

17:50.230 --> 17:52.430
所以说记住下面两点

17:52.430 --> 17:54.150
定义含书的时候

17:54.150 --> 17:55.350
就是声明含书的时候

17:57.030 --> 18:00.350
只需要考虑这个含书如何实现即可

18:00.350 --> 18:03.270
完全不需要考虑其他无关的东西

18:03.270 --> 18:04.470
完全不考虑

18:04.470 --> 18:05.990
就你在写这个含书的时候

18:05.990 --> 18:08.110
想都不要去想这些东西

18:08.110 --> 18:09.350
它在哪里雕拥啊

18:09.350 --> 18:10.070
跟你有啥关系

18:11.030 --> 18:12.030
有啥关系

18:12.030 --> 18:14.950
你只需要去想这个含书在做什么例子

18:14.950 --> 18:16.630
你这个是一个求和含书

18:16.670 --> 18:18.270
你就把求和搞定就行了

18:19.190 --> 18:20.110
你不要去想其他的

18:21.150 --> 18:22.030
你就想第一步

18:22.030 --> 18:23.550
你要求和

18:23.550 --> 18:24.470
你第一步要做啥

18:24.470 --> 18:25.150
第二步要做啥

18:25.150 --> 18:25.910
第三步要做啥

18:27.110 --> 18:28.590
你要求阶层

18:28.590 --> 18:29.310
第一步要做啥

18:29.310 --> 18:29.950
第二步做啥

18:29.950 --> 18:31.190
第三步做啥

18:31.190 --> 18:32.350
你就想这里就行了

18:32.350 --> 18:33.990
跟其他的没关系

18:33.990 --> 18:35.430
你这个调调切割嘛

18:35.430 --> 18:36.710
不然的话你程序切割了

18:36.710 --> 18:38.390
你思想没有切割

18:38.390 --> 18:39.270
你思想没有切割

18:39.270 --> 18:40.350
那肯定复杂

18:40.350 --> 18:41.510
你思想还是负担中

18:44.210 --> 18:46.050
那么你在这是含书声明

18:46.050 --> 18:47.970
另外在含书调用的时候

18:48.330 --> 18:50.290
你完全不要去考虑这个

18:51.610 --> 18:54.490
比方说我在这要求一个两个数之和

18:54.490 --> 18:57.290
我去调用含书得到一个结果就完事了

18:57.290 --> 18:58.530
我完全不用去考虑

18:58.530 --> 19:00.250
它里边又是咋写的

19:00.250 --> 19:00.970
跟你有啥关系

19:02.130 --> 19:03.450
你不考虑含书里边咋写

19:03.450 --> 19:04.650
你写不了含书了嘛

19:04.650 --> 19:05.690
那我同学们问你

19:06.530 --> 19:08.650
你天天都要用一个含书叫

19:08.650 --> 19:09.330
Consologue

19:09.330 --> 19:10.130
这是不是含书

19:10.130 --> 19:10.730
这是含书

19:11.730 --> 19:12.050
对吧

19:13.170 --> 19:14.010
这就是一个含书

19:15.450 --> 19:16.330
那么这个含书

19:16.330 --> 19:17.970
你知不知道它里边咋写的

19:18.330 --> 19:19.250
你知不知道它里边咋写的

19:19.250 --> 19:21.250
怎么把这个输出到屏幕上的

19:21.250 --> 19:23.210
怎么把它输出到留言器控制台的

19:23.210 --> 19:24.770
你知道这里边的过程有多复杂吗

19:25.610 --> 19:26.850
你不要觉得理所当然

19:26.850 --> 19:28.090
就输出个控制台有多复杂

19:29.450 --> 19:30.890
你去看一下背包引擎

19:30.890 --> 19:32.690
要去打印在屏幕上做打印

19:32.690 --> 19:33.890
你不要设计到多少东西

19:35.410 --> 19:36.930
那你不知道它里边咋实现的

19:36.930 --> 19:37.690
你能写这个

19:37.690 --> 19:38.450
你能调用

19:38.450 --> 19:39.690
这就是含书调用嘛

19:39.690 --> 19:40.530
你能调用它吗

19:40.530 --> 19:42.210
你不天天调用你调用都很happy嘛

19:42.890 --> 19:45.770
所以说你调用含书的时候

19:45.770 --> 19:46.970
完全不用去考虑

19:46.970 --> 19:48.490
含书里边是咋写的

19:49.210 --> 19:50.330
你生命的时候

19:50.330 --> 19:52.330
完全不用考虑外边是咋用的

19:53.330 --> 19:53.850
懂不懂意思吗

19:53.850 --> 19:55.450
你只需要写含书的时候

19:55.450 --> 19:56.610
就考虑含书自己

19:56.610 --> 19:57.570
调用了含书的时候

19:57.570 --> 19:58.410
完全不会考虑含书

19:58.410 --> 19:59.450
具体咋实现的

19:59.450 --> 20:00.690
你只需要知道这个含书

20:00.690 --> 20:02.250
用是什么用处就行了

20:03.090 --> 20:04.410
一定要它就用处就来了

20:04.410 --> 20:05.090
得到结果了

20:06.250 --> 20:07.690
这样子才能达到

20:07.690 --> 20:09.330
就是你程序切割出去过后

20:09.330 --> 20:10.850
你思想也要做切割

20:11.330 --> 20:13.130
以前倒是一个单线层的思想

20:13.130 --> 20:13.570
对吧

20:13.570 --> 20:15.850
就是我一条道走到黑

20:15.970 --> 20:17.010
从那走到尾

20:17.010 --> 20:18.170
那现在有了含书之后

20:18.170 --> 20:19.530
也要把思想分成多块

20:19.530 --> 20:21.570
含书这是一块单独的

20:22.250 --> 20:23.490
切割出去的

20:23.490 --> 20:24.410
然后使用的时候

20:24.410 --> 20:25.690
就调用一下就完事了

20:25.690 --> 20:26.730
就能得到结果了

20:27.450 --> 20:28.970
所以说这个这件事

20:28.970 --> 20:30.290
我会反复反复的强调

20:30.290 --> 20:31.730
跟那个什么表达师

20:31.730 --> 20:33.730
跟那个佛循环一样

20:33.730 --> 20:35.130
反复的强调这一点

20:35.930 --> 20:37.730
所以这样子才能减轻思想不淡

20:37.730 --> 20:39.330
才能觉得有了含书

20:39.330 --> 20:40.690
确实程序变简单

20:42.370 --> 20:43.770
这里我给大家说三个东西

20:43.770 --> 20:45.770
一个东西叫三要素

20:46.490 --> 20:47.770
就是含书里边有三要素

20:47.770 --> 20:49.730
叫做含书名参数

20:49.730 --> 20:50.570
反回值注意

20:50.570 --> 20:52.450
这三要素里边是没有含书体的

20:52.450 --> 20:54.410
含书体有些同学觉得很重要

20:54.410 --> 20:56.090
其实含书体是最不重要的

20:57.330 --> 20:58.330
含书体是什么

20:58.330 --> 20:59.770
就里边的流程

20:59.770 --> 21:01.650
里边流程实现方式有很多种

21:01.650 --> 21:02.490
随便怎么实现

21:02.490 --> 21:03.530
它总会是能实现的

21:03.530 --> 21:03.890
对吧

21:03.890 --> 21:05.930
只剩了大家目前的初学者

21:05.930 --> 21:07.410
在刚刚开始学程序的时候

21:07.410 --> 21:08.250
觉得含书体重要

21:08.250 --> 21:09.450
因为这里边有代码

21:10.250 --> 21:11.850
实际上你开发程序

21:11.850 --> 21:12.570
开发到一定程度

21:12.570 --> 21:13.770
比方工作了三五年之后

21:13.770 --> 21:15.050
你觉得这个含书体

21:15.130 --> 21:16.010
越来越不重要了

21:16.010 --> 21:16.490
对吧

21:16.490 --> 21:17.170
张三能写

21:17.170 --> 21:17.850
你是能写

21:17.850 --> 21:19.210
一个实习生也能写

21:19.210 --> 21:19.890
大家都能写

21:19.890 --> 21:20.770
有什么好重要的

21:22.090 --> 21:23.130
这是含书的三要素

21:23.130 --> 21:24.290
是不包含含书体的

21:25.650 --> 21:27.210
这个三要素有什么用

21:27.210 --> 21:28.650
只要具备三要素

21:28.650 --> 21:29.730
就能输写含书体

21:30.850 --> 21:32.970
我只要把三要素给定义出来了

21:32.970 --> 21:34.770
就是含书的名字是什么

21:34.770 --> 21:35.810
参数是什么

21:35.810 --> 21:37.050
反回值是什么

21:37.930 --> 21:38.770
我给定义出来了

21:38.770 --> 21:40.410
比方一个求和含书

21:40.410 --> 21:41.330
这个求和含书告诉你

21:41.330 --> 21:42.490
名字是求和

21:42.490 --> 21:43.290
名字表示什么意思

21:43.290 --> 21:44.810
就是含书的含义

21:44.850 --> 21:46.130
有的时候会导散一个宿舍

21:46.130 --> 21:47.890
把这个含书要做什么事情

21:47.890 --> 21:48.890
参数告诉你

21:48.890 --> 21:50.450
我要给你提供哪些东西

21:51.250 --> 21:52.210
反回值告诉你

21:52.210 --> 21:54.210
你应该给我反回什么东西

21:54.210 --> 21:55.970
含书体是不是就能写了

21:55.970 --> 21:56.890
逻辑就通了

21:57.890 --> 21:59.370
就没有任何缺少的条件了

21:59.370 --> 22:01.530
是不是就完全可以写这个含书体了

22:01.530 --> 22:02.810
只是每个人实现的过程

22:02.810 --> 22:03.850
可能不一样而已

22:03.850 --> 22:04.930
有的含书可能复杂

22:04.930 --> 22:05.530
有的含书简单

22:05.530 --> 22:06.690
但是肯定能写了

22:06.690 --> 22:07.010
对吧

22:08.850 --> 22:10.410
然后有了三要素之后

22:10.410 --> 22:12.890
你就能完成含书调用了

22:12.890 --> 22:14.210
我现在含书体写都没写

22:14.210 --> 22:15.410
但是我知道有这么一个含书

22:15.410 --> 22:16.810
将来肯定把含书体完成

22:16.810 --> 22:18.290
我是不是就能调用它了

22:18.290 --> 22:19.250
我给它传一个三

22:19.250 --> 22:20.410
传一个五

22:20.410 --> 22:21.730
你看这样传递过去了

22:21.730 --> 22:23.930
十三传递到刑餐

22:23.930 --> 22:25.610
十三传递到刑餐

22:25.610 --> 22:25.770
对吧

22:25.770 --> 22:27.410
它就运行运行会返回一个

22:27.410 --> 22:29.250
这个表达是它的返回结果

22:29.250 --> 22:31.090
就是含书的返回结果

22:31.090 --> 22:31.290
对吧

22:31.290 --> 22:31.810
我就知道了

22:31.810 --> 22:33.850
这个就是求贺结果

22:33.850 --> 22:34.770
是不是就可以调用了

22:34.770 --> 22:36.770
我完全不用知道它里边是咋写的

22:36.770 --> 22:37.370
比方说

22:37.370 --> 22:38.370
像我们刚才举的例子

22:38.370 --> 22:40.410
console log

22:40.410 --> 22:42.170
这是一个含书吧

22:42.170 --> 22:43.130
这个含书告诉你了

22:43.170 --> 22:44.490
它的名字叫log

22:44.490 --> 22:45.690
它放在一个对象里面

22:45.690 --> 22:47.490
它的名字叫log

22:47.490 --> 22:48.890
它里边有一个参数

22:48.890 --> 22:50.930
这个参数你传啥都可以

22:50.930 --> 22:54.130
它的作用是把它打印到控制台

22:54.130 --> 22:56.050
这个含书是不是就可以调用了

22:56.050 --> 22:57.410
你知不知道它里边打写的

22:57.410 --> 22:58.130
不知道了

22:58.130 --> 23:00.530
不知道我还是可以调用它

23:00.530 --> 23:00.770
对不对

23:00.770 --> 23:02.130
就是这么一个逻辑

23:02.130 --> 23:03.930
含书的三要数

23:03.930 --> 23:05.410
这个问题就解答了

23:05.410 --> 23:06.690
为什么变复杂了

23:06.690 --> 23:08.290
你只需要抓住含书的三要数

23:08.290 --> 23:09.410
调用含书的时候

23:09.410 --> 23:11.530
只需要知道含书的三要数

23:11.570 --> 23:13.050
又可以无障碍地使用含书

23:13.050 --> 23:14.450
你完全不需要知道

23:14.450 --> 23:15.850
这个含书里边打写的

23:15.850 --> 23:17.970
你之前是你自己写的

23:17.970 --> 23:19.930
也有可能是你同事写的

23:19.930 --> 23:21.810
也有可能是系统直接给你提供的

23:21.810 --> 23:23.610
像console log

23:23.610 --> 23:24.290
无所谓的

23:24.290 --> 23:25.490
管它是谁写的

23:25.490 --> 23:26.890
你自己写的你就忘记它

23:26.890 --> 23:28.330
反正就写完了

23:28.330 --> 23:29.450
这个含书可以用了

23:29.450 --> 23:30.170
除了问题

23:30.170 --> 23:30.530
除了问题

23:30.530 --> 23:31.770
没在调吗

23:31.770 --> 23:32.650
没出问题之前

23:32.650 --> 23:33.130
无所谓的

23:33.130 --> 23:34.090
就这样的弄

23:35.370 --> 23:37.810
你写它写写这个含书的时候

23:37.810 --> 23:39.170
你只需要思考

23:39.170 --> 23:40.770
这个含书

23:40.810 --> 23:41.650
三要数

23:41.650 --> 23:42.930
它的名字是什么

23:42.930 --> 23:44.050
含义是什么

23:44.050 --> 23:44.690
就名字是什么

23:44.690 --> 23:45.850
就不要表示含义

23:45.850 --> 23:46.610
有哪些参数

23:46.610 --> 23:47.730
我应该给它返回什么

23:47.730 --> 23:49.050
这个含书体就能写了

23:49.050 --> 23:50.690
你完全不用去考虑外边的东西

23:50.690 --> 23:53.130
这样子你的思想负担一下就减薪了

23:53.130 --> 23:54.770
这是第二个问题

23:54.770 --> 23:56.290
第三个问题

23:56.290 --> 23:58.530
这个是学的含书

23:58.530 --> 23:59.530
应该有些同学

23:59.530 --> 24:00.810
部分同学有这个问题

24:00.810 --> 24:01.730
你有这个问题

24:01.730 --> 24:04.370
其实你已经到了一个

24:04.370 --> 24:06.330
相对比较高阶的位置了

24:06.330 --> 24:07.650
你在思考这个问题

24:07.650 --> 24:08.610
就学含书的时候

24:08.690 --> 24:11.330
我不知道该怎么去切割流程

24:11.330 --> 24:13.210
就是现在我给了一套流程

24:13.210 --> 24:15.410
这个套流程你现在还没开始写代码

24:15.410 --> 24:16.490
但是你隐隐约约

24:16.490 --> 24:20.050
知道这个流程里边有一些重复的东西

24:20.050 --> 24:21.010
有一些负担的东西

24:21.010 --> 24:23.010
我需要提成含书

24:23.010 --> 24:25.570
我怎么事先知道

24:25.570 --> 24:27.130
因为你还没有写这个代码

24:27.130 --> 24:27.930
我怎么去实现

24:27.930 --> 24:28.730
你要全部写出来

24:28.730 --> 24:31.290
当然我就容易看出来了

24:31.290 --> 24:32.210
但是你没写之前

24:32.210 --> 24:35.170
我怎么知道有哪些含书要提取

24:35.170 --> 24:36.490
我这里只提了一个

24:36.490 --> 24:39.210
其实有很多含书要提取

24:39.210 --> 24:40.090
这是这样子

24:40.090 --> 24:41.690
我们要提取含书

24:41.690 --> 24:42.930
一般分为两步

24:42.930 --> 24:44.810
第一步设计含书

24:44.810 --> 24:46.010
就是说了这个意思

24:46.010 --> 24:47.090
设计含书就是

24:47.090 --> 24:48.930
我应该有哪些含书

24:48.930 --> 24:50.690
每个含书的作用是什么

24:50.690 --> 24:52.730
也就是每个含书的三要数是什么

24:52.730 --> 24:53.970
因为只要三要数一出来

24:53.970 --> 24:55.530
是不是啥都出来了

24:55.530 --> 24:57.330
剩下的具体实现那无所谓

24:57.330 --> 24:58.170
随便打实现

24:58.170 --> 24:59.890
反正能实现就

24:59.890 --> 25:02.410
关键是设计

25:02.410 --> 25:04.730
设计含书是最难的

25:04.730 --> 25:05.850
这一步是最难的

25:05.890 --> 25:07.770
就是设计出含书的三要数

25:07.770 --> 25:09.770
目前无需同学们掌握

25:09.770 --> 25:12.970
你们目前要去强行掌握这个东西

25:12.970 --> 25:15.210
那不太可能

25:15.210 --> 25:16.330
不太可能

25:16.330 --> 25:19.250
你要这个事情的一般来说

25:19.250 --> 25:21.010
你要什么时候能够

25:21.010 --> 25:22.530
自如非常非常自如

25:22.530 --> 25:23.690
就对大部分同学而言

25:23.690 --> 25:24.850
对一些兼职

25:24.850 --> 25:27.330
就是兼职生的力量别论

25:27.330 --> 25:28.450
对大部分同学而言

25:28.450 --> 25:32.130
一般要工作隔一到三年之后

25:32.130 --> 25:33.090
不影响你工作

25:33.090 --> 25:34.130
工作可以工作

25:34.130 --> 25:35.570
因为后边我们学了框架之后

25:35.570 --> 25:37.850
基本上流程都是固定的

25:37.850 --> 25:39.170
基本上都相对固定的

25:39.170 --> 25:42.130
就没有那么需要你去灵活提取

25:42.130 --> 25:42.530
含书

25:42.530 --> 25:43.810
灵活设计含书的地方

25:43.810 --> 25:45.570
很伤很伤

25:45.570 --> 25:46.970
但是这个东西是有用的

25:46.970 --> 25:47.970
是绝对有用的

25:47.970 --> 25:49.490
比方说你以后到公司里面

25:49.490 --> 25:50.730
要去做一些高阶的东西

25:50.730 --> 25:54.610
比方说一些编写一些公共代码

25:54.610 --> 25:56.530
做一些公共的含书

25:56.530 --> 25:59.130
写一些框架之类的事情

25:59.130 --> 26:01.050
这个就不能尤其重要

26:01.050 --> 26:05.130
但是现阶段不太可能

26:05.850 --> 26:09.250
这个事情的现阶段你只能多看优质的代码

26:09.250 --> 26:10.370
比方老师是怎么写的

26:10.370 --> 26:10.570
对吧

26:10.570 --> 26:12.450
慢慢形成一点点感觉

26:12.450 --> 26:14.530
这个东西不是从零到一百

26:14.530 --> 26:16.450
不是从只有零和一

26:16.450 --> 26:17.770
是零到一百分

26:17.770 --> 26:19.530
比方说你今天是零分

26:19.530 --> 26:20.770
设计含书你完全搞不定

26:20.770 --> 26:23.090
必须要老师来帮你设计好

26:23.090 --> 26:25.170
这是肯定的

26:25.170 --> 26:27.290
慢慢这样会有点感觉

26:27.290 --> 26:28.850
变成五分了

26:28.850 --> 26:29.650
十分了

26:29.650 --> 26:31.290
慢慢变成二十分了

26:31.290 --> 26:32.290
三十分了

26:32.290 --> 26:32.930
五十分了

26:32.930 --> 26:34.050
工作了一年过后

26:34.050 --> 26:34.690
三年过后

26:34.690 --> 26:35.410
变六十分了

26:35.410 --> 26:36.210
七十分了

26:36.210 --> 26:37.770
这个时候

26:37.770 --> 26:40.570
你觉得我要不要去搞一个什么公共户

26:40.570 --> 26:42.250
框架

26:42.250 --> 26:45.170
来降低公司的开发成本

26:45.170 --> 26:47.010
那你可以继续想这些事

26:47.010 --> 26:48.570
现阶段太早

26:48.570 --> 26:49.090
太早

26:49.090 --> 26:50.010
测点事

26:50.010 --> 26:51.770
设计含书现在不用理管

26:51.770 --> 26:53.210
老师会帮你设计好

26:53.210 --> 26:55.130
多看老师的代码就可以了

26:55.130 --> 26:55.730
第二个

26:55.730 --> 26:56.930
你们现在要搞定的事情

26:56.930 --> 26:59.730
就是书写含书题

26:59.730 --> 27:02.090
就是三要数给你写出来了

27:02.090 --> 27:03.370
含书给你设计好了

27:03.410 --> 27:05.170
你把含书实现

27:05.170 --> 27:08.010
这一步是现阶段的终点

27:08.010 --> 27:09.370
好吧

27:09.370 --> 27:10.330
就解释清楚了

27:10.330 --> 27:11.690
关于含书这一块

27:11.690 --> 27:13.530
说了半天

27:13.530 --> 27:14.930
都是理论性质的

27:14.930 --> 27:15.170
好

27:15.170 --> 27:17.170
咱们来聊一聊

27:17.170 --> 27:21.710
实战

27:21.710 --> 27:21.910
好

27:21.910 --> 27:22.670
我们看一下

27:22.670 --> 27:25.390
今天就两道题

27:25.390 --> 27:26.710
你看现在第一道题

27:26.710 --> 27:29.190
完成下面的含书

27:29.190 --> 27:31.430
这个含书三要数是定出来了

27:31.430 --> 27:33.150
含书名字给你写出来了

27:33.150 --> 27:35.270
参数写出来了

27:35.470 --> 27:36.750
下面是含书的注释

27:36.750 --> 27:39.190
这个这种注释叫做文档注释

27:39.190 --> 27:40.830
这叫做文档注释

27:42.590 --> 27:44.270
什么叫文档注释

27:44.270 --> 27:47.110
就是一个鞋杠两个信号开头

27:47.110 --> 27:48.830
这个文档注释是怎么出来的

27:48.830 --> 27:50.150
一个鞋杠两个信号开头

27:50.150 --> 27:51.630
一回车它就出来了

27:51.630 --> 27:53.710
后边你们慢慢把它补权就行了

27:55.830 --> 27:57.390
那么这个文档注释有什么用呢

27:57.390 --> 27:58.790
其实它也是注释

27:58.790 --> 28:00.030
并没有什么别的特点

28:00.030 --> 28:01.230
也是注释

28:01.230 --> 28:03.550
它的好处在于你在调用这个含书的时候

28:03.590 --> 28:04.750
你看它是不是有提示

28:06.110 --> 28:06.990
是有提示

28:06.990 --> 28:08.710
你指着这个含书的时候是有提示

28:11.110 --> 28:12.870
这就是文档注释的好处

28:12.870 --> 28:13.630
因为有的时候

28:14.110 --> 28:16.190
我们以后会分成很多的纪念是文件

28:17.230 --> 28:19.630
那这个可能在别的文件里边

28:19.630 --> 28:22.350
你都不知道这个含书到底该怎么去传递参数

28:22.350 --> 28:23.630
得到得到的是什么东西

28:23.630 --> 28:24.390
可能就忘了

28:24.390 --> 28:26.470
那么指着这个含书就可以看到结果了

28:26.470 --> 28:27.710
你不需要去看

28:27.710 --> 28:29.910
有些同学他忘了这个含书

28:29.910 --> 28:30.910
怎么有什么作用

28:30.910 --> 28:32.590
他就跑去看这个含书体

28:32.750 --> 28:33.710
含书里边的实现

28:33.710 --> 28:35.150
那这里边可能有一百行代了

28:36.270 --> 28:38.070
拿着脑袋就看晕了

28:38.070 --> 28:39.830
就看这个文档注释就可以了

28:39.830 --> 28:42.110
就起到没个好处作用

28:42.110 --> 28:43.670
文档注释我简单说一下

28:43.670 --> 28:46.590
就是前面就是一个普通注释

28:46.590 --> 28:47.950
描述这个含书在做什么事

28:48.870 --> 28:50.630
下面就是描述参数的

28:51.670 --> 28:52.470
描述参数

28:52.470 --> 28:53.990
这个Pirons这个关键字

28:53.990 --> 28:55.310
表示我们描述一个参数

28:55.310 --> 28:56.430
参数的名字叫N

28:57.350 --> 28:59.510
它的内型是一个number

28:59.510 --> 29:00.750
它是一个数字

29:00.830 --> 29:01.790
到身体传的时候

29:01.790 --> 29:02.870
给我传一个数字

29:04.430 --> 29:07.950
然后它的含书是要求阶层的数

29:09.030 --> 29:10.670
后面的Aterythym

29:11.390 --> 29:12.950
表示含书的反回值

29:12.950 --> 29:15.830
反回的内型也是一个数字

29:16.590 --> 29:17.630
反回的什么意思呢

29:17.630 --> 29:18.590
表示阶层结果

29:18.590 --> 29:18.750
好

29:18.750 --> 29:20.110
咱们来越读一下这个含书

29:20.110 --> 29:21.630
这个含书就是求阶层

29:21.630 --> 29:23.510
得到某个数的阶层

29:23.510 --> 29:25.150
如果说这个数小于1

29:25.150 --> 29:26.270
那么就得到0

29:27.470 --> 29:28.430
得到哪个数的阶层

29:28.470 --> 29:29.350
就是这个参数

29:29.350 --> 29:30.990
要阶层的数

29:30.990 --> 29:32.230
哪个数要求阶层

29:32.230 --> 29:34.070
然后阶层结果是什么

29:34.070 --> 29:34.870
你给我反回

29:35.390 --> 29:35.590
好

29:35.590 --> 29:36.390
那么这个含书

29:36.390 --> 29:37.670
三要数是不是清楚了

29:37.670 --> 29:38.830
它反回什么

29:38.830 --> 29:41.550
有哪些参数含书的含书的名字

29:41.550 --> 29:42.550
都清楚了

29:42.550 --> 29:43.910
这个含书体就能写了

29:44.510 --> 29:45.550
你看是不是这样子

29:46.350 --> 29:48.030
知道参要数就能写含书体

29:48.390 --> 29:49.630
那这个含书体怎么写了

29:49.630 --> 29:51.350
现在给了一个数N要求阶层

29:51.350 --> 29:51.950
怎么求

29:51.950 --> 29:52.750
说你们求过了

29:52.750 --> 29:53.270
对吧

29:53.270 --> 29:55.350
哪一个Ridows等于1

29:55.350 --> 29:56.510
我这就不讲了

29:58.510 --> 30:00.430
1小于等于N

30:00.430 --> 30:00.830
对吧

30:00.830 --> 30:01.630
i加加

30:02.110 --> 30:02.950
从1寻到

30:02.950 --> 30:04.430
从2开始吧

30:04.430 --> 30:05.630
2寻换到N就行了

30:06.350 --> 30:07.750
然后每寻换一次

30:07.750 --> 30:08.990
乘等于i

30:09.430 --> 30:10.550
是不是阶层就抽出来了

30:12.070 --> 30:12.590
对不对

30:13.070 --> 30:13.590
好

30:13.590 --> 30:15.230
然后求出来的结果

30:15.230 --> 30:16.430
是不是就这个结果

30:16.830 --> 30:17.110
对吧

30:17.110 --> 30:18.070
把求出来的结果

30:18.070 --> 30:18.590
这个寻换完了

30:18.590 --> 30:18.990
是不是结果

30:18.990 --> 30:19.950
我们之前是做什么

30:19.950 --> 30:20.630
之前是输出

30:20.630 --> 30:21.670
现在当你输出了没

30:22.110 --> 30:22.750
没有当你输出

30:22.750 --> 30:23.910
你不要自作聪明

30:24.350 --> 30:24.950
应该做什么

30:24.950 --> 30:25.830
应该做反回

30:25.830 --> 30:26.070
对吧

30:26.070 --> 30:27.150
把这个结果反回

30:28.070 --> 30:28.310
好

30:28.310 --> 30:28.950
写完函数

30:28.950 --> 30:29.870
这个函数就写完了

30:29.870 --> 30:31.310
写完函数之后

30:31.870 --> 30:32.950
你可以测试一下

30:32.950 --> 30:34.190
然后棉花庄

30:34.190 --> 30:36.190
我要输出

30:36.190 --> 30:38.070
我要得到一个5的阶层

30:38.070 --> 30:39.630
那么我传一个5进去

30:40.150 --> 30:40.590
对吧

30:40.950 --> 30:42.390
把5作为时参

30:42.390 --> 30:43.230
传到这个行参

30:43.230 --> 30:43.990
然后它就运行

30:43.990 --> 30:45.150
走一遍这个流程

30:45.150 --> 30:45.830
走完流程

30:45.830 --> 30:47.270
是不是就反回一个结果

30:47.270 --> 30:48.310
反回一个结果

30:48.310 --> 30:49.630
就是这个表达式的结果

30:49.630 --> 30:50.150
这个玩意

30:50.150 --> 30:52.030
函数调用也是表达式

30:52.030 --> 30:53.430
这个表达式就是函数

30:53.430 --> 30:54.230
反回的结果

30:54.750 --> 30:55.910
那么我们是不是可以用变量

30:55.910 --> 30:56.630
接收一下

30:57.630 --> 30:58.030
对吧

30:58.590 --> 30:59.550
变量接收一下

30:59.550 --> 31:00.670
输出一下这个

31:00.670 --> 31:01.710
输出一下这个n

31:04.380 --> 31:05.500
弄到右侧

31:08.260 --> 31:09.100
这边120

31:09.100 --> 31:09.820
没问题吧

31:10.220 --> 31:10.620
当然了

31:10.620 --> 31:12.820
你完全表现我现在只要输出

31:12.820 --> 31:14.620
那我完全是不是可以不给这个

31:15.060 --> 31:16.060
不给这个变量

31:16.060 --> 31:18.100
然后直接把这个表达式放到这里输出

31:18.100 --> 31:18.460
对吧

31:18.460 --> 31:19.140
又来了

31:19.140 --> 31:19.740
突没

31:20.580 --> 31:21.820
所有需要输去的地方

31:21.820 --> 31:22.620
是不是可以放

31:22.900 --> 31:24.500
字面量变量表达式

31:24.500 --> 31:24.700
对吧

31:24.700 --> 31:25.860
这个玩意就是表达式

31:25.860 --> 31:26.620
把这个表达式

31:26.620 --> 31:28.340
也就是函数执行的结果

31:28.340 --> 31:29.220
拿过来输出

31:30.140 --> 31:30.900
也可以

31:30.940 --> 31:31.460
120

31:32.660 --> 31:33.340
会玩的吗

31:33.580 --> 31:33.940
好

31:33.940 --> 31:34.820
我们来测试一下

31:34.820 --> 31:36.540
如果说数字小于的1

31:36.540 --> 31:37.900
那么等写个1呢

31:39.060 --> 31:40.060
发现也没问题

31:40.060 --> 31:41.260
那写个0呢

31:42.100 --> 31:43.220
发现0有问题了

31:43.220 --> 31:43.580
对吧

31:43.580 --> 31:45.260
如果说数字小于1得到0

31:45.260 --> 31:45.980
所以说这件事

31:45.980 --> 31:48.340
我们可以在前边判断一下

31:48.340 --> 31:50.100
如果说n小于的1

31:50.100 --> 31:51.140
那么我们直接

31:51.860 --> 31:52.420
反回0

31:52.420 --> 31:53.540
因为这个Return

31:53.540 --> 31:54.860
只要执行到Return

31:54.860 --> 31:56.340
它就会终止函数的执行

31:56.340 --> 31:58.500
比方只要执行到这句话

31:59.500 --> 32:01.500
这个函数就立即停止

32:01.500 --> 32:02.500
后边就不执行了

32:03.500 --> 32:04.900
函数直接停止

32:04.900 --> 32:06.100
因为它已经有结果了

32:06.100 --> 32:07.900
函数已经产生了结果了

32:07.900 --> 32:09.300
后边流程不用走了

32:09.900 --> 32:11.900
因此我后边就没有放到L10里面

32:11.900 --> 32:12.100
对吧

32:12.100 --> 32:13.500
这是函数的一个特点

32:13.500 --> 32:14.900
它里面只要写到Return

32:14.900 --> 32:17.700
那么表示函数就运行到这就停止了

32:17.700 --> 32:19.500
那么这个表达式就有结果了

32:19.500 --> 32:20.700
怎么结果就是个0

32:21.700 --> 32:22.500
懂了意思吧

32:22.500 --> 32:24.500
于是我们这里得到了0

32:24.500 --> 32:25.900
只要小于就吃0

32:25.900 --> 32:26.500
好

32:26.500 --> 32:27.500
我们反复的测试

32:27.500 --> 32:28.500
5没问题

32:28.500 --> 32:29.500
6没问题

32:29.500 --> 32:30.500
1没问题

32:30.500 --> 32:32.500
我们就觉得这个函数应该没啥问题了

32:32.500 --> 32:34.500
将来有问题将来再说

32:34.500 --> 32:36.500
不要老是想着完美

32:36.500 --> 32:38.500
这个世界上没有完美的函数

32:38.500 --> 32:40.500
函数越复杂

32:40.500 --> 32:42.500
考虑到情况越多

32:42.500 --> 32:44.500
函数出8个的几率就越高

32:44.500 --> 32:46.500
所以说除了8个再说

32:46.500 --> 32:48.500
以后反正你们到公司里面

32:48.500 --> 32:50.500
也有专门的测试

32:50.500 --> 32:52.500
简单测试一下差不多得了

32:52.500 --> 32:55.500
那么说明是不是函数就写好了

32:55.500 --> 32:57.500
同学们养成一个好习惯

32:57.500 --> 32:59.500
函数写好了给我关上

32:59.500 --> 33:00.500
不要去看它

33:00.500 --> 33:02.500
免得脑袋里边又开始想

33:02.500 --> 33:03.500
我在调用函数的时候

33:03.500 --> 33:04.500
又再开始想

33:04.500 --> 33:05.500
它先经过一个判断

33:05.500 --> 33:07.500
再定的一个边量

33:07.500 --> 33:08.500
再写个奉勋环

33:08.500 --> 33:09.500
你疯掉了

33:09.500 --> 33:10.500
你疯掉了我也疯掉了

33:10.500 --> 33:12.500
我要这么想我都会疯掉

33:12.500 --> 33:13.500
千万不要去这么想

33:13.500 --> 33:14.500
写好了

33:14.500 --> 33:15.500
这个函数写好了没写好了

33:15.500 --> 33:16.500
它作用是什么

33:16.500 --> 33:17.500
给它一个数

33:17.500 --> 33:18.500
它就能返回一个阶层

33:18.500 --> 33:19.500
完了

33:19.500 --> 33:20.500
这个函数现在就忘记它

33:20.500 --> 33:21.500
不是你写的这个函数

33:21.500 --> 33:23.500
这是谁写的张山系统

33:23.500 --> 33:24.500
随便随便写一下

33:24.500 --> 33:25.500
登革写的

33:26.500 --> 33:27.500
你不用去看它

33:27.500 --> 33:29.500
接下来就直接用它来

33:29.500 --> 33:30.500
直接用就行了

33:30.500 --> 33:31.500
舒服的很

33:31.500 --> 33:33.500
就你现在已经招出了一个

33:33.500 --> 33:34.500
少的机器人

33:34.500 --> 33:36.500
你不要每一次

33:36.500 --> 33:38.500
跟着它跑

33:38.500 --> 33:39.500
跟着它跑一遍

33:39.500 --> 33:41.500
没意义的跟它自己去运作

33:41.500 --> 33:42.500
好地道题

33:42.500 --> 33:43.500
输出五的阶层

33:43.500 --> 33:44.500
怎么输出

33:44.500 --> 33:45.500
直接输出

33:46.500 --> 33:47.500
想都不要去想

33:47.500 --> 33:48.500
里面写的是啥

33:48.500 --> 33:49.500
反正出了问题

33:49.500 --> 33:50.500
我们再调

33:50.500 --> 33:51.500
写个五

33:51.500 --> 33:52.500
它没出问题

33:52.500 --> 33:53.500
它没出问题

33:53.500 --> 33:54.500
之前我想都不要去想

33:54.500 --> 33:55.500
它里面是啥

33:55.500 --> 33:56.500
它不就是求阶层

33:56.500 --> 33:57.500
对吧

33:57.500 --> 33:58.500
给它一个五

33:58.500 --> 33:59.500
它就能给我一个阶层结果

33:59.500 --> 34:00.500
它不就出来了

34:00.500 --> 34:01.500
是不是这样子变得简单了

34:01.500 --> 34:02.500
对吧

34:02.500 --> 34:03.500
那么流程变得简单了

34:03.500 --> 34:05.500
我主流程很简单

34:05.500 --> 34:07.500
实际上的事情交给它了

34:07.500 --> 34:08.500
对吧

34:08.500 --> 34:09.500
它里面也很简单

34:09.500 --> 34:10.500
相当于是把大问题

34:10.500 --> 34:11.500
分解成了小问题

34:11.500 --> 34:12.500
好

34:12.500 --> 34:14.500
求五和六的阶层之合

34:14.500 --> 34:16.500
然后输出

34:16.500 --> 34:17.500
然后五的阶层

34:17.500 --> 34:18.500
我们先求出来

34:18.500 --> 34:19.500
五的阶层

34:19.500 --> 34:21.500
N1

34:21.500 --> 34:23.500
然后六的阶层

34:23.500 --> 34:25.820
N2

34:25.820 --> 34:26.820
六的阶层求出来

34:26.820 --> 34:27.820
然后输出

34:27.820 --> 34:29.820
N1

34:29.820 --> 34:31.820
加上N2

34:31.820 --> 34:32.820
所以八百四

34:32.820 --> 34:33.820
你不要去想

34:33.820 --> 34:34.820
它里面怎么过程

34:34.820 --> 34:36.820
这不就是求五的阶层吗

34:36.820 --> 34:37.820
这个函数

34:37.820 --> 34:38.820
不就是搞定这个事吗

34:38.820 --> 34:39.820
你辛辛苦苦写了半天

34:39.820 --> 34:41.820
你现在又在想里面的东西

34:41.820 --> 34:43.820
那辛苦不是白费了吗

34:43.820 --> 34:44.820
你之前的辛苦

34:44.820 --> 34:45.820
不就是让它以后轻松吗

34:45.820 --> 34:46.820
这不就是轻松了吗

34:46.820 --> 34:47.820
你给它一个五

34:47.820 --> 34:48.820
它给你一个阶层

34:48.820 --> 34:49.820
对吧

34:49.820 --> 34:50.820
就完事了

34:50.820 --> 34:51.820
好

34:51.820 --> 34:52.820
那么这样你既然是表达

34:52.820 --> 34:54.820
是不是可以

34:54.820 --> 34:56.820
可以这样

34:56.820 --> 34:58.820
对吧

34:58.820 --> 34:59.820
再重申一次

34:59.820 --> 35:01.820
有些人老是忍不住去想里边的东西

35:01.820 --> 35:02.820
不要去想里边的东西

35:02.820 --> 35:04.820
你如果说里边东西还不放心

35:04.820 --> 35:06.820
你就把这个再写一遍

35:06.820 --> 35:08.820
你只要写到你这一块单码

35:08.820 --> 35:09.820
你觉得放心了

35:09.820 --> 35:10.820
好

35:10.820 --> 35:11.820
OK 你就不要去想它了

35:11.820 --> 35:12.820
用就行了

35:12.820 --> 35:13.820
大胆的用

35:13.820 --> 35:15.820
出的问题再输

35:15.820 --> 35:17.820
那这里是六的阶层

35:17.820 --> 35:18.820
这里是不是五的阶层

35:18.820 --> 35:19.820
整个反馈结果

35:19.820 --> 35:21.820
相加输出就完事了

35:21.820 --> 35:23.820
你看也不一样

35:24.820 --> 35:25.820
你想没有函数的话

35:25.820 --> 35:27.820
这个单码就写下去麻烦

35:27.820 --> 35:28.820
好

35:28.820 --> 35:29.820
输出阶层结果

35:29.820 --> 35:32.820
不超过一千的所有数字

35:32.820 --> 35:33.820
就哪些阶层从一开始

35:33.820 --> 35:34.820
当然从一开始

35:34.820 --> 35:36.820
一的阶层有没有超过一千

35:36.820 --> 35:37.820
没有

35:37.820 --> 35:38.820
那就输出一

35:38.820 --> 35:39.820
二的阶层有没有超过一千

35:39.820 --> 35:40.820
没有

35:40.820 --> 35:41.820
那就输出二

35:41.820 --> 35:42.820
三的阶层有没有超过一千

35:42.820 --> 35:43.820
没有就输出三

35:43.820 --> 35:45.820
就这个意思

35:46.820 --> 35:48.820
从一开始

35:48.820 --> 35:50.820
我们觉得一千的阶层

35:50.820 --> 35:51.820
肯定是超过一千了

35:51.820 --> 35:52.820
我就写个一千

35:52.820 --> 35:54.820
一到一千之间循环

35:54.820 --> 35:56.820
那是不是我就判断一下

35:56.820 --> 35:58.820
每一次阶层结果

35:58.820 --> 36:00.820
每一次阶层的结果

36:00.820 --> 36:01.820
把爱传进去

36:01.820 --> 36:03.820
是不是得到每一次阶层的结果

36:03.820 --> 36:04.820
脑袋里面千万不要想

36:04.820 --> 36:05.820
里边怎么写的

36:05.820 --> 36:07.820
这就是求阶层的结果

36:07.820 --> 36:08.820
这不是理解的吗

36:08.820 --> 36:09.820
不是理解的

36:09.820 --> 36:11.820
就是我写的

36:11.820 --> 36:13.820
不是理解的这个东西

36:14.820 --> 36:15.820
听清楚了吗

36:15.820 --> 36:16.820
原老师现在高处理这个

36:16.820 --> 36:17.820
不是理解的

36:17.820 --> 36:18.820
既也是自带的

36:18.820 --> 36:19.820
求阶层

36:19.820 --> 36:21.820
那你脑袋里面还会去想吗

36:21.820 --> 36:22.820
不去想了

36:22.820 --> 36:23.820
这就是求阶层

36:23.820 --> 36:25.820
得到一个阶层结果

36:25.820 --> 36:26.820
我看一下这个结果

36:26.820 --> 36:28.820
是不是小于一千

36:28.820 --> 36:30.820
不超过一千小于等于一千

36:30.820 --> 36:31.820
只要小于等于一千

36:31.820 --> 36:32.820
我就把这个n

36:32.820 --> 36:33.820
把这个i输出

36:33.820 --> 36:34.820
i的阶层结果

36:34.820 --> 36:35.820
是小于等于一千的

36:35.820 --> 36:36.820
当然了

36:36.820 --> 36:37.820
也可以把这个表达是

36:37.820 --> 36:41.130
是不是直接放过来

36:41.130 --> 36:42.130
就完了

36:42.130 --> 36:44.130
就一二他是五六

36:44.130 --> 36:46.130
后面就

36:47.130 --> 36:48.130
Ls

36:48.130 --> 36:49.130
这个Ls

36:49.130 --> 36:51.130
如果他超过了一千

36:51.130 --> 36:52.130
比如说一比没有超过一千

36:52.130 --> 36:53.130
二没有超过一千

36:53.130 --> 36:54.130
五六

36:54.130 --> 36:55.130
到七

36:55.130 --> 36:56.130
七超过一千了

36:56.130 --> 36:57.130
是不是就可以break了

36:57.130 --> 36:58.130
停滞循环了

36:58.130 --> 36:59.130
后面没有必要去看了

36:59.130 --> 37:00.130
你七都超过一千了

37:00.130 --> 37:02.130
八肯定超过一千了

37:02.130 --> 37:03.130
到了第一个

37:03.130 --> 37:04.130
超过一千了

37:04.130 --> 37:06.130
我就可以结束循环了

37:06.130 --> 37:07.130
后面就没有必要进行了

37:07.130 --> 37:09.130
这样提高运行效率

37:09.130 --> 37:10.130
一二三是五六

37:10.130 --> 37:11.130
他超过一千的

37:11.130 --> 37:13.950
能理解吧

37:13.950 --> 37:14.950
通过这道题

37:14.950 --> 37:16.950
第一道的

37:16.950 --> 37:18.950
函数就应该是这种感觉

37:18.950 --> 37:19.950
你看一下这个代码

37:19.950 --> 37:21.950
如果说没有函数的话

37:21.950 --> 37:26.100
这个写在这个麻烦了

37:26.100 --> 37:27.100
第二题

37:29.100 --> 37:33.750
函数三要数给你弄出来了

37:33.750 --> 37:34.750
这个函数的名字叫include

37:34.750 --> 37:36.750
表示没包含的意思

37:36.750 --> 37:37.750
他说

37:37.750 --> 37:40.750
在数组ARR中

37:40.750 --> 37:41.750
是不是告诉你

37:41.750 --> 37:42.750
这个参数是一个数组

37:42.750 --> 37:43.750
给你扔进来了

37:43.750 --> 37:46.750
让你寻找是否存在这个东西

37:46.750 --> 37:47.750
在这个里面

37:47.750 --> 37:49.750
找一下有没有这个

37:49.750 --> 37:51.750
返回有没有找到

37:51.750 --> 37:53.750
返回的是一个布尔

37:53.750 --> 37:54.750
找到就是true

37:54.750 --> 37:55.750
没有找到就是force

37:55.750 --> 37:56.750
这就是

37:56.750 --> 37:58.750
第一个参数就是要便利的数组

37:58.750 --> 37:59.750
它是个数组类型

37:59.750 --> 38:00.750
array

38:00.750 --> 38:02.750
就是你要在这个数组里面

38:02.750 --> 38:03.750
一项一项去找

38:03.750 --> 38:05.750
Target什么是任何类型

38:05.750 --> 38:06.750
任何类型

38:06.750 --> 38:07.750
NB表是任何类型

38:07.750 --> 38:08.750
你要找的目标

38:08.750 --> 38:09.750
就要找这个

38:09.750 --> 38:10.750
那是不是一个查到问题

38:10.750 --> 38:11.750
我们把查到问题

38:11.750 --> 38:12.750
封装成了一个函数

38:12.750 --> 38:13.750
查到问题怎么写

38:13.750 --> 38:14.750
是不是isfand

38:14.750 --> 38:16.750
显然没有找到

38:16.750 --> 38:18.750
然后来询用完这个数组

38:18.750 --> 38:19.750
i.u0

38:19.750 --> 38:21.750
i.r.nance

38:21.750 --> 38:22.750
注意看

38:22.750 --> 38:25.750
这个文档注释还有个好处

38:25.750 --> 38:27.750
当你把类型标注好之后

38:27.750 --> 38:29.750
它在这个函数的写单码的过程中

38:29.750 --> 38:30.750
它会告诉你

38:30.750 --> 38:33.750
你看是不是有智能提示

38:33.750 --> 38:34.750
nance

38:34.750 --> 38:35.750
它会告诉你

38:35.750 --> 38:36.750
有个属性叫nance数组里面

38:36.750 --> 38:38.750
那如果说你没有这个

38:38.750 --> 38:39.750
比方的新号

38:39.750 --> 38:40.750
新号也表示任何类型

38:40.750 --> 38:42.750
你没有这个类型标注

38:42.750 --> 38:43.750
它就不知道

38:43.750 --> 38:44.750
因为它不知道

38:44.750 --> 38:45.750
它是一个数组

38:46.750 --> 38:48.750
后面都是一些联想的

38:48.750 --> 38:49.750
联想出来的

38:49.750 --> 38:50.750
不一定准确

38:50.750 --> 38:51.750
但是你写到个array的话

38:51.750 --> 38:52.750
就知道了

38:52.750 --> 38:54.750
这一块一定是有nance

38:58.060 --> 39:00.060
循环这个数组对不对

39:00.060 --> 39:01.060
我们要找什么

39:01.060 --> 39:03.060
找这个ai

39:03.060 --> 39:04.060
是不是等于talkit

39:04.060 --> 39:05.060
这个单码我不讲了

39:05.060 --> 39:07.060
下面联系循环的

39:07.060 --> 39:10.210
找到了

39:10.210 --> 39:11.210
找到了干嘛

39:11.210 --> 39:12.210
是不是isfand

39:12.210 --> 39:13.210
设为q

39:13.210 --> 39:14.210
然后break停止寻找

39:14.210 --> 39:16.210
然后除了这个循环

39:16.210 --> 39:17.210
是不是可以判断

39:17.210 --> 39:18.210
isfand

39:19.210 --> 39:20.210
有没有找到

39:21.210 --> 39:22.210
找到了怎么样

39:22.210 --> 39:23.210
没找到怎么样

39:23.210 --> 39:24.210
那现在找到怎么样

39:24.210 --> 39:25.210
没有让你输出

39:25.210 --> 39:27.210
你给我在这里输出一个是

39:27.210 --> 39:28.210
那又是不是不符合

39:28.210 --> 39:29.210
含书的含义了

39:29.210 --> 39:30.210
含书的含义是什么

39:30.210 --> 39:32.210
让你问你有没有找到

39:32.210 --> 39:34.210
你返回

39:34.210 --> 39:36.210
找到了我就返回什么

39:36.210 --> 39:37.210
返回q

39:37.210 --> 39:38.210
没有找到了

39:38.210 --> 39:40.210
我就返回force

39:40.210 --> 39:41.210
应该这样子写

39:43.210 --> 39:45.210
这个写法是不是有点多说

39:45.210 --> 39:46.210
它为q返回q

39:46.210 --> 39:47.210
它为force

39:47.210 --> 39:48.210
返回force

39:48.210 --> 39:50.210
直接把它返回不完了

39:50.210 --> 39:53.350
是不是这样

39:55.350 --> 39:56.350
这样子可不可以

39:56.350 --> 39:57.350
直接把它返回

39:57.350 --> 39:59.350
它这个代码还是有点多说

39:59.350 --> 40:00.350
还是有点多说

40:00.350 --> 40:02.350
其实在含书里边做一个查照

40:02.350 --> 40:03.350
还可以这样子来做

40:03.350 --> 40:05.350
我不要这个辩量了

40:05.350 --> 40:11.120
这样子写就可以了

40:11.120 --> 40:12.120
为什么呢

40:12.120 --> 40:13.120
你可以说

40:13.120 --> 40:14.120
只要我找到了

40:14.120 --> 40:15.120
我是不是就return了

40:15.120 --> 40:16.120
return是不是就含书结束了

40:16.120 --> 40:17.120
后边代码还运行吗

40:17.120 --> 40:18.120
就不运行了

40:18.120 --> 40:20.120
只要我找到了一个

40:20.120 --> 40:22.120
我就直接结束含书

40:22.120 --> 40:23.120
是不是可以了

40:24.120 --> 40:25.120
结束结束

40:25.120 --> 40:26.120
那就不光是结束循环了

40:26.120 --> 40:27.120
是结束整个含书

40:28.120 --> 40:29.120
我已经留了一个结果了

40:29.120 --> 40:30.120
我找到了

40:30.120 --> 40:31.120
OK了

40:32.120 --> 40:34.120
如果说找完了都没有找到

40:34.120 --> 40:36.120
我在这里返回force

40:36.120 --> 40:38.120
说明你前面都没有返回

40:38.120 --> 40:39.120
你前面返回来

40:39.120 --> 40:40.120
我这里肯定不会运行

40:41.120 --> 40:42.120
就这个意思

40:42.120 --> 40:43.120
说查到问题

40:43.120 --> 40:44.120
我们往往可以这样子写

40:44.120 --> 40:45.120
好

40:45.120 --> 40:46.120
那么我现在多测试一下

40:46.120 --> 40:47.120
我给他一个书

40:50.780 --> 40:51.780
include

40:56.200 --> 40:57.200
判断一下

40:57.200 --> 40:58.200
这要传两个参数

40:58.200 --> 40:59.200
第一个参数传一个数组

40:59.200 --> 41:01.200
我是不是可以传个字面量进去

41:01.200 --> 41:02.200
对吧

41:02.200 --> 41:03.200
数组里边传一个

41:03.200 --> 41:05.200
三一五六七

41:06.200 --> 41:07.200
然后找什么找三

41:07.200 --> 41:09.200
看一下有没有三存不存在的

41:09.200 --> 41:10.200
我们输出一下结果

41:13.700 --> 41:15.700
三在这个数字里面是存在的

41:15.700 --> 41:17.700
这个含书返回了一个

41:17.700 --> 41:19.700
然后我们看一下五存不存在的

41:19.700 --> 41:20.700
五也是存在的

41:20.700 --> 41:22.700
我们看一下二存不存在的

41:22.700 --> 41:24.700
多测试一下

41:24.700 --> 41:25.700
你不放心就多测试一下

41:26.700 --> 41:27.700
给他一个数组

41:27.700 --> 41:28.700
当然一个数组

41:28.700 --> 41:30.700
也可以把它定义到变量里边

41:31.700 --> 41:32.700
对吧

41:32.700 --> 41:33.700
然后把个变量传过去

41:33.700 --> 41:34.700
都行

41:34.700 --> 41:35.700
反正数据的地方

41:35.700 --> 41:36.700
你可以传任何东西

41:36.700 --> 41:37.700
你可以传变量

41:37.700 --> 41:38.700
你可以传字面量

41:38.700 --> 41:39.700
你可以传表达是都行

41:39.700 --> 41:40.700
都行

41:41.700 --> 41:42.700
反正就是会

41:42.700 --> 41:44.700
你把数据给他

41:44.700 --> 41:45.700
然后把这个数据给他

41:45.700 --> 41:46.700
管理是什么数据

41:46.700 --> 41:47.700
然后他就会给你

41:47.700 --> 41:49.700
做一套这个流程

41:49.700 --> 41:50.700
然后告诉你一个结果

41:50.700 --> 41:51.700
这就是含书

41:54.340 --> 41:55.340
那么

41:55.340 --> 41:56.340
觉得测试没问题的

41:56.340 --> 41:57.340
干什么

41:57.340 --> 41:58.340
然后说过怎么样

41:58.340 --> 41:59.340
关掉

41:59.340 --> 42:01.340
这个含书是你写的吗

42:01.340 --> 42:02.340
来

42:02.340 --> 42:03.340
同学们又来问这个问题

42:03.340 --> 42:04.340
这个含书是你写的吗

42:04.340 --> 42:05.340
不是

42:05.340 --> 42:07.340
谁说的这个含书是你写的

42:07.340 --> 42:08.340
也不是袁老师写的

42:08.340 --> 42:09.340
一个含书谁写的

42:09.340 --> 42:10.340
我也不知道谁写的

42:10.340 --> 42:11.340
反正莫名其妙

42:11.340 --> 42:12.340
就在这里有个这个含书了

42:12.340 --> 42:13.340
好像是系统写的吧

42:13.340 --> 42:15.340
好像是借也是自带的吧

42:15.340 --> 42:16.340
我也搞不清楚

42:16.340 --> 42:17.340
反正不是我写的

42:17.340 --> 42:18.340
这个含书不是我写的

42:18.340 --> 42:20.340
那么这个含书的作用是什么呢

42:20.340 --> 42:21.340
给他一个数组

42:21.340 --> 42:22.340
给他一个值

42:22.340 --> 42:23.340
他就能告诉你存不存在

42:23.340 --> 42:24.340
那我们就可以用了

42:25.340 --> 42:26.340
好 地牢题

42:27.340 --> 42:29.340
这里有个数组给你写的好了

42:29.340 --> 42:31.340
判断这个数组是否存在8

42:31.340 --> 42:33.340
输出4还是不是

42:33.340 --> 42:34.340
直接调用了含书

42:34.340 --> 42:35.340
include

42:35.340 --> 42:36.340
输出什么

42:36.340 --> 42:37.340
输出这个含书的直行结果

42:37.340 --> 42:39.340
输出这个含书的直行结果

42:39.340 --> 42:40.340
给他一个数组

42:40.340 --> 42:41.340
那么是

42:41.340 --> 42:42.340
判断了谁

42:42.340 --> 42:43.340
8

42:43.340 --> 42:45.340
看这个8在数组中里面存不存在

42:45.340 --> 42:46.340
存在的坏了

42:46.340 --> 42:48.340
就是不存在就是force

42:48.340 --> 42:49.340
简单简单

42:49.340 --> 42:50.340
一下子就变得简单了

42:50.340 --> 42:52.340
你不要去想他里面

42:52.340 --> 42:53.340
写的这个含书

42:53.340 --> 42:54.340
根本就不是你写的

42:54.340 --> 42:55.340
你想啥

42:55.340 --> 42:56.340
他里面可复杂了

42:56.340 --> 42:57.340
他里面有一关行呆吗

42:57.340 --> 42:58.340
你想什么想

42:58.340 --> 42:59.340
不用去想

42:59.340 --> 43:00.340
反正他就是

43:01.340 --> 43:02.340
就存在

43:02.340 --> 43:04.340
反正就是这个含书就在这

43:05.340 --> 43:07.970
好

43:07.970 --> 43:08.970
然后第二题

43:08.970 --> 43:09.970
判断数字2

43:09.970 --> 43:11.970
是否同时存在于nomus

43:11.970 --> 43:12.970
同时存在

43:12.970 --> 43:13.970
有一个数字2

43:13.970 --> 43:15.970
是不是在这里面也存在

43:15.970 --> 43:16.970
在这里面也存在

43:16.970 --> 43:17.970
输出4何否

43:19.970 --> 43:21.970
对 我这里要输出4何否

43:21.970 --> 43:22.970
对吧

43:22.970 --> 43:23.970
所以说我这里还是要这样判的

43:23.970 --> 43:24.970
include

43:24.970 --> 43:25.970
nomus

43:26.970 --> 43:33.760
4

43:33.760 --> 43:35.760
这个是代码打快了

43:35.760 --> 43:36.760
老是

43:36.760 --> 43:38.760
他老是反应不过来

43:38.760 --> 43:39.760
否

43:39.760 --> 43:42.140
那么就是4

43:42.140 --> 43:43.140
对吧

43:43.140 --> 43:44.140
让我们看一下

43:44.140 --> 43:45.140
4什么存在呢

43:45.140 --> 43:46.140
就否

43:48.140 --> 43:49.140
能看懂吗

43:50.140 --> 43:51.140
这个表达是一个布尔

43:51.140 --> 43:52.140
true or false

43:52.140 --> 43:53.140
如果说

43:53.140 --> 43:54.140
怎么读

43:54.140 --> 43:55.140
如果存在

43:55.140 --> 43:56.140
你看这个命名

43:56.140 --> 43:57.140
一定要命名也好

43:57.140 --> 43:58.140
就非常容易越读

43:58.140 --> 43:59.140
如果存在

44:00.140 --> 44:01.140
那么就输出4

44:01.140 --> 44:02.140
否则就输出否

44:04.140 --> 44:07.150
好

44:07.150 --> 44:08.150
好 第二个

44:08.150 --> 44:09.150
判断数字2

44:09.150 --> 44:10.150
是否同时存在

44:10.150 --> 44:11.150
这个太简单了

44:12.150 --> 44:13.150
include

44:13.150 --> 44:14.150
nomus2

44:15.150 --> 44:16.150
看2在不在这里面

44:16.150 --> 44:17.150
对吧

44:17.150 --> 44:19.150
并且include

44:20.150 --> 44:21.150
nomus2

44:23.150 --> 44:25.150
看一下2在不在这里面

44:25.150 --> 44:26.150
并且2在不在这里面

44:26.150 --> 44:28.150
如果两个条件同时满足

44:28.150 --> 44:29.150
这是表达式

44:29.150 --> 44:30.150
这个表达式

44:30.150 --> 44:31.150
会返回一个true

44:31.150 --> 44:32.150
或者 false

44:32.150 --> 44:33.150
这个表达式

44:33.150 --> 44:34.150
也会返回一个true

44:34.150 --> 44:35.150
说明都是同时存在

44:35.150 --> 44:36.150
同时存在就输出4

44:37.150 --> 44:38.150
否则就输出否

44:38.150 --> 44:40.150
我不知道现在还有多少同学

44:40.150 --> 44:41.150
原老师这样强调一下

44:41.150 --> 44:42.150
还有多少同学

44:42.150 --> 44:44.150
回去享州里边再扎起

44:45.150 --> 44:46.150
有没有这样的同学

44:46.150 --> 44:48.150
有这样的同学

44:48.150 --> 44:49.150
轻轻的

44:49.150 --> 44:50.150
因为脑袋去装一下墙

44:50.150 --> 44:52.150
不要去想这个问题

44:52.150 --> 44:53.150
不要去想这个问题

44:54.150 --> 44:55.150
不然的话心理负担太重了

44:55.150 --> 44:57.150
原老师从来不想去想这个问题

44:57.150 --> 44:58.150
我写到这

44:58.150 --> 44:59.150
这就是系统写的寒书

44:59.150 --> 45:00.150
非常舒服

45:00.150 --> 45:01.150
我真信

45:01.150 --> 45:02.150
越读又好越读

45:02.150 --> 45:03.150
对吧

45:03.150 --> 45:04.150
我觉得企业师真的太智能了

45:04.150 --> 45:06.150
他这么知道过要去这个寒书

45:06.150 --> 45:07.150
他就会提供这个寒书

45:07.150 --> 45:08.150
对吧

45:08.150 --> 45:09.150
不是理解的

45:09.150 --> 45:10.150
不要去想这个

45:10.150 --> 45:11.150
有个存在不存在

45:11.150 --> 45:12.150
太舒服了

45:13.150 --> 45:14.150
这样子

45:14.150 --> 45:16.150
你还真能够真正体会到

45:16.150 --> 45:17.150
这个寒书的

45:17.150 --> 45:19.150
给我们开发它的变理

45:19.150 --> 45:21.150
不然的话你永远觉得它是负担

45:21.150 --> 45:23.150
好 第三题有点难度

45:23.150 --> 45:25.150
因为你想通了也没什么难度的

45:25.150 --> 45:26.150
判断NAMS3中

45:26.150 --> 45:29.150
是否所有数字都在NAMS中存在

45:29.150 --> 45:31.150
就是NAMS3是个数组

45:31.150 --> 45:32.150
它有个NAMS2

45:32.150 --> 45:33.150
有个NAMS5

45:33.150 --> 45:34.150
有个NAMS1

45:34.150 --> 45:36.150
这些数字当然你不能说

45:36.150 --> 45:37.150
一定它里面有NAMS2、NAMS1

45:37.150 --> 45:39.150
它又可能是别的数字

45:39.150 --> 45:40.150
可以改的

45:40.150 --> 45:41.150
就这个数组里面

45:41.150 --> 45:42.150
有些数字

45:42.150 --> 45:43.150
这个数字看一下

45:43.150 --> 45:46.150
在它里面存不存在

45:46.150 --> 45:47.150
再看一下NAMS5

45:47.150 --> 45:48.150
在它里面存不存在

45:48.150 --> 45:49.150
再看一下NAMS1

45:49.150 --> 45:50.150
在它里面存不存在

45:50.150 --> 45:52.150
如果说都存在的话

45:52.150 --> 45:54.150
输出4或者4

45:54.150 --> 45:55.150
输出4

45:55.150 --> 45:56.150
只要有一个不存在

45:56.150 --> 45:57.150
就输出4

45:57.150 --> 45:59.150
是吧

46:05.240 --> 46:06.240
好

46:06.240 --> 46:07.240
那么这道题怎么做呢

46:07.240 --> 46:09.240
这道题是要思考题

46:09.240 --> 46:10.240
不要求同学们能够做出来

46:10.240 --> 46:12.240
如果说你觉得这一套题复杂的话

46:12.240 --> 46:14.240
可以略过没关系的

46:15.240 --> 46:16.240
其实说出来这个题

46:16.240 --> 46:18.240
也没有太大的难度

46:18.240 --> 46:19.240
就怎么样了

46:19.240 --> 46:20.240
我需要准备一张纸

46:20.240 --> 46:22.240
这个纸呢

46:22.240 --> 46:24.240
一开始记录的是Force

46:24.240 --> 46:25.240
这个纸是什么意思

46:25.240 --> 46:27.240
这个纸上记录的就是

46:27.240 --> 46:29.240
不是有没有找到

46:29.240 --> 46:30.240
只有不是有没有找到

46:30.240 --> 46:32.240
是否全是

46:32.240 --> 46:35.450
是否全是什么意思

46:35.450 --> 46:37.450
就是它在里面存在

46:37.450 --> 46:38.450
它在里面存在

46:38.450 --> 46:40.450
它也在NAMS里面存在

46:40.450 --> 46:41.450
就是全是

46:41.450 --> 46:43.450
一开始还没开始动

46:43.450 --> 46:45.450
所以说一开始肯定不是全是

46:45.450 --> 46:48.760
我想一想

46:48.760 --> 46:49.760
不对

46:49.760 --> 46:51.760
一开始是去

46:51.760 --> 46:52.760
是否全是

46:52.760 --> 46:54.760
一开始为什么是去

46:54.760 --> 46:56.760
我是这样理解的

46:56.760 --> 46:58.760
一开始的时候

46:58.760 --> 47:00.760
我都还没有找

47:00.760 --> 47:01.760
一个都没有

47:01.760 --> 47:02.760
是不是一个数

47:02.760 --> 47:04.760
一个数我都没去看过

47:04.760 --> 47:05.760
对吧

47:05.760 --> 47:06.760
那我就认为

47:06.760 --> 47:07.760
一个空的数

47:07.760 --> 47:09.760
什么都没有的数

47:09.760 --> 47:10.760
一定是存在的

47:10.760 --> 47:12.760
其实我写完了就知道了

47:12.760 --> 47:14.760
一开始解释还不好解释

47:14.760 --> 47:15.760
就是你如果

47:15.760 --> 47:17.760
这里就记录一个处

47:17.760 --> 47:19.760
看一下2在里面存不存在

47:20.760 --> 47:22.760
看一下2在里面存不存在

47:22.760 --> 47:24.760
无论得到的是处还是结果

47:24.760 --> 47:26.760
给它求并且

47:26.760 --> 47:27.760
给它求并且

47:27.760 --> 47:29.760
比方说2得到的结果

47:29.760 --> 47:31.760
得到的结果是处

47:31.760 --> 47:32.760
好 那么就是

47:32.760 --> 47:35.760
处 and并且处

47:35.760 --> 47:37.760
那么又重新记录一下

47:37.760 --> 47:38.760
它还是处

47:38.760 --> 47:39.760
对吧

47:39.760 --> 47:40.760
如果说2是force

47:40.760 --> 47:41.760
它不存在

47:41.760 --> 47:43.760
那么就是处并且force

47:43.760 --> 47:45.760
是不是变成force了

47:45.760 --> 47:46.760
并且是两个都为数

47:46.760 --> 47:48.760
所以说这里就变成force了

47:48.760 --> 47:50.760
那只要这里变成force

47:50.760 --> 47:52.760
就立即结束了

47:52.760 --> 47:54.760
所以找到一个不存在的

47:54.760 --> 47:56.760
就立即结束了

47:56.760 --> 48:00.460
原来是这样子做

48:00.460 --> 48:02.460
好像反而麻烦

48:02.460 --> 48:03.460
反正是吧

48:03.460 --> 48:04.460
有没有同学觉得

48:04.460 --> 48:06.460
是这里说的不对

48:06.460 --> 48:07.460
这个逻辑是对的

48:07.460 --> 48:08.460
就是这样子写可有意义的

48:08.460 --> 48:09.460
但是我们是

48:09.460 --> 48:12.460
写到这儿是不是有感觉

48:12.460 --> 48:15.460
有一个更简单的办法

48:15.460 --> 48:17.460
是有更简单的办法

48:17.460 --> 48:19.460
什么办法

48:19.460 --> 48:22.460
我要找的这个数

48:22.460 --> 48:24.460
就是我要只要找到

48:24.460 --> 48:26.460
一个不存在的就不存在了

48:26.460 --> 48:27.460
对吧

48:27.460 --> 48:28.460
是不是

48:28.460 --> 48:33.280
只要找到一个不存在的就不存在了

48:33.280 --> 48:34.280
那我就找吧

48:34.280 --> 48:36.280
easy find

48:36.280 --> 48:38.280
那我就用查照问题吧

48:38.280 --> 48:40.910
这里表示

48:40.910 --> 48:42.910
我两种想法都写一下

48:42.910 --> 48:43.910
这都是思考题

48:43.910 --> 48:44.910
无所谓的

48:44.910 --> 48:45.910
实际上听不懂就算了

48:45.910 --> 48:49.990
我用两种想法都写一下

48:49.990 --> 48:50.990
第一种是查照方式

48:50.990 --> 48:52.990
用查照问题的处理方式

48:52.990 --> 48:53.990
easy find

48:53.990 --> 48:55.990
就是找

48:55.990 --> 48:57.990
找什么呢

48:57.990 --> 49:00.990
找有一个数

49:00.990 --> 49:02.990
不存在

49:02.990 --> 49:06.560
与

49:07.560 --> 49:11.320
这有点糟

49:11.320 --> 49:12.320
是否找到有一个数

49:12.320 --> 49:14.320
不存在与

49:20.700 --> 49:21.700
循环这里每一个数

49:21.700 --> 49:22.700
对吧

49:22.700 --> 49:23.700
看一下这个数

49:23.700 --> 49:25.700
是不是不存在与

49:25.700 --> 49:27.700
哪个数

49:27.700 --> 49:29.700
看

49:31.700 --> 49:33.700
3i

49:33.700 --> 49:34.700
对吧

49:34.700 --> 49:35.700
251

49:35.700 --> 49:37.700
这个数

49:37.700 --> 49:39.700
不存在与

49:41.700 --> 49:42.700
判断一下

49:42.700 --> 49:44.700
不存在是不是要取反

49:46.700 --> 49:47.700
哪个数

49:51.700 --> 49:52.700
看这个数

49:52.700 --> 49:54.700
把表拉似的结果

49:54.700 --> 49:55.700
如果看不懂表拉似的话

49:55.700 --> 49:56.700
又来一遍

49:56.700 --> 49:57.700
n

49:57.700 --> 49:58.700
这道题

49:58.700 --> 49:59.700
我再说一下

49:59.700 --> 50:00.700
有难度了

50:00.700 --> 50:01.700
看不懂没关系

50:01.700 --> 50:03.700
不要造成心理负担

50:03.700 --> 50:04.700
看不懂这个题

50:04.700 --> 50:05.700
是不是又完了

50:05.700 --> 50:06.700
这题是思考题

50:06.700 --> 50:08.700
本来我就加了一点难度在这里

50:09.700 --> 50:10.700
我们平时开发

50:10.700 --> 50:12.700
是不太会遇到这么复杂的题的

50:12.700 --> 50:13.700
得到一个数

50:13.700 --> 50:15.700
那么这里传n也可以

50:15.700 --> 50:16.700
传n也可以

50:16.700 --> 50:17.700
放轻松

50:17.700 --> 50:22.100
就是这个数

50:22.100 --> 50:24.100
在这里面是否存在

50:24.100 --> 50:25.100
如果说你存在

50:25.100 --> 50:26.100
我就给你取反

50:26.100 --> 50:27.100
你不存在

50:27.100 --> 50:28.100
那就相当于是

50:28.100 --> 50:29.100
你要这样读

50:29.100 --> 50:30.100
要代码要读出来

50:30.100 --> 50:31.100
不存在

50:31.100 --> 50:32.100
inclusive表示包含

50:32.100 --> 50:33.100
不包含

50:33.100 --> 50:34.100
那么是

50:34.100 --> 50:36.100
不包含这个东西

50:36.100 --> 50:37.100
如果不包含

50:37.100 --> 50:38.100
是不是找到了

50:38.100 --> 50:39.100
是不包含的

50:40.100 --> 50:41.100
找到了对吧

50:41.100 --> 50:43.100
就是easy find

50:43.100 --> 50:44.100
设为2

50:44.100 --> 50:45.100
break

50:47.100 --> 50:48.100
不包含

50:48.100 --> 50:49.100
好

50:49.100 --> 50:50.100
那么最后

50:50.100 --> 50:51.100
看一下easy find

50:51.100 --> 50:52.100
如果找到了

50:52.100 --> 50:53.100
找到什么

50:54.100 --> 50:55.100
什么叫找到了

50:55.100 --> 50:56.100
就是它里面有一个数

50:56.100 --> 50:58.100
不包含

50:58.100 --> 50:59.100
在num是中

50:59.100 --> 51:01.100
就有其中一个数

51:01.100 --> 51:03.100
num是里面是没有的

51:03.100 --> 51:04.100
那这种情况

51:04.100 --> 51:05.100
是不是输出否

51:06.100 --> 51:07.100
因为我要所有的都有

51:07.100 --> 51:09.100
它其中一个数在num是里面没有

51:09.100 --> 51:11.100
那么我就输出否

51:11.100 --> 51:16.800
l是

51:16.800 --> 51:17.800
我就输出是

51:19.800 --> 51:21.800
251是都有的

51:21.800 --> 51:22.800
我再来一个11

51:23.800 --> 51:24.800
那就是否

51:24.800 --> 51:26.800
这是这种邪法

51:26.800 --> 51:27.800
其实这种邪法

51:27.800 --> 51:28.800
把它变成查到问题

51:28.800 --> 51:29.800
反而不是那么好一家

51:29.800 --> 51:30.800
我再来放一种邪法

51:30.800 --> 51:31.800
放一种邪法

51:31.800 --> 51:32.800
就是我刚才说的这种邪法

51:33.800 --> 51:34.800
是否全是

51:34.800 --> 51:35.800
我就直接用变量

51:35.800 --> 51:36.800
result

51:36.800 --> 51:37.800
这个force

51:37.800 --> 51:38.800
我等于去

51:38.800 --> 51:39.800
我等于去

51:40.800 --> 51:41.800
那么这个是什么意思呢

51:41.800 --> 51:42.800
就是我一个数找吗

51:42.800 --> 51:43.800
251吗

51:49.140 --> 51:50.140
来吧

51:50.140 --> 51:51.140
看一下这种邪法

51:53.140 --> 51:54.140
比方说

51:54.140 --> 51:55.140
2存在

51:56.140 --> 51:57.140
它一开始是去

51:59.140 --> 52:00.140
5也存在

52:01.140 --> 52:02.140
1也存在

52:03.140 --> 52:04.140
num是里面都存在

52:04.140 --> 52:05.140
比方说

52:05.140 --> 52:06.140
那么我怎么处理这个问题呢

52:06.140 --> 52:08.140
一开始我记住个变量为处

52:08.140 --> 52:09.140
每一次得到结果之后

52:09.140 --> 52:10.140
我就把这个东西

52:10.140 --> 52:12.140
跟这个东西来处合并且

52:12.140 --> 52:13.140
然后再写回去

52:13.140 --> 52:14.140
处合处还是处

52:14.140 --> 52:15.140
又写回去还是处

52:15.140 --> 52:16.140
然后那接下来

52:16.140 --> 52:18.140
5处合处还是处

52:18.140 --> 52:20.140
又把它写回去还是处

52:20.140 --> 52:22.140
这里1处合处还是处

52:22.140 --> 52:23.140
那么最终它为处

52:23.140 --> 52:24.140
就表示找到了

52:24.140 --> 52:25.140
全是

52:26.140 --> 52:27.140
就全是

52:27.140 --> 52:29.140
那如果说有一个是force

52:29.140 --> 52:30.140
来看

52:30.140 --> 52:31.140
处合处还是处

52:31.140 --> 52:32.140
写回去处

52:32.140 --> 52:33.140
然后5

52:33.140 --> 52:35.140
force和处是不是得到force

52:35.140 --> 52:37.140
force和处得到force

52:37.140 --> 52:39.140
那么就是force

52:40.140 --> 52:42.140
看到是force就结束了

52:43.140 --> 52:44.140
我们来判断这个东西

52:44.140 --> 52:45.140
就行了

52:45.140 --> 52:46.140
所以说我们这里

52:46.140 --> 52:47.140
循环

52:47.140 --> 52:48.140
i等于0

52:48.140 --> 52:50.140
i小于num3

52:50.140 --> 52:51.140
i加加

52:54.140 --> 52:55.140
是否全是

52:55.140 --> 52:56.140
我只要看一下

52:56.140 --> 52:57.140
这一块是不是

52:57.140 --> 52:58.140
然后跟它自己

52:58.140 --> 52:59.140
来求一个并且

52:59.140 --> 53:00.140
对吧

53:00.140 --> 53:01.140
所以说我们result

53:01.140 --> 53:02.140
重新复制

53:03.140 --> 53:04.140
并且include

53:05.140 --> 53:06.140
num

53:06.140 --> 53:07.140
num3

53:08.140 --> 53:09.140
这啥意思

53:09.140 --> 53:11.140
我看一下这个数

53:11.140 --> 53:12.140
在它里面存在存在

53:12.140 --> 53:13.140
比方说看2

53:13.140 --> 53:14.140
对吧

53:14.140 --> 53:15.140
在num里面存不存在

53:15.140 --> 53:16.140
那么存在的话

53:16.140 --> 53:17.140
它就是q

53:17.140 --> 53:18.140
不存在就是force

53:18.140 --> 53:19.140
把它这个结果

53:19.140 --> 53:21.140
跟result来求一个并且

53:21.140 --> 53:23.140
然后再重新给result复制

53:23.140 --> 53:24.140
对不对

53:24.140 --> 53:26.140
然后我们来看一下result的值

53:26.140 --> 53:27.140
如果result值

53:27.140 --> 53:28.140
已经变成了force了

53:29.140 --> 53:30.140
就break

53:30.140 --> 53:31.140
那就停止

53:31.140 --> 53:32.140
当然不停止也没关系

53:32.140 --> 53:33.140
因为后边是force

53:33.140 --> 53:35.140
跟任何数求并且

53:35.140 --> 53:36.140
都是force

53:36.140 --> 53:37.140
所以后边没意义了

53:37.140 --> 53:38.140
又可以停止了

53:38.140 --> 53:39.140
如果已经

53:39.140 --> 53:40.140
不全是了

53:40.140 --> 53:41.140
那就停止了

53:41.140 --> 53:42.140
最后来我们来判断一下

53:42.140 --> 53:43.140
这个result

53:44.140 --> 53:45.140
输出

53:45.140 --> 53:46.140
result为处

53:46.140 --> 53:47.140
那就输出4

53:47.140 --> 53:48.140
全部都存在

53:48.140 --> 53:49.140
全部都是有的

53:49.140 --> 53:51.140
否则的话就输出4

53:52.140 --> 53:53.140
这两种显法都可以

53:54.140 --> 53:55.140
这道题有点复杂

53:57.140 --> 53:58.140
但是这道题再复杂

53:58.140 --> 54:00.140
你想象一下

54:00.140 --> 54:02.140
如果说没有这个函数

54:02.140 --> 54:05.770
那这个复杂程度

54:05.770 --> 54:07.770
我都不是考元老师能讲

54:07.770 --> 54:08.770
就给人家讲得明白的

54:10.770 --> 54:11.770
那就是复杂

54:11.770 --> 54:12.770
真的是特别特别复杂

54:13.770 --> 54:14.770
就是因为这个函数

54:14.770 --> 54:15.770
帮了忙

54:15.770 --> 54:16.770
尽管这个道题很复杂

54:16.770 --> 54:17.770
但是

54:17.770 --> 54:19.770
至少有少部分同学

54:19.770 --> 54:20.770
几少部分同学

54:20.770 --> 54:22.770
也能够听得懂

54:24.770 --> 54:25.770
好了 那就完了

54:26.770 --> 54:27.770
这就是咱们这节课

54:27.770 --> 54:29.770
先对函数最基本最基本的东西

54:29.770 --> 54:31.770
其实最基本也是最重要的

54:31.770 --> 54:33.770
就函数了一些

54:33.770 --> 54:34.770
概念性的东西

54:34.770 --> 54:35.770
想法性的东西

54:35.770 --> 54:37.770
如何给我们写的按把

54:37.770 --> 54:38.770
连接起来的东西

54:39.770 --> 54:40.770
做了一个复杂

54:41.770 --> 54:42.770
好 这两道题好好去练习一下

