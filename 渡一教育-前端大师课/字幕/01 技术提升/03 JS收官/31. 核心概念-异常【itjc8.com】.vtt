WEBVTT

00:00.000 --> 00:02.840
好了 我们这节课来聊一聊

00:02.840 --> 00:05.440
很多同学都比较害怕的一个话题

00:05.440 --> 00:07.480
就是异常

00:07.480 --> 00:10.200
异常是什么呢 其实就是错误

00:10.200 --> 00:12.280
就是我们程序中发生的错误

00:12.280 --> 00:14.360
也就是我们程序里面发生的问题

00:14.360 --> 00:16.240
我说这个程序有错误

00:16.240 --> 00:18.040
说明它这个程序有异常

00:18.040 --> 00:19.720
这个程序有问题

00:19.720 --> 00:23.480
其实有问题它并不是一件坏事

00:23.480 --> 00:27.240
这个世界上不存在说一个程序它没有问题

00:27.240 --> 00:29.280
所有的程序都有问题

00:29.640 --> 00:30.760
关键是什么呢

00:30.760 --> 00:34.720
关键是我们要知道问题在哪

00:34.720 --> 00:36.240
就像我们人一样 对吧

00:36.240 --> 00:38.840
人会不会有一个人 他没有问题

00:38.840 --> 00:39.920
不会的

00:39.920 --> 00:43.320
人总是伴随着一生的问题

00:43.320 --> 00:46.680
袁老师在高中的时候就深刻地意识到了这一点

00:46.680 --> 00:50.320
要学会长期与问题相处

00:50.320 --> 00:53.000
就是你是没有办法全部解决掉的

00:53.000 --> 00:55.000
总会有这样那样的问题

00:55.000 --> 00:58.280
而且很多时候你解决一个问题

00:58.320 --> 01:00.960
你会发现又出现了一些新的问题

01:00.960 --> 01:04.080
长期与问题共处

01:04.080 --> 01:05.880
意识到问题的存在

01:05.880 --> 01:08.920
然后解决自己想要解决的

01:08.920 --> 01:11.720
优先级比较高的比较重要的问题

01:11.720 --> 01:13.160
比较严重的问题

01:13.160 --> 01:15.960
有些问题好解决 有些问题不好解决

01:15.960 --> 01:17.960
人的一生就是这样子

01:18.840 --> 01:20.280
有些同学可能是

01:20.280 --> 01:21.320
有着这么一种心态

01:21.320 --> 01:24.240
就是老师想回避问题

01:24.240 --> 01:26.280
我不想知道自己的问题在哪

01:26.280 --> 01:27.720
我也不想去想它

01:27.720 --> 01:31.480
我觉得问题是一件非常痛苦的一件事

01:31.480 --> 01:33.720
其实不应该是这样的一个心态

01:33.720 --> 01:37.320
要学会长期与问题共处

01:37.320 --> 01:39.120
这样子你会常

01:39.120 --> 01:41.680
因为你意识到这些问题所在

01:41.680 --> 01:43.000
你能看得见它

01:43.000 --> 01:44.960
你能感受得到它

01:44.960 --> 01:48.440
因此你才有可能会去解决它

01:48.440 --> 01:51.320
如果说你都不能意识到自己有问题

01:51.320 --> 01:52.960
不知道问题在呢

01:52.960 --> 01:54.720
谈何解决呢

01:54.720 --> 01:55.760
对吧

01:55.760 --> 01:59.200
而且长期与问题共处的话

01:59.200 --> 02:01.280
随着你不断的去解决问题

02:01.280 --> 02:03.400
当然也会产生新的问题

02:03.400 --> 02:05.920
你这个人就会越来越强大

02:07.120 --> 02:08.080
说远了

02:08.080 --> 02:09.760
我们说回到我们的程序

02:09.760 --> 02:12.560
其实异常并不是一件坏事

02:12.560 --> 02:15.240
它是在不断的提醒开发人员

02:15.240 --> 02:16.920
你这一块有问题

02:16.920 --> 02:17.960
你要不要解决

02:17.960 --> 02:20.240
有些问题我们可能就不解决了

02:20.240 --> 02:21.960
有些问题真的有些问题

02:21.960 --> 02:23.760
我们就可能不解决了

02:23.760 --> 02:25.360
比方说举个例子

02:26.760 --> 02:27.920
举个什么例子呢

02:27.920 --> 02:29.920
比方说我有两个书

02:30.920 --> 02:34.920
这个两个书是来自于用户的输入

02:34.920 --> 02:36.320
比方说是个数字1

02:36.320 --> 02:38.760
数字2来自于用户的输入

02:38.760 --> 02:42.480
那如果说用户输入的两个都是0

02:42.480 --> 02:44.760
那么我要做一个处法

02:44.760 --> 02:48.160
0和0相处是不是等于NAN

02:48.160 --> 02:51.160
那么NAN在经过后边的运算的时候

02:51.160 --> 02:53.560
就可能会产生一些问题

02:53.760 --> 02:55.160
那么这些问题可能是

02:55.160 --> 02:57.160
就是用户自己不遵守规则

02:57.160 --> 02:58.560
自己随便输入的

02:58.560 --> 03:01.160
有可能我们就不解决

03:01.160 --> 03:02.360
所以有些问题

03:02.360 --> 03:04.160
我们确实是可以不用解决的

03:04.160 --> 03:07.560
但是你要意识到这里可能是有问题的

03:07.560 --> 03:08.960
这个很重要

03:08.960 --> 03:11.160
程序这一块文讲异常

03:11.160 --> 03:14.160
最重要的同学们要学习的是什么呢

03:14.160 --> 03:15.960
不要害怕错误

03:15.960 --> 03:18.160
不要害怕异常

03:18.160 --> 03:20.360
出现异常表示我们程序里边

03:20.360 --> 03:22.560
出现了一些小的隐患

03:22.560 --> 03:24.560
或者是一些小的问题

03:24.560 --> 03:26.560
我们要知道它的存在

03:26.560 --> 03:28.560
我们要知道它发生的原因

03:28.560 --> 03:30.560
至于解不解决它

03:30.560 --> 03:31.560
我们再说

03:31.560 --> 03:32.560
懂得意思吗

03:32.560 --> 03:34.560
这是关于这个异常

03:34.560 --> 03:36.560
其实你开发做多了你会发现

03:36.560 --> 03:38.560
真正可怕的是什么

03:38.560 --> 03:40.560
它没有异常

03:40.560 --> 03:42.560
这个是最可怕的

03:42.560 --> 03:43.560
就是程序非常干净

03:43.560 --> 03:44.560
但是你会发现

03:44.560 --> 03:46.560
它这个程序运行的过程中

03:46.560 --> 03:48.560
得到了结果跟你不一样

03:48.560 --> 03:50.560
这是最麻烦的

03:50.560 --> 03:52.560
我们夏杰克说这种情况

03:52.560 --> 03:53.560
就是这个程序的结果

03:53.560 --> 03:55.560
跟你想象的不一样

03:55.560 --> 03:57.560
那么程序肯定是有问题对吧

03:57.560 --> 03:59.560
但是它又没有给你爆错

03:59.560 --> 04:01.560
那么这种情况就不好调试了

04:01.560 --> 04:03.560
其实很多时候爆错

04:03.560 --> 04:05.560
非常非常好调试

04:05.560 --> 04:07.560
咱们来看一下

04:07.560 --> 04:08.560
有的时候我们在浏览期里面

04:08.560 --> 04:10.560
会看到这样子一个红色的语句

04:10.560 --> 04:11.560
对吧

04:11.560 --> 04:12.560
它告诉你程序里面有错误

04:12.560 --> 04:13.560
不要害怕

04:13.560 --> 04:15.560
它其实在这条语句里面

04:15.560 --> 04:17.560
告诉你了非常非常多的信息

04:17.560 --> 04:19.560
我们要通过这些信息

04:19.560 --> 04:21.560
就找到错误发生的原因

04:21.560 --> 04:23.560
异常本身并不是坏事

04:23.560 --> 04:25.560
它可以让开发人员发现错误

04:25.560 --> 04:26.560
定位错误

04:26.560 --> 04:28.560
甚至在某些时候

04:28.560 --> 04:30.560
我们还要故意的抛出异常

04:30.560 --> 04:31.560
它没有爆错

04:31.560 --> 04:32.560
但我们故意让它爆错

04:32.560 --> 04:34.560
都是有可能的

04:34.560 --> 04:36.560
我们首先来看异常的分类

04:36.560 --> 04:38.560
就是错误有哪些类型

04:38.560 --> 04:40.560
在JS里面

04:40.560 --> 04:42.560
异常表现为一个对象

04:42.560 --> 04:44.560
这个对象就是一个普通对象

04:44.560 --> 04:45.560
不同的对象

04:45.560 --> 04:47.560
它表达了不同的异常类型

04:47.560 --> 04:48.560
不同的异常类型

04:48.560 --> 04:49.560
对应到不同的错误

04:49.560 --> 04:50.560
我们来看一下

04:50.560 --> 04:52.560
我们常见的异常类型

04:52.560 --> 04:53.560
有三种

04:53.560 --> 04:55.560
一种叫做愚法错误

04:55.560 --> 04:58.560
Syntax Error

04:58.560 --> 04:59.560
愚法错误

04:59.560 --> 05:01.560
那么这种错误什么时候发生的

05:01.560 --> 05:02.560
就是你愚法写错了

05:02.560 --> 05:08.700
比方说你在这里面写了一个

05:08.700 --> 05:10.700
这就是一个愚法错误

05:10.700 --> 05:12.700
Syntax Error

05:12.700 --> 05:13.700
那么这个错误发生之后

05:13.700 --> 05:14.700
你就知道了

05:14.700 --> 05:16.700
你凡是看到这个单词

05:16.700 --> 05:17.700
你就知道了

05:17.700 --> 05:19.700
这个程序里面愚法都是有问题的

05:19.700 --> 05:21.700
比方说

05:21.700 --> 05:23.700
这里面你写的是

05:23.700 --> 05:25.700
复讯环的时候单词打错了

05:25.700 --> 05:27.700
打成这个复讯环了

05:27.700 --> 05:28.700
怎么样

05:28.700 --> 05:30.700
比方说我们这里写个

05:30.700 --> 05:31.700
I小于10

05:31.700 --> 05:32.700
I加加

05:32.700 --> 05:33.700
写上这么一个东西

05:33.700 --> 05:35.700
是不是就愚法错误

05:35.700 --> 05:36.700
它告诉你什么

05:36.700 --> 05:38.700
unexpected token

05:38.700 --> 05:40.700
就是

05:40.700 --> 05:42.700
超出预期的

05:42.700 --> 05:44.700
一个关键字

05:44.700 --> 05:46.700
VAR

05:46.700 --> 05:48.700
它本来是包在这的

05:48.700 --> 05:50.700
因为它不认识前面的东西

05:50.700 --> 05:52.700
其实你看一下它周围的代码

05:52.700 --> 05:54.700
你大概就知道了

05:54.700 --> 05:55.700
有个地方写错了

05:55.700 --> 05:57.700
这叫做愚法错误

05:57.700 --> 05:59.700
第二种错误是

05:59.700 --> 06:01.700
Reverence Error

06:01.700 --> 06:02.700
这种引用错误

06:02.700 --> 06:04.700
这个东西往往是使用了

06:04.700 --> 06:06.700
未定义的变量或者是寒树

06:06.700 --> 06:07.700
比方说

06:07.700 --> 06:09.700
我们这里写

06:09.700 --> 06:11.700
我们用一个什么A

06:11.700 --> 06:12.700
去调用

06:12.700 --> 06:13.700
把它当成寒树来调用

06:13.700 --> 06:14.700
有没有这个A

06:14.700 --> 06:15.700
是没有这个A

06:15.700 --> 06:16.700
那么这个时候

06:16.700 --> 06:18.700
它就会包一个Reverence Error

06:18.700 --> 06:21.700
A is not defined

06:21.700 --> 06:22.700
它没有被定义

06:22.700 --> 06:24.700
就是它从来没有定一个变量

06:24.700 --> 06:25.700
或者定一个寒树

06:25.700 --> 06:26.700
因此你直接使用它

06:26.700 --> 06:28.700
它会包这个引用错误

06:28.700 --> 06:29.700
还包括什么呢

06:29.700 --> 06:32.700
你使用一个变量B

06:32.700 --> 06:34.700
所以也会包这个错误

06:34.700 --> 06:35.700
B is not defined

06:35.700 --> 06:36.700
对吧

06:36.700 --> 06:38.700
好 再往下看

06:38.700 --> 06:39.700
Type Error

06:39.700 --> 06:41.700
这种错误是发生在最频繁的错误

06:41.700 --> 06:43.700
叫内形错误

06:43.700 --> 06:45.700
往往是使用了一个对象中

06:45.700 --> 06:46.700
不存在的成员

06:46.700 --> 06:48.700
都是比较普遍的情况

06:48.700 --> 06:49.700
比方说

06:49.700 --> 06:51.700
我这里有一个

06:51.700 --> 06:53.700
变量

06:53.700 --> 06:55.700
定义的

06:55.700 --> 06:57.700
但是我这里没有给它复制

06:57.700 --> 07:00.700
接下来我把它当成对象来使用

07:00.700 --> 07:02.700
使用 比方说它的

07:02.700 --> 07:04.700
Toxicin

07:05.700 --> 07:07.700
那么这个时候就会包一个内形错误

07:07.700 --> 07:08.700
它告诉你

07:08.700 --> 07:10.700
无法读取属性

07:10.700 --> 07:11.700
从哪里读呢

07:11.700 --> 07:13.700
就是一个undefined里面去读一个属性

07:13.700 --> 07:14.700
读什么属性呢

07:14.700 --> 07:15.700
读Toxicin

07:15.700 --> 07:18.700
你看这个错误信息是否描述得非常详细

07:18.700 --> 07:20.700
这就是个Type Error

07:20.700 --> 07:21.700
对吧

07:21.700 --> 07:22.700
你这个A

07:22.700 --> 07:23.700
它的内形是什么

07:23.700 --> 07:24.700
内形是undefined

07:24.700 --> 07:26.700
undefined里面是没有这个Toxicin的

07:26.700 --> 07:28.700
对吧 就是个内形错误

07:28.700 --> 07:30.700
包括NOW也是这样子

07:30.700 --> 07:31.700
如果说定义变量

07:31.700 --> 07:32.700
它的值是NOW

07:32.700 --> 07:35.700
那么你去用它的一个方法

07:35.700 --> 07:37.700
它也会包这个错误

07:37.700 --> 07:39.700
无法读取属性

07:39.700 --> 07:40.700
然后里面读取属性

07:40.700 --> 07:41.700
读这个属性

07:41.700 --> 07:42.700
它说什么意思

07:42.700 --> 07:49.700
这就是内形错误

07:49.700 --> 07:50.700
还包括这种

07:50.700 --> 07:55.700
A里面有一个属性ABC

07:55.700 --> 07:58.700
那么现在我想把NAME

07:58.700 --> 07:59.700
读出来 这个没问题

07:59.700 --> 08:00.700
但是如果说

08:00.700 --> 08:02.700
我把它当成一个函数来读

08:02.700 --> 08:03.700
调用的话

08:03.700 --> 08:04.700
它会发生内形错误

08:04.700 --> 08:05.700
它说这个玩意

08:05.700 --> 08:07.700
它并不是一个方形

08:07.700 --> 08:08.700
不是一个函数

08:08.700 --> 08:10.700
它的内形是一个制服串

08:10.700 --> 08:11.700
并不是函数

08:11.700 --> 08:13.700
这些都是属于内形错误

08:13.700 --> 08:15.700
那么除了这三种之外

08:15.700 --> 08:18.700
其实它还有一些别的错误内形

08:18.700 --> 08:19.700
不过那些错误内形

08:19.700 --> 08:21.700
我们遇到了基本上很少很少

08:21.700 --> 08:23.700
所以说这里不再介绍了

08:23.700 --> 08:24.700
如果说

08:24.700 --> 08:26.700
希望知道更多的错误内形的话

08:26.700 --> 08:27.700
可以参与MDN

08:27.700 --> 08:28.700
你可以进这个网站

08:28.700 --> 08:30.700
官方网站里面去看一下

08:30.700 --> 08:32.700
这边 你看

08:32.700 --> 08:34.700
这些都是它的各种错误内形

08:34.700 --> 08:36.700
它预定义的

08:37.700 --> 08:38.700
始终记住

08:38.700 --> 08:40.700
每一个异常都是一个对象

08:40.700 --> 08:42.700
那么这个对象哪来的呢

08:42.700 --> 08:43.700
它是通过对应的

08:43.700 --> 08:45.700
构造函数创建的

08:45.700 --> 08:46.700
啥意思

08:46.700 --> 08:47.700
比方说这个type error

08:47.700 --> 08:49.700
是一个内形错误

08:49.700 --> 08:50.700
那么你看这

08:51.700 --> 08:56.360
我们比方说

08:56.360 --> 08:58.360
就这个玩意吧

08:58.360 --> 09:00.360
这是一个内形错误

09:00.360 --> 09:02.360
它实际上是一个对象

09:02.360 --> 09:03.360
这个对象里边

09:03.360 --> 09:05.360
它的对象哪来的呢

09:05.360 --> 09:07.360
是通过一个构造函数创建的

09:07.360 --> 09:08.360
哪个构造函数呢

09:08.360 --> 09:10.360
就识这个各种函数

09:10.360 --> 09:11.360
比方说我们这个type error

09:11.360 --> 09:14.360
它就是溜了一个type error

09:14.360 --> 09:16.360
这里边写错误消息

09:16.360 --> 09:20.360
比方说adder name is not a function

09:21.360 --> 09:22.360
对 这就产生了一个错误

09:22.360 --> 09:24.360
你看type error

09:24.360 --> 09:26.360
这就是一个

09:26.360 --> 09:27.360
错误对象

09:27.360 --> 09:28.360
不是产生一个错误

09:28.360 --> 09:29.360
它是一个错误对象

09:29.360 --> 09:31.360
那么这个错误对象呢

09:31.360 --> 09:33.360
如果说我要把它用一个

09:33.360 --> 09:35.360
控制台用error的方式

09:35.360 --> 09:38.360
这个是用一个错误的格式把它打印出来

09:39.360 --> 09:41.360
把它放到一个变量里边吧

09:41.360 --> 09:46.460
把它放到一个变量里边

09:47.460 --> 09:49.460
比方说我用cancel error

09:49.460 --> 09:51.460
把这个错误打印出来

09:51.460 --> 09:52.460
它就是这个效果

09:52.460 --> 09:54.460
你看看是不是就是这个效果

09:54.460 --> 09:55.460
这就是一个错误对象

09:55.460 --> 09:56.460
错误就是一个对象

09:56.460 --> 09:59.460
对象通过一个构造函数来创建的

09:59.460 --> 10:00.460
那么这个

10:00.460 --> 10:01.460
我们没有创建它吧

10:01.460 --> 10:03.460
那谁来创建这个错误的

10:03.460 --> 10:04.460
是不是就是浏览器

10:04.460 --> 10:06.460
浏览器发现了一个问题

10:06.460 --> 10:09.460
于是它帮你创建了一个对应的错误对象

10:09.460 --> 10:12.460
显示到了控制台

10:12.460 --> 10:13.460
就这么个意思

10:14.460 --> 10:16.460
在张丹丹把运行过程中

10:16.460 --> 10:17.460
出现错误的时候

10:17.460 --> 10:19.460
JS会做这么几件事

10:19.460 --> 10:22.460
你自动创建对应的异常对象

10:22.460 --> 10:24.460
抛出错误

10:24.460 --> 10:25.460
比方说他遇到了

10:25.460 --> 10:27.460
你再调用一个name方法

10:27.460 --> 10:28.460
但是没有这个方法

10:28.460 --> 10:30.460
这个name是一个致富串

10:30.460 --> 10:31.460
于是浏览器

10:31.460 --> 10:34.460
它就会自动的帮你创建一个type error

10:34.460 --> 10:36.460
然后把错误消息给你写好

10:36.460 --> 10:37.460
写好之后

10:37.460 --> 10:39.460
给你抛出来

10:39.460 --> 10:43.460
然后程序终止运行

10:43.460 --> 10:44.460
就程序不再往后运行了

10:44.460 --> 10:46.460
因为已经出现了一个错误了

10:46.460 --> 10:47.460
需要你处理

10:47.460 --> 10:48.460
但是你没有处理

10:48.460 --> 10:50.460
它就不再继续往后运行了

10:50.460 --> 10:52.460
程序终止

10:52.460 --> 10:53.460
要出现问题

10:53.460 --> 10:55.460
你再继续运行的话

10:55.460 --> 10:56.460
那个程序

10:56.460 --> 10:58.460
首先逻辑上就说不通了对吧

10:58.460 --> 11:00.460
比方说

11:00.460 --> 11:01.460
我这里

11:01.460 --> 11:03.460
我这里举个例子吧

11:03.460 --> 11:05.460
我这个name当成方法来调用

11:05.460 --> 11:07.460
我要把它保存到变量b里边

11:07.460 --> 11:11.460
然后我这后边要输出b

11:11.460 --> 11:12.460
那这个代码

11:12.460 --> 11:14.460
这个地方是不是就爆错了

11:14.460 --> 11:15.460
对吧

11:15.460 --> 11:16.460
那么这个地方爆错了

11:16.460 --> 11:18.460
这个b就没法复制了

11:18.460 --> 11:20.460
因为这个玩意它不是一个函数

11:20.460 --> 11:22.460
它拿不到这个表拉式的值

11:22.460 --> 11:24.460
它就没有办法给b复制

11:24.460 --> 11:25.460
没有办法给b复制

11:25.460 --> 11:27.460
它就无法往后继续运行

11:27.460 --> 11:28.460
打硬着b

11:28.460 --> 11:29.460
这个程序就终止了

11:29.460 --> 11:30.460
在哪里终止

11:30.460 --> 11:32.460
在这里就终止了

11:32.460 --> 11:34.460
我们来看一下

11:34.460 --> 11:35.460
是不是

11:35.460 --> 11:36.460
没有输出b吧

11:36.460 --> 11:37.460
没有吧

11:37.460 --> 11:38.460
对吧

11:38.460 --> 11:39.460
我们来看一下b

11:39.460 --> 11:40.460
b是不是还是undefined的

11:40.460 --> 11:42.460
它拿不到值

11:42.460 --> 11:43.460
就这么个意思

11:43.460 --> 11:44.460
只要出现了错误

11:44.460 --> 11:46.460
程序不再往后继续运行

11:46.460 --> 11:48.460
立即终止

11:48.460 --> 11:50.460
然后控制台里边

11:50.460 --> 11:52.460
会显示异常对象

11:52.460 --> 11:53.460
就是我们刚才看到的

11:53.460 --> 11:54.460
你出现了错误

11:54.460 --> 11:55.460
对吧

11:55.460 --> 11:56.460
你又没有处理

11:56.460 --> 11:57.460
那么程序终止

11:57.460 --> 11:59.460
然后同时在控制台里边

11:59.460 --> 12:00.460
打印出这个错误

12:01.460 --> 12:03.460
你开发者来进行观察

12:04.460 --> 12:05.460
这就是

12:05.460 --> 12:06.460
即使它自动

12:06.460 --> 12:07.460
会完成的事

12:08.460 --> 12:09.460
它把这个东西

12:09.460 --> 12:10.460
打印到控制台里边

12:10.460 --> 12:11.460
我们就可以观察

12:11.460 --> 12:12.460
这个错误对象了

12:12.460 --> 12:14.460
每一个异常对象里边

12:14.460 --> 12:16.460
都记录了两个关键信息

12:16.460 --> 12:18.460
一个是错误描述信息

12:19.460 --> 12:20.460
就是描述了

12:20.460 --> 12:21.460
异常出现的原因

12:21.460 --> 12:22.460
我们看这

12:22.460 --> 12:23.460
是不是

12:23.460 --> 12:25.460
这就是错误描述信息

12:25.460 --> 12:26.460
每一个异常对象里边

12:26.460 --> 12:27.460
都会有这个东西

12:27.460 --> 12:28.460
其实我们在

12:28.460 --> 12:30.460
创建异常对象的时候

12:31.460 --> 12:32.460
它第一个

12:32.460 --> 12:33.460
构造函数的

12:33.460 --> 12:34.460
第一个参数

12:34.460 --> 12:35.460
它就会让你告诉它

12:35.460 --> 12:36.460
错误的描述信息

12:36.460 --> 12:37.460
随便描述

12:37.460 --> 12:38.460
描述了过后

12:38.460 --> 12:39.460
这个对象

12:39.460 --> 12:40.460
它里边就是这个描述信息

12:41.460 --> 12:42.460
就这么一个意思

12:42.460 --> 12:43.460
然后还有

12:43.460 --> 12:44.460
第二个信息

12:44.460 --> 12:46.460
就是调用堆战信息

12:47.460 --> 12:49.460
它可以描述异常出现的位置

12:49.460 --> 12:51.460
是在代码的哪一行

12:51.460 --> 12:52.460
出现的异常

12:53.460 --> 12:54.460
那么这个玩意

12:54.460 --> 12:55.460
我们在代码里边来看

12:55.460 --> 12:56.460
比方说

12:56.460 --> 12:59.900
我写了一个

13:02.900 --> 13:03.900
然后的话

13:03.900 --> 13:05.900
我们再写个解释吧

13:06.900 --> 13:07.900
我们在

13:07.900 --> 13:08.900
解释里边来去

13:08.900 --> 13:09.900
引用一下这个解释

13:17.020 --> 13:18.020
在解释里边

13:18.020 --> 13:19.020
我们这样子写

13:19.020 --> 13:21.020
写一个方法

13:21.020 --> 13:22.020
A

13:22.020 --> 13:24.020
然后里边

13:24.020 --> 13:26.020
输出A

13:26.020 --> 13:27.020
Start

13:28.020 --> 13:30.020
然后再输出A

13:30.020 --> 13:31.020
End

13:31.020 --> 13:33.020
调用方法B

13:33.020 --> 13:35.020
或者调用函数B

13:35.020 --> 13:37.020
然后我们再输写一个

13:37.020 --> 13:39.020
函数B

13:39.020 --> 13:41.020
输出BStart

13:41.020 --> 13:44.020
然后再输出BEnd

13:44.020 --> 13:46.020
再调用函数C

13:47.020 --> 13:49.020
在函数C里边

13:49.020 --> 13:52.020
我们就输出CStart

13:52.020 --> 13:53.020
接下来

13:53.020 --> 13:55.020
我们来让它引发一个错误

13:55.020 --> 13:56.020
怎么引发错误

13:56.020 --> 13:57.020
非常简单

13:57.020 --> 13:58.020
我就这样子写

13:58.020 --> 13:59.020
订了一个A

13:59.020 --> 14:01.020
然后输出A.NET

14:01.020 --> 14:02.020
然后这样子的A.NET

14:02.020 --> 14:03.020
拿不到

14:03.020 --> 14:05.020
所以说就会引发错误

14:05.020 --> 14:06.020
好

14:06.020 --> 14:07.020
然后我们在全局里边

14:07.020 --> 14:09.020
去调用函数C

14:09.020 --> 14:11.020
你看一下这个错误发生的

14:11.020 --> 14:12.020
流程

14:12.020 --> 14:14.020
先是外层

14:14.020 --> 14:15.020
外层是

14:15.020 --> 14:16.020
我们来画个框框

14:16.020 --> 14:18.020
外层是函数A

14:18.020 --> 14:19.020
函数A里边

14:19.020 --> 14:20.020
去调用

14:20.020 --> 14:21.020
完成是全局

14:21.020 --> 14:22.020
对吧

14:22.020 --> 14:23.020
全局代码

14:23.020 --> 14:24.020
全局代码里边

14:24.020 --> 14:26.020
调用了函数A

14:27.020 --> 14:28.020
函数A里边

14:28.020 --> 14:30.020
调用了函数B

14:30.020 --> 14:31.020
函数B里边

14:31.020 --> 14:33.020
调用了函数C

14:33.020 --> 14:34.020
这里边

14:34.020 --> 14:36.020
是不是引发了一个错误

14:36.020 --> 14:37.020
对吧

14:37.020 --> 14:39.020
什么叫错误堆战信息

14:39.020 --> 14:40.020
就是这个错误

14:40.020 --> 14:41.020
最终

14:41.020 --> 14:43.020
是在哪个函数里边引发的

14:43.020 --> 14:44.020
那么

14:44.020 --> 14:46.020
这个函数里边

14:46.020 --> 14:47.020
在C里边引发的

14:47.020 --> 14:48.020
在C里边引发的错误

14:48.020 --> 14:50.020
在这里发生了错误

14:50.020 --> 14:51.020
然后

14:51.020 --> 14:53.020
是谁在调用函数

14:53.020 --> 14:55.020
是函数B

14:55.020 --> 14:57.020
函数B又是谁在调用的

14:57.020 --> 14:58.020
是函数A

14:58.020 --> 14:59.020
函数A是谁在调用的

14:59.020 --> 15:00.020
全局

15:00.020 --> 15:01.020
对吧

15:01.020 --> 15:02.020
这就是堆战信息

15:02.020 --> 15:03.020
好

15:03.020 --> 15:04.020
我们用了这个解释过后

15:04.020 --> 15:05.020
我们来看一下浏览器

15:05.020 --> 15:07.580
就知道了

15:07.580 --> 15:10.580
打开浏览器

15:10.580 --> 15:12.580
先来看一下错误

15:12.580 --> 15:13.580
你会发现

15:13.580 --> 15:14.580
首先看那个错误打印

15:14.580 --> 15:15.580
A start

15:15.580 --> 15:16.580
B start

15:16.580 --> 15:17.580
C start

15:17.580 --> 15:18.580
也就是说

15:18.580 --> 15:19.580
这个代码里边

15:19.580 --> 15:20.580
这个东西正常运行了

15:20.580 --> 15:21.580
调用B

15:21.580 --> 15:23.580
这个东西正常运行

15:23.580 --> 15:24.580
调用C

15:24.580 --> 15:26.580
这个东西正常运行

15:26.580 --> 15:27.580
运行之后

15:27.580 --> 15:28.580
这里是不是发生了错误

15:28.580 --> 15:29.580
发生错误过后

15:29.580 --> 15:30.580
C没有办法继续了

15:30.580 --> 15:32.580
比如这里还有一个C end

15:32.580 --> 15:33.580
C end能不能打印

15:33.580 --> 15:34.580
它没法打印了

15:34.580 --> 15:35.580
程序不发继续了

15:35.580 --> 15:37.580
这里发生了错误

15:37.580 --> 15:39.580
那么这里没发继续了

15:39.580 --> 15:41.580
就会导致C就终止了

15:41.580 --> 15:42.580
B一看

15:42.580 --> 15:44.580
C你运行过程中

15:44.580 --> 15:45.580
出现了问题

15:45.580 --> 15:46.580
这个问题

15:46.580 --> 15:47.580
你没有解决

15:47.580 --> 15:49.580
你C没有解决这个问题

15:49.580 --> 15:50.580
我怎么解决呢

15:50.580 --> 15:51.580
我也解决不了

15:51.580 --> 15:52.580
也就是它就运行

15:52.580 --> 15:53.580
C的过程中

15:53.580 --> 15:55.580
它也发生了错误

15:55.580 --> 15:57.580
那么于是B

15:57.580 --> 16:00.580
导致了B也引发错误

16:00.580 --> 16:02.580
B引发了错误之后

16:02.580 --> 16:04.580
它这个错误也没有解决

16:04.580 --> 16:06.580
这个代码也不能运行

16:06.580 --> 16:07.580
B也终止了

16:07.580 --> 16:09.580
然后又到了A这里

16:09.580 --> 16:11.580
就发现我也不知道

16:11.580 --> 16:12.580
B里面做了啥

16:12.580 --> 16:14.580
反正就是B里面出现了错误

16:14.580 --> 16:15.580
出现了错误

16:15.580 --> 16:17.580
我这里也跟着爆错了

16:17.580 --> 16:18.580
我这里也没法解决了

16:18.580 --> 16:20.580
那么它也终止运行

16:20.580 --> 16:21.580
好像回到了全局

16:21.580 --> 16:24.580
比如说这里写个Global End

16:24.580 --> 16:26.580
全局这里

16:26.580 --> 16:27.580
发现调用A

16:27.580 --> 16:28.580
我也不知道A里面做了啥

16:28.580 --> 16:30.580
反正A里面也有一个错误

16:30.580 --> 16:32.580
不管是直接错误还是间接错误

16:32.580 --> 16:33.580
反正它有一个错误

16:33.580 --> 16:35.580
然后我也没法继续了

16:35.580 --> 16:37.580
那么这句话也不会输出

16:37.580 --> 16:38.580
所以最终

16:38.580 --> 16:40.580
以后表我们写了这么多输出语句

16:40.580 --> 16:42.580
其实最终输出的就是

16:42.580 --> 16:44.580
没有错误的那一段

16:44.580 --> 16:46.580
就是这三个

16:46.580 --> 16:47.580
你看一下

16:47.580 --> 16:50.580
然后它把错误给打印出来了

16:50.580 --> 16:52.580
堆战信息是什么

16:52.580 --> 16:53.580
看下边

16:53.580 --> 16:55.580
这就是堆战信息

16:55.580 --> 16:58.580
它告诉你错误是在哪里引发的

16:58.580 --> 17:00.580
最终是在C里面引发的

17:00.580 --> 17:02.580
为什么会在C里面引发的

17:02.580 --> 17:04.580
是因为B在调用C

17:04.580 --> 17:05.580
为什么会在B里面引发的

17:05.580 --> 17:06.580
是因为A在调用B

17:06.580 --> 17:08.580
为什么会在A里面引发的

17:08.580 --> 17:10.580
是因为在全局里面调用了A

17:10.580 --> 17:13.580
而且它会告诉你

17:13.580 --> 17:15.580
单码的位置

17:15.580 --> 17:18.580
你看1点界是16

17:18.580 --> 17:19.580
什么意思

17:19.580 --> 17:20.580
就是第16行

17:20.580 --> 17:22.580
你看这里是不是16行

17:22.580 --> 17:24.580
在这里引发了错误

17:24.580 --> 17:25.580
指在这儿

17:25.580 --> 17:27.580
你可以看到这个错误的原因

17:27.580 --> 17:29.580
它可以非常精准的告诉你

17:29.580 --> 17:31.580
意常在哪一句引发的

17:31.580 --> 17:33.580
然后你点这儿

17:33.580 --> 17:35.580
可以知道

17:35.580 --> 17:36.580
间接的话

17:36.580 --> 17:39.580
就是在这里调用C引发的错误

17:39.580 --> 17:42.580
然后在点下边

17:42.580 --> 17:43.580
这里调用了B引发的错误

17:43.580 --> 17:45.580
其中我们平时开发的话

17:45.580 --> 17:46.580
只需要点第1个就行了

17:46.580 --> 17:48.580
第1个它给你写到后边了

17:48.580 --> 17:49.580
就写到这儿了

17:49.580 --> 17:50.580
所以以后遇到错误

17:50.580 --> 17:52.580
先看错误的描述

17:52.580 --> 17:55.580
再点击这个位置

17:55.580 --> 17:56.580
看到错误

17:56.580 --> 17:58.580
锁处的位置

17:58.580 --> 17:59.580
在哪里引发的

17:59.580 --> 18:01.580
然后再进行分析

18:01.580 --> 18:03.580
这一刻最重要的东西

18:03.580 --> 18:04.580
我就说完了

18:04.580 --> 18:06.580
你们要做的事情

18:06.580 --> 18:07.580
这一刻的知识取了之后

18:07.580 --> 18:09.580
不影响你写代码

18:09.580 --> 18:11.580
代码该咋写

18:11.580 --> 18:13.580
就是遇到错误的时候

18:13.580 --> 18:15.580
你要知道这个错误

18:15.580 --> 18:17.580
是什么意思

18:17.580 --> 18:19.580
是什么内想的错误

18:19.580 --> 18:21.580
它发生在代码的哪一行

18:22.580 --> 18:24.580
那么接下来我们来看一下

18:24.580 --> 18:25.580
这个练习题

18:25.580 --> 18:27.580
说出下边错误

18:27.580 --> 18:29.580
描述了含义

18:29.580 --> 18:31.580
以及该错误发生的原因

18:31.580 --> 18:33.580
第一个错误

18:33.580 --> 18:35.580
它是一个内想错误

18:35.580 --> 18:37.580
它说无法读取

18:37.580 --> 18:39.580
属性of love

18:39.580 --> 18:40.580
说明啥呀

18:40.580 --> 18:42.580
而且它还会告诉你

18:42.580 --> 18:44.580
你在常识读哪个属性

18:44.580 --> 18:45.580
读say hi这个属性

18:45.580 --> 18:46.580
说明什么呢

18:46.580 --> 18:47.580
说明你一定

18:47.580 --> 18:48.580
我不管你程序

18:48.580 --> 18:49.580
前面是怎么回事

18:49.580 --> 18:50.580
反正你

18:50.580 --> 18:51.580
出现这个错误

18:51.580 --> 18:53.580
那你一定是这样子的

18:53.580 --> 18:55.580
有一个东西是

18:57.580 --> 18:59.580
然后你在尝试的

18:59.580 --> 19:00.580
不管这个脑是怎么来的

19:00.580 --> 19:01.580
你可以通过别的含书

19:01.580 --> 19:02.580
返回结果

19:02.580 --> 19:03.580
给a复制

19:03.580 --> 19:04.580
反正a是一个脑

19:04.580 --> 19:06.580
编辆也不一定是a

19:06.580 --> 19:08.580
反正就是一个东西是脑

19:08.580 --> 19:09.580
然后呢

19:09.580 --> 19:10.580
你在尝试的

19:10.580 --> 19:12.580
雕用它的一个

19:12.580 --> 19:13.580
读一个属性

19:13.580 --> 19:14.580
名叫say hi

19:14.580 --> 19:16.580
不管你是把它当成方法

19:16.580 --> 19:17.580
来读

19:17.580 --> 19:18.580
还是把它当成属性来读

19:18.580 --> 19:19.580
然后这个代码

19:19.580 --> 19:20.580
就一定会无法这个错误

19:20.580 --> 19:21.580
好看一下吧

19:23.580 --> 19:24.580
你看

19:25.580 --> 19:26.580
是不是就是这个错误

19:27.580 --> 19:28.580
对吧

19:28.580 --> 19:29.580
你得知道这个错误的含义

19:29.580 --> 19:30.580
再看第二个

19:30.580 --> 19:33.580
cannot read the properties of undefined

19:33.580 --> 19:34.580
reading name

19:34.580 --> 19:35.580
啥意思啊

19:35.580 --> 19:37.580
就是有一个东西

19:37.580 --> 19:38.580
它是undefined

19:38.580 --> 19:40.580
它为什么是undefined

19:40.580 --> 19:41.580
那你要去分析了

19:41.580 --> 19:43.580
有可能它不应该是undefined

19:43.580 --> 19:44.580
它变成undefined

19:44.580 --> 19:45.580
你要去分析

19:45.580 --> 19:46.580
反正它就是

19:46.580 --> 19:47.580
这个错误的意思

19:47.580 --> 19:49.580
有个东西是undefined

19:49.580 --> 19:51.580
你没有给它复职

19:51.580 --> 19:53.580
然后再读它的name属性

19:53.580 --> 19:54.580
那就报错了

19:55.580 --> 19:56.580
好

19:56.580 --> 19:57.580
再看下面

19:57.580 --> 19:59.580
reference error

19:59.580 --> 20:01.580
b is not defined

20:01.580 --> 20:02.580
说明啥呀

20:02.580 --> 20:03.580
说明在代码里边

20:03.580 --> 20:04.580
某个地方

20:04.580 --> 20:05.580
具体哪个地方

20:05.580 --> 20:06.580
是不是要去点

20:06.580 --> 20:07.580
后边

20:07.580 --> 20:08.580
因为这里的实在是

20:08.580 --> 20:09.580
这里直接书写的

20:09.580 --> 20:10.580
所以说

20:11.580 --> 20:13.580
它用这种形式给你显示

20:13.580 --> 20:14.580
具体的位置

20:14.580 --> 20:16.580
你可以通过对战信息

20:16.580 --> 20:17.580
去找到

20:18.580 --> 20:19.580
不过一个错误秒数

20:19.580 --> 20:20.580
跟你说的很清楚

20:20.580 --> 20:21.580
b is not defined

20:21.580 --> 20:22.580
什么意思呢

20:22.580 --> 20:23.580
就是说

20:23.580 --> 20:25.580
我在代码里边一定有一个东西

20:25.580 --> 20:27.580
一定我再读一个b

20:27.580 --> 20:29.580
一个变量b

20:29.580 --> 20:31.580
不管你是把它当成函数使用

20:31.580 --> 20:33.580
还是把它当成变量使用

20:33.580 --> 20:35.580
比方说你再直接读一个变量b

20:35.580 --> 20:37.580
或者是把它当成一个函数使用

20:37.580 --> 20:38.580
都会引发这个错误

20:38.580 --> 20:40.580
它本身就并不存在

20:40.580 --> 20:42.580
它没有被定义过

20:42.580 --> 20:43.580
就这么个意思

20:44.580 --> 20:45.580
下边

20:46.580 --> 20:48.580
那么这个玩意的错误

20:48.580 --> 20:49.580
就是指的是

20:49.580 --> 20:51.580
往往是这么一回事

20:51.580 --> 20:52.580
它有一个东西

20:52.580 --> 20:53.580
是一个对象

20:53.580 --> 20:54.580
比方说

20:54.580 --> 20:55.580
它是一个对象

20:55.580 --> 20:57.580
对象里面那个name属性

20:57.580 --> 20:58.580
它不是一个函数

20:58.580 --> 21:01.580
但是你把它当成函数使用

21:01.580 --> 21:03.580
是什么意思呢

21:03.580 --> 21:04.580
比方说

21:04.580 --> 21:06.580
对象里面有个name属性

21:07.580 --> 21:08.580
它不是一个函数

21:08.580 --> 21:09.580
它有可能是数字

21:09.580 --> 21:10.580
有可能是

21:10.580 --> 21:11.580
这回事

21:11.580 --> 21:12.580
反正不是函数

21:12.580 --> 21:15.580
但是你把它当成函数再使用

21:15.580 --> 21:16.580
它就爆错了

21:17.580 --> 21:19.580
比方说再来一个意思

21:19.580 --> 21:20.580
比方说a

21:20.580 --> 21:21.580
a是一个对象

21:21.580 --> 21:22.580
对吧

21:22.580 --> 21:24.580
你把它当成一个函数使用的时候

21:24.580 --> 21:25.580
它就爆错了

21:25.580 --> 21:27.580
a是那种方式

21:27.580 --> 21:30.580
这些都是我们程序里面开发过程中

21:30.580 --> 21:33.580
非常非常常见的错误

21:33.580 --> 21:34.580
这些错误

21:34.580 --> 21:35.580
你要知道

21:35.580 --> 21:36.580
你不要再害怕了

21:36.580 --> 21:37.580
就是很多东西

21:37.580 --> 21:38.580
你只要一分析它

21:38.580 --> 21:39.580
一了解它

21:39.580 --> 21:40.580
你就不害怕了

21:40.580 --> 21:42.580
有些同学喜欢

21:42.580 --> 21:44.580
有些同学害怕看那个恐怖片

21:44.580 --> 21:45.580
害怕鬼

21:45.580 --> 21:47.580
但是你要分析啊

21:47.580 --> 21:48.580
你分析过后

21:48.580 --> 21:49.580
你会发现

21:49.580 --> 21:50.580
鬼什么习性呢

21:50.580 --> 21:52.580
他白天不工作

21:52.580 --> 21:53.580
晚上上班

21:53.580 --> 21:54.580
白天休息

21:54.580 --> 21:56.580
然后晚上的时候

21:56.580 --> 21:58.580
喜欢躲在那个什么计较咖喱

21:58.580 --> 22:00.580
皮个长发

22:00.580 --> 22:01.580
穿一个白色的衣服

22:01.580 --> 22:02.580
打工装

22:02.580 --> 22:04.580
然后有人过边

22:04.580 --> 22:05.580
邓哥往那里一过

22:05.580 --> 22:07.580
出来瞎一下

22:08.580 --> 22:09.580
然后还要化妆

22:09.580 --> 22:10.580
对吧

22:10.580 --> 22:11.580
我们都是美颜

22:11.580 --> 22:12.580
他要丑颜

22:12.580 --> 22:13.580
对不对

22:13.580 --> 22:16.580
然后说话一定要慢

22:16.580 --> 22:18.580
然后声音一定要放低

22:18.580 --> 22:20.580
就这样子

22:20.580 --> 22:22.580
慢慢了解它的习性之后

22:22.580 --> 22:23.580
你会发现

22:23.580 --> 22:25.580
还是可以相处的对吧

22:25.580 --> 22:26.580
还是可以相处的

22:26.580 --> 22:27.580
就没有那么害怕了

22:27.580 --> 22:29.580
像错误这种也是一样

22:29.580 --> 22:31.580
你只要了解了它之后

22:31.580 --> 22:32.580
你会发现就这么回事了

22:32.580 --> 22:34.580
不再害怕了

22:34.580 --> 22:36.580
以后看到错误

22:36.580 --> 22:37.580
你就知道

22:37.580 --> 22:39.580
要去看它的错误描述

22:39.580 --> 22:40.580
英文不好

22:40.580 --> 22:41.580
英文不好翻译

22:41.580 --> 22:43.580
有翻译软件

22:43.580 --> 22:44.580
复制粘贴

22:44.580 --> 22:46.580
到翻译软件里面翻译一下

22:46.580 --> 22:48.580
然后看它的堆账信息

22:48.580 --> 22:49.580
就看它的错误的位置

22:49.580 --> 22:50.580
基本上就能找到

22:50.580 --> 22:52.580
错误的直接原因了

22:52.580 --> 22:53.580
好

22:53.580 --> 22:54.580
那么这就是它的重点

22:54.580 --> 22:55.580
就完了

22:55.580 --> 22:56.580
那接下来

22:56.580 --> 22:58.580
就不是重点了

22:58.580 --> 23:00.580
接下来我要讲的东西

23:00.580 --> 23:02.580
是一些非常高端的内容

23:02.580 --> 23:03.580
这些内容

23:03.580 --> 23:05.580
你们学了之后

23:05.580 --> 23:06.580
有点印象

23:06.580 --> 23:08.580
就可以了

23:08.580 --> 23:09.580
因为这些内容

23:09.580 --> 23:12.580
它会对我们写代码造成影响

23:12.580 --> 23:13.580
刚才我们说的

23:13.580 --> 23:14.580
写代码没有影响

23:14.580 --> 23:17.580
只是当你学会观察错误

23:17.580 --> 23:18.580
定位错误

23:18.580 --> 23:19.580
但是接下来

23:19.580 --> 23:20.580
我要讲的两块知识

23:20.580 --> 23:22.580
对我们写代码是有影响的

23:22.580 --> 23:23.580
但是

23:23.580 --> 23:24.580
还是我刚才说的

23:24.580 --> 23:26.580
一年

23:26.580 --> 23:28.580
就用不到一两次

23:28.580 --> 23:30.580
甚至一年都一次都用不到

23:30.580 --> 23:33.580
只有到什么时候才有用了

23:33.580 --> 23:35.580
我们将来成为

23:35.580 --> 23:37.580
高级前段工程师

23:37.580 --> 23:39.580
写一些高端的代码

23:39.580 --> 23:41.580
特别写一些公共库

23:41.580 --> 23:42.580
公共框架

23:42.580 --> 23:44.580
写这些东西的时候

23:44.580 --> 23:45.580
这些知识就很有用了

23:45.580 --> 23:46.580
但是现在的你

23:46.580 --> 23:48.580
多多找找要了解一下

23:48.580 --> 23:51.580
第一点就是补货异常

23:51.580 --> 23:53.580
补货异常是什么意思呢

23:53.580 --> 23:54.580
就是处理错误

23:54.580 --> 23:55.580
我觉得这一块知识

23:55.580 --> 23:56.580
听一听

23:56.580 --> 23:58.580
也没有作业

23:58.580 --> 24:00.580
补货异常就是处理错误

24:00.580 --> 24:02.580
是不是错误发生了

24:02.580 --> 24:05.580
有些时候错误发生了

24:05.580 --> 24:07.580
我们可能会对错误

24:07.580 --> 24:08.580
进行相应的处理

24:08.580 --> 24:11.580
我们不希望程序终止

24:11.580 --> 24:12.580
你不要停止程序

24:12.580 --> 24:13.580
也不要在控制台里面抱错

24:13.580 --> 24:15.580
我知道怎么处理

24:15.580 --> 24:17.580
那么这个叫补货异常

24:17.580 --> 24:18.580
有错误

24:18.580 --> 24:20.580
我们处理错误就完事了

24:20.580 --> 24:22.580
那么如何来补货异常呢

24:22.580 --> 24:23.580
代码是

24:23.580 --> 24:26.580
try, catch, finally

24:26.580 --> 24:27.580
我们来看一下

24:27.580 --> 24:29.580
在try里面写代码1

24:29.580 --> 24:31.580
在catch里面写代码2

24:31.580 --> 24:33.580
在finally里面写代码3

24:33.580 --> 24:34.580
这个代码里面

24:34.580 --> 24:36.580
这个代码随便写

24:36.580 --> 24:37.580
啥意思呢

24:37.580 --> 24:39.580
它就是尝试着运行

24:39.580 --> 24:40.580
这个代码

24:40.580 --> 24:42.580
try就尝试着运行

24:42.580 --> 24:43.580
它会运行

24:43.580 --> 24:45.580
如果说这个代码发生了错误

24:45.580 --> 24:47.580
比方这里有十行代码

24:47.580 --> 24:49.580
第五行发生了错误

24:49.580 --> 24:51.580
立即停止

24:51.580 --> 24:53.580
try里面代码执行

24:53.580 --> 24:55.580
转而去执行catch

24:55.580 --> 24:57.580
catch是什么意思

24:57.580 --> 24:59.580
拋

24:59.580 --> 25:00.580
你要知道什么叫拋错误

25:00.580 --> 25:01.580
就是

25:01.580 --> 25:02.580
我有一个错误了

25:02.580 --> 25:03.580
我把扔出来

25:03.580 --> 25:04.580
就像个袖球一样

25:04.580 --> 25:05.580
我把扔出来

25:05.580 --> 25:06.580
程序不会剥了

25:06.580 --> 25:07.580
它剥了

25:07.580 --> 25:08.580
悬桌子的

25:08.580 --> 25:09.580
我扔出来

25:09.580 --> 25:11.580
叫拋错误

25:11.580 --> 25:12.580
catch是什么

25:12.580 --> 25:13.580
我把错误接住

25:13.580 --> 25:15.580
我来进行后续的处理

25:15.580 --> 25:16.580
所以说

25:16.580 --> 25:18.580
如果说在这个过程中发生了错误

25:18.580 --> 25:21.580
它就会马上停止这一块代码

25:21.580 --> 25:23.580
转而执行catch

25:23.580 --> 25:26.900
然后它会把错误

25:26.900 --> 25:27.900
错误不是一个对象吗

25:27.900 --> 25:29.900
它会把错误对象

25:29.900 --> 25:31.900
传递给这个参数

25:31.900 --> 25:33.900
传递给这

25:33.900 --> 25:35.900
那么你可以用个便量来接收

25:35.900 --> 25:37.900
我这里用的是air

25:37.900 --> 25:39.900
然后它会执行这里面代码

25:39.900 --> 25:41.900
这里面代码可以写任何代码

25:41.900 --> 25:43.900
当代码一出现异常之后

25:43.900 --> 25:44.900
会执行这里代码

25:44.900 --> 25:45.900
异常对象

25:45.900 --> 25:46.900
会传给这个air

25:46.900 --> 25:47.900
好

25:47.900 --> 25:49.900
然后这里有执行完了之后

25:49.900 --> 25:50.900
再执行finally

25:50.900 --> 25:51.900
finally是什么意思

25:51.900 --> 25:52.900
最终的

25:52.900 --> 25:53.900
始终要执行的

25:53.900 --> 25:55.900
那么这里会执行代码3

25:55.900 --> 25:56.900
finally这一块是可以省略的

25:56.900 --> 25:58.900
可写可不可写

25:58.900 --> 25:59.900
这一块代码是

25:59.900 --> 26:00.900
无论有没有异常

26:00.900 --> 26:01.900
最终都会执行

26:01.900 --> 26:04.900
比如说没有异常的执行顺序

26:04.900 --> 26:05.900
是代码1代码3

26:05.900 --> 26:06.900
这里执行完了

26:06.900 --> 26:07.900
就会执行这

26:07.900 --> 26:09.900
如果说有异常的话

26:09.900 --> 26:10.900
就是代码1

26:10.900 --> 26:11.900
出现异常

26:11.900 --> 26:12.900
终断执行

26:12.900 --> 26:14.900
转而执行代码2

26:14.900 --> 26:16.900
然后执行完了之后

26:16.900 --> 26:17.900
再执行代码3

26:17.900 --> 26:19.900
是这么一个逻辑

26:19.900 --> 26:20.900
这叫做补货异常

26:20.900 --> 26:21.900
比方说我觉得

26:23.900 --> 26:25.900
我们来一个

26:26.900 --> 26:27.900
二点解释

26:28.900 --> 26:29.900
二点解释

26:29.900 --> 26:30.900
我们这样子写

26:31.900 --> 26:32.900
try

26:32.900 --> 26:36.270
这里面我们就写个异常

26:37.270 --> 26:38.270
订个A

26:38.270 --> 26:40.270
然后输出AdderName

26:41.270 --> 26:44.270
然后再来一个输出End

26:46.270 --> 26:48.270
或者TryEnd

26:48.270 --> 26:50.270
我们前面输出一个TranStart

26:53.480 --> 26:54.480
好 接下来Catch

26:54.480 --> 26:57.480
就这段代码里边有可能有异常

26:57.480 --> 26:58.480
也有可能没有

26:58.480 --> 26:59.480
我也不知道有没有异常

26:59.480 --> 27:01.480
因为我现在肯定知道

27:01.480 --> 27:02.480
现在代码比较简单

27:02.480 --> 27:03.480
但是有的时候你就不知道

27:03.480 --> 27:05.480
比方说这个As来自于

27:05.480 --> 27:07.480
另外一个函数调用

27:07.480 --> 27:09.480
那我这个函数给我的东西

27:09.480 --> 27:10.480
到底是啥

27:10.480 --> 27:11.480
我都不知道了

27:11.480 --> 27:12.480
里边有没有Name我也不知道

27:12.480 --> 27:13.480
所以说有的时候

27:13.480 --> 27:15.480
我就不知道这个代码有没有异常

27:15.480 --> 27:16.480
我不知道的

27:17.480 --> 27:18.480
然后如果说有异常

27:18.480 --> 27:20.480
你跑到这来执行

27:21.480 --> 27:23.480
你把异常对象给我

27:23.480 --> 27:26.480
那么这里我就说Catch

27:27.480 --> 27:30.480
表示有异常了

27:30.480 --> 27:32.480
然后这里我来处理错误

27:32.480 --> 27:34.480
那么错误的错误对象在这

27:34.480 --> 27:36.480
我可以通过这个错误对象

27:36.480 --> 27:37.480
拿到什么呢

27:37.480 --> 27:39.480
拿到它的Message

27:39.480 --> 27:41.480
这是错误的消息

27:41.480 --> 27:43.480
是一个制服创

27:43.480 --> 27:45.480
当然你要用就用不用就拿到

27:45.480 --> 27:46.480
有的时候我不想

27:46.480 --> 27:48.480
我不想知道你是什么错误

27:48.480 --> 27:50.480
那我就可以不不写这个都可以

27:50.480 --> 27:53.480
我们这里输出Catch

27:53.480 --> 27:55.480
然后再来一个finally

27:55.480 --> 27:57.480
finally是可写可不写的

27:57.480 --> 27:59.480
再输出一个finally

27:59.480 --> 28:01.480
好就看这张单码

28:01.480 --> 28:02.480
这张单码我们就在

28:02.480 --> 28:04.480
就在note的环境里面执行吧

28:04.480 --> 28:05.480
都是一样的

28:05.480 --> 28:08.480
你看是不是没有爆错

28:08.480 --> 28:09.480
try start

28:09.480 --> 28:10.480
运行这

28:10.480 --> 28:11.480
定义这

28:11.480 --> 28:12.480
运行到这

28:12.480 --> 28:14.480
第四行是不是出现了错误

28:14.480 --> 28:16.480
出现了错误之后

28:16.480 --> 28:17.480
马上停止

28:17.480 --> 28:18.480
就没有再输出这个了

28:18.480 --> 28:20.480
转而执行Catch

28:20.480 --> 28:21.480
于是输出这个

28:21.480 --> 28:23.480
try start

28:23.480 --> 28:25.480
好错误消息是什么呢

28:25.480 --> 28:26.480
错误消息是一个制服创

28:26.480 --> 28:28.480
它告诉你无法读习属相

28:28.480 --> 28:30.480
a name of undefined

28:30.480 --> 28:32.480
然后catch end

28:32.480 --> 28:33.480
对吧

28:33.480 --> 28:34.480
这个不是错误

28:34.480 --> 28:36.480
这是错误消息一个制服创而已

28:36.480 --> 28:37.480
我把制服创打印了一下

28:37.480 --> 28:38.480
对吧

28:38.480 --> 28:39.480
所以它继续执行

28:39.480 --> 28:41.480
执行完了之后执行finally

28:41.480 --> 28:42.480
程序不会终止

28:42.480 --> 28:44.480
还会继续往后执行

28:44.480 --> 28:45.480
懂得意思吗

28:45.480 --> 28:46.480
这就是trycatch

28:46.480 --> 28:47.480
这是它的语法

28:47.480 --> 28:49.480
了解语法就可以了

28:49.480 --> 28:51.480
为什么我们说这一块东西

28:51.480 --> 28:53.480
对现在来说不重要呢

28:53.480 --> 28:55.480
是因为在绝大部分时候

28:55.480 --> 28:57.480
我们都无需补货异常

28:57.480 --> 28:59.480
异常本身就是好事

28:59.480 --> 29:01.480
它不是坏事

29:01.480 --> 29:03.480
它让你知道我们这一块是有问题的

29:03.480 --> 29:07.480
那什么时候我们会补货异常了

29:07.480 --> 29:09.480
只有满足以下两个条件

29:09.480 --> 29:10.480
一个都不能少

29:10.480 --> 29:13.480
必须要满足以下两个条件的时候

29:13.480 --> 29:15.480
我们才能去补货异常

29:15.480 --> 29:16.480
什么条件呢

29:16.480 --> 29:18.480
我们能够预知

29:18.480 --> 29:21.480
某段代码会出现异常

29:21.480 --> 29:22.480
就是这段代码

29:22.480 --> 29:25.480
我知道它有可能会出现异常

29:25.480 --> 29:26.480
比方说这里

29:26.480 --> 29:27.480
我就通过一个函数调用

29:27.480 --> 29:30.480
这个函数我现在有点拿不准

29:30.480 --> 29:32.480
它给我的有可能是undefined的

29:32.480 --> 29:33.480
有可能是loud

29:33.480 --> 29:34.480
有可能是一个对象

29:34.480 --> 29:36.480
对象里边有可能有name属性

29:36.480 --> 29:37.480
有可能没有

29:37.480 --> 29:38.480
对吧

29:38.480 --> 29:40.480
也就是我能够预知这个代码

29:40.480 --> 29:42.480
有可能会发生异常

29:42.480 --> 29:45.480
这个条件还是比较好满足的

29:46.480 --> 29:47.480
第二

29:47.480 --> 29:51.480
我们还要知道出现异常后要做什么

29:51.480 --> 29:54.480
这点是非常重要的

29:54.480 --> 29:56.480
如果说你不知道要做什么

29:56.480 --> 29:57.480
我这里报错了

29:57.480 --> 29:58.480
但是我这个错误

29:58.480 --> 29:59.480
如果说出现了

29:59.480 --> 30:01.480
如果说给我的是undefined的

30:01.480 --> 30:02.480
那我要做啥

30:02.480 --> 30:03.480
我都不知道了

30:03.480 --> 30:04.480
这里报了错

30:04.480 --> 30:06.480
我要做啥 我不知道

30:07.480 --> 30:10.480
那这个东西你不能去补货它

30:10.480 --> 30:11.480
补货是什么意思

30:11.480 --> 30:13.480
就是我知道你出了问题了

30:13.480 --> 30:15.480
但是我要做一些后续的处理

30:15.480 --> 30:17.480
比方说我要做一些日子记录

30:17.480 --> 30:19.480
把问题记录下来等等等等

30:19.480 --> 30:21.480
那么这个时候才需要去补货

30:21.480 --> 30:23.480
你都不知道要做啥

30:23.480 --> 30:24.480
你就不要补货

30:24.480 --> 30:25.480
就跟它报出来

30:26.480 --> 30:27.480
知道这个意思吗

30:28.480 --> 30:29.480
上述的条件

30:29.480 --> 30:30.480
任意一个不满足

30:30.480 --> 30:31.480
都不应该处理一场

30:31.480 --> 30:33.480
好 这我给他同学们说一个

30:33.480 --> 30:35.480
我看到的 特别是以前

30:35.480 --> 30:36.480
现在很少了

30:36.480 --> 30:39.480
我看到了一个常见的同学们的错误

30:39.480 --> 30:41.480
有一些同学学了这一块知识之后

30:42.480 --> 30:44.480
由于他本身就很害怕这个东西

30:44.480 --> 30:45.480
他特别害怕

30:45.480 --> 30:47.480
不希望再控制他看到这个东西

30:47.480 --> 30:49.480
所以说他看到一件

30:49.480 --> 30:51.480
惊天忌 气鬼什么的事

30:51.480 --> 30:54.480
就说他把所有的代码

30:54.480 --> 30:56.480
我个权力代码里边

30:56.480 --> 30:58.480
你反正就要报一场吧

30:58.480 --> 31:00.480
调有A的时候

31:00.480 --> 31:02.480
这些东西都有可能会报一场

31:02.480 --> 31:03.480
我把所有的代码

31:03.480 --> 31:05.480
全部放到开启里边

31:07.480 --> 31:09.480
然后开启里边啥也不写

31:12.480 --> 31:16.300
这样子好挺好

31:16.300 --> 31:18.300
这样子控制台就不会出现

31:18.300 --> 31:20.300
那个红色的错误了

31:20.300 --> 31:21.300
是没有出现的

31:21.300 --> 31:24.300
但是代表这个程序没有错误吗

31:24.300 --> 31:25.300
不代表

31:25.300 --> 31:27.300
它仍然报了错

31:27.300 --> 31:29.300
你看这个Globo

31:29.300 --> 31:31.300
这里开启就不用管了

31:31.300 --> 31:32.300
你看程序还是停止的

31:32.300 --> 31:34.300
你看

31:34.300 --> 31:36.300
我调用A的时候

31:36.300 --> 31:37.300
调用A的时候

31:37.300 --> 31:38.300
这里运行没问题

31:38.300 --> 31:39.300
调用B

31:39.300 --> 31:40.300
这里运行没问题

31:40.300 --> 31:41.300
调用C

31:41.300 --> 31:42.300
这里运行没问题

31:42.300 --> 31:44.300
这里报错了

31:44.300 --> 31:45.300
这里报错了

31:45.300 --> 31:47.300
那C有没有处理这个错误

31:47.300 --> 31:48.300
C有没有处理这个错误

31:48.300 --> 31:49.300
没有处理

31:49.300 --> 31:51.300
于是错误就往上抛

31:51.300 --> 31:52.300
抛给了B

31:52.300 --> 31:53.300
来B来处理吧

31:53.300 --> 31:54.300
B说我也处理不了

31:54.300 --> 31:56.300
你这个C运行报错了

31:56.300 --> 31:57.300
我也处理不了

31:57.300 --> 31:58.300
那我也停止了

31:58.300 --> 31:59.300
我继续往上抛

31:59.300 --> 32:00.300
抛到哪抛到A

32:00.300 --> 32:01.300
好

32:01.300 --> 32:02.300
那么这个A说

32:02.300 --> 32:03.300
B的运行过程中

32:03.300 --> 32:04.300
B也报错了

32:04.300 --> 32:05.300
B也报错了

32:05.300 --> 32:06.300
那我也处理不了

32:06.300 --> 32:07.300
我往上抛

32:07.300 --> 32:08.300
就抛给了谁

32:08.300 --> 32:09.300
抛给了全局

32:09.300 --> 32:10.300
全局说

32:10.300 --> 32:11.300
这个A报错了

32:12.300 --> 32:13.300
我能处理

32:14.300 --> 32:16.300
是不是就进入到看起来执行

32:16.300 --> 32:17.300
对吧

32:17.300 --> 32:19.300
因此这个错误被捕获了

32:19.300 --> 32:21.300
一个被捕获的错误

32:21.300 --> 32:24.300
浏览器是不会把它打印到控制台的

32:24.300 --> 32:25.300
是不会进行打印的

32:25.300 --> 32:26.300
懂得意思吧

32:26.300 --> 32:28.300
除非你自己手动打印

32:28.300 --> 32:31.300
console error

32:32.300 --> 32:33.300
把这个什么

32:33.300 --> 32:35.300
把这个error对象手动打印起

32:35.300 --> 32:36.300
到这个控制台

32:39.060 --> 32:41.060
你看那是不是效果一样的

32:41.060 --> 32:42.060
那就没什么区别了

32:42.060 --> 32:44.060
因为这个东西有什么意义呢

32:44.060 --> 32:46.060
有什么它就不写这句话

32:46.060 --> 32:47.060
这样的好处说

32:47.060 --> 32:48.060
怎么意思呢

32:48.060 --> 32:50.060
就是控制台没有这个红色的东西

32:50.060 --> 32:51.060
你想一想

32:51.060 --> 32:53.060
没有这个红色的东西是不是更恐怖

32:53.060 --> 32:54.060
出了问题了吗

32:54.060 --> 32:55.060
出了问题了

32:55.060 --> 32:56.060
你看这些

32:56.060 --> 32:57.060
里边都被中断了

32:57.060 --> 32:59.060
但是整个程序里边

32:59.060 --> 33:00.060
后续还可以执行吧

33:00.060 --> 33:02.060
后续还可以执行

33:03.060 --> 33:04.060
整个程序

33:04.060 --> 33:06.060
它还可以继续往后执行

33:06.060 --> 33:08.060
它里边中断了

33:08.060 --> 33:09.060
肯定是遇到的问题

33:09.060 --> 33:11.060
你还不知道问题在呢

33:11.060 --> 33:13.060
没有任何的问题描述

33:13.060 --> 33:14.060
你也不知道问题在呢

33:14.060 --> 33:17.060
这个玩意给你开发造成更多的麻烦

33:17.060 --> 33:19.060
所以说千万不能因为这个原因

33:19.060 --> 33:20.060
去补货错误

33:21.060 --> 33:23.060
只有上面两种情况

33:23.060 --> 33:24.060
同时满足的时候

33:24.060 --> 33:25.060
你才需要补货错误

33:26.060 --> 33:27.060
那么下面我给大家举了个例子

33:27.060 --> 33:28.060
这个例子

33:28.060 --> 33:30.060
现在我们写代码写不了

33:30.060 --> 33:31.060
将来

33:31.060 --> 33:33.060
我们有可能

33:33.060 --> 33:35.060
会写这样的代码

33:35.060 --> 33:36.060
那么这个是啥意思呢

33:36.060 --> 33:38.060
就是给大家演示了一段

33:38.060 --> 33:40.060
我有可能补货错误的代码

33:40.060 --> 33:41.060
比方说

33:41.060 --> 33:42.060
这是个伟代码

33:42.060 --> 33:43.060
并不是真正可以执行的

33:43.060 --> 33:45.060
只是来说明这个意思

33:45.060 --> 33:47.060
比方说这里有个network

33:47.060 --> 33:48.060
网络

33:48.060 --> 33:50.060
网络里边提供了一个方法

33:50.060 --> 33:51.060
Gate Heroes

33:51.060 --> 33:52.060
表示能够获得

33:52.060 --> 33:54.060
王者荣耀的英雄数据

33:55.060 --> 33:57.060
可以拿到一个英雄数组

33:57.060 --> 33:58.060
那么我把英雄数组

33:58.060 --> 34:00.060
保存到那个边量里边

34:00.060 --> 34:02.060
然后我调用另外一个函数

34:02.060 --> 34:04.060
这个函数把英雄数组传进去

34:04.060 --> 34:06.060
它就会在页面上显示

34:07.060 --> 34:08.060
把英雄显示到

34:08.060 --> 34:09.060
显示到页面上

34:09.060 --> 34:11.060
创建元素显示到页面上

34:11.060 --> 34:12.060
比方就这么一件事

34:12.060 --> 34:14.060
但是我能够知道

34:14.060 --> 34:16.060
这里我在使用网络

34:16.060 --> 34:19.060
网络这一块是有可能会出问题的

34:19.060 --> 34:21.060
比方说用户突然断线的

34:21.060 --> 34:24.060
或者说服务系那边突然荡机了

34:24.060 --> 34:26.060
总之可能会出一些

34:26.060 --> 34:27.060
莫名其妙的问题

34:27.060 --> 34:28.060
网络故障

34:28.060 --> 34:29.060
那么这一块

34:29.060 --> 34:31.060
而且我同时我知道

34:31.060 --> 34:33.060
当出现问题之后

34:33.060 --> 34:36.060
我可能会要给用户一些提示

34:36.060 --> 34:38.060
不是在控制台里边给用户爆错

34:38.060 --> 34:39.060
用户去看不见

34:39.060 --> 34:40.060
我要给用户一个提示

34:40.060 --> 34:42.060
告诉他网络可能有故障

34:42.060 --> 34:44.060
那么这个时候

34:44.060 --> 34:46.060
我就使用Trackatch

34:46.060 --> 34:48.060
也就是这个函数

34:48.060 --> 34:50.060
我知道他有可能会爆错

34:50.060 --> 34:51.060
网络故障拿不到英雄

34:51.060 --> 34:52.060
他可能会爆错

34:52.060 --> 34:54.060
于是我把它放到Track里边

34:55.060 --> 34:56.060
放进去过后

34:56.060 --> 34:58.060
一旦出现了错误

34:58.060 --> 35:00.060
我就给用户调用另外一个方法

35:00.060 --> 35:02.060
给用户显示一个框框

35:02.060 --> 35:04.060
框框里边给他提示错误的原因

35:04.060 --> 35:07.060
把这个Error的Message放进去

35:07.060 --> 35:08.060
就这么个意思

35:08.060 --> 35:10.060
那么在这种场景下

35:10.060 --> 35:12.060
我就有可能会使用Trackatch

35:12.060 --> 35:15.060
你能够知道他有可能会发生错误

35:15.060 --> 35:16.060
并且知道

35:16.060 --> 35:18.060
这个错误我需要

35:18.060 --> 35:20.060
用什么方式来解决

35:20.060 --> 35:21.060
要进行处理

35:21.060 --> 35:23.060
你就可以使用Trackatch

35:23.060 --> 35:25.060
再看下一个

35:26.060 --> 35:28.060
手动的拨出错误

35:28.060 --> 35:30.060
前面的错误都是指的是浏览器

35:30.060 --> 35:33.060
自动的给人的一些错误出来

35:33.060 --> 35:34.060
除此之外

35:34.060 --> 35:36.060
其实我们还可以手动的

35:36.060 --> 35:37.060
扔一些错误

35:38.060 --> 35:40.060
扔错误的方式非常简单

35:40.060 --> 35:42.060
使用一个新语法

35:42.060 --> 35:43.060
叫Stroke

35:44.060 --> 35:45.060
就是拨

35:46.060 --> 35:48.060
把错误错误就是一个球

35:48.060 --> 35:49.060
一个对象拨出来

35:49.060 --> 35:51.060
把桌子掀了

35:51.060 --> 35:52.060
拨

35:52.060 --> 35:55.060
Stroke后边传的是一个异常对象

35:55.060 --> 35:58.060
其实后边传啥都无所谓

35:58.060 --> 35:59.060
比方说

35:59.060 --> 36:01.060
我们这里的Stroke

36:01.060 --> 36:02.060
一颗一二三

36:02.060 --> 36:04.060
一看他就给你包了一个错误

36:04.060 --> 36:06.060
他说这里这句话就包了一个错误

36:06.060 --> 36:07.060
这个错

36:07.060 --> 36:08.060
uncaught

36:08.060 --> 36:09.060
表示什么意思

36:09.060 --> 36:11.060
他就是这个错误没有被捕获

36:11.060 --> 36:13.060
就是没有处理这个错误

36:13.060 --> 36:15.060
错误对象就是一二三

36:15.060 --> 36:16.060
啥都可以拨

36:16.060 --> 36:18.060
只不过这种写法

36:18.060 --> 36:20.060
我们一般不这样子写

36:20.060 --> 36:21.060
我们一般怎么写呢

36:21.060 --> 36:23.060
自己创建一个错误对象

36:23.060 --> 36:24.060
错误对象怎么创建

36:24.060 --> 36:25.060
创建六

36:25.060 --> 36:26.060
六一个什么

36:26.060 --> 36:27.060
如果说你要创建一个语法错误

36:27.060 --> 36:29.060
就是六

36:29.060 --> 36:31.060
syntax error

36:31.060 --> 36:33.060
某个语法错误

36:33.060 --> 36:34.060
就是错误消息

36:34.060 --> 36:36.060
他就包了一个某个语法错误

36:36.060 --> 36:39.060
你要拨一个就是type error

36:39.060 --> 36:40.060
你就创建一个type error

36:40.060 --> 36:42.060
把错误消息写进去

36:42.060 --> 36:43.060
就这么简单

36:43.060 --> 36:45.060
这拨一个错误

36:45.060 --> 36:47.060
比方说我再来看一个例子

36:48.060 --> 36:50.060
就在一个大码里边

36:51.060 --> 36:53.060
A等于1

36:53.060 --> 36:55.060
我们就输出start吧

36:55.060 --> 36:57.060
start

36:57.060 --> 36:58.060
然后再输出end

36:58.060 --> 37:00.060
中间我就拨一个错误

37:00.060 --> 37:01.060
throw

37:01.060 --> 37:02.060
六

37:03.060 --> 37:05.060
也可以创建一个error对象

37:05.060 --> 37:07.060
实际上type error

37:07.060 --> 37:10.060
这些东西都是既成之error的

37:10.060 --> 37:12.060
都是既成与他的

37:12.060 --> 37:14.060
我就拨一个type error

37:17.060 --> 37:19.060
这句话就爆错了

37:19.060 --> 37:21.060
运行到16号就爆错了

37:22.060 --> 37:24.060
只输出start

37:24.060 --> 37:25.060
这句话就爆错了

37:25.060 --> 37:27.060
他告诉你错误的效

37:27.060 --> 37:28.060
是type error

37:28.060 --> 37:29.060
错误的消息是这个

37:29.060 --> 37:30.060
对战信息

37:30.060 --> 37:32.060
你看他都会告诉你

37:32.060 --> 37:33.060
懂了意思吧

37:33.060 --> 37:34.060
这里其实还在提示你

37:34.060 --> 37:36.060
这个代码是运行不到的

37:36.060 --> 37:38.060
因为他前面会爆错

37:38.060 --> 37:39.060
这就是throw

37:39.060 --> 37:41.060
拨出错误

37:41.060 --> 37:42.060
又啥用了

37:42.060 --> 37:44.060
拨错误又啥用了

37:44.060 --> 37:47.060
拨错误现在对同学们完全没有

37:47.060 --> 37:49.060
将来当你们

37:49.060 --> 37:53.060
成长为一个高级工程师之后

37:53.060 --> 37:55.060
你写一些高端的代码的时候

37:55.060 --> 37:56.060
极其有用

37:57.060 --> 37:59.060
为什么会说他有用呢

38:00.060 --> 38:02.060
什么时候我们会拨出错误

38:02.060 --> 38:03.060
三个条件

38:03.060 --> 38:05.060
同时满足

38:05.060 --> 38:06.060
我们可以预知

38:06.060 --> 38:08.060
就是在编写某个函数的时候

38:08.060 --> 38:09.060
一般来说我们不会在

38:09.060 --> 38:10.060
拳句里面拨错误

38:10.060 --> 38:12.060
一般都是在编写某个函数的时候

38:13.060 --> 38:16.060
我知道整个函数的执行过程

38:16.060 --> 38:18.060
有可能会出现某种错误

38:20.060 --> 38:21.060
但是这个错误

38:21.060 --> 38:23.060
浏览器不会自动给你拨出来

38:23.060 --> 38:25.060
你就必须要手动拨了

38:26.060 --> 38:29.060
该函数无法处理这个错误

38:30.060 --> 38:32.060
具体的一个例子就是这个

38:32.060 --> 38:35.500
我给他随便举了个例子

38:35.500 --> 38:37.500
比方要说像这个

38:37.500 --> 38:39.500
我写一个函数

38:39.500 --> 38:41.500
两数之合

38:41.500 --> 38:43.500
但是我对这个函数是有要求的

38:43.500 --> 38:45.500
我希望两个必须是数字

38:45.500 --> 38:47.500
你不过要给我传两个字不错进来

38:47.500 --> 38:48.500
传两个字不错进来

38:48.500 --> 38:50.500
就是变成字不错拼接了

38:50.500 --> 38:52.500
有奇异

38:52.500 --> 38:54.500
你必须要给我传两个数字

38:54.500 --> 38:55.500
有两个参数是数字

38:55.500 --> 38:57.500
我给你返回数字相加的结果

38:57.500 --> 38:58.500
但是呢

38:58.500 --> 39:00.500
我在写这个函数的时候

39:00.500 --> 39:02.500
我能确定别人给我传啥吗

39:02.500 --> 39:03.500
我没有办法确定

39:03.500 --> 39:04.500
他又可能给我传什么

39:04.500 --> 39:06.500
Defend 拉

39:06.500 --> 39:07.500
都有可能给我传

39:07.500 --> 39:09.500
那我怎么加呢

39:09.500 --> 39:11.500
这里是不是有两种做法

39:11.500 --> 39:12.500
第一种做法

39:12.500 --> 39:13.500
我就假

39:13.500 --> 39:14.500
我死叫假

39:14.500 --> 39:15.500
假完了过了

39:15.500 --> 39:16.500
死啥就死啥

39:16.500 --> 39:17.500
你给我传两个字不错

39:17.500 --> 39:19.500
我就变成拼接了

39:19.500 --> 39:20.500
或者是呢

39:20.500 --> 39:21.500
就是你给我传啥

39:21.500 --> 39:23.500
我就给你转成数字

39:23.500 --> 39:24.500
如果说转不出来

39:24.500 --> 39:26.500
就是NNN

39:26.500 --> 39:28.500
那如果说是你把这个函数

39:28.500 --> 39:30.500
是这样定义的话

39:30.500 --> 39:31.500
你这样理解这个函数的话

39:31.500 --> 39:32.500
那就OK

39:32.500 --> 39:33.500
那就不会爆错

39:33.500 --> 39:35.500
那这个姿势就用不了了

39:35.500 --> 39:36.500
那就不会爆错

39:36.500 --> 39:37.500
就像我们之前写的那个

39:37.500 --> 39:38.500
把它转成数字

39:38.500 --> 39:39.500
对吧

39:39.500 --> 39:40.500
写过了对吧

39:40.500 --> 39:43.500
所以说关键看这个函数的含义

39:43.500 --> 39:45.500
如果说这个函数要求比较严格

39:45.500 --> 39:47.500
你必须给我传两个数字

39:47.500 --> 39:49.500
如果说你一定不按照要求来

39:49.500 --> 39:52.500
我就用一个错误来提示你

39:52.500 --> 39:55.500
你没有按照要求来传递参数

39:55.500 --> 39:57.500
而这也是一种邪法

39:57.500 --> 40:00.500
这是不同的邪法的风格的问题

40:00.500 --> 40:03.500
那么如果说假设

40:03.500 --> 40:05.500
我这个函数要求特别严格

40:05.500 --> 40:07.500
必须要给我传数字

40:07.500 --> 40:09.500
如果你给我传的不是数字

40:09.500 --> 40:11.500
我要想办法来告诉你

40:11.500 --> 40:13.500
你给我传的是有问题的

40:13.500 --> 40:14.500
那么我就会

40:14.500 --> 40:16.500
最好的告诉方式就是错误

40:16.500 --> 40:18.500
那我怎么来写呢

40:18.500 --> 40:19.500
因为这个玩意

40:19.500 --> 40:20.500
你给我传的不是数字

40:20.500 --> 40:22.500
浏览器是不会爆错了对吧

40:22.500 --> 40:24.500
但是按照这个函数严格的要求

40:24.500 --> 40:26.500
你是必须要给我传数字的

40:26.500 --> 40:28.500
是不是有错误

40:28.500 --> 40:29.500
这种情况是不是有错误

40:29.500 --> 40:30.500
一个传的不是数字

40:30.500 --> 40:31.500
B也不是数字

40:31.500 --> 40:32.500
或者是B也

40:32.500 --> 40:33.500
A和B

40:33.500 --> 40:34.500
任何一个不是数字

40:34.500 --> 40:36.500
那么我在这个函数的要求下

40:36.500 --> 40:38.500
我认为它是有错误的

40:38.500 --> 40:40.500
但是浏览器不会给我抛这个错误

40:40.500 --> 40:42.500
所以说我就自己手动抛

40:42.500 --> 40:44.500
抛了一个Type-A软

40:44.500 --> 40:45.500
内形错误

40:45.500 --> 40:47.500
B需要两个数字

40:47.500 --> 40:49.500
传入两个数字才能求合

40:49.500 --> 40:51.500
其实我还可以详细的告诉他

40:51.500 --> 40:53.500
到底A和B哪个不是数字

40:53.500 --> 40:55.500
都可以详细的告诉他

40:55.500 --> 40:58.500
写到错误消息里面

40:58.500 --> 40:59.500
那这样子一来的话

40:59.500 --> 41:00.500
这个函数写好了

41:00.500 --> 41:02.500
给别人用这个函数的时候

41:02.500 --> 41:04.500
如果说别人不追这手规范

41:06.500 --> 41:08.500
那么这个时候呢

41:08.500 --> 41:10.500
就会得到一个错误

41:10.500 --> 41:13.500
经过这个错误的提示

41:13.500 --> 41:14.500
调用函数的人

41:14.500 --> 41:15.500
他就会想一想

41:15.500 --> 41:18.500
你这个函数要求很严格

41:18.500 --> 41:20.500
那么这里我传了两个东西进去

41:20.500 --> 41:21.500
其中一个东西可以

41:21.500 --> 41:22.500
要么就是两个都不是数字

41:22.500 --> 41:24.500
要么就是其中一个不是数字

41:24.500 --> 41:26.500
你还会给我报这个错

41:26.500 --> 41:27.500
根据错误消息

41:27.500 --> 41:29.500
我在检查代码

41:29.500 --> 41:31.500
把这个代码修正为正确的状态

41:31.500 --> 41:33.500
就起这么一个作用

41:33.500 --> 41:34.500
错误再次强调了

41:34.500 --> 41:36.500
错误并不是坏手

41:36.500 --> 41:38.500
它在提醒你

41:38.500 --> 41:40.500
做正确的事情

41:40.500 --> 41:42.500
就这么个意思

41:42.500 --> 41:44.500
这是抛错误

41:44.500 --> 41:46.500
现在大家不用管

41:46.500 --> 41:48.500
也不会去写这个代码

41:50.500 --> 41:51.500
还有一个事情就是

41:51.500 --> 41:54.500
如果说某一个函数需要

41:54.500 --> 41:55.500
抛出错误

41:55.500 --> 41:58.500
一定要在函数的文档注释中

41:58.500 --> 41:59.500
铲述清楚

41:59.500 --> 42:01.500
让别人知道

42:01.500 --> 42:03.500
往往这种情况就出现在

42:03.500 --> 42:05.500
你写的函数

42:05.500 --> 42:07.500
但是不是你在用

42:07.500 --> 42:09.500
是别人在用

42:09.500 --> 42:10.500
别人不知道你这个函数

42:10.500 --> 42:12.500
有可能会报错

42:12.500 --> 42:15.500
因此你最好在文档注释里面

42:15.500 --> 42:16.500
写清楚

42:16.500 --> 42:18.500
这样子别人一看这个注释

42:18.500 --> 42:20.500
他有可能会抛出错误

42:20.500 --> 42:22.500
而且错误的那一小时太平了

42:22.500 --> 42:24.500
别人可能会觉得这个错误

42:24.500 --> 42:26.500
我有可能能解决

42:26.500 --> 42:28.500
比方说这里来自于有两个

42:28.500 --> 42:30.500
这里来自于用户的输入

42:30.500 --> 42:32.500
A和B来自于用户的输入

42:34.500 --> 42:36.500
我就用一个串

42:36.500 --> 42:39.500
如果说你发现了错误

42:39.500 --> 42:42.500
我就提示用户重新输入

42:42.500 --> 42:44.500
提示用户重新输入

42:44.500 --> 42:46.500
输入的不是输入

42:46.500 --> 42:47.500
懂了意思吧

42:47.500 --> 42:48.500
他有可能处理

42:48.500 --> 42:49.500
有可能不处理

42:49.500 --> 42:51.500
但是你要提示他

42:51.500 --> 42:52.500
好了

42:52.500 --> 42:54.500
说了半天就说完了

42:54.500 --> 42:55.500
最后我们总结一下

42:55.500 --> 42:57.500
这节课我们讲的异常

42:57.500 --> 42:59.500
讲的错误

42:59.500 --> 43:01.500
提升了注意者心的

43:01.500 --> 43:03.500
你要理解异常的分类

43:03.500 --> 43:04.500
错误的分类

43:04.500 --> 43:05.500
它是一个对象

43:05.500 --> 43:06.500
它里面提供了哪些信息

43:06.500 --> 43:08.500
有错误的原因

43:08.500 --> 43:09.500
有错误的位置

43:09.500 --> 43:11.500
你要通过这两个信息

43:11.500 --> 43:12.500
重要的信息

43:12.500 --> 43:15.500
找到错误发生在什么地方

43:15.500 --> 43:16.500
出现了

43:16.500 --> 43:17.500
为什么会出现错误

43:17.500 --> 43:19.500
这是我们这里可追核心的

43:19.500 --> 43:21.500
也就是练习这一部分

43:21.500 --> 43:24.500
然后其他的了解就行了

43:24.500 --> 43:25.500
补货异常

43:25.500 --> 43:26.500
抛出异常

43:26.500 --> 43:27.500
我们了解就行了

43:27.500 --> 43:28.500
知道有这么一回事

43:28.500 --> 43:29.500
就可以了

43:29.500 --> 43:31.500
你们反正不会去写这种代码的

43:31.500 --> 43:33.500
这就是这里和了全部内容了

