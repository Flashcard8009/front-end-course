WEBVTT

00:00.880 --> 00:04.320
再说一次 上节课的东西

00:04.320 --> 00:06.840
就是原型练练那一块的东西

00:06.840 --> 00:09.520
谋谋糊糊没关系的

00:09.520 --> 00:12.560
因为我们后边会专门做笔面式讲解

00:12.560 --> 00:16.440
只要你能够完成练习题就可以了

00:16.440 --> 00:18.880
因为我知道那一块只是会有点绕

00:18.880 --> 00:21.920
继承这一块就完全没有作业了

00:21.920 --> 00:23.960
但是我不得不讲

00:23.960 --> 00:26.880
其实上一节课就是原型练和继承

00:27.200 --> 00:28.880
要不要现在讲

00:28.880 --> 00:31.400
我都不知道纠结了多久了

00:31.400 --> 00:33.000
反复的纠结

00:33.000 --> 00:35.240
但是我最后还是觉得讲吧

00:35.240 --> 00:37.040
不要埋下隐患

00:37.040 --> 00:39.840
就是这一块你学的谋谋糊糊都没关系

00:39.840 --> 00:42.360
就是一字半解都没关系

00:42.360 --> 00:43.920
你至少知道

00:43.920 --> 00:46.280
不然一点都不知道什么叫原型练习

00:46.280 --> 00:47.560
什么叫继承

00:47.560 --> 00:50.160
这个我太担心后边会遇到问题了

00:50.160 --> 00:52.720
其实我们平时开发的用不用原型练的

00:52.720 --> 00:54.880
跟我们平时开发应该这样说吧

00:55.000 --> 00:58.480
99%的情况下都跟我们没什么关系

00:58.480 --> 00:59.960
你们后边我们去做界面

00:59.960 --> 01:00.880
做各种效果的时候

01:00.880 --> 01:03.320
你会发现什么原型练什么继承的

01:03.320 --> 01:05.520
跟我压根就没什么关系

01:05.520 --> 01:08.000
但是它确确实实的存在在

01:08.000 --> 01:10.640
与咱们的系统当中

01:10.640 --> 01:11.920
像我们的浏览器

01:11.920 --> 01:15.160
像我们的之后学的一些框架

01:15.160 --> 01:17.840
他们都到处用到了继承

01:17.840 --> 01:19.400
对于我们理解浏览器

01:19.400 --> 01:21.160
理解框架是有帮助的

01:21.160 --> 01:22.680
只不过我们现阶段

01:22.720 --> 01:25.960
写呆确实跟我们关系不大

01:25.960 --> 01:28.520
但是你不能压根啥都不知道

01:28.520 --> 01:30.400
能听懂多少听懂多少

01:30.400 --> 01:31.720
心态放轻松

01:31.720 --> 01:33.520
不要有太大的压力

01:33.520 --> 01:35.280
尽量理解理解不了

01:35.280 --> 01:35.800
也没事

01:35.800 --> 01:38.680
至少你知道了有什么东西了

01:38.680 --> 01:40.440
这一回没作业就听就行了

01:40.440 --> 01:41.160
下来之后

01:41.160 --> 01:43.240
把老师做这个小练习

01:43.240 --> 01:45.480
跟着做一下跟着写一下就可以了

01:45.480 --> 01:49.120
我们从一个案例来说

01:49.120 --> 01:51.360
这里比方说咱们一个视频网站

01:51.400 --> 01:52.960
你在开发一个视频网站

01:52.960 --> 01:55.160
它里边有两种会员

01:55.160 --> 01:56.360
一个叫普通会员

01:56.360 --> 01:57.280
一个叫VIP会员

01:57.280 --> 01:58.560
因为他要说那里说没关系

01:58.560 --> 02:00.400
那将来我们写一个视频网站

02:00.400 --> 02:01.640
或者是别的网站

02:01.640 --> 02:03.240
我要设计一个普通会员

02:03.240 --> 02:04.680
设计个VIP会员

02:04.680 --> 02:06.120
那不得有继承吗

02:06.120 --> 02:07.280
那你举例意思

02:07.280 --> 02:09.160
肯定是跟继承有关系

02:09.160 --> 02:10.240
是这样子的

02:10.240 --> 02:12.680
将来你们就算去写网站的什么

02:12.680 --> 02:13.920
普通会员VIP会员

02:13.920 --> 02:15.160
也不会用到继承

02:16.360 --> 02:16.880
也不会

02:16.880 --> 02:19.240
只是继承只是解决这个问题的

02:19.240 --> 02:20.880
其中一种办法

02:20.880 --> 02:23.440
那将来你们也不太会用到继承

02:23.440 --> 02:24.080
不过了

02:24.080 --> 02:25.200
这个这个例子

02:25.200 --> 02:27.240
是可以帮助我们理解继承的

02:28.640 --> 02:29.720
所以不用担心

02:29.720 --> 02:31.040
不想有任何的心理压力

02:31.040 --> 02:33.040
袁老师说现在不用担心这个

02:33.040 --> 02:34.640
那就真的不用担心

02:34.640 --> 02:36.000
你尽量听把放轻松

02:36.000 --> 02:36.960
尽量听下来过后

02:36.960 --> 02:38.520
跟着把这个例子写一遍就完事了

02:39.880 --> 02:40.760
有两种会员

02:40.760 --> 02:43.440
普通会员的有属性用户名密码方法

02:43.440 --> 02:44.960
可以变观看免费视频

02:44.960 --> 02:45.600
是吧

02:45.600 --> 02:47.320
然后一个VIP会员

02:47.320 --> 02:48.080
VIP会员

02:48.080 --> 02:50.520
他拥有普通会员的所有属性

02:50.560 --> 02:52.080
同时多了一个属性

02:52.080 --> 02:53.520
是会员的到期时间

02:54.600 --> 02:55.600
他有方法

02:55.600 --> 02:57.560
普通会员里边所有方法他都有

02:57.560 --> 02:59.120
普通会员能干的事

02:59.120 --> 02:59.800
他都能干

03:00.720 --> 03:01.520
除此之外呢

03:01.520 --> 03:02.600
他还多了一个方法

03:02.600 --> 03:04.800
能观看付费视频

03:04.800 --> 03:06.520
就现在的视频网站

03:06.520 --> 03:08.320
他搞出来多少会员了

03:08.320 --> 03:09.720
我以前就买一个会员

03:09.720 --> 03:11.280
就什么可以去广告

03:11.280 --> 03:12.360
可以看付费视频了

03:12.360 --> 03:14.480
现在有些视频还看不了

03:14.480 --> 03:16.320
还得升级会员

03:16.320 --> 03:17.400
那些我们就不考虑了

03:17.400 --> 03:18.760
比方说就有两种会员

03:19.760 --> 03:22.400
那我们来如何来写代码

03:22.400 --> 03:23.640
描述这个东西的

03:23.640 --> 03:26.160
比方说我们要使用构造函数

03:26.160 --> 03:27.560
来创建会员

03:27.560 --> 03:30.160
那如何来输写这个构造函数呢

03:30.160 --> 03:31.320
那一写的话

03:31.320 --> 03:33.040
我们就写出来这么一种代码了

03:33.040 --> 03:33.880
我把它复制一下

03:36.080 --> 03:37.920
你看今天都没有作用

03:37.920 --> 03:39.000
就写出来这么个代码

03:39.000 --> 03:41.000
你看这是普通会员

03:41.000 --> 03:42.480
给我传一个用户名密码

03:42.480 --> 03:43.480
然后我保存一下

03:43.480 --> 03:44.040
对吧

03:44.040 --> 03:45.120
这没什么好说的

03:45.120 --> 03:46.960
普通会员里边设计到一个方法

03:46.960 --> 03:48.240
方法都是放到元凶上面了

03:48.880 --> 03:52.280
然后我就简单模拟一下

03:52.280 --> 03:55.120
打印一个观看免费视频

03:55.120 --> 03:57.840
play观看free免费videos视频

03:58.880 --> 04:00.920
VIP会员也是一个构造函数

04:00.920 --> 04:01.440
它不一样

04:01.440 --> 04:02.040
对吧

04:02.040 --> 04:04.200
有一个用户名密码一样的

04:04.200 --> 04:05.280
保存用户名密码

04:05.280 --> 04:06.560
然后一个过期时间

04:06.560 --> 04:08.240
保存过期时间

04:08.240 --> 04:09.160
它有两个方法

04:09.160 --> 04:10.560
一个是观看免费视频

04:10.560 --> 04:11.880
一个是观看付费视频

04:13.320 --> 04:14.160
没问题吧

04:14.160 --> 04:15.840
就写了这么两个构造函数

04:15.840 --> 04:17.720
那到时候我要创建一个普通用户

04:18.720 --> 04:20.240
那就是六游者

04:20.240 --> 04:23.360
传一个名字进去

04:23.360 --> 04:26.120
账号密码

04:26.120 --> 04:28.280
如果说我要创建一个VIP用户

04:28.280 --> 04:30.440
那就是VIP账号

04:30.440 --> 04:32.040
然后一个过期时间

04:32.040 --> 04:36.360
2010月1号

04:36.360 --> 04:37.640
就这么个意思

04:37.640 --> 04:40.240
当然的VIP会员里边有两个方法

04:40.240 --> 04:42.000
普通会员里边只有一个方法

04:42.000 --> 04:43.320
代码就写完了

04:43.320 --> 04:44.400
这代码行不行了

04:44.400 --> 04:46.000
当然没有任何问题

04:46.000 --> 04:48.000
只是代码不好

04:48.000 --> 04:49.280
为什么说不好呢

04:49.280 --> 04:52.920
因为这里面出现了两块重复代码

04:52.920 --> 04:54.000
哪两块重复代码了

04:54.000 --> 04:55.480
第一块重复代码在这个位置

04:58.450 --> 05:00.250
你看是不是在重复

05:01.890 --> 05:03.130
那么这里的重复代码

05:03.130 --> 05:05.090
其实我们仔细的梳理一下

05:05.090 --> 05:07.890
它的逻辑上是这样子的

05:07.890 --> 05:09.730
因为VIP会员

05:09.730 --> 05:11.930
它也是一个会员

05:12.930 --> 05:14.730
那普通会员有的东西

05:14.730 --> 05:15.450
有的属性

05:15.450 --> 05:17.250
那VIP会员是不是一定有

05:18.170 --> 05:19.490
不管将来普通会员

05:19.490 --> 05:20.290
加了什么属性

05:20.290 --> 05:22.250
比如说加了一些什么生日

05:22.250 --> 05:24.810
加了一些乱七八糟的

05:24.810 --> 05:26.290
比如说电话号码之类的

05:26.290 --> 05:27.330
无所谓

05:27.330 --> 05:30.010
你只要普通会员有的

05:30.010 --> 05:31.050
VIP会员一定有

05:32.090 --> 05:33.530
是这个逻辑吗

05:33.530 --> 05:35.730
你注册肯定都是从普通会员开始注册的

05:36.850 --> 05:38.290
所以说这个逻辑是通的

05:38.290 --> 05:40.570
因此这两块确实是一个重复代码

05:41.410 --> 05:42.810
这两块确实是

05:42.810 --> 05:43.970
而且将来不管怎么变

05:43.970 --> 05:46.010
它这两块都应该做相应的变化

05:46.010 --> 05:47.050
它加了手机号

05:47.050 --> 05:48.930
它这里也要加手机号

05:48.970 --> 05:50.450
是不是这个逻辑

05:50.450 --> 05:52.370
这是第一块重复

05:52.370 --> 05:54.730
第二块重复是方法上的重复

05:54.730 --> 05:56.370
就原性上的重复

05:56.370 --> 05:58.930
你这一块普通会员能够观看免费视频

05:58.930 --> 06:00.770
那付费会员更加可以观看了

06:00.770 --> 06:02.810
普通会员能干的事

06:02.810 --> 06:04.570
方法就是功能

06:04.570 --> 06:05.730
能干的事

06:05.730 --> 06:07.210
普通会员能做的事

06:07.210 --> 06:09.010
那VIP会员他一定能做

06:09.010 --> 06:10.250
而且逻辑是一样的

06:11.650 --> 06:13.050
于是就形成这么一个逻辑了

06:13.050 --> 06:14.370
那么这个逻辑形成了

06:14.370 --> 06:15.890
就造成了重复代码

06:15.890 --> 06:17.690
那重复代码怎么解决

06:17.730 --> 06:18.970
都是我们要研究的问题

06:19.970 --> 06:21.050
好我们看一下第一个

06:22.170 --> 06:24.570
首先要处理构造器内部的重复

06:25.490 --> 06:26.970
我们就在代码里面讲吧

06:26.970 --> 06:28.490
其实下来过后同学们要复习的话

06:28.490 --> 06:29.450
你会看文档

06:29.450 --> 06:31.210
我讲的时候其实就是文档的内容

06:32.770 --> 06:34.250
这一块代码怎么来解决重复

06:36.090 --> 06:36.890
怎么解决呢

06:36.890 --> 06:39.530
其实这一块代码解决重复还是比较简单的

06:39.530 --> 06:41.370
需要其实没有什么新知识

06:41.370 --> 06:43.450
就继承这一块其实没有新知识

06:43.450 --> 06:45.210
都是用过去的知识

06:45.890 --> 06:46.610
在解决

06:46.650 --> 06:48.210
那么这一块怎么来解决呢

06:48.210 --> 06:49.170
其实这一块代码

06:49.170 --> 06:51.330
我是不是就把这个玩意运行一遍就完事了

06:51.890 --> 06:53.610
是吧把这个函数运行一遍就完事了

06:54.210 --> 06:56.090
于是呢我这这里就可以这样子写

06:56.090 --> 06:57.970
是不是把写个U2函数

06:58.530 --> 07:01.330
U2 name password

07:01.850 --> 07:03.610
是不是把传给它运行词就完事了

07:04.010 --> 07:05.250
但是你能这样子写吗

07:05.690 --> 07:06.450
你这样一调用

07:06.450 --> 07:08.090
它是意识指向就出现问题了

07:08.090 --> 07:09.610
意识就不在指向新对象了

07:09.610 --> 07:10.290
指向的是谁

07:10.810 --> 07:11.810
指向的是

07:12.970 --> 07:13.490
Windows

07:14.370 --> 07:16.130
它的Windows上面给你加了一个U2 name

07:16.170 --> 07:16.850
加了一个Password

07:16.850 --> 07:17.730
肯定不能这样写

07:17.730 --> 07:18.890
那能这样子写吗

07:20.170 --> 07:21.210
你这样子写的话

07:21.210 --> 07:23.890
那这里面又产生另外一个新对象了

07:24.290 --> 07:26.130
它是在一个全新的对象上面

07:26.130 --> 07:27.850
加了一个U2 name password的

07:29.450 --> 07:31.210
它不是在我这个对象上面加

07:31.210 --> 07:31.610
对吧

07:31.850 --> 07:33.770
你看一把一把个注写打出来就知道了

07:33.770 --> 07:35.450
这里有个Z式等于一个空对象

07:36.970 --> 07:38.690
这里有个Z式等于一个空对象

07:38.690 --> 07:40.570
我希望在这个Z式上加

07:40.850 --> 07:41.930
但是我一定有U2

07:41.930 --> 07:43.850
它已经创建一个另外一个新对象了

07:43.850 --> 07:45.250
它在这个上面加了

07:45.490 --> 07:46.850
所以说这里应该怎么写

07:47.170 --> 07:48.210
这应该这样子写

07:51.680 --> 07:53.800
U2 call

07:54.480 --> 07:55.760
我把Z式传进去

07:55.760 --> 07:57.200
把我这个Z式传进去

07:57.200 --> 07:57.400
对吧

07:57.400 --> 07:58.960
你在我这个Z式上面加

07:59.160 --> 08:00.200
是绑定Z式

08:00.560 --> 08:03.760
然后再给你传参数U2 name password

08:04.080 --> 08:04.560
对吧

08:04.560 --> 08:06.680
把这边的数据给你传过去

08:07.080 --> 08:09.680
也就是说你在我这个Z式上面

08:09.680 --> 08:10.560
给我加上这个

08:10.640 --> 08:11.240
加上这个

08:12.160 --> 08:13.520
于是这样子写就可以了

08:14.640 --> 08:15.360
到后面了

08:15.360 --> 08:17.320
我只需要加上你没有加的

08:17.320 --> 08:17.520
对吧

08:17.520 --> 08:18.600
我特殊的东西

08:18.600 --> 08:19.440
我给你加上

08:20.360 --> 08:22.120
一样的东西你就自己去搞定

08:22.400 --> 08:23.920
你看这个同伏单码做的解决了

08:24.160 --> 08:24.320
好

08:24.320 --> 08:24.920
我们来看一下

08:24.920 --> 08:26.960
好像就两行简称一行

08:26.960 --> 08:28.160
那是这个例子

08:28.360 --> 08:29.960
那万一这里有十几个属性了

08:29.960 --> 08:31.840
而且这个属性的复制还不是说

08:31.840 --> 08:32.800
简单的这样复制

08:32.800 --> 08:34.520
可能里边还要经过很多的逻辑

08:34.520 --> 08:35.680
比方是像FurseName

08:35.680 --> 08:36.280
那是Name

08:36.280 --> 08:36.640
对吧

08:36.640 --> 08:38.080
我还要拼接一个FurseName

08:38.080 --> 08:39.880
那各种逻辑都在里边

08:40.200 --> 08:41.400
你是不是都要走一遍

08:41.600 --> 08:43.120
这里只是举个例子

08:44.120 --> 08:44.320
好

08:44.320 --> 08:45.400
那么现在我们来试一下

08:45.400 --> 08:46.680
创建一个VIP user

08:48.080 --> 08:49.640
留一个VIP user

08:50.640 --> 08:52.280
然后用户名ABC

08:53.120 --> 08:56.040
ABC密码123

08:56.240 --> 09:00.800
然后过去时间的2022年10月1号

09:01.880 --> 09:03.120
输出一下VIP

09:04.360 --> 09:04.880
你看

09:05.520 --> 09:06.320
是不是都有了

09:07.000 --> 09:07.200
对吧

09:07.200 --> 09:08.160
那这就正常了

09:08.360 --> 09:09.800
这一块重复单码是不是解决了

09:11.280 --> 09:12.960
关键是另外一个

09:12.960 --> 09:14.040
这个怎么办

09:15.360 --> 09:16.520
这个玩意怎么办

09:17.360 --> 09:18.400
好我们来看一下文档

09:19.400 --> 09:21.320
处理原型上的重复

09:21.320 --> 09:24.320
其实这一块我们只需要做这么一件事就行了

09:25.320 --> 09:26.200
看一下别张图

09:26.200 --> 09:27.000
来处理

09:27.000 --> 09:29.000
其实这一块就要用到原型链的知识了

09:30.240 --> 09:31.760
默认情况下是这样子的

09:32.280 --> 09:34.960
由着的构造函数跟它的构造函数是没有关系的

09:35.960 --> 09:37.520
它有一个原型

09:37.520 --> 09:37.840
对吧

09:37.840 --> 09:40.680
就是一个原型上有一个播放免费视频

09:40.920 --> 09:43.040
它有一个原型播放付费视频

09:43.640 --> 09:44.120
对不对

09:44.280 --> 09:48.080
那么现在它之前的这个不处理的话

09:48.080 --> 09:50.040
VIP优热的构造这个原型

09:50.040 --> 09:52.560
它的隐私原型是不是应该指向OBG车的

09:52.840 --> 09:54.920
因为OBG跟我们这里没有直接的关系

09:54.920 --> 09:56.240
所以把它化淡一点

09:56.520 --> 09:57.760
它是不是应该指向这的

09:58.400 --> 09:59.160
同样的道理

09:59.160 --> 10:01.280
优热的这个原型

10:01.960 --> 10:03.920
是不是它的隐私原型应该指向这的

10:04.920 --> 10:06.080
然后中间是没有这个的

10:06.080 --> 10:07.560
没有这个是断开的

10:07.560 --> 10:08.440
没有这个连接

10:08.920 --> 10:10.200
他们之间是没有关系的

10:11.040 --> 10:13.480
那我们现在只需要做一件事就可以了

10:13.720 --> 10:16.840
我让这个原型这条链断掉

10:17.280 --> 10:18.320
把这条链链断了

10:18.920 --> 10:21.480
让它的隐私原型指向这是不是就可以了

10:21.480 --> 10:22.600
就形成原型链了

10:23.120 --> 10:23.560
对不对

10:24.800 --> 10:28.040
所以就是我要把这条线变成这条线

10:28.840 --> 10:29.400
就可以了

10:30.800 --> 10:31.840
为什么就可以了呢

10:31.840 --> 10:32.400
你看啊

10:32.400 --> 10:34.200
因为这样子就形成原型链了

10:34.640 --> 10:36.040
它创建的对象

10:36.880 --> 10:37.920
它创建的对象

10:40.240 --> 10:41.120
它创建的对象

10:41.240 --> 10:43.480
然后它的隐私原型是不是指向它

10:44.080 --> 10:45.800
它的隐私原型是不是指向它

10:45.800 --> 10:46.920
然后它又指向OBGX

10:48.360 --> 10:49.240
那这样子一来

10:49.240 --> 10:52.480
我这里边是不是就可以不用写那个PlayFree

10:53.000 --> 10:53.760
Video对吧

10:53.760 --> 10:55.400
播放免费视频是不是可以不用写了

10:56.080 --> 10:59.400
只要是User有的方法我都有了

10:59.400 --> 11:00.560
因为在原型链上

11:01.880 --> 11:03.080
是不是这个逻辑就形成了

11:03.400 --> 11:04.840
那么这件事该怎么做呢

11:05.360 --> 11:07.000
就可以利用我们上级课学的东西

11:07.680 --> 11:09.480
通过继续代码就可以解决

11:09.720 --> 11:10.920
OBGX就这句话

11:11.680 --> 11:12.120
拿过来

11:14.740 --> 11:17.940
完成原型上的变化

11:19.380 --> 11:21.740
我只要把VIPUser的原型

11:22.700 --> 11:25.020
我只要把这个VIPUser的原型

11:25.980 --> 11:27.100
设置它的什么

11:27.380 --> 11:28.580
set prototype 5

11:28.580 --> 11:30.020
设置它的隐私原型

11:30.020 --> 11:30.940
就把这个对象

11:31.300 --> 11:33.100
设置这个对象的隐私原型

11:33.660 --> 11:34.820
就这个对象的隐私原型

11:34.820 --> 11:35.460
设置为啥

11:35.460 --> 11:38.100
设置为User.prototype

11:38.900 --> 11:39.700
就完了呀

11:40.180 --> 11:41.940
那么它的隐私原型就只过去了

11:42.420 --> 11:44.380
其实这句话呢就相当于是什么呢

11:44.620 --> 11:48.060
相当于是VIPUser.prototype

11:48.060 --> 11:49.140
它的隐私原型

11:49.140 --> 11:50.180
要给它改一下

11:50.180 --> 11:50.740
改成什么

11:50.740 --> 11:52.140
它本来是指向OBGX的原型

11:52.140 --> 11:52.500
对吧

11:52.500 --> 11:53.620
本来是等于这个的

11:54.540 --> 11:55.620
那么现在给它改成了

11:55.620 --> 11:57.460
怎么改成User.prototype

11:58.660 --> 11:59.420
只不过呢

11:59.740 --> 12:01.940
官方不让你去用这个东西

12:01.940 --> 12:03.220
所以说我们要用

12:03.220 --> 12:04.260
官方提供的函数

12:04.260 --> 12:05.580
用这个东西去实现

12:05.780 --> 12:06.660
就道理是一样的

12:06.660 --> 12:07.340
就是这么个道理

12:07.940 --> 12:08.620
就完了呀

12:08.820 --> 12:09.300
那这样子

12:09.300 --> 12:10.820
我是不是就可以不用设置这个

12:11.140 --> 12:11.740
playfree

12:11.940 --> 12:12.620
video了

12:12.620 --> 12:13.260
不用设置了

12:13.980 --> 12:14.780
那么来看一下

12:15.100 --> 12:15.540
能不能

12:16.420 --> 12:17.060
play

12:18.540 --> 12:18.980
free

12:19.580 --> 12:19.940
video

12:19.940 --> 12:20.660
看一下行不行

12:21.540 --> 12:22.100
是不是可以

12:22.460 --> 12:24.060
为什么它原型链上了

12:24.940 --> 12:25.980
在原型链上了

12:26.380 --> 12:27.660
它这里它这里找不到

12:27.660 --> 12:29.140
它就会继续往上着

12:29.460 --> 12:30.140
是不是可以找到了

12:30.500 --> 12:32.900
那有一天我觉得VIPUser

12:32.900 --> 12:34.660
他看免费视频的时候

12:34.940 --> 12:35.940
还要去交广告

12:36.460 --> 12:38.420
那我是不是要重新实现这个方法

12:38.420 --> 12:39.620
那重新实现没关系

12:39.620 --> 12:41.260
你既然功能有变化

12:41.700 --> 12:42.220
功能有变化

12:42.220 --> 12:44.940
我是不是在这里加一个playfree video就可以了

12:45.580 --> 12:47.380
比方说那我就可以加上

12:49.860 --> 12:50.660
VIPUser

12:51.100 --> 12:52.460
那这就比较重复代码了

12:52.460 --> 12:53.340
因为你有变化

12:53.820 --> 12:54.060
对吧

12:54.060 --> 12:55.380
我们这里就输出一个

12:55.380 --> 12:58.620
削掉广告的免费视频

13:00.300 --> 13:00.700
对吧

13:00.700 --> 13:01.820
它就运行我们这个了

13:02.100 --> 13:03.340
这样的好处在于什么呢

13:03.340 --> 13:05.260
就是我这里可以改变

13:05.660 --> 13:06.540
上面的行为

13:07.020 --> 13:09.260
但是我不会影响到User

13:09.460 --> 13:12.460
User的对象它是不是还是用的是这个

13:13.060 --> 13:15.060
User的对象并没有影响

13:15.540 --> 13:17.060
它只是影响了VIPUser

13:17.060 --> 13:18.580
VIPUser看免费视频的时候

13:18.580 --> 13:19.220
去交了广告

13:19.220 --> 13:19.900
它用的是这个了

13:19.900 --> 13:20.940
因为在原型链子上

13:20.940 --> 13:21.740
原型链子上

13:22.300 --> 13:23.340
发现这个就用这个

13:23.740 --> 13:26.460
就这里面新写一个playfree video

13:26.700 --> 13:28.700
它就不会继续往后查到了

13:29.260 --> 13:30.700
这就是一种完美的解决方法

13:30.700 --> 13:32.300
那么到此就完美的解决了

13:32.300 --> 13:35.180
之前提到了两处重复代码的问题

13:35.180 --> 13:35.820
都解决了

13:35.820 --> 13:36.820
而且非常灵活

13:36.820 --> 13:39.580
我可以跟VIPU的可以更改之前的行为

13:40.300 --> 13:41.580
而不会影响到User

13:42.420 --> 13:43.180
对它就完事了

13:43.820 --> 13:44.860
这就是我要做的事情

13:46.580 --> 13:49.220
那么这一切它跟继承有啥关系呢

13:49.980 --> 13:50.660
是这样子的

13:50.980 --> 13:51.860
这就是继承

13:52.100 --> 13:52.820
这就是继承

13:52.820 --> 13:53.780
就写完了都已经

13:54.340 --> 13:56.180
其实你看着它也不复杂的

13:56.540 --> 13:57.500
它也没什么好复杂的

13:57.500 --> 13:58.780
你把原型链理解清楚

13:58.780 --> 13:59.620
它就不复杂了

14:00.460 --> 14:01.340
继承有什么关系呢

14:01.340 --> 14:02.540
继承它其实是这样的

14:02.540 --> 14:03.940
它是面向对象的概念

14:03.940 --> 14:06.060
面向对象我们这里肯定不涉及了

14:06.900 --> 14:09.380
一学前端再来一个面向对象你就疯掉了

14:09.900 --> 14:11.060
肯定不涉及面向对象了

14:11.060 --> 14:12.940
但是它是面向对象的概念

14:12.940 --> 14:14.700
你只需要知道这件事就行了

14:16.220 --> 14:18.540
它主要这些都是科普性质的

14:18.540 --> 14:20.460
就你作为一个程序而

14:21.180 --> 14:23.460
你虽然说咱们前端不学面向对象

14:23.460 --> 14:24.660
再多多少少指导一点

14:24.660 --> 14:26.060
多指导一点没坏处

14:27.500 --> 14:29.500
纯粹是吹牛的

14:29.500 --> 14:30.340
可以吹牛用的

14:31.220 --> 14:32.580
它是面向对象的概念

14:32.580 --> 14:35.540
它描述了两个对象内形的关系

14:35.660 --> 14:38.540
这里有个概念叫做什么叫对象内形

14:39.740 --> 14:40.500
叫做对象内形

14:41.340 --> 14:43.500
VIP user就是一个对象内形

14:44.700 --> 14:47.860
它可以产生付费用户

14:47.860 --> 14:48.860
这是普通用户

14:48.860 --> 14:50.180
普通用户的对象内形

14:50.180 --> 14:51.620
你这个用户是普通用户

14:51.620 --> 14:53.580
还是VIP用户

14:54.460 --> 14:58.620
那么说普通用户和VIP用户就是对象内形

14:59.740 --> 15:01.020
在我们的代码里边

15:01.020 --> 15:02.900
它表述为

15:05.580 --> 15:06.420
在我们的代码里边

15:06.420 --> 15:09.460
它表述为内获得了构造函数

15:10.460 --> 15:12.020
内是什么夹法啊

15:12.020 --> 15:12.580
谁瞎陪啊

15:12.580 --> 15:13.620
这些语言的概念

15:14.540 --> 15:16.380
在我们介石里边就是构造函数

15:16.380 --> 15:17.620
你可以认为它是一个东西

15:18.700 --> 15:19.500
内和构造函数

15:19.500 --> 15:19.980
内是什么

15:19.980 --> 15:20.460
就是内形

15:21.020 --> 15:21.700
对象的内形

15:22.420 --> 15:22.900
构造函数

15:22.900 --> 15:23.940
其实在我们介石里面

15:23.940 --> 15:24.940
就是一个东西

15:24.940 --> 15:27.980
它描述了构造函数之间的关系

15:28.500 --> 15:29.100
这就是继承

15:30.100 --> 15:32.140
在具体一点的话就这样子

15:32.700 --> 15:34.020
如果说有一个东西

15:34.020 --> 15:34.940
它可以这样描述

15:35.340 --> 15:36.740
A不一定是B

15:36.740 --> 15:37.980
但B一定是A

15:38.980 --> 15:39.460
来看一下

15:40.460 --> 15:43.020
用户不一定是VIP用户

15:43.900 --> 15:46.180
但VIP用户一定是用户

15:46.820 --> 15:47.740
是不是可以描述出来了

15:48.780 --> 15:49.980
只要你看现实生活当中

15:49.980 --> 15:51.260
你到处去举例子

15:51.260 --> 15:52.940
你只要能够描述出来这么一个东西

15:53.780 --> 15:55.020
那继承关系就形成了

15:55.620 --> 15:56.740
从逻辑上就形成了

15:57.380 --> 15:59.060
用户不一定是VIP用户

15:59.060 --> 16:00.140
但是VIP用户

16:00.140 --> 16:01.340
一个都不能少

16:01.340 --> 16:03.540
反过来到过去都要能够描述出来

16:04.100 --> 16:05.660
用户不一定是VIP用户

16:05.660 --> 16:07.180
VIP用户一定是用户

16:07.860 --> 16:09.860
那么它的逻辑上就形成了继承关系

16:10.380 --> 16:11.660
面向对象用来干嘛的

16:11.660 --> 16:13.380
就是来描述现实世界的

16:16.300 --> 16:17.900
那么它怎么形成关系的

16:17.900 --> 16:20.020
它形成的关系我们可以这样子来说

16:20.020 --> 16:23.220
用专业数据来说就是B继承A

16:23.220 --> 16:24.540
A派生B

16:24.540 --> 16:26.060
A是B的负类

16:26.060 --> 16:27.740
B是A的纸类

16:27.740 --> 16:28.500
啥意思

16:28.500 --> 16:29.540
我们再来一次

16:29.540 --> 16:32.180
用户不一定是VIP用户

16:32.180 --> 16:33.780
VIP用户一定是用户

16:33.780 --> 16:38.180
所以说我们认为VIP用户继承用户

16:40.970 --> 16:44.610
用户派生VIP用户

16:44.610 --> 16:46.730
就是这个概念不用去背

16:46.730 --> 16:47.570
制造就行了

16:47.570 --> 16:48.610
忘了也没关系

16:50.490 --> 16:54.170
也可以说用户是VIP用户的负类

16:54.530 --> 16:57.490
VIP用户是用户的纸类

16:59.050 --> 17:00.770
这就是继承关系就形成了

17:01.930 --> 17:03.010
负质关系就形成了

17:03.610 --> 17:05.850
那么形成了负质关系有什么用呢

17:05.850 --> 17:07.050
它有这么一个特点

17:07.050 --> 17:11.730
纸类的实力应该自动的拥有负类的所有成员

17:11.730 --> 17:12.570
这啥意思

17:12.570 --> 17:15.490
你VIP用户是U字的纸类

17:15.490 --> 17:17.730
那么U字有的东西那你肯定有

17:17.730 --> 17:18.250
对吧

17:18.250 --> 17:20.290
就像家里边遗产继承一样

17:20.290 --> 17:20.810
对吧

17:20.810 --> 17:22.890
负贝的遗产就直接继承下来了

17:22.890 --> 17:24.970
你有的东西我一定有

17:24.970 --> 17:26.970
你有的属性我一定有

17:26.970 --> 17:29.090
你有的方法我一定有

17:29.090 --> 17:30.530
这就是继承关系

17:31.530 --> 17:35.250
它是用来描述我们的对象之间的关系的

17:35.890 --> 17:37.410
继承里边有两个特性

17:37.410 --> 17:39.050
那这个关系纯粹是了解的

17:39.050 --> 17:40.970
这是面向对象里边的东西

17:40.970 --> 17:42.090
一个叫单根性

17:42.850 --> 17:44.850
纸类最多只有一个负类

17:46.330 --> 17:47.610
它不可能有多个父亲吗

17:49.130 --> 17:51.930
我们说邓哥的父亲没问题

17:51.930 --> 17:53.930
我们不能说邓哥的父亲门

17:53.930 --> 17:54.730
这就出问题了

17:54.730 --> 17:55.050
对吧

17:55.050 --> 17:56.610
它只有一个父亲

17:56.610 --> 17:59.090
那么其实在我们的这里的也可以看到

17:59.130 --> 17:59.810
非常清楚

18:01.050 --> 18:03.690
这里的就是引示原型

18:03.690 --> 18:04.450
它只有一个

18:04.450 --> 18:05.570
它不可能有多个

18:05.570 --> 18:06.130
对不对

18:06.130 --> 18:07.010
就是这么个意思

18:08.090 --> 18:08.970
叫单根性

18:08.970 --> 18:10.690
什么叫继承的传递性呢

18:10.690 --> 18:13.850
就是间接父类的成员会传递到子类当中

18:13.850 --> 18:15.010
比方说像这个图里边

18:15.490 --> 18:16.450
不接个册

18:18.250 --> 18:20.610
是不是它的间接父类

18:21.770 --> 18:22.010
对吧

18:22.010 --> 18:23.170
是不是它的间接父类

18:23.410 --> 18:25.650
那么它里边的成员

18:25.650 --> 18:26.770
它里边是不是也可以

18:27.130 --> 18:27.450
对吧

18:27.450 --> 18:28.450
它会传递过来

18:29.090 --> 18:30.090
其实跟我们一样

18:30.090 --> 18:31.170
就是原型连的茶招

18:31.850 --> 18:32.770
它没有就找它

18:32.770 --> 18:33.970
它没有的话就找到它

18:34.370 --> 18:37.090
所以说我们由于我们的解释里边

18:37.090 --> 18:38.970
所有的东西都是对象

18:38.970 --> 18:40.690
最终的原型连上都有它

18:40.690 --> 18:41.770
所以说我们可以认为

18:41.770 --> 18:43.850
Objects是所有的父类

18:44.530 --> 18:45.530
所有的东西

18:45.530 --> 18:46.570
所有的构造函数

18:46.570 --> 18:49.370
所有的内都继承制Objects

18:50.090 --> 18:51.450
说Object里边有的东西

18:51.450 --> 18:52.730
所有的对象都有

18:53.410 --> 18:54.530
除非你搞些超操作

18:54.530 --> 18:56.450
比方上一课的Objects

18:56.450 --> 18:57.450
这种超操作

18:57.450 --> 19:00.090
你更改了它的隐释原型

19:00.090 --> 19:01.650
否则的话正常情况下

19:01.650 --> 19:03.450
它里边有的东西

19:03.450 --> 19:04.450
就这里边有的东西

19:04.450 --> 19:05.970
所有的对象都会受到影响

19:06.330 --> 19:06.650
为什么

19:06.650 --> 19:07.930
因为有这个继承关系

19:09.330 --> 19:10.010
那就完了

19:10.010 --> 19:11.170
其实没有啥

19:11.170 --> 19:13.530
其实就是逻辑说出来很吓人

19:13.530 --> 19:14.970
面向对象是这样子的

19:14.970 --> 19:16.250
面向对象

19:16.250 --> 19:18.250
单一码其实不复杂

19:19.090 --> 19:20.490
面向对象复杂的是什么呢

19:20.490 --> 19:21.450
设计

19:22.610 --> 19:23.810
你一个程序

19:23.810 --> 19:25.250
系统里边有这么多东西

19:25.250 --> 19:25.490
对吧

19:25.490 --> 19:26.690
现实世界这么复杂

19:27.250 --> 19:28.050
在程序里边

19:28.050 --> 19:32.450
我如何来更好的来反议

19:32.450 --> 19:33.890
设置这个构造函数

19:33.890 --> 19:35.090
设置这个内

19:35.090 --> 19:36.970
来反映这个现实世界

19:36.970 --> 19:39.490
这一块设计是非常非常复杂的

19:41.410 --> 19:43.010
具体写单一码其实不复杂

19:43.010 --> 19:44.290
单一码就与法一不多

19:45.410 --> 19:46.210
就是我们这一块

19:46.210 --> 19:47.010
既然是跟面向对象

19:47.010 --> 19:47.970
没有什么直接关系

19:48.970 --> 19:50.410
那么在既然式里边

19:50.410 --> 19:52.530
我们如果说

19:52.530 --> 19:54.530
将来我们只是假设

19:54.530 --> 19:55.370
将来你们写程序

19:55.370 --> 19:58.130
基本上99%的情况下跟继承都没关系

19:58.130 --> 19:59.450
那假设吗

19:59.450 --> 20:00.570
我们将来写程序的时候

20:00.570 --> 20:02.050
有很多地方都需要继承

20:02.050 --> 20:03.290
这个东西比方说

20:03.290 --> 20:05.050
一只猫是一个动物

20:05.050 --> 20:06.290
动物不一定是猫

20:06.290 --> 20:08.370
猫和动物是继承关系

20:08.370 --> 20:11.450
VIP用户和用户之间形成继承关系

20:11.450 --> 20:12.370
对吧

20:12.370 --> 20:14.730
登革和老师之间形成继承关系

20:14.730 --> 20:15.650
登革是一个老师

20:15.650 --> 20:17.370
老师不一定是登革吗

20:17.370 --> 20:18.170
继承继承关系

20:18.170 --> 20:19.090
到处是继承关系

20:19.090 --> 20:22.410
那我每一次都要来这一坨代码

20:22.410 --> 20:24.770
就是原先上车轨代码

20:24.810 --> 20:25.930
其实也没多复杂

20:25.930 --> 20:26.490
对吧

20:26.490 --> 20:27.490
就一句话的是

20:27.490 --> 20:29.690
那我能不能再把它封装一下呢

20:29.690 --> 20:30.690
其实可以

20:31.690 --> 20:32.770
怎么来封装呢

20:32.770 --> 20:33.850
我写一个函数

20:33.850 --> 20:35.650
以后就到处可以用了

20:35.650 --> 20:36.730
就是把那个内句话

20:36.730 --> 20:37.770
给它放到函数里边

20:37.770 --> 20:38.770
inherit

20:38.770 --> 20:40.570
你给我传一个纸

20:40.570 --> 20:41.890
纸内的构造函数

20:41.890 --> 20:43.370
就是传一个纸构造函数

20:43.370 --> 20:45.770
传一个副构造函数

20:45.770 --> 20:46.890
那到处我用的时候

20:46.890 --> 20:48.130
我就这样子用

20:48.130 --> 20:49.610
inherit

20:49.610 --> 20:52.410
我希望VIP user和user之间产生关联

20:52.410 --> 20:54.010
把纸内传进去

20:54.010 --> 20:55.290
副内传进去

20:55.290 --> 20:56.250
说到内

20:56.250 --> 20:58.770
在我们的纪冶室里面就是构造函数

20:58.770 --> 20:59.530
纸内传进去

20:59.530 --> 21:00.810
副内传进去

21:00.810 --> 21:03.730
然后把这句话贴进来

21:03.730 --> 21:05.250
这里换成child

21:05.250 --> 21:06.770
这里换成parent

21:06.770 --> 21:07.570
就我焊了

21:07.570 --> 21:08.570
就封装一下

21:08.570 --> 21:10.890
让之后的继承变得更加简单

21:10.890 --> 21:11.530
完了

21:11.530 --> 21:12.810
那这里能不能封装呢

21:12.810 --> 21:15.810
这里是不好封装的

21:15.810 --> 21:16.730
这里是不好封装的

21:16.730 --> 21:17.850
这里要封装的

21:17.850 --> 21:19.410
让它简洁一点是可以的

21:19.410 --> 21:20.730
但是你不能省略这句话

21:20.770 --> 21:23.970
这句话是肯定无法省略的

21:23.970 --> 21:27.010
任何语言里边这句话都不能省略

21:27.010 --> 21:28.370
但是这句话可以把它简化

21:28.370 --> 21:29.850
到这里我就不说了

21:29.850 --> 21:32.690
怎么去简化它不说了

21:32.690 --> 21:34.370
那就完了

21:34.370 --> 21:36.010
就完了这就是继承

21:36.010 --> 21:37.650
这其实并不复杂

21:37.650 --> 21:39.090
在过去这里了解一下

21:39.090 --> 21:39.730
在过去

21:39.730 --> 21:41.170
这个以后我们在比面试的时候

21:41.170 --> 21:42.250
还会想起讲

21:42.250 --> 21:45.730
过去由于没有提供更改隐私员性的办法

21:45.730 --> 21:49.130
你看这句话是不是在更改隐私员性

21:49.130 --> 21:51.730
但是过去是没有这个函数的

21:51.730 --> 21:52.770
现在有了

21:52.770 --> 21:54.130
以前没有

21:54.130 --> 21:57.130
以前由于没有更改隐私员性的办法

21:57.130 --> 22:01.130
所以又不能直接使用这个玩意儿

22:03.440 --> 22:05.320
官方不让用

22:05.320 --> 22:06.840
那过去就废老大事了

22:06.840 --> 22:07.560
这个玩意儿

22:07.560 --> 22:10.120
这个函数就没有那么简单了

22:10.120 --> 22:11.720
过去造一大偶

22:11.720 --> 22:13.320
然后来解决这个问题

22:13.320 --> 22:15.520
因为他们不能直接设置隐私员性

22:15.520 --> 22:17.520
那个时候我们想了一种办法

22:17.520 --> 22:19.720
我们把它称之为胜悲模式

22:19.720 --> 22:20.280
来解决

22:20.280 --> 22:21.680
来达到同样的目的

22:21.680 --> 22:22.560
这里不介绍了

22:22.560 --> 22:23.720
以后比面试会介绍

22:25.120 --> 22:25.720
那就没了

22:25.720 --> 22:26.600
这是继承

22:26.600 --> 22:27.320
下来过后

22:27.320 --> 22:29.280
同学们要做的事情

22:29.280 --> 22:30.720
就一件事

22:30.720 --> 22:33.440
就是把这个袁老师在课程上写的一个代码

22:33.440 --> 22:34.360
自己写一遍

22:34.360 --> 22:35.120
有那么个印象

22:35.120 --> 22:37.720
知道一个继承怎么回事

22:37.720 --> 22:38.720
啥叫继承

22:39.920 --> 22:41.720
接下来表述

22:41.720 --> 22:43.720
就完事了

22:43.720 --> 22:43.960
OK

22:43.960 --> 22:45.120
这是关于这个继承

