WEBVTT

00:00.620 --> 00:02.620
好 语言行列

00:02.620 --> 00:04.220
这一块儿知识

00:04.220 --> 00:10.020
它直接决定了你对介石这门语言玩得溜不溜

00:10.020 --> 00:12.820
你要把这一本语言玩得很溜的话

00:12.820 --> 00:14.820
这一块儿知识就很重要

00:14.820 --> 00:16.820
你不想玩得很溜的话

00:16.820 --> 00:18.820
那这一块儿知识就没有那么重要

00:18.820 --> 00:20.320
这一块儿知识呢

00:20.320 --> 00:22.820
也是面试里边的一个重点的口点

00:22.820 --> 00:25.320
为什么现在就要拿出来讲了

00:25.320 --> 00:27.320
不是 咱们之后有一门

00:27.320 --> 00:29.320
专门的课讲笔面试 对吧

00:29.620 --> 00:31.620
里边还会再重新讲

00:31.620 --> 00:33.620
然后结合面试题再重新讲一遍

00:33.620 --> 00:35.620
其实这一块儿呢

00:35.620 --> 00:37.620
那种都是一样的

00:37.620 --> 00:40.620
但是我必须要让你们提前知道一下

00:40.620 --> 00:43.120
你至少你现在可能会理解得抹抹忽忽的

00:43.120 --> 00:44.120
都没有关系

00:44.120 --> 00:46.120
但是你要知道有这么多东西存在

00:46.120 --> 00:48.120
不知道的话

00:48.120 --> 00:50.120
那后边就会埋下无数的隐患

00:50.120 --> 00:52.120
对后边的学习

00:52.120 --> 00:54.120
它其实也没有多难了

00:54.120 --> 00:56.120
就是稍微的有点绕

00:56.120 --> 00:58.120
其实我们之前已经铺垫了

00:58.120 --> 01:00.120
什么构造函数啊 值和引用啊

01:00.120 --> 01:02.120
还有就是那个

01:02.120 --> 01:04.120
圆形方面的知识

01:04.120 --> 01:06.120
你把前面的知识理解清楚了

01:06.120 --> 01:08.120
学习这一块儿就不是那么难了

01:08.120 --> 01:10.120
就还是比较轻松愉快的

01:12.120 --> 01:14.120
然后我们这几个目标

01:14.120 --> 01:16.120
因为毕竟不是笔面试课程嘛

01:16.120 --> 01:18.120
虽然我们这一块儿

01:18.120 --> 01:20.120
也会涉及到了一些面试题

01:20.120 --> 01:22.120
其实这几个听完了

01:22.120 --> 01:24.120
如果说你真正理解了

01:24.120 --> 01:26.120
那后边笔面试的时候

01:27.120 --> 01:29.120
我们这一集可能目标

01:29.120 --> 01:30.120
不是做面试题

01:30.120 --> 01:32.120
面试题我会讲

01:32.120 --> 01:34.120
我们的目标还是要做练习题

01:34.120 --> 01:36.120
就是你只要能够把练习题

01:36.120 --> 01:38.120
做出来就ok

01:38.120 --> 01:40.120
不管你前面听的如何模糊都没关系

01:40.120 --> 01:42.120
你只要能够做出来练习题就可以了

01:42.120 --> 01:44.120
所以说没有那么大的压力

01:44.120 --> 01:46.120
如果说有点模糊以后再说

01:46.120 --> 01:48.120
都没关系

01:48.120 --> 01:50.120
其实这一块儿听下来的话

01:50.120 --> 01:52.120
我觉得毕竟是我来讲嘛

01:52.120 --> 01:54.120
应该是你只要稍稍总结一下

01:54.120 --> 01:56.120
回顾一下

01:56.120 --> 01:58.120
课后再把这个文档对到这个图

01:58.120 --> 02:00.120
下边这张图好好看一下

02:00.120 --> 02:02.120
也就不模糊了

02:02.120 --> 02:04.120
我们来看一下什么是圆形连

02:04.120 --> 02:06.120
首先第一点大家再一次给大家强调

02:06.120 --> 02:08.120
所有的对象

02:08.120 --> 02:10.120
都是通过6的

02:10.120 --> 02:12.120
方式来创建的

02:12.120 --> 02:14.120
本质上都是通过6的方式来创建的

02:14.120 --> 02:16.120
本质上都是通过6的方式来创建的

02:16.120 --> 02:18.120
比方说

02:18.120 --> 02:20.120
我们有一个U字2构造函数

02:20.120 --> 02:22.120
所以6一个U字2创建个对象

02:22.120 --> 02:24.120
那如果说这样子写呢

02:24.120 --> 02:26.120
这样子写呢等效于

02:26.120 --> 02:28.120
下面的写法

02:28.120 --> 02:30.120
6的一个object来创建对象

02:30.120 --> 02:32.120
然后给它属性复制

02:32.120 --> 02:34.120
都是通过6的方式来创建的

02:34.120 --> 02:36.120
那么我们

02:36.120 --> 02:38.120
上面的代码就会形成两张

02:38.120 --> 02:40.120
圆形图你看一下

02:40.120 --> 02:42.120
通过6一个U字2

02:42.120 --> 02:44.120
U字2是个构造函数

02:44.120 --> 02:46.120
6的一个实力

02:46.120 --> 02:48.120
实力是一个隐释圆形

02:48.120 --> 02:50.120
指向这个U字的圆形

02:50.120 --> 02:52.120
这张图是不是建了很多次了

02:52.120 --> 02:54.120
然后我们下面这个代码

02:54.120 --> 02:56.120
这个代码呢也是一样

02:56.120 --> 02:58.120
因为它相当于是6一个object

02:58.120 --> 03:00.120
构造函数

03:00.120 --> 03:02.120
6

03:02.120 --> 03:04.120
有的人说这这一点

03:04.120 --> 03:06.120
我随便给大家说一下

03:06.120 --> 03:08.120
就是那个在

03:08.120 --> 03:10.120
面试题的时候呢

03:10.120 --> 03:12.120
我记得有一次

03:12.120 --> 03:14.120
面试题里面考到这个东西

03:14.120 --> 03:16.120
他问你type

03:16.120 --> 03:18.120
type object

03:18.120 --> 03:20.120
objects到底是一个啥

03:20.120 --> 03:22.120
是一个啥呢

03:22.120 --> 03:24.120
应该是一个对象

03:24.120 --> 03:26.120
因为它的名字叫objects

03:26.120 --> 03:28.120
不是的它是一个构造函数

03:28.120 --> 03:30.120
说它得到的结果是一个方形

03:30.120 --> 03:32.120
是一个函数

03:32.120 --> 03:34.120
因为我们平时要6一个object

03:34.120 --> 03:36.120
通过这种方式来创建对象的

03:36.120 --> 03:38.120
因此它只能是函数

03:38.120 --> 03:40.120
这里随便给大家说一下

03:40.120 --> 03:42.120
objects个构造函数

03:42.120 --> 03:44.120
通过它留了一个普通对象

03:44.120 --> 03:46.120
它的隐释圆形

03:46.120 --> 03:48.120
还是这么个三角关系

03:48.120 --> 03:50.120
三角关系是不变的

03:50.120 --> 03:52.120
好,接下来就好玩的事情出现了

03:54.120 --> 03:56.120
隐释圆形

03:56.120 --> 03:58.120
我们之前说过

03:58.120 --> 04:00.120
隐释圆形是所有对象

04:00.120 --> 04:02.120
都有的

04:02.120 --> 04:04.120
所有的对象都有隐释圆形的

04:04.120 --> 04:06.120
是吧

04:06.120 --> 04:08.120
那圆形

04:08.120 --> 04:10.120
是不是个对象呢

04:10.120 --> 04:12.120
这个圆形是不是对象啊

04:12.120 --> 04:14.120
这个圆形

04:14.120 --> 04:16.120
也是对象

04:16.120 --> 04:18.120
比方说吧

04:18.120 --> 04:20.120
我们来看一个例子

04:20.120 --> 04:22.120
这里我们有一个自己写个构造函数

04:22.120 --> 04:24.120
我们就随便写一个

04:24.120 --> 04:26.120
空的都没关系

04:26.120 --> 04:28.120
我们直接输出

04:28.120 --> 04:30.120
这个函数的proto type

04:30.120 --> 04:32.120
它是不是一个对象

04:32.120 --> 04:34.120
它也是一个对象

04:34.120 --> 04:36.120
那它是对象的话

04:36.120 --> 04:38.120
它有没有隐释圆形

04:38.120 --> 04:40.120
它也应该有隐释圆形

04:40.120 --> 04:42.120
才对

04:42.120 --> 04:44.120
下面你看

04:44.120 --> 04:46.120
圆形对象

04:46.120 --> 04:48.120
就这个玩意儿本身

04:48.120 --> 04:50.120
它也是一个对象

04:50.120 --> 04:52.120
默认情况下呢

04:52.120 --> 04:54.120
这个圆形对象是哪来的

04:54.120 --> 04:56.120
因为我们知道所有对象都是通风溜来产生的

04:56.120 --> 04:58.120
那圆形对象哪来的呢

04:58.120 --> 05:00.120
是浏览器直接帮你溜出来的

05:00.120 --> 05:02.120
它溜的是谁

05:02.120 --> 05:04.120
溜的是OBGX

05:04.120 --> 05:06.120
所以说这个圆形对象是谁来溜出来的

05:06.120 --> 05:08.120
是不是OBGX溜出来的

05:08.120 --> 05:10.120
那么它的隐释圆形

05:10.120 --> 05:12.120
应该指向OBGX的圆形

05:14.120 --> 05:16.120
就这么个东西

05:16.120 --> 05:18.120
说说上面的两副圆形图

05:18.120 --> 05:20.120
实际上它是有关联的

05:20.120 --> 05:22.120
关联在哪呢

05:22.120 --> 05:24.120
你看看

05:24.120 --> 05:26.120
通过六一个U字的构造函数

05:26.120 --> 05:28.120
它产生了一个对象

05:28.120 --> 05:30.120
这个对象的隐释圆形指向U字的

05:30.120 --> 05:32.120
因为U字是U字

05:32.120 --> 05:34.120
所以它的隐释圆形指向的是U字的圆形

05:36.120 --> 05:38.120
而这个圆形它本身也是对象

05:38.120 --> 05:40.120
它是通过哪来的

05:40.120 --> 05:42.120
它是通过六一个OBGX产生的

05:42.120 --> 05:44.120
所以说呢

05:44.120 --> 05:46.120
它的隐释圆形呢

05:46.120 --> 05:48.120
它就指向OBGX的圆形

05:48.120 --> 05:50.120
你把这张图先看懂

05:50.120 --> 05:52.120
对吧

05:52.120 --> 05:54.120
然后其中一个比较特殊的点的

05:54.120 --> 05:56.120
就是OBGX的圆形

05:56.120 --> 05:58.120
它不是也是对象吗

05:58.120 --> 06:00.120
但是这一点是特殊点

06:00.120 --> 06:02.120
特殊情况

06:02.120 --> 06:04.120
它的圆形哪来的呢

06:04.120 --> 06:06.120
它也是对象

06:06.120 --> 06:08.120
指向的是NOW

06:08.120 --> 06:10.120
指向的是空

06:10.120 --> 06:12.120
那么你看一下这一块

06:12.120 --> 06:14.120
是不是形成了一个链条啊

06:16.120 --> 06:18.120
是不是形成了一个链条

06:18.120 --> 06:20.120
U1这个对象

06:20.120 --> 06:22.120
它的隐释圆形指向它

06:22.120 --> 06:24.120
它的隐释圆形有指向它

06:24.120 --> 06:26.120
它的隐释圆形指向NOW

06:26.120 --> 06:28.120
这就是圆形链

06:28.120 --> 06:30.120
所以圆形链是怎么产生的

06:30.120 --> 06:32.120
是通过隐释圆形

06:32.120 --> 06:34.120
一块一块往上指

06:34.120 --> 06:36.120
一条链条是叫圆形链

06:36.120 --> 06:38.120
那么这个圆形链有什么意义呢

06:38.120 --> 06:40.120
大家看下面这句话

06:40.120 --> 06:42.120
当读取一个对象的成员的时候

06:42.120 --> 06:44.120
会先看对象自生

06:44.120 --> 06:46.120
有没有这个成员

06:46.120 --> 06:48.120
如果说没有

06:48.120 --> 06:50.120
一次在圆形链上

06:50.120 --> 06:52.120
查找

06:52.120 --> 06:54.120
我们之前怎么说

06:54.120 --> 06:56.120
先找自己有没有

06:56.120 --> 06:58.120
再找它的隐释圆形有没有

06:58.120 --> 07:00.120
其实还没完

07:00.120 --> 07:02.120
还会继续往上找

07:02.120 --> 07:04.120
我们过去就相当于

07:04.120 --> 07:06.120
我而拼图就拼了一小块

07:06.120 --> 07:08.120
虽然说能看出来了大概是什么样子

07:08.120 --> 07:10.120
但是没有看到整个的全貌

07:10.120 --> 07:12.120
那么现在的这节课

07:12.120 --> 07:14.120
就告诉大家整个全貌是什么样子

07:14.120 --> 07:16.120
那你这一会清楚了过后

07:16.120 --> 07:18.120
既也是什么对象

07:18.120 --> 07:20.120
还说得非常非常清楚了

07:20.120 --> 07:22.120
我们来看一下

07:22.120 --> 07:24.120
这就解释了一个非常有意识的现象

07:24.120 --> 07:26.120
什么现象呢

07:26.120 --> 07:28.120
我们上节课不是

07:28.120 --> 07:30.120
学过那个东西吗

07:30.120 --> 07:32.120
一个对象

07:32.120 --> 07:34.120
比方说我们这里的

07:34.120 --> 07:36.120
有点

07:36.120 --> 07:38.120
有一个U

07:38.120 --> 07:40.120
好

07:40.120 --> 07:42.120
我们上节课不是有这么一个东西吗

07:42.120 --> 07:44.120
叫Hash

07:44.120 --> 07:46.120
OmProperty

07:46.120 --> 07:48.120
这里上面有这么一个函数

07:48.120 --> 07:50.120
有没有同学有奇怪呀

07:50.120 --> 07:52.120
这个函数哪来的呀

07:52.120 --> 07:54.120
原老师说这个函数一开始就有了

07:54.120 --> 07:56.120
好像就很神奇

07:56.120 --> 07:58.120
它就直接有了

07:58.120 --> 08:00.120
我自己这个对象上有没有

08:00.120 --> 08:02.120
肯定没有

08:02.120 --> 08:04.120
因为要有的话必须要写

08:04.120 --> 08:06.120
Z还是OmProperty

08:06.120 --> 08:08.120
就跟它复制为函数

08:08.120 --> 08:10.120
它自己有没有没有

08:10.120 --> 08:12.120
找它的原型

08:12.120 --> 08:14.120
找U的影视原型指向谁

08:14.120 --> 08:16.120
指向U的Prototype

08:16.120 --> 08:18.120
它上面有没有呢

08:18.120 --> 08:20.120
也没有

08:20.120 --> 08:22.120
但是为什么我这里就有了呢

08:22.120 --> 08:24.120
那只能是在原型链上

08:24.120 --> 08:26.120
它自己没有

08:26.120 --> 08:28.120
Object的原型上提供了这个函数

08:28.120 --> 08:30.120
好我们来验证一下

08:30.120 --> 08:32.120
Object的原型上面是不是真的提供了这个函数啊

08:32.120 --> 08:34.120
我们找到这个

08:34.120 --> 08:36.120
Object的Prototype上面

08:36.120 --> 08:38.120
是不是有一个HashOmProperty

08:38.120 --> 08:40.120
你看一下是不是出来了

08:40.120 --> 08:42.120
是不是一个函数

08:42.120 --> 08:44.120
所以说由于Object的原型上

08:44.120 --> 08:46.120
有这个函数

08:46.120 --> 08:48.120
因此呢在我们这个

08:48.120 --> 08:50.120
由者的实力上

08:50.120 --> 08:52.120
也能使用这个函数

08:52.120 --> 08:54.120
懂的意思吧

08:54.120 --> 08:56.120
也就是我再来说一点

08:56.120 --> 08:58.120
就是我们这个UDR

08:58.120 --> 09:00.120
HashOmProperty

09:00.120 --> 09:02.120
OmProperty

09:02.120 --> 09:04.120
是不是就应该等于

09:04.120 --> 09:06.120
Object的车Prototype

09:06.120 --> 09:08.120
HashOmProperty

09:08.120 --> 09:10.120
它两个是一样的

09:10.120 --> 09:12.120
所以说我们这里用的是啥

09:12.120 --> 09:14.120
用的就是它

09:14.120 --> 09:16.120
懂的意思吧

09:16.120 --> 09:18.120
那么换而言之

09:18.120 --> 09:20.120
其他的构造函数呢

09:20.120 --> 09:22.120
就我们这里是由者嘛

09:22.120 --> 09:24.120
是不是也是一样的

09:24.120 --> 09:26.120
换成任何构造函数

09:26.120 --> 09:28.120
通过其他的构造函数创建的对象

09:28.120 --> 09:30.120
它不是也有原型吗

09:30.120 --> 09:32.120
那它的原型是不是也只指向Object的Prototype

09:32.120 --> 09:34.120
也就产生了一个

09:34.120 --> 09:36.120
有意思的情况了

09:36.120 --> 09:38.120
我只要在Object的Prototype上面

09:38.120 --> 09:40.120
加上任何一个

09:40.120 --> 09:42.120
成员

09:42.120 --> 09:44.120
就会影响到所有的对象

09:44.120 --> 09:46.120
对吧

09:46.120 --> 09:48.120
那比方说我们在这里

09:48.120 --> 09:50.120
给Object个车

09:50.120 --> 09:52.120
Prototype加上一个A等于E

09:52.120 --> 09:54.120
你看一下

09:54.120 --> 09:56.120
我输出U点A

09:56.120 --> 09:58.120
它就是E

09:58.120 --> 10:00.120
U字里面说影响到了U字

10:00.120 --> 10:02.120
然后我们来看一下

10:02.120 --> 10:04.120
我们再来一个输组呢

10:04.120 --> 10:06.120
输组是不是也是溜出来的

10:06.120 --> 10:08.120
溜的是啥 溜的是Ry

10:08.120 --> 10:10.120
只不过把这里换成了Ry

10:10.120 --> 10:12.120
我就不写了

10:12.120 --> 10:14.120
Ry

10:14.120 --> 10:16.120
Ry也有实力嘛

10:16.120 --> 10:18.120
输组是不是有一个原型

10:18.120 --> 10:20.120
没有Object的东西

10:20.120 --> 10:22.120
所以说我们这里来换成Ry

10:22.120 --> 10:24.120
我们看一下Ry上面有没有A

10:24.120 --> 10:26.120
也有A

10:26.120 --> 10:28.120
看没有 如果说我以后要做一件事

10:28.120 --> 10:30.120
想影响到所有的对象

10:30.120 --> 10:32.120
里面都会加一个成员

10:32.120 --> 10:34.120
我们只需要往Object里面加就可以了

10:34.120 --> 10:36.120
对吧

10:36.120 --> 10:38.120
这就是一个原型链

10:38.120 --> 10:40.120
好

10:40.120 --> 10:42.120
这个其实我们理解到这

10:42.120 --> 10:44.120
就已经非常不错了

10:44.120 --> 10:46.120
但是呢

10:46.120 --> 10:48.120
这个电条权没 还没权

10:48.120 --> 10:50.120
为什么还没权呢

10:50.120 --> 10:52.120
因为

10:52.120 --> 10:54.120
袁老师之前还说过

10:54.120 --> 10:56.120
函数是不是也是对象啊

10:56.120 --> 10:58.120
函数不也是对象吗

10:58.120 --> 11:00.120
它是一种特殊的对象

11:00.120 --> 11:02.120
它可以雕用的

11:02.120 --> 11:04.120
它也是对象可以往里面加属

11:04.120 --> 11:06.120
只要是对象就是溜出来的

11:06.120 --> 11:08.120
不知道同学还记不记得

11:08.120 --> 11:10.120
我之前写过一个函数

11:10.120 --> 11:12.120
我说这个函数它也是对象

11:12.120 --> 11:14.120
然后我们之前还写过这个

11:14.120 --> 11:16.120
我写了这个函数

11:16.120 --> 11:18.120
我打写了

11:18.120 --> 11:20.120
我就这个函数

11:20.120 --> 11:22.120
ReturnA加B

11:22.120 --> 11:24.120
然后我说这个东西就相当于是溜了

11:24.120 --> 11:27.440
一个方形

11:27.440 --> 11:29.440
函数的

11:29.440 --> 11:31.440
函数的参数A

11:31.440 --> 11:33.440
参数B

11:33.440 --> 11:36.880
函数体为ReturnA加B

11:36.880 --> 11:38.880
函数本身也是对象

11:38.880 --> 11:40.880
只不过这个对象比较特殊

11:40.880 --> 11:42.880
你在这样子使用

11:42.880 --> 11:44.880
它里面也可以加属性

11:44.880 --> 11:46.880
只要是对象

11:46.880 --> 11:48.880
它就有隐私原象

11:48.880 --> 11:50.880
它就有隐私原象

11:50.880 --> 11:52.880
那么这张图其实还没有画完

11:52.880 --> 11:54.880
其他都画到了

11:54.880 --> 11:56.880
原象也是对象画到了

11:56.880 --> 11:58.880
但是函数这一块没画到

11:58.880 --> 12:00.880
那它的隐私原象又指向谁呢

12:00.880 --> 12:02.880
它的隐私原象又指向谁呢

12:02.880 --> 12:04.880
对吧

12:04.880 --> 12:06.880
那就是我们刚才说的

12:06.880 --> 12:08.880
它指向谁

12:08.880 --> 12:10.880
关键是看它是怎么出来的

12:10.880 --> 12:12.880
它怎么溜的是谁

12:12.880 --> 12:14.880
溜的是方形

12:14.880 --> 12:16.880
因此呢

12:16.880 --> 12:18.880
它们的隐私原象应该指向方形的原象

12:18.880 --> 12:20.880
所以说我们这里可以看到

12:20.880 --> 12:22.880
函数的

12:22.880 --> 12:24.880
隐私原象

12:24.880 --> 12:26.880
应该等于方形的Prototype

12:26.880 --> 12:28.880
好

12:28.880 --> 12:30.880
接下来

12:30.880 --> 12:32.880
符号作文

12:32.880 --> 12:34.880
下边就是完整的链条

12:34.880 --> 12:36.880
这就是整个天空了

12:36.880 --> 12:38.880
整张拼图就出来了

12:38.880 --> 12:40.880
就这个

12:40.880 --> 12:42.880
刚才上面的那张图是一样的

12:42.880 --> 12:44.880
它溜就是有很多箭头

12:44.880 --> 12:46.880
这个很淡的箭头就是溜出来的

12:46.880 --> 12:48.880
它自定义函数溜的

12:48.880 --> 12:50.880
我们来看看溜的实力

12:50.880 --> 12:52.880
它的隐私原象指向

12:52.880 --> 12:54.880
自定义函数的原象

12:54.880 --> 12:56.880
包括什么耳锐

12:56.880 --> 12:58.880
还有自己的user自己定的

12:58.880 --> 13:00.880
构造函数

13:00.880 --> 13:02.880
这个原象本身也是对象

13:02.880 --> 13:04.880
它的隐私原象指向Object的原象

13:04.880 --> 13:06.880
为什么

13:06.880 --> 13:08.880
因为它是通过溜Object的产生的

13:08.880 --> 13:10.880
关系

13:10.880 --> 13:12.880
这个不要去背

13:12.880 --> 13:14.880
这个图我都被背不住

13:14.880 --> 13:16.880
如果说你将来做面试题

13:16.880 --> 13:18.880
这个东西只有做面试题的时候有用

13:18.880 --> 13:20.880
做面试题的时候

13:20.880 --> 13:22.880
如果说需要这张图的话

13:22.880 --> 13:24.880
你自己去推导

13:24.880 --> 13:26.880
或者把元老社图保存到手机里面

13:26.880 --> 13:28.880
这张图可以解决

13:28.880 --> 13:30.880
所有的原形链的面试题

13:30.880 --> 13:32.880
就出来了

13:32.880 --> 13:34.880
左边我们已经画过一次了

13:34.880 --> 13:36.880
我们关键是看右边的

13:36.880 --> 13:38.880
我们现在有了一个方可形

13:38.880 --> 13:40.880
方可形是一个函数

13:40.880 --> 13:42.880
那么这个函数

13:42.880 --> 13:44.880
是浏览器运行的时候

13:44.880 --> 13:46.880
它直接给你放进去了

13:46.880 --> 13:48.880
相当于是宇宙战争之初

13:48.880 --> 13:50.880
一个创世神

13:50.880 --> 13:52.880
直接把这个函数安进来的

13:52.880 --> 13:54.880
有了这个函数过后

13:54.880 --> 13:56.880
有了这个方可形之后

13:56.880 --> 13:58.880
我们就可以通过6一个方可形

13:58.880 --> 14:00.880
来产生各种各样的函数

14:00.880 --> 14:02.880
包括我们的Object车

14:02.880 --> 14:04.880
哪来的6方可形

14:04.880 --> 14:06.880
就是6它出来的

14:06.880 --> 14:08.880
6一个方可形就产生一个函数

14:08.880 --> 14:10.880
Object车通过6一个方可形

14:10.880 --> 14:12.880
就产生一个Object车

14:12.880 --> 14:14.880
通过6一个方可形就产生一个自定义函数

14:14.880 --> 14:16.880
包括我们刚才的上

14:16.880 --> 14:18.880
对吧

14:18.880 --> 14:20.880
所以说我们由于

14:20.880 --> 14:22.880
6的方可形产生Object车

14:22.880 --> 14:24.880
除了Object车的隐私原型

14:24.880 --> 14:26.880
你看指向的是方可形的原型

14:26.880 --> 14:28.880
自定义函数的隐私原型

14:28.880 --> 14:30.880
指向的是方可形的原型

14:30.880 --> 14:32.880
而方可形的原型

14:32.880 --> 14:34.880
因为它也是对象

14:34.880 --> 14:36.880
它又是6Object车产生的

14:36.880 --> 14:40.570
所以它的隐私原型又指向的是Object车

14:40.570 --> 14:42.570
然后我们再看

14:42.570 --> 14:44.570
方可形的字节也有隐私原型

14:44.570 --> 14:46.570
不过这个隐私原型比较特殊

14:46.570 --> 14:48.570
这张图里有两个特殊点

14:48.570 --> 14:50.570
一个是这个隐私原型指向大

14:50.570 --> 14:52.570
一个是方形的隐私原型

14:52.570 --> 14:54.570
因为它就不是6产生的

14:54.570 --> 14:56.570
它是通过C和Ca加代码

14:56.570 --> 14:58.570
写出来的

14:58.570 --> 15:00.570
它不是通过6产生的

15:00.570 --> 15:02.570
所以它的隐私原型是指向的

15:02.570 --> 15:04.570
隐私原型

15:04.570 --> 15:06.570
这一块跟我们开发没有什么关系

15:08.570 --> 15:10.570
这张图就出来了

15:10.570 --> 15:12.570
那么这张图对我们开发有什么意义呢

15:12.570 --> 15:14.570
首先我们来看

15:14.570 --> 15:16.570
我们之前不是说了

15:16.570 --> 15:18.570
所有的函数都有一个东西叫做什么

15:18.570 --> 15:22.330
叫core

15:22.330 --> 15:24.330
core来的

15:24.330 --> 15:26.330
函数自己有没有core

15:26.330 --> 15:29.770
我们来判断一下吧

15:29.770 --> 15:31.770
函数自己有没有core

15:31.770 --> 15:33.770
函数自己肯定是

15:33.770 --> 15:35.770
没有core的

15:35.770 --> 15:37.770
比方说s o n property

15:37.770 --> 15:39.770
有没有core的东西

15:39.770 --> 15:41.770
force

15:41.770 --> 15:43.770
是没有

15:43.770 --> 15:45.770
因此

15:45.770 --> 15:47.770
函数自己是没有core

15:47.770 --> 15:49.770
扩这个成员的

15:49.770 --> 15:51.770
你看我们还是按照这个规则来看

15:51.770 --> 15:53.770
自己没有这个成员

15:53.770 --> 15:55.770
它在哪里去找

15:55.770 --> 15:57.770
隐私原型上去找

15:57.770 --> 15:59.770
那说明啥

15:59.770 --> 16:01.770
说明为什么所有的函数都有core

16:01.770 --> 16:03.770
是因为在函数的圆形上就有这个东西

16:03.770 --> 16:05.770
好

16:05.770 --> 16:07.770
咱们来看一下

16:07.770 --> 16:09.770
就解释了很多问题了

16:09.770 --> 16:11.770
方个形的proto type上面是有core

16:11.770 --> 16:13.770
对吧

16:13.770 --> 16:15.770
看到没

16:15.770 --> 16:17.770
那我们自己的函数

16:17.770 --> 16:24.480
自己的函数为什么会有core

16:24.480 --> 16:26.480
自己的函数

16:26.480 --> 16:28.480
为什么会有core

16:28.480 --> 16:30.480
是不是因为方个形的隐私原

16:30.480 --> 16:32.480
它的圆形上有core

16:32.480 --> 16:34.480
所以说你看凉个sq

16:34.480 --> 16:36.480
为什么会有erplug

16:36.480 --> 16:38.480
是不是就解释了

16:38.480 --> 16:40.480
是因为方形的圆形上有erplug

16:40.480 --> 16:42.480
所以说如果说将来我们要做这么一件事

16:42.480 --> 16:44.480
我希望影响

16:44.480 --> 16:46.480
让所有的函数

16:46.480 --> 16:48.480
其他对象我不影响

16:48.480 --> 16:50.480
我们知道我要影响所有的对象的话

16:50.480 --> 16:52.480
就在这上面加对吧

16:52.480 --> 16:54.480
在这上面加东西

16:54.480 --> 16:56.480
我如果说只想影响函数

16:56.480 --> 16:58.480
我不想影响对

16:58.480 --> 17:00.480
其他对象我就在哪里加

17:00.480 --> 17:02.480
是不是在这里加东西

17:02.480 --> 17:04.480
所有的函数比方说我加一个东西

17:04.480 --> 17:06.480
我要让所有的函数都有一个属性

17:06.480 --> 17:08.480
比方说这样写

17:08.480 --> 17:10.480
方个形

17:10.480 --> 17:12.480
proto type加上一个属性

17:12.480 --> 17:14.480
意思放个

17:14.480 --> 17:16.480
表示

17:16.480 --> 17:18.480
就是让所有的函数都有这个属性

17:18.480 --> 17:20.480
意思放个表示是不是函数

17:20.480 --> 17:22.480
比方说我这里有个函数

17:22.480 --> 17:24.480
s

17:24.480 --> 17:26.480
就随便写个吧

17:26.480 --> 17:28.480
我们来输出一下

17:28.480 --> 17:30.480
上面里面是不是有这个属性

17:30.480 --> 17:31.480
对不对

17:31.480 --> 17:32.480
是不是有这个属性

17:32.480 --> 17:34.480
那么这样我们以后就可以方便

17:34.480 --> 17:36.480
我不知道的是啥

17:36.480 --> 17:37.480
这是别人给我的东西

17:37.480 --> 17:38.480
它有可能是个变量

17:38.480 --> 17:39.480
有可能是个数字

17:39.480 --> 17:40.480
有可能是个制服串

17:40.480 --> 17:41.480
有可能是个对象

17:41.480 --> 17:42.480
它也有可能是函数

17:42.480 --> 17:43.480
我要判断它是不是函数

17:43.480 --> 17:45.480
我除了可以用type

17:45.480 --> 17:46.480
除了可以用type

17:46.480 --> 17:47.480
我来判断之外

17:47.480 --> 17:48.480
是不是还可以用这个

17:48.480 --> 17:50.480
因为只有所有的函数上面

17:50.480 --> 17:52.480
只有函数上面才会有这个东西

17:52.480 --> 17:53.480
对吧

17:53.480 --> 17:55.480
普通对象上面有没有ob界

17:55.480 --> 17:57.480
我们来看一下ob界

17:57.480 --> 17:59.480
里面有没有这个

18:00.480 --> 18:01.480
它就是untypad

18:01.480 --> 18:02.480
就没有

18:02.480 --> 18:03.480
为什么呢

18:03.480 --> 18:05.480
因为普通对象的话

18:05.480 --> 18:07.480
普通对象的话在这

18:07.480 --> 18:10.480
它的圆形链上是没有这个

18:10.480 --> 18:12.480
这个东西的

18:12.480 --> 18:13.480
懂了意思吧

18:13.480 --> 18:16.480
只有函数的圆形链上有这个东西

18:16.480 --> 18:17.480
所以说函数的圆形链

18:17.480 --> 18:18.480
我们再看一下

18:18.480 --> 18:21.480
它自己指向方形的圆形

18:21.480 --> 18:22.480
方形的圆形的

18:22.480 --> 18:23.480
又指向ob界的圆形

18:23.480 --> 18:24.480
也就是说

18:24.480 --> 18:25.480
ob界的东西

18:25.480 --> 18:26.480
这里边的东西

18:26.480 --> 18:27.480
会不会影响到函数

18:27.480 --> 18:28.480
也会影响到函数

18:28.480 --> 18:30.480
ob界的影响范围是最广的

18:30.480 --> 18:32.480
这里边的所有东西

18:32.480 --> 18:34.480
影响到所有的对象

18:34.480 --> 18:37.480
包括普通对象

18:37.480 --> 18:38.480
包括圆形

18:38.480 --> 18:39.480
包括函数

18:39.480 --> 18:40.480
它都会影响到

18:40.480 --> 18:42.480
但是函数里面的东西的话

18:42.480 --> 18:44.480
它只会影响到函数

18:44.480 --> 18:46.480
这就是整个链条

18:46.480 --> 18:47.480
你把这张图

18:47.480 --> 18:48.480
翻来覆去

18:48.480 --> 18:49.480
每一根线

18:49.480 --> 18:50.480
翻来覆去看一下

18:50.480 --> 18:52.480
直到看懂为止

18:52.480 --> 18:53.480
看懂了过后就忘记它

18:53.480 --> 18:54.480
你尝试着自己

18:54.480 --> 18:56.480
看一下能不能推倒

18:56.480 --> 18:57.480
把它画出来

18:57.480 --> 18:58.480
尝试画了过后

18:58.480 --> 18:59.480
你跟我土对照一下

18:59.480 --> 19:01.480
看画得对不对

19:01.480 --> 19:03.480
下来你们去做一下这件事

19:03.480 --> 19:05.480
如果说你自己能够画出来

19:05.480 --> 19:06.480
而且跟我画得一对的

19:06.480 --> 19:08.480
或者说自己画的有点不对

19:08.480 --> 19:09.480
然后改了之后

19:09.480 --> 19:10.480
你重新画一下

19:10.480 --> 19:11.480
你画得对了

19:11.480 --> 19:12.480
你只要自己能画得出来

19:12.480 --> 19:13.480
那么这一块

19:13.480 --> 19:15.480
你就理解得非常非常清楚了

19:15.480 --> 19:16.480
那画的时候

19:16.480 --> 19:17.480
你不要去背

19:17.480 --> 19:19.480
你要通过推倒

19:19.480 --> 19:20.480
怎么推倒呢

19:20.480 --> 19:23.480
通过最简单的三角关系来推倒

19:23.480 --> 19:24.480
例如一个

19:24.480 --> 19:25.480
勾到函数

19:25.480 --> 19:26.480
那就会形成一个三角关系

19:26.480 --> 19:28.480
那每一个东西都是溜出来的

19:28.480 --> 19:29.480
对不对

19:29.480 --> 19:30.480
那就看它溜的是啥

19:30.480 --> 19:32.480
是不是它的三角关系就画出来了

19:32.480 --> 19:34.480
它溜的是啥

19:34.480 --> 19:35.480
三角关系是不是画出来了

19:35.480 --> 19:37.480
然后看到两个特殊点

19:37.480 --> 19:39.480
一个是这个地方

19:39.480 --> 19:40.480
一个是这个地方

19:40.480 --> 19:41.480
就可以了

19:41.480 --> 19:44.480
你就可以把整个链条画出来

19:44.480 --> 19:45.480
好

19:45.480 --> 19:46.480
我们来看一下

19:46.480 --> 19:47.480
圆形链这一块

19:47.480 --> 19:48.480
等一下

19:48.480 --> 19:49.480
等一会再看面试题吧

19:49.480 --> 19:50.480
我们来看一下

19:50.480 --> 19:52.480
首先都开发的影响

19:52.480 --> 19:53.480
好

19:53.480 --> 19:54.480
第一个影响的就是

19:54.480 --> 19:56.480
我们学了这块知识

19:56.480 --> 19:57.480
对开发有什么影响的

19:57.480 --> 19:58.480
第一个影响

19:58.480 --> 19:59.480
在圆形上

19:59.480 --> 20:00.480
我们要知道

20:00.480 --> 20:02.480
在圆形上更改

20:02.480 --> 20:05.480
会产生多大的影响

20:05.480 --> 20:07.480
比方说我们刚才已经说了

20:07.480 --> 20:08.480
这个点对吧

20:08.480 --> 20:09.480
你在这上面更改

20:09.480 --> 20:11.480
你在这上面加东西

20:11.480 --> 20:13.480
影响的是所有的对象

20:13.480 --> 20:15.480
你在这上面加东西

20:15.480 --> 20:19.480
影响的是所有的函数

20:19.480 --> 20:21.480
你在这上面加东西

20:21.480 --> 20:22.480
影响的是谁

20:22.480 --> 20:24.480
影响的是你自定义的

20:24.480 --> 20:25.480
函数实力

20:25.480 --> 20:27.480
就是通过6它来产生的

20:27.480 --> 20:31.480
你要知道它的影响范围

20:31.480 --> 20:32.480
下面这句话

20:32.480 --> 20:35.480
更改构造函数的圆形

20:35.480 --> 20:37.480
会对哪里谁产生影响的

20:37.480 --> 20:40.480
会对所有圆形链上

20:40.480 --> 20:43.480
有这个圆形的对象产生影响

20:43.480 --> 20:44.480
你更改了它

20:44.480 --> 20:46.480
只要圆形链上

20:46.480 --> 20:47.480
有这个东西

20:47.480 --> 20:48.480
它就会产生影响

20:48.480 --> 20:50.480
这是第一点大家要知道的

20:50.480 --> 20:52.480
这就以后能比方说

20:52.480 --> 20:53.480
我要去做一些事

20:53.480 --> 20:55.480
比方说像咱们的第一题

20:55.480 --> 20:57.480
你也去提答说

20:57.480 --> 20:58.480
边说边做

20:58.480 --> 21:03.900
看一下第一题咋说的

21:03.900 --> 21:06.900
它说突视距是一个方法

21:06.900 --> 21:09.900
它属于Object Prototype

21:09.900 --> 21:11.900
说啥意思

21:11.900 --> 21:15.900
说明Object突视距在这

21:15.900 --> 21:18.900
在这是不是会影响到所有对象

21:18.900 --> 21:20.900
因此我们会发现

21:20.900 --> 21:22.900
只要是对象

21:22.900 --> 21:24.900
它都会有突视距方法

21:24.900 --> 21:25.900
那么这个方法有什么用的

21:25.900 --> 21:27.900
它就是返回一个制服串

21:27.900 --> 21:29.900
返回这么一种格式的制服串

21:29.900 --> 21:30.900
然后我们来看一下

21:30.900 --> 21:31.900
把这个格式制服串

21:31.900 --> 21:33.900
我们不需要去管它

21:33.900 --> 21:38.210
比方说我们这里有一个对象

21:38.210 --> 21:40.210
一变成二

21:40.210 --> 21:42.210
然后对象里边

21:42.210 --> 21:43.210
是不是有突视距

21:43.210 --> 21:44.210
对吧

21:44.210 --> 21:45.210
为什么呢

21:45.210 --> 21:46.210
因为它的影视员

21:46.210 --> 21:47.210
就指向这个东西

21:47.210 --> 21:50.210
链上肯定有这个东西

21:50.210 --> 21:52.210
你看是不是这个东西

21:52.210 --> 21:54.210
但是这种格式

21:54.210 --> 21:58.210
并不是每一个对象想要的

21:58.210 --> 21:59.210
是一个问题来了

21:59.210 --> 22:00.210
解释一下

22:00.210 --> 22:02.210
数组的突视距

22:02.210 --> 22:05.210
为什么能得到不同的格式

22:05.210 --> 22:08.210
比方说这是一个数组

22:08.210 --> 22:09.210
你看一下数组的突视距

22:09.210 --> 22:11.210
它变成这样子了

22:11.210 --> 22:12.210
我们的突视距

22:12.210 --> 22:13.210
本来是这样子的

22:13.210 --> 22:14.210
对吧

22:14.210 --> 22:15.210
为什么数组的突视距

22:15.210 --> 22:17.210
它要特别一些呢

22:17.210 --> 22:19.210
它为什么会变成这样子呢

22:19.210 --> 22:20.210
解释一下

22:20.210 --> 22:23.650
怎么解释

22:23.650 --> 22:25.650
那只能是数组的突视距

22:25.650 --> 22:27.650
把它改了对吧

22:27.650 --> 22:29.650
比方说这是一个数组

22:29.650 --> 22:30.650
而Rey

22:30.650 --> 22:32.650
它产生了一个数组的对象对吧

22:32.650 --> 22:34.650
那说明它对象里边

22:34.650 --> 22:35.650
有没有突视距没有

22:35.650 --> 22:36.650
那就肯定在这里边

22:36.650 --> 22:38.650
是给它加了一个突视距

22:38.650 --> 22:40.650
数组的元性上

22:40.650 --> 22:41.650
给它加了一个突视距

22:41.650 --> 22:43.650
由于我们在查照成员的时候

22:43.650 --> 22:44.650
先找自己

22:44.650 --> 22:46.650
然后再一次寻找元性链

22:46.650 --> 22:47.650
由于它在这里

22:47.650 --> 22:48.650
已经找到了突视距

22:48.650 --> 22:51.650
你是不是不再往上面寻找了

22:51.650 --> 22:53.650
所以我们来验证一下吧

22:53.650 --> 22:54.650
看是不是

22:54.650 --> 22:57.650
Rey的Prototype

22:57.650 --> 22:58.650
突视距

22:58.650 --> 22:59.650
就是我们有了元性链过后

22:59.650 --> 23:01.650
可以解释很多事情了

23:01.650 --> 23:02.650
是不是等于

23:02.650 --> 23:05.650
Rey的Prototype的突视距呢

23:05.650 --> 23:07.650
Force

23:07.650 --> 23:08.650
是不是

23:08.650 --> 23:09.650
对吧

23:09.650 --> 23:10.650
就不是了

23:10.650 --> 23:12.650
因此我们数组的时候

23:12.650 --> 23:13.650
用的突视距是用的是谁

23:13.650 --> 23:15.650
用的是这个突视距

23:15.650 --> 23:16.650
那这个突视距是不是

23:16.650 --> 23:17.650
把一个重写过后了

23:17.650 --> 23:19.650
把它重写了一遍

23:19.650 --> 23:20.650
对吧

23:20.650 --> 23:21.650
那这就是

23:21.650 --> 23:22.650
其实这也是一个

23:22.650 --> 23:23.650
常见的开发技巧

23:23.650 --> 23:24.650
如果说元性链上

23:24.650 --> 23:26.650
我希望对一些

23:26.650 --> 23:28.650
它不是去更改

23:28.650 --> 23:29.650
因为它一更改的话

23:29.650 --> 23:30.650
不得了

23:30.650 --> 23:31.650
它更改了这一块的话

23:31.650 --> 23:33.650
对所有对象全部产生影响

23:33.650 --> 23:34.650
影响范围太大了

23:34.650 --> 23:35.650
它只想影响数组

23:35.650 --> 23:36.650
所以它改的是这

23:36.650 --> 23:38.650
这叫方法的覆盖

23:38.650 --> 23:39.650
它其实不是覆盖

23:39.650 --> 23:41.650
就是在元性链

23:41.650 --> 23:42.650
以它的实力更近的地方

23:42.650 --> 23:44.650
给它加了一个

23:44.650 --> 23:46.650
就这么个意思

23:46.650 --> 23:48.650
那如果说现在有个问题

23:48.650 --> 23:50.650
这个问题是到面试题

23:50.650 --> 23:51.650
它说

23:51.650 --> 23:54.650
如果说我有一个数组

23:54.650 --> 23:56.650
我希望这个数组

23:56.650 --> 23:57.650
调用不解个冊的

23:57.650 --> 23:59.650
这上面的突视距

23:59.650 --> 24:01.650
该怎么去调用

24:01.650 --> 24:04.650
该怎么去调用

24:04.650 --> 24:07.650
该怎么调用呢

24:07.650 --> 24:08.650
你肯定不能用

24:08.650 --> 24:09.650
这种方式调用

24:09.650 --> 24:10.650
因为这种方式调用

24:10.650 --> 24:11.650
它跑到数组的

24:11.650 --> 24:12.650
突视距上面去了

24:12.650 --> 24:13.650
对吧

24:13.650 --> 24:14.650
那怎么调用

24:14.650 --> 24:15.650
要用这种方式

24:16.650 --> 24:18.650
不解个冊

24:18.650 --> 24:19.650
Prototype

24:19.650 --> 24:21.650
直接找到突视距的方法

24:21.650 --> 24:22.650
这样是不是

24:22.650 --> 24:25.960
直接找到突视距的方法

24:25.960 --> 24:27.960
但是突视距是没有参数的

24:27.960 --> 24:28.960
那我这里用

24:30.960 --> 24:31.960
把这个数组

24:31.960 --> 24:33.960
给它绑定进来

24:33.960 --> 24:34.960
绑定到这一式

24:34.960 --> 24:35.960
因为这个突视距里面

24:35.960 --> 24:36.960
是用到了这一式

24:36.960 --> 24:38.960
这里面是用到了这一式的

24:38.960 --> 24:39.960
把这个数组

24:39.960 --> 24:40.960
给它绑定进来

24:40.960 --> 24:42.960
用这种方式来调用

24:42.960 --> 24:43.960
什么意思

24:43.960 --> 24:44.960
直接找到

24:44.960 --> 24:45.960
这上面的方法

24:46.960 --> 24:47.960
然后来调用它

24:47.960 --> 24:48.960
调用的时候

24:48.960 --> 24:49.960
绑定一下这一式

24:49.960 --> 24:50.960
因为它里面

24:50.960 --> 24:51.960
用到了这一式

24:51.960 --> 24:52.960
我怎么知道

24:52.960 --> 24:53.960
它用到了这一式

24:53.960 --> 24:55.960
这个东西也确实不知道

24:55.960 --> 24:56.960
但是现在就告诉你

24:56.960 --> 24:57.960
它里面用到了这一式

24:59.960 --> 25:00.960
就这里就调用

25:01.960 --> 25:02.960
好 调用过来

25:02.960 --> 25:03.960
我们来看一下

25:03.960 --> 25:07.750
这个数数什么结果

25:07.750 --> 25:08.750
因为发现

25:08.750 --> 25:09.750
它就是这种格式

25:10.750 --> 25:12.750
这也是过去

25:12.750 --> 25:13.750
过去常用于判断

25:13.750 --> 25:14.750
一个东西

25:14.750 --> 25:15.750
到底是不是

25:15.750 --> 25:16.750
数组的一种方式

25:16.750 --> 25:17.750
它就是用这种格式

25:17.750 --> 25:18.750
得到过后

25:18.750 --> 25:19.750
看一下这个字不出来

25:19.750 --> 25:20.750
是不是耳朵

25:21.750 --> 25:22.750
它对耳朵这一块

25:22.750 --> 25:23.750
有特殊处理

25:23.750 --> 25:24.750
这个特殊处理方法

25:24.750 --> 25:26.750
好 那么这就是

25:26.750 --> 25:27.750
这个解释了解一下

25:27.750 --> 25:29.750
现在我们不太会用

25:29.750 --> 25:30.750
这种方式

25:30.750 --> 25:31.750
这种方式也可以

25:33.750 --> 25:34.750
好 这是第一点

25:34.750 --> 25:35.750
解释清楚了

25:35.750 --> 25:36.750
第二点

25:36.750 --> 25:37.750
如果说

25:37.750 --> 25:38.750
自己的构造函数

25:38.750 --> 25:39.750
希望改变图示

25:39.750 --> 25:40.750
如何改变

25:40.750 --> 25:41.750
比方说这里的

25:41.750 --> 25:42.750
有个构造函数

25:42.750 --> 25:43.750
我们自己的

25:43.750 --> 25:44.750
由这吧

25:44.750 --> 25:45.750
随便 啥都无所谓

25:45.750 --> 25:46.750
构造函数里面

25:46.750 --> 25:47.750
内容无所谓的

25:47.750 --> 25:48.750
有一个U字

25:48.750 --> 25:49.750
那么这个时候

25:49.750 --> 25:50.750
就形成一个非常

25:50.750 --> 25:51.750
跟数组一样

25:51.750 --> 25:52.750
形成了一个圆形链

25:52.750 --> 25:53.750
对吧

25:53.750 --> 25:54.750
那个U字RB界

25:54.750 --> 25:55.750
U字RB界的圆形

25:55.750 --> 25:56.750
RB界的圆形

25:56.750 --> 25:58.750
所以形成这个链条了

25:58.750 --> 25:59.750
那现在

25:59.750 --> 26:00.750
我们U字RB界

26:00.750 --> 26:01.750
有没有图示军

26:01.750 --> 26:02.750
首先

26:02.750 --> 26:03.750
它肯定是有

26:05.750 --> 26:06.750
你看 是不是

26:06.750 --> 26:07.750
还是有图示军

26:07.750 --> 26:08.750
它用的是谁的图示军

26:08.750 --> 26:09.750
用的是这个的图示军

26:09.750 --> 26:10.750
但是我不希望

26:10.750 --> 26:11.750
它用它的图示军

26:11.750 --> 26:12.750
我希望用自己的

26:12.750 --> 26:14.750
能不能去改它

26:14.750 --> 26:15.750
最好不要改它

26:15.750 --> 26:16.750
愿意改它的话

26:16.750 --> 26:17.750
影响范围太广了

26:17.750 --> 26:18.750
除非你就是

26:18.750 --> 26:19.750
就是希望

26:19.750 --> 26:21.750
我所有对象都要改变

26:21.750 --> 26:22.750
除了当中

26:22.750 --> 26:23.750
太狠了

26:23.750 --> 26:24.750
就太凶狠了

26:24.750 --> 26:25.750
这样子

26:25.750 --> 26:26.750
最好不要这样做

26:26.750 --> 26:27.750
很少有这样的需求

26:27.750 --> 26:28.750
所以说

26:28.750 --> 26:29.750
我们最好了

26:29.750 --> 26:30.750
影响范围不要那么大

26:30.750 --> 26:31.750
我们只影响U字RB

26:31.750 --> 26:32.750
因此

26:32.750 --> 26:33.750
我们是不是可以

26:33.750 --> 26:34.750
在这样做

26:34.750 --> 26:36.750
在U字RB的圆形上

26:36.750 --> 26:37.750
去加一个图示军

26:39.750 --> 26:40.750
一个函数

26:40.750 --> 26:45.210
我们输出一下

26:45.210 --> 26:47.210
这是一个用户

26:48.210 --> 26:49.210
那你看现在

26:52.970 --> 26:53.970
这里应该返回

26:53.970 --> 26:54.970
返回一个字无措

26:58.440 --> 26:59.440
这里把它打印出来

26:59.440 --> 27:00.440
你看是不是完事了

27:01.440 --> 27:02.440
这里边可以写任何东西

27:02.440 --> 27:03.440
你想写啥写啥

27:04.440 --> 27:05.440
这是我们对开发的

27:05.440 --> 27:06.440
第一个影响

27:06.440 --> 27:07.440
你要知道

27:07.440 --> 27:08.440
我们去更改

27:08.440 --> 27:09.440
圆形上的东西的时候

27:09.440 --> 27:10.440
影响的范围

27:10.440 --> 27:11.440
到底有多广

27:12.440 --> 27:13.440
第一点

27:13.440 --> 27:14.440
第二点

27:14.440 --> 27:16.440
要学会利用圆形链

27:16.440 --> 27:17.440
来判断内形

27:17.440 --> 27:19.440
这里有两种

27:19.440 --> 27:20.440
判断方式

27:20.440 --> 27:21.440
第一种常用

27:21.440 --> 27:22.440
第二种就不常用

27:22.440 --> 27:24.440
第二种了解一下就行了

27:24.440 --> 27:25.440
想想第一种

27:25.440 --> 27:26.440
第一种叫Instance

27:26.440 --> 27:27.440
这是一个新语法

27:27.440 --> 27:28.440
叫关键字

27:29.440 --> 27:30.440
它的语法是这样子

27:30.440 --> 27:31.440
前面是一个对象

27:31.440 --> 27:33.440
后面是一个构造函数

27:33.440 --> 27:34.440
它判断了什么呢

27:34.440 --> 27:36.440
判断了对象的圆形链中

27:36.440 --> 27:37.440
是否存在

27:37.440 --> 27:39.440
构造函数的圆形

27:40.440 --> 27:41.440
说的好像很糟的样子

27:41.440 --> 27:42.440
其实它非常简单

27:43.440 --> 27:44.440
比方说我们这里

27:44.440 --> 27:45.440
写一个二点解释

27:46.440 --> 27:47.440
写一个

27:49.440 --> 27:52.710
我们就看数组

27:53.710 --> 27:54.710
123

27:55.710 --> 27:56.710
我们来输出一下

27:56.710 --> 27:58.710
ARR是不是对象

27:58.710 --> 28:00.710
Instance

28:06.660 --> 28:07.660
看一下输出什么

28:07.660 --> 28:08.660
它返回了一个处合force

28:08.660 --> 28:09.660
输出处

28:09.660 --> 28:10.660
什么意思

28:10.660 --> 28:11.660
它就表示了说

28:11.660 --> 28:13.660
ARR是一个实例

28:13.660 --> 28:15.660
它不是一个圆形链吗

28:16.660 --> 28:18.660
这个圆形链上

28:18.660 --> 28:20.660
它有没有数组的圆形

28:20.660 --> 28:21.660
比方说这里是一个ARR

28:22.660 --> 28:23.660
ARR

28:23.660 --> 28:24.660
这是一个AR的构造函数

28:24.660 --> 28:27.660
有没有这个ARR的构造函数的圆形

28:27.660 --> 28:28.660
我把它贴过来

28:28.660 --> 28:39.160
你看

28:39.160 --> 28:41.160
这个ARR是实例

28:41.160 --> 28:43.160
它的圆形链上

28:43.160 --> 28:45.160
有没有ARR的圆形标

28:45.160 --> 28:46.160
这里

28:46.160 --> 28:47.160
因为它是6.ARR创建的

28:47.160 --> 28:48.160
对吧

28:48.160 --> 28:49.160
有没有ARR的圆形

28:51.160 --> 28:52.160
是不是有

28:52.160 --> 28:53.160
那么就返回处

28:53.160 --> 28:54.160
如果没有的话

28:54.160 --> 28:55.160
就返回force

28:56.160 --> 28:57.160
比方说

28:57.160 --> 28:58.160
那里这里

28:58.160 --> 29:00.160
应该换成方个形

29:01.160 --> 29:02.160
那就返回了force

29:02.160 --> 29:03.160
对吧

29:03.160 --> 29:05.160
因为它这个ARR的圆形链上

29:05.160 --> 29:06.160
没有方个形的圆形

29:06.160 --> 29:08.160
你看方个形的圆形在了

29:08.160 --> 29:09.160
方个形的圆形在这

29:09.160 --> 29:10.160
它就没有

29:10.160 --> 29:12.160
那么这个玩意用来判断什么呢

29:12.160 --> 29:14.160
其实我们在写代码的时候

29:14.160 --> 29:15.160
脑袋里面不会去想

29:15.160 --> 29:17.160
这个圆形链上也没有这东西

29:17.160 --> 29:18.160
其实我们不会这样想

29:18.160 --> 29:20.160
袁老师会怎么来读这个代码

29:21.160 --> 29:22.160
ARR

29:22.160 --> 29:24.160
把这个instantive读成是不是

29:25.160 --> 29:26.160
ARR

29:26.160 --> 29:27.160
是不是函数

29:28.160 --> 29:29.160
一下就读出来了

29:29.160 --> 29:30.160
它不是吧

29:30.160 --> 29:31.160
force

29:31.160 --> 29:32.160
ARR

29:32.160 --> 29:33.160
是不是数组

29:33.160 --> 29:34.160
q

29:34.160 --> 29:36.160
ARR是不是对象

29:36.160 --> 29:38.160
你说ARR是不是对象吗

29:38.160 --> 29:39.160
肯定是

29:39.160 --> 29:40.160
所有东西都是对象

29:40.160 --> 29:41.160
q

29:41.160 --> 29:43.160
它就起到这么一个作用

29:43.160 --> 29:44.160
判断是不是

29:44.160 --> 29:46.160
它是不是某一个内形

29:47.160 --> 29:49.160
instantive就起到这么一个作用

29:50.160 --> 29:51.160
这个玩意

29:51.160 --> 29:53.160
就是对应到我们第二题

29:53.160 --> 29:54.160
第二题

29:54.160 --> 29:56.160
就是我们将来在开发的时候

29:56.160 --> 29:57.160
经常会发现

29:57.160 --> 29:59.160
我们的程序里边

29:59.160 --> 30:00.160
有一些真正的数组

30:00.160 --> 30:01.160
什么叫真正的数组

30:01.160 --> 30:03.160
就通过这种方式创建的

30:03.160 --> 30:04.160
或者是六一个ARR

30:04.160 --> 30:05.160
来创建的

30:05.160 --> 30:06.160
就真正的数组

30:06.160 --> 30:07.160
还有一些

30:07.160 --> 30:08.160
它不是真正的数组

30:08.160 --> 30:09.160
是一些假的数组

30:09.160 --> 30:10.160
我们把它叫做内数组

30:10.160 --> 30:11.160
叫内四

30:12.160 --> 30:13.160
内四相一个数组

30:13.160 --> 30:14.160
或者叫尾数组

30:15.160 --> 30:16.160
你看它长的

30:16.160 --> 30:17.160
跟数组差不多

30:17.160 --> 30:18.160
属性连为1

30:18.160 --> 30:19.160
属性1为2

30:20.160 --> 30:21.160
属性2为3

30:22.160 --> 30:23.160
前面是属性敏

30:23.160 --> 30:24.160
就是下标

30:24.160 --> 30:25.160
后面都是属性直

30:25.160 --> 30:27.160
然后还有一个内四属性

30:27.160 --> 30:29.160
长得跟数组好像一模一样

30:29.160 --> 30:30.160
它是不是数组

30:30.160 --> 30:32.160
它不是六一个ARR来创建的

30:33.160 --> 30:34.160
它不是数组

30:34.160 --> 30:35.160
但是用的时候

30:35.160 --> 30:37.160
到时候好像都差不多

30:38.160 --> 30:41.160
i0i小于ARR1.lens

30:41.160 --> 30:42.160
i加加

30:42.160 --> 30:43.160
循环

30:43.160 --> 30:46.160
然后输出每一项AR1

30:46.160 --> 30:48.160
是不是可以输出1234

30:48.160 --> 30:49.160
把它换成AR2

30:49.160 --> 30:50.160
是不是也可以

30:50.160 --> 30:51.160
有什么区别呢

30:51.160 --> 30:53.160
它有这个内四属性

30:53.160 --> 30:54.160
它可以一次读出来的

30:54.160 --> 30:55.160
这些属性值

30:55.160 --> 30:56.160
是不是也可以

30:56.160 --> 30:58.160
但它不是真正的数组

30:58.160 --> 31:00.160
它不是通过六一个ARR来创建的

31:00.160 --> 31:02.160
那其实有区别的

31:02.160 --> 31:04.160
它不是六一个ARR的话

31:04.160 --> 31:05.160
它就意味着

31:05.160 --> 31:06.160
意味着啥呢

31:06.160 --> 31:07.160
意味着

31:07.160 --> 31:09.160
如果说比较这里是个ARR

31:09.160 --> 31:12.160
那么这里的ARR圆形上

31:12.160 --> 31:13.160
所有成员

31:13.160 --> 31:14.160
它是没有的

31:15.160 --> 31:17.160
数组的圆形上有很多成员

31:17.160 --> 31:18.160
我们后边会学习

31:18.160 --> 31:21.160
ARR圆形上有超级多的东西

31:22.160 --> 31:23.160
一看有超级多东西

31:23.160 --> 31:24.160
那么这些东西

31:24.160 --> 31:25.160
它都没有

31:26.160 --> 31:27.160
它有

31:27.160 --> 31:28.160
因为它是真正的数组

31:28.160 --> 31:29.160
它是六一个ARR出来的

31:29.160 --> 31:30.160
所以它有

31:30.160 --> 31:32.160
它的圆形链上有一个数组的圆形

31:32.160 --> 31:34.160
但它不是六一个ARR出来的

31:34.160 --> 31:36.160
它的圆形链上就没有数组的圆形

31:36.160 --> 31:38.160
这就是伪数组

31:38.160 --> 31:39.160
这就是真数组

31:39.160 --> 31:40.160
但有的时候

31:40.160 --> 31:42.160
这个辩量不是你自己写出来的

31:42.160 --> 31:44.160
是来自于别人给力的

31:44.160 --> 31:46.160
你都不知道它是不是真数组

31:46.160 --> 31:47.160
那么这个时候

31:47.160 --> 31:48.160
我要判断一下

31:48.160 --> 31:50.160
它们到底是不是一个真正的数组

31:50.160 --> 31:52.160
因为真正的数组

31:52.160 --> 31:55.160
就可以用ARR圆形上的东西

31:55.160 --> 31:57.160
它是伪数组就用不了

31:57.160 --> 31:58.160
所以我们有的是要判断

31:58.160 --> 31:59.160
那怎么来判断呢

31:59.160 --> 32:02.160
就可以利用这个instance

32:02.160 --> 32:03.160
怎么来

32:03.160 --> 32:05.160
比方说ARR1我要判断

32:05.160 --> 32:06.160
就判断ARR1

32:06.160 --> 32:08.160
是不是利用真正的数组

32:08.160 --> 32:10.160
是不是一个数组

32:10.160 --> 32:12.160
这判断是非常准确的

32:12.160 --> 32:15.160
ARR1是真正的数组

32:15.160 --> 32:18.160
它的圆形链上有没有这个东西的圆形

32:18.160 --> 32:19.160
其实你写在那里

32:19.160 --> 32:21.160
就读成是不是

32:21.160 --> 32:23.160
它是不是一个数组

32:23.160 --> 32:24.160
它就是

32:24.160 --> 32:27.600
你要再看ARR2

32:28.600 --> 32:29.600
ARR2

32:29.600 --> 32:34.640
就直接把它输出吧

32:34.640 --> 32:36.640
ARR2是不是真数组呢

32:36.640 --> 32:37.640
就不是

32:37.640 --> 32:39.640
你会发现ARR1就是真数组

32:39.640 --> 32:41.640
ARR2就不是真数组

32:41.640 --> 32:44.960
就通过这种方式来判断

32:44.960 --> 32:46.960
其实对我们开发写单法

32:46.960 --> 32:47.960
就这个影响

32:47.960 --> 32:48.960
另外一种呢

32:48.960 --> 32:49.960
就是不太常用的

32:49.960 --> 32:51.960
就是get a prototype

32:51.960 --> 32:53.960
这个玩意是怎么了解一下就行了

32:53.960 --> 32:55.960
它是呢

32:55.960 --> 32:57.960
它这个函数放在哪的

32:57.960 --> 32:59.960
它这个函数放在这的

32:59.960 --> 33:00.960
放在这里边的

33:00.960 --> 33:01.960
这里边一个数组

33:01.960 --> 33:02.960
它不是放在圆形上的

33:02.960 --> 33:03.960
这个函数放在这的

33:03.960 --> 33:05.960
这个函数的作用呢是

33:05.960 --> 33:06.960
你给它一个对象

33:06.960 --> 33:08.960
它得到一个对象的影视圆形

33:08.960 --> 33:10.960
啥意思啊

33:10.960 --> 33:11.960
你看一下

33:11.960 --> 33:12.960
我们这样子也行

33:12.960 --> 33:13.960
写也行

33:16.330 --> 33:17.330
就是

33:18.330 --> 33:20.330
objects

33:20.330 --> 33:21.330
get

33:22.330 --> 33:23.330
prototype

33:23.330 --> 33:25.330
ARR1

33:25.330 --> 33:26.330
它返回的是什么呢

33:26.330 --> 33:28.330
返回的就是

33:28.330 --> 33:30.330
就这个对象的影视圆形

33:32.710 --> 33:34.710
它返回的是这个对象的影视圆形

33:34.710 --> 33:36.710
那么这个对象的影视圆形

33:36.710 --> 33:37.710
你判断一下

33:37.710 --> 33:39.710
它是不是等于

33:40.710 --> 33:42.710
数组的

33:42.710 --> 33:43.710
圆形

33:43.710 --> 33:44.710
它为处

33:44.710 --> 33:46.710
那肯定是留一个数组产生的

33:46.710 --> 33:47.710
对吧

33:47.710 --> 33:49.710
它判断的不是圆形垫

33:49.710 --> 33:50.710
它判断的是某一个

33:50.710 --> 33:51.710
圆形

33:51.710 --> 33:52.710
啥意思啊

33:52.710 --> 33:53.710
就看一个图

33:53.710 --> 33:55.710
判断的get a prototype

33:55.710 --> 33:56.710
就是

33:56.710 --> 33:57.710
我们把这个

34:03.990 --> 34:07.450
贴过来

34:07.450 --> 34:09.450
把ARR1传进去

34:09.450 --> 34:10.450
这就是AR1

34:10.450 --> 34:11.450
它得到的是什么呢

34:11.450 --> 34:13.450
得到的是这个

34:13.450 --> 34:14.450
返回的是这个

34:14.450 --> 34:16.450
那我判断的是什么呢

34:16.450 --> 34:17.450
判断的是这个玩意儿

34:17.450 --> 34:19.450
等不等于数组的

34:19.450 --> 34:21.450
圆形

34:21.450 --> 34:23.450
懂了意思吧

34:23.450 --> 34:25.450
那如果说是等于数组的圆形的话

34:25.450 --> 34:26.450
就留一个数组产生的

34:26.450 --> 34:28.450
它判断的不是圆形垫

34:28.450 --> 34:29.450
它只是其中一个

34:29.450 --> 34:31.450
当前的实力的圆形

34:31.450 --> 34:32.450
这种方法不是很常用

34:32.450 --> 34:33.450
了解就行了

34:33.450 --> 34:34.450
这个我们也不多说了

34:34.450 --> 34:36.450
了解就行了

34:36.450 --> 34:37.450
好

34:37.450 --> 34:39.450
对我们开发的第三个影响

34:39.450 --> 34:42.450
要学会创建空圆形对象

34:42.450 --> 34:43.450
这啥意思啊

34:43.450 --> 34:44.450
就是说

34:44.450 --> 34:47.450
我们创建了任何一个对象

34:47.450 --> 34:49.450
它其实都是

34:49.450 --> 34:51.450
有影视圆形的

34:51.450 --> 34:52.450
我来输出一下

34:52.450 --> 34:55.450
OBG的Prot

34:55.450 --> 34:57.450
所以都是有影视圆形的

34:57.450 --> 35:01.450
也就它都会形成一个三角结构

35:01.450 --> 35:03.450
上面

35:03.450 --> 35:06.450
你任何一个对象都是溜出来的

35:06.450 --> 35:08.450
溜出来它就会形成一个三角结构

35:08.450 --> 35:11.450
那我能不能不形成三角结构呢

35:11.450 --> 35:12.450
就是我要得到一个对象

35:12.450 --> 35:14.450
这个对象它里边

35:14.450 --> 35:15.450
它没有这个东西

35:15.450 --> 35:16.450
它没有影视圆形

35:16.450 --> 35:19.450
这样子可以节约提升

35:19.450 --> 35:20.450
就是有些对象我确实

35:20.450 --> 35:22.450
没有必要用它的影视圆形

35:22.450 --> 35:26.450
那么这样子可以节约一些效率

35:26.450 --> 35:27.450
就是提升一些效率

35:27.450 --> 35:29.450
就是一个非常非常干净的对象

35:29.450 --> 35:30.450
它只是一个对象

35:30.450 --> 35:31.450
里边我给它写什么属性

35:31.450 --> 35:32.450
就有什么属性

35:32.450 --> 35:34.450
它没有影视圆形

35:34.450 --> 35:36.450
能不能这样做得到了

35:36.450 --> 35:39.450
可以有多种做法

35:39.450 --> 35:42.450
最简单最简单最容易理解的做法

35:42.450 --> 35:44.450
是这样子做

35:44.450 --> 35:47.450
但是这种做法不推荐

35:47.450 --> 35:52.920
这个玩意是可以复职的

35:52.920 --> 35:53.920
是可以复职的

35:53.920 --> 35:54.920
那这样子

35:54.920 --> 35:56.920
依然拉这个对象干净的不得了

35:56.920 --> 35:58.920
我们在浏览器里面看一下对象

35:58.920 --> 35:59.920
在浏览器里面

35:59.920 --> 36:00.920
就可以看得很清楚

36:00.920 --> 36:01.920
如果说

36:01.920 --> 36:02.920
这样子写一个对象

36:02.920 --> 36:04.920
A等于1B等于2

36:04.920 --> 36:05.920
你会看到

36:05.920 --> 36:06.920
这个对象

36:06.920 --> 36:08.920
它是有影视圆形的

36:08.920 --> 36:09.920
你看

36:09.920 --> 36:10.920
是有影视圆形

36:10.920 --> 36:11.920
影视圆形指向谁

36:11.920 --> 36:12.920
指向Objects的圆形

36:12.920 --> 36:14.920
Objects里面有这些东西

36:14.920 --> 36:15.920
已经完全完了

36:15.920 --> 36:16.920
什么突出军业

36:16.920 --> 36:17.920
这些东西都有

36:17.920 --> 36:18.920
好

36:18.920 --> 36:19.920
那我能不能创建一个

36:19.920 --> 36:20.920
非常干净的对象呢

36:20.920 --> 36:21.920
我就这样

36:21.920 --> 36:24.920
我给它的影视圆形Proton

36:24.920 --> 36:26.920
设为老

36:26.920 --> 36:27.920
一设为老之后

36:27.920 --> 36:29.920
我们再看这个O比起

36:29.920 --> 36:30.920
特别的干净

36:30.920 --> 36:32.920
你看就没有一个影视圆形了

36:32.920 --> 36:33.920
当然那你再想用

36:33.920 --> 36:34.920
它里面的什么突出军

36:34.920 --> 36:35.920
那就不好意思

36:35.920 --> 36:36.920
没有了

36:36.920 --> 36:37.920
都没有了

36:37.920 --> 36:38.920
但有的时候

36:38.920 --> 36:39.920
我不需要用这些东西

36:39.920 --> 36:40.920
我就需要一个

36:40.920 --> 36:41.920
非常干净的对象

36:41.920 --> 36:42.920
那能不能做得到呢

36:42.920 --> 36:43.920
就可以

36:43.920 --> 36:44.920
通过这种方式

36:44.920 --> 36:46.920
但这种方式不推荐

36:46.920 --> 36:47.920
官方文档里面

36:47.920 --> 36:48.920
已经明确告诉你

36:48.920 --> 36:50.920
不要去在代码里面

36:50.920 --> 36:51.920
去用这个东西

36:51.920 --> 36:52.920
不要用

36:52.920 --> 36:53.920
用都不要用

36:53.920 --> 36:54.920
你知道有这个东西存在就行了

36:54.920 --> 36:57.740
但不要用

36:57.740 --> 36:58.740
至于为什么

36:58.740 --> 37:00.740
它有可能江南的版本里面

37:00.740 --> 37:01.740
就直接给你禁用了

37:01.740 --> 37:03.740
不让你用这个东西了

37:03.740 --> 37:04.740
但它仍然存在

37:04.740 --> 37:05.740
存在是可以存在的

37:05.740 --> 37:06.740
一直存在的

37:06.740 --> 37:08.740
但它不会让你用了

37:08.740 --> 37:10.740
你只能趋现就果

37:10.740 --> 37:11.740
我们讲的时候

37:11.740 --> 37:12.740
可以用这种方式

37:12.740 --> 37:13.740
给大家打印出来

37:13.740 --> 37:14.740
可以看一看

37:14.740 --> 37:15.740
但是你不能用

37:15.740 --> 37:16.740
不能在真实的

37:16.740 --> 37:18.740
开发里面去用这个东西

37:18.740 --> 37:20.740
就能趋现就果了

37:20.740 --> 37:21.740
也就是说

37:21.740 --> 37:22.740
官方给你提供了

37:22.740 --> 37:23.740
几个函数

37:23.740 --> 37:24.740
让你用函数

37:24.740 --> 37:26.740
去操作这个东西

37:26.740 --> 37:28.740
就这么个意识

37:28.740 --> 37:30.740
用函数来操作这个东西

37:30.740 --> 37:31.740
你看吧

37:31.740 --> 37:32.740
下面有一些函数

37:32.740 --> 37:33.740
第一个函数就是

37:35.740 --> 37:37.740
它就是创建一个新对象

37:37.740 --> 37:39.740
里边传一个东西

37:39.740 --> 37:40.740
传这个东西就是

37:40.740 --> 37:42.740
新对象的影视元形

37:42.740 --> 37:44.740
比方说

37:44.740 --> 37:45.740
咱们又来个ob界

37:45.740 --> 37:46.740
等于

37:48.740 --> 37:50.740
这里面传入一个东西

37:50.740 --> 37:52.740
传入什么呢

37:52.740 --> 37:54.740
你随便传入什么都可以

37:54.740 --> 37:56.740
你传入一个now

37:56.740 --> 37:58.740
那么这个对象

37:58.740 --> 38:00.740
你干的属性负值

38:00.740 --> 38:01.740
a等于1

38:01.740 --> 38:02.740
ob界b等于2

38:02.740 --> 38:04.740
然后看一下这个对象

38:04.740 --> 38:06.740
这个对象的影视元形是now

38:06.740 --> 38:07.740
为什么

38:07.740 --> 38:08.740
因为这里传的是now

38:08.740 --> 38:09.740
再看一下这个函数

38:09.740 --> 38:11.740
这个函数反回一个空对象

38:11.740 --> 38:13.740
这个对象的影视元形

38:13.740 --> 38:14.740
指向它

38:14.740 --> 38:15.740
就这个意识

38:15.740 --> 38:16.740
你传的是什么

38:16.740 --> 38:17.740
它就指向什么

38:18.740 --> 38:19.740
懂的意思吧

38:19.740 --> 38:20.740
那比方说

38:20.740 --> 38:21.740
我沾了一个好玩的

38:21.740 --> 38:22.740
ob界

38:22.740 --> 38:23.740
ob界个次

38:23.740 --> 38:24.740
create

38:24.740 --> 38:25.740
我传一个什么呢

38:25.740 --> 38:27.740
传一个arid prototype

38:28.740 --> 38:30.740
它就得是一个数组

38:31.740 --> 38:32.740
为什么

38:32.740 --> 38:34.740
因为它的影视元形指向数组

38:34.740 --> 38:36.740
数组的元形

38:36.740 --> 38:37.740
你看

38:37.740 --> 38:38.740
它就得是一个数组

38:38.740 --> 38:40.740
你看有数组里面各种各样的函数

38:40.740 --> 38:42.740
还可以往里面加东西

38:42.740 --> 38:43.740
加一个e

38:44.740 --> 38:47.740
ob界里面就变个数组了

38:47.740 --> 38:49.740
数组也可以通过这种方式来创建

38:50.740 --> 38:52.740
就很好玩的方法

38:52.740 --> 38:53.740
但是我们平时用这个方法的话

38:53.740 --> 38:55.740
就是来创建一个真正的空对象

38:55.740 --> 38:56.740
一个非常干净

38:56.740 --> 38:58.740
没有任何影视元形的对象

38:58.740 --> 38:59.740
create

38:59.740 --> 39:00.740
传一个arid

39:00.740 --> 39:04.440
就是个空对象

39:04.440 --> 39:06.440
里面是没有任何的影视元形的

39:06.440 --> 39:08.440
如果说你不用这种方式来创建对象

39:08.440 --> 39:10.440
你用这种方式来创建对象的话

39:10.440 --> 39:11.440
那么对象里面

39:11.440 --> 39:13.440
它是有影视元形的

39:13.440 --> 39:14.440
当然看你的需求

39:14.440 --> 39:15.440
绝大部分时候

39:15.440 --> 39:17.440
我们就希望它有影视元形

39:17.440 --> 39:18.440
有的时候

39:18.440 --> 39:20.440
我需要它非常干净

39:20.440 --> 39:22.440
那我就用这种方式了

39:22.440 --> 39:23.440
这第一种方式

39:23.440 --> 39:24.440
第二种方式

39:24.440 --> 39:26.440
就是不能直接使用Prot

39:26.440 --> 39:29.440
第二种方式是set

39:29.440 --> 39:31.440
其实我们刚才说这个

39:31.440 --> 39:33.440
说这个啥意思

39:33.440 --> 39:36.440
这个玩意其实就是

39:36.440 --> 39:39.440
objProt

39:39.440 --> 39:44.440
等同于objget

39:44.440 --> 39:48.440
Prototipleobj

39:48.440 --> 39:50.440
因为它不让你直接用这个

39:50.440 --> 39:52.440
所以说给你做了一个方法出来

39:52.440 --> 39:55.440
让你用这个方法来得到它的影视元形

39:55.440 --> 39:59.900
其实就是这个

39:59.900 --> 40:01.900
好 下面这个

40:01.900 --> 40:02.900
这个玩意是什么呢

40:02.900 --> 40:08.900
这个玩意要等同于给它复制

40:08.900 --> 40:10.900
复制为123都可以

40:10.900 --> 40:12.900
然后上面这句话

40:12.900 --> 40:14.900
就等同于objget

40:14.900 --> 40:17.900
setPrototipleobj

40:17.900 --> 40:18.900
传进去

40:18.900 --> 40:21.900
然后123传进去

40:21.900 --> 40:23.900
但是它告诉你

40:23.900 --> 40:24.900
影象一个方法过后

40:24.900 --> 40:26.900
它就会有一些约束

40:26.900 --> 40:28.900
你这个影视元形

40:28.900 --> 40:29.900
你不要弄个数字

40:29.900 --> 40:30.900
你给我一个对象

40:30.900 --> 40:31.900
或者是NOW都可以

40:31.900 --> 40:33.900
你不要给我来一个数字

40:33.900 --> 40:36.900
但是到底就等同于上面个代吗

40:36.900 --> 40:37.900
知道这个意思吗

40:37.900 --> 40:39.900
所以说有了第二种方式之后

40:39.900 --> 40:40.900
我们也可以这样做

40:40.900 --> 40:42.900
来创建一个干净的对象

40:42.900 --> 40:45.900
A等于1 B等于2

40:45.900 --> 40:47.900
现在我们这样来做

40:47.900 --> 40:49.900
objsetPrototipleobj

40:49.900 --> 40:52.900
影视元形设为NOW

40:52.900 --> 40:54.900
这样子我们来看一下obj

40:55.900 --> 40:56.900
它又干净了

40:56.900 --> 40:57.900
因为它的影视元形

40:57.900 --> 40:58.900
被设为NOW

40:58.900 --> 40:59.900
其实这个玩意相当于

40:59.900 --> 41:00.900
是给它影视元形复制

41:00.900 --> 41:01.900
只不过它里边

41:01.900 --> 41:02.900
就做了一些判断

41:02.900 --> 41:05.900
不能复一些奇怪的值

41:05.900 --> 41:07.900
好 那么我们看一下

41:07.900 --> 41:08.900
第三道题

41:08.900 --> 41:10.900
创建一个没有影视元形的

41:10.900 --> 41:11.900
用户对象

41:11.900 --> 41:12.900
随意添加一些属性

41:12.900 --> 41:14.900
那么是不是有两种写法

41:14.900 --> 41:15.900
简单说一下

41:15.900 --> 41:17.900
你们自己去写

41:17.900 --> 41:19.900
先来一个createNOW

41:19.900 --> 41:20.900
一个用户对象

41:20.900 --> 41:21.900
往用户对象里边

41:21.900 --> 41:22.900
加一些属性

41:22.900 --> 41:23.900
加什么你自己随便加

41:23.900 --> 41:24.900
然后打印一下

41:24.900 --> 41:26.900
最好在浏览器边打印

41:26.900 --> 41:27.900
看一下有没有影视元形

41:27.900 --> 41:29.900
是不是给它提出干净了

41:29.900 --> 41:31.900
然后也可以

41:31.900 --> 41:33.900
创建一个对象

41:33.900 --> 41:35.900
先给它创建各种属性

41:35.900 --> 41:36.900
UserName

41:36.900 --> 41:37.900
用户名

41:37.900 --> 41:40.900
然后连零随便写

41:40.900 --> 41:43.900
通过Object是set

41:43.900 --> 41:45.900
set是设置

41:45.900 --> 41:46.900
原型

41:46.900 --> 41:47.900
甚至哪个原型

41:47.900 --> 41:50.900
就是User的影视元形为达

41:50.900 --> 41:54.340
这样子也可以

41:55.340 --> 41:56.340
这是这道题

41:56.340 --> 41:57.340
第三题

41:59.340 --> 42:00.340
练习题就这么一些了

42:00.340 --> 42:02.340
就这么一些练习题

42:02.340 --> 42:04.340
目标就是完成练习题

42:04.340 --> 42:06.340
最后我们来看一下

42:06.340 --> 42:07.340
面试题

42:07.340 --> 42:09.340
这个面试题

42:10.340 --> 42:11.340
尽量做吧

42:11.340 --> 42:13.340
其实我觉得应该没啥问题

42:13.340 --> 42:15.340
而且是大厂的面试题

42:15.340 --> 42:16.340
我们看大厂面试题

42:16.340 --> 42:17.340
到什么程度

42:17.340 --> 42:20.720
第一道题存有恶心理的

42:20.720 --> 42:24.410
第一道题不是

42:24.410 --> 42:25.410
大厂的面试题

42:25.410 --> 42:27.410
是元老师储的面试题

42:27.410 --> 42:28.410
存有恶心理的

42:28.410 --> 42:29.410
你把地道题做出来了

42:29.410 --> 42:31.410
我就不信你做不出其他的题

42:33.410 --> 42:34.410
这张图

42:34.410 --> 42:37.790
做的那题是无敌的

42:37.790 --> 42:38.790
User是啥

42:38.790 --> 42:39.790
User就这个

42:40.790 --> 42:42.790
User的Prototab是啥

42:42.790 --> 42:43.790
就这个

42:43.790 --> 42:44.790
U1是啥

42:44.790 --> 42:45.790
U2是啥

42:45.790 --> 42:46.790
U1就是一个实力

42:46.790 --> 42:48.790
U2也是一个实力

42:48.790 --> 42:50.790
都是通过6它来创建的

42:50.790 --> 42:52.790
6这个函数来创建的

42:53.790 --> 42:54.790
好来吧

42:54.790 --> 42:56.790
接下来我们来做这个题

42:56.790 --> 43:02.120
第一道题U1.say hello

43:02.120 --> 43:05.120
是不是等于U2.say hello

43:06.120 --> 43:07.120
是不是

43:07.120 --> 43:09.120
U1 U2

43:09.120 --> 43:10.120
他们的影视面型

43:10.120 --> 43:11.120
不都是指向这吗

43:11.120 --> 43:12.120
say hello在哪

43:12.120 --> 43:14.120
say hello不就在这吗

43:14.120 --> 43:16.120
说他们是不是一个say hello

43:16.120 --> 43:17.120
没问题吧

43:17.120 --> 43:18.120
第一个

43:21.120 --> 43:24.120
第二个User.prototab

43:24.120 --> 43:25.120
U2是啥

43:25.120 --> 43:26.120
Prototab是啥

43:26.120 --> 43:27.120
这个

43:27.120 --> 43:29.120
是不是等于方可形点Prototab

43:29.120 --> 43:30.120
方可形的Prototab是这个

43:30.120 --> 43:32.120
那肯定不一样

43:32.120 --> 43:34.120
第二个是Force

43:34.120 --> 43:36.120
你看到这个图

43:36.120 --> 43:37.120
就是无敌的

43:37.120 --> 43:46.160
稍微放小一点

43:46.160 --> 43:47.160
差不多

43:47.160 --> 43:51.160
第三个User的影视原型

43:51.160 --> 43:52.160
U2是这个

43:52.160 --> 43:54.160
它的影视原型是不是这个

43:56.160 --> 43:58.160
是不是等于方形点Protab

43:58.160 --> 44:00.160
方形点Protab是不是也是这个

44:01.160 --> 44:02.160
是不是一样的

44:02.160 --> 44:04.160
第三个是去

44:04.160 --> 44:07.160
第四个User.prototab

44:07.160 --> 44:08.160
影视原型是不是这个

44:08.160 --> 44:10.160
是不是等于方形的影视原型

44:10.160 --> 44:11.160
方形的影视原型比较特殊

44:11.160 --> 44:13.160
它也是像这个

44:13.160 --> 44:15.160
所以还是一样的

44:15.160 --> 44:17.160
你看那个图圈就

44:17.160 --> 44:18.160
就纯粹是看图

44:18.160 --> 44:20.160
看图写作业了

44:20.160 --> 44:21.160
然后呢

44:21.160 --> 44:22.160
现在U1.protob

44:22.160 --> 44:23.160
就剩下的事情

44:23.160 --> 44:25.160
就是你只要能够画出这张图

44:25.160 --> 44:26.160
怎么的话

44:26.160 --> 44:27.160
就是按照推导

44:27.160 --> 44:28.160
三角弯弦一个个去推

44:28.160 --> 44:30.160
都要看它是哪一个6的

44:30.160 --> 44:32.160
它的影视原型就只像哪一个

44:32.160 --> 44:33.160
U1.protobab

44:33.160 --> 44:34.160
就是影视原型

44:34.160 --> 44:36.160
U1.影视原型不是这样吗

44:36.160 --> 44:37.160
是不是等于U2的影视原型

44:37.160 --> 44:38.160
不也是这样吗

44:38.160 --> 44:40.160
都是6一个User出来的

44:40.160 --> 44:41.160
对吧

44:41.160 --> 44:43.160
那这个下面这个是去

44:43.160 --> 44:45.160
U1的影视原型

44:45.160 --> 44:46.160
U1的影视原型

44:46.160 --> 44:48.160
是不是等于User的影视原型

44:48.160 --> 44:49.160
User的影视原型在这

44:49.160 --> 44:51.160
那不相等

44:51.160 --> 44:52.160
Forced

44:53.160 --> 44:56.160
方形的影视原型在这

44:56.160 --> 44:57.160
是不是等于

44:57.160 --> 44:58.160
Ubject的影视原型

44:58.160 --> 45:00.160
Ubject的影视原型

45:00.160 --> 45:01.160
它也是这样

45:01.160 --> 45:02.160
是吧

45:02.160 --> 45:03.160
一样的

45:07.880 --> 45:08.880
好 再下一个

45:09.880 --> 45:12.880
方形的原型的影视原型

45:12.880 --> 45:14.880
它的原型的影视原型

45:14.880 --> 45:15.880
是不是这个

45:16.880 --> 45:18.880
是不是等于Ubject的

45:19.880 --> 45:23.880
原型的影视原型

45:23.880 --> 45:24.880
是不是NOW

45:25.880 --> 45:27.880
那肯定不相等

45:27.880 --> 45:28.880
Forced

45:28.880 --> 45:29.880
最后一个

45:29.880 --> 45:30.880
前面都一样

45:30.880 --> 45:31.880
前面都一样

45:31.880 --> 45:32.880
是不是找到这个

45:32.880 --> 45:34.880
然后是不等于Ubject的影视原型

45:34.880 --> 45:35.880
那也是这个

45:35.880 --> 45:36.880
所以最后一个为True

45:40.320 --> 45:42.320
我觉得这张图比较大成的

45:42.320 --> 45:43.320
练习多难

45:43.320 --> 45:46.280
你看一下

45:46.280 --> 45:47.280
自己对一下吧

45:47.280 --> 45:48.280
True or False

45:48.280 --> 45:50.280
但是你以为这张图的话

45:50.280 --> 45:51.280
就没有任何难度了

45:51.280 --> 45:52.280
所以关键这张图

45:52.280 --> 45:54.280
你要能够理解 画出来

45:54.280 --> 45:56.280
好 接下来看第二道题

45:56.280 --> 45:57.280
下边代码输出什么

45:57.280 --> 45:59.280
这是自己的面试题

46:00.280 --> 46:02.280
它考的是Instance

46:03.280 --> 46:04.280
一个普通对象

46:04.280 --> 46:06.280
那就相当于是NOW的Ubject的

46:07.280 --> 46:09.280
相当于是NOW的一个Ubject的

46:09.280 --> 46:10.280
NOW的一个Ubject的

46:10.280 --> 46:11.280
那么它的影视原型

46:11.280 --> 46:12.280
不应该指向这吗

46:13.280 --> 46:14.280
形成一个三角关系

46:14.280 --> 46:17.280
那么它的这个对象的原型链上

46:17.280 --> 46:19.280
这个对象的原型链上

46:19.280 --> 46:21.280
有没有Ubject的原型的

46:21.280 --> 46:22.280
肯定有

46:22.280 --> 46:23.280
那就这样读吧

46:24.280 --> 46:26.280
这个玩意是不是一个对象

46:26.280 --> 46:28.280
那肯定是个对象

46:28.280 --> 46:30.280
所以第一个就是Q

46:31.280 --> 46:32.280
第二个

46:33.280 --> 46:34.280
函数是不是一个对象

46:34.280 --> 46:35.280
你说函数是不是

46:36.280 --> 46:37.280
这个玩意是不是一个函数

46:37.280 --> 46:39.280
图式军是不是一个函数

46:40.280 --> 46:41.280
是不是函数吗

46:41.280 --> 46:42.280
那肯定是函数

46:42.280 --> 46:43.280
所以第二个也是Q

46:43.280 --> 46:45.280
不用去想这个问题了

46:45.280 --> 46:47.280
因为对象上面

46:47.280 --> 46:48.280
不是有个图式军吗

46:49.280 --> 46:51.280
所有对象都有个图式军

46:51.280 --> 46:52.280
那图式军是不是函数吗

46:52.280 --> 46:53.280
那肯定是函数

46:54.280 --> 46:55.280
而不接个车

46:55.280 --> 46:57.280
这个玩意是不是函数

46:58.280 --> 46:59.280
是不是讲过的

46:59.280 --> 47:00.280
这个玩意是不是函数

47:00.280 --> 47:01.280
Ubject

47:01.280 --> 47:02.280
肯定是函数

47:02.280 --> 47:03.280
Q

47:04.280 --> 47:06.280
函数是不是对象

47:06.280 --> 47:08.280
函数是不是对象

47:08.280 --> 47:09.280
所有的东西都是对象

47:09.280 --> 47:10.280
对吧

47:10.280 --> 47:11.280
所以说函数

47:12.280 --> 47:14.280
也是对象

47:15.280 --> 47:16.280
也是Q

47:16.280 --> 47:17.280
所以说四个处

47:21.280 --> 47:22.280
第三题

47:22.280 --> 47:23.280
金龙的一道面说题

47:25.280 --> 47:26.280
就是你刚才那个东西

47:26.280 --> 47:27.280
用图来看

47:27.280 --> 47:28.280
看圆形链

47:28.280 --> 47:29.280
也可以

47:31.280 --> 47:33.280
往方形上加了一个A

47:33.280 --> 47:35.280
这里有一个A

47:35.280 --> 47:37.280
然后往Object的圆形上

47:37.280 --> 47:38.280
加了一个B

47:38.280 --> 47:39.280
这里有一个B

47:39.280 --> 47:41.280
然后有一个函数A

47:42.280 --> 47:43.280
6的一个A

47:44.280 --> 47:45.280
放到变量A里面

47:45.280 --> 47:46.280
A 这就是A

47:46.280 --> 47:47.280
对吧

47:48.280 --> 47:49.280
这是变量A

47:50.280 --> 47:51.280
好

47:51.280 --> 47:53.280
变量A 点A

47:53.280 --> 47:54.280
自己没有吗

47:54.280 --> 47:55.280
自己没有从圆形链上找

47:55.280 --> 47:56.280
这上面有没有A

47:56.280 --> 47:57.280
没有

47:57.280 --> 47:58.280
这上面有没有A

47:58.280 --> 47:59.280
没有

47:59.280 --> 48:00.280
所以第一个

48:00.280 --> 48:01.280
这个玩意

48:01.280 --> 48:02.280
是没有的

48:02.280 --> 48:03.280
就是Undefined

48:04.280 --> 48:05.280
A点B是不是有

48:05.280 --> 48:06.280
B是不是有

48:06.280 --> 48:07.280
这里B等于2

48:09.280 --> 48:10.280
这里A等于1

48:11.280 --> 48:12.280
B是有的

48:12.280 --> 48:13.280
那么这B是2

48:14.280 --> 48:15.280
然后了A点A

48:15.280 --> 48:16.280
大写的A点A

48:16.280 --> 48:17.280
A点A

48:17.280 --> 48:18.280
自己有没有

48:18.280 --> 48:19.280
自己没有

48:19.280 --> 48:21.280
但它链条上是有

48:21.280 --> 48:22.280
影视远向上有

48:22.280 --> 48:23.280
这里出一个A等于1

48:23.280 --> 48:24.280
这里是1

48:25.280 --> 48:26.280
大写的A点B

48:27.280 --> 48:28.280
能不能找到B呢

48:28.280 --> 48:29.280
自己没有

48:29.280 --> 48:30.280
自己没有看这里有没有B

48:30.280 --> 48:31.280
没有B

48:31.280 --> 48:32.280
然后继续往影视远向上找

48:32.280 --> 48:34.280
就找到B等于2

48:35.280 --> 48:36.280
B这里也有

48:36.280 --> 48:38.280
说Undefined2 1 2

48:41.550 --> 48:42.550
Undefined2 1 2

48:43.550 --> 48:44.550
你就这样了

48:44.550 --> 48:45.550
这个题

48:45.550 --> 48:46.550
就圆形这方面的题

48:46.550 --> 48:47.550
就听到这些课

48:47.550 --> 48:49.550
真的如果说能够全部吸收完的话

48:49.550 --> 48:50.550
那面试题都可以搞定了

48:50.550 --> 48:51.550
不要说练习题了

48:51.550 --> 48:52.550
面试题都可以搞定了

48:54.550 --> 48:55.550
就是这些课的东西

48:56.550 --> 48:57.550
这方面需要下来

48:57.550 --> 48:59.550
同学们光是听完还不够

48:59.550 --> 49:00.550
还要好好对着这张图

49:00.550 --> 49:02.550
好好去把它梳理清楚

49:02.550 --> 49:03.550
关键的关键

49:03.550 --> 49:04.550
重心的重心就是

49:04.550 --> 49:06.550
你要自己能够推导出这张图

49:07.550 --> 49:08.550
通过这种三角关系

49:08.550 --> 49:09.550
六的是谁

49:09.550 --> 49:11.550
那你的影视远向指向谁

49:11.550 --> 49:12.550
他的远向就是谁

49:13.550 --> 49:14.550
你自己去

49:14.550 --> 49:15.550
他也是对象

49:15.550 --> 49:16.550
他六的是谁

49:16.550 --> 49:17.550
你要去想

49:17.550 --> 49:18.550
韩束

49:18.550 --> 49:19.550
韩束也是对象

49:19.550 --> 49:20.550
他六的是谁

49:20.550 --> 49:22.550
然后把三角关系去画完

49:22.550 --> 49:23.550
画完出来就是这张图

49:24.550 --> 49:25.550
原老师每一次画这张图

49:26.550 --> 49:27.550
都不是靠背下来的

49:27.550 --> 49:29.550
都是通过一点点推导

49:29.550 --> 49:30.550
出来的

49:30.550 --> 49:31.550
我首先看一个

49:31.550 --> 49:32.550
这里边有个方向形

49:32.550 --> 49:33.550
都是一开始就安进去了

49:34.550 --> 49:35.550
我们程序里边有个Object车

49:35.550 --> 49:36.550
我就开始想

49:36.550 --> 49:37.550
Object车是怎么来的

49:37.550 --> 49:38.550
是六方向形出来的

49:38.550 --> 49:40.550
那这个线就出来了

49:40.550 --> 49:41.550
那么六他出来的

49:41.550 --> 49:42.550
他肯定形成三角关系

49:42.550 --> 49:43.550
那他的影视远向

49:43.550 --> 49:45.550
肯定要指向他的远向

49:45.550 --> 49:46.550
对吧

49:46.550 --> 49:47.550
然后我们自定期的

49:47.550 --> 49:48.550
够到韩束哪来的

49:48.550 --> 49:50.550
也是六方向形出来的

49:50.550 --> 49:51.550
所有的韩束

49:51.550 --> 49:52.550
都是六一个方向形出来的

49:52.550 --> 49:53.550
那他的影视远向

49:53.550 --> 49:54.550
不也是一形成三角关系吗

49:54.550 --> 49:55.550
那我普通对象是哪来的呢

49:56.550 --> 49:57.550
要么就是六Object车

49:57.550 --> 49:59.550
要么就是六我们自定义的韩束

49:59.550 --> 50:00.550
把这张图画清楚了

50:00.550 --> 50:02.550
那原形就彻底搞清楚了

50:02.550 --> 50:03.550
就任何都不用怕了

50:03.550 --> 50:05.550
然后你可以随便忘

50:05.550 --> 50:06.550
忘了过后

50:06.550 --> 50:07.550
你可以反正可以重新画出来的

50:08.550 --> 50:09.550
好吧

50:09.550 --> 50:10.550
下去好好梳理一下

