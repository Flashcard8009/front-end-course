WEBVTT

00:00.000 --> 00:04.500
浏览器的渲染流程

00:05.000 --> 00:09.500
这一块的课程呢 我们这节课啊 先简单的给大家介绍一下

00:10.000 --> 00:15.000
不至于让同学们完全不知道 不至于影响后边写带嘛

00:15.500 --> 00:19.500
这一块东西呢 其实还有很多很多的细节

00:20.000 --> 00:24.500
那么这些细节呢 我们将来在笔面式课程里边再进行详细的介绍哈

00:25.500 --> 00:30.000
首先来 我们就一步一步看吧 它经历到什么样的流程

00:30.500 --> 00:34.000
就是我们浏览器它是怎么把页面给渲染出来的

00:34.500 --> 00:39.000
那么什么叫渲染的 你可以把浏览器呢 想象成一个画家

00:40.500 --> 00:43.000
你又想象成凳梗 凳梗就是个画家

00:43.500 --> 00:46.000
它需要把我们的页面给它画出来

00:46.500 --> 00:49.000
同学们看到我们的丰富的页面啊

00:50.000 --> 00:56.500
这个页面上的东西呢 你可以把它想象成 就是一张很大很大的图片

00:57.000 --> 01:00.500
浏览器是一个像素点 一个像素点把它画出来的

01:01.500 --> 01:05.500
真的那么夸张吗 就这么夸张 包括这些文字

01:06.000 --> 01:08.500
全都是一点一点画出来的

01:09.500 --> 01:12.500
那么这个整个画的过程就叫做宣展

01:13.500 --> 01:17.000
你们不知道有没有同学学的是那个绘画啊

01:17.500 --> 01:20.000
哪一个画本 对吧 上面全是一张白纸

01:21.000 --> 01:23.500
但是上面做画 对吧 一点点画 一点点画

01:24.000 --> 01:26.000
就把它画出来了 这个过程就是宣展

01:27.000 --> 01:29.000
那么我们讲的是浏览器的宣展流程

01:29.000 --> 01:31.500
它就是怎么样一步一步把它画出来的

01:33.000 --> 01:35.500
第一个步骤叫解析ATML

01:36.500 --> 01:38.500
也就是我们浏览器呢 要画它画啥呢

01:39.000 --> 01:41.000
它画的是一个ATML文档

01:42.000 --> 01:44.000
也就是说我们它是怎么把这个页面画出来的

01:44.000 --> 01:47.500
它首先得拿到这个东西 它得拿到这个玩意

01:48.000 --> 01:52.000
ATML元素 Beta元素 Head 标签 Body DIVP元素

01:52.500 --> 01:56.000
得拿到它的元素结构 这就叫做解析ATML

01:56.500 --> 02:00.000
拿到ATML文档 那么从哪里拿呢 有两种途径

02:00.500 --> 02:02.500
一种途径是从网络上来拿

02:03.000 --> 02:06.000
以网络平时访问网站 3WD 京东联合

02:06.500 --> 02:10.000
那么一回车 是不是从京东的那边的浮览器

02:10.500 --> 02:13.000
从拿到了我们这个网易的元代

02:14.500 --> 02:17.500
拿到这个东西 好 浏览器拿到这个东西它就开始画了

02:18.500 --> 02:19.500
就这么个意思

02:20.500 --> 02:22.500
好 那么解析它们首先要拿到元代

02:23.000 --> 02:25.500
这是第一个途径 第二个途径是从本地文件中

02:26.000 --> 02:29.000
那么这是什么途径呢 比方说我在本地文件里边

02:29.500 --> 02:33.500
举新建一个文件夹 然后在这个文件夹里边去随便写一个

02:37.000 --> 02:39.500
需要这么砍吗 吓我

02:42.000 --> 02:44.000
我的天呐

02:46.000 --> 02:49.890
我电到咋了 我的电脑

02:50.390 --> 02:52.390
那么这是不是一个ATM文章 对吧

02:52.890 --> 02:54.890
你们再写一个吧 随便写一个

02:58.890 --> 03:02.890
那么我们点击这里 点右键 Open with Dev Server

03:03.390 --> 03:04.890
那么这种是不是在本地拿的

03:05.890 --> 03:08.890
其实不是 如果说利用这种方式打开页面的话

03:09.390 --> 03:11.890
它也是从网络来上来拿的

03:12.390 --> 03:13.890
你看这是一个地址 网络地址

03:14.390 --> 03:17.390
通过网络地址 浏览器

03:17.890 --> 03:20.890
从本地的服务器 它还是经历了一个网络

03:21.390 --> 03:23.390
只不过网络掐桥了 臭桥了

03:23.890 --> 03:26.890
我的资源就在本地 就在我的计算机上面

03:27.390 --> 03:29.890
但是它还是 就绕了一圈又回来了

03:30.390 --> 03:33.390
还是在这里 从网络上拿到网页元代

03:34.390 --> 03:35.390
拿到这个东西

03:35.890 --> 03:38.390
下面这个东西是咋了 下面这个东西是插件

03:38.890 --> 03:40.390
就是个 Dev Server插件

03:41.390 --> 03:44.390
就是个 Dev Server插件给我们夹的 你不用去管它

03:45.390 --> 03:47.390
好 那么这就是从网络上来拿

03:47.890 --> 03:49.890
什么叫从本地拿呢 点击右键

03:50.390 --> 03:52.390
我们在文件夹里边打开

03:53.390 --> 03:57.890
这里双击 用这种方式 那就是从本地拿

03:58.390 --> 03:59.890
其实都差不多

04:00.390 --> 04:02.390
反正就是要拿到这个元代

04:02.890 --> 04:05.890
然后从上到下一行一行的看

04:06.390 --> 04:08.890
看我们的元代 看第一行 看第二行 看第三行

04:09.390 --> 04:13.390
依次往下看 这个看的过程就叫做解析

04:13.890 --> 04:15.390
解析我们的元代吧

04:15.890 --> 04:17.890
当然它不光是要看 它看了过后

04:18.390 --> 04:20.890
它要知道什么意思 比如说它看到了这个

04:21.390 --> 04:22.890
这是一个文档声明

04:23.390 --> 04:24.890
这个玩意是我们的根元术 对吧

04:25.390 --> 04:27.890
它要进行 因为它拿到手的其实就是一个制服串

04:28.390 --> 04:29.390
你们学过介石

04:30.390 --> 04:31.890
它就是一个普通的制服串

04:32.390 --> 04:33.390
制服是长这个样子

04:33.890 --> 04:34.890
它怎么样知道这个制服串里面

04:35.390 --> 04:36.890
每一段是什么含义呢

04:36.890 --> 04:37.890
那么这就需要解析

04:38.390 --> 04:39.890
这是需要一个非常复杂的一套流程

04:40.390 --> 04:41.390
把它解析出来

04:42.890 --> 04:45.390
如果说同学们是计算机本专业的话

04:45.890 --> 04:48.890
那么你们应该学过一个课程叫做编译原理

04:49.390 --> 04:53.390
跟那个差不多 就是解析我们的代码

04:53.890 --> 04:54.890
没学过也没关系

04:55.390 --> 04:56.390
反正就是你要把分析出来

04:56.890 --> 04:58.390
到底哪一块是标切开始

04:58.890 --> 04:59.390
哪一块是标切结束

04:59.890 --> 05:00.390
哪一块是标切的内容

05:00.890 --> 05:02.890
哪一块是标切的属性

05:03.390 --> 05:04.390
从一个制服串里面分析

05:04.890 --> 05:05.890
这个过程不用去关心

05:06.390 --> 05:07.890
但是你要知道有这么一个过程

05:08.390 --> 05:08.890
要解析编代吧

05:09.390 --> 05:10.890
如果说解析的过程中

05:11.390 --> 05:12.890
它遇到了CSS或者是介石

05:13.390 --> 05:13.890
比方说你看

05:14.390 --> 05:14.890
从它到下看

05:15.390 --> 05:16.390
看到这儿了

05:16.890 --> 05:17.890
所以遇到一个CSS

05:18.390 --> 05:19.390
又继续往下看

05:19.890 --> 05:21.390
看到这儿了 是不是看到一个介石

05:21.890 --> 05:24.890
凡是遇到了CSS 遇到了介石

05:25.390 --> 05:26.890
它立即要停止解析

05:27.390 --> 05:28.890
我们把这个过程叫主售

05:29.390 --> 05:31.390
等着 不动了

05:31.890 --> 05:32.890
比方说看到这儿

05:34.890 --> 05:35.890
有一个CSS 对吧

05:36.390 --> 05:38.390
那么它要重新的去拿这个CSS

05:38.890 --> 05:40.390
从哪里拿呢 一般就从网络上来拿

05:40.890 --> 05:41.890
拿这个CSS

05:42.390 --> 05:44.390
那如果说这个网络比较慢

05:44.890 --> 05:46.890
比方说这个CSS要拿个5秒钟

05:47.390 --> 05:48.390
它真的就在这里等5秒钟

05:48.890 --> 05:49.390
就会等

05:49.890 --> 05:51.390
它不会继续往后运行的

05:51.890 --> 05:54.890
等个 一定要等到它把它拿到之后

05:55.390 --> 05:56.890
然后把它解析完成之后

05:57.390 --> 05:58.890
再继续往下解析一下

05:59.390 --> 06:00.390
到这儿

06:00.890 --> 06:01.890
又遇到了一个介石 对吧

06:02.390 --> 06:02.890
继续等待

06:03.390 --> 06:04.390
等待把个介石拿到

06:04.890 --> 06:06.890
拿到之后还要运行这个介石代码

06:07.390 --> 06:09.890
运行了之后 然后继续往后运进行

06:10.390 --> 06:11.390
懂了意思吧

06:11.890 --> 06:13.890
所以说遇到了CSS 遇到了介石

06:14.390 --> 06:15.890
立即停止解析

06:16.390 --> 06:18.890
进而解析CSS 或者执行介石

06:20.390 --> 06:21.390
那又好像就像我问了

06:21.890 --> 06:23.890
这是拿CSS 拿介石

06:24.390 --> 06:25.890
那如果说有一张图片呢

06:26.390 --> 06:27.890
比方说这里有一张图片

06:28.890 --> 06:29.890
有个SRC地址

06:30.890 --> 06:32.890
比方说一点些PG

06:33.390 --> 06:36.390
那这里会不会去拿图片等待呢

06:37.390 --> 06:38.390
不会

06:38.890 --> 06:40.390
它这个图片也会去

06:40.890 --> 06:41.890
要不要去拿 要去拿

06:42.390 --> 06:44.390
比方说这里图片要拿5秒钟

06:44.890 --> 06:45.890
但是呢

06:46.390 --> 06:47.890
我不会在这里等5秒钟

06:48.390 --> 06:48.890
你去哪里的

06:49.390 --> 06:50.390
我接着往后进行解析了

06:50.890 --> 06:52.390
所以说图片这种资源

06:52.890 --> 06:54.390
包括你们以后学的

06:54.890 --> 06:56.390
什么视频 音频这种资源

06:56.890 --> 06:57.390
这种资源呢

06:57.390 --> 06:59.390
它不会导致解析主色

06:59.890 --> 07:01.390
它不会主色解析

07:01.890 --> 07:02.890
它不会停止解析

07:03.390 --> 07:03.890
继续往后解析

07:04.390 --> 07:04.890
只不过呢

07:05.390 --> 07:05.890
我会

07:06.890 --> 07:07.890
就同时去拿

07:08.390 --> 07:08.890
同时去拿

07:09.390 --> 07:09.890
就这么个意思

07:10.390 --> 07:11.890
图片是不会导致解析的

07:12.390 --> 07:12.890
主色的

07:13.390 --> 07:14.890
但介石和CSS它会

07:15.390 --> 07:15.890
那么这里呢

07:16.390 --> 07:17.390
我们有张图

07:17.890 --> 07:18.890
非常清晰地看出

07:19.390 --> 07:19.890
它整个过程

07:20.390 --> 07:21.890
首先是拿到AT秒

07:22.390 --> 07:23.390
然后读去它

07:23.890 --> 07:24.890
然后解析它

07:25.390 --> 07:25.890
读去到AT秒

07:26.390 --> 07:26.890
它会解析AT秒

07:27.390 --> 07:28.390
解析的过程中

07:28.890 --> 07:29.390
如果说遇到了CSS

07:29.890 --> 07:30.390
遇到了这

07:30.890 --> 07:31.890
于是它就会读去CSS

07:32.390 --> 07:33.890
读去完了过后解析CSS

07:34.890 --> 07:36.390
然后CSS也需要解析的

07:36.890 --> 07:38.390
拿到的是一个字无创

07:38.890 --> 07:40.890
那个字无创里边哪一块是选择器

07:41.390 --> 07:42.390
哪一块是样式

07:42.890 --> 07:43.390
它要解析出来

07:44.390 --> 07:45.890
然后解析完成之后

07:46.390 --> 07:47.890
继续解析剩下的AT秒

07:48.390 --> 07:48.890
继续往后

07:49.390 --> 07:50.390
然后到了介石

07:50.890 --> 07:51.390
读去介石

07:51.890 --> 07:53.890
把介石通过网络拿到

07:54.390 --> 07:55.890
然后执行介石

07:56.390 --> 07:56.890
执行完了之后

07:57.390 --> 07:58.890
再继续往后解析

07:59.390 --> 07:59.890
AT秒

08:00.390 --> 08:01.390
是这么一回事

08:01.890 --> 08:03.390
好那么这里就会涉及到

08:03.890 --> 08:04.890
一个东西可以解释了

08:05.390 --> 08:06.890
为什么我们要把CSS

08:07.390 --> 08:08.390
写到页面的开头

08:08.890 --> 08:11.390
而介石写到页面的最后

08:11.890 --> 08:12.890
为什么要这样做呢

08:13.390 --> 08:14.890
是因为CSS

08:15.390 --> 08:15.890
我们把它写到开头

08:16.390 --> 08:16.890
是为了让浏览器

08:17.390 --> 08:18.890
尽快地读取解析样式

08:19.390 --> 08:20.390
因为样式对于我们

08:20.890 --> 08:21.890
用户看到的东西

08:22.390 --> 08:23.890
是起一个关键的作用

08:24.390 --> 08:25.390
如果说没有样式的话

08:25.890 --> 08:26.390
用户看到的东西

08:26.390 --> 08:27.390
就非常丑陋

08:27.890 --> 08:28.890
所以我们要尽早的

08:29.390 --> 08:30.890
把样式给它解析出来

08:31.390 --> 08:32.390
让用户一开始

08:32.890 --> 08:34.390
就看到的是一个漂亮的页面

08:36.890 --> 08:38.390
可以避免给用户看到丑陋的页面

08:38.890 --> 08:40.390
也是为了避免页面闪烁

08:40.890 --> 08:41.890
什么叫页面闪烁呢

08:42.390 --> 08:42.890
我给大家举个例子

08:43.390 --> 08:44.890
比方说我这里有个A7元素

08:45.390 --> 08:46.890
我这里能去写一个CSS

08:47.890 --> 08:49.390
我给这个A7元素的

08:49.890 --> 08:51.390
颜色给它写成

08:51.890 --> 08:52.390
红色

08:52.890 --> 08:53.890
然后自写大小的

08:54.390 --> 08:55.390
给它改成3颜

08:56.390 --> 08:57.390
3倍的自写大小

08:57.890 --> 08:58.390
我们来打开

08:58.890 --> 09:00.890
我们再引用一个CSS看一下

09:02.390 --> 09:03.890
我们一般来说是把CSS引用到

09:04.390 --> 09:05.390
页面开头的对吧

09:06.390 --> 09:08.390
于是你一开始就会看到

09:08.890 --> 09:10.890
这是一个3倍自写大小的

09:11.390 --> 09:13.890
就是Hallower

09:14.390 --> 09:15.390
然后再写大一点

09:15.890 --> 09:16.390
5倍

09:17.390 --> 09:18.390
一开始你看我刷新

09:18.890 --> 09:20.390
一开始看到的是5倍大小的

09:21.390 --> 09:22.890
什么叫页面闪烁呢

09:23.390 --> 09:24.390
那么接下来我来试一下

09:24.890 --> 09:25.390
我把这个CSS

09:25.390 --> 09:26.890
放到这个A7后边

09:27.390 --> 09:28.890
那会导致一个什么样的结果呢

09:29.390 --> 09:30.890
它会先显示出一个

09:31.390 --> 09:32.890
因为到这的时候是不是还没有样式

09:33.390 --> 09:34.890
因此它会先显示出一个

09:35.390 --> 09:37.390
默认样式的Hallower

09:37.890 --> 09:39.390
然后再去解析CSS

09:39.890 --> 09:40.890
CSS一解析完成

09:41.390 --> 09:42.390
是不是样式又加进去了

09:42.890 --> 09:43.390
样式加进去过后

09:43.890 --> 09:44.890
它又突然变成了

09:45.390 --> 09:46.890
5倍自写大小的

09:47.390 --> 09:49.890
红色的效果

09:50.390 --> 09:51.890
那么它就会有个页面闪烁

09:52.390 --> 09:53.390
从一个默认样式

09:53.390 --> 09:55.390
变到最终样式的这么一个闪烁

09:55.890 --> 09:57.890
这里因为我的本都是在本地

09:57.890 --> 09:58.890
速度太快了

09:58.890 --> 09:59.890
所以看不到闪烁

09:59.890 --> 10:01.390
但是我可以给它模拟一下

10:01.890 --> 10:03.390
这里我找到网络

10:03.390 --> 10:04.890
网络这一块我可以控制一下

10:04.890 --> 10:05.890
我的网速

10:05.890 --> 10:08.890
把它控制成3G

10:09.890 --> 10:11.390
好 接下来我们来刷新一下

10:12.890 --> 10:13.890
这个网络明白吗

10:13.890 --> 10:15.390
你看一开始是个默认的

10:15.390 --> 10:16.890
然后再变成这个样子

10:17.390 --> 10:18.890
所以说如果说你CSS

10:18.890 --> 10:19.890
系到后边的话

10:19.890 --> 10:21.390
它会导致页面闪烁

10:21.890 --> 10:22.890
因此我们CSS

10:22.890 --> 10:23.890
一般都是写到

10:23.890 --> 10:24.890
页面的最底部

10:24.890 --> 10:26.390
不是说它不能写到后边

10:26.390 --> 10:27.390
是可以的

10:27.390 --> 10:28.890
这个给用户的体验

10:28.890 --> 10:30.390
是太过于差了

10:31.390 --> 10:32.390
那么为什么我GSS

10:32.390 --> 10:33.890
要写到最后呢

10:33.890 --> 10:35.390
是因为GSS

10:36.390 --> 10:37.390
它是做交互的

10:37.390 --> 10:39.390
一般来说是做交互的

10:39.390 --> 10:40.890
这个网络的优先级

10:40.890 --> 10:42.890
不是特别特别的高

10:42.890 --> 10:43.890
我们最重要的是什么

10:43.890 --> 10:45.390
先赶快让用户

10:45.390 --> 10:47.390
看到一个漂亮的东西

10:47.390 --> 10:48.890
然后交互

10:48.890 --> 10:49.890
因为用户的反应

10:49.890 --> 10:50.890
其实也没有那么快

10:50.890 --> 10:52.390
它可能会先扭烂一下

10:52.390 --> 10:53.390
看一下这个页面

10:53.390 --> 10:55.390
再决定我要去点哪里

10:55.390 --> 10:56.390
我要去操作啥

10:56.890 --> 10:57.390
对不对

10:57.390 --> 10:58.890
所以说我没有必要

10:58.890 --> 11:00.890
一开始就非得

11:01.890 --> 11:03.390
来给它来一个交互

11:03.390 --> 11:05.890
所以说交互可以往后靠一点

11:05.890 --> 11:07.390
如果说你交互提前

11:07.390 --> 11:08.390
可不可以呢

11:08.390 --> 11:09.890
其实也可以

11:10.390 --> 11:12.390
只不过用户的等待时间

11:12.390 --> 11:13.390
是不是要变长一点

11:13.390 --> 11:13.890
对吧

11:13.890 --> 11:15.890
比方说你把这里一个介石

11:15.890 --> 11:16.890
那你把这个介石

11:16.890 --> 11:18.390
在这里引用可不可以呢

11:18.390 --> 11:19.390
其实可以的

11:20.390 --> 11:21.390
但是这样子

11:21.390 --> 11:24.390
会不会导致多花费一点时间

11:24.390 --> 11:25.390
比方说的一个介石

11:25.390 --> 11:27.390
是不是这里会花费一点时间

11:27.390 --> 11:29.390
其实这个时间是可以省掉的

11:29.390 --> 11:31.390
可以让用户先看到东西再说

11:31.390 --> 11:33.390
然后后表我再来进行

11:33.390 --> 11:34.390
慢慢的处理交互

11:34.390 --> 11:35.390
这就是为什么介石

11:35.390 --> 11:36.390
我们往往写到最后

11:37.390 --> 11:38.390
其实除了这个原因之外

11:38.390 --> 11:39.390
我们一会还会讲到

11:39.390 --> 11:40.390
另外一个原因

11:40.390 --> 11:41.390
一会就知道了

11:42.390 --> 11:44.390
这是把这个问题给它解释了

11:44.390 --> 11:46.390
这是解析一天秒

11:46.390 --> 11:47.390
从上到下进行解析

11:47.390 --> 11:48.390
看第二步

11:48.390 --> 11:49.390
生成动物树

11:50.390 --> 11:52.390
其实这一个步骤

11:52.390 --> 11:53.390
这些步骤

11:53.390 --> 11:54.390
它其实并不是说

11:54.390 --> 11:55.390
我先把第一步

11:55.390 --> 11:56.390
全部完成之后

11:56.390 --> 11:57.390
再来做第二步

11:57.390 --> 11:58.390
其实不是的

11:58.390 --> 12:00.390
它基本上是同时进行的

12:00.390 --> 12:02.390
就浏览器一边解析一天秒

12:02.390 --> 12:04.390
它一边就会生成动物树

12:04.390 --> 12:06.390
这动物树是啥呀

12:07.390 --> 12:09.390
其实就是我们介石里面

12:09.390 --> 12:10.390
获取的动物树

12:10.390 --> 12:12.390
最顶部是一个document

12:12.390 --> 12:13.390
这里是个document

12:13.390 --> 12:14.390
然后里面是根源

12:14.390 --> 12:15.390
说一天秒一天秒

12:15.390 --> 12:16.390
里面是通过切尔军

12:16.390 --> 12:17.390
是不是可以拿到这个

12:17.390 --> 12:18.390
然后通过切尔军

12:18.390 --> 12:19.390
是不是可以拿到这个

12:19.390 --> 12:20.390
拿到这些

12:20.390 --> 12:21.390
对吧

12:21.390 --> 12:23.390
其实就是我们介石的动物树

12:23.390 --> 12:25.390
因为动物树在哪里构建的

12:25.390 --> 12:26.390
就在这里构建的

12:26.390 --> 12:28.390
它一边解析一天秒

12:28.390 --> 12:29.390
它不是同时进行的

12:29.390 --> 12:30.390
它比较好这里

12:30.390 --> 12:31.390
它看到了

12:31.390 --> 12:33.390
我是一个包废面子

12:33.390 --> 12:34.390
是一个etimate文档

12:34.390 --> 12:36.390
它就会生成这么一个对象

12:36.390 --> 12:38.390
然后它发现了一个etimate

12:38.390 --> 12:40.390
它就会生成一个etimate元素

12:40.390 --> 12:41.390
一个指

12:41.390 --> 12:42.390
动物

12:42.390 --> 12:43.390
然后看到里面有两个

12:43.390 --> 12:44.390
一个指源

12:44.390 --> 12:45.390
一个head

12:45.390 --> 12:46.390
一个body

12:46.390 --> 12:47.390
两个指源素

12:47.390 --> 12:49.390
把里面又生成了a7

12:49.390 --> 12:50.390
它是看到一个

12:50.390 --> 12:51.390
就加一个

12:51.390 --> 12:52.390
看到一个加一个

12:52.390 --> 12:54.390
它是一点点的构建出来的

12:54.390 --> 12:56.390
那么这也就解释了

12:56.390 --> 12:57.390
另外一个原因

12:57.390 --> 12:59.390
为什么把gs写到最后的

12:59.390 --> 13:00.390
另外一个原因

13:00.390 --> 13:02.390
如果说你写到这儿

13:02.390 --> 13:04.390
那么比方算你写到这儿

13:04.390 --> 13:05.390
或者是你写到这儿

13:05.390 --> 13:06.390
你这个时候

13:06.390 --> 13:08.390
你要去获取这个a7元素

13:08.390 --> 13:10.390
你能获取得到吗

13:10.390 --> 13:11.390
你是不是获取不到

13:11.390 --> 13:12.390
因为它从上到下

13:12.390 --> 13:13.390
你解析 解析到这儿

13:13.390 --> 13:14.390
比方说我这里

13:14.390 --> 13:15.390
没有用那个外部的

13:15.390 --> 13:16.390
就本

13:16.390 --> 13:17.390
就在这里直接写

13:17.390 --> 13:18.390
也没问题

13:18.390 --> 13:19.390
在这里写的时候

13:19.390 --> 13:20.390
它是不是还是要等到

13:20.390 --> 13:21.390
这个gs执行完了之后

13:21.390 --> 13:23.390
再继续往后解析

13:23.390 --> 13:24.390
因此到这儿的时候

13:24.390 --> 13:26.390
其实还没有解析到这个a7

13:26.390 --> 13:27.390
比方说你拿到

13:27.390 --> 13:28.390
拿这个a7元素

13:28.390 --> 13:29.390
document

13:29.390 --> 13:30.390
query is negative

13:30.390 --> 13:31.390
拿这个a7元素

13:31.390 --> 13:32.390
你能拿到吗

13:32.390 --> 13:34.390
你拿不到

13:34.390 --> 13:35.390
a7

13:35.390 --> 13:39.660
来看一下

13:39.660 --> 13:40.660
小心

13:40.660 --> 13:42.660
看是不是拿不到

13:42.660 --> 13:45.660
我把网络还原回来

13:45.660 --> 13:49.170
所以现在拿不到

13:49.170 --> 13:51.170
就这么个原因

13:51.170 --> 13:52.170
这是第二个原因

13:52.170 --> 13:54.170
为什么要介绍到下面

13:54.170 --> 13:55.170
那么这一点

13:55.170 --> 13:56.170
我给大家介绍另外一个东西

13:56.170 --> 13:58.170
就是一个小知识

13:58.170 --> 13:59.170
就是当document

13:59.170 --> 14:01.170
完全生成好之后

14:01.170 --> 14:03.170
它会触发这么一个世界

14:03.170 --> 14:06.170
叫dom content loaded的世界

14:06.170 --> 14:08.170
这个世界注册在document上

14:08.170 --> 14:10.170
那么这个是什么世界

14:10.170 --> 14:11.170
它表示的是

14:11.170 --> 14:12.170
我这个网页

14:12.170 --> 14:14.170
所有document都解析完成了

14:14.170 --> 14:15.170
比方说从上到下

14:15.170 --> 14:16.170
进行解析

14:16.170 --> 14:17.170
好多解析完成了

14:17.170 --> 14:18.170
它就会触发这个世界

14:18.170 --> 14:19.170
因此有的

14:19.170 --> 14:21.170
你会以后看到一些

14:21.170 --> 14:22.170
公式的代码里边

14:22.170 --> 14:24.170
有一些比较特殊的代码

14:24.170 --> 14:26.170
它希望尽快执行

14:26.170 --> 14:28.170
但是就尽快夹载

14:28.170 --> 14:30.170
它可能会把这个介绍

14:30.170 --> 14:31.170
写到上面

14:31.170 --> 14:32.170
但是写到上面的时候

14:32.170 --> 14:33.170
它不能直接这样子写

14:33.170 --> 14:34.170
这样子写

14:34.170 --> 14:35.170
拿不到元素

14:35.170 --> 14:36.170
因为到这个时候

14:36.170 --> 14:38.170
还没有这个a7元素

14:38.170 --> 14:40.170
它要等一会儿才写

14:40.170 --> 14:41.170
那么在这里

14:41.170 --> 14:42.170
它会这样子写

14:42.170 --> 14:43.170
document

14:43.170 --> 14:46.740
add event niessen

14:46.740 --> 14:48.740
这个世界

14:48.740 --> 14:49.740
同学们注意一下

14:49.740 --> 14:50.740
这个世界是不能通过

14:50.740 --> 14:55.580
这种方式来注册的

14:55.580 --> 14:56.580
on-dom

14:56.580 --> 14:57.580
dom那个

14:57.580 --> 14:59.580
康舔车

14:59.580 --> 15:00.580
楼地的

15:00.580 --> 15:01.580
是不能通过这种世界来注册的

15:01.580 --> 15:02.580
就像我之前说的

15:02.580 --> 15:03.580
这种方式是注册世界

15:03.580 --> 15:04.580
最完美的方式

15:04.580 --> 15:05.580
利用on那种方式

15:05.580 --> 15:07.580
是有些世界是不支持的

15:07.580 --> 15:08.580
这个世界就不支持

15:08.580 --> 15:09.580
那么这里

15:09.580 --> 15:10.580
我就可以拿

15:10.580 --> 15:11.580
去拿这个a7

15:11.580 --> 15:12.580
它最可以拿到

15:12.580 --> 15:13.580
因为这个既然是执行

15:13.580 --> 15:14.580
你看执行的时候

15:14.580 --> 15:16.580
它注册一个世界就完了

15:16.580 --> 15:17.580
因为这个世界

15:17.580 --> 15:18.580
目前还没有触发

15:18.580 --> 15:19.580
就结束了

15:19.580 --> 15:20.580
继续往后解析

15:20.580 --> 15:21.580
解析完了过后

15:21.580 --> 15:22.580
就会触发这个世界

15:22.580 --> 15:23.580
触发这个世界

15:23.580 --> 15:24.580
它就会运行这个函数

15:24.580 --> 15:25.580
那么这个时候

15:25.580 --> 15:27.580
再去执行a7

15:27.580 --> 15:28.580
拿a7就拿到了

15:28.580 --> 15:29.580
就可以拿到

15:29.580 --> 15:30.580
你看

15:30.580 --> 15:31.580
是可以拿到

15:31.580 --> 15:32.580
因此有的时候

15:32.580 --> 15:34.580
我们要把GS

15:34.580 --> 15:36.580
如果说要提前写的话

15:36.580 --> 15:38.580
也得把它放到这个世界里边

15:38.580 --> 15:40.580
不然你拿不到动物元素

15:40.580 --> 15:42.580
动物数都还没有完成

15:42.580 --> 15:43.580
懂得意思吗

15:43.580 --> 15:45.580
就这么个意思

15:45.580 --> 15:46.580
这是这一块

15:46.580 --> 15:48.580
说到这个世界

15:48.580 --> 15:50.580
我另外再给大家介绍一个世界

15:50.580 --> 15:51.580
叫dome的世界

15:51.580 --> 15:53.580
以后面试题经常会问

15:53.580 --> 15:54.580
dome的时间

15:54.580 --> 15:56.580
跟dome content loaded的时间

15:56.580 --> 15:58.580
有什么样的区别

15:58.580 --> 15:59.580
这个dome的时间

15:59.580 --> 16:01.580
其实它是注册在Windows上面的

16:01.580 --> 16:03.580
我们用dome的时间来写一下

16:03.580 --> 16:04.580
其实你会发现

16:04.580 --> 16:06.580
也可以拿到

16:06.580 --> 16:07.580
我们这里输出一下

16:07.580 --> 16:12.580
输出一下的是dome content loaded的时间

16:12.580 --> 16:14.580
另外一个是windows

16:14.580 --> 16:15.580
可以用on来注册

16:15.580 --> 16:16.580
onload的可以

16:16.580 --> 16:18.580
也可以用addimension loaded的

16:18.580 --> 16:19.580
也可以

16:19.580 --> 16:20.580
都行

16:20.580 --> 16:22.580
load的时间

16:22.580 --> 16:23.580
这个世界

16:23.580 --> 16:24.580
我们输出一下

16:24.580 --> 16:26.580
window

16:26.580 --> 16:28.580
load

16:28.580 --> 16:29.580
然后还是一样

16:29.580 --> 16:30.580
拿这个A7

16:30.580 --> 16:31.580
你会发现

16:31.580 --> 16:33.580
它也能拿到

16:33.580 --> 16:34.580
你看

16:34.580 --> 16:36.580
所以也能拿到这个A7

16:36.580 --> 16:37.580
那么这两个世界

16:37.580 --> 16:38.580
有什么样的区别呢

16:38.580 --> 16:39.580
load的这个世界

16:39.580 --> 16:40.580
是这样子的

16:40.580 --> 16:41.580
它指的是

16:41.580 --> 16:43.580
页面中的所有资源

16:43.580 --> 16:45.580
全部夹仔完成

16:45.580 --> 16:46.580
什么资源呢

16:46.580 --> 16:48.580
比方说这里有张图片

16:48.580 --> 16:50.580
我们来看一下

16:50.580 --> 16:53.580
来一张图片吧

16:53.580 --> 16:58.940
来一张

16:58.940 --> 17:00.940
不是广告的

17:00.940 --> 17:02.940
挺可爱的

17:02.940 --> 17:04.940
来一张图片

17:04.940 --> 17:07.380
好

17:07.380 --> 17:08.380
保存

17:08.380 --> 17:09.380
来看一下

17:10.380 --> 17:13.380
为了让你们看得更加清楚

17:13.380 --> 17:14.380
我再把这个网络

17:14.380 --> 17:16.380
速度再调慢一点

17:16.380 --> 17:17.380
调成这个

17:17.380 --> 17:18.380
好

17:18.380 --> 17:19.380
刷新

17:19.380 --> 17:20.380
看一下

17:20.380 --> 17:23.210
你看哪个先触发

17:23.210 --> 17:24.210
是不是这个先触发

17:24.210 --> 17:26.210
然后再触发图片的

17:26.210 --> 17:27.210
再触发load

17:27.210 --> 17:28.210
那这是怎么回事呢

17:28.210 --> 17:29.210
是这样子的

17:29.210 --> 17:30.210
load的世界

17:30.210 --> 17:32.210
是必须要我整个网页中

17:32.210 --> 17:33.210
所有资源

17:33.210 --> 17:35.210
全部夹仔完成

17:35.210 --> 17:38.210
它才会触发这个load的世界

17:38.210 --> 17:39.210
也就是说

17:39.210 --> 17:40.210
我们重判它要解析

17:40.210 --> 17:41.210
解析到图片这里

17:41.210 --> 17:43.210
是不是要夹仔图片资源

17:43.210 --> 17:44.210
但是我刚才说了

17:44.210 --> 17:45.210
不会等

17:45.210 --> 17:46.210
继续往后进行

17:46.210 --> 17:47.210
继续解析动

17:47.210 --> 17:48.210
动物是不是解析完了

17:48.210 --> 17:49.210
触发这个世界

17:49.210 --> 17:51.210
但图片可能还没有拿到

17:51.210 --> 17:52.210
还等一会儿

17:52.210 --> 17:54.210
最终图片也拿到了

17:54.210 --> 17:55.210
如果说页面中还有别的图片

17:55.210 --> 17:56.210
还有别的视频

17:56.210 --> 17:57.210
音频

17:57.210 --> 17:58.210
全部都必须要拿到

17:58.210 --> 17:59.210
拿到之后

17:59.210 --> 18:01.210
全部资源夹仔完成

18:01.210 --> 18:02.210
才会触发load的

18:02.210 --> 18:03.210
所以load的触发世界

18:03.210 --> 18:04.210
是比较靠后的

18:04.210 --> 18:06.210
因此如果说

18:06.210 --> 18:08.210
你在页面上

18:08.210 --> 18:12.210
我仅仅是想得到动元素

18:12.210 --> 18:14.210
是不是应该用这个世界

18:14.210 --> 18:15.210
对吧

18:15.210 --> 18:16.210
当然前的条件

18:16.210 --> 18:17.210
你介绍是要写前面

18:17.210 --> 18:18.210
如果说你介绍写到最后的话

18:18.210 --> 18:19.210
那无所谓了

18:19.210 --> 18:20.210
你不用这个世界

18:20.210 --> 18:21.210
都可以拿到

18:21.210 --> 18:22.210
全部的动物元素了

18:22.210 --> 18:24.210
如果说你写前面的话

18:24.210 --> 18:25.210
我想在动物

18:25.210 --> 18:26.210
我只是拿到动物元素

18:26.210 --> 18:28.210
是不是在这个世界就可以了

18:28.210 --> 18:30.210
它可以尽早的触发世界

18:30.210 --> 18:32.210
来去完成一些东西

18:32.210 --> 18:33.210
那如果说我想

18:33.210 --> 18:36.210
拿到每一张图片的尺寸

18:36.210 --> 18:37.210
那么这个尺寸

18:37.210 --> 18:38.210
必须要等图片

18:38.210 --> 18:39.210
全部夹仔完成

18:39.210 --> 18:40.210
你要用load的

18:40.210 --> 18:41.210
懂了意思吗

18:41.210 --> 18:43.210
另外load的时间

18:43.210 --> 18:44.210
它也可以针对

18:44.210 --> 18:46.210
单个外部资源使用

18:46.210 --> 18:47.210
也什么意思呢

18:47.210 --> 18:48.210
也就是我这里面的比方

18:48.210 --> 18:49.210
最有两张图片

18:49.210 --> 18:50.210
这两张图片

18:50.210 --> 18:52.210
哪个图片先夹仔完成

18:52.210 --> 18:53.210
哪个图片后夹仔完成

18:53.210 --> 18:55.210
其实我是不知道的

18:57.210 --> 18:58.210
你也不知道

18:58.210 --> 18:59.210
我也不知道

18:59.210 --> 19:00.210
谁也不知道

19:00.210 --> 19:01.210
刘烂琪自己都不知道

19:01.210 --> 19:02.210
哪个图片先拿到

19:02.210 --> 19:03.210
看网络了

19:03.210 --> 19:05.210
还看这个图片大小

19:05.210 --> 19:06.210
哪个图片先拿到

19:06.210 --> 19:07.210
哪个图片后拿到

19:07.210 --> 19:08.210
我并不知道

19:08.210 --> 19:09.210
但是我比方说

19:09.210 --> 19:11.210
我只关心这个图片

19:11.210 --> 19:13.210
我只关心第一张图片

19:16.210 --> 19:18.210
我第一张图片夹仔完成过后了

19:18.210 --> 19:19.210
我可能要做着

19:19.210 --> 19:20.210
做一些事

19:20.210 --> 19:21.210
第二张夹仔完成

19:21.210 --> 19:22.210
有没有夹仔完成

19:22.210 --> 19:23.210
我不care

19:23.210 --> 19:25.210
那么这种情况下

19:25.210 --> 19:26.210
我可以针对单个资源

19:26.210 --> 19:27.210
比方说

19:27.210 --> 19:28.210
我们给他写个id

19:28.210 --> 19:29.210
img1

19:29.210 --> 19:30.210
于是我这里

19:30.210 --> 19:31.210
可以使用document

19:31.210 --> 19:34.210
get element by id

19:34.210 --> 19:35.210
img1

19:35.210 --> 19:37.210
拿到图片1

19:37.210 --> 19:38.210
那么我给图片1

19:38.210 --> 19:40.210
注册unload的时间

19:40.210 --> 19:42.210
只要图片1夹仔完成

19:42.210 --> 19:43.210
它就会触发这个时间

19:43.210 --> 19:44.210
就不是整个网易的

19:44.210 --> 19:45.210
所有图片

19:45.210 --> 19:47.210
img1 loaded

19:47.210 --> 19:51.420
我们来看一下

19:51.420 --> 19:52.420
真的刷新

19:52.420 --> 19:53.420
img1 loaded

19:53.420 --> 19:54.420
img2还没完成

19:54.420 --> 19:55.420
这个第一张图片

19:55.420 --> 19:56.420
就已经夹仔出来了

19:56.420 --> 19:57.420
就这么个意思

19:57.420 --> 19:59.420
它可以针对单个图片

19:59.420 --> 20:01.420
这是生成dome数

20:01.420 --> 20:03.420
就是生成一个dome结构

20:03.420 --> 20:05.420
这一块我要补充的东西

20:05.420 --> 20:07.420
接下来生成渲染数

20:07.420 --> 20:08.420
还是一样的

20:08.420 --> 20:09.420
它一边解析

20:09.420 --> 20:11.420
一边生成dome数

20:11.420 --> 20:12.420
一边生成dome数

20:12.420 --> 20:14.420
一边生成样式数

20:14.420 --> 20:15.420
渲染数

20:15.420 --> 20:16.420
渲染数是怎么回事呢

20:16.420 --> 20:18.420
它是一边计算

20:18.420 --> 20:19.420
dome数里面

20:19.420 --> 20:21.420
每一个节点的样式规则

20:21.420 --> 20:23.420
最终形成渲染数

20:23.420 --> 20:24.420
啥意思

20:24.420 --> 20:25.420
就是它渲染到

20:25.420 --> 20:26.420
比较渲染到

20:26.420 --> 20:28.420
body的时候

20:28.420 --> 20:30.420
它要知道body的

20:30.420 --> 20:32.420
各个CSS属性是啥

20:32.420 --> 20:33.420
对吧

20:33.420 --> 20:34.420
那么这个时候

20:34.420 --> 20:35.420
它就会生成渲染数

20:35.420 --> 20:37.420
其实这个过程

20:37.420 --> 20:38.420
我们之前讲过

20:38.420 --> 20:40.420
就是CSS属性的

20:40.420 --> 20:42.420
计算过程

20:42.420 --> 20:43.420
先看升临值

20:43.420 --> 20:44.420
对吧

20:44.420 --> 20:45.420
然后再成叠

20:45.420 --> 20:46.420
冲突

20:46.420 --> 20:48.420
然后再使用继承

20:48.420 --> 20:50.420
然后再使用默认值

20:50.420 --> 20:52.420
让每一个统结点

20:52.420 --> 20:54.420
它都有一个完整的

20:54.420 --> 20:55.420
CSS属性

20:55.420 --> 20:57.420
这里我只是随便写了一些

20:57.420 --> 20:59.420
实际上它里面是一套

20:59.420 --> 21:01.420
很多很多的CSS属性

21:01.420 --> 21:03.420
都要在这里全部计算出来

21:03.420 --> 21:05.420
就在这个步骤完成

21:05.420 --> 21:06.420
根据你写的样式表

21:06.420 --> 21:07.420
里面的选择器

21:07.420 --> 21:09.420
根据你的浏览器的

21:09.420 --> 21:11.420
默认样式

21:11.420 --> 21:12.420
浏览器的默认样式

21:12.420 --> 21:13.420
根据它的规则

21:13.420 --> 21:14.420
规则

21:14.420 --> 21:15.420
根据继承规则

21:15.420 --> 21:16.420
然后一步一步

21:16.420 --> 21:17.420
全部设置好

21:17.420 --> 21:18.420
每一个结点

21:18.420 --> 21:21.420
每一个元素的CSS属性

21:21.420 --> 21:23.420
说渲染数就在这里成成

21:23.420 --> 21:24.420
其实这一步

21:24.420 --> 21:26.420
其实还会分为两步

21:26.420 --> 21:27.420
我们之后

21:27.420 --> 21:28.420
比面试的课程里面

21:28.420 --> 21:30.420
再慢慢去细说

21:30.420 --> 21:32.420
这里我就简单把它合并成一步

21:32.420 --> 21:33.420
就是生成这么一个东西

21:33.420 --> 21:34.420
那么这样一来

21:34.420 --> 21:36.420
现在整个动物书里边

21:36.420 --> 21:37.420
它不是说

21:37.420 --> 21:38.420
前一步做完了过后

21:38.420 --> 21:39.420
再做后一步

21:39.420 --> 21:41.420
还是一边做一边来的

21:41.420 --> 21:42.420
就一边生成动物

21:42.420 --> 21:43.420
再计算了

21:43.420 --> 21:46.420
所以说这是同时进行的

21:46.420 --> 21:48.420
那么这一步完成之后

21:48.420 --> 21:49.420
就到下一步了

21:49.420 --> 21:50.420
布局

21:50.420 --> 21:52.420
那就开始慢慢开始显示了

21:52.420 --> 21:53.420
这一步很重要

21:53.420 --> 21:55.420
面试题频繁出现

21:55.420 --> 21:56.420
对我们开发

21:56.420 --> 21:58.420
也多多少少有影响

21:58.420 --> 22:01.420
这个这一步叫做布局Layout

22:01.420 --> 22:03.420
或者要重排Reflow

22:03.420 --> 22:05.420
为什么要重排呢

22:05.420 --> 22:07.420
排就是排列吗

22:07.420 --> 22:08.420
为什么要重排呢

22:08.420 --> 22:10.420
不就是排列吗

22:10.420 --> 22:11.420
是因为这个步骤

22:11.420 --> 22:12.420
它会反复的进行

22:12.420 --> 22:14.420
它不会一次就完事了

22:14.420 --> 22:15.420
以后就不用再进行了

22:15.420 --> 22:17.420
它会反复的进行

22:17.420 --> 22:18.420
为什么这样说呢

22:18.420 --> 22:20.420
这一步在做什么

22:20.420 --> 22:21.420
这一步就是

22:21.420 --> 22:24.420
我要算出每个元素

22:24.420 --> 22:27.420
它的位置和尺寸

22:27.420 --> 22:30.420
我们现在多么结构出来了

22:30.420 --> 22:31.420
但是位置尺寸

22:31.420 --> 22:34.420
我其实很多地方还不清楚

22:34.420 --> 22:36.420
位置尺寸包含哪些信息

22:36.420 --> 22:37.420
包含的信息多了

22:37.420 --> 22:39.420
你整个窗口有多辣

22:39.420 --> 22:41.420
滚动条在哪个位置

22:41.420 --> 22:43.420
滚动条在哪个位置

22:43.420 --> 22:44.420
那么这个元素

22:44.420 --> 22:46.420
应该在显示在这个窗口里面

22:46.420 --> 22:47.420
哪个位置

22:47.420 --> 22:50.420
比方说这个元素

22:50.420 --> 22:52.420
比方说要把这个框框画出来

22:52.420 --> 22:53.420
你会发现这个框框

22:53.420 --> 22:54.420
只画了一部分

22:54.420 --> 22:55.420
并没有画完

22:55.420 --> 22:57.420
上面还有部分遮住了

22:57.420 --> 22:59.420
那为什么只画这一部分

22:59.420 --> 23:00.420
它要算的

23:00.420 --> 23:02.420
看你的滚动条的位置

23:02.420 --> 23:04.420
看其他元素的遮挡关系

23:04.420 --> 23:07.420
看这个尺寸窗口的大小

23:07.420 --> 23:08.420
然后跟距离的各种世界

23:08.420 --> 23:09.420
属性要算

23:09.420 --> 23:10.420
最终算出来什么

23:10.420 --> 23:12.420
算出来它的尺寸

23:12.420 --> 23:13.420
尺寸目前就这么大

23:13.420 --> 23:15.420
你可能真正的尺寸还要高一些

23:15.420 --> 23:17.420
但是你目前显示出来的尺寸

23:17.420 --> 23:18.420
就这么大

23:18.420 --> 23:19.420
然后在哪个位置

23:19.420 --> 23:21.420
在你窗口左边

23:21.420 --> 23:22.420
这枚段距离

23:22.420 --> 23:24.420
你窗口上边

23:24.420 --> 23:25.420
这枚段距离

23:25.420 --> 23:26.420
它要算出来

23:26.420 --> 23:27.420
算出来是不是就可以画了

23:27.420 --> 23:28.420
就这么意思

23:28.420 --> 23:29.420
它要去计算

23:29.420 --> 23:33.420
这个计算过程是非常非常复杂的

23:33.420 --> 23:35.420
那么这个过程就称之为

23:35.420 --> 23:36.420
Layout

23:36.420 --> 23:37.420
Layout叫做Reflow

23:37.420 --> 23:39.420
不同的浏览器的教法不一样

23:39.420 --> 23:40.420
以后你们面试体里边

23:40.420 --> 23:43.420
常见的教法叫做Reflow

23:43.420 --> 23:44.420
回流或者重排

23:44.420 --> 23:45.420
回流这个单词

23:45.420 --> 23:47.420
回流这个翻译

23:47.420 --> 23:49.420
我也不知道是哪个省线翻译的

23:49.420 --> 23:50.420
反正有这样的翻译

23:50.420 --> 23:52.420
Re表示重新的Flow

23:52.420 --> 23:54.420
表示流的意思

23:54.420 --> 23:55.420
其实这个流的意思

23:55.420 --> 23:58.420
就是从上到下一次排列的意思

23:58.420 --> 24:00.420
它是它给你翻成回流

24:00.420 --> 24:02.420
反正它就要这样翻译

24:02.420 --> 24:04.420
比较好的就是翻一层重排

24:04.420 --> 24:06.420
重新排列

24:06.420 --> 24:09.420
是指浏览器一边生成渲染数

24:09.420 --> 24:10.420
CSS有了

24:10.420 --> 24:11.420
动结构有了

24:11.420 --> 24:13.420
但是我要现在要计算

24:13.420 --> 24:15.420
每个元素

24:15.420 --> 24:17.420
它应该把它画到哪个地方

24:17.420 --> 24:19.420
最终的尺寸和位置

24:19.420 --> 24:21.420
这一步完成之后

24:21.420 --> 24:23.420
一面中所有元素的位置

24:23.420 --> 24:25.420
和尺寸就全部确定下来了

24:25.420 --> 24:27.420
那么就可以画出来了

24:27.420 --> 24:28.420
但是这个步骤

24:28.420 --> 24:29.420
它没有那么简单

24:29.420 --> 24:31.420
一是它非常费时

24:31.420 --> 24:33.420
第二

24:33.420 --> 24:36.420
这个过程它会反复的进行

24:36.420 --> 24:37.420
为什么会反复进行

24:37.420 --> 24:39.420
那就画一次不就出来了吗

24:39.420 --> 24:41.420
为什么会反复进行

24:41.420 --> 24:43.420
你滚动滚动条的时候

24:43.420 --> 24:45.420
是不是位置尺寸有变化

24:45.420 --> 24:47.420
有时候没有变的

24:47.420 --> 24:49.420
我指的是在四口里边的

24:49.420 --> 24:51.420
相对于整个窗口的

24:51.420 --> 24:53.420
它是不是会变化

24:53.420 --> 24:54.420
它会往哪里跑

24:54.420 --> 24:55.420
就往上跑

24:55.420 --> 24:56.420
对吧

24:56.420 --> 24:57.420
那是不是在重新

24:57.420 --> 24:58.420
这个玩意儿每滑动一次

24:58.420 --> 25:00.420
滚动条没滚动一次

25:00.420 --> 25:02.420
它就得重新计算

25:02.420 --> 25:06.420
重新计算回流

25:06.420 --> 25:08.420
重新来一次

25:08.420 --> 25:10.420
不然它没有算出新的位置

25:10.420 --> 25:11.420
它就没法画

25:11.420 --> 25:12.420
懂了意思吧

25:12.420 --> 25:13.420
所以说这个过程是反复的

25:13.420 --> 25:14.420
不断的进行

25:14.420 --> 25:15.420
除了之中

25:15.420 --> 25:16.420
包括在哪里呢

25:16.420 --> 25:18.420
包括你看这个图片

25:18.420 --> 25:20.790
如果说你想想

25:20.790 --> 25:22.790
这个图片夹在过程中

25:22.790 --> 25:24.790
这个图片没有夹在出来

25:24.790 --> 25:25.790
这个图片还没有夹在出来

25:25.790 --> 25:26.790
这个图片先出来了

25:26.790 --> 25:28.790
那是不是这个图片

25:28.790 --> 25:29.790
就应该在这

25:29.790 --> 25:30.790
是不是应该在这

25:30.790 --> 25:32.790
就这个第二张那个狗

25:32.790 --> 25:33.790
它是起

25:33.790 --> 25:34.790
是不是应该在这

25:34.790 --> 25:35.790
等第一个图片夹在出来过程

25:35.790 --> 25:37.790
它是不是被挤到后边去了

25:37.790 --> 25:38.790
所以说很多地方

25:38.790 --> 25:40.790
包括这个图片夹在完成之后

25:40.790 --> 25:43.790
也会导致页面重新排列

25:43.790 --> 25:44.790
你可以想象到

25:44.790 --> 25:46.790
我们到处会有页面重新排列

25:46.790 --> 25:49.790
包括一个元素的位置变化

25:49.790 --> 25:50.790
是不是会导致

25:50.790 --> 25:52.790
其他元素有可能会跟着变化

25:52.790 --> 25:53.790
都会重新排列

25:53.790 --> 25:56.790
都会要重新算

25:56.790 --> 25:58.790
那么除了这些东西

25:58.790 --> 25:59.790
浏览器自动完成之外

25:59.790 --> 26:01.790
其实我们在介石里面

26:01.790 --> 26:05.790
有一些操作也会导致

26:05.790 --> 26:07.790
面试体经常会问这个

26:07.790 --> 26:11.790
哪些操作我们会导致重排

26:11.790 --> 26:14.790
当你要获取元素的尺寸和位置的时候

26:14.790 --> 26:16.790
它会导致重排

26:16.790 --> 26:18.790
当你直接或间接的

26:18.790 --> 26:20.790
改变元素的尺寸和位置的时候

26:20.790 --> 26:22.790
也会导致重排

26:22.790 --> 26:23.790
好 我先解释第二个

26:23.790 --> 26:25.790
第二个是比较简单的吧

26:25.790 --> 26:28.790
直接改变元素的宽高

26:28.790 --> 26:29.790
坐标比方它绝对定位

26:29.790 --> 26:30.790
改变它的位置

26:30.790 --> 26:32.790
是不是会导致重新计算

26:32.790 --> 26:34.790
尺寸位置重新计算

26:34.790 --> 26:35.790
导致重排吧

26:35.790 --> 26:36.790
这个没问题吧

26:36.790 --> 26:37.790
这个好理解吧

26:37.790 --> 26:39.790
那什么叫间接呢

26:39.790 --> 26:41.790
什么叫间接

26:41.790 --> 26:42.790
间接比方说

26:42.790 --> 26:45.790
我改了图片的src地址

26:45.790 --> 26:47.790
是不是图片加载完成过后

26:47.790 --> 26:49.790
它可能图片变得更大了

26:49.790 --> 26:50.790
是不是也会导致重排

26:50.790 --> 26:52.790
比方说我改了字体大小

26:52.790 --> 26:55.790
是不是导致了一些

26:55.790 --> 26:57.790
有些字体大小变大了

26:57.790 --> 26:58.790
是不是导致它的元素

26:58.790 --> 26:59.790
可能会被撑开

26:59.790 --> 27:01.790
也会导致重排

27:01.790 --> 27:02.790
所以很多地方

27:02.790 --> 27:04.790
不光是直接改变宽高

27:04.790 --> 27:07.790
凡是你觉得这个改了之后

27:07.790 --> 27:09.790
会导致其他元素

27:09.790 --> 27:11.790
或者是自己的宽高位置

27:11.790 --> 27:15.790
发生变化的都会导致重排

27:15.790 --> 27:16.790
这是第二个

27:16.790 --> 27:17.790
那么为什么

27:17.790 --> 27:21.790
第一个获取也会导致重排呢

27:21.790 --> 27:22.790
因为它要

27:22.790 --> 27:25.790
因为这个重排它其实

27:25.790 --> 27:27.790
并不是实时的

27:27.790 --> 27:29.790
比方说我这里滚动

27:29.790 --> 27:31.790
如果说我的电脑很卡

27:31.790 --> 27:33.790
你会发现我滚动调滚的过后

27:33.790 --> 27:35.790
这边滚动有一点延时

27:35.790 --> 27:36.790
有一点滞后

27:36.790 --> 27:38.790
如果说电脑很卡很卡的时候

27:38.790 --> 27:40.790
它又会出现这种情况

27:40.790 --> 27:41.790
也就是说这个重排

27:41.790 --> 27:43.790
它并不是说立即执行的

27:43.790 --> 27:45.790
它需要一个时间一个过程

27:45.790 --> 27:46.790
那么我们既也是代码

27:46.790 --> 27:48.790
运行到某一句话的时候

27:48.790 --> 27:49.790
我这里需要得到一个准确的

27:49.790 --> 27:52.790
这个元素准确的尺寸和位置

27:52.790 --> 27:54.790
它必须要给你重新计算一次

27:54.790 --> 27:56.790
才能给你一个准确的值

27:56.790 --> 27:57.790
否则的话

27:57.790 --> 28:00.790
它有可能拿到的是一个不准确的值

28:00.790 --> 28:02.790
简单了解一下就可以了

28:02.790 --> 28:04.790
总之你获取元素的尺寸和位置

28:04.790 --> 28:06.790
它也会导致它重排

28:06.790 --> 28:08.790
重排是非常耗时的

28:08.790 --> 28:10.790
浏览器为了提升性能

28:10.790 --> 28:12.790
都做了一些相应的处理

28:12.790 --> 28:14.790
它最常见的处理就是这样子的

28:14.790 --> 28:15.790
它如果说发现

28:15.790 --> 28:16.790
你既也是代码中

28:16.790 --> 28:18.790
连续导致重排的代码

28:18.790 --> 28:20.790
它会把重排的时间点了

28:20.790 --> 28:21.790
延后

28:21.790 --> 28:23.790
看地址就知道了

28:23.790 --> 28:24.790
然后这里

28:24.790 --> 28:25.790
我给它宽度设为

28:25.790 --> 28:27.790
设置宽度是否导致重排

28:27.790 --> 28:29.790
设置高度是否导致reflow

28:29.790 --> 28:32.790
做标是否都会导致重排

28:32.790 --> 28:34.790
那么这里按理说

28:34.790 --> 28:36.790
它会重排四次

28:36.790 --> 28:38.790
这里运行出来过后

28:38.790 --> 28:39.790
等待重排

28:39.790 --> 28:41.790
排完了之后再来运行这句话

28:41.790 --> 28:42.790
又导致重排

28:42.790 --> 28:44.790
而重排是比较耗时的

28:44.790 --> 28:45.790
这里重排四次

28:45.790 --> 28:47.790
其实没有必要

28:47.790 --> 28:48.790
它会怎么做呢

28:48.790 --> 28:49.790
它会这样子来做

28:49.790 --> 28:51.790
它会先改变宽度

28:51.790 --> 28:52.790
这个时候宽度变了

28:52.790 --> 28:53.790
没有重排

28:53.790 --> 28:55.790
也就是还没有反应到页面上

28:55.790 --> 28:56.790
页面上还看不出来

28:56.790 --> 28:57.790
它宽度变了

28:57.790 --> 28:59.790
马上运行下句话

28:59.790 --> 29:00.790
改变高度

29:00.790 --> 29:01.790
高度变了

29:01.790 --> 29:02.790
页面上看不出来

29:02.790 --> 29:03.790
因为单板运行速度很快

29:03.790 --> 29:04.790
非常非常快

29:04.790 --> 29:05.790
人眼是感觉不到的

29:05.790 --> 29:07.790
人呢倒是没有什么感觉

29:07.790 --> 29:10.790
但是如果你把时间力度

29:10.790 --> 29:13.790
放大

29:13.790 --> 29:15.790
比方说这里需要一年

29:15.790 --> 29:17.790
这里呢也需要一年

29:17.790 --> 29:18.790
这句话

29:18.790 --> 29:19.790
那这一年

29:19.790 --> 29:20.790
这一运行过后

29:20.790 --> 29:21.790
人类浏览器的宽度

29:21.790 --> 29:22.790
还是圆然的宽度

29:22.790 --> 29:24.790
它不会变成100

29:24.790 --> 29:26.790
你看到的还是圆然的宽度

29:26.790 --> 29:28.790
它要等到一块

29:28.790 --> 29:30.790
一直变

29:30.790 --> 29:31.790
最后它发现

29:31.790 --> 29:33.790
没有别的事可以做了

29:33.790 --> 29:34.790
暂时没有别的事可以做了

29:34.790 --> 29:35.790
这个时候

29:35.790 --> 29:37.790
它才会一起来

29:37.790 --> 29:39.790
进行一次重新运算

29:39.790 --> 29:41.790
它把刚才的这些东西

29:41.790 --> 29:43.790
真正的让用户看得到

29:43.790 --> 29:45.790
变成了宽度变成100

29:45.790 --> 29:46.790
高度变200

29:46.790 --> 29:47.790
所以它不会重排四次

29:47.790 --> 29:49.790
它只会重排一次

29:49.790 --> 29:51.790
这是浏览器做的优化

29:51.790 --> 29:53.790
好吧

29:53.790 --> 29:55.790
但是

29:55.790 --> 29:57.790
有但是

29:57.790 --> 29:59.790
但是什么呢

29:59.790 --> 30:01.790
如果说你在这个过程中

30:01.790 --> 30:03.790
夹杂了这么一种代码

30:03.790 --> 30:05.790
我设置宽度设置高度

30:05.790 --> 30:06.790
然后呢这里

30:06.790 --> 30:09.790
我在读取它目前的高度

30:09.790 --> 30:11.790
这个时候

30:11.790 --> 30:12.790
它就没办法了

30:12.790 --> 30:15.790
它迫不得已强行重排

30:15.790 --> 30:16.790
为什么呢

30:16.790 --> 30:17.790
你想这个道理

30:17.790 --> 30:19.790
如果说我这里设置了宽高之后

30:19.790 --> 30:20.790
我在读取高度

30:20.790 --> 30:22.790
它这个时候不重新计算

30:22.790 --> 30:25.790
它如何给你准确的高度

30:25.790 --> 30:27.790
比方说之前的高度是1000

30:27.790 --> 30:29.790
它这里不重新计算高度

30:29.790 --> 30:30.790
它给你的还是1000

30:30.790 --> 30:31.790
那肯定不合理

30:31.790 --> 30:33.790
我刚刚才把高度设成200

30:33.790 --> 30:34.790
怎么你给我1000呢

30:34.790 --> 30:36.790
所以它这个时候你读取

30:36.790 --> 30:37.790
就在整个过程中

30:37.790 --> 30:40.790
如果说你在尝试的读取

30:40.790 --> 30:42.790
它的尺寸和位置

30:42.790 --> 30:43.790
会导致强行重排

30:43.790 --> 30:45.790
这就是再一次印证了

30:45.790 --> 30:46.790
刚才的说法

30:46.790 --> 30:49.790
为什么读取它也会导致重排的原因

30:49.790 --> 30:51.790
它给你一个准确的值

30:51.790 --> 30:53.790
因此这个代码它就会重排两次

30:53.790 --> 30:55.790
改变宽度 改变高度

30:55.790 --> 30:59.790
现在读取高度了强行重排

30:59.790 --> 31:00.790
如果说时间

31:00.790 --> 31:03.790
把时间力度放大一点

31:03.790 --> 31:05.790
你会发现这里卡顿了一下

31:05.790 --> 31:07.790
但是我们设置得太快了

31:07.790 --> 31:08.790
我们看不出来

31:08.790 --> 31:09.790
然后改变横坐标

31:09.790 --> 31:10.790
改变重坐标

31:10.790 --> 31:11.790
这个时候

31:11.790 --> 31:13.790
因为又有改动的代码

31:13.790 --> 31:14.790
所以后边又会有一次重排

31:14.790 --> 31:16.790
这个代码就会导致两次重排

31:16.790 --> 31:20.790
因此对于我们开发而言

31:20.790 --> 31:21.790
像我们在读取什么

31:21.790 --> 31:24.790
宽高尺寸位置的时候

31:24.790 --> 31:26.790
能不频繁读取

31:26.790 --> 31:28.790
就不要频繁读取

31:28.790 --> 31:29.790
不知道同学们

31:29.790 --> 31:30.790
还有没有印象

31:30.790 --> 31:33.790
之前我们在写拖动

31:33.790 --> 31:34.790
那个例子的时候

31:34.790 --> 31:35.790
我们当时

31:35.790 --> 31:37.790
这个代码大概是长这个样子的

31:37.790 --> 31:40.790
就是AMOS MOOD

31:40.790 --> 31:41.790
当鼠标移动的时候

31:41.790 --> 31:42.790
我当时是不是

31:42.790 --> 31:45.790
可以获取宽高

31:45.790 --> 31:49.790
获取某一个元素的宽高

31:49.790 --> 31:51.790
但是我当时当时说

31:51.790 --> 31:55.790
这个世界触发的太频繁了

31:55.790 --> 31:58.790
但是宽高又没有什么变化

31:58.790 --> 32:00.790
你没有必要每一次去获取

32:00.790 --> 32:01.790
这个有点浪费时间

32:01.790 --> 32:02.790
就是这个原因

32:02.790 --> 32:04.790
每一次获取这个东西

32:04.790 --> 32:05.790
都会导致重排

32:05.790 --> 32:07.790
那你这个鼠标移动

32:07.790 --> 32:09.790
你看世界触发的人得多频繁

32:09.790 --> 32:11.790
其实没有必要

32:11.790 --> 32:12.790
这个玩意如果说

32:12.790 --> 32:14.790
当然如果说它有变化的话

32:14.790 --> 32:15.790
这个就一定说了

32:15.790 --> 32:17.790
如果说它没有变化的话

32:17.790 --> 32:18.790
你可以一开始

32:18.790 --> 32:21.790
先把它保存到一个变量里边

32:21.790 --> 32:23.790
特别用这个变量就行了

32:23.790 --> 32:25.790
你用变量它又不会导致重排的

32:25.790 --> 32:27.790
你用这个鼠性就会导致重排

32:27.790 --> 32:28.790
懂了意思吗

32:28.790 --> 32:30.790
这是一些小技巧

32:31.790 --> 32:33.790
好 这是重排这一块

32:33.790 --> 32:34.790
我给大家说的

32:34.790 --> 32:35.790
好 最后一个是重绘

32:35.790 --> 32:37.790
这些可能没有什么作业

32:37.790 --> 32:39.790
只是理论性的东西

32:39.790 --> 32:41.790
但是同学们一定要知道

32:41.790 --> 32:42.790
同学们下来之后

32:42.790 --> 32:44.790
你就把这一套东西

32:44.790 --> 32:46.790
在脑袋里面好好过一下

32:46.790 --> 32:48.790
最好的用话

32:48.790 --> 32:49.790
记笔记也好

32:49.790 --> 32:50.790
或者是

32:50.790 --> 32:52.790
把说出来也好

32:52.790 --> 32:53.790
最好是说出来

32:53.790 --> 32:55.790
断练自己的表达能力

32:55.790 --> 32:56.790
就是浏览圈的流程

32:56.790 --> 32:57.790
到底是一个怎么样的回事

32:57.790 --> 32:58.790
每一步做了什么事情

32:58.790 --> 33:00.790
好 最后一步重绘

33:00.790 --> 33:02.790
还是一样

33:02.790 --> 33:04.790
一边重排 一边重绘

33:04.790 --> 33:06.790
重绘是非常简单的

33:06.790 --> 33:07.790
位置确定的

33:07.790 --> 33:09.790
大小确定的

33:10.790 --> 33:12.790
就可以把他画出来了

33:12.790 --> 33:13.790
那么这个时候画的时候

33:13.790 --> 33:15.790
是靠了一个

33:15.790 --> 33:16.790
把整个绘画的过程

33:16.790 --> 33:18.790
就称为repeat

33:18.790 --> 33:20.790
为什么要重绘呢

33:20.790 --> 33:22.790
那又是为什么要重的

33:22.790 --> 33:23.790
又是要加个重字呢

33:23.790 --> 33:25.790
还是一样的道理

33:25.790 --> 33:27.790
这个过程会反复进行

33:28.790 --> 33:30.790
所有会导致重排的代码

33:30.790 --> 33:32.790
都会导致重绘

33:32.790 --> 33:33.790
好理解吧

33:33.790 --> 33:35.790
为什么

33:35.790 --> 33:37.790
因为他的元素的尺寸变了

33:37.790 --> 33:39.790
尺寸重新计算了

33:39.790 --> 33:40.790
位置重新计算了

33:40.790 --> 33:41.790
不得重新画一遍

33:41.790 --> 33:43.790
之前的像粉

33:43.790 --> 33:45.790
用个叉子把黑板上的叉掉

33:45.790 --> 33:46.790
重新画一遍

33:46.790 --> 33:47.790
其实

33:47.790 --> 33:48.790
我们的流量器

33:48.790 --> 33:49.790
这些东西

33:49.790 --> 33:52.790
包括你们玩的什么游戏之类的

33:52.790 --> 33:54.790
就有点像一个手术

33:54.790 --> 33:56.790
极快的一个老师

33:56.790 --> 33:57.790
比方邓哥

33:58.790 --> 33:59.790
他为什么能看到

33:59.790 --> 34:00.790
各种动画

34:00.790 --> 34:01.790
各种连续的效果

34:01.790 --> 34:03.790
就是一个手术极快的老师

34:03.790 --> 34:04.790
先给他画一张图

34:04.790 --> 34:05.790
马上给他擦了

34:05.790 --> 34:06.790
给他画下一张

34:06.790 --> 34:07.790
然后

34:07.790 --> 34:08.790
人的眼睛就看到

34:08.790 --> 34:09.790
他是一个连续的了

34:09.790 --> 34:11.790
就这么个意思

34:11.790 --> 34:12.790
所以说

34:12.790 --> 34:13.790
这里就是

34:13.790 --> 34:15.790
所有的尺寸位置变化

34:15.790 --> 34:17.790
那么都会导致重新画一遍

34:17.790 --> 34:18.790
整个绘画的过程

34:18.790 --> 34:20.790
是靠GPU完成的

34:20.790 --> 34:21.790
所以说速度非常快

34:21.790 --> 34:22.790
因此

34:22.790 --> 34:25.790
相对于那些导致重排的代码

34:26.790 --> 34:27.790
相对的

34:27.790 --> 34:30.790
那些紧绘导致重绘的代码

34:30.790 --> 34:32.790
效率会高出很多

34:32.790 --> 34:33.790
什么叫紧绘导致重绘

34:33.790 --> 34:35.790
就说有些代码

34:35.790 --> 34:37.790
或者是有些现象

34:37.790 --> 34:40.790
我不会导致重新计算尺寸

34:40.790 --> 34:41.790
计算位置

34:41.790 --> 34:44.790
但是它的样子确实变了

34:45.790 --> 34:46.790
哪些情况呢

34:46.790 --> 34:48.790
改变背景颜色

34:48.790 --> 34:50.790
跟排列没关系吗

34:50.790 --> 34:52.790
跟尺寸位置没关系吗

34:52.790 --> 34:53.790
只是背景颜色变了

34:53.790 --> 34:54.790
但是再重新画一遍

34:54.790 --> 34:55.790
它不会导致重排

34:55.790 --> 34:57.790
但是它会重新画一遍

34:57.790 --> 34:59.790
改变字体颜色

34:59.790 --> 35:01.790
圆角边框

35:01.790 --> 35:03.790
圆角边框只是看了个样子

35:03.790 --> 35:04.790
我们的盒子是一个

35:04.790 --> 35:05.790
试试方方的盒子

35:05.790 --> 35:08.790
但圆角边框只是试着那个角

35:08.790 --> 35:10.790
看上去有点圆滑

35:10.790 --> 35:13.790
它其实盒子还是一颗举行的

35:13.790 --> 35:16.790
它并不影响盒子的尺寸和位置

35:16.790 --> 35:18.790
因此像这种背景图

35:18.790 --> 35:20.790
这些东西都会导致重绘

35:20.790 --> 35:22.790
你去改变这些东西都会导致重绘

35:22.790 --> 35:24.790
它不会导致重排

35:24.790 --> 35:26.790
懂了意思吧

35:26.790 --> 35:27.790
好 知道这一点

35:27.790 --> 35:29.790
我们后边学习C3

35:29.790 --> 35:30.790
C3的时候就很简单了

35:30.790 --> 35:32.790
有些动画

35:32.790 --> 35:35.790
为什么C3的动画的效率更高

35:35.790 --> 35:36.790
你看C3之前

35:36.790 --> 35:37.790
我们用GS做动画

35:37.790 --> 35:39.790
都是一点点的去改变它

35:39.790 --> 35:40.790
先把从这个位置

35:40.790 --> 35:41.790
改到下一个位置

35:41.790 --> 35:43.790
用技时器一点点的去改变它

35:43.790 --> 35:44.790
来玩这个动画效果

35:44.790 --> 35:45.790
但是不仅麻烦

35:45.790 --> 35:47.790
而且效率还低

35:47.790 --> 35:48.790
为什么呢

35:48.790 --> 35:49.790
是因为GS

35:49.790 --> 35:52.790
比方说我们这里简单一个伟大

35:52.790 --> 35:54.790
我做一个动画

35:54.790 --> 35:57.790
我去每个10毫秒

35:57.790 --> 36:02.550
改变一个元素的Left值

36:02.550 --> 36:03.550
那你每一次改变Left值

36:03.550 --> 36:05.550
是不是会导致重排

36:05.550 --> 36:06.550
对吧

36:06.550 --> 36:07.550
重排过后

36:07.550 --> 36:08.550
当然会导致重绘

36:08.550 --> 36:10.550
它位置变了

36:10.550 --> 36:13.550
而C3也可以做出类似的动画

36:13.550 --> 36:14.550
但是C3

36:14.550 --> 36:16.550
你用C3的方式来做的话

36:16.550 --> 36:17.550
它不会导致重排

36:17.550 --> 36:19.550
因此它的效率更高

36:19.550 --> 36:21.550
它只是视觉上

36:21.550 --> 36:23.550
它合制还是原来的位置

36:23.550 --> 36:25.550
视觉上你得放到

36:25.550 --> 36:26.550
在另外一个地方画出来

36:26.550 --> 36:28.550
所以说

36:28.550 --> 36:29.550
它不会导致重排

36:29.550 --> 36:32.550
不会去重新计划职员的位置

36:32.550 --> 36:34.550
后边里面学就知道了

36:34.550 --> 36:36.550
OK 那就完事了

36:36.550 --> 36:37.550
就是这里刻的内容

36:37.550 --> 36:38.550
这里刻的内容我再重申一次

36:38.550 --> 36:40.550
它是一些理论性的指示

36:40.550 --> 36:41.550
你不能完全不知道

36:41.550 --> 36:43.550
你要知道的就是我这里刻

36:43.550 --> 36:44.550
要讲的东西

36:44.550 --> 36:45.550
下来之后

36:45.550 --> 36:47.550
你可以用做笔记的方式

36:47.550 --> 36:48.550
写一段话

36:48.550 --> 36:50.550
把这里刻讲的内容写下来

36:50.550 --> 36:51.550
也可以呢

36:51.550 --> 36:52.550
最好

36:52.550 --> 36:54.550
原来是特别建议大家

36:54.550 --> 36:56.550
找一个没人的地方

36:56.550 --> 36:59.550
或者你找一个自己合适的地方

36:59.550 --> 37:01.550
把它说出来

37:01.550 --> 37:02.550
因为你们以后

37:02.550 --> 37:04.550
面试的时候是要说的呀

37:04.550 --> 37:06.550
是要给别人说的

37:06.550 --> 37:09.550
那么锻炼表达能力

37:09.550 --> 37:11.550
是非常重要的

37:11.550 --> 37:12.550
最好在前进

37:12.550 --> 37:14.550
就开始注重这一点

37:14.550 --> 37:15.550
像我们学了一些课

37:15.550 --> 37:17.550
特别是一些一篇理论的课程

37:17.550 --> 37:19.550
那么学了之后

37:19.550 --> 37:20.550
在公交课上 地铁上

37:20.550 --> 37:21.550
再倒在一边过一下

37:21.550 --> 37:22.550
或者是说出来

37:22.550 --> 37:23.550
最好是说出来

37:23.550 --> 37:24.550
把表达出来

37:24.550 --> 37:25.550
这一刻讲了啥

37:25.550 --> 37:27.550
极其的重要

37:27.550 --> 37:28.550
好了 其他没啥了

37:28.550 --> 37:30.550
那么这一刻就到此结束了

