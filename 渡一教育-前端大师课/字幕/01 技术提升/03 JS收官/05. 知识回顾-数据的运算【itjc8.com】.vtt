WEBVTT

00:01.010 --> 00:04.410
好了 我们前边已经搞定了数据的表达

00:04.410 --> 00:08.810
现在我们可以把事件万物所有的我们想要表达的数据

00:08.810 --> 00:11.210
都可以放到程序里边进行表达了

00:11.210 --> 00:16.010
大不了有的是用数组 有的是用支付串 有的是用数字 有的是用对象

00:16.010 --> 00:18.610
我们选择一个合适的 把它表达出来就可以了

00:18.610 --> 00:20.810
这一块已经没问题了 已经扫干净了

00:20.810 --> 00:22.810
然后接下来我们要聊的另外一个事

00:22.810 --> 00:25.410
光有数据在计算机这边还不够

00:25.410 --> 00:28.010
我们还要把它拿出来做各种各样的运算

00:28.810 --> 00:32.810
然后两个数字相加 一些支付串我们要拼接

00:32.810 --> 00:35.810
或者是一些逻辑运算 并且或者对吧

00:35.810 --> 00:39.610
有些东西我们要进行比较 这些都是属于运算

00:39.610 --> 00:42.210
这个运算的翻策是很大的

00:42.210 --> 00:45.210
不是说只有数学才叫运算

00:45.210 --> 00:48.010
数学只是运算的其中一种

00:48.010 --> 00:49.810
好 我们既然聊一聊这些运算

00:49.810 --> 00:53.210
我们快速的过一下 很多运算是非常简单的

00:53.210 --> 00:56.610
只不过在运算的过程中在介绍这个语言特点里边

00:56.610 --> 00:59.810
会有一些非常奇妙的事情

00:59.810 --> 01:02.810
我们主要是聊一些比较奇妙的事情

01:02.810 --> 01:04.810
好 第一个是算数运算

01:04.810 --> 01:08.810
算数运算就这么几种 加减乘除求予

01:08.810 --> 01:11.810
这个没有什么好说的吧

01:11.810 --> 01:13.810
只是我们要值得注意的是这个

01:13.810 --> 01:18.010
就是加号和减号是可以放到单个数据前边的

01:18.010 --> 01:20.010
它表示正负 这啥意思呢

01:20.010 --> 01:23.810
比方说咱们来打开浏览器

01:24.810 --> 01:26.810
我们比方说写一个三

01:26.810 --> 01:28.810
那就是一个数字 没问题

01:28.810 --> 01:31.810
它告诉我一个反悔 这个表达是反悔的结果就是三

01:31.810 --> 01:33.810
那么其实我们也可以写个正三

01:33.810 --> 01:36.810
这个加号放前边是可以的 表示正好

01:36.810 --> 01:38.810
那么它得到结果还是咱

01:38.810 --> 01:41.810
哎呀 这个玩意儿有啥用呢

01:41.810 --> 01:43.810
这个玩意儿还真的有用

01:43.810 --> 01:45.810
什么用呢 这次就到另外一个问题

01:45.810 --> 01:48.810
叫做内形的影视转换

01:48.810 --> 01:51.810
那么这里有个参考 点一下就跳到下面

01:51.810 --> 01:53.810
这个影视转换是什么意思呢

01:53.810 --> 01:57.810
就是说我们在做运算的时候不是有符号吗

01:57.810 --> 02:00.810
像这个加号 减号都是运算符

02:00.810 --> 02:04.810
那么这些运算符它有自己期望的数据

02:04.810 --> 02:06.810
比方说像这个乘号

02:06.810 --> 02:09.810
它期望的是什么呢 两个都是数字

02:09.810 --> 02:11.810
比方说我们写一个二乘一三

02:11.810 --> 02:14.810
这个乘号就希望左右两边都是一个数字

02:14.810 --> 02:16.810
我才能相乘吗 不然我咋相乘呢

02:16.810 --> 02:18.810
你给我一个什么一个数组

02:18.810 --> 02:20.810
再乘一个对象

02:20.810 --> 02:22.810
咋理解了这个玩意儿

02:22.810 --> 02:25.810
它期望的是数字

02:25.810 --> 02:28.810
就是每一个符号它有个期望值

02:28.810 --> 02:31.810
期望什么 比方说我们要比较的是

02:31.810 --> 02:33.810
我们要做什么并且 对吧

02:33.810 --> 02:35.810
并且A并且B

02:35.810 --> 02:38.810
那么它期望什么 期望A是一个布尔

02:38.810 --> 02:40.810
B也是一个布尔 对吧

02:40.810 --> 02:42.810
所以它有个期望值 懂得意思吗

02:42.810 --> 02:44.810
比方说要求予

02:44.810 --> 02:48.810
求予它就期望 这些数据都是数字

02:48.810 --> 02:51.810
那么如果说它不满足期望的话

02:51.810 --> 02:53.810
既也是它不会提醒你说

02:53.810 --> 02:55.810
哎 抱个错 给谈框框说你这个地方

02:55.810 --> 02:58.810
不是数字哦 我现在要做惩罚哦

02:58.810 --> 02:59.810
不是数字哦 你给我弄成数字

02:59.810 --> 03:01.810
我才能做惩罚哦

03:01.810 --> 03:04.810
它不会爆错 也不会提醒你

03:04.810 --> 03:06.810
有些人它就会爆错

03:06.810 --> 03:08.810
它提醒你 它说你我要做惩罚

03:08.810 --> 03:10.810
你给我我的不是数字 我没法做

03:10.810 --> 03:12.810
但既也是不会提醒你

03:12.810 --> 03:15.810
它会悄悄的把这个数字呢

03:15.810 --> 03:18.810
把这个数据转换成想要的结果

03:18.810 --> 03:21.810
那么这就是引式转换

03:21.810 --> 03:22.810
懂得意思吗

03:22.810 --> 03:25.810
比方说我给它的不是一个

03:25.810 --> 03:28.810
我给它的数字 它期望是数字对吧

03:28.810 --> 03:31.810
它说我给它的不是数字

03:31.810 --> 03:32.810
那怎么办呢

03:32.810 --> 03:34.810
它就悄悄的把这个东西转成数字

03:34.810 --> 03:36.810
把这个玩意儿也转成数字

03:36.810 --> 03:38.810
当然有些转出来 它转不了

03:38.810 --> 03:40.810
转不了就是NNN

03:40.810 --> 03:42.810
NNN它不也是数字吗

03:42.810 --> 03:44.810
NNN是一种特殊的数字

03:45.810 --> 03:49.810
那么它转了之后再进行运转

03:49.810 --> 03:51.810
这就叫做引式转换

03:51.810 --> 03:53.810
那么这个引式转换就特别有趣

03:53.810 --> 03:57.810
我们肯定用它来做一些现象

03:57.810 --> 04:00.810
注意的是这个引式转换它是临时的

04:00.810 --> 04:02.810
不会对元数据造成影响

04:02.810 --> 04:03.810
比方说啥意思呢

04:03.810 --> 04:05.810
比方说你这里有一个变量A

04:05.810 --> 04:07.810
A里边放的是ABC

04:07.810 --> 04:08.810
放的是1 对吧

04:08.810 --> 04:10.810
那我现在要A乘

04:10.810 --> 04:12.810
写的是2吗

04:13.810 --> 04:15.810
AA等于2

04:15.810 --> 04:17.810
现在我们要做个惩法

04:17.810 --> 04:19.810
A乘以3得到结果自然是6

04:19.810 --> 04:20.810
对吧 它怎么做的呢

04:20.810 --> 04:22.810
它明明是一个字符号

04:22.810 --> 04:24.810
它把它引式转换成了数字

04:24.810 --> 04:26.810
但是那种引式转换是临时的

04:26.810 --> 04:27.810
就是临时的把它转换成2

04:27.810 --> 04:29.810
然后再乘以3得到一个结果6

04:29.810 --> 04:30.810
这是个表达式 对吧

04:30.810 --> 04:31.810
反回结果16

04:31.810 --> 04:33.810
它不会对A造成影响的

04:33.810 --> 04:35.810
A里边还是字符号

04:35.810 --> 04:37.810
这个地方大家注意一下就行了

04:37.810 --> 04:38.810
那么我们这个玩意儿

04:38.810 --> 04:40.810
有什么拥的这个玩意儿

04:40.810 --> 04:41.810
这个玩意儿特别有用

04:41.810 --> 04:42.810
有的时候特别有用

04:42.810 --> 04:44.810
比方说我们刚才说了

04:44.810 --> 04:45.810
前边放一个加号表示什么

04:45.810 --> 04:47.810
表示正号 对吧

04:47.810 --> 04:49.810
我现在有个变量

04:49.810 --> 04:51.810
我也不知道它里边是啥

04:51.810 --> 04:52.810
我都不知道它里边是啥

04:52.810 --> 04:54.810
可能来自于别的开发者

04:54.810 --> 04:55.810
别的同事

04:55.810 --> 04:58.810
你的同事给你提供的这个变量

04:58.810 --> 04:59.810
或者是一个函数的参数

04:59.810 --> 05:01.810
你都不知道它是啥

05:01.810 --> 05:03.810
但是我希望它是一个数字

05:03.810 --> 05:04.810
我想把它转成数字

05:04.810 --> 05:05.810
那怎么办呢

05:05.810 --> 05:07.810
做一个非常简单的事

05:07.810 --> 05:09.810
可以给它直接乘一个1

05:09.810 --> 05:11.810
所以有个乘号

05:11.810 --> 05:12.810
这里写的是1没问题吧

05:12.810 --> 05:13.810
这个是一个乘号

05:13.810 --> 05:14.810
它期望什么

05:14.810 --> 05:16.810
期望它是一个数字

05:16.810 --> 05:19.810
它如果不是数字呢

05:19.810 --> 05:20.810
如果说不是数字

05:20.810 --> 05:22.810
是不是就把它转成数字

05:22.810 --> 05:23.810
对吧

05:23.810 --> 05:24.810
那这样子因为

05:24.810 --> 05:25.810
不管它转成什么数字

05:25.810 --> 05:26.810
乘1它始终等于它自身

05:26.810 --> 05:27.810
对吧

05:27.810 --> 05:28.810
所以说这样子的

05:28.810 --> 05:29.810
这个表达式

05:29.810 --> 05:30.810
它就一定返回一个数字

05:30.810 --> 05:31.810
它本来是2的

05:31.810 --> 05:32.810
你看

05:32.810 --> 05:33.810
它本来是一个字幅创2的

05:33.810 --> 05:34.810
这样这个表达式

05:34.810 --> 05:35.810
就是转换成数字

05:35.810 --> 05:36.810
所以我们经常就会写

05:36.810 --> 05:37.810
这样的代码

05:37.810 --> 05:38.810
比方说一个n

05:38.810 --> 05:40.810
我那个a不知道是啥

05:40.810 --> 05:41.810
但是我想把它转换成数字

05:41.810 --> 05:42.810
放到n里边

05:42.810 --> 05:43.810
那我怎么写呢

05:43.810 --> 05:45.810
就写个a乘1

05:45.810 --> 05:46.810
那么我看一下这个n

05:46.810 --> 05:47.810
是不是就得到

05:47.810 --> 05:49.810
它转成数字的结果了

05:49.810 --> 05:50.810
对吧

05:50.810 --> 05:53.810
就是一个非常奇妙的写法

05:53.810 --> 05:54.810
那我们也可以

05:54.810 --> 05:55.810
更加简洁的

05:55.810 --> 05:56.810
这样子来写

05:56.810 --> 05:58.810
一个加号n

05:58.810 --> 05:59.810
为什么呢

05:59.810 --> 06:00.810
因为加号放前边

06:00.810 --> 06:01.810
表示什么

06:01.810 --> 06:02.810
表示正数

06:02.810 --> 06:03.810
正什么

06:03.810 --> 06:04.810
正数

06:04.810 --> 06:06.810
是不是期望是数字

06:06.810 --> 06:07.810
不是数字就把它转

06:07.810 --> 06:08.810
就把它转成数字

06:08.810 --> 06:10.810
那么这个也是个表达式

06:10.810 --> 06:11.810
别看它这么短

06:11.810 --> 06:13.810
短就不是表达式了吗

06:13.810 --> 06:14.810
它真的是表达式

06:14.810 --> 06:16.810
把这个表达式的结果

06:16.810 --> 06:17.810
复制给n

06:17.810 --> 06:18.810
不是把a复制给n

06:18.810 --> 06:20.810
是把这个表达式的结果

06:20.810 --> 06:21.810
复制给n

06:21.810 --> 06:22.810
表达式什么意思

06:22.810 --> 06:24.810
表达式就是

06:24.810 --> 06:25.810
把它转成数字

06:25.810 --> 06:27.810
然后取个正号

06:27.810 --> 06:28.810
把它复制给n

06:28.810 --> 06:29.810
你看

06:29.810 --> 06:30.810
那么n就是1,2了

06:30.810 --> 06:31.810
你再看

06:31.810 --> 06:32.810
单独看这个表达式

06:32.810 --> 06:33.810
是不是得到结果

06:33.810 --> 06:34.810
也是一个数字的2

06:34.810 --> 06:35.810
所以说我们

06:35.810 --> 06:36.810
这种方式

06:36.810 --> 06:37.810
给一个变量

06:37.810 --> 06:38.810
前面加一个加号

06:38.810 --> 06:39.810
就可以强制的

06:39.810 --> 06:41.810
把它转成数字

06:41.810 --> 06:42.810
所以不是把变量

06:42.810 --> 06:43.810
本身转化

06:43.810 --> 06:44.810
是这个表达式就是一个数字的

06:44.810 --> 06:45.810
你再把这个表达式

06:45.810 --> 06:46.810
放到某一个地方

06:46.810 --> 06:48.810
当然你也可以直接

06:48.810 --> 06:49.810
给a重新复制

06:49.810 --> 06:50.810
对吧

06:50.810 --> 06:51.810
这样给a重新复制之后

06:51.810 --> 06:53.810
是不是a就变成数字了

06:53.810 --> 06:54.810
对吧

06:54.810 --> 06:55.810
现在a就变成数字了

06:55.810 --> 06:56.810
因为重新复制了

06:56.810 --> 06:57.810
懂了意思吧

06:57.810 --> 06:58.810
好

06:58.810 --> 06:59.810
这就是那个

06:59.810 --> 07:00.810
影视转化

07:00.810 --> 07:02.810
我们可以做的一件小事

07:02.810 --> 07:03.810
那么这就是个数字

07:03.810 --> 07:04.810
就算数运算这里

07:04.810 --> 07:06.810
我们可以值得一个

07:06.810 --> 07:07.810
比较小的地方

07:07.810 --> 07:08.810
这些东西不用去计

07:08.810 --> 07:09.810
原老师说

07:09.810 --> 07:11.810
这个东西还真的挺有用的

07:11.810 --> 07:14.810
要不要上个早自习

07:14.810 --> 07:15.810
其实你们上早自习

07:15.810 --> 07:16.810
上晚自习

07:16.810 --> 07:18.810
我心里边是特别舒服的

07:18.810 --> 07:20.810
因为我觉得你们学习

07:20.810 --> 07:21.810
积极性很高

07:21.810 --> 07:22.810
态度很好

07:22.810 --> 07:23.810
精神可嘉

07:23.810 --> 07:24.810
但是我有点害怕

07:24.810 --> 07:26.810
你又把它变成文科学习了

07:26.810 --> 07:27.810
什么历史

07:27.810 --> 07:28.810
政治要去背

07:28.810 --> 07:29.810
不要去背

07:29.810 --> 07:31.810
这个都没啥意义的

07:31.810 --> 07:32.810
那我怎么记得住了

07:32.810 --> 07:33.810
你多看老师的蛋吧

07:33.810 --> 07:35.810
我以后会做这种事情

07:35.810 --> 07:37.810
会做很多次的

07:37.810 --> 07:39.810
经常会做这种事情

07:39.810 --> 07:40.810
只要做到了

07:40.810 --> 07:41.810
原老师写了个蛋

07:41.810 --> 07:42.810
你慢慢印象就生了

07:42.810 --> 07:44.810
看到就想吐

07:44.810 --> 07:45.810
所以说这些东西

07:45.810 --> 07:47.810
我前面给大家说一下

07:47.810 --> 07:48.810
有点印象

07:48.810 --> 07:49.810
是可以这么去做的

07:49.810 --> 07:51.810
有点印象就可以了

07:51.810 --> 07:52.810
不用去使劲用备

07:52.810 --> 07:53.810
好吧

07:53.810 --> 07:55.810
我们先把这些过一遍

07:55.810 --> 07:56.810
过一遍我们再来做题

07:56.810 --> 07:58.810
然后第二个是制服社拼接

07:58.810 --> 08:00.810
他用的符号还是夹号

08:00.810 --> 08:01.810
夹号特别有意思

08:02.810 --> 08:04.810
夹号它看内行的

08:04.810 --> 08:05.810
就是左右两边是数字

08:05.810 --> 08:07.810
它就进行夹法

08:07.810 --> 08:09.810
那如果说两端有一个是制服串的话

08:09.810 --> 08:11.810
那就不再进行算数运算了

08:11.810 --> 08:13.810
变成制服串拼接了

08:13.810 --> 08:15.810
比方说你这里我用的是

08:15.810 --> 08:18.810
一个1加上一个2

08:20.810 --> 08:21.810
那么这个夹号

08:21.810 --> 08:22.810
它发现其中一端

08:22.810 --> 08:24.810
只要有一端是制服串

08:24.810 --> 08:26.810
它就变成了制服串拼接了

08:26.810 --> 08:28.810
就变成一个制服串拼接

08:28.810 --> 08:30.810
12它不是12

08:30.810 --> 08:31.810
是叫做制服串

08:31.810 --> 08:32.810
制服串怎么读的

08:32.810 --> 08:34.810
说过的一个制服一个制服去读

08:34.810 --> 08:36.810
12它不叫12

08:38.810 --> 08:39.810
好

08:39.810 --> 08:41.810
那么现在就是这么一个东西了

08:42.810 --> 08:43.810
就是制服串拼接

08:43.810 --> 08:45.810
那么这个制服串拼接也有一个

08:45.810 --> 08:47.810
我们也可以利用它这个特点

08:48.810 --> 08:50.810
然后来利用影视转换

08:50.810 --> 08:52.810
拿把一个东西转成制服串

08:52.810 --> 08:54.810
比方说我用一个变量N

08:54.810 --> 08:56.810
10

08:56.810 --> 08:58.810
那我想把它变成制服串怎么做呢

08:58.810 --> 08:59.810
非常简单

08:59.810 --> 09:01.810
我就把这个N加上一个空制服串

09:01.810 --> 09:03.810
由于夹号一端

09:03.810 --> 09:04.810
出现了一个制服串

09:04.810 --> 09:05.810
对吧

09:05.810 --> 09:07.810
它期望的就是它也得是一个制服串

09:07.810 --> 09:08.810
但它是不是制服串

09:08.810 --> 09:09.810
不是

09:09.810 --> 09:10.810
它就会把这个东西转成制服串

09:10.810 --> 09:12.810
是不是就是影视转换

09:12.810 --> 09:13.810
你看这个表达是

09:13.810 --> 09:15.810
是不是变成制服串的10

09:15.810 --> 09:16.810
当然这样子

09:16.810 --> 09:17.810
你可以给N重

09:17.810 --> 09:19.810
可以把这个表达是重新给N复制

09:19.810 --> 09:22.810
N就变成一个制服串的10

09:22.810 --> 09:24.810
也可以给它保存到另外一个变量

09:24.810 --> 09:25.810
都可以

09:26.810 --> 09:28.810
这就是利用制服串拼接

09:28.810 --> 09:30.810
我们可以做到一些小的技巧

09:30.810 --> 09:32.810
都不要去背

09:32.810 --> 09:34.810
有的这么点印象就可以了

09:34.810 --> 09:35.810
将来我们要用到的时候

09:35.810 --> 09:37.810
自然就会说

09:37.810 --> 09:39.810
好复制运算

09:39.810 --> 09:40.810
复制运算的自然就是等号

09:40.810 --> 09:42.810
加等于乘等于

09:42.810 --> 09:44.810
除等于 减等于

09:44.810 --> 09:46.810
百分号等于都要求予等于

09:46.810 --> 09:48.810
那么我们用的最多就是等号了

09:48.810 --> 09:50.810
就是把右边那个数据

09:50.810 --> 09:51.810
复制给左边那个变量

09:51.810 --> 09:52.810
这个东西没什么好说的

09:52.810 --> 09:54.810
那值得注意的是这个

09:54.810 --> 09:56.810
就是加等于

09:56.810 --> 09:57.810
它是什么意思呢?

09:57.810 --> 09:59.810
值得是A等于A加上

09:59.810 --> 10:00.810
后边一个小库号

10:00.810 --> 10:01.810
把后边的那些东西

10:01.810 --> 10:02.810
扩起来 啥意思啊?

10:02.810 --> 10:03.810
我举个例子

10:03.810 --> 10:05.810
比方说我有个变量A

10:05.810 --> 10:06.810
等于A3

10:06.810 --> 10:08.810
我要给它加上一个

10:09.810 --> 10:11.810
我要给它乘等于吧

10:11.810 --> 10:13.810
乘等于

10:14.810 --> 10:16.810
2

10:16.810 --> 10:18.810
加1

10:18.810 --> 10:19.810
那么这个玩意

10:19.810 --> 10:21.810
应该等于几呢?

10:21.810 --> 10:22.810
有时候要说

10:22.810 --> 10:24.810
A3应该是把它写成这种格式

10:24.810 --> 10:25.810
对吧?

10:25.810 --> 10:26.810
等于什么?

10:26.810 --> 10:28.810
等于A乘2加1

10:28.810 --> 10:30.810
那就是6加1等于7

10:30.810 --> 10:32.810
对吧?把7重新复制给A

10:32.810 --> 10:34.810
应该是这种结果

10:34.810 --> 10:35.810
A应该等于7

10:35.810 --> 10:36.810
那这样子写的话

10:36.810 --> 10:37.810
A肯定是等于7的

10:37.810 --> 10:39.810
但是实际上不是这样子的

10:39.810 --> 10:40.810
不是这样子的

10:40.810 --> 10:41.810
它是怎么回事呢?

10:41.810 --> 10:43.810
A乘等于

10:44.810 --> 10:45.810
2加1

10:45.810 --> 10:47.810
应该是这种格式

10:47.810 --> 10:49.810
它等下于这个

10:49.810 --> 10:50.810
A乘1

10:50.810 --> 10:52.810
后面这一坨要扩起来

10:52.810 --> 10:54.810
我说的就是这个意思

10:54.810 --> 10:55.810
把后面这一坨扩起来

10:55.810 --> 10:56.810
所以说等于什么?

10:56.810 --> 10:57.810
A乘等于3

10:57.810 --> 10:58.810
等于9

10:58.810 --> 11:00.810
我们来看一下吧

11:03.810 --> 11:05.810
乘等于2加1

11:05.810 --> 11:06.810
是不是等于9?

11:06.810 --> 11:08.810
对吧?这一点大家要

11:08.810 --> 11:10.810
给小细节大家注意一下

11:10.810 --> 11:12.810
等于这种格式

11:12.810 --> 11:14.810
乘等于乘等于

11:14.810 --> 11:16.810
都是这种格式

11:17.810 --> 11:18.810
对

11:18.810 --> 11:19.810
刚才算数一算

11:19.810 --> 11:20.810
还少说一个

11:20.810 --> 11:21.810
加加减减

11:21.810 --> 11:22.810
自身增益

11:22.810 --> 11:23.810
自身减移

11:24.810 --> 11:25.810
复制运算

11:25.810 --> 11:27.810
复制运算这里有一个小细节

11:27.810 --> 11:28.810
一个小贴视

11:28.810 --> 11:30.810
对我们开发是有

11:30.810 --> 11:32.810
有点影响的

11:32.810 --> 11:34.810
就是复制表达式

11:34.810 --> 11:36.810
它是个表达式

11:36.810 --> 11:38.810
是不是到复制表达式?

11:38.810 --> 11:39.810
复制也是表达式

11:39.810 --> 11:41.810
定义辨量不是

11:41.810 --> 11:42.810
这个是不是表达式?

11:42.810 --> 11:43.810
这个不是

11:43.810 --> 11:44.810
叫定义辨量

11:44.810 --> 11:45.810
同时复制

11:45.810 --> 11:47.810
我说是单单指复制

11:47.810 --> 11:49.810
比方说给a复制一个7

11:49.810 --> 11:50.810
对吧?

11:50.810 --> 11:51.810
那么这就是复制

11:51.810 --> 11:53.810
复制也是个表达式

11:53.810 --> 11:54.810
你看谷歌伦然期

11:54.810 --> 11:56.810
它会告诉你这个表达式的值

11:56.810 --> 11:58.810
表达式的值

11:58.810 --> 12:00.810
有些人说是不是就是a的值?

12:00.810 --> 12:01.810
不是的

12:01.810 --> 12:03.810
尽管它大部分情况下就是a的值

12:03.810 --> 12:05.810
表达式的值是什么?

12:05.810 --> 12:07.810
是指的是这个右边东西

12:07.810 --> 12:09.810
也有这个怎么来理解

12:09.810 --> 12:12.810
把7复制给辨量a

12:12.810 --> 12:13.810
这是一个表达式

12:13.810 --> 12:15.810
表达式的运算结果

12:15.810 --> 12:18.810
为后边这一坨7

12:18.810 --> 12:20.810
那么这个语差用了

12:20.810 --> 12:21.810
知道这个语差用了

12:21.810 --> 12:23.810
比方说我没有两个辨量

12:23.810 --> 12:26.810
a等于ab

12:26.810 --> 12:28.810
或者是三个四个都无所谓

12:28.810 --> 12:30.810
我想给a和b同时复制为7

12:30.810 --> 12:32.810
我可以这么写

12:32.810 --> 12:35.810
a等于b等于7

12:35.810 --> 12:36.810
哪里看?

12:36.810 --> 12:38.810
现在a7b也是7

12:38.810 --> 12:39.810
为什么?

12:39.810 --> 12:41.810
大家要这样看

12:41.810 --> 12:42.810
给a复制

12:42.810 --> 12:43.810
复制什么?

12:43.810 --> 12:46.810
复制这个表达式的运算结果

12:46.810 --> 12:48.810
不是把b复制给a

12:48.810 --> 12:49.810
不能这样去看

12:49.810 --> 12:52.810
是这个表达式的运算结果

12:52.810 --> 12:53.810
复制给a

12:53.810 --> 12:54.810
是这么个意思

12:54.810 --> 12:56.810
好,那么开始算这个表达式了

12:56.810 --> 12:58.810
这个表达式是怎么算的呢?

12:58.810 --> 12:59.810
我们来算这个表达式

12:59.810 --> 13:01.810
这个表达式这样算的

13:01.810 --> 13:03.810
把这个7先复制给b

13:03.810 --> 13:04.810
b是不是等于7了?

13:04.810 --> 13:05.810
这个没问题吧

13:05.810 --> 13:08.810
然后这个表达式的结果

13:08.810 --> 13:10.810
就整个这一坨

13:10.810 --> 13:11.810
是个表达式

13:11.810 --> 13:14.810
一加一,二加三都是表达式

13:14.810 --> 13:16.810
这个表达式会有一个结果

13:16.810 --> 13:18.810
任何表达式都有结果的

13:18.810 --> 13:19.810
这个表达式的结果是什么?

13:19.810 --> 13:20.810
就是右边这一坨

13:20.810 --> 13:22.810
这个表达式就是7

13:22.810 --> 13:24.810
然后再把这个7复制给a

13:24.810 --> 13:25.810
要这么去看

13:25.810 --> 13:26.810
知道吧

13:26.810 --> 13:28.810
那么最后说,a和b都是7了

13:28.810 --> 13:30.810
比方我们再来一个

13:30.810 --> 13:32.810
我现在有三个变量abc

13:32.810 --> 13:33.810
那是一样的

13:33.810 --> 13:36.810
a等于b,等于c,等于7

13:36.810 --> 13:37.810
那这个有什么理解呢?

13:37.810 --> 13:39.810
那不是一样的吧

13:39.810 --> 13:41.810
把这个表达式的结果

13:41.810 --> 13:42.810
复制给谁?

13:42.810 --> 13:43.810
复制给a

13:43.810 --> 13:45.810
那现在是不是要算这个表达式了?

13:45.810 --> 13:46.810
算这个表达式是怎么算的?

13:46.810 --> 13:49.810
是把这个表达式的结果

13:49.810 --> 13:50.810
复制给谁?

13:50.810 --> 13:51.810
复制给b

13:51.810 --> 13:52.810
对不对?

13:52.810 --> 13:53.810
是不是这个意思?

13:53.810 --> 13:55.810
好,又要算这个表达式

13:55.810 --> 13:58.810
那这个表达式是不是要把7复制

13:59.810 --> 14:02.810
把7复制给c

14:02.810 --> 14:03.810
对不对?

14:03.810 --> 14:05.810
好,那么7复制的c是不等于7了

14:05.810 --> 14:07.810
最先的比等于7的是c

14:08.810 --> 14:09.810
c等于7过后

14:09.810 --> 14:11.810
这个表达式算完了

14:11.810 --> 14:13.810
那么它的运算结果是什么?

14:13.810 --> 14:14.810
表达式的反馈结果

14:14.810 --> 14:16.810
就是右边的一坨是7

14:16.810 --> 14:18.810
所以这个表达式就等于7

14:18.810 --> 14:19.810
然后又是b

14:19.810 --> 14:21.810
把7复制给b

14:21.810 --> 14:23.810
7复制给b过后

14:23.810 --> 14:25.810
那么这个表达式的结果是多少?

14:25.810 --> 14:26.810
是不是右边的一坨?

14:26.810 --> 14:27.810
右边的一坨是多少?

14:27.810 --> 14:28.810
就是7

14:28.810 --> 14:30.810
然后再把7复制给a

14:30.810 --> 14:31.810
对吧?

14:31.810 --> 14:32.810
所以复制给a

14:32.810 --> 14:33.810
然后a有等于7了

14:33.810 --> 14:34.810
然后这也是一个表达式

14:34.810 --> 14:35.810
这个表达式的运算结果

14:35.810 --> 14:36.810
就是右边的一坨

14:36.810 --> 14:37.810
是不是有时7?

14:37.810 --> 14:38.810
就耳朵是套娃一样的

14:38.810 --> 14:39.810
又套娃了

14:39.810 --> 14:40.810
那你看

14:40.810 --> 14:41.810
谷歌鲁远区会告诉你

14:41.810 --> 14:42.810
这个也是个表达式

14:42.810 --> 14:44.810
这个表达式的运算结果为7

14:44.810 --> 14:45.810
懂得意思吗?

14:45.810 --> 14:46.810
其实我们写代码的时候

14:46.810 --> 14:47.810
倒是没有去想那么多

14:47.810 --> 14:48.810
但是只要知道

14:48.810 --> 14:49.810
至少一个分析的时候

14:49.810 --> 14:51.810
你要知道有什么个现象

14:51.810 --> 14:53.810
我们有的时候就会这样子写

14:53.810 --> 14:54.810
写的一个

14:54.810 --> 14:56.810
写一个连等

14:56.810 --> 14:57.810
比较连等

14:57.810 --> 14:59.810
就是连续复制

14:59.810 --> 15:00.810
练式复制

15:00.810 --> 15:02.810
就是把同一个复制给多个点量

15:02.810 --> 15:03.810
就可以这样子写

15:03.810 --> 15:04.810
但是注意

15:05.810 --> 15:06.810
不能有发的

15:09.250 --> 15:11.250
把写前面倒是可以

15:12.250 --> 15:14.250
把写前面倒是可以

15:14.250 --> 15:15.250
你看

15:16.250 --> 15:17.250
他告诉你这个表达式

15:17.250 --> 15:18.250
那没关系

15:18.250 --> 15:19.250
那我们这样子写倒是可以

15:19.250 --> 15:20.250
定一个变量

15:20.250 --> 15:22.250
A的值是多少呢

15:22.250 --> 15:24.250
把这个表达式复制过来

15:24.250 --> 15:25.250
这个表达式我们之前分析过了

15:25.250 --> 15:26.250
对吧

15:26.250 --> 15:27.250
就是7

15:27.250 --> 15:28.250
把7复制给A

15:28.250 --> 15:29.250
这个样子倒是可以

15:29.250 --> 15:30.250
但是呢

15:30.250 --> 15:32.250
你不能这样子写

15:32.250 --> 15:37.570
它又爆错了

15:37.570 --> 15:38.570
语法错误

15:38.570 --> 15:39.570
为什么呢

15:39.570 --> 15:41.570
因为这个玩意它不是表达式

15:41.570 --> 15:42.570
对不对

15:42.570 --> 15:43.570
它不是表达式

15:43.570 --> 15:44.570
等于啥

15:44.570 --> 15:45.570
等于这个表达式的结果

15:45.570 --> 15:46.570
但是它不是表达式

15:46.570 --> 15:47.570
它就爆错了

15:47.570 --> 15:48.570
它告诉你

15:48.570 --> 15:50.570
它就已经无法识别这个代码

15:50.570 --> 15:52.570
所以说这也要注意

15:52.570 --> 15:53.570
我们平时连连续复制的时候

15:53.570 --> 15:55.570
要么就是在最前面写个碗

15:55.570 --> 15:56.570
要么就是

15:57.570 --> 15:58.570
当最前面写个碗的话

15:58.570 --> 16:00.570
B和C都得提前定义

16:00.570 --> 16:01.570
好吧

16:01.570 --> 16:03.570
就是这个小技巧

16:03.570 --> 16:05.570
可以多给多个属性同性复制

16:05.570 --> 16:06.570
当然这样子

16:06.570 --> 16:07.570
我们只是给变量同时复制

16:07.570 --> 16:09.570
那给对象行不行

16:09.570 --> 16:11.570
给对象行不行

16:11.570 --> 16:13.570
比方说我们这一个对象

16:13.570 --> 16:14.570
OBG

16:14.570 --> 16:16.570
OBG1等于

16:16.570 --> 16:19.570
它是有一个N

16:19.570 --> 16:21.570
N等于2

16:21.570 --> 16:23.570
然后还有一个OBG2

16:23.570 --> 16:25.570
N等于3

16:25.570 --> 16:26.570
然后我想

16:26.570 --> 16:30.570
把OBG1的N和OBG2的N都变成10

16:30.570 --> 16:33.570
OBG1.N

16:33.570 --> 16:36.570
等于OBG2.N等于10

16:36.570 --> 16:37.570
这样子可不可以

16:37.570 --> 16:39.570
当然也是可以的

16:39.570 --> 16:41.570
没有任何问题

16:41.570 --> 16:42.570
我们可以想一想

16:42.570 --> 16:46.200
为什么没有任何问题

16:46.200 --> 16:47.200
为什么没有任何问题

16:47.200 --> 16:48.200
不一样的吗

16:48.200 --> 16:51.200
又啥区别呢

16:51.200 --> 16:52.200
把这个表达式的结果

16:52.200 --> 16:54.200
复制给对象的这个属性N

16:54.200 --> 16:57.200
复制给OBG1.N

16:57.200 --> 16:58.200
那是不是要算这个表达式

16:58.200 --> 16:59.200
这个表达式怎么算的

16:59.200 --> 17:01.200
把10复制给OBG2.N

17:01.200 --> 17:04.200
那么它是不是变10

17:04.200 --> 17:05.200
然后这个表达式的

17:05.200 --> 17:06.200
运算结果是什么

17:06.200 --> 17:07.200
运算结果就是10

17:08.200 --> 17:09.200
是不是右边这一坨

17:09.200 --> 17:10.200
运算结果就是10

17:10.200 --> 17:13.200
然后把10再复制给OBG1.N

17:13.200 --> 17:16.200
是一样的

17:16.200 --> 17:20.200
那么这是复制我要说的

17:20.200 --> 17:22.200
接下来是比较运算

17:22.200 --> 17:25.200
比较运算有大于小于

17:25.200 --> 17:26.200
大于等于小于等于

17:26.200 --> 17:27.200
这个没什么好说的

17:27.200 --> 17:28.200
主要说那个等

17:28.200 --> 17:29.200
相等和不相等

17:29.200 --> 17:31.200
相等和不相等有两种

17:31.200 --> 17:33.200
一种是两个等号的

17:33.200 --> 17:37.700
相等和一个等号的不相等

17:37.700 --> 17:38.700
还有另外一种是

17:38.700 --> 17:39.700
三个等号的相等

17:39.700 --> 17:42.700
和两个等号的不相等

17:42.700 --> 17:43.700
那么用哪一种呢

17:43.700 --> 17:46.700
永远不要用两个等号的相等

17:46.700 --> 17:47.700
和一个等号的不相等

17:47.700 --> 17:50.700
就这两个东西永远不要用

17:50.700 --> 17:52.700
永远永远没有任何情况

17:52.700 --> 17:54.700
你需要去用它

17:54.700 --> 17:57.700
除了面试体力不要会靠

17:57.700 --> 17:59.700
因此这一块的同学们记住

17:59.700 --> 18:01.700
我们目前的学习

18:01.700 --> 18:03.700
就是搞定我们平时开发中

18:03.700 --> 18:06.700
经常要用到的一些知识

18:06.700 --> 18:08.700
有一些知识是以后

18:08.700 --> 18:10.700
它纯粹就是面试里面

18:10.700 --> 18:12.700
要搞理的这种知识

18:12.700 --> 18:14.700
这种知识我们专门放到

18:14.700 --> 18:16.700
面试课程里面去做

18:16.700 --> 18:18.700
因为这些知识第一它繁琐

18:18.700 --> 18:20.700
第二它没什么用

18:20.700 --> 18:22.700
东西还多还复杂

18:22.700 --> 18:24.700
现在的同学们学习也是

18:24.700 --> 18:26.700
有些同学觉得复杂

18:26.700 --> 18:28.700
主要的原因就是因为

18:28.700 --> 18:30.700
我们太早的去搞定

18:30.700 --> 18:32.700
面试体力边的东西了

18:32.700 --> 18:33.700
太早了

18:33.700 --> 18:35.700
导致了就把这个事情搞得

18:35.700 --> 18:37.700
很麻烦很复杂

18:37.700 --> 18:42.680
其实我们人的

18:42.680 --> 18:44.680
不好意思

18:44.680 --> 18:46.680
其实呢这并不符合

18:46.680 --> 18:48.680
我们人类的学习习惯

18:48.680 --> 18:50.680
我们人类的都比较喜欢

18:50.680 --> 18:52.680
先来简单的慢慢慢慢

18:52.680 --> 18:54.680
再去加深这样子比较好的

18:54.680 --> 18:56.680
就好比说玩游戏的时候

18:56.680 --> 18:58.680
第一关的时候你都

18:58.680 --> 19:00.680
等级也没起来

19:00.680 --> 19:02.680
装备也没起来

19:02.680 --> 19:04.680
这个时候来一个最终Boss

19:04.680 --> 19:06.680
但是

19:06.680 --> 19:08.680
你如果说学到后边的时候

19:08.680 --> 19:10.680
装备起来了等级起来了

19:10.680 --> 19:12.680
打他跟爸爸打额子一样

19:12.680 --> 19:14.680
特别简单

19:14.680 --> 19:16.680
所以说很多问题到后边

19:16.680 --> 19:18.680
就变得很简单了

19:18.680 --> 19:20.680
因此我们没有必要太早的去

19:20.680 --> 19:22.680
接触这些

19:22.680 --> 19:24.680
像运算浮浙一块

19:24.680 --> 19:26.680
其实介石里面有很多很细的规则

19:26.680 --> 19:28.680
这些规则咱们以后的

19:28.680 --> 19:30.680
比面试里面都会去讲

19:30.680 --> 19:32.680
就专门来搞定面试体的

19:32.680 --> 19:34.680
假的不存在的

19:34.680 --> 19:36.680
不用就行了

19:36.680 --> 19:38.680
永远使用三个等号和

19:38.680 --> 19:40.680
这种方式来进行比较

19:40.680 --> 19:42.680
永远使用它

19:42.680 --> 19:44.680
没问题了吧

19:44.680 --> 19:46.680
比较运算这一块

19:46.680 --> 19:48.680
它有一个这么一个还有这么一个特点

19:48.680 --> 19:50.680
不管你用什么比较

19:50.680 --> 19:52.680
什么大鱼啊大鱼等于啊小鱼啊小鱼等于啊

19:52.680 --> 19:54.680
还有包括那个等号相等啊不相等

19:54.680 --> 19:56.680
都有这么一个特点

19:56.680 --> 19:58.680
始终返回不稳

19:58.680 --> 20:00.680
说的什么

20:00.680 --> 20:02.680
比较运算是个表达式

20:02.680 --> 20:04.680
它也是个表达式

20:04.680 --> 20:06.680
它一定返回不稳

20:06.680 --> 20:08.680
我带马文这里还写错了

20:08.680 --> 20:10.680
少了一个引号

20:12.680 --> 20:14.680
它一定返回的是一个不稳

20:14.680 --> 20:16.680
啥意思啊

20:16.680 --> 20:18.680
我们这里有一个一二小于七

20:18.680 --> 20:20.680
返回什么

20:20.680 --> 20:22.680
返回的这个表达式

20:22.680 --> 20:24.680
返回的一定是不稳

20:24.680 --> 20:26.680
或者是force

20:26.680 --> 20:28.680
哪怕你写这么一些东西

20:30.680 --> 20:32.680
换一个吧

20:32.680 --> 20:34.680
小鱼

20:34.680 --> 20:36.680
它返回的也是不稳

20:36.680 --> 20:38.680
当然这些东西它怎么运算呢

20:38.680 --> 20:40.680
现在我们不用管

20:40.680 --> 20:42.680
我们平时也不会去写这种代码

20:42.680 --> 20:44.680
将来比面试的时候再慢慢去细说它里面的规则

20:44.680 --> 20:46.680
这种规则是很细的

20:46.680 --> 20:48.680
总之这个表达式它一定返回的是不稳

20:48.680 --> 20:50.680
于是呢我们在写代码的时候呢

20:50.680 --> 20:52.680
有的时候啊

20:52.680 --> 20:54.680
这些东西呢现在大家有一个印象就行了

20:54.680 --> 20:56.680
将来我们写代码遇到的这些成绩的时候

20:56.680 --> 20:58.680
老师竟然会写一个优质的代码出来

20:58.680 --> 21:00.680
比方说我要

21:00.680 --> 21:02.680
有这么一段代码

21:02.680 --> 21:04.680
我有一个变量的sex

21:04.680 --> 21:06.680
男或者是女

21:06.680 --> 21:08.680
如果说它是男的话

21:08.680 --> 21:10.680
我要给这个对象的一个属性

21:10.680 --> 21:12.680
叫ease mail

21:12.680 --> 21:14.680
把它设为true

21:14.680 --> 21:16.680
如果说它不是男的话

21:16.680 --> 21:18.680
我要把这个属性设为force

21:18.680 --> 21:20.680
比方就有这么一个需求

21:20.680 --> 21:22.680
这只是代码中的一小段

21:22.680 --> 21:24.680
那这段代码就比较啰嗦

21:24.680 --> 21:26.680
它不是说不正确

21:26.680 --> 21:28.680
它还可以讨论这个代码

21:28.680 --> 21:30.680
到底相对于

21:30.680 --> 21:32.680
下面这个代码到底哪一种代码好

21:32.680 --> 21:34.680
这个是可以讨论的

21:34.680 --> 21:36.680
不是说只要简洁的就是好人

21:36.680 --> 21:38.680
它不一定的

21:38.680 --> 21:40.680
那只是它

21:40.680 --> 21:42.680
我们现在单说这里多说

21:42.680 --> 21:44.680
多说不一定是坏的

21:44.680 --> 21:46.680
但是如果说我们可以把它写得更加简洁的话

21:46.680 --> 21:48.680
是可以把它写成这种格式的

21:48.680 --> 21:50.680
为什么呢

21:50.680 --> 21:52.680
你这个属性不就是true和force吗

21:52.680 --> 21:54.680
这个表达式返回的

21:54.680 --> 21:56.680
一定是true和force

21:56.680 --> 21:58.680
它是比较运算

21:58.680 --> 22:00.680
它违处的时候我就给它复制为true

22:00.680 --> 22:02.680
它为force的时候我就给它复制为force

22:02.680 --> 22:04.680
那我不把这个表达式直接给它复制吗

22:04.680 --> 22:06.680
是不是可以这样子

22:06.680 --> 22:08.680
把这个表达式的运算结果

22:08.680 --> 22:10.680
直接给它复制不就完了吗

22:10.680 --> 22:12.680
它为true的时候它就给它复制为true

22:12.680 --> 22:14.680
它为force的时候就把force复制给它

22:14.680 --> 22:16.680
这就是更加简洁优大的代码

22:16.680 --> 22:18.680
有这么个印象就行了

22:20.680 --> 22:22.680
逻辑运算

22:22.680 --> 22:24.680
并且或者取反

22:24.680 --> 22:26.680
我们先来看取反

22:26.680 --> 22:28.680
取反的这个表达式它一定返回布尔

22:28.680 --> 22:30.680
这里就可以玩说花样出来了

22:32.680 --> 22:34.680
由于这个取反它一定返回的是布尔

22:34.680 --> 22:36.680
不管后边跟的是啥

22:36.680 --> 22:38.680
它期望的是什么

22:38.680 --> 22:40.680
期望的是后边跟的是布尔

22:40.680 --> 22:42.680
后边跟的是true它也返回force

22:42.680 --> 22:44.680
后边跟的是force它也返回true

22:44.680 --> 22:46.680
但是后边它有可能跟的是e

22:46.680 --> 22:48.680
它有可能跟的是123

22:48.680 --> 22:50.680
也有可能跟的是一个制服串

22:52.680 --> 22:54.680
那么遇到这种情况

22:54.680 --> 22:56.680
它会把这个东西

22:56.680 --> 22:58.680
转换成布尔来进行判定

22:58.680 --> 23:00.680
那么这里设有另外一个规则叫布尔判定

23:02.680 --> 23:04.680
有的时候我们需要布尔判定

23:04.680 --> 23:06.680
比方说什么时候呢比方说像这种情况

23:06.680 --> 23:08.680
它期望后边是一个布尔

23:08.680 --> 23:10.680
但它不是布尔它就要把这东西拿来进行

23:10.680 --> 23:12.680
布尔判定或者是有的时候判断里边

23:12.680 --> 23:14.680
判断里边这个地方可能写的

23:14.680 --> 23:16.680
不是布尔不是true

23:16.680 --> 23:18.680
force那么它需要把它

23:18.680 --> 23:20.680
判定为true还是force

23:20.680 --> 23:22.680
那么怎么判定呢

23:22.680 --> 23:24.680
非常简单就这种

23:24.680 --> 23:26.680
你只需要记force的情况就可以了

23:26.680 --> 23:28.680
这个需要记得

23:28.680 --> 23:30.680
它为force的时候它判定为force

23:30.680 --> 23:32.680
都没什么好说的

23:32.680 --> 23:34.680
它为now onDefand的时候也判定为force

23:34.680 --> 23:36.680
它为0的时候也判定为force

23:36.680 --> 23:38.680
它为nn的时候也判定为force

23:38.680 --> 23:40.680
它为空制布串的时候也判定为force

23:40.680 --> 23:42.680
其他情况下全部判定为true

23:42.680 --> 23:44.680
全部判定为true

23:44.680 --> 23:46.680
你只需要记住force就行了

23:47.680 --> 23:49.680
好了那么说到这儿呢

23:49.680 --> 23:50.680
我们就可以说到刚才的一个情况

23:50.680 --> 23:52.680
就是这个感叹号有什么用呢

23:52.680 --> 23:54.680
这个感叹号有的时候有这么一个作用

23:54.680 --> 23:56.680
就是我拿到随便哪一个东西啊

23:56.680 --> 23:58.680
比如说一个变量A

23:58.680 --> 24:00.680
一个对象

24:00.680 --> 24:02.680
我想把它转换成布尔我该怎么去转

24:02.680 --> 24:04.680
把它转成true和force

24:04.680 --> 24:06.680
该怎么去转

24:06.680 --> 24:08.680
我就可以利用这种情况

24:08.680 --> 24:10.680
我写个感叹号后边写个A

24:10.680 --> 24:12.680
是不是它就会对它进行布尔判定

24:12.680 --> 24:14.680
判定完了过后把它转换成相反的情况

24:14.680 --> 24:16.680
这个表达是否一定返回的是布尔

24:16.680 --> 24:18.680
只不过是相反的嘛

24:18.680 --> 24:20.680
它会true就返回force

24:20.680 --> 24:22.680
它会force就返回true

24:22.680 --> 24:24.680
这个表达是否一定返回的是布尔

24:24.680 --> 24:26.680
我再在前面再加一个感叹号

24:26.680 --> 24:28.680
那这是啥意思啊

24:28.680 --> 24:30.680
那你看第一个感叹号是针对谁

24:30.680 --> 24:32.680
针对后边这一坨

24:32.680 --> 24:34.680
后边是不是表达是

24:34.680 --> 24:36.680
把这个表达是取反

24:36.680 --> 24:38.680
反反得这么嘛

24:38.680 --> 24:40.680
双重缝定等于肯定嘛

24:40.680 --> 24:42.680
对不对

24:42.680 --> 24:44.680
那么把这个再取反

24:44.680 --> 24:45.680
是不是

24:45.680 --> 24:46.680
我就这个表达是

24:46.680 --> 24:48.680
就刚好是把它的布尔判定

24:48.680 --> 24:50.680
输出了true和force了

24:50.680 --> 24:52.680
我们就可以通过这个一段小代嘛

24:52.680 --> 24:54.680
就可以把任何一个数据

24:54.680 --> 24:56.680
转换成布尔

24:56.680 --> 24:58.680
把任何一个数据

24:58.680 --> 25:00.680
比方说我们这里

25:00.680 --> 25:02.680
转换个E就把E转换成布尔了

25:02.680 --> 25:04.680
转换成那个空置不出来

25:04.680 --> 25:06.680
把空置不出来转换成布尔了

25:06.680 --> 25:08.680
可以通过这么一个小技巧

25:08.680 --> 25:10.680
来完成这么一个操作

25:10.680 --> 25:12.680
OK 这是布尔判定

25:12.680 --> 25:14.680
这是那个逻辑运算

25:14.680 --> 25:16.680
好 逻辑运算这里呢

25:16.680 --> 25:18.680
还有一个要说的

25:18.680 --> 25:20.680
就是这个并且和或者

25:20.680 --> 25:22.680
并且和或者这里呢

25:22.680 --> 25:24.680
需要同学们要注意一下

25:24.680 --> 25:26.680
它是有短路规则的

25:26.680 --> 25:28.680
第一个并且

25:28.680 --> 25:30.680
我们先说它的含义

25:30.680 --> 25:32.680
并且就是真真为真

25:32.680 --> 25:34.680
两边都必须要为真

25:34.680 --> 25:36.680
一个为假都不行

25:36.680 --> 25:38.680
真真为真 其他为假

25:38.680 --> 25:40.680
它有短路规则

25:40.680 --> 25:42.680
什么叫短路规则

25:42.680 --> 25:44.680
就有的时候啊

25:44.680 --> 25:46.680
它不是两端吗

25:46.680 --> 25:48.680
它不是有两端吗

25:48.680 --> 25:50.680
左右左边的一端并且

25:50.680 --> 25:52.680
右边的一端

25:52.680 --> 25:54.680
对不对

25:54.680 --> 25:56.680
那左边的一端是一个数据

25:56.680 --> 25:58.680
右边的一端也是个数据

25:58.680 --> 26:00.680
那你到底是不是布尔无所谓

26:00.680 --> 26:02.680
反正我会进行布尔判定的

26:02.680 --> 26:06.310
你给我一个一二三

26:06.310 --> 26:08.310
我也会对它进行布尔判定

26:08.310 --> 26:10.310
这是forced的时候

26:10.310 --> 26:12.310
它有必要去判断右边那个吗

26:12.310 --> 26:14.310
没必要

26:14.310 --> 26:16.310
这叫短路规则

26:16.310 --> 26:18.310
左边那个

26:18.310 --> 26:20.310
如果说为forced

26:20.310 --> 26:22.310
就已经有一个为假了

26:22.310 --> 26:24.310
右边那个管它是真还是假

26:24.310 --> 26:26.310
是不是已经改变不了整个表达式的结果了

26:26.310 --> 26:28.310
对吧

26:28.310 --> 26:30.310
所以说它有这么一个短路规则

26:30.310 --> 26:32.310
这边前面

26:32.310 --> 26:34.310
已经可以确定结果了

26:34.310 --> 26:36.310
我就不需要判断后边了

26:36.310 --> 26:38.310
短路规则

26:38.310 --> 26:40.310
第二个

26:40.310 --> 26:42.310
它反回什么

26:42.310 --> 26:44.310
反回的应该是布尔

26:44.310 --> 26:46.310
不是的

26:46.310 --> 26:48.310
这一块并且和或者在GS语言里面

26:48.310 --> 26:50.310
其他语言不一样

26:50.310 --> 26:52.310
GS语言里面它反回的不是布尔

26:52.310 --> 26:54.310
不是的并且怎么样

26:54.310 --> 26:56.310
并且怎么样不是应该是真和假吗

26:56.310 --> 26:58.310
不是的

26:58.310 --> 27:00.310
它反回的不是布尔

27:00.310 --> 27:02.310
它反回的是最后一个判定的数据

27:02.310 --> 27:04.310
这是啥意思

27:04.310 --> 27:06.310
两个都为真

27:06.310 --> 27:08.310
一为真

27:08.310 --> 27:10.310
它看了左边那个一过后

27:10.310 --> 27:12.310
它为真了

27:12.310 --> 27:14.310
它要不要看后边那个

27:14.310 --> 27:16.310
这是并且必须要两个都为真

27:16.310 --> 27:18.310
它只看了一个还不行

27:18.310 --> 27:20.310
它为真了

27:20.310 --> 27:22.310
它最后一个看的数据是啥

27:22.310 --> 27:24.310
最后一个看的数据是2

27:24.310 --> 27:26.310
所以说这个表达式反回2

27:26.310 --> 27:28.310
这个表达式反回2

27:28.310 --> 27:30.310
那表达0并且2

27:30.310 --> 27:32.310
我们知道0判定为forced

27:32.310 --> 27:34.310
左边那个已经是forced了

27:34.310 --> 27:36.310
它不需要判定后边那个

27:36.310 --> 27:38.310
所以它最后一个判定的是谁

27:38.310 --> 27:40.310
最后一个判定的是这个数据

27:40.310 --> 27:42.310
于是它就反回这个数据

27:42.310 --> 27:44.310
反回0

27:44.310 --> 27:47.620
它有这么一个特点

27:47.620 --> 27:49.620
这是并且

27:49.620 --> 27:51.620
那么有时候就想问

27:51.620 --> 27:53.620
你再把我搞蒙了

27:53.620 --> 27:55.620
我们平时写的这么一副

27:55.620 --> 27:57.620
一副啥啥啥

27:57.620 --> 27:59.620
并且啥啥啥

27:59.620 --> 28:01.620
你说这里边这个表达式不是布尔

28:01.620 --> 28:03.620
它不一定是布尔

28:03.620 --> 28:05.620
那为什么可以做判断

28:05.620 --> 28:07.620
那我们来吧

28:07.620 --> 28:09.620
比方说这里就是1x2

28:09.620 --> 28:11.620
那看它怎么运算的

28:11.620 --> 28:13.620
这是个表达式

28:13.620 --> 28:15.620
它要先算这个表达式

28:15.620 --> 28:17.620
是不是要先算这个表达式

28:17.620 --> 28:19.620
这个表达式算出来是多少啊

28:19.620 --> 28:21.620
刚才说了

28:21.620 --> 28:23.620
并且2算出来是多少

28:23.620 --> 28:25.620
是不是2啊

28:25.620 --> 28:27.620
把2放到衣服里边能判断吗

28:27.620 --> 28:29.620
不还是能判断吧

28:29.620 --> 28:31.620
把2再进行布尔判定吗

28:31.620 --> 28:33.620
这也可以

28:33.620 --> 28:35.620
这也可以

28:35.620 --> 28:37.620
是没问题的

28:37.620 --> 28:39.620
其实最终的逻辑呢

28:39.620 --> 28:41.620
跟那个你把它当成反回的是布尔

28:41.620 --> 28:43.620
逻辑是一样的

28:43.620 --> 28:45.620
只是它反回的并不是布尔

28:45.620 --> 28:47.620
那么利用这一点

28:47.620 --> 28:49.620
前段开发者就是利用这个

28:49.620 --> 28:51.620
这些乱七八糟的特性了

28:51.620 --> 28:53.620
可以我说一些话出来

28:53.620 --> 28:55.620
比方说下面这种代码

28:55.620 --> 28:57.620
你看

28:57.620 --> 28:59.620
这个变量叫ESP

28:59.620 --> 29:01.620
一个表达式吧

29:01.620 --> 29:03.620
它如果说判定为真

29:03.620 --> 29:05.620
那我就输出OK

29:05.620 --> 29:07.620
就这么一个简单的功能

29:07.620 --> 29:09.620
那如果说我用衣服来写怎么写呢

29:09.620 --> 29:11.620
衣服它为真

29:11.620 --> 29:13.620
那我就输出这个东西

29:13.620 --> 29:15.620
这个逻辑没问题吧

29:15.620 --> 29:17.620
其实还有更简洁的写法

29:17.620 --> 29:19.620
就是它并且它

29:19.620 --> 29:21.620
这个有意思的

29:21.620 --> 29:23.620
为什么

29:23.620 --> 29:25.620
因为它为真的时候

29:25.620 --> 29:27.620
因为它有短路为辙

29:27.620 --> 29:29.620
它为真的时候

29:29.620 --> 29:31.620
它才会去判定它

29:31.620 --> 29:33.620
对不对

29:33.620 --> 29:35.620
那么这也是个表达式

29:35.620 --> 29:37.620
它也会去判定它

29:37.620 --> 29:39.620
也就是它才会运行这个代码

29:39.620 --> 29:41.620
就输出了

29:41.620 --> 29:43.620
它为假的时候

29:43.620 --> 29:45.620
是不是就不会运行这个代码

29:45.620 --> 29:47.620
所以说这里可以用这种方式

29:47.620 --> 29:49.620
来替代这个结构

29:49.620 --> 29:51.620
所以说有些简洁的

29:51.620 --> 29:53.620
就是比较简单的衣服

29:53.620 --> 29:55.620
是可以有很多的替代品的

29:55.620 --> 29:57.620
好 接下来是货责

29:57.620 --> 29:59.620
货责就刚好相反 假假为假

29:59.620 --> 30:01.620
比方两个都是假

30:01.620 --> 30:03.620
其他的为辙

30:03.620 --> 30:05.620
也有短路为辙

30:05.620 --> 30:07.620
也是一样 返回最后一个判定的数据

30:07.620 --> 30:09.620
那么这个东西我们可以做啥呢

30:09.620 --> 30:11.620
比如说有这么一个功能

30:11.620 --> 30:13.620
这些东西都不要去背

30:13.620 --> 30:15.620
我们以后做各种练习

30:15.620 --> 30:17.620
各种效果的时候

30:17.620 --> 30:19.620
用到了老师自然就会写这种代码

30:19.620 --> 30:21.620
然后你再去想一想

30:21.620 --> 30:23.620
现在有些有点盖

30:23.620 --> 30:25.620
现在有点那么一个印象就可以了

30:27.620 --> 30:29.620
实现功能

30:29.620 --> 30:31.620
重点就是每一颗的重点

30:31.620 --> 30:33.620
大家一定要抓住

30:33.620 --> 30:35.620
前面我只是让大家有点印象

30:35.620 --> 30:37.620
重点是最后的作业

30:37.620 --> 30:39.620
只要你能够把作业完成

30:39.620 --> 30:41.620
那就OK

30:41.620 --> 30:43.620
这一块就少干净了

30:43.620 --> 30:45.620
来看一下比方说

30:45.620 --> 30:47.620
没有这么一个功能

30:47.620 --> 30:49.620
如果说它有纸

30:49.620 --> 30:51.620
一个变量N

30:51.620 --> 30:53.620
这些东西都是以前就准备好的

30:53.620 --> 30:55.620
就是一段代码

30:55.620 --> 30:57.620
中间的这一段

30:57.620 --> 30:59.620
如果说没有纸就是L

30:59.620 --> 31:01.620
我就把N负纸为1

31:01.620 --> 31:03.620
这相当于是什么呢

31:03.620 --> 31:05.620
它有纸我就用它的纸

31:05.620 --> 31:07.620
它没有纸我就给它一个默认纸

31:07.620 --> 31:09.620
那么以前的写法

31:09.620 --> 31:11.620
得用一符L来写

31:11.620 --> 31:13.620
有了我们现在的这种想法过后

31:13.620 --> 31:15.620
以后你会经常在前段代码里面

31:15.620 --> 31:17.620
看到这种写法

31:17.620 --> 31:19.620
到处的是

31:19.620 --> 31:21.620
它有纸吗

31:21.620 --> 31:23.620
如果说它为真的话

31:23.620 --> 31:25.620
是不是由于短路规则

31:25.620 --> 31:27.620
或者只要有一个为真就可以了

31:27.620 --> 31:29.620
它为真的话是不是就直接

31:29.620 --> 31:31.620
反回它的纸

31:31.620 --> 31:33.620
这个表达是就直接反回它的纸

31:33.620 --> 31:35.620
不需要做后边的判定了

31:35.620 --> 31:37.620
就把它的纸负责给N

31:37.620 --> 31:39.620
如果它为假的话

31:39.620 --> 31:41.620
是不是才要判定后边的

31:41.620 --> 31:43.620
它为假的话

31:43.620 --> 31:45.620
那么找到它

31:46.620 --> 31:48.620
就形成了这么一个结果了

31:49.620 --> 31:51.620
反回来永远是最后一个判定的数据

31:53.620 --> 31:55.620
这就是非常常见

31:55.620 --> 31:57.620
这种做法就是付默认纸

31:57.620 --> 31:59.620
有纸我就用你

31:59.620 --> 32:01.620
没有纸我就用默认纸

32:03.620 --> 32:05.620
罗金运算这一块

32:05.620 --> 32:07.620
之前学习里面还没有设计到的

32:07.620 --> 32:09.620
就是一个三目运算

32:09.620 --> 32:11.620
这三目运算

32:11.620 --> 32:13.620
其实完全可以被义父代替

32:13.620 --> 32:15.620
像这些

32:15.620 --> 32:17.620
像这些都可以用义父来写

32:17.620 --> 32:19.620
包括我们这里学的三目运算

32:19.620 --> 32:21.620
就是义父这一块

32:21.620 --> 32:23.620
是完美的解决办法

32:23.620 --> 32:25.620
只是他有的时候没有那么简洁而已

32:27.620 --> 32:29.620
你用义父写一点问题都没有

32:29.620 --> 32:31.620
而且约读性来说

32:31.620 --> 32:33.620
上来说的话还更加好约读

32:33.620 --> 32:35.620
所以说同学们

32:35.620 --> 32:37.620
现阶段你可以说不习惯那种方式的

32:37.620 --> 32:39.620
你可以写义父L十种写法

32:39.620 --> 32:41.620
没问题没有任何问题

32:42.620 --> 32:44.620
只是别人要写了这种

32:44.620 --> 32:46.620
你要能知道他在写上

32:46.620 --> 32:48.620
老师很容易就写出来这种单码

32:51.320 --> 32:53.320
你看多了慢慢就回了

32:53.320 --> 32:55.320
这些东西你强行背什么用的

32:55.320 --> 32:57.320
好咱们看一下最后一个点

32:57.320 --> 32:59.320
三目运算符是什么意思呢

32:59.320 --> 33:01.320
就是如果为真

33:01.320 --> 33:03.320
比方说我要给一个东西复职

33:03.320 --> 33:06.320
如果为真那我就把它复职为一

33:06.320 --> 33:08.320
如果为假我就把它复职为二

33:08.320 --> 33:10.320
这是一个常见的需求

33:10.320 --> 33:12.320
更加简洁的单码是用三目运算

33:12.320 --> 33:14.320
三目运算的写法就是

33:14.320 --> 33:16.320
数据一问号

33:16.320 --> 33:18.320
数据二冒号数据三

33:18.320 --> 33:20.320
ABC就是数据

33:20.320 --> 33:22.320
既然是数据可以是字面量

33:22.320 --> 33:24.320
可以是辨量可以是表拉式

33:26.320 --> 33:28.320
就这个玩意儿为真吗

33:28.320 --> 33:30.320
有为真吗问号对吧

33:30.320 --> 33:32.320
为真的话我就整个表拉式就取B

33:32.320 --> 33:34.320
它为假的话我就取C

33:34.320 --> 33:36.320
就这个意思

33:36.320 --> 33:38.320
比方说我们这里写

33:38.320 --> 33:40.320
一问号

33:40.320 --> 33:42.320
2冒号

33:42.320 --> 33:44.320
3

33:44.320 --> 33:46.320
它为真吗

33:46.320 --> 33:48.320
我这个表拉式就是2

33:48.320 --> 33:50.320
它为假我这个表拉式就是3

33:50.320 --> 33:52.320
所以这个表拉式的结果目前是2

33:52.320 --> 33:54.320
那如果说是0

33:54.320 --> 33:56.320
问号2冒号3

33:56.320 --> 33:58.320
那这个表拉式的结果就是3

33:58.320 --> 34:00.320
就这个意思

34:00.320 --> 34:02.320
那就是三目运算

34:02.320 --> 34:04.320
其实你对照一下这个衣服判断的话

34:04.320 --> 34:06.320
就非常好理解

34:06.320 --> 34:08.320
好我们快速的把这些指数过了一遍

34:08.320 --> 34:10.320
过了一遍之后

34:10.320 --> 34:12.320
来做题

34:12.320 --> 34:14.320
这里有三道题

34:14.320 --> 34:18.400
需要完成

34:18.400 --> 34:20.400
第一道题每道题都是

34:20.400 --> 34:22.400
多少少少有一些难度的

34:22.400 --> 34:24.400
编写一个完美的

34:24.400 --> 34:26.400
求合函数

34:26.400 --> 34:28.400
函数还有点印象吧

34:28.400 --> 34:30.400
因为我用的函数很简单啊

34:30.400 --> 34:32.400
这一块应该不造成什么问题

34:32.400 --> 34:34.400
如果两个数据都是普通数字

34:34.400 --> 34:36.400
求合即可NN的数字要变

34:36.400 --> 34:38.400
就如果说我们一个

34:38.400 --> 34:40.400
简单的求合函数

34:40.400 --> 34:42.400
那就非常简单的A加B

34:42.400 --> 34:44.400
反回表拉式的结果

34:44.400 --> 34:46.400
比如说我们这里

34:46.400 --> 34:48.400
输出一个求合

34:48.400 --> 34:50.400
1 2

34:50.400 --> 34:52.400
函数交用也是表拉式

34:52.400 --> 34:54.400
这个表拉式是什么结果

34:54.400 --> 34:56.400
那这里反回了什么结果

34:56.400 --> 34:58.400
反回了A加B1加2就等于3

34:58.400 --> 35:00.400
所以说我们这里得到结果就是3

35:00.400 --> 35:02.400
这个没问题吧

35:02.400 --> 35:04.400
那万一我不是数字呢

35:04.400 --> 35:06.400
那万一我是制服窗呢

35:06.400 --> 35:08.400
是不是出问题了

35:08.400 --> 35:10.400
所以说我要得到一个完美的求合函数

35:10.400 --> 35:12.400
那怎么写呢

35:12.400 --> 35:14.400
它两个不是数字

35:14.400 --> 35:16.400
就要把它转成数字

35:16.400 --> 35:18.400
就要把它转成数字

35:18.400 --> 35:20.400
不是数字就要转成数字

35:20.400 --> 35:22.400
就这么个意思

35:22.400 --> 35:24.400
因此呢我就做这么一件事

35:24.400 --> 35:26.400
A等于什么

35:26.400 --> 35:28.400
加A

35:28.400 --> 35:30.400
B等于加B

35:30.400 --> 35:32.400
是不是

35:32.400 --> 35:34.400
我只要在前面写个加号

35:34.400 --> 35:36.400
是不是就是有一个隐视转弯

35:36.400 --> 35:38.400
它不是数字就强行把它转成数字

35:38.400 --> 35:40.400
对吧然后这样子一来的话

35:40.400 --> 35:42.400
你再看

35:42.400 --> 35:44.400
对不对

35:44.400 --> 35:46.400
这个没问题吧

35:46.400 --> 35:48.400
好那如果说

35:48.400 --> 35:50.400
我这个字不算是这样子的呢

35:50.400 --> 35:52.400
还变成NAN呢

35:52.400 --> 35:54.400
为什么呢因为像这种数据

35:54.400 --> 35:56.400
你把它转成

35:56.400 --> 35:58.400
数字转不了

35:58.400 --> 36:00.400
转不了就变成NAN了

36:00.400 --> 36:02.400
好那这里要求是什么

36:02.400 --> 36:04.400
NAN的数据需要变成0

36:06.400 --> 36:08.400
就这个玩意儿如果说转出来

36:08.400 --> 36:10.400
是NAN

36:10.400 --> 36:12.400
那我要把它变成0

36:12.400 --> 36:14.400
好那怎么写呢

36:14.400 --> 36:16.400
写判断可不可以

36:16.400 --> 36:18.400
当然可以啊

36:18.400 --> 36:20.400
我如何来判断NAN

36:20.400 --> 36:22.400
同学们如何判断NAN

36:22.400 --> 36:24.400
所以一个函数啊

36:24.400 --> 36:26.400
叫意思NAN

36:26.400 --> 36:28.400
通过它来判断

36:28.400 --> 36:30.400
它为真这个函数

36:30.400 --> 36:32.400
结果为真那么就表示

36:32.400 --> 36:34.400
它就是一个NAN

36:34.400 --> 36:36.400
NAN的情况下我把它复制为0

36:36.400 --> 36:38.400
B也是一样

36:38.400 --> 36:40.400
B如果说是NAN

36:40.400 --> 36:42.400
那么我要把B复制为0

36:42.400 --> 36:44.400
就是这样子可以

36:44.400 --> 36:46.400
印象

36:46.400 --> 36:48.400
它就变成0了

36:48.400 --> 36:50.400
但这样子写的未免有点多说

36:50.400 --> 36:52.400
我们可不可以有更加简洁的写法呢

36:52.400 --> 36:54.400
可以

36:54.400 --> 36:57.900
前面这个表达是

36:57.900 --> 36:59.900
这是个表达是吗

36:59.900 --> 37:01.900
这个表达是判定出来有可能是NAN

37:01.900 --> 37:03.900
对吧

37:03.900 --> 37:05.900
反正一定是变成数字了

37:05.900 --> 37:07.900
一定是变成数字了

37:07.900 --> 37:09.900
它有可能是NAN

37:09.900 --> 37:11.900
但是如果说是NAN

37:11.900 --> 37:13.900
它判定是不是Force

37:13.900 --> 37:15.900
判定为Force这是货者

37:15.900 --> 37:17.900
必须要两个得为假

37:17.900 --> 37:19.900
才能为假

37:19.900 --> 37:21.900
判定一个为Force还得不到结果

37:21.900 --> 37:23.900
因此要判定这个

37:23.900 --> 37:25.900
因此一判定这个

37:25.900 --> 37:27.900
这个就是最后一个判定

37:27.900 --> 37:29.900
反过来就是最后一个判定

37:29.900 --> 37:35.260
反回最后一个判定的数据

37:35.260 --> 37:37.260
那么这个表达是就返回0

37:37.260 --> 37:39.260
就是如果说它是NAN

37:39.260 --> 37:41.260
它就返回0

37:41.260 --> 37:43.260
如果它不是NAN

37:43.260 --> 37:45.260
它是正常数字

37:45.260 --> 37:47.260
那前面就判定为真

37:47.260 --> 37:49.260
为真的话就返回

37:49.260 --> 37:51.260
这个数字本身

37:51.260 --> 37:53.260
那这里是不是也一样

37:53.260 --> 37:55.260
这样子非常非常简洁

37:55.260 --> 37:57.260
这个代码

37:57.260 --> 37:59.260
这就是一个完美的球合寒书

37:59.260 --> 38:01.260
然后这个表达是

38:01.260 --> 38:03.260
或者这个表达是返回上的一搞动

38:03.260 --> 38:05.260
然后影视转换的就搞动了

38:05.260 --> 38:07.260
你把这个代码看懂

38:07.260 --> 38:09.260
所以说我们以负习这一块的知识

38:09.260 --> 38:11.260
我们以做题为最终目标

38:11.260 --> 38:13.260
你能把题做出来就OK

38:13.260 --> 38:15.260
下来去测试一下这个寒书

38:15.260 --> 38:17.260
就OK了

38:17.260 --> 38:19.260
第二题

38:19.260 --> 38:21.260
不使用衣服

38:21.260 --> 38:23.260
尽管用衣服其实这些

38:23.260 --> 38:25.260
都能做

38:25.260 --> 38:27.260
只不过这里要求你不使用衣服

38:27.260 --> 38:29.260
毕竟是集中练习

38:29.260 --> 38:31.260
判断一个年份

38:31.260 --> 38:33.260
是否是润年

38:33.260 --> 38:35.260
输出是或者是否

38:35.260 --> 38:37.260
那么润年的规则是什么呢

38:37.260 --> 38:39.260
就是要判断这个有个辩量

38:39.260 --> 38:41.260
要判断一个辩量是不是润年

38:41.260 --> 38:43.260
四年一润

38:43.260 --> 38:45.260
百年不润

38:45.260 --> 38:47.260
换成人话来说

38:47.260 --> 38:49.260
这其实就是人话

38:49.260 --> 38:51.260
换成我们代码的

38:51.260 --> 38:53.260
表达就是能备是整除

38:53.260 --> 38:55.260
四年一润说能备是整除

38:55.260 --> 38:57.260
再换成更加直白的一点

38:57.260 --> 38:59.260
就是什么呢

38:59.260 --> 39:01.260
换成更加直白一点

39:01.260 --> 39:03.260
条件一是什么

39:03.260 --> 39:05.260
条件一是除异

39:05.260 --> 39:07.260
除异

39:07.260 --> 39:09.260
四的余数

39:09.260 --> 39:11.260
为0

39:11.260 --> 39:13.260
对吧

39:13.260 --> 39:15.260
并且百年不润

39:15.260 --> 39:17.260
除异100的

39:17.260 --> 39:19.260
余数不为0

39:19.260 --> 39:21.260
不就是条件一吗

39:21.260 --> 39:23.260
就翻译成程序的语言

39:23.260 --> 39:25.260
好,第二条件是什么

39:25.260 --> 39:27.260
400年弊润

39:27.260 --> 39:29.260
除异400的余数

39:29.260 --> 39:31.260
为0

39:31.260 --> 39:33.260
上述2点满足

39:33.260 --> 39:35.260
起一就可以了

39:35.260 --> 39:37.260
你说这两个条件之间

39:37.260 --> 39:39.260
用什么

39:39.260 --> 39:41.260
他不就除异了吗

39:41.260 --> 39:43.260
条件一是什么

39:43.260 --> 39:45.260
条件一或者

39:45.260 --> 39:47.260
条件二

39:47.260 --> 39:49.260
两个条件满足任何一个

39:49.260 --> 39:51.260
那么都是润年

39:51.260 --> 39:53.260
你把写出来就不完了吗

39:53.260 --> 39:55.260
条件一是什么

39:55.260 --> 39:57.260
你搞不清楚

39:57.260 --> 39:59.260
由先级就扩一下

39:59.260 --> 40:01.260
这一坨条件

40:01.260 --> 40:03.260
后面条件二

40:03.260 --> 40:05.260
好,条件一是什么

40:05.260 --> 40:07.260
除异4的余数

40:09.260 --> 40:11.260
为0,三个等号

40:11.260 --> 40:13.260
永远不要使用两个等号

40:13.260 --> 40:15.260
并且

40:15.260 --> 40:17.260
除异100的

40:17.260 --> 40:19.260
余数

40:19.260 --> 40:21.260
不为0

40:21.260 --> 40:23.260
就条件一嘛

40:23.260 --> 40:25.260
好,条件二是什么

40:25.260 --> 40:27.260
除异400的余数为0

40:27.260 --> 40:29.260
你看不就写错了吗

40:29.260 --> 40:31.260
这个判定

40:31.260 --> 40:33.260
好,那我用个辩量来接受一下

40:33.260 --> 40:35.260
这个结果

40:35.260 --> 40:39.790
出书一下

40:39.790 --> 40:41.790
看一下是不是润年呢

40:41.790 --> 40:43.790
2000年是润年

40:43.790 --> 40:45.790
2020年是不是润年呢

40:45.790 --> 40:47.790
也是润年

40:47.790 --> 40:49.790
那

40:49.790 --> 40:53.230
2

40:53.230 --> 40:55.230
1900年呢

40:55.230 --> 40:57.230
他能被4整除,但是呢

40:57.230 --> 40:59.230
他百年不润

40:59.230 --> 41:01.230
他也能被100整除

41:01.230 --> 41:03.230
润年是不能被100整除的

41:03.230 --> 41:05.230
他又不能被400整除

41:05.230 --> 41:07.230
你看这个条件,他就不是润年

41:07.230 --> 41:09.230
但是我要求的是

41:09.230 --> 41:11.230
输出出何错是吗

41:11.230 --> 41:13.230
不是,我要求的是输出啥

41:13.230 --> 41:15.230
输出适合否

41:15.230 --> 41:17.230
那怎么办

41:17.230 --> 41:19.230
不能用判断哦

41:19.230 --> 41:21.230
那我是不是可以再来改一下

41:21.230 --> 41:23.230
瑞兆策等于

41:23.230 --> 41:25.230
那个三目一算福

41:25.230 --> 41:27.230
瑞兆策为真吗

41:27.230 --> 41:29.230
真的话我就试

41:29.230 --> 41:31.230
为假的话我就否

41:31.230 --> 41:33.230
他为真我就返回这个

41:33.230 --> 41:35.230
他为假我就返回这个

41:35.230 --> 41:37.230
然后把这个表达式的返回结果

41:37.230 --> 41:39.230
再重新给瑞兆策复制

41:39.230 --> 41:41.230
这样子不就是变成适合否了吗

41:41.230 --> 41:43.230
不,这里可以

41:43.230 --> 41:45.230
但是用衣服一点问题都没有

41:45.230 --> 41:47.230
用衣服砸血

41:47.230 --> 41:49.230
瑞兆策为真吗

41:49.230 --> 41:51.230
而且把它复制为是

41:51.230 --> 41:53.230
只不过招险有点啰嗦而已

41:53.230 --> 41:55.230
其实没有问题的

41:55.230 --> 41:58.800
但是你要认识这个弹

41:58.800 --> 42:00.800
个弹把它写出来,你至少得认识

42:00.800 --> 42:02.800
你写不写也是一回事

42:02.800 --> 42:04.800
你至少得认识

42:06.800 --> 42:08.800
好,那这种写法可以

42:08.800 --> 42:10.800
那我能不能,既然我只是做一下输出

42:10.800 --> 42:12.800
我能不能把这个表达式直接放这

42:12.800 --> 42:16.800
我要把这件事说到里吐

42:17.800 --> 42:19.800
这个地方是数据

42:19.800 --> 42:21.800
变量,质面量,表达式都可以

42:21.800 --> 42:23.800
把这个表达式的结果输出

42:23.800 --> 42:25.800
可不可以,当然也可以

42:28.800 --> 42:30.800
那我能不能这样子呢

42:30.800 --> 42:32.800
那这一坨是不是表达式

42:32.800 --> 42:34.800
别管它多长嘛

42:34.800 --> 42:36.800
它长上的天也是一个表达式嘛

42:36.800 --> 42:37.800
我把整个扩一下

42:37.800 --> 42:39.800
这个玩意是不是个表达式

42:39.800 --> 42:41.800
我预防优先级的问题

42:41.800 --> 42:43.800
把整个这个坨扩一下,扩起来

42:43.800 --> 42:45.800
这个是不是表达式

42:45.800 --> 42:47.800
这个表达式的结果为真的时候

42:47.800 --> 42:49.800
我是4,它为假的时候我是4

42:49.800 --> 42:51.800
那我把这个4和4保存到

42:51.800 --> 42:52.800
这个redouche里面

42:52.800 --> 42:53.800
是不是我这里直接可以输出

42:53.800 --> 42:54.800
输出redouche

42:54.800 --> 42:56.800
这样子可不可以,也可以呀

42:57.800 --> 42:59.800
三目运算符,这里不就是写

42:59.800 --> 43:01.800
数据1,数据2,数据3

43:01.800 --> 43:03.800
你管理这个数据是啥

43:03.800 --> 43:05.800
数据可以是变量,可以是质

43:05.800 --> 43:07.800
可以是变量,可以是质面量

43:07.800 --> 43:08.800
可以是表达式

43:08.800 --> 43:10.800
我放一个表达式,对吧,可以吗

43:10.800 --> 43:12.800
这个表达式的判定结果为真

43:12.800 --> 43:14.800
那就是4

43:14.800 --> 43:16.800
表达式的判定结果为假就是4

43:16.800 --> 43:18.800
能不能,当然可以

43:18.800 --> 43:20.800
那既然这样的话

43:20.800 --> 43:22.800
那我能不能把这一坨全部放到这呢

43:23.800 --> 43:25.800
为什么不可以呢

43:26.800 --> 43:28.800
为什么不可以呢

43:28.800 --> 43:30.800
这一块无非就把表达式的结果输出

43:30.800 --> 43:32.800
连变量都不需要

43:33.800 --> 43:35.800
活用表达式

43:36.800 --> 43:39.800
是一个非常非常重要的一个技能

43:40.800 --> 43:42.800
你的程序就不是死程序了

43:43.800 --> 43:45.800
你不是说只能按照老师的写法

43:45.800 --> 43:47.800
一点都不能变

43:47.800 --> 43:49.800
老师定一个变量就只能定一个变量

43:49.800 --> 43:51.800
老师定了两个变量就只能定两个变量

43:51.800 --> 43:53.800
就非常灵活了

43:53.800 --> 43:55.800
我要把这件事一定要说到底

43:57.800 --> 43:59.800
好,那么这就是这道题

43:59.800 --> 44:01.800
好,第三题

44:01.800 --> 44:06.650
不使用衣服

44:06.650 --> 44:08.650
根据身高体重,计算健康状况

44:08.650 --> 44:10.650
这道题呢

44:10.650 --> 44:12.650
还是一件有意义的事

44:13.650 --> 44:15.650
这里有一个规则

44:15.650 --> 44:17.650
这规则跟程序开发不关系

44:17.650 --> 44:19.650
但是是一个常识性的东西

44:19.650 --> 44:21.650
就是比如一些

44:21.650 --> 44:23.650
什么小小密手环之类的

44:23.650 --> 44:25.650
他可以判定健康状况

44:25.650 --> 44:27.650
根据身体,比如有些

44:27.650 --> 44:29.650
现在很少了

44:29.650 --> 44:30.650
以前呢

44:30.650 --> 44:32.650
街上有些什么电脑测身高

44:32.650 --> 44:34.650
电脑测健康

44:34.650 --> 44:36.650
他给你量个身高体重

44:36.650 --> 44:38.650
做个简单的运算就知道结果了

44:38.650 --> 44:40.650
那是怎么知道的呢

44:40.650 --> 44:42.650
是一个国际标准

44:42.650 --> 44:44.650
他是使用BMI

44:44.650 --> 44:45.650
来计算健康状况的

44:45.650 --> 44:47.650
BMI是怎么来得到的

44:47.650 --> 44:49.650
是体重处理身高的平方

44:51.650 --> 44:53.650
体重处理身高的平方

44:55.650 --> 44:56.650
那么注意单位

44:56.650 --> 44:57.650
体重的单位是千克

44:57.650 --> 44:59.650
身高的单位是米

44:59.650 --> 45:00.650
这样子得到

45:00.650 --> 45:01.650
是不是得到一个数据

45:01.650 --> 45:03.650
数字,对吧,BMI

45:03.650 --> 45:04.650
得到数字之后

45:04.650 --> 45:05.650
可以看这个数字的范围

45:05.650 --> 45:06.650
如果说这个数字

45:06.650 --> 45:07.650
在20到25之间

45:07.650 --> 45:09.650
那么就是正常的

45:09.650 --> 45:11.650
高于25就偏胖

45:11.650 --> 45:13.650
他就是这么算的

45:13.650 --> 45:14.650
现在有两个边量

45:14.650 --> 45:15.650
身高

45:15.650 --> 45:17.650
单位是厘米

45:18.650 --> 45:20.650
这里是千克

45:20.650 --> 45:21.650
这个没问题

45:21.650 --> 45:22.650
我把这个地方复始一下

45:22.650 --> 45:23.650
之前写的

45:24.650 --> 45:26.650
注解有点问题

45:26.650 --> 45:30.730
那你计算健康状况

45:30.730 --> 45:32.730
我们知道健康状况

45:32.730 --> 45:34.730
是不是来自于BMI

45:34.730 --> 45:35.730
对不对

45:35.730 --> 45:37.730
那么这里写上这么一个BMI

45:37.730 --> 45:38.730
计算,因为它是一个缩写

45:38.730 --> 45:40.730
所以说我们这里都全部大写

45:40.730 --> 45:42.730
这是个命名规范

45:42.730 --> 45:43.730
缩写就全部大写

45:43.730 --> 45:44.730
好,BMI

45:44.730 --> 45:45.730
它来自于哪呢

45:45.730 --> 45:46.730
是不是体重

45:46.730 --> 45:47.730
除以身高

45:47.730 --> 45:48.730
体重是什么位置

45:48.730 --> 45:49.730
注意单位哦

45:49.730 --> 45:50.730
它体重是什么

45:50.730 --> 45:51.730
千克

45:51.730 --> 45:52.730
这里体重就是千克

45:52.730 --> 45:53.730
那OK

45:53.730 --> 45:54.730
除以什么呢

45:54.730 --> 45:55.730
除以身高的平方

45:55.730 --> 45:57.730
好,身高的平方

45:57.730 --> 45:58.730
那么就身高

45:58.730 --> 45:59.730
注意它是米

45:59.730 --> 46:00.730
是不是得把它换算成米

46:01.730 --> 46:02.730
对吧

46:02.730 --> 46:03.730
那就是什么

46:03.730 --> 46:04.730
身高的平方

46:04.730 --> 46:05.730
本来应该是这样子写的

46:05.730 --> 46:06.730
成两次

46:06.730 --> 46:07.730
成两次就是平方

46:08.730 --> 46:09.730
但是呢

46:09.730 --> 46:12.730
由于它受单位的影响

46:12.730 --> 46:14.730
所以说每一个块

46:14.730 --> 46:16.730
要除一个一板

46:16.730 --> 46:17.730
是不是

46:17.730 --> 46:18.730
里面边米是不是要除一板

46:18.730 --> 46:21.230
对吧

46:21.230 --> 46:22.230
这样才平方

46:22.230 --> 46:24.230
顺便给大家说一下

46:24.230 --> 46:26.230
一个非常小的知识

46:26.230 --> 46:27.230
就是求平方这里

46:27.230 --> 46:28.230
你没有必要这样子写

46:29.230 --> 46:31.230
求平方这里可以这样子写

46:31.230 --> 46:32.230
二的三四方

46:34.230 --> 46:35.230
两个型号就可以了

46:35.230 --> 46:36.230
后面就是指数

46:36.230 --> 46:37.230
后面就是指数

46:37.230 --> 46:39.230
叫三的二四方

46:41.230 --> 46:42.230
三的三四方

46:43.230 --> 46:44.230
对,就可以这样子写

46:44.230 --> 46:45.230
所以说

46:45.230 --> 46:46.230
你要求平方的话

46:46.230 --> 46:47.230
完全可以这样

46:48.230 --> 46:49.230
成一二

46:49.230 --> 46:50.230
一保存

46:50.230 --> 46:51.230
其实它会把外面的

46:51.230 --> 46:52.230
扩号给你去掉

46:52.230 --> 46:53.230
因为这个

46:53.230 --> 46:55.230
这个优先级是高于乘除的

46:55.230 --> 46:56.230
求指数的优先级

46:56.230 --> 46:57.230
是高于乘除的

46:57.230 --> 46:58.230
就这个玩意的平方

46:58.230 --> 47:00.230
它除以这个玩意的平方

47:01.230 --> 47:02.230
就算出一个BMI

47:02.230 --> 47:03.230
你甚至可以输出一下

47:03.230 --> 47:05.230
看一下这个BMI

47:05.230 --> 47:06.230
目前是29

47:06.230 --> 47:08.230
29的话就应该是偏胖

47:09.230 --> 47:10.230
好,那么现在

47:10.230 --> 47:11.230
我们来计算建筒状况

47:11.230 --> 47:12.230
要输出这个

47:13.230 --> 47:14.230
是不是来三目运算

47:15.230 --> 47:17.230
BMI小于

47:19.230 --> 47:20.230
在20到25之间

47:20.230 --> 47:21.230
是不是

47:22.230 --> 47:23.230
大于等于20

47:24.230 --> 47:27.230
并且BMI小于等于25

47:28.230 --> 47:29.230
这个代码

47:29.230 --> 47:30.230
这个表达是

47:30.230 --> 47:31.230
是不是表达的就是

47:31.230 --> 47:32.230
20到25之间

47:32.230 --> 47:34.230
如果说这个判定为真

47:35.230 --> 47:36.230
这个判定为真

47:37.230 --> 47:38.230
那么

47:38.230 --> 47:39.230
就应该是什么了

47:39.230 --> 47:41.230
正常对不对

47:41.230 --> 47:43.230
剩下的是不是不正常

47:45.230 --> 47:46.230
是不是就不正常

47:46.230 --> 47:47.230
我们看一下

47:48.230 --> 47:49.230
输出一下

47:50.230 --> 47:54.340
是不是就不正常

47:54.340 --> 47:55.340
那现在就不正常

47:55.340 --> 47:57.340
那我们把个体重调小一点吧

47:57.340 --> 47:58.340
80公斤应该就正常了

48:00.340 --> 48:01.340
对吧

48:01.340 --> 48:02.340
这就是

48:02.340 --> 48:03.340
不正常正常

48:03.340 --> 48:04.340
那不正常里面

48:04.340 --> 48:05.340
我不要的

48:05.340 --> 48:06.340
不是不正常

48:06.340 --> 48:07.340
我要是偏瘦偏胖

48:08.340 --> 48:10.340
那么这里边是不是又有情况了

48:11.340 --> 48:12.340
那这里有咋写

48:14.840 --> 48:15.840
三目运算

48:15.840 --> 48:16.840
无非就是个表达师

48:16.840 --> 48:17.840
这个表达师为真

48:17.840 --> 48:18.840
我就取这个的结果

48:19.840 --> 48:20.840
这个为假

48:20.840 --> 48:22.840
我就取这边这一坨的结果

48:22.840 --> 48:23.840
这一边这一坨

48:23.840 --> 48:24.840
可以是字面量

48:24.840 --> 48:25.840
目前就是字面量

48:25.840 --> 48:26.840
可以是变量

48:26.840 --> 48:27.840
这边这一坨

48:27.840 --> 48:28.840
能不能是个表达师

48:29.840 --> 48:30.840
也可以

48:30.840 --> 48:32.840
任何可以写数据的地方

48:32.840 --> 48:34.840
都可以写字面量变量表达师

48:35.840 --> 48:36.840
那这里我完全可以写个表达师

48:38.840 --> 48:40.840
那表达师

48:40.840 --> 48:41.840
那就是啥意思

48:41.840 --> 48:42.840
他为真

48:42.840 --> 48:43.840
我就取这个字面量正常

48:43.840 --> 48:45.840
返回给他

48:45.840 --> 48:46.840
他为假

48:46.840 --> 48:49.840
我就取这个表达师的运算结果

48:49.840 --> 48:50.840
管他这个表达师是啥

48:50.840 --> 48:51.840
反正他总有个结果

48:51.840 --> 48:53.840
所有的表达师都有结果

48:53.840 --> 48:55.840
把这个表达师的结果给他复制

48:56.840 --> 48:57.840
那这个表达师不可以写上

48:57.840 --> 48:59.840
不可以再写个三目运算

49:00.840 --> 49:02.840
BMI小于20

49:02.840 --> 49:04.840
那我就是偏瘦

49:05.840 --> 49:07.840
尽管这里其实用

49:08.840 --> 49:10.840
判断EOS衣服更好

49:11.840 --> 49:13.840
代码其实更加清爽

49:13.840 --> 49:15.840
但是我就要让你们念这个表达师

49:15.840 --> 49:17.840
表达师的概念是特别重要的

49:17.840 --> 49:18.840
偏怕

49:22.110 --> 49:23.110
他其实把扩号给你去

49:23.110 --> 49:24.110
然后告诉你优先级没问题

49:24.110 --> 49:25.110
就是你这里加了扩号

49:25.110 --> 49:27.110
就是有些格式化程序

49:27.110 --> 49:29.110
像我一个电脑上按了个格式化程序

49:29.110 --> 49:30.110
你加了扩号

49:30.110 --> 49:31.110
因为你担心优先级的问题

49:31.110 --> 49:32.110
但是他分不清楚

49:32.110 --> 49:33.110
我就是扩一下

49:33.110 --> 49:35.110
这是个表达师扩一下

49:35.110 --> 49:36.110
但是他一保算

49:36.110 --> 49:37.110
他就把扩号去了

49:37.110 --> 49:38.110
他告诉你没问题

49:38.110 --> 49:39.110
你不用扩

49:39.110 --> 49:41.110
他知道这个优先级

49:41.110 --> 49:42.110
那就没问题了

49:42.110 --> 49:43.110
那我们再来看个代码

49:44.110 --> 49:45.110
他为真

49:45.110 --> 49:46.110
我就取这个

49:48.110 --> 49:49.110
他为假

49:49.110 --> 49:51.110
我就取这个表达师的运算结果

49:51.110 --> 49:52.110
这个表达师是不是要算

49:52.110 --> 49:54.110
那么这个表达师他就算

49:54.110 --> 49:55.110
他就按照他的逻辑算

49:55.110 --> 49:56.110
小于20就偏瘦

49:56.110 --> 49:57.110
否则的话就偏烫

49:59.110 --> 50:00.110
对吧

50:00.110 --> 50:01.110
因为正常的情况

50:01.110 --> 50:02.110
就是20到25已经去掉了

50:02.110 --> 50:04.110
那么除了小于20之外

50:04.110 --> 50:05.110
那只能是偏胖

50:06.110 --> 50:07.110
那这样子没问题

50:08.110 --> 50:09.110
现在是偏胖

50:09.110 --> 50:11.110
那50公斤那肯定是偏瘦了

50:12.110 --> 50:13.110
那我这样子可以把他

50:13.110 --> 50:14.110
保存到边量里面

50:14.110 --> 50:16.110
我能不能直接在这里输出呢

50:16.110 --> 50:17.110
可不可以呢

50:17.110 --> 50:18.110
也可以

50:19.110 --> 50:20.110
这是表达师的威力

50:20.110 --> 50:22.110
任何可以写数据的地方

50:22.110 --> 50:23.110
都可以写边量

50:23.110 --> 50:25.110
字面量表达师

50:25.110 --> 50:26.110
突了没

50:26.110 --> 50:27.110
还没拖击

50:27.110 --> 50:28.110
后面还有很多

50:29.110 --> 50:31.110
OK 那么这就是这一块东西

50:31.110 --> 50:33.110
这些可能时间有点长

50:33.110 --> 50:35.110
然后东西有点多

50:35.110 --> 50:36.110
技巧有点多

50:36.110 --> 50:38.110
但是大家主要关心的

50:38.110 --> 50:39.110
就是这三道题

50:40.110 --> 50:41.110
你可以下来过后

50:42.110 --> 50:43.110
不用看我这个文档

50:44.110 --> 50:46.110
这文档本来也是给你们查閱用的

50:46.110 --> 50:48.110
没有让你们一句话一句话去读

50:49.110 --> 50:50.110
一做题

50:51.110 --> 50:52.110
做不出来

50:52.110 --> 50:53.110
可以看一下我提的一块讲解

50:53.110 --> 50:54.110
你把题做出来了

50:54.110 --> 50:56.110
能理解的这些题了

50:56.110 --> 50:57.110
那就OK了

50:58.110 --> 50:59.110
这一块就少干净了

51:00.110 --> 51:02.110
这就是关于数据的运算

51:03.110 --> 51:05.110
其实我们大部分时候

51:05.110 --> 51:06.110
数据运算这一块

51:06.110 --> 51:07.110
都用的是非常简单的运算

51:07.110 --> 51:08.110
做个假法

51:08.110 --> 51:09.110
做个惩罚

51:09.110 --> 51:10.110
做个制服说要拼接

51:10.110 --> 51:11.110
用的是比较简单的

51:12.110 --> 51:13.110
简单的我就没有必要

51:13.110 --> 51:14.110
去让你们练的

51:14.110 --> 51:15.110
你们肯定是会的

51:15.110 --> 51:16.110
我一定是让你们练

51:16.110 --> 51:18.110
你们不太常见的

51:18.110 --> 51:19.110
不简单的

51:19.110 --> 51:20.110
因为那一块

51:20.110 --> 51:21.110
你们以后遇到了

51:21.110 --> 51:22.110
就会出问题

51:22.110 --> 51:24.110
所以我一定要让你们去练这一块

51:25.110 --> 51:26.110
OK

51:26.110 --> 51:27.110
好 就这一块的知识

51:27.110 --> 51:28.110
把题做一下

