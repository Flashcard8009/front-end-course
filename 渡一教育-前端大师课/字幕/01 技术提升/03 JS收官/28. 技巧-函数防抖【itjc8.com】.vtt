WEBVTT

00:00.180 --> 00:03.880
这些课我们聊一聊在将来的开发当中

00:03.880 --> 00:05.980
经常会遇到的一个问题

00:05.980 --> 00:10.980
以及针对这个问题我们先有的最优的一个解决办法

00:10.980 --> 00:14.380
首先看问题吧 比方说这里有个文笨框

00:14.380 --> 00:18.380
假设我们输入一些文字 我这里就没做了

00:18.380 --> 00:22.380
下面会列出一个联想的搜索

00:22.380 --> 00:25.180
像一些搜索引擎是不是经常这么干 对吧

00:25.180 --> 00:28.180
你前面写一小段文字 下面给你列出

00:28.180 --> 00:31.180
有可能你想搜索的东西 那么就是联想

00:31.180 --> 00:37.180
那么这个联想搜索可能会耗费一定的网络传输

00:37.180 --> 00:41.180
需要跟网络进行通信 将来你们会学习网络通信

00:41.180 --> 00:45.180
总之它会做一些比较费事的一些操作

00:45.180 --> 00:48.180
那么针对这个功能我们应该怎么去写呢

00:48.180 --> 00:51.180
我们很有可能就会这样写

00:51.180 --> 00:55.180
给这个文笨框注册一个点击实践

00:55.180 --> 00:57.180
拿到这个文笨框

01:04.180 --> 01:08.180
然后给这个文笨框去注册一个实践

01:08.180 --> 01:11.180
叫做key棒的实践

01:11.180 --> 01:14.180
当键盘按下的时候出发的实践

01:14.180 --> 01:16.180
或者是key up 都行

01:16.180 --> 01:19.180
无所谓 跟我们讲的事情没有直接的关系

01:19.180 --> 01:23.180
然后在这里边去做一些费事的操作

01:23.180 --> 01:26.180
拥护按键

01:26.180 --> 01:29.180
拥护有按键

01:29.180 --> 01:33.180
把目前这个字打印出来

01:33.180 --> 01:39.180
然后再打印一下耗实操作

01:39.180 --> 01:41.180
要做一些耗实的操作

01:41.180 --> 01:43.180
好 咱们来看一下目前这个例子

01:43.180 --> 01:45.180
它到底会有什么样的问题

01:45.180 --> 01:47.180
我们打开控制台

01:47.180 --> 01:48.180
然后找到console

01:48.180 --> 01:50.180
我们在这里边去按键

01:51.180 --> 01:53.180
你看一下

01:53.180 --> 01:55.180
这个事件出发多少次

01:55.180 --> 01:58.180
是不是触发了非常多的次数

01:58.180 --> 02:01.180
拥护的输入可能很快

02:01.180 --> 02:03.180
拥护的输入很快

02:03.180 --> 02:05.180
我们这个事件就不停的触发

02:05.180 --> 02:09.180
就不停的去造成这种耗实的操作

02:09.180 --> 02:10.180
但是你会发现

02:10.180 --> 02:12.180
在实际的应用当中

02:12.180 --> 02:15.180
很多次的操作是没有意义的

02:15.180 --> 02:17.180
你看 像我们最终

02:17.180 --> 02:18.180
用户写完了过后

02:18.180 --> 02:21.180
我们只需要最终的那个结果

02:21.180 --> 02:22.180
也就是说

02:22.180 --> 02:26.180
只需要最后一次操作的结果就行了

02:26.180 --> 02:28.180
前辈的这些触发

02:28.180 --> 02:31.180
这些执行是没有意义的

02:31.180 --> 02:32.180
懂的意思吗

02:32.180 --> 02:34.180
好 这是其中一个例子

02:34.180 --> 02:35.180
这个例子里边

02:35.180 --> 02:37.180
我们可以得出一个现象

02:37.180 --> 02:39.180
就是我们有的时候

02:39.180 --> 02:43.180
雕用某一个函数是非常频繁的

02:43.180 --> 02:46.180
像这个keyup时间

02:46.180 --> 02:48.180
这个函数的执行是不是非常频繁

02:48.180 --> 02:50.180
反复的执行

02:50.180 --> 02:54.180
但是很前辈的执行都没有意义

02:54.180 --> 02:57.180
只有最后一次执行有意义

02:57.180 --> 02:59.180
那么这个时候

02:59.180 --> 03:00.180
我们就可能要

03:00.180 --> 03:02.180
想一个办法来解决这个问题了

03:02.180 --> 03:05.180
因为前辈做了很多无意义的操作

03:05.180 --> 03:07.180
好 咱们再来一个例子

03:07.180 --> 03:10.180
像这种触发非常频繁的事件

03:10.180 --> 03:12.180
还不仅仅是keyup

03:12.180 --> 03:13.180
还包括

03:13.180 --> 03:16.180
我们给它做出一个mouse move

03:16.180 --> 03:20.770
我们再按一下

03:22.770 --> 03:26.140
好 来 你看

03:26.140 --> 03:28.140
我们鼠标在页面上移动的时候

03:28.140 --> 03:31.140
是不是不停地在触发这个mouse move的事件

03:31.140 --> 03:33.140
那么也就意味着

03:33.140 --> 03:35.140
不停地运行这个函数

03:35.140 --> 03:37.140
如果说这个函数

03:37.140 --> 03:40.140
它里边做了一些耗时的操作

03:40.140 --> 03:42.140
同时前辈的操作没有意义

03:42.140 --> 03:45.140
只有最后一次执行有意义

03:45.140 --> 03:47.140
是不是这种场景跟前面的这个

03:47.140 --> 03:49.140
keyup的个事件的场景

03:49.140 --> 03:51.140
是不是一样的

03:51.140 --> 03:53.140
好 咱们再来看一个例子

03:53.140 --> 03:55.140
就是一个实际的效果了

03:55.140 --> 03:56.140
这个效果的同学们

03:56.140 --> 03:58.140
之后也会进行制作

03:58.140 --> 04:01.140
刷新 这是一个铺步留步局

04:01.140 --> 04:03.140
你们将来会学习如何来制作

04:03.140 --> 04:05.140
它需要用到介石代码

04:05.140 --> 04:06.140
我现在就告诉你

04:06.140 --> 04:09.140
这里边我写好了一个函数

04:09.140 --> 04:11.140
叫做layout

04:11.140 --> 04:13.140
我们把

04:14.140 --> 04:15.140
页面说小

04:15.140 --> 04:17.140
页面说小了过后

04:17.140 --> 04:19.140
这个布局是不是就不太合适

04:19.140 --> 04:21.140
对不对 需要重新布局

04:21.140 --> 04:23.140
那么我写好了一个函数

04:23.140 --> 04:25.140
叫做layout

04:25.140 --> 04:27.140
这个函数我首先告诉你

04:27.140 --> 04:29.140
是一个非常耗时的函数

04:29.140 --> 04:31.140
但是你只要一调用它

04:31.140 --> 04:33.140
整个页面就重新布局了

04:33.140 --> 04:35.140
布局成更舒服的样子了

04:35.140 --> 04:37.140
更加适合这个窗口的大小

04:37.140 --> 04:40.140
那么如果说我们要完成这个

04:40.140 --> 04:42.140
它随着窗口的尺寸变动

04:42.140 --> 04:45.140
而自动重新布局的功能的话

04:45.140 --> 04:46.140
那么我们应该做怎么做呢

04:46.140 --> 04:49.140
我们需要在介石代码里边去写一段

04:49.140 --> 04:51.140
就是监听

04:51.140 --> 04:53.140
Windows ADD

04:53.140 --> 04:56.140
监听窗口尺寸变化的时间

04:56.140 --> 04:58.140
它叫resize

04:58.140 --> 04:59.140
你没学过 我现在就告诉你

04:59.140 --> 05:00.140
它叫resize

05:00.140 --> 05:01.140
窗口尺寸一变动

05:01.140 --> 05:03.140
它就会触发这个时间

05:03.140 --> 05:04.140
咱们来看一下

05:04.140 --> 05:07.140
我们写一个函数

05:07.140 --> 05:12.740
打印resize

05:12.740 --> 05:14.740
来 打开控制台

05:14.740 --> 05:16.740
现在我们窗口尺寸变动

05:16.740 --> 05:18.740
你看 所以不停的触发

05:18.740 --> 05:20.740
对吧 我不停的变动

05:20.740 --> 05:21.740
不停的变动

05:21.740 --> 05:23.740
它不停的触发

05:23.740 --> 05:25.740
那么如果说我在这里边

05:25.740 --> 05:27.740
去调用resize

05:27.740 --> 05:28.740
叫layout函数

05:28.740 --> 05:30.740
是不是能够重新布局

05:30.740 --> 05:31.740
窗口尺寸变化了

05:31.740 --> 05:32.740
我重新布局

05:32.740 --> 05:33.740
没问题吧

05:33.740 --> 05:34.740
刚才我们试过了

05:34.740 --> 05:35.740
一调这个函数

05:35.740 --> 05:36.740
我写好的

05:36.740 --> 05:37.740
你不用管它里边写的它

05:37.740 --> 05:38.740
反正比较耗时

05:38.740 --> 05:39.740
来 走

05:39.740 --> 05:41.740
我们来看一下能不能重新布局

05:41.740 --> 05:43.740
是不是可以重新布局

05:43.740 --> 05:44.740
但是这个函数

05:44.740 --> 05:46.740
是不是运行了非常多的次数

05:46.740 --> 05:48.740
我们这里可以打印一下

05:48.740 --> 05:52.740
运行了layout

05:52.740 --> 05:54.740
来 走

05:54.740 --> 05:56.740
你看 是不是运行了很多次

05:56.740 --> 05:58.740
我这里录屏还有点卡

05:58.740 --> 05:59.740
如果说电脑不卡的话

05:59.740 --> 06:00.740
它运行了次数更多

06:00.740 --> 06:02.740
但是实际上

06:02.740 --> 06:04.740
我们需不需要

06:04.740 --> 06:05.740
前边那些重新布局

06:05.740 --> 06:06.740
不需要

06:06.740 --> 06:09.740
我们只需要用户停下来过后

06:09.740 --> 06:11.740
最后的一次重新布局

06:11.740 --> 06:13.740
因为前面的布局没有意义

06:13.740 --> 06:15.740
停下来过后再进行布局

06:15.740 --> 06:16.740
不行吗

06:16.740 --> 06:18.740
你看这三个场景

06:18.740 --> 06:20.740
无论是这个文奔框也好

06:20.740 --> 06:23.740
还是这个鼠标移动也好

06:23.740 --> 06:24.740
还是这个

06:24.740 --> 06:26.740
我们实际的重新布局

06:26.740 --> 06:27.740
这个效果也好

06:27.740 --> 06:29.740
这个resize的事件也好

06:29.740 --> 06:30.740
它都在说明一个

06:30.740 --> 06:31.740
共同的道理

06:31.740 --> 06:33.740
就是第一个

06:33.740 --> 06:36.740
有一件非常耗时的操作

06:36.740 --> 06:38.740
这是第一个前提

06:38.740 --> 06:39.740
这操作很好使

06:39.740 --> 06:41.740
不好使的话就无所谓了

06:41.740 --> 06:43.740
多次运行就多次运行没无所谓

06:43.740 --> 06:45.740
因为不好使的操作

06:45.740 --> 06:46.740
不会造成卡顿

06:46.740 --> 06:48.740
不会浪费资源

06:48.740 --> 06:50.740
第一操作很好使

06:50.740 --> 06:52.740
第二呢

06:52.740 --> 06:54.740
前面的操作没有意义

06:54.740 --> 06:56.740
只有最后一次才有意义

06:56.740 --> 06:58.740
就前面密集的执行

06:58.740 --> 06:59.740
没有意义的

06:59.740 --> 07:01.740
那么造成了浪费

07:01.740 --> 07:03.740
当这两个条件

07:03.740 --> 07:05.740
同时满足的时候

07:05.740 --> 07:07.740
我们就可以想一种手段

07:07.740 --> 07:08.740
来进行解决

07:08.740 --> 07:09.740
这种手段就叫做

07:09.740 --> 07:11.740
寒树防斗

07:11.740 --> 07:15.690
寒树防斗

07:15.690 --> 07:17.690
注意啊前提条件我再说一次

07:17.690 --> 07:19.690
你不要今天学到寒树防斗过后

07:19.690 --> 07:20.690
所有的事件

07:20.690 --> 07:21.690
什么mouse move事件啊

07:21.690 --> 07:23.690
input事件

07:23.690 --> 07:24.690
全都来了

07:24.690 --> 07:25.690
来这种东西

07:25.690 --> 07:26.690
不要这样子

07:26.690 --> 07:27.690
我一定是

07:27.690 --> 07:29.690
两个条件同时满足

07:29.690 --> 07:30.690
第一个

07:30.690 --> 07:32.690
一个寒树的操作很好使

07:32.690 --> 07:33.690
第二个

07:33.690 --> 07:34.690
寒树频繁触发

07:34.690 --> 07:36.690
但是前面的触发没有意义

07:36.690 --> 07:37.690
前面的执行没意义

07:37.690 --> 07:39.690
只有

07:39.690 --> 07:41.690
最后一次有意义

07:41.690 --> 07:43.690
那么就可以使用寒树防斗

07:43.690 --> 07:45.690
寒树防斗是做什么事呢

07:45.690 --> 07:46.690
首先寒树防斗

07:46.690 --> 07:48.690
无法解决

07:48.690 --> 07:51.690
寒树被密集执行的问题

07:51.690 --> 07:52.690
都解决不了的

07:52.690 --> 07:53.690
你看这个事件

07:53.690 --> 07:54.690
它频繁触发

07:54.690 --> 07:55.690
哪里怎么办呢

07:55.690 --> 07:56.690
这是浏览器的机制啊

07:56.690 --> 07:58.690
像瑞塞尔事件也好

07:58.690 --> 07:59.690
这个trp

07:59.690 --> 08:00.690
或者是input事件啊

08:00.690 --> 08:02.690
也是文本改变的事件也好

08:02.690 --> 08:04.690
还是这个mouse move事件

08:04.690 --> 08:05.690
这是浏览器决定的

08:05.690 --> 08:06.690
它如何触发

08:07.690 --> 08:08.690
但是呢

08:08.690 --> 08:11.690
我们可以把耗时的操作延迟

08:11.690 --> 08:13.690
就是说

08:13.690 --> 08:16.690
每一次调用一个寒树的时候

08:16.690 --> 08:17.690
调用某一个寒树

08:17.690 --> 08:20.690
我先暂时不执行那些耗时的操作

08:20.690 --> 08:21.690
我先延后等一下

08:21.690 --> 08:22.690
万一后边还要来了

08:22.690 --> 08:23.690
对吧

08:23.690 --> 08:24.690
我稍微等一下

08:24.690 --> 08:25.690
等个一秒钟吧

08:25.690 --> 08:27.690
比方说时间可以设置

08:27.690 --> 08:28.690
等个一秒钟

08:28.690 --> 08:29.690
这一秒钟之内

08:29.690 --> 08:31.690
这个寒树又要执行了

08:31.690 --> 08:32.690
那我之前的耗时操作

08:32.690 --> 08:34.690
我就取消掉了

08:34.690 --> 08:36.690
再重新等一秒钟

08:36.690 --> 08:38.690
有点像那个电梯关门

08:38.690 --> 08:40.690
哪个人等三秒

08:40.690 --> 08:41.690
三秒没人了

08:41.690 --> 08:42.690
我就电梯关门

08:42.690 --> 08:43.690
三秒钟有人来了

08:43.690 --> 08:45.690
重新计时

08:45.690 --> 08:46.690
然后再等三秒

08:46.690 --> 08:48.690
有点那个意思

08:48.690 --> 08:49.690
这个寒树运行了

08:49.690 --> 08:51.690
但是耗时操作我先不做

08:51.690 --> 08:52.690
我等一会

08:52.690 --> 08:53.690
那一会在等的过程中

08:53.690 --> 08:55.690
如果说又运行了这个寒树

08:55.690 --> 08:57.690
又想要做耗时操作

08:57.690 --> 08:58.690
那之前就不等了

08:58.690 --> 09:00.690
我再重新计时一段时间

09:00.690 --> 09:02.690
直到等了一段时间过后

09:02.690 --> 09:04.690
再也没有调用这个寒树了

09:04.690 --> 09:06.690
说明用户停下来了

09:06.690 --> 09:07.690
那么这个时候

09:07.690 --> 09:08.690
我再去执行耗时操作

09:08.690 --> 09:10.690
能懂这个意思吗

09:10.690 --> 09:12.690
那么这个寒树防斗的

09:12.690 --> 09:13.690
具体大一码该怎么写呢

09:13.690 --> 09:15.690
它就是写一个寒树

09:15.690 --> 09:19.060
叫做Dibons

09:19.060 --> 09:21.060
Dibons

09:21.060 --> 09:23.060
就是防斗的意思

09:23.060 --> 09:24.060
这个寒树的功能

09:24.060 --> 09:27.060
是你传入一个寒树心来

09:27.060 --> 09:28.060
也给我传一个寒树

09:28.060 --> 09:30.060
寒树是可以作为参数的

09:30.060 --> 09:32.060
上级课是不是已经见过了

09:33.060 --> 09:35.060
你给我传一个寒树心来

09:35.060 --> 09:38.060
然后给我传一个延迟时间进来

09:40.060 --> 09:42.060
我假设这个寒树已经写好了

09:42.060 --> 09:43.060
到时候我怎么用呢

09:43.060 --> 09:45.060
你看着我就这么用

09:45.060 --> 09:46.060
我这个寒树

09:46.060 --> 09:48.060
是不是执行了一些耗时的操作

09:48.060 --> 09:49.060
对吧

09:49.060 --> 09:51.060
那么我把这个寒树

09:51.060 --> 09:53.060
用这种方式来输写

09:53.060 --> 09:54.060
你看是不是

09:54.060 --> 09:56.060
第一个参数传入一个寒树

09:56.060 --> 09:57.060
把这个寒树

09:57.060 --> 09:59.060
作为参数传到这儿来了

09:59.060 --> 10:00.060
然后第二个参数

10:00.060 --> 10:02.060
我给它传一个时间

10:02.060 --> 10:04.060
比方说有

10:04.060 --> 10:06.060
两秒钟吧

10:06.060 --> 10:08.060
两秒钟之内

10:08.060 --> 10:09.060
没有操作了

10:09.060 --> 10:12.060
那么才运行这个寒树

10:12.060 --> 10:13.060
就这个意思

10:13.060 --> 10:14.060
那么这个滴帮使呢

10:14.060 --> 10:16.060
它会给我返回一个新的寒树

10:18.060 --> 10:19.060
一个新的寒树

10:19.060 --> 10:20.060
叫做牛

10:20.060 --> 10:21.060
我随便取个名字吧

10:21.060 --> 10:22.060
叫牛hander

10:23.060 --> 10:24.060
我到时候呢

10:24.060 --> 10:25.060
事件触发的时候

10:25.060 --> 10:27.060
运行的是这个新的寒树

10:29.570 --> 10:30.570
懂这意思吗

10:30.570 --> 10:31.570
那么到时候事件

10:31.570 --> 10:33.570
因迫者事件它是频繁触发

10:33.570 --> 10:34.570
但触发的不再是运行

10:34.570 --> 10:35.570
原来这个寒树了

10:35.570 --> 10:37.570
运行的是新的寒树

10:37.570 --> 10:38.570
新的寒树呢

10:38.570 --> 10:39.570
会帮我们进行等待

10:39.570 --> 10:41.570
只有倒达两秒钟

10:41.570 --> 10:42.570
都没有进行

10:42.570 --> 10:44.570
任何的触发的时候

10:44.570 --> 10:46.570
才会运行这个寒树

10:46.570 --> 10:47.570
它就要做这么一件事

10:47.570 --> 10:48.570
我们先把一个搞定

10:48.570 --> 10:50.570
正常全搞定了

10:50.570 --> 10:51.570
那么接下来就是这个

10:51.570 --> 10:53.570
滴帮使寒树该如何写

10:53.570 --> 10:54.570
这也是面试的时候

10:54.570 --> 10:55.570
经常温刀了

10:55.570 --> 10:56.570
所以说这一会儿

10:56.570 --> 10:57.570
一定要会写

10:57.570 --> 10:58.570
目前呢

10:58.570 --> 11:00.570
还没有学习ES6

11:00.570 --> 11:01.570
那么学习了ES6

11:01.570 --> 11:02.570
还要更简洁的写法

11:02.570 --> 11:04.570
到时候同学们学了ES6过后

11:04.570 --> 11:05.570
自己把它改成简洁的写法

11:05.570 --> 11:06.570
就完事了

11:06.570 --> 11:08.570
我就用ES5来写

11:08.570 --> 11:10.570
那么怎么来写

11:10.570 --> 11:11.570
首先我们可以看到

11:11.570 --> 11:12.570
这个寒树呢

11:12.570 --> 11:13.570
接下来两个寒树

11:13.570 --> 11:14.570
一个是寒树

11:14.570 --> 11:15.570
就是要执行的浩式寒树

11:15.570 --> 11:18.570
第二个呢是延迟时间

11:18.570 --> 11:19.570
它要返回什么

11:19.570 --> 11:21.570
返回一个新的寒树

11:21.570 --> 11:22.570
所以我们return的是什么

11:22.570 --> 11:24.570
return的是一个新的寒树

11:25.570 --> 11:27.570
这个结构没问题吧

11:27.570 --> 11:28.570
给我一个寒树

11:28.570 --> 11:29.570
给我一个等待时间

11:29.570 --> 11:31.570
我给你返回一个新的寒树

11:31.570 --> 11:32.570
那么来接收

11:32.570 --> 11:33.570
将来呢

11:33.570 --> 11:34.570
要运行的是什么

11:34.570 --> 11:35.570
运行的不再是

11:35.570 --> 11:37.570
原来那个寒树了

11:37.570 --> 11:38.570
运行的是这个寒树

11:38.570 --> 11:41.570
这个寒树是不能有浩式操作的

11:41.570 --> 11:43.570
不能有特别浩式的操作在里面

11:43.570 --> 11:46.570
它浩式操作在这里面

11:46.570 --> 11:47.570
一定要认识清楚啊

11:47.570 --> 11:48.570
这是返回以后

11:48.570 --> 11:50.570
要执行的新的寒树

11:50.570 --> 11:52.570
那么这个寒树要做什么呢

11:52.570 --> 11:53.570
这个寒树不就是

11:53.570 --> 11:55.570
要等待一段时间

11:55.570 --> 11:57.570
才去运行它吗

11:57.570 --> 11:58.570
对不对

11:58.570 --> 11:59.570
所以说呢

11:59.570 --> 12:00.570
我们这里可以写出这么一个代码

12:00.570 --> 12:02.570
叫set timeout

12:02.570 --> 12:04.570
等待一小会

12:04.570 --> 12:05.570
等待多久呢

12:05.570 --> 12:07.570
是不等待这个寒树的参数

12:07.570 --> 12:09.570
你指定了一段时间过后

12:09.570 --> 12:11.570
我再去运行

12:11.570 --> 12:12.570
运行什么

12:12.570 --> 12:14.570
运行这个fn

12:14.570 --> 12:15.570
我们一点一点来写啊

12:15.570 --> 12:17.570
写这个寒树并不瀑散

12:17.570 --> 12:18.570
第一次听呢

12:18.570 --> 12:19.570
可能觉得很绕

12:19.570 --> 12:20.570
后面呢

12:20.570 --> 12:21.570
你写习惯了

12:21.570 --> 12:23.570
拿这个突然写的非常简单了

12:23.570 --> 12:24.570
没问题吧

12:24.570 --> 12:26.570
我是不是可以这样子写

12:26.570 --> 12:28.570
等待一段时间

12:28.570 --> 12:30.570
再去运行你这个fn这个寒树

12:30.570 --> 12:32.570
好

12:32.570 --> 12:34.570
然后我们这样子写了之后啊

12:34.570 --> 12:35.570
我们来看一下

12:35.570 --> 12:36.570
目前是什么情况的

12:36.570 --> 12:38.570
我们就看这个input时间啊

12:38.570 --> 12:39.570
目前运行的是哪个寒树

12:39.570 --> 12:41.570
运行的是这个对吧

12:41.570 --> 12:43.570
但是呢它没有立即执行

12:43.570 --> 12:44.570
这个耗时操作

12:44.570 --> 12:46.570
而是等了一段时间再去执行

12:46.570 --> 12:47.570
好 咱们看一下

12:49.570 --> 12:54.100
好 不在这里写啊

12:54.100 --> 12:56.100
是不是执行了还是很多次啊

12:56.100 --> 12:58.100
所以有很多次

12:58.100 --> 12:59.100
哎 但是呢你会发现

12:59.100 --> 13:00.100
这些触发啊

13:00.100 --> 13:01.100
这些寒树的执行啊

13:01.100 --> 13:03.100
是不是被延迟了

13:03.100 --> 13:05.100
好 延迟的功能是搞定了

13:05.100 --> 13:07.100
还没有立即触发耗时操作

13:07.100 --> 13:08.100
但是最终呢

13:08.100 --> 13:10.100
执行的次数是没变的

13:10.100 --> 13:12.100
你这里触发了八次

13:12.100 --> 13:14.100
我希望了就最后一次生效

13:14.100 --> 13:15.100
我不要八次都生效

13:15.100 --> 13:17.100
你八次给我等待了

13:17.100 --> 13:18.100
等待了两秒钟

13:18.100 --> 13:19.100
然后八次全部重新运行

13:19.100 --> 13:21.100
哎 有啥意义呢

13:21.100 --> 13:23.100
那这又怎么办呢

13:23.100 --> 13:25.100
哎 我们可以这样

13:25.100 --> 13:27.100
这个C Timeout的寒树啊

13:27.100 --> 13:29.100
它每一次会反 雕用过后

13:29.100 --> 13:31.100
会返回一个ID

13:31.100 --> 13:33.100
就是TimeoutID

13:34.100 --> 13:37.110
我们在这里呢

13:37.110 --> 13:38.110
可以定一个变量

13:38.110 --> 13:40.110
在上面定一个变量

13:40.110 --> 13:41.110
这样保证

13:41.110 --> 13:42.110
为什么要在上面定义

13:42.110 --> 13:43.110
不在里边定义呢

13:43.110 --> 13:45.110
你如果说在里边定义的话

13:45.110 --> 13:47.110
每一次触发这个事件

13:47.110 --> 13:48.110
雕用这个寒树

13:48.110 --> 13:50.110
都是一个新的ID的

13:50.110 --> 13:51.110
懂了意思吧

13:51.110 --> 13:53.110
因为为什么要定在外面

13:53.110 --> 13:54.110
是因为我每一次

13:54.110 --> 13:55.110
雕这个寒树的时候

13:55.110 --> 13:56.110
说明啥

13:56.110 --> 13:59.110
说明有新的操作进来了

13:59.110 --> 14:02.110
之前的就不要等了

14:02.110 --> 14:03.110
之前的你看

14:03.110 --> 14:04.110
第一次雕用的寒树的时候

14:04.110 --> 14:05.110
只等待两秒钟

14:05.110 --> 14:07.110
然后执行这个耗时操作

14:07.110 --> 14:09.110
它可能还在等待期间

14:09.110 --> 14:11.110
又雕了这个寒树一次

14:11.110 --> 14:12.110
那么就

14:12.110 --> 14:13.110
那这个寒树就告诉他

14:13.110 --> 14:15.110
之前的不要再等了

14:15.110 --> 14:17.110
Clear Timeout

14:17.110 --> 14:19.940
那么我

14:19.940 --> 14:22.940
我再后再去产生一个新的等待

14:22.940 --> 14:23.940
有同学说

14:23.940 --> 14:24.940
这个玩意呢

14:24.940 --> 14:25.940
我其实呢

14:25.940 --> 14:26.940
也可以把它放到一个判断里边

14:26.940 --> 14:27.940
他们ID有值

14:27.940 --> 14:29.940
就是之前说明有等待的时候

14:29.940 --> 14:30.940
我才清楚

14:30.940 --> 14:31.940
没有等待我就不用清楚了

14:31.940 --> 14:32.940
都无所谓的

14:32.940 --> 14:34.940
反正没有等待的清楚的话

14:34.940 --> 14:35.940
它就不会

14:35.940 --> 14:36.940
它不会有任何的效果

14:36.940 --> 14:37.940
也不会爆出

14:37.940 --> 14:38.940
你这样写也可以

14:38.940 --> 14:39.940
懂了意思吧

14:39.940 --> 14:40.940
再来一次

14:40.940 --> 14:42.940
这一块可能有点绕

14:42.940 --> 14:43.940
触发事件

14:43.940 --> 14:44.940
运行这个寒树

14:44.940 --> 14:45.940
第一次运行

14:45.940 --> 14:47.940
之前不要等了

14:47.940 --> 14:48.940
我来重新计格时

14:48.940 --> 14:49.940
计时到了过后

14:49.940 --> 14:50.940
运行这个寒树

14:50.940 --> 14:51.940
好

14:51.940 --> 14:52.940
马上又触发了这个事件

14:52.940 --> 14:53.940
触发的很频繁

14:53.940 --> 14:54.940
触发这个事件

14:54.940 --> 14:55.940
一触发告诉他

14:55.940 --> 14:56.940
之前的不用等了

14:56.940 --> 14:57.940
你看一清楚

14:57.940 --> 14:59.940
是不是之前的等待就失销了

14:59.940 --> 15:01.940
之前的这个FN就不会运行了

15:01.940 --> 15:02.940
然后这一次

15:02.940 --> 15:03.940
我又重新计格时

15:03.940 --> 15:05.940
又再去等待一段时间

15:05.940 --> 15:06.940
到了这儿

15:06.940 --> 15:07.940
只有到什么时候呢

15:07.940 --> 15:08.940
没有再调用这个寒树了

15:08.940 --> 15:10.940
有段时间没有再调用了

15:10.940 --> 15:11.940
时间到了

15:11.940 --> 15:13.940
它运行最后一次的FN

15:13.940 --> 15:14.940
就这么个逻辑

15:14.940 --> 15:16.940
好 咱们看一下

15:16.940 --> 15:20.080
两秒钟

15:20.080 --> 15:21.080
你看

15:21.080 --> 15:22.080
是不是只触发了一次了

15:22.080 --> 15:23.080
这就好多了

15:23.080 --> 15:24.080
好 接下来

15:24.080 --> 15:26.080
我们再来修饰它的细节

15:26.080 --> 15:28.080
首先到这里打印了安迪凡

15:28.080 --> 15:30.080
为什么会打印一个安迪凡呢

15:30.080 --> 15:32.080
是因为这里用到了Z

15:32.080 --> 15:33.080
对吧

15:33.080 --> 15:35.080
这个寒树里边用到了Z

15:35.080 --> 15:38.080
那么现在这个寒树里边的Z指向

15:38.080 --> 15:39.080
出了问题

15:39.080 --> 15:40.080
为什么出了问题

15:40.080 --> 15:41.080
你想一想

15:41.080 --> 15:43.080
这个寒树是怎么调用的

15:43.080 --> 15:45.080
我们说Z的指向还记得吗

15:45.080 --> 15:49.080
取决于这个寒树是如何调用的

15:49.080 --> 15:50.080
这个Z的指

15:50.080 --> 15:52.080
这个寒树是如何调用的

15:52.080 --> 15:54.080
是否直接调用的

15:54.080 --> 15:56.080
那么也就是说

15:56.080 --> 15:58.080
甭管你传的是啥寒树

15:58.080 --> 16:00.080
反正Z是永远指向全局

16:00.080 --> 16:02.080
就这么个意思

16:02.080 --> 16:03.080
那这样合适吗

16:03.080 --> 16:04.080
不合适

16:04.080 --> 16:07.080
那么这个Z是指向应该指向谁呢

16:07.080 --> 16:08.080
同意没想一想

16:08.080 --> 16:09.080
你看

16:09.080 --> 16:11.080
D邦是他返回一个新的寒树

16:11.080 --> 16:14.080
这个新的寒树有可能用于任何地方

16:14.080 --> 16:15.080
比方说用到这

16:15.080 --> 16:17.080
用到这的时候

16:17.080 --> 16:19.080
那么就是事件触发指向这个寒树

16:19.080 --> 16:21.080
那么在这个寒树里边

16:21.080 --> 16:23.080
在这个新的寒指向寒树里边

16:23.080 --> 16:24.080
应该指向谁

16:24.080 --> 16:26.080
是不是指向那个事件

16:26.080 --> 16:27.080
那个注册对象

16:27.080 --> 16:28.080
对吧

16:28.080 --> 16:29.080
就是个input

16:29.080 --> 16:31.080
那么这个寒树的Z是指向谁

16:31.080 --> 16:33.080
是不是按道理来说

16:33.080 --> 16:35.080
这个寒树的Z是指向谁

16:35.080 --> 16:37.080
好好处理一下

16:37.080 --> 16:40.080
我要把这个寒树里边的Z

16:40.080 --> 16:42.080
传递到这个寒树里边去

16:42.080 --> 16:44.080
这样子看上去很合理

16:44.080 --> 16:45.080
因此呢

16:45.080 --> 16:47.080
我在进一步的说

16:47.080 --> 16:48.080
也就是说

16:48.080 --> 16:52.290
这个寒树的Z

16:53.290 --> 16:55.290
传递到FN

16:56.290 --> 16:57.290
对不对

16:57.290 --> 16:59.290
而这个寒树的Z是在哪里可以获取

16:59.290 --> 17:00.290
是不是在这里可以获取

17:00.290 --> 17:01.290
再写下来

17:01.290 --> 17:02.290
写下来吧

17:03.290 --> 17:04.290
把它抽一块

17:04.290 --> 17:06.290
写到脑里无所谓了

17:06.290 --> 17:08.290
我在这里可以用一个变量

17:08.290 --> 17:12.290
来保存Z

17:12.290 --> 17:14.290
这个变量名字随便定义吧

17:14.290 --> 17:16.290
你看得出啥意思就行了

17:16.290 --> 17:18.290
来保存这个Z是指向

17:18.290 --> 17:19.290
然后呢

17:19.290 --> 17:21.290
我们的目的是要把这个Z

17:21.290 --> 17:23.290
传递给这个FN

17:23.290 --> 17:24.290
那怎么来传递呢

17:24.290 --> 17:25.290
是不是用

17:25.290 --> 17:26.290
用什么

17:26.290 --> 17:27.290
用什么呀

17:27.290 --> 17:28.290
是不是用

17:28.290 --> 17:30.290
Apply也好

17:30.290 --> 17:31.290
call是吧

17:31.290 --> 17:32.290
也可以

17:32.290 --> 17:33.290
对吧都行

17:35.290 --> 17:36.290
然后呢

17:36.290 --> 17:37.290
把这个Z

17:37.290 --> 17:38.290
绑进去

17:38.290 --> 17:39.290
这样子呢

17:39.290 --> 17:40.290
执行FN的时候

17:40.290 --> 17:41.290
它里边绑进了Z

17:41.290 --> 17:43.290
就跟Y乘这个寒树

17:43.290 --> 17:45.290
就跟这个寒树的Z

17:45.290 --> 17:46.290
是一致的

17:46.290 --> 17:47.290
没问题吧

17:47.290 --> 17:48.290
咱们来试一下

17:48.290 --> 17:49.290
走

17:51.660 --> 17:52.660
你看

17:52.660 --> 17:53.660
所以这个答应出来了

17:53.660 --> 17:54.660
好这样子的

17:54.660 --> 17:56.660
Z的指向就搞定了

17:56.660 --> 17:58.660
那么既然还有一些问题

17:58.660 --> 18:00.660
比方说我这里边的可能

18:00.660 --> 18:02.660
会用到这个式件参数E

18:02.660 --> 18:03.660
对吧

18:03.660 --> 18:04.660
我要知道那个

18:04.660 --> 18:06.660
可能要通过这个式件参数E

18:06.660 --> 18:07.660
标用它一些东西

18:07.660 --> 18:09.660
因为毕竟是式件传过来的吧

18:09.660 --> 18:10.660
也就是说我要

18:10.660 --> 18:12.660
那个防斗的寒树

18:12.660 --> 18:14.660
这是防斗寒树

18:14.660 --> 18:16.660
这是防斗的目标寒树

18:16.660 --> 18:17.660
这个目标寒树

18:17.660 --> 18:18.660
可能会有这些参数

18:18.660 --> 18:19.660
有几个参数说不好

18:19.660 --> 18:20.660
有可能有零个

18:20.660 --> 18:22.660
有可能有100个说不好的

18:22.660 --> 18:23.660
那么这些参数呢

18:23.660 --> 18:24.660
它会被传到

18:24.660 --> 18:26.660
这个新的寒树里边去

18:26.660 --> 18:28.660
它会传递给这个寒树

18:28.660 --> 18:29.660
不知道有多好个

18:29.660 --> 18:30.660
因为我在这里写的是

18:30.660 --> 18:31.660
通用代码

18:31.660 --> 18:33.660
所有的防斗场景

18:33.660 --> 18:34.660
都可以用这个代码

18:34.660 --> 18:35.660
所以说它给

18:35.660 --> 18:36.660
给这个寒树传递的

18:36.660 --> 18:37.660
参数不知道有多好个

18:37.660 --> 18:39.660
反正它传进来的几个

18:39.660 --> 18:42.660
我就要全部传递给它

18:42.660 --> 18:44.660
把它的参数要传递给它

18:44.660 --> 18:45.660
懂得意思吗

18:45.660 --> 18:46.660
调整它的时候

18:46.660 --> 18:47.660
它有一些参数

18:47.660 --> 18:50.660
那么从同样传过去

18:50.660 --> 18:52.660
咱们把个E打印一下

18:52.660 --> 18:53.660
目前那个E的

18:53.660 --> 18:54.660
肯定是没有值的

18:54.660 --> 18:58.300
走 两秒钟

18:58.300 --> 19:00.610
你看 这里的NG犯

19:00.610 --> 19:02.610
是不是 那个E没有值

19:02.610 --> 19:04.610
那么怎么办呢

19:04.610 --> 19:05.610
我这里是不是

19:05.610 --> 19:06.610
还要说这么一件事

19:06.610 --> 19:09.610
将该寒树的参数

19:09.610 --> 19:11.610
全部传递给谁

19:11.610 --> 19:13.610
给FN

19:13.610 --> 19:14.610
那么这里呢

19:14.610 --> 19:16.610
我就要记住它的参数列表

19:16.610 --> 19:17.610
参数列表在哪

19:17.610 --> 19:18.610
argument

19:18.610 --> 19:19.610
对吧

19:19.610 --> 19:21.610
这是一个伪数组

19:21.610 --> 19:22.610
那么这个伪数组

19:22.610 --> 19:24.610
而我们组合来传递过去

19:24.610 --> 19:26.610
你看这个apply的方法

19:26.610 --> 19:27.610
apply的方法

19:27.610 --> 19:28.610
后面是不是要传递一个

19:28.610 --> 19:29.610
参数的数组

19:29.610 --> 19:30.610
把参数数组传过来

19:30.610 --> 19:32.610
对不对

19:32.610 --> 19:33.610
那么我们就可以把

19:33.610 --> 19:34.610
这个 argument

19:34.610 --> 19:35.610
这个伪数组的

19:35.610 --> 19:37.610
切割成真数组

19:37.610 --> 19:38.610
因为这个apply

19:38.610 --> 19:40.610
后面要放一个参数数组

19:40.610 --> 19:41.610
那么这是一个伪数组

19:41.610 --> 19:42.610
把它变成真数组

19:42.610 --> 19:44.610
怎么变成真数组呢

19:44.610 --> 19:45.610
我之前讲过

19:45.610 --> 19:47.610
怎么把它变成真数组

19:47.610 --> 19:50.610
利用array prototype

19:50.610 --> 19:52.610
原先上面有一个方法叫slice

19:52.610 --> 19:54.610
切割数组

19:54.610 --> 19:57.610
它可以切割一个伪数组

19:58.610 --> 20:00.610
也可以切割真数组

20:00.610 --> 20:01.610
就是我每个

20:01.610 --> 20:04.980
有一个数组

20:04.980 --> 20:06.980
它可以通过slice来进行切割

20:06.980 --> 20:08.980
这个slice会返回一个新数组

20:08.980 --> 20:09.980
对吧

20:09.980 --> 20:10.980
懂了意思吧

20:10.980 --> 20:11.980
只不过了

20:11.980 --> 20:13.980
这个方法是数组里边的方法

20:13.980 --> 20:15.980
但是伪数组有没有这个方法

20:15.980 --> 20:16.980
不好意思

20:16.980 --> 20:17.980
伪数组是没有这个方法的

20:17.980 --> 20:18.980
它没有的

20:18.980 --> 20:20.980
没有这个slice

20:20.980 --> 20:21.980
我们可以利用

20:21.980 --> 20:22.980
但是我们可以利用

20:22.980 --> 20:24.980
prototype slice

20:24.980 --> 20:25.980
把这个伪数组

20:25.980 --> 20:28.980
作为z来传进去

20:28.980 --> 20:30.980
这是以前常见的做法

20:30.980 --> 20:31.980
那么这样子

20:31.980 --> 20:35.980
就是雕用slice函数

20:35.980 --> 20:37.980
然后以这个玩意

20:37.980 --> 20:38.980
为切割目标

20:38.980 --> 20:39.980
你看

20:39.980 --> 20:40.980
之前用真数组

20:40.980 --> 20:42.980
去雕用slice函数的时候

20:42.980 --> 20:43.980
你想一想

20:43.980 --> 20:44.980
在slice函数里边

20:44.980 --> 20:46.980
这里没有传入是哪个数组

20:46.980 --> 20:48.980
它怎么知道要切割哪个数组呢

20:48.980 --> 20:50.980
因为是它雕用的

20:50.980 --> 20:51.980
但是你想一想

20:51.980 --> 20:54.980
你自己去写slice函吗

20:54.980 --> 20:55.980
不是扭蛋器写的

20:55.980 --> 20:56.980
你自己写的

20:56.980 --> 20:57.980
你想一想

20:57.980 --> 21:01.490
这个slice函数里边

21:01.490 --> 21:02.490
你怎么知道是哪个数组

21:02.490 --> 21:04.490
所以只能通过z是

21:04.490 --> 21:06.490
你还记得z是指向吗

21:06.490 --> 21:07.490
通过前面那个对象

21:07.490 --> 21:08.490
调用slice

21:08.490 --> 21:10.490
那么slice函数里边

21:10.490 --> 21:11.490
z是指向谁

21:11.490 --> 21:13.490
是不是指向前面那个对象

21:13.490 --> 21:14.490
对吧

21:14.490 --> 21:15.490
obj

21:15.490 --> 21:17.490
那么a里边的z是指向谁

21:17.490 --> 21:18.490
是不是指向obj

21:18.490 --> 21:20.490
slice的z是指向谁

21:20.490 --> 21:21.490
是不是指向这个

21:21.490 --> 21:22.490
对不对

21:22.490 --> 21:23.490
那么现在尾数组

21:23.490 --> 21:25.490
没有这个方法怎么办

21:25.490 --> 21:27.490
我把函数的名字找到

21:27.490 --> 21:28.490
在哪在圆形上

21:28.490 --> 21:29.490
你看圆形的姿势

21:29.490 --> 21:31.490
可以拿出来用了

21:31.490 --> 21:32.490
在圆形上

21:32.490 --> 21:33.490
直接在圆形上

21:33.490 --> 21:34.490
调用那个函数

21:34.490 --> 21:35.490
那么这个时候

21:35.490 --> 21:36.490
它的z是指向谁

21:36.490 --> 21:37.490
会指向这个圆形

21:37.490 --> 21:38.490
那行吗

21:38.490 --> 21:39.490
肯定不行

21:39.490 --> 21:41.490
所以说我把这个要写个

21:41.490 --> 21:42.490
我们要用什么

21:42.490 --> 21:43.490
用那个

21:44.490 --> 21:45.490
扣

21:46.490 --> 21:47.490
对吧

21:47.490 --> 21:48.490
绑定z

21:48.490 --> 21:49.490
绑定这个slice函数的z

21:49.490 --> 21:50.490
指向谁

21:50.490 --> 21:52.490
指向那个尾数组

21:52.490 --> 21:53.490
那么它这里切割

21:53.490 --> 21:54.490
切割的是谁了

21:54.490 --> 21:55.490
变成尾数组

21:55.490 --> 21:56.490
对不对

21:56.490 --> 21:57.490
我们利用这种方式

21:57.490 --> 21:59.490
来切割这个尾数组

21:59.490 --> 22:00.490
后面就传到

22:00.490 --> 22:01.490
函数的函数了

22:01.490 --> 22:02.490
从哪里开始切割

22:02.490 --> 22:03.490
从第0个函数

22:03.490 --> 22:04.490
从第下标0的位置

22:04.490 --> 22:05.490
开始切割

22:05.490 --> 22:06.490
切割到摸尾

22:06.490 --> 22:07.490
那么这样子

22:07.490 --> 22:11.180
它就会返回一个新数组

22:11.180 --> 22:13.180
obj

22:13.180 --> 22:14.180
这样子

22:14.180 --> 22:15.180
这个目的

22:15.180 --> 22:16.180
就是为了

22:16.180 --> 22:17.180
当然你自己去循环

22:17.180 --> 22:18.180
这个obj

22:18.180 --> 22:19.180
然后呢

22:19.180 --> 22:20.180
建立一个数组

22:20.180 --> 22:21.180
一想一想

22:21.180 --> 22:22.180
我数组里面都想

22:22.180 --> 22:23.180
反正呢

22:23.180 --> 22:24.180
你得想个办法

22:24.180 --> 22:25.180
给把那个东西

22:25.180 --> 22:26.180
转成一个函数组

22:26.180 --> 22:27.180
把这个函数组

22:27.180 --> 22:28.180
是不是可以传递过去

22:29.180 --> 22:30.180
这样子呢

22:30.180 --> 22:31.180
就不管给这个函数

22:31.180 --> 22:32.180
有多少的函数

22:32.180 --> 22:33.180
它都会无缝的

22:33.180 --> 22:35.180
传递给这个fn函数

22:35.180 --> 22:36.180
Z也搞定的

22:36.180 --> 22:37.180
函数也搞定的

22:37.180 --> 22:38.180
那就完事了

22:38.180 --> 22:40.820
好 咱们看一下

22:40.820 --> 22:41.820
好 等两秒

22:41.820 --> 22:42.820
两秒钟

22:42.820 --> 22:43.820
你看

22:43.820 --> 22:44.820
时间参数是不是拿到了

22:45.820 --> 22:46.820
这就完成了

22:46.820 --> 22:47.820
一个防斗函数

22:48.820 --> 22:49.820
这是通用的

22:49.820 --> 22:50.820
不光是什么input的时间

22:50.820 --> 22:51.820
啥时间都可以用

22:51.820 --> 22:53.820
比方说mouse目的时间

22:55.820 --> 22:56.820
也是一样

22:56.820 --> 22:57.820
把这个函数提出来

23:01.540 --> 23:02.540
我觉得这个时间里面

23:02.540 --> 23:03.540
有house操作

23:03.540 --> 23:04.540
而且我只需要

23:04.540 --> 23:05.540
最后一次就可以了

23:05.540 --> 23:06.540
因此呢

23:06.540 --> 23:07.540
我可以调用这个db

23:07.540 --> 23:09.540
把这个函数传进去

23:09.540 --> 23:10.540
然后呢

23:10.540 --> 23:11.540
给它个等待时间

23:11.540 --> 23:14.100
一秒钟吧

23:14.100 --> 23:15.100
就是mouse

23:15.100 --> 23:17.100
mouse

23:17.100 --> 23:18.100
mouse

23:18.100 --> 23:19.100
mouse

23:19.100 --> 23:20.100
就随便写个名字

23:20.100 --> 23:21.100
好

23:21.100 --> 23:22.100
我们把这个新的函数

23:22.100 --> 23:23.100
拿去放进去

23:23.100 --> 23:24.100
我再说一次

23:24.100 --> 23:26.100
它不能改变

23:26.100 --> 23:28.100
事件触发的频率

23:28.100 --> 23:30.100
但是可以把那些触发

23:30.100 --> 23:31.100
每次触发时间里边

23:31.100 --> 23:33.100
那些耗时操作

23:33.100 --> 23:35.100
这些耗时操作

23:35.100 --> 23:36.100
都模拟得

23:36.100 --> 23:38.100
延迟执行

23:38.100 --> 23:39.100
好

23:39.100 --> 23:40.100
看一下

23:40.100 --> 23:41.100
鼠标移动

23:41.100 --> 23:42.100
走走走走走走

23:42.100 --> 23:43.100
你看

23:43.100 --> 23:44.100
耗时操作没触发吧

23:44.100 --> 23:45.100
我现在没停

23:45.100 --> 23:46.100
只要停下来

23:46.100 --> 23:47.100
等一秒钟

23:47.100 --> 23:49.100
是不是耗时操作出发了

23:49.100 --> 23:50.100
就这个意思

23:50.100 --> 23:51.100
这就是防斗

23:51.100 --> 23:52.100
那么这样一来

23:52.100 --> 23:53.100
我们再解决

23:53.100 --> 23:54.100
刚才的问题

23:54.100 --> 23:55.100
由于我们这个

23:55.100 --> 23:56.100
layout函数

23:56.100 --> 23:58.100
就是我们这里

23:58.100 --> 23:59.100
图片铺不流

23:59.100 --> 24:00.100
layout函数

24:00.100 --> 24:02.100
太过于耗时了

24:02.100 --> 24:03.100
因此我们怎么办

24:03.100 --> 24:04.100
是不是利用防斗

24:04.100 --> 24:06.100
我们把这个防斗函数

24:06.100 --> 24:09.930
给它写过去

24:09.930 --> 24:10.930
写过来

24:11.930 --> 24:13.930
然后这里有耗时操作

24:13.930 --> 24:14.930
对不对

24:14.930 --> 24:15.930
好

24:15.930 --> 24:16.930
我们再来

24:17.930 --> 24:18.930
把这个耗时操作了

24:18.930 --> 24:20.930
加到防斗函数里边去

24:20.930 --> 24:21.930
作为第一个函数

24:21.930 --> 24:22.930
后边给它写上一个时间

24:22.930 --> 24:24.930
比方说500毫秒吧

24:26.930 --> 24:28.930
我这个电脑屏比较卡

24:28.930 --> 24:29.930
1000毫秒吧

24:29.930 --> 24:30.930
就是一秒钟

24:30.930 --> 24:31.930
得到一个什么

24:31.930 --> 24:32.930
得到一个新的

24:33.930 --> 24:35.930
处理函数

24:36.930 --> 24:38.930
把这个新的处理函数

24:38.930 --> 24:39.930
放进去

24:40.930 --> 24:41.930
这样子能每一次

24:41.930 --> 24:42.930
窗口大小变化

24:42.930 --> 24:43.930
运行的是个新的函数

24:44.930 --> 24:45.930
而新的函数

24:45.930 --> 24:46.930
它有一个时间

24:46.930 --> 24:47.930
对吧

24:47.930 --> 24:48.930
它等待了一段时间

24:48.930 --> 24:49.930
没有操作过后

24:49.930 --> 24:51.930
才会真正的去运行这个函数

24:51.930 --> 24:53.930
这样子就把耗时操作延后了

24:53.930 --> 24:54.930
咱们再看一下

24:56.930 --> 24:57.930
好

24:57.930 --> 24:58.930
走走走

24:58.930 --> 25:00.930
你看是不是没有重新排列

25:00.930 --> 25:01.930
没有重新排列

25:01.930 --> 25:02.930
只要我停下来

25:02.930 --> 25:03.930
不动了

25:03.930 --> 25:04.930
你看

25:04.930 --> 25:05.930
才运行了这个耗时操作

25:05.930 --> 25:06.930
刚才就抖了一下

25:06.930 --> 25:07.930
走

25:07.930 --> 25:08.930
不抖的话

25:08.930 --> 25:09.930
你看

25:09.930 --> 25:10.930
就运行一次就可以了

25:10.930 --> 25:12.930
这样就大大的减少了

25:12.930 --> 25:14.930
耗时操作的

25:14.930 --> 25:16.930
执行频率

25:16.930 --> 25:17.930
懂了一半

25:17.930 --> 25:18.930
这就是函数防斗

25:18.930 --> 25:20.930
这就可以代码了

25:20.930 --> 25:22.930
可能对初学者来说

25:22.930 --> 25:23.930
有一定的难度

25:23.930 --> 25:24.930
因为这些函数

25:24.930 --> 25:25.930
传来传去

25:25.930 --> 25:26.930
初学者来说

25:26.930 --> 25:29.930
传函数是最痛苦的一件事了

25:29.930 --> 25:30.930
慢慢看

25:30.930 --> 25:31.930
慢慢去理解

25:31.930 --> 25:33.930
这是每一个开发者

25:33.930 --> 25:34.930
都需要过的课

25:35.930 --> 25:36.930
也没什么大不了的

25:36.930 --> 25:37.930
早晚都能过的

25:37.930 --> 25:38.930
好好去思考一下

25:38.930 --> 25:39.930
好好去理解一下

25:39.930 --> 25:41.930
这是函数防斗

