WEBVTT

00:00.000 --> 00:05.800
hello 大家好 这一集开始咱们来说一个新的内容 叫做Walker

00:05.800 --> 00:07.800
叫做Walker 是一个新的接口

00:07.800 --> 00:13.000
这个Walker其实也不常用 其实你会换过头来说H5的这些东西

00:13.000 --> 00:17.000
还真没几个常用的 是吧 因为兼容性不行 是吧

00:17.000 --> 00:22.400
但是既然没有几个常用的 大家就也要了解一下 简单的了解一下

00:22.400 --> 00:26.600
Walker这个东西很有意思 它打破了一个我们之前的一个概念

00:26.600 --> 00:29.800
什么概念的 我们之前说GIS都是单线程的 对吧

00:29.800 --> 00:33.800
我们之前说GIS都是单线程的 GIS都是单线程的

00:33.800 --> 00:40.000
单线程的 就是虽然说有一些什么回调之类的

00:40.000 --> 00:44.200
但是它最后都要把这个指令插入到这个指令的对战里面去 是吧

00:44.200 --> 00:48.200
然后还是按照顺序一个一个去执行

00:48.200 --> 00:53.200
但是自从出了这个Walker之后 这个世界就变了 是吧

00:53.400 --> 01:00.030
Walker是多线程的 而且它是真的多线程 是真的多线程

01:00.030 --> 01:05.030
是真的多线程 不是伟多线程

01:05.030 --> 01:11.450
不是伟多线程 什么叫伟多线程

01:11.450 --> 01:17.450
伟多线程 其实类似于阿迦克斯这种回调

01:17.450 --> 01:20.250
你可以把它当成一种伟多线程

01:20.250 --> 01:26.450
虽然它还是真的是多线程 因为GIS的底层有一个线程池

01:27.050 --> 01:30.050
你把命令分配给了线程池了之后

01:30.050 --> 01:32.050
它就去帮你去执行命令

01:32.050 --> 01:38.050
然后命令的返回结果 它在需要执行返回结果的时候

01:38.050 --> 01:40.050
就是成功的回调的时候

01:40.050 --> 01:44.050
它要再把成功的命令重新插入到指令对战里面来

01:44.050 --> 01:50.050
但是为什么管的叫伟 是因为它在多线程的运行过程中

01:50.050 --> 01:53.050
你都没法控制 那些代码不是你写的 你没法控制

01:54.050 --> 01:55.050
但是Walker不一样

01:55.050 --> 02:02.050
Walker虽然开出来的多线程 在多的线程里面执行的代码都是你写的

02:02.050 --> 02:05.050
在多的线程里面执行的代码都是你写的

02:05.050 --> 02:07.050
所以Walker就很溜 是吧 很厉害

02:07.050 --> 02:10.050
但是有同学说了 多线程

02:10.050 --> 02:14.050
我是不是在Walker里面去操作一下什么DOM

02:14.050 --> 02:17.050
我是不是界面的运行速度就会变快

02:17.050 --> 02:20.050
我跟你说没有那么简单

02:20.050 --> 02:22.050
Walker是有很多限制的

02:23.050 --> 02:26.050
Walker首先不能操作DOM

02:26.050 --> 02:30.050
你就显然就这一点 是不是 就感觉这玩意

02:30.050 --> 02:36.050
暂时我们感觉不能够大量的就是提高我们的意面性能

02:36.050 --> 02:38.050
对吧 不能操作DOM

02:38.050 --> 02:40.050
第二个 没有Window对象

02:40.050 --> 02:42.050
没有Window对象

02:42.050 --> 02:45.050
你想操作Window上的对象没门 什么

02:45.050 --> 02:47.050
你想打个俄论 打个Confirm

02:47.050 --> 02:50.050
Confirm不可能 没有Window对象

02:51.050 --> 02:57.050
然后它还有什么限制呢 就是不能读取文件

02:57.050 --> 03:01.740
有同学说 老师 我这个上传

03:01.740 --> 03:04.740
我感觉上传步骤挺耗费资源的 是吧

03:04.740 --> 03:06.740
那我就扔到这个Walker里面去摆

03:06.740 --> 03:08.740
让他去做这个文本框

03:08.740 --> 03:10.740
然后去读取本地文件

03:10.740 --> 03:12.740
不可以 不能读取本地文件

03:12.740 --> 03:14.740
就是做文件上传 你也不能用它

03:14.740 --> 03:18.740
但是它可以干嘛呢 可以发家科斯

03:19.740 --> 03:23.740
可以发家科斯 可以计算

03:23.740 --> 03:25.740
而且科斯本身就是异部的

03:25.740 --> 03:27.740
所以你用它干嘛呢 是吧

03:27.740 --> 03:28.740
所以说我们顶多的时候

03:28.740 --> 03:31.740
现在用的就是用它做异部的计算

03:31.740 --> 03:33.740
但是你说到前端页面上

03:33.740 --> 03:34.740
哪有那么大的计算量 是吧

03:34.740 --> 03:36.740
也没有多大的计算量

03:37.740 --> 03:39.740
所以说Walker现在再加上

03:39.740 --> 03:42.740
它的兼容性不是特别的好

03:42.740 --> 03:45.740
所以用这个东西几乎微乎其微

03:45.740 --> 03:47.740
用这个东西的超级少

03:48.740 --> 03:51.740
虽然少 咱们也试试这个玩意怎么用

03:51.740 --> 03:53.740
大家先简单的了解一下

03:53.740 --> 03:54.740
简单的了解一下

03:54.740 --> 03:56.740
好 我们说Walker怎么用

03:56.740 --> 03:58.740
我先新建一个文件

03:58.740 --> 03:59.740
先新建一个文件

03:59.740 --> 04:04.740
叫做Walker.js 是吧

04:04.740 --> 04:05.740
Walker.js

04:06.740 --> 04:08.740
我这块有个scrib的标签

04:08.740 --> 04:09.740
是吧 我这块有个scrib标签

04:09.740 --> 04:11.740
我这个类的GS会照常的执行

04:11.740 --> 04:15.740
比如说我Consolvlog

04:15.740 --> 04:19.740
一个一行的等号 是吧

04:19.740 --> 04:20.740
对 两行的等号

04:20.740 --> 04:21.740
三行的等号

04:21.740 --> 04:22.740
四行的等号 是吧

04:22.740 --> 04:24.740
它会这样顺序的执行

04:24.740 --> 04:27.740
我希望在我输入这些等号的中间

04:27.740 --> 04:29.740
开始干一件事

04:29.740 --> 04:32.740
开始干一个什么事呢

04:32.740 --> 04:35.740
算一个求合的一个操作

04:35.740 --> 04:36.740
算一个求合的操作

04:36.740 --> 04:38.740
比如说我Ware一个A

04:38.740 --> 04:41.740
等于1万

04:41.740 --> 04:42.740
那我就要算

04:42.740 --> 04:44.740
从1加到1万等于等于多少

04:44.740 --> 04:45.740
但是你想想

04:45.740 --> 04:46.740
我如果在这儿夹

04:46.740 --> 04:47.740
是不是也能夹

04:48.740 --> 04:49.740
我要是在这儿夹

04:49.740 --> 04:50.740
是不是也能夹

04:50.740 --> 04:51.740
Ware一个i

04:51.740 --> 04:52.740
等于零

04:52.740 --> 04:53.740
是吧

04:53.740 --> 04:55.740
然后i小于a

04:55.740 --> 04:56.740
i加加

04:56.740 --> 04:59.740
然后我再声明一个result

04:59.740 --> 05:00.740
是吧

05:00.740 --> 05:01.740
等于零

05:01.740 --> 05:04.740
然后result加等于i

05:04.740 --> 05:05.740
是吧

05:05.740 --> 05:07.740
然后最后我再输出一下

05:07.740 --> 05:09.740
sot

05:09.740 --> 05:13.740
Consolve一下result

05:13.740 --> 05:15.740
我是不是这样也能写

05:15.740 --> 05:16.740
我这样肯定能写

05:16.740 --> 05:17.740
但是它有个问题

05:17.740 --> 05:18.740
它有什么问题呢

05:18.740 --> 05:20.740
它就是我后面这两行

05:20.740 --> 05:22.740
我必须得等它计算完了

05:22.740 --> 05:23.740
我才能写

05:23.740 --> 05:24.740
我后面这两行

05:24.740 --> 05:25.740
必须得等它计算完了

05:25.740 --> 05:26.740
我才能输出出来

05:29.740 --> 05:30.740
就感觉吧

05:30.740 --> 05:31.740
就会稍微的慢一些

05:31.740 --> 05:33.740
比如说我要是10万

05:33.740 --> 05:35.740
它就会更慢是吧

05:35.740 --> 05:37.740
10万它就会更慢

05:37.740 --> 05:39.740
那我可以怎么办

05:39.740 --> 05:40.740
我可以怎么办

05:40.740 --> 05:41.740
我可以怎么办

05:41.740 --> 05:43.740
我可以这个时候就开始用异步

05:43.740 --> 05:44.740
我可以用异步

05:44.740 --> 05:48.740
可以word一个worker

05:48.740 --> 05:52.740
等于new一个worker

05:52.740 --> 05:54.740
这个里面传什么呢

05:54.740 --> 05:56.740
这个worker里面传什么呢

05:56.740 --> 05:58.740
传一个GS的文件名

05:58.740 --> 06:00.740
传一个GS的文件名

06:03.740 --> 06:04.740
它会怎么样呢

06:04.740 --> 06:06.740
它就会去加载这个GS

06:06.740 --> 06:09.740
它就会去加载这个GS

06:09.740 --> 06:11.740
你说加载这个GS就要执行吗

06:11.740 --> 06:13.740
那肯定不行是吧

06:13.740 --> 06:14.740
我不能让它加载就是执行

06:14.740 --> 06:17.740
我必须让它接收到我的命令了之后

06:17.740 --> 06:18.740
才能执行

06:18.740 --> 06:20.740
怎么样接收呢

06:20.740 --> 06:22.740
我们的这个就叫主线程

06:22.740 --> 06:23.740
这个页面里的GS

06:23.740 --> 06:26.740
就是我们GS的主线程

06:26.740 --> 06:28.740
我们开启了一个新的线程

06:28.740 --> 06:31.740
就相当于我又雇用了一个工人

06:31.740 --> 06:32.740
我又雇用了一个工人

06:32.740 --> 06:33.740
worker是吧

06:33.740 --> 06:34.740
那工人不是雇用了

06:34.740 --> 06:35.740
刚一雇用

06:35.740 --> 06:36.740
它就开始不停的干活是吧

06:36.740 --> 06:38.740
是你让它干活

06:38.740 --> 06:39.740
它才能干活是吧

06:39.740 --> 06:41.740
所以说它得有一个接收

06:41.740 --> 06:43.740
消息的这么一个

06:43.740 --> 06:45.740
接收消息的这么一个功能

06:45.740 --> 06:47.740
接收消息的这么一个功能

06:47.740 --> 06:49.740
这个里面可以传一些参数

06:49.740 --> 06:51.740
可以传一些参数

06:51.740 --> 06:53.740
里面应该是一个e

06:59.740 --> 07:01.740
这里面有一个e

07:01.740 --> 07:02.740
然后我们来看一下

07:02.740 --> 07:05.740
我输出一下这个e到底是什么

07:05.740 --> 07:09.310
我输出这个e到底是什么

07:10.310 --> 07:12.310
我雇用了一个worker

07:12.310 --> 07:14.310
然后我可以用worker的

07:14.310 --> 07:16.310
什么给他发消息

07:16.310 --> 07:18.310
send message

07:20.310 --> 07:21.310
不是send message

07:21.310 --> 07:23.310
叫post message

07:24.310 --> 07:26.310
post message

07:26.310 --> 07:28.310
post message里面可以传一个参数

07:28.310 --> 07:29.310
传一些参数

07:29.310 --> 07:34.310
比如说我传一个nam為a

07:35.310 --> 07:37.310
传一个nam为a

07:37.310 --> 07:38.310
你看我执行到这的时候

07:38.310 --> 07:40.310
这里面会给我打印个什么

07:40.310 --> 07:41.310
看我执行到这的时候

07:41.310 --> 07:43.310
这里面会打印什么

07:45.940 --> 07:47.940
它打出来一个事件

07:47.940 --> 07:49.940
它打出来一个事件

07:50.940 --> 07:52.940
它打出来一个事件

07:52.940 --> 07:53.940
我们在这个事件里面

07:53.940 --> 07:55.940
可以看到有个语叫做date

07:55.940 --> 07:57.940
date就是10万

07:57.940 --> 07:59.940
我们可以在这个里面

07:59.940 --> 08:01.940
去做我们想要做的事情

08:01.940 --> 08:02.940
我们可以在这个里面

08:02.940 --> 08:04.940
去做想要做的事情

08:04.940 --> 08:05.940
在这个里面怎么做呢

08:05.940 --> 08:07.940
我们把这里的代码写到这

08:07.940 --> 08:09.940
把这里面的代码写到这

08:10.940 --> 08:12.940
那就是从这到这是吧

08:13.940 --> 08:15.940
然后我想

08:15.940 --> 08:16.940
我算完了之后

08:16.940 --> 08:17.940
我得把这个结果给

08:17.940 --> 08:19.940
得返还回去是吧

08:19.940 --> 08:20.940
我算完了之后

08:20.940 --> 08:22.940
得把这个结果给返还回去

08:22.940 --> 08:23.940
我怎么返还

08:23.940 --> 08:24.940
记住啊

08:24.940 --> 08:28.940
主线程和辅线程之间

08:28.940 --> 08:31.940
都用post message

08:31.940 --> 08:33.940
进行发送消息

08:33.940 --> 08:36.940
用on message做接受消息

08:36.940 --> 08:38.940
那就是说

08:38.940 --> 08:40.940
我这个也能接受消息是吧

08:40.940 --> 08:42.940
它也得有个on message是吧

08:42.940 --> 08:44.940
这样它才能接受消息

08:44.940 --> 08:50.050
就像个回调是吧

08:50.050 --> 08:51.050
就像个回调的

08:51.050 --> 08:53.050
就是我在这块开始

08:53.050 --> 08:54.050
post message我让你做

08:54.050 --> 08:55.050
做完了之后

08:55.050 --> 08:56.050
你就执行我这个回调

08:56.050 --> 08:58.050
就是大概是这么个意思

08:58.050 --> 08:59.050
是这么个意思

08:59.050 --> 09:00.050
它这里有e

09:00.050 --> 09:01.050
我在这里面

09:01.050 --> 09:06.050
直接console.loge的data

09:06.050 --> 09:07.050
好吧

09:07.050 --> 09:09.050
console.loge的data

09:09.050 --> 09:10.050
然后呢

09:10.050 --> 09:11.050
我直接就

09:11.050 --> 09:12.050
就不输入这个result

09:12.050 --> 09:13.050
是吧

09:13.050 --> 09:14.050
因为在这里面就输入了

09:14.050 --> 09:15.050
是吧

09:15.050 --> 09:16.050
那我在这块怎么给它发回去

09:16.050 --> 09:17.050
刚才咱说的是吧

09:17.050 --> 09:19.050
发送用post message

09:19.050 --> 09:21.050
接收用on message

09:21.050 --> 09:26.050
list post message

09:26.050 --> 09:27.050
是吧

09:27.050 --> 09:29.050
list post message

09:29.050 --> 09:30.050
那把谁传进去

09:30.050 --> 09:32.050
我要传的是result

09:32.050 --> 09:33.050
是吧

09:33.050 --> 09:34.050
又传进去了

09:34.050 --> 09:35.050
那我们来执行一下

09:35.050 --> 09:38.680
看一下这个结果是什么

09:38.680 --> 09:39.680
a is not defined

09:39.680 --> 09:43.250
我看看哪有写了个a

09:43.250 --> 09:45.250
我这里面写了个a是吧

09:45.250 --> 09:48.250
应该是e的data的nam

09:48.250 --> 09:49.250
是吧

09:49.250 --> 09:51.250
因为我传的参数

09:51.250 --> 09:53.250
把这个参数传进去了

09:53.250 --> 09:55.250
这个参数里面有一个属性是nam

09:55.250 --> 09:57.250
这个参数作为data

09:57.250 --> 09:59.250
作为存在data里

09:59.250 --> 10:01.250
再刷新一下

10:01.250 --> 10:02.250
看

10:02.250 --> 10:04.250
1行 2行 3行 4行是吧

10:04.250 --> 10:06.250
先把4行等号给打印完了

10:06.250 --> 10:09.250
先把4行等号给打印完了

10:10.250 --> 10:11.250
然后

10:12.250 --> 10:14.250
然后才算出这个结果是吧

10:14.250 --> 10:15.250
就证明什么呀

10:15.250 --> 10:17.250
它并没有组色在这是吧

10:17.250 --> 10:19.250
它并没有组色在这

10:19.250 --> 10:21.250
是这个线程它先在这做了

10:21.250 --> 10:23.250
这个线程先在这做了

10:24.250 --> 10:26.250
然后当我这个线程做完了之后

10:26.250 --> 10:28.250
它又执行了一个

10:28.250 --> 10:29.250
这个线程里面

10:29.250 --> 10:31.250
又发送了一个消息

10:31.250 --> 10:32.250
然后我在这个on message里面

10:32.250 --> 10:34.250
接收到了这个消息

10:34.250 --> 10:36.250
然后我才输出了出来

10:36.250 --> 10:37.250
所以我们看到的是

10:37.250 --> 10:39.250
先打印了4行等号

10:39.250 --> 10:41.250
我们先打印了4行等号

10:42.250 --> 10:43.250
我们用一种方式

10:43.250 --> 10:45.250
来看看我们这个里面的执行速度

10:45.250 --> 10:46.250
我们用一种方式来看看

10:46.250 --> 10:48.250
我们这里的执行速度

10:48.250 --> 10:50.250
console有点log

10:50.250 --> 10:52.250
我来看一下

10:53.250 --> 10:55.250
怎么能看出来一个速度呢

10:55.250 --> 10:56.250
你有一个

10:58.250 --> 10:59.250
看到

10:59.250 --> 11:02.390
data

11:05.390 --> 11:06.390
no

11:06.390 --> 11:11.750
这里面能打出一个时间

11:12.750 --> 11:14.750
这里面能打出一个时间

11:14.750 --> 11:16.750
我们用data的no

11:18.750 --> 11:19.750
记录一下

11:19.750 --> 11:20.750
记录一个data的no

11:20.750 --> 11:21.750
were一个

11:21.750 --> 11:22.750
begin

11:22.750 --> 11:23.750
time

11:23.750 --> 11:25.750
等于

11:25.750 --> 11:27.750
data的no

11:28.750 --> 11:31.750
然后我们在这开始执行是吧

11:32.750 --> 11:33.750
然后结束了之后

11:33.750 --> 11:35.750
我在were一个and time

11:36.750 --> 11:37.750
and time

11:37.750 --> 11:38.750
然后等于

11:38.750 --> 11:40.750
data的no

11:41.750 --> 11:44.750
然后我们console了点log一下

11:44.750 --> 11:45.750
and time

11:45.750 --> 11:47.750
减缺begin time

11:48.750 --> 11:50.750
看一下这个中间的时间差是多少

11:50.750 --> 11:51.750
你看

11:51.750 --> 11:52.750
如果我不用中间这段

11:52.750 --> 11:53.750
就是我不用一步的方式

11:53.750 --> 11:55.750
我用这个顺序的方式来写

11:56.750 --> 12:01.980
我用这个顺序的方式来写

12:02.980 --> 12:03.980
a 是吧

12:06.490 --> 12:07.490
were一个result

12:07.490 --> 12:08.490
等于0

12:09.490 --> 12:11.490
然后我在这块console了

12:12.490 --> 12:13.490
点log

12:14.490 --> 12:16.490
console的logresult

12:17.490 --> 12:18.490
我们看一下

12:18.490 --> 12:21.490
这样的话执行到最后这个时间是多少

12:21.490 --> 12:22.490
这个时间是多少

12:25.490 --> 12:26.490
7毫秒

12:27.490 --> 12:28.490
这么短吗

12:28.490 --> 12:30.490
这个数数不够大

12:30.490 --> 12:31.490
我看看来个100万

12:34.490 --> 12:35.490
100万大了是吧

12:35.490 --> 12:36.490
36毫秒

12:37.490 --> 12:39.490
它从这走到这

12:39.490 --> 12:40.490
用了多少时间

12:40.490 --> 12:41.490
用了36毫秒

12:41.490 --> 12:44.490
你看我用一步的来写

12:46.490 --> 12:47.490
那就是我把这段给住了

12:47.490 --> 12:48.490
是吧

12:48.490 --> 12:49.490
我把这段给住了

12:50.490 --> 12:53.490
我开启了咱们的worker

12:53.490 --> 12:56.490
这样的话从上到下

12:56.490 --> 12:58.490
你看看需要用多少时间

12:59.490 --> 13:02.060
1毫秒

13:03.060 --> 13:04.060
你就说快不快

13:04.060 --> 13:05.060
1毫秒

13:05.060 --> 13:06.060
你就说快不快

