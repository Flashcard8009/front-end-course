WEBVTT

00:00.880 --> 00:03.880
这些课是一个扩展课程

00:04.880 --> 00:09.880
所谓扩展课程的就是说大家凭着兴趣来学一学

00:09.880 --> 00:10.880
来听一听

00:11.880 --> 00:13.880
之所以要准备这些课

00:13.880 --> 00:15.880
其实我一开始是不想讲这些课的

00:15.880 --> 00:17.880
因为它涉及到的知识量很多

00:17.880 --> 00:20.880
而且比较的复杂

00:20.880 --> 00:22.880
之所以要安排这一节课

00:23.880 --> 00:25.880
其实给大家拓展一些事业

00:25.880 --> 00:27.880
给大家感受一下

00:27.880 --> 00:29.880
一些工程师

00:29.880 --> 00:32.880
因为这个PMPM其实就是一个开发者

00:32.880 --> 00:34.880
就是一个人写的

00:34.880 --> 00:36.880
可以给大家感受一下

00:36.880 --> 00:38.880
一些工程师他去为了解决一些问题

00:38.880 --> 00:40.880
他做了哪些思考

00:40.880 --> 00:44.880
以及他是怎么样用他的聪明材质

00:44.880 --> 00:46.880
来解决这个问题的

00:46.880 --> 00:48.880
所以说通过这节课

00:48.880 --> 00:49.880
大家也可以感受到

00:49.880 --> 00:51.880
尽管很多时候事情

00:51.880 --> 00:53.880
好像挺复杂的样子

00:53.880 --> 00:55.880
但是这些事情总归要有人去处理

00:55.880 --> 00:57.880
如果没有人处理这些问题的话

00:57.880 --> 00:59.880
那么咱们的整个行业

00:59.880 --> 01:01.880
就永远无法进步

01:01.880 --> 01:02.880
那么这些可能

01:02.880 --> 01:04.880
我们来带大家认识一些概念

01:04.880 --> 01:08.880
一些PMPM这种巧妙的处理方式

01:08.880 --> 01:10.880
大家开一下眼界

01:10.880 --> 01:13.880
首先你要学习PMPM的处理方式

01:13.880 --> 01:15.880
你就必须要知道一些概念

01:15.880 --> 01:17.880
这些概念可能你们以前

01:17.880 --> 01:18.880
没有怎么接触过

01:18.880 --> 01:19.880
所以说这些可能

01:19.880 --> 01:21.880
先跟大家做个补充

01:22.880 --> 01:25.880
这是一些关于操作系统的知识

01:25.880 --> 01:28.880
第一个就是关于文件的本质

01:28.880 --> 01:29.880
什么叫做文件

01:29.880 --> 01:30.880
我们平时都在用文件

01:30.880 --> 01:32.880
比方说像什么技师本

01:32.880 --> 01:33.880
一个文件

01:33.880 --> 01:36.880
像什么GS保存在一个文件里面

01:36.880 --> 01:38.880
那么这个文件到底是什么

01:38.880 --> 01:39.880
大家可以这样认为

01:39.880 --> 01:40.880
在操作系统里面

01:40.880 --> 01:43.880
文件实际上是一个指针

01:43.880 --> 01:45.880
就像那时存的是一个地址

01:45.880 --> 01:47.880
但是它存的不是内存地址

01:47.880 --> 01:49.880
我们以前的编程的时候

01:49.880 --> 01:50.880
一个编辆存的是地址

01:50.880 --> 01:52.880
那么文件它存的不是内存地址

01:52.880 --> 01:54.880
而存的是什么地址呢

01:54.880 --> 01:57.880
是一个外部存储地址

01:57.880 --> 01:58.880
就是什么叫外部存储地址呢

01:58.880 --> 02:00.880
我们这里面就可以简单的

02:00.880 --> 02:02.880
把它理解为硬盘

02:02.880 --> 02:04.880
或者是U盘就是磁盘

02:04.880 --> 02:07.880
其实它外部存储还可以是网络

02:07.880 --> 02:08.880
比方说下面一张图

02:08.880 --> 02:09.880
大家可以认识得很清楚

02:09.880 --> 02:13.880
比方说我们文件abc.txt里面

02:13.880 --> 02:16.880
这个文件它里面写了一篇文章

02:16.880 --> 02:18.880
那么这个文件它存的上来

02:18.880 --> 02:20.880
它其实就是一个指针

02:20.880 --> 02:21.880
我们的文章数据在哪呢

02:21.880 --> 02:23.880
文章的数据在磁盘里面

02:23.880 --> 02:24.880
在硬盘里面

02:24.880 --> 02:25.880
那么这个指针呢

02:25.880 --> 02:26.880
这个地址呢

02:26.880 --> 02:28.880
它指向这个磁盘

02:28.880 --> 02:29.880
这个图呢

02:29.880 --> 02:30.880
我这样的话呢

02:30.880 --> 02:31.880
大家可好理解一点

02:31.880 --> 02:33.880
其他指向的是手地址

02:33.880 --> 02:35.880
是这么个意思

02:35.880 --> 02:36.880
这是文件

02:36.880 --> 02:37.880
其实我们

02:37.880 --> 02:39.880
那么大家认识到这个概念过后

02:39.880 --> 02:41.880
再回过以前我们删除文件

02:41.880 --> 02:44.880
其实我以前给大家简单说了一下

02:44.880 --> 02:45.880
就是删除文件

02:45.880 --> 02:47.880
为什么无论你是EKB的文件

02:47.880 --> 02:49.880
还是一个G的文件

02:49.880 --> 02:50.880
删除的都很快了

02:50.880 --> 02:52.880
就是因为删文件的时候

02:52.880 --> 02:53.880
实际上我们删的是啥

02:53.880 --> 02:55.880
删的是这个文件的指针

02:55.880 --> 02:57.880
这个指针没了

02:57.880 --> 02:59.880
而不是这个具体的内容

02:59.880 --> 03:00.880
所以说你无论删

03:00.880 --> 03:01.880
都不大的文件

03:01.880 --> 03:02.880
速度都非常非常快

03:02.880 --> 03:03.880
因为你只是删了一个指针

03:03.880 --> 03:04.880
指针没了

03:04.880 --> 03:05.880
它内容还在

03:05.880 --> 03:06.880
大家知不知道

03:06.880 --> 03:08.880
现在市面上有一个叫做

03:08.880 --> 03:10.880
数据恢复

03:10.880 --> 03:11.880
专门一个行业

03:11.880 --> 03:12.880
叫数据恢复

03:12.880 --> 03:13.880
就是你有一些

03:13.880 --> 03:15.880
数据不小心删了

03:15.880 --> 03:16.880
不小心删了

03:16.880 --> 03:18.880
你可能想把它恢复过来

03:18.880 --> 03:20.880
比方说你回收站也清空了

03:20.880 --> 03:21.880
你要想把它恢复

03:21.880 --> 03:23.880
人们恢复理论上是可以的

03:23.880 --> 03:24.880
因为为什么

03:24.880 --> 03:25.880
它数据还在

03:25.880 --> 03:26.880
在这里

03:26.880 --> 03:27.880
但是这个数据

03:27.880 --> 03:29.880
如果说你过了很长一段时间

03:29.880 --> 03:30.880
一般恢复的时候

03:30.880 --> 03:31.880
那边就会告诉你

03:31.880 --> 03:34.880
为你删除的时间是多久

03:34.880 --> 03:35.880
多久以前删除了

03:35.880 --> 03:37.880
比方说你两年前删除的

03:37.880 --> 03:38.880
不好意思

03:38.880 --> 03:39.880
这个数据可能不在了

03:39.880 --> 03:40.880
为什么呢

03:40.880 --> 03:42.880
因为这两年的过程中

03:42.880 --> 03:44.880
你可能不断的去

03:44.880 --> 03:45.880
又去新建了一些文件

03:45.880 --> 03:47.880
那么这一块区域的数据

03:47.880 --> 03:48.880
可能被新的文件的数据

03:48.880 --> 03:50.880
给覆盖掉了

03:51.880 --> 03:52.880
可能还剩一点点

03:52.880 --> 03:53.880
那一点点的话

03:53.880 --> 03:54.880
那可能文件就不完整了

03:54.880 --> 03:55.880
它恢复不了

03:55.880 --> 03:56.880
所以说

03:56.880 --> 03:59.880
如果说你操作的及时

03:59.880 --> 04:00.880
你又删了文件之后

04:00.880 --> 04:01.880
你可能过了一两天

04:01.880 --> 04:03.880
你没有去建立什么新文件

04:03.880 --> 04:05.880
也没有去做什么系统更新

04:05.880 --> 04:06.880
那么这个

04:06.880 --> 04:07.880
实际上这一块东西

04:07.880 --> 04:09.880
它基本上是保处不变的

04:09.880 --> 04:10.880
这个时候你去恢复

04:10.880 --> 04:12.880
是有能力恢复的

04:12.880 --> 04:13.880
要的意思

04:13.880 --> 04:14.880
OK

04:14.880 --> 04:15.880
这是关于

04:15.880 --> 04:16.880
第一个概念

04:16.880 --> 04:18.880
文件它是一个指针

04:18.880 --> 04:19.880
那么第二个点

04:19.880 --> 04:22.880
就是关于我们文件的复制粘贴

04:22.880 --> 04:23.880
复制粘贴

04:23.880 --> 04:26.880
实际上它是有两个过程组成的

04:26.880 --> 04:27.880
它做了什么事呢

04:27.880 --> 04:29.880
比方说我们把原文件

04:29.880 --> 04:31.880
abc.txt复制

04:31.880 --> 04:32.880
粘贴到一个新的位置

04:32.880 --> 04:35.880
给它取个名字叫bcd.txt

04:35.880 --> 04:36.880
那么这样子一来

04:36.880 --> 04:37.880
它做了什么事呢

04:37.880 --> 04:39.880
它首先把磁盘里边的数据

04:39.880 --> 04:40.880
原文件它不是指向一块数据吗

04:40.880 --> 04:41.880
比方说一篇文章

04:41.880 --> 04:43.880
它先把这篇文章的数据

04:43.880 --> 04:44.880
给它复制一下

04:44.880 --> 04:46.880
放到一个磁盘的新的位置

04:46.880 --> 04:48.880
然后再去建立一个新的文件

04:48.880 --> 04:49.880
bcd.txt

04:49.880 --> 04:50.880
一般复制粘贴

04:50.880 --> 04:52.880
一般都是同样的文件名

04:52.880 --> 04:55.880
实际上是可以产生不同的文件名的

04:55.880 --> 04:58.880
当然这东西要用代码

04:58.880 --> 04:59.880
那么这里产生一个新的文件

04:59.880 --> 05:00.880
让新的文件的指针

05:00.880 --> 05:02.880
去指向新的数据

05:02.880 --> 05:04.880
所以说你复制的文件过后

05:04.880 --> 05:05.880
你去改动新的文件

05:05.880 --> 05:08.880
会不会对原来文件造成影响

05:08.880 --> 05:09.880
是不是不会

05:09.880 --> 05:11.880
不会对原来文件造成任何影响

05:11.880 --> 05:12.880
但是数据

05:12.880 --> 05:14.880
因为它多了一份数据

05:14.880 --> 05:15.880
它都是文件的拷贝

05:15.880 --> 05:17.880
也就是复制

05:17.880 --> 05:19.880
接下来说我们今天中选的那种

05:19.880 --> 05:23.880
就是关于硬链接hardlink

05:23.880 --> 05:25.880
这个概念它是来自于Unic十号座系统

05:25.880 --> 05:27.880
现在在Ninux十号座系统里面

05:27.880 --> 05:28.880
可以使用

05:28.880 --> 05:30.880
它是指的是什么意思呢

05:30.880 --> 05:33.880
它指的是有点像对象的复制的

05:33.880 --> 05:37.880
它是将一个文件的指针复制到

05:37.880 --> 05:40.880
是把指针复制到另一个文件中

05:40.880 --> 05:41.880
那么这样子

05:41.880 --> 05:43.880
我们认为另外一个文件

05:43.880 --> 05:45.880
就是之前文件的硬链接

05:45.880 --> 05:46.880
比方什么意思呢

05:46.880 --> 05:48.880
就之前一个文件A

05:48.880 --> 05:49.880
它指向一块数据

05:49.880 --> 05:53.880
如果说我用A来产生一个硬链接B

05:53.880 --> 05:54.880
什么意思呢

05:54.880 --> 05:56.880
就是B的指针跟S一样的

05:56.880 --> 05:58.880
那么B也指向这一块数据

05:58.880 --> 06:00.880
那两个文件它指向同一块数据了

06:00.880 --> 06:02.880
这就叫做硬链接

06:02.880 --> 06:04.880
我们就认为B是A的硬链接

06:04.880 --> 06:06.880
当然硬链接产生了之后

06:06.880 --> 06:08.880
一旦产生了硬链接

06:08.880 --> 06:10.880
这个B和A还有没有关系

06:10.880 --> 06:12.880
他们没有关系的

06:12.880 --> 06:14.880
通过B也可以找到这个数据

06:14.880 --> 06:15.880
就举个例子吧

06:15.880 --> 06:17.880
比方说

06:17.880 --> 06:21.190
这个文件A

06:21.190 --> 06:22.190
文件A在哪呢

06:22.190 --> 06:26.190
比方说在D盘下面的ABC这个文件下面的1.txt

06:26.190 --> 06:29.190
然后我产生一个硬链接

06:29.190 --> 06:30.190
产生在哪呢

06:30.190 --> 06:33.190
产生在D盘下面的ABC点

06:33.190 --> 06:36.190
或者是123.txt

06:36.190 --> 06:38.190
那么当你去改动这个文件的时候

06:38.190 --> 06:40.190
它是不是也会变

06:40.190 --> 06:41.190
对吧

06:41.190 --> 06:42.190
是这么个意思吧

06:42.190 --> 06:44.190
而且它产生硬�接

06:44.190 --> 06:46.190
过后你会发现了

06:46.190 --> 06:48.190
如果说我删除了其中一个文件

06:48.190 --> 06:50.190
另一个文件是否受影响

06:50.190 --> 06:51.190
不受影响

06:51.190 --> 06:52.190
文件数据会受不受影响

06:52.190 --> 06:53.190
不受影响

06:53.190 --> 06:55.190
只要你不把全部删完

06:55.190 --> 06:56.190
全部删完过后

06:56.190 --> 06:57.190
那么这个数据是不是还在

06:57.190 --> 06:58.190
还是在

06:58.190 --> 07:00.190
只是找不到了而已

07:00.190 --> 07:01.190
那么就跟之前一样

07:01.190 --> 07:02.190
如果说你把它删了

07:02.190 --> 07:03.190
它就找不到这个数据了

07:03.190 --> 07:04.190
那么有了硬链接之后

07:04.190 --> 07:05.190
你删了一个

07:05.190 --> 07:06.190
是不是另一个还在

07:06.190 --> 07:07.190
还在

07:07.190 --> 07:08.190
OK

07:08.190 --> 07:09.190
这就是硬�接

07:09.190 --> 07:11.190
你会发现到硬�接

07:11.190 --> 07:13.190
它不会产生额外的�盘占用

07:13.190 --> 07:14.190
就是磁盘杖

07:14.190 --> 07:16.190
你没有额外的开销

07:16.190 --> 07:17.190
它没有

07:17.190 --> 07:18.190
因为这两个文件都会找到

07:18.190 --> 07:19.190
相同的那种

07:19.190 --> 07:21.190
而且硬链接的数量

07:21.190 --> 07:22.190
是没有限制的

07:22.190 --> 07:23.190
比方说我可以通过文件

07:23.190 --> 07:24.190
或者是我产生一个

07:24.190 --> 07:25.190
硬链接避过后

07:25.190 --> 07:26.190
我又可以通过

07:26.190 --> 07:27.190
必来产生硬链接

07:27.190 --> 07:28.190
都无所谓

07:28.190 --> 07:29.190
因为只要硬链接

07:29.190 --> 07:30.190
也产生两个文件

07:30.190 --> 07:31.190
它就不存在说

07:31.190 --> 07:32.190
谁是谁的硬链接了

07:32.190 --> 07:33.190
不存在了

07:33.190 --> 07:34.190
因为两个文件

07:34.190 --> 07:35.190
都是一样的效果了

07:35.190 --> 07:36.190
都是完全一样的了

07:36.190 --> 07:37.190
你通过它可以找到

07:37.190 --> 07:38.190
通过它也可以找到

07:38.190 --> 07:39.190
而且它可以产生

07:39.190 --> 07:40.190
很多很多的硬链接

07:40.190 --> 07:42.190
几十个上百个上千个

07:42.190 --> 07:45.190
都不会造成额外的磁盘开销

07:45.190 --> 07:47.190
以前的Windows操作系统

07:47.190 --> 07:48.190
是不支持硬链接的

07:48.190 --> 07:49.190
所以说以前

07:49.190 --> 07:50.190
我要给产生的东西

07:50.190 --> 07:51.190
还没发现

07:51.190 --> 07:52.190
现在就可以了

07:52.190 --> 07:53.190
现在Windows操作系统

07:53.190 --> 07:54.190
从Vista开始

07:54.190 --> 07:55.190
就已经开始支持了

07:55.190 --> 07:56.190
硬链接的操作

07:56.190 --> 07:58.190
我们要在控制台中

07:58.190 --> 07:59.190
CMD

07:59.190 --> 08:00.190
这个东西不能用PowerShell

08:00.190 --> 08:01.190
因为我们现在

08:01.190 --> 08:02.190
到了文史过后

08:02.190 --> 08:03.190
我们知道

08:03.190 --> 08:04.190
控制台有两种用法

08:04.190 --> 08:06.190
一种是CMD

08:06.190 --> 08:07.190
就在这里

08:07.190 --> 08:08.190
命令提示符

08:08.190 --> 08:12.190
还有一个是 PowerShell

08:12.190 --> 08:13.190
这是两个

08:13.190 --> 08:15.190
这个是比较新的

08:15.190 --> 08:16.190
它的API

08:16.190 --> 08:17.190
能够使用的命令

08:17.190 --> 08:18.190
有些区别

08:18.190 --> 08:19.190
在这里边还可以编程

08:19.190 --> 08:20.190
它的功能要强大得多

08:20.190 --> 08:22.190
但是你要产生硬链接的话

08:22.190 --> 08:24.190
是必须要在CMD中

08:24.190 --> 08:25.190
使用命令的

08:25.190 --> 08:26.190
怎么来产生呢

08:26.190 --> 08:28.190
我给大家举个例子

08:28.190 --> 08:30.190
比方说吧

08:30.190 --> 08:31.190
就这个

08:31.190 --> 08:33.190
咱们在

08:33.190 --> 08:35.190
咱们这里不是有个路径吗

08:36.190 --> 08:37.190
有个路径

08:39.190 --> 08:40.190
我们看一下吧

08:40.190 --> 08:41.190
比方说我们在这里

08:41.190 --> 08:42.190
新建个文件

08:43.190 --> 08:45.190
新建个文件夹吧

08:45.190 --> 08:46.190
新建个文件夹

08:47.190 --> 08:49.190
叫做Temp

08:50.190 --> 08:52.190
一个临时文件夹

08:52.190 --> 08:54.190
里边有一个

08:54.190 --> 08:55.190
article

08:55.190 --> 08:56.190
一篇文章

08:56.190 --> 08:57.190
TST

08:57.190 --> 08:59.190
这是

08:59.190 --> 09:01.190
一篇文章

09:01.190 --> 09:02.190
有这么一个文本文件

09:02.190 --> 09:04.190
文本文件好演示吗

09:04.190 --> 09:05.190
接下来

09:05.190 --> 09:06.190
我要在这个目录下面

09:06.190 --> 09:07.190
跟目录下面

09:07.190 --> 09:09.190
去建立这个文件的一个硬链接

09:09.190 --> 09:10.190
怎么来建立呢

09:10.190 --> 09:12.190
我们首先打开CMD

09:12.190 --> 09:14.190
CMD

09:14.190 --> 09:15.190
这里用查照

09:15.190 --> 09:16.190
点击右键

09:16.190 --> 09:18.190
这里要用管理员身份运行

09:19.190 --> 09:21.190
现在我们要进入这个目录

09:21.190 --> 09:23.190
我们稍微放大一点

09:23.190 --> 09:24.190
字体

09:24.190 --> 09:25.190
20

09:25.190 --> 09:27.190
我们要进入这个目录

09:27.190 --> 09:28.190
怎么进入呢

09:28.190 --> 09:29.190
因为我这个在地盘

09:29.190 --> 09:30.190
所以说我先切换盘

09:30.190 --> 09:31.190
扶到地盘

09:31.190 --> 09:33.190
然后我这里点击右键

09:33.190 --> 09:34.190
复制一下吧

09:34.190 --> 09:36.190
复制路径

09:36.190 --> 09:37.190
粘贴过来

09:37.190 --> 09:39.190
CD

09:39.190 --> 09:41.190
粘贴

09:42.190 --> 09:44.190
没复制上吗

09:44.190 --> 09:45.190
复制路径

09:45.190 --> 09:46.190
粘贴

09:46.190 --> 09:47.190
点右键

09:47.190 --> 09:48.190
不行

09:48.190 --> 09:49.190
这个路径里边有特殊制服

09:49.190 --> 09:50.190
就有空格

09:50.190 --> 09:51.190
有点这些东西

09:51.190 --> 09:53.190
所以说我还要加上双银

09:53.190 --> 09:54.190
点右键

09:54.190 --> 09:55.190
就可以粘贴

09:55.190 --> 09:56.190
回车

09:56.190 --> 09:57.190
是不是进入这个目录了

09:57.190 --> 09:59.190
进入这个目录之后

09:59.190 --> 10:00.190
我们可以使用命令了

10:00.190 --> 10:01.190
什么命令的

10:02.190 --> 10:04.190
创建链接

10:04.190 --> 10:05.190
那么什么链接呢

10:05.190 --> 10:06.190
是硬链接

10:09.190 --> 10:11.190
然后后边写上两个参数

10:11.190 --> 10:12.190
一个是什么参数呢

10:12.190 --> 10:15.190
一个是你的新的文件的名称

10:15.190 --> 10:17.190
就是你链接文件的名称

10:17.190 --> 10:19.190
你的新的链接文件是什么名称

10:19.190 --> 10:21.190
比方说我给他取个名字叫做

10:23.190 --> 10:25.190
这是我的新的文件

10:25.190 --> 10:26.190
我要链接谁呢

10:26.190 --> 10:28.190
就是后面就是目标文件

10:28.190 --> 10:30.190
后边是目标文件

10:30.190 --> 10:31.190
目标文件是什么呢

10:31.190 --> 10:32.190
目标文件是

10:32.190 --> 10:35.190
我们当前目录下边的

10:35.190 --> 10:37.190
把之前关了

10:37.190 --> 10:39.190
当前目录下边的哪个呢

10:39.190 --> 10:42.190
TEMP目录下边的什么呢

10:42.190 --> 10:44.190
这些是我都忘了

10:44.190 --> 10:46.190
article.txt

10:46.190 --> 10:48.190
article.txt

10:48.190 --> 10:49.190
回车

10:51.190 --> 10:52.190
无销开关

10:52.190 --> 10:53.190
这里

10:53.190 --> 10:54.190
这个写纲要用右写纲

10:54.190 --> 10:55.190
在温州市操作系统

10:55.190 --> 10:56.190
下面要用右写纲

10:56.190 --> 10:57.190
回车

10:57.190 --> 10:59.190
那么这个时候他提示你

10:59.190 --> 11:00.190
为这个文件的

11:00.190 --> 11:01.190
创建一个硬帘阶

11:01.190 --> 11:02.190
那么这个东西

11:02.190 --> 11:03.190
跟这个东西是一样的

11:03.190 --> 11:04.190
它只剩是一样的

11:04.190 --> 11:05.190
好

11:05.190 --> 11:06.190
接下来咱们来看一下

11:06.190 --> 11:07.190
如果说

11:07.190 --> 11:08.190
你看我们的link.txt

11:08.190 --> 11:10.190
你看是不是一样的那种

11:10.190 --> 11:12.190
跟这个article是不是一样的

11:12.190 --> 11:13.190
好

11:13.190 --> 11:14.190
这里我们

11:14.190 --> 11:15.190
把它分一下

11:15.190 --> 11:16.190
分享屏吧

11:16.190 --> 11:18.190
左边我们用link

11:18.190 --> 11:21.760
你看link跟article是不是一样的

11:21.760 --> 11:23.760
而且我在link里边改东西

11:23.760 --> 11:24.760
随便写一个

11:24.760 --> 11:25.760
比方说

11:25.760 --> 11:26.760
写中英文

11:26.760 --> 11:28.760
this is a

11:28.760 --> 11:29.760
article

11:29.760 --> 11:30.760
保存

11:33.760 --> 11:35.760
重新打开一次

11:35.760 --> 11:36.760
反正反应不过来

11:36.760 --> 11:37.760
其实重新打开一次

11:37.760 --> 11:38.760
你看

11:38.760 --> 11:39.760
两个文件是不是一样的了

11:39.760 --> 11:40.760
我改其中一个

11:40.760 --> 11:41.760
另一个会受影响

11:41.760 --> 11:42.760
比方在另一个里面

11:42.760 --> 11:43.760
写个123

11:43.760 --> 11:44.760
保存

11:44.760 --> 11:45.760
到了这边来

11:45.760 --> 11:46.760
你看是不是一样的

11:46.760 --> 11:47.760
这就是硬帘阶

11:47.760 --> 11:48.760
因为他们指向的是

11:48.760 --> 11:50.760
同一块磁盘空间

11:50.760 --> 11:52.760
你在温州市操作系统下面

11:52.760 --> 11:53.760
你能不能看到一个文件

11:53.760 --> 11:54.760
是硬帘阶

11:54.760 --> 11:55.760
你看不到的

11:55.760 --> 11:56.760
因为硬帘阶

11:56.760 --> 11:57.760
操作系统

11:57.760 --> 11:58.760
并不知道

11:58.760 --> 11:59.760
这是一个硬帘阶

11:59.760 --> 12:00.760
一旦创建好了

12:00.760 --> 12:01.760
他就认为是一个普通文件了

12:01.760 --> 12:03.760
因为他指向一块数据

12:03.760 --> 12:04.760
他不知道还有别的文件

12:04.760 --> 12:06.760
会指向这个数据

12:06.760 --> 12:08.760
他就是对操作系统而言

12:08.760 --> 12:09.760
他都是普通文件

12:09.760 --> 12:10.760
那我举个例子

12:10.760 --> 12:11.760
就比方说

12:11.760 --> 12:13.760
我有一个文件

12:13.760 --> 12:14.760
是一个G

12:14.760 --> 12:15.760
一个G

12:15.760 --> 12:16.760
文件A

12:16.760 --> 12:17.760
它是一个G

12:17.760 --> 12:18.760
它是个指针

12:18.760 --> 12:20.760
指向一个G的磁盘空间

12:20.760 --> 12:21.760
那么我给他创建了

12:21.760 --> 12:23.760
一个就是硬帘阶B

12:23.760 --> 12:27.140
创建了一个硬帘阶

12:27.140 --> 12:28.140
那么你会在操作系统

12:28.140 --> 12:29.140
发现了B的大小

12:29.140 --> 12:31.140
它也是一个G

12:31.140 --> 12:32.140
那是不是整个磁盘

12:32.140 --> 12:33.140
占用了两个G呢

12:33.140 --> 12:34.140
不是

12:34.140 --> 12:35.140
就感觉很神奇

12:35.140 --> 12:36.140
A是文件是一个G

12:36.140 --> 12:37.140
B文件也是个G

12:37.140 --> 12:38.140
结果的整个磁盘

12:38.140 --> 12:39.140
它只占用了一个G

12:39.140 --> 12:41.140
因为这两个是指针

12:41.140 --> 12:42.140
在操作系统里边很难看出

12:42.140 --> 12:43.140
它是一个硬帘阶的

12:43.140 --> 12:45.140
你看不出来的

12:45.140 --> 12:47.140
OK 这是关于硬帘阶

12:48.140 --> 12:49.140
好 接下来

12:50.140 --> 12:51.140
还有这个简单说一下

12:51.140 --> 12:53.140
就是在Windows操作系统中

12:53.140 --> 12:55.140
通常你不要去跨磁盘

12:55.140 --> 12:57.140
跨越盘覆创建硬帘阶

12:57.140 --> 12:59.140
就是你在第一盘下面的文件

12:59.140 --> 13:01.140
你不要跑到C盘下面去创建硬帘阶

13:01.140 --> 13:03.140
明白的意思吗

13:03.140 --> 13:05.140
这个是不是你就慢慢的开始解释了

13:05.140 --> 13:07.140
商业科我那个NPM

13:07.140 --> 13:08.140
他们的缓存

13:08.140 --> 13:10.140
为什么在同一个磁盘的根木路

13:10.140 --> 13:11.140
解释了这个点

13:11.140 --> 13:12.140
因为种种原因

13:12.140 --> 13:14.140
距离什么原因不展开了

13:15.140 --> 13:18.140
下一个概念叫符号链接

13:18.140 --> 13:19.140
symbol link

13:19.140 --> 13:21.140
它又称为软链接

13:21.140 --> 13:22.140
什么意思呢

13:22.140 --> 13:24.140
如果说我为某一个文件

13:24.140 --> 13:25.140
或者文件夹

13:25.140 --> 13:26.140
也就是说

13:26.140 --> 13:27.140
大家还忘了说一点

13:27.140 --> 13:30.140
硬链接是不能给文件夹创建的

13:30.140 --> 13:32.140
因为文件夹它没有内容

13:32.140 --> 13:33.140
因为只有文件才有内容

13:33.140 --> 13:35.140
文件夹哪有内容

13:35.140 --> 13:37.140
文件夹是用来存放文件的

13:37.140 --> 13:39.140
文件夹它本身是没有内容的

13:39.140 --> 13:40.140
木路是没有内容的

13:40.140 --> 13:42.140
所以说木路是不能创建硬链接的

13:42.140 --> 13:44.140
好 接下来看符号链接

13:44.140 --> 13:46.140
符号链接的是为某一个文件

13:46.140 --> 13:47.140
或者文件夹

13:47.140 --> 13:50.140
符号链接是可以为文件夹创建的

13:50.140 --> 13:52.140
来创建一个符号链接

13:52.140 --> 13:54.140
比方说A创建一个符号链接B

13:54.140 --> 13:55.140
B是什么

13:55.140 --> 13:57.140
B指向的不是A指向的东西

13:57.140 --> 13:59.140
而是B直接指向A

13:59.140 --> 14:01.140
那么这个无论A是啥

14:01.140 --> 14:03.140
A是一个文件 还有指向文件

14:03.140 --> 14:04.140
A是一个木路 它就指向木路

14:04.140 --> 14:06.140
随便

14:06.140 --> 14:07.140
那么这样子

14:07.140 --> 14:09.140
比方说文件A它是一个文件

14:09.140 --> 14:11.140
那么B是一个软链接

14:11.140 --> 14:12.140
就是要做符号链接

14:12.140 --> 14:14.140
那么B就指向A

14:16.140 --> 14:18.140
那么其实从土里边你可以看到

14:18.140 --> 14:20.140
这个就是

14:20.140 --> 14:22.140
它有什么样的特点的

14:22.140 --> 14:23.140
如果A不建了

14:23.140 --> 14:24.140
那B还有效吗

14:24.140 --> 14:25.140
B就无效了

14:25.140 --> 14:26.140
对吧

14:26.140 --> 14:27.140
因为B指向了A

14:27.140 --> 14:28.140
你把A够够搞没了

14:28.140 --> 14:29.140
B指向谁呢

14:29.140 --> 14:30.140
对不对

14:30.140 --> 14:31.140
如果说你把A删了

14:31.140 --> 14:32.140
B就无效了

14:32.140 --> 14:34.140
但是之前的硬链接里边

14:34.140 --> 14:35.140
如果A删了B还有效

14:35.140 --> 14:36.140
它照样有效

14:36.140 --> 14:37.140
对吧 就是它们的区别

14:37.140 --> 14:39.140
就是软链接

14:39.140 --> 14:40.140
好

14:40.140 --> 14:41.140
那么在文件式操作系统里

14:41.140 --> 14:43.140
要怎么来创建一个

14:43.140 --> 14:44.140
软链接呢

14:44.140 --> 14:46.140
就是符号链接呢

14:46.140 --> 14:47.140
我这里写错了

14:47.140 --> 14:49.140
应该是创建

14:49.140 --> 14:52.830
符号链接

14:52.830 --> 14:54.830
所以是创建符号链接

14:54.830 --> 14:56.830
我这里写错了

14:56.830 --> 14:57.830
重新保存一次

14:57.830 --> 15:02.170
OK

15:02.170 --> 15:03.170
好 创建符号链接

15:03.170 --> 15:05.170
还是使用MKLink

15:05.170 --> 15:06.170
斜杠D

15:06.170 --> 15:07.170
斜杠D

15:07.170 --> 15:08.170
然后同样的链接名称

15:08.170 --> 15:09.170
目标文件

15:09.170 --> 15:10.170
当然可以是目标文件

15:10.170 --> 15:11.170
也可以是目录

15:11.170 --> 15:13.170
比方说举个例子

15:13.170 --> 15:14.170
我又到这来

15:14.170 --> 15:16.170
比方说我们到地盘

15:16.170 --> 15:19.480
回到地盘

15:19.480 --> 15:20.480
回到地盘

15:20.480 --> 15:21.480
地盘让我们看一下

15:21.480 --> 15:22.480
DNR哪些目录呢

15:22.480 --> 15:24.480
比方说我为这个目录

15:24.480 --> 15:25.480
为这个

15:25.480 --> 15:26.480
Repository

15:26.480 --> 15:28.480
为这个目录创建一个

15:28.480 --> 15:29.480
创建一个什么呢

15:29.480 --> 15:32.480
创建一个就是符号链接

15:32.480 --> 15:34.480
比方说

15:34.480 --> 15:37.480
咱们可以使用MKLink

15:37.480 --> 15:39.480
斜杠D

15:39.480 --> 15:40.480
因为这个加不加斜杠D

15:40.480 --> 15:42.480
关键是你看你要为文件创建

15:42.480 --> 15:44.480
还是为目录创建

15:44.480 --> 15:45.480
比方说你要为目录创建

15:45.480 --> 15:47.480
符号链接就加上斜杠D

15:47.480 --> 15:48.480
如果说你要为文件

15:48.480 --> 15:49.480
创建符号链接

15:49.480 --> 15:50.480
那就不加

15:50.480 --> 15:52.480
因为我这里是目录

15:52.480 --> 15:54.480
符号链接让一般使用来

15:54.480 --> 15:56.480
对目录创建的

15:56.480 --> 15:57.480
斜杠D

15:57.480 --> 15:59.480
然后这里使用

15:59.480 --> 16:01.480
链接的名称Link

16:01.480 --> 16:02.480
就用Link吧

16:02.480 --> 16:05.480
然后链接的就是目标

16:05.480 --> 16:07.480
目标是什么呢

16:07.480 --> 16:09.480
Repository

16:09.480 --> 16:11.480
好,那么现在就创建好了

16:11.480 --> 16:13.480
那么我Link创建一个链接

16:13.480 --> 16:14.480
那么这个链接的是

16:14.480 --> 16:16.480
链接到Repository

16:16.480 --> 16:18.480
好,咱们到这个目录里面

16:18.480 --> 16:19.480
去看一下

16:19.480 --> 16:21.790
到这个地盘

16:21.790 --> 16:23.790
你看一下,是不是多了一个Link

16:23.790 --> 16:25.790
那么这个Link的图标

16:25.790 --> 16:26.790
来看一下

16:26.790 --> 16:27.790
我给大家放大一点

16:27.790 --> 16:28.790
中型图标

16:28.790 --> 16:29.790
那么这个Link的图标

16:29.790 --> 16:30.790
是不是有一个箭头

16:30.790 --> 16:32.790
那么通过这个图标

16:32.790 --> 16:33.790
大家可以知道

16:33.790 --> 16:34.790
原来这是个链接

16:34.790 --> 16:35.790
这是个符号链接

16:35.790 --> 16:36.790
像那种硬链接

16:36.790 --> 16:37.790
它是没有这个箭头的

16:37.790 --> 16:40.790
因为硬链接就是一个普通的文件

16:40.790 --> 16:42.790
它就是直接链接到数据的

16:42.790 --> 16:44.790
所以说它不会有这些图标

16:44.790 --> 16:46.790
它就是一个普通的文件

16:46.790 --> 16:47.790
但是符号链接不一样

16:47.790 --> 16:49.790
符号链接是链接到另一个目录的

16:49.790 --> 16:50.790
链接到哪个目录

16:50.790 --> 16:51.790
链接到这个目录

16:51.790 --> 16:52.790
Repository

16:52.790 --> 16:54.790
当我们进这个目录的时候

16:54.790 --> 16:55.790
实际上进的是哪个目录

16:55.790 --> 16:57.790
实际上进的是Repository这个目录

16:57.790 --> 16:58.790
听懂了吧

16:58.790 --> 17:00.790
这是关于符号链接

17:02.790 --> 17:03.790
下一个

17:03.790 --> 17:04.790
就是符号链接

17:04.790 --> 17:05.790
简单说一下

17:05.790 --> 17:07.790
符号链接和硬链接的区别

17:07.790 --> 17:08.790
这些东西都是后端

17:08.790 --> 17:10.790
后端的开发者需要考的

17:10.790 --> 17:11.790
一个是硬链接

17:11.790 --> 17:12.790
它只能链接文件

17:12.790 --> 17:13.790
符号链接可以链接目录

17:13.790 --> 17:15.790
硬链接在链接完之后

17:15.790 --> 17:17.790
可以跟文件那种关联

17:17.790 --> 17:18.790
你看

17:18.790 --> 17:19.790
链接完了过

17:19.790 --> 17:20.790
是跟文件那种关联的

17:20.790 --> 17:21.790
跟之前的文件还有没有关系

17:21.790 --> 17:22.790
没有关系

17:22.790 --> 17:23.790
所以之前的文件

17:23.790 --> 17:25.790
怎么样操作跟它没关系的

17:25.790 --> 17:26.790
而符号链接的

17:26.790 --> 17:29.790
始终是跟之前的文件关联

17:29.790 --> 17:31.790
和文件内容不直接相关

17:31.790 --> 17:32.790
就通过它

17:32.790 --> 17:33.790
是链接到它

17:33.790 --> 17:34.790
那么它是链接到哪

17:34.790 --> 17:35.790
跟我没关系

17:35.790 --> 17:36.790
我反正我就找你

17:36.790 --> 17:37.790
你去链接到哪

17:37.790 --> 17:38.790
我无所谓

17:38.790 --> 17:40.790
这是他们两个的区别

17:41.790 --> 17:42.790
好 最后我说一下

17:42.790 --> 17:43.790
关于这个快捷方式

17:43.790 --> 17:44.790
这个东西

17:44.790 --> 17:46.790
其实跟本节合没有关系

17:46.790 --> 17:47.790
但是有可能有些同学

17:47.790 --> 17:48.790
会想到

17:48.790 --> 17:49.790
因为前面的符号链接

17:49.790 --> 17:51.790
就特别像一个快捷方式

17:51.790 --> 17:52.790
实际上是不是呢

17:52.790 --> 17:53.790
实际上差不多

17:53.790 --> 17:54.790
快捷方式其实就是

17:54.790 --> 17:55.790
类似于符号链接

17:55.790 --> 17:57.790
也就是它指向一个目录

17:57.790 --> 17:58.790
或者指向一个文件

17:58.790 --> 17:59.790
那么

17:59.790 --> 18:00.790
这是Windows系统

18:00.790 --> 18:02.790
早期就支持的链接方式

18:02.790 --> 18:03.790
最早的时候

18:03.790 --> 18:05.790
它就支持这个就是快捷方式

18:05.790 --> 18:06.790
它不仅仅的

18:06.790 --> 18:08.790
快捷方式跟那个就是

18:08.790 --> 18:09.790
符号链接的

18:09.790 --> 18:11.790
不太一样的地方就在于

18:11.790 --> 18:12.790
快捷方式它不仅仅

18:12.790 --> 18:13.790
需要记录一个指针

18:13.790 --> 18:14.790
指向其他文件

18:14.790 --> 18:15.790
或者目录

18:15.790 --> 18:16.790
你看

18:16.790 --> 18:17.790
是不是指向其他文件

18:17.790 --> 18:18.790
或者目录指过来

18:18.790 --> 18:19.790
对吧

18:19.790 --> 18:20.790
它启动还是包含别的信息

18:20.790 --> 18:21.790
比方说全线

18:21.790 --> 18:23.790
比方说兼容性启动方式

18:23.790 --> 18:25.790
等其同各种属性

18:25.790 --> 18:26.790
就是Windows系统

18:26.790 --> 18:28.790
Windows系统搞出来的东西

18:28.790 --> 18:29.790
这个玩意

18:29.790 --> 18:31.790
因为它只是Windows系统独有的

18:31.790 --> 18:32.790
也不要其他系统里面

18:32.790 --> 18:33.790
没有这个玩意

18:33.790 --> 18:34.790
只是Windows系统里面

18:34.790 --> 18:35.790
搞出来的东西

18:35.790 --> 18:36.790
所以说呢

18:36.790 --> 18:37.790
一般来说

18:37.790 --> 18:38.790
你编程的话

18:38.790 --> 18:39.790
你要考虑一个程序

18:39.790 --> 18:41.790
你要在各个系统里面

18:41.790 --> 18:42.790
到兼容的话

18:42.790 --> 18:43.790
一般不太会去使用

18:43.790 --> 18:45.790
快捷方式这个东西

18:45.790 --> 18:46.790
不太会去使用它

18:46.790 --> 18:47.790
当然了

18:47.790 --> 18:48.790
如果说你指挥Windows开发的话

18:48.790 --> 18:50.790
你需要做类似的效果的话

18:50.790 --> 18:52.790
你可以考虑快捷方式

18:52.790 --> 18:53.790
OK

18:53.790 --> 18:54.790
好

18:54.790 --> 18:55.790
后边重点

18:55.790 --> 18:59.790
Node环境对应链接和符号链接的处理

18:59.790 --> 19:01.790
就是在我们Node解释单码

19:01.790 --> 19:02.790
它对应链接和符号链接

19:02.790 --> 19:03.790
只怎么处理的

19:03.790 --> 19:04.790
它是这样子

19:04.790 --> 19:05.790
应链接的

19:05.790 --> 19:06.790
它本身就是一个

19:06.790 --> 19:07.790
实实在在的文件

19:07.790 --> 19:08.790
通过这个文件的指针

19:08.790 --> 19:09.790
是不是找到文件内容

19:09.790 --> 19:10.790
对吧

19:10.790 --> 19:11.790
所以Node它根本就没法

19:11.790 --> 19:12.790
对它进行测试处理

19:12.790 --> 19:13.790
它就是一个普通的文件

19:13.790 --> 19:15.790
它没有办法区别对待

19:15.790 --> 19:16.790
Node根本就不知道

19:16.790 --> 19:17.790
这个文件是不是一个应链接

19:17.790 --> 19:18.790
它完全不知道

19:18.790 --> 19:20.790
它就是一个普通文件

19:20.790 --> 19:21.790
就是普通文件而已

19:21.790 --> 19:22.790
所以应链接它不存在

19:22.790 --> 19:23.790
所以有什么差异

19:23.790 --> 19:24.790
跟之前一样的

19:24.790 --> 19:25.790
比方说你来这里

19:25.790 --> 19:26.790
来接了一个文件

19:26.790 --> 19:27.790
对吧

19:27.790 --> 19:28.790
刚才我们用了应链接

19:28.790 --> 19:29.790
来这里接了一个文件

19:29.790 --> 19:30.790
你用Node去读

19:30.790 --> 19:31.790
它能读到

19:31.790 --> 19:32.790
能读到

19:32.790 --> 19:33.790
一点问题都没有

19:33.790 --> 19:34.790
因为它就是个普通文件

19:34.790 --> 19:35.790
你要说现在

19:35.790 --> 19:36.790
比方说我现在

19:36.790 --> 19:37.790
我不告诉你之前

19:37.790 --> 19:39.790
我是怎么来创建应链接的

19:39.790 --> 19:40.790
你告诉我哪个文件是应链接

19:40.790 --> 19:41.790
哪个文件不是

19:41.790 --> 19:42.790
是原始文件了

19:42.790 --> 19:43.790
原始文件了

19:43.790 --> 19:44.790
你说得出来吗

19:44.790 --> 19:45.790
说不出来

19:45.790 --> 19:46.790
因为这两个文件

19:46.790 --> 19:47.790
是一样的

19:47.790 --> 19:48.790
都指向文件那种

19:48.790 --> 19:49.790
它是一个普通的文件

19:49.790 --> 19:50.790
所以它不可能

19:50.790 --> 19:51.790
说于什么区别对待

19:51.790 --> 19:53.790
但符号链接就不一样了

19:53.790 --> 19:54.790
符号链接

19:54.790 --> 19:55.790
它指向的是

19:55.790 --> 19:56.790
你别人的位置

19:56.790 --> 19:59.790
它自己只是一个符号

19:59.790 --> 20:00.790
它指向别人的位置

20:00.790 --> 20:01.790
所以Node

20:01.790 --> 20:03.790
它读到符号链接的时候

20:03.790 --> 20:05.790
如果说符号链接下面

20:05.790 --> 20:06.790
有一些介石文件

20:06.790 --> 20:07.790
那么它在运行

20:07.790 --> 20:08.790
介石文件的时候

20:08.790 --> 20:10.790
它的环境是原始路径

20:10.790 --> 20:11.790
这是什么意思

20:12.790 --> 20:13.790
为大家举个例子

20:14.790 --> 20:15.790
接下来我们

20:17.790 --> 20:19.790
在Tempo里边

20:19.790 --> 20:21.790
我们新建个文件夹

20:21.790 --> 20:22.790
比如

20:23.790 --> 20:25.790
里边写上一个Adder介石

20:25.790 --> 20:27.790
然后Tempo文件夹下面

20:28.790 --> 20:29.790
有个B点介石

20:31.790 --> 20:32.790
接下来

20:32.790 --> 20:33.790
我们来看一下

20:33.790 --> 20:34.790
一些比较有趣的效果

20:34.790 --> 20:35.790
我在B点介石里边

20:35.790 --> 20:36.790
导出一个东西

20:36.790 --> 20:38.790
March is port

20:38.790 --> 20:39.790
导出一个什么

20:39.790 --> 20:40.790
就导出一个B

20:43.170 --> 20:44.170
A这个介石里边

20:44.170 --> 20:46.170
我们要获取B的内容

20:46.170 --> 20:47.170
该怎么获取

20:47.170 --> 20:48.170
是不是Require

20:48.170 --> 20:49.170
对吧

20:50.170 --> 20:51.170
返回上一级目录

20:51.170 --> 20:52.170
对吧 是不是获取B

20:52.170 --> 20:53.170
返回上一级目录

20:53.170 --> 20:54.170
因为它在上一级目录

20:54.170 --> 20:55.170
对吧

20:55.170 --> 20:56.170
上一级目录获取B

20:56.170 --> 20:57.170
那么拿到B导出的内容

20:57.170 --> 21:01.170
那么输出B模块的内容

21:01.170 --> 21:02.170
是什么呢

21:02.170 --> 21:03.170
是B

21:03.170 --> 21:04.170
没问题吧

21:04.170 --> 21:06.170
好 咱们来执行一下

21:06.170 --> 21:07.170
执行一下

21:07.170 --> 21:09.170
Node 哪个地方呢

21:09.170 --> 21:10.170
Temp

21:10.170 --> 21:11.170
下面的sub

21:11.170 --> 21:13.170
下面的A点介石

21:13.170 --> 21:14.170
返回上

21:14.170 --> 21:15.170
可以达到B模块的内容

21:15.170 --> 21:16.170
这个没问题吧

21:16.170 --> 21:17.170
很简单

21:17.170 --> 21:19.170
它们相当陆近

21:19.170 --> 21:20.170
然后呢

21:20.170 --> 21:21.170
A模块里面

21:21.170 --> 21:22.170
我们再写一句代码

21:22.170 --> 21:23.170
这句代码很有意思

21:23.170 --> 21:25.170
它是输出这么一个

21:25.170 --> 21:26.170
权聚辩量

21:26.170 --> 21:28.170
这是个权聚辩量

21:28.170 --> 21:30.170
相对于是Global

21:30.170 --> 21:31.170
权聚辩量

21:31.170 --> 21:32.170
权聚对象

21:32.170 --> 21:33.170
Global里边的属性

21:33.170 --> 21:35.170
两个下滑线DRN

21:35.170 --> 21:36.170
什么意思呢

21:36.170 --> 21:37.170
这个表示

21:37.170 --> 21:38.170
这个文件

21:38.170 --> 21:39.170
就是这个代码运行的

21:39.170 --> 21:41.170
当前目录是什么

21:41.170 --> 21:42.170
我们运行

21:42.170 --> 21:43.170
因为看到

21:43.170 --> 21:44.170
这一块呢

21:44.170 --> 21:45.170
是哪里

21:45.170 --> 21:46.170
也是这一块输出的

21:46.170 --> 21:47.170
上面这一块

21:47.170 --> 21:48.170
你看一下

21:48.170 --> 21:49.170
好好看一下这个

21:49.170 --> 21:50.170
结构

21:50.170 --> 21:51.170
前面有什么地盘

21:51.170 --> 21:52.170
那就不用看

21:52.170 --> 21:53.170
主要看这

21:53.170 --> 21:54.170
什么保管理工具

21:54.170 --> 21:55.170
原码

21:55.170 --> 21:56.170
在其他保管理系里

21:56.170 --> 21:57.170
你看是不是

21:57.170 --> 21:58.170
对影子2

21:58.170 --> 21:59.170
4-4

21:59.170 --> 22:00.170
Temp sub

22:00.170 --> 22:01.170
Temp sub

22:01.170 --> 22:02.170
那么它输出的目录

22:02.170 --> 22:03.170
是不是

22:03.170 --> 22:04.170
就是当前这个A运行的目录

22:04.170 --> 22:05.170
对吧

22:05.170 --> 22:06.170
运行的目录

22:06.170 --> 22:08.170
现在下面有意识都来了

22:09.170 --> 22:10.170
我现在呢

22:10.170 --> 22:11.170
做这么一件事

22:12.170 --> 22:14.170
如果说我对A

22:14.170 --> 22:15.170
使用硬链接

22:15.170 --> 22:17.170
把它链接到这个根目录

22:17.170 --> 22:18.170
看会怎么样

22:20.170 --> 22:21.170
我们先进入这个目录

22:21.170 --> 22:22.170
复制一下途径

22:23.170 --> 22:24.170
CD

22:24.170 --> 22:28.950
CD是没法清楚的

22:28.950 --> 22:29.950
然后呢

22:29.950 --> 22:30.950
我们这里

22:30.950 --> 22:31.950
使用硬链接

22:31.950 --> 22:32.950
MK link

22:32.950 --> 22:33.950
硬链接是吗

22:33.950 --> 22:34.950
A-H

22:34.950 --> 22:35.950
A.js

22:35.950 --> 22:36.950
目标位置呢

22:36.950 --> 22:37.950
Temp

22:37.950 --> 22:38.950
下边的

22:39.950 --> 22:40.950
A.js

22:40.950 --> 22:41.950
那么这里是不是建立了

22:41.950 --> 22:42.950
A.js

22:42.950 --> 22:43.950
那么我们使用的是

22:43.950 --> 22:44.950
硬链接

22:44.950 --> 22:46.950
看一下硬链接会怎么样

22:48.950 --> 22:49.950
我们在这里运行

22:49.950 --> 22:50.950
根目录下面的

22:50.950 --> 22:51.950
A.js

22:51.950 --> 22:52.950
会怎么样

22:52.950 --> 22:54.950
你首先看

22:54.950 --> 22:56.950
是不是出问题了

22:56.950 --> 22:58.950
A.js里面

22:58.950 --> 22:59.950
你看

22:59.950 --> 23:00.950
这一块内容读不出不了

23:00.950 --> 23:02.950
因为它把它当成一个普通文件

23:02.950 --> 23:03.950
它就是一个普通文件

23:03.950 --> 23:05.950
它要返回上级目录去找B

23:05.950 --> 23:06.950
上级目录是不是这

23:07.950 --> 23:08.950
下面有B吗

23:08.950 --> 23:09.950
就找不到

23:09.950 --> 23:10.950
就要出问题

23:10.950 --> 23:12.950
如果说我把这两行注释了

23:13.950 --> 23:14.950
注释了的话

23:14.950 --> 23:16.950
当然这里边也跟着注释了

23:16.950 --> 23:18.950
他们是同一个文件

23:18.950 --> 23:19.950
只相同一会

23:19.950 --> 23:21.950
然后现在我们再去运行

23:21.950 --> 23:22.950
你看输出了目录

23:22.950 --> 23:24.950
是不是这个目录了

23:24.950 --> 23:25.950
对吧

23:25.950 --> 23:26.950
是不是这个目录了

23:26.950 --> 23:27.950
也就是硬链接

23:27.950 --> 23:28.950
好

23:28.950 --> 23:29.950
今天我们用符号链接看一下

23:29.950 --> 23:30.950
就好玩了

23:30.950 --> 23:31.950
我们把这个去掉

23:31.950 --> 23:32.950
把这个硬�接

23:32.950 --> 23:33.950
把这个文件删除

23:33.950 --> 23:34.950
它删除会不会

23:34.950 --> 23:35.950
把整个文件内容删除

23:35.950 --> 23:36.950
因为它这里边还有

23:36.950 --> 23:37.950
这里边还有

23:38.950 --> 23:40.950
接下来我们用符号链接

23:40.950 --> 23:41.950
我链接

23:41.950 --> 23:43.950
我把这个文件夹

23:43.950 --> 23:45.950
链接到这个跟目录下边

23:45.950 --> 23:46.950
看着

23:46.950 --> 23:47.950
我们这样子

23:47.950 --> 23:48.950
mklink

23:48.950 --> 23:49.950
符号链接

23:49.950 --> 23:50.950
链接文件夹

23:50.950 --> 23:52.950
然后把链接到哪呢

23:52.950 --> 23:54.950
链接到link这个目录下面

23:54.950 --> 23:55.950
然后链接到哪呢

23:55.950 --> 23:57.950
链接到tempo sub这个目录

23:58.950 --> 23:59.950
接下来有意思了

24:00.950 --> 24:01.950
你看

24:01.950 --> 24:02.950
这个link

24:02.950 --> 24:03.950
你看这里一个箭头

24:03.950 --> 24:04.950
它是个符号链接

24:04.950 --> 24:05.950
link下面有个adder接式

24:05.950 --> 24:06.950
看没

24:06.950 --> 24:07.950
对吧

24:07.950 --> 24:08.950
但是它是符号链接

24:08.950 --> 24:09.950
这个文件夹是符号链接

24:09.950 --> 24:10.950
它链接到哪呢

24:10.950 --> 24:11.950
链接到是不是这个

24:11.950 --> 24:12.950
sub文件夹

24:12.950 --> 24:13.950
接下来有意思了

24:14.950 --> 24:15.950
我们去运行哪个呢

24:15.950 --> 24:19.950
运行link下面的adder接式

24:20.950 --> 24:21.950
看一下能不能正常运行

24:22.950 --> 24:23.950
有发现它能正常运行

24:24.950 --> 24:26.950
这就是我要说的

24:26.950 --> 24:29.950
路德他对符号链接的处理方式

24:30.950 --> 24:32.950
他最终运行代码的时候

24:32.950 --> 24:33.950
就在运行代码的时候

24:33.950 --> 24:34.950
代码环境里边

24:34.950 --> 24:37.950
他仍然把它当成是原始的路径

24:37.950 --> 24:39.950
而不是符号链接的路径

24:39.950 --> 24:40.950
虽然说你通过符号链接

24:40.950 --> 24:41.950
能不能找到这个文件

24:41.950 --> 24:42.950
能

24:42.950 --> 24:44.950
但是他在运行的过程中

24:44.950 --> 24:45.950
他代码他认为

24:45.950 --> 24:46.950
他的运行的环境

24:46.950 --> 24:48.950
是原始的路径环境

24:48.950 --> 24:50.950
而不是以符号链接

24:50.950 --> 24:51.950
找过来的环境

24:51.950 --> 24:52.950
对吧

24:52.950 --> 24:53.950
这个很重要的

24:53.950 --> 24:54.950
这句有点类似于什么呢

24:54.950 --> 24:56.950
有点类似于你们玩游戏

24:57.950 --> 24:58.950
玩游戏

24:58.950 --> 24:59.950
玩游戏比方说你游戏

24:59.950 --> 25:00.950
安在哪呢

25:00.950 --> 25:01.950
安在地盘

25:01.950 --> 25:02.950
比方说

25:02.950 --> 25:03.950
Games

25:03.950 --> 25:05.950
然后有个什么

25:05.950 --> 25:06.950
游戏

25:06.950 --> 25:08.950
有个Games

25:08.950 --> 25:09.950
有个游戏的目录下面

25:09.950 --> 25:10.950
有很多文件

25:10.950 --> 25:12.950
还有什么Games.data文件

25:12.950 --> 25:14.950
Games.dll文件

25:14.950 --> 25:15.950
一大堆

25:15.950 --> 25:16.950
然后有一个什么呢

25:16.950 --> 25:17.950
Luo

25:17.950 --> 25:19.950
一个11文件

25:19.950 --> 25:21.950
是不是有一个游戏文件

25:21.950 --> 25:23.950
游戏文件的话

25:23.950 --> 25:24.950
你可以把这个文件

25:24.950 --> 25:25.950
是不是发生一个快捷

25:25.950 --> 25:26.950
方式到桌面

25:26.950 --> 25:27.950
对吧

25:27.950 --> 25:28.950
在桌面

25:28.950 --> 25:29.950
桌面上运行

25:29.950 --> 25:31.950
是不是放了一个快捷方式

25:31.950 --> 25:33.950
快捷方式

25:33.950 --> 25:35.950
是不是就相当于是符号链接

25:35.950 --> 25:36.950
符号链接方过来

25:36.950 --> 25:38.950
但是你在运行这个文件的时候

25:38.950 --> 25:39.950
它是按照哪个目录运行的

25:39.950 --> 25:40.950
是按照这个目录运行的

25:40.950 --> 25:41.950
你想

25:41.950 --> 25:42.950
如果说按照桌面的目录运行

25:42.950 --> 25:44.950
桌面目录是不是少了很多信息

25:44.950 --> 25:45.950
什么数据文件

25:45.950 --> 25:46.950
冬天连接库

25:46.950 --> 25:47.950
是不是这些东西都不存在

25:47.950 --> 25:48.950
那它怎么运行的

25:48.950 --> 25:49.950
对吧

25:49.950 --> 25:50.950
所以说它运行的环境

25:50.950 --> 25:52.950
一定是它原式的环境

25:52.950 --> 25:53.950
就这么个意思

25:53.950 --> 25:55.950
产生符号链接过后

25:55.950 --> 25:56.950
它能不能找到这个文件

25:56.950 --> 25:57.950
但是呢

25:57.950 --> 25:58.950
它运行的环境

25:58.950 --> 25:59.950
一定是它原式的目录

25:59.950 --> 26:00.950
你看这个原式的目录

26:00.950 --> 26:01.950
打印出来了

26:01.950 --> 26:02.950
仍然得到并不快的那种

26:02.950 --> 26:03.950
你看

26:03.950 --> 26:04.950
如果说用新目录

26:04.950 --> 26:05.950
新目录的话

26:05.950 --> 26:06.950
那么你看一下

26:06.950 --> 26:07.950
这个上面

26:07.950 --> 26:08.950
上一个目录是不是这个目录

26:08.950 --> 26:09.950
这个目录下面有并吗

26:09.950 --> 26:10.950
是不是没有并

26:10.950 --> 26:11.950
是没有并

26:11.950 --> 26:12.950
所以说呢

26:12.950 --> 26:13.950
这个大家要理解

26:13.950 --> 26:15.950
符号链接和运行链接

26:15.950 --> 26:18.950
在程序执行的时候的差异

26:18.950 --> 26:19.950
好

26:19.950 --> 26:20.950
接下来

26:20.950 --> 26:22.950
开始拼NPM的原理了

26:22.950 --> 26:23.950
这一部分

26:23.950 --> 26:24.950
我告诉大家

26:24.950 --> 26:25.950
比较的蓝

26:25.950 --> 26:26.950
比较的绕

26:26.950 --> 26:27.950
特别特别绕

26:28.950 --> 26:29.950
但是呢

26:29.950 --> 26:30.950
大家可以听一听

26:30.950 --> 26:31.950
听着玩

26:31.950 --> 26:32.950
这一块呢

26:32.950 --> 26:33.950
它想了很多的办法

26:33.950 --> 26:34.950
来解决这个问题

26:34.950 --> 26:36.950
而且它解的办法

26:36.950 --> 26:37.950
很巧妙

26:37.950 --> 26:38.950
当然巧妙

26:38.950 --> 26:39.950
你要能听懂

26:39.950 --> 26:40.950
当然

26:41.950 --> 26:42.950
第一次听起来

26:42.950 --> 26:43.950
肯定比较绕

26:43.950 --> 26:44.950
当然听一听听着玩

26:44.950 --> 26:45.950
反正这个东西

26:45.950 --> 26:46.950
给你们就业

26:46.950 --> 26:48.950
也没有什么

26:48.950 --> 26:49.950
也没什么帮助

26:49.950 --> 26:50.950
就前面的知识了

26:50.950 --> 26:51.950
了解一下

26:51.950 --> 26:52.950
对你们开门

26:52.950 --> 26:53.950
你们事业有帮助

26:53.950 --> 26:54.950
那么这一块

26:54.950 --> 26:55.950
就听着玩了

26:55.950 --> 26:56.950
听到这了

26:56.950 --> 26:57.950
这个构建方式呢

26:57.950 --> 26:59.950
我这里打算手动来

26:59.950 --> 27:00.950
做一次

27:00.950 --> 27:01.950
就是不用拼NPM

27:01.950 --> 27:02.950
我看一下

27:02.950 --> 27:03.950
它到底要搭

27:03.950 --> 27:04.950
因为拼NPM

27:04.950 --> 27:05.950
它的做法呢

27:05.950 --> 27:06.950
其实什么瞎载

27:06.950 --> 27:07.950
包袜那些都是一样的

27:07.950 --> 27:08.950
无非就是构建一个

27:08.950 --> 27:09.950
特别特殊的

27:09.950 --> 27:10.950
漏断码90目录

27:10.950 --> 27:11.950
是不是就构建这么一个目录

27:11.950 --> 27:12.950
一个特别特殊的

27:12.950 --> 27:13.950
漏断码90目录

27:13.950 --> 27:15.950
那么它怎么来构建的

27:15.950 --> 27:16.950
那么现在呢

27:16.950 --> 27:17.950
假设有两个包

27:17.950 --> 27:18.950
一个包A

27:18.950 --> 27:19.950
和一个包B

27:19.950 --> 27:20.950
A呢

27:20.950 --> 27:21.950
依赖B

27:21.950 --> 27:22.950
好我们在这里

27:22.950 --> 27:23.950
都可以

27:23.950 --> 27:24.950
直接写上两个包

27:24.950 --> 27:25.950
来吧

27:25.950 --> 27:26.950
我们呢

27:26.950 --> 27:27.950
在哪里写呢

27:28.950 --> 27:29.950
我们就

27:30.950 --> 27:31.950
在哪里写

27:32.950 --> 27:33.950
我们就在这吧

27:33.950 --> 27:34.950
地盘的跟目录下边

27:34.950 --> 27:36.950
跟目录下边去

27:36.950 --> 27:37.950
但是我在地盘

27:37.950 --> 27:39.950
跟目录下边写呢

27:39.950 --> 27:40.950
你们呢

27:40.950 --> 27:42.950
又不是很容易看得到

27:42.950 --> 27:43.950
那么我们在这吧

27:44.950 --> 27:45.950
这里

27:45.950 --> 27:46.950
这里

27:46.950 --> 27:47.950
这里呢

27:47.950 --> 27:48.950
我们新建个目录

27:48.950 --> 27:49.950
新建个目录

27:49.950 --> 27:50.950
表示catch

27:50.950 --> 27:51.950
catch

27:51.950 --> 27:52.950
这个目录

27:52.950 --> 27:53.950
这里呢

27:53.950 --> 27:54.950
那么新建一个文件夹

27:55.950 --> 27:56.950
新建个文件夹

27:56.950 --> 27:57.950
比方说A这个包

27:57.950 --> 27:58.950
A这个包

27:58.950 --> 27:59.950
然后呢

27:59.950 --> 28:00.950
有一个B这个包

28:00.950 --> 28:01.950
是不是有两个文件夹

28:01.950 --> 28:02.950
对吧

28:02.950 --> 28:03.950
分别来表示两个包

28:03.950 --> 28:04.950
对比方说

28:04.950 --> 28:05.950
我们要

28:05.950 --> 28:07.950
这是互联网上的

28:07.950 --> 28:09.950
互联网上的两个包

28:09.950 --> 28:10.950
比方说我们这里是

28:11.950 --> 28:12.950
来自于哪呢

28:12.950 --> 28:13.950
这个包来自于

28:14.950 --> 28:15.950
这里

28:15.950 --> 28:16.950
比方说来自于

28:18.950 --> 28:19.950
NPM

28:19.950 --> 28:20.950
来自于NPM

28:20.950 --> 28:21.950
或者是来自于

28:21.950 --> 28:22.950
淘宝

28:22.950 --> 28:23.950
淘宝

28:23.950 --> 28:24.950
哎呦

28:24.950 --> 28:25.950
改不过来了

28:25.950 --> 28:26.950
改不过来算了吧

28:26.950 --> 28:27.950
好

28:27.950 --> 28:28.950
然后呢

28:28.950 --> 28:29.950
A里边有个GS

28:29.950 --> 28:30.950
index的GS

28:30.950 --> 28:31.950
它要用到什么呢

28:31.950 --> 28:32.950
要用到B

28:32.950 --> 28:33.950
也就是它里边

28:33.950 --> 28:34.950
要require什么呢

28:34.950 --> 28:36.950
要requireB

28:36.950 --> 28:37.950
对吧

28:37.950 --> 28:38.950
它有这么一个代码

28:38.950 --> 28:40.950
拿到B里边的东西

28:40.950 --> 28:42.950
那么这里输出

28:42.950 --> 28:44.950
我是M模块

28:44.950 --> 28:48.950
得到B模块的内容

28:48.950 --> 28:49.950
是什么呢

28:49.950 --> 28:50.950
是B

28:50.950 --> 28:51.950
OK

28:51.950 --> 28:52.950
B模块

28:52.950 --> 28:53.950
B模块呢

28:53.950 --> 28:54.950
B模块呢

28:54.950 --> 28:55.950
我们这里

28:55.950 --> 28:57.950
写一个index的GS

28:57.950 --> 28:58.950
B模块呢

28:58.950 --> 28:59.950
我们就export

28:59.950 --> 29:01.950
导出一个就是B

29:02.950 --> 29:03.950
输出

29:04.950 --> 29:06.950
我是B模块

29:07.950 --> 29:08.950
OK

29:08.950 --> 29:09.950
然后导出B

29:09.950 --> 29:10.950
行了

29:10.950 --> 29:11.950
这两个模块就写好了

29:11.950 --> 29:12.950
好

29:12.950 --> 29:13.950
接下来我们来看看

29:13.950 --> 29:14.950
它的整个执行过程

29:15.950 --> 29:18.950
这就是A这个模块

29:18.950 --> 29:19.950
A包

29:19.950 --> 29:20.950
一个index的GS

29:20.950 --> 29:21.950
要用到B

29:21.950 --> 29:22.950
B里边的一个index的GS

29:22.950 --> 29:23.950
什么都没有

29:23.950 --> 29:24.950
那么假设我们的工程

29:24.950 --> 29:25.950
为project

29:25.950 --> 29:26.950
project直接依赖A

29:26.950 --> 29:28.950
但是它不直接依赖B

29:28.950 --> 29:29.950
那么这个安装的时候

29:29.950 --> 29:31.950
PMPM会做下面的处理

29:31.950 --> 29:32.950
怎么处理呢

29:32.950 --> 29:33.950
第一个

29:33.950 --> 29:34.950
首先查看依赖关系

29:34.950 --> 29:35.950
那么一查看

29:35.950 --> 29:36.950
我要本来要用A

29:36.950 --> 29:37.950
但是A又依赖B

29:37.950 --> 29:38.950
它怎么查看

29:38.950 --> 29:39.950
查看A里边的是不是

29:39.950 --> 29:40.950
Pike一点节省

29:40.950 --> 29:41.950
这里边没写

29:41.950 --> 29:42.950
它肯定要有这个东西

29:42.950 --> 29:43.950
去查看它

29:43.950 --> 29:45.950
它又没有依赖关系

29:45.950 --> 29:46.950
依查

29:46.950 --> 29:47.950
原来A还依赖B

29:47.950 --> 29:48.950
所以说我最终分析出来

29:48.950 --> 29:49.950
分析大堆

29:49.950 --> 29:50.950
有可能B还依赖别的东西

29:50.950 --> 29:51.950
总之分析大堆

29:51.950 --> 29:53.950
总之我得到我的依赖

29:53.950 --> 29:54.950
我最重要安装了

29:54.950 --> 29:55.950
包里哪些有A和B

29:55.950 --> 29:56.950
对吧

29:56.950 --> 29:57.950
有这两个

29:57.950 --> 29:58.950
那么这个时候

29:58.950 --> 29:59.950
就看A和B

29:59.950 --> 30:00.950
是否已经缓存起来了

30:00.950 --> 30:01.950
是不是看跟目录下面

30:01.950 --> 30:03.950
有没有缓存

30:03.950 --> 30:05.950
当然还要去对比版本

30:05.950 --> 30:07.950
相应的版本有没有缓存

30:07.950 --> 30:08.950
如果没有的话就下载

30:08.950 --> 30:09.950
如果有的话

30:09.950 --> 30:10.950
那么进入下一步

30:10.950 --> 30:11.950
那么现在我们假设

30:11.950 --> 30:13.950
它已经缓存到这个目录了

30:13.950 --> 30:14.950
假设已经缓存到

30:14.950 --> 30:16.950
开启这个目录了

30:16.950 --> 30:18.950
不要说缓存到这了

30:18.950 --> 30:20.950
缓存到这了过后

30:20.950 --> 30:21.950
接下来干嘛呢

30:21.950 --> 30:22.950
它接下来

30:22.950 --> 30:23.950
会在工程里面

30:23.950 --> 30:24.950
创建Load Marjus目录

30:24.950 --> 30:25.950
并对目录

30:25.950 --> 30:26.950
做下面这个处理

30:26.950 --> 30:28.950
一看管也是不是直接云了

30:28.950 --> 30:29.950
没关系

30:29.950 --> 30:30.950
咱们一点点来

30:30.950 --> 30:32.950
它首先到我们工程里边

30:32.950 --> 30:34.950
我们这里新建的工程吧

30:34.950 --> 30:36.950
再新建一个

30:36.950 --> 30:37.950
再

30:37.950 --> 30:39.950
我刚才不放这

30:39.950 --> 30:40.950
不放这

30:40.950 --> 30:41.950
放这

30:45.480 --> 30:46.480
云

30:46.480 --> 30:47.480
关掉

30:47.480 --> 30:48.480
关掉重新打开

30:49.480 --> 30:50.480
每次都是这样子

30:50.480 --> 30:51.480
一旦接好目录

30:51.480 --> 30:52.480
它就被占用

30:53.480 --> 30:54.480
一动过来

30:55.480 --> 30:56.480
一动过来

30:56.480 --> 30:58.480
那么这比方说缓存目录

30:58.480 --> 30:59.480
我们的工程目录在哪呢

30:59.480 --> 31:00.480
比方说工程目录在这

31:00.480 --> 31:01.480
Project

31:02.480 --> 31:03.480
比方说工程目录在这

31:04.480 --> 31:05.480
那么它做了什么事呢

31:05.480 --> 31:06.480
它在Project里面

31:06.480 --> 31:08.480
去建一个文件夹

31:08.480 --> 31:10.480
叫Load Marjus

31:10.480 --> 31:12.480
那么这个好理解

31:12.480 --> 31:13.480
因为我们Project里面

31:13.480 --> 31:14.480
不是有自己的代码吗

31:14.480 --> 31:15.480
应这个是了解

31:15.480 --> 31:16.480
你看

31:16.480 --> 31:17.480
我们有自己的

31:17.480 --> 31:18.480
应这个是了解

31:18.480 --> 31:19.480
那么我们在

31:19.480 --> 31:20.480
自己的代码里面要干嘛

31:20.480 --> 31:21.480
是不是要用

31:21.480 --> 31:22.480
Require

31:22.480 --> 31:23.480
是不是要用A

31:23.480 --> 31:24.480
是不是要用到A

31:25.480 --> 31:26.480
要用到A模块

31:27.480 --> 31:28.480
那么要用到A模块

31:28.480 --> 31:29.480
它肯定要去下载

31:29.480 --> 31:30.480
下载A

31:30.480 --> 31:31.480
已经下载它的依赖

31:31.480 --> 31:32.480
B

31:32.480 --> 31:33.480
那么肯定要放到

31:33.480 --> 31:34.480
Load Marjus目录下面

31:34.480 --> 31:35.480
那么接下来

31:35.480 --> 31:36.480
它做什么事呢

31:36.480 --> 31:37.480
问题是

31:37.480 --> 31:38.480
那么首先我们来分析

31:38.480 --> 31:39.480
Load Marjus目录

31:39.480 --> 31:40.480
它一开始不会着急

31:40.480 --> 31:42.480
把A直接放到这里边了

31:42.480 --> 31:43.480
也不会着急

31:43.480 --> 31:44.480
把B直接放到这里边

31:44.480 --> 31:45.480
它首先建一个目录

31:45.480 --> 31:46.480
它名字叫做

31:47.480 --> 31:49.480
它会首先会建立这么一个目录

31:50.480 --> 31:51.480
这个目录干嘛呢

31:51.480 --> 31:52.480
这个目录呢

31:52.480 --> 31:55.480
是用于Pnpm来管理

31:55.480 --> 31:57.480
它用来管理包的

31:57.480 --> 31:58.480
管理包已经包的依赖关系

31:58.480 --> 32:00.480
它在这里边进行管理

32:00.480 --> 32:01.480
那么这个目录Load

32:01.480 --> 32:02.480
能不能读到

32:02.480 --> 32:03.480
肯定读不到啊

32:03.480 --> 32:04.480
比方说

32:04.480 --> 32:05.480
Load

32:05.480 --> 32:06.480
除非你用决定读进

32:06.480 --> 32:07.480
你用怎么读

32:07.480 --> 32:08.480
你这样的读

32:08.480 --> 32:09.480
Load Marjus

32:09.480 --> 32:10.480
除非你这样去读

32:10.480 --> 32:11.480
否则的话

32:11.480 --> 32:12.480
你用那个

32:12.480 --> 32:13.480
正常的读法

32:13.480 --> 32:14.480
比方说我们要读一个模块

32:14.480 --> 32:15.480
A

32:15.480 --> 32:16.480
从这个目录下面去找

32:16.480 --> 32:17.480
不会

32:17.480 --> 32:18.480
所以说

32:18.480 --> 32:19.480
它不会干扰Load的运行

32:19.480 --> 32:20.480
那么这个东西

32:20.480 --> 32:21.480
对Load相当于是隐藏的

32:21.480 --> 32:23.480
Load是读不到它的

32:23.480 --> 32:24.480
那么今天我们来看一下

32:24.480 --> 32:25.480
它到底是怎么管理的

32:25.480 --> 32:26.480
它特别神奇

32:26.480 --> 32:28.480
它这里边又分为两个目录

32:28.480 --> 32:30.480
一个是Load Marjus

32:30.480 --> 32:32.480
又是一个Load Marjus

32:32.480 --> 32:33.480
那么这个Load Marjus

32:33.480 --> 32:34.480
有什么用呢

32:34.480 --> 32:35.480
先不管

32:35.480 --> 32:36.480
先放这

32:36.480 --> 32:37.480
我一会会说

32:37.480 --> 32:38.480
它以前没有的

32:38.480 --> 32:39.480
以前没有这个东西的

32:39.480 --> 32:40.480
是我

32:40.480 --> 32:42.480
我刚刚看到的官网

32:42.480 --> 32:43.480
它就更新了

32:43.480 --> 32:44.480
更新了以后

32:44.480 --> 32:45.480
它为了解决一个问题

32:45.480 --> 32:47.480
本来是可以没有的

32:47.480 --> 32:48.480
它的核心原理

32:48.480 --> 32:49.480
是可以没有这个东西的

32:49.480 --> 32:50.480
接下来

32:50.480 --> 32:51.480
它还有一个目录

32:51.480 --> 32:53.480
还有一个目录叫做

32:53.480 --> 32:54.480
就是我们的

32:54.480 --> 32:56.480
registry npm淘宝.org

32:56.480 --> 32:57.480
这是什么东西的

32:57.480 --> 32:59.480
就是我们的包从哪里下载的

32:59.480 --> 33:00.480
那么我们的registry

33:00.480 --> 33:02.480
地址它就在哪里

33:02.480 --> 33:09.480
registry npm.淘宝.org

33:09.480 --> 33:11.480
它有这么一个东西

33:11.480 --> 33:12.480
有这么一个目录

33:12.480 --> 33:13.480
OK

33:13.480 --> 33:14.480
当然了

33:14.480 --> 33:16.480
其实它这个目录前面还有一个点

33:16.480 --> 33:17.480
它故意给你加了一个点

33:17.480 --> 33:18.480
其实无所谓

33:18.480 --> 33:19.480
加不下点无所谓

33:19.480 --> 33:20.480
好

33:20.480 --> 33:21.480
那么这里就是建立了这么一个目录

33:21.480 --> 33:22.480
这个目录干嘛呢

33:22.480 --> 33:23.480
它这个目录里下面

33:23.480 --> 33:26.480
它才是真正的保存包的

33:26.480 --> 33:27.480
比方说我们要从缓存里

33:27.480 --> 33:28.480
不要copy过来

33:28.480 --> 33:29.480
对吧

33:29.480 --> 33:30.480
从缓存里不要copy过来

33:30.480 --> 33:31.480
copy到哪

33:31.480 --> 33:32.480
copy到全部

33:32.480 --> 33:33.480
copy到这下面

33:33.480 --> 33:34.480
因为我们

33:34.480 --> 33:35.480
这个包是从这里下载的

33:35.480 --> 33:36.480
所以说

33:36.480 --> 33:37.480
它会建立这个目录

33:37.480 --> 33:38.480
如果说你的包

33:38.480 --> 33:39.480
有些包是从这下载的

33:39.480 --> 33:40.480
有些包是从npm上载的

33:40.480 --> 33:41.480
那么这里还有一个文件讲

33:41.480 --> 33:42.480
就是npm

33:42.480 --> 33:44.480
这个比方说我们copyA这个包

33:44.480 --> 33:45.480
A这个包是从这下载的

33:45.480 --> 33:46.480
它就放在这里边

33:46.480 --> 33:47.480
B这个包

33:47.480 --> 33:48.480
B个包不是从这下载的

33:48.480 --> 33:49.480
它放在别的地方

33:49.480 --> 33:50.480
一般来说

33:50.480 --> 33:51.480
谁会去用不同的入口呢

33:51.480 --> 33:52.480
一般都是一个入口

33:52.480 --> 33:54.480
所以说一般都是一个

33:54.480 --> 33:55.480
那么这个地方

33:55.480 --> 33:56.480
说来保存什么呢

33:56.480 --> 33:58.480
保存所有包的具体版本

33:58.480 --> 33:59.480
和代码文件

33:59.480 --> 34:00.480
包的代码和版本

34:00.480 --> 34:01.480
全部在这里边

34:01.480 --> 34:02.480
好比方说我们现在

34:02.480 --> 34:03.480
有哪个包

34:03.480 --> 34:04.480
是不是有A这个包

34:04.480 --> 34:05.480
以及什么有B这个包

34:05.480 --> 34:06.480
对吧

34:06.480 --> 34:07.480
对吧

34:07.480 --> 34:08.480
是不是有两个包

34:08.480 --> 34:09.480
对吧

34:09.480 --> 34:10.480
A这个包的版本呢

34:10.480 --> 34:11.480
我现在不知道版本

34:11.480 --> 34:12.480
比方说1.0.0吗

34:12.480 --> 34:13.480
1.0.0

34:13.480 --> 34:15.480
比方说

34:15.480 --> 34:17.480
比方说有这么一个版本

34:17.480 --> 34:19.480
B这个包也有这么一个版本

34:19.480 --> 34:20.480
也就是说

34:20.480 --> 34:21.480
它如果说

34:21.480 --> 34:22.480
这样子就能支持多版本

34:22.480 --> 34:23.480
如果说A这个包有不同的版本

34:23.480 --> 34:24.480
是不是在这里写

34:24.480 --> 34:25.480
不同的版本就完事了

34:25.480 --> 34:26.480
对吧

34:26.480 --> 34:27.480
好

34:27.480 --> 34:28.480
那么每一个版本下面

34:28.480 --> 34:29.480
它有一个文件讲

34:29.480 --> 34:31.480
又有一个npm

34:31.480 --> 34:34.980
如果说这个拼图呢

34:34.980 --> 34:35.980
npm

34:35.980 --> 34:36.980
你现在听着很晕

34:36.980 --> 34:38.980
那么一会讲完了过后

34:38.980 --> 34:39.980
你看它去怎么执行

34:39.980 --> 34:40.980
这里就明白了

34:41.980 --> 34:42.980
讲完了之后

34:42.980 --> 34:43.980
大家可以想一想

34:43.980 --> 34:44.980
有没有别的办法

34:44.980 --> 34:45.980
它的办法是非常巧妙的

34:45.980 --> 34:46.980
那么这个东西

34:46.980 --> 34:47.980
是为了区分版本的

34:47.980 --> 34:48.980
对吧

34:48.980 --> 34:49.980
那么每一个版本下边

34:49.980 --> 34:50.980
它又有一个npm

34:50.980 --> 34:51.980
那么为什么

34:51.980 --> 34:52.980
每一个版本下面

34:52.980 --> 34:53.980
有npm

34:53.980 --> 34:55.980
每一个版本下面的npm

34:55.980 --> 34:58.980
就是包含这个包本身

34:58.980 --> 34:59.980
自己本身

34:59.980 --> 35:00.980
以及它的所有倚带

35:00.980 --> 35:01.980
全部在这里边

35:01.980 --> 35:02.980
你看

35:02.980 --> 35:03.980
我这个包A

35:03.980 --> 35:05.980
A里边有不同的版本

35:05.980 --> 35:07.980
这个版本下边

35:07.980 --> 35:08.980
这个版本下边

35:08.980 --> 35:10.980
使用了一个nodemarchus目录

35:10.980 --> 35:11.980
那么这个目录下面

35:11.980 --> 35:13.980
就包含了自己包的文件

35:13.980 --> 35:14.980
有些人会说

35:14.980 --> 35:15.980
为什么不把直接

35:15.980 --> 35:16.980
把A的代码文件

35:16.980 --> 35:17.980
放到这呢

35:17.980 --> 35:18.980
你会明白了

35:18.980 --> 35:20.980
这些东西都有原因的

35:20.980 --> 35:22.980
它要放一个nodemarchus目录

35:22.980 --> 35:23.980
那么这个目录下面

35:23.980 --> 35:25.980
它包含包A自己

35:25.980 --> 35:26.980
以及别的包

35:26.980 --> 35:28.980
那么首先它要搞定自己

35:28.980 --> 35:30.980
就是在这里边建一个A

35:30.980 --> 35:31.980
什么意思呢

35:31.980 --> 35:32.980
就是我这个包里边的代码

35:32.980 --> 35:33.980
要执行

35:33.980 --> 35:34.980
是不是首先

35:34.980 --> 35:35.980
至少得有我自己的代码

35:35.980 --> 35:36.980
对吧

35:36.980 --> 35:37.980
至少得有我自己的代码

35:37.980 --> 35:38.980
B也是一样

35:38.980 --> 35:39.980
B这个包要执行

35:39.980 --> 35:40.980
那么首先

35:40.980 --> 35:41.980
肯定要有我自己的代码

35:41.980 --> 35:42.980
所以说它肯定有

35:42.980 --> 35:43.980
一定有一个自己

35:43.980 --> 35:44.980
就每一个包

35:44.980 --> 35:45.980
它对应一个版本

35:45.980 --> 35:46.980
版本下面有nodemarchus

35:46.980 --> 35:47.980
它下面一定有个自己

35:47.980 --> 35:48.980
好了

35:48.980 --> 35:49.980
那个自己的

35:49.980 --> 35:50.980
里边是不是要写代码文件了

35:50.980 --> 35:51.980
接下来

35:51.980 --> 35:53.980
代码文件哪来

35:55.980 --> 35:56.980
看下面了

35:57.980 --> 35:58.980
这个时候

35:58.980 --> 36:00.980
它会从缓存的对应包中

36:00.980 --> 36:02.980
使用硬链接放置文件

36:02.980 --> 36:05.980
到相应包的代码目录中

36:05.980 --> 36:06.980
那么这个时候

36:06.980 --> 36:07.980
它就会使用硬链接

36:07.980 --> 36:08.980
把这个东西

36:08.980 --> 36:09.980
和这个东西

36:09.980 --> 36:10.980
链接到

36:10.980 --> 36:11.980
把A里边的index.js

36:11.980 --> 36:12.980
链接到这

36:12.980 --> 36:13.980
把B里边的index.js

36:13.980 --> 36:14.980
链接到这

36:14.980 --> 36:15.980
好

36:15.980 --> 36:16.980
接下来

36:16.980 --> 36:17.980
我们自己来做一次吧

36:17.980 --> 36:18.980
点击右键

36:18.980 --> 36:19.980
复制路径

36:21.980 --> 36:23.980
我们在这里

36:23.980 --> 36:24.980
从这里开始吧

36:24.980 --> 36:27.980
点击复制路径

36:27.980 --> 36:31.510
已经在这了

36:31.510 --> 36:32.510
是吧

36:32.510 --> 36:33.510
已经在这了

36:33.510 --> 36:34.510
那么我们这里使用什么

36:34.510 --> 36:35.510
使用mklink

36:35.510 --> 36:36.510
创建什么呢

36:36.510 --> 36:38.510
创建硬链接

36:38.510 --> 36:39.510
好

36:39.510 --> 36:40.510
我们的新的文件在哪呢

36:40.510 --> 36:41.510
新的文件在这

36:42.510 --> 36:43.510
A里边

36:43.510 --> 36:44.510
我们这里

36:44.510 --> 36:45.510
复制向路径

36:45.510 --> 36:46.510
新的文件

36:47.510 --> 36:48.510
我们在这

36:48.510 --> 36:49.510
一大堆

36:49.510 --> 36:50.510
一长串

36:51.510 --> 36:52.510
A里边

36:52.510 --> 36:53.510
A下面的什么呢

36:53.510 --> 36:54.510
index.js的解释

36:54.510 --> 36:55.510
对吧

36:55.510 --> 36:56.510
好

36:56.510 --> 36:57.510
目标文件

36:57.510 --> 36:58.510
我们原来的文件在哪呢

36:58.510 --> 36:59.510
原来的文件

36:59.510 --> 37:00.510
是不是就在这个

37:01.510 --> 37:02.510
在这个文件

37:02.510 --> 37:03.510
对吧

37:03.510 --> 37:04.510
复制向路径

37:05.510 --> 37:07.510
这是我们原来的文件

37:07.510 --> 37:08.510
创建硬链接

37:08.510 --> 37:09.510
那么这样子你看

37:09.510 --> 37:10.510
A里边

37:12.510 --> 37:14.510
A里边说一个index.js的解释

37:14.510 --> 37:15.510
那么并没有导致

37:15.510 --> 37:16.510
尺盘那种人家

37:16.510 --> 37:17.510
对吧

37:17.510 --> 37:19.510
因为我使用的是硬链接

37:19.510 --> 37:20.510
然后B是不是一样的道理

37:20.510 --> 37:21.510
对吧

37:21.510 --> 37:22.510
B是一样的道理

37:22.510 --> 37:23.510
所以说来吧

37:23.510 --> 37:24.510
b

37:24.510 --> 37:25.510
link

37:25.510 --> 37:26.510
而且现在我们用相对路径

37:26.510 --> 37:27.510
相对路径

37:27.510 --> 37:28.510
我们现在

37:28.510 --> 37:29.510
要往哪里边写呢

37:29.510 --> 37:30.510
要往pro

37:30.510 --> 37:32.510
要往pro.j

37:33.510 --> 37:35.510
load modules

37:36.510 --> 37:37.510
下边的

37:39.510 --> 37:40.510
pnpm

37:41.510 --> 37:42.510
太多了

37:43.510 --> 37:44.510
我这里还是复制吧

37:45.510 --> 37:46.510
复制路径

37:47.510 --> 37:48.510
只用绝对路径得了

37:49.510 --> 37:53.590
下面的index.js

37:54.590 --> 37:55.590
接下来

37:55.590 --> 37:56.590
原来的呢

37:56.590 --> 37:57.590
在这

37:57.590 --> 37:58.590
复制路径

37:58.590 --> 38:01.220
回事

38:01.220 --> 38:02.220
那么这里刷新

38:02.220 --> 38:03.220
你看B里边

38:03.220 --> 38:04.220
是不是也有了

38:04.220 --> 38:05.220
那么它是通过硬链接的方式

38:05.220 --> 38:07.220
是不是把原来的东西打过来了

38:07.220 --> 38:08.220
那么这样子

38:08.220 --> 38:09.220
原来的代码文件

38:09.220 --> 38:10.220
是不是全部过来了

38:10.220 --> 38:11.220
当然有还有别的文件

38:11.220 --> 38:12.220
肯定还有什么

38:12.220 --> 38:13.220
pk.j

38:13.220 --> 38:14.220
还有其他乱七八糟的文件

38:14.220 --> 38:15.220
除了load

38:15.220 --> 38:17.220
除了这里边的load modules

38:17.220 --> 38:18.220
其他东西

38:18.220 --> 38:19.220
其他本质

38:19.220 --> 38:20.220
他自己的代码文件

38:20.220 --> 38:21.220
全部要拷贝过来

38:21.220 --> 38:22.220
通过硬链接拷贝过来

38:23.220 --> 38:24.220
OK

38:24.220 --> 38:25.220
那么这样子

38:25.220 --> 38:26.220
你想想

38:26.220 --> 38:27.220
a

38:27.220 --> 38:28.220
下面的a

38:28.220 --> 38:29.220
这个1.0

38:29.220 --> 38:30.220
它是不是包含了

38:30.220 --> 38:31.220
自己的代码

38:31.220 --> 38:32.220
全部都有了

38:32.220 --> 38:33.220
B里边是不是包含了

38:33.220 --> 38:34.220
自己的代码

38:34.220 --> 38:35.220
全部都有了

38:35.220 --> 38:36.220
好

38:36.220 --> 38:37.220
接下来我们再看

38:37.220 --> 38:38.220
B里边

38:38.220 --> 38:39.220
这个目录下面还要放什么呢

38:39.220 --> 38:40.220
除了放A自己

38:40.220 --> 38:42.220
还要放自直接一代

38:42.220 --> 38:43.220
你看这里

38:43.220 --> 38:44.220
你看

38:44.220 --> 38:45.220
index.js

38:45.220 --> 38:46.220
来自于缓存的一连接

38:46.220 --> 38:47.220
index.js

38:47.220 --> 38:48.220
来自于缓存的一连接

38:48.220 --> 38:49.220
对吧

38:49.220 --> 38:50.220
好

38:50.220 --> 38:51.220
那么接下来下一步

38:51.220 --> 38:52.220
就是要使用符号链接

38:52.220 --> 38:54.220
把每个包的直接依赖

38:54.220 --> 38:55.220
放到自己目录中

38:55.220 --> 38:56.220
什么意思

38:56.220 --> 38:57.220
你看这

38:57.220 --> 38:58.220
A这个包里边

38:58.220 --> 38:59.220
是不是还要依赖B

38:59.220 --> 39:00.220
对吧

39:00.220 --> 39:01.220
因为它直接依赖B

39:01.220 --> 39:02.220
所以把B直接

39:02.220 --> 39:03.220
把它放到load module

39:03.220 --> 39:04.220
就是目录下面了

39:04.220 --> 39:06.220
也就是说什么意思

39:06.220 --> 39:08.220
也就是说我在load module 下面

39:08.220 --> 39:10.220
还要去用符号链接

39:10.220 --> 39:11.220
去链接B

39:11.220 --> 39:12.220
在这里边加个B

39:12.220 --> 39:13.220
去链接谁

39:13.220 --> 39:14.220
链接B

39:14.220 --> 39:15.220
那链接哪个地方的B呢

39:15.220 --> 39:16.220
链接这

39:16.220 --> 39:17.220
因为这个B是不是

39:17.220 --> 39:18.220
B包里边的

39:18.220 --> 39:19.220
就是这个B

39:19.220 --> 39:20.220
这个B

39:20.220 --> 39:21.220
是不是他自己的代码

39:21.220 --> 39:22.220
我链接在这

39:22.220 --> 39:23.220
那么我们用一个符号链接

39:23.220 --> 39:24.220
把它放到这

39:24.220 --> 39:25.220
是不是A

39:25.220 --> 39:26.220
就可以读到B了

39:26.220 --> 39:27.220
好

39:27.220 --> 39:29.600
咱们来看

39:29.600 --> 39:30.600
接下来我们这里

39:30.600 --> 39:31.600
使用

39:31.600 --> 39:33.600
这里复制一下

39:33.600 --> 39:34.600
复制一下

39:34.600 --> 39:35.600
复制路径

39:35.600 --> 39:38.360
CD

39:38.360 --> 39:40.740
好

39:40.740 --> 39:41.740
然后我们使用

39:41.740 --> 39:42.740
现在我们到这个路径

39:42.740 --> 39:43.740
到这个路径下面

39:43.740 --> 39:44.740
这个路径下面

39:44.740 --> 39:46.740
然后使用mk link

39:46.740 --> 39:47.740
使用什么呢

39:47.740 --> 39:49.740
符号链接

39:49.740 --> 39:50.740
钢D

39:50.740 --> 39:51.740
链接目录

39:51.740 --> 39:53.740
然后目录的名字叫B

39:53.740 --> 39:54.740
好

39:54.740 --> 39:55.740
链接到路径

39:55.740 --> 39:56.740
路径在这

39:56.740 --> 39:58.740
链接这个地址

39:58.740 --> 40:01.750
复制路径

40:01.750 --> 40:02.750
OK

40:02.750 --> 40:03.750
充电到符号链接

40:03.750 --> 40:04.750
刷新

40:04.750 --> 40:05.750
那你看

40:05.750 --> 40:06.750
这里是不是一个符号链接

40:06.750 --> 40:07.750
符号链接到这

40:07.750 --> 40:08.750
对吧

40:08.750 --> 40:09.750
好

40:09.750 --> 40:10.750
那么接下来我来解释

40:10.750 --> 40:11.750
mk就是目录

40:11.750 --> 40:12.750
为什么直接把A和B

40:12.750 --> 40:13.750
就放到这呢

40:13.750 --> 40:14.750
为什么要多一个

40:14.750 --> 40:15.750
mk就是目录

40:15.750 --> 40:16.750
你想这个道理

40:16.750 --> 40:17.750
A点接S

40:17.750 --> 40:18.750
它要运行

40:18.750 --> 40:19.750
它是不是要一代磨块B

40:19.750 --> 40:20.750
这是它直接依赖

40:20.750 --> 40:21.750
对吧

40:21.750 --> 40:22.750
它的直接依赖

40:22.750 --> 40:23.750
好

40:23.750 --> 40:24.750
那么它直接依赖的话

40:24.750 --> 40:25.750
这样子是不是要去找

40:25.750 --> 40:26.750
运行的

40:26.750 --> 40:27.750
到时候肯定要运行

40:27.750 --> 40:28.750
这个接S

40:28.750 --> 40:29.750
它运行的时候

40:29.750 --> 40:30.750
是不是要去找

40:30.750 --> 40:31.750
mkB

40:31.750 --> 40:32.750
它怎么找呢

40:32.750 --> 40:33.750
怎么找呢

40:33.750 --> 40:34.750
这种显法

40:34.750 --> 40:35.750
是不是要从

40:35.750 --> 40:36.750
当前目录的

40:36.750 --> 40:37.750
当看下

40:37.750 --> 40:38.750
当前目录里面

40:38.750 --> 40:39.750
有没有mk

40:39.750 --> 40:40.750
A这个文件

40:40.750 --> 40:41.750
下面是不是没有

40:41.750 --> 40:42.750
mk

40:42.750 --> 40:43.750
然后呢

40:43.750 --> 40:44.750
是不是返回上一级目录

40:44.750 --> 40:45.750
上一级目录

40:45.750 --> 40:46.750
是不是这个

40:46.750 --> 40:47.750
看这个目录下面

40:47.750 --> 40:48.750
有没有mk

40:48.750 --> 40:49.750
是不是没有

40:49.750 --> 40:50.750
然后再返回上一级目录

40:50.750 --> 40:51.750
是不是返回这个

40:51.750 --> 40:52.750
那么是不是返回了

40:52.750 --> 40:53.750
它版本的目录

40:53.750 --> 40:54.750
我现在S

40:54.750 --> 40:56.750
在1.0版本下面运行

40:56.750 --> 40:57.750
那么1.0版本

40:57.750 --> 40:58.750
下面运行的时候

40:58.750 --> 40:59.750
我是依赖B的

40:59.750 --> 41:00.750
你看这个下面

41:00.750 --> 41:01.750
是不是有mk

41:01.750 --> 41:02.750
就可以找到B了

41:02.750 --> 41:03.750
这就是它

41:03.750 --> 41:04.750
为什么要

41:04.750 --> 41:05.750
这里要写个mk

41:05.750 --> 41:06.750
如果说这里

41:06.750 --> 41:07.750
不是个mk

41:07.750 --> 41:08.750
不写这个文件

41:08.750 --> 41:09.750
像你都找不到B了

41:09.750 --> 41:10.750
对吧

41:10.750 --> 41:11.750
所以说这里为什么

41:11.750 --> 41:12.750
还要去再写一个

41:12.750 --> 41:13.750
就是这个原因

41:13.750 --> 41:14.750
听懂了吗

41:14.750 --> 41:16.750
这就是它为什么

41:16.750 --> 41:17.750
这里要再写一个

41:18.750 --> 41:19.750
OK

41:19.750 --> 41:20.750
那么这里就是

41:20.750 --> 41:22.750
S会搞定的

41:22.750 --> 41:24.750
这里只管直接依赖

41:24.750 --> 41:25.750
只管直接依赖

41:25.750 --> 41:26.750
A直接依赖B

41:26.750 --> 41:27.750
那比方说

41:27.750 --> 41:28.750
A直接依赖B

41:28.750 --> 41:29.750
B直接依赖C

41:29.750 --> 41:30.750
那这里要不要安装C

41:30.750 --> 41:31.750
不安装

41:31.750 --> 41:32.750
它安装直接依赖

41:32.750 --> 41:33.750
那么B呢

41:33.750 --> 41:35.750
是不是它就是规范

41:35.750 --> 41:36.750
就是PMPM的规范

41:36.750 --> 41:37.750
它就

41:37.750 --> 41:38.750
你写单一码

41:38.750 --> 41:39.750
就应该直接使用

41:39.750 --> 41:40.750
直接依赖

41:40.750 --> 41:41.750
不应该去使用

41:41.750 --> 41:42.750
间接依赖

41:42.750 --> 41:43.750
所以说这个时候A

41:43.750 --> 41:44.750
去找间接依赖

41:44.750 --> 41:45.750
如果说A里面

41:45.750 --> 41:46.750
要找C

41:46.750 --> 41:47.750
那么如果说B依赖C

41:47.750 --> 41:48.750
那这里是不是找不到

41:48.750 --> 41:49.750
找不到就爆出了

41:49.750 --> 41:50.750
这就是我上一课

41:50.750 --> 41:51.750
为什么说

41:51.750 --> 41:53.750
PMPM对那种

41:53.750 --> 41:55.750
协法不规一方的代码

41:55.750 --> 41:56.750
是没法运行的

41:56.750 --> 41:57.750
因为它没法找到

41:57.750 --> 41:58.750
间接依赖

41:58.750 --> 41:59.750
它只能去找直接依赖

42:00.750 --> 42:01.750
那么同样的B

42:01.750 --> 42:02.750
是不是找自己的

42:02.750 --> 42:03.750
直接依赖

42:03.750 --> 42:04.750
放到这儿

42:04.750 --> 42:05.750
但是B呢

42:05.750 --> 42:06.750
没有直接依赖了

42:06.750 --> 42:07.750
OK

42:07.750 --> 42:08.750
那么这个时候

42:08.750 --> 42:09.750
是不是就把这个文件夹

42:09.750 --> 42:10.750
架构建好了

42:10.750 --> 42:11.750
那你想啊

42:11.750 --> 42:12.750
这个文件夹里边

42:12.750 --> 42:13.750
是不是就已经构建了

42:13.750 --> 42:14.750
现在跟缓存没关系了

42:14.750 --> 42:15.750
缓存英全部拿过去了

42:15.750 --> 42:16.750
缓存其实就是

42:16.750 --> 42:17.750
用来建立硬件接的

42:18.750 --> 42:19.750
然后呢

42:19.750 --> 42:21.750
这个文件夹建好了之后

42:21.750 --> 42:22.750
就是这里面就保存了

42:22.750 --> 42:24.750
所有包的代码文件

42:24.750 --> 42:25.750
每个包都可以正常运行

42:25.750 --> 42:27.750
因为每个包下面

42:27.750 --> 42:28.750
就完本的区分

42:28.750 --> 42:29.750
已经每个版本下面

42:29.750 --> 42:30.750
它有自己的依赖

42:30.750 --> 42:32.750
是不是全部构建好了

42:32.750 --> 42:34.750
构建好了之后

42:34.750 --> 42:35.750
接下来

42:35.750 --> 42:36.750
看这个目录

42:36.750 --> 42:37.750
它为什么现在要

42:37.750 --> 42:38.750
多出来这么一个目录

42:39.750 --> 42:40.750
它是这样子

42:43.060 --> 42:44.060
以前呢

42:44.060 --> 42:45.060
确实有这个问题啊

42:45.060 --> 42:46.060
就是说

42:46.060 --> 42:47.060
你去

42:47.060 --> 42:48.060
A去依赖B

42:48.060 --> 42:49.060
B去依赖C

42:49.060 --> 42:50.060
如果说

42:50.060 --> 42:52.060
A这个人写的代码

42:52.060 --> 42:53.060
很丑陋

42:53.060 --> 42:54.060
他里边去用到C的东西

42:54.060 --> 42:55.060
是不是用到间接一代

42:55.060 --> 42:56.060
是不是找不到

42:56.060 --> 42:57.060
对吧

42:57.060 --> 42:58.060
是不是找不到

42:58.060 --> 42:59.060
为了解决

42:59.060 --> 43:00.060
为了解决这个问题

43:00.060 --> 43:01.060
也不能老是期望别人

43:01.060 --> 43:02.060
去改改变

43:02.060 --> 43:03.060
因为别人

43:03.060 --> 43:04.060
可能他不会改变

43:04.060 --> 43:05.060
他觉得我以前用的

43:05.060 --> 43:06.060
好好的评论

43:06.060 --> 43:07.060
你PAMPM

43:07.060 --> 43:08.060
这个东西

43:08.060 --> 43:09.060
本来就是别人搞出来的

43:09.060 --> 43:10.060
你给我倒罗安吧

43:10.060 --> 43:11.060
我就不改

43:11.060 --> 43:12.060
所以说呢

43:12.060 --> 43:13.060
PAMPM呢

43:13.060 --> 43:14.060
他为了解决这个问题

43:14.060 --> 43:15.060
他又想了一个办法

43:16.060 --> 43:17.060
我这里边肯定是

43:17.060 --> 43:18.060
加直接依赖

43:18.060 --> 43:19.060
这个毫无疑问的

43:19.060 --> 43:20.060
这是规范

43:20.060 --> 43:21.060
我这里边肯定是

43:21.060 --> 43:22.060
加直接依赖

43:22.060 --> 43:24.060
那么间接一代怎么办呢

43:24.060 --> 43:25.060
那如果说

43:25.060 --> 43:26.060
你遇到间接一代的问题

43:26.060 --> 43:27.060
怎么办呢

43:27.060 --> 43:28.060
如果说A那边

43:28.060 --> 43:29.060
他就要用C

43:29.060 --> 43:30.060
于是呢

43:30.060 --> 43:31.060
他就做了这么一个处理

43:31.060 --> 43:32.060
他在这里

43:32.060 --> 43:33.060
去建了个Loudmage

43:33.060 --> 43:34.060
也就是说啥呢

43:34.060 --> 43:35.060
你A啊

43:35.060 --> 43:36.060
A要用C对吧

43:36.060 --> 43:37.060
这里边有个一代C

43:37.060 --> 43:38.060
那么这里找不到

43:38.060 --> 43:39.060
对吧

43:39.060 --> 43:40.060
一往上找没有Loudmage

43:40.060 --> 43:41.060
一往上找没有

43:41.060 --> 43:42.060
一往上找没有

43:42.060 --> 43:43.060
一往上找

43:43.060 --> 43:44.060
到这个文件夹要时候

43:44.060 --> 43:45.060
是不是里面一个Loudmage

43:45.060 --> 43:46.060
就是

43:46.060 --> 43:47.060
那么他把这个

43:47.060 --> 43:48.060
其他的依赖全部放这

43:49.060 --> 43:50.060
懂我的意思吗

43:50.060 --> 43:51.060
这里边放啥

43:51.060 --> 43:52.060
这里边放置

43:52.060 --> 43:54.060
除了本工程

43:54.060 --> 43:56.060
直接依赖的

43:56.060 --> 43:58.060
所有间接一代

43:58.060 --> 43:59.060
什么意思

43:59.060 --> 44:00.060
就是我们当

44:00.060 --> 44:01.060
当前的工程project

44:01.060 --> 44:02.060
他依赖谁

44:02.060 --> 44:03.060
是不是

44:03.060 --> 44:04.060
依赖

44:04.060 --> 44:05.060
依赖A

44:05.060 --> 44:06.060
A依赖B

44:06.060 --> 44:07.060
对吧

44:07.060 --> 44:08.060
那么A是我们的

44:08.060 --> 44:09.060
直接依赖

44:09.060 --> 44:10.060
那么B是我们的

44:10.060 --> 44:11.060
间接一代

44:11.060 --> 44:12.060
那么所谓的间接一代

44:12.060 --> 44:13.060
全部放到这

44:13.060 --> 44:14.060
那如果说B还依赖C呢

44:14.060 --> 44:15.060
OK

44:15.060 --> 44:16.060
C也放到这

44:16.060 --> 44:17.060
那么这里是

44:17.060 --> 44:18.060
平积目录存放

44:18.060 --> 44:19.060
他没有深度

44:19.060 --> 44:20.060
直接平积目录存放

44:20.060 --> 44:21.060
那么这里怎么存放呢

44:21.060 --> 44:22.060
他这里是这样子

44:22.060 --> 44:23.060
全部用符号链接

44:23.060 --> 44:24.060
你看这里的图

44:25.060 --> 44:26.060
他的Loudmage

44:26.060 --> 44:27.060
就是下面

44:28.060 --> 44:29.060
我这里写错了

44:29.060 --> 44:30.060
这里应该是B

44:30.060 --> 44:31.060
我这里改不了了

44:31.060 --> 44:32.060
B存

44:38.980 --> 44:39.980
好像没把图加过来

44:39.980 --> 44:40.980
没把图加过来

44:40.980 --> 44:41.980
因为这个地方

44:41.980 --> 44:42.980
他要放一个什么呢

44:42.980 --> 44:43.980
放一个B

44:43.980 --> 44:44.980
就这么个意思

44:44.980 --> 44:45.980
当然他使用的是符号链接

44:45.980 --> 44:46.980
那么来吧

44:46.980 --> 44:47.980
使用符号链接

44:49.980 --> 44:50.980
我看一下

44:50.980 --> 44:51.980
我看图也没加过来

44:53.980 --> 44:54.980
在这

44:54.980 --> 44:55.980
加过来了

44:55.980 --> 44:56.980
B符号链接

44:57.980 --> 44:58.980
在这

44:58.980 --> 44:59.980
来吧

44:59.980 --> 45:00.980
我们这里复制一下

45:00.980 --> 45:01.980
复制路径

45:01.980 --> 45:02.980
又来

45:04.980 --> 45:05.980
到哪呢

45:06.980 --> 45:07.980
到

45:07.980 --> 45:08.980
在这吧

45:08.980 --> 45:09.980
在这

45:09.980 --> 45:10.980
在这复制路径

45:14.120 --> 45:15.120
我在这

45:15.120 --> 45:17.120
PMPM复制路径

45:17.120 --> 45:20.070
CD

45:20.070 --> 45:23.540
OK

45:23.540 --> 45:27.830
好

45:27.830 --> 45:28.830
然后呢

45:28.830 --> 45:29.830
我们现在在这个目录

45:29.830 --> 45:30.830
在这个目录

45:30.830 --> 45:31.830
然后呢

45:31.830 --> 45:32.830
我们现在要干嘛呢

45:32.830 --> 45:34.830
现在还是要amc link

45:34.830 --> 45:35.830
建立符号链接

45:35.830 --> 45:37.830
我们一个路径是在这

45:37.830 --> 45:39.830
Loudmage就是

45:39.830 --> 45:40.830
下面的什么呢

45:40.830 --> 45:41.830
B

45:41.830 --> 45:42.830
我们要为B建一个符号链接

45:42.830 --> 45:43.830
连接到哪呢

45:43.830 --> 45:44.830
连接到这

45:44.830 --> 45:45.830
是吧

45:45.830 --> 45:46.830
是不是要连接到这

45:46.830 --> 45:47.830
复制路径

45:47.830 --> 45:48.830
连接到这

45:49.830 --> 45:50.830
创新的符号链接

45:50.830 --> 45:51.830
那么一看一下

45:51.830 --> 45:52.830
那么现在呢

45:52.830 --> 45:54.830
Loudmage就是下面

45:55.830 --> 45:56.830
Loudmage就是下面

45:56.830 --> 45:57.830
是不是多了个B了

45:57.830 --> 45:58.830
对吧

45:58.830 --> 45:59.830
它是个符号链接

45:59.830 --> 46:00.830
好

46:00.830 --> 46:01.830
那这样子呢

46:01.830 --> 46:02.830
你看

46:02.830 --> 46:03.830
如果说

46:03.830 --> 46:04.830
当然现在这个情况

46:04.830 --> 46:05.830
没有什么意义

46:05.830 --> 46:06.830
如果说还有C的话

46:06.830 --> 46:07.830
那么这里是不是还有个C

46:07.830 --> 46:08.830
对吧

46:08.830 --> 46:09.830
如果说还有C的话

46:09.830 --> 46:10.830
是不是还有个C

46:10.830 --> 46:11.830
那么这样子呢

46:11.830 --> 46:13.830
如果说A不小心用到了C

46:13.830 --> 46:14.830
不小心用到了C

46:14.830 --> 46:15.830
那么这样子是不是一层层

46:15.830 --> 46:16.830
可以找过来

46:16.830 --> 46:17.830
对吧

46:17.830 --> 46:18.830
找到这就可以找到了

46:18.830 --> 46:19.830
OK

46:19.830 --> 46:20.830
那么这样子呢

46:20.830 --> 46:21.830
才把这个目录构建完了

46:21.830 --> 46:22.830
好

46:22.830 --> 46:24.830
这个目录构建完成之后

46:24.830 --> 46:25.830
接下来

46:25.830 --> 46:26.830
要考虑我们工程了

46:26.830 --> 46:28.830
我们工程要用谁

46:28.830 --> 46:29.830
要用谁

46:29.830 --> 46:30.830
是不是要用A

46:30.830 --> 46:31.830
对吧

46:31.830 --> 46:32.830
OK

46:32.830 --> 46:33.830
我来这里边

46:33.830 --> 46:34.830
建立一个符号链接

46:34.830 --> 46:35.830
就在这里边

46:35.830 --> 46:36.830
建立一个符号链接

46:36.830 --> 46:37.830
跟我们的笛里边是一样的

46:37.830 --> 46:39.830
工程的都能把就是目录下面

46:39.830 --> 46:40.830
使用符号链接放置直接一带

46:40.830 --> 46:41.830
我们直接一带A

46:41.830 --> 46:43.830
然后直接让A去支枪它

46:43.830 --> 46:44.830
OK

46:44.830 --> 46:45.830
我们再来

46:45.830 --> 46:46.830
好这里复制一下

46:46.830 --> 46:47.830
复制路径

46:49.830 --> 46:50.830
CD

46:50.830 --> 46:52.830
进入这个目录

46:52.830 --> 46:53.830
好

46:53.830 --> 46:54.830
接下来我们换

46:55.830 --> 46:56.830
这样子

46:59.210 --> 47:00.210
OK

47:00.210 --> 47:02.210
然后MK link

47:02.210 --> 47:03.210
鞋杠D

47:03.210 --> 47:05.210
我要在这里建立一个目录A

47:05.210 --> 47:06.210
然后使用符号链接

47:06.210 --> 47:07.210
连接到哪呢

47:07.210 --> 47:08.210
连接到这

47:08.210 --> 47:09.210
A吗

47:09.210 --> 47:10.210
A不就在这吗

47:10.210 --> 47:11.210
A在吗

47:11.210 --> 47:12.210
1.0.0版本

47:12.210 --> 47:13.210
对吧

47:13.210 --> 47:16.030
复制

47:16.030 --> 47:17.030
复制路径

47:17.030 --> 47:18.030
回车

47:18.030 --> 47:19.030
OK

47:19.030 --> 47:20.030
这里刷新式

47:20.030 --> 47:21.030
好

47:21.030 --> 47:22.030
这里是不是A了

47:22.030 --> 47:23.030
A就出来了

47:23.030 --> 47:24.030
对吧

47:24.030 --> 47:26.030
这就是整个NPMP

47:26.030 --> 47:27.030
它的勾件效果

47:27.030 --> 47:28.030
来我们来马上来试一下

47:28.030 --> 47:30.030
真的可以吗

47:30.030 --> 47:31.030
我们来运行一下

47:31.030 --> 47:32.030
Project

47:32.030 --> 47:33.030
No

47:36.110 --> 47:37.110
在这里

47:37.110 --> 47:38.110
点击右键

47:38.110 --> 47:39.110
转转打开

47:40.110 --> 47:41.110
进不来了

47:42.110 --> 47:44.110
应该是用了一些特殊符号

47:44.110 --> 47:45.110
我这里用了综合号

47:45.110 --> 47:46.110
可能路径就进来了

47:46.110 --> 47:47.110
没关系

47:47.110 --> 47:48.110
我这里复制一下

47:48.110 --> 47:49.110
复制路径

47:49.110 --> 47:50.110
然后地盘

47:50.110 --> 47:51.110
CD

47:53.110 --> 47:55.110
它说找不到这个路径

47:55.110 --> 47:59.130
该路径不存在

47:59.130 --> 48:01.130
哪不存在

48:02.130 --> 48:03.130
扯淡

48:03.130 --> 48:04.130
哪不存在

48:04.130 --> 48:05.130
行

48:05.130 --> 48:06.130
那我就

48:07.130 --> 48:08.130
一点点来

48:08.130 --> 48:09.130
先进到这个步

48:09.130 --> 48:10.130
复制路径

48:10.130 --> 48:15.100
清空一下

48:15.100 --> 48:17.100
然后在CD4-4

48:17.100 --> 48:19.100
确实

48:19.100 --> 48:20.100
像这个符号

48:20.100 --> 48:21.100
得是个特殊符号

48:21.100 --> 48:23.100
得转移才行

48:23.100 --> 48:24.100
到这

48:24.100 --> 48:25.100
然后在CD

48:25.100 --> 48:26.100
Project

48:26.100 --> 48:27.100
OK

48:27.100 --> 48:28.100
到这

48:30.100 --> 48:31.100
现在我们运行

48:31.100 --> 48:32.100
load

48:32.100 --> 48:33.100
运行哪个

48:33.100 --> 48:34.100
运行index的介绍

48:34.100 --> 48:35.100
看能不能运行

48:35.100 --> 48:36.100
是不可以拿到

48:36.100 --> 48:38.100
我可以拿到

48:38.100 --> 48:40.100
模块A的代码

48:40.100 --> 48:41.100
对吧直接执行了

48:41.100 --> 48:42.100
模块A你别执行了

48:42.100 --> 48:43.100
对吧模块A你别用了

48:43.100 --> 48:44.100
模块B

48:44.100 --> 48:45.100
然后呢又可以得到

48:45.100 --> 48:46.100
模块B的那种

48:46.100 --> 48:47.100
那怎么回事呢

48:47.100 --> 48:48.100
你想一想这个道理

48:48.100 --> 48:49.100
我们去读

48:49.100 --> 48:50.100
我们去读

48:50.100 --> 48:51.100
A是不是读

48:51.100 --> 48:52.100
我们工程下面的load

48:52.100 --> 48:53.100
码就是读到这个

48:53.100 --> 48:54.100
运行这个代码

48:54.100 --> 48:56.100
而运行这个代码很奇怪

48:56.100 --> 48:58.100
这里边哪有B

48:58.100 --> 48:59.100
就是没有B

48:59.100 --> 49:00.100
哪有B

49:00.100 --> 49:01.100
这个文件讲里边

49:01.100 --> 49:02.100
但是注意

49:02.100 --> 49:03.100
这是个符号链接

49:03.100 --> 49:04.100
所以说它执行的是

49:04.100 --> 49:05.100
什么是真实的

49:05.100 --> 49:07.100
那个路径下面的文件

49:07.100 --> 49:08.100
真实的路径在哪

49:08.100 --> 49:10.100
真实的路径是不是在这

49:10.100 --> 49:11.100
它执行的是这个文件

49:11.100 --> 49:12.100
这个文件里边

49:12.100 --> 49:13.100
是能不能找到B

49:13.100 --> 49:15.100
能啊往上找呗

49:15.100 --> 49:16.100
这一层这一层

49:16.100 --> 49:17.100
找到这一层

49:17.100 --> 49:18.100
那时候呢

49:18.100 --> 49:19.100
下面是不是一个load码就是

49:19.100 --> 49:21.100
下面是不是可以找到B了

49:21.100 --> 49:22.100
对吧就可以找到B了

49:22.100 --> 49:23.100
那么这样子的

49:23.100 --> 49:25.100
既可以保证它正确执行

49:25.100 --> 49:26.100
而且呢

49:26.100 --> 49:27.100
也可以保证

49:27.100 --> 49:28.100
我在这里是不可能用到

49:28.100 --> 49:29.100
用到B的

49:29.100 --> 49:30.100
是不可能的

49:30.100 --> 49:31.100
我们来执行次

49:31.100 --> 49:32.100
是不是用不到

49:32.100 --> 49:33.100
为什么呢

49:33.100 --> 49:34.100
load码就是下面没有B

49:34.100 --> 49:35.100
你找不到

49:35.100 --> 49:36.100
你只能找到A

49:36.100 --> 49:37.100
那你可以去找到B

49:37.100 --> 49:39.100
它是用这种巧妙的方式

49:39.100 --> 49:40.100
来搞定的

49:40.100 --> 49:41.100
看见没

49:41.100 --> 49:42.100
这个ok啊

49:42.100 --> 49:44.100
这就是关于pmpm的原理

49:44.100 --> 49:45.100
那么我们来看一下吧

49:45.100 --> 49:46.100
我们在自己的

49:46.100 --> 49:47.100
就在这个工程下面

49:47.100 --> 49:49.100
再来安装一次

49:49.100 --> 49:50.100
进不去

49:50.100 --> 49:51.100
我们在这吧

49:51.100 --> 49:52.100
之前的工程里边

49:52.100 --> 49:53.100
安装一次啊

49:53.100 --> 49:57.100
安装一次pmpmi

49:57.100 --> 49:59.100
你再来看一下

49:59.100 --> 50:00.100
你感受一下

50:00.100 --> 50:02.100
是不是这个过程

50:02.100 --> 50:04.740
缓存都是用了缓存

50:04.740 --> 50:05.740
对吧

50:05.740 --> 50:06.740
当

50:06.740 --> 50:07.740
ok

50:07.740 --> 50:09.740
那么你看一下pmpm

50:09.740 --> 50:10.740
那么这个缓

50:10.740 --> 50:11.740
没什么好说的

50:11.740 --> 50:12.740
跟之前一样

50:12.740 --> 50:13.740
而且缓这个目录

50:13.740 --> 50:14.740
它也是做了处理的

50:14.740 --> 50:15.740
它只能显示你

50:15.740 --> 50:16.740
直接依赖的就是

50:16.740 --> 50:17.740
CD

50:17.740 --> 50:19.740
就是你命令行工具

50:19.740 --> 50:20.740
间接依赖的

50:20.740 --> 50:21.740
它都不放在这

50:21.740 --> 50:22.740
间接依赖的

50:22.740 --> 50:23.740
都跑到这里边去了

50:23.740 --> 50:25.740
你看这是间接依赖的

50:25.740 --> 50:26.740
所以它把处理的

50:26.740 --> 50:27.740
非常好

50:27.740 --> 50:28.740
你看

50:28.740 --> 50:29.740
这里边就是

50:29.740 --> 50:30.740
除了摩卡之外

50:30.740 --> 50:31.740
全都有

50:31.740 --> 50:32.740
你找一找吧

50:32.740 --> 50:33.740
就是没有摩卡

50:33.740 --> 50:34.740
到了A

50:34.740 --> 50:35.740
就是没有摩卡

50:35.740 --> 50:36.740
除了摩卡就全都有

50:36.740 --> 50:38.740
那么全是间接依赖

50:38.740 --> 50:39.740
全在这

50:39.740 --> 50:40.740
好那么这里呢

50:40.740 --> 50:41.740
这里呢

50:41.740 --> 50:42.740
这里呢

50:42.740 --> 50:43.740
你看一下

50:43.740 --> 50:44.740
这里边是不是就是

50:44.740 --> 50:45.740
所有的包

50:45.740 --> 50:46.740
都在这里边

50:46.740 --> 50:47.740
我们来看一下摩卡

50:47.740 --> 50:48.740
看一下摩卡

50:48.740 --> 50:50.740
摩卡展开过后

50:50.740 --> 50:51.740
你看是不是版本

50:51.740 --> 50:53.740
版本下面是不是露的马九世

50:53.740 --> 50:54.740
露的马九世

50:54.740 --> 50:55.740
下面你看是不是全是链接

50:55.740 --> 50:57.740
只有谁除了自己之外

50:57.740 --> 50:58.740
除了摩卡自己之外

50:58.740 --> 51:00.740
是不是其他全是链接

51:00.740 --> 51:01.740
对吧

51:01.740 --> 51:02.740
给我们刚才一个图

51:02.740 --> 51:03.740
是不是一样的

51:03.740 --> 51:04.740
最后一个图

51:04.740 --> 51:05.740
你看A这个包里边

51:05.740 --> 51:06.740
除了A自己之外

51:06.740 --> 51:07.740
全是链接

51:07.740 --> 51:08.740
全是链接

51:08.740 --> 51:09.740
链接别人的

51:09.740 --> 51:10.740
同样的

51:10.740 --> 51:11.740
你看一下别的

51:11.740 --> 51:12.740
别的包

51:12.740 --> 51:14.740
你看是不是只有除了自己

51:14.740 --> 51:15.740
MKDRP

51:15.740 --> 51:16.740
除了自己就是

51:16.740 --> 51:18.740
直接依赖的链接

51:18.740 --> 51:19.740
对吧

51:19.740 --> 51:21.740
它就形成了这种格式

51:21.740 --> 51:22.740
然后在这里

51:22.740 --> 51:23.740
除了这个PMPM之外

51:23.740 --> 51:24.740
把直接依赖

51:24.740 --> 51:25.740
用个链接放这

51:25.740 --> 51:26.740
对吧

51:26.740 --> 51:27.740
用个链接放这

51:27.740 --> 51:28.740
OK

51:28.740 --> 51:29.740
下面这个文件

51:29.740 --> 51:30.740
是用来记录

51:30.740 --> 51:31.740
确切版本号的

51:31.740 --> 51:32.740
不用管

51:32.740 --> 51:33.740
OK

51:33.740 --> 51:34.740
就是PMPM它的执行员

51:34.740 --> 51:35.740
就讲完了

51:35.740 --> 51:36.740
就这个东西

51:36.740 --> 51:37.740
变色的时候考不考了

51:37.740 --> 51:38.740
不考了

51:38.740 --> 51:39.740
我相信

51:39.740 --> 51:40.740
你去网上搜一下

51:40.740 --> 51:42.740
我不知道你

51:42.740 --> 51:44.740
谁能跟你讲的这么细

51:44.740 --> 51:45.740
这一块

51:45.740 --> 51:47.740
网上

51:47.740 --> 51:48.740
我大概看了一下

51:48.740 --> 51:50.740
没有任何一篇文档

51:50.740 --> 51:51.740
包括国外的

51:51.740 --> 51:52.740
都没有

51:52.740 --> 51:53.740
你任何一篇

51:53.740 --> 51:54.740
至少我没有找到

51:54.740 --> 51:55.740
任何一篇文档

51:55.740 --> 51:56.740
是把这个东西

51:56.740 --> 51:57.740
讲的那么细的

51:57.740 --> 51:58.740
为什么讲的那么细

51:58.740 --> 51:59.740
不是因为它重要

51:59.740 --> 52:00.740
是因为我觉得这一块

52:00.740 --> 52:01.740
特别有意思

52:01.740 --> 52:02.740
而且

52:02.740 --> 52:03.740
你了解的就是文件

52:03.740 --> 52:04.740
什么一链接

52:04.740 --> 52:05.740
软链接这些东西

52:05.740 --> 52:06.740
这些东西对人意

52:06.740 --> 52:07.740
以后是有些帮助的

52:07.740 --> 52:09.740
PMPM本身这个原理

52:09.740 --> 52:10.740
面试的时候

52:10.740 --> 52:11.740
也不太会考虑

52:11.740 --> 52:12.740
OK

52:12.740 --> 52:13.740
这是关于PMPM的

52:13.740 --> 52:14.740
这些原理

52:14.740 --> 52:15.740
给大家讲清楚了

