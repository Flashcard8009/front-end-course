WEBVTT

00:01.460 --> 00:05.460
咱们这门课呢 叫做包管理工具

00:05.460 --> 00:09.460
有的时候呢 也把叫做包管理器 一个意思啊

00:09.460 --> 00:13.460
我们这门课 首先我们这门课学的东西啊

00:13.460 --> 00:16.460
你们以后在出去面试的时候呢

00:16.460 --> 00:18.460
一个都不会考

00:18.460 --> 00:20.460
除非它实在是没有考的了

00:20.460 --> 00:22.460
它会考虑一下在包管理工具这一块

00:22.460 --> 00:26.460
否则的话 基本上面试的时候是不会考的

00:26.460 --> 00:29.460
那是不是说这门课不重要了

00:29.460 --> 00:32.460
不是的 这门课是它之所以不会考

00:32.460 --> 00:34.460
是因为它非常的简单

00:34.460 --> 00:37.460
另外呢 这门课呢 它非常的重要

00:37.460 --> 00:39.460
为什么说它重要呢

00:39.460 --> 00:43.460
它是后边很多课程的基础

00:43.460 --> 00:46.460
比方说有些同学呢 学这个后边的webpack

00:46.460 --> 00:48.460
对吧 我们很重要的一门课

00:48.460 --> 00:50.460
那么webpack学不懂啊

00:50.460 --> 00:52.460
或者是觉得那里边怎么命令啊

00:52.460 --> 00:55.460
启动脚本啊 这东西乱七八糟的一大堆

00:55.460 --> 00:58.460
还有什么city 命令行 搞不清楚

00:58.460 --> 01:01.460
那怎么回事呢 就是因为它缺少了

01:01.460 --> 01:04.460
包管理工具这个基础知识

01:04.460 --> 01:07.460
所以说呢 这门课虽然说它面试的时候不考

01:07.460 --> 01:10.460
但是呢 它由于是后边很多课程的基础

01:10.460 --> 01:12.460
所以大家也得好好学

01:12.460 --> 01:14.460
另外呢 就是这门课呢 它非常的简单

01:14.460 --> 01:15.460
非常非常的简单

01:15.460 --> 01:16.460
简单到什么程度呢

01:16.460 --> 01:20.460
简单到比这个模块化还要简单

01:20.460 --> 01:21.460
大家应该学过模块化的吧

01:21.460 --> 01:22.460
也是我讲的课程

01:22.460 --> 01:25.460
那么这个模块化呢 已经是非常简单的课程了

01:25.460 --> 01:27.460
它比模块化都还要简单

01:27.460 --> 01:30.460
它就是高速的工具这么去使用

01:30.460 --> 01:32.460
好 那么我们这节课呢

01:32.460 --> 01:34.460
首先来做一个概述啊 介绍一下

01:34.460 --> 01:36.460
它的前因后果是怎么回事

01:36.460 --> 01:38.460
这个包管理工具到底是什么玩意

01:38.460 --> 01:39.460
它是怎么产生的

01:39.460 --> 01:41.460
咱们首先介绍一下

01:41.460 --> 01:44.460
首先呢 我们这门课的前置知识啊

01:44.460 --> 01:45.460
就是你要学习这门课呢

01:45.460 --> 01:46.460
一定有些前置知识

01:46.460 --> 01:48.460
当然你得有解释

01:48.460 --> 01:50.460
还要学习过ES6

01:50.460 --> 01:52.460
还得学习过模块化

01:52.460 --> 01:55.460
还得学习过Gate

01:55.460 --> 01:57.460
就是我们之前学的那个就是

01:59.460 --> 02:01.460
Gate 你得学习了

02:01.460 --> 02:03.460
模块化的话

02:03.460 --> 02:05.460
这里边呢 因为我是讲的模块化

02:05.460 --> 02:07.460
模块化这里面我讲了漏的安装

02:07.460 --> 02:08.460
漏的安装

02:08.460 --> 02:09.460
所以说呢

02:09.460 --> 02:11.460
到你们得学的时候呢

02:11.460 --> 02:13.460
学这门课的时候呢

02:13.460 --> 02:14.460
把模块化学完了之后呢

02:14.460 --> 02:15.460
你肯定是安装的漏的

02:15.460 --> 02:16.460
我们这门课呢

02:16.460 --> 02:18.460
就不设计漏的安装了

02:18.460 --> 02:19.460
好 然后呢

02:19.460 --> 02:21.460
我们这门课的所有的代码

02:21.460 --> 02:23.460
一旦设计到代码

02:23.460 --> 02:25.460
全部书写在漏的介石环境中

02:25.460 --> 02:27.460
就说我们这门课是针对

02:27.460 --> 02:28.460
漏的环境的

02:28.460 --> 02:30.460
不针对浏览器环境

02:30.460 --> 02:31.460
有的时候说

02:31.460 --> 02:33.460
我们漏的还没有怎么学呀

02:33.460 --> 02:34.460
我们只学了一个漏的安装

02:34.460 --> 02:35.460
以及common介石

02:35.460 --> 02:36.460
够了

02:36.460 --> 02:38.460
我们只需要漏的环境

02:38.460 --> 02:39.460
以及common介石

02:39.460 --> 02:41.460
这个模块化标准就完全够了

02:41.460 --> 02:43.460
那么至于浏览器环境

02:43.460 --> 02:45.460
需不需要保管力工具呢

02:45.460 --> 02:46.460
需要

02:46.460 --> 02:47.460
但是浏览器环境

02:47.460 --> 02:48.460
为什么现在学不了呢

02:48.460 --> 02:49.460
因为保管力器呢

02:49.460 --> 02:50.460
目前呢

02:50.460 --> 02:52.460
缺少了一些技术的情况下

02:52.460 --> 02:55.460
在浏览器环境是没法用的

02:55.460 --> 02:57.460
那么浏览器环境怎么办呢

02:57.460 --> 02:59.460
是我们后边的一门课程

02:59.460 --> 03:00.460
叫做

03:00.460 --> 03:02.460
构建工具来搞定的

03:02.460 --> 03:03.460
构建工具呢

03:03.460 --> 03:05.460
它可以搞定浏览器环境

03:05.460 --> 03:06.460
当然构建工具它不一定

03:06.460 --> 03:08.460
只是针对浏览器环境

03:08.460 --> 03:09.460
它针对所有环境

03:09.460 --> 03:10.460
不过浏览器环境呢

03:10.460 --> 03:12.460
就可以通过构建工具来搞定

03:12.460 --> 03:14.460
原来这个意思嘛

03:14.460 --> 03:15.460
总之呢我们这门课

03:15.460 --> 03:17.460
是在漏的环境下学习的

03:17.460 --> 03:19.460
所以说你得把漏的环境安装好

03:19.460 --> 03:20.460
好那么接下来

03:20.460 --> 03:22.460
我们来具体看啊

03:22.460 --> 03:24.460
在我们这节课学习之前

03:24.460 --> 03:25.460
就是概述之前

03:25.460 --> 03:26.460
我们首先学习一些概念

03:26.460 --> 03:27.460
因为有些同学呢

03:27.460 --> 03:29.460
我听到有些同学在问

03:29.460 --> 03:30.460
怎么磨块啊

03:30.460 --> 03:31.460
什么裤啊

03:31.460 --> 03:32.460
什么包啊

03:32.460 --> 03:33.460
这概念

03:33.460 --> 03:34.460
他们到底有什么区别

03:34.460 --> 03:35.460
怎么来的

03:35.460 --> 03:37.460
我给大家做一个解释

03:37.460 --> 03:38.460
磨块呢

03:38.460 --> 03:39.460
我们之前已经解释过了

03:39.460 --> 03:40.460
什么东西呢

03:40.460 --> 03:42.460
通常在介事

03:42.460 --> 03:43.460
我们说的介事磨块

03:43.460 --> 03:44.460
就是什么呢

03:44.460 --> 03:46.460
通常是以单个文件的形式

03:46.460 --> 03:47.460
得回归一下我们的磨块的话

03:47.460 --> 03:48.460
是不是一个文件

03:48.460 --> 03:49.460
一个磨块

03:49.460 --> 03:51.460
通过某种方式来导出

03:51.460 --> 03:52.460
当然我们现在是漏的环境

03:52.460 --> 03:54.460
那是什么方式导出啊

03:54.460 --> 03:57.460
是不是用common介事的方式来导出

03:57.460 --> 03:58.460
那么在一个磨块里面

03:58.460 --> 03:59.460
要导出另外一个磨块

03:59.460 --> 04:00.460
是用require来导出

04:00.460 --> 04:01.460
对吧

04:01.460 --> 04:02.460
当然s6呢

04:02.460 --> 04:04.460
有s6的导入和导出方式

04:04.460 --> 04:05.460
总之呢

04:05.460 --> 04:06.460
一个文件呢

04:06.460 --> 04:07.460
它

04:07.460 --> 04:09.460
以某一个文件的形式

04:09.460 --> 04:11.460
存在的功能片段

04:11.460 --> 04:13.460
什么叫功能片段呢

04:13.460 --> 04:14.460
功能片段呢

04:14.460 --> 04:16.460
就是说我们要实现一个整体的功能

04:16.460 --> 04:18.460
它是有很多很多的小功能组成的

04:18.460 --> 04:20.460
那么你把这些小功能

04:20.460 --> 04:21.460
放到一个一个的文件中

04:21.460 --> 04:22.460
那么这些文件呢

04:22.460 --> 04:23.460
就是一个磨块

04:23.460 --> 04:26.460
每个文件就是一个磨块

04:26.460 --> 04:28.460
比如说我提供这么一个磨块

04:28.460 --> 04:30.460
这个磨块实现什么功能呢

04:30.460 --> 04:33.460
实现一些产生一些水积书啊

04:33.460 --> 04:35.460
产生一些水积的制补圈啊

04:35.460 --> 04:39.460
产生一些水积的制服啊

04:39.460 --> 04:40.460
比如说ABCD

04:40.460 --> 04:41.460
A到Z

04:41.460 --> 04:42.460
产生一个水积的制服

04:42.460 --> 04:44.460
那么这些呢

04:44.460 --> 04:46.460
都是一些功能片段

04:46.460 --> 04:49.460
它是为整体功能实现来服务的

04:49.460 --> 04:50.460
那么像这个东西呢

04:50.460 --> 04:51.460
而且呢

04:51.460 --> 04:53.460
它是以单个文件形式来出现

04:53.460 --> 04:54.460
那么像这个东西呢

04:54.460 --> 04:55.460
我们把它叫做磨块

04:55.460 --> 04:56.460
那么磨块里面呢

04:56.460 --> 04:58.460
有一个特殊磨块

04:58.460 --> 05:00.460
叫做入口磨块

05:00.460 --> 05:01.460
或者是主磨块

05:01.460 --> 05:02.460
我们之前也学过的吧

05:02.460 --> 05:03.460
在磨块里面

05:03.460 --> 05:04.460
我们通常的磨块

05:04.460 --> 05:05.460
都有一个入口文件

05:05.460 --> 05:07.460
或者把它叫做主文件

05:07.460 --> 05:08.460
或者叫做启动文件

05:08.460 --> 05:10.460
那么像这个文件的磨块呢

05:10.460 --> 05:11.460
我们把它称为入口磨块

05:11.460 --> 05:13.460
或者是主磨块

05:13.460 --> 05:14.460
这是一些概念

05:14.460 --> 05:15.460
首先磨块我们考清楚

05:15.460 --> 05:17.460
你先脑在里面你就想

05:17.460 --> 05:18.460
一个磨块就有一个文件

05:18.460 --> 05:20.460
这个文件实现了一个功能片段

05:20.460 --> 05:21.460
一个小功能

05:21.460 --> 05:23.460
那么什么叫酷呢

05:23.460 --> 05:24.460
酷呢

05:24.460 --> 05:26.460
这个单词要对应一下

05:26.460 --> 05:27.460
磨块叫marge

05:27.460 --> 05:29.460
酷叫nebulary

05:29.460 --> 05:30.460
点成neb

05:30.460 --> 05:32.460
那么这个酷是什么意思呢

05:32.460 --> 05:33.460
我们先让它说第三方酷

05:33.460 --> 05:34.460
第三方酷

05:34.460 --> 05:35.460
那么酷是什么意思呢

05:35.460 --> 05:36.460
酷是

05:36.460 --> 05:38.460
它是由一个或多个磨块

05:38.460 --> 05:41.460
组成的完整功能

05:41.460 --> 05:42.460
那么磨块

05:42.460 --> 05:43.460
它可能只是一个功能片段

05:43.460 --> 05:45.460
你光靠的功能片段呢

05:45.460 --> 05:47.460
也实现不了什么东西

05:47.460 --> 05:49.460
但是呢多个磨块组合而成

05:49.460 --> 05:51.460
那么它可能形成一个完整的功能

05:51.460 --> 05:52.460
比方说

05:52.460 --> 05:53.460
咱们的Jquery

05:53.460 --> 05:54.460
对吧

05:54.460 --> 05:55.460
Jquery就是一个完整的功能

05:55.460 --> 05:56.460
比方说

05:56.460 --> 05:58.460
我们这里写一下啊

05:58.460 --> 05:59.460
像什么Jquery啊

05:59.460 --> 06:01.460
像什么moke.js啊

06:01.460 --> 06:02.460
对吧

06:02.460 --> 06:03.460
像这些呢就是一个

06:03.460 --> 06:04.460
就是一个酷了

06:04.460 --> 06:05.460
就是酷级别了

06:05.460 --> 06:07.460
它里面可以包含很多的磨块

06:07.460 --> 06:09.460
那么把这些磨块整合起来

06:09.460 --> 06:10.460
那么形成一个完整的功能

06:10.460 --> 06:12.460
那么就是一个酷

06:12.460 --> 06:14.460
酷的范畴它更大一点

06:14.460 --> 06:15.460
moke.js大家学过没有

06:15.460 --> 06:17.460
是来模拟数据的

06:17.460 --> 06:19.460
总之呢没学过也没关系啊

06:19.460 --> 06:21.460
我就是告诉大家酷的概念

06:21.460 --> 06:23.460
那么这个酷呢

06:23.460 --> 06:24.460
它的主要作用呢

06:24.460 --> 06:27.460
是为开发中的某一方面的问题

06:27.460 --> 06:29.460
提供完整的解决方案

06:29.460 --> 06:30.460
什么意思呢

06:30.460 --> 06:32.460
比方说像我们的Jquery酷

06:32.460 --> 06:34.460
我们平时用原生的动物能不能用

06:34.460 --> 06:35.460
它能用

06:35.460 --> 06:37.460
但是用起来是不是麻烦

06:37.460 --> 06:41.460
为了减化我们用原生的动物的凡数

06:41.460 --> 06:43.460
所以说呢Jquery酷出现了

06:43.460 --> 06:45.460
它提供了一种完整的方案

06:45.460 --> 06:46.460
什么方案呢

06:46.460 --> 06:47.460
就通过选择器对吧

06:47.460 --> 06:52.460
以及大量的Jquery对象的属性和方法

06:52.460 --> 06:53.460
特别是方法对吧

06:53.460 --> 06:55.460
提供大量的Jquery的方法

06:55.460 --> 06:57.460
来帮助我们来操作动物元素

06:57.460 --> 06:59.460
是不是一套完整的方案对吧

06:59.460 --> 07:01.460
它是为了解决开发中某一方面的问题

07:01.460 --> 07:02.460
对吧

07:02.460 --> 07:03.460
它只是解决

07:03.460 --> 07:04.460
或许动物对象难的问题

07:04.460 --> 07:06.460
操作动物对象繁硕的问题对吧

07:06.460 --> 07:08.460
提供一个完整的解决方案

07:08.460 --> 07:09.460
像moke.js呢

07:09.460 --> 07:10.460
大家没学过

07:10.460 --> 07:11.460
没说没关系

07:11.460 --> 07:12.460
它自己提供了什么方案呢

07:12.460 --> 07:13.460
就是有了之后呢

07:13.460 --> 07:15.460
我们要模拟数据

07:15.460 --> 07:17.460
比方说模拟100个学生

07:17.460 --> 07:18.460
模拟200个学生

07:18.460 --> 07:19.460
那么平时呢

07:19.460 --> 07:20.460
我们要自己写的话

07:20.460 --> 07:21.460
很麻烦啊

07:21.460 --> 07:22.460
我的一个一个

07:22.460 --> 07:23.460
就是做一些测试的时候

07:23.460 --> 07:25.460
我的一个一个写写对象

07:25.460 --> 07:26.460
对象里面有些属性

07:26.460 --> 07:27.460
很麻烦

07:27.460 --> 07:28.460
那么moke.js呢

07:28.460 --> 07:29.460
可以用简单的几行代码

07:29.460 --> 07:31.460
就可以模拟出大量的数据

07:31.460 --> 07:33.460
它是为某一方面的事情

07:33.460 --> 07:35.460
提供一些完整的解决方案

07:35.460 --> 07:36.460
这是酷

07:36.460 --> 07:37.460
总之呢

07:37.460 --> 07:38.460
我们有这么概念

07:38.460 --> 07:39.460
模困的是单个文件

07:39.460 --> 07:40.460
酷是有很多

07:40.460 --> 07:41.460
一个

07:41.460 --> 07:42.460
或者多个模困组成的

07:42.460 --> 07:43.460
比方说一些简单的酷呢

07:43.460 --> 07:44.460
它可能一个文件就搞定了

07:44.460 --> 07:46.460
不需要多个多个模困

07:46.460 --> 07:48.460
一个模困就搞定的

07:48.460 --> 07:49.460
这是酷

07:49.460 --> 07:51.460
就翻手上不一样

07:51.460 --> 07:53.460
那么最后呢就是包

07:53.460 --> 07:54.460
包它的单词呢

07:54.460 --> 07:55.460
是package

07:55.460 --> 07:56.460
这个单词呢

07:56.460 --> 07:57.460
我们在我们这门课里面

07:57.460 --> 07:58.460
会经常看到

07:58.460 --> 08:00.460
包是什么呢

08:00.460 --> 08:02.460
包其实就是酷的进一步升级

08:02.460 --> 08:04.460
包是什么呢

08:04.460 --> 08:06.460
包其实就是包含元数据的酷

08:07.460 --> 08:08.460
什么叫元数据呢

08:08.460 --> 08:09.460
元数据呢

08:09.460 --> 08:11.460
就是一些额外的信息

08:11.460 --> 08:12.460
哪些信息呢

08:12.460 --> 08:13.460
比方说

08:13.460 --> 08:14.460
你不是开发的一个结块位吗

08:14.460 --> 08:15.460
对吧

08:15.460 --> 08:16.460
那么你的酷的名称是什么呢

08:16.460 --> 08:17.460
名称就叫做结块位

08:17.460 --> 08:18.460
描述什么呢

08:18.460 --> 08:19.460
描述是什么呢

08:19.460 --> 08:20.460
描述就是

08:20.460 --> 08:21.460
我这个酷呢

08:21.460 --> 08:22.460
结块位这个酷呢

08:22.460 --> 08:24.460
是用来方便

08:24.460 --> 08:26.460
操作动物元素的

08:26.460 --> 08:27.460
就是个简单的描述

08:27.460 --> 08:29.460
当然你的github主页

08:29.460 --> 08:31.460
因为我们很多的酷呢

08:31.460 --> 08:33.460
都在放到github上开源的吧

08:33.460 --> 08:35.460
那么你的github主页是什么呢

08:35.460 --> 08:36.460
你放上去

08:36.460 --> 08:38.460
这些东西都是一些描述信息

08:38.460 --> 08:40.460
你的徐克正协议

08:40.460 --> 08:41.460
徐克正协议我们后边呢

08:41.460 --> 08:42.460
讲那个上传酷的时候

08:42.460 --> 08:44.460
发布我们自己写的酷的时候

08:44.460 --> 08:45.460
包的时候呢

08:45.460 --> 08:46.460
我们会讲

08:46.460 --> 08:47.460
还有一些什么桌子

08:47.460 --> 08:49.460
你的结块桌子是谁啊

08:49.460 --> 08:50.460
你这个结块的酷

08:50.460 --> 08:52.460
还要不要用到别的酷啊

08:52.460 --> 08:53.460
这些依赖对吧

08:53.460 --> 08:54.460
依赖依赖关系

08:54.460 --> 08:56.460
那么这些信息全部包含进来

08:56.460 --> 08:58.460
形成一个文档

08:58.460 --> 08:59.460
形成一个文档

08:59.460 --> 09:00.460
我就说

09:00.460 --> 09:01.460
我这个酷的一些详细信息

09:01.460 --> 09:02.460
让描述出来

09:02.460 --> 09:04.460
那么一个酷一旦有了

09:04.460 --> 09:05.460
这些信息过后了

09:05.460 --> 09:07.460
我们就可以把它称之为包

09:07.460 --> 09:08.460
别人的意思吗

09:08.460 --> 09:10.460
所以说我们下面这张图呢

09:10.460 --> 09:12.460
就可以很好的表示出这些的关系

09:12.460 --> 09:13.460
文的模块呢

09:13.460 --> 09:15.460
是一个单独的文件对吧

09:15.460 --> 09:16.460
多个模块

09:16.460 --> 09:17.460
当然也可能是一个模块

09:17.460 --> 09:19.460
它会组成一个完整的功能

09:19.460 --> 09:20.460
这个功能呢

09:20.460 --> 09:22.460
就是酷

09:22.460 --> 09:23.460
那么我们说包呢

09:23.460 --> 09:25.460
包其实就在酷的基础上

09:25.460 --> 09:26.460
增加了一些元数据

09:26.460 --> 09:28.460
增加了一些描述信息

09:28.460 --> 09:29.460
所以说

09:29.460 --> 09:31.460
如果说你已经有了结块的酷了

09:31.460 --> 09:32.460
比方说我是一个作者

09:32.460 --> 09:33.460
我是结块的作者

09:33.460 --> 09:35.460
那么我已经写好了结块了

09:35.460 --> 09:36.460
是不是已经写好了一个酷了

09:36.460 --> 09:37.460
对吧

09:37.460 --> 09:38.460
那么我们如何把它变成包呢

09:38.460 --> 09:40.460
就是给它添加一些描述信息

09:40.460 --> 09:41.460
就把它变成包了

09:41.460 --> 09:44.460
所以说包和酷之间呢

09:44.460 --> 09:45.460
如果你一旦有了酷

09:45.460 --> 09:46.460
你要把它变成包了

09:46.460 --> 09:47.460
是非常非常容易的

09:47.460 --> 09:49.460
加上一些描述就完事了

09:49.460 --> 09:50.460
因此呢

09:50.460 --> 09:51.460
我们很多时候呢

09:51.460 --> 09:52.460
在概念上呢

09:52.460 --> 09:54.460
也没有去严格区分什么包啊

09:54.460 --> 09:55.460
酷啊

09:55.460 --> 09:56.460
我们都可以认为它差不多的

09:56.460 --> 09:57.460
跟差不多的

09:57.460 --> 09:58.460
好吧

09:58.460 --> 09:59.460
就这么一个意思啊

09:59.460 --> 10:01.460
就是这个三个概念

10:01.460 --> 10:02.460
好

10:02.460 --> 10:04.460
我们来看

10:04.460 --> 10:05.460
包管理器

10:05.460 --> 10:06.460
包管理工具

10:06.460 --> 10:08.460
它是怎么出现的

10:08.460 --> 10:09.460
之前呢

10:09.460 --> 10:11.460
咱们学了这个模块画

10:11.460 --> 10:13.460
模块画最早的模块画

10:13.460 --> 10:14.460
就是咱们的前端里面

10:14.460 --> 10:16.460
就是CommonJets对吧

10:16.460 --> 10:18.460
CommonJets模块画的出现了

10:18.460 --> 10:21.460
实在在Snow的环境下面的Jets代码

10:21.460 --> 10:22.460
我们以前写的

10:22.460 --> 10:24.460
也在浏览器环境里面写Jets代码

10:24.460 --> 10:25.460
是不是经常是一个文件

10:25.460 --> 10:26.460
要写大腿

10:26.460 --> 10:27.460
对吧

10:27.460 --> 10:29.460
也不敢分成太多的文件了

10:29.460 --> 10:30.460
为什么呢

10:30.460 --> 10:31.460
因为

10:31.460 --> 10:33.460
你一旦分成太多一个文件的话

10:33.460 --> 10:34.460
你叫考虑其他文件

10:34.460 --> 10:36.460
你不要有没有全球面量污染的问题

10:36.460 --> 10:37.460
对吧

10:37.460 --> 10:39.460
就是我们之前讲模块画的一些问题

10:39.460 --> 10:40.460
但是有了模块画之后呢

10:40.460 --> 10:42.460
我们就可以把Jets代码

10:42.460 --> 10:44.460
分得非常非常细

10:44.460 --> 10:45.460
分得非常非常细

10:45.460 --> 10:47.460
因为它不会造成污染

10:47.460 --> 10:48.460
而且呢

10:48.460 --> 10:49.460
它模块里面本身

10:49.460 --> 10:50.460
通过声明

10:50.460 --> 10:51.460
就是Require的方式

10:51.460 --> 10:52.460
就可以明确一代了

10:52.460 --> 10:53.460
对吧

10:53.460 --> 10:54.460
我这个模块

10:54.460 --> 10:55.460
一代哪些模块

10:55.460 --> 10:56.460
我们只需要用Require就行了

10:56.460 --> 10:58.460
一代关系非常的清晰

10:58.460 --> 10:59.460
因此呢

10:59.460 --> 11:00.460
有了模块画之后呢

11:00.460 --> 11:01.460
特别是在最早的时候

11:01.460 --> 11:03.460
是loader环境里面有了模块画

11:03.460 --> 11:05.460
因此在loader环境下面的Jets代码

11:05.460 --> 11:07.460
它就可以使用模画画的这种方式

11:07.460 --> 11:09.460
对整个工程的

11:09.460 --> 11:12.460
进行更加细腻度的划分

11:12.460 --> 11:13.460
什么叫细腻度

11:13.460 --> 11:15.460
就功能分得更细了

11:15.460 --> 11:16.460
我们可能一个类啊

11:16.460 --> 11:17.460
一个函数

11:17.460 --> 11:18.460
一个对象

11:18.460 --> 11:19.460
一个配置

11:19.460 --> 11:20.460
甚至一个配置

11:20.460 --> 11:21.460
就是存了一些长量

11:21.460 --> 11:22.460
这么一些配置

11:22.460 --> 11:24.460
那么这些人都可以作为一个模块

11:24.460 --> 11:25.460
单独的模块

11:25.460 --> 11:26.460
对吧

11:26.460 --> 11:28.460
我们以前的浏览器里面

11:28.460 --> 11:29.460
是很难想象的

11:29.460 --> 11:30.460
但是呢

11:30.460 --> 11:31.460
有了模块画之后呢

11:31.460 --> 11:32.460
我们就可以这样做了

11:32.460 --> 11:34.460
那么这种细腻度的划分呢

11:34.460 --> 11:37.460
正是开发大型应用的技术

11:37.460 --> 11:39.460
就是你要开发一个大型应用

11:39.460 --> 11:41.460
你要让你的应用

11:41.460 --> 11:42.460
足够好啊

11:42.460 --> 11:43.460
容易维护

11:43.460 --> 11:45.460
那么你一定要进行细腻度的划分

11:45.460 --> 11:47.460
越细越好

11:47.460 --> 11:49.460
因为你一旦细腻度的之后呢

11:49.460 --> 11:51.460
那么每一个小的模块

11:51.460 --> 11:53.460
我们就可以进行灵活的组装

11:53.460 --> 11:55.460
可以把它组装成一个大的模块

11:55.460 --> 11:57.460
也可以对小的模块进行重复使用

11:57.460 --> 11:59.460
就非常灵活方便

11:59.460 --> 12:01.460
所以说我们要实现

12:01.460 --> 12:03.460
要在前端能够实现大型应用

12:03.460 --> 12:05.460
那么必须要有模块画

12:05.460 --> 12:07.460
这是我们在模块画内里讲的

12:09.460 --> 12:12.460
有了模块画作为基础之后呢

12:12.460 --> 12:15.460
很多的开发者可以想了

12:15.460 --> 12:16.460
咱们有了模块画

12:16.460 --> 12:18.460
那么我们就可以编写更加

12:18.460 --> 12:20.460
精细的一些小的模块

12:20.460 --> 12:22.460
然后用这些模块组装成一个

12:22.460 --> 12:24.460
完整的第三方库

12:24.460 --> 12:26.460
来解决一些问题了

12:26.460 --> 12:28.460
因此有了模块画之后

12:28.460 --> 12:31.460
很多第三方库开始出现了

12:31.460 --> 12:33.460
比如说加密

12:33.460 --> 12:35.460
咱们GS对一些制服串的加密

12:35.460 --> 12:36.460
现在大家还没有学习

12:36.460 --> 12:38.460
你们以后肯定会设计到的

12:38.460 --> 12:40.460
特别是在服务端你会设计到

12:40.460 --> 12:42.460
因为现在你们还没有完整的

12:42.460 --> 12:43.460
学习都得GS了

12:43.460 --> 12:45.460
那么GS里面可能要对

12:45.460 --> 12:47.460
一些制服串的进行加密

12:47.460 --> 12:49.460
或者有的时候

12:49.460 --> 12:51.460
我们就可以把加密

12:51.460 --> 12:53.460
去做成一个模块发布上去

12:53.460 --> 12:55.460
做成一个不是模块

12:55.460 --> 12:57.460
做成一个库发布上去

12:57.460 --> 12:59.460
那么就可以使用这个库的功能

12:59.460 --> 13:00.460
就可以反复使用

13:00.460 --> 13:01.460
没有必要去从

13:01.460 --> 13:02.460
每次开发的时候

13:02.460 --> 13:03.460
一遇到加密我都要重新继续写

13:03.460 --> 13:04.460
没必要了

13:04.460 --> 13:06.460
我们把它做成一些通用的库

13:06.460 --> 13:09.460
比如说常见的一些工具方法

13:09.460 --> 13:11.460
比如说像什么

13:11.460 --> 13:13.460
给产生一个水机的字幕刷

13:13.460 --> 13:14.460
产生一个水机树

13:14.460 --> 13:15.460
稳筋上用的

13:15.460 --> 13:18.460
或者是对一个对象进行刻龙

13:18.460 --> 13:19.460
浅刻龙 深刻龙

13:19.460 --> 13:21.460
一些常见的工具方法

13:21.460 --> 13:24.460
我们也可以把它做成一个第三方库

13:24.460 --> 13:26.460
像什么模拟数据

13:26.460 --> 13:28.460
这些我们是经常遇到的需求

13:28.460 --> 13:30.460
我们没有必要每次开发的时候

13:30.460 --> 13:31.460
全部重新写

13:31.460 --> 13:33.460
其实你们以后在公司里面开发的时候

13:33.460 --> 13:35.460
很多的时候

13:35.460 --> 13:36.460
特别是一些重要的功能

13:36.460 --> 13:37.460
常见的功能

13:37.460 --> 13:39.460
你都不需要自己去写

13:39.460 --> 13:42.460
你利用一些第三方库都可以搞定

13:42.460 --> 13:43.460
因此有人开玩笑说

13:43.460 --> 13:44.460
咱们学程序

13:44.460 --> 13:46.460
其实就学程序开发

13:46.460 --> 13:48.460
绝大部分时候是在查

13:48.460 --> 13:50.460
查有没有现成的

13:50.460 --> 13:51.460
是在百度

13:51.460 --> 13:53.460
而不是在敲带

13:53.460 --> 13:55.460
以及大部分时候

13:55.460 --> 13:57.460
以及是在学习

13:57.460 --> 13:59.460
别人的库是怎么去使用的

13:59.460 --> 14:01.460
这是一种现象

14:01.460 --> 14:02.460
这是正常的

14:02.460 --> 14:04.460
没有必要重复去造轮子

14:04.460 --> 14:05.460
去做一些重复的劳动

14:05.460 --> 14:06.460
别人写好的

14:06.460 --> 14:07.460
而且成熟的东西

14:07.460 --> 14:08.460
我们就可以直接拿来用

14:08.460 --> 14:09.460
魔幻化的出现

14:09.460 --> 14:11.460
就推动了这一个趋势了

14:11.460 --> 14:13.460
很多的第三方库

14:13.460 --> 14:16.460
大量的在前端社区湧现

14:16.460 --> 14:19.460
那么这些库都是为漏德服务的

14:19.460 --> 14:21.460
我们这门客只讨论漏德环境

14:21.460 --> 14:22.460
那么这些库呢

14:22.460 --> 14:23.460
他们使用common GS

14:23.460 --> 14:25.460
标准来书写而成

14:25.460 --> 14:26.460
非常容易使用

14:26.460 --> 14:27.460
怎么使用呢

14:27.460 --> 14:29.460
你只需要把这个库下载下来

14:29.460 --> 14:30.460
比方说

14:30.460 --> 14:32.460
这个库里边给你提供了

14:32.460 --> 14:35.460
比方说有一个库叫做abc

14:35.460 --> 14:37.460
有这么一个库

14:37.460 --> 14:38.460
那么它给你提供

14:38.460 --> 14:40.460
它里边有很多魔幻文件

14:40.460 --> 14:41.460
很多的魔幻文件

14:41.460 --> 14:43.460
比方说Adder GS

14:43.460 --> 14:45.460
它里边有很多的GS

14:45.460 --> 14:46.460
Cader GS

14:46.460 --> 14:48.460
还提供了一个index的GS

14:48.460 --> 14:50.460
你把这些库是不是下载下来

14:50.460 --> 14:52.460
那么是不是可以把放到你的工程里边

14:52.460 --> 14:53.460
你用个文件夹嘛

14:53.460 --> 14:54.460
比方说就一个abc

14:54.460 --> 14:56.460
把它放到你的工程里边

14:56.460 --> 14:57.460
放到工程里边下载下来过后呢

14:57.460 --> 14:58.460
那怎么去使用呢

14:58.460 --> 15:00.460
你就参考了官方网站

15:00.460 --> 15:01.460
官方网站怎么用就怎么用

15:01.460 --> 15:02.460
比方说它说

15:02.460 --> 15:04.460
你要实现某一个功能

15:04.460 --> 15:06.460
你要导入这个b这个魔幻

15:06.460 --> 15:08.460
ok 那你就怎么写呢

15:08.460 --> 15:09.460
你就可以这样写

15:09.460 --> 15:11.460
require

15:11.460 --> 15:13.460
我之前写过了对吧

15:13.460 --> 15:16.460
导入abc下面的b.js

15:16.460 --> 15:17.460
对吧

15:17.460 --> 15:18.460
是不是可以这样子写

15:18.460 --> 15:19.460
因此非常容易使用对吧

15:19.460 --> 15:20.460
对吧

15:20.460 --> 15:21.460
非常容易使用

15:21.460 --> 15:22.460
你把导入进来

15:22.460 --> 15:23.460
它就会

15:23.460 --> 15:24.460
官方文档里边就会告诉你

15:24.460 --> 15:26.460
你导入这个b里边有哪些东西

15:26.460 --> 15:27.460
有哪些方法

15:27.460 --> 15:28.460
有哪些属性

15:28.460 --> 15:29.460
它就会告诉你

15:29.460 --> 15:31.460
按照它的要求来去使用就行了

15:31.460 --> 15:32.460
或者说

15:32.460 --> 15:33.460
它说我们的所有东西

15:33.460 --> 15:34.460
都是在index里边

15:34.460 --> 15:36.460
ok 那你可以导入这个index

15:36.460 --> 15:37.460
对吧

15:37.460 --> 15:38.460
那么导入进来

15:38.460 --> 15:39.460
怎么去使用

15:39.460 --> 15:41.460
ok 那么看官方文档怎么去使用

15:41.460 --> 15:42.460
没了意思嘛

15:42.460 --> 15:43.460
这就是

15:43.460 --> 15:46.460
用起来还非常非常的方便

15:46.460 --> 15:48.460
然而呢

15:48.460 --> 15:50.460
我们这下来要说它的问题了

15:50.460 --> 15:51.460
这些问题呢

15:51.460 --> 15:52.460
就会引出

15:52.460 --> 15:54.460
为什么需要保管连续

15:54.460 --> 15:57.460
然而在下载和使用

15:57.460 --> 15:59.460
这些第三方库的时候呢

15:59.460 --> 16:00.460
我们遇到了一些

16:00.460 --> 16:02.460
非常头痛的问题

16:02.460 --> 16:04.460
来 我们接下来看一下这些问题

16:04.460 --> 16:05.460
以及这些问题是怎么产生的

16:05.460 --> 16:07.460
我们了解一下

16:07.460 --> 16:09.460
这些问题会让你非常非常痛苦

16:09.460 --> 16:11.460
来 第一个

16:11.460 --> 16:14.460
下载过程非常繁硕

16:14.460 --> 16:15.460
就是我们

16:15.460 --> 16:19.460
从决定要去使用一个第三方库

16:19.460 --> 16:21.460
然后到我们真正开始

16:21.460 --> 16:22.460
去使用它

16:22.460 --> 16:24.460
这个过程是很繁硕的

16:24.460 --> 16:25.460
怎么繁硕法呢

16:25.460 --> 16:26.460
我们来看一下

16:26.460 --> 16:28.460
我们要做哪些事情

16:28.460 --> 16:29.460
比方说我要去使用

16:29.460 --> 16:32.460
这个名字叫做abc的这个库

16:32.460 --> 16:33.460
我要怎么去做呢

16:33.460 --> 16:35.460
首先我们是要照百度

16:35.460 --> 16:36.460
对吧

16:36.460 --> 16:37.460
到百度里边去

16:37.460 --> 16:38.460
然后呢

16:38.460 --> 16:41.460
去搜索一下abc这个库

16:41.460 --> 16:43.460
观网地址是什么

16:43.460 --> 16:44.460
或者是

16:44.460 --> 16:46.460
github上面去搜索一下abc这个库

16:46.460 --> 16:47.460
对吧

16:47.460 --> 16:49.460
看它的github主页是什么

16:49.460 --> 16:50.460
然后说进入观网

16:50.460 --> 16:51.460
或者进入主页

16:51.460 --> 16:52.460
那么它肯定不管是

16:52.460 --> 16:53.460
你是观网也好

16:53.460 --> 16:54.460
还是github也好

16:54.460 --> 16:55.460
那么它一般呢

16:55.460 --> 16:57.460
会提供一个下载

16:57.460 --> 16:58.460
那么可以通过

16:58.460 --> 16:59.460
观网的下载呢

16:59.460 --> 17:01.460
去找到你想要的版本

17:01.460 --> 17:02.460
比方说它有很多个版本

17:02.460 --> 17:03.460
你想要哪个版本

17:03.460 --> 17:04.460
或者是

17:04.460 --> 17:05.460
一般都是想要最新版

17:05.460 --> 17:06.460
对吧

17:06.460 --> 17:07.460
那么你把它下载下来

17:07.460 --> 17:09.460
下载下来之后又干嘛呢

17:09.460 --> 17:10.460
你是不是要把它

17:10.460 --> 17:12.460
拷贝到工程目的里边去

17:12.460 --> 17:13.460
对吧

17:13.460 --> 17:14.460
一般来说呢

17:14.460 --> 17:15.460
我们工程里边呢

17:15.460 --> 17:16.460
会建立这么一个目录

17:16.460 --> 17:17.460
比方说

17:17.460 --> 17:18.460
这个是我们的工程

17:18.460 --> 17:19.460
我们会建立这么一个目录

17:19.460 --> 17:20.460
比方说package

17:20.460 --> 17:21.460
package是

17:21.460 --> 17:22.460
或者是呢

17:22.460 --> 17:23.460
我们给它

17:23.460 --> 17:24.460
从命名

17:24.460 --> 17:25.460
或者叫neb

17:25.460 --> 17:26.460
neb

17:26.460 --> 17:27.460
就是一个库

17:27.460 --> 17:29.460
就是我们用的第三方库

17:29.460 --> 17:30.460
我们把它放到这个文件夹里边

17:30.460 --> 17:31.460
很多的库

17:31.460 --> 17:32.460
一个库一个文件夹

17:32.460 --> 17:33.460
一个库一个文件夹

17:33.460 --> 17:34.460
放进来

17:34.460 --> 17:35.460
对吧

17:35.460 --> 17:36.460
我们要这么做

17:36.460 --> 17:37.460
比方说我们要放一个abc的库

17:37.460 --> 17:38.460
那么我们是不是要把abc的文件

17:38.460 --> 17:39.460
全部拷不了这

17:39.460 --> 17:40.460
对吧

17:40.460 --> 17:41.460
拷不了这

17:41.460 --> 17:42.460
没问题吧

17:42.460 --> 17:43.460
然后拷贝性难

17:43.460 --> 17:44.460
然后呢

17:44.460 --> 17:45.460
如果说这个拷贝的过程

17:45.460 --> 17:46.460
遇到这个问题

17:46.460 --> 17:47.460
是不是要改名称

17:47.460 --> 17:48.460
比方说

17:48.460 --> 17:50.460
因为别人写了个abc库

17:50.460 --> 17:52.460
是一个公司

17:52.460 --> 17:53.460
比方说公司A写的

17:53.460 --> 17:54.460
那么有可能公司B

17:54.460 --> 17:56.460
它也会出品一个库

17:56.460 --> 17:57.460
库的名字呢

17:57.460 --> 17:58.460
也叫做abc

17:58.460 --> 17:59.460
一杯这种可能

17:59.460 --> 18:00.460
当然有这种可能

18:00.460 --> 18:01.460
名字冲突了

18:01.460 --> 18:03.460
那这个目录结构

18:03.460 --> 18:04.460
是不是你得改一下名字

18:04.460 --> 18:06.460
我们可能要用一个abc1

18:06.460 --> 18:08.460
abc1

18:08.460 --> 18:09.460
然后用一个abc2

18:09.460 --> 18:10.460
对吧

18:10.460 --> 18:11.460
是不是要用这种模式来做

18:11.460 --> 18:13.460
把库文件拷进来

18:13.460 --> 18:14.460
然后呢

18:14.460 --> 18:15.460
我们在我们的代码里边

18:15.460 --> 18:16.460
我们的代码里边

18:16.460 --> 18:17.460
从库里边去导入

18:17.460 --> 18:19.460
比方说

18:19.460 --> 18:20.460
这是我们自己的

18:20.460 --> 18:22.460
我们自己的就是代码

18:22.460 --> 18:23.460
然后呢

18:23.460 --> 18:24.460
我们从require

18:24.460 --> 18:26.460
从neb里边

18:26.460 --> 18:27.460
然后呢abc1

18:27.460 --> 18:29.460
里边去导入相应的东西

18:29.460 --> 18:30.460
对吧

18:30.460 --> 18:32.460
是不是要这样去用

18:32.460 --> 18:33.460
看用的过程呢

18:33.460 --> 18:35.460
是非常非常繁硕的

18:35.460 --> 18:36.460
而且呢

18:36.460 --> 18:38.460
我们还要去看着它的

18:38.460 --> 18:39.460
官方稳当

18:39.460 --> 18:41.460
学习怎么去使用

18:41.460 --> 18:42.460
因此呢

18:42.460 --> 18:43.460
我会把它的就是

18:43.460 --> 18:44.460
官网呢

18:44.460 --> 18:45.460
或者是github主页呢

18:45.460 --> 18:47.460
把它收藏到文件夹里边

18:47.460 --> 18:48.460
不然的话

18:48.460 --> 18:49.460
每次都要去收一遍

18:49.460 --> 18:50.460
非常的麻烦

18:50.460 --> 18:51.460
像以前

18:51.460 --> 18:53.460
以前没有保管理器的时候呢

18:53.460 --> 18:55.460
这样很早的年代啊

18:55.460 --> 18:56.460
要使用一个第三方库的话

18:56.460 --> 18:57.460
基本上

18:57.460 --> 18:58.460
你要从一个

18:58.460 --> 18:59.460
网

18:59.460 --> 19:00.460
就是你的浏览器的

19:00.460 --> 19:01.460
收藏夹里边去找

19:01.460 --> 19:02.460
你会发现那个时候的

19:02.460 --> 19:03.460
前端开发者

19:03.460 --> 19:04.460
有一个有一个

19:04.460 --> 19:05.460
专门的文件夹

19:05.460 --> 19:06.460
那个文件夹里面

19:06.460 --> 19:07.460
全部是保存官网

19:08.460 --> 19:10.460
经常我们开发的过程中

19:10.460 --> 19:11.460
开发了半个小时

19:11.460 --> 19:12.460
一个小时过后呢

19:12.460 --> 19:13.460
下面电脑上的这个就是

19:13.460 --> 19:15.460
底部的就是那个

19:15.460 --> 19:16.460
状态栏

19:16.460 --> 19:17.460
基本上塞满了

19:17.460 --> 19:19.460
一个屏幕都放不下了

19:19.460 --> 19:20.460
全是官网

19:20.460 --> 19:21.460
全是官网地址

19:21.460 --> 19:23.460
而且浏览器的调

19:23.460 --> 19:24.460
上面的窗口

19:24.460 --> 19:25.460
有非常非常多

19:25.460 --> 19:26.460
全是官网地址

19:26.460 --> 19:27.460
因为我们要去看

19:27.460 --> 19:28.460
它的API稳当

19:28.460 --> 19:30.460
来学习怎么去使用

19:30.460 --> 19:31.460
对吧

19:31.460 --> 19:32.460
OK啊

19:32.460 --> 19:33.460
这是一个问题

19:33.460 --> 19:35.460
是下载的过程呢

19:35.460 --> 19:36.460
非常繁硕

19:37.460 --> 19:38.460
这个过程

19:38.460 --> 19:39.460
这个问题呢

19:39.460 --> 19:41.460
还比较的容易解决

19:41.460 --> 19:43.460
其实也不算容易解决吧

19:43.460 --> 19:44.460
我们比较能接受

19:44.460 --> 19:46.460
还不会造成太大的痛苦

19:46.460 --> 19:49.460
但是下边的问题就麻烦了

19:49.460 --> 19:51.460
如果说这个裤呢

19:51.460 --> 19:54.460
还需要依赖其他裤

19:54.460 --> 19:55.460
那么这个问题

19:55.460 --> 19:56.460
就有点麻烦了

19:56.460 --> 19:58.460
那么我们还要按照要求

19:58.460 --> 20:02.460
先下载其他裤

20:02.460 --> 20:04.460
这是什么意思呢

20:04.460 --> 20:05.460
就是说比方说

20:05.460 --> 20:07.460
我们下了这个ABC裤

20:07.460 --> 20:08.460
它有两个同名

20:08.460 --> 20:10.460
我们该取名为ABC1ABC2

20:10.460 --> 20:12.460
所以我们就用ABC吧

20:12.460 --> 20:14.460
就比方说有一个裤

20:14.460 --> 20:15.460
ABC

20:15.460 --> 20:16.460
那么这个裤呢

20:16.460 --> 20:18.460
它是基于其他裤

20:18.460 --> 20:19.460
编写而成的

20:19.460 --> 20:21.460
它不是单独存在的

20:21.460 --> 20:23.460
它是基于其他裤编写而成的

20:23.460 --> 20:24.460
那么这个时候呢

20:24.460 --> 20:25.460
比方说这个裤呢

20:25.460 --> 20:26.460
它要用到什么裤呢

20:26.460 --> 20:28.460
它要依赖

20:28.460 --> 20:31.460
这个裤它可能要依赖

20:31.460 --> 20:33.460
接query

20:33.460 --> 20:36.460
它可能要依赖接query的最新版

20:36.460 --> 20:38.460
最新版

20:38.460 --> 20:39.460
比方说

20:39.460 --> 20:41.460
这个裤要依赖接query的最新版

20:41.460 --> 20:42.460
那么也就是说

20:42.460 --> 20:43.460
我们呢

20:43.460 --> 20:45.460
它可能用两种做法

20:45.460 --> 20:46.460
第一种做法

20:46.460 --> 20:48.460
接query就直接包含在这个裤里面了

20:48.460 --> 20:50.460
那么这种做法有什么问题呢

20:50.460 --> 20:51.460
比方说

20:51.460 --> 20:52.460
这个裤里面

20:52.460 --> 20:54.460
它就已经直接包含了接query了

20:54.460 --> 20:55.460
比方它里面有自己的列部

20:55.460 --> 20:56.460
这个列部里面

20:56.460 --> 20:58.460
它有自己有自己的接query

20:58.460 --> 21:00.460
原来的意思吧

21:00.460 --> 21:01.460
就这个裤呢

21:01.460 --> 21:02.460
你下载下来之后呢

21:02.460 --> 21:04.460
它里面已经包含了接query了

21:04.460 --> 21:06.460
它已经在这里面自己使用了

21:06.460 --> 21:07.460
那么这样做有什么问题呢

21:07.460 --> 21:10.460
比方说你将来又下载了一个裤

21:10.460 --> 21:13.460
比方说下载一个BCD

21:13.460 --> 21:14.460
下载这么一个裤

21:14.460 --> 21:15.460
那么这么一个裤

21:15.460 --> 21:17.460
它如果说也依赖接query的话

21:17.460 --> 21:18.460
是不是有问题出现了

21:18.460 --> 21:20.460
那么这里是又有一个接query

21:20.460 --> 21:21.460
那我们的工程里面

21:21.460 --> 21:24.460
是不是多了大量的接query在里面

21:24.460 --> 21:25.460
有这个必要吗

21:25.460 --> 21:26.460
是不是多了大量的接query

21:26.460 --> 21:27.460
重复在里面

21:27.460 --> 21:29.460
比方它也一代的是最新版

21:29.460 --> 21:31.460
原来的意思吧

21:31.460 --> 21:33.460
所以说那有些裤呢

21:33.460 --> 21:34.460
有些第三方裤呢

21:34.460 --> 21:36.460
它虽然说它依赖某一个裤

21:36.460 --> 21:37.460
另外一个裤

21:37.460 --> 21:38.460
但是呢

21:38.460 --> 21:41.460
它不会把这个裤包含在它里面

21:41.460 --> 21:43.460
因此你要需要自行下载

21:43.460 --> 21:45.460
因此我们是不是还要再下载一个裤

21:45.460 --> 21:46.460
接query

21:46.460 --> 21:47.460
对吧

21:47.460 --> 21:49.460
接query

21:49.460 --> 21:51.460
那么我们现在接query放在哪呢

21:51.460 --> 21:53.460
放在哪是有要求的对不对

21:53.460 --> 21:54.460
一不能随便放

21:54.460 --> 21:56.460
因为它这个ABC这个裤呢

21:56.460 --> 21:58.460
关键是看它里面代码是怎么用的

21:58.460 --> 22:00.460
比方说它这个A.js里面用到了接query

22:00.460 --> 22:01.460
它怎么写的呢

22:01.460 --> 22:02.460
比方说

22:02.460 --> 22:03.460
举个例子

22:03.460 --> 22:05.460
当然我们现在是用common.js来写的

22:05.460 --> 22:07.460
先别管那个实现

22:07.460 --> 22:08.460
先别管它能不能运行起来

22:08.460 --> 22:09.460
这个无所谓

22:09.460 --> 22:10.460
我们说一个道理

22:10.460 --> 22:11.460
比方说A

22:11.460 --> 22:12.460
或者是

22:12.460 --> 22:13.460
第一个变量多了

22:13.460 --> 22:14.460
多了等于什么呢

22:14.460 --> 22:15.460
require

22:15.460 --> 22:16.460
它是这样写的

22:16.460 --> 22:17.460
看着啊

22:17.460 --> 22:18.460
它是这样写的

22:18.460 --> 22:20.460
返回上一集目录

22:20.460 --> 22:22.460
然后接query

22:22.460 --> 22:24.460
index.js

22:24.460 --> 22:26.460
比方说它这么写的

22:26.460 --> 22:28.460
那么它就要求的是什么呢

22:28.460 --> 22:30.460
要求里是不是有一个目录关系

22:30.460 --> 22:31.460
对吧

22:31.460 --> 22:32.460
因为它这是别人库里边谁在待

22:32.460 --> 22:34.460
它就要求你接query要放在哪

22:34.460 --> 22:35.460
是吧

22:35.460 --> 22:37.460
放在跟这个ABC是同名目录下面的

22:37.460 --> 22:38.460
同级目录下面的

22:38.460 --> 22:41.460
它又对这个方式的目录是有要求的

22:41.460 --> 22:42.460
你懂我这个意思吧

22:43.460 --> 22:45.460
什么拒绝房呢

22:49.460 --> 22:50.460
没错

22:50.460 --> 22:51.460
来 我们直接再来

22:51.460 --> 22:52.460
不要让我们这里

22:52.460 --> 22:53.460
要求放在这

22:53.460 --> 22:55.460
它接query放在这

22:55.460 --> 22:56.460
好 那么如果说有一天

22:56.460 --> 22:57.460
BCD这个库呢

22:57.460 --> 22:59.460
它又要求接query放在这

22:59.460 --> 23:01.460
你不是很麻烦

23:01.460 --> 23:03.460
到底放在哪呢

23:03.460 --> 23:04.460
而且呢

23:04.460 --> 23:05.460
还有一种情况就是

23:05.460 --> 23:06.460
ABC这个库呢

23:06.460 --> 23:07.460
它可能要求的是

23:07.460 --> 23:09.460
接query的最新版

23:09.460 --> 23:10.460
BCD这个库呢

23:10.460 --> 23:11.460
要求的它不是最新版

23:11.460 --> 23:13.460
比方说是1.0版本

23:13.460 --> 23:14.460
一用最新版

23:14.460 --> 23:15.460
它反而要爆出

23:15.460 --> 23:16.460
反而要出问题

23:16.460 --> 23:17.460
那又怎么办呢

23:17.460 --> 23:19.460
是不是再来一大堆问题

23:19.460 --> 23:20.460
这个问题是很难解决的

23:20.460 --> 23:22.460
是一个非常非常麻烦的问题

23:22.460 --> 23:23.460
原来的意思吗

23:23.460 --> 23:24.460
而且呢

23:24.460 --> 23:26.460
很多时候一些第三方库

23:26.460 --> 23:29.460
绝对不是这么简单的依赖

23:29.460 --> 23:31.460
一个库还一代接query

23:31.460 --> 23:32.460
这么简单就完了吗

23:32.460 --> 23:34.460
当有了模块化之后

23:34.460 --> 23:37.460
它功能分得非常非常的细

23:37.460 --> 23:38.460
你们之后呢

23:38.460 --> 23:39.460
会看到

23:39.460 --> 23:40.460
很多的第三方库

23:40.460 --> 23:42.460
它有几十个依赖

23:42.460 --> 23:45.460
或者说有十那个依赖

23:45.460 --> 23:46.460
那么十那个依赖

23:46.460 --> 23:48.460
那些依赖的库呢

23:48.460 --> 23:49.460
它自己有自己的依赖

23:49.460 --> 23:51.460
那么经常会形成这种关系

23:51.460 --> 23:52.460
A依赖什么呢

23:52.460 --> 23:57.460
B C D E F

23:57.460 --> 23:58.460
依赖这些库

23:58.460 --> 24:00.460
那么这个B这个库呢

24:00.460 --> 24:01.460
有依赖什么呢

24:01.460 --> 24:02.460
B这个库有依赖

24:02.460 --> 24:04.460
有依赖

24:04.460 --> 24:07.460
1 2 3 4这个库

24:07.460 --> 24:09.460
经常会出现这种复杂的关系

24:09.460 --> 24:11.460
就是一大堆的就是循环依赖

24:11.460 --> 24:13.460
就是那种就是劣势的依赖

24:13.460 --> 24:14.460
它依赖它

24:14.460 --> 24:15.460
它有依赖它

24:15.460 --> 24:16.460
它有点压它

24:16.460 --> 24:18.460
那么面对这么复杂的依赖关系

24:18.460 --> 24:20.460
它靠自己手动去瞎斩

24:20.460 --> 24:21.460
你还吃得消吗

24:21.460 --> 24:23.460
因为有了模块化之后

24:23.460 --> 24:25.460
功能分得非常非常的细

24:25.460 --> 24:26.460
就不像以前一大堆功能

24:26.460 --> 24:28.460
放到一个库里面就完事了

24:28.460 --> 24:30.460
每个库它只解决一部分的问题

24:30.460 --> 24:31.460
你们以后会经常看到

24:31.460 --> 24:34.460
它非常分得非常非常的细

24:34.460 --> 24:36.460
因此我们库的依赖关系

24:36.460 --> 24:38.460
就会变得非常非常复杂

24:38.460 --> 24:40.460
而且我现在这里还只是

24:40.460 --> 24:41.460
假设的依赖追行版

24:41.460 --> 24:43.460
那如果说依赖的不是追行版的

24:43.460 --> 24:45.460
A依赖B这个库的1.0版本

24:45.460 --> 24:47.460
但是B的追行版的是2.0

24:47.460 --> 24:49.460
C要依赖B的

24:49.460 --> 24:51.460
C要依赖B的就是2.0

24:51.460 --> 24:53.460
这怎么办了这些东西

24:53.460 --> 24:55.460
那是不是非常复杂了现在

24:55.460 --> 24:57.460
那么面对这么复杂的依赖关系

24:57.460 --> 25:00.460
你手动处理还可行吗

25:00.460 --> 25:02.460
所以一定不可行吧

25:02.460 --> 25:04.460
我们需要有专门的工具

25:04.460 --> 25:06.460
专门的非常智能的工具

25:06.460 --> 25:07.460
方便使用的工具

25:07.460 --> 25:08.460
来帮我们处理这些

25:08.460 --> 25:10.460
繁殊的问题

25:10.460 --> 25:12.460
然后我们来看

25:12.460 --> 25:13.460
下一个问题

25:13.460 --> 25:16.900
我们在开发环境中

25:16.900 --> 25:18.900
安装了大量的库

25:18.900 --> 25:20.900
如何在生产环境中还原

25:20.900 --> 25:22.900
又如何区分

25:22.900 --> 25:24.900
什么意思呢

25:24.900 --> 25:26.900
首先你要理解

25:26.900 --> 25:28.900
什么叫开发环境

25:28.900 --> 25:30.900
什么叫开发环境呢

25:30.900 --> 25:32.900
我们现在说的是LoadJS

25:32.900 --> 25:34.900
说的是LoadJS

25:34.900 --> 25:35.900
什么叫开发环境呢

25:35.900 --> 25:36.900
就是你现在自己的电脑

25:36.900 --> 25:37.900
你现在的听客

25:37.900 --> 25:38.900
应该在电脑上听

25:38.900 --> 25:40.900
就是你现在目前的电脑

25:40.900 --> 25:42.900
你在电脑上在写单

25:42.900 --> 25:43.900
你现在目前的电脑上

25:43.900 --> 25:44.900
组成的环境

25:44.900 --> 25:45.900
就是开发环境

25:45.900 --> 25:47.900
你再开发嘛

25:47.900 --> 25:50.900
那么什么叫做生产环境呢

25:50.900 --> 25:51.900
生产环境是什么意思呢

25:51.900 --> 25:53.900
就是你单码全部写好了

25:53.900 --> 25:54.900
写好了测试了

25:54.900 --> 25:55.900
没有什么问题了

25:55.900 --> 25:57.900
经过一系列公司里面的

25:57.900 --> 25:58.900
一些流程

25:58.900 --> 26:00.900
确定没有问题了

26:00.900 --> 26:02.900
那么是不是要把你的单码

26:02.900 --> 26:05.900
传到服务器上面

26:05.900 --> 26:06.900
传到真实的

26:06.900 --> 26:08.900
公司购买的服务器上面

26:08.900 --> 26:10.900
一般是阿里云亚云服务器

26:10.900 --> 26:12.900
或者是公司自己买的物理服务器

26:12.900 --> 26:13.900
无所谓

26:13.900 --> 26:15.900
总之要传到服务器上面

26:15.900 --> 26:16.900
要在服务器上面运行

26:16.900 --> 26:18.900
总不能永远在你电脑上运行

26:18.900 --> 26:19.900
在你电脑上运行

26:19.900 --> 26:20.900
别人也没法用了

26:20.900 --> 26:22.900
那么在服务器环境运行

26:22.900 --> 26:24.900
就是真正的去投入使用了

26:24.900 --> 26:26.900
那么服务器的环境

26:26.900 --> 26:28.900
是生产环境

26:28.900 --> 26:30.900
因此我们在开发的过程中

26:30.900 --> 26:32.900
其实有这么一个

26:32.900 --> 26:33.900
我换一张简图

26:33.900 --> 26:37.590
一张简单的图

26:37.590 --> 26:41.590
那么我们自己的电脑

26:41.590 --> 26:44.590
这是开发环境

26:44.590 --> 26:46.590
这是我们自己的电脑

26:46.590 --> 26:48.590
然后服务器那边

26:48.590 --> 26:50.590
有一个服务器环境

26:50.590 --> 26:52.590
服务器环境

26:52.590 --> 26:54.590
我们可以让他问

26:54.590 --> 26:56.590
他是生产环境

26:56.590 --> 26:58.590
我们开发完了之后

26:58.590 --> 27:00.590
会把我们的代码

27:00.590 --> 27:02.590
会把我们的代码

27:02.590 --> 27:06.290
是不是要上传过去

27:06.290 --> 27:09.290
我们的代码

27:09.290 --> 27:14.420
原码

27:14.420 --> 27:16.420
是不是要上传到服务器

27:16.420 --> 27:17.420
那么这个上传过程

27:17.420 --> 27:19.420
会有什么样的问题呢

27:20.420 --> 27:21.420
看这儿

27:22.420 --> 27:24.420
由于我们在我们的开发环境

27:24.420 --> 27:25.420
因为我们要做开发

27:25.420 --> 27:27.420
肯定要安装很多的第三方库

27:27.420 --> 27:29.420
包括我们的漏的解释

27:29.420 --> 27:30.420
你们以后要学习漏的解释

27:30.420 --> 27:31.420
做很多的开发

27:31.420 --> 27:33.420
要安装一大堆的库在里面

27:33.420 --> 27:34.420
要安装多少呢

27:34.420 --> 27:36.420
到底要安装多少呢

27:36.420 --> 27:39.420
可能我们只是安装了十那个库

27:39.420 --> 27:41.420
比方说

27:41.420 --> 27:46.050
我们安装了十个库

27:46.050 --> 27:47.050
本来只是安装了十个库

27:47.050 --> 27:49.050
但是不得了了

27:49.050 --> 27:50.050
十个库呢

27:50.050 --> 27:51.050
每个库呢

27:51.050 --> 27:52.050
它有依赖

27:52.050 --> 27:53.050
它每个库有依赖

27:53.050 --> 27:54.050
你是不是得把一代安装了

27:54.050 --> 27:55.050
比方说第1个库

27:55.050 --> 27:56.050
它一代A

27:56.050 --> 27:57.050
第2个库一代BCD

27:57.050 --> 27:59.050
第3个库一代EFG

27:59.050 --> 28:02.050
第4个库一代EZX

28:02.050 --> 28:04.050
那么你是不是得把

28:04.050 --> 28:05.050
一代的库安装了

28:05.050 --> 28:06.050
不然它怎么用呢

28:06.050 --> 28:07.050
对不对

28:07.050 --> 28:08.050
你得把一代安装了

28:08.050 --> 28:09.050
那么一代的库

28:09.050 --> 28:10.050
又一代别的库

28:10.050 --> 28:11.050
所以说呢

28:11.050 --> 28:12.050
虽然我们只安装了十个库

28:12.050 --> 28:13.050
只下载了十个库

28:13.050 --> 28:14.050
到最后呢

28:14.050 --> 28:15.050
可能我们

28:15.050 --> 28:16.050
导致的结果是

28:16.050 --> 28:18.050
最终下载了多少个库

28:18.050 --> 28:19.050
就是下载了500个库

28:19.050 --> 28:20.050
完全有可能

28:20.050 --> 28:21.050
你们不信看吧

28:21.050 --> 28:22.050
你们后边学习什么

28:22.050 --> 28:23.050
5U啊reacts

28:23.050 --> 28:24.050
你看那个库有多少

28:24.050 --> 28:25.050
吓死你

28:26.050 --> 28:27.050
那么涉及到的文件有多少呢

28:27.050 --> 28:28.050
涉及到的文件

28:29.050 --> 28:31.050
涉及上千个文件

28:32.050 --> 28:33.050
可能还不止

28:33.050 --> 28:34.050
可能还不止

28:34.050 --> 28:35.050
一般像你们

28:35.050 --> 28:36.050
后面做了什么

28:36.050 --> 28:38.050
5U啊5U全家统的一套

28:38.050 --> 28:39.050
安装下来

28:39.050 --> 28:40.050
基本上就几千个文件了

28:40.050 --> 28:41.050
差不多了

28:42.050 --> 28:43.050
涉及到文件非常多

28:43.050 --> 28:44.050
每个文件就是个模块

28:44.050 --> 28:45.050
模块组成库

28:45.050 --> 28:46.050
库一库之间

28:46.050 --> 28:47.050
形成一代关系

28:47.050 --> 28:48.050
对吧

28:49.050 --> 28:50.050
那么涉及到这么多文件

28:50.050 --> 28:51.050
我们都知道

28:52.050 --> 28:53.050
文件一多了

28:53.050 --> 28:55.050
哪怕你占用的空间补大

28:55.050 --> 28:56.050
所以每个文件的

28:56.050 --> 28:57.050
占用空间倒是

28:57.050 --> 28:58.050
没有那么的大

28:58.050 --> 28:59.050
但是其实下来也不少了

28:59.050 --> 29:00.050
这些库夹起来

29:00.050 --> 29:03.050
可能有个几十兆上百兆了

29:04.050 --> 29:05.050
像这么多文件

29:05.050 --> 29:07.050
你要上传到服务器的过程

29:07.050 --> 29:08.050
是非常非常缓慢的

29:09.050 --> 29:10.050
文件一多了

29:10.050 --> 29:11.050
你知道他每个文件

29:11.050 --> 29:12.050
要在服务器建立锁印

29:12.050 --> 29:13.050
在操作系统里面建立锁印

29:13.050 --> 29:14.050
文件一多

29:15.050 --> 29:16.050
上传就满了

29:16.050 --> 29:18.050
其实你们也应该

29:18.050 --> 29:19.050
用这么久的电脑了

29:19.050 --> 29:20.050
应该有个感觉

29:21.050 --> 29:22.050
比方说

29:22.050 --> 29:27.000
删除一个实际的文件

29:28.000 --> 29:31.000
和删除一万个

29:32.000 --> 29:33.000
1kb的文件

29:33.000 --> 29:34.000
哪个速度快

29:36.000 --> 29:37.000
哪个速度快

29:37.000 --> 29:38.000
哪个三的快

29:38.000 --> 29:39.000
是不是一定是

29:39.000 --> 29:41.000
第一个三的快

29:41.000 --> 29:42.000
你别看他有实际

29:42.000 --> 29:44.000
你瞬间就杀没了

29:44.000 --> 29:45.000
瞬间

29:45.000 --> 29:46.000
不到一秒钟就没了

29:46.000 --> 29:47.000
为什么呢

29:47.000 --> 29:48.000
因为他那些

29:48.000 --> 29:50.000
石盘里面的数据还在

29:50.000 --> 29:52.000
他根本不会在石盘上

29:52.000 --> 29:53.000
把实际的数据

29:53.000 --> 29:55.000
挨在这干抹掉了

29:55.000 --> 29:56.000
他不会这样做的

29:56.000 --> 29:57.000
没有那个操作系统

29:57.000 --> 29:58.000
这么干的

29:58.000 --> 30:00.000
他只是在文件列表里面

30:00.000 --> 30:01.000
把那个目录给他删了

30:01.000 --> 30:03.000
是不是只删一个目录就对了

30:03.000 --> 30:04.000
就删一个目录就对了

30:04.000 --> 30:05.000
对吧

30:05.000 --> 30:06.000
我表示一下

30:06.000 --> 30:07.000
这块区域没人用了

30:07.000 --> 30:08.000
这一块内存

30:08.000 --> 30:09.000
硬盘区域没人用了

30:09.000 --> 30:11.000
所以说我一下就删完了

30:11.000 --> 30:12.000
他只是删了个目录

30:12.000 --> 30:13.000
原来的意思吗

30:13.000 --> 30:15.000
就好必说你在菜单里面

30:15.000 --> 30:16.000
菜单里面

30:16.000 --> 30:18.000
看不到那个菜了

30:18.000 --> 30:20.000
那个菜从菜单里面删了

30:20.000 --> 30:21.000
给你杠了

30:21.000 --> 30:22.000
就这么个意思

30:22.000 --> 30:23.000
那么那个菜石

30:23.000 --> 30:24.000
实际上在不在了

30:24.000 --> 30:25.000
他在这个硬盘里面

30:25.000 --> 30:26.000
在这个硬盘里面

30:26.000 --> 30:27.000
只剥了

30:27.000 --> 30:28.000
你看不到了

30:28.000 --> 30:29.000
也找不到了

30:29.000 --> 30:30.000
他是这样子删的

30:30.000 --> 30:31.000
因此

30:31.000 --> 30:32.000
删一个实际的文件

30:32.000 --> 30:33.000
是非常非常快的

30:33.000 --> 30:34.000
但是你要删一个

30:34.000 --> 30:35.000
一万个的1KB文件

30:35.000 --> 30:36.000
是不是非常慢

30:36.000 --> 30:37.000
对吧

30:37.000 --> 30:38.000
是不是非常慢

30:38.000 --> 30:39.000
为什么慢呢

30:39.000 --> 30:40.000
因为他要一个目录

30:40.000 --> 30:41.000
一个目录

30:41.000 --> 30:42.000
删一万次

30:42.000 --> 30:43.000
虽然每个文件很少

30:43.000 --> 30:44.000
跟每个文件的

30:45.000 --> 30:46.000
所以就这么个道理

30:46.000 --> 30:48.000
你要上传文件一读

30:48.000 --> 30:50.000
那么他就会重新去建立

30:50.000 --> 30:51.000
这个目录在服务器

30:52.000 --> 30:53.000
而且本地

30:53.000 --> 30:54.000
上传的过程中

30:54.000 --> 30:56.000
也要从磁盘一个

30:56.000 --> 30:57.000
一个去读这个目录

30:57.000 --> 30:59.000
速度会非常非常慢

30:59.000 --> 31:02.000
而且经常会丢包

31:02.000 --> 31:03.000
丢包如果一个文件

31:03.000 --> 31:04.000
损坏了

31:04.000 --> 31:05.000
那么又导致

31:05.000 --> 31:06.000
又要出问题

31:07.000 --> 31:08.000
你看一下

31:08.000 --> 31:09.000
其实我们以后

31:09.000 --> 31:10.000
开发的工程里面

31:10.000 --> 31:11.000
经常会遇到这种情况

31:11.000 --> 31:13.000
就是我们的一代的酷

31:13.000 --> 31:15.000
以及酷一代的酷

31:15.000 --> 31:17.000
涉及到上千个文件

31:17.000 --> 31:18.000
但是我们自己的文件

31:18.000 --> 31:20.000
自己写代码开发的文件

31:20.000 --> 31:22.000
自己的模块文件

31:22.000 --> 31:23.000
一共有多少个呢

31:23.000 --> 31:25.000
可能就几十个

31:27.000 --> 31:28.000
因此我们上传

31:28.000 --> 31:29.000
自己的模块文件

31:29.000 --> 31:30.000
也是非常快的

31:30.000 --> 31:31.000
东西不多

31:31.000 --> 31:32.000
但是一旦上传依赖

31:32.000 --> 31:33.000
是不是就很多

31:34.000 --> 31:35.000
因此

31:35.000 --> 31:36.000
这就是我们这个问题

31:36.000 --> 31:37.000
这个问题

31:37.000 --> 31:38.000
什么意思

31:38.000 --> 31:39.000
我给大家解释清楚

31:39.000 --> 31:41.000
我们开发环境里面

31:41.000 --> 31:42.000
有大量的酷

31:42.000 --> 31:43.000
那么生产环境

31:43.000 --> 31:44.000
怎么办

31:44.000 --> 31:45.000
我肯定不能用这种方式

31:45.000 --> 31:46.000
把自己的开发环境里面的东西

31:46.000 --> 31:48.000
全部上传到生产环境

31:48.000 --> 31:49.000
那肯定不行

31:49.000 --> 31:50.000
那怎么办

31:50.000 --> 31:51.000
那生产环境里面

31:51.000 --> 31:52.000
怎么来使用那些遗难

31:52.000 --> 31:53.000
怎么来还原

31:53.000 --> 31:54.000
这又是个大问题的

31:56.000 --> 31:57.000
那么什么叫做

31:57.000 --> 31:58.000
如何区分呢

31:58.000 --> 31:59.000
我给大家举个例子

32:00.000 --> 32:01.000
我们在开发阶段

32:01.000 --> 32:03.000
可能会用到一些

32:03.000 --> 32:04.000
只有在开发阶段

32:04.000 --> 32:05.000
会用到的酷

32:05.000 --> 32:06.000
比方说里面

32:06.000 --> 32:07.000
后面会学习这么个酷

32:08.000 --> 32:09.000
叫做摸墙

32:10.000 --> 32:11.000
这是做什么

32:11.000 --> 32:12.000
测试用

32:13.000 --> 32:14.000
测试用

32:15.000 --> 32:16.000
那你想

32:17.000 --> 32:18.000
你都上了服务器

32:18.000 --> 32:19.000
哪里还需要测试吗

32:20.000 --> 32:21.000
不需要了吧

32:21.000 --> 32:22.000
你只有在本地的时候

32:22.000 --> 32:24.000
开发的阶段才会测试

32:24.000 --> 32:25.000
对吧

32:25.000 --> 32:26.000
你在服务器

32:26.000 --> 32:27.000
还用这个玩意干嘛

32:27.000 --> 32:28.000
是没用了

32:28.000 --> 32:30.000
那么类似于这种酷

32:30.000 --> 32:31.000
那这种酷

32:31.000 --> 32:33.000
它只在开发阶段

32:33.000 --> 32:34.000
我们才用一下

32:34.000 --> 32:36.000
但服务器就不需要用了

32:36.000 --> 32:37.000
那么像这种酷

32:37.000 --> 32:38.000
还有不少

32:38.000 --> 32:39.000
还有不少

32:39.000 --> 32:40.000
我们后面会遇到

32:40.000 --> 32:41.000
还有不少这种酷

32:41.000 --> 32:42.000
只是在开发阶段

32:42.000 --> 32:44.000
开发阶段有什么作用

32:44.000 --> 32:46.000
以后在服务器的端就不需要了

32:46.000 --> 32:47.000
那么这种酷

32:47.000 --> 32:49.000
又如何跟

32:49.000 --> 32:51.000
在不同的环境里面区分呢

32:51.000 --> 32:52.000
我开发阶段

32:52.000 --> 32:53.000
我怎么样子

32:53.000 --> 32:55.000
知道这个酷子在开发阶段里面使用

32:55.000 --> 32:56.000
服务器不需要安装

32:56.000 --> 32:57.000
又怎么知道呢

32:57.000 --> 33:00.000
这句话有两个问题

33:00.000 --> 33:01.000
第一个问题就是

33:01.000 --> 33:02.000
我开发环境的酷

33:02.000 --> 33:04.000
怎么去在生产环境中重新还原

33:04.000 --> 33:06.000
我肯定不能用这种方式

33:06.000 --> 33:07.000
挨带带上传

33:07.000 --> 33:08.000
这个太恐怖了

33:09.000 --> 33:11.000
还原的时候又如何来区分

33:11.000 --> 33:13.000
哪些是生产环境不需要的酷

33:13.000 --> 33:15.000
我就不要了

33:15.000 --> 33:16.000
对不对

33:17.000 --> 33:19.000
然后再想一个问题

33:19.000 --> 33:21.000
我这个问题都不解释了

33:21.000 --> 33:22.000
如果说你一个酷

33:22.000 --> 33:24.000
突然有些更新了

33:24.000 --> 33:26.000
你想想这个事情

33:26.000 --> 33:27.000
会遇到多好的事情

33:27.000 --> 33:29.000
会遇到多好的麻烦

33:29.000 --> 33:31.000
你再重新下一遍吧

33:31.000 --> 33:32.000
重新下一遍还不说

33:32.000 --> 33:33.000
他一旦的东西

33:33.000 --> 33:34.000
你再重新下一遍吧

33:34.000 --> 33:36.000
这个事情就很麻烦了

33:36.000 --> 33:37.000
就非常恐怖了

33:37.000 --> 33:39.000
然后最后一个问题就是

33:39.000 --> 33:41.000
如果有一天我自己想开发一个酷

33:41.000 --> 33:43.000
那么我开发一个酷

33:43.000 --> 33:45.000
作用时开发了一个通用酷

33:45.000 --> 33:47.000
比方说开发了一个工具酷

33:47.000 --> 33:48.000
提供了一些工具函数

33:48.000 --> 33:50.000
那么这个酷如何再下一次使用呢

33:50.000 --> 33:52.000
下一次开发使用呢

33:52.000 --> 33:53.000
当然说

33:53.000 --> 33:55.000
我把它保存到油盘里边

33:55.000 --> 33:57.000
下一次来拷贝

33:57.000 --> 34:00.000
这种是一种非常low的方式

34:00.000 --> 34:01.000
这种方式

34:01.000 --> 34:02.000
一是它不能管

34:02.000 --> 34:04.000
它很难管理多个版本

34:04.000 --> 34:06.000
如果说有多个版本怎么办

34:06.000 --> 34:08.000
有些东西用铁子

34:08.000 --> 34:10.000
那么如何把它分享出去呢

34:10.000 --> 34:12.000
分享让别人也看到了

34:12.000 --> 34:14.000
那么分享让别人可以

34:14.000 --> 34:16.000
非常方便的下载各种版本

34:16.000 --> 34:19.000
像这些问题都是一些问题

34:19.000 --> 34:21.000
那么面对这些问题呢

34:21.000 --> 34:24.000
你会发现要用人工的方式

34:24.000 --> 34:26.000
就已经很难了

34:26.000 --> 34:28.000
哪怕如果真的要用人工的方式的话

34:28.000 --> 34:30.000
可能要组建一个团队

34:30.000 --> 34:31.000
这个团队什么事也别管

34:31.000 --> 34:33.000
就在管理酷的

34:33.000 --> 34:35.000
浪费了大量的人力物力

34:35.000 --> 34:36.000
核心还管理不好

34:36.000 --> 34:39.000
所以说我们需要一些自动化的工具

34:39.000 --> 34:41.000
这个工具呢就是包管理工具

34:41.000 --> 34:44.000
包管理工具就是要解决上面的问题

34:44.000 --> 34:45.000
明白了吧

34:45.000 --> 34:47.000
所以说我们这门客

34:47.000 --> 34:48.000
到底在学习啥呀

34:48.000 --> 34:50.000
就是学习工具怎么使用

34:50.000 --> 34:51.000
工具解决什么问题

34:51.000 --> 34:53.000
就怎么去下载一个库

34:53.000 --> 34:55.000
怎么去上船一个库

34:55.000 --> 34:57.000
怎么去更新一个库

34:57.000 --> 35:00.000
怎么来开发环境和浪费环境还原

35:00.000 --> 35:01.000
以前呢

35:01.000 --> 35:03.000
它怎么来管理一带的

35:03.000 --> 35:06.000
这些就是包管理工具要做的事情

35:06.000 --> 35:07.000
那么我们接下来看一下

35:07.000 --> 35:09.000
前端的包管理工具

35:09.000 --> 35:11.000
那么既然说到前端的包管理工具

35:11.000 --> 35:12.000
其实你没有

35:12.000 --> 35:13.000
你看这个词

35:13.000 --> 35:15.000
也知道每个语言

35:15.000 --> 35:16.000
每门技术

35:16.000 --> 35:19.000
他们都有自己的包管理工具都有

35:19.000 --> 35:21.000
不同的技术有自己的

35:21.000 --> 35:22.000
但是前端一直没有

35:22.000 --> 35:23.000
为什么呢

35:23.000 --> 35:25.000
因为前端一直没有形成模块化

35:25.000 --> 35:27.000
那当它形成模块化了之后

35:27.000 --> 35:30.000
那么包管理器是自然而然必须要产生的

35:30.000 --> 35:32.000
因为它一定会形成包

35:32.000 --> 35:34.000
一定会形成第三方库

35:34.000 --> 35:35.000
那么我们这门客

35:35.000 --> 35:37.000
讲解的包管理器有哪些呢

35:37.000 --> 35:38.000
第一个

35:38.000 --> 35:40.000
最重要的NPM

35:40.000 --> 35:41.000
是最重要的

35:41.000 --> 35:42.000
我们首先讲讲这个

35:42.000 --> 35:44.000
然后这个讲完了之后

35:44.000 --> 35:45.000
我们再讲讲压

35:45.000 --> 35:47.000
这也是一个包管理器

35:47.000 --> 35:50.000
不过它也是基于NPM的

35:50.000 --> 35:51.000
我们来了解一下压

35:51.000 --> 35:52.000
这个东西也很好用

35:52.000 --> 35:53.000
但是潜力条件

35:53.000 --> 35:56.000
你必须要先学动NPM

35:56.000 --> 35:57.000
然后还有一些其他的包管理器

35:57.000 --> 35:59.000
我们到时候了解一下吧

35:59.000 --> 36:01.000
重点是NPM

36:01.000 --> 36:02.000
因为它几乎可以这样认为

36:02.000 --> 36:04.000
前端的所有的包管理器

36:04.000 --> 36:06.000
都是基于NPM的

36:06.000 --> 36:10.000
所以说NPM它既是一个包管理器

36:10.000 --> 36:12.000
也是其他的包管理器的基石

36:12.000 --> 36:13.000
因为其他的包管理器要实现

36:13.000 --> 36:15.000
它也离不开NPM

36:15.000 --> 36:19.000
尽管现在压好像有这个趋势

36:19.000 --> 36:21.000
要替代NPM的

36:21.000 --> 36:23.000
但是目前还没有

36:23.000 --> 36:24.000
目前还替代不了

36:24.000 --> 36:25.000
因为它内部的实现

36:25.000 --> 36:29.000
也是依托于NPM的

36:29.000 --> 36:31.000
就是数据仓库的

36:31.000 --> 36:34.000
我们到时候会说

36:34.000 --> 36:36.000
NPM到底是啥呢

36:36.000 --> 36:37.000
它的全程叫做load

36:37.000 --> 36:39.000
我们之前学的load

36:39.000 --> 36:41.000
load package

36:41.000 --> 36:43.000
包manager

36:43.000 --> 36:45.000
load包管理器

36:45.000 --> 36:47.000
但是现在NPM已经成为了

36:47.000 --> 36:49.000
一家独立的公司了

36:49.000 --> 36:51.000
而且它的预想是

36:51.000 --> 36:53.000
不光是要管理load的环境

36:53.000 --> 36:55.000
而且还有其他环境

36:55.000 --> 36:57.000
我们现在不管

36:57.000 --> 36:58.000
目前呢

36:58.000 --> 36:59.000
就目前而言

36:59.000 --> 37:01.000
它肯定是依托于load

37:01.000 --> 37:04.000
因此它由于运行在load环境中

37:04.000 --> 37:05.000
所以说我们这门客

37:05.000 --> 37:07.000
为什么全是在load环境里边

37:07.000 --> 37:08.000
因为我们要学习NPM

37:08.000 --> 37:11.000
它是在load环境里边运行的

37:11.000 --> 37:13.000
它可以让开发者在load环境中

37:13.000 --> 37:15.000
用非常非常简单的方式

37:15.000 --> 37:17.000
完成包的查找

37:17.000 --> 37:18.000
查找一个包

37:18.000 --> 37:19.000
安装一个包

37:19.000 --> 37:20.000
更新一个包

37:20.000 --> 37:21.000
卸载一个包

37:21.000 --> 37:22.000
上传这些操作

37:22.000 --> 37:25.000
可以用非常非常简单的方式来实现

37:25.000 --> 37:26.000
那么下面一段话

37:26.000 --> 37:28.000
它介绍了它为什么要运行load环境

37:28.000 --> 37:29.000
而不是流烂器环境的

37:29.000 --> 37:31.000
它是一个非常简单的道理

37:31.000 --> 37:34.000
就是流烂器环境

37:34.000 --> 37:36.000
它根本就没法提供下载

37:36.000 --> 37:38.000
删除独去本地文件的功能

37:38.000 --> 37:39.000
啥意思

37:39.000 --> 37:40.000
来吧

37:40.000 --> 37:41.000
我给你打开一个流烂器

37:41.000 --> 37:42.000
来吧

37:42.000 --> 37:44.000
你来这里给我写介事带

37:44.000 --> 37:46.000
你从网上给我下载一个文件

37:46.000 --> 37:47.000
下载

37:47.000 --> 37:48.000
把它保存到桌面

37:48.000 --> 37:49.000
来吧

37:49.000 --> 37:50.000
下载个文件

37:50.000 --> 37:51.000
你做得到吗

37:51.000 --> 37:53.000
你之前学的GS里边有这个功能吗

37:53.000 --> 37:54.000
你只有阿加克斯对吧

37:54.000 --> 37:55.000
你就访问一个网络地址

37:55.000 --> 37:56.000
你得到这个文件内容

37:56.000 --> 37:58.000
你怎么把它保存到本地呢

37:58.000 --> 38:00.000
你怎么来操作本地呢

38:00.000 --> 38:03.000
因为GS它是不允许你操作本地文件的

38:03.000 --> 38:05.000
这本地什么在C盘里边

38:05.000 --> 38:06.000
你给我建一个新建个文件

38:06.000 --> 38:08.000
你介事能做到吗

38:08.000 --> 38:10.000
在流烂器环境里面是肯定做不到的

38:10.000 --> 38:11.000
肯定做不到的

38:11.000 --> 38:12.000
为什么

38:12.000 --> 38:13.000
你用流烂器环境

38:13.000 --> 38:14.000
要保护用户的隐私

38:14.000 --> 38:15.000
对吧

38:15.000 --> 38:16.000
不然的话你在你的网站里面

38:16.000 --> 38:17.000
写断GS

38:17.000 --> 38:19.000
把别人用户的文件

38:19.000 --> 38:21.000
结构全部读出来了

38:21.000 --> 38:22.000
那怎么得了

38:22.000 --> 38:24.000
所以说不允许你操作本地文件

38:25.000 --> 38:27.000
但是在漏的环境不一样了

38:27.000 --> 38:29.000
漏的环境属于服务器环境

38:29.000 --> 38:31.000
它没有这种流烂器的种种限制

38:31.000 --> 38:32.000
因此

38:32.000 --> 38:35.000
GS可以完整的发挥它语言的功效

38:35.000 --> 38:37.000
它可以完整的掌控计算机

38:37.000 --> 38:38.000
比方说我这台计算机

38:38.000 --> 38:40.000
运行一个漏的程序

38:40.000 --> 38:42.000
那么那个漏的程序可以做很多

38:42.000 --> 38:44.000
像什么加把语言啊

38:44.000 --> 38:45.000
C下不语言啊

38:45.000 --> 38:46.000
C下加语言

38:46.000 --> 38:48.000
很多在一个本地做的事情

38:48.000 --> 38:49.000
漏的都能做

38:50.000 --> 38:53.000
理论上是可以完整的掌控

38:54.000 --> 38:55.000
因此

38:56.000 --> 38:58.000
保管力器肯定要操作文件

38:58.000 --> 38:59.000
它要下载文件

38:59.000 --> 39:00.000
保存到本地

39:00.000 --> 39:02.000
然后卸达的时候可能要删除文件

39:02.000 --> 39:04.000
那么这些操作都涉及到文件功能

39:04.000 --> 39:05.000
因此

39:05.000 --> 39:07.000
它不能在流烂器环境里面执行

39:07.000 --> 39:09.000
它就用的是漏的环境

39:09.000 --> 39:10.000
没了意思吗

39:19.720 --> 39:20.720
NPM的出现

39:20.720 --> 39:21.720
它弥补了

39:21.720 --> 39:23.720
漏的没有保管力器的缺陷

39:23.720 --> 39:25.720
因为它漏的还有了模块化

39:25.720 --> 39:27.720
保管力器是必须要使用

39:27.720 --> 39:28.720
必须要有的

39:28.720 --> 39:31.720
那么NPM的出现刚好就弥补了这个缺陷了

39:31.720 --> 39:32.720
于是呢

39:32.720 --> 39:33.720
漏的出现了不久

39:33.720 --> 39:35.720
马上在它的安装文件中

39:35.720 --> 39:37.720
就开始内置了NPM

39:37.720 --> 39:39.720
就是我们之前不是安装了漏的吗

39:39.720 --> 39:41.720
安装漏的时候

39:41.720 --> 39:42.720
其实细心的同学就会发现了

39:42.720 --> 39:43.720
其中有个选项

39:43.720 --> 39:45.720
它默认是勾选的

39:45.720 --> 39:47.720
是不是安装NPM

39:47.720 --> 39:49.720
它默认就给你安装了NPM

39:49.720 --> 39:52.720
因此你不用去自单独去安装了

39:52.720 --> 39:55.720
你已经有了

39:56.720 --> 39:57.720
而且漏的环境

39:57.720 --> 40:00.720
还专门为NPM提供了良好的支持

40:00.720 --> 40:01.720
我们后面会说

40:01.720 --> 40:02.720
漏的带码

40:02.720 --> 40:03.720
模块化的带码里边

40:03.720 --> 40:05.720
特别common.js的模块化带码里边

40:05.720 --> 40:06.720
你会看到

40:06.720 --> 40:08.720
它专门为NPM提供了良好的支持

40:08.720 --> 40:10.720
所以说你使用NPM下载包

40:10.720 --> 40:11.720
就非常非常方便了

40:11.720 --> 40:13.720
而且下载和使用非常方便

40:13.720 --> 40:15.720
咱们来看一下NPM的组成

40:15.720 --> 40:16.720
如果你面试的时候

40:16.720 --> 40:17.720
要考虑的话

40:17.720 --> 40:19.720
我可能就考虑一下

40:19.720 --> 40:20.720
考虑一下这个概念

40:20.720 --> 40:22.720
这个概念挺简单的

40:22.720 --> 40:25.720
第一个组成叫registry

40:25.720 --> 40:26.720
叫做入口

40:26.720 --> 40:27.720
其实你这个什么意思呢

40:27.720 --> 40:30.720
你可以把它想象成一个庞大的数据库

40:30.720 --> 40:33.720
就放在服务器的一个庞大的数据库

40:33.720 --> 40:34.720
谁的服务器呢

40:34.720 --> 40:36.720
就是NPM的官方服务器

40:36.720 --> 40:38.720
他可以建立一个服务器

40:38.720 --> 40:40.720
那个服务器有个庞大的数据库

40:40.720 --> 40:42.720
这个数据库在做什么呢

40:42.720 --> 40:44.720
来保存各种第三方库

40:44.720 --> 40:46.720
第三方的包

40:46.720 --> 40:48.720
那么这些第三方的包

40:48.720 --> 40:49.720
老来的呢

40:49.720 --> 40:52.720
是第三方库的开发者按照自己库

40:52.720 --> 40:55.720
把自己的库按照NPM的规范

40:55.720 --> 40:56.720
他里面有些规范

40:56.720 --> 40:57.720
我们后面会讲

40:57.720 --> 40:58.720
那么按照这些规范

40:58.720 --> 41:00.720
打包商传到数据库中

41:00.720 --> 41:01.720
比方说

41:01.720 --> 41:03.720
我是举个简单的例子

41:03.720 --> 41:04.720
一个形象的例子就是

41:04.720 --> 41:06.720
我是NPM的开发者

41:06.720 --> 41:08.720
我建了一个数据库

41:08.720 --> 41:09.720
然后我就打电话

41:09.720 --> 41:11.720
打电话给杰克尔瑞官方

41:11.720 --> 41:12.720
说我这边

41:12.720 --> 41:14.720
你要不然你把你这个代码

41:14.720 --> 41:16.720
你这个库的代码

41:16.720 --> 41:17.720
填一些描述信息

41:17.720 --> 41:18.720
把它打成一个包

41:18.720 --> 41:20.720
打包就是填一些描述信息

41:20.720 --> 41:21.720
对吧

41:21.720 --> 41:23.720
比方说你的作者是谁

41:23.720 --> 41:24.720
你的地址hop主页是谁

41:24.720 --> 41:25.720
对吧

41:25.720 --> 41:27.720
你的联系人的邮箱

41:27.720 --> 41:28.720
等等的那些信息填好

41:28.720 --> 41:30.720
填好了你发给我

41:30.720 --> 41:31.720
包括你的代码

41:31.720 --> 41:33.720
各个版本的代码也发给我

41:33.720 --> 41:34.720
那么我把它上传到

41:34.720 --> 41:36.720
我的数据库里面去保存

41:36.720 --> 41:37.720
那么别人以后

41:37.720 --> 41:38.720
用户下载的时候

41:38.720 --> 41:39.720
下载你的包的时候

41:39.720 --> 41:40.720
他就不用跑到

41:40.720 --> 41:41.720
你的官方网站去了

41:41.720 --> 41:42.720
他全部

41:42.720 --> 41:44.720
所有的第三方库

41:44.720 --> 41:46.720
全部到我这个网站

41:46.720 --> 41:48.720
进行统一的下载安装

41:48.720 --> 41:50.720
用统一的方式进行下载安装

41:50.720 --> 41:51.720
明白这个意思吗

41:51.720 --> 41:52.720
就是这个意思

41:52.720 --> 41:53.720
所以说他就是来

41:53.720 --> 41:55.720
把一个很大的数据库

41:55.720 --> 41:56.720
来保存这些东西

41:56.720 --> 41:58.720
它叫做registry

41:58.720 --> 41:59.720
叫入口

41:59.720 --> 42:01.720
那么使用者通过

42:01.720 --> 42:02.720
统一的地址下来的

42:02.720 --> 42:03.720
第三方库

42:03.720 --> 42:04.720
你就明白这个道理了吧

42:04.720 --> 42:05.720
所有的第三方库

42:05.720 --> 42:06.720
都到了我这儿来了

42:06.720 --> 42:07.720
所以说你直接要

42:07.720 --> 42:08.720
通过我这儿来

42:08.720 --> 42:09.720
进行下载就行了

42:09.720 --> 42:11.720
那么是不是统一的地址

42:11.720 --> 42:12.720
对不对

42:12.720 --> 42:13.720
就第一个组成部分

42:14.720 --> 42:16.720
第二就是他的官网

42:16.720 --> 42:17.720
在官网你肯定

42:17.720 --> 42:19.720
以后要经常访问的

42:19.720 --> 42:22.720
就是3w.npm.com

42:22.720 --> 42:24.720
打开看一下吧

42:26.720 --> 42:27.720
看一下吧

42:27.720 --> 42:29.720
官网的

42:29.720 --> 42:31.720
改版了吗

42:31.720 --> 42:32.720
我记得以前这里

42:32.720 --> 42:34.720
直接给你显示的一个

42:34.720 --> 42:36.720
显示一个他目前有多少个库

42:37.720 --> 42:38.720
现在好像没显示的

42:38.720 --> 42:40.720
目前是有几十万个库了

42:40.720 --> 42:41.720
在上面

42:41.720 --> 42:42.720
几十万个包在上面

42:42.720 --> 42:43.720
你要搜索一个包

42:43.720 --> 42:44.720
比方说在这里

42:44.720 --> 42:45.720
搜索一个接query

42:46.720 --> 42:47.720
回车

42:47.720 --> 42:48.720
你看就是一个

42:48.720 --> 42:49.720
搜出来了

42:49.720 --> 42:50.720
这就是个库

42:50.720 --> 42:51.720
这是个包

42:51.720 --> 42:53.720
你看这很多很多的库

42:53.720 --> 42:54.720
都上转过来了

42:54.720 --> 42:55.720
我们后边会说

42:55.720 --> 42:56.720
怎么来查罩

42:56.720 --> 42:57.720
怎么去查看他的文档

42:57.720 --> 42:58.720
怎么去使用

42:58.720 --> 42:59.720
我们后边会说

43:00.720 --> 43:01.720
那么就是他的官方

43:01.720 --> 43:02.720
官网

43:02.720 --> 43:03.720
我们用官网一般做什么

43:03.720 --> 43:04.720
一般是查包

43:04.720 --> 43:06.720
就查了有哪些包

43:06.720 --> 43:07.720
哪些包可以使用

43:07.720 --> 43:08.720
比方说点进去过后

43:08.720 --> 43:10.720
这个包里边有些详细信息

43:11.720 --> 43:12.720
weekly download

43:12.720 --> 43:13.720
什么意思呢

43:13.720 --> 43:14.720
就是搜下载量

43:14.720 --> 43:16.720
一搜的下载量大概有多少

43:16.720 --> 43:17.720
你看接query一搜的下载量

43:17.720 --> 43:18.720
有同学说

43:18.720 --> 43:20.720
接query到底还要不要学习呢

43:20.720 --> 43:21.720
你说要不要学习

43:21.720 --> 43:22.720
还不得学吗

43:22.720 --> 43:23.720
一搜有多少下载

43:23.720 --> 43:26.720
两百九十七万

43:26.720 --> 43:27.720
对吧

43:27.720 --> 43:28.720
那么九十七万的下载

43:28.720 --> 43:29.720
目前的版本

43:29.720 --> 43:30.720
三点四点一

43:30.720 --> 43:31.720
来省市

43:31.720 --> 43:33.720
就是徐河镇MIT

43:33.720 --> 43:35.720
那么就包的大小

43:36.720 --> 43:37.720
一点三

43:37.720 --> 43:38.720
一点三兆

43:38.720 --> 43:39.720
当然这是

43:39.720 --> 43:40.720
没有把它压缩过的

43:40.720 --> 43:41.720
没有压缩过的

43:41.720 --> 43:42.720
就原码格式的

43:42.720 --> 43:43.720
是有一点三兆

43:43.720 --> 43:44.720
一共有多少个文件呢

43:44.720 --> 43:46.720
一百二十五个文件

43:46.720 --> 43:47.720
有多

43:47.720 --> 43:48.720
提交了多少个问题呢

43:48.720 --> 43:49.720
七十三个问题

43:49.720 --> 43:50.720
七十三个问题

43:50.720 --> 43:51.720
好

43:51.720 --> 43:52.720
那么这是它的就是

43:52.720 --> 43:53.720
官方网站的

43:53.720 --> 43:54.720
Homepage 官方网站

43:54.720 --> 43:56.720
就是它的github主页

43:56.720 --> 43:57.720
对吧

43:57.720 --> 43:59.720
上一次更新是什么呢

43:59.720 --> 44:01.720
七个月之前

44:01.720 --> 44:03.720
就是这些信息对吧

44:03.720 --> 44:04.720
而且看这边

44:04.720 --> 44:06.720
是不是可以看到依赖

44:07.720 --> 44:08.720
看到这里有依赖

44:08.720 --> 44:09.720
dependency

44:09.720 --> 44:10.720
是吧 依赖

44:10.720 --> 44:11.720
表示我这个杰夸瑞库

44:11.720 --> 44:13.720
有没有依赖别的库呢

44:13.720 --> 44:14.720
dependency

44:14.720 --> 44:15.720
就是依赖

44:15.720 --> 44:16.720
有没有呢

44:16.720 --> 44:17.720
没有

44:18.720 --> 44:19.720
那下面是什么呢

44:19.720 --> 44:20.720
下面是我们以后再说

44:21.720 --> 44:22.720
那么后边是

44:22.720 --> 44:24.720
一万四千一

44:24.720 --> 44:25.720
一百二十三

44:25.720 --> 44:26.720
这是啥意思呢

44:26.720 --> 44:27.720
这是啥意思

44:27.720 --> 44:28.720
这表示有哪些库

44:28.720 --> 44:29.720
依赖的杰夸瑞呢

44:29.720 --> 44:30.720
看一下

44:30.720 --> 44:31.720
有很多的库

44:31.720 --> 44:32.720
都依赖杰夸瑞

44:32.720 --> 44:33.720
有一万多个库

44:33.720 --> 44:34.720
当然它这里

44:34.720 --> 44:35.720
没有完全列出来

44:35.720 --> 44:36.720
那么后边是

44:36.720 --> 44:38.720
五十个版本

44:38.720 --> 44:39.720
它五十个版本

44:39.720 --> 44:40.720
全部上传到就是

44:40.720 --> 44:41.720
MPM上面的

44:41.720 --> 44:42.720
你看

44:42.720 --> 44:44.720
每个版本都有记录

44:44.720 --> 44:45.720
目前的MPM上面

44:45.720 --> 44:46.720
有五十个版本

44:46.720 --> 44:47.720
记录到它的五十个版本

44:47.720 --> 44:49.720
这些东西说全在MPM上

44:49.720 --> 44:51.720
都可以通过官方网站

44:51.720 --> 44:52.720
可以进行查询

44:52.720 --> 44:53.720
比方说我们后边

44:53.720 --> 44:54.720
要学习到什么

44:54.720 --> 44:55.720
伍佑

44:55.720 --> 44:56.720
好 看一下吧

44:58.720 --> 44:59.720
伍佑

45:00.720 --> 45:01.720
Dependance

45:01.720 --> 45:02.720
没有依赖

45:02.720 --> 45:03.720
我们换一个

45:03.720 --> 45:04.720
换一个

45:04.720 --> 45:06.720
看一下有没有一个依赖的

45:08.720 --> 45:09.720
Ragged

45:10.720 --> 45:11.720
OK

45:11.720 --> 45:14.030
你看

45:14.030 --> 45:15.030
Ragged是我们后边要学的

45:15.030 --> 45:16.030
它有三个依赖

45:16.030 --> 45:17.030
刚才的伍佑

45:17.030 --> 45:18.030
好像不是官方的伍佑

45:18.030 --> 45:19.030
不是官方的伍佑

45:20.030 --> 45:21.030
没注意

45:21.030 --> 45:22.030
你看 是不是有三个依赖

45:22.030 --> 45:23.030
对吧

45:23.030 --> 45:24.030
三个依赖

45:24.030 --> 45:25.030
我们点其中一个依赖

45:25.030 --> 45:26.030
随便点一个

45:26.030 --> 45:27.030
其中一个依赖

45:27.030 --> 45:28.030
我看一下

45:28.030 --> 45:29.030
它有没有别的依赖

45:29.030 --> 45:30.030
Lose

45:31.030 --> 45:32.030
它也有一个依赖

45:32.030 --> 45:33.030
它有依赖这个

45:33.030 --> 45:34.030
我们看这个有没有依赖

45:35.030 --> 45:36.030
这个没依赖了

45:36.030 --> 45:37.030
是不是会形成

45:37.030 --> 45:39.030
包与包之间的依赖关系

45:39.030 --> 45:40.030
对吧

45:40.030 --> 45:41.030
就是这个意思

45:42.030 --> 45:43.030
我们回去

45:44.030 --> 45:45.030
官网一般来做什么

45:45.030 --> 45:46.030
一般我们平时用的时候

45:46.030 --> 45:47.030
就查询包

45:47.030 --> 45:48.030
它还有功能

45:48.030 --> 45:49.030
就是注册登录

45:49.030 --> 45:50.030
其实它

45:50.030 --> 45:51.030
这个官网里边

45:51.030 --> 45:52.030
它是有

45:52.030 --> 45:53.030
你看 这是有3UP

45:53.030 --> 45:54.030
3UP注册

45:54.030 --> 45:55.030
3IN登录

45:55.030 --> 45:56.030
它有注册登录的

45:56.030 --> 45:58.030
不过我们一般使用者

45:58.030 --> 45:59.030
开发者

45:59.030 --> 46:01.030
一般不会去注册登录

46:01.030 --> 46:03.030
什么人会去注册登录呢

46:03.030 --> 46:04.030
什么人呢

46:04.030 --> 46:07.030
我自己想写一个库

46:07.030 --> 46:09.030
分享出去给别人使用

46:09.030 --> 46:10.030
也像别人那样子

46:10.030 --> 46:12.030
把它伤传到NPM上去

46:12.030 --> 46:14.030
那就必须要注册登录了

46:14.030 --> 46:15.030
当然你用命令行

46:15.030 --> 46:16.030
我们后边会学的命令行

46:16.030 --> 46:17.030
也可以搞定

46:17.030 --> 46:18.030
不过

46:18.030 --> 46:19.030
你使用这个

46:19.030 --> 46:21.030
就是官网要简单一些

46:21.030 --> 46:22.030
注册登录

46:22.030 --> 46:23.030
官网一般

46:23.030 --> 46:25.030
一般就是用来查询包的

46:25.030 --> 46:27.030
这是第二个部分

46:27.030 --> 46:28.030
一个入口

46:28.030 --> 46:29.030
一个是数据户

46:29.030 --> 46:30.030
一个是官网

46:30.030 --> 46:31.030
还有一个是什么

46:31.030 --> 46:32.030
还有一个就是很重要的

46:32.030 --> 46:33.030
我们就是这门客

46:33.030 --> 46:35.030
主要学习的CD

46:35.030 --> 46:36.030
我们通常把CD

46:36.030 --> 46:38.030
也可以读作CLI

46:38.030 --> 46:39.030
它叫什么意思呢

46:39.030 --> 46:41.030
叫Command9 interface

46:41.030 --> 46:43.030
叫命令行接口

46:43.030 --> 46:44.030
什么意思

46:44.030 --> 46:46.030
就是它提供了

46:46.030 --> 46:48.030
你下载下来load

46:48.030 --> 46:50.030
把load安装好了之后

46:50.030 --> 46:51.030
你安装到NPM

46:51.030 --> 46:53.030
它就会自动安装NPM

46:53.030 --> 46:54.030
NPM就会在本地

46:54.030 --> 46:55.030
就是你的计算机上

46:55.030 --> 46:57.030
给你提供一个命令行接口

46:57.030 --> 46:58.030
这个命令行接口

46:58.030 --> 47:00.030
可以让你输入一些命令

47:00.030 --> 47:02.030
来操作NPM

47:02.030 --> 47:03.030
比如说我们后面要下载包

47:03.030 --> 47:04.030
下载一个包

47:04.030 --> 47:05.030
升级一个包

47:05.030 --> 47:07.030
卸载一个包

47:07.030 --> 47:08.030
等等操作

47:08.030 --> 47:10.030
NPM的很多操作

47:10.030 --> 47:12.030
都要通过本地的CD

47:12.030 --> 47:14.030
就是命令行接口来完成

47:14.030 --> 47:16.030
那命令行接口除了通数一点

47:16.030 --> 47:17.030
就是我们这里

47:17.030 --> 47:19.030
CMD里边写的命令

47:19.030 --> 47:21.030
比如我们CMD里边

47:21.030 --> 47:22.030
写到什么CD命令

47:22.030 --> 47:23.030
对吧

47:24.030 --> 47:26.030
地盘

47:26.030 --> 47:28.030
比方说DIR命令

47:28.030 --> 47:29.030
是不是

47:29.030 --> 47:30.030
这就是一个命令对吧

47:30.030 --> 47:31.030
这就是一个命令

47:31.030 --> 47:33.030
那么NPM里边

47:33.030 --> 47:34.030
它给我们提供了

47:34.030 --> 47:35.030
以前命令

47:35.030 --> 47:36.030
通过这个命令

47:36.030 --> 47:38.030
我们可以完成各种各样的操作

47:38.030 --> 47:39.030
安装好了NPM之后

47:39.030 --> 47:40.030
就可以了

47:40.030 --> 47:42.030
当然你现在用了温室过后

47:42.030 --> 47:43.030
我不太建议你

47:43.030 --> 47:44.030
使用CMD的方式了

47:44.030 --> 47:46.030
我建议你使用这个

47:46.030 --> 47:47.030
PowerShell

47:47.030 --> 47:48.030
PowerShell

47:48.030 --> 47:50.030
功能更加强大一点

47:50.030 --> 47:52.030
放大一点

47:52.030 --> 47:55.470
使用这个PowerShell

47:55.470 --> 47:56.470
PowerShell

47:56.470 --> 47:57.470
使用这个玩意

47:57.470 --> 47:59.470
当然你用了VSCode之后

47:59.470 --> 48:01.470
连这个都也不需要了

48:01.470 --> 48:03.470
因为我们按Ctrl加键

48:03.470 --> 48:05.470
按Ctrl加键

48:06.470 --> 48:08.470
你看Ctrl加键

48:08.470 --> 48:11.470
我这里设置的就是PowerShell环境的

48:11.470 --> 48:13.470
这里面直接输入命令

48:13.470 --> 48:14.470
输入命令

48:14.470 --> 48:16.470
比方说我们之前说DIR

48:16.470 --> 48:17.470
你看

48:17.470 --> 48:18.470
是不是可以查看目录

48:18.470 --> 48:19.470
对不对

48:19.470 --> 48:20.470
查看目录

48:20.470 --> 48:21.470
那么这里边

48:21.470 --> 48:23.470
我们就可以使用NPM

48:23.470 --> 48:24.470
给我们提供了命令

48:24.470 --> 48:25.470
这结构

48:25.470 --> 48:26.470
我们只交给大家一种命令

48:26.470 --> 48:27.470
怎么命令

48:27.470 --> 48:31.470
查看NPM的当前版本

48:31.470 --> 48:32.470
怎么写呢

48:32.470 --> 48:34.470
NPM

48:34.470 --> 48:35.470
NPM

48:35.470 --> 48:37.470
橫杠V

48:37.470 --> 48:39.470
橫杠V

48:39.470 --> 48:40.470
回车

48:40.470 --> 48:41.470
他告诉你

48:41.470 --> 48:43.470
我目前的NPM版本

48:43.470 --> 48:45.470
是6.4.1

48:45.470 --> 48:46.470
看一下

48:46.470 --> 48:47.470
大家现在去运行一下

48:47.470 --> 48:49.470
这里就是Ctrl加键

48:49.470 --> 48:50.470
或者是这样子

48:50.470 --> 48:51.470
我们之前都讲过

48:51.470 --> 48:53.470
右键的过程中打开

48:53.470 --> 48:54.470
在任何一个目录里面

48:54.470 --> 48:55.470
输入都行

48:55.470 --> 48:57.470
输入这个命令都行

48:57.470 --> 48:59.470
因为它是加入到环境面量的

48:59.470 --> 49:00.470
所以任何一个目录

49:00.470 --> 49:02.470
输入这个东西都行

49:02.470 --> 49:03.470
看一下当前的

49:03.470 --> 49:04.470
你安装的NPM的版本是多少

49:04.470 --> 49:05.470
看一下

49:05.470 --> 49:06.470
我这里是6.4.1

49:06.470 --> 49:07.470
无所谓

49:07.470 --> 49:09.470
可能有些版本的差异

49:09.470 --> 49:10.470
一般你们那边

49:10.470 --> 49:11.470
可能版本要高一点

49:11.470 --> 49:13.470
无所谓的

49:13.470 --> 49:14.470
如果说

49:14.470 --> 49:16.470
你在运行这个命令的时候出错了

49:16.470 --> 49:18.470
那么找里面取里边的

49:18.470 --> 49:20.470
相应老师给你解决一下

49:20.470 --> 49:22.470
一般是不会出问题的

49:22.470 --> 49:24.470
那么也可以输入了NPM

49:24.470 --> 49:26.470
两个横杆

49:26.470 --> 49:28.470
Version

49:28.470 --> 49:30.470
你看是不是一样的倒过

49:30.470 --> 49:32.470
一样的效果

49:32.470 --> 49:33.470
为什么是一样的

49:33.470 --> 49:34.470
因为这两个是一个东西

49:34.470 --> 49:35.470
既然我们后边

49:35.470 --> 49:37.470
会学习NPM的很多命令

49:37.470 --> 49:38.470
其实你会发现

49:38.470 --> 49:39.470
NPM的很多命令

49:39.470 --> 49:41.470
它是有一个权限

49:41.470 --> 49:43.470
权限是两个横杆开头的

49:43.470 --> 49:44.470
两个横杆开头的一个权限

49:44.470 --> 49:45.470
Version

49:45.470 --> 49:46.470
版本

49:46.470 --> 49:47.470
NPM我看一下

49:47.470 --> 49:49.470
NPM的版本是多少

49:49.470 --> 49:50.470
看到6.4.1

49:50.470 --> 49:52.470
也可以提供了一个

49:52.470 --> 49:54.470
相应来说简单的缩写

49:54.470 --> 49:56.470
就是一个横杆

49:56.470 --> 49:57.470
一个V

49:57.470 --> 49:59.470
这两个命令是一样的

49:59.470 --> 50:00.470
OK

50:00.470 --> 50:01.470
这一块我们只看一下

50:01.470 --> 50:02.470
这个命令就行了

50:02.470 --> 50:03.470
一般我们用这个命令

50:03.470 --> 50:04.470
再测试一下

50:04.470 --> 50:06.470
查看一下NPM的版本

50:06.470 --> 50:07.470
好

50:07.470 --> 50:08.470
这是我们这里和讲的内容

50:08.470 --> 50:09.470
这一块我们就介绍一下

50:09.470 --> 50:11.470
NPM它怎么来的

50:11.470 --> 50:12.470
为什么要来

50:12.470 --> 50:13.470
因为它是保管年期

50:13.470 --> 50:14.470
要解决

50:14.470 --> 50:16.470
手动来处理包的时候

50:16.470 --> 50:17.470
各种麻烦

50:17.470 --> 50:18.470
它要通过它来自动解决

50:18.470 --> 50:20.470
它提供了三个东西

50:20.470 --> 50:21.470
一个是入口

50:21.470 --> 50:22.470
入口你不用管

50:22.470 --> 50:24.470
它自己建的数据库在原成

50:24.470 --> 50:25.470
第二个是官网

50:25.470 --> 50:26.470
也不用管

50:26.470 --> 50:27.470
跟你没关系

50:27.470 --> 50:28.470
你只需要去用查询包就行了

50:28.470 --> 50:30.470
第三个就是我们CLI

50:30.470 --> 50:32.470
就是命令行接口

50:32.470 --> 50:33.470
我们要使用它

50:33.470 --> 50:34.470
提供的各种命令

50:34.470 --> 50:35.470
比方刚才学的一个命令

50:35.470 --> 50:36.470
就是横杆V

50:36.470 --> 50:37.470
对吧

50:37.470 --> 50:38.470
它要使用它

50:38.470 --> 50:39.470
提供的各种命令

50:39.470 --> 50:41.470
来完成各种操作

50:41.470 --> 50:43.470
最后我们跟它说一下

50:43.470 --> 50:44.470
NPM的关系是什么呢

50:44.470 --> 50:46.470
到底是谁成就了谁呢

50:46.470 --> 50:49.470
有人说是loader成就了NPM

50:49.470 --> 50:51.470
有人说是NPM成就了loader

50:51.470 --> 50:53.470
我觉得它们是相互成就的

50:53.470 --> 50:55.470
loader的出现了

50:55.470 --> 50:57.470
带来的模块化

50:57.470 --> 50:59.470
然后让NPM活了

50:59.470 --> 51:01.470
NPM的活

51:01.470 --> 51:02.470
就是很多

51:02.470 --> 51:03.470
很多就是

51:03.470 --> 51:04.470
因为前端人群很多

51:04.470 --> 51:06.470
前端的用户就是开发的技术很多

51:06.470 --> 51:08.470
它们愿意把自己的东西

51:08.470 --> 51:09.470
loader开发的东西

51:09.470 --> 51:10.470
上传到NPM上

51:10.470 --> 51:12.470
因为loader还没有自己的保管年期

51:12.470 --> 51:14.470
NPM的活报又带来了

51:14.470 --> 51:16.470
很多的第三方库的发展

51:16.470 --> 51:17.470
NPM的活报

51:17.470 --> 51:18.470
比方说有些优秀的第三方库

51:18.470 --> 51:20.470
比方说Roy X、R5U

51:20.470 --> 51:21.470
它们到了NPM上

51:21.470 --> 51:22.470
那么这些库

51:22.470 --> 51:23.470
因为loader带来的大量的用户

51:23.470 --> 51:25.470
所以它们是相互成就的

51:25.470 --> 51:26.470
好吧

51:26.470 --> 51:27.470
OK

51:27.470 --> 51:28.470
这是我们这几课

51:28.470 --> 51:29.470
可能有点啰嗦

51:29.470 --> 51:30.470
讲了多

51:30.470 --> 51:31.470
讲多就是对大家以后

51:31.470 --> 51:32.470
学习写

51:32.470 --> 51:34.470
具体的学习起来

51:34.470 --> 51:36.470
就是在概念上的

51:36.470 --> 51:37.470
少新鞋上岸

51:37.470 --> 51:38.470
好吧这是这几课的

51:38.470 --> 51:39.470
概述

51:39.470 --> 51:40.470
那么我们从下一个开始

51:40.470 --> 51:41.470
就开始正式来学习

51:41.470 --> 51:42.470
NPM

