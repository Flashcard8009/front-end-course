WEBVTT

00:00.880 --> 00:05.880
好 大家可能给大家介绍一下 最近这一两年

00:05.880 --> 00:11.380
比较流行的 比较前沿的这么一个保管力器叫做PMPM

00:11.380 --> 00:14.380
这个玩意我可以花多花点时间来讲一讲

00:14.380 --> 00:20.880
因为它我估计可能在未来会比较的火

00:20.880 --> 00:25.880
目前还有一些原因是会制作它的发展

00:25.880 --> 00:27.880
咱们来看一下这个PMPM

00:28.380 --> 00:31.880
它是一种新兴的保管力器 从MPM的下载量来看

00:31.880 --> 00:36.880
也就是它安装的话 它要下载安装 同样的我们要通过MPM的安装

00:36.880 --> 00:39.880
简单的说它就是一个包 它给你提供了一些命令

00:39.880 --> 00:42.880
那么我们要下载它的话 要从MPM去下载

00:42.880 --> 00:45.880
目前来看的话 它还没有超过压

00:45.880 --> 00:49.880
但是实际上它的功能 就是它的效率来说的话

00:49.880 --> 00:52.880
它已经超过压了 目前的下载量还没有超过

00:52.880 --> 00:55.880
一方面可能它的团队比较小

00:55.880 --> 00:57.880
最开始它就是一个人开发的

00:57.880 --> 01:01.880
我们知道压是一个团队开发的 它背后有些强大的组织

01:01.880 --> 01:04.880
但是PMPM背后就一个开发者

01:04.880 --> 01:08.880
团队比较小 也没有花大量的精力去宣传

01:08.880 --> 01:12.880
可能知名度没有压那么高

01:12.880 --> 01:17.880
但是它的实现方式就特别值得MPM和压来学习

01:17.880 --> 01:22.880
实际上MPM包括我们之前讲的CMPM

01:22.880 --> 01:26.880
CMPM在它的底层已经在向PMPM学习了

01:26.880 --> 01:29.880
因为我们之前说过 CMPM

01:29.880 --> 01:32.880
自从MPM它出来了就是Registered这个配置之后

01:32.880 --> 01:35.880
它本身也就意义不大了

01:35.880 --> 01:39.880
它还要想生存的话 可能要进一步往前走

01:39.880 --> 01:43.880
那么它就向PMPM学习了一些东西

01:43.880 --> 01:46.880
包括目前的官方MPM

01:46.880 --> 01:50.880
它某一些细节的地方也在向它学习

01:51.880 --> 01:54.880
而且做一些比较喜欢前沿技术的开发者

01:54.880 --> 01:56.880
他用过这个东西之后

01:56.880 --> 01:59.880
他一般都会推荐使用PMPM

01:59.880 --> 02:01.880
PMPM它为什么这么屌

02:01.880 --> 02:03.880
它到底具有什么样的优势呢

02:03.880 --> 02:05.880
咱们就给大家总结到四个点

02:05.880 --> 02:10.880
第一个点 它的安装效率要高于MPM和压

02:10.880 --> 02:13.880
包括它们的最新版 它都比它们高

02:13.880 --> 02:15.880
至于为什么这么高

02:15.880 --> 02:17.880
后面我们稍微的讲一下它的原理

02:18.880 --> 02:21.880
另外通过PMPM去安装之后

02:21.880 --> 02:25.880
可以获得非常简洁的NodeMarch 90目录

02:25.880 --> 02:27.880
以后我们就可以看到了

02:27.880 --> 02:30.880
还用它可以避免开发时使用间接一代的问题

02:30.880 --> 02:33.880
第四能够极大的降低使用空间的占用

02:33.880 --> 02:35.880
目前就这么四个优势

02:35.880 --> 02:38.880
咱们看一下吧 用一下你就明白了

02:39.880 --> 02:40.880
首先我们要

02:43.880 --> 02:46.880
首先我们要去安装一下PMPM

02:46.880 --> 02:48.880
安装PMPM的话

02:48.880 --> 02:50.880
全聚安装

02:51.880 --> 02:52.880
全聚安装

02:52.880 --> 02:56.880
我们使用NPMI 横杠技

02:56.880 --> 02:58.880
安装PMPM

02:58.880 --> 02:59.880
也就是说这个东西

02:59.880 --> 03:01.880
它本身就是作为一个MPM包出现的

03:01.880 --> 03:02.880
我们回车

03:02.880 --> 03:04.880
然后进行全聚安装

03:04.880 --> 03:06.880
为什么要进行全聚安装呢

03:06.880 --> 03:07.880
因为它给你提供了一个命令

03:07.880 --> 03:09.880
这个命令我们之后

03:09.880 --> 03:10.880
进行包管理的时候

03:10.880 --> 03:11.880
就全部使用这个命令

03:11.880 --> 03:13.880
就是PMPM命令

03:13.880 --> 03:15.880
所以说你得最好用全聚安装

03:15.880 --> 03:16.880
不然的话

03:16.880 --> 03:18.880
以后每个工程都要去安装

03:18.880 --> 03:19.880
PMPM 特别麻烦

03:19.880 --> 03:21.880
你直接用全聚安装就完事了

03:22.880 --> 03:23.880
稍微等一下

03:27.150 --> 03:28.150
安装完成

03:28.150 --> 03:29.150
安装完成之后

03:29.150 --> 03:30.150
我们可以通过

03:30.150 --> 03:32.150
PMPM-V

03:32.150 --> 03:33.150
这个命令

03:33.150 --> 03:35.150
来查看一下能不能运行成功

03:35.150 --> 03:37.150
我这里发现可以运行成功

03:37.150 --> 03:38.150
说明啥呢

03:38.150 --> 03:39.150
它的版本是4.6.0

03:40.150 --> 03:41.150
然后呢

03:41.150 --> 03:42.150
它给你提供了一个命令

03:42.150 --> 03:43.150
PMPM 是正常的

03:43.150 --> 03:44.150
可以正常使用了

03:45.150 --> 03:47.150
那之后怎么去使用呢

03:47.150 --> 03:48.150
特别特别简单

03:49.150 --> 03:51.150
就是把你平时用的NPM

03:52.150 --> 03:54.150
把它换成PMPM就行了

03:55.150 --> 03:56.150
只不过有一些

03:56.150 --> 03:58.150
有一些命令可能不能使用

03:59.150 --> 04:01.150
如果说你用PMPM的时候

04:01.150 --> 04:02.150
遇到一些细节的命令

04:02.150 --> 04:03.150
不能使用的话

04:03.150 --> 04:04.150
你把它换成NPM

04:04.150 --> 04:06.150
通常我们安装包

04:06.150 --> 04:07.150
和卸载包

04:07.150 --> 04:10.150
我们都会把它换成PMPM

04:10.150 --> 04:11.150
咱们来试一下

04:12.150 --> 04:13.150
比方说我们用PMPM

04:13.150 --> 04:14.150
去安装一个包

04:15.150 --> 04:16.150
安装什么包呢

04:16.150 --> 04:17.150
我们比方说以前

04:17.150 --> 04:19.150
我们安装过一个叫Mochar

04:19.150 --> 04:20.150
一个测试工具

04:20.150 --> 04:21.150
对不对

04:21.150 --> 04:22.150
安装过这个包

04:22.150 --> 04:24.150
这个包是不是有很多的依赖

04:24.150 --> 04:25.150
对吧

04:25.150 --> 04:26.150
它有大对的依赖

04:26.150 --> 04:27.150
我们先看到过的

04:27.150 --> 04:30.170
我们这里回车

04:30.170 --> 04:31.170
让它安装

04:31.170 --> 04:32.170
那么第一次安装了

04:32.170 --> 04:33.170
它由于没有缓存

04:33.170 --> 04:34.170
你看它是不是要下载

04:34.170 --> 04:35.170
对吧

04:35.170 --> 04:36.170
把这个包要下载下来

04:36.170 --> 04:37.170
以及包的所有依赖

04:37.170 --> 04:39.170
全部下载下来

04:40.170 --> 04:41.170
下载完成

04:41.170 --> 04:43.170
那么它加了一个依赖

04:43.170 --> 04:44.170
叫Mochar

04:44.170 --> 04:46.170
目前的版本是6.2.2

04:46.170 --> 04:47.170
对不对

04:47.170 --> 04:48.170
现在下载完成了

04:48.170 --> 04:49.170
同样的呢

04:49.170 --> 04:51.170
它会生成一个load-marges目录

04:51.170 --> 04:54.170
而且这个package.json

04:54.170 --> 04:55.170
我们刚才没有写

04:55.170 --> 04:56.170
它这个东西跟一样

04:56.170 --> 04:57.170
它跟一样差不多

04:57.170 --> 04:59.170
一样如果说你没有写

04:59.170 --> 05:01.170
package.json这个配置文件

05:01.170 --> 05:02.170
那么它会自动给你生成

05:02.170 --> 05:03.170
对吧

05:03.170 --> 05:04.170
那么PMPM也一样

05:04.170 --> 05:05.170
它会自动给你生成

05:05.170 --> 05:07.170
而且把依赖关系给你加进去

05:07.170 --> 05:08.170
这些都是看得到的

05:09.170 --> 05:11.170
还有这个文件是干吗的呢

05:11.170 --> 05:12.170
这个文件

05:12.170 --> 05:13.170
其实就是它的

05:13.170 --> 05:15.170
就类似于一样的一个锁文件

05:15.170 --> 05:16.170
就是来锁定版本的

05:16.170 --> 05:18.170
来记录详细版本的

05:18.170 --> 05:19.170
就是这个文件

05:19.170 --> 05:21.170
记录它每一个依赖的详细版本

05:21.170 --> 05:22.170
那么是不是一样了

05:22.170 --> 05:23.170
感觉它都差不多对吧

05:23.170 --> 05:25.170
那为什么它那么强大呢

05:25.170 --> 05:26.170
接着我们来看

05:28.540 --> 05:29.540
首先我们看这

05:29.540 --> 05:30.540
首先下载

05:30.540 --> 05:32.540
目前下载了87个包

05:32.540 --> 05:33.540
对吧

05:33.540 --> 05:34.540
目前下载了87个包

05:34.540 --> 05:35.540
那一换了

05:35.540 --> 05:36.540
如果说我们把这个删掉

05:36.540 --> 05:38.540
load-marges目录删掉

05:39.540 --> 05:40.540
删掉

05:41.540 --> 05:42.540
那么其实你感觉到了

05:42.540 --> 05:44.540
删这个目录有这么多包

05:44.540 --> 05:45.540
其实删起来的

05:45.540 --> 05:46.540
已经比其他的

05:46.540 --> 05:48.540
用压压用npm删起来快得多了

05:48.540 --> 05:49.540
至于为什么了

05:49.540 --> 05:50.540
以后我们再详细说

05:51.540 --> 05:52.540
好

05:52.540 --> 05:53.540
现在我们再安装一次

05:53.540 --> 05:55.540
pnpm

05:55.540 --> 05:56.540
i

05:58.540 --> 06:01.690
安装一次

06:01.690 --> 06:02.690
那么这个时候

06:02.690 --> 06:03.690
你看它有没有下载

06:03.690 --> 06:04.690
是不是完全没有下载

06:04.690 --> 06:05.690
对吧

06:05.690 --> 06:06.690
它完美

06:06.690 --> 06:07.690
就reused

06:07.690 --> 06:09.690
我们总共需要了87个

06:10.690 --> 06:11.690
reused的什么意思呢

06:11.690 --> 06:12.690
就是

06:12.690 --> 06:14.690
我们重复使用

06:14.690 --> 06:16.690
之前缓存里边了

06:16.690 --> 06:18.690
有87个全部使用的是缓存

06:18.690 --> 06:20.690
我们从一个都没下载

06:20.690 --> 06:22.690
所以这样子速度就会快很多

06:22.690 --> 06:23.690
OK

06:23.690 --> 06:25.690
这是关于它的缓存

06:25.690 --> 06:27.690
然后我们主重点去看一下

06:27.690 --> 06:29.690
load-marges目录

06:29.690 --> 06:30.690
咱们展开看一下

06:30.690 --> 06:31.690
你会发现这个目录

06:31.690 --> 06:33.690
特别的简洁

06:33.690 --> 06:35.690
变得特别的清晰简洁

06:35.690 --> 06:36.690
你看我们安装的

06:36.690 --> 06:38.690
我们一代的不是marcher

06:38.690 --> 06:39.690
OK

06:39.690 --> 06:40.690
那么它直接就是marcher

06:40.690 --> 06:41.690
对吧

06:41.690 --> 06:43.690
它直接就是一代这个东西

06:43.690 --> 06:45.690
它直接就是指数相的marcher

06:45.690 --> 06:48.690
就跟我们以前看到的MPM

06:48.690 --> 06:50.690
和一二是不是不太一样

06:50.690 --> 06:51.690
一二和MPM

06:51.690 --> 06:53.690
它是不是把所有的依赖

06:53.690 --> 06:54.690
把它拍平了

06:54.690 --> 06:55.690
拍扁了

06:55.690 --> 06:57.690
一起放到这个目录下面

06:57.690 --> 06:58.690
对吧

06:58.690 --> 06:59.690
这是我们以前的

06:59.690 --> 07:00.690
我们以前去MPM的时候

07:00.690 --> 07:01.690
我看一下

07:01.690 --> 07:03.690
包的使用

07:03.690 --> 07:04.690
你看

07:04.690 --> 07:06.690
那个地方我记得安装了

07:06.690 --> 07:08.690
安装了marcher的

07:08.690 --> 07:09.690
你看安装marcher之后

07:09.690 --> 07:11.690
是不是就安装了很多东西

07:11.690 --> 07:12.690
对吧

07:12.690 --> 07:13.690
它安装了很多东西

07:13.690 --> 07:14.690
但是呢

07:14.690 --> 07:15.690
这边

07:15.690 --> 07:16.690
你会看到

07:16.690 --> 07:17.690
它这个目录下面

07:17.690 --> 07:18.690
只有一个marcher

07:18.690 --> 07:20.690
这就一个好处在什么呢

07:20.690 --> 07:22.690
它主要的好处在于

07:22.690 --> 07:23.690
我们后边

07:23.690 --> 07:25.690
如果说你去使用的时候

07:25.690 --> 07:27.690
你只能使用marcher

07:27.690 --> 07:28.690
这个是没问题的

07:28.690 --> 07:29.690
因为你依赖它

07:29.690 --> 07:30.690
你去使用它

07:31.690 --> 07:32.690
就是这里

07:32.690 --> 07:33.690
我们比较说

07:33.690 --> 07:34.690
load test

07:34.690 --> 07:35.690
第二件事

07:35.690 --> 07:36.690
你这样子是不是不抱错的

07:36.690 --> 07:37.690
没问题的

07:37.690 --> 07:38.690
它能够正确的

07:38.690 --> 07:39.690
把这个包倒入进来

07:39.690 --> 07:40.690
但是

07:40.690 --> 07:41.690
如果说你去使用

07:41.690 --> 07:42.690
间接一代

07:42.690 --> 07:43.690
它就不行了

07:43.690 --> 07:44.690
你就不能去直接使用

07:44.690 --> 07:45.690
间接一代了

07:45.690 --> 07:47.690
因为我们这里的声明的时候

07:47.690 --> 07:48.690
声明的是

07:48.690 --> 07:49.690
我只依赖marcher

07:49.690 --> 07:50.690
对吧

07:50.690 --> 07:52.690
那么我要用的时候

07:52.690 --> 07:53.690
只能用marcher

07:53.690 --> 07:54.690
因为我这里声明的

07:54.690 --> 07:55.690
依赖它

07:55.690 --> 07:56.690
所以说我只能用它

07:56.690 --> 07:57.690
如果说你去用

07:57.690 --> 07:58.690
marcher的依赖

07:58.690 --> 07:59.690
行不行

07:59.690 --> 08:00.690
不行

08:00.690 --> 08:01.690
比方说

08:01.690 --> 08:02.690
我们看一下

08:02.690 --> 08:03.690
marcher依赖啥

08:03.690 --> 08:04.690
marcher依赖

08:04.690 --> 08:05.690
我们来看一下

08:05.690 --> 08:06.690
它的拍片点节省

08:06.690 --> 08:07.690
看它的文件

08:07.690 --> 08:09.690
我们往下找一找

08:09.690 --> 08:10.690
第一

08:11.690 --> 08:12.690
OK

08:12.690 --> 08:13.690
我们随便找一个吧

08:13.690 --> 08:14.690
它依赖什么

08:14.690 --> 08:15.690
依赖这个dif

08:15.690 --> 08:16.690
依赖这个dif这个包

08:16.690 --> 08:18.690
那么我们这里能不能去

08:18.690 --> 08:19.690
依赖dif

08:19.690 --> 08:20.690
去把dif的内容拿出来了

08:20.690 --> 08:21.690
可不可以呢

08:22.690 --> 08:23.690
我们看一下

08:24.690 --> 08:25.690
这不可以

08:25.690 --> 08:27.690
它说找不到模块dif

08:27.690 --> 08:29.690
这个东西就跟我们的NPM

08:29.690 --> 08:30.690
和压就不太一样了

08:30.690 --> 08:31.690
咱们用NPM来试一下

08:31.690 --> 08:32.690
用压来试一下

08:33.690 --> 08:34.690
我们这里把loadmarcher

08:34.690 --> 08:35.690
目录删掉

08:35.690 --> 08:36.690
重新来一次

08:36.690 --> 08:39.190
拍片点

08:39.190 --> 08:40.190
这个目录

08:40.190 --> 08:41.190
我们一把

08:42.190 --> 08:44.190
这个锁这个目录删掉

08:44.190 --> 08:46.190
现在我们用NPM来搞

08:46.190 --> 08:47.190
试一次

08:47.190 --> 08:48.190
NPM install

08:48.190 --> 08:50.190
那么安装一下这个marcher

08:51.190 --> 08:52.190
回车

08:52.190 --> 08:56.890
我们用原式的NPM命令来试一下

08:56.890 --> 08:57.890
你看

08:57.890 --> 08:59.890
NPM是不是明显的感觉

08:59.890 --> 09:00.890
要慢很多

09:01.890 --> 09:05.160
OK

09:05.160 --> 09:07.160
那么我们看到NPM安装之后

09:07.160 --> 09:08.160
我们以前做的

09:08.160 --> 09:09.160
它是把拍片

09:09.160 --> 09:10.160
它的依赖

09:10.160 --> 09:11.160
它marcher要安装在这个目录

09:11.160 --> 09:12.160
那它的依赖

09:12.160 --> 09:14.160
全部要安装在这个目录

09:14.160 --> 09:15.160
那么这就导致

09:15.160 --> 09:16.160
导致了什么问题

09:16.160 --> 09:17.160
你看我们现在的单码

09:17.160 --> 09:18.160
会不会爆错

09:18.160 --> 09:19.160
NPM

09:20.160 --> 09:21.160
load

09:21.160 --> 09:22.160
test

09:22.160 --> 09:23.160
你看是不是不爆错了

09:23.160 --> 09:24.160
也就是说

09:24.160 --> 09:25.160
以前的NPM

09:25.160 --> 09:26.160
和压也好

09:26.160 --> 09:27.160
NPM也好

09:27.160 --> 09:29.160
它给我们带到一个不好的

09:29.160 --> 09:30.160
就是让我们

09:30.160 --> 09:32.160
有机会犯错的一个点是什么

09:32.160 --> 09:34.160
我们可以去使用

09:34.160 --> 09:35.160
间接依赖

09:35.160 --> 09:37.160
实际上在任何的

09:38.160 --> 09:40.160
很多的语言的开发环境里边

09:40.160 --> 09:42.160
你都不允许去使用间接依赖了

09:42.160 --> 09:44.160
你要去使用它

09:44.160 --> 09:45.160
说明你什么

09:45.160 --> 09:46.160
你想这个道理

09:46.160 --> 09:47.160
这是我们的工程的代码

09:47.160 --> 09:48.160
对吧

09:48.160 --> 09:49.160
我们的工程代码去

09:49.160 --> 09:50.160
去使用了什么

09:50.160 --> 09:51.160
dif

09:51.160 --> 09:52.160
这个包

09:52.160 --> 09:53.160
那么说明我们工程

09:53.160 --> 09:54.160
是不是直接依赖dif的

09:54.160 --> 09:55.160
但是你的拍片点

09:55.160 --> 09:56.160
介绍里边有没有

09:56.160 --> 09:57.160
描述你直接依赖dif

09:57.160 --> 09:58.160
没有

09:59.160 --> 10:00.160
过去就会出现

10:00.160 --> 10:01.160
这种情况

10:01.160 --> 10:03.160
甚至有些

10:03.160 --> 10:05.160
保得开发者

10:05.160 --> 10:06.160
因为他技术水平有限

10:06.160 --> 10:08.160
理解可能理解有限

10:08.160 --> 10:09.160
或者是有些

10:09.160 --> 10:11.160
有的时候图方便

10:11.160 --> 10:13.160
比方说我确实

10:13.160 --> 10:14.160
我在开发的过程中

10:14.160 --> 10:15.160
确实要使用这个包

10:15.160 --> 10:17.160
我不想去安装了

10:17.160 --> 10:18.160
为什么呢

10:18.160 --> 10:20.160
因为我安装这个

10:20.160 --> 10:21.160
摸卡的时候

10:21.160 --> 10:22.160
已经自动帮我安装了

10:22.160 --> 10:23.160
我就懒得去

10:23.160 --> 10:24.160
我懒得去这里

10:24.160 --> 10:25.160
重新安装一次

10:25.160 --> 10:26.160
重新去写一下这个

10:26.160 --> 10:27.160
依赖关系了

10:27.160 --> 10:28.160
那么就会导致这些

10:28.160 --> 10:30.160
不良的开发代码出现

10:30.160 --> 10:31.160
所以说这是不好的

10:31.160 --> 10:32.160
但是

10:32.160 --> 10:33.160
npmp

10:33.160 --> 10:34.160
规避了这个问题

10:34.160 --> 10:36.160
我们再把删除

10:40.880 --> 10:42.880
然后把这个也删除

10:42.880 --> 10:43.880
现在我们再用

10:43.880 --> 10:44.880
pmpm再试一次

10:44.880 --> 10:46.880
用pmpm

10:46.880 --> 10:49.640
install

10:50.640 --> 10:53.140
稍等一下

10:53.140 --> 10:54.140
OK

10:56.140 --> 10:57.140
那么pmpm

10:57.140 --> 10:58.140
他就避避了这个问题

10:58.140 --> 10:59.140
因为为什么呢

10:59.140 --> 11:00.140
他并没有把

11:00.140 --> 11:01.140
他的间接依赖

11:01.140 --> 11:03.140
也放到这个目录下边

11:03.140 --> 11:05.140
这就是pmpm的做法

11:05.140 --> 11:06.140
OK

11:06.140 --> 11:07.140
不继续看

11:08.140 --> 11:09.140
另外呢

11:10.140 --> 11:11.140
另外呢

11:11.140 --> 11:12.140
如果说你要执行

11:12.140 --> 11:13.140
本地的CD

11:13.140 --> 11:15.140
你可以使用p

11:15.140 --> 11:16.140
npx

11:16.140 --> 11:17.140
那么他的功能

11:17.140 --> 11:18.140
跟那个npx的功能

11:18.140 --> 11:19.140
是完全一样的

11:19.140 --> 11:21.140
就比方说我们之前的

11:21.140 --> 11:22.140
我们是安装到本地的

11:22.140 --> 11:23.140
对吧

11:23.140 --> 11:24.140
我们要使用什么

11:24.140 --> 11:25.140
npx摩卡

11:25.140 --> 11:26.140
对吧

11:26.140 --> 11:27.140
我们安装的摩卡

11:27.140 --> 11:28.140
需要使用这个

11:28.140 --> 11:29.140
需要使用这个玩意

11:31.140 --> 11:32.140
他现在报错了

11:32.140 --> 11:33.140
报错了

11:33.140 --> 11:34.140
报错的原因呢

11:34.140 --> 11:35.140
是我这里不是测试代码

11:36.140 --> 11:37.140
我这个代码

11:37.140 --> 11:38.140
他要执行这个tester.js

11:39.140 --> 11:40.140
我要保存一下

11:41.140 --> 11:42.140
npx摩卡

11:44.140 --> 11:45.140
目前呢

11:45.140 --> 11:46.140
他没有报错

11:46.140 --> 11:47.140
因为我这里有个tester.js

11:47.140 --> 11:48.140
其实他默认情况下

11:48.140 --> 11:50.140
就会运行这个tester.js

11:50.140 --> 11:51.140
它是一个测试的

11:51.140 --> 11:52.140
测试的脚本

11:52.140 --> 11:53.140
一个测试的命令

11:53.140 --> 11:54.140
那么这个tester.js

11:54.140 --> 11:55.140
里面啥都没写

11:55.140 --> 11:56.140
他就说

11:56.140 --> 11:58.140
没有0个脚本

11:58.140 --> 11:59.140
通过测试

11:59.140 --> 12:01.140
运行的时间是2毫秒

12:01.140 --> 12:02.140
这个东西不管他

12:02.140 --> 12:03.140
总之这个命令是不是运行了

12:04.140 --> 12:05.140
那么同样的

12:05.140 --> 12:06.140
我们也可以使用np

12:07.140 --> 12:09.140
pnpx摩卡

12:09.140 --> 12:10.140
是一样的效果

12:10.140 --> 12:11.140
完全一样的效果

12:12.140 --> 12:13.140
那么这两个有什么区别

12:13.140 --> 12:14.140
他们区别就在于一个

12:15.140 --> 12:16.140
就是什么呢

12:16.140 --> 12:18.140
当我们去安装

12:18.140 --> 12:19.140
用npx

12:20.140 --> 12:21.140
去执行一个

12:21.140 --> 12:22.140
不存在的命令的时候

12:22.140 --> 12:23.140
他会进行安装

12:23.140 --> 12:25.140
那么如果用pnpx的时候

12:25.140 --> 12:27.140
他会用pnpm来进行安装

12:27.140 --> 12:28.140
什么意思

12:28.140 --> 12:29.140
说的这么长串

12:29.140 --> 12:30.140
是什么意思

12:30.140 --> 12:31.140
比方说我们把

12:31.140 --> 12:32.140
loaded margins去掉

12:33.140 --> 12:34.140
把loaded margins去掉

12:34.140 --> 12:36.140
我们再把这东西

12:36.140 --> 12:37.140
全部去掉

12:37.140 --> 12:38.140
全部去掉

12:38.140 --> 12:39.140
好比方说

12:39.140 --> 12:41.140
我们现在干净了工程

12:41.140 --> 12:42.140
那么这个时候

12:42.140 --> 12:43.140
我们是不是没有安装

12:43.140 --> 12:44.140
任何的本地命令

12:44.140 --> 12:45.140
对吧

12:45.140 --> 12:46.140
摩卡是不是没有安装

12:46.140 --> 12:47.140
那么这个时候

12:47.140 --> 12:48.140
能去执行摩卡吗

12:49.140 --> 12:50.140
实际上

12:50.140 --> 12:51.140
以前是不想

12:51.140 --> 12:52.140
现在是可以了

12:52.140 --> 12:54.140
现在npx是有这样的功能了

12:54.140 --> 12:56.140
他是哪跟谁学的

12:56.140 --> 12:57.140
就是这些保管的一些

12:57.140 --> 12:59.140
他们之间就是互相学来学去

12:59.140 --> 13:01.140
说不定我讲完课

13:01.140 --> 13:02.140
过了一两个月

13:02.140 --> 13:03.140
他们又更新了

13:03.140 --> 13:04.140
又互相学了一些东西

13:04.140 --> 13:05.140
他们互相学习

13:05.140 --> 13:06.140
跟以前那个

13:06.140 --> 13:08.140
java和cshab差不多

13:08.140 --> 13:10.140
两个打老之间

13:10.140 --> 13:11.140
相互学习

13:12.140 --> 13:13.140
那么这里是跟谁学的

13:13.140 --> 13:14.140
跟压学的

13:14.140 --> 13:15.140
压里边不是有个东西吗

13:15.140 --> 13:16.140
我们之前学过

13:16.140 --> 13:18.140
压里边有个特别礼物

13:18.140 --> 13:19.140
还记得吗

13:19.140 --> 13:20.140
我们当我们使用

13:20.140 --> 13:22.140
压create这个命令的时候

13:22.140 --> 13:23.140
他干嘛呢

13:23.140 --> 13:25.140
他会去帮我们去安装

13:25.140 --> 13:26.140
一些命令

13:26.140 --> 13:27.140
全局安装一些命令

13:27.140 --> 13:28.140
那么这个npx

13:28.140 --> 13:30.140
如果去执行一个

13:30.140 --> 13:31.140
不存在的命令的时候

13:31.140 --> 13:32.140
他会怎么样了

13:32.140 --> 13:34.140
他会在本地零时

13:34.140 --> 13:35.140
安装一个

13:35.140 --> 13:36.140
然后用完了

13:36.140 --> 13:37.140
马上就把它

13:37.140 --> 13:38.140
它是这样子

13:38.140 --> 13:39.140
简单说一下吧

13:39.140 --> 13:43.950
放在这儿

13:43.950 --> 13:44.950
再简单说一下

13:47.840 --> 13:50.840
就当使用npx

13:50.840 --> 13:52.840
就比如

13:52.840 --> 13:54.840
比如使用npx

13:54.840 --> 13:55.840
Mochia

13:55.840 --> 13:57.840
那么执行

13:57.840 --> 14:00.840
本地的

14:00.840 --> 14:01.840
哪个命令

14:01.840 --> 14:03.840
Mochia命令是

14:06.220 --> 14:07.220
如果

14:08.220 --> 14:09.220
Mochia

14:10.220 --> 14:11.220
没有安装

14:11.220 --> 14:13.220
如果说他没有安装

14:13.220 --> 14:14.220
则

14:14.220 --> 14:15.220
npx

14:15.220 --> 14:17.220
会自动的

14:17.220 --> 14:19.220
零时的

14:19.220 --> 14:20.220
安装Mochia

14:20.220 --> 14:21.220
这个跟一样的

14:21.220 --> 14:22.220
还有点不一样

14:22.220 --> 14:23.220
他会自动的

14:23.220 --> 14:25.220
零时的去安装Mochia

14:26.220 --> 14:28.220
安装好了

14:28.220 --> 14:30.220
安装好了之后

14:30.220 --> 14:32.220
安装好了之后

14:33.220 --> 14:35.220
安装好后

14:36.220 --> 14:38.220
自动运行

14:38.220 --> 14:39.220
Mochia命令

14:39.220 --> 14:41.220
他就会做这么一件事

14:41.220 --> 14:43.220
比方说我们这里简单说一下

14:43.220 --> 14:44.220
我们这里npx

14:44.220 --> 14:45.220
Mochia一回车

14:45.220 --> 14:46.220
是否没有这个命令

14:46.220 --> 14:47.220
哪有这个命令

14:47.220 --> 14:48.220
没有

14:48.220 --> 14:49.220
没有的话

14:49.220 --> 14:50.220
他会去零时安装

14:50.220 --> 14:51.220
这个Mochia命令

14:51.220 --> 14:52.220
安装好了过后

14:52.220 --> 14:53.220
马上去执行它

14:53.220 --> 14:54.220
所以说

14:54.220 --> 14:55.220
我们可以使用npx

14:55.220 --> 14:57.220
达到跟之前一二里边

14:57.220 --> 14:59.220
created那个命令的

14:59.220 --> 15:00.220
类似的效果

15:01.220 --> 15:02.220
安装成功了

15:02.220 --> 15:03.220
去零时使用

15:03.220 --> 15:04.220
那么再来

15:04.220 --> 15:05.220
我们Mochia的时候

15:05.220 --> 15:06.220
再来

15:08.220 --> 15:10.220
那是不是又要重新去安装

15:10.220 --> 15:12.220
因为它是零时安装的

15:12.220 --> 15:13.220
零时安装的

15:13.220 --> 15:14.220
所以说

15:14.220 --> 15:16.220
它不会保存在本地

15:16.220 --> 15:17.220
相当于是

15:17.220 --> 15:18.220
它下来到内存

15:18.220 --> 15:19.220
内存里面去运行下命令

15:19.220 --> 15:21.220
那么下一次使用者

15:21.220 --> 15:22.220
他也得重新安装

15:22.220 --> 15:23.220
如果说我们要

15:23.220 --> 15:24.220
经常使用的命令的话

15:24.220 --> 15:26.220
肯定不能这样干

15:26.220 --> 15:27.220
肯定要去安装下来

15:27.220 --> 15:28.220
但是如果说

15:28.220 --> 15:29.220
有的时候我们比方说

15:29.220 --> 15:30.220
使用脚手架

15:30.220 --> 15:32.220
我们之前还给他演示过

15:32.220 --> 15:33.220
虽然说我们现在

15:33.220 --> 15:35.220
没有学习过reacts

15:35.220 --> 15:36.220
但是我给大家演示过

15:36.220 --> 15:37.220
使用脚手架

15:37.220 --> 15:39.220
来搭建一个工程的时候

15:39.220 --> 15:40.220
我们可能就是要

15:40.220 --> 15:42.220
零时的下载一个脚手架

15:42.220 --> 15:43.220
零时的把脚手架

15:43.220 --> 15:45.220
去搭建一个工程

15:45.220 --> 15:46.220
那么这个时候

15:46.220 --> 15:47.220
我们就可以用npx

15:47.220 --> 15:49.220
一个命令叫crazy rekt

15:49.220 --> 15:50.220
app

15:50.220 --> 15:51.220
是个脚手架

15:51.220 --> 15:53.220
后边是不是写上

15:53.220 --> 15:55.220
这个命令后边的参数

15:55.220 --> 15:56.220
后边的东西就是

15:56.220 --> 15:57.220
给这个命令的

15:57.220 --> 15:59.220
它先下载这个命令

15:59.220 --> 16:00.220
零时下载

16:00.220 --> 16:01.220
然后

16:01.220 --> 16:02.220
再去用这个命令

16:02.220 --> 16:03.220
执行后边的参数

16:03.220 --> 16:05.220
后边参数比方说mine

16:05.220 --> 16:06.220
app

16:06.220 --> 16:07.220
可以回车

16:07.220 --> 16:08.220
那么这个时候

16:08.220 --> 16:09.220
它就会先去下载

16:09.220 --> 16:10.220
这个命令

16:10.220 --> 16:11.220
然后去执行这个玩意

16:11.220 --> 16:12.220
你看这个

16:12.220 --> 16:14.220
是不是要再搭建了

16:14.220 --> 16:16.220
停了停止停止

16:17.220 --> 16:18.220
OK

16:18.220 --> 16:19.220
这是我们以后要接触的

16:19.220 --> 16:20.220
就说一下

16:20.220 --> 16:21.220
就是npx

16:21.220 --> 16:22.220
就是npx这个命令

16:22.220 --> 16:24.220
它有可能也会触发

16:24.220 --> 16:26.220
触发包的安装

16:26.220 --> 16:28.220
也有可能会触发包的安装

16:28.220 --> 16:29.220
那么这个pnpx

16:29.220 --> 16:30.220
和npx

16:30.220 --> 16:32.220
他们的区别在哪呢

16:32.220 --> 16:36.300
就是这个pm

16:37.300 --> 16:39.300
就是npx和pmx

16:39.300 --> 16:40.300
区别在哪呢

16:40.300 --> 16:41.300
就这个区别

16:41.300 --> 16:42.300
就是什么区别呢

16:42.300 --> 16:43.300
唯一不同的就是

16:43.300 --> 16:45.300
如果说用pmx

16:45.300 --> 16:47.300
执行一个需要安装的命令的时候

16:47.300 --> 16:48.300
就是它执行的命令的过程中

16:48.300 --> 16:49.300
需要安装的时候

16:49.300 --> 16:51.300
它会用pm进行安装

16:51.300 --> 16:52.300
就这个区别

16:52.300 --> 16:53.300
其他没有什么区别

16:55.300 --> 16:57.300
这就是pmpm的简单使用

16:57.300 --> 16:58.300
特别简单

16:58.300 --> 16:59.300
你就是安装

16:59.300 --> 17:00.300
把pmpm安装下来

17:00.300 --> 17:01.300
之后就全部

17:02.300 --> 17:03.300
反而是安装包

17:03.300 --> 17:05.300
还是卸载包

17:05.300 --> 17:07.300
卸载包用remove

17:07.300 --> 17:08.300
都一样

17:08.300 --> 17:10.300
都用pmpm

17:10.300 --> 17:11.300
那么接下来

17:11.300 --> 17:13.300
我们来看简单的了解一下

17:13.300 --> 17:14.300
pmpm的原理

17:14.300 --> 17:15.300
详细的原理的话

17:15.300 --> 17:17.300
我打算放到下节课

17:17.300 --> 17:18.300
来详细的讲

17:18.300 --> 17:19.300
因为我觉得它挺有意思的

17:19.300 --> 17:21.300
不过下节课是一个扩展课程

17:21.300 --> 17:23.300
大家可以选择性的听

17:23.300 --> 17:25.300
我简单说一下它的原理

17:25.300 --> 17:26.300
它的原理

17:26.300 --> 17:28.300
它跟那个呀和pmpm一样

17:28.300 --> 17:29.300
它仍然使用缓存

17:29.300 --> 17:31.300
并且使用一个锁文件

17:31.300 --> 17:33.300
pmpmlog

17:33.300 --> 17:36.300
来记录详细的版本一代

17:36.300 --> 17:38.300
这跟呀和pmpm是一样的

17:38.300 --> 17:39.300
就没什么好说的了

17:39.300 --> 17:40.300
我这里简单说一下

17:40.300 --> 17:42.300
它的缓存在哪呢

17:42.300 --> 17:43.300
它的缓存在这

17:45.300 --> 17:47.300
由于比较特殊的原因

17:47.300 --> 17:48.300
具体什么样的特殊原因

17:48.300 --> 17:50.300
下节课你听了就明白了

17:50.300 --> 17:52.300
由于它比较特殊的原因

17:52.300 --> 17:53.300
所以说

17:55.300 --> 17:56.300
它的缓存在哪呢

17:56.300 --> 17:58.300
关键是看你的工程

17:58.300 --> 17:59.300
比方说你在这个工程

17:59.300 --> 18:00.300
在这个工程里面

18:00.300 --> 18:01.300
在这个地方

18:01.300 --> 18:02.300
你安装包

18:02.300 --> 18:04.300
那么你安装包的时候是不是要下载

18:04.300 --> 18:06.300
下载东西是不是要缓存起来

18:06.300 --> 18:08.300
那么你在这个工程里边

18:08.300 --> 18:09.300
你下载的包

18:09.300 --> 18:10.300
它在哪呢

18:10.300 --> 18:11.300
它在这个工程

18:11.300 --> 18:13.300
所在的盘的跟目录

18:14.300 --> 18:16.300
它不是一个固定的地方

18:16.300 --> 18:18.300
它是在这个工程

18:18.300 --> 18:20.300
所在盘的跟目录

18:20.300 --> 18:21.300
比方说它在哪里

18:21.300 --> 18:22.300
它的地盘

18:22.300 --> 18:23.300
因为这个工程在地盘

18:23.300 --> 18:24.300
对吧

18:24.300 --> 18:25.300
所以说它的缓存在哪里

18:25.300 --> 18:26.300
它的缓存在地盘

18:27.300 --> 18:28.300
看一下啊

18:28.300 --> 18:29.300
地盘哪个

18:29.300 --> 18:31.300
第二pmpmHengang Store

18:31.300 --> 18:32.300
在这里边

18:32.300 --> 18:33.300
你看

18:33.300 --> 18:34.300
这里边

18:34.300 --> 18:36.300
registrympmtaobao.org

18:36.300 --> 18:38.300
这是我们的registry路径

18:38.300 --> 18:39.300
registry的地址

18:39.300 --> 18:41.300
那么它这里建了个同名的文件夹

18:41.300 --> 18:43.300
所有的缓存在这里边

18:43.300 --> 18:44.300
比方说我们刚才用的

18:44.300 --> 18:45.300
安装了什么

18:45.300 --> 18:46.300
摩巧对吧

18:46.300 --> 18:47.300
看一下吧

18:47.300 --> 18:48.300
摩巧

18:48.300 --> 18:49.300
你看

18:49.300 --> 18:50.300
缓存在这

18:50.300 --> 18:52.300
如果说你后边

18:54.300 --> 18:55.300
如果说你后边

18:55.300 --> 18:56.300
同样在地盘里边

18:56.300 --> 18:58.300
去创建工程呀

18:58.300 --> 18:59.300
去安装包的时候呢

18:59.300 --> 19:00.300
他只要去发现

19:00.300 --> 19:02.300
这个根部路下面有这个东西

19:02.300 --> 19:03.300
那么他就会使用缓存

19:04.300 --> 19:05.300
至于他为什么不放

19:05.300 --> 19:06.300
一个固定的位置

19:06.300 --> 19:07.300
为什么这样做

19:07.300 --> 19:08.300
有他自己的原因

19:09.300 --> 19:10.300
因为他的实现方式

19:10.300 --> 19:12.300
跟Npm差异就比较大了

19:13.300 --> 19:14.300
这是第一个

19:14.300 --> 19:15.300
第二个就是

19:16.300 --> 19:17.300
可能有点看不懂

19:17.300 --> 19:18.300
夏济坷过就是

19:18.300 --> 19:19.300
着重讲这个东西

19:20.300 --> 19:22.300
他跟那个压痕Npm不太一样

19:23.300 --> 19:24.300
他觉得压痕Npm呢

19:24.300 --> 19:26.300
他有一个不好的点

19:26.300 --> 19:27.300
是什么点呢

19:27.300 --> 19:28.300
我给大家说一下

19:28.300 --> 19:30.300
就是Npm他为什么要做

19:30.300 --> 19:31.300
这个东西出来

19:31.300 --> 19:33.300
他一直觉得压痕Npm

19:33.300 --> 19:34.300
他始终没有解决一个问题

19:34.300 --> 19:37.300
就是多份包文件

19:37.300 --> 19:38.300
拷贝的问题

19:40.300 --> 19:41.300
什么意思

19:41.300 --> 19:42.300
我举个例子

19:43.300 --> 19:46.300
比方说我使用Npm也好

19:46.300 --> 19:48.300
或者是使用压也好

19:48.300 --> 19:50.300
我安装了一个什么安装了

19:50.300 --> 19:51.300
一个楼大喜

19:53.300 --> 19:56.300
安装了一个楼大喜

19:57.300 --> 19:58.300
比方说在某个工程

19:58.300 --> 19:59.300
哪个工程呢

19:59.300 --> 20:00.300
工程一

20:01.300 --> 20:03.300
工程一里边是安装了楼大喜

20:03.300 --> 20:04.300
安装了楼大喜

20:04.300 --> 20:06.300
那么楼大喜的文件夹在哪呢

20:06.300 --> 20:07.300
他的文件他是不是里面

20:07.300 --> 20:08.300
有很多的介石文件

20:08.300 --> 20:10.300
还有一些乱七八糟的数据

20:10.300 --> 20:11.300
还一些配置文件

20:11.300 --> 20:12.300
那么这些文件

20:13.300 --> 20:15.300
是不是会出现在工程一里面

20:15.300 --> 20:17.300
工程一里面是不是就有了一个

20:17.300 --> 20:18.300
楼大喜文件

20:19.300 --> 20:20.300
对不对

20:20.300 --> 20:21.300
是有了一个楼大喜文件夹

20:21.300 --> 20:22.300
他里面有很多文件

20:22.300 --> 20:24.300
同时由于他是第一次安装

20:24.300 --> 20:25.300
于是Npm也好

20:25.300 --> 20:26.300
Npm也好

20:26.300 --> 20:27.300
压也好

20:27.300 --> 20:28.300
他不会把他经济缓存

20:28.300 --> 20:30.300
在一个缓存目督里边

20:30.300 --> 20:32.300
是不是也会有一个楼大喜文件夹

20:33.300 --> 20:34.300
对吧

20:34.300 --> 20:35.300
那么目前是不是有两个

20:35.300 --> 20:36.300
两份文件夹

20:36.300 --> 20:37.300
没问题吧

20:38.300 --> 20:39.300
OK

20:39.300 --> 20:40.300
那将来有一天

20:40.300 --> 20:41.300
我们在工程二

20:41.300 --> 20:42.300
因为有些包呢

20:42.300 --> 20:43.300
他可能要反复使用

20:43.300 --> 20:44.300
工程二的时候

20:44.300 --> 20:46.300
也需要安装楼大喜

20:46.300 --> 20:47.300
安装楼大喜

20:47.300 --> 20:48.300
这个时候不用联网了

20:48.300 --> 20:49.300
他会怎么做呢

20:49.300 --> 20:51.300
他会把缓存文件夹

20:51.300 --> 20:52.300
里边的内容

20:52.300 --> 20:53.300
这个楼大喜文件夹

20:53.300 --> 20:54.300
直接可以考备过来

20:54.300 --> 20:55.300
只要版本一样

20:55.300 --> 20:57.300
前例条件是要版本一样

20:57.300 --> 20:58.300
只要版本不一样的话

20:58.300 --> 20:59.300
还要去下载新版本

20:59.300 --> 21:01.300
再把新版本缓存

21:01.300 --> 21:02.300
因为他缓存里边

21:02.300 --> 21:03.300
可以缓存很多版本

21:03.300 --> 21:04.300
那么如果说

21:04.300 --> 21:05.300
版本一样

21:05.300 --> 21:06.300
那么这个时候

21:06.300 --> 21:07.300
不会联网了

21:07.300 --> 21:09.300
第一次下载

21:09.300 --> 21:11.300
下载过后缓存

21:11.300 --> 21:12.300
然后工程一里边

21:12.300 --> 21:13.300
有这个文件夹

21:13.300 --> 21:14.300
那么第二次

21:14.300 --> 21:15.300
就是用缓存

21:15.300 --> 21:17.300
使用缓存

21:17.300 --> 21:19.300
怎么使用的

21:19.300 --> 21:21.300
考备过来的

21:21.300 --> 21:23.300
如果说你以后

21:23.300 --> 21:25.300
工程三

21:25.300 --> 21:27.300
是不是也是要这样做

21:27.300 --> 21:28.300
工程四也是要这样做

21:28.300 --> 21:29.300
大家想一想

21:29.300 --> 21:31.300
这个东西有什么问题呢

21:31.300 --> 21:32.300
第一个问题

21:32.300 --> 21:33.300
也在硬盘里边

21:33.300 --> 21:35.300
是不是就有很多份

21:35.300 --> 21:37.300
相同的楼大喜文件夹

21:37.300 --> 21:39.300
是不是有很多相同的楼大喜包

21:39.300 --> 21:41.300
对吧

21:41.300 --> 21:42.300
白白的占用了

21:42.300 --> 21:43.300
很多的内存

21:43.300 --> 21:44.300
也就是不是内存

21:44.300 --> 21:45.300
硬盘空间

21:45.300 --> 21:47.300
虽然硬盘很便宜

21:47.300 --> 21:48.300
但是如果说

21:48.300 --> 21:49.300
包一多了

21:49.300 --> 21:50.300
到后边一多了

21:50.300 --> 21:52.300
就是也蛮浪费空间的

21:52.300 --> 21:54.300
另外呢

21:54.300 --> 21:56.300
这个考备要不要时间

21:56.300 --> 21:57.300
我们说过

21:57.300 --> 21:58.300
考备其实在复制什么呢

21:58.300 --> 22:00.300
就是一个一个文件数据

22:00.300 --> 22:01.300
要复制过来

22:01.300 --> 22:02.300
那么还要复制什么

22:02.300 --> 22:03.300
还要复制目录

22:03.300 --> 22:05.300
如果说文件一多

22:05.300 --> 22:07.300
而且文件内容一多

22:07.300 --> 22:08.300
现在我们只有一个包

22:08.300 --> 22:09.300
那很多个包

22:09.300 --> 22:10.300
是同样的道理对吧

22:10.300 --> 22:11.300
比方说工程二

22:11.300 --> 22:12.300
一代的一百个

22:12.300 --> 22:14.300
直接或者间接一代的

22:14.300 --> 22:16.300
一千个包

22:16.300 --> 22:17.300
有没有可能

22:17.300 --> 22:18.300
百分之百有可能吧

22:18.300 --> 22:19.300
以后随便开发的一个项目

22:19.300 --> 22:21.300
随便都是一千多个

22:21.300 --> 22:22.300
如果说工程二直接

22:22.300 --> 22:24.300
会间接一代的一千多个包

22:24.300 --> 22:25.300
那么是不是要从缓存里面

22:25.300 --> 22:26.300
考备一千多个包进来

22:26.300 --> 22:28.300
这个考备的速度也挺慢的

22:28.300 --> 22:29.300
也挺慢的

22:29.300 --> 22:30.300
那么他就是

22:30.300 --> 22:31.300
PMM呢

22:31.300 --> 22:32.300
他就觉得

22:32.300 --> 22:34.300
这种方式

22:34.300 --> 22:36.300
这种方式就存在这样的问题

22:36.300 --> 22:37.300
虽然说你用了缓存

22:37.300 --> 22:38.300
但这里还是速度慢

22:38.300 --> 22:40.300
因为你要考备

22:40.300 --> 22:41.300
那么PMM怎么做的呢

22:41.300 --> 22:44.300
他是使用符号和硬�接

22:44.300 --> 22:46.300
那么这个符号和硬�接

22:46.300 --> 22:48.300
这是什么东西呢

22:48.300 --> 22:49.300
你可以简单的

22:49.300 --> 22:50.300
目前你可以简单

22:50.300 --> 22:52.300
把它想象成快捷方式

22:52.300 --> 22:54.300
他用的是快捷方式

22:54.300 --> 22:56.300
什么叫快捷方式呢

22:56.300 --> 22:59.300
随便找个例子吧

22:59.300 --> 23:01.300
然后这里右键

23:01.300 --> 23:04.300
发送到桌面快捷方式

23:04.300 --> 23:05.300
那是不是桌面上

23:05.300 --> 23:07.300
有这个文件夹的考备呢

23:07.300 --> 23:08.300
没有

23:08.300 --> 23:10.300
桌面上的指示

23:10.300 --> 23:12.300
有一个快捷方式

23:12.300 --> 23:13.300
通过这个快捷方式

23:13.300 --> 23:15.300
可以快速的进入这个文件

23:15.300 --> 23:18.300
可以快速的进入这个路径

23:18.300 --> 23:19.300
原来的意思吗

23:19.300 --> 23:21.300
它只是一个快捷方式而已

23:21.300 --> 23:22.300
你把快捷方式删了

23:22.300 --> 23:24.300
它并不代表这里面有文件

23:24.300 --> 23:25.300
并不代表这里面有文件

23:25.300 --> 23:28.300
它只是个快捷方式

23:28.300 --> 23:29.300
所以说呢

23:29.300 --> 23:31.300
PMM类似于这种做法

23:31.300 --> 23:32.300
但它不是快捷方式

23:32.300 --> 23:33.300
这个东西是我们下节课

23:33.300 --> 23:35.300
要讲的符号链接和硬链接

23:35.300 --> 23:38.300
这相当于是Ulic是操作系统的东西了

23:38.300 --> 23:40.300
下节课我们是个扩展课

23:40.300 --> 23:41.300
慢慢说

23:41.300 --> 23:43.300
因为它使用的是这个两个

23:43.300 --> 23:44.300
它的做法是怎么做的

23:44.300 --> 23:45.300
它是这样做的

23:45.300 --> 23:49.060
PMM的做法

23:49.060 --> 23:51.060
同样的道理

23:51.060 --> 23:53.060
我们还是以这个为例

23:53.060 --> 23:55.060
如果说工程1

23:55.060 --> 23:57.060
第一次下载楼大喜

23:57.060 --> 23:59.060
它下不下来在这呢

23:59.060 --> 24:00.060
它根本就不下来在这

24:00.060 --> 24:01.060
它下来在那

24:01.060 --> 24:02.060
它直接下来到缓存

24:02.060 --> 24:03.060
它发现缓存里面没有

24:03.060 --> 24:05.060
它直接下来到缓存

24:05.060 --> 24:07.060
然后这里放什么呢

24:07.060 --> 24:10.060
这里只放的是一个快捷方式

24:10.060 --> 24:11.060
快捷方式你可以认为

24:11.060 --> 24:13.060
它几乎不占用任何的硬盘空间

24:13.060 --> 24:14.060
它只是这个东西

24:14.060 --> 24:16.060
指向缓存里面的这个位置

24:16.060 --> 24:18.060
明白这里是吧

24:18.060 --> 24:20.060
目前你就这样理解

24:20.060 --> 24:21.060
它不是快捷方式

24:21.060 --> 24:22.060
它到底是什么东西

24:22.060 --> 24:23.060
我们下节课再说

24:23.060 --> 24:25.060
它就这样做

24:25.060 --> 24:26.060
那么工程2呢

24:26.060 --> 24:28.060
它也是只间接一个快捷方式

24:28.060 --> 24:29.060
对吧

24:29.060 --> 24:30.060
工程3呢

24:30.060 --> 24:32.060
只间接一个快捷方式

24:32.060 --> 24:33.060
你会发现

24:33.060 --> 24:36.060
在用PMM的时候呢

24:36.060 --> 24:38.060
整个系统里边

24:38.060 --> 24:40.060
整个磁盘里边

24:40.060 --> 24:41.060
所有的包只有一份

24:41.060 --> 24:43.060
哪怕1000个工程

24:43.060 --> 24:45.060
每个工程都要用到楼大喜

24:45.060 --> 24:47.060
楼大喜我只在缓存里边有一份

24:47.060 --> 24:48.060
其他地方全是快捷方式

24:48.060 --> 24:50.060
不占用硬盘空间的

24:50.060 --> 24:51.060
而且快捷方式

24:51.060 --> 24:54.060
这种方式的复制

24:54.060 --> 24:56.060
这种方式的复制就比较拷贝了

24:56.060 --> 24:59.060
叫做建立链接

24:59.060 --> 25:01.060
建立链接

25:01.060 --> 25:06.200
建立链接

25:06.200 --> 25:08.200
所以它这个东西比较拷贝了

25:08.200 --> 25:10.200
因此它这个速度要快得多

25:10.200 --> 25:12.200
要比那个拷贝文件快得多

25:12.200 --> 25:15.200
可以对比一下左右两种方式

25:15.200 --> 25:18.200
它是用这种模式来做的

25:18.200 --> 25:20.200
而且另外呢

25:20.200 --> 25:23.200
它由于使用了这种模式

25:23.200 --> 25:25.200
它就规避了之前的那个问题

25:25.200 --> 25:26.200
到底是怎么规定的

25:26.200 --> 25:28.200
我们下一课详细说

25:28.200 --> 25:30.200
它就规避了之前的那个问题

25:30.200 --> 25:31.200
什么问题呢

25:31.200 --> 25:33.200
就是Windows操作系统

25:33.200 --> 25:35.200
路径过长的问题

25:35.200 --> 25:36.200
我们之前说过

25:36.200 --> 25:37.200
在那个NPM的时候呢

25:37.200 --> 25:38.200
以前它就是

25:38.200 --> 25:39.200
追找的时候

25:39.200 --> 25:41.200
它就是用这种方式来做的

25:42.200 --> 25:43.200
A依赖B

25:43.200 --> 25:45.200
那么B放到A下面

25:45.200 --> 25:46.200
B依赖C

25:46.200 --> 25:48.200
C放到B下面

25:48.200 --> 25:50.200
它以前是不是用这种方式来做的

25:50.200 --> 25:52.200
用这种模式来做的

25:52.200 --> 25:55.200
那么D有依赖

25:55.200 --> 25:57.200
B它就这样子放的

25:57.200 --> 25:58.200
那么这样子放

25:58.200 --> 25:59.200
它是不是之前说过有两个问题

25:59.200 --> 26:00.200
第一个问题呢

26:00.200 --> 26:01.200
是不是有包的重复

26:01.200 --> 26:02.200
重复的

26:02.200 --> 26:04.200
有很多重复的内容

26:04.200 --> 26:05.200
但是如果说

26:05.200 --> 26:06.200
你使用了快捷方式

26:06.200 --> 26:07.200
这两个地方都是快捷方式

26:07.200 --> 26:09.200
它不存在重复的内容

26:09.200 --> 26:10.200
所以就规避了这样的问题

26:10.200 --> 26:11.200
另外呢

26:11.200 --> 26:12.200
以前呢

26:12.200 --> 26:13.200
是不是导致路径过长的问题

26:13.200 --> 26:14.200
那么路径过长的问题呢

26:14.200 --> 26:15.200
使用这个东西过后呢

26:15.200 --> 26:16.200
它也可以规避

26:16.200 --> 26:17.200
具体怎么回事呢

26:17.200 --> 26:18.200
我们下一个再说

26:19.200 --> 26:21.200
因此它规避了这个东西过后呢

26:21.200 --> 26:23.200
它就又把它还原成

26:23.200 --> 26:24.200
数形的依赖结果了

26:24.200 --> 26:26.200
又把它还原成这种数结构了

26:26.200 --> 26:28.200
数结构有个好处在于什么呢

26:28.200 --> 26:30.200
比方说你安装A这个包的时候

26:30.200 --> 26:31.200
你会发现

26:31.200 --> 26:33.200
你的目录下面只有A

26:33.200 --> 26:34.200
在A下面才有B

26:34.200 --> 26:35.200
才有C

26:35.200 --> 26:37.200
它就会形成这么一种关系

26:37.200 --> 26:38.200
这种关系呢

26:38.200 --> 26:39.200
要比什么呢

26:39.200 --> 26:41.200
就是把它拍扁这种结构

26:41.200 --> 26:42.200
要好得多

26:42.200 --> 26:44.200
从逻辑上来说要好得多

26:44.200 --> 26:46.200
以前的之所以不能不这样

26:46.200 --> 26:47.200
NPM之所以不这样做呢

26:47.200 --> 26:49.200
是因为考虑到这个重复的问题

26:49.200 --> 26:51.200
但是它可以用

26:51.200 --> 26:52.200
快捷方式来解决

26:52.200 --> 26:54.200
另外它考虑到就是

26:54.200 --> 26:55.200
长路径的问题

26:55.200 --> 26:56.200
那么长路径呢

26:56.200 --> 26:57.200
也可以

26:57.200 --> 26:58.200
这个问题

26:58.200 --> 26:59.200
就是也可以用快捷方式

26:59.200 --> 27:00.200
类似于快捷方式的这种方式

27:00.200 --> 27:02.200
解决这个长路径的问题

27:03.200 --> 27:04.200
有些人说

27:04.200 --> 27:05.200
那既然这么好的东西

27:05.200 --> 27:07.200
为什么NPM现在没有用了

27:08.200 --> 27:10.200
没有那么简单的

27:10.200 --> 27:11.200
因为它一旦使用了

27:11.200 --> 27:12.200
这个东西过程

27:12.200 --> 27:13.200
它会带来一些新的问题

27:13.200 --> 27:15.200
咱们下节课就可以看到

27:16.200 --> 27:17.200
因此它使用了

27:17.200 --> 27:18.200
这种方式过程

27:18.200 --> 27:19.200
它就选择了使用

27:19.200 --> 27:20.200
又回到之前的那种

27:20.200 --> 27:21.200
塑形的依赖

27:21.200 --> 27:23.200
保存塑形的目录结构

27:23.200 --> 27:24.200
我觉得这种结构

27:24.200 --> 27:26.200
那么有这几乎完美的依赖管理

27:26.200 --> 27:27.200
这种依赖管理

27:27.200 --> 27:28.200
好处在于什么

27:28.200 --> 27:30.200
你只能使用直接依赖

27:30.200 --> 27:32.200
而不能使用间接依赖

27:32.200 --> 27:33.200
将我们刚才演示的

27:33.200 --> 27:34.200
你在TES的里边

27:34.200 --> 27:35.200
你只能使用

27:35.200 --> 27:36.200
你安装了摩墙

27:36.200 --> 27:37.200
你只能使用摩墙

27:37.200 --> 27:38.200
你不能使用摩墙

27:38.200 --> 27:39.200
间接依赖的东西

27:39.200 --> 27:41.200
因为它形成了这种结构了

27:44.200 --> 27:45.200
最后我们说一下

27:45.200 --> 27:46.200
PNPM的注意事项

27:46.200 --> 27:48.200
说了这么多好处

27:51.200 --> 27:53.200
那么它有没有不好的地方

27:53.200 --> 27:54.200
实际上我觉得

27:54.200 --> 27:56.200
我是这样理解的

27:56.200 --> 27:57.200
PNPM

27:57.200 --> 27:59.200
它本身没有什么不好的地方

27:59.200 --> 28:02.200
目前的所有保管理工具里边

28:02.200 --> 28:05.200
PNPM应该是做得最完美的

28:05.200 --> 28:06.200
那为什么

28:07.200 --> 28:08.200
这里还要注意事项呢

28:08.200 --> 28:11.200
是因为别人不完美

28:11.200 --> 28:13.200
这个世界不完美

28:13.200 --> 28:15.200
导致了它太完美了

28:15.200 --> 28:16.200
导致了它用起来了

28:16.200 --> 28:17.200
还是有些问题

28:17.200 --> 28:19.200
因为这个世界不完美

28:19.200 --> 28:21.200
因为它呢

28:21.200 --> 28:23.200
你使用PNPM过后

28:23.200 --> 28:24.200
你会导致你的

28:24.200 --> 28:27.200
每一个保只能使用直接依赖

28:27.200 --> 28:29.200
不能使用间接依赖

28:30.200 --> 28:31.200
那么这个时候

28:31.200 --> 28:33.200
如果说你安装的包

28:33.200 --> 28:34.200
它不完美

28:34.200 --> 28:35.200
那就要出问题

28:35.200 --> 28:36.200
什么意思

28:36.200 --> 28:37.200
我举个例子

28:38.200 --> 28:39.200
比如说

28:39.200 --> 28:41.200
我的工程

28:41.200 --> 28:43.200
工程名字叫ABC

28:43.200 --> 28:44.200
它依赖哪个包呢

28:44.200 --> 28:46.200
它依赖A这个包

28:46.200 --> 28:48.200
A这个包依赖哪个包呢

28:48.200 --> 28:50.200
依赖B这个包

28:51.200 --> 28:52.200
依赖B这个包

28:52.200 --> 28:53.200
好B这个包依赖哪个包呢

28:53.200 --> 28:54.200
依赖C这个包

28:54.200 --> 28:56.200
用工程师来举个例子

28:56.200 --> 28:57.200
你马上就明白了

28:57.200 --> 28:59.200
那么如果说

28:59.200 --> 29:01.200
看一下以前

29:01.200 --> 29:03.200
以前的NPM时代的做法

29:03.200 --> 29:04.200
我们

29:04.200 --> 29:06.200
通过我们的工程去安装A这个包

29:06.200 --> 29:09.200
它是不是在Node

29:09.200 --> 29:11.200
Margeus目录下边

29:11.200 --> 29:13.200
就会产生什么A

29:13.200 --> 29:14.200
B

29:14.200 --> 29:16.200
是不是会产生这么一种结构

29:16.200 --> 29:17.200
C

29:17.200 --> 29:18.200
那么我们的工程里边

29:18.200 --> 29:19.200
以前的NPM的时候

29:19.200 --> 29:20.200
我们的工程里边

29:20.200 --> 29:23.200
是不是可以RequireA

29:23.200 --> 29:24.200
是不是也

29:24.200 --> 29:25.200
当然肯定是小型

29:25.200 --> 29:26.200
不可能有大型

29:26.200 --> 29:28.200
RequireB

29:28.200 --> 29:30.200
所以可以这样做

29:30.200 --> 29:31.200
虽然说我们直接

29:31.200 --> 29:32.200
一代的指示A

29:32.200 --> 29:34.200
但是我们是不是可以用B

29:34.200 --> 29:35.200
我们可以

29:35.200 --> 29:37.200
其他的包也可以

29:37.200 --> 29:39.200
你可以想象一下

29:39.200 --> 29:41.200
在开发A这个包的人

29:41.200 --> 29:45.540
开发A包的人

29:45.540 --> 29:47.910
他在做什么

29:47.910 --> 29:48.910
他要一看

29:48.910 --> 29:50.910
我们现在开发的是A这个包

29:50.910 --> 29:51.910
那么我们是不是要

29:51.910 --> 29:52.910
依赖B

29:52.910 --> 29:53.910
是不是安装B

29:53.910 --> 29:54.910
那么它的NodeMargeus目录

29:54.910 --> 29:55.910
下面是什么样子

29:55.910 --> 29:57.910
是不是有一个B

29:57.910 --> 29:58.910
有一个C

29:58.910 --> 29:59.910
对吧

29:59.910 --> 30:00.910
那么如果说

30:00.910 --> 30:02.910
开发A包的人

30:03.910 --> 30:05.910
比较谨慎

30:05.910 --> 30:06.910
比较符合规范

30:06.910 --> 30:07.910
那么他可能

30:07.910 --> 30:09.910
他只会用到RequireB

30:09.910 --> 30:10.910
为什么

30:10.910 --> 30:11.910
因为他直接一代的指右B

30:11.910 --> 30:12.910
对吧

30:12.910 --> 30:13.910
他不会用C

30:13.910 --> 30:14.910
但是很遗憾的是

30:14.910 --> 30:16.910
有可能开发A包的过程中

30:16.910 --> 30:17.910
他确实要用到C

30:17.910 --> 30:18.910
但是呢

30:18.910 --> 30:20.910
又懒得在Packet.js里面去加了

30:20.910 --> 30:21.910
又懒得重新安装一次

30:21.910 --> 30:22.910
因为他觉得

30:22.910 --> 30:23.910
我安装B的时候

30:23.910 --> 30:24.910
就已经安装C了

30:24.910 --> 30:25.910
我懒得重新安装了

30:25.910 --> 30:27.910
他可能会写出这个代码

30:27.910 --> 30:28.910
那么会写出

30:28.910 --> 30:29.910
这个代码过后呢

30:29.910 --> 30:31.910
你想想这个道理

30:31.910 --> 30:32.910
如果说A包里边

30:32.910 --> 30:34.910
有这种代码存在

30:34.910 --> 30:36.910
那么会导致一个什么结果了

30:36.910 --> 30:37.910
会导致

30:37.910 --> 30:38.910
如果说我们的工程

30:38.910 --> 30:39.910
在使用A包的时候

30:39.910 --> 30:40.910
就要出问题

30:40.910 --> 30:41.910
比如说出什么问题

30:41.910 --> 30:43.910
现在我们把它换成

30:43.910 --> 30:44.910
把它换成

30:44.910 --> 30:45.910
我们的工程

30:45.910 --> 30:46.910
我们的工程

30:46.910 --> 30:47.910
把它换成Pnpm

30:47.910 --> 30:49.910
那么他安装出来是这种结构

30:49.910 --> 30:50.910
A

30:52.910 --> 30:53.910
但是严格来说

30:53.910 --> 30:54.910
也不是这种结构

30:54.910 --> 30:56.910
我们简单的这样的理解

30:57.910 --> 30:58.910
那么这个时候呢

30:58.910 --> 31:00.910
我们去使用A包的时候

31:00.910 --> 31:02.910
你看一下会不会出问题

31:02.910 --> 31:03.910
因为A这个包里边

31:03.910 --> 31:04.910
它用到了什么

31:04.910 --> 31:05.910
用到了C

31:05.910 --> 31:07.910
而A里边能不能用C

31:07.910 --> 31:08.910
能不能用C

31:08.910 --> 31:09.910
A里边代码

31:09.910 --> 31:10.910
它只能

31:10.910 --> 31:11.910
A里边它一个node margin

31:11.910 --> 31:12.910
它里边只有B

31:12.910 --> 31:13.910
它没有C

31:13.910 --> 31:14.910
它找不到C

31:14.910 --> 31:15.910
它找不到C

31:15.910 --> 31:18.910
就跟我们找不到B和C一样

31:18.910 --> 31:19.910
懂这个意思吗

31:19.910 --> 31:21.910
所以说由于这些

31:21.910 --> 31:22.910
第三方的包

31:22.910 --> 31:23.910
它可能去写一些

31:23.910 --> 31:25.910
这种类似的代码

31:26.910 --> 31:28.910
写这种类似的代码出来

31:28.910 --> 31:29.910
甚至有些包里边

31:29.910 --> 31:31.910
还可能给写这种代码

31:32.910 --> 31:33.910
还可能给写这种代码出来

31:33.910 --> 31:35.910
给写绝对路径

31:35.910 --> 31:37.910
node margin

31:37.910 --> 31:38.910
下面哪个哪个包

31:38.910 --> 31:39.910
它都没有

31:39.910 --> 31:40.910
它都没有去直接依赖

31:40.910 --> 31:41.910
它就是看别人依赖了

31:41.910 --> 31:42.910
间接依赖它

31:42.910 --> 31:43.910
它就这样子写

31:43.910 --> 31:44.910
它可以写出这样的代码

31:44.910 --> 31:45.910
它更加是

31:45.910 --> 31:47.910
是不是更加用不了了

31:47.910 --> 31:48.910
所以说Npm的本身

31:48.910 --> 31:49.910
它没有什么太大的问题

31:49.910 --> 31:50.910
主要是其他的包

31:50.910 --> 31:52.910
它没有按照规范来写

31:52.910 --> 31:53.910
导致了很多包

31:53.910 --> 31:54.910
在Pnpm里边

31:54.910 --> 31:55.910
里边用不了

31:55.910 --> 31:57.910
好像是它自己的问题

31:57.910 --> 31:58.910
根本不是它的问题

31:58.910 --> 31:59.910
是别人写包的时候

31:59.910 --> 32:01.910
不按照规范来写的问题

32:02.910 --> 32:03.910
所以说

32:03.910 --> 32:04.910
Ns用Pnpm的时候

32:04.910 --> 32:06.910
如果说你安装的包中

32:06.910 --> 32:08.910
包含间接依赖

32:08.910 --> 32:10.910
就像A里边

32:10.910 --> 32:11.910
本来它只能用B的

32:11.910 --> 32:12.910
这个包里边

32:12.910 --> 32:14.910
它跑去用了C

32:14.910 --> 32:15.910
这叫间接依赖

32:15.910 --> 32:16.910
那么这样的包

32:16.910 --> 32:17.910
是不规范的

32:17.910 --> 32:18.910
那么用这些不规范的包

32:18.910 --> 32:19.910
就会出问题

32:20.910 --> 32:23.910
那么我们目前Pnpm

32:23.910 --> 32:26.910
由于它的好处太显而易见了

32:26.910 --> 32:27.910
所以说

32:27.910 --> 32:29.910
目前很多的比较流行的包

32:29.910 --> 32:30.910
都开始在修正

32:30.910 --> 32:31.910
之前的依赖

32:31.910 --> 32:33.910
这种间接依赖赖马了

32:33.910 --> 32:35.910
不过到目前的

32:35.910 --> 32:36.910
用Pnpm的

32:36.910 --> 32:38.910
还是不是特别保险

32:38.910 --> 32:41.910
因为你可能也很

32:41.910 --> 32:42.910
因为我们平时

32:42.910 --> 32:43.910
要开发一个大型项目

32:43.910 --> 32:45.910
要安装很多很多的包

32:45.910 --> 32:46.910
从来发现一个包

32:46.910 --> 32:47.910
用不了了

32:47.910 --> 32:48.910
又没有什么可以替代的

32:48.910 --> 32:49.910
这个时候就麻烦了

32:49.910 --> 32:50.910
利用Pnpm就麻烦了

32:50.910 --> 32:52.910
所以说谨慎使用

32:53.910 --> 32:55.910
我觉得再给他一点

32:55.910 --> 32:56.910
也不是给他一点时间

32:56.910 --> 32:57.910
再给别人

32:57.910 --> 32:59.910
再给这个世界一点时间

32:59.910 --> 33:01.910
让他们慢慢变得完美吧

33:01.910 --> 33:03.910
这是关于Pnpm

33:03.910 --> 33:06.910
它本来是个很好的东西

33:07.910 --> 33:08.910
那么下节课

33:08.910 --> 33:09.910
我们来说一下

33:09.910 --> 33:10.910
就是一个扩展课程

33:10.910 --> 33:12.910
说一下它里边的详细的原理

33:12.910 --> 33:14.910
我觉得那部分也挺有意思的

33:14.910 --> 33:15.910
虽然说

33:15.910 --> 33:17.910
它只是一个扩展课程

