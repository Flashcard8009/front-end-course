WEBVTT

00:00.430 --> 00:04.830
好了 这节课呢 时间可能会稍微有点长啊

00:04.830 --> 00:08.230
也稍微有那么一丢丢的难度

00:08.230 --> 00:12.430
因为这节课呢 我们会讲一些伍佑的基本原理

00:12.430 --> 00:14.830
但是呢 大家放心啊 不会讲得很深

00:14.830 --> 00:19.430
因为我们毕竟是入门阶段嘛 所以说我们还是以实现效果为目标

00:19.430 --> 00:21.830
但是呢 你要去实现效果

00:21.830 --> 00:24.630
你也不能说完全不知道原理

00:24.630 --> 00:28.030
因为你完全不知道原理的话 你写的代码是啥你都不知道

00:28.030 --> 00:30.830
当然是有些朋友说那我跟着老师写行不行呢

00:30.830 --> 00:33.230
那倒是可以 老师写啥你写啥

00:33.230 --> 00:35.830
那写出来过后也没意义啊 你又理解不了

00:35.830 --> 00:40.230
所以说呢 我们还是多多少少得知道一点点原理啊 不会太深

00:40.230 --> 00:46.230
主要的目标呢 是要让大家知道我们写出来的代码到底写的是个啥

00:46.230 --> 00:49.030
好 我们这里一步步说

00:49.030 --> 00:51.030
首先呢 我们上级课的代码在这儿了对吧

00:51.030 --> 00:53.430
对了 我说一下啊 上级课的代码啊

00:53.430 --> 00:57.030
反而是我们课堂上涉及到了老师写的一些效果啊

00:58.030 --> 01:02.030
一些案例啊 一些代码 大家一定要跟着写一遍

01:02.030 --> 01:05.030
你不写一遍 这个学习效果是特别特别的差

01:05.030 --> 01:09.030
很多同学呢 学到后边都不知道老师在讲啥了

01:09.030 --> 01:13.030
很大程度的原因呢 都是因为前期没有跟着老师一起做

01:13.030 --> 01:16.030
一定要去写一遍啊 有点印象

01:16.030 --> 01:19.030
好 咱们上级课呢 写的简单一段代码

01:19.030 --> 01:22.030
那么这段代码里边呢 有些东西我需要解释一下

01:22.030 --> 01:24.030
首先这个玩意我说过了 这个玩意是啥呀

01:24.030 --> 01:27.030
这个实力对吧 创建了一个无忧的实力

01:27.030 --> 01:31.030
那么这个实力里边会有一些属性啊 有些方法对不对

01:31.030 --> 01:34.030
我们当时还演示过 这个实力里边是不是有这个title

01:34.030 --> 01:37.030
有这个实力里边是不是有这个products

01:37.030 --> 01:40.030
那是怎么回事呢 咱们来看一下第1个概念

01:40.030 --> 01:45.660
叫做课件里边啊 叫做注入

01:46.660 --> 01:48.660
啥叫注入呢 大家看这个图啊

01:48.660 --> 01:51.660
我们当时是不是创建了一个6的一个无忧啊

01:51.660 --> 01:53.660
是不是创建了一个无忧的实力

01:53.660 --> 01:56.660
那么这就是争承了一个无忧的实力对象

01:56.660 --> 01:59.660
这个对象里边它本身自带了一些成员

01:59.660 --> 02:02.660
就是无忧这个框架给我们加的一些成员

02:02.660 --> 02:04.660
那么我们来看一下这些成员啊

02:04.660 --> 02:06.660
我们把这个浏览器打开

02:06.660 --> 02:08.660
上级课呢

02:09.660 --> 02:12.660
点击右键的检查 到这个控制台里边去

02:12.660 --> 02:14.660
我们来看一下这个VM 就是无忧的实力

02:14.660 --> 02:18.660
打开看一下 它里边是不是有很多很多的成员啊

02:18.660 --> 02:21.660
它不仅仅是有什么title对吧

02:22.660 --> 02:25.660
有这个total stock 不仅仅有这些

02:25.660 --> 02:27.660
还有一些其他的成员

02:27.660 --> 02:29.660
那么这些成员呢 我们把它分成三个部分

02:29.660 --> 02:32.660
第一个部分呢 是以多了这个符号开头的

02:32.660 --> 02:35.660
你看这边啊 是不是有很多的成员

02:35.660 --> 02:37.660
有些是属性 有些是方法

02:37.660 --> 02:39.660
它是以多了开头的 对吧

02:39.660 --> 02:42.660
那么这些成员呢 是无忧提供给你

02:42.660 --> 02:45.660
一些使用的方法啊 一些使用的属性

02:45.660 --> 02:47.660
那么这些玩意呢 我们以后

02:47.660 --> 02:49.660
讲到的时候 需要用到的时候呢

02:49.660 --> 02:51.660
再给大家说 总之这里知道

02:51.660 --> 02:53.660
这个实力里边有这么一些方法

02:53.660 --> 02:54.660
是无忧给你提供的

02:54.660 --> 02:57.660
它是以多了开头的 方便你使用的

02:57.660 --> 02:59.660
现在还用不到

02:59.660 --> 03:03.660
然后呢 还有一些呢 是以下滑线开头的

03:03.660 --> 03:05.660
看那边 你看这里边啊

03:05.660 --> 03:07.660
所以有很多还用下滑线开头的

03:07.660 --> 03:10.660
那么以下滑线开头呢 是无忧内部使用的成员

03:10.660 --> 03:13.660
有些属性啊 有些方法是内部使用的

03:13.660 --> 03:15.660
不建议你去使用它

03:15.660 --> 03:17.660
平时开放那里肯定用不到它

03:17.660 --> 03:18.660
也不建议你去使用它

03:18.660 --> 03:20.660
所以这个东西的了解一下就完事了

03:20.660 --> 03:21.660
这个东西是我们要用的

03:21.660 --> 03:23.660
这个东西呢 是不要理用的

03:23.660 --> 03:25.660
但它存在

03:25.660 --> 03:27.660
然后呢 第三个部分呢 就这一部分

03:27.660 --> 03:30.660
这一部分哪来的呢 这一部分成员

03:30.660 --> 03:32.660
是根据我们的配置对象

03:32.660 --> 03:34.660
我们窗戒无忧的时候 不是有配置对象吗

03:34.660 --> 03:36.660
配置对象里边是不是有这么data啊

03:36.660 --> 03:37.660
computed的对吧

03:37.660 --> 03:40.660
我们这几课呢 会说一下这个data

03:40.660 --> 03:43.660
computed的那么以后再说

03:43.660 --> 03:45.660
但是我们上几课遇到了对吧

03:45.660 --> 03:47.660
像我们这有一些配置啊

03:47.660 --> 03:48.660
某一些配置

03:48.660 --> 03:51.660
它会提取到无忧实力里边去

03:51.660 --> 03:54.660
对吧 它相当于是从这个对象里边

03:54.660 --> 03:56.660
这个配置对象里边

03:56.660 --> 03:59.660
给它提到了哪呢 提到这里边去了

03:59.660 --> 04:00.660
那么这个工作呢

04:00.660 --> 04:02.660
是它在构造函数里面去完成的

04:02.660 --> 04:04.660
这个这个过程呢 叫做注入

04:04.660 --> 04:06.660
什么叫注入呢 其实也很好理解

04:06.660 --> 04:08.660
就是把一些配置啊

04:08.660 --> 04:09.660
一些特殊的配置

04:09.660 --> 04:10.660
像这个data配置

04:10.660 --> 04:11.660
computed的配置

04:11.660 --> 04:12.660
和method的配置

04:12.660 --> 04:14.660
有些特殊的配置里边的成员呢

04:14.660 --> 04:17.660
把它放到了无忧实力里边去了

04:17.660 --> 04:19.660
看到没 这叫注入

04:19.660 --> 04:20.660
好 咱们来看一下啊

04:20.660 --> 04:21.660
浏览器里边

04:21.660 --> 04:23.660
我们刚才打印出来的这个无忧实力

04:23.660 --> 04:26.660
你看一下这边 是不是有product

04:26.660 --> 04:28.660
哪来的 注入进来的

04:28.660 --> 04:30.660
从哪里注入进来的

04:30.660 --> 04:31.660
是不是从这里注入进来的

04:31.660 --> 04:33.660
data配置里边注入进来的

04:33.660 --> 04:35.660
看到没 还有什么这个dnet product

04:35.660 --> 04:37.660
是一个方法对吧

04:37.660 --> 04:38.660
这个玩意哪来的

04:38.660 --> 04:40.660
是不是从method里边注入进来的

04:40.660 --> 04:41.660
对吧 也就是说

04:41.660 --> 04:43.660
它会从我们配置里面

04:43.660 --> 04:45.660
有一些地方提取出来

04:45.660 --> 04:47.660
注入到无忧实力里边去

04:47.660 --> 04:49.660
这叫注入

04:49.660 --> 04:51.660
那么大家想一个问题啊

04:51.660 --> 04:53.660
我现在大家发挥一下想象力

04:53.660 --> 04:55.660
为什么

04:55.660 --> 04:58.660
无忧它自带的一些东西

04:58.660 --> 05:00.660
它要以多的开头

05:00.660 --> 05:02.660
或者是以下滑线开头

05:02.660 --> 05:04.660
为什么

05:04.660 --> 05:06.660
你觉得为啥

05:06.660 --> 05:08.660
是不是防止重明啊

05:08.660 --> 05:09.660
因为你注入的时候

05:09.660 --> 05:10.660
是不是会注入一些

05:10.660 --> 05:12.660
到无忧实力里边去

05:12.660 --> 05:14.660
对吧 如果说你注入的东西跟那个

05:14.660 --> 05:16.660
它以前成员重明了

05:16.660 --> 05:18.660
是不是不好办了

05:18.660 --> 05:20.660
因此它为了便于区分

05:20.660 --> 05:22.660
它自己给你提供的东西呢

05:22.660 --> 05:23.660
有一些特殊的符号开头

05:23.660 --> 05:24.660
就是为了避免

05:24.660 --> 05:26.660
与注入的内容重明

05:26.660 --> 05:28.660
是这么的意思

05:28.660 --> 05:30.660
这是注入

05:30.660 --> 05:31.660
那么我们目前呢

05:31.660 --> 05:32.660
接触到的注入呢

05:32.660 --> 05:33.660
有三个配置会注入

05:33.660 --> 05:34.660
会被注入

05:34.660 --> 05:35.660
哪三个配置呢

05:35.660 --> 05:36.660
一个是data

05:36.660 --> 05:37.660
一个是computed

05:37.660 --> 05:39.660
一个是method

05:39.660 --> 05:40.660
对吧 这些配置

05:40.660 --> 05:42.660
这些配置呢会注入

05:42.660 --> 05:43.660
好 注入过后呢

05:43.660 --> 05:44.660
我们实力里边

05:44.660 --> 05:45.660
是不是会多了一些成员

05:45.660 --> 05:47.660
对吧 除了它原本自带的之外

05:47.660 --> 05:48.660
还会多了一些

05:48.660 --> 05:50.660
我们自己配置里边的成员

05:50.660 --> 05:52.660
那么接下来一句话很重要

05:52.660 --> 05:54.660
就是我们在写无忧模板的时候

05:54.660 --> 05:55.660
什么叫模板

05:55.660 --> 05:56.660
就写了这一块

05:56.660 --> 05:58.660
对吧 就是我们要显示什么东西

05:58.660 --> 05:59.660
就是模板

05:59.660 --> 06:01.660
那么这一块就是我们的模板

06:01.660 --> 06:02.660
模板的话

06:02.660 --> 06:04.660
模板里边

06:04.660 --> 06:06.660
可以直接使用

06:06.660 --> 06:08.660
无忧实力中的成员

06:08.660 --> 06:10.660
这就是为什么

06:10.660 --> 06:11.660
我给大家解释清楚了

06:11.660 --> 06:12.660
这就是为什么你这里

06:12.660 --> 06:13.660
可以直接写个Title

06:13.660 --> 06:14.660
它能识别

06:14.660 --> 06:15.660
为什么呢

06:15.660 --> 06:19.230
因为无忧实力里边有Title

06:19.230 --> 06:21.230
所以无忧实力里边有Title

06:21.230 --> 06:22.230
对吧 你为什么在这里

06:22.230 --> 06:26.230
可以写一个PurDunk

06:26.230 --> 06:27.230
为什么呢

06:27.230 --> 06:30.230
因为无忧实力里边有PurDunk

06:30.230 --> 06:31.230
对吧 而且是个输出

06:31.230 --> 06:33.230
你可以循环它

06:33.230 --> 06:34.230
对不对

06:34.230 --> 06:36.230
但是这么一回事

06:36.230 --> 06:37.230
原来的意思

06:37.230 --> 06:38.230
为什么可以写Tototalk

06:38.230 --> 06:42.230
因为无忧实力里边有Totostalk

06:42.230 --> 06:43.230
看到没

06:43.230 --> 06:44.230
就是这个原因

06:44.230 --> 06:46.230
那么除了这些我们注入的成员

06:46.230 --> 06:48.230
能不能使用

06:48.230 --> 06:49.230
以多了开枪的成员

06:49.230 --> 06:51.230
也可以

06:51.230 --> 06:52.230
比方说这个

06:52.230 --> 06:53.230
实力里边有个多了开枪的成员

06:53.230 --> 06:54.230
叫做EL

06:54.230 --> 06:56.230
就是整个元素

06:56.230 --> 06:58.230
就是无忧控制的整个元素

06:58.230 --> 07:00.230
得到的就是个动物对象

07:00.230 --> 07:01.230
非常简单

07:01.230 --> 07:02.230
那我们在这里边

07:02.230 --> 07:03.230
能不能使用动物对象

07:03.230 --> 07:05.230
能不能使用这个EL

07:05.230 --> 07:06.230
也可以

07:07.230 --> 07:10.230
我们得到EL的

07:10.230 --> 07:12.230
动物元素的TagNet

07:12.230 --> 07:14.230
保存

07:14.230 --> 07:16.230
得到个DAV

07:16.230 --> 07:18.230
也就是什么意思呢

07:18.230 --> 07:19.230
就是说

07:19.230 --> 07:20.230
这里边的东西

07:20.230 --> 07:21.230
无忧实力里边的东西

07:21.230 --> 07:23.230
在模板里面都可以直接使用

07:23.230 --> 07:24.230
当然要放到这个

07:24.230 --> 07:26.230
胡子语法里面去

07:26.230 --> 07:27.230
这是第一个概念

07:27.230 --> 07:28.230
非常简单

07:28.230 --> 07:29.230
对不对

07:29.230 --> 07:30.230
叫注入

07:30.230 --> 07:32.230
那么这里其实还涉及到

07:32.230 --> 07:33.230
一个小的知识

07:33.230 --> 07:34.230
给大家说一下就行了

07:34.230 --> 07:35.230
上一课不是说了

07:35.230 --> 07:36.230
一个数据享用式吗

07:36.230 --> 07:37.230
什么叫数据享用式

07:37.230 --> 07:40.230
就是data里边的数据一边

07:40.230 --> 07:42.230
界面会跟着边对吧

07:42.230 --> 07:43.230
说得更严格一点

07:43.230 --> 07:45.230
就是data这个数据一边

07:45.230 --> 07:47.230
无忧会收到通知

07:47.230 --> 07:49.230
这叫数据享用式

07:49.230 --> 07:51.230
数据享用式并不是天生就带的

07:51.230 --> 07:53.230
它是要在注入阶段

07:53.230 --> 07:55.230
如果注入完成了过后

07:55.230 --> 07:56.230
才会有数据享用式

07:56.230 --> 07:57.230
那么具体它是

07:57.230 --> 07:59.230
怎么做的数据享用式

07:59.230 --> 08:00.230
它怎么玩呢

08:00.230 --> 08:01.230
咱们这个阶段不涉及

08:01.230 --> 08:03.230
我们知道这个点就行了

08:03.230 --> 08:04.230
注入之后呢

08:04.230 --> 08:06.230
它就会有数据享用式

08:06.230 --> 08:08.230
注入之前是没有的

08:08.230 --> 08:10.230
那么这是第1个阶段

08:10.230 --> 08:11.230
注入

08:11.230 --> 08:12.230
这个概念给大家说清楚

08:12.230 --> 08:13.230
好

08:13.230 --> 08:15.670
第2个概念

08:15.670 --> 08:16.670
叫做虚拟动不出

08:16.670 --> 08:17.670
这一块呢

08:17.670 --> 08:18.670
这一块呢

08:18.670 --> 08:19.670
可能有点难

08:19.670 --> 08:20.670
有一点点难的话

08:20.670 --> 08:21.670
就是这一个地方有点难了

08:21.670 --> 08:22.670
因为它这个地方呢

08:22.670 --> 08:23.670
需要花费一点时间

08:23.670 --> 08:25.670
我才能给大家解释清楚

08:25.670 --> 08:26.670
不然的话你不太很

08:26.670 --> 08:27.670
不太容易理解

08:27.670 --> 08:29.670
大家看到这个模板里边

08:29.670 --> 08:30.670
这个模板里边

08:30.670 --> 08:32.670
是不是我们写了很多的元素

08:32.670 --> 08:33.670
这些元素呢

08:33.670 --> 08:35.670
按照我们过往的理解

08:35.670 --> 08:37.670
它就是一个一个动物元素对不对

08:37.670 --> 08:38.670
但是呢

08:38.670 --> 08:40.670
如果说你这样子写到

08:40.670 --> 08:42.670
无用模板里边就不一样了

08:42.670 --> 08:46.500
在无用模板里边

08:46.500 --> 08:49.500
这些东西全部都不是

08:49.500 --> 08:50.500
动物元素

08:50.500 --> 08:52.500
这不是真正的动物元素

08:52.500 --> 08:54.500
无用会把它当成一个制服串

08:54.500 --> 08:55.500
就这个玩意

08:55.500 --> 08:56.500
是个制服串对无用来说

08:56.500 --> 08:58.500
它最终会变成什么呢

08:58.500 --> 09:00.500
变成一个东西叫做虚拟动

09:00.500 --> 09:01.500
好

09:01.500 --> 09:03.500
接下来来看一下

09:03.500 --> 09:05.500
为什么到底是怎么回事

09:05.500 --> 09:07.500
因为它是这么考虑的

09:07.500 --> 09:08.500
它是说

09:08.500 --> 09:10.500
如果说我整个数据变了

09:10.500 --> 09:12.500
我去重新生成渐变

09:12.500 --> 09:14.500
那如果说我直接操作

09:14.500 --> 09:15.500
真实的动物元素

09:15.500 --> 09:17.500
讲它一个一个都是真实的动物元素

09:17.500 --> 09:20.500
我去操作真实的动物元素的话

09:20.500 --> 09:22.500
就会严重的影响效率

09:22.500 --> 09:24.500
因为真实的动物元素

09:24.500 --> 09:26.500
我们知道会触发浏览器的

09:26.500 --> 09:27.500
什么重排啊

09:27.500 --> 09:28.500
回流啊对吧

09:28.500 --> 09:30.500
会触发浏览器的重新渲染

09:30.500 --> 09:32.500
它有可能会触发重新渲染

09:32.500 --> 09:34.500
那么就会严重的触发效率问题

09:34.500 --> 09:36.500
为了提升效率

09:36.500 --> 09:39.500
于是唯有使用的是虚拟动物的方式

09:39.500 --> 09:42.500
能描述要渲染的内容

09:42.500 --> 09:44.500
其实这种方式也不是唯有原创的

09:44.500 --> 09:46.500
很早就有了

09:46.500 --> 09:50.500
那么什么叫做虚拟动物呢

09:50.500 --> 09:53.500
你是直接操作真实动物

09:53.500 --> 09:55.500
不是效率很低吗

09:55.500 --> 09:57.500
那虚拟动物是怎么玩呢

09:57.500 --> 09:59.500
虚拟动物就是一个普通的

09:59.500 --> 10:02.500
不能再普通的一个介石对象

10:02.500 --> 10:04.500
那你说这个效率不肯定高啊

10:04.500 --> 10:07.500
操作介石对象的属性负质

10:07.500 --> 10:09.500
更改属性质

10:09.500 --> 10:11.500
读取属性质

10:11.500 --> 10:13.500
改动对象的结构

10:13.500 --> 10:14.500
效率都是非常高的

10:14.500 --> 10:16.500
因为它不涉及到介面对不对

10:16.500 --> 10:18.500
它只是一个普通对象而已

10:18.500 --> 10:19.500
比方说我有这么一个对象

10:19.500 --> 10:21.500
这个对象就是一个普通的介石对象

10:21.500 --> 10:23.500
它里面有些属性

10:23.500 --> 10:25.500
Tag表示描述一下

10:25.500 --> 10:27.500
我的介面上应该是有一个元素

10:27.500 --> 10:28.500
叫H1

10:28.500 --> 10:29.500
但是有没有没有

10:29.500 --> 10:31.500
我只是描述一下

10:31.500 --> 10:34.500
这个H1应该有一些指元素

10:34.500 --> 10:35.500
每一个

10:35.500 --> 10:38.500
那么指元素目前只有一个

10:38.500 --> 10:41.500
这个指元素Tag表示

10:41.500 --> 10:42.500
元素的类型

10:42.500 --> 10:43.500
类型没有类型

10:43.500 --> 10:46.500
没有类型它只是一个文本元素

10:46.500 --> 10:47.500
因为我们知道在一面上

10:47.500 --> 10:49.500
所有的节点都是可以称为节点的

10:49.500 --> 10:50.500
对吧

10:50.500 --> 10:51.500
包括文本也是可以称为节点的

10:51.500 --> 10:53.500
那么这个跟虚拟动物

10:53.500 --> 10:55.500
就接近了这个思想

10:55.500 --> 10:57.500
那么文本它也是个节点

10:57.500 --> 10:59.500
那么文本内容是这个内容

10:59.500 --> 11:02.500
这样子就描述了一个虚拟动物了

11:02.500 --> 11:03.500
明白我的意思吗

11:03.500 --> 11:04.500
是不是跟那个真实动物的结构

11:04.500 --> 11:05.500
有点类似

11:05.500 --> 11:07.500
但它不是真实的动物

11:07.500 --> 11:08.500
没有什么神奇的

11:08.500 --> 11:09.500
不要把它想得特别神奇

11:09.500 --> 11:11.500
虚拟动物就是一个普通的介石对象

11:11.500 --> 11:13.500
它就是用来描述的

11:13.500 --> 11:14.500
描述界面上

11:14.500 --> 11:15.500
应该有什么

11:15.500 --> 11:16.500
有没有还没有

11:16.500 --> 11:18.500
应该是有什么

11:18.500 --> 11:19.500
就这样的描述

11:19.500 --> 11:20.500
看没

11:20.500 --> 11:21.500
表上面这个话

11:21.500 --> 11:22.500
就表示了有一个元素

11:22.500 --> 11:24.500
H1它有一个指节点

11:24.500 --> 11:26.500
那又是一个虚拟动物

11:26.500 --> 11:27.500
虚拟动物就是一个元素

11:27.500 --> 11:28.500
就是一个对象

11:28.500 --> 11:29.500
这个虚拟动物

11:29.500 --> 11:33.500
它又是一个文本节点

11:33.500 --> 11:35.500
内容是这个东西

11:35.500 --> 11:37.500
对吧

11:37.500 --> 11:38.500
好

11:38.500 --> 11:41.500
那么它这样子做了过后了

11:41.500 --> 11:42.500
也就是说

11:42.500 --> 11:44.500
这里根本就不存在真实的动物

11:44.500 --> 11:45.500
你不然的话你看一下

11:45.500 --> 11:46.500
真实动物里边

11:46.500 --> 11:48.500
是不是只写了一个Li

11:48.500 --> 11:49.500
是不是只写了一个

11:49.500 --> 11:50.500
那生成出来过后

11:50.500 --> 11:51.500
这边才是真实的动物

11:51.500 --> 11:52.500
你到了界面上

11:52.500 --> 11:53.500
浏览器里边

11:53.500 --> 11:55.500
你看到的是真实的动物

11:55.500 --> 11:57.500
浏览器把它渲染出来了

11:57.500 --> 11:58.500
那么是不是三个Li

11:58.500 --> 11:59.500
是不一样的

11:59.500 --> 12:00.500
对吧

12:00.500 --> 12:01.500
真实动物里边

12:01.500 --> 12:02.500
这个文本节点

12:02.500 --> 12:03.500
我们是这样子写的

12:03.500 --> 12:04.500
但是到了浏览器里边

12:04.500 --> 12:05.500
只变成了这个

12:05.500 --> 12:06.500
说明了啥呀

12:06.500 --> 12:08.500
说明了

12:08.500 --> 12:10.500
这些东西根本就不是真实动物

12:10.500 --> 12:11.500
我就要说明这个问题

12:11.500 --> 12:12.500
听懂了吗

12:12.500 --> 12:15.130
好

12:15.130 --> 12:16.130
那么接下来又做什么呢

12:16.130 --> 12:17.130
因为它最终

12:17.130 --> 12:18.130
最终还是得变成真实动物

12:18.130 --> 12:20.130
那么我们接下来再继续看

12:20.130 --> 12:21.130
我们刚才说了

12:21.130 --> 12:22.130
唯有模板里边

12:22.130 --> 12:23.130
写的并不是真实动物

12:23.130 --> 12:25.130
但是呢

12:25.130 --> 12:27.130
我们写的东西

12:27.130 --> 12:28.130
叫做模板

12:28.130 --> 12:30.130
你看这个页面

12:30.130 --> 12:31.130
我给大家重新写的一个

12:31.130 --> 12:32.130
非常简单的

12:32.130 --> 12:33.130
便于解释

12:33.130 --> 12:34.130
你看这个页面

12:34.130 --> 12:35.130
这是什么

12:35.130 --> 12:36.130
这不是真实动物

12:36.130 --> 12:37.130
这是模板

12:37.130 --> 12:39.130
有的是我们较习惯了

12:39.130 --> 12:40.130
可以教一个元素

12:40.130 --> 12:41.130
这里有个H1元素

12:41.130 --> 12:42.130
但是你心里边要知道

12:42.130 --> 12:43.130
这个玩意根本就

12:43.130 --> 12:44.130
不是什么元素

12:44.130 --> 12:46.130
它是模板里边的内容

12:46.130 --> 12:47.130
看到没

12:47.130 --> 12:48.130
那么这里

12:48.130 --> 12:49.130
我有两个数据

12:49.130 --> 12:50.130
Title一个Orthor

12:50.130 --> 12:52.130
标题和作者

12:52.130 --> 12:53.130
标题作者

12:53.130 --> 12:54.130
非常简单的

12:54.130 --> 12:55.130
维又应用

12:55.130 --> 12:57.130
那么这个玩意叫做模板

12:57.130 --> 13:00.130
维又它看到模板之后

13:00.130 --> 13:02.130
它会把模板的

13:02.130 --> 13:04.130
编译成为虚拟洞

13:04.130 --> 13:06.130
它不是真实动物

13:06.130 --> 13:07.130
你看上面这个模板

13:07.130 --> 13:09.130
它会变成什么呢

13:09.130 --> 13:10.130
经过维又之后

13:10.130 --> 13:12.130
它会变成这个东西

13:12.130 --> 13:14.130
变成了一个用对象来描述它

13:14.130 --> 13:16.130
当然我这个地方

13:16.130 --> 13:17.130
写的比较简略

13:17.130 --> 13:18.130
虚拟洞里边

13:18.130 --> 13:19.130
其实还有很多很多的属性

13:19.130 --> 13:21.130
我们说这个意思

13:22.130 --> 13:24.130
我界面上有一个元素

13:24.130 --> 13:25.130
叫DIV

13:25.130 --> 13:27.130
有没有没有我只是描述它

13:27.130 --> 13:29.130
有它有两个指节点

13:29.130 --> 13:31.130
第一个指节点是一个H1

13:31.130 --> 13:33.130
H1又有一个指节点

13:33.130 --> 13:34.130
指节点是一个什么呢

13:34.130 --> 13:35.130
是一个

13:35.130 --> 13:36.130
只有一个

13:36.130 --> 13:37.130
是一个文本

13:37.130 --> 13:38.130
看到没

13:38.130 --> 13:39.130
那么深圳出来的

13:39.130 --> 13:40.130
过后

13:40.130 --> 13:41.130
你看这个地方

13:41.130 --> 13:42.130
是不是就变成了这个了

13:42.130 --> 13:43.130
Hallower的

13:43.130 --> 13:44.130
那么相当于是

13:44.130 --> 13:45.130
把TitleHallower的

13:45.130 --> 13:46.130
T换到了这里

13:46.130 --> 13:47.130
这个位置了

13:47.130 --> 13:48.130
看到没

13:48.130 --> 13:49.130
是不是这样就可以描述出来了

13:49.130 --> 13:50.130
这叫虚拟洞

13:51.130 --> 13:52.130
好 接下来看下面的张图

13:52.130 --> 13:53.130
就是我们的模板

13:53.130 --> 13:54.130
经过5u过后

13:54.130 --> 13:55.130
它会进行一个编译

13:55.130 --> 13:57.130
5u内部的内置的一个编译器

13:57.130 --> 13:59.130
它在运行的过程中进行编译

13:59.130 --> 14:01.130
编译成了一个虚拟节点

14:01.130 --> 14:03.130
DIV有两个指源书

14:03.130 --> 14:04.130
H1P

14:04.130 --> 14:06.130
H1有一个指源书

14:06.130 --> 14:07.130
Text

14:07.130 --> 14:08.130
一个文本节点

14:08.130 --> 14:10.130
P原来书有一个文本节点

14:10.130 --> 14:11.130
然后呢

14:11.130 --> 14:12.130
最终

14:12.130 --> 14:13.130
你不能老是虚拟洞

14:13.130 --> 14:14.130
那么界面上

14:14.130 --> 14:15.130
就什么都显示不了了

14:15.130 --> 14:16.130
对吧

14:16.130 --> 14:17.130
但最终

14:17.130 --> 14:19.130
它一定会生成一个真实洞

14:19.130 --> 14:21.130
它会根据虚拟洞

14:21.130 --> 14:23.130
然后再去生成真实洞

14:23.130 --> 14:24.130
就生成这个样子

14:24.130 --> 14:25.130
只它的整个过程

14:25.130 --> 14:27.130
我们把这个过程叫做渲染

14:27.130 --> 14:28.130
什么叫渲染

14:28.130 --> 14:30.130
在5u里面的渲染的意思就是

14:30.130 --> 14:32.130
先生成虚拟洞

14:32.130 --> 14:34.130
然后再生成真实洞

14:34.130 --> 14:37.700
就要渲染

14:37.700 --> 14:39.700
好 接下来我们再看一个场景

14:39.700 --> 14:41.700
就是我们的数据变了

14:41.700 --> 14:42.700
数据变了

14:42.700 --> 14:43.700
我们是不是要重新渲染

14:43.700 --> 14:44.700
我们之前说过

14:44.700 --> 14:45.700
数据有响应是

14:45.700 --> 14:46.700
点进去打开

14:46.700 --> 14:48.700
这是我们的简单应用

14:48.700 --> 14:50.700
我们把它保存一下吧

14:50.700 --> 14:52.700
还是保存到VM里面

14:52.700 --> 14:54.700
这个页面

14:54.700 --> 14:56.700
我们这里找到这个VM里面

14:56.700 --> 14:58.700
title改成123

14:58.700 --> 14:59.700
是不是数据变

14:59.700 --> 15:00.700
这里也会跟着变

15:00.700 --> 15:01.700
对吧

15:01.700 --> 15:04.700
或者是我们把这个VM的Auser

15:04.700 --> 15:06.700
改成进

15:06.700 --> 15:07.700
数据变

15:07.700 --> 15:09.700
是不是这里可以跟着变

15:09.700 --> 15:10.700
那么这个过程到底是

15:10.700 --> 15:11.700
什么样子的呢

15:11.700 --> 15:12.700
看这

15:12.700 --> 15:14.700
重新渲染的流程

15:14.700 --> 15:15.700
你看

15:15.700 --> 15:17.700
之前第一次渲染的时候

15:17.700 --> 15:18.700
是不是先生成虚拟洞

15:18.700 --> 15:20.700
然后再生成真实的节点

15:20.700 --> 15:21.700
对吧

15:21.700 --> 15:22.700
于是我们得到最开始的结果

15:22.700 --> 15:23.700
是这么一个结果

15:23.700 --> 15:24.700
这是真实洞

15:24.700 --> 15:25.700
生成出来了

15:25.700 --> 15:26.700
真实洞

15:26.700 --> 15:27.700
然后

15:27.700 --> 15:28.700
如果说数据一变的话

15:28.700 --> 15:31.700
比方说我们把Auser改成进

15:31.700 --> 15:32.700
你想一想

15:32.700 --> 15:34.700
重新渲染是什么意思

15:34.700 --> 15:36.700
是不是要重新生成虚拟洞呢

15:36.700 --> 15:38.700
我们之前生成了虚拟洞

15:38.700 --> 15:40.700
这个P元数的直接点的

15:40.700 --> 15:42.700
内容是作者员

15:42.700 --> 15:45.700
然后再重新生成一次虚拟洞

15:45.700 --> 15:47.700
所以又重新生成一个虚拟洞数

15:47.700 --> 15:48.700
然后他的文本节点

15:48.700 --> 15:49.700
是不是改了

15:49.700 --> 15:50.700
变成了作者进

15:50.700 --> 15:52.700
看到没

15:52.700 --> 15:54.700
然后接下来是不是有两颗数

15:54.700 --> 15:56.700
之前的虚拟洞数

15:56.700 --> 15:58.700
和之后的虚拟洞数

15:58.700 --> 16:00.700
接下来我又会做一件事

16:00.700 --> 16:02.700
就是把这两颗数进行对比

16:02.700 --> 16:04.700
比较差异

16:04.700 --> 16:05.700
两个DIV有没有差异

16:05.700 --> 16:06.700
没有差异 不管

16:06.700 --> 16:07.700
A7有没有差异

16:07.700 --> 16:08.700
没有差异 不管

16:08.700 --> 16:09.700
P元数有没有差异

16:09.700 --> 16:10.700
没有差异 不管

16:10.700 --> 16:12.700
A比较比较比较到这个节点了

16:12.700 --> 16:14.700
这个两个对象是不是有差异

16:14.700 --> 16:16.700
注意哦 这两个

16:16.700 --> 16:18.700
这些都是不是真实的动物

16:18.700 --> 16:19.700
都是虚拟的动物

16:19.700 --> 16:20.700
都是一个一个的对象

16:20.700 --> 16:22.700
因此在对比对象的时候

16:22.700 --> 16:23.700
效率是很高的

16:23.700 --> 16:25.700
如果说你直接去操作真实动物

16:25.700 --> 16:26.700
来进行对比的话

16:26.700 --> 16:27.700
那效率就很低了

16:27.700 --> 16:29.700
所以说他对比的是什么呢

16:29.700 --> 16:31.700
对比的是一个普通的对象

16:31.700 --> 16:32.700
所以说效率非常高

16:32.700 --> 16:33.700
那么就对比到了

16:33.700 --> 16:35.700
发现这个节点是有变化的

16:35.700 --> 16:37.700
那么接下来他做的事情就是

16:37.700 --> 16:40.700
把这个变化应用到真实节点中

16:40.700 --> 16:41.700
就真实的动物数里边

16:41.700 --> 16:43.700
他发现这个节点

16:43.700 --> 16:44.700
对应到真实动物里边

16:44.700 --> 16:45.700
就是对应这个东西

16:45.700 --> 16:46.700
所以说他把这个东西

16:46.700 --> 16:48.700
只需要改动这一个地方就行了

16:48.700 --> 16:50.700
把这个文本进行改动就行了

16:50.700 --> 16:53.700
所以说我们可以看到这个Element

16:53.700 --> 16:55.700
我们把这个控制台找到

16:56.700 --> 16:58.700
打开这个控制台

16:58.700 --> 16:59.700
注意看

16:59.700 --> 17:04.010
我们现在改动作者

17:04.010 --> 17:06.010
你注意看A7和P元的处

17:06.010 --> 17:08.010
看一下哪个地方变了

17:10.010 --> 17:13.790
回车

17:13.790 --> 17:14.790
看清楚没

17:15.790 --> 17:16.790
是不是这里散了一下

17:16.790 --> 17:18.790
没看清楚倒回去看一下

17:18.790 --> 17:20.790
是不是只有这里散一下

17:20.790 --> 17:21.790
A7一变没

17:21.790 --> 17:22.790
没动

17:22.790 --> 17:23.790
也就是说呢

17:23.790 --> 17:25.790
我们可以通过这个流量器的调试工具

17:25.790 --> 17:26.790
可以清晰的看到

17:26.790 --> 17:28.790
当我们改动数据过后

17:28.790 --> 17:30.790
只有数据

17:30.790 --> 17:31.790
就对在真实动物那一块

17:31.790 --> 17:33.790
只有数据这个位置变了

17:33.790 --> 17:35.790
其实P元数都没有变

17:35.790 --> 17:36.790
只剩了P元数的那种变了

17:36.790 --> 17:37.790
他这里会散一下

17:37.790 --> 17:39.790
其实真实的情况是P元数都没有变

17:39.790 --> 17:42.790
只是P元数的内部的文本节变变了

17:42.790 --> 17:44.790
其他地方都没有动

17:44.790 --> 17:45.790
总结的意思吧

17:45.790 --> 17:46.790
所以说呢

17:46.790 --> 17:47.790
唯有为什么效率高

17:47.790 --> 17:49.790
因为我们改动的数据

17:49.790 --> 17:50.790
他不会把整个界面

17:50.790 --> 17:51.790
全部重新来一次

17:51.790 --> 17:52.790
不会的

17:52.790 --> 17:54.790
他只会在页面上去改动那一块

17:54.790 --> 17:55.790
需要变动的地方

17:55.790 --> 17:57.790
为什么他可以做到这一点

17:57.790 --> 17:59.790
就是因为他有蓄力动物的操作

17:59.790 --> 18:01.790
他首先在蓄力动物里边去

18:01.790 --> 18:02.790
通过普通对象进行对比

18:02.790 --> 18:04.790
发现有变化的地方

18:04.790 --> 18:05.790
然后呢

18:05.790 --> 18:06.790
再找出一个变化的地方

18:06.790 --> 18:07.790
对应到真实节变都

18:07.790 --> 18:09.790
真实动物里边哪个地方

18:09.790 --> 18:11.790
那么只去改动这一个地方就行了

18:11.790 --> 18:12.790
避免了大量的

18:12.790 --> 18:14.790
去其他的真实动物

18:14.790 --> 18:16.790
进行无意义的操作

18:16.790 --> 18:17.790
这就是他的对比

18:17.790 --> 18:18.790
重新选的

18:18.790 --> 18:21.490
好,那么接下来

18:21.490 --> 18:22.490
还有一个问题

18:22.490 --> 18:24.490
还有蓄力动物这一块

18:24.490 --> 18:25.490
还有一个最后一个问题

18:25.490 --> 18:27.490
就是我们的代码了

18:27.490 --> 18:28.490
就是五幼

18:28.490 --> 18:30.490
他怎么来得到蓄力集

18:30.490 --> 18:31.490
动物数的呢

18:31.490 --> 18:32.490
刚才我们说了

18:32.490 --> 18:33.490
五幼自动完成了,对不对

18:33.490 --> 18:34.490
那么我们现在

18:34.490 --> 18:36.490
再稍微的深入一下

18:36.490 --> 18:38.490
这个蓄力动物到底是啥呀

18:38.490 --> 18:39.490
其实啊

18:39.490 --> 18:41.490
五幼的配置里边

18:41.490 --> 18:42.490
就是这个五幼啊

18:42.490 --> 18:43.490
它配置里边有一个

18:43.490 --> 18:45.490
配置叫做Render函数

18:45.490 --> 18:48.990
蓄力动物怎么来的

18:48.990 --> 18:49.990
是要

18:49.990 --> 18:51.990
它是运行的Render这个函数

18:51.990 --> 18:53.990
返回结果

18:53.990 --> 18:55.990
这个函数返回的结果

18:55.990 --> 18:57.990
就是它的蓄力动物数

18:57.990 --> 18:58.990
也就是这个数是怎么来的

18:58.990 --> 19:00.990
就是这个函数的返回结果

19:00.990 --> 19:01.990
那么我们是

19:01.990 --> 19:02.990
可不可以在这里写配置啊

19:02.990 --> 19:03.990
可以啊

19:03.990 --> 19:05.990
它本身就是让你去写这个配置的

19:05.990 --> 19:07.990
那么现在我们来写一下啊

19:07.990 --> 19:09.990
怎么来生成一个蓄力动物呢

19:09.990 --> 19:11.990
其实就是我们做一个一模一样的出来

19:11.990 --> 19:13.990
把这个去掉

19:13.990 --> 19:15.990
把这个去掉啊

19:15.990 --> 19:17.990
做一个一模一样的出来

19:17.990 --> 19:19.990
DIV里边有个A7有个P元素

19:19.990 --> 19:20.990
来吧

19:20.990 --> 19:22.990
把这个注射掉啊

19:22.990 --> 19:23.990
注射过后你看啊

19:23.990 --> 19:24.990
无半没了啊

19:24.990 --> 19:25.990
肯定什么都没有了

19:25.990 --> 19:26.990
那么接下来我们在Render里边

19:26.990 --> 19:27.990
去生成蓄力动物

19:27.990 --> 19:28.990
怎么写呢

19:28.990 --> 19:29.990
好,第一个问题就是

19:29.990 --> 19:31.990
我怎么来创建一个蓄力动物呢

19:31.990 --> 19:33.990
它是给你提供了一个函数

19:33.990 --> 19:35.990
这个函数的通过参数给你传进来了啊

19:35.990 --> 19:37.990
我们通常用一个名字

19:37.990 --> 19:38.990
H来表示这个参数

19:38.990 --> 19:40.990
我说一下啊

19:40.990 --> 19:42.990
这一课平时开发肯定是

19:42.990 --> 19:43.990
不会用这种方式来写的

19:43.990 --> 19:44.990
这种方式写起来太麻烦了

19:44.990 --> 19:47.990
我只是通过这种方式来告诉大家

19:47.990 --> 19:50.990
这个渲染的本质是什么

19:50.990 --> 19:52.990
深入的去理解

19:52.990 --> 19:54.990
就心里边一定要有一个很重要的概念

19:54.990 --> 19:56.990
就是蓄力动物数

19:56.990 --> 19:58.990
通过这个函数

19:58.990 --> 19:59.990
这是一个函数

19:59.990 --> 20:00.990
这个名字随便取啊

20:00.990 --> 20:01.990
就是个参数名

20:01.990 --> 20:02.990
给你们做

20:02.990 --> 20:03.990
create

20:03.990 --> 20:04.990
create

20:04.990 --> 20:06.990
create动物叫做微动的

20:06.990 --> 20:07.990
蓄力节点

20:07.990 --> 20:08.990
我们写个函数

20:08.990 --> 20:10.990
我们通常也可以用个H

20:10.990 --> 20:11.990
都一样啊

20:11.990 --> 20:12.990
好,通过H

20:12.990 --> 20:14.990
H是个函数

20:14.990 --> 20:15.990
第一个参数传

20:15.990 --> 20:17.990
蓄力动物的就是传这个东西

20:17.990 --> 20:19.990
第一个参数就传这个东西

20:23.300 --> 20:24.300
它的类型

20:24.300 --> 20:25.300
类型是一个什么呢

20:25.300 --> 20:27.300
DIV对吧

20:27.300 --> 20:29.300
创建个DIV

20:29.300 --> 20:30.300
然后呢

20:30.300 --> 20:32.300
接下来是它的指源

20:32.300 --> 20:33.300
指节点

20:33.300 --> 20:35.300
指节点比方说伪空

20:36.300 --> 20:37.300
好,我们这里返回

20:37.300 --> 20:39.300
这就非常简单了

20:39.300 --> 20:41.300
我觉得这个就生成了一个蓄力动物

20:41.300 --> 20:42.300
蓄力动物

20:42.300 --> 20:43.300
非常简单

20:43.300 --> 20:45.300
我们这里输出一下吧

20:45.300 --> 20:46.300
输出一个Render

20:46.300 --> 20:48.300
我们可以看到啊

20:48.300 --> 20:50.300
这里控材刷新

20:50.300 --> 20:52.300
你看,是不是掉了这个Render函数

20:52.300 --> 20:53.300
这个函数是运行的

20:53.300 --> 20:55.300
它会把这个函数的运行结果

20:55.300 --> 20:57.300
作为蓄力动物数

20:57.300 --> 20:58.300
返回了什么呢

20:58.300 --> 20:59.300
返回的是一个蓄力动物节点

20:59.300 --> 21:01.300
于是这里出现个DIV

21:01.300 --> 21:03.300
那比方说你这里写个HE

21:04.300 --> 21:05.300
刷新

21:05.300 --> 21:07.300
你看,这里是不是变成HE

21:07.300 --> 21:08.300
对不对

21:08.300 --> 21:10.300
那么它最终的把这个蓄力动物

21:10.300 --> 21:12.300
生成了一个最终的

21:12.300 --> 21:14.300
真实动物里面去

21:14.300 --> 21:16.300
好,那么继续啊

21:16.300 --> 21:17.300
那么节点是DIV

21:17.300 --> 21:18.300
DIV里面有什么指节点呢

21:18.300 --> 21:20.300
我们目前没有写的吧

21:20.300 --> 21:22.300
那么我们可以给它写两个指节点

21:22.300 --> 21:23.300
指节点是什么

21:23.300 --> 21:24.300
指节点是不是

21:24.300 --> 21:26.300
还是蓄力动物呀

21:26.300 --> 21:27.300
所以说我们这里

21:27.300 --> 21:28.300
是不是还是可以用HE

21:28.300 --> 21:30.300
第一个指节点,HE元数

21:30.300 --> 21:32.300
HE元数有什么指节点呢

21:32.300 --> 21:33.300
我们这里

21:33.300 --> 21:35.300
它里面就是一个文笨的

21:35.300 --> 21:36.300
文笨的话

21:36.300 --> 21:38.300
我们就可以直接写字母创

21:38.300 --> 21:41.300
比方我们用模板字母创吧

21:41.300 --> 21:43.300
第一个违约应用

21:43.300 --> 21:45.300
你这个时候就不能这样子写了

21:45.300 --> 21:47.300
这个玩意只能写到模板里面

21:47.300 --> 21:49.300
我现在再用模板吗

21:49.300 --> 21:50.300
没有用模板

21:50.300 --> 21:51.300
我用的是什么

21:51.300 --> 21:53.300
直接生成蓄力动物数

21:53.300 --> 21:54.300
那么我们现在

21:54.300 --> 21:57.300
这里我们可以用字母创拼接

21:57.300 --> 21:59.300
模板字母创拼接

21:59.300 --> 22:00.300
Z

22:00.300 --> 22:01.300
所以Z是我们之前说过

22:01.300 --> 22:02.300
在配置对象里面

22:02.300 --> 22:03.300
这些配置对象里面

22:03.300 --> 22:05.300
Z是始终指向的是谁呀

22:05.300 --> 22:08.300
始终指向的是那个

22:08.300 --> 22:09.300
无由实力

22:09.300 --> 22:10.300
所以Z是里面

22:10.300 --> 22:13.300
你是不是有这个态度

22:13.300 --> 22:14.300
对吧

22:14.300 --> 22:15.300
那你看我们这个结构

22:15.300 --> 22:16.300
DM有个指节点

22:16.300 --> 22:17.300
HE有个指节点

22:17.300 --> 22:18.300
一个字母创

22:18.300 --> 22:19.300
一个文笨

22:19.300 --> 22:20.300
这个文笨里面

22:20.300 --> 22:22.300
是凭接出来的结果

22:22.300 --> 22:23.300
好,我们来看一下

22:23.300 --> 22:24.300
所以出来了

22:24.300 --> 22:26.300
所以运行到Render

22:26.300 --> 22:27.300
对不对,非常简单吧

22:27.300 --> 22:28.300
然后我们再来

22:28.300 --> 22:29.300
第二个指节点

22:29.300 --> 22:30.300
HE

22:30.300 --> 22:31.300
这是什么呢

22:31.300 --> 22:33.300
是P元素

22:33.300 --> 22:34.300
内容呢

22:34.300 --> 22:35.300
内容是

22:35.300 --> 22:37.300
作者

22:37.300 --> 22:38.300
作者

22:38.300 --> 22:40.300
帽号

22:40.300 --> 22:42.300
OSL

22:42.300 --> 22:45.300
好,是不是生成了一个蓄力动物数了

22:45.300 --> 22:47.740
这些错了

22:47.740 --> 22:49.740
Z是叫OSL

22:50.740 --> 22:51.740
好,创新

22:51.740 --> 22:52.740
你看是不是做出来

22:52.740 --> 22:53.740
一模一样的效果

22:53.740 --> 22:54.740
运行到Render

22:54.740 --> 22:55.740
这个Render的函数

22:55.740 --> 22:56.740
反而会结果

22:56.740 --> 22:57.740
作为蓄力动物数

22:57.740 --> 22:58.740
好,今天我们来看一下

22:58.740 --> 23:00.740
今天我们来改动一下数据

23:00.740 --> 23:02.740
OSL等于进

23:02.740 --> 23:03.740
改动一下数据

23:03.740 --> 23:04.740
这个数据改动

23:04.740 --> 23:05.740
它会怎么样呢

23:05.740 --> 23:08.740
它会重新运行

23:09.740 --> 23:11.740
重新运行这个Render方法

23:11.740 --> 23:12.740
重新宣传吧

23:12.740 --> 23:13.740
我们刚才说了

23:13.740 --> 23:14.740
重新的逻辑是什么

23:14.740 --> 23:15.740
数据一变

23:15.740 --> 23:16.740
它有响应是

23:16.740 --> 23:18.740
因此它触发了重宣传

23:18.740 --> 23:19.740
重宣传的

23:19.740 --> 23:21.740
本质就是雕拢Render

23:21.740 --> 23:22.740
重新雕拢Render

23:22.740 --> 23:23.740
重新雕拢Render

23:23.740 --> 23:24.740
是不是又重新生成一个数

23:24.740 --> 23:25.740
对吧

23:25.740 --> 23:26.740
因为数据变大比较数据

23:26.740 --> 23:27.740
比较数据刚才

23:27.740 --> 23:28.740
这个元变成了什么

23:28.740 --> 23:30.740
进

23:30.740 --> 23:31.740
重新调用Render

23:31.740 --> 23:32.740
你看生存的蓄力动物数

23:32.740 --> 23:33.740
是不是有个地方变了

23:33.740 --> 23:35.740
是不是这个地方变了

23:35.740 --> 23:36.740
对不对

23:36.740 --> 23:37.740
重新拼接出来就变了

23:37.740 --> 23:38.740
看了没

23:38.740 --> 23:39.740
是这么个意思

23:39.740 --> 23:41.740
然后我们改成进

23:41.740 --> 23:42.740
你看

23:42.740 --> 23:43.740
是不是又重新运行到Render

23:43.740 --> 23:46.740
是不是效果完全一样了

23:46.740 --> 23:47.740
说本质是什么了

23:47.740 --> 23:48.740
本质就是

23:48.740 --> 23:49.740
就是它的宣传

23:49.740 --> 23:50.740
就是调用这个Render方法

23:50.740 --> 23:52.740
生存蓄力动物数

23:52.740 --> 23:54.740
把这个理解清楚

23:54.740 --> 23:56.740
这一块下来要好好去消化一下

23:56.740 --> 23:57.740
脑袋里面反复了

23:57.740 --> 24:00.740
去疏离一下这个概念

24:00.740 --> 24:05.420
多说

24:05.420 --> 24:06.420
好

24:06.420 --> 24:07.420
但是呢

24:07.420 --> 24:08.420
你这样子写太晚

24:08.420 --> 24:09.420
噁不噁心

24:09.420 --> 24:11.420
你就说噁不噁心就得了

24:11.420 --> 24:12.420
肯定很噁心

24:12.420 --> 24:13.420
但是有时候

24:13.420 --> 24:14.420
那种

24:14.420 --> 24:15.420
昨天我们就上节课

24:15.420 --> 24:16.420
我们写的那个

24:16.420 --> 24:17.420
v4

24:17.420 --> 24:19.420
v4的东西循环

24:19.420 --> 24:20.420
对吧

24:20.420 --> 24:21.420
那这个东西又怎么写呢

24:21.420 --> 24:22.420
比方说什么

24:22.420 --> 24:23.420
世间

24:23.420 --> 24:24.420
v4

24:24.420 --> 24:25.420
这东西又怎么写呢

24:25.420 --> 24:27.420
那么我们这里呢

24:27.420 --> 24:28.420
也不去设计的

24:28.420 --> 24:29.420
因为总之呢

24:29.420 --> 24:30.420
你知道在Render里边

24:30.420 --> 24:31.420
肯定是可以写的

24:31.420 --> 24:32.420
比方循环

24:32.420 --> 24:33.420
我们就可以用v4循环吧

24:33.420 --> 24:34.420
生存一个

24:34.420 --> 24:36.420
生存一系列的节点数数

24:36.420 --> 24:37.420
也可以的

24:37.420 --> 24:38.420
总之是有办法的

24:38.420 --> 24:40.930
反正我们这个

24:40.930 --> 24:42.930
直接使用Render去写的话

24:42.930 --> 24:43.930
会比较麻烦

24:43.930 --> 24:44.930
对不对

24:44.930 --> 24:46.930
我们无就不是为了轻松吗

24:46.930 --> 24:48.930
为了减去我们的开发复杂吗

24:48.930 --> 24:49.930
也不能搞得太麻烦了

24:49.930 --> 24:50.930
所以说呢

24:50.930 --> 24:52.930
它给我们提供了模办

24:52.930 --> 24:53.930
模办是用来干嘛的

24:53.930 --> 24:54.930
模办的目标

24:54.930 --> 24:57.930
只有一个

24:57.930 --> 24:59.930
就是根据模办

24:59.930 --> 25:01.930
生存Render方法

25:01.930 --> 25:03.930
也就是说啥呢

25:03.930 --> 25:04.930
也就是说

25:04.930 --> 25:07.930
如果说你不写Render的话

25:07.930 --> 25:10.930
但是你有模办

25:10.930 --> 25:11.930
它会怎么样呢

25:11.930 --> 25:13.930
它会把这个模办

25:13.930 --> 25:15.930
给你编译成为Render方法

25:15.930 --> 25:16.930
就这么个意思

25:16.930 --> 25:17.930
什么叫编译

25:17.930 --> 25:18.930
编译就是这个

25:18.930 --> 25:19.930
做的这个事

25:19.930 --> 25:20.930
也就是说最终

25:20.930 --> 25:21.930
它还是得有Render

25:21.930 --> 25:22.930
那么我们来看一下

25:22.930 --> 25:24.930
具体的逻辑是什么

25:24.930 --> 25:26.930
就这个逻辑

25:26.930 --> 25:28.930
它首先看一下有没有Render

25:28.930 --> 25:29.930
有Render方法

25:29.930 --> 25:30.930
那如果剩下的东西

25:30.930 --> 25:32.930
我什么都不看了

25:32.930 --> 25:33.930
什么这里的模办

25:33.930 --> 25:34.930
我看都不看

25:34.930 --> 25:36.930
我就直接叫Render方法

25:36.930 --> 25:37.930
把Render方法的返回结果

25:37.930 --> 25:38.930
作为序律解件书

25:38.930 --> 25:39.930
你都写Render了

25:39.930 --> 25:41.930
你都不怕麻烦去写Render了

25:41.930 --> 25:42.930
它就不管了

25:42.930 --> 25:44.930
它就直接叫Render方法了

25:44.930 --> 25:45.930
那如果说你没有写Render的话

25:45.930 --> 25:46.930
它就看

25:46.930 --> 25:47.930
那你没有写Render的话

25:47.930 --> 25:49.930
那就必须要给我提供模办

25:49.930 --> 25:51.930
它要去找模办

25:51.930 --> 25:52.930
它会把模办

25:52.930 --> 25:53.930
编译成为Render方法

25:53.930 --> 25:55.930
你没有写我帮你写呗

25:55.930 --> 25:56.930
你想

25:56.930 --> 25:58.930
你在Render确实不好写这个方法

25:58.930 --> 25:59.930
但是模办比较好写

25:59.930 --> 26:01.930
模办写得比较轻松一点

26:01.930 --> 26:03.930
因此看一下有没有模办

26:03.930 --> 26:05.930
它怎么来看有没有模办呢

26:05.930 --> 26:06.930
它看一下有没有这个配置

26:06.930 --> 26:08.930
叫Temperate这个配置

26:08.930 --> 26:10.930
Temperate

26:10.930 --> 26:11.930
它主要看这个

26:11.930 --> 26:12.930
这是个字无寸

26:12.930 --> 26:13.930
这是个字无寸

26:13.930 --> 26:14.930
那么看一下这个碗呀

26:14.930 --> 26:16.930
里面有没有写模办带吗

26:16.930 --> 26:17.930
有没有写呢

26:17.930 --> 26:22.140
比方说我们这里就写了

26:22.140 --> 26:24.140
这个地方不要了

26:24.140 --> 26:25.140
好就写了

26:25.140 --> 26:26.140
你看写了嘛

26:26.140 --> 26:27.140
写了过后呢

26:27.140 --> 26:28.140
我们在这边来看一下刷新

26:28.140 --> 26:30.140
是不是效果一样呢

26:30.140 --> 26:32.140
效果是完全一样的

26:32.140 --> 26:33.140
明儿的意思吧

26:33.140 --> 26:34.140
它会怎么样呢

26:34.140 --> 26:35.140
如果说你写了个Temperate的配置

26:35.140 --> 26:37.140
它就会把Temperate的配置

26:37.140 --> 26:39.140
给你编译成为Render

26:39.140 --> 26:40.140
你看

26:40.140 --> 26:41.140
现在有真实节点吗

26:41.140 --> 26:42.140
你现在看得很清楚

26:42.140 --> 26:43.140
这是一个字无寸

26:43.140 --> 26:44.140
这是个字无寸

26:44.140 --> 26:45.140
哪个是真实节点

26:45.140 --> 26:47.140
没有一个是真实节点

26:47.140 --> 26:49.140
它全都是蓄力节点

26:49.140 --> 26:51.140
它会把这个东西

26:51.140 --> 26:52.140
变成什么Render方法

26:52.140 --> 26:54.140
它会变成这个样子

26:54.140 --> 26:55.140
一模一样的样子

26:55.140 --> 26:57.140
就邦逆写成一个Render

26:57.140 --> 26:58.140
就这么意思

26:58.140 --> 26:59.140
这是Temperate的配置

26:59.140 --> 27:01.140
看一下有没有这个配置

27:01.140 --> 27:04.140
那如果说你这个配置也没有的话

27:04.140 --> 27:06.140
这个配置也没有的话

27:06.140 --> 27:07.140
怎么办呢

27:07.140 --> 27:09.140
它会去看一下

27:09.140 --> 27:12.140
你EL这个元素对应你的地方

27:12.140 --> 27:13.140
它会把这个元素

27:13.140 --> 27:16.140
直接作为模办

27:16.140 --> 27:17.140
懂了意思吧

27:17.140 --> 27:19.700
相信

27:20.700 --> 27:22.700
它会把这个元素

27:22.700 --> 27:24.700
它会把这个元素的

27:25.700 --> 27:26.700
就整个元素的

27:26.700 --> 27:27.700
包括它自己

27:27.700 --> 27:29.700
整个东西作为模办

27:29.700 --> 27:31.700
它就是这么确定的

27:31.700 --> 27:33.700
那么把它作为模办过后

27:33.700 --> 27:34.700
又可以生成Render了

27:34.700 --> 27:36.700
总之一句话说

27:36.700 --> 27:38.700
它一定要得由Render

27:38.700 --> 27:39.700
你没有写

27:39.700 --> 27:41.700
它就把模办编一层Render

27:41.700 --> 27:43.700
最终起作用的是Render

27:43.700 --> 27:44.700
听懂了意思吧

27:44.700 --> 27:46.700
因为Render它会生成蓄力节点书

27:46.700 --> 27:47.700
只有生成了蓄力节点书

27:47.700 --> 27:48.700
它才能进行渲染

27:48.700 --> 27:50.700
渲染成真实节点

27:52.700 --> 27:53.700
而且我们根据

27:54.700 --> 27:55.700
一个常识

27:55.700 --> 27:56.700
书形结构

27:56.700 --> 27:58.700
是不是只有一个根结点

27:58.700 --> 27:59.700
对不对

27:59.700 --> 28:00.700
因为书形结构

28:00.700 --> 28:01.700
是不是只有一个根结点

28:01.700 --> 28:03.700
因此它要求模办

28:04.700 --> 28:06.700
蓄力节点书必须是单根的

28:06.700 --> 28:07.700
所以说我们模办里面

28:07.700 --> 28:08.700
必须是单根

28:08.700 --> 28:09.700
你看这个模办

28:09.700 --> 28:10.700
是不是单根

28:10.700 --> 28:11.700
只有一个根结点

28:11.700 --> 28:12.700
DIV

28:12.700 --> 28:15.910
我这里写重了

28:15.910 --> 28:16.910
这个模办

28:16.910 --> 28:17.910
是不是只有一个DIV

28:17.910 --> 28:18.910
对不对

28:18.910 --> 28:19.910
那么我们自己写模办的时候

28:19.910 --> 28:20.910
如果说

28:20.910 --> 28:21.910
你模办不是写到这儿的

28:21.910 --> 28:22.910
你是写到这儿的

28:22.910 --> 28:26.610
是不是也是得有一个

28:27.610 --> 28:28.610
对吧

28:28.610 --> 28:29.610
你到底能不能这样子写呢

28:29.610 --> 28:30.610
你能不能写两根

28:30.610 --> 28:31.610
一写两根过后

28:31.610 --> 28:32.610
你把它作为模办

28:32.610 --> 28:34.610
编印出来是一棵树吗

28:35.610 --> 28:36.610
肯定不是一棵树

28:36.610 --> 28:37.610
对吧

28:37.610 --> 28:38.610
这个时候就要出问题了

28:39.610 --> 28:40.610
你看这里

28:40.610 --> 28:41.610
它只能识别一起

28:41.610 --> 28:42.610
对吧

28:42.610 --> 28:43.610
第二个就识别不了了

28:44.610 --> 28:46.610
所以它一定要具有单根

28:46.610 --> 28:47.610
这个大家注意一下

28:48.610 --> 28:49.610
好 没问题吧

28:49.610 --> 28:51.610
我讲的比较详细的

28:51.610 --> 28:52.610
比较慢

28:52.610 --> 28:53.610
把这些概念搞清楚

28:53.610 --> 28:54.610
不着急

28:54.610 --> 28:55.610
我们不着急进入项目

28:55.610 --> 28:56.610
先讲几节可基本东西

28:57.610 --> 28:59.610
磨刀不入 砍材工吧

28:59.610 --> 29:00.610
好 下一个概念

29:00.610 --> 29:02.610
接着这里可比较难

29:02.610 --> 29:03.610
就是给虚的动物

29:03.610 --> 29:04.610
后边都比较简单

29:04.610 --> 29:05.610
挂斩

29:06.610 --> 29:07.610
什么叫挂斩呢

29:07.610 --> 29:11.050
就是它不是最重要

29:11.050 --> 29:12.050
会生成真实的动物

29:12.050 --> 29:13.050
它不能老是虚的动物

29:13.050 --> 29:14.050
不然的话

29:14.050 --> 29:15.050
页面上怎么看得见的

29:15.050 --> 29:16.050
页面上就看不懂

29:16.050 --> 29:18.050
虚的动物是接视对象

29:18.050 --> 29:19.050
页面上只能看

29:19.050 --> 29:21.050
生成真实的动物给页面

29:21.050 --> 29:22.050
所以说

29:22.050 --> 29:24.050
它最终会生成真实的动物

29:24.050 --> 29:26.050
那么这样的就是一个问题了

29:26.050 --> 29:28.050
我要把这个真实的

29:28.050 --> 29:29.050
生成的真实的动物数

29:30.050 --> 29:32.050
放到哪去

29:32.050 --> 29:34.050
页面上有这么多元素

29:34.050 --> 29:36.050
比如说这里配这个模板

29:36.050 --> 29:38.050
页面上可能有很多元素

29:38.050 --> 29:40.050
这个DIV

29:40.050 --> 29:41.050
也就是说5U

29:41.050 --> 29:42.050
它不是说

29:42.050 --> 29:43.050
要把整个网页

29:43.050 --> 29:44.050
全部用5U来控制

29:44.050 --> 29:46.050
它可以只控制页面中一个区域

29:46.050 --> 29:48.050
有它生成的这个真实动物

29:48.050 --> 29:50.050
放到页面上的什么位置

29:50.050 --> 29:51.050
通过什么呢

29:51.050 --> 29:52.050
通过页要配置

29:52.050 --> 29:53.050
就这么简单

29:53.050 --> 29:55.050
就说你生成的真实动物

29:55.050 --> 29:56.050
放到这个位置

29:56.050 --> 29:58.050
这个叫做挂斩

29:58.050 --> 29:59.050
把真实的动物

29:59.050 --> 30:00.050
放到页面上去

30:00.050 --> 30:02.050
某个地方去叫做挂斩

30:02.050 --> 30:03.050
那么这个地方

30:03.050 --> 30:05.050
我们可以通过EL配置

30:05.050 --> 30:07.050
这里边是一个CSS选择器

30:07.050 --> 30:10.550
把它挂斩到页面上的某个区域

30:10.550 --> 30:12.550
好 通过这个说法

30:12.550 --> 30:14.550
大家也可以清楚的知道

30:14.550 --> 30:16.550
5U

30:16.550 --> 30:17.550
它不是说

30:17.550 --> 30:19.550
你一定要把整个页面

30:19.550 --> 30:21.550
全部用5U来做

30:21.550 --> 30:22.550
尽管大部分时候

30:22.550 --> 30:25.550
我们都是这样做的

30:25.550 --> 30:27.550
不好意思

30:27.550 --> 30:29.550
但是有的时候

30:29.550 --> 30:33.550
它并没有强制要求的这样做

30:33.550 --> 30:34.550
有的时候

30:34.550 --> 30:35.550
我们可能只需要

30:35.550 --> 30:36.550
要让5U控制页面

30:36.550 --> 30:38.550
看到某一个小的区域

30:38.550 --> 30:39.550
就可以了

30:39.550 --> 30:40.550
然后其他地方

30:40.550 --> 30:41.550
我们用接块

30:41.550 --> 30:43.550
用一些传统的技术来做

30:43.550 --> 30:45.550
但是启动某一个地方

30:45.550 --> 30:47.550
我挂斩了5U

30:47.550 --> 30:48.550
明白了意思吧

30:48.550 --> 30:50.550
5U的官方网站上边

30:50.550 --> 30:51.550
给你说了

30:51.550 --> 30:52.550
我们这个5U

30:52.550 --> 30:54.550
它是一个建进式的

30:54.550 --> 30:56.550
GS框架

30:56.550 --> 30:58.550
什么叫做建进式

30:58.550 --> 30:59.550
一个呢

30:59.550 --> 31:00.550
就是说

31:00.550 --> 31:01.550
我们的页面呢

31:01.550 --> 31:03.550
就是比方说以前的页面

31:03.550 --> 31:05.550
是用一些接块啊

31:05.550 --> 31:06.550
一些BitJap

31:06.550 --> 31:08.550
或者其他乱七八糟的东西啊

31:08.550 --> 31:10.550
用传统的方式开发的

31:11.550 --> 31:13.550
我想把它改造成5U

31:13.550 --> 31:14.550
我不用说

31:14.550 --> 31:16.550
把整个推翻全部重来

31:16.550 --> 31:17.550
成本太高

31:17.550 --> 31:19.550
我可以一块一块的

31:19.550 --> 31:21.550
然后先把这个区域

31:21.550 --> 31:23.550
做成5U

31:23.550 --> 31:25.550
用5U来控制这个区域

31:25.550 --> 31:27.550
挂斩到这个地方

31:27.550 --> 31:28.550
以后呢

31:28.550 --> 31:29.550
我们再慢慢去扩大

31:29.550 --> 31:30.550
是建进式的

31:30.550 --> 31:31.550
当然建进式

31:31.550 --> 31:32.550
还有一些别的含义啊

31:32.550 --> 31:34.550
比方说5U的学习比较简单

31:34.550 --> 31:36.550
学习成本比较低

31:36.550 --> 31:37.550
其实呢

31:37.550 --> 31:39.550
要学生的还是比较复杂啊

31:39.550 --> 31:40.550
它的学习呢

31:40.550 --> 31:43.550
是一个非常平滑的曲线

31:43.550 --> 31:44.550
我可以学一点东西

31:44.550 --> 31:45.550
就可以做一点效果

31:45.550 --> 31:46.550
学一点东西

31:46.550 --> 31:47.550
就可以做点效果

31:47.550 --> 31:49.550
这也是一个建进式的概念

31:49.550 --> 31:50.550
好吧

31:50.550 --> 31:51.550
这是挂斩

31:51.550 --> 31:53.550
通过EL这个配置

31:53.550 --> 31:54.550
当然除了这种配置之外呢

31:54.550 --> 31:56.550
其实还有一种方法进行挂斩

31:56.550 --> 31:58.550
就是5U实力里边

31:58.550 --> 31:59.550
不是刚才说的

31:59.550 --> 32:01.550
5U实力里边有些自己的方法吗

32:01.550 --> 32:02.550
对吧

32:02.550 --> 32:03.550
其中一个方法叫做Mount

32:03.550 --> 32:07.860
就是你一开始先不用配置这个

32:07.860 --> 32:09.860
一开始先不用配置

32:09.860 --> 32:11.860
我等一会

32:11.860 --> 32:13.860
我现在把东西配置好

32:13.860 --> 32:14.860
生成了5U实力

32:14.860 --> 32:15.860
等一会儿

32:15.860 --> 32:19.430
等到后边

32:19.430 --> 32:20.430
等到后边的时候

32:20.430 --> 32:21.430
我们通过这个Mount的方法

32:21.430 --> 32:22.430
来进挂斩

32:22.430 --> 32:25.430
比方说我在这里不挂斩

32:25.430 --> 32:26.430
你看啊

32:26.430 --> 32:27.430
是不是不挂斩

32:27.430 --> 32:28.430
什么都没有

32:28.430 --> 32:29.430
对不对

32:29.430 --> 32:30.430
因为它什么都没有

32:30.430 --> 32:31.430
那么接下来

32:31.430 --> 32:33.430
我们通过这个5U实力的Mount方法

32:33.430 --> 32:34.430
这个时候

32:34.430 --> 32:35.430
动态的把它挂斩到哪儿呢

32:35.430 --> 32:37.430
挂的到App这里

32:37.430 --> 32:38.430
对吧

32:38.430 --> 32:40.430
它就挂在进去

32:40.430 --> 32:41.430
比方来说

32:41.430 --> 32:42.430
非常简单

32:42.430 --> 32:43.430
那么两个有什么区别呢

32:43.430 --> 32:44.430
目前没有什么区别

32:44.430 --> 32:45.430
但将来呢

32:45.430 --> 32:47.430
可能会有点区别

32:47.430 --> 32:48.430
比方说

32:48.430 --> 32:50.430
我要先创建5U实力

32:50.430 --> 32:52.430
我们可能会要做一些事

32:52.430 --> 32:54.430
可能要做一些别的事

32:56.430 --> 32:58.430
把这些事情做完了之后

32:58.430 --> 32:59.430
我最后挂斩

32:59.430 --> 33:00.430
是可以做到的

33:00.430 --> 33:01.430
总之这两个方法

33:01.430 --> 33:03.430
对目前来说都差不多

33:03.430 --> 33:04.430
好

33:04.430 --> 33:05.430
最后最终

33:05.430 --> 33:07.430
我们来看一下玩怎么流程

33:07.430 --> 33:08.430
再复习一下

33:08.430 --> 33:12.770
第一个

33:12.770 --> 33:13.770
实力

33:13.770 --> 33:14.770
首先被创建

33:14.770 --> 33:15.770
就凋用这个6

33:15.770 --> 33:16.770
是不是创建实力

33:16.770 --> 33:17.770
对吧

33:17.770 --> 33:18.770
创建完了实力

33:18.770 --> 33:19.770
创建了实力过后

33:19.770 --> 33:20.770
马上还会发生这么一个过程

33:20.770 --> 33:21.770
就注入

33:22.770 --> 33:23.770
他会怎么样呢

33:23.770 --> 33:25.770
他会把这些东西

33:25.770 --> 33:27.770
创建后的这种

33:27.770 --> 33:28.770
这些东西

33:28.770 --> 33:29.770
这些东西

33:29.770 --> 33:30.770
这些东西提到哪

33:30.770 --> 33:31.770
提到实力里边去

33:31.770 --> 33:32.770
然后呢

33:32.770 --> 33:34.770
这个时候注入完成之后

33:34.770 --> 33:35.770
有了想象式

33:35.770 --> 33:36.770
数据变化

33:36.770 --> 33:37.770
他能坚定到了

33:37.770 --> 33:41.340
注入之前是没有想象式的

33:41.340 --> 33:43.340
比方你在注入之前

33:43.340 --> 33:44.340
你要去访问什么

33:44.340 --> 33:45.340
VM点

33:45.340 --> 33:46.340
什么

33:46.340 --> 33:47.340
Title没有

33:48.340 --> 33:49.340
没有人

33:49.340 --> 33:50.340
注入之后就有了

33:50.340 --> 33:51.340
好

33:51.340 --> 33:52.340
注入完了过后

33:52.340 --> 33:53.340
他会

33:53.340 --> 33:55.340
他会去编译成为一个

33:55.340 --> 33:56.340
虚地动物数

33:56.340 --> 33:57.340
就编译成微动的

33:57.340 --> 33:58.340
虚地动物数

33:58.340 --> 33:59.340
怎么编译呢

33:59.340 --> 34:00.340
我们之前讲了

34:00.340 --> 34:01.340
首先找一下

34:01.340 --> 34:02.340
有没有Render

34:02.340 --> 34:03.340
有Render的话

34:03.340 --> 34:04.340
我就调用Render

34:04.340 --> 34:05.340
没有Render的话

34:05.340 --> 34:06.340
我就找模板

34:06.340 --> 34:07.340
把它生成Render

34:07.340 --> 34:08.340
对吧

34:08.340 --> 34:09.340
然后运行Render

34:09.340 --> 34:10.340
总之呢

34:10.340 --> 34:11.340
还会经过一期的过程

34:11.340 --> 34:12.340
最终一定要得到一个

34:12.340 --> 34:13.340
虚地动物数

34:14.340 --> 34:15.340
得到了虚地动物数

34:15.340 --> 34:16.340
是不是可以生成

34:16.340 --> 34:17.340
真实动物呢

34:17.340 --> 34:18.340
真实动物生成到哪呢

34:18.340 --> 34:19.340
所以一个挂

34:20.340 --> 34:21.340
这就是第一次宣展

34:21.340 --> 34:22.340
首次宣展

34:23.340 --> 34:24.340
好

34:24.340 --> 34:25.340
接下来挂载完了过后

34:25.340 --> 34:27.340
我们页面上就可以看到东西了

34:28.340 --> 34:30.340
看到东西过后呢

34:30.340 --> 34:32.340
数据有可能会变化

34:32.340 --> 34:33.340
数据一变

34:34.340 --> 34:35.340
干嘛呢

34:35.340 --> 34:36.340
他要重新宣展

34:36.340 --> 34:37.340
怎么重新宣展呢

34:37.340 --> 34:38.340
首先他重新生成

34:38.340 --> 34:39.340
这新的虚地动物数

34:39.340 --> 34:41.340
也就是重新调用Render

34:41.340 --> 34:43.340
生成新的虚地动物数

34:43.340 --> 34:44.340
然后对比之前那个数

34:44.340 --> 34:45.340
跟现在那个数有差异

34:45.340 --> 34:46.340
然后把这个差异的

34:46.340 --> 34:48.340
应用到真实动物里边去

34:49.340 --> 34:50.340
就完成宣展了

34:51.340 --> 34:52.340
整个就这么一个过程

34:52.340 --> 34:53.340
你看我们上去何代

34:54.340 --> 34:55.340
我点一下

34:55.340 --> 34:56.340
是不是改动了数据

34:57.340 --> 34:58.340
改动了什么数据呢

34:58.340 --> 34:59.340
点一下

35:00.340 --> 35:01.340
点加

35:01.340 --> 35:02.340
改动了什么

35:02.340 --> 35:04.340
数据变了

35:04.340 --> 35:06.340
数据变了是不是重新调用Render

35:06.340 --> 35:07.340
重新调用Render过后呢

35:07.340 --> 35:08.340
他重新宣展

35:08.340 --> 35:09.340
重新一重新宣展

35:09.340 --> 35:11.340
是不是知道哪个地方有变化

35:11.340 --> 35:12.340
他就发现

35:12.340 --> 35:13.340
这个地方有变化

35:14.340 --> 35:15.340
对吧

35:15.340 --> 35:16.340
好这个地方有变化了

35:16.340 --> 35:18.340
在页面上他就改动了这个地方

35:18.340 --> 35:20.340
还有一个总库存有变化

35:20.340 --> 35:22.340
我们可以在这里看得很清楚

35:22.340 --> 35:24.340
找到个控制台吧

35:24.340 --> 35:29.410
屏幕展开

35:29.410 --> 35:30.410
就这样吧

35:30.410 --> 35:32.410
在这里展开

35:32.410 --> 35:36.300
把地个展开吧

35:36.300 --> 35:37.300
你看我点加号

35:37.300 --> 35:39.300
你看页面上什么地方变了

35:40.300 --> 35:41.300
你看是不是只有必要的地方

35:41.300 --> 35:42.300
会发生变化

35:42.300 --> 35:44.300
其他地方不会动的

35:44.300 --> 35:45.300
对吧

35:45.300 --> 35:46.300
这是虚地动物数的功能

35:47.300 --> 35:49.300
这是原地这一块

35:50.300 --> 35:51.300
是不是

35:51.300 --> 35:53.300
有些地方有点少老

35:53.300 --> 35:54.300
其实没有那么老虎

35:54.300 --> 35:55.300
好好地去梳理一下

35:55.300 --> 35:56.300
没问题的

35:56.300 --> 35:57.300
肯定没问题的

35:57.300 --> 35:59.300
好的这一部分

35:59.300 --> 36:00.300
那么接下来呢

36:00.300 --> 36:02.300
就是给大家讲一讲一些

36:02.300 --> 36:03.300
跟代码相关的

36:03.300 --> 36:05.300
有相当于是API的东西的

36:05.300 --> 36:06.300
就怎么用了

36:06.300 --> 36:07.300
那这一部分就比较轻松了

36:07.300 --> 36:08.300
如果说你现在听着

36:08.300 --> 36:09.300
脑袋一点晕晕的

36:09.300 --> 36:10.300
可以先暂停

36:10.300 --> 36:11.300
可以先去回顾一下

36:11.300 --> 36:12.300
先把这个

36:12.300 --> 36:14.300
之前讲的原理的这部分吃透

36:14.300 --> 36:16.300
然后再来听下面的部分

36:17.300 --> 36:18.300
好接下来呢

36:18.300 --> 36:19.300
我们就回到

36:19.300 --> 36:20.300
之前的代码里边

36:21.300 --> 36:22.300
我们代码里边

36:22.300 --> 36:23.300
之前不是分为两块吗

36:23.300 --> 36:24.300
一块是什么

36:24.300 --> 36:25.300
模板

36:25.300 --> 36:26.300
一块是什么呢

36:26.300 --> 36:27.300
配置

36:27.300 --> 36:28.300
对吧

36:28.300 --> 36:29.300
我们其实写五右的

36:29.300 --> 36:31.300
基本上就是在两个地方

36:31.300 --> 36:32.300
来回切

36:32.300 --> 36:33.300
来回横跳

36:33.300 --> 36:34.300
一块写模板

36:34.300 --> 36:35.300
一块写一下配置

36:35.300 --> 36:37.300
因为这两个地方有相关性

36:38.300 --> 36:39.300
配置主要是

36:39.300 --> 36:40.300
功能性质的

36:40.300 --> 36:41.300
跟功能相关的

36:41.300 --> 36:42.300
你看

36:42.300 --> 36:43.300
有哪些数据

36:43.300 --> 36:44.300
对吧

36:45.300 --> 36:47.300
我们可以根据目前的数据

36:47.300 --> 36:48.300
计算出什么样的数据

36:48.300 --> 36:49.300
我们有哪些方法

36:49.300 --> 36:50.300
有哪些操作

36:50.300 --> 36:51.300
是跟功能相关的

36:52.300 --> 36:54.300
直接跟数据打交道的

36:55.300 --> 36:56.300
而我们的模板写的是咋呀

36:56.300 --> 36:57.300
模板写的是

36:57.300 --> 36:59.300
怎么样根据数据

37:00.300 --> 37:02.300
有了这么一样的一个数据

37:02.300 --> 37:03.300
我应该

37:03.300 --> 37:05.300
生成什么样的一个界面

37:05.300 --> 37:06.300
这是模板关心的事情

37:08.300 --> 37:09.300
这两块

37:09.300 --> 37:10.300
那么接下来我们也讲一讲

37:10.300 --> 37:11.300
就是模板里边写啥

37:11.300 --> 37:12.300
有哪些写法

37:12.300 --> 37:13.300
有哪些写法

37:13.300 --> 37:15.300
配置里边有哪些写法

37:15.300 --> 37:17.300
这里有个四位老徒

37:17.300 --> 37:18.300
因为我们之后

37:18.300 --> 37:20.300
会不断的去丰富这一块的知识体系

37:20.300 --> 37:22.300
好,来看

37:22.300 --> 37:23.300
模板主要分为两块

37:23.300 --> 37:24.300
一块是内容

37:24.300 --> 37:25.300
一块是指令

37:25.300 --> 37:27.300
将来还会写别的东西

37:27.300 --> 37:28.300
内容是什么呢

37:28.300 --> 37:30.300
内容就是这个地方

37:30.300 --> 37:32.300
就是元素内容

37:32.300 --> 37:33.300
你看这些地方

37:33.300 --> 37:34.300
就是元素内容

37:34.300 --> 37:35.300
就是这些地方

37:35.300 --> 37:37.300
元素内容有些东西

37:37.300 --> 37:38.300
是静态内容

37:38.300 --> 37:39.300
就是它不会变化

37:39.300 --> 37:40.300
永远不变

37:40.300 --> 37:41.300
比方说这几个字

37:42.300 --> 37:43.300
永远不变

37:43.300 --> 37:44.300
就是静态的

37:44.300 --> 37:45.300
有些地方是动态的

37:45.300 --> 37:46.300
还有可能会变化

37:46.300 --> 37:47.300
就这个地方

37:47.300 --> 37:49.300
这个地方可能会变化

37:49.300 --> 37:50.300
是动态的

37:50.300 --> 37:51.300
好,动态的部分

37:51.300 --> 37:52.300
我们之前说过

37:52.300 --> 37:53.300
写的是什么呢

37:53.300 --> 37:54.300
大狐之鱼法

37:54.300 --> 37:55.300
这个东西说过了

37:55.300 --> 37:56.300
没什么好说的

37:56.300 --> 37:57.300
就是两个大话号

37:57.300 --> 37:58.300
里边写什么

37:58.300 --> 37:59.300
介石表达式

37:59.300 --> 38:00.300
直接写就行了

38:00.300 --> 38:02.300
接下来另外一部分

38:02.300 --> 38:03.300
就是指令

38:04.300 --> 38:05.300
指令我们在哪呢

38:05.300 --> 38:07.300
你看,这个玩意就是指令

38:07.300 --> 38:09.300
这个玩意就是指令

38:10.300 --> 38:12.300
指令它一定是以V

38:12.300 --> 38:14.300
橫杠开头的

38:14.300 --> 38:15.300
我们首先来学习

38:15.300 --> 38:16.300
第一个指令

38:16.300 --> 38:17.300
今天我们会学习

38:17.300 --> 38:18.300
三个指令

38:18.300 --> 38:20.300
第一个指令是叫做Vband

38:20.300 --> 38:22.670
指令用来干嘛呢

38:22.670 --> 38:23.670
指令用来

38:23.670 --> 38:24.670
主要是写到

38:24.670 --> 38:27.670
这个元素的属性位置

38:27.670 --> 38:28.670
主要是写到

38:28.670 --> 38:29.670
这个元素的属性位置

38:29.670 --> 38:30.670
它是

38:31.670 --> 38:32.670
它有一些功能性质的

38:32.670 --> 38:34.670
比方说循环生成元素

38:34.670 --> 38:35.670
判断要不要生成

38:35.670 --> 38:37.670
这个元素等等等等

38:37.670 --> 38:38.670
首先是Vband

38:38.670 --> 38:39.670
这个指令是用来干嘛的呢

38:39.670 --> 38:41.670
是用来绑定属性的

38:41.670 --> 38:43.670
它有一个指令参数

38:43.670 --> 38:44.670
叫做属性名

38:44.670 --> 38:45.670
啥意思啊

38:45.670 --> 38:46.670
说的都不是人话了

38:46.670 --> 38:47.670
我们来看一下吧

38:47.670 --> 38:48.670
非常简单

38:50.670 --> 38:51.670
Vband

38:51.670 --> 38:58.210
这里引用

39:02.780 --> 39:07.240
比方说我们的页面上

39:07.240 --> 39:09.240
有一张图片

39:10.240 --> 39:11.240
又一个不用

39:11.240 --> 39:17.370
得到这个VM

39:18.370 --> 39:20.370
我们页面上有一张图片

39:20.370 --> 39:21.370
但是这个图片的

39:21.370 --> 39:22.370
SRC路径

39:22.370 --> 39:23.370
它是动态的

39:23.370 --> 39:25.370
它有可能会发生变化

39:26.370 --> 39:27.370
比方说我们这里有一个数据

39:27.370 --> 39:28.370
对吧

39:28.370 --> 39:29.370
反而是动态的地方

39:29.370 --> 39:30.370
我们是不是要提供数据

39:33.370 --> 39:34.370
要提供一个数据

39:34.370 --> 39:35.370
数据里面

39:35.370 --> 39:37.370
我们有一个UML

39:37.370 --> 39:38.370
对吧

39:38.370 --> 39:39.370
IMEG

39:39.370 --> 39:40.370
那么这是一个图片的路径

39:40.370 --> 39:41.370
图片路径

39:41.370 --> 39:42.370
我随便找一个

39:43.370 --> 39:44.370
随便找一个图片路径

39:51.090 --> 39:55.770
随便来一个吧

39:55.770 --> 39:56.770
图字图片第一次

39:57.770 --> 39:58.770
这是图片路径

39:59.770 --> 40:00.770
那么我们希望

40:00.770 --> 40:02.770
这个元素的这个属性

40:03.770 --> 40:04.770
它不是静态的

40:04.770 --> 40:05.770
静态的话

40:05.770 --> 40:06.770
你直接把这个

40:06.770 --> 40:07.770
粘过来就行了

40:07.770 --> 40:08.770
它永远不会变化

40:08.770 --> 40:09.770
我希望它是动态的

40:09.770 --> 40:10.770
它有可能会变化的

40:11.770 --> 40:12.770
它应该读取

40:12.770 --> 40:13.770
这个属性值

40:13.770 --> 40:14.770
放到这个位置

40:14.770 --> 40:15.770
那怎么办呢

40:16.770 --> 40:17.770
你就可以写上

40:17.770 --> 40:18.770
Vband

40:18.770 --> 40:19.770
所以一个指令

40:20.770 --> 40:21.770
指令名称

40:21.770 --> 40:22.770
后边跟上冒号

40:22.770 --> 40:23.770
冒号后边是指令的参数

40:24.770 --> 40:25.770
参数是不是属性名

40:26.770 --> 40:27.770
就这么个意思

40:27.770 --> 40:28.770
你看

40:30.770 --> 40:31.770
Vband的

40:31.770 --> 40:32.770
绑定属性用的

40:34.770 --> 40:36.770
指令参数就是属性名

40:36.770 --> 40:38.770
指令参数就是属性名

40:38.770 --> 40:40.770
也就是这个SRC属性

40:40.770 --> 40:43.770
来自于一个介石表达式

40:43.770 --> 40:45.770
这里写的是介石表达式

40:46.770 --> 40:47.770
没了意思吧

40:47.770 --> 40:49.770
那么这个表达式写啥呢

40:49.770 --> 40:50.770
记住了

40:50.770 --> 40:52.770
反射模板表写介石代码的地方

40:52.770 --> 40:54.770
全部都是实力环境

40:54.770 --> 40:55.770
就是实力里面有的东西

40:55.770 --> 40:56.770
它都可以有

40:56.770 --> 40:57.770
这里怎么写

40:58.770 --> 40:59.770
实力里面

40:59.770 --> 41:00.770
一看有注入

41:00.770 --> 41:01.770
因为有注入

41:01.770 --> 41:02.770
所以说实力里面

41:02.770 --> 41:03.770
肯定是有这个EmeG

41:03.770 --> 41:04.770
对吧

41:04.770 --> 41:09.360
然后我把它挂载到了

41:09.360 --> 41:10.360
保证你看一下

41:10.360 --> 41:14.780
不就出来了吗

41:14.780 --> 41:16.780
那么这个东西有什么好处呢

41:16.780 --> 41:17.780
将来如果说

41:17.780 --> 41:18.780
我们要变换图片的时候

41:18.780 --> 41:20.780
因为图片有可能会变换

41:20.780 --> 41:21.780
不要说变这个

41:21.780 --> 41:23.780
右键复制图片机制

41:23.780 --> 41:24.780
变换的时候

41:24.780 --> 41:25.780
我们很简单

41:25.780 --> 41:27.780
我们只需要改动EmeG

41:27.780 --> 41:28.780
属性就行了

41:28.780 --> 41:29.780
一改

41:29.780 --> 41:30.780
就变了

41:30.780 --> 41:31.780
因为

41:31.780 --> 41:33.780
它是动态的

41:33.780 --> 41:34.780
数据变了

41:34.780 --> 41:35.780
是不是重新渲染

41:35.780 --> 41:36.780
重新渲染是不是

41:36.780 --> 41:38.780
虚拟节点重新生成

41:38.780 --> 41:39.780
对比过后发现

41:39.780 --> 41:40.780
这个SRC属性要变化

41:40.780 --> 41:41.780
就变化了

41:42.780 --> 41:43.780
就这么个意思

41:44.780 --> 41:45.780
能理解吧

41:45.780 --> 41:47.780
这就是Vband的指令

41:47.780 --> 41:48.780
非常简单

41:48.780 --> 41:49.780
然后其他的属性

41:49.780 --> 41:50.780
怎么能绑定的

41:50.780 --> 41:51.780
也可以绑定任何属性

41:51.780 --> 41:53.780
任何属性都可以绑定

41:53.780 --> 41:55.780
包括A元素的REF属性

41:55.780 --> 41:56.780
任何元素的属性

41:56.780 --> 41:58.780
都可以通过Vband来进行绑定

41:58.780 --> 41:59.780
动态的生成

42:00.780 --> 42:01.780
那么这样的写的

42:01.780 --> 42:03.780
因为这种绑定属性

42:03.780 --> 42:05.780
这个需求比较常见

42:05.780 --> 42:06.780
所以说5U给我们提供了

42:06.780 --> 42:07.780
一个语法堂

42:07.780 --> 42:08.780
就是说你可以减写

42:08.780 --> 42:10.780
Vband的这个指令

42:10.780 --> 42:12.780
你可以减写为帽号SRC

42:12.780 --> 42:14.780
一凡是写个帽号开头

42:14.780 --> 42:15.780
属性

42:15.780 --> 42:16.780
那就是相当于写的

42:16.780 --> 42:17.780
一个Vband的在前面

42:17.780 --> 42:18.780
效果是一样的

42:18.780 --> 42:19.780
你看

42:19.780 --> 42:20.780
你现在在改

42:21.780 --> 42:22.780
没了意思

42:22.780 --> 42:24.780
这就是这个Vband的指令

42:25.780 --> 42:26.780
好 这是第1个指令

42:26.780 --> 42:27.780
没问题吧

42:27.780 --> 42:28.780
非常简单

42:28.780 --> 42:29.780
这个指令叫做V4

42:31.780 --> 42:32.780
V4

42:33.780 --> 42:34.780
它用来干嘛呢

42:34.780 --> 42:35.780
它是用来循环数组的

42:35.780 --> 42:36.780
我上一课是用过的

42:36.780 --> 42:37.780
非常简单

42:37.780 --> 42:39.780
就是V4这个指令

42:39.780 --> 42:41.780
后面写上一段介式代码

42:41.780 --> 42:42.780
循环什么呢

42:42.780 --> 42:43.780
循环数组

42:43.780 --> 42:44.780
硬关键字

42:44.780 --> 42:46.780
前面可以只用一个Item

42:46.780 --> 42:47.780
表

42:47.780 --> 42:48.780
这个变量明智随便去

42:48.780 --> 42:50.780
表示循环这个数组

42:50.780 --> 42:51.780
把每一项拿出来

42:51.780 --> 42:52.780
放到这里边

42:52.780 --> 42:53.780
然后也可以跟上下标

42:53.780 --> 42:54.780
对吧 它会把下标

42:54.780 --> 42:56.780
对应的下标放到这里边

42:56.780 --> 42:57.780
这是循环

42:57.780 --> 42:59.780
然后它就会循环了

42:59.780 --> 43:00.780
生成这个元素

43:00.780 --> 43:01.780
就这么简单

43:01.780 --> 43:02.780
多复杂呢

43:02.780 --> 43:03.780
没什么复杂的

43:03.780 --> 43:05.780
那么就一个小的点

43:05.780 --> 43:07.780
需要注意的就是

43:07.780 --> 43:10.780
由于某些目前不太好解释的原因

43:10.780 --> 43:12.780
你可以认为就是效率问题

43:12.780 --> 43:13.780
为了提升效率

43:14.780 --> 43:15.780
主要是问题出在

43:15.780 --> 43:17.780
比对新就两棵树的时候

43:17.780 --> 43:19.780
为了提升比对效率

43:19.780 --> 43:21.780
它强烈建议

43:22.780 --> 43:25.780
再写循环生成元素的地方

43:25.780 --> 43:26.780
加上这么一个东西

43:27.780 --> 43:29.780
一个key 绑定一个key属性

43:29.780 --> 43:30.780
怎么绑定

43:30.780 --> 43:31.780
用V半点去绑定

43:31.780 --> 43:33.780
绑定一个key属性

43:33.780 --> 43:35.780
然后你可以减线为帽号key

43:35.780 --> 43:37.780
key是一个特殊的属性

43:37.780 --> 43:38.780
绑定为什么呢

43:38.780 --> 43:41.780
绑定为一个唯一的值

43:41.780 --> 43:43.780
唯一前稳定的值

43:43.780 --> 43:45.780
比方说绑定这个i

43:45.780 --> 43:46.780
i是唯一的

43:46.780 --> 43:47.780
下标是唯一的

43:47.780 --> 43:49.780
绑定一个唯一的值

43:49.780 --> 43:50.780
那么这里绑定出来

43:50.780 --> 43:51.780
OK了

43:51.780 --> 43:52.780
但是效果没有任何差异

43:52.780 --> 43:53.780
效果完全一样

43:53.780 --> 43:54.780
没有任何差异

43:54.780 --> 43:55.780
而且这个key

43:55.780 --> 43:56.780
绑定到最终的元素里面

43:56.780 --> 43:57.780
也是不存在的

43:57.780 --> 43:58.780
这主要是给无诱用的

43:58.780 --> 44:00.780
给虚历节奖用的

44:00.780 --> 44:02.780
提升一些效率

44:02.780 --> 44:03.780
那么至于

44:03.780 --> 44:04.780
为什么会提升效率

44:04.780 --> 44:05.780
我们现在下一个节奖来说

44:05.780 --> 44:06.780
这就让我们不去

44:06.780 --> 44:08.780
设置太深入的知识

44:08.780 --> 44:10.780
它强烈这样一这样做

44:10.780 --> 44:12.780
而且到我这儿

44:12.780 --> 44:13.780
就不是强烈建议了

44:13.780 --> 44:14.780
是必须要这样做的

44:14.780 --> 44:16.780
但是绑定的key

44:16.780 --> 44:17.780
一般来说

44:17.780 --> 44:18.780
也不是下标i

44:18.780 --> 44:19.780
为什么

44:19.780 --> 44:21.780
因为下标i不是很稳定

44:21.780 --> 44:22.780
为什么不是很稳定呢

44:22.780 --> 44:23.780
那如果说

44:23.780 --> 44:24.780
我在这个前面加一下

44:25.780 --> 44:26.780
iPhone前面

44:26.780 --> 44:27.780
到时候我用unshift

44:27.780 --> 44:29.780
数据的操作方法加一下

44:29.780 --> 44:30.780
那么后边的下标

44:30.780 --> 44:31.780
是会全变的

44:31.780 --> 44:32.780
每一项

44:32.780 --> 44:33.780
它最近的下标

44:33.780 --> 44:34.780
不是很稳定

44:34.780 --> 44:35.780
也就是什么呢

44:35.780 --> 44:37.780
iPhone它不一定是第1项

44:37.780 --> 44:38.780
不一定永远是第1项

44:38.780 --> 44:40.780
小米不一定永远是第2项

44:42.780 --> 44:43.780
i它倒是唯一

44:43.780 --> 44:44.780
但是不稳定

44:44.780 --> 44:46.780
因此强烈建议大家

44:46.780 --> 44:47.780
使用什么

44:47.780 --> 44:48.780
用编号

44:49.780 --> 44:51.780
以后像这些数据

44:51.780 --> 44:52.780
都是从服务器来的

44:52.780 --> 44:53.780
服务器的每个数据

44:53.780 --> 44:55.780
它基本上都会给你一个编号

44:56.780 --> 44:57.780
比如id

45:03.610 --> 45:04.610
那么这里绑定什么呢

45:04.610 --> 45:06.610
应该绑定的是iPhone.id

45:07.610 --> 45:08.610
这样是最好的

45:09.610 --> 45:11.610
看到效果了没有任何差异

45:12.610 --> 45:13.610
id是稳定的

45:13.610 --> 45:14.610
而且是唯一的

45:14.610 --> 45:15.610
那么有一天

45:15.610 --> 45:16.610
把这个小米删了

45:16.610 --> 45:17.610
你看

45:17.610 --> 45:18.610
影不影响这些id

45:18.610 --> 45:19.610
id不影响

45:19.610 --> 45:21.610
它仍然是保持对应关系

45:22.610 --> 45:24.610
这个玩意跟我们开发

45:24.610 --> 45:25.610
最后一点点关系

45:25.610 --> 45:26.610
就是你这里以后呢

45:26.610 --> 45:28.610
能写id的地方尽量写id

45:28.610 --> 45:29.610
实在没有id写

45:29.610 --> 45:31.610
那么可以考虑使用这个下标

45:31.610 --> 45:32.610
但是一定要写上这个key

45:32.610 --> 45:34.610
提升那个渲染效率

45:35.610 --> 45:37.610
这是这一块

45:37.610 --> 45:38.610
这个指令

45:39.610 --> 45:41.610
下一个von指令

45:41.610 --> 45:43.610
von指令叫绑定事件

45:43.610 --> 45:44.610
你看

45:44.610 --> 45:45.610
我之前用过了

45:45.610 --> 45:46.610
说在这

45:46.610 --> 45:47.610
那么这个完整的下方

45:47.610 --> 45:48.610
应该是这样子

45:48.610 --> 45:50.610
von冒号click

45:50.610 --> 45:52.610
是应该是这样子的

45:52.610 --> 45:54.610
这叫

45:54.610 --> 45:55.610
绑定事件

45:55.610 --> 45:57.610
指令参数是世界名

45:57.610 --> 45:58.610
von冒号

45:58.610 --> 46:00.610
冒号是指令参数世界名

46:00.610 --> 46:02.610
那么可以简写为

46:03.610 --> 46:06.050
id

46:06.050 --> 46:07.050
这种意思

46:07.050 --> 46:08.050
可以简写为id

46:08.050 --> 46:09.050
那么这里呢

46:09.050 --> 46:10.050
就可以使用一个方法

46:10.050 --> 46:11.050
可以直接写代码

46:11.050 --> 46:12.050
比如说

46:12.050 --> 46:14.050
比方说你做的事情很小

46:14.050 --> 46:16.050
一句话就可以解决

46:16.050 --> 46:17.050
可以直接把代码写到刷

46:17.050 --> 46:18.050
也可以呢

46:18.050 --> 46:19.050
调用一个方法

46:19.050 --> 46:20.050
方法有几个参数

46:20.050 --> 46:21.050
去传进去玩刷

46:22.050 --> 46:23.050
对不对

46:23.050 --> 46:24.050
这是事件

46:24.050 --> 46:26.420
好了

46:26.420 --> 46:27.420
无办我就解释完了

46:27.420 --> 46:28.420
无非就是一个内容

46:28.420 --> 46:29.420
一个指

46:29.420 --> 46:30.420
一个内容大呼之余法

46:30.420 --> 46:31.420
然后一些指令

46:31.420 --> 46:32.420
指令有很多

46:32.420 --> 46:34.420
我们目前介绍了三个

46:34.420 --> 46:35.420
vband

46:36.420 --> 46:37.420
v4

46:37.420 --> 46:38.420
和

46:38.420 --> 46:39.420
von

46:39.420 --> 46:42.060
好 下面

46:42.060 --> 46:43.060
配置

46:43.060 --> 46:44.060
配置

46:44.060 --> 46:45.060
我们都讲完了

46:45.060 --> 46:47.060
我们就是要过一下就行了

46:47.060 --> 46:48.060
data是什么

46:48.060 --> 46:49.060
和界面相关的数据

46:50.060 --> 46:51.060
边看

46:51.060 --> 46:52.060
往下面看

46:52.060 --> 46:54.060
这是跟界面相关的数据

46:54.060 --> 46:56.060
这是挂载的目标

46:56.060 --> 46:57.060
这个玩意

46:57.060 --> 46:58.060
目前不涉及

46:58.060 --> 47:00.060
我们将来再说

47:00.060 --> 47:01.060
这个是里面一些

47:01.060 --> 47:02.060
常用的操作方法

47:03.060 --> 47:05.060
它不一定是跟事件相关

47:05.060 --> 47:06.060
有可能有些

47:06.060 --> 47:07.060
我们要

47:07.060 --> 47:08.060
初始的时候要做一些事

47:08.060 --> 47:09.060
我们可以把形成一些方法

47:09.060 --> 47:10.060
以后都会见到的

47:11.060 --> 47:12.060
这方法

47:12.060 --> 47:13.060
还有就是render

47:13.060 --> 47:14.060
templator

47:14.060 --> 47:15.060
templator是配置模办

47:15.060 --> 47:16.060
如果说没有这个配置的话

47:16.060 --> 47:17.060
它可以从

47:18.060 --> 47:19.060
上面去读

47:19.060 --> 47:20.060
会从这里去读

47:21.060 --> 47:22.060
render就是

47:22.060 --> 47:23.060
渲染方法

47:23.060 --> 47:24.060
我们一般不会写的

47:24.060 --> 47:25.060
它主要是用于

47:25.060 --> 47:26.060
居东生产微漏的

47:27.060 --> 47:28.060
如果说没有它的话

47:28.060 --> 47:29.060
它会重配

47:29.060 --> 47:30.060
templator

47:30.060 --> 47:31.060
会从这上面

47:31.060 --> 47:32.060
去找到个模办

47:32.060 --> 47:33.060
编印成为render

47:34.060 --> 47:36.060
eo就是挂载的目标

47:36.060 --> 47:37.060
就这么几个配置

47:38.060 --> 47:39.060
这就是这几颗的内容

47:39.060 --> 47:40.060
那么这几颗学完了过后

47:41.060 --> 47:42.060
没有什么

47:42.060 --> 47:43.060
就是鞋带把的作业

47:44.060 --> 47:45.060
作业只有一个

47:45.060 --> 47:46.060
把我这几颗

47:46.060 --> 47:47.060
讲的远利性的东西

47:48.060 --> 47:49.060
在脑袋里面过一遍

47:50.060 --> 47:51.060
到底怎么回事

47:51.060 --> 47:52.060
它整个渲染流程是什么

47:52.060 --> 47:53.060
先做什么

47:53.060 --> 47:54.060
先生成实力

47:54.060 --> 47:55.060
再进行注入

47:55.060 --> 47:56.060
把那个流程搞清楚

47:56.060 --> 47:57.060
第二件事

47:58.060 --> 47:59.060
脑袋里面回忆一下

48:00.060 --> 48:02.060
模板里面有哪些指令

48:02.060 --> 48:03.060
每个指令干嘛呢

48:04.060 --> 48:05.060
然后配置里面有哪些

48:05.060 --> 48:06.060
我们目前学过的配置

48:06.060 --> 48:07.060
每个配置干嘛用的

48:08.060 --> 48:09.060
脑袋里面回忆一下

48:09.060 --> 48:10.060
你觉得OK了

48:10.060 --> 48:11.060
我们进入下节课

48:12.060 --> 48:13.060
这就是这节课的内容

