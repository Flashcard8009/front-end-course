WEBVTT

00:00.000 --> 00:05.640
相信写到这呢 很多小伙伴呢 就已经迫不及待的 想把这个首页给他做完了

00:06.920 --> 00:18.440
你看 我们现在呢 有路由了 对吧 可以切换页面 也有学新的咱们API啊 可以远程获取数据了 那首页可以做了呀 对吧 首页不就是那几个数据吗 那几个banner

00:18.700 --> 00:22.020
把获取到一个数组 然后循环渲染出一个首页就完事了

00:23.040 --> 00:26.360
但是啊 我们来做一下 你会发现还有问题

00:26.880 --> 00:29.960
你说这个代码往哪写的问题 你看吗

00:30.200 --> 00:35.520
我们现在进入到首页吧 到这了啊 咱们把这些东西弄去吧 去掉啊

00:36.480 --> 00:40.800
去掉 这些玩意儿都去掉 不要了啊 暂时不要了

00:42.560 --> 00:48.040
就这个首页摆这了 然后呢 我得循环那个banner对啊 上级口门是不是获取数据啊

00:48.720 --> 00:53.840
呃 获取数据这API banner不要了啊 把API banner呢 我们就在首页里边获取

00:54.800 --> 00:58.480
对吧 拿到这个函数啊 好 我们导入进来吧 import

01:00.880 --> 01:02.640
API banner

01:03.760 --> 01:05.360
然后这里呢 get banners

01:06.560 --> 01:11.680
啊 我们这个函数是不是有了 那有这个函数问题是现在你怎么调用 你说你写了

01:12.960 --> 01:19.760
你找了半天就不知道写了 那我说写这吧 那写这有啥用啊 你用个便当接受一下啊 banners

01:20.560 --> 01:23.360
呃 这个便当还没用 这是个promise 对吧 你还在这样子

01:23.840 --> 01:30.640
啊 这里z 拿到这个响应结果 而好 咱们来输出一下吧 那输出肯定是能输出的

01:31.920 --> 01:33.600
点击看一下空残 放心

01:35.280 --> 01:40.080
三秒钟 一到一到两秒钟 是不是拿到这个数据了 拿到这个数据怎么办嘛 你说怎么办嘛

01:41.280 --> 01:44.560
哎呦 到这里怎么弄的怎么怎么弄都不行

01:45.360 --> 01:50.960
那那一推说 那那那你这里只能循环 你要循环的话 比方了一个UOLI吧

01:51.920 --> 01:59.040
我要循环这个li 啊 生成把一般的数据 我现在都不去做什么效果 我就把般的数据显示到这行不行呢

01:59.280 --> 02:03.680
那你循环吧 你循环啥呀 你问的是你循环啥啊 你循环啥吧

02:04.560 --> 02:08.240
这个玩意儿的数据只能来自于主键实力 那主键实力就是这个空对象

02:09.200 --> 02:13.120
那怎么办嘛 来说这样子行不行呢 我这里给他一个delta

02:13.840 --> 02:17.520
啊 给他个delta 然后呢 delta里边呢 有一个数据

02:18.480 --> 02:20.800
这个数据呢 我们就把他叫做banners吧

02:21.600 --> 02:24.720
这个banners的数据来自于哪呢 来自于这个函数调整的结果

02:25.280 --> 02:27.680
哎 这个这个思路这个对不对呢 这个思路倒是对的

02:28.240 --> 02:33.280
那我们来调一下吧 那怎么弄嘛 你这个东西又怎么弄嘛 你这样子写完了过后能有效吗

02:34.080 --> 02:37.200
你觉得能有效吗 那我们啥都不做来循环一下吧 banners

02:38.080 --> 02:38.960
啊 循环一下

02:40.400 --> 02:42.000
呃 这个banners呢

02:43.040 --> 02:45.280
呃 我这里之前莫可数据的时候啊

02:45.840 --> 02:50.320
哦 有id啊 有id 那我们的数据呢 t字呢 就是他的id嘛 item.id

02:51.600 --> 02:52.480
那行吧 这样子

02:53.200 --> 02:56.320
也不行啊 这个玩意反回的是promise啊 你怎么循环啊

02:57.600 --> 02:59.440
你保存 你看 这不得爆错吗 这个

03:02.080 --> 03:04.880
倒是没爆错啊 倒是没爆错 因为promise是个对象

03:04.880 --> 03:08.160
promise对象呢 他这个玩意也可以循环对象的啊 循环对象的属性

03:08.160 --> 03:09.840
那promise是个对象里面没有属性

03:10.320 --> 03:12.160
就这个玩意拿到这个promise你怎么弄嘛

03:13.520 --> 03:15.520
你发现怎么都没办法了 这个玩意

03:16.480 --> 03:19.840
怎么都没办法了 因为他说那这个把这个data变成二sync

03:19.840 --> 03:24.720
那我这里等待一下行不行呢 挺好的思路啊 挺好的思路 那你觉得行吗

03:25.600 --> 03:30.480
你觉得行吗 你这样子以来反而是标记了而sync的函数

03:30.480 --> 03:32.080
他反回来一定是promise

03:32.960 --> 03:36.160
这个玩意只不过是promise成功之后的结果

03:36.720 --> 03:39.440
对吧 这个函数反回来一定是promise

03:39.440 --> 03:42.640
那你就相当于是 你这样子写的话 就相当于是这样子写的

03:43.600 --> 03:45.600
return new一个promise

03:46.480 --> 03:48.320
你觉得行吗 那肯定不行啊

03:49.360 --> 03:51.360
然后呢 有一个对象

03:53.600 --> 03:55.600
就是get banners z

03:56.560 --> 03:58.560
相当于是这样子写的 z

03:58.560 --> 04:00.560
R 反回来是一个对象

04:01.360 --> 04:05.040
对象的banners 你说这个玩意能行吗 肯定不行啊 你反回来是个promise

04:05.600 --> 04:07.600
promise里面没有属性啊

04:08.400 --> 04:10.800
那怎么弄的 这样子肯定也不行啊

04:11.280 --> 04:13.280
你写一下吧 肯定也不行啊

04:14.160 --> 04:17.040
保存 刷新 那不也有想法

04:18.080 --> 04:22.400
对不对 说这个东西没办法了 已经搞的 已经搞的没办法

04:23.360 --> 04:25.280
现在是这里头一个很严重的问题 就是

04:25.840 --> 04:29.280
我这个app写那的问题 我啥都准备好了 不着写那

04:30.480 --> 04:34.720
那怎么办呢 就需要我们策解课的知识啊 叫做组建的生命周期

04:36.960 --> 04:38.960
好 我们来看一下啊

04:38.960 --> 04:41.760
回顾一下咱们很早的时候学过的一张图

04:42.000 --> 04:44.000
这张图呢 我们再来重新把它看一下

04:44.720 --> 04:47.040
就是我们当我们溜一个五六的时候

04:47.360 --> 04:50.960
或者是当我们创建了一个组建的时候 在使用这个组建的时候

04:51.120 --> 04:55.040
它会创建一个实力 对吧 无论是溜五六创建一个五六应用

04:55.440 --> 04:58.960
或者是使用组建的时候 比方说我们这样子的使用组建

05:02.080 --> 05:06.640
就这么一个组建 那么是不是在使用组建 他会就创建这个组建的实力

05:07.760 --> 05:11.040
这个实力创建的过后呢 会经过一段很多的事情啊

05:11.120 --> 05:13.040
我们再回顾一下 首先是注入

05:14.080 --> 05:18.720
什么叫注入呢 就把这个组建里边 把组建里边的那些配置啊

05:18.960 --> 05:24.400
什么props啊 什么data啊 什么那个methods啊 还有computed啊这些东西啊

05:24.640 --> 05:26.880
提取到哪呢 提取到组建实力上面去

05:27.200 --> 05:32.080
然后呢 并且呢对data来进行想用式啊 完成想用式数据的设置

05:32.720 --> 05:36.800
对吧 这叫注入 诶 注入完成过后呢 是不是要编译生成蓄力动物数

05:37.520 --> 05:40.640
得去生成vload嘛 对不对 生成蓄力动物数

05:41.200 --> 05:43.520
然后呢 生成蓄力动物数过后呢 还得挂载

05:44.320 --> 05:47.680
对不对 挂载就是生成真实动物 到了页面上去

05:48.320 --> 05:49.360
对吧 进行挂载

05:50.320 --> 05:51.920
然后呢 进入以挂载的状态

05:52.480 --> 05:55.200
好 接下来呢 就是如果说我们的数据变动了 那么

05:55.600 --> 05:58.640
他会重新生成蓄力动物数啊 还我们当时还说了

05:58.880 --> 06:01.680
甚至跟把这个新旧两颗数呢 进行对比

06:02.320 --> 06:06.000
对不对 还记得吧 怎么来生成蓄力动物数 是不是调一千的

06:06.160 --> 06:09.840
先看一下有没有rander方法啊 那就有的话就调用rander方法来

06:09.920 --> 06:13.920
直接得到蓄力动物数 如果说没有的话 那么就去找什么template配置

06:14.240 --> 06:16.720
如果说template配置也没有的话 那么就是有eL

06:16.720 --> 06:20.400
不过eL这个配置呢 只有5件 5u的根实力是有的啊

06:20.560 --> 06:23.840
就5u应用 6u那个时候才能配置eL

06:24.160 --> 06:25.440
组件里面是不能配置的啊

06:26.640 --> 06:29.200
如果说有template的话 那么就直接编印成rander

06:29.440 --> 06:34.080
像我们这个在单组件应用里面呢 他肯定是没有template的啊

06:34.080 --> 06:36.000
写的时候有 但是呢一编印完成

06:36.400 --> 06:38.480
他就变成了rander还出了啊 这是我们讲过的

06:40.000 --> 06:41.120
总之就是这么一个过程

06:43.360 --> 06:46.480
然后呢 这节课呢 我们要把详细的把这个过程展开

06:46.960 --> 06:47.840
在5u里边

06:48.480 --> 06:52.800
因为他考虑到我们有可能在一个组件的某一个阶段

06:53.440 --> 06:56.320
要做一些额外的事情 比方说我们刚才就有一个需求

06:56.720 --> 06:58.880
我希望这个组件创建好了之后

06:59.680 --> 07:02.640
比方说在完成了注入之后

07:03.840 --> 07:06.080
那么我们就可能会去加载一些

07:06.880 --> 07:11.760
一部数据 比方说像远程的APN去拿到的数据 在这里在这个地方进行加载

07:12.560 --> 07:16.480
那么他就需要5u呢 给我们提供一些勾字函数

07:18.000 --> 07:18.640
叫做hooks

07:19.840 --> 07:20.480
勾字函数

07:22.990 --> 07:27.950
这个hooks呢 在不同的语境下边是有不同的意思的啊 这里呢表示勾字函数

07:28.510 --> 07:33.870
什么叫勾字函数呢 就是说这个地方呢 有一个扩展点 你在这里呢 可以去做一些事情

07:34.990 --> 07:37.390
那么这里呢 可以通过一个函数的配置去完成

07:38.430 --> 07:38.910
原来的意思吧

07:40.110 --> 07:43.230
5u实际上有给我们提供这些勾字函数 看下面这张图

07:44.030 --> 07:48.670
这就是5u的 组件的详细生命周期 也就是5u实力的详细生命周期

07:49.310 --> 07:54.910
当我们去6一个5u 或者是使用一个组件的时候 那么这个组件呢 会被 实力会被创建

07:55.070 --> 07:57.390
第一次使用的时候啊 组件会实力会被创建

07:57.950 --> 08:01.710
然后呢 在这个时候呢 他就会运行一个勾字函数 叫做befall create

08:02.270 --> 08:03.870
那么这个勾字函数写哪呢

08:04.830 --> 08:07.630
直接写到 直接写到组件配置里边去

08:09.390 --> 08:11.390
比方说这里befall create

08:12.110 --> 08:13.630
就这样配置 对吧

08:14.430 --> 08:17.150
所以说我们这几颗呀 会多很多的组件配置

08:18.350 --> 08:22.350
就是其实都是一个意思 表示生命周期勾字函数有这么一些

08:22.590 --> 08:23.550
我们一个个看啊

08:23.950 --> 08:28.430
befall create 我们这里输出一下 before 看这个这个函数有没有执行

08:29.550 --> 08:29.950
create

08:30.670 --> 08:31.070
保存

08:31.790 --> 08:32.590
这边过来

08:33.150 --> 08:33.630
刷新

08:36.190 --> 08:38.750
这里就包错了啊 写真这吧

08:39.790 --> 08:40.030
刷新

08:40.270 --> 08:43.970
是不是输出了 before create

08:44.610 --> 08:45.890
说明这个函数运行了

08:46.130 --> 08:49.730
那么这个函数的运行时间点是什么呢 是实力被创建之后

08:49.970 --> 08:51.010
并且在注入之前

08:52.290 --> 08:54.850
那么在注入之前是有一个什么样的效果的

08:55.090 --> 08:58.690
注入我们知道什么意思 这过去的一些核心概念要用起来了

08:59.970 --> 09:01.010
什么叫注入

09:01.170 --> 09:01.970
什么叫注入

09:02.210 --> 09:06.850
是不是要完成数据响应式 并把这些响应式的数据提到了呢 提到就实力里面去

09:07.090 --> 09:08.770
它是在注入之前发生的

09:09.010 --> 09:11.410
因此呢 这个函数里边 假如说啊

09:12.210 --> 09:13.010
看大家理解

09:13.970 --> 09:16.050
比方说我们有个data data里边有一个banders

09:16.770 --> 09:17.810
比方说给空数组

09:19.410 --> 09:22.690
在befall create里边 我们要得到这个z点banders

09:22.930 --> 09:24.370
能不能拿到

09:24.770 --> 09:26.930
在这个地方去拿这个banders 能不能拿到呢

09:27.810 --> 09:28.930
是不是拿不到啊这个时候

09:29.410 --> 09:30.770
好 保存咱们来看一下啊

09:31.170 --> 09:31.730
刷新

09:32.210 --> 09:33.010
是不是undefined

09:33.410 --> 09:36.770
我们这里比如说明明写的这个banders是吗 为什么是undefined呢

09:37.810 --> 09:39.970
因为这个时候呢 还没有完成注入

09:40.210 --> 09:41.890
实力里边根本就没有这个

09:42.130 --> 09:43.330
没有提取到实力

09:43.570 --> 09:44.850
并且没有响应式

09:45.330 --> 09:47.730
所以说呢 你这里去获取这些数据啊 都获取不到了

09:48.530 --> 09:49.330
明儿的意思吧

09:50.130 --> 09:51.730
好 有了注入过后呢

09:51.970 --> 09:54.530
这个时候呢 就有响应式了 并且实际上也有了

09:54.530 --> 09:57.170
这个时候会触发这个勾字函数 叫created

09:58.610 --> 09:59.570
created

10:00.290 --> 10:01.010
这个勾字函数

10:01.490 --> 10:04.690
那么在这个勾字函数里边 你就可以拿到这些响应式数据了

10:04.690 --> 10:07.010
created 你看一下 现在就不一样了

10:07.490 --> 10:07.970
刷新

10:08.690 --> 10:09.730
然后第一个是undefined

10:09.730 --> 10:11.330
那后边是不是又拿到一个数组了

10:11.330 --> 10:12.930
这个数组长度为0 空的

10:13.810 --> 10:15.330
看到没 就这个函数

10:15.730 --> 10:16.930
那么接下来继续啊

10:16.930 --> 10:18.130
但是这个时候呢

10:18.130 --> 10:19.490
它是在什么之前呢

10:19.490 --> 10:21.010
它是在生成vnode之前

10:21.330 --> 10:22.610
它还没有蓄力节点

10:23.570 --> 10:25.730
那么没有蓄力节点 那肯定是没有真实动

10:26.050 --> 10:26.450
对不对

10:26.450 --> 10:28.450
那么这个时候呢 还是比较早期的啊

10:28.530 --> 10:29.970
连是蓄力节点都没有生成

10:30.770 --> 10:32.690
好 然后呢才蓄力生成蓄力节点

10:32.690 --> 10:33.890
生成了蓄力节点过后呢

10:33.890 --> 10:35.810
还会触发这个函数 叫beformount

10:36.290 --> 10:37.970
这什么之前呢 在mount之前

10:37.970 --> 10:38.690
mount什么意思

10:38.930 --> 10:39.410
挂载

10:39.730 --> 10:40.610
挂载之前

10:41.170 --> 10:43.090
也就是挂载之前是一个什么状态呢

10:43.090 --> 10:44.610
这个时候有了蓄力节点

10:44.610 --> 10:47.170
但是呢 你看生成vnode就在这

10:47.170 --> 10:49.090
对应之前的 别意蓄力动物数

10:49.090 --> 10:50.130
生成vnode

10:50.690 --> 10:51.570
然后呢

10:51.570 --> 10:52.770
挂载什么意思啊

10:52.770 --> 10:54.290
挂载的就是生成真实动物

10:54.290 --> 10:56.370
也就是在这个函数里面是没有真实动物的

10:56.770 --> 10:58.370
你看啊 先运行这个 再运行这个

10:58.530 --> 11:01.090
然后呢 再运行beformount

11:03.410 --> 11:04.370
我们来看一下

11:04.370 --> 11:05.570
在这里边是没有

11:06.370 --> 11:08.290
比方说这里个div嘛 给它个id

11:08.290 --> 11:09.490
id为test

11:09.810 --> 11:10.930
我们来看一下啊

11:10.930 --> 11:12.690
document gets element by id

11:14.880 --> 11:16.400
那么这个时候肯定是有banus的

11:16.400 --> 11:18.400
banus在quaddy的时候就有了

11:18.400 --> 11:19.680
后边肯定也有了

11:19.680 --> 11:20.880
beformount

11:21.280 --> 11:22.800
那么这个时候我们来获取一下

11:23.280 --> 11:25.520
document gets element by id

11:26.080 --> 11:26.720
test

11:27.040 --> 11:28.160
看一下能不能获取

11:29.200 --> 11:29.840
刷新

11:30.560 --> 11:32.240
刷到啊 获取不到啊

11:32.240 --> 11:34.400
因为这个时候还没有真实的动物节点

11:35.280 --> 11:37.440
如果说你要在真实动物节点生成之前

11:37.440 --> 11:38.160
可以做一些事情

11:38.160 --> 11:39.680
那可以使用这三个

11:39.920 --> 11:40.480
对吧

11:40.480 --> 11:41.600
然后呢 最后呢

11:41.600 --> 11:43.440
这个时候呢 才进行挂载

11:43.440 --> 11:45.600
挂载完了过后才有真实的节点

11:45.600 --> 11:47.760
这个时候会触发mounted

11:49.040 --> 11:50.400
好 我们来看mounted

11:52.960 --> 11:53.520
好 输出

11:54.240 --> 11:55.120
mounted

11:55.120 --> 11:57.680
那么这个时候就有虚力动物节点了

11:57.680 --> 12:00.160
document gets element by id

12:01.120 --> 12:02.000
test

12:02.000 --> 12:02.560
看一下吧

12:03.840 --> 12:04.320
刷新

12:04.960 --> 12:07.200
你看这个时候是不是就有这个div了

12:07.200 --> 12:09.920
就能得到动物元素了

12:09.920 --> 12:10.800
如果说有的时候呢

12:10.800 --> 12:12.640
你要得到一些对动物进行操作

12:12.640 --> 12:13.920
拿到动物元素的话

12:13.920 --> 12:15.040
那么就可以在这里做

12:15.040 --> 12:16.000
当然这也包括呢

12:16.000 --> 12:16.720
我们使用ref

12:16.720 --> 12:17.600
我们学过的ref

12:18.160 --> 12:19.200
比方说ref

12:19.200 --> 12:20.960
这里呢我们也是用container吧

12:22.240 --> 12:23.840
比方有这么个例子

12:23.840 --> 12:25.040
ref里面有container

12:25.040 --> 12:25.920
那么如果说过来

12:25.920 --> 12:26.800
这里去拿这个ref

12:26.800 --> 12:27.600
能不能拿到

12:28.880 --> 12:29.280
ref

12:29.920 --> 12:30.400
container

12:30.400 --> 12:31.040
能不能拿到呢

12:32.990 --> 12:33.710
拿不到

12:33.710 --> 12:34.510
为什么拿不到呢

12:34.510 --> 12:35.710
因为这个要生成了

12:35.710 --> 12:37.390
因为这个东西拿到的是什么

12:37.390 --> 12:38.430
是一个真实的动物

12:38.430 --> 12:39.070
对不对

12:39.070 --> 12:40.110
但是呢这个时候真实的动物

12:40.110 --> 12:40.990
生成出来没有

12:40.990 --> 12:42.110
还没有生成出来

12:42.110 --> 12:43.150
所以这个时候拿不到

12:43.150 --> 12:44.750
但是呢在下边这个mounted里边

12:44.750 --> 12:45.470
是不是可以拿到了

12:46.030 --> 12:46.990
好 咱们来看一下啊

12:47.630 --> 12:48.030
刷新

12:48.670 --> 12:50.030
你看这是undefined

12:50.030 --> 12:50.590
没拿到

12:50.590 --> 12:51.470
但是呢mounted里边

12:51.470 --> 12:52.590
是不是可以拿到了

12:53.470 --> 12:54.990
好 就是神明周期勾字函说

12:54.990 --> 12:56.110
不同的阶段可以

12:56.110 --> 12:56.990
你可以去做一些

12:56.990 --> 12:58.030
自己想要做的事情

12:58.990 --> 13:00.510
然后后面就是已挂载状态了

13:00.510 --> 13:01.790
就已经挂载好了

13:01.790 --> 13:02.750
等待用户操作

13:02.750 --> 13:03.710
等待用户点击

13:03.710 --> 13:04.830
还有什么东西啊

13:04.830 --> 13:06.190
总之呢有可能

13:06.190 --> 13:08.110
数据发生变动在中途

13:08.110 --> 13:09.150
发生了变动过后呢

13:09.150 --> 13:10.270
他要进行重新宣展

13:10.270 --> 13:10.990
什么叫重新宣展

13:10.990 --> 13:11.790
就这三步

13:12.430 --> 13:12.910
不再说了

13:13.870 --> 13:15.070
重新宣展的时候呢

13:15.070 --> 13:16.110
太之前

13:16.110 --> 13:16.910
他要去

13:16.910 --> 13:18.270
他会调用一个勾字函说的

13:18.270 --> 13:19.470
beforeupdate

13:20.510 --> 13:21.630
重新宣展之前

13:21.630 --> 13:22.910
会调用这个beforeupdate

13:23.870 --> 13:25.870
好 比方说我们这里写一个啊

13:25.870 --> 13:27.070
beforeupdate

13:28.670 --> 13:31.230
输出beforeupdate

13:32.510 --> 13:34.190
这里当我们随便拿一个数据吧

13:34.190 --> 13:34.510
caught

13:35.630 --> 13:37.710
下面一个按钮点击过后

13:37.710 --> 13:41.070
再增加caught加1

13:43.360 --> 13:44.320
输出数据变动

13:45.040 --> 13:46.160
caught加加

13:47.920 --> 13:48.240
好了

13:48.240 --> 13:49.200
那么这个时候呢

13:49.200 --> 13:50.400
每调用一次加加

13:50.400 --> 13:52.160
你看一下这个函数有没有运行

13:52.160 --> 13:52.640
保存

13:52.640 --> 13:53.040
刷新

13:55.630 --> 13:56.350
每调用一次

13:58.110 --> 13:59.390
我一边上没显示

13:59.950 --> 14:01.070
我一边上没显示

14:01.150 --> 14:01.790
显示一个吧

14:02.430 --> 14:02.830
caught

14:03.950 --> 14:04.670
因为不行

14:04.670 --> 14:06.510
一面上没有用到这个数据的话

14:06.510 --> 14:08.590
那么他就表示这个页面呢

14:08.590 --> 14:09.790
对这个数据没有依赖

14:09.790 --> 14:10.750
没有依赖的话

14:10.750 --> 14:12.430
他就不会引发重新宣展

14:13.710 --> 14:14.510
好 再来

14:15.470 --> 14:15.790
加1

14:15.790 --> 14:16.430
你看

14:16.430 --> 14:18.110
所以调用这个方案还说加1

14:18.670 --> 14:19.870
每一次数据变动

14:20.430 --> 14:22.190
他会重新宣展

14:22.190 --> 14:22.990
重新宣展之前

14:22.990 --> 14:24.510
他会调用beforeupdate

14:24.510 --> 14:25.070
那么这个时候

14:25.070 --> 14:26.990
由于他在重新宣展之前

14:26.990 --> 14:28.910
如果说你这个时候去拿之前的

14:29.630 --> 14:31.870
拿这个元素的话

14:31.870 --> 14:34.350
可能是拿到还是之前的元素

14:34.350 --> 14:35.470
之前的结果

14:35.470 --> 14:37.310
比方说我们去拿这个aq

14:37.310 --> 14:38.510
给这个aq一个wrap

14:39.550 --> 14:39.950
title

14:41.150 --> 14:41.790
9个例子吧

14:42.910 --> 14:44.670
如果说我们这里去拿这个z

14:44.670 --> 14:45.230
wraps

14:45.710 --> 14:46.190
title

14:46.190 --> 14:48.270
叫做inner text

14:48.270 --> 14:48.990
拿到是什么呢

14:51.150 --> 14:52.270
拿到还是之前的

14:52.910 --> 14:53.630
点击

14:53.630 --> 14:54.430
你看是不是0

14:54.990 --> 14:55.550
对吧

14:55.550 --> 14:56.430
拿的是之前的

14:57.150 --> 14:58.030
再点击

14:58.030 --> 14:59.230
1是不是拿到之前的

15:00.110 --> 15:01.950
如果说你这里是操作动物元素的话

15:01.950 --> 15:03.310
拿的是之前的动物元素

15:04.030 --> 15:04.750
原来是吧

15:04.750 --> 15:07.150
因为它是在重新宣展之前

15:07.150 --> 15:08.030
还没有宣展

15:08.030 --> 15:10.110
但是这个时候数据是已经更新了

15:10.110 --> 15:11.150
数据肯定是更新了

15:12.350 --> 15:13.950
因为你是改动了数据过后

15:14.590 --> 15:15.790
才引发的重新宣展

15:15.790 --> 15:16.190
对吧

15:16.190 --> 15:18.030
所以说这个时候数据肯定是更新了

15:18.030 --> 15:19.150
那么我们来看一下靠准

15:22.880 --> 15:23.360
点击

15:23.360 --> 15:25.120
所以靠准数据是更新了的

15:25.120 --> 15:25.840
但是呢

15:25.840 --> 15:27.280
见面还是之前的见面

15:28.720 --> 15:28.960
好

15:28.960 --> 15:30.640
然后接下来是update

15:30.640 --> 15:31.760
update

15:32.160 --> 15:33.680
就是在更新之后

15:33.680 --> 15:34.560
重新宣展之后

15:34.560 --> 15:35.680
它会触发这个函数

15:35.680 --> 15:36.640
这个构置函数

15:36.640 --> 15:37.440
那么我们输出一下

15:39.550 --> 15:40.110
update

15:40.830 --> 15:42.590
这里我们还是一样吧

15:42.590 --> 15:43.950
就把这三个过去到

15:43.950 --> 15:44.590
好

15:44.590 --> 15:44.830
好

15:46.030 --> 15:46.350
小心

15:48.030 --> 15:48.590
点击

15:48.590 --> 15:49.070
你看

15:49.070 --> 15:49.950
update的过后了

15:49.950 --> 15:52.030
是不是见面就已经雄性宣展好了

15:52.030 --> 15:52.750
那么这个时候呢

15:52.750 --> 15:53.870
一去获取动物元素的话

15:53.870 --> 15:55.310
获取的是最新的动物元素

15:56.030 --> 15:57.070
就这么个意思

15:58.190 --> 15:59.870
然后又回到以外的状态

15:59.870 --> 16:00.270
然后呢

16:00.270 --> 16:01.710
接下来如果说数据再点一下

16:01.710 --> 16:02.350
不要再点一下

16:02.350 --> 16:03.390
把数据又变动了

16:03.390 --> 16:04.510
又来一次这个过程

16:05.070 --> 16:06.510
看来就在这里反复的

16:06.510 --> 16:08.190
转圈圈循环

16:09.310 --> 16:11.550
直到有一天这个组件不用了

16:11.550 --> 16:13.070
有一天这个组件不用了

16:13.070 --> 16:14.830
那么它会进行销毁组件

16:14.830 --> 16:15.550
销毁的时候呢

16:15.550 --> 16:16.510
不用在内部啊

16:16.510 --> 16:17.550
会做很多事情

16:18.190 --> 16:19.870
那么在做这些事情之前呢

16:19.870 --> 16:21.150
它会先触发before

16:21.150 --> 16:21.870
destroy

16:21.870 --> 16:23.070
然后销毁完了之后呢

16:23.070 --> 16:24.510
会触发destroy的

16:24.510 --> 16:24.830
好

16:24.830 --> 16:26.190
咱们来写下这两个函数啊

16:27.630 --> 16:28.190
before

16:28.750 --> 16:29.550
destroy

16:30.510 --> 16:31.870
我这里输出

16:31.870 --> 16:32.830
before

16:32.830 --> 16:34.030
destroy

16:34.030 --> 16:35.470
这两个还说里面

16:35.470 --> 16:36.830
我们也没什么事情可以干

16:36.830 --> 16:37.870
destroy

16:37.870 --> 16:39.310
输出

16:39.310 --> 16:41.310
destroy

16:41.310 --> 16:44.670
那么什么情况下组件会被销毁呢

16:44.670 --> 16:47.230
就这个组件在界面上已经不用了

16:48.190 --> 16:50.030
比方说我们用vif的时候

16:50.030 --> 16:51.870
一开始这个组件好好的

16:51.870 --> 16:52.590
vif

16:52.590 --> 16:53.550
一开始等于

16:53.550 --> 16:54.510
它的值

16:54.510 --> 16:55.870
一个表达式的值等于处

16:55.870 --> 16:57.310
那么这个组件是好好的

16:58.270 --> 17:01.710
突然有一天这个vif变成force了

17:01.710 --> 17:02.990
那么这个组件是不是没用了

17:03.630 --> 17:04.910
因为我们知道vif就表示

17:04.910 --> 17:05.950
要不要渲染这个组件

17:05.950 --> 17:06.750
它不渲染了

17:06.750 --> 17:08.030
那么这个组件就消失了

17:08.030 --> 17:09.870
消失的时候它就会消毁

17:09.870 --> 17:11.550
消毁的时候就会雕用这两个

17:11.550 --> 17:12.590
先后雕用这两个

17:13.150 --> 17:13.790
勾字函数

17:14.830 --> 17:15.230
好

17:15.230 --> 17:16.270
那咱们来看一下吧

17:16.270 --> 17:17.310
那么我们这个界面上

17:17.310 --> 17:17.950
怎么来消毁呢

17:17.950 --> 17:18.990
其实就是切换页面

17:19.950 --> 17:22.510
因为在ViuRotar这个路由里边呢

17:22.510 --> 17:24.270
它当它发现不同的地址的时候呢

17:24.910 --> 17:26.510
那么它会给你渲染不同的组件

17:26.590 --> 17:27.310
之前没有

17:27.310 --> 17:28.190
之前现在的组件呢

17:28.190 --> 17:29.710
它就会给你消毁掉

17:29.710 --> 17:30.910
所以我们这里电文章

17:30.910 --> 17:31.310
你看一下

17:32.350 --> 17:33.710
是不是之前那个Home组件

17:34.430 --> 17:35.550
这两个还是有明显的

17:36.190 --> 17:36.510
对吧

17:36.510 --> 17:37.310
这是组件的消费

17:38.430 --> 17:38.670
好

17:38.670 --> 17:40.670
这是组件的生命周期里边

17:40.670 --> 17:41.790
整个的生命周期

17:41.790 --> 17:43.230
好好去梳理一下

17:43.230 --> 17:43.950
每一个阶段

17:43.950 --> 17:45.470
它都会给你出发一些勾字函数

17:46.190 --> 17:47.710
其实这里边很多的勾字函数

17:47.710 --> 17:49.950
我们平时都不太用得到

17:49.950 --> 17:51.390
用的最多的呢

17:51.390 --> 17:52.350
是这么几个

17:52.350 --> 17:53.390
我们来看常见应用

17:54.350 --> 17:55.950
注意注意注意常见的

17:55.950 --> 17:56.670
首先说一下

17:56.670 --> 17:58.990
我这里举了三个常见应用的例子

17:58.990 --> 18:01.390
但是不是说你们以后只会遇到这三种

18:02.590 --> 18:04.270
将来呢遇到不同的情况了

18:04.270 --> 18:05.470
不要去使经营用备

18:05.470 --> 18:07.550
这些情况都不是说一定的

18:08.510 --> 18:10.430
要根据具体的情况去灵活处理

18:10.430 --> 18:11.950
关键是看懂上面那个图

18:12.430 --> 18:13.950
根据情况自己去灵活处理

18:13.950 --> 18:15.390
每个阶段可以做什么事情

18:15.950 --> 18:17.230
我举个三个例子啊

18:17.230 --> 18:19.150
最常见的就是加载远程数据

18:19.150 --> 18:20.110
用我们刚才的例子

18:20.590 --> 18:21.950
加载远程数据呢

18:22.910 --> 18:23.950
我们怎么来操作呢

18:23.950 --> 18:24.510
你看着啊

18:24.510 --> 18:25.630
我们可以这样操作

18:25.630 --> 18:27.550
我们把这个代码就复制一下了吧

18:28.190 --> 18:29.950
下体可有一把删掉

18:31.390 --> 18:31.710
好

18:31.710 --> 18:32.830
我们回到这来

18:33.470 --> 18:35.150
比方说没这里一个Banus对吧

18:35.790 --> 18:37.150
一个Banus远程数据

18:37.950 --> 18:38.990
我们这里vf

18:39.550 --> 18:41.150
我现在直接显示个长度吧

18:42.350 --> 18:46.620
尤其Banus这个数据的长度

18:46.620 --> 18:48.940
我们可以先给它一个空数组

18:50.300 --> 18:51.020
默认值嘛

18:51.020 --> 18:51.740
一个空数组

18:52.460 --> 18:54.460
表示我这个时候远程数据还没有加载过来

18:54.460 --> 18:56.860
一开始的远程数据加载是不是要一段时间

18:56.860 --> 18:57.180
对吧

18:57.180 --> 18:58.460
一开始没有加载过来

18:58.460 --> 18:59.580
那么自然是空数组

19:00.380 --> 19:01.900
一开始给它空数组

19:01.900 --> 19:03.580
然后什么时候去加载呢

19:03.580 --> 19:05.260
我们就可以在created里面

19:05.260 --> 19:06.940
你看一下这个时间点啊

19:06.940 --> 19:08.540
我们尽早的去加载这个数据

19:09.420 --> 19:09.740
created

19:10.300 --> 19:12.860
因为为什么不在before creator里面呢

19:12.860 --> 19:13.180
其实

19:14.140 --> 19:14.940
也可以啊

19:14.940 --> 19:16.060
也不是不可以

19:16.060 --> 19:18.140
这不before creator呢太早了

19:18.700 --> 19:19.900
那个时候呢得想

19:19.900 --> 19:21.260
连注入都没有发生

19:21.580 --> 19:23.100
连数据注入都没有发生

19:23.100 --> 19:24.300
那么那个时候如果说

19:24.300 --> 19:26.700
你要在函数里面去用当前

19:26.700 --> 19:28.220
当前data里面的一些数据啊

19:28.220 --> 19:29.580
比方说当前有分页

19:29.580 --> 19:32.300
第1页目前每页显示10条

19:32.300 --> 19:33.900
这些数据你是过去不到的

19:33.900 --> 19:35.820
因为它没有的提取到

19:35.820 --> 19:36.940
组建实力里面去

19:36.940 --> 19:37.820
所以说通常了

19:37.820 --> 19:38.620
不会用这个

19:38.620 --> 19:40.380
我们会有帮到这个created里面

19:41.340 --> 19:42.620
这里的created

19:44.300 --> 19:45.100
这里干嘛呢

19:45.100 --> 19:46.300
我是不是要调用这个方法

19:46.300 --> 19:48.060
getBanus远程数据的方法

19:48.060 --> 19:48.780
它是一个异步的

19:48.780 --> 19:50.940
所以说可以把它做成一个异步函数

19:51.260 --> 19:53.180
因为它不需要返回任何东西

19:53.180 --> 19:54.700
所以说返回ProBase

19:54.700 --> 19:56.380
会返回一个nth范围无所谓的

19:57.180 --> 19:58.780
好await 是不是等待

19:58.780 --> 19:59.660
等待一下

19:59.660 --> 20:00.460
是不是拿到一个数组

20:00.460 --> 20:01.340
拿到一个Banus数组

20:01.340 --> 20:02.060
我们上点课写的

20:02.060 --> 20:02.380
对吧

20:02.380 --> 20:04.860
然后我重新给数据复制

20:04.860 --> 20:06.380
好 咱们来梳理一下这个过程啊

20:07.500 --> 20:07.980
看首页

20:08.860 --> 20:09.260
刷新

20:11.180 --> 20:11.980
是不是0

20:11.980 --> 20:12.700
一开始是0

20:12.700 --> 20:13.660
然后变成三个

20:14.380 --> 20:15.020
对不对

20:15.020 --> 20:16.860
好 那么整个过程是什么呢

20:16.860 --> 20:18.140
看这个图啊

20:18.140 --> 20:20.860
首先发生的是created的方法

20:21.260 --> 20:22.060
运行到这个方法

20:22.860 --> 20:24.140
这个方法是不是要等待啊

20:24.140 --> 20:25.180
它是个异步方法

20:25.180 --> 20:26.860
那么我们可以说夸张一点

20:26.860 --> 20:27.820
它要等待一年

20:28.380 --> 20:29.420
它等到一年的话

20:29.420 --> 20:30.780
那不是不是时间很长

20:30.780 --> 20:31.580
那这里要等吗

20:32.300 --> 20:33.020
这里要等吗

20:33.020 --> 20:34.140
不会等啊

20:34.140 --> 20:36.140
异步的就是让它异步去做就行了

20:36.140 --> 20:37.500
异步无非就是个回调函数

20:37.500 --> 20:39.580
这个只是一个与法堂恶意

20:39.580 --> 20:41.660
它最终的就是真实的单码

20:41.660 --> 20:42.300
应该是这样子的

20:45.920 --> 20:46.480
this

20:46.480 --> 20:46.960
Banus

20:47.760 --> 20:48.000
对吧

20:48.000 --> 20:48.800
这个回调函数

20:48.800 --> 20:50.080
等它拿到数据过后

20:50.080 --> 20:51.600
它自然会运行这个回调函数

20:52.400 --> 20:53.280
你要那意思吧

20:53.360 --> 20:54.080
所以说呢

20:54.080 --> 20:54.880
这里它不会等

20:54.880 --> 20:56.320
它会继续往后走

20:56.320 --> 20:57.760
运行before mount

20:57.760 --> 20:58.480
你没有

20:58.480 --> 20:59.440
运行mounted

20:59.440 --> 21:00.000
没有

21:00.000 --> 21:01.040
然后变成挂载状态

21:01.040 --> 21:01.760
这个时候等着了

21:01.760 --> 21:02.560
没不动了

21:03.200 --> 21:03.360
哎

21:03.360 --> 21:04.720
突然有一天数据拿到了

21:05.760 --> 21:07.040
拿到了这个数据过后呢

21:07.040 --> 21:08.000
我又把个数据呢

21:08.000 --> 21:10.560
给这个data里面的数据复制

21:10.560 --> 21:11.760
因为它是有响应式的

21:12.480 --> 21:14.320
给它一复制是不是改动了数据

21:14.320 --> 21:15.200
一改动数据的话

21:15.200 --> 21:16.320
是不是触发数据变动

21:16.880 --> 21:18.800
然后引发重新选了

21:20.640 --> 21:22.480
所以说我们这个过程里边

21:23.760 --> 21:24.880
这种写法是一样的

21:24.880 --> 21:25.840
看一下效果

21:25.840 --> 21:26.480
都是一样的

21:26.480 --> 21:29.520
而圣壳和未成的只是一个愚法堂

21:30.320 --> 21:31.520
那么在这种效果里边

21:31.520 --> 21:32.800
你可以想象得到

21:34.800 --> 21:36.160
尽管我们代码只有这么两

21:36.160 --> 21:37.520
但是你要理解清楚

21:37.520 --> 21:39.120
理解清楚是很重要的

21:39.120 --> 21:39.520
不然的话

21:39.520 --> 21:41.200
你稍微遇到一件变化就蒙了

21:42.960 --> 21:43.920
对原理的理解

21:43.920 --> 21:45.440
一定要引起高度的忠实

21:47.360 --> 21:47.840
好

21:47.840 --> 21:49.200
虽然说我们这个界面

21:49.200 --> 21:50.640
看上去就是这个效果

21:51.360 --> 21:52.400
那么我问一下大家

21:54.000 --> 21:54.960
它有没有运行这个

21:56.400 --> 21:57.280
它有没有运行这个

22:00.020 --> 22:00.660
update

22:03.040 --> 22:03.840
有没有运行这个

22:04.480 --> 22:05.760
肯定是运行的

22:05.760 --> 22:07.520
你好好再回过去

22:07.520 --> 22:08.720
头去听一下

22:08.720 --> 22:09.840
我刚才的说的东西

22:10.400 --> 22:11.520
说肯定是运行的

22:11.520 --> 22:12.080
对吧

22:12.080 --> 22:12.800
那有时候说

22:12.800 --> 22:15.680
我这个模拟的时间太长了

22:15.680 --> 22:17.200
能不能短一点的

22:17.200 --> 22:18.640
短一点是不是就可以

22:18.640 --> 22:19.760
不用运行update的

22:19.760 --> 22:21.120
就是可以这样想象

22:21.120 --> 22:23.120
就creted里边很快就拿到数据了

22:23.120 --> 22:24.320
就拿到这个异布数据了

22:24.320 --> 22:24.720
所以说

22:25.680 --> 22:26.480
改动了数据

22:26.560 --> 22:28.080
那么就直接挂载就完事了

22:28.080 --> 22:30.160
就没有去触发这个重新渲染

22:30.960 --> 22:31.920
有没有这种可能呢

22:31.920 --> 22:32.720
是不可能的

22:32.720 --> 22:33.760
只要它是异布的

22:34.800 --> 22:36.480
因为异布的是不是

22:36.480 --> 22:37.520
我们知道时间对列

22:37.520 --> 22:37.840
对吧

22:37.840 --> 22:39.120
是不是放到时间对列最后的

22:39.680 --> 22:39.920
对不对

22:39.920 --> 22:41.200
放到时间对列里边去了

22:41.200 --> 22:42.640
所以这些事情做完了之后

22:42.640 --> 22:44.080
才会从时间对列里边去拿

22:44.400 --> 22:45.120
拿这个东西

22:45.120 --> 22:46.320
然后才把它渲染出来

22:46.960 --> 22:47.600
你还认识吧

22:48.080 --> 22:48.320
好

22:48.320 --> 22:49.600
所以说这个creted

22:49.600 --> 22:50.640
哪怕你把这个bock

22:52.480 --> 22:53.520
不写这个延时

22:54.480 --> 22:54.800
刷新

22:55.520 --> 22:56.800
是不是还是要运行Updating的

22:56.800 --> 22:58.320
所以还直播很快

22:58.320 --> 22:58.640
一看

22:59.200 --> 23:00.240
其实有一个变化

23:00.240 --> 23:01.360
0变成3

23:02.000 --> 23:03.120
直播很快变到3

23:04.000 --> 23:05.040
太快了而已

23:05.040 --> 23:06.240
但是实际上它是异布的

23:06.240 --> 23:08.000
所以说它一定会经过这么一个过程

23:08.000 --> 23:10.000
也就是说我们在这种模式下面呢

23:10.000 --> 23:10.560
它就会

23:10.560 --> 23:13.280
我们的组件就是要经过一个重渲染的过程

23:13.280 --> 23:14.000
一开始呢

23:14.000 --> 23:15.280
渲染一个默认的情况

23:15.280 --> 23:16.000
就没有数据

23:16.000 --> 23:17.200
这个组件应该是什么样子

23:19.040 --> 23:19.840
可以这样子

23:19.840 --> 23:20.960
大家也可以这样来做

23:20.960 --> 23:21.840
不要用bif

23:22.560 --> 23:23.280
banners

23:23.280 --> 23:23.840
gernance

23:25.520 --> 23:26.160
小于0

23:27.200 --> 23:28.160
大于0的时候

23:28.160 --> 23:30.560
我才显示整个组件的根源数

23:30.560 --> 23:31.920
不然的话这个组件啥都不选了

23:32.720 --> 23:33.760
可不可以用这种方式呢

23:33.760 --> 23:34.640
也可以

23:34.640 --> 23:35.360
因为有的时候呢

23:35.360 --> 23:36.880
这个组件如果说没数据的话

23:36.880 --> 23:38.560
我也不知道该显示啥了

23:38.560 --> 23:40.560
所以说我只有它有数据的时候呢

23:40.560 --> 23:42.400
我才显示这个组件里面的根源数

23:42.400 --> 23:43.440
这种也是一个做法

23:44.640 --> 23:45.360
一开始没数据

23:45.360 --> 23:46.480
所以说啥都没选了

23:46.480 --> 23:47.440
有了数据过后呢

23:48.080 --> 23:48.720
我才把这个

23:49.520 --> 23:50.800
这个vif为forced

23:50.800 --> 23:52.000
我才把数据选了出来

23:52.000 --> 23:53.120
这样子也是一种办法

23:54.080 --> 23:55.760
那么这样子就看不到0变3了

23:55.760 --> 23:56.560
对吧

23:56.560 --> 23:57.520
一开始你看

23:57.520 --> 23:58.880
一开始没数据就空白了

23:59.600 --> 24:00.800
等到有了数据过后变成3

24:01.440 --> 24:01.920
对不对

24:01.920 --> 24:04.080
将来我们还可以加上一个loading效果

24:04.080 --> 24:05.920
正在加载中的一个效果

24:05.920 --> 24:06.400
都可以

24:07.040 --> 24:07.840
原来的意思吧

24:07.840 --> 24:08.640
这就是常见的

24:08.640 --> 24:09.840
非常常见的一种模式

24:09.840 --> 24:10.720
加载原成数据

24:11.840 --> 24:14.000
我们通常是处理到creted里面

24:14.000 --> 24:15.680
那么能不能写到这个mounted里面呢

24:15.680 --> 24:17.680
其实也不是不可以

24:17.680 --> 24:18.640
差别其实不大

24:18.640 --> 24:21.200
这不我们习惯上来去写到creted里面

24:22.160 --> 24:23.200
但有些公司那我看了一些

24:23.200 --> 24:24.320
到mounted里面都有

24:25.200 --> 24:25.440
好

24:25.440 --> 24:26.160
第二个例子呢

24:27.920 --> 24:29.920
我们这就可能对于这个项目来说

24:29.920 --> 24:30.800
做成这样子就行了

24:31.440 --> 24:33.120
我们也可以把UL选择出来吧

24:33.120 --> 24:34.400
就这个时候选择就很简单了

24:35.120 --> 24:35.840
li

24:35.840 --> 24:36.240
v4

24:37.520 --> 24:38.560
选择这个什么Banners

24:40.000 --> 24:40.720
Banners

24:40.720 --> 24:41.920
然后再绑一个kits

24:41.920 --> 24:43.280
kits就是它的ID

24:43.280 --> 24:44.240
你看一下我们之前

24:44.960 --> 24:46.160
那个banner的默克数据

24:46.160 --> 24:47.520
其实这个默克数据跟可适的

24:47.520 --> 24:49.920
跟真实的福细数据是一样的

24:50.000 --> 24:51.520
只不过数据内容是假的

24:52.960 --> 24:53.600
有大图

24:54.640 --> 24:55.200
有中图

24:55.200 --> 24:55.760
有大图

24:56.960 --> 24:58.080
有标题

24:58.080 --> 24:59.040
有标书

24:59.040 --> 25:00.240
咱们随便写一个吧

25:00.240 --> 25:01.120
随便下写一下

25:04.000 --> 25:04.960
这个img吧

25:04.960 --> 25:05.760
我写个img

25:08.020 --> 25:08.820
来个中图吧

25:09.940 --> 25:12.020
绑定img的src地址

25:12.020 --> 25:14.020
为item.madeimg

25:15.380 --> 25:19.620
然后再写一个span元数吧

25:19.620 --> 25:20.660
或者h2元数

25:21.460 --> 25:22.100
h2元数

25:22.100 --> 25:23.060
绑定它的title吧

25:24.900 --> 25:26.260
再写个h3元数

25:27.220 --> 25:28.340
绑定它的descript

25:30.180 --> 25:31.060
好保存啊

25:31.060 --> 25:31.460
你看一下

25:35.090 --> 25:35.890
就变成了

25:35.890 --> 25:36.690
就这么三项了

25:37.410 --> 25:38.850
下边有一个艺术隐藏了

25:38.850 --> 25:39.570
所以看不见了

25:40.610 --> 25:41.490
没问题吧

25:41.490 --> 25:42.770
这就拿到了福细的数据了

25:42.770 --> 25:43.890
这个我们这些效果

25:43.890 --> 25:44.610
我们还要高手

25:44.610 --> 25:45.010
还要做

25:45.730 --> 25:45.890
好

25:45.890 --> 25:47.810
那么这是一个远程加载数据的操作

25:47.810 --> 25:48.930
要利用到生命周期

25:49.890 --> 25:50.130
好

25:50.130 --> 25:51.570
现在我们看一下第二种

25:51.650 --> 25:52.530
常见的操作

25:52.530 --> 25:55.170
就是你可能在页面上直接去操作动

25:55.970 --> 25:58.450
比方说我们刚才演示的用riff是直接操作动作

25:58.450 --> 25:59.170
那么这个时候

25:59.170 --> 26:01.010
就要写到multi的里面去了

26:01.010 --> 26:01.410
对不对

26:01.410 --> 26:02.450
比方说我们看这个例子

26:03.010 --> 26:04.210
看上面有个demo

26:04.210 --> 26:04.530
动

26:06.560 --> 26:07.440
我们把运行出来

26:08.400 --> 26:11.120
npmvue12

26:11.120 --> 26:11.680
像这个

26:12.160 --> 26:13.280
如果说你不干

26:13.280 --> 26:14.560
不干后面的主线名的话

26:14.560 --> 26:16.000
那么他默认去找什么

26:16.000 --> 26:16.800
app.vue

26:18.080 --> 26:19.680
先找一下有没有Made.js

26:19.680 --> 26:20.880
没有的话就找app.vue

26:20.880 --> 26:22.080
这个东西你了解一下就行了

26:22.160 --> 26:23.120
反正因为这个玩意

26:23.120 --> 26:24.480
也只是一个测试用的

26:24.480 --> 26:26.080
在真实的项目开发里边

26:26.080 --> 26:27.920
最终硬行整体效果的时候

26:27.920 --> 26:28.880
是不会用这个命令的

26:30.800 --> 26:31.600
你看呀

26:31.600 --> 26:33.920
我这里有目的是要为了显示

26:33.920 --> 26:35.440
这个div的宽高

26:36.000 --> 26:37.120
因为这个宽高我不知道

26:37.120 --> 26:38.960
所以我要把宽高显示出来

26:38.960 --> 26:40.080
那么你看这个玩意怎么做

26:40.640 --> 26:42.080
也不好做

26:42.080 --> 26:43.040
得用生命周期

26:43.040 --> 26:43.680
你看怎么写的

26:44.240 --> 26:45.520
我这里写了两个数据

26:45.520 --> 26:46.800
这两个数据一开始是零

26:46.800 --> 26:47.680
为什么一开始是零

26:47.680 --> 26:49.040
一开始连div都没有

26:49.040 --> 26:50.400
那不是零是什么的

26:50.400 --> 26:51.280
我都不知道是啥了

26:52.400 --> 26:54.000
然后我给了个div一个Ref

26:54.000 --> 26:55.120
container对吧

26:55.120 --> 26:57.280
当我们的div加载出来过后了

26:58.000 --> 26:59.120
我是不是可以在这个时候

26:59.120 --> 27:00.400
可以拿到这个div的宽高

27:00.960 --> 27:01.360
对不对

27:01.360 --> 27:02.720
通过这个Ref是container

27:02.720 --> 27:03.600
拿到它的宽度

27:03.600 --> 27:04.480
拿到它的高度

27:04.480 --> 27:06.560
然后给它复制到container位置里边

27:06.560 --> 27:07.600
container hight里边

27:07.600 --> 27:08.480
改动数据

27:08.480 --> 27:09.280
数据也改动

27:10.720 --> 27:10.960
那么

27:12.320 --> 27:13.760
那么这个组建重新宣展

27:13.760 --> 27:15.440
所以这个这种方式呢

27:15.440 --> 27:16.480
它是不是也会导致

27:17.600 --> 27:18.640
组建宣展两次

27:18.640 --> 27:20.640
第一次用零的方式宣展一次

27:20.640 --> 27:21.600
后边有数据了

27:21.600 --> 27:22.640
也重新宣展一次

27:23.200 --> 27:23.600
对吧

27:23.600 --> 27:24.800
也会宣展两次

27:24.800 --> 27:25.600
有的这个东西呢

27:25.600 --> 27:26.960
它也会运行什么updating

27:27.520 --> 27:28.560
肯定会运行

27:29.360 --> 27:29.920
updating

27:30.720 --> 27:31.520
保存

27:31.520 --> 27:31.920
放心

27:33.040 --> 27:33.360
你看

27:33.360 --> 27:34.000
是不是有运行

27:34.800 --> 27:36.080
这样就显示出来了

27:36.080 --> 27:37.520
看下这个组建是不是这么高啊

27:38.080 --> 27:40.160
它也免伤1520x22

27:40.800 --> 27:42.560
这也是一种常见的做法

27:42.560 --> 27:44.400
如果说你要直接操作多么的话

27:44.400 --> 27:46.400
尽管了在5u里边呢

27:46.400 --> 27:47.920
尽量的不要去直接操作多么

27:49.200 --> 27:49.520
好

27:49.520 --> 27:50.160
接下来是

27:50.320 --> 27:51.680
启动和清除计时器

27:52.880 --> 27:54.400
这个玩意又是什么情况呢

27:54.400 --> 27:56.080
我就觉得这么一个例子

27:56.080 --> 27:56.720
看下面这个

28:00.240 --> 28:00.960
有色

28:02.720 --> 28:03.760
这点我来看一下

28:03.760 --> 28:05.280
首先app组建里边

28:05.280 --> 28:07.040
我写了一段简单的代码

28:07.040 --> 28:08.480
我使用了一个指数键叫clog

28:08.480 --> 28:09.120
一个时钟

28:10.720 --> 28:11.280
你看一下吧

28:11.280 --> 28:11.600
首先

28:12.320 --> 28:12.800
看一下吧

28:14.640 --> 28:15.440
就这么一个玩意

28:15.440 --> 28:16.000
一个时钟

28:16.960 --> 28:17.680
这就是个组建

28:18.400 --> 28:19.920
然后下面我可以切换

28:20.480 --> 28:22.080
把个时钟印不显示了

28:23.040 --> 28:23.680
又显示

28:24.400 --> 28:25.680
就这么一个小的效果

28:25.680 --> 28:26.560
很小很小的效果

28:27.760 --> 28:28.800
有这么一个时钟

28:29.680 --> 28:30.080
然后呢

28:30.080 --> 28:31.040
我要不要显示时钟呢

28:31.040 --> 28:32.240
是一个数据来控制的

28:32.240 --> 28:34.080
在5u里边始终是数据来控制界面

28:34.960 --> 28:35.120
好

28:35.120 --> 28:36.160
数据呢一开始为q

28:36.640 --> 28:36.800
好

28:36.800 --> 28:37.920
现在界面怎么来渲染呢

28:39.520 --> 28:41.680
有这么一个clog指数键

28:41.680 --> 28:43.040
要不要渲染这个指数键

28:43.040 --> 28:44.400
取决于这个指

28:44.400 --> 28:46.000
它为q的时候就要渲染

28:46.000 --> 28:47.360
为forced的时候就不渲染它

28:47.920 --> 28:48.320
对吧

28:48.320 --> 28:50.720
也就是说它里边是有可能会发生什么

28:50.720 --> 28:51.120
发生

28:52.000 --> 28:52.720
发生那个

28:52.720 --> 28:53.040
就是

28:54.400 --> 28:54.960
销毁的

28:55.600 --> 28:56.960
这下面一个按钮点击过后

28:56.960 --> 28:58.720
就把它切换为相反的状态

28:58.720 --> 28:59.360
切换显示

29:00.080 --> 29:01.040
很简单对吧

29:01.040 --> 29:02.240
然后我们来看一下clog组建

29:03.520 --> 29:04.720
这个组建里面很简单

29:04.720 --> 29:06.000
就一段文字

29:06.000 --> 29:07.600
然后显示一个数据

29:08.400 --> 29:09.120
这个数据呢

29:09.120 --> 29:09.760
默认值呢

29:09.760 --> 29:10.560
一开始的默认值呢

29:10.560 --> 29:12.400
我调用了当前的一个方法

29:12.400 --> 29:13.440
当前实力的一个方法

29:13.920 --> 29:14.560
就这个方法

29:15.520 --> 29:16.160
get screened

29:16.800 --> 29:17.680
这个方法很简单

29:17.680 --> 29:18.800
就创建一个日期

29:18.800 --> 29:20.240
得到当前的时间

29:20.400 --> 29:21.440
local time screen

29:21.840 --> 29:22.000
对吧

29:22.000 --> 29:22.800
这就是当前时间

29:24.640 --> 29:24.880
好

29:24.880 --> 29:26.480
那么如果说我仅仅这样做的话

29:26.480 --> 29:27.680
那么这个始终是不会动的

29:28.400 --> 29:29.040
仅仅这样做

29:29.040 --> 29:30.240
我这个始终是不会动的

29:30.240 --> 29:31.440
因为它渲染出来了过后

29:32.160 --> 29:33.760
是不是就当前时间就渲染出来了

29:33.760 --> 29:34.800
它凭什么动了

29:34.800 --> 29:36.560
没有任何理由它会动

29:36.560 --> 29:37.200
对不对

29:37.200 --> 29:37.600
因此呢

29:37.600 --> 29:38.960
我在启动一个计时器

29:38.960 --> 29:41.200
每隔一秒钟动一下

29:41.200 --> 29:41.600
因此呢

29:41.600 --> 29:42.560
我就写了这么一个东西

29:44.080 --> 29:46.000
我在这里一个数据里边加了一个timeout

29:46.640 --> 29:47.360
表示计时器

29:48.960 --> 29:49.520
计时器

29:50.960 --> 29:52.480
每隔一秒钟动了一下

29:52.480 --> 29:53.440
也就是每隔一秒钟

29:53.440 --> 29:54.880
我重新设置一下这个数据

29:56.320 --> 29:57.840
重新设置一下这个数据

29:57.840 --> 29:59.200
是不是就导致了重新渲染

29:59.200 --> 30:00.800
因为介面上用到了这个数据

30:01.360 --> 30:01.680
对吧

30:02.080 --> 30:02.960
那么这个计时器

30:02.960 --> 30:05.280
启动计时器的单码写脑呢

30:05.280 --> 30:07.280
我就可以写到crity的里边

30:07.280 --> 30:08.320
在很早的时候

30:08.320 --> 30:10.400
crity的时候创建好了过后有数据了

30:10.400 --> 30:10.800
然后呢

30:10.800 --> 30:11.840
我每隔一秒钟

30:11.840 --> 30:12.560
这次intel

30:13.440 --> 30:15.120
把只能复制到给这个计时器

30:17.040 --> 30:17.680
有时候就说

30:17.680 --> 30:18.640
不要这个计时器写不写

30:18.640 --> 30:19.040
可以啊

30:19.040 --> 30:19.600
你不要嘛

30:20.800 --> 30:21.440
不要也是

30:21.440 --> 30:22.000
效果还是

30:22.000 --> 30:22.640
还是可以

30:23.440 --> 30:24.720
每隔一秒钟

30:24.720 --> 30:25.920
我重新调问这个方法

30:26.640 --> 30:28.080
去设置这个credit

30:28.080 --> 30:29.440
设置当前时间

30:29.440 --> 30:29.680
对吧

30:29.680 --> 30:30.240
那这个

30:30.240 --> 30:31.120
它自然就动起来了

30:32.000 --> 30:32.800
小心

30:32.800 --> 30:33.360
动起来了

30:33.920 --> 30:35.280
但是这样一动起来了不得了了

30:35.280 --> 30:35.760
你看啊

30:37.440 --> 30:38.560
好像是没有什么问题啊

30:38.560 --> 30:39.360
一切都没有什么问题

30:39.360 --> 30:40.800
我这里可以输出一下

30:44.830 --> 30:46.430
更新的时间

30:49.070 --> 30:49.630
你看啊

30:51.710 --> 30:52.430
不断的在输出吗

30:52.430 --> 30:53.230
没问题吧

30:53.310 --> 30:55.870
那如果1000万显示呢

30:57.150 --> 31:02.270
你看不断的去输出这个东西,不断的去改数据,不断的干嘛,不断的重新选了

31:02.790 --> 31:04.310
不断的去重新选这个组件

31:04.570 --> 31:05.350
这个clock组件

31:06.110 --> 31:08.150
好但是有一天那个组件要被销毁啊

31:08.670 --> 31:09.430
你看啊

31:10.970 --> 31:13.790
这个组件点击切换过,这个组件是不是被销毁了

31:14.050 --> 31:15.330
结果这个计时器还在动

31:15.830 --> 31:20.950
为什么销毁的组件还没有销毁计时器,这个计时器是你自己订的,他又不知道这里面有计时器

31:21.670 --> 31:24.030
他只知道我一换数据怎么又变了我就确认了

31:24.270 --> 31:25.310
怎么又变了我就确认了

31:25.550 --> 31:27.090
他不知道这里面是怎么变的啊

31:27.350 --> 31:30.170
因为这个计时器还在动,那这个计时器有必要动吗现在

31:31.710 --> 31:36.570
白白的去浪费了一段时间去执行这个代码有必要吗,没必要了,因为这个组件都看不见了

31:37.330 --> 31:39.890
所以这个组件销毁的时候呢,我们通常要把

31:40.410 --> 31:44.490
一些计时器啊这些轻力,就自己写的东西啊,要做一些轻力工作

31:45.010 --> 31:47.570
像这种计时器就要轻力,因此我这里呢

31:47.830 --> 31:49.370
就写个Destroy

31:50.090 --> 31:51.370
Destroy的

31:51.630 --> 31:54.690
当组件销毁的时候,它会运行这个函数啊,Destroy的

31:56.230 --> 31:57.770
你看啊,组件销毁

31:59.050 --> 32:00.070
什么运行的Destroy的

32:00.330 --> 32:05.450
对吧,因此我们在这里是不是要轻空计时器,怎么来清楚呢,那是不是计时器呢,得保存一下

32:05.710 --> 32:07.490
哎呦,怎么能放到这儿保存

32:07.750 --> 32:09.030
我们外面订个辨量

32:09.290 --> 32:11.090
能不能放到这儿保存,最好不要

32:11.590 --> 32:14.410
为什么呢,如果说你放到这儿保存的话,就意味着

32:15.170 --> 32:18.770
我在使用这个组件的时候,如果说多使用了几次组件

32:19.190 --> 32:20.310
我这里只送了一次嘛

32:20.570 --> 32:22.870
多使用几次组件,它每个组件的数据

32:23.130 --> 32:24.910
计时器是不是用的同一个计时器啊

32:25.430 --> 32:27.730
如果说你就希望这样子的话,它就可以啊

32:27.990 --> 32:32.070
我当然能够更多的使用了,希望的是每个组件有自己的一套数据

32:32.330 --> 32:35.930
每个组件都会调用一下这个方法,都会产生一个新的对象

32:36.190 --> 32:39.250
那么这个新的对象里面都有自己的数据,把他们通话写到这儿

32:40.530 --> 32:42.070
好,因此呢,我们这里是S-Tamer

32:42.330 --> 32:42.830
然后复制

32:44.110 --> 32:45.150
代码就这么来的

32:45.610 --> 32:47.410
为什么要复制,因为我要以后要清理

32:47.670 --> 32:50.230
清理的时候,我要用Clear Interval

32:50.990 --> 32:52.270
S-Tamer

32:52.530 --> 32:53.030
清理一下

32:54.070 --> 32:56.110
好,保存一下,咱们来看一下,刷新

32:57.390 --> 32:59.950
否刷到运行这个计时器,然后点击切换

33:01.230 --> 33:03.270
现在被销毁了,是不是运行了这个代码

33:03.530 --> 33:04.550
清理的计时器

33:04.810 --> 33:07.630
就做一些自己的清理工作,这也是一种常见的

33:07.890 --> 33:08.910
生命中心海朔的用法

33:09.890 --> 33:11.930
哎,在点击的时候呢

33:12.190 --> 33:13.010
在点击的时候

33:13.270 --> 33:19.410
是不是这个组件又复活了呢?不是的,它又创建了一个完全全新的组件了,又从头开始

33:19.670 --> 33:22.230
全部从头开始创建一遍

33:23.250 --> 33:25.290
又是一个新的组件了,北京我们试一下

33:25.550 --> 33:27.090
我们这里用一个回体的

33:27.850 --> 33:28.870
输出,回体的

33:29.130 --> 33:29.890
来看一下吧

33:32.620 --> 33:33.140
哎

33:34.420 --> 33:35.180
好错

33:35.440 --> 33:36.200
好怎么错

33:38.350 --> 33:40.650
margin error

33:41.170 --> 33:42.190
模块错误

33:44.990 --> 33:45.990
无销的

33:46.510 --> 33:50.090
重复了key,可以得我们之前写过的

33:53.460 --> 33:54.480
好,你看

33:55.500 --> 34:00.360
可以记得,然后不让它去update,更新我们的数据,更新界面,重新选上界面

34:00.620 --> 34:01.400
然后呢,第四座椅

34:01.660 --> 34:02.680
所以清楚了计时器

34:03.180 --> 34:04.720
当我们再次显示的时候呢

34:04.980 --> 34:07.540
它实际上怎么回事呢?它是对比新旧两棵树

34:07.800 --> 34:09.580
之前那棵树现在没有这个组件了,对吧

34:10.100 --> 34:12.400
现在是就,当前的树是没有这个组件了

34:12.660 --> 34:13.680
点击切换显示

34:13.880 --> 34:17.120
新的树又有这个组件了,是不是要重新创建组件

34:18.240 --> 34:19.200
又运行的created

34:19.460 --> 34:22.080
又是一个新的组件了,跟之前那个组件就没什么关系了

34:23.360 --> 34:24.120
明白了意思吧

34:25.160 --> 34:26.440
就这么一个过程

34:27.200 --> 34:28.560
ok,这就是这节课的内容啊

34:28.800 --> 34:31.560
组件生命周期,对我们最终的这个

34:31.800 --> 34:34.640
对我们最终的这个项目的影响呢,好像没有什么影响啊

34:35.400 --> 34:36.680
也就这么两站航带吧

34:38.160 --> 34:43.320
我们拿到这个数据了,那么接下来就是拿了个数据过后,怎么来把首页做完,那是我们后边的事情了

34:43.320 --> 34:45.080
ok,那么这就我们讲到这儿

