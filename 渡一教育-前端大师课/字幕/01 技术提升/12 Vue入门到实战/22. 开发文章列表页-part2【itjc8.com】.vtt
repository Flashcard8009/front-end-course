WEBVTT

00:00.820 --> 00:05.680
这些课我们来把这个文章列表页就给它弄出来了

00:05.940 --> 00:08.240
内容有点多 比较长

00:08.500 --> 00:11.560
并且有一些新的知识

00:11.820 --> 00:13.880
我们就按照这个主线弄

00:14.140 --> 00:17.200
弄到不能弄的地方我们就补充一些知识

00:17.720 --> 00:19.500
好 来吧 慢慢来

00:19.760 --> 00:21.800
就这个文章列表页做完

00:22.060 --> 00:25.900
可以说我们整个项目应该是开发完了60%的吧

00:26.160 --> 00:27.700
就已经差不多了

00:28.700 --> 00:33.080
首先我们要确定一个路由跳转逻辑

00:33.340 --> 00:35.640
为啥要确定路由跳转逻辑呢

00:35.900 --> 00:38.200
咱们来看一下文章列表页

00:38.960 --> 00:40.760
到文章列表页

00:42.540 --> 00:47.420
这个地方我们首先显示的是全部的分类下面的文章

00:47.920 --> 00:48.440
对不对

00:48.940 --> 00:55.860
有的时候我们可能要显示某一个分类下面的文章而不是全部的分类

00:56.120 --> 00:56.880
那怎么办呢

00:57.100 --> 01:02.200
我们希望了一般来说我们上网的过程中都希望在地址栏中来标识出来

01:02.460 --> 01:03.740
比方说我们访问这个地址

01:04.000 --> 01:06.060
就显示的是全部的文章

01:06.820 --> 01:09.640
当然还是要分页 分页肯定是还是要分页的

01:09.900 --> 01:11.160
下面这个分页呢

01:11.420 --> 01:12.700
大家可能看的不是很清楚啊

01:12.960 --> 01:14.240
我们往上一点

01:15.000 --> 01:15.520
你看

01:16.280 --> 01:16.800
对不对

01:17.320 --> 01:22.440
然后呢如果说我们要显示某一个分类下面的比方说我们点击这个分类啊

01:22.940 --> 01:24.220
因为发现了一个地址栏变了

01:24.740 --> 01:25.240
看到没

01:26.220 --> 01:29.280
这样子变地址栏有什么好处呢就变于分享

01:29.800 --> 01:33.740
比方说我看这个分类下面的有一个专题啊专门来讲

01:34.000 --> 01:34.920
azb协议的

01:35.180 --> 01:36.200
我们有些文章

01:36.460 --> 01:39.520
大家觉得不错就可以把这个地址呢分类的地址呢

01:39.780 --> 01:40.720
分享给你的朋友

01:40.980 --> 01:43.620
一朋友打开这个地址就直接看直接看到的就是

01:43.880 --> 01:46.700
网络协议下面的文章了

01:47.200 --> 01:49.720
懂这个意思吧就是我们就通过地址来区分

01:50.480 --> 01:51.820
不同分类下面的文章

01:52.800 --> 01:54.460
其实除了这个地

01:54.700 --> 01:59.900
除了分类之外呢我们有的时候啊在上网的过程中啊会看到有些网站

02:01.240 --> 02:03.800
还会从地址哪里边来区分页吗

02:04.060 --> 02:05.840
不过呢我这个效果里面不是啊

02:06.100 --> 02:07.640
但是我这一次

02:07.900 --> 02:11.220
给大家讲的时候呢打算从地址哪里边去给大家区分页吗

02:11.740 --> 02:16.100
啥意思呢就比方说我要查看id为二分分类下面的文章

02:16.360 --> 02:18.900
那如果说我要查看这是第一页吗某人是第一页

02:19.160 --> 02:20.440
别人进来过后就是第一页

02:20.740 --> 02:22.540
那如果说你看到第四页

02:23.220 --> 02:24.340
第四页的时候

02:25.260 --> 02:28.340
看到第四页的时候觉得这些文章也不错啊我想把这个页码

02:28.840 --> 02:30.500
这个页码下面的文章分享出去

02:30.760 --> 02:35.500
于是呢我复制一下地址哪有用吗现在现在肯定没用啊因为我之前没有这样去做

02:35.760 --> 02:41.080
但是呢我这一次准准备这样做了什么意思呢就是说我点了分页过后了地址哪要变化

02:41.340 --> 02:43.180
怎么变化呢前面的pass

02:43.700 --> 02:44.700
就是路径不变

02:44.960 --> 02:47.260
我变化的是一个后边的参数

02:48.000 --> 02:50.340
问号后边跟参数吧这个里面是学习过的

02:50.900 --> 02:52.580
比方说我们配级等于一

02:52.840 --> 02:56.020
里面成了等于十每页先收十条

02:56.540 --> 03:00.380
第一页或者是第三页点了第四页过后呢还变成这个样子

03:01.140 --> 03:03.820
啊这样子是不是变于分享我把这个页码分享出去

03:04.060 --> 03:06.260
要别人进来过后就直接看到是第四页

03:06.780 --> 03:08.060
就这么个意思啊

03:08.560 --> 03:11.380
好这是关于我们想做的事情

03:11.640 --> 03:13.940
通过地址哪来区分不同分类上的文章

03:14.200 --> 03:18.180
其实不仅如此啊我们还看到这里分类分类有个激活样子对不对

03:18.440 --> 03:20.100
到底哪一个是激活状态

03:20.440 --> 03:23.220
我们也根据地址来来进行确定

03:23.740 --> 03:26.020
所以说我们这里呢要做到这么一个

03:26.540 --> 03:30.260
做到这么一个逻辑就是路由跳船逻辑看一下啊这一张图

03:30.520 --> 03:33.140
这个图呢可能你们看到比较小啊我把这个

03:33.400 --> 03:36.020
图片的地址呢复制一下啊在浏览器里边打开

03:36.260 --> 03:37.540
这样子你们看比较大一点

03:40.100 --> 03:40.860
方小一点吗

03:42.660 --> 03:43.420
好你看呀啊

03:43.940 --> 03:44.660
就这么一个图

03:45.100 --> 03:48.300
我希望访问这个地址啊我之前他用的是blog对吧

03:48.400 --> 03:51.840
那么现在能够改成article是也是可以啊也可以用blog都无所谓

03:52.600 --> 03:54.040
啊比方说我们访问这个地址

03:54.300 --> 03:57.160
访问这个地址的时候呢查看的是全部文章

03:57.400 --> 04:01.000
并且呢是第1页的文章啊每页显示的默认10条吗

04:01.760 --> 04:04.520
好如果说我访问这个地址的话那么查看的是

04:04.880 --> 04:07.440
还是全部文章啊因为这个PASS没有变

04:08.240 --> 04:11.280
全部文章第几页呢第三页每页显示30条

04:12.080 --> 04:14.040
明白的意思吧哎我们有这么一个逻辑

04:14.520 --> 04:15.640
好如果说

04:15.860 --> 04:21.460
是分类的话呢我们可以用这样的地址表示来分类刚才是没有分类吧没有分类就是全部

04:21.740 --> 04:25.580
哎如果说分类的话我们用这样的地址哎给他一个分类的id

04:25.840 --> 04:27.620
id为1的话那么就是查看

04:28.140 --> 04:29.620
分类id为1的文章

04:30.380 --> 04:31.460
当然呢也可

04:31.720 --> 04:34.540
下面如果说写的是3的话就查看分类id为3的文章

04:34.800 --> 04:37.860
哎我这些写错了啊这里应该是3啊大家知道就行了啊

04:38.380 --> 04:40.420
呃下面呢就是查看id为4

04:40.940 --> 04:45.540
的文章然后呢第二页每页显示20条前面两个呢都显示了第1页每页显示10条

04:45.700 --> 04:46.620
对啊默认值吗

04:47.900 --> 04:49.420
哎那问题是怎么做呢

04:50.980 --> 04:52.260
啊这个地方好说

04:52.700 --> 04:54.820
这个地方我们是不是以前路有都配置好了

04:55.060 --> 04:56.820
对不对我们回到我们之前的路由这里

04:57.260 --> 04:57.820
rotr

04:58.060 --> 04:58.460
roge

04:59.940 --> 05:02.940
当我们访问这样的地址的时候我们匹配到blog逐渐

05:03.460 --> 05:06.740
这个是没有问题的对吧没有任何问题那又说说这个东西怎么来匹配了

05:06.840 --> 05:07.740
这个东西你不用管

05:08.020 --> 05:10.780
因为他匹配的时候呢只匹配pass

05:11.460 --> 05:14.020
不管后边的参数啊参数的一些啥无所谓

05:14.240 --> 05:15.040
他只匹配pass

05:15.300 --> 05:21.040
passp就是那个路径啊路径匹配到了那就ok比方说你这个你看我们现在是已经匹配到博客组建了

05:22.080 --> 05:23.520
哎我们如果说加上一个参数

05:23.960 --> 05:24.520
随便写吧

05:26.740 --> 05:28.140
你看看能不能匹配到博客组建

05:28.700 --> 05:31.420
所以还是可以匹配到博客组建对不对没有任何问题啊

05:33.920 --> 05:34.520
没有任何问题

05:35.320 --> 05:36.320
哎我跑了

05:36.400 --> 05:36.720
很大

05:38.120 --> 05:38.440
好

05:39.160 --> 05:40.480
哎对为什么爆错啊

05:41.720 --> 05:43.160
我看一下啊为什么爆错

05:46.060 --> 05:48.740
哎这是之前的一个错误啊就是这个组建

05:49.580 --> 05:51.740
这个组建我看一下啊顺便把这个错误解决一下

05:52.220 --> 05:54.740
Home这个组建这个组建里边有什么错误呢

05:54.740 --> 05:55.140
他说

05:56.220 --> 05:57.780
无法读取client's wits

05:57.780 --> 05:58.580
or undefined

05:59.620 --> 06:01.180
那应该是没有销毁啊

06:03.750 --> 06:07.830
哦这里之前写错了啊之前set size那我这里写成resize了啊

06:09.030 --> 06:10.150
啊我把它销毁一下

06:11.110 --> 06:12.910
销毁一下那个注册的时间

06:15.110 --> 06:16.950
好回到这儿 ok

06:17.390 --> 06:19.990
啊这是之前我们的测试代码一把删掉吧

06:22.340 --> 06:23.300
测试代码删掉

06:26.200 --> 06:28.400
好了那里我们可以可以刚才可以看到啊

06:29.040 --> 06:32.840
加上一些地址栏参数其实也无所谓的因为他匹配的时候只管匹配pass

06:33.280 --> 06:37.480
这个匹配就ok了所以说这个事情呢其实我们已经搞定了

06:38.040 --> 06:38.440
就这个

06:40.160 --> 06:41.720
这个事情已经搞定了

06:42.320 --> 06:46.160
article对吧因为无论你传什么参数都可以匹配到这个blog图件

06:46.800 --> 06:51.120
那么现在呢这个路由规则文已经有了啊现在我们还需要一个路由规则

06:52.100 --> 06:57.260
就是当你的pass让你的路进是这个样子的时候他也能够匹配到blog图件

06:58.020 --> 07:01.620
那怎么办呢我们加一个规则不就完了吗好来我们来加个规则啊

07:02.140 --> 07:10.060
好肉池这里呢我们新增加一个规则给他取个名字叫做某个分内下的刚才是全部博客嘛现在是某个分内下的博客

07:10.580 --> 07:13.900
啊路进呢就什么article

07:15.940 --> 07:18.260
问题来了这个地方写啥

07:18.720 --> 07:23.080
这个地方写啥因为这个地方是变动的对吧你写一

07:23.340 --> 07:24.560
不行那三怎么办呢

07:25.120 --> 07:29.220
那你会不会再加一个三那你不知道加多少个因为你不知道有多少分内

07:29.480 --> 07:30.240
对不对

07:30.760 --> 07:33.840
说这个地方很麻烦啊就这个地方是动态的

07:34.080 --> 07:37.400
他可以变化他可能是一可能是三可能是五

07:37.920 --> 07:41.520
那么这个就是一个新的知识啊叫做动态路由

07:41.760 --> 07:44.320
什么动态路由呢我们看知识部分啊动态路由

07:45.300 --> 07:46.580
就是这么一个场景

07:47.100 --> 07:50.420
当我们要遮斜地址的都要匹配到同一个组件的时候

07:51.180 --> 07:51.940
我们怎么办呢

07:52.720 --> 07:55.540
呃员这种情况很简单对吧我们之前写过了

07:55.800 --> 07:57.340
那如果说要匹配到不同的组

07:57.580 --> 08:00.400
呃不同的地址要匹配到组件的话那么这个地方是动态的

08:00.660 --> 08:03.740
动态的地方呢我们一个特殊的语法啊就是写个帽号

08:05.020 --> 08:06.540
帽号后面呢写上一个

08:07.300 --> 08:10.640
随便写个吧给他取个名字就动给动态部分取个名字

08:11.220 --> 08:16.480
也就说一个路也就一个路级里面动态部分可能有多个啊比方说你这样的写那么动态部分呢就可以

08:16.740 --> 08:23.140
可以可以使多个对吧啥意思呢就当我们访问这样的地址啊假设啊假设我们有这么一个东西

08:23.400 --> 08:25.440
那么当我们的访问地址是article

08:26.200 --> 08:26.720
cat

08:27.240 --> 08:30.040
123啊那么依旧匹配到a

08:30.300 --> 08:31.340
2呢就匹配到b

08:31.600 --> 08:34.400
c就匹配到3啊3就匹配到c就这么个意思

08:34.660 --> 08:37.220
那如果说你只是只是这样的写了那么

08:37.480 --> 08:40.040
那么这个就不能匹配了对吧那只有这样子才能匹配

08:40.080 --> 08:42.000
就这个地方是动态的随便你写啥都可以

08:42.240 --> 08:43.320
他就匹配到这个a

08:43.840 --> 08:44.600
没玩意的意思吧

08:45.120 --> 08:45.880
就这么个意思

08:47.160 --> 08:50.760
好那么现在这里给他取个名字啊那么就对名字的当地里面最好不要乱命名

08:51.000 --> 08:52.280
最好命一个有意义的名字

08:52.540 --> 08:56.360
比方说这里呢实际上的意义含意是什么呢含意是casper id

08:56.620 --> 08:57.920
对吧分类的名字

08:58.420 --> 08:58.940
分类的id

08:59.700 --> 09:02.520
我们就可以把它写成一个动态的那么这样子一来的话

09:03.540 --> 09:07.900
这有些路径啊你看我现在什么都没有做就把这个东西写好了这这一部分可以是动态的

09:08.160 --> 09:09.940
咱们来看一下能不能匹配到播络的逐渐

09:10.400 --> 09:11.920
好我们到这里边来

09:12.560 --> 09:15.600
article肯定能匹配的吧之前我们那个规则是生效的

09:15.880 --> 09:17.400
接下来我们来写别的规则啊

09:19.300 --> 09:20.060
写别的规则

09:21.100 --> 09:21.940
cat3

09:22.380 --> 09:23.820
你看是不是还是能匹配到这个组件

09:24.420 --> 09:26.220
cat4是不是还是能匹配到他

09:26.480 --> 09:27.260
对吧都能匹配到他

09:28.540 --> 09:29.020
对不对

09:29.280 --> 09:30.820
好那么这个问题是不是就解决了

09:31.600 --> 09:33.780
那解决了之后还剩下一个问题就是

09:34.040 --> 09:36.720
那我现在匹配到这个组件了那倒是没什么问题

09:36.980 --> 09:39.020
在这个组件里边我得知道啊

09:39.280 --> 09:41.320
我到底要选显示的是全部文章

09:41.540 --> 09:43.680
还是显示的是某个分类下的文章

09:43.940 --> 09:46.500
也就是他要得到什么得到分类的id

09:47.000 --> 09:47.500
对不对

09:47.760 --> 09:52.200
有可能有id将这种相当的就是不是有id分类的id为1分类的id为3

09:52.640 --> 09:56.040
我根据不同的分类id去获取不同的文章之前我们写过接口的

09:56.980 --> 09:59.040
那如果说像这种情况就没有分类id

09:59.300 --> 10:01.040
对吧我得知道分类的id是啥

10:01.300 --> 10:04.400
indefine的话分类没有分类id的话我就获取全部文章

10:04.660 --> 10:08.360
也有分类id的话我就获取某个分类下面的文章对不对

10:08.620 --> 10:11.060
甭管后边怎么做这个信息是不是得获取

10:11.260 --> 10:12.120
那怎么获取呢

10:12.500 --> 10:14.340
现在我们回到这个组件里边的问题来了

10:15.620 --> 10:16.240
跑这来

10:16.500 --> 10:18.940
然后我们这里的要获取分类的id是啥

10:20.220 --> 10:23.040
那么这个信息来自于哪来自于路由对不对

10:23.560 --> 10:25.100
那么这个信息怎么来获取呢

10:25.100 --> 10:26.620
我们看一下我们的文章

10:27.140 --> 10:28.160
动态路由这一块

10:29.700 --> 10:32.780
当我们的地址中使用那个

10:33.540 --> 10:36.340
这种东西的时候表示这一部分的内容是变化的

10:36.860 --> 10:40.700
那么我们在组件里面如何来获取这一部分的实际的值呢

10:40.980 --> 10:41.980
比方说我们刚才的

10:43.260 --> 10:44.020
这个地方

10:45.300 --> 10:46.580
写的是4对吧

10:46.840 --> 10:48.380
那么这个地方我们的路由规则是什么

10:48.620 --> 10:49.660
路由规则是这样的写的

10:50.180 --> 10:50.680
cat

10:51.700 --> 10:52.740
cat.id

10:52.980 --> 10:55.540
对不对那4就匹配到它了我如何来获取这个4呢

10:55.800 --> 10:56.820
我也不知道它写的是啥

10:58.100 --> 10:59.900
下面有一个非常简单的方式

11:00.660 --> 11:04.500
5U Router是一个5U的插件这是我们之前学习过的

11:05.280 --> 11:08.340
当安装好这个插件之后把它注入到5U过后呢

11:08.540 --> 11:11.360
它还它除了给我们提供了我们之前学习的啊

11:11.620 --> 11:15.720
提供了一些组件什么5U Router 5U学过的Router Link导航

11:15.980 --> 11:17.760
除了提供这个组件之外呢

11:18.020 --> 11:20.580
除了还给我们一些配置可以配置路由之外呢

11:20.840 --> 11:21.600
还给我们

11:21.860 --> 11:24.160
5U的原型上

11:24.940 --> 11:26.220
注入了一些

11:26.720 --> 11:27.240
对象

11:29.690 --> 11:31.490
注入的原型对象

11:32.250 --> 11:33.030
咋意思呢

11:34.050 --> 11:36.350
不知道大家还有没有印象啊我们之前在

11:36.610 --> 11:38.910
是不是自己也注入过原型的东西对吧

11:39.070 --> 11:42.450
网5U的原型上给我们注入了一些方法我们之前也做过的

11:42.950 --> 11:46.030
所以说一定要跟着我写啊戴嘛不然的话你之前东西就忘了

11:46.290 --> 11:47.310
你没有写过的话

11:47.570 --> 11:50.130
最好呢不但要写出来但是不能抄啊

11:50.630 --> 11:52.170
不但要写出来你还知道这些

11:52.430 --> 11:53.970
写的自己写的是什么

11:54.230 --> 11:55.510
就要充分的理解

11:55.770 --> 11:56.910
慢一点都没关系

11:57.150 --> 12:00.110
因为你只知道这个项目一做完你的技术是突飞蒙金

12:01.130 --> 12:04.210
好那么既然我们自己都可以注入那么这个

12:04.470 --> 12:06.250
插件它自然也可以注入

12:06.450 --> 12:07.490
像个实力

12:07.750 --> 12:10.810
像你这个原型上注入一些方法呀注入一些对象

12:11.070 --> 12:12.350
它实际上根本注入了一个对象

12:12.870 --> 12:14.130
注入了什么对象呢

12:14.650 --> 12:15.670
其中一个对象叫做

12:15.930 --> 12:19.010
夺了开头啊叫做肉子你看它也是符合命名规范的

12:19.270 --> 12:20.030
因为夺了开头

12:20.290 --> 12:22.070
啊尽量了补不去

12:22.330 --> 12:23.350
跟我们自己的

12:23.610 --> 12:24.370
呃

12:24.630 --> 12:26.690
Data呀Message呀进出迷

12:27.710 --> 12:28.990
这个对象这个对象是什么呢

12:29.250 --> 12:30.270
提供路由信息

12:31.810 --> 12:32.570
什么叫路由信息

12:32.830 --> 12:35.390
就是来自于地址南里边的各种信息

12:35.810 --> 12:38.410
什么访问的当前访问的路径是啥呀

12:38.670 --> 12:39.430
你看啊

12:39.690 --> 12:42.250
当前访问的路径是啥呀路径不就是这个吗

12:42.510 --> 12:45.450
哎这个路径里边哪一部分是动态的呀动态的值是啥呀

12:45.710 --> 12:46.870
对吧这些都是路由信息

12:47.130 --> 12:48.910
包括如果说你给了地址南参数

12:49.170 --> 12:50.450
那么地址南参数是啥呀

12:50.710 --> 12:52.490
地址南参数虽然说不影响匹配

12:52.750 --> 12:54.290
但是呢他也是路由信息的一部分

12:54.550 --> 12:56.850
对吧我们可以通过这个对象的来获取

12:57.110 --> 12:57.870
沟通路由信息

12:58.630 --> 13:00.050
所以说我们这样子就知道了

13:00.310 --> 13:02.990
哎那这边呢我们可以拿到他的路由信息

13:03.250 --> 13:04.270
我们来试一下啊拿一下

13:06.440 --> 13:07.640
我们随便到个地方吧

13:07.900 --> 13:08.740
creted里边吧

13:10.460 --> 13:11.140
creted

13:12.380 --> 13:12.940
creted

13:13.260 --> 13:14.140
说怎么不像呢

13:14.540 --> 13:15.320
输出什么呢

13:15.580 --> 13:17.060
原形上的怎么访问

13:17.880 --> 13:19.920
是不是就这一次啊就实力吗

13:20.180 --> 13:20.440
road

13:20.700 --> 13:21.720
我们输出一下这个road

13:23.100 --> 13:23.760
看一下吧

13:24.780 --> 13:25.300
刷新

13:26.060 --> 13:27.340
你看是不是输出了一个对象

13:27.820 --> 13:29.140
这个对象里边还告诉我哎

13:29.400 --> 13:31.460
完整的路径是这个你看他是不是这个

13:31.700 --> 13:32.740
我给他加上一些参数吧

13:33.240 --> 13:34.520
他参数他不影响匹配啊

13:34.780 --> 13:35.540
但是他也是

13:35.660 --> 13:37.140
他会影响路由的信息

13:38.660 --> 13:39.420
随便加一个吧

13:39.680 --> 13:42.500
你看啊完整路径是不是这个对不对

13:42.760 --> 13:44.300
那么路径呢是不是这个

13:44.820 --> 13:45.460
对不对

13:45.720 --> 13:48.020
我们的匹配到的路由名字是不是这个

13:48.260 --> 13:50.900
你看是不是我们各种路由的信息全部在里边了

13:51.160 --> 13:53.260
creted是什么的creted就是地转参数就这个

13:53.520 --> 13:54.740
他会把它转换成一个对象

13:55.560 --> 13:56.340
Name it

13:56.840 --> 13:59.740
其实他用什么转换的就是用那个第三方扣叫creted

14:00.000 --> 14:01.180
用它来进行转换的

14:01.700 --> 14:02.740
我们之前用过的

14:03.060 --> 14:04.280
还出了转换对象啊

14:04.520 --> 14:05.560
对象里面都是字无串啊

14:05.820 --> 14:08.320
因为他不知道你这里边他不会给你进行类型转换的

14:08.580 --> 14:09.600
都是字无串

14:09.860 --> 14:10.620
都没关系

14:11.660 --> 14:13.560
好然后呢其中有一个动态的部分

14:13.820 --> 14:15.620
看到没动态的部分就这一部分

14:16.000 --> 14:17.140
这一部分会变成什么呢

14:17.400 --> 14:18.820
变成这个属性叫paras

14:20.100 --> 14:22.660
动态就是地址地址中的动态部分

14:22.920 --> 14:24.200
那么动态部分是一个对象

14:24.460 --> 14:25.480
他会转换的对象

14:25.740 --> 14:28.300
转换对象的值呢属性值属性名

14:28.800 --> 14:32.380
属性名就是我们之前定义的那个

14:32.940 --> 14:33.600
这个名字

14:33.860 --> 14:35.380
说的这个名字还是有用的啊

14:35.620 --> 14:36.520
他会变成属性名

14:36.780 --> 14:38.320
你看我们4匹配到了他

14:38.580 --> 14:39.600
那么就形成了一个对象啊

14:39.860 --> 14:40.880
4匹配到了他

14:41.140 --> 14:41.920
就形成了一个对象

14:42.180 --> 14:42.920
对象里边

14:43.180 --> 14:45.600
creted ID

14:45.860 --> 14:46.260
那么4

14:47.020 --> 14:48.300
好理解吧当然是字无串啊

14:48.560 --> 14:49.840
好理解吧非常好理解

14:50.100 --> 14:51.900
那如果说你是多个多个动态部分的

14:52.140 --> 14:52.660
比方说啊

14:52.920 --> 14:53.940
我这里写个a

14:54.200 --> 14:56.240
1 2 3

14:56.500 --> 14:57.780
现在肯定匹配不上了啊

14:58.040 --> 15:00.600
那如果说匹配上这样子匹配上了呢就是如果说

15:01.080 --> 15:01.580
b

15:02.340 --> 15:04.280
c是不是可以匹配上有三个动态部分

15:04.520 --> 15:06.440
那么这个对象就变成了a为1

15:06.700 --> 15:07.980
当然是这不错啊

15:08.480 --> 15:10.020
b呢为2

15:11.820 --> 15:13.100
c呢为3

15:13.360 --> 15:14.120
明白了意思吧

15:14.380 --> 15:16.160
这就是paras这个数据

15:16.420 --> 15:17.200
很好理解吧

15:17.700 --> 15:18.460
不难啊

15:20.000 --> 15:23.340
好那么这个地方我们是不是可以通过他来获取到动态部分的

15:24.100 --> 15:24.620
那如果说

15:24.880 --> 15:26.920
没有动态部分呢我们来看一下没有动态部分

15:28.460 --> 15:29.740
我把参数保留吧

15:31.260 --> 15:33.100
没有动态部分他也能匹配到这个组件

15:33.620 --> 15:34.900
小心你看一下啊

15:35.940 --> 15:37.980
for pass 这些没问题啊 pass 都没问题

15:38.220 --> 15:40.020
carry是不是page name is都没问题啊

15:40.280 --> 15:41.560
然后我们来看一下这个

15:43.100 --> 15:44.380
paras是不是空对象啊

15:44.640 --> 15:46.680
因为他没有动态部分自然而然是空对象

15:47.460 --> 15:47.960
对吧

15:48.220 --> 15:49.240
这是roach这个

15:49.500 --> 15:51.040
注入的元性对象

15:51.540 --> 15:54.620
非常有用我们可以在代码中获取到的当前的路由信息

15:55.380 --> 15:57.940
其实说白了也就是地址中的提供了各种信息

15:58.640 --> 16:02.240
好来吧那如果说我这里要显示出你要哪个分类他还不简单吗

16:03.000 --> 16:04.800
分类 ID 为什么呢

16:05.320 --> 16:08.280
因为我们在制造模板里面了就可以直接就是那个

16:08.640 --> 16:10.680
组件实力了直接来roach

16:10.960 --> 16:12.080
第二什么

16:13.520 --> 16:14.960
对不对对象里面的什么

16:17.080 --> 16:20.420
没有的话就是 ond 犯的有的话那么自然而然他就是

16:20.680 --> 16:21.440
分类的 ID

16:21.960 --> 16:23.320
保存啊你看分类的 ID

16:23.560 --> 16:24.760
目前这种地址的他就没有

16:25.020 --> 16:26.040
那如果说这个种地址的

16:26.340 --> 16:26.900
开车

16:27.780 --> 16:28.820
分类的 ID 为3

16:29.060 --> 16:31.060
有这种地址的分类的 ID 为4

16:31.620 --> 16:32.500
没有意思吧

16:32.780 --> 16:34.820
好那么第一步了我们就

16:35.340 --> 16:39.300
OK了第一步完成了路由跳转逻辑我们就配置好了

16:40.220 --> 16:41.860
好那么接下来就是开发组件了

16:42.120 --> 16:43.660
就组件开发了他也不

16:44.420 --> 16:48.260
负责但是呢也要在我直到下开发不然的话你这一块会写的乱七八糟的

16:48.520 --> 16:52.860
刚刚开始吧很正常啊很正常也不要气嘞慢慢的你就找到这种感觉了

16:53.840 --> 16:56.640
咱们呢这个blog 组件呢就是我们这个

16:56.900 --> 16:58.080
是个页面是个组件吧

16:58.440 --> 17:00.680
这个组件呢他实际上是分为两个部分

17:00.940 --> 17:02.920
你看啊就左边这一块和右边这一块

17:03.180 --> 17:06.380
也就是我们在页面上对比一下对影一下啊就左边这一块

17:07.920 --> 17:08.420
和

17:09.440 --> 17:10.220
右边这一块

17:10.740 --> 17:11.760
无非就是两个组件吧

17:12.020 --> 17:13.800
然后呢把它组装到一个blog

17:14.060 --> 17:15.600
blog 这个页面里面不就完了吗

17:15.860 --> 17:16.620
是不是就两个组件

17:16.880 --> 17:19.080
好那么简单的看一下这两个组件要做什么事

17:19.440 --> 17:20.200
先简单的做一下

17:20.780 --> 17:24.100
左边这个组件呢他是要显示一个博客列表

17:24.660 --> 17:26.540
你看是不是显示个博客列表文章列表

17:26.800 --> 17:29.380
并且呢还要分页你看下面对一个分页吗

17:30.140 --> 17:31.300
下面看不清

17:32.940 --> 17:34.740
你看不得有个分页吗

17:35.000 --> 17:37.300
说他要显示分页啊要显示博客列表

17:37.820 --> 17:38.580
这没问题吧

17:41.140 --> 17:43.340
那么这个到底显示

17:43.600 --> 17:46.380
因为不显示博客列表显示文章列表就涉及到

17:46.640 --> 17:49.340
我的文章数据哪来那肯定得远程过去啊

17:49.800 --> 17:51.680
那远程过去的时候就设计到一些信息了

17:51.920 --> 17:52.980
哪个分类下的呀

17:53.240 --> 17:54.120
第几页呀

17:54.380 --> 17:55.480
没想是几条

17:55.740 --> 17:57.080
那么这些信息哪来

17:57.340 --> 17:58.620
从地址里边来

17:59.480 --> 18:00.920
也就是从路由信息里边来

18:01.180 --> 18:02.540
根据路由信息

18:03.120 --> 18:05.920
获取远程数据路由信息里面包含了分类吗

18:06.180 --> 18:08.620
包含了夜吗包含了夜容量

18:08.880 --> 18:10.620
那么这些信息是不是会获取远程数据了

18:10.880 --> 18:11.820
拿到远程数据

18:12.580 --> 18:13.620
渲染出来一个列表

18:15.140 --> 18:16.420
对吧就是这个简头的意思

18:16.680 --> 18:18.080
那么这个简头什么意思呢

18:18.980 --> 18:20.480
然后我们点分页的时候啊

18:20.480 --> 18:22.380
你看我们之前的功能没有啊

18:22.680 --> 18:24.880
点分页的时候实际上我们现在要做的事情

18:24.880 --> 18:25.880
是要改变地址

18:25.880 --> 18:26.980
是不是改变路由啊

18:27.680 --> 18:28.480
改变地址来

18:28.780 --> 18:29.880
所以说这里还有一个简头

18:29.880 --> 18:32.080
当我们点击分页的时候要改变地址

18:32.280 --> 18:33.180
第一次一遍

18:34.380 --> 18:36.080
是不是得从又重新来

18:36.180 --> 18:38.480
又根据路由信息获取远程数据

18:38.580 --> 18:40.280
又重新渲染人类列表

18:40.780 --> 18:41.980
等待用户点击分页

18:42.080 --> 18:43.680
一点击分页是不是又改变地址

18:43.780 --> 18:45.280
地址一遍又重新来

18:45.580 --> 18:46.580
对吧就这个图件的意思

18:46.580 --> 18:47.780
这个图件要做这么严实

18:49.080 --> 18:51.080
好另外一个图件叫block category

18:51.580 --> 18:54.080
什么意思呢就显示这个文章分类

18:54.780 --> 18:56.080
那么这个也是一样的

18:56.580 --> 18:59.080
我要根据路由信息显示激活状态

18:59.080 --> 19:00.080
你看一下吧

19:00.580 --> 19:03.580
我这个category id為2

19:03.580 --> 19:05.080
所以这个地方是激活的

19:05.780 --> 19:08.080
那如果说是id为3呢

19:08.580 --> 19:10.080
你看这个地方是不是激活的

19:10.080 --> 19:11.580
对吧这个地方是激活的

19:11.580 --> 19:14.080
根据路由信息显示激活状态

19:15.080 --> 19:15.580
这个没问题吧

19:15.580 --> 19:17.080
所以这个简头的意思

19:17.080 --> 19:18.080
那么这个简头什么意思呢

19:18.080 --> 19:20.080
就我们点击分类过后

19:20.580 --> 19:23.080
我要干嘛呀我要改变这个路由信息

19:23.080 --> 19:25.080
点击分类改变路由信息

19:25.080 --> 19:27.080
路由信息一变享用式吗

19:27.080 --> 19:28.080
路由信息一变

19:29.080 --> 19:30.580
那个路由对象是享用式的

19:31.080 --> 19:34.580
路由信息一变

19:34.580 --> 19:35.580
那么这个地方

19:37.080 --> 19:39.080
这个地方是不是就过来了

19:39.580 --> 19:42.080
又重新改变激活状态

19:42.080 --> 19:44.080
同时由于路由信息变了

19:44.080 --> 19:46.080
那么这个图件是不是也会跟这变

19:47.080 --> 19:48.080
路由信息变了

19:48.080 --> 19:50.080
那么这个只要重新获取文章列表

19:50.080 --> 19:51.080
重新完成分页

19:51.580 --> 19:52.080
对不对

19:52.080 --> 19:53.080
就这么个意思

19:53.580 --> 19:56.080
所以说呢我们这两个组件

19:56.080 --> 19:58.080
我们的组件书应该是这样子

19:58.080 --> 20:00.080
副组件就是一个blog

20:00.080 --> 20:02.080
它的指数件有两个blog list

20:02.080 --> 20:04.080
和blog passcode

20:05.080 --> 20:06.080
大家可以看到通过这个图

20:06.080 --> 20:07.080
我说还没有写代吗

20:07.080 --> 20:09.080
大家都可以看得很清楚了

20:10.080 --> 20:11.080
这两个组件之间

20:11.080 --> 20:13.080
是不是有一个间接通信啊

20:13.080 --> 20:14.080
看到没

20:15.080 --> 20:17.080
它改变了地址

20:18.080 --> 20:20.080
它是不是会改变地址南的Catscore

20:20.080 --> 20:22.080
对吧改变这个地方

20:22.080 --> 20:23.080
它改变了地址

20:23.080 --> 20:26.080
会导致它更新

20:26.080 --> 20:27.080
这个组件更新

20:28.080 --> 20:31.080
你看是不是这两个兄弟组件

20:31.080 --> 20:32.080
之前我们学过组件通信

20:32.080 --> 20:33.080
各种通信方式

20:33.080 --> 20:35.080
来我们回顾一下

20:35.080 --> 20:37.080
之前的组件通信

20:37.080 --> 20:39.080
你看prob event riffs

20:39.080 --> 20:41.080
你看这些通信

20:41.080 --> 20:43.080
能够在兄弟组件之间发生吗

20:43.080 --> 20:44.080
prob

20:44.080 --> 20:46.080
副组件到植入件的属性传递

20:46.080 --> 20:49.080
event植入件到副组件的世界传递

20:50.080 --> 20:52.080
riffs是直接获取某一个组件

20:52.080 --> 20:55.080
就副组件直接获取植入件的某一个引用

20:55.080 --> 20:58.080
它从来没有什么兄弟组件之间通信

20:58.080 --> 21:01.080
那么现在经过一个间接的路由

21:01.080 --> 21:03.080
是不是可以完成兄弟组件之间的通信了

21:03.080 --> 21:05.080
因此我们组件通信了多了一种方式

21:06.080 --> 21:09.080
叫做通过路由

21:10.080 --> 21:11.080
rotor

21:12.080 --> 21:15.080
通过路由间接

21:16.080 --> 21:20.080
在不同组件之间通信

21:20.080 --> 21:21.080
那么具体的做法

21:21.080 --> 21:23.080
那么这两个组件可以不是附质

21:23.080 --> 21:24.080
可以是兄弟

21:24.080 --> 21:26.080
也可以是任何毫无关系的组件都可以

21:26.080 --> 21:28.080
因为一个组件改变了路由

21:28.080 --> 21:29.080
另一个组件他发现路由变了

21:29.080 --> 21:32.080
他就会重新做出一些变化

21:32.080 --> 21:33.080
当然具体的话

21:33.080 --> 21:34.080
我们一会还要写代

21:34.080 --> 21:35.080
还会有些细节问题

21:35.080 --> 21:38.080
但是整体上我们有这么一个逻辑存在了

21:38.080 --> 21:39.080
所以组件通信

21:39.080 --> 21:41.080
又多了一个方式了

21:41.080 --> 21:42.080
对吧

21:42.080 --> 21:43.080
这是关于这一块

21:44.080 --> 21:45.080
整体的逻辑就是这样子

21:45.080 --> 21:47.080
当然就像我们来写

21:47.080 --> 21:48.080
第一个组件

21:48.080 --> 21:49.080
bloglist

21:49.080 --> 21:50.080
博客列表组件

21:50.080 --> 21:51.080
这个组件还没有

21:51.080 --> 21:53.080
那咱们来新建一个

21:53.080 --> 21:54.080
在blog里面

21:54.080 --> 21:56.080
component里面新建一个组件

21:56.080 --> 22:00.080
叫做bloglist.view

22:02.080 --> 22:05.080
那么这里的shebloglist

22:05.080 --> 22:06.080
先随便写一个吧

22:06.080 --> 22:07.080
一会我们还有一个组件

22:07.080 --> 22:10.080
叫做blogcast query

22:10.080 --> 22:14.080
就是我们的右边男分类的组件

22:14.080 --> 22:15.080
其实这个组件里面

22:15.080 --> 22:16.080
肯定要用到他

22:16.080 --> 22:17.080
我们之前写过的

22:17.080 --> 22:18.080
对吧

22:18.080 --> 22:19.080
把它封装一下

22:19.080 --> 22:23.080
那么这里写个blogcast query

22:23.080 --> 22:24.080
好了

22:24.080 --> 22:25.080
把这两个组件写好

22:25.080 --> 22:27.080
那么我们在博客组件里面

22:27.080 --> 22:28.080
怎么用呢

22:28.080 --> 22:29.080
其实我们就可以利用

22:29.080 --> 22:31.080
之前我们写的component里面

22:31.080 --> 22:33.080
不是写了一个布局组件吗

22:33.080 --> 22:35.080
还记得吗

22:35.080 --> 22:36.080
就这个layout

22:36.080 --> 22:37.080
布局组件

22:37.080 --> 22:39.080
左边男组区右边男

22:39.080 --> 22:40.080
那么我们左边男不要

22:40.080 --> 22:42.080
只需要中间组区和右边男

22:42.080 --> 22:43.080
对吧

22:43.080 --> 22:45.080
右边男放那个什么

22:45.080 --> 22:46.080
放什么

22:46.080 --> 22:48.080
放blogcast query

22:48.080 --> 22:49.080
中间这个组区放什么

22:49.080 --> 22:50.080
放bloglist

22:50.080 --> 22:51.080
不就完了吗

22:51.080 --> 22:52.080
还有啥

22:52.080 --> 22:54.080
所以说我们这里的blog

22:54.080 --> 22:56.080
其实非常简单

22:56.080 --> 22:58.080
我们导入这个布局组件

22:58.080 --> 23:02.080
layout from component

23:02.080 --> 23:03.080
layout

23:03.080 --> 23:04.080
导入它

23:04.080 --> 23:06.080
然后注册一下component

23:06.080 --> 23:08.080
layout

23:08.080 --> 23:11.080
同时导入刚才写的那两个组件

23:11.080 --> 23:13.080
一个是bloglist

23:13.080 --> 23:15.460
叫写纲

23:15.460 --> 23:18.460
当前目录下component里面的bloglist

23:18.460 --> 23:22.460
然后另外一个是blogcast query

23:22.460 --> 23:23.460
导入一下

23:23.460 --> 23:25.460
那么都注册进来

23:25.460 --> 23:27.460
bloglist

23:27.460 --> 23:30.460
blogcast query

23:30.460 --> 23:31.460
我们这里要写的模板

23:31.460 --> 23:32.460
其实也很简单

23:32.460 --> 23:37.920
就是layout

23:37.920 --> 23:39.920
这个组件里面的组区

23:39.920 --> 23:40.920
就是直接写

23:40.920 --> 23:43.920
组区其实就是一个bloglist

23:43.920 --> 23:44.920
这是组区

23:44.920 --> 23:48.920
右边男就是write

23:48.920 --> 23:52.240
一个具名插槽

23:52.240 --> 23:53.240
右边男

23:53.240 --> 23:55.240
右边男区我们这里

23:55.240 --> 24:00.800
就用blogcast query

24:00.800 --> 24:01.800
以后我们把这两个组件

24:01.800 --> 24:03.800
说好就OK了

24:03.800 --> 24:04.800
现在我们看一下

24:04.800 --> 24:06.800
看一下分男是不是出来了

24:06.800 --> 24:08.800
你看不得出来了吗

24:08.800 --> 24:09.800
我们这里看一下吧

24:09.800 --> 24:11.800
这是组区域吗

24:11.800 --> 24:13.800
这是write

24:13.800 --> 24:15.800
write是困地不变的

24:15.800 --> 24:16.800
团地不变

24:16.800 --> 24:18.800
那么组区团地是可以伸缩的

24:18.800 --> 24:19.800
这是我们之前做好的组件

24:19.800 --> 24:21.800
也不用去管它了

24:21.800 --> 24:27.330
没问题吧

24:27.330 --> 24:28.330
好了

24:28.330 --> 24:29.330
那么这个地方

24:29.330 --> 24:30.330
我们一个个来做

24:30.330 --> 24:35.330
首先我们来完成这个blog

24:36.330 --> 24:37.330
bloglist

24:37.330 --> 24:39.330
这个组件

24:39.330 --> 24:40.330
来吧

24:40.330 --> 24:43.330
这个组件有一些静态的央视

24:43.330 --> 24:45.330
央视我们就不用管它了

24:45.330 --> 24:48.330
我就直接把央视给你们提供出来了

24:48.330 --> 24:50.330
写央视挺费时间的

24:50.330 --> 24:54.330
同学们我还是鼓励同学们自己写

24:54.330 --> 24:55.330
最好

24:55.330 --> 24:56.330
我这里上课的时间

24:56.330 --> 24:58.330
就不要去浪费掉了

24:59.330 --> 25:07.960
本节课有这么一个东西

25:07.960 --> 25:08.960
就把这个复制一下

25:08.960 --> 25:11.960
放到bloglist里面

25:11.960 --> 25:13.960
就是央视给你们写好了

25:13.960 --> 25:14.960
央视已经写好了

25:14.960 --> 25:15.960
你们不用管了

25:15.960 --> 25:17.960
然后静态的内容已经写好了

25:17.960 --> 25:18.960
也不用管了

25:18.960 --> 25:21.960
就是把一个补课信息显示出来

25:21.960 --> 25:22.960
咱们来看一下

25:22.960 --> 25:24.960
目前就是这个样子

25:24.960 --> 25:25.960
一条补课信息

25:25.960 --> 25:26.960
然后这个是随便写写的

25:26.960 --> 25:28.960
以及静态内容

25:28.960 --> 25:29.960
那么我们要做的

25:29.960 --> 25:30.960
实际上就是一个li

25:30.960 --> 25:31.960
就是一个补课

25:31.960 --> 25:32.960
分页就放到这

25:32.960 --> 25:34.960
分页是不是我们要用到分页插件

25:35.960 --> 25:37.960
首先导入分页插件

25:43.960 --> 25:44.960
分页肯定要放到这个位置

25:44.960 --> 25:45.960
对不对

25:45.960 --> 25:47.960
放个分页

25:47.960 --> 25:48.960
注写一下逐渐

25:52.960 --> 25:53.960
分页放上

25:53.960 --> 25:55.960
上面这个UL就是一个列表

25:55.960 --> 25:59.960
就是我们的文章列表

25:59.960 --> 26:00.960
分页放上

26:00.960 --> 26:02.960
现在分页的一些属性

26:02.960 --> 26:03.960
都没有给它提供

26:03.960 --> 26:05.960
现在没有显示出分页

26:05.960 --> 26:06.960
打开了整个结构

26:06.960 --> 26:08.960
就差不多是这个样子

26:08.960 --> 26:10.960
然后我们这个组件

26:10.960 --> 26:12.960
肯定设计到远程加载数据

26:12.960 --> 26:13.960
并且还有个圈圈

26:13.960 --> 26:14.960
转一转

26:14.960 --> 26:16.960
你看看

26:16.960 --> 26:18.960
我们从手页写过来

26:18.960 --> 26:19.960
你看是不是个圈圈

26:19.960 --> 26:20.960
转一转

26:20.960 --> 26:21.960
对不对

26:21.960 --> 26:22.960
那么我们是不是可以利用

26:22.960 --> 26:23.960
之前的MX

26:23.960 --> 26:24.960
对吧

26:24.960 --> 26:25.960
还可以利用我们的

26:25.960 --> 26:27.960
全局的指令

26:27.960 --> 26:29.960
来吧

26:29.960 --> 26:31.960
咱们这里可以写上

26:31.960 --> 26:32.960
一个

26:32.960 --> 26:34.960
先把这些小的问题解决

26:34.960 --> 26:35.960
一些小的细节问题解决了

26:35.960 --> 26:37.960
它不但会干扰我们的

26:37.960 --> 26:39.960
开发进度

26:39.960 --> 26:40.960
首先我们导入

26:40.960 --> 26:41.960
之前的MX

26:41.960 --> 26:43.960
因为我们社交远程加载数据吧

26:43.960 --> 26:44.960
就是一个MX

26:44.960 --> 26:45.960
叫非期data

26:45.960 --> 26:48.960
之前写的MX

26:48.960 --> 26:49.960
非期data

26:49.960 --> 26:50.960
那么这里

26:50.960 --> 26:51.960
我们给它注入一个MX

26:51.960 --> 26:52.960
好

26:52.960 --> 26:53.960
那么注入这个MX

26:53.960 --> 26:54.960
是过后

26:54.960 --> 26:55.960
它就会有一个

26:55.960 --> 26:56.960
不错的效果

26:56.960 --> 26:57.960
什么效果呢

26:57.960 --> 26:58.960
就是它里边

26:58.960 --> 26:59.960
自动有了数据

26:59.960 --> 27:00.960
自动有了数据

27:00.960 --> 27:01.960
data

27:01.960 --> 27:03.960
这些数据其实都是有的

27:03.960 --> 27:04.960
那么我们现在

27:04.960 --> 27:05.960
要做的事情

27:05.960 --> 27:06.960
实际上就是

27:06.960 --> 27:08.960
给它提供一个方法

27:08.960 --> 27:09.960
方法

27:09.960 --> 27:10.960
而sync

27:10.960 --> 27:11.960
fetch

27:11.960 --> 27:12.960
data

27:12.960 --> 27:13.960
那么这个方法

27:13.960 --> 27:14.960
我们先用最简单的方式

27:14.960 --> 27:15.960
来实现一下

27:15.960 --> 27:17.960
就是来获取

27:17.960 --> 27:18.960
一些博客的列表

27:18.960 --> 27:20.960
获取一些博客的数据

27:20.960 --> 27:21.960
那么我们要获取

27:21.960 --> 27:22.960
博客的数据

27:22.960 --> 27:23.960
是不是要导入之前的API

27:23.960 --> 27:24.960
对不对

27:24.960 --> 27:25.960
来吧

27:25.960 --> 27:27.960
获取博客数据

27:27.960 --> 27:29.960
导入之前的API

27:29.960 --> 27:30.960
API

27:30.960 --> 27:31.960
blog

27:31.960 --> 27:32.960
这里面不是一个

27:32.960 --> 27:34.960
gass blog

27:34.960 --> 27:35.960
对不对

27:35.960 --> 27:36.960
这是一个异步方法

27:36.960 --> 27:37.960
那么我们这里

27:37.960 --> 27:39.960
调用这个异步方法

27:39.960 --> 27:40.960
什么差数

27:40.960 --> 27:41.960
蓝色卡传

27:41.960 --> 27:42.960
其实这里面还要传

27:42.960 --> 27:43.960
分夜码

27:43.960 --> 27:45.960
夜容量和分类的ID

27:45.960 --> 27:46.960
对不对

27:46.960 --> 27:47.960
那么这里面

27:47.960 --> 27:48.960
我蓝色卡传

27:48.960 --> 27:49.960
保持默认值

27:49.960 --> 27:50.960
就显示全部博客

27:50.960 --> 27:51.960
然后我这里

27:51.960 --> 27:52.960
直接返回了

27:52.960 --> 27:53.960
也不做啥

27:53.960 --> 27:54.960
直接返回

27:54.960 --> 27:55.960
得了

27:55.960 --> 27:57.960
但是现在就已经有效果了

27:57.960 --> 27:58.960
你看一下

27:58.960 --> 27:59.960
我们在这里呢

27:59.960 --> 28:02.960
伤心一下

28:02.960 --> 28:03.960
报了一个错

28:03.960 --> 28:04.960
我看一下

28:04.960 --> 28:05.960
把它错误先解决

28:05.960 --> 28:07.960
Connected Properties

28:07.960 --> 28:08.960
Probs

28:08.960 --> 28:13.720
Undefined

28:13.720 --> 28:14.720
它说有一个错误

28:14.720 --> 28:16.720
无法读取

28:16.720 --> 28:17.720
Probs属性

28:17.720 --> 28:21.600
这个错误哪来的

28:21.600 --> 28:22.600
我记起来了

28:22.600 --> 28:23.600
是这个地方

28:23.600 --> 28:24.600
Mixing是我们

28:24.600 --> 28:26.600
这里要传个默认值

28:26.600 --> 28:27.600
对不对

28:27.600 --> 28:28.600
它是个方法

28:28.600 --> 28:29.600
方法返回的

28:29.600 --> 28:30.600
对象

28:30.600 --> 28:31.600
我忘了

28:31.600 --> 28:32.600
这要传个默认值

28:32.600 --> 28:33.600
默认值就是

28:33.600 --> 28:35.600
我们的数据默认值

28:35.600 --> 28:36.600
那个数据格式

28:36.600 --> 28:37.600
你所想要知道

28:37.600 --> 28:38.600
我一个数据格式

28:38.600 --> 28:39.600
它不是个输主

28:39.600 --> 28:40.600
搞清楚

28:40.600 --> 28:42.600
我这个数据格式还记得吗

28:42.600 --> 28:44.600
它这个数据格式是一个对象

28:44.600 --> 28:45.600
对象里面

28:45.600 --> 28:46.600
若是这个属性

28:46.600 --> 28:47.600
才是个输主

28:47.600 --> 28:48.600
所以说

28:48.600 --> 28:49.600
这个数据的默认值

28:49.600 --> 28:50.600
就干默认一个对象

28:50.600 --> 28:51.600
或者是默认纳

28:51.600 --> 28:52.600
也可以

28:52.600 --> 28:53.600
对象

28:53.600 --> 28:54.600
默认一个空对象

28:54.600 --> 28:55.600
保存

28:55.600 --> 28:57.600
那现在我们来看一下

28:57.600 --> 28:58.600
伤心

28:58.600 --> 29:00.600
好像见面上看不到啥效果

29:00.600 --> 29:01.600
但是我们可以通过主见这里

29:01.600 --> 29:02.600
可以看到它的数据

29:02.600 --> 29:04.600
确实是有变化的

29:04.600 --> 29:09.260
这个Bloglist

29:09.260 --> 29:11.260
你看呀

29:11.260 --> 29:12.260
数据是不是变了

29:12.260 --> 29:13.260
data是不是有数据了

29:13.260 --> 29:14.260
is loading

29:14.260 --> 29:15.260
是为forced

29:15.260 --> 29:17.260
data是有数据的

29:17.260 --> 29:18.260
那么总数

29:18.260 --> 29:20.260
总的数据量2210

29:20.260 --> 29:22.260
然后Rose

29:22.260 --> 29:24.260
是我们的就是那个

29:24.260 --> 29:25.260
行

29:25.260 --> 29:26.260
一共有10条数据

29:26.260 --> 29:27.260
默认每页钱是10条吗

29:27.260 --> 29:28.260
是不是数据已经有了

29:28.260 --> 29:29.260
那其实数据有了

29:29.260 --> 29:31.260
我们要做的事情呢

29:31.260 --> 29:33.260
这个地方其实是不是

29:33.260 --> 29:34.260
已经可以写了

29:34.260 --> 29:35.260
v4

29:35.260 --> 29:36.260
for循环

29:36.260 --> 29:37.260
item in

29:37.260 --> 29:38.260
怎么呢

29:38.260 --> 29:39.260
data

29:39.260 --> 29:40.260
data叫什么

29:40.260 --> 29:41.260
Rose

29:41.260 --> 29:42.260
对不对

29:42.260 --> 29:43.260
data叫Rose

29:43.260 --> 29:44.260
循环这个数组

29:44.260 --> 29:45.260
把它渲染出来

29:45.260 --> 29:46.260
记得要把它绑定一个key

29:46.260 --> 29:47.260
key是什么呢

29:47.260 --> 29:48.260
key其实就是

29:48.260 --> 29:50.260
每一个行数据的id

29:50.260 --> 29:52.260
把它id绑定进去

29:52.260 --> 29:53.260
唯一嘛

29:53.260 --> 29:55.260
唯一钱稳定

29:55.260 --> 29:57.260
那么这里一个个写呗

29:57.260 --> 29:58.260
首先这个说裂图

29:58.260 --> 30:00.260
这个说裂图随便说一下

30:00.260 --> 30:01.260
这个说裂图呢

30:01.260 --> 30:03.260
它有可能有有可能没有

30:03.260 --> 30:04.260
之前我们在模拟数据的时候呢

30:04.260 --> 30:06.260
没有考虑到这一点

30:06.260 --> 30:07.260
这个说裂图啊

30:07.260 --> 30:08.260
我是一定是有的对吧

30:08.260 --> 30:09.260
这个模拟一个

30:09.260 --> 30:10.260
就随机一个图片

30:10.260 --> 30:11.260
但是实际上这个说裂图呢

30:11.260 --> 30:13.260
是有可能有

30:13.260 --> 30:14.260
有可能没有

30:14.260 --> 30:15.260
没了意思吧

30:15.260 --> 30:17.260
要因此这个说裂图啊

30:17.260 --> 30:18.260
我应该

30:18.260 --> 30:21.640
最好用这种方式来做

30:21.640 --> 30:22.640
这边呢

30:22.640 --> 30:24.640
我们写个1嘛

30:24.640 --> 30:27.640
给他一个数组

30:27.640 --> 30:29.640
数组里面有可能有说裂图

30:29.640 --> 30:30.640
有可能没有

30:30.640 --> 30:31.640
所以没有的话就是那

30:31.640 --> 30:32.640
对吧

30:32.640 --> 30:33.640
从数组里面选一个

30:33.640 --> 30:34.640
选一个说裂图

30:34.640 --> 30:35.640
或者是选一个那

30:35.640 --> 30:37.640
都可以

30:37.640 --> 30:38.640
好了

30:38.640 --> 30:39.640
这里把它改好了之后呢

30:39.640 --> 30:40.640
我们保存一下啊

30:40.640 --> 30:43.640
在这边也保存一下

30:43.640 --> 30:44.640
那么这样子呢

30:44.640 --> 30:45.640
我们得到的数据呢

30:45.640 --> 30:46.640
它有些就是有说裂图的

30:46.640 --> 30:47.640
有些就是没有的

30:47.640 --> 30:48.640
好

30:48.640 --> 30:49.640
咱们来看这个数据

30:49.640 --> 30:50.640
有些呢

30:50.640 --> 30:51.640
上本

30:51.640 --> 30:52.640
是不是那有些呢

30:52.640 --> 30:53.640
上本

30:53.640 --> 30:54.640
这个也是那

30:54.640 --> 30:55.640
这个也是那

30:55.640 --> 30:56.640
有这么不巧吗

30:57.640 --> 30:58.640
上吧

30:58.640 --> 30:59.640
你看有些是有

30:59.640 --> 31:00.640
有些是没有

31:00.640 --> 31:01.640
对吧

31:01.640 --> 31:02.640
那么这里的央视这一块呢

31:02.640 --> 31:03.640
就是这个DIV

31:03.640 --> 31:04.640
这个DIV是显示说裂图的

31:04.640 --> 31:05.640
央视银写好了

31:05.640 --> 31:06.640
你们自己去看一下

31:06.640 --> 31:07.640
样式啊

31:07.640 --> 31:08.640
我哪能说样式

31:08.640 --> 31:09.640
这个DIV有可能有

31:09.640 --> 31:10.640
有可能没有

31:10.640 --> 31:13.010
那么我就用VIF

31:13.010 --> 31:14.010
VIF呢

31:14.010 --> 31:15.010
我们这也顺便说一下

31:15.010 --> 31:16.010
有些人说

31:16.010 --> 31:17.010
那为什么不用

31:17.010 --> 31:18.010
没秀呢

31:18.010 --> 31:20.010
这不是说有些有些没有吗

31:20.010 --> 31:21.010
不是频繁切换吗

31:21.010 --> 31:22.010
哈哈哈

31:22.010 --> 31:23.010
频繁切换指的是

31:23.010 --> 31:24.010
同一个元素

31:24.010 --> 31:26.010
在那里频繁切换

31:26.010 --> 31:27.010
你这里循环生成

31:27.010 --> 31:29.010
每一次循环都是一个新的元素

31:29.010 --> 31:30.010
对不对

31:30.010 --> 31:31.010
每一个元素他要么就有

31:31.010 --> 31:32.010
要么就没有

31:32.010 --> 31:33.010
他不会一会有

31:33.010 --> 31:34.010
一会没有

31:34.010 --> 31:35.010
所以说这里的用VIF

31:35.010 --> 31:36.010
合适一点啊

31:36.010 --> 31:37.010
什么情况要显示呢

31:37.010 --> 31:39.010
就是item.sum

31:39.010 --> 31:41.010
有说的图的时候显示

31:41.010 --> 31:42.010
那么显示的时候

31:42.010 --> 31:43.010
这个超链接我们扔这

31:43.010 --> 31:44.010
以后再说这个

31:44.010 --> 31:45.010
超链接的问题

31:45.010 --> 31:46.010
因为这要挑转到

31:46.010 --> 31:48.010
文章的详情

31:48.010 --> 31:49.010
这里的详情

31:49.010 --> 31:50.010
我们还没有做

31:50.010 --> 31:51.010
超链接A元素先扔这

31:51.010 --> 31:52.010
好图片的链接地址呢

31:52.010 --> 31:53.010
我们这里呢

31:53.010 --> 31:54.010
就动态的绑垫

31:54.010 --> 31:55.010
绑垫什么呢

31:55.010 --> 31:56.010
item.sum

31:57.010 --> 31:59.010
图片的那个

31:59.010 --> 32:00.010
如果说图片显示不出来

32:00.010 --> 32:01.010
那么这里呢

32:01.010 --> 32:02.010
就显示一个文本

32:02.010 --> 32:03.010
图片的文本呢

32:03.010 --> 32:04.010
我们就绑定台头

32:04.010 --> 32:05.010
文章的标题

32:05.010 --> 32:07.010
那么这个

32:07.010 --> 32:08.010
鼠标移上去的

32:08.010 --> 32:09.010
这个提示文字呢

32:09.010 --> 32:11.010
也是图片标题

32:11.010 --> 32:13.010
把这个地方写好

32:13.010 --> 32:14.010
好保存啊

32:14.010 --> 32:15.010
你看一下这里

32:15.010 --> 32:17.010
文管怎么说

32:17.010 --> 32:18.010
你看

32:18.010 --> 32:19.010
其他的

32:19.010 --> 32:20.010
其他的数据呢

32:20.010 --> 32:21.010
不怎么样

32:21.010 --> 32:23.010
但是呢图片是不是搞定了

32:23.010 --> 32:25.010
说的图这一块搞定了

32:26.010 --> 32:27.010
好那么后边

32:27.010 --> 32:28.010
就这个东西

32:28.010 --> 32:29.010
这个地方就

32:29.010 --> 32:30.010
主席的信息了

32:30.010 --> 32:31.010
这里个A元素

32:31.010 --> 32:32.010
点击过后呢

32:32.010 --> 32:33.010
调整文章强情

32:33.010 --> 32:34.010
文章强情还没有做

32:34.010 --> 32:35.010
所以说先扔这吧

32:35.010 --> 32:36.010
那么这里的地方显示什么呢

32:36.010 --> 32:38.010
显示的是item.title

32:38.010 --> 32:39.010
文章标题

32:39.010 --> 32:40.010
好那这一部分显示什么呢

32:40.010 --> 32:42.010
显示的是文章的发布日期

32:42.010 --> 32:43.010
发布日期呢

32:43.010 --> 32:44.010
我们这里的是一个时间戳

32:44.010 --> 32:45.010
先把显示出来吧

32:45.010 --> 32:46.010
cris date

32:46.010 --> 32:47.010
这个时间戳

32:47.010 --> 32:48.010
我这一块要搞定的

32:48.010 --> 32:49.010
好浏蓝量

32:49.010 --> 32:50.010
浏蓝量呢

32:50.010 --> 32:52.010
是item scan number

32:52.010 --> 32:54.010
这些都没什么技术含量的

32:54.010 --> 32:55.010
评论

32:55.010 --> 33:03.010
评论的话是item.comment number

33:03.010 --> 33:04.010
对吧评论数量

33:04.010 --> 33:06.010
好那么这里呢一个分类

33:06.010 --> 33:08.010
分类的名字呢

33:08.010 --> 33:11.010
是不是来自于item.cascary

33:11.010 --> 33:12.010
看一下吧

33:12.010 --> 33:13.010
对到属性看一下

33:13.010 --> 33:14.010
也就明白了

33:14.010 --> 33:16.010
是这个cascary

33:16.010 --> 33:17.010
对象里面的name

33:17.010 --> 33:18.010
对不对

33:18.010 --> 33:21.010
cascary.name

33:21.010 --> 33:22.010
这个念节奏文人在

33:22.010 --> 33:23.010
有之后再说

33:23.010 --> 33:26.010
这是文章的描述

33:26.010 --> 33:30.010
描述的话就是item.cascary

33:30.010 --> 33:31.010
好了

33:31.010 --> 33:32.010
所以绑立进去了

33:32.010 --> 33:34.010
保存啊再看

33:34.010 --> 33:35.010
你看

33:35.010 --> 33:37.010
每篇文章是不是不一样啊

33:37.010 --> 33:38.010
但这些都是假的啊

33:38.010 --> 33:40.010
都是假的

33:40.010 --> 33:42.010
这个title太短了

33:42.010 --> 33:43.010
能不能把它变长一点

33:43.010 --> 33:45.010
我看一下不可接受

33:45.010 --> 33:48.010
怎么把这个title变长一点呢

33:48.010 --> 33:52.010
我们之前生成文本的时候

33:52.010 --> 33:54.010
在mock的一般

33:54.010 --> 33:56.010
生成文本的时候

33:56.010 --> 33:58.010
这里用的是ctitle对吧

33:58.010 --> 34:00.010
有一个name

34:00.010 --> 34:01.010
minmax

34:01.010 --> 34:08.500
最小只到最大只之间的一个数量

34:08.500 --> 34:10.500
我们这里来一个吧

34:10.500 --> 34:12.500
最小只呢

34:12.500 --> 34:13.500
一个只

34:13.500 --> 34:15.500
最大只呢

34:15.500 --> 34:17.500
50个只

34:17.500 --> 34:18.500
这样子

34:18.500 --> 34:19.500
这个标题

34:19.500 --> 34:21.500
标题是不是都没问题

34:21.500 --> 34:22.500
跟列表其实很好显示

34:22.500 --> 34:25.000
没有什么技术含量的

34:25.000 --> 34:26.000
就是你自己小心点

34:26.000 --> 34:29.000
这个有个小问题就是日期

34:29.000 --> 34:30.000
日期它是个时间戳

34:30.000 --> 34:32.000
那肯定不是很好

34:32.000 --> 34:34.000
我要把它显示成一个正确的格式

34:34.000 --> 34:35.000
这个正确的格式

34:35.000 --> 34:37.000
你可以用什么movement插件

34:37.000 --> 34:39.000
用movement的一些第三方库来弄

34:39.000 --> 34:40.000
不过我就这么一个小小的学校

34:40.000 --> 34:42.000
还要去弄一个movement

34:42.000 --> 34:43.000
那么大的一个库

34:43.000 --> 34:44.000
何必呢

34:44.000 --> 34:46.000
我就干脆在ut里面搞一个算了

34:46.000 --> 34:47.000
我有些问题

34:47.000 --> 34:48.000
新建设的

34:48.000 --> 34:50.000
新建设的

34:51.000 --> 34:52.000
格式化日期

34:52.000 --> 34:53.000
然后又导出一个函数

34:53.000 --> 34:55.000
这个函数也特别简单

34:55.000 --> 34:56.000
你给我一个时间戳

34:56.000 --> 34:58.000
time stamp

34:59.000 --> 35:00.000
那么我给你格式化

35:00.000 --> 35:02.000
成一个合适的日期格式

35:02.000 --> 35:03.000
那怎么来格式化呢

35:03.000 --> 35:04.000
我就留一个data

35:05.000 --> 35:06.000
这个都多简单嘛

35:06.000 --> 35:07.000
这个

35:07.000 --> 35:08.000
把它变成数字嘛

35:08.000 --> 35:09.000
它有可能是字部串

35:09.000 --> 35:10.000
有可能是数字

35:10.000 --> 35:11.000
把它变成数字再说

35:11.000 --> 35:12.000
我们得到一个

35:12.000 --> 35:13.000
一个

35:13.000 --> 35:14.000
一个

35:14.000 --> 35:16.000
一个

35:16.000 --> 35:17.000
一个

35:17.000 --> 35:18.000
一个

35:18.000 --> 35:19.000
一个

35:19.000 --> 35:20.000
不得到一个

35:20.000 --> 35:21.000
data

35:21.000 --> 35:22.000
得到一个日期

35:22.000 --> 35:23.000
然后直接返回吧

35:23.000 --> 35:24.000
返回这么一个格式

35:24.000 --> 35:26.000
连

35:26.000 --> 35:27.000
横杠

35:27.000 --> 35:28.000
越

35:28.000 --> 35:29.000
横杠

35:29.000 --> 35:30.000
日

35:30.000 --> 35:31.000
完了吧

35:31.000 --> 35:32.000
连的就是data

35:32.000 --> 35:33.000
get full year

35:33.000 --> 35:35.000
这个没什么好说的

35:35.000 --> 35:36.000
然后呢

35:36.000 --> 35:37.000
越呢get month

35:37.000 --> 35:39.000
记得加一

35:39.000 --> 35:40.000
然后呢

35:40.000 --> 35:42.000
日呢get date

35:42.000 --> 35:44.000
不就完了吗

35:44.000 --> 35:45.000
把这个format date

35:45.000 --> 35:48.000
导出

35:48.000 --> 35:49.000
导入

35:49.000 --> 35:50.000
默认的

35:50.000 --> 35:51.000
format date

35:51.000 --> 35:52.000
默认导出

35:52.000 --> 35:53.000
把他默认导出

35:53.000 --> 35:54.000
导出了导先导入

35:54.000 --> 35:55.000
改个名字

35:55.000 --> 35:57.000
改成format date

35:57.000 --> 35:59.000
那么这样子呢

35:59.000 --> 36:00.000
导出了

36:00.000 --> 36:01.000
重新导出

36:01.000 --> 36:02.000
就像这种逻辑

36:02.000 --> 36:03.000
就是一个文件

36:03.000 --> 36:04.000
牙里边有很多个模块

36:04.000 --> 36:05.000
那么通过一个index

36:05.000 --> 36:06.000
把它全部导出

36:06.000 --> 36:07.000
统一导出

36:07.000 --> 36:09.000
是一种非常常见的不做法

36:10.000 --> 36:12.000
然后到这边来

36:12.000 --> 36:14.000
回到我们之前这里

36:14.000 --> 36:15.000
那这里呢

36:15.000 --> 36:17.000
我们是不是可以用个方法

36:17.000 --> 36:18.000
用刚才那个方法

36:18.000 --> 36:19.000
把这个东西传进去

36:19.000 --> 36:21.000
得到一个合适的日期格式

36:21.000 --> 36:22.000
那么把这个方法导入进来啊

36:22.000 --> 36:23.000
导这个方法

36:23.000 --> 36:26.000
from utl

36:28.000 --> 36:30.000
那里面这个导出是叫什么呢

36:30.000 --> 36:33.000
叫format date

36:33.000 --> 36:34.000
好那么我问一下

36:34.000 --> 36:35.000
大家一个问题啊

36:35.000 --> 36:36.000
能不能直接在这里

36:36.000 --> 36:37.000
用这个方法

36:37.000 --> 36:38.000
能不能直接用啊

36:38.000 --> 36:42.510
你能直接用你就天鬼了

36:42.510 --> 36:44.510
保存你看一下

36:44.510 --> 36:45.510
你不能爆出太乖了

36:45.510 --> 36:46.510
哪有这个方法啊

36:46.510 --> 36:47.510
format date

36:47.510 --> 36:49.510
因为这个是模板

36:49.510 --> 36:50.510
模板里面用的是什么

36:50.510 --> 36:51.510
组件里边的东西

36:51.510 --> 36:52.510
这个是组件里面的东西吗

36:52.510 --> 36:53.510
不是

36:53.510 --> 36:54.510
那不是怎么办的

36:54.510 --> 36:55.510
把编程组件里面的东西

36:55.510 --> 36:56.510
不就完了吗

36:56.510 --> 36:58.510
你把这个玩意儿放在这

36:58.510 --> 37:00.510
不就是多了一个方法吗

37:00.510 --> 37:01.510
方法的名字叫这个

37:01.510 --> 37:02.510
方法的纸呢就是这个纸

37:02.510 --> 37:03.510
对不对

37:03.510 --> 37:05.510
那么就一个这个方法了嘛

37:05.510 --> 37:06.510
把这个可以传进去啊

37:06.510 --> 37:07.510
现在不就完了吗

37:08.510 --> 37:09.510
小心

37:10.510 --> 37:11.510
出来了啊

37:12.510 --> 37:13.510
这个你看

37:13.510 --> 37:15.510
日期啊日期在这

37:15.510 --> 37:16.510
日期在这

37:16.510 --> 37:17.510
日期呢

37:17.510 --> 37:18.510
如果说像这里的

37:18.510 --> 37:19.510
还要前面还加个0

37:19.510 --> 37:20.510
对不对

37:20.510 --> 37:21.510
还加个0保持

37:21.510 --> 37:23.510
保持是两位数的格式

37:23.510 --> 37:24.510
保持两位数的格式呢

37:24.510 --> 37:26.510
我这里再简单写一下啊

37:26.510 --> 37:27.510
这一刻的开发量

37:27.510 --> 37:28.510
还是比较多的

37:30.510 --> 37:31.510
慢慢来做吧

37:31.510 --> 37:32.510
遇到一个问题解决问题

37:32.510 --> 37:33.510
不要慌

37:34.510 --> 37:35.510
心中不慌

37:35.510 --> 37:36.510
好那么这个月呢

37:36.510 --> 37:38.510
我单独来弄一下吧

37:40.510 --> 37:42.510
月呢先是那个加1

37:42.510 --> 37:43.510
对不对

37:43.510 --> 37:44.510
加1过后呢

37:45.510 --> 37:46.510
啊

37:46.510 --> 37:47.510
变成致不错

37:47.510 --> 37:48.510
变成致不错过后呢

37:48.510 --> 37:49.510
然后用什么

37:51.510 --> 37:53.510
知道这个这个函数吧

37:53.510 --> 37:54.510
保证这个致不错

37:54.510 --> 37:56.510
有两个长度为二

37:56.510 --> 37:57.510
不足长度为二了呢

37:57.510 --> 37:59.510
我就在开始的位置

37:59.510 --> 38:00.510
给他填冲

38:00.510 --> 38:01.510
填冲什么的

38:01.510 --> 38:02.510
填冲你

38:03.510 --> 38:04.510
就这么意思

38:04.510 --> 38:05.510
好冒死人

38:05.510 --> 38:08.950
好同样道理呢

38:08.950 --> 38:09.950
日期呢

38:09.950 --> 38:10.950
电呢

38:10.950 --> 38:11.950
也越日吗

38:11.950 --> 38:12.950
电呢

38:12.950 --> 38:14.950
是get that

38:14.950 --> 38:18.860
get that

38:18.860 --> 38:19.860
得到日期部分

38:19.860 --> 38:20.860
变成致不错

38:20.860 --> 38:21.860
致不错里面一个方法

38:21.860 --> 38:23.860
还是一样pan start

38:23.860 --> 38:25.860
不不足二就填冲你

38:25.860 --> 38:27.860
那么这个地方使用电

38:27.860 --> 38:30.300
好

38:30.300 --> 38:31.300
保存

38:31.300 --> 38:32.300
那就看一看

38:32.300 --> 38:33.300
那不看

38:33.300 --> 38:34.300
这个部分铁冲好了吗

38:35.300 --> 38:36.300
很简单啊

38:36.300 --> 38:37.300
很简单挣动就行了

38:38.300 --> 38:40.300
好了那么这一部分呢

38:40.300 --> 38:42.300
列表是不是都弄完了

38:42.300 --> 38:43.300
都出来了

38:43.300 --> 38:44.300
还有个小的问题

38:44.300 --> 38:45.300
就是漏顶

38:45.300 --> 38:46.300
漏顶效果

38:46.300 --> 38:47.300
我们把这小的问题

38:47.300 --> 38:48.300
全部处理要

38:48.300 --> 38:50.300
然后进入我们的核心内容

38:50.300 --> 38:51.300
还有一种漏顶效果

38:51.300 --> 38:52.300
漏顶效果呢

38:52.300 --> 38:53.300
就是在这

38:53.300 --> 38:55.300
我们给他加上一个v-loading啊

38:55.300 --> 38:56.300
v-loading

38:56.300 --> 38:57.300
为什么呢

38:58.300 --> 38:59.300
为什么呢

38:59.300 --> 39:00.300
我一直漏顶

39:00.300 --> 39:02.300
我们之前混入的对象里面有

39:02.300 --> 39:03.300
给你看这些的

39:03.300 --> 39:04.300
其实也就是

39:04.300 --> 39:05.300
凸显出来了

39:05.300 --> 39:07.300
混入对象有一些不好的地方

39:07.300 --> 39:09.300
其中最明显的不好的地方是什么

39:09.300 --> 39:10.300
你不知道他混入了什么东西

39:10.300 --> 39:11.300
对不对

39:11.300 --> 39:12.300
你忘了

39:12.300 --> 39:13.300
容易忘记他混入了什么东西

39:13.300 --> 39:14.300
你要去看文档

39:15.300 --> 39:16.300
或者是看一下

39:16.300 --> 39:17.300
之前那个

39:17.300 --> 39:18.300
新的写法

39:18.300 --> 39:19.300
在这里的写法

39:19.300 --> 39:20.300
不然你又会忘记他混入了

39:20.300 --> 39:21.300
找道理混入了那些东西

39:21.300 --> 39:22.300
将来呢

39:22.300 --> 39:23.300
我又三立表用了

39:23.300 --> 39:25.300
那个completion api过后呢

39:25.300 --> 39:26.300
这个问题就解决了

39:26.300 --> 39:27.300
他就可以不用混入了

39:27.300 --> 39:28.300
不过混入这种思想呢

39:28.300 --> 39:29.300
要学习

39:29.300 --> 39:30.300
他其实是为了

39:30.300 --> 39:31.300
在不同的组件之间

39:31.300 --> 39:32.300
提取重复代码

39:33.300 --> 39:34.300
好保存啊

39:34.300 --> 39:35.300
我们来看一下

39:35.300 --> 39:36.300
这个漏顶效果是不是有了

39:36.300 --> 39:37.300
刷新

39:37.300 --> 39:38.300
你看是不是有漏顶呢

39:38.300 --> 39:39.300
对不对

39:39.300 --> 39:40.300
但是那有个小的问题啊

39:40.300 --> 39:41.300
如果说我把

39:41.300 --> 39:43.300
这个滚动墙滑下来过后

39:43.300 --> 39:44.300
再刷新

39:44.300 --> 39:46.300
到时候现在也能看到

39:46.300 --> 39:47.300
但是之后呢

39:47.300 --> 39:48.300
实际上是有一个问题的

39:48.300 --> 39:49.300
怎么问题呢

39:49.300 --> 39:51.300
我给大家画个图吧

39:51.300 --> 39:52.300
其实这里是一个问题的

39:52.300 --> 39:53.300
我之前做了个漏顶

39:53.300 --> 39:55.300
漏顶的指定的时候

39:55.300 --> 39:56.300
是没有

39:56.300 --> 39:57.300
没有考虑到的

39:57.300 --> 39:58.300
这个地方呢

39:58.300 --> 39:59.300
我们要处理一下啊

39:59.300 --> 40:01.300
实际上是要处理一下的

40:01.300 --> 40:03.300
现在大家可能

40:03.300 --> 40:04.300
不是很认识

40:04.300 --> 40:05.300
这个问题的存在

40:05.300 --> 40:06.300
那么以后我们看到

40:06.300 --> 40:07.300
这个问题再说吧

40:07.300 --> 40:08.300
那现在看上去

40:08.300 --> 40:09.300
好像是没问题的

40:09.300 --> 40:10.300
对不对

40:10.300 --> 40:11.300
好像是没问题的吧

40:12.300 --> 40:13.300
好OK啊

40:13.300 --> 40:14.300
那没问题

40:14.300 --> 40:15.300
我们就接着来吧

40:16.300 --> 40:17.300
现在我们进入了

40:17.300 --> 40:18.300
核心的地方

40:18.300 --> 40:21.610
BlockDisk里边的内在逻辑

40:21.610 --> 40:22.610
什么内在逻辑呢

40:22.610 --> 40:23.610
我们来梳理一下啊

40:23.610 --> 40:24.610
要梳理清楚了

40:24.610 --> 40:26.610
我们再来进行开发

40:26.610 --> 40:28.610
首先看这个箭头

40:28.610 --> 40:29.610
我们的地址男力表

40:29.610 --> 40:30.610
不是有很多信息吗

40:30.610 --> 40:31.610
之前不是说过

40:31.610 --> 40:32.610
BlockDisk的

40:32.610 --> 40:33.610
然后从地址男力表

40:33.610 --> 40:34.610
获取信息吗

40:34.610 --> 40:35.610
根据路由信息

40:35.610 --> 40:36.610
来显示文章列表

40:36.610 --> 40:37.610
因为不同的地址

40:37.610 --> 40:38.610
它显示文章列表

40:38.610 --> 40:39.610
是不一样的

40:39.610 --> 40:40.610
不同的页嘛

40:40.610 --> 40:41.610
不同的分类

40:41.610 --> 40:42.610
它显示文章列表

40:42.610 --> 40:43.610
肯定不一样

40:43.610 --> 40:44.610
我们要把这个信息

40:44.610 --> 40:45.610
放到哪呢

40:45.610 --> 40:46.610
通过一个综转

40:46.610 --> 40:47.610
就是计算属性

40:48.610 --> 40:50.610
通过计算属性

40:50.610 --> 40:51.610
我们是不是可以

40:51.610 --> 40:52.610
拿到这些信息啊

40:52.610 --> 40:54.610
拿到它是哪个分类的

40:54.610 --> 40:56.610
拿到它是哪一个页的

40:56.610 --> 40:58.610
拿到它每页钱是多少条

40:58.610 --> 41:01.610
可以通过计算属性来拿呀

41:01.610 --> 41:02.610
对不对

41:02.610 --> 41:03.610
这个没问题吧

41:03.610 --> 41:04.610
好

41:05.610 --> 41:07.610
我们先写上这个计算属性

41:07.610 --> 41:08.610
做一点写一点

41:09.610 --> 41:10.610
computed

41:11.610 --> 41:12.610
因为这个信息

41:12.610 --> 41:13.610
也不是我们自己

41:13.610 --> 41:14.610
自己直接写的

41:14.610 --> 41:15.610
它是来自于别的地方

41:15.610 --> 41:16.610
那么我们可以用

41:16.610 --> 41:17.610
计算属性来拿

41:17.610 --> 41:18.610
好

41:18.610 --> 41:19.610
来拿吧

41:19.610 --> 41:20.610
有哪一信息呢

41:20.610 --> 41:21.610
我们把它叫做

41:21.610 --> 41:22.610
road info吧

41:23.610 --> 41:24.610
路由信息

41:25.610 --> 41:26.610
肯定获取出来是个对象

41:26.610 --> 41:27.610
因为它里面信息很多

41:28.610 --> 41:34.420
获取路由信息

41:35.420 --> 41:36.420
有哪一信息呢

41:36.420 --> 41:37.420
一个一个来

41:37.420 --> 41:39.420
第一个信息是不是分类

41:39.420 --> 41:40.420
到底是哪一个分类

41:40.420 --> 41:41.420
对吧

41:41.420 --> 41:43.420
taskery id

41:43.420 --> 41:44.420
分类

41:44.420 --> 41:45.420
分类的话

41:45.420 --> 41:46.420
我们从哪一读呢

41:46.420 --> 41:47.420
是不是从这里读啊

41:48.420 --> 41:49.420
从路由

41:50.420 --> 41:51.420
从z什么之前读过的

41:51.420 --> 41:52.420
是吧

41:52.420 --> 41:53.420
road里边去读

41:53.420 --> 41:54.420
什么parals

41:54.420 --> 41:55.420
什么kaskery id

41:55.420 --> 41:56.420
还记得吧

41:56.420 --> 41:57.420
当时

41:58.420 --> 42:00.420
当时我们在定路由的时候

42:02.420 --> 42:03.420
在哪呢

42:03.420 --> 42:04.420
rotor

42:04.420 --> 42:05.420
定路由的时候

42:05.420 --> 42:06.420
是不是这个动态的

42:06.420 --> 42:07.420
从这里的这个地方去读

42:07.420 --> 42:08.420
但是如果说是

42:08.420 --> 42:09.420
这种地址的话

42:09.420 --> 42:10.420
是不是没有

42:10.420 --> 42:11.420
就没有这个kaskery

42:11.420 --> 42:12.420
总之我把它转成数字

42:12.420 --> 42:13.420
因为读出来是一个自读串

42:13.420 --> 42:14.420
把转成数字

42:14.420 --> 42:16.420
转发出来是不是有可能是NAN

42:16.420 --> 42:17.420
对不对

42:17.420 --> 42:18.420
所以有可能是NN

42:18.420 --> 42:19.420
非数字

42:19.420 --> 42:20.420
转发不出来

42:20.420 --> 42:21.420
那如果说你是非数字的话

42:21.420 --> 42:22.420
我就给它一个默认值

42:22.420 --> 42:24.420
默认值就是获取所有

42:24.420 --> 42:25.420
对吧

42:25.420 --> 42:26.420
你转发不出来

42:26.420 --> 42:27.420
说你没有给我提供分类id

42:27.420 --> 42:28.420
没有分类id的话

42:28.420 --> 42:29.420
就是负一

42:29.420 --> 42:30.420
对不对

42:30.420 --> 42:31.420
我们之前的一个接口里面

42:31.420 --> 42:32.420
不是也是吗

42:32.420 --> 42:33.420
负一表示

42:33.420 --> 42:36.420
获取所有的分类

42:37.420 --> 42:38.420
好来吧

42:38.420 --> 42:39.420
就给它负一

42:39.420 --> 42:40.420
分类id

42:40.420 --> 42:41.420
好

42:41.420 --> 42:42.420
这个信息是不是读出来了

42:42.420 --> 42:43.420
接下来我们再来看

42:43.420 --> 42:44.420
还要读什么呢

42:44.420 --> 42:45.420
还要读这个

42:45.420 --> 42:46.420
第几页

42:48.420 --> 42:49.420
第几页

42:49.420 --> 42:50.420
第几页我们应该怎么读呢

42:50.420 --> 42:52.420
读这也是肉车里面的

42:53.420 --> 42:54.420
query

42:54.420 --> 42:55.420
对不对

42:55.420 --> 42:56.420
读了一个地址蓝参数

42:56.420 --> 42:57.420
地址蓝参数是一个对象

42:57.420 --> 42:58.420
对象里面是不是可以

42:58.420 --> 43:00.420
它把它组装成对象了

43:00.420 --> 43:01.420
还记得吗

43:01.420 --> 43:02.420
当时我们组装成对象的指示

43:02.420 --> 43:03.420
是什么呢

43:03.420 --> 43:05.800
是这个

43:05.800 --> 43:08.800
page为17

43:08.800 --> 43:10.800
nimate为10

43:10.800 --> 43:11.800
对不对

43:11.800 --> 43:12.800
所以变成这样子了

43:12.800 --> 43:14.800
当然我们还是把它转成数字

43:14.800 --> 43:15.800
来吧

43:15.800 --> 43:16.800
query

43:16.800 --> 43:17.800
page

43:17.800 --> 43:18.800
所以转成数字

43:18.800 --> 43:19.800
读出来

43:19.800 --> 43:20.800
转成数字过后也有可能是n

43:20.800 --> 43:21.800
因为它有可能

43:21.800 --> 43:22.800
没有传递这个地址参数

43:22.800 --> 43:23.800
没有传递到我

43:23.800 --> 43:24.800
我会给它一个默认值

43:24.800 --> 43:25.800
默认第几页

43:25.800 --> 43:26.800
默认当然是第1页

43:27.800 --> 43:28.800
对不对

43:28.800 --> 43:29.800
你看就可以通过

43:29.800 --> 43:30.800
这种计算属性中转一下

43:30.800 --> 43:31.800
好

43:31.800 --> 43:32.800
然后呢

43:32.800 --> 43:33.800
再来一个limit

43:33.800 --> 43:34.800
limit的话也是一样的道理

43:34.800 --> 43:36.800
road

43:37.800 --> 43:38.800
query

43:38.800 --> 43:39.800
limit

43:39.800 --> 43:40.800
如果说没有这个值呢

43:40.800 --> 43:41.800
我就该取一个10

43:41.800 --> 43:43.800
默认显示10条

43:44.800 --> 43:45.800
是不是搞定了

43:45.800 --> 43:46.800
对吧

43:47.800 --> 43:48.800
好

43:48.800 --> 43:49.800
那么这样子呢

43:49.800 --> 43:50.800
是不是得到三个信息了

43:50.800 --> 43:51.800
三个信息是不是够了

43:51.800 --> 43:52.800
对不对

43:52.800 --> 43:53.800
我们就返回

43:53.800 --> 43:55.800
路由里面不就提供这三个信息吧

43:55.800 --> 43:56.800
castquery

43:56.800 --> 43:57.800
id

43:57.800 --> 43:58.800
page

43:58.800 --> 44:01.800
nimate

44:02.800 --> 44:03.800
路由信息

44:04.800 --> 44:05.800
好

44:05.800 --> 44:06.800
然后再来

44:06.800 --> 44:08.800
我们这里就可以

44:09.800 --> 44:11.800
试一下

44:11.800 --> 44:12.800
crate的时候

44:12.800 --> 44:14.800
试一下路由信息对不对

44:14.800 --> 44:15.800
输出

44:15.800 --> 44:16.800
this

44:16.800 --> 44:18.800
roadinfo

44:18.800 --> 44:19.800
保存

44:19.800 --> 44:20.800
你看一下

44:20.800 --> 44:21.800
打印出来

44:21.800 --> 44:22.800
你看这个信息对不对

44:22.800 --> 44:24.800
castqueryid是不是4

44:24.800 --> 44:25.800
limit是不是10

44:25.800 --> 44:26.800
page是不是3

44:26.800 --> 44:28.800
那如果说不给他传这个呢

44:31.680 --> 44:32.680
你看这里

44:32.680 --> 44:33.680
castqueryid是4

44:33.680 --> 44:34.680
limit10

44:34.680 --> 44:35.680
page1

44:35.680 --> 44:36.680
默认值

44:36.680 --> 44:37.680
那如果说给他个article呢

44:38.680 --> 44:39.680
得到castqueryid为-1

44:39.680 --> 44:40.680
limit10

44:40.680 --> 44:41.680
page1

44:41.680 --> 44:42.680
是不是都正确了

44:42.680 --> 44:43.680
一个地方给他传一个

44:43.680 --> 44:44.680
page等于

44:44.680 --> 44:45.680
3

44:45.680 --> 44:46.680
limit

44:46.680 --> 44:47.680
等于30

44:48.680 --> 44:50.680
你看是不是都好了

44:50.680 --> 44:51.680
路由信息是

44:51.680 --> 44:52.680
通过这个计算属性

44:52.680 --> 44:53.680
就可以获取到了

44:53.680 --> 44:54.680
好 继续啊

44:54.680 --> 44:56.680
拿这个计算属性有什么用的

44:56.680 --> 44:58.680
这个计算属性很有用的

44:58.680 --> 44:59.680
一个来

44:59.680 --> 45:01.680
首先我们不是有个方法

45:01.680 --> 45:02.680
叫face data吗

45:02.680 --> 45:03.680
对不对

45:03.680 --> 45:05.680
这非在data起什么作用啊

45:05.680 --> 45:07.680
是不是获取远程数据

45:07.680 --> 45:09.680
获取远程数据的时候

45:09.680 --> 45:10.680
在这

45:10.680 --> 45:11.680
获取远程数据的时候

45:11.680 --> 45:13.680
这里不得传吗

45:13.680 --> 45:14.680
传第几页

45:14.680 --> 45:15.680
没钱多少条

45:15.680 --> 45:16.680
哪个分类

45:16.680 --> 45:17.680
都得有啊

45:17.680 --> 45:18.680
那么这个信息哪来

45:18.680 --> 45:19.680
是不是可以通过一个

45:19.680 --> 45:20.680
计算属性来啊

45:20.680 --> 45:21.680
好 来看啊

45:21.680 --> 45:22.680
我们这里是不是可以传

45:22.680 --> 45:23.680
第Zs

45:23.680 --> 45:25.680
RouteInfo里面的page

45:25.680 --> 45:26.680
第几页

45:26.680 --> 45:27.680
Zs

45:27.680 --> 45:28.680
RouteInfo里面的什么

45:28.680 --> 45:29.680
limit

45:29.680 --> 45:30.680
没钱多少条

45:30.680 --> 45:31.680
还有什么

45:31.680 --> 45:33.680
RouteInfo里面的castqueryid

45:33.680 --> 45:36.380
保存

45:36.380 --> 45:37.380
你看一下啊

45:37.380 --> 45:38.380
那么目前呢

45:38.380 --> 45:39.380
我们现在

45:40.380 --> 45:41.380
刷新

45:41.380 --> 45:44.970
然后你这里

45:44.970 --> 45:45.970
这里倒是看不出来

45:45.970 --> 45:46.970
那我们在这边

45:46.970 --> 45:47.970
来测试一下吧

45:47.970 --> 45:48.970
在我们之前的API里面

45:48.970 --> 45:49.970
来测试一下

45:54.950 --> 45:55.950
之前

45:55.950 --> 45:56.950
把这个就删掉了啊

45:57.950 --> 45:58.950
之前

45:58.950 --> 46:00.950
我们默可数据这一块

46:00.950 --> 46:01.950
默可数据这一块

46:01.950 --> 46:02.950
我们来

46:03.950 --> 46:04.950
不在这

46:04.950 --> 46:06.950
我们在这个API里面吧

46:06.950 --> 46:08.950
我们看API的调用

46:08.950 --> 46:09.950
因为都是测试数据

46:09.950 --> 46:10.950
倒是看不太出来

46:10.950 --> 46:11.950
把page

46:11.950 --> 46:12.950
limit

46:12.950 --> 46:14.950
就是那个castqueryid

46:17.950 --> 46:18.950
保存

46:18.950 --> 46:19.950
你看是不是3

46:19.950 --> 46:21.950
30-1

46:21.950 --> 46:22.950
如果说我这里

46:22.950 --> 46:24.950
它就得到了这样的远程数据

46:24.950 --> 46:26.950
那如果说我这辆传递呢

46:26.950 --> 46:27.950
它得到的是

46:27.950 --> 46:29.950
1-13

46:29.950 --> 46:30.950
第一页每页十条

46:30.950 --> 46:31.950
分类ID为3

46:31.950 --> 46:32.950
那么如果说

46:32.950 --> 46:33.950
到时候不是测试数据了

46:33.950 --> 46:34.950
是不是得到的真实数据了

46:34.950 --> 46:35.950
就从服务器拿到

46:35.950 --> 46:37.950
分类ID为3

46:37.950 --> 46:38.950
第一页每页

46:38.950 --> 46:39.950
每页十条

46:39.950 --> 46:40.950
对不对

46:40.950 --> 46:41.950
好

46:41.950 --> 46:42.950
那么这样就搞定了

46:43.950 --> 46:44.950
现在我们把

46:44.950 --> 46:45.950
就把这一步搞定了

46:45.950 --> 46:46.950
去计算属性

46:46.950 --> 46:48.950
来得到正确的远程数据

46:48.950 --> 46:49.950
只不过目前的远程数据

46:49.950 --> 46:50.950
是测试

46:50.950 --> 46:51.950
如果说将来没有测试

46:51.950 --> 46:53.950
就正确的远程数据了

46:53.950 --> 46:54.950
好

46:54.950 --> 46:55.950
下面先不看

46:55.950 --> 46:56.950
先不着急

46:56.950 --> 46:57.950
好

46:57.950 --> 46:58.950
接下来我们来看分页

46:58.950 --> 47:00.950
我们分页有个组件

47:00.950 --> 47:01.950
分页组件

47:01.950 --> 47:03.950
我们之前做过的pager

47:03.950 --> 47:04.950
它不是有些属性

47:04.950 --> 47:05.950
有些方法吗

47:05.950 --> 47:07.950
我们一个个该传递

47:07.950 --> 47:08.950
传递属性方法

47:08.950 --> 47:09.950
分页组件

47:09.950 --> 47:11.950
当前的页嘛

47:11.950 --> 47:12.950
是多少呢

47:12.950 --> 47:13.950
current

47:14.950 --> 47:15.950
当前页嘛

47:15.950 --> 47:16.950
来自于哪呢

47:16.950 --> 47:18.950
是不是来自于

47:19.950 --> 47:21.950
当前页嘛

47:21.950 --> 47:22.950
来自于

47:23.950 --> 47:24.950
来自于哪

47:25.950 --> 47:27.950
是不是就来自于路由信息

47:27.950 --> 47:29.950
我都只写蒙了

47:29.950 --> 47:30.950
road info

47:30.950 --> 47:31.950
点配级

47:31.950 --> 47:32.950
当前页嘛来自于这

47:33.950 --> 47:34.950
一是它传递

47:34.950 --> 47:35.950
看这张图

47:39.030 --> 47:41.030
这个计算属性里面的路由信息

47:41.030 --> 47:43.030
有一部分还会传给分页组件

47:43.030 --> 47:44.030
分页组件里面有些信息

47:44.030 --> 47:45.030
来自于计算属效

47:46.030 --> 47:47.030
好

47:47.030 --> 47:48.030
总数据量

47:48.030 --> 47:49.030
这个地方要说一下

47:49.030 --> 47:50.030
总数据量

47:50.030 --> 47:52.030
总数据量来自于哪呢

47:53.030 --> 47:55.030
路由信息里面有总数据量吗

47:56.030 --> 47:57.030
没有

47:57.030 --> 47:59.030
总数据量是谁给我们的

48:01.030 --> 48:02.030
总数据量是谁给我们的

48:02.030 --> 48:04.030
所以远程服务器

48:04.030 --> 48:06.030
怎么来自于data里面的头脱

48:07.030 --> 48:08.030
对不对

48:08.030 --> 48:09.030
怎么来自于这

48:09.030 --> 48:11.030
那么首先data里面有没有头脱

48:11.030 --> 48:13.030
那我给它加上一个配衣服

48:13.030 --> 48:14.030
如果说data里面

48:14.030 --> 48:15.030
data里面有没有头脱

48:15.030 --> 48:17.030
因为它一开始数据还没有加载出来

48:17.030 --> 48:19.030
那肯定是不能显示分页组件的

48:19.030 --> 48:21.030
只有头脱数据量有的时候

48:21.030 --> 48:23.030
我们才显示分页组件

48:23.030 --> 48:24.030
有头脱的时候

48:24.030 --> 48:25.030
那么这个头脱的值呢

48:26.030 --> 48:28.030
说来自于data里面

48:28.030 --> 48:29.030
这个很简单

48:30.030 --> 48:32.030
还有什么属性要传递呢

48:32.030 --> 48:35.750
还有这个limit

48:36.750 --> 48:37.750
夜容量

48:37.750 --> 48:38.750
所以你来自于分页信息

48:38.750 --> 48:39.750
对不对

48:39.750 --> 48:40.750
来自于什么

48:40.750 --> 48:42.750
road info的limit

48:43.750 --> 48:45.750
还有什么呢

48:45.750 --> 48:47.750
还有这个visible number

48:47.750 --> 48:48.750
可见夜码数

48:48.750 --> 48:50.750
这个东西呢就固定吧

48:51.750 --> 48:52.750
显示10个夜码

48:52.750 --> 48:53.750
最多显示10个夜码

48:53.750 --> 48:54.750
数值夜码

48:54.750 --> 48:55.750
好保存

48:55.750 --> 48:56.750
你看一下这个分页就出来了

49:00.020 --> 49:03.460
你看分页是不是出来了

49:04.460 --> 49:05.460
分页就出来了

49:05.460 --> 49:06.460
一共多少页呢

49:06.460 --> 49:07.460
我现在点了过后

49:07.460 --> 49:08.460
点过没有反应

49:08.460 --> 49:09.460
是因为我们没有注册试件

49:09.460 --> 49:10.460
因为它还有一个试件

49:11.460 --> 49:12.460
是不是page change试件

49:12.460 --> 49:13.460
好来吧

49:13.460 --> 49:14.460
给它注册一个试件

49:15.460 --> 49:16.460
page change试件

49:16.460 --> 49:17.460
那么给它写个方法

49:17.460 --> 49:18.460
handle page change

49:23.760 --> 49:24.760
在这

49:25.760 --> 49:27.760
处理夜码变化

49:28.760 --> 49:30.760
那么夜码变了过后要干嘛呀

49:31.760 --> 49:32.760
我们这里它不是

49:32.760 --> 49:33.760
到时候给我们一个新的夜码

49:33.760 --> 49:34.760
对吧

49:34.760 --> 49:35.760
试件参数是一个新的夜码

49:35.760 --> 49:37.760
那么我们这里随便用一个吧

49:37.760 --> 49:38.760
扭配起来得到

49:39.760 --> 49:40.760
扭配起

49:40.760 --> 49:41.760
好保存啊

49:41.760 --> 49:43.760
我来看一下个新的夜码多少

49:43.760 --> 49:46.130
点击

49:47.130 --> 49:48.130
2

49:48.130 --> 49:49.130
说第二页

49:49.130 --> 49:50.130
点击这个最后一页

49:50.130 --> 49:51.130
一共有224页

49:52.130 --> 49:53.130
点击下一页

49:53.130 --> 49:54.130
对吧

49:54.130 --> 49:55.130
点击第十页

49:55.130 --> 49:56.130
新的夜码说拿到了

49:56.130 --> 49:57.130
点这些都没用

49:59.130 --> 50:00.130
好那么拿到新的夜码

50:00.130 --> 50:01.130
我们要干嘛呀

50:01.130 --> 50:02.130
还记得吗

50:03.130 --> 50:04.130
我们要干嘛呀

50:05.130 --> 50:06.130
处理分页

50:06.130 --> 50:07.130
我们要干嘛

50:07.130 --> 50:09.130
我们要改变路由

50:10.130 --> 50:11.130
对不对

50:11.130 --> 50:12.130
什么改变路由啊

50:12.130 --> 50:13.130
改变了

50:13.130 --> 50:14.130
改变这儿

50:14.130 --> 50:15.130
其他的不变

50:16.130 --> 50:17.130
你之前是多少

50:17.130 --> 50:18.130
哪个分类就是哪个分类

50:18.130 --> 50:20.130
之前是哪个分类就是哪个分类

50:20.130 --> 50:21.130
然后呢

50:21.130 --> 50:22.130
之前是多少你每次

50:22.130 --> 50:23.130
我不变

50:23.130 --> 50:24.130
我就改变什么了

50:24.130 --> 50:25.130
改变夜码

50:26.130 --> 50:27.130
对不对

50:27.130 --> 50:29.130
那么这就涉及到一个问题

50:29.130 --> 50:30.130
我这里要干嘛呀

50:31.130 --> 50:33.130
要挑转到

50:34.130 --> 50:37.130
当前的分类ID

50:38.130 --> 50:40.130
当前的夜容量

50:41.130 --> 50:44.130
New page的夜码

50:44.130 --> 50:46.130
要挑了到这样一个地址

50:46.130 --> 50:47.130
那么这个地址呢

50:48.130 --> 50:49.130
是不是有可能是两种

50:50.130 --> 50:51.130
一种是什么呢

50:51.130 --> 50:52.130
一种是这样的地址

50:53.130 --> 50:54.130
article

50:54.130 --> 50:56.130
就是他没有分类

50:56.130 --> 50:57.130
没有分类是不是这个地址

50:57.130 --> 50:59.130
然后呢配一起等于什么

50:59.130 --> 51:00.130
这个New page

51:00.130 --> 51:02.130
等于这个New page

51:03.130 --> 51:04.130
New page

51:04.130 --> 51:05.130
所以要挑转到这儿

51:05.130 --> 51:06.130
之前的limit

51:06.130 --> 51:08.130
等于原来的limit

51:08.130 --> 51:09.130
原来的limit是不是

51:09.130 --> 51:12.130
这也是road info的limit

51:12.130 --> 51:14.130
所以要这样挑出来

51:14.130 --> 51:15.130
但这样

51:15.130 --> 51:17.130
还有一个地址呢是这个

51:18.130 --> 51:19.130
还有一种地址

51:19.130 --> 51:20.130
就是他现在有分类

51:21.130 --> 51:22.130
article

51:23.130 --> 51:24.130
这个地方

51:24.130 --> 51:25.130
我们要填什么了

51:25.130 --> 51:27.130
填分类的ID

51:27.130 --> 51:29.130
this isroad info

51:29.130 --> 51:30.130
cascaryID

51:31.130 --> 51:33.130
然后参数

51:33.130 --> 51:35.130
配一起等于新的夜码

51:35.130 --> 51:37.130
后面都一样了

51:37.130 --> 51:39.830
好输了一下

51:39.830 --> 51:41.830
是不是就这两种情况

51:41.830 --> 51:42.830
两种地址

51:42.830 --> 51:43.830
那么这到底挑转到哪一个

51:43.830 --> 51:44.830
是不是我们可以判断

51:45.830 --> 51:46.830
判断什么

51:46.830 --> 51:47.830
判断当前有没有分类

51:48.830 --> 51:49.830
如果说当前

51:49.830 --> 51:50.830
怎么来判断当前有没有分类

51:50.830 --> 51:51.830
road info

51:51.830 --> 51:52.830
cascaryID

51:52.830 --> 51:53.830
等于-1

51:53.830 --> 51:55.830
说当前没有分类

51:55.830 --> 51:57.830
当前没有分类

51:58.830 --> 52:00.830
没有分类应该怎么样

52:00.830 --> 52:01.830
这个时候我们应该

52:01.830 --> 52:03.830
挑转到这个地址

52:03.830 --> 52:07.780
挑转到这种地址

52:07.780 --> 52:09.780
else有分类

52:09.780 --> 52:10.780
有分类

52:10.780 --> 52:11.780
我们是不是要挑转到

52:11.780 --> 52:14.600
这种地址

52:14.600 --> 52:17.600
现在问题是怎么跳出来

52:17.600 --> 52:19.600
现在还在把这个东西

52:19.600 --> 52:20.600
拦住了

52:20.600 --> 52:21.600
我们是不是可以用

52:21.600 --> 52:23.600
location和ref来挑软

52:23.600 --> 52:24.600
可以倒是可以

52:24.600 --> 52:25.600
刷新页面

52:26.600 --> 52:27.600
我们现在要做无刷新的

52:27.600 --> 52:28.600
对吧

52:28.600 --> 52:29.600
只是切换主件而已

52:29.600 --> 52:30.600
无刷新挑转

52:30.600 --> 52:31.600
你这个玩意肯定要刷新页面的

52:31.600 --> 52:32.600
一切都在重新来

52:32.600 --> 52:34.600
这样肯定是可以的

52:34.600 --> 52:35.600
功能肯定可以实现

52:35.600 --> 52:36.600
一切重新来就重新来一遍

52:36.600 --> 52:38.600
它又重新根据刷新的过后

52:38.600 --> 52:40.600
又重新根据地址

52:40.600 --> 52:41.600
重新来一遍

52:41.600 --> 52:42.600
肯定是可以的

52:42.600 --> 52:45.600
但是我们要做无刷新的挑转

52:46.600 --> 52:47.600
怎么办

52:47.600 --> 52:49.600
之前我们学过这个rotor

52:49.600 --> 52:51.600
它根本提供了一个rotolink逐渐

52:51.600 --> 52:52.600
可以实现无刷新的挑转

52:52.600 --> 52:54.600
这个主件实现出来是个air元数

52:54.600 --> 52:56.600
要点了air元数过后才会挑转

52:56.600 --> 52:59.600
那么现在我们是要在代码里边挑转

53:00.600 --> 53:02.600
那问题是怎么在代码里边挑转的

53:03.600 --> 53:05.600
这要受到另外一个问题了

53:05.600 --> 53:07.600
唯有rotolink给我们注入的

53:07.600 --> 53:09.600
原型对象里面不仅有一个rot

53:09.600 --> 53:11.600
还用一个rot

53:11.600 --> 53:13.600
单词差不多

53:13.600 --> 53:15.600
但是一个e一个是r

53:15.600 --> 53:16.600
这都是路由信息

53:16.600 --> 53:18.600
这个玩意是用于

53:19.600 --> 53:21.600
控制页面挑转

53:22.600 --> 53:24.600
转来用来控制页面挑转

53:24.600 --> 53:27.600
它可以实现在代码的中来进行挑转页面

53:27.600 --> 53:29.600
并且是无刷新的

53:29.600 --> 53:31.600
那怎么来具体怎么做呢

53:31.600 --> 53:32.600
其实你可以看一下下面的

53:32.600 --> 53:34.600
动态路由的

53:34.600 --> 53:36.600
编程式的导航

53:36.600 --> 53:37.600
非常简单

53:37.600 --> 53:38.600
就是

53:38.600 --> 53:40.600
它可以提供一个rotor

53:40.600 --> 53:41.600
一个r

53:41.600 --> 53:42.600
它里边提供了很多方法

53:42.600 --> 53:44.600
其中一个方法要push

53:44.600 --> 53:45.600
就是挑转

53:45.600 --> 53:46.600
里边写挑转地址

53:46.600 --> 53:48.600
你把刚刚的地址拼接一下挑转

53:48.600 --> 53:49.600
就普通挑转

53:49.600 --> 53:50.600
也可以呢

53:50.600 --> 53:52.600
跟那个rotor link是一样的

53:52.600 --> 53:54.600
那么它也可以给它一个对象

53:54.600 --> 53:55.600
给对象

53:55.600 --> 53:57.600
就可以利用命名路由了

53:57.600 --> 53:58.600
那么这样子可以解除

53:58.600 --> 54:01.600
跟路由地址的偶和

54:01.600 --> 54:02.600
这样子比较好一点

54:02.600 --> 54:03.600
虽然它写的也比较繁琐

54:03.600 --> 54:05.600
但是这样子做的肯定是好一些的

54:06.600 --> 54:08.600
那么我们就用命名路由来挑转

54:08.600 --> 54:10.600
如果说你要到时候要返回前进呢

54:10.600 --> 54:12.600
就可以利用rotor里边一个go方法

54:12.600 --> 54:14.600
f1就表示退回到上一个页面

54:14.600 --> 54:15.600
f2就退回到前两个页面

54:15.600 --> 54:17.600
e就表示前进一个页面

54:17.600 --> 54:18.600
它类似于history go

54:19.600 --> 54:20.600
好来吧

54:20.600 --> 54:21.600
你再挑转别

54:21.600 --> 54:23.980
来吧这里怎么挑转

54:26.870 --> 54:30.870
zrotor push

54:31.870 --> 54:33.870
挑转了哪个命名路由

54:33.870 --> 54:35.870
命名路由哪一个

54:35.870 --> 54:37.870
我们找八个路由拿开

54:37.870 --> 54:42.080
命名路由是不是这个blog

54:42.080 --> 54:43.080
没有分类

54:43.080 --> 54:45.080
没有分类不是这个名字吗

54:45.080 --> 54:46.080
命名路由这个

54:47.080 --> 54:48.080
挑转到这

54:48.080 --> 54:50.080
那么还要带一些参数过去

54:50.080 --> 54:51.080
还要带query

54:51.080 --> 54:52.080
可以怎么带过去呢

54:52.080 --> 54:54.080
对象里边跟rotor link一样

54:54.080 --> 54:55.080
rotor link也可以这样写

54:55.080 --> 54:56.080
就这里的对象写法

54:56.080 --> 54:59.080
跟rotor link的写法是完全一样的

54:59.080 --> 55:00.080
那么这里怎么挑转呢

55:00.080 --> 55:02.080
再写个query配置

55:02.080 --> 55:04.080
那么它会自动生存这样的地址

55:04.080 --> 55:06.080
它会找命名路由是这个路由

55:06.080 --> 55:08.080
那么它的地址是这个

55:08.080 --> 55:09.080
带了query

55:09.080 --> 55:11.080
它就会把query拼接成一个问号

55:11.080 --> 55:12.080
放到后边

55:12.080 --> 55:14.080
当然你可以直接拼接写一个字幕算

55:14.080 --> 55:16.080
进行挑转也可以

55:16.080 --> 55:17.080
但是最好用这种方式

55:17.080 --> 55:18.080
用命名路由比较好一点

55:18.080 --> 55:19.080
之前的原因

55:19.080 --> 55:22.080
我之前讲的命名路由是讲过的

55:22.080 --> 55:23.080
query是不是有两个

55:23.080 --> 55:24.080
一个是page

55:24.080 --> 55:25.080
yema

55:25.080 --> 55:26.080
yema等于什么

55:26.080 --> 55:27.080
等于新的yema

55:28.080 --> 55:29.080
其实query是一样的

55:29.080 --> 55:30.080
query既然是一样的话

55:30.080 --> 55:31.080
那么我们这里的

55:31.080 --> 55:32.080
实际上是可以

55:32.080 --> 55:33.080
得到一个query

55:33.080 --> 55:34.080
query是什么的

55:35.080 --> 55:37.080
page为new page

55:37.080 --> 55:38.080
link面成了

55:38.080 --> 55:39.080
为原来的

55:40.080 --> 55:42.080
就是this road

55:43.080 --> 55:45.080
roadinfo里边的link面

55:46.080 --> 55:48.080
把query放到这

55:49.080 --> 55:50.080
query都是一样的

55:51.080 --> 55:52.080
所以就挑转了

55:52.080 --> 55:53.080
这样就挑转了

55:53.080 --> 55:54.080
好 else

55:54.080 --> 55:55.080
如果说有分类的话

55:55.080 --> 55:57.080
那么另外一种挑转方式

55:57.080 --> 55:58.080
rotor push

56:00.080 --> 56:01.080
名字呢

56:01.080 --> 56:02.080
不是再是个名字

56:02.080 --> 56:03.080
另外一个名字

56:03.080 --> 56:04.080
叫做category blog

56:06.080 --> 56:07.080
query一样

56:08.080 --> 56:09.080
还有一个

56:09.080 --> 56:10.080
是什么呢

56:10.080 --> 56:11.080
parrys

56:11.080 --> 56:12.080
因为它挑转的这个地方

56:12.080 --> 56:13.080
它有一个地址

56:13.080 --> 56:14.080
地址里面有一个动态的东西

56:14.080 --> 56:15.080
动态东西是啥

56:15.080 --> 56:16.080
一般告诉的

56:16.080 --> 56:17.080
它没法跳转

56:17.080 --> 56:18.080
它没法拼接这个路径

56:18.080 --> 56:19.080
也要把动态的东西告诉它

56:19.080 --> 56:20.080
就哪一个

56:21.080 --> 56:22.080
这一个动态部分

56:22.080 --> 56:23.080
是哪一个category id

56:24.080 --> 56:25.080
那你怎么告诉呢

56:25.080 --> 56:26.080
如果说你是直接拼接置物创的话

56:26.080 --> 56:27.080
也拼接成这个置物创

56:27.080 --> 56:28.080
就完事了

56:28.080 --> 56:29.080
把置物创放到这个位置

56:29.080 --> 56:31.080
但是如果说你是命名路由的话

56:31.080 --> 56:32.080
那怎么办呢

56:32.080 --> 56:33.080
就在这

56:33.080 --> 56:34.080
动态路由的导航

56:36.080 --> 56:37.080
你看怎么导航的

56:37.080 --> 56:38.080
是个parrys

56:38.080 --> 56:39.080
就这个对象的协防

56:39.080 --> 56:40.080
这个对象的协防

56:40.080 --> 56:41.080
跟这里是一样的

56:42.080 --> 56:43.080
parrys

56:43.080 --> 56:44.080
对吧

56:44.080 --> 56:45.080
跟配置parrys一样的

56:45.080 --> 56:46.080
parrys

56:46.080 --> 56:47.080
有动态路由的话

56:47.080 --> 56:48.080
动态部分给它

56:48.080 --> 56:49.080
动态部分的名字

56:49.080 --> 56:50.080
category id

56:52.080 --> 56:53.080
它也对应到这

56:53.080 --> 56:54.080
它也知道了

56:54.080 --> 56:55.080
你把动态部分

56:55.080 --> 56:56.080
这个地方替换掉

56:56.080 --> 56:57.080
替换成什么呢

56:57.080 --> 56:58.080
替换成

56:58.080 --> 57:00.080
this

57:00.080 --> 57:01.080
roadinfo

57:01.080 --> 57:02.080
就当前的分类 id

57:02.080 --> 57:03.080
就 id不变

57:05.080 --> 57:06.080
跳转到新叶吧

57:07.080 --> 57:08.080
就完了

57:08.080 --> 57:09.080
那么很多配置圈举

57:09.080 --> 57:10.080
就完事了

57:10.080 --> 57:12.080
咱们再试一下

57:12.080 --> 57:13.080
都写完了

57:13.080 --> 57:14.080
试一下

57:14.080 --> 57:15.080
看一下这个逻辑有没有走通

57:17.840 --> 57:18.840
这个逻辑

57:18.840 --> 57:19.840
当我们分页变化的时候

57:20.840 --> 57:21.840
改变这个路

57:21.840 --> 57:22.840
改变这个地址

57:24.840 --> 57:27.850
来吧

57:27.850 --> 57:28.850
看这个地址

57:28.850 --> 57:29.850
地址的变化

57:29.850 --> 57:30.850
点3

57:30.850 --> 57:31.850
跳上第三页了

57:31.850 --> 57:32.850
点5

57:32.850 --> 57:33.850
跳上第五页了

57:33.850 --> 57:34.850
你看这个地方

57:34.850 --> 57:35.850
选动的话也跟着变了

57:35.850 --> 57:36.850
为什么呢

57:36.850 --> 57:37.850
因为这个数据一变

57:37.850 --> 57:38.850
你看

57:38.850 --> 57:39.850
这个改变的路由

57:39.850 --> 57:40.850
路由一变

57:40.850 --> 57:42.850
计算属性的依赖是不是变了

57:42.850 --> 57:43.850
计算属性是依赖路由的

57:43.850 --> 57:44.850
那么路由一变

57:44.850 --> 57:45.850
计算属性

57:45.850 --> 57:46.850
又会重新计算

57:47.850 --> 57:48.850
重新计算

57:48.850 --> 57:49.850
计算完了过后

57:49.850 --> 57:50.850
是不是重新给分业组建

57:50.850 --> 57:53.850
那分业组建的当前也是跟着变了

57:53.850 --> 57:55.850
那么分业组建也会发生渲染

57:56.850 --> 57:57.850
我们再点击

57:57.850 --> 57:58.850
又处理分业

57:58.850 --> 57:59.850
又改变路由

57:59.850 --> 58:00.850
路由过后

58:00.850 --> 58:01.850
重新计算属性

58:01.850 --> 58:02.850
又改变分业

58:03.850 --> 58:04.850
对不对

58:04.850 --> 58:06.850
因为分业组建是依赖属性的

58:06.850 --> 58:08.850
依赖属性是依赖它的

58:08.850 --> 58:09.850
对不对

58:09.850 --> 58:11.850
就是这么一个一条链条就出来了

58:11.850 --> 58:12.850
变它

58:12.850 --> 58:13.850
重新计算

58:13.850 --> 58:15.850
分业组建刷新

58:15.850 --> 58:17.850
再点击又改变

58:17.850 --> 58:18.850
重新计算

58:18.850 --> 58:19.850
分业组建刷新

58:19.850 --> 58:20.850
对不对

58:20.850 --> 58:21.850
你看

58:21.850 --> 58:22.850
是吧

58:22.850 --> 58:23.850
分业组建都是没问题的

58:23.850 --> 58:24.850
对吧

58:24.850 --> 58:25.850
最后一页

58:25.850 --> 58:27.850
但是你会发现一个问题

58:27.850 --> 58:29.850
数据为什么没变

58:30.850 --> 58:32.850
数据变了吗

58:32.850 --> 58:33.850
动都没动

58:33.850 --> 58:34.850
你看

58:34.850 --> 58:35.850
点3

58:36.850 --> 58:37.850
有改变数据吗

58:37.850 --> 58:38.850
没有改变

58:39.850 --> 58:40.850
改变数据了

58:40.850 --> 58:41.850
没有改变

58:42.850 --> 58:44.850
数据没有变化

58:44.850 --> 58:46.850
那为什么数据没有变化呢

58:46.850 --> 58:48.850
因为我们什么数据

58:48.850 --> 58:49.850
就是我们这个界面

58:49.850 --> 58:50.850
这个界面数据哪来的

58:50.850 --> 58:52.850
我们好好分析一下

58:52.850 --> 58:54.850
这个界面数据哪来的

58:55.850 --> 58:57.850
是来自于data.rose

58:57.850 --> 58:58.850
对吧

58:58.850 --> 58:59.850
还一代这个数据

58:59.850 --> 59:00.850
那么这个数据一变

59:00.850 --> 59:01.850
它肯定会变化

59:01.850 --> 59:03.850
问题是这个数据变了吗

59:03.850 --> 59:05.850
这个数据来自于哪

59:05.850 --> 59:06.850
这个数据来自于哪

59:06.850 --> 59:08.850
来自于远程加载

59:08.850 --> 59:09.850
什么时候远程加载的

59:09.850 --> 59:11.850
是我们之前在混合里边

59:11.850 --> 59:12.850
在这

59:12.850 --> 59:14.850
混合里边

59:15.850 --> 59:16.850
所以一定要跟着我写

59:16.850 --> 59:17.850
之前的代码

59:17.850 --> 59:18.850
不跟着我写

59:18.850 --> 59:19.850
后面一定是蒙的

59:20.850 --> 59:22.850
我们这个项目虽然小

59:22.850 --> 59:23.850
但是呢

59:23.850 --> 59:24.850
其实涵盖了大部分

59:24.850 --> 59:26.850
你们将来会遇到的场景

59:26.850 --> 59:27.850
在混合里边

59:27.850 --> 59:29.850
我们在created里边调用的

59:29.850 --> 59:30.850
对吧

59:30.850 --> 59:31.850
调用了这个函数

59:31.850 --> 59:32.850
是不是在

59:32.850 --> 59:33.850
主键加载完成过后

59:33.850 --> 59:34.850
调用了这个函数

59:34.850 --> 59:35.850
只调用了一次吗

59:35.850 --> 59:37.850
主在加载完成过后

59:37.850 --> 59:38.850
主键创建完成过后

59:38.850 --> 59:39.850
调用这个函数

59:39.850 --> 59:40.850
这个函数的反回结果

59:40.850 --> 59:41.850
给data复辞

59:41.850 --> 59:42.850
对不对

59:42.850 --> 59:43.850
data有值了

59:43.850 --> 59:44.850
那么后续还会

59:44.850 --> 59:45.850
运行这个created吗

59:45.850 --> 59:46.850
它并不会运行的

59:46.850 --> 59:47.850
后续没有运行created

59:47.850 --> 59:49.850
它就自然没有运行这个函数

59:49.850 --> 59:50.850
没有运行这个函数

59:50.850 --> 59:52.850
它就没有给data重新复辞

59:52.850 --> 59:53.850
没有重新复辞

59:53.850 --> 59:55.850
自然这个界面

59:55.850 --> 59:56.850
是不会变化的

59:56.850 --> 59:58.850
好好梳理一下

59:58.850 --> 01:00:00.850
计算属性虽然在变

01:00:00.850 --> 01:00:01.850
但这个方法

01:00:01.850 --> 01:00:03.850
并没有得到重新调用

01:00:04.850 --> 01:00:06.850
这个地址的变化

01:00:06.850 --> 01:00:07.850
并没有引起方法

01:00:07.850 --> 01:00:08.850
重新调用

01:00:08.850 --> 01:00:09.850
方法怎么是调用的

01:00:09.850 --> 01:00:11.850
只在created里面调用

01:00:11.850 --> 01:00:13.850
剩下的时间没有调用

01:00:13.850 --> 01:00:14.850
就这个问题

01:00:14.850 --> 01:00:15.850
那么现在我们叫

01:00:15.850 --> 01:00:16.850
人为的作为建设

01:00:16.850 --> 01:00:17.850
这件事做完了

01:00:17.850 --> 01:00:19.850
这个主意就写完了

01:00:19.850 --> 01:00:21.850
做一件什么事呢

01:00:21.850 --> 01:00:23.850
地址一变化

01:00:23.850 --> 01:00:26.850
我要重新调用这个方法

01:00:26.850 --> 01:00:28.850
重新给data复辞

01:00:28.850 --> 01:00:30.850
data只要一复辞

01:00:30.850 --> 01:00:31.850
我们这个界面

01:00:31.850 --> 01:00:33.850
是依赖data的

01:00:33.850 --> 01:00:34.850
这个地方

01:00:34.850 --> 01:00:35.850
那么它自然而然

01:00:35.850 --> 01:00:37.850
会渲染新的数据

01:00:37.850 --> 01:00:38.850
对吧

01:00:39.850 --> 01:00:41.850
那么我怎么样

01:00:41.850 --> 01:00:44.850
让路由变化过后

01:00:44.850 --> 01:00:46.850
重新调用方法呢

01:00:47.850 --> 01:00:49.850
你想半天都想不出来

01:00:49.850 --> 01:00:51.850
因为这不是

01:00:51.850 --> 01:00:52.850
这是一个新的知识

01:00:52.850 --> 01:00:54.850
你搞不定的

01:00:54.850 --> 01:00:56.850
怎么办呢

01:00:56.850 --> 01:00:58.850
得用这种方式

01:00:58.850 --> 01:00:59.850
一个新的配置

01:00:59.850 --> 01:01:01.850
产生了叫watch

01:01:01.850 --> 01:01:03.850
下面那个watch

01:01:03.850 --> 01:01:04.850
watch什么意思

01:01:04.850 --> 01:01:05.850
观察

01:01:05.850 --> 01:01:06.850
有的时候

01:01:06.850 --> 01:01:07.850
我们要手动的

01:01:07.850 --> 01:01:10.850
数据现在多了一个配置

01:01:10.850 --> 01:01:12.850
叫做watch

01:01:12.850 --> 01:01:13.850
对不对

01:01:13.850 --> 01:01:15.850
对在这

01:01:15.850 --> 01:01:16.850
它用来观察数据变化了

01:01:16.850 --> 01:01:18.850
非常简单

01:01:18.850 --> 01:01:21.850
怎么配置在这里配置

01:01:21.850 --> 01:01:23.850
你看之前配置过这么一些东西了

01:01:23.850 --> 01:01:25.850
Megasins

01:01:25.850 --> 01:01:29.290
Megasins

01:01:29.290 --> 01:01:34.590
我配置写了

01:01:34.590 --> 01:01:36.590
好像忘了写了

01:01:36.590 --> 01:01:37.590
实际上这里

01:01:37.590 --> 01:01:38.590
还有一个配置

01:01:38.590 --> 01:01:39.590
Megasins

01:01:39.590 --> 01:01:40.590
忘了写了

01:01:40.590 --> 01:01:42.590
现在多了一个watch

01:01:42.590 --> 01:01:43.590
起到了

01:01:43.590 --> 01:01:44.590
watch

01:01:44.590 --> 01:01:47.590
这里边可以观察很多数据

01:01:47.590 --> 01:01:49.590
到底观察哪个数据

01:01:49.590 --> 01:01:51.590
作为属性名

01:01:51.590 --> 01:01:52.590
比方说我要观察它

01:01:52.590 --> 01:01:54.590
观察不就是路由信息吗

01:01:54.590 --> 01:01:56.590
地址变化不就是路由信息吗

01:01:56.590 --> 01:01:58.590
那么观察的是什么

01:01:58.590 --> 01:01:59.590
road

01:01:59.590 --> 01:02:00.590
你这样子一写

01:02:00.590 --> 01:02:01.590
它就是观察什么

01:02:01.590 --> 01:02:03.590
它就会观察this your road

01:02:03.590 --> 01:02:04.590
就这么简单

01:02:04.590 --> 01:02:06.590
你要写这样子写

01:02:06.590 --> 01:02:07.590
那么它就会观察

01:02:07.590 --> 01:02:09.590
this your data的变化

01:02:09.590 --> 01:02:11.590
就这个值有没有变

01:02:11.590 --> 01:02:13.590
这个值有没有变

01:02:13.590 --> 01:02:14.590
变了过后

01:02:14.590 --> 01:02:16.590
它会怎么样呢

01:02:16.590 --> 01:02:18.590
只要这个值一变

01:02:18.590 --> 01:02:20.590
它就会调用这个方法

01:02:20.590 --> 01:02:21.590
这是一个函数

01:02:21.590 --> 01:02:22.590
它就会调用这个函数

01:02:22.590 --> 01:02:24.590
这个函数里面有两个参数

01:02:24.590 --> 01:02:25.590
一个是六八

01:02:25.590 --> 01:02:26.590
一个是O的话

01:02:26.590 --> 01:02:28.590
这个是新的值

01:02:28.590 --> 01:02:29.590
这是以前的值

01:02:29.590 --> 01:02:30.590
它变化嘛

01:02:30.590 --> 01:02:31.590
当然你也可以

01:02:31.590 --> 01:02:32.590
这个新的值

01:02:32.590 --> 01:02:34.590
实际上就等于

01:02:34.590 --> 01:02:35.590
在这里面过去的路程

01:02:35.590 --> 01:02:36.590
就等于新的值

01:02:36.590 --> 01:02:37.590
所以说一个新的值

01:02:37.590 --> 01:02:38.590
如果说你不需要就了值的话

01:02:38.590 --> 01:02:41.590
那么这个其实是没有必要使用的

01:02:41.590 --> 01:02:43.590
就当路由变化的时候

01:02:43.590 --> 01:02:45.590
我要去做一些事

01:02:45.590 --> 01:02:47.590
那么这里我们说出

01:02:47.590 --> 01:02:49.590
路由变化了

01:02:49.590 --> 01:02:50.590
你看一下

01:02:50.590 --> 01:02:51.590
就这么简单

01:03:00.080 --> 01:03:02.080
一码没出来了

01:03:06.080 --> 01:03:09.030
你看什么路由变化了

01:03:09.030 --> 01:03:10.030
点击

01:03:10.030 --> 01:03:11.030
你看路由指数在变

01:03:11.030 --> 01:03:12.030
它一开始有没有运行

01:03:12.030 --> 01:03:13.030
它一开始不运行的

01:03:14.030 --> 01:03:15.030
一开始不运行的

01:03:16.030 --> 01:03:17.030
点击

01:03:17.030 --> 01:03:18.030
你看路由变化了

01:03:18.030 --> 01:03:19.030
它能监控到路由变化

01:03:20.030 --> 01:03:21.030
看呗

01:03:21.030 --> 01:03:22.030
看呗

01:03:24.030 --> 01:03:25.030
其实在路由

01:03:25.030 --> 01:03:26.030
我们的ViewRouter里面

01:03:26.030 --> 01:03:27.030
这是个对象

01:03:27.030 --> 01:03:28.030
对不对

01:03:28.030 --> 01:03:29.030
我们知道

01:03:29.030 --> 01:03:31.030
对象的每一次路由变化

01:03:31.030 --> 01:03:32.030
它都是一个新的对象

01:03:32.030 --> 01:03:33.030
所以说我们可以

01:03:33.030 --> 01:03:34.030
只监控它就行了

01:03:35.030 --> 01:03:36.030
如果说ViewRouter

01:03:36.030 --> 01:03:37.030
它每次做的时候

01:03:37.030 --> 01:03:38.030
它每次路由变化

01:03:38.030 --> 01:03:40.030
还是从用之前的对象

01:03:40.030 --> 01:03:41.030
只是改了它对象里面的属性

01:03:41.030 --> 01:03:42.030
那就监控不到

01:03:42.030 --> 01:03:43.030
但是ViewRouter

01:03:43.030 --> 01:03:44.030
肯定没有这样做

01:03:44.030 --> 01:03:45.030
它没有改动属性

01:03:45.030 --> 01:03:46.030
它就是

01:03:46.030 --> 01:03:47.030
以前是个对象

01:03:48.030 --> 01:03:49.030
然后路由变了过后

01:03:49.030 --> 01:03:50.030
它马上产生一个新的对象

01:03:50.030 --> 01:03:51.030
给它复制

01:03:51.030 --> 01:03:52.030
说直接监控它就行了

01:03:52.030 --> 01:03:53.030
你就知道路由变

01:03:54.030 --> 01:03:55.030
那么这里

01:03:55.030 --> 01:03:56.030
我们文档里面

01:03:56.030 --> 01:03:57.030
可以多看一看吧

01:03:57.030 --> 01:03:58.030
实际上我们刚才

01:03:58.030 --> 01:03:59.030
是用这种写法

01:03:59.030 --> 01:04:00.030
对吧

01:04:00.030 --> 01:04:01.030
这种写法是一种简写

01:04:01.030 --> 01:04:02.030
它完整的写法是这样子

01:04:03.030 --> 01:04:04.030
它配置为一个对象

01:04:04.030 --> 01:04:05.030
对象里面一个handle的

01:04:05.030 --> 01:04:06.030
handle的就是

01:04:06.030 --> 01:04:07.030
我们的处理函数

01:04:08.030 --> 01:04:09.030
实际上

01:04:09.030 --> 01:04:10.030
完整的写法是这样子的

01:04:19.890 --> 01:04:20.890
它实际上

01:04:20.890 --> 01:04:21.890
它是一个handle

01:04:21.890 --> 01:04:22.890
只不过

01:04:22.890 --> 01:04:23.890
如果说我们只有一个处理函数的话

01:04:23.890 --> 01:04:25.890
直接可以把它配置为对象

01:04:25.890 --> 01:04:26.890
这个效果是一样的

01:04:26.890 --> 01:04:27.890
你看一看吧

01:04:27.890 --> 01:04:31.420
路由变化了

01:04:31.420 --> 01:04:32.420
路由变化了

01:04:32.420 --> 01:04:33.420
你看

01:04:33.420 --> 01:04:34.420
路由变化了

01:04:34.420 --> 01:04:35.420
效果是一样的

01:04:35.420 --> 01:04:37.420
但是你用这种对象的写法

01:04:37.420 --> 01:04:38.420
就可以配置一些额外的配置

01:04:38.420 --> 01:04:39.420
什么额外的配置呢

01:04:39.420 --> 01:04:40.420
就两个

01:04:40.420 --> 01:04:41.420
一个stip

01:04:41.420 --> 01:04:42.420
stip什么意思

01:04:42.420 --> 01:04:43.420
默认为force

01:04:43.420 --> 01:04:44.420
刚才我们不是说了吗

01:04:44.420 --> 01:04:46.420
它只监控这个的变化

01:04:47.420 --> 01:04:48.420
如果说这个没变

01:04:48.420 --> 01:04:50.420
它里面的属性变了

01:04:50.420 --> 01:04:51.420
它是监控不到的

01:04:51.420 --> 01:04:53.420
那么你默认为force

01:04:53.420 --> 01:04:55.420
它不会监控里面的属性

01:04:55.420 --> 01:04:57.420
那么刚才有可能有同学问

01:04:57.420 --> 01:04:59.420
刚才我也说了

01:04:59.420 --> 01:05:01.420
那为什么它这个对象看上去

01:05:01.420 --> 01:05:03.420
就是里面属性变了

01:05:03.420 --> 01:05:04.420
里边的query变了

01:05:04.420 --> 01:05:05.420
patterns变了

01:05:05.420 --> 01:05:06.420
它为什么能监控到了

01:05:06.420 --> 01:05:08.420
是因为它给它配置为一个新的对象

01:05:08.420 --> 01:05:10.420
你可以监控它

01:05:10.420 --> 01:05:12.420
如果说将来

01:05:12.420 --> 01:05:13.420
遇到一些场景

01:05:13.420 --> 01:05:14.420
你要监控某些东西

01:05:14.420 --> 01:05:15.420
它对象没变

01:05:15.420 --> 01:05:16.420
它只是属性变了

01:05:16.420 --> 01:05:17.420
你把地谱稍微

01:05:17.420 --> 01:05:19.420
它就可以监控到内部属性的变化了

01:05:20.420 --> 01:05:21.420
不过这样非一些效率

01:05:21.420 --> 01:05:22.420
会浪费一些效率

01:05:23.420 --> 01:05:25.420
然后这个配置表示immediate

01:05:25.420 --> 01:05:27.420
表示适合立即执行一次

01:05:27.420 --> 01:05:28.420
它默认为force

01:05:28.420 --> 01:05:29.420
就是一开始它不会执行的

01:05:29.420 --> 01:05:31.420
这个handle一开始不会执行

01:05:31.420 --> 01:05:32.420
如果你周围去的话

01:05:32.420 --> 01:05:34.420
那么它一开始也会执行一次

01:05:34.420 --> 01:05:36.420
根据自己的需要来就行了

01:05:36.420 --> 01:05:37.420
这是这种解法

01:05:37.420 --> 01:05:39.420
那么下面我还提供了一些例子

01:05:39.420 --> 01:05:42.420
比方说我要监控它里边的某一个属性

01:05:42.420 --> 01:05:43.420
我不用监控那么多

01:05:43.420 --> 01:05:44.420
我不用监控它

01:05:44.420 --> 01:05:46.420
我只监控它里边的某一个属性

01:05:46.420 --> 01:05:47.420
那怎么办呢

01:05:47.420 --> 01:05:48.420
我们可以用这种

01:05:48.420 --> 01:05:49.420
属性表达式吗

01:05:49.420 --> 01:05:51.420
这不是什么无诱的知识

01:05:51.420 --> 01:05:52.420
这是解释基础的知识

01:05:52.420 --> 01:05:54.420
所谓基础很重要

01:05:55.420 --> 01:05:56.420
用个属性表达式

01:05:57.420 --> 01:05:58.420
它监控了什么

01:05:58.420 --> 01:06:00.420
监控就是这一式肉彻的Pirate

01:06:00.420 --> 01:06:01.420
只监控它的变化

01:06:01.420 --> 01:06:02.420
它不会监控别的变化

01:06:02.420 --> 01:06:04.420
比方说啊就个例子

01:06:04.420 --> 01:06:06.420
那么比方说我这里呢

01:06:06.420 --> 01:06:08.420
监控的是

01:06:08.420 --> 01:06:11.440
起过来吧

01:06:14.580 --> 01:06:15.580
我监控的不是它

01:06:19.660 --> 01:06:22.660
监控的是肉彻里边的Pirate

01:06:22.660 --> 01:06:24.660
Pirate是否发生变化

01:06:24.660 --> 01:06:25.660
其他我不监控

01:06:26.660 --> 01:06:30.160
这是属性表达式

01:06:30.160 --> 01:06:32.160
用这个作为属性名字

01:06:32.160 --> 01:06:33.160
监控它

01:06:33.160 --> 01:06:34.160
来吧

01:06:34.160 --> 01:06:35.160
让我们来看一下

01:06:36.160 --> 01:06:37.160
现在

01:06:41.050 --> 01:06:42.050
倒是也能监控到

01:06:42.050 --> 01:06:43.050
为什么能监控到

01:06:43.050 --> 01:06:44.050
为什么能监控到

01:06:44.050 --> 01:06:46.050
因为肉彻变了

01:06:46.050 --> 01:06:47.050
它都是一个新的对象了

01:06:47.050 --> 01:06:49.050
它里边的东西也是个新的对象

01:06:49.050 --> 01:06:50.050
也会把它变化

01:06:50.050 --> 01:06:51.050
那我就监控那个吧

01:06:51.050 --> 01:06:53.050
监控KiteScoreID

01:06:54.050 --> 01:06:57.580
点击

01:06:57.580 --> 01:06:58.580
你看是不是没有反应的

01:06:58.580 --> 01:06:59.580
因为它之前是3

01:06:59.580 --> 01:07:00.580
现在也是3

01:07:00.580 --> 01:07:01.580
它不是对象了

01:07:01.580 --> 01:07:03.580
因为对象是个新的地址

01:07:03.580 --> 01:07:04.580
那么就没有反应了

01:07:04.580 --> 01:07:06.580
那么我只监控什么了

01:07:06.580 --> 01:07:07.580
监控的query

01:07:08.580 --> 01:07:09.580
点配级

01:07:10.580 --> 01:07:11.580
你看啊

01:07:11.580 --> 01:07:17.000
是不是可以监控了

01:07:17.000 --> 01:07:18.000
那么这样子

01:07:18.000 --> 01:07:19.000
但是如果说这个变了

01:07:19.000 --> 01:07:20.000
它就不会变了

01:07:20.000 --> 01:07:21.000
这不会发生那个事件

01:07:21.000 --> 01:07:22.000
那么这里

01:07:22.000 --> 01:07:23.000
当然我们用不到这些东西

01:07:23.000 --> 01:07:24.000
就随便说一下

01:07:24.000 --> 01:07:26.000
就这种可以写得

01:07:26.000 --> 01:07:27.000
更加详细一点

01:07:27.000 --> 01:07:29.000
这个地方有些文字写法了

01:07:29.000 --> 01:07:31.000
也是一样把它配置为对象的玩笑

01:07:31.000 --> 01:07:32.000
好了

01:07:32.000 --> 01:07:33.000
这就是监控知识部分

01:07:33.000 --> 01:07:35.000
这我们这一刻的知识部分就完了

01:07:35.000 --> 01:07:36.000
那么回到这来

01:07:36.000 --> 01:07:37.000
我要监控谁

01:07:37.000 --> 01:07:41.080
监控肉彻的变化

01:07:41.080 --> 01:07:42.080
肉彻的变化

01:07:42.080 --> 01:07:43.080
它一变化我干嘛呀

01:07:43.080 --> 01:07:44.080
要做的事情很简单

01:07:44.080 --> 01:07:46.080
重新调用那个方法

01:07:46.080 --> 01:07:47.080
获取数据

01:07:47.080 --> 01:07:48.080
重新给的data复制

01:07:48.080 --> 01:07:49.080
就完了

01:07:49.080 --> 01:07:50.080
首先我们在

01:07:50.080 --> 01:07:52.080
因为我们要做家的东西的效果

01:07:52.080 --> 01:07:53.080
对吧

01:07:53.080 --> 01:07:55.080
我们首先把eSnowteam的设为去

01:07:55.080 --> 01:07:56.080
表示正在家的中

01:07:56.080 --> 01:07:58.080
这里把它配置成一个

01:07:58.080 --> 01:07:59.080
一步函数

01:07:59.080 --> 01:08:00.080
然后我们去调用

01:08:00.080 --> 01:08:02.080
ZsFHdata

01:08:02.080 --> 01:08:04.080
重新获取数据

01:08:04.080 --> 01:08:06.080
因为重新获取数据的时候

01:08:06.080 --> 01:08:07.080
不用传参数

01:08:07.080 --> 01:08:08.080
重新获取数据的时候

01:08:08.080 --> 01:08:10.080
它就会根据最新的计算储销

01:08:10.080 --> 01:08:12.080
来获取最新的数据

01:08:12.080 --> 01:08:13.080
好

01:08:13.080 --> 01:08:14.080
那么把个获取到的数据

01:08:14.080 --> 01:08:15.080
给谁呢

01:08:15.080 --> 01:08:16.080
给这个data

01:08:16.080 --> 01:08:17.080
然后再把eSnowteam

01:08:17.080 --> 01:08:19.080
作为force

01:08:19.080 --> 01:08:21.080
无非就做这么一件事

01:08:21.080 --> 01:08:22.080
好

01:08:22.080 --> 01:08:23.080
我们来看

01:08:23.080 --> 01:08:26.080
目前显示的是

01:08:26.080 --> 01:08:27.080
第12页

01:08:27.080 --> 01:08:28.080
里面成为10

01:08:28.080 --> 01:08:29.080
然后

01:08:29.080 --> 01:08:31.080
现在我们点击它

01:08:31.080 --> 01:08:33.080
你看

01:08:33.080 --> 01:08:34.080
见面什么变了

01:08:34.080 --> 01:08:35.080
点击它

01:08:35.080 --> 01:08:36.080
见面什么变了

01:08:36.080 --> 01:08:37.080
还肯定要独去数据

01:08:37.080 --> 01:08:38.080
要一段时间

01:08:38.080 --> 01:08:39.080
哎呦

01:08:39.080 --> 01:08:41.080
他说他漏定效果跑哪去了

01:08:41.080 --> 01:08:42.080
就是我一样说的

01:08:42.080 --> 01:08:43.080
漏定效果

01:08:43.080 --> 01:08:44.080
是这样子

01:08:44.080 --> 01:08:45.080
它是个样式的问题

01:08:45.080 --> 01:08:46.080
为了让大家看得清楚了

01:08:46.080 --> 01:08:48.080
我把漏定设为force

01:08:48.080 --> 01:08:49.080
给它取掉

01:08:49.080 --> 01:08:50.080
取掉过后

01:08:50.080 --> 01:08:51.080
它就永远显示出了

01:08:51.080 --> 01:08:52.080
对吧

01:08:52.080 --> 01:08:53.080
你把漏定效果先显示出来

01:08:53.080 --> 01:08:54.080
好

01:08:54.080 --> 01:08:55.080
来我们来改变一下分页

01:08:55.080 --> 01:08:56.080
实物

01:08:56.080 --> 01:08:57.080
变了

01:08:57.080 --> 01:08:58.080
漏定效果还在

01:08:58.080 --> 01:08:59.080
漏定效果呢

01:08:59.080 --> 01:09:00.080
漏定效果呢

01:09:00.080 --> 01:09:02.080
在哪去了

01:09:02.080 --> 01:09:04.080
跑这来了

01:09:04.080 --> 01:09:05.080
它是个样式问题

01:09:05.080 --> 01:09:06.080
怎么回事呢

01:09:06.080 --> 01:09:07.080
是因为我们这个列表

01:09:07.080 --> 01:09:08.080
你看这个列表

01:09:08.080 --> 01:09:10.080
高度实际上就这么高

01:09:10.080 --> 01:09:11.080
宽度100%

01:09:11.080 --> 01:09:12.080
高度100%

01:09:12.080 --> 01:09:13.080
刚好撑慢

01:09:13.080 --> 01:09:14.080
对吧

01:09:14.080 --> 01:09:15.080
就这么一个高度

01:09:15.080 --> 01:09:16.080
然后一出部分的事情

01:09:16.080 --> 01:09:17.080
使用滚动条

01:09:17.080 --> 01:09:18.080
overflow y

01:09:18.080 --> 01:09:19.080
out to

01:09:19.080 --> 01:09:20.080
对吧

01:09:20.080 --> 01:09:21.080
使用滚动条

01:09:21.080 --> 01:09:22.080
那么也就是说

01:09:22.080 --> 01:09:24.080
由于它高度只有这么一点

01:09:24.080 --> 01:09:25.080
剩下的高度呢

01:09:25.080 --> 01:09:27.080
是滚动高度了

01:09:27.080 --> 01:09:28.080
它实际的高度

01:09:28.080 --> 01:09:29.080
高度只有这么一点

01:09:29.080 --> 01:09:30.080
看一面上

01:09:30.080 --> 01:09:31.080
414

01:09:31.080 --> 01:09:32.080
你看这

01:09:32.080 --> 01:09:33.080
3704

01:09:33.080 --> 01:09:34.080
内容高度3704

01:09:34.080 --> 01:09:35.080
加上潘景的414

01:09:35.080 --> 01:09:37.080
由于它高度只有这么一点

01:09:37.080 --> 01:09:38.080
因此呢

01:09:38.080 --> 01:09:39.080
它里边的漏定

01:09:39.080 --> 01:09:40.080
就是个图片

01:09:40.080 --> 01:09:41.080
就是个图片

01:09:42.080 --> 01:09:43.080
Top 50%

01:09:43.080 --> 01:09:45.080
50%就只有这么一点

01:09:45.080 --> 01:09:46.080
只到这

01:09:46.080 --> 01:09:47.080
对吧

01:09:47.080 --> 01:09:48.080
只到这

01:09:48.080 --> 01:09:49.080
50%

01:09:49.080 --> 01:09:50.080
所以说呢

01:09:50.080 --> 01:09:51.080
它就在显示在上面去了

01:09:51.080 --> 01:09:52.080
滚动的时候

01:09:52.080 --> 01:09:53.080
它就跟着滚动

01:09:53.080 --> 01:09:54.080
造成这么一个效果

01:09:54.080 --> 01:09:55.080
那怎么办呢

01:09:56.080 --> 01:09:57.080
那怎么办呢

01:09:58.080 --> 01:09:59.080
办法呢

01:09:59.080 --> 01:10:00.080
其实很简单啊

01:10:00.080 --> 01:10:01.080
点击分页的时候

01:10:01.080 --> 01:10:03.080
你把滚动条扔上去

01:10:04.080 --> 01:10:05.080
是不是该扔上去吗

01:10:05.080 --> 01:10:06.080
也比较合理嘛

01:10:06.080 --> 01:10:07.080
对不对

01:10:07.080 --> 01:10:09.080
我们这里也不用去搞得太复杂

01:10:09.080 --> 01:10:10.080
是不是该扔上去吧

01:10:10.080 --> 01:10:12.080
点分页过后是不是要从头开始了

01:10:12.080 --> 01:10:13.080
因此呢

01:10:13.080 --> 01:10:14.080
我们这里点了分页过后

01:10:14.080 --> 01:10:15.080
还要做这么一件事

01:10:16.080 --> 01:10:17.080
点分页的时候

01:10:17.080 --> 01:10:19.080
滚动高度

01:10:19.080 --> 01:10:20.080
为0

01:10:20.080 --> 01:10:21.080
把色为0

01:10:21.080 --> 01:10:22.080
那谁说是哪个滚动高度为0

01:10:22.080 --> 01:10:24.080
无非就设置这个玩意儿呗

01:10:24.080 --> 01:10:25.080
那么我们给它个Rave

01:10:25.080 --> 01:10:27.080
这个肯定要设置滚动高度

01:10:27.080 --> 01:10:28.080
肯定要有

01:10:28.080 --> 01:10:29.080
原生动物操作了

01:10:29.080 --> 01:10:30.080
不要个Rave

01:10:30.080 --> 01:10:31.080
表示

01:10:31.080 --> 01:10:33.080
container吧

01:10:33.080 --> 01:10:34.080
同气

01:10:36.080 --> 01:10:37.080
this raves

01:10:37.080 --> 01:10:38.080
这个学过了

01:10:38.080 --> 01:10:39.080
不再说了

01:10:39.080 --> 01:10:40.080
container

01:10:40.080 --> 01:10:41.080
动物元素

01:10:41.080 --> 01:10:42.080
scrawl

01:10:42.080 --> 01:10:43.080
top

01:10:44.080 --> 01:10:45.080
被滚上去了

01:10:46.080 --> 01:10:47.080
路由变化过后

01:10:47.080 --> 01:10:48.080
肯定要重新获取数据

01:10:48.080 --> 01:10:49.080
那重新获取数据的话

01:10:49.080 --> 01:10:50.080
滚动高度有干

01:10:50.080 --> 01:10:51.080
滚动上去

01:10:51.080 --> 01:10:52.080
好

01:10:52.080 --> 01:10:53.080
现在我们来看看

01:10:53.080 --> 01:10:54.080
点击16

01:10:54.080 --> 01:10:55.080
滚上去了

01:10:56.080 --> 01:10:57.080
点18

01:10:57.080 --> 01:10:58.080
滚上去了

01:10:58.080 --> 01:10:59.080
对不对

01:10:59.080 --> 01:11:01.080
那如果说想滚动的平滑一点

01:11:01.080 --> 01:11:02.080
怎么办

01:11:02.080 --> 01:11:04.080
实际上是个样式问题

01:11:04.080 --> 01:11:05.080
用一个

01:11:05.080 --> 01:11:06.080
把这个东西

01:11:06.080 --> 01:11:08.080
设置一个叫做scrawl

01:11:08.080 --> 01:11:09.080
be heavier

01:11:09.080 --> 01:11:10.080
设为smooth

01:11:10.080 --> 01:11:12.080
平滑滚动

01:11:12.080 --> 01:11:14.080
现在我们来看

01:11:14.080 --> 01:11:15.080
现在我们点19

01:11:15.080 --> 01:11:16.080
滚动上去了

01:11:17.080 --> 01:11:18.080
对吧

01:11:18.080 --> 01:11:19.080
23

01:11:19.080 --> 01:11:20.080
滚动上去了

01:11:21.080 --> 01:11:22.080
好

01:11:22.080 --> 01:11:23.080
那么这个

01:11:23.080 --> 01:11:25.080
左边这个主键是不是就做完了

01:11:25.080 --> 01:11:26.080
还有啥

01:11:26.080 --> 01:11:27.080
就没啥了

01:11:27.080 --> 01:11:28.080
就做完了

01:11:28.080 --> 01:11:29.080
应该没

01:11:29.080 --> 01:11:30.080
好

01:11:30.080 --> 01:11:31.080
那么这边这个主键

01:11:31.080 --> 01:11:32.080
block list做完了

01:11:32.080 --> 01:11:33.080
剩下就是block category

01:11:34.080 --> 01:11:35.080
右边这个主键

01:11:35.080 --> 01:11:36.080
好

01:11:36.080 --> 01:11:37.080
我们再来看一下整体

01:11:37.080 --> 01:11:38.080
右边这个主键

01:11:38.080 --> 01:11:39.080
要做的事情

01:11:39.080 --> 01:11:40.080
就是要读分类

01:11:40.080 --> 01:11:41.080
因为为什么要读分类

01:11:41.080 --> 01:11:42.080
因为右边这个主键

01:11:42.080 --> 01:11:43.080
设计到一个问题

01:11:43.080 --> 01:11:45.080
就是哪个是激活状态

01:11:45.080 --> 01:11:46.080
设计到这么一个问题

01:11:46.080 --> 01:11:47.080
就是要读

01:11:47.080 --> 01:11:48.080
到底是哪个分类

01:11:48.080 --> 01:11:49.080
没有分类

01:11:49.080 --> 01:11:50.080
我觉得这个是激活状态

01:11:50.080 --> 01:11:51.080
有分类的话

01:11:51.080 --> 01:11:52.080
就是这些东西是激活状态

01:11:52.080 --> 01:11:53.080
对不对

01:11:53.080 --> 01:11:54.080
所以说我们右边

01:11:54.080 --> 01:11:56.080
它要从路由信息里边读分类

01:11:56.080 --> 01:11:58.080
然后还要根据路由信息

01:11:58.080 --> 01:11:59.080
它根据路由信息

01:11:59.080 --> 01:12:00.080
显示激活状态

01:12:00.080 --> 01:12:01.080
然后这个键头

01:12:01.080 --> 01:12:02.080
什么意思呢

01:12:02.080 --> 01:12:04.080
就点击到某一个分类过后

01:12:04.080 --> 01:12:06.080
我要改变路由

01:12:06.080 --> 01:12:07.080
改变路由

01:12:07.080 --> 01:12:08.080
这边对路由有监控

01:12:08.080 --> 01:12:09.080
所以我们之前

01:12:09.080 --> 01:12:10.080
间接通信

01:12:10.080 --> 01:12:11.080
实现了

01:12:11.080 --> 01:12:12.080
这边对路由有监控

01:12:12.080 --> 01:12:13.080
路由一变

01:12:13.080 --> 01:12:14.080
那么这边也会跟着变

01:12:14.080 --> 01:12:15.080
路由一变

01:12:15.080 --> 01:12:16.080
这边也会监控

01:12:16.080 --> 01:12:17.080
这边路由一变

01:12:17.080 --> 01:12:19.080
那么这些分类的激活状态也变了

01:12:19.080 --> 01:12:21.080
就这么一个逻辑

01:12:21.080 --> 01:12:22.080
好

01:12:22.080 --> 01:12:23.080
因此我们在complete里面

01:12:23.080 --> 01:12:25.080
搞定这个组件

01:12:25.080 --> 01:12:26.080
好

01:12:26.080 --> 01:12:27.080
这个组件里面

01:12:27.080 --> 01:12:28.080
我们写上一个DIV

01:12:28.080 --> 01:12:29.080
这个央视没有

01:12:29.080 --> 01:12:31.080
这个央视你其实也弄起来比较简单

01:12:31.080 --> 01:12:33.080
给大家写一个内央视

01:12:33.080 --> 01:12:38.080
叫做BlogCascaryContainer

01:12:38.080 --> 01:12:39.080
OK

01:12:39.080 --> 01:12:40.080
这么一个Cascary

01:12:40.080 --> 01:12:44.460
然后Scoutness

01:12:44.460 --> 01:12:46.460
定个宽度咋样

01:12:47.460 --> 01:12:49.460
我们把这个玩意定个宽度吧

01:12:49.460 --> 01:12:53.500
宽度

01:12:53.500 --> 01:12:55.500
要是多好合适呢

01:12:55.500 --> 01:12:56.500
我看一下这边啊

01:12:56.500 --> 01:12:57.500
这些都是央视问题了

01:12:57.500 --> 01:12:58.500
你们自己去弄吧

01:12:58.500 --> 01:12:59.500
我这里呢

01:12:59.500 --> 01:13:00.500
快速的自己弄一下

01:13:01.500 --> 01:13:02.500
这边是

01:13:03.500 --> 01:13:04.500
宽度

01:13:04.500 --> 01:13:06.880
这边的宽度是多少

01:13:06.880 --> 01:13:07.880
300

01:13:07.880 --> 01:13:08.880
OK那有什么

01:13:08.880 --> 01:13:09.880
那我就300

01:13:10.880 --> 01:13:11.880
宽度也300

01:13:12.880 --> 01:13:13.880
BlogCascaryContainer

01:13:13.880 --> 01:13:14.880
BlogCascaryContainer

01:13:15.880 --> 01:13:16.880
然后它里边的

01:13:16.880 --> 01:13:17.880
因为它有个panning

01:13:18.880 --> 01:13:19.880
它有个panning

01:13:19.880 --> 01:13:20.880
panning的话

01:13:20.880 --> 01:13:21.880
20个相处

01:13:21.880 --> 01:13:22.880
OK它就20个相处

01:13:24.880 --> 01:13:25.880
panning

01:13:25.880 --> 01:13:26.880
20个相处

01:13:27.880 --> 01:13:28.880
好

01:13:28.880 --> 01:13:29.880
然后呢

01:13:29.880 --> 01:13:30.880
就是

01:13:30.880 --> 01:13:31.880
差不多了

01:13:31.880 --> 01:13:32.880
差不多了

01:13:32.880 --> 01:13:33.880
然后这里边写上一个

01:13:34.880 --> 01:13:35.880
HL元素

01:13:35.880 --> 01:13:36.880
文章分类

01:13:37.880 --> 01:13:38.880
然后下边呢

01:13:38.880 --> 01:13:39.880
就是一个我们之前的组件

01:13:39.880 --> 01:13:40.880
Import

01:13:40.880 --> 01:13:41.880
倒入进来

01:13:41.880 --> 01:13:42.880
叫做RightNest

01:13:45.640 --> 01:13:46.640
RightNest

01:13:46.640 --> 01:13:49.460
好

01:13:50.460 --> 01:13:52.460
RightNest

01:13:52.460 --> 01:13:53.460
然后呢

01:13:53.460 --> 01:13:54.460
我们注册一下

01:13:54.460 --> 01:13:55.460
ComponentRightNest

01:13:57.460 --> 01:13:58.460
有什么样式问题的话

01:13:58.460 --> 01:13:59.460
我们一会儿再调吧

01:14:02.410 --> 01:14:03.410
主要是逻辑

01:14:04.410 --> 01:14:05.410
看一下这边

01:14:05.410 --> 01:14:06.410
文章分类出来

01:14:06.410 --> 01:14:07.410
我们调一下样式

01:14:07.410 --> 01:14:08.410
HL的样式调一下

01:14:11.410 --> 01:14:12.410
LetterSpacing

01:14:12.410 --> 01:14:13.410
FoundWeightBold

01:14:13.410 --> 01:14:14.410
LetterSpacing

01:14:14.410 --> 01:14:15.410
好

01:14:15.410 --> 01:14:16.410
再加一个

01:14:17.410 --> 01:14:18.410
它下边的HL元素

01:14:19.410 --> 01:14:21.410
FoundWeightBold

01:14:22.410 --> 01:14:23.410
LetterSpacing

01:14:23.410 --> 01:14:24.410
FoundWeightBold

01:14:24.410 --> 01:14:28.840
LetterSpacing

01:14:29.840 --> 01:14:30.840
好

01:14:30.840 --> 01:14:31.840
差不多

01:14:31.840 --> 01:14:32.840
然后呢

01:14:32.840 --> 01:14:33.840
字体大小再调一下

01:14:34.840 --> 01:14:35.840
字体大小

01:14:36.840 --> 01:14:37.840
好像字体大小就是

01:14:37.840 --> 01:14:38.840
EEM

01:14:39.840 --> 01:14:44.490
FoundSizeEEM

01:14:46.930 --> 01:14:47.930
好

01:14:47.930 --> 01:14:51.270
Margin再去掉

01:14:51.270 --> 01:14:52.270
Margin0

01:14:53.270 --> 01:14:54.270
好

01:14:54.270 --> 01:14:55.270
差不多了

01:14:55.270 --> 01:14:56.270
好

01:14:56.270 --> 01:14:57.270
文章分类

01:14:57.270 --> 01:14:58.270
好

01:14:58.270 --> 01:14:59.270
下边的东西呢

01:14:59.270 --> 01:15:00.270
就是一个RightNest

01:15:00.270 --> 01:15:01.270
那么现在我们刚才

01:15:02.270 --> 01:15:03.270
那么这数据哪来了

01:15:03.270 --> 01:15:04.270
我们看这个逻辑

01:15:07.270 --> 01:15:08.270
路由信息里边

01:15:08.270 --> 01:15:09.270
我们是不是可以用一个计算数

01:15:09.270 --> 01:15:10.270
去拿到这个分类ID

01:15:10.270 --> 01:15:11.270
对吧

01:15:11.270 --> 01:15:12.270
分类ID是不是可以

01:15:12.270 --> 01:15:13.270
通过计算数去拿到

01:15:13.270 --> 01:15:14.270
好来吧

01:15:15.270 --> 01:15:16.270
从分类ID里边

01:15:16.270 --> 01:15:17.270
拿计算数

01:15:19.270 --> 01:15:20.270
对

01:15:23.270 --> 01:15:26.220
拿法了

01:15:26.220 --> 01:15:27.220
跟那边的拿法是一样的

01:15:28.220 --> 01:15:29.220
这边咋了

01:15:29.220 --> 01:15:30.220
那边就咋了

01:15:31.220 --> 01:15:32.220
直接来吧

01:15:32.220 --> 01:15:33.220
直接把这个东西返回

01:15:33.220 --> 01:15:34.220
就完事了

01:15:34.220 --> 01:15:37.720
因为它有一个简单的

01:15:37.720 --> 01:15:38.720
就是逻辑判断

01:15:38.720 --> 01:15:40.720
所以说把它封装成一个计算数

01:15:40.720 --> 01:15:41.720
如果说没有逻辑判断的话

01:15:41.720 --> 01:15:42.720
你直接写也可以

01:15:43.720 --> 01:15:47.000
好有了这个计算数

01:15:47.000 --> 01:15:48.000
先过后来

01:15:48.000 --> 01:15:49.000
我们来看一下

01:15:49.000 --> 01:15:50.000
这个计算数有啥用

01:15:55.320 --> 01:15:56.320
然后我们还有一个数据

01:15:56.320 --> 01:15:57.320
就是所有分类的数组

01:15:57.320 --> 01:15:58.320
因为这个数据

01:15:58.320 --> 01:15:59.320
就是data里边的数据

01:16:00.320 --> 01:16:01.320
所有分类的数组

01:16:01.320 --> 01:16:02.320
这个数据

01:16:02.320 --> 01:16:03.320
为什么要有这个数据呢

01:16:03.320 --> 01:16:04.320
因为我们

01:16:04.320 --> 01:16:05.320
这里要显示所有的分类

01:16:05.320 --> 01:16:06.320
不得从远程过去分类

01:16:06.320 --> 01:16:07.320
我们不是有这个API吗

01:16:07.320 --> 01:16:08.320
对不对

01:16:08.320 --> 01:16:09.320
所以说这一块

01:16:09.320 --> 01:16:10.320
本身它也有noting效果

01:16:10.320 --> 01:16:12.320
所以这一块也有混合

01:16:14.320 --> 01:16:15.320
fetch data

01:16:18.320 --> 01:16:19.320
其实像我们这个项目里边

01:16:19.320 --> 01:16:20.320
搞一个混合

01:16:20.320 --> 01:16:22.320
其实意义倒是不大

01:16:22.320 --> 01:16:23.320
只是我希望通过这个项目

01:16:23.320 --> 01:16:25.320
告诉大家有混合这个东西

01:16:25.320 --> 01:16:26.320
因为并且重复代码不多

01:16:26.320 --> 01:16:29.320
像把它提去出一个混入的话

01:16:29.320 --> 01:16:31.320
反而容易导致过渡设计

01:16:32.320 --> 01:16:34.320
叫做过渡设计

01:16:35.320 --> 01:16:40.190
过渡设计其实也不好

01:16:41.190 --> 01:16:42.190
就合适就行了

01:16:42.190 --> 01:16:44.190
像我们的项目比较简单

01:16:44.190 --> 01:16:45.190
它并不需要这个东西

01:16:45.190 --> 01:16:47.190
只是我通过这个项目

01:16:47.190 --> 01:16:48.190
告诉大家有这么一个东西

01:16:48.190 --> 01:16:49.190
Megasyn

01:16:50.190 --> 01:16:51.190
混合

01:16:52.190 --> 01:16:53.190
fetch data

01:16:54.190 --> 01:16:55.190
注意 传个默认值

01:16:55.190 --> 01:16:57.190
因为混合的话

01:16:57.190 --> 01:16:58.190
我们默认值之前

01:16:58.190 --> 01:16:59.190
模拟的数据

01:17:01.190 --> 01:17:02.190
就是一个数组

01:17:02.190 --> 01:17:03.190
分类就是一个数组

01:17:03.190 --> 01:17:04.190
OK 那我就给它

01:17:04.190 --> 01:17:05.190
默认值就是个数组

01:17:07.190 --> 01:17:08.190
自然而然

01:17:08.190 --> 01:17:09.190
我们的Message里边

01:17:09.190 --> 01:17:10.190
是不是要提供一个东西

01:17:11.190 --> 01:17:12.190
什么东西呢 就是

01:17:15.820 --> 01:17:16.820
fetch

01:17:17.820 --> 01:17:18.820
fetch data

01:17:19.820 --> 01:17:20.820
我要提供这么一个东西

01:17:20.820 --> 01:17:21.820
这东西怎么做呢

01:17:21.820 --> 01:17:23.820
就是来自一个API

01:17:23.820 --> 01:17:28.440
API

01:17:29.440 --> 01:17:30.440
blog

01:17:30.440 --> 01:17:32.440
这里我们要得到getblog

01:17:32.440 --> 01:17:34.440
categories

01:17:34.440 --> 01:17:35.440
是这样写吧

01:17:36.440 --> 01:17:37.440
API看一下

01:17:38.440 --> 01:17:39.440
ok types

01:17:39.440 --> 01:17:40.440
我这里用的types

01:17:40.440 --> 01:17:42.440
名字干的统一吧

01:17:43.440 --> 01:17:44.440
categories

01:17:47.390 --> 01:17:47.890
得到这个

01:17:47.890 --> 01:17:49.890
那么这边要做的事情很简单

01:17:49.890 --> 01:17:50.890
return await

01:17:50.890 --> 01:17:51.890
getblogcategories

01:17:51.890 --> 01:17:52.890
它又不需要什么参数

01:17:52.890 --> 01:17:54.890
拿到所有的分类就完事了

01:17:54.890 --> 01:17:55.890
对不对

01:17:56.890 --> 01:17:57.890
好 那么这样子一来

01:17:57.890 --> 01:17:58.890
我们这个组建里边

01:17:58.890 --> 01:17:59.890
是不是有了两个数据

01:17:59.890 --> 01:18:00.890
一个是is loading

01:18:00.890 --> 01:18:01.890
对吧

01:18:01.890 --> 01:18:03.890
一个是data

01:18:03.890 --> 01:18:05.890
data就是我们远程过去的数据

01:18:06.890 --> 01:18:07.890
好 那么现在我们有这个东西

01:18:07.890 --> 01:18:09.890
有数据有分类ID

01:18:10.890 --> 01:18:11.890
分类ID取用来做什么

01:18:11.890 --> 01:18:13.890
用来决定哪个要显示

01:18:13.890 --> 01:18:15.890
哪个不显示

01:18:16.890 --> 01:18:17.890
哪个是激活状态

01:18:17.890 --> 01:18:18.890
哪个哪些不是

01:18:19.890 --> 01:18:21.890
这个所有的分类的数据

01:18:22.890 --> 01:18:23.890
现在表示我们这里的列表

01:18:23.890 --> 01:18:24.890
列表的信息

01:18:25.890 --> 01:18:26.890
对不对

01:18:26.890 --> 01:18:27.890
那如果说这样子一写完的话

01:18:27.890 --> 01:18:28.890
很多朋友就可以想了

01:18:28.890 --> 01:18:30.890
那我特别想把这个列

01:18:30.890 --> 01:18:32.890
直接绑定到data里边

01:18:32.890 --> 01:18:33.890
这样子可不可以呢

01:18:34.890 --> 01:18:35.890
再加上一个vlog

01:18:36.890 --> 01:18:37.890
loading等于什么

01:18:37.890 --> 01:18:38.890
is loading

01:18:38.890 --> 01:18:39.890
因为它vloging

01:18:39.890 --> 01:18:40.890
需要容器

01:18:41.890 --> 01:18:42.890
play-sync native

01:18:42.890 --> 01:18:43.890
再加上

01:18:43.890 --> 01:18:44.890
那这样子挺好的

01:18:44.890 --> 01:18:45.890
刷新看一下

01:18:45.890 --> 01:18:46.890
这边

01:18:46.890 --> 01:18:47.890
刷新看一下

01:18:48.890 --> 01:18:50.890
那么这个高度

01:18:50.890 --> 01:18:51.890
我给它设个高度

01:18:51.890 --> 01:18:52.890
高度百分之二

01:18:56.100 --> 01:18:57.100
你看 这样不挺好吗

01:19:00.050 --> 01:19:01.050
再来

01:19:01.050 --> 01:19:02.050
你看 这样子不挺好吗

01:19:02.050 --> 01:19:03.050
这个滚动条

01:19:03.050 --> 01:19:04.050
给它设置为一个

01:19:04.050 --> 01:19:05.050
一直显示的滚动条

01:19:06.050 --> 01:19:07.050
把之前那个

01:19:07.050 --> 01:19:08.050
设置一下样式

01:19:09.050 --> 01:19:11.050
overflow y scroll

01:19:14.130 --> 01:19:15.130
你看 这样不挺好吗

01:19:16.130 --> 01:19:17.130
分类也显示出来了

01:19:17.130 --> 01:19:19.130
分类的字体是不是有点大

01:19:20.130 --> 01:19:21.130
好 字体有点大

01:19:21.130 --> 01:19:22.130
那么我们把这个字体

01:19:22.130 --> 01:19:23.130
调一下

01:19:23.130 --> 01:19:24.130
之前的right list

01:19:24.130 --> 01:19:25.130
字体调一下

01:19:26.130 --> 01:19:27.130
li的话

01:19:27.130 --> 01:19:28.130
我们给它设置个字体大小

01:19:28.130 --> 01:19:29.130
方式尺寸

01:19:31.130 --> 01:19:32.130
差不多了

01:19:34.130 --> 01:19:35.130
不挺好吗

01:19:36.130 --> 01:19:37.130
但是你会有发现

01:19:37.130 --> 01:19:38.130
少了一个数据

01:19:38.130 --> 01:19:39.130
一个是全部

01:19:39.130 --> 01:19:40.130
另外一个就是哪个

01:19:40.130 --> 01:19:41.130
哪个是激活状态

01:19:41.130 --> 01:19:43.130
是不是这个数据里面没有

01:19:43.130 --> 01:19:44.130
之前还记得吗

01:19:44.130 --> 01:19:45.130
这里面需要的数据

01:19:45.130 --> 01:19:46.130
它是要有一个属性

01:19:46.130 --> 01:19:47.130
叫easy snag

01:19:47.130 --> 01:19:49.130
它能够显示激活状态

01:19:49.130 --> 01:19:50.130
easy snag反正分类里面

01:19:50.130 --> 01:19:51.130
也没有指分类

01:19:51.130 --> 01:19:52.130
所以这个东西

01:19:52.130 --> 01:19:53.130
倒是可以有可以没有

01:19:54.130 --> 01:19:55.130
没有算了

01:19:55.130 --> 01:19:56.130
这个属性得有

01:19:56.130 --> 01:19:57.130
我知道哪个是选中

01:19:58.130 --> 01:19:59.130
但是服务器那边

01:19:59.130 --> 01:20:00.130
给我的数据有没有

01:20:00.130 --> 01:20:01.130
没有

01:20:01.130 --> 01:20:02.130
所以说我们

01:20:02.130 --> 01:20:03.130
服务器给我的数据

01:20:03.130 --> 01:20:04.130
直接拿来用可以

01:20:04.130 --> 01:20:05.130
但是你就少了

01:20:05.130 --> 01:20:06.130
这两个东西

01:20:06.130 --> 01:20:07.130
一个是全部

01:20:07.130 --> 01:20:10.130
一个是激活状态

01:20:10.130 --> 01:20:12.130
这些东西是没有的

01:20:12.130 --> 01:20:13.130
那怎么办

01:20:13.130 --> 01:20:14.130
你看我这里怎么处理的

01:20:14.130 --> 01:20:16.130
激活状态要取决于它

01:20:17.130 --> 01:20:19.130
取决于地址哪里面的东西

01:20:19.130 --> 01:20:21.130
原式数据

01:20:21.130 --> 01:20:22.130
服务器的原式数据

01:20:22.130 --> 01:20:23.130
是在这

01:20:23.130 --> 01:20:24.130
我们把这两个东西

01:20:24.130 --> 01:20:26.130
又写个计算属性

01:20:26.130 --> 01:20:27.130
这个计算属性

01:20:27.130 --> 01:20:28.130
根据它

01:20:28.130 --> 01:20:29.130
来得到一个担有的

01:20:29.130 --> 01:20:31.130
easy snag属性的分类数据

01:20:31.130 --> 01:20:32.130
就把分类数据里面

01:20:32.130 --> 01:20:33.130
每一个

01:20:33.130 --> 01:20:35.130
弄一个easy snag属性

01:20:35.130 --> 01:20:36.130
出来

01:20:36.130 --> 01:20:37.130
计算属性吗

01:20:37.130 --> 01:20:38.130
easy snag

01:20:38.130 --> 01:20:39.130
它是不是easy snag

01:20:39.130 --> 01:20:40.130
这两个

01:20:40.130 --> 01:20:42.130
而它是不是easy snag

01:20:43.130 --> 01:20:44.130
逻辑关系就出来了

01:20:44.130 --> 01:20:45.130
到时候它一遍

01:20:45.130 --> 01:20:46.130
计算属性

01:20:46.130 --> 01:20:47.130
因为它是计算属性

01:20:47.130 --> 01:20:48.130
计算属性

01:20:48.130 --> 01:20:49.130
一带一遍

01:20:49.130 --> 01:20:50.130
它就会跟着变

01:20:50.130 --> 01:20:51.130
它一不变

01:20:51.130 --> 01:20:52.130
跟着变

01:20:52.130 --> 01:20:53.130
它又一带它

01:20:53.130 --> 01:20:54.130
它就会跟着变

01:20:54.130 --> 01:20:55.130
对不对

01:20:55.130 --> 01:20:56.130
我们把这个计算属性

01:20:56.130 --> 01:20:57.130
绑定到这个rightness

01:20:57.130 --> 01:20:58.130
属性里面去

01:20:58.130 --> 01:20:59.130
你看

01:20:59.130 --> 01:21:00.130
是这么一个逻辑

01:21:00.130 --> 01:21:01.130
那么它变了

01:21:01.130 --> 01:21:03.130
那么rightness自然就变了

01:21:03.130 --> 01:21:05.130
它都不用去监控路由

01:21:05.130 --> 01:21:06.130
因为它不用就要

01:21:06.130 --> 01:21:07.130
调用别的方法

01:21:07.130 --> 01:21:09.130
我又不需要重新获取数据

01:21:09.130 --> 01:21:10.130
我只要这个变了

01:21:10.130 --> 01:21:11.130
那么这个就变了

01:21:11.130 --> 01:21:13.130
数据远方不动就可以了

01:21:13.130 --> 01:21:14.130
所以说按照这个逻辑

01:21:15.130 --> 01:21:16.130
再写个计算属性

01:21:16.130 --> 01:21:17.130
叫做

01:21:17.130 --> 01:21:18.130
就叫做list

01:21:19.130 --> 01:21:20.130
那么这边就绑定list

01:21:24.020 --> 01:21:26.020
这个历史要做什么事情呢

01:21:26.020 --> 01:21:27.020
这个历史

01:21:27.020 --> 01:21:28.020
这个历史首先

01:21:28.020 --> 01:21:29.020
我们

01:21:29.020 --> 01:21:31.020
要拿到

01:21:32.020 --> 01:21:33.020
原式的数据

01:21:34.020 --> 01:21:35.020
ZS

01:21:35.020 --> 01:21:36.020
什么原式的数据

01:21:36.020 --> 01:21:37.020
原式的数据

01:21:37.020 --> 01:21:38.020
我们把它一个map

01:21:42.520 --> 01:21:43.520
或者是

01:21:43.520 --> 01:21:44.520
给它加上一个

01:21:44.520 --> 01:21:48.540
原式数据

01:21:48.540 --> 01:21:49.540
list

01:21:50.540 --> 01:21:51.540
result

01:21:51.540 --> 01:21:52.540
它是个数据

01:21:52.540 --> 01:21:53.540
它有一个全部

01:21:53.540 --> 01:21:54.540
全部的话

01:21:54.540 --> 01:21:55.540
我们刚刚封装一个对象

01:21:55.540 --> 01:21:56.540
lamb等于全部

01:21:56.540 --> 01:21:57.540
全部分类

01:21:59.540 --> 01:22:00.540
没问题吧

01:22:00.540 --> 01:22:01.540
id等于-1

01:22:03.540 --> 01:22:04.540
没问题吧

01:22:04.540 --> 01:22:05.540
其他不要了

01:22:06.540 --> 01:22:07.540
其他数据我都不要了

01:22:07.540 --> 01:22:08.540
全部分类

01:22:08.540 --> 01:22:09.540
id为-1

01:22:09.540 --> 01:22:11.540
我还有个文章总数

01:22:12.540 --> 01:22:14.540
总数就是

01:22:16.540 --> 01:22:17.540
之前封装的那个

01:22:19.540 --> 01:22:20.540
模拟数据

01:22:22.540 --> 01:22:24.540
一个article

01:22:25.540 --> 01:22:26.540
文章总数

01:22:26.540 --> 01:22:27.540
文章总数

01:22:27.540 --> 01:22:28.540
是不是来自于

01:22:29.540 --> 01:22:30.540
ZS-data

01:22:31.540 --> 01:22:32.540
Reduce

01:22:32.540 --> 01:22:33.540
会总吗

01:22:34.540 --> 01:22:35.540
A

01:22:35.540 --> 01:22:36.540
B

01:22:36.540 --> 01:22:37.540
会总

01:22:38.540 --> 01:22:39.540
基础代码千万不能

01:22:39.540 --> 01:22:41.540
基础代码千万不能扔

01:22:42.540 --> 01:22:43.540
这些忘记了

01:22:47.060 --> 01:22:48.060
没灵吗

01:22:48.060 --> 01:22:49.060
或者没灵吗

01:22:49.060 --> 01:22:50.060
会各种吗

01:22:50.060 --> 01:22:51.060
A

01:22:52.060 --> 01:22:53.060
article

01:22:55.060 --> 01:22:56.060
加上B

01:22:58.060 --> 01:22:59.060
要循环汇总也可以

01:22:59.060 --> 01:23:00.060
怎么汇总就可以

01:23:00.060 --> 01:23:01.060
总之吧

01:23:01.060 --> 01:23:02.060
这个数据里面

01:23:02.060 --> 01:23:03.060
这个数据里面

01:23:03.060 --> 01:23:04.060
不是所有的文章分类吗

01:23:04.060 --> 01:23:05.060
每个文章分类里面

01:23:05.060 --> 01:23:06.060
不是有一个

01:23:06.060 --> 01:23:07.060
文章数量吗

01:23:07.060 --> 01:23:09.060
把文章数量全部加起来

01:23:09.060 --> 01:23:10.060
是不是总数

01:23:17.060 --> 01:23:18.060
文章总数

01:23:18.060 --> 01:23:19.060
会

01:23:20.060 --> 01:23:22.060
加上数据里面加一个全部

01:23:22.060 --> 01:23:23.060
作为第一项

01:23:25.500 --> 01:23:26.500
除了第一项之外

01:23:27.500 --> 01:23:28.500
后面的东西

01:23:28.500 --> 01:23:29.500
是不是把展开就行了

01:23:29.500 --> 01:23:30.500
ZS-data

01:23:30.500 --> 01:23:31.500
展开就行了

01:23:31.500 --> 01:23:32.500
得到这么一个数据

01:23:32.500 --> 01:23:33.500
好了

01:23:33.500 --> 01:23:34.500
这样子全部是不是出来了

01:23:34.500 --> 01:23:35.500
至少

01:23:35.500 --> 01:23:36.500
我们返回Reduce

01:23:36.500 --> 01:23:37.500
全部就出来了

01:23:37.500 --> 01:23:38.500
这边去绑定

01:23:39.500 --> 01:23:40.500
咱们再看

01:23:40.500 --> 01:23:42.500
你看全部是不是就出来了

01:23:42.500 --> 01:23:44.500
全部肯定是有的

01:23:44.500 --> 01:23:45.500
分类后面还要

01:23:45.500 --> 01:23:46.500
还要显示

01:23:46.500 --> 01:23:48.500
还要显示文章总数

01:23:49.500 --> 01:23:50.500
内门后面

01:23:50.500 --> 01:23:51.500
这个地方要显示文章总数

01:23:51.500 --> 01:23:52.500
你看这边

01:23:52.500 --> 01:23:53.500
多讨多少篇

01:23:53.500 --> 01:23:54.500
文章总数

01:23:55.500 --> 01:23:56.500
这个还要

01:23:56.500 --> 01:23:57.500
设计到一个新的样式

01:23:58.500 --> 01:23:59.500
设计到一个新的样式

01:23:59.500 --> 01:24:00.500
这个样式

01:24:00.500 --> 01:24:01.500
我们还别做

01:24:01.500 --> 01:24:02.500
以后再做吧

01:24:02.500 --> 01:24:03.500
我们还没有显示

01:24:03.500 --> 01:24:04.500
好

01:24:04.500 --> 01:24:05.500
那么现在就是把全部加进去了

01:24:05.500 --> 01:24:06.500
对吧

01:24:06.500 --> 01:24:07.500
往数据里边加了一下

01:24:07.500 --> 01:24:08.500
但是还不够

01:24:08.500 --> 01:24:09.500
因为我还要

01:24:09.500 --> 01:24:10.500
设置这个选中状态

01:24:10.500 --> 01:24:11.500
来

01:24:11.500 --> 01:24:12.500
Result

01:24:12.500 --> 01:24:13.500
我们再Map

01:24:14.500 --> 01:24:15.500
返回的时候再Map一下

01:24:15.500 --> 01:24:17.500
我要把他们原来的

01:24:17.500 --> 01:24:18.500
那个对象

01:24:18.500 --> 01:24:19.500
每一个对象里边

01:24:19.500 --> 01:24:20.500
要加一个属性

01:24:21.500 --> 01:24:22.500
那他怎么来加吧

01:24:23.500 --> 01:24:24.500
得到一个新的对象

01:24:24.500 --> 01:24:25.500
新的对象里边

01:24:25.500 --> 01:24:27.500
把原来的属性全部展开

01:24:27.500 --> 01:24:29.500
该加一个属性叫

01:24:29.500 --> 01:24:30.500
Is is that

01:24:30.500 --> 01:24:31.500
是否激活

01:24:31.500 --> 01:24:33.500
你觉得是否激活取决于啥

01:24:36.390 --> 01:24:37.390
我要把这个数据

01:24:37.390 --> 01:24:38.390
和当前的分类ID

01:24:38.390 --> 01:24:39.390
一起来弄一个

01:24:39.390 --> 01:24:40.390
计算属性出来

01:24:41.390 --> 01:24:42.390
就把原来的数据里边

01:24:42.390 --> 01:24:43.390
除了加一个全部

01:24:43.390 --> 01:24:44.390
然后还要把

01:24:44.390 --> 01:24:45.390
每一个数据

01:24:45.390 --> 01:24:47.390
加一个属性叫Is is that

01:24:47.390 --> 01:24:48.390
取决于啥

01:24:48.390 --> 01:24:50.390
取决于当前这个ID

01:24:51.390 --> 01:24:52.390
是不是等于

01:24:53.390 --> 01:24:54.390
分类ID

01:24:55.390 --> 01:24:56.390
所以当前的分类ID

01:24:56.390 --> 01:24:57.390
等的话就激活

01:24:57.390 --> 01:24:59.390
那么没有的话就不激活

01:24:59.390 --> 01:25:00.390
是不是搞了一个

01:25:00.390 --> 01:25:01.390
计算属性出来

01:25:01.390 --> 01:25:02.390
好 你看

01:25:03.390 --> 01:25:04.390
刷新

01:25:05.390 --> 01:25:06.390
分类3是激活的

01:25:07.390 --> 01:25:08.390
对不对

01:25:08.390 --> 01:25:09.390
那如果说全部的话

01:25:09.390 --> 01:25:10.390
如果说全部的话

01:25:10.390 --> 01:25:11.390
就这个 这个样子

01:25:12.390 --> 01:25:13.390
是不是全部都是激活的

01:25:15.390 --> 01:25:16.390
没问题吧

01:25:17.390 --> 01:25:18.390
是不是搞定了

01:25:19.390 --> 01:25:20.390
那么这个逻辑就搞定了

01:25:22.390 --> 01:25:23.390
你看 这个搞定了

01:25:23.390 --> 01:25:24.390
这个搞定了

01:25:24.390 --> 01:25:25.390
这个搞定了

01:25:25.390 --> 01:25:26.390
然后这个变化

01:25:26.390 --> 01:25:28.390
它会导致计算属性发生变化

01:25:28.390 --> 01:25:29.390
它也会跟着变化

01:25:29.390 --> 01:25:30.390
它一变化

01:25:30.390 --> 01:25:33.700
Rex列式组织就会刷新

01:25:33.700 --> 01:25:35.700
刚才的Fake Data的方法

01:25:35.700 --> 01:25:36.700
已经搞定了

01:25:37.700 --> 01:25:38.700
一开始

01:25:38.700 --> 01:25:39.700
那个混合里边

01:25:39.700 --> 01:25:40.700
会created的时候

01:25:40.700 --> 01:25:41.700
会调用这个方法

01:25:41.700 --> 01:25:43.700
它会出示发出的数据

01:25:43.700 --> 01:25:44.700
数据一变

01:25:44.700 --> 01:25:45.700
那么一个计算属性

01:25:46.700 --> 01:25:47.700
它一变

01:25:47.700 --> 01:25:48.700
它刷新

01:25:48.700 --> 01:25:49.700
Rex列式组织

01:25:49.700 --> 01:25:50.700
那么就剩下这个建筒了

01:25:50.700 --> 01:25:51.700
这建筒什么意思

01:25:51.700 --> 01:25:52.700
就是这个组织

01:25:52.700 --> 01:25:53.700
它有一个事件

01:25:53.700 --> 01:25:54.700
什么事件呢

01:25:54.700 --> 01:25:55.700
就是当

01:25:55.700 --> 01:25:56.700
是那个时候事件

01:25:57.700 --> 01:25:58.700
这个是圈级事件

01:25:58.700 --> 01:25:59.700
好像叫做

01:26:00.700 --> 01:26:01.700
当什么做个事件

01:26:01.700 --> 01:26:02.700
叫是那个时候事件

01:26:02.700 --> 01:26:03.700
这个事件

01:26:03.700 --> 01:26:04.700
我们要注册一下

01:26:05.700 --> 01:26:06.700
是那个时候

01:26:06.700 --> 01:26:07.700
其实是事件

01:26:07.700 --> 01:26:08.700
Tando

01:26:08.700 --> 01:26:09.700
是那个时候

01:26:10.700 --> 01:26:11.700
当我们选中了

01:26:11.700 --> 01:26:12.700
选中一个的时候

01:26:13.700 --> 01:26:14.700
它的事件

01:26:17.020 --> 01:26:18.020
那么之前

01:26:18.020 --> 01:26:20.020
我们这里还可以加个判断吧

01:26:20.020 --> 01:26:21.020
因为它如果说

01:26:21.020 --> 01:26:22.020
当前就是选中状态的话

01:26:22.020 --> 01:26:23.020
那么你就不触发了

01:26:23.020 --> 01:26:24.020
只有它当前

01:26:24.020 --> 01:26:25.020
不是选中状态的时候

01:26:26.020 --> 01:26:28.020
或者这个没有值的时候

01:26:30.020 --> 01:26:31.020
才触发

01:26:31.020 --> 01:26:32.020
它当前就是这个状态

01:26:32.020 --> 01:26:33.020
它就不用触发了

01:26:33.020 --> 01:26:34.020
好

01:26:34.020 --> 01:26:35.020
那么我们注册这个事件

01:26:36.020 --> 01:26:37.020
Tando是那个时候

01:26:37.020 --> 01:26:42.910
它就没有传

01:26:42.910 --> 01:26:43.910
它会传一个对象进来

01:26:44.910 --> 01:26:47.290
我们输出一下牌头

01:26:48.290 --> 01:26:49.290
来看一下

01:26:49.290 --> 01:26:55.890
点这个

01:26:55.890 --> 01:26:56.890
没反应对吧

01:26:56.890 --> 01:26:57.890
因为它本身就选中状态

01:26:58.890 --> 01:26:59.890
所以有反应

01:26:59.890 --> 01:27:00.890
对不对

01:27:00.890 --> 01:27:01.890
它把这个对象给我传进来了

01:27:01.890 --> 01:27:02.890
就点了这个

01:27:03.890 --> 01:27:05.890
点了这个过后我要干嘛呢

01:27:06.890 --> 01:27:07.890
我要干嘛

01:27:07.890 --> 01:27:08.890
我要干的事情特别简单

01:27:08.890 --> 01:27:09.890
我改变路由就完事了

01:27:10.890 --> 01:27:11.890
改变路由就完事了

01:27:11.890 --> 01:27:12.890
来吧

01:27:12.890 --> 01:27:13.890
我改变路由

01:27:18.890 --> 01:27:19.890
哪个路由

01:27:19.890 --> 01:27:21.890
是不是又分成两种情况

01:27:21.890 --> 01:27:22.890
跟这边逻辑是一样的

01:27:23.890 --> 01:27:24.890
又分成两种

01:27:24.890 --> 01:27:25.890
跟这边的逻辑是一样的

01:27:30.700 --> 01:27:31.700
分两种情况

01:27:34.900 --> 01:27:35.900
扶植一下吧

01:27:35.900 --> 01:27:36.900
能过来

01:27:37.900 --> 01:27:38.900
quarry不变

01:27:39.900 --> 01:27:40.900
也马不变

01:27:40.900 --> 01:27:41.900
也马要回到第1页

01:27:41.900 --> 01:27:42.900
你改变了分类过后

01:27:42.900 --> 01:27:43.900
要回到第1页

01:27:43.900 --> 01:27:44.900
也马回到第1页

01:27:44.900 --> 01:27:45.900
里面程的不变

01:27:46.900 --> 01:27:47.900
之前是什么里面程

01:27:47.900 --> 01:27:48.900
现在就什么里面程

01:27:48.900 --> 01:27:50.900
里面程的数据

01:27:50.900 --> 01:27:51.900
我们就直接

01:27:51.900 --> 01:27:52.900
这里就直接取吧

01:27:52.900 --> 01:27:53.900
取肉车里面

01:27:54.900 --> 01:27:55.900
quarry

01:27:55.900 --> 01:27:56.900
我还是要用一个

01:27:56.900 --> 01:27:57.900
用一个计算属性得了

01:27:59.900 --> 01:28:00.900
里面程

01:28:00.900 --> 01:28:07.950
这边是

01:28:09.950 --> 01:28:13.220
quarry

01:28:15.220 --> 01:28:16.220
里面程

01:28:16.220 --> 01:28:17.220
没有的话我就取10

01:28:18.220 --> 01:28:19.220
里面程

01:28:20.220 --> 01:28:21.220
我之前我是把

01:28:21.220 --> 01:28:22.220
合并成一个对象

01:28:22.220 --> 01:28:23.220
我现在把它分开

01:28:23.220 --> 01:28:24.220
因为没有几个

01:28:24.220 --> 01:28:25.220
之前是要全部都过去

01:28:25.220 --> 01:28:26.220
现在只过去两个

01:28:26.220 --> 01:28:27.220
其实你也可以

01:28:27.220 --> 01:28:28.220
把它弄到一起

01:28:28.220 --> 01:28:29.220
你们自己去弄

01:28:30.220 --> 01:28:31.220
好 首先我们quarry

01:28:31.220 --> 01:28:32.220
参数了

01:28:32.220 --> 01:28:33.220
一页马要变成第1页

01:28:33.220 --> 01:28:35.220
因为你分类变了过后

01:28:35.220 --> 01:28:36.220
我之前是另外一个分类

01:28:36.220 --> 01:28:38.220
你哪怕翻到第10页了

01:28:38.220 --> 01:28:39.220
我改变到

01:28:40.220 --> 01:28:41.220
重新改变一个分类

01:28:41.220 --> 01:28:42.220
它肯定要从第1页开始

01:28:42.220 --> 01:28:44.220
说页马固定为1

01:28:44.220 --> 01:28:45.220
里面程

01:28:46.220 --> 01:28:48.220
就得到当前的里面程

01:28:49.220 --> 01:28:50.220
quarry

01:28:50.220 --> 01:28:51.220
对吧

01:28:51.220 --> 01:28:52.220
quarry是固定的

01:28:52.220 --> 01:28:53.220
好 那么剩下就是

01:28:53.220 --> 01:28:54.220
category ID

01:28:54.220 --> 01:28:56.220
如果说你点击到category ID

01:28:57.220 --> 01:28:58.220
你点击到ID

01:28:58.220 --> 01:28:59.220
是等于-1

01:28:59.220 --> 01:29:00.220
那么是不是要

01:29:00.220 --> 01:29:02.220
跑到全部分类里面去

01:29:02.220 --> 01:29:03.220
跑到全部分类里面去

01:29:03.220 --> 01:29:04.220
那肯定是要

01:29:04.220 --> 01:29:05.220
到这个路由

01:29:05.220 --> 01:29:07.220
quarry上进去

01:29:08.220 --> 01:29:09.220
对吧

01:29:09.220 --> 01:29:10.220
或者是我不要quarry

01:29:10.220 --> 01:29:11.220
不要quarry

01:29:13.220 --> 01:29:14.220
都行

01:29:14.220 --> 01:29:15.220
那么现在

01:29:15.220 --> 01:29:16.220
Els

01:29:16.220 --> 01:29:17.220
就是有分类

01:29:17.220 --> 01:29:18.220
你点了某一个分类

01:29:18.220 --> 01:29:19.220
不是全部

01:29:19.220 --> 01:29:21.220
点到不是全部的话

01:29:21.220 --> 01:29:22.220
那么我就应该

01:29:22.220 --> 01:29:24.220
到这个命名路由

01:29:26.220 --> 01:29:27.220
到这个命名路由

01:29:27.220 --> 01:29:28.220
然后quarry上进去

01:29:28.220 --> 01:29:29.220
parry上的category ID

01:29:29.220 --> 01:29:30.220
应该等于

01:29:30.220 --> 01:29:32.220
item.id

01:29:32.220 --> 01:29:35.730
逻辑是差不多的

01:29:35.730 --> 01:29:37.730
好 那么这个逻辑就实现了

01:29:37.730 --> 01:29:38.730
路由一变

01:29:38.730 --> 01:29:39.730
它也会跟那边

01:29:39.730 --> 01:29:40.730
之前那个组建

01:29:40.730 --> 01:29:41.730
发现路由变了

01:29:41.730 --> 01:29:42.730
它也会跟那边

01:29:42.730 --> 01:29:43.730
好 咱们来看一下

01:29:45.730 --> 01:29:46.730
其实已经打通了

01:29:46.730 --> 01:29:47.730
代码已经打通了

01:29:47.730 --> 01:29:49.730
点分类1

01:29:50.730 --> 01:29:52.730
跑到分类1里面去了

01:29:52.730 --> 01:29:53.730
点分类3

01:29:53.730 --> 01:29:55.730
只能看不出来而已

01:29:55.730 --> 01:29:56.730
然后点全部

01:29:56.730 --> 01:29:58.730
你看 看地址

01:29:58.730 --> 01:29:59.730
地址不正确了

01:29:59.730 --> 01:30:00.730
地址正确了

01:30:00.730 --> 01:30:01.730
我们之前的组建测试过了

01:30:01.730 --> 01:30:02.730
它会根据地址来选

01:30:05.490 --> 01:30:06.490
就搞定了

01:30:07.490 --> 01:30:08.490
那么最后一件事

01:30:08.490 --> 01:30:09.490
最后现在之前

01:30:09.490 --> 01:30:10.490
整忘了

01:30:10.490 --> 01:30:11.490
最后一件事就是

01:30:11.490 --> 01:30:12.490
这里边有一些

01:30:12.490 --> 01:30:13.490
有一个数据

01:30:13.490 --> 01:30:14.490
就是显示

01:30:14.490 --> 01:30:15.490
就显示这个

01:30:15.490 --> 01:30:16.490
有多少多少偏

01:30:16.490 --> 01:30:17.490
那么这个地方

01:30:17.490 --> 01:30:18.490
要改动一下

01:30:18.490 --> 01:30:19.490
之前那个组建

01:30:19.490 --> 01:30:20.490
叫resonance

01:30:20.490 --> 01:30:21.490
就是这边

01:30:21.490 --> 01:30:22.490
这个span

01:30:22.490 --> 01:30:23.490
我看一下

01:30:24.490 --> 01:30:25.490
这里有个元素

01:30:25.490 --> 01:30:26.490
span元素

01:30:27.490 --> 01:30:28.490
我还得加一个span

01:30:28.490 --> 01:30:29.490
这个span有可能有

01:30:29.490 --> 01:30:30.490
有可能没有

01:30:30.490 --> 01:30:31.490
就是如果说

01:30:31.490 --> 01:30:32.490
你给我的数据里边

01:30:32.490 --> 01:30:33.490
有一个属性叫做

01:30:34.490 --> 01:30:35.490
一个附加信息

01:30:35.490 --> 01:30:36.490
就ersight

01:30:36.490 --> 01:30:37.490
如果说你的item里边

01:30:37.490 --> 01:30:38.490
有一个ersight属性

01:30:38.490 --> 01:30:40.490
那么就是附加信息

01:30:40.490 --> 01:30:41.490
附加信息的话

01:30:41.490 --> 01:30:42.490
我就要把显示出来

01:30:43.490 --> 01:30:45.490
item叫ersight

01:30:45.490 --> 01:30:47.490
那么给它一个内样式吧

01:30:47.490 --> 01:30:48.490
class

01:30:49.490 --> 01:30:50.490
ersight

01:30:50.490 --> 01:30:51.490
绝地子

01:30:51.490 --> 01:30:53.490
那么就要加个span

01:30:53.490 --> 01:30:54.490
这个span

01:30:54.490 --> 01:30:55.490
如果说有一个附加信息

01:30:55.490 --> 01:30:56.490
这就是附加信息

01:30:56.490 --> 01:30:57.490
那么我就把在这里

01:30:57.490 --> 01:30:58.490
给它显示出来

01:30:58.490 --> 01:30:59.490
那么这个附加信息

01:30:59.490 --> 01:31:00.490
我这边对象里边

01:31:00.490 --> 01:31:01.490
肯定没有

01:31:01.490 --> 01:31:02.490
搞定计算属性

01:31:02.490 --> 01:31:04.490
搞定计算属性不完

01:31:05.490 --> 01:31:06.490
这一刻

01:31:06.490 --> 01:31:07.490
要好好去梳理一下

01:31:07.490 --> 01:31:09.490
这一刻弄完了过后

01:31:10.490 --> 01:31:12.490
对这个主键的把控能力

01:31:12.490 --> 01:31:13.490
就会突飞猛进

01:31:14.490 --> 01:31:15.490
假装

01:31:15.490 --> 01:31:16.490
所以我们该加一个属性

01:31:16.490 --> 01:31:17.490
就完成了

01:31:17.490 --> 01:31:18.490
对不对

01:31:18.490 --> 01:31:19.490
ersight的属性

01:31:19.490 --> 01:31:20.490
这属性的值是啥

01:31:20.490 --> 01:31:22.490
多少多少偏

01:31:22.490 --> 01:31:23.490
多少多少偏

01:31:23.490 --> 01:31:24.490
我们在这里加

01:31:24.490 --> 01:31:25.490
其实也可以

01:31:25.490 --> 01:31:26.490
在这里加

01:31:26.490 --> 01:31:27.490
map的时候

01:31:27.490 --> 01:31:28.490
该加一个属性

01:31:28.490 --> 01:31:29.490
ersight

01:31:29.490 --> 01:31:31.490
多少多少偏

01:31:31.490 --> 01:31:32.490
多少多少偏

01:31:32.490 --> 01:31:33.490
是不是就是

01:31:33.490 --> 01:31:35.490
article code

01:31:37.490 --> 01:31:38.490
偏

01:31:38.490 --> 01:31:39.490
对不对

01:31:39.490 --> 01:31:40.490
加那个属性

01:31:40.490 --> 01:31:41.490
好保存

01:31:41.490 --> 01:31:42.490
你看

01:31:42.490 --> 01:31:43.490
有这个属性

01:31:43.490 --> 01:31:44.490
它就会显示出来

01:31:44.490 --> 01:31:45.490
NAN

01:31:45.490 --> 01:31:46.490
这个地方

01:31:46.490 --> 01:31:47.490
汇总的时候

01:31:47.490 --> 01:31:48.490
汇总的一个问题

01:31:48.490 --> 01:31:52.700
打印一下汇总

01:31:52.700 --> 01:31:53.700
article

01:31:53.700 --> 01:31:54.700
这里写错了

01:31:54.700 --> 01:31:56.700
应该是A加上那个

01:31:57.700 --> 01:31:58.700
保存

01:31:59.700 --> 01:32:00.700
你看是不是出来了

01:32:00.700 --> 01:32:01.700
不过那样式

01:32:01.700 --> 01:32:02.700
我们稍微设置一下

01:32:02.700 --> 01:32:03.700
稍微设置到

01:32:03.700 --> 01:32:04.700
这边的样式

01:32:05.700 --> 01:32:06.700
如果说里边

01:32:06.700 --> 01:32:07.700
有一个ersight

01:32:08.700 --> 01:32:09.700
那样式

01:32:10.700 --> 01:32:11.700
那么我给它

01:32:11.700 --> 01:32:12.700
设置一下

01:32:17.890 --> 01:32:18.890
首先一个激活效果

01:32:19.890 --> 01:32:20.890
激活效果

01:32:20.890 --> 01:32:21.890
agative

01:32:22.890 --> 01:32:23.890
agative在这

01:32:24.890 --> 01:32:25.890
都加上

01:32:25.890 --> 01:32:26.890
都加上这个agative

01:32:33.270 --> 01:32:34.270
agative的样式

01:32:34.270 --> 01:32:35.270
它这边也有了

01:32:36.270 --> 01:32:37.270
然后呢

01:32:37.270 --> 01:32:38.270
给它设置一下

01:32:38.270 --> 01:32:39.270
肢体大小

01:32:39.270 --> 01:32:42.740
颜色这些东西

01:32:42.740 --> 01:32:44.740
放置weights bold

01:32:44.740 --> 01:32:46.740
这是agative的样式

01:32:47.740 --> 01:32:49.740
防止size margin left

01:32:53.900 --> 01:32:54.900
这些大小

01:32:54.900 --> 01:32:55.900
margin left

01:32:55.900 --> 01:32:57.900
然后呢再设置一个

01:32:59.900 --> 01:33:00.900
再设置一个啥

01:33:01.900 --> 01:33:03.900
再设置一个

01:33:03.900 --> 01:33:04.900
颜色

01:33:04.900 --> 01:33:05.900
微灰色

01:33:10.980 --> 01:33:11.980
试一下

01:33:12.980 --> 01:33:13.980
OK

01:33:13.980 --> 01:33:14.980
差不多了对吧

01:33:14.980 --> 01:33:15.980
有点意思

01:33:16.980 --> 01:33:17.980
点击

01:33:17.980 --> 01:33:18.980
点击

01:33:19.980 --> 01:33:20.980
点它的时候

01:33:20.980 --> 01:33:21.980
其实也可以切换

01:33:21.980 --> 01:33:22.980
那么给它做这个实际

01:33:22.980 --> 01:33:23.980
点它的时候

01:33:23.980 --> 01:33:24.980
也是同样的实际

01:33:26.980 --> 01:33:27.980
点它的时候也可以切换

01:33:28.980 --> 01:33:29.980
好来吧

01:33:30.980 --> 01:33:31.980
点它

01:33:31.980 --> 01:33:32.980
是不是也可以切换

01:33:32.980 --> 01:33:33.980
点它

01:33:33.980 --> 01:33:34.980
也可以切换

01:33:34.980 --> 01:33:35.980
点它

01:33:35.980 --> 01:33:36.980
也可以切换

01:33:36.980 --> 01:33:37.980
好那么这个页面

01:33:37.980 --> 01:33:38.980
其实我们就已经

01:33:38.980 --> 01:33:39.980
做出来

01:33:39.980 --> 01:33:40.980
分类这里的话

01:33:40.980 --> 01:33:41.980
我们也可以给它

01:33:41.980 --> 01:33:42.980
一个滚动条

01:33:42.980 --> 01:33:44.980
慢慢把它玩上一点

01:33:44.980 --> 01:33:45.980
把细节玩上一点

01:33:46.980 --> 01:33:47.980
这个地方也可以

01:33:47.980 --> 01:33:48.980
再滚动条吧

01:33:48.980 --> 01:33:49.980
overflow y

01:33:50.980 --> 01:33:51.980
这边

01:33:51.980 --> 01:33:52.980
这边我们就out to

01:33:53.980 --> 01:33:54.980
你看这边也有滚动条

01:33:57.420 --> 01:33:58.420
这边也有

01:33:59.420 --> 01:34:00.420
应付分类比较多的情况

01:34:00.420 --> 01:34:01.420
但是分类一般来说

01:34:01.420 --> 01:34:02.420
不会这么多

01:34:04.420 --> 01:34:05.420
你看是不是搞定了

01:34:08.380 --> 01:34:09.380
地次兰

01:34:09.380 --> 01:34:10.380
它出发地次兰变化

01:34:10.380 --> 01:34:11.380
地次兰变化导致

01:34:11.380 --> 01:34:12.380
这两个图片又重新券了

01:34:12.380 --> 01:34:13.380
这边也会出发

01:34:13.380 --> 01:34:14.380
地次兰变化

01:34:15.380 --> 01:34:17.380
那么就是文章列表页

01:34:17.380 --> 01:34:18.380
就全部搞定了

01:34:18.380 --> 01:34:19.380
这里看内容比较多

01:34:19.380 --> 01:34:20.380
时间比较长

01:34:20.380 --> 01:34:21.380
知识点也很多

01:34:21.380 --> 01:34:22.380
大家下来了

01:34:22.380 --> 01:34:24.380
好好去消化一下

01:34:24.380 --> 01:34:25.380
一定

01:34:25.380 --> 01:34:26.380
坚信自己

01:34:26.380 --> 01:34:27.380
一个问题一个问题解决

01:34:27.380 --> 01:34:28.380
一定是能把它做完的

01:34:28.380 --> 01:34:29.380
好

01:34:29.380 --> 01:34:30.380
同学们加油

