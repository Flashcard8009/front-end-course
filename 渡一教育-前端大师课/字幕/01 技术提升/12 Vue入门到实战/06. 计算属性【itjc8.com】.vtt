WEBVTT

00:00.180 --> 00:04.780
上课之前 说一下上节课这个头像组件

00:05.040 --> 00:09.900
头像组件还可以非常非常小的一个问题 也不算问题吧

00:10.160 --> 00:10.940
给他说一下

00:11.700 --> 00:15.020
就是上期课 咱们不是说了这个属性吗 对吧

00:15.280 --> 00:20.660
属性这里有些约束 我们学了几个了 一个是内形的约束 一个是避田 对不对

00:20.920 --> 00:24.500
那我们这个size的属性是没有避田的 对吧 你可以不填

00:24.760 --> 00:28.340
那么我再说另外一个 就是说它可以有默认值的

00:28.340 --> 00:33.460
咋意思呢 就是说 比方这个地方啊 我们不填这个属性

00:33.720 --> 00:35.760
不填的话 它是可以有默认值的

00:36.020 --> 00:40.120
那怎么来用默认值呢 就是非常简单啊 我们这里呢可以写个default

00:41.140 --> 00:44.220
默认值 默认值一个数字吗 比方我们给他写个

00:44.980 --> 00:45.480
多少

00:45.740 --> 00:46.260
150

00:47.020 --> 00:50.860
好 保存啊 你看 我们的页面上没有填的时候 他就是150

00:51.120 --> 00:52.660
可吧 点击右键 检查

00:53.420 --> 00:56.760
这里呢 image 150个像素 我们看组件数啊

00:57.220 --> 01:00.040
这个组件数里边这个vata第1个size

01:00.560 --> 01:02.080
对吧 没有填就是150

01:02.600 --> 01:05.420
没有意思吧 就是个默认值啊 非常简单 大家说一下

01:06.440 --> 01:08.480
好了 这一刻呢 我们要开发一个组件了啊

01:08.740 --> 01:09.760
这个组件是什么呢

01:10.280 --> 01:11.300
就是我们

01:11.560 --> 01:12.580
这个网页中

01:12.840 --> 01:14.380
到处都会出现的

01:14.640 --> 01:15.400
图标组件

01:16.160 --> 01:16.680
这个组件

01:17.960 --> 01:20.260
那么这个组件开发呢 需要一个新的知识

01:20.520 --> 01:23.840
这个知识不具备的话 这个组件开发起来呢 会遇到一些困难

01:24.360 --> 01:26.660
什么知识呢 就是我们的计算属性

01:26.960 --> 01:29.160
计算属性在很早的时候 我们其实接触过

01:29.400 --> 01:31.360
当时我们写第1个无忧应用的时候

01:31.620 --> 01:32.640
是不是有这么一个配置啊

01:32.900 --> 01:33.400
叫做

01:33.660 --> 01:35.200
computed

01:35.460 --> 01:36.480
对吧 有这么一个配置

01:36.740 --> 01:40.320
那么这几刻呢 咱们就来讲一讲这个配置啊

01:40.580 --> 01:41.360
计算属性

01:41.860 --> 01:45.960
这个计算属性呢 不仅是我们在开发中常见的这么一个配置

01:46.480 --> 01:46.980
而且呢

01:48.000 --> 01:51.080
面试体里边也是一个常问到的一个配置

01:51.600 --> 01:52.360
好 咱们来看一下

01:53.380 --> 01:54.160
笔记打开

01:55.140 --> 01:58.460
面试体呢 可能会问你计算属性跟方法有什么区别

01:59.220 --> 02:02.060
那么你要回答这个问题呢 你必须要搞清楚什么叫计算属性

02:02.560 --> 02:03.580
这里给大家举个例子啊

02:04.860 --> 02:06.140
比方说吧

02:06.660 --> 02:07.940
咱们有一个

02:08.700 --> 02:11.780
就这个app 就这个组件吧 在这个组件里面玩 把这些东西删掉

02:12.040 --> 02:15.100
因为我们之前已经测试好了 将来会用到啊 留在这

02:16.140 --> 02:18.180
现在呢 我们这个就一个app组件

02:18.680 --> 02:19.980
这个组件里面呢 有个数据

02:20.740 --> 02:21.500
这个数据呢

02:22.260 --> 02:23.540
一个是first name

02:24.860 --> 02:25.660
原

02:26.940 --> 02:28.460
The last name

02:29.740 --> 02:32.060
中国人的名字呢 跟国外的好像有点区别对吧

02:32.300 --> 02:33.140
这个玩意是信

02:33.580 --> 02:36.900
国外的这个玩意是信这个是名啊 无所谓吧 就这么样一个东西

02:37.180 --> 02:39.740
然后呢 我们在页面上显示呢 比方说

02:40.260 --> 02:42.800
我们希望得到一个数据是全名

02:44.020 --> 02:47.420
全名这个数据怎么显示呢 我们有很多种显示方式

02:47.660 --> 02:49.460
比方说吧 我们举个简单的例子

02:49.980 --> 02:51.060
我们这里一个信

02:52.940 --> 02:53.540
信是什么呢

02:54.180 --> 02:55.900
就是first name

02:56.180 --> 02:57.700
然后呢 一个名

03:00.260 --> 03:00.700
名

03:01.220 --> 03:01.780
就是

03:04.160 --> 03:05.080
last name

03:06.880 --> 03:08.400
好 然后呢 一个全名

03:09.040 --> 03:12.200
诶 全名的一个非常简单的写法 怎么写呢 就全名这样子写

03:15.040 --> 03:15.480
这样子写

03:15.800 --> 03:20.840
就是first name 拼戒一个的吧 拼戒一个就行了吧 表达数字嘛 一个空格嘛

03:21.640 --> 03:23.720
加上一个last name

03:23.960 --> 03:25.320
不就完了吗 不就全名了吗

03:25.720 --> 03:28.440
这样子写行不行呢 当然是没有什么问题的

03:28.940 --> 03:29.960
没有什么问题的

03:30.220 --> 03:32.780
因为我们这个的需求呢 比较简单

03:33.540 --> 03:38.680
但这个需求的本质是什么呀 就是要根据已有的两个数据 要得到一个新的数据

03:39.180 --> 03:44.300
对不对 那么将来如果说这个地方可能比较麻烦 这个计算 根据已有的属性得到新的数据

03:44.560 --> 03:49.160
新的数据的话 这过程比较复杂的话 那么就不适合作为一个表达式写出来了

03:49.420 --> 03:53.000
有可能有很多的表达式 或者是有很多的代码才能计算出来

03:53.260 --> 03:55.060
那么我们这里取这么一个简单的例子

03:55.620 --> 04:00.980
如果说比较简单的话 当然可以这样子写 那如果说比较复杂呢 他计算过程比较复杂呢

04:01.420 --> 04:05.580
那怎么办呢 我们可以想到 根据我们以前所学啊 我们是不是可以写个方法

04:07.060 --> 04:10.540
就get for name 得到权名

04:11.220 --> 04:15.740
怎么来得到权名呢 注意啊 在无诱的配置里边 只要写到方法的地方

04:16.100 --> 04:22.300
方法内部的这个z啊 指向是谁 指向的是无诱实力 对吧 指向的是这个组件实力

04:22.900 --> 04:25.900
那么说实力里边是不是有first name 对吧 我们这里直接返回

04:27.860 --> 04:31.100
z 点first name 拼接上z 点那生命

04:31.900 --> 04:37.940
那么这边呢 我们全名可以用什么呢 当中间可以加上一个空格啊 加上空格拼接

04:38.660 --> 04:43.860
那么这里是不是可以使用调用方法呀 get for name 调用方法 是不是得到权名的

04:44.340 --> 04:46.340
非常简单 你看呀 效果是完全一样的

04:47.340 --> 04:50.500
这样子写挺好的呀 有什么问题呢 这样子写

04:51.700 --> 05:00.300
有一个非常非常小的问题 我们把这个方法里边呢给他输出一个啊 叫做master code 表示吗 方法被调用了

05:00.940 --> 05:04.620
那如果说我们这个组件里边有很多地方都要使用到这个

05:05.220 --> 05:08.540
计算出来的结果 都要使用这个权名 比方说啊

05:10.020 --> 05:14.540
多写几个 那么结果是什么呢 他又会多次调用这个方法

05:15.540 --> 05:17.100
你看啊 方法是不是多次调用了

05:18.100 --> 05:21.940
如果说我们假设啊 当然这个这个这个例子呢 倒不是

05:24.300 --> 05:25.780
倒看不出来啊 这比较简单

05:26.660 --> 05:30.820
但是我们假设 如果说这个计算过程是比较复杂的 比较耗时的

05:31.740 --> 05:36.140
那这个方法调用多次是不是会影响效率啊 对吧 而且那里会看一下

05:36.900 --> 05:38.500
无论他的计算过程多么复杂

05:39.220 --> 05:44.820
他是不是只跟这两个数据有关系 这两个数据不变 那么计算的结果就不变

05:45.580 --> 05:46.620
所以一定是这样子

05:47.300 --> 05:50.820
能理解吧 这两个东西不变 那么计算的结果就不变

05:51.500 --> 05:54.820
那有必要去调用这么多次方法去重新计算一下吗

05:55.180 --> 05:57.900
没必要 于是呢 为了解决这个问题啊

05:58.660 --> 06:03.260
无忧呢 他可以做了这么一个配置 叫做computing 叫计算属性

06:05.860 --> 06:07.900
计算属性里边写的是什么呢

06:08.980 --> 06:11.380
这是个对象啊 对象里边一个属性就是一个计算属效

06:12.020 --> 06:17.820
计算属性的本质的意思就是 根据已有的数据得到一个新的数据

06:18.820 --> 06:23.220
那么怎么写呢 我们就可以直接这样子写一个full name full name是不是一个新的数据

06:23.540 --> 06:28.180
我们这个命名啊 一般不用什么get什么set什么 一般是用的是就是一个名字

06:28.660 --> 06:29.260
一个名词

06:30.340 --> 06:37.580
就表示一个新的数据 新的数据来自于哪呢 来自于已有的数据算出来的return zester

06:39.460 --> 06:41.620
first name 拼接上 空格

06:43.220 --> 06:50.740
zester last name 是根据已有数据算出来的 我们比较在这里啊 他也是个方法 叫做full name code

06:52.900 --> 06:58.060
好 接下来我们来看一下啊 我们这个东西该怎么使用了 他就不能当把它当成方法使用了 你不能这样子写啊

06:58.700 --> 06:59.380
你不能这样子写的

07:04.040 --> 07:08.480
你不能这样子写 把它当成方法掉了 不行了啊 他不是方法啊 你看现在直接爆错了

07:09.200 --> 07:11.520
那么应该怎么来使用了 把它当成数据来使用

07:12.520 --> 07:13.480
把它当成这样子来使用

07:14.320 --> 07:21.680
你看 就像一个一个属性一样 一个数据一样 好保存 你会看到数据得到的结果完全一样

07:22.440 --> 07:25.240
但是呢 实际上这个方法只被调整了一次

07:25.680 --> 07:30.280
要不要full name code 方法只被调整了一次 那么计算属性是怎么回事呢

07:31.080 --> 07:33.680
其实非常简单 他就就是多了一个缓存

07:34.920 --> 07:38.080
当我们去使用这个数据的时候 他本质上是在调用这个方法

07:38.960 --> 07:39.520
得到结果

07:40.840 --> 07:44.480
在调用这个方法的过程中呢 我又会做一个介绍 就是记录这个依赖

07:44.720 --> 07:47.200
就是这个方法依赖什么数据呢 依赖这两个数据

07:47.760 --> 07:49.360
哎 只要这两个数据不变

07:50.280 --> 07:52.920
我这个方法没有必要重新计算 所以说第一次

07:54.000 --> 07:56.520
我在这里显示全名 调用这个方法 对吧

07:57.840 --> 07:59.320
那么这里呢 叔叔这么一句话

08:00.240 --> 08:04.480
好 那么这个时候他就缓存下来了 first name 他一代first name 一代那是name

08:05.480 --> 08:09.080
诶 于是呢 这个他计算出来的值 远近就缓存下来了

08:09.520 --> 08:12.080
当我第二次再去用这个计算属性的时候 诶 不计算

08:12.840 --> 08:14.800
之前有诶 自己把之前的这个结果拿出来用

08:15.320 --> 08:17.680
就没有 他就没有重新去计算调用这个方法了

08:18.240 --> 08:19.040
是不是提高了效率啊

08:20.120 --> 08:24.520
如果说将来有一天我的名字新变了 或者是名变了 啊 比方说我们这里敢干

08:25.800 --> 08:26.600
把这个新

08:27.400 --> 08:30.080
我这就随便写个啊 修改新名为

08:31.000 --> 08:31.840
啊 计算

08:34.480 --> 08:38.960
那比方说啊 我们点击过后 点击过后呢 我们把这个first name

08:40.040 --> 08:41.240
啊 我们这里写个方法吧

08:43.400 --> 08:51.080
since new name first

08:52.920 --> 08:53.280
last

08:54.160 --> 08:57.280
啊 我们这里呢 把个first name 改为first

08:59.760 --> 09:01.840
把这个last name 改为last

09:02.520 --> 09:05.000
好 比方说有这么一个方法啊 我点击过后呢 就调用这个方法

09:05.000 --> 09:05.680
since new name

09:06.560 --> 09:10.640
注意 这里是单一号啊 为什么 因为外面的双一号有冲突啊 这单一号

09:11.640 --> 09:12.360
新呢 为基

09:14.280 --> 09:14.760
名呢

09:16.120 --> 09:16.800
last name

09:19.880 --> 09:20.080
成

09:21.640 --> 09:24.200
好 那么这样子是不是改动了first name 和改动了last name

09:24.600 --> 09:28.760
改动了过后呢 是不是一面 这个组件会重新生成虚的动物数 会重新炫载

09:29.200 --> 09:33.280
而重新炫载过程中 是不是要重新计算权力 重新计算传遍的时候 他就会发现

09:33.640 --> 09:39.360
哎 之前的东西变了 不再是之前那个样子了 一旦像变化的时候 他就会重新计算

09:39.960 --> 09:44.840
看一下吧 效果 你看 第一次刷新 第一次调用 运行的一次

09:45.400 --> 09:50.080
计算属性 没有重复运行 效率非常高 然后改了新名字过后呢

09:50.920 --> 09:54.640
他又只运行了一次 对吧 一旦像变化了 只运行了一次

09:55.000 --> 09:57.840
看到没 这就是计算属性他的优势 他有缓存

10:00.040 --> 10:01.520
没问题吧 就这么个意思

10:02.360 --> 10:08.400
好 那么接下来 那么来看一下他的完整的东西啊 完整的计算属性的写法呢 实际上我们刚才那个是减写

10:08.880 --> 10:13.480
完整的计算属性的其实就类似于什么呢 类似于这个object

10:14.420 --> 10:15.920
define body

10:18.400 --> 10:21.680
里边什么的吧 然后呢 里边是不是有一个getter

10:23.600 --> 10:26.320
set 对吧 所以有这两个东西其实这里写法一样

10:26.320 --> 10:28.880
计算书现在它本来就是这样子写的

10:28.880 --> 10:29.900
应该是这样子写的

10:29.900 --> 10:30.680
一个配置

10:30.680 --> 10:33.240
getter,getter的时候没有参数无参的

10:33.240 --> 10:36.300
根据遗诱数据得到一个新的数据发挥

10:36.300 --> 10:39.380
setter的时候给一个参数就是你付的值是什么

10:39.380 --> 10:40.660
然后去做事情

10:40.660 --> 10:41.940
这是它的完整写法

10:41.940 --> 10:43.460
所以我们刚才这个代码

10:43.460 --> 10:45.000
如果说一把写完的话

10:45.000 --> 10:46.280
它的完整写法是这样子的

10:46.280 --> 10:49.410
把它写过来

10:49.410 --> 10:52.060
getter

10:52.060 --> 10:54.360
完整的写法是这样子

10:54.360 --> 10:57.420
那么设置给得到全名

10:57.420 --> 10:57.940
对不对

10:57.940 --> 10:59.480
它只能读不能写

10:59.980 --> 11:01.780
你看效果是完全一样的

11:05.620 --> 11:07.420
后面为什么没有重新计算了

11:07.420 --> 11:08.960
因为数据上是没有变化的

11:09.720 --> 11:10.480
懂的意思吧

11:10.480 --> 11:12.280
那么也就是说它是可以有setter的

11:12.280 --> 11:14.840
但是平时我们用计算属性很少使用setter

11:14.840 --> 11:16.640
比方说有setter过后

11:16.640 --> 11:19.200
我好像就不需要setter留念这个函数了

11:19.200 --> 11:20.480
那么我们这里

11:20.480 --> 11:23.040
直接把这个for name

11:23.040 --> 11:24.320
设置为什么呢

11:24.320 --> 11:26.100
设置为计算

11:27.080 --> 11:29.380
那么这样子是不是实际上

11:29.380 --> 11:31.940
是在调用这个计算属性的setter

11:31.940 --> 11:33.220
那么这个bar是什么呢

11:33.220 --> 11:35.780
bar就是以传的负责值就是基层

11:36.560 --> 11:38.600
比方说我们这里

11:38.600 --> 11:42.180
正在设置全名

11:42.180 --> 11:44.740
那么这里把bar打印出来看一下

11:44.740 --> 11:45.700
保存

11:45.700 --> 11:46.540
放心

11:46.540 --> 11:47.980
那我首先问大家一个问题

11:47.980 --> 11:50.260
当我点这个按钮的时候

11:50.260 --> 11:52.420
要不要重新调用getter

11:53.540 --> 11:54.980
好好想一想

11:55.860 --> 11:58.850
看一下这个代码

11:58.850 --> 12:00.490
当我点这个按钮的时候

12:00.490 --> 12:03.090
其实实际上点这个按钮了

12:03.090 --> 12:04.130
就在运行这个

12:04.130 --> 12:04.850
对吧

12:04.850 --> 12:06.490
那也就是说运行这个的时候

12:06.490 --> 12:12.680
它最终的结果会不会导致重新运行getter

12:12.680 --> 12:15.440
不要想复杂了

12:15.440 --> 12:19.560
这个东西实际上是在调用setter函数

12:19.560 --> 12:23.000
setter函数里面有没有改动它的依赖

12:23.000 --> 12:24.120
有没有改动这两个依赖

12:24.120 --> 12:25.400
没有改动

12:25.400 --> 12:27.640
没有改动getter有什么关系呢

12:27.680 --> 12:29.920
没有改动数据就不会导致重新运行

12:29.920 --> 12:31.000
不会导致重新运行

12:31.000 --> 12:33.120
那就不会运行

12:33.120 --> 12:33.600
对不对

12:33.600 --> 12:34.880
就不会运行这些东西

12:34.880 --> 12:35.520
不会运行

12:35.520 --> 12:37.320
这个不会重新生产区域多么数

12:37.320 --> 12:39.040
不会重新运行这一部分

12:39.040 --> 12:40.920
它自然不然不会运行getter

12:40.920 --> 12:41.680
没意思吧

12:41.680 --> 12:44.440
除非我这里改动了数据

12:44.440 --> 12:45.560
不行要改动数据

12:45.560 --> 12:47.360
而且要改动它的依赖数据

12:47.360 --> 12:48.200
它的依赖相辨了

12:48.200 --> 12:49.720
比方说我这里的cult

12:49.720 --> 12:51.520
我这里改动cult也不行

12:51.520 --> 12:52.440
我们先这样子

12:52.440 --> 12:53.480
先这样子

12:53.480 --> 12:55.840
我先不做任何改动一点

12:56.040 --> 12:57.880
它只是输出这么一句话

12:57.880 --> 12:58.800
其他什么都没有做

12:58.800 --> 13:00.440
也没有重新选的

13:00.440 --> 13:02.680
那么如果说我改动了数据

13:02.680 --> 13:04.600
getcult改动了数据

13:04.600 --> 13:06.120
cult加加

13:06.120 --> 13:08.080
那么会不会导致重新运行改成了

13:08.080 --> 13:09.600
也不会

13:09.600 --> 13:11.840
然后再往一上显示个cult

13:11.840 --> 13:15.750
h2cult

13:15.750 --> 13:18.870
你看点击cult加加

13:18.870 --> 13:19.630
刷新

13:19.630 --> 13:20.630
cult加加

13:20.630 --> 13:22.470
有没有重新运行那个计算属性

13:22.470 --> 13:23.270
得到计算属性

13:23.270 --> 13:24.230
有没有重新运行

13:24.230 --> 13:24.830
没有

13:24.830 --> 13:27.110
因为你没有改动它的什么依赖相

13:27.150 --> 13:29.070
是不是非常智能

13:29.070 --> 13:30.390
我以为它非常智能的知道

13:30.390 --> 13:31.390
我这个东西

13:31.390 --> 13:32.470
要它的纸

13:32.470 --> 13:33.710
纸依赖这两个东西

13:33.710 --> 13:34.710
只要这两个不变

13:34.710 --> 13:38.230
我就一直用缓存的结果

13:38.230 --> 13:39.670
那就比方法的效率要高

13:39.670 --> 13:40.550
对不对

13:40.550 --> 13:40.710
好

13:40.710 --> 13:41.270
那么

13:41.270 --> 13:42.310
那除非什么情况

13:42.310 --> 13:43.350
我改动这两个

13:43.350 --> 13:44.590
比方说去改动这两个吧

13:44.590 --> 13:45.550
你给我一个全名

13:45.550 --> 13:46.670
那我就用制服刷品

13:46.670 --> 13:49.190
制服刷分割以下

13:49.190 --> 13:50.150
制服刷的第一项

13:50.150 --> 13:51.310
就是first name

13:51.310 --> 13:53.510
first name有什么制服刷的第一项

13:53.510 --> 13:55.230
subscribe

13:55.350 --> 13:55.950
就第一项吧

13:57.790 --> 13:58.230
然后呢

13:58.230 --> 13:58.990
last name

13:58.990 --> 14:00.870
就是后边的东西

14:00.870 --> 14:01.390
subscribe stream

14:02.430 --> 14:03.990
从下标为一开始

14:03.990 --> 14:04.310
对不对

14:04.310 --> 14:05.310
重新设置first name

14:05.310 --> 14:06.430
重新设置 last name

14:06.430 --> 14:07.270
那这两个一改

14:07.270 --> 14:08.270
千变一重新选的

14:08.270 --> 14:10.590
一重新选的重新读去计算属性

14:10.590 --> 14:11.110
也计算属性

14:11.110 --> 14:12.510
因为发现这两个已经改了

14:12.510 --> 14:13.550
不能再用缓存了

14:13.550 --> 14:14.910
那么重新运行一次

14:14.910 --> 14:15.950
得到新的东西

14:15.950 --> 14:16.790
重新再缓存

14:17.990 --> 14:19.110
明白的意思吧

14:19.110 --> 14:19.270
好

14:19.270 --> 14:20.510
咱们来看

14:20.510 --> 14:21.630
点击

14:21.630 --> 14:22.790
一样

14:22.790 --> 14:24.110
不仅把first name

14:24.110 --> 14:25.270
而那三个名设置的

14:25.270 --> 14:25.790
同时呢

14:26.950 --> 14:28.030
计算属性也掉了

14:28.030 --> 14:28.750
又重新掉了

14:28.750 --> 14:29.430
哪一次

14:29.430 --> 14:30.990
又缓存起来了

14:30.990 --> 14:31.510
没了一转

14:31.510 --> 14:32.670
就这就是计算属性

14:34.390 --> 14:35.670
其实并不复杂

14:35.670 --> 14:36.310
那么我们来看一下

14:36.310 --> 14:37.430
这个辨识体该怎么回答

14:37.430 --> 14:38.670
我给他读一次

14:38.670 --> 14:40.590
计算属性的方法有什么区别呢

14:40.590 --> 14:42.750
计算属性本质上

14:42.750 --> 14:44.270
我刚才说刚才是全线

14:44.270 --> 14:44.830
减线的话

14:44.830 --> 14:46.430
就如果说你只有get的话

14:46.430 --> 14:47.950
平时最大部分情况下

14:47.950 --> 14:49.750
99%的情况

14:49.750 --> 14:51.870
计算属性一般只有get

14:51.870 --> 14:52.990
很少去使用set

14:53.950 --> 14:54.950
那么只有get的情况

14:54.950 --> 14:56.270
你可以直接把它写成个函数

14:56.270 --> 14:57.270
它只有get

14:57.270 --> 14:58.470
来看一下

14:58.470 --> 14:59.590
计算属性本质上的

14:59.590 --> 15:00.470
就是包含一个get

15:00.470 --> 15:01.470
还有setter

15:02.470 --> 15:03.830
当获取计算属性的时候

15:03.830 --> 15:05.990
实际上是在调用计算属性的相应的方法

15:05.990 --> 15:06.430
对吧

15:06.430 --> 15:07.870
获取就是调用get

15:07.870 --> 15:09.030
设置的就是调用get

15:09.030 --> 15:10.150
setter

15:10.150 --> 15:10.990
很少去设置

15:11.910 --> 15:14.350
为用了它会收集计算属性的依赖

15:14.350 --> 15:15.590
比方它运行get的时候

15:15.590 --> 15:17.030
在读这个计算属性的时候

15:17.030 --> 15:18.510
它在调用get

15:18.510 --> 15:20.070
那么它可以看一下

15:20.070 --> 15:21.590
我地边以一代什么数据

15:21.590 --> 15:22.950
一代这两个数据

15:23.150 --> 15:24.270
它就会往收集起来

15:24.270 --> 15:25.630
将来只要这两个数据不变

15:25.630 --> 15:26.950
我就一直使用缓存

15:27.590 --> 15:28.830
只要这两个数据变了

15:28.830 --> 15:29.830
我就不使用缓存了

15:30.630 --> 15:31.830
它有这么一个特点

15:32.630 --> 15:35.270
缓存计算属性的返回结果

15:35.270 --> 15:37.670
只有一代向变化后才会重新计算

15:37.670 --> 15:39.630
当然你不是说让你去背这个面试题

15:40.190 --> 15:41.710
千万不要背你背不住的

15:41.710 --> 15:43.110
你背得住就省线了

15:43.110 --> 15:44.470
因为我们面试题很多

15:44.470 --> 15:45.750
一定要理解它的关键点

15:45.750 --> 15:47.150
要用自己的话表达出来

15:47.150 --> 15:48.430
所以理解很重要

15:49.310 --> 15:50.390
理解到心里边的话

15:50.390 --> 15:51.470
你其实不会忘记的

15:51.470 --> 15:52.710
你知道它是怎么回事了

15:52.750 --> 15:56.630
只是要用一个语言把它表达出来而已

15:57.750 --> 15:58.830
方法就没有缓存

15:58.830 --> 16:00.670
你每一次调整方法都会重新执行

16:00.670 --> 16:01.590
我们之前看到过

16:01.590 --> 16:01.790
对吧

16:01.790 --> 16:02.590
在这里调整方法

16:02.590 --> 16:03.870
每一次调整都会重新执行

16:04.750 --> 16:06.830
计算属性的Gate set参数固定的

16:07.390 --> 16:09.710
你看这里是不是Gate是没有参数的

16:10.550 --> 16:11.870
Set上的只有一个参数

16:11.870 --> 16:14.510
参数固定的方法参数是补线的

16:14.510 --> 16:15.470
无论你看方法

16:15.830 --> 16:17.110
刚才我们写过一个方法

16:17.110 --> 16:17.990
它参数可以没有

16:17.990 --> 16:19.150
也可以有多个无所谓的

16:20.150 --> 16:21.510
由于有以上的区别

16:21.590 --> 16:23.870
所以说我们在开发过程中

16:23.870 --> 16:24.950
计算属性用来做什么的

16:24.950 --> 16:26.750
通常是根据已有的东西

16:26.750 --> 16:27.950
得到一个新的东西

16:28.630 --> 16:29.830
并在得到数据的过程中

16:29.830 --> 16:31.110
不建议使用异部

16:31.310 --> 16:33.750
当前时间水积数等副作用操作

16:33.990 --> 16:34.910
为什么不建议

16:36.430 --> 16:37.310
为什么不建议

16:38.270 --> 16:39.910
因为它只会运行一次

16:40.910 --> 16:42.510
我下举个例子

16:42.790 --> 16:44.030
比方说Full Name里面

16:44.030 --> 16:45.950
后面加上一个当前时间的时间戳

16:45.950 --> 16:46.990
随便下举个例子

16:46.990 --> 16:48.990
这个例子也太搞笑了

16:49.430 --> 16:51.270
比方说加这个东西

16:51.590 --> 16:53.350
那么你能保证它每一次

16:53.910 --> 16:55.430
都是用的当前时间

16:55.430 --> 16:56.590
不是它又缓存

16:57.230 --> 16:58.350
分析它又缓存

16:59.550 --> 17:00.110
没啥意思吧

17:00.110 --> 17:01.670
比方说你改动了一些东西过后

17:02.030 --> 17:03.750
这个时间还是之前的时间

17:04.310 --> 17:05.910
比方说我们这里

17:07.430 --> 17:08.510
比方说一个Cult

17:08.510 --> 17:10.390
Cult我们写一个按钮

17:12.840 --> 17:13.600
Cult加加

17:15.960 --> 17:16.640
这里

17:16.640 --> 17:18.320
这很多时候会造成一些困扰

17:20.320 --> 17:21.400
你看这个数据变了

17:21.400 --> 17:22.160
这个数据变吗

17:22.320 --> 17:22.880
不变

17:23.400 --> 17:23.920
对不对

17:24.120 --> 17:24.880
有的人说不对

17:24.880 --> 17:27.080
它当前时间不是一直在变化吗

17:27.080 --> 17:27.920
这个东西一变化

17:27.920 --> 17:28.880
不是依赖相变了吗

17:28.880 --> 17:30.360
依赖相变了不得重新计算吗

17:30.720 --> 17:31.120
主义

17:31.120 --> 17:32.440
它的计算的依赖项

17:32.440 --> 17:34.080
只有响应式数据

17:34.640 --> 17:36.080
因为我们知道注入的过程中

17:36.080 --> 17:37.440
这个东西是不是有响应式

17:37.440 --> 17:38.760
你改动它会受到通知

17:38.760 --> 17:39.360
你改动

17:39.360 --> 17:40.720
这个当前时间变了过后

17:40.720 --> 17:41.800
无忧能不能受到通知

17:41.800 --> 17:43.000
它是受不到通知的

17:43.400 --> 17:45.880
只有那些响应式数据变化过后

17:45.880 --> 17:47.040
它才能受到通知

17:47.040 --> 17:47.920
是这么一回事

17:48.360 --> 17:49.120
说这个东西

17:49.120 --> 17:50.680
你最好不要在计算数据里面用

17:51.040 --> 17:51.920
它有什么随技术

17:51.920 --> 17:54.160
因为它只计算一次就缓存下来了

17:54.560 --> 17:55.720
那么没有办法保证

17:55.720 --> 17:57.920
每一次都会用的是新的随技术

17:58.080 --> 17:58.720
所以说这些东西

17:58.720 --> 17:59.720
就尽量不要用

17:59.880 --> 18:01.040
这些负重用操作

18:01.200 --> 18:02.360
什么负重用操作

18:02.720 --> 18:03.480
什么是负重用

18:03.480 --> 18:05.360
就是对外部造成影响的

18:06.200 --> 18:08.120
不可预计的操作

18:08.160 --> 18:09.280
就是负重用操作

18:10.520 --> 18:11.400
包括什么

18:11.400 --> 18:12.200
包括什么

18:12.200 --> 18:13.040
异部

18:13.040 --> 18:15.120
像这个东西根本不能做成异部含书

18:15.120 --> 18:16.800
这异部也不能在这里边去使用

18:17.120 --> 18:17.840
别的意思吧

18:18.040 --> 18:19.200
因为它有缓存

18:19.200 --> 18:21.360
广望会造成一些不可预调的结果

18:21.920 --> 18:23.320
所以说计算数据我们往往就是

18:23.320 --> 18:25.160
根据以后数据就得到新的数据了

18:25.400 --> 18:26.520
没有什么别的东西

18:26.520 --> 18:28.200
可能需要一个段的计算过程

18:28.800 --> 18:29.720
好这是这一部分

18:30.920 --> 18:32.680
实际上他们两个最重要的区别

18:32.680 --> 18:34.800
还不是在这种技术上的区别

18:34.800 --> 18:36.080
是含义上的区别

18:36.800 --> 18:38.480
就是你们开发到了一进阶段过后

18:38.480 --> 18:39.360
特别特别

18:39.920 --> 18:41.920
会特别在乎含义的区别

18:42.160 --> 18:43.480
因为含义代表什么

18:43.600 --> 18:45.320
代表你写代表的逻辑

18:46.480 --> 18:47.400
含义上的区别是什么

18:47.400 --> 18:48.640
计算属性是数据

18:48.760 --> 18:49.960
含义上是一个数据

18:49.960 --> 18:53.000
你看信名全名

18:53.000 --> 18:54.040
不都是数据吗

18:54.040 --> 18:55.520
只不过全名是和信

18:55.520 --> 18:57.880
是由信和名计算出来的

18:58.720 --> 19:00.240
看不看这个含义非常明确

19:00.600 --> 19:01.640
既然是数据

19:01.640 --> 19:03.560
那个数据可以读取也可以复制

19:03.560 --> 19:05.040
对吧读取就是setter

19:05.440 --> 19:06.440
复制就是setter

19:07.280 --> 19:09.040
而方法的含义是不是数据

19:09.280 --> 19:10.720
方法的含义根本就不是数据

19:10.720 --> 19:12.080
它是一个操作

19:12.520 --> 19:14.280
用于处理一些事情

19:14.400 --> 19:15.480
你看我们方法的命名

19:15.480 --> 19:17.400
都是get是动辞对吧

19:17.440 --> 19:18.680
得到什么什么

19:19.200 --> 19:20.920
设置什么什么

19:21.160 --> 19:21.720
对不对

19:22.040 --> 19:23.360
是玩含义都不一样的

19:24.040 --> 19:24.720
没啥意思吧

19:24.720 --> 19:26.440
这就是以后面试的

19:26.440 --> 19:27.880
就可以从这两个方面回答

19:27.880 --> 19:28.920
一个是从技术上的

19:28.920 --> 19:30.120
一个是从含义上的回答

19:30.120 --> 19:31.240
就非常非常全面

19:32.120 --> 19:33.280
好这是计算属性

19:33.400 --> 19:35.080
那么我们学了计算属性过后

19:35.080 --> 19:36.640
接下来我们就开始来做

19:37.720 --> 19:38.760
图标组建了

19:39.000 --> 19:40.320
我把这个玩意儿复制一下

19:41.720 --> 19:42.920
这东西就删除掉

19:46.450 --> 19:47.650
好来做个图标组建

19:47.650 --> 19:48.930
我们在component里边

19:48.970 --> 19:50.090
新建一个文件

19:50.090 --> 19:50.850
叫做icon

19:55.760 --> 19:56.440
好首先

19:56.440 --> 19:57.960
让我们来看一下图标组建

19:58.280 --> 19:59.040
要做一个图标

19:59.040 --> 20:00.320
我们以前是咋做的

20:00.600 --> 20:01.760
我们这里是字体图标

20:01.760 --> 20:03.000
不是什么学毕图

20:03.960 --> 20:05.080
我们要做图标以前是咋做的

20:05.080 --> 20:06.880
是不是要用一个icon font

20:07.440 --> 20:07.840
对不对

20:07.840 --> 20:08.760
是要用这个玩意儿

20:09.160 --> 20:11.040
我这里已经新建了一个项目了

20:11.040 --> 20:12.480
你们那边也可以新建个项目

20:12.720 --> 20:13.920
也可以直接用我的

20:14.400 --> 20:15.080
新建一个项目

20:15.080 --> 20:16.240
就是mysite这个项目

20:16.400 --> 20:17.840
这里边我已经加入了

20:17.840 --> 20:19.920
我这个网站里边有可能会用到的一些图标

20:19.920 --> 20:20.800
全部加入进来了

20:21.600 --> 20:22.920
我们希望把它封装一下

20:22.960 --> 20:23.920
封装成一个图建

20:24.880 --> 20:26.360
那么我们做图建的时候

20:26.360 --> 20:26.880
其实

20:27.760 --> 20:29.200
我们首先要可以考虑一下

20:29.200 --> 20:30.800
这个图建怎么样用则爽

20:32.360 --> 20:33.760
怎么样用则爽我就怎么来

20:34.440 --> 20:35.640
怎么样用则爽了

20:35.800 --> 20:37.960
我希望了就最好这样子用就最爽

20:37.960 --> 20:38.840
比方说这个图标

20:39.240 --> 20:40.080
这个首页图标

20:40.080 --> 20:41.800
我就这样子可以这样子使用最爽

20:42.480 --> 20:43.280
一个icon

20:44.240 --> 20:45.720
我给你加上一个属性

20:45.720 --> 20:46.160
type

20:46.600 --> 20:47.320
类型是什么

20:47.320 --> 20:48.360
首页

20:48.360 --> 20:49.600
这个图标就显示出来了

20:50.120 --> 20:50.960
是不是用的很爽

20:51.400 --> 20:53.520
主建就是为了让我们开发方便的

20:53.840 --> 20:55.280
把它封装过后开发就非常发展

20:55.280 --> 20:56.120
非常方便的

20:56.680 --> 20:58.160
那么我们就按照这种模式来做

20:58.440 --> 20:59.760
因此它是不是得有个属性

21:00.120 --> 21:00.480
type

21:02.560 --> 21:03.560
得有个属性type

21:03.560 --> 21:04.560
你给我一个类型

21:11.250 --> 21:12.850
属性名字叫什么type

21:13.490 --> 21:14.370
那么属性的类型

21:15.570 --> 21:16.530
叫是一个stream

21:17.810 --> 21:18.970
属性类型是不是一个stream

21:18.970 --> 21:19.330
注意一下

21:19.330 --> 21:20.570
这个type跟这个type不一样

21:20.890 --> 21:22.570
这个type是我们的属性名字

21:23.210 --> 21:26.050
这个type是属性的类型

21:26.610 --> 21:27.930
好像写的是一样

21:27.930 --> 21:28.810
但是含义不一样

21:30.210 --> 21:31.130
没有默认值

21:31.130 --> 21:32.130
你必须要给我传递

21:32.130 --> 21:33.210
你要用图标

21:33.210 --> 21:34.450
你得告诉我图标类型

21:34.450 --> 21:35.370
你必须要传递

21:35.370 --> 21:35.690
对吧

21:35.690 --> 21:37.250
我们把属性设置一下

21:38.290 --> 21:38.770
好那么接下来

21:38.770 --> 21:40.170
我们来想一下这个主建的模板

21:40.170 --> 21:40.850
模板是什么

21:41.490 --> 21:43.250
因为我们都学过自己图标

21:43.250 --> 21:46.050
这些图标模板无非就是一个挨援书

21:46.050 --> 21:46.890
对吧

21:46.890 --> 21:48.290
比方说手页

21:48.290 --> 21:50.970
比方说手页

21:51.330 --> 21:51.970
手页

21:53.570 --> 21:54.250
复制一下

21:56.550 --> 21:57.350
挨援书

21:57.350 --> 21:59.070
它有个类样式icon font

21:59.070 --> 22:00.190
同时还有一个类样式

22:00.190 --> 22:01.790
就是图标的具体类样式

22:01.790 --> 22:03.110
是不是有两个类样式

22:03.110 --> 22:04.550
这个类样式是固定的

22:05.710 --> 22:07.710
这个类样式是不是有可能会变化

22:09.070 --> 22:09.390
对吧

22:09.390 --> 22:10.590
手页是这个类样式

22:10.590 --> 22:11.350
那么别的

22:12.550 --> 22:13.310
先这个样子写

22:13.310 --> 22:14.310
写出来再看一下

22:14.830 --> 22:15.790
我们在这里去

22:15.790 --> 22:17.110
没写个主建的时候

22:17.110 --> 22:18.150
那么一定要去测试

22:18.150 --> 22:18.830
反复测试

22:18.830 --> 22:19.310
没问题了

22:19.310 --> 22:20.190
过后再接上往前

22:20.190 --> 22:21.710
后面写icon

22:22.270 --> 22:23.190
那么注册一下

22:23.190 --> 22:24.070
conponent

22:27.070 --> 22:27.710
比方说

22:27.710 --> 22:29.230
我们这里加上一个icon

22:30.790 --> 22:31.310
保存

22:37.120 --> 22:38.160
这里必须要传个type数

22:39.360 --> 22:40.360
type比方说home

22:43.070 --> 22:43.390
保存

22:45.590 --> 22:46.630
没出来是吧

22:46.630 --> 22:48.630
但是我们的元素有没有

22:48.630 --> 22:49.670
元素肯定是有的

22:49.670 --> 22:50.470
你看

22:50.470 --> 22:51.390
I元素是不是出来了

22:52.550 --> 22:52.870
对不对

22:54.230 --> 22:55.550
那么现在问题在哪呢

22:55.550 --> 22:57.350
问题为什么没有显示出来了

22:57.350 --> 22:58.750
是因为我们没有用央式

22:58.750 --> 22:58.990
对不对

22:58.990 --> 23:00.710
央式上是不是要导入CSS

23:01.430 --> 23:01.870
对吧

23:01.870 --> 23:03.030
那么CSS在哪里导入呢

23:03.030 --> 23:03.990
我们可以就在这边

23:04.750 --> 23:05.950
就在这个style里面导入

23:06.870 --> 23:07.870
那么同样的道理

23:07.870 --> 23:08.950
为了避免央式重名

23:08.950 --> 23:09.910
我们加上一个scout

23:10.470 --> 23:11.310
导入这个类样式

23:11.870 --> 23:12.430
导入类样式

23:12.430 --> 23:13.150
过后我们这里

23:13.950 --> 23:14.910
使用icon

23:15.590 --> 23:17.430
首先导入这个import

23:18.030 --> 23:18.910
用这种方式来导入

23:19.750 --> 23:21.070
导入CSS导入进来

23:22.670 --> 23:23.550
你看这个CSS

23:23.550 --> 23:24.910
它是没有写写一名的

23:25.030 --> 23:26.910
就是使用当前网站的协议

23:26.910 --> 23:28.550
当前网站的是addp

23:28.550 --> 23:29.630
我们这里是addp

23:29.630 --> 23:31.110
那么它这里就是addp协议

23:31.670 --> 23:32.390
导入进来

23:33.030 --> 23:34.510
导入进来过后其实还有啥

23:34.510 --> 23:35.390
其实也没啥了

23:36.270 --> 23:36.830
保存

23:36.830 --> 23:37.430
然后呢

23:37.430 --> 23:38.190
这边你看

23:38.190 --> 23:39.070
图标是不是出来了

23:39.070 --> 23:39.790
首页图标

23:41.150 --> 23:41.270
好

23:41.270 --> 23:42.910
那如果说我们要换一个图标呢

23:42.910 --> 23:44.990
比方说我们要换成这个文章

23:44.990 --> 23:46.430
文章的话我们换成

23:46.830 --> 23:48.350
比方说我们换成另外一个类型

23:48.350 --> 23:48.870
block

23:48.870 --> 23:49.430
block

23:50.230 --> 23:50.710
博客

23:51.390 --> 23:52.710
或者是article文章

23:52.710 --> 23:53.270
都行

23:53.270 --> 23:53.630
好

23:53.630 --> 23:54.190
保存

23:55.070 --> 23:55.790
这里有换吗

23:56.990 --> 23:58.110
它有换就见鬼了

23:58.110 --> 23:59.270
为什么没有换啊

24:00.030 --> 24:01.230
你现在传这个属性

24:01.630 --> 24:02.670
跟这边有关系吗

24:02.670 --> 24:04.350
跟这边模板里面显示有关系吗

24:04.830 --> 24:06.030
一点关系都没有

24:06.030 --> 24:07.710
模板里面这个位置

24:07.710 --> 24:09.310
它模板里面显示什么图标

24:09.310 --> 24:10.550
所以取决于这个类样式

24:11.830 --> 24:12.350
看到没

24:12.350 --> 24:13.550
那这个类样式是静态的

24:13.550 --> 24:14.190
没有变化

24:14.190 --> 24:14.910
那肯定不行

24:15.790 --> 24:18.710
所以说我们这个图标这个组建里面

24:18.710 --> 24:19.950
有个地方是动态的

24:19.950 --> 24:21.150
就它的类样式

24:21.150 --> 24:22.030
是不是动态的

24:22.030 --> 24:24.670
我们上去是不见过那个style是动态的

24:24.750 --> 24:25.870
那么类样式

24:26.550 --> 24:27.710
也可以是动态的

24:28.110 --> 24:28.990
那怎么办呢

24:29.510 --> 24:31.150
维又队那个类样式

24:31.150 --> 24:32.630
它也有它的特殊处理

24:33.470 --> 24:35.470
所以也可以去绑定的样式

24:35.470 --> 24:36.830
绑定的写法

24:36.830 --> 24:37.830
类样式里面写什么呢

24:37.830 --> 24:41.190
昨天我们上节课我们style里面写的是一个对象

24:41.190 --> 24:41.830
对吧

24:41.830 --> 24:43.350
class能不能写对象呢

24:43.350 --> 24:44.070
可以

24:44.070 --> 24:45.670
class有很多种写法

24:47.070 --> 24:48.750
class里面有很多种写法

24:49.350 --> 24:50.590
可以写制服串

24:50.590 --> 24:51.990
你可以在这里面写制服串

24:51.990 --> 24:53.030
比方说我们再写一个

24:53.030 --> 24:53.950
写个制服串

24:55.110 --> 24:56.150
比方说吧

24:56.150 --> 24:57.150
我们写一个什么

24:58.150 --> 24:58.830
写个留言

24:58.830 --> 24:59.550
复制一下

25:00.110 --> 25:01.270
把制服串放过来

25:02.510 --> 25:03.390
保存

25:04.590 --> 25:05.230
你看

25:05.230 --> 25:06.590
它是不是有两个类样式的

25:06.590 --> 25:07.790
它会自动给你合并

25:07.790 --> 25:10.870
把动态的类样式和静态的类样式进行合并

25:10.870 --> 25:11.910
你看是不是icon放置

25:11.910 --> 25:13.350
加上动态的类样式

25:14.310 --> 25:14.830
对吧

25:14.830 --> 25:16.310
那么这边也可以写别的

25:16.830 --> 25:17.470
也可以写的

25:17.470 --> 25:18.950
比方说MT

25:20.070 --> 25:20.630
保存

25:21.310 --> 25:22.150
你看这边

25:23.150 --> 25:23.710
是不是

25:24.190 --> 25:25.350
它会给你合并

25:25.350 --> 25:26.790
这是用制服串的写法

25:26.790 --> 25:27.950
也可以用对象的写法

25:27.950 --> 25:29.150
也可以用数组的写法

25:29.150 --> 25:30.750
有很多种写法

25:30.750 --> 25:31.590
那么这里呢

25:31.590 --> 25:32.830
我给大家这个地方

25:32.830 --> 25:33.830
因为它很简单

25:33.830 --> 25:34.590
并不难

25:34.590 --> 25:36.790
所以说我这里记录一下

25:37.990 --> 25:38.870
这个vband

25:40.780 --> 25:42.260
除了style里面还有class

25:42.260 --> 25:43.460
它也是比较特殊的

25:43.460 --> 25:45.700
它可以绑定制服串

25:45.700 --> 25:48.260
也可以绑定一个对象

25:49.780 --> 25:51.660
一个对象

25:51.660 --> 25:53.140
还可以绑定一个数组

25:53.140 --> 25:54.420
一个数组

25:54.540 --> 25:55.860
那么看一下详情

25:55.860 --> 25:57.420
那么每个东西是什么呢

25:57.420 --> 25:59.020
你可以看一下这个网站

25:59.020 --> 25:59.900
我给大家一个链接

26:05.100 --> 26:05.780
教程

26:05.780 --> 26:07.180
而且会看文档

26:07.180 --> 26:07.740
同学们

26:09.100 --> 26:11.300
我现在给你们看的都是不难的

26:11.300 --> 26:11.940
都不难的

26:11.940 --> 26:13.780
非常简单的

26:13.780 --> 26:15.300
也看一下这个文档

26:15.300 --> 26:16.340
如果说实在看不懂的话

26:16.340 --> 26:17.500
将来反正我们用到的地方了

26:17.500 --> 26:18.420
也会给大家解释

26:22.320 --> 26:23.320
给大家加一个链接

26:24.480 --> 26:25.120
链接

26:27.320 --> 26:28.320
插入

26:28.320 --> 26:28.920
插链接

26:31.960 --> 26:32.720
点这个地方

26:32.720 --> 26:33.560
就可以打开这个

26:34.120 --> 26:34.560
这个地方了

26:34.560 --> 26:35.120
去看一下

26:35.120 --> 26:36.200
就看这一节就行了

26:36.200 --> 26:37.600
绑定ATM class

26:37.600 --> 26:38.720
绑定那样式

26:38.720 --> 26:40.200
这有很多种写法

26:40.200 --> 26:42.320
那么我们目前倒是用不到的一些写法

26:42.320 --> 26:44.240
我们只需要用到这个字不串

26:44.240 --> 26:45.400
就这个字不串是动态的

26:45.400 --> 26:45.720
对吧

26:46.960 --> 26:47.520
想一想

26:48.600 --> 26:52.240
这个字不串写什么比较好

26:52.240 --> 26:53.960
有人说到这个地方很不简单吗

26:53.960 --> 26:54.920
这些写Type

26:54.920 --> 26:56.160
对不对

26:56.160 --> 26:57.400
Type不挺好的吗

26:57.400 --> 26:58.680
绑定这个数项

26:58.680 --> 27:00.360
那么你这边传递的时候

27:00.360 --> 27:00.920
一边怎么传

27:00.920 --> 27:02.240
是不是把那样式传过去

27:03.440 --> 27:04.600
所以一传这个不认识的

27:04.600 --> 27:06.320
他肯定是那就不行

27:06.320 --> 27:07.280
他现在显示不出来

27:07.280 --> 27:08.560
你看埃康放置Blog

27:08.560 --> 27:09.440
肯定显示不出来

27:09.440 --> 27:10.320
你要传他认识的

27:10.320 --> 27:12.280
比方说你传这个下箭头

27:12.280 --> 27:13.080
复制一下

27:13.080 --> 27:17.300
那么你这边给他传过去

27:17.300 --> 27:18.740
这边是下箭头吧

27:18.740 --> 27:20.340
挺好的呀

27:20.340 --> 27:20.860
好吗

27:22.220 --> 27:22.500
好吗

27:22.500 --> 27:23.420
你看这个玩意是啥呀

27:24.860 --> 27:25.900
现在呢

27:25.900 --> 27:28.140
一个小的问题就是

27:29.380 --> 27:32.180
代码可阅读性集差

27:32.180 --> 27:34.660
因为你给他传的是那样式

27:34.700 --> 27:36.340
这个那样式在埃康放置里面

27:36.340 --> 27:37.860
是不是千奇百怪的那样式

27:37.860 --> 27:38.380
对吧

27:38.380 --> 27:40.020
这些都是网友上传的

27:40.020 --> 27:41.340
那样式千奇百怪的

27:42.940 --> 27:44.420
那么我们最好是传递的时候

27:44.420 --> 27:46.100
我们希望的就是

27:46.100 --> 27:47.780
我说一下我们希望的是什么

27:47.780 --> 27:49.180
下箭头比方说我们希望的是

27:49.180 --> 27:50.580
传一个有意义的东西

27:50.580 --> 27:52.260
Iron

27:52.260 --> 27:52.860
对吧

27:52.860 --> 27:53.340
Iron什么

27:53.340 --> 27:53.900
箭头

27:53.900 --> 27:55.660
Dong就是向下的

27:55.660 --> 27:57.260
这样子是不是特别好阅读

27:57.260 --> 27:58.020
我希望了

27:58.020 --> 28:00.060
这传这个东西的时候呢

28:00.060 --> 28:01.860
他就给我转换成这个那样式

28:01.860 --> 28:02.660
绑定进去

28:03.540 --> 28:04.860
明儿的意思吧

28:04.860 --> 28:05.940
我现在做这个转换

28:07.660 --> 28:08.900
这不复杂吧

28:08.900 --> 28:09.740
这个玩意

28:09.740 --> 28:11.060
这样的我们看上去有好看

28:11.060 --> 28:11.340
对吧

28:11.340 --> 28:12.060
效果有达到了

28:12.060 --> 28:12.980
这是最好的

28:12.980 --> 28:13.900
我们这样子

28:13.900 --> 28:15.420
我们在使用这个组件的时候

28:15.420 --> 28:16.900
就不用在脑袋里面去记得

28:16.900 --> 28:18.020
一些乱七八糟的那样式

28:18.020 --> 28:18.980
那个那样式太乱了

28:20.020 --> 28:20.420
而且呢

28:20.420 --> 28:21.380
将来呢

28:21.380 --> 28:22.340
很好替换

28:22.340 --> 28:24.860
比方说我们在这里面

28:24.860 --> 28:25.900
我们想改一下那样式

28:25.900 --> 28:27.660
比方说我们现在的Iron

28:27.660 --> 28:28.100
Dong

28:28.100 --> 28:29.460
就下箭头是这个那样式

28:29.460 --> 28:30.260
将来我们可能是

28:30.260 --> 28:31.300
这个下箭头不好看

28:31.340 --> 28:32.620
我们可能要换一个下箭头

28:33.620 --> 28:34.500
那么那样式一变

28:34.500 --> 28:35.140
但是呢

28:35.140 --> 28:36.380
并不影响这边的带

28:36.380 --> 28:37.380
这边还是用IronDong

28:38.300 --> 28:38.820
懂的意思吧

28:40.260 --> 28:42.820
所以说现在我们是不是要做一个映射呀

28:42.820 --> 28:44.620
把我们一个正常的名字

28:44.620 --> 28:46.660
映射成为一个那样式

28:46.660 --> 28:47.380
那怎么映射呢

28:48.020 --> 28:49.300
不要想复杂了

28:49.300 --> 28:50.780
不要想复杂了

28:50.780 --> 28:51.220
接下来呢

28:51.220 --> 28:52.700
我们来看一下我们客间里面

28:52.700 --> 28:53.540
图标这一块

28:55.800 --> 28:56.520
一样式链间

28:56.520 --> 28:57.640
你们可以就用我这个

28:57.640 --> 28:59.440
也肯定你们自己去加无所谓的

29:00.560 --> 29:01.640
你直接写

29:01.640 --> 29:03.360
我在这里就非常粗暴的

29:03.360 --> 29:04.920
处理的一种方式

29:04.920 --> 29:07.760
我就直接写了一个classmap

29:07.760 --> 29:08.880
一个映射的对象

29:09.560 --> 29:11.120
前边是正常的名字

29:11.120 --> 29:12.960
后边是那样式的名字

29:12.960 --> 29:13.760
你传的话

29:13.760 --> 29:14.960
你给我传正常的名字

29:14.960 --> 29:15.800
我就给你得到了

29:15.800 --> 29:16.600
是那样式的名字

29:16.600 --> 29:17.760
是不是写个映射就完事了

29:19.160 --> 29:20.480
然后我要做的是啥事

29:20.480 --> 29:21.000
啥事啊

29:22.760 --> 29:23.720
等下我手机关一下

29:31.160 --> 29:33.160
然后要做的事情就一件

29:33.160 --> 29:35.600
我要根据你给我传的属性

29:35.600 --> 29:37.240
属性是正常的这个东西

29:37.440 --> 29:38.560
正常的图标内象

29:39.880 --> 29:41.360
我要根据属性

29:41.360 --> 29:46.200
得到这个正常内形对应的内样式

29:46.200 --> 29:47.560
是不是我们可以用computed

29:48.920 --> 29:49.800
所以可以计判属性

29:49.800 --> 29:50.880
这几个我们计判属性

29:50.880 --> 29:51.880
就用这么一个调教

29:52.880 --> 29:53.400
那怎么写

29:53.400 --> 29:55.480
那比方说我们得到class name

29:56.440 --> 29:56.800
对吧

29:57.680 --> 29:59.280
或者是fence class都行

30:00.480 --> 30:01.480
水面区个名什么名字

30:02.320 --> 30:03.440
图标的内样式

30:03.960 --> 30:05.480
图标内样式

30:07.360 --> 30:08.080
怎么算出来的

30:08.080 --> 30:09.160
这是个计算属性吧

30:09.160 --> 30:09.960
怎么算出来的

30:10.600 --> 30:13.560
你根据他用他作为属性名

30:13.560 --> 30:15.720
是不是从这个对象里面去取他的属性值

30:16.640 --> 30:16.800
对吧

30:16.800 --> 30:18.320
你传到home我就取这个

30:18.320 --> 30:19.800
你传这个arrow我就取这个

30:20.960 --> 30:21.440
对吧

30:21.440 --> 30:22.360
那么我们来看一下啊

30:22.360 --> 30:23.880
这怎么怎么弄啊

30:23.880 --> 30:25.000
return什么呢

30:25.000 --> 30:26.200
class map

30:27.800 --> 30:29.760
第二属性名字

30:29.760 --> 30:31.360
Z is your type

30:33.760 --> 30:34.960
属性我们之前说过

30:34.960 --> 30:37.120
也会注入到实地里面去

30:37.120 --> 30:37.960
所以Z is your type

30:39.600 --> 30:40.400
而且这个

30:40.400 --> 30:41.680
这个东西是不是跟这个

30:41.680 --> 30:43.360
他产生一代了

30:43.360 --> 30:44.880
他编了那么他就会编

30:44.880 --> 30:46.480
那么我们只需要把这个

30:46.480 --> 30:48.120
计算属性放到这

30:48.120 --> 30:49.120
fence class

30:50.240 --> 30:51.800
所以就很好解决这个问题了

30:51.800 --> 30:52.920
那么这样子我们来看啊

30:52.920 --> 30:54.920
arrow-down下箭头

30:55.960 --> 30:56.800
可以出现了下箭头

30:57.720 --> 30:58.440
你看为什么

30:58.440 --> 30:59.840
arrow-down传过去

30:59.840 --> 31:00.720
那么这边

31:00.720 --> 31:03.160
i-con里边是不是根据arrow-down

31:03.160 --> 31:04.320
就找到了这个

31:04.320 --> 31:05.360
这个的样式

31:05.360 --> 31:06.440
那么这个的样式就放到这了

31:07.440 --> 31:09.440
将来有一天这个特别好维护啊

31:09.440 --> 31:10.240
将来有一天我觉得

31:10.240 --> 31:12.240
哎这个下箭头不是很好看

31:12.240 --> 31:13.000
我换一个下箭头

31:13.000 --> 31:13.920
那样是一遍

31:13.920 --> 31:14.800
那样是一遍

31:14.800 --> 31:15.760
需要改动这吗

31:15.760 --> 31:17.000
不需要

31:17.000 --> 31:17.920
使用的地方

31:17.920 --> 31:19.600
各种各种地方都在使用它

31:19.600 --> 31:20.520
但是不需要动

31:20.520 --> 31:22.240
我们只需要把这个地方一切换

31:23.240 --> 31:23.800
出去玩笑了

31:24.920 --> 31:25.440
对吧

31:25.440 --> 31:27.080
那么这就是非常好的一种做法啊

31:28.120 --> 31:28.480
好了吗

31:28.480 --> 31:30.320
我们现在这个写完了吗

31:31.760 --> 31:33.240
写完了吗

31:33.240 --> 31:33.920
现在这个玩意儿

31:34.920 --> 31:35.600
写完了吗

31:35.600 --> 31:36.800
好像也没有写完

31:38.000 --> 31:39.720
为什么说没有写完呢

31:42.680 --> 31:45.240
为什么说他这个玩意儿还没有写完呢

31:45.520 --> 31:48.240
是因为现在我们还是要一个问题

31:48.240 --> 31:50.000
这个图标怎么去控制它大小

31:51.040 --> 31:52.800
怎么去控制它的图标颜色

31:53.600 --> 31:55.560
因为我知道控制大小就是控制自己大小

31:55.920 --> 31:57.800
控制颜色就是控制字体颜色

31:57.800 --> 31:58.280
对吧

31:59.280 --> 32:00.640
那有可能还要

32:00.640 --> 32:02.240
可能会控制它的什么marting

32:02.440 --> 32:03.760
所以要控制的东西很多

32:05.840 --> 32:06.560
那怎么办呢

32:08.400 --> 32:09.120
现在呢

32:09.520 --> 32:10.920
为了解决这个问题

32:10.920 --> 32:11.720
你看啊

32:11.720 --> 32:12.960
这是这个组件

32:12.960 --> 32:14.800
现在一个问题就出现了

32:15.280 --> 32:16.280
我这个情况

32:16.280 --> 32:18.000
它的样式的情况比较多

32:18.000 --> 32:18.960
它可能有marting

32:18.960 --> 32:19.840
可能有pending

32:19.840 --> 32:21.680
可能有什么乱七八糟的玩意儿

32:21.680 --> 32:22.960
可能要display block

32:22.960 --> 32:25.280
可能要颜色变成红色

32:25.280 --> 32:27.680
可能要那个字体大小变成32个像素

32:27.680 --> 32:29.960
都有可能说不准它的样式是啥

32:30.760 --> 32:31.920
说不准它的样式是啥

32:32.560 --> 32:33.120
就是我这里

32:33.120 --> 32:34.400
如果说我在这里边控制

32:34.440 --> 32:35.680
这个组件内部控制

32:36.440 --> 32:37.320
已经不是很方便了

32:37.320 --> 32:38.600
我顶多这样子写一下

32:38.600 --> 32:39.600
icon font

32:40.400 --> 32:41.200
icon font

32:41.200 --> 32:42.440
我给他说写个

32:42.440 --> 32:43.400
color inherit

32:43.920 --> 32:45.280
计程上面的人的颜色

32:45.280 --> 32:46.400
font size

32:46.800 --> 32:47.440
inherit

32:47.840 --> 32:49.080
我顶多这样子写一下

32:49.080 --> 32:50.040
还能咋写呢

32:50.040 --> 32:50.960
我都不知道咋写了

32:50.960 --> 32:52.880
因为我不知道它要有什么样的控制

32:52.880 --> 32:53.680
懂我的意思吧

32:54.200 --> 32:57.560
我希望外面使用的人来控制它的样式

32:58.440 --> 32:59.160
这是一个问题

33:00.160 --> 33:01.480
那么现在问题在哪呢

33:01.480 --> 33:02.880
问题的根源在于

33:03.000 --> 33:05.120
我这边是在使用这个组件

33:05.120 --> 33:08.000
我怎么去控制这个组件内部的样式呢

33:08.440 --> 33:09.240
怎么去控制呢

33:10.840 --> 33:12.200
接下来我给大家看一张图

33:13.200 --> 33:14.720
无忧他想到了这个问题

33:16.320 --> 33:17.160
他怎么在做的呢

33:21.550 --> 33:23.390
比方说我有一个组件app

33:25.590 --> 33:27.630
它里边有个div那样式为a

33:27.630 --> 33:29.870
里边有一个指元素div那样式为b

33:29.870 --> 33:30.910
然后使用了一个指

33:30.910 --> 33:31.710
指组件

33:32.070 --> 33:33.350
然后一个那样式为c

33:34.230 --> 33:36.110
指组件里边呢有一个class为a

33:36.110 --> 33:36.830
class为b

33:36.830 --> 33:37.550
class为c

33:37.550 --> 33:39.150
因为我们知道这个那样式冲突

33:39.150 --> 33:40.150
我们之前怎么解决的

33:40.150 --> 33:41.790
是不是使用作用寓

33:42.390 --> 33:42.870
样式

33:42.870 --> 33:43.070
对吧

33:43.070 --> 33:44.310
待作用寓的样式

33:44.510 --> 33:45.030
你看这

33:45.350 --> 33:46.150
就加了一个sculpt

33:46.510 --> 33:49.630
那么app里边是不是也可以同样加一个style sculpt

33:54.390 --> 33:54.830
对不对

33:55.070 --> 33:56.030
也可以同样加这个

33:57.150 --> 33:58.430
现在问题是

33:58.590 --> 34:01.390
你每一个组件它有自己的样式

34:01.830 --> 34:04.510
为了跟别的组件不产生冲突

34:04.510 --> 34:05.390
它有自己的样式

34:05.550 --> 34:06.990
但是现在就出现一个问题

34:06.990 --> 34:08.830
我怎么来控制它的问题

34:09.790 --> 34:11.190
特别是这种现象的

34:11.190 --> 34:12.790
特别是在一些布局的时候

34:12.790 --> 34:13.550
特别常见

34:13.550 --> 34:14.750
我外一层的有个布局

34:14.750 --> 34:16.190
布局里边使用了一个组件

34:16.190 --> 34:16.950
但是呢

34:17.310 --> 34:18.310
根据我的布局

34:18.310 --> 34:20.110
你这个组件要稍微做一些调整

34:20.110 --> 34:22.110
要根据我的布局来做一些调整

34:22.590 --> 34:23.630
怎么去影响它

34:23.750 --> 34:25.190
那么我又考虑到这个问题

34:25.190 --> 34:26.230
你看它怎么来考虑的

34:26.990 --> 34:28.190
组件app里边

34:28.190 --> 34:29.030
注意听啊

34:29.030 --> 34:31.430
组件app里边这是一个非常非常小的细节

34:31.950 --> 34:33.510
有三个的样式abc

34:34.510 --> 34:35.910
ab会影响谁

34:35.910 --> 34:36.990
b会影响谁

34:36.990 --> 34:38.110
b会影响他

34:38.110 --> 34:38.910
看呗

34:38.910 --> 34:39.470
会影响他

34:39.470 --> 34:40.310
这没问题吧

34:40.910 --> 34:41.910
他不会影响其他

34:41.910 --> 34:43.510
你看他不会影响这个组件的b

34:44.510 --> 34:45.910
然后c会影响谁呢

34:45.910 --> 34:46.710
会影响他

34:46.710 --> 34:47.910
因为他加了scoped

34:48.110 --> 34:50.510
所以说他会影响自己

34:50.710 --> 34:52.310
他不会影响这个组件的c

34:53.310 --> 34:53.710
对吧

34:53.710 --> 34:54.710
我们知道加了scoped

34:54.710 --> 34:57.910
他就会为这些元素加上一个自定义的属性

34:58.310 --> 34:59.110
每个选择器

34:59.110 --> 35:00.910
会加上一个自定义属性的选择器

35:00.910 --> 35:02.310
他只会影响自己的东西

35:02.510 --> 35:03.710
他不会影响这个b和c

35:04.310 --> 35:05.310
但是

35:05.310 --> 35:06.510
没有考虑到

35:07.910 --> 35:08.910
我可能

35:09.710 --> 35:13.110
要多多少少对他的根元素要做一些影响

35:13.710 --> 35:15.710
那他适应我这边的布局

35:16.310 --> 35:17.310
因此呢

35:17.910 --> 35:20.510
对于这个选择器A

35:21.110 --> 35:22.910
他会影响到这边的根元素

35:23.710 --> 35:26.110
他除了影响自己的A之外

35:26.110 --> 35:27.910
还会影响到这边的根元素

35:31.610 --> 35:32.410
能理解吗

35:32.410 --> 35:33.810
他会影响到这边的根元素

35:34.010 --> 35:35.410
就是为了解决这个问题

35:36.210 --> 35:36.810
他不会

35:36.810 --> 35:38.210
也就是说我在这个组件里边

35:38.210 --> 35:39.210
副组件里边

35:40.410 --> 35:41.410
加上scoped

35:41.410 --> 35:44.210
最多最多就影响到执着件的根元素

35:45.010 --> 35:46.410
不会影响到后期的根元素

35:47.410 --> 35:48.610
也就是这边的根元素

35:48.610 --> 35:49.810
受到两个组件的影响

35:49.810 --> 35:50.610
他的样式

35:50.610 --> 35:52.010
除了自己之外

35:52.010 --> 35:53.210
自己可以影响他吗

35:53.610 --> 35:54.410
除了自己之外

35:54.410 --> 35:56.410
还受到副组件的影响

35:56.410 --> 35:58.210
副组件可以对根元素的样式

35:58.210 --> 35:59.210
做一些设置

35:59.210 --> 36:00.210
他是怎么做到的呢

36:00.210 --> 36:01.610
其实你看这个

36:01.610 --> 36:02.810
代码级一下就明白了

36:04.010 --> 36:04.410
刷新

36:07.500 --> 36:08.300
我这边没保存

36:08.300 --> 36:09.500
加上scoped过后

36:09.500 --> 36:09.900
没保存

36:09.900 --> 36:10.700
加上scoped

36:10.700 --> 36:11.700
刷新

36:11.700 --> 36:12.500
你看一下

36:12.500 --> 36:13.300
这是APP组件

36:13.300 --> 36:15.300
APP组件是不是加了一个制定影属性

36:15.300 --> 36:17.700
你看这是APP的组件7BA

36:17.700 --> 36:20.100
APP组件的元素7BA

36:20.700 --> 36:22.100
下面这个I元素

36:22.100 --> 36:24.100
I元素是不是直组件的根元素

36:24.100 --> 36:24.900
直组件的根元素

36:24.900 --> 36:26.900
他用了两个制定影属性

36:26.900 --> 36:28.500
一个是7BA

36:28.500 --> 36:29.900
就是副组件给他加的

36:30.500 --> 36:31.900
一个是自己的

36:31.900 --> 36:35.500
是不是自己的scoped得到了制定影属性

36:35.700 --> 36:37.500
也就是副组件可以影响他

36:37.500 --> 36:38.900
直组件也可以影响他

36:38.900 --> 36:40.900
那么这个问题就可以轻松解决了

36:40.900 --> 36:44.470
我要设置他的样式怎么办呢

36:44.470 --> 36:45.470
I count count

36:47.070 --> 36:50.470
不要到found size 26

36:50.470 --> 36:52.070
然后红色

36:53.270 --> 36:54.470
保存

36:54.470 --> 36:54.970
你看

36:54.970 --> 36:56.170
是不是变了

36:56.170 --> 36:57.470
因为他这个根元素

36:57.470 --> 36:58.670
受到两个组件的影响

36:58.670 --> 36:59.270
一个是副组件

36:59.270 --> 37:00.270
一个是自己

37:00.270 --> 37:00.770
对吧

37:00.770 --> 37:01.970
这样子

37:01.970 --> 37:03.670
就为了应对这样的场景

37:03.670 --> 37:06.470
副组件可能要从一个更高的层次

37:06.470 --> 37:07.970
因为直组件的话

37:07.970 --> 37:09.570
他看的东西比较窄

37:09.570 --> 37:10.970
他看不到各权局

37:10.970 --> 37:13.470
副组件的可能站的位置要高一点

37:13.470 --> 37:15.470
他可能要从一个权局的示威

37:15.470 --> 37:16.470
你这个情况呢

37:16.470 --> 37:17.670
在我这个布局下

37:17.670 --> 37:19.670
可能会做一些样式上的调整

37:19.670 --> 37:21.970
那么对根元素进行调整

37:21.970 --> 37:24.470
就这么个意思

37:24.470 --> 37:29.870
这是组件作用域的一些影响的细节

37:29.870 --> 37:30.370
那么这一刻

37:30.370 --> 37:32.270
我们就做出一个非常简单的一个组件

37:32.270 --> 37:33.370
就是I count

37:33.370 --> 37:33.870
那么这一刻

37:33.870 --> 37:36.870
我们将来大家把这个组件去完成

37:36.870 --> 37:37.570
好

37:37.570 --> 37:38.470
这是这一刻的内容

37:38.470 --> 37:39.670
我们前进的开发组件

37:39.670 --> 37:40.670
会稍微慢一点

37:40.670 --> 37:41.670
因为我们有一些支持的

37:41.670 --> 37:44.470
会一边学习组件一边来做

37:44.470 --> 37:45.470
大家千万不要着急

37:45.470 --> 37:46.670
先把一页面做出来

37:46.670 --> 37:48.170
那个还糟了很

37:48.170 --> 37:50.070
其实我们做五六开发也好

37:50.070 --> 37:52.670
后面大家做五六X开发也好

37:52.670 --> 37:54.670
都是不着急做一页面

37:54.670 --> 37:56.670
我们先慢慢慢慢把组件打起来

37:56.670 --> 37:58.070
一个组件一个组件测试好

37:58.070 --> 37:59.170
测试了没问题

37:59.170 --> 38:01.670
后来你会发现组件越来越多

38:01.670 --> 38:03.570
一页面就越来越简单

38:03.570 --> 38:05.370
做起来就越来越轻松

38:05.370 --> 38:06.670
如果说一开始去做一页面的话

38:06.670 --> 38:08.570
你会发现一大堆组件缺失

38:08.570 --> 38:10.070
导致的开发压力特别大

38:10.070 --> 38:11.970
我们从一开始从一小的组件开始

38:11.970 --> 38:13.270
慢慢慢慢开发

38:13.270 --> 38:15.670
后来莫名其妙的一页面就出来了

38:15.670 --> 38:15.970
好

38:15.970 --> 38:17.670
这是这个组件

38:17.670 --> 38:18.870
我们每一节课的东西

38:18.870 --> 38:21.470
作业雷大不动的就是

38:21.470 --> 38:23.770
你要把我课堂的组件一定要完成

