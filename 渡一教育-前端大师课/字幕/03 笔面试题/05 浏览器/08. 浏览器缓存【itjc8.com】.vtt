WEBVTT

00:00.430 --> 00:02.470
大家好 我是谢老师

00:02.730 --> 00:04.530
这节课的话 我们来看一下这个

00:05.290 --> 00:07.090
浏览器缓存

00:07.590 --> 00:11.690
这个这节课的内容的话 基本上比较偏理论

00:11.950 --> 00:12.970
理论要多一些

00:13.230 --> 00:15.790
但我最后的话 我还是给大家写了一个

00:16.310 --> 00:18.610
demo 我们可以一起来看一下

00:19.630 --> 00:22.950
好 那我们这边的话来看一下 内容也比较多啊 这一小节

00:23.210 --> 00:25.270
内容比较多 然后比较偏理论

00:25.770 --> 00:27.050
好 那我们一个一个来看

00:27.310 --> 00:28.330
那首先第一个

00:28.850 --> 00:31.150
什么是浏览器缓存

00:31.410 --> 00:35.750
那关于这个浏览器缓存的话 这个的话 大家应该是有一定的印象的

00:36.270 --> 00:38.310
对吧 为什么要使用这个缓存

00:38.570 --> 00:41.390
有了这个缓存之后是不可以提升我们的这个

00:41.650 --> 00:42.410
性能

00:43.170 --> 00:45.490
对不对 整体的这个web应用的性能

00:45.990 --> 00:49.570
好 那我们这边我们还是来看一下 具体这个什么是浏览器缓存

00:50.090 --> 00:52.650
在正式开始讲解浏览器缓存之前

00:52.910 --> 00:55.970
我们先回顾一下整个web应用它的一个流程

00:56.490 --> 00:58.290
那你看我这边 我这边到有一个图

00:59.310 --> 01:00.850
首先的话 这个是我们的客户端

01:01.350 --> 01:04.170
客户端是不是会向服务器发起请求

01:04.930 --> 01:07.490
对不对 我们称之为http请求

01:08.010 --> 01:09.290
好 然后接下来的话

01:09.550 --> 01:12.870
呃 这边服务器 服务器接受到请求之后

01:13.130 --> 01:16.450
啊 他一般要干嘛呢 他一般要做的一件事情就是

01:16.710 --> 01:18.250
他要去向这个数据库

01:18.770 --> 01:20.310
啊 这个发一个

01:20.570 --> 01:24.390
就是查询数据的这个请求 然后数据库这边的话就开始查询数据

01:25.030 --> 01:28.430
找到一定的数据之后 然后把这个数据返回给服务器

01:28.690 --> 01:31.250
那服务器这边的话再经过一系列的处理

01:31.510 --> 01:33.470
那最后的话 把这个响应

01:33.810 --> 01:35.350
返回给我们的客户端

01:36.110 --> 01:39.650
看到没有 这就是我们整个这个web应用它一个

01:39.910 --> 01:41.750
一个简单的流程啊

01:42.010 --> 01:44.570
那我们这边让我们思考一个问题 什么问题呢

01:45.070 --> 01:50.710
就是上面的整个流程中 哪些地方比较好时间

01:51.870 --> 01:53.270
哎 哪些地方比较好时间

01:53.670 --> 01:56.110
那我这边那总结起来的话就两个方面

01:56.550 --> 01:59.630
哪两个方面呢 一个的话是发送请求的时候

02:00.390 --> 02:03.210
一个是涉及到大量计算的时候

02:04.230 --> 02:11.910
啊 那一个的话是这个发送请求的时候 发送请求不是说啊 这边发这个http请求就只有这个啊 其实不是

02:12.170 --> 02:19.070
还有一个是什么呢 还有一个就是你这边的话服务器向数据库是不是发起这个查询数据的这个请求

02:19.850 --> 02:21.890
对不对啊 这个的话也算是

02:22.350 --> 02:25.510
第二个就是什么呢 第二个就是涉及到大量计算的时候

02:26.470 --> 02:33.190
那涉及到大量计算的话 计算不仅仅是这边服务器 服务器这边的话当然要计算

02:33.750 --> 02:39.110
这里的话会比较花时间 还有就是什么呢 还有就是你数据库在查询数据的时候

02:40.310 --> 02:46.950
啊 那这个的话他也会涉及到一定的这个计算 因为他查数据嘛 我们查数据的话有各种各样的需求

02:47.410 --> 02:54.170
对吧 根据我们的需求来查询数据 那么查询这个数据的话 他也是有这个时间的这个消耗的

02:55.250 --> 02:59.490
说单论缓存的话 我们其实干嘛呢 我们其实可以在很多地方

03:00.130 --> 03:03.930
可以做缓存 比方你看过这边 举例比较数据库缓存

03:04.690 --> 03:10.130
可不可以啊 因为我刚说了 你数据库这边查询这个数据是不是也是需要花时间的

03:10.850 --> 03:12.210
对不对 那我们可以刚

03:12.910 --> 03:22.710
干嘛呢 我们可以把一些常见的查询啊 常见的查询的一个查询结果 把这个结果这个数据啊 查询出来的这个数据这个结果

03:22.950 --> 03:31.030
把它缓存在那里 那之后的话就直接用这个缓存数据 那我数据库这边的话是不是就不需要再去这个再去查询一遍

03:31.670 --> 03:32.590
对不对啊

03:33.750 --> 03:35.510
还有就是什么呢 还有就是这个C点

03:36.370 --> 03:43.010
C点缓存啊 然后还有就是代理服务器缓存 浏览器缓存 应用程缓存

03:43.570 --> 03:48.130
啊 说说你看 单论这个缓存的话 其实很多地方可以做缓存

03:48.850 --> 03:56.130
啊 你把这些地方的缓存一做 那就可以干嘛呢 就可以大大的提升你整个vable应用的这个性能

03:57.090 --> 04:02.410
明白吧啊 说说这个缓存啊 光论这个缓存的话 其实是分很多种的

04:03.190 --> 04:10.150
分很多种的啊 当我们这边的话 我们就是要每一种来说的话 那这个的话工作量非常非常的大

04:10.470 --> 04:16.110
对吧 那我们这个文章那篇幅也非常非常的大 甚至这个的话可以出一个一本小书了

04:16.950 --> 04:23.630
对不对啊 小小的一冊书了啊 说我们这边的话就针对什么呢 我们这边的话就针对于浏览器缓存

04:24.390 --> 04:30.550
啊 我们主要进就是今天的话 我们来看看浏览器缓存这个的话也是和我们前端开发的话 息息相关的

04:31.490 --> 04:34.530
对不对啊 我们主要来看一下这个 浏览器缓存

04:35.730 --> 04:40.970
好 然后整个浏览器缓存它的过程的话是这个样子的 你看我这边 这边画了一幅图

04:41.770 --> 04:47.650
好 这边的话 这里是浏览器 这里的话是缓存 这里的话是服务器 ok

04:48.050 --> 04:50.970
好 然后接下来的话 第一次发送http请求

04:51.730 --> 04:57.610
对吧 第一次发http请求 第一次发这个http请求的话 他首先会去看一下缓存

04:58.510 --> 05:06.630
有没有缓存的数据 那你第一次是不是肯定没有 对没有的话 然后这样这边啊 你看箭头打回来 没有缓存结果

05:07.510 --> 05:11.710
对了 好没有缓存结果的话 那接下来就干嘛呢 接下来的话就像服务器

05:12.430 --> 05:18.910
发起请求 看到没有 这边一根箭头啊 就发到这个服务器这边 服务器干嘛呢 服务器是不是把这个资源给你

05:19.190 --> 05:26.070
返还回来 返还回来之后 然后接下来我这边客户端把这些资源存储到这个缓存里面

05:27.050 --> 05:36.130
那么下一次的话 我是不是就可以从缓存里面出去拿数据了 对不对 你看这个的话就是一个缓存的一个基本的这个流程

05:36.570 --> 05:41.570
其实并没有那么复杂 对不对 并没有那么复杂啊 那我们这边我们来看一下啊

05:42.410 --> 05:47.930
从上通我们可以看到 整个浏览器的缓存其实没有想象的那么复杂

05:48.490 --> 05:56.010
啊 最基本的原理就是什么呢 每次发请求的时候 先到哪里呢 先到缓存 你看这边看这个图

05:56.370 --> 06:01.650
是不是先到缓存中去请求 对不对 看一下有没有这个资源

06:02.370 --> 06:08.130
如果没有 没有的话 我再向服务器发起请求 那么如果有

06:08.930 --> 06:12.370
有的话呢 我就直接使用什么呢 使用缓存的这个资源

06:13.130 --> 06:16.850
对不对啊 但这边的话还会有一些细节 这个我们一会再来说啊

06:17.570 --> 06:24.890
第二个 浏览器每次拿到返回的这个请求结果都会将这个结果和缓存标识

06:25.190 --> 06:29.830
存到浏览器缓存中 因为有方便我下一次使用嘛

06:31.030 --> 06:38.790
对不对 ok 好然后以上两个结论啊 就是浏览器缓存机制的一个关键

06:41.550 --> 06:49.790
那么接下来的话 我会从这个两个维度来介绍这个浏览器缓存 一个就是缓存的存储位置

06:50.410 --> 06:56.650
另外一个就是什么呢 缓存的这个类型啊 我们从这两个方面来看一下这个浏览器缓存

06:57.330 --> 07:04.410
好吧 好 我们一个一个来看 那首先第一个 第一个的话是按照这个缓存的位置来进行分类

07:05.330 --> 07:10.290
啊 那按照这个缓存的位置来进行分类的话 这个不同的位置它是有各种的

07:10.650 --> 07:12.410
就是各自的这个优先级的

07:12.990 --> 07:22.310
啊 就有的位置它的优先级高 有的位置它的优先级低啊 那找的话肯定就是先干嘛 是不是先从优先级高的

07:22.750 --> 07:32.550
这个缓存位置去找资源 对不对 然后如果没有找到再去找什么呢 再去找这个优先级低的这个位置的这个缓存资源

07:33.230 --> 07:40.230
可不可以啊 好 然后当一次查找缓存都没有命中的时候啊 就是我把所有的位置都找光了

07:40.970 --> 07:48.570
都没有就是我要用的资源 然后干嘛呢 才会去寝求网络 才会去寝求网络

07:49.130 --> 07:56.210
好 那我们来看一下究竟有哪些位置 那这边的话我分了四个啊 一次是什么呢 一次是 service walker

07:57.050 --> 08:01.170
memory catch啊 disk catch和这个 push catch

08:01.890 --> 08:07.970
有这么四种啊 每一种的话我们大致来看一下啊 但这边的看一下的话都是偏理论的

08:08.390 --> 08:14.990
ok 我先提前说一下啊 都是偏理论的啊 那首先的话 第一个 service walker

08:16.350 --> 08:21.790
啊 service walker的话 它是运行在浏览器背后的这个独立线程

08:22.230 --> 08:26.790
啊 我知道这个浏览器的话 它会有很多个线程 对不对 然后其中这个

08:28.110 --> 08:35.990
执行接式代码的话 只有一个线程 所以我们说接式的话是单线程啊 但不是说整个浏览器是只有一个线程啊 浏览器里面有很多线程

08:36.450 --> 08:38.810
啊 然后这个service walker的话 它是一个

08:39.810 --> 08:45.330
就是单独的独立的这个线程 这个的话一般就是在这个pwa里面

08:46.010 --> 08:51.370
用的比较多啊 然后service walker必须使用https

08:51.930 --> 08:54.570
他可以干嘛呢 他可以请求拦截

08:55.210 --> 09:01.290
看到没有 他涉及到这个请求拦截啊 然后所以必须使用https协议 保障这个安全

09:02.150 --> 09:02.750
好 那这个

09:03.870 --> 09:10.270
service walker service walker的话 具体就是怎么用的 那首先第一步 第一步的话 你需要先注册

09:11.550 --> 09:17.350
需要先注册啊 注册一个service walker 注册了之后 然后接下来的话

09:18.470 --> 09:26.990
之后的这个资源就可以缓冲在这个service walker里面啊 你看这张图 看这张图你就知道 首先我们要注册

09:27.490 --> 09:28.810
注册一个service walker

09:29.530 --> 09:37.410
对不对 好 然后接下之前 之前的话是你请求啊 向这个后端服务器请求资源 然后在这边他把资源是不是给你返还回来

09:37.970 --> 09:43.370
对不对 好 然后接下有了service walker之后 他就有点类似于什么的 有点类似于代理服务器

09:44.210 --> 09:49.170
啊 有点类似于代理服务器 好 你这边要请求资源 请求资源的话 你第一次的话是没有

09:49.650 --> 09:55.370
没有的话 然后接下来这边啊 sw sw 就是我们的service walker 好 然后接下来的话这边

09:55.790 --> 10:04.910
向服务器请求 请求了之后 服务器是不把资源给返回来 返还回来 大家就存储在我的service walker上面了

10:05.670 --> 10:13.350
看了没有 他就有点类似于一个代理服务器 就存储在这上面了 好 大家由这儿把资源给你返还回来

10:13.950 --> 10:16.430
好 大家下一次我再发请求的时候

10:17.470 --> 10:23.110
啊 那你这个service walker上面是不是就有资源了 对不对 他就直接从这儿就给你返还回来了

10:24.090 --> 10:27.570
看了没有啊 这就是关于这个service walker 他的话

10:28.690 --> 10:37.330
就是以前和pwa 就是一起联用啊pwa是什么 pwa的话是一个渐进社网络应用

10:37.890 --> 10:48.170
啊 这个是谷歌主推的 那那个service walker的话在里面扮演的这个角色就是什么呢 就是可以让我们的vivo应用 能够离线的这个使用

10:49.150 --> 10:54.110
能够离线 对你没有听错啊 可以离线 就是我网络断开了 断开了我这个vivo应用

10:54.430 --> 11:03.790
就这个vivo应用啊 就还是可以用啊 就是有些图片啊 这些还是能够显示的出来 为什么呢 因为我是缓存在service walker上面的

11:04.590 --> 11:11.470
对不对 我很多一些资源都是缓存在这上面的 所以即使我现在没有网络了啊 我这些资源我依然可以用

11:12.370 --> 11:19.850
看到没有啊 这是这个service walker啊 但我这边那就是只是一个偏理论啊 后面的话我们找个时间单独

11:20.490 --> 11:23.530
来看一下这个service walker啊 我们写一些这个demo

11:24.170 --> 11:31.010
好吧 好 然后下一个 下一个位置的话是什么呢 下一个位置是这个memory catch

11:32.090 --> 11:35.610
那memory memory 顾名思义就是什么了 是不是就是内存

11:36.470 --> 11:41.750
对不对 也就是我们的这个缓存的话 把它缓存在哪里呢 缓存在内存里面

11:42.710 --> 11:47.030
那缓存在内存里面的话有个好处 什么好处呢 就是我们任何

11:48.110 --> 11:51.190
就是这个就cpu的话 它只能和内存打交道

11:51.990 --> 11:56.550
对不对 那么任何的这个操作都要经过内存 那内存的话 它速度也是比较快的

11:57.190 --> 12:02.510
啊 所以你如果把这个资源缓存在这个内存里面的话 那它的读取速度是很快的

12:02.970 --> 12:03.850
啊 非常非常快

12:04.610 --> 12:09.890
啊 那我这个能不能把所有的资源全部都放在内存里面了 那肯定也是不行的

12:10.330 --> 12:15.890
虽然它读取很快 但是这个内存它的容量会干嘛呢 容量会小得多

12:16.890 --> 12:18.410
可不可以啊 容量会小得多

12:20.010 --> 12:26.050
所以当你的这个资源啊 比如第一次 第一次的话它就是缓存在这个内存里面啊 而且你比如说你把这个

12:26.610 --> 12:30.610
table页面你把它关闭了 关闭了之后 然后现在它的这个内存

12:30.990 --> 12:33.590
就是内存里面的这个缓存 它也就释放了

12:34.310 --> 12:38.710
明白吧啊 然后接下来你怎么看你的这个资源 是不是来自于这个

12:39.310 --> 12:45.910
呃 内存的这个缓存的 就你打开那个网络 打开网络之后让你刷新页面 你会发现这边啊

12:46.430 --> 12:52.150
比如说这边这边是size size 是我文件的大小 对不对 你看这边就有什么呢 就有memory catch

12:53.190 --> 12:59.070
啊 memory catch 就说明什么 说明这三个资源是来自于这个内存中的缓存

13:00.050 --> 13:03.850
看了没有啊 那我们这边我们可以看个例子吗 比如说我这边让我打开这个清冬

13:05.690 --> 13:07.210
我这边打开这个检查

13:08.650 --> 13:10.410
然后打开什么呢 打开这个network

13:13.290 --> 13:23.270
然后这边打开清冬 走啊 里面资源很多 看了没有 资源很多 好 然后既然我们这边让我们来看一下

13:24.190 --> 13:29.470
啊 你看有一些的话 是不是来自于这个内存缓存 这边memory catch

13:30.210 --> 13:31.690
好吧 这个稍微拉过来一点

13:33.770 --> 13:41.330
ok 看到没有啊 memory catch 啊 但第一次的话 第一次的话 你看到是不是没有那么多 对不对 就只有00闪闪 这边一个

13:42.250 --> 13:44.850
啊 两个 这个的话是来自于内存缓存的

13:45.770 --> 13:48.610
然后三个啊 然后你这边再一刷新

13:49.370 --> 13:51.770
那这一次就多了 看到没有 这一次就多了

13:52.690 --> 13:59.450
看到没有 你看这里 这些图片的话是不是就都来自缓存了 对不对 我就没有必要再干嘛呢 是没有必要再发送请求了

14:00.210 --> 14:02.410
对不对 我把它缓存在内存里面的

14:04.410 --> 14:06.370
好 这是这个memory catch

14:07.090 --> 14:15.930
啊 memory catch的话啊 它这个机制保证了一个页面中 如果有两个相同的这个请求啊 比如两个src都是相同的imager

14:16.330 --> 14:18.770
两个horray for 相同的这个link

14:21.620 --> 14:26.060
然后它的干嘛呢 它的这个请求的话就最多是一次

14:26.900 --> 14:30.140
对不对 请求的最多就是一次啊 这是memory catch

14:32.240 --> 14:33.960
好 接下来的话 我们来看一下这个

14:34.960 --> 14:42.560
disk catch 啊disk的话 顾名思义就是什么 是不是硬盘上 也就是说你的这个缓存是存在哪里呢 存在硬盘上

14:43.360 --> 14:49.480
那你存在这个硬盘上的话 那它相比刚才我们介绍的这个memory catch 那它的读取速度

14:50.200 --> 14:58.840
肯定就比那个memory catch要慢一些 但是呢 它有优点 优点就是你的这个容量 你缓存的容量

14:59.260 --> 15:04.340
还有就是存储的实效性上面 那你这个memory catch是比不了的

15:04.980 --> 15:08.700
对不对 你memory catch的话 你只要这个标签页一关闭了

15:09.620 --> 15:16.340
你这个内存里面的缓存是不是就没有了 对不对 但是disk catch就不一样啊 他这边无论是这个

15:16.860 --> 15:23.020
容量上面 还是这个存储的实效性上面 都是大大的要优于这个memory catch

15:25.500 --> 15:34.420
好 然后在所有浏览器缓存中啊这个disk catch就是这个硬盘上的这个缓存 它的覆盖面啊 基本上是最大的

15:34.900 --> 15:44.180
他会根据这个http header中的这个字段来判断哪些资源需要缓存 哪些资源可以不请求直接使用

15:44.620 --> 15:50.460
哪些资源已经过期需要重新请求 你注意 这些的话都是浏览器自动来判断的

15:51.080 --> 15:59.600
知道吧啊 有的同学可能有疑问啊 这个disk catch让我这边的话硬盘缓存 让我怎么设置他呢 这个不需要你是去设置

16:00.160 --> 16:03.320
啊 这个的话 他浏览器会自动的来进行这个操作

16:04.040 --> 16:08.360
不需要你去设置 需要你设置的是什么呢 是这个 service walker

16:09.200 --> 16:18.880
啊 这个东西的话 需要你自己去创建一个service walker的这个文件啊 自己去注册啊 然后接下来的话 监听一个install世界啊 这个需要你来做

16:19.260 --> 16:25.740
这边的话这个memory catch和这个disk catch 这个的话都是浏览器自己的行为

16:26.620 --> 16:35.500
明白吗 都是浏览器自己的行为 他自己的话就会来进行这个缓存 这个文件我要不要缓存 然后缓存在哪个位置 他会自己的进行一个判断

16:37.860 --> 16:45.020
然后这里你注意 凡是持久性这个存储都会面临一个什么呢 面临一个容量增长的问题

16:45.560 --> 16:52.440
这个很好理解 对不对 你这个disk catch缓存在这个硬盘上面 那就缓存在硬盘上面的话

16:53.480 --> 17:04.640
那你这个一直蒸一直蒸 那这个硬盘上面的缓存文件是不是就会越来越大 对不对 那这个的话怎么办呢 你放心 浏览器的话 他也会自动的进行清理

17:05.560 --> 17:14.080
看到没有 自动进行清理 他会把特殊 他会有一些特殊的这个算法 把一些最老的或者就是可能过时的资源

17:14.380 --> 17:18.780
会把它删除掉 看到没有 这是disk catch

17:19.700 --> 17:23.460
好 最后一个 最后一个的话是这个push catch

17:24.100 --> 17:31.260
push catch的话翻译成中文叫做推送缓存 这个的话是属于http2中新增的这个内容

17:32.620 --> 17:41.220
我们知道我们的这个http协议 第一版的话是0.9 然后过了是1.0 然后过了是1.1 那么这个http

17:42.200 --> 17:46.720
协缸2的话 这个的话是最新的 我记得这个是15年出来的

17:47.360 --> 17:52.880
15年出来的 然后这个push catch的话 他就是http2中新增的这个内容

17:55.510 --> 18:02.110
他的这个优先级的话 你注意一下啊 他的优先级的话是上面就是这么几种里面最低的

18:02.590 --> 18:09.670
所以你看这边有一句话 当以上三种缓存都没有命中的时候 他才会被使用

18:10.130 --> 18:16.930
啊 然后目前的话这个push catch就这个推送缓存 他现在的话就是国内能够查到的资料比较少

18:17.490 --> 18:25.210
然后普及度也还不高啊 包括在国外啊 国外的话 现在的话这个这个push catch用的也比较少

18:25.730 --> 18:29.690
如果就是大家对这个有兴趣的话 这边有一篇文章 我看打的开不

18:31.130 --> 18:37.170
打的开 打的开 大家可以把这篇文章 可以自己看一下 当然肯定是英文的

18:37.630 --> 18:42.950
啊 肯定是英文 因为因为我刚已经说了啊 他在这个国内目前的话 这个普及度都还不高

18:43.710 --> 18:49.470
相应的这个文章也比较少啊 所以这篇的话也是这个英文的 你有兴趣的话可以自己看一下

18:50.070 --> 18:53.270
好吧 这是这个push catch推送缓存

18:54.670 --> 19:03.150
然后文章里面有这么几个结论啊 你可以大致看一下 所有的资源都能够被推送啊 并且能够缓存啊 但是这个 edge和suffer it

19:03.610 --> 19:13.490
支持比较差啊 可以推送no catch和no store的这个资源啊 但这个这个的话是我们涉及到一会儿讲那个缓存类型分类的时候 我们会提到

19:14.250 --> 19:20.570
啊 然后一旦连接会被关闭push catch就被释放啊 然后还有一些其他的点啊 这个的话你就

19:21.130 --> 19:26.970
看到这篇文章啊 我这边那就是看到这篇文章之后 那这个文章里面他所提出了这么几个

19:27.530 --> 19:31.970
观点啊 我把它总结出来的 ok 我这个的话就不在这说了

19:32.870 --> 19:34.910
好 那这个的话就是按照这个

19:35.950 --> 19:43.110
按照这个缓存位置来进行分类啊 这边那就是给大家介绍了一下 但大家的话可能觉得会比较抽象

19:43.870 --> 19:50.950
对不对啊 介绍了四种 但是每一种说的很抽象啊 那这个很正常 因为我们这边的话是为这个面试

19:51.750 --> 19:57.830
做准备啊 面试的时候你能够说出这么四种啊 我们的目的就达到了

19:58.590 --> 19:58.990
明白吧

19:59.650 --> 20:02.210
好 然后下面

20:03.170 --> 20:10.170
下面的话是按照缓存的这个类型来进行分类啊 这个的话其实是属于http

20:10.690 --> 20:13.370
缓存里面的这个知识了啊 那我们这边我们来看一下

20:14.090 --> 20:20.170
如果按照缓存类型来进行分类的话 可以分为什么呢 可以分为强缓存和协商缓存

20:21.010 --> 20:27.810
可不可以啊 一个是强制缓存 一个是协商缓存啊 你需要注意的是无论是强缓存还是协商缓存

20:28.070 --> 20:30.590
他们都是属于什么呢 都是属于disc catch

20:31.630 --> 20:40.470
disc catch 就是也就是我们上面这个分类是分了四种 对不对 他是属于这个disc catch 啊 或者叫做http catch 里面的一种

20:41.790 --> 20:44.030
好 那我们首先的话 我们来看这个强制缓存

20:44.830 --> 20:50.150
什么叫做强制缓存 所谓强制缓存的话 就是啊 我比如说我有缓存资源在那里

20:50.630 --> 20:56.990
对不对 缓存资源在那里的话 然后接下来的话 浏览器在发送请求之前 他看一下你这个缓存有没有

20:57.870 --> 21:04.670
哎 有啊 并且这个缓存是能够用的 那我就直接使用你的这个缓存资源 我连请求都不发

21:05.670 --> 21:10.550
可不可以啊 我连请求都不发啊 我们这边我们来看一下 强制缓存的含义是

21:11.150 --> 21:18.590
当客户端请求后 先访问什么呢 缓存数据库啊 看什么呢 看这个缓存资源

21:19.250 --> 21:21.930
存不存在 有直接返回

21:22.930 --> 21:30.770
概念啊 不存在的话 才会去请求真的这个服务器 然后响应之后再写入什么呢 再写入缓存数据库

21:32.090 --> 21:35.930
然后强制缓存 他干嘛呢 他直接减少了请求数

21:37.210 --> 21:41.090
直接减少了请求数 为什么这么说 因为我如果缓存

21:41.570 --> 21:47.690
就是缓存的那个数据库里面 有这个缓存资源 有我要用的资源 我是不是压根就不会发起

21:48.070 --> 21:54.270
真实的请求 对不对啊 所以说他是什么呢 他是提升最大的缓存策略

21:55.110 --> 22:04.310
可不可以啊 他是提升最大的缓存策略啊 那这个强制缓存 强制缓存的话 可以就是造成强制缓存的制断有两个

22:04.830 --> 22:08.070
一个是catch control 一个是这个expires

22:08.870 --> 22:13.710
那这两个有什么区别呢 其实就是新脑版本的区别 我们来看一下吧

22:14.430 --> 22:20.770
这个expires 他是http 1.0的这个制断 我们说过我们的http的话 现在有四个版本

22:21.330 --> 22:26.610
从第一代 第一代是0.9 啊 然后接下来1.0 1.0过了 然后现在

22:27.530 --> 22:32.450
大家管饭再用的是1.1 啊 然后最新的话是http2

22:34.010 --> 22:36.330
啊 那这个是什么呢 这个是1.0里面的制断

22:37.050 --> 22:40.210
表示什么呢 表示你缓存到期的一个时间

22:41.070 --> 22:46.630
啊 虽然我就是我们要设置缓存 但你缓存总得有个时间啊 对不对 我不可能我请求了一次

22:47.190 --> 22:52.710
之后让那个缓存永远不过期 那我永远都是拿到缓存的数据 这不可能吗 对不对

22:53.510 --> 23:00.430
好 所以缓存的话 他会有一个到期的时间 但是这个expires的话 他是什么 他是设置一个绝对时间

23:01.390 --> 23:05.510
看到没有 比如说这边expires 然后接下来这边后面就是一个时间

23:06.490 --> 23:11.090
看到没有 啊 这边的话low ember 这边low ember 就是11月

23:11.970 --> 23:21.250
10号 对吧 2017年11月10号星期四 对吧 然后这个8点 早上8点45分11秒过期

23:22.490 --> 23:24.370
就是早期的话 那是这样子来设置的

23:25.330 --> 23:29.890
那这样子设置的话 虽然目的能够达到 但是呢 他有两个缺点

23:30.570 --> 23:35.210
首先第一个就是你这个是绝对时间 那用户的话可以就是随便的去改

23:36.090 --> 23:41.650
对不对 啊 用户可以随便去改 但这个的话可能性不大 一般的话普通用户的话也不会

23:42.370 --> 23:49.130
压根都不知道这个东西 对吧 谁去改了 对吧 很多用户压根就是连那个怎么开控制台都不知道

23:49.730 --> 23:53.890
平时就浏览一下网页 就完事了 啊 但他确实会有这么一个点

23:54.530 --> 23:59.330
对吧 会有这么一个点 啊 第二个其实主要是第二个 就你这个写法太复杂了

24:00.310 --> 24:08.030
对不对啊 你看这边的话 就是我这边啊 这个星期几都好 然后在这边空格啊 然后接下来这边就是日期空格

24:08.590 --> 24:09.310
然后接下来月份

24:10.190 --> 24:21.110
啊 表示的时间的制度出来 如果多了一个空格啊 或者少一个空格啊 多一个字母少一个字母 都会变什么呢 都会变成非法属性

24:22.190 --> 24:25.230
从而导致什么呢 导致你的这个设置失效

24:26.190 --> 24:28.910
看到没有啊 这是这个最早的expire

24:30.070 --> 24:36.590
强缓 是一个强缓 但是呢 不怎么好用啊 不怎么好用 好 后面的话在这个

24:37.870 --> 24:39.150
http 1.1

24:39.830 --> 24:46.150
就是1.0过的时候就是1.1 对不对 就增加了一个字段 什么字段呢 叫做catch control

24:46.830 --> 24:53.590
啊 那这个字段的话就是什么呢 他表示我支援缓存的最大有效时间

24:54.570 --> 25:01.250
克里面啊 你看这边catch control 然后加这边max-edge 然后加这边是一个时间戳

25:02.290 --> 25:08.690
啊 说这前面的话 他是一个绝对时间 而这个是一个什么呢 这个是一个相对时间

25:09.170 --> 25:15.090
啊 也就是说从我当前时间开始算啊 大家过了这么长时间之后缓存到期

25:15.930 --> 25:22.130
哎 你看这个相对于前面你这个写一个这个绝对时间来讲 是不是稍微要方便一些了

25:22.990 --> 25:29.310
对不对 要方便一些了啊 但这边的话就是我的这个catch control 除了max-edge

25:30.150 --> 25:34.150
这个字以外啊 他还有一些其他的字 比如这边no

25:34.830 --> 25:38.590
这个low-store 啊 这个是代表什么 代表不要缓存

25:39.590 --> 25:46.310
啊 不要缓存 所有内容都不走缓存啊 无论是强缓还是协商缓存啊 都不要缓存

25:46.970 --> 25:52.170
啊 这个low-catch 这个也是不要缓存 啊 但是他实际上还是会要求客户端

25:52.850 --> 26:01.050
这个缓存内容啊 然后就是之后是否使用由这个协商缓存来决定 那什么是协商缓存 我们一会就会讲

26:01.610 --> 26:04.250
啊 什么是协商缓存 啊 但还有些其他的

26:05.010 --> 26:10.690
怎么样 还有些其他的什么 public呀 private呀 那你完整的列表你可以看这个mdn

26:11.550 --> 26:20.230
mdn 上面这边写的有 看到没有 public private no catch no store 啊 然后这边max-edge

26:20.870 --> 26:26.430
对不对啊 各种各样的这个这个键啊 有些什么键可以设置

26:28.030 --> 26:32.670
啊 这是catch control 然后上面这些键的话 它是可以混用的

26:33.150 --> 26:38.990
看到没有 比如说你看我这边catch gun control 然后加这边public 是不是设置了这个public

26:39.690 --> 26:47.970
对不对 所有内容都可以被缓存 然后接下来这边 这边的话这个max-edge 然后加这边是不是设置了一个缓存的这个时间

26:49.010 --> 26:52.490
对不对 然后下面的话会有一个这个优先级的这个图

26:53.570 --> 26:54.810
怎么样 优先级的图

26:56.490 --> 27:01.930
啊 比如说我设置了我又设置了一个no store 我又设置了什么呢 我又设置了一个max-edge

27:02.570 --> 27:07.410
那谁的优先级刚是这个no store 对不对 那最终的话这个资源它就不会缓存

27:08.010 --> 27:08.850
啊 就不会缓存

27:09.490 --> 27:10.170
啊 这是这个

27:10.890 --> 27:15.090
啊 关于这个catch control啊 我们一会会用一下啊 一会在我们的这个例子里面

27:15.610 --> 27:15.850
这里

27:16.490 --> 27:22.730
这里你看我一会这个例子里面什么就写了 对不对catch gun control max edge缓存多少秒呢 缓存10秒

27:23.290 --> 27:24.730
啊 一会我们来看这个例子

27:25.570 --> 27:27.610
好 然后接下来下一个

27:32.370 --> 27:35.090
啊 这里的话总结了一下啊 总结了一下 我们来看一下

27:35.950 --> 27:43.070
就是自从http1.1开始这个expire 逐渐被什么 逐渐被catch control取代

27:43.670 --> 27:44.950
这个时候刚我们说过的

27:45.710 --> 27:49.710
对不对啊 你这个的话是http1.0推出的 它是一个相对时间

27:50.030 --> 27:54.190
这个的话是一个 这个是一个绝对时间 这个的话是一个相对时间

27:54.630 --> 27:57.470
所以它逐渐被这个catch control取代啊

27:57.870 --> 28:04.190
catch control是一个相对时间 即使客户端时间发生改变 相对时间也不会随之改变

28:04.650 --> 28:10.970
啊 可以保持一致性 还有就是这个catch control可配置性比较大 你看这边是不是有这么多

28:11.570 --> 28:13.570
可以配置的 对不对 有这么多

28:14.570 --> 28:14.810
啊

28:15.650 --> 28:23.810
然后它的优先级要高于expire 啊 但是在实际开发中的话 为了兼容这个http1.0和1.1

28:24.210 --> 28:27.010
实际项目中里面的话 两个字段都会设置

28:27.970 --> 28:29.130
啊 两个字段都会设置

28:29.690 --> 28:31.290
好 这是关于这个强制缓存

28:31.990 --> 28:34.870
好 然后接下来的话 我们来看协商缓存

28:35.790 --> 28:40.430
什么叫做协商缓存啊 当强制缓存失效的时候

28:41.750 --> 28:46.030
啊 我的这个强制缓存 比如我缓存时间是多久多久的 比如一个小时

28:46.630 --> 28:55.510
一个小时之后 那接下来我的缓存是不是就失效了 对不对 失效了之后 然后接下来就需要使用什么呢 接下来就需要使用协商缓存

28:56.310 --> 28:59.230
协商缓存什么意思 协商缓存的话就是

28:59.970 --> 29:04.330
这个客户端会发送这个请求到服务器

29:05.010 --> 29:11.370
注意哦 和强缓不一样 强缓的话 是不是你直接使用我的这个缓存资源就可以了 你不需要再向服务器

29:11.770 --> 29:12.490
发行请求了

29:13.250 --> 29:18.130
对不对 但是协商缓存不一样 协商缓存的话是 他仍然会向服务器

29:18.770 --> 29:25.610
发送请求 啊 他向服务器发送请求的时候 他会带一个什么呢 他会带一个资源标识过去

29:26.590 --> 29:34.510
资源标识 什么叫做资源标识 就是我的这个资源啊 我从这个服务器拿回来 拿回来我是不是要放到我的这个缓存里面

29:34.950 --> 29:42.950
我放到缓存里面之后 我会给他一个标识 也就是他的状态啊 或者说状态嘛啊 然后接下来下一次的话 我这个缓存

29:43.510 --> 29:51.270
一旦他这个强缓到期了 到期了的话 那说明是不是这个缓存就不能用了 对不对 不能用了之后我就会向服务器

29:51.690 --> 29:57.450
发送真实的请求 啊 但是呢 我会携带上我的这个缓存标识

29:58.210 --> 30:05.730
好 大家服务器这边 服务器这边的话 他就会拿到你的缓存标识 和我的这个服务器上面的资源进行一个对比

30:06.450 --> 30:11.730
看我这个服务器 有没有这个就是这个资源哈 有没有发生改变

30:12.650 --> 30:19.650
如果没有发生改变 好 那接下来我服务器的话 就会告诉你啊 我这边的话 其实资源也没有变化

30:20.230 --> 30:23.790
那么你之前 你的这个缓存里面的资源 虽然过期了

30:24.630 --> 30:28.430
对吧 虽然过期了 但是呢 可以继续用

30:29.230 --> 30:33.470
啊 可以继续用 说这个时候返回的状态码就是什么呢 就是304

30:34.110 --> 30:36.870
表示该资源无根薪

30:37.590 --> 30:43.230
看到没有 然后接下来的话 这个浏览器就再一次从什么呢 从缓存中去获取资源

30:44.070 --> 30:46.790
看到没有 这个的话就是协商缓存

30:47.770 --> 30:54.130
这个就是协商缓存 啊 就是他强缓到期之后 我把这个标识 资源标识

30:55.050 --> 30:59.210
发送到这个服务器 服务器进行一个对比 如果

30:59.810 --> 31:04.930
资源没有发生变化 让我告诉你没有更新 那你可以继续使用缓存

31:05.850 --> 31:07.730
看到没有啊 协商缓存

31:09.910 --> 31:17.870
好 然后接下来 如果你的这个资源有更新 有更新的话 他是不是就是失效了 对不对 失效的话 他就会返回新的数据

31:18.310 --> 31:20.750
和这个缓存的一个标识啊

31:21.670 --> 31:25.510
缓存规则 这里的缓存规则就是指的是你的一些时间啊之类的

31:26.070 --> 31:31.230
好 那既然浏览器响应数据之后 再把这些规则干嘛呢 写入到缓存数据库

31:31.830 --> 31:36.310
看到没有 他的流程度就是这样子的 发请求 接下来强缓过期

31:36.870 --> 31:41.550
对吧 只返回缓存标识 那既然带着缓存标识 找到服务器

31:41.950 --> 31:45.990
服务器说我资源确实发生了变化 那既然是不是会把新的资源

31:46.410 --> 31:50.130
是返还给你 对不对 这个时候状态码就是什么了 状态码就是200了

31:50.690 --> 31:57.010
啊 然后在这边浏览器用了之后 再把什么呢 再把这个资源和这个缓存标识存入到缓存里面

31:57.890 --> 32:05.130
看到没有 和刚才就不一样 刚才的话你去找服务器 找服务器这服务器跟你说 哎 我也没更新 他就不会给你返回资源

32:05.850 --> 32:09.570
啊 两者的区别就在于服务器会不会给你返回这个资源

32:10.210 --> 32:15.890
啊 我这边让我没有过期 没有过期的话 我就不会给你返回资源啊 然后我返回的状态码就是

32:16.210 --> 32:16.890
304

32:18.090 --> 32:20.890
明白没有 啊 这就是协商缓存

32:23.450 --> 32:29.570
啊 协商缓存的话 在请求数上和这个没有缓存是一致的

32:30.330 --> 32:36.050
啊 你注意他和没有缓存是一致的 为什么 因为他他的请求会真实的到达是服务器

32:36.770 --> 32:42.450
对不对 但如果是304的话 他返回的只是一个什么 只是一个状态码而已

32:43.050 --> 32:45.450
他只是个状态码 因为资源没有改变吗

32:45.990 --> 32:54.690
对吧 啊 然后并没有实际的文件内容 啊 说他在响应体这个体积上的这个节省也是他的一个优化点

32:55.610 --> 33:01.490
可不可以啊 啊 他的优化主要就体现在响应上面 响应因为你很小嘛 对不对 就一个304的

33:01.810 --> 33:09.290
响应啊 那你这个网络的这个传输时间就很短 对不对 所以你这个的话有总比没有好啊

33:10.970 --> 33:15.610
啊 这是协商缓存 然后协商缓存可以和强制缓存一起使用

33:16.010 --> 33:20.810
作为什么呢 作为强制缓存私效后的一种备用方案

33:21.650 --> 33:24.170
看到没有 实际开发中的话 他们也是

33:25.090 --> 33:32.530
确实是一起使用的啊 那他们这边有两组 有两组 一个的话叫做这个nuster modified

33:33.330 --> 33:35.410
and 什么呢 if modified sense

33:36.250 --> 33:40.610
注意这个是第一组啊 一组 那这个第二个 第二个是etag

33:41.470 --> 33:47.470
etag 和这个时候这个if non match 让我们一组一组来看 好吧

33:49.230 --> 33:52.110
好 首先第一组的话是这个nuster modified

33:52.750 --> 33:58.670
还有这个if modified sense 我们这边来看 他有这么几个步骤 其实还是比较简单

33:59.190 --> 34:03.310
就是首先服务器的话 他给你返回的话 他会给你返回一个这个字段

34:03.910 --> 34:08.230
叫做nuster modified 这段 那这边的话是不是就记录了一个时间啊

34:09.050 --> 34:16.970
看到没有 这里就记录一个时间啊 这个时间是什么呢 这个时间是资源最后一次被修改的时间

34:17.970 --> 34:21.570
看到没有 就是我的资源最后一次被修改是什么时候 是这个时候

34:22.130 --> 34:27.210
OK 那接下来这个字段的话 他就会会返回到哪里呢 返回到这个客户端

34:27.810 --> 34:31.530
对不对 返回到客户端 客户端的话 然后接下来下一次

34:32.690 --> 34:35.730
他请求的时候 他就会把什么呢 他就会把这个值

34:36.470 --> 34:44.190
就是你之前记录的资源的最后一次修改时间 不是这个吗 对吧 那接下来我就把这个值写到我的请求头里面

34:44.830 --> 34:47.230
我的请求头里面会有一个什么呢 会有一个这个字段

34:48.070 --> 34:52.870
叫做if modified sense 看到没有 会有这么一个字段

34:53.670 --> 35:00.670
啊 有这么一个字段 那接下来的话服务器就会干嘛呢 服务器接下来他拿到你的这个请求 请求里面的这个字段里面是不是就有这个值啊

35:01.130 --> 35:12.090
这个值的话就会和他最新的 最新的一个last modify的 因为这个last modify的始终记录的是什么呢 始终记录的是资源最后一次修改的时间

35:12.650 --> 35:18.370
对不对 他就和他最新的资源最后一次修改的时间进行一个对比 那如果相等

35:19.090 --> 35:23.650
表示你资源是没有修改 对不对啊 比如说我这个最后一次修改

35:24.110 --> 35:29.390
是昨天下午的五点 然后叫你发请求 然后拿到了这个拿到了这个值

35:30.390 --> 35:35.710
这个值的话 然后是昨天下午的五点 和我现在是一样的 那说明我资源没有改 那我这边就返回

35:36.150 --> 35:40.990
三零四 那比如说你发请求 然后我这边写的是什么呢 资源最新的

35:41.550 --> 35:49.950
就是最后一次修改时间是下午五点 好大家在七点钟的时候 让我资源发生了修改了 修改了之后让我服务器端这个值是不是就变了

35:50.530 --> 35:56.290
对不对 变成这个下午的七点 好那在这个时候你在发请求的话 你带的是什么 这不带的是

35:56.850 --> 36:00.610
之前的那个旧的那个时间 对不对 两者就不一样了

36:02.290 --> 36:09.530
啊 所以说这边反之的话就表示修改了 然后既然修改了 那我就干嘛呀 我是不给你返回新的这个资源

36:10.650 --> 36:13.010
对吧 然后响应这个200的这个状态吗

36:13.470 --> 36:13.510
啊

36:14.750 --> 36:18.270
但是这个这个的话 他有一定的这个缺陷啊 我们来看一下有什么缺陷

36:18.830 --> 36:23.470
首先第一个就是你资源更新的速度 如果是秒以下的单位

36:24.190 --> 36:29.470
那么这个缓存的话 他是不能使用的 啊 因为他的这个时间单位最低就是秒

36:30.230 --> 36:32.870
你看这边这个时间是最低就是秒

36:33.710 --> 36:41.430
对不对 好 第二个 如果文件是通过服务器动态生成的 那么该方法的这个更新时间

36:41.730 --> 36:43.370
永远是生成的时间

36:44.290 --> 36:49.210
啊 尽管你的这个文件可能没有变化啊 你这样子的话 他起不到这个缓存的作用

36:49.690 --> 36:54.770
说这一组的话 他是有这个缺陷的 所以才出现了什么呢 才出现了第二组

36:55.810 --> 36:57.730
怎么样 其实和刚才那个强缓是不很像

36:58.370 --> 37:02.450
对不对 强缓的话 这个expire有问题 所以出现了catch control

37:03.010 --> 37:08.610
协商缓存 因为他有问题 所以出现了etag和iflum match

37:09.470 --> 37:15.670
啊 这个etag和iflum match也是http1.1出现的 那我们这边我们来看一下

37:17.470 --> 37:25.070
啊 为了解决上述的问题 出现了什么呢 出现了一组这个新的字段 叫做etag和iflum match

37:25.630 --> 37:28.510
那他的区别是什么呢 刚才我们这个

37:29.110 --> 37:34.470
这个laster modified他记录的是什么 记录的是不是你这个文件这个资源

37:35.330 --> 37:38.610
修改的时间 对不对 让我这个etag

37:39.170 --> 37:41.330
etag我所幸我就不记录

37:42.250 --> 37:46.370
你的这个修改的时间了 我干嘛呢 我是一个哈希子

37:47.450 --> 37:50.250
我是个哈希子 那你这边的话 只要就是

37:50.810 --> 37:56.090
第一次请求 请求的话 让我这边给你带一个这个etag 就是我这个资源会有个哈希子

37:56.810 --> 38:02.650
那接下来后面只要我这个资源发生了更改 让我这边的话 就会有一个新的 是不是哈希子

38:03.630 --> 38:06.750
对不对 啊 我服务器的这个资源就会有新的哈希子

38:07.230 --> 38:11.350
然后你客户端的话 把你就是我之前给你的这个哈希子

38:11.870 --> 38:16.230
带到服务器端 那服务器端就会把这个两个哈希子进行个比较

38:16.830 --> 38:21.590
啊 那如果不一样 说明什么 说明服务器端这边就已经修改了

38:22.390 --> 38:28.590
对不对 就已经修改了 说到本质的话和上面其实是一样的 这不上面的话记录的是

38:29.010 --> 38:33.850
文件修改的时间 而我这边的话是给你的一个资源的哈希子

38:36.090 --> 38:36.810
啊 我们来看一下

38:37.530 --> 38:46.090
etag存储的是文件的这个特殊标识 一般是一个哈希子 啊 然后服务器端存储的文件的一趴个字段

38:46.650 --> 38:55.770
然后之后的流程和这个last modify就是一样的了 只不过把这个时间换成了什么 换成了这个一趴个字段以及对应的

38:56.230 --> 38:59.310
哈希 啊 然后把这个if modify的sense

39:00.070 --> 39:07.990
变成了if long match 仅此而已 ok 仅此而已 啊 流程其实都是一样的 你看我这边有个图

39:08.830 --> 39:10.470
首先这边的话 第一次请求资源

39:11.790 --> 39:18.390
看一秒过来 过来的话 这样我是不把资源给你返回来 返回来同时我这边还会给你返回一个什么的 返回一个etag

39:19.070 --> 39:27.870
这etag就是一个这个哈希子 好 然后在这边 这边呢 如果有强患 就是客户端这边 客户端这边 如果有强患 是不是就一直用强患

39:28.330 --> 39:32.930
而强患失效之后 是不是重新发送请求 但这次就会带着什么呢 带着etag

39:33.770 --> 39:39.650
啊 去找服务器 啊服务器这边的话 就会检查我服务器资源的这个etag有没有方式变化

39:40.290 --> 39:47.530
如果没有变化 我给你返回什么 说返回304状态嘛 对不对 但如果有变化 有变化的话 那就干嘛

39:48.030 --> 39:50.310
是不是给你返回新的资源 对不对

39:52.710 --> 39:59.390
好 然后两者之间的一个简论对比 首先是精度上面etag要优于这个laster modified

40:00.110 --> 40:03.790
啊 你这个laster modified 我们刚才说了 它最低是什么 最低是不是秒

40:04.710 --> 40:08.390
对不对 但是你这个etag它是一个哈希子 它和时间

40:09.030 --> 40:12.670
本身没有关系 说它的这个精确度要更高一些

40:13.410 --> 40:19.210
好 第二个是性能 性能的话这个etag的话要比这个laster modified 要稍微低一些

40:19.930 --> 40:26.290
因为你这个laster modified的话 它记录的是时间 但是etag的话 它是记录的是一个什么 哈希子

40:26.770 --> 40:30.010
哈希子的话 我们要干嘛 我们是不是要通过服务器去生成啊

40:30.810 --> 40:36.130
对不对 所以性能上的话稍微要低一些 但低不了太多啊 你生成一个哈希子好快吗

40:37.050 --> 40:40.610
好 然后接下第三个就是优先级上 优先级上的话etag

40:40.910 --> 40:42.830
它比这个laster modified要高

40:43.510 --> 40:48.470
啊 要高 当然在这个实际开发中 仍然是什么 仍然是这两个一起用

40:49.430 --> 40:52.510
就和你这个强缓一样 强缓是不是这两个结合着一起用

40:53.150 --> 40:56.790
对不对 那协商缓存也是 这两个的话结合着一起使用

40:59.310 --> 41:04.470
好 这是关于这个协商缓存 而最后的话就是这个缓存的这个

41:05.190 --> 41:08.190
读取规则 我们这边让我们来做一个总结

41:09.130 --> 41:16.170
当浏览器要请求资源时 他首先的话 他会去从这个sovis walker 他优先级是最高的

41:16.570 --> 41:19.370
啊 他前提是什么 前提是你设置了这个

41:20.010 --> 41:27.290
sovis walker 你没设置的话 那这个就没 没有 就是没得说了 对吧 前提是你设置了这个sovis walker

41:27.730 --> 41:30.930
我在前面讲的时候我就说过 这个东西是不是需要我们自己去设置啊

41:31.610 --> 41:35.370
对不对啊 这这些的话不需要 这个memory catch disco catch

41:35.830 --> 41:42.630
啊 这个pushy catchpushy catch的话 我看一下他是不是需要我们去设置啊 我看一下啊

41:44.350 --> 41:51.510
啊pushy catch的话 我看一看这里啊 你可以给其他域名推送资源啊 那这边上应该是也是需要

41:52.150 --> 41:57.870
设置的 因为这个东西呢 现在确实不够普及 资料也比较少啊 所以我把它列在这里

41:58.350 --> 42:03.990
这里的话 大家就是作为一个就是了解啊 知道有这么一个东西 等后面这个

42:04.810 --> 42:10.570
慢慢慢慢这个pushy catch 他的资料比较多了之后啊 到时候我再把它展开来说一说

42:11.250 --> 42:15.090
好吧 好 那回到我们这边 回到我们这边这个读取规则

42:15.890 --> 42:22.770
好 然后首先的话是从sovis walker中获取这个内容 好 然后接下来干嘛呢 接下来查看memory catch

42:23.610 --> 42:26.490
好 然后接下来的话 这边查看disco catch

42:27.530 --> 42:32.450
disco catch 这边又细分 分成什么呢 分成强制缓存和协商缓存

42:33.030 --> 42:41.070
对不对 强制缓存和协商缓存 也就是说刚才讲的这个 按照类型来分类 强制缓存 协商缓存是属于这一块的

42:42.390 --> 42:50.710
明白吧 是属于这一块的啊 好 然后接下来的话 发送就是你上面都没有命中啊 都没有命中 然后接下来干嘛呢 发送网络请求

42:51.310 --> 42:56.910
等待网络响应 好 大家回头的话会把这个内容存入到disco catch里面

42:57.370 --> 42:59.490
然后会将这个响应内容的引用

43:00.130 --> 43:02.890
存入到memory catch里面 这些都是自动的

43:03.930 --> 43:14.210
是吧 这些都是自动的啊 但是这边把这个响应内容存入到这个disco catch里面 要看你的那个hgdp响应头是怎么配置的 就你有没有配置这些

43:15.250 --> 43:16.410
就你这边 比如说

43:17.770 --> 43:20.930
这边 你有没有配置这个 这个要看啊

43:21.910 --> 43:32.750
然后这边如果上面都没有命中 就是啊 讲到这了是吧 就发送网络请求然后放入到disco catch 然后引用放入到memory catch

43:33.350 --> 43:39.670
啊 然后最后的话将这个响应内容 如果你设置了service walker 那就放到service walker里面 ok

43:40.710 --> 43:43.830
啊 然后其中针对第三步 我这边画了一个流程图

43:44.670 --> 43:46.950
啊 我们这边我们来看一下 首先啊 这边

43:47.930 --> 43:51.290
比如说他要请求服务器了 首先看你是否是否有缓存

43:52.370 --> 43:56.770
对不对 有没有缓存啊 如果没有啊 没有那就没什么好说了 是不是直接发请求

43:57.530 --> 44:01.410
对不对 发请求 然后接下来把这个结果以及这个缓存标识

44:02.130 --> 44:09.810
返还回来 好如果有缓存 有缓存的话 然后接下来这边的话就要看一下你的这个缓存有没有过期

44:10.930 --> 44:14.930
对不对啊 如果没有过期 没有过期的话 那是不是就是直接走抢缓

44:15.350 --> 44:18.270
对不对 那就从这个缓存里面啊 获取这个数据

44:19.270 --> 44:26.870
对不对 获取这个数据 那如果过期了 过期了的话 那接下来干嘛呢 是发送请求 仍然要发送请求

44:27.950 --> 44:35.270
发送请求之后 然后接下来的话 这边看你的这个资源是否更新了 如果没有更新 没有更新我这边返回什么

44:35.590 --> 44:40.110
是返回三零四状态吗 对不对 然后最后仍然是从缓存里面

44:40.830 --> 44:41.950
来读取这个内容

44:42.870 --> 44:44.790
对不对 仍然是从缓存里面读取内容

44:45.230 --> 44:46.230
但是如果过期了

44:47.470 --> 44:53.670
过期的话 那我这个服务器我就给你返回最新的内容 对不对 以及新的缓存标识

44:54.190 --> 44:57.150
那你这边用了之后 然后存到缓存里面 说存一份

44:58.150 --> 45:03.470
对不对 存一份 这个的话就是我们这个强缓和协商缓存 它的一个

45:03.870 --> 45:06.910
整个流程啊 你可以把这个图自己看一下

45:07.650 --> 45:17.650
好 然后后面 后面的话是浏览器行为 这里的话就是我们在刷新一个页面的时候啊 我们这边可以指定 要不要

45:18.050 --> 45:19.770
就是读取缓存里面的内容

45:20.530 --> 45:25.490
怎么来指定呢 很简单 这边对应就是三种不同的这个行为

45:26.250 --> 45:31.090
首先的话 你比如说 你如果是正常的打开网页 在这个地址栏 输入这个网址

45:31.490 --> 45:33.490
他就会从这个disc catch

45:34.210 --> 45:42.530
里面去找啊 看有没有这个缓存 如果有的话就用 但前提是没有过期 对吧 好那如果没有的话就发送这个

45:42.970 --> 45:45.490
网络请求 好那这样如果你是刷新

45:46.770 --> 45:54.330
如果你是按那个F5刷新 那这个时候由于你的table没有关闭 你的这个memory catch是可以用的

45:54.730 --> 45:58.770
所以他会优先使用什么呢 优先使用memory catch

45:59.730 --> 46:02.930
可不可以啊 其次才是disc catch

46:04.130 --> 46:07.410
好 然后接下来 如果你是按住control键

46:08.450 --> 46:12.610
加这个F5 那这个叫什么呢 这个叫做强制刷新

46:13.730 --> 46:18.290
强制刷新 那这个时候浏览器他就干嘛呢 他就不会使用缓存

46:19.330 --> 46:23.890
可不可以啊 不会使用缓存啊 这个是浏览器的一些这个行为啊

46:24.610 --> 46:29.570
好 然后我们这个最后的话 我们来看一个实操案例 这实操案例的话我这边写好了

46:30.850 --> 46:35.810
我们来看一下啊 一个很简单的一个案例 让我这边的话使用这个load.js

46:37.090 --> 46:44.690
写了一个服务器啊 这个服务器的话会返回一些静态资源 这静态资源都在哪里呢 都在这个static里面

46:45.810 --> 46:53.250
看到没有 都在static里面static里面有我的html 有我的css啊 有有一张图片

46:53.730 --> 46:58.770
有一个ts啊 好 然后接下来用户如果请求我的这个服务器

46:59.730 --> 47:05.810
那回头的话 我就会把这些静态资源给他返回啊 给他返回 但是这边你要注意

47:06.290 --> 47:08.610
我这边返回的时候 我这边设置了一个什么

47:09.330 --> 47:14.210
你看我这边的话 是不是就设置了一个catch control max edge 10

47:14.850 --> 47:21.570
什么意思啊 回到我们的这边catch control 是不是强制缓存catch control 对不对 然后接下来

47:22.290 --> 47:28.770
缓存的有效时间 我设置的是多少 是不是10秒钟 对不对 然后并且的话 这边带了一个标识

47:29.330 --> 47:29.890
itag

47:31.730 --> 47:36.290
带了一个标识 ok 好 那我们这边把我们的这个服务器 我把它启动起来

47:38.380 --> 47:49.780
这边的话是3000啊 ok 启动了 坚定3000转口 好 然后接下回到这边

47:50.580 --> 47:52.260
回到这边啊 你注意

47:53.460 --> 47:57.380
啊 注意看哦 好 我这边的话 把这个letwork打开

47:58.100 --> 48:03.540
好 然后接下来我这边local host的3000啊 第一次请求 第一次请求 是不是这边

48:04.340 --> 48:11.940
都是发送真正的请求 对不对 让大家我刷新一下 你看这边的话就是干嘛呀 是不是这一次就是

48:12.580 --> 48:15.540
从这个memorycatch里面去读取

48:16.420 --> 48:21.220
对不对 因为我只设置了10秒啊 说说我刚才就赶紧刷新了 因为我害怕那个10秒

48:21.700 --> 48:23.780
时间过期了 你看这边是不是

48:24.340 --> 48:27.380
memorycatch 对不对 大家这边是不是就都是零

48:28.260 --> 48:35.060
对不对 ok 好 然后接下来的话 我再一刷新 再一刷新的话 是不是很明显现在过了10秒钟了

48:35.540 --> 48:38.420
对不对 过了10秒钟 但是我服务器那边

48:39.380 --> 48:41.860
资源有没有更新 是没有更新

48:42.420 --> 48:47.780
对不对 没有更新 这边你是可以看到这个 他会带一个这个etag的啊 比如我现在再一刷新

48:50.320 --> 48:51.280
这边request

48:52.800 --> 48:55.280
呃 这一次是 我看一下

48:58.420 --> 49:04.260
这边 这边没有 是吧 我这边让我再次刷新一下啊 现在是不是很明显过了10秒了啊 再次刷新

49:05.220 --> 49:07.140
你看 是不是就都是304了

49:08.260 --> 49:13.780
对不对 都是304了啊 然后这边呢 就是你可以看到这边是带了etag值过去了

49:15.700 --> 49:22.180
呃 哦 这里 这里 看到没有 if long match 是不是带了 这个这个就是我的etag值

49:22.900 --> 49:28.900
怎么样 这就是我的etag值啊 你这边local host 这边的话呢 raise bounce

49:30.660 --> 49:33.860
呃 我看一下local host raise bounce 这边

49:34.740 --> 49:35.780
还没有给我返回呢

49:36.420 --> 49:43.780
啊 他这边的话 刚才该看一下了 因为现在我刷新了啊 刷新了他不一样了 我这边让我再重新刷新一下

49:45.460 --> 49:48.820
啊 是不是那是304 对不对 然后

49:49.300 --> 49:49.940
然后

49:50.900 --> 49:55.300
这边并没有给我返回 我看一下 这边是request raise bounce

49:56.100 --> 50:03.460
就是在request bounce里面啊 raise bounce里面没有啊 但是你在这可以看到啊 比如我这边这个css

50:03.940 --> 50:08.180
你在这可以看到 这边是不是确认是说这边 这边会带上这个etag

50:08.500 --> 50:09.940
etag它就是一个hash值

50:11.300 --> 50:18.340
它就是个hash值啊 然后既然你这边会把它带上 带上的话在哪个字段里面呢 就在if long match里面

50:18.900 --> 50:22.580
看到没有 就在if long match里面啊 那和我们这说的时候是一样的

50:23.620 --> 50:24.180
呃 这边

50:25.860 --> 50:36.020
和这边说一样的 对不对 之后的话 它会把这个etag值带上啊 它其实就和那个if modify的sense是一样的 怎么把if modify sense

50:36.820 --> 50:39.620
改成了什么呢 改成了这个if long match

50:40.420 --> 50:48.580
ok 啊 这是一个实际的一个例子啊 简简单单的写了一个demo啊 大家下来的话可以把这个例子自己看一下

50:49.300 --> 50:55.060
啊 我这边还有个动作 看到没有啊 我这边还有个动作

50:56.420 --> 50:56.740
ok

50:59.540 --> 51:03.460
然后啊 这里这里有个问题要注意啊 这里有个问题要注意

51:05.060 --> 51:10.660
就是在我们这个实理啊 就我写的这个demo里面 如果我修改了服务器的静态资源

51:11.140 --> 51:18.420
刻骨端是没办法实时更新的 为什么呢 因为我没有设置那个hash值的改变啊 你看我这边这个代码

51:19.140 --> 51:20.660
这个代码的话 这里

51:22.260 --> 51:27.780
这里的话 是不是 这边引包 引包这边是不是哈歇 对不对哈息的话 然后接下来这边是把哈息

51:28.820 --> 51:34.580
第一次哈息给你带过去 对不对 那后期的话 我这边的话 我这边比如说这个字边发生了改变

51:35.060 --> 51:37.060
啊 我这边随便改一下 比如说把这个标题

51:38.340 --> 51:40.420
把这个标题我改成一个conner

51:42.420 --> 51:43.380
conner read

51:44.180 --> 51:46.500
啊 改成conner read之后 然后下在这边

51:47.460 --> 51:50.100
在这边你刷新啊 他是没有这个展现的

51:51.060 --> 51:53.860
克拉米亚没有展现 为什么 因为你静态资源

51:54.260 --> 52:00.740
正常情况下的话 就是你这边一旦改了之后 你这边的话会干嘛呢 会重新生成一个哈息值

52:01.220 --> 52:06.740
啊 但我这边的话没有做处理啊 但是我想通过这个例子 告诉你什么呢 告诉你

52:07.460 --> 52:14.340
就是为什么我们在做这个静态资源勾件的时候 我们要根据他的这个内容 我们在他的文件名后面

52:14.660 --> 52:16.100
加一串这个哈息值

52:16.660 --> 52:18.420
为什么啊 原因的话就是

52:20.260 --> 52:24.740
只要你修改了文件啊 只要你文件内容有变化

52:25.220 --> 52:31.220
那么对应生成的新的文件名 他后面的这个哈息值也就会发生变化

52:32.180 --> 52:37.220
那从而导致什么呢 导致你嵌入页面的文件的这个 ur 他也就发生变化

52:37.700 --> 52:40.660
啊 说说就可以干嘛呢 就可以更新缓存

52:41.620 --> 52:44.740
明白吧 就可以更新缓存啊 所以我这个例子啊

52:45.140 --> 52:49.140
我这个例子的话 我这边 我如果比如说我对这个静态资源 这个是我的静态资源吗

52:49.540 --> 52:53.300
对不对 我对他进行任意的修改 你那边刷新的话他是没有效果

52:53.940 --> 52:58.900
因为为什么呢 因为我服务器这边看不到这个 就是我没有做这个哈息的改变

52:59.940 --> 53:05.620
明白吧 我没有做哈息的改变啊 但通过这个例子的话 我也就告诉你了 为什么

53:06.100 --> 53:13.060
那你在做这个一些这个静态资源勾件的时候啊 比如打包的时候 为什么他后面会生成一个这个

53:13.460 --> 53:19.700
就是文件名后面会有一串哈息值 为什么他其实就是为了解决这个更新缓存的这个目的

53:20.660 --> 53:24.740
知道吧 就是为了解决这个更新缓存 解决这个问题

53:26.020 --> 53:31.380
ok 好 然后最后最后就是关于缓存的一个最佳实践

53:32.100 --> 53:36.820
最佳实践 然后接下来这边就分为两种 一种的话是频繁变动的资源

53:37.860 --> 53:42.020
那你这个频繁变动的资源的话 那我们这边干嘛呢 是不是我们这边就首先

53:42.420 --> 53:43.140
low catch

53:44.580 --> 53:48.500
是不是这边就是不缓存 对不对 然后配合什么呢 配合这个一TUG

53:49.140 --> 53:56.420
来验证你资源是否有效啊 这种做法的话 虽然不能接受这个节省请求的数量

53:56.980 --> 53:59.860
但是他可以减少什么呢 减少响应数据的大小

54:00.820 --> 54:07.780
对不对啊 你这边就是配合这个一TUG 我这边如果资源没有过期的话 我就给你返回一个状态嘛

54:08.180 --> 54:15.300
我至少不用再给你返回资源了嘛 对不对 虽然你资源频繁的在变动啊 但是我这边如果没有更新的话

54:15.780 --> 54:18.740
那你这边那就我就不用再给你重新返回

54:19.380 --> 54:23.700
这个新的资源啊 然后对于这个不常变换的资源

54:24.340 --> 54:28.820
如果不常变换的资源 那我这边就给你干嘛呀 我这边是不是就给你设置一个

54:30.100 --> 54:36.580
很大的一个这个缓存的这个时间 对不对 然后他每次都会干嘛呢 每次都会命中这个强缓

54:37.780 --> 54:41.540
每次都会命中强缓 对不对 上面的话他是不会命中强缓的

54:42.180 --> 54:44.660
对不对啊 这边的话他就是每次会命中强缓

54:45.620 --> 54:47.700
但每次命中强缓 这里就会涉及到一个问题

54:48.500 --> 54:51.300
比如我这边 这边这个很大 我设置的是一年

54:52.100 --> 54:56.980
很大 那我万一我服务器发生了变化怎么办呢 其实就是我们上面所讲的

54:57.460 --> 54:58.260
就我们上面这边

54:58.900 --> 55:04.980
所讲的啊 为了解决这个问题 我们需要在文件名后面添加一个哈西兹

55:05.700 --> 55:11.300
啊 然后接下来版本号啊 要么哈西兹要么版本号 反正就是一些动态的制服

55:11.860 --> 55:14.980
啊 然后之后的话我们只需要更改这些动态的制服

55:15.540 --> 55:16.100
就可以了

55:16.820 --> 55:25.380
可不可以啊 这就是这个缓存的一个最佳实践啊 针对两种就是不同类型的这个资源 我们该如何来做缓存

55:26.260 --> 55:30.020
OK啊 这个的话就是这节课啊 关于这个整个

55:30.340 --> 55:38.100
浏览器这个缓存啊 我说了哈 我一开始就说了这这节课啊 比较偏理论啊 可能大家听到的话也觉得这个

55:38.660 --> 55:43.540
实操不知道该怎么实操 实操的话你这边的话就是一般这个是服务器给你返回的

55:44.500 --> 55:50.980
可能没有 你看我这边都是服务器是不给你返回的 对不对 但是我们作为前端的话 我们要了解这些知识

55:52.420 --> 55:56.740
知道吧 一定要了解这些知识啊 你知道就是别人一说 强缓

55:57.220 --> 55:59.380
协商缓存 要知道是什么意思吗

56:00.100 --> 56:09.300
对不对 你不能说听都没听过吗 这个就说不过去了嘛 对不对 OK 好 然后这节课就先到这里啊 大家下来的话可以把这个

56:09.700 --> 56:13.540
这篇文档啊 自己再好好看一下啊 好 再见

