WEBVTT

00:01.140 --> 00:05.500
大家好 我是谢老师 这些课的话 我们来看一下这个

00:06.260 --> 00:12.400
vivo walker 啊 这个的话 我们在上就前面讲那个跨标签页通信的时候

00:12.920 --> 00:15.480
我们提到过一个这个shared walker

00:16.000 --> 00:20.600
对吧 我当时就说这个shared walker的话 它是vivo walker的一种

00:20.860 --> 00:25.200
啊 说说我们这边的话 就把这个vivo walker来给大家介绍一下

00:25.720 --> 00:27.520
好 这个vivo walker

00:28.280 --> 00:30.580
他出现的背景是什么呢

00:30.900 --> 00:32.880
我们都知道我们的这个java script

00:33.140 --> 00:36.720
它是不是它是一门这个单线程执行的这个语言

00:37.240 --> 00:39.800
对不对 也就是说浏览器里面只有一个线程

00:40.060 --> 00:41.580
来执行我们的这个代码

00:42.100 --> 00:44.140
那只有一个线程的话就会有个问题

00:44.660 --> 00:49.780
就如果我们的代码啊 就是如果全部都是同步的代码 因为我们知道java script里面代码

00:50.040 --> 00:51.060
有同步有异步

00:51.320 --> 00:54.900
对吧 异步都还好 异步的话他会扔给这个异步处理模块

00:55.160 --> 00:58.740
啊 异步处理模块来处理 处理完了之后然后扔到对列里面

00:58.940 --> 01:01.500
异步都还好 关键是这个同步

01:02.540 --> 01:05.340
同步的话 你如果同步的某一段代码

01:05.860 --> 01:08.420
啊 非常非常的就是计算量非常非常的大

01:08.680 --> 01:10.720
他就会出现什么呢 他就会出现

01:10.980 --> 01:11.500
主设

01:12.260 --> 01:15.840
然后后面的代码就不会什么呢 就不会执行

01:16.860 --> 01:19.940
看到没有 比如我这边举个例子啊 我这边写个死循环

01:20.700 --> 01:22.500
vile2死循环

01:22.760 --> 01:25.060
那只要你写这个好完蛋了

01:25.320 --> 01:27.620
后面所有的同步代码

01:27.780 --> 01:31.060
就全部被主设啊 应该说后面的话无论同步还是异步

01:31.320 --> 01:34.740
因为你这边一被主设是不是后面都走不到后面去

01:35.500 --> 01:36.500
对不对啊

01:37.500 --> 01:41.040
所以说html5的话他就提出了一个什么呢 他就提出了一个

01:41.300 --> 01:42.160
vibre walker

01:42.660 --> 01:44.980
啊 这个的话就可以解决这个问题

01:45.500 --> 01:47.020
他干嘛呢啊 我们来看一下

01:47.280 --> 01:49.080
html5的vibre walker

01:49.340 --> 01:53.420
可以让vibre应用具备后台处理的能力

01:54.180 --> 01:56.500
他支持什么呢 支持多线程处理

01:57.260 --> 01:59.820
看到没有 你以前的话你是单线程

02:00.580 --> 02:02.140
单线程只有一个线程

02:02.640 --> 02:05.200
来解释执行这个GS代码 那没办法

02:05.460 --> 02:06.740
主设了就主设了

02:07.000 --> 02:10.320
对吧 主设就等着呗 那有什么办法呢 我就只有一个线程

02:10.840 --> 02:13.140
对不对 但现在的话有这个vibre walker

02:13.400 --> 02:16.220
那我就可以干嘛呢 我就可以支持多线程

02:16.980 --> 02:20.300
我可以把这个就比如说比较耗实的一些计算

02:20.560 --> 02:21.340
或者代码

02:21.840 --> 02:22.860
我把它就是

02:23.640 --> 02:25.180
交给另外一个线程来处理

02:25.900 --> 02:29.220
看到没有啊 因此的话可以充分利用

02:29.480 --> 02:31.540
多核cpu带来的优势

02:32.040 --> 02:35.380
啊 这就是vibre walker 他解决什么问题

02:36.400 --> 02:38.700
好 然后我们这边的话就把这个vibre walker

02:38.960 --> 02:42.280
我们来介绍一下 分为这么几个点 首先是这个概述

02:42.540 --> 02:45.360
概述的话其实上面的话就介绍的差不多了

02:45.620 --> 02:49.700
那第二个 第二个的话我们就是来看一个vibre walker的一个使用势力

02:50.740 --> 02:55.080
第三个 第三个就是使用vibre walker实现跨标签页通信

02:55.220 --> 02:57.440
这个部分的话 我们在前面

02:57.700 --> 03:01.020
讲那个跨标签页通信的时候 我们是不是已经介绍过了

03:01.780 --> 03:05.380
对不对 说这个部分的话可以不看啊 所以我们这边主要把这两个

03:05.640 --> 03:06.140
看一下

03:06.660 --> 03:08.440
ok 那一个一个来

03:08.960 --> 03:11.260
那首先是关于vibre walker的这个概述

03:11.520 --> 03:17.140
啊 刚才也提到了vibre walker的话他是一项什么的 他是一项后台处理技术

03:18.180 --> 03:19.700
对不对 把这段话看一下嘛

03:20.300 --> 03:26.140
在此之前javascript的创建vibre应用程序中啊 因为所有的处理都是单线程

03:26.780 --> 03:29.140
如果某一个啊 他执行的时间太长

03:29.900 --> 03:35.780
那干嘛呀 那我们的程序界面就会长时间处于停止状态 因为他要去处理那段脚本嘛

03:36.420 --> 03:42.300
对不对 如果你的等待时间超出一定限度 浏览器就会进入到假实状态

03:42.940 --> 03:47.580
可能大家现在没有遇到过假实了啊 我记得我最早刚开始上网的时候

03:48.140 --> 03:50.900
啊 有些时候进入这个网页就直接就加死了

03:51.580 --> 03:56.300
那直接就加死了就卡来不动了啊 但现在的话 慢慢遇不到了啊

03:57.100 --> 03:58.580
现在有很多优化的手段

03:59.540 --> 04:01.140
好 为了解决这个问题

04:01.780 --> 04:08.540
html5的话 新增了一个vibre walker api 啊 使用这个这个api

04:09.180 --> 04:14.340
用户可以很容易的创建一个什么的后台运行的现成

04:15.340 --> 04:20.780
看到没有 后台运行的现成 就是你之前的话 你处理这个java script 是不是单线程

04:21.340 --> 04:25.380
对不对 只有一个线程 好没关系 我现在给你创建个线程

04:26.460 --> 04:31.620
看到没有 我给你创建个线程 那这个线程被称之为什么呢 称之为walker

04:32.540 --> 04:38.740
所以说在前面我在讲那个跨标签通信的时候 我就说啊 我们这要创建个walker 创建个walker

04:39.100 --> 04:41.620
什么意思啊 就是创建一个线程的意思

04:42.580 --> 04:50.420
没有吧 好 然后将什么呢 将这个耗费时间比较长的这个处理 交给后台来执行

04:51.300 --> 04:58.180
啊 那你对于这个前台页面来讲的话 你那些不好使的处理 是不是直接处理就可以啊 因为那些处理的话它不好使

04:58.820 --> 05:02.020
对不对 直接处理就行了啊 这个就是vibre walker

05:02.700 --> 05:04.860
好 我们来看一下vibre walker有哪些特点啊

05:05.820 --> 05:15.180
首先通过夹载一个接视文件啊 到时候我们是不是要创建一个walker 对不对 walker的话 实际上就是一个什么呢 就是一个接视文件啊

05:15.820 --> 05:23.260
通过夹载一个接视文件来进行大量复杂的计算 而不挂起主线这个主进程

05:23.980 --> 05:30.060
啊 也就是它不会影响你的这个呃 执行那个接视代码的那个线程 不会影响的啊

05:30.620 --> 05:37.060
然后主线程和这个线程之间可以进行通信 怎么通信呢 通过post的message和unmessage

05:37.780 --> 05:46.670
来进行一个这个通信啊 这边是通信 这边是还写错了 是吧 通信啊 通信

05:47.670 --> 05:55.670
好 然后这边的话 可以在walker中通过这个import script来加载其他的这个接视啊 接视代码

05:56.270 --> 06:00.470
就是其他的接视脚本文件 然后可以使用set timeout

06:01.430 --> 06:05.390
clear timeout 然后set interval clear interval这些方法

06:06.190 --> 06:13.070
啊 可以发这个阿加克斯请求 可以访问levelgator啊 可以使用javascript的核心对象

06:13.630 --> 06:18.510
啊 这是他的一些特点啊 然后接下来的话 他也有一定的局限性

06:19.030 --> 06:24.110
比如说不能跨域加载接视 然后不能什么呢 不能访问动物 这点你一定要注意

06:25.110 --> 06:31.750
这点你一定要注意啊 在walker里面 这样我们的walker里面 他是不能跟什么的 不能访问这个动物的

06:32.510 --> 06:37.110
这点一定要注意啊 然后还有就是什么呢 使用这个web walker加载这个数据

06:37.750 --> 06:45.390
没有这个jsonp和阿加克斯加载数据高效啊 这是他本身的一些局限性啊 这个注意一下就好了

06:46.230 --> 06:50.030
好 然后下面的话是关于这个web walker他的一个兼容性

06:50.910 --> 06:54.990
目前来讲的话 基本就没有太大问题了 对吧 你看连i1

06:55.710 --> 07:02.590
啊 连这个这么弱的i1 i10和i11他都支持 那基本就没什么问题 这么一片绿

07:03.390 --> 07:05.310
对不对 形式大好 ok

07:06.310 --> 07:09.150
好 然后下面 下面的话就是关于这边

07:10.430 --> 07:16.510
使用这个web walker之前啊 一些属性和方法 我们来看一下啊 这个其实我们之前接触过一期了

07:17.150 --> 07:18.950
比如什么呢 比如这个poster message

07:20.230 --> 07:27.910
是不是这个发送消息啊 按message干嘛 是不是 接收消息 他是一个什么 他是个事件 对不对 这个是个事件 这个是一个

07:28.350 --> 07:34.310
方法啊 那这个self self的话表示本线程范围内的作用语

07:35.230 --> 07:40.070
然后还有一个是这个import script 这个是什么呢 这个就是你在这个walker

07:40.990 --> 07:47.710
walker内部 你如果要夹载其他脚本 那你可以使用这个方法啊 这边他可以接收

07:48.190 --> 07:53.630
好几个参数 就你如果要夹载多个外部脚本 你可以使用这个方法

07:54.470 --> 07:58.270
ok啊 这是关于这个web walker 一个简单的介绍

07:59.310 --> 08:05.710
好 然后完事之后 然后我们这边呢 我们就来看一个快速入门势力啊 我们这边来看一个快速入门势力

08:06.750 --> 08:13.870
首先的话 要使用这个web walker啊 方法非常简单 干嘛呢 你new一个web walker就可以了

08:14.670 --> 08:19.310
看到没有 你有一个web walker啊 然后接下来干嘛呢 传入一个

08:19.870 --> 08:22.270
json文件啊 也就是说比如说这里

08:23.270 --> 08:25.230
这里 你看我这边的话 是不是有一个这个

08:26.110 --> 08:28.190
html 然后我这边的话有一个这个

08:28.910 --> 08:32.910
把这名字改一下 改成walker好一点 对吧 不要叫walk 叫walker

08:33.950 --> 08:38.670
啊 walker的话 它本质就是一个什么 是不是就是一个json文件

08:39.390 --> 08:42.750
对不对 好 然后接下来在这边 你这边script

08:44.030 --> 08:49.070
然后你在这里的话 你就new new 一个web walker

08:51.570 --> 08:55.010
web 我看这边是什么 啊 new 一个walker

08:56.290 --> 08:57.810
new 一个walker

08:59.010 --> 09:03.170
看到没有 new 一个walker就可以了 new 一个walker 然后这里的话

09:04.130 --> 09:07.490
传入什么呢 传入就是你这个json文件

09:08.610 --> 09:12.610
当前目录下面的walker.js

09:12.850 --> 09:17.250
那你就这个样子 这个样子的话 它就创建了一个这个walker

09:17.650 --> 09:19.330
也就是说打开了一个新的现成

09:20.130 --> 09:23.090
明白吧 okay 好 然后继续啊

09:24.370 --> 09:32.290
啊 这里传入的这个uil啊 可以是相对也可以是绝对啊 只要是相同的协议 主机和端口即可 okay

09:33.010 --> 09:40.130
好 然后如果 如果想获取walker进程的返回值 你可以绑一个安卖设计属性

09:40.370 --> 09:41.890
这是前面介绍过的

09:42.450 --> 09:43.490
对不对 这个是个实践

09:44.210 --> 09:45.810
相当于jntmessage实践

09:46.930 --> 09:52.370
对不对jntmessage实践啊 这边那就是walker 也就是这里

09:52.850 --> 09:59.490
这个的话我说它是个现成嘛 对不对 它是个现成 它你把那个一些耗时的操作就交给它来执行

09:59.730 --> 10:05.010
它执行完了之后 如果有些结果它要返回来 让我们干嘛呢 我们在这个html里面

10:05.330 --> 10:09.490
我们绑定一个message实践啊 jntmessage实践就可以了

10:09.970 --> 10:12.610
然后walker那边干嘛呢 你猜都猜得到

10:13.090 --> 10:16.610
walker里面的话 它是不是就通过posedmessage

10:17.410 --> 10:21.330
对不对 通过posedmessage把这个数据给你返还出来

10:23.010 --> 10:29.330
好 然后接下来这里啊 当后台walker的posedmessage方法调用时

10:29.570 --> 10:33.890
该事件指的就是这个message事件 它就会触发

10:34.770 --> 10:38.770
可能就会触发 okay 这是它的一个基本使用

10:39.330 --> 10:43.490
好 那接下来我们这边我们来看一个基本的这个例子 然后把这个例子我们把它写一下

10:44.370 --> 10:46.050
好html我这边就拿过来了啊

10:47.570 --> 10:51.170
各式画一下html这边有一个这个p

10:52.530 --> 10:55.490
然后接下来这边有一个output 这边是result

10:55.970 --> 11:01.090
那这边有两个button 一个是开始工作 一个是停止工作 这边我们来看一下

11:02.050 --> 11:08.210
啊 就是这样子的 这边技术 然后接下来这边是空的啊 这边的话是什么呢 这边是这个output

11:08.850 --> 11:14.770
output 只不过它现在是空的啊 然后两个按钮 一个开始工作 一个停止工作 okay

11:15.490 --> 11:21.090
好 然后接下来的话我这边干嘛呢 我这边的话先获取一下两个按钮

11:22.690 --> 11:30.930
这边const一个startbutton等于一个document.get element by id

11:33.620 --> 11:35.460
这边start

11:36.260 --> 11:36.740
btn

11:39.980 --> 11:42.300
好 然后接下来的话这边stopbtn

11:44.140 --> 11:44.540
ok

11:46.540 --> 11:52.940
好 把这个获取到好 获取到之后 然后接下来我们这边let一个walker

11:54.060 --> 11:57.020
这要是什么呢 这个的话就是用于存署

11:59.180 --> 12:00.700
用于存署

12:02.700 --> 12:04.140
存署这个walker

12:05.100 --> 12:05.500
进程

12:06.780 --> 12:11.420
啊好 然后接下来下一步 下一步的话我们这边给他绑定一个按钮

12:12.140 --> 12:17.900
不不不 我在说啥 给他绑定一个事件啊 绑定一个这个click事件

12:18.860 --> 12:20.540
等于一个function

12:21.420 --> 12:29.260
好 也就是说当用户点击这个开始工作的时候 对吧 点击的时候 然后接下来我们这边要做什么事情呢 我们这边要做技术

12:30.140 --> 12:34.220
啊 我们要做技术啊 有的同学说这个技术还不简单吗 对不对

12:35.260 --> 12:38.540
创建一个变量啊 这个变量 然后接下来不停的这个

12:39.260 --> 12:44.620
搞一个这个set interval 对吧 set interval 然后接下来一直技术 记了之后 然后把这个值

12:45.180 --> 12:50.780
接下来渲染到这 这个很简单呀 但是我们现在要做的是什么呢 我不在我这边来技术

12:51.660 --> 12:53.820
我干嘛呢 我让walker来技术

12:54.540 --> 13:00.140
看到没有 我让walker来做walker做了之后 他把这个值返回给我

13:01.020 --> 13:04.860
看到没有 哎 那我这边怎么办呢 那我这边呢 就首先

13:06.140 --> 13:06.540
walker

13:07.180 --> 13:09.740
等于一个new walker

13:10.780 --> 13:13.260
然后把什么 把这个你的这个walker

13:14.940 --> 13:21.980
walker.json 是不传进去啊 对不对 首先的话创建一个这个walker 创建一个walker之后

13:22.860 --> 13:24.300
然后接下来的话这个walker

13:24.860 --> 13:27.420
然后就gnt什么的gnt message

13:28.300 --> 13:31.260
message时间 好 然后接下来的话这边function

13:33.220 --> 13:34.980
好 然后接下来的话这边接收

13:35.780 --> 13:43.140
传递过来的这个内容啊 那这边的话我们也不着急 我们一步一步来 我们首先干嘛呢 把它打印出来

13:43.860 --> 13:50.660
对不对 把它打印出来 ok 好 然后接下来的话我们这边创建了walker 那接下来的话在这边

13:51.300 --> 13:52.980
walker这边就要写代码

13:53.620 --> 13:56.660
好 这边这边的话其实就和你普通的json是一样的

13:57.380 --> 13:59.620
知道吧啊 比如说我这边net一个

14:00.580 --> 14:05.780
cnt 等于一个从0开始啊 然后接下来的话我这边

14:07.860 --> 14:08.740
set mode

14:10.660 --> 14:10.980
嗯

14:12.740 --> 14:20.820
好 这边的话就用set intro啊set intro 然后加这边是你要做的事情 对吧 然后每个

14:21.380 --> 14:29.140
一秒钟做这个事情 那我要做什么事情呢 我这边的话每个一秒钟 我这边的话就挨加加一下

14:29.620 --> 14:36.580
我不是挨加加cnt 加加一下 加加了之后 然后接下来后我这边调用post的message

14:37.300 --> 14:39.300
post的message 我把你的这个cunt

14:40.740 --> 14:46.420
给你传递过去啊 我把这个给你传递过去 然后接下来就会触发什么 是不是就会触发

14:46.740 --> 14:50.900
这个message事件 然后接下来是不是到达这里 让我把它打印出来

14:51.540 --> 14:53.540
看到没有 好 然后接下来

14:54.020 --> 15:02.100
完事之后 然后每个一秒啊 okay就完了啊就完了 walker就做这个事情啊就做这个事情

15:02.500 --> 15:04.340
好 然后接下来的话我这边保存一下

15:05.860 --> 15:11.620
保存了之后 然后我们过来摟一眼啊啊开始工作 看到没有

15:12.660 --> 15:17.060
看到没有 这边data 1 2 3 4 5 6

15:17.620 --> 15:20.340
看到没有 是不是拿到了 对不对 message event

15:21.060 --> 15:26.980
就拿到了啊 但他有一些其他的信息啊 但我们主要要什么呢 我们主要要data

15:27.860 --> 15:31.780
对不对 我们主要要data okay啊 拿到这个data之后

15:32.980 --> 15:35.700
我们这边干嘛呢 我们这边就可以设置一下

15:37.140 --> 15:41.540
好 我们这边的话就是这个result 是吧 那我们这边呢就是document

15:42.500 --> 15:44.980
点query selector

15:45.300 --> 15:51.540
然后挺好result 设置什么呢 设置他的inner html

15:52.020 --> 15:55.140
等于一个event点点data

15:56.260 --> 15:57.460
对吧 好 保存

15:58.340 --> 16:01.700
保存了之后 然后接下来的话 这边重新来开始工作

16:03.460 --> 16:07.940
看到没有 这边技术是不是就开始了 对不对 但这个功能本身没什么

16:08.340 --> 16:10.580
啊 功能本身没什么 但是我们这边

16:11.060 --> 16:17.220
演示的是什么呢 我们这边的话是把这个工作交给谁 是不是交给这个walker来做的

16:18.100 --> 16:26.660
对不对 交给这个walker来做的 walker做了之后 然后接下来他把这个干嘛呢 他把这个结果通过post的message

16:26.900 --> 16:29.220
是不是返回给我们的主线程

16:30.180 --> 16:32.820
对不对 两个线程之间是不冲突的

16:33.460 --> 16:34.260
啊 不冲突的

16:34.980 --> 16:36.100
明白吧 okay

16:36.740 --> 16:37.060
好

16:37.940 --> 16:40.100
然后这个是开始 然后接下来还有个停止

16:40.900 --> 16:44.100
停止的话 然后我们这边的话 也给他绑定一个实践

16:45.220 --> 16:48.500
点on click 等于一个function

16:50.180 --> 16:55.220
好 然后接下来我要停止 也就是说我这边alker啊 我接下来的话 我要把这个

16:55.780 --> 17:01.380
这个线程 我把停掉 怎么做呢 很简单 这边的话 walker 调一个方法

17:02.500 --> 17:05.300
这个方法叫做什么呢 叫做这个terminate

17:08.930 --> 17:15.970
看到没有 调这个方法 terminate terminate 就是这个终止的意思啊 然后接下来的话把这个walker

17:17.010 --> 17:18.530
复制为lun

17:19.250 --> 17:23.330
啊 okay 把清空就完事了 好 我们来看一下好不好使啊

17:24.050 --> 17:24.930
好 开始工作

17:26.690 --> 17:30.530
啊 这边是不是开始技术啊 对不对 开始技术好 然后停止

17:32.640 --> 17:35.280
是不是就ok了 对不对 就ok了

17:35.840 --> 17:42.880
看到没有啊 这就是这个一个web walker 一个快速入门的这个势力啊 当然代码的话也在这边

17:43.440 --> 17:45.120
啊 也在这边 ok

17:46.080 --> 17:49.360
好 然后后面 后面的话是使用web walker

17:49.840 --> 17:56.800
实现跨标签页通信啊 这个的话 我们之前在讲这个跨标签页通信的时候 我们代码是写过的

17:57.280 --> 18:02.720
对不对 那我们这边就简单介绍一下 就是我们web walker的话 他分为两种类型

18:03.680 --> 18:08.720
你注意 他分为两种类型 哪两种类型呢 一个是专用线程

18:09.520 --> 18:15.920
就我们刚才那个刚才那个就是专用线程 什么意思啊 就你这边一个页面对吧 一个页面你这边是不是new了一个walker

18:16.240 --> 18:20.480
对不对new了一个walker什么创建了个线程啊 这里不应该叫进程 这边是线程

18:22.480 --> 18:29.280
线程啊 你这边的话就是创建了个线程 那这个线程的话是我这个页面专用的

18:30.240 --> 18:33.440
明白吧 我回头的话 我比说再创建一个html

18:34.080 --> 18:41.360
再创建一个html 我再new一个walker 那new出来的那个walker就是新的html页面专用的

18:42.000 --> 18:48.560
就这个意思 对不对 就这个意思啊 那他除了这个专用呢 还有什么呢 还有共享线程

18:49.280 --> 18:52.000
共享线程sharedweb walker

18:52.720 --> 18:54.400
那就是什么呢 那就是你这个

18:55.440 --> 18:59.440
几个这个页面创建出来的这个线程 他们是共用的

19:00.320 --> 19:01.760
是共用的啊 就这个意思

19:02.400 --> 19:08.320
可不可以啊 我们这边我们来看一下 这边的话这个专用线程啊 随当前页面的关闭而结束

19:08.800 --> 19:12.640
这意味着专用线程只能被创建他的页面法问

19:13.440 --> 19:16.080
可不可以啊 只能被创建他的页面法问

19:16.560 --> 19:22.960
而这个预知相对的是这个共享线程 他是什么 他是什么呢 他是同时有多个页面线程连接

19:23.760 --> 19:30.160
你看我们前面做了一个跨标签页通信 那是不是就是要多个页面共享一个线程

19:31.200 --> 19:35.120
对不对 那那个时候肯定得创建什么呢 创建这个共享线程

19:35.760 --> 19:39.520
啊 所以这边的话就不再是newwalker了

19:39.920 --> 19:43.120
而是new一个什么呢 new一个shared walker

19:44.080 --> 19:46.560
没有吧 new一个shared walker

19:47.760 --> 19:53.200
ok 好 然后这下面的代码的话 就是我们那个前面讲的跨标签页通信的那个代码

19:53.680 --> 19:54.640
啊 这个就不说了

19:55.280 --> 20:00.320
好吧啊 这就是官员这个web walker啊 但我这边呢只是简单介绍了一下而已

20:00.960 --> 20:08.240
没有吧 你回头的话 你完全可以使用这个web walker做一些更复杂的这个应用啊 这个的话就看你这个在工作当中

20:08.720 --> 20:09.920
一个真实的需求了

20:10.480 --> 20:16.960
啊 我们这边呢是因为讲面识题 讲面识题的话 顺带就把这个知识点给大家讲一讲啊

20:17.600 --> 20:21.600
好 这就是关于这个web walker 大家下来的话可以再看一看

20:22.160 --> 20:24.800
好吧啊 这期课就先到这里啊 再见

