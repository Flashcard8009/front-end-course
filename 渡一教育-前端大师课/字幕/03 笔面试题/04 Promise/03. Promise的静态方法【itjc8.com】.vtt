WEBVTT

00:00.880 --> 00:09.880
我上课的时候 举的那个登革的例子 都是开玩笑

00:09.880 --> 00:15.880
都是为这个把这个知识给大家讲得透彻一点 讲得有趣一点

00:15.880 --> 00:20.880
这并不代表它是真的 因为我这课呢 还是要给大家说清楚

00:20.880 --> 00:26.880
也并不代表我的价值观 反正就是举例子 下举例子

00:26.880 --> 00:29.880
声明清楚 别拿这个来说事

00:31.880 --> 00:35.880
声明清楚了 我们就可以接着来登革了 登革是个连续剧

00:35.880 --> 00:41.880
他又遇到新闻的问题了 之前表白可能成功了 已经开始在一起过日子了

00:41.880 --> 00:45.880
这个时候 登少出门 他给登革交代了几个任务

00:45.880 --> 00:50.880
今天让你把饭给我做了 衣服洗了 然后卫生给他打烧了

00:50.880 --> 00:55.880
就这么三件事 那么这三件事呢 不需要登革亲自去做

00:55.880 --> 01:00.880
但是你要去操作一下 比方你做饭的时候 谁还亲自做饭啊 都交给电饭宝

01:00.880 --> 01:05.880
洗衣服那是交给洗衣机 打烧卫生的交给炒的滴汽软

01:05.880 --> 01:12.880
但是你要去操作 对不对 而且他去完成这些事呢 需要一段时间

01:12.880 --> 01:18.880
登少呢 他就要求你把这些事做了 全部成了呢

01:18.880 --> 01:21.880
你给我汇报一下 都成了 问题了

01:21.880 --> 01:25.880
如果说有失败了 你要给我汇报一下 到底怎么回事

01:25.880 --> 01:31.880
你为什么干不成 对吧 回来要不要汇键盘 对吧 这些事情呢 要汇报一下

01:31.880 --> 01:36.880
那么登革在做这个事的时候呢 他就有两种选择

01:36.880 --> 01:40.880
第一种呢 就像以前表白的样子 前面那件事完了之后

01:40.880 --> 01:47.880
我再去做后面的那件事 那么在这个例子里边 显然不合适

01:47.880 --> 01:52.880
然后你做电饭 就是做饭的时候 你把电饭帽打开 他要做一个小时

01:52.880 --> 01:56.880
你就在那里等一个小时 没必要吧 对吧 让他去做

01:56.880 --> 02:02.880
然后呢 你就自己去做别的事 比如说打开洗衣机 把衣服扔进去

02:02.880 --> 02:06.880
然后呢 打开扫地机去了 让他去干活

02:06.880 --> 02:08.880
最后呢 来搜结果我就完成了

02:08.880 --> 02:13.880
因此 在这一次 跟之前的表白那个场景不一样吗

02:13.880 --> 02:18.880
这一次呢 登革了他决定 为了最大程度的节约时间

02:18.880 --> 02:23.880
他把这些任务呢 同时进行 最终的把结果汇总

02:23.880 --> 02:29.880
比方说你做饭 按了过后你就不管了 洗衣机 衣服扔进去不管了

02:29.880 --> 02:34.880
扫地机去了 打开之后不管了 让这些他们自己去做

02:34.880 --> 02:36.880
做完了之后呢 他总会有个回馈嘛

02:36.880 --> 02:39.880
比方说他做了一个小时成功了 他做了一个半小时失败了

02:39.880 --> 02:45.880
他做了两个小时成功了 那么所有的任务加起来也就是两个小时

02:45.880 --> 02:47.880
懂的意思吧 同时进行

02:48.880 --> 02:51.880
完事之后呢 我们把最终的结果来汇总

02:51.880 --> 02:54.880
两个小时过后都完了吧 对吧

02:54.880 --> 02:58.880
那你第一个成功了 第二个失败了 第三个成功了

02:58.880 --> 03:00.880
那么这样子呢 就把它做一个汇总消息

03:00.880 --> 03:06.880
其实这个汇总啊 也可以把它看成是一个任务

03:06.880 --> 03:12.880
对吧 他要等其他的任务都完成之后 那么这个任务才能完成

03:12.880 --> 03:13.880
这就是汇总

03:14.880 --> 03:18.880
从单一码的层面来表示的话 下面有一段伟大码

03:18.880 --> 03:22.880
比方说这里写了三个函数 一个是Cook 做饭

03:22.880 --> 03:24.880
你只认识一下吧 这个函数也没什么复杂的

03:24.880 --> 03:26.880
返回一个Promise 对吧 一个任务

03:26.880 --> 03:32.880
然后呢 等了两秒钟之后 有可能翻译OK 有可能失败

03:33.880 --> 03:39.880
洗衣服一样的 等了2点5秒 有可能成功 有可能失败

03:40.880 --> 03:45.880
打烧卫生一样的 等了 这里多等一会吧 等了三秒钟

03:46.880 --> 03:49.880
那么他有可能成功 有可能失败

03:49.880 --> 03:51.880
对吧 我就写了这么三个函数

03:51.880 --> 03:56.880
那么接下来的要求是 你如何利用这三个函数

03:57.880 --> 03:59.880
让这些任务同时进行

04:00.880 --> 04:03.880
然后最终又可以汇总成一个结果

04:04.880 --> 04:06.880
其实同时运行它并不难

04:07.880 --> 04:10.880
我们来看一下 同时运行这些任务它并不难

04:10.880 --> 04:13.880
我们来写个介绍 把这三个函数扔进来

04:13.880 --> 04:17.880
我这里把他择定一下 不用去看他怎么去实现了

04:17.880 --> 04:18.880
总之这三个函数就是三个任务

04:19.880 --> 04:22.880
那同时应该非常简单 第一个函数调用它

04:22.880 --> 04:25.880
第二个函数调用它 不就同时进行了吗

04:26.880 --> 04:30.880
我又没有说 第一个函数的后续处理中去调用下一个

04:33.880 --> 04:35.880
就同时进行了 运行你看

04:36.880 --> 04:37.880
就同时进行了

04:38.880 --> 04:40.880
然后有些失败了 有些成功了

04:40.880 --> 04:42.880
对不对 这不是同性

04:42.880 --> 04:43.880
那如果说要穿行怎么办

04:43.880 --> 04:46.880
就让你之前表白 上一个结束之后再运行下一个

04:46.880 --> 04:47.880
大概怎么写

04:48.880 --> 04:52.880
然后先做完 做完完了过后 后续处理呢

04:53.880 --> 04:55.880
我再去什么 洗衣服

04:56.880 --> 04:58.880
对吧 后续处理我调用卧型

04:58.880 --> 05:00.880
这样子有些同学看不懂了

05:00.880 --> 05:02.880
这样子就能看懂了

05:02.880 --> 05:03.880
那返回吗

05:03.880 --> 05:06.880
那函数是不是返回可以直接这样子写

05:08.880 --> 05:09.880
对吧 你做完做成功了

05:09.880 --> 05:12.880
然后我就去洗衣服 返回个promage

05:12.880 --> 05:14.880
好 如果我洗衣服写完了之后

05:14.880 --> 05:16.880
我再去打扫卫生

05:17.880 --> 05:19.880
对吧 这不就是穿行吗

05:20.880 --> 05:21.880
就是穿行

05:22.880 --> 05:23.880
然后你看 先做饭

05:23.880 --> 05:25.880
做饭完了过后再洗衣服

05:25.880 --> 05:27.880
洗衣服完了之后呢

05:27.880 --> 05:29.880
再打开扫地机器的

05:30.880 --> 05:32.880
扫地机器的然后失败了

05:33.880 --> 05:34.880
这就是穿行

05:34.880 --> 05:36.880
同时进行的就非常简单

05:36.880 --> 05:37.880
我不用在后续处理边处理

05:37.880 --> 05:38.880
我直接就调用了

05:39.880 --> 05:41.880
先去做饭 再去洗衣服

05:41.880 --> 05:42.880
再直接打扫卫生

05:43.880 --> 05:45.880
那至于做饭的后续处理呢

05:45.880 --> 05:46.880
我这里没管

05:46.880 --> 05:48.880
洗衣服的后续处理我这里没管

05:48.880 --> 05:50.880
打扫卫生的后续处理我没管

05:50.880 --> 05:52.880
这样子符合要求吗

05:53.880 --> 05:57.880
这样子倒是可以让他们同时进行

05:57.880 --> 05:59.880
但是我怎么汇总呢

05:59.880 --> 06:02.880
问题是我在哪里写汇总代码呢

06:03.880 --> 06:04.880
请问你你帮我写一下

06:04.880 --> 06:06.880
我在哪里写汇总代码

06:07.880 --> 06:09.880
你说这里写 这里写你咋写

06:10.880 --> 06:11.880
你怎么知道

06:11.880 --> 06:12.880
这个时候你怎么知道他成功呢

06:12.880 --> 06:13.880
他什么时候成功

06:13.880 --> 06:14.880
他什么时候成功

06:14.880 --> 06:15.880
他什么时候成功

06:15.880 --> 06:16.880
哪个成功时候失败

06:16.880 --> 06:17.880
所以都不知道

06:17.880 --> 06:20.880
那你说我在这里写可以吗

06:21.880 --> 06:23.880
我在这里写的话

06:23.880 --> 06:25.880
我只能说我知道做饭成功了

06:27.880 --> 06:28.880
做饭失败了

06:29.880 --> 06:30.880
但是其他任务呢

06:30.880 --> 06:31.880
成功还是失败

06:31.880 --> 06:32.880
我也不清楚了

06:32.880 --> 06:33.880
对吧

06:33.880 --> 06:35.880
所以单码的就造成了一些麻烦

06:35.880 --> 06:37.880
那么这些麻烦怎么解决了

06:37.880 --> 06:38.880
就咱们这些和学的知识

06:38.880 --> 06:39.880
就静台方法

06:39.880 --> 06:40.880
静台方法呢

06:40.880 --> 06:42.880
这一块知识特别简单

06:42.880 --> 06:44.880
前面的东西理解过后了

06:44.880 --> 06:46.880
这个静台方法就是其实很轻松的

06:46.880 --> 06:47.880
就是promise

06:47.880 --> 06:48.880
它是个构造函数

06:48.880 --> 06:50.880
它给我们提供了一些静台方法

06:50.880 --> 06:51.880
什么叫静台方法

06:51.880 --> 06:52.880
就通过这个promise函数

06:52.880 --> 06:54.880
可以直接调用的方法叫静台方法

06:54.880 --> 06:55.880
我们之前也讲过

06:55.880 --> 06:56.880
对吧

06:56.880 --> 06:57.880
这就是个静台方法

06:57.880 --> 06:59.880
那么它有哪些静台方法呢

06:59.880 --> 07:00.880
给大家看一下

07:00.880 --> 07:01.880
第一个静台方法result

07:01.880 --> 07:04.880
表示的是直接返回一个

07:04.880 --> 07:06.880
完成状态的任务

07:06.880 --> 07:07.880
啥意思呢

07:07.880 --> 07:08.880
我给大家先看一个介绍

07:09.880 --> 07:11.880
就是说这个promise

07:11.880 --> 07:12.880
你调用这个result

07:12.880 --> 07:14.880
里边随便写个数据

07:14.880 --> 07:15.880
任务完成之后

07:15.880 --> 07:16.880
是有个数据吗

07:16.880 --> 07:17.880
你直接写个数据

07:17.880 --> 07:19.880
它就会返回一个任务

07:19.880 --> 07:20.880
这个任务

07:20.880 --> 07:22.880
它就直接就是完成状态

07:23.880 --> 07:25.880
就这么简单

07:25.880 --> 07:27.880
这种写法就相当于是去砸写的

07:27.880 --> 07:29.880
就相当于是你这样写的

07:29.880 --> 07:30.880
你有一个promise

07:32.880 --> 07:33.880
然后

07:34.880 --> 07:36.880
然后调用它的result

07:37.880 --> 07:38.880
这里

07:39.880 --> 07:40.880
就这么简单

07:40.880 --> 07:41.880
就相当于是这句话

07:41.880 --> 07:42.880
其实这个函数

07:42.880 --> 07:44.880
还本来实现的方式

07:44.880 --> 07:45.880
所以说

07:45.880 --> 07:46.880
没什么好说的

07:46.880 --> 07:47.880
对吧

07:47.880 --> 07:48.880
它就给你提供

07:48.880 --> 07:49.880
这样子写的方便一点

07:49.880 --> 07:51.880
然后这个方法有啥用呢

07:51.880 --> 07:52.880
其实这个方法

07:52.880 --> 07:54.880
对我们平时开发来说没什么用

07:54.880 --> 07:56.880
有的时候就做一些测试

07:56.880 --> 07:58.880
或者更加更多的时候

07:58.880 --> 08:00.880
出现在面试题里边

08:00.880 --> 08:02.880
以后你们学到一些框架

08:02.880 --> 08:04.880
如果说想深入的

08:04.880 --> 08:06.880
去理解一些框架的原码的话

08:06.880 --> 08:07.880
有些框架第三方库

08:07.880 --> 08:09.880
他们的原码里边有用的

08:09.880 --> 08:12.880
我这里不去详细展开了

08:12.880 --> 08:15.880
总之跟你们平时写的按码关系不大的

08:15.880 --> 08:17.880
当然你成为一个

08:18.880 --> 08:20.880
资深的圈段开发工程师的话

08:20.880 --> 08:22.880
可能跟你关系就比较多了

08:22.880 --> 08:24.880
在现在的关系里面没什么关系

08:26.880 --> 08:27.880
就是这么一个东西

08:27.880 --> 08:28.880
然后呢

08:29.880 --> 08:30.880
这个方法就相反

08:30.880 --> 08:31.880
它反而回头是一个

08:31.880 --> 08:33.880
拒绝状态的任务

08:33.880 --> 08:34.880
就失败放出来的任务

08:34.880 --> 08:36.880
那么就比方说你这里写个

08:36.880 --> 08:37.880
里面写个

08:37.880 --> 08:39.880
里面就是失败的原因

08:40.880 --> 08:41.880
它就会返回一个promise

08:41.880 --> 08:43.880
它是它直接就是

08:43.880 --> 08:44.880
拒绝状态

08:44.880 --> 08:45.880
然后的原因就是

08:45.880 --> 08:47.880
对吧 传的什么就是什么

08:47.880 --> 08:48.880
非常简单啊

08:48.880 --> 08:49.880
你这里边就是相当于是

08:49.880 --> 08:50.880
相当于是这句话

08:50.880 --> 08:51.880
就相当于是什么呢

08:51.880 --> 08:53.880
就相当于是NewPromise

08:54.880 --> 08:55.880
Result Reject

08:55.880 --> 08:57.880
我们这里reject

08:57.880 --> 08:59.880
就相当于是这样写的

09:01.880 --> 09:02.880
是一样的对不对

09:03.880 --> 09:05.880
这是前两个静态方法

09:05.880 --> 09:06.880
这两个静态方法

09:06.880 --> 09:08.880
以后我们去做一些

09:08.880 --> 09:10.880
演示的时候可以用一下

09:10.880 --> 09:11.880
非常简单

09:11.880 --> 09:12.880
就直接返回一个promise

09:13.880 --> 09:15.880
后边四个是需要我们

09:15.880 --> 09:17.880
需要一点理解的

09:17.880 --> 09:18.880
因为后边四个东西

09:18.880 --> 09:19.880
细节其实蛮多的

09:19.880 --> 09:20.880
但是我们不需要记

09:21.880 --> 09:22.880
要去理解

09:22.880 --> 09:23.880
理解清楚了过后

09:23.880 --> 09:24.880
你只要理解了

09:24.880 --> 09:26.880
这些方法的含义

09:26.880 --> 09:28.880
你把含义理解清楚了

09:28.880 --> 09:29.880
那么它一细节

09:29.880 --> 09:31.880
你都可以通过逻辑去推

09:31.880 --> 09:33.880
比方说这个方法叫All

09:33.880 --> 09:34.880
里边传一个什么

09:34.880 --> 09:35.880
传一个任务数组

09:35.880 --> 09:36.880
啥意思啊

09:36.880 --> 09:37.880
比方说我可以这样写

09:37.880 --> 09:38.880
promiseAll

09:38.880 --> 09:39.880
里边传的是

09:39.880 --> 09:40.880
一个数组

09:42.880 --> 09:43.880
数组的每一项是啥

09:43.880 --> 09:45.880
每一项就是个promise

09:45.880 --> 09:47.880
比方说是不是可以这样写

09:47.880 --> 09:49.880
promiseResult

09:50.880 --> 09:51.880
那你看这个

09:51.880 --> 09:52.880
这个是不是第一

09:52.880 --> 09:53.880
数组的第一项

09:53.880 --> 09:54.880
第一项是不是给它

09:54.880 --> 09:55.880
是一个promise

09:56.880 --> 09:57.880
那当然说有些人

09:57.880 --> 09:58.880
必须要

09:58.880 --> 09:59.880
我也不知道为什么

09:59.880 --> 10:00.880
有些人必须要变量

10:00.880 --> 10:01.880
他不用变量

10:01.880 --> 10:02.880
他就是代码

10:02.880 --> 10:03.880
就看不懂了

10:05.880 --> 10:06.880
一定要用这种方式

10:06.880 --> 10:08.880
把变量再放过来

10:08.880 --> 10:10.880
不知道有啥区别

10:11.880 --> 10:12.880
总之这是个promise

10:12.880 --> 10:13.880
刚才演示过的

10:13.880 --> 10:14.880
一个是个完成的promise

10:14.880 --> 10:16.880
当然你是不是可以有拒绝的呢

10:16.880 --> 10:18.880
也可以有拒绝的

10:18.880 --> 10:20.880
promiseResult

10:22.880 --> 10:24.880
这也是不是数组的第二项

10:25.880 --> 10:26.880
连这个都看不懂

10:26.880 --> 10:27.880
他一定要把这个数组

10:27.880 --> 10:29.880
放到一个变量里边

10:30.880 --> 10:31.880
然后把数组再传过来

10:31.880 --> 10:33.880
我也不知道有啥区别

10:34.880 --> 10:36.880
反正就是给它一个数组

10:36.880 --> 10:37.880
怎么给无所谓的

10:37.880 --> 10:39.880
它每一项你怎么写无所谓的

10:39.880 --> 10:41.880
总之这是promise

10:44.880 --> 10:45.880
总之你给它传一些promise进去

10:45.880 --> 10:47.880
数组里边有些promise

10:48.880 --> 10:49.880
传进去

10:49.880 --> 10:50.880
这个all这个方法

10:50.880 --> 10:52.880
它会返回一个新的人物

10:52.880 --> 10:53.880
就这个玩意

10:53.880 --> 10:54.880
它会得到一个新的人物

10:55.880 --> 10:56.880
关键我们要找的

10:56.880 --> 10:57.880
就是这个任务

10:57.880 --> 10:59.880
啥时候是挂起

10:59.880 --> 11:00.880
啥时候是完成

11:00.880 --> 11:02.880
啥时候是失败

11:03.880 --> 11:04.880
all是什么意思

11:04.880 --> 11:05.880
全部

11:05.880 --> 11:06.880
一个都不能少

11:08.880 --> 11:11.880
你所有的任务必须要全部成功

11:11.880 --> 11:12.880
我就成功

11:12.880 --> 11:14.880
就这个数组里边有很多任务

11:14.880 --> 11:15.880
对吧

11:15.880 --> 11:16.880
一起去做

11:16.880 --> 11:17.880
一起去弄

11:17.880 --> 11:20.880
然后你只要全部成功了

11:20.880 --> 11:21.880
那我就成功了

11:21.880 --> 11:23.880
比如说我这里写个123

11:25.880 --> 11:26.880
三个任务是不是

11:26.880 --> 11:28.880
我们都是完成的状态

11:28.880 --> 11:29.880
对吧

11:29.880 --> 11:30.880
我给它传了三个任务

11:30.880 --> 11:31.880
三个任务都是完成的

11:31.880 --> 11:33.880
那么这个promise就是完成的

11:33.880 --> 11:34.880
就这么简单

11:35.880 --> 11:36.880
好 你看

11:41.700 --> 11:42.700
一秒钟之后吧

11:42.700 --> 11:43.700
说说一下

11:45.700 --> 11:46.700
那为什么刚才都是偏点

11:46.700 --> 11:47.700
我之后再说

11:48.700 --> 11:49.700
是不是完成的

11:49.700 --> 11:51.700
完成的数据

11:51.700 --> 11:52.700
它为什么是一个数组呢

11:52.700 --> 11:54.700
你想这个道理

11:54.700 --> 11:56.700
一个都不能少

11:56.700 --> 11:57.700
所以要等每一个任务权

11:57.700 --> 11:59.700
所有的任务全部完成

11:59.700 --> 12:00.700
完成的过后

12:00.700 --> 12:01.700
肯定不止一个数据

12:01.700 --> 12:02.700
是不是有很多数据

12:02.700 --> 12:03.700
它有一个

12:03.700 --> 12:04.700
它有一个

12:04.700 --> 12:05.700
它有一个

12:05.700 --> 12:07.700
它就把这些数据合并成为一个数据

12:07.700 --> 12:08.700
所以说

12:08.700 --> 12:10.700
如果说你针对这个promise做后续处理

12:10.700 --> 12:11.700
你该怎么写

12:11.700 --> 12:13.700
z 做后续处理

12:13.700 --> 12:14.700
result

12:14.700 --> 12:15.700
那么这个result

12:15.700 --> 12:17.700
不就是这个数据吗

12:17.700 --> 12:19.700
这个result就是把

12:19.700 --> 12:21.700
这里面的所有的promise

12:21.700 --> 12:22.700
完成之后

12:22.700 --> 12:23.700
所有的完成的相关数据

12:23.700 --> 12:25.700
汇总之后得到的结果

12:28.270 --> 12:29.270
是不是

12:29.270 --> 12:31.270
它一叫一个不能少

12:31.270 --> 12:32.270
我就是全部

12:32.270 --> 12:33.270
一个不能少

12:33.270 --> 12:34.270
全部都必须成功

12:34.270 --> 12:35.270
那我就成功

12:36.270 --> 12:37.270
那如果说

12:37.270 --> 12:38.270
这里面的promise

12:38.270 --> 12:40.270
有其中一个promise是刮旗

12:40.270 --> 12:42.270
它既没有成功又没有失败

12:42.270 --> 12:43.270
那是这种情况

12:43.270 --> 12:44.270
像这个promise

12:44.270 --> 12:45.270
是不是一直刮旗的

12:46.270 --> 12:47.270
对不对

12:47.270 --> 12:48.270
那么像这种情况

12:48.270 --> 12:49.270
那么请问这个pro

12:49.270 --> 12:50.270
什么状态

12:51.270 --> 12:52.270
那肯定就是刮旗的

12:52.270 --> 12:53.270
你看现在这个

12:53.270 --> 12:54.270
回掉还算

12:54.270 --> 12:55.270
还能运行吗

12:55.270 --> 12:56.270
不能运行

12:56.270 --> 12:57.270
然后我们再看一下

12:58.270 --> 13:00.270
它什么叫一个不能少

13:00.270 --> 13:02.270
你自己体会一下

13:03.270 --> 13:04.270
一秒钟之后

13:04.270 --> 13:06.270
输出一下这个promise的状态

13:07.270 --> 13:08.270
这是平底

13:08.270 --> 13:09.270
对吧

13:09.270 --> 13:10.270
它必须要全部成功

13:10.270 --> 13:11.270
它才能成功

13:11.270 --> 13:12.270
一刻刮旗

13:12.270 --> 13:13.270
它就刮旗

13:14.270 --> 13:16.270
那什么时候失败呢

13:16.270 --> 13:18.270
只要有一个失败

13:18.270 --> 13:19.270
它就失败

13:19.270 --> 13:20.270
那比方说吧

13:20.270 --> 13:22.270
我这里把其中一个失败

13:22.270 --> 13:23.270
借个词

13:23.270 --> 13:24.270
那么这个promise

13:24.270 --> 13:25.270
什么状态

13:25.270 --> 13:26.270
这个promise

13:26.270 --> 13:27.270
那它就是失败

13:29.840 --> 13:30.840
你看是不是借个体的

13:30.840 --> 13:31.840
数据是什么

13:31.840 --> 13:32.840
数据是2

13:32.840 --> 13:33.840
哎

13:33.840 --> 13:34.840
其他怪了

13:34.840 --> 13:35.840
那你成功的时候

13:35.840 --> 13:36.840
不是把数据汇总了吗

13:36.840 --> 13:37.840
失败的时候

13:37.840 --> 13:38.840
为什么不汇总

13:38.840 --> 13:40.840
你自己想那个逻辑吧

13:41.840 --> 13:43.840
只要有一个失败

13:43.840 --> 13:44.840
我就失败了

13:44.840 --> 13:45.840
啥意思

13:45.840 --> 13:46.840
比方说

13:46.840 --> 13:47.840
有10个人

13:49.840 --> 13:50.840
短炮白蜜

13:52.840 --> 13:54.840
只要有一个人摔倒了

13:54.840 --> 13:55.840
整个人无结束了

13:55.840 --> 13:56.840
不再玩了

13:56.840 --> 13:57.840
玩不下去

13:57.840 --> 13:58.840
不用玩了

13:58.840 --> 14:00.840
那我就表现一个记录员

14:00.840 --> 14:01.840
他就看

14:01.840 --> 14:02.840
所有的成功了

14:02.840 --> 14:05.840
我就把每个人的用史记录下来

14:05.840 --> 14:06.840
只要有一个人失败了

14:06.840 --> 14:07.840
我转身就走

14:08.840 --> 14:09.840
那比方说跑到中途

14:09.840 --> 14:10.840
有一个人摔倒了

14:10.840 --> 14:12.840
说有一个任务失败了

14:12.840 --> 14:13.840
他转身就走了

14:13.840 --> 14:14.840
那么剩下的人

14:14.840 --> 14:15.840
可能还没跑完

14:15.840 --> 14:16.840
他看不看

14:16.840 --> 14:17.840
看都不看了

14:17.840 --> 14:18.840
他怎么汇总

14:18.840 --> 14:19.840
他没法汇总

14:19.840 --> 14:21.840
他只知道失败的那个人

14:21.840 --> 14:23.840
他能够百分之百确定的是

14:23.840 --> 14:25.840
失败的那个人的失败原因

14:25.840 --> 14:26.840
是2

14:26.840 --> 14:27.840
其他的人

14:27.840 --> 14:28.840
不知道

14:28.840 --> 14:30.840
因为我这里写的是任务立即完成

14:30.840 --> 14:31.840
对吧

14:31.840 --> 14:32.840
你给的任务

14:32.840 --> 14:33.840
他不一定是立即完成的

14:33.840 --> 14:34.840
他可能是正在挂起的

14:34.840 --> 14:35.840
他也说不清楚

14:35.840 --> 14:36.840
所以说他只能去

14:36.840 --> 14:37.840
他失败的时候

14:37.840 --> 14:40.840
他只清楚失败的那一个的原因

14:40.840 --> 14:42.840
看到一个失败了就OK了

14:42.840 --> 14:43.840
就走了

14:43.840 --> 14:44.840
这就是

14:44.840 --> 14:45.840
为什么失败的时候

14:45.840 --> 14:46.840
只有一个数据

14:46.840 --> 14:47.840
说这个东西要通过

14:47.840 --> 14:49.840
现实世界

14:49.840 --> 14:51.840
就是通过正常的逻辑去推

14:51.840 --> 14:52.840
你去背是没用的

14:52.840 --> 14:53.840
背不住的

14:54.840 --> 14:55.840
就是all

14:56.840 --> 14:57.840
然后any

14:57.840 --> 14:59.840
以后我们会举一些实际的例子

14:59.840 --> 15:00.840
any

15:00.840 --> 15:01.840
反而回一个

15:01.840 --> 15:02.840
也是一样

15:02.840 --> 15:03.840
反而回一个任务

15:04.840 --> 15:05.840
他什么意思呢

15:05.840 --> 15:06.840
他指的是

15:07.840 --> 15:09.840
只要有一个成功

15:09.840 --> 15:10.840
是不是相反的

15:10.840 --> 15:12.840
或是所有的any表示任何一个

15:12.840 --> 15:14.840
只要有任何一个成功了

15:14.840 --> 15:16.840
那我这个新的任务就成功了

15:18.840 --> 15:19.840
让大家想一想

15:21.840 --> 15:23.840
开动里面的脑袋想一想

15:24.840 --> 15:25.840
这个任务

15:26.840 --> 15:27.840
他一秒钟之后

15:27.840 --> 15:28.840
他是成功还是失败

15:30.840 --> 15:31.840
是不是成功呢

15:31.840 --> 15:32.840
为啥

15:32.840 --> 15:33.840
any

15:33.840 --> 15:34.840
只要有一个

15:34.840 --> 15:35.840
我不需要全部

15:35.840 --> 15:36.840
我只要一个就行了

15:37.840 --> 15:38.840
落水3000

15:38.840 --> 15:39.840
我只取一票

15:39.840 --> 15:40.840
对不对

15:40.840 --> 15:41.840
这票的好

15:42.840 --> 15:43.840
那么这里只需要

15:43.840 --> 15:44.840
有一个任务成功就行了

15:44.840 --> 15:45.840
那这里成功了

15:45.840 --> 15:46.840
两个

15:46.840 --> 15:47.840
够了

15:47.840 --> 15:48.840
我只要一个

15:49.840 --> 15:50.840
一个成功就OK

15:50.840 --> 15:51.840
那么大家

15:51.840 --> 15:52.840
这是第一个问题

15:52.840 --> 15:53.840
他一定是成功了

15:53.840 --> 15:54.840
这好我一问

15:54.840 --> 15:55.840
那么关键是

15:55.840 --> 15:56.840
他成功的数据是啥

15:58.840 --> 15:59.840
你告诉我

16:00.840 --> 16:01.840
是一个数据

16:01.840 --> 16:02.840
还是

16:02.840 --> 16:03.840
多个数据

16:03.840 --> 16:04.840
多个数据是数据

16:05.840 --> 16:06.840
是一个数据还是数据

16:08.840 --> 16:09.840
按逻辑来说

16:09.840 --> 16:10.840
是不是应该是

16:11.840 --> 16:12.840
一个数据

16:12.840 --> 16:13.840
为什么

16:13.840 --> 16:14.840
any

16:14.840 --> 16:15.840
任何一个成功就行

16:16.840 --> 16:17.840
也就是说

16:17.840 --> 16:18.840
他成功了之后

16:18.840 --> 16:19.840
其他就不用看了

16:19.840 --> 16:20.840
是不是只得到一个

16:20.840 --> 16:21.840
能确定的

16:21.840 --> 16:22.840
就是那个成功的数据

16:22.840 --> 16:23.840
谁先成功

16:23.840 --> 16:24.840
他也不一定知道

16:24.840 --> 16:25.840
我这边写的

16:25.840 --> 16:26.840
就是

16:26.840 --> 16:27.840
按照顺序

16:27.840 --> 16:28.840
他是先成功的

16:28.840 --> 16:29.840
他的数据

16:29.840 --> 16:30.840
应该是1

16:32.840 --> 16:33.840
对了

16:33.840 --> 16:34.840
Promise any is not

16:36.840 --> 16:37.840
any

16:38.840 --> 16:39.840
Promise any

16:40.840 --> 16:41.840
is not a function

16:43.840 --> 16:44.840
好吧

16:44.840 --> 16:45.840
这个地方

16:45.840 --> 16:46.840
我给大家说一下

16:46.840 --> 16:47.840
这个寒树是存在的

16:47.840 --> 16:49.840
他说这个寒树不存在

16:49.840 --> 16:50.840
这个寒树是存在的

16:50.840 --> 16:51.840
出现这个错误的原因

16:51.840 --> 16:52.840
是因为我这边

16:52.840 --> 16:53.840
漏的版本有点低

16:53.840 --> 16:54.840
因为我这边

16:54.840 --> 16:55.840
用这个装扣的运行

16:55.840 --> 16:57.840
它不是在浏览性环境里面运行

16:57.840 --> 16:58.840
是漏的环境里面运行的

16:58.840 --> 17:00.840
我说漏的环境版本有点低

17:00.840 --> 17:02.840
它这个寒树还没有

17:02.840 --> 17:03.840
我把它换到浏览期

17:03.840 --> 17:04.840
浏览期里面没问题

17:05.840 --> 17:10.330
是不是得到2

17:11.330 --> 17:12.330
Fulfill的1

17:12.330 --> 17:13.330
对吧

17:13.330 --> 17:14.330
完成1

17:14.330 --> 17:15.330
是不是有一个完成了

17:15.330 --> 17:16.330
首先他完成

17:16.330 --> 17:17.330
那得到的结果就是1

17:17.330 --> 17:18.330
当然呢

17:18.330 --> 17:19.330
实际情况里面

17:19.330 --> 17:20.330
我这里用的是

17:20.330 --> 17:22.330
就是马上就得到的是一个

17:22.330 --> 17:23.330
完成的Promise

17:23.330 --> 17:24.330
完成的任务

17:24.330 --> 17:25.330
但实际情况里面

17:25.330 --> 17:26.330
这些任务都需要

17:26.330 --> 17:27.330
经过一段时间

17:27.330 --> 17:29.330
这是关于这个点

17:30.330 --> 17:31.330
这是end

17:31.330 --> 17:32.330
然后下

17:32.330 --> 17:33.330
那么什么时候失败呢

17:33.330 --> 17:35.330
全部任务失败

17:35.330 --> 17:36.330
什么跟上面一个刚好相反

17:36.330 --> 17:38.330
全部任务失败就失败

17:38.330 --> 17:40.330
没有一个任务完成

17:40.330 --> 17:41.330
那就失败

17:41.330 --> 17:42.330
然后我这里全部

17:42.330 --> 17:43.330
全部都是被拒绝的

17:45.330 --> 17:46.330
是不是全部都失败了

17:46.330 --> 17:47.330
那么请问

17:47.330 --> 17:48.330
全部都失败了

17:48.330 --> 17:49.330
他肯定失败了

17:50.330 --> 17:51.330
相关原因

17:51.330 --> 17:53.330
是单个数据

17:53.330 --> 17:54.330
还是多个

17:55.330 --> 17:56.330
是不是多个了

17:57.330 --> 17:58.330
因为他能够

17:58.330 --> 17:59.330
这个是全部任务都失败了

18:00.330 --> 18:01.330
他失败的时候

18:01.330 --> 18:02.330
他一定是全部任务都失败

18:02.330 --> 18:03.330
所以他会把

18:03.330 --> 18:04.330
全部任务失败的原因

18:04.330 --> 18:05.330
都归准

18:07.770 --> 18:08.770
保留暗器里边

18:12.170 --> 18:13.170
这边

18:14.170 --> 18:15.170
这里已经

18:15.170 --> 18:16.170
刷新来一次

18:18.170 --> 18:19.170
你看

18:23.210 --> 18:24.210
你看

18:24.210 --> 18:25.210
是不是得到了

18:25.210 --> 18:26.210
是一个输出

18:26.210 --> 18:28.210
它封装到一个对象里面的

18:28.210 --> 18:29.210
我们来看一下

18:29.210 --> 18:31.210
这边我们用Catch

18:32.210 --> 18:33.210
Catch

18:34.210 --> 18:36.210
看一下打印下来这个Rail

18:36.210 --> 18:38.210
这里就只能到留暗器

18:38.210 --> 18:40.210
留在环境里边现在没有

18:43.220 --> 18:44.220
打印一下

18:47.560 --> 18:49.560
我再打印出来是啥呀

18:51.560 --> 18:53.560
Catch

18:53.560 --> 18:54.560
放射

18:57.560 --> 18:58.560
试看

19:01.380 --> 19:02.380
这样打印一下

19:03.380 --> 19:04.380
再来

19:08.100 --> 19:09.100
他得到的是个对象

19:09.100 --> 19:11.100
对象里面有个属性叫Aerous

19:13.100 --> 19:14.100
他有一些错误消息

19:14.100 --> 19:15.100
错误消息就是

19:15.100 --> 19:16.100
他给封装了一下

19:16.100 --> 19:17.100
所以我们要得到

19:17.100 --> 19:18.100
所有的错误

19:18.100 --> 19:19.100
要得到他的Aerous

19:21.100 --> 19:22.100
然后这样子

19:26.630 --> 19:27.630
你看失败

19:28.630 --> 19:30.630
好 这是关于这个

19:30.630 --> 19:31.630
NE

19:31.630 --> 19:33.630
看一下有没有别的函数呢

19:33.630 --> 19:35.630
还有AllSettled

19:36.630 --> 19:37.630
这个也是什么意思呢

19:37.630 --> 19:38.630
它也是一样

19:38.630 --> 19:39.630
返回一个新的任务

19:40.630 --> 19:41.630
给它传一个数数

19:41.630 --> 19:42.630
它表示说

19:43.630 --> 19:44.630
全部

19:44.630 --> 19:45.630
我不一定要全部成功

19:45.630 --> 19:47.630
反正全部都得

19:47.630 --> 19:48.630
有结果

19:48.630 --> 19:49.630
什么叫有结果

19:49.630 --> 19:50.630
以绝

19:50.630 --> 19:51.630
什么叫以绝

19:51.630 --> 19:52.630
还记得吗

19:52.630 --> 19:53.630
啥叫以绝

19:54.630 --> 20:05.050
我上一节课的那个

20:05.050 --> 20:06.050
课件已经删掉了

20:06.050 --> 20:07.050
就是那张图

20:09.050 --> 20:10.050
还是把找一下吧

20:10.050 --> 20:12.050
我找一下上一节课的那个图

20:12.050 --> 20:14.550
再

20:19.740 --> 20:20.740
解释

20:20.740 --> 20:22.740
破裂式基础

20:25.380 --> 20:26.380
就这个图

20:29.070 --> 20:30.070
就这个图

20:30.070 --> 20:31.070
只要你是以绝

20:31.070 --> 20:32.070
就是表示有了结果

20:32.070 --> 20:33.070
你不一定是成功

20:33.070 --> 20:34.070
有可能失败

20:34.070 --> 20:35.070
有可能成功

20:35.070 --> 20:36.070
无所谓

20:36.070 --> 20:37.070
只要你有结果

20:37.070 --> 20:38.070
你不是挂起就行了

20:39.070 --> 20:40.070
任务输出中

20:40.070 --> 20:42.070
所有任务只要有了结果

20:43.070 --> 20:45.070
那么我这个新的Promise

20:45.070 --> 20:46.070
就成功

20:47.070 --> 20:48.070
这种情况下

20:48.070 --> 20:49.070
是不可能有失败的

20:50.070 --> 20:51.070
你想一想这个道理

20:51.070 --> 20:52.070
有没有可能

20:52.070 --> 20:53.070
这个逻辑下

20:53.070 --> 20:54.070
有没有可能

20:54.070 --> 20:55.070
这个失败

20:56.070 --> 20:57.070
无所谓

20:57.070 --> 20:58.070
我不管你这里边Promise

20:58.070 --> 20:59.070
成功还是失败

20:59.070 --> 21:00.070
无所谓

21:00.070 --> 21:01.070
你只要有结果

21:01.070 --> 21:02.070
全部只要有了结果

21:02.070 --> 21:03.070
我就成功了

21:03.070 --> 21:04.070
那如果说一直没有结果了

21:04.070 --> 21:05.070
一直没有结果

21:05.070 --> 21:06.070
它就挂起

21:06.070 --> 21:07.070
它只有两种状态

21:07.070 --> 21:08.070
挂起和成功

21:08.070 --> 21:09.070
它不可能有失败

21:09.070 --> 21:11.070
比方说我给大家看一下吧

21:11.070 --> 21:13.070
有些成功了

21:13.070 --> 21:14.070
有些失败了

21:14.070 --> 21:15.070
然后呢

21:15.070 --> 21:16.070
我们这里用的是Orcetl

21:16.070 --> 21:17.070
首先看一下

21:17.070 --> 21:18.070
它最终的状态

21:21.340 --> 21:22.340
是不是

21:22.340 --> 21:23.340
它成功了

21:23.340 --> 21:24.340
它的数据有点

21:24.340 --> 21:25.340
有点意思

21:25.340 --> 21:26.340
它也是贵重

21:26.340 --> 21:28.340
它跟Or也是一样

21:28.340 --> 21:29.340
Or它只管成功了

21:29.340 --> 21:30.340
对吧

21:30.340 --> 21:31.340
所以所谓说

21:31.340 --> 21:32.340
只把成功了来贵重

21:32.340 --> 21:33.340
那么Orcetl的

21:33.340 --> 21:34.340
cetl的什么意思

21:34.340 --> 21:35.340
就是以绝的意思

21:35.340 --> 21:36.340
我只要保证

21:36.340 --> 21:37.340
所有的完成

21:37.340 --> 21:38.340
就是有结果就行了

21:38.340 --> 21:39.340
那么这个结果

21:39.340 --> 21:41.340
是有可能有成功

21:41.340 --> 21:42.340
有可能有失败

21:42.340 --> 21:43.340
所以它贵重的信心

21:43.340 --> 21:44.340
要比较详细一点

21:44.340 --> 21:45.340
比方说它第一个

21:45.340 --> 21:46.340
它对应什么

21:46.340 --> 21:47.340
它对应的是

21:47.340 --> 21:48.340
第一个Promise

21:48.340 --> 21:50.340
它对应这个结果

21:50.340 --> 21:51.340
它的状态是

21:51.340 --> 21:53.340
第一个Promise的状态是

21:53.340 --> 21:54.340
完成了

21:54.340 --> 21:55.340
值是1

21:55.340 --> 21:57.340
第二个Promise的状态是

21:57.340 --> 21:58.340
拒绝的

21:59.340 --> 22:01.340
原因是2

22:01.340 --> 22:02.340
第三个Promise的状态

22:02.340 --> 22:03.340
是完成的

22:03.340 --> 22:04.340
值为3

22:04.340 --> 22:05.340
自己就对到的看一下

22:05.340 --> 22:06.340
是不是这个道理

22:06.340 --> 22:07.340
所以它得到了

22:07.340 --> 22:08.340
还是一个贵重结果

22:08.340 --> 22:09.340
数据

22:09.340 --> 22:10.340
然后这个贵重结果

22:10.340 --> 22:11.340
比较详细

22:11.340 --> 22:12.340
每一个是一个对象

22:12.340 --> 22:13.340
它对象就告诉你

22:13.340 --> 22:15.340
它这个Promise

22:16.340 --> 22:17.340
每一个Promise

22:17.340 --> 22:19.340
它最后的情况是什么

22:19.340 --> 22:21.340
它都有结果了

22:21.340 --> 22:22.340
如果说

22:22.340 --> 22:23.340
其中一个Promise

22:23.340 --> 22:24.340
一直是挂起的话

22:25.340 --> 22:26.340
这就是All Settled

22:27.340 --> 22:28.340
再下一个Arrest

22:28.340 --> 22:30.340
Arrest的话就是

22:31.340 --> 22:32.340
比赛

22:33.340 --> 22:36.340
看谁先有结果

22:36.340 --> 22:37.340
我不管你是成功

22:37.340 --> 22:38.340
还是失败

22:38.340 --> 22:40.340
只要你有结果

22:40.340 --> 22:42.340
我的结果就跟你一样

22:42.340 --> 22:43.340
叫Arrest

22:44.340 --> 22:46.340
看谁先有结果

22:46.340 --> 22:47.340
由于这里

22:47.340 --> 22:49.340
我们作为所有的Promise

22:49.340 --> 22:51.340
都是立即完成的

22:51.340 --> 22:52.340
立即结束的

22:52.340 --> 22:53.340
所以说

22:53.340 --> 22:54.340
这是成功的

22:54.340 --> 22:55.340
这是失败的

22:55.340 --> 22:56.340
这是成功的

22:56.340 --> 22:57.340
那么它就会按照顺序

22:57.340 --> 22:58.340
第一个是成功的

22:58.340 --> 23:00.340
那么这个就是成功的

23:00.340 --> 23:01.340
明儿的意思

23:01.340 --> 23:02.340
我们来看一下

23:03.340 --> 23:04.340
第一个是成功的

23:04.340 --> 23:05.340
那么最终的

23:05.340 --> 23:06.340
它就Promise

23:06.340 --> 23:07.340
就是成功的

23:07.340 --> 23:08.340
第一个的数据是1

23:08.340 --> 23:10.340
那么它就数据就是1

23:10.340 --> 23:11.340
对不对

23:11.340 --> 23:12.340
当然我这边

23:12.340 --> 23:13.340
都是立即完成的

23:13.340 --> 23:14.340
所以它取第一个

23:14.340 --> 23:15.340
但是实际情况下

23:15.340 --> 23:16.340
这里边Promise

23:16.340 --> 23:17.340
完成的时间

23:17.340 --> 23:18.340
是不确定的

23:18.340 --> 23:20.340
有可能它需要一秒钟完成

23:20.340 --> 23:21.340
有可能它需要

23:21.340 --> 23:22.340
三秒钟

23:22.340 --> 23:23.340
立即完成的

23:23.340 --> 23:24.340
那么就取的是它

23:24.340 --> 23:25.340
谁先完成

23:25.340 --> 23:26.340
竞赛

23:26.340 --> 23:27.340
谁先有结果

23:27.340 --> 23:28.340
就用谁的

23:29.340 --> 23:30.340
那么如果说

23:30.340 --> 23:32.340
比方说它

23:32.340 --> 23:33.340
第一个是先失败

23:33.340 --> 23:35.340
那么它就失败了

23:37.660 --> 23:38.660
它就失败了

23:38.660 --> 23:39.660
数据原因

23:39.660 --> 23:41.660
跟它的失败原因是一样的

23:41.660 --> 23:42.660
谁先成功

23:42.660 --> 23:43.660
它就成功

23:43.660 --> 23:45.660
数据跟它成功的一样

23:45.660 --> 23:46.660
谁先失败

23:46.660 --> 23:47.660
它就失败

23:48.660 --> 23:49.660
就这么个意思

23:49.660 --> 23:51.660
就找第一个有结果的

23:51.660 --> 23:52.660
这就是Race竞赛

23:52.660 --> 23:53.660
这就是Promise里面的

23:53.660 --> 23:54.660
所有竞赛方法

23:54.660 --> 23:56.660
那么平时我们用的话

23:56.660 --> 23:57.660
灵活运用

23:57.660 --> 23:58.660
其实我们平时

23:58.660 --> 23:59.660
竞赛方法都用的不多

23:59.660 --> 24:00.660
有的时候会用的

24:00.660 --> 24:01.660
下面有一个

24:01.660 --> 24:02.660
有些练习体

24:02.660 --> 24:03.660
我们把练习体做了之后

24:03.660 --> 24:05.660
再来看登革的一个例子

24:07.660 --> 24:08.660
这里有个函数

24:08.660 --> 24:09.660
这个函数的作用

24:09.660 --> 24:10.660
当然这个函数

24:10.660 --> 24:11.660
是我模拟的

24:11.660 --> 24:13.660
模拟的一个网络通信

24:13.660 --> 24:15.660
说你给我一个页码

24:16.660 --> 24:17.660
我就能从网络中

24:17.660 --> 24:18.660
获取这个页码的

24:18.660 --> 24:19.660
一些学生数据

24:20.660 --> 24:21.660
咱们来用一下

24:21.660 --> 24:23.660
这个还说你自己有兴趣的话

24:23.660 --> 24:24.660
可以看一下

24:24.660 --> 24:25.660
就写了一些模拟的数据

24:25.660 --> 24:26.660
没兴趣的话

24:26.660 --> 24:27.660
就不用看了

24:27.660 --> 24:28.660
无所谓的

24:28.660 --> 24:29.660
用了其实也是学过的知识

24:29.660 --> 24:30.660
只是有点糟而已

24:31.660 --> 24:32.660
比方说传一个仪

24:32.660 --> 24:34.660
表示获取第一页的学生

24:34.660 --> 24:35.660
它给你反核了啥

24:35.660 --> 24:36.660
反核的是Promise

24:36.660 --> 24:37.660
你看这个注释

24:37.660 --> 24:38.660
已经打得很清楚了

24:38.660 --> 24:39.660
反核的Promise

24:39.660 --> 24:40.660
你应该怎么用

24:41.660 --> 24:42.660
所以后去处理

24:42.660 --> 24:43.660
你给我获取学生

24:43.660 --> 24:45.660
那么这是一个任务

24:45.660 --> 24:47.660
这个任务完成之后

24:47.660 --> 24:49.660
是不是拿到一些学生数据

24:50.660 --> 24:53.660
输出一下学生数据

24:57.660 --> 24:58.660
运行

25:01.480 --> 25:02.480
他这里需要一段时间

25:02.480 --> 25:03.480
他这里报错了

25:03.480 --> 25:04.480
说明啥

25:04.480 --> 25:05.480
他告诉你网络错误

25:05.480 --> 25:06.480
获取第一页数据失败

25:06.480 --> 25:07.480
他觉得他有可能会有错误

25:07.480 --> 25:09.480
其实我都是模拟的

25:09.480 --> 25:11.480
我用一个随技术来模拟

25:11.480 --> 25:12.480
不要说到这边

25:12.480 --> 25:14.480
我就给他注册两个吧

25:17.480 --> 25:18.480
到底是什么原因失败的

25:18.480 --> 25:19.480
一个说一下

25:25.580 --> 25:26.580
等了一段时间

25:26.580 --> 25:27.580
是不是拿到一个数据

25:27.580 --> 25:28.580
这个数据里面

25:28.580 --> 25:30.580
其实学生我做的很简单

25:30.580 --> 25:31.580
一个是学生编号

25:31.580 --> 25:33.580
ID一个是学生的姓名

25:33.580 --> 25:35.580
我去用这种方式

25:35.580 --> 25:36.580
反正是模拟

25:36.580 --> 25:38.580
模拟一个网络通信

25:38.580 --> 25:40.580
有这么一个任务

25:40.580 --> 25:41.580
得到一个学生

25:41.580 --> 25:42.580
然后呢

25:43.580 --> 25:45.580
就是可以去获取某一页的学生

25:45.580 --> 25:47.580
成功就拿到学生的数据

25:47.580 --> 25:49.580
失败了就拿到失败的原因

25:49.580 --> 25:50.580
明白吧

25:50.580 --> 25:52.580
这是这个函数

25:52.580 --> 25:54.580
好 接下来我要利用这个函数

25:54.580 --> 25:56.580
来做一些练习

25:56.580 --> 25:58.580
第一个练习

25:58.580 --> 26:00.580
你们可以自己尝试去做一下

26:00.580 --> 26:02.580
获取一到十页的学生

26:02.580 --> 26:05.580
结果有十页的学生都要获取

26:05.580 --> 26:07.580
那么最终获取到了过后

26:07.580 --> 26:10.580
按照顺序合并成立的数据

26:10.580 --> 26:12.580
任何一页的数据

26:12.580 --> 26:14.580
获取出现错误

26:14.580 --> 26:16.580
则任务不再继续

26:16.580 --> 26:17.580
打印错误消息

26:17.580 --> 26:18.580
这啥意思

26:18.580 --> 26:20.580
就是说我这边

26:20.580 --> 26:22.580
我可能一下子不要一页一页的拿

26:22.580 --> 26:24.580
然后一下子去拿十页的学生

26:24.580 --> 26:26.580
要同时

26:26.580 --> 26:30.580
2 3 4 5 6 7 8 9 10

26:30.580 --> 26:32.580
我同时

26:32.580 --> 26:34.580
从网络上去拿十页的学生

26:34.580 --> 26:36.580
所以我一开始要调问几次

26:36.580 --> 26:38.580
是不是十次

26:38.580 --> 26:39.580
对不对

26:39.580 --> 26:42.580
好 那么比方说中途有某一页错了

26:42.580 --> 26:44.580
这拿第五页的时候错了

26:44.580 --> 26:47.580
那么剩下的数据不要了

26:47.580 --> 26:49.580
任务不再继续

26:49.580 --> 26:50.580
不要了

26:50.580 --> 26:53.580
我就打印错误消息完事了

26:53.580 --> 26:56.580
那这到底怎么做呢

26:56.580 --> 26:57.580
我就问你

26:57.580 --> 27:00.580
这是几个静态方法你觉得使用哪一个

27:00.580 --> 27:03.470
那一个个看吧

27:03.470 --> 27:04.470
这几个不要

27:04.470 --> 27:06.470
这两个就不用看了

27:06.470 --> 27:08.470
首先是all

27:08.470 --> 27:09.470
all是什么意思

27:09.470 --> 27:11.470
一个都不能少

27:11.470 --> 27:14.470
这个玩意是不是一个都不能少

27:14.470 --> 27:16.470
你甭管他后面干啥

27:16.470 --> 27:18.470
我要获取十页这个任务

27:18.470 --> 27:19.470
是不是一个都不能少

27:19.470 --> 27:20.470
必须要全部都打到

27:20.470 --> 27:21.470
全部都要成功

27:21.470 --> 27:22.470
一个都不能失败

27:22.470 --> 27:24.470
失败一个我就没法继续了

27:24.470 --> 27:26.470
是不是就应该使用all

27:26.470 --> 27:27.470
那我们就是用背

27:27.470 --> 27:28.470
promise all

27:28.470 --> 27:29.470
这里边传啥

27:29.470 --> 27:31.470
是不是要传一个任务数据

27:31.470 --> 27:33.470
我们这里是不是有很多任务

27:33.470 --> 27:34.470
要获取十页

27:34.470 --> 27:35.470
那么就传一个任务数据

27:35.470 --> 27:38.470
但是个任务数据怎么写呢

27:38.470 --> 27:40.470
我给大家推荐的一种写法

27:40.470 --> 27:43.470
第一种写法就是你拿一个数据

27:43.470 --> 27:45.470
十页

27:45.470 --> 27:49.000
这个写法

27:49.000 --> 27:50.000
你懂的

27:50.000 --> 27:53.000
我刁了这个函数十次

27:53.000 --> 27:54.000
5

27:54.000 --> 27:55.000
6

27:55.000 --> 27:56.000
7

27:56.000 --> 27:57.000
8

27:57.000 --> 27:59.000
现在用这种最笨的写法

27:59.000 --> 28:01.000
最笨的写法也是最好理解的

28:01.000 --> 28:03.000
所以每刁用一个函数

28:03.000 --> 28:04.000
这个反回的就是什么

28:04.000 --> 28:05.000
反回的就是个promise

28:05.000 --> 28:07.000
如果说你连这个都看不懂

28:07.000 --> 28:08.000
那我就没办法了

28:08.000 --> 28:11.000
那你可能只能这样子写了

28:11.000 --> 28:13.000
因为有些同学我也不知道为啥

28:13.000 --> 28:14.000
他一定要用变两个

28:14.000 --> 28:17.000
不用变两他脑袋是蒙的

28:17.000 --> 28:19.000
拿到第一个promise

28:19.000 --> 28:20.000
第二个promise

28:20.000 --> 28:23.000
这里写P1

28:23.000 --> 28:25.000
这里写P1写这儿

28:25.000 --> 28:26.000
然后一共写10个

28:26.000 --> 28:28.000
这里写P1P2P3P10

28:28.000 --> 28:30.000
那我就不讲了

28:30.000 --> 28:31.000
这种写法

28:31.000 --> 28:32.000
如果说你一定要用这种写法

28:32.000 --> 28:33.000
就去写

28:33.000 --> 28:35.000
这里我们得到一个数组

28:35.000 --> 28:36.000
是不是数组全进来

28:36.000 --> 28:38.000
我也不知道这个是任务

28:38.000 --> 28:39.000
每个任务

28:39.000 --> 28:40.000
是不是说第一个任务

28:40.000 --> 28:41.000
就一定先完成

28:41.000 --> 28:42.000
那也不一定

28:42.000 --> 28:43.000
你看我这里

28:43.000 --> 28:44.000
为了说明这一点

28:44.000 --> 28:45.000
我都把每个任务

28:45.000 --> 28:46.000
等待的时间都是水积的

28:46.000 --> 28:48.000
我都不知道他什么时候玩

28:48.000 --> 28:50.000
所以说不一定是哪个先完成

28:50.000 --> 28:52.000
但是他最终汇总的结果

28:52.000 --> 28:54.000
一定是按了这个数据去来汇总

28:54.000 --> 28:56.000
这个玩意是不是一个promise

28:56.000 --> 28:58.000
那么对这个promise进行后续处理

28:58.000 --> 29:01.000
如果说这个promise成功了

29:01.000 --> 29:02.000
说明啥

29:02.000 --> 29:04.000
科学们说明啥

29:04.000 --> 29:06.000
是不是所有任务都成功了

29:06.000 --> 29:07.000
那么换而言之

29:07.000 --> 29:08.000
如果说这个promise失败了

29:08.000 --> 29:10.000
是不是只能说明

29:10.000 --> 29:12.000
至少其中一个失败了

29:12.000 --> 29:13.000
其他是不是失败

29:13.000 --> 29:14.000
我不知道

29:14.000 --> 29:18.850
来的看一下吧

29:18.850 --> 29:19.850
过去是不是有一个失败了

29:19.850 --> 29:20.850
第三页数据失败了

29:20.850 --> 29:23.850
那么这个事情是不是没做了

29:23.850 --> 29:24.850
不用做了

29:24.850 --> 29:28.290
再来看

29:28.290 --> 29:29.290
第五页数据都失败了

29:29.290 --> 29:31.290
我把机率调低一点

29:31.290 --> 29:32.290
机率有点高

29:32.290 --> 29:33.290
失败的机率

29:33.290 --> 29:34.290
再来

29:34.290 --> 29:37.980
十个

29:37.980 --> 29:38.980
你看

29:38.980 --> 29:39.980
最终汇总的结果

29:39.980 --> 29:41.980
你看个result

29:41.980 --> 29:43.980
一个很大的数据

29:43.980 --> 29:46.980
这是第一个任务完成的

29:46.980 --> 29:48.980
这是第二个任务完成的数据

29:48.980 --> 29:51.980
第三个任务完成的数据

29:51.980 --> 29:53.980
第四个任务完成的数据

29:53.980 --> 29:54.980
它的格式就是这样子

29:54.980 --> 29:56.980
它的汇总结果是这样子

29:56.980 --> 29:57.980
是一个数据

29:57.980 --> 29:59.980
第一个任务完成的数据

29:59.980 --> 30:00.980
是不是一个数据

30:00.980 --> 30:02.980
一个学生

30:02.980 --> 30:04.980
第二个任务完成的数据

30:04.980 --> 30:05.980
是不是有很多学生

30:05.980 --> 30:07.980
第三个任务完成的数据

30:07.980 --> 30:09.980
是不是拨取到第三页的学生

30:09.980 --> 30:10.980
对不对

30:10.980 --> 30:12.980
那么我要按顺域去

30:12.980 --> 30:14.980
就是我要把这个数据展开

30:14.980 --> 30:15.980
是不是要把里面

30:15.980 --> 30:16.980
每一个数据展开

30:16.980 --> 30:18.980
我就给大家介绍一个方法

30:18.980 --> 30:20.980
要把数据展开

30:20.980 --> 30:21.980
把这种格式的东西展开

30:21.980 --> 30:23.980
其实非常简单

30:23.980 --> 30:24.980
比较看一下

30:24.980 --> 30:25.980
比方说我有个数据

30:25.980 --> 30:26.980
这个数据里面

30:26.980 --> 30:28.980
第一项又是一个数据

30:28.980 --> 30:30.980
第二项又是一个数据

30:30.980 --> 30:32.980
第三项又是一个数据

30:32.980 --> 30:34.980
我要把这个方法展开

30:34.980 --> 30:35.980
其实就把这个

30:35.980 --> 30:38.980
雕用这个数据的一个方法叫flat

30:38.980 --> 30:40.980
反而回来就是有一个展开的数据

30:40.980 --> 30:42.980
有这么一个API

30:42.980 --> 30:43.980
之前没有讲

30:43.980 --> 30:44.980
我随便说一下

30:44.980 --> 30:45.980
它就把这个数据里面

30:45.980 --> 30:48.980
它的指数据展开

30:48.980 --> 30:49.980
所以说我们这边

30:50.980 --> 30:51.980
要做了什么事情

30:52.980 --> 30:56.260
好看一下了

31:00.360 --> 31:01.360
你看是不是得到了

31:01.360 --> 31:02.360
按顺序了

31:04.360 --> 31:05.360
这个按顺序

31:05.360 --> 31:06.360
它不是说它一定是

31:06.360 --> 31:07.360
它先完成

31:07.360 --> 31:08.360
它再完成

31:08.360 --> 31:09.360
它再完成

31:09.360 --> 31:10.360
不是的

31:10.360 --> 31:11.360
它又可能是它先完成

31:11.360 --> 31:13.360
然后它再完成

31:13.360 --> 31:14.360
然后它再完成

31:14.360 --> 31:16.360
但是它最终汇总的时候

31:16.360 --> 31:17.360
它一定会按照

31:17.360 --> 31:19.360
你给它传入的顺序来进行汇总

31:19.360 --> 31:20.360
它会自动给你

31:20.360 --> 31:21.360
按照传入的顺序来汇总

31:21.360 --> 31:23.360
这个不用担心

31:23.360 --> 31:24.360
它是地道题

31:24.360 --> 31:25.360
地道题就是这里写的

31:25.360 --> 31:26.360
有点恶心

31:26.360 --> 31:27.360
所以说我写单版的话

31:27.360 --> 31:28.360
我肯定不可以用这东西

31:28.360 --> 31:30.360
那如果说我过去一到一百页了

31:30.360 --> 31:31.360
那就是咋办了

31:31.360 --> 31:32.360
所以有些同学开始想到

31:32.360 --> 31:34.360
是不是用循环

31:34.360 --> 31:36.360
每一次循环往里面加一个

31:36.360 --> 31:38.360
除了用循环之外

31:38.360 --> 31:41.800
还可以用这种方式来写

31:41.800 --> 31:42.800
不是有实业吗

31:43.800 --> 31:45.800
创建一个实则数据

31:45.800 --> 31:46.800
然后能用个feal

31:47.800 --> 31:48.800
随便feal一个东西

31:48.800 --> 31:49.800
把我们数据的每一项

31:49.800 --> 31:50.800
填充一个东西

31:50.800 --> 31:51.800
你自己看

31:52.800 --> 31:53.800
六一个

31:53.800 --> 31:54.800
六一个

31:54.800 --> 31:55.800
二个

31:55.800 --> 31:56.800
十个

31:56.800 --> 31:57.800
feal

31:58.800 --> 31:59.800
每一项

31:59.800 --> 32:00.800
随便填充一个

32:00.800 --> 32:01.800
全程一个e

32:01.800 --> 32:02.800
那么是不是得到

32:02.800 --> 32:03.800
十个e的数组

32:03.800 --> 32:04.800
那么对这个数组

32:04.800 --> 32:05.800
再使用map

32:05.800 --> 32:06.800
intel

32:06.800 --> 32:07.800
intel是不是

32:07.800 --> 32:09.800
这就要传个函数

32:10.800 --> 32:11.800
函数的第一项

32:11.800 --> 32:12.800
是不是数组的每一个

32:12.800 --> 32:13.800
每一项的值

32:14.800 --> 32:15.800
函数的第二个

32:15.800 --> 32:17.800
函数是不是下标

32:17.800 --> 32:19.800
返回啥

32:19.800 --> 32:20.800
返回

32:21.800 --> 32:22.800
下标加e

32:23.800 --> 32:24.800
你看是不是得到

32:24.800 --> 32:25.800
一到十的数组

32:26.800 --> 32:27.800
第一个

32:27.800 --> 32:28.800
不需要它每一项

32:28.800 --> 32:29.800
每一项是啥无所谓

32:29.800 --> 32:30.800
我只是把下标加e

32:30.800 --> 32:31.800
作为它数组的项

32:32.800 --> 32:33.800
那么你看

32:33.800 --> 32:34.800
第一项是不是表示

32:34.800 --> 32:35.800
叶马1

32:35.800 --> 32:36.800
第二项表示叶马2

32:36.800 --> 32:37.800
对吧

32:37.800 --> 32:38.800
那么这个玩意

32:39.800 --> 32:45.890
你看我这里可以这样写

32:46.890 --> 32:47.890
这个玩意

32:47.890 --> 32:48.890
是不是就这个数组

32:48.890 --> 32:49.890
就这样的一个数组

32:49.890 --> 32:50.890
针对这个数组

32:50.890 --> 32:51.890
我在干嘛

32:51.890 --> 32:52.890
再用map

32:52.890 --> 32:53.890
intel

32:53.890 --> 32:54.890
再继续intel

32:56.890 --> 32:58.890
其实我这里都不用两次音色

32:59.890 --> 33:00.890
其实就在这里可以音色

33:00.890 --> 33:01.890
这个i加e

33:01.890 --> 33:03.890
其实就已经是下标加e了

33:04.890 --> 33:06.890
数组的第一项就是e

33:06.890 --> 33:07.890
数组的第二项就是

33:07.890 --> 33:08.890
如果说你是在看不懂的话

33:08.890 --> 33:09.890
我就再来一次音色

33:09.890 --> 33:11.890
对这个数组再来一次音色

33:11.890 --> 33:12.890
那么就是

33:13.890 --> 33:14.890
每一项我就把它当成一个叶马

33:15.890 --> 33:16.890
返回的是什么呢

33:16.890 --> 33:18.890
返回的是fade to student

33:18.890 --> 33:19.890
这样子的这个数组

33:19.890 --> 33:20.890
返回的是不是

33:20.890 --> 33:21.890
一个promise的数数

33:22.890 --> 33:26.350
这样得到是不是

33:26.350 --> 33:27.350
一个promise的数数

33:28.350 --> 33:29.350
promise也是对象的

33:29.350 --> 33:30.350
你不要把它讲得那么神奇

33:32.350 --> 33:33.350
给我一个叶马

33:33.350 --> 33:34.350
返回的是

33:35.350 --> 33:36.350
这个函数的返回结果

33:37.350 --> 33:38.350
这个函数的返回结果

33:38.350 --> 33:39.350
不就是promise

33:39.350 --> 33:40.350
于是把每一个数字

33:40.350 --> 33:41.350
音色成了一个promise

33:44.050 --> 33:45.050
当然你其实

33:45.050 --> 33:47.050
这两个map也没有必要

33:47.050 --> 33:48.050
你其实就在这里

33:48.050 --> 33:49.050
fade to students

33:49.050 --> 33:51.050
这里i加e加e

33:51.050 --> 33:53.740
那里就说说

33:53.740 --> 33:54.740
我要有100个学生

33:54.740 --> 33:55.740
这里起个100就好说

33:57.740 --> 33:58.740
喜欢都不用写

33:58.740 --> 33:59.740
效果是完全一样的

34:04.360 --> 34:05.360
十秒钟

34:05.360 --> 34:06.360
对不仅是十秒

34:08.360 --> 34:10.360
好这是第一题

34:13.440 --> 34:14.440
把这个保留着

34:15.440 --> 34:16.440
下一道题

34:16.440 --> 34:17.440
获取一道实业的学生

34:19.440 --> 34:20.440
不用写了

34:20.440 --> 34:22.440
然后按照叶马的顺序

34:22.440 --> 34:23.440
合并成一个数组

34:27.030 --> 34:28.030
一样的对吧

34:29.030 --> 34:31.030
如果某些叶马的数据

34:31.030 --> 34:32.030
获取失败

34:32.030 --> 34:34.030
就不加入该数据即可

34:35.030 --> 34:36.030
是不是跟之前不一样了

34:36.030 --> 34:37.030
给之前用的

34:37.030 --> 34:38.030
只要有一个失败

34:39.030 --> 34:40.030
任务都没了

34:40.030 --> 34:41.030
对吧

34:41.030 --> 34:42.030
就直接答应失败原因

34:42.030 --> 34:43.030
就完事了

34:43.030 --> 34:44.030
但是现在不是

34:45.030 --> 34:46.030
你失败失败你的吧

34:46.030 --> 34:47.030
我就是那一页不要了

34:48.030 --> 34:49.030
然后你第五页失败了

34:49.030 --> 34:50.030
我第五页不要了

34:50.030 --> 34:51.030
我就合并的时候

34:51.030 --> 34:53.030
就12346789

34:54.030 --> 34:57.030
如果说第三和五页都失败了

34:57.030 --> 34:59.030
那就1246789

35:00.030 --> 35:01.030
我就这样子

35:01.030 --> 35:02.030
不需要你失败了

35:02.030 --> 35:03.030
无所谓

35:03.030 --> 35:05.030
那你看一下用哪一个

35:06.030 --> 35:08.030
就失败的无所谓

35:08.030 --> 35:09.030
就是你只好有结果

35:09.030 --> 35:10.030
我就想

35:10.030 --> 35:12.030
是不是All settled

35:12.030 --> 35:13.030
对吧

35:14.030 --> 35:15.030
这颗任务只要你输出

35:15.030 --> 35:16.030
里面全部任务已决

35:16.030 --> 35:17.030
就想

35:17.030 --> 35:18.030
你不能不能说

35:18.030 --> 35:19.030
一个任务都还没完

35:19.030 --> 35:20.030
你就结束了

35:20.030 --> 35:21.030
不行

35:21.030 --> 35:22.030
所有的都在结束

35:22.030 --> 35:23.030
都得有结果

35:23.030 --> 35:24.030
你可能失败了

35:24.030 --> 35:25.030
你可能成功了

35:25.030 --> 35:26.030
无所谓我只需要成功的

35:26.030 --> 35:27.030
所以说我们这里

35:27.030 --> 35:29.030
就可以用Promise

35:29.030 --> 35:30.030
All settled

35:31.030 --> 35:32.030
把个数据传进去

35:33.030 --> 35:34.030
这么多人传进去

35:34.030 --> 35:35.030
好

35:35.030 --> 35:37.030
那么我看一下结果

35:38.030 --> 35:39.030
我这里不用开启了

35:39.030 --> 35:41.030
因为这个玩意是不可能失败的

35:41.030 --> 35:42.030
刚才说过了

35:42.030 --> 35:43.030
这种情况是不可能失败的

35:43.030 --> 35:45.030
所以说我这里看结果

35:45.030 --> 35:46.030
就行了

35:46.030 --> 35:47.030
看Razoff的结果

35:49.730 --> 35:50.730
你可能中间有失败

35:50.730 --> 35:51.730
有可能中间有成功

35:51.730 --> 35:52.730
无所谓

35:52.730 --> 35:55.170
你看

35:56.170 --> 35:57.170
Standars有些

35:57.170 --> 35:58.170
他第一个成功了

35:58.170 --> 35:59.170
得到了一个数组

35:59.170 --> 36:01.170
有学生对象的数组

36:01.170 --> 36:02.170
第二个成功了

36:03.170 --> 36:04.170
得到学生对象的数组

36:04.170 --> 36:05.170
第三个成功了

36:05.170 --> 36:06.170
第四个也成功了

36:06.170 --> 36:07.170
第五个

36:07.170 --> 36:08.170
这是第几个

36:08.170 --> 36:09.170
第六页失败了

36:09.170 --> 36:10.170
第七个成功了

36:10.170 --> 36:11.170
第八个成功了

36:11.170 --> 36:12.170
所以说是不是我们这里

36:12.170 --> 36:13.170
只需要成功的

36:13.170 --> 36:14.170
失败的我管都不管

36:14.170 --> 36:15.170
我只需要成功的

36:15.170 --> 36:16.170
那怎么办

36:17.170 --> 36:18.170
我们之前学过了一些数组

36:18.170 --> 36:19.170
APM拿出来用

36:22.170 --> 36:23.170
所以Filter

36:23.170 --> 36:24.170
对这个对象

36:24.170 --> 36:26.170
这些过滤

36:26.170 --> 36:27.170
Filter

36:27.170 --> 36:28.170
什么呢

36:28.170 --> 36:29.170
我只要

36:29.170 --> 36:31.170
我只要成功的

36:31.170 --> 36:32.170
就它的Standars

36:32.170 --> 36:34.170
是不是要等于Fulfill的

36:35.170 --> 36:37.170
Fulfill的比较成功

36:37.170 --> 36:38.170
这个是比较失败

36:38.170 --> 36:39.170
我只要成功的

36:40.170 --> 36:41.170
这样子是不是

36:41.170 --> 36:42.170
反回一个新数组

36:42.170 --> 36:43.170
这个新数组是不是

36:43.170 --> 36:44.170
就只有成功的

36:45.170 --> 36:47.170
然后我针对这个新数组

36:47.170 --> 36:48.170
我再来Map

36:49.170 --> 36:50.170
我们先来看

36:50.170 --> 36:51.170
一步一步来

36:52.170 --> 36:53.170
稍微快一点

36:53.170 --> 36:54.170
就有点遭不住了

36:55.170 --> 36:56.170
说说一下

36:57.170 --> 36:58.170
这里我把失败

36:58.170 --> 36:59.170
几率调高一点

36:59.170 --> 37:00.170
几点上

37:01.170 --> 37:02.170
可能会导致

37:02.170 --> 37:03.170
大面积的失败

37:04.170 --> 37:05.170
那么这样子

37:05.170 --> 37:06.170
一过滤

37:06.170 --> 37:07.170
你看这个Results里面

37:08.170 --> 37:09.170
是不是只有成功的

37:09.170 --> 37:13.170
一 二 三 四 五 六 七

37:13.170 --> 37:14.170
只有七个

37:14.170 --> 37:15.170
有三个失败了

37:15.170 --> 37:17.170
几点三还是

37:17.170 --> 37:18.170
蠻合适的

37:18.170 --> 37:19.170
三十的几率

37:20.170 --> 37:21.170
所以只有七个

37:21.170 --> 37:22.170
我就只拿到成功的

37:22.170 --> 37:23.170
我拿到成功的时候

37:23.170 --> 37:24.170
我不要这个对象

37:24.170 --> 37:25.170
我要它里面的

37:25.170 --> 37:26.170
这个数组

37:26.170 --> 37:28.170
所以说我来个硬设

37:28.170 --> 37:29.170
这是一个数组

37:29.170 --> 37:30.170
我继续硬设它

37:31.170 --> 37:33.170
把每一项item

37:33.170 --> 37:34.170
每一项我只要什么

37:34.170 --> 37:35.170
只要它等by6

37:36.170 --> 37:38.170
其他个属性我不要

37:38.170 --> 37:39.170
我只要它的by6

37:39.170 --> 37:40.170
你看一下这样得到的结果

37:41.170 --> 37:47.680
那你看是不是又形成了动格式了

37:48.680 --> 37:49.680
是不是又形成了个式了

37:50.680 --> 37:51.680
为什么不是从

37:52.680 --> 37:53.680
一开始

37:53.680 --> 37:55.680
因为它第一页失败了

37:55.680 --> 37:56.680
对这个动格式

37:56.680 --> 37:57.680
我们再来flat

37:57.680 --> 37:58.680
开扁

37:58.680 --> 38:00.680
flat就是平面的意思

38:00.680 --> 38:02.680
把这种有深度的数组结构

38:02.680 --> 38:03.680
把它开扁

38:03.680 --> 38:05.680
形成一围数组

38:06.680 --> 38:08.680
这不就是这道题的结果吗

38:09.680 --> 38:12.680
有些页码是缺失的比较第六页

38:12.680 --> 38:13.680
第六页

38:13.680 --> 38:14.680
六开头的就没有

38:14.680 --> 38:16.680
九开头的就没有

38:16.680 --> 38:18.680
这就是这道题

38:18.680 --> 38:19.680
用all settled

38:20.680 --> 38:21.680
下一道题

38:21.680 --> 38:23.680
获取一道实业的学生

38:23.680 --> 38:26.680
你们都可以自己先尝试着做一下

38:26.680 --> 38:28.680
获取一道实业的学生

38:28.680 --> 38:31.680
打印最先获取到的数据

38:32.680 --> 38:34.680
注意它的描述

38:35.680 --> 38:37.680
如果全是

38:37.680 --> 38:39.680
如果全部都获取失败

38:39.680 --> 38:41.680
只打印所有的错误消息

38:41.680 --> 38:45.310
你觉得是哪一个

38:45.310 --> 38:48.310
咱们要打印最先获取到的数据

38:49.310 --> 38:51.310
就是我只要那个

38:51.310 --> 38:53.310
第一个成功的

38:53.310 --> 38:56.690
是any

38:56.690 --> 38:57.690
任意一成功

38:57.690 --> 38:58.690
不管你是哪一个

38:58.690 --> 38:59.690
只要你成功了

38:59.690 --> 39:00.690
我就ok了

39:00.690 --> 39:02.690
我就把你打印出来

39:02.690 --> 39:04.690
全部失败了

39:04.690 --> 39:06.690
我就打印所有的错误消息

39:06.690 --> 39:07.690
所以说我这里

39:08.690 --> 39:10.690
Promise any

39:10.690 --> 39:12.690
Promise

39:12.690 --> 39:14.690
如果说我这边成功了

39:14.690 --> 39:16.690
说明有一个学生

39:16.690 --> 39:17.690
有一个学生获取到了

39:17.690 --> 39:19.690
那我就打印这个学生

39:19.690 --> 39:21.690
打印最先获取到的数据

39:21.690 --> 39:23.690
就完事了

39:23.690 --> 39:25.690
只要有一个成功

39:28.060 --> 39:30.060
哎呀他又遇到这个问题

39:30.060 --> 39:32.060
我看一下我在这边直接印行吗

39:44.780 --> 39:45.780
不行

39:45.780 --> 39:47.780
弄到里边还没有这个any方法

39:47.780 --> 39:49.780
那我只能

39:49.780 --> 39:51.780
这玩意只能在浏览器里面运行了

39:53.780 --> 39:56.780
哎呀我怎么又跑到电器体里边去写了

39:56.780 --> 40:00.470
以后把我弄出去

40:00.470 --> 40:13.260
只能在浏览器里面运行了

40:13.260 --> 40:16.260
发现第二页先成功

40:16.260 --> 40:17.260
对吧

40:17.260 --> 40:18.260
那么得到第二页

40:18.260 --> 40:19.260
那不一定的

40:19.260 --> 40:21.260
哪一页先成功不一定的

40:21.260 --> 40:23.260
现在是第三页先成功

40:23.260 --> 40:24.260
再刷新

40:24.260 --> 40:25.260
现在是第一页先成功

40:25.260 --> 40:26.260
这说不准了

40:27.260 --> 40:29.260
哪个页目先成功不准

40:29.260 --> 40:30.260
说不准

40:30.260 --> 40:31.260
但无所谓

40:31.260 --> 40:32.260
只要哪个先成功

40:32.260 --> 40:34.260
我就打印哪一个的成功消息

40:34.260 --> 40:36.260
什么情况下我会失败

40:36.260 --> 40:37.260
就全部都失败了

40:37.260 --> 40:38.260
我就会失败

40:38.260 --> 40:40.260
那么我就打印失败的消息

40:41.260 --> 40:43.260
什么时候我们全部会失败

40:43.260 --> 40:44.260
就全部失败了

40:44.260 --> 40:45.260
不要说我这里

40:45.260 --> 40:46.260
就夸张一点小鱼

40:46.260 --> 40:47.260
是不是有一定失败

40:47.260 --> 40:48.260
那么这种情况下的

40:48.260 --> 40:50.260
它一定是全部失败

40:50.260 --> 40:51.260
你看我一直在等

40:51.260 --> 40:52.260
等所有人完成

40:52.260 --> 40:54.260
我发现全部都失败了

40:54.260 --> 40:55.260
全部都失败的时候

40:55.260 --> 40:57.260
就写下它的一边的Adress

40:57.260 --> 40:58.260
对吧

40:58.260 --> 40:59.260
有一个属性

40:59.260 --> 41:00.260
这项目看到过的

41:00.260 --> 41:01.260
这个属性

41:01.260 --> 41:03.260
就可以拿到所有的错误消息

41:03.260 --> 41:04.260
你看

41:05.260 --> 41:07.260
这是个数书

41:07.260 --> 41:08.260
这是个数书

41:09.260 --> 41:10.260
第一个错误消息

41:10.260 --> 41:11.260
第二个错误消息

41:12.260 --> 41:13.260
OK

41:13.260 --> 41:14.260
这是这道题

41:15.260 --> 41:17.260
好 下一道题

41:18.260 --> 41:19.260
获取一道实验的学生

41:19.260 --> 41:22.260
输出最先得到的结果

41:22.260 --> 41:24.260
有结果输出结果

41:24.260 --> 41:25.260
输出错误

41:25.260 --> 41:26.260
这是啥意思

41:26.260 --> 41:28.260
这就是Race

41:29.260 --> 41:30.260
反正有结果就行

41:30.260 --> 41:32.260
我不管你是成功还是失败

41:32.260 --> 41:35.260
就第一个有结果的那个任务

41:35.260 --> 41:36.260
一到实验

41:36.260 --> 41:37.260
我是拿第一页的数据

41:37.260 --> 41:38.260
拿第二的数据

41:38.260 --> 41:39.260
谁先回来

41:39.260 --> 41:40.260
不管你是拿到

41:40.260 --> 41:41.260
还是没拿到

41:41.260 --> 41:42.260
你回来了

41:42.260 --> 41:43.260
我就看一下

41:43.260 --> 41:45.260
你怎么是什么情况

41:45.260 --> 41:46.260
其他的不管

41:46.260 --> 41:47.260
说到这里

41:47.260 --> 41:48.260
那就也很简单

41:48.260 --> 41:49.260
Promise

41:49.260 --> 41:50.260
Race

41:50.260 --> 41:53.820
Promise

41:54.820 --> 41:55.820
Race out

41:56.820 --> 41:57.820
第一个的数据

41:58.820 --> 41:59.820
还有就是

41:59.820 --> 42:00.820
第一个的错误消息

42:01.820 --> 42:02.820
就用这样子写吧

42:02.820 --> 42:03.820
都行

42:04.820 --> 42:06.820
这边我们要精力调低一点

42:06.820 --> 42:07.820
0.3

42:08.820 --> 42:09.820
我也不知道

42:09.820 --> 42:10.820
我现在我也不知道

42:10.820 --> 42:11.820
第一个到底是成功还是失败

42:11.820 --> 42:12.820
反正就第一个有结果的

42:12.820 --> 42:13.820
第一个

42:13.820 --> 42:14.820
第一个有结果的说明啥

42:14.820 --> 42:16.820
说明是第十页

42:16.820 --> 42:19.820
第十页算一先有结果

42:19.820 --> 42:20.820
它结果呢

42:20.820 --> 42:21.820
是失败的

42:21.820 --> 42:22.820
那我就运行了这个

42:23.820 --> 42:24.820
再来一次

42:25.820 --> 42:26.820
这是第三页

42:26.820 --> 42:27.820
算一先有结果

42:27.820 --> 42:28.820
第三页的结果是成功的

42:28.820 --> 42:30.820
我就拿了第三页

42:30.820 --> 42:31.820
那么这种情况

42:31.820 --> 42:32.820
如果说

42:32.820 --> 42:33.820
什么情况

42:33.820 --> 42:34.820
我们会用这种

42:36.820 --> 42:37.820
在目前的场景下

42:37.820 --> 42:39.820
好像也不会用到这种方式

42:39.820 --> 42:41.820
就举了这么个例子

42:41.820 --> 42:42.820
最后我给大家看一下

42:42.820 --> 42:44.820
邓哥的解决办法

42:45.820 --> 42:46.820
我们前面不是说

42:46.820 --> 42:47.820
邓哥有这么三个函数吗

42:47.820 --> 42:48.820
邓哥的解决办法

42:48.820 --> 42:50.820
就是这么一套袋

42:50.820 --> 42:54.160
不能这样的写对吧

42:54.160 --> 42:55.160
要怎么写

42:56.160 --> 42:59.540
它不就是要要一个结果吗

42:59.540 --> 43:00.540
不管它

43:00.540 --> 43:01.540
不管全部成功还是全部失败

43:01.540 --> 43:02.540
还是有些成功有些失败

43:02.540 --> 43:04.540
我就要汇总一个结果

43:04.540 --> 43:06.540
所以说这里最适合用 all settled

43:07.540 --> 43:08.540
只要你有结果就行

43:08.540 --> 43:10.540
因为我要给邓少汇报

43:11.540 --> 43:12.540
那么拿几个 promise

43:12.540 --> 43:13.540
第一个

43:13.540 --> 43:14.540
调用这个函数

43:14.540 --> 43:15.540
是不是拿到一个 promise

43:15.540 --> 43:16.540
调这个函数

43:16.540 --> 43:17.540
是不是拿到一个 promise

43:17.540 --> 43:18.540
调这个函数

43:18.540 --> 43:19.540
是不是拿到一个 promise

43:19.540 --> 43:20.540
这三个 promise 都去做吧

43:21.540 --> 43:22.540
如果说

43:22.540 --> 43:23.540
反正就是

43:23.540 --> 43:25.540
我最终要汇总成一个结果

43:25.540 --> 43:27.540
你们都有结果了之后

43:27.540 --> 43:29.540
下面大马如果说看不懂的话

43:29.540 --> 43:31.540
我来一步一步来看

43:31.540 --> 43:32.540
你们都有结果了

43:32.540 --> 43:33.540
我们来看一下这个 result

43:39.180 --> 43:41.180
是不是前两个都有出了问题

43:41.180 --> 43:42.180
最后一个成功了

43:43.180 --> 43:44.180
对不对

43:45.180 --> 43:46.180
再来看

43:46.180 --> 43:47.180
运行

43:47.180 --> 43:48.180
那输不准的

43:48.180 --> 43:49.180
我用我用了水机

43:50.180 --> 43:51.180
第一个成功了

43:51.180 --> 43:52.180
后边两个都有出了问题

43:52.180 --> 43:53.180
对吧

43:53.180 --> 43:54.180
不管出什么问题

43:54.180 --> 43:55.180
反正就是汇报一下

43:55.180 --> 43:56.180
给邓少汇报

43:56.180 --> 43:57.180
怎么汇报

43:58.180 --> 43:59.180
当然就是

43:59.180 --> 44:00.180
这就无所谓了

44:00.180 --> 44:01.180
其实你只要能看懂这个就无所谓了

44:01.180 --> 44:03.180
然后我这里边用了一种方式

44:03.180 --> 44:04.180
就是说

44:05.180 --> 44:06.180
我把它形成

44:06.180 --> 44:08.180
把这个玩意儿变成一个字母创

44:08.180 --> 44:10.180
如果说你是成功的

44:10.180 --> 44:12.180
我就得到它的 value

44:12.180 --> 44:13.180
如果说你是失败的

44:13.180 --> 44:14.180
我就得到它的 reason

44:14.180 --> 44:16.180
然后得到这么一个字母创数

44:16.180 --> 44:17.180
所以我这里咋写的呢

44:17.180 --> 44:18.180
result

44:19.180 --> 44:20.180
filt

44:21.180 --> 44:22.180
把每一个对象

44:23.180 --> 44:24.180
做一个三目运算

44:24.180 --> 44:26.180
如果说它的 standard 是等于

44:26.180 --> 44:27.180
filt

44:29.180 --> 44:30.180
filt

44:30.180 --> 44:32.180
表示如果说你的任务成功的

44:32.180 --> 44:34.180
成功的话我就拿你的 value

44:35.180 --> 44:36.180
如果说你是失败的

44:36.180 --> 44:37.180
我就拿你的 reason

44:39.180 --> 44:42.180
总会有一个数据

44:42.180 --> 44:43.180
那我们来看一下

44:43.180 --> 44:44.180
说这个结果输出

44:44.180 --> 44:48.060
是否拿到一个字母创的输出

44:49.060 --> 44:50.060
对吧

44:50.060 --> 44:51.060
拿到一个字母创的输出

44:51.060 --> 44:52.060
然后呢

44:52.060 --> 44:53.060
我把这个字母创的输出

44:53.060 --> 44:55.060
用交易连接起来

44:55.060 --> 44:56.060
有一个分号连接

44:57.060 --> 44:58.060
我就是起了这么一段来

44:58.060 --> 44:59.060
你自己看

44:59.060 --> 45:02.820
没有什么好说的

45:03.820 --> 45:05.820
要么就得到它的 value

45:05.820 --> 45:06.820
要么把它的 reason

45:06.820 --> 45:07.820
然后呢

45:07.820 --> 45:08.820
用分号连接

45:08.820 --> 45:09.820
最后把这个得到的

45:09.820 --> 45:11.820
最终的那个字母创打印出来

45:12.820 --> 45:14.820
就是可以更早汇报的结果

45:16.820 --> 45:17.820
你会

45:17.820 --> 45:18.820
同这个汇报结果

45:18.820 --> 45:19.820
可以看出

45:20.820 --> 45:22.820
做方案好像出了问题

45:22.820 --> 45:23.820
衣服好像没问题了

45:23.820 --> 45:25.820
极其的有问题

45:26.820 --> 45:28.820
这就是咱们

45:28.820 --> 45:29.820
这个结果的东西

45:29.820 --> 45:31.820
这个东西整体还是比较简单的

45:31.820 --> 45:32.820
就是

45:33.820 --> 45:34.820
做一些

45:34.820 --> 45:35.820
有了一些静态方法

45:35.820 --> 45:38.820
可以让我们对多任务的倡议

45:38.820 --> 45:40.820
有了一些控制能力

45:41.820 --> 45:43.820
这是这个结果的内容

45:43.820 --> 45:44.820
大家下去把这个作业题

45:44.820 --> 45:46.820
好好去梳理一下

45:46.820 --> 45:47.820
你可以自己写不出来

45:47.820 --> 45:48.820
然后呢

45:48.820 --> 45:49.820
听到我讲件之后

45:49.820 --> 45:50.820
不要那么写出来

45:50.820 --> 45:51.820
然后呢

45:51.820 --> 45:52.820
把这个笨哥的例子

45:52.820 --> 45:53.820
也好好去体会一下

45:53.820 --> 45:54.820
这一回就到这了

