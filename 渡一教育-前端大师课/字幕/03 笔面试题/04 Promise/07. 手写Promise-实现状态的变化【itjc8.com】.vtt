WEBVTT

00:00.110 --> 00:03.550
好 那么我们现在开始来写这个Promise

00:03.550 --> 00:05.950
我们写Promise实际上写的是什么呢

00:05.950 --> 00:07.950
其实写的就是一个构造器

00:07.950 --> 00:09.550
对吧 我们通过一个New

00:09.550 --> 00:11.870
然后能通过这个构造器Promise

00:11.870 --> 00:13.390
然后给它团一个参数

00:13.390 --> 00:14.990
就能创建这么一个Promise

00:14.990 --> 00:16.590
对吧 这是我们的创建方式

00:16.590 --> 00:18.830
然后我们这里可能就先来写这个构造器

00:18.830 --> 00:20.430
我们完全可以使用ES6

00:20.430 --> 00:21.630
给我们提供的Class

00:21.630 --> 00:23.470
来写完成这个构造器的书写

00:23.470 --> 00:26.910
然后名字呢我们就给它取名为MyPromise

00:26.910 --> 00:28.270
好 因为它是个构造器啊

00:28.270 --> 00:30.030
所以说我们需要取一个Constructor

00:30.110 --> 00:32.110
那么这个Constructor里边有没有参数呢

00:32.110 --> 00:34.830
你会发现它是需要传递一个参数的 对吧

00:34.830 --> 00:36.190
那么这个参数是啥呢

00:36.190 --> 00:38.830
其实就是Promise本身就是一个任务

00:38.830 --> 00:39.950
那这个参数是什么呢

00:39.950 --> 00:41.230
参数是一个函数

00:41.230 --> 00:44.430
这个函数呢它表示的是任务的执行过程

00:44.430 --> 00:46.990
它描述了这个任务一开始做什么再做什么

00:46.990 --> 00:48.430
对吧 那我们这里呢

00:48.430 --> 00:50.430
给它取个名字叫做Excutor

00:50.430 --> 00:52.270
Excutor什么意思呢

00:52.270 --> 00:54.750
就执行器啊 然后打个注释

00:54.750 --> 00:58.670
这是创建一个Promise

00:59.390 --> 01:00.910
然后呢这个地方是什么呢

01:00.910 --> 01:02.430
它是一个函数方式

01:02.430 --> 01:07.310
然后呢它是表示任务执行器

01:07.310 --> 01:09.550
调用这个函数它就会执行任务

01:09.550 --> 01:12.030
然后我们通过之前学些Promise

01:12.030 --> 01:14.430
我们应该知道这个函数是不是同步执行的

01:14.430 --> 01:15.710
立即执行 对吧

01:15.710 --> 01:19.310
这里这个函数立即执行

01:19.310 --> 01:21.790
立即执行

01:21.790 --> 01:26.430
好 OK 那么这就是一个基本的结构就出来了

01:26.430 --> 01:28.030
那么这个函数要立即执行

01:28.030 --> 01:30.110
那怎么来执行呢 是不是通过这种方式

01:30.110 --> 01:31.710
调用它是不是就完事了

01:31.710 --> 01:32.990
一定要用这个函数

01:32.990 --> 01:34.590
那么这个函数要不要传参数呢

01:34.590 --> 01:35.950
你看一下这个函数有没有参数

01:35.950 --> 01:37.230
是不是有两个参数啊

01:37.230 --> 01:38.270
这两个参数是什么

01:38.270 --> 01:39.070
又是一个函数

01:39.070 --> 01:40.750
一个Result一个Reject

01:40.750 --> 01:42.430
对不对 是不是有两个参数

01:42.430 --> 01:44.830
那么我们这里呢需要给它传递两个参数

01:44.830 --> 01:46.830
一个是Result一个是Reject

01:46.830 --> 01:48.110
那么如何来传递呢

01:48.110 --> 01:49.310
当然我们可以在这里呢

01:49.310 --> 01:50.190
去协谅两个函数

01:50.190 --> 01:51.390
一个是Result

01:51.390 --> 01:52.910
Result函数

01:52.910 --> 01:54.430
不要定义两个函数

01:54.430 --> 01:55.790
然后呢一个是Reject

01:55.790 --> 01:57.310
通过这种方式给它传递进去

01:57.390 --> 01:58.430
但是这样子做的话

01:58.430 --> 01:59.950
会把这里代码写得很乱

01:59.950 --> 02:01.150
所以说我这边呢

02:01.150 --> 02:03.790
就打算这里新开两个

02:03.790 --> 02:05.630
在原型上给它开两个函数

02:05.630 --> 02:07.870
因为这两个函数呢我不希望用户调用

02:09.310 --> 02:11.790
我这个函数会把它传进来对吧

02:11.790 --> 02:13.230
所以说我这里不希望用户调用

02:13.230 --> 02:14.350
因此呢我这里

02:14.350 --> 02:16.750
从命名上给它加上一个下滑线

02:16.750 --> 02:18.030
这也是无忧的

02:18.030 --> 02:19.310
既然无忧啊或者一些

02:19.310 --> 02:20.750
别的第三方库的一些做法

02:20.750 --> 02:21.790
一些私有的东西呢

02:21.790 --> 02:24.750
我把它写成一个下滑线开头

02:24.750 --> 02:26.750
然后这里呢我写个Result函数

02:27.550 --> 02:29.390
然后还有一个就是Reject函数

02:31.150 --> 02:31.710
Reject函数

02:32.990 --> 02:35.070
这两个函数我打算一个注释啊

02:35.070 --> 02:36.030
这个函数是做什么呢

02:36.030 --> 02:37.710
因为我们代码最后可能比较多啊

02:37.710 --> 02:39.310
其实也就200多行吧

02:39.310 --> 02:40.190
也不是很多

02:40.910 --> 02:42.590
所以还不止200多行

02:42.590 --> 02:43.790
因为还有静态方法

02:43.790 --> 02:45.470
我们还是把注释打好

02:45.470 --> 02:46.430
这个函数是做什么呢

02:46.430 --> 02:51.550
就是标记当前任务完成

02:51.550 --> 02:51.950
对吧

02:51.950 --> 02:52.990
一调这个函数

02:52.990 --> 02:53.950
相当于是调这个

02:53.950 --> 02:55.470
调这个函数相当于是调这个

02:55.470 --> 02:57.150
那么就标记当前任务完成

02:57.230 --> 03:00.510
然后这里呢就是标记当前任务失败

03:00.510 --> 03:00.990
对吧

03:00.990 --> 03:01.870
就做这么一个作用

03:02.430 --> 03:02.590
好

03:02.590 --> 03:03.630
我们再来看一下啊

03:03.630 --> 03:05.790
这两个函数有没有参数啊

03:06.590 --> 03:07.470
那肯定有参数

03:07.470 --> 03:07.870
为什么呢

03:07.870 --> 03:08.990
因为我调这个函数的时候

03:08.990 --> 03:09.790
Result的时候

03:09.790 --> 03:10.750
我是不是要给它传

03:10.750 --> 03:11.870
可以给它传参数对吧

03:12.830 --> 03:13.550
调这个函数

03:13.550 --> 03:14.750
也可以不传也可以传

03:14.750 --> 03:15.230
不传的话

03:15.230 --> 03:17.390
相当于是传的是N一半对不对

03:17.390 --> 03:18.270
是不是可以传参数

03:18.270 --> 03:20.110
因此这两个函数都是有参数的

03:20.110 --> 03:20.830
这两个参数呢

03:20.830 --> 03:22.590
我们分别给它命名为data

03:22.590 --> 03:22.990
对吧

03:22.990 --> 03:23.950
任务完成的时候

03:23.950 --> 03:26.350
是不是可以有一个参数数是

03:27.470 --> 03:30.110
内情是ndata表示的是什么意思呢

03:30.110 --> 03:34.030
表示任务完成的相关数据

03:34.910 --> 03:35.870
然后这边呢

03:35.870 --> 03:37.710
它也会有一个参数叫result

03:37.710 --> 03:39.630
就是任务失败的时候的相关数据

03:40.910 --> 03:42.910
上paraday

03:43.310 --> 03:44.350
那么这里呢就是result

03:45.710 --> 03:47.710
任务失败的相关数据

03:48.990 --> 03:49.390
对不对

03:50.430 --> 03:50.750
好

03:50.750 --> 03:52.350
那么我们把这个结构写出来了

03:52.350 --> 03:53.950
这两个函数各有参数

03:54.350 --> 03:54.670
好了

03:54.670 --> 03:55.790
有了这两个函数之后呢

03:55.870 --> 03:59.790
我这边在调用这个任务描述函数的时候

03:59.790 --> 04:00.910
调用它的时候

04:00.910 --> 04:02.190
那我是不是把这两个函数给

04:02.190 --> 04:02.990
它就完成了

04:02.990 --> 04:03.310
对吧

04:03.310 --> 04:04.030
我这里不要用

04:04.030 --> 04:04.750
但是我给你

04:04.750 --> 04:06.030
你任何时候都可以调用

04:06.030 --> 04:06.590
一调用

04:06.590 --> 04:07.310
那我这个

04:07.310 --> 04:07.950
调用这个

04:07.950 --> 04:08.670
任务就完成了

04:08.670 --> 04:09.710
调这个任务就失败了

04:09.710 --> 04:10.350
所以说我这里呢

04:10.350 --> 04:13.550
可以通过这个zresult

04:14.270 --> 04:15.550
是把函数就传给它了

04:15.550 --> 04:17.950
zresult就传给它了

04:17.950 --> 04:20.190
就这个基本逻辑就出来了

04:20.190 --> 04:21.790
那么比方说我这里函数里边

04:22.510 --> 04:23.550
输出一个

04:23.550 --> 04:23.950
完成

04:25.550 --> 04:26.270
这里呢

04:26.270 --> 04:27.950
我输出一个失败

04:28.830 --> 04:29.230
然后呢

04:29.230 --> 04:30.750
我还可以把打印出来

04:30.750 --> 04:30.990
对吧

04:31.790 --> 04:32.110
接下来

04:33.630 --> 04:34.430
这里的失败呢

04:34.430 --> 04:35.710
我就是打印这个zresult

04:37.150 --> 04:37.550
解说了

04:39.230 --> 04:39.550
好

04:39.550 --> 04:41.070
那这个基本结构出来之后呢

04:41.070 --> 04:42.030
我们来试一下

04:42.030 --> 04:43.790
我们把它变成我们的myresult

04:45.070 --> 04:45.950
mypromise

04:46.670 --> 04:46.750
好

04:46.750 --> 04:48.030
我们先调用zresult

04:48.030 --> 04:48.590
看一下

04:48.590 --> 04:50.110
我调用这个函数的时候

04:50.110 --> 04:51.070
因为我这里传

04:51.150 --> 04:51.790
传递的是它

04:51.790 --> 04:52.190
对吧

04:52.190 --> 04:53.470
所以我调这个函数的时候呢

04:53.470 --> 04:54.590
实际上调的是谁

04:54.590 --> 04:56.270
实际上调的就是这个

04:57.070 --> 04:57.550
对吧

04:57.550 --> 04:59.150
然后传递到一个123

04:59.150 --> 05:00.030
那么这个123呢

05:00.030 --> 05:01.390
实际上传给谁啊

05:01.390 --> 05:02.510
就传给这个data

05:03.390 --> 05:03.630
对吧

05:03.630 --> 05:04.350
我们来试一下

05:04.830 --> 05:06.590
然后我们就用那个code runner

05:06.590 --> 05:08.190
然后你直接调用

05:08.190 --> 05:08.670
是不是

05:08.670 --> 05:09.390
就输出了这个

05:09.390 --> 05:09.790
说明啥

05:09.790 --> 05:11.310
说明我们这里调的Zresult

05:11.310 --> 05:12.030
确实是这个

05:12.990 --> 05:13.230
OK

05:13.230 --> 05:14.350
我们就写到这了

05:14.350 --> 05:15.630
然后写到这有没有什么问题呢

05:15.630 --> 05:16.990
其实还是有些问题的

05:16.990 --> 05:18.830
因为我这个函数里边呢

05:18.830 --> 05:19.230
肯定

05:19.870 --> 05:20.590
你可以想象

05:20.750 --> 05:21.390
这个函数里边

05:21.390 --> 05:23.390
我们一个promise完成了

05:23.390 --> 05:24.590
我们要做什么事情

05:25.790 --> 05:26.510
promise完成了

05:26.510 --> 05:26.910
有的人说

05:26.910 --> 05:28.750
promise完成了是不是要调用Zin啊

05:28.750 --> 05:29.550
那不一定

05:29.550 --> 05:30.350
因为我这里可能

05:30.910 --> 05:33.790
可能任何都没有调用Zin对吧

05:33.790 --> 05:35.470
就没有直接的关系

05:35.470 --> 05:36.990
有一些关系没有直接的关系

05:36.990 --> 05:38.750
promise完成过后做什么呢

05:38.750 --> 05:39.630
我们回忆一下

05:40.350 --> 05:42.190
我们之前讲promise的时候

05:42.190 --> 05:43.150
是不是两个阶段

05:43.150 --> 05:43.870
三个状态

05:44.670 --> 05:45.630
一开始状态是什么

05:45.630 --> 05:46.510
pending

05:46.510 --> 05:47.950
完成之后的状态是什么

05:47.950 --> 05:49.150
完成状态是什么

05:49.150 --> 05:49.710
ffield

05:50.430 --> 05:51.390
失败的状态是什么

05:51.390 --> 05:52.270
rejecting的

05:52.270 --> 05:52.510
对吧

05:52.510 --> 05:52.990
所以说

05:52.990 --> 05:54.670
我们无论是完成也好

05:54.670 --> 05:55.630
还是失败也好

05:55.630 --> 05:57.710
实际上是要改变状态的

05:57.710 --> 05:58.190
因此呢

05:58.190 --> 05:59.870
我们完成实际上是做什么

05:59.870 --> 06:00.670
改变状态

06:02.590 --> 06:03.470
和数据

06:03.470 --> 06:03.790
对吧

06:03.790 --> 06:05.470
我们成功之后是不是有个数据

06:05.470 --> 06:06.590
把数据改掉

06:06.590 --> 06:08.190
然后失败的时候改什么呢

06:08.190 --> 06:08.590
改变

06:10.750 --> 06:13.550
也是改变状态和数据

06:13.550 --> 06:13.710
对吧

06:13.710 --> 06:15.550
这个数据就是失败的原因

06:15.550 --> 06:17.150
是不是都要做这么一件事

06:17.150 --> 06:19.150
因此我们这里肯定要改变状态和数据

06:19.870 --> 06:22.430
那我们状态和数据在哪里去改变呢

06:22.430 --> 06:23.470
其实非常简单

06:23.470 --> 06:25.070
我就给每一个promise

06:25.070 --> 06:26.190
设置一些属性

06:26.190 --> 06:26.990
设置两个属性

06:26.990 --> 06:27.790
一个是状态

06:27.790 --> 06:28.670
我们用一个下方线

06:28.670 --> 06:29.630
set

06:29.630 --> 06:31.230
这个属性一开始是什么

06:31.230 --> 06:31.870
pending

06:31.870 --> 06:32.350
对吧

06:32.350 --> 06:33.470
这叫状态

06:34.590 --> 06:35.310
还有一个属性呢

06:35.310 --> 06:36.110
就是value

06:37.070 --> 06:38.350
这是一开始是undefend

06:38.990 --> 06:39.710
这是数据

06:41.070 --> 06:42.110
其实我们要改什么呢

06:43.790 --> 06:44.430
要改什么呢

06:44.430 --> 06:46.190
其实不就是改这两个东西吗

06:46.190 --> 06:47.150
如果说你成功了

06:47.150 --> 06:47.950
我改什么

06:47.950 --> 06:48.990
是不是要改这个this

06:50.110 --> 06:50.430
set

06:51.310 --> 06:52.350
把它变为什么

06:52.350 --> 06:53.630
变为ful field

06:54.750 --> 06:55.310
对吧

06:55.310 --> 06:56.270
变这个

06:56.270 --> 06:57.870
然后再把这个数据

06:57.870 --> 06:59.390
value变成什么data

07:00.270 --> 07:01.390
那我失败的时候呢

07:02.110 --> 07:03.230
是不是要做这么一件事

07:03.230 --> 07:04.350
变成regality

07:05.870 --> 07:06.350
然后呢

07:06.350 --> 07:06.830
数据呢

07:07.550 --> 07:08.350
失败的原因呢

07:08.350 --> 07:08.990
就是这个regin

07:09.550 --> 07:10.430
是不是要做这么一件事

07:10.990 --> 07:11.230
好

07:11.230 --> 07:12.590
这个逻辑没问题吧

07:12.590 --> 07:12.750
好

07:12.750 --> 07:13.550
那么没有没问题的话

07:13.550 --> 07:14.910
我们再来运行一下

07:14.910 --> 07:15.550
那么这个时候呢

07:15.550 --> 07:16.670
你会发现它爆错了

07:18.430 --> 07:19.390
他说为什么爆错呢

07:19.470 --> 07:20.030
他说这个

07:20.510 --> 07:22.670
无法读取state of undefend

07:23.230 --> 07:24.750
从undefend里边读属性

07:24.750 --> 07:25.790
state是读不到的

07:25.790 --> 07:26.750
为什么读不到呢

07:26.750 --> 07:28.190
是因为这个z是undefend

07:28.670 --> 07:30.110
那为什么z是undefend呢

07:30.110 --> 07:31.470
我们说z的指向啊

07:32.670 --> 07:33.870
因为我们调这个regio

07:34.590 --> 07:35.310
调这个regio

07:35.310 --> 07:36.030
实际上调什么呢

07:36.030 --> 07:36.990
调的只有这个regio

07:37.470 --> 07:37.950
对吧

07:38.190 --> 07:39.790
那么这个regio里边用到了z

07:39.790 --> 07:41.710
那z的指向指向谁呢

07:41.710 --> 07:43.470
我们说z的指向学义什么

07:43.470 --> 07:44.910
学义如何调用它

07:44.910 --> 07:45.870
那我这里怎么调用呢

07:45.870 --> 07:46.750
是不是直接调用的

07:47.470 --> 07:48.750
直接调用它z指向谁

07:49.230 --> 07:51.070
就按理说应该指向全局辨量

07:51.070 --> 07:53.470
但是由于我使用了es6的class

07:53.950 --> 07:54.670
然后又导致呢

07:54.670 --> 07:55.870
它是在严格模式下边

07:55.870 --> 07:56.670
严格模式下边

07:56.670 --> 07:58.430
设置了这个z的指向是undefend

07:58.910 --> 08:00.430
因此就导致了这样的问题

08:00.430 --> 08:01.150
那怎么办呢

08:01.150 --> 08:01.950
我希望是什么

08:01.950 --> 08:03.310
希望这个z是指向什么

08:03.310 --> 08:04.910
指向当前的promise对象

08:05.710 --> 08:07.550
那我在传的时候可以这样子

08:07.550 --> 08:08.590
加上一个band

08:08.590 --> 08:09.710
是不是就可以搞定了

08:09.710 --> 08:10.190
对吧

08:10.190 --> 08:10.830
band.z

08:11.550 --> 08:12.350
那么这样子的

08:12.350 --> 08:13.790
它band的方法

08:13.790 --> 08:15.070
会返回一个新的函数

08:15.070 --> 08:16.030
这个新的函数呢

08:16.510 --> 08:18.270
就是绑进了z的函数

08:19.070 --> 08:20.350
那么这边也是一样

08:21.070 --> 08:21.950
band的函数

08:22.830 --> 08:24.270
这里的z是什么

08:24.270 --> 08:25.470
这里的z就是

08:25.470 --> 08:26.670
当前的promise

08:26.670 --> 08:28.270
当前新创建的promise

08:28.270 --> 08:28.830
对吧

08:28.830 --> 08:30.990
然后我把这个函数绑定了z

08:30.990 --> 08:32.110
那么之后调用的函数

08:32.110 --> 08:33.150
无论你怎么调用它

08:33.150 --> 08:34.430
它z的都是指向

08:35.390 --> 08:36.270
新的promise

08:36.270 --> 08:37.630
那么我现在再看一下

08:39.390 --> 08:40.270
所以没爆错了

08:40.270 --> 08:41.390
好咱们来试一下

08:41.390 --> 08:42.910
我们这里得到一个promise

08:44.750 --> 08:45.710
输出这个promise

08:46.270 --> 08:47.310
好没有些印象

08:48.270 --> 08:49.710
我们把这个运行干脆

08:50.750 --> 08:51.310
关到

08:51.310 --> 08:52.510
可以换到另外一个地方吗

08:53.550 --> 08:54.190
这个玩意儿

08:55.390 --> 08:56.030
能换吗

08:57.710 --> 08:58.030
等一下

08:58.030 --> 08:58.510
我试一下

08:59.230 --> 09:00.510
将一到右侧

09:00.510 --> 09:01.870
这样子舒服一些

09:03.550 --> 09:04.030
那现在呢

09:04.030 --> 09:05.470
你看我们现在是不是完成了

09:05.470 --> 09:06.430
rezo5123

09:06.430 --> 09:07.710
那么就付费用的

09:07.710 --> 09:08.750
z呢就是123

09:08.750 --> 09:10.590
那如果说我用reget的程度

09:12.510 --> 09:13.710
那它装上就是reget的

09:13.710 --> 09:14.830
对吧123

09:14.830 --> 09:15.310
好ok

09:15.310 --> 09:16.270
这一回合就完成了

09:16.990 --> 09:17.550
那么写到这呢

09:17.550 --> 09:19.470
其实我们可以进一步优化我们的程序

09:20.030 --> 09:21.310
首先第一个优化点

09:21.310 --> 09:22.350
就是我们这些状态

09:22.350 --> 09:23.150
我们目前用的是

09:23.150 --> 09:24.190
置物串的处理方式

09:24.190 --> 09:25.070
你看这里是置物串

09:25.070 --> 09:26.030
这里是置物串

09:26.030 --> 09:26.910
那么这种到处

09:26.910 --> 09:28.430
那么我们就会发现

09:28.430 --> 09:29.310
我们在单码里面

09:29.310 --> 09:31.550
可能这些置物串分布在很多地方

09:31.550 --> 09:31.950
以后呢

09:31.950 --> 09:33.150
我们将来的判断呀

09:33.150 --> 09:33.870
判断它的状态

09:33.870 --> 09:35.230
各种状态的处理的

09:35.230 --> 09:36.910
我们都可能会用到这种置物串

09:36.910 --> 09:38.350
是不是会反复使用

09:38.350 --> 09:39.150
那么这种置物串

09:39.150 --> 09:40.190
会反复出现的话

09:40.190 --> 09:41.550
那么会造成一些

09:41.550 --> 09:43.070
很难维护的一个问题

09:43.150 --> 09:44.030
将来我如果说

09:44.030 --> 09:46.110
我们把状态的名字想变一下

09:46.110 --> 09:47.710
其实Promise这个

09:47.710 --> 09:50.350
ES6的Promise的状态名字都变过一次

09:50.350 --> 09:51.790
一开始完成了状态的名字

09:51.790 --> 09:53.310
叫做Razor

09:53.310 --> 09:54.830
后来变成了Fulfilled

09:54.830 --> 09:56.190
将来要改变状态的名字

09:56.190 --> 09:57.070
是不知道到处感

09:57.070 --> 09:57.950
所以我们一般来说

09:57.950 --> 09:59.710
对这里的做法呢

09:59.710 --> 10:00.670
一个优秀的代码呢

10:00.670 --> 10:02.430
我们可以把它变成一个常量

10:02.430 --> 10:04.270
用常量来代替这个置物串

10:04.270 --> 10:05.150
那我们可以把常量

10:05.150 --> 10:06.590
常量写到上面

10:06.590 --> 10:10.990
就是记录Promise的三种状态

10:10.990 --> 10:12.270
就一共有只有三种状态

10:12.350 --> 10:13.310
那么我们这里呢

10:13.310 --> 10:14.270
常量的写法呢

10:14.270 --> 10:16.110
我们一般来说

10:16.110 --> 10:18.110
我说的常量不是这个Counts

10:18.110 --> 10:20.110
只得它真正的是常量

10:20.110 --> 10:22.670
真正的永远不会改变的这种东西

10:22.670 --> 10:24.350
我们就写Pendy

10:24.350 --> 10:25.870
那么就写Pendy

10:25.870 --> 10:26.910
用这种模式来写

10:26.910 --> 10:28.990
这种模式其实也很常见的

10:28.990 --> 10:32.190
还有一个就是Fulfilled

10:32.190 --> 10:35.790
把它变成Fulfilled

10:35.790 --> 10:38.910
然后还有一个就是Rejective

10:38.910 --> 10:40.670
写成Rejective

10:40.670 --> 10:41.390
那么这里呢

10:41.390 --> 10:44.270
我们可以用这个常量来替代这个置物串了

10:44.270 --> 10:46.110
这样子写出来优雅的多

10:46.110 --> 10:47.630
其实大厂在考验

10:47.630 --> 10:49.230
考虑这些东西的时候

10:49.230 --> 10:51.550
一方面在考虑也你的逻辑示威能力

10:51.550 --> 10:53.550
另一方面也在考验你的代码

10:53.550 --> 10:54.190
处理能力

10:54.190 --> 10:57.390
你想把这些代码把它处理好了之后

10:57.390 --> 10:59.310
写出来真的很吓人的

10:59.310 --> 11:00.190
说实话

11:00.190 --> 11:01.710
要不会把面试完吓到的

11:01.710 --> 11:03.070
如果你真的能够把

11:03.070 --> 11:06.270
我这些Promise手写的东西试透

11:06.270 --> 11:08.030
然后面试真的能够把写出来的话

11:08.030 --> 11:09.710
真的会很吓人的

11:09.710 --> 11:11.310
好 这也是一个优化点

11:11.470 --> 11:12.910
然后这个优化点完了之后呢

11:12.910 --> 11:14.670
你会发现这一块有重复代吗

11:15.550 --> 11:17.550
其实你会发现改变状态

11:19.230 --> 11:21.950
无论是Rejective也好还是Rejective也好

11:21.950 --> 11:23.550
他们都会在改变状态 对不对

11:23.550 --> 11:25.550
所以说我们可以把改变状态这个行为呢

11:25.550 --> 11:26.350
抽离出去

11:26.350 --> 11:27.550
形成一个单独的函数

11:27.550 --> 11:29.310
因此呢 我在这里呢写上一个Change

11:29.310 --> 11:30.110
Status

11:30.110 --> 11:30.830
State

11:31.470 --> 11:32.910
你告诉我一个新的状态

11:33.630 --> 11:35.230
还有一个就是新的数据

11:35.230 --> 11:37.070
OK 那我就帮你改变状态

11:37.070 --> 11:38.190
好 那么这里呢就是

11:39.150 --> 11:41.150
更改状态

11:41.150 --> 11:42.670
更改任务状态

11:44.030 --> 11:46.030
好 那么第一个参数状态呢

11:46.030 --> 11:46.990
肯定是一个字母串 对吧

11:46.990 --> 11:48.510
状态是一个字母串

11:48.990 --> 11:51.310
这是新状态

11:51.710 --> 11:54.030
那么这里呢就是相关数据

11:54.990 --> 11:55.950
成功了

11:57.070 --> 11:58.830
这是N1 任何数据都可以

11:59.310 --> 12:00.510
相关数据

12:01.470 --> 12:02.750
你成功之后啊

12:02.750 --> 12:03.790
你这个数据呢

12:03.790 --> 12:05.870
就是成功的数据

12:05.870 --> 12:06.750
你失败的话

12:06.750 --> 12:07.550
就是失败的原因

12:07.870 --> 12:08.910
通过它来传递

12:08.910 --> 12:10.190
那么我们这里呢要做的事情

12:10.190 --> 12:10.830
其实很简单了

12:10.830 --> 12:11.790
是不是就调这个this

12:12.590 --> 12:13.390
ChangeState

12:13.390 --> 12:13.950
State

12:13.950 --> 12:14.830
把新的状态是什么呢

12:14.830 --> 12:16.030
新的状态就是这个

12:16.030 --> 12:16.910
因为你成功了嘛

12:16.910 --> 12:18.030
所以新的状态是什么

12:18.030 --> 12:18.510
FullFill

12:19.470 --> 12:20.190
我们用长量

12:21.790 --> 12:22.670
然后呢

12:22.670 --> 12:24.110
那个值呢

12:24.670 --> 12:25.470
值是什么呢

12:25.470 --> 12:26.670
值的就是Data

12:27.550 --> 12:28.590
所以一句话就写完了

12:28.590 --> 12:29.710
那么同样的到这边啊

12:29.710 --> 12:30.750
也是一句话就写完了

12:31.470 --> 12:33.310
那么这里的就变成Reason

12:33.310 --> 12:34.190
失败了

12:34.190 --> 12:34.910
而Rejective

12:37.250 --> 12:38.370
是吧 就写完了

12:39.650 --> 12:41.250
好那么这个改变状态的话

12:41.250 --> 12:41.970
做什么事情呢

12:41.970 --> 12:43.410
就把刚才的办法写一遍遍

12:44.450 --> 12:46.930
当前的状态是变了变成NewState

12:46.930 --> 12:48.850
然后呢把当前的什么Value也变了

12:48.850 --> 12:51.090
变成什么变成那个Value

12:51.090 --> 12:51.810
是不是完事了

12:52.450 --> 12:53.490
好咱们再试一下啊

12:53.490 --> 12:54.370
你会看到效果呢

12:54.370 --> 12:55.170
仍然是一样的

12:56.290 --> 12:57.730
你看变成拒绝了

12:57.730 --> 12:58.770
然后我们调用Result

13:02.420 --> 13:04.020
好变成完成了

13:04.820 --> 13:05.140
对吧

13:05.860 --> 13:06.100
OK

13:07.380 --> 13:08.820
好这一块就完成了

13:08.820 --> 13:09.780
好完成之后呢

13:09.780 --> 13:11.060
我们再来研究啊

13:11.140 --> 13:12.420
这里有没有问题呢

13:12.420 --> 13:13.620
肯定是有问题的

13:13.620 --> 13:14.260
因为我们说过

13:14.260 --> 13:15.540
Promise的状态更改啊

13:15.540 --> 13:16.180
是不能

13:16.180 --> 13:18.260
就是一旦确定下来是不能改的

13:18.260 --> 13:19.380
这个状态是不能改的

13:20.500 --> 13:21.300
比方说我们现在

13:21.300 --> 13:22.100
如果说这样子的话

13:22.100 --> 13:22.660
你会发现

13:22.660 --> 13:24.020
那状态改了两次

13:24.020 --> 13:25.140
第一次变成Result

13:25.140 --> 13:26.420
后来又变成Rejective

13:27.060 --> 13:27.380
对吧

13:27.380 --> 13:28.500
拒绝也变了

13:28.500 --> 13:30.100
那么状态是不能更改的

13:30.100 --> 13:31.460
所以说我们在改变状态的时候

13:31.460 --> 13:32.340
是不是要做过一个判断

13:32.900 --> 13:33.620
做什么判断呢

13:33.620 --> 13:34.980
判断一下啊

13:34.980 --> 13:36.980
如果说你当前的状态

13:36.980 --> 13:40.020
已经不等于平顶了

13:41.940 --> 13:42.660
说明什么

13:42.660 --> 13:45.860
说明目前状态已经更改

13:46.420 --> 13:47.540
状态已经被改了

13:47.540 --> 13:48.820
那么以后别

13:48.820 --> 13:50.260
以这一次调用这个签计State

13:50.260 --> 13:50.660
说明说

13:51.300 --> 13:53.220
一定不是第一次雕用了

13:53.220 --> 13:54.820
之前已经把状态改过了

13:54.820 --> 13:56.340
那么这个时候我就什么都不干

13:56.900 --> 13:57.620
啥也不干

13:57.620 --> 13:58.580
就写这么一个判断

13:58.580 --> 13:59.620
所以就完成了

13:59.620 --> 14:00.420
那这个判断出来了

14:00.420 --> 14:01.300
过后我们再来看啊

14:02.340 --> 14:02.580
哎

14:02.580 --> 14:03.860
是不是只有第一个成功了

14:03.860 --> 14:04.420
改变状态

14:04.420 --> 14:05.700
那后续的是不是都失败了

14:05.700 --> 14:06.500
那后续如果说

14:06.500 --> 14:08.740
我这里改改成其他的

14:08.740 --> 14:10.340
哪怕是同一个状态的不同数据

14:10.420 --> 14:11.060
也会失败

14:11.620 --> 14:11.940
对吧

14:11.940 --> 14:12.580
为什么呢

14:12.580 --> 14:13.940
是不是跟那个promise是一样的

14:14.580 --> 14:14.900
为什么呢

14:14.900 --> 14:16.340
你就因为经过这么一个判断

14:16.340 --> 14:16.980
是不是一个判断

14:16.980 --> 14:17.940
就会搞定这件事

14:19.060 --> 14:19.380
好

14:19.380 --> 14:20.100
这里是关了

14:21.220 --> 14:21.460
好

14:21.460 --> 14:22.420
咱们继续啊

14:22.420 --> 14:23.380
还有什么问题呢

14:23.380 --> 14:24.260
就是如果说啊

14:24.260 --> 14:25.620
我们在promise的执行过程中

14:25.620 --> 14:26.740
如说爆出了

14:26.740 --> 14:27.140
一二三

14:29.060 --> 14:30.100
到我这里有没有处理的

14:30.100 --> 14:31.140
肯定是没有处理

14:31.140 --> 14:31.860
但是我们知道

14:31.860 --> 14:33.460
promise的执行期间

14:33.460 --> 14:34.500
在这些执行期间

14:34.500 --> 14:35.220
一旦爆出

14:35.220 --> 14:36.580
是不是状态就自动变成了什么

14:37.140 --> 14:37.460
失败

14:38.020 --> 14:39.300
那怎么在处理这个事呢

14:39.300 --> 14:40.180
其实非常简单

14:40.660 --> 14:42.900
我就直接把这个函数在执行过程中

14:42.900 --> 14:43.860
看看有没有错误

14:43.860 --> 14:44.500
只要有错误

14:44.500 --> 14:46.980
我就直接帮你雕拢这个锐介的车

14:46.980 --> 14:47.780
那怎么来处理呢

14:47.780 --> 14:48.660
是不是在这里

14:48.660 --> 14:50.580
在执行这个函数的过程中

14:52.180 --> 14:53.140
你再执行这个函数

14:53.140 --> 14:54.340
我用一个串把它包起来

14:55.140 --> 14:56.180
只要你执行过程中

14:56.180 --> 14:57.540
不管你是发现了什么错误

14:57.540 --> 14:58.580
只要你爆了错误

14:58.580 --> 14:59.620
那我这里干嘛呀

14:59.620 --> 15:01.460
我这里就直接雕拢这个锐介的车

15:02.020 --> 15:02.900
帮你雕拢

15:03.300 --> 15:04.020
雕拢了什么呢

15:04.020 --> 15:04.900
错误的原因是什么

15:04.900 --> 15:05.940
不就是错误对象吗

15:07.060 --> 15:07.620
好好保存

15:07.620 --> 15:08.340
你现在看一下

15:09.300 --> 15:09.780
印象

15:10.740 --> 15:12.100
你看是不是被拒绝了

15:12.100 --> 15:12.740
然后呢

15:12.740 --> 15:13.620
数据是什么

15:13.620 --> 15:14.900
数据是123

15:14.900 --> 15:15.940
因为我拋出来是123

15:15.940 --> 15:17.460
当然你拋出来是别的的话

15:17.460 --> 15:18.580
它就是别的

15:20.180 --> 15:20.580
印象

15:22.260 --> 15:24.260
状态被拒绝

15:24.260 --> 15:26.660
然后据的原因呢

15:26.660 --> 15:27.380
就这个原因

15:27.380 --> 15:28.740
一个AIR对象

15:29.540 --> 15:31.060
就通过这么一个单码就可以处理

15:31.860 --> 15:32.180
OK

15:32.180 --> 15:33.220
那么咱们这一刻呢

15:33.220 --> 15:34.260
就写到这吧

15:34.260 --> 15:35.300
我们这一刻实现了什么呢

15:35.300 --> 15:35.940
实现了

15:36.660 --> 15:38.100
Promise给它记录状态

15:38.100 --> 15:39.140
和记录相关数据

15:39.860 --> 15:40.180
然后呢

15:40.180 --> 15:41.700
也实现了对那个

15:42.340 --> 15:42.980
构造器

15:42.980 --> 15:44.740
对这个执行器的调用

15:44.740 --> 15:45.540
而且调用过程中

15:45.540 --> 15:46.980
我们可以监控它有错误

15:46.980 --> 15:47.540
有错误的话

15:47.540 --> 15:48.900
我直接把它变成拒绝态

15:49.380 --> 15:50.500
然后我们会发现呢

15:50.500 --> 15:51.620
无论是为作为也好

15:51.620 --> 15:52.500
还是为借车也好

15:52.500 --> 15:53.540
他们的本质工作

15:53.540 --> 15:54.660
其实没有做啥事

15:54.660 --> 15:56.180
只是改变状态而已

15:56.180 --> 15:57.460
只是把状态给它更改

15:58.100 --> 15:59.220
好更改状态的时候呢

15:59.220 --> 16:00.260
我们做了个判断

16:00.260 --> 16:01.220
判断一下这个状态

16:01.220 --> 16:02.500
是不是已经被更改过了

16:02.500 --> 16:02.980
更改过了

16:02.980 --> 16:04.900
我就不再去重复更改

16:04.900 --> 16:05.540
没有更改过

16:05.540 --> 16:07.060
我就把状态更改了就行了

16:07.700 --> 16:08.660
OK那么这一块

16:08.660 --> 16:09.620
我们是不是都完成了

16:09.620 --> 16:11.060
好同学们可以先跟着我做

16:11.060 --> 16:12.020
把它写到这么一块

16:12.020 --> 16:12.900
体会一下一个代码

16:12.900 --> 16:13.780
到底是什么含义

