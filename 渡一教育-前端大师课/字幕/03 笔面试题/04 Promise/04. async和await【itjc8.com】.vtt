WEBVTT

00:00.820 --> 00:04.660
支持咱们Promise这一块东西又学完了

00:04.660 --> 00:09.540
Promise这个东西它其实大家也体验到了

00:09.540 --> 00:13.460
它并没有消除毁掉 它毁掉是没有消除的

00:13.460 --> 00:16.740
你看我们Promise里面咱们怎么写的

00:16.740 --> 00:21.300
Promise 溜了一个Promise 然后这里面写了它东西

00:21.300 --> 00:23.620
这里面是不是有毁掉 是不是有毁掉函数

00:23.620 --> 00:26.580
然后后面我们Zin方法里面是不是有一个毁掉函数

00:26.580 --> 00:29.860
它其实没有消除毁掉 但它消除了什么呢

00:29.940 --> 00:34.980
它有两个作用 第一个作用是消除了毁掉地域

00:34.980 --> 00:37.540
它不用毁掉 毁掉函毁掉了 对吧

00:37.540 --> 00:43.060
它可以使用练识编程让整个毁掉函数的有序的进行

00:43.060 --> 00:44.420
这是它第一个好处

00:44.420 --> 00:48.260
第二个好处就是我们以后的所有的异部场景

00:48.260 --> 00:51.060
其实都可以使用Promise来完成

00:51.060 --> 00:54.740
那么就统一了 不管你是公事也好

00:54.740 --> 00:57.380
还是个人也好 张三也好 李四也好

00:57.460 --> 01:00.660
咱们处理毁掉 要处理这个异部场景

01:00.660 --> 01:02.500
都把它变成一个异部任务

01:02.500 --> 01:05.940
这样子我们就把异部的处理统一得起来

01:05.940 --> 01:07.940
统一有什么好处呢

01:07.940 --> 01:11.460
这节课看一下 统一之后的好处在于

01:11.460 --> 01:13.540
官方这个时候就可以出面了

01:13.540 --> 01:17.300
既然大家都用了这种方式来处理异部

01:17.300 --> 01:20.900
好 我就给你出一个新的语法

01:20.900 --> 01:25.220
注意啊 只有官方才能出新语法

01:25.300 --> 01:28.100
你写个函数 写个对象谁不会呢

01:28.100 --> 01:29.540
我们也可以写 对吧

01:29.540 --> 01:31.060
你不是官方你可以写

01:31.060 --> 01:33.940
像Promise最早的时候是不是个A加规范

01:33.940 --> 01:36.260
最早的时候产生了一个社区规范

01:36.260 --> 01:37.780
它就不是官方搞的

01:37.780 --> 01:39.780
它无非就是让你去做一个对象吗

01:39.780 --> 01:44.420
然后做一个对象里边有哪些方法给你规定好

01:44.420 --> 01:48.500
像一些对象 函数这些东西不一定官方来搞

01:48.500 --> 01:50.580
民间也可以搞出来

01:50.660 --> 01:55.300
但是只有语法必须要官方规定

01:55.300 --> 01:58.660
比方说什么关键制 负寻还 外货寻还

01:58.660 --> 02:00.180
这些就必须要官方规定

02:00.180 --> 02:02.740
你民间是搞不出来这个东西的

02:02.740 --> 02:04.660
那么这个东西呢

02:04.660 --> 02:09.220
由于我们的异部处理统一的起来

02:09.220 --> 02:11.060
统一之后的好处在于

02:11.060 --> 02:12.740
你既然大家都使用Promise了

02:12.740 --> 02:15.220
好 我给你出一个新的语法

02:15.220 --> 02:17.140
让你写Promise也好

02:17.140 --> 02:20.340
让你去处理Promise也好

02:20.340 --> 02:21.780
变得更加简单

02:21.780 --> 02:24.180
那么这个语法就是我们这一课学的

02:24.180 --> 02:26.740
这个语法可以真正的消除毁掉

02:26.740 --> 02:29.060
它不是说消除所有场景的毁掉

02:29.060 --> 02:31.540
指的是消除异部场景里面的毁掉

02:31.540 --> 02:35.060
它是真的可以消除了

02:35.060 --> 02:36.180
我们来看一下

02:36.180 --> 02:38.020
由Promise之后

02:38.020 --> 02:41.380
异部的任务有那种统一的处理方式

02:41.380 --> 02:44.420
那么ES官方就对它进一步进行的优化

02:44.420 --> 02:47.700
ES7 就是ES2016

02:47.780 --> 02:49.220
2019年出的

02:49.220 --> 02:50.500
它就出了两个关键字

02:50.500 --> 02:51.860
一个是Elsink

02:51.860 --> 02:55.220
它的全称叫做Elsincorice

02:55.220 --> 02:58.740
表示的是异部的Erwight

02:58.740 --> 02:59.860
表示等待

02:59.860 --> 03:01.300
就出了这么两个关键字

03:01.300 --> 03:02.100
这两个关键字

03:02.100 --> 03:05.460
让我们可以更加优雅的来表达Promise

03:05.460 --> 03:06.580
给大家看一下吧

03:06.580 --> 03:07.540
我们再分开学一下

03:07.540 --> 03:08.660
非常简单

03:08.660 --> 03:10.500
你把Promise理解清楚了过后

03:10.500 --> 03:16.180
Elsink和Erwight就并不复杂了

03:16.260 --> 03:20.100
第一个是Elsink表示的是Elsincorice

03:20.100 --> 03:21.220
它是用来干嘛的呢

03:21.220 --> 03:24.260
它是用来修饰函数的

03:24.260 --> 03:26.420
就是它写的地方也不能乱写

03:26.420 --> 03:27.940
也不能随便找个地方写

03:27.940 --> 03:30.260
它必须要标注在函数前边

03:30.260 --> 03:31.780
标注像这种场景

03:31.780 --> 03:33.460
你看前边是用了一个Elsink

03:33.460 --> 03:33.940
对吧

03:33.940 --> 03:36.180
当然我们也有的时候是一个匿名函数

03:36.180 --> 03:38.260
比方说我们是一个箭头函数

03:38.260 --> 03:39.940
那箭头函数可不可以用Elsink呢

03:39.940 --> 03:41.700
可以标注在前面就可以了

03:41.700 --> 03:44.340
那么这就是一个异部的箭头函数

03:44.500 --> 03:47.460
比方说有的时候我们写一个就是函数表达式

03:47.460 --> 03:50.260
其实本质上跟箭头函数也是差不多的

03:50.260 --> 03:52.100
那么也可以标注在前面

03:52.100 --> 03:54.100
那有的时候我们写个立即执行函数呢

03:54.100 --> 03:58.100
比方说像这种立即执行函数

03:58.100 --> 03:59.060
对吧

03:59.060 --> 04:01.860
那么前边也可以标注一个Elsink

04:01.860 --> 04:03.380
有的时候我们立即执行函数呢

04:03.380 --> 04:05.060
它不一定是普通函数形式

04:05.060 --> 04:06.740
它又可能是箭头函数

04:06.740 --> 04:08.820
箭头函数它本质上跟这个也有什么区别呢

04:08.820 --> 04:10.180
它除了Ris的指向

04:10.180 --> 04:11.380
有一些细节上的区别

04:11.380 --> 04:13.140
本质上它还是个函数表达式

04:13.540 --> 04:14.580
这也是一个函数

04:14.580 --> 04:16.420
那么前边也可以标记为Elsink

04:17.300 --> 04:18.180
那总之呢

04:18.180 --> 04:19.620
它用来修饰函数

04:19.620 --> 04:20.820
各种函数前边

04:20.820 --> 04:23.220
它都可以去标注这个Elsink

04:24.020 --> 04:25.940
那么这个Elsink标注到函数前边

04:25.940 --> 04:27.140
有什么作用呢

04:27.140 --> 04:31.300
它就表明了这个函数百分之一千一万

04:31.300 --> 04:33.220
它一定用返回Promise

04:33.220 --> 04:34.260
我来看一下吧

04:35.140 --> 04:35.860
我们这里呢

04:35.860 --> 04:38.420
前面去写一个解释

04:38.420 --> 04:39.140
那么这个解释呢

04:39.140 --> 04:39.940
我们就写个方法

04:41.540 --> 04:42.580
这方法我啥都没有

04:43.460 --> 04:44.740
那如果说我啥都不写的话

04:44.740 --> 04:46.660
我们雕用这个方法返回的是啥

04:46.660 --> 04:47.540
它返回的

04:47.540 --> 04:48.820
那就是undefined对吧

04:48.820 --> 04:49.940
因为它没有用Return

04:50.500 --> 04:51.220
这个没问题吧

04:51.860 --> 04:54.500
但是我只要在这个函数前面标记了Elsink

04:55.060 --> 04:57.300
这个函数它一定返回Promise

04:58.500 --> 05:00.180
哪怕这个函数里面一行代吧都没有

05:00.180 --> 05:01.380
它一定返回Promise

05:01.380 --> 05:02.340
你看是不是Promise

05:02.900 --> 05:03.220
对吧

05:03.220 --> 05:04.340
就这么简单

05:04.340 --> 05:05.460
它表明这个函数

05:05.460 --> 05:06.980
它一定返回Promise

05:06.980 --> 05:08.500
那么这个函数里边

05:09.140 --> 05:09.540
你用的

05:09.540 --> 05:10.740
如果说你用了Return

05:11.700 --> 05:13.460
后面也跟了一个表达社会的值

05:13.940 --> 05:16.260
这个函数里边我们现在没有用Return

05:16.260 --> 05:16.740
对吧

05:16.740 --> 05:18.180
没有Return就相当于是

05:18.180 --> 05:19.700
你就Return了一个undefined

05:19.700 --> 05:20.340
对不对

05:20.340 --> 05:21.620
那么这个Return呢

05:21.620 --> 05:23.780
就是返回的东西变成了什么了

05:23.780 --> 05:25.620
如果说你没有标记这个Elsink

05:25.620 --> 05:26.740
那你返回的是啥

05:26.740 --> 05:27.620
那就是啥

05:27.620 --> 05:29.620
但是你标记了这个Elsink

05:29.620 --> 05:31.460
这个函数它的返回值

05:31.460 --> 05:36.020
表示的是Promise完成之后的数据

05:37.220 --> 05:38.100
这当图啊

05:38.100 --> 05:39.620
一定要老在里边一定要记下来

05:40.580 --> 05:42.260
完成状态是不是有个相关数据

05:42.260 --> 05:44.020
失败状态是不是有个相关原因

05:44.020 --> 05:44.580
对吧

05:44.580 --> 05:46.100
那么这个就相当于是

05:46.100 --> 05:47.860
完成之后的相关数据

05:48.580 --> 05:50.100
那么现在我们来看一下这个Promise

05:50.100 --> 05:50.340
是不是

05:50.980 --> 05:52.180
返回的是一个Promise

05:52.180 --> 05:52.900
它的数据呢

05:52.900 --> 05:53.860
就undefined

05:53.860 --> 05:54.660
当你不写的话

05:54.660 --> 05:55.540
跟写不写都是一样

05:56.340 --> 05:57.780
那如果说你返回一个Elsink

05:57.780 --> 05:58.580
那么完成

05:58.580 --> 06:00.020
它的Promise呢

06:00.020 --> 06:01.140
状态就是Elsink

06:01.140 --> 06:02.100
简不简单

06:02.100 --> 06:02.900
是不是特别简单

06:02.900 --> 06:03.300
对吧

06:03.300 --> 06:04.100
那么这样子呢

06:04.660 --> 06:07.140
这个函数的代码呢

06:07.140 --> 06:08.900
就相当于是这样子写的

06:08.980 --> 06:10.180
一模一样的啊

06:10.180 --> 06:13.060
就相当于是你return了一个new promise

06:13.060 --> 06:13.940
然后呢

06:13.940 --> 06:14.420
这里呢

06:14.420 --> 06:15.540
用了一个resolve

06:15.540 --> 06:16.580
这个resolve呢

06:16.580 --> 06:17.700
里边写了一个123

06:18.980 --> 06:21.700
下面的代码是不是要麻烦一些写起来

06:21.700 --> 06:21.940
对吧

06:21.940 --> 06:23.380
上面的代码是不是写起来

06:23.380 --> 06:24.100
要舒服一些

06:24.100 --> 06:24.900
要简单一些

06:25.460 --> 06:25.700
对吧

06:25.700 --> 06:26.900
就从这么回事啊

06:26.900 --> 06:27.380
所以呢

06:28.820 --> 06:30.100
不用太过于纠结啊

06:30.100 --> 06:31.540
这个玩意其实挺简单的

06:32.020 --> 06:32.980
有些同学觉得这个

06:32.980 --> 06:34.020
有些之前啊

06:34.020 --> 06:35.460
可能接触过这些关键字

06:35.460 --> 06:36.420
觉得它挺难吃

06:36.420 --> 06:38.260
因为你Promise没有了解清楚

06:38.420 --> 06:39.460
你Promise了解清楚了

06:39.460 --> 06:40.420
这个特别简单

06:40.980 --> 06:41.940
明白了意思吧

06:41.940 --> 06:43.460
它其实就是一个愚法堂

06:47.220 --> 06:47.940
愚法堂

06:47.940 --> 06:48.900
怎么叫愚法堂呢

06:48.900 --> 06:51.300
就是它并没有带来

06:51.940 --> 06:53.140
功能性的变化

06:53.140 --> 06:54.900
实质性的变化并没有

06:54.900 --> 06:56.820
它其实利用以前的技术

06:56.820 --> 06:58.580
让你写起来更加舒服一点

06:59.220 --> 07:00.260
就像吃糖一样

07:00.260 --> 07:00.820
对吧

07:00.820 --> 07:02.260
吃糖没有什么营养

07:02.260 --> 07:03.700
但是能让你舒服

07:03.700 --> 07:04.980
就是这么一个东西

07:04.980 --> 07:05.700
叫愚法堂

07:06.420 --> 07:07.940
那这就是这个Essink

07:08.020 --> 07:09.300
Essink这个关键字的作用

07:09.860 --> 07:10.500
那里看

07:10.500 --> 07:11.540
我这里写了一个方法

07:11.540 --> 07:12.500
调用这个方法之后

07:12.500 --> 07:13.460
这个方法返回的是什么

07:13.460 --> 07:14.820
返回的是个Promise

07:14.820 --> 07:16.660
那你要怎么再用这个方法呢

07:16.660 --> 07:17.700
看你怎么用

07:17.700 --> 07:20.180
相当于是你怎么去用Promise的

07:20.500 --> 07:21.860
你调用这个方法是不是可以用Zin

07:23.460 --> 07:24.260
是不是可以用Zin

07:25.140 --> 07:25.860
用Data

07:27.780 --> 07:28.580
输出Data

07:28.580 --> 07:30.420
是不是输出的就是E23

07:32.830 --> 07:33.950
你看输出E23

07:33.950 --> 07:35.070
它返回的就是Promise

07:35.070 --> 07:35.870
Promise该怎么用

07:35.870 --> 07:36.830
它就不怎么用

07:36.830 --> 07:37.790
对吧 就这么简单

07:39.390 --> 07:40.030
让你看

07:40.030 --> 07:42.510
那如果说这个方法里边

07:42.510 --> 07:44.270
它又返回了一个Promise呢

07:44.990 --> 07:45.790
如果说

07:45.790 --> 07:46.830
这里面返回的是

07:47.710 --> 07:48.990
比方我扭了一个Promise

07:51.920 --> 07:52.720
Visual

07:52.720 --> 07:54.160
我这里Set Timeout

07:56.080 --> 07:57.040
一秒钟之后

07:57.040 --> 07:57.760
Visual

07:58.720 --> 07:59.200
E23

07:59.760 --> 08:00.640
那你看

08:00.640 --> 08:02.720
这个方法它返回的是一个Promise

08:02.720 --> 08:03.040
对吧

08:03.760 --> 08:05.200
它又标击为Essink

08:06.000 --> 08:07.760
按照逻辑来讲的话

08:08.400 --> 08:09.680
它应该是怎么回事呢

08:09.680 --> 08:10.960
应该是这个方法

08:10.960 --> 08:12.560
它返回了一个Promise

08:13.520 --> 08:14.400
然后呢

08:14.400 --> 08:16.000
这个Promise的数据呢

08:16.000 --> 08:17.040
又是一个Promise

08:17.040 --> 08:17.280
对吧

08:17.280 --> 08:18.800
因为它Return了Promise

08:18.800 --> 08:19.760
Return是啥

08:19.760 --> 08:21.520
那么这个Promise的数据就是啥

08:21.520 --> 08:22.400
那它的数据呢

08:22.400 --> 08:24.080
就应该也是一个Promise

08:24.080 --> 08:25.600
按你说是应该是这个逻辑

08:25.600 --> 08:26.800
实际上不是的

08:26.800 --> 08:27.440
像这种情况

08:27.440 --> 08:29.360
还会给你进行一个特殊处理

08:29.360 --> 08:31.760
如果说你这个函数返回的是一个Promise

08:31.760 --> 08:32.800
那么就相当于是

08:32.800 --> 08:33.840
你没有标击这个

08:34.560 --> 08:35.040
你看了

08:35.520 --> 08:37.120
你标击跟没有标击是一样的

08:37.600 --> 08:39.280
因为标击这个返回的就是Promise

08:39.280 --> 08:39.760
对吧

08:39.840 --> 08:41.120
你没有标击的话

08:41.120 --> 08:42.320
返回来还是Promise

08:42.880 --> 08:44.960
所以说这个相当于是你没有标击

08:44.960 --> 08:46.480
然后你标击上也没事

08:47.120 --> 08:47.840
标击过后了

08:47.840 --> 08:49.120
它其实就是这个Promise

08:49.120 --> 08:49.680
拿到的

08:50.400 --> 08:50.800
因此呢

08:50.800 --> 08:52.240
我们这里调了这个函数呢

08:52.240 --> 08:52.960
Z

08:52.960 --> 08:53.360
Z

08:53.360 --> 08:55.120
那么它一秒钟之后

08:55.120 --> 08:55.840
它就会输出

08:57.040 --> 08:57.440
1 2 3

08:58.000 --> 08:58.240
对吧

08:58.240 --> 08:59.360
一秒钟之后完成吧

08:59.360 --> 08:59.840
完成之后

08:59.840 --> 09:00.800
它就预讯这个函数

09:00.800 --> 09:01.840
输出1 2 3

09:01.840 --> 09:02.720
那道理是一样

09:04.080 --> 09:05.680
它就相当于没有标击

09:05.680 --> 09:06.880
就这么一种情况

09:06.880 --> 09:08.160
那我这里的解释

09:08.160 --> 09:08.960
更加准确一点

09:09.920 --> 09:11.280
如果说你返回的是一个Promise

09:11.280 --> 09:12.640
你看这个返回的是不是Promise

09:13.120 --> 09:16.000
那么这个函数得到了Promise

09:16.000 --> 09:18.160
它的状态和数据跟它保持一致

09:18.720 --> 09:19.840
其实你这样理想

09:19.840 --> 09:21.600
相当于是你没有写这个二思绪

09:22.880 --> 09:24.720
这是关于这一点

09:24.720 --> 09:25.520
有小的细节

09:26.240 --> 09:28.000
另外如果说你这个函数

09:28.000 --> 09:29.120
执行过程中爆错了

09:29.680 --> 09:30.400
那比方说

09:30.400 --> 09:31.200
我这里呢

09:31.200 --> 09:33.680
我这个势力里边是直接抛了一个错误

09:34.160 --> 09:34.880
那有可能呢

09:34.880 --> 09:35.840
我不是抛了错误

09:35.840 --> 09:37.200
是直接本身代码爆错

09:37.360 --> 09:39.520
比方说我这里写了一个数据

09:39.520 --> 09:40.160
然后呢

09:40.160 --> 09:42.000
我去调用这个数据的

09:42.720 --> 09:43.680
tools据办法

09:46.320 --> 09:48.880
拉我是不能没有这个tools据办法的

09:48.880 --> 09:50.560
所以说我运行这个函数的时候呢

09:50.560 --> 09:51.840
我给它注册两个回调

09:51.840 --> 09:53.440
一个是成功之后的回调

09:53.440 --> 09:55.200
一个是失败之后的回调

09:55.200 --> 09:55.680
成功

09:55.680 --> 09:57.040
成功的时候我返回1 2 3

09:57.680 --> 09:58.400
失败的时候

10:00.000 --> 10:01.120
我输出这个错误

10:01.840 --> 10:03.120
那么你看看它看一下

10:03.120 --> 10:04.400
它会运行哪个回调呢

10:04.400 --> 10:06.080
它几次会运行失败的回调

10:06.720 --> 10:09.520
它这个函数执行过程中如果说爆了错

10:09.520 --> 10:10.560
那么相当于是

10:10.560 --> 10:12.480
因为这个函数返回的一定是promise

10:12.480 --> 10:12.960
对吧

10:13.520 --> 10:15.440
那么就相当于是这个promise

10:15.440 --> 10:16.080
怎么样

10:16.080 --> 10:16.640
失败了

10:17.600 --> 10:18.320
好 我们来看一下

10:19.360 --> 10:20.400
是不是预讯到这个

10:20.960 --> 10:22.800
那么如果我们再看得更加清楚一点

10:22.800 --> 10:23.920
就是我们把输出一下

10:23.920 --> 10:25.440
m函数的返回结果

10:25.440 --> 10:26.640
你看返回的是啥

10:26.640 --> 10:28.240
返回的是一个promise

10:28.240 --> 10:29.840
这个promise是rejected

10:29.840 --> 10:30.640
表示失败了

10:31.200 --> 10:32.560
那么后边是一个失败的

10:33.920 --> 10:34.720
失败的原因

10:34.720 --> 10:35.840
就是抛出那个错误

10:36.880 --> 10:37.520
对吧

10:37.520 --> 10:39.280
那么这就是这种场景

10:39.280 --> 10:40.880
它总之这个函数返回的是promise

10:40.880 --> 10:41.440
要么成功

10:41.440 --> 10:42.880
成功就是正常执行完

10:42.880 --> 10:44.240
然后return的结果就是

10:44.240 --> 10:45.360
成功之后的数据

10:46.000 --> 10:47.440
那么它一种就是失败

10:47.440 --> 10:48.480
失败的话那就是

10:49.600 --> 10:51.200
它中间如果说爆了错

10:51.200 --> 10:51.760
它就失败了

10:52.560 --> 10:53.920
这是个er-sync关键字

10:57.230 --> 10:58.590
然后下面这个er-wait

10:59.230 --> 11:00.590
er-wait什么意思呢

11:00.590 --> 11:03.950
它表示等待某一个promise完成

11:04.830 --> 11:05.470
注意啊

11:05.470 --> 11:06.910
这个er-wait关键字

11:07.070 --> 11:09.150
它必须要写到函数里面

11:09.150 --> 11:10.590
你说你不能这样子写

11:10.590 --> 11:11.470
然后这个

11:11.470 --> 11:12.430
这是一个promise

11:12.430 --> 11:12.670
对吧

11:12.670 --> 11:14.030
返回了一个promise

11:14.030 --> 11:15.870
我这里就这样子写吧

11:17.070 --> 11:18.430
那么我们调用这个函数

11:20.190 --> 11:22.750
我们在前边你是不能这样子写的

11:23.950 --> 11:24.430
为什么

11:24.430 --> 11:25.710
因为er-wait这个关键字

11:25.710 --> 11:26.830
它这样写要爆错的

11:26.830 --> 11:27.230
你看

11:28.750 --> 11:29.390
告诉你

11:29.390 --> 11:30.270
语法错误

11:30.270 --> 11:31.870
你看这个错误是不是语法错误

11:31.870 --> 11:32.510
对吧

11:32.510 --> 11:33.230
syntax

11:34.030 --> 11:34.990
它说er-wait

11:35.310 --> 11:37.630
is only valid in er-sync function

11:37.630 --> 11:38.510
它表示的意思呢

11:38.510 --> 11:40.910
表示er-wait必须要在一个函数里边

11:40.910 --> 11:43.310
而且这个函数还必须要是er-sync的

11:43.310 --> 11:44.670
表计为er-sync的函数

11:46.110 --> 11:47.470
也就是说这个代码呢

11:47.470 --> 11:48.830
如果说你要运行那个代码

11:48.830 --> 11:50.910
你就必须要写到一个函数里边

11:54.910 --> 11:56.430
必须要写到一个函数里边

11:56.430 --> 11:57.150
将来呢

11:57.150 --> 11:59.150
我可能过了一两年之后啊

11:59.150 --> 12:00.270
现在正在讨论

12:00.270 --> 12:02.430
要不要把这个er-wait升到紧急代码

12:02.430 --> 12:04.350
就不在函数里边也可以用

12:04.350 --> 12:05.630
当然大家都希望这样做

12:05.630 --> 12:06.350
但是目前呢

12:06.350 --> 12:09.150
因为一些细节上的原因啊

12:09.150 --> 12:10.350
这样做还有一点冒险啊

12:10.350 --> 12:12.350
所以说目前还正在讨论阶段

12:12.350 --> 12:13.310
可能过了一两年

12:13.310 --> 12:14.670
它就可以得这样子写

12:14.670 --> 12:15.230
现在还不行

12:16.030 --> 12:17.470
必须要放到函数里边

12:17.470 --> 12:18.190
而且呢

12:18.190 --> 12:20.430
这个函数还必须要标记为er-sync

12:21.310 --> 12:22.030
就这么个意思

12:23.150 --> 12:23.790
那么现在呢

12:23.790 --> 12:24.990
我们去调用这个tese函数

12:25.550 --> 12:26.990
那么首先你看这个tese函数

12:26.990 --> 12:27.870
标记了er-sync过了

12:27.870 --> 12:28.990
它是不是也返回Promise

12:29.550 --> 12:29.870
对吧

12:31.230 --> 12:32.510
那么这里这个函数里边

12:32.510 --> 12:33.390
我们可以等待

12:34.350 --> 12:36.110
这个Promise

12:37.230 --> 12:37.950
明白了意思吧

12:37.950 --> 12:39.150
这个er-wait什么意思啊

12:39.150 --> 12:40.110
它表示的是

12:40.510 --> 12:42.830
等待某一个Promise完成

12:42.830 --> 12:43.190
那你看

12:43.190 --> 12:45.230
m这个函数返回的是不是Promise

12:46.030 --> 12:46.430
对吧

12:47.150 --> 12:48.750
Promise完成之后

12:48.750 --> 12:50.110
整个这个表达是

12:50.670 --> 12:51.870
它会得到一个什么呢

12:52.750 --> 12:54.510
它会得到一个数据

12:54.910 --> 12:56.670
当你要接收的话

12:56.670 --> 12:57.310
你就可以接收

12:57.310 --> 12:58.510
不需要的话就不需要

12:59.550 --> 13:00.510
这个数据是什么

13:00.510 --> 13:02.910
就是这个Promise完成后的结果

13:04.350 --> 13:05.470
明白了意思吧

13:05.470 --> 13:06.990
好比方说我这样子写

13:06.990 --> 13:07.630
vizual

13:08.270 --> 13:09.070
我写个

13:09.070 --> 13:09.550
1

13:10.110 --> 13:10.670
1

13:11.310 --> 13:12.510
这是不是一个Promise

13:13.550 --> 13:14.910
那么这个er-wait什么意思

13:14.910 --> 13:16.590
等待这个Promise完成

13:16.590 --> 13:17.790
关键什么时候完成

13:17.790 --> 13:18.910
立即完成就完成

13:19.390 --> 13:20.590
离一年之后完成

13:20.590 --> 13:21.630
那我也得等

13:21.630 --> 13:22.670
反正等待完成

13:23.390 --> 13:24.910
等待完成过后

13:25.870 --> 13:27.950
这个整个表达是返回的是

13:27.950 --> 13:29.390
完成之后的数据

13:29.390 --> 13:30.910
你完成之后的数据是1 1

13:30.910 --> 13:31.790
那么还加一本1 1

13:31.790 --> 13:32.670
复制给data

13:33.470 --> 13:35.390
那么这里边我就输出data

13:35.390 --> 13:35.870
看一下吧

13:37.790 --> 13:38.510
好你看

13:38.510 --> 13:38.990
r11

13:39.950 --> 13:40.270
对不对

13:40.910 --> 13:42.670
好那么我们就调用这个m函数了

13:43.230 --> 13:44.270
那大家想一下

13:44.270 --> 13:45.710
这个我们会输出什么样的结果

13:47.710 --> 13:48.510
那你看吧

13:48.510 --> 13:50.430
m这个函数是不是返回的是什么

13:50.430 --> 13:50.990
Promise

13:52.110 --> 13:52.670
对不对

13:52.670 --> 13:53.950
那么这个Promise完成之后

13:53.950 --> 13:54.990
返回的是什么呢

13:54.990 --> 13:55.550
123

13:57.310 --> 13:57.710
对不对

13:58.270 --> 13:59.630
那么这里是不是得到123

14:01.310 --> 14:02.350
其实这个代码呢

14:02.350 --> 14:03.950
就相当于是怎么写的呢

14:04.830 --> 14:06.270
就相当于是这样子写的

14:08.350 --> 14:09.550
mz

14:10.590 --> 14:12.750
等它完成之后输出它的纸

14:12.750 --> 14:14.030
是不是就这个代码

14:14.590 --> 14:14.990
对不对

14:14.990 --> 14:15.710
是不是就这个代码

14:15.710 --> 14:16.750
其实是一样的

14:17.550 --> 14:19.230
它只是用了Arwaiter 语法

14:19.230 --> 14:20.750
是不是把回调给我消除掉了

14:20.750 --> 14:22.830
你不用去用回调的模式了

14:22.830 --> 14:24.990
这样代码是不是看上去更加舒服一点

14:24.990 --> 14:26.590
等待这个Promise完成

14:26.590 --> 14:28.430
完成之后的数据放到边疆里边

14:29.550 --> 14:29.870
对吧

14:29.870 --> 14:31.230
那么这样看上去舒服

14:31.230 --> 14:31.870
舒服很多

14:33.150 --> 14:34.990
那么这样给大家解释一下

14:34.990 --> 14:37.070
为什么他要说这个Arwaiter

14:37.070 --> 14:38.750
必须要放到Ersynk里边

14:38.750 --> 14:39.630
函数里边

14:39.630 --> 14:40.750
为什么会这样子呢

14:41.390 --> 14:42.910
大家想一想这个道理

14:42.910 --> 14:44.910
其实这个跟现实上逻辑是挂钩的

14:45.790 --> 14:46.910
你有两个任务

14:48.350 --> 14:51.390
你要等待第一个任务完成之后

14:51.390 --> 14:53.470
我才能继续进行这个任务

14:54.030 --> 14:55.710
那么第一个任务是异步的

14:56.830 --> 14:58.190
第一个任务是一个Promise

14:58.190 --> 14:59.230
是一个异步任务

14:59.230 --> 15:00.190
那么我请问你

15:00.190 --> 15:01.390
它是不是一个异步任务

15:02.670 --> 15:03.790
是不是也是一个异步任务

15:03.790 --> 15:04.590
就跟我们之前说的

15:04.590 --> 15:06.030
学到的练习编程是一样的

15:06.750 --> 15:07.790
后续任务

15:07.790 --> 15:09.390
它也是一个异步任务

15:09.390 --> 15:11.230
我还要等待前一个任务完成之后

15:11.230 --> 15:12.670
我才能继续进行下去

15:12.670 --> 15:13.630
那我本身

15:13.630 --> 15:15.150
本身也需要等待一段时间

15:15.630 --> 15:15.950
对吧

15:16.590 --> 15:18.510
然后表现我给大家觉得实际的理智

15:18.510 --> 15:19.710
这里让我用一个Delay

15:25.700 --> 15:26.340
Ersynk

15:26.340 --> 15:28.260
你给我传一个等待时间

15:28.260 --> 15:30.580
那么这边我就反回了什么呢

15:30.580 --> 15:32.100
反回一个Promise

15:32.100 --> 15:33.140
我用传统的方式

15:36.180 --> 15:37.300
这个函数要汇写

15:37.860 --> 15:38.740
Delay这个函数

15:39.220 --> 15:40.020
SetTimeout

15:41.540 --> 15:42.260
Delay寄

15:42.260 --> 15:43.220
是不是之前写过的

15:43.780 --> 15:44.260
Uzo

15:45.940 --> 15:47.700
这个函数我就没有用Ersynk标记

15:47.700 --> 15:48.660
因为这个地方

15:48.660 --> 15:50.980
SetTimeout本身是毁掉模式

15:50.980 --> 15:51.540
这个玩意儿

15:51.540 --> 15:52.100
它

15:52.100 --> 15:54.020
那既然有了Promise过后

15:54.020 --> 15:55.220
SetTimeout像这种函数

15:55.220 --> 15:57.140
它为什么不可以做成Promise的这种形式

15:57.140 --> 15:58.660
还要使用毁掉了

15:58.660 --> 15:59.300
它不敢

15:59.300 --> 16:00.500
它不是说它不想

16:00.500 --> 16:01.540
它不敢

16:01.540 --> 16:03.220
因为它这一改的话

16:03.220 --> 16:04.900
以前的代码好多都要出问题

16:05.380 --> 16:07.860
它考虑以前的代码的兼容性

16:07.860 --> 16:08.900
它不敢改

16:08.900 --> 16:10.260
所以说呢这一块呢

16:10.260 --> 16:12.100
我们自己封装一下就完成了

16:12.100 --> 16:13.940
把这些碳冒水封装成Delay函数

16:14.660 --> 16:15.140
延迟

16:15.940 --> 16:17.140
它反回来就是个Promise

16:17.140 --> 16:17.780
对吧

16:17.780 --> 16:18.980
等待一段时间过后

16:18.980 --> 16:19.940
这个Promise完成

16:21.380 --> 16:22.260
以后这个函数之后

16:22.260 --> 16:25.140
你看我们怎么来使用这个Erwynk来调用它

16:25.620 --> 16:26.340
我们可以等待

16:26.340 --> 16:27.540
比方说我们之前

16:27.540 --> 16:28.500
之前要咋写

16:28.500 --> 16:29.940
之前我们可能是这样的写的

16:30.740 --> 16:32.660
Delay比方说

16:32.660 --> 16:33.700
等待一秒钟

16:34.420 --> 16:35.140
然后呢

16:35.140 --> 16:36.580
我们去执行某一个东西

16:40.020 --> 16:41.380
执行某个东西

16:42.980 --> 16:44.260
以前我们是不是得这样子写

16:45.860 --> 16:46.500
是不是有毁掉

16:48.100 --> 16:48.500
印象

16:50.420 --> 16:52.180
你看是不是等了一秒钟执行某个东西

16:52.180 --> 16:52.820
这个很简单吧

16:53.780 --> 16:54.980
可不可以这样做可以

16:54.980 --> 16:56.340
但是有了Erwynk之后

16:56.340 --> 16:58.820
就有了Erwynk和Erwynk关键制之后

16:58.820 --> 16:59.540
我们可以这样子

17:00.660 --> 17:02.100
我再新开一个任务

17:02.100 --> 17:02.980
这个任务呢

17:02.980 --> 17:04.980
就是等待一秒钟之后去执行这个东西

17:04.980 --> 17:06.660
就把这件事封装到一个函数里面

17:07.220 --> 17:08.980
我就调用这个Delay

17:09.940 --> 17:10.820
等待一秒钟

17:11.700 --> 17:13.060
它返回了是不是一个Promise

17:13.780 --> 17:14.980
那我等待它呗

17:14.980 --> 17:15.780
等待它完成

17:16.500 --> 17:17.460
好那这个时候呢

17:17.460 --> 17:18.820
我不需要完成之后的数据

17:18.820 --> 17:20.660
你看完成之后是没有数据的

17:20.660 --> 17:21.540
我这个地方呢

17:21.540 --> 17:22.420
完成之后没有数据

17:22.420 --> 17:22.980
我也不需要

17:22.980 --> 17:24.020
不需要的话就直接等

17:25.220 --> 17:26.020
等待它完成

17:26.660 --> 17:28.020
完成之后呢

17:28.020 --> 17:31.220
我们再输出执行某个东西

17:31.940 --> 17:33.140
效果是完全一样的

17:33.140 --> 17:33.860
那你看

17:33.860 --> 17:35.380
上面代码看上去舒服了

17:35.380 --> 17:36.740
还是下面一个代码看上去舒服

17:37.300 --> 17:38.740
下面代码是没有回掉的

17:38.740 --> 17:39.460
说舒服很多

17:40.180 --> 17:40.980
但是呢

17:40.980 --> 17:42.500
唯一的美中部主的地方呢

17:42.500 --> 17:44.340
就是我们必须要把它放到一个函数里面

17:46.180 --> 17:46.980
因为它

17:46.980 --> 17:48.340
我要去等待它完成

17:48.340 --> 17:49.860
那我本身也是个异部任务

17:49.860 --> 17:50.020
对吧

17:50.020 --> 17:51.060
这个逻辑是通的

17:51.700 --> 17:52.260
有的时候呢

17:52.260 --> 17:52.980
我们有的时候

17:52.980 --> 17:54.020
我觉得这个函数

17:54.820 --> 17:56.740
就是为了写一个Erwynk

17:56.740 --> 17:57.860
我承认一个函数

17:57.860 --> 17:59.380
那有的时候我们可能会这样的写

17:59.460 --> 18:01.140
把它写成一个立即执行函数

18:05.520 --> 18:06.960
把它写成一个立即执行函数

18:09.820 --> 18:10.620
效果是一样的

18:12.880 --> 18:13.360
那当然了

18:13.360 --> 18:14.720
你也可以使用箭头函数

18:18.180 --> 18:18.900
效果是一样的

18:20.260 --> 18:21.460
这就是Erwynk

18:23.220 --> 18:25.620
好那么这是Erwynk的基本用法

18:27.780 --> 18:29.220
有一些细节给大家说一下

18:31.060 --> 18:33.620
Erwynk也可以等待其他数据

18:33.620 --> 18:35.220
比方说你等待的不是ProMesh

18:36.180 --> 18:38.020
那么这个就相当于是什么呢

18:38.020 --> 18:39.940
比方说你这里等待的是1

18:40.820 --> 18:42.260
比方说这里就一个例子

18:43.140 --> 18:46.450
输出data

18:46.450 --> 18:47.330
那么输出什么呢

18:47.330 --> 18:48.770
它输出肯定结果也是1

18:48.770 --> 18:51.090
这就代码就相当于是什么呢

18:51.090 --> 18:52.850
如果说你等待的不是ProMesh

18:53.890 --> 18:55.650
那么它会给你变成ProMesh

18:55.650 --> 18:56.690
它怎么变

18:56.690 --> 18:57.970
就是你这里不是ProMesh

18:57.970 --> 19:00.530
它就把你这里的表达是这个结果

19:00.530 --> 19:01.570
比方结果是1

19:01.810 --> 19:03.090
它就给你变成这个样子

19:03.250 --> 19:05.650
总之Erwynk它等待的一定是ProMesh

19:05.650 --> 19:07.250
如果说你写的不是ProMesh

19:07.250 --> 19:08.450
它可以变成这种格式

19:08.450 --> 19:09.490
把你写的东西放这

19:10.770 --> 19:12.050
所以说它最终还是ProMesh

19:13.330 --> 19:14.370
这是一个细节

19:14.370 --> 19:15.890
另外一个细节呢就是说

19:15.890 --> 19:17.410
这个ProMesh它不一定是成功

19:17.410 --> 19:18.450
有可能会失败

19:18.690 --> 19:21.010
那如果说它失败了

19:22.050 --> 19:23.570
我这里代码它就会爆出

19:24.610 --> 19:26.130
它就会抛出一个异常

19:27.170 --> 19:27.650
就个例子吧

19:27.650 --> 19:28.930
比方说我这里不一定是成功啊

19:28.930 --> 19:29.970
我有可能会失败

19:30.050 --> 19:31.250
那么这就代码了

19:31.250 --> 19:32.530
它就会得到一个异常

19:33.570 --> 19:35.090
一秒钟之后它就会抛出一个异常

19:36.370 --> 19:37.650
你看是不是得到一个异常

19:37.650 --> 19:40.210
那么如果说你要处理失败的话

19:40.210 --> 19:41.490
以前得怎么写

19:41.490 --> 19:44.270
以前是不是得这样的写

19:44.270 --> 19:45.550
我订了

19:46.830 --> 19:48.110
然后呢

19:48.110 --> 19:49.390
成功之后干嘛

19:49.390 --> 19:50.670
我只输出成功

19:50.670 --> 19:53.230
然后呢失败之后干嘛

19:53.230 --> 19:54.510
我输出失败原因

19:54.510 --> 19:55.790
或者是输出失败

19:55.790 --> 19:57.070
或者是输出失败

19:57.070 --> 19:58.350
或者是输出失败

19:58.350 --> 19:59.630
或者是输出失败

19:59.630 --> 20:02.190
我以前是不是要用回调的形式代码

20:02.190 --> 20:03.470
那你看现在是怎么写法

20:03.470 --> 20:04.750
新的写法

20:04.750 --> 20:05.790
新的写法的话

20:05.790 --> 20:07.310
他以为他这里会抛出异常

20:07.310 --> 20:08.590
所以说我们可以利用那个

20:08.590 --> 20:11.150
基础部分学习的Track Catch

20:12.430 --> 20:13.710
这是成功的代码

20:13.710 --> 20:14.990
如果说执行过程中

20:14.990 --> 20:16.270
这句话爆错了

20:16.270 --> 20:17.550
抛出了异常我们可以开启

20:17.550 --> 20:20.110
让它转而运行这里的代码

20:20.110 --> 20:21.390
这就是失败的原因

20:21.390 --> 20:24.940
你需要的话就用

20:24.940 --> 20:26.220
我这里不需要

20:26.220 --> 20:27.500
打印失败

20:27.500 --> 20:28.780
这里直接打印成功

20:29.100 --> 20:31.100
就写成这么一种格式

20:31.100 --> 20:34.780
你看上面的格式

20:34.780 --> 20:35.980
看上去是不是舒服很多

20:35.980 --> 20:36.860
没有回调嘛

20:36.860 --> 20:37.900
对不对

20:39.180 --> 20:40.460
失败

20:40.460 --> 20:43.020
这就是await它的处理方式

20:43.020 --> 20:45.580
这就是这里的内容

20:45.580 --> 20:46.860
其实内容不多

20:46.860 --> 20:48.140
就两个关键字

20:48.140 --> 20:50.700
它其实就是在Promise基础上

20:50.700 --> 20:53.260
让你进一步代码写上去

20:53.260 --> 20:54.540
更加舒服一点

20:54.540 --> 20:57.100
现在我们回到

20:57.100 --> 20:59.660
最开始学习Promise的问题

21:00.060 --> 21:03.260
又是邓哥的问题了

21:03.260 --> 21:05.820
告诉大家邓哥呢

21:05.820 --> 21:08.060
你们小瞧他了

21:08.060 --> 21:10.140
他的女神可不只有四个

21:10.140 --> 21:12.780
他的女神可能是四十个

21:12.780 --> 21:15.740
可能是四百个

21:15.740 --> 21:17.660
邓哥还是很厉害的人

21:17.660 --> 21:19.980
那么现在这种情况怎么办呢

21:19.980 --> 21:21.580
刚才之前四个女神

21:21.580 --> 21:23.180
我们都要写一大堆代码

21:23.180 --> 21:26.140
那四十个是不是写得更多

21:26.140 --> 21:27.420
你看我们现在用这几个

21:27.420 --> 21:28.620
而圣可和卫者

21:28.700 --> 21:31.180
非常舒服的解决

21:31.180 --> 21:33.100
那么邓哥为了方便

21:33.100 --> 21:34.300
编写这个表白代码

21:34.300 --> 21:35.500
所以他决定能把这个

21:35.500 --> 21:36.620
四十位女神的名字

21:36.620 --> 21:38.220
放到一个书乳里面

21:38.220 --> 21:40.220
叫做beauty girls

21:40.220 --> 21:41.020
美女

21:41.020 --> 21:42.540
这边全是

21:42.540 --> 21:44.380
他的女神的名字

21:44.380 --> 21:46.220
用小本记一下

21:46.220 --> 21:47.100
然后呢

21:47.100 --> 21:50.220
他决定循环这个书主

21:50.220 --> 21:51.420
一个一个表白

21:51.420 --> 21:52.780
失败了就表白下一个

21:52.780 --> 21:54.460
成功了就停止

21:54.460 --> 21:55.980
那么这个代码怎么写呢

21:56.060 --> 21:58.540
我把之前的代码给他从头写一遍

22:00.380 --> 22:01.740
好复制

22:01.740 --> 22:03.500
把这个代码弄过来

22:03.500 --> 22:06.220
这就是一个最终的完美的解决办法

22:06.220 --> 22:07.820
你看这个代码最终写出来

22:07.820 --> 22:08.620
就非常舒服了

22:08.620 --> 22:11.100
总之这是个女神的名字书主

22:11.100 --> 22:11.980
全是字母算书主

22:11.980 --> 22:13.020
谁一生存呢

22:13.020 --> 22:13.900
好扔这

22:13.900 --> 22:15.260
然后这是我们之前那个函书

22:15.260 --> 22:16.620
圣的message

22:16.620 --> 22:18.380
发送表白短信

22:18.380 --> 22:19.340
好不变

22:19.340 --> 22:20.460
返回来是promise

22:20.460 --> 22:22.300
前面要不要比较表记而圣可

22:22.300 --> 22:22.780
不用了

22:22.780 --> 22:24.620
因为他返回来就是promise

22:24.620 --> 22:25.660
以表记而圣可的目的

22:25.740 --> 22:27.260
不就是让他返回promise吗

22:27.260 --> 22:28.940
这里返回的本身就是promise

22:28.940 --> 22:29.900
所以说不用了

22:29.900 --> 22:32.940
好接下来我们就接着之前的写

22:32.940 --> 22:35.420
那么现在怎么写

22:35.420 --> 22:37.660
如果说你用传统的那个promise写

22:37.660 --> 22:38.460
还是麻烦

22:38.460 --> 22:39.420
能不能写呢

22:39.420 --> 22:40.460
其实可以写

22:40.460 --> 22:42.300
大家有兴趣的同学呢

22:42.300 --> 22:43.740
现在还可以想象怎么写

22:43.740 --> 22:45.340
还是有点麻烦的

22:45.340 --> 22:46.300
能写

22:46.300 --> 22:48.060
肯定是能写能用循环来写

22:48.060 --> 22:50.380
现在我们用而圣可和而威致的话

22:50.380 --> 22:51.580
非常的舒服

22:51.580 --> 22:53.100
你看怎么写

22:53.100 --> 22:54.780
首先我写个立即指引函数

22:55.500 --> 22:56.940
这个函数呢肯定是一个

22:56.940 --> 22:58.700
义不函数而圣可函数

22:58.700 --> 22:59.900
比如说我们说义不函数

22:59.900 --> 23:01.100
它指的是就是

23:01.100 --> 23:02.620
这个函数返回的是promise

23:03.420 --> 23:04.300
就是义不函数

23:04.300 --> 23:05.660
像这个玩意就是个义不函数

23:05.660 --> 23:05.980
对吧

23:05.980 --> 23:07.420
它不一定是标记的而圣可

23:07.420 --> 23:08.540
它只要返回promise

23:09.340 --> 23:10.300
它就是个义不函数

23:11.180 --> 23:12.540
由于而圣可标记之后

23:12.540 --> 23:13.820
它一定返回promise

23:13.820 --> 23:15.180
说而圣可标记过后的函数

23:15.180 --> 23:16.140
一定是义不函数

23:17.340 --> 23:18.220
这么可逻辑

23:19.580 --> 23:21.020
为什么把它写成一个义不函数呢

23:21.020 --> 23:22.140
因为它里边要用而威致

23:22.860 --> 23:23.420
看了怎么写

23:24.940 --> 23:26.140
它不是有很多女生吗

23:27.100 --> 23:28.460
我就循环

23:28.460 --> 23:29.420
用for or不循环

23:30.460 --> 23:33.740
循环每一个女生的名字

23:35.500 --> 23:36.140
beauty

23:37.020 --> 23:37.580
girls

23:41.570 --> 23:44.130
好我们这里输出女生的名字

23:45.570 --> 23:46.450
你看是不是循环了

23:46.450 --> 23:47.650
得到所有的女生名字了

23:48.690 --> 23:49.490
接下来呢

23:52.210 --> 23:54.930
这在某一个对每一个学生

23:55.010 --> 23:56.530
我们去send a message

23:56.930 --> 23:57.810
发送消息

23:58.610 --> 23:59.650
把名字传进去

24:00.610 --> 24:02.210
对每一个女生发送消息

24:03.010 --> 24:03.410
对吧

24:04.610 --> 24:06.530
那如果说你直接这样子写的话

24:06.530 --> 24:07.730
它就同时发送消息了

24:08.450 --> 24:10.130
第一次循环发送一个消息

24:10.130 --> 24:11.090
它不会等的对吧

24:11.090 --> 24:11.970
不会等那个消息

24:12.610 --> 24:13.810
不会等这个任务完成

24:13.810 --> 24:15.330
它马上就进入下一个循环

24:15.330 --> 24:16.210
又发送了一个消息

24:16.690 --> 24:18.290
它不会等那个任务完成

24:18.690 --> 24:20.930
所以它瞬间就发生了很多消息对吧

24:20.930 --> 24:21.330
然后呢

24:21.970 --> 24:23.250
最终一起收到回复

24:24.130 --> 24:25.410
那这样子显然不合适

24:25.410 --> 24:26.610
我要一个一个发

24:26.610 --> 24:27.250
那怎么办

24:27.250 --> 24:29.730
我就可以在货循环里边去写

24:31.010 --> 24:32.130
每一次循环

24:32.130 --> 24:33.810
你别着急进行下一次循环

24:33.810 --> 24:34.930
你先把这个代码等了

24:34.930 --> 24:35.730
等一下再说

24:36.290 --> 24:37.170
等它什么了

24:37.170 --> 24:39.170
等它那个promise完成

24:39.170 --> 24:40.130
这是不是promise

24:40.930 --> 24:42.690
完成之后之前是怎么做的

24:43.250 --> 24:43.970
用zim对吧

24:43.970 --> 24:44.690
现在不用认了

24:45.650 --> 24:46.610
完成之后了

24:46.610 --> 24:47.490
它会返回一个

24:48.130 --> 24:49.170
完成之后的数据

24:50.530 --> 24:52.450
完成之后不是有数据吗

24:52.530 --> 24:53.250
那这个数据呢

24:53.250 --> 24:54.530
我们按照我们之前的写法

24:54.530 --> 24:55.810
完成之后的数据是什么

24:55.810 --> 24:57.730
一个支付串表示女生的回复

24:57.730 --> 24:58.370
失败之后了

24:58.370 --> 25:00.370
也会有一个支付串表示女生的回复

25:00.370 --> 25:00.930
好

25:00.930 --> 25:03.330
完成之后我们会拿到一个回复

25:05.090 --> 25:05.810
我们就输出

25:06.530 --> 25:06.930
对不来

25:12.700 --> 25:13.500
对吧

25:13.500 --> 25:14.540
那么再输出一个

25:15.180 --> 25:15.980
表白成功

25:18.300 --> 25:19.420
现在我们来运行看一下

25:21.500 --> 25:23.260
第一个你看是不是一个一个进行

25:23.740 --> 25:24.460
一个一个进行

25:25.180 --> 25:25.900
对吧

25:25.980 --> 25:26.940
那为什么进行一个

25:26.940 --> 25:28.220
没有进行到下一个呢

25:28.220 --> 25:29.740
是因为第一个就失败了

25:29.740 --> 25:30.620
失败会怎么样

25:30.620 --> 25:31.260
之前说了

25:31.980 --> 25:33.100
偶尔一彩等待的时候

25:33.100 --> 25:34.140
如果说发生了失败

25:35.180 --> 25:36.620
它就会抛出一个异常

25:37.100 --> 25:38.460
这就代码就爆错了

25:38.460 --> 25:39.020
爆错的话

25:39.020 --> 25:41.420
整个代码是不是不会融入后续

25:42.540 --> 25:43.500
好那么如果说

25:43.500 --> 25:45.660
我们这里是不是要去处理这个错误

25:45.660 --> 25:46.620
我们可以用拆开

25:49.340 --> 25:51.020
上面是没有爆错的情况

25:51.020 --> 25:52.300
没有爆错是不是成功了

25:52.300 --> 25:53.900
成功之后拿到成功的消息

25:54.700 --> 25:55.660
输出成功的消息

25:55.660 --> 25:56.380
然后表白成功

25:57.660 --> 26:00.460
好如果说失败了

26:00.940 --> 26:01.340
失败了

26:01.340 --> 26:03.260
它是不是会给我一个失败的原因

26:03.260 --> 26:04.700
失败的原因是什么了

26:04.700 --> 26:06.620
是不是也是一个回复之不错

26:08.140 --> 26:08.460
对吧

26:08.460 --> 26:09.580
那么我们这里可以说

26:09.580 --> 26:10.940
也可以接受到一个锐盆

26:12.060 --> 26:12.940
回复

26:12.940 --> 26:13.980
那么输出一下回复

26:14.780 --> 26:15.660
这里我们输出一下

26:16.380 --> 26:17.420
表白失败

26:18.620 --> 26:19.980
好我们看一下一个了

26:20.940 --> 26:21.340
第一个

26:22.140 --> 26:23.100
这个表白失败

26:23.100 --> 26:24.380
第二个也是表白失败

26:24.380 --> 26:25.660
第三个表白失败

26:25.660 --> 26:27.180
就是一直往后都表白失败

26:28.060 --> 26:28.460
对吧

26:28.460 --> 26:29.100
表白失败

26:29.100 --> 26:29.340
好

26:29.340 --> 26:30.380
这表白成功了

26:30.380 --> 26:31.420
这里说还有bug

26:31.420 --> 26:32.220
什么bug

26:32.220 --> 26:33.500
就表白成功之后

26:33.500 --> 26:36.220
我们不需要进一步表白了

26:36.220 --> 26:37.420
不需要继续表白了

26:38.140 --> 26:38.780
那怎么办

26:39.260 --> 26:39.900
很简单吧

26:39.900 --> 26:40.860
这里是循环

26:40.860 --> 26:41.580
对吧

26:41.580 --> 26:43.500
表白成功之后退出循环

26:45.500 --> 26:45.740
好

26:45.740 --> 26:46.700
咱们再看一下

26:46.700 --> 26:47.260
另一条

26:51.380 --> 26:53.380
就不再往后面继续表白了

26:53.380 --> 26:54.180
失败失败

26:54.180 --> 26:55.700
失败了过后就继续循环对吧

26:56.740 --> 26:57.140
失败

26:58.180 --> 26:58.500
失败

26:59.940 --> 27:00.500
表白成功

27:00.500 --> 27:01.300
是不是不再继续了

27:02.340 --> 27:04.260
这个代码看上去是不是舒服太多了

27:05.060 --> 27:06.180
它没有回掉吧

27:06.180 --> 27:07.780
整个过程一看有回掉吗

27:07.780 --> 27:08.820
没有回掉

27:08.820 --> 27:09.460
它变成了一种

27:10.580 --> 27:12.740
注意传统的那种代码书写方式

27:12.740 --> 27:13.540
非常的清晰

27:15.220 --> 27:16.660
循环所有的女孩

27:16.660 --> 27:17.060
名字

27:18.420 --> 27:19.620
一次发送短信

27:19.620 --> 27:20.260
每一次发送

27:20.260 --> 27:20.820
人家要等

27:20.820 --> 27:22.180
还不着急进行下一次循环

27:22.180 --> 27:22.660
等一下

27:23.300 --> 27:24.340
但表白成功还是失败

27:24.340 --> 27:25.300
成功了过后

27:25.300 --> 27:26.420
我就输出成功的

27:26.420 --> 27:27.220
水回回消息

27:27.220 --> 27:27.780
然后输出

27:27.780 --> 27:28.980
然后结束循环

27:29.060 --> 27:29.700
不再继续了

27:30.340 --> 27:30.900
失败了

27:30.900 --> 27:31.860
如果说失败了

27:31.860 --> 27:33.460
转而进入失败的处理

27:33.460 --> 27:34.580
处理过后继续循环

27:35.460 --> 27:35.940
对吧

27:35.940 --> 27:37.460
这个代码逻辑很好

27:37.460 --> 27:38.260
很容易理解

27:39.860 --> 27:40.020
好

27:40.020 --> 27:40.660
那如果说

27:40.660 --> 27:42.260
我们如果说全部都失败

27:42.820 --> 27:44.180
全部都失败过后

27:44.180 --> 27:45.620
我们可能还要输出于一句

27:46.500 --> 27:47.300
总结性的话

27:47.300 --> 27:48.260
那这个又怎么办呢

27:48.260 --> 27:49.780
那这个处理的方式跟过去

27:50.980 --> 27:52.260
接下来是基础里边

27:52.260 --> 27:53.540
相当于是一个查照问题

27:53.540 --> 27:53.780
对吧

27:53.780 --> 27:56.980
循环查照每一个女孩的回复结果

27:56.980 --> 27:57.380
看一下

27:58.340 --> 27:58.900
如果说

27:59.940 --> 28:01.140
只要有一个成功了

28:01.140 --> 28:01.860
那就成功了

28:03.700 --> 28:04.420
所有的失败

28:04.420 --> 28:04.980
那就失败了

28:04.980 --> 28:06.260
所以我们就用一个flag

28:06.260 --> 28:07.780
用一个边量的玩具

28:07.780 --> 28:08.100
就是

28:10.580 --> 28:11.300
success

28:11.300 --> 28:12.180
是不是成功了

28:12.180 --> 28:13.140
默认是没有成功

28:13.700 --> 28:14.980
只要有一个成功了

28:14.980 --> 28:15.860
你就把它设置为

28:17.060 --> 28:17.460
对不对

28:18.100 --> 28:19.540
那如果说循环结束过后

28:19.540 --> 28:20.100
都没有成功

28:20.820 --> 28:21.700
就一直是失败

28:21.700 --> 28:22.340
一直是失败

28:22.340 --> 28:24.100
那么这个代码就不会运行

28:24.100 --> 28:26.260
这是非常非常基础的这个编程问题

28:27.060 --> 28:28.180
相当于是个查照问题

28:29.060 --> 28:30.500
要先把它设置为force

28:30.500 --> 28:31.780
成功之后就把它设为q

28:32.340 --> 28:33.380
如果说都没有成功了

28:33.380 --> 28:34.580
最终还是不还是force

28:34.580 --> 28:35.780
所以说出了循环之后

28:36.340 --> 28:36.980
出了循环之后

28:36.980 --> 28:38.500
我们判断一下这个辩量

28:38.500 --> 28:40.020
如果说这个辩量还是force

28:40.820 --> 28:41.700
还是没有成功

28:42.420 --> 28:43.300
这感叹号啥意思

28:43.300 --> 28:43.860
感叹号

28:43.860 --> 28:45.060
感叹号就是没有的意思

28:45.940 --> 28:46.980
不是没有

28:46.980 --> 28:49.140
就这个感叹号否定的意思

28:49.780 --> 28:50.580
但是不说

28:50.580 --> 28:51.460
还是没有成功

28:51.460 --> 28:52.420
那么最后就输出

28:52.980 --> 28:53.540
凳哥

28:54.500 --> 28:55.060
朱丁

28:56.660 --> 28:57.620
十十个都不行

28:57.620 --> 28:58.340
那就没办法

29:00.430 --> 29:01.950
那我就不用一个个等了

29:01.950 --> 29:02.510
成功了

29:02.510 --> 29:03.790
那这句话是没有输出

29:04.670 --> 29:04.830
好

29:04.830 --> 29:05.710
我们这里停止

29:06.670 --> 29:08.270
我们把名字改少一点吧

29:08.990 --> 29:10.830
就两个吧

29:14.770 --> 29:15.250
再运行

29:18.180 --> 29:18.500
好

29:18.500 --> 29:19.300
这里是不是输出了

29:20.260 --> 29:21.700
你看像这个代码

29:21.700 --> 29:23.780
看上去有清爽很多很多

29:23.780 --> 29:25.780
整个过程没有毁掉

29:25.860 --> 29:27.780
这就是Orsink和Orwish

29:27.780 --> 29:28.500
给我们开发

29:29.300 --> 29:30.420
Promise的异部长运

29:30.420 --> 29:31.700
带来了一些好处

29:33.140 --> 29:34.100
那么整个一步

29:34.100 --> 29:35.220
我们就学习完了

29:35.220 --> 29:36.100
然后最后

29:36.100 --> 29:36.980
我们还有一节课

29:36.980 --> 29:38.660
就专门来讲这一块的面试题

29:40.020 --> 29:40.340
好

29:40.340 --> 29:42.740
我们先来做一下本节课的练习题

29:44.020 --> 29:45.220
练习题有两道题

29:46.340 --> 29:46.900
第一道题

29:47.620 --> 29:48.260
他告诉你

29:48.820 --> 29:50.340
有一个函数已经给你写好了

29:50.340 --> 29:51.380
这个函数里边咋写的

29:51.380 --> 29:52.580
你现在不用管

29:52.580 --> 29:55.140
因为这是你们后边课程要学的

29:55.140 --> 29:56.340
现在还有点超纲

29:56.340 --> 29:57.860
但是这个函数已经写好了

29:57.860 --> 29:58.820
猪尸也可以打好了

29:58.820 --> 29:59.780
你要知道怎么去用

30:00.980 --> 30:02.020
这个函数

30:02.020 --> 30:05.220
它是远程获取王者荣耀

30:05.220 --> 30:06.500
所有的英雄数据

30:06.500 --> 30:07.380
你要知道它怎么用

30:08.980 --> 30:10.500
看一下这个函数标记的是啥

30:11.380 --> 30:12.580
标记的是不是Orsink

30:14.100 --> 30:15.540
那么这个函数返回什么类型

30:17.780 --> 30:18.500
返回什么类型

30:19.060 --> 30:21.140
返回它一定是Promise

30:22.180 --> 30:24.020
只要你看到一个函数标记为Orsink

30:24.100 --> 30:25.860
看都不用去看它有函数里边的东西

30:25.860 --> 30:27.380
它返回的一定是Promise

30:28.100 --> 30:28.900
一个异部人物

30:29.860 --> 30:30.900
以来调问这个函数过后

30:30.900 --> 30:32.340
它返回的是Promise

30:32.340 --> 30:33.540
那是不是可以用Z

30:34.180 --> 30:35.860
成功之后是不是可以拿到一个东西

30:36.420 --> 30:37.700
拿到一个相关的数据

30:37.700 --> 30:37.940
对吧

30:37.940 --> 30:38.900
我们输出一下数据

30:38.900 --> 30:39.460
来看一下

30:39.460 --> 30:41.140
就成功之后这个数据是啥

30:42.100 --> 30:42.820
我们运行

30:42.820 --> 30:43.300
看一下吧

30:51.490 --> 30:52.370
是不是得到一个数组

30:53.330 --> 30:53.650
对吧

30:53.650 --> 30:54.770
成功之后得到一个数组

30:54.770 --> 30:58.050
这个数组是所有的王者荣耀的英雄

30:59.250 --> 31:00.450
每个英雄是一个对象

31:01.650 --> 31:03.810
那是不是你后面可以接着处理呢

31:03.810 --> 31:04.770
对吧

31:04.770 --> 31:06.450
当然你除了用这种方式

31:06.450 --> 31:07.890
是不是还可以用我们这些和学习的

31:09.010 --> 31:10.690
Orsink的方式

31:11.650 --> 31:12.770
写个立即之音函数吧

31:13.970 --> 31:14.930
我们调问这个方法

31:14.930 --> 31:15.890
它返回的是Promise

31:15.890 --> 31:17.170
Promise是可以等待

31:17.170 --> 31:17.730
而为止

31:17.730 --> 31:18.210
等待它

31:19.250 --> 31:20.930
等待它完了过后

31:20.930 --> 31:22.210
成功之后是不是可能拿到

31:22.850 --> 31:23.890
成功之后的数据

31:24.770 --> 31:25.890
如果说你要处理失败的话

31:25.890 --> 31:26.850
你就用拆开器

31:27.570 --> 31:28.850
我这里不需要处理失败

31:28.850 --> 31:30.290
然后我们这里刷新一下

31:31.010 --> 31:32.450
说还是可以拿到这个数据

31:32.450 --> 31:32.850
看到没

31:33.650 --> 31:34.290
那么这两

31:34.290 --> 31:35.570
这这种下面这种写法

31:35.570 --> 31:37.410
就它就没有这个Zin里边的回调

31:37.410 --> 31:38.290
其实这种写法

31:38.290 --> 31:39.650
它也是一个语法堂

31:39.650 --> 31:41.250
它最终还是Killings用的是Zin

31:42.770 --> 31:43.410
就写起来

31:43.410 --> 31:44.530
我们也要写得舒服一点

31:45.490 --> 31:45.730
好

31:45.730 --> 31:46.690
我们这里输出了

31:46.690 --> 31:47.970
得到所有的英雄数据了

31:47.970 --> 31:49.250
那么接着我们的要求是

31:50.210 --> 31:51.970
把它显示到这个UOL里边

31:52.530 --> 31:53.730
我们拿到这个UOL

31:57.200 --> 31:57.760
Vocuments

31:58.640 --> 31:58.960
Yes

31:58.960 --> 31:59.760
Limits ID

32:00.640 --> 32:01.360
Here it is

32:03.040 --> 32:03.280
好

32:03.280 --> 32:04.160
我们这里要做啥

32:04.160 --> 32:04.640
哎呀

32:04.640 --> 32:05.280
老问题了

32:05.280 --> 32:06.160
对吧

32:06.160 --> 32:06.960
我要生成

32:06.960 --> 32:08.240
每个英雄生成一个Li

32:08.800 --> 32:10.240
这个英雄是一个数组吧

32:11.280 --> 32:12.240
对不对

32:12.240 --> 32:13.520
每个英雄是一个对啥

32:13.520 --> 32:14.320
是一个对象吧

32:14.880 --> 32:15.520
这个对象

32:16.240 --> 32:17.360
那我们每个英雄

32:17.360 --> 32:17.920
把对

32:17.920 --> 32:19.600
把每个英雄的对象变成啥

32:20.160 --> 32:21.200
变成一个Li

32:22.880 --> 32:23.840
不就做这个事吗

32:24.960 --> 32:26.160
Li里边的内容呢

32:26.240 --> 32:28.480
我只需要拼接英雄的名字

32:28.480 --> 32:29.600
Dingel Cling

32:29.600 --> 32:31.760
说以前做过很多次了对吧

32:31.760 --> 32:33.280
就不再说了

32:33.280 --> 32:33.680
于是呢

32:33.680 --> 32:35.040
会拿到一个新数组

32:35.040 --> 32:36.400
这个新数组的每一项呢

32:36.400 --> 32:37.600
是一个Li元数

32:44.780 --> 32:45.340
小沙

32:45.660 --> 32:47.020
它说Documents

32:47.660 --> 32:48.220
Dex

32:48.220 --> 32:49.100
哦这写错了

32:50.700 --> 32:51.100
刷新

32:53.520 --> 32:54.320
Dex

32:54.320 --> 32:55.360
Eliments

32:55.360 --> 32:56.320
Bind ID

32:56.720 --> 32:57.760
拿你写的有问题

32:57.760 --> 32:59.120
哦这里没有写分

33:02.060 --> 33:02.380
好

33:02.380 --> 33:04.140
你看是不是拿到一个新的数组

33:04.140 --> 33:05.260
这个新的数组

33:05.340 --> 33:08.140
把每一个英雄对象变成Li支付串

33:08.140 --> 33:08.620
然后呢

33:08.620 --> 33:09.580
我们接下来用什么呢

33:09.580 --> 33:10.300
用join

33:10.300 --> 33:12.220
把这个数组拼一下

33:13.820 --> 33:14.220
刷新

33:14.220 --> 33:16.060
所以拿到这么一个支付串了

33:16.060 --> 33:18.540
把这个支付串使用Inner

33:18.540 --> 33:19.100
AT秒

33:19.740 --> 33:20.380
复制过去

33:20.940 --> 33:21.500
就完了

33:22.620 --> 33:23.020
刷新

33:23.980 --> 33:25.100
就拿到所有的英雄了

33:25.660 --> 33:25.900
对

33:26.460 --> 33:27.020
好这是

33:27.980 --> 33:28.620
地道题啊

33:29.100 --> 33:29.900
大家可以问

33:29.900 --> 33:30.860
但是听着每一道题

33:30.860 --> 33:31.580
我讲戒之前

33:31.580 --> 33:32.620
你们可以尝试说一下

33:34.140 --> 33:34.780
好第二题

33:38.130 --> 33:38.850
第二题呢

33:38.850 --> 33:39.970
第一个问题

33:39.970 --> 33:41.170
让你完成地内函数

33:41.170 --> 33:42.850
这个函数是我们之前做过的

33:42.850 --> 33:44.130
而且我们刚刚才写过的

33:44.130 --> 33:44.850
你们自己写啊

33:44.850 --> 33:45.410
我这里不讲

33:47.940 --> 33:48.580
直接

33:48.580 --> 33:49.460
copy过来了

33:49.460 --> 33:50.340
这个没什么好说的

33:52.670 --> 33:53.870
这个函数要回写啊

33:53.870 --> 33:55.790
这是其实这个函数就是封装

33:55.790 --> 33:56.750
这些摊帽子

33:56.750 --> 33:58.030
而这些摊帽子这种形式呢

33:58.030 --> 33:59.470
变成Promise这种形式

34:00.190 --> 34:01.630
这个函数等待一段时间

34:01.630 --> 34:02.910
还返回一个Promise

34:02.910 --> 34:04.110
之前的是这些摊帽子

34:04.110 --> 34:05.070
是等待一段时间

34:05.070 --> 34:06.270
然后运行一个回掉

34:06.270 --> 34:06.830
对吧

34:06.830 --> 34:07.470
现在是等待

34:08.030 --> 34:08.830
返回一个Promise

34:08.830 --> 34:10.270
这个Promise等待一段时间之后

34:10.350 --> 34:11.070
它会自动完成

34:12.510 --> 34:13.150
没什么好说的

34:13.790 --> 34:15.390
然后呢利用这个地内函数

34:15.390 --> 34:16.270
让你做这么一件事

34:16.910 --> 34:17.790
等待三次

34:18.430 --> 34:19.070
看下面

34:19.070 --> 34:19.950
先等待一秒

34:19.950 --> 34:21.230
然后输出一个ok

34:21.230 --> 34:22.030
再等待一秒

34:22.030 --> 34:23.150
再输出一个ok

34:23.150 --> 34:24.030
再等待一秒

34:24.030 --> 34:24.750
输出一个ok

34:26.030 --> 34:26.590
怎么写

34:26.590 --> 34:28.350
你们自己自己去想办法写一下

34:29.950 --> 34:30.910
好好了没

34:30.910 --> 34:31.470
好我看一下

34:31.470 --> 34:32.670
不知道里面是怎么写的啊

34:33.550 --> 34:34.910
这里又可以有两种写法

34:34.910 --> 34:36.510
一种就是用Promise的

34:36.910 --> 34:37.710
API来写

34:38.270 --> 34:39.710
等待一秒钟

34:39.710 --> 34:41.150
Zin输出什么

34:43.150 --> 34:43.470
ok

34:44.110 --> 34:44.510
对吧

34:45.390 --> 34:46.110
然后呢

34:46.110 --> 34:47.150
返回下一个任务

34:47.150 --> 34:48.190
又等待一秒钟

34:50.510 --> 34:51.470
又等待一秒钟

34:53.310 --> 34:56.430
然后输出ok

34:57.310 --> 34:58.430
再等待一秒钟

35:00.990 --> 35:01.390
然后

35:02.430 --> 35:04.030
就是一个任务接一个任务

35:04.030 --> 35:04.910
短练式变成

35:05.950 --> 35:06.510
这种写法

35:06.510 --> 35:07.230
其实要比那个

35:07.790 --> 35:09.390
用回调很肯定要好

35:09.390 --> 35:10.590
它没有回调低远

35:10.590 --> 35:11.390
它没有一个回调

35:11.390 --> 35:11.950
套一个回调

35:11.950 --> 35:12.750
对吧

35:12.750 --> 35:13.950
这样子肯定要舒服得多

35:14.670 --> 35:15.310
一秒钟

35:15.310 --> 35:15.950
哎呀

35:16.510 --> 35:16.910
我这里

35:17.950 --> 35:19.310
哦这里有一个接个册

35:19.310 --> 35:20.030
有一个任务

35:20.750 --> 35:21.150
好看

35:22.030 --> 35:22.830
等待一秒钟

35:23.390 --> 35:23.870
ok

35:23.870 --> 35:24.670
再等待一秒钟

35:24.670 --> 35:24.910
ok

35:24.910 --> 35:25.630
再等待一秒钟

35:25.630 --> 35:26.030
ok

35:26.030 --> 35:26.750
好结束了

35:28.590 --> 35:30.590
我们也可以利用这几颗写下的东西

35:30.590 --> 35:32.030
然后写下更加舒服了

35:32.030 --> 35:32.830
你看

35:32.830 --> 35:33.630
我用而位册

35:34.430 --> 35:34.830
Zin

35:42.670 --> 35:44.030
好

35:44.030 --> 35:45.150
这是个一步寒朔

35:45.150 --> 35:46.830
我在这里面直接写个循环

35:46.830 --> 35:47.630
做完了

35:47.630 --> 35:48.430
循环几次

35:48.430 --> 35:49.070
循环三次

35:51.230 --> 35:51.630
对不对

35:51.630 --> 35:52.750
不是要输出三个ok吗

35:53.310 --> 35:54.510
每一次循环

35:54.510 --> 35:54.910
干嘛

35:56.350 --> 35:56.990
等待

35:59.230 --> 35:59.870
一秒钟

36:00.910 --> 36:01.550
输出

36:01.550 --> 36:02.030
ok

36:02.030 --> 36:03.390
那你看这个代码拿个舒服

36:04.270 --> 36:05.630
肯定上来的舒服太多了

36:05.630 --> 36:05.870
对吧

36:07.710 --> 36:08.430
循环三次

36:08.430 --> 36:08.750
ok

36:08.750 --> 36:09.230
ok

36:09.230 --> 36:09.790
ok

36:09.790 --> 36:10.750
效果是完全一样的

36:10.750 --> 36:11.630
然后循环结束了

36:12.430 --> 36:13.790
而且这样子特别好维护

36:13.790 --> 36:14.910
比方说我要等待

36:14.910 --> 36:16.030
我要做实试

36:16.030 --> 36:16.590
这样的事

36:16.590 --> 36:17.870
我这个感情实就完手了

36:19.230 --> 36:20.350
其实下面一个代码呢

36:20.350 --> 36:21.230
也可以用循环

36:22.350 --> 36:23.870
只是有点麻烦而已

36:24.590 --> 36:25.310
有点麻烦

36:25.950 --> 36:28.030
用这种其实也比较方便一点

36:30.510 --> 36:31.070
ok

36:31.070 --> 36:31.390
那

36:33.470 --> 36:34.270
有没有同学知道

36:34.270 --> 36:35.710
下面一个东西怎么能用循环写

36:36.270 --> 36:37.310
你们可以自己想想办法

36:38.750 --> 36:39.870
想不出来也没事

36:39.870 --> 36:40.750
反正我们有了

36:40.750 --> 36:42.190
而胜可而为者之后

36:42.270 --> 36:43.550
我们又可以用上面的人物写法

36:43.550 --> 36:44.590
更加舒服

36:44.590 --> 36:44.830
好

36:44.830 --> 36:46.270
那么我们Promise的学习呢

36:46.270 --> 36:47.950
一部任务的学习就结束了

36:47.950 --> 36:49.150
我们花了不少的时间

36:49.870 --> 36:51.070
来学这个东西

36:51.070 --> 36:52.190
因为这个东西特别重要

36:52.190 --> 36:53.710
衣食面试器特别特别好

36:53.710 --> 36:54.590
跑式体很密集

36:55.550 --> 36:56.030
另外呢

36:56.030 --> 36:56.270
就是

36:57.070 --> 36:58.910
这本身也是一个比较有难度的地方

36:59.870 --> 37:01.150
前端有难度的地方

37:01.150 --> 37:01.870
其实不读

37:02.590 --> 37:03.630
这算是一块

37:05.070 --> 37:05.550
另外呢

37:05.550 --> 37:07.950
就他其实跟我们以后开发呢

37:07.950 --> 37:08.750
影响了

37:08.750 --> 37:10.110
倒不是特别大

37:10.110 --> 37:10.590
我跟你说

37:10.590 --> 37:12.670
以后开发力对你们的影响是啥

37:12.670 --> 37:13.790
对你们的影响就是这个

37:14.750 --> 37:15.550
其实就是第一期

37:17.550 --> 37:18.750
高速里有一个函数

37:18.750 --> 37:20.110
它标记为而sync

37:20.110 --> 37:21.070
你要知道去怎么

37:21.070 --> 37:22.270
就是它是一个异固函数

37:22.910 --> 37:24.110
不管它标密标记而sync

37:24.110 --> 37:25.390
反正它办法或者是Promise

37:25.950 --> 37:27.790
它能拿到一些远程的数据

37:29.150 --> 37:30.510
我们需要用这个函数

37:32.030 --> 37:34.030
去获取到远程数据

37:34.030 --> 37:34.750
就是这样的获取

37:34.750 --> 37:36.910
其实跟我们以后经常会写这种办法

37:37.710 --> 37:39.710
其他长期有没有用到Promise的时候呢

37:39.710 --> 37:40.110
也有

37:40.750 --> 37:41.230
不读

37:41.790 --> 37:42.990
最常见的常见就是这个

37:43.550 --> 37:45.150
但是如果说你这一块紧急

37:45.150 --> 37:46.190
你就把这块

37:46.190 --> 37:48.270
东西安不就弯的背下来

37:48.270 --> 37:48.910
也不行

37:48.910 --> 37:49.230
因为

37:50.990 --> 37:52.350
反正也会有很多隐患

37:52.350 --> 37:53.790
所以我们花点时间把他学了

37:53.790 --> 37:54.750
把早晚都得学的

37:54.750 --> 37:56.270
这可必须要买过去的

37:56.270 --> 37:57.070
我们加油吧

37:57.630 --> 37:58.910
把这些课的作业完成

37:58.910 --> 38:00.030
后边我们会拿一些课

38:00.030 --> 38:01.470
专门来讲Promise的面试题

38:01.470 --> 38:02.030
一定要看

38:02.830 --> 38:04.190
好 这些课的内容就到这了

38:04.190 --> 38:04.670
拜拜

