WEBVTT

00:00.110 --> 00:03.510
好 这节课咱们来实现Promise的另外一个静态方法

00:03.510 --> 00:07.710
它说All 这个静态方法里边可以传一个什么

00:07.710 --> 00:11.010
传一个数组 对吧 虽然说它可以传数组

00:11.010 --> 00:15.410
其实呢 它不仅仅可以传数组 还可以传什么呀

00:15.410 --> 00:21.110
还可以传迭代器 就是Aterator 迭代器

00:21.110 --> 00:24.110
前边的面试题呢 大家学过了迭代器 对吧

00:24.110 --> 00:27.610
其实数组呢 也是一种迭代器的一种

00:27.610 --> 00:32.610
迭代器的特点是什么 可以使用For Over循环来循环它

00:32.610 --> 00:35.110
但是呢 你不能使用For 循环啊

00:35.110 --> 00:38.610
因为迭代器它不一定有下标的 懂得意思吧

00:38.610 --> 00:43.110
你不能使用For循环 而数组呢 是一种迭代器

00:43.110 --> 00:47.110
只不过数组它支持For循环 它包括伪数组

00:47.110 --> 00:50.610
伪数组也是迭代器 那么它支持For循环

00:50.610 --> 00:53.610
但是呢 不是所有的迭代器都支持For循环的

00:53.610 --> 00:57.110
它得到这么一个迭代器 就这里边可以传迭代器的

00:57.110 --> 00:59.110
当然我们经常传的都是数组 但是呢

00:59.110 --> 01:02.110
我们要把它想象成迭代器 这是面试题

01:02.110 --> 01:06.110
你能不能拿高分的一个点 就写这个O方法的时候

01:06.110 --> 01:10.110
注意啊 所以说你到时候写这个O方法

01:10.110 --> 01:12.110
那么这里传的一个数组 你要便利它

01:12.110 --> 01:14.110
你能不能用For循环便利 不能

01:14.110 --> 01:17.110
因为它不一定传的是数组 它可能传的是别的迭代器

01:17.110 --> 01:20.110
它可能没有下标 到时候面试的时候

01:20.110 --> 01:23.110
你就写的是For二五循环 那么面试完问题

01:23.110 --> 01:25.110
你为什么要用For二五啊 为什么不用用For循环啊

01:25.110 --> 01:28.110
因为这里呢 它传的是迭代器

01:28.110 --> 01:31.110
迭代器是不能用For循环来循环它的

01:31.110 --> 01:33.110
这是一个考点 同学们要记住

01:33.110 --> 01:38.110
好 那么现在呢 我们 知道O方法不用解释了吧

01:38.110 --> 01:40.110
它就是什么意思呢 就这里边传了很多东西

01:40.110 --> 01:42.110
传了很多个Promise

01:42.110 --> 01:45.110
你有一个Promise没 你有很多个Promise

01:45.110 --> 01:49.110
Promise 1、Promise 2 啊 传了很多个Promise

01:49.110 --> 01:53.110
它比这个盘数 它会返回一个新的Promise

01:53.110 --> 01:56.110
这个新的Promise 什么时候完成 成功

01:56.110 --> 01:59.110
必须要这里边的所有的Promise

01:59.110 --> 02:02.110
全部成功之后 它才成功

02:02.110 --> 02:04.110
那么比方说 第一个Promise成功之后

02:04.110 --> 02:07.110
数据是1 掉个Promise 数据是12 第三个Promise

02:07.110 --> 02:09.110
数据是3 那么它成功之后呢

02:09.110 --> 02:12.110
它这里得到了是一个数组

02:12.110 --> 02:14.110
这个Data是一个数组

02:14.110 --> 02:17.110
这个Data的纸呢 就应该是 1 2 3

02:17.110 --> 02:19.110
懂了意思吧

02:19.110 --> 02:21.110
好 那如果说这个数组里边传的是

02:21.110 --> 02:23.110
还有一个没有传Promise

02:23.110 --> 02:25.110
没有传Promise的话

02:25.110 --> 02:27.110
它里边会给你进行处理

02:27.110 --> 02:30.110
怎么处理呢 它就把它变成Promise Resolve 4

02:30.110 --> 02:32.110
懂了意思吧 就用这种方式来处理的

02:32.110 --> 02:35.110
所以这里边变成了1 2 3 4

02:35.110 --> 02:37.110
这就是这么一个逻辑

02:37.110 --> 02:40.110
必须要全部成功 我这个才成功

02:40.110 --> 02:42.110
那什么时候失败呢

02:42.110 --> 02:44.110
只要有任何一个Promise失败了

02:44.110 --> 02:47.110
哪个先失败 那么我这边

02:47.110 --> 02:49.110
反正就是失败的 只要有任何一个Promise失败

02:49.110 --> 02:51.110
那我就这就失败了

02:51.110 --> 02:52.110
那失败的原因是什么呢

02:52.110 --> 02:54.110
就是第一个Promise失败的原因

02:54.110 --> 02:56.110
比方说它先失败了

02:56.110 --> 02:59.110
那它失败的原因是Reason 2

02:59.110 --> 03:02.110
那么这里边Reason就变成了Reason 2

03:02.110 --> 03:04.110
Reason 2

03:04.110 --> 03:07.110
懂了意思吧 就这么一个逻辑

03:07.110 --> 03:08.110
好 咱们来写这个逻辑

03:08.110 --> 03:10.110
Promise这个Or方法也是

03:10.110 --> 03:12.110
面试的时候比较容易考到的

03:12.110 --> 03:14.110
写一个Or方法

03:14.110 --> 03:16.110
我再一次啊 多利八说

03:16.110 --> 03:17.110
这个元老师太啰嗦了

03:17.110 --> 03:18.110
再一次重生啊

03:18.110 --> 03:20.110
如果说面试让你写Or方法

03:20.110 --> 03:22.110
没有让你前面去实现自己的Promise

03:22.110 --> 03:24.110
你该怎么写 应该在这里写

03:24.110 --> 03:25.110
Or方法

03:25.110 --> 03:26.110
多利八是吧

03:26.110 --> 03:29.110
这个 不要怪我啰嗦

03:29.110 --> 03:31.110
我就生怕同学们没搞清楚

03:31.110 --> 03:33.110
到时候写都不知道在哪里写

03:33.110 --> 03:34.110
就有点郁闷了

03:34.110 --> 03:37.110
好 那么这边我就得到一个参数

03:37.110 --> 03:41.680
这是一个Materator

03:41.680 --> 03:44.680
这里是一个Materator

03:44.680 --> 03:46.680
怎么来定呢

03:46.680 --> 03:48.680
我只能这样定吧

03:48.680 --> 03:52.680
这是一个得到所有的Promise

03:52.680 --> 03:58.680
就是得到一个新的Promise

03:58.680 --> 04:03.680
该Promise的状态取决于

04:03.680 --> 04:12.680
取决于Promise的执行

04:12.680 --> 04:14.680
这个玩意我就不过都打中诗了

04:14.680 --> 04:16.680
它是一个迭代器

04:16.680 --> 04:18.680
还是多写一下吧

04:18.680 --> 04:21.680
是一个迭代器

04:21.680 --> 04:27.120
包含多个Promise

04:27.120 --> 04:32.120
全部Promise成功

04:32.120 --> 04:36.120
则返回的Promise成功

04:36.120 --> 04:44.120
数据为所有Promise成功的数据

04:44.120 --> 04:46.120
就这里面的数据是1234

04:47.120 --> 04:53.120
并且数据的数据

04:53.120 --> 04:54.120
它不是按照谁先完成

04:54.120 --> 04:56.120
谁就是第一个不是的

04:56.120 --> 04:57.120
它是按照数据的数据

04:57.120 --> 04:58.120
比方说你它先完成

04:58.120 --> 04:59.120
它的数据是3

04:59.120 --> 05:00.120
不好意思

05:00.120 --> 05:01.120
3还是在这儿

05:01.120 --> 05:02.120
懂的意思吧

05:02.120 --> 05:07.120
并且数据是按照传入的数据

05:07.120 --> 05:11.120
然后排列

05:11.120 --> 05:16.120
那么只要有一个Promise失败

05:16.120 --> 05:20.120
则返回的Promise失败

05:20.120 --> 05:27.120
原因是第一个失败的Promise的原因

05:27.120 --> 05:28.120
这是它的核心逻辑

05:28.120 --> 05:30.120
我把它注射打全一点

05:30.120 --> 05:32.120
好了来实现吧

05:32.120 --> 05:33.120
Return

05:33.120 --> 05:34.120
现在啥都不要想

05:34.120 --> 05:35.120
你给我返回一个Promise再说

05:35.120 --> 05:37.120
当然我这里要返回的是MyPromise

05:37.120 --> 05:38.120
我再一次罗里巴说的

05:38.120 --> 05:40.120
再重生一次

05:40.120 --> 05:41.120
你们那边如果说

05:41.120 --> 05:43.120
让你单独实现恶方法的时候

05:43.120 --> 05:44.120
这里返回来

05:44.120 --> 05:45.120
也不要多写个MyPromise

05:45.120 --> 05:47.120
我就怕同学们照抄我的天啊

05:47.120 --> 05:49.120
照抄的话就很尴尬了

05:49.120 --> 05:51.120
到时候要返回官方的

05:51.120 --> 05:52.120
好

05:52.120 --> 05:54.120
那么现在我返回Promise了

05:54.120 --> 05:56.120
接下来呢

05:56.120 --> 05:59.120
怎么来处理呢

05:59.120 --> 06:00.120
首先我肯

06:00.120 --> 06:01.120
这个要不要循环

06:01.120 --> 06:03.120
那肯定要循环

06:03.120 --> 06:04.120
对不对

06:04.120 --> 06:05.120
那么我们循环一个

06:05.120 --> 06:07.120
循环每一个Promise

06:07.120 --> 06:08.120
用Foreve循环

06:08.120 --> 06:10.120
一定要用Foreve

06:10.120 --> 06:12.120
现在呢我们是不是

06:12.120 --> 06:13.120
因为我们先假设

06:13.120 --> 06:15.120
他所有的都能成功

06:15.120 --> 06:16.120
那成功的时候

06:16.120 --> 06:17.120
我是不是要给他

06:17.120 --> 06:19.120
最终我要给他Resolve一个东西

06:19.120 --> 06:20.120
对吧

06:20.120 --> 06:21.120
Resolve一个什么东西呢

06:21.120 --> 06:23.120
Resolve一个

06:23.120 --> 06:26.120
一个数组

06:26.120 --> 06:28.120
最终我要给他Resolve一个数组

06:28.120 --> 06:29.120
我这要调入Resolve的方法

06:29.120 --> 06:30.120
给他一个数组

06:30.120 --> 06:31.120
那比方说有四个

06:31.120 --> 06:32.120
就是一 二 三 四

06:32.120 --> 06:34.120
我要把他传进去

06:34.120 --> 06:36.120
那么我这里是不是要准备好一个数组

06:37.120 --> 06:38.120
对不对

06:38.120 --> 06:39.120
那么我这里呢

06:39.120 --> 06:41.120
Resolve准备好一个数组

06:41.120 --> 06:43.120
来接收每一个Promise

06:43.120 --> 06:46.120
成功之后的这么一个结果

06:46.120 --> 06:49.120
这个没问题吧

06:49.120 --> 06:50.120
好

06:50.120 --> 06:52.120
那么现在大家思考一个问题

06:52.120 --> 06:54.120
两个问题其实

06:54.120 --> 06:55.120
第一个问题是

06:55.120 --> 06:57.120
我如何保证这个数组

06:57.120 --> 06:59.120
是有序的来排列

06:59.120 --> 07:00.120
什么叫有序的排列

07:00.120 --> 07:02.120
就第一个Promise完成之后

07:02.120 --> 07:05.120
我往这个数组里边加一下

07:05.120 --> 07:07.120
第二Promise完成之后

07:07.120 --> 07:09.120
我数组里边加一下

07:09.120 --> 07:11.120
你千万不能这样子写

07:11.120 --> 07:13.120
每一个Promise你完成了

07:13.120 --> 07:14.120
你完成了

07:14.120 --> 07:16.120
我就往那个数组里边Resolve

07:16.120 --> 07:18.120
Push一个Data

07:18.120 --> 07:20.120
你千万不能这样子写

07:20.120 --> 07:21.120
为什么呢

07:21.120 --> 07:23.120
因为你不知道哪一个先完成

07:23.120 --> 07:24.120
那万一3000完成了

07:24.120 --> 07:25.120
那就3就变成了第1个了

07:25.120 --> 07:26.120
3就变成第1个了

07:26.120 --> 07:28.120
我要保证有序

07:28.120 --> 07:29.120
这是第一个问题

07:29.120 --> 07:31.120
同样要想好几次思考

07:31.120 --> 07:32.120
第二个问题是什么呢

07:32.120 --> 07:35.120
我如何知道

07:35.120 --> 07:38.120
什么时候所有的Promise都完成了

07:38.120 --> 07:42.120
这个我如何知道

07:42.120 --> 07:45.120
是不是这里有好几个问题

07:45.120 --> 07:47.120
好 同学们不知道

07:47.120 --> 07:49.120
自己有没有什么方案

07:49.120 --> 07:51.120
我这里给大家提供一种方案

07:51.120 --> 07:53.120
我这里写上了一个辨量

07:53.120 --> 07:56.120
叫做Code

07:56.120 --> 07:58.120
这个表示什么

07:58.120 --> 08:01.120
Promise的技术

08:01.120 --> 08:02.120
如果说用for循环

08:02.120 --> 08:03.120
有下标的话

08:03.120 --> 08:04.120
我就肯定比较容易知道了

08:04.120 --> 08:06.120
而且数组还有一个属性类似

08:06.120 --> 08:07.120
但是由于它是一个迭代器

08:07.120 --> 08:09.120
它不一定有类似属性

08:09.120 --> 08:10.120
更加不能用for循环

08:10.120 --> 08:13.120
所以说我们这里用个辨量技术

08:13.120 --> 08:16.120
一开始数字是0

08:16.120 --> 08:18.120
一开始数字是0

08:18.120 --> 08:20.120
那么每循环一次

08:20.120 --> 08:24.120
我这个数字是不是要加加

08:24.120 --> 08:27.120
是不是要加加

08:27.120 --> 08:29.120
每一次循环数字加加

08:30.120 --> 08:31.120
好 理想一想

08:31.120 --> 08:33.120
那循环结束之后

08:33.120 --> 08:34.120
这个Code

08:34.120 --> 08:35.120
我先不说别的

08:35.120 --> 08:36.120
这个Code

08:36.120 --> 08:39.120
是不是就是Promise的种数

08:39.120 --> 08:40.120
那肯定是吗

08:40.120 --> 08:41.120
那比方说

08:41.120 --> 08:42.120
我们这里换成我们

08:42.120 --> 08:45.120
自己写的Promise

08:45.120 --> 08:49.120
来试一下

08:49.120 --> 08:51.120
这里没有这些东西

08:51.120 --> 08:53.120
我就这里就直接写个

08:53.120 --> 08:56.120
MyPromise Result 1

08:56.120 --> 08:59.120
然后这里Result 2

08:59.120 --> 09:00.120
Result 3

09:00.120 --> 09:02.120
好 咱们这里

09:02.120 --> 09:03.120
2 3

09:03.120 --> 09:04.120
好 我们来看一下

09:04.120 --> 09:06.120
一共有4个 对不对

09:06.120 --> 09:07.120
那这里是不是

09:07.120 --> 09:09.120
这个是不是得到它的种数

09:09.120 --> 09:11.120
就是Promise的种数

09:11.120 --> 09:14.120
慢慢从0开始一个个G

09:14.120 --> 09:16.120
然后除了种数之外

09:16.120 --> 09:18.120
我们还需要一个辨量

09:18.120 --> 09:20.120
就是要得到Promise的

09:20.120 --> 09:22.120
完成数量

09:22.120 --> 09:25.120
FullFilledCode

09:25.120 --> 09:27.120
它也是从0开始

09:27.120 --> 09:29.120
以完成的数量

09:29.120 --> 09:32.120
哪些Promise是已经完成的

09:32.120 --> 09:33.120
那么这个数量

09:33.120 --> 09:34.120
我怎么来记述呢

09:34.120 --> 09:35.120
是不是我只有等到

09:35.120 --> 09:37.120
这个Promise完成之后

09:37.120 --> 09:38.120
对不对

09:38.120 --> 09:40.120
你完成了一个

09:40.120 --> 09:42.120
那我就可以计个数了

09:42.120 --> 09:46.500
FullFilledCode加加

09:46.500 --> 09:48.500
以完成的数量

09:48.500 --> 09:49.500
接下来

09:49.500 --> 09:51.500
让我们来输出一下

09:51.500 --> 09:53.500
FullFilledCode

09:53.500 --> 09:54.500
好 运行

09:57.500 --> 09:58.500
运行

09:58.500 --> 10:03.260
运行怎么没消息呢

10:03.260 --> 10:06.700
前边

10:06.700 --> 10:08.700
Code加加

10:08.700 --> 10:10.700
好 我再打断点了

10:10.700 --> 10:11.700
我看一下

10:11.700 --> 10:13.700
为什么他都没弹出来消息

10:17.900 --> 10:19.900
他都没有运行

10:19.900 --> 10:21.900
没有运行到这句话吗

10:21.900 --> 10:24.900
没有运行到这句话

10:25.900 --> 10:26.900
这有点神奇

10:26.900 --> 10:31.790
我们这里打个断点

10:31.790 --> 10:33.790
再来

10:33.790 --> 10:38.420
好 终于运行过来了

10:38.420 --> 10:40.420
运行到这 运行到这

10:40.420 --> 10:42.420
0

10:42.420 --> 10:44.420
运行到这

10:44.420 --> 10:46.420
后边就没运行了

10:46.420 --> 10:48.420
我再来 再来 再试一下

10:48.420 --> 10:50.420
这是什么问题

10:50.420 --> 10:53.420
我一步步来运行到这

10:53.420 --> 10:54.420
这个加加

10:54.420 --> 10:55.420
现在变成了1

10:55.420 --> 10:56.420
没问题

10:56.420 --> 10:58.420
加加变成了2

10:58.420 --> 10:59.420
没问题

10:59.420 --> 11:01.420
变成了3

11:01.420 --> 11:03.420
3没问题

11:03.420 --> 11:05.420
再变成

11:05.420 --> 11:07.420
变成4没问题

11:12.440 --> 11:14.440
这里出了问题

11:14.440 --> 11:16.440
出了问题他应该给我爆错

11:16.440 --> 11:18.440
他为什么没爆错了

11:18.440 --> 11:19.440
我知道这里有问题

11:19.440 --> 11:20.440
我知道这里有问题

11:20.440 --> 11:22.440
他为什么没有爆错

11:22.440 --> 11:23.440
我想来研究一下

11:23.440 --> 11:25.440
为什么正常应该要爆错的

11:25.440 --> 11:26.440
为什么问题呢

11:26.440 --> 11:27.440
就是在这

11:27.440 --> 11:30.440
这有个4他不是Promise

11:30.440 --> 11:31.440
那怎么办

11:31.440 --> 11:33.440
像这种不是Promise怎么办

11:33.440 --> 11:35.440
我说过你就把它当成Promise

11:35.440 --> 11:37.440
怎么办呢 就用Riddle把包一下

11:37.440 --> 11:39.440
所以针对这个屁

11:39.440 --> 11:40.440
我先二话不说

11:40.440 --> 11:42.440
我先给他来一个MyPromise

11:42.440 --> 11:44.440
Riddle我再说

11:44.440 --> 11:46.440
我先给他包一下再说

11:46.440 --> 11:47.440
那么你看一下

11:47.440 --> 11:49.440
我们之前实现了Riddle

11:49.440 --> 11:50.440
如果说你给我传的

11:50.440 --> 11:51.440
就是一个Promise的话

11:51.440 --> 11:52.440
我直接把自身返回了

11:52.440 --> 11:53.440
对不对

11:53.440 --> 11:55.440
如果说其他情况的话

11:55.440 --> 11:56.440
我给你返回一个Promise

11:56.440 --> 11:58.440
总之他返回的就是Promise

11:58.440 --> 12:00.440
因此给他包一下就没问题了

12:00.440 --> 12:01.440
咱们来看

12:01.440 --> 12:03.440
但是他应该要爆错的才对

12:03.440 --> 12:04.440
那么现在得到的是40

12:04.440 --> 12:06.440
首先解释这个现象

12:06.440 --> 12:08.440
他为什么得到的是4和0的

12:08.440 --> 12:10.440
不是这里全部都完成了吗

12:10.440 --> 12:11.440
4个Promise全部都完成了

12:11.440 --> 12:13.440
为什么得到的是4和0的

12:13.440 --> 12:15.440
因为这个家是放到哪的

12:15.440 --> 12:16.440
是放到Riddle里面的

12:16.440 --> 12:17.440
它是不是异布的

12:17.440 --> 12:19.440
它是不是放到Widdle里面执行

12:19.440 --> 12:20.440
因此执行这个代码的时候

12:20.440 --> 12:22.440
这个Riddle是不是还没有执行

12:22.440 --> 12:24.440
是这个逻辑吗

12:24.440 --> 12:26.440
所以说我们这个Full Code

12:26.440 --> 12:27.440
这个地方在这里打印

12:27.440 --> 12:31.440
比方说Full Code

12:31.440 --> 12:33.440
你完成了数量

12:33.440 --> 12:35.440
换句话说

12:35.440 --> 12:37.440
我要说明什么道理呢

12:37.440 --> 12:39.440
代码运行到这儿

12:39.440 --> 12:41.440
是不是总数都已经确定好了

12:41.440 --> 12:42.440
你看这个行代码都运行了

12:42.440 --> 12:43.440
对吧

12:43.440 --> 12:44.440
说不定循环早就结束了

12:44.440 --> 12:46.440
代码运行到这儿的时候

12:46.440 --> 12:47.440
循环已经结束了

12:47.440 --> 12:48.440
因为它在Widdle里面

12:48.440 --> 12:50.440
这个时候总数就已经出来了

12:50.440 --> 12:52.440
因为完成一个它加加

12:52.440 --> 12:53.440
然后我怎么来知道

12:53.440 --> 12:54.440
是不是最后一个呢

12:54.440 --> 12:56.440
是不是我这里判断一下

12:56.440 --> 12:58.440
Full Code

12:58.440 --> 13:00.440
加了之后是不是等于Code

13:00.440 --> 13:02.440
如果想等于说明啥

13:02.440 --> 13:06.440
说明当前是最后一个Promise

13:06.440 --> 13:09.440
最后一个Promise完成了

13:09.440 --> 13:11.440
那我们这里输出一下

13:11.440 --> 13:13.440
全部完成了

13:13.440 --> 13:15.440
OK 我们运行

13:15.440 --> 13:17.440
好 你看是不是全部完成了

13:17.440 --> 13:18.440
就在这里

13:18.440 --> 13:19.440
因此在这个位置

13:19.440 --> 13:20.440
我们使用什么

13:20.440 --> 13:22.440
使用Result

13:22.440 --> 13:23.440
是不是告诉他

13:23.440 --> 13:24.440
你全部都完成了

13:24.440 --> 13:26.440
是不是我这个Promise也完成了

13:26.440 --> 13:27.440
因为一个Order逻辑

13:27.440 --> 13:28.440
就是全部成功之后

13:28.440 --> 13:30.440
到我的也跟着成功了

13:30.440 --> 13:32.440
好 那么这里Result

13:32.440 --> 13:33.440
好 别的不说

13:33.440 --> 13:35.440
我们看一下能不能正确的Result

13:35.440 --> 13:39.200
成功

13:39.200 --> 13:40.200
好 这个没问题了

13:40.200 --> 13:41.200
对吧

13:41.200 --> 13:43.200
OK 那接下来就是数据了

13:43.200 --> 13:45.200
我传什么数据进去

13:45.200 --> 13:46.200
我传的什么数据

13:46.200 --> 13:47.200
肯定是传的是Result

13:47.200 --> 13:49.200
这个毫无疑问

13:49.200 --> 13:51.200
这边我们要把这个Result打印出来

13:51.200 --> 13:54.960
Result

13:54.960 --> 13:56.960
运行

13:56.960 --> 13:58.960
打印出来是空的

13:58.960 --> 13:59.960
因为这个数据是空注准

13:59.960 --> 14:00.960
里边啥都没有

14:00.960 --> 14:01.960
好 传的是Result

14:01.960 --> 14:03.960
那么现在呢

14:03.960 --> 14:05.960
Result里面是没有值的

14:05.960 --> 14:07.960
那我怎么来给它复值呢

14:07.960 --> 14:08.960
刚刚之前是不是说过

14:08.960 --> 14:09.960
这个data

14:09.960 --> 14:11.960
表示我目前这个Promise

14:11.960 --> 14:12.960
已经完成了

14:12.960 --> 14:13.960
它的数据是data

14:13.960 --> 14:15.960
但是那我不能用PoC

14:15.960 --> 14:16.960
因为用PoC的话

14:16.960 --> 14:18.960
那么会导致顺序不对

14:19.960 --> 14:20.960
Result

14:20.960 --> 14:21.960
我不能用PoC

14:21.960 --> 14:22.960
为什么现在不报错了呢

14:22.960 --> 14:23.960
问题是

14:23.960 --> 14:25.960
那边这个问题

14:25.960 --> 14:27.960
它为什么不报错了

14:27.960 --> 14:29.960
这个很头疼

14:29.960 --> 14:30.960
刚才用的是这个

14:30.960 --> 14:31.960
这个都没有这个变量

14:31.960 --> 14:32.960
对吧

14:32.960 --> 14:33.960
没有这个变量

14:33.960 --> 14:34.960
它应该给我报错了

14:34.960 --> 14:35.960
结果不给我报错

14:35.960 --> 14:36.960
这是什么情况

14:41.960 --> 14:42.960
我明白了

14:42.960 --> 14:43.960
我明白了

14:43.960 --> 14:44.960
我明白了

14:44.960 --> 14:45.960
为什么不报错

14:45.960 --> 14:46.960
是因为我那边开启掉了

14:46.960 --> 14:47.960
我那个Promise里面

14:47.960 --> 14:48.960
没有在控制台打印错误

14:48.960 --> 14:49.960
对吧

14:49.960 --> 14:50.960
我是把它开启掉了

14:50.960 --> 14:51.960
所以说

14:51.960 --> 14:52.960
如果说你要把这个

14:52.960 --> 14:53.960
做得完善一点的话

14:53.960 --> 14:54.960
在这个ROM里面

14:54.960 --> 14:56.960
如果说发现了错误

14:56.960 --> 14:57.960
对吧

14:57.960 --> 14:58.960
我顺便

14:58.960 --> 14:59.960
除了Result之外

14:59.960 --> 15:01.960
我顺便拿一个Error

15:01.960 --> 15:03.960
打印一下这个错误

15:03.960 --> 15:04.960
现在我就知道了

15:04.960 --> 15:06.960
哪些的错误是什么情况了

15:06.960 --> 15:07.960
当然了

15:07.960 --> 15:08.960
也可以在

15:08.960 --> 15:09.960
不仅在这

15:09.960 --> 15:10.960
在勾到器里面

15:10.960 --> 15:11.960
是吧

15:11.960 --> 15:12.960
这里有一个开启

15:12.960 --> 15:13.960
那么我们这里Error

15:13.960 --> 15:14.960
Consol

15:14.960 --> 15:15.960
Error

15:15.960 --> 15:16.960
打印错误

15:17.960 --> 15:18.960
做这么一个处理完事了

15:18.960 --> 15:19.960
我说怎么回事

15:20.960 --> 15:21.960
不报错

15:21.960 --> 15:22.960
太奇怪了

15:22.960 --> 15:23.960
被开启掉了

15:24.960 --> 15:25.960
好

15:25.960 --> 15:26.960
那么现在回到这

15:27.960 --> 15:28.960
现在

15:28.960 --> 15:29.960
我们不能用PUSH

15:29.960 --> 15:30.960
因为用PUSH的话

15:30.960 --> 15:31.960
会导致

15:31.960 --> 15:32.960
我们把换成Results

15:33.960 --> 15:35.960
它有可能会出现一种情况

15:35.960 --> 15:36.960
它就是

15:39.530 --> 15:40.530
没问题了吧

15:40.530 --> 15:41.530
现在应该没问题了

15:42.530 --> 15:43.530
它还有哪一样

15:43.530 --> 15:44.530
250行

15:45.530 --> 15:46.530
250行

15:47.530 --> 15:48.530
这里是Data

15:49.530 --> 15:52.350
那么现在看上去

15:52.350 --> 15:53.350
好像没问题

15:53.350 --> 15:54.350
1234排列正确的

15:54.350 --> 15:56.350
那如说是这种情况

15:56.350 --> 15:57.350
比方说Pro

15:57.350 --> 15:58.350
Pro1

15:58.350 --> 15:59.350
6一个Promise

16:01.350 --> 16:02.350
用的是MyPromise

16:04.350 --> 16:05.350
我要等待一会

16:05.350 --> 16:06.350
不是马上

16:06.350 --> 16:07.350
我等待

16:07.350 --> 16:08.350
10毫秒吧

16:08.350 --> 16:09.350
然后我再完成1

16:11.350 --> 16:12.350
那么这样子的话

16:12.350 --> 16:13.350
我把Pro1传进去的话

16:13.350 --> 16:14.350
它肯定不是

16:14.350 --> 16:15.350
第一个完成的

16:15.350 --> 16:16.350
肯定不是

16:17.350 --> 16:18.350
第一个完成的

16:18.350 --> 16:19.350
应该是2

16:19.350 --> 16:20.350
然后是3

16:20.350 --> 16:21.350
然后是4

16:21.350 --> 16:22.350
然后是它

16:22.350 --> 16:23.350
结果就出现了这样一个

16:23.350 --> 16:24.350
2341

16:24.350 --> 16:25.350
那不是我们想要的

16:25.350 --> 16:27.350
所以说我们不能用PUSH

16:27.350 --> 16:28.350
那怎么做呢

16:29.350 --> 16:30.350
就逻辑很简单

16:30.350 --> 16:31.350
什么逻辑

16:32.350 --> 16:33.350
就看循环到第几次

16:33.350 --> 16:34.350
你第一次循环

16:34.350 --> 16:35.350
那么你

16:35.350 --> 16:36.350
这个Promise完成之后

16:36.350 --> 16:37.350
你就给

16:37.350 --> 16:38.350
应该给数组的

16:38.350 --> 16:39.350
第一项复制

16:39.350 --> 16:40.350
你第二次循环

16:40.350 --> 16:41.350
就应该给数组的

16:41.350 --> 16:42.350
第二项复制

16:42.350 --> 16:43.350
对吧

16:43.350 --> 16:44.350
所以说我这里写个辩量

16:45.350 --> 16:46.350
所以一定要用NAT

16:46.350 --> 16:47.350
一定要用NAT

16:47.350 --> 16:48.350
不然用VAR的话

16:48.350 --> 16:49.350
那么这个辩量

16:49.350 --> 16:50.350
就会提到顶部了

16:50.350 --> 16:51.350
就提到这个函数的顶部

16:51.350 --> 16:52.350
又会变成一个

16:52.350 --> 16:54.350
典型的必保问题

16:54.350 --> 16:55.350
那么这个辩量

16:55.350 --> 16:56.350
会导致每个Promise

16:56.350 --> 16:57.350
共用这个辩量

16:58.350 --> 16:59.350
那到时候认的时候

16:59.350 --> 17:00.350
那个辩量都已经是

17:00.350 --> 17:01.350
一个固定的值了

17:01.350 --> 17:02.350
对吧

17:02.350 --> 17:03.350
都已经是一个固定的值了

17:03.350 --> 17:04.350
所以说我们这个辩量

17:04.350 --> 17:05.350
一定要写到

17:05.350 --> 17:06.350
一个课讯环理一边

17:06.350 --> 17:07.350
保证这个辩量

17:07.350 --> 17:08.350
只在单式

17:08.350 --> 17:09.350
课讯环组成效

17:10.350 --> 17:11.350
我们知道

17:11.350 --> 17:12.350
ES6有一个跨局作用率

17:12.350 --> 17:13.350
对吧

17:13.350 --> 17:14.350
那么这个

17:14.350 --> 17:15.350
用内锁之后

17:15.350 --> 17:16.350
这个辩量是

17:16.350 --> 17:17.350
只作用于这个块的

17:17.350 --> 17:18.350
每一次循环

17:18.350 --> 17:19.350
这个I都不一样

17:20.350 --> 17:21.350
那么这个I等于什么

17:22.350 --> 17:23.350
等于扣子

17:23.350 --> 17:25.350
这句话要提前写

17:26.350 --> 17:27.350
要写到这

17:29.350 --> 17:30.350
写到这

17:30.350 --> 17:31.350
这样子的每一次

17:31.350 --> 17:32.350
你看

17:32.350 --> 17:33.350
第一个Promise

17:33.350 --> 17:34.350
完成之后

17:34.350 --> 17:35.350
我们输出一下这个I

17:41.180 --> 17:42.180
第一次完成

17:42.180 --> 17:43.180
是不是先完成的

17:43.180 --> 17:44.180
是第二个

17:44.180 --> 17:45.180
然后最后完成的是第零个

17:45.180 --> 17:46.180
那么这个I

17:46.180 --> 17:47.180
是不是就记录了

17:47.180 --> 17:48.180
每一个Promise

17:48.180 --> 17:49.180
它对应的下标

17:49.180 --> 17:50.180
对不对

17:50.180 --> 17:51.180
你看我们完成的顺序是

17:51.180 --> 17:53.180
二 三 四

17:53.180 --> 17:54.180
对吧

17:54.180 --> 17:56.180
下标为一到先完成

17:56.180 --> 17:57.180
下标为二到再完成

17:57.180 --> 17:58.180
下标为三到再完成

17:58.180 --> 17:59.180
然后最后完成的是

17:59.180 --> 18:00.180
下标为理由

18:00.180 --> 18:01.180
那么这样子

18:01.180 --> 18:02.180
输出一二三理由

18:02.180 --> 18:03.180
是没有问题的

18:03.180 --> 18:04.180
是对应好了的

18:04.180 --> 18:05.180
如果说

18:05.180 --> 18:07.180
它不是这样的输出

18:07.180 --> 18:08.180
比方说我真的用的话

18:08.180 --> 18:09.180
那里看一下

18:09.180 --> 18:10.180
那管它

18:10.180 --> 18:12.180
那全部都是输出一样的

18:12.180 --> 18:13.180
而且它对应关心就没了

18:13.180 --> 18:14.180
所以说我们这里

18:14.180 --> 18:15.180
一定要用DAT

18:15.180 --> 18:17.180
然后把当前的下标

18:17.180 --> 18:18.180
保存一下

18:18.180 --> 18:19.180
就靠成了就每一次循环

18:19.180 --> 18:20.180
它就可以充当一个下标

18:20.180 --> 18:21.180
对吧

18:21.180 --> 18:22.180
把它保存一下

18:23.180 --> 18:24.180
OK

18:24.180 --> 18:25.180
那么这样子一来的话

18:25.180 --> 18:26.180
我这里是不是简单了

18:26.180 --> 18:27.180
就变成了什么

18:27.180 --> 18:28.180
Results

18:28.180 --> 18:29.180
I等于什么

18:29.180 --> 18:30.180
等于DAT

18:31.180 --> 18:32.180
那我们现在再看一下

18:32.180 --> 18:33.180
运行

18:33.180 --> 18:34.180
是不是一二三四

18:34.180 --> 18:35.180
排得好了

18:36.180 --> 18:37.180
OK

18:37.180 --> 18:38.180
那么成功的情况

18:38.180 --> 18:39.180
就已经搞定了

18:39.180 --> 18:40.180
就已经搞定了

18:40.180 --> 18:41.180
还有啥

18:41.180 --> 18:42.180
你这个每一个Promise

18:42.180 --> 18:43.180
完成的时候记个数

18:43.180 --> 18:45.180
如果说数量到一定数量之后

18:45.180 --> 18:46.180
那我就认为

18:46.180 --> 18:47.180
所有的都全部完成了

18:47.180 --> 18:48.180
全部完成我就结束了

18:48.180 --> 18:49.180
结束的时候

18:49.180 --> 18:50.180
我把这种数据给你传过来

18:50.180 --> 18:51.180
这个数据

18:51.180 --> 18:52.180
我要保证它的顺序

18:52.180 --> 18:54.180
所以说我让每一个Promise

18:54.180 --> 18:56.180
要对应一个I

18:56.180 --> 18:57.180
就是它的下标

18:57.180 --> 18:58.180
每个Promise在整个

18:58.180 --> 19:00.180
这个迭代器里面的下标

19:00.180 --> 19:01.180
对应好了之后

19:01.180 --> 19:02.180
我只要你完成

19:02.180 --> 19:03.180
反正个下标

19:03.180 --> 19:04.180
在这个快递状态里面

19:04.180 --> 19:05.180
是不会变的

19:05.180 --> 19:06.180
那么只要你完成

19:06.180 --> 19:07.180
我就用这个下标

19:07.180 --> 19:08.180
给它复制

19:08.180 --> 19:09.180
对吧

19:09.180 --> 19:10.180
我不管你是什么时候完成

19:10.180 --> 19:11.180
反正个I不会变

19:12.180 --> 19:13.180
OK 那么这个地方

19:13.180 --> 19:14.180
搞定了之后

19:14.180 --> 19:15.180
那拒绝怎么办

19:16.180 --> 19:18.180
拒绝极其简单

19:18.180 --> 19:19.180
因为拒绝的逻辑是什么

19:19.180 --> 19:20.180
只要有任何一个人

19:20.180 --> 19:22.180
一任何一个Promise失败

19:22.180 --> 19:23.180
那我就失败了

19:24.180 --> 19:25.180
任何一个

19:25.180 --> 19:26.180
是不是要对

19:26.180 --> 19:28.180
每一个Promise注册拒绝处理

19:28.180 --> 19:30.180
就写一句话

19:30.180 --> 19:31.180
就结束完了

19:32.180 --> 19:33.180
为什么呢

19:33.180 --> 19:34.180
比方说

19:34.180 --> 19:35.180
第二个Promise

19:35.180 --> 19:36.180
比方说

19:36.180 --> 19:37.180
第一个Promise失败了

19:38.180 --> 19:39.180
第一个Promise

19:39.180 --> 19:40.180
前面三个都成功了

19:40.180 --> 19:41.180
比方说

19:41.180 --> 19:43.180
这里锐这个成

19:44.180 --> 19:45.180
那么这个成功了

19:45.180 --> 19:46.180
这个成功了

19:46.180 --> 19:47.180
那么他们都记述了

19:47.180 --> 19:48.180
记得三个了

19:48.180 --> 19:49.180
对吧

19:49.180 --> 19:50.180
还差一个

19:50.180 --> 19:51.180
然后十毫秒之后

19:51.180 --> 19:52.180
一失败了

19:52.180 --> 19:53.180
那么一失败

19:53.180 --> 19:54.180
是不是要调用这个

19:54.180 --> 19:55.180
调用这个

19:55.180 --> 19:56.180
是不是导致这个失败了

19:56.180 --> 19:57.180
那有同学说

19:57.180 --> 19:58.180
两个失败怎么办

19:58.180 --> 19:59.180
两个失败没事

19:59.180 --> 20:00.180
因为这个锐这个成了

20:00.180 --> 20:02.180
它只会调用一次

20:02.180 --> 20:04.180
它第二次调用是无效的

20:04.180 --> 20:05.180
所以就保证了

20:05.180 --> 20:06.180
最先调用的

20:06.180 --> 20:07.180
省销

20:07.180 --> 20:08.180
后续就调用了

20:08.180 --> 20:09.180
就无效了

20:09.180 --> 20:10.180
反正都失败了

20:10.180 --> 20:11.180
那么这样子呢

20:11.180 --> 20:13.870
你看一下

20:13.870 --> 20:14.870
好

20:14.870 --> 20:15.870
我们看一下失败的

20:15.870 --> 20:16.870
输出

20:17.870 --> 20:18.870
失败

20:19.870 --> 20:23.080
失败

20:24.080 --> 20:25.080
看一下

20:25.080 --> 20:26.080
是不是没问题

20:26.080 --> 20:28.080
那么失败就搞定了

20:28.080 --> 20:29.080
就非常简单

20:29.080 --> 20:30.080
好

20:30.080 --> 20:31.080
那么这个地方完了之后

20:31.080 --> 20:33.080
其实这里还有一个逻辑

20:33.080 --> 20:34.080
什么逻辑呢

20:34.080 --> 20:35.080
就是如果说

20:35.080 --> 20:37.080
你传的是一个空数组

20:37.080 --> 20:39.080
数组是空的

20:39.080 --> 20:40.080
那么什么叫空的

20:40.080 --> 20:41.080
就是它等于0

20:42.080 --> 20:43.080
如果说它等于0

20:44.080 --> 20:45.080
那么这种情况下

20:45.080 --> 20:46.080
你会发现这个Promise

20:46.080 --> 20:47.080
就永远完成不了了

20:47.080 --> 20:49.080
因为它进不了循环

20:49.080 --> 20:50.080
等于是吧

20:50.080 --> 20:52.080
不要说我这里传了一个空数组

20:54.080 --> 20:55.080
这种情况

20:56.080 --> 20:57.080
你发现这个Promise

20:57.080 --> 20:58.080
永远都成功不了

20:58.080 --> 20:59.080
永远都失败不了

20:59.080 --> 21:00.080
那么这种情况

21:00.080 --> 21:01.080
官方是怎么处理的呢

21:01.080 --> 21:02.080
你可以查看MDN稳当

21:02.080 --> 21:03.080
它的处理方式呢

21:03.080 --> 21:05.080
如果说你传的就是0

21:05.080 --> 21:07.080
直接转

21:07.080 --> 21:09.080
转过什么一个空数组

21:11.080 --> 21:12.080
直接转过一个空数组

21:12.080 --> 21:14.080
这是它的处理方式

21:15.080 --> 21:16.080
还有一种什么情况呢

21:16.080 --> 21:18.080
还有一种就是在整个执行过程中

21:18.080 --> 21:19.080
爆了错

21:19.080 --> 21:20.080
是爆错

21:20.080 --> 21:21.080
比方说你传了一个

21:21.080 --> 21:22.080
什么

21:22.080 --> 21:23.080
传了一个辣物进去

21:23.080 --> 21:25.080
那么这些都会导致爆错的

21:25.080 --> 21:26.080
它都不是一个迭代器

21:27.080 --> 21:28.080
那么像这种情况

21:28.080 --> 21:29.080
爆错的情况

21:29.080 --> 21:30.080
那么直接为这个车

21:30.080 --> 21:31.080
就觉得这个车

21:31.080 --> 21:32.080
就是错过的原因

21:32.080 --> 21:33.080
所以我们这里

21:33.080 --> 21:34.080
直接把它拆开启一下

21:37.160 --> 21:38.160
如果说爆了错

21:38.160 --> 21:39.160
爆了错怎么办呢

21:39.160 --> 21:40.160
就是为这个车

21:43.110 --> 21:44.110
给你说

21:45.110 --> 21:46.110
好我们来看一下

21:46.110 --> 21:47.110
运行

21:47.110 --> 21:48.110
失败

21:48.110 --> 21:51.490
这是错误的原因

21:51.490 --> 21:52.490
等等

21:52.490 --> 21:54.490
我这里还是要扛兽

21:54.490 --> 21:58.570
Aero一下

21:58.570 --> 21:59.570
OK 失败

22:01.570 --> 22:03.570
好那么这就是Promise

22:03.570 --> 22:04.570
OR的整个的实现

22:04.570 --> 22:05.570
代码解释不多

22:05.570 --> 22:06.570
你把个逻辑理讯就行了

22:06.570 --> 22:07.570
关键逻辑在哪呢

22:07.570 --> 22:08.570
关键逻辑

22:08.570 --> 22:10.570
就是你一定要有一个技术

22:10.570 --> 22:11.570
总数是多少

22:11.570 --> 22:12.570
以完成有多少

22:12.570 --> 22:13.570
不然的话你就不知道

22:13.570 --> 22:14.570
是不是已经是最后一个完成

22:14.570 --> 22:15.570
只有最后一个完成

22:15.570 --> 22:17.570
我才认为整个Promise完成

22:18.570 --> 22:19.570
还有一个关键点在哪呢

22:19.570 --> 22:21.570
就是它的排列顺序

22:21.570 --> 22:22.570
结果的排列顺序

22:22.570 --> 22:23.570
要跟这个

22:23.570 --> 22:24.570
叠带器里面的顺序

22:24.570 --> 22:25.570
要保持一致

22:25.570 --> 22:26.570
所以说我用

22:26.570 --> 22:27.570
在循环的时候用一个

22:27.570 --> 22:29.570
在循环题里边的

22:29.570 --> 22:30.570
变两i

22:30.570 --> 22:31.570
保证它的作用剧

22:31.570 --> 22:32.570
只作用于这个循环题

22:32.570 --> 22:34.570
每一次循环都是一个新的i

22:34.570 --> 22:35.570
让每一个Promise

22:35.570 --> 22:36.570
每一个Promise

22:36.570 --> 22:37.570
去对应到这个i

22:37.570 --> 22:38.570
这样子

22:38.570 --> 22:39.570
不管它什么时候完成

22:39.570 --> 22:41.570
那么它的i

22:41.570 --> 22:42.570
它都是对应到下标的值

22:42.570 --> 22:43.570
它不会变化

22:43.570 --> 22:45.570
把这两个关键点抓住

22:45.570 --> 22:47.570
这个代码就比较容易写出来了

22:47.570 --> 22:48.570
所以这是关于这个

22:48.570 --> 22:49.570
O的写法

