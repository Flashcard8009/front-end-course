WEBVTT

00:00.000 --> 00:03.580
来吧 重新聊一聊生命周期

00:05.120 --> 00:09.460
实际上我们以前说什么生命周期这些东西啊 都是指的是单个组件

00:09.720 --> 00:13.560
或者是无忧实力 什么叫无忧实力 就是六一个无忧

00:14.080 --> 00:16.900
组件我们知道是内部创建出来的 对吧

00:17.400 --> 00:18.940
实际上本质都是一样的

00:20.220 --> 00:23.300
那么我们平时都说的是单个 那如果说

00:23.800 --> 00:28.680
无忧实力里边用到了组件 组件里边又掏了组件 那么他们的生命周期又是什么样子呢

00:29.000 --> 00:32.000
我相信有些同学可能有这样的一个疑问

00:33.040 --> 00:38.660
其实这里对应到面试题 这个面试题就问你 又一个无忧之后发生了什么事情

00:39.180 --> 00:41.740
而数据变化之后呢 又发生了什么事情

00:42.240 --> 00:43.020
那么这是两个问题

00:43.520 --> 00:46.600
其实这两个问题要把回答清楚 还是不简单的

00:48.400 --> 00:55.560
这个问题其实你可以简单回答 也可以把它回答得更加详细一点 简单回答就是我们入门阶段学的这个图

00:55.780 --> 00:57.820
实力创建 然后经过了哪些过程

00:58.080 --> 01:02.680
然后数据改变过后 又经过了哪些过程 你把这些生命周期的触发给它回答清楚了

01:02.940 --> 01:03.960
也至少不会错

01:04.480 --> 01:09.580
但是呢 这样子要拿高分 或者是要拖隐而出 因为大家都知道这样子回答

01:09.840 --> 01:12.660
如果说你这样子回答的话 你很难拖隐而出

01:12.920 --> 01:14.460
所以说咱们就业家的课啊

01:14.720 --> 01:18.300
就还不仅仅是为了让你找到工作 找到工作其实太容易了

01:18.800 --> 01:20.860
而是希望大家能够拿一个高薪

01:21.620 --> 01:24.180
那么我们希望大家还是能够详细的回答一下

01:24.640 --> 01:27.720
再详细的回答 那就肯定要涉及到组建之间的关联

01:28.220 --> 01:33.300
其实咱们这结合啊 就是把之前我们学习的各种各样的乱七八糟的原理啊 什么编译啊

01:33.860 --> 01:38.980
啊 什么deaf啊 对吧 什么v-load啊 这东西 什么数据详细啊 其实把它创起来了

01:39.500 --> 01:42.420
看一下整个过程是什么样子 从一个权娱的角度来看

01:43.180 --> 01:46.460
好 首先我们来说六一个五幼之后 他做了什么事情

01:47.460 --> 01:52.900
好 首先他创建了一个五幼实力 其实创建五幼实力和组建的基本流程都是一样的

01:53.380 --> 01:58.060
他首先会做一些初始划操作 主要去设置一些什么私有属性啊 到实力中

01:58.700 --> 02:02.660
就是有一些以下划线开头的 就会到这里边去

02:04.020 --> 02:09.340
然后呢 当然还有一些多了开头的啊 然后呢 他会运行生命周期勾指函数 before create

02:09.700 --> 02:11.860
那么这个勾指函数还会运行的时间很早很早

02:12.700 --> 02:17.820
这个时候有啥呀 啥都没有 就啥都没有 这个时候你能做的事情 你也做不了什么事情

02:18.340 --> 02:19.540
连数据享用是都没有

02:20.540 --> 02:26.140
接下来我们继续看 进入第三步 那么这个时候他会进入注入流程 他会这里会处理属性

02:26.260 --> 02:30.740
因为他一如果说一个普通组建的话 他就会有属性 对吧 五幼实力是没有属性的

02:31.220 --> 02:35.580
就组建跟实力呢 还是有一点点差别啊 不过呢 我们可以把当成统一的东西再处理

02:37.220 --> 02:40.140
处理一些属性啊 属性的如果他会把它变成一个享用式

02:41.100 --> 02:48.820
还会 还有computed 还有什么masters data对吧 provide 迎接个成绩 这些东西都会在这个注入流程里面进行处理

02:49.820 --> 02:57.580
然后最终会使用代理模式 把他们挂在到实力里面 因为我们知道啊 像这个比方说一个data为例 也这个data呢 它是

02:57.860 --> 02:58.860
提到配置里面了 对吧

03:00.380 --> 03:07.780
这是我们的配置 配置里边有一个data 他可能是个函数 也可能直接是个对象 但组建里面呢 我们建议大家都使用函数

03:08.540 --> 03:15.460
如果说函数的话 他会调问这个函数 是不是得到一个对象 对吧 拿了个对象过后呢 我们之前也学过享用式 他会怎么样呢 他会用opso

03:16.900 --> 03:17.420
opso

03:19.620 --> 03:25.340
我们知道 留一个opso 对吧 来把这个对象传进去 来观察这个对象 是吧 还变成享用式了

03:25.740 --> 03:32.340
对吧 但是他只是把这个对象变成享用式 那我们要在无诱实力里面去访问怎么访问的 那就他就是用了一个代理模式

03:32.740 --> 03:38.740
他怎么来做的呢 他其实做的是方法 方法非常非常简单 比方这个响应式对象呢 他拿到一个的东西叫

03:39.740 --> 03:49.660
stats 是一个响应式对象 比方说啊 我觉得写个伟代码啊 我们的data等于什么呢 等于opso显示 它从配置里面去拿什么 调用这个data方法 什么拿到一个data 然后呢opso

03:51.220 --> 03:51.940
data 对吧

03:52.900 --> 03:58.940
现在呢 我们正在 这是一个构造函数里面啊 有一个优 这构造函数里面写个伟代码啊

03:59.700 --> 04:01.940
我们写还是在这里面写伟代码吧

04:06.200 --> 04:13.410
为了帮大家理清楚啊 就是比方说我们的构造函数无诱

04:14.330 --> 04:19.250
这构造函数里面要做好多好多事情 那么其中一件事情呢 就是拿到这个opsy

04:21.640 --> 04:27.280
这里存个参数进来对吧opsy 是里面不有data吗 它是不是调用那个data 拿到什么 拿到个data

04:27.880 --> 04:30.200
然后既然呢 它会调用一个函数啊 叫做opso

04:31.160 --> 04:35.880
函数 就是观察 就是我们之前讲过的数据想进式 把data传进去 就是把它变成想进式

04:37.240 --> 04:39.320
变成想进式数据

04:41.160 --> 04:46.280
那么它会变低规载进行处理 观察它的每一个属性啊 然后呢

04:47.200 --> 04:52.080
如果说还是对象的话 然后低规处理 然后数组的话 那么改变它的原型链 对吧 我们之前说过的

04:52.520 --> 04:58.600
那么如果说讲到这 你回答到这的时候面试官也想让你详细说一下 那你就进入到我们之前那个面试体

04:58.840 --> 05:00.960
就是想印式是怎么实现的

05:02.160 --> 05:10.240
好 变成了想印式数据过后 但是呢 我们这个实例里边没有啊 像我们那个数据啊 比方数据里边有一个a有一个b 那么我们通过这个a

05:10.600 --> 05:16.600
是通过this也能得到 他怎么通过this得到呢 他其实做了个非常非常简单的代理 他具体的做法呢 比方说

05:17.160 --> 05:19.560
他就这样做的这个伟大马啊 Define property

05:20.760 --> 05:21.080
this

05:22.160 --> 05:22.520
属向a

05:23.280 --> 05:26.080
当我们获取属向a的时候 拿到实际上是啥呀

05:27.080 --> 05:30.120
拿的 其实拿的就是data

05:30.760 --> 05:34.440
a 就这么简单啊 当然他是循环这个data里面所谓的属性啊

05:35.280 --> 05:38.640
不是地规啊 他这里不需要地规 他就是喜欢第一场就像了

05:39.560 --> 05:44.680
那么把他把这些属性挂到z里面去 那么当时我们从z里面读a的时候 是不是就读到那个

05:45.600 --> 05:51.040
相当于是读到data里面的a 对啊 做个非常简单的代理 当然我们是设置他的值的时候

05:51.440 --> 05:52.800
所以设置的是data里面的a

05:53.880 --> 06:00.480
就这么简单啊 做了个非常非常简单的代理 那么通过这种代理的方式呢 把个data里面的所有东西呢 升挂到实力里面去了

06:01.200 --> 06:02.680
那么他通过类似的做法啊

06:03.880 --> 06:09.800
他对computed也做类似的处理 对属性也做类似的处理 实际上他属性保存了哪儿呢 保存到一个私有属性

06:10.400 --> 06:11.520
叫做下滑线

06:12.320 --> 06:17.800
prox里面的 他是一个想象式对象 他里面的属性都是想象式的啊 他就放到这里面的

06:18.520 --> 06:24.480
然后呢 还是要把他把这个东西挂载到那个z 里面 对吧 没社子就更加简单了 没社子他就

06:25.720 --> 06:31.320
没社子的话他直接复制了 他就是 比方说有一个 他的同一个同一个op 形式里面得到没社子

06:32.600 --> 06:33.200
没社子

06:35.160 --> 06:35.680
op 形式

06:37.520 --> 06:42.600
所以没社子一个配置 对吧 拿到这个 拿到这个配置 然后干嘛呀 循环

06:43.160 --> 06:50.400
所以每一式循环 循环他的所有的属性啊 循环他的所有的属性啊 我们就可以用objects啊

06:51.000 --> 06:56.040
kiss啊 或者是entress啊 这些东西啊 总之呢 拿到他每一个没社子 所以一个属性名

06:58.920 --> 07:04.280
没社子 拿了一个属性名啊 然后呢 有一个属性值对吧 我们再要复一起

07:06.810 --> 07:08.210
有一个属 有一个属性名

07:09.010 --> 07:13.370
master name 一个是方形 对吧

07:15.570 --> 07:22.370
然后拿到每一个 每一个就是方法的名字和方法的函数 我们要做的事情呢 就是把它定义到z里面去啊

07:22.730 --> 07:28.410
z的方法名啊 等于什么呢 等于他的函数 函数还会绑定一个啊band

07:28.730 --> 07:32.890
这次 保证了 所以说我们为什么在方 在个方法里边

07:33.370 --> 07:38.890
那个函数里边 这是始终指向的是无忧的实力 就这个原因啊 他用那band方式来绑定的

07:39.690 --> 07:42.650
基本上就这样做的 其实非常简单 并不复杂

07:44.170 --> 07:48.090
好 总之把这些东西 他的目标就是把这些东西全部放到这个实力里面去

07:48.410 --> 07:55.530
来注入这个流程 就是我们之前入名言論也曾经说过 对吧 好 那么这件事情做完了过后呢 它会运行一个生命周期勾字函数 还是比较crity的

07:55.690 --> 08:01.450
所以在crity里面呢 我们已经可以拿到各种各样的详细数据了 也可以在实力里面 无忧实力里面 拿到各种方法呀

08:02.170 --> 08:04.490
computed呀 就是计算属性啊这些东西都可以拿到了

08:05.610 --> 08:08.330
所以crity的呃函数我们经常用 这里呢可以做一些

08:09.530 --> 08:12.490
比方说一部处理啊 一些前置的前置的事情

08:13.770 --> 08:18.010
但是呢 这里是不能获取到真实动物元素的 为什么呢 因为他现在还没有渲染

08:19.050 --> 08:23.450
好 那么接下来要进入渲染流程了 渲染流程的他首先要做的一件事情就是编译

08:24.170 --> 08:32.170
因为像我们用56crity来创建的工程啊 他里边你这件事情是不要中 不用做的 因为他从模办里边 单文件组件里边直接就给你生成

08:32.250 --> 08:34.250
Render函数了 但是如果说你没有

08:34.890 --> 08:38.490
Render函数 那么他就要从模办里边去找了 就是我们最早的时候啊

08:39.210 --> 08:45.850
通过在页面上直接引用View的时候 那么这个时候我们模办是一起了一个字不错里面的 对吧 他需要通过运行时编译 这是讲过的啊

08:46.490 --> 08:49.770
那么把模办编译成Render 就是这一步他一定要拿到Render函数

08:50.410 --> 08:51.770
拿到了Render函数过后

08:52.010 --> 08:55.050
他会运行一个生命周期构置函数的before mount

08:55.850 --> 09:00.490
运行这个生命周期构置函数 好 运行完了过后就是你自己配置了啊

09:01.050 --> 09:04.570
然后接下来他会做渲染流程了 这件事情比较复杂

09:05.050 --> 09:08.090
就是我们之前讲的啊 如何来生成vload

09:08.410 --> 09:12.250
如何来进行dev 都是在这个流程里面说的 他会创建一个watcher

09:13.530 --> 09:17.130
之前我们刚刚写过这个伟带码 对吧 伟带码打写的

09:17.850 --> 09:22.730
是吧 生成一个update component这个函数 这个函数要做的事情特别简单

09:22.730 --> 09:27.850
就是this update 然后呢 this render 对吧 他会调用Render

09:27.850 --> 09:30.650
然后把Render争取间放到这个update里面

09:30.650 --> 09:33.210
然后把这个update component函数呢放到watcher里面

09:33.210 --> 09:35.770
因为我们知道有了个watcher过后他就变成详硬式了

09:36.330 --> 09:38.090
就是这个函数的运行期间

09:38.650 --> 09:41.450
这个函数里面要做很多事情啊 你别看这有运行代码

09:41.450 --> 09:44.010
在这里边做的事情很多 这里边做的事情也很多

09:44.250 --> 09:46.010
就是他从模办编译都来的

09:46.970 --> 09:50.730
那么无论怎么样嘛 他生成 他是运行期间

09:50.730 --> 09:53.930
无论掏了多少层 函数里面调函数都无所谓

09:53.930 --> 09:56.090
只要你运行期间用到了详硬式数据

09:56.810 --> 10:00.090
都会寄赖 有一个watcher 他用到了我

10:00.090 --> 10:01.290
这个watcher他用到了我

10:02.010 --> 10:02.730
明白这个意思吧

10:02.730 --> 10:05.610
说当那个详硬式数据变化过后 他会重新运行这个watcher

10:06.170 --> 10:09.610
然后重新运行这个watcher 他就间接了重新运行的这个函数

10:09.610 --> 10:10.490
就这么个意思

10:10.490 --> 10:11.770
说这一步怎么回答呢

10:11.770 --> 10:12.970
他会创建一个watcher

10:13.450 --> 10:15.770
传入一个函数 叫做updatecomponent

10:15.770 --> 10:16.570
传入一个函数

10:17.610 --> 10:19.770
然后函函数呢会运行render

10:19.770 --> 10:22.330
你看函函数运行render得到一个蓄力节点

10:23.290 --> 10:24.730
那么其实就是个蓄力动母数

10:24.730 --> 10:26.010
当然是当前这个组建的

10:26.890 --> 10:29.690
再把得到了vload 传到update函数里边去执行

10:30.810 --> 10:31.930
传到这里边去执行

10:33.130 --> 10:35.370
在执行render函数的过程中啊

10:35.370 --> 10:36.810
他会收集所有的依赖

10:37.690 --> 10:42.250
将来依赖变化时会重新运行updatecomponent函数

10:43.050 --> 10:43.530
啥意思

10:44.890 --> 10:47.290
就是我们之前讲过的 响应是原理的一块

10:47.770 --> 10:49.370
当我们render函数的运行过程中

10:49.370 --> 10:52.170
是不是会用到一些数据啊 用到一些属性啊

10:52.170 --> 10:53.530
对吧 这些都是依赖

10:53.530 --> 10:55.050
那么这些依赖变化的时候呢

10:55.610 --> 10:57.210
他知道有一个watcher来观察他

10:57.210 --> 10:58.730
那么他就会重新运行这个watcher

10:58.730 --> 10:59.610
就这么个意思

11:00.410 --> 11:02.330
好那么又进入update函数的执行过程

11:02.810 --> 11:05.050
update函数呢他接受一个参数就是vload

11:05.530 --> 11:07.050
就是这个数的根节点

11:08.330 --> 11:10.330
那么他会去对比 看一下有没有旧数

11:10.890 --> 11:12.330
他里边会触发那个派起函数

11:12.650 --> 11:14.650
发现还是会发现 目前没有旧数

11:14.650 --> 11:16.250
没有旧数就很非常简单

11:16.250 --> 11:17.930
直接为当前的虚拟动作数

11:17.930 --> 11:21.450
每一个普通节点生成am属性

11:21.450 --> 11:23.050
对吧 真实的aliment属性

11:23.050 --> 11:23.930
那么即真实动作

11:23.930 --> 11:25.610
为每一个虚拟节点生成一个真实动作

11:26.250 --> 11:27.850
而且把个真实动作的挂载到一面上

11:27.850 --> 11:29.130
那就显示出来了

11:30.090 --> 11:31.930
那么这个过程中呢有可能会遇到

11:32.890 --> 11:35.850
创建的不是一个普通的节点

11:35.850 --> 11:38.250
是一个组建的vload

11:38.490 --> 11:41.050
那么这个时候就会进入组建的实力化流程

11:42.010 --> 11:43.610
那么组建的实力化流程跟这个流程

11:43.610 --> 11:45.050
就是相当于是地规在做这个事

11:45.610 --> 11:47.050
那么各个流程基本上很相同

11:48.090 --> 11:50.090
那么它最终会把这个组建的东西

11:50.090 --> 11:51.450
挂得到vload的components

11:51.450 --> 11:53.050
instance属性里边一边服用

11:53.690 --> 11:54.890
这件事情做完了过后

11:54.890 --> 11:56.890
其实页面上就已经能看到东西了

11:56.890 --> 11:58.650
好 看到了东西了过后再运行

11:58.650 --> 12:00.090
这边都是跟勾指寒是mounty的

12:00.090 --> 12:01.290
所以在mounty里边呢

12:01.290 --> 12:02.810
你就可以得拿到很多东西了

12:02.810 --> 12:05.690
就可以拿到通过rave的东西啊

12:05.690 --> 12:09.050
还有通过rave也是在这一步完成的

12:09.530 --> 12:11.770
所以说在mounty里边可以拿到通过rave的东西啊

12:11.770 --> 12:13.930
还有就是真实的东西都可以拿到了

12:14.730 --> 12:16.730
这是第一个啊创新建的时候

12:16.730 --> 12:17.450
他们的流程

12:17.450 --> 12:18.650
那么这里呢我有一个例子啊

12:18.650 --> 12:20.170
给大家详细的解释一下

12:20.810 --> 12:22.250
这个例子呢非常简单

12:22.250 --> 12:24.010
就是我这个MediaJS里边

12:24.010 --> 12:26.250
你看Made有写了很多的生命中心函数

12:26.250 --> 12:26.570
对吧

12:27.690 --> 12:29.290
因为这也是一个无忧实力嘛

12:29.290 --> 12:29.690
对吧

12:29.690 --> 12:31.290
跟组建的本质呢其实差不多的

12:31.770 --> 12:32.490
生命中心函数

12:32.490 --> 12:33.290
然后他做的事情呢

12:33.290 --> 12:34.330
他就直接写的Render

12:34.330 --> 12:35.610
他选择了一个虚的节点

12:35.610 --> 12:36.810
对虚的节点是一个组建

12:37.290 --> 12:38.410
好那么个组建里边呢

12:38.490 --> 12:39.370
也非常简单啊

12:40.250 --> 12:42.090
也写了很多的生命中心函数

12:43.050 --> 12:44.890
我这里呢做了一点点东西啊

12:44.890 --> 12:45.530
有两个属性

12:45.530 --> 12:46.650
一个是虚一个是抗腿

12:46.650 --> 12:47.450
抗的就是一个数字

12:48.410 --> 12:49.290
用了了组建A

12:50.170 --> 12:51.210
那么一个A器啊

12:51.210 --> 12:52.410
这个部分没什么好说的

12:52.410 --> 12:54.570
A呢他要不要显示呢取决于这个虚

12:55.530 --> 12:56.570
为虚的时候就显示

12:57.210 --> 12:58.170
为forced的时候就不显示

12:58.170 --> 12:59.130
然后把靠着传给他

12:59.690 --> 13:02.090
这里一个按钮的点击过后增加这个靠子

13:02.090 --> 13:03.690
这里呢一个按钮的点击过后呢

13:03.690 --> 13:04.730
切换这个显示方式

13:04.730 --> 13:06.650
那么这个东西是我一会要演示的

13:06.650 --> 13:07.770
现在可以暂子不管它

13:08.650 --> 13:10.970
然后B呢A里面其实很简单

13:10.970 --> 13:12.250
A里面就显示一个东西

13:12.250 --> 13:13.210
把靠着显示出来

13:13.210 --> 13:14.250
然后把它靠成来传给B

13:15.050 --> 13:16.010
A里面有生命中心

13:16.010 --> 13:17.370
勾字函数每个都注册的

13:17.370 --> 13:18.890
以后我们可以观察一下

13:18.890 --> 13:19.530
然后B呢

13:20.090 --> 13:21.530
非常简单就显示出来就完事了

13:21.530 --> 13:22.570
靠着显示出来就完事了

13:23.930 --> 13:25.530
那么我们把它化成一个组建数的话

13:25.530 --> 13:26.170
就这个样子

13:26.810 --> 13:28.250
5u实例里边有什么呢

13:28.250 --> 13:30.090
有那个APP

13:30.970 --> 13:32.570
APP里边组建数啊

13:33.370 --> 13:34.650
不是虚的纪念数啊

13:34.650 --> 13:35.930
APP里边有什么有A

13:36.410 --> 13:37.690
A里边有什么有B

13:39.050 --> 13:40.410
是不是形成这样的一个组建数

13:40.410 --> 13:42.170
APP里边传了一个属性

13:42.170 --> 13:43.050
靠着给A

13:43.050 --> 13:44.570
A有把个属性的传给B

13:44.570 --> 13:45.850
就变成这样子了

13:45.850 --> 13:47.930
好 那我们来看一下整个它的流程

13:47.930 --> 13:49.210
来帮助大家理解

13:49.210 --> 13:50.650
首先我们6一个5u的时候

13:52.410 --> 13:53.210
6一个5u的时候

13:53.210 --> 13:54.250
是不是创建那个5u实例

13:54.250 --> 13:55.130
对吧 这是一个对象

13:55.130 --> 13:55.850
这边是个对象

13:56.730 --> 13:58.170
就通过勾字函数创建出来的

13:58.730 --> 14:00.090
其实你可以把组建的

14:00.090 --> 14:02.250
也象成小象成勾字函数创建出来的

14:02.890 --> 14:04.250
好 那我们有个实例的

14:04.250 --> 14:04.730
对吧

14:04.730 --> 14:05.770
那么这个实例里边

14:07.050 --> 14:07.930
这个实例里边

14:08.650 --> 14:09.690
是不是要开始运行

14:09.690 --> 14:10.970
什么都去勾字函数了

14:10.970 --> 14:11.850
先运行啥

14:11.850 --> 14:13.130
先运行before

14:13.930 --> 14:15.130
这是5u实例的

14:15.130 --> 14:15.850
5u实例

14:17.530 --> 14:18.330
before crazy

14:19.530 --> 14:21.370
然后再运行5u实例的

14:22.330 --> 14:23.450
5u实例的

14:23.450 --> 14:25.290
然后是crazy

14:25.290 --> 14:25.850
crazy的

14:26.650 --> 14:26.890
对吧

14:26.890 --> 14:28.250
现在有响应识数据了

14:28.250 --> 14:29.690
然后再运行5u实例的

14:30.810 --> 14:32.810
before mounted

14:33.850 --> 14:35.450
好 接下来该干嘛了

14:35.450 --> 14:36.490
你看看我们刚才的流程

14:38.490 --> 14:39.610
before mounted什么时候运行的

14:39.610 --> 14:40.650
是不是Render函数有了

14:40.650 --> 14:41.690
过后就开始运行

14:41.690 --> 14:43.610
然后接下来进入update component了

14:44.170 --> 14:45.530
就是更新组建了

14:45.530 --> 14:47.450
实体其实本质上也是个组建

14:47.450 --> 14:48.810
我们更新组建了

14:49.370 --> 14:50.810
好 那么更新组建的时候

14:51.450 --> 14:52.010
你看

14:53.130 --> 14:54.570
更新组建的时候

14:54.570 --> 14:55.290
它会怎么样呢

14:56.090 --> 14:58.170
它会运行它的Render函数

14:58.170 --> 14:58.650
对吧

14:58.650 --> 14:59.610
生成蓄力节链

15:00.650 --> 15:01.530
运行Render函数

15:02.570 --> 15:03.290
Render函数

15:03.290 --> 15:04.810
Render函数得到什么一个蓄力节链

15:04.810 --> 15:05.690
是不是就是一个APP

15:05.690 --> 15:06.010
对吧

15:06.010 --> 15:07.450
生成一个蓄力节�APP

15:07.530 --> 15:08.650
这个是个组建配置对象

15:09.210 --> 15:10.330
这个非常非常普通的

15:10.330 --> 15:11.050
就是这么一个东西

15:12.330 --> 15:13.050
就这么一个东西

15:13.050 --> 15:14.010
就是组建配置对象

15:14.010 --> 15:15.050
它不是组建实力

15:15.050 --> 15:15.850
它是个配置

15:16.650 --> 15:17.290
然后呢

15:17.290 --> 15:18.330
根据这个配置对象来

15:18.810 --> 15:20.010
创建一个蓄力节点

15:20.010 --> 15:21.210
主要不是组建实力

15:21.690 --> 15:23.290
创建了蓄力节点

15:24.010 --> 15:24.810
这是个蓄力节点

15:24.810 --> 15:26.010
我们用蓝色来表示

15:26.010 --> 15:27.290
它是个蓄力节点vendor的

15:29.530 --> 15:30.570
那么而现在

15:30.570 --> 15:31.770
它有可能会向这个组建

15:31.770 --> 15:32.730
传入一些属性

15:32.730 --> 15:34.010
当然我这里没有传

15:34.010 --> 15:35.130
它可以向它传入属性

15:35.130 --> 15:36.010
当然可以

15:36.090 --> 15:36.570
于是呢

15:36.570 --> 15:38.810
它vload里面有个component options

15:39.530 --> 15:40.250
有个这个东西

15:41.050 --> 15:42.890
其实我们可以看到非常清楚

15:42.890 --> 15:43.530
我们在这里

15:44.250 --> 15:45.690
就在multi的里面吧

15:46.250 --> 15:46.970
输出一个this

15:49.130 --> 15:49.770
输出个this

15:49.770 --> 15:50.650
就是维幼实力

15:51.050 --> 15:52.010
我们来看一下一面上

15:53.450 --> 15:54.410
看一下它的组建

15:54.410 --> 15:55.370
组建结构就知道了

15:56.490 --> 15:57.210
其他都不用管

15:57.210 --> 15:58.090
我们就看一下这里

15:58.090 --> 15:58.410
是吧

15:58.410 --> 15:59.290
multi的一个维幼实力

15:59.770 --> 16:01.050
这个维幼实力里边你看

16:01.450 --> 16:02.170
它的vload

16:03.690 --> 16:04.170
是吧

16:04.170 --> 16:05.770
这个东西才是那个

16:06.170 --> 16:06.570
vload

16:06.570 --> 16:07.610
它不是组建实力

16:07.610 --> 16:08.250
是vload

16:08.250 --> 16:10.490
vload里边有个什么component options

16:10.890 --> 16:11.450
啥意思

16:11.450 --> 16:12.810
是我向这个组建

16:12.810 --> 16:13.690
用这个组建的时候

16:13.690 --> 16:14.730
传入了一些属性

16:15.290 --> 16:16.090
传入了一些

16:16.090 --> 16:16.890
例如Listeners

16:16.890 --> 16:17.770
传入了一些什么

16:18.890 --> 16:19.610
监听函数

16:19.610 --> 16:20.010
对吧

16:20.010 --> 16:20.970
事件组成的监听函数

16:20.970 --> 16:21.610
等等

16:21.610 --> 16:22.970
那么这些东西是传进去了

16:23.530 --> 16:23.930
对不对

16:24.330 --> 16:24.810
而于是呢

16:24.810 --> 16:25.370
也就是说

16:25.370 --> 16:26.010
什么意思呢

16:26.010 --> 16:27.770
它会给它一个component options

16:27.770 --> 16:28.810
表示我向这个组建

16:28.810 --> 16:29.690
用这个组建的时候

16:30.490 --> 16:31.370
这是个蓄力节点

16:31.370 --> 16:32.090
用这个组建的时候

16:32.090 --> 16:33.290
传入了一些配置

16:35.390 --> 16:35.950
没问题吧

16:36.910 --> 16:37.150
好

16:37.150 --> 16:37.870
没问题

16:37.870 --> 16:38.830
然后呢

16:38.830 --> 16:40.350
现在进入派起一开对比

16:40.350 --> 16:40.830
对吧

16:40.830 --> 16:42.430
这是我们目前深深的蓄力节点

16:42.430 --> 16:43.150
就一个

16:43.150 --> 16:43.790
App

16:43.790 --> 16:44.590
但是一对比的话

16:44.590 --> 16:45.310
没有就

16:45.310 --> 16:46.830
是不是没有一个旧的数

16:46.830 --> 16:48.270
没有旧的数怎么办

16:48.270 --> 16:49.630
那我是不是要新建

16:49.630 --> 16:51.630
我们之前知道真实动物的新建

16:51.630 --> 16:52.110
非常简单

16:52.670 --> 16:53.230
bocuments

16:53.230 --> 16:54.670
create elements就完事了

16:54.670 --> 16:56.190
但是组建的新建它会怎么样呢

16:56.750 --> 16:57.070
它会

16:57.790 --> 16:58.750
通过构造函数

16:58.750 --> 16:59.710
再去溜一个

16:59.710 --> 17:00.830
把这个配置对象传进去

17:00.830 --> 17:01.550
相当于是这样子

17:03.310 --> 17:04.030
相当于是这样子

17:04.030 --> 17:04.670
遇到组建的时候

17:04.750 --> 17:05.870
它又会溜一个vue

17:06.830 --> 17:08.110
把这个组建的

17:08.110 --> 17:10.830
就是把那个vload的components

17:11.390 --> 17:12.430
options传进去

17:16.380 --> 17:17.340
相当于是这样子

17:17.340 --> 17:18.140
据的远吧

17:18.140 --> 17:18.540
又说不通

17:19.180 --> 17:21.180
把这个vload的components传进去

17:21.180 --> 17:22.300
是不是创建了一个什么

17:24.220 --> 17:24.540
App

17:25.340 --> 17:25.980
创建个App

17:26.460 --> 17:26.780
然后呢

17:26.780 --> 17:28.300
它会收到这个关系

17:28.300 --> 17:29.820
它里边的q准里边

17:29.820 --> 17:31.900
它的组建数里边q准里边一个App

17:31.900 --> 17:33.580
你看每一个组建它都有一个q准

17:36.890 --> 17:37.530
你看q准

17:37.610 --> 17:39.370
这个q准不是说趋利节点的

17:39.770 --> 17:40.970
它指的是组建数里边

17:40.970 --> 17:42.010
它有哪些直组件

17:42.570 --> 17:43.450
它有一个直组件

17:43.450 --> 17:44.010
vue

17:44.010 --> 17:44.570
它们认识

17:44.570 --> 17:45.450
这是App组建

17:46.410 --> 17:47.610
那么设置好关系

17:48.490 --> 17:50.090
它里边有什么一个东西

17:51.130 --> 17:51.610
好

17:51.610 --> 17:52.090
然后呢

17:52.090 --> 17:53.530
会到像这个vload里边

17:53.530 --> 17:54.250
添加一个属性

17:54.250 --> 17:55.610
叫做components instance

17:56.810 --> 17:57.770
或者组建实力

17:58.170 --> 17:59.930
那么这个组建实力实际上就指向它

18:00.810 --> 18:01.370
没了意思吧

18:01.370 --> 18:02.570
这个就指向它

18:03.290 --> 18:04.330
这个组建实力

18:04.810 --> 18:06.250
这个实力是可以重复使用的

18:06.250 --> 18:07.290
放到vload里边去了

18:08.250 --> 18:08.810
好那一看

18:08.810 --> 18:10.570
我们现在的生命周期是不是运行到这个

18:10.570 --> 18:12.170
但是现在运行盟体的

18:12.170 --> 18:13.210
还没完啊

18:13.210 --> 18:13.770
还没完

18:13.770 --> 18:14.730
这是个低规的过程

18:15.290 --> 18:17.050
它去创建区地节点

18:17.050 --> 18:17.930
发现它了

18:17.930 --> 18:19.290
然后经过拍起算法

18:19.290 --> 18:20.730
发现没有旧数

18:20.730 --> 18:22.090
没有旧数我就新建一个实力

18:22.090 --> 18:22.970
是不是新建了一个实力

18:23.450 --> 18:23.850
对吧

18:23.850 --> 18:25.450
那这也就是说它的这个

18:26.090 --> 18:27.530
它的这个函数还没有完啊

18:28.330 --> 18:28.970
它的这个就是

18:29.610 --> 18:30.970
App.components这个函数

18:31.610 --> 18:32.490
还没有完

18:32.490 --> 18:33.690
所以它还得继续

18:33.690 --> 18:34.970
因为它是个低规的过程

18:34.970 --> 18:36.410
于是它是不是被创建了

18:36.490 --> 18:39.130
它重点是它就会运行App组建的

18:39.130 --> 18:39.850
什么

18:39.850 --> 18:40.410
before

18:41.450 --> 18:41.850
create

18:42.410 --> 18:44.010
也会运行App组建的

18:44.570 --> 18:44.970
create

18:46.490 --> 18:47.930
也会运行App组建的

18:48.490 --> 18:48.890
before

18:49.290 --> 18:49.690
盟体的

18:49.690 --> 18:51.130
好那么现在App组建的Render

18:51.130 --> 18:51.930
函数已经出来了

18:52.570 --> 18:52.890
对吧

18:52.890 --> 18:53.530
已经出来了

18:53.530 --> 18:54.330
出来了过后了

18:54.330 --> 18:54.970
接下来干嘛

18:55.450 --> 18:56.730
接下来是不是要生成

18:56.730 --> 18:58.650
App组建的虚拟动物数

18:58.650 --> 18:59.530
那么生成呗

18:59.530 --> 19:00.650
它目前的虚拟动物数呢

19:01.450 --> 19:02.330
我看一下

19:02.330 --> 19:03.290
App组建的虚拟动物数

19:03.290 --> 19:04.490
然后这些东西我就不看了

19:04.490 --> 19:05.210
就列过了

19:05.290 --> 19:06.810
那么它有没有一个A起一个A

19:06.810 --> 19:07.050
对吧

19:07.050 --> 19:08.410
A一开始是显示的

19:08.410 --> 19:08.890
于是呢

19:09.770 --> 19:11.370
是不是生成一个虚拟动物数了

19:11.370 --> 19:13.450
好那么接下来它是不是要对比旧数

19:13.450 --> 19:14.490
旧数里边有东西吗

19:14.490 --> 19:15.450
没东西

19:15.450 --> 19:16.570
创建动物元素

19:17.210 --> 19:18.810
放到这个虚拟节点里边

19:18.810 --> 19:19.050
对吧

19:19.050 --> 19:19.930
一个A我们属性

19:19.930 --> 19:20.090
对吧

19:20.090 --> 19:21.210
A你们属性

19:21.210 --> 19:22.810
创建动物元素生成出来

19:23.450 --> 19:24.410
好那么这个时候

19:24.410 --> 19:24.970
其实页面上

19:25.530 --> 19:27.370
如果说这里代码可以停止的话

19:28.490 --> 19:29.370
就是页面上还没有

19:29.370 --> 19:31.850
页面上最终才会挂载上去

19:31.850 --> 19:32.490
不过没关系

19:32.490 --> 19:34.250
它实际上动物元素已经创出来了

19:34.410 --> 19:35.450
但是又遇到一个A

19:35.450 --> 19:35.930
看没

19:35.930 --> 19:37.290
在App组件里面是一个A

19:37.290 --> 19:38.250
这是一个植株键

19:39.450 --> 19:40.730
于是遇到了植株键了

19:41.530 --> 19:43.050
刚才没有实力还没完

19:43.050 --> 19:44.810
它等待这个东西创建好

19:44.810 --> 19:45.610
那么这个东西

19:45.610 --> 19:47.690
创建就运行的过程中又遇到A

19:47.690 --> 19:48.570
它是要创建A

19:49.930 --> 19:50.250
对吧

19:51.530 --> 19:52.090
要创建A

19:52.730 --> 19:55.450
那么创建A的过程跟创建App的过程

19:55.450 --> 19:56.570
实际上是一样的

19:56.570 --> 19:57.610
同样的这个A

19:57.610 --> 19:58.570
也有两个属性

19:58.970 --> 19:59.770
也有这两个属性

20:00.810 --> 20:01.770
那么创建一个A

20:01.770 --> 20:02.570
这是虚拟节点

20:03.210 --> 20:04.170
这是普通的虚拟节点

20:04.170 --> 20:05.210
这是组建的虚拟节点

20:05.210 --> 20:06.410
这边是实力

20:06.410 --> 20:07.610
组建实力

20:07.610 --> 20:08.890
通过D5又创建出来了

20:09.690 --> 20:10.570
那么创建个A

20:11.210 --> 20:12.330
那么创建A的过程中

20:12.330 --> 20:13.690
A是不是又要来一次

20:14.250 --> 20:15.370
是不是又要来一次

20:15.370 --> 20:16.010
看一下A

20:17.210 --> 20:21.130
现在又运行A的BeforeCreated

20:21.130 --> 20:23.210
然后又运行A的Created

20:23.210 --> 20:26.170
又运行A的BeforeMounted

20:26.170 --> 20:26.810
明白了意思吧

20:27.610 --> 20:28.810
然后A里边

20:29.530 --> 20:32.570
刚刚他刚传遞了一个一些属性

20:32.570 --> 20:34.170
往A里边传的一些属性比较Cut

20:34.730 --> 20:35.930
那么都放到这里边的

20:36.570 --> 20:37.690
而且我们创建A的过程中

20:37.690 --> 20:39.210
是不是把属性变成响应似的

20:39.210 --> 20:40.090
属性变化了

20:40.090 --> 20:41.210
它里边又要重新选择

20:41.770 --> 20:42.010
好

20:42.010 --> 20:42.650
比方说吧

20:43.450 --> 20:44.090
那么现在呢

20:44.090 --> 20:44.410
我们

20:45.530 --> 20:46.970
创建的A又是什么呢

20:46.970 --> 20:49.130
A又是一个DIV H1又有一个B

20:49.130 --> 20:49.930
那么也就是说

20:49.930 --> 20:50.810
A是这个样子的

20:53.050 --> 20:54.890
DIV H1一个B

20:54.890 --> 20:55.370
对吧

20:55.370 --> 20:57.290
那么这些东西是不是由于没有救数

20:57.290 --> 21:00.090
所以说创了相应的真实动物

21:00.090 --> 21:00.970
然后遇到一个B

21:00.970 --> 21:01.690
B怎么办呢

21:01.690 --> 21:02.970
又去创建一个B的实力

21:04.250 --> 21:05.450
那么这个东西会指向B

21:07.770 --> 21:08.890
这是一个帝规的过程

21:11.450 --> 21:12.730
于是又运行了什么

21:12.730 --> 21:14.890
B的BeforeCreated

21:15.450 --> 21:17.530
又运行了B的Created

21:17.530 --> 21:20.730
又运行了B的BeforeMounted

21:21.370 --> 21:22.010
对吧

21:22.010 --> 21:22.970
那么B的结构

21:22.970 --> 21:24.090
我们看一下B的结构

21:24.090 --> 21:25.210
B的结构非常简单

21:25.210 --> 21:26.730
有个当然往B里边传的一个属性

21:26.730 --> 21:28.250
又是只有一个DIV H1

21:28.250 --> 21:29.370
当然里边的稳定节点

21:29.450 --> 21:30.410
其实也是一个节点

21:31.210 --> 21:32.250
我这里没画出来了

21:32.250 --> 21:33.370
为了简单

21:33.370 --> 21:35.050
那么B里边就比较简单一点了

21:36.250 --> 21:37.050
当然B里边

21:37.050 --> 21:39.210
它里边一个V兜的属性

21:39.210 --> 21:40.250
这些都有一个V兜的属性

21:40.250 --> 21:41.130
只向它的根节点

21:41.770 --> 21:42.490
这样的意思吧

21:42.490 --> 21:43.610
这就是为什么要单根

21:43.610 --> 21:44.970
多分就搞不定这件事情

21:45.770 --> 21:48.650
你看DIV H1就变成这样子了

21:49.210 --> 21:51.130
那么B终于是把B创建完了

21:51.930 --> 21:52.730
B创建完了

21:53.210 --> 21:54.410
B创建完了过后

21:54.410 --> 21:56.090
那么就是运行了B的Mounted

21:57.130 --> 21:58.250
B的Mounted运行完了

21:58.330 --> 21:59.850
所以这一块终于完了

21:59.850 --> 22:01.530
A又回到A了

22:01.530 --> 22:03.130
发现终于完了

22:03.130 --> 22:04.170
那我这边也完了

22:04.170 --> 22:06.730
那么又运行A的Mounted

22:07.690 --> 22:08.970
好A里边完了过后

22:08.970 --> 22:10.090
又回到App了

22:10.090 --> 22:11.050
App过后

22:11.050 --> 22:12.410
看一下A用完了

22:12.410 --> 22:13.450
看一下还没有其他节点

22:13.450 --> 22:14.330
都没有其他节点

22:14.330 --> 22:15.130
当然如果说有的话

22:15.130 --> 22:15.850
还要继续创建

22:16.570 --> 22:17.770
比方它还要用到别的主节

22:17.770 --> 22:19.370
又要深度去创建

22:19.370 --> 22:20.170
低过去创建

22:20.170 --> 22:20.970
但是没了

22:20.970 --> 22:24.890
所以说运行App的Mounted

22:24.890 --> 22:26.250
然后又回到这个V有实力

22:26.250 --> 22:27.530
又运行V有实力的

22:29.210 --> 22:29.850
忘记了

22:29.850 --> 22:30.890
它就是这么一个过程

22:30.890 --> 22:32.490
那么完成整个

22:32.490 --> 22:33.930
每一个组件

22:33.930 --> 22:35.850
以此来创建它的虚拟动作数

22:35.850 --> 22:37.210
于是我们看到这个生命周期

22:37.850 --> 22:38.890
连起来就是这样子

22:38.890 --> 22:39.610
你看吧

22:39.610 --> 22:40.250
V有实力

22:40.890 --> 22:42.090
然后App

22:42.890 --> 22:43.530
然后A

22:44.410 --> 22:45.690
这到B before Mounted

22:46.250 --> 22:47.130
就等着了

22:47.130 --> 22:48.330
然后要D归创建

22:48.330 --> 22:48.730
B

22:48.730 --> 22:50.010
好把B终于创建完了

22:50.010 --> 22:50.890
然后又回到A

22:50.890 --> 22:51.450
又回到App

22:51.450 --> 22:52.170
又回到V有实力

22:52.970 --> 22:53.210
对吧

22:53.210 --> 22:54.250
这是最开始的情况

22:55.050 --> 22:55.690
没了意思吧

22:57.960 --> 22:59.000
好

22:59.000 --> 23:00.920
今天我们看后边的重新渲染

23:00.920 --> 23:02.120
就是什么时候重新渲染

23:02.120 --> 23:03.720
就是它一带的东西变了

23:03.720 --> 23:04.440
最常见的就是什么

23:04.440 --> 23:05.160
改变data

23:05.160 --> 23:06.600
有一时候它说要改变属性

23:06.600 --> 23:07.720
那改变属性是怎么来的

23:07.720 --> 23:09.240
还不是通过改变data来的

23:09.240 --> 23:09.800
对吧

23:09.800 --> 23:11.000
你把data作为一个属性

23:11.000 --> 23:11.800
传到传进去了

23:11.800 --> 23:12.760
通过改变data

23:12.760 --> 23:14.760
改变数据

23:14.760 --> 23:16.440
然后呢导致了它的属性

23:16.440 --> 23:17.480
重新被传递

23:17.480 --> 23:19.640
最终还是会落实到改变data

23:19.640 --> 23:21.080
重新来

23:21.080 --> 23:22.360
那么就会就是我们

23:22.360 --> 23:23.880
改变数据过后又发生什么

23:23.880 --> 23:25.880
就是进入重新来的流程

23:26.760 --> 23:27.720
怎么重新来的

23:27.720 --> 23:29.240
因为我们之前在确认的时候

23:29.240 --> 23:30.120
是不是运行那个函数

23:30.120 --> 23:30.840
非常重要的函数

23:30.840 --> 23:32.600
就updates component函数

23:32.600 --> 23:33.560
这个函数呢就是

23:34.440 --> 23:35.720
它会放到watcher里边

23:35.720 --> 23:37.400
所以说这个函数的运行期间

23:37.400 --> 23:38.600
反而是用到的数据

23:38.600 --> 23:39.400
只要有变化

23:39.400 --> 23:41.400
它都会通知这个watcher重新运行

23:41.400 --> 23:42.200
它会自动完成的

23:42.200 --> 23:42.440
对吧

23:42.440 --> 23:43.640
这是响应式数据的

23:43.640 --> 23:45.720
这种非常巧妙的结构完成的

23:46.840 --> 23:47.720
在数据变化后

23:47.720 --> 23:49.160
所有依赖该数据的watcher

23:49.160 --> 23:50.200
都会重新执行

23:50.200 --> 23:52.040
当然不一定是这个函数

23:52.040 --> 23:53.240
还有一些别的函数

23:53.240 --> 23:54.280
还一致定函数

23:54.440 --> 23:55.560
比方说我们自己写的watcher

23:55.560 --> 23:56.440
watcher函数

23:56.440 --> 23:57.560
里边的函数

23:57.560 --> 23:58.920
都会重新执行

23:58.920 --> 24:00.760
我们这里不用去管别的

24:00.760 --> 24:01.560
我们只管

24:02.680 --> 24:04.120
这个updates component函数

24:04.120 --> 24:05.000
它对应的watcher

24:05.000 --> 24:06.200
比方数据变了

24:06.200 --> 24:07.560
那么我们先要运行这个函数

24:07.560 --> 24:08.600
这个函数其实就是

24:08.600 --> 24:09.640
重新生成的虚极节链

24:09.640 --> 24:10.840
然后重新调用这个updates

24:12.280 --> 24:13.080
那么它执行的时候

24:13.080 --> 24:14.680
你可以一定要回答到

24:14.680 --> 24:16.360
watcher会被调度器

24:16.360 --> 24:17.480
放到nextech之中

24:17.480 --> 24:18.280
运行我们讲过的

24:18.280 --> 24:18.520
对吧

24:18.520 --> 24:19.160
就是微对列中

24:19.160 --> 24:20.600
这张数字是为了避免

24:20.600 --> 24:21.720
如果说多个一代的数据

24:21.720 --> 24:22.120
abcd

24:23.080 --> 24:24.360
同时一次改变

24:24.360 --> 24:24.680
那么

24:25.400 --> 24:26.840
不至于运行四次

24:27.480 --> 24:28.760
不至于多次执行

24:28.760 --> 24:30.360
所以把它放到微对的一边

24:31.240 --> 24:31.960
那么这个时候

24:31.960 --> 24:33.720
它会首先运行beforeupdates

24:36.360 --> 24:36.920
运行这个函数

24:36.920 --> 24:37.640
我们先看完

24:37.640 --> 24:39.480
以后再演练一遍

24:40.520 --> 24:41.240
运行这个函数

24:41.240 --> 24:42.360
这是生命之虚构的函数

24:42.360 --> 24:42.760
接下来

24:43.320 --> 24:44.280
就是重新执行了

24:44.280 --> 24:46.200
updates component函数重新执行

24:46.200 --> 24:47.080
那么重新执行的时候

24:47.080 --> 24:48.680
其实跟之前的流程是一样的

24:48.680 --> 24:50.120
然后运行人代函数

24:50.120 --> 24:51.000
运行人代函数

24:51.080 --> 24:52.440
之前的依赖就不要了

24:52.440 --> 24:53.720
重新收集所要依赖

24:53.720 --> 24:55.240
因为每一次渲染的时候

24:55.240 --> 24:56.600
它依赖的数据可能不一样

24:56.600 --> 24:58.440
因为必须要考虑微衣服的存在

24:58.440 --> 24:59.160
对吧

24:59.160 --> 25:00.760
每个微衣服块里面的用到数据

25:00.760 --> 25:01.400
可能不一样

25:01.400 --> 25:02.920
所以它要重新收集依赖

25:02.920 --> 25:03.880
将来依赖变化的时候

25:03.880 --> 25:05.320
又会重新运行这个函数

25:06.520 --> 25:08.120
然后再执行updates函数

25:08.120 --> 25:08.920
触发派遣

25:08.920 --> 25:10.760
那派遣现在是不是有救数了

25:10.760 --> 25:12.280
它会跟新旧两颗数进行对比

25:12.840 --> 25:14.760
那如果说普通atm节点的话

25:14.760 --> 25:15.480
我们之前说过的

25:16.120 --> 25:17.800
那么它会导致

25:17.800 --> 25:19.160
因为它直接就使用新数

25:19.160 --> 25:21.240
它不会去改变虚拟动物数的

25:21.240 --> 25:23.320
它会直接让它vload的数据

25:23.320 --> 25:25.640
它会直接让vload的数据直向新数

25:25.640 --> 25:26.120
对吧

25:26.120 --> 25:28.120
然后只去改变真实节点

25:28.120 --> 25:30.040
哪些真实节点需要创建

25:30.040 --> 25:31.400
哪些真实节点需要删除

25:31.400 --> 25:33.720
移动更新都去一式做

25:33.720 --> 25:35.800
而且尽量用最小量的更新

25:35.800 --> 25:38.040
这个东西就回到什么地府的流程了

25:38.040 --> 25:38.440
对不对

25:38.440 --> 25:39.400
所以地府的内框

25:39.400 --> 25:40.440
如果说它要详细的问的话

25:40.440 --> 25:43.080
你就进入那个面试题去给它回答

25:44.440 --> 25:45.480
然后组建了节点

25:45.480 --> 25:46.360
说说面试的时候

25:46.360 --> 25:48.680
像这个东西要回答详细的会越来越多

25:48.760 --> 25:50.360
可能一两个小时都说不完

25:50.360 --> 25:51.880
你看我讲可以用了多久了

25:51.880 --> 25:54.040
因为面试的时候用到这些问题

25:54.040 --> 25:55.240
可能一两句话就完了

25:55.240 --> 25:57.240
那说明理解的不够全面

25:58.360 --> 26:00.440
就是将这些知识点都是相互关联的

26:00.440 --> 26:02.440
要回答的话会扯很远很远

26:04.200 --> 26:06.040
然后组建的节点

26:06.040 --> 26:07.560
如果说是组建对比呢

26:07.560 --> 26:09.560
那么组建它也会找到创建

26:09.560 --> 26:09.880
对吧

26:09.880 --> 26:10.920
比方说之前没有这个组建

26:10.920 --> 26:12.040
现在有vif的存在

26:12.040 --> 26:13.240
可能会用到这个组建

26:13.240 --> 26:14.680
然后有可能会删除这个组建

26:14.680 --> 26:15.480
有可能会移动

26:15.480 --> 26:16.280
有可能会更新

26:16.280 --> 26:17.400
比方说组建的属性变了

26:18.920 --> 26:20.120
那么这个组建有什么回事呢

26:20.120 --> 26:21.880
当新组建需要创建的时候

26:21.880 --> 26:23.080
比方说之前没有这个组建

26:23.080 --> 26:24.040
现在有这个组建了

26:24.040 --> 26:25.720
那么是不是要进入创建流程

26:25.720 --> 26:26.680
那是不是进入这个流程

26:27.800 --> 26:28.200
对不对

26:29.000 --> 26:30.040
会进入创建流程

26:30.760 --> 26:32.440
当旧组建需要删除的时候

26:32.440 --> 26:33.800
会调用旧组建的什么

26:33.800 --> 26:34.920
迪斯多尼方法

26:34.920 --> 26:36.360
比方说之前的组建不要了

26:36.360 --> 26:38.200
现在以前用没用到了

26:38.200 --> 26:39.720
那么删除这个组建

26:39.720 --> 26:40.840
那么这个方法呢

26:40.840 --> 26:41.960
它的具体做法是

26:41.960 --> 26:43.240
会先触发生命周期构成

26:43.240 --> 26:44.280
比方迪斯多尼

26:44.280 --> 26:46.280
然后第一规调用直变的迪斯多尼方法

26:46.280 --> 26:48.600
然后再触发生命周期构成

26:48.600 --> 26:49.240
还是迪斯多尼的

26:49.240 --> 26:50.440
以后我们详细说

26:50.440 --> 26:52.600
当组建属性需要更新的时候

26:52.600 --> 26:54.440
相当于是组建的Update Component

26:54.440 --> 26:55.880
还是会被重新触发执行

26:55.880 --> 26:56.920
因为组建更新是什么意思

26:56.920 --> 26:57.800
就是属性变化嘛

26:58.520 --> 26:59.320
对不对

26:59.320 --> 27:00.120
属性变化的时候

27:00.120 --> 27:01.640
属性是响应式的

27:01.640 --> 27:03.480
而组建里面用到了这个响应式数据

27:03.480 --> 27:05.160
一把这个响应式数据一变

27:05.160 --> 27:06.280
是不是导致了它进入

27:06.280 --> 27:07.800
直接导致它进入重新的流程

27:07.800 --> 27:09.560
都让你基本上不用做任何处理

27:09.560 --> 27:11.800
你只需要把它的属性给它改了就行了

27:11.800 --> 27:13.080
在副组建里面把属性

27:16.440 --> 27:17.560
那么这些事情做完了过

27:17.560 --> 27:19.640
和运行生命都是勾字还是Update

27:19.640 --> 27:21.000
我们来演示一下

27:21.000 --> 27:22.440
看一下它具体的怎么做的

27:22.440 --> 27:24.440
免得大家有点飘

27:24.440 --> 27:25.560
听这个东西

27:25.560 --> 27:27.080
我们这里非常简单的

27:27.080 --> 27:27.960
我们Increase

27:28.840 --> 27:29.720
调这个Increase

27:29.720 --> 27:30.680
增加这个数据

27:30.680 --> 27:32.440
你看一下我们这里是怎么弄的

27:32.440 --> 27:33.240
Increase在哪呢

27:33.240 --> 27:33.960
数据在哪呢

27:33.960 --> 27:34.840
在App组建里面

27:34.840 --> 27:36.200
是不是App组建里面的数据

27:36.200 --> 27:37.160
这是个响应式数据

27:37.160 --> 27:37.720
对吧

27:37.720 --> 27:39.480
那么App组建里面有没有用到这个数据

27:39.480 --> 27:40.120
实际上用到了

27:40.120 --> 27:40.840
你看在模板里面

27:40.840 --> 27:41.720
是不是用到这个数据

27:41.720 --> 27:43.080
把这个数据传递给植入点

27:43.080 --> 27:43.560
对吧

27:43.720 --> 27:44.520
你说

27:44.520 --> 27:48.120
这个数据是被这个组建所依赖的

27:49.240 --> 27:50.280
然后传递给它

27:50.280 --> 27:51.400
来帮我们来看一下

27:51.400 --> 27:53.160
在App组建里面把数据传给它

27:53.160 --> 27:55.160
所以我们这里调了这个

27:55.160 --> 27:55.960
点这个按钮

27:55.960 --> 27:56.920
调了靠直加加

27:56.920 --> 27:58.680
是不是改变了这个响应式数据

27:58.680 --> 27:59.800
因此导致了什么呢

27:59.800 --> 28:02.200
导致这个App组建是不是要被重选了

28:03.560 --> 28:04.760
要被重选了

28:04.760 --> 28:05.320
对吧

28:05.320 --> 28:07.160
于似乎它会怎么样呢

28:07.160 --> 28:09.160
它会生成一个新的数据动物数

28:12.360 --> 28:14.120
它会生成一个新的动物数

28:14.200 --> 28:15.400
这个新的动物数

28:15.400 --> 28:17.400
当然BUTTON那边我就没画了

28:17.400 --> 28:18.920
也是一个A7

28:18.920 --> 28:21.400
有个DIV一个A7

28:21.400 --> 28:22.840
然后这里是不是也是一个组建

28:22.840 --> 28:24.680
当然现在目前还没设计到这个东西

28:24.680 --> 28:25.400
对吧

28:25.400 --> 28:27.400
那么也是这个组建

28:27.400 --> 28:28.520
那么这个组建呢

28:28.520 --> 28:30.360
给它传入一些属性

28:30.360 --> 28:31.720
那么这个属性是不是变化了

28:31.720 --> 28:32.760
之前那个属性里面

28:32.760 --> 28:34.200
传的数据是什么呢

28:34.200 --> 28:35.960
传的数据是0

28:35.960 --> 28:37.960
我们这就简单写一下

28:37.960 --> 28:40.120
这个属性里面是

28:40.120 --> 28:41.640
这个东西里面还有堆箱

28:41.640 --> 28:42.280
还有属性里面

28:42.280 --> 28:43.400
我们就不用管了

28:43.400 --> 28:44.680
现在是1了对不对

28:44.680 --> 28:45.320
那么对比啊

28:45.320 --> 28:46.200
这个东西是一样

28:46.200 --> 28:47.080
一样就不动它

28:47.080 --> 28:48.520
A7一样对吧

28:48.520 --> 28:49.480
真实元素不动

28:49.480 --> 28:51.000
那么这个东西

28:51.000 --> 28:51.600
这个两个首先

28:51.600 --> 28:52.760
这两个节点一不一样

28:52.760 --> 28:53.240
一样啊

28:53.240 --> 28:54.040
他们类型是什么

28:54.040 --> 28:55.160
都是A组建

28:55.160 --> 28:55.400
对吧

28:55.400 --> 28:56.440
他们的key值也一样

28:56.440 --> 28:57.800
key值都是undefined的

28:57.800 --> 28:59.160
所以说它会重用这个

28:59.160 --> 29:00.760
component instance

29:00.760 --> 29:01.880
这个component instance呢

29:01.880 --> 29:03.480
它会重用

29:03.480 --> 29:05.800
它不会重新去创建一个新的实力

29:05.800 --> 29:07.640
它会重用

29:07.640 --> 29:09.080
明白了意思吧

29:09.080 --> 29:09.640
它会重用

29:09.640 --> 29:10.360
它们两个指向

29:10.360 --> 29:12.680
都指向的是它

29:12.680 --> 29:15.480
但是它的什么属性变化了

29:15.480 --> 29:15.960
对吧

29:15.960 --> 29:17.000
是不是属性变化了

29:17.000 --> 29:18.440
属性从0变成1了

29:18.440 --> 29:19.400
于是它会怎么样了

29:19.400 --> 29:21.800
它会重新给它的配置复制

29:21.800 --> 29:23.160
它这个事情特别简单

29:23.160 --> 29:24.360
就重新给它的配置复制

29:24.360 --> 29:26.440
就属性复制就行了

29:26.440 --> 29:26.840
一复制

29:26.840 --> 29:28.360
因为它是响应数据

29:28.360 --> 29:30.680
而我们A是不是依赖这个东西

29:30.680 --> 29:32.200
而重新一给它复制

29:32.200 --> 29:35.480
就导致了A重新券的

29:35.480 --> 29:37.000
所以说它的具体流程

29:37.000 --> 29:39.560
它首先运行的是App的什么

29:39.560 --> 29:41.880
before update

29:41.880 --> 29:43.720
那么现在进入update的流程

29:43.720 --> 29:44.840
update的流程还没有完了

29:44.840 --> 29:45.640
要等着

29:45.640 --> 29:47.320
它又是个第规的过程

29:47.320 --> 29:48.200
你看

29:48.200 --> 29:50.680
我给它一重新复制

29:50.680 --> 29:55.230
你看

29:55.230 --> 29:57.790
刷新

29:57.790 --> 29:58.350
increase

29:58.350 --> 29:59.550
你看是不是运行了

29:59.550 --> 30:01.070
before update

30:01.070 --> 30:02.510
一重新复制吧

30:02.510 --> 30:04.190
那么接下来

30:04.190 --> 30:06.430
由于它重新复制的过后

30:06.430 --> 30:07.710
到这边来

30:07.710 --> 30:09.310
导致了

30:09.310 --> 30:10.270
这边的响应是

30:10.270 --> 30:11.710
它们的数据也发生变化

30:11.710 --> 30:13.230
同之了这个组建的Watcher

30:13.310 --> 30:15.470
这个组建的Watcher自动开始执行

30:15.470 --> 30:18.670
于是它又开始重新渲染了

30:18.670 --> 30:20.830
过程都一样

30:20.830 --> 30:22.190
它又开始重新来

30:22.190 --> 30:23.230
它一重渲染的时候

30:23.230 --> 30:23.790
你看

30:23.790 --> 30:26.430
它是不是又要生成一个新的数

30:26.430 --> 30:28.030
道理是一样的

30:28.030 --> 30:29.550
又要生成一个新的数

30:29.550 --> 30:29.790
好

30:29.790 --> 30:33.820
这个新的数

30:33.820 --> 30:35.660
这个新的数这些东西都一样

30:35.660 --> 30:37.820
你看

30:37.820 --> 30:38.460
都一样

30:38.460 --> 30:40.620
这个地方有变化

30:40.620 --> 30:41.260
文本有变化

30:41.260 --> 30:41.900
文本有变化

30:41.900 --> 30:42.700
我就不管了

30:42.700 --> 30:43.660
文本一般它实际上

30:43.660 --> 30:44.860
还有一个文本节点下面

30:44.860 --> 30:46.460
文本节点它自己去更新就完事了

30:46.460 --> 30:48.060
一堆笔发现不一样更新就完事了

30:49.900 --> 30:51.900
然后这边有个组建B

30:51.900 --> 30:52.540
组建B

30:52.540 --> 30:53.420
像这些东西都一样

30:53.420 --> 30:53.980
对吧

30:53.980 --> 30:55.020
元素本身都一样

30:55.020 --> 30:56.300
就是里边的文本变了

30:56.300 --> 30:56.940
变了就变了

30:56.940 --> 30:59.340
它是会更新相应的真实的节点

31:00.220 --> 31:00.460
好

31:00.460 --> 31:01.100
然后B

31:01.100 --> 31:02.060
B的属性

31:02.060 --> 31:03.500
你看之前这个属性

31:03.500 --> 31:04.940
用的是什么

31:04.940 --> 31:05.820
用的是0

31:05.820 --> 31:06.380
对吧

31:06.380 --> 31:07.980
来自于之前的属性的值

31:07.980 --> 31:09.900
它把之前的属性传来到这了

31:09.900 --> 31:10.700
传来到这了

31:10.700 --> 31:12.700
然后现在这个B的属性又变成1了

31:13.420 --> 31:15.420
那传递B的属性是不是相应似的

31:15.420 --> 31:16.460
也是相应似的

31:16.460 --> 31:17.820
于是这里是不是有变化

31:17.820 --> 31:19.500
但是这两个东西是同一个东西

31:19.500 --> 31:20.460
它们是相同的

31:20.460 --> 31:20.700
对吧

31:20.700 --> 31:22.060
都是同一个内形

31:22.060 --> 31:24.060
而且T值有一样

31:24.060 --> 31:24.860
所以说

31:24.860 --> 31:27.980
这个实力也是直接拿过来

31:27.980 --> 31:29.420
我就不画一个线了

31:29.420 --> 31:30.940
其实它们两个是一个实力

31:30.940 --> 31:32.220
用的是一个东西

31:32.220 --> 31:33.260
我就这样吧

31:35.770 --> 31:36.970
它们用的是一个实力

31:39.880 --> 31:40.920
然后我们要做的事情

31:40.920 --> 31:42.920
就是把这个东西改一下

31:42.920 --> 31:44.280
把之前的这个东西

31:44.440 --> 31:46.440
把这个东西传递过去的东西改一下

31:46.440 --> 31:48.440
这个东西一改

31:48.440 --> 31:50.440
一改是不是相应数据

31:50.440 --> 31:52.040
而相应数据是不是导致了

31:52.040 --> 31:53.240
B又重新选了

31:53.240 --> 31:53.480
对吧

31:53.480 --> 31:54.440
这是

31:54.440 --> 31:56.440
所以说这个时候运行的A的

31:56.440 --> 31:57.400
A

31:57.400 --> 31:58.440
B4

31:58.440 --> 31:59.320
Update

31:59.320 --> 32:00.040
之前运行

32:00.040 --> 32:01.160
然后比比要A

32:01.160 --> 32:02.200
要重新选两B

32:02.200 --> 32:03.240
A还没完

32:03.240 --> 32:05.240
又进入B的选两流程

32:05.240 --> 32:07.240
懂这意思吧

32:07.240 --> 32:08.200
B的选两流程

32:08.200 --> 32:09.480
那么B选两过后呢

32:09.480 --> 32:11.160
就只有一个文本节点不一样

32:11.160 --> 32:11.480
对吧

32:11.480 --> 32:13.480
A习一边的文本节点不一样

32:13.640 --> 32:14.280
文本节点不一样

32:14.280 --> 32:15.080
把文本一改

32:15.080 --> 32:15.880
那就完成了

32:15.880 --> 32:17.480
好那么现在就进入B

32:17.480 --> 32:18.520
B首先运行

32:19.320 --> 32:19.640
B4

32:20.280 --> 32:20.920
Update

32:20.920 --> 32:22.520
然后进入重现

32:22.520 --> 32:23.960
生产虚拟动

32:23.960 --> 32:26.280
然后对比就数

32:26.280 --> 32:27.240
就好像一样的

32:27.240 --> 32:28.040
只有一个文本不一样

32:28.040 --> 32:28.680
把文本一改

32:29.320 --> 32:30.680
那么B是不是完了

32:30.680 --> 32:31.240
B完了过后

32:31.240 --> 32:32.920
它就会调用这个Update的

32:33.640 --> 32:35.080
生命周期勾出函数

32:35.080 --> 32:36.360
那么B完了过后A

32:36.360 --> 32:36.920
一看

32:36.920 --> 32:37.640
还有没有别的呢

32:37.640 --> 32:39.000
还有其他几点没有呢

32:39.000 --> 32:39.640
好像没有了

32:39.640 --> 32:41.000
那我这个数也便利完了

32:41.000 --> 32:41.880
所以说A

32:41.880 --> 32:43.000
运行Update的

32:43.880 --> 32:44.760
那么A完了过后

32:44.760 --> 32:45.960
再回到App

32:45.960 --> 32:46.520
App看下

32:46.520 --> 32:47.560
还因为别的节点呢

32:47.560 --> 32:48.760
好像App里边也没了

32:48.760 --> 32:51.160
那么运行App的Update的

32:51.640 --> 32:52.360
就完成了

32:53.080 --> 32:53.960
没别的东西呢

32:53.960 --> 32:54.840
跟它有关系吗

32:54.840 --> 32:55.960
跟它没关系

32:55.960 --> 32:57.000
因为我们从这里

32:57.000 --> 32:58.200
是从这里开始的

32:58.200 --> 32:59.080
改变了它的数据

32:59.080 --> 33:00.040
从这里重现成开始的

33:00.040 --> 33:01.640
就导致了A和B重新宣传

33:02.120 --> 33:03.880
那如果说我A里面

33:04.440 --> 33:05.960
A里面没有用到这个数据呢

33:06.840 --> 33:08.440
那A还会还不会宣传呢

33:08.440 --> 33:09.400
它就不会

33:09.400 --> 33:10.040
它就不会宣传

33:10.040 --> 33:11.080
它只会宣传它

33:11.080 --> 33:12.200
比方这个Cult数据

33:12.280 --> 33:13.480
A里面不要

33:13.480 --> 33:14.920
没有通过属性传过去

33:14.920 --> 33:16.040
或者说传过去了

33:16.040 --> 33:16.600
但是我

33:16.600 --> 33:17.800
无法里面根本没用

33:17.800 --> 33:18.600
用了没用这个数据

33:18.600 --> 33:19.800
那就不是它的依赖数据

33:20.440 --> 33:22.040
不依赖它的数据变了过后

33:22.040 --> 33:23.000
跟它没关系

33:23.000 --> 33:24.600
它不会触发它的Watcher

33:24.600 --> 33:26.120
因为Watcher只记录依赖

33:26.120 --> 33:26.760
那这意思吧

33:26.760 --> 33:27.720
它就整个串起来了

33:28.920 --> 33:29.560
那么就数

33:29.560 --> 33:30.680
当然后面就不用了

33:30.680 --> 33:32.040
因为它直接指向新数了

33:32.040 --> 33:33.800
就数它就会被垃圾回收掉

33:34.440 --> 33:34.760
对吧

33:34.760 --> 33:36.120
那么现在这个东西变成了

33:36.120 --> 33:36.920
它目前的数

33:37.720 --> 33:38.440
变成1

33:38.440 --> 33:39.240
它目前的数

33:39.240 --> 33:40.360
这个就是它目前的数

33:41.080 --> 33:42.360
这些东西后来就没了

33:42.360 --> 33:43.560
被垃圾回收掉了

33:44.840 --> 33:45.640
变成这样子了

33:46.680 --> 33:47.400
没有意思吧

33:50.280 --> 33:50.680
好

33:50.680 --> 33:52.040
然后我们再看一下

33:52.040 --> 33:52.920
组建销毁的情况

33:52.920 --> 33:54.440
看一下刚才那个运行的

33:55.560 --> 33:58.440
B4ABBA2

33:58.440 --> 33:58.920
对吧

33:58.920 --> 33:59.560
是不是这个流程

34:00.280 --> 34:00.520
好

34:00.520 --> 34:02.040
然后我们再看组建销毁的情况

34:02.520 --> 34:03.720
组建销毁就是投稿

34:03.720 --> 34:05.560
我们点击投稿的时候

34:06.040 --> 34:08.040
它是不是触发的是什么

34:08.040 --> 34:09.240
这个东西的电话

34:09.240 --> 34:09.560
对吧

34:09.640 --> 34:10.840
它又来一遍

34:10.840 --> 34:11.240
你看吧

34:12.360 --> 34:13.720
把这个销点一下

34:13.720 --> 34:15.320
销变成4

34:15.320 --> 34:16.040
4变成2

34:16.040 --> 34:16.520
对吧

34:16.520 --> 34:17.080
投稿嘛

34:17.080 --> 34:17.720
切换

34:17.720 --> 34:19.400
然后这个玩意有一个V衣服

34:19.400 --> 34:19.640
对吧

34:19.640 --> 34:21.240
V衣服它会影响生成的什么

34:21.240 --> 34:22.120
虚拟动物数

34:22.760 --> 34:23.080
对吧

34:23.080 --> 34:24.280
这个东西要不要生成

34:24.280 --> 34:25.000
生成一个节点

34:25.000 --> 34:26.040
它会影响这个

34:26.040 --> 34:26.280
好

34:26.280 --> 34:27.160
咱们来看一下

34:27.160 --> 34:27.640
V修的话

34:27.640 --> 34:29.080
它就始终会生成这个节点

34:29.080 --> 34:29.640
V衣服的话

34:29.640 --> 34:30.840
它有可能不生成

34:30.840 --> 34:31.000
好

34:31.000 --> 34:31.480
我们来看一下

34:32.440 --> 34:33.640
这是之前的就数

34:33.640 --> 34:34.440
现在是新数

34:34.440 --> 34:34.920
现在我们

34:36.360 --> 34:37.400
又来把这个东西

34:38.120 --> 34:41.160
首先是它重新选择

34:41.160 --> 34:41.960
它重新选择

34:41.960 --> 34:43.240
是不是它要运行什么

34:44.360 --> 34:45.800
App的BeforeUpdate

34:45.800 --> 34:46.520
只要运行这个

34:46.520 --> 34:47.640
然后生成一棵新的数

34:48.120 --> 34:48.760
对不对

34:48.760 --> 34:49.960
这个新的数里边

34:49.960 --> 34:51.080
现在之前是去

34:51.080 --> 34:51.960
现在变成Force了

34:51.960 --> 34:52.680
变成Force的话

34:52.680 --> 34:53.880
是不是只有一个A习了

34:53.880 --> 34:54.840
就没有这个东西了

34:57.480 --> 34:58.360
是没有这个东西了

34:59.400 --> 34:59.640
好

34:59.640 --> 35:00.200
没有这个东西

35:00.200 --> 35:01.480
之前的就数有现在没有

35:01.480 --> 35:02.120
该干嘛

35:02.120 --> 35:03.480
是不是找到这个就数

35:03.960 --> 35:05.160
找到这个就数

35:05.240 --> 35:05.880
然后呢

35:05.880 --> 35:06.680
调用它的

35:07.720 --> 35:08.840
它的实力里边

35:08.840 --> 35:09.640
主键实力

35:09.640 --> 35:11.160
主键实力是不是拿到之前的实力

35:11.160 --> 35:11.880
调用它的什么

35:11.880 --> 35:12.520
调用它的

35:13.000 --> 35:13.800
DiskDroid方法

35:14.440 --> 35:16.600
也就是调用这个实力的DiskDroid

35:17.240 --> 35:18.120
这个DiskDroid方法

35:18.120 --> 35:19.160
其实我们可以手动调用的

35:19.160 --> 35:20.760
在主键里边可以用ZiskDroid

35:20.760 --> 35:21.720
把小肥调

35:21.720 --> 35:22.200
是可以的

35:23.480 --> 35:23.800
好

35:23.800 --> 35:25.160
调用这个方法过后

35:25.720 --> 35:27.400
那就会进入DiskDroid流程

35:27.400 --> 35:28.760
DiskDroid流程是什么呢

35:28.760 --> 35:32.600
是首先A运行D4DiskDroid

35:34.570 --> 35:35.290
它运行这个

35:36.250 --> 35:37.450
它运行这个过后了

35:38.010 --> 35:38.890
AD4DiskDroid过后

35:39.530 --> 35:40.250
运行这个

35:40.250 --> 35:41.450
然后它接下来该干嘛呀

35:42.330 --> 35:43.450
接下来它会看一下

35:44.090 --> 35:45.050
我这个东西

35:45.050 --> 35:45.770
元素啊

35:45.770 --> 35:46.170
比较多

35:46.170 --> 35:46.730
它的元素

35:48.010 --> 35:48.730
地柜删除啊

35:48.730 --> 35:49.690
首先把它

35:49.690 --> 35:51.610
就直接把它删除掉

35:51.610 --> 35:53.530
真实动物删除掉

35:53.530 --> 35:54.090
然后呢

35:54.570 --> 35:55.290
还会运行

35:55.770 --> 35:56.730
这个B的

35:56.730 --> 35:57.930
Component Instance

35:57.930 --> 35:58.730
它的DiskDroid

35:59.530 --> 36:00.490
运行B的DiskDroid

36:02.250 --> 36:03.530
运行B的DiskDroid

36:03.530 --> 36:04.890
然后B又会运行B4

36:05.370 --> 36:06.010
DiskDroid

36:07.370 --> 36:08.730
现在不是更新了

36:08.730 --> 36:09.530
DiskDroid

36:09.530 --> 36:11.050
B的DiskDroid

36:11.050 --> 36:12.410
就是把这些元素全部删除掉

36:12.410 --> 36:13.770
运行DiskDroid删除掉

36:17.160 --> 36:18.040
B没了

36:18.040 --> 36:19.240
然后再回到A这里

36:19.240 --> 36:20.040
A看一下

36:20.040 --> 36:22.040
还因为别的B就完了

36:22.040 --> 36:23.800
完了B运行完了过后

36:23.800 --> 36:24.600
没有别的节点了

36:24.600 --> 36:26.600
那有B就会运行DiskDroid

36:28.360 --> 36:28.920
DiskDroid

36:30.520 --> 36:30.840
好

36:30.840 --> 36:31.720
那么B终于完了

36:32.280 --> 36:33.240
所有事情干完了

36:33.240 --> 36:33.880
那B没了

36:34.920 --> 36:35.960
好那么这里呢

36:36.040 --> 36:37.720
这个Instance肯定也没了

36:37.720 --> 36:38.520
Instance也没了

36:38.520 --> 36:39.320
那么接下来

36:39.320 --> 36:41.240
看A里面看下还有没有别的节点呢

36:41.240 --> 36:42.120
好像没有别的节点了

36:42.120 --> 36:44.920
总之A里面东西就全部没了

36:44.920 --> 36:46.360
那么A里面没有别的节点了

36:46.360 --> 36:47.560
A又会调用DiskDroid

36:50.650 --> 36:51.050
A没了

36:52.010 --> 36:52.970
那么就剩下一个App

36:54.010 --> 36:54.330
对吧

36:55.290 --> 36:55.930
那么App呢

36:55.930 --> 36:57.450
看一下还没有别的节点需要处理一下

36:57.450 --> 36:57.610
没有

36:57.610 --> 36:58.730
那么App更新完成

36:59.530 --> 37:00.090
打个别提

37:00.730 --> 37:01.290
所以说我们

37:01.290 --> 37:02.810
当我们切换显示的时候

37:02.810 --> 37:03.690
它是这样子输出的

37:04.650 --> 37:06.330
ABB beforeDiskDroid

37:06.330 --> 37:07.290
A beforeDiskDroid

37:07.290 --> 37:09.050
ABB beforeDiskDroid

37:09.050 --> 37:10.010
ABD afterDiskDroid

37:10.010 --> 37:10.810
然后App update

37:10.810 --> 37:11.770
更新完成

37:12.490 --> 37:12.890
看没

37:14.010 --> 37:16.010
好那么现在我们又切换成显示呢

37:16.010 --> 37:16.570
又来看啊

37:18.090 --> 37:19.210
现在蓄力动作是这样子的

37:22.490 --> 37:23.530
这是旧的输

37:23.530 --> 37:24.810
好切换能显示

37:24.810 --> 37:25.930
是不是我们又点下这个按钮

37:25.930 --> 37:27.850
点下按钮是不是触发了App组件的

37:27.850 --> 37:28.810
数据变化

37:28.810 --> 37:30.090
数据变化是不是要重现了

37:30.090 --> 37:31.530
好重现了是不是要执行那个

37:32.410 --> 37:33.610
update component的函数

37:33.610 --> 37:35.050
update component的函数是不是要执行

37:35.050 --> 37:35.610
update函数

37:35.610 --> 37:37.050
update函数是不是要执行

37:37.050 --> 37:37.610
Render函数

37:37.610 --> 37:38.970
Render函数是不是要生成一个新的

37:39.770 --> 37:40.250
数啊

37:41.130 --> 37:41.610
对吧

37:41.610 --> 37:44.410
那个新的数里边是不是就又有又多了一个节点了

37:45.290 --> 37:46.250
又多了一个节点了

37:47.050 --> 37:47.930
是不是多了一个A

37:48.490 --> 37:49.210
节点A

37:49.210 --> 37:50.410
然后传了一些属性

37:50.970 --> 37:53.610
目前那个数据的数字呢是1

37:53.610 --> 37:54.570
我就这样写吧

37:54.570 --> 37:56.170
现在一个1跟我们写的

37:56.170 --> 37:56.890
也没什么关系了

37:56.890 --> 37:58.090
写不写都无所谓

37:58.090 --> 37:59.690
总之有这么一个组件

37:59.690 --> 38:01.290
然后呢是不是对比新就两数

38:02.170 --> 38:03.290
发现一个新数里边

38:04.810 --> 38:05.530
新数里边

38:07.130 --> 38:08.250
没有这个节点

38:08.330 --> 38:09.770
那么我这里是不是只能新建

38:09.770 --> 38:11.610
如果说有的话是不是直接把那个实地拿过来

38:11.610 --> 38:12.490
但是现在没有

38:12.490 --> 38:13.690
没有的话是不是只能新建

38:14.330 --> 38:14.890
新建那个

38:15.530 --> 38:16.490
好那么新建的话

38:16.490 --> 38:18.490
我们是不是会触发A的新建流程

38:18.490 --> 38:19.450
创建流程

38:19.450 --> 38:20.490
怎么怎么创建的

38:21.370 --> 38:22.650
创建一个实地A

38:23.210 --> 38:23.850
对吧

38:23.850 --> 38:24.890
然后A运行啥

38:25.690 --> 38:26.810
created before

38:28.170 --> 38:30.410
before created a create

38:30.410 --> 38:31.370
然后A又运行

38:32.250 --> 38:33.130
created

38:33.130 --> 38:35.850
然后A又运行before mount

38:36.410 --> 38:37.050
然后A又

38:37.930 --> 38:40.330
接下来开始运行Render了对吧

38:40.330 --> 38:42.090
不能再画了不能再写了

38:42.090 --> 38:43.130
开始运行Render了

38:43.130 --> 38:45.770
Render过程又是个低违的过程

38:45.770 --> 38:46.250
它回事

38:46.250 --> 38:46.810
首先生成什么

38:47.450 --> 38:48.090
生成一个

38:48.890 --> 38:50.570
这个地方是不是有个instance

38:53.790 --> 38:54.350
instance

38:55.070 --> 38:55.710
实地

38:55.710 --> 38:56.350
然后呢

38:56.350 --> 38:57.950
A的生成过程是不是又来一次

38:59.710 --> 39:00.830
生成Render

39:00.830 --> 39:01.950
里边有个B对吧

39:02.590 --> 39:03.630
是不是要创建B

39:03.630 --> 39:04.910
好来吧又创建B

39:09.630 --> 39:10.430
到底是一样的

39:11.390 --> 39:12.030
创建B

39:12.030 --> 39:13.070
B里边很简单

39:13.070 --> 39:14.030
B里边只有这两个

39:16.570 --> 39:17.050
A

39:17.050 --> 39:17.610
这是B

39:20.400 --> 39:23.280
是不是B又要运行before

39:23.280 --> 39:24.400
就把复制一下吧

39:25.440 --> 39:26.240
B要运行

39:26.880 --> 39:27.600
这三个

39:28.480 --> 39:28.800
对不对

39:28.800 --> 39:29.600
好

39:29.600 --> 39:30.800
B那边是不是创建完了

39:30.800 --> 39:31.840
显示出来了对吧

39:31.840 --> 39:32.880
显示出来了过后B

39:32.880 --> 39:34.160
是不是要运行mounted

39:35.440 --> 39:36.480
那么B完了过后

39:36.480 --> 39:37.840
A的节点这个节点搞定的

39:37.840 --> 39:39.280
看一下A还没有别的节点呢

39:39.280 --> 39:40.320
没有了没有了

39:40.320 --> 39:41.440
A也mounted

39:42.400 --> 39:44.160
那么A处理完了

39:44.160 --> 39:45.440
然后看一下App

39:45.440 --> 39:46.880
App还有没有别的节点

39:46.880 --> 39:47.760
都要对比了

39:47.760 --> 39:48.240
没有了

39:48.240 --> 39:49.040
那么App

39:51.040 --> 39:52.080
所以说我们重新

39:53.200 --> 39:53.840
透过的时候

39:53.840 --> 39:54.320
你看一下

39:55.200 --> 39:55.680
对比一下

39:57.280 --> 39:57.920
是不是一样的

39:59.760 --> 40:00.640
所以说这个就是

40:01.520 --> 40:03.200
当我们有个组建书的时候

40:03.200 --> 40:05.040
它到底是怎么一个个完成更新的

40:05.600 --> 40:06.800
就这么一个逻辑

40:06.800 --> 40:09.440
那么这篇稳当了就已经起到很完善了

40:09.520 --> 40:10.320
那你在

40:10.320 --> 40:11.600
我当然我是这里说

40:11.600 --> 40:12.160
讲了那么多

40:12.160 --> 40:12.880
是为了跟你讲

40:12.880 --> 40:13.840
跟你一讲清楚

40:13.840 --> 40:15.200
让你自己理解

40:15.200 --> 40:16.000
回到的时候

40:16.000 --> 40:17.760
你可以用自己的语言组织一下

40:17.760 --> 40:19.600
把整个过程的表述出来

40:19.600 --> 40:20.000
好吧

40:20.000 --> 40:21.520
你可以参考我这个文档

40:21.520 --> 40:22.800
怎么是一个什么样的步骤

40:23.520 --> 40:23.840
OK

40:24.720 --> 40:25.680
那么至此呢

40:25.680 --> 40:27.040
你对5U的整个

40:27.920 --> 40:28.640
组建宣的

40:28.640 --> 40:29.760
它都是如何更新的

40:29.760 --> 40:31.920
其实就有了一个比较深刻的认识

40:31.920 --> 40:32.880
后边很多一些

40:33.920 --> 40:35.520
一些别的东西讲的时候

40:35.520 --> 40:36.320
就非常好讲

40:36.880 --> 40:38.240
其实最难的部分

40:38.400 --> 40:39.520
你就已经OK了

40:39.520 --> 40:40.800
后边的节目就不难了

40:41.600 --> 40:43.120
那么这是这些可能内容

