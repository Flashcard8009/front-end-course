WEBVTT

00:00.620 --> 00:03.180
这些课咱们来聊一聊优化

00:04.200 --> 00:06.520
我们在入门先端已经聊过一次优化了

00:06.520 --> 00:09.080
当时聊的是打包体积的优化 对吧

00:09.080 --> 00:10.600
我们的接视打包太大了

00:10.600 --> 00:12.400
我们可以想一些办法呀

00:12.640 --> 00:14.440
把它变小一点

00:14.700 --> 00:15.980
在咱们之前聊的

00:16.760 --> 00:19.060
那么这些课咱们聊的是

00:21.320 --> 00:22.600
不是打包体积的问题了

00:23.120 --> 00:25.680
是我们的接视代码已经传输过来了

00:25.920 --> 00:29.000
打包体积那边我们按照之前的优化去优化就行了

00:30.000 --> 00:32.840
接视已经传输过来了现在要执行它了

00:33.100 --> 00:36.420
在执行的过程中有哪些我们可以

00:36.680 --> 00:38.220
尽量优化的点

00:39.500 --> 00:42.300
东西很多因为优化本身就是一个比较

00:42.560 --> 00:43.600
大的一个话题

00:43.860 --> 00:45.380
而且它没有一个定时

00:45.640 --> 00:49.220
我们这里讲的了这里和讲的了都是一些

00:51.520 --> 00:53.060
比较常见的做法

00:53.320 --> 00:54.860
它们都不是一个定时

00:55.360 --> 00:58.180
最好了就是在具体的项目里边

00:58.640 --> 00:59.680
具体的去分析

00:59.920 --> 01:01.720
比方这一块发现

01:01.980 --> 01:03.000
它的宣展效率很低

01:03.260 --> 01:04.780
那么我们要去找到它的原因

01:05.040 --> 01:06.060
针对这个原因呢

01:06.320 --> 01:07.360
得去做一些处理

01:07.860 --> 01:09.140
所以说我们这就和讲的了

01:09.400 --> 01:10.420
并不是说你们以后

01:10.680 --> 01:11.440
做项目

01:11.700 --> 01:13.500
要把这些东西全部用进去

01:13.760 --> 01:15.800
当然一些必要的地方确实要用进去

01:16.060 --> 01:17.080
因为它毕竟

01:17.340 --> 01:18.600
非常简单

01:18.860 --> 01:22.460
而且用起来的也不麻烦也不会影响到项目里边的

01:22.720 --> 01:23.980
代码可绝毒性

01:24.240 --> 01:25.780
可维护性也不会产生影响

01:26.040 --> 01:27.840
所以说能够用进去的可以用进去

01:28.640 --> 01:31.240
但不是说就一定把它背下来全部要用进去

01:31.500 --> 01:32.020
那不是的

01:32.800 --> 01:34.840
我们一定要具体情况具体分析

01:35.600 --> 01:37.400
其实我们做软件开发呀

01:38.420 --> 01:41.240
目标只有一个因为我们软件就是一个工具

01:42.000 --> 01:43.540
为商业服务的工具

01:43.800 --> 01:45.080
而商业具也追逐的是什么呢

01:45.340 --> 01:46.100
追逐的是利润

01:46.860 --> 01:48.400
利润就是什么收益减成本

01:49.420 --> 01:54.540
你不能说我做一个项目要把它优化到极致花太多太多的时间去做这件事情

01:55.060 --> 01:56.080
结果呢可能

01:56.300 --> 02:01.660
优化的效果就是页面上渲染的时候少了0.01秒

02:02.180 --> 02:02.940
100毫秒

02:03.460 --> 02:04.740
也没有效果有效果

02:05.000 --> 02:06.540
但是呢可能这个效果呢

02:06.780 --> 02:07.820
跟我们的收益比起来

02:08.320 --> 02:10.100
那就微不主道微不主道了

02:10.360 --> 02:13.940
而我们花费了太多的去成本去追逐这个东西呢其实没有必要

02:14.720 --> 02:16.260
以后呢你们当了项目经历

02:17.020 --> 02:18.820
你们就会明白这个这个道理了

02:19.320 --> 02:19.840
所以说

02:20.100 --> 02:23.940
优化这个事情的作为我们的技术开发者你首先要会

02:24.920 --> 02:27.720
你要能够具体情况具体分析你要有这个能力

02:27.980 --> 02:29.020
这才是最重要的

02:29.520 --> 02:31.560
但是我用不用他只是个工具

02:31.820 --> 02:32.860
你我用不用他

02:33.360 --> 02:35.160
那么具体情况具体分析

02:35.920 --> 02:38.740
我希望大家能正确的去看待这个优化

02:39.760 --> 02:41.040
好了我们还是回到技术这里

02:41.300 --> 02:44.120
我们在Viu里边有哪些常见的优化手段呢

02:44.640 --> 02:45.400
一个个说啊

02:45.920 --> 02:46.920
首先这个东西呢

02:47.440 --> 02:49.240
就把总结下来了啊首先是个key

02:49.500 --> 02:50.000
key

02:50.520 --> 02:52.040
这个玩笑我是

02:52.300 --> 02:52.820
讲过的吧

02:53.120 --> 02:55.960
在viu的deaf里边我是不是讲过的

02:56.240 --> 02:57.160
他为什么需要key

02:57.440 --> 02:58.960
那么key用key的存在呢

02:59.220 --> 03:00.240
其实就是在为了

03:00.500 --> 03:02.560
主要就是为了在渲染列表的时候

03:03.320 --> 03:04.600
如果说列表像有变动

03:05.360 --> 03:07.160
他为了尽量少的

03:07.420 --> 03:09.200
删除和新增元素

03:09.720 --> 03:11.240
如果说没有key的话

03:11.520 --> 03:13.560
比方说我们就举个例子啊

03:16.880 --> 03:17.920
如果说没有key

03:18.420 --> 03:19.440
那么就是ab

03:19.700 --> 03:20.480
cd

03:20.720 --> 03:22.760
之前的列表是这个一共有五项

03:23.020 --> 03:23.800
四项嘛

03:24.060 --> 03:24.820
现在呢

03:25.320 --> 03:26.360
增加了一项

03:26.620 --> 03:27.380
增加了一项e

03:27.640 --> 03:28.660
增加到前面了

03:29.420 --> 03:29.940
b

03:30.200 --> 03:30.960
c

03:31.220 --> 03:32.500
如果说没有key啊

03:34.040 --> 03:36.080
那么可能造成的问题是什么呢

03:36.340 --> 03:38.380
他一对比他比较都是li元素

03:39.160 --> 03:40.960
他一对比他这一项和这一项

03:41.200 --> 03:42.740
发现都是li元素

03:43.500 --> 03:44.280
因此呢

03:44.540 --> 03:47.100
他有key值没有key值key值都是ondi犯的

03:47.360 --> 03:48.120
因此key值相同

03:48.380 --> 03:51.960
他就他就会把这个东西跟这个东西一对比是不是就把他改成

03:52.420 --> 03:52.940
e啊

03:53.200 --> 03:53.700
对不对

03:53.960 --> 03:55.760
那如果说这个li里面有很多很多的元素

03:56.000 --> 03:57.540
那么如果一式去变你去

03:57.800 --> 03:58.820
判断去更改

03:59.080 --> 03:59.580
对不对

03:59.840 --> 04:00.880
所以要这么一个问题

04:01.380 --> 04:02.420
那么这里呢

04:02.920 --> 04:03.940
a和b不一样

04:04.200 --> 04:05.220
他又会把他变成a

04:05.480 --> 04:07.280
然后呢这个b和c他会把别人b

04:07.540 --> 04:08.540
这个呢会把别人c

04:08.800 --> 04:09.820
然后后面加一个d

04:10.080 --> 04:11.120
新增一个元素d

04:11.620 --> 04:13.920
对吧就会造成很就这样的一个问题

04:14.180 --> 04:15.460
改动了大量的

04:16.220 --> 04:17.000
动物元素

04:17.260 --> 04:19.300
包括新增包括删除

04:19.560 --> 04:20.320
包括改动

04:21.300 --> 04:24.360
好那么如果说我们使用了key又会怎么样的

04:24.620 --> 04:25.340
像那种情况

04:25.600 --> 04:26.420
使用了key过后

04:27.180 --> 04:28.060
他对比出来

04:28.300 --> 04:31.020
这个key跟这个key是一样的他们就认为是同一个元素

04:31.540 --> 04:33.840
啊这个key跟这个key是一样的

04:34.100 --> 04:36.900
这个key跟这个key是一样的这个key跟这个key是一样的

04:37.160 --> 04:39.740
他最终的他只会在前面新增一个元素e

04:39.980 --> 04:41.020
这些元素是不会动的

04:41.780 --> 04:42.540
别人的意思吗

04:43.300 --> 04:47.420
主要的目的就是为了减少删除新增和改动元素

04:48.400 --> 04:51.480
尽量少的删除新增改动元素

04:52.240 --> 04:53.520
都是用key的目的

04:53.780 --> 04:56.840
所以说我们在循环列表的时候啊其实用 will click 来做项目的话

04:57.100 --> 05:00.940
你没有在一个循环列表里边使用key的话他一般会给你包一个警告

05:01.700 --> 05:03.500
好这个没什么好说的啊您讲过的

05:04.020 --> 05:05.540
第二个呢使用冻结的对象

05:06.060 --> 05:06.820
是啥意思呢

05:07.340 --> 05:08.620
什么叫做冻结的对象

05:09.640 --> 05:13.240
冻结的对象呢其实你们也在es5 里面应该是学过的啊

05:14.000 --> 05:15.280
比方一个一个obg

05:16.260 --> 05:16.880
随便来一个吧

05:19.140 --> 05:20.720
我们可以用obg是freeze

05:21.880 --> 05:22.680
把对象冻结

05:23.680 --> 05:27.000
冻结的过后对象有什么样的特点呢首先obg是e is frozen

05:27.720 --> 05:29.800
来派对对象是否是冻结他变成chill

05:30.800 --> 05:31.600
然后这个对象

05:32.520 --> 05:33.320
他是不能变的

05:35.000 --> 05:38.440
比方说啊我们给他复制复制可不可以呢obg

05:38.800 --> 05:43.080
复制是可以的他冻结的是这个对象啊冻结的不是这个变量啊你要搞清楚啊

05:44.080 --> 05:45.400
我们再重新来吧

05:48.560 --> 05:49.560
然后冻结

05:51.040 --> 05:53.240
好冻结之后呢这个对象里面的属性

05:53.800 --> 05:54.760
你是不能改变的

05:55.640 --> 05:56.600
知道吧我们看一下

05:57.840 --> 05:59.920
哎是不是还是e你改的属性没用

06:01.320 --> 06:01.800
知道吧

06:02.160 --> 06:03.320
那么obg b

06:05.400 --> 06:07.520
也就是个对象是不可变的就这么个意思

06:08.920 --> 06:10.520
好这是冻结对象的特点

06:10.960 --> 06:12.920
那能不能冻结一个数组了当然也可以

06:13.360 --> 06:14.920
比方说能冻结一个

06:16.360 --> 06:16.760
一个数组

06:17.280 --> 06:19.080
obg is frozen

06:19.640 --> 06:20.200
ar

06:20.920 --> 06:23.160
冻结之后呢这个数组里面是不能加加东西的

06:24.000 --> 06:25.720
你看他是不是直接给你抱错了啊

06:26.240 --> 06:27.000
他不能加东西

06:27.640 --> 06:30.080
那么这个数组呢你看还是这样子能不能改了

06:30.840 --> 06:31.360
也不能改

06:32.880 --> 06:33.920
是吧第一项还是e

06:35.200 --> 06:37.240
这就是冻结对象的特点啊回顾一下

06:38.000 --> 06:40.840
那么一个对象冻结之后由于他里面东西不可变

06:42.360 --> 06:44.400
所以说我用了他会对这个冻结对象的

06:44.600 --> 06:45.640
做一个优化处理

06:46.640 --> 06:47.840
他会怎么来优化处理呢

06:48.440 --> 06:53.680
就是以为又在想做一个响应式的时候他不是会变异我们的对象深度变异对吧

06:53.920 --> 06:57.920
变异对象的每一个属性如果说属性是对象还会对他进行深度变异

06:59.200 --> 07:01.760
但是如果说他发现一个东一个对象

07:02.160 --> 07:04.080
比方说变异到一个属性这个属性是一个对象

07:04.520 --> 07:07.880
但是这个对象是被冻结了他怎么判断的就是用obg is frozen

07:08.160 --> 07:08.680
那判断的

07:09.440 --> 07:10.480
啊刚才我们研视过

07:11.000 --> 07:12.720
他判断到这个对象是个冻结对象

07:13.280 --> 07:14.040
那会怎么样呢

07:14.880 --> 07:17.280
他就不会对这个对象做任何的响应式处理

07:18.280 --> 07:20.640
为什么呢因为这种冻结对象是不能改变的

07:21.200 --> 07:24.840
那做响应式处理没什么意义响应式处理的意义就是他改变了

07:25.080 --> 07:26.040
我要通知对吧

07:26.400 --> 07:29.480
那如果说他本身就是冻结的他不会改变那我就不需要通知了

07:30.040 --> 07:30.760
啊因此呢

07:32.080 --> 07:33.680
比方说有这么一个对象

07:34.920 --> 07:37.680
这个对象里边他欠套了东西他的东西很多

07:38.560 --> 07:40.760
obg他东西很多

07:41.600 --> 07:43.320
而且里边还可能欠套有对象

07:44.040 --> 07:49.320
而且呢我们发现这个对象呢本身我们拿过来只是为了把对象的东西显示到界面上

07:49.680 --> 07:51.240
并不会将来并不会改变他

07:52.040 --> 07:53.600
像什么情况呢比方要像一些

07:55.560 --> 07:56.320
我随便举个例子啊

07:56.760 --> 07:57.600
比方要像一些

07:58.480 --> 08:01.520
评论列表评论列表他本身就并不会变

08:02.040 --> 08:07.240
我们只是把它显示出来比方说像一些新闻的摘要就用新闻列表文章列表

08:07.680 --> 08:11.560
那么列表里边我们东西本本身并不会变我们只是把它显示出来而已

08:12.200 --> 08:16.080
那么这个时候呢他没有必要变成響应式他本身就不会变

08:16.720 --> 08:20.280
也就是我们把它变成冻结对象之后呢可以减少一个什么时间呢

08:20.680 --> 08:23.960
可以减少把五又把它变成響应式的这个时间

08:24.360 --> 08:28.680
因为五又要去便利他每一个属性把它变成響应式对吧他冻结一下他就不用便宜

08:29.360 --> 08:30.320
就减少这个时间

08:31.160 --> 08:34.040
当然如果说只有单个对象的话减少的确实不多

08:34.360 --> 08:38.520
但是如果说你是一个列表的话比方说文章列表每篇文章是个对象对吧

08:39.320 --> 08:44.760
那么如果说文章列表越来越多很多或者是评论列表很多数据很多

08:45.240 --> 08:49.000
那么这个时候呢你要把这些对象一个一个变成響应式那就比较花时间了

08:49.720 --> 08:54.040
你注意啊在优化的时候很多时候我们都是对一些重复发生的

08:54.920 --> 09:00.200
性能问题才需要进行优化很多时候就是哪怕他性能有问题但是他只发生一次

09:00.920 --> 09:06.760
一般来说呢我们都不会进行优化啊那难得或者是他如果说他优化的成本比较高的话

09:07.160 --> 09:12.120
不能难得去优化因为他只发生一次影响也不会太大但是如果说他的东西很多

09:12.680 --> 09:17.960
不断的重复这个性能问题那就变得严重了放大了吧他那么这里呢我有个例子啊

09:18.520 --> 09:23.340
使用冻结对象的例子打开看一下啊

09:28.280 --> 09:29.240
呃我们看一下代码

09:30.520 --> 09:38.280
代码很简单我这里呢有两个呃先看一下我的数据啊数据里边有两个数据一个是普通的对象一个数据一个对象数据

09:39.240 --> 09:40.280
一个呢是

09:41.320 --> 09:43.400
呃冻结的对象数据

09:44.600 --> 09:45.960
啊这边呢我有两个方法

09:46.520 --> 09:53.000
一个是普通对象数据我通过一个函数啊getdata这个getdata这个getdata是方法的就模拟一下啊

09:53.480 --> 09:57.960
模拟一下呃远程拿到数据嘛我就这里呢就设了100万个数据

09:58.760 --> 10:06.440
没循环意思的给他加了一个数据进去啊加了一个对象啊有id有那个name有他的就是柱子那就是

10:07.000 --> 10:09.160
就模拟一个人员列表吧对吧

10:09.640 --> 10:15.640
给他加了这么一个数据进去好我这里呢就把这个数据拿到了这是普通情况啊

10:16.360 --> 10:20.360
然后这里我输出这是一个最普通的情况我们平时切代码就这样写的

10:21.080 --> 10:22.360
然后另外一个方法呢是

10:22.840 --> 10:24.520
夹载一个冻结对象的数据

10:25.000 --> 10:29.320
然后我就做的事情是一样的我拿到这个数据然后我们把这个数据冻结了

10:29.720 --> 10:30.680
冻结了过后呢

10:31.160 --> 10:33.000
放了这个数据给他复制

10:33.560 --> 10:34.920
那么他就是一个冻结的东西

10:35.160 --> 10:36.360
他就是没有冻结的东西

10:37.400 --> 10:42.280
好这边呢我有两个按钮点这个按钮第一个按钮的话就夹载普通数据

10:42.600 --> 10:45.960
我叫用这个方法我就把这个东西呢变成一个拿到数据

10:46.680 --> 10:49.800
点这个按钮呢我就夹载了个冻结冻结的就是数据

10:50.760 --> 10:51.800
啊哪有这

10:52.760 --> 10:56.360
然后页面上显示什么东西呢其实啥都没显示啊显示个非常简单的东西

10:56.520 --> 11:00.200
也就是说显示了一个普通对象数据的长度一个冻结对象的数据的长度

11:00.440 --> 11:01.720
我们主要是观察

11:03.160 --> 11:04.760
他的解释执行时间

11:05.480 --> 11:05.800
啊

11:06.600 --> 11:08.040
来我们的页面上去看一下

11:08.680 --> 11:09.960
运营出来了打开

11:11.240 --> 11:12.600
点击右键检查

11:12.840 --> 11:17.960
我们可以找到我们的流量器工具里面呢有一个性能性能工具啊Performance

11:18.840 --> 11:19.240
找他

11:20.040 --> 11:23.080
这里呢我们可以点点击开始录制啊Record

11:23.720 --> 11:25.000
接下来我们点第一个按钮

11:25.400 --> 11:25.880
夹载

11:31.770 --> 11:33.290
有这么久吗好夹载出来了

11:33.530 --> 11:34.570
接下来我们点第二个按钮

11:34.970 --> 11:35.370
夹载

11:37.130 --> 11:38.410
好可以其实可以从

11:39.370 --> 11:40.250
我们不用去

11:40.490 --> 11:43.690
不用去精确的计时都可以感觉到这里边

11:44.250 --> 11:46.010
经过的时间是不是他要小得多

11:46.810 --> 11:48.490
好这里呢我们性能的性能

11:49.050 --> 11:50.890
分析出来了啊分析报告出来了

11:51.370 --> 11:54.730
那么我们这里呢可以用这个滑动窗口啊看一下我们的

11:54.970 --> 11:59.690
性能就是我们经就是从个点击这个录制开始啊到我们停止

11:59.930 --> 12:00.410
中间

12:01.130 --> 12:02.890
他的性能发生了哪些事情啊

12:03.450 --> 12:04.490
这里边呢我们

12:05.290 --> 12:06.330
主要关注的是

12:07.450 --> 12:07.850
这一图

12:08.890 --> 12:09.850
就是有这个啊

12:10.090 --> 12:10.970
有这个

12:11.210 --> 12:11.690
叫什么

12:11.930 --> 12:12.970
这个叫什么图啊这个

12:13.610 --> 12:15.290
就是有有这个就是

12:16.330 --> 12:19.130
波浪图的这个地方那么就是性能出问题的地方

12:19.770 --> 12:22.490
啊其实上面这个红线预议也提示你这里有性能问题

12:23.450 --> 12:24.490
那么我们来看一下啊

12:24.730 --> 12:26.330
第一是我们点这个按钮的时候

12:26.970 --> 12:28.330
他经过的时间是这么一段

12:28.970 --> 12:31.050
从下面我们可以看到他经过的时间是

12:31.690 --> 12:33.130
脚笨的执行时间

12:33.370 --> 12:37.930
啊因为他这里面基本上没有渲染时间因为渲染的东西很简单因为他没有什么东西啊可以渲染

12:38.170 --> 12:40.730
所以主要是脚笨执行的时间经过多好了

12:40.970 --> 12:45.370
经过了6660啊就6秒多才能把个脚笨执行完

12:45.850 --> 12:48.890
而另外一方面呢到这边啊就第二次点击的时候

12:49.610 --> 12:55.850
点这个按钮的时候啊你看这个黄色这个黄色什么意思这个黄色就是脚笨执行的时间啊主要都是脚笨在执行

12:56.090 --> 12:57.290
他只经过了一秒钟

12:57.850 --> 12:59.690
那么这个性能损失在哪呢

13:00.090 --> 13:01.690
性能损失其实就是在

13:02.010 --> 13:03.690
转换响应是数据的一块

13:04.090 --> 13:05.450
我们有100万个对象

13:05.690 --> 13:11.610
如果说里面没有把这个数据冻结的话那么他会首先把这个数据变成响应式那么这个只有一次没关系

13:12.090 --> 13:13.130
那么接下来就是对这个

13:13.370 --> 13:15.450
数据表每一个对象要把它变成响应式

13:15.690 --> 13:20.570
而变成响应式的时候还要变的对象里面的每一个属性如果说属性啊你还是对象还要去变的他

13:21.050 --> 13:25.930
其实没有必要如果说你这个对象他只是为了显示他并不会变化

13:26.170 --> 13:27.210
那么其实没有必要

13:27.850 --> 13:31.050
但是你一定要注意啊虽然说性能提高了他带来了一个

13:32.090 --> 13:34.650
情况就是这个对象他不再是响应式的

13:35.130 --> 13:40.170
也就是如果说你有一些想我这个数据里面加一个加一项加一个数据不好意思你加不了

13:40.970 --> 13:42.010
因为他不是响应式的

13:42.810 --> 13:47.610
不要理智吧如果说你要改变这个对数据里面某一项的对象里面的一个属性

13:48.570 --> 13:50.250
不好意思他也不是响应式的

13:50.490 --> 13:53.530
其实呢我们可以从控制台里面输出的结果可以看得出来啊

13:54.010 --> 13:56.010
我们可以看到输出了normal data

13:56.250 --> 13:58.410
普通对象里面展开啊随便展开一个

13:59.050 --> 14:00.650
你看他是一个响应式数据对吧

14:00.970 --> 14:02.650
所在数据本身是响应式的

14:02.970 --> 14:07.770
然后呢数据里面每一项的对象他是真路遍地他也是一个响应式的你看我不走

14:08.810 --> 14:12.650
这里面你看每个属性都是响应式的这个属性里面他也是响应式的

14:13.290 --> 14:14.410
然后我们再看这边

14:16.970 --> 14:21.050
所以不是响应式的数据本身不是响应式数据里面每一项也不是响应式

14:21.690 --> 14:22.090
看到没

14:22.970 --> 14:27.770
因此你如果说将来你真的想改变他的话那不好意思你他不会

14:28.010 --> 14:30.010
你可以改但是呢页面上不会有任何变动

14:30.170 --> 14:31.290
因为他不是响应式

14:32.250 --> 14:35.290
这是关于这一点啊大家要明确

14:36.490 --> 14:38.490
好这是使用动机推向

14:39.370 --> 14:46.010
下一个使用函数式逐渐啊这里呢有一个官方文章的链接你可以去看一下啊函数式逐渐

14:47.290 --> 14:53.610
就是啥意思呢就是有的时候啊我们一个组件他可能只是为了把属性你给我传过来的一些属性

14:53.610 --> 14:58.730
啊比方说你给我传个一个文章对象我只是负责了把这个文章对象用一个界面给他显示出来

14:59.690 --> 15:06.010
我不会去改变改变任何东西啊我也我也不需要用用到什么样的生命周期函数

15:06.650 --> 15:10.570
我也没有自己的data那么像这样的一个组件呢

15:11.370 --> 15:14.090
其实是没有必要去创建一个组件实力的

15:15.210 --> 15:19.210
我们都学过啊5u里边对一个每一个组件都会去溜一个

15:19.610 --> 15:23.050
5u对吧来创建一个组件实力他实际上溜的是5ucomponent

15:23.930 --> 15:25.930
那么其实本质上也就是5u嘛

15:26.090 --> 15:29.130
他会去溜一个5u创建一个5u的组件的实力

15:30.250 --> 15:33.290
但是有些组件其实根本就没必要他没有什么状态

15:34.170 --> 15:35.850
根本就没有什么状态需要维护

15:36.890 --> 15:41.610
他只是把他显示出来那么像这种东西呢你可以避免他

15:42.010 --> 15:47.050
避免就是告诉5u你不要去创建组件实力的怎么告诉呢你就使用函数式组件

15:47.690 --> 15:51.370
函数式组件就没有这时没有生命周期函数

15:52.090 --> 15:56.330
他只是为了他只是给我传递一些数据传递一些属性过来

15:56.650 --> 15:58.250
然后呢我把界面显示出来就完事了

15:58.810 --> 16:00.410
用法非常简单啊有心就可以看一看

16:01.450 --> 16:02.650
然后这边呢我做了个例子

16:08.480 --> 16:08.880
看一下啊

16:09.760 --> 16:10.480
先把运行出来

16:14.240 --> 16:15.040
还是组件啊

16:15.680 --> 16:17.920
这边呢我有个两个组件一个是普通组件

16:18.320 --> 16:22.080
这个普通组件呢就是他要做的事情非常简单我就显示一个东西

16:22.640 --> 16:25.040
显示一个我传一个东西进来一个数字我就显示出来

16:25.760 --> 16:28.480
然后另外一个呢因为我发现这个组件根本就没有意义

16:28.720 --> 16:33.360
他根本就没有必要去创建实力他又没有那个生命周期又没有自己的data

16:33.840 --> 16:36.800
创了个实力干嘛呀那我就赶紧把它做成一个函数式组件

16:37.280 --> 16:39.920
写法非常简单给他配置加一个方形的

16:40.320 --> 16:43.360
所谓q然后呢模板里边加一个方形的就ok了

16:44.160 --> 16:45.200
那么函数式组件

16:45.920 --> 16:49.280
他就没有意思了你这里边你不能写生命周期函数啊没用的

16:49.520 --> 16:53.360
然后这边呢使用属性的时候呢一要加上一个属性的名字而叫probs

16:54.080 --> 16:57.200
不能不能像那个普通组件那样直接使用了啊加上一个probs

16:57.440 --> 16:57.920
the card

16:58.400 --> 17:01.760
再使用那么这样子的函数组件他是不会创建实力的啊

17:02.320 --> 17:05.280
接下来我们来看一下啊在app里边呢我就用这两个组件

17:05.760 --> 17:06.480
呃这边

17:08.910 --> 17:14.510
我点击第一个按钮我就生成一万个普通组件点掉来呢我就生成一万个函数组件

17:15.870 --> 17:22.990
好那么我下面呢写了两个div啊一个div呢我就循环很多次啊这里是一个数字这个数字在这

17:23.630 --> 17:26.190
我一开始都是0啊一开始都是0

17:26.750 --> 17:32.510
呃然后呢我点击第一个按钮的时候我就把它复制为一万这个按钮的时候我会把这个属性复制为一万

17:32.830 --> 17:36.910
因此呢我这边就循环这个循环一万只相当于是一开始是零次啊一开始啥都没显示

17:37.230 --> 17:40.510
然后点了第一个按钮过后我就循环了一万次啊可以这样写啊

17:40.910 --> 17:43.230
印后面跟跟跟一个数字那么这个

17:43.630 --> 17:48.430
他就会循环这么多次每次循环呢从一开始啊把从把只能从这个取出来

17:48.990 --> 17:50.830
啊相当于是个货循环便利

17:51.630 --> 17:52.910
啊这个给他个提示啊

17:53.150 --> 17:57.870
然后呢这边靠着传进去啊他不是削个属性吗我们这里的渲染的是普通逐渐

17:58.270 --> 18:01.630
渲染一万次普通逐渐那这边的同样的道理渲染一万次

18:02.510 --> 18:03.310
函数式逐渐

18:04.510 --> 18:07.790
啊用法都是一样的啊用法的传出去的都是一样的用法

18:09.230 --> 18:11.230
好那么我们来看一下他们的效率啊

18:11.870 --> 18:13.070
接下来打开他

18:14.510 --> 18:18.030
同样道理啊我们这边呢去分析一下行程吧弄下来了

18:20.650 --> 18:23.610
好征程哎这边performance打开啊难度之

18:24.410 --> 18:25.690
生成一万个普通逐渐

18:26.250 --> 18:27.690
生成一万个函数逐渐

18:28.970 --> 18:31.130
哎感觉上好像差不多对吧我们停止

18:31.530 --> 18:32.730
其实我们可以看到这个

18:33.290 --> 18:34.330
分析里边的差异

18:35.450 --> 18:37.770
感觉差不多呢是因为他们渲染的

18:38.410 --> 18:41.290
东西都差不多因为都要渲染一万次吧怎么叫渲染

18:42.010 --> 18:46.410
我这里说的渲染不是五球的那个render啊我这里说的渲染是这个

18:46.730 --> 18:50.170
指的这个意思就是浏览器把它画出来是不是都要画一万次

18:50.650 --> 18:53.370
对吧这边都要画一万都要画一万次很多啊

18:54.330 --> 18:57.130
所以说他画的画的个界面需要时间

18:57.690 --> 19:00.890
你看那个紫色的区域这紫色区域是啥呀叫render

19:01.290 --> 19:03.290
这指的不是那个无忧的render啊

19:03.530 --> 19:06.970
是浏览器要生成动物元素一个个把动物元素夹进来

19:07.210 --> 19:12.250
然后是不是要构建一个动物树然后就构建一个CSS树对吧这个地方画的时间

19:13.370 --> 19:16.730
哪绿色才叫panning panning才是具体的把这个东西画出来

19:16.970 --> 19:20.970
render呢指的是生成那个动物树生成CSS树生成渲染树

19:21.370 --> 19:22.570
这个地方画的时间

19:22.970 --> 19:23.610
没了意思吧

19:24.490 --> 19:28.810
那么你看紫色的其实都差不多的对吧但是呢黄色部分是什么

19:29.290 --> 19:30.170
脚本执行时间

19:30.730 --> 19:32.010
黄色部分是不是有差异

19:32.410 --> 19:35.850
因为看到由于函数是主由于那个

19:36.570 --> 19:38.490
呃普通组建

19:39.050 --> 19:40.410
第一次我们点了普通组建吗

19:40.970 --> 19:42.330
是不是黄色区域要多一些

19:42.730 --> 19:44.810
他执行的时间461毫秒

19:45.690 --> 19:47.210
然后这边呢我们看一下这边

19:47.930 --> 19:50.730
他执行的时间269毫秒是不是要少一些啊

19:51.450 --> 19:54.570
对吧因为他创建创建对象需要花费一定时间

19:54.810 --> 19:55.610
创建无忧实力

19:55.850 --> 19:58.170
因为创建一个无忧实力是不是要经过各种生命周期

19:58.410 --> 20:00.170
还要做不同的事情我们之前讲过啊

20:00.410 --> 20:03.050
一个无忧组建的完整生命周期是不是有很多事情要做

20:03.850 --> 20:06.810
这样这里呢由于是函数组建他很多事情就不会做了

20:07.130 --> 20:07.690
他少一些

20:08.810 --> 20:11.770
然后呢其实内存消耗了也可以看到要少很多

20:12.490 --> 20:15.050
你看下面一个内存的增长进度

20:15.770 --> 20:19.210
一开始内存在这你看然后增长到增长到这了

20:19.690 --> 20:20.170
看呗

20:20.650 --> 20:22.970
然后呢这边内存是不是增长要少一点

20:23.770 --> 20:24.250
对不对

20:24.810 --> 20:27.210
内存增长要少一点啊就这么个意思

20:27.850 --> 20:29.130
好这是关于这个

20:29.610 --> 20:32.410
函数组建和普通组建

20:33.450 --> 20:34.090
好下一个

20:34.730 --> 20:35.930
使用计算属性

20:36.250 --> 20:37.370
这指的是啥意思啊

20:37.850 --> 20:41.130
就是这个东西就没什么好说的我进来解释一下就行了

20:41.450 --> 20:44.810
就是比方说你的模板里边可能要用到很多次有某一个数据

20:45.530 --> 20:47.690
比方说我要对一个东西呢求

20:48.170 --> 20:52.490
我对一个金额啊我的界面上出现很多次这样的金额同一个金额啊

20:53.370 --> 20:57.050
我们可能一个div里边要显示这么一个金额这个金额呢

20:58.570 --> 21:00.890
我可能要做的事情特别简单我就是把他

21:01.690 --> 21:05.450
保留两位小数啊就比方说做这么一件事啊保留两位小数

21:06.250 --> 21:08.330
那么这里呢我显示同一个金额

21:08.890 --> 21:09.290
money

21:10.090 --> 21:10.890
to text

21:11.770 --> 21:13.130
二保留两位小数

21:13.530 --> 21:17.050
哎一会呢我有个p元数他也要显示同一个数据啊

21:18.330 --> 21:20.330
显示同一个数据也要保留两位小数

21:21.050 --> 21:22.090
那么都是一样的

21:22.650 --> 21:25.210
如果说你在模板里边有大量的这样的内容的话

21:25.610 --> 21:26.970
都是同一个数据的时候

21:27.450 --> 21:29.450
那么这个时候建议使用计算属性

21:29.770 --> 21:32.890
为什么呢他避免在模板里面反复的去运算这个函数

21:33.290 --> 21:35.850
当然我这个函数比较简单那如果说他比较

21:36.650 --> 21:38.650
复杂这个运算过程比较耗时间

21:39.290 --> 21:40.410
那么就比较麻烦了

21:40.410 --> 21:42.090
那你可能会把封装成一个方法

21:42.330 --> 21:43.930
然后传个参数进去来雕用

21:43.930 --> 21:46.970
那么这个时候呢就尽量考虑使用计算属性来解决这个问题

21:48.010 --> 21:48.650
没啥意思吧

21:50.010 --> 21:54.810
当然这只是尽量啊有的时候呢因为计算属性有他自己的缺陷

21:54.810 --> 21:56.330
怎么缺陷了就是他不能喘参

21:57.850 --> 21:59.850
他无法喘参如果说你要根据不同的情况

21:59.850 --> 22:02.490
我要得到不同的东西的话那还不如把他弄成方法

22:03.690 --> 22:06.250
这是使用计算属性的因为计算属性是有缓存的啊

22:07.850 --> 22:10.570
然后下一个非实时绑定的表达项

22:11.050 --> 22:11.770
这啥意思呢

22:12.170 --> 22:14.730
其实我们在上节课学习动画的时候

22:15.210 --> 22:16.570
就已经看到这个问题了啊

22:16.650 --> 22:19.370
我们来阅读一下这个我给大家写的这个文档

22:19.370 --> 22:22.250
当我们使用vmode来绑定和表达项的时候

22:22.250 --> 22:23.610
最常见的是input元素

22:24.250 --> 22:26.890
那么这个时候当用户改变表达上的状态的时候

22:26.890 --> 22:29.050
比方用户在input元素里面打东西打字

22:29.930 --> 22:31.770
每一次input状态的变化

22:32.410 --> 22:35.930
是不是都会导致无忧的数据发生变化

22:35.930 --> 22:37.290
因为他们是双向绑定的

22:37.770 --> 22:41.610
对吧每一次input事件的发生

22:41.610 --> 22:43.130
那么还会导致数据发生变化

22:43.930 --> 22:46.010
而数据一变无忧是不是要发生重现染

22:46.250 --> 22:46.730
vender

22:47.450 --> 22:48.890
那就摘了一些性能上的开销

22:49.290 --> 22:50.730
因为我们打字的数据很快

22:51.050 --> 22:52.650
那么导致的不断的再重新宣传

22:53.610 --> 22:55.050
而更严重的是什么呢

22:55.050 --> 22:56.330
如果说你这个时候

22:56.730 --> 22:58.330
你在打字的时候

22:58.330 --> 23:00.570
一面上有一些动画正在进行中

23:01.210 --> 23:04.490
由于GS执行现成和浏览器的渲染现成是互赤的

23:04.490 --> 23:05.050
这个知道吧

23:06.090 --> 23:07.210
我们介石的执行

23:07.210 --> 23:09.290
介石在执行的时候浏览器是没发宣传的

23:10.170 --> 23:12.090
换句话说另外呢浏览器正在宣传中的时候

23:12.090 --> 23:13.210
GS是无法执行的

23:14.090 --> 23:15.850
所以有的时候你看到

23:16.250 --> 23:19.370
一面上有一些卡顿没发一个按钮没发点的

23:19.370 --> 23:20.890
或者是滚动条没发滚动了

23:21.290 --> 23:22.570
那么说这个时候呢

23:22.730 --> 23:24.970
使之吧有很多介石代码正在执行

23:24.970 --> 23:26.490
或者是进入了某些使循环

23:26.490 --> 23:27.290
它不停的执行

23:27.770 --> 23:29.450
那么浏览器无法进行宣传的

23:29.450 --> 23:30.330
你滚动没用

23:30.330 --> 23:31.770
它没发给你画出来

23:32.330 --> 23:34.170
你看到了所有东西都是浏览器

23:34.490 --> 23:36.330
用个笔给你画出来的

23:36.330 --> 23:37.930
你滚动一下它自己重新画一下

23:37.930 --> 23:39.210
滚动一下自己重新画一下

23:39.530 --> 23:41.130
它没发画了你就没发滚动了

23:41.130 --> 23:42.090
你没发点了

23:42.250 --> 23:43.690
对吧这些事情都没发错了

23:43.690 --> 23:44.570
所以导致

23:44.570 --> 23:46.330
那么有动画正在发生的时候

23:46.330 --> 23:49.130
如果说我们用微墨的绑定的表达项

23:49.130 --> 23:50.410
不断的再被改变

23:50.410 --> 23:52.250
那么这个时候动画会出现卡顿

23:53.610 --> 23:54.890
这个时候怎么来解决这个问题呢

23:54.890 --> 23:55.690
你可以使用Lazy

23:55.690 --> 23:57.210
我们讲过的微墨的一个修饰服

23:57.210 --> 23:57.690
Lazy

23:57.690 --> 23:59.290
Lazy就是它失去击凹点的时候

23:59.290 --> 24:00.250
我再去变化数据

24:00.730 --> 24:03.130
还有一种方法呢就是不用微墨的

24:03.530 --> 24:04.490
那么来看一下

24:06.360 --> 24:07.240
第三个例子

24:12.300 --> 24:12.780
三

24:13.740 --> 24:14.540
映出来

24:16.140 --> 24:16.860
先看待嘛

24:18.960 --> 24:20.000
这有两个组件啊

24:20.000 --> 24:21.440
一个是不使用微墨的

24:21.440 --> 24:22.560
一个是使用微墨的

24:22.560 --> 24:23.840
这两个组件做的事情

24:24.320 --> 24:26.480
我们之前就是我们上节课做的事情

24:27.280 --> 24:29.760
上节课我们做了个动画的时候

24:29.760 --> 24:30.560
是不是做了一个

24:35.610 --> 24:36.810
这个都不用虚心的分析了

24:36.810 --> 24:37.930
一看就看出来了

24:37.930 --> 24:39.690
左边是使用微墨的

24:39.690 --> 24:41.130
上节课我们是看到这个问题

24:42.330 --> 24:45.130
我现在把时间放长了

24:45.130 --> 24:45.690
放了5秒

24:45.690 --> 24:47.130
你看我这里打字的时候

24:47.690 --> 24:49.450
它只能在打字的间隙里面

24:49.610 --> 24:51.050
可以运行一下画一下动画

24:52.010 --> 24:53.290
这个打字的时候是没法画的

24:53.290 --> 24:54.250
你看5秒找过了

24:55.130 --> 24:55.770
为什么呢

24:55.770 --> 24:58.170
因为我们在触发打字的时候

24:58.170 --> 24:59.610
是在不断改变它的数据

24:59.610 --> 25:01.210
而改变它的数据的时候

25:02.330 --> 25:03.610
会在运行界野式

25:04.170 --> 25:05.210
会运行重渲

25:05.210 --> 25:06.330
重渲就是运行界野式

25:06.970 --> 25:07.930
重新生成虚拟动

25:08.330 --> 25:08.730
对不对

25:09.690 --> 25:11.930
把这个组件重新绘制一遍

25:13.450 --> 25:14.730
所以说导致了

25:14.730 --> 25:16.730
它的动画就被卡顿

25:16.730 --> 25:17.850
所以待嘛不讲了

25:17.850 --> 25:19.050
我们之前使用的是微墨的

25:19.770 --> 25:21.770
现在我们第二个是不使用微墨的

25:21.770 --> 25:23.770
把我们的app里面就使用两个组件

25:23.770 --> 25:24.810
一个使用微墨的

25:24.810 --> 25:25.850
一个不使用微墨的

25:26.330 --> 25:28.170
我这里就没有使用微墨的

25:28.730 --> 25:29.610
你看我怎么做的

25:30.330 --> 25:31.610
你看这里没有绑定微墨的

25:31.930 --> 25:33.290
没有绑定微墨的时候

25:33.290 --> 25:36.490
当我们点击按下键盘的inter件的时候

25:37.130 --> 25:38.010
它调用这个方法

25:38.970 --> 25:40.970
你看我们的数据里面也没有那个数据的

25:40.970 --> 25:41.530
你看这边

25:44.430 --> 25:46.430
我这里不是一个数据吗

25:46.430 --> 25:48.350
跟那个界面上进行双向绑定

25:48.510 --> 25:49.310
那么这边

25:50.190 --> 25:51.870
我就没有那个数据了

25:51.870 --> 25:53.230
而我是点击的时候

25:53.230 --> 25:55.230
它不是给我传了一个实践参数亿吗

25:55.790 --> 25:56.190
对不对

25:56.190 --> 25:56.830
这个知道吧

25:57.390 --> 25:58.350
传了一个实践参数亿

25:58.350 --> 25:59.790
我通过实践参数亿的talkies

25:59.790 --> 26:00.830
什么拿到实践员

26:00.830 --> 26:02.190
就是普通的动物操作

26:02.670 --> 26:04.190
从动物对象里面拿到这个Value

26:05.070 --> 26:06.270
呈成个临时面量

26:06.670 --> 26:09.470
然后我把这个纸放了个260里面去

26:10.030 --> 26:11.150
我回车的时候搞定了实践

26:11.150 --> 26:12.030
然后我手动的把

26:12.430 --> 26:13.790
手动的把这个动物对象的Value

26:13.790 --> 26:14.510
稍微控制住圈

26:15.230 --> 26:16.510
看来我是用这种方式来做的

26:16.510 --> 26:17.390
就没有使用微墨

26:18.110 --> 26:19.310
那么这样子的我们来看一下吧

26:22.300 --> 26:23.100
这样子我们回车

26:23.660 --> 26:24.700
你看我现在不停的打

26:25.180 --> 26:26.060
有影响动画吗

26:26.940 --> 26:27.260
没有

26:28.380 --> 26:29.420
并不会影响动画

26:31.610 --> 26:32.810
我并不会影响动画

26:32.810 --> 26:33.690
哪个边也不一样

26:33.690 --> 26:33.930
你看

26:35.610 --> 26:35.930
你看

26:36.570 --> 26:37.610
都是5秒那么动画

26:37.610 --> 26:38.810
我放手如何开始快乐

26:38.810 --> 26:40.090
但是我一打字就慢了

26:41.050 --> 26:43.050
看来这就是这一点的区别

26:43.450 --> 26:46.250
当然并不是说你们以后都不要使用微墨的

26:46.250 --> 26:47.610
微墨的又没有好处了

26:47.610 --> 26:48.810
微墨的又好处

26:48.810 --> 26:50.890
微墨的是比较符合Value的架构

26:50.890 --> 26:52.170
实际上是没有思想的

26:53.450 --> 26:54.730
Value架构实际上是什么

26:54.730 --> 26:58.570
我应该关注的是数据而不是界面

26:58.810 --> 27:01.130
界面是根据数据生成出来的

27:01.770 --> 27:03.450
而我们现在不是用微墨的的话

27:03.450 --> 27:04.970
我们看是不是关心到界面的

27:04.970 --> 27:06.490
我是拿到动物对象来操作了

27:06.490 --> 27:07.530
看了没

27:08.170 --> 27:09.850
是不是拿到动物对象来操作了

27:11.050 --> 27:13.930
这不是不符合Value的设计理念

27:13.930 --> 27:15.450
但是有的时候呢为了效率呢

27:15.450 --> 27:17.770
我们也可以采取这么一个折中的办法

27:18.010 --> 27:18.810
当然呢

27:19.050 --> 27:20.330
你不要走火入魔

27:20.890 --> 27:23.450
维护性和代码的口阅读性

27:23.450 --> 27:27.050
这一点仍然是非常非常重要的

27:27.290 --> 27:29.850
甚至有的时候比效率还要重要

27:29.850 --> 27:34.810
所以这个中心你要去平衡

27:34.810 --> 27:36.330
好这是

27:36.330 --> 27:39.690
当然这一点还有些隐患就是

27:39.690 --> 27:41.450
它可能在某一个时间点

27:41.450 --> 27:43.050
比方说你使用Lazy

27:43.050 --> 27:45.290
它必须要使用失去焦点的时候

27:45.290 --> 27:47.370
才会变化数据对吧

27:47.370 --> 27:49.850
那么如果说没有失去焦点的时候

27:49.850 --> 27:51.450
它可能就稳闷框里面显示东西

27:51.450 --> 27:54.010
那么的数据就保持了就是不一致的

27:54.010 --> 27:58.140
好这说说一块

27:58.140 --> 28:04.500
下一个保持对象

28:04.500 --> 28:07.580
引用稳定这个其实很简单

28:07.580 --> 28:10.140
Value触发重宣的时机

28:10.140 --> 28:13.740
它是因为这个模板里的一带的数据发生了变化

28:13.740 --> 28:16.540
我用到了一个Name变了我就要重新宣了

28:16.540 --> 28:19.100
那如果说数据没有变化

28:19.100 --> 28:21.660
哪怕你给数据重新复制了

28:21.660 --> 28:24.220
Value它也不会做任何的处理

28:24.220 --> 28:26.540
那么它到底是怎么判断的

28:26.940 --> 28:27.820
它不是唯一一带

28:27.820 --> 28:31.760
是唯有圆码里面给大家解决出来的

28:31.760 --> 28:32.800
它怎么来判断的

28:32.800 --> 28:36.000
它这样判断的就是Value是新的值

28:36.000 --> 28:37.200
这个玩意表示新的值

28:37.200 --> 28:39.120
你要重新给它复制的时候它新的值

28:39.120 --> 28:40.480
因为它用的是setter函数

28:40.480 --> 28:43.040
这个代码就写到setter里面了

28:43.040 --> 28:46.080
新的值如果跟旧的值是一样的

28:46.080 --> 28:47.920
它是用三个等号来比较的

28:47.920 --> 28:49.440
也就是说类型一样

28:49.440 --> 28:52.720
如果说对象的话对象引用地址也一样

28:52.720 --> 28:54.800
或者是Value不等于Value

28:54.800 --> 28:56.880
Value不等于Value这啥意思

28:56.960 --> 29:00.480
就是搞定NAN那种神奇的状况

29:00.480 --> 29:03.280
这个你可以不用看了

29:03.280 --> 29:04.000
不用管它

29:04.000 --> 29:05.600
就是这个东西

29:05.600 --> 29:06.880
两个值一样的时候

29:06.880 --> 29:08.720
它是不会做任何处理的

29:08.720 --> 29:10.320
就相当于是你给它复制的

29:10.320 --> 29:12.000
跟没复制是一样的

29:12.000 --> 29:13.840
就比方说有一个数据

29:13.840 --> 29:16.320
在它里面一个数据

29:16.320 --> 29:18.400
它一开始是A等于E

29:18.400 --> 29:20.800
后来你给它Z10点A又复制为一个E

29:20.800 --> 29:23.040
这个时候是不会导致重篇来的

29:23.040 --> 29:24.320
因为它又这样就代码

29:24.320 --> 29:25.520
它发现两个相同

29:25.680 --> 29:27.040
那么就直接写出了

29:28.160 --> 29:29.840
所以说我们有的时候

29:31.520 --> 29:34.160
这种情况其实我们平时也不太会遇到

29:34.160 --> 29:37.600
就是出现没有必要的渲染

29:37.600 --> 29:40.400
但是有的时候你会写一些非常奇心怪状的代码

29:40.400 --> 29:41.520
可能会导致这个问题

29:42.640 --> 29:43.760
不仅是数据

29:43.760 --> 29:45.520
属性的都是一样的

29:45.520 --> 29:46.640
属性如果说

29:46.640 --> 29:48.960
它发现两次属性的值是一样的

29:48.960 --> 29:50.640
它不会导致重新渲染的

29:50.640 --> 29:51.680
因为我们知道

29:51.680 --> 29:53.760
新旧两棵树生成新树的时候

29:53.760 --> 29:56.240
那个组建里边有些目前的属性

29:56.240 --> 29:57.680
那么它会给它复制

29:57.680 --> 30:00.240
给那个当前的组建实力的属性复制

30:00.240 --> 30:01.920
因为属性也是相应式的

30:01.920 --> 30:04.160
一复制它会也会进行对比

30:04.160 --> 30:05.680
如果说两个值一样

30:05.680 --> 30:06.960
它就不会进行宣传

30:08.800 --> 30:10.480
好 我们来看一下

30:10.480 --> 30:11.680
看一下这个例子就明白了

30:21.680 --> 30:22.800
这个例子呢

30:22.800 --> 30:23.760
我做的比较全面

30:23.760 --> 30:24.640
我这里用那个mock

30:24.640 --> 30:26.560
就表模拟服务器返回的数据

30:27.680 --> 30:28.480
你看一下吧

30:28.480 --> 30:29.280
我们先看一下

30:29.280 --> 30:30.240
我们做的效果出来

30:33.720 --> 30:34.840
好 这里呢就是

30:36.680 --> 30:38.360
第一个左边也是一个例子

30:38.360 --> 30:39.000
右边一个例子

30:39.000 --> 30:40.280
它功能都是完全一样的

30:40.280 --> 30:41.720
都是从服务器拿到数据

30:41.720 --> 30:42.840
拿到一些评论列表

30:43.400 --> 30:45.320
这是某个用户名评论的内容

30:45.320 --> 30:47.000
当然我这里数据全是模拟的

30:47.720 --> 30:48.360
全是模拟的

30:48.360 --> 30:49.240
你们可以自己去看一下

30:49.240 --> 30:50.200
这些模拟代码

30:50.200 --> 30:52.520
没什么好说的

30:52.520 --> 30:53.720
它提供了两个API

30:53.720 --> 30:56.120
一个是用get请求请求这个地址

30:56.120 --> 30:58.520
那么表示拿去目前的所有评论

30:58.680 --> 31:00.360
又poster请求去请求这个地址

31:00.360 --> 31:02.760
表示我目前要添加一个评论

31:03.560 --> 31:04.360
好 我们来看一下

31:07.150 --> 31:08.670
现在我们有一个组件

31:08.670 --> 31:09.630
这个组件很简单

31:09.630 --> 31:10.590
特别简单

31:10.590 --> 31:12.670
我就是显示

31:12.670 --> 31:14.270
当一个传一个属性进来

31:14.270 --> 31:15.310
一个传一个就是

31:15.950 --> 31:17.230
评论对象进来

31:17.230 --> 31:19.070
我显示出来的哪个用户

31:19.070 --> 31:20.990
帽号评论的内容是什么

31:21.550 --> 31:22.030
简单吧

31:23.070 --> 31:25.310
然后为了看到这个组件

31:25.310 --> 31:26.510
到底有没有重宣的

31:27.710 --> 31:28.590
我这里呢

31:28.670 --> 31:30.030
设置了一个十变元数

31:30.030 --> 31:31.150
颜色为红色

31:31.150 --> 31:33.070
这里的设置了一个Renderer

31:33.070 --> 31:34.830
表示重宣的次数

31:34.830 --> 31:35.790
一开始是0嘛

31:35.790 --> 31:36.750
一开始是

31:36.750 --> 31:37.870
夹在的时候宣展的一次

31:37.870 --> 31:38.830
那个不叫重宣的

31:38.830 --> 31:39.710
叫宣展

31:39.710 --> 31:41.470
我们就开始重宣的就设为0

31:41.470 --> 31:42.190
什么叫重宣的

31:42.190 --> 31:44.110
就是它的属性变化

31:44.110 --> 31:45.310
导致的宣展

31:45.310 --> 31:46.350
或者是

31:46.350 --> 31:48.830
data变化导致的宣展

31:48.830 --> 31:49.630
这叫重宣的

31:50.510 --> 31:51.630
好 当它

31:51.630 --> 31:53.710
当它属性变化

31:53.710 --> 31:54.750
导致重宣的时候

31:54.750 --> 31:56.510
它会运行这个神秘车去勾字函数

31:56.510 --> 31:57.310
对吧

31:57.310 --> 31:58.190
在我们更新

31:58.190 --> 31:59.390
就是在运行Renderer之前

31:59.390 --> 32:00.190
它会运行这个

32:01.230 --> 32:02.190
那么这个时候呢

32:02.190 --> 32:03.550
我把Renderer加加

32:03.550 --> 32:06.270
表示这里已经重宣展的一次了

32:06.270 --> 32:07.150
那么这个十变元数

32:07.150 --> 32:08.110
它就显示的是

32:08.110 --> 32:09.550
目前这个组件

32:09.550 --> 32:10.350
它被宣展了多少

32:10.350 --> 32:11.470
重宣展了几次

32:11.470 --> 32:12.190
一开始是0

32:12.190 --> 32:13.790
0的话就不显示

32:13.790 --> 32:15.470
它有值的时候才显示

32:15.470 --> 32:16.590
显示它重宣的几次

32:17.470 --> 32:18.190
就这么个意思

32:18.830 --> 32:20.830
好 今天我们看一下这个App组件

32:20.830 --> 32:21.950
这个App组件我在做什么

32:21.950 --> 32:23.230
央视也不用看了

32:24.750 --> 32:26.590
我这里提供了两个API方法

32:26.670 --> 32:29.390
这个跟我们现实的里边也是一样

32:29.390 --> 32:30.350
只不过现实情况

32:30.350 --> 32:31.950
我们一般是把它放到一个文件夹

32:31.950 --> 32:33.310
叫API文件夹里边去的

32:33.310 --> 32:33.790
对吧

32:33.790 --> 32:34.910
也生成一些模块

32:34.910 --> 32:35.790
通过模块来

32:35.790 --> 32:36.830
导入调用的

32:36.830 --> 32:37.870
最后为了看得清楚

32:37.870 --> 32:38.590
就写到这了

32:38.590 --> 32:39.470
一样的道理

32:39.470 --> 32:40.670
我就用一个actuals

32:41.310 --> 32:42.350
去请求注意

32:42.350 --> 32:43.790
这里不能用废棋

32:43.790 --> 32:44.670
为什么不能用废棋

32:44.670 --> 32:45.390
因为这个mock

32:46.590 --> 32:47.550
它不能mock废棋

32:48.270 --> 32:49.070
mock的是i

32:49.070 --> 32:50.510
它只能mock了一个传统的

32:50.510 --> 32:52.350
插mail, HTTP request

32:52.350 --> 32:53.790
只能mock那个东西

32:53.790 --> 32:55.390
它把那个东西给给i了

32:55.390 --> 32:56.110
但是actuals

32:56.110 --> 32:57.470
它用的就是那个东西

32:57.470 --> 32:58.430
所以说用actuals

32:58.430 --> 32:59.550
我这里没有用那个废棋

33:00.430 --> 33:01.150
用废棋的话

33:01.150 --> 33:02.990
你肯定要找一些别的mock废棋

33:03.230 --> 33:04.350
这个东西好像不行了

33:05.710 --> 33:05.950
好

33:05.950 --> 33:07.310
这个就是actuals

33:07.310 --> 33:08.350
我们这里get

33:09.070 --> 33:09.630
请求这个

33:09.630 --> 33:11.150
是不是拿到所有的评论

33:11.150 --> 33:11.470
对吧

33:11.470 --> 33:12.510
这个代码没什么好说的

33:12.990 --> 33:14.270
然后天价一个评论

33:14.270 --> 33:15.070
我们去用pose

33:15.070 --> 33:16.110
去请求这个地址

33:16.110 --> 33:17.070
一般来说

33:17.070 --> 33:17.870
天价评论的时候

33:17.870 --> 33:19.150
还要给它传一个对象进去

33:19.150 --> 33:20.030
我这里也不传了

33:20.030 --> 33:21.310
让它自动生成一条评论

33:22.350 --> 33:23.470
然后全都是魔力

33:23.950 --> 33:24.190
好

33:24.190 --> 33:25.230
先让我们看核心代码

33:25.710 --> 33:26.990
我们导入了一个主见

33:26.990 --> 33:27.870
主见也注册了

33:28.430 --> 33:29.470
我有两个数组

33:29.870 --> 33:30.430
分别来

33:30.430 --> 33:31.470
主要是来观察

33:32.750 --> 33:33.630
一个数组呢

33:33.630 --> 33:34.350
记录的就是

33:37.390 --> 33:38.430
不正常的情况

33:38.430 --> 33:39.070
就是如果说

33:39.070 --> 33:40.270
我们写一些错误代码

33:40.270 --> 33:40.990
我该怎么去写

33:40.990 --> 33:41.710
其实我们这里

33:41.710 --> 33:42.830
平时真正做的时候

33:42.830 --> 33:43.550
只有一个数组

33:43.550 --> 33:43.790
对吧

33:43.790 --> 33:46.190
来记录我们的评论列表

33:46.190 --> 33:47.150
但是为了这里

33:47.150 --> 33:48.190
为了进行对比

33:48.190 --> 33:48.910
两种方法

33:48.910 --> 33:49.390
两种情况

33:49.390 --> 33:50.510
我这里准备了好两个数组

33:51.070 --> 33:52.030
所以开始的时候呢

33:52.030 --> 33:53.470
我把两个数组的舔充满

33:54.430 --> 33:54.910
对吧

33:54.910 --> 33:55.230
填满

33:56.510 --> 33:56.750
好

33:56.750 --> 33:57.790
那么就是拿到

33:57.790 --> 33:58.670
所有的评论填满

33:58.670 --> 33:59.070
因此呢

33:59.070 --> 33:59.870
你可以看到这

33:59.870 --> 34:00.830
就拿到所有的评论

34:00.830 --> 34:01.390
都填满了

34:02.030 --> 34:02.830
都出现了

34:02.830 --> 34:02.990
出来了

34:02.990 --> 34:03.310
对吧

34:03.790 --> 34:05.470
我们关注的是后续宣展

34:06.110 --> 34:07.070
就是比方说现在

34:08.670 --> 34:09.790
我第一个按钮

34:09.790 --> 34:11.230
点左边的按钮的时候

34:11.710 --> 34:12.510
我要干嘛呀

34:12.750 --> 34:14.350
我要添加一个评论

34:15.310 --> 34:15.870
你看啊

34:16.750 --> 34:17.470
就魔力吧

34:17.470 --> 34:17.870
我这里

34:17.870 --> 34:18.910
虽然说真正的情况

34:18.910 --> 34:20.190
应该是写一些文门框

34:20.190 --> 34:21.070
点击按钮过后

34:21.070 --> 34:22.990
把他组装成一个对象

34:22.990 --> 34:24.350
传到服务器对吧

34:24.350 --> 34:25.550
来服务器完成添加

34:25.550 --> 34:26.270
我这里呢

34:26.270 --> 34:26.910
不管了啊

34:26.910 --> 34:27.630
就魔力

34:27.630 --> 34:28.510
不传任何参数

34:28.510 --> 34:30.110
他自己自动给我生成一个评论

34:30.830 --> 34:31.790
添加一个评论

34:33.310 --> 34:34.030
然后呢

34:34.030 --> 34:34.670
我的做法

34:34.670 --> 34:35.470
这种做法是

34:36.270 --> 34:37.150
添加完了服务器

34:37.150 --> 34:38.110
等待服务器完成

34:38.830 --> 34:39.550
完成过后

34:39.550 --> 34:40.190
服务器会告诉我

34:40.190 --> 34:40.830
添加成功了

34:40.830 --> 34:41.470
OK了

34:41.470 --> 34:42.430
那么这个时候呢

34:42.430 --> 34:44.510
我会重新调用这个函数

34:45.070 --> 34:46.510
从服务器重新拿到

34:46.510 --> 34:47.470
所有的评论列表

34:48.990 --> 34:49.790
然后给他复制

34:50.590 --> 34:51.790
给这个comments一复制

34:52.510 --> 34:53.310
这种情况

34:53.310 --> 34:54.190
那么大家想一想

34:55.870 --> 34:57.390
从这种情况来看

34:57.390 --> 34:58.590
是不是你重新复制

34:58.590 --> 35:00.510
导致了数组的引用变化了

35:00.510 --> 35:01.870
数组的引用变了

35:02.190 --> 35:02.750
肯定变了

35:03.630 --> 35:05.550
而且数组里面每一个对象的引用

35:05.550 --> 35:06.270
是不是也变了

35:08.110 --> 35:08.830
是不是也变了

35:09.870 --> 35:11.790
因为每一次从服务器拿到的是

35:11.790 --> 35:12.590
拿到的是一个什么

35:12.590 --> 35:14.350
接审格式的制服串

35:15.470 --> 35:16.110
然后呢

35:16.110 --> 35:18.430
有这像这些工具啊

35:18.430 --> 35:19.630
一个小时的工具

35:19.630 --> 35:20.750
他把手动了

35:20.830 --> 35:22.830
他帮你的把这个接审格式的制服串

35:22.830 --> 35:24.030
转换回对象的

35:24.590 --> 35:26.510
所以说哪怕两个接审格式的制服串

35:26.510 --> 35:27.310
完全一样

35:27.950 --> 35:28.910
比方说你看一下这个

35:29.470 --> 35:29.870
这个地方

35:32.940 --> 35:34.700
哪怕你这个地方是完全一样的

35:34.700 --> 35:35.580
比方说啊我这里

35:36.460 --> 35:37.740
写一个数组

35:37.740 --> 35:38.700
写一个对象吧

35:39.980 --> 35:40.940
接审格式的制服串

35:42.220 --> 35:42.540
A

35:43.500 --> 35:44.220
等于1

35:44.220 --> 35:45.580
这是个接审格式的制服串的吧

35:46.460 --> 35:46.780
接审

35:48.300 --> 35:49.580
我把它格式化两次

35:49.580 --> 35:50.300
接审Pose

35:53.180 --> 35:53.900
ov借1

35:55.260 --> 35:56.700
然后呢ov借2

35:56.700 --> 35:57.900
等于接审Pose

35:58.460 --> 36:00.540
你觉得ov借1和ov借2是不是一样的

36:01.340 --> 36:01.900
相等吧

36:02.540 --> 36:03.180
ov借1

36:03.180 --> 36:03.740
ov借2

36:04.300 --> 36:05.180
看上去是一样的

36:05.180 --> 36:05.260
对吧

36:05.260 --> 36:06.300
我们看一下是不是一样的

36:07.180 --> 36:07.740
是force

36:08.780 --> 36:11.580
当他把个接审格式制服串转换了对象的时候

36:12.220 --> 36:14.140
实际上每次转换的是新对象

36:14.140 --> 36:16.860
每一个里面每一个细节全是新的

36:17.820 --> 36:19.580
就没有一个相同的跟之前的对象

36:20.140 --> 36:22.140
虽然说长的样子是完全一样的

36:22.140 --> 36:23.020
那么这样子一复制

36:23.020 --> 36:24.620
你看数组引用发生变化吧

36:25.180 --> 36:25.580
对不对

36:26.220 --> 36:26.940
然后呢

36:26.940 --> 36:28.060
数组引用都不说了

36:28.060 --> 36:29.740
它里面的每一个对象也发生了变化

36:30.460 --> 36:32.300
每一个对象发生的变化就意味着

36:32.300 --> 36:34.300
这里给它传递的每一个属性

36:35.100 --> 36:37.180
之前用的那个组件

36:37.660 --> 36:38.700
这个key都一样的

36:38.700 --> 36:38.940
对吧

36:38.940 --> 36:40.220
要重复使用这个组件

36:40.220 --> 36:41.500
重复使用这个组件的实力

36:41.500 --> 36:43.500
它给它每一次传到的对象是不是不一样

36:44.300 --> 36:44.540
对吧

36:44.540 --> 36:45.180
导致他

36:45.180 --> 36:46.860
导致这个组件重现了

36:47.100 --> 36:48.060
重现的时候呢

36:48.060 --> 36:49.580
我们这里用v4

36:49.580 --> 36:50.380
要重新宣

36:50.380 --> 36:51.180
重新宣这个

36:51.180 --> 36:52.380
这个都是没办法

36:52.380 --> 36:54.140
循环这个数组肯定是要循环的

36:54.140 --> 36:54.940
要重新循环

36:55.580 --> 36:58.300
然后每一次给它传递的这个item是不是不一样

36:58.300 --> 36:59.260
地址都不一样

36:59.740 --> 37:00.300
你看啊

37:00.940 --> 37:02.380
现在一开始的时候

37:03.420 --> 37:04.540
这里面每一个组件

37:04.540 --> 37:05.020
它有一个

37:05.580 --> 37:07.020
传了一个属性进去

37:07.020 --> 37:07.900
一个对象进去

37:08.540 --> 37:09.820
然后我们点击过后

37:09.820 --> 37:12.700
是不是重新从服务器拿到一个新的数组

37:13.260 --> 37:14.860
数组里面每一个对象的地址

37:14.860 --> 37:18.380
跟这个组件里面的属性目前的地址是不一样的

37:19.100 --> 37:20.540
这样子一重新复制

37:20.540 --> 37:22.300
那么这些组件就会认为

37:22.460 --> 37:25.420
你给我的属性更新了

37:25.420 --> 37:26.540
变化了

37:26.540 --> 37:27.340
变化了

37:27.340 --> 37:28.460
那我就要重新宣了

37:28.460 --> 37:30.780
但实际上它们对象里面的内容都是一样的

37:31.740 --> 37:32.620
点击的看一下

37:33.260 --> 37:34.940
这些组件就全部重新宣了

37:34.940 --> 37:36.060
新增那个呢

37:36.540 --> 37:37.500
由于是新增的

37:37.500 --> 37:38.620
它只有第四宣了

37:39.340 --> 37:40.220
新增那个组件

37:40.860 --> 37:42.060
然后再点击一下

37:42.060 --> 37:43.980
你看之前那个组件宣了两次了

37:43.980 --> 37:46.620
刚才那个新增的重新来的一次

37:46.620 --> 37:47.580
现在又新增了一个

37:48.220 --> 37:50.220
你看这些组件是不是没有必要重新来

37:50.620 --> 37:51.340
那怎么办呢

37:51.900 --> 37:52.780
其实非常简单

37:52.780 --> 37:54.460
保持对象地址的稳定

37:55.500 --> 37:56.460
你看第二种情况

37:57.100 --> 37:57.900
就正确的做法

37:58.460 --> 37:59.660
我们这里用了一个数组

38:01.180 --> 38:01.900
还一样的啊

38:02.460 --> 38:04.060
然后一开始去加载它

38:04.060 --> 38:05.740
一开始没办法肯定要从服务去拿

38:06.380 --> 38:08.060
然后接下来点击按钮的时候

38:08.060 --> 38:09.100
你看一下我们怎么做的

38:10.700 --> 38:11.740
点击按钮的时候

38:11.740 --> 38:13.260
我叼用这个函数

38:13.900 --> 38:15.100
添加到服务器

38:15.100 --> 38:16.140
发送于阿迦克斯请求

38:16.140 --> 38:17.260
添加到服务器

38:17.260 --> 38:19.500
服务器那边会返回给我一个完整的

38:20.460 --> 38:21.260
评论对象

38:21.660 --> 38:24.060
我手动的把这个评论对象加到

38:24.060 --> 38:24.860
这个数组列表

38:24.860 --> 38:26.060
也就是不再重新去

38:26.060 --> 38:27.420
从服务器拿到完整的

38:27.420 --> 38:28.460
评论列表了

38:28.460 --> 38:29.260
我只是把

38:29.260 --> 38:31.020
把这个新增的这个东西

38:31.020 --> 38:33.020
加入到目前的评论列表里面去

38:34.060 --> 38:35.020
那么这样子的

38:35.020 --> 38:35.900
就保证了这个

38:36.860 --> 38:38.940
数组里边的是不是

38:38.940 --> 38:40.860
其他的对象的引用地址没变

38:41.500 --> 38:41.820
对吧

38:42.780 --> 38:44.380
因此我们来看一下第二种情况

38:45.820 --> 38:46.700
一开始都一样的

38:47.020 --> 38:47.420
点击

38:48.380 --> 38:50.060
是不是这些都没有输出那个

38:50.060 --> 38:50.460
Render

38:50.460 --> 38:51.660
所以他们没有update

38:51.660 --> 38:52.060
对吧

38:52.060 --> 38:53.180
没有重新选了

38:53.180 --> 38:55.100
再点击你看是不是只有新增

38:55.100 --> 38:56.060
他没有重新选了

38:57.100 --> 38:57.820
对不对

38:57.820 --> 38:58.780
那就这么个意思

39:01.310 --> 39:02.270
好那么其实这里

39:02.270 --> 39:03.870
还是有一些小的细节问题

39:04.430 --> 39:05.310
什么细节问题呢

39:05.310 --> 39:06.990
但是细节问题他并不严重

39:06.990 --> 39:07.710
比方说你看着

39:09.710 --> 39:10.830
加了11 12了

39:10.830 --> 39:11.390
对吧

39:11.390 --> 39:12.030
那你看这边

39:13.150 --> 39:14.030
他只有一个13

39:15.230 --> 39:15.630
为什么

39:16.510 --> 39:17.390
服务器都是一样的

39:17.390 --> 39:19.070
都是同一个服务器拿

39:19.230 --> 39:21.070
现在实际上他是有1112

39:21.710 --> 39:23.150
1112都有的

39:23.790 --> 39:25.310
但是由于服务器那边

39:25.310 --> 39:27.150
我并不知道服务器那边还有更新

39:27.150 --> 39:28.990
因为他这个数据有可能会导致

39:30.030 --> 39:30.990
不是实实的

39:31.630 --> 39:32.590
就是我这边

39:32.590 --> 39:34.990
我只加入了我添加这一下

39:36.030 --> 39:37.470
有没有别人添加评论

39:37.470 --> 39:38.030
我不知道

39:39.470 --> 39:40.990
不知道有没有别人添加评论

39:40.990 --> 39:42.030
当然这个问题呢

39:42.030 --> 39:44.430
其实我们在网站的开发中是经常遇到的

39:44.990 --> 39:47.150
数据其实很多数据没有必要去实实

39:48.030 --> 39:48.910
只要刷新一下页面

39:48.910 --> 39:49.870
是不是全部都出来了

39:50.910 --> 39:51.710
没有必要去实实

39:51.710 --> 39:53.070
当然我这刷新不会有

39:53.070 --> 39:54.110
因为我是模拟数据

39:55.310 --> 39:56.270
不需要实实

39:56.270 --> 39:57.390
所以也ok

39:57.390 --> 39:58.590
如果说你一定要实实的

39:58.590 --> 40:00.510
其实怎么做呢

40:01.390 --> 40:02.510
要不就用websocket

40:02.990 --> 40:04.590
服务器用服务器推特技术

40:04.590 --> 40:05.390
就服务器那边

40:05.950 --> 40:06.670
有了新数据

40:06.670 --> 40:07.550
马上就推给你

40:07.550 --> 40:08.350
你这边夹进去

40:09.310 --> 40:10.030
或者就是

40:10.030 --> 40:12.270
如果说你一定要在点击之后变成实实的

40:12.270 --> 40:13.310
其实也有办法

40:13.310 --> 40:14.910
你这边也可以从服务器拿到数据

40:14.910 --> 40:16.590
但是不要给他直接复职

40:16.750 --> 40:17.630
因为一复职的话

40:17.630 --> 40:18.990
对象引用地址全部更新了

40:19.550 --> 40:20.750
你要去对比这两

40:20.750 --> 40:22.030
就是考虑到算法了

40:22.430 --> 40:23.630
你要用对比这个数据

40:24.110 --> 40:25.550
和从服务器拿到这个数据

40:26.350 --> 40:27.150
他们的差异

40:28.110 --> 40:28.990
主要是比id

40:29.710 --> 40:30.910
id没有变化

40:31.550 --> 40:32.350
那我就认为他不变

40:32.910 --> 40:33.550
不变的

40:33.550 --> 40:34.670
那我这个对象引用

40:34.670 --> 40:35.790
就呆在这个数据里边

40:36.430 --> 40:37.790
id有变化

40:37.790 --> 40:39.630
就是表示有新的数据

40:39.630 --> 40:42.110
那么我把它插入了这个数据的合适位置

40:42.670 --> 40:44.590
总之你不要去改动这个数据里面

40:44.590 --> 40:45.230
所有的对象

40:45.950 --> 40:46.510
意思吧

40:46.510 --> 40:47.470
要写个算法

40:47.470 --> 40:49.470
那么如果说有兴趣的话

40:49.470 --> 40:50.670
你可以自己去写一下

40:50.670 --> 40:54.190
我建议给他提示的就是用双子针

40:54.190 --> 40:55.470
这也不会策略的

40:55.470 --> 40:57.790
其实很多时候就没有必要去保持

40:57.790 --> 41:00.350
没有必要一定要实施

41:00.990 --> 41:02.110
这是关于这一块

41:02.110 --> 41:03.630
对象地址稳定

41:04.670 --> 41:06.750
其实从这个例子也可以看出

41:06.750 --> 41:09.790
我们把组件分得很细的话

41:09.790 --> 41:11.470
其实实际上是有好处的

41:11.470 --> 41:12.670
比方说你看

41:12.670 --> 41:13.790
如果说你不用组件

41:13.790 --> 41:14.990
你直接把这个玩意

41:15.230 --> 41:16.430
直接写到这个app里边来

41:16.990 --> 41:18.190
有什么不好的地方呢

41:18.190 --> 41:20.110
因为这个组件是一定要宣展的

41:20.110 --> 41:20.430
对吧

41:20.430 --> 41:21.870
因为他的数据变了

41:21.870 --> 41:22.670
他点击按钮过

41:22.670 --> 41:23.470
他是数据变了

41:24.030 --> 41:25.150
他一定会重新宣展

41:25.710 --> 41:26.510
而重新宣展的时候

41:26.510 --> 41:27.630
是不是一定我就

41:27.630 --> 41:29.470
因为如果说你把这个东西直接写过来

41:30.110 --> 41:31.150
比方说我就写到这

41:33.230 --> 41:34.350
那就是不是就

41:34.350 --> 41:36.350
无法阻止他宣展这一部分

41:36.350 --> 41:37.230
因为你不可能说

41:38.190 --> 41:39.870
这个一个组件里边

41:39.870 --> 41:41.870
我只让他宣展这几个元素

41:41.870 --> 41:43.070
不让他宣展这几个元素

41:43.070 --> 41:44.190
那是做不到的对吧

41:44.350 --> 41:45.550
他一定都是全部宣展的

41:46.030 --> 41:47.310
所以如果说你把一个组件写得

41:47.310 --> 41:48.110
特别特别元素

41:48.110 --> 41:48.750
特别特别多

41:48.750 --> 41:49.470
实际上是不好的

41:49.950 --> 41:50.990
哪怕一丁检变化

41:50.990 --> 41:52.110
都会导致这个元素重新

41:52.830 --> 41:54.750
虚拟动物全部重新生成一次

41:55.310 --> 41:56.590
但是那你就把它变成一个

41:56.590 --> 41:57.710
只组件过后了

41:57.710 --> 41:59.390
你就可以控制他的对象地址

41:59.390 --> 42:00.190
如果说对象地址

42:00.590 --> 42:02.830
稳定给他的属性是稳定的不变的

42:03.310 --> 42:05.150
那么这个组件里边的

42:05.150 --> 42:07.070
所有的虚拟动物都不会再重新宣展了

42:07.550 --> 42:09.070
这就是细分组件的好处

42:11.480 --> 42:13.640
好下面这个用V秀替代VF

42:13.640 --> 42:14.760
这时候说的什么场景的

42:14.840 --> 42:15.960
不是说一定要这样替换

42:16.360 --> 42:17.880
就是有些东西他频繁切换

42:18.360 --> 42:20.680
用V秀可以保证虚拟动物数稳定对吧

42:21.080 --> 42:22.840
避免频繁的新增和删除元素

42:24.520 --> 42:25.960
那么这里的问题前提条件

42:25.960 --> 42:26.680
哪个什么条件

42:27.080 --> 42:28.200
条件的就是一个是

42:28.200 --> 42:31.240
元素它会从频繁的切换状态

42:32.360 --> 42:33.320
另外一个条件就是

42:33.320 --> 42:35.240
这个元素里边包含了

42:35.240 --> 42:37.560
大量的指元素和后代元素

42:37.960 --> 42:39.320
那如果说你只有一个A元素

42:41.000 --> 42:41.400
切换

42:42.360 --> 42:42.920
切换呗

42:43.080 --> 42:45.480
用VF跟那个V秀有差不多的性能

42:45.960 --> 42:46.760
那只有一个吗

42:47.800 --> 42:48.520
那如果说这个

42:49.080 --> 42:50.840
不是A元素是一个DIV

42:50.840 --> 42:53.160
它里边可能有一万个元素指元素

42:53.160 --> 42:55.720
这是一个很大一块的区域

42:55.720 --> 42:56.760
那么这个时候呢

42:56.760 --> 42:57.880
就用V秀好的件

42:57.880 --> 42:59.320
而且还要频繁切换的时候

42:59.800 --> 43:00.600
用V秀就好得多

43:03.040 --> 43:05.760
好所以其实拖离场景去看

43:06.400 --> 43:07.840
优化的话没有什么意义

43:07.840 --> 43:09.600
优化一定是跟场景结合的

43:10.400 --> 43:11.200
好下面这个

43:11.920 --> 43:13.040
使用延迟装载

43:14.000 --> 43:15.360
今天我们就说到这

43:15.360 --> 43:16.880
下节可能我们讲这个KPULINE

43:16.880 --> 43:18.160
和长裂表优化

43:18.400 --> 43:19.440
后边来讲

43:20.480 --> 43:21.520
因为时间太长了

43:22.400 --> 43:24.560
使用延迟装载是什么意思呢

43:25.840 --> 43:28.160
它主要是为了解决这个白品问题

43:29.520 --> 43:31.600
这问题我们来看一下一个例子

43:32.640 --> 43:33.440
我们用延迟装载

43:41.160 --> 43:43.000
给你写这些例子我都花了好多时间

43:50.780 --> 43:53.340
我先用无延迟装载

43:54.540 --> 43:58.410
就是这个白品问题

43:58.410 --> 44:00.250
它有段时间是白品的

44:00.250 --> 44:03.450
白品的问题具体情况要具体分析

44:03.450 --> 44:04.970
每个项目可能又不一样

44:04.970 --> 44:06.010
但整体来说呢

44:06.010 --> 44:07.290
无非就是这么两个点

44:07.290 --> 44:09.370
一个是白品的时候在干嘛呀

44:09.370 --> 44:10.890
它一个是在传输

44:12.170 --> 44:14.330
你打的包打成一个介石包

44:14.330 --> 44:18.810
访问这个地址是不是要远程加在这个介石

44:18.810 --> 44:20.330
介石包你可能有几兆

44:20.330 --> 44:21.370
那肯定要加载很久

44:21.370 --> 44:23.690
那你如果说你只有10G、20KB

44:23.690 --> 44:24.650
那肯定加载很快

44:24.970 --> 44:27.370
所以说它一般来说会加载介石包

44:27.370 --> 44:28.730
这个时候一面上啥都没有

44:28.730 --> 44:29.930
因为一面上只有一个什么

44:29.930 --> 44:32.970
只有一个DIV ID为APP

44:32.970 --> 44:33.930
对吧啥都看不见

44:33.930 --> 44:35.050
所以说这个时候是白品状态

44:35.770 --> 44:37.210
因此减少打包体积

44:37.210 --> 44:38.570
是不是有助于环节白品

44:38.970 --> 44:40.810
当然我们也可以有其他的办法

44:40.810 --> 44:43.290
一般来说我们可以先在这个DIV里面写一些样式

44:43.290 --> 44:44.650
好看的东西

44:45.370 --> 44:46.250
让它看着

44:46.250 --> 44:47.370
比方一个动画样

44:47.370 --> 44:48.010
让它看着

44:48.010 --> 44:48.810
够够紧

44:48.810 --> 44:51.610
其实有的时候用户体验

44:51.610 --> 44:53.050
它不一定是等待时间

44:53.130 --> 44:55.690
不一定需要一定需要减少等待时间

44:55.690 --> 44:57.370
有的时候它等待这段时间内

44:57.370 --> 44:58.570
你让它有东西可看

44:58.570 --> 45:00.330
然后一个进度条

45:00.330 --> 45:01.770
一个小孩带来跑

45:02.330 --> 45:03.130
也可以环节

45:03.770 --> 45:06.730
环节就是避免很多用户就直接离开了

45:08.330 --> 45:09.690
总之就是白品状态

45:10.250 --> 45:11.050
那么怎么办

45:11.050 --> 45:12.250
减少打包体积

45:12.250 --> 45:14.330
那么这个问题的国家浙济科方程之内

45:14.330 --> 45:15.210
以前我们讲过了

45:15.770 --> 45:16.730
通过怎么来去打包

45:17.610 --> 45:18.970
对打包体积进行优化

45:19.690 --> 45:21.370
那么现在我们主要说的问题是第二个

45:21.850 --> 45:23.850
就是GS已经传输过来了

45:23.850 --> 45:25.130
我现在要运行这个GS

45:25.130 --> 45:26.650
但是我运行的东西太多了

45:27.610 --> 45:29.290
一时半会流量器渲染不过来

45:30.010 --> 45:31.050
那么这个时候呢

45:31.050 --> 45:32.730
也会是处于白品状态

45:32.730 --> 45:33.450
你看这个时候

45:33.450 --> 45:35.130
我本来就要本地开发的

45:35.130 --> 45:36.970
GS传输速度是很快的

45:36.970 --> 45:38.250
但是它依然有这么长时间

45:38.250 --> 45:39.050
直接的白品

45:39.050 --> 45:39.770
你看我刷新

45:41.210 --> 45:42.250
它时间还是蛮长的

45:42.250 --> 45:42.970
对吧

45:42.970 --> 45:44.570
那么我要解决这个问题

45:45.850 --> 45:46.890
你看它传输完成过后

45:46.890 --> 45:48.650
流量器开始执行GS构造介面

45:48.650 --> 45:50.730
但是因为一开始有些介面很大

45:51.290 --> 45:52.250
特别特别多东西

45:52.250 --> 45:54.010
你看现在页面是越来越大了

45:54.890 --> 45:57.050
有可能一开始要宣传的组件太多了

45:57.050 --> 45:57.850
那么这个时候呢

45:57.850 --> 45:59.690
不仅介面是执行的时间很长

45:59.690 --> 46:01.290
而且就是纠缠里执行完了

46:01.290 --> 46:03.530
流量器要宣传的元素也太多了

46:03.530 --> 46:04.810
导致页面白平

46:06.090 --> 46:06.970
那么这个时候呢

46:06.970 --> 46:08.010
我们来看怎么来处理

46:08.890 --> 46:10.250
游动办法就是延迟夹展

46:10.250 --> 46:11.370
看一下怎么来做

46:11.370 --> 46:13.450
首先我们来看一下无延迟夹展

46:13.450 --> 46:14.410
就是普通情况

46:14.410 --> 46:15.450
我说的一个组件

46:15.450 --> 46:17.050
这个组件呢就模拟一个

46:17.050 --> 46:18.650
非常非常重的组件

46:19.610 --> 46:20.170
比方说

46:20.890 --> 46:22.570
我们的无幼里面不是个页面吗

46:22.570 --> 46:23.770
有很多页面组件对吧

46:23.770 --> 46:25.530
放了无幼式通过路由来切换的

46:27.050 --> 46:28.250
那么页面组件可能

46:28.810 --> 46:30.410
里面又有很多大的组件

46:30.410 --> 46:31.850
总之我就模拟一个大的组件

46:32.250 --> 46:33.930
这个组件里面循环了五千次

46:34.570 --> 46:35.130
生成一个

46:35.130 --> 46:36.170
生成不同的DMV

46:36.490 --> 46:38.250
老实说老师你是不是太夸张了

46:38.810 --> 46:39.770
哪有那么多元素

46:40.650 --> 46:41.770
太常见了

46:41.770 --> 46:43.450
五千个元素太常见了

46:44.330 --> 46:44.970
为啥呀

46:45.850 --> 46:47.130
你觉得这个五千个元素

46:47.130 --> 46:48.650
好像没很多的样子

46:48.650 --> 46:50.570
你看这其实就是五千个元素

46:51.050 --> 46:52.730
在占页面上这么一点去

46:52.730 --> 46:53.530
你想一想

46:53.530 --> 46:54.970
一些复杂页面里边

46:54.970 --> 46:57.130
元素是不是划分得非常非常细呀

46:58.410 --> 47:00.490
很多时候元素可能只是一个底

47:00.490 --> 47:02.010
一个非常不起眼的一个符号

47:02.010 --> 47:03.530
一个字体图标

47:03.530 --> 47:04.570
就是一个元素

47:04.570 --> 47:05.050
对吧

47:05.050 --> 47:06.410
里边可能还有它的尾元素

47:07.210 --> 47:07.690
对不对

47:07.690 --> 47:08.730
所以说其实

47:08.730 --> 47:10.330
我们的页面上的元素是很多的

47:10.330 --> 47:11.130
很多的

47:11.130 --> 47:12.570
那么比方说我就用这种方式

47:12.570 --> 47:14.490
来模拟一个元素很多的组件

47:14.490 --> 47:15.770
它也没有其他的什么东西

47:16.330 --> 47:17.850
我就给它设了一些样式

47:17.850 --> 47:18.570
把它设了

47:18.570 --> 47:19.690
每个DMV设的很小

47:20.250 --> 47:21.370
然后我们来看一下我们的APP

47:22.250 --> 47:23.050
正常情况下

47:23.050 --> 47:24.410
你看我做的事情非常简单

47:24.410 --> 47:25.290
我就导入这个组件

47:26.330 --> 47:28.250
我的一个APP组件里边

47:28.250 --> 47:29.850
我就把整合成一个页面

47:30.330 --> 47:32.090
我一个页面中要用到很多组件

47:32.650 --> 47:34.170
那么我这里就写了一个组件

47:34.170 --> 47:34.970
来模拟吧

47:34.970 --> 47:36.730
我可能有别的组件

47:36.730 --> 47:38.090
别的组件可能也很多

47:38.090 --> 47:38.890
反正我就模拟

47:39.530 --> 47:40.570
我可能这个

47:40.570 --> 47:41.930
我把它组装成页面的时候

47:41.930 --> 47:44.330
我可能页面中要用到21个

47:44.890 --> 47:45.850
这样的一个组件

47:45.850 --> 47:46.810
类似的组件

47:46.810 --> 47:48.650
我这里都用的是它

47:48.810 --> 47:50.810
实际情况下还要用别的对吧

47:50.810 --> 47:51.610
一个区域用它

47:51.610 --> 47:52.410
一个区域用别的

47:53.290 --> 47:53.770
都行

47:53.770 --> 47:54.250
什么意思

47:54.730 --> 47:55.690
就是这个意思

47:55.690 --> 47:57.850
它总之要选择很多个这样的综组件

47:58.730 --> 48:00.090
那么选择的结果就是

48:00.090 --> 48:01.130
它选择东西太多了

48:02.010 --> 48:02.890
它选择不过来

48:04.090 --> 48:05.850
一是接是执行的时间太长

48:05.850 --> 48:07.130
二是它选择东西太多

48:07.690 --> 48:08.330
选择不过来

48:09.210 --> 48:09.690
你要吧

48:09.690 --> 48:10.810
它就摆平了

48:10.810 --> 48:13.370
我们来仔细来分析它的性能指标

48:16.480 --> 48:17.600
就放过来吧

48:17.600 --> 48:18.400
来开始录制

48:19.200 --> 48:19.600
刷新

48:21.630 --> 48:22.190
好停止

48:24.670 --> 48:25.150
你看啊

48:26.110 --> 48:27.710
目前情况就这样的一个情况

48:28.910 --> 48:30.110
看指涉的区域是不是在

48:30.750 --> 48:31.310
Rendering

48:31.870 --> 48:32.430
对吧

48:32.430 --> 48:33.630
是不是在构建那个

48:34.990 --> 48:35.470
Dome数

48:35.470 --> 48:36.590
构建CSS数

48:36.590 --> 48:37.390
构建渲染数

48:37.870 --> 48:38.190
对不对

48:39.150 --> 48:40.510
黄色的区域是不是脚奔执行

48:40.510 --> 48:42.190
因为脚奔执行有段时间

48:42.190 --> 48:43.550
然后Rendering的一段时间

48:44.350 --> 48:45.870
脚奔执行就是借势在执行

48:45.870 --> 48:47.390
就是我们的5U的代码在执行

48:47.790 --> 48:48.990
因为它为什么要执行那么长

48:48.990 --> 48:50.030
因为它要循环

48:50.030 --> 48:51.230
循环的次数

48:51.550 --> 48:52.510
现在很多的

48:53.070 --> 48:55.310
员数生成虚拟动物都需要时间的

48:55.310 --> 48:57.390
然后这些借势执行完了过后

48:57.390 --> 48:59.550
这一段时间就是浏览器的虚拟动物

48:59.550 --> 49:00.430
确然的时间

49:00.430 --> 49:01.630
后面就是划出来的

49:02.430 --> 49:04.430
因此在划出来之前

49:04.430 --> 49:05.630
我们看到的都是摆平

49:06.670 --> 49:07.470
Merry's吧

49:08.350 --> 49:10.110
好那么怎么来解决这个问题呢

49:10.110 --> 49:11.150
这个问题呢

49:11.150 --> 49:12.590
你可以通过分包

49:12.590 --> 49:13.630
延迟

49:13.630 --> 49:16.110
就是有些区域不是立即加载出来的

49:16.110 --> 49:17.470
我需要延迟加载

49:18.430 --> 49:21.710
就是动态的从网上去获取一些包

49:21.710 --> 49:23.230
我们之前学过的路由

49:23.230 --> 49:24.670
是不是有动态路由

49:24.670 --> 49:27.390
就是那个路由满家站

49:27.390 --> 49:28.030
对不对

49:28.030 --> 49:29.390
这是一种处理方案

49:29.870 --> 49:31.390
但是有的时候很多区域

49:31.390 --> 49:33.390
它确实需要立即显示都很重要

49:33.390 --> 49:34.590
它需要立即显示

49:34.590 --> 49:36.350
那么这个时候又怎么办呢

49:37.630 --> 49:39.150
好那么这个时候呢

49:39.150 --> 49:41.150
我们的思路其实很简单

49:41.150 --> 49:42.590
你们都是立即显示

49:42.590 --> 49:44.430
但是我们来个先后顺序

49:44.430 --> 49:45.390
给你一个优先级

49:45.390 --> 49:47.070
最重要的显示

49:47.230 --> 49:48.670
赤织的后显示

49:48.670 --> 49:50.670
就是我们来个渲染优先级嘛

49:50.670 --> 49:52.270
那具体咋做的呢

49:52.270 --> 49:52.990
看这

49:53.870 --> 49:55.630
其实我解决的不是总时间

49:55.630 --> 49:57.230
而是把这些时间分片

49:57.230 --> 50:00.030
有点类似于Ragged的那种思路

50:00.030 --> 50:02.030
把时间分片

50:02.030 --> 50:03.950
分片过后先显染一块重要的

50:03.950 --> 50:05.230
再显示其他的

50:05.230 --> 50:06.430
一点点来

50:07.950 --> 50:09.630
看一下延迟加载

50:11.230 --> 50:12.670
大半辆其实也很小

50:12.670 --> 50:13.950
这个组件不变

50:14.910 --> 50:16.830
然后呢我混入了一个东西

50:16.830 --> 50:17.390
你看

50:17.390 --> 50:18.910
混入了一个Diff

50:19.950 --> 50:21.230
但这不是一定的做法

50:21.230 --> 50:22.510
我就是举个例子

50:22.510 --> 50:23.790
传了一个数字进去

50:23.790 --> 50:24.830
这啥意思啊

50:24.830 --> 50:25.710
这是一个函数

50:25.710 --> 50:26.910
一定是个函数嘛对吧

50:26.910 --> 50:27.790
雕用这个函数

50:27.790 --> 50:29.790
所以得到一个组件配置对象

50:29.790 --> 50:30.990
才能进行混入嘛

50:31.630 --> 50:33.070
混入我们之前学过

50:33.070 --> 50:34.510
Diff我们来看一下这个Diff

50:34.510 --> 50:35.550
它是一个函数

50:36.030 --> 50:37.630
也给我传的是一个

50:38.270 --> 50:40.030
MaxFrameCult

50:40.510 --> 50:42.110
啥意思啊这个东西

50:45.420 --> 50:46.860
因为我们知道在

50:46.860 --> 50:48.380
浏览器里边有个东西叫做

50:48.380 --> 50:49.100
渲染针

50:50.220 --> 50:51.740
所以我们之前好像在上一课的时候

50:51.740 --> 50:52.380
就讲过对吧

50:53.660 --> 50:55.020
它的协访叫做

50:55.820 --> 51:00.540
RequestAnimationFree

51:00.540 --> 51:01.100
对不对

51:01.100 --> 51:02.380
所以里边传个回调函数

51:03.180 --> 51:04.860
渲染针是在不断的发生的

51:12.750 --> 51:13.790
这是一个渲染针

51:13.790 --> 51:15.150
这是一个渲染针

51:15.150 --> 51:16.990
它不断的在进行渲染

51:17.790 --> 51:18.270
对吧

51:18.430 --> 51:19.230
就是渲染针

51:20.350 --> 51:21.950
那么我这个MaxFrameCult

51:21.950 --> 51:22.910
什么意思呢

51:23.230 --> 51:24.990
就是说我这个组件

51:25.790 --> 51:26.510
最大

51:27.070 --> 51:29.390
是在哪一个渲染针的区间内

51:29.390 --> 51:30.590
完成所有的渲染

51:30.590 --> 51:31.630
就这么个意思啊

51:31.630 --> 51:33.390
比方说我这个传一个21

51:33.390 --> 51:34.350
那么就表示

51:34.350 --> 51:36.110
我要在21针之内

51:36.910 --> 51:38.110
把这个页面渲染出来

51:38.750 --> 51:39.390
就这个意思

51:40.510 --> 51:41.710
传一个最大的渲染针

51:42.350 --> 51:43.390
或者是我传一个100

51:43.390 --> 51:44.910
就表示我要在100针

51:44.910 --> 51:45.710
这是一针

51:45.710 --> 51:46.590
这是二针

51:46.590 --> 51:47.470
这是三针

51:47.950 --> 51:49.310
我要在100针之内

51:49.310 --> 51:50.110
把它渲染出来

51:51.310 --> 51:52.110
正常情况下

51:52.110 --> 51:53.390
浏览器是一秒钟

51:53.390 --> 51:53.870
60人

51:54.510 --> 51:55.390
不同的机器配置

51:55.390 --> 51:55.870
也不一样

51:56.350 --> 51:56.910
如果说

51:56.910 --> 51:58.510
某一段时间内

51:58.510 --> 52:00.030
它要渲染的东西太多了

52:00.030 --> 52:01.950
那么就会导致针率降低

52:02.350 --> 52:03.470
那么这一段时间就被

52:03.470 --> 52:04.670
后边的针就被挤压

52:04.670 --> 52:06.110
往后面挤压过去了

52:06.110 --> 52:06.670
对吧

52:06.670 --> 52:07.710
一直得不到渲染

52:07.710 --> 52:08.430
就这么个意思

52:08.750 --> 52:09.870
所以说我们把分成

52:09.870 --> 52:10.830
一段一段的渲染

52:10.830 --> 52:11.310
比方说

52:11.310 --> 52:12.430
这一段我渲染

52:12.430 --> 52:14.110
这一段我渲染其中一个组件

52:14.110 --> 52:15.710
这一段我渲染另一个组件

52:15.710 --> 52:17.070
这一段我渲染第三个组件

52:17.630 --> 52:19.470
我一针一针的去渲染它

52:20.510 --> 52:21.550
或者是隔击针

52:21.550 --> 52:22.750
我这个地方啥都不渲染

52:22.750 --> 52:23.870
没什么必要

52:23.870 --> 52:24.350
对吧

52:24.350 --> 52:25.790
尽量的把它密集一点

52:25.790 --> 52:27.470
渲染出来就OK了

52:28.510 --> 52:29.310
懂这个意思吧

52:29.310 --> 52:30.430
所以你给我传一个最大的

52:30.430 --> 52:31.550
渲染针进来

52:31.550 --> 52:33.470
然后我这里可以返回一个组件配置

52:34.270 --> 52:36.110
其实没有那么复杂

52:36.910 --> 52:38.190
我就看一下目前

52:38.990 --> 52:40.910
我目前经历的针数

52:41.150 --> 52:42.190
一开始是0吗

52:42.430 --> 52:43.070
对吧

52:43.070 --> 52:44.990
然后针数是不是不断的增加

52:45.470 --> 52:46.750
浏览器每渲染一针

52:46.830 --> 52:48.430
我就表示我经过了一针了

52:48.430 --> 52:50.030
每渲染一针我就真经过了一针了

52:50.030 --> 52:51.470
表示我目前经过了针数

52:52.110 --> 52:53.870
然后在Monday的礼拜我写了这么一个东西

52:54.350 --> 52:56.590
叫做刷新我的目前的针数

52:57.230 --> 52:58.270
你看我怎么写的

52:58.270 --> 52:59.070
就是一个函数

52:59.070 --> 53:00.510
我这里会调那个函数

53:00.830 --> 53:01.870
那么这个函数执行的时候

53:01.870 --> 53:02.750
怎么就说的

53:02.990 --> 53:03.950
高速浏览器

53:03.950 --> 53:05.470
你下一针渲染之前

53:05.790 --> 53:07.070
我要运行这么一个东西

53:10.270 --> 53:11.630
你在下一针运行之前

53:11.630 --> 53:13.390
那么它会运行这个毁掉函数

53:14.190 --> 53:15.470
这毁掉函数里面做什么事情

53:16.190 --> 53:17.150
它加1

53:17.150 --> 53:18.750
它一开始是0对吧

53:20.750 --> 53:21.630
文字吧

53:22.190 --> 53:24.270
FramedCult一开始是0

53:26.960 --> 53:27.600
然后呢

53:28.080 --> 53:29.120
第一针渲染的时候

53:29.120 --> 53:30.640
它加1它是不是变成1了

53:32.560 --> 53:33.360
变成1了

53:33.920 --> 53:34.800
就这么一个意思

53:35.120 --> 53:36.160
然后再比较一下

53:36.400 --> 53:38.480
这个1是不是小于了它呀

53:39.440 --> 53:40.080
它是多少

53:40.080 --> 53:40.800
它是21

53:41.600 --> 53:43.200
21是不是小于

53:43.200 --> 53:44.080
小于它的话

53:44.080 --> 53:45.520
我重新调用这个函数

53:46.480 --> 53:47.600
重新调用它

53:47.600 --> 53:49.840
重新调用它是不是又注册了一个毁掉

53:50.320 --> 53:53.040
那么这一次是不是又注册了这么一个函数

53:53.520 --> 53:55.440
重新调用它是不是又注册了一个毁掉

53:55.440 --> 53:56.640
那么就高速浏览器

53:56.640 --> 53:58.000
我这一次OK了

53:58.000 --> 53:59.840
那么下一针渲染之前的时候

53:59.840 --> 54:01.440
你还是要运行我这个毁掉

54:01.840 --> 54:02.960
要重新运行这个毁掉

54:02.960 --> 54:04.160
对吧,是个低规的做法

54:04.800 --> 54:07.070
又运行这个毁掉

54:07.070 --> 54:08.030
运行这个毁掉的时候

54:08.030 --> 54:08.990
它是不是又加1

54:09.710 --> 54:10.350
变成2

54:10.350 --> 54:12.350
要看一下2是不是小于21针啊

54:12.830 --> 54:13.390
还小于

54:13.390 --> 54:14.510
说明说我还要记录

54:14.510 --> 54:15.710
一直记录到21针

54:16.030 --> 54:16.990
我就不再记录了

54:17.950 --> 54:18.750
就这么个意思

54:20.270 --> 54:21.870
这个地方懂这么意思了吗

54:21.870 --> 54:22.510
就说我

54:23.310 --> 54:24.030
告诉我

54:24.030 --> 54:25.870
我到底要监控多少针

54:27.070 --> 54:27.870
好,那么监

54:27.870 --> 54:30.030
我就可以通过它来表示

54:30.030 --> 54:31.230
你就可以得到

54:31.230 --> 54:33.310
目前我选择到第几针了

54:33.310 --> 54:33.710
对不对

54:34.270 --> 54:35.790
好,接下来我写了这么一个方法

54:35.790 --> 54:36.350
叫Diffle

54:37.710 --> 54:40.110
你给我传一个数字进来

54:40.750 --> 54:41.710
表示说

54:41.710 --> 54:43.310
我希望这个组建

54:44.030 --> 54:45.710
在第几针

54:46.670 --> 54:48.430
就是超过第几针的时候

54:48.430 --> 54:49.230
被宣兰

54:49.790 --> 54:50.990
那么我这里呢

54:50.990 --> 54:52.270
反回来就是一个布尔

54:52.910 --> 54:54.190
当前的帧数

54:54.190 --> 54:55.630
是不是大于等于这个帧数

54:55.630 --> 54:56.430
比方说这个时候

54:56.430 --> 54:57.630
你给我传一个6进来

54:58.430 --> 54:59.150
我现在

54:59.150 --> 55:00.910
我现在刚刚宣兰到第二针

55:01.870 --> 55:03.070
是不是还没有倒流

55:03.070 --> 55:04.270
没有倒流是不是反回Force

55:04.270 --> 55:04.830
表示

55:04.830 --> 55:06.030
我这里不宣兰

55:06.590 --> 55:07.630
如果说我现在

55:07.630 --> 55:08.910
你给我传一个1进来

55:10.190 --> 55:12.030
那么就目前宣兰到第二针了

55:12.110 --> 55:13.310
你给我的是1

55:13.310 --> 55:14.350
表示什么意思

55:14.350 --> 55:16.030
表示你希望在第1针之后

55:16.030 --> 55:17.150
就要进行宣兰

55:17.150 --> 55:18.190
那么现在是不是可以宣兰

55:18.430 --> 55:19.710
就这么个意思

55:22.030 --> 55:22.270
好

55:22.270 --> 55:23.550
我们看一下这边怎么用的

55:24.830 --> 55:25.470
传个21

55:25.470 --> 55:27.390
表示我这个组建的

55:27.390 --> 55:29.950
要监控的帧数是21

55:29.950 --> 55:31.230
那么我比方说

55:31.230 --> 55:32.510
我这里就举个例子

55:32.510 --> 55:33.790
循环宣兰的21次

55:35.070 --> 55:36.350
比方说我这里有21个

55:36.350 --> 55:37.630
这个样子组建要宣兰

55:37.630 --> 55:38.910
类似的组建要宣兰

55:38.910 --> 55:40.190
实际情况不一定是循环

55:40.270 --> 55:41.470
它可能是并列写的

55:41.470 --> 55:42.750
因为它不是

55:42.750 --> 55:44.030
循环宣兰它

55:44.030 --> 55:45.310
每个区域的组建不一样

55:45.310 --> 55:46.350
无所谓嘛

55:46.350 --> 55:47.630
都是一个意思

55:47.630 --> 55:50.410
循环它

55:50.410 --> 55:51.930
然后加了一个vif来判断

55:53.210 --> 55:56.320
比方说你循环第1次的时候

55:56.320 --> 55:57.600
我先这样子写

55:57.600 --> 55:58.880
别人看不懂

55:58.880 --> 56:02.300
我先这样子写

56:02.300 --> 56:03.580
vif

56:03.580 --> 56:04.860
vif

56:04.860 --> 56:06.140
vif

56:06.140 --> 56:08.700
我认为这个组建的优先级很高

56:08.700 --> 56:11.260
你希望马上第1针的时候就

56:11.260 --> 56:12.540
第1针之前

56:12.540 --> 56:13.820
第0针的时候

56:13.820 --> 56:15.100
马上要给我宣兰出来

56:15.500 --> 56:16.700
不要等

56:16.700 --> 56:18.300
然后这里写个1

56:18.300 --> 56:19.100
表示什么意思

56:19.100 --> 56:22.460
表示你在第1针的时候宣兰出来就OK了

56:22.460 --> 56:24.780
这个表示你在第2针的时候宣兰出来就OK了

56:24.780 --> 56:26.540
前面的时候就不用宣兰

56:26.540 --> 56:28.860
因为如果说你目前的针数没有达到2的话

56:28.860 --> 56:29.820
那么这个是force

56:29.820 --> 56:31.260
force的话是不是不会运行

56:31.260 --> 56:32.220
不会宣兰这个组建

56:32.220 --> 56:34.460
那么组建里边的虚拟动物数就不会生成

56:34.460 --> 56:35.740
原来意思吧

56:35.740 --> 56:37.900
流量器的宣兰东西那就没有那么多

56:37.900 --> 56:41.100
我就把它用这种方式来给它排这个优先级

56:41.100 --> 56:42.700
来进行宣兰

56:42.860 --> 56:43.660
这意思吧

56:43.660 --> 56:45.420
这里的为了写的方便呢

56:45.420 --> 56:47.340
有真实的情况实际上是这样子写的

56:47.340 --> 56:47.660
为什么

56:47.660 --> 56:48.700
因为这里是不同的组件

56:49.900 --> 56:51.020
是不同的组件的

56:51.020 --> 56:52.300
不同的区域对吧

56:52.300 --> 56:53.980
可能是不准动排列

56:53.980 --> 56:56.220
可能外面还加些DIV来进行排列

56:56.220 --> 56:57.420
就这么个意思

56:57.420 --> 57:00.460
那么这里的为了方便我就把写成 force还了

57:00.460 --> 57:01.420
这里就n

57:01.420 --> 57:02.380
从一开始到二十一

57:03.340 --> 57:04.060
好保存

57:05.020 --> 57:06.060
先让我们看一下

57:06.060 --> 57:07.900
现在把它变成严实装载过后

57:09.580 --> 57:11.260
这是之前的威严

57:11.260 --> 57:12.620
就是普通装载

57:12.700 --> 57:13.980
现在我们来进行严实装载

57:13.980 --> 57:14.540
轻空

57:15.260 --> 57:15.900
蓝度字

57:16.380 --> 57:16.940
刷新

57:17.820 --> 57:18.300
你看

57:18.300 --> 57:19.900
首先感官上是不是好得多

57:20.700 --> 57:21.260
对吧

57:21.260 --> 57:22.540
然后来看一下停止

57:24.140 --> 57:24.700
它就是

57:25.340 --> 57:28.060
你看是不是分成各一段一段的线转出来的

57:28.060 --> 57:29.260
一整一整线转出来的

57:29.260 --> 57:31.260
你看每一段都有介绍执行

57:31.260 --> 57:32.060
都有那个

57:32.780 --> 57:34.060
Rendering都有Paint

57:34.060 --> 57:34.380
对吧

57:34.380 --> 57:35.980
每一段一段执行出来的

57:35.980 --> 57:37.100
一段一段执行出来的

57:38.060 --> 57:38.700
原来的意思吧

57:39.420 --> 57:41.180
这就是这种方啊

57:41.180 --> 57:43.020
其实总时间呢其实是没有变化

57:43.020 --> 57:43.580
没有什么变化

57:43.580 --> 57:44.860
可能还要稍微延长一点

57:44.860 --> 57:47.260
但是给用户的感官上是不是好太多了

57:47.660 --> 57:48.780
来我们来刷新再看一下

57:50.460 --> 57:51.660
感官上可好太多了

57:52.220 --> 57:52.700
对吧

57:53.340 --> 57:55.340
这也是一种减少白平的手段

57:57.180 --> 57:58.060
这个装载的

57:58.060 --> 57:59.740
其实严实装载就是一个思路

57:59.740 --> 58:01.500
它不是一种固定的代码鞋法

58:01.500 --> 58:03.020
本质上就是利用这个

58:03.740 --> 58:06.140
Requested Animation Frame这个事件

58:06.860 --> 58:07.820
来控制它的针

58:07.820 --> 58:09.660
刀极在低级针来进行旋转

58:09.660 --> 58:10.620
分辟旋转的一种

58:10.620 --> 58:12.380
它的具体实现的其实是多种多样的

58:12.380 --> 58:13.580
比方说我还看到有些人

58:13.580 --> 58:14.860
它是这样子实现的

58:14.860 --> 58:15.980
它不是控制组件

58:15.980 --> 58:16.780
它是控制数据

58:17.420 --> 58:18.300
有时候呢

58:18.300 --> 58:20.060
因为数据太多了

58:20.060 --> 58:21.980
比方说一个列表的时候

58:21.980 --> 58:22.860
它数据太多了

58:22.860 --> 58:23.980
要选的东西导致太多

58:24.460 --> 58:26.220
那么我就分批装载数据

58:26.220 --> 58:27.740
我先从服务器拿到所有数据

58:28.220 --> 58:29.260
但是那我这些数据呢

58:29.740 --> 58:30.780
它有一个vux吧

58:30.780 --> 58:31.980
比方说它有一个vux

58:33.020 --> 58:34.220
vux里边有一个数组

58:34.220 --> 58:34.940
比方datas

58:34.940 --> 58:35.500
它有一个数组

58:36.060 --> 58:37.900
我从服务器拿到1万个数据

58:38.860 --> 58:42.140
大家可是拿到了1万个数据

58:42.140 --> 58:43.580
按理说正常情况下

58:43.580 --> 58:45.340
我直接把个数据放到数组里面就OK了

58:45.340 --> 58:46.860
但它不是这样子放的

58:46.860 --> 58:48.060
它是分批放的

58:48.060 --> 58:50.460
在浏览器的第一针之前

58:50.460 --> 58:51.500
我放10个

58:51.500 --> 58:52.940
浏览器的第二针

58:52.940 --> 58:54.380
我再放10个20个

58:54.380 --> 58:55.660
分批放进去

58:55.660 --> 58:57.340
然后让那个vux每一次宣展的

58:57.340 --> 58:59.340
不要太多东西

58:59.340 --> 59:01.420
这也是一种做法

59:01.420 --> 59:02.940
总之呢

59:02.940 --> 59:04.780
它本质上就是利用这个特性

59:04.780 --> 59:07.740
优化是非常非常灵活

59:08.300 --> 59:09.900
以休想说学习捷克

59:09.900 --> 59:11.980
就掌控了这些优化的所有东西了

59:11.980 --> 59:13.180
那是不行了

59:13.180 --> 59:15.340
还是要去不断的锻炼自己

59:15.340 --> 59:17.420
提高自己的程序思维能力

59:17.420 --> 59:19.260
特别是对一些框架使用的时候

59:19.260 --> 59:20.700
夺去你的它的原理

59:20.700 --> 59:21.660
到时候优化的时候

59:21.660 --> 59:22.700
具体情况具体分析

59:22.700 --> 59:24.620
你才有一定的思路

59:24.620 --> 59:26.060
不然的话你完全没有思路的

59:27.020 --> 59:28.460
OK 那么优化这一块我就

59:29.100 --> 59:29.740
讲到这了

59:29.740 --> 59:30.780
还有两个优化方式

59:30.780 --> 59:31.740
我下节课再说

59:32.380 --> 59:32.860
好吧

59:32.860 --> 59:33.820
那么这里可以到这了

