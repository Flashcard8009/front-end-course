WEBVTT

00:00.000 --> 00:03.120
各位同学 这节课谁给大家说一下

00:03.120 --> 00:06.020
它不仅仅是为了应对面试题

00:06.320 --> 00:08.720
将来在你们公司里边做开发的时候

00:08.720 --> 00:11.440
这个概念其实是很重要的

00:11.440 --> 00:15.040
但还比较简单 说实话里边细节一大堆

00:15.040 --> 00:17.440
但是实际上本身是比较简单的

00:17.440 --> 00:19.080
我们来看一下是什么回事

00:19.320 --> 00:22.320
这就后来咱们来聊的是JWT

00:22.560 --> 00:25.400
那么首先就要说这个玩意它有什么用

00:25.400 --> 00:27.440
它出来是干嘛用的 对吧

00:27.600 --> 00:31.600
我们首先解决为什么它会出现的这个问题

00:31.600 --> 00:35.560
来 我们来回顾一下之前我们学Cookie的时候讲登录

00:35.560 --> 00:41.720
那么讲登录的时候 我们说ADB协议是没有状态的

00:41.720 --> 00:46.200
这下一次请求的时候就不知道上一次之前是什么情况了

00:46.200 --> 00:48.000
所以说我们会怎么来处理呢

00:48.000 --> 00:50.280
比如说我们传一个账号密码到服务器

00:50.280 --> 00:52.680
服务器那边登录成功了 它会给它一个证件

00:52.680 --> 00:54.880
对吧 有出入证 我们之前讲过的

00:55.000 --> 00:57.000
其实这个东西叫做什么呢 叫做令牌

00:58.000 --> 01:01.000
然后后续的客户端再把这个令牌传给服务器的时候

01:01.000 --> 01:03.080
服务器也发现它有这个令牌

01:03.080 --> 01:05.880
说明了它之前是登录成功的 对吧

01:05.880 --> 01:08.520
我要 那么就可以做一些相应的操作了

01:09.160 --> 01:10.520
这是我们以前讲的流程

01:11.440 --> 01:14.080
那么这一节课我们就要深入到这个令牌里边去了

01:14.640 --> 01:16.960
这个动玩意到底是个啥 它是一个数字

01:17.440 --> 01:19.440
还是个制服串 还是一个什么东西

01:19.440 --> 01:21.400
它总得是个东西吧 对吧

01:21.400 --> 01:22.560
我们之前讲Cookie

01:22.680 --> 01:25.160
Cookie里边不是讲那个发到服务器的时候

01:25.160 --> 01:28.120
是不是有一个Cookie传到服务器 对吧

01:28.120 --> 01:31.760
那这个传的到底是个啥 这个地方传啥呢

01:32.920 --> 01:36.040
以前是没有统一的要求的 对吧

01:36.040 --> 01:38.440
每个公司有自己的规定 随便传啥

01:39.400 --> 01:41.840
那么比方说以前一回公司怎么做的

01:41.840 --> 01:44.800
登录成功过后 它就把ID 用户的ID告诉它

01:45.360 --> 01:48.360
比方说用户的UserID 它用这样的方式来传

01:48.360 --> 01:51.560
你登录成功之后 服务器就告诉你的UserID是E

01:51.640 --> 01:54.600
那么你下一次在登录的时候

01:54.600 --> 01:57.200
在做后续的操作的时候 把这个Cookie给我带上

01:57.200 --> 02:01.400
服务器一看 也有这个就是用户ID 对吧

02:01.400 --> 02:04.200
那么就我知道你登录成功了 对不对

02:04.200 --> 02:05.160
这是以前的做法

02:05.160 --> 02:07.720
当然我们再把信息量丰富一点的话

02:07.720 --> 02:08.600
还可以做一些别的事

02:08.600 --> 02:10.680
比方说你登录成功之后

02:10.680 --> 02:13.920
服务器它会发一个SetCookie 对吧

02:15.320 --> 02:18.360
然后告诉你的用户信息

02:19.160 --> 02:20.760
或者说我们就要交到token

02:21.720 --> 02:23.280
有个令牌 令牌是什么呢

02:23.280 --> 02:25.120
里边包含的是一个用户的信息

02:25.120 --> 02:27.200
用户的信息是不是一个对象 对吧

02:27.200 --> 02:28.240
是一个对象吧

02:28.240 --> 02:31.760
对象里边有什么用户的姓名

02:31.760 --> 02:32.840
用户的账号

02:32.840 --> 02:35.520
而Count 比方说而的命

02:35.520 --> 02:38.400
然后还有什么用户的密码就算了吧

02:38.400 --> 02:40.040
密码不要记录在这里面

02:40.040 --> 02:41.160
用户的年龄

02:42.480 --> 02:44.720
18岁 比方说像这些

02:44.720 --> 02:47.120
那么我们把它变成一个接生格式的支付串

02:47.120 --> 02:48.960
是不是可以放到这儿 对吧

02:48.960 --> 02:52.400
那么后续用户在请求服务器的时候

02:52.400 --> 02:54.920
是不是把这个令牌就可以带过去 对吧

02:54.920 --> 02:55.720
那么服务器看

02:55.720 --> 02:57.680
哦 原来一登录成功了 那就OK

02:58.840 --> 03:00.480
这是过去的做法

03:00.480 --> 03:01.360
那么过去的做法

03:01.360 --> 03:05.600
这种做法肯定是有问题的

03:05.600 --> 03:07.160
过去也有一些办法来解决

03:08.360 --> 03:09.640
什么问题呢

03:09.640 --> 03:12.320
第一个 那如果是非流浪迹环境

03:12.320 --> 03:14.120
如何在令牌里面记录过去时间

03:14.120 --> 03:14.880
这什么意思呢

03:14.880 --> 03:16.840
因为我们知道Cookie是不是有过去时间

03:16.840 --> 03:17.120
对吧

03:17.160 --> 03:18.520
我们设置Cookie的时候

03:18.520 --> 03:19.600
是不是还可以设置

03:19.600 --> 03:20.600
它的过期时间

03:20.600 --> 03:21.960
Mike Sage 对吧

03:21.960 --> 03:24.680
比方说一个小时后过期

03:24.680 --> 03:26.000
可以设置过期时间

03:26.000 --> 03:28.480
那如果说不是流浪迹环境

03:28.480 --> 03:29.280
不是流浪迹环境

03:29.280 --> 03:32.040
这个Cookie最好就别用了

03:32.040 --> 03:34.240
虽然说可以通过消息头给它传过去

03:34.240 --> 03:35.960
但是因为不是流浪迹环境

03:35.960 --> 03:40.360
它就没法自动的把Cookie保存到保存前了

03:40.360 --> 03:43.440
可能比方说像移动端的APP

03:43.440 --> 03:44.320
或者是小程序

03:44.320 --> 03:46.240
哪有什么Cookie 哪有什么Cookie

03:46.280 --> 03:49.520
所以说这个时候就没有这个东西了

03:49.520 --> 03:51.400
那没有这个东西的时候

03:51.400 --> 03:52.440
那就遇到一个问题

03:52.440 --> 03:55.040
过期时间你就必须要写到之后里面

03:55.040 --> 03:56.760
是必须要写到这个令牌里面

03:56.760 --> 03:58.360
就要写过去时间

03:58.360 --> 03:59.800
对了 这是第一个问题

03:59.800 --> 04:01.120
令牌里面 其实令牌里面

04:01.120 --> 04:01.880
怎么能写过去时间

04:01.880 --> 04:02.280
当然可以

04:02.280 --> 04:04.360
我再加个属性不就完了吗

04:04.360 --> 04:05.840
Mike Sage

04:05.840 --> 04:07.520
所以加个属性就完了

04:07.520 --> 04:10.920
3600也可以 也没什么问题

04:10.920 --> 04:14.640
但是它确实是一个问题需要解决的

04:14.640 --> 04:15.560
这是一种方案

04:15.560 --> 04:17.600
对吧 加到这个Token里面

04:17.600 --> 04:20.400
然后因为它不一定是Cookie

04:20.400 --> 04:22.000
如果说像移动端环境的话

04:22.000 --> 04:24.520
那可能就不应该用这个消息头了

04:24.520 --> 04:26.520
那可能就要用另外一个自定义的消息头

04:26.520 --> 04:28.800
比方说这个消息头叫做Oscarization

04:28.800 --> 04:31.160
或者叫ABC 都行

04:31.160 --> 04:32.840
那么后续的客户端

04:32.840 --> 04:35.160
传到服务系的时候也不应该用Cookie了

04:35.160 --> 04:37.080
因为它不是浏览器环境

04:37.080 --> 04:39.600
那么我们可能应该用Oscarization

04:39.600 --> 04:41.240
或者是用一个BCD

04:41.240 --> 04:44.200
都行 自己定义

04:44.200 --> 04:49.520
那就用一个普通的响应头和普通的勤求头

04:49.520 --> 04:52.920
懂得意思吗 就这么个意思

04:52.920 --> 04:55.960
好 那么现在呢就第一个问题

04:55.960 --> 04:57.800
非能浏览器环境里面

04:57.800 --> 04:59.040
就不应该使用Cookie的

04:59.040 --> 05:01.320
那么这个过期时间里得处理

05:01.320 --> 05:06.000
对吧 其实像咱们现在的大前端环境

05:06.000 --> 05:08.120
你看移动端是咱们前端在做

05:08.120 --> 05:10.040
小程序是咱们前端在做

05:10.040 --> 05:12.240
那个页面也是咱们前端在做

05:12.720 --> 05:14.520
后端就开发服务器就行了

05:14.520 --> 05:16.120
那么后端在开发服务器的时候

05:16.120 --> 05:17.560
实际上它是不知道

05:17.560 --> 05:20.440
你将来是什么产品在寝求服务器的

05:20.440 --> 05:21.920
它有可能是个小程序

05:21.920 --> 05:26.080
有可能是一个移动端的APP

05:26.080 --> 05:27.960
也有可能是一个桌面应用

05:27.960 --> 05:29.680
也有可能是一个网页

05:29.680 --> 05:31.760
所以说现在的我们大部分

05:31.760 --> 05:33.760
都不太使用Cookie去做这些

05:33.760 --> 05:35.760
来存这个出入字

05:35.760 --> 05:38.240
一般是把它存到local storage里面

05:38.240 --> 05:39.320
一般是这样做

05:39.320 --> 05:40.800
那么也就是服务器

05:40.840 --> 05:41.720
它登录成功之后

05:41.720 --> 05:43.440
它不是用Cookie引力响应的

05:43.440 --> 05:46.240
它可能是一个自定义的小型响应头

05:46.240 --> 05:47.200
那你响求的时候

05:47.200 --> 05:48.720
你要表现阿迦克斯响求

05:48.720 --> 05:51.800
你要自己加一个响求头

05:51.800 --> 05:53.240
给它夹到这里边

05:53.240 --> 05:55.360
这是现在的比较普遍的做法

05:55.360 --> 05:56.880
这不是我们这就和调研究的问题

05:56.880 --> 05:58.640
这些和调研究的是什么呢

05:58.640 --> 06:00.480
就是里面写下啥

06:00.480 --> 06:01.280
因为它没有Cookie的

06:01.280 --> 06:03.440
所以说要写一个过期时间

06:03.440 --> 06:04.560
要写进去

06:04.560 --> 06:05.760
那么第二个问题

06:05.760 --> 06:07.800
如何防止令牌被伪造

06:07.800 --> 06:09.040
因为你想啊

06:09.040 --> 06:10.000
你这个出入字

06:10.000 --> 06:11.600
不管你是啥出入字吧

06:11.600 --> 06:12.960
你知道那种是啥吧

06:12.960 --> 06:14.880
你也不管你不管这个客户端是啥吧

06:14.880 --> 06:15.800
你可能是个浏览器

06:15.800 --> 06:17.920
有可能是一个手机设备

06:17.920 --> 06:19.280
也可能是一个桌面影

06:19.280 --> 06:20.240
无所谓

06:20.240 --> 06:22.080
反正我要把这个证件传给你

06:22.080 --> 06:23.160
对吧

06:23.160 --> 06:24.080
那完蛋了

06:24.080 --> 06:26.200
你这个玩意儿传到客户端

06:26.200 --> 06:29.080
你知道客户端是在拥护那一边

06:29.080 --> 06:30.520
拥护那边发生什么事

06:30.520 --> 06:31.520
那你就完全不知道

06:31.520 --> 06:32.960
你让它中病毒了

06:32.960 --> 06:34.720
或者是它自己是一个搞开发的

06:34.720 --> 06:37.320
它可以随意的改这个出入字

06:37.320 --> 06:38.840
哪怕它没有这个出入字

06:38.840 --> 06:41.440
它也可以给你伪造一个出入字出来

06:41.440 --> 06:41.720
对吧

06:41.720 --> 06:42.440
你看这种方式

06:42.440 --> 06:44.800
这种方式特别容易伪造

06:44.800 --> 06:46.720
怎么伪造

06:46.720 --> 06:47.440
不用我讲吧

06:47.440 --> 06:48.840
你们发送阿迦哥是请求的

06:48.840 --> 06:50.400
说你加一个请求头部就完了吗

06:50.400 --> 06:52.240
给他设置这么一个投款格式

06:52.240 --> 06:53.360
给他写进去就完了

06:53.360 --> 06:54.560
就这么简单

06:54.560 --> 06:57.000
这个请求头特别特别容易被伪造

06:57.000 --> 06:58.520
那么现在就是另外一个问题

06:58.520 --> 07:00.440
如何防止这个令牌被伪造

07:00.440 --> 07:01.240
就服务器怎么知道

07:01.240 --> 07:03.240
这个令牌不是我发的

07:03.240 --> 07:05.320
是他自己弄出来的

07:05.320 --> 07:06.400
这些问题

07:06.400 --> 07:08.320
其实这个问题能不能解决

07:08.360 --> 07:10.480
你们学过加密

07:10.480 --> 07:12.200
这很好解决

07:12.200 --> 07:12.840
怎么解决

07:12.840 --> 07:15.000
我给你提供一种方案

07:15.000 --> 07:16.640
比方说我们就简单一点吧

07:16.640 --> 07:18.920
那么就不用一个阶层对象吧

07:18.920 --> 07:21.920
我们用一个E来表示用户的ID

07:21.920 --> 07:23.760
这个玩意特别容易伪造

07:23.760 --> 07:25.680
然后你阿迦哥是请求的时候

07:25.680 --> 07:27.360
你们学过IKE小时对吧

07:27.360 --> 07:32.040
IKE小时去请求的时候

07:32.040 --> 07:33.160
请求一个URI地址

07:33.160 --> 07:36.590
你是不是给他加一个header

07:36.590 --> 07:38.350
说可以加个header

07:38.430 --> 07:39.790
他加一个BCD

07:39.790 --> 07:42.270
那种就是token等于E

07:42.270 --> 07:43.990
我没有登录成功

07:43.990 --> 07:45.550
但是我可以加上户带过去

07:45.550 --> 07:46.510
服务器已经蒙了

07:46.510 --> 07:47.990
他又不知道这个玩意是不是伪造的

07:47.990 --> 07:49.670
他哪听出了

07:49.670 --> 07:51.430
所以这个玩意特别容易被伪造

07:52.750 --> 07:53.670
怎么解决

07:53.670 --> 07:54.350
我们学过加密

07:54.350 --> 07:55.350
其实很好解决

07:55.350 --> 07:56.590
我怎么解决呢

07:56.590 --> 07:57.830
我这个token的格式

07:57.830 --> 07:58.670
给你要求一下

07:58.670 --> 08:00.390
你这个格式得是这样子

08:00.390 --> 08:01.990
前边是E

08:01.990 --> 08:03.510
后边我比方说

08:03.510 --> 08:06.190
后边我加上一个底

08:06.190 --> 08:07.590
一个分割服

08:07.670 --> 08:09.190
前边是你的数据

08:09.190 --> 08:11.470
颁发的就是token数据

08:11.470 --> 08:14.990
后边我服务器给你响应token的时候

08:14.990 --> 08:17.190
它不是单独的响应的ID

08:17.190 --> 08:18.150
后边给你加上

08:18.150 --> 08:19.430
服务器那边会有一个密钥

08:21.310 --> 08:23.070
做一个对称加密就行了

08:23.070 --> 08:23.670
服务器密钥

08:26.710 --> 08:27.550
对称加密

08:27.550 --> 08:30.110
把这个E用那个密钥进行对称加密

08:30.110 --> 08:31.750
那加密出来可能就是这个样子

08:31.750 --> 08:32.990
那就鬼子知道它什么样子

08:34.630 --> 08:35.630
你不知道它什么样子

08:35.630 --> 08:37.030
那比较说就这个样子

08:37.950 --> 08:38.870
加密成这个样子

08:40.110 --> 08:42.430
好那你要伪造怎么伪造呢

08:42.430 --> 08:44.190
比方说你这个玩意

08:44.190 --> 08:46.310
你只有你登录成功过后才会给你

08:46.310 --> 08:47.030
你不登登录成功

08:47.030 --> 08:48.070
你根本就不知道这个东西

08:49.150 --> 08:50.510
那时候比方说我现在没有登录

08:50.510 --> 08:52.470
没有登录我肯定不知道这个东西

08:52.470 --> 08:52.910
对不对

08:52.910 --> 08:55.110
那我只知道我可以伪造一个用户的ID

08:55.110 --> 08:56.710
比方说我像伪造E

08:56.710 --> 08:58.630
那伪造E光发这个东西服务器不认

08:58.630 --> 08:59.790
因为它缺少一部分

08:59.790 --> 09:00.470
对吧

09:00.470 --> 09:01.710
那么后边怎么办呢

09:02.950 --> 09:04.110
后边怎么办呢

09:04.110 --> 09:05.070
那我是不要对

09:05.070 --> 09:06.950
我比方说我要伪造这个用户ID

09:06.990 --> 09:08.230
我要对E进行加密

09:08.230 --> 09:09.870
但是完了我不知道密要

09:09.870 --> 09:11.670
这个密要只有服务器有

09:11.670 --> 09:13.990
这个虽然是对称加密

09:13.990 --> 09:15.750
但是我没有把个密要分发出来

09:15.750 --> 09:17.590
那我这里我不知道密要

09:17.590 --> 09:19.790
那就算我对E自己随便找个密要

09:19.790 --> 09:21.870
那加密出来可能就不是这个样子的

09:21.870 --> 09:23.510
可能就变成了这个样子

09:24.830 --> 09:25.590
懂了意思吧

09:25.590 --> 09:27.390
那么这个样子传到服务器过

09:27.390 --> 09:29.510
服务器一看你的用户ID是E

09:29.510 --> 09:31.350
有可能是我之前给你办法的

09:31.350 --> 09:33.510
验证一下呗

09:33.510 --> 09:36.190
服务器就把一个E用服务器的密要加密一次

09:36.230 --> 09:37.390
加密出来是这个

09:37.390 --> 09:38.310
那就不对了

09:38.310 --> 09:39.870
那你看服务器加密出来是这个

09:39.870 --> 09:40.830
但是你给我的是这个

09:40.830 --> 09:42.670
说明这个玩意是你伪造的

09:42.670 --> 09:43.670
并不是我办法的

09:44.710 --> 09:45.310
懂的意思吗

09:45.310 --> 09:46.630
就这么个意思

09:46.630 --> 09:48.230
所以说这个要解决这两个问题

09:48.230 --> 09:48.950
其实很好解决

09:48.950 --> 09:50.390
第一个问题要解决怎么解决

09:50.390 --> 09:52.030
我把那个过期时间写通的硬盘

09:52.030 --> 09:52.990
那种里面去就行了

09:52.990 --> 09:53.430
对吧

09:53.430 --> 09:54.470
这个问题怎么解决

09:54.470 --> 09:57.030
这个问题就是我用服务器用个加密

09:57.030 --> 09:58.190
就解决没有解决了

09:59.830 --> 10:01.630
解决了就不需要GWT了

10:02.990 --> 10:05.190
那为什么还需要GWT呢

10:05.190 --> 10:08.070
因为它想在互联网的环境中

10:08.070 --> 10:10.390
出现一种统一的方式

10:10.390 --> 10:11.910
大家都这么用

10:11.910 --> 10:13.710
统一的这么一种格式

10:13.710 --> 10:15.110
所以说GWT

10:15.110 --> 10:17.190
第一个它是为了解决这些问题

10:17.190 --> 10:18.630
第二个呢

10:18.630 --> 10:20.830
它就是要提供一个统一的安全的

10:20.830 --> 10:21.310
什么叫安全

10:21.310 --> 10:24.110
就是不能被篡改的这么一种令牌格式

10:24.110 --> 10:25.030
这就这么一个东西

10:25.030 --> 10:27.030
所以说它有多神秘的

10:27.030 --> 10:27.750
一点都不神秘

10:27.750 --> 10:27.990
对吧

10:27.990 --> 10:28.750
就是我不用它

10:28.750 --> 10:30.670
我完全可以达到同样的目的

10:30.670 --> 10:33.190
只不过它是统一的

10:33.190 --> 10:33.910
就这么个意思

10:35.350 --> 10:36.390
那么它的本质

10:36.390 --> 10:39.110
其实它的权上叫做接生WebToken

10:39.110 --> 10:40.150
这个玩意没发翻译了

10:40.150 --> 10:40.670
这个翻译之后

10:40.670 --> 10:44.110
就是一个接生格式的互联网令牌

10:44.110 --> 10:44.950
它没有说登录

10:44.950 --> 10:46.590
它不是仅仅可以用于登录

10:46.590 --> 10:48.110
所有的在互联网环境中

10:48.110 --> 10:49.430
需要颁发令牌的地方

10:51.190 --> 10:52.110
比方说有几个例子

10:52.110 --> 10:53.230
你忘记密码

10:53.230 --> 10:55.070
是不是给你发一封邮件

10:55.070 --> 10:55.390
对吧

10:55.390 --> 10:56.830
那个邮件里面是一个链接

10:56.830 --> 10:58.150
那个链接是一式性的

10:58.150 --> 10:59.390
用了就不能再用了

10:59.390 --> 11:00.390
那个链接里面

11:00.390 --> 11:02.590
其实也保含令牌的

11:02.590 --> 11:03.310
链接地址里面

11:03.310 --> 11:04.350
我们不去成就

11:04.390 --> 11:05.830
不过这个玩意就是

11:07.030 --> 11:07.910
它的作用就是

11:07.910 --> 11:10.270
来得到一个不能被伪造的令牌

11:10.270 --> 11:12.590
这个令牌只能有服务器颁发

11:12.590 --> 11:13.510
你其他伪造不了

11:13.510 --> 11:14.350
你伪造过后

11:14.350 --> 11:15.550
它就验证通不过

11:15.550 --> 11:16.510
就这个一东西

11:16.510 --> 11:17.950
本质就是一个支付串

11:17.950 --> 11:18.790
你看

11:18.790 --> 11:20.270
本质就是像刚才的样子

11:20.270 --> 11:21.310
这么一个支付串

11:21.310 --> 11:22.830
这格式不像这个种格式

11:26.070 --> 11:27.030
其实所以说

11:27.030 --> 11:29.510
GWT还只是一个令牌格式而已

11:29.510 --> 11:31.030
那么这个令牌颁发到哪

11:31.030 --> 11:32.070
颁发到Cookie

11:32.070 --> 11:33.910
还是说你用别的请求头

11:33.950 --> 11:35.190
都想应头

11:35.190 --> 11:36.030
都无所谓的

11:36.030 --> 11:36.830
它不要求

11:36.830 --> 11:38.710
你说把它存到Cookie里边

11:38.710 --> 11:39.910
还是要存到Nokestory级表

11:39.910 --> 11:40.950
没有任何限制

11:40.950 --> 11:42.550
它只是一个支付串而已

11:42.550 --> 11:45.470
所以说对于传输而已

11:45.470 --> 11:48.030
你可以使用任何方式来传输这个GWT

11:48.030 --> 11:49.470
比方说我们可以

11:49.470 --> 11:50.750
服务器那边通过了

11:50.750 --> 11:51.630
登录成功了

11:51.630 --> 11:52.550
它可以用这种方式

11:52.550 --> 11:54.950
现在Cookie把token的

11:54.950 --> 11:56.030
这个令牌的内容

11:56.030 --> 11:57.710
就GWT令牌这个内容的

11:57.710 --> 11:58.670
放到Cookie里边

11:58.670 --> 12:01.750
也可以通过一个普通的想应头

12:01.750 --> 12:03.670
我们自己约定一个Otherization

12:03.710 --> 12:04.590
表授权

12:04.590 --> 12:05.510
我给你一个令牌

12:05.510 --> 12:06.430
把令牌放到这

12:06.430 --> 12:09.030
它自定义的想应头

12:09.030 --> 12:09.510
当然了

12:09.510 --> 12:11.430
这个客户端就有不同的处理

12:11.430 --> 12:12.430
如果说是流量器

12:12.430 --> 12:13.110
看到这个的话

12:13.110 --> 12:14.630
就会自动的保存到Cookie里边

12:14.630 --> 12:15.150
对吧

12:15.150 --> 12:16.870
如果说不是流量器的话

12:16.870 --> 12:18.310
还要读这个

12:18.310 --> 12:19.950
你到底要自己写代码

12:19.950 --> 12:21.630
写代码去读取请求

12:21.630 --> 12:22.870
想应头里边的这个东西

12:22.870 --> 12:24.790
然后把保存到Nokestory级里边

12:24.790 --> 12:26.030
都行

12:26.030 --> 12:28.030
GWT它只是一个令牌格式而已

12:28.030 --> 12:30.510
它只是规定到这个里边应该是啥

12:30.510 --> 12:31.550
怎么去传输

12:31.550 --> 12:35.890
你放到了随便

12:35.890 --> 12:38.970
这样令牌可以出现在想应的任何一个地方

12:38.970 --> 12:41.370
甚至有些它把这个token的放到这

12:41.370 --> 12:43.090
放到想应体里边

12:43.090 --> 12:43.810
消息体里边

12:43.810 --> 12:44.850
比如说一些别的数据

12:44.850 --> 12:45.690
登入成功了

12:45.690 --> 12:46.690
然后用户的信息

12:46.690 --> 12:47.610
然后加成一个token

12:47.610 --> 12:48.570
都可以

12:48.570 --> 12:49.570
自行决定

12:51.410 --> 12:53.610
它也可以同时出现在想应的多个地方

12:53.610 --> 12:54.770
比如说我们这里

12:54.770 --> 12:55.650
技术现在Cookie

12:55.650 --> 12:56.850
也出现在Otherization

12:56.850 --> 12:58.090
也出现在这个想应体里边

12:58.090 --> 12:59.130
都可以

12:59.130 --> 13:00.850
这样子会增加额外的传输量

13:00.850 --> 13:01.570
你重复了

13:01.570 --> 13:02.370
对不对

13:02.370 --> 13:03.170
都可以

13:04.050 --> 13:06.450
那么客户端拿到这个令牌之后

13:06.450 --> 13:07.330
把这个令牌拿到之后

13:07.330 --> 13:08.370
它只做一件事

13:08.370 --> 13:09.250
把它存起来

13:09.250 --> 13:10.690
那至于怎么存

13:10.690 --> 13:12.610
你浏览器可以存Cookie

13:12.610 --> 13:14.050
可以存local storage

13:14.050 --> 13:15.330
你那里的小程序里边

13:15.330 --> 13:16.890
只能存local storage

13:16.890 --> 13:18.650
存本地数据

13:18.650 --> 13:19.770
如果说你app的话

13:19.770 --> 13:21.490
可以存到一个手机文件里边

13:21.490 --> 13:22.410
你桌面应用的话

13:22.410 --> 13:23.970
可以存到一个PC端的文件里边

13:23.970 --> 13:24.570
都可以

13:24.570 --> 13:25.810
那随便你怎么存

13:25.810 --> 13:26.770
总之你把它存起来

13:26.770 --> 13:27.690
下一次请求的时候

13:27.690 --> 13:29.890
把它带过来就行了

13:29.890 --> 13:30.890
后续的请求的时候

13:30.890 --> 13:31.530
客户端那边

13:31.530 --> 13:34.690
它只需要把之前发布的这个令牌

13:34.690 --> 13:35.610
该带过去

13:35.610 --> 13:36.450
那带的方式

13:36.450 --> 13:38.250
我们一般把它放到请求头里边

13:38.250 --> 13:39.850
当然也可以用Cookie的方式带过去

13:39.850 --> 13:41.730
那这个东西要跟服务器之间

13:41.730 --> 13:42.690
进行约定

13:42.690 --> 13:45.010
看你们公司是怎么带的

13:45.010 --> 13:47.090
我跟大家说一般的情况

13:47.090 --> 13:48.290
一般来说的话

13:48.290 --> 13:51.450
使用了JWT是这么一种情况

13:51.450 --> 13:52.290
响应的时候

13:52.290 --> 13:53.730
它就没有这个Cookie

13:55.170 --> 13:56.850
要么放这

13:56.850 --> 13:58.250
要么放这

13:58.250 --> 13:59.530
这是一般通用

13:59.530 --> 14:01.010
比较常见的处理办法

14:01.050 --> 14:02.770
它就不用Cookie了

14:02.770 --> 14:04.730
你自己去存Douge Storage

14:04.730 --> 14:06.010
你不要存Cookie了

14:06.010 --> 14:07.290
就这么个意思

14:07.290 --> 14:08.330
请求的时候

14:10.010 --> 14:10.810
请求的时候

14:12.570 --> 14:13.290
那么带到这

14:15.090 --> 14:17.770
带到请求头里边

14:17.770 --> 14:19.210
然后加上一个单子叫Berry

14:19.210 --> 14:20.770
Berry就表示附带的

14:20.770 --> 14:21.530
附带一个令牌

14:21.530 --> 14:22.210
一个空格

14:22.210 --> 14:23.650
后边写上这个令牌

14:23.650 --> 14:25.970
把之前发的令牌放到请求头里边

14:25.970 --> 14:27.330
给它发过去

14:27.330 --> 14:27.650
对不对

14:27.650 --> 14:29.770
就好像我们刚才写的阿迪克斯一样

14:29.810 --> 14:31.050
一个小词

14:31.050 --> 14:31.850
地址

14:31.850 --> 14:33.370
然后请求一个地址

14:33.370 --> 14:34.130
接下来

14:34.130 --> 14:35.490
这里边是不是可以配置Header

14:36.930 --> 14:38.290
Header里边是不是可以配置一下

14:38.290 --> 14:38.570
这个

14:42.530 --> 14:43.690
这应该写这个

14:43.690 --> 14:44.490
Ocentation

14:47.530 --> 14:48.130
你要写这个

14:51.440 --> 14:52.240
然后呢

14:52.240 --> 14:53.000
把这个令牌

14:54.200 --> 14:55.160
Berry

14:56.320 --> 14:57.840
然后这个JWT令牌

14:57.840 --> 14:58.880
把你拼接一下

14:58.880 --> 15:00.880
从Lover Storage几百把读出来拼接一下

15:00.920 --> 15:01.640
发过去就完事了

15:02.640 --> 15:04.360
当这个网上要再重申一次

15:04.360 --> 15:05.520
这个每个公司

15:05.520 --> 15:07.200
它不一定是完全一致的

15:07.200 --> 15:09.200
它看你们公司自行的约定

15:09.200 --> 15:10.120
一般来说

15:10.120 --> 15:12.000
杰克文档里面会给你写的很清楚

15:12.000 --> 15:13.000
你怎么去做

15:13.000 --> 15:15.280
你看我们杰克文档里面

15:15.280 --> 15:16.920
所以就有这个约定了

15:17.760 --> 15:19.160
好像里面在做那个

15:20.640 --> 15:22.520
这是个人博客和以及

15:24.440 --> 15:26.120
聊天机的时候

15:26.120 --> 15:27.840
聊天机的时候我一点忘了

15:27.840 --> 15:29.560
我们去看个人博客吧

15:29.600 --> 15:30.680
个人博客

15:31.600 --> 15:32.280
博客

15:32.280 --> 15:32.840
是这个吗

15:34.120 --> 15:34.520
不是

15:38.280 --> 15:39.720
个人空间

15:39.720 --> 15:40.520
就在这

15:40.520 --> 15:42.600
那登录的时候是不是就会告诉你

15:42.600 --> 15:43.080
对吧

15:43.080 --> 15:44.880
他说登录成功过后服务器

15:44.880 --> 15:47.040
服务器会用Ocentation给你响应

15:51.300 --> 15:52.540
Ocentation给你响应

15:52.540 --> 15:53.300
表示授权

15:55.220 --> 15:56.700
然后你

15:57.420 --> 15:58.220
后续

15:58.220 --> 16:00.660
如果说你要访问一些必须要登录之后

16:00.660 --> 16:01.620
才能访问的接口

16:02.580 --> 16:03.660
比方说啊

16:03.660 --> 16:04.540
你添加分类

16:05.860 --> 16:07.260
那么这里需要授权

16:07.260 --> 16:08.140
需要授权我们看一下

16:08.140 --> 16:09.380
怎么说的

16:12.860 --> 16:14.100
需要授权的接口

16:14.100 --> 16:15.100
那么需要授权的时候

16:15.100 --> 16:16.620
你需要在寝求投利

16:16.620 --> 16:18.060
加上这个Ocentation

16:18.060 --> 16:19.220
把头坑放到这

16:20.140 --> 16:21.340
就这么一个逻辑

16:23.420 --> 16:23.820
好

16:23.820 --> 16:24.780
这里说了半天

16:24.780 --> 16:28.740
我来说这个GWT在实际开发中的应用

16:28.740 --> 16:29.620
其实我都还没有说到

16:29.620 --> 16:30.740
这里边到底写的是啥

16:30.740 --> 16:31.180
对吧

16:32.420 --> 16:32.700
好

16:32.700 --> 16:35.460
然后我们接下来来看一下

16:35.460 --> 16:37.460
有了这个GWT过后

16:37.540 --> 16:39.180
我们能不能再伪造了

16:39.180 --> 16:40.620
这个令牌能不能伪造了

16:40.620 --> 16:42.340
现在让我们客户端去请求服务器

16:42.340 --> 16:43.260
张浩铭把船过去

16:43.260 --> 16:43.860
登录成功

16:43.860 --> 16:46.100
然后服务器给他办发一个GWT令牌

16:46.100 --> 16:47.740
就这里边一个制服串

16:47.740 --> 16:49.380
然后客户端就把保存起来

16:49.380 --> 16:49.540
好

16:49.540 --> 16:50.380
后续的请求的时候

16:50.380 --> 16:52.260
把它附带到请求投利边

16:52.260 --> 16:53.580
给他带过去

16:53.580 --> 16:54.020
好

16:54.020 --> 16:55.540
带过去现在的服务器那边

16:55.540 --> 16:56.740
需要写端代码

16:56.740 --> 16:58.060
来验证这个令牌

16:58.060 --> 16:59.580
有没有被伪造过

16:59.580 --> 17:00.940
是不是我办法的

17:00.940 --> 17:02.060
那么他要进行验证

17:02.060 --> 17:03.060
那么他基本逻辑

17:03.060 --> 17:04.260
其实跟这里的逻辑

17:04.340 --> 17:06.980
我们刚才讲的逻辑实际上是一样的

17:06.980 --> 17:09.260
就通过这种逻辑来验证的

17:09.260 --> 17:10.420
然后验证通过之后

17:10.420 --> 17:11.380
那就OK

17:11.380 --> 17:11.780
通不过

17:11.780 --> 17:12.900
那就给你包错了

17:12.900 --> 17:14.900
给你返回一个错误

17:14.900 --> 17:15.060
好

17:15.060 --> 17:15.820
接下来我们来看一下

17:15.820 --> 17:19.980
GWT它到底是怎么来完成这个功能的

17:19.980 --> 17:21.540
为什么它能够防止伪造

17:21.540 --> 17:23.380
其实逻辑就是这个逻辑

17:23.380 --> 17:24.820
这个逻辑并没有变化

17:24.820 --> 17:25.500
一模一样的

17:25.500 --> 17:27.700
只它格式的有点区别

17:27.700 --> 17:29.020
一个完整的GWT

17:29.020 --> 17:30.820
其实就是一个完整的制服串

17:30.820 --> 17:31.980
它有三部分组成

17:31.980 --> 17:33.420
第一部分

17:33.460 --> 17:34.660
一个底

17:34.660 --> 17:35.580
第二部分

17:35.580 --> 17:36.620
不用慌啊

17:36.620 --> 17:37.780
这个是啥东西

17:37.780 --> 17:38.740
一个底分割

17:38.740 --> 17:39.380
然后第三部分

17:39.380 --> 17:40.420
一共就三部分

17:40.420 --> 17:41.900
第一个部分的叫做Header

17:43.220 --> 17:44.100
它记录的是什么呢

17:44.100 --> 17:45.460
它相当于是记录了一下

17:45.460 --> 17:47.980
我这个GWT这个定牌

17:47.980 --> 17:49.500
是怎么来签名的

17:49.500 --> 17:51.220
这个签名的其实就是这一步

17:52.380 --> 17:53.540
就是这一步

17:53.540 --> 17:56.780
就是把这一段来加密

17:56.780 --> 17:57.740
它用的是哪一种算法

17:57.740 --> 17:58.700
因为我们知道对成加密

17:58.700 --> 17:59.660
也有很多种算法

17:59.660 --> 18:00.180
对吧

18:00.180 --> 18:01.500
还可以使用非准成加密

18:01.500 --> 18:02.460
都是可以的

18:02.500 --> 18:04.300
记录有什么样的算法

18:04.300 --> 18:06.180
第二部分就是

18:06.180 --> 18:08.380
Pelode叫做定牌附合

18:08.380 --> 18:09.220
它记录的是什么呢

18:09.220 --> 18:10.460
记录的就是主体信息

18:10.460 --> 18:12.300
那么就相当于是我这里的这个

18:13.300 --> 18:15.340
你到底要把定牌里面

18:15.340 --> 18:16.420
放什么原式信息

18:16.420 --> 18:17.580
比方说你要放用户信息

18:17.580 --> 18:18.300
是一个对象

18:18.300 --> 18:19.820
那把它接成格式化

18:19.820 --> 18:20.780
放这儿

18:20.780 --> 18:22.900
或者是你记录一个用户ID

18:22.900 --> 18:23.420
都行

18:23.420 --> 18:25.340
就是它的原式信息Pelode

18:25.340 --> 18:27.020
第三个就是sync nature

18:27.020 --> 18:28.100
叫定牌签名

18:28.100 --> 18:29.340
这部分就相当于是这个

18:30.740 --> 18:31.700
就相当于是这个

18:31.740 --> 18:33.300
就加密过后的

18:33.300 --> 18:34.100
防止伪造的

18:34.100 --> 18:35.660
所以真正它的能够防止伪造的是

18:35.660 --> 18:36.660
第三部分

18:36.660 --> 18:37.580
就是这三部分主持

18:37.580 --> 18:40.300
它的格式就是Pelode叫做定牌附合

18:41.500 --> 18:44.140
咱们要研究的是什么呢

18:44.140 --> 18:46.020
其实我们知道这一点就OK了

18:46.020 --> 18:47.660
因为这个玩意是服务其办法的

18:47.660 --> 18:48.740
对于潜众开发来说

18:48.740 --> 18:50.180
也不需要知道它里边

18:50.180 --> 18:51.940
这个东西怎么来生存出来的

18:51.940 --> 18:53.620
但是有可能面试题会问

18:53.620 --> 18:54.580
它会问你

18:54.580 --> 18:57.140
让你阐述一下jwt的定牌格式

18:57.140 --> 19:00.420
哪里就可以详细的说一下

19:00.420 --> 19:01.380
也可以简单的说

19:01.420 --> 19:02.300
也可以详细的说

19:02.300 --> 19:04.100
那我们还是把讲完吧

19:04.100 --> 19:05.260
其实它并不复杂

19:06.420 --> 19:08.140
比方上面这个jwt

19:08.140 --> 19:08.860
它就是三部分

19:08.860 --> 19:10.540
header就在这第一个部分

19:10.540 --> 19:11.540
Pelode就第二个部分

19:11.540 --> 19:13.180
sync nature就第三个部分

19:13.180 --> 19:14.460
我们来看header

19:14.460 --> 19:16.420
header其实它就是一个接胜对象

19:16.420 --> 19:17.580
一个对象的接胜格式化

19:19.700 --> 19:22.260
接胜格式化怎么出来是这个样子

19:23.340 --> 19:24.460
它不是加密

19:24.460 --> 19:26.420
这一部分没有任何加密

19:26.420 --> 19:27.580
它做了什么事呢

19:27.580 --> 19:29.060
你看这首先看这个对象

19:29.060 --> 19:31.300
对象其实它就有两个属性

19:31.300 --> 19:34.180
第一个属性叫做算法

19:34.180 --> 19:35.740
算法的属性就是你描述一下

19:35.740 --> 19:37.900
整个jwt就是最后一部分

19:37.900 --> 19:41.060
第三部分的签名是用什么算法签名的

19:41.060 --> 19:41.900
到时候验证的时候

19:41.900 --> 19:43.500
它就会用这种算法来进行验证

19:44.500 --> 19:46.300
这是第一部分

19:46.300 --> 19:49.420
第二部分叫做类型

19:49.420 --> 19:51.900
类型就是直接固定的jwt

19:51.900 --> 19:52.940
就这么一个普通对象

19:52.940 --> 19:53.500
这是header

19:53.500 --> 19:54.780
其实没有什么信息

19:54.780 --> 19:56.260
就一个签名算法而已

19:56.260 --> 19:57.740
这算法了了解一下

19:57.740 --> 19:59.460
算法一般来说写两种

19:59.460 --> 20:01.220
一种是hs256

20:01.260 --> 20:02.820
这是一种对层加密的算法

20:02.820 --> 20:04.100
还一种是hs256

20:04.100 --> 20:06.140
就是一种非对层加密的算法

20:06.140 --> 20:08.220
那么这里我们选择一种就可以了

20:09.740 --> 20:12.100
好 那么这个对象为什么变成这个样子

20:12.100 --> 20:13.420
它是做了这么一件处理

20:13.420 --> 20:17.060
它对它进行了bes64url编码

20:18.660 --> 20:20.580
bes64是啥意思

20:20.580 --> 20:23.100
你可以去看一下这里的百度百刻

20:23.100 --> 20:27.220
bes64其实就是六十四个可打印制幅

20:28.860 --> 20:30.300
就是把任何数据

20:30.300 --> 20:33.820
变成一个六十四个可打印制幅

20:34.820 --> 20:37.020
那么六十四个可打印制幅有哪些

20:37.020 --> 20:39.980
0到9 有几个 是不是十个

20:39.980 --> 20:42.620
数字 26个英文字母

20:42.620 --> 20:44.900
大小写乘12 就是五十二个

20:46.060 --> 20:47.620
多少个了 六十二个了

20:47.620 --> 20:49.340
那么还差两个

20:49.340 --> 20:50.540
哪两个呢

20:50.540 --> 20:52.500
一个是那个加号

20:53.460 --> 20:54.380
一个是写杠

20:56.020 --> 20:58.140
然后就是一共六十四个可打印制幅

20:58.140 --> 21:01.020
它可以把任何东西转换成六十四个可打印制幅

21:01.020 --> 21:01.620
bes64

21:02.620 --> 21:05.940
那么其实在JS里边有这个东西

21:05.940 --> 21:06.980
JS里边

21:06.980 --> 21:09.140
比方说我们现在B2A

21:10.100 --> 21:11.340
B就是bes64

21:11.340 --> 21:12.740
A2B

21:14.340 --> 21:18.380
把普通字无创变成一个bes64

21:18.380 --> 21:21.740
那么比方说我给它写一个abc

21:21.740 --> 21:23.180
得到就是这个东西

21:23.180 --> 21:24.820
不是加密啊 不是加密

21:24.820 --> 21:27.820
你把这个东西可以还原成原式格式

21:27.860 --> 21:29.500
我们再来重新来一碗

21:29.500 --> 21:29.940
来个1

21:31.380 --> 21:31.900
A2B

21:33.220 --> 21:35.500
是不是写反了啊 B2A

21:35.500 --> 21:38.740
这个才是把它变成bes64

21:38.740 --> 21:40.740
对了 这个才变成bes64 写反了

21:41.900 --> 21:45.460
那么这个玩意是可以还原成这个A的

21:45.460 --> 21:46.580
哎呀 为什么有等号

21:46.580 --> 21:47.620
你不是说没有等号吗

21:47.620 --> 21:49.820
只有加号和写杠嘛

21:49.820 --> 21:51.540
这个等号是填充位

21:51.540 --> 21:53.100
就是有的时候呢

21:53.100 --> 21:56.340
不足 比方说它这里只有一个字节

21:56.420 --> 21:58.140
那么这里会填充两位

21:58.140 --> 21:59.100
把它变成三个字节

21:59.100 --> 22:01.100
它一定是得到三个字节的倍数

22:01.100 --> 22:02.500
如果说你这里写的是abc的话

22:02.500 --> 22:03.820
就没有那个了

22:03.820 --> 22:04.980
所以就没有等号了

22:04.980 --> 22:06.300
就等号是个特殊符号

22:06.300 --> 22:08.340
不过这个东西我们不用去细究

22:08.340 --> 22:09.460
总之它可以通过这种方式

22:09.460 --> 22:10.860
把它变成bes64

22:10.860 --> 22:12.300
那么bes64可以变回来吗

22:12.300 --> 22:16.960
可以变回来就是A2B

22:16.960 --> 22:18.280
所以变回来了

22:18.280 --> 22:19.800
对吧 所以这款人并不是加密

22:19.800 --> 22:22.440
哪有加密啊 没有加密啊

22:22.440 --> 22:24.160
这个加密也没有什么意义

22:24.160 --> 22:25.440
对吧 算法都是公开的

22:25.440 --> 22:26.440
你都可以变回来

22:26.440 --> 22:28.320
所以说这一部分实际上是没有加密的

22:29.120 --> 22:30.480
那么我们来验证一下

22:30.480 --> 22:31.880
我们把这个玩意儿

22:31.880 --> 22:33.720
是可以还原成它原式格式的

22:35.720 --> 22:36.320
我们来看一下

22:40.000 --> 22:42.280
把这个玩意儿还原成原式格式

22:42.280 --> 22:45.280
你看 是不是得到一个接生格式的字幕刷了

22:45.280 --> 22:47.280
算法 内销

22:47.280 --> 22:48.240
就这么简单

22:48.240 --> 22:49.360
这第一部分没有加密

22:49.360 --> 22:50.880
它就是这个东西

22:50.880 --> 22:52.400
把它变成bes64编码

22:52.400 --> 22:55.120
它只是个编码 帮到招

22:55.120 --> 22:56.080
好 第二部分

22:56.800 --> 22:59.520
再后 这是主题信息

22:59.520 --> 23:01.400
这里边记录上了

23:01.400 --> 23:03.560
记录了一些

23:03.560 --> 23:05.360
首先有一些额外的信息

23:05.360 --> 23:06.640
比方说像GWT

23:06.640 --> 23:08.440
这一次的令牌是谁搬发的

23:08.440 --> 23:09.080
对吧

23:09.080 --> 23:11.320
然后呢 发布的时间是多久

23:11.320 --> 23:12.080
到期时间

23:12.080 --> 23:13.360
所以解决个过期时间的问题

23:13.360 --> 23:14.680
过期时间就在这里边

23:14.680 --> 23:16.640
然后主题听众这些东西

23:16.640 --> 23:17.840
我们不用去管

23:17.840 --> 23:19.920
然后除此之外呢

23:19.920 --> 23:21.320
除此之外

23:21.320 --> 23:23.880
我们还可以自己定计一些信息放在这

23:24.800 --> 23:26.800
这些加面子可以资讯了解一下

23:26.800 --> 23:28.760
它有一些固定的一些信息

23:28.760 --> 23:29.240
除此之外

23:29.240 --> 23:30.560
我们可以自己定义

23:30.560 --> 23:34.770
比方说我们在这里边

23:34.770 --> 23:36.210
那么我再加一个

23:36.210 --> 23:39.090
用户的账号

23:39.090 --> 23:41.570
账号是尔德密

23:41.570 --> 23:45.850
然后用户的年龄是20岁

23:45.850 --> 23:52.980
然后用户的目前的雨额是1000块钱

23:52.980 --> 23:55.580
就可以把用户的信息都会记录到这里边

23:55.580 --> 23:57.420
是不是形成了对象

23:57.460 --> 23:59.380
然后再怎么样

23:59.380 --> 24:02.860
再把对象又进行Base 60编码

24:02.860 --> 24:04.900
就又变成这个一长圈了

24:04.900 --> 24:05.820
对吧

24:05.820 --> 24:06.460
你看

24:06.460 --> 24:07.860
再把这个东西变成一个

24:07.860 --> 24:08.940
首先把它变成接上

24:08.940 --> 24:10.500
然后进行Base 60编码

24:10.500 --> 24:12.260
比方说我们现在进行Base 60编码

24:12.260 --> 24:14.580
过后就变成这个样子了

24:14.580 --> 24:16.220
然后我们把这个样子还原

24:16.220 --> 24:17.340
你看一下

24:17.340 --> 24:18.500
A2B

24:18.500 --> 24:20.300
它也没有加密

24:20.300 --> 24:22.580
还原又还原成这个样子了

24:22.580 --> 24:22.780
对吧

24:22.780 --> 24:24.940
这是我们的制定信息

24:24.940 --> 24:26.940
这是创建时间

24:26.940 --> 24:28.940
我记不住

24:28.940 --> 24:30.940
发布时间

24:30.940 --> 24:31.940
对

24:31.940 --> 24:33.940
就硬盘的发布时间

24:33.940 --> 24:35.940
这是前量部分

24:35.940 --> 24:36.940
是不是特别简单

24:36.940 --> 24:37.940
第一部分是什么

24:37.940 --> 24:38.940
基本上是固定的

24:38.940 --> 24:39.940
对吧

24:39.940 --> 24:40.940
设置一个算法就固定下来了

24:40.940 --> 24:42.940
第二部分是什么呢

24:42.940 --> 24:44.940
是一个主体信息

24:44.940 --> 24:46.940
就是我们有些制定信息

24:46.940 --> 24:48.940
还有些到期时间都可以写到这

24:48.940 --> 24:50.940
这是前量部分

24:50.940 --> 24:52.940
第三部分是最重要的

24:52.940 --> 24:54.940
因为前量部分并没有加密

24:54.940 --> 24:56.940
第三部分是最重要的

24:56.940 --> 24:59.940
第三部分就是一个加密的结构

24:59.940 --> 25:01.940
它是防止篡改的

25:01.940 --> 25:04.940
其实就是类似于我们前面的这种做法

25:04.940 --> 25:06.940
最后一个位置放一个

25:06.940 --> 25:08.940
防止篡改的东西

25:08.940 --> 25:09.940
它是怎么做的呢

25:09.940 --> 25:10.940
它其实就是把前量部分

25:10.940 --> 25:12.940
不是前量部分生成了一个

25:12.940 --> 25:14.940
Base 60编码

25:14.940 --> 25:15.940
两部分对吧

25:15.940 --> 25:17.940
你看这第一部分

25:17.940 --> 25:18.940
第二部分

25:18.940 --> 25:21.940
然后把整个制服串

25:21.940 --> 25:24.940
使用你们之前指定的算法

25:24.940 --> 25:26.940
就之前比方说对称加密

25:26.940 --> 25:29.940
Hs256这种算法

25:29.940 --> 25:31.940
然后呢对它进行加密

25:31.940 --> 25:34.940
当然加密的时候要指定一个密钥

25:34.940 --> 25:36.940
这个密钥只能在服务端存放

25:36.940 --> 25:38.940
客户端是不能给它的

25:38.940 --> 25:39.940
不能给任何人

25:39.940 --> 25:40.940
然后加密过后

25:40.940 --> 25:43.940
是不是得到一个加密结果

25:43.940 --> 25:45.940
这个加密结果

25:45.940 --> 25:47.940
就是第三部分

25:47.940 --> 25:50.940
然后把123组装起来

25:50.940 --> 25:51.940
形成一个完整的GWT

25:51.940 --> 25:53.940
就这么简单

25:53.940 --> 25:54.940
第一部分就怕没啥用

25:54.940 --> 25:56.940
第二部分是我们的

25:56.940 --> 26:00.940
相当于是我们的这部分信息

26:00.940 --> 26:01.940
对吧 制定你的信息

26:01.940 --> 26:02.940
就是你定牌里边要存啥

26:02.940 --> 26:04.940
随便你存啥

26:04.940 --> 26:06.940
你属性的方式存进去

26:06.940 --> 26:08.940
第三部分就是对前量部分的加密结果

26:08.940 --> 26:09.940
这样的好处在什么呢

26:09.940 --> 26:11.940
就可以防止篡改了

26:11.940 --> 26:13.940
为什么呢 如果说你有一天想篡改

26:13.940 --> 26:15.940
我想把我的鱼儿

26:15.940 --> 26:18.940
我想把我的鱼儿改成

26:18.940 --> 26:19.940
10万

26:19.940 --> 26:21.940
好 这样子一改

26:21.940 --> 26:22.940
第一部分没问题

26:22.940 --> 26:23.940
第一部分我就可以得到

26:23.940 --> 26:24.940
对吧 通过

26:24.940 --> 26:26.940
一个Base 60编码就可以得到

26:26.940 --> 26:27.940
第一部分没问题

26:27.940 --> 26:28.940
我很容易就把它改了

26:28.940 --> 26:30.940
第二部分也很简单

26:30.940 --> 26:31.940
我只需要把这个东西

26:31.940 --> 26:32.940
变成一个节省格式的支付创

26:32.940 --> 26:34.940
然后用Base 60编码

26:34.940 --> 26:36.940
所以可以得到第二部分

26:36.940 --> 26:38.940
关键是第三部分我搞不定

26:38.940 --> 26:39.940
因为第三部分

26:39.940 --> 26:41.940
我要把前量部分加起来

26:41.940 --> 26:42.940
来进行加密

26:42.940 --> 26:43.940
但是我没有密要

26:43.940 --> 26:45.940
我没有服务性的密要

26:45.940 --> 26:46.940
所以说我第三部分搞不定

26:46.940 --> 26:47.940
没有办法

26:47.940 --> 26:49.940
我就说自己随便弄一个密要

26:49.940 --> 26:50.940
那生成出来的第三部分

26:50.940 --> 26:51.940
肯定是到了服务器

26:51.940 --> 26:52.940
就验证通不过了

26:52.940 --> 26:53.940
因为服务器那边

26:53.940 --> 26:55.940
拿到这个GWT之后

26:55.940 --> 26:56.940
它会把前量部分

26:56.940 --> 26:58.940
重新用之前的密要加密一次

26:58.940 --> 27:00.940
看一下跟第三部分一不一样

27:00.940 --> 27:01.940
不一样的话

27:01.940 --> 27:03.940
那肯定是被创改过的

27:03.940 --> 27:04.940
就这么一个逻辑

27:04.940 --> 27:05.940
逻辑是很简单

27:05.940 --> 27:06.940
跟我们最开始

27:06.940 --> 27:07.940
本节课最开始讲的逻辑

27:07.940 --> 27:08.940
其实是一样的

27:08.940 --> 27:12.700
其实就是一样的

27:12.700 --> 27:14.700
因此在GWT里边

27:14.700 --> 27:16.700
前量部分是没有加密的

27:16.700 --> 27:19.700
然后第三部分是前量部分

27:19.700 --> 27:22.700
对前量部分加密的结果

27:22.700 --> 27:24.700
就这么一回事

27:26.700 --> 27:28.700
最后就是令牌的验证

27:28.700 --> 27:29.700
你看

27:29.700 --> 27:30.700
就非常简单了

27:30.700 --> 27:32.700
我张浩敏把发到服务器

27:32.700 --> 27:33.700
服务器登入通过

27:33.700 --> 27:35.700
给他发一个GWT令牌

27:35.700 --> 27:36.700
保存起来

27:36.700 --> 27:37.700
然后后续了

27:37.700 --> 27:38.700
如果说这个令牌被创改了

27:38.700 --> 27:39.700
到了服务器

27:39.700 --> 27:41.700
服务器与验证通不过了

27:41.700 --> 27:44.700
他会把令牌的前量部分拿出来

27:45.700 --> 27:46.700
然后重新加密一次

27:46.700 --> 27:47.700
发现跟令牌的第三部分

27:47.700 --> 27:48.700
就对不上了

27:48.700 --> 27:50.700
那他肯定就验证通不过了

27:50.700 --> 27:53.700
所以说他能够有效的防止串感

27:55.700 --> 27:57.700
其实我们这里

27:57.700 --> 27:58.700
可以给他看一下

27:58.700 --> 27:59.700
有一个第三方库

27:59.700 --> 28:01.700
他就可以做这个事

28:01.700 --> 28:03.700
一般是在服务器端做

28:03.700 --> 28:04.700
客服装那边

28:04.700 --> 28:06.700
基本上就是保存一下GWT

28:06.700 --> 28:07.700
后续请求的时候

28:07.700 --> 28:08.700
该带过去就完成了

28:08.700 --> 28:09.700
对客服装来说没啥

28:09.700 --> 28:11.700
如果说你将来你要写

28:11.700 --> 28:13.700
用漏的接式写服务器的话

28:13.700 --> 28:15.700
也肯定是要接触GWT

28:15.700 --> 28:16.700
包括我们在以后

28:16.700 --> 28:18.700
漏的接式讲解的过程中

28:18.700 --> 28:20.700
也会给他讲到GWT

28:20.700 --> 28:22.700
就是安装一个东西

28:24.700 --> 28:25.700
看一下吧

28:25.700 --> 28:26.700
体验一下吧

28:26.700 --> 28:28.700
就是怎么回事

28:28.700 --> 28:30.700
当然这是服务器端吧

28:30.700 --> 28:32.700
我们安装一个叫做

28:32.700 --> 28:34.700
接生WebToken

28:34.700 --> 28:40.570
床的鬼那种

28:43.390 --> 28:44.390
GWT

28:44.390 --> 28:45.390
Require

28:45.390 --> 28:49.410
接生WebToken

28:49.410 --> 28:50.410
就这个玩意

28:50.410 --> 28:52.410
这个玩意里面就提供了

28:52.410 --> 28:53.410
两个方法

28:53.410 --> 28:54.410
一个是3

28:55.410 --> 28:56.410
就是

28:56.410 --> 28:57.410
发布一个令牌

28:57.410 --> 28:59.410
就生成一个令牌

28:59.410 --> 29:00.410
这个令牌

29:00.410 --> 29:02.410
第一个参数我看一下

29:03.410 --> 29:05.410
我都忘了

29:05.410 --> 29:06.410
忘了要看一下文章

29:06.410 --> 29:08.410
第一个参数就传PALO的

29:08.410 --> 29:10.410
其实里面给你封装了

29:10.410 --> 29:12.410
比方说传A等于B等于2

29:12.410 --> 29:14.410
第二个参数是传一个

29:14.410 --> 29:15.410
什么呢

29:16.410 --> 29:18.410
就是我们的加密必要

29:18.410 --> 29:20.410
我这里要写个密要

29:20.410 --> 29:21.410
这个密要只能保存在服务器

29:21.410 --> 29:23.410
比方说这个密要就是

29:25.410 --> 29:30.660
用中文

29:30.660 --> 29:32.660
最好不要用中文

29:34.660 --> 29:35.660
很帅

29:35.660 --> 29:36.660
这个密要你自己知道就行了

29:36.660 --> 29:37.660
不要告诉别人

29:37.660 --> 29:39.660
也不要在网络上做任何的传输

29:39.660 --> 29:41.660
你可以内部用一个变量

29:41.660 --> 29:44.660
或者是用一个文件

29:44.660 --> 29:46.660
把保存起来

29:47.660 --> 29:48.660
最好不要用变量

29:48.660 --> 29:50.660
一般用环境变量去保存

29:51.660 --> 29:52.660
然后把密要传进去

29:52.660 --> 29:54.660
第三部分是一个配置

29:56.660 --> 29:58.660
可以配置一些过期时间之类的

29:58.660 --> 30:00.660
就没什么好配置的

30:02.660 --> 30:04.660
这样子我就得到了一个

30:04.660 --> 30:05.660
头肯

30:05.660 --> 30:06.660
来我们来看一下

30:06.660 --> 30:12.090
就这么一上

30:12.090 --> 30:14.090
它就争成了这么一个头肯了

30:14.090 --> 30:15.090
头肯过后

30:15.090 --> 30:16.090
那么将来客户端

30:16.090 --> 30:17.090
把头肯保存起来

30:17.090 --> 30:19.090
将来寻求的时候就发过来了

30:19.090 --> 30:21.090
那么下一次它就把头肯发过来了

30:25.190 --> 30:26.190
比方说这里

30:26.190 --> 30:28.190
客户端来自于客户端的一个头肯

30:28.190 --> 30:29.190
收到了

30:29.190 --> 30:30.190
然后我要验证一下

30:30.190 --> 30:32.190
这个头肯是不是正确的

30:32.190 --> 30:34.190
然后这里就可以用Verify

30:35.190 --> 30:36.190
把头肯放进去

30:36.190 --> 30:38.190
同样的把密要给它

30:39.190 --> 30:41.190
用这个密要去验证一下

30:41.190 --> 30:42.190
验证出错的话

30:42.190 --> 30:43.190
它就会爆错

30:47.780 --> 30:48.780
没问题

30:48.780 --> 30:49.780
那没问题的话

30:49.780 --> 30:51.780
它就会返回一个结果

30:51.780 --> 30:57.940
你看

30:57.940 --> 30:58.940
就得到了

30:58.940 --> 30:59.940
得到了我们的原始结果了

30:59.940 --> 31:00.940
在这里面

31:00.940 --> 31:02.940
这个其实就是中间的那一部分

31:02.940 --> 31:03.940
有效在后

31:03.940 --> 31:04.940
它有个发布日期

31:04.940 --> 31:06.940
它会自动给你骑进去了

31:06.940 --> 31:07.940
就这么简单

31:07.940 --> 31:09.940
那如果说被创改了怎么办呢

31:09.940 --> 31:11.940
比方说我这里改了一个期

31:12.940 --> 31:13.940
创改了一下

31:13.940 --> 31:14.940
那验证就通不过了

31:14.940 --> 31:16.940
它Invalid的头肯

31:16.940 --> 31:17.940
这个头肯是无效的

31:17.940 --> 31:18.940
爆错了

31:18.940 --> 31:19.940
就这么简单

31:19.940 --> 31:21.940
这些都是在服务器那边去做的事

31:21.940 --> 31:23.940
你前段那边只需要

31:23.940 --> 31:24.940
把保存起来

31:24.940 --> 31:25.940
下一次给它扔过去就行了

31:26.940 --> 31:27.940
除非你自己莫名其妙地

31:27.940 --> 31:28.940
想去创改它

31:28.940 --> 31:29.940
也创改不了

31:30.940 --> 31:31.940
最后我们总结一下

31:31.940 --> 31:32.940
JWT

31:32.940 --> 31:34.940
它其实就是一种令牌格式

31:34.940 --> 31:36.940
它跟着怎么去传它

31:36.940 --> 31:37.940
没有关系

31:37.940 --> 31:38.940
你怎么去存它

31:38.940 --> 31:39.940
没有任何关系

31:39.940 --> 31:40.940
你想这么存就怎么存

31:40.940 --> 31:42.940
想这么传就怎么传

31:42.940 --> 31:43.940
只不过一般来说

31:44.940 --> 31:45.940
JWT一般来说

31:45.940 --> 31:46.940
就是我们的街客文档

31:46.940 --> 31:47.940
里边这种做法

31:49.940 --> 31:51.940
就是你每一次请求的时候

31:51.940 --> 31:52.940
你有这个东西

31:52.940 --> 31:53.940
你就给我带到请求头里边

31:53.940 --> 31:55.940
用这种格式带过来

31:56.940 --> 31:58.940
如果说你登陆成功了之后

31:58.940 --> 31:59.940
服务器

32:00.940 --> 32:02.940
服务器就会通过响应头

32:02.940 --> 32:04.940
把JWT告诉你

32:04.940 --> 32:05.940
有些服务型的

32:05.940 --> 32:06.940
有些公司他喜欢

32:06.940 --> 32:08.940
把它放到包里面也行

32:09.940 --> 32:12.380
面试请问看一下

32:12.380 --> 32:14.380
JWT命令牌格式

32:14.380 --> 32:15.380
是不是就非常明确了

32:15.380 --> 32:16.380
三部分一个是header

32:16.380 --> 32:17.380
一个是header

32:17.380 --> 32:18.380
一个是single nature

32:18.380 --> 32:20.380
头 负荷 然后签名

32:21.380 --> 32:22.380
然后头里边

32:22.380 --> 32:23.380
标识了你的签名算法

32:23.380 --> 32:24.380
这一部分是怎么

32:24.380 --> 32:26.380
用什么算法出来的

32:26.380 --> 32:28.380
然后令牌内容就是JWT

32:28.380 --> 32:30.380
这个部分就是主体信息

32:30.380 --> 32:31.380
里面包含了过期时间

32:31.380 --> 32:33.380
那些那些包含了内容

32:33.380 --> 32:35.380
然后single nature就是签名的结果

32:35.380 --> 32:36.380
它能有什么用呢

32:36.380 --> 32:38.380
它能够有效的防止被篡改

32:38.380 --> 32:39.380
如果说攻击者

32:39.380 --> 32:41.380
改动了前面两个部分

32:41.380 --> 32:42.380
就会导致和第三部分

32:42.380 --> 32:43.380
就对应不上了

32:43.380 --> 32:45.380
所以说这个头腾就失效了

32:45.380 --> 32:46.380
同时它在验证的时候

32:46.380 --> 32:48.380
它还会验证过期时间

32:48.380 --> 32:50.380
你过期时间到了

32:51.380 --> 32:52.380
那么这个令牌

32:52.380 --> 32:54.380
它也会自动验证失败

32:55.380 --> 32:56.380
所以说

32:56.380 --> 32:58.380
只要你的密要不被卸了

32:58.380 --> 33:00.380
一个验证通过的头

33:00.380 --> 33:02.380
可能是值得被信任的

33:02.380 --> 33:04.380
好 这就是JWT的所有知识了

