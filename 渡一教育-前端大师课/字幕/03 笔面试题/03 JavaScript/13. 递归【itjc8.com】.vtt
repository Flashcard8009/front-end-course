WEBVTT

00:01.010 --> 00:03.050
大家好 我是谢老师

00:03.050 --> 00:06.130
这节课的话 我们来看一下这个地规

00:06.130 --> 00:09.970
首先的话 我们还是从一道这个面试题入手

00:09.970 --> 00:13.810
这道面试题的话 问的是使用地规

00:13.810 --> 00:17.650
完成1到100的这个累价

00:17.650 --> 00:19.950
那这里的话 它题目要求就是什么

00:19.950 --> 00:22.010
是不是要使用这个地规

00:22.010 --> 00:25.590
实际上你这个题目完成1到100的这个累价

00:25.590 --> 00:29.430
我们不使用地规的话 我们之前使用这个

00:29.430 --> 00:31.730
复循环 是可以实现的

00:31.730 --> 00:33.530
但是这边的话 题目明确

00:33.530 --> 00:36.590
这个明确要求你使用这个地规来完成

00:36.590 --> 00:38.910
比如说这道面试题的话 它其实很明显

00:38.910 --> 00:43.250
很明显 它就是考察你 会不会使用这个地规

00:43.250 --> 00:45.310
好 那我们来看一下什么是地规呢

00:45.310 --> 00:46.570
地规

00:46.570 --> 00:49.390
这个recussive method

00:49.390 --> 00:52.730
is a method that calls itself

00:52.730 --> 00:54.010
什么意思啊

00:54.010 --> 00:56.050
就这个地规方法

00:56.050 --> 00:57.590
它是一个方法

00:57.790 --> 00:59.590
它这个方法它是干嘛的呢

00:59.590 --> 01:01.630
它是调用自己

01:01.630 --> 01:02.410
看到没有

01:02.410 --> 01:04.210
couse itself

01:04.210 --> 01:05.730
下面也有翻译

01:05.730 --> 01:08.550
地规调用是一种特殊的调用形式

01:08.550 --> 01:12.130
指的是自己调用自己

01:12.130 --> 01:15.450
它其实整个来讲的话 它分为两个步骤

01:15.450 --> 01:17.250
就是首先是地

01:17.250 --> 01:19.050
地的话就是地过去

01:19.050 --> 01:21.350
然后归 归的话就是回来

01:21.350 --> 01:23.650
你看我这边的话有张图

01:23.650 --> 01:24.410
看到没有

01:24.410 --> 01:26.730
比如我们有一个这个f

01:26.730 --> 01:27.990
f这个函数

01:27.990 --> 01:29.670
在这个f函数里面

01:29.670 --> 01:32.230
那这样又调用了f函数

01:32.230 --> 01:34.790
那这样又调用f函数

01:34.790 --> 01:36.630
那这样又调用

01:36.630 --> 01:40.150
这个的话其实就是一个地过去的过程

01:40.150 --> 01:42.810
好 那这样在最后一个

01:42.810 --> 01:45.390
再执行f函数的时候

01:45.390 --> 01:46.710
它不满足条件了

01:46.710 --> 01:49.110
那不满足条件的话 它就会停止

01:49.110 --> 01:50.750
再一次就是往下

01:50.750 --> 01:54.310
往下再次去调用f函数就不会了

01:54.310 --> 01:54.950
它就会干嘛了

01:54.970 --> 01:56.890
它就会把我这一次

01:56.890 --> 01:59.290
就这一次的这个执行结果

01:59.290 --> 02:01.330
返回去 看到没有

02:01.330 --> 02:03.930
返回去 然后接下这个函数的执行

02:03.930 --> 02:04.690
也就结束了

02:04.690 --> 02:06.770
然后再又把这个结果返回去

02:06.770 --> 02:08.930
这个我们就称之为归来

02:08.930 --> 02:10.170
所以它其实分为两步

02:10.170 --> 02:11.330
一个是地过去

02:11.330 --> 02:13.690
一个是回来

02:13.690 --> 02:14.810
OK

02:14.810 --> 02:16.890
好 然后下面的话写了一个这个

02:16.890 --> 02:18.050
地归的这个例子

02:18.050 --> 02:19.130
这个例子很简单

02:19.130 --> 02:19.930
我就不敲了

02:19.930 --> 02:21.050
我们来看一下

02:21.050 --> 02:23.410
function never end

02:23.470 --> 02:26.190
这个方法的名字叫做never end

02:26.190 --> 02:27.950
我们来看看它在做什么事情

02:27.950 --> 02:29.630
首先console.log

02:29.630 --> 02:32.430
this is a message that is never end

02:32.430 --> 02:34.750
这是一个永远不会结束的方法

02:34.750 --> 02:35.830
然后接下来这边

02:35.830 --> 02:38.510
所以它又调用了never end

02:38.510 --> 02:39.270
看到没有

02:39.270 --> 02:41.510
那这个方法是不是地归呢

02:41.510 --> 02:42.670
它是地归

02:42.670 --> 02:44.070
它不停的在调用

02:44.070 --> 02:46.110
只不过这个地归方法的话

02:46.110 --> 02:48.190
因为你没有设置结束条件

02:48.190 --> 02:50.190
所以最终你运行的时候

02:50.190 --> 02:51.790
它是会暴战的

02:51.850 --> 02:53.650
最终它的那个内存跑完了之后

02:53.650 --> 02:54.810
它就爆掉了

02:54.810 --> 02:59.290
所以说我们这边在设计这个地归的时候

02:59.290 --> 03:01.930
我们需要满足两个条件

03:01.930 --> 03:02.850
什么条件呢

03:02.850 --> 03:03.890
首先第一个

03:03.890 --> 03:08.890
地归调用必须有结束条件

03:08.890 --> 03:09.730
看到没有

03:09.730 --> 03:11.250
你必须要有结束条件

03:11.250 --> 03:12.890
你如果没有这个结束条件的话

03:12.890 --> 03:14.530
那就会像这个函数一样

03:14.530 --> 03:15.930
它就一直执行一直执行

03:15.930 --> 03:19.050
直到最后你的这个计算机的内存跑完了

03:19.050 --> 03:21.370
然后不得已它就停下来了

03:21.430 --> 03:22.870
好 接下来第二个

03:22.870 --> 03:26.310
每次调用的时候都需要根据需求

03:26.310 --> 03:29.230
改变传递的这个参数内容

03:30.030 --> 03:31.190
这句话什么意思呢

03:31.190 --> 03:32.750
就是我比如说

03:32.750 --> 03:33.750
我比如说这边

03:33.750 --> 03:36.350
这边是我在执行这个F函数

03:36.350 --> 03:36.910
对不对

03:36.910 --> 03:38.790
我在执行这个F函数的时候

03:38.790 --> 03:41.070
然后加这个函数里面是不是要去

03:41.070 --> 03:42.310
自己调用自己

03:42.310 --> 03:46.270
大家是不是再次调用自己执行这个F函数

03:46.270 --> 03:47.230
那一般来讲的话

03:47.230 --> 03:50.430
我们这边是会给这个F函数设置

03:50.450 --> 03:51.610
这个参数的

03:52.250 --> 03:53.450
设置参数的时候

03:53.450 --> 03:55.530
在这样每一次你传递的这个参数

03:55.530 --> 03:56.890
它就会改变一点

03:56.890 --> 03:59.210
每一次传递的参数就会改变一点

03:59.210 --> 04:00.290
直到最后什么呢

04:00.290 --> 04:03.050
直到最后你的参数不满足条件

04:04.130 --> 04:04.570
看没有

04:04.570 --> 04:05.730
你如果什么都不传

04:06.730 --> 04:07.650
什么都不传的话

04:07.650 --> 04:08.410
那你得看一下

04:08.410 --> 04:11.290
反正得通过一种方式来改变

04:11.290 --> 04:12.370
直到它最后什么呢

04:12.370 --> 04:15.090
最后它就是能够就是停止这个地柜

04:15.730 --> 04:17.690
反正就得有这么一个条件

04:18.250 --> 04:18.610
好吧

04:19.350 --> 04:19.750
好

04:19.750 --> 04:22.030
那我们这边我们来看一个具体的这个例子

04:22.590 --> 04:25.710
而这个例子的话是求一个这个地柜

04:26.150 --> 04:26.790
不不

04:26.790 --> 04:29.830
这个例子的话是求一个数的阶层

04:30.310 --> 04:32.230
这里的话是地柜的一个势力

04:32.230 --> 04:33.870
它是求一个数的阶层

04:34.390 --> 04:35.710
那什么叫做阶层呢

04:35.710 --> 04:37.270
来到我们这边代码

04:37.270 --> 04:38.390
什么叫阶层

04:38.390 --> 04:40.510
这是数学里面的一个这个概念

04:40.510 --> 04:41.310
比如我这边我

04:41.950 --> 04:43.950
他阶层就是写作一个感叹号

04:44.590 --> 04:45.750
我感叹号

04:45.750 --> 04:46.270
他就是什么呢

04:46.270 --> 04:48.890
他就是我乘一个4

04:48.890 --> 04:50.170
乘一个3

04:50.170 --> 04:51.370
乘一个2

04:51.370 --> 04:52.570
乘一个1

04:53.250 --> 04:54.770
这个叫做阶层

04:55.090 --> 04:56.210
那这样我这边的话

04:56.210 --> 04:57.770
比如说我有一个10

04:57.770 --> 04:59.210
我要算10的阶层

04:59.930 --> 05:01.650
那10的阶层是不是就是10

05:01.650 --> 05:03.410
从10开始乘一个9

05:03.730 --> 05:05.570
乘一个8

05:05.890 --> 05:07.370
乘一个7

05:07.770 --> 05:09.370
乘一个6

05:09.370 --> 05:10.570
我就不挨在这写了

05:10.570 --> 05:11.370
一词类推

05:11.370 --> 05:12.490
最终乘到多少

05:12.490 --> 05:14.090
是最终乘到1啊

05:14.650 --> 05:15.290
看到没有

05:15.430 --> 05:16.950
这就是数学里面

05:16.950 --> 05:18.230
阶层的这个概念

05:18.550 --> 05:19.430
那我们现在的话

05:19.430 --> 05:21.510
得通过这个帝规的形式

05:22.390 --> 05:23.750
来书写这个

05:24.670 --> 05:25.990
阶层啊

05:25.990 --> 05:26.510
好

05:26.510 --> 05:27.230
那我们这边的话

05:27.230 --> 05:29.750
我们假设有这么一个这个函数

05:29.750 --> 05:30.430
比如说

05:30.630 --> 05:31.190
funk

05:32.150 --> 05:33.390
假设叫做funk

05:33.390 --> 05:34.510
这么一个这个函数

05:34.510 --> 05:35.830
这个函数的话

05:35.830 --> 05:37.190
他就可以计算

05:37.190 --> 05:38.230
某个数的阶层

05:38.230 --> 05:39.990
比如说我给他传一个10

05:39.990 --> 05:41.590
他就会给我返回什么呢

05:41.590 --> 05:43.190
他就会给我返回

05:43.190 --> 05:45.190
这个10的阶层

05:45.950 --> 05:46.550
看到没有

05:46.550 --> 05:47.190
然后接下来

05:47.190 --> 05:47.950
我们这边

05:49.830 --> 05:50.350
funk

05:51.630 --> 05:52.870
或者我们就用我们这边

05:52.870 --> 05:54.430
这个粒子的这个名字吗

05:55.030 --> 05:55.790
那粒子的话

05:55.790 --> 05:56.630
这个叫做这个

05:56.630 --> 05:57.550
这个好像就是

05:57.550 --> 05:59.030
求阶层的那个单词啊

05:59.030 --> 05:59.830
我查一下

06:00.830 --> 06:02.550
我记得这个就是阶层的单词

06:05.560 --> 06:07.280
这个叫做factorial

06:08.120 --> 06:09.480
factorial

06:09.480 --> 06:10.360
factorial

06:10.360 --> 06:10.920
ok

06:11.480 --> 06:11.720
好

06:11.720 --> 06:12.920
然后这样我们这边就用这个

06:13.120 --> 06:13.920
factorial

06:15.040 --> 06:15.360
好

06:15.360 --> 06:16.200
然后接下这边的话

06:16.200 --> 06:16.560
你比如说

06:16.560 --> 06:17.520
你给他传一个

06:18.420 --> 06:20.420
然后他就会给你返回什么呢

06:20.420 --> 06:22.020
就会给你返回

06:22.020 --> 06:23.020
我的阶层

06:23.420 --> 06:24.020
看到没有

06:24.020 --> 06:24.820
那我们这边的话

06:24.820 --> 06:27.020
我们先假设这个函数已经写好了

06:28.020 --> 06:29.620
你这个在写阶层的时候

06:29.620 --> 06:31.420
你一定要有委托的思想

06:32.020 --> 06:32.820
就这两个字

06:33.220 --> 06:34.020
委托

06:38.770 --> 06:39.570
委托

06:40.570 --> 06:41.370
什么委托

06:41.370 --> 06:42.050
什么叫委托

06:42.050 --> 06:43.250
就是我委托他

06:43.250 --> 06:44.850
我不管他是怎么实现的

06:45.370 --> 06:46.970
我不管他是怎么实现的

06:46.970 --> 06:49.170
我假设我的这个函数已经写好了

06:49.570 --> 06:50.370
已经写好了

06:50.370 --> 06:52.370
然后接下来我给他传一个5

06:52.370 --> 06:54.770
他就会给我返回5的阶层

06:54.770 --> 06:56.370
我给他传一个10

06:56.370 --> 06:58.970
他就会给我返回一个10的阶层

06:59.170 --> 06:59.570
好

06:59.570 --> 07:01.970
那接下来我们以这个5的阶层为例

07:02.170 --> 07:04.770
那比如说我要计算这个5的阶层

07:05.170 --> 07:07.570
那他是不是等价于什么

07:07.970 --> 07:11.770
等价于我成一个4的阶层

07:13.510 --> 07:14.410
你思考一下

07:14.410 --> 07:15.010
是不是

07:15.610 --> 07:16.210
对不对

07:16.410 --> 07:17.210
好到接下来的话

07:17.210 --> 07:19.610
那就是那我们的问题就集中在哪里了

07:19.710 --> 07:21.310
是不是计算4的阶层

07:21.710 --> 07:22.910
那计算4的阶层

07:22.910 --> 07:25.310
他是不是就等价于什么呀

07:25.310 --> 07:28.310
是不是4乘一个3的阶层

07:29.410 --> 07:29.910
对不对

07:30.210 --> 07:30.410
好

07:30.410 --> 07:31.710
然后接下来的话最终

07:31.910 --> 07:33.510
然后3的阶层

07:33.910 --> 07:34.710
他等价于什么呢

07:34.710 --> 07:37.910
等价于3乘一个2的阶层

07:37.910 --> 07:38.210
好

07:38.210 --> 07:39.910
1次内退2的阶层

07:39.910 --> 07:43.410
等价于这个2乘一个1的阶层

07:43.710 --> 07:45.110
那1的阶层就最好算

07:45.110 --> 07:46.310
1的阶层就是多少

07:46.510 --> 07:47.310
是不是就是1

07:48.610 --> 07:49.110
看不看

07:49.610 --> 07:50.510
那通过这个的话

07:50.510 --> 07:52.010
那我们就可以写出这个

07:52.510 --> 07:53.410
第一规这个方法

07:53.610 --> 07:53.710
好

07:53.710 --> 07:54.710
我们这边我们来写一下

07:56.510 --> 07:58.110
这边的话就是方形

07:59.010 --> 08:00.310
把它接收一个数

08:00.710 --> 08:01.410
接收一个数

08:01.410 --> 08:02.810
假设是一个x

08:04.210 --> 08:04.510
好

08:04.510 --> 08:05.810
那接下来传过来

08:06.210 --> 08:07.610
这个x传过来之后

08:07.610 --> 08:09.110
然后接下来如果

08:10.010 --> 08:11.310
这个x

08:12.510 --> 08:14.310
x等于一个1

08:14.610 --> 08:16.310
那说明用户要计算多少

08:16.510 --> 08:18.210
是不计算这个1的阶层

08:19.310 --> 08:20.710
那么用户要计算1的阶层

08:20.710 --> 08:21.810
1的阶层就是多少

08:22.410 --> 08:24.610
1的阶层是不是就是一样

08:25.010 --> 08:25.410
对不对

08:25.410 --> 08:28.210
我直接反回一否则的话

08:28.710 --> 08:31.210
那说明用户传的这个数不是1

08:31.410 --> 08:32.710
那不是1的话

08:32.710 --> 08:34.110
那接下来我就计算

08:34.610 --> 08:37.410
这个一直到x的这个阶层

08:37.510 --> 08:38.510
那到x的阶层

08:38.510 --> 08:40.510
那是不是就等价于x

08:40.910 --> 08:42.010
乘以一个

08:42.110 --> 08:43.310
你这个函数是不是就是

08:43.310 --> 08:44.810
结算这个阶层的

08:45.310 --> 08:45.710
对不对

08:45.710 --> 08:47.010
那我调用这个函数

08:47.010 --> 08:48.110
然后价传入什么呢

08:48.110 --> 08:49.910
传入x-1

08:50.910 --> 08:51.410
看没有

08:51.410 --> 08:52.610
那最终把这个值

08:53.110 --> 08:53.910
返回出去

08:54.710 --> 08:56.410
你看和上面的这个思想是不是一样的

08:56.510 --> 08:57.910
你假设这边是传的5吗

08:58.610 --> 08:59.710
假设这边是传的5

08:59.810 --> 09:00.310
5的话

09:00.310 --> 09:01.810
然后价不进一符进l4

09:01.810 --> 09:03.210
那价这边是不是就变成5

09:03.410 --> 09:04.710
5乘以一个多少

09:04.810 --> 09:05.910
是不是乘以一个这个

09:06.310 --> 09:07.610
继续调用这个函数

09:07.710 --> 09:08.210
调用这个函数

09:08.210 --> 09:09.710
然后价这边就传的多少了

09:09.810 --> 09:10.910
是不是传的是4

09:10.910 --> 09:12.410
那最终整个这个函数是

09:12.610 --> 09:13.810
会给我返回什么

09:13.910 --> 09:15.810
是不是会给我返回4的阶层

09:16.210 --> 09:16.710
对不对

09:16.810 --> 09:17.910
那接下再次调的时候

09:17.910 --> 09:19.810
然后价这里接收的参数就是4了

09:19.910 --> 09:21.110
那价这边就是4

09:21.310 --> 09:22.010
乘一个什么呢

09:22.010 --> 09:23.310
乘一个这里就是3

09:23.810 --> 09:25.410
3然后价过来这边是3

09:25.410 --> 09:26.810
那价这边变成3

09:27.210 --> 09:28.410
乘一个这个

09:28.810 --> 09:29.710
这里是2

09:30.110 --> 09:30.510
对吧

09:30.510 --> 09:31.110
直到什么呢

09:31.110 --> 09:33.610
直到最终这个x是1的时候

09:33.810 --> 09:35.510
进来直接返回1

09:35.510 --> 09:38.110
那价一步一步又返还回去

09:39.510 --> 09:40.010
看到没有

09:42.010 --> 09:42.910
啊看到没有

09:43.010 --> 09:44.510
这个的话就是我们这个

09:45.610 --> 09:47.610
这个就是我们这个计算这个阶层

09:48.010 --> 09:49.210
啊计算这个阶层

09:49.410 --> 09:50.810
那我刚刚把什么打开了

09:51.310 --> 09:54.940
稍微等一下啊把这个打开了

09:55.140 --> 09:57.140
这就是我们这个计算阶层的这个函数

09:57.540 --> 09:59.440
好回到我们的这个课件啊

09:59.440 --> 10:02.340
这个的话可能大家看我写起来很简单哈

10:02.440 --> 10:05.940
但是如果你之前没有接触过这个低规的话

10:05.940 --> 10:08.240
你是需要反复去练习的

10:08.540 --> 10:10.440
啊一定要把这个想明白

10:10.640 --> 10:14.040
刚开始学习这个低规的同学可能会觉得比较绕

10:14.340 --> 10:15.940
啊比较绕你就写简单点嘛

10:15.940 --> 10:17.340
你这边就不要传5嘛

10:17.340 --> 10:18.940
你传个几嘛你传个3嘛

10:19.640 --> 10:20.240
对不对

10:20.340 --> 10:22.140
传个3然后加你一步一步看

10:22.340 --> 10:24.040
看是不是这样子的啊

10:24.540 --> 10:26.840
好这是关于我们的这个低规

10:27.840 --> 10:29.940
看到没有啊然后加我这边写了下

10:30.040 --> 10:32.640
整个低规的这个计算过程如下

10:33.040 --> 10:34.440
啊首先这边是不是传了5啊

10:34.940 --> 10:37.240
传了5然后加等价于什么呢5

10:37.740 --> 10:38.740
乘一个这边

10:39.040 --> 10:42.040
说这个再次调用这个函数

10:42.040 --> 10:43.440
大家传入这个4

10:44.340 --> 10:46.440
对不对好大家这边等价于什么呢

10:46.440 --> 10:47.540
等价于这边4

10:47.740 --> 10:49.840
乘一个这边再次调用这个函数

10:50.140 --> 10:50.940
传入3

10:51.340 --> 10:52.840
然后接下来传入2

10:53.140 --> 10:56.140
传入1那传入1最终这这个值就返回什么

10:56.740 --> 10:58.440
这个值返回是不是就是返回1

10:58.840 --> 11:01.140
返回1然后接下来这边2乘1啊

11:01.140 --> 11:02.140
这边是不是得到

11:02.840 --> 11:03.240
2

11:03.540 --> 11:04.440
然后一步一步

11:04.640 --> 11:07.140
然后接下来又把这个结果是不是返还回去

11:07.340 --> 11:09.140
啊最终得到什么呢得到这个

11:09.340 --> 11:11.740
120啊我们这边可以来验证一下嘛

11:12.240 --> 11:13.240
就我们这边的话

11:15.280 --> 11:15.980
log一下

11:18.660 --> 11:19.660
调用这个方法

11:20.060 --> 11:20.760
传入5

11:21.160 --> 11:22.360
好然后接下这边

11:23.760 --> 11:24.460
load

11:28.420 --> 11:28.920
走

11:29.820 --> 11:30.420
看到没有

11:30.720 --> 11:32.720
是OK的啊没有问题的

11:33.420 --> 11:33.920
好

11:34.720 --> 11:36.620
然后接下这边这边还有个图哈

11:36.720 --> 11:37.820
就是一步一步的

11:38.620 --> 11:41.220
5 4 3 2 1

11:41.220 --> 11:43.420
好大家这边是不是又一步一步回去啊

11:43.820 --> 11:44.320
对不对

11:45.020 --> 11:46.520
你一定要把这个例子搞懂

11:47.520 --> 11:50.520
啊就是我们这边使用这个阶层的这个例子

11:50.720 --> 11:53.520
这里的话就是使用这个地规

11:53.720 --> 11:56.020
来计算了这个数的这个阶层

11:56.120 --> 11:57.120
把这个例子搞懂

11:57.620 --> 12:00.620
搞懂之后让我下面还有扩展的两个例子

12:00.720 --> 12:02.920
啊我们来看一下啊这边有一些注意思想

12:02.920 --> 12:03.720
我们来读一下嘛

12:04.120 --> 12:08.220
首先地规函数的优点就是定义简单逻辑清晰啊

12:08.220 --> 12:12.520
理论上所有地规函数都可以用循环的方式来实现

12:12.920 --> 12:14.020
就是我们的循环

12:14.220 --> 12:15.820
大家学过循环对不对

12:15.820 --> 12:18.120
无论是否循环还是wild循环啊

12:18.120 --> 12:19.720
但否循环和wild循环

12:19.920 --> 12:22.020
本身两者之间就可以相互转换的

12:22.420 --> 12:25.920
好那所有的这个复循环都可以改成地规的

12:26.620 --> 12:28.120
都可以改成地规为什么呢

12:28.120 --> 12:30.320
因为你想想你那个复循环是不是也是

12:30.320 --> 12:33.520
就是呃第一个是第一个表达是

12:33.820 --> 12:35.020
啊我们这边写一下嘛

12:35.720 --> 12:37.320
比如你想想你的那个复循环

12:38.320 --> 12:39.620
比如说我们这边的话

12:40.020 --> 12:41.520
就是从一加到一百吗

12:41.920 --> 12:43.920
哇一个i等于一个一

12:44.120 --> 12:46.520
然后i小于等于一个一百

12:46.820 --> 12:48.520
i加加好我就不写完了哈

12:48.620 --> 12:50.320
你想想你的那个复循环

12:50.320 --> 12:52.520
你看这边是不是就是在不停的在改变条件

12:53.420 --> 12:56.220
看到没有改变了之后然后接下来下一次这边

12:56.320 --> 12:58.320
i加加哦这里啊这里

12:58.420 --> 13:01.920
sorry这里啊就这里是不是不停的在这个改变条件

13:02.220 --> 13:04.020
改变了之后然后接下来改变了之后

13:04.020 --> 13:08.420
那下次是不是在判断判断是否还符合这个循环

13:09.220 --> 13:10.920
如果不符合是不是就跳出去

13:11.020 --> 13:13.120
符合的话就在这里执行

13:13.320 --> 13:15.020
对应的这个复循环的逻辑

13:15.020 --> 13:16.320
然后在这边是不是又改变

13:16.720 --> 13:18.020
那是不是就类似于这边

13:18.120 --> 13:20.420
调用函数然后函数的这个参数改变

13:21.320 --> 13:22.620
对不对啊

13:23.220 --> 13:26.220
说任何的这个循环其实都是可以改成这个

13:26.220 --> 13:26.920
抵规的

13:27.520 --> 13:29.920
好我这边的话还有两个这个例子

13:29.920 --> 13:32.320
我们来看一下啊这里这里就是

13:32.720 --> 13:35.920
计算从ok是加到y的这个结果

13:36.220 --> 13:38.220
啊我们这边把这个例子我们来写一些

13:39.420 --> 13:40.520
把这个注释掉

13:41.520 --> 13:43.420
这边的话我们就假设是一个funk嘛

13:44.020 --> 13:45.020
好然后接下来

13:46.020 --> 13:48.420
接下来的话它是可以什么的接受两个参数

13:48.420 --> 13:50.020
一个是x y

13:50.320 --> 13:51.820
好然后加它返回什么呢

13:52.020 --> 13:53.620
返回就是从

13:57.520 --> 13:58.620
从ok是

13:59.320 --> 14:00.320
加到

14:01.120 --> 14:01.520
y

14:02.320 --> 14:03.720
看没有它返回这个

14:03.920 --> 14:05.520
什么叫做从ok是加到y

14:05.720 --> 14:06.420
就这个意思

14:06.720 --> 14:08.620
就比如说我ok是传的是1

14:08.720 --> 14:10.420
然后接下来y传的是100

14:10.520 --> 14:11.920
那它就是会返回什么呢

14:12.120 --> 14:13.620
返回从

14:14.120 --> 14:14.620
1

14:15.220 --> 14:15.920
加到

14:18.190 --> 14:19.090
加到100

14:20.090 --> 14:21.290
那什么叫做重新加到100

14:21.290 --> 14:22.090
就是1

14:22.390 --> 14:23.290
加2

14:23.590 --> 14:24.690
加3

14:24.890 --> 14:25.790
加4

14:26.090 --> 14:27.090
以此类推

14:27.890 --> 14:28.890
以此类

14:29.890 --> 14:31.790
以此类推

14:31.990 --> 14:33.090
一直加到多少呢

14:33.090 --> 14:34.390
加到99

14:34.490 --> 14:35.790
加到100

14:36.290 --> 14:38.190
这个我们之前是不是使用这个复讯环

14:38.290 --> 14:38.990
来写的

14:39.490 --> 14:39.990
对不对

14:40.190 --> 14:42.190
好那我们这边我们用地规来写一下

14:42.690 --> 14:44.690
那用地规来写一下你想一想啊

14:44.690 --> 14:46.190
比如说我从1

14:46.790 --> 14:47.690
加到多少呢

14:47.690 --> 14:48.690
加到100

14:48.890 --> 14:51.390
它是不是就等价于100

14:51.990 --> 14:53.190
加上一个

14:53.490 --> 14:54.290
假设我们这个

14:54.990 --> 14:56.090
放课已经写好了

14:56.690 --> 14:57.590
已经写好了

14:58.290 --> 15:00.690
是不是就是从1加到99的值

15:01.790 --> 15:02.290
对不对

15:02.490 --> 15:03.990
把前面也换成这个吗

15:05.390 --> 15:06.890
这边的话是100

15:06.890 --> 15:08.290
从1加到100

15:08.590 --> 15:10.290
它是不是就等价于从100

15:10.690 --> 15:11.390
加到

15:11.490 --> 15:13.190
这个从1加到99的值

15:13.390 --> 15:15.190
那从1加到99的值

15:15.190 --> 15:17.990
是不是又等价于99

15:18.390 --> 15:19.890
加上一个

15:21.090 --> 15:23.090
这个从1加到98

15:24.890 --> 15:25.390
对不对

15:25.690 --> 15:27.090
好那最终到多少

15:27.390 --> 15:29.690
最终的话是不是就是会到这个1

15:30.090 --> 15:31.590
那从1加到1

15:32.890 --> 15:33.390
放

15:33.790 --> 15:35.390
最终这个从1加到1

15:35.390 --> 15:36.990
那最终得到的值就是多少

15:37.890 --> 15:38.690
就是1

15:39.590 --> 15:40.190
看到没有

15:40.590 --> 15:40.990
啊

15:40.990 --> 15:43.190
那和刚才的话其实是类似的

15:43.590 --> 15:45.290
好那我们这边我们就来输写一下

15:45.690 --> 15:46.590
这边的话放

15:46.790 --> 15:47.390
function

15:48.090 --> 15:48.590
funk

15:48.990 --> 15:50.090
接收两个参数

15:50.190 --> 15:51.690
一个是x

15:51.790 --> 15:52.690
一个是y

15:54.090 --> 15:54.490
好

15:54.890 --> 15:55.490
return

15:56.790 --> 15:57.290
不不

15:57.290 --> 15:58.190
这边判断

15:58.590 --> 15:59.090
if

16:00.390 --> 16:01.090
if什么呢

16:01.090 --> 16:02.590
if你的x

16:03.190 --> 16:04.690
全等于这个y

16:05.290 --> 16:07.490
那这边的话你就直接return一个

16:07.690 --> 16:08.290
x

16:08.890 --> 16:11.090
对不对啊否则的话

16:11.590 --> 16:13.290
这里的话就是应该是return什么

16:13.690 --> 16:16.690
所以你从ak4加到y就等价于什么了

16:16.890 --> 16:18.190
等价于y

16:18.690 --> 16:21.390
加上一个啊继续掉这个函数

16:21.590 --> 16:23.090
然后接下从这个

16:23.990 --> 16:24.390
我看

16:24.790 --> 16:25.790
从ak4

16:26.290 --> 16:28.890
然后加到什么是y-1啊

16:30.090 --> 16:30.990
这边是这个样子

16:31.390 --> 16:32.390
对你假设这边吗

16:32.390 --> 16:33.690
假设这边这个是传的1

16:33.690 --> 16:34.590
这个传的100

16:34.690 --> 16:35.790
那这边是不是100

16:36.490 --> 16:37.690
对不对大家这边1

16:38.390 --> 16:40.190
从1加到多少是不是99

16:40.590 --> 16:40.990
对不对

16:40.990 --> 16:43.090
你这边带个数进去看一下就可以了

16:44.090 --> 16:45.490
好了我们这边我们来看一下好不好

16:45.490 --> 16:45.890
死

16:46.590 --> 16:47.590
这边的话

16:47.690 --> 16:49.590
console.log

16:49.890 --> 16:50.390
放卡

16:51.590 --> 16:53.690
从1加到100

16:54.390 --> 16:56.290
好然后加这边执行一下

16:56.790 --> 16:57.690
这5050

16:58.190 --> 16:58.890
ok的吧

16:59.190 --> 17:02.090
对不对从1加到100的值就是5050

17:03.390 --> 17:04.590
这是第2个

17:04.990 --> 17:06.090
低规的这个例子

17:06.690 --> 17:08.190
然后这边还举了一个例子

17:08.890 --> 17:11.790
还举了一个例子是这个非波拉切数的

17:12.390 --> 17:14.590
我们把这个的话也带着大家写一写吧

17:15.590 --> 17:17.190
这个低规这是第2个例子

17:17.390 --> 17:19.290
然后加这边低规第3个例子

17:21.390 --> 17:22.190
低规

17:22.990 --> 17:24.390
第3个例子

17:25.490 --> 17:26.890
怎么了非波拉切

17:27.990 --> 17:29.690
非波拉切

17:32.500 --> 17:33.300
拉切

17:34.300 --> 17:34.900
数捏

17:35.800 --> 17:38.500
那首先的话你得知道什么是非波拉切数捏

17:38.700 --> 17:39.600
啊你这边的

17:39.900 --> 17:43.600
其实大家之前写的一个误寻环哈应该是练习过的

17:44.400 --> 17:46.400
非波拉切数捏

17:48.100 --> 17:49.600
什么是非波拉切数捏

17:50.000 --> 17:52.700
我们来看一下啊又被称之为兔子数捏

17:53.000 --> 17:55.800
指的是这样子的一个数捏啊首先从0开始

17:55.900 --> 17:56.900
第一位是0

17:57.300 --> 18:00.600
然后接下来第二位是什么呢第二位是这个1

18:01.600 --> 18:02.600
把这个关一下

18:04.540 --> 18:05.840
好第二位是这个1

18:06.140 --> 18:08.040
好然后接下来第三位是1

18:08.140 --> 18:11.040
好然后接下来该开始啊挨着挨着的

18:11.340 --> 18:14.440
呃后面一位就等于什么呢等于前两位之和

18:15.240 --> 18:16.540
看到没有我把这个复制过来

18:20.780 --> 18:21.280
啊

18:21.680 --> 18:25.880
这边后面从第3位开始第3位就等于前面两位之和

18:26.280 --> 18:28.680
啊人家这边220不等于1加1

18:29.080 --> 18:30.480
3是不等于1加2

18:30.780 --> 18:32.580
然后5是不是等于2加3

18:32.780 --> 18:37.280
对不对8等于个3加5啊也就是说后面那位就等于前面那位

18:37.380 --> 18:37.980
之和

18:38.280 --> 18:41.080
好了现在的话我们希望有什么呢有这么一个方法

18:41.480 --> 18:45.480
方法随便取了一个名字好那我们这边就随便取个名字吗

18:45.480 --> 18:47.680
比如说这边的话就是这个funk

18:48.580 --> 18:49.380
还是funk

18:49.980 --> 18:53.980
比如说我这边的话我传一个这个55的话就是位数

18:54.680 --> 18:55.580
这个就是位数

18:55.780 --> 18:58.180
好然后接下来他就会给我返回什么呢

18:58.580 --> 19:00.380
他就会给我返回

19:01.780 --> 19:04.680
5上面的第5位

19:05.880 --> 19:07.080
第5位

19:07.780 --> 19:09.580
所对应的

19:09.980 --> 19:11.780
飞波拉切数

19:14.460 --> 19:18.560
看没有啊这个的话以前用那个复循环也是写过的

19:18.960 --> 19:19.460
对不对

19:19.660 --> 19:22.460
那第5位的飞波拉切数是不是就等于

19:23.060 --> 19:23.760
funk

19:24.960 --> 19:27.860
4加上一个funk

19:28.460 --> 19:29.960
3对不对

19:30.160 --> 19:34.060
反正你告诉我你跟我说这个funk这个啊我就可以返回

19:34.760 --> 19:37.460
返回对应这个位数的飞波拉切数

19:37.560 --> 19:40.760
那我不管你怎么实现的那我这边的话是不是就直接

19:41.160 --> 19:44.960
就是应该是等于第4位上的这个飞波拉切数加上第3位的

19:45.160 --> 19:45.960
飞波拉切数

19:46.560 --> 19:47.560
是不是应该是这样子的

19:48.060 --> 19:48.960
对不对啊

19:48.960 --> 19:52.460
说说我们这边我们就可以来写function funk

19:52.960 --> 19:54.960
说一定要有这个委托的思想

19:55.860 --> 19:56.460
知道吧

19:56.660 --> 19:57.860
一定要有委托的思想

19:57.860 --> 19:59.260
好比如说这边接受一个参数

19:59.260 --> 20:01.560
这个参数是不是应该是位数

20:02.860 --> 20:04.060
啊这个应该是位数

20:04.260 --> 20:05.260
好位数完了之后

20:05.260 --> 20:06.860
然后接下来eif

20:07.360 --> 20:09.660
x全等于一个这个e

20:09.660 --> 20:11.660
说明是第一位第一位是不是写死啊

20:12.660 --> 20:14.760
对不对啊第一位写死是0

20:15.060 --> 20:16.960
好然后接下来l是

20:17.760 --> 20:18.260
if

20:18.860 --> 20:20.060
这个x

20:20.560 --> 20:21.660
等于一个这个2

20:22.360 --> 20:24.160
等于一个这个2的话然后加这边

20:24.360 --> 20:26.260
第二位的话是多少是不是1

20:27.060 --> 20:27.560
对不对

20:27.960 --> 20:30.860
好的加否则不是第一位也不是第二位

20:30.960 --> 20:33.360
那说明是这个第3位以及后面的

20:33.460 --> 20:34.760
那后面的话

20:34.960 --> 20:37.960
是不是就是应该是等于一个 funk

20:38.960 --> 20:41.860
x-1是不是你的上一位的飞波拉切数

20:42.260 --> 20:43.860
加上一个

20:45.060 --> 20:46.760
上上位的飞波拉切数

20:46.860 --> 20:49.060
那是不是就是应该是x-2啊

20:50.560 --> 20:51.160
看到没有

20:51.460 --> 20:52.660
是不是也是这个样子的

20:53.060 --> 20:53.960
啊我们这边呢

20:53.960 --> 20:54.860
我们来试验一下嘛

20:54.860 --> 20:56.360
比如我们这边啊

20:56.360 --> 20:58.260
log funk

20:59.260 --> 21:00.460
然后我们穿第几位呢

21:00.460 --> 21:03.060
比如说12345比我们就

21:03.460 --> 21:04.460
就看第五位

21:04.960 --> 21:06.560
好然后接下来我们这边走

21:07.860 --> 21:08.560
是不是就是3

21:09.260 --> 21:13.060
看到没有比如说这567第七位应该是8

21:13.760 --> 21:14.560
第七位

21:15.560 --> 21:16.760
看到没有

21:17.160 --> 21:18.760
所以就通过这个地规的思想

21:19.160 --> 21:21.960
是不是来这个做这个飞波拉切数列的这个

21:22.060 --> 21:22.760
这个T

21:23.360 --> 21:24.560
看到没有啊

21:24.860 --> 21:25.760
所以总之的话

21:25.760 --> 21:26.860
整个这个地规的话

21:26.860 --> 21:28.460
就是大家下去要多练一下

21:28.460 --> 21:30.960
大家先把这三个练习哈

21:31.160 --> 21:32.160
先把它搞懂

21:32.360 --> 21:33.160
搞懂了之后

21:33.160 --> 21:34.560
然后接下来下去的话可以

21:34.660 --> 21:35.960
就是自己再练一下

21:36.160 --> 21:38.360
把你之前写的这个课讯环

21:38.660 --> 21:41.360
大家之前应该是做过很多课讯环的这个练习

21:41.660 --> 21:42.160
对不对

21:42.160 --> 21:43.860
好你都可以改成什么呢

21:43.960 --> 21:46.060
都可以改成这个地规

21:46.660 --> 21:47.860
啊都可以改成地规

21:48.660 --> 21:49.060
好

21:49.460 --> 21:51.160
然后最后这个整体解答

21:51.160 --> 21:54.260
使用地规完成1-100的这个磊夹

21:54.660 --> 21:55.860
那这个是不是很简单了

21:56.160 --> 21:56.460
对不对

21:56.460 --> 21:59.560
而且他这边都告诉你1-100你这边都可以

22:00.360 --> 22:02.060
啊这边就写个方法嘛

22:02.060 --> 22:04.560
写个方法让家这边穿穿100

22:04.560 --> 22:05.760
其实就是我们刚才的

22:05.860 --> 22:06.660
是这道题

22:07.760 --> 22:08.460
是不是这道题

22:09.160 --> 22:09.660
好吧

22:09.960 --> 22:11.860
好大家下来的话可以把这个地规

22:12.060 --> 22:13.060
再看一看

22:13.560 --> 22:15.060
这期课就先到这里

22:15.260 --> 22:15.760
拜拜

