WEBVTT

00:00.620 --> 00:02.620
大家好 我是谢老师

00:02.620 --> 00:07.020
这个课的话 我们来看一下这个面试题里面经常爱问的

00:07.020 --> 00:12.620
关于这个net,wa和const 他们三者的这个区别

00:12.620 --> 00:15.620
首先的话 这边有一道这个整体

00:15.620 --> 00:17.620
net,const,wa的区别

00:17.620 --> 00:22.620
然后还顺便问你什么是快捷作用于 如何用

00:22.620 --> 00:27.620
其实主要就是考察的这三个关键字 它的区别

00:27.620 --> 00:29.620
好 我们知道在我们的JS里面

00:29.620 --> 00:34.620
声明这个变量 它的这个关键字有三种

00:34.620 --> 00:39.620
哪三种呢 一个是wa 然后net,const

00:39.620 --> 00:42.620
为什么会有三种呢 之所以有三种

00:42.620 --> 00:45.620
这个其实是由历史原因造成的

00:45.620 --> 00:49.620
我们知道最早的时候只有什么

00:49.620 --> 00:52.620
最早的时候是不是只有wa 对不对

00:52.620 --> 00:55.620
然后到了es6之后 然后给我们提供了什么

00:55.620 --> 00:58.620
给我们提供了net和const

00:58.620 --> 01:02.620
那既然提供了就是新的声明变量的方式

01:02.620 --> 01:06.620
那它一定是为了解决就是就的 就是这个wa

01:06.620 --> 01:09.620
它的这个声明方式 它的一些缺陷

01:09.620 --> 01:12.620
所以才会添加了这两种

01:12.620 --> 01:15.620
好 那接下来我们就来看一下他们的区别

01:15.620 --> 01:18.620
那在正式讲区别之前的话

01:18.620 --> 01:22.620
我们这边首先有个东西 要看一下就是关于作用于

01:22.620 --> 01:26.620
什么是作用于 在我们这个es6之前

01:26.620 --> 01:29.620
就是说es5 作用于的话有两种

01:29.620 --> 01:34.620
一种是全局作用于 一种是韩数作用于

01:34.620 --> 01:37.620
但其实还有一种 还有一种叫做以我作用于

01:37.620 --> 01:40.620
但以我的话用的很少 什么叫全局作用于

01:40.620 --> 01:44.620
全局作用于就是 比如说我这边我来写个代码

01:44.620 --> 01:48.620
一个i 一个e

01:48.620 --> 01:52.620
ok 那我这个i 就是在我整个这段

01:52.620 --> 01:55.620
脚本里面都可以使用的

01:55.620 --> 01:58.620
那我们就说它是在全局作用于里面

01:58.620 --> 02:00.620
然后还有一个是什么呢

02:00.620 --> 02:04.620
还有一个是这个韩数作用于 韩数作用于

02:04.620 --> 02:09.620
比如说我这边写一个function test

02:09.620 --> 02:15.190
one 一个这个j 等于一个二

02:15.190 --> 02:18.190
那么我的这个j的这个j

02:18.190 --> 02:21.190
j的这个变量的话 它能生效的地方就只有什么呢

02:21.190 --> 02:24.190
只有什么呢 只有在这个韩数里面

02:24.190 --> 02:28.190
一旦出了这个韩数 你是不是就不能使用这个j了

02:28.190 --> 02:31.190
比如说我们这边我们来log一下

02:31.190 --> 02:35.570
log这个j 然后这样我们这边我们来看一下

02:35.570 --> 02:37.570
刷新

02:40.570 --> 02:45.140
重新到这边来 重新刷新

02:45.140 --> 02:48.140
看到没有 这j is not defend

02:48.140 --> 02:51.140
为什么 因为我们这边

02:51.140 --> 02:55.140
因为我们这边的话这个j是在这个韩数里面生命的

02:55.140 --> 02:57.140
那在这个韩数里面生命的话

02:57.140 --> 02:59.140
它就只能在这个韩数里面用

02:59.140 --> 03:01.140
它的作用于就在这个韩数里面

03:01.140 --> 03:05.140
最早的话在这个es5里面

03:05.140 --> 03:09.140
就只有全局作用于 韩数作用于

03:09.140 --> 03:13.140
到了es6 就新增了什么呢 新增了快作用于

03:13.140 --> 03:15.140
什么叫做快作用于

03:15.140 --> 03:19.140
快作用于就是由一对大扩号来进行这个

03:20.140 --> 03:23.140
包括你的这个if

03:23.140 --> 03:25.140
if与就是有这个大扩号

03:25.140 --> 03:27.140
包括这个for

03:27.140 --> 03:29.140
for是不是也是有大扩号

03:29.140 --> 03:31.140
对不对 它就新增了快作用于

03:31.140 --> 03:33.140
什么意思 我演示一下

03:33.140 --> 03:35.140
比如说这边

03:35.140 --> 03:38.140
比如以前我这边写一个这个大扩号

03:38.140 --> 03:41.140
然后我挖一个i 等于一个e

03:41.140 --> 03:44.140
以前是不存在快作用于的

03:44.140 --> 03:46.140
这个的话在其他语言都是有的

03:46.140 --> 03:47.140
什么声语言啊

03:47.140 --> 03:49.140
java这些都是有的

03:49.140 --> 03:52.140
给我这边console.logi

03:52.140 --> 03:54.140
好 我们来看一下

03:54.140 --> 03:56.140
刷新 你看

03:56.140 --> 03:58.140
是不是能够访问得到

03:58.140 --> 04:00.140
对不对 能够访问得到

04:00.140 --> 04:02.140
然后它那个es6出现之后

04:02.140 --> 04:03.140
然后它这样子

04:03.140 --> 04:05.140
比如我们这边用这个lit

04:05.140 --> 04:07.140
来声明这个变量的话

04:07.140 --> 04:09.140
它这边的话就存在了这个快作用于

04:09.140 --> 04:11.140
比如我们这边重新刷新

04:11.140 --> 04:12.140
你看

04:12.140 --> 04:16.020
然后把这个

04:16.020 --> 04:22.020
可怕这些关了

04:22.020 --> 04:23.020
好 这边刷新

04:23.020 --> 04:24.020
你看这边

04:24.020 --> 04:26.020
是不是i is not a default

04:26.020 --> 04:27.020
对不对

04:27.020 --> 04:28.020
i is not a default

04:28.020 --> 04:29.020
为什么

04:29.020 --> 04:30.020
究其原因就是这里

04:30.020 --> 04:32.020
它有快作用于

04:32.020 --> 04:33.020
你这边这个i

04:33.020 --> 04:36.020
是使用这个lit声明的

04:36.020 --> 04:37.020
lit声明的话

04:37.020 --> 04:39.020
它起作用就指在什么呢

04:39.020 --> 04:43.020
指在这对大扩号里面

04:43.020 --> 04:44.020
对吧

04:44.020 --> 04:47.020
就指在这个大扩号里面

04:47.020 --> 04:50.020
然后这是关于这个作用于

04:50.020 --> 04:51.020
但作用于的话

04:51.020 --> 04:52.020
其实不止这点内容

04:52.020 --> 04:53.020
作用于的话

04:53.020 --> 04:55.020
关于这个作用于更多的内容

04:55.020 --> 04:56.020
我们专门有个章节

04:56.020 --> 04:59.020
叫做作用于和作用于链

04:59.020 --> 05:02.020
你可以去把那一小节看一下

05:02.020 --> 05:04.020
专门有这么一个章节

05:04.020 --> 05:06.020
这个作用于和作用于链

05:06.020 --> 05:08.020
也是特别爱考的一个知识点

05:08.020 --> 05:09.020
好吧

05:10.020 --> 05:11.020
好

05:11.020 --> 05:12.020
然后接下来的话

05:12.020 --> 05:13.020
我们就来看

05:13.020 --> 05:14.020
三种关键字

05:14.020 --> 05:15.020
那首先最早

05:15.020 --> 05:17.020
最早的话也是大家最熟悉的

05:17.020 --> 05:18.020
使用什么呢

05:18.020 --> 05:19.020
使用这个wa

05:19.020 --> 05:21.020
wa关键字

05:21.020 --> 05:22.020
这个关键字的话

05:22.020 --> 05:23.020
首先第一个就是

05:23.020 --> 05:25.020
没有快计作用于的概念

05:25.020 --> 05:26.020
这刚才是不是已经演示了

05:26.020 --> 05:27.020
对吧

05:27.020 --> 05:28.020
这个的话

05:28.020 --> 05:30.020
就是我们刚才演示的这个例子

05:30.020 --> 05:31.020
这个就不说了

05:31.020 --> 05:32.020
好

05:32.020 --> 05:33.020
然后第二个

05:33.020 --> 05:36.020
有全局作用于和寒树作用于的概念

05:36.020 --> 05:37.020
比如你看我这边

05:37.020 --> 05:39.020
在全局声明了一个10

05:39.020 --> 05:41.020
那这样我这边是不是有个寒树

05:41.020 --> 05:42.020
寒树

05:42.020 --> 05:44.020
我在寒树里面声明了一个20

05:44.020 --> 05:47.020
那既然我访问这个a

05:47.020 --> 05:50.020
a的话在我这个寒树里面有没有

05:50.020 --> 05:52.020
在这个寒树里面有没有

05:52.020 --> 05:53.020
什么没有声明a

05:53.020 --> 05:54.020
没有声明a的话

05:54.020 --> 05:55.020
它就会顺到什么呢

05:55.020 --> 05:57.020
顺着它的作用于链

05:57.020 --> 05:58.020
一程一程去找

05:58.020 --> 06:01.020
那现在把这个全局作用于的a

06:01.020 --> 06:02.020
找到

06:02.020 --> 06:03.020
所以最终

06:03.020 --> 06:04.020
数出10

06:04.020 --> 06:05.020
然后这个b

06:05.020 --> 06:07.020
b的话在我的这个作用于里面

06:07.020 --> 06:08.020
是不是有

06:08.020 --> 06:09.020
对不对

06:09.020 --> 06:10.020
所以打印说20

06:10.020 --> 06:12.020
然后接下来

06:12.020 --> 06:15.020
整个这个寒树执行完毕之后

06:15.020 --> 06:16.020
我这边的话

06:16.020 --> 06:18.020
在全局作用于里面

06:18.020 --> 06:19.020
康设点诺个b

06:19.020 --> 06:20.020
那这个时候

06:20.020 --> 06:22.020
它能不能找到这个b

06:22.020 --> 06:23.020
能不能

06:23.020 --> 06:24.020
是不能

06:24.020 --> 06:26.020
当我们整个这个寒树

06:26.020 --> 06:28.020
执行完毕之后

06:28.020 --> 06:29.020
它里面的所有东西

06:29.020 --> 06:31.020
是不是就会被销毁掉

06:31.020 --> 06:32.020
那销毁掉之后

06:32.020 --> 06:33.020
然后接下来的话

06:33.020 --> 06:34.020
你这边再去打印这个b

06:34.020 --> 06:35.020
它是找不到的

06:35.020 --> 06:36.020
我们这边

06:36.020 --> 06:39.660
我们可以来试一下

06:39.660 --> 06:41.660
拿到这边来

06:41.660 --> 06:46.800
各式画一下

06:46.800 --> 06:47.800
好我们这边刷新

06:47.800 --> 06:48.800
看了没有

06:48.800 --> 06:50.800
是b is not defend

06:50.800 --> 06:53.800
和我那边的结果是一样的

06:53.800 --> 06:54.800
对吧

06:54.800 --> 06:55.800
好

06:55.800 --> 06:56.800
然后第三个

06:56.800 --> 06:57.800
不初始画的话

06:57.800 --> 07:00.800
直它就默认为这个on defy

07:00.800 --> 07:02.800
不用这样挖了一个a

07:02.800 --> 07:03.800
那这样你这个时候

07:03.800 --> 07:04.800
你没有给它初始画直

07:04.800 --> 07:06.800
你直接去使用

07:06.800 --> 07:07.800
那么这个时候

07:07.800 --> 07:09.800
它的直就为什么呢

07:09.800 --> 07:11.800
这个时候它的直就为on defy

07:11.800 --> 07:12.800
就为on defy

07:12.800 --> 07:15.800
这个知识点大家应该都是知道的

07:15.800 --> 07:16.800
好

07:16.800 --> 07:17.800
然后下一个

07:17.800 --> 07:20.800
下一个的话是存在这个变量提升

07:20.800 --> 07:22.800
什么叫做变量提升

07:22.800 --> 07:23.800
所谓变量提升

07:23.800 --> 07:24.800
它指的是什么

07:24.800 --> 07:26.800
是把声明提升

07:26.800 --> 07:27.800
对不对

07:27.800 --> 07:28.800
比如举个例子

07:28.800 --> 07:29.800
我们这边来举个例子

07:29.800 --> 07:32.800
比如说我这边

07:32.800 --> 07:34.800
log

07:34.800 --> 07:35.800
log这个a

07:35.800 --> 07:38.800
我现在直接打印输出这个a

07:38.800 --> 07:39.800
那么你这个时候

07:39.800 --> 07:40.800
肯定是会爆错的

07:40.800 --> 07:41.800
我这边刷新

07:41.800 --> 07:43.800
A is not different的

07:43.800 --> 07:44.800
好那我这边的话

07:44.800 --> 07:45.800
我把这个代码稍微改一下

07:45.800 --> 07:46.800
我这边的话

07:46.800 --> 07:47.800
然后把这个w

07:47.800 --> 07:48.800
这个a

07:48.800 --> 07:50.800
写到下面

07:50.800 --> 07:52.800
我把这个写到下面

07:52.800 --> 07:53.800
那这个时候的话

07:53.800 --> 07:55.800
它还会不会爆错呢

07:55.800 --> 07:56.800
这个时候它就不会爆错了

07:56.800 --> 07:57.800
它不会爆错

07:57.800 --> 07:58.800
然后接下来

07:58.800 --> 08:00.800
它这里它输出多少呢

08:00.800 --> 08:01.800
有同学可能会觉得

08:01.800 --> 08:02.800
它就输出10倍

08:02.800 --> 08:03.800
因为你这边

08:03.800 --> 08:04.800
给的10

08:04.800 --> 08:05.800
但其实不一样

08:05.800 --> 08:06.800
就不是

08:06.800 --> 08:09.800
它这边会输出一个on defy

08:09.800 --> 08:10.800
看到没有

08:10.800 --> 08:11.800
为什么

08:11.800 --> 08:12.800
因为它这边的话

08:12.800 --> 08:16.940
存在一个变量提升的现象

08:16.940 --> 08:19.940
这里存在一个

08:19.940 --> 08:22.940
变量提升的现象

08:22.940 --> 08:24.940
什么叫做变量提升

08:24.940 --> 08:28.940
所谓变量提升

08:28.940 --> 08:32.940
就是将这个变量的

08:32.940 --> 08:34.940
声明部分

08:34.940 --> 08:38.940
声明部分

08:38.940 --> 08:41.940
提升到当前

08:41.940 --> 08:45.940
注意是当前作用语的最顶端

08:45.940 --> 08:46.940
看到没有

08:46.940 --> 08:47.940
所以说

08:47.940 --> 08:49.940
上面的代码

08:49.940 --> 08:51.940
上面的代码

08:51.940 --> 08:54.940
就等价于

08:54.940 --> 08:57.770
等价于

08:57.770 --> 08:58.770
等价于什么呢

08:58.770 --> 09:00.770
等价于你这样子在写

09:00.770 --> 09:02.770
挖了一个a

09:02.770 --> 09:05.770
首先你挖了一个a

09:05.770 --> 09:06.770
就是声明嘛

09:06.770 --> 09:07.770
对吧

09:07.770 --> 09:08.770
把声明提升到

09:08.770 --> 09:09.770
当前作用语的最上面

09:09.770 --> 09:10.770
然后接下来

09:10.770 --> 09:11.770
你这边的话

09:11.770 --> 09:12.770
console.log

09:12.770 --> 09:13.770
这个a

09:13.770 --> 09:14.770
然后接下来最后才是

09:14.770 --> 09:16.770
给a这个复制

09:16.770 --> 09:17.770
看到没有

09:17.770 --> 09:18.770
就上面这两行代码

09:18.770 --> 09:20.770
其实等价于这三行代码

09:20.770 --> 09:22.770
它会把声明部分

09:22.770 --> 09:23.770
这个是不是

09:23.770 --> 09:25.770
称之为变量的声明

09:25.770 --> 09:26.770
对吧

09:26.770 --> 09:27.770
把声明部分

09:27.770 --> 09:31.770
提升到当前作用语的最顶端

09:31.770 --> 09:32.770
看到没有

09:32.770 --> 09:35.770
它这边就是这个样子的

09:35.770 --> 09:38.720
console.log

09:38.720 --> 09:39.720
OK

09:39.720 --> 09:42.030
好

09:42.030 --> 09:43.030
然后这边

09:43.030 --> 09:44.030
存在这个变量声明

09:44.030 --> 09:45.030
包括这里

09:45.030 --> 09:46.030
包括这里

09:46.030 --> 09:48.030
这里是不是有一个这个函数

09:48.030 --> 09:49.030
有一个函数

09:49.030 --> 09:50.030
那接下来你这边的话

09:50.030 --> 09:52.030
直接console

09:52.030 --> 09:55.030
这边的话

09:55.030 --> 09:56.030
它会把这个

09:56.030 --> 09:58.030
是不是提升到上面

09:58.030 --> 09:59.030
对不对

09:59.030 --> 10:00.030
会把这个声明

10:00.030 --> 10:01.030
提升到上面

10:01.030 --> 10:02.030
所以这边打印这个a

10:02.030 --> 10:04.030
也是unleap

10:04.030 --> 10:05.030
这里的a

10:05.030 --> 10:06.030
和这里的a

10:06.030 --> 10:07.030
不会冲突

10:07.030 --> 10:08.030
因为这边是不是

10:08.030 --> 10:10.030
又是另外一个函数作用语了

10:10.030 --> 10:11.030
对不对

10:11.030 --> 10:13.030
好

10:13.030 --> 10:14.030
下一个

10:14.030 --> 10:15.030
全局作用语

10:15.030 --> 10:17.030
用a声明的变量

10:17.030 --> 10:20.030
会挂载到这个window对象

10:20.030 --> 10:22.030
这个下面

10:22.030 --> 10:23.030
这个的话也是

10:23.030 --> 10:25.030
a的一个特点

10:25.030 --> 10:26.030
比如说我们这边

10:26.030 --> 10:27.030
我们来举个例子

10:27.030 --> 10:28.030
比如说这边

10:28.030 --> 10:30.030
a一个i

10:30.030 --> 10:32.030
等于个10

10:32.030 --> 10:33.030
那你这边的话

10:33.030 --> 10:34.030
你可以直接什么呢

10:34.030 --> 10:37.030
可以直接打印window.i

10:37.030 --> 10:38.030
那你会发

10:38.030 --> 10:39.030
就是会发现

10:39.030 --> 10:40.030
这边打印出来

10:40.030 --> 10:41.030
就是多少呢

10:41.030 --> 10:42.030
这边说心

10:42.030 --> 10:43.030
这就是10

10:43.030 --> 10:44.030
对不对

10:44.030 --> 10:45.030
那说明什么呀

10:45.030 --> 10:46.030
说明我们这边

10:46.030 --> 10:47.030
用a声明的变量

10:47.030 --> 10:48.030
它是不是成为了

10:48.030 --> 10:51.030
这个window对象的一个属性啊

10:51.030 --> 10:52.030
对不对

10:52.030 --> 10:53.030
但是net就不会有

10:53.030 --> 10:54.030
你注意

10:54.030 --> 10:55.030
比如说我这边

10:55.030 --> 10:56.030
我再来一个net

10:56.030 --> 10:57.030
一个j

10:57.030 --> 10:59.030
等于一个20

10:59.030 --> 11:00.030
好

11:00.030 --> 11:01.030
然后接下来

11:01.030 --> 11:03.030
这边让我访问这个j

11:03.030 --> 11:04.030
好

11:04.030 --> 11:05.030
然后这样我们这边说心

11:05.030 --> 11:06.030
好

11:06.030 --> 11:07.030
你看这边

11:07.030 --> 11:08.030
什么访问就是unleap

11:08.030 --> 11:09.030
对不对

11:09.030 --> 11:10.030
为什么

11:10.030 --> 11:11.030
因为你这边

11:11.030 --> 11:12.030
访问了

11:13.030 --> 11:14.030
你访问了他

11:14.030 --> 11:15.030
没有的属性

11:15.030 --> 11:16.030
他就会给你报

11:16.030 --> 11:17.030
一个unleap

11:19.030 --> 11:20.030
好

11:20.030 --> 11:21.030
这是这个

11:21.030 --> 11:22.030
好

11:22.030 --> 11:23.030
下一个

11:23.030 --> 11:25.030
就是在同一作用语中

11:25.030 --> 11:26.030
允许什么呢

11:26.030 --> 11:28.030
允许重复声明

11:28.030 --> 11:29.030
比我们来看这里

11:29.030 --> 11:30.030
比较挖了一个a

11:30.030 --> 11:31.030
等于10

11:31.030 --> 11:32.030
那这样我这边的话

11:32.030 --> 11:33.030
又挖了一个a

11:33.030 --> 11:34.030
等于20

11:34.030 --> 11:35.030
那这是不是

11:35.030 --> 11:36.030
就是典型的

11:36.030 --> 11:37.030
重复声明

11:37.030 --> 11:38.030
对不对

11:38.030 --> 11:39.030
你看我这边

11:39.030 --> 11:40.030
声明了两个a

11:40.030 --> 11:41.030
那他会不会报错呢

11:41.030 --> 11:42.030
他不会报错

11:42.030 --> 11:44.030
他就是你后面的声明

11:44.030 --> 11:46.030
会把前面的声明

11:46.030 --> 11:47.030
把它覆盖掉

11:47.030 --> 11:48.030
所以最终的话

11:48.030 --> 11:50.030
他打印出来的是20

11:50.030 --> 11:52.030
打印出来是20

11:52.030 --> 11:54.030
然后这边也是一样的

11:54.030 --> 11:55.030
这边我说在

11:55.030 --> 11:57.030
韩束作用语里面

11:57.030 --> 11:59.030
声明了两个b

11:59.030 --> 12:00.030
声明了两个b之后

12:00.030 --> 12:01.030
然后后面的

12:01.030 --> 12:02.030
就会把前面的

12:02.030 --> 12:03.030
就给覆盖掉

12:03.030 --> 12:05.030
但late就不行

12:05.030 --> 12:06.030
比我们这边

12:06.030 --> 12:07.030
我们来试一下

12:07.030 --> 12:08.030
这个

12:08.030 --> 12:12.110
这个是重复声明

12:12.110 --> 12:18.240
重复

12:18.240 --> 12:20.240
重复声明

12:20.240 --> 12:23.240
这个就是a

12:23.240 --> 12:26.240
声明的变量

12:26.240 --> 12:29.240
会成为window

12:29.240 --> 12:33.240
对象的一个属性

12:33.240 --> 12:34.240
对吧

12:34.240 --> 12:35.240
好那这样我们这边

12:35.240 --> 12:36.240
我们来看重复声明

12:36.240 --> 12:37.240
比如a一个i

12:37.240 --> 12:39.240
等于一个10

12:39.240 --> 12:40.240
复制一份

12:40.240 --> 12:41.240
然后加这个

12:41.240 --> 12:42.240
等于一个20

12:42.240 --> 12:43.240
好

12:43.240 --> 12:44.240
然后这样我们这边

12:44.240 --> 12:45.240
来打印一下

12:45.240 --> 12:46.240
好

12:46.240 --> 12:47.240
这边

12:47.240 --> 12:48.240
是没问题

12:48.240 --> 12:49.240
对不对

12:49.240 --> 12:50.240
完全没问题

12:50.240 --> 12:52.240
但你如果用这个late就不行

12:52.240 --> 12:54.240
比如我们这边

12:54.240 --> 12:55.240
late

12:55.240 --> 12:56.240
一个j

12:56.240 --> 12:58.240
等于一个10

12:58.240 --> 12:59.240
然后再来

12:59.240 --> 13:00.240
j等于20

13:00.240 --> 13:01.240
我都不需要打印的

13:01.240 --> 13:02.240
我现在就这样子写

13:02.240 --> 13:03.240
声明两个j

13:03.240 --> 13:05.240
他这边就会爆出

13:05.240 --> 13:06.240
对不对

13:06.240 --> 13:07.240
这个

13:07.240 --> 13:08.240
这个标志符j

13:08.240 --> 13:10.240
has already been declared

13:10.240 --> 13:12.240
是不是已经声明了

13:12.240 --> 13:13.240
对不对

13:13.240 --> 13:14.240
已经声明了

13:14.240 --> 13:15.240
啊

13:16.240 --> 13:18.240
这是这个关于a

13:18.240 --> 13:20.240
a的特点基本上就这一些

13:20.240 --> 13:21.240
就给大家总结完了

13:21.240 --> 13:22.240
好

13:22.240 --> 13:24.240
然后这样我们这边

13:24.240 --> 13:26.240
我们来看一下这个late

13:26.240 --> 13:28.240
late关键是我们说的

13:28.240 --> 13:30.240
late的话是es6

13:30.240 --> 13:31.240
新推出的

13:31.240 --> 13:32.240
那既然那是新推出的

13:32.240 --> 13:34.240
它肯定是要解决这个a

13:34.240 --> 13:36.240
它所存在的一些问题

13:36.240 --> 13:37.240
对吧

13:37.240 --> 13:38.240
那首先第1个

13:38.240 --> 13:40.240
就是通过late

13:40.240 --> 13:41.240
包括Const

13:41.240 --> 13:42.240
也是

13:42.240 --> 13:43.240
它就是什么呢

13:43.240 --> 13:46.240
它就有快捷作用语的概念

13:46.240 --> 13:48.240
就你这边有这个大过号之后

13:48.240 --> 13:50.240
它这边就会形成一个快捷作用语

13:50.240 --> 13:53.240
那你在这个快捷作用语以外

13:53.240 --> 13:54.240
你访问这个

13:54.240 --> 13:56.240
比如这边声明的这个辩量a

13:56.240 --> 13:57.240
它是访问不到的

13:57.240 --> 13:58.240
它这边会爆什么呢

13:58.240 --> 14:01.240
会爆这个a is not defend

14:01.240 --> 14:02.240
看到没有

14:02.240 --> 14:04.240
这个我们刚才是不是也视力了

14:04.240 --> 14:05.240
对不对

14:06.240 --> 14:07.240
好 第二个

14:07.240 --> 14:10.240
第二个就是不存在这个辩量提升

14:10.240 --> 14:11.240
比如这里

14:12.240 --> 14:13.240
不要照比

14:13.240 --> 14:17.000
好 我们来看一下

14:17.000 --> 14:18.000
late

14:19.000 --> 14:21.000
声明的辩量

14:21.000 --> 14:25.000
不存在这个辩量提升

14:25.000 --> 14:27.000
其实严格来讲

14:27.000 --> 14:28.000
这边完整的是叫做什么

14:28.000 --> 14:30.000
辩量声明提升

14:30.000 --> 14:31.000
对不对

14:31.000 --> 14:33.000
它提升的是这个辩量的声明

14:33.000 --> 14:35.000
好 我们这边我们来试一下

14:35.000 --> 14:36.000
由这边来log

14:36.000 --> 14:38.000
log一个这个接

14:38.000 --> 14:39.000
好 接下来我再干完了

14:39.000 --> 14:40.000
我再干

14:40.000 --> 14:43.000
这边在接等于一个10

14:44.000 --> 14:46.000
好 那我们这边我们来看一下

14:46.000 --> 14:47.000
刷新

14:48.000 --> 14:51.000
这边它是不是无法访问接

14:51.000 --> 14:53.000
在什么呢 在它初始化之前

14:53.000 --> 14:54.000
看到没有

14:54.000 --> 14:55.000
你注意哦

14:55.000 --> 14:56.000
它这边报的是一个引用错误

14:56.000 --> 14:57.000
这个错误

14:57.000 --> 14:59.000
reference error

14:59.000 --> 15:02.000
不能这个就是访问这个接

15:02.000 --> 15:04.000
在它这个初始化之前

15:04.000 --> 15:05.000
看到没有

15:05.000 --> 15:06.000
报的是这个错误

15:06.000 --> 15:08.000
它不是说这个

15:08.000 --> 15:10.000
这个接没有定义

15:10.000 --> 15:11.000
你注意

15:11.000 --> 15:12.000
注意哦 这个细小的区别

15:12.000 --> 15:14.000
之前说报的是这个接

15:14.000 --> 15:15.000
is not defined

15:15.000 --> 15:16.000
是没有定义

15:16.000 --> 15:17.000
对不对

15:17.000 --> 15:18.000
但是这边的话

15:18.000 --> 15:19.000
它不是说接没定义

15:19.000 --> 15:20.000
定义还是定义了

15:20.000 --> 15:21.000
但是呢

15:21.000 --> 15:24.000
就是你还没有进行初始化

15:24.000 --> 15:25.000
你没有进行初始化

15:25.000 --> 15:28.000
之前你是不能够访问的

15:28.000 --> 15:30.000
这点一定要注意

15:30.000 --> 15:31.000
一定要注意

15:31.000 --> 15:32.000
好 为什么呢

15:32.000 --> 15:34.000
其实就引出我们下一个知识点

15:34.000 --> 15:37.000
叫做暂时性死去

15:38.000 --> 15:39.000
我们来看一下

15:39.000 --> 15:40.000
什么叫做暂时性死去

15:40.000 --> 15:42.000
这边举了一些例子

15:42.000 --> 15:43.000
然后这边的话

15:43.000 --> 15:44.000
是先打印这个A

15:44.000 --> 15:45.000
然后架这边

15:45.000 --> 15:47.000
才声明辨量这个A

15:47.000 --> 15:49.000
这报的就是刚才那个错误

15:49.000 --> 15:50.000
对吧

15:50.000 --> 15:51.000
包括这边

15:51.000 --> 15:53.000
这边都是一样的例子

15:53.000 --> 15:54.000
为什么呢

15:54.000 --> 15:55.000
之所以会这样

15:55.000 --> 15:56.000
就是存在一个

15:56.000 --> 16:00.000
叫做暂时性死去

16:00.000 --> 16:02.000
什么叫做暂时性死去

16:02.000 --> 16:03.000
我们来看一下

16:03.000 --> 16:04.000
这个es6中

16:04.000 --> 16:07.000
对这个暂时性死去的这个解释

16:08.000 --> 16:10.000
the variables are created

16:10.000 --> 16:12.000
when they are containing

16:12.000 --> 16:16.000
like through environment

16:16.000 --> 16:18.000
is instated

16:18.000 --> 16:21.000
but may not be assessed

16:21.000 --> 16:22.000
就是它这边的话

16:22.000 --> 16:24.000
你看在它的持法环境里面

16:24.000 --> 16:25.000
它已经被建立了

16:25.000 --> 16:27.000
但是它还不能被什么

16:27.000 --> 16:28.000
是不能被访问

16:28.000 --> 16:29.000
对不对

16:29.000 --> 16:30.000
may not be assessed

16:30.000 --> 16:32.000
它这边

16:32.000 --> 16:33.000
我们这边

16:33.000 --> 16:34.000
直接看简单理解吗

16:34.000 --> 16:36.000
简单理解就是什么

16:36.000 --> 16:38.000
简单理解就是

16:38.000 --> 16:40.000
你在这个代码块内

16:40.000 --> 16:43.000
你在使用

16:43.000 --> 16:45.000
使用这个

16:45.000 --> 16:46.000
let const meaning

16:46.000 --> 16:48.000
声明辨量之前

16:48.000 --> 16:50.000
该辨量都是不可使用的

16:50.000 --> 16:53.000
其实应该是说是负值之前

16:53.000 --> 16:54.000
负值之前

16:54.000 --> 16:55.000
就是我这边的话

16:55.000 --> 16:57.000
是没有进行初始化

16:57.000 --> 16:58.000
对不对

16:58.000 --> 16:59.000
就是你在对这个值

16:59.000 --> 17:02.000
进行初始化之前

17:02.000 --> 17:04.000
你都是不能使用的

17:04.000 --> 17:06.700
不对

17:06.700 --> 17:07.700
不对

17:07.700 --> 17:08.700
就是声明之前

17:08.700 --> 17:09.700
不是初始化之前

17:09.700 --> 17:10.700
是声明之前

17:10.700 --> 17:11.700
因为你这边的话

17:11.700 --> 17:13.700
比如说我这样子

17:13.700 --> 17:15.700
比如说我这边

17:15.700 --> 17:17.700
我let一个接

17:17.700 --> 17:18.700
然后接下来

17:18.700 --> 17:19.700
后面才进行初始化

17:19.700 --> 17:20.700
这样子是可以的

17:20.700 --> 17:21.700
对不对

17:21.700 --> 17:22.700
我这边的话

17:22.700 --> 17:23.700
没有进行初始化

17:23.700 --> 17:24.700
但我这边使用

17:24.700 --> 17:25.700
可不可以呢

17:25.700 --> 17:26.700
可以的

17:26.700 --> 17:27.700
它打印出什么呢

17:27.700 --> 17:28.700
它打印出

17:28.700 --> 17:29.700
andify

17:29.700 --> 17:30.700
对不对

17:30.700 --> 17:31.700
那就是声明之前

17:31.700 --> 17:32.700
对的

17:32.700 --> 17:33.700
就是你这边的话

17:33.700 --> 17:34.700
在使用这个命令

17:34.700 --> 17:36.700
该变量都是不可用的

17:36.700 --> 17:37.700
在这个语法上

17:37.700 --> 17:38.700
称之为

17:38.700 --> 17:41.700
暂时性死去

17:41.700 --> 17:43.700
其实这个也很好理解

17:43.700 --> 17:44.700
对不对

17:44.700 --> 17:45.700
你声段还没声明变的

17:45.700 --> 17:47.700
你怎么能去使用它呢

17:47.700 --> 17:48.700
虽然它最后

17:48.700 --> 17:50.700
它最终它的这个net

17:50.700 --> 17:51.700
它最后的话

17:51.700 --> 17:53.700
其实也是通过这个wa

17:53.700 --> 17:54.700
来创建

17:54.700 --> 17:55.700
它其实也是一个语法堂

17:55.700 --> 17:57.700
最终还是通过这个wa

17:57.700 --> 17:58.700
这个不可避免

17:58.700 --> 17:59.700
对不对

17:59.700 --> 18:00.700
就是你的这个

18:00.700 --> 18:02.700
就是你这样子

18:02.700 --> 18:03.700
你比如说

18:04.700 --> 18:05.700
这边

18:06.700 --> 18:07.700
这边

18:07.700 --> 18:08.700
你这个样子

18:08.700 --> 18:09.700
这个样子

18:09.700 --> 18:10.700
其实最终这个net

18:10.700 --> 18:11.700
它其实还是通过什么呢

18:11.700 --> 18:13.700
还是通过这个wa来创建的

18:13.700 --> 18:14.700
但创建的话

18:14.700 --> 18:15.700
然后以前的话

18:15.700 --> 18:16.700
是不是

18:16.700 --> 18:17.700
你可以直接使用

18:17.700 --> 18:18.700
它现在就强行

18:18.700 --> 18:19.700
给你规定不行

18:19.700 --> 18:20.700
对不对

18:20.700 --> 18:22.700
你在声明之前

18:22.700 --> 18:23.700
你就是不能用

18:23.700 --> 18:24.700
就这么简单

18:24.700 --> 18:25.700
但是你这个变量

18:25.700 --> 18:26.700
存不存在

18:26.700 --> 18:27.700
其实已经存在了

18:27.700 --> 18:29.700
所以说它报的错都不是

18:29.700 --> 18:30.700
你是not defend的

18:30.700 --> 18:31.700
而是什么呢

18:31.700 --> 18:33.700
你无法访问

18:33.700 --> 18:34.700
对不对

18:34.700 --> 18:35.700
刚才反复强调的

18:35.700 --> 18:36.700
报的错是这个

18:39.700 --> 18:40.700
你无法访问

18:40.700 --> 18:41.700
而不是像以前

18:41.700 --> 18:42.700
以前的话

18:42.700 --> 18:43.700
没有的话是直接报的是

18:43.700 --> 18:45.700
你是not defend的

18:45.700 --> 18:46.700
对吧

18:47.700 --> 18:48.700
好

18:48.700 --> 18:49.700
接下来的话第四个

18:49.700 --> 18:50.700
第四个就是

18:50.700 --> 18:52.700
不允许重复声明

18:52.700 --> 18:53.700
比如你无论是

18:53.700 --> 18:54.700
使用net也好

18:54.700 --> 18:55.700
还是wa也好

18:55.700 --> 18:56.700
你这边

18:56.700 --> 18:57.700
只要比如说

18:57.700 --> 18:58.700
你wa声明了一个a

18:58.700 --> 18:59.700
但是你这边net也有a

18:59.700 --> 19:01.700
它会认为是重复声明

19:01.700 --> 19:02.700
包括这边也是

19:02.700 --> 19:03.700
这边也是

19:03.700 --> 19:04.700
看到没有

19:04.700 --> 19:06.700
然后两个net就更不用说了

19:06.700 --> 19:07.700
反正只要就是

19:07.700 --> 19:09.700
你用net声明的话

19:09.700 --> 19:10.700
它不允许你和其他变量

19:10.700 --> 19:12.700
这个是重复的

19:12.700 --> 19:13.700
就这么简单

19:13.700 --> 19:14.700
但是如果两个是wa的话

19:14.700 --> 19:15.700
是不是可以

19:15.700 --> 19:16.700
对不对

19:16.700 --> 19:18.700
这是关于这个net

19:18.700 --> 19:20.700
它的特点

19:20.700 --> 19:21.700
好

19:21.700 --> 19:24.700
然后接下来的话这个const

19:24.700 --> 19:25.700
const的话

19:25.700 --> 19:27.700
基本上大致和net

19:27.700 --> 19:28.700
很相似

19:28.700 --> 19:29.700
它说这个net的话

19:29.700 --> 19:31.700
然后有几个区别

19:31.700 --> 19:32.700
首先第一个

19:32.700 --> 19:33.700
就是const的话

19:33.700 --> 19:36.700
它是必须立即出实化

19:36.700 --> 19:38.700
比如你不能这样子写

19:38.700 --> 19:39.700
看到没有

19:39.700 --> 19:42.700
你const一个a这个变量

19:42.700 --> 19:44.700
然后将我不给它出实化

19:44.700 --> 19:45.700
不给它出实之

19:45.700 --> 19:46.700
这个是不行的

19:46.700 --> 19:48.700
const它要求你

19:48.700 --> 19:49.700
你声明的时候

19:49.700 --> 19:51.700
就必须出实化

19:51.700 --> 19:53.700
不然它就会报这个错

19:53.700 --> 19:54.700
好 第二个就是什么呢

19:54.700 --> 19:57.700
const它声明的是常量

19:57.700 --> 19:58.700
我们就是常量

19:58.700 --> 20:00.700
常量就是不可改变的

20:00.700 --> 20:02.700
比如你看这边

20:02.700 --> 20:04.700
const一个这个a等于10

20:04.700 --> 20:05.700
然后接下来

20:05.700 --> 20:08.700
那这个a它就永远等于10

20:08.700 --> 20:10.700
你不能再对它进行改变了

20:10.700 --> 20:11.700
比如我这边

20:11.700 --> 20:12.700
再对它进行负责

20:12.700 --> 20:14.700
它这边就会报错

20:14.700 --> 20:15.700
看到没有 type error

20:15.700 --> 20:17.700
它是一个类型错误

20:17.700 --> 20:20.700
assignment to constant variable

20:20.700 --> 20:24.700
就不能给这个常量进行负责

20:24.700 --> 20:25.700
看到没有

20:25.700 --> 20:26.700
这是const

20:26.700 --> 20:27.700
然后const的特点

20:27.700 --> 20:29.700
就和let是一样的

20:29.700 --> 20:31.700
包括它这个是

20:31.700 --> 20:32.700
不允许重复声明

20:32.700 --> 20:34.700
然后有这个快捷作用域

20:34.700 --> 20:36.700
这些都是相同的

20:36.700 --> 20:39.010
好

20:39.010 --> 20:41.010
然后最后总结了下特点

20:41.010 --> 20:42.010
这边是这个

20:42.010 --> 20:44.010
wa关键值的特点

20:44.010 --> 20:46.010
没有快捷作用域

20:46.010 --> 20:47.010
然后有全局作用域

20:47.010 --> 20:48.010
函数作用域

20:48.010 --> 20:49.010
不出实化

20:49.010 --> 20:51.010
默认之为andify

20:51.010 --> 20:52.010
其实let

20:52.010 --> 20:53.010
let不出实化

20:53.010 --> 20:54.010
是不是也是andify

20:54.010 --> 20:55.010
对不对

20:55.010 --> 20:57.010
const是必须要出实化

20:57.010 --> 20:59.010
然后存在

20:59.010 --> 21:00.010
变量提升

21:00.010 --> 21:02.010
然后全局作用域

21:02.010 --> 21:04.010
这个wa的声明

21:04.010 --> 21:06.010
会挂在window对象上面

21:06.010 --> 21:08.010
然后允许重复声明

21:08.010 --> 21:11.010
然后let基本上就和它

21:11.010 --> 21:12.010
就是相反的

21:12.010 --> 21:13.010
对不对

21:13.010 --> 21:14.010
然后你回答的时候

21:14.010 --> 21:15.010
你要把这个回答上

21:15.010 --> 21:17.010
暂时性死去

21:17.010 --> 21:19.010
什么叫暂时性死去

21:19.010 --> 21:21.010
就是你在声明变量之前

21:21.010 --> 21:23.010
不允许用这个变量

21:23.010 --> 21:24.010
它会把它锁死

21:24.010 --> 21:26.010
称之为一个暂时性死去

21:26.010 --> 21:30.010
然后其他的就和

21:30.010 --> 21:31.010
上面的是反的

21:31.010 --> 21:33.010
比如上面允许重复声明

21:33.010 --> 21:35.010
它这边就不允许

21:35.010 --> 21:41.900
然后这条

21:41.900 --> 21:43.900
这条没有

21:43.900 --> 21:44.900
ok

21:44.900 --> 21:45.900
然后接下来的话

21:45.900 --> 21:46.900
这边const

21:46.900 --> 21:47.900
const的话

21:47.900 --> 21:48.900
然后和let

21:48.900 --> 21:49.900
特性基本是一样

21:49.900 --> 21:50.900
然后就两个差别

21:50.900 --> 21:53.900
一个是你必须立即出实化

21:53.900 --> 21:54.900
另外一个就是

21:54.900 --> 21:56.900
常量的值是不变的

21:58.900 --> 21:59.900
下面的话

21:59.900 --> 22:01.900
关于这个争停的这个解答

22:01.900 --> 22:03.900
其实就是上面的这个总结了

22:03.900 --> 22:04.900
对不对

22:04.900 --> 22:05.900
你把这个上面的总结

22:05.900 --> 22:06.900
你把它答出来

22:06.900 --> 22:09.900
然后什么是快捷作用语

22:09.900 --> 22:10.900
快捷作用语

22:10.900 --> 22:12.900
是不是就是使用这个大括号

22:12.900 --> 22:14.900
包括这个义父语句和

22:14.900 --> 22:15.900
护循环

22:15.900 --> 22:16.900
这个大括号

22:16.900 --> 22:18.900
是不是也是属于快捷作用语

22:18.900 --> 22:21.900
其他的话就没什么了

22:21.900 --> 22:23.900
这一刻就先到这里

22:23.900 --> 22:24.900
再见

