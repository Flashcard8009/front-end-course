WEBVTT

00:00.750 --> 00:03.050
大家好 我是谢老师

00:03.310 --> 00:05.350
这节课的话 我们来看一下这个指示点

00:05.870 --> 00:06.390
Evo

00:06.890 --> 00:09.710
Evo这个的话 大家平时应该是用的比较少

00:09.970 --> 00:12.010
或者压根说就是压根就没用过

00:12.270 --> 00:14.070
应该平时就从来没用过

00:14.310 --> 00:16.870
但是面试的时候他又喜欢问

00:17.390 --> 00:20.210
比如说我这边列举了一道面试的整体

00:20.710 --> 00:22.770
他问你这个javascript中

00:23.030 --> 00:24.310
Evo方法是啥

00:24.810 --> 00:27.370
然后一般的话是在什么场景下使用

00:27.890 --> 00:30.450
所以我们把Evo单独拿出来

00:30.950 --> 00:34.790
我们来看一看这个关于这个Evo的一些相关知识

00:35.310 --> 00:37.870
好 那我这边的话总结了这么几个

00:38.130 --> 00:41.710
首先第一个 就是关于Evo的一个基本用法

00:41.970 --> 00:44.010
这个的话大家作为一个了解

00:44.270 --> 00:47.350
大致知道这个 至少知道这个东西它是干什么用的

00:47.850 --> 00:49.650
第二个就是它的作用率

00:49.910 --> 00:53.750
最后一个就是你看这边 永远不要使用Evo

00:54.250 --> 00:55.790
所以你为什么你看到

00:56.050 --> 00:57.830
好像这个知识点你第一次看到

00:58.290 --> 01:01.370
可能对于有的同学来讲 可能就确确实实

01:01.630 --> 01:02.650
之前从来没用过

01:03.670 --> 01:07.250
对不对 第一次看到 才知道有这么一个东西

01:07.510 --> 01:08.790
为什么呢 因为现在的话

01:09.050 --> 01:11.350
建议你不要使用Evo

01:13.150 --> 01:14.930
好 那我们这边让我们一个一个来看

01:15.190 --> 01:17.230
首先的话是这个基本用法

01:19.490 --> 01:20.050
然后首先

01:20.570 --> 01:22.610
Evo的话它是一个函数

01:22.870 --> 01:26.970
它接收什么呢 接收一个制服串作为函数

01:27.830 --> 01:32.270
看到没有 这个制服串的话你可以是一个javascript的表达社

01:32.530 --> 01:35.070
或者是语句 以及一系列语句

01:35.310 --> 01:37.870
就一系列的这个javascript的语句 都可以

01:38.270 --> 01:39.690
然后接下来它就可以干嘛呢

01:39.950 --> 01:42.390
它就可以把你传入的这个制服串

01:42.630 --> 01:43.910
当作这个

01:44.170 --> 01:45.690
就是JS代码

01:45.950 --> 01:47.310
来进行一个解释

01:47.750 --> 01:49.290
比如说我们这边我们举个例子

01:50.050 --> 01:51.590
然后这边打开我的vscode

01:52.110 --> 01:53.390
我们这边的话 我们来看一下

01:54.670 --> 01:55.430
我这边的话

01:55.690 --> 01:56.190
Evo

01:56.990 --> 01:58.450
看到没有 它是一个函数

01:58.710 --> 02:00.490
好 然后接下来的话 它接收一个什么呢

02:00.750 --> 02:01.770
接收一个制服串

02:02.290 --> 02:04.070
所以你可以给它传一个制服串进去

02:04.330 --> 02:06.710
那这个制服串的话不是一个简单的制服串

02:07.150 --> 02:10.470
这个制服串本身是什么呢 本身是一段jsa

02:11.510 --> 02:13.550
比如说这边console.log

02:14.310 --> 02:16.110
Hello world

02:16.630 --> 02:18.670
好 然后接下来我们这边我们来执行一下

02:22.800 --> 02:26.640
这边cd到桌面 我这文件在桌面上

02:26.900 --> 02:28.440
然后走

02:29.040 --> 02:32.880
看到没有 你看这边 是不是在我的控制台打印输出了

02:33.140 --> 02:33.640
Hello world

02:34.420 --> 02:38.260
对不对 他是不是把这个制服串当作了JS代码

02:38.760 --> 02:40.040
来进行一个执行

02:40.820 --> 02:44.920
对不对 并且不仅仅是一句代码 你看我们这边刚才写的

02:45.680 --> 02:48.240
或者是什么的 这一系列语句

02:48.500 --> 02:50.540
都可以 比如说这边这个例子

02:50.800 --> 02:52.080
我们把这个例子拿过来

02:53.360 --> 02:53.860
然后

02:55.660 --> 02:56.940
把这个往下拉一点

02:57.140 --> 03:00.980
好 那我们这边我们来看一下 首先看一下这个制服串

03:01.240 --> 03:02.520
这个制服串的话

03:02.780 --> 03:05.340
这个是一个多航制服串

03:05.860 --> 03:07.900
当然大家没学过这个

03:08.420 --> 03:10.460
我想想学过没有 学过了 学过了

03:10.460 --> 03:12.000
这个的话是es6

03:12.260 --> 03:13.520
es6里面的这个

03:14.040 --> 03:14.820
模板制服串

03:15.080 --> 03:17.120
对不对 然后这个模板制服串里面

03:18.140 --> 03:20.960
我里面是不是有一段这个JS代码

03:21.220 --> 03:23.000
这个JS代码也非常简单

03:23.200 --> 03:24.700
挖了一个a等于1

03:24.960 --> 03:27.300
b等于2 如果a大于b

03:27.560 --> 03:30.380
然后输出这个 否则的话输出这个

03:30.640 --> 03:35.240
这个很明显 这段制服串就是记录的什么呢 记录了一段这个JS代码

03:35.500 --> 03:41.040
好 完事之后 我把这个制服串扔到哪里去呢 我把它扔到

03:41.380 --> 03:42.160
1握里面

03:43.680 --> 03:44.200
OK

03:44.460 --> 03:45.740
来我们这边我们来看一下

03:47.520 --> 03:48.040
走

03:48.800 --> 03:52.140
看到没有 最终它输出什么 输出a小于b

03:53.000 --> 03:56.440
为什么呢 原因很简单 因为你a确实小于b 所以它进a else

03:57.200 --> 04:01.400
看到没有 这就是这个e我的一个基本用法 包括你这边的话

04:02.160 --> 04:05.800
我那个文档里面取了一些其他的例子 比如说我们这边的话

04:06.840 --> 04:10.760
e我2加一个2 那这个是一个什么

04:11.840 --> 04:15.160
这个是不是就是它是一个表达式了 对不对 它不是个语句

04:15.560 --> 04:19.760
它是个表达式 那最终这个得到了值是多少呢 这个得到了值就是4

04:20.080 --> 04:21.880
但你这样子的话你是看不到效果的

04:23.000 --> 04:28.120
看到没有 看不到效果 为什么呢 因为它会把这个值给你返回回来 返回回来的话 那我们这边的话我们可以

04:28.640 --> 04:29.400
cancel

04:30.940 --> 04:33.240
cancel.log 我们可以打印一下

04:36.780 --> 04:42.940
看到没有 这里的话就是它这边就是给你返回了一个值 就执行结果 这边2加24

04:43.440 --> 04:48.560
执行结果是4 那既然它把它返回回来 返回回来 然后将我们这边通过cancel.log

04:48.820 --> 04:50.100
我们把它打印出来

04:53.270 --> 04:55.070
回到我们的这个

04:55.270 --> 04:55.790
交案

04:56.550 --> 05:02.450
而这边的话还举了一些其他的例子 这边就不在那个viscode里面敲了 我们这边我们来看一下

05:02.950 --> 05:08.070
这边的话e我 然后传入的是什么呢 这边的话是new了一个sdream hello

05:09.350 --> 05:13.710
看到没有 这边的话是创建一个制服串 是不是它也是把它把这一段

05:14.230 --> 05:16.270
当作jstimer来进行执行的

05:17.030 --> 05:21.130
而这边的e我2加2 等等e我4 返回的是q

05:21.970 --> 05:31.970
好 然后这边2加2 等等这个newsdream2加2 这个是force 为什么 这个是不是涉及到那个包装对象的姿势啊

05:32.850 --> 05:40.450
对不对 因为它这个是一个包装对象啊 这个的话就是一个普通制服串 你哪怕不用义务 你直接这样子等他返回的就是force

05:40.810 --> 05:41.970
那我们这边我们可以来看一下

05:42.850 --> 05:43.810
比如说我们这边的话

05:45.090 --> 05:46.090
直接log

05:47.490 --> 05:49.330
log一个比如说这个2

05:50.010 --> 05:51.130
然后等等等

05:52.770 --> 05:53.650
newsdream

05:55.090 --> 05:56.610
然后这边的话 传入一个2

05:57.450 --> 05:58.050
好 走

05:59.330 --> 06:06.130
所以返回的也是个force 为什么 因为这个是一个普通类型 这个是一个什么 这个是不是一个包装对象

06:07.050 --> 06:11.810
对不对啊 所以这边的话 就是你不要就是这里加了这个e我 你就不认识了

06:12.330 --> 06:13.970
啊 你这个普通的进行比较

06:14.690 --> 06:19.010
他返回的也是这个force 你这边加e我的话 只不过是就是把这个

06:19.530 --> 06:21.450
当作jsh代码 是不是来执行

06:22.330 --> 06:23.410
对不对 OK

06:24.330 --> 06:26.290
好 然后接下来的话 我们来看一下啊

06:27.290 --> 06:32.770
通过上面的代码我们可以发现e我的话 他会将传入的制服串作为jsh

06:33.290 --> 06:34.530
来进行一个执行

06:35.730 --> 06:40.210
那我如果我的这个制服串 他不是这个标准的jsh代码呢

06:41.770 --> 06:46.530
啊 如果他不是这个标准的jsh代码 那怎么办呢 那他会将这个参数

06:47.090 --> 06:51.770
原封不动的返回啊 比如说我这边的话 我传的压根就不是制服串

06:52.250 --> 06:54.010
我传的是什么 这个传的是一个布尔兹

06:54.810 --> 06:58.210
对不对 这个传的是什么 这个传的是一个Lumber类型的籽

06:59.050 --> 07:03.730
对不对啊 他就会把这个籽原封不动的返回啊 那我们这边我们来看一个

07:04.650 --> 07:05.010
比如说

07:06.250 --> 07:06.490
这里

07:08.370 --> 07:13.170
啊 这边e我去走 你看最终这边返回的是不是去啊

07:14.050 --> 07:19.890
对不对 那我这边让我如果负责一份 让我传入一个e 好吧 前面都注释掉吧

07:21.250 --> 07:26.410
前面注释掉 这个也注释掉 免得影响这个看

07:27.290 --> 07:28.490
好 然后这里

07:29.730 --> 07:32.690
看到没有 返回的就是e 注意这个e他不是制服串

07:33.650 --> 07:38.010
这个他不是制服串 你看这个颜色是不是都是黄色 他是一个Lumber

07:38.210 --> 07:43.450
然后 如果制服串不是这个接时代吗

07:44.010 --> 07:46.890
他也会将这个制服串 原封不动的返回

07:47.450 --> 07:55.010
也就是说两种情况 要么你不是制服串 不是制服不是制服串 他是其他类型 对吧 是布尔类型 是那个Lumber类型

07:55.290 --> 07:57.690
好 然后我给你原封不动的返回

07:58.410 --> 08:04.210
第二种 如果你试制服串 试制服串 但是你这个制服串不是接时代吗

08:05.210 --> 08:08.530
那么我也会把这个制服串 原封不动的返回

08:09.530 --> 08:13.050
看到没有啊 那我们这边我这边举了个例子

08:14.130 --> 08:15.530
就把这个例子拿来看一下嘛

08:17.370 --> 08:18.450
把上面的注释掉

08:21.130 --> 08:29.890
啊 这边 挖了一个哈喽哈喽的话 这边给了个植物 好 大家这边依我哈喽 那这个的话是不是不是一段这个合法的接时代码

08:30.530 --> 08:34.170
对不对 就是一个普通的制服串 所以最终他返回的是这个制服串

08:34.970 --> 08:37.970
好 然后我这边这个制服串的话 我这边是不是又是一个变流名

08:38.450 --> 08:41.410
所以这里最终输出什么呢 最终输出5

08:42.610 --> 08:48.610
看到没有 最终就输出5啊 这个的话就是关于这个依我的一个基本用法

08:49.850 --> 08:53.730
看没有 其实很简单 就是把传入的这个GS制服串

08:54.330 --> 09:00.930
拿来进行一个解释 我们这边我们来总结一下嘛 总结一下 就是首先的话你会给他传参 他是一个函数

09:02.090 --> 09:04.050
对不对 他是个函数 你肯定会向他传参

09:04.570 --> 09:09.290
传参的话就分为这么几种情况 首先你传的不是制服串

09:10.170 --> 09:17.290
那不是制服串你就是其他类型的 对吧 你是比如说布尔类型 纳布尔类型 或者其他类型 那他就会将参数

09:17.730 --> 09:19.410
原封不动的返回

09:20.610 --> 09:24.610
那第二种是制服串 是制服串这里又要分

09:25.330 --> 09:28.970
看你这个制服串是不是GS代码

09:29.890 --> 09:33.890
如果是GS代码 干嘛 是不解释执行

09:34.530 --> 09:39.850
对不对 如果不是GS代码 将这个制服串是原封不动的返回

09:41.130 --> 09:47.610
革命啊 这个的话就是关于这个EWO的基本用法 你可以自己再看一看 试一试

09:48.370 --> 09:53.610
ok 好 然后接下来的话 我们来看下一个EWO的作用预

09:56.090 --> 09:59.930
EWO里面的代码 在当前词法环境中执行

10:00.770 --> 10:04.730
因此他可以看到外部的变量 那我们这边我们来看这么一个例子

10:05.370 --> 10:10.930
然后这里的话列特了一个A等于一个1 然后接下来的话 这边有一个这个函数F

10:11.250 --> 10:15.130
对吧 然后调用F 调用F 然后接下来这边又声明了一个这个

10:15.970 --> 10:22.650
变量A A的话是2 那这个A和这个A它是什么呢 它是不会这个冲突的

10:23.210 --> 10:27.610
对不对 因为他们在不同的这个作用预 它是全局作用预 它是函数作用预

10:28.290 --> 10:30.050
好 然后接下来的话 这边EWO

10:30.610 --> 10:38.890
cancel.logA 我这边是不是要打印这个A 那这个A的话 它能不能找到我上一层 也就是说这个A呢

10:39.370 --> 10:41.450
啊 它是可以的 那我们这边我们来看一下

10:42.410 --> 10:49.720
回到我们这边 好吧 这个放到右边去算了 放到这右边

10:52.280 --> 11:00.120
ok 好 这样方便点 好 我们把这个注释掉 注释掉之后 然后接下来的话 我们这边啊 外面外面那个我们也就不用写了 是吧

11:00.400 --> 11:04.240
我们这边呢 就直接写一个方形啊 比如说方形F

11:05.760 --> 11:07.720
好 然后接下来这边的话 调用一下

11:08.520 --> 11:13.200
调用一下这个函数 那在这个函数里面 我们内扯一个A 等于一个E

11:13.920 --> 11:18.040
对吧 好 然后接下来的话 这边EWO 然后传入一个制服串

11:18.600 --> 11:20.720
cancel.logA

11:21.960 --> 11:28.960
那回头的话 它这边这个A的话 它就可以找到什么呢 找到它外一层的这个作用预

11:29.240 --> 11:31.040
这个A 那我们这边我们来看一下

11:33.240 --> 11:34.800
走 看到没有

11:35.680 --> 11:40.760
是不是就找到了啊 它不仅可以找到 而且它还可以干嘛呢 它还可以比如说我们再举个例子

11:42.200 --> 11:47.000
我这边的话还可以改变啊 比如说我这边net一个A 等于一个E

11:47.640 --> 11:54.360
好 然后接下来我这边EWO 然后传一段这个制服串 是吧 制服串 然后接下来我这边 我把这个字给你改了

11:54.560 --> 11:56.160
改成10

11:57.360 --> 12:01.160
看到没有 好 那接下回头我这边log一下log这个A

12:02.360 --> 12:10.840
走 这就变成10了 对不对 也就是这个EWO的话 它的作用预就有点类似于什么的 有点类似于这个函数作用预

12:11.400 --> 12:17.480
那你这边让你把它看作是一个函数 那这个函数里面 如果没有A的话 它就干嘛呢 它就找它的外一层

12:17.960 --> 12:22.240
对不对 如果有的话 它就找它什么 找它自己的 比如我们这边 我再来看一下

12:23.040 --> 12:28.600
把这个打开 你这边那是因为你没有 你如果有的话 比如说我这边的话 我net一个这个A

12:29.200 --> 12:32.280
等于一个什么呢 等于一个100 用封号建格一下

12:33.200 --> 12:34.840
OK 好 那接下来我们这边走

12:35.920 --> 12:40.680
那它打印出来就是什么 是不是打印出来就是100 为什么 因为我这个作用预里面有这个A

12:41.480 --> 12:42.680
那如果你在没有

12:45.040 --> 12:50.040
对吧 没有没有 我就找什么 我就找外一层 是不是就和我们的那个函数作用预很像啊

12:50.880 --> 12:53.920
对不对 和函数作用预很像啊 OK

12:55.400 --> 12:57.120
好 然后接下来下面

12:58.200 --> 13:07.720
颜格模式下E我有自己的词法环境啊 因此这个E我内部声明的这个函数和辩量 在外部是不可见的

13:08.200 --> 13:11.000
那我们这边我们来看一下啊 比如说我们这边举个例子

13:13.660 --> 13:15.900
比如说我们这边的话E我

13:16.900 --> 13:21.340
然后我们这边的话挖了一个A等于一个100

13:22.380 --> 13:25.220
那这边的话 它就和那个函数作用预的区别就出来了

13:25.860 --> 13:28.900
函数作用预里面 你如果在函数里面声明了个辩量

13:29.380 --> 13:33.660
函数执行完之后那个辩量就不在了 你外部是不是自然而然也访问不到

13:34.420 --> 13:42.740
对不对 但是E我的话 你这边 这边我们现在没有在严格模式下面啊 那我们这边的话就是有一个制服串 制服的制服串的话 这边A等于一个

13:43.300 --> 13:47.380
100声明了个辩量 好 那这样我们这边我们在外部我们来访问一下

13:48.140 --> 13:49.980
console.logA 走

13:51.060 --> 13:56.780
访问到没有 是不是就访问到了 对不对 好 那我这边的话 我如果把它开成严格模式

13:58.780 --> 14:01.820
比如说我这边的话UserStrict

14:02.860 --> 14:04.940
好 然后接下来我们这边再来走

14:05.980 --> 14:11.380
看到没有 还访问得到吧 是不是就访问不到了 那你一旦把这个严格模式一打开

14:11.660 --> 14:15.740
他是不是就有点类似于那个函数作用于了 和函数作用基本就一模一样

14:16.340 --> 14:22.660
对不对 我这里面声明的 一旦出了这个疑惑之后 你外界的话是访问不到的

14:23.740 --> 14:29.060
访问不到的 说这边的话就是严格模式下有自己的释放环境

14:29.860 --> 14:39.580
ok 好 然后最后你这边可以把这这这个例子再看一下 把这个例子看一下 其实就和我们刚才讲的是差不多的

14:40.060 --> 14:45.380
好 最后最后的话就是永远不要使用仪我

14:46.180 --> 14:49.820
可能有的同学说 你这仪我感觉听了好像没听

14:50.700 --> 14:56.780
为什么呢 你讲了吧就讲了一下基本用法 怎么用我好像现在有点会了

14:57.260 --> 15:02.980
但是你怎么没讲讲他具体的使用场景呢 就这个东西在哪些场景下使用呢

15:03.620 --> 15:09.540
那原因很简单 因为这边的话他压根线就现在压根就没有适用的场景

15:10.540 --> 15:14.700
看没有啊 所以这边那就是永远不要使用一我

15:15.660 --> 15:22.540
在现代编程中一我的使用是非常谨慎啊 然后人们常说啊一我一直这个一我

15:23.300 --> 15:30.540
是这个邪恶的啊 为什么呢 原因很简单很走很久之前这个街市他非常非常的弱

15:31.300 --> 15:34.140
非常非常弱 所以很多事情的话你只能通过这个一我

15:34.740 --> 15:40.700
来完成 我说过最早街市他就是一门婆婆通通简简单单的一门脚本语言

15:41.540 --> 15:41.900
你想他

15:42.620 --> 15:47.980
就是针对的人群都是什么呢 针对的人群都是一些就是非编程人士

15:49.140 --> 15:54.180
因为真正认认的那个编程人士他们编写单码都是用什么的 用C呀用C加加呀

15:54.900 --> 15:56.260
用这些语言

15:56.780 --> 16:02.180
说当时那个不能能爱起他在设计这门语言的时候他就想了这门语言要足够的简单

16:02.900 --> 16:04.420
就是非专业人士

16:05.100 --> 16:11.220
都可以用啊 说当时的话这个街市他非常非常做 很多事情就只能干嘛呢 只能通过

16:11.740 --> 16:12.460
一我来完成

16:13.540 --> 16:21.980
啊 但现在的话基本上就是没有任何的理由来使用这个一我了啊 原因很简单 这边总结了三点 首先他非常的这个危险

16:22.620 --> 16:23.900
啊 你容易就是

16:25.740 --> 16:27.980
如果你用这个一我 运行这个制服串

16:28.500 --> 16:31.740
这个代码容易被这个恶意方修改

16:32.460 --> 16:34.300
就你这边 比如说你在你的代码里面

16:36.380 --> 16:37.100
比方你在这里面

16:38.180 --> 16:44.500
啊 你在你的代码里面写了个一我 然后接下来的话 你这边的话 这个他是传一个制服串 是吧 那这个制服串我是这边

16:45.020 --> 16:45.780
传入进来的

16:46.500 --> 16:53.700
那我这边的哇一个ak是啊 这边有一段制服串 那这个制服串的话是传入到这里面来执行 那这个制服串呢 比如说

16:54.700 --> 16:55.780
是由用户输入的

16:56.620 --> 16:57.900
啊 假设是用户输入的

16:58.180 --> 17:02.740
那这个时候用户是不是就可以输入一段什么 是不是输入一段恶意的代码

17:03.580 --> 17:05.500
对不对啊 说他非常的危险

17:07.140 --> 17:14.060
然后第二个一我的话通常比其他替代方法更慢 因为他必须调用这个接式这个解释器

17:15.340 --> 17:22.660
然后其许多其他结构的话 许多其他结构啊 现在已经就是被接式引擎已经优化了

17:23.020 --> 17:25.940
但是一我没有啊 所以经常你用这个一我的话

17:26.700 --> 17:33.220
还比你用这个普通的接式代码 他要慢很多啊 最后就是混乱的这个代码逻辑

17:33.820 --> 17:41.140
所以你不能去看哪啊 告诉你都是不要使用一我 比如说我们这边我们把这个mdn打开

17:43.610 --> 17:44.810
我们这边把mdn打开

17:48.220 --> 17:51.580
那mdn 然后我们这边找到这个一我 这边

17:52.900 --> 17:53.380
我们把他打开

17:55.420 --> 17:55.780
咋回事

17:57.740 --> 17:58.540
咋回事

18:00.840 --> 18:04.800
呃 我这边还打不开了吗 来个百度快招呢

18:05.960 --> 18:07.240
百度快招应该能够打开吧

18:08.960 --> 18:11.960
啊 百度大快招打开了啊 这边的话

18:13.040 --> 18:13.680
看到没有 这里

18:15.440 --> 18:18.080
这里是永远不要使用一我

18:19.800 --> 18:26.960
看到没有 永远不要使用一我啊 说现在的话就是现代编程啊 没有任何的理由再去使用这个一我了

18:27.680 --> 18:31.680
好吧 说我们这个一我的话也是 就是我们的目的就是简单介绍一下

18:32.440 --> 18:38.320
啊 对你能对你们的要求是什么呢 对你们的要求就是知道哦 原来接式里面有这么一个东西

18:39.080 --> 18:44.960
对吧 不至于到时候别人提到的话 你一点都不知道 第二个的话就是大致知道这个东西是干嘛的

18:45.680 --> 18:49.200
对吧 他可以就是解释这个制服串 把这个制服串

18:49.760 --> 18:55.440
当做这个接式代码来进行一个解释执行 当然前提是你那个制服串就是一段接式代码啊

18:55.840 --> 19:00.080
如果你是一段普通的制服串 他会是原封不通的 打还给你

19:00.840 --> 19:06.880
对不对 就大致知道这个一我他怎么用的 然后他的这个作用欲啊 或者说他的一些特点是什么

19:07.280 --> 19:13.160
就可以了 真真实实在开发的时候记住 永远不要使用一我

19:14.080 --> 19:18.280
好吧 最后的话就是关于这个整体解答 我们来看一下

19:19.000 --> 19:25.680
javascript中一握方法是啥 一般什么场景使用啊 一握的话他是接式中的一个权具函数

19:26.160 --> 19:31.240
他将指定的制服串计算为javascript代码 并执行他 或者说并解释他

19:31.960 --> 19:39.160
那什么场景下使用呢 那你这边就可以这么回答 在现代js编程中应该尽量避免使用一握

19:39.760 --> 19:41.720
基本上没有什么场景的

19:42.680 --> 19:48.840
啊 基本上没有什么场景的 就你以前的那些场景啊 以前有些场景需要使用这个一握

19:49.640 --> 19:53.320
来做 那现在的话都有更好的方式进行替代

19:54.120 --> 19:59.320
看到没有啊 之前所有使用一握的地方都有更好的方式来进行替代

20:00.200 --> 20:05.880
啊 说并不存在什么的 并不存在某些场景 必须要使用一握才能实现 已经不存在了

20:06.360 --> 20:08.880
说现在的话基本上就没什么场景使用了

20:09.680 --> 20:14.360
ok 啊 这就是关于这个一握 大家的话简单了解一下

20:15.040 --> 20:19.280
就可以了 好不好 这期课就先到这里 再见

