WEBVTT

00:01.140 --> 00:03.140
大家好 我是谢老师

00:03.140 --> 00:05.140
这期课的话我们来看一下关于这个

00:05.140 --> 00:08.140
weak sit和weak map

00:08.140 --> 00:11.140
就是美团在19年

00:11.140 --> 00:13.140
然后出的一道面试题

00:13.140 --> 00:17.140
是否了解weak map和weak sit

00:17.140 --> 00:19.140
说说我们这边的话我们来看一下

00:19.140 --> 00:22.140
什么是weak map和weak sit

00:22.140 --> 00:25.140
那这里的话首先要从这个对象说起

00:25.140 --> 00:27.140
对象的话大家其实非常熟悉

00:27.140 --> 00:29.140
对吧 你看我这边的话

00:29.140 --> 00:31.140
有这么一段代码

00:31.140 --> 00:33.140
很简单的一段代码

00:33.140 --> 00:36.140
这边的话有这么一个对象

00:36.140 --> 00:38.140
叫做organism

00:38.140 --> 00:40.140
然后既然它有一个键叫做site

00:40.140 --> 00:42.140
对应一个字

00:42.140 --> 00:45.140
大家在这边打印它site属性

00:45.140 --> 00:47.140
就得出这个字

00:47.140 --> 00:49.140
然后接下来这一步

00:49.140 --> 00:51.140
这一步是不是在便利

00:51.140 --> 00:54.140
便利它对象里面所有的键

00:54.140 --> 00:57.140
大家打印出键说对应的这个字

00:57.140 --> 00:58.140
然后接下来这一步

00:58.140 --> 01:01.140
这一步的话是在删除

01:01.140 --> 01:03.140
删除它属性

01:03.140 --> 01:05.140
删除了之后你再打印它就是什么呢

01:05.140 --> 01:07.140
它就是undefiled对吧

01:07.140 --> 01:09.140
这个的话是大家很熟悉的一段代码

01:09.140 --> 01:11.140
这个的话我就不写了

01:11.140 --> 01:15.140
那为什么要从这个对象来开始复行呢

01:15.140 --> 01:17.140
因为这个map

01:17.140 --> 01:20.140
它其实就和这个对象非常相似

01:20.140 --> 01:22.140
它也是这个键子队

01:22.140 --> 01:23.140
它也是键子队

01:23.140 --> 01:25.140
那么来看一下

01:25.140 --> 01:29.140
这一步是这个JS中新的集合对象

01:29.140 --> 01:32.140
它是这个ES6新增加的

01:32.140 --> 01:34.140
功能的话类似对象

01:34.140 --> 01:36.140
其实就和对象基本是一样的

01:36.140 --> 01:37.140
也是键子队

01:37.140 --> 01:39.140
但是呢它有那么一些差异

01:39.140 --> 01:41.140
我们来看一下有些什么差异

01:41.140 --> 01:42.140
那首先第一个

01:42.140 --> 01:45.140
第一个是关于这个天下属性

01:45.140 --> 01:49.900
那我们这边来演示一下

01:49.900 --> 01:52.900
我们这边的话先来到这里

01:52.900 --> 01:54.900
我们先来创建个对象

01:54.900 --> 01:57.900
比如我这边挖一个OB接

01:57.900 --> 02:00.900
等于一个空对象

02:00.900 --> 02:02.900
这边的话是不是创建一个对象

02:02.900 --> 02:04.900
那既然我想给它添加键的话

02:04.900 --> 02:06.900
是不是直接添加就可以了

02:06.900 --> 02:07.900
对不对

02:07.900 --> 02:09.900
比如内幕是一个张三

02:09.900 --> 02:12.900
这是普通对象

02:12.900 --> 02:16.660
普通

02:16.660 --> 02:20.660
普通就是创建普通对象

02:20.660 --> 02:21.660
普通对象

02:21.660 --> 02:24.660
然后添加

02:24.660 --> 02:26.660
添加这个属性

02:26.660 --> 02:27.660
对吧

02:27.660 --> 02:28.660
或者说添加这个键

02:28.660 --> 02:29.660
ok

02:29.660 --> 02:30.660
好

02:30.660 --> 02:31.660
然后接下来这个Map

02:31.660 --> 02:32.660
Map它是怎么呢

02:32.660 --> 02:34.660
Map这边我们挖一个M

02:34.660 --> 02:37.660
等于一个NewMap

02:37.660 --> 02:38.660
看没有

02:38.660 --> 02:42.660
它这边要求你就是NewMap

02:42.660 --> 02:43.660
也就是从Map这个

02:43.660 --> 02:44.660
构造函数里面

02:44.660 --> 02:47.660
实力化一个新的Map出来

02:47.660 --> 02:48.660
这个其实

02:48.660 --> 02:50.660
我们这个其实也是等价于什么

02:50.660 --> 02:52.660
其实这边是一样的

02:52.660 --> 02:53.660
你不要觉得这边不一样

02:53.660 --> 02:56.660
它这边其实我们也是New object

02:56.660 --> 02:58.660
对不对

02:58.660 --> 03:00.660
其实也是等价于这句话的

03:00.660 --> 03:01.660
好

03:01.660 --> 03:02.660
然后接下来

03:02.660 --> 03:03.660
这里没什么区别

03:03.660 --> 03:04.660
好

03:04.660 --> 03:07.660
然后接下来就是添加

03:07.660 --> 03:09.660
添加这个键

03:09.660 --> 03:12.290
添加键的话

03:12.290 --> 03:13.290
它是怎么添加呢

03:13.290 --> 03:14.290
它这里的话

03:14.290 --> 03:16.290
有一个方法

03:16.290 --> 03:17.290
叫做什么

03:17.290 --> 03:19.290
叫做Set方法

03:19.290 --> 03:20.290
通过这个Set方法

03:20.290 --> 03:21.290
然后接下来

03:21.290 --> 03:23.290
在这边你来添加这个键子对

03:23.290 --> 03:26.290
比如说我们这边Lame

03:26.290 --> 03:28.290
然后这边

03:28.290 --> 03:30.290
解决

03:30.290 --> 03:31.290
看没有

03:31.290 --> 03:33.290
我们这边可以打印一下

03:33.290 --> 03:35.290
比如说这边Log这个M

03:35.290 --> 03:36.290
这边第六行打印

03:36.290 --> 03:37.290
它是不是空的

03:37.290 --> 03:38.290
对吧

03:38.290 --> 03:39.290
好

03:39.290 --> 03:40.290
然后接下来下面

03:40.290 --> 03:42.290
下面来打印M

03:42.290 --> 03:43.290
好

03:43.290 --> 03:48.100
然后在这边走

03:48.100 --> 03:49.100
你看

03:49.100 --> 03:50.100
第一次打印的时候

03:50.100 --> 03:53.100
这边Map的这个

03:53.100 --> 03:55.100
长度是0

03:55.100 --> 03:56.100
对吧

03:56.100 --> 03:57.100
那第二次

03:57.100 --> 04:00.100
第二次的话这边

04:00.100 --> 04:01.100
第二次这边是不是就是

04:01.100 --> 04:03.100
有这个键子对了

04:03.100 --> 04:04.100
对吧

04:04.100 --> 04:05.100
键是Lame

04:05.100 --> 04:06.100
然后在这边

04:06.100 --> 04:07.100
指向的值

04:07.100 --> 04:09.100
值的话是这个解决

04:09.100 --> 04:10.100
看没有

04:10.100 --> 04:12.100
它不允许你什么呢

04:12.100 --> 04:13.100
不允许你就是

04:13.100 --> 04:14.100
再添加这个相同的

04:14.100 --> 04:15.100
比如说我这边

04:15.100 --> 04:19.100
再来M点这个Set

04:19.100 --> 04:21.100
比如说这边Lame

04:21.100 --> 04:22.100
好

04:22.100 --> 04:23.100
我值是相同的

04:23.100 --> 04:25.100
仍然是比较解决

04:25.100 --> 04:26.100
所以就是添加

04:26.100 --> 04:27.100
两个键进去呢

04:27.100 --> 04:28.100
我们来看一下

04:28.100 --> 04:30.730
这边M

04:30.730 --> 04:32.730
是不是仍然只有一个键

04:32.730 --> 04:33.730
对不对

04:33.730 --> 04:34.730
仍然只有一个键

04:34.730 --> 04:35.730
但是你这边可以改

04:35.730 --> 04:36.730
比如说我这边

04:36.730 --> 04:37.730
第一次是斜截

04:37.730 --> 04:38.730
第二次我把它改成

04:38.730 --> 04:39.730
张三

04:39.730 --> 04:41.730
再加这边走

04:41.730 --> 04:42.730
第一次是斜截

04:42.730 --> 04:44.730
第二次就变成张三了

04:44.730 --> 04:45.730
对不对

04:45.730 --> 04:47.730
你可以这个

04:47.730 --> 04:48.730
就是通过Set的方法

04:48.730 --> 04:49.730
它既可以添加

04:49.730 --> 04:50.730
也可以就是修改

04:50.730 --> 04:51.730
你这个键

04:51.730 --> 04:53.730
所对应的这个值

04:53.730 --> 04:55.730
然后通过这个二维数组

04:55.730 --> 04:56.730
快速的初始化

04:56.730 --> 04:58.730
一个这个Map

04:58.730 --> 04:59.730
比如说我们这边

04:59.730 --> 05:01.730
我们来看一下

05:01.730 --> 05:06.360
通过

05:06.360 --> 05:12.400
通过一个二维数组

05:12.400 --> 05:14.400
然后可以

05:14.400 --> 05:17.400
快速的初始化

05:17.400 --> 05:19.400
一个Map

05:19.400 --> 05:20.400
比如说举个例子

05:20.400 --> 05:21.400
比如说我们这边

05:21.400 --> 05:22.400
来写这么一个

05:22.400 --> 05:23.400
二维数组

05:23.400 --> 05:25.400
比如挖一个AR

05:25.400 --> 05:27.400
等于一个

05:27.400 --> 05:28.400
这边

05:28.400 --> 05:29.400
好

05:29.400 --> 05:30.400
一

05:30.400 --> 05:31.400
二

05:31.400 --> 05:32.400
然后

05:32.400 --> 05:33.400
这边随便改一下

05:33.400 --> 05:34.400
三

05:34.400 --> 05:36.400
四

05:36.400 --> 05:38.400
五

05:38.400 --> 05:40.400
六

05:40.400 --> 05:41.400
七

05:41.400 --> 05:42.400
八

05:42.400 --> 05:43.400
ok

05:43.400 --> 05:44.400
这边是不是这个二维数组

05:44.400 --> 05:45.400
对吧

05:45.400 --> 05:46.400
好

05:46.400 --> 05:47.400
然后接下来我这边

05:47.400 --> 05:49.400
挖一个M

05:49.400 --> 05:52.400
等于一个这个NewMap

05:52.400 --> 05:53.400
然后我就可以干嘛了

05:53.400 --> 05:55.400
我就可以把这个AR

05:55.400 --> 05:56.400
我把它传进去

05:56.400 --> 05:57.400
传进去之后

05:57.400 --> 05:58.400
然后接下来

05:58.400 --> 06:02.710
我们这边Log一下

06:02.710 --> 06:04.710
然后这边打印

06:04.710 --> 06:05.710
看到没有

06:05.710 --> 06:06.710
这边这个E的话

06:06.710 --> 06:07.710
就是作为键

06:07.710 --> 06:08.710
也就是说你这边

06:08.710 --> 06:09.710
二维数组

06:09.710 --> 06:11.710
里面的每一个数组

06:11.710 --> 06:12.710
其实就是怎么样

06:12.710 --> 06:13.710
就是它里面的

06:13.710 --> 06:15.710
是不是一个键子队

06:15.710 --> 06:16.710
对不对

06:16.710 --> 06:17.710
然后接下来

06:17.710 --> 06:18.710
第一个数组的第一项

06:18.710 --> 06:19.710
会成为键

06:19.710 --> 06:20.710
然后第二项

06:20.710 --> 06:21.710
会成为什么

06:21.710 --> 06:22.710
第二项是不会成为纸

06:22.710 --> 06:23.710
对不对

06:23.710 --> 06:24.710
那你这边的话

06:24.710 --> 06:25.710
你就可以这样子

06:25.710 --> 06:28.710
我们不见得要

06:28.710 --> 06:29.710
这个E2

06:29.710 --> 06:30.710
那我们这边的话

06:30.710 --> 06:32.710
就比如说这个Name

06:32.710 --> 06:35.710
然后张3

06:35.710 --> 06:37.710
然后接下来这边

06:37.710 --> 06:39.710
Edge

06:39.710 --> 06:41.710
对应比如说18

06:41.710 --> 06:42.710
对吧

06:42.710 --> 06:43.710
然后接下来

06:43.710 --> 06:45.710
这边比如Gender

06:45.710 --> 06:48.710
Gender对应的是一个Mail

06:48.710 --> 06:49.710
OK

06:49.710 --> 06:50.710
好

06:50.710 --> 06:51.710
看到没有

06:51.710 --> 06:52.710
你看我这边

06:52.710 --> 06:53.710
键子队是不是就出来了

06:53.710 --> 06:54.710
Lame对应的是张3

06:54.710 --> 06:56.710
Edge对应的是18

06:56.710 --> 06:57.710
Gender对应的是Mail

06:57.710 --> 06:59.710
我们可以通过这个2位数组

06:59.710 --> 07:01.710
来获取它的这个

07:01.710 --> 07:03.710
来快速的

07:03.710 --> 07:05.710
初始化这个Map

07:05.710 --> 07:06.710
好那接下来我这边

07:06.710 --> 07:08.710
我可以获取它的这个长度

07:08.710 --> 07:09.710
怎么获取呢

07:09.710 --> 07:10.710
它有一个叫做

07:10.710 --> 07:12.710
Size的属性

07:12.710 --> 07:15.710
Blog

07:15.710 --> 07:17.710
这边Size

07:17.710 --> 07:18.710
好然后这边走

07:18.710 --> 07:19.710
看到没有

07:19.710 --> 07:20.710
这边是不是Size

07:20.710 --> 07:21.710
这个是你以前

07:21.710 --> 07:22.710
你这个对象

07:22.710 --> 07:23.710
没办法做到的

07:23.710 --> 07:24.710
对不对

07:24.710 --> 07:25.710
以前你对象

07:25.710 --> 07:26.710
我比如说我这边

07:26.710 --> 07:29.710
初始化一个对象

07:29.710 --> 07:30.710
比如我这边

07:30.710 --> 07:32.710
挖一个OBG

07:32.710 --> 07:35.710
等于一个Lame

07:35.710 --> 07:37.710
张3

07:37.710 --> 07:39.710
然后Edge

07:39.710 --> 07:40.710
18

07:40.710 --> 07:42.710
然后Gender

07:42.710 --> 07:43.710
对应一个Mail

07:43.710 --> 07:44.710
好那接下来

07:44.710 --> 07:45.710
我这边

07:45.710 --> 07:47.710
我想获取这个对象

07:47.710 --> 07:48.710
它的这个长度

07:48.710 --> 07:49.710
也就是它里面

07:49.710 --> 07:50.710
键有多少个

07:50.710 --> 07:51.710
我说没办法

07:51.710 --> 07:52.710
那只能通过什么呢

07:52.710 --> 07:54.710
只能通过一些其他的方式

07:54.710 --> 07:55.710
比如你通过Full In

07:55.710 --> 07:56.710
去便利

07:56.710 --> 07:58.710
然后接下技术之类的

07:58.710 --> 07:59.710
只能通过这种

07:59.710 --> 08:01.710
就稍微要

08:01.710 --> 08:02.710
就是稍微就是

08:02.710 --> 08:03.710
不像这个这么方便

08:03.710 --> 08:04.710
对不对

08:04.710 --> 08:06.710
我这边就直接一个属性

08:06.710 --> 08:08.710
就出来了

08:08.710 --> 08:09.710
对不对

08:09.710 --> 08:10.710
好然后这样

08:10.710 --> 08:11.710
我如果要获取

08:11.710 --> 08:13.710
某个Map的值

08:13.710 --> 08:14.710
用我这边

08:14.710 --> 08:15.710
要获取这个Lame的值

08:15.710 --> 08:16.710
怎么获取呢

08:16.710 --> 08:18.710
这边可以这个样子

08:20.710 --> 08:22.710
M2.get

08:22.710 --> 08:23.710
掉get方法

08:23.710 --> 08:24.710
好然后接下来

08:24.710 --> 08:25.710
传入什么呢

08:25.710 --> 08:26.710
传入你的这个键

08:26.710 --> 08:28.710
比较这边Name

08:28.710 --> 08:29.710
走

08:29.710 --> 08:31.710
就出来了

08:31.710 --> 08:32.710
对不对

08:32.710 --> 08:33.710
这边

08:33.710 --> 08:34.710
张3

08:34.710 --> 08:35.710
它就出来了

08:35.710 --> 08:37.710
好然后这个Map

08:37.710 --> 08:39.710
它也支持就是便利

08:39.710 --> 08:40.710
比如说我们这边的话

08:40.710 --> 08:42.710
以前我们便利

08:42.710 --> 08:44.710
便利这个Object

08:44.710 --> 08:45.710
我们这边的话

08:45.710 --> 08:46.710
通过什么

08:46.710 --> 08:48.710
就通过这个Full In

08:48.710 --> 08:49.710
对不对

08:49.710 --> 08:51.710
哇一个i

08:51.710 --> 08:53.710
off这个ob键

08:53.710 --> 08:55.710
我们以前是这样子便利的

08:55.710 --> 08:56.710
好然后接下来

08:56.710 --> 08:57.710
这边Log

08:57.710 --> 08:59.710
Log这个Object

08:59.710 --> 09:01.710
然后这个i

09:01.710 --> 09:03.710
这一下

09:03.710 --> 09:05.710
硬硬

09:05.710 --> 09:06.710
这边它

09:06.710 --> 09:07.710
不能通过off

09:07.710 --> 09:11.600
这边应该是硬

09:11.600 --> 09:13.600
所以可以拿到对象的每下

09:13.600 --> 09:14.600
对不对

09:14.600 --> 09:15.600
好让我们这个Map的话

09:15.600 --> 09:17.600
也支持这样子的便利

09:17.600 --> 09:18.600
比如说我们这边

09:18.600 --> 09:20.600
把这些打印都注射了

09:20.600 --> 09:21.600
好这边的话

09:21.600 --> 09:23.600
我们也可以

09:23.600 --> 09:24.600
Full

09:24.600 --> 09:26.600
哇一个i

09:26.600 --> 09:29.600
硬这个M2

09:29.600 --> 09:30.600
好然后接下来

09:30.600 --> 09:32.600
这边Log

09:32.600 --> 09:33.600
这里就应该是什么

09:33.600 --> 09:37.600
是不是M2.get

09:37.600 --> 09:38.600
对不对

09:38.600 --> 09:39.600
然后接下li

09:39.600 --> 09:40.600
就是每个键

09:40.600 --> 09:41.600
对不对

09:41.600 --> 09:43.600
好走

09:44.600 --> 09:46.600
就是没拿到吗

09:46.600 --> 09:47.600
我看一下

09:47.600 --> 09:48.600
Log

09:48.600 --> 09:54.280
Log这个i

09:54.280 --> 09:55.280
哇一个i

09:55.280 --> 09:59.870
跟这个M2

09:59.870 --> 10:00.870
看一下

10:00.870 --> 10:02.870
这边Log

10:02.870 --> 10:04.870
M2

10:04.870 --> 10:06.870
这边是有的

10:06.870 --> 10:08.870
我看一下

10:08.870 --> 10:11.870
这边在便利的时候

10:11.870 --> 10:12.870
直接

10:12.870 --> 10:14.870
它是一个可谍的对象

10:14.870 --> 10:16.870
然后用foroff

10:16.870 --> 10:17.870
直接用foroff

10:17.870 --> 10:19.870
Full硬它还便利

10:19.870 --> 10:20.870
不出来它的键是吧

10:20.870 --> 10:25.250
那我们这边就用foroff

10:25.250 --> 10:26.250
foroff的话

10:26.250 --> 10:27.250
那这边这个i

10:27.250 --> 10:29.250
是不是就是取到的每个字

10:29.250 --> 10:30.250
对不对

10:30.250 --> 10:32.250
那这样我们这边就直接来

10:32.250 --> 10:33.250
走

10:33.250 --> 10:34.250
是不是拿到了

10:34.250 --> 10:35.250
对不对

10:35.250 --> 10:36.250
拿到了它打印出来

10:36.250 --> 10:38.250
是不是一个一个的数组

10:38.250 --> 10:39.250
看了没有

10:39.250 --> 10:40.250
一个一个的数组

10:40.250 --> 10:44.250
这就是关于Map的基本的使用

10:44.250 --> 10:45.250
基本的使用

10:45.250 --> 10:46.250
也就是说从这

10:46.250 --> 10:48.250
从添加属性

10:48.250 --> 10:50.250
一直到获取属性常度

10:50.250 --> 10:53.250
一直到便利Map对象

10:53.250 --> 10:54.250
就这些

10:54.250 --> 10:56.250
快速的过了一遍

10:56.250 --> 10:57.250
还可以使用

10:57.250 --> 10:59.250
KissValuesEntrance

10:59.250 --> 11:00.250
方法

11:00.250 --> 11:02.250
包括for each

11:02.250 --> 11:03.250
这个我就不

11:03.250 --> 11:05.250
挨着挨着势力了

11:05.250 --> 11:07.250
好那我们主要看什么呢

11:07.250 --> 11:08.250
主要看这个

11:08.250 --> 11:10.250
主要看这个

11:10.250 --> 11:12.250
一个我搞出来一个Map

11:12.250 --> 11:15.250
让我以前用这个Object

11:15.250 --> 11:16.250
对吧

11:16.250 --> 11:18.250
我用这个用的好好的

11:18.250 --> 11:21.250
你干嘛要给我搞出来一个Map

11:21.250 --> 11:23.250
它和我以前这个

11:23.250 --> 11:25.250
有什么区别

11:25.250 --> 11:26.250
好那我们这边

11:26.250 --> 11:28.620
我们来看一下这张表

11:28.620 --> 11:30.620
这里首先表里面

11:30.620 --> 11:31.620
第一点

11:31.620 --> 11:33.620
就是Map默认情况下

11:33.620 --> 11:34.620
不包含任何件

11:34.620 --> 11:36.620
只包含插入的

11:36.620 --> 11:37.620
比如你这边set了一个

11:37.620 --> 11:38.620
它是不是就有一个

11:38.620 --> 11:39.620
对不对

11:39.620 --> 11:40.620
但是Object的话

11:40.620 --> 11:42.620
你这边有一个圆形

11:42.620 --> 11:44.620
圆形链上的建民有可能

11:44.620 --> 11:45.620
和自己对象上

11:45.620 --> 11:48.620
设置的建民产生冲突

11:48.620 --> 11:49.620
在ES5中

11:49.620 --> 11:50.620
你可以用这个

11:50.620 --> 11:52.620
Object.create这个node

11:52.620 --> 11:55.620
创建一个没有圆形的对象

11:55.620 --> 11:56.620
这是首先

11:56.620 --> 11:58.620
第一个就是它没有额外的件

11:58.620 --> 11:59.620
第二个

11:59.620 --> 12:00.620
第二个其实是

12:00.620 --> 12:02.620
一个比较非常大的特点

12:02.620 --> 12:03.620
就是什么呢

12:03.620 --> 12:04.620
一个Map的件

12:04.620 --> 12:05.620
它可以是任意值

12:05.620 --> 12:07.620
我可以是函数对象

12:07.620 --> 12:10.620
或者是其他任意基本内心

12:10.620 --> 12:12.620
这是Object就不一样

12:12.620 --> 12:13.620
Object的话

12:13.620 --> 12:14.620
它必须是strain

12:14.620 --> 12:15.620
或者是symbol

12:15.620 --> 12:16.620
比如我们这边

12:16.620 --> 12:18.620
我们举个例子

12:18.620 --> 12:19.620
比如我们这边

12:19.620 --> 12:20.620
这边的话

12:20.620 --> 12:21.620
你看我这边的话

12:21.620 --> 12:22.620
我现在这个是不是支付串

12:22.620 --> 12:23.620
我可以换成什么呢

12:23.620 --> 12:25.620
我可以换成布尔值

12:25.620 --> 12:26.620
可不可以

12:26.620 --> 12:28.620
然后接下这个数字就不说了

12:28.620 --> 12:30.620
数字干是不是已经演示过了

12:30.620 --> 12:31.620
对不对

12:31.620 --> 12:32.620
甚至可以是一个什么

12:32.620 --> 12:33.620
甚至可以是个函数

12:33.620 --> 12:35.620
有这边function

12:35.620 --> 12:37.620
一个匿名函数

12:37.620 --> 12:39.620
好我们这边我们来打印一下

12:39.620 --> 12:40.620
就这样子看吧

12:40.620 --> 12:46.060
这边node index

12:46.060 --> 12:47.060
可不可以

12:47.060 --> 12:50.060
你的这个件可以支持任意内心

12:50.060 --> 12:52.060
这个在以前对象里面是不行的

12:52.060 --> 12:54.060
对象的话你这个件必须是什么

12:54.060 --> 12:56.060
必须是支付串

12:56.060 --> 12:57.060
对不对

12:57.060 --> 12:58.060
或者什么呢

12:58.060 --> 12:59.060
或者symbol

12:59.060 --> 13:00.060
这是这个

13:00.060 --> 13:02.060
这个第二点

13:02.060 --> 13:03.060
下一个

13:03.060 --> 13:05.060
就是件的顺序

13:05.060 --> 13:07.060
map的key是有序的

13:07.060 --> 13:09.060
因此当迭代的时候

13:09.060 --> 13:11.060
map对象也插入了

13:11.060 --> 13:13.060
顺序返回这个件子

13:13.060 --> 13:15.060
但是object它是无序的

13:15.060 --> 13:17.060
下一个就是

13:17.060 --> 13:18.060
它的长度

13:18.060 --> 13:19.060
这个刚才是不是演示过了

13:19.060 --> 13:20.060
就我们这个的话

13:20.060 --> 13:22.060
可以通过这个size

13:22.060 --> 13:23.060
来获取它的这个长度

13:23.060 --> 13:24.060
但是object不行

13:24.060 --> 13:26.060
object你就只能通过手动的

13:26.060 --> 13:27.060
比如 for in

13:27.060 --> 13:28.060
先去便利便利

13:28.060 --> 13:30.060
然后接下来在技术的形式

13:30.060 --> 13:32.060
来计算

13:32.060 --> 13:33.060
然后接下来这个map

13:33.060 --> 13:35.060
它可以直接迭代

13:35.060 --> 13:36.060
我们该是不是使用for off

13:36.060 --> 13:37.060
是不是直接迭代

13:37.060 --> 13:39.060
object的话你得通过什么

13:39.060 --> 13:40.060
得通过这个for in

13:40.060 --> 13:41.060
先获取到什么

13:41.060 --> 13:43.060
是不是先获取到件

13:43.060 --> 13:44.060
是不是才能迭代

13:44.060 --> 13:46.060
然后还有一个就是

13:46.060 --> 13:48.060
什么呢就性能

13:48.060 --> 13:49.060
map的话在频繁

13:49.060 --> 13:51.060
增加或者删除

13:51.060 --> 13:52.060
件子对的时候

13:52.060 --> 13:54.060
它的表现是更好一些

13:54.060 --> 13:55.060
但是对象的话

13:55.060 --> 13:57.060
它没有做出这种优化

13:57.060 --> 13:59.060
所以为什么它这个es6

13:59.060 --> 14:01.060
推出了这个map

14:01.060 --> 14:04.060
它相比这个之前的这个object

14:04.060 --> 14:06.060
它是有这些优点的

14:06.060 --> 14:08.060
有这些优点

14:08.060 --> 14:11.060
那明白了这个什么是map之后

14:11.060 --> 14:13.060
那接下来我们来看这个

14:13.060 --> 14:15.060
wakemap

14:15.060 --> 14:16.060
刚才面试提问的

14:16.060 --> 14:17.060
是不是就是问你

14:17.060 --> 14:19.060
是否了解wakemap

14:19.060 --> 14:21.060
对吧什么叫做wakemap呢

14:21.060 --> 14:23.060
你看它前面加了一个

14:23.060 --> 14:25.060
单词叫做wake

14:25.060 --> 14:26.060
wake什么意思

14:26.060 --> 14:28.060
wake是不是弱的意思

14:28.060 --> 14:29.060
对不对

14:29.060 --> 14:31.060
所以它就是一个弱类型

14:31.060 --> 14:32.060
它是一个弱类型

14:32.060 --> 14:33.060
我们来看一下

14:33.060 --> 14:36.060
wakemap起源于map

14:36.060 --> 14:38.060
它们两者非常的像

14:38.060 --> 14:40.060
但是它们之间有一些区别

14:40.060 --> 14:42.060
什么区别呢

14:42.060 --> 14:43.060
我们来看一下

14:43.060 --> 14:44.060
首先差一一

14:44.060 --> 14:45.060
就是wakemap的话

14:45.060 --> 14:47.060
你的这个key必须是什么呢

14:47.060 --> 14:49.060
必须是对象

14:49.060 --> 14:51.060
我们之前讲map的时候

14:51.060 --> 14:52.060
我们说过map是不是

14:52.060 --> 14:54.060
任何纸都可以做一件

14:54.060 --> 14:55.060
对不对

14:55.060 --> 14:56.060
但是wakemap不一样

14:56.060 --> 14:58.060
wakemap它只接受什么呢

14:58.060 --> 15:00.060
只接受对象作为件

15:00.060 --> 15:02.060
否则它会返回一个错误

15:02.060 --> 15:04.060
这是第一个区别

15:04.060 --> 15:08.140
那比我们这边我们来看一下

15:08.140 --> 15:10.140
我们把这儿代码注射掉

15:10.140 --> 15:16.140
比如说我们这里

15:16.140 --> 15:19.140
挖一个wm

15:19.140 --> 15:21.140
等于一个new

15:21.140 --> 15:25.650
wakemap

15:25.650 --> 15:27.650
接下来我们这边

15:27.650 --> 15:29.650
然后sit

15:29.650 --> 15:31.650
1

15:31.650 --> 15:33.650
我看sit是

15:33.650 --> 15:35.650
直接穿两个是吧

15:35.650 --> 15:37.650
然后这边sit

15:37.650 --> 15:38.650
1

15:38.650 --> 15:39.650
2

15:39.650 --> 15:41.650
然后接下来我们这边打印

15:41.650 --> 15:43.650
nog

15:43.650 --> 15:44.650
我们这边我们来看一下

15:44.650 --> 15:46.650
node

15:46.650 --> 15:47.650
你看

15:47.650 --> 15:48.650
是爆错了

15:48.650 --> 15:49.650
对不对

15:49.650 --> 15:51.650
invide value

15:51.650 --> 15:53.650
used as

15:53.650 --> 15:55.650
wakemap key

15:55.650 --> 15:57.650
就是不合法的这个字

15:57.650 --> 15:58.650
哪个字就是这个e

15:58.650 --> 15:59.650
你必须是什么呢

15:59.650 --> 16:00.650
必须是对象

16:00.650 --> 16:02.650
你必须是对象

16:02.650 --> 16:04.650
比如说这样子

16:04.650 --> 16:05.650
这样子

16:05.650 --> 16:07.650
这样子了就ok

16:07.650 --> 16:09.650
走

16:12.650 --> 16:14.650
我看一下

16:14.650 --> 16:18.150
这边还不能直接这个样子吗

16:19.150 --> 16:22.150
对象不合法是吧

16:22.150 --> 16:24.150
对象不合法

16:24.150 --> 16:25.150
对象是吧

16:25.150 --> 16:27.150
你得至少有个键字对

16:27.150 --> 16:28.150
对不对

16:28.150 --> 16:29.150
有lamb

16:29.150 --> 16:30.150
ok

16:30.150 --> 16:32.150
这样子就ok了

16:32.150 --> 16:35.550
走

16:35.550 --> 16:36.550
是ok了

16:36.550 --> 16:37.550
看到没有

16:37.550 --> 16:39.550
这边就ok了

16:39.550 --> 16:41.550
这是首先第一个差异

16:41.550 --> 16:43.550
第二个

16:43.550 --> 16:44.550
并非这个map中

16:44.550 --> 16:46.550
所有方法都支持

16:46.550 --> 16:47.550
就我们wakemap

16:47.550 --> 16:48.550
可以用什么方法

16:48.550 --> 16:49.550
可以用delete

16:49.550 --> 16:51.550
你去删除

16:51.550 --> 16:52.550
get

16:52.550 --> 16:53.550
去获取

16:53.550 --> 16:54.550
set

16:54.550 --> 16:55.550
去设置

16:55.550 --> 16:56.550
还有hass

16:56.550 --> 16:57.550
hass刚才没有介绍

16:57.550 --> 16:59.550
hass就是看一个键

16:59.550 --> 17:00.550
是否存在

17:00.550 --> 17:02.550
比如说我们这边

17:02.550 --> 17:03.550
我们举个例子

17:03.550 --> 17:05.550
比如刚才

17:05.550 --> 17:06.550
刚才

17:06.550 --> 17:09.550
比如我们把这个打开

17:09.550 --> 17:10.550
把这个打开

17:10.550 --> 17:11.550
打开之后

17:11.550 --> 17:12.550
然后接下来

17:12.550 --> 17:13.550
我们这边

17:13.550 --> 17:14.550
使用hass

17:14.550 --> 17:19.210
使用hass

17:19.210 --> 17:20.210
方法

17:20.210 --> 17:21.210
查询

17:21.210 --> 17:23.210
某个键

17:23.210 --> 17:26.210
某个键

17:26.210 --> 17:28.210
是否存在

17:28.210 --> 17:30.210
大家这边log一下

17:30.210 --> 17:31.210
log

17:31.210 --> 17:32.210
比如说我们这边

17:32.210 --> 17:33.210
m

17:33.210 --> 17:35.210
它就还有个方法叫做hass

17:35.210 --> 17:36.210
让你可以看

17:36.210 --> 17:37.210
比如它的内幕

17:37.210 --> 17:39.210
它是不是有内幕

17:39.210 --> 17:40.210
对吧

17:40.210 --> 17:41.210
你看

17:41.210 --> 17:42.210
这边打印出来就什么

17:42.210 --> 17:43.210
这就是true

17:43.210 --> 17:44.210
对不对

17:44.210 --> 17:45.210
就可以查

17:45.210 --> 17:46.210
查询它是否有

17:46.210 --> 17:48.210
某一个键

17:48.210 --> 17:50.210
很简单的一个方法

17:55.020 --> 17:56.020
那么这些方法

17:56.020 --> 17:57.020
这些方法的话

17:57.020 --> 17:58.020
这个vacmap

17:58.020 --> 18:00.020
它是可以使用的

18:00.020 --> 18:01.020
然后其他的

18:01.020 --> 18:02.020
就除开这些方法

18:02.020 --> 18:03.020
以外的方法

18:03.020 --> 18:04.020
这个vacmap

18:04.020 --> 18:06.020
它是不能够使用的

18:06.020 --> 18:07.020
然后还有一个就是

18:07.020 --> 18:08.020
最大的不同就是

18:08.020 --> 18:09.020
vacmap

18:09.020 --> 18:10.020
不支持

18:10.020 --> 18:12.020
迭代对象的方法

18:12.020 --> 18:13.020
也就是说

18:13.020 --> 18:14.020
我们刚才迭代对象

18:14.020 --> 18:15.020
我们刚才是不是使用

18:16.020 --> 18:18.020
for一起

18:18.020 --> 18:19.020
对不对

18:19.020 --> 18:20.020
那vacmap

18:20.020 --> 18:22.020
它是不支持的

18:23.020 --> 18:24.020
比如我们这边

18:24.020 --> 18:26.840
我们来试一下

18:28.840 --> 18:30.840
比如说我们这边

18:30.840 --> 18:36.540
vm.for each

18:36.540 --> 18:40.740
然后item

18:40.740 --> 18:41.740
log

18:41.740 --> 18:46.210
item

18:46.210 --> 18:47.210
这爆出

18:47.210 --> 18:48.210
对不对

18:48.210 --> 18:49.210
它是不支持

18:49.210 --> 18:51.210
但是map它就支持

18:51.210 --> 18:53.210
比如说我们这边

18:53.210 --> 18:54.210
我们刚才的

18:56.580 --> 18:57.580
这里

18:57.580 --> 18:58.580
它就支持

18:58.580 --> 18:59.580
比如我们把这个代码

18:59.580 --> 19:05.350
拿过来

19:05.350 --> 19:06.350
我们放到下面

19:06.350 --> 19:10.430
你看它是不是就支持

19:10.430 --> 19:11.430
对不对

19:11.430 --> 19:12.430
for一起

19:12.430 --> 19:14.810
ok

19:14.810 --> 19:16.810
那这就是这个vacmap

19:16.810 --> 19:17.810
然后除开这个以外的话

19:17.810 --> 19:18.810
它其实还有一个

19:18.810 --> 19:19.810
最重要的区别

19:19.810 --> 19:21.810
因为它是弱集合

19:21.810 --> 19:22.810
对不对

19:22.810 --> 19:23.810
这个vac

19:23.810 --> 19:24.810
就是这个vac

19:24.810 --> 19:25.810
vac它是弱

19:25.810 --> 19:27.810
它究竟什么叫做弱呢

19:27.810 --> 19:28.810
你看这里

19:28.810 --> 19:30.810
就是它的引用链接

19:30.810 --> 19:31.810
所指向的数据

19:31.810 --> 19:32.810
对象的连接

19:32.810 --> 19:34.810
它没有map的连接

19:34.810 --> 19:36.810
关系那么强

19:36.810 --> 19:37.810
它是弱的

19:37.810 --> 19:39.810
那它体现在哪里呢

19:39.810 --> 19:40.810
你看这边

19:40.810 --> 19:41.810
第三个差异

19:41.810 --> 19:43.810
当gc

19:43.810 --> 19:45.810
gc就是那个就是拉机

19:45.810 --> 19:47.810
就是那个清理那个拉机的那个

19:47.810 --> 19:49.810
gc叫啥名字来着

19:49.810 --> 19:51.810
那个拉机回收

19:51.810 --> 19:52.810
拉机回收

19:52.810 --> 19:53.810
当那个拉机回收

19:53.810 --> 19:56.810
清理这个引用的时候

19:56.810 --> 19:58.810
这个vacmap

19:58.810 --> 19:59.810
它的这个对象

19:59.810 --> 20:00.810
它就会丢失这个连接

20:00.810 --> 20:01.810
怎么意思

20:01.810 --> 20:02.810
我们来看一下

20:02.810 --> 20:03.810
看这个代码

20:03.810 --> 20:04.810
比如我这边

20:04.810 --> 20:05.810
这边这个jong

20:05.810 --> 20:06.810
jong

20:06.810 --> 20:07.810
它是一个对象

20:07.810 --> 20:08.810
对吧

20:08.810 --> 20:09.810
好然后既然我创建了

20:09.810 --> 20:10.810
两个东西

20:10.810 --> 20:11.810
一个是map

20:11.810 --> 20:12.810
一个是vacmap

20:12.810 --> 20:14.810
然后两个都设置什么呢

20:14.810 --> 20:16.810
map设置这个jong

20:16.810 --> 20:17.810
就是键

20:17.810 --> 20:19.810
键是这个jong

20:19.810 --> 20:20.810
对吧

20:20.810 --> 20:21.810
就是这个对象

20:21.810 --> 20:22.810
对应的值是什么呢

20:22.810 --> 20:23.810
是这个支付串

20:23.810 --> 20:25.810
vacmap我也设置

20:25.810 --> 20:26.810
我也设置

20:26.810 --> 20:28.810
这个键是这个对象

20:28.810 --> 20:29.810
然后值是这个

20:29.810 --> 20:30.810
好然后这样

20:30.810 --> 20:31.810
我这边做了一个很关键的操作

20:31.810 --> 20:33.810
你看我把这个jong

20:33.810 --> 20:34.810
也就是这个对象

20:34.810 --> 20:35.810
我干嘛

20:35.810 --> 20:37.810
我说把它变成空了

20:37.810 --> 20:38.810
对不对

20:38.810 --> 20:39.810
把它变成空了

20:39.810 --> 20:40.810
变成空的话

20:40.810 --> 20:41.810
那你这个map

20:41.810 --> 20:42.810
map的话

20:42.810 --> 20:43.810
由于你这个jong

20:43.810 --> 20:45.810
你是作为一个键

20:45.810 --> 20:47.810
这个键指向这个值的

20:47.810 --> 20:48.810
说到这个map对象

20:48.810 --> 20:51.810
它就会保持引用连接

20:51.810 --> 20:53.810
就会保持这个连接

20:53.810 --> 20:55.810
但是vacmap就不一样

20:55.810 --> 20:56.810
vacmap的话

20:56.810 --> 20:59.810
它就会将这个连接丢失掉

20:59.810 --> 21:00.810
也就是说你这个jong

21:00.810 --> 21:01.810
你这个键

21:01.810 --> 21:02.810
已经变成垃圾了

21:02.810 --> 21:03.810
那你这个的话

21:03.810 --> 21:04.810
找不到了

21:05.810 --> 21:06.810
看到没有

21:06.810 --> 21:07.810
找不到了

21:07.810 --> 21:11.810
说这个使用这个vacmap的时候

21:11.810 --> 21:13.810
要考虑到它这几个差异

21:13.810 --> 21:14.810
一个是这个key

21:14.810 --> 21:15.810
必须是对象

21:15.810 --> 21:16.810
然后并不是

21:16.810 --> 21:18.810
所有map中的方法都支持

21:18.810 --> 21:21.810
还有就是这个

21:21.810 --> 21:24.810
这个gc清理这个引用的时候

21:24.810 --> 21:25.810
数据会被清除

21:25.810 --> 21:26.810
会被删除

21:26.810 --> 21:27.810
OK

21:27.810 --> 21:29.810
这是关于这个map

21:29.810 --> 21:30.810
除干map

21:30.810 --> 21:31.810
然后还有什么

21:31.810 --> 21:32.810
还有一个set

21:32.810 --> 21:33.810
是吧

21:33.810 --> 21:34.810
他刚才还问了这个weekset

21:34.810 --> 21:35.810
所以我们这边

21:35.810 --> 21:38.810
把这set我们也来看一下

21:38.810 --> 21:39.810
set的话

21:39.810 --> 21:41.810
也类似于这个map

21:41.810 --> 21:43.810
但是它对于这个单个值

21:43.810 --> 21:44.810
更有用

21:44.810 --> 21:45.810
比我们这边

21:45.810 --> 21:46.810
我们来看一下

21:46.810 --> 21:48.810
set的这个基本用法

21:48.810 --> 21:49.810
好

21:49.810 --> 21:53.850
来到这边

21:53.850 --> 22:01.910
这里set基本用法

22:01.910 --> 22:02.910
好

22:02.910 --> 22:03.910
首先的话

22:03.910 --> 22:04.910
创建一个set

22:04.910 --> 22:07.910
那这边ys等于一个new

22:07.910 --> 22:09.910
set

22:09.910 --> 22:10.910
好

22:10.910 --> 22:11.910
然后接下来的话

22:11.910 --> 22:13.910
你往里面添加这个值

22:13.910 --> 22:14.910
它就是什么呢

22:14.910 --> 22:17.910
它就是s点通过and的方法

22:17.910 --> 22:18.910
刚才那个map

22:18.910 --> 22:19.910
是通过set方法

22:19.910 --> 22:20.910
对吧

22:20.910 --> 22:22.910
这个的话它是通过and的方法

22:22.910 --> 22:24.910
我这边添加一个123

22:24.910 --> 22:25.910
我们把添加之前

22:25.910 --> 22:26.910
和添加之后

22:26.910 --> 22:27.910
我们都打印出来看一下

22:27.910 --> 22:28.910
就是添加之前

22:28.910 --> 22:29.910
是吧

22:29.910 --> 22:30.910
好

22:30.910 --> 22:31.910
然后接下来

22:31.910 --> 22:32.910
这边是添加之后

22:32.910 --> 22:35.910
好走

22:35.910 --> 22:36.910
你看添加之前是不空的

22:36.910 --> 22:38.910
添加之后是这个

22:38.910 --> 22:39.910
这边就有值了

22:39.910 --> 22:41.910
它建值都是一样的

22:41.910 --> 22:42.910
所以这边的建和值

22:42.910 --> 22:44.910
都是这个123

22:44.910 --> 22:45.910
好

22:45.910 --> 22:47.910
然后set有个很大的特点

22:47.910 --> 22:50.910
set就是不允许

22:50.910 --> 22:59.820
不允许添加相同的值

22:59.820 --> 23:00.820
比如说你看我这边

23:00.820 --> 23:03.820
我这边s点and

23:03.820 --> 23:05.820
我再来一个123

23:05.820 --> 23:08.820
然后接下我们这边log一下

23:08.820 --> 23:09.820
logs

23:09.820 --> 23:10.820
走

23:10.820 --> 23:11.820
你看

23:11.820 --> 23:12.820
是不是真正是123

23:12.820 --> 23:13.820
对

23:13.820 --> 23:14.820
它就不会说

23:14.820 --> 23:15.820
两个123123

23:15.820 --> 23:17.820
不会

23:17.820 --> 23:19.820
然后接下来这个set的话

23:19.820 --> 23:20.820
还可以什么呢

23:20.820 --> 23:21.820
还可以通过这个

23:21.820 --> 23:23.820
一为数组来进行初始化

23:23.820 --> 23:24.820
比如说我们这边

23:24.820 --> 23:29.800
我们这边来一个数组

23:29.800 --> 23:30.800
挖一个ar

23:30.800 --> 23:34.800
等于一个1234567

23:34.800 --> 23:35.800
好

23:35.800 --> 23:36.800
那接下来你这边

23:36.800 --> 23:40.800
挖一个s等于一个NewSet

23:40.800 --> 23:41.800
那你就可以干嘛呢

23:41.800 --> 23:43.800
就可以把这个一为数组

23:43.800 --> 23:44.800
传进去

23:44.800 --> 23:45.800
传进去之后

23:45.800 --> 23:47.800
然后去让我们这边log一下

23:47.800 --> 23:48.800
也是

23:48.800 --> 23:49.800
走

23:49.800 --> 23:50.800
看到没有

23:50.800 --> 23:51.800
它是不是就成功的

23:51.800 --> 23:54.800
生成了一个set

23:54.800 --> 23:55.800
并且这个值

23:55.800 --> 23:58.800
是你的这个一为数组的这个值

23:58.800 --> 23:59.800
对不对

23:59.800 --> 24:00.800
好

24:00.800 --> 24:01.800
那这边的话

24:01.800 --> 24:02.800
它可以通过数组初始化

24:02.800 --> 24:04.800
然后它又有个特点叫做什么呢

24:04.800 --> 24:06.800
不允许添加相同的值

24:06.800 --> 24:08.800
那通过这个

24:08.800 --> 24:09.800
两个一组合

24:09.800 --> 24:10.800
那我们就可以干嘛呢

24:10.800 --> 24:12.800
我们就可以快速的

24:12.800 --> 24:14.800
给数组驱从

24:14.800 --> 24:17.800
利用set

24:17.800 --> 24:18.800
你数有这个

24:18.800 --> 24:19.800
现在用的很多用

24:19.800 --> 24:21.800
就是给数组驱从

24:21.800 --> 24:23.800
利用这个set

24:23.800 --> 24:30.800
快速来为数组驱从

24:30.800 --> 24:32.800
就驱除重复值

24:32.800 --> 24:33.800
就很方便

24:33.800 --> 24:34.800
比如说我们这边

24:34.800 --> 24:37.800
我们来挖一个ar

24:37.800 --> 24:38.800
等于一个

24:38.800 --> 24:51.800
比如说1224335214526

24:51.800 --> 24:52.800
你看我这边

24:52.800 --> 24:53.800
这边是不是有很多的

24:53.800 --> 24:55.800
这个重复的这个值

24:55.800 --> 24:56.800
对不对

24:56.800 --> 24:57.800
那我现在要驱从

24:57.800 --> 24:58.800
怎么去呢

24:58.800 --> 24:59.800
那很简单

24:59.800 --> 25:02.800
我挖一个ar2

25:02.800 --> 25:03.800
那这个的话

25:03.800 --> 25:05.800
就是存放我的这个驱从之后的

25:05.800 --> 25:06.800
那等于一个什么呢

25:06.800 --> 25:07.800
等于一个这边

25:07.800 --> 25:10.800
我们首先扭一个set

25:10.800 --> 25:11.800
扭一个set

25:11.800 --> 25:14.800
然后再把这个ar2传进去

25:14.800 --> 25:15.800
ar2传进去

25:15.800 --> 25:17.800
那这边是不是就是这块

25:17.800 --> 25:19.800
这块它又不允许

25:19.800 --> 25:20.800
有这个重复值

25:20.800 --> 25:21.800
我们这边这样子

25:21.800 --> 25:23.800
我们一步一步来

25:23.800 --> 25:25.800
这边我们log一下

25:25.800 --> 25:32.030
console.log

25:32.030 --> 25:33.030
你看那这个set里面

25:33.030 --> 25:35.030
是不是124356

25:35.030 --> 25:37.030
是不是就是没有重复的

25:37.030 --> 25:38.030
对不对

25:38.030 --> 25:39.030
好了回头

25:39.030 --> 25:40.030
我把这个干嘛呢

25:40.030 --> 25:42.030
我再重新把它转成一个数组

25:42.030 --> 25:44.030
那这边你就可以通过什么呢

25:44.030 --> 25:46.030
可以通过这个展开运算幅

25:46.030 --> 25:51.030
这边你就可以直接点点点

25:51.030 --> 25:53.030
展开运算幅

25:53.030 --> 25:55.030
重新把它展成什么

25:55.030 --> 25:57.030
这边的话就是点点点

25:57.030 --> 26:01.690
再加一个这个数组的符号

26:01.690 --> 26:02.690
这边

26:02.690 --> 26:04.690
重新把它转成一个什么

26:04.690 --> 26:06.690
就重新转成一个数组

26:06.690 --> 26:07.690
看到没有

26:07.690 --> 26:08.690
那你这边

26:08.690 --> 26:10.690
其实就可以这个样子

26:10.690 --> 26:13.690
就快速的是不是给这个set

26:13.690 --> 26:14.690
去重了

26:14.690 --> 26:15.690
不不不

26:15.690 --> 26:17.690
给这个数组是去重了

26:17.690 --> 26:18.690
对不对

26:18.690 --> 26:19.690
那你这边就可以

26:19.690 --> 26:20.690
A2

26:20.690 --> 26:22.690
等于这个

26:22.690 --> 26:24.690
你看一行代码就搞定了

26:24.690 --> 26:26.690
快速为数组去重了

26:26.690 --> 26:27.690
以前的话

26:27.690 --> 26:28.690
还得自己去便利

26:28.690 --> 26:30.690
然后比较各种各样的

26:30.690 --> 26:31.690
非常的麻烦

26:31.690 --> 26:32.690
那现在的话

26:32.690 --> 26:34.690
直接这样子写就ok了

26:34.690 --> 26:36.690
这是这个set

26:36.690 --> 26:38.690
它的一个应用场景

26:39.690 --> 26:41.690
然后set还有一些其他的

26:41.690 --> 26:42.690
比如这边

26:42.690 --> 26:43.690
它是可迭代的

26:43.690 --> 26:45.690
所以你可以这样子来便利它

26:45.690 --> 26:46.690
比如说我们这边

26:50.700 --> 26:51.700
比如说我们就把这个

26:51.700 --> 26:53.700
就把这个set拉过来

26:53.700 --> 26:58.810
上面这个注射了

26:58.810 --> 27:00.810
这边你是可以便利的

27:00.810 --> 27:02.810
还是通过这个

27:03.810 --> 27:05.810
挖一个i

27:05.810 --> 27:07.810
off这个s

27:08.810 --> 27:10.810
然后加这边log一下

27:11.810 --> 27:14.820
看到没有

27:14.820 --> 27:16.820
或者通过for一起

27:16.820 --> 27:18.820
这个我就不写了

27:18.820 --> 27:19.820
然后还有就是这个删除

27:19.820 --> 27:21.820
通过delete

27:21.820 --> 27:22.820
来进行删除

27:22.820 --> 27:23.820
或者通过什么

27:23.820 --> 27:24.820
通过clear

27:25.820 --> 27:26.820
通过clear

27:26.820 --> 27:28.820
clear就全部清除掉

27:28.820 --> 27:32.200
比如说我们这边我们来看一下

27:32.200 --> 27:33.200
比如说我现在的话

27:33.200 --> 27:35.200
这边s

27:36.200 --> 27:37.200
我调什么呢

27:37.200 --> 27:38.200
调delete

27:39.200 --> 27:40.200
删除什么呢

27:40.200 --> 27:41.200
删除1

27:41.200 --> 27:42.200
对吧

27:42.200 --> 27:43.200
它本身会返回一个什么呢

27:43.200 --> 27:44.200
会返回

27:44.200 --> 27:45.200
删除成功还是失败

27:45.200 --> 27:47.200
就是会返回一个布尔茲

27:47.200 --> 27:49.200
比如我们这边log

27:49.200 --> 27:51.200
然后这边走

27:51.200 --> 27:52.200
这边一个去

27:52.200 --> 27:53.200
代表什么

27:53.200 --> 27:54.200
删除成功

27:54.200 --> 27:56.200
然后接下来这边log一下

27:56.200 --> 27:58.200
log一下s

27:58.200 --> 27:59.200
看到没有

27:59.200 --> 28:01.200
这不只有234567

28:02.200 --> 28:03.200
对不对

28:03.200 --> 28:04.200
然后还有一个方法

28:04.200 --> 28:06.200
还有一个方法叫做clear

28:06.200 --> 28:08.200
clear就是清空

28:08.200 --> 28:10.200
然后接下来这边你看一下

28:10.200 --> 28:11.200
logs

28:14.860 --> 28:15.860
这就空了

28:15.860 --> 28:16.860
对不对

28:16.860 --> 28:17.860
就空了

28:18.860 --> 28:20.860
这是关于set

28:20.860 --> 28:22.860
它的一个基本的使用

28:23.860 --> 28:25.860
然后这边有一些应用场景

28:25.860 --> 28:28.860
应用场景其实主要就是利用到什么呢

28:28.860 --> 28:30.860
利用到set我们刚刚说的

28:30.860 --> 28:32.860
它是不是不能存储相同的值

28:32.860 --> 28:33.860
对不对

28:33.860 --> 28:34.860
那你看首先

28:34.860 --> 28:35.860
第一个应用场景就是什么

28:35.860 --> 28:37.860
第一个就是驱虫

28:37.860 --> 28:38.860
看到没有

28:38.860 --> 28:39.860
驱虫

28:39.860 --> 28:40.860
除了驱虫以外

28:40.860 --> 28:41.860
这样还可以干嘛呢

28:41.860 --> 28:42.860
还可以比如说

28:42.860 --> 28:43.860
求这个并计

28:43.860 --> 28:45.860
给我们来看一下

28:45.860 --> 28:48.860
比如这边123234

28:48.860 --> 28:51.860
我要求他们的并计

28:51.860 --> 28:56.060
什么叫做并计

28:56.060 --> 28:58.060
所谓并计的话就是什么呢

28:58.060 --> 29:00.060
就是这边就是你这个

29:00.060 --> 29:01.060
比如这个集合

29:01.060 --> 29:02.060
和这个集合

29:02.060 --> 29:04.060
所有的元素

29:04.060 --> 29:05.060
对不对

29:05.060 --> 29:06.060
就是并计

29:06.060 --> 29:07.060
这个并计怎么做呢

29:07.060 --> 29:08.060
你看一下

29:08.060 --> 29:09.060
这边的话就是

29:09.060 --> 29:11.060
首先这边点点点AR1

29:11.060 --> 29:13.060
点点点AR2

29:13.060 --> 29:15.060
两个放在一起

29:15.060 --> 29:16.060
放在一起之后

29:16.060 --> 29:17.060
然后接下来干嘛呢

29:17.060 --> 29:19.060
把重复的去掉

29:19.060 --> 29:20.060
通过这个set

29:20.060 --> 29:21.060
把重复的去掉

29:21.060 --> 29:22.060
因为你现在的话

29:22.060 --> 29:24.060
你这边点点点AR1

29:24.060 --> 29:25.060
点点点AR2

29:25.060 --> 29:26.060
然后组成新的数组

29:26.060 --> 29:27.060
新的数组就是什么

29:27.060 --> 29:29.060
就是123234

29:29.060 --> 29:31.060
是不是里面有重复的

29:31.060 --> 29:32.060
有重复的

29:32.060 --> 29:33.060
然后通过这个newset

29:33.060 --> 29:35.060
把重复的把它去掉

29:35.060 --> 29:36.060
去掉之后

29:36.060 --> 29:38.060
然后接下来再重新把它

29:38.060 --> 29:39.060
还原成数组

29:39.060 --> 29:42.630
我们这边我们把这个看一下

29:42.630 --> 29:43.630
来到这边

29:43.630 --> 29:47.780
把这个注释掉

29:47.780 --> 29:48.780
然后最终

29:48.780 --> 29:50.780
这边打印一下嘛

29:50.780 --> 29:52.780
log

29:52.780 --> 29:56.780
log一下这个new

29:56.780 --> 30:01.980
load index

30:01.980 --> 30:02.980
看了没有

30:02.980 --> 30:03.980
这不1234

30:03.980 --> 30:04.980
是不是这个就是

30:04.980 --> 30:05.980
我这两个的并计啊

30:05.980 --> 30:06.980
对不对

30:06.980 --> 30:07.980
首先你要搞清楚

30:07.980 --> 30:08.980
这个并计的概念

30:08.980 --> 30:10.980
所谓并计就是

30:10.980 --> 30:11.980
A这个集合

30:11.980 --> 30:12.980
和这个

30:12.980 --> 30:13.980
就是所有A里面的元素

30:13.980 --> 30:15.980
和所有B里面的元素

30:15.980 --> 30:17.980
这个就叫做他们的并计

30:17.980 --> 30:18.980
好

30:18.980 --> 30:19.980
然后还可以干嘛呢

30:19.980 --> 30:21.980
还可以求这个交集

30:21.980 --> 30:22.980
还可以求交集

30:22.980 --> 30:23.980
我们来看一下

30:23.980 --> 30:24.980
怎么求交集

30:24.980 --> 30:25.980
什么叫交集

30:25.980 --> 30:26.980
交集就是他们俩

30:26.980 --> 30:27.980
是不是相同的这个元素

30:27.980 --> 30:28.980
比如这两个交集

30:28.980 --> 30:30.980
是不是应该是23

30:30.980 --> 30:32.980
23是不是两个集合都有

30:32.980 --> 30:33.980
对不对

30:33.980 --> 30:34.980
好那这样我们这边

30:34.980 --> 30:35.980
我们来看一下

30:35.980 --> 30:36.980
首先的话

30:36.980 --> 30:37.980
这边的话就是

30:37.980 --> 30:41.980
把A1转成这个set集合

30:41.980 --> 30:42.980
这个变成set集合

30:42.980 --> 30:44.980
然后加这边一个空数组

30:44.980 --> 30:46.980
好然后接下来去便利

30:46.980 --> 30:47.980
第1个这个集合

30:47.980 --> 30:49.980
然后看这个第2个集合

30:49.980 --> 30:50.980
是否有

30:50.980 --> 30:51.980
看它是否有

30:51.980 --> 30:53.980
如果这个有

30:53.980 --> 30:55.980
就把它推入到什么呢

30:55.980 --> 30:56.980
推入到这个

30:56.980 --> 30:58.980
新的数组里面

30:58.980 --> 30:59.980
看了没有

30:59.980 --> 31:01.980
否则就是一个这个空

31:01.980 --> 31:02.980
那我们这边我们来看一下

31:02.980 --> 31:11.390
这边是这个是并计

31:11.390 --> 31:15.820
并计

31:15.820 --> 31:17.820
下面一个是交集

31:17.820 --> 31:23.580
ok

31:23.580 --> 31:25.580
好然后走

31:25.580 --> 31:26.580
看了没有

31:26.580 --> 31:27.580
是不是23

31:27.580 --> 31:28.580
对不对

31:28.580 --> 31:29.580
那这个代码也很简单

31:29.580 --> 31:32.580
这边就是先转成两个集合

31:32.580 --> 31:34.580
再下去便利第1个集合

31:34.580 --> 31:35.580
便利第1个集合

31:35.580 --> 31:36.580
取出第1个集合的每一项

31:36.580 --> 31:38.580
然后看第2个集合是否有

31:38.580 --> 31:40.580
如果有我就干嘛呢

31:40.580 --> 31:42.580
我就把它推入进去

31:42.580 --> 31:44.580
那这个的话其实

31:44.580 --> 31:47.580
不用集合好像

31:47.580 --> 31:49.580
但用集合要方便一点

31:49.580 --> 31:50.580
用集合我是不是这边

31:50.580 --> 31:51.580
要判断他有没有的时候

31:51.580 --> 31:52.580
是不是直接

31:52.580 --> 31:53.580
调用这个has方法

31:53.580 --> 31:54.580
是不是就可以了

31:54.580 --> 31:55.580
对不对

31:55.580 --> 31:57.580
转成集合要方便一些

31:57.580 --> 31:59.580
但你不用集合也可以

31:59.580 --> 32:00.580
你是不是就是

32:00.580 --> 32:01.580
双重迫雄狂去便利

32:01.580 --> 32:03.580
这个这两个宿主啊

32:03.580 --> 32:05.580
对不对

32:05.580 --> 32:07.580
还有些其他的应用啊

32:07.580 --> 32:08.580
插击

32:08.580 --> 32:09.580
这边还有插击

32:09.580 --> 32:11.580
下去可以看一下

32:11.580 --> 32:12.580
好最后我们说一下

32:12.580 --> 32:14.580
这个关于这个week sit

32:14.580 --> 32:16.580
week sit

32:16.580 --> 32:17.580
那刚才的话

32:17.580 --> 32:19.580
我们讲了那个week map

32:19.580 --> 32:21.580
你理解了这个week map之后

32:21.580 --> 32:22.580
你再来看这个week sit

32:22.580 --> 32:24.580
那基本就是一样的

32:24.580 --> 32:25.580
那前面是不是也是

32:25.580 --> 32:26.580
有一个week

32:27.580 --> 32:28.580
对不对

32:29.580 --> 32:30.580
好那我们这边看一下

32:30.580 --> 32:33.580
week sit和set的区别在于

32:33.580 --> 32:35.580
week sit只能存储

32:35.580 --> 32:37.580
对象引用

32:37.580 --> 32:38.580
这个和刚才那个week map

32:38.580 --> 32:39.580
是一样的

32:39.580 --> 32:40.580
对吧

32:40.580 --> 32:41.580
不能存放值

32:41.580 --> 32:42.580
好第二个就是什么呢

32:42.580 --> 32:44.580
week对象中存储的这个

32:44.580 --> 32:45.580
对象值都是什么

32:45.580 --> 32:47.580
都是若引用

32:47.580 --> 32:48.580
都是若引用

32:48.580 --> 32:50.580
那和刚才那个week map

32:50.580 --> 32:51.580
也是一样的

32:51.580 --> 32:53.580
所以你只要理解了week map

32:53.580 --> 32:54.580
那这边week sit

32:54.580 --> 32:55.580
就和他一样的

32:55.580 --> 32:57.580
他反正就是体现在一个什么呢

32:57.580 --> 32:58.580
就是弱值

32:58.580 --> 32:59.580
对不对

32:59.580 --> 33:00.580
他是一个弱引用

33:00.580 --> 33:02.580
然后week sit

33:02.580 --> 33:03.580
能够使用的方法

33:03.580 --> 33:07.580
有这些and delete has clear

33:08.580 --> 33:10.580
然后他和week map一样

33:10.580 --> 33:12.580
week sit也将丢失

33:12.580 --> 33:14.580
这个对内部数据的访问链接

33:14.580 --> 33:15.580
我们来看一下

33:15.580 --> 33:16.580
看一下

33:16.580 --> 33:17.580
这边还是这个例子

33:17.580 --> 33:18.580
这边做

33:18.580 --> 33:19.580
做他是一个这个对象

33:19.580 --> 33:20.580
对吧

33:20.580 --> 33:22.580
创建了两个set集合

33:22.580 --> 33:23.580
一个是set

33:23.580 --> 33:24.580
一个是week sit

33:25.580 --> 33:26.580
好

33:26.580 --> 33:27.580
然后接下来这边

33:27.580 --> 33:28.580
这边的话把这个set

33:28.580 --> 33:29.580
把这个jo

33:29.580 --> 33:30.580
添加进去

33:30.580 --> 33:31.580
然后week sit也把这个jo

33:31.580 --> 33:32.580
添加进去

33:32.580 --> 33:33.580
好

33:33.580 --> 33:34.580
然后接下来把这个

33:34.580 --> 33:35.580
什么呢

33:35.580 --> 33:36.580
把这个对象

33:36.580 --> 33:37.580
这个

33:37.580 --> 33:38.580
是不是清空了

33:38.580 --> 33:39.580
对不对

33:39.580 --> 33:41.580
你把这个对象清空

33:41.580 --> 33:43.580
他就会被这个

33:43.580 --> 33:45.580
拉机回收机

33:45.580 --> 33:46.580
就会回收

33:46.580 --> 33:47.580
回收之后

33:47.580 --> 33:48.580
然后即让他被回收

33:48.580 --> 33:50.580
让我们的这个week sit

33:50.580 --> 33:52.580
他就无法再去

33:52.580 --> 33:54.580
访问这个jo

33:54.580 --> 33:55.580
这个数据

33:57.580 --> 33:58.580
然后这个week sit

33:58.580 --> 34:00.580
他也不支持425和417

34:00.580 --> 34:01.580
他们不可迭代

34:01.580 --> 34:03.580
这点和那个week map

34:03.580 --> 34:04.580
是不是也是一样的

34:04.580 --> 34:05.580
对不对

34:05.580 --> 34:06.580
所以他基本就是

34:06.580 --> 34:08.580
和那个week map一模一样

34:08.580 --> 34:09.580
好

34:09.580 --> 34:11.580
最后最后的话就是

34:11.580 --> 34:12.580
比较总结

34:12.580 --> 34:14.580
大家可以把这个看一下

34:14.580 --> 34:15.580
就是map

34:15.580 --> 34:17.580
他有什么样的特点

34:17.580 --> 34:18.580
在这个位置

34:18.580 --> 34:20.580
比如说建民唯一

34:20.580 --> 34:21.580
不可重复

34:21.580 --> 34:22.580
类似于集合

34:22.580 --> 34:23.580
然后里面的那个

34:23.580 --> 34:25.580
建可以为什么

34:25.580 --> 34:26.580
是不是任意值

34:26.580 --> 34:27.580
可以便利

34:27.580 --> 34:29.580
可以转换各种数据内格式

34:29.580 --> 34:30.580
方法的话

34:30.580 --> 34:31.580
有这么一些

34:33.580 --> 34:34.580
week map

34:34.580 --> 34:35.580
他就是什么

34:35.580 --> 34:36.580
是不是弱

34:36.580 --> 34:37.580
对不对

34:37.580 --> 34:38.580
主要是体现在一个弱子

34:38.580 --> 34:39.580
他哪里弱

34:39.580 --> 34:41.580
就是你这边

34:41.580 --> 34:43.580
如果就是引用了那个对象

34:43.580 --> 34:45.580
就是你的建

34:45.580 --> 34:47.580
建民所指向的对象

34:47.580 --> 34:48.580
如果丢射的话

34:48.580 --> 34:49.580
他会就是

34:49.580 --> 34:51.580
对那个值

34:51.580 --> 34:53.580
他就找不到了

34:53.580 --> 34:54.580
对不对

34:54.580 --> 34:55.580
他就找不到了

34:55.580 --> 34:57.580
然后这里不能便利

34:57.580 --> 34:59.580
方法有这么一些

34:59.580 --> 35:00.580
好

35:00.580 --> 35:01.580
然后接下来这个set

35:01.580 --> 35:02.580
set最大的特点就是什么呢

35:02.580 --> 35:04.580
成员唯一

35:04.580 --> 35:06.580
这个其实是这个set集合

35:06.580 --> 35:07.580
最大的一个特点

35:07.580 --> 35:09.580
我们经常其实是拿这个set

35:09.580 --> 35:10.580
来做一些

35:10.580 --> 35:12.580
就是和数组相关的操作

35:12.580 --> 35:14.580
经常比如驱虫

35:14.580 --> 35:15.580
比如刚才大家看到的

35:15.580 --> 35:17.580
取交集并级

35:17.580 --> 35:19.580
经常是拿来做这种操作

35:19.580 --> 35:21.580
然后还有就是weekset

35:21.580 --> 35:22.580
weekset的话

35:22.580 --> 35:23.580
它就是一个

35:23.580 --> 35:26.580
也是这个弱引用版本的set

35:26.580 --> 35:27.580
对不对

35:27.580 --> 35:28.580
成员都是什么呢

35:28.580 --> 35:30.580
都是弱引用

35:31.580 --> 35:33.580
最后来看一下这个整体解答

35:33.580 --> 35:37.580
是否了解weekmap和weekset

35:37.580 --> 35:39.580
weekset对象

35:39.580 --> 35:40.580
是一些对象值的

35:40.580 --> 35:42.580
是对象值

35:42.580 --> 35:44.580
刚才是不是这个week

35:44.580 --> 35:45.580
weekset

35:45.580 --> 35:46.580
我们这边说了

35:46.580 --> 35:47.580
它只能存储什么

35:47.580 --> 35:48.580
只能存储对象

35:48.580 --> 35:50.580
和那个weekmap是一样的

35:50.580 --> 35:52.580
weekmap它的那个键

35:52.580 --> 35:54.580
是不是也是只能存对象

35:54.580 --> 35:56.960
对吧

35:56.960 --> 35:58.960
它是一些对象值的集合

35:58.960 --> 36:01.960
然后每个对象值只能出现一次

36:01.960 --> 36:03.960
它和set的区别

36:03.960 --> 36:05.960
这里就是区别

36:05.960 --> 36:07.960
它只能存对象的集合

36:07.960 --> 36:08.960
并且它是什么

36:08.960 --> 36:09.960
弱引用

36:09.960 --> 36:10.960
对不对

36:10.960 --> 36:11.960
大家weekmap

36:11.960 --> 36:12.960
weekmap的话

36:12.960 --> 36:15.960
对象它也是键值的集合

36:15.960 --> 36:16.960
但是键必须是什么

36:16.960 --> 36:18.960
是不是对象类型

36:18.960 --> 36:19.960
对不对

36:19.960 --> 36:20.960
它首先是

36:20.960 --> 36:21.960
这个是第一个区别

36:21.960 --> 36:22.960
第二个就是什么

36:22.960 --> 36:23.960
它是不是也是

36:23.960 --> 36:24.960
就是弱连接

36:24.960 --> 36:25.960
对不对

36:25.960 --> 36:26.960
是弱连接

36:26.960 --> 36:27.960
而且还有什么

36:27.960 --> 36:28.960
就是不可没举

36:28.960 --> 36:31.960
就是weekmap和weekset

36:31.960 --> 36:32.960
它们都是什么

36:32.960 --> 36:33.960
都是不可没举的

36:33.960 --> 36:35.960
你用那个for一起方法

36:35.960 --> 36:36.960
是不行的

36:36.960 --> 36:37.960
对吧

36:37.960 --> 36:42.960
这就是关于weekset和weekmap

36:42.960 --> 36:43.960
大家下来的话

36:43.960 --> 36:44.960
可以再把这一块

36:44.960 --> 36:45.960
再把它看一看

36:45.960 --> 36:46.960
好吧

36:46.960 --> 36:47.960
这一块就先到这里

36:47.960 --> 36:48.960
拜拜

