WEBVTT

00:01.070 --> 00:03.110
大家好 我是谢老师

00:03.370 --> 00:06.690
这节课我们来看一下接式里面的值和引用

00:06.950 --> 00:10.290
这里的话有一道经典的面试题

00:10.550 --> 00:13.350
接式的基本数据类型有哪些

00:13.870 --> 00:17.190
基本数据类型和引用数据类型的区别

00:17.450 --> 00:20.010
这是面试中比较爱问的一道题

00:20.790 --> 00:24.110
主要就是考察什么呢 考察就是你的接式基础

00:24.630 --> 00:25.390
那我们来看一下

00:25.910 --> 00:27.690
在我们的接式里面

00:27.950 --> 00:30.510
数据类型的话其实可以分为两大类

00:30.670 --> 00:33.330
哪两大类呢 一个是基本类型

00:33.590 --> 00:35.370
一个是引用类型

00:35.890 --> 00:37.170
基本类型的话有六种

00:37.670 --> 00:38.450
Stream

00:38.710 --> 00:39.470
Symbol

00:39.730 --> 00:40.230
Lumber

00:40.490 --> 00:41.010
Bulling

00:41.270 --> 00:42.030
Undify

00:42.290 --> 00:43.050
和Null

00:43.830 --> 00:46.130
然后Symbol也是有新增加的嘛

00:46.390 --> 00:49.190
然后这个引用类型 引用类型的话就只有什么呢

00:49.450 --> 00:50.730
只有Object

00:51.250 --> 00:52.790
包含你比如说什么

00:53.050 --> 00:56.110
Aurace数组 他最终打印这个类型的时候是不是也是

00:56.370 --> 00:56.870
Object

00:57.910 --> 01:00.210
那两者之间有什么区别呢 我们来看一下

01:00.710 --> 01:04.050
而基本数据类型的话 他又被称之为简单值

01:04.310 --> 01:05.830
或者原始值

01:06.090 --> 01:07.370
你要知道他指的都是

01:07.630 --> 01:08.650
基本数据类型

01:08.910 --> 01:10.710
他是这个接式中

01:10.970 --> 01:12.490
最底层的

01:12.750 --> 01:14.550
或者最简单的形式

01:14.810 --> 01:19.910
他为什么被称之为简单值呢 原因很简单 就是他不可再细化了

01:20.430 --> 01:22.210
你没办法再往下面分了

01:22.470 --> 01:24.990
啊 比方你数字 数字比如说我生命一个

01:25.250 --> 01:26.070
比如说我这边

01:26.330 --> 01:28.370
我挖一个i 等于一个e

01:28.570 --> 01:30.630
那你还有没有办法把他往下分啊

01:30.890 --> 01:33.690
你没有必要 没有办法把它再往下分的

01:33.950 --> 01:35.750
对不对 这个就是已经是最小单位了

01:37.030 --> 01:38.310
包括这个

01:39.070 --> 01:41.630
这里有布尔泽 就是True和False

01:41.890 --> 01:44.450
Null和Nd5 就是Null和Nd5

01:44.710 --> 01:45.730
你没办法拆分的

01:45.990 --> 01:48.810
不可再细化 不可再进行拆分

01:49.070 --> 01:50.850
所以他被称之为简单值

01:51.110 --> 01:52.130
或者原始值

01:52.890 --> 01:55.710
好 然后我们的基本数据类型 他是存储在哪里呢

01:56.010 --> 01:58.990
他是存储在内存中的占区的

01:59.750 --> 02:03.590
我们知道我们的内存分为这个占区和堆区

02:04.870 --> 02:08.210
我们的这个基本数据类型 他就是存储在这个占区

02:08.470 --> 02:10.630
占区有个特点 什么特点呢

02:10.890 --> 02:14.870
就是先进后出 后进先出

02:15.130 --> 02:16.910
比如说你看他就像这个

02:17.170 --> 02:18.450
这个乒乓球盒子一样

02:18.710 --> 02:20.750
乒乓球盒子是不是只有一个出口

02:21.010 --> 02:21.770
在这个位置

02:22.290 --> 02:25.110
好 让我最先放进去的这个1号球

02:26.430 --> 02:28.990
你最先放进去 是不是最后才拿得出来

02:29.750 --> 02:32.570
然后既然你最后放进去的这个5号球

02:32.830 --> 02:35.650
你最后放进去 是不是最先就可以拿出来

02:36.150 --> 02:39.230
对不对 点心那就是比如我们用那个吗 用那个函数

02:39.490 --> 02:40.250
来举例

02:40.510 --> 02:41.790
比如说我们这边

02:42.050 --> 02:43.590
方形A

02:45.110 --> 02:46.650
这里有一个A函数

02:47.930 --> 02:51.510
A函数里面我又调用了什么呢 我又调用了这个B函数

02:53.790 --> 02:55.070
调用B函数

02:55.270 --> 02:57.330
然后B函数里面我又调用了什么呢

02:57.590 --> 02:59.630
我又调用了这个C函数

03:00.390 --> 03:04.230
那他这边是什么样子呢 他这边首先是在这个全局

03:04.490 --> 03:05.770
有一个这个全局环境

03:06.030 --> 03:07.310
这边给大家换一下

03:09.900 --> 03:11.700
就是这边 首先的话在

03:12.720 --> 03:14.520
首先的话在这个最底部

03:16.040 --> 03:17.600
这个是我们的这个全局

03:18.360 --> 03:22.960
全局上下文 全局上下文之后再加这边他发现你这个调这个A函数

03:23.220 --> 03:26.300
A函数的价是不是会有一个这个函数上下文

03:26.680 --> 03:28.560
对不对 那既然这边会有一个这个A

03:29.580 --> 03:30.860
啊 这个是Globo啊

03:31.620 --> 03:32.900
这个是Globo

03:34.100 --> 03:37.380
Globo啊 我这边不太好写字哈 我就写慢一点

03:37.940 --> 03:43.940
Globo 好人家这边A A的话 然后既然他这边的话调用B 调用B是不是又会开启一个这个B的

03:45.060 --> 03:50.220
这个上下文 对不对 然后B里面又调用什么呢 又调用C啊 这边调用一下C

03:52.750 --> 03:57.910
好 这边就是C 看到没有 他就是这个样子了 好那既然是不是就是执行这个C里面的这个弹法

03:58.950 --> 04:06.630
对不对 挨着挨着执行 挨着挨着执行之后 然后既然这边执行完之后 然后这样这个C他是不是就出战了

04:07.670 --> 04:13.190
对不对 就弹出去了 然后既然来到哪里 来到B 来到B 然后既然执行这个B函数里面的这个

04:13.550 --> 04:13.830
代码

04:14.910 --> 04:19.310
执行这个B函数里面的代码 执行完之后 然后加这个B是不是也就弹出去了

04:20.110 --> 04:26.030
对不对 来到这个A 执行完之后 然后加A也会干嘛 A是不是也会弹出去

04:26.670 --> 04:33.110
对不对 你看 最先进来的是不是最后才出去 看到没有 这个的话就是这个站的这个特点

04:33.630 --> 04:37.710
这个我们在讲那个 后面讲那个执行商项文的时候 我们还会说这个事情

04:40.110 --> 04:48.480
把这个消除了 好 这是关于这个站 我们的基本数据类型就是存储在站区的

04:49.480 --> 04:56.160
好 然后接下来这边 这边有一些就是声明这个基本数据的一些势力

04:56.560 --> 05:02.720
我声明了一个制服创 是吧 然后一个这个数字 一个布尔兹 一个NOW 一个Undify

05:03.320 --> 05:06.440
好 这里唯独要注意什么呢 唯独要注意这个NOW

05:07.280 --> 05:12.400
你看这边 声明了一个minel 等于一个这个NOW 然后再通过这个type of

05:13.480 --> 05:17.440
来访问它的类型的时候 你会发现它这边打印出来的是什么呀

05:18.920 --> 05:20.760
打印出来的时候是object

05:21.760 --> 05:28.920
对不对 为什么是object 呢 原因很简单 这是由于历史原因遗留下来的

05:29.400 --> 05:35.480
它是从第一个版本开始的一个bug 它究竟是什么bug呢 就是我们知道所有的数据

05:35.880 --> 05:42.320
无论你什么数据 最终它在内存里面 它都是以什么来存储啊 是不是都是以二镜子来存储

05:43.560 --> 05:50.280
对不对 那么在解释里面 他判断这个数据类型的时候 他是怎么来判断的 他是判断你的这个前三位

05:50.960 --> 05:59.640
是否为零 这个就是他底层判断了 判断你前三位是否为零 如果为零他认为你就是一个object

06:00.960 --> 06:07.480
然后接下来 你的这个NOW的话 因为是空嘛 就没有嘛 所以他的二镜子他全部都是零

06:08.600 --> 06:12.400
全部为零 那全部为零的话 他自然而然他前三位是不是也是零

06:13.000 --> 06:16.520
所以你这边type of的话 他会返回这个object

06:17.240 --> 06:23.040
明白没有 就是因为他这个底层判断的时候 他通过判断前三位是否为零

06:23.920 --> 06:30.800
来决定你是否是对象 结果呢 你这个NOW啊全部都为零 所以前三位也是零

06:31.320 --> 06:33.400
所以他判了出来也是一个object

06:34.200 --> 06:39.160
但这个时候有的同学就会说 那你这个bug你为什么不修复呢 原因很简单

06:39.640 --> 06:45.800
随着你的这个语言的这个发展 写的cool啊这些东西越来越多 你没办法再修复了

06:46.360 --> 06:50.720
你一旦修复的话 你会破坏 就是现有就是所有的这个代码

06:51.800 --> 06:58.120
啊 你现在以存在的这个多这个代码啊 所有代码都会被破坏掉 说没办法进行修复了啊

06:58.600 --> 07:03.080
说后面的话 作者又搞出了一个什么呢 又搞出了一个这个叫做undefy

07:04.040 --> 07:08.120
看到没有 又搞出了一个这个undefy啊 为什么呢

07:09.080 --> 07:16.520
这里就是95年皆是诞生的时候啊 最初像这个加瓦一样 只设置了什么呢 只设置了这个NOW

07:17.240 --> 07:23.240
表示这个无啊 大家这个NOW的话 它会被自动转为这个零 但是这个

07:24.800 --> 07:31.040
皆是的这个设计者就那个不能能爱起 他觉得这样子还不够啊 主要就是有这么两个原因

07:31.520 --> 07:38.440
第一个的话 就是NOW像在加瓦里一样 被当成一个对象啊 但是这个皆是的数据类型分为

07:39.080 --> 07:44.760
原始类型和复合两大类啊 然后他觉得就是表示无的值 最好不要试对象

07:45.440 --> 07:53.080
就你都是无了 那最好不要试对象啊 然后接下来的话 还有就什么呢 还有就是这个皆是最初版本没有这个错误处理机制

07:53.560 --> 07:57.920
你如果这个NOW自动转为零 很不容易发现这个错误

07:58.640 --> 08:02.240
啊 因此的话 他就设计了一个什么呢 设计了一个undefine

08:03.320 --> 08:11.280
那你注意是先有这个NOW 后面才有的这个undefine undefine他其实就是为了填补之前这个NOW

08:12.160 --> 08:15.800
他所存在的一些这个问题 主要是为了解决这个问题

08:16.480 --> 08:22.840
好了 具体怎么来区分呢 比如这个NOW 那的话你注意他转成数值的时候 他会转成这个零

08:23.200 --> 08:27.160
他是和就是之前这个C远是一样的 他会转成零

08:27.640 --> 08:31.080
然后点心的用法 点心的用法就是首先作为函数的参数

08:31.720 --> 08:37.120
表示该函数的参数不是对象 或者什么呢 作为对象原型链的终点

08:37.600 --> 08:42.960
那我们知道这个原型链 原型链我们一直往上找 一直往上找 最终找到就是谁

08:43.560 --> 08:50.120
所以就是这个NOW 对不对 其实这个NOW的话 现在的话 更多的表示就是一个空

08:50.720 --> 08:54.920
就什么都没有 就用这个NOW来表示 而这个undefine

08:55.520 --> 08:59.040
undefine的话 他转成数值 他会转成这个NAN

08:59.960 --> 09:00.840
表示一个飞数

09:02.000 --> 09:10.280
他是在什么常和下用呢 他是在比如说变量声明了 但是没有负值的时候 这个时候就是本价于什么呢 undefine

09:11.000 --> 09:12.280
就表示没有值

09:13.240 --> 09:19.160
或者什么呢 或者比较调用函数时 应该提供参数 但是没有提供 该参数就是一个undefine

09:19.880 --> 09:25.960
或者这个对象没有负值的属性 值也是undefine 或者这个函数没有返回值时

09:26.760 --> 09:36.520
就是undefine 就是两者 这个NOW和这个undefine 他在这个接式的代码中 他的一些这个使用场景上面是有区别的

09:37.480 --> 09:41.160
NOW他表示的就是没有 就是没有 没有这个东西 压度就没有

09:41.720 --> 09:46.120
而undefine表示的是什么呢 undefine表示的是有这个东西 但是这个东西现在没有值

09:46.840 --> 09:51.800
看到没有 就两者他这个生成的含义 他不一样啊

09:53.400 --> 09:58.600
好 这是关于这个简单值 好 那我们来看这个复杂值 也就是我们的引用值

09:59.560 --> 10:02.040
在那个接式里面对象

10:02.920 --> 10:08.840
对象他就是一个复杂值 为什么 因为对象他可以拆呀 比如说我这边的话我这里

10:09.560 --> 10:15.320
用我这边挖了一个obj的云一个 比如说name

10:17.480 --> 10:19.000
信节 edge

10:19.800 --> 10:24.920
18 好 你看这边这个对象对象他是有什么 是不是有多个简单值组成的

10:25.320 --> 10:28.120
对不对 我这边我还可以有其他的值 比如score

10:28.920 --> 10:31.320
100 是不是还可以有其他的值 对不对

10:31.880 --> 10:33.720
那他就是有多个简单值

10:34.360 --> 10:38.600
组成的 那有多个简单值组成的我是不可以给他进行个拆分

10:39.240 --> 10:42.520
对不对 拆成这个是一个制服创 这个是个数字 这个是个数字

10:43.160 --> 10:49.640
哎 所以你看他和这个简单值有一个最大的区别就是什么 他可以拆分成多个简单值

10:50.040 --> 10:56.520
或者复杂值啊 什么意思呢 就是我这边除了简单值 我这边还可不可以对应一个对象

10:57.400 --> 10:58.840
对不对 比如我这边new

11:00.360 --> 11:00.920
stu

11:02.520 --> 11:06.360
啊 大家我这边再来可不可以啊 比如张三

11:07.320 --> 11:13.480
啊 但我这个 你不要管这个对象 他这个格式对不对啊

11:14.200 --> 11:18.920
就合不合理 你不要管他可不合理 我这边只是举例子啊 就是我这个对象是不是可以有

11:19.320 --> 11:22.120
简单值和这个复杂值组成

11:22.680 --> 11:28.760
对不对啊 就说这边的话 他就是可以拆分成多个简单值或者复杂值

11:30.440 --> 11:34.040
那么这个复杂值在内存中的这个大小

11:34.440 --> 11:41.240
它是未知的啊 因为它可以包含任何值 所以复杂值它是存在哪里的呢 它是存在堆区的

11:42.120 --> 11:43.800
存在堆区的啊 看图

11:44.360 --> 11:50.440
就是像这个样子 就我们的这个战区 战区只存一个什么呢 只存一个地址 你注意

11:51.000 --> 11:52.840
它只存储一个地址

11:54.120 --> 12:01.960
只存储一个地址 然后这个地址就会去引用什么呢 引用这个堆区 堆区里面存储的是具体的这个数据

12:02.920 --> 12:09.000
啊 这边才是存储的具体的数据啊 两个这个区域是不一样的啊 这个的话应该也是

12:09.640 --> 12:11.000
学过的啊

12:12.440 --> 12:12.680
好

12:13.880 --> 12:20.040
然后这边这个代码实例啊 上面的话就是简单值 下面的话就是复杂值 比如这个数组

12:20.600 --> 12:22.440
啊 那这边是一个对象

12:24.920 --> 12:26.600
好 这是关于简单值和复杂值

12:27.240 --> 12:30.520
好 然后接下来总结一下他们两者之间的区别

12:31.240 --> 12:35.240
那首先第一个 第一个的话就是访问方式上的区别

12:36.680 --> 12:41.240
简单值的话 它是按值来进行访问的啊 比如我复值的话也是复的是值

12:41.960 --> 12:44.120
看到没有 比如我们这边st2

12:45.000 --> 12:45.720
它是一个Hello

12:46.440 --> 12:51.400
st2 然后这样你把这个st2所复制给st2 它是什么 它是把这个值

12:52.760 --> 12:55.320
把这个值复制给st2

12:56.040 --> 13:02.600
复制给这个st2之后再将我改变st2 改变stst2 营不影响st2

13:03.320 --> 13:05.400
营不影响 是没有任何影响

13:06.120 --> 13:08.920
对不对 不会有任何影响 因为它是把这个值给它

13:09.480 --> 13:14.040
啊 所以这边你打印的时候st2是这个nau 但是st2是不是还是一个Hello

13:14.680 --> 13:21.160
但是引用类型就不一样了 引用类型你在复值的时候它复的是一个什么呢 它复的是一个这个引用地址

13:21.640 --> 13:25.640
它是把地址给它 地址给它的话两者是不是只向同一个地址

13:26.360 --> 13:32.520
对不对 就好比我比如说我这边 我有一个c 然后我把c复给这个b 那其实就是把什么的 把这个地址

13:33.160 --> 13:37.320
地址复给它 地址复给的话那两个是不是只向比如说同一个数据

13:37.960 --> 13:42.760
对不对 好 那这里的话就会涉及到 比如说我改一个 改一个另外也会改

13:43.160 --> 13:43.960
那比如说我们这边

13:45.160 --> 13:49.240
obj是个对象 然后接下来这边把这个obj

13:50.200 --> 13:54.840
复值给obj2 你注意这边的话 其实就是把obj的地址

13:55.480 --> 14:01.240
复值给这个obj2 好的 既然呢 我改变这个obj啊 根据这个引用

14:01.720 --> 14:07.000
找到它在堆去的这个地址 那就要给它添加了一个内幕属性 那这个obj2

14:07.320 --> 14:08.600
这不也有这个内幕属性

14:09.720 --> 14:13.880
对不对啊 这是这个访问方式啊 第二个

14:14.440 --> 14:19.480
第二个就是比较方式 比较方式的话 简单值是采用值的比较

14:20.040 --> 14:23.640
而复杂值采用的是引用的比较啊 比如说我们这边

14:25.000 --> 14:29.880
举个例子 比如我们这边挖一个a等于一个 把上面注射掉

14:31.960 --> 14:38.200
好 比如说这边挖一个a等于一个10 大家挖一个b等于一个10

14:38.760 --> 14:44.520
那这个时候你比如说loga等等b的时候 它这个时候它会返回什么呢

14:44.600 --> 14:53.240
它会返回这个q 代码我就不执行了 它肯定是返回这个q 为什么 因为两个都是简单值 简单值它进行的是一个值的比较

14:53.720 --> 14:59.320
但是你这边 你比如说挖一个ar1等于一个 数组有123

15:01.080 --> 15:06.680
好 大家这边挖一个ar2也是123 那你这边的话你log

15:07.160 --> 15:14.360
ar1等等等ar2 那这个时候它返回的是什么呢 这个时候它返回的是for

15:15.400 --> 15:19.800
哎 它返回的是force 为什么呢 原因很简单 它进行的是地址的比较

15:20.120 --> 15:25.000
说你两个数组里面装的元素是不是一样的 但由于它是地址的比较

15:25.400 --> 15:30.040
它会比较两个地址是否一样 那两个地址是不是肯定明显不一样

15:30.600 --> 15:33.000
对不对 它相当于就是什么呢 相当于就是

15:34.440 --> 15:39.160
这边啊 你这里有一个这个123 然后降过这边 又开p了个空间 有个123

15:39.480 --> 15:44.760
然后两个是一样的 就是那个数字是一样啊 这里面装的内容是一样 但是地址一不一样

15:45.160 --> 15:51.320
这地址是不一样 对不对 但是它这边比较就是比较的是什么 这比较的比较的就是地址

15:51.880 --> 15:53.800
说它返回的是force

15:54.440 --> 15:54.760
ok

15:56.680 --> 16:02.360
啊 这是这个比较方式啊 这边举了一些例子啊 大家下来可以看一下

16:03.320 --> 16:03.960
啊 第五个

16:05.000 --> 16:10.840
第五个就是这个动态属性啊 对于复杂值来讲 我们可以添加属性和方法

16:11.240 --> 16:16.600
也可以改变和删除属性和方法 但是简单值不可以啊 比如我们这边举个例子

16:19.140 --> 16:19.780
比如说我们这边

16:20.900 --> 16:25.940
这边的话挖一个挖一个obj 等于一个空对象

16:26.500 --> 16:31.780
好 那这个obj它是一个什么 是复杂值 复杂值的话 我这边可以随便给它添属性

16:32.580 --> 16:41.380
看到没有 随便添 然后加你这边来log一下logobj.lim 那这边肯定是打印出什么呢 打印出这个

16:42.020 --> 16:48.020
卸节 对不对 但是简单值就不行 简单值比如说我这边让我挖一个这个st2

16:48.580 --> 16:50.020
等于一个比如Hello

16:51.060 --> 16:55.140
好 然后加我这边我要给它添加一个属性 点lim等于一个

16:55.860 --> 16:56.260
卸节

16:57.460 --> 16:58.820
好 这个时候你再来log

16:59.860 --> 17:01.460
log这个st2

17:02.500 --> 17:03.460
点lim

17:04.180 --> 17:08.420
那这个时候它拿到的是什么呢 这边它拿到的是一个undefined

17:09.300 --> 17:10.660
啊 我们这边可以运行一下吗

17:11.540 --> 17:12.260
我们来看一下

17:14.940 --> 17:16.940
然后把这个移到右边

17:19.660 --> 17:21.020
cd-dex-top

17:21.900 --> 17:23.420
然后log index

17:24.220 --> 17:27.260
看到没有 是不是这个是卸节 这个是undefined 为什么

17:27.260 --> 17:30.700
因为这边的话你这个简单值 简单值它是不可以添加属性的

17:31.260 --> 17:35.740
啊 这个呢其实涉及到那个包装类型 就是包装对象的知识

17:36.220 --> 17:39.100
它这边的话会生成一个包装对象

17:39.420 --> 17:44.140
那接下来你这边给它挂这个属性的时候 其实是挂在包装对象上面的

17:44.860 --> 17:51.500
啊 当然包装对象你如果还没看的话 你可以去看一下那个包装对象那个章节 看了你就明白了

17:53.820 --> 17:54.540
啊 就是这个

17:55.180 --> 17:59.740
啊 第六个 第六个关于这个变量负责 变量负责的话

18:01.340 --> 18:02.700
呃 这个干什么说过了

18:03.420 --> 18:07.660
对不对 你这边的话简单类型的话 它是负的是什么 是直接负的是值

18:08.380 --> 18:09.740
但是如果是这个

18:10.380 --> 18:12.860
引用类型 它负的是什么 它负的是一个引用

18:13.580 --> 18:16.540
负的是一个引用 引用就是什么 是不是负的是一个地址啊

18:17.340 --> 18:19.100
对不对 把地址付给它

18:20.700 --> 18:26.300
好 这就是关于这个值和引用啊 就是什么是简单值 什么是复杂值

18:27.020 --> 18:29.580
以及两者之间一些具体的区别

18:30.300 --> 18:37.100
然后你在回答的时候 你就可以啊 像这样子来回答 比如首先他问你基本数据类型有点些 那这个很简单

18:37.900 --> 18:44.780
对吧 这个很简单 好 然后接下来他问你这个基本数据类型和引用数据类型的区别 那是不是就是把这几点

18:45.420 --> 18:45.980
回答出来

18:46.940 --> 18:51.980
对不对 就是访问方式 比较方式 动态属性啊 然后变量负责

18:52.300 --> 18:53.100
那把这些把它

18:53.660 --> 18:56.460
回答出来啊 这边有个总结 你就把这个总结

18:56.940 --> 18:57.820
你把它回答出来

18:58.220 --> 18:59.020
就差不多了

18:59.580 --> 19:05.660
好吧 好 这个大家下来可以自己再看一下 好 这些课就到这里 再见

