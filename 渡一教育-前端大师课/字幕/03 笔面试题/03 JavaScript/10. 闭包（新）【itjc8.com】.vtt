WEBVTT

00:00.690 --> 00:02.690
大家好 我是谢老师

00:02.690 --> 00:04.690
这节课的话我们来看一下这个

00:04.690 --> 00:05.690
币包

00:05.690 --> 00:07.690
这里的话有一道面试题

00:07.690 --> 00:09.690
他问你什么呢 他问你币包是什么

00:09.690 --> 00:11.690
然后应用场景有哪些

00:11.690 --> 00:14.690
以及最后一个 如何销毁币包

00:14.690 --> 00:15.690
那这个币包的话

00:15.690 --> 00:18.690
在我们这个前端面试中

00:18.690 --> 00:20.690
它是一个比较重要的支持点

00:20.690 --> 00:23.690
也是就是较高几率会被问到的一个支持点

00:23.690 --> 00:25.690
特别是在前几年

00:25.690 --> 00:28.690
我记得是差不多1314年左右

00:28.690 --> 00:30.690
经常就是必然会被问到

00:30.690 --> 00:32.690
这几年的话稍微少一些了

00:32.690 --> 00:34.690
这几年稍微少一些了

00:34.690 --> 00:36.690
前几年1314年的时候必然会被问到

00:36.690 --> 00:38.690
你一去面试就会问你

00:38.690 --> 00:39.690
什么是币包

00:39.690 --> 00:41.690
那这个币包的话也是同学们

00:41.690 --> 00:45.690
经常就是比较难理解的一个支持点

00:45.690 --> 00:47.690
你如果就是你有这两本教材

00:47.690 --> 00:51.690
就是一个是javascript的高级程序设计

00:51.690 --> 00:53.690
就我们俗称的这个红宝书

00:53.690 --> 00:55.690
然后还有就是javascript的权威子弹

00:55.690 --> 00:57.690
这个就是我们说的那个犀牛书

00:57.690 --> 00:59.690
你如果有这两本书的话

00:59.690 --> 01:02.690
你会发现这两本书里面对这个币包

01:02.690 --> 01:05.690
它里面的这个解释它是不一样的

01:05.690 --> 01:08.690
然后如果你去网络上搜索

01:08.690 --> 01:10.690
关于这个币包的这个内容的话

01:10.690 --> 01:13.690
你会发现就是各自一词

01:13.690 --> 01:14.690
各有各的说法

01:14.690 --> 01:15.690
可为什么呢

01:15.690 --> 01:16.690
众说分运

01:16.690 --> 01:17.690
对不对

01:17.690 --> 01:18.690
说这样子的话

01:18.690 --> 01:19.690
就让这个币包

01:19.690 --> 01:21.690
显得更加的这个神秘了

01:21.690 --> 01:22.690
对于同学们来讲

01:22.690 --> 01:25.690
就更加难以理解了

01:25.690 --> 01:28.690
那么这个知识点真的就这么难理解吗

01:28.690 --> 01:30.690
真的有那么深奥吗

01:30.690 --> 01:31.690
不是

01:31.690 --> 01:32.690
其实不是

01:32.690 --> 01:36.690
你如果要理解这个javascript中的这个币包

01:36.690 --> 01:38.690
其实非常容易

01:38.690 --> 01:39.690
你首先需要干嘛呢

01:39.690 --> 01:43.690
你首先要需要有两个知识点的储备

01:43.690 --> 01:45.690
要有两个知识点的储备

01:45.690 --> 01:46.690
哪两个呢

01:46.690 --> 01:50.690
一个是关于javascript中作用域和作用域列

01:50.690 --> 01:52.690
首先这个你要知道

01:52.690 --> 01:53.690
第二个就是什么

01:53.690 --> 01:54.690
第二个就是javascript中的

01:54.690 --> 01:57.690
垃圾回收

01:57.690 --> 02:00.690
说说你在打开这个视频之前

02:00.690 --> 02:02.690
你如果关于这两个

02:02.690 --> 02:03.690
你还没有听

02:03.690 --> 02:04.690
那建议你的话

02:04.690 --> 02:07.690
先去把这两个视频先看了

02:07.690 --> 02:08.690
好吧

02:08.690 --> 02:09.690
先把这两个看了

02:09.690 --> 02:12.690
看了你回头再来看这个币包

02:12.690 --> 02:13.690
回头再来看

02:13.690 --> 02:14.690
好

02:14.690 --> 02:15.690
那我这边的话

02:15.690 --> 02:16.690
我继续讲

02:16.690 --> 02:18.690
让我这边假设你是看过的

02:18.690 --> 02:19.690
假设看过的

02:19.690 --> 02:20.690
让我这边还是简单来

02:20.690 --> 02:21.690
回顾一下这两个知识点

02:21.690 --> 02:22.690
首先第一个

02:22.690 --> 02:24.690
第一个是关于javascript中

02:24.690 --> 02:26.690
作用域和作用域列

02:26.690 --> 02:28.690
那什么是作用域

02:28.690 --> 02:30.690
回忆一下什么是作用域

02:30.690 --> 02:31.690
作用域的话

02:31.690 --> 02:34.690
是不是一个独立的地盘

02:34.690 --> 02:35.690
对不对

02:35.690 --> 02:36.690
它让你的变量

02:36.690 --> 02:38.690
不会外泄暴露出去

02:38.690 --> 02:41.690
你不同作用域下的同名

02:41.690 --> 02:42.690
变量名

02:42.690 --> 02:43.690
它是不会冲突的

02:43.690 --> 02:46.690
比如说我全局作用域下面

02:46.690 --> 02:47.690
有一个i

02:47.690 --> 02:49.690
然后我函数作用域下面有个i

02:49.690 --> 02:51.690
两个i它是不冲突的

02:51.690 --> 02:52.690
为什么不冲突

02:52.690 --> 02:53.690
就是因为有作用域

02:53.690 --> 02:54.690
对吧

02:54.690 --> 02:55.690
就是因为有作用域

02:55.690 --> 02:56.690
好

02:56.690 --> 02:57.690
第二个很重要

02:57.690 --> 02:58.690
这个也是面试

02:58.690 --> 02:59.690
经常考察的一个

02:59.690 --> 03:01.690
就是作用域的话

03:01.690 --> 03:04.690
它是在定义的时候就确定了

03:04.690 --> 03:05.690
明白吧

03:05.690 --> 03:07.690
定义的时候就确定了

03:07.690 --> 03:08.690
并且不会改变

03:08.690 --> 03:10.690
它和执行上下文不一样

03:10.690 --> 03:12.690
执行上下文是调用的时候

03:12.690 --> 03:14.690
我才确定

03:14.690 --> 03:16.690
而作用域是什么呢

03:16.690 --> 03:19.690
作用域是定义的时候就确定

03:19.690 --> 03:20.690
OK

03:20.690 --> 03:21.690
这是第二点

03:21.690 --> 03:22.690
第三点就是

03:22.690 --> 03:24.690
如果当前作用域中

03:24.690 --> 03:26.690
没有查到这个值

03:26.690 --> 03:27.690
它就会干嘛

03:27.690 --> 03:30.690
它就会向上级作用域去查

03:30.690 --> 03:31.690
直到查到哪里呢

03:31.690 --> 03:34.690
直到查到全局作用域

03:34.690 --> 03:35.690
这个的话就是

03:35.690 --> 03:38.690
整个查找的过程形成了一个叫做

03:38.690 --> 03:40.690
作用域链条

03:40.690 --> 03:41.690
对不对

03:41.690 --> 03:42.690
这是我们前面讲

03:42.690 --> 03:44.690
这个作用域和作用域链的时候

03:44.690 --> 03:46.690
介绍的这个知识

03:46.690 --> 03:48.690
然后第二个知识储备是什么呢

03:48.690 --> 03:50.690
储备是垃圾回收

03:50.690 --> 03:52.690
我们知道加瓦斯克里面

03:52.690 --> 03:54.690
它的话不像这个加瓦

03:54.690 --> 03:55.690
不配

03:55.690 --> 03:57.690
它不像那个像C元

03:57.690 --> 03:58.690
像C元的话

03:58.690 --> 03:59.690
就是你这边的话

03:59.690 --> 04:01.690
你要手动的回收这个内存

04:01.690 --> 04:03.690
要手动的释放内存

04:03.690 --> 04:06.690
但是这个像加瓦加瓦斯克这种

04:06.690 --> 04:09.690
它有自动的这个垃圾回收机制

04:09.690 --> 04:11.690
它这个垃圾回收机制的话

04:11.690 --> 04:12.690
它会定期的

04:12.690 --> 04:14.690
周期性的找到什么呢

04:14.690 --> 04:17.690
找到不再使用的这个便量

04:17.690 --> 04:19.690
只要你这个便量不再使用了

04:19.690 --> 04:21.690
那么它就会被什么呢

04:21.690 --> 04:23.690
被垃圾收集器回收

04:23.690 --> 04:24.690
回收之后

04:24.690 --> 04:26.690
既然它就会释放内存

04:26.690 --> 04:29.690
如果你这个便量还在使用

04:29.690 --> 04:31.690
它就不会被回收

04:31.690 --> 04:32.690
你记住

04:32.690 --> 04:34.690
只要再使用

04:34.690 --> 04:35.690
只要再使用

04:35.690 --> 04:36.690
我就不回收

04:36.690 --> 04:37.690
你只要没有使用了

04:37.690 --> 04:39.690
我才会被回收

04:39.690 --> 04:40.690
对不对

04:40.690 --> 04:42.690
当然这个垃圾回收机制里面

04:42.690 --> 04:44.690
就是它的这个垃圾回收的方法

04:44.690 --> 04:46.690
包括这个什么标记法

04:46.690 --> 04:47.690
引用技术法

04:47.690 --> 04:48.690
什么的

04:48.690 --> 04:50.690
这个我们在讲这个垃圾回收的

04:50.690 --> 04:51.690
那个视频里面

04:51.690 --> 04:52.690
是不是给大家介绍了

04:52.690 --> 04:53.690
对不对

04:53.690 --> 04:54.690
ok

04:54.690 --> 04:55.690
好然后你这边的话

04:55.690 --> 04:57.690
首先有这两个知识储备

04:57.690 --> 04:59.690
有了这两个知识储备之后

04:59.690 --> 05:00.690
好

05:00.690 --> 05:02.690
那接下来我们再来看

05:02.690 --> 05:04.690
什么是B包

05:04.690 --> 05:05.690
回头你来看B包的话

05:05.690 --> 05:07.690
它就显得非常简单了

05:07.690 --> 05:09.690
好我首先把定义拨出来

05:09.690 --> 05:10.690
好吧

05:10.690 --> 05:12.690
首先B包的话

05:12.690 --> 05:15.690
它不是一个具体的技术

05:15.690 --> 05:16.690
它是什么呢

05:16.690 --> 05:18.690
它是一种现象

05:18.690 --> 05:19.690
它是一种现象

05:19.690 --> 05:20.690
它是指什么呢

05:20.690 --> 05:22.690
它是指定义函数

05:22.690 --> 05:23.690
这里是10

05:23.690 --> 05:26.690
定义函数10

05:26.690 --> 05:30.700
定义函数10

05:30.700 --> 05:32.700
周围环境中的信息

05:32.700 --> 05:35.700
可以在函数中使用

05:35.700 --> 05:36.700
周围环境中

05:36.700 --> 05:37.700
也就是什么

05:37.700 --> 05:39.700
就是你这个函数的外部环境

05:39.700 --> 05:41.700
不是说函数的内部环境

05:41.700 --> 05:42.700
换句话说

05:42.700 --> 05:44.700
执行函数10

05:44.700 --> 05:46.700
只要你的函数

05:46.700 --> 05:48.700
使用了外部数据

05:48.700 --> 05:50.700
那么它就创建了B包

05:50.700 --> 05:51.700
看到没有

05:51.700 --> 05:53.700
只要它使用了外部数据

05:53.700 --> 05:55.700
也就是说我这个函数内部

05:55.700 --> 05:56.700
我没有这个数据

05:56.700 --> 05:57.700
比我函数内部

05:57.700 --> 05:58.700
我要访问一个i

05:58.700 --> 06:00.700
但是我函数的内部

06:00.700 --> 06:02.700
我没有定义这个i

06:02.700 --> 06:04.700
那我就会干嘛呀

06:04.700 --> 06:06.700
我是不会顺着我的作用预列

06:06.700 --> 06:07.700
是不是一层一层的

06:07.700 --> 06:10.700
往我的上一层作用预来找

06:10.700 --> 06:11.700
对不对

06:11.700 --> 06:13.700
那这个时候它就会干嘛呢

06:13.700 --> 06:15.700
换件B包

06:15.700 --> 06:16.700
所以说这边的话

06:16.700 --> 06:17.700
作用预列

06:17.700 --> 06:18.700
它就是我们揭示中

06:18.700 --> 06:21.700
实现B包的一个手段

06:21.700 --> 06:22.700
说为什么跟你说

06:22.700 --> 06:24.700
你要先去把一个作用预列听了

06:24.700 --> 06:25.700
对不对

06:25.700 --> 06:27.700
不然你都不知道我在说什么

06:27.700 --> 06:28.700
好

06:28.700 --> 06:29.700
那我们这边的话

06:29.700 --> 06:31.700
真的是这样子的吗

06:31.700 --> 06:33.700
有的同学可能会对这个的话

06:33.700 --> 06:35.700
抱有一定的这个疑问

06:35.700 --> 06:36.700
让我们这边的话

06:36.700 --> 06:37.700
我们来证明一下

06:37.700 --> 06:39.700
好不好

06:39.700 --> 06:40.700
好

06:40.700 --> 06:41.700
来到我们这边

06:41.700 --> 06:43.700
首先的话我写一段简单的代码

06:43.700 --> 06:45.700
我把这个放大一点点

06:45.700 --> 06:47.700
不用我这边方形一个

06:47.700 --> 06:49.700
比如就叫a吗

06:49.700 --> 06:50.700
好

06:50.700 --> 06:51.700
这是一个简简单的函数

06:51.700 --> 06:53.700
然后接下来我这边调用一下

06:53.700 --> 06:54.700
调用一下

06:54.700 --> 06:55.700
然后接下来

06:55.700 --> 06:57.700
我在这个函数内部干嘛

06:57.700 --> 06:59.700
我声明一个辩量

06:59.700 --> 07:00.700
i

07:00.700 --> 07:01.700
i等于一个e

07:01.700 --> 07:02.700
好

07:02.700 --> 07:03.700
然后接下来的话

07:03.700 --> 07:05.700
我们这边log一下

07:05.700 --> 07:07.700
log一下这个i

07:07.700 --> 07:08.700
OK

07:08.700 --> 07:09.700
然后接下来

07:09.700 --> 07:11.700
这边在这个console点logi

07:11.700 --> 07:13.700
这边我们打一个断点

07:13.700 --> 07:14.700
看到没有

07:14.700 --> 07:15.700
这边然后打了一个断点

07:15.700 --> 07:16.700
打了断点之后

07:16.700 --> 07:17.700
然后接下来的话

07:17.700 --> 07:19.700
这边来到这个运行和调试

07:19.700 --> 07:21.700
那这边运行调试

07:21.700 --> 07:22.700
OK

07:22.700 --> 07:23.700
好

07:23.700 --> 07:24.700
然后接下来它执行到这一行

07:24.700 --> 07:27.700
也就是我们打断点的这个第三行

07:27.700 --> 07:28.700
对吧

07:28.700 --> 07:30.700
这一行执行到这一行的时候

07:30.700 --> 07:31.700
你这边就可以看到

07:31.700 --> 07:33.700
整个我们的这个一个辩量的这个情况

07:33.700 --> 07:36.700
你看这边有一个这个local

07:36.700 --> 07:37.700
有一个local

07:37.700 --> 07:38.700
local指的是什么

07:38.700 --> 07:39.700
local指的就是你这个a

07:39.700 --> 07:42.700
函数的函数内部

07:42.700 --> 07:43.700
看到没有

07:43.700 --> 07:44.700
这个内部的话

07:44.700 --> 07:47.700
你看这边有一个辩量i

07:47.700 --> 07:48.700
i的话是多少

07:48.700 --> 07:49.700
i的话是1

07:49.700 --> 07:50.700
对不对

07:50.700 --> 07:51.700
然后接下来有一个race

07:51.700 --> 07:52.700
race的话

07:52.700 --> 07:53.700
我们这几课

07:53.700 --> 07:54.700
不做讨论

07:54.700 --> 07:55.700
好吧

07:55.700 --> 07:56.700
这race的话

07:56.700 --> 07:58.700
你就看race相关的章节

07:58.700 --> 08:00.700
那这个的话是不是很好理解

08:00.700 --> 08:01.700
对不对

08:01.700 --> 08:02.700
很好理解

08:02.700 --> 08:03.700
好

08:03.700 --> 08:04.700
然后接下来

08:04.700 --> 08:05.700
我把这个代码稍微变一下

08:05.700 --> 08:06.700
我怎么变呢

08:06.700 --> 08:08.700
我把我定义的辩量

08:08.700 --> 08:10.700
我放到外面来

08:10.700 --> 08:12.700
你看我这边

08:12.700 --> 08:15.700
我放到了a函数外边

08:15.700 --> 08:16.700
放到a函数外边之后

08:16.700 --> 08:17.700
然后接下来

08:17.700 --> 08:19.700
再对于我这个a函数来讲

08:19.700 --> 08:21.700
我这边还有没有i

08:21.700 --> 08:22.700
还有没有

08:22.700 --> 08:24.700
这不就没有了

08:24.700 --> 08:25.700
对不对

08:25.700 --> 08:26.700
就没有了

08:26.700 --> 08:27.700
没有的话他就会干嘛呢

08:27.700 --> 08:29.700
他就会顺着他的作用预列

08:29.700 --> 08:31.700
往外一成早

08:31.700 --> 08:33.700
是不是找到这个i

08:33.700 --> 08:34.700
对不对

08:34.700 --> 08:35.700
好那接下来

08:35.700 --> 08:36.700
我们这边重新拿一下

08:36.700 --> 08:37.700
保存

08:37.700 --> 08:38.700
到这边

08:38.700 --> 08:39.700
走

08:39.700 --> 08:40.700
你看

08:40.700 --> 08:42.700
这边的话他就干嘛呀

08:42.700 --> 08:44.700
是不是创建了一个壁包

08:44.700 --> 08:45.700
对不对

08:45.700 --> 08:46.700
closer

08:46.700 --> 08:47.700
这边你点开

08:47.700 --> 08:48.700
看到没有

08:48.700 --> 08:49.700
我们的这个i

08:49.700 --> 08:50.700
就在哪里

08:50.700 --> 08:52.700
就在他创建了这个

08:52.700 --> 08:54.700
壁包里面

08:54.700 --> 08:55.700
看到没有

08:55.700 --> 08:57.700
他是顺着这个作用预列

08:57.700 --> 08:58.700
往上找

08:58.700 --> 08:59.700
然后此时的话

08:59.700 --> 09:01.700
会创建一个这个壁包

09:01.700 --> 09:03.700
所以说这个s中的壁包

09:03.700 --> 09:05.700
通过这个作用预列

09:05.700 --> 09:07.700
来这个实现的

09:07.700 --> 09:08.700
看到没有

09:08.700 --> 09:09.700
你看这样子一看的话

09:09.700 --> 09:11.700
是不是就很简单呀

09:11.700 --> 09:13.700
是不是就很简单

09:13.700 --> 09:14.700
对不对

09:14.700 --> 09:15.700
ok

09:15.700 --> 09:16.700
回到我们这边

09:16.700 --> 09:17.700
好这边的话

09:17.700 --> 09:18.700
我这个两张图就是

09:18.700 --> 09:19.700
我们刚才演示的那个啊

09:19.700 --> 09:20.700
这边是

09:20.700 --> 09:21.700
就是我们刚才

09:21.700 --> 09:22.700
把这个i变量

09:22.700 --> 09:23.700
定义在这个a

09:23.700 --> 09:24.700
函数里面的时候

09:24.700 --> 09:25.700
而且这边

09:25.700 --> 09:27.700
这边是将这个i变量

09:27.700 --> 09:29.700
定义到这个a函数

09:29.700 --> 09:30.700
外边的时候

09:30.700 --> 09:31.700
看到没有

09:31.700 --> 09:32.700
我们会发现什么呢

09:32.700 --> 09:34.700
会发现此时的i

09:34.700 --> 09:36.700
就放在closer

09:36.700 --> 09:38.700
就是我们的这个b包

09:38.700 --> 09:39.700
里面

09:39.700 --> 09:40.700
是不是就证实了

09:40.700 --> 09:41.700
我们前面的说法

09:41.700 --> 09:42.700
我们什么说法

09:42.700 --> 09:44.700
是不是只要在函数中

09:44.700 --> 09:46.700
使用了外部的数据

09:46.700 --> 09:48.700
就会干嘛呀

09:48.700 --> 09:50.700
就会创建b包

09:50.700 --> 09:51.700
对不对

09:51.700 --> 09:52.700
就会创建b包

09:52.700 --> 09:53.700
ok

09:53.700 --> 09:54.700
好

09:54.700 --> 09:55.700
然后接下来

09:55.700 --> 09:56.700
我们这个继续啊

09:56.700 --> 09:58.700
说说你看这个b包

09:58.700 --> 09:59.700
这个b包的话

09:59.700 --> 10:01.700
其实也没有那么难理解

10:01.700 --> 10:02.700
对不对

10:02.700 --> 10:04.700
没有那么难理解

10:04.700 --> 10:05.700
然后这边的话

10:05.700 --> 10:06.700
就是谢老师的话

10:06.700 --> 10:08.700
还比较推崇的一个方法

10:08.700 --> 10:09.700
就什么方法呢

10:09.700 --> 10:11.700
就当你觉得某个知识点

10:11.700 --> 10:12.700
某个技术点

10:12.700 --> 10:14.700
比较难的时候

10:14.700 --> 10:15.700
你可以采用一个什么呢

10:15.700 --> 10:17.700
可以采用一个猜词法

10:17.700 --> 10:19.700
这是我最近学习的话

10:19.700 --> 10:21.700
特别喜欢用的一个方法

10:21.700 --> 10:22.700
猜词

10:22.700 --> 10:23.700
你就把这个词

10:23.700 --> 10:25.700
拆开一个一个的去理解

10:25.700 --> 10:26.700
比如说我们这边的话

10:26.700 --> 10:27.700
这个b包

10:27.700 --> 10:28.700
b的话

10:28.700 --> 10:29.700
你可以理解为什么

10:29.700 --> 10:30.700
b的话

10:30.700 --> 10:32.700
你是不是可以理解为是一个封闭

10:32.700 --> 10:33.700
闭环

10:33.700 --> 10:34.700
对不对

10:34.700 --> 10:35.700
封闭闭环

10:35.700 --> 10:36.700
然后包的话

10:36.700 --> 10:37.700
你可以理解为一个

10:37.700 --> 10:40.700
类似于包裹的这个空间

10:40.700 --> 10:42.700
说b包b包什么意思

10:42.700 --> 10:45.700
是不是就是一个封闭的空间

10:45.700 --> 10:46.700
对不对

10:46.700 --> 10:48.700
一个独立的封闭的空间

10:48.700 --> 10:50.700
那么这个封闭的空间

10:50.700 --> 10:51.700
用来干嘛的呢

10:51.700 --> 10:52.700
这个封闭的空间

10:52.700 --> 10:55.700
就是用来存储这个变量的

10:55.700 --> 10:56.700
你回头看我们这边

10:56.700 --> 10:57.700
你看这个b包

10:57.700 --> 10:59.700
一个封闭的空间

10:59.700 --> 11:01.700
那这个封闭的空间

11:01.700 --> 11:03.700
是不是拿来存储这个变量

11:03.700 --> 11:04.700
对不对

11:04.700 --> 11:06.700
存储这个变量

11:06.700 --> 11:07.700
那这边的话

11:07.700 --> 11:09.700
哪些变量会存储呢

11:09.700 --> 11:11.700
是不是我一个函数下面

11:11.700 --> 11:13.700
所有这个变量的这个声明

11:13.700 --> 11:15.700
都会放到这个b包

11:15.700 --> 11:17.700
这个封闭的空间里面呢

11:17.700 --> 11:18.700
倒也不是

11:18.700 --> 11:19.700
也不是

11:19.700 --> 11:20.700
好让我这边的话

11:20.700 --> 11:21.700
我给你证明一下

11:21.700 --> 11:23.700
我们来看一下

11:23.700 --> 11:25.700
好回到我们的这个代码

11:25.700 --> 11:27.700
好把这个稍微调一下

11:28.700 --> 11:30.700
好然后接下来的话

11:30.700 --> 11:31.700
把这个先停掉

11:31.700 --> 11:33.700
好然后接下来的话

11:33.700 --> 11:34.700
我在a函数里面干嘛呢

11:34.700 --> 11:36.700
我定义两个变量

11:36.700 --> 11:37.700
挖一个这个接

11:37.700 --> 11:38.700
接的话等于个10

11:38.700 --> 11:40.700
然后挖一个这个k

11:40.700 --> 11:42.700
等于一个20

11:42.700 --> 11:43.700
好然后接下来

11:43.700 --> 11:45.700
我这边function b

11:45.700 --> 11:48.080
function b

11:48.080 --> 11:49.080
好然后接下来这边

11:49.080 --> 11:51.080
调一下这个b这个函数

11:51.080 --> 11:53.080
好在这个b这个函数里面

11:53.080 --> 11:55.080
我挖一个x4

11:55.080 --> 11:57.080
等于一个30

11:57.080 --> 11:59.080
挖一个y

11:59.080 --> 12:01.080
等于一个40

12:01.080 --> 12:03.080
ok好然后接下来我这边

12:03.080 --> 12:05.080
再来function一个c

12:05.080 --> 12:08.390
好然后接下来哈

12:08.390 --> 12:09.390
这边c

12:09.390 --> 12:12.390
ok好在c里面我干嘛呢

12:12.390 --> 12:14.390
在c里面我来进行一个

12:14.390 --> 12:16.390
打印打印什么呢打印

12:16.390 --> 12:17.390
首先这个i

12:17.390 --> 12:19.390
然后接下来话这个g

12:19.390 --> 12:20.390
然后k

12:20.390 --> 12:22.390
然后x

12:22.390 --> 12:24.390
打印这么几个保存一下

12:24.390 --> 12:26.390
好我们来看一下

12:26.390 --> 12:29.390
对于我这个c这个函数来讲

12:29.390 --> 12:31.390
这边把分号加上

12:31.390 --> 12:34.390
对于我这个c这个函数来讲

12:34.390 --> 12:36.390
他有没有声明变量

12:36.390 --> 12:37.390
你看一下有没有声明变量

12:37.390 --> 12:38.390
说没有对不对

12:38.390 --> 12:39.390
一看就看得到

12:39.390 --> 12:40.390
没有声明变量

12:40.390 --> 12:42.390
啊这边igk

12:42.390 --> 12:44.390
ak4你这边打印的

12:44.390 --> 12:46.390
任何一个变量都是什么

12:46.390 --> 12:48.390
都是要通过他的这个

12:48.390 --> 12:49.390
作用预列

12:49.390 --> 12:52.390
是不是一层一层的来找啊

12:52.390 --> 12:54.390
对不对一层一层来找

12:54.390 --> 12:56.390
那么这里的话就会设计到什么呢

12:56.390 --> 12:57.390
这里就会设计到

12:57.390 --> 12:59.390
他就会创建这个笔包

12:59.390 --> 13:00.390
对不对

13:00.390 --> 13:02.390
他就会创建那么一个封闭的空间

13:02.390 --> 13:04.390
创建这么一个空间

13:04.390 --> 13:06.390
然后接下来话你这边

13:06.390 --> 13:07.390
要用到的

13:07.390 --> 13:09.390
我就把这个变量放进这个空间

13:09.390 --> 13:10.390
好那我们这边的话

13:10.390 --> 13:11.390
打一个断点

13:11.390 --> 13:13.390
把这个断点取消了

13:13.390 --> 13:15.390
好那这样我们这边来

13:15.390 --> 13:16.390
运行调试

13:16.390 --> 13:17.390
ok你看这边

13:17.390 --> 13:19.390
这边的话就创建了什么呢

13:19.390 --> 13:22.390
创建了三个笔包

13:22.390 --> 13:23.390
看到没有

13:23.390 --> 13:24.390
创建了三个笔包

13:24.390 --> 13:25.390
首先的话这边

13:25.390 --> 13:26.390
我们看最下面的这个closer

13:26.390 --> 13:27.390
这个是什么呢

13:27.390 --> 13:29.390
这个就是你全局的这个笔包

13:29.390 --> 13:30.390
这里面存储了什么

13:30.390 --> 13:32.390
就是存储了这个i

13:32.390 --> 13:34.390
对不对存储了谁

13:34.390 --> 13:35.390
存储了他

13:35.390 --> 13:36.390
存储了i

13:36.390 --> 13:37.390
好然后接下来

13:37.390 --> 13:38.390
这边还创建了一个什么

13:38.390 --> 13:40.390
是不是创建了一个这个closer

13:40.390 --> 13:41.390
b这个笔包

13:41.390 --> 13:42.390
这个a这个笔包

13:42.390 --> 13:43.390
对不对

13:43.390 --> 13:45.390
a这个笔包里面存储了什么呢

13:45.390 --> 13:47.390
存储了接存储了k

13:47.390 --> 13:48.390
看到没有

13:48.390 --> 13:49.390
接k为什么

13:49.390 --> 13:50.390
因为你这边他是不是在

13:50.390 --> 13:51.390
打印接和k

13:51.390 --> 13:52.390
对不对

13:52.390 --> 13:53.390
好然后接下来

13:53.390 --> 13:55.390
我们再来打开这个closer

13:55.390 --> 13:56.390
b

13:56.390 --> 13:57.390
我们来打开看一下

13:57.390 --> 13:59.390
你看这个笔包的话

13:59.390 --> 14:01.390
就只有什么呀

14:01.390 --> 14:02.390
只有什么

14:02.390 --> 14:05.390
这不只有x啊

14:05.390 --> 14:06.390
看到没有

14:06.390 --> 14:07.390
只有x

14:07.390 --> 14:08.390
有没有y

14:08.390 --> 14:09.390
没有y

14:09.390 --> 14:10.390
为什么呀

14:10.390 --> 14:11.390
因为你这个y的话

14:11.390 --> 14:12.390
你这边话说

14:12.390 --> 14:14.390
没有用到

14:14.390 --> 14:15.390
对不对

14:15.390 --> 14:16.390
没有用到

14:16.390 --> 14:17.390
或者换句话说

14:17.390 --> 14:18.390
叫做什么呢

14:18.390 --> 14:21.390
叫做没有被引用到

14:21.390 --> 14:22.390
没有被引用到

14:22.390 --> 14:24.390
所以他没有被引用到的

14:24.390 --> 14:25.390
变量

14:25.390 --> 14:28.390
他是不会放入到笔包里面的

14:28.390 --> 14:29.390
明白没

14:29.390 --> 14:30.390
我再说一遍

14:30.390 --> 14:32.390
如果没有用到的变量

14:32.390 --> 14:34.390
他是不会放入到笔包里面的

14:34.390 --> 14:36.390
所以说回到我们这边

14:36.390 --> 14:38.390
我们这边

14:38.390 --> 14:39.390
上面的代码

14:39.390 --> 14:41.390
韩束C中

14:41.390 --> 14:42.390
一个变量都没有创建

14:42.390 --> 14:43.390
对吧

14:43.390 --> 14:44.390
然后去打印这几个

14:44.390 --> 14:45.390
对不对

14:45.390 --> 14:46.390
然后这边的话

14:46.390 --> 14:47.390
创建了几个笔包

14:47.390 --> 14:49.390
就创建了三个笔包

14:49.390 --> 14:51.390
全局笔包里面存储了i

14:51.390 --> 14:54.390
然后笔包a里面是这个j和k

14:54.390 --> 14:55.390
然后b里面是什么

14:55.390 --> 14:58.390
是不是就一个x

14:58.390 --> 14:59.390
对不对

14:59.390 --> 15:00.390
所以说这边

15:00.390 --> 15:01.390
这边有一句话

15:01.390 --> 15:03.390
要不要放入到笔包

15:03.390 --> 15:04.390
因为我们刚才说了

15:04.390 --> 15:05.390
笔包是一个封闭的空间

15:05.390 --> 15:06.390
他是用来存储

15:06.390 --> 15:08.390
这个被引用的变量

15:08.390 --> 15:09.390
对不对

15:09.390 --> 15:11.390
所以要不要放入笔包

15:11.390 --> 15:12.390
取决于什么呢

15:12.390 --> 15:14.390
取决于你这个变量

15:14.390 --> 15:18.390
有没有被其他空间引用

15:18.390 --> 15:19.390
没有吧

15:19.390 --> 15:21.390
取决于有没有被引用

15:21.390 --> 15:23.390
如果你被引用了

15:23.390 --> 15:25.390
那我会被就放到笔包里面

15:25.390 --> 15:27.390
如果没有被引用

15:27.390 --> 15:29.390
那我是不会放到笔包里面的

15:29.390 --> 15:30.390
ok

15:30.390 --> 15:31.390
好

15:31.390 --> 15:32.390
然后接下来的话

15:32.390 --> 15:33.390
我们继续

15:33.390 --> 15:34.390
接下来的话

15:34.390 --> 15:36.390
有的同学可能就会有一个新的问题了

15:36.390 --> 15:37.390
什么新的问题呢

15:37.390 --> 15:38.390
他说

15:38.390 --> 15:39.390
这个谢老师

15:39.390 --> 15:40.390
就你这边的话

15:40.390 --> 15:41.390
我一调用这边

15:41.390 --> 15:44.390
夸夸夸给我创建了三个笔包

15:44.390 --> 15:45.390
对不对

15:45.390 --> 15:46.390
那我这边呢

15:46.390 --> 15:47.390
稍微比如说

15:47.390 --> 15:48.390
我这边的话

15:48.390 --> 15:49.390
欠他的层数稍微多一点

15:49.390 --> 15:50.390
他的这个笔包

15:50.390 --> 15:52.390
岂不是越来越多

15:52.390 --> 15:53.390
越来越多的话

15:53.390 --> 15:54.390
接下来他这个每一个笔包

15:54.390 --> 15:57.390
他叫占据一段内存空间

15:57.390 --> 15:58.390
那岂不是就是

15:58.390 --> 16:00.390
我的这个内存空间

16:00.390 --> 16:02.390
会被大量的消耗

16:02.390 --> 16:03.390
对不对

16:03.390 --> 16:04.390
他可能会有这样的问题

16:04.390 --> 16:06.390
你看我们这边都创建了几个

16:06.390 --> 16:08.390
我们这边是不是都创建了三个

16:08.390 --> 16:09.390
对不对

16:09.390 --> 16:10.390
ok

16:10.390 --> 16:11.390
好

16:11.390 --> 16:12.390
会不会有这个问题呢

16:12.390 --> 16:13.390
我们来看一下

16:13.390 --> 16:14.390
好

16:14.390 --> 16:15.390
实际上

16:15.390 --> 16:18.390
是自动形成的这个笔包

16:18.390 --> 16:19.390
他是会什么呢

16:19.390 --> 16:21.390
是会被销毁掉的

16:21.390 --> 16:22.390
是会被销毁掉的

16:22.390 --> 16:23.390
什么意思

16:23.390 --> 16:24.390
就比如说我这边

16:24.390 --> 16:25.390
我举了个例子

16:25.390 --> 16:26.390
好我这边

16:26.390 --> 16:27.390
我把这行代码注射掉

16:27.390 --> 16:28.390
这个C函数什么也不做

16:28.390 --> 16:29.390
好

16:29.390 --> 16:30.390
然后接下来

16:30.390 --> 16:31.390
我们这边

16:31.390 --> 16:33.390
console.log

16:33.390 --> 16:34.390
什么呢

16:34.390 --> 16:36.390
log一个比如说log一个y

16:37.390 --> 16:38.390
log一个y

16:38.390 --> 16:39.390
ok

16:39.390 --> 16:40.390
好然后接下来

16:40.390 --> 16:43.150
在这边打个断点

16:43.150 --> 16:44.150
在这边

16:45.150 --> 16:46.150
保存一下

16:46.150 --> 16:47.150
马上我把这停掉

16:48.150 --> 16:50.150
好在这打个断点

16:50.150 --> 16:52.150
好这个代码的结果大家都知道

16:52.150 --> 16:54.150
这个结果应该是什么

16:54.150 --> 16:55.150
这个的话

16:55.150 --> 16:56.150
我打印这个y

16:56.150 --> 16:57.150
打印y的话

16:57.150 --> 16:58.150
你这边的话全局没有y

16:58.150 --> 17:00.150
他是不是就是应该是会爆错的

17:00.150 --> 17:01.150
对不对

17:01.150 --> 17:02.150
你这边让你执行一下这个代码

17:02.150 --> 17:03.150
load index

17:03.150 --> 17:04.150
是会爆错

17:04.150 --> 17:05.150
对不对

17:05.150 --> 17:06.150
好那我们这边

17:06.150 --> 17:07.150
让我们启动这个调试

17:07.150 --> 17:08.150
我们来看一下

17:08.150 --> 17:09.150
为什么会爆错

17:09.150 --> 17:10.150
你看你这边

17:10.150 --> 17:11.150
你这边的话

17:11.150 --> 17:12.150
还然后把这个

17:12.150 --> 17:13.150
稍微放小一点点

17:14.150 --> 17:16.150
这个能不能往下拉一点

17:16.150 --> 17:17.150
可以

17:17.150 --> 17:18.150
你仔细看一下

17:18.150 --> 17:21.150
当你代码运行到第16行的时候

17:21.150 --> 17:25.150
你这边还有没有这个b包呀

17:25.150 --> 17:27.150
还有没有b包

17:27.150 --> 17:28.150
这就没有了

17:28.150 --> 17:29.150
对不对

17:29.150 --> 17:30.150
就没有了

17:30.150 --> 17:31.150
为什么呢

17:31.150 --> 17:32.150
因为你这边的话

17:32.150 --> 17:34.150
你15行再调用这个a这个函数

17:34.150 --> 17:35.150
然后接下来

17:35.150 --> 17:38.150
他这边把整个这个a函数执行完

17:38.150 --> 17:40.150
我不管你这个a函数里面

17:40.150 --> 17:41.150
又创建了b函数

17:41.150 --> 17:42.150
b函数里面又创建了c函数

17:42.150 --> 17:43.150
这个我不管

17:43.150 --> 17:44.150
总之我这边的话

17:44.150 --> 17:47.150
把整个这个a函数执行完之后

17:47.150 --> 17:50.150
我整个这个空间就会被干嘛呀

17:50.150 --> 17:52.150
就会被销毁掉

17:52.150 --> 17:53.150
对不对

17:53.150 --> 17:54.150
我里面的这些变量

17:54.150 --> 17:56.150
我都没有再被引用了

17:56.150 --> 17:58.150
都没有再被引用了

17:58.150 --> 18:00.150
然后我整个这个a函数一执行完

18:00.150 --> 18:03.150
我这个空间就会被销毁掉

18:03.150 --> 18:04.150
一被销毁掉之后

18:04.150 --> 18:06.150
那你这边访问这个

18:06.150 --> 18:07.150
你在外部打印这个y

18:07.150 --> 18:09.150
当然他就打印不到喽

18:09.150 --> 18:10.150
对不对

18:10.150 --> 18:11.150
当然就打印不到

18:11.150 --> 18:12.150
而且你看这边

18:12.150 --> 18:14.150
这边还存不存在b包

18:14.150 --> 18:16.150
这也就不存在b包了

18:16.150 --> 18:17.150
对不对

18:17.150 --> 18:18.150
有东西会说

18:18.150 --> 18:20.150
你这边有一些什么exports module

18:20.150 --> 18:21.150
这些是什么

18:21.150 --> 18:22.150
这个的话是后面

18:22.150 --> 18:24.150
就是你们要学的这个load.js

18:24.150 --> 18:26.150
load.js里面的这个知识

18:26.150 --> 18:29.150
老师就是针对这个讲了的

18:29.150 --> 18:30.150
ok

18:30.150 --> 18:31.150
这个后面再看

18:31.150 --> 18:33.150
现在的话你可以先放一边

18:33.150 --> 18:34.150
先放一边

18:34.150 --> 18:35.150
但是你现在的话

18:35.150 --> 18:36.150
你可以看到一个事情是什么呢

18:36.150 --> 18:39.150
当你代码执行到第16行的时候

18:39.150 --> 18:42.150
确确实实刚才的那三个b包

18:42.150 --> 18:44.150
是不是都没有了呀

18:44.150 --> 18:45.150
对不对

18:45.150 --> 18:46.150
都没有了

18:46.150 --> 18:48.150
所以就不存在刚才我们

18:48.150 --> 18:51.150
就是刚才大家所存在的那种疑问

18:51.150 --> 18:53.150
让我这边创建了b包那么多

18:53.150 --> 18:54.150
会不会占用空间

18:54.150 --> 18:56.150
不会

18:56.150 --> 18:58.150
但这里指的是什么呢

18:58.150 --> 18:59.150
我这边我说想

18:59.150 --> 19:03.150
这里我指的是自动形成的b包

19:03.150 --> 19:04.150
你想想我们这边

19:04.150 --> 19:06.150
我们在执行代码的时候

19:06.150 --> 19:08.150
他的b包自动形成

19:08.150 --> 19:09.150
自动销毁

19:09.150 --> 19:10.150
我们在编码的时候

19:10.150 --> 19:12.150
我们其实基本上是不care这个的

19:12.150 --> 19:13.150
对不对

19:13.150 --> 19:15.150
比如我不给你讲这个知识点的话

19:15.150 --> 19:17.150
你其实平时你不影响你编码的

19:17.150 --> 19:19.150
它是不影响的

19:19.150 --> 19:20.150
对不对

19:20.150 --> 19:21.150
不影响的

19:21.150 --> 19:22.150
但是有一种情况是什么呢

19:22.150 --> 19:24.150
就是我们这个有些时候

19:24.150 --> 19:27.150
我们可以手动来制造一个b包

19:27.150 --> 19:29.150
手动制造一个b包

19:29.150 --> 19:30.150
那比如说你看这边

19:30.150 --> 19:32.150
我举了个例子

19:32.150 --> 19:34.150
好这就是刚才的例子

19:34.150 --> 19:35.150
比如说我这边的话

19:35.150 --> 19:36.150
我这个函数

19:36.150 --> 19:37.150
我这边有一个eat这个函数

19:37.150 --> 19:39.150
这边有一个food

19:39.150 --> 19:40.150
这边打印food

19:40.150 --> 19:41.150
这边的话

19:41.150 --> 19:42.150
肯定是打印出这个机车

19:42.150 --> 19:43.150
对不对

19:43.150 --> 19:44.150
我这边掉

19:44.150 --> 19:45.150
只要一掉用这个eat

19:45.150 --> 19:47.150
那这边是不是打印出这个机车

19:47.150 --> 19:48.150
对不对

19:48.150 --> 19:49.150
好那接下来

19:49.150 --> 19:50.150
我在它的下一行

19:50.150 --> 19:51.150
我打印这个food

19:51.150 --> 19:52.150
它就会干嘛呢

19:52.150 --> 19:54.150
它就会爆错

19:54.150 --> 19:55.150
它就会爆错

19:55.150 --> 19:56.150
为什么

19:56.150 --> 19:57.150
原因很简单

19:57.150 --> 19:58.150
你这边的函数掉用完之后

19:58.150 --> 19:59.150
函数的整个空间

19:59.150 --> 20:01.150
所以就会被销毁掉了

20:01.150 --> 20:02.150
对不对

20:02.150 --> 20:03.150
被销毁掉之后

20:03.150 --> 20:04.150
现在你的food

20:04.150 --> 20:05.150
你的这个变量的话

20:05.150 --> 20:07.150
是不是就会被这个垃圾回收

20:07.150 --> 20:08.150
对不对

20:08.150 --> 20:10.150
就会作为垃圾被回收掉

20:10.150 --> 20:12.150
但是如果我们对这个代码

20:12.150 --> 20:14.150
做一个简单的修改

20:14.150 --> 20:16.150
我们把它修改成这个样子

20:16.150 --> 20:17.150
你看哦

20:17.150 --> 20:18.150
注意看哦

20:18.150 --> 20:20.150
你如果把代码改成这个样子

20:20.150 --> 20:22.150
它就不一样了

20:22.150 --> 20:24.150
我们来仔细分析一下

20:24.150 --> 20:26.150
当我将这个代码

20:26.150 --> 20:27.150
改成这个样子之后

20:27.150 --> 20:28.150
我的函数内部

20:28.150 --> 20:29.150
是不是声明了

20:29.150 --> 20:31.150
一个food的这个变量

20:31.150 --> 20:32.150
对不对

20:32.150 --> 20:33.150
好

20:33.150 --> 20:34.150
接下来的话

20:34.150 --> 20:35.150
我这边return

20:35.150 --> 20:37.150
我返回了一个函数

20:37.150 --> 20:39.150
返回了一个函数

20:39.150 --> 20:40.150
然后返回一个函数给什么

20:40.150 --> 20:41.150
是不是给外部

20:41.150 --> 20:42.150
外部有个变量

20:42.150 --> 20:43.150
是不是接收掉

20:43.150 --> 20:44.150
对不对

20:44.150 --> 20:45.150
接收到

20:45.150 --> 20:46.150
那你这个外部

20:46.150 --> 20:47.150
接收的这个look

20:47.150 --> 20:48.150
相当于就是什么

20:48.150 --> 20:50.150
相当于是不是就是这个函数

20:50.150 --> 20:52.150
这不就是这个函数

20:52.150 --> 20:53.150
对不对

20:53.150 --> 20:54.150
你这边的话

20:54.150 --> 20:55.150
Eat

20:55.150 --> 20:56.150
它返回的是这么一个匿名函数

20:56.150 --> 20:57.150
返回的这个匿名函数

20:57.150 --> 20:58.150
我用这个look

20:58.150 --> 20:59.150
接收到

20:59.150 --> 21:00.150
那look

21:00.150 --> 21:01.150
是不是相当于

21:01.150 --> 21:02.150
就是这么一个函数

21:02.150 --> 21:04.150
让我调用look的时候

21:04.150 --> 21:07.780
当我调用这个函数的时候

21:07.780 --> 21:08.780
那这个函数

21:08.780 --> 21:10.780
它相当于是执行的是

21:10.780 --> 21:11.780
这个函数

21:11.780 --> 21:12.780
那这个函数里面

21:12.780 --> 21:13.780
要访问什么呢

21:13.780 --> 21:15.780
是访问这个food

21:15.780 --> 21:16.780
对不对

21:16.780 --> 21:17.780
访问这个food

21:17.780 --> 21:18.780
那这里就会

21:18.780 --> 21:19.780
涉及到一个问题了

21:19.780 --> 21:21.780
我这个函数里面

21:21.780 --> 21:24.780
有没有food的这个变量

21:24.780 --> 21:25.780
有没有

21:25.780 --> 21:27.780
没有

21:27.780 --> 21:28.780
对不对

21:28.780 --> 21:29.780
没有没有怎么办

21:29.780 --> 21:30.780
没有的话

21:30.780 --> 21:32.780
顺着你的这个作用预链

21:32.780 --> 21:33.780
往外找

21:33.780 --> 21:35.780
顺着你作用预链往外找

21:35.780 --> 21:37.780
是不是找到它呀

21:37.780 --> 21:38.780
也就是说

21:38.780 --> 21:39.780
它一直会被干嘛

21:39.780 --> 21:41.780
是不是一直会被引用着

21:41.780 --> 21:42.780
对不对

21:42.780 --> 21:43.780
即使我这边

21:43.780 --> 21:44.780
第七行

21:44.780 --> 21:45.780
这边的话

21:45.780 --> 21:46.780
调用这个eat

21:46.780 --> 21:47.780
调用完毕

21:47.780 --> 21:48.780
但是由于我这eat

21:48.780 --> 21:49.780
返回了一个函数

21:49.780 --> 21:50.780
对不对

21:50.780 --> 21:51.780
返回了一个函数

21:51.780 --> 21:53.780
这个函数引用了food

21:53.780 --> 21:54.780
所以这个food

21:54.780 --> 21:56.780
它是不会被垃圾回收的

21:56.780 --> 21:57.780
没有吧

21:57.780 --> 21:59.780
这个就是我们手动返回一个

21:59.780 --> 22:00.780
必包的这个情况

22:00.780 --> 22:01.780
手动返回

22:01.780 --> 22:03.780
返回给这个外部

22:03.780 --> 22:04.780
那它干嘛

22:04.780 --> 22:06.780
它这个food就一直被引用着

22:06.780 --> 22:08.780
那这个必包它就一直存在

22:08.780 --> 22:09.780
OK

22:09.780 --> 22:10.780
好那我们这边

22:10.780 --> 22:14.570
我们来执行一下

22:14.570 --> 22:15.570
你看

22:15.570 --> 22:17.570
这边它是不是打印出机次

22:17.570 --> 22:18.570
看到没有

22:18.570 --> 22:19.570
打印出机次

22:19.570 --> 22:22.570
这就是我们这边手动

22:22.570 --> 22:26.570
手动这个创建这个必包的这个情况

22:26.570 --> 22:28.570
那我们这里的话

22:28.570 --> 22:30.570
我们手动创建了一个这个必包

22:30.570 --> 22:32.570
然后接下来把这个必包干嘛呢

22:32.570 --> 22:34.570
是把这个返回给了这个外部

22:34.570 --> 22:35.570
致使什么呢

22:35.570 --> 22:36.570
致使在外部

22:36.570 --> 22:37.570
我这边执行这个look

22:37.570 --> 22:39.570
是不是也能访问到这个food

22:39.570 --> 22:40.570
这个food的话

22:40.570 --> 22:41.570
它不会随着什么呢

22:41.570 --> 22:43.570
不会随着你这个函数执行完毕

22:43.570 --> 22:44.570
我就销毁掉了

22:44.570 --> 22:45.570
不会

22:45.570 --> 22:46.570
为什么

22:46.570 --> 22:47.570
因为我被引用着的

22:47.570 --> 22:48.570
对不对

22:48.570 --> 22:49.570
我被引用着

22:49.570 --> 22:50.570
只要我刚说过

22:50.570 --> 22:52.570
只要一个便量

22:52.570 --> 22:53.570
它被引用着

22:53.570 --> 22:55.570
它是不是不会被垃圾进行回收

22:55.570 --> 22:57.570
就是垃圾回收器进行回收

22:57.570 --> 22:58.570
对不对

22:58.570 --> 22:59.570
它一直被引用着的

22:59.570 --> 23:00.570
好

23:00.570 --> 23:01.570
那这边的话

23:01.570 --> 23:02.570
就是我们的这个

23:02.570 --> 23:04.570
一个必包的这个特点

23:04.570 --> 23:05.570
也就体现出来了

23:05.570 --> 23:06.570
我们来看一下

23:06.570 --> 23:08.570
我这边总结了两个

23:08.570 --> 23:09.570
通过必包

23:09.570 --> 23:12.570
可以让外部环境干嘛呢

23:12.570 --> 23:15.570
访问到函数内部的局部便量

23:15.570 --> 23:17.570
你回头你再看一下是不是

23:17.570 --> 23:19.570
外部环境

23:19.570 --> 23:20.570
是不是访问到这个了

23:20.570 --> 23:21.570
对不对

23:21.570 --> 23:22.570
为什么

23:22.570 --> 23:23.570
因为它一直被这个

23:23.570 --> 23:24.570
你返回的是匿名函数

23:24.570 --> 23:25.570
匿名函数一直引用着它的

23:25.570 --> 23:26.570
对不对

23:26.570 --> 23:27.570
只要引用着

23:27.570 --> 23:29.570
它就不会被垃圾回收器回收

23:29.570 --> 23:30.570
反复强调

23:30.570 --> 23:31.570
第二个

23:31.570 --> 23:34.570
通过必包可以让局部便量保存下来

23:34.570 --> 23:37.570
不随着上下文环境一起销毁

23:37.570 --> 23:39.570
也就是我们这边

23:39.570 --> 23:42.570
即使你这个议册执行完毕了

23:42.570 --> 23:44.570
让我这个负的也会干嘛呀

23:44.570 --> 23:46.570
是不是一直引用着

23:46.570 --> 23:47.570
对不对

23:47.570 --> 23:48.570
因为有必包的存在

23:48.570 --> 23:49.570
它一直引用着

23:49.570 --> 23:51.570
它不会被销毁

23:51.570 --> 23:53.570
那这个会不会被销毁

23:53.570 --> 23:54.570
用我这边让我再来一个

23:54.570 --> 23:56.570
比如说有个负的2

23:56.570 --> 23:58.570
负的2

23:58.570 --> 24:00.570
这边我随便写个

24:00.570 --> 24:02.570
比如说随便写个ABC

24:02.570 --> 24:04.570
这个会不会被销毁

24:04.570 --> 24:05.570
这个会不会

24:05.570 --> 24:06.570
你想想

24:06.570 --> 24:07.570
仔细想想

24:07.570 --> 24:09.570
想想解老师讲的

24:09.570 --> 24:10.570
肯定会被销毁

24:10.570 --> 24:11.570
对不对

24:11.570 --> 24:12.570
会不会销毁

24:12.570 --> 24:13.570
你看什么

24:13.570 --> 24:16.570
看它有没有被外部环境引用

24:16.570 --> 24:17.570
对不对

24:17.570 --> 24:19.570
你看它这边有没有被引用

24:19.570 --> 24:20.570
没有被引用

24:20.570 --> 24:21.570
只要它没有被引用

24:21.570 --> 24:22.570
它没有用了

24:22.570 --> 24:23.570
没有用了留着干嘛呢

24:23.570 --> 24:24.570
对不对

24:24.570 --> 24:25.570
它就会被销毁掉

24:25.570 --> 24:26.570
而这个的话

24:26.570 --> 24:27.570
它就不会

24:27.570 --> 24:28.570
为什么

24:28.570 --> 24:29.570
因为它这边的话

24:29.570 --> 24:31.570
你这个返回的这个利民函数

24:31.570 --> 24:33.570
它是不是引用着你这个负的的

24:33.570 --> 24:34.570
对不对

24:34.570 --> 24:35.570
引用着的

24:37.570 --> 24:39.570
那这个使用这个B包

24:39.570 --> 24:41.570
让我们这边有哪些应用场景

24:41.570 --> 24:42.570
能不能来看一下

24:42.570 --> 24:43.570
早期的时候

24:43.570 --> 24:45.570
其实可以解决一个

24:45.570 --> 24:47.570
就是非常常见的一个问题

24:47.570 --> 24:50.570
就是全局变量污染的问题

24:50.570 --> 24:51.570
早期的时候

24:51.570 --> 24:54.570
我们的一个JS还没有这个模块化

24:54.570 --> 24:55.570
最早期的时候

24:55.570 --> 24:57.570
没有那个Export

24:57.570 --> 24:59.570
然后那个Import

24:59.570 --> 25:00.570
我们这个JS6模块化

25:00.570 --> 25:01.570
对吧

25:01.570 --> 25:02.570
现在有了很方便

25:02.570 --> 25:04.570
但早期的时候没有

25:04.570 --> 25:05.570
没有的时候

25:05.570 --> 25:06.570
你早期的话

25:06.570 --> 25:08.570
你在进行这个多人协作的时候

25:08.570 --> 25:10.570
那就很容易造成这个全局变量

25:10.570 --> 25:11.570
它就冲突了

25:11.570 --> 25:13.570
比如你也定一个i

25:13.570 --> 25:14.570
我也定一个i

25:14.570 --> 25:15.570
最终它就冲突了

25:15.570 --> 25:16.570
那怎么办呢

25:16.570 --> 25:18.570
那就可以使用这个B包

25:18.570 --> 25:19.570
通过B包

25:19.570 --> 25:20.570
我们将什么呢

25:20.570 --> 25:21.570
将这个变量的调用

25:21.570 --> 25:24.570
写到一个独立的这个空间里面

25:24.570 --> 25:26.570
从而一定程度上

25:26.570 --> 25:27.570
解决这个

25:27.570 --> 25:29.570
全局变量污染的问题

25:29.570 --> 25:30.570
那我们这边来看一下

25:30.570 --> 25:32.570
我这边给了段代码

25:32.570 --> 25:33.570
好 首先看全局

25:33.570 --> 25:35.570
全局是不是有个NEM

25:36.570 --> 25:37.570
对不对

25:37.570 --> 25:38.570
全局有个NEM

25:38.570 --> 25:40.570
NEM叫做GlobalNEM

25:40.570 --> 25:42.570
好 然后接下来的话

25:42.570 --> 25:43.570
你看我这边的话有一个Int

25:43.570 --> 25:47.570
Int的话是一个立即执行函数

25:47.570 --> 25:48.570
你注意看

25:48.570 --> 25:49.570
它是个立即执行函数

25:49.570 --> 25:50.570
立即执行函数

25:50.570 --> 25:51.570
然后执行完了之后

25:51.570 --> 25:52.570
它会返回一个什么

25:52.570 --> 25:56.570
是会返回一个这个立冥函数

25:56.570 --> 25:58.570
也就是说最终这个Int它是什么

25:58.570 --> 26:01.570
Int的话它是不是这个立冥函数

26:01.570 --> 26:02.570
对不对

26:02.570 --> 26:03.570
那这个立冥函数的话

26:03.570 --> 26:04.570
那这边调用什么呢

26:04.570 --> 26:06.570
调用这个callNEM

26:06.570 --> 26:07.570
callNEM里面

26:07.570 --> 26:09.570
然后打印输出

26:09.570 --> 26:10.570
打印输出NEM

26:10.570 --> 26:11.570
打印哪个NEM

26:11.570 --> 26:13.570
这不打印的是这个NEM

26:13.570 --> 26:14.570
对不对

26:14.570 --> 26:15.570
这个NEM和这个NEM

26:15.570 --> 26:17.570
会不会冲突

26:17.570 --> 26:18.570
会不会冲突

26:18.570 --> 26:19.570
它不会冲突

26:19.570 --> 26:20.570
对不对

26:20.570 --> 26:21.570
它不会冲突

26:21.570 --> 26:24.570
它是在它独立的这个空间里面

26:24.570 --> 26:26.570
那下面这个也是一样的

26:26.570 --> 26:27.570
也是一样的

26:27.570 --> 26:28.570
看到没有

26:28.570 --> 26:31.570
这边这个Int Super

26:31.570 --> 26:34.570
它也是返回一个立冥函数

26:34.570 --> 26:36.570
也就是说整个Int Super

26:36.570 --> 26:37.570
其实是这么一个函数

26:37.570 --> 26:38.570
这个函数的话

26:38.570 --> 26:40.570
最终调用callNEM

26:40.570 --> 26:41.570
callNEM这边的话

26:41.570 --> 26:42.570
要打印输出NEM

26:42.570 --> 26:43.570
那它这边的话

26:43.570 --> 26:45.570
对的就是这个NEM

26:45.570 --> 26:46.570
看到没有

26:46.570 --> 26:47.570
整个你看我这边的话

26:47.570 --> 26:48.570
整个代码里面

26:48.570 --> 26:49.570
定义了三个NEM

26:49.570 --> 26:50.570
但是三个NEM

26:50.570 --> 26:52.570
它是不会冲突的

26:52.570 --> 26:53.570
不会冲突的

26:53.570 --> 26:54.570
不仅这个NEM不会冲突

26:54.570 --> 26:55.570
你看这边

26:55.570 --> 26:56.570
相同的callNEM

26:56.570 --> 26:58.570
这边也不会冲突

26:58.570 --> 26:59.570
对不对

26:59.570 --> 27:00.570
因为它是一个函数

27:00.570 --> 27:01.570
函数的话

27:01.570 --> 27:02.570
它有独立的这个空间

27:02.570 --> 27:04.570
那我怎么通过这个外部

27:04.570 --> 27:05.570
访问到呢

27:05.570 --> 27:06.570
我这边是把这个

27:06.570 --> 27:07.570
立冥函数

27:07.570 --> 27:08.570
我把它返回出去

27:08.570 --> 27:09.570
对不对

27:09.570 --> 27:11.570
我把它返回到外部

27:11.570 --> 27:12.570
返回到外部的话

27:12.570 --> 27:13.570
外部就可以访问到了

27:13.570 --> 27:14.570
然后接下来

27:14.570 --> 27:16.570
我这个函数又引用了什么

27:16.570 --> 27:18.570
这引用了我这个

27:18.570 --> 27:20.570
立即执行函数

27:20.570 --> 27:22.570
内部的这些变量

27:22.570 --> 27:23.570
对不对

27:23.570 --> 27:24.570
因为你立即执行函数

27:24.570 --> 27:25.570
也是函数

27:25.570 --> 27:26.570
函数只要是函数的话

27:26.570 --> 27:27.570
它的这个区域

27:27.570 --> 27:29.570
它就是独立的

27:29.570 --> 27:30.570
它就是独立的

27:30.570 --> 27:31.570
看到没有

27:31.570 --> 27:32.570
这个的话就是

27:32.570 --> 27:33.570
早期使用这个必包

27:33.570 --> 27:35.570
来解决这个全局变量

27:35.570 --> 27:37.570
污染的这个问题

27:37.570 --> 27:38.570
这个的话

27:38.570 --> 27:40.570
也算是必包的一个应用

27:40.570 --> 27:41.570
好

27:41.570 --> 27:42.570
最后的话

27:42.570 --> 27:43.570
我们来对这个必包

27:43.570 --> 27:44.570
我们来做一个

27:44.570 --> 27:46.570
小小的这个总结

27:46.570 --> 27:47.570
好吧

27:47.570 --> 27:48.570
首先

27:48.570 --> 27:49.570
必包的话

27:49.570 --> 27:50.570
必包必包

27:50.570 --> 27:51.570
它就是一个什么

27:51.570 --> 27:54.570
它就是一个封闭的空间

27:54.570 --> 27:55.570
它里面存储了什么

27:55.570 --> 27:56.570
存储了其他地方

27:56.570 --> 28:00.570
会引用到该作用于的这个值

28:00.570 --> 28:01.570
对不对

28:01.570 --> 28:02.570
只要你其他

28:02.570 --> 28:04.570
其他地方你引用到了

28:04.570 --> 28:05.570
那我这边的话

28:05.570 --> 28:06.570
就会通过必包

28:06.570 --> 28:08.570
我给你存储起来

28:08.570 --> 28:09.570
对不对

28:09.570 --> 28:10.570
它会生成一个必包

28:10.570 --> 28:11.570
然后里面就存储了

28:11.570 --> 28:12.570
被引用到的值

28:12.570 --> 28:13.570
没有引用的

28:13.570 --> 28:14.570
对不对

28:14.570 --> 28:15.570
那它通过什么来实现的呢

28:15.570 --> 28:17.570
通过作用预链

28:17.570 --> 28:18.570
来实现的

28:18.570 --> 28:19.570
好

28:19.570 --> 28:20.570
第二个

28:20.570 --> 28:23.570
只要函数中使用了外部的数据

28:23.570 --> 28:25.570
是不是就会创建这个必包

28:25.570 --> 28:26.570
对不对

28:26.570 --> 28:27.570
然后这种情况下

28:27.570 --> 28:28.570
创建的这个必包

28:28.570 --> 28:30.570
我们在编码的时候

28:30.570 --> 28:32.570
我们是不需要去关心的

28:32.570 --> 28:33.570
这个就是什么

28:33.570 --> 28:35.570
这个就是自动创建的那种必包

28:35.570 --> 28:36.570
自动创建的必包

28:36.570 --> 28:38.570
我们是不需要去关心

28:38.570 --> 28:39.570
对不对

28:39.570 --> 28:40.570
不需要去关心

28:40.570 --> 28:41.570
你是不是创建了必包

28:41.570 --> 28:43.570
你是否销毁了必包

28:43.570 --> 28:44.570
不需要去关心

28:44.570 --> 28:45.570
对不对

28:45.570 --> 28:46.570
你想想你以前不知道

28:46.570 --> 28:47.570
这个必包这个自制点的时候

28:47.570 --> 28:49.570
你写代码是不是一样的不影响

28:49.570 --> 28:50.570
对不对

28:50.570 --> 28:51.570
一样的不影响

28:51.570 --> 28:52.570
然后还有种情况的话

28:52.570 --> 28:53.570
我们可以干嘛呢

28:53.570 --> 28:54.570
我们可以手动的

28:54.570 --> 28:56.570
通过一些手段

28:56.570 --> 28:58.570
手动创建必包

28:58.570 --> 28:59.570
就是什么呢

28:59.570 --> 29:01.570
就是返回一个这个函数

29:01.570 --> 29:02.570
然后这个函数

29:02.570 --> 29:03.570
返回到外部

29:03.570 --> 29:04.570
那这个函数的话

29:04.570 --> 29:05.570
又引用了

29:05.570 --> 29:07.570
就是你内部的一些便量

29:07.570 --> 29:08.570
对不对

29:08.570 --> 29:10.570
就比如说我们这个例子

29:10.570 --> 29:11.570
就比如说我们这个例子

29:11.570 --> 29:13.570
你这边返回了一个函数

29:13.570 --> 29:14.570
这个函数的话

29:14.570 --> 29:15.570
又用到了

29:15.570 --> 29:17.570
整个这个异特函数里面

29:17.570 --> 29:19.570
内部的一些便量

29:19.570 --> 29:20.570
那你这边的话

29:20.570 --> 29:22.570
他就会把整个这个空间

29:22.570 --> 29:23.570
整个这个空间

29:23.570 --> 29:25.570
形成一个这个封闭的空间

29:25.570 --> 29:26.570
封闭的空间

29:26.570 --> 29:27.570
甚至为是一个必包嘛

29:27.570 --> 29:28.570
对不对

29:28.570 --> 29:29.570
就会存在这么一个这个必包

29:29.570 --> 29:30.570
那这个负德的话

29:30.570 --> 29:32.570
他也就不会被销毁

29:32.570 --> 29:34.570
也就不会被销毁

29:36.570 --> 29:38.570
然后从而让外部狂心

29:38.570 --> 29:40.570
访问到寒说内部的局部便量

29:40.570 --> 29:41.570
让局部便量

29:41.570 --> 29:42.570
怎么呢

29:42.570 --> 29:44.570
就保存下来对不对

29:44.570 --> 29:46.570
这是关于这个必包的一个总结

29:46.570 --> 29:48.570
一个总结就这么3点

29:48.570 --> 29:49.570
就这么3点

29:49.570 --> 29:51.570
大家可以把视频暂停一下

29:51.570 --> 29:52.570
自己再看一看

29:52.570 --> 29:54.570
再捋一捋

29:54.570 --> 29:55.570
好

29:55.570 --> 29:56.570
然后最后的话

29:56.570 --> 29:57.570
我们这边的话

29:57.570 --> 29:59.570
来看一个这个必包的一个

29:59.570 --> 30:01.570
经典的这个问题

30:01.570 --> 30:02.570
这个必包的经典问题

30:02.570 --> 30:03.570
我们来看一下

30:03.570 --> 30:04.570
首先的话这边

30:04.570 --> 30:06.570
这边的话有一段这个代码

30:06.570 --> 30:07.570
我们这边把它拿过来

30:07.570 --> 30:08.570
我们来看一下

30:08.570 --> 30:11.780
好

30:11.780 --> 30:12.780
这里

30:12.780 --> 30:13.780
好

30:13.780 --> 30:14.780
我们来看一下这段代码

30:14.780 --> 30:15.780
这边的话

30:15.780 --> 30:16.780
我有一个护循环

30:16.780 --> 30:18.780
护循环简简单单

30:18.780 --> 30:19.780
从1

30:19.780 --> 30:20.780
然后循环到3

30:20.780 --> 30:21.780
也就是说123

30:21.780 --> 30:22.780
因为哀家家嘛

30:22.780 --> 30:23.780
也就是说123

30:23.780 --> 30:24.780
好

30:24.780 --> 30:25.780
然后每一次进护循环

30:25.780 --> 30:27.780
我设置了一个什么呢

30:27.780 --> 30:29.780
设置了一个set time out

30:29.780 --> 30:30.780
然后我让他干嘛呢

30:30.780 --> 30:32.780
我让他一秒钟之后

30:32.780 --> 30:34.780
打印输出这个i

30:34.780 --> 30:35.780
那我们这边我们来看一下

30:35.780 --> 30:36.780
首先这边i

30:36.780 --> 30:37.780
i的话是1

30:37.780 --> 30:38.780
1的话

30:38.780 --> 30:39.780
然后接下来的话这边进来

30:39.780 --> 30:40.780
进来的话一秒钟

30:40.780 --> 30:42.780
然后打印输出这个i

30:42.780 --> 30:43.780
那i的话照理说

30:43.780 --> 30:44.780
现在i是不是1

30:44.780 --> 30:45.780
对不对

30:45.780 --> 30:46.780
好

30:46.780 --> 30:47.780
然后接下来的话这边哀家家

30:47.780 --> 30:49.780
哀家家的话变成这个2

30:49.780 --> 30:50.780
2的话

30:50.780 --> 30:51.780
然后接下来的话过来

30:51.780 --> 30:52.780
过来的话

30:52.780 --> 30:54.780
然后接下来进这个

30:54.780 --> 30:55.780
护循环

30:55.780 --> 30:57.780
然后家这边应该打印输出2

30:57.780 --> 30:58.780
也就是说我们期望是什么

30:58.780 --> 31:00.780
期望输出的是

31:00.780 --> 31:02.780
是不是123

31:02.780 --> 31:03.780
对不对

31:03.780 --> 31:04.780
123

31:04.780 --> 31:07.280
但是你看一下实际结果

31:07.280 --> 31:08.280
实际结果

31:08.280 --> 31:10.280
实际结果打印输出的是什么呢

31:10.280 --> 31:13.280
打印输出的是444

31:13.280 --> 31:15.280
也就是说3个set time out

31:15.280 --> 31:18.280
输出的都是一样的

31:18.280 --> 31:19.280
那为什么呢

31:19.280 --> 31:21.280
这里的话实际上就是

31:21.280 --> 31:22.280
这里的话其实

31:22.280 --> 31:23.280
你不要小看这里的代码

31:23.280 --> 31:27.280
这里的代码其实也是用到了这个臂包

31:27.280 --> 31:29.280
也是涉及到一个臂包的问题

31:29.280 --> 31:30.280
我们想想

31:30.280 --> 31:31.280
我们回顾一下

31:31.280 --> 31:32.280
刚才在讲这个臂包的时候

31:32.280 --> 31:33.280
我们怎么说的

31:33.280 --> 31:35.280
只要你在调用函数的时候

31:35.280 --> 31:37.280
我们这边是不是会调用这个函数

31:37.280 --> 31:38.280
对不对

31:38.280 --> 31:39.280
它是一个匿名函数会调用

31:39.280 --> 31:41.280
只要你调用这个匿名函数

31:41.280 --> 31:45.280
而且你用到了它外部的辩量

31:45.280 --> 31:47.280
只要你用到外部的辩量

31:47.280 --> 31:49.280
是不是就会产生这个臂包

31:49.280 --> 31:50.280
对不对

31:50.280 --> 31:51.280
那你看一下我们这个匿名函数

31:51.280 --> 31:53.280
我们这个匿名函数里面

31:53.280 --> 31:54.280
打印这个i

31:54.280 --> 31:56.280
有没有这个i

31:56.280 --> 31:57.280
有没有啊

31:57.280 --> 31:58.280
同学们

31:58.280 --> 31:59.280
是没有

31:59.280 --> 32:00.280
没有的话

32:00.280 --> 32:01.280
它就会用哪个i

32:01.280 --> 32:02.280
它是不是就会去顺着

32:02.280 --> 32:03.280
它的作用语列

32:03.280 --> 32:04.280
往外部找

32:04.280 --> 32:05.280
是不是找到这个i

32:05.280 --> 32:06.280
对不对

32:06.280 --> 32:07.280
找到这个i

32:07.280 --> 32:08.280
也就是说你这边

32:08.280 --> 32:09.280
循环了三次

32:09.280 --> 32:11.280
三次的这个i

32:11.280 --> 32:12.280
最终都是什么

32:12.280 --> 32:13.280
最终的话都是

32:13.280 --> 32:14.280
通过作用语列

32:14.280 --> 32:16.280
去找的这个i

32:16.280 --> 32:17.280
也就是说他们最终

32:17.280 --> 32:18.280
访问的是什么呢

32:18.280 --> 32:21.280
访问的是同一个i

32:21.280 --> 32:22.280
明白吧

32:22.280 --> 32:27.040
他们访问的是同一个i

32:27.040 --> 32:29.040
那么访问的这个i

32:29.040 --> 32:30.040
这个i在一秒钟之后

32:30.040 --> 32:31.040
它是不是就变成4了

32:31.040 --> 32:33.040
因为你最后还要i加加一遍

32:33.040 --> 32:34.040
对不对

32:34.040 --> 32:35.040
你最后这边还要i加加

32:35.040 --> 32:36.040
所以最终就变成4

32:36.040 --> 32:38.040
说这个3个这个方形

32:38.040 --> 32:41.040
答应出来的都是4

32:41.040 --> 32:43.040
那我要解决这个问题

32:43.040 --> 32:44.040
怎么解决呢

32:44.040 --> 32:45.040
很简单

32:45.040 --> 32:46.040
那我这边的话

32:46.040 --> 32:47.040
我知道我这边

32:47.040 --> 32:48.040
访问的是外部的这个i

32:48.040 --> 32:50.040
最终访问的都是

32:50.040 --> 32:51.040
这个相同的

32:51.040 --> 32:52.040
是不是一个i

32:52.040 --> 32:53.040
那怎么办

32:53.040 --> 32:54.040
那我这边就是

32:54.040 --> 32:55.040
去除这个b包

32:55.040 --> 32:56.040
我这边怎么去除呢

32:56.040 --> 32:58.040
我这边的话

32:58.040 --> 33:00.040
我把它放到一个

33:00.040 --> 33:03.040
立即执行函数里面

33:03.040 --> 33:05.040
这边放到一个

33:05.040 --> 33:07.040
立即执行函数里面

33:07.040 --> 33:08.040
好然后放到

33:08.040 --> 33:09.040
立即执行函数里面之后

33:09.040 --> 33:10.040
然后接下来我这边的话

33:10.040 --> 33:11.040
我把这个i

33:11.040 --> 33:14.040
你参数的形式传递进来

33:14.040 --> 33:15.040
看了没有

33:15.040 --> 33:17.040
传递进来之后

33:17.040 --> 33:18.040
然后接下来的话

33:18.040 --> 33:20.040
把这一块我把它放进去

33:20.040 --> 33:24.760
然后在这边的话

33:24.760 --> 33:25.760
接收一下

33:25.760 --> 33:27.760
比如说这边叫做index

33:27.760 --> 33:28.760
ok

33:28.760 --> 33:31.760
然后在这边就打index

33:31.760 --> 33:32.760
你看我这边

33:32.760 --> 33:34.760
就做了一个简单的处理

33:34.760 --> 33:36.760
加了一个立即执行函数

33:36.760 --> 33:38.760
那这边的话结果就不一样了

33:38.760 --> 33:39.760
我们首先来看结果

33:39.760 --> 33:40.760
走

33:41.760 --> 33:42.760
看了没有

33:42.760 --> 33:43.760
是不是123

33:44.760 --> 33:45.760
对不对123

33:45.760 --> 33:46.760
那为什么和刚才就不一样了呢

33:46.760 --> 33:47.760
因为刚才我

33:47.760 --> 33:49.760
刚才我反复强调

33:49.760 --> 33:50.760
刚才你这边在

33:50.760 --> 33:52.760
打印这个i的时候

33:52.760 --> 33:53.760
它最终取得的是什么

33:53.760 --> 33:55.760
是4循环里面

33:55.760 --> 33:56.760
相同的这个i

33:56.760 --> 33:57.760
对不对

33:57.760 --> 33:58.760
但是这一次就不一样了

33:58.760 --> 34:00.760
这一次你外部加了一个

34:00.760 --> 34:01.760
这个立即执行函数

34:01.760 --> 34:02.760
你这边i是不是

34:02.760 --> 34:04.760
以参数的形式传递过来

34:04.760 --> 34:05.760
对不对

34:05.760 --> 34:07.760
那它第1次传递的就是1

34:07.760 --> 34:08.760
第2次传递的就是2

34:08.760 --> 34:10.760
第3次传递的就是3

34:10.760 --> 34:12.760
它用的是不同的这个

34:12.760 --> 34:14.760
你这边传递的这个i这个变量

34:14.760 --> 34:16.760
变量的这个值

34:16.760 --> 34:17.760
明白吧

34:17.760 --> 34:19.760
使用的是不同的这个变量值

34:19.760 --> 34:21.760
就和刚才就不一样了

34:21.760 --> 34:22.760
你看这边就是

34:22.760 --> 34:23.760
一个必报

34:23.760 --> 34:25.760
一个非常经典的这个问题

34:25.760 --> 34:27.760
因为刚才那种

34:27.760 --> 34:28.760
因为刚才

34:28.760 --> 34:30.760
我把这个去除你再看一下

34:31.760 --> 34:33.760
把这个去除掉

34:34.760 --> 34:38.290
这边

34:38.290 --> 34:39.290
因为刚才这里

34:39.290 --> 34:40.290
刚才这里的话

34:40.290 --> 34:41.290
它访问的是什么

34:41.290 --> 34:42.290
访问的始终是这个

34:42.290 --> 34:44.290
货循环里面的这个i

34:44.290 --> 34:46.290
三个这个方形

34:46.290 --> 34:48.290
访问的都是同一个这个i

34:48.290 --> 34:49.290
对不对

34:49.290 --> 34:50.290
你最终的话你这边

34:50.290 --> 34:51.290
因为你这个本身这个

34:51.290 --> 34:53.290
这里没有

34:53.290 --> 34:54.290
没有的话

34:54.290 --> 34:55.290
我得向我外乘这个

34:55.290 --> 34:56.290
终于率找

34:56.290 --> 34:57.290
找找找就找到谁了

34:57.290 --> 34:58.290
找到这个全局的了

34:58.290 --> 35:00.290
你注意这个是全局的

35:00.290 --> 35:01.290
这个是全局的

35:01.290 --> 35:03.290
就找到这个全局的了

35:03.290 --> 35:04.290
对不对

35:04.290 --> 35:05.290
所以最终的话

35:05.290 --> 35:06.290
这个的话

35:06.290 --> 35:07.290
分成了4

35:07.290 --> 35:08.290
所以最终的话

35:08.290 --> 35:09.290
打印出来都是4

35:09.290 --> 35:10.290
但是刚才那种

35:10.290 --> 35:11.290
就是这边

35:11.290 --> 35:12.290
就这边

35:12.290 --> 35:13.290
这个的话就不一样了

35:13.290 --> 35:14.290
这个的话你每次

35:14.290 --> 35:16.290
这边的话会把这个i的这个值

35:16.290 --> 35:18.290
是不是传给这个立即执行还说

35:18.290 --> 35:19.290
对不对

35:19.290 --> 35:21.290
那每一次传入这个i的这个值

35:21.290 --> 35:22.290
是不一样的

35:22.290 --> 35:23.290
那我这边的话

35:23.290 --> 35:24.290
我这里这个方形

35:24.290 --> 35:26.290
然后打印这个index

35:26.290 --> 35:27.290
index对于我这个

35:27.290 --> 35:28.290
还说里面是没有

35:28.290 --> 35:29.290
没有的话

35:29.290 --> 35:30.290
我外乘找我找到

35:30.290 --> 35:31.290
是不是这个方形

35:31.290 --> 35:32.290
是不是够传递进来了

35:33.290 --> 35:34.290
对不对

35:34.290 --> 35:35.290
够传递进来了

35:35.290 --> 35:36.290
第一次是1

35:36.290 --> 35:37.290
第二次传了是2

35:37.290 --> 35:38.290
第三次传了是3

35:38.290 --> 35:39.290
所以打印出来的

35:39.290 --> 35:41.290
就是123

35:41.290 --> 35:43.290
这就是必包很经典的一个问题

35:43.290 --> 35:45.290
以前出去面试的时候

35:45.290 --> 35:47.290
经常会被问到这个问题

35:47.290 --> 35:48.290
问你为什么

35:48.290 --> 35:49.290
为什么这边的话

35:49.290 --> 35:51.290
打印出来是444

35:51.290 --> 35:52.290
他首先会问你

35:52.290 --> 35:54.290
这个打印出来是多少

35:54.290 --> 35:57.290
如果你能正确回答说是444

35:57.290 --> 35:59.290
他就会问你为什么

35:59.290 --> 36:00.290
然后你说出为什么之后

36:00.290 --> 36:02.290
既然他会继续问你

36:02.290 --> 36:03.290
如何解决

36:03.290 --> 36:05.290
如何就是不通过A16

36:05.290 --> 36:07.290
不通过A16如何解决

36:08.290 --> 36:10.290
当然我们现在有了A16之后

36:10.290 --> 36:11.290
就很简单了

36:11.290 --> 36:12.290
就我们这个问题的话

36:12.290 --> 36:13.290
我们就直接把这个

36:13.290 --> 36:15.290
改成一个net就可以了

36:15.290 --> 36:16.290
你这边你看一下

36:16.290 --> 36:17.290
比如说我们这里

36:17.290 --> 36:20.290
把这个直接改成net

36:20.290 --> 36:22.920
保存一下

36:22.920 --> 36:23.920
这不就OK了

36:23.920 --> 36:24.920
对不对

36:25.920 --> 36:28.920
这就是关于必包的经典问题

36:28.920 --> 36:29.920
最后的话

36:29.920 --> 36:30.920
然后是关于

36:30.920 --> 36:32.920
整体的解答

36:32.920 --> 36:33.920
我们来看一下

36:33.920 --> 36:34.920
这边的话

36:34.920 --> 36:35.920
第一个问题

36:35.920 --> 36:36.920
必包是什么

36:36.920 --> 36:37.920
那必包的话

36:37.920 --> 36:38.920
它就是一个封闭的空间

36:38.920 --> 36:39.920
对吧

36:39.920 --> 36:40.920
里面存储了

36:40.920 --> 36:41.920
其他地方

36:41.920 --> 36:43.920
会引用到该作用域的这个值

36:43.920 --> 36:44.920
然后接受的话

36:44.920 --> 36:46.920
是通过这个作用域链

36:46.920 --> 36:47.920
来实现这个必包

36:47.920 --> 36:48.920
其实就是我们

36:48.920 --> 36:49.920
刚才这三句话

36:49.920 --> 36:51.920
还记不记得

36:51.920 --> 36:53.920
在哪里来着

36:53.920 --> 36:54.920
我看一下

36:54.920 --> 36:55.920
我总结的这里

36:55.920 --> 36:57.920
其实就是这三句话

36:57.920 --> 36:58.920
对不对

36:58.920 --> 36:59.920
就是这三句话

36:59.920 --> 37:00.920
你把它答出来就可以了

37:00.920 --> 37:01.920
第二个

37:01.920 --> 37:02.920
必包的应用场景有哪些

37:02.920 --> 37:04.920
那必包的应用场景

37:04.920 --> 37:05.920
我这边主要就介绍了什么

37:05.920 --> 37:07.920
解决一个全局辩量

37:07.920 --> 37:09.920
是污染的问题

37:09.920 --> 37:10.920
对不对

37:10.920 --> 37:11.920
但现在的话

37:11.920 --> 37:13.920
有了这个JS模块化了

37:13.920 --> 37:14.920
这边的话

37:14.920 --> 37:16.920
也不太需要去担心

37:16.920 --> 37:18.920
这个全局辩量污染的问题了

37:18.920 --> 37:20.920
那最后一个就是

37:20.920 --> 37:22.920
如何销毁这个必包

37:22.920 --> 37:24.920
那你如果是自动产生的必包

37:24.920 --> 37:25.920
就是我们比如说

37:25.920 --> 37:26.920
就是在调用函数的时候

37:26.920 --> 37:28.920
它自动产生的这个必包

37:28.920 --> 37:29.920
这个的话

37:29.920 --> 37:30.920
我们是不用去担心的

37:30.920 --> 37:31.920
它是不是调用完了

37:31.920 --> 37:32.920
对不对

37:32.920 --> 37:34.920
那如果我们是手动创建的这个必包

37:34.920 --> 37:36.920
那比如说你看这边

37:37.920 --> 37:38.920
比如这个

37:38.920 --> 37:39.920
这个的话

37:39.920 --> 37:40.920
我们是不是手动了

37:40.920 --> 37:41.920
我们返回了一个利民函数

37:41.920 --> 37:43.920
利民函数引用了这个负的

37:43.920 --> 37:44.920
对不对

37:44.920 --> 37:45.920
那也就是说在你全局里面

37:45.920 --> 37:47.920
这个必包是不是一直存在

37:47.920 --> 37:48.920
对不对

37:48.920 --> 37:49.920
一直存在

37:49.920 --> 37:50.920
它是不会自动销毁的

37:50.920 --> 37:51.920
你属于这种情况下的必包

37:51.920 --> 37:52.920
它是不会自动销毁的

37:52.920 --> 37:54.920
因为我把整个这个必包

37:54.920 --> 37:55.920
这个封闭的空间

37:55.920 --> 37:56.920
返回给了什么

37:56.920 --> 37:58.920
是不是返回给了外部全局环境

37:58.920 --> 37:59.920
对不对

37:59.920 --> 38:00.920
它不会销毁

38:00.920 --> 38:01.920
那不会销毁的话

38:01.920 --> 38:02.920
那我们就可以干嘛呢

38:02.920 --> 38:04.920
我们就可以手动

38:04.920 --> 38:05.920
手动设置一下

38:05.920 --> 38:07.920
把这个被引用的便量

38:07.920 --> 38:09.920
设置为这个NOW

38:09.920 --> 38:11.920
就是手动来清除这个便量

38:11.920 --> 38:13.920
那下一次的话

38:13.920 --> 38:16.920
这个JS的这个垃圾回收器

38:16.920 --> 38:18.920
它进行这个垃圾回收的时候

38:18.920 --> 38:19.920
它发现你这个便量

38:19.920 --> 38:20.920
已经没有用了

38:20.920 --> 38:21.920
对不对

38:21.920 --> 38:22.920
为什么

38:22.920 --> 38:23.920
因为你设置为NOW了

38:23.920 --> 38:24.920
设置为NOW它就没有用了

38:24.920 --> 38:25.920
没有用了

38:25.920 --> 38:26.920
它就会把它回收掉

38:26.920 --> 38:27.920
你记住

38:27.920 --> 38:29.920
就是JS的这个垃圾回收

38:29.920 --> 38:31.920
这个垃圾回收器

38:31.920 --> 38:32.920
就你这个便量

38:32.920 --> 38:33.920
只要再用

38:33.920 --> 38:34.920
我就不会回收

38:34.920 --> 38:35.920
只要没有用了

38:35.920 --> 38:37.920
我就会把它回收

38:37.920 --> 38:38.920
明白吧

38:38.920 --> 38:40.920
所以你这边要销毁

38:40.920 --> 38:41.920
手动创建的必包

38:41.920 --> 38:43.920
也可以通过这种方式

38:43.920 --> 38:44.920
好吧

38:44.920 --> 38:45.920
OK

38:45.920 --> 38:46.920
好

38:46.920 --> 38:48.920
这就是关于这个必包

38:48.920 --> 38:50.920
关于必包这一小节

38:50.920 --> 38:51.920
大家下去的话

38:51.920 --> 38:52.920
再把这一小节

38:52.920 --> 38:53.920
自己再看一看

38:53.920 --> 38:54.920
履履

38:54.920 --> 38:55.920
好

38:55.920 --> 38:56.920
这期课就先到这里

38:56.920 --> 38:57.920
再见

