WEBVTT

00:00.880 --> 00:02.920
大家好 我是谢老师

00:03.180 --> 00:07.540
这些课的话我们来看一下关于在接识中运算幅

00:07.800 --> 00:09.320
相关的内容

00:09.580 --> 00:11.380
首先的话 这边有一道题

00:12.140 --> 00:15.220
下面代码中A在什么情况下

00:15.480 --> 00:17.520
执行输出语句这个

00:17.780 --> 00:18.280
打印1

00:18.540 --> 00:19.580
他这边的A

00:20.080 --> 00:21.880
问你等于什么值的时候

00:22.120 --> 00:23.400
然后就在这边有个意义

00:23.660 --> 00:27.240
A等等1 并且A等等2 并且A等等3

00:27.500 --> 00:30.320
然后这个整体会返回去 是吧

00:30.320 --> 00:31.340
要进到这个E幅

00:31.860 --> 00:32.880
打印输出这个E

00:33.900 --> 00:35.700
好 这个的话就和运算幅

00:35.960 --> 00:36.460
相关了

00:36.980 --> 00:39.800
其实运算幅这一章节的话 本身

00:40.300 --> 00:41.840
就每个运算幅其实

00:42.100 --> 00:42.860
没什么难的

00:43.120 --> 00:47.220
但是呢 他会设计到什么呢 会设计到就是不同数据类型

00:47.720 --> 00:50.020
他这个数据类型的转换

00:50.280 --> 00:54.120
所以说我希望你听这节课的时候 你是先去把这个

00:54.640 --> 00:57.720
就我之前讲的这个数据类型的转换

00:57.960 --> 00:59.760
把这节课是先听了的

00:59.960 --> 01:01.760
你把这节课先听了然后

01:03.040 --> 01:04.060
再来听这个

01:04.320 --> 01:04.840
运算幅

01:05.600 --> 01:09.180
那我们一会讲那个运算幅的时候 那有些这个

01:09.440 --> 01:10.460
运算操作

01:10.720 --> 01:15.840
我也会就是带着大家来看这个转换的这个文档 两个结合起来看

01:17.380 --> 01:20.460
好 那这边来到我们的这个运算幅

01:21.480 --> 01:24.040
那运算幅我们来看一下 首先看一下左边的目录

01:24.300 --> 01:25.560
他大致氛围这么多

01:25.820 --> 01:28.140
首先第一个就是算数运算幅

01:28.860 --> 01:29.880
算数运算幅

01:30.140 --> 01:32.040
就是加减乘除

01:32.440 --> 01:33.020
取

01:33.460 --> 01:36.020
好 然后接下来就是这个比较运算幅

01:36.280 --> 01:38.080
比如大鱼小鱼

01:38.580 --> 01:41.140
大鱼等于小鱼等于啊

01:41.400 --> 01:43.460
然后全等不全等之类的

01:46.300 --> 01:48.860
然后接下来是这个布尔运算幅

01:49.260 --> 01:52.300
啊就是取反啊然后并啊货啊

01:52.560 --> 01:55.260
啊然后这还有一个三元运算幅啊

01:55.520 --> 01:57.300
也也归拉在这里面的

01:57.820 --> 01:59.360
好 然后未运算幅

01:59.560 --> 02:03.140
啊安慰与安慰非 安慰这个货

02:03.660 --> 02:05.800
然后还有就是一些其他的运算幅

02:06.060 --> 02:07.240
比如说这个维德呀

02:07.500 --> 02:08.280
斗号啊

02:08.540 --> 02:10.580
最后就是关于这个运算的这个顺序

02:10.840 --> 02:14.160
啊也就是说这个运算幅啊你不要看这个运算幅感觉很简单

02:14.420 --> 02:15.700
其实这里面内容挺多的

02:16.460 --> 02:18.000
挺多这个运算幅的啊

02:18.260 --> 02:18.760
然后

02:19.020 --> 02:20.820
不同的这个数据类型

02:21.580 --> 02:23.380
之间他又涉及到这个

02:23.640 --> 02:25.160
呃类型的转换

02:25.420 --> 02:27.720
啊所以我们这边的话一点一点来看

02:28.700 --> 02:29.580
那首先第一个

02:29.840 --> 02:36.620
第一个的话是算数运算幅啊在这个街市中共有10个算数运算幅我们来看一下

02:36.900 --> 02:39.700
首先的话是加法啊加

02:39.960 --> 02:40.720
减

02:40.980 --> 02:41.500
成

02:41.760 --> 02:42.260
除

02:42.780 --> 02:44.060
啊这个是最基本的

02:44.320 --> 02:47.640
然后既然这边还有指数啊指数是两个星

02:47.900 --> 02:49.340
然后接下来取

02:49.600 --> 02:54.540
然后自增自减啊然后加这个数值运算幅也就是说这边

02:54.800 --> 02:56.600
呃前面加个加号他就是正

02:56.800 --> 03:02.440
加个减号他就是负啊你看这个就是负数啊这个上面这个是正数下面这个是负数

03:02.960 --> 03:05.000
好那接下来我们这边一个一个来看

03:06.020 --> 03:08.340
那首先的话第一个是加法

03:08.840 --> 03:16.780
啊加法的话最常见的就是什么呢就是求两个数值的这个和啊这个非常简单啊比如说我们这边我们来看一下

03:17.040 --> 03:18.580
比如说加法运算幅

03:20.840 --> 03:22.880
加法运算幅

03:23.400 --> 03:24.920
啊这边呢我们log一下

03:25.700 --> 03:28.000
啊比如说1加2

03:28.560 --> 03:34.100
对吧非常的简单那这个的话就是一个3OK那这个的话你要注意一下什么呢

03:34.460 --> 03:37.520
就是如果是其他非数值类型

03:37.780 --> 03:40.860
注意非数值类型他也是可以相加的

03:41.880 --> 03:46.480
他这里会干嘛呢他这里的话就会把其他类型给你转换成这个数值类型

03:46.740 --> 03:49.560
比如像这边去加上一个去

03:50.320 --> 03:55.960
是不是一个这个布尔茲啊对不对两边都是布尔茲那他会干嘛呢他会把这个

03:56.540 --> 03:57.740
转换为这个

03:58.980 --> 04:05.480
啊转换为这个数值啊这边这个也是转换为数值啊比如我们这边我们来看一下log

04:08.320 --> 04:12.880
log q加上一个q啊走

04:13.560 --> 04:17.880
这不得到二对不对啊这边的话写一下啊就是非

04:19.000 --> 04:19.480
数值

04:20.880 --> 04:24.400
非数值会被转换

04:25.240 --> 04:26.160
为数值

04:28.470 --> 04:28.830
数值

04:30.270 --> 04:33.790
数值啊但这个非数值指的是什么就是非制服串

04:34.630 --> 04:44.270
因为如果是制服串的话他做的就是另外一种操作了叫做制服串拼接啊这里指的是非制服串啊比如说我们这边的话还有什么呢我们来看一下

04:45.870 --> 04:51.950
啊好像也就不也就布尔茲是吧布尔因为你如果是制服串的话那就是做制服串拼接了啊

04:52.670 --> 04:57.070
啊比如说我们这边我们来看一下哈比较特殊的是如果是这个有制服串

04:57.790 --> 05:04.430
那他做的是什么呢他做的是制服串拼接他不管你有几个制服串只要你其中有一个是制服串

05:04.990 --> 05:07.710
他就是做制服串拼接啊比如说我们来看这种

05:08.430 --> 05:08.830
有这个

05:12.540 --> 05:12.860
log

05:15.790 --> 05:24.270
啊你看我这边我这个三是不是制服串啊后面四和五是数字好他的这个运算他就是什么呢从左到右

05:24.990 --> 05:26.750
从左到右啊所以他这边那三

05:27.470 --> 05:31.390
先加上这个四他变成什么呢变成制服串的三四

05:31.390 --> 05:35.550
然后三四是一个制服串然后接下再加上五所以变成三四五

05:36.110 --> 05:36.270
走

05:37.230 --> 05:41.710
看到没有是不是三四五啊并且你看这边显示的是什么呢是白色的

05:42.750 --> 05:48.190
啊白色代表制服串你看刚才数字的话是不是这个黄色对不对啊

05:48.270 --> 05:50.270
然后接下来这边如果

05:52.270 --> 05:52.990
如果

05:55.150 --> 05:59.790
如果有一个操作数是制服串

06:01.230 --> 06:08.670
那么就是进行制服串的拼接

06:09.630 --> 06:12.670
看到没有啊好然后接下来下面

06:13.230 --> 06:16.350
下面的话我如果比如说我如果是对象

06:16.910 --> 06:19.710
啊因为上面我们举的是不是都是基本数据类型

06:20.270 --> 06:26.510
对不对Lumber然后接下来布林然后实均都是基本数据类型好那接下来如果是对象

06:28.990 --> 06:35.230
如果是对象啊我们来看一下他是怎么样的一个操作比如说我这边的话一个数组

06:35.870 --> 06:38.430
对吧数组然后加上一个1

06:39.310 --> 06:43.230
啊然后或者什么呢或者这边的话是一个这个对象

06:44.430 --> 06:46.670
加上一个1好那我们这边我们来看一下

06:47.630 --> 06:47.870
走

06:49.310 --> 06:54.750
你看这边得到的是什么上面这个得到的是啊1

06:55.550 --> 06:57.550
下面这个的话得到的是这个

06:58.910 --> 07:02.750
并且你观察一下上面这个1他是什么是不是制服串的1

07:03.390 --> 07:07.390
对不对那下面这个的话明显也是一个制服串好他这个怎么来的

07:07.790 --> 07:11.870
啊把这结果写在这里啊这个的话他是一个制服串的1

07:13.470 --> 07:15.790
好这个也是这个是制服串的

07:16.510 --> 07:19.470
345对吧这个是数字的2

07:20.270 --> 07:21.790
这个是数字的3

07:22.750 --> 07:24.350
好这个的话是制服串的这个

07:25.150 --> 07:31.470
他怎么来的他这里的话就涉及到一个什么呢就涉及到一个这个数据类型的这个转换了

07:32.670 --> 07:37.390
我们这边的话我们来看一下我们这个是不是对象对不对这个是不是也是对象

07:38.030 --> 07:44.430
说他需要干嘛呢他需要先把对象转换为什么呢转换为这个普通数据类型

07:44.830 --> 07:46.270
好那接下来我们这边我们来看一下

07:47.790 --> 07:49.390
来到这个数据类型转换这边

07:51.150 --> 07:52.670
好我们这边来看一下这个number

07:53.310 --> 07:55.390
这里啊然后接下来对象

07:56.190 --> 08:02.190
对象的话那这边就是什么呢他就是有这么几步啊首先的话调用自身的value of

08:03.310 --> 08:06.830
调value of然后调什么呢然后调图时维

08:08.030 --> 08:14.110
看到没有啊对象转number其实是这样子转的先调value of再调图时维

08:14.830 --> 08:19.710
啊但你如果之前听过这个数据类型转换这节课的话啊这个你应该是知道的

08:20.110 --> 08:25.710
没听过的我建议你先去把这个数据类型转换先听了这样你听这节课要轻松一些

08:26.910 --> 08:30.030
好这边的话就是先调value of然后调图时维

08:30.030 --> 08:34.380
所以说我们这边的话我们来打印一下log

08:35.580 --> 08:38.300
呃这个点这个value of

08:39.900 --> 08:40.460
value

08:41.500 --> 08:45.260
哦他先调value of如果你value of他还是一个对象

08:46.300 --> 08:48.380
那他就调什么呢他就调这个图时维

08:49.100 --> 08:54.460
调图时维如果还是一个对象他就抱错啊这个是之前讲过的我就不多说了啊

08:54.940 --> 08:57.740
好然后接下来的话这边调什么呢调这个图时维

08:59.260 --> 09:00.380
好我们这边我们来看一下

09:01.500 --> 09:08.220
你看这边的话我们先调这个value of调value of的话得到的是一个这个

09:08.860 --> 09:14.140
对不对然后接下来他再调图时维图时维图转称一个什么是转称一个控制圈

09:15.020 --> 09:22.300
对不对一个控制圈是不是转称制服圈了那制服圈的话然后接下来的话这边加上1是得到制服串的1

09:23.020 --> 09:30.540
对不对啊那那个那个对象也是一样的比如我们这边调用对象的value of

09:31.420 --> 09:33.100
然后这边to street

09:35.020 --> 09:37.020
好我们这边让我们来看一下我们把上面注释掉吧

09:37.980 --> 09:40.700
免得影响我们的这个观察

09:41.660 --> 09:44.860
好把这边把上面这都注释掉

09:45.900 --> 09:54.460
好走你看他这边的话首先value of是不是得到的是这么一个对象对不对那仍然是对象仍然是对象然后接下来调什么

09:54.700 --> 09:59.980
是不是调图时维调这个图时维是不是就得到这个对不对这个是个制服圈啊

10:00.540 --> 10:05.260
这是个制服圈好了接下最终执行的是什么是不是这个制服串

10:05.820 --> 10:12.620
和这个1啊和这个1的这个拼接对了因为只要有一方这个是制服串了

10:12.620 --> 10:15.980
他就是做制服串的拼接所以最终得到的是这个

10:16.940 --> 10:21.740
明白没有啊说我们这边我们来记一下哈如果是对象

10:23.100 --> 10:31.180
会什么呢会先将先将对象转为什么呢

10:31.900 --> 10:37.900
转为这个基本内心基本内心好那接下来这个对象

10:39.580 --> 10:43.980
对象转这个应该说这边的话是转为这个数字内心

10:45.180 --> 10:49.580
因为他调的是什么调的是这个吗因为他调的是这个Lumber

10:50.220 --> 10:56.060
所以调的是这个方法对不对调这个Lumber这个方法好然后接下来的话这边对象转

10:56.620 --> 10:57.260
转Lumber

10:58.300 --> 11:00.300
转Lumber会什么呢

11:01.420 --> 11:12.060
会先调用这个Value of如果得到的还是对象

11:13.660 --> 11:18.780
那么就会调用什么呢调用这个啊23

11:20.380 --> 11:24.620
是吧调用23啊然后如果23

11:24.940 --> 11:30.060
都还是对象那就

11:31.260 --> 11:31.660
保错

11:33.100 --> 11:37.980
看没有那他就保错啊当我们这边在调用txt的时候是不是已经得到制服串了

11:38.540 --> 11:42.220
对不对啊那这边的话他就是做这个运算了

11:42.780 --> 11:43.100
OK

11:44.460 --> 11:47.980
好这是关于这个对象回到我们那边

11:50.270 --> 11:53.470
回到我们这边就是这边啊对象的这个相加

11:54.190 --> 12:00.750
如果运算就一个操作数他是这个对象他必须先转成这个原始类型的值

12:01.150 --> 12:03.310
然后再相加对吧

12:04.510 --> 12:07.550
然后这边就没什么了啊你注意这个是可以覆盖的啊

12:08.110 --> 12:09.790
这是可以覆盖的比如什么意思

12:10.270 --> 12:10.990
比如说我们这边

12:12.830 --> 12:16.750
呃我们这边的话现在打印这个他是不是得出这个

12:17.550 --> 12:20.830
对不对object object1让我这边的话我可以干嘛呢

12:21.150 --> 12:22.510
我这边的话可以这个样子

12:22.990 --> 12:26.270
嗯我想想啊我把这个我把这个先提出来

12:26.510 --> 12:28.670
有挖一个obj

12:30.030 --> 12:30.830
等于一个

12:34.780 --> 12:39.180
好挖一个这个obj啊我这边的话给他一个值比如说nam

12:39.740 --> 12:41.740
等于一个啊比较细节

12:42.060 --> 12:44.060
OK好那这样我这边的话obj

12:45.260 --> 12:49.900
obj来和这个e相加那这个是这个时候啊答案大家都知道

12:50.460 --> 12:51.340
这不得到的是这个

12:52.060 --> 12:56.220
对不对好然后接下来的话我们知道他在转换的时候他会先掉

12:56.460 --> 13:01.660
这个value of再掉2是最好然后接下来我这边呢我把这个value of我给他覆盖掉

13:03.020 --> 13:06.060
可没有我把他这个原来的这个value of

13:06.540 --> 13:07.660
我给他覆盖掉

13:08.300 --> 13:12.620
我这边的话我手动反回什么呢手动反回比较反回一个数字2

13:13.500 --> 13:16.700
那回头他在掉这个value of的时候是不是拿到就是拿到一个2

13:17.260 --> 13:21.100
2是不是就已经不是对象了对不对他就用这个2和这个e相加

13:21.420 --> 13:23.740
说他最终得到就什么呢得到的就是3

13:24.860 --> 13:28.220
可没有得到的就是3啊这点的话注意啊

13:29.260 --> 13:29.740
好

13:30.780 --> 13:35.100
这是关于这个啊对象如果有一个值是对象的话

13:36.140 --> 13:39.820
好然后接下来下面啊我看这边啊这边的话还有一个

13:41.020 --> 13:44.540
有一个特例如果一个操作数它是什么呢它是date

13:45.260 --> 13:49.820
对象的实力它是先优先执行什么呢先优先执行to stream的

13:50.380 --> 13:53.500
我们刚才看到是不是他先啊我们这边如果是对象

13:53.740 --> 13:57.900
他在转这个原始类型的时候啊他是先调什么是不是先调value of

13:58.540 --> 14:00.460
再调什么是不是再调to stream

14:01.340 --> 14:03.100
对不对那这个的话刚好相反

14:03.900 --> 14:08.140
这个date它刚好相反它这个它是先调什么呢先调这个

14:08.620 --> 14:12.780
to stream然后再调value of好我们这边我们来看一下吧

14:14.300 --> 14:15.420
把这个注射掉

14:15.820 --> 14:21.820
好比如说啊我看一下哈啊比如这边

14:23.100 --> 14:24.380
哇一个d

14:24.620 --> 14:29.850
等一个new date那他是不是一个date对象

14:30.090 --> 14:33.690
好那接下来我们这边nog d加上一个e

14:33.930 --> 14:38.810
走啊你看他这边得到了是不是这个对不对后面拼接一个e

14:39.050 --> 14:43.930
那我们来看他是先调的是哪个呢啊我们怎么来看他先调的哪个呢

14:44.650 --> 14:49.210
好我们这边的话可以这边我们来去覆盖他的那个

14:49.770 --> 14:51.050
就是to stream

14:52.330 --> 14:55.130
to stream方法等于一个方形

14:56.490 --> 14:59.770
好to stream的话然后将我们这边覆盖我们给他返回一个2

15:00.490 --> 15:04.650
对吧好让他在这边d点这个value value of

15:06.010 --> 15:07.690
也把它覆盖掉好

15:08.330 --> 15:10.810
这个的话我们给他返回一个3

15:11.530 --> 15:15.370
那最后我们看这边你这个加1如果得到最终值是3

15:16.010 --> 15:19.530
那说明的话他这边是不是先调的to stream对不对这边得到2

15:19.850 --> 15:23.450
如果最终得到的值是4那说明是不是调的是这个value of

15:24.090 --> 15:26.890
对不对好那接下来我们这边走一个走

15:30.090 --> 15:33.770
我看一下啊对的对的这边那是不是先调to stream

15:35.290 --> 15:39.770
对不对先调的这个to stream啊所以这边的话拿到这个2加1

15:40.010 --> 15:43.290
就得到3就和上面是上面是不一样的

15:43.690 --> 15:48.970
上面的话他是什么呢他是先调value of再调to stream啊比如说我们这边

15:49.450 --> 15:57.960
我们来看一下把这个打开

15:59.320 --> 16:02.840
把这个打开好打开之后然后我们这边一个value of

16:03.320 --> 16:05.160
一个to stream

16:06.520 --> 16:10.040
好然后下这边的话就一刷一个比如说3

16:11.000 --> 16:12.920
ok好那这样我们这边我们来看一下

16:13.880 --> 16:17.160
他如果得到的是说明是不是先调的2 stream

16:17.160 --> 16:20.520
如果得到的3是不是得说明先是调用的value of

16:21.080 --> 16:24.840
对不对好还下面20秒下面出事了好我们这边运行

16:25.800 --> 16:31.400
说得到的是3啊对不对得到的是3说明什么是不是先调的是value of

16:32.280 --> 16:37.480
对不对啊好回到我们这边好这是关于这个

16:38.440 --> 16:41.960
加法啊好然后下这边来看一下这个余述

16:43.800 --> 16:48.760
好余述的话他是返回就是两个数的他的这个余述

16:49.560 --> 16:53.560
他就就是啊返回他的这个余述啊比如这个举个例子吧

16:54.840 --> 16:59.880
余述运算符好这边的话就是我们这边介绍了这个加法啊加法要特殊点

16:59.880 --> 17:04.760
然后其他的这个减法惩法处罚那就是正常的和数学里面是一样的

17:05.560 --> 17:11.160
如果是那个不同类型的啊他比如说支付创他会转一下比我们这边我们来看一下

17:12.200 --> 17:15.560
比如说loglog比如支付创的5

17:16.280 --> 17:20.920
减去一个支付创的2那他这边的话就是什么呢他就不再是一个拼接了

17:20.920 --> 17:23.400
他就是会把这个转成这个

17:24.440 --> 17:27.880
数字这个转成数字说最终得到的是3

17:28.360 --> 17:33.240
看没有啊然后接下来你这边的话比如说log比如说我

17:34.920 --> 17:42.680
减去一个这个q减去一个q那得到就是是不是是对吧好了你如果是就是有对象

17:42.680 --> 17:48.120
有对象的话他就转转转不出来反正就是nn啊比如说我们这边加一个对象

17:48.120 --> 17:51.880
啊不不不能加减去一个这个支付创的2

17:52.440 --> 17:54.840
那最终他一定是得到的是一个number内心

17:55.320 --> 17:59.720
一定是个number内心那这个的话你没办法做减法对吧说他最终得到的就是

18:01.000 --> 18:03.000
可乐秒啊这个就不多说了啊

18:03.720 --> 18:05.560
好这边写一下就是呃

18:07.160 --> 18:08.200
四则运算

18:08.760 --> 18:10.680
我们称之为四则运算吧

18:10.680 --> 18:15.080
四则运算中的这个减

18:15.720 --> 18:16.520
然后乘

18:17.400 --> 18:22.520
然后除是吧除除我应该用那个就这个吧减成除都是

18:23.480 --> 18:24.840
都是转成

18:26.200 --> 18:27.640
转成这个数值

18:28.920 --> 18:33.960
数值进行运算即可啊如果

18:35.240 --> 18:38.760
如果无法转为数值

18:40.040 --> 18:40.440
数值

18:41.640 --> 18:47.240
那么最终得到的就是n a n

18:48.360 --> 18:52.040
对吧反正我最终会得到一个数字那这个数字的话你比如像这种

18:52.200 --> 18:53.640
你没办法做这个减法运算

18:54.520 --> 18:58.520
那得到的就是什么呢得到的就是n a n啊这个就不多说了

18:59.080 --> 19:01.880
好然后刚才说到那个余数是吧啊我们这边余数

19:03.080 --> 19:03.720
余数

19:05.400 --> 19:10.680
余数啊余数也很简单是吧就比如说我这边我对二取于

19:11.320 --> 19:13.560
那这个5对2取于然后3就是多少

19:14.200 --> 19:17.400
3是不是就是2然后于多少什么于1对对

19:17.400 --> 19:21.160
所以这里的话得到的值就是1啊这个也没什么好说的

19:21.880 --> 19:26.840
好然后注意啊就是运算结果的这个正负号由第一个

19:27.400 --> 19:30.520
运算值那就操作数嘛就由第一个操作数

19:30.760 --> 19:36.040
正负号来决定不要这边负1对这个2取于啊得到负1

19:36.520 --> 19:40.280
1对负2取于得到这个1啊你注意这里有个规律

19:41.560 --> 19:43.560
有个规律就是在座

19:44.920 --> 19:47.000
在座这个取于

19:47.960 --> 19:55.560
取取取取于运算时运算时啊小数

19:56.920 --> 19:57.480
小数

19:59.480 --> 20:06.200
小数对大数对大数取这个于

20:08.040 --> 20:11.720
取于啊直接得到

20:12.920 --> 20:13.640
这个小数

20:14.600 --> 20:15.640
小数

20:16.920 --> 20:20.120
啊就你算都不用去算啊比如说我这边log

20:20.600 --> 20:25.880
啊比如说我这边3对这个100取于那是不是小数对大数取于

20:25.880 --> 20:28.680
那得到的就是这个小数那我们这边我们来看一下走

20:29.080 --> 20:30.520
这就得到这个小数本身

20:31.160 --> 20:37.240
为什么因为他3不起嘛对不对他3为0嘛然后于是3嘛对不对啊

20:37.240 --> 20:40.440
说这边的话就是直接就返回这个小数啊

20:40.600 --> 20:44.040
然后接下来你这边注意就是如果他有政府号的话

20:44.040 --> 20:49.560
这个政府号取决于第一个数就前面的数啊比如这边1对负2取于

20:50.040 --> 20:54.520
这不也是小数对大数对不对好那接下来这边的话log

20:55.800 --> 20:57.720
得到就收到得到就是1

20:58.200 --> 20:59.720
看到没有得到就是1

21:00.680 --> 21:01.080
好

21:02.520 --> 21:08.520
这是这个于数啊啊所以为了得到这个负数的正确于数值

21:08.600 --> 21:13.400
可以先干嘛先使用绝对值含数啊比我们来看一下这边啊

21:13.720 --> 21:15.640
这边让我们接收一个数

21:16.040 --> 21:20.040
然后我们要看这个数他的这个对二取于是否等于1

21:20.680 --> 21:21.240
那我这边

21:22.200 --> 21:22.920
传这个负5

21:23.640 --> 21:28.200
负5的话他得到的也是负4传这个负4也是这个负4

21:28.680 --> 21:32.600
为什么因为这个负4对2取于得到是什么得到是不是负2

21:33.720 --> 21:35.080
啊我看一下我想想

21:35.800 --> 21:39.640
哦这这这这个啊这个是本来就是负4这个负5

21:40.360 --> 21:42.360
负5对这个2取于

21:43.080 --> 21:47.960
得到的是多少得到的是不是负1啊对不对得到的是负1啊

21:48.280 --> 21:51.720
所以你这边就可以干嘛呢先做这个啊用绝对值

21:52.280 --> 21:55.480
把它转一下转了之后再进行一个判断

21:57.320 --> 22:02.760
然后于数运算符也可以用于什么呢也可以用于浮点数的运算啊比如这个

22:03.080 --> 22:04.920
但是我们知道这个浮点数运算它是

22:05.480 --> 22:06.200
不精确的

22:06.760 --> 22:10.120
对吧这个之前我们讲过浮点数它无法精确的这个

22:10.680 --> 22:12.040
存储和运算

22:14.280 --> 22:18.360
好然后下一个下一个是这个自帧自减运算符

22:19.000 --> 22:20.920
啊这个的话你就注意这个加加

22:21.480 --> 22:24.280
在前和加加在后的这个区别

22:24.760 --> 22:27.080
啊我们这边我们来看一下自帧自减

22:31.290 --> 22:31.850
自帧

22:33.530 --> 22:33.930
自减

22:36.960 --> 22:37.600
自帧自减

22:38.880 --> 22:39.360
需要

22:40.480 --> 22:43.040
注意的就是这个

22:43.920 --> 22:48.960
嗯超这个符号就运算符运算符在前

22:50.320 --> 22:52.800
在前和在后

22:54.160 --> 22:54.880
的区别

22:55.760 --> 22:57.120
好如果是在前

22:58.560 --> 23:01.760
在前是不是先做这个自帧或者自减

23:02.960 --> 23:07.760
先做自帧或者自减

23:10.410 --> 23:10.810
对不对

23:11.210 --> 23:13.930
然后再参与运算

23:16.750 --> 23:17.470
运算啊

23:18.030 --> 23:19.150
如果是在后

23:20.910 --> 23:24.750
在后那是先做运算

23:25.470 --> 23:31.070
然后再自帧或者自减

23:37.340 --> 23:38.780
看没有啊这个区别

23:39.100 --> 23:40.460
好那我们这边让我们来看一下

23:40.940 --> 23:41.580
不用我们这边

23:42.300 --> 23:44.700
哇一个这个哎再一个一

23:45.340 --> 23:46.700
好然后接下来的话这边

23:47.820 --> 23:49.340
哇一个这个接

23:49.900 --> 23:53.980
等于一个什么呢等于一个这个i加加加上一个

23:55.900 --> 24:00.220
ok好然后接下来我们这边log一下分别log一下i和接

24:01.580 --> 24:03.820
i的话它肯定是最终会变成2的

24:04.300 --> 24:06.620
对不对这个i你打赢它始终是2

24:06.860 --> 24:07.820
关键就是这个接

24:08.700 --> 24:11.980
接的话它是等于i加加然后加上一个5

24:12.380 --> 24:13.500
你这个符号是什么

24:14.140 --> 24:15.260
这个是不是在后面

24:16.060 --> 24:16.540
对不对

24:16.540 --> 24:17.260
它是在后面

24:17.580 --> 24:18.860
在后面的话它是什么呢

24:18.860 --> 24:19.900
先做运算

24:19.900 --> 24:21.180
也就是说这边的话这个

24:21.660 --> 24:25.660
i这个先加上这个5

24:25.900 --> 24:27.420
i是1嘛加上这个5

24:27.820 --> 24:28.700
5是这个6

24:29.100 --> 24:30.540
然后接下来这边接的只是6

24:30.940 --> 24:32.620
然后接下来这个i在干嘛呢

24:32.780 --> 24:33.340
再自帧

24:33.740 --> 24:36.620
所以说我们这边看到的这边输出的就应该是2

24:36.940 --> 24:38.220
然后接下来这个是6

24:40.640 --> 24:41.040
看到没有

24:41.680 --> 24:42.320
2和6

24:42.560 --> 24:44.160
但我如果我把这个改一下

24:45.120 --> 24:46.400
我如果是加加i

24:47.120 --> 24:48.000
那这个

24:48.240 --> 24:50.240
这个自帧的这个符号是不是在前了

24:50.480 --> 24:52.800
在前了就会先做这个自帧运算

24:53.520 --> 24:55.120
自帧运算它这边就变成多少

24:55.360 --> 24:56.000
这变成2

24:56.640 --> 24:59.200
变成2然后加上5所以接的值就是7

24:59.440 --> 25:00.480
所以这边的话就是2

25:01.120 --> 25:01.520
7

25:01.760 --> 25:02.800
那我就来看一下

25:03.040 --> 25:03.540
走

25:04.560 --> 25:04.960
看到没有

25:05.360 --> 25:06.240
2和7

25:06.640 --> 25:10.720
好然后一般在开发的时候我们会屏蔽这个

25:11.200 --> 25:13.520
这个加加符号在前还是在后

25:14.240 --> 25:15.120
的这个区别

25:15.120 --> 25:16.960
所以我们一般不建议大家这样子写

25:16.960 --> 25:18.080
我们一般会怎么样子呢

25:18.080 --> 25:19.680
我们这边会让这个i加加

25:19.920 --> 25:20.640
单独

25:20.880 --> 25:21.920
成为一条语句

25:22.480 --> 25:25.040
单独成为一条语句之后我管你是在前面

25:25.280 --> 25:26.080
还是

25:26.320 --> 25:27.600
这样子是吧

25:27.600 --> 25:29.920
我管你是在前面还是在后面

25:29.920 --> 25:32.400
反正你执行完这个62行代码之后

25:32.400 --> 25:34.000
你这个i是不是就自帧1了

25:34.480 --> 25:36.720
对不对好那我这边的话一定得到是多少

25:36.720 --> 25:37.600
是吧2和7

25:39.200 --> 25:39.840
看到没有啊

25:39.840 --> 25:41.120
无论你是这个样子

25:41.520 --> 25:42.160
还是

25:42.400 --> 25:42.960
这个样子

25:43.520 --> 25:44.800
那一定得到的是

25:45.040 --> 25:45.840
2和7

25:46.080 --> 25:48.640
在开发的时候我们一定会去屏蔽这个区别的

25:49.280 --> 25:51.840
没有因为这个你写到这里面

25:52.480 --> 25:53.760
就是会给我们的阅读

25:54.000 --> 25:54.800
带来不变

25:55.280 --> 25:57.840
面试的时候他喜欢考你对吧

25:57.840 --> 26:00.160
他就考你知不知道这个的区别

26:01.680 --> 26:04.000
这是关于这个自帧和自解

26:05.520 --> 26:08.080
运算之后变量的值会发生变化

26:09.120 --> 26:11.920
这种效应我们叫做运算的负作用

26:12.080 --> 26:13.920
塞的这个

26:15.440 --> 26:18.080
好其他的话就没什么了

26:18.320 --> 26:19.840
然后后面下一个

26:20.880 --> 26:22.400
数值运算幅

26:23.200 --> 26:24.720
负数值运算幅

26:25.520 --> 26:26.400
好这个就是什么了

26:26.400 --> 26:28.800
这个就是你加一个正号他就是正数

26:29.120 --> 26:30.720
加一个减号他就是负数

26:31.360 --> 26:32.400
比我们这边我们来看一下

26:33.200 --> 26:33.680
下一个

26:34.320 --> 26:35.440
数值运算幅

26:41.580 --> 26:42.620
比如说我们这边

26:44.380 --> 26:46.220
log一个比如说政府

26:46.460 --> 26:48.540
政府的话让你前面写个这个加

26:48.780 --> 26:50.860
加5那他是不是就代表是正我

26:51.340 --> 26:54.140
对不对那我们这边的话我们来打印一下走

26:54.540 --> 26:57.500
打印出来就是我对吧那你如果是个减号

26:57.740 --> 27:00.060
前面是个减号是不是代表就是负的

27:00.540 --> 27:02.220
那他就是负

27:02.620 --> 27:03.900
对不对这个很简单

27:04.140 --> 27:06.220
但是你要注意一下如果你这边的话

27:06.940 --> 27:09.900
前面不是数字前面是什么前面是比如说

27:10.300 --> 27:12.460
是这个布尔茲呀

27:12.780 --> 27:13.900
或者是这个

27:14.620 --> 27:16.060
这个对象啊

27:16.220 --> 27:17.500
对吧数组或者对象啊

27:17.740 --> 27:20.580
他这边的话他其实也是会干嘛呢会把这些

27:20.820 --> 27:22.620
转换为这个数字的

27:23.380 --> 27:25.420
他怎么转他就是通过这个 number 喊说

27:26.220 --> 27:27.980
通过这个 number 喊说我们这边我们来看一下

27:29.660 --> 27:31.580
这边比如说把这个注释掉

27:33.840 --> 27:35.120
比如说log

27:36.920 --> 27:39.480
log 然后加一个正的q

27:40.240 --> 27:41.520
或者负的q吗

27:42.040 --> 27:42.560
负的q

27:43.080 --> 27:44.080
好这边走

27:44.360 --> 27:46.520
看到没有最终是不是得到的是非

27:46.980 --> 27:49.040
好然后接下来这边log 一下

27:49.540 --> 27:51.080
比如说负的一个数组

27:51.840 --> 27:52.360
负的

27:52.880 --> 27:54.160
一个这个对象

27:54.920 --> 27:55.940
然后下这边走

27:57.220 --> 27:59.780
看到没有这个的话就转化是什么了负0

28:00.040 --> 28:02.340
这个的话就是没办法转就是NAN

28:02.600 --> 28:05.680
当有的同学会觉得很奇怪哈为什么你这个数组

28:06.180 --> 28:07.340
都转成了是负0

28:07.600 --> 28:10.020
那你这个为什么对象就是NAN

28:10.280 --> 28:11.820
那很简单其实这个就是

28:12.080 --> 28:14.640
你搞清楚他的本质之后他本质就是什么

28:14.900 --> 28:16.180
是不是使用的是Lumber函数啊

28:16.720 --> 28:20.560
对不对Lumber函数的话我们刚才其实答应出来已经看到了

28:20.820 --> 28:24.660
你数组的话是不是他最终转成那个支付串他是一个空置串

28:25.440 --> 28:28.240
对不对空置串的话在转换的时候

28:28.500 --> 28:29.520
我们这边我们来看一下

28:30.300 --> 28:31.320
空置串

28:32.860 --> 28:33.360
这里

28:33.620 --> 28:36.440
空置串转的时候是不是就是转成0啊

28:37.200 --> 28:39.000
对不对空置串他转就是转成0

28:39.260 --> 28:40.540
但是你这个对象就不一样了

28:40.800 --> 28:43.100
你这个对象转出来最终是哪个东西

28:43.360 --> 28:45.140
你转出来的支付串是不是这玩意儿

28:45.900 --> 28:46.420
对不对

28:46.720 --> 28:49.080
他不是说是空置付串他转出来是这个东西

28:49.600 --> 28:50.360
所以最终

28:50.620 --> 28:52.920
这个东西然后就让你去做这个运算

28:53.180 --> 28:55.220
说得到的是不只能设NAN

28:56.000 --> 28:57.280
对不对注意这个区别啊

28:57.780 --> 28:58.800
我这边给你写一下

28:59.580 --> 29:00.340
就是

29:01.360 --> 29:02.140
之所以

29:02.900 --> 29:04.700
之所以这个数组

29:05.720 --> 29:07.260
转出来空数组

29:07.520 --> 29:08.280
空数组

29:08.800 --> 29:09.560
转出来

29:10.580 --> 29:11.600
设这个

29:11.860 --> 29:12.380
0

29:14.420 --> 29:15.700
设因为

29:16.980 --> 29:18.000
空数组

29:18.260 --> 29:19.300
在

29:19.800 --> 29:20.820
转为

29:21.080 --> 29:22.360
制服串的时候

29:22.880 --> 29:24.400
制服串的时候

29:24.920 --> 29:25.680
得到

29:26.460 --> 29:28.000
得到的是

29:28.260 --> 29:29.780
空置付串

29:30.300 --> 29:31.060
对不对

29:31.320 --> 29:33.360
然后空置付串

29:33.880 --> 29:35.160
转为

29:35.420 --> 29:36.180
数字

29:36.440 --> 29:37.460
就是什么呢

29:37.720 --> 29:38.240
就是0

29:39.000 --> 29:40.280
啊而你这个对象

29:40.540 --> 29:41.560
对象的话

29:41.820 --> 29:42.580
他拿到了是什么

29:44.120 --> 29:44.880
而

29:45.140 --> 29:46.160
这个对象

29:48.180 --> 29:50.220
转这个制服串

29:50.480 --> 29:54.060
得到的是什么呢得到的是这个玩意儿

29:55.600 --> 29:56.880
得到的是这个玩意儿

29:57.900 --> 29:58.400
对不对

29:58.660 --> 30:02.100
得到的是这个玩意儿这个玩意儿的话那你这个就没办法转成数字

30:02.360 --> 30:04.560
说最终得到的是就是什么是NNN

30:05.060 --> 30:07.120
好我这边呢我强调是什么呢是空数组

30:07.620 --> 30:09.920
你如果不是空数组的话他转出来的话

30:10.180 --> 30:11.460
制服串他不是这个0

30:12.220 --> 30:14.020
我们这边我可以来看一下比如说我们这边

30:14.280 --> 30:14.780
LOG

30:16.020 --> 30:17.860
LOG比如说我们这边呢LUMBER

30:18.680 --> 30:19.760
大家这边一个数组

30:20.020 --> 30:22.460
因为我们知道他转数字最终其实调的就是什么

30:22.720 --> 30:24.100
调的就是这个LUMBER函数

30:24.360 --> 30:25.380
对吧那我们这边可以

30:25.640 --> 30:26.660
比较给他写一个东西

30:27.700 --> 30:28.200
走

30:28.960 --> 30:29.480
看到没有

30:29.740 --> 30:30.760
这边得到的就是什么

30:31.020 --> 30:31.780
NNN啊

30:32.560 --> 30:33.060
看到没有

30:35.360 --> 30:37.680
好但是你如果是一个数的话

30:38.440 --> 30:40.740
一个数的话他转出来就多少呢就是1

30:41.000 --> 30:41.760
就是1

30:42.020 --> 30:42.520
走

30:43.560 --> 30:44.060
看到没有

30:44.320 --> 30:44.840
就是1

30:45.100 --> 30:47.140
这个的话是之前我在讲那个

30:47.600 --> 30:49.400
数据类型转换的时候

30:49.660 --> 30:50.420
我讲过的

30:51.440 --> 30:53.480
就是你那个数组如果有一个数

30:54.000 --> 30:55.800
他转出来可以给你转成这个LUMBER

30:56.060 --> 30:58.860
但是你如果就是数组没有多个数他转出来的就是什么

30:59.120 --> 30:59.900
就是NNN

31:00.160 --> 31:01.680
你可以把那些可以去听一下

31:02.440 --> 31:02.960
为什么

31:03.220 --> 31:04.760
我讲了为什么其实就是什么呢

31:05.280 --> 31:06.040
就是这个过程

31:06.300 --> 31:07.840
他先用VALUE OF

31:08.340 --> 31:11.160
VALUE OF转出来是什么样子然后接下来这个TOO STREAM

31:11.660 --> 31:12.440
转出来是什么样子

31:12.700 --> 31:14.240
一步一步去分析

31:14.240 --> 31:14.760
好

31:16.540 --> 31:18.580
好这是关于这个数值

31:18.840 --> 31:21.140
数值运算幅和负数值运算幅

31:21.400 --> 31:21.660
政府

31:24.900 --> 31:31.040
然后这个负数运算幅也同样去有将一个值转为数值的功能就是

31:31.300 --> 31:31.800
正负取反

31:32.060 --> 31:34.100
比我们这边我们来看一下x是1

31:34.360 --> 31:35.900
负x就是负1

31:36.160 --> 31:38.980
对吧负负也开始那就又变回来了

31:39.240 --> 31:40.000
变成1

31:40.780 --> 31:41.280
对不对

31:41.540 --> 31:42.560
这个就不说了

31:43.320 --> 31:44.100
下一个

31:44.300 --> 31:45.580
指数运算幅

31:45.840 --> 31:47.640
这个是ES6新增加的

31:48.140 --> 31:49.180
我们这边我们来看一下

31:49.420 --> 31:50.200
指数运算幅

31:56.180 --> 31:56.960
指数

31:59.350 --> 32:00.370
指数运算幅

32:00.630 --> 32:03.450
好指数运算幅的话这边的话比如说我们这边LOCK一下

32:04.210 --> 32:05.750
比如说2的

32:06.770 --> 32:07.810
三次方

32:09.590 --> 32:10.350
就得到这个8

32:10.870 --> 32:13.950
对不对以前的话你这个在ES6之前你得怎么写

32:14.210 --> 32:15.990
ES6之前你得这么来写

32:16.510 --> 32:19.070
就是得通过调这个MES

32:19.530 --> 32:22.090
MES它有一个POW的这个方法

32:22.350 --> 32:24.910
那就让我这边2的三次方

32:25.170 --> 32:26.190
你得这样子来写

32:27.470 --> 32:30.030
那ES6的话就给你提供了一个这个指数运算幅

32:30.290 --> 32:31.310
这不就很方便

32:32.070 --> 32:32.450
对不对

32:32.710 --> 32:33.870
好直接就这样子写就可以了

32:35.830 --> 32:39.150
好然后你注意这个的话它是右结合

32:39.410 --> 32:42.470
指数运算幅它是右结合就比如说你这边的话

32:42.990 --> 32:44.010
2

32:44.270 --> 32:49.130
然后新号新号3新号新号2它是什么呢是先求这个3的

32:49.390 --> 32:50.170
平方

32:50.670 --> 32:53.790
得到一个数然后接下来的话整体在这个2的

32:54.050 --> 32:55.010
这么多次方

32:55.530 --> 32:57.890
它是先从右再到左

33:00.190 --> 33:00.950
好下一个

33:01.470 --> 33:03.790
下一个是这个复职运算幅

33:04.030 --> 33:05.570
复职运算幅也很简单

33:05.830 --> 33:06.850
这个没什么好说的

33:07.110 --> 33:11.190
这里话就注意这个加等加等减等乘等除等

33:11.450 --> 33:12.210
取与等

33:12.470 --> 33:13.110
这就是什么

33:13.370 --> 33:14.530
比如x加等于y

33:14.790 --> 33:17.090
它就等同于x等于x加y

33:17.850 --> 33:19.130
x减等于y

33:19.330 --> 33:22.150
它就等同于x等于x减y

33:22.670 --> 33:24.210
依此类推

33:27.270 --> 33:29.310
好然后还有这个未运算幅

33:29.570 --> 33:31.110
未运算幅一会再说

33:31.370 --> 33:33.410
一会我们单独有个小结

33:33.670 --> 33:34.950
讲这个未运算幅

33:36.230 --> 33:37.510
好然后接下来下一个

33:38.030 --> 33:40.330
下一个是比较运算幅

33:40.590 --> 33:42.890
比较运算幅这边就又有规则了

33:43.150 --> 33:44.430
好我们这边我们来看一下

33:46.230 --> 33:46.990
先把这边

33:47.750 --> 33:48.270
注释掉

33:48.890 --> 33:50.790
好比较运算幅

33:57.730 --> 34:01.050
比较运算幅的话涉及到了这个规则

34:01.310 --> 34:03.870
它就一和那个加运算幅一样

34:04.130 --> 34:05.410
它又比较多

34:05.670 --> 34:06.910
它不仅仅说是数字

34:07.150 --> 34:08.230
我们先来看最基本的应用

34:08.490 --> 34:09.510
给我们这边log

34:10.790 --> 34:13.090
log一个5大于一个3

34:13.350 --> 34:14.110
这个很好理解

34:14.370 --> 34:15.910
是吧这个的话返回的就是什么呢

34:16.170 --> 34:17.450
返回的就是这个q

34:18.210 --> 34:21.790
好那接下来我如果是这个不同的这个类型

34:22.050 --> 34:23.830
比如说我这边的话我log一下

34:24.030 --> 34:28.390
5大于一个制幅串的3

34:28.650 --> 34:30.690
我们来看一下这边走

34:30.950 --> 34:32.990
你看这边它是不是仍然是这个区

34:33.250 --> 34:34.290
它这边会做什么呢

34:34.550 --> 34:38.630
它这边的话会把你这个制幅串转为

34:38.890 --> 34:41.190
我看一下这里

34:42.470 --> 34:44.770
对的它是先转成数值

34:45.030 --> 34:46.050
先转成数值

34:46.310 --> 34:47.130
也就是说我们这边

34:47.390 --> 34:49.950
这边的话会先将

34:50.670 --> 34:58.380
会先将这个制幅串的3

34:59.140 --> 35:02.680
就这个制幅串的3转为数值

35:04.260 --> 35:05.280
转为数值

35:05.540 --> 35:07.840
因为我们这边是不是只有一边是制幅串

35:08.100 --> 35:09.900
这边是不是这个数值

35:10.160 --> 35:12.720
对不对所以它会把这个也转成这个数值

35:12.980 --> 35:16.040
比如说我们这边再来一个log

35:16.800 --> 35:19.880
比如说我大于的这个q

35:20.600 --> 35:22.000
那这个q的话是布尔兹

35:22.240 --> 35:23.920
布尔兹的话它是不是也会把它转成数值

35:24.180 --> 35:27.460
对不对所以这边的大数值的话这个转出来是1

35:27.720 --> 35:28.620
所以也应该是q

35:28.880 --> 35:29.080
走

35:29.820 --> 35:30.320
这边也是q

35:30.840 --> 35:32.640
好那接下来的话这边

35:33.400 --> 35:34.680
如果是这个

35:35.440 --> 35:35.960
对象

35:36.480 --> 35:37.440
那是不是也是一样的

35:37.700 --> 35:38.720
对不对比如说我5

35:38.980 --> 35:40.000
大于一个什么呢

35:40.260 --> 35:40.820
大于一个0

35:42.100 --> 35:44.660
大于一个0的话这个最终转出来是不是0

35:44.920 --> 35:46.460
0的话它这边也是q

35:46.960 --> 35:47.480
看到没有

35:47.680 --> 35:50.000
但你如果注意啊你如果是这个

35:50.260 --> 35:50.760
5

35:52.040 --> 35:53.580
大于一个对象

35:54.340 --> 35:56.900
大于一个对象那你这个对象的话它这边

35:57.680 --> 35:58.700
转出来是什么

35:58.960 --> 36:00.240
这转出来是NAN

36:00.500 --> 36:03.040
NAN和任何这个数

36:03.560 --> 36:05.860
做计算是不是得到的最终都是NAN

36:06.120 --> 36:07.920
所以这个得到的是NAN

36:08.680 --> 36:09.180
走

36:09.440 --> 36:09.960
喂

36:10.720 --> 36:12.260
这边是force

36:12.520 --> 36:13.800
我看一下我看一下

36:15.760 --> 36:16.780
哦这边是这个样子的

36:17.340 --> 36:19.340
就是你这个转出来它是NAN

36:19.580 --> 36:22.420
好NAN和其他数做比较运算的时候

36:22.660 --> 36:24.220
它得到的一定是force

36:24.460 --> 36:27.780
做其他比如加减乘除运算的时候得到的是NAN

36:28.040 --> 36:29.320
好我们这边看一下吧

36:30.100 --> 36:31.120
比如我们这边log

36:31.620 --> 36:32.900
log比如说我

36:33.420 --> 36:35.220
大于一个NAN

36:35.480 --> 36:37.780
然后我小于一个NAN

36:38.020 --> 36:39.820
把这个先租实掉

36:40.340 --> 36:41.100
好我们这边走

36:41.360 --> 36:43.660
你看无论大于还是小于它得到的都是force

36:44.180 --> 36:44.680
对不对

36:44.940 --> 36:46.740
好那接下来我们这边的话我们log

36:47.500 --> 36:50.320
log比如说我加上一个NAN

36:50.580 --> 36:51.340
然后我

36:51.860 --> 36:53.380
减去个NAN

36:53.640 --> 36:54.160
好乘

36:54.420 --> 36:55.940
然后接下来的话除

36:56.200 --> 36:58.260
那这些的话做这些计算的话

36:58.520 --> 36:59.780
它最终得到的就是什么呢

37:00.040 --> 37:01.840
最终得到的就是NAN

37:02.360 --> 37:02.860
看完不要

37:03.120 --> 37:04.660
因为你这个比较运算

37:05.160 --> 37:07.220
你这个大于小于它是个比较运算幅

37:07.480 --> 37:09.260
比较运算幅最终得到的是一个什么

37:09.520 --> 37:11.060
是不是应该是得到的是一个布尔滋

37:11.820 --> 37:12.340
对不对

37:12.580 --> 37:13.620
最终得到的是个布尔滋

37:13.880 --> 37:15.660
所以它这边得到的就是force

37:16.640 --> 37:17.920
这边我们可以总结一下嘛

37:18.180 --> 37:19.440
就是NAN

37:20.220 --> 37:20.980
在做

37:22.000 --> 37:24.060
在做比较的时候

37:25.080 --> 37:27.640
得到的是force

37:28.160 --> 37:30.200
就是一定得到的是force

37:32.100 --> 37:33.900
然后NAN

37:34.400 --> 37:36.700
在做计算的时候

37:37.980 --> 37:38.740
的时候

37:39.000 --> 37:41.060
然后得到的是什么呢

37:41.320 --> 37:42.840
得到的是NAN

37:43.100 --> 37:45.660
然后还有一个就是NAN和它自身也不像的

37:46.240 --> 37:47.200
然后我们这边log

37:47.960 --> 37:49.240
logNAN

37:49.500 --> 37:51.040
比如说全等于

37:53.080 --> 37:56.400
这个就是全等运算幅

37:56.660 --> 37:57.180
对不对

37:57.440 --> 37:58.720
然后接下来这边走

38:01.020 --> 38:02.560
你看这边是不是和自身也不像的

38:02.820 --> 38:03.320
对不对

38:03.580 --> 38:03.840
force

38:04.100 --> 38:07.420
这个其实就和第一条是不是匹配的

38:07.940 --> 38:11.520
对不对你看第一条NAN在做比较的时候一定得到的是force

38:11.780 --> 38:13.060
那我这个是不是也是在做比较

38:14.080 --> 38:14.580
对不对

38:14.780 --> 38:16.580
所以它这边得到的也是force

38:16.840 --> 38:17.600
OK

38:18.880 --> 38:20.920
好这是关于这个NAN

38:21.440 --> 38:22.720
好那接下来我们这边继续

38:22.980 --> 38:24.000
回到我们这边

38:24.780 --> 38:25.800
把这个

38:26.560 --> 38:27.840
把这个放到上面嘛

38:29.640 --> 38:30.660
把这个放到上面

38:30.920 --> 38:32.720
好然后继续回到我们这边

38:33.480 --> 38:37.060
我们这边刚刚讲到了就是这些的话它会对这些进行一个什么

38:37.320 --> 38:39.880
进行一个转换先转成数值啊

38:40.140 --> 38:41.680
对不对再做比较

38:42.660 --> 38:44.020
当遇到

38:45.300 --> 38:49.060
当遇到不是数值

38:49.820 --> 38:50.860
的操作数

38:53.120 --> 38:54.400
会先

38:55.680 --> 38:59.880
会先将其转为什么呢

39:02.050 --> 39:03.030
转为

39:03.590 --> 39:04.550
是不是数值啊

39:05.390 --> 39:07.170
对不对好这是第一个

39:07.430 --> 39:08.710
好然后接下来第二个

39:09.470 --> 39:11.790
如果两边

39:12.550 --> 39:14.350
都是制幅串

39:14.890 --> 39:17.970
那么这个比较规则

39:19.250 --> 39:20.790
就又变化了

39:23.500 --> 39:25.300
啊比较的是什么呢

39:26.060 --> 39:27.540
比较的是

39:28.380 --> 39:30.820
这个它这个制幅的编码大小

39:34.170 --> 39:36.090
好什么意思啊我们来看一下

39:37.870 --> 39:40.610
好来到我们这边啊我们看一下

39:42.370 --> 39:42.810
这边

39:43.250 --> 39:45.290
先看两个

39:45.550 --> 39:48.250
这个运算值是否都是制幅串

39:49.290 --> 39:52.370
如果是按照字典顺序比较

39:52.610 --> 39:55.250
比较的是什么呢比较的是Ulicode码点

39:55.850 --> 40:00.330
否则它将两个运算值都转成什么呢转成这个数值啊

40:00.570 --> 40:02.090
这个后面这个我们该是不已经看了

40:02.570 --> 40:03.770
对不对它会转成数值

40:04.030 --> 40:06.090
关键是两个都是制幅串的时候

40:06.590 --> 40:10.170
它是按照什么呢按照这个字典顺序进行比较

40:10.690 --> 40:13.770
那什么字典顺序其实就是这个Ulicode

40:14.270 --> 40:17.970
码点啊这个你如果了解这个ask码的话

40:18.190 --> 40:20.990
你理解这个其实并不难的啊

40:20.990 --> 40:22.590
比如说我们这边我们来看一下这个ask码

40:24.430 --> 40:25.470
我们看这个ask码吗

40:27.720 --> 40:29.480
不要这边ask

40:34.340 --> 40:35.860
ask码啊

40:37.340 --> 40:38.340
找个图片

40:43.180 --> 40:44.900
找一个ask码就这个就这个

40:47.110 --> 40:49.230
好我们来看一下这个ask码的这个图片

40:50.190 --> 40:53.750
呃有点小啊可以了啊就这么大

40:54.570 --> 40:55.570
哎

40:56.970 --> 40:58.250
啊这什么意思

40:58.730 --> 41:02.370
好我们知道最早的话这个计算机是美国发明的

41:02.890 --> 41:07.210
对不对那美国发明的话他们用到的制幅是什么呢他们用到制幅就这些

41:08.330 --> 41:14.410
就这么多啊比如大写的a对吧大写的a b c d反正一共26个字母吗

41:14.770 --> 41:21.730
a到这个z那小写的a b c d然后到z那加上一些其他的符号啊比如什么

41:22.150 --> 41:24.510
感叹号啊这个美元符号啊

41:24.950 --> 41:28.390
然后接下来百分号啊然后接下来一些这些符号杂起杂吧

41:28.630 --> 41:32.350
加起来啊都采一共多少个呢一共128个

41:32.790 --> 41:36.470
啊用一个字节来存储就可以了啊也就说我们最终比如说我们

41:37.670 --> 41:39.350
这个英文里面的比如这个a

41:39.910 --> 41:43.270
他最终是什么呢他最终是不是要以二净字的形式来存储啊

41:43.710 --> 41:47.350
那二净字的形式来存储的话他这边对呢他就有一个数

41:47.850 --> 41:51.650
比如这个a a的话他对应的这个数就是多少呢对应的就是97

41:52.170 --> 41:55.490
看到没有然后b对应的这个数就是什么呢就是这个98

41:56.010 --> 42:01.530
说当我制服串进行比较的时候他比较的是什么比较的是他这个在这个马表里面

42:02.410 --> 42:06.370
他的这个数值的这个大小啊所以这边呢你比较比如说a

42:06.630 --> 42:11.810
小于这个b他是会给你返回去的为什么因为a对应的这个数字是97

42:12.370 --> 42:14.370
b对应的数字是98

42:15.030 --> 42:16.830
所以他会给你返回一个这个

42:17.830 --> 42:21.710
那我们这个js的话他比较的话虽然没用这个ask马

42:23.190 --> 42:26.790
就是没有用这个ask马那个表啊但是他用了这个Ulicode

42:27.270 --> 42:30.430
基本上是差不多的他Ulicode的话就是包含了其他字符

42:30.990 --> 42:31.710
就是除了

42:32.310 --> 42:38.430
包含这些字符以外啊因为他这个Ulicode的话基本上就是把世界上所有的文字都

42:38.790 --> 42:41.430
包含进去了啊我们看到这个ask马表

42:42.050 --> 42:48.930
这个ask表他是不是他是有一定局限性的对不对他只有这个英文啊只有英文的这个字母

42:49.250 --> 42:56.130
那比如说我这边的话有些其他国家的比如说法文啊对吧然后接下德文啊这个他是没办法表示的

42:56.370 --> 43:02.650
他没有对应的这个字符和数字的这个对应关系啊比如在用中文啊中文里面是不是汉字

43:03.210 --> 43:11.130
对不对中文啊然后那个日语啊这些他没办法表示的啊说后面的话就是有一个什么呢有一个这个Ulicode

43:12.170 --> 43:16.330
他就是把这个世界上所有的这个啊字符

43:17.010 --> 43:20.210
全部都包含进去了啊但本质上和这个是一样的

43:21.130 --> 43:28.330
本质上和这个是一样的也就是说你一个字符对应有一个数字一个字符对应有一个数字啊那我们这边我们来看一下

43:28.770 --> 43:29.570
比如说我们这边

43:33.370 --> 43:34.770
比如说我们这边log

43:36.290 --> 43:38.250
log啊比如说字符串的A

43:39.010 --> 43:40.890
小于字符串的B

43:41.690 --> 43:42.730
啊我们这边走

43:47.340 --> 43:48.220
啊这边走

43:50.140 --> 43:57.080
啊把把这个做上啊走你看是不是去啊对不对

43:57.360 --> 44:04.360
反回的是去为什么原因很简单呀你A对应的是什么A对应的是不是97B对应的是98

44:04.920 --> 44:10.280
对不对那比如说我这个小A他一定是大于这个大A的因为大A对应了这个阿斯克马的这个字

44:10.880 --> 44:14.920
这个数字是65啊所以我们这边呢就是这个A他一定是

44:15.600 --> 44:16.320
大于

44:17.140 --> 44:19.340
这个大A的好走

44:20.180 --> 44:28.460
看到没有是不是也是去啊啊也是去啊所以这个首先是第一点他比较的是字符的编码大小

44:29.580 --> 44:35.260
明白吧啊所以说不像有的同学想到哎这个字符说他没办法比较呀这个怎么比较大小他可以比较

44:35.740 --> 44:42.380
啊因为他背后对应了有一张这个马表是吧好然后如果是多个单词

44:43.980 --> 44:44.620
哎你看这边

44:44.920 --> 44:48.920
比如说我这边的话有一个这个cat

44:50.640 --> 44:53.760
大于一个什么呢大于一个这个boy

44:56.040 --> 44:58.120
boy啊或者boyfriend

44:59.520 --> 45:04.680
哎呀你看那这个又该怎么比较呢也看上去好像这个单词更长一些

45:05.320 --> 45:06.760
对不对他反回应该是force

45:07.320 --> 45:13.280
但不是他比较是怎么比较他是取出你这边是不是两个字符串对不对这个一个字符串这个一个字符串

45:13.580 --> 45:17.780
那接下来取出他们的第一位第一位第一位他的这个

45:18.340 --> 45:23.700
呃这个对应的这个字点啊就是这个编码大小啊他是多少

45:24.260 --> 45:29.660
那是979899是吧他是99他是多少他是98那这个是不是就比这个大

45:30.020 --> 45:33.460
那比较结果出来了那直接就反回什么了反回处

45:35.060 --> 45:35.420
看到没有

45:35.940 --> 45:39.940
反回处那除非是什么呢除非是你这边第一位他比较不出来

45:40.980 --> 45:42.700
你这个两个第一个是不是两个都是谁

45:43.380 --> 45:45.660
对不对那既然他就比较什么呢比较第二个

45:46.900 --> 45:51.780
看到没有比较第二个那比较第二个明显这个是不是在后面一些他的那个只要大一些

45:52.420 --> 45:56.540
对不对那这个这个要小一些啊所以这边呢就是应该是force

45:57.780 --> 46:00.900
看到没有他就是这样子的一位一位去比较

46:02.300 --> 46:06.260
一位一位去比较啊那当然有的同学说那如果是这种情况呢

46:06.760 --> 46:09.480
如果是这种情况

46:10.040 --> 46:14.920
不要这个是CAT然后前面位数都相同啊大家后面多了一个A

46:16.120 --> 46:18.320
多了一个A那这种你看他是怎么比较的

46:19.200 --> 46:23.120
这边是force为什么是force因为你这边的话前面这个是不是相同

46:23.720 --> 46:26.240
对不对然后既然我后面这边是不是他是有值的

46:27.200 --> 46:29.280
对不对有值的你这个后面没有值了

46:30.160 --> 46:33.080
说那和明显就是我后面这个是不是要大一些

46:33.980 --> 46:38.660
对不对啊他总之的话你记住他就是一位一位的进行比较啊

46:39.620 --> 46:42.820
就是比较的是制服编码大小如果

46:45.520 --> 46:48.040
如果是一个制服串

46:48.880 --> 46:51.400
那么就取出

46:52.240 --> 46:54.760
制服串的每一个

46:55.480 --> 46:55.960
制服

46:56.920 --> 46:58.240
来进行

46:59.360 --> 47:01.560
比较啊来进行比较

47:02.540 --> 47:02.940
OK

47:03.820 --> 47:05.340
好我们这边看一下啊

47:05.600 --> 47:09.260
JS隐形内部首先比较制服的这个Ulicode码点

47:09.540 --> 47:12.700
然后接下来再比较第二个制服的Ulicode码点

47:12.940 --> 47:14.060
以此类推

47:14.580 --> 47:15.080
对吧

47:16.620 --> 47:19.620
然后接下来因为我刚才说了哈这个Ulicode它就包含了

47:20.060 --> 47:21.620
世界上所有的这个

47:21.980 --> 47:24.460
文字说的包括中文也是可以比较的

47:24.720 --> 47:25.460
比如说这边

47:25.720 --> 47:26.100
大

47:26.340 --> 47:28.380
大于这个小他是force为什么呢

47:28.600 --> 47:32.160
他比较的是这个码点码点大的话码点是这个22823

47:32.420 --> 47:34.680
小的话是23567

47:34.920 --> 47:36.160
所以他反回的是force

47:36.520 --> 47:37.800
比我们这边我们可以看一下

47:39.600 --> 47:40.360
呃这边

47:44.480 --> 47:45.520
把这个注射掉

47:47.320 --> 47:48.040
是force

47:48.800 --> 47:49.100
对吧

47:49.360 --> 47:49.860
OK

47:52.160 --> 47:52.940
然后

47:54.220 --> 47:55.760
非制服串的比较

47:56.520 --> 47:57.560
非制服串啊

47:58.320 --> 48:00.120
如果两个运算值之中

48:00.120 --> 48:03.700
至少有一个不是制服串那么分成两种情况

48:03.960 --> 48:06.000
那首先就是原始类型

48:06.260 --> 48:08.300
原始类型我们刚才说了他是会先干嘛

48:08.560 --> 48:10.360
是先转成这个数值在比较

48:10.880 --> 48:15.220
对比较这边五大于四他会先把干嘛呢先把这个四

48:16.000 --> 48:16.760
转为什么呢

48:17.020 --> 48:18.800
转为这个数值的事

48:19.060 --> 48:20.340
然后接下来进行比较

48:20.600 --> 48:25.200
去force就不说了去转化成1force转化成0对吧

48:25.460 --> 48:29.560
啊任何这个和nn的这个比较反回的都是什么呢

48:30.320 --> 48:31.360
都是force

48:32.380 --> 48:33.140
啊都是force

48:33.400 --> 48:34.680
好那接下来下一个

48:34.940 --> 48:36.480
如果有对象

48:37.240 --> 48:38.520
如果有对象

48:38.780 --> 48:41.840
他其实要做的事情也是一样的他还是调用什么

48:42.100 --> 48:44.920
还是调用这个lumber这个函数

48:45.680 --> 48:48.760
对不对他背底里到这个调用的还是这个lumber的函数

48:49.020 --> 48:52.860
他调用这个lumber这个函数来转的时候他是不是就还是遵循这个规则

48:53.120 --> 48:55.160
先是什么是value all

48:55.420 --> 48:57.460
然后接下来再干嘛再调用2stray

48:58.240 --> 49:00.020
对不对啊这个的话也是刚才

49:00.320 --> 49:01.000
想过的啊

49:01.360 --> 49:03.140
刚才讲过的啊比如这边

49:03.400 --> 49:03.900
2

49:04.160 --> 49:05.440
大于这个1

49:06.220 --> 49:09.800
最终这个转出来这个是2的制服串这个是1的制服串

49:10.560 --> 49:11.600
啊那接下来这边

49:11.860 --> 49:18.240
比较的就是什么呢比较就是2的制服串和1的制服串比较那最终转换成什么是不两个制服串的比较

49:19.020 --> 49:20.040
对不对啊

49:21.840 --> 49:23.120
好然后接下来这个

49:23.880 --> 49:27.720
啊这个的话他也是调lumber方法他转出来这个对象转出来是不是这个

49:28.440 --> 49:29.000
对不对

49:29.260 --> 49:30.800
这个对象转出来也是什么

49:31.060 --> 49:31.560
是不是也是这个

49:31.820 --> 49:35.400
对不对所以他这边大于等于他得到的是什么呢得到的是q

49:35.920 --> 49:36.940
啊得到是q

49:38.220 --> 49:39.500
好这个就不说了

49:40.260 --> 49:40.780
好下一个

49:41.540 --> 49:45.900
下一个是这个严格相等运算服我们一起来看一下

49:47.680 --> 49:53.060
好严格类型的话我们来看一下啊这是接式里面提供了一种特有的就三个等号

49:53.320 --> 49:55.120
其他语言里面都是没有的

49:55.620 --> 49:56.140
他是什么呢

49:56.340 --> 49:58.400
他是就是你如果两个值

49:58.660 --> 50:00.180
不是同一个类型

50:00.440 --> 50:01.980
他直接就给你干嘛呢

50:02.240 --> 50:03.260
直接给你返回

50:03.520 --> 50:04.020
force

50:04.280 --> 50:05.060
他就不像这个

50:05.820 --> 50:06.840
比如说我们这边举个例子

50:08.800 --> 50:10.080
呃严格

50:10.840 --> 50:11.880
严格相等

50:12.640 --> 50:13.920
啊比如说我们这边log

50:14.680 --> 50:15.960
log一个5

50:16.220 --> 50:17.000
等等等

50:17.500 --> 50:18.280
这个制服串的5

50:18.780 --> 50:19.500
我们来看了

50:19.760 --> 50:21.080
这边左边是不是lumber的型

50:21.340 --> 50:23.400
右边是strain的型是不类型都不相逃

50:23.900 --> 50:26.200
那他就直接干嘛呢直接给你返回force

50:27.180 --> 50:30.100
克勒米尔他就和那个就是相等运算服不一样

50:30.360 --> 50:32.100
我们还有一个是相等运算

50:33.060 --> 50:35.100
相等运算服

50:35.620 --> 50:37.420
那比如说这边log

50:37.660 --> 50:40.740
一个5等等一个制服串的5

50:41.260 --> 50:46.380
那这边他是两个类型是不一样是吧不一样我会干嘛呢我会尝试的做转换

50:46.640 --> 50:49.460
我把这个转换成什么呢转换成lumber类型

50:49.960 --> 50:53.300
转换成lumber类型是不是得到是我说得到的是什么呢得到的是

50:54.280 --> 50:57.600
克勒米尔啊那这个严格相等的话他就不一样

50:57.860 --> 50:59.920
啊他这话只要你类型不同

51:00.680 --> 51:04.520
最只要这个两个值不是同一类型

51:04.780 --> 51:07.320
直接什么直接返回force

51:07.840 --> 51:12.960
而这个相等运算服他会把他们什么呢转换成同一个类型

51:13.720 --> 51:18.600
然后再看这个值是否相等啊我们这边我们来看一下

51:19.300 --> 51:23.940
首先这边第一个一全等于这个force对吧这个force

51:24.700 --> 51:31.620
好大家同一类的原始值类型啊比如这边一全等于这个零差一啊这个是什么意思

51:33.060 --> 51:39.820
这可能有同学平时看的很少是吧零差一这个是什么的这个就是16进值表示啊就是我们的这个前维

51:40.380 --> 51:47.820
16进值这边的话他就是其实也是什么呢也是一对吧也是一啊那比如说我们这边再来举个例子

51:48.800 --> 51:50.300
呃我把这个注射

51:53.200 --> 52:03.680
比我们这边loglog比如说来个几呢来个三吧三然后全等于比我们二进值二进值的三是多少

52:04.560 --> 52:10.760
呃10我看二二是1011是吧那这边的话你就写零币

52:11.320 --> 52:14.960
11啊那接下来我们这边我们来看一下是不是也是去

52:15.640 --> 52:19.040
对不对为什么因为这个是二进值的全这个前维零币

52:19.540 --> 52:24.900
好那1111的话就是二进值的话就是3对吧所以返回的是去

52:27.430 --> 52:34.390
好然后注意NN与任何值都不相等包括这个自身这我们刚是不是看过的

52:35.550 --> 52:39.150
对不对这个其实就是符合哪条呢符合我们刚才写的这一条

52:39.990 --> 52:43.670
就是这边NN在做比较的时候一定得到的是什么

52:44.410 --> 52:50.530
是不是force啊哪怕你和自己做比较那你也是在比较吗对吧说他一定得到的是force

52:52.450 --> 52:55.450
好让阵铃等于复领啊好然后下一个

52:56.250 --> 53:02.490
呃复合类型的值什么叫复合类型的值啊比如这个对象然后这样数组含数

53:03.010 --> 53:10.570
他们在比较的时候他们比较的就不是值了你注意他们比较的就不是值了而是什么呢而是这个地址

53:11.310 --> 53:14.550
啊这点的话一定要注意比如说我这边举个例子

53:20.110 --> 53:20.510
对象

53:21.910 --> 53:28.270
在比较的时候比较的就不是值了

53:30.740 --> 53:36.580
而是比较的地址啊比如说我们这边log

53:37.300 --> 53:43.540
一个数组是否全等于另外一个数组那这边他肯定会给你返回什么呢返回force

53:44.040 --> 53:48.360
为什么因为这两个数组他们地址是不一样的啊那比如说我这边

53:49.920 --> 53:51.480
我挖一个a啊

53:52.360 --> 53:57.720
等于一个空数组而且再挖一个a啊2等于一个a啊

53:58.600 --> 54:04.840
那我这边的话其实是什么呢把a啊啊代表的是一个数组对不对然后把这个数组的地址

54:05.280 --> 54:09.520
复指给谁复指给a啊也就是他就是这个意思

54:10.260 --> 54:11.180
啊我这边画一下

54:12.780 --> 54:17.580
啊比如说我这边我们都知道他是不是有一个这个站有一个堆对不对这个是站

54:18.300 --> 54:23.300
这个是啊啊堆好然后接下来哈这边有一个什么呢有一个a啊

54:24.940 --> 54:30.500
有一个a啊啊好然后加a啊然后加对应的是一个什么是不是一个空数组

54:30.980 --> 54:34.140
对不对那空数组里面具体的这些数据其实是放在堆去的

54:34.360 --> 54:38.680
然后我这边的话只存放什么呢只存放你这边他会有个地址啊比如说什么零

54:39.400 --> 54:41.400
一般是16进制的啊比较零差

54:42.400 --> 54:43.160
然后b

54:44.000 --> 54:48.640
然后啊之类之类的好然后加我这边的话就是指向什么就指向这个地址

54:49.640 --> 54:54.280
对不对指向这个地址我这边的话这个占据存储的是什么存储的是这个东西

54:55.000 --> 54:56.600
存储的是这个东西就这个地址

54:57.160 --> 55:02.360
好然后加我这边的话a啊复指给a啊2其实就是什么所以把这个地址

55:03.220 --> 55:10.740
复指给这个a啊2对不对把这个地址因为我这边的话这边

55:11.340 --> 55:14.060
就这边存储的是什么呢存储的是这个地址

55:14.860 --> 55:16.900
啊那接下来这他的话也是什么

55:17.340 --> 55:18.300
说他是不是也是

55:18.780 --> 55:19.340
指向

55:19.980 --> 55:20.620
同一个地方

55:21.620 --> 55:23.300
对不对也指向同一个地方

55:25.900 --> 55:29.500
啊OK好所以你这边的话你来答应啊这边log

55:30.480 --> 55:35.600
log ar是否全等于ar2那他这边的话返回的就是什么呢

55:35.860 --> 55:36.880
返回的就是处

55:37.640 --> 55:38.200
克拉米亚

55:38.680 --> 55:40.200
返回的就是处啊

55:42.000 --> 55:42.240
好

55:43.280 --> 55:44.040
然后

55:44.300 --> 55:44.800
这边

55:45.480 --> 55:53.520
呃对于两个对象的这个比较啊如果你是通过这个大鱼小鱼进行比较那比较的是什么呢比较的也是这个地址

55:54.280 --> 55:55.320
啊比较的也是地址

55:56.080 --> 55:58.120
因为你地址最终对应的有一个这个

55:59.100 --> 56:03.300
啊刚才那个话那个已经消了就是他是不是也是有一个这个地址的这个字啊

56:03.980 --> 56:05.740
对不对啊比如说我们这边

56:07.660 --> 56:08.700
这个是大鱼

56:11.820 --> 56:13.260
啊这个啊force

56:14.300 --> 56:15.340
走force

56:16.100 --> 56:24.100
force啊他先应该是他先声明啊先声明的他后声明他的地址的话要比他在后靠后一些啊

56:25.080 --> 56:27.520
当一般来讲的话

56:28.280 --> 56:30.720
我们这个对象的这个大小比较

56:30.960 --> 56:31.920
我看一下啊

56:33.000 --> 56:35.840
啊不对不对啊对象的大小比较应该是什么

56:36.600 --> 56:39.160
对象的大小比较是不应该是我们前面讲了的

56:39.800 --> 56:44.280
对不对他们这个对象的这个大小比较是干嘛是先转成这个数值呀

56:44.800 --> 56:50.920
对不对啊他是先转成数值啊他这个如果是这个这个相等的这个比较

56:51.440 --> 56:52.200
在哪去了

56:53.180 --> 56:54.180
嗯

56:56.180 --> 56:57.180
啊如果是

56:58.500 --> 56:59.100
哪去了

57:00.100 --> 57:09.420
啊这里啊如果是这种相等比较比较的是地址啊如果是这个大鱼小鱼啊这种这种的话他比较的是什么比较的是值啊比较的是值

57:11.420 --> 57:21.980
好然后下一个下一个的话是这个undefine和这个空啊undefine的话然后和自声是这个相等的然后空的话和自声也是啊都是相等的

57:23.020 --> 57:26.980
这个没什么好说的好下一个下一个的话是严格不相等

57:28.580 --> 57:36.260
这个严格不相等的话他就和刚才那个严格相等是相反的啊比如说他这边的话就是一个感叹号然后两个等号

57:36.700 --> 57:37.420
比如说我们这边

57:39.180 --> 57:45.790
严格不相等严格

57:47.270 --> 57:54.670
不相等啊他就是和刚才是反的嘛就我们这边比如log5然后不严格相等于制服错的5

57:55.250 --> 58:00.890
那这个是不是就是应该是q了对不对这个就应该是q啊这个也没什么好说了

58:02.570 --> 58:10.690
好然后接下来下一个下一个是相等运算服那相等运算服的话他就是干嘛是会做一个这个数据类型的这个转换

58:11.690 --> 58:18.450
对不对他和这个严格运算服最大的区别就是他会做这个数据类型的转换啊比如说我们这边我们来看一下

58:19.070 --> 58:29.070
比较一等等去啊那这边他就会把什么把去是不是转换成数值啊0等等4是对吧啊然后接下来比如说这边这个制服串

58:29.870 --> 58:33.950
制服串啊啊这个这个是数值那既然他就会把干嘛是把这个

58:35.110 --> 58:39.550
转成这个数值啊对不对然后接下来进行一个这个比较

58:40.630 --> 58:44.110
这个转成数值是多少这个转成数值是不是NN

58:44.890 --> 58:48.010
对不对所以最终得到是什么呢得到的是force啊

58:48.490 --> 58:53.650
那这个这个空制车空制车转成数值得到的是0啊得到是0

58:54.050 --> 58:55.530
然后既然你如果是这边

58:56.770 --> 59:02.490
这边的话你是比如说制服串的1他转成数值最终就是1啊但是你如果是这种

59:03.370 --> 59:10.290
比如说我这里啊这边相等运算服

59:14.810 --> 59:20.880
相等运算服啊我这边呢我比如说是

59:21.660 --> 59:22.740
这种制服串

59:24.100 --> 59:25.700
比如说123

59:26.460 --> 59:32.340
123转成数值是不是就是123对不对就123但我后面加了一个这个A

59:33.140 --> 59:38.900
那也就是加了一个非数字的这个制服那么这一块整体转出来的话他就是什么呢他就是NN

59:39.540 --> 59:41.660
啊让我这边让我比如说随便大于一个数

59:42.340 --> 59:48.220
大于一个1那这边的话他得到就是什么呢啊NN和1进行比较所以最终就是force

59:49.200 --> 59:51.240
对不对最终就是force啊

59:53.040 --> 59:57.400
这个注意啊为什么因为你这个东西转出来是NN但你如果没有这个

59:58.440 --> 01:00:04.680
没有这个的话他转出来就是吗是吧123是不是就是去啊对不对就是去啊

01:00:06.480 --> 01:00:07.000
好

01:00:08.240 --> 01:00:10.120
然后如果是对象

01:00:10.960 --> 01:00:14.240
如果是对象和原始类型进行比较

01:00:14.860 --> 01:00:21.060
那是不是就和刚刚之前是一样的先调什么先调这个value of再调什么再调2st

01:00:21.540 --> 01:00:24.340
这个都说烂了啊这个我不再多说了啊

01:00:25.220 --> 01:00:25.460
好

01:00:26.460 --> 01:00:29.580
然后这边啊这这里看一下吧

01:00:31.690 --> 01:00:38.810
啊这里上利中啊上面的例子是吧上利中皆是引擎会先对这个数组调用数组的value of

01:00:39.130 --> 01:00:43.490
他返回的还是个数组然后接下来调用数组的什么呢调用数组的2st

01:00:43.950 --> 01:00:49.630
得到什么得到制服串形式你注意如果只有一个数字一个数字他得到的是这个制服串

01:00:50.390 --> 01:00:55.510
啊说说为什么我们这边得到一个数字是他转出来是1但是如果多加一点数字

01:00:56.030 --> 01:00:57.070
他转出来是什么

01:00:57.570 --> 01:01:01.910
你用number转出来他是吗他是不是NN啊对不对他是NN

01:01:04.380 --> 01:01:09.240
好然后其他就不多说了这边这边就是覆盖啊这边就是把他的这个默认的value of

01:01:09.500 --> 01:01:10.520
2st

01:01:11.040 --> 01:01:11.800
这个也不说了

01:01:12.260 --> 01:01:15.080
好然后这边undefine和这个脑

01:01:15.840 --> 01:01:17.120
undefine和脑

01:01:17.380 --> 01:01:21.220
只有与自身比较或者相互比较时才会返回去

01:01:21.740 --> 01:01:24.300
啊然后和其他值比较时都是force

01:01:24.560 --> 01:01:29.940
在这边undefine等等undefine去脑等等脑去undefine等等脑去

01:01:30.180 --> 01:01:31.220
但是和其他

01:01:31.720 --> 01:01:38.380
其他比如说这边啊和布尔值比较和数值进行比较得到的都是什么呢得到都是force

01:01:38.840 --> 01:01:39.280
啊

01:01:40.640 --> 01:01:45.240
相等运算幅的一些缺点那相等运算幅最大缺点就是什么呢

01:01:45.500 --> 01:01:50.880
就是他会有一个这个自动的这个类型转换啊所以说一般来讲的话我们这边

01:01:51.140 --> 01:01:54.200
呃在写代码的时候我们一般都是要求用这个

01:01:54.960 --> 01:01:58.800
啊就现在你去公司里面写代码啊要求你都是用这个权等

01:02:00.080 --> 01:02:02.140
直接写权等不要写等等啊

01:02:03.160 --> 01:02:06.500
好然后不相等啊不相等就是一个这个

01:02:07.400 --> 01:02:12.680
一个感叹号一个等号啊他这边的话也是会做一个这个类型转换的啊比如说我们这边的话

01:02:14.600 --> 01:02:17.600
比如说log

01:02:18.720 --> 01:02:21.600
然后我不等于一个制服穿的我

01:02:22.320 --> 01:02:28.200
那这个呢他实际上会做什么是不是数据的型转换对不对转出来的话你如果用等等比较的话他是chew

01:02:29.160 --> 01:02:31.320
那你说他不等的话他就是force

01:02:32.320 --> 01:02:33.640
对不对他就是force

01:02:34.620 --> 01:02:38.460
好那这边的话就整体把这个整个

01:02:39.220 --> 01:02:42.460
呃算数运算幅和比较运算幅

01:02:43.540 --> 01:02:50.740
这边说完了啊也讲了一个小时了啊这边的话你可以自己再看一看啊你把这个视频暂停了

01:02:50.980 --> 01:02:56.980
那把这个课件先自己看一看消化一下啊然后我们这边的话接着来讲这个啊

01:02:57.400 --> 01:03:00.460
布尔运算幅你或者你把视频暂停了你休息一下吗

01:03:01.000 --> 01:03:06.360
啊去喝口水是吧上个厕所休息一下那一会我们来看这个布尔运算幅

01:03:07.960 --> 01:03:14.440
好这个布尔运算幅其中我们一般不会叫布尔运算幅我们一般叫做逻辑运算幅啊

01:03:14.960 --> 01:03:18.360
就是一般我们称聋我这边写下嘛就一般称之为

01:03:20.480 --> 01:03:22.320
一般称之为逻辑运算幅

01:03:23.280 --> 01:03:25.160
就是你看比如其他的教材啊

01:03:25.980 --> 01:03:29.060
或者说啊啊就是这个名字要用的多一些

01:03:29.580 --> 01:03:34.060
罗锦运算幅只不过这个罗锦运算幅他最终得到的一定是一个布尔迟啊

01:03:34.060 --> 01:03:35.260
去或者或是

01:03:35.940 --> 01:03:42.860
我们来看一下这个呢那包含什么呢包含四个一个是趋返啊一个是这个浅或者叫做病

01:03:43.460 --> 01:03:45.060
一般我喜欢叫他叫这个病

01:03:46.500 --> 01:03:49.060
啊那这样或啊这个就与或非嘛

01:03:49.620 --> 01:03:54.380
那这个就是与嘛然后或然后非那这边还有一个三元运算幅

01:03:55.000 --> 01:04:03.200
好那我们这边我们来看一下啊首先这个取反这个最简单这个就什么呢就是非真为假非假为真啊你如果是处

01:04:04.240 --> 01:04:11.520
如果是处我给你变成force如果你是force我给你变成去看没有就做一个这个啊取反

01:04:12.440 --> 01:04:19.080
好然后接下来以下六个字取反后为这个去那六个字呢就比较unlify

01:04:19.900 --> 01:04:26.140
你取反是处然后空然后force0nn空之串是这个

01:04:27.060 --> 01:04:30.660
取反是处啊然后其他指的话他是什么呢他是force

01:04:31.540 --> 01:04:35.860
他其实内部是什么呢内部其实他就是用那个布林那个函数

01:04:36.780 --> 01:04:41.500
先把它转成布尔迟转成布尔迟然后接下来再进行一个取反

01:04:42.060 --> 01:04:44.900
那比如说这个unlify他转成布尔迟就是什么

01:04:45.560 --> 01:04:52.040
他转成布尔迟是不是就是force对那你再取反取反的话他就是什么是不是就是处啊那我们这边我们可以来看一下

01:04:52.680 --> 01:04:53.000
比如说

01:04:55.120 --> 01:04:56.320
比如这边nog

01:04:57.680 --> 01:05:03.560
啊这边的话比如说布林他其实内部就调的什么呢调的布林这个函数啊比如我们这边unlify

01:05:04.760 --> 01:05:07.680
unlify啊那比如说这个空

01:05:08.660 --> 01:05:11.180
对吧然后接下来空之串

01:05:12.260 --> 01:05:20.380
然后接下来0啊这些比较典型的你这边再把它转成这个布尔迟的时候他得到的都是什么呢

01:05:20.780 --> 01:05:28.460
得到的都是force那你对force取反是不是那肯定就是得到处啊对不对啊那你这边他如果是比如说是一个数组

01:05:29.180 --> 01:05:34.380
哪怕我是个空数组啊那这边你看他转成布尔迟的时候是什么是不是处

01:05:34.840 --> 01:05:39.880
说他取反就是什么这就是force啊对不对啊他就是这个样子来的啊

01:05:41.880 --> 01:05:47.880
啊上面代码中不管什么类型的值经过取反都变成了布尔迟啊比如说这边

01:05:48.600 --> 01:05:52.680
54啊然后加这边啊这个Hello啊然后加这边

01:05:53.360 --> 01:05:56.160
是吧取反都是force啊所以说我们有一个

01:05:56.880 --> 01:06:02.120
协访啊就是可以快速的把一个值转成这个布尔迟怎么写的就是两个赶上号

01:06:03.100 --> 01:06:06.700
啊为什么呢因为你一个赶上号是不是他的那个布尔迟取反了

01:06:07.460 --> 01:06:13.460
对不对比如说我这个5450是转成布尔迟本来应该是去但是你一个赶上号的话他是不是变成force

01:06:14.140 --> 01:06:19.300
对不对那这样我再来个赶上号他就变成这个去了啊比如说我们这边快速

01:06:20.020 --> 01:06:27.740
将一个值快速快速将一个值

01:06:28.720 --> 01:06:31.720
转为什么呢转为布尔迟

01:06:32.600 --> 01:06:39.240
那我们以前用的是什么是不是用了这个布林这个函数啊那你现在的话就可以用什么呢可以用两个赶上号啊比如说赶上号

01:06:40.040 --> 01:06:44.560
54我们知道这个54转成布尔迟是不是一定是去啊但是你一个赶上号的话

01:06:45.360 --> 01:06:49.160
他是不是他就是force啊然后再转一遍啊是不是就是去啊

01:06:49.840 --> 01:06:53.240
看到没有啊那比如说我们这边啊比如就这个嘛

01:06:53.740 --> 01:06:54.260
undefined

01:06:56.460 --> 01:06:57.460
然后这边那就是

01:06:58.420 --> 01:07:08.310
两个赶上号啊然后下这边走是force啊对不对快速的话就转出来了啊

01:07:09.790 --> 01:07:13.390
啊这个是非好然后接下来的话这个且

01:07:14.350 --> 01:07:23.310
且的话是什么呢且的话就是呃要就是他这边一般的话就是拼接两个表达式啊就是左边一个右边一个

01:07:23.810 --> 01:07:26.290
那两个表达式的话都为真

01:07:27.210 --> 01:07:29.810
他才反回真如果有一个为假

01:07:30.610 --> 01:07:33.090
他就是假啊就是这个是且

01:07:35.200 --> 01:07:36.000
且运算浮

01:07:38.460 --> 01:07:39.380
就 end end

01:07:40.220 --> 01:07:40.740
运算浮

01:07:43.020 --> 01:07:44.620
啊这个的话就是你

01:07:46.820 --> 01:07:47.420
有

01:07:48.700 --> 01:07:49.220
一个

01:07:49.740 --> 01:07:50.220
为

01:07:50.500 --> 01:07:50.740
假

01:07:52.420 --> 01:07:54.260
就什么呢就都为假

01:07:57.440 --> 01:07:58.080
就都为假

01:08:00.140 --> 01:08:01.460
然后全部

01:08:02.300 --> 01:08:05.100
为真啊最终

01:08:06.500 --> 01:08:08.260
才会得到

01:08:08.860 --> 01:08:09.180
真

01:08:10.100 --> 01:08:17.780
对吧啊这个的话你就注意什么呢就一定要注意短路现象啊这个运算浮其实我相信大家这个应该是知道的就是注意

01:08:18.660 --> 01:08:19.340
短路现象

01:08:20.620 --> 01:08:23.300
这也是经常就是面试的时候终于考察了一个东西

01:08:23.780 --> 01:08:24.700
什么叫做短路现象

01:08:25.220 --> 01:08:27.700
就我这个end的符号是不是两个为真

01:08:28.380 --> 01:08:29.060
最终才是真

01:08:29.620 --> 01:08:30.620
有一个为假

01:08:31.420 --> 01:08:37.820
这不就是假那比如说我第一个为假的时候我第一个字已经为假了我还有没有必要去计算第二个

01:08:38.820 --> 01:08:40.340
所以就没有必要去计算第二个了

01:08:40.860 --> 01:08:43.700
对不对啊那他最终得到的字就是假啊

01:08:45.740 --> 01:08:46.500
这边你看一下

01:08:48.300 --> 01:08:59.060
这种跳过第二个运算值的机制称之为这个短路啊为什么呢因为你这个第一个已经为forced的话那我就没有必要再计算第二个了

01:09:00.380 --> 01:09:06.060
啊然后其他的话就没什么了啊哦还有一个

01:09:08.020 --> 01:09:08.500
就是这个

01:09:09.260 --> 01:09:12.260
就是这个运算浮啊并这个运算浮他可以连用

01:09:12.660 --> 01:09:16.100
然后他会返回什么呢返回第一个不而之为forced

01:09:16.700 --> 01:09:17.420
表达式的字

01:09:17.940 --> 01:09:19.060
如果都为去

01:09:19.620 --> 01:09:24.500
返回什么呢返回最后一个表达式的字啊什么意思比如说我们这边我们来举个例子

01:09:25.300 --> 01:09:28.380
哎比如说你看他面试的时候有可能会这个样子比较一

01:09:29.460 --> 01:09:30.260
and 二

01:09:31.180 --> 01:09:33.140
你注意哦这边的话你看这个是一这个是二

01:09:33.620 --> 01:09:37.860
哎仿佛这边的话啊不是不而之这边是不是也是不是不而之啊啊

01:09:38.540 --> 01:09:44.260
然后你这边的话你肯定会想到他这边是不是会把它转成不而之把它转成不而之啊

01:09:44.260 --> 01:09:48.980
然后这个处处然后最后返回处啊他这边的话他最终返回的是什么呢

01:09:49.260 --> 01:09:53.140
返回的是你这边一一是不是去对不对

01:09:53.160 --> 01:09:56.200
给大家二二识别是去啊他就返回最后的这个

01:09:56.800 --> 01:09:59.920
直啊他返回的是直说这边得到了什么得到是二

01:10:01.680 --> 01:10:03.360
可不可以啊比如我这边再来 and

01:10:04.680 --> 01:10:08.880
and 3 and 4 and 5

01:10:09.800 --> 01:10:15.400
那接下来这个是处啊处这个识别是处处全部都是处那全部都是处返回最后一个

01:10:15.960 --> 01:10:19.080
这个值啊最后一个为真的值所以这边得到就是

01:10:19.540 --> 01:10:19.740
我

01:10:20.900 --> 01:10:25.660
可不可以啊但是你这边的如果一旦有一个为假了用这边啊0

01:10:27.220 --> 01:10:33.580
啊这个是真对吧这个是真到这这是不是假了他就会返回第一个假值因为后面我没有必要再算了吗

01:10:33.940 --> 01:10:38.300
短路现象后面没有没有必要了所以这边返回就什么了返回这个就是0

01:10:39.300 --> 01:10:39.460
走

01:10:40.260 --> 01:10:40.580
可不可以啊

01:10:41.220 --> 01:10:45.260
返回的就是0啊你要注意啊这边的话会有一个考点

01:10:47.020 --> 01:10:48.100
啊这是关于这个

01:10:49.300 --> 01:10:53.500
关于这个且啊且好那接下来下面这个货

01:10:54.060 --> 01:10:58.260
货的话就和它是相反的货的话只要有一个

01:10:58.860 --> 01:10:59.260
为真

01:11:00.060 --> 01:11:06.820
他最终就是真除非你全部都是假啊所以说他的短路现象就是什么呢他的短路现象就是第一个为真的时候

01:11:07.660 --> 01:11:10.540
后面就不会再算了啊好

01:11:11.220 --> 01:11:11.940
然后这个

01:11:12.920 --> 01:11:18.080
这个货的话他也是可以连用啊然后返回第一个布尔直为这个去的

01:11:18.840 --> 01:11:25.000
表达式的这个字啊如果都是负担返回最后一个这个负担的字啊就和刚才那个是不是反的

01:11:25.760 --> 01:11:26.280
对不对

01:11:26.800 --> 01:11:27.800
我们这边我们来写一下

01:11:28.320 --> 01:11:29.360
这个货

01:11:31.940 --> 01:11:32.700
货运算幅

01:11:35.780 --> 01:11:39.100
有一个是真值

01:11:40.380 --> 01:11:43.460
真值就什么呢就为真值

01:11:44.220 --> 01:11:45.000
就为真

01:11:45.260 --> 01:11:45.760
啊

01:11:46.020 --> 01:11:46.980
如果

01:11:47.540 --> 01:11:48.580
全部

01:11:48.840 --> 01:11:50.380
都为假

01:11:51.140 --> 01:11:51.900
那最终

01:11:53.180 --> 01:11:53.700
就是

01:11:53.940 --> 01:11:54.220
假

01:11:54.980 --> 01:11:56.460
啊然后接下来这边的话

01:11:57.020 --> 01:11:58.820
比如我是以这种数字为例

01:11:59.080 --> 01:11:59.840
比如说我这边

01:12:03.260 --> 01:12:04.040
点log

01:12:04.800 --> 01:12:06.600
好我这边的话比如说我这边

01:12:06.860 --> 01:12:07.120
1

01:12:07.620 --> 01:12:08.640
或者2

01:12:09.160 --> 01:12:10.440
或者3

01:12:10.700 --> 01:12:11.960
或者4

01:12:12.220 --> 01:12:13.240
或者5

01:12:13.500 --> 01:12:16.320
ok那我这边一开始这个是不是就是真值了

01:12:16.880 --> 01:12:19.640
那一开始就是真值那我后面是不是没有必要再去看了

01:12:19.900 --> 01:12:21.880
对不对你最终返回的一定是一个真值

01:12:22.140 --> 01:12:24.080
那我这边返回就什么了返回的就是1

01:12:25.840 --> 01:12:26.880
啊这边返回的就是1

01:12:27.140 --> 01:12:28.660
除非什么除非全部都是假

01:12:28.920 --> 01:12:30.200
啊比如你第一个是假

01:12:31.220 --> 01:12:31.980
第二个

01:12:32.500 --> 01:12:33.260
也是假

01:12:33.520 --> 01:12:34.800
对吧你这个控制创也是假

01:12:35.060 --> 01:12:35.820
第三个

01:12:36.080 --> 01:12:36.840
也是假

01:12:37.100 --> 01:12:41.980
好到第四个是真值那这接下来他只要找到真值了那这边好返回这个真值

01:12:42.240 --> 01:12:42.740
走

01:12:43.420 --> 01:12:46.840
这不就是4对不对除非什么除非全是假啊比我这个

01:12:47.600 --> 01:12:48.120
空

01:12:48.380 --> 01:12:49.140
然后接下这边

01:12:49.660 --> 01:12:50.160
控制创

01:12:50.420 --> 01:12:52.720
那他就返回什么了返回最后一个

01:12:52.980 --> 01:12:53.740
假值

01:12:54.520 --> 01:12:55.020
走

01:12:55.280 --> 01:12:56.560
克拉米亚是不是就控制创

01:12:56.820 --> 01:12:57.600
或者

01:12:58.100 --> 01:12:59.640
搞成这个吗

01:13:01.180 --> 01:13:01.680
走

01:13:02.200 --> 01:13:02.960
是吧

01:13:03.480 --> 01:13:03.980
克拉米亚

01:13:04.240 --> 01:13:06.540
他就和上面的这个是反折的

01:13:06.800 --> 01:13:08.340
注意这些细节

01:13:09.360 --> 01:13:09.880
好

01:13:10.140 --> 01:13:11.160
然后

01:13:12.140 --> 01:13:13.160
三元

01:13:13.420 --> 01:13:15.980
三元就不说了啊三元的话就是这边

01:13:16.240 --> 01:13:18.020
这个问号看你是真还是假

01:13:18.280 --> 01:13:19.820
真的话执行第一个表达是

01:13:20.080 --> 01:13:21.360
假的话执行第二个

01:13:21.620 --> 01:13:22.120
表达是

01:13:22.380 --> 01:13:23.920
他其实就是义佛要死的

01:13:24.420 --> 01:13:24.940
是不是说写

01:13:25.700 --> 01:13:26.220
对不对

01:13:26.480 --> 01:13:27.500
义佛要死了说写

01:13:28.780 --> 01:13:29.540
好下一个

01:13:30.060 --> 01:13:31.860
下一个是这个卫运算浮

01:13:32.620 --> 01:13:35.940
我们来看一下这个可能大家用的很少啊我们来看一下这个卫运算浮

01:13:36.920 --> 01:13:42.800
好这个卫运算浮是什么呢卫运算浮的话他是首先先将你的这个操作数

01:13:43.060 --> 01:13:44.600
转成二净子

01:13:45.360 --> 01:13:47.160
转成二净子是不是就是零一零一零一

01:13:47.420 --> 01:13:47.920
对不对

01:13:48.180 --> 01:13:49.460
然后按照每一位

01:13:49.720 --> 01:13:51.520
来进行这个运算啊

01:13:52.800 --> 01:13:54.320
这里是运算

01:13:58.380 --> 01:14:00.160
进行运算啊比我们举个例子

01:14:00.420 --> 01:14:00.940
比我五

01:14:01.160 --> 01:14:04.320
五的话我们把转成二净子他这边就是零零零零零零零

01:14:04.580 --> 01:14:05.480
101

01:14:05.760 --> 01:14:09.040
看没有啊因为我们要满就是保证32位

01:14:09.280 --> 01:14:11.120
前面不足的就补零就可以了

01:14:11.640 --> 01:14:13.900
好100的32位啊就是零零零零

01:14:14.160 --> 01:14:15.480
1100

01:14:15.740 --> 01:14:16.320
100

01:14:16.560 --> 01:14:17.020
看没有

01:14:17.280 --> 01:14:18.440
15的32位

01:14:18.800 --> 01:14:19.680
这边呢就是

01:14:19.940 --> 01:14:21.380
零零零要要要

01:14:21.640 --> 01:14:22.040
ok

01:14:22.300 --> 01:14:24.320
然后接下来他这边有这么几个操作浮

01:14:24.580 --> 01:14:26.740
首先这边的话是一个这个安慰飞

01:14:27.500 --> 01:14:30.840
安慰飞就什么呢安慰飞就是把每一位你所见是不是转成二净子了

01:14:30.940 --> 01:14:37.080
转成二净子 然后每一位 你是0 我就给你变成1 你是1 我就给你变成0

01:14:38.100 --> 01:14:39.900
可不可以啊 说我这边的话这个

01:14:40.660 --> 01:14:43.480
安慰飞 他前面是个飘啊 这边

01:14:43.740 --> 01:14:49.120
飘这个5 那就是把它的这个二净子 它的二净子是这个 是吧 那全部取反

01:14:49.880 --> 01:14:53.480
全部取反 然后这边就是1111 然后加010

01:14:54.240 --> 01:14:56.280
那转出来就是什么呢 转出来就是

01:14:56.540 --> 01:14:57.040
付6

01:14:57.640 --> 01:14:59.860
有同学觉得很奇怪 为什么是付的

01:15:00.120 --> 01:15:02.920
因为你这边第一位 第一位以前是0 现在转成什么了

01:15:03.180 --> 01:15:03.960
就转成1了

01:15:04.460 --> 01:15:05.740
我们第一位的话 符号位

01:15:06.520 --> 01:15:07.280
符号位

01:15:07.540 --> 01:15:08.560
你0是正

01:15:08.820 --> 01:15:09.580
1是负

01:15:10.100 --> 01:15:11.380
所以转出来是一个负的

01:15:11.900 --> 01:15:15.980
所以安慰飞的话 他实际上就是对这个操作数 求这个负

01:15:16.760 --> 01:15:18.540
就是比如说5 他就是

01:15:18.800 --> 01:15:21.880
转成负5 然后再减一个1 变成负6

01:15:22.380 --> 01:15:22.900
看到没有

01:15:24.180 --> 01:15:25.700
好 然后接下来的话 这边

01:15:26.160 --> 01:15:27.200
安慰语

01:15:27.440 --> 01:15:30.000
就是一个and的符号 我们这边我们看一下

01:15:31.040 --> 01:15:31.540
这边

01:15:32.560 --> 01:15:33.600
慰运算符

01:15:36.700 --> 01:15:37.200
慰

01:15:37.980 --> 01:15:38.740
运算符

01:15:42.050 --> 01:15:43.330
比如说我们这边log

01:15:44.610 --> 01:15:46.650
log这个飘这个5

01:15:47.170 --> 01:15:48.450
他打印出来就多少呢

01:15:49.470 --> 01:15:50.230
是付6

01:15:50.750 --> 01:15:51.250
对不对

01:15:52.030 --> 01:15:56.370
好 然后接下来下一个 下一个是这个安慰语 安慰语就是一个and

01:15:56.630 --> 01:15:57.410
一个and

01:15:57.670 --> 01:16:00.230
他是首先还是先转成这个32位的二净子

01:16:00.770 --> 01:16:02.830
然后接下来的话 每一位

01:16:03.090 --> 01:16:06.150
按照这个慰运算的规则来计算

01:16:06.670 --> 01:16:07.950
那慰运算的规则是什么呢

01:16:08.210 --> 01:16:08.710
你看

01:16:08.970 --> 01:16:10.250
两个都为1

01:16:10.510 --> 01:16:12.810
那就是1 只要有一个为0

01:16:13.070 --> 01:16:13.830
最终就是0

01:16:14.090 --> 01:16:16.150
这就和我们刚才这个讲那个

01:16:16.410 --> 01:16:17.430
逻辑运算符

01:16:17.690 --> 01:16:19.730
里面的那个语是一样的

01:16:19.990 --> 01:16:20.490
对不对

01:16:21.770 --> 01:16:24.070
就是两个都是真 因为1你可以把它看出是真嘛

01:16:24.330 --> 01:16:25.870
对吧 两个都是真的时候

01:16:26.130 --> 01:16:26.890
最终才是真

01:16:27.150 --> 01:16:28.930
得到这个1 只要有一个为假

01:16:29.130 --> 01:16:32.470
比如这0 或者两个都是0 只要有一个是假

01:16:32.730 --> 01:16:35.030
最终得到的是这个0 这个假字

01:16:35.550 --> 01:16:36.050
对不对

01:16:36.310 --> 01:16:37.330
说说你看这边

01:16:37.590 --> 01:16:38.350
比如12

01:16:38.870 --> 01:16:40.910
然后与一个这个10

01:16:41.170 --> 01:16:43.730
最终得到的是什么呢 最终得到的是这个8

01:16:43.990 --> 01:16:46.030
为什么呢 因为12二净子是

01:16:46.290 --> 01:16:47.570
1100

01:16:47.830 --> 01:16:49.630
10的话是1010

01:16:49.870 --> 01:16:52.170
那你这边的话 第一位1

01:16:52.430 --> 01:16:52.930
1

01:16:53.190 --> 01:16:54.990
是不是得到1 后面是不是都是0

01:16:55.770 --> 01:16:58.830
对不对 说得到了什么了 得到了是这个8

01:16:59.150 --> 01:16:59.650
好

01:17:00.170 --> 01:17:02.470
好 然后接下来的话是安慰货

01:17:02.730 --> 01:17:05.270
安慰货的话就和刚才那个布尔

01:17:05.530 --> 01:17:07.590
运算符里面的那个货是一样的

01:17:09.370 --> 01:17:10.910
这边 比如说我这个1

01:17:11.170 --> 01:17:14.250
1那得到就是1 只要有一个是1

01:17:15.010 --> 01:17:15.890
就一个是真

01:17:16.150 --> 01:17:17.070
所以最终得到就是1

01:17:17.310 --> 01:17:18.590
对不对 除非你两个都是假

01:17:18.850 --> 01:17:19.610
两个都是0

01:17:19.870 --> 01:17:21.150
那最终得到的是0

01:17:21.410 --> 01:17:21.910
看到没有

01:17:22.170 --> 01:17:23.210
那还是看这个例子

01:17:23.470 --> 01:17:25.250
有1 1

01:17:25.510 --> 01:17:26.530
就是这一列

01:17:26.790 --> 01:17:27.550
是不是得到是1

01:17:28.010 --> 01:17:29.030
1 0

01:17:29.290 --> 01:17:31.330
是不是1 0 1是不是也是1

01:17:31.590 --> 01:17:33.650
那最后这个两个都是0 所以得到是0

01:17:33.910 --> 01:17:35.690
所以这边是1110

01:17:36.470 --> 01:17:36.970
看到没有

01:17:37.230 --> 01:17:39.030
安慰这个结果就是1110

01:17:39.290 --> 01:17:40.550
最终得到的就是

01:17:40.810 --> 01:17:41.330
14

01:17:43.110 --> 01:17:45.670
好 然后接下来还有这个异货

01:17:46.190 --> 01:17:47.930
异货的话它就是什么呢

01:17:48.190 --> 01:17:49.770
它两位不同

01:17:50.030 --> 01:17:52.590
返回1 两位相同返回0

01:17:53.110 --> 01:17:55.910
比如说这边1 1 两位是不相同返回0

01:17:56.370 --> 01:17:58.430
好 10 不同返回1

01:17:58.690 --> 01:18:00.470
0 1 不同返回1

01:18:00.730 --> 01:18:02.770
0 0 相同返回0

01:18:03.530 --> 01:18:04.050
看到没有

01:18:04.310 --> 01:18:06.350
所以接下来这边这个12

01:18:06.610 --> 01:18:08.650
然后接下来异货一个10

01:18:08.910 --> 01:18:10.190
得到的是6

01:18:10.450 --> 01:18:11.990
我们这边我可以看一下

01:18:12.750 --> 01:18:13.790
给我们这边log

01:18:14.550 --> 01:18:18.390
12 比如说并一个10

01:18:18.650 --> 01:18:19.450
然后12

01:18:20.190 --> 01:18:21.070
货一个10

01:18:21.330 --> 01:18:23.250
然后12还有一个什么 这边异货

01:18:24.230 --> 01:18:26.010
把它打印出来看一下

01:18:26.270 --> 01:18:27.550
这边是8

01:18:27.810 --> 01:18:28.310
14

01:18:28.570 --> 01:18:29.350
这边是6

01:18:29.610 --> 01:18:30.110
对吧

01:18:31.390 --> 01:18:31.910
ok

01:18:32.170 --> 01:18:34.210
这就是它计算的这个规则

01:18:35.490 --> 01:18:36.250
计算的规则

01:18:36.770 --> 01:18:38.310
好 那如果是像这种

01:18:38.810 --> 01:18:40.870
我们看到这种的话是不是就是不是数字

01:18:41.630 --> 01:18:42.910
对不对 不是数字

01:18:43.170 --> 01:18:44.970
不是数字这边它又怎么计算的呢

01:18:46.750 --> 01:18:47.530
它这里的话

01:18:47.790 --> 01:18:49.570
如果两个操作数

01:18:49.830 --> 01:18:51.350
只有一个违征

01:18:51.570 --> 01:18:52.470
它就返回1

01:18:52.730 --> 01:18:54.890
就和刚才这个规则其实是一样的嘛

01:18:55.150 --> 01:18:56.810
对吧 只要有一个违征返回1

01:18:57.070 --> 01:18:59.010
如果两个都违征或者都违

01:18:59.250 --> 01:18:59.750
假

01:19:00.010 --> 01:19:00.770
它就返回0

01:19:01.030 --> 01:19:02.310
比如这边这个是

01:19:03.070 --> 01:19:04.350
q的话是真

01:19:05.130 --> 01:19:05.630
对吧

01:19:05.890 --> 01:19:07.930
然后接下来的话 这边这个Hello

01:19:08.190 --> 01:19:10.250
Hello的话 它这边会做一个转换

01:19:10.510 --> 01:19:13.050
它会转换成什么呢 会转换成NAN

01:19:13.310 --> 01:19:14.330
NAN是不是假

01:19:14.850 --> 01:19:17.410
对不对 一真一假 所以这边返回1

01:19:17.670 --> 01:19:18.950
那这边Force

01:19:19.210 --> 01:19:19.970
那加这边

01:19:20.430 --> 01:19:22.490
这边这个是假 这个是不是也是假

01:19:23.250 --> 01:19:25.290
都是假 所以这边返回什么呢

01:19:25.550 --> 01:19:26.590
返回这个0

01:19:27.850 --> 01:19:29.650
好 这是关于这个异货

01:19:30.170 --> 01:19:32.470
最后一个就是这个移位

01:19:33.490 --> 01:19:34.510
最后就是个移位

01:19:34.770 --> 01:19:35.790
这个的话就是

01:19:36.050 --> 01:19:37.070
两个

01:19:37.330 --> 01:19:39.370
两个小余号或者两个大余号

01:19:39.630 --> 01:19:42.710
就是向左或者向右进行一个移位

01:19:42.970 --> 01:19:45.270
它实际上就是高效率的将数字

01:19:45.530 --> 01:19:47.310
乘以或者处以二

01:19:47.570 --> 01:19:49.110
的指定数的次方

01:19:50.330 --> 01:19:51.410
给我们举个例子

01:19:51.670 --> 01:19:52.490
有这边二

01:19:52.750 --> 01:19:54.530
二然后接下来的话 这边

01:19:55.050 --> 01:19:57.610
向左边移 二 然后加得到这个8

01:19:57.850 --> 01:19:58.870
它是怎么得到的

01:19:59.390 --> 01:20:00.170
它是这样子的

01:20:00.670 --> 01:20:04.010
这里的话我们首先二 二转称二进去是不是0000

01:20:04.270 --> 01:20:05.030
是不是10

01:20:05.790 --> 01:20:06.310
对不对

01:20:06.570 --> 01:20:07.590
这个是2

01:20:07.850 --> 01:20:10.150
好 再将我要把它移两位

01:20:10.410 --> 01:20:12.190
移两位的话 也就是这个1

01:20:12.450 --> 01:20:13.470
移到这

01:20:13.730 --> 01:20:14.250
是不是移位

01:20:14.510 --> 01:20:15.210
移到这

01:20:15.470 --> 01:20:16.030
是不是两位

01:20:16.290 --> 01:20:17.570
那是不是就变成多少 0000

01:20:17.770 --> 01:20:19.830
所以10000

01:20:20.090 --> 01:20:21.870
以前这个1是不是在这个位置

01:20:22.390 --> 01:20:23.670
对不对 是不是移到这个位置了

01:20:25.450 --> 01:20:27.510
它最终的话 这个转出来就是什么

01:20:27.770 --> 01:20:29.050
转出来就是这个8

01:20:29.550 --> 01:20:30.830
转出来就是这个8

01:20:31.090 --> 01:20:34.930
那它就相当于什么了 它就快速的乘以了什么 二的二次方

01:20:36.730 --> 01:20:37.230
看到没有

01:20:37.490 --> 01:20:39.030
就快速的乘以二的二次方

01:20:39.290 --> 01:20:40.550
也就是说我这边上我这

01:20:40.810 --> 01:20:41.990
向左移几位

01:20:42.250 --> 01:20:43.070
其实就是

01:20:43.330 --> 01:20:44.650
乘以这个数的

01:20:44.910 --> 01:20:45.430
多少次方

01:20:45.690 --> 01:20:46.710
比如说我们这边

01:20:47.430 --> 01:20:48.190
我们再来一个

01:20:51.480 --> 01:20:52.780
log

01:20:53.540 --> 01:20:53.800
二

01:20:54.060 --> 01:20:54.820
然后

01:20:55.080 --> 01:20:55.840
比如说三

01:20:56.360 --> 01:20:57.380
这不就是移三位

01:20:57.640 --> 01:20:58.660
等价于什么呀

01:21:00.200 --> 01:21:02.000
等价于

01:21:02.500 --> 01:21:03.520
然后乘以

01:21:04.800 --> 01:21:06.600
等价于乘以

01:21:08.620 --> 01:21:10.660
乘以这个二的

01:21:10.920 --> 01:21:11.680
是不是30方

01:21:13.640 --> 01:21:14.140
对不对

01:21:14.400 --> 01:21:16.960
二的30方 二的是20的8

01:21:17.220 --> 01:21:19.140
对吧 8再乘一个这个2

01:21:19.400 --> 01:21:20.040
是不是16

01:21:21.040 --> 01:21:22.560
是不是就应该是10了

01:21:23.060 --> 01:21:23.480
对不对

01:21:23.720 --> 01:21:25.440
让我这边来比如说随便拿一个数

01:21:25.880 --> 01:21:26.640
比如这个10

01:21:27.680 --> 01:21:29.200
10的话 然后接下来

01:21:29.460 --> 01:21:31.000
乘以一个8

01:21:31.760 --> 01:21:33.040
是不是就是应该是80

01:21:33.820 --> 01:21:34.320
对不对

01:21:34.580 --> 01:21:35.360
就是应该是80

01:21:35.620 --> 01:21:38.940
这边的话就相当于是快速的乘以这个二的三次方

01:21:39.200 --> 01:21:40.480
那你也向右边移

01:21:42.870 --> 01:21:43.630
向右边移

01:21:43.890 --> 01:21:45.690
向右边移是不是就是应该是除一个二的

01:21:45.950 --> 01:21:46.450
三次方

01:21:47.190 --> 01:21:48.250
对不对 我们看一下这个字

01:21:48.510 --> 01:21:50.050
这边得到的字是1

01:21:50.550 --> 01:21:51.330
我们这边我们来看一下

01:21:52.410 --> 01:21:52.910
这边

01:21:53.430 --> 01:21:56.750
这里向右移 向右移的话它就是除以二的指定次方

01:21:57.010 --> 01:21:58.290
比如说这个16

01:21:59.050 --> 01:22:00.850
向右边移移位

01:22:01.110 --> 01:22:03.650
那就是二的移次方就是二

01:22:03.910 --> 01:22:05.970
然后16除以二是不是就得到8

01:22:06.550 --> 01:22:08.270
对不对 通过这种移位的方式

01:22:08.790 --> 01:22:10.050
它这个有什么意义呢

01:22:10.310 --> 01:22:12.110
它这种的话就是会非常高效

01:22:12.870 --> 01:22:14.150
因为我们知道这个

01:22:14.910 --> 01:22:15.430
最终

01:22:15.690 --> 01:22:16.710
我们做计算

01:22:16.970 --> 01:22:19.030
是不是都是会转成二进值来做计算

01:22:19.530 --> 01:22:21.830
对不对 你这个数值在做计算的时候

01:22:22.670 --> 01:22:24.270
最终都是转成二进值

01:22:24.950 --> 01:22:27.510
好 这种你这边直接用这个未运算幅的话

01:22:27.770 --> 01:22:29.830
它这个计算

01:22:30.090 --> 01:22:31.870
就比如说你要乘一个二的多少次方

01:22:32.130 --> 01:22:33.410
或者除一个二的多少次方

01:22:33.670 --> 01:22:34.670
你用这种未运算幅

01:22:34.930 --> 01:22:36.210
速度就要快一些

01:22:36.470 --> 01:22:37.750
就非常的高效

01:22:38.010 --> 01:22:39.030
而但整体来讲的话

01:22:39.290 --> 01:22:41.850
这个未运算幅确实是用的比较少的

01:22:42.610 --> 01:22:44.410
对吧 我相信你写代码写了这么久

01:22:44.670 --> 01:22:46.210
你基本上已经一次都没用过

01:22:46.710 --> 01:22:48.770
所以这个的话就作为了解

01:22:49.270 --> 01:22:50.550
你知道有这么一个东西

01:22:51.190 --> 01:22:52.910
对吧 不至于别人跟你说的时候

01:22:53.170 --> 01:22:54.590
你一脸懵逼

01:22:54.850 --> 01:22:56.390
未运算幅是啥

01:22:58.950 --> 01:23:03.050
好 接下来的话 其他运算幅 这边有一个这个void

01:23:04.330 --> 01:23:06.630
void的话 它这边的话

01:23:07.150 --> 01:23:09.190
它就是不返回任何值

01:23:09.450 --> 01:23:11.230
或者说返回这个undefine

01:23:11.490 --> 01:23:13.530
void的话 基本上用在什么地方呢

01:23:13.790 --> 01:23:15.850
void的话 我们来看一下

01:23:17.980 --> 01:23:21.560
void早期的是主要是用于就是这个超级链接中

01:23:21.760 --> 01:23:24.320
插入这个代码防止网页跳转

01:23:24.560 --> 01:23:26.640
比如说我们这边我们写个A标签

01:23:27.660 --> 01:23:28.840
比如说我们这边

01:23:29.440 --> 01:23:31.240
写一个这个A标签

01:23:31.760 --> 01:23:33.800
但在这边的话 我们在这个js里面

01:23:34.560 --> 01:23:35.600
不太好写

01:23:36.100 --> 01:23:37.380
比如这边的话 有一个这个A标签

01:23:37.640 --> 01:23:40.720
A标签的话 然后我们这边的话 比如说给它一个点击事件

01:23:41.480 --> 01:23:43.280
就比如说一个horif

01:23:45.060 --> 01:23:47.360
好 接下来这边 你就可以写这个void

01:23:48.080 --> 01:23:49.360
我想想

01:23:49.620 --> 01:23:51.660
这个horif一般就写个请号

01:23:51.920 --> 01:23:53.960
那这样我们这边 比如说一个点击事件

01:23:54.220 --> 01:23:54.720
对吧

01:23:56.020 --> 01:23:57.180
然后

01:23:57.440 --> 01:23:58.820
unclick

01:23:59.080 --> 01:24:00.360
然后不不不

01:24:00.620 --> 01:24:01.840
就是写在horif

01:24:02.120 --> 01:24:03.840
对的 就写在horif

01:24:04.100 --> 01:24:05.740
好 比如说我们这边正常来讲的话

01:24:06.000 --> 01:24:07.800
A标签是不是写horif证明的值

01:24:08.060 --> 01:24:08.820
它就可以跳转

01:24:09.080 --> 01:24:10.860
对吧 然后这样我们像阻止它跳转

01:24:11.120 --> 01:24:13.680
你这边就可以直接写这个void

01:24:14.200 --> 01:24:16.240
代表它这个跳转是一个空

01:24:16.860 --> 01:24:19.920
就是以前你看别人写这个早期的时候写js代码

01:24:20.160 --> 01:24:23.100
很多就是这边horif 写一个这个空

01:24:23.360 --> 01:24:24.640
代表就是不跳转

01:24:24.900 --> 01:24:27.460
当然现在的话见到比较少了

01:24:28.480 --> 01:24:30.780
这是这个orid了解一下就可以了

01:24:31.560 --> 01:24:33.600
然后逗号运算符

01:24:33.860 --> 01:24:36.420
逗号运算符就是做分隔的吗

01:24:36.680 --> 01:24:38.460
A然后逗号B

01:24:38.720 --> 01:24:40.000
做这个分隔的

01:24:40.260 --> 01:24:41.540
好 这个也不说了

01:24:41.800 --> 01:24:44.360
好 然后接下来就是关于一个这个

01:24:44.820 --> 01:24:46.620
运算符的这个优先级

01:24:47.380 --> 01:24:49.680
我们这个运算符的话它会有不同

01:24:49.940 --> 01:24:51.740
就是不同的这个优先级别

01:24:52.240 --> 01:24:54.300
优先级高的就先运算

01:24:54.560 --> 01:24:56.600
优先级低的就后运算

01:24:57.360 --> 01:24:59.680
比如说这个 这个其实我们学数学是不是都知道

01:25:00.440 --> 01:25:01.720
对不对 你这边那就是

01:25:01.980 --> 01:25:04.020
先乘除再加减

01:25:04.540 --> 01:25:06.580
那我如果要改变这个优先级怎么办呢

01:25:06.840 --> 01:25:07.860
我是不是加一个扩号

01:25:08.880 --> 01:25:10.680
对不对 我加一个扩号就可以了

01:25:10.940 --> 01:25:12.720
说这个优先级我们不需要去背

01:25:13.120 --> 01:25:14.000
不需要去背

01:25:14.260 --> 01:25:15.280
你这个有什么好背的呢

01:25:15.540 --> 01:25:16.820
我比如说我想提高

01:25:17.080 --> 01:25:18.600
某个地方的优先级我干嘛呀

01:25:18.860 --> 01:25:20.660
我是不是直接比如说这边给他加一个扩号

01:25:20.920 --> 01:25:21.940
这个加一个扩号

01:25:22.700 --> 01:25:23.460
是不是就OK了

01:25:23.980 --> 01:25:26.040
对不对 所以这个不需要去记的

01:25:26.540 --> 01:25:27.060
你看这边

01:25:27.320 --> 01:25:30.640
记住所有运算符的优先级非常难的也没有必要

01:25:30.900 --> 01:25:32.440
你如果要提高你干嘛呢

01:25:32.700 --> 01:25:33.960
你加上一个扩号

01:25:34.220 --> 01:25:35.500
加上一个扩号

01:25:36.020 --> 01:25:36.520
就可以了

01:25:37.040 --> 01:25:38.320
这边这个远扩号

01:25:38.820 --> 01:25:40.620
远扩号的作用就是拿来干嘛呢

01:25:40.820 --> 01:25:42.880
提高运算的优先级

01:25:43.140 --> 01:25:44.920
因为他的优先级是最高的

01:25:45.180 --> 01:25:46.720
远扩号中的表达是

01:25:46.980 --> 01:25:47.740
会第一个

01:25:48.000 --> 01:25:49.020
进行运算

01:25:49.540 --> 01:25:50.040
好吧

01:25:50.800 --> 01:25:52.600
这是关于这个远扩号

01:25:53.120 --> 01:25:56.180
远扩号其他我看一下啊有没有什么要说的

01:25:57.460 --> 01:25:59.520
远扩号号的话就住一下这里

01:25:59.780 --> 01:26:03.600
就是远扩号中只能放什么呢只能放表达是

01:26:03.860 --> 01:26:05.920
你如果放这个比较这个是一条语句

01:26:06.180 --> 01:26:07.960
对不对他就会抱错啊

01:26:08.220 --> 01:26:10.020
为什么因为他只能放表达是

01:26:11.080 --> 01:26:14.920
好最后一个最后一个就是关于这个左结合和右结合

01:26:15.180 --> 01:26:19.280
我们知道我们的这个运算幅有些时候是左结合有些时候是右结合

01:26:19.540 --> 01:26:20.560
就他的这个顺序

01:26:20.820 --> 01:26:21.840
你要注意一下

01:26:22.100 --> 01:26:23.380
好什么是左结合呢

01:26:23.880 --> 01:26:28.740
左结合的话就是左侧两个运算数结合在一起

01:26:29.000 --> 01:26:30.540
啊然后接下来这边先

01:26:30.800 --> 01:26:31.820
先执行左边的

01:26:32.080 --> 01:26:33.880
然后执行完了之后是不会得到一个值啊

01:26:34.380 --> 01:26:36.940
得到一个值之后然后接下来再执行右边的

01:26:37.200 --> 01:26:38.220
那这个叫做左结合

01:26:38.420 --> 01:26:39.500
右结合是什么呢

01:26:39.760 --> 01:26:42.060
右结合是就是先执行右边的

01:26:43.340 --> 01:26:45.140
右边执行了然后接下来

01:26:45.400 --> 01:26:47.180
这个是不是整体是不是得到一个值啊

01:26:47.700 --> 01:26:48.980
得到一个值然后再执行

01:26:49.480 --> 01:26:51.020
这个计算整体的这个

01:26:51.540 --> 01:26:52.820
这个是右结合

01:26:53.080 --> 01:26:55.620
就是一个从左边开始计算一个从右边开始计算

01:26:56.140 --> 01:26:57.420
好然后

01:26:57.660 --> 01:27:00.740
皆是有原因从大多数运算幅都是左结合

01:27:01.000 --> 01:27:01.520
比如说我们这边

01:27:01.780 --> 01:27:03.300
x加y加z

01:27:03.560 --> 01:27:05.620
那他是先x加这个y

01:27:06.080 --> 01:27:09.160
然后接下来干嘛呢然后接下来是不是会得到一个值啊

01:27:09.420 --> 01:27:10.940
这个值再和z

01:27:11.460 --> 01:27:13.260
进行一个这个相加

01:27:14.020 --> 01:27:17.100
然后有一些少数的是右结合比如说负值

01:27:17.600 --> 01:27:19.140
负值就是典型的右结合

01:27:19.400 --> 01:27:20.420
先把这个z

01:27:20.680 --> 01:27:21.960
负给这个y

01:27:22.220 --> 01:27:24.760
然后接下来 y的值负给x

01:27:25.020 --> 01:27:26.300
那再负给w

01:27:26.820 --> 01:27:28.620
包括这个三元运算幅

01:27:28.860 --> 01:27:29.900
也是

01:27:31.180 --> 01:27:32.960
还有就是这个指数运算幅

01:27:33.220 --> 01:27:35.020
他也是右结合这个刚才是不看的

01:27:35.380 --> 01:27:35.740
对不对

01:27:36.000 --> 01:27:38.040
2信号信号3信号信号2

01:27:38.300 --> 01:27:40.100
它是什么呢它是右结合先这样子

01:27:40.860 --> 01:27:41.780
得到这个数

01:27:42.040 --> 01:27:44.180
那再计算2的这个

01:27:44.440 --> 01:27:46.240
33的9是吧9赤方

01:27:48.280 --> 01:27:48.800
OK

01:27:49.560 --> 01:27:51.880
好这是关于整个这个运算幅啊

01:27:52.140 --> 01:27:53.920
我们又把它拉了一遍

01:27:54.180 --> 01:27:55.400
非常的多是吧

01:27:55.660 --> 01:27:56.220
挺多的

01:27:56.980 --> 01:28:00.060
其实主要就是注意什么主要就是注意这个加法

01:28:01.340 --> 01:28:03.640
加法和这个就是比较的时候

01:28:03.800 --> 01:28:05.760
它有个那个数据类型软换

01:28:06.020 --> 01:28:07.080
它是怎么软换的

01:28:07.340 --> 01:28:08.200
这个要注意一下

01:28:08.460 --> 01:28:10.120
其他都还好啊

01:28:10.880 --> 01:28:12.300
好那我们来看一下这道题

01:28:12.800 --> 01:28:17.920
下面代码中啊这个的话什么时候会打印出一

01:28:19.460 --> 01:28:21.000
我怎么让他打印出一呢

01:28:22.020 --> 01:28:24.840
哎你看这边是不是首先这个必须是q

01:28:25.600 --> 01:28:28.160
啊这个必须是q然后下这个是不是也是q

01:28:28.420 --> 01:28:29.440
这个也是q

01:28:29.700 --> 01:28:31.240
因为我们这边呢是不是and

01:28:31.500 --> 01:28:33.040
对不对and你不能有假

01:28:33.240 --> 01:28:35.200
你有假的话是不是最终得到假值

01:28:35.440 --> 01:28:36.280
是不是不会进一步啊

01:28:36.540 --> 01:28:39.640
也就是说这个要为q这个也要为q这个也要为q

01:28:40.400 --> 01:28:41.440
那这里的问题就来了

01:28:42.200 --> 01:28:46.040
让我这个的话我a如果等于1这个倒是q那这个是不是就是force

01:28:47.080 --> 01:28:49.120
对不对然后加这个是不是肯定也是force

01:28:49.640 --> 01:28:52.440
对不对你这个是force他就不会再计算这个了

01:28:52.700 --> 01:28:54.740
啊让我这个a究竟该等于多少值呢

01:28:55.000 --> 01:28:57.820
这个的话你就不能按照常规的去想

01:28:58.080 --> 01:29:00.120
我a它应该是等于什么值

01:29:00.880 --> 01:29:02.940
让我这边我就让a等于一个什么呢

01:29:03.080 --> 01:29:05.440
我让a等于一个制幅创

01:29:06.580 --> 01:29:08.480
对不对我让他等一个制幅创

01:29:08.740 --> 01:29:11.580
他是制幅创的话制幅创和一个数值比较

01:29:11.840 --> 01:29:15.020
那制幅创是不是就会设计到一个数据类型转换

01:29:16.560 --> 01:29:19.380
对不对数据类型转换那接下来他就会先干嘛呀

01:29:19.640 --> 01:29:20.940
先调这个

01:29:23.220 --> 01:29:25.980
数我看制幅创转那个数字

01:29:26.240 --> 01:29:28.480
啊他需要看你是不是存数字

01:29:28.740 --> 01:29:30.900
他总之他调的是什么调的是那个Lumber

01:29:31.660 --> 01:29:32.680
Lumber那个函数

01:29:32.880 --> 01:29:34.420
啊你如果是存数字

01:29:34.940 --> 01:29:36.720
那接下来我给你返回那个存数字

01:29:36.980 --> 01:29:38.260
那你如果是一个对象

01:29:39.540 --> 01:29:40.820
啊如果是个对象那我就干嘛

01:29:41.080 --> 01:29:42.620
说先调Value of

01:29:42.880 --> 01:29:43.460
再调

01:29:43.720 --> 01:29:44.420
to stream

01:29:45.180 --> 01:29:48.260
对不对那我这边就可以怎么办啊我这边就可以通过这种方法

01:29:48.520 --> 01:29:50.820
啊我这边呢你看我改写你的to stream

01:29:51.320 --> 01:29:53.620
我让a是首先我让a是等于一个什么

01:29:53.880 --> 01:29:55.160
是不等于一个对象啊

01:29:55.920 --> 01:29:58.220
对不对我让你a是一个对象

01:29:58.740 --> 01:30:01.060
对象然后既然你和我这个值比较的时候

01:30:01.260 --> 01:30:03.060
让我这个对象的话我先干嘛呢

01:30:03.300 --> 01:30:04.600
我先进行一个转换

01:30:05.100 --> 01:30:06.900
转换成这个数值

01:30:07.160 --> 01:30:09.960
转换的数字他是不是就会去调这个Value of

01:30:10.220 --> 01:30:13.300
调了如果还是个对象他就是调什么是不调to stream

01:30:13.560 --> 01:30:15.600
让我这边改写你的to stream方法

01:30:16.900 --> 01:30:17.400
看到没有

01:30:17.900 --> 01:30:19.440
改写你的to stream方法

01:30:19.700 --> 01:30:23.540
你的to stream方法让他返回什么呢返回a点i加加

01:30:24.820 --> 01:30:28.920
啊a点i加加的话那接下来a刚开始是不等于一届因为这个加加

01:30:29.420 --> 01:30:30.960
加加的话那是在后面

01:30:31.260 --> 01:30:33.560
后面是不是他先返回值然后接下来再加加

01:30:33.820 --> 01:30:35.620
对不对那接下来第一次就是1

01:30:36.380 --> 01:30:38.940
然后完事之后然后接下来第二次就是2

01:30:39.460 --> 01:30:42.020
那第三次他又会调to stream第三次就是3

01:30:42.540 --> 01:30:44.320
最终他会进入到这个eave

01:30:44.840 --> 01:30:46.380
我们这边我们把这个代码看一下

01:30:47.400 --> 01:30:49.180
很经典的一道面试题啊

01:30:52.170 --> 01:30:53.450
把这个删了吧

01:30:56.270 --> 01:30:57.290
我们这边我们来看一下

01:30:58.050 --> 01:30:58.570
就是画一下

01:30:59.330 --> 01:31:01.130
啊这个是非常经典的一道面试题

01:31:02.410 --> 01:31:02.910
看到没有

01:31:03.110 --> 01:31:05.270
好我这边的话我这个a是一个对象

01:31:06.190 --> 01:31:07.470
再说一遍a是个对象

01:31:07.990 --> 01:31:12.330
对象你要和这个数字的e进行比较让我这边就只能干嘛

01:31:12.590 --> 01:31:13.870
是不是做一个这个

01:31:14.630 --> 01:31:15.410
类型转换

01:31:16.170 --> 01:31:17.970
类型转换那这边的话会调什么

01:31:18.730 --> 01:31:20.530
他是不是会调这个number的这个方法

01:31:21.290 --> 01:31:23.090
调这个number这个方法他会先干嘛

01:31:23.350 --> 01:31:24.370
是不是先调这个

01:31:24.630 --> 01:31:25.650
value of

01:31:26.410 --> 01:31:26.930
对不对

01:31:27.190 --> 01:31:29.230
然后如果你返回的还是对象那接下来我

01:31:29.750 --> 01:31:30.250
调什么

01:31:30.890 --> 01:31:31.790
是不是调这个

01:31:32.050 --> 01:31:32.810
toolsdream

01:31:33.330 --> 01:31:34.350
这个是不是讲过很多遍了

01:31:35.110 --> 01:31:38.690
对不对那调这个toolsdream的话让我这边就改写你的toolsdream

01:31:38.950 --> 01:31:39.990
那你返回什么

01:31:40.250 --> 01:31:42.270
返回这边a.i++

01:31:43.050 --> 01:31:44.590
看到没有就通过这种方式

01:31:44.850 --> 01:31:47.150
或者你改哪个你改这个value of也可以

01:31:47.910 --> 01:31:49.970
改value of他就没有必要到第三步了

01:31:50.230 --> 01:31:52.270
对不对他这边直接调value of的时候

01:31:52.530 --> 01:31:54.830
就已经你这边给他返回这个就可以了

01:31:55.090 --> 01:31:56.350
比我们这边我们来看一下

01:31:56.610 --> 01:31:57.630
这边方法2

01:31:57.890 --> 01:31:59.690
方法2时候改的就是value of

01:31:59.890 --> 01:32:00.410
对不对

01:32:00.670 --> 01:32:01.690
里面的代码都是一样的

01:32:03.470 --> 01:32:07.330
好这就是关于整个这个运算符

01:32:07.830 --> 01:32:08.590
运算符

01:32:08.850 --> 01:32:10.910
JS里面有这么多运算符

01:32:11.670 --> 01:32:15.010
下去的话把这个运算符好好自己再看一看

01:32:15.510 --> 01:32:16.790
其实主要就是注意什么的

01:32:17.050 --> 01:32:17.810
注意这个

01:32:19.350 --> 01:32:21.670
注意这个数据类型的这个转换

01:32:22.430 --> 01:32:25.250
你要是能把这个数据类型的转换你把它搞清楚

01:32:25.510 --> 01:32:27.550
其实你看这个运算符其实也没啥

01:32:28.310 --> 01:32:28.830
对不对

01:32:29.050 --> 01:32:30.230
无外乎就是有些

01:32:30.490 --> 01:32:31.090
比如对象

01:32:31.350 --> 01:32:33.230
他在做运算的时候他要转换一下

01:32:33.490 --> 01:32:37.230
那转换他其实就是按照我们那个数据类型转换的规则

01:32:37.990 --> 01:32:38.770
来进行转换的

01:32:39.530 --> 01:32:40.050
对不对

01:32:41.070 --> 01:32:43.110
好这句课的话就到这里

01:32:43.370 --> 01:32:43.890
再见

