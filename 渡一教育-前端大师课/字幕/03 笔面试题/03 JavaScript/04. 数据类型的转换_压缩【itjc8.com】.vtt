WEBVTT

00:01.460 --> 00:03.500
大家好 我是谢老师

00:03.760 --> 00:07.860
把这些课的话 我们来看一下接式中的这个数据类型的

00:08.120 --> 00:08.880
转换

00:09.140 --> 00:11.700
这边有道题 就是接式中

00:11.960 --> 00:14.520
如何进行这个数据转换的

00:15.020 --> 00:15.800
我们都知道

00:16.300 --> 00:21.180
在这个接式里面啊 接式的话它是一个这个动态类型的理念

00:21.940 --> 00:25.020
也就是我们的这个变量的话是没有这个类型限制的

00:25.280 --> 00:26.540
比如说举个例子

00:27.520 --> 00:31.920
我们这边挖一个i 等于一个e 那回头的话我这边i

00:32.180 --> 00:36.020
我也可以给它复制成一个什么呀 复制成一个制服串

00:36.780 --> 00:40.100
对不对 完全是合法的 那我们这边的话

00:40.620 --> 00:41.380
打印一下

00:41.900 --> 00:42.920
然后这边

00:44.200 --> 00:44.980
这没有任何问题

00:45.240 --> 00:45.740
对不对

00:46.000 --> 00:51.120
好 然后这里的话它就会涉及到一个问题 就是你不同的这个类型

00:51.380 --> 00:54.180
在做运算的时候 它会有一些这个

00:54.440 --> 00:55.980
数据类型的这个转换

00:56.200 --> 00:56.960
比如说这边

00:57.480 --> 00:59.760
你看这个4的话它是制服串

01:00.020 --> 01:02.080
然后接下来这个3的话也是制服串

01:02.340 --> 01:04.640
但是他们做了什么呢 他们做了这个减法

01:04.900 --> 01:07.720
那做减法之后它这边的话仍然会得到这个

01:07.960 --> 01:08.980
正确的这个结果

01:09.240 --> 01:11.040
它这边的话就会把这个制服串

01:11.800 --> 01:14.360
做一个转换 转成这个Lumber类型

01:14.620 --> 01:15.900
然后加这个3也是

01:16.160 --> 01:18.200
会做一个这个类型转换

01:18.460 --> 01:21.800
转成这个Lumber类型啊 比如说我们这边我们来看一下

01:25.080 --> 01:26.620
比如说这边Log

01:27.620 --> 01:29.180
制服串的是

01:29.940 --> 01:31.480
减去一个这个3

01:32.260 --> 01:33.540
然后就在这边走

01:34.300 --> 01:34.820
看到没有

01:35.320 --> 01:37.880
是不是得到了这个1 而且你这边你可以那个

01:38.400 --> 01:39.680
可以看一下它的这个Type

01:40.440 --> 01:42.240
有1一个这个I

01:42.500 --> 01:43.260
Result吗

01:44.020 --> 01:45.300
等于一个这个

01:48.220 --> 01:50.260
等于一个制服串的4-3

01:50.520 --> 01:54.360
好 然后下我们这边打印一下Result 以及这个Type of

01:55.140 --> 01:55.640
Result

01:56.160 --> 01:57.440
好 我们这边我们来看一下

01:57.700 --> 01:58.200
看到没有

01:58.920 --> 02:00.720
这边这个Result得到的是一个什么

02:01.480 --> 02:01.980
是吧

02:02.240 --> 02:03.280
得到的是一个Lumber

02:03.540 --> 02:05.320
对不对 说明就是

02:06.080 --> 02:07.620
在JS中

02:07.880 --> 02:09.160
这是我们第二个

02:09.420 --> 02:10.440
在JS中

02:13.520 --> 02:14.020
在

02:14.280 --> 02:16.080
JS中

02:16.340 --> 02:20.420
存在什么呢 存在数据类型的

02:20.940 --> 02:21.700
转换

02:21.960 --> 02:23.760
是吧 刚才那个是第一个

02:24.520 --> 02:26.820
第一个是这个JS

02:27.080 --> 02:27.580
是

02:28.200 --> 02:28.960
动态

02:29.740 --> 02:30.240
圆

02:30.760 --> 02:31.780
然后变量

02:32.040 --> 02:33.580
可以是

02:34.080 --> 02:34.860
任意

02:36.640 --> 02:37.160
类型

02:38.440 --> 02:39.720
好 那接下来我们继续

02:39.980 --> 02:45.100
那我们刚才已经说了 就是在JS中它存在什么呢 存在数据类型的转换

02:45.360 --> 02:47.660
我们刚才也确确实实看到了它

02:47.920 --> 02:49.440
是不是做这个数据类型转换

02:49.960 --> 02:54.320
那它这边的话就是关于这个数据类型转换的一些细节问题

02:54.580 --> 02:56.360
那接下来我们就需要来看一下

02:57.080 --> 02:59.120
那关于这个数据类型转换

02:59.380 --> 03:01.940
其实大体上来分的话可以分为两类

03:02.460 --> 03:05.020
一个叫什么呢 一个叫做强制转换

03:05.540 --> 03:07.320
也许地方的话也被分支

03:07.580 --> 03:09.620
这个翻译为什么呢 就是显示

03:12.220 --> 03:13.500
这个显示

03:14.780 --> 03:15.280
显

03:16.300 --> 03:17.340
显示

03:18.620 --> 03:19.380
转换

03:19.640 --> 03:21.180
然后接下来把这个

03:21.440 --> 03:23.220
第二类是这个自动转换

03:23.480 --> 03:24.500
叫它自己执行的

03:24.760 --> 03:25.780
把这一类

03:26.160 --> 03:28.800
然后有些地方又叫什么呢 叫做影视转换

03:29.820 --> 03:31.620
其实说的是一个意思

03:32.140 --> 03:33.140
影视

03:35.100 --> 03:35.620
转换

03:35.880 --> 03:38.440
看到没有 就是从大类上来分的话

03:38.700 --> 03:40.480
可以分为这两大类

03:40.740 --> 03:44.320
显示转换和影视转换 或者强制转换

03:44.580 --> 03:45.100
自动转换

03:45.600 --> 03:48.940
好 那接下来我们一个一个来看 那首先我们来看这个强制转换

03:49.200 --> 03:50.720
或者这个显示转换

03:51.500 --> 03:54.560
那强制转换的话主要指的是什么呢

03:54.760 --> 03:57.580
主要指的是只使用这三个函数

03:58.860 --> 03:59.380
Lumber

04:00.140 --> 04:00.660
Stream

04:01.160 --> 04:02.200
和这个布林

04:02.460 --> 04:05.520
这三个函数的话分别就会讲

04:06.280 --> 04:10.900
就是分别会将其他类型的值转成什么呢 转成这个数字

04:11.160 --> 04:12.180
比如这个Lumber

04:12.680 --> 04:15.500
Lumber的话就是把其他类型转成这个数字

04:16.260 --> 04:17.540
然后这个Stream

04:17.800 --> 04:20.880
Stream的话就是把这个其他类型转成这个制服串

04:21.380 --> 04:22.300
然后接下这个布林

04:22.560 --> 04:24.460
布林的话就是把其他类型转为

04:24.760 --> 04:25.280
布尔值

04:26.040 --> 04:30.140
好 那我们一个一个来看 首先的话第一个是Lumber

04:31.420 --> 04:34.960
使用Lumber函数可以将任意类型的值

04:35.220 --> 04:38.840
转成数字类型 主要是任意类型

04:39.860 --> 04:42.680
任意类型 哪怕你丢一个数组

04:43.200 --> 04:45.000
或者丢一个这个对象

04:45.500 --> 04:48.320
我都会把它转成什么呢 转成这个数字类型

04:48.840 --> 04:50.120
那我们一个一个来看

04:50.380 --> 04:51.900
这儿分两种情况来讨论

04:52.120 --> 04:54.660
一种是什么呢 一种是原始类型的值

04:54.920 --> 04:56.200
那这种的话比较简单

04:56.460 --> 05:00.820
这种比较简单 另一种就是什么呢 另一种就是参数是对象 object

05:01.580 --> 05:04.400
这种的话我也可以把对象转成数字

05:04.660 --> 05:07.220
但是里面有一些具体的步骤

05:07.720 --> 05:09.000
好 那我们这边我们来看一下

05:10.280 --> 05:14.380
那首先第一个是原始类型 原始类型的话这边比较Lumber

05:14.640 --> 05:17.960
你如果本来就是数字 比如这边举个例子 本来就是数字

05:18.220 --> 05:20.020
那我转出来的话 是不是还是数字

05:20.780 --> 05:21.300
对不对

05:21.780 --> 05:23.140
啊 那我们把这儿写一下嘛

05:25.210 --> 05:26.090
这是第二点

05:27.650 --> 05:30.690
好 然后接下来的话这边 这边的强制转换开始

05:32.170 --> 05:32.770
强制

05:34.410 --> 05:37.970
转换 强制转换里面 然后接下来的话 首先第一个

05:40.260 --> 05:41.180
这个是第三点嘛

05:42.180 --> 05:44.820
好 3-1 这个的话是Lumber

05:45.700 --> 05:46.620
Lumber的话

05:48.140 --> 05:48.740
可以

05:49.900 --> 05:54.020
将任意 任意类型的值

05:54.660 --> 05:57.460
都转为Lumber

05:58.220 --> 05:58.820
类型

05:59.340 --> 06:03.940
对吧 然后又分成两种情况 哪两种呢 首先第一种是这个

06:04.380 --> 06:05.900
简单值

06:07.180 --> 06:08.340
简单数据类型

06:08.580 --> 06:11.340
那我们这边我们来试一下 比如说我们这边

06:13.580 --> 06:14.620
比如这边Lumber

06:15.380 --> 06:20.340
那本身是Lumber我们就不看了啊 我们这边的话 我们主要看一些就是其他类型的 比如说这边

06:20.700 --> 06:21.340
123

06:22.260 --> 06:24.100
123 好 然后加这边走

06:25.140 --> 06:30.620
看到没有 这边是不是123 他这个是黄色 黄色代表是数字 你如果是制服串的话 他是

06:31.380 --> 06:33.820
我们来看一下哈 比如你这边的话是制服串的话

06:35.300 --> 06:36.260
他是不是这个白色

06:37.340 --> 06:38.180
对不对啊

06:38.860 --> 06:43.020
好 然后接下来的话 再来一个什么呢 再来一个比如说Lock

06:44.540 --> 06:45.580
比如说我们布尔滋

06:46.420 --> 06:46.780
Number

06:47.940 --> 06:48.860
然后Q

06:49.820 --> 06:50.500
然后Force

06:52.770 --> 06:53.610
然后这边走

06:54.690 --> 06:57.730
看没有Q的话转车 转出来就是多少 是不是1

06:58.490 --> 07:00.130
然后接下来这边是不是就是0

07:01.410 --> 07:07.850
好 然后接下来这边这个制服串 制服串的话 你如果是这种制服串 数字制服串 他转出来是123

07:08.290 --> 07:10.650
那如果是这种制服串 比如谢杰

07:12.170 --> 07:12.890
谢杰

07:13.850 --> 07:14.810
那你这种的话

07:15.810 --> 07:21.290
是没办法转成数字 没办法转成数字 他得到了就什么呢 他得到了就是NAN

07:21.890 --> 07:26.170
那NAN是不是也是属于Number那些 总之我给你转成Number了嘛

07:26.610 --> 07:29.930
对不对 我NAN你这个NAN他也属于这个Number那些吗

07:30.450 --> 07:30.970
KLM

07:31.730 --> 07:34.250
而且这个Number他非常的严格

07:35.170 --> 07:41.050
怎么个严格法呢 你这边的话哪怕你这边前面是123 然后接下来的话这边

07:41.730 --> 07:45.050
谢杰 我前面是不是数字 对不对 后面是这个

07:46.010 --> 07:54.610
这个这个就是这个这个制服啊 就是字母字母啊 那他转出来还是什么呢 转出来还是NAN

07:55.370 --> 07:58.250
他和Puzzint就不一样啊 你注意 这边我写下

08:00.130 --> 08:02.330
Number和

08:03.850 --> 08:07.250
这个Puzzint就不一样

08:08.890 --> 08:13.490
Puzzint是什么样子呢 Puzzint的话他是尽可能的会去这个多转

08:15.250 --> 08:15.890
Puzzint

08:17.810 --> 08:24.810
Puzzint是会尽可能的去多转换

08:25.730 --> 08:28.770
啊 就是我这边的话 比如说我这边把这个改成Puzzint

08:31.010 --> 08:31.970
把这个改成

08:33.850 --> 08:42.170
改成这个Puzzint 那这种的话他是可以转换出来的 得到这个123 然后这边为了做一些区别 我这边

08:43.130 --> 08:44.410
加一个Puzzint

08:46.770 --> 08:51.500
啊 这个加到前面吗 把这个加到前面啊

08:54.980 --> 08:57.700
好 然后接下来这边 清空一下 走

08:58.540 --> 09:04.940
看到没有 他会尽可能的 你这边的话是123 谢杰 那既然我前面可以转数字 那既然我会把前面的

09:05.260 --> 09:07.460
转成数字 那除非是哪种的 除非是这种

09:08.140 --> 09:10.060
这种比如说一开始就是

09:10.740 --> 09:11.220
这个

09:11.980 --> 09:13.740
字母 那这种他没办法转

09:13.940 --> 09:16.540
这种没办法转 是不是得到NAN

09:17.100 --> 09:22.900
对不对 但是这个number就不一样 number的话 你只要里面有这个字母 我这边的话是不是NAN

09:23.340 --> 09:26.220
对不对 包括比如说一些其他的字符 啊 只要不是数字

09:27.060 --> 09:28.780
比如说我这边的话加一个问号

09:30.460 --> 09:34.220
走 是不是仍然是NAN 对不对 只要有

09:34.780 --> 09:38.020
不是这个数字的这个字符 那就是NAN

09:38.980 --> 09:44.300
好 然后我们的基本类型还有些什么 是不是 还有这个 only five

09:46.850 --> 09:49.490
对不对 这边的话 还有这个undefine

09:51.490 --> 09:53.050
以及什么 是不是这个 know

09:56.240 --> 09:58.600
好 那这边 接下来这边来看一下

10:00.000 --> 10:03.320
undefine的话得到的是什么 得到的是NAN

10:05.240 --> 10:11.240
NAN 而这个 know的话得到的是0 你注意这个区别啊 know的话是得到是0

10:11.600 --> 10:16.720
那接下来这个undefine 得到的是这个NAN 这个的话是有这个历史原因的

10:17.560 --> 10:18.960
最早的话就只有这个 know

10:19.880 --> 10:23.960
只有这个 know 啊 后来这个杰斯的作者觉得这个now

10:24.840 --> 10:33.320
他应该是表示没有 而不能像就是比如说我定义了个遍量没复辞 你不应该也是闹 所以才出现了这个undefine

10:35.480 --> 10:38.560
好 然后如果是parzint的话 我们这边我们来看一下

10:39.400 --> 10:40.680
如果是parzint

10:43.360 --> 10:47.680
parzint 啊 这边前面还是给个标识

10:49.080 --> 10:58.560
这边的话parzint 啊 这边啊 然后这边parzint

11:00.760 --> 11:01.760
啊 我们这边我们来看一下

11:03.200 --> 11:04.400
ok 少一个

11:05.440 --> 11:07.320
这边的话是 know

11:08.280 --> 11:16.280
now 是0 好 让下我们这边来看一下啊 这边那两个就是都是什么 如果是parzint的话 这边两个都是NAN

11:16.920 --> 11:23.560
对吧 你注意啊 就是parzint和这个number 他在这些细节上面是有一些区别的啊

11:24.280 --> 11:25.400
好 回到我们这边

11:26.480 --> 11:32.840
这个是原始类型啊 也就是说基本类型的这个转换啊 这里还刚才还少了一个 就是空置幅创

11:33.360 --> 11:36.640
空置幅创转化出来是0 比如说我们这边

11:38.320 --> 11:40.640
空置串 我们就写的第一个嘛

11:41.800 --> 11:46.120
在第一个 比如这边空置串 他转换出来是多少呢 转换出来是0

11:47.360 --> 11:48.160
比如说我们这边走

11:49.720 --> 11:53.360
看不看是0啊 这个的话就是这个简单值

11:54.000 --> 12:01.680
好 然后接下来的话 简单值看完了之后 然后接下来我们来看复杂值 然后这边的话 还有些其他的啊

12:02.280 --> 12:08.080
就是parzint和number都会自动过滤什么的 过滤这个就是制幅串

12:08.600 --> 12:13.720
前后的这个空白制幅 比如说你看这边parzint 前面是不是有这个反斜杠T

12:14.920 --> 12:15.440
代表什么

12:16.600 --> 12:17.240
代表那个

12:18.600 --> 12:20.560
这个叫什么来着 我一下子忘记名字了

12:22.400 --> 12:27.200
哦 那个字表幅 是吧 字表幅 然后反斜杠这个v

12:29.800 --> 12:37.760
呃 这个是垂直字表幅啊 这个是反斜杠T是水平字表幅 反斜杠V是垂直字表幅啊 大家这边

12:38.440 --> 12:48.000
反斜杠这个R是这个回车啊 反斜杠N是换行 他就都会把这些就给这个过滤掉啊 包括这个number也是 会把它过滤掉

12:48.440 --> 12:55.000
这个就不说了 这是转这个基本内心 接下来的话我们来看一下 重点的话来看一下这个

12:55.720 --> 13:00.760
如果你要转了直是对象内心 我们来看一下他是怎么操作的

13:03.040 --> 13:07.080
好 当我们的参数是对象的时候 他大致有这么几个步骤

13:07.640 --> 13:12.920
首先第一步 他会调用对象 自身的value方法

13:13.600 --> 13:16.080
啊 如果返回原始类型的值

13:16.920 --> 13:24.280
则直接对该值使用这个number函数 然后转成这个number之后就不进行这个后续的步骤了

13:24.920 --> 13:26.600
好 如果这个value of

13:27.320 --> 13:30.240
返回的什么呢 返回的还是对象

13:31.040 --> 13:35.400
那接下来他会调用什么呢 调用对象的这个自身的to stream方法

13:36.360 --> 13:41.560
to stream方法如果返回这个原始类型的值啊 什么叫原始类型的值 就是我们上面

13:42.160 --> 13:50.720
这些啊 这些简单类型 好 然后接下来的话 返回的是原始类型啊 就简单类型嘛 那就要对该值使用number函数

13:51.200 --> 13:57.960
因为我们知道就是原始类型 是不是都可以通过这个number类型来转换 对不对 刚才你看我们这边举了这么多

13:58.440 --> 14:06.640
原始类型的这个例子啊 原始类型是都可以通过这个number来转换的啊 所以他这边呢 首先是调value of

14:07.440 --> 14:15.560
看能不能得到原始类型 能得到原始类型ok 搞定啊 然后直接用number来转就可以了 如果不能啊 如果得到的还是对象

14:16.280 --> 14:18.760
我用什么呢 接下来我调用to stream方法

14:19.760 --> 14:29.040
to stream方法 大家看能不能得到啊 如果能得到ok 那搞定啊 使用这个number函数来进行转换啊 不再进行这个后续步骤

14:29.560 --> 14:34.720
那如果这一步得到的还是对象 那就干嘛呢 那就抱错

14:35.520 --> 14:38.400
啊 那就抱错 好 那接下我们这边 我们去提来看一下

14:39.920 --> 14:40.920
啊 把这边注释掉

14:42.520 --> 14:45.120
好 接下来我们来看这个 如果是对象

14:46.080 --> 14:46.640
就第二种

14:47.640 --> 14:48.560
对象的情况

14:50.440 --> 14:55.240
对象的情况啊 那接下来他这边分为三步 首先第一步

14:56.480 --> 14:59.480
第一步调用什么呢 调用这个value of

15:00.680 --> 15:01.360
调value of

15:05.120 --> 15:13.180
调value of 好 然后接下来第二步 第二步 第二步是调什么呢 调这个to stream

15:14.180 --> 15:16.820
对吧 好 然后这边如果还是

15:17.820 --> 15:20.100
这个得到的是对象 第三步

15:22.420 --> 15:26.180
啊 然后如果还是对象

15:27.060 --> 15:27.500
就抱错

15:29.380 --> 15:32.940
对不对 一共这么三步啊 首先是value of 啊 如果

15:34.140 --> 15:35.260
能得到

15:36.620 --> 15:38.700
得到这个简单值

15:39.940 --> 15:40.260
调用

15:41.580 --> 15:45.760
调用这个 number 对吧

15:47.040 --> 15:47.560
如果

15:49.520 --> 15:51.840
如果是对象

15:53.080 --> 15:58.280
进入什么呢 进入第二步 是不是这样子啊

15:59.080 --> 16:05.840
对不对 好 然后第二步是什么呢 第二步是调这个to stream方法啊 能得到简单值

16:06.960 --> 16:11.920
调用什么呢 调用这个number 因为简单值它是都可以通过number来转的

16:12.880 --> 16:14.320
啊 然后如果

16:14.880 --> 16:17.680
仍然是对象

16:18.400 --> 16:19.280
进入第三步

16:20.480 --> 16:21.680
那第三步其实就是什么呀

16:22.720 --> 16:25.520
就是抱错 对不对 第三步就是直接就抱错

16:26.360 --> 16:29.720
就这么三种情况 好 那接下来的话 我们这边我们来看一下

16:31.040 --> 16:36.640
首先的话这个value of 和这个to stream 这个的话是任何对象都有的

16:37.960 --> 16:43.200
啊 这个要说一下 value of 和这个to stream

16:44.600 --> 16:47.920
to stream 方法是任何

16:48.840 --> 16:49.760
这个对象

16:50.960 --> 16:52.000
或者这个值

16:52.920 --> 16:53.520
都有的

16:55.520 --> 16:55.920
因为

16:56.840 --> 16:58.080
这两个方法

16:59.880 --> 17:05.560
这两个方法是挂在哪里的呢 挂在这个object

17:06.240 --> 17:09.040
点这个portal type

17:09.640 --> 17:11.720
啊 就是这个object的原型对象上面的

17:13.640 --> 17:13.960
对不对

17:14.320 --> 17:17.640
所以都有啊 都有这个value of 就是得到一个这个

17:18.680 --> 17:20.720
值 value嘛 就得到它的值

17:20.960 --> 17:25.840
然后to stream的话就是得到它的这个制服创 我们这边可以取个例子

17:26.600 --> 17:30.720
比如我们这边挖一个obj 等于一个

17:32.240 --> 17:32.760
name

17:33.000 --> 17:34.280
然后比如说

17:35.040 --> 17:35.560
解极

17:35.820 --> 17:37.880
对吧 好 然后接下来的话 我们这边

17:39.160 --> 17:39.920
我们log一下

17:40.960 --> 17:44.000
log这个obj 点这个

17:44.520 --> 17:51.290
value of 和这个to stream

17:54.390 --> 17:56.190
好 然后这样我们这边我们来执行一下

17:59.030 --> 18:04.150
你看 如果是value 我就返回它的值 就返回它值本身 是不仅仅是一个对象

18:04.410 --> 18:06.710
如果是to stream to stream 是不是就转成这种形式了

18:07.730 --> 18:08.250
看了没有

18:08.750 --> 18:12.090
好 那接下来的话 我们这边我们来分析一下 来分析一下

18:12.350 --> 18:14.130
如果我针对

18:15.670 --> 18:18.490
如果我针对这个 就这个对象

18:18.990 --> 18:19.770
我调用

18:20.830 --> 18:22.110
调用这个lumber

18:22.630 --> 18:23.910
把这个obj

18:24.430 --> 18:28.270
传进去 让它的一个步骤是什么样子的 我们来分析一下

18:28.530 --> 18:30.310
首先第一步 调用什么

18:30.570 --> 18:32.350
是不是调用这个value of

18:33.130 --> 18:34.670
对不对 然后得到什么

18:35.430 --> 18:36.450
得到

18:40.570 --> 18:42.370
得到谁 是不是得到他呀

18:43.390 --> 18:46.730
得到他 然后发现仍然是一个什么 是不是仍然是一个对象

18:47.230 --> 18:49.550
然后接下来的话进入什么呢 进入第二步

18:50.030 --> 18:52.830
第二步 调用什么 是不是调用to stream

18:54.110 --> 18:55.650
对不对 调用to stream

18:55.910 --> 18:59.730
调用to stream 就得到什么呀 是不是得到这个 是不是这个是个支付串

18:59.990 --> 19:01.790
你看颜色都不一样 是不是是白色

19:02.050 --> 19:03.330
对不对 这个就是支付串

19:05.110 --> 19:06.910
ok 那得到这个

19:07.170 --> 19:08.710
这个简单指名

19:08.970 --> 19:09.730
是不是得到了

19:09.990 --> 19:12.530
得到了之后好 那接下来我就干嘛呀

19:12.790 --> 19:16.890
接下来的话 我这边相当于是不是就是直接lumber

19:19.560 --> 19:20.060
lumber

19:20.280 --> 19:22.840
然后接下来对这个支付串进行转换

19:23.600 --> 19:26.400
对不对 相当于就是对这个支付串

19:28.200 --> 19:31.520
进行转换 那对这个支付串进行转换 那最终就得到什么

19:32.560 --> 19:34.340
我这边右边写不到了 我就说

19:34.600 --> 19:36.400
就写到下面 最终

19:39.050 --> 19:41.610
最终得到什么

19:43.870 --> 19:45.450
对不对 得到n a n

19:45.710 --> 19:49.290
我们来验证一下 是不是 我们这边就简单运行一下就可以了

19:50.070 --> 19:50.570
看到没有

19:51.030 --> 19:52.070
是不是n a n

19:52.310 --> 19:54.870
你这边的话 你可以把这个视频

19:55.130 --> 19:56.410
你可以把它暂停一下

19:57.190 --> 20:00.510
把暂停一下 暂停一下之后 然后你把这个好好理解

20:00.770 --> 20:02.050
就是自己想一想

20:02.550 --> 20:04.870
理解一下 理解一下这个步骤

20:07.150 --> 20:09.470
好 接下来回到我们这边

20:10.750 --> 20:13.570
这边的话 他举了些例子 这些你就都明白了

20:13.830 --> 20:15.350
对吧 为什么这个是n a n

20:15.610 --> 20:17.390
然后接下这个 这个为什么是n a n

20:17.850 --> 20:21.950
然后加这个 这个数组如果是这个单个数值的

20:22.210 --> 20:26.050
如果你是包含的是单个数值的 他转出来的话是这个

20:26.310 --> 20:29.370
就是是这个5 其他的话都是这个n a n

20:29.630 --> 20:33.990
那我们这边的话 我们就可以干嘛呀 我们是不是可以把他的这个值打印出来看一下呀

20:34.750 --> 20:35.770
比如说我们这边

20:36.810 --> 20:37.830
把这注射了

20:40.350 --> 20:40.850
注射了

20:41.110 --> 20:44.190
好 然后加我们这边 哇一个这个啊

20:44.710 --> 20:47.770
等于一个我们先来看不是单参的吗 有123

20:48.170 --> 20:49.510
好 那就让我们这边log

20:50.290 --> 20:51.810
log这个

20:53.090 --> 20:55.650
a r 首先是什么 是个value of

20:56.930 --> 20:59.250
对不对 先掉这个 然后加我们再这个to stream

21:00.010 --> 21:01.810
to stream

21:02.050 --> 21:03.850
好 然后接下我们这边我们来看一下

21:05.650 --> 21:09.730
好 然后你这边的话 首先value of得到的 是不是仍然是个对象

21:10.490 --> 21:12.290
仍然是个对象 是不是要进入第二步

21:12.550 --> 21:14.350
第二步 然后得到的是这个制服圈

21:14.850 --> 21:17.530
这个制服圈里面有什么 是不是有这个斗号呀

21:18.490 --> 21:24.250
斗号是不是不属于这个数字 对不对 说他最终转出来是什么呢 最终转出来是n a n

21:24.530 --> 21:25.410
啊 这边log

21:27.480 --> 21:28.280
log这个

21:28.520 --> 21:29.280
number

21:30.040 --> 21:31.080
然后 哎呀啊

21:31.320 --> 21:34.920
说他最终转出来是n a n 那为什么单参又可以呢

21:35.160 --> 21:38.760
啊 那我们这边我们来看一下 单参其实你猜都猜到了 他没有什么

21:39.000 --> 21:41.040
是没有后面的东西 说没有斗号呀

21:41.800 --> 21:43.080
对不对 他没有斗号

21:43.840 --> 21:45.400
啊 这边还是写出来给大家看一下吗

21:47.200 --> 21:47.960
要这边5

21:48.220 --> 21:48.720
啊

21:49.080 --> 21:51.120
我这边就不做转换了哈 我这边就直接

21:52.660 --> 21:55.740
把这个value of和2 stream 我打印出来给大家看一下

21:58.040 --> 21:58.800
哦 这边是2

22:02.220 --> 22:05.560
好 走 你看 单参的话他是不是后面没有那个斗号啊

22:06.320 --> 22:07.600
对不对 没有斗号

22:07.860 --> 22:09.660
说他转出来是什么 转出来就是啊

22:09.920 --> 22:10.940
是这个数字的

22:11.200 --> 22:12.220
就这么简单

22:14.260 --> 22:16.060
好 然后这里的话

22:16.560 --> 22:20.400
这里的话我们还需要干嘛呢 还需要这里我看一下啊

22:20.860 --> 22:22.400
这边其实还写了一些例子

22:23.160 --> 22:23.940
啊 就是这里

22:24.200 --> 22:26.760
就是关于这个value of和这个2 stream

22:27.260 --> 22:30.080
其实是什么呢 其实是可以自己定义的

22:31.100 --> 22:33.920
看到没有 其实你可以自己定义的 比如说你看我们这边

22:34.680 --> 22:35.720
我把这个例子写一下

22:37.790 --> 22:38.810
把这注写了

22:40.970 --> 22:41.730
就是关于

22:45.360 --> 22:47.400
关于这个value of

22:48.940 --> 22:49.440
和

22:49.960 --> 22:50.720
2 stream

22:52.520 --> 22:53.540
其实

22:54.260 --> 22:56.860
是可以自己

22:57.620 --> 22:58.140
定义的

22:58.660 --> 23:01.220
那比如说我们这边写个例子 我要转number

23:01.480 --> 23:03.520
我要转一个什么呢 我要转一个对象

23:04.040 --> 23:07.620
那对象里面有一个这个方法 叫做这个value of

23:09.160 --> 23:10.960
看到没有 大家这边 function

23:13.920 --> 23:15.460
大家这边就直接

23:15.720 --> 23:17.500
return什么呢 return这个2

23:18.780 --> 23:21.340
好 然后接下来的话我这边我打印一下

23:24.000 --> 23:24.760
打印一下

23:25.020 --> 23:27.320
好 这边的话就是一样的 首先的话你这边的话

23:27.780 --> 23:29.820
它会掉什么呢 这边你是一个对象 对吧

23:30.080 --> 23:31.620
对象的话我会先开始干嘛

23:31.880 --> 23:33.660
这不掉这个value of方法

23:33.920 --> 23:37.640
value of方法由于你这边重新定义了这个value of方法 返回什么

23:37.900 --> 23:38.800
返回这个2

23:39.060 --> 23:41.100
最终它转出来就是什么呢 就是2

23:41.860 --> 23:42.120
走

23:42.880 --> 23:43.400
看到没有

23:43.920 --> 23:44.680
是不是就是2

23:45.200 --> 23:45.700
对不对

23:45.960 --> 23:47.500
好 那接下来比如说我们这边再来

23:49.280 --> 23:49.800
复制一份

23:51.600 --> 23:54.660
比如说我这边定义的是什么呢 定义的是这个2 stream

23:56.460 --> 23:56.960
2 stream

23:57.180 --> 23:59.980
好 2 stream 然后这样我这边的话我返回一个5

24:00.240 --> 24:02.420
那它首先的话掉什么呢 掉value of

24:02.680 --> 24:04.340
value of的话它是不是会得到

24:04.600 --> 24:05.360
就是这个对象

24:06.380 --> 24:06.900
对不对

24:07.160 --> 24:08.640
就会得到这个对象 比如说

24:08.900 --> 24:10.480
这样子我把这个对象重新想

24:10.740 --> 24:12.780
obj 等于一个这个对象

24:15.430 --> 24:16.210
等于一个这个对象

24:16.470 --> 24:17.990
好 然后接下来这边的话 我log

24:19.030 --> 24:20.550
logobj

24:20.810 --> 24:21.590
点这个

24:21.850 --> 24:22.870
value of

24:24.150 --> 24:25.170
你这边你看一下

24:29.930 --> 24:31.470
看到没有 它首先是不是得到这个对象

24:31.690 --> 24:34.490
得到这个对象之后 然后接下来它发现还是个对象

24:34.750 --> 24:36.490
然后它掉什么呢 掉这个2 stream

24:36.750 --> 24:38.090
但是2 stream 你干嘛了

24:38.330 --> 24:40.650
你是不是自己定义了 是不是返回这个5啊

24:40.890 --> 24:42.690
说它最终得到的值就是什么呢

24:43.210 --> 24:44.730
最终得到的值就是5

24:45.490 --> 24:46.010
看到没有

24:46.270 --> 24:47.290
最终得到的值就是5

24:47.550 --> 24:50.110
然后你也可以就是两个一起定义

24:51.130 --> 24:51.890
比如这边

24:53.170 --> 24:57.670
两个一起定义其实就是看它究竟是先调用value of还是这个

24:57.930 --> 24:59.070
2 stream 比如我这边

24:59.330 --> 25:00.870
定义2 stream 返回5

25:01.070 --> 25:03.390
那接下来我再把这个value of 拿过来

25:05.170 --> 25:07.210
大家还有个value of 方法

25:13.560 --> 25:14.600
value of

25:15.880 --> 25:17.660
value of 返回什么 返回2

25:17.920 --> 25:19.440
那这个最终值得到多少

25:19.960 --> 25:22.520
你想一想 这个最终值得到多少

25:22.780 --> 25:23.800
是不是得到是2

25:24.060 --> 25:26.880
为什么 因为value of 这边是不是就已经得到值了

25:27.400 --> 25:32.760
对不对 已经得到值了 所以这个最终的话得到的是2

25:33.540 --> 25:34.040
看到没有

25:34.500 --> 25:36.820
这个是关于这个number 这个转换

25:37.580 --> 25:39.620
这个知识点 一定要注意

25:40.900 --> 25:42.700
好 接下来的话下一个

25:42.960 --> 25:45.000
下一个的是这个stream

25:45.260 --> 25:46.540
那stream的话也是

25:46.800 --> 25:49.340
它是强转 强转的话这边也是分两类

25:49.600 --> 25:51.400
一个是基本数据类型

25:51.660 --> 25:52.940
一个是对下

25:53.200 --> 25:54.980
那我们首先来看基本数据类型

25:55.240 --> 25:58.580
基本数据类型的话就很简单 我这边就不写了

25:59.080 --> 26:02.660
这边的话就是你如果是数值就转成数值的制服串

26:02.920 --> 26:03.940
制服串不变

26:04.060 --> 26:05.060
接下来这边

26:05.320 --> 26:06.340
这个布尔茲

26:06.600 --> 26:08.900
就转成这种制服串的q

26:09.160 --> 26:11.460
force就转成制服串的force

26:11.980 --> 26:14.800
undefy就转成这个制服串的undefy

26:15.060 --> 26:16.060
然后下这个now

26:16.320 --> 26:18.640
空就转成制服串的这个空

26:19.660 --> 26:20.160
看到没有

26:20.420 --> 26:21.440
这个就不多说了

26:21.700 --> 26:22.980
我们主要来看一下什么呢

26:23.240 --> 26:24.520
主要来看一下这个

26:24.780 --> 26:25.800
对象的这个转换

26:26.060 --> 26:27.080
回到我们这边

26:31.330 --> 26:32.350
这是第几个

26:34.570 --> 26:35.850
强制转换3-1

26:36.110 --> 26:37.110
那3-2

26:39.140 --> 26:40.420
3-2

26:40.940 --> 26:41.440
stream

26:42.220 --> 26:42.980
方法

26:43.240 --> 26:44.260
转换

26:44.520 --> 26:45.020
对象

26:45.800 --> 26:47.340
好 那我们这边让我们来看一下

26:48.880 --> 26:50.400
stream方法

26:50.920 --> 26:54.240
背后的转换规则和lambar基本相同

26:54.500 --> 26:55.520
只不过什么呢

26:55.780 --> 26:58.600
换了这个value of 和 tostream的这个

26:59.120 --> 27:00.140
这个执行顺序

27:00.400 --> 27:02.700
也就是它是先调用这个 tostream

27:03.980 --> 27:06.540
先调用tostream看能不能拿到这个基本

27:06.800 --> 27:08.080
就是原始类型的值

27:09.060 --> 27:12.380
如果能拿到 然后下直接调这个stream这个函数

27:13.140 --> 27:15.200
来进行转换 因为这前面已经说了

27:15.460 --> 27:19.040
任何这个原始类型的值是不是都可以转成制服串

27:19.300 --> 27:20.840
对不对 那如果不是

27:21.100 --> 27:24.420
不是的话 然后再调用什么呢 再调用这个value of

27:25.180 --> 27:26.220
再调用value of

27:26.460 --> 27:28.780
那你如果这个value of这边的话

27:29.020 --> 27:32.620
返回这个原始类型的值 那直接调这个stream函数

27:32.860 --> 27:33.900
如果还不是

27:34.660 --> 27:35.420
那就爆出

27:35.880 --> 27:38.440
好 那这样呢 我们这边可以来试验一下

27:39.980 --> 27:41.520
我们这边来写一下步骤

27:42.040 --> 27:42.680
首先

27:42.940 --> 27:45.880
第一步它是反折的 先调什么呢

27:46.120 --> 27:47.920
先调这个tostream

27:49.200 --> 27:50.720
先调tostream方法

27:50.980 --> 27:53.040
好 然后下如果能够

27:53.800 --> 27:56.360
拿到这个原始类型值

27:57.640 --> 27:58.920
原始类型值

27:59.440 --> 28:00.720
好 然后下这边

28:00.980 --> 28:03.280
就直接调什么 是不是调这个stream

28:04.040 --> 28:05.320
调stream方法

28:06.160 --> 28:07.920
对不对 好 如果不是

28:08.440 --> 28:11.520
如果不是的话 那就调什么呢 调这个value of

28:12.800 --> 28:13.820
value of方法

28:14.080 --> 28:18.440
看是否能拿到原始类型的值

28:18.940 --> 28:19.960
如果是

28:20.720 --> 28:21.500
那就干嘛

28:21.760 --> 28:24.560
是不是调这个stream方法

28:26.120 --> 28:29.180
对不对 好 那接下来如果还不是 那就干嘛呢

28:29.440 --> 28:30.400
就抱错

28:30.660 --> 28:34.070
抱错

28:34.330 --> 28:37.390
好 那接下来我们这边我们来看一个例子吧

28:38.030 --> 28:39.230
比如说我们这边

28:41.120 --> 28:42.860
挖一个这个

28:43.420 --> 28:44.660
obj

28:44.920 --> 28:47.620
等于一个什么呢 等于一个这个

28:47.880 --> 28:49.820
A对应的是一个E

28:50.860 --> 28:51.620
ok

28:51.880 --> 28:55.460
好 那接下来我们这边我们把它对应的两个都打印出来

28:55.720 --> 28:56.740
obj

28:57.260 --> 28:58.780
点这个

28:59.700 --> 29:01.340
什么 tostream

29:01.600 --> 29:02.380
tostream

29:02.880 --> 29:05.200
好 那obj点这个value of

29:06.480 --> 29:07.240
value of

29:07.700 --> 29:10.260
好 那接下来我们来看一下打印出来的字

29:11.300 --> 29:15.380
好 你看 这边的话 它这边的话这个调tostream的时候

29:15.900 --> 29:17.420
这里就已经是什么

29:17.940 --> 29:19.740
已经是不拿到这个支付创了

29:20.260 --> 29:24.100
对不对 然后value of拿到的是这个字 说最终你这边

29:25.100 --> 29:25.620
log

29:26.140 --> 29:27.420
这边stream

29:27.940 --> 29:29.980
然后这个obj的话

29:30.240 --> 29:32.020
他第一步是不是就是调这个tostream

29:32.280 --> 29:35.340
对不对 说最终他取什么呢 取这个字

29:35.800 --> 29:38.880
所以他最终拿到的一定是这个字

29:39.140 --> 29:40.920
我们来看一下 走

29:41.440 --> 29:41.960
是不是

29:42.720 --> 29:43.220
看到没有

29:43.480 --> 29:44.760
就是这个字

29:45.280 --> 29:48.600
好 当然的话你这个的话也是可以自己定义的

29:49.360 --> 29:52.200
也是可以自己定义的 比如说我们这边我们举个例子

29:52.960 --> 29:54.240
比如我们这边的话有一个

29:55.000 --> 29:57.040
挖一个这个obj

29:57.560 --> 29:58.600
等于一个

29:59.600 --> 30:00.380
比较A

30:00.640 --> 30:01.660
然后是一个E

30:02.000 --> 30:05.440
然后这样我给他定一个什么呢 我给他定一个tostream方法

30:07.600 --> 30:10.520
tostream方法 tostream方法 然后这样我给他反回一个

30:10.920 --> 30:13.240
this is a

30:14.000 --> 30:14.520
test

30:15.540 --> 30:18.360
看到没有 我反回的是一个什么 所以反回一个这个支付创

30:18.620 --> 30:20.400
所以接下来你这边的话你log

30:21.160 --> 30:22.960
log 然后现在你用这个stream

30:24.000 --> 30:25.520
你去把这个obj

30:25.780 --> 30:29.120
转成支付创 那最终拿到的是什么呢 拿到的是这个

30:29.360 --> 30:30.640
因为他先调tostream

30:31.140 --> 30:34.940
先调tostream 你的这个tostream是不是把他默认的tostream是不覆盖了

30:35.460 --> 30:37.780
对不对 说他这边一定打印出来的是

30:38.020 --> 30:39.820
this is a test

30:40.580 --> 30:41.100
看到没有

30:41.360 --> 30:43.500
那你如果你这边还反回一个对象

30:45.260 --> 30:49.020
还反回一个对象 包括你这边再来定义这个value of

30:50.260 --> 30:53.380
value of他这边好像本来就是反回一个对象是吧

30:53.640 --> 30:55.180
好 那我们这边我们来看一下

30:56.700 --> 30:57.460
是抱错

30:58.440 --> 31:02.280
是抱错 为什么 因为他这边你这个tostream你反回了一个对象

31:02.540 --> 31:06.120
然后他就干嘛 他就进入第二步 第二步是不是调用这个value of

31:06.640 --> 31:10.720
value of我们刚才看到了value of就是打印出来的是这个对象

31:10.980 --> 31:11.760
整个这个对象

31:12.000 --> 31:14.320
对不对 所以他这边就干嘛了 就抱错

31:15.080 --> 31:18.400
就抱错 其实包括刚才那边 就刚才上面那个也是

31:19.440 --> 31:23.520
刚才上面我们那个lumber也是 比如说我们这边

31:23.780 --> 31:24.280
复制一份

31:26.620 --> 31:27.140
我们这边

31:29.770 --> 31:32.450
我们这边一直反回什么呢 一直反回对象

31:32.710 --> 31:37.610
这个他是先调value value of 然后反回对象 然后叫这个我们也反回对象

31:37.950 --> 31:40.670
那现在你这边来看一下 他一定是抱错

31:41.790 --> 31:42.290
走

31:42.810 --> 31:43.330
看到没有

31:43.830 --> 31:47.510
是抱错 对不对 他这边就是type arrow

31:47.770 --> 31:51.770
内形错误 无法进行这个转换 把它转成这个

31:52.030 --> 31:53.290
简单数据类型

31:55.090 --> 31:57.650
这是关于这个stream

32:00.870 --> 32:03.910
stream 两种情况啊 一个是转这个

32:04.310 --> 32:07.270
简单的这个数据类型 一个是转这个对象

32:07.530 --> 32:11.630
他分那么几步 把这个步骤 自己再看一看

32:13.110 --> 32:14.550
好 然后下一个

32:14.810 --> 32:16.990
下一个是这个布尔

32:17.250 --> 32:21.110
布尔相对来讲的话就比较简单了 他就不用分了

32:21.350 --> 32:25.190
不用分两种情况 刚才这个lumber和stream是不要分两种情况

32:25.450 --> 32:28.010
对不对 要分你是简单数据类型

32:28.270 --> 32:29.810
还是这个复杂数据类型

32:30.170 --> 32:32.330
布尔就不用 布尔的话就这些

32:33.350 --> 32:37.450
这五个他会转成force 其他的全部转成去

32:37.950 --> 32:38.710
就这么简单

32:39.230 --> 32:43.590
哪怕你是对象 我就给你转成去 哪怕你是空对象

32:44.110 --> 32:46.910
看到没有 这个我就不写了 这边你看这边

32:47.170 --> 32:49.730
这个布尔 我传个空对象 是不是也是去啊

32:50.250 --> 32:53.310
大家这边布尔 大家这边传个空数组 是不是也是去啊

32:53.570 --> 32:55.370
除了什么呢 除了这几个

32:56.130 --> 32:59.210
就是undefine,空,然后0

32:59.470 --> 33:01.510
然后NAN 空制幅串

33:01.770 --> 33:04.070
但空制幅串就包含那个内几种

33:04.330 --> 33:05.870
就这边

33:06.890 --> 33:07.910
还是写一个吧

33:08.430 --> 33:10.210
这边3-3

33:10.730 --> 33:11.750
这个布林

33:13.290 --> 33:15.850
布林 就空制幅串就包含这几种

33:17.650 --> 33:18.410
布林

33:19.430 --> 33:21.490
就包含这几种 这种制幅串

33:21.990 --> 33:22.750
然后

33:23.010 --> 33:24.050
这种制幅串

33:24.270 --> 33:25.530
还有 是不是还有

33:25.790 --> 33:27.070
还有这种制幅串

33:27.590 --> 33:28.350
就都是什么

33:28.610 --> 33:29.630
都是force

33:30.910 --> 33:31.430
看到没有

33:31.690 --> 33:32.450
就都是force

33:34.510 --> 33:37.310
这是关于这个布尔 布尔没什么好说的

33:38.590 --> 33:41.670
好 这个就是强制转换 我们就说完了

33:41.930 --> 33:45.250
强制转换说完了 然后接下来我们来说这个自动转换

33:46.270 --> 33:48.570
有些时候我们在做运算的时候

33:48.830 --> 33:53.950
不同的数据类型之间进行运算 他就会有一个这个自动转换的这个过程

33:54.050 --> 33:55.010
我们这边写一下

33:58.310 --> 33:59.590
刚才是强制转换

33:59.850 --> 34:00.870
上面

34:03.170 --> 34:05.990
上面介绍的设

34:06.490 --> 34:07.530
强制

34:08.550 --> 34:09.310
转换

34:09.570 --> 34:10.850
也就是

34:11.630 --> 34:12.390
我们

34:12.650 --> 34:14.430
开发人员

34:14.690 --> 34:16.990
手动进行

34:17.510 --> 34:18.010
转换

34:18.270 --> 34:18.790
对吧

34:19.050 --> 34:21.090
好 接下来的

34:21.350 --> 34:23.910
接下来要介绍的设

34:24.170 --> 34:25.190
自动

34:25.690 --> 34:26.210
转换

34:27.490 --> 34:30.770
也就是说程序内部

34:31.070 --> 34:32.350
自动发生的

34:32.610 --> 34:35.430
对不对? 就比如说我们刚才那个

34:35.690 --> 34:36.710
刚才那个

34:36.970 --> 34:38.510
制服创的4

34:38.770 --> 34:40.550
减去一个制服创的3

34:40.810 --> 34:42.850
我是不是没有对这两边的这个操作说

34:43.610 --> 34:45.410
进行手动的Lumber, number

34:45.650 --> 34:46.450
没有吧

34:46.690 --> 34:47.970
它程序内部自动会

34:48.490 --> 34:50.030
进行一个转换

34:50.270 --> 34:52.590
其实也是调到Lumber那个函数

34:53.090 --> 34:55.130
那我们这边我们来看一下

34:55.130 --> 34:57.690
这个

34:58.190 --> 35:05.370
首先这边第一种情况不同类型的数据互相转换,比如这个是Lumber类型,这个是制服串类型

35:05.630 --> 35:07.670
最终它会变成一个制服串类型

35:08.190 --> 35:13.550
第二种是就是非布尔类型数据,就这边我传的是个制服串

35:14.330 --> 35:16.890
最终它会转成什么呢,会转成这个q

35:17.410 --> 35:22.010
然后第三种情况是就是使用这个一元运算幅,比如这种加

35:22.270 --> 35:23.030
加一个对象

35:23.230 --> 35:27.370
它最终会转成一个NAN,减一个对象也是

35:30.190 --> 35:32.750
然后我们这边来看一下,这边自动转换

35:33.530 --> 35:40.430
也分三种情况,自动转成布尔籽,自动转成制服串,自动转成数值

35:40.690 --> 35:41.710
好,让我们一个一个来看

35:42.230 --> 35:48.890
那什么时候它会自动转成布尔籽呢,那就是在JS预期为布尔籽的地方

35:49.610 --> 35:53.710
什么叫做预期为布尔籽的地方,那很简单,比如说义父语句

35:53.970 --> 35:56.770
义父语句里面,它是不是就希望你义父,就这边

35:59.050 --> 36:01.350
就你这边义父,它是不是就是

36:02.630 --> 36:05.970
希望你这边是不是给我提供一个布尔籽啊

36:06.470 --> 36:10.050
对不对,那我如果不给你提供布尔籽,我给你提供一个比如说APC

36:10.310 --> 36:11.590
那我这边是不是一个

36:12.350 --> 36:12.870
制服串

36:13.390 --> 36:16.450
对不对,那接下来的话,它就会把这个制服串

36:16.870 --> 36:20.750
它在内部,自动的给你转换成布尔类型

36:21.270 --> 36:22.550
那它怎么转换的呢

36:23.050 --> 36:26.130
把它怎么转换的呢,它其实也是调用的,你看这边

36:26.390 --> 36:28.190
它内部也是调用的这个

36:28.690 --> 36:30.750
布尔函数,就这个布林函数

36:31.510 --> 36:34.470
看了没有,那既然它也是调用了布林函数,那就是

36:34.730 --> 36:35.610
这几个值

36:36.370 --> 36:37.910
是不是就是会转成force啊

36:38.170 --> 36:41.230
那这些值以外的是不是就转成这个区啊

36:41.750 --> 36:43.270
对不对,比如说我们这边的话

36:44.310 --> 36:45.830
APC,我们这边log

36:46.670 --> 36:47.810
比如说Hello

36:48.310 --> 36:51.270
那你这个的话,它掉这个布林,它就等价于什么吗

36:52.030 --> 36:52.550
这里

36:53.830 --> 36:55.870
这里等价于

36:58.710 --> 36:59.750
就等价于这个

37:03.160 --> 37:03.920
就等价于这个台码

37:04.440 --> 37:08.800
对不对,那最终它得到就是什么呢,得到就是q,打印出什么,是吧Hello

37:09.060 --> 37:10.600
但你如果是这个空置串

37:11.620 --> 37:13.660
它就是force啊

37:14.420 --> 37:16.220
对不对,这个是这个

37:16.480 --> 37:19.040
转布,这个自动转成布尔

37:19.800 --> 37:20.840
这个没什么好说的

37:21.640 --> 37:23.440
好,然后它有个快速写法啊

37:23.700 --> 37:26.500
注意,就是任何值,比如说我要把它转成布尔值

37:26.760 --> 37:29.080
有个快速写法就是什么呢,直接加两个感叹号

37:30.100 --> 37:32.140
两个感叹号,就一个感叹号是不是取反

37:32.400 --> 37:33.420
那既然这个

37:33.680 --> 37:38.540
比如说我本来是真,然后你取一个这个感叹号,它会做一个什么呢,它会做一个这个

37:39.300 --> 37:39.820
转换

37:40.080 --> 37:41.360
就是布尔转换

37:41.860 --> 37:46.480
就是自动的啊,自动的,做一个这个布尔类型的这个转换,但是呢它是取反

37:46.740 --> 37:50.060
反着的,所以你再加一个感叹号,是不是又取回来了

37:50.560 --> 37:51.080
对不对

37:51.180 --> 37:52.460
比如说我们这边取个例子

37:53.740 --> 37:54.500
比如这边

37:54.760 --> 37:55.540
快速

37:55.800 --> 37:58.100
转换为布尔转

38:00.240 --> 38:01.260
比如说我们这边

38:01.780 --> 38:02.540
log

38:03.580 --> 38:05.360
比如说我们这边的话就写个什么呢

38:06.140 --> 38:07.420
比如说abc

38:08.700 --> 38:10.480
那它就快速给我转成什么

38:10.740 --> 38:11.260
是不是q啊

38:11.520 --> 38:12.280
这边一个

38:12.780 --> 38:15.860
一个的话你这边取反,取反的话它转成的是什么

38:16.120 --> 38:16.880
是不是force啊

38:17.140 --> 38:18.160
说这边要写两个

38:18.680 --> 38:21.240
写两个,它这边就快速的转成了

38:21.740 --> 38:22.260
q

38:22.260 --> 38:28.400
好,然后下一个,下一个的话是转这个制服串

38:28.920 --> 38:30.960
自动转制服串,那这个也很简单

38:31.220 --> 38:34.540
就你直接就是其他数据类型,你和这个制服串

38:34.800 --> 38:37.880
一拼接,它就会自动转成这个制服串

38:38.140 --> 38:39.680
随便你什么,比如说你这边

38:40.180 --> 38:41.720
制服串5和这个1

38:41.980 --> 38:44.520
这个是数字类型吗,这个是布尔类型

38:44.780 --> 38:45.560
这个是对象

38:46.060 --> 38:47.860
那接下来这个是这个

38:48.120 --> 38:50.680
这个也是对象,这个是韩束对吧,andfi

38:51.180 --> 38:52.220
然后接下来这个空

38:52.720 --> 38:55.540
好,然后这边比较有意思的就是5加一个对象

38:55.800 --> 38:56.820
得到的是这个

38:57.580 --> 38:58.620
我们这边我们来写一下嘛

39:00.940 --> 39:01.460
就这边

39:02.740 --> 39:03.240
log

39:05.040 --> 39:07.340
5,不不,制服串的5

39:07.860 --> 39:09.640
加上一个这个空对象

39:09.900 --> 39:11.180
它得到的是什么呢

39:11.440 --> 39:12.460
得到的是这个

39:14.260 --> 39:15.020
得到的是这个

39:16.300 --> 39:18.860
好,那我们来思考一下为什么得到的是这个

39:19.120 --> 39:20.140
好,首先这边

39:20.400 --> 39:21.680
是不是在做这个制服串的

39:21.940 --> 39:22.440
加拔

39:23.220 --> 39:23.720
这里

39:24.800 --> 39:26.080
在做

39:26.580 --> 39:28.120
制服串的

39:28.640 --> 39:29.140
加拔

39:30.440 --> 39:31.200
那就

39:31.960 --> 39:33.240
变成了

39:33.760 --> 39:34.260
什么

39:34.520 --> 39:35.560
说变成了

39:36.320 --> 39:37.080
我挑个什么

39:37.340 --> 39:38.100
就变成了

39:38.360 --> 39:40.420
制服串的

39:41.180 --> 39:41.700
拼接

39:42.200 --> 39:42.720
对不对

39:42.980 --> 39:43.740
那左边

39:44.500 --> 39:45.020
是

39:45.280 --> 39:46.040
制服串

39:46.300 --> 39:47.060
ok

39:47.580 --> 39:48.860
对吧,那右边

39:49.620 --> 39:51.420
右边不是

39:51.940 --> 39:52.700
制服串

39:52.900 --> 39:55.040
那么就需要

39:55.460 --> 39:57.780
调用什么呀,是不是调用这个方法

39:58.040 --> 39:59.060
实追方法

39:59.560 --> 40:01.100
转为制服串

40:03.130 --> 40:04.150
转为

40:04.410 --> 40:04.910
制

40:05.170 --> 40:05.690
服

40:05.950 --> 40:06.450
串

40:09.420 --> 40:10.700
那就回到哪里的知识了

40:11.460 --> 40:13.160
回到我们这边强

40:13.420 --> 40:14.800
这个强制转换

40:15.060 --> 40:16.340
回到这边的知识

40:16.600 --> 40:18.380
你看这边我如果

40:18.640 --> 40:20.180
传一个对象过去

40:20.440 --> 40:21.980
交给这个实追这个方法

40:22.240 --> 40:23.000
得到的是什么

40:23.260 --> 40:24.280
得到的是这个

40:24.740 --> 40:26.280
所以最终的话你

40:26.540 --> 40:28.580
这边为什么五加上一个这个对象

40:28.840 --> 40:30.040
拼接出来是这个五

40:30.300 --> 40:31.660
obj,obj

40:31.920 --> 40:32.940
原因就在这里

40:33.200 --> 40:35.020
他这边相当于是对这个对象

40:35.280 --> 40:37.540
调用了什么呢,调用了strain这个

40:37.800 --> 40:38.320
函数

40:39.080 --> 40:42.160
就是执行了这个strain这个函数

40:42.420 --> 40:44.460
这个的话就是我们刚才这边

40:44.720 --> 40:45.980
是不是显示转换

40:46.240 --> 40:47.020
对不对

40:47.280 --> 40:49.020
你如果参数是一个对象的话

40:49.280 --> 40:51.620
他这边是先干嘛呢,先调这个txtrain

40:51.620 --> 40:54.180
调这个txtrain对象就转成这个样子了

40:54.440 --> 40:56.480
转成这个样子了,然后接下来

40:56.740 --> 40:57.760
他已经是这个

40:58.020 --> 40:59.040
制服串形式了

40:59.300 --> 41:02.880
接下来调这个strain方法,就会返回他的制服串形式

41:04.420 --> 41:05.180
然后

41:05.960 --> 41:08.670
转为制服串

41:09.690 --> 41:10.470
所以

41:12.250 --> 41:13.030
所以

41:13.290 --> 41:14.050
这个

41:14.810 --> 41:15.330
就

41:15.590 --> 41:16.610
转为了

41:16.870 --> 41:18.390
转为了他

41:19.930 --> 41:21.210
转为了他

41:21.930 --> 41:24.230
转为了他,对不对

41:24.490 --> 41:25.510
然后最后

41:26.030 --> 41:27.050
两个

41:27.310 --> 41:28.590
制服串

41:28.850 --> 41:30.130
是拼接

41:30.890 --> 41:31.390
起来

41:32.170 --> 41:32.690
对不对

41:32.950 --> 41:33.710
拼接起来

41:34.990 --> 41:38.830
这是关于这个自动转成制服串,主要是注意一下

41:39.090 --> 41:39.590
这个

41:39.850 --> 41:41.650
其他的话就没什么好说的

41:42.910 --> 41:48.290
然后这种自动转换很容易出错,确实是,比如你这边ob节点y是

41:48.550 --> 41:50.350
y是你不小心写成制服串了

41:50.550 --> 41:51.590
那你加一个20

41:51.850 --> 41:54.650
你本来期望是得到120,但是他得到的是什么

41:54.910 --> 41:55.930
是10020

41:56.690 --> 41:57.210
对不对

41:57.470 --> 41:58.490
很容易出错

41:59.770 --> 42:00.530
好,最后

42:00.790 --> 42:04.130
最后一个就是什么了,最后一个就是转这个数值

42:04.890 --> 42:06.690
就是主要是在做这个

42:07.210 --> 42:08.730
加减运算的时候

42:08.990 --> 42:11.290
加减成熟这些运算的时候

42:11.550 --> 42:12.830
他就会把其他类型

42:13.330 --> 42:14.610
转成一个这个

42:15.130 --> 42:16.170
Lumber类型

42:16.410 --> 42:20.250
系统内部仍然是自动调用什么呢,调用这个Lumber函数

42:20.810 --> 42:24.130
所以为什么我们先讲这个强制转换

42:24.390 --> 42:25.410
然后再讲这个

42:25.670 --> 42:26.950
自动转换

42:27.210 --> 42:29.530
就是因为你自动转换其实内部也是调的

42:29.790 --> 42:31.310
强制转换的,是不是这些方法

42:32.090 --> 42:32.590
对不对

42:32.850 --> 42:34.130
好,那我们这边来看

42:34.390 --> 42:36.950
这边5,5的话是不是就是强行调Lumber

42:37.450 --> 42:41.810
对不对,调这个Lumber方法,转成数字的5,这个转成数字的2

42:42.070 --> 42:43.090
然后接下来这边

42:43.850 --> 42:44.370
运算

42:44.630 --> 42:45.130
有这个q

42:45.390 --> 42:48.470
q的话,然后接下来调用这个数字

42:48.930 --> 42:53.290
不配,调用这个Lumber,Lumber函数,是不是转成这个1

42:53.790 --> 42:54.310
对不对

42:54.570 --> 42:55.850
这个就没什么好说的

42:56.870 --> 42:58.150
好,这个我们来看一下这个

42:59.430 --> 43:00.450
这个是怎么回事

43:01.470 --> 43:02.250
这个是怎么回事

43:02.510 --> 43:04.550
这个的话你这边首先是不是5

43:05.070 --> 43:06.350
对不对,大家空数组

43:07.110 --> 43:07.870
这边是个数组

43:08.130 --> 43:10.430
数组的话调用这个空数组

43:10.950 --> 43:12.870
空数组很明显你可以看出这边它

43:13.250 --> 43:14.270
转换成了什么

43:14.790 --> 43:16.330
转换成了0,我们把这个看一下

43:17.050 --> 43:18.070
好,我们来到这边

43:18.330 --> 43:20.890
我们把这个打印一下

43:21.150 --> 43:24.730
制服串的5,然后乘以一个这个空数组

43:24.990 --> 43:26.770
我们这边可以运行一下

43:27.030 --> 43:27.810
保存

43:28.570 --> 43:29.330
运行

43:29.590 --> 43:31.390
好,可以看到这边得出的是多少

43:31.650 --> 43:32.650
是不是得出的是0

43:33.390 --> 43:35.730
对吧,那它这个的话为什么是0呢

43:35.990 --> 43:37.530
那首先让我们这边来分析

43:37.790 --> 43:39.830
首先你这边的话是做惩罚

43:40.090 --> 43:40.610
我们这边

43:41.110 --> 43:41.630
首先

43:42.910 --> 43:44.430
首先这里

43:45.430 --> 43:50.010
是进行惩罚操作

43:50.270 --> 43:53.850
对吧,那作为你做这个惩罚操作的话

43:54.110 --> 43:54.750
所以

43:55.510 --> 43:56.670
两边

43:57.950 --> 44:01.390
就都要转换为什么呀

44:01.650 --> 44:03.070
就Lumber了一些

44:04.350 --> 44:04.850
对不对

44:05.110 --> 44:07.170
好,那接下来左边和右边我们

44:07.670 --> 44:09.110
就一个一个来看

44:09.350 --> 44:11.010
那首先的话是左边

44:11.510 --> 44:12.790
左边的话它是一个什么

44:13.050 --> 44:14.190
是不是一个制服串的5

44:14.590 --> 44:18.070
制服串的5,然后接下来它这边要调用这个Lumber函数

44:18.330 --> 44:19.750
然后接下来这边这个5

44:20.010 --> 44:21.810
那它最终转出来就是多少

44:23.090 --> 44:24.870
最终转出来是不是就是应该是5

44:25.650 --> 44:26.150
对吧

44:26.410 --> 44:28.210
好,那接下来右边

44:29.230 --> 44:29.990
右边

44:31.550 --> 44:32.050
右边

44:32.310 --> 44:35.370
右边的话我们很明显的看到就是这边的话

44:35.630 --> 44:36.910
这个数组

44:37.170 --> 44:38.190
就这个数组

44:39.470 --> 44:40.230
最终

44:43.030 --> 44:44.450
最终

44:44.890 --> 44:47.890
转换为了多少,是转换成0

44:48.490 --> 44:48.990
对不对

44:49.250 --> 44:50.450
它怎么转换成0的呢

44:50.690 --> 44:52.590
好,我们来看一下这边这个Lumber

44:52.850 --> 44:54.390
我们回到刚才那边吧

44:54.890 --> 44:56.690
就是这个转Lumber那里

44:57.970 --> 44:58.470
这边

44:59.090 --> 45:00.010
Lumber的话

45:00.490 --> 45:01.890
你如果是原始值

45:02.130 --> 45:05.390
原始值的话,那我这边就给你转成对应的Lumber类型

45:05.650 --> 45:06.290
都可以转

45:06.670 --> 45:07.190
对不对

45:07.450 --> 45:08.990
你如果不是原始值

45:09.250 --> 45:10.390
那比如说我们现在是数组

45:10.650 --> 45:12.050
数组的话它是属于什么

45:12.310 --> 45:13.490
是不是它是属于对下

45:14.650 --> 45:15.090
对吧

45:15.330 --> 45:16.810
对象的话它第一步调什么

45:17.050 --> 45:19.010
第一步是不是调ViewOff

45:19.770 --> 45:21.810
看它是否能够得到原始值

45:22.050 --> 45:23.370
如果能够得到原始值

45:23.610 --> 45:24.650
然后接下来的话

45:25.170 --> 45:26.610
再调这个Lumber函数

45:26.850 --> 45:28.210
好,那我们这边我们来看一下

45:29.250 --> 45:32.570
我们来看一下这个空数组它的ViewOff是什么

45:37.020 --> 45:38.620
console.nog

45:38.860 --> 45:39.860
这边的话

45:40.340 --> 45:42.660
它的点ViewOff

45:46.030 --> 45:47.430
OK,保存

45:48.150 --> 45:48.510
走

45:48.990 --> 45:52.190
你可以看到这边的话它的ViewOff还是什么

45:52.590 --> 45:53.750
是不是还是一个数组

45:54.390 --> 45:54.870
对不对

45:55.110 --> 45:57.190
它拿到的还是一个数组

45:57.710 --> 46:07.350
就是空数组的ViewOff

46:08.270 --> 46:13.750
拿到的仍然是这个空数组

46:13.990 --> 46:18.870
然后仍然是一个对象

46:19.390 --> 46:19.870
对吧

46:19.990 --> 46:20.990
仍然是一个对象

46:20.990 --> 46:22.110
然后接下来就要干嘛

46:22.350 --> 46:27.510
接下来就要进行第二步

46:28.910 --> 46:29.790
第二步是干嘛

46:30.150 --> 46:32.350
是不是调用哪个方法

46:32.870 --> 46:33.550
你看这里

46:34.150 --> 46:35.710
调用是不是toStream

46:36.390 --> 46:36.870
对吧

46:37.110 --> 46:40.790
所以接下来的话就调用toStream

46:42.670 --> 46:43.950
toStream方法

46:45.750 --> 46:46.190
OK

46:46.710 --> 46:48.750
好,然后接下来我们这边我们来看一下

46:49.030 --> 46:50.230
我这个开的智能提示

46:50.230 --> 46:52.550
他这个老师会谈这个智能提示

46:53.550 --> 46:54.710
好,这边的log

46:55.430 --> 46:59.310
他然后点toStream

47:00.630 --> 47:01.070
OK

47:01.590 --> 47:03.230
好,然后接下来我们这边保存

47:03.430 --> 47:03.830
保存了

47:03.830 --> 47:05.070
然后接下来我们这边我们来看一下

47:05.070 --> 47:05.470
走

47:05.870 --> 47:06.190
你看

47:06.550 --> 47:07.670
它得到的是一个什么

47:08.270 --> 47:09.870
你这边它虽然没打印出来

47:09.870 --> 47:10.990
虽然没打印出来

47:10.990 --> 47:12.190
但是你这边你可以看到

47:12.390 --> 47:13.430
它得到的是一个什么

47:13.830 --> 47:15.990
是不是得到的是一个空制浮串

47:16.990 --> 47:17.390
对不对

47:17.870 --> 47:24.190
它得到的是一个空制浮串

47:24.710 --> 47:26.430
好,那得到的空制浮串的话

47:26.430 --> 47:27.270
那现在的话

47:27.590 --> 47:29.310
这个空制浮串是不是原始值了

47:30.390 --> 47:31.990
空制浮串是不是就是原始值了

47:32.670 --> 47:32.870
对吧

47:32.870 --> 47:34.150
空制浮串是原始值

47:34.150 --> 47:35.230
然后接下来的话

47:35.830 --> 47:36.870
空制浮串

47:38.790 --> 47:42.270
空制浮串是原始值

47:44.150 --> 47:46.230
因此可以干嘛呀

47:46.270 --> 47:52.110
可以使用这个Lumber转为数字

47:52.630 --> 47:54.950
那你回头让你看一下这边空制浮串

47:55.710 --> 47:57.230
转数字在这里

47:57.750 --> 47:59.790
空制浮串转数字是不是转成0

48:00.550 --> 48:01.070
对不对

48:01.590 --> 48:02.630
空制浮串

48:04.670 --> 48:05.670
转成这个数字

48:05.950 --> 48:07.230
它最终得到的就是什么呢

48:07.230 --> 48:09.030
最终得到的就是0

48:09.510 --> 48:11.590
你这边的话你可以看一下

48:12.350 --> 48:14.390
我们这边把它打印出来看一下

48:17.370 --> 48:18.410
LOG

48:21.300 --> 48:23.380
好,让它在这边保存一下

48:24.380 --> 48:26.700
走,你看,这边是不是得到0

48:27.220 --> 48:28.860
所以说最终的话

48:29.260 --> 48:33.620
这个空数组最终转出来就是0

48:34.380 --> 48:35.660
这边得到了是0

48:36.180 --> 48:36.940
因此

48:38.420 --> 48:39.260
因此

48:41.300 --> 48:42.060
因此

48:42.300 --> 48:44.620
最终这个空数组

48:44.940 --> 48:48.420
转换出来就为什么呢

48:48.660 --> 48:49.940
就为0

48:50.980 --> 48:51.500
看到没有

48:51.740 --> 48:52.500
就为0

48:56.860 --> 48:58.580
那这里的话有的同学说

48:58.580 --> 49:00.540
哎,那些老师就这边的话

49:00.540 --> 49:02.500
空数组转出来是0

49:02.740 --> 49:05.060
那如果是我数组里面有元素呢

49:05.820 --> 49:07.860
有元素它转出来应该是多少呢

49:08.300 --> 49:09.380
那有元素的话

49:09.380 --> 49:11.580
那要取决于你这个数组里面

49:12.420 --> 49:13.500
有几个元素

49:14.060 --> 49:15.380
好,你这边你来看一下

49:15.380 --> 49:16.780
比如说我们这边的话

49:17.020 --> 49:19.100
Consult.LOG

49:19.100 --> 49:20.700
好,把上面的注射掉了

49:21.660 --> 49:23.060
把上面这些注射掉

49:25.270 --> 49:27.630
OK,好,我们这边Consult.LOG

49:27.630 --> 49:29.670
比如说这边仍然是制服串的5

49:30.270 --> 49:31.070
乘一个什么呢

49:31.070 --> 49:32.070
乘一个这个数组

49:32.070 --> 49:33.710
数组里面的话这边是2

49:34.310 --> 49:35.830
它有一个元素是2

49:36.110 --> 49:37.670
这个得到的值是多少呢

49:37.990 --> 49:40.270
其实刚才那个智能提示已经提示出来了

49:40.870 --> 49:41.350
多少

49:41.510 --> 49:42.350
是不是10

49:42.870 --> 49:43.350
对不对

49:43.590 --> 49:44.390
这里是10

49:44.630 --> 49:46.670
好,来我们这边我们还是来分析一下

49:46.910 --> 49:47.870
这边是怎么回事

49:48.270 --> 49:50.470
首先左边是这个制服串

49:50.870 --> 49:51.950
左边是制服串的话

49:51.950 --> 49:52.790
左边是转成5

49:52.790 --> 49:53.470
这个没问题

49:53.470 --> 49:54.550
我们主要分析什么呢

49:54.550 --> 49:56.230
主要分析这个右边

49:58.230 --> 50:00.030
主要分析右边

50:00.470 --> 50:01.310
那右边的话

50:01.310 --> 50:04.350
首先这个针对这个2

50:04.350 --> 50:05.350
它调用什么

50:05.350 --> 50:08.030
是不是调用ValueOf

50:08.630 --> 50:09.110
对不对

50:09.110 --> 50:10.630
调用这个ValueOf

50:10.630 --> 50:12.070
那我们这边我们来看一下

50:12.670 --> 50:13.350
LOG

50:14.750 --> 50:16.590
然后2ValueOf

50:16.590 --> 50:18.590
这个值能提示它不见得是对的

50:18.590 --> 50:19.950
好,我们这边保存

50:19.950 --> 50:20.550
走

50:20.550 --> 50:22.390
你看它得到的是什么

50:22.390 --> 50:24.670
是不是得到的仍然是这个数组

50:25.270 --> 50:25.910
对不对

50:25.910 --> 50:28.630
得到的仍然是这个数组

50:28.630 --> 50:31.350
那得到这个仍然是这个数组之后

50:31.350 --> 50:33.190
然后接下来没办法了

50:33.190 --> 50:34.590
你得到的还是一个数组

50:34.590 --> 50:35.870
也就还是一个对象

50:35.870 --> 50:37.030
还是一个对象的话

50:37.030 --> 50:37.790
那这边就干嘛

50:37.790 --> 50:40.710
这边的话是不是就是调2Stream

50:41.310 --> 50:41.910
对吧

50:41.910 --> 50:44.110
好,那接下来这边NOG

50:45.110 --> 50:46.590
然后2Stream

50:46.590 --> 50:47.470
好,保存

50:47.990 --> 50:48.550
走

50:48.550 --> 50:49.070
你看

50:49.070 --> 50:51.310
当调这个Stream的时候就得到什么

50:51.310 --> 50:53.350
是不是得到制服串的2

50:53.350 --> 50:54.550
你看这个颜色都不一样

50:54.550 --> 50:55.670
如果是数字的话

50:55.670 --> 50:57.350
它是这个黄色的

50:57.350 --> 50:58.470
这边是白色

50:58.470 --> 50:59.430
白色说明什么

50:59.430 --> 51:00.670
说明是这个制服串

51:00.670 --> 51:02.190
所以这边就得到什么

51:02.190 --> 51:05.990
所以得到制服串的2

51:05.990 --> 51:08.270
那制服串的2调这个Lumber

51:08.270 --> 51:09.590
然后最后

51:10.590 --> 51:13.190
最后这个Lumber

51:13.190 --> 51:13.670
对吧

51:13.750 --> 51:15.430
然后接下来这里面

51:15.430 --> 51:17.390
这里面是一个制服串的2

51:17.390 --> 51:18.790
那就变成了多少

51:18.790 --> 51:20.550
这就变成了2

51:20.550 --> 51:21.310
对不对

51:21.310 --> 51:21.990
OK

51:21.990 --> 51:24.630
那你如果数组里面有多个元素呢

51:24.630 --> 51:25.350
我们来看一下

51:26.670 --> 51:29.550
如果数组里面有多个元素

51:29.550 --> 51:32.870
比如说Consol.log

51:32.870 --> 51:34.790
仍然是制服串的5

51:34.790 --> 51:35.790
乘一个

51:35.790 --> 51:37.510
这边12

51:37.510 --> 51:39.950
你看12

51:39.950 --> 51:42.390
那这个的话得出来应该是多少

51:42.430 --> 51:43.670
我们保存一下

51:43.670 --> 51:46.670
你看这边得出来的结果就不一样了

51:46.670 --> 51:48.590
它得出来的就多少呢

51:48.590 --> 51:50.870
得出来的就是NAN

51:50.870 --> 51:52.950
它给你转成Number那些没有

51:52.950 --> 51:54.390
转了的

51:54.390 --> 51:55.030
对吧

51:55.030 --> 51:56.710
因为NAN也属于什么

51:56.710 --> 51:57.870
也属于Lumber

51:57.870 --> 51:58.990
它是转了的

51:58.990 --> 52:01.870
那为什么转出来是NAN呢

52:01.870 --> 52:03.790
是不是还是那样子分析

52:03.790 --> 52:04.350
对不对

52:04.350 --> 52:05.910
你这边的把那两个log

52:05.910 --> 52:08.150
你把它打印出来看一下就可以了

52:08.150 --> 52:09.630
你先打一个

52:09.630 --> 52:10.150
先打一个

52:10.150 --> 52:10.830
先打什么

52:10.870 --> 52:13.550
先打这个view off

52:13.550 --> 52:14.030
对吧

52:14.030 --> 52:15.710
先看这个view off

52:15.710 --> 52:16.750
它转出来是什么

52:18.190 --> 52:18.390
好

52:18.390 --> 52:20.070
我们这边保存一下

52:20.070 --> 52:20.990
走

52:20.990 --> 52:21.990
转出来什么

52:21.990 --> 52:23.790
是不是仍然是数组

52:23.790 --> 52:24.150
对吧

52:24.150 --> 52:24.990
这边12

52:26.670 --> 52:27.830
12

52:27.830 --> 52:28.470
仍然

52:30.940 --> 52:33.500
仍然是数组

52:33.500 --> 52:34.940
那没办法继续调什么

52:34.940 --> 52:35.940
是不是调这个

52:37.420 --> 52:39.660
调这个toursdream

52:39.660 --> 52:40.580
12

52:40.580 --> 52:43.580
然后点toursdream

52:43.580 --> 52:44.460
对吧

52:44.460 --> 52:44.780
好

52:44.780 --> 52:47.100
然后接下来这边来看toursdream

52:47.100 --> 52:48.460
toursdream你看这边

52:48.460 --> 52:49.580
它就转成什么了

52:49.580 --> 52:51.060
是不是转成这种制服创了

52:53.060 --> 52:53.780
对不对

52:53.780 --> 52:55.460
转成这种制服创了

52:55.460 --> 52:55.660
好

52:55.660 --> 52:56.900
转成这种制服创之后

52:56.900 --> 52:58.420
然后接下来这种制服创

52:58.420 --> 53:01.380
你用那个Lumber去转的话

53:01.380 --> 53:03.020
它转出来的话就是什么

53:03.020 --> 53:04.940
这转出来就是NAN

53:04.940 --> 53:06.580
你这边你来看一下嘛

53:06.580 --> 53:08.940
这边Lumber

53:08.980 --> 53:11.780
然后制服创12

53:11.780 --> 53:12.380
对吧

53:12.380 --> 53:13.460
那这种的话

53:13.460 --> 53:14.860
它转出来就是什么

53:14.860 --> 53:16.820
所以转出来最终它得到什么

53:16.820 --> 53:19.220
是不是它得到NAN

53:19.220 --> 53:21.140
那NAN和任意值做计算

53:21.140 --> 53:22.980
是不是得到都是NAN

53:22.980 --> 53:23.780
看了没有

53:23.780 --> 53:24.420
说这个的话

53:24.420 --> 53:28.060
你一步一步都是可以去分析的

53:28.060 --> 53:29.940
都是可以去分析的

53:29.940 --> 53:31.100
好吧

53:31.100 --> 53:31.780
OK

53:31.780 --> 53:35.740
这个是关于这边

53:36.700 --> 53:38.940
关于这边

53:38.940 --> 53:39.540
多说了一下

53:40.820 --> 53:41.060
好

53:41.060 --> 53:41.500
注意

53:41.500 --> 53:44.060
NOW的话转成数字为0

53:44.060 --> 53:47.100
undefine的话转成数字是NAN

53:47.100 --> 53:48.460
这个好像在上面有吧

53:48.460 --> 53:48.980
我看一下

53:50.820 --> 53:52.300
undefine是NAN

53:52.300 --> 53:53.500
NOW的话是0

53:53.500 --> 53:54.740
这是不是写了的

53:54.740 --> 53:55.020
对吧

53:55.020 --> 53:56.380
在原始值这个地方写了的

53:57.820 --> 53:58.140
好

53:58.140 --> 54:02.340
然后一元运算服也会把运算值

54:02.340 --> 54:05.700
就是一个操作数

54:05.700 --> 54:07.460
我们一般也称之为操作数

54:07.460 --> 54:08.900
会把一个操作数转成什么

54:08.900 --> 54:10.140
转成数值

54:10.140 --> 54:11.700
那我们这边我们来看一下

54:11.700 --> 54:13.780
你这边比如加一个制服串

54:13.780 --> 54:15.780
注意一下前面没有东西

54:15.780 --> 54:17.100
你如果前面还有东西的话

54:17.100 --> 54:18.180
它就是什么了

54:18.180 --> 54:20.140
它是不是制服串拼接了

54:20.140 --> 54:20.420
对不对

54:20.420 --> 54:21.660
我这边我就是写一个什么

54:21.660 --> 54:22.620
就是写个加

54:22.620 --> 54:24.020
制服串前面写个加号

54:24.020 --> 54:25.500
或者写个减号

54:25.500 --> 54:26.340
那它自动的话

54:26.340 --> 54:27.420
就会把它转成什么

54:27.420 --> 54:28.740
转成数值

54:28.740 --> 54:30.940
包括加一个Q

54:30.940 --> 54:32.180
减一个force

54:32.220 --> 54:32.580
看到没有

54:32.580 --> 54:34.620
这边就转成1了

54:34.620 --> 54:35.540
这边减一个force

54:35.540 --> 54:37.420
这边就转成0了

54:37.420 --> 54:38.580
我们这边我们来看一下

54:38.580 --> 54:41.780
让我们看第一个

54:41.780 --> 54:46.120
把这个注释掉

54:46.120 --> 54:46.600
好

54:46.600 --> 54:47.160
nog

54:48.920 --> 54:49.360
好

54:49.360 --> 54:50.960
然后就在这边走

54:50.960 --> 54:53.000
你看这边是不是得到ngn

54:53.000 --> 54:53.600
对不对

54:53.600 --> 54:54.800
但你前面不能有东西

54:54.800 --> 54:55.920
你如果前面有东西的话

54:55.920 --> 54:56.640
它就是什么

54:56.640 --> 54:58.520
所以它就制服串拼接了

54:58.520 --> 55:00.360
所以就是eabc

55:00.360 --> 55:02.600
对不对

55:02.600 --> 55:04.000
OK

55:04.360 --> 55:07.440
然后其他就没什么了

55:07.440 --> 55:09.120
整个数据类型的转换

55:09.120 --> 55:11.640
咱们就讲完了

55:11.640 --> 55:12.240
我们来看一下

55:12.240 --> 55:14.000
这个整体解答

55:14.000 --> 55:18.120
javascript中如何进行数据类型转换

55:18.120 --> 55:19.400
那你听了这些课之后

55:19.400 --> 55:20.880
再回头再看这道题

55:20.880 --> 55:22.680
是不是就很简单了

55:22.680 --> 55:23.160
对不对

55:23.160 --> 55:24.320
就很简单了

55:24.320 --> 55:25.000
分为什么

55:25.000 --> 55:28.120
分为影视转换和显性转换

55:28.120 --> 55:30.880
显性其实又称之为强制转换

55:30.880 --> 55:31.240
对吧

55:31.240 --> 55:33.560
影视转换又称之为自动转换

55:33.600 --> 55:34.080
OK

55:34.080 --> 55:36.640
然后这样影视转换这边是怎么转的

55:36.640 --> 55:37.280
对吧

55:37.280 --> 55:38.440
然后显示转换

55:38.440 --> 55:40.520
这边是怎么转的

55:40.520 --> 55:40.880
对吧

55:40.880 --> 55:42.680
这几个函数

55:42.680 --> 55:45.160
你把这几个反正把它达出来

55:45.160 --> 55:46.520
就OK了

55:46.520 --> 55:47.560
好吧

55:47.560 --> 55:48.440
所以这些课的话

55:48.440 --> 55:50.560
这个数据类型转换

55:50.560 --> 55:51.840
其实主要重点就是什么呢

55:51.840 --> 55:54.120
就是你首先要弄清楚

55:54.120 --> 55:55.040
在javascript里面

55:55.040 --> 55:56.480
它的类型转换

55:56.480 --> 55:58.040
首先分成两种

55:58.040 --> 55:59.560
一个是强制转换

55:59.560 --> 56:03.000
一个是自动转换

56:03.040 --> 56:04.160
把这两个分清楚

56:04.160 --> 56:05.680
然后接下来的话就是什么呢

56:05.680 --> 56:06.920
强制转换

56:06.920 --> 56:08.560
这边是不是这三个函数

56:08.560 --> 56:10.400
Lumber,Stream,Bulling

56:10.400 --> 56:11.000
对吧

56:11.000 --> 56:12.680
然后自动转换的时候

56:12.680 --> 56:14.800
它其实也是去调用的什么

56:14.800 --> 56:17.400
是不是也是调用的是这些函数

56:17.400 --> 56:17.680
对不对

56:17.680 --> 56:18.640
只不过它有一些什么

56:18.640 --> 56:20.240
是不是有一些顺序

56:20.240 --> 56:22.680
比如说我自动转这个致富串

56:22.680 --> 56:24.680
自动转致富串如果是

56:27.680 --> 56:28.280
不不不

56:28.280 --> 56:28.720
是这里

56:28.720 --> 56:29.400
是这里

56:29.400 --> 56:30.360
这边Stream

56:30.400 --> 56:31.840
Stream我这边在转的时候

56:31.840 --> 56:33.440
它有一些这个顺序

56:33.440 --> 56:35.080
比如说我转原始值的时候

56:35.080 --> 56:36.080
原始值还好

56:36.080 --> 56:36.280
对吧

56:36.280 --> 56:38.120
我如果是转对象的时候

56:38.120 --> 56:38.760
转对象的时候

56:38.760 --> 56:39.880
它就先调什么

56:39.880 --> 56:42.120
是不是先调toStream

56:42.120 --> 56:43.480
再调什么

56:43.480 --> 56:45.520
是不是再调vue of

56:45.520 --> 56:45.840
对吧

56:45.840 --> 56:48.080
我如果我设这个转这个Lumber

56:48.080 --> 56:48.840
转Lumber的话

56:48.840 --> 56:49.600
这边的话

56:49.600 --> 56:52.800
遇到对象先调vue of

56:52.800 --> 56:53.960
再调什么

56:53.960 --> 56:56.040
是不是再调toStream

56:56.040 --> 56:59.280
它是不是会有一个这样子的顺序

56:59.280 --> 56:59.720
对吧

56:59.760 --> 57:00.800
把这个搞懂

57:00.800 --> 57:02.000
这个搞懂之后

57:02.000 --> 57:03.760
然后那个自动转换的话

57:03.760 --> 57:05.560
它其实也是调的

57:05.560 --> 57:06.960
是不是这些函数

57:06.960 --> 57:07.400
对不对

57:07.400 --> 57:09.160
内部也是做的这些操作

57:09.160 --> 57:10.640
OK

57:10.640 --> 57:11.480
大家下来的话

57:11.480 --> 57:14.000
把这个数据类型这一小节

57:14.000 --> 57:15.400
再把它看一看

57:15.400 --> 57:16.200
好吧

57:16.200 --> 57:16.400
好

57:16.400 --> 57:17.840
这些就先到这里

57:17.840 --> 57:18.200
再见

