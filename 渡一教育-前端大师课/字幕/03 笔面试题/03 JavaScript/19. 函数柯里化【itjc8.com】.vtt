WEBVTT

00:01.140 --> 00:03.180
大家好 我是谢老师

00:03.180 --> 00:06.780
这节课我们来看一下这个 函数科理化

00:07.280 --> 00:11.380
这个是面试中也是很大概率会出现的一道题

00:11.640 --> 00:14.440
他就会问你 什么是函数科理化

00:14.700 --> 00:17.020
甚至让你自己写一个这个

00:17.280 --> 00:18.540
科理化函数

00:19.060 --> 00:22.380
好 那我们这边的话我们从这么几个点来给大家介绍

00:22.640 --> 00:25.980
首先的话就是介绍一下 这个什么是这个函数科理化

00:26.220 --> 00:27.760
或者说这个科理化函数

00:28.160 --> 00:32.360
那接下来我们来看一个这个科理化函数的一个快速入门势力

00:33.140 --> 00:34.160
然后我们

00:34.680 --> 00:39.280
知道了什么是这个科理化之后 然后我们来看一下这个科理化函数

00:39.540 --> 00:42.100
他在我们开发中的一个实际的应用

00:42.600 --> 00:46.200
他有没有实际的应用价值 他究竟只是这个穴头而已

00:46.460 --> 00:49.520
还是说就是实际开发中确实挺有用的

00:49.780 --> 00:53.360
那这样我们来封装一个这个科理化函数

00:53.620 --> 00:55.160
最后就是什么了 最后就是

00:55.400 --> 00:57.720
拿一道经典的这个科理化面试题

00:57.960 --> 00:59.000
我们一起来看一下

00:59.260 --> 00:59.760
好吧

01:00.020 --> 01:01.300
好 我们一个一个来看

01:01.560 --> 01:05.400
那首先第一个 第一个的话首先简单介绍一下啊 这个

01:05.660 --> 01:08.980
什么是函数科理化 或者说什么是科理化函数

01:09.740 --> 01:13.320
他这个的话其实是属于这个函数式编程里面的

01:13.580 --> 01:14.360
一个内容

01:15.120 --> 01:17.680
当然关于这个什么是函数式编程啊

01:17.940 --> 01:18.700
他其实

01:18.960 --> 01:21.260
就是是另外一种编程范式了

01:21.520 --> 01:23.560
他又是属于这个声明式编程的

01:24.540 --> 01:28.120
就我们常见了两种这个编程范式 一种是命令式

01:28.380 --> 01:29.860
一种是声明式

01:30.120 --> 01:32.980
就大家之前一直接触的都是什么呢 都是命令式

01:33.240 --> 01:38.360
命令式的话就是最大的特点就是你要去想我每一步要怎么实现

01:38.880 --> 01:42.720
但声明式就不用 啊声明式的话就是我告诉他我想要什么

01:42.980 --> 01:44.760
然后接下来的话我直接就是

01:45.020 --> 01:45.640
呃

01:45.900 --> 01:49.460
就书写我要的结果就可以了啊 比如说典型的

01:49.720 --> 01:51.560
HTML CSS

01:51.820 --> 01:53.220
他们就是声明式的语言

01:53.520 --> 01:55.080
你想想你写那个

01:55.480 --> 01:56.240
CSS

01:56.500 --> 01:57.920
对吧我写个Karnarade

01:58.160 --> 02:00.080
我是不是声明我要红色

02:00.340 --> 02:03.420
但具体他怎么实现的得到的红色我们是不是不关心啊

02:04.180 --> 02:07.520
对不对啊 这个就是不同的两种编程范式

02:08.020 --> 02:10.320
但是这个函数式编程的话

02:10.840 --> 02:13.400
他整的来讲的话其实入门是比较困难的

02:13.920 --> 02:18.520
啊比较困难 因为他里面涉及到很多这个数学里面的这个知识

02:18.780 --> 02:22.360
就入门的门槛比这个命令式编程要高很多

02:22.940 --> 02:25.300
那我们的这个科理化函数呢

02:25.560 --> 02:29.740
他属于这个函数式编程里面的一个这个知识啊

02:30.000 --> 02:34.040
然后这个知识的话还是比较简单的啊 我们这边我们来看一下

02:35.360 --> 02:39.460
呃 首先在计算机科学中科理化啊英语叫做这个Carry

02:39.940 --> 02:41.000
呃 又意味什么呢

02:41.260 --> 02:42.540
卡瑞化或者家里化

02:42.800 --> 02:46.140
但我们一般就是国内我们意味都是就叫做科理化

02:46.640 --> 02:48.340
他指的是什么呢 好看这句话

02:48.680 --> 02:53.420
他指的是把是接收多个参数的函数

02:53.920 --> 02:57.440
啊注意啊 首先他是把这个接收多个参数的函数

02:57.840 --> 03:02.520
把一个函数变成一个什么呢 变成另一个函数

03:03.520 --> 03:08.720
看到没有 把我们来看啊 这边把把什么呢 把一个函数

03:09.240 --> 03:11.840
变成一个函数

03:13.280 --> 03:17.440
那把一个函数变成另外一个函数 那把这个函数什么样的函数呢

03:17.620 --> 03:26.340
接收多个参数的函数 变成什么样的函数呢 变成接收一个单一参数的函数

03:27.540 --> 03:34.940
可能没有 那并且把这个函数把它返回出去啊 这个其实就是科理化 那说起来的话是比较绕的

03:35.580 --> 03:38.940
是吧 我们一会让我们看个实际的例子 大家就明白了

03:39.540 --> 03:45.580
好 下面这个技术是由这个克里斯托弗啊 斯特雷奇以这个逻辑学家

03:46.480 --> 03:54.920
这个哈斯凯尔加利命名的啊 就是以一个人名 就是这个人的名字啊 他是个逻辑学家啊

03:54.920 --> 04:01.000
然后就是这个克里斯托弗 斯特雷奇就以这个逻辑学家的这个名字来命名的

04:02.080 --> 04:11.320
好 然后其他的直觉上 然后克里化声称 如果你固定某些参数 你将得到接收余下参数的一个函数

04:11.780 --> 04:14.500
但现在你来看这些的话 你理解都不深

04:15.420 --> 04:21.900
对不对啊 你看上去就是这句话 你也不知道他在说什么 好 我们这边我们来看一个这个快速入门的这个势力

04:22.460 --> 04:27.660
大家就知道了啊 好比我们这边啊 这个例子很简单 对吧 我把这个例子

04:28.500 --> 04:33.220
我把这个例子复制过来 拿过来啊 我把这个放大一点吧

04:36.870 --> 04:42.030
把这个例子拿过来 这个说一个很简单的例子 对不对啊 有一个这个and方法

04:42.770 --> 04:48.370
哦 按的函数 按的函数啊 不能说方法 以对象的形式调用才是方法啊 这边的话是这个

04:49.290 --> 04:55.130
这个and函数 然后他接收什么 是不是接收两个参数啊 x和y 那既然这边返回

04:56.530 --> 05:00.690
返回是吧 x加y 那这个函数他就是接收什么

05:01.490 --> 05:09.390
是接收多个参数啊 对不对 该函数就是接收

05:09.850 --> 05:11.650
多个

05:12.690 --> 05:18.570
参数 好 那接下来的话 我们要对他进行一个这个颗粒化啊 我们要将他进行颗粒化

05:19.330 --> 05:19.730
接下来

05:21.650 --> 05:24.530
接下来 我们要将其

05:26.090 --> 05:27.770
进行颗粒化

05:30.670 --> 05:30.830
颗

05:32.750 --> 05:39.710
颗粒化啊 那颗粒化的核心就是什么呢 把它重新变成一个什么呀 是不是只接收一个参数的

05:40.290 --> 05:42.810
对不对 所以我们这边的话 我们这边function

05:45.320 --> 05:55.240
然后ad你只接收一个参数 但你只接收一个参数是不够啊 对不对 然后我们怎么办呢 我们这边的话 我们给你返回一个

05:56.560 --> 05:57.880
返回一个函数

05:58.800 --> 06:03.560
看到没有 我给你返回一个函数 然后加这个函数的话 然后再接收

06:04.680 --> 06:08.000
剩下的这个参数 好 然后接下来 我们这边return

06:08.660 --> 06:10.660
ak4加一个y

06:11.940 --> 06:16.700
看到没有 我每次我的函数只接收几个参数啊 是不是只接收一个参数呀

06:17.420 --> 06:25.700
无论是这个and 还是他返回的这个函数 只接收一个参数 好 那接下来我们这边在调用的时候 我们就可以干嘛呢 我们这边就可以这样子

06:27.180 --> 06:35.060
我首先传个一 那传个一这个是不是不够 对不对 然后传个一之后一传进来ak4是一 然后既然他会返回一个什么

06:35.960 --> 06:46.080
会返回一个这个函数啊 对不对 也就是你整个这一块 他得到的反归值是一个什么呢 是一个函数 什么函数就是这个函数

06:46.840 --> 06:52.000
看到没有 就是这个函数 然后接下来的话 我们这边再来传二

06:52.800 --> 06:56.080
然后下他这边返回x加 y 那我们这边我们可以试一下

06:57.000 --> 06:58.840
好 我这边的话log

07:01.200 --> 07:02.440
好 我们这边我们来看一下啊

07:03.220 --> 07:03.420
走

07:04.540 --> 07:10.620
看到没有 这边是我搞定了啊 然后怎么还输出了

07:12.060 --> 07:13.100
两个方形呢

07:14.140 --> 07:16.380
哦 这里 这里啊 把这儿注死了

07:17.900 --> 07:18.540
把这儿注死了

07:19.740 --> 07:23.460
ok 是我搞定了 对不对 你看这就是一个

07:24.220 --> 07:30.340
颗粒化函数的一个快速入门势力啊 我们这边回来看一下 这边啊 刚才写了代码啊

07:31.040 --> 07:36.320
好 在上面的代码中 我们就对这个and函数进行了一个颗粒化改造

07:36.960 --> 07:40.760
干嘛呢 只接收一个函数 但是返回的也不是值了

07:41.480 --> 07:44.280
而是返回的是一个什么 是不是是一个函数

07:45.240 --> 07:50.600
对不对 那这个函数也接收一个函数啊 然后利用b包的特性 注意这里利用到了b包

07:51.760 --> 07:57.440
如果你不知道什么是b包 建议你去把这个b包这个章节啊 先看一下啊 这里的话很明显

07:57.860 --> 08:05.340
你看这里是不是很明显用到b包 对不对 这边啊这个xx的话就来源于这个and作用语的这个x 对不对

08:06.780 --> 08:07.780
好 然后

08:09.380 --> 08:15.140
然后最后啊 然后访问到最开始传入的x的字 最终返回x和y的和

08:16.020 --> 08:19.340
你把这个例子看了之后 你回头你再过来来看啊

08:20.320 --> 08:27.480
他把接收多个参数的函数 变换成接收一个单一参数的函数

08:28.280 --> 08:32.640
你现在是不是感觉就看得懂一些了 对不对 稍微看得懂一些了

08:34.240 --> 08:40.680
当然现在的话 大家对这个概念稍微清晰了一些 但是大家现在肯定一定会有一个新的疑问

08:41.200 --> 08:43.920
就什么疑问呢 是我为什么要这么做呀

08:44.700 --> 08:48.580
对不对 我以前我像这边我传两个参数好好的

08:49.380 --> 08:55.420
我干嘛 我这边我要搞成这样子呀 这么复杂啊 然后还给我返回一个函数 然后接下来我再来调用

08:55.940 --> 09:04.140
为什么呢 好 那我们接下来我们来说一下科理化它的好处 科理化其实就一个好处 最大的好处就是什么呢 固定参数

09:05.420 --> 09:11.020
啊 固定参数 好 什么意思啊 回到我们这边 我们来看一下

09:12.000 --> 09:17.560
看一下啊 这边 科理化的实际应用 好 我们来看一下

09:19.000 --> 09:24.840
他比如说这边实际的应用 首先这边就是参数复用 其实也就是刚才我所说的这个固定参数

09:25.720 --> 09:32.600
比如说我这边 这边的话我封装了一个函数 这个函数干嘛呢 这个函数接收一个证则表达是

09:33.720 --> 09:40.160
然后呢 接收一个这个你要验证的制服串 然后接下来返回他是否符合要求

09:41.240 --> 09:43.320
克勒米尔 好 我们把这个例子我们来看一下

09:44.120 --> 09:53.490
好 把这个拿过来过来一点 好 这边的话 我们有一个这个check

09:54.210 --> 09:56.490
这边接收两个参数 对吧 一个是这个

09:57.450 --> 10:01.370
呃 你接收的这个证则表达是 然后的话是一个

10:02.290 --> 10:09.930
你要验证的制服串 好 然后接下来你看我们这边 这边的话传入证则表达是 然后验证的制服串好 这边出结果啊 我要这个

10:10.550 --> 10:14.590
证则表达是 然后加验证制服串出结果 但是这里就有个问题

10:15.110 --> 10:19.550
假设我们每一次 我们的这个证则表达是都是一样的

10:20.190 --> 10:28.270
那你注意哦 每一次我的证则表达是都是一样的 只有什么呢 只有制服串不一样啊 就是要验证的制服串不一样

10:28.550 --> 10:35.870
但是你在用这个方法的时候 你不得不干嘛呀 不得不 是吧 还是得老老实实的传啊

10:36.810 --> 10:44.850
对不对 你还是得老老实实的传这个参数啊 大家比如说abc 你还是得传 为什么呢 因为你函数就是这么设计的

10:45.370 --> 10:51.810
他需要接收两个参数 所以你这边哪怕第一项都是一样的 那你第二项也得传

10:52.450 --> 10:56.810
好 那我们把这个场景扩展开来 那假设我有这么一个函数 比如说taste函数

10:58.170 --> 11:02.890
那接收啊 五个参数 ab c d

11:03.630 --> 11:11.270
1 接收五个参数 但是我们发现就是我们在使用的时候 实际使用的时候啊 abc d

11:11.910 --> 11:19.430
或者比如说abc 啊 都是什么呢 都是一样的啊 经常变的都是什么呢 都是这个后面两个

11:20.070 --> 11:23.750
但是呢 我又不可能在这个taste函数里面把abc全部固定死

11:24.470 --> 11:29.870
啊 因为有些时候我想要就是用户也可以 就传不同的a 不同的b 不同的c

11:30.330 --> 11:37.930
但是大部分情况的话这个abc都是相同的 那你如果没有颗粒化的话 那你以后调用的时候 是不是每一次都得

11:38.650 --> 11:39.850
这样子abc 第一

11:40.690 --> 11:46.010
是不是都就是就是前面哪怕是相同的 是不是也得传递啊

11:47.450 --> 11:49.610
对不对 也需要传递

11:50.850 --> 11:55.290
那所以说你看这个时候就体现出什么了 就体现出颗粒化的好处了

11:55.770 --> 11:59.730
啊 有了这个颗粒化之后 那接下来 比较上面的这个代码 我们就可以怎么来改

12:00.450 --> 12:04.610
把这儿删掉 那上面的这个代码 我把这儿注射掉啊

12:06.250 --> 12:09.770
那我们这边是不是就是可以function 然后这边的话就是

12:10.970 --> 12:11.170
check

12:13.850 --> 12:19.690
好 然后接下来他接受一个什么 接受一个reg 对吧 然后加这边retur一个方形

12:20.130 --> 12:21.490
好 这边的话是你要这个

12:22.410 --> 12:25.490
验证的这个str 好 然后加这边的话return

12:26.250 --> 12:28.570
returnreg.str

12:30.810 --> 12:32.650
不不不 这边应该是掉test

12:33.850 --> 12:34.250
test

12:34.850 --> 12:35.370
str

12:36.090 --> 12:40.890
看到没有 我把它改成这个样子之后 那接下来回头的话我就可以干嘛呀 比如说我这边是

12:41.690 --> 12:46.370
相同的啊 这个正则表的是相同的 那我这边的话就可以check

12:47.170 --> 12:49.530
然后把这个正则把它传进去

12:52.850 --> 12:56.130
啊 传进去 然后得到一个什么呢 得到一个新的函数

12:57.250 --> 13:02.130
得到一个新的函数 然后接下来的话我这边 以后我在用的时候我就用什么呀

13:02.450 --> 13:05.930
我是不是就用这个新的函数 让我传一个参数是不是就可以了

13:07.090 --> 13:08.730
对不对啊 我这边我们来看一下

13:09.610 --> 13:15.070
然后落格一下吧 看到没有啊 大家这边我只需要传

13:16.190 --> 13:21.070
一个参数 前面相同的我不需要再传了啊 没有这边adc

13:21.950 --> 13:22.990
好 我这边我们来看一下

13:25.400 --> 13:27.440
搞定没有 是不是正常结果出来了

13:28.120 --> 13:33.000
看到没有 这就是这个科理化最大的好处 就是什么呢 固定参数

13:33.940 --> 13:39.140
看到没有 固定参数啊 你可以把视频暂停一下 你可以把这一块好好理解一下

13:39.660 --> 13:43.500
啊 当我这边的话 因为我参数很少 我这边是不是就只有两个参数

13:44.520 --> 13:49.140
对不对 你想 你应该能够想象得到就是我们有些函数他接受的参数是很多的

13:50.140 --> 13:52.100
对不对 他接受的参数是很多的

13:52.700 --> 13:55.980
那很多的话 那比如说如果前面都是相同的话 那我每次都得

13:56.500 --> 13:58.980
传这个相同的这个参数 这点就很烦

13:59.600 --> 14:05.120
那我通过把这个函数科理化之后 我以后的话 我就把这个相同的参数 我就把它固定下来了

14:05.380 --> 14:07.680
固定下来 你看我这后面我只用传什么

14:07.940 --> 14:11.280
这不只用传不一样的 对不对 一样的这个

14:12.040 --> 14:13.320
是不是就已经固定下来了

14:15.120 --> 14:16.900
那如果比如说我这个

14:17.160 --> 14:22.800
政治表达是 比如我下次要用的是 真正表达是不一样的 那不一样了吗 那你这边就直接

14:23.300 --> 14:26.120
重新调什么呢 重新调check就可以了

14:26.840 --> 14:31.960
对不对 重新调check 然后在这边随便传一个这个真正表达是 比如说

14:33.240 --> 14:35.040
a到z 然后

14:35.540 --> 14:37.340
这个加一个这边g

14:39.380 --> 14:42.460
对不对 你随便传一个 然后既然你注意他得到的是一个什么

14:43.220 --> 14:46.300
一定要注意他得到的是一个什么 所以他得到的是一个函数

14:47.060 --> 14:51.940
所以你这边的话直接在调用 直接在调用 然后加这边比较taste

14:54.130 --> 14:58.370
是不是ok的 对不对 ok的 这就是关于我们的这个

14:59.130 --> 15:08.090
就科理化函数 它的第一个实际应用 参数复用 我这边给你写一下 其实就是什么呢 其实就是固定参数

15:10.180 --> 15:11.200
然后写到下面吗

15:13.590 --> 15:14.110
写到下面

15:15.390 --> 15:23.590
就是将参数 就相同的参数 相同的参数 固定

15:24.350 --> 15:24.870
下来

15:25.590 --> 15:30.190
这就是他的这个实际应用 好 然后接下来第二个

15:31.210 --> 15:35.050
第二个这写的是提前确认 其实和上面是一样的

15:35.570 --> 15:38.890
和上面是一样的 这个例子我们把它看一下嘛 比如说这边

15:39.930 --> 15:42.490
挖了一个案等于一个这个function

15:43.250 --> 15:45.050
这function的话 接受一个什么呢

15:45.810 --> 15:48.370
接受一个element 我们来看一下啊

15:48.890 --> 15:52.970
element是要绑定事件的这个动物元素

15:53.590 --> 15:55.110
然后接下来这个element

15:55.630 --> 15:57.510
element是你要绑定什么事件

15:58.590 --> 16:05.990
然后handle呢 handle呢是这个事件处理函数啊 然后接下来进来 进来是不是有一个e for else判断

16:06.790 --> 16:08.990
啊e for document.

16:09.470 --> 16:13.510
这个and the event listener 那说明是不标准多么的绑立方式

16:14.150 --> 16:19.150
啊否则的话他就怎么绑 否则是不是IE IE的话他是不是就是attach event

16:20.130 --> 16:20.410
对不对

16:21.130 --> 16:27.610
好 那你每一次在绑定的时候 比如说我这边每次绑定啊我这边啊 比如说我这边有一个这个

16:28.090 --> 16:33.130
div元素嘛 有一个div啊 这样我要绑定一个 比如说click事件

16:34.690 --> 16:42.290
click事件 好大家这边是不是有一个事件处理函数啊啊 这事件处理函数我就不写啊 我写一个这个函数好 我就这边

16:42.810 --> 16:45.970
这边来绑定 但绑定的话你进去每次都需要干嘛

16:46.870 --> 16:51.990
每次都需要干嘛 每次是不是都需要判断一下 document.and event listener

16:52.790 --> 16:54.990
对不对 看他究竟是什么这个

16:56.070 --> 17:04.270
浏览器啊 如果是标准的就是支持这个的 那就用这种方式吧 如果是IE 啊IE不支持这个 那就用这个attach event来吧

17:05.030 --> 17:08.190
你每一个都得判断一下 但是你想想有没有必要

17:09.230 --> 17:15.710
有没有必要 是没有必要 对不对啊 我就可以干嘛了 我就可以在一开始就判断了 所以你看我这边

17:16.950 --> 17:22.230
这边 这边的话 然后这边 if document.and event listener

17:23.070 --> 17:26.790
判断 判断完了之后干嘛呢 返回一个函数

17:27.630 --> 17:29.310
看到没有 返回一个函数

17:30.990 --> 17:35.390
那么我下一次在用的时候 我用的就是哪个 我用的是不是就是这个函数

17:36.030 --> 17:42.750
这个函数还需不需要做一个这个 document.and event listener的判断 还需不需要 这不就不需要了

17:43.530 --> 17:46.570
对不对 这里的话就不需要了 也就是说我这边的话

17:48.690 --> 17:51.770
这边的话 我这个and 通过这个and

17:52.410 --> 18:00.370
and的话 它这边的话是一个立即执行函数 然后再返回那个函数 说这个and最终也是不是也是个函数啊 然后我这边在这个调用的时候

18:01.050 --> 18:02.610
我每次这个调用的时候

18:04.130 --> 18:06.250
啊 调用的时候 它还会不会执行这一步

18:07.030 --> 18:12.710
它说不会执行这一步 为什么 因为它这边的话 你这个and实际上是哪个函数啊 是不是这个函数啊

18:13.630 --> 18:17.150
对不对 你的这个and实际上是这个函数

18:17.750 --> 18:23.750
这个函数的话 然后我必须要再判断了 因为之前的话已经判断过了 一开始我就通过这个判断

18:24.070 --> 18:32.350
判断了 究竟给你返回哪个函数 是返回这个还是返回这个 那当你调用这个and的时候 要么调用的是

18:32.930 --> 18:38.170
这个 要么调用的是这个 我不需要再做这个义父判断了

18:38.970 --> 18:44.770
看到没有啊 这就是这个提前确认 其实也是什么呢 是不是先确认好 对不对

18:45.250 --> 18:50.930
你看这里的话就是也是克里化函数的一个应用啊 下面是换了一种写法

18:52.090 --> 18:56.450
你看下面这个 下面这边的话 然后一开始接收四个参数

18:57.070 --> 18:58.510
可能这个就更加明显了

18:59.070 --> 19:04.870
这个就更加明显 一开始接收四个参数啊 一是support 是否支持 然后接下来后面三个是

19:05.470 --> 19:12.230
一样的 那你如果没有克里化的话 我干嘛呀 我每一次是不是都得调四个参数啊 对不对 我每一次这边

19:14.070 --> 19:21.310
没这版事件的时候啊 我这边都得传个啊 支持啊 比我们假设传一个去啊 大家第二次也得传一个去

19:21.950 --> 19:26.190
也得传个去啊去 你在同一个浏览器里面 你是不是这个肯定是一样的

19:27.150 --> 19:33.550
对不对 肯定是一样的 那你这边的话每次都是得传一个这个去 那每次传一个去 你这个是没有必要啊

19:34.950 --> 19:40.670
对不对 没有必要啊 说说我们这边的话就直接干嘛呢 这边的话就直接

19:41.430 --> 19:47.950
使用这个克里化啊 把这个固定下来 固定下来之后 然后加这边返回一个这个函数

19:48.870 --> 19:53.470
看到没有 返回一个函数啊 这就是关于这个克里化的一个实际应用

19:53.970 --> 20:01.450
我们这边我们来看一下 我们在做项目的过程中啊 封装一些动物操作啊 非常的常见啊 然后

20:03.050 --> 20:09.290
啊 这里当然提供两种写法啊 然后这其实就是什么呢 提前确定的会走哪一个方法

20:09.770 --> 20:13.050
避免什么呀 说避免每一次都进行判断

20:13.970 --> 20:16.090
对不对 避免我每次都进行判断

20:17.070 --> 20:23.590
说这个在我们开发中 其实是有实际这个作用的啊 就是有这个实际的价值的

20:24.190 --> 20:33.510
好了 好 然后这里的话 接下来我们就开始来准备封装一个通用的这个克里化函数 因为我们刚才上面写的这个克里化

20:34.150 --> 20:36.030
上面写的这些例子 他不够通用

20:36.990 --> 20:43.550
对不对 不够通用 都是针对当前的这个场景写的 好 那接下来我们来封装一个通用的克里化函数

20:45.670 --> 20:52.070
好 我们这边的话来到这里啊 我们把这注释掉 把这注释掉 好 然后接下来这边

20:53.790 --> 20:58.670
封装 封装一个通用的

20:59.310 --> 21:09.150
克里化函数啊 那我们这边我们先来看一下这个通用的这个克里化函数怎么用啊 比如说我假设我这个已经封通好了

21:11.430 --> 21:15.430
假设已经封通好了 好 那接下来的话 后期我比如说我这边

21:16.230 --> 21:24.110
有一个方形and 比如说他接受什么呢 接受这个 a b c d

21:24.750 --> 21:30.910
他接受四个参数啊 四个参数然后在这边return a加b加c

21:32.150 --> 21:33.070
加d

21:34.050 --> 21:41.850
可了没有 那接下来我到时候我要对这个这个函数进行克里化的时候 我就不用自己再熟悉了 我就调用我这个

21:42.210 --> 21:45.570
啊 怎么调用呢 我这边的话就可以直接调这个carry

21:47.610 --> 21:50.410
调carry 然后把什么呢 把我的这个

21:51.410 --> 21:54.970
方法传进去啊 比如说我这边可以传一个这个and

21:55.650 --> 21:58.170
and 然后接下来 那既然你的参数是不够

21:58.830 --> 21:59.990
因为我这边的话就是

22:01.190 --> 22:06.110
你要首先第一个参数是你要运行什么样的函数啊 然后这边的话就是这个参数啊

22:06.590 --> 22:12.990
然后这边他就会给你返回一个函数 返回一个函数 然后将我这边继续来传啊 比如传一个一

22:14.350 --> 22:20.550
传一个一啊 大家这边传一个二 传一个三 传一个四

22:21.230 --> 22:25.710
那这个时候是不参数够了 这个时候参数够了之后 然后最终他才会给我干嘛呢

22:26.050 --> 22:33.450
就是运行啊 或者说执行这个函数啊 或者这样子 或者我这边的话carry

22:35.130 --> 22:38.450
我一开始传什么呢 我传多传一点 有一二

22:39.330 --> 22:45.130
那我现在是不是这边的话就传了三个参数啊 对不对 传了三个参数之后 然后接下来的话还缺几个

22:46.090 --> 22:52.650
还缺几个 这边还缺两个 对不对 那你这边就可以传 反正凑够 就是这边这个参数啊 凑够四个

22:53.350 --> 22:55.310
凑够四个 他就可以执行

22:55.990 --> 22:58.430
第一个 第一个肯定是你要执行的函数

22:59.430 --> 23:05.990
明白没有 第一个肯定是你要执行的函数啊 就是他有多种多样的这个调用方法啊 包括你可以这个样子

23:08.420 --> 23:10.980
比如说我这边的话就是啊 呃and

23:12.380 --> 23:16.340
然后一二 对吧 然后三

23:17.340 --> 23:18.300
然后四

23:19.060 --> 23:23.100
看见没有 多种多样的调用方式 只要你把最后这个参数

23:24.080 --> 23:25.560
给我凑够四个

23:26.400 --> 23:31.120
就可以了啊 好 那我们这边的话 我们叫封装这么一个通用的这个carry

23:31.800 --> 23:33.360
他第一个参数肯定是什么

23:34.280 --> 23:38.800
这肯定是这个你要进行颗粒化的那个函数

23:39.480 --> 23:44.880
对不对 你要进行一个这个颗粒化函数 那接下来你哪个函数要进行颗粒化啊 所以他这边的话

23:45.440 --> 23:47.480
我们这边可以通过什么呢 可以通过这个

23:48.360 --> 23:52.360
哇一个fn 等于一个arguments

23:54.080 --> 23:55.560
啊 我们就不在这这里写了

23:56.680 --> 23:59.880
就不在这里写了啊 我们直接通过什么了 通过这个arguments来拿

24:00.440 --> 24:02.760
拿到什么呢 首先这边是拿到

24:05.200 --> 24:08.160
拿到要执行的

24:09.640 --> 24:14.520
函数 这是首先是第一步 拿到这个之后然后接下来的话

24:15.200 --> 24:20.520
我不知道他后面是不是还有没有这个参数 那如果比如说像这个这个的话 后面是没有参数的

24:20.780 --> 24:24.940
那这边的话是不是后面有参数啊 对不对 所以这个事情我是不知道的

24:25.340 --> 24:29.020
不知道了怎么办呢 那我这边的话啊就把这个

24:29.900 --> 24:30.500
后面的

24:31.620 --> 24:37.220
后面的是个所有参数 我把它拿到 拿到我把它转成一个数组啊 边我这边哇

24:38.580 --> 24:42.700
哇一个arcs 等于一个这个array

24:43.700 --> 24:46.180
点这个portotype

24:47.620 --> 24:50.180
点这个slice 点core

24:51.220 --> 24:55.340
好 然后接下这边arguments 然后再从第几个 从第1个

24:56.380 --> 25:01.380
看到没有 这就是获取就是第1个以后的参数 比如说我这边第一次

25:02.300 --> 25:07.020
第一次 第一次的话 我这边的话 这个刚才的这个arguments 把谁拿到了

25:08.220 --> 25:13.020
把谁拿到 把他拿到了 把他拿到了之后 然后接下来后面是吧 还有两个参数啊

25:13.900 --> 25:18.540
看到没有 然后这样我就把这两个参数拿到 组成一个什么呢 组成一个数组

25:19.000 --> 25:22.320
好 我们这边可以打印出来看一下啊 我把这个

25:23.800 --> 25:24.240
复制一份

25:26.120 --> 25:27.160
把这个先注射

25:28.280 --> 25:30.440
然后这边的话 这个不要了

25:31.760 --> 25:32.360
这个不要了

25:33.960 --> 25:36.760
这个不要了 好 然后这样我们这边我们来打印一下

25:38.440 --> 25:41.840
nog 这个是fn 我们这样子

25:43.640 --> 25:44.040
fn

25:45.400 --> 25:45.800
fn

25:46.660 --> 25:48.820
然后接下来的话 这边args

25:53.400 --> 25:55.960
ok 好 那这样我们这边 我们来看一下

25:57.760 --> 26:02.860
啊 先空一下 走

26:03.980 --> 26:07.300
看到没有 首先第1个fn 是不是肯定是拿到的是什么

26:07.900 --> 26:12.180
这不拿到就是你要执行这个克力化函数的这个函数 对不对 就你要执行这个函数

26:12.780 --> 26:18.540
是不是先拿到他 拿到他之后 然后接下来拿到什么呀 这不拿到你第一次调用的时候 他后面的这个参数

26:19.360 --> 26:24.480
对不对 你这个第1个和第3个因为没有 所以他是一个空数组 好 然后接下来放上这边

26:25.040 --> 26:32.000
呃 第二次调 就是这边第二次调用 第二次调用这边是有这个1和2 那我这边是不是就把1和2拿到了

26:32.640 --> 26:37.320
对不对 那假设我这边再来一个 我这边的话 穿一个1 2 3

26:38.040 --> 26:43.160
啊 三 大家这边走 那这边是不是就把123就拿到了 并且是一个什么呀

26:43.640 --> 26:46.640
是不是是一个数组啊 看到没有 并且是个数组

26:49.040 --> 26:49.540
好

26:50.440 --> 26:57.240
然后完事之后 大家我们下一步 下一步我们就需要干嘛呢 我们就需要判断这个参数是否足够

26:59.580 --> 27:11.460
接下来我们就需要判断 判断什么呢 判断这个参数是否足够 因为足够的话我是不直接运行这个FN啊

27:12.120 --> 27:18.720
对不对 那比如说我们这边 义父 义父什么呢 义父这个arx

27:19.480 --> 27:24.280
arx 是不是就是啊 啊 这里后面的参数啊 点这个认识

27:25.600 --> 27:34.640
他如果全等于什么呢 全等于fn 点认识啊fn fn 是谁 fn 是不是就是这个你要执行的这个函数啊

27:34.920 --> 27:38.760
然后点认识 点认识是否获取到他行参的数量 对不对 如果相等

27:40.200 --> 27:41.880
啊 进入此义父

27:43.440 --> 27:51.480
进入此义父 说明第一次参数就是传够了的

27:53.360 --> 27:53.920
传

27:55.160 --> 27:56.000
传够了的

27:57.400 --> 28:01.640
对不对 那第一次就传够了 那接下来就直接干嘛呀 这不直接执行啊

28:02.640 --> 28:06.080
直接执行这个fn

28:07.080 --> 28:10.840
函数 对不对 那怎么执行的 那这边就是fn

28:11.580 --> 28:13.260
然后接下来点这个apply

28:15.820 --> 28:18.260
啊 然后接下来把什么 把这个arx

28:19.060 --> 28:23.900
传过去 好 大家这边是不是会得到一个这个结果 得到一个结果 然后接下来你把这个结果

28:25.340 --> 28:32.180
都返回 对不对 那没有进义父 没有进义父 说明是不是没有传够啊 没有传够我们这边暂时

28:32.900 --> 28:35.260
给他返回一个制服串 就是参数不够

28:36.500 --> 28:42.060
参数不够好吧 好 那接下来我们这边我们来看一下啊

28:43.580 --> 28:44.340
我们这边再来一个

28:45.540 --> 28:45.780
是

28:46.900 --> 28:48.940
好 然后这边是不是得打印一下

28:50.420 --> 28:52.740
啊 我们这边的把这个挨在这放进去哈

28:54.540 --> 29:03.730
然后12345 然后把这个拿过去 然后把这个

29:05.050 --> 29:10.730
拿过去 啊 只有哪个 是不是只有最后一个

29:11.570 --> 29:16.530
是可以输出结果的 对不对 其他的话都会给我返回什么 这参数不够

29:17.370 --> 29:18.410
好 我们这边我们来试一试

29:22.530 --> 29:28.250
看到没有 是不是前面四个是不是都给我返回的是参数不够 只有最后一个 因为最后一个你传够了的呀

29:29.170 --> 29:33.610
你是不是传够了的 传够了让我这边的话是不是就直接执行他进义父是不是就执行了

29:34.210 --> 29:40.010
对不对 OK 好 然后接下来完事之后让我们这边如果参数不够的情况

29:40.750 --> 29:49.650
啊 下面下面是处理什么的参数不够的情况

29:50.690 --> 29:56.890
那参数不够的情况 我们肯定不是说返回一个制服错吗 我们应该返回一个什么是返回一个新的函数

29:57.570 --> 29:59.890
对不对 我们这边的话就是有一个这个function

30:00.970 --> 30:04.490
function 然后接下来有一个什么的有一个这个下滑线 carry

30:06.530 --> 30:11.130
有这么一个这个函数 好 然后接下来这边当这边的话我就返回这个函数

30:12.690 --> 30:16.530
看到没有啊 那我就给你返回这么一个函数 好 我们这样再来执行

30:17.650 --> 30:23.050
看到没有啊 前面几个都是返回的是什么 因为参数不够 参数不够返回的是不是都是这个

30:23.930 --> 30:24.970
都是这个函数啊

30:26.010 --> 30:29.530
看到没有 然后加最后一个参数够了 他进义父是不是返回 是不是直接执行

30:30.210 --> 30:37.330
啊 好 那接下来我们知道前面几个都是返回的是这个函数了 那前面几个返回的函数 然后接下来他又继续干嘛呀

30:37.870 --> 30:40.670
是不是既然是个函数 那我既然是不是可以继续

30:41.790 --> 30:46.910
调用 对不对 继续调用 然后接下来我这边就可以来传值啊 传一

30:47.870 --> 30:55.550
传二 传三 传四 我是不是可以这样子啊 对不对 三一点啊 三一点

30:56.190 --> 31:03.390
啊 也就是说这边 这边的话 你第一次执行到这 这的话返回是一个函数 那既然是一个函数 那我这边是不是可以继续的

31:03.850 --> 31:07.450
调用他 要加传这个值啊 那比如说我这边传一个一

31:09.660 --> 31:15.260
只传一个一 参数够不够 是不是 仍然不够 但是我现在是不是已经接受到一个参数了

31:16.100 --> 31:23.100
对不对 接受到一个参数 然后接下来我们干嘛呢 我们将这个新的参数推入到我们的这个ax里面

31:25.880 --> 31:28.680
啊 我们这边的话就是直接点点点

31:29.640 --> 31:30.280
arguments

31:31.260 --> 31:38.940
把arguments展开啊 拿到这个arguments的值 推入到这个ax里面 好 然后接下来我们这边可以log一下

31:40.460 --> 31:42.780
log一下 然后这里的话是这个ax

31:44.220 --> 31:45.500
好 接下来我们这边再来执行

31:46.740 --> 31:50.620
走 看到没有 这边的话是不是就是一了

31:51.860 --> 31:57.140
这边是不是就是一了 这边有一个这个undefine undefine是因为我这边

31:57.920 --> 32:03.960
这边他没有返回值 啊 整个这个他是一个函数吗 没有个返回值 所以他这边打印出来是undefine

32:04.640 --> 32:06.080
ok 那现在是不是还是不够

32:06.800 --> 32:11.600
好 还是不够的话 那我就再干嘛呢 再继续return

32:13.680 --> 32:20.640
继续return这个函数 看到没有 直到什么呀 直到他每一次接受参数 然后再推入到这个ax里面

32:20.860 --> 32:26.140
那现在你需要干嘛呢 这做一个判断 对不对ax

32:27.060 --> 32:30.820
点论是如果全等于fn

32:31.900 --> 32:35.140
点论是好 那接下来这边是不是执行这句话

32:37.280 --> 32:42.880
看到没有 让我们一个通用的这个颗粒化函数 我们就写完了 好 我们这边我们可以看一下

32:43.440 --> 32:44.120
比如说我们这里

32:46.160 --> 32:51.520
走 你看这边这边是不是参数不够 参数不够的话 他这边继续返回什么

32:52.080 --> 32:57.240
so carry 我们把每一次 然后这个ax 什么把它打印出来吗 log

32:59.490 --> 33:02.260
ax

33:03.540 --> 33:12.650
ok 你看ax现在是不是一 然后加这边carry 他返回的时候又是个函数 又是个函数 那我是不是可以继续调要

33:13.650 --> 33:17.530
对不对 我就传个二 传个二 然后加进来 他是不是又会接受到这个参数

33:18.330 --> 33:20.610
对不对 接到参数 他又推入到这个ax里面

33:21.450 --> 33:22.450
啊 大家我们这边再来

33:23.570 --> 33:25.530
你看 这次是不是就是有两个了

33:26.150 --> 33:29.670
对不对 一指内推啊 然后接下这边 传个三

33:30.790 --> 33:35.510
走 这边三个对不对 然后再传一个四 再传个四是不是就够了

33:37.310 --> 33:38.150
再传一个四

33:39.110 --> 33:41.910
是不是就够了 看到没有 这边是不是就打印出这个十了

33:42.670 --> 33:48.030
看到没有啊 这就是一个封装的一个通用的颗粒化函数啊

33:48.630 --> 33:52.790
好 这个通用的颗粒化函数 然后接下来我下面的话有这么一些测试

33:53.370 --> 33:58.290
这边有些测试啊 大家可以看一下 这边的话我就直接复制过去啊

34:00.510 --> 34:01.430
直接复制过来

34:07.800 --> 34:14.520
这边测试啊 这个其实就刚才那个只不过少一个参数 是吧 然后你这边可以就是各种各样的用法都可以

34:14.800 --> 34:19.400
反正要保证什么的 最终就是你三个参数是够的 因为你这边是不是接受三个参数

34:20.120 --> 34:26.840
对不对啊 然后加这边测试 测试二的话是传一个这个振折进去啊 也是ok的 那我们这边我们来看一下

34:29.190 --> 34:32.670
看到没有啊 都是ok的啊 你这边可以把这个三了啊

34:33.710 --> 34:38.960
打印出来 这都是ok的

34:39.680 --> 34:44.560
看到没有啊 都是ok的啊 这就是这个封装的这个通用的这个

34:45.200 --> 34:49.960
颗粒化函数啊 你这个的话其实你可以把这个代码加到什么呢 加到你自己的那个

34:50.640 --> 34:54.600
啊 函数库里面 你的工具库里面 大家应该有一个自己的工具库吧

34:55.160 --> 34:58.840
啊 把这个加进去 加进去以后你要进行这个颗粒化的时候

34:59.400 --> 35:04.160
说你直接调这个调这个函数就可以了 对不对 不需要考虑那么多 直接调这个就可以了

35:05.560 --> 35:13.600
好 然后最后最后的话 我们来看一道这个比较经典的这个颗粒化的这个面试题啊

35:15.520 --> 35:23.360
啊 这道面试题是这样子的 你看我这边调用n的方法啊 大家这边一 即是一个参数一 那很明显他返回的是一个什么

35:24.080 --> 35:27.400
是不是个函数 函数 后面是不是才能继续加过

35:28.280 --> 35:33.560
对不对 让家二 二 然后很明显他这边是不是又返回的是一个函数 然后加这边三

35:34.080 --> 35:37.360
啊 然后加等于六啊 其实就是把这个值是不是加起来

35:37.880 --> 35:43.600
好 大家这边是不是也是值加起来 但是这个很有意思的是什么呢 我参数的个数是不固定的

35:44.040 --> 35:49.280
你注意哦 和我们刚才的颗粒化是不一样的哦 我们看刚才的那个颗粒化是不参数是

35:49.680 --> 35:56.440
这个固定的 比如你看我们这边 对不对 比如我对这个函数进行一个颗粒化操作 那这个参数就是不就是三个

35:57.000 --> 36:03.480
对 只要我这边凑购三个是不是就发射 对不对 凑购三个啊 这边出结果执行 对不对

36:04.080 --> 36:09.320
啊 那接下来这边这边是不固定的 你看我这边一二三三个参数一二三四

36:10.040 --> 36:12.160
看到没有 四个参数 然后加一二三四五

36:13.000 --> 36:18.840
看到没有 是不固定的 那这个怎么做呢 啊 这边的话其实还是会使用到颗粒化

36:20.000 --> 36:26.320
啊 肯定会使用到颗粒化 为什么 因为我每次要接受他新的这个参数 对不对啊 每次接受到

36:26.680 --> 36:30.400
好 那这样我们来看一下这道题怎么写 把这条题拿过来

36:33.210 --> 36:38.290
啊 把上面注射掉啊 上面注射掉

36:39.130 --> 36:48.550
好 然后接下来这边一道面试题 一道面试题

36:49.630 --> 36:54.620
把这个拉过来 这个面试题是这个样子的

36:57.360 --> 37:01.720
ok 好 那接下来我们这边我们来写一下 然后这边的话就是function

37:03.000 --> 37:04.640
function and

37:07.320 --> 37:13.760
啊 方形and 好 那首先 首先第一步的话我需要干嘛呢 我需要定义一个数组

37:14.280 --> 37:18.120
来存储所有的参数 因为你看我这边 我第一次可能是不是传一个

37:18.640 --> 37:21.720
那既然也有可能是传什么 是不是传这个多个

37:22.560 --> 37:24.600
对不对 那我首先第一次干嘛呢 我先把这个

37:25.200 --> 37:32.000
他的这个参数 先把它拿到 啊 拿到的话 那就和我们刚才那个是一样的 我们刚才是怎么拿的

37:33.560 --> 37:34.200
啊 是不是这里

37:35.400 --> 37:43.680
or a 然后portal type slice call 那下这边我们只不是从第一个啊 那我们现在的话不需要排除第一个 那接下这边是不是就直接这个样子

37:44.440 --> 37:51.150
ax 这边是不是不需要排除的 把第一个排除

37:52.150 --> 37:55.550
对不对 那就拿到什么呢 拿到所有的参数

37:56.590 --> 38:07.590
就拿到第一次调用啊 第一次调用的所有的参数啊 我们写慢一点 我们一点一点来看啊 那我们这边的话就

38:08.590 --> 38:11.070
老规矩啊 我们这边打印出来 low e

38:14.860 --> 38:18.500
这个ax 大家这边这边也就不注视了

38:19.300 --> 38:20.500
啊 这样子嘛 这样子

38:21.220 --> 38:27.140
and 然后这个第一次是传那个一是吧 好 大家这边第二次是一二三

38:27.940 --> 38:28.980
好 大家这边又是

38:29.980 --> 38:33.100
一啊一样的 好 然后接下来我们这边执行

38:34.020 --> 38:42.820
看到没有 这就把它第一次的这个所有的参数拿到了对不对 拿到之后 然后接下来干嘛呢 接下来返回一个

38:43.260 --> 38:43.820
函数

38:44.540 --> 38:47.900
哎 返回一个函数 那我们这边呢 就是有一个这个方形

38:49.180 --> 38:50.180
方形下滑线

38:51.100 --> 38:59.720
and 这个函数是最终你要返回的 这个

39:01.080 --> 39:07.120
and 那这个函数是干嘛的呢 这个函数就是收集继续收集参数

39:09.720 --> 39:15.990
该函数 该函数会被

39:16.910 --> 39:23.550
返回 该函数的作用是什么呢 继续收集参数

39:25.110 --> 39:27.550
对不对 因为你后面还就是会继续传参数

39:28.350 --> 39:30.350
啊 那既然你继续传到我就继续收集喽

39:31.350 --> 39:33.870
对不对 好 我把这个退下

39:36.880 --> 39:43.840
啊 你这边的话 你这个要继续传参 那我这边就继续收集喽 对不对 好 那我这边怎么办呢 那我这边的话就ax

39:44.840 --> 39:51.340
点这个push 点push 啊 大家这边点点点

39:52.180 --> 39:52.780
arguments

39:55.000 --> 39:58.000
看没有 我就把你新接受的传说 比如你这边第二次

39:58.880 --> 40:02.960
这个传那个二进来 这样我是不是也把它推入到这个ax里面

40:03.480 --> 40:09.880
你这边第二次传那个四过来 我是不是也把它推入到这个ax里面啊 大家这边的话我们打印一下

40:10.720 --> 40:11.120
log

40:12.240 --> 40:12.640
ax

40:13.640 --> 40:17.360
啊 大家这边真的啊 刚才刚才不该那个 不该三的

40:18.400 --> 40:19.880
好 然后接下来这边

40:21.000 --> 40:22.040
呃 第二次

40:23.320 --> 40:29.120
大家这边这个是第二次 是吧 大家这边第二次 好 那这样我们这边我们来看一下

40:36.330 --> 40:45.100
呃 啊 这里 你看 我说就把你第二次的参数

40:45.740 --> 40:50.900
是不是拿进去了 看没有 这边是啊 二二 对不对 但是现在有个问题

40:51.220 --> 40:57.740
我不知道你骑没骑 对不对 你看我这边有可能干嘛呀 是不是传了一二之后 再这样我这边是不是要继续传呀

40:58.380 --> 41:03.100
好 那这样我这边继续干嘛呢 继续return 这个下滑线

41:04.300 --> 41:04.540
啊

41:05.460 --> 41:07.380
andner 继续返回

41:08.340 --> 41:14.020
那继续返回到那他岂不是就是呃无求无尽的吗 那比如说我们这边打印ax

41:17.580 --> 41:22.540
ax 好 我们这边我们来看一下哈 这边 好 大家我这边 再来一个这个3

41:24.620 --> 41:30.340
啊 你看这边这边话是不是就会接受一个这个3 注意 注意这个的话是这 这他会打两次啊

41:31.100 --> 41:33.740
啊 看到没有啊 比如说我这边的话 再来一个

41:34.460 --> 41:39.020
嗯 三四五啊 然后现在这边走 是不是三四五啊

41:40.660 --> 41:47.460
看到没有啊 那这里吗 他就一直 你就可以一直掉 因为我们一直都是干嘛呀 是不是一直都是返回

41:48.460 --> 41:54.060
这个函数啊 这个函数又接收参数 然后这样我要做的事情很简单 我就是把你接收到的新的参数

41:54.420 --> 41:56.020
推入到我的这个ax

41:56.780 --> 41:59.500
里面 啊 那什么时候不接收呢

42:00.220 --> 42:03.900
什么时候不接收呢 好 那我们这边的话 我们就给他定义一个

42:04.380 --> 42:05.220
to stream 方法

42:06.340 --> 42:08.180
看没有 我们这边的话就给这个

42:10.680 --> 42:13.080
定义一个 to stream

42:13.920 --> 42:16.280
to stream 然后等于一个 function

42:17.800 --> 42:22.640
啊 当你调用这个 to stream 方法的时候 让我们这边就知道哦 你的参数已经够了

42:23.640 --> 42:25.040
啊 这边

42:28.020 --> 42:28.340
当

42:31.300 --> 42:34.380
当调用什么呢 to stream 方法的时候

42:37.840 --> 42:38.440
to stream

42:39.400 --> 42:43.280
方法的时候 说明我不要再接收参数了

42:45.990 --> 42:47.790
接收参数了

42:48.390 --> 42:50.870
对不对啊 然后接下来 执行什么呀

42:51.270 --> 42:52.510
执行计算操作

42:53.870 --> 42:58.990
对不对啊 那我这边呢 那我就开始计算呗 那计算就很简单 计算的话就是你这个

42:59.750 --> 43:00.470
啊ax

43:01.470 --> 43:04.790
ax 它是个数组吗 大家我这边可以使用这个reduce

43:06.870 --> 43:10.430
reduce 好 大家这边的话 拿到两项的值

43:10.870 --> 43:14.150
好 然后在这边返回什么 返回a加b

43:14.870 --> 43:19.070
对不对 那最终他会得到一个这个结果 得到这个结果 然后将我这边直接

43:19.630 --> 43:19.990
return

43:21.430 --> 43:27.550
看了没有啊 那回头让我这边的话 我就可以干嘛呀 啊 比如我这边123我已经接收够了 接收够了

43:27.550 --> 43:30.430
我就调什么 就调这个to stream 方法

43:31.270 --> 43:32.510
啊 我们这边我们来看一下好不好说

43:33.550 --> 43:35.830
console.log

43:37.150 --> 43:37.430
啊

43:38.270 --> 43:41.110
那 负责两分 那把这个拿过去

43:45.760 --> 43:47.120
那把这个拿过去

43:50.150 --> 43:52.510
好 然后先让我们这边我们来看一下 走

43:54.470 --> 43:55.430
啊 第一个16

43:56.270 --> 44:02.430
哦 这边没有掉to stream 是吧 你注意你没掉to stream的话 它就会一直返回的是什么 说返回的是

44:03.150 --> 44:05.150
啊 这个下滑线andner

44:05.670 --> 44:12.150
对不对 一直然后又又返回的是一个函数啊 这边的话掉一下 to stream

44:14.810 --> 44:20.490
是不搞定了 对不对 哪怕我这边让我再继续传啊 无所谓啊 无所谓 比我这边继续传

44:21.010 --> 44:24.130
那没关系啊 对吧 啊 加在里面就可以了

44:24.690 --> 44:26.970
看了没有 这个就是啊 这道面试题

44:28.050 --> 44:30.730
啊 这里的话其实就是用到了课理化函数

44:31.570 --> 44:37.410
看了没有啊 这是关于这个整个课理化啊 给大家介绍这么多

44:38.090 --> 44:46.250
啊 下面是关于这个整体啊 什么是课理化 那这个就简单了 是吧 什么是课理化 那你就自己用你自己的语言啊 你稍微组织一下

44:46.690 --> 44:48.370
自己说一下什么是这个课理化

44:49.050 --> 44:55.010
它其实就是什么呀 是把一个多参的函数变成什么啊 是变成单参的函数

44:55.930 --> 45:05.290
对不对啊 把多参的就以前接受多个参数的函数变成什么呢 变成接受一个参数的函数啊 这就是课理化 你自己把那个语言

45:05.810 --> 45:14.770
组织一下 前提是你要先理解啊 你理解了之后你就可以用自己的话 把它说出来啊 这就告就先到这里 拜拜

