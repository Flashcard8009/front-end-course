WEBVTT

00:00.880 --> 00:02.920
大家好 我是谢老师

00:03.180 --> 00:07.020
这期课的话 我们来看一个JS里面经常考的一个点

00:07.280 --> 00:08.820
就是关于作用域

00:09.080 --> 00:10.360
和作用域链

00:10.860 --> 00:12.400
这里的话这道面是提

00:12.660 --> 00:16.500
谈谈你对作用域和作用域链的这个理解

00:17.000 --> 00:20.080
那这里的话他问的是两个问题 一个是作用域

00:20.340 --> 00:21.880
一个是作用域链

00:22.380 --> 00:23.920
那我们一个一个来看

00:24.440 --> 00:26.480
那首先的话是关于这个作用域

00:26.740 --> 00:28.020
那什么是作用域呢

00:28.280 --> 00:30.320
作用域的话这个大家应该是知道的

00:30.540 --> 00:31.340
它是什么呢

00:31.600 --> 00:34.920
作用域是在这个运行时代码中

00:35.180 --> 00:37.480
某些特定部分中变量

00:37.740 --> 00:40.560
函数对象的可访问性

00:40.820 --> 00:42.860
换句话说他决定了这些

00:43.120 --> 00:47.480
就是代码区块中啊这些变量或者资源的可见性

00:47.740 --> 00:50.800
也就是我们的作用域的话你可以把它理解成

00:51.060 --> 00:52.340
这就是一种隔离

00:52.840 --> 00:53.360
对不对

00:53.620 --> 00:56.440
不同的这个作用域啊比如说我的

00:56.700 --> 00:57.700
在函数里面

00:57.960 --> 00:59.760
比如我们举个例子 比如说我这边

00:59.980 --> 01:00.480
方形

01:02.280 --> 01:04.320
那接下来在这里声明一个变量

01:04.580 --> 01:05.340
比较i

01:06.100 --> 01:06.880
等于一个1

01:07.140 --> 01:09.940
OK 好那我这边的话有这么一个这个函数

01:10.200 --> 01:12.260
有这么一个函数然后我这边调用一下

01:12.520 --> 01:16.620
调用的时候然后加这边这个函数是不是就会生成一个函数作用域

01:17.880 --> 01:18.400
对不对

01:18.660 --> 01:20.960
生成这么一个函数作用域之后

01:21.220 --> 01:25.320
然后接下来当我的函数调用完毕之后然后接下来我在外面

01:25.820 --> 01:27.100
我来访问这个i

01:27.360 --> 01:28.380
访问得到吧

01:29.100 --> 01:32.980
说访问不到呀为什么因为你这个i的话是属于

01:33.240 --> 01:34.520
函数作用域的

01:35.040 --> 01:36.820
外面是不可用的

01:37.600 --> 01:38.620
外面是不可用的

01:39.380 --> 01:39.900
明白吧

01:40.160 --> 01:41.700
就好比你加到这个垃圾桶

01:42.460 --> 01:43.220
然后

01:43.480 --> 01:44.500
放在你家里

01:44.760 --> 01:47.060
那其他人就外面的人他是不可以用的

01:47.320 --> 01:48.600
只有你自己能够用

01:49.120 --> 01:49.620
对不对

01:49.880 --> 01:50.660
这就是

01:50.920 --> 01:52.700
作用域一个基本的理解

01:52.960 --> 01:53.460
这边

01:53.980 --> 01:55.000
我们可以这样理解

01:55.260 --> 01:57.820
作用域就是一个独立的地盘

01:58.020 --> 02:00.340
让变量不会外泄

02:00.600 --> 02:01.360
暴露出去

02:01.620 --> 02:03.140
也就是他最大的作用什么呢

02:03.400 --> 02:04.420
就是隔离

02:04.680 --> 02:05.200
变量

02:05.460 --> 02:09.040
不同作用域下同名变量不会有重途

02:09.300 --> 02:10.320
比如说我这边

02:10.840 --> 02:11.840
我在外面

02:12.100 --> 02:13.900
再来声明一个这个i

02:14.160 --> 02:18.000
但我这边不应该用了用哇哈我内特好一些

02:18.260 --> 02:19.520
比如说我这边

02:20.560 --> 02:22.600
使用内特声明一个这个i

02:22.860 --> 02:24.900
然后加这边声明一个这个i这个2

02:25.160 --> 02:26.180
他这边会不会爆出啊

02:26.440 --> 02:27.720
他这边是不是不会爆出啊

02:28.020 --> 02:29.560
对不对啊这边的话

02:29.820 --> 02:32.380
他打印出来的就是哪个呢打印出来的就是这个

02:33.140 --> 02:34.680
看到没有这这个i

02:35.200 --> 02:35.960
和这个i

02:36.220 --> 02:40.580
他是不会重吐的因为他们两个处于不同的这个作用域

02:41.080 --> 02:42.120
啊就好比就是

02:42.360 --> 02:46.200
你家外面的啊就你小区下面的楼下的这个垃圾桶

02:46.460 --> 02:49.020
和你家的这个垃圾桶两个不会重吐

02:49.780 --> 02:51.580
对不对不会重吐啊

02:52.860 --> 02:53.360
好

02:54.140 --> 02:55.420
然后这边

02:56.180 --> 02:57.460
es6之前

02:57.660 --> 03:00.460
这个jS边没有快级作用

03:00.700 --> 03:03.220
只有什么呢只有全局作用域和

03:03.460 --> 03:04.580
韩束作用域

03:04.820 --> 03:07.140
这个我们之前在讲那个内特

03:07.380 --> 03:10.980
就是那个哇内特抗士的区别的时候我们说过啊

03:11.500 --> 03:14.060
然后他还有一个这个e我e我我们单独来说

03:14.560 --> 03:16.100
然后到了es6

03:16.360 --> 03:19.460
es6的到来给我们提供了什么呢给我们提供了这个

03:19.700 --> 03:23.780
快级作用域啊他是通过什么通过这个内特和抗士的

03:24.300 --> 03:25.820
通过这两个这个关键字

03:26.340 --> 03:27.100
是不来实现的

03:27.660 --> 03:31.060
对不对啊这是首先一个这个作用域的一个这个概念

03:31.500 --> 03:37.660
好那接下来我们说了es6之前的话这个作用域分为这个全局作用域和韩束作用域

03:37.900 --> 03:39.700
那我们接下来我们一次来看一下

03:39.940 --> 03:42.100
全局作用域和韩束作用域

03:42.780 --> 03:44.820
那首先的话这个全局作用域

03:45.340 --> 03:47.780
全局作用域的话我们一个一个来看啊

03:48.300 --> 03:51.180
所谓全局作用域指的是在代码中

03:51.420 --> 03:53.020
最任何地方

03:53.740 --> 03:58.660
啊任何地方都能访问到的啊这个对象拥有全局作用域

03:58.900 --> 04:03.020
一般来说以下几种情形拥有全局作用域啊首先第一种

04:03.260 --> 04:08.900
最外层韩束和最外层韩束外面定义的这个变量拥有全局作用域

04:09.140 --> 04:10.180
我们这边我们来看一下

04:11.460 --> 04:15.300
比如我这边我这边是不是挖了一个这个out variable

04:15.820 --> 04:19.380
对不对那这个的话就是在哪里呢这个是不是就是在全局作用域

04:20.100 --> 04:20.660
定义的

04:21.180 --> 04:23.220
对不对然后这边有一个这个function

04:23.740 --> 04:25.540
这里有一个叫做这个out放

04:26.020 --> 04:27.060
的一个这个韩束

04:27.300 --> 04:30.140
那这个out放里面大家这边有一个这个因

04:30.900 --> 04:31.660
这个variable

04:31.920 --> 04:34.740
那这个的话就是属于什么呢这个变量就属于在

04:35.000 --> 04:36.280
韩束作用域里面

04:36.780 --> 04:38.320
啊好让我们这边

04:38.580 --> 04:40.880
console.logout variable

04:41.140 --> 04:41.900
能不能访问得到

04:42.420 --> 04:43.440
是不可以访问得到

04:43.940 --> 04:46.020
对不对完全没问题啊这边打印出来

04:46.480 --> 04:48.280
好然后接下来这边调用out放

04:48.540 --> 04:51.860
调用out放然后接下来的话这边会调这个inner放

04:52.120 --> 04:53.140
这边又有一个韩束

04:53.660 --> 04:54.420
inner放

04:54.680 --> 04:57.500
inner放在这边打印这个inner variable

04:57.760 --> 04:59.020
inner variable然后

04:59.280 --> 05:01.340
在我的这个inner放里面

05:01.600 --> 05:03.640
有没有这个inner variable

05:04.400 --> 05:04.920
有没有

05:05.180 --> 05:05.680
没有

05:05.940 --> 05:08.240
没有它就会到它的外层去找

05:08.500 --> 05:09.000
看到没有

05:09.260 --> 05:11.320
找到这个就是你的这个out放

05:12.080 --> 05:13.880
这个韩束里面是不是有一个这个inner variable

05:14.140 --> 05:15.420
这个in variable

05:16.140 --> 05:18.520
好他就找到这个所以这边的话打印出来什么呢

05:18.780 --> 05:19.560
就是内层

05:20.320 --> 05:22.120
内层变量打印出这个啊

05:22.620 --> 05:24.560
好大家这边console.log

05:24.820 --> 05:25.960
in variable

05:26.720 --> 05:30.820
你这个时候打印这个in variable这个in variable是属于哪个

05:31.080 --> 05:33.380
是不是属于这个out放这个

05:33.640 --> 05:34.660
韩束作用域里面的

05:35.680 --> 05:39.520
对不对属于这个作用域里面的所以你这边的话你在外面你是访问不了的

05:39.780 --> 05:41.260
所以他这边会爆错啊

05:41.520 --> 05:42.600
is not different的

05:43.060 --> 05:45.340
好大家这边的话调用这个inner放

05:45.600 --> 05:48.940
那调用inner放这个inner放是不是也是在这个out放里面

05:49.460 --> 05:50.220
是不定义的

05:50.480 --> 05:52.020
啊当你的这个out放

05:52.540 --> 05:56.380
这个执行完毕之后那里面的所有东西就都释放掉了

05:56.640 --> 05:58.020
说他这边的话就也是

05:58.260 --> 05:59.700
is not different的

06:01.500 --> 06:02.260
好第二个

06:02.780 --> 06:04.820
所有为定义

06:05.080 --> 06:08.420
直接复职的这个变量自动声明为

06:08.660 --> 06:09.700
全局忠于

06:09.940 --> 06:12.500
什么意思呢就比如说我这边的话直接

06:13.060 --> 06:13.860
呃

06:14.120 --> 06:16.120
这边直接给了一个这个variable

06:16.380 --> 06:18.740
variable然后接下来这里直接复职

06:19.000 --> 06:19.780
我说没有声明

06:20.540 --> 06:21.060
对不对

06:21.300 --> 06:25.400
没有声明没有声明来讲我直接复职那这个变量他就会成为一个什么呢

06:25.660 --> 06:27.460
他就会成为一个这个全局的

06:27.960 --> 06:29.740
他就会存在于这个全局

06:30.000 --> 06:32.060
作用域里面我们这边举个例子吗

06:32.820 --> 06:33.340
比如说

06:36.760 --> 06:38.300
比如说我们这边function

06:38.560 --> 06:39.840
啊我们这边写个test

06:41.360 --> 06:44.440
好然后将我这边直接这个i等于个10

06:44.700 --> 06:45.200
看到没有

06:45.460 --> 06:46.500
我这边弄这个i

06:47.260 --> 06:50.840
我是不是没有声明声明没有声明我直接给他复职那这个i

06:52.380 --> 06:53.140
就会

06:56.380 --> 06:57.140
就会

06:57.900 --> 06:58.680
是一个

06:58.940 --> 07:00.220
全局

07:00.720 --> 07:01.240
变量

07:02.000 --> 07:05.340
看到没有啊然后这边我当然我得调稳一下啊

07:05.840 --> 07:07.900
好然后将我在外面我来访问

07:08.420 --> 07:09.420
我来访问这个i

07:09.680 --> 07:10.980
好然后加这边走

07:11.740 --> 07:12.500
拿到没有

07:13.280 --> 07:14.040
这不拿到了

07:14.560 --> 07:15.060
对不对

07:15.260 --> 07:18.080
这里就拿到了啊这边是这个第二个特点

07:19.620 --> 07:20.900
就是没有

07:21.420 --> 07:22.440
就没有声明的

07:22.700 --> 07:24.740
他会直接成为一个这个全局变量

07:25.500 --> 07:26.540
好接下来第三点

07:27.560 --> 07:34.460
所有window对象属性啊拥有全局作用域我们来看一下啊window对象类之属性

07:34.720 --> 07:38.820
拥有全局作用域比如说这个window点namewindow点location

07:39.080 --> 07:40.620
window点top

07:40.880 --> 07:42.660
这些啊这些他就是

07:42.980 --> 07:46.500
也是一个全局变量比如说我们这边我们新建一个

07:49.740 --> 07:51.020
我们这边新建一个

07:53.980 --> 07:57.560
然后这里index.html

07:59.850 --> 08:00.870
把这个先关一下

08:01.390 --> 08:03.430
好然后这里script

08:04.450 --> 08:05.990
你看我这边我直接log

08:06.750 --> 08:08.290
log比如说location

08:09.310 --> 08:10.850
你看这边能不能打印出来

08:13.900 --> 08:14.660
把这边

08:15.180 --> 08:15.680
打开

08:18.030 --> 08:18.790
能够拿到

08:19.310 --> 08:21.870
对不对这个等价于什么呢等价于你这边的话

08:22.070 --> 08:23.350
直接log

08:23.610 --> 08:26.690
window点location

08:26.950 --> 08:27.970
两个是一样的

08:28.230 --> 08:29.510
我们这边刷新一下

08:30.790 --> 08:31.290
看到没有

08:31.550 --> 08:32.570
两个是不是一模一样

08:32.830 --> 08:34.110
所以他这边啊他

08:34.370 --> 08:36.410
就说就是所有window对象的属性

08:36.670 --> 08:37.690
他也是全局的

08:39.990 --> 08:42.550
好然后全局作用域有一个b端

08:42.810 --> 08:43.850
好这边换一行

08:44.350 --> 08:45.890
全局作用域有个b端

08:46.390 --> 08:51.010
就是什么呢他会有一个叫做就是污染全局命名空间

08:51.730 --> 08:53.910
引起什么呢引起这个

08:54.170 --> 08:55.570
变量名的这个冲突

08:56.090 --> 08:57.830
什么意思啊比较举个例子

08:58.090 --> 08:59.410
比如这个是张三写的代码

08:59.670 --> 09:01.970
张三写的代码里面有一个叫做data

09:02.490 --> 09:05.550
data里面然后写了一个这个data对应的是一个对象

09:05.810 --> 09:08.890
好大家理事理事他也有个变量也是data

09:09.390 --> 09:10.170
那既然来

09:10.430 --> 09:14.370
你想把它放在一起的话那这个是不是就会把上面的这个给

09:14.630 --> 09:15.230
覆盖掉

09:16.050 --> 09:19.890
对不对啊所以说为什么的话就是在比如像jQuery啊

09:20.150 --> 09:20.910
或者这个

09:21.130 --> 09:22.010
report

09:22.270 --> 09:27.630
这些库的原码里面所有的代码都是放在一个立即执行函数里面的

09:28.130 --> 09:30.170
为什么他就是不想就是

09:30.430 --> 09:36.570
被受到污染啊因为比如像我jQuery这么大的一个库他里面肯定会定义很多变量啊之类的

09:37.350 --> 09:38.630
那我如果的话

09:38.890 --> 09:42.210
我如果就是正常来写啊比如说我举个例子吗

09:42.970 --> 09:44.770
比如说我们以前引jQuery

09:45.530 --> 09:47.590
引jQuery啊比如说这边的话

09:49.370 --> 09:50.410
我就

09:51.110 --> 09:53.270
直接写啊比如这边引入了这个jQuery

09:53.770 --> 09:54.550
点js

09:54.810 --> 09:59.150
然后这边引入了这个jQuery引入了jQuery我们知道他是不是只会给我们暴露一个什么

09:59.670 --> 10:03.250
是不是只会给我们暴露一个这个jQuery这个对象啊

10:03.770 --> 10:05.550
对不对他会不会有多别的东西

10:06.070 --> 10:10.150
是没有为什么他就是为了不想造成这个全局污染

10:10.410 --> 10:12.990
比如在这个jQuery他写的这个

10:13.250 --> 10:18.610
库的这个原码里面他里面肯定有很多变量啊什么i啊j啊这些肯定会有很多

10:18.870 --> 10:19.890
那他如果

10:20.870 --> 10:22.150
全部放在全局里面

10:22.410 --> 10:27.650
让我们就是自己啊我们用户自己在写的时候让我这边随便写的比如说这边i等于1

10:27.910 --> 10:31.110
那这个是不是就会把他人家写的这个给覆盖掉

10:31.870 --> 10:33.350
对不对全局污染了吗

10:33.610 --> 10:36.750
你这边的话就是会你这边写定义的这个变量就会

10:37.250 --> 10:37.750
覆盖

10:38.270 --> 10:39.810
就是这个原码库里面的

10:40.570 --> 10:43.150
啊说这边的话就是我们尽量不要干嘛呢

10:43.410 --> 10:45.410
尽量不要就是把我们的变量

10:45.690 --> 10:47.750
定义到这个全局作用里面

10:48.210 --> 10:53.170
啊以免引起什么呢引起这个全局命名空间的这个污染啊

10:54.970 --> 10:57.570
好这是关于这个全局作用语

10:58.330 --> 10:59.570
好然后接下来第二个

11:00.330 --> 11:04.850
第二个的话是这个函数作用语啊函数作用语刚其实也提到了

11:05.370 --> 11:05.970
就是什么

11:06.230 --> 11:11.370
这就是你这边调用一个这个函数的时候函数是有一个作用语的啊比我们来看这个代码

11:12.130 --> 11:13.810
这边的话 do something

11:14.270 --> 11:16.070
do something 然后接下来这里

11:16.590 --> 11:19.030
声明了一个变量st u name

11:19.710 --> 11:24.190
那这个变量的话他就指在什么是不指在这个函数里面

11:24.950 --> 11:25.750
可以被访问的

11:26.310 --> 11:31.230
你如果在外面你来访问行不行是不行对不对他这边会爆错啊

11:31.790 --> 11:34.430
然后就在这边调这个inrc inrc

11:35.430 --> 11:38.350
这个inrc是不是也是在这个do something这个函数里面

11:39.110 --> 11:42.070
对吧说他就也会爆错啊函数作用语

11:42.530 --> 11:45.770
好然后我们的作用语是分成的

11:46.170 --> 11:53.250
也就是说内部作用语可以访问外层作用语的变量反之不行啊但这里说是这个外层

11:54.130 --> 12:00.490
其实的话这个说法是不准确的啊这个我们在下面会说我们先这里的话我们先把它理解成外层

12:00.850 --> 12:02.770
好吧我们这边我们来看一下这个例子

12:03.650 --> 12:09.810
这个例子的话首先这边这个副传了一个这个二啊这边接受过来人家这边有个b人家这边的话

12:10.350 --> 12:14.830
嗯调用这个bar调用这个barbar这边说打印输出abc

12:15.430 --> 12:20.070
好那将我们一点一点来理好在bar这个函数啊注意我们只看这

12:21.510 --> 12:21.870
只看这

12:22.710 --> 12:24.230
在bar这个函数里面

12:25.510 --> 12:26.350
有没有变量a

12:27.230 --> 12:33.470
是没有变量b有没有这边也没有 c有没有 c是有 c的话是不是这里传过来的

12:33.910 --> 12:37.390
对吧 c是有的啊ab是没有的ab没有怎么办呢

12:37.970 --> 12:42.170
那b没有的话他就会去从他的这个外层就也就是这个full

12:42.970 --> 12:48.330
full是不是是他的这个外层对不对从这去找去找然后接下来这边是不是就找到谁了

12:49.210 --> 12:54.330
是不是找到这个b了对不对到家a a的话然后这里是不是传进来的

12:54.970 --> 13:02.930
看到没有这里我这个full接受一个参数这个就是我的这个a说最终的话这边abc拿到啊我们这边我们来看一下

13:03.910 --> 13:10.230
啊泡泡一全局作用语标有标识服这个full泡泡二作用语是这个full

13:11.230 --> 13:17.790
是这个full然后接下来有标识服a然后接下来这个bar然后这个b

13:18.270 --> 13:22.710
然后泡泡3泡泡3的话就是这个barbar的话就只有什么是不是只有c

13:23.790 --> 13:30.670
对不对只有c啊就我们最外层最外层的全局作用语他是一个这个full

13:31.530 --> 13:38.170
啊只有一个full然后接下来来到这个full这个作用语这个作用语的话就有什么呢就有这边是不是传过来一个a

13:38.690 --> 13:44.810
然后既然是不是有一个这个bar对不对然后既然还有一个这个b啊那泡泡c就是这个函数

13:45.290 --> 13:54.450
这个bar这个作用语这个作用语就只有一个什么是只有一个c对不对啊虽然我这个只有一个c但是我可以干嘛呢我可以一层一层往外来找

13:55.430 --> 14:12.390
好然后值得注意的是这个快语句啊就是这个快捷作用它不会创建一个新的这个快快捷作用语这个我们在之前是讲过的啊就是最早的时候在es5里面

14:13.110 --> 14:14.470
你是不是不存在快捷作用语

14:15.390 --> 14:20.830
对吧但是这个es6引入了快捷作用语怎么做呢就是通过这个

14:21.570 --> 14:30.370
net和这个const啊那你这边这个大括号是不是会形成一个快捷作用语但是在以前的话你这个大括号里面你这边这个哇

14:30.850 --> 14:31.570
所以是不行的

14:32.570 --> 14:34.330
对不对啊就是这个

14:36.090 --> 14:37.370
好然后

14:38.970 --> 14:48.130
这边下面这个快捷作用语啊这个其实就是刚才所讲的啊就是你如果想声明快捷作用语你可以通过什么呢可以通过这个net和const

14:48.710 --> 14:52.790
来进行一个这个声明啊这个就不多说了啊

14:53.350 --> 14:58.830
那包括这个netconst它是不能重复声明的这个是不是之前也说过的

14:59.510 --> 15:04.430
在那个net就那个哇 netconst内章啊也是说过的

15:05.190 --> 15:12.630
好然后下一个循环中绑定快作用语的这个妙用啊比如说这边举个例子比如说我这边

15:13.450 --> 15:14.730
我们把这个代码我们来看一下

15:16.290 --> 15:16.730
比如这里

15:18.730 --> 15:19.850
这里是不是有三个按钮

15:21.370 --> 15:30.170
对吧有三个按钮好然后有三个按钮之后然后接下来的话我们这边拿到所有的这个按钮我们给他绑定

15:30.810 --> 15:32.330
绑定这个可丽可事件

15:34.950 --> 15:39.470
好我们来看这个代码哈这边的话首先的话就是拿到所有的按钮

15:40.250 --> 15:48.570
对不对拿到之后然后接下来的话便利所有的按钮各自给他绑定一个事件然后打印这是第几个啊这是第2加1个按钮

15:48.930 --> 15:50.810
好那接下来我们这边我们来看一下这段代码

15:52.250 --> 15:54.090
刷新好大家这边

15:55.410 --> 15:59.970
过来点啊点击你会发现这边显示的是这是第四个

16:00.770 --> 16:01.530
这是第四个

16:02.330 --> 16:03.050
这是第四个

16:03.850 --> 16:08.810
你看你会发现所有的显示的都是什么了都是第四个

16:09.930 --> 16:10.490
为什么呢

16:11.010 --> 16:15.090
原因很简单就是因为以前这个你用这个话的形式

16:16.130 --> 16:17.150
来声明的变量

16:17.650 --> 16:19.970
那这种形式他有没有会计作用约

16:20.730 --> 16:22.010
他是没有会计作用约

16:22.530 --> 16:25.850
对不对也就是你最终用的都是什么呀是不同一个爱呀

16:26.890 --> 16:30.210
看到没有最终你这边用到的都是同一个爱

16:31.490 --> 16:36.090
但是你这边的话如果就是想让他不一样怎么办啊你这边就是可以

16:36.550 --> 16:39.870
把这个前面的这个声明从哇改成内置

16:40.650 --> 16:44.750
改成内置之后然后见他是不是就存在这个会计作用约因为这边有大过号

16:45.510 --> 16:49.350
是不是有会计作用约那每一个爱是不是他是不一样的

16:49.870 --> 16:50.390
对不对

16:50.630 --> 16:52.170
好那我们这边让我们来看一下

16:52.670 --> 16:53.910
就在这边我们改成

16:54.170 --> 16:57.290
好然后加这边重新刷新

16:57.790 --> 16:58.310
啊这边

16:58.570 --> 17:00.110
看到没有第1个第2个

17:00.370 --> 17:00.870
第3个

17:01.390 --> 17:02.910
你看这种方式是不是就OK了

17:03.690 --> 17:04.190
看到没有

17:04.490 --> 17:08.490
哎啊这也是一个很典型的案例啊

17:09.770 --> 17:12.090
而这是关于这个作用约啊

17:12.590 --> 17:17.970
我们就是介绍了一下什么是作用约然后全局作用约韩束作用约以及这个会计作用约

17:18.490 --> 17:22.330
啊你到时候你面试的时候你回答你也从这三个点来回答

17:22.850 --> 17:25.890
首先的话比如要问到作用约你首先解释一下什么是作用约

17:26.410 --> 17:31.290
啊然后接下来就解释一下作用约啊有哪些作用约最常见的全局作用约

17:31.730 --> 17:34.090
韩束作用约和这个会计作用约

17:34.390 --> 17:41.650
啊然后每一种作用约他的这个特点有什么挨着挨着把它理出来啊那这个问题就算回答的差不多了

17:42.650 --> 17:46.010
好然后接下来第2个第2个的话是这个作用约链

17:46.930 --> 17:52.850
那在解释这个作用约链之前我们首先要解释一个新的名词叫做自由辩量

17:54.130 --> 17:58.890
什么叫做自由辩量啊其实这个概念很简单我们来看一下啊不要在下面的代码中

17:59.390 --> 18:04.070
console点诺个a要得到什么呢要得到这个a辩量的值

18:04.470 --> 18:06.990
但是你看在这个fn这个韩束里面

18:08.150 --> 18:11.390
fn里面有没有a辩量我有没有声明a辩量

18:12.030 --> 18:17.830
没有没有他是不是就会从这个外层去找对不对找到谁是不是找到这个全局作用约里面的

18:18.670 --> 18:26.150
这个100对不对说最终这里答应出100那这个a就是一个什么呢 a就是一个自由辩量

18:26.930 --> 18:27.690
可不可以啊这边

18:28.450 --> 18:35.610
当前作用约没有定义的辩量他就是一个什么呢就是一个自由辩量

18:36.650 --> 18:38.950
啊好这里的话我们

18:39.710 --> 18:48.690
看到一个现象就是这边的话当我的这个当前作用约里面没有这个辩量啊也就是我要访问一个自由辩量的值的时候

18:49.190 --> 18:50.970
他会顺着外层去找

18:51.750 --> 18:54.810
外层外层如果还没有啊这样就再外层

18:55.530 --> 19:01.430
啊但前提是你还有啊那这个的话就是什么呢这个就是作用约链啊我们这边我们来看一下

19:02.190 --> 19:04.750
而上面的这个例子他是从他的副级

19:05.010 --> 19:10.110
找到了啊那如果副级也没有呢他就会一层一层向上寻找

19:10.370 --> 19:15.230
直到什么呢直到全局作用约都没找到啊他就这个放弃了

19:15.490 --> 19:19.590
那么这个一层一层的这个关系就是什么呢就是作用约链

19:20.550 --> 19:27.790
看到没有也就是说他就像一个链条一样我顺着这个链条一层一层的往外找那最终找到全局

19:28.290 --> 19:32.390
作用约啊找到了那接下来就使用啊没找到的话那就

19:33.150 --> 19:35.710
没有找到的话那你这边的话就是最终是不是就

19:36.230 --> 19:39.050
没有这个辩量对不对不用我们这边举个例子吗

19:41.700 --> 19:42.480
比如说这里

19:46.790 --> 19:48.070
不用我们这边方形

19:48.330 --> 19:48.830
a

19:50.130 --> 19:52.430
方形下面有一个这个方形

19:52.690 --> 19:53.190
b

19:55.290 --> 19:56.310
这个方形

19:56.570 --> 19:57.070
c

19:58.370 --> 19:59.650
好然后现在这边

20:00.150 --> 20:01.430
这边的话要log

20:01.690 --> 20:03.230
log一个这个i

20:03.490 --> 20:05.010
啊然后将我这边调用一下

20:06.030 --> 20:07.330
大家这边调用一下

20:08.610 --> 20:09.890
大家这边调用一下

20:10.650 --> 20:10.910
ok

20:11.410 --> 20:14.230
好那最终的话这边啊这边再声明一下

20:14.490 --> 20:16.270
哇一个i等于个10

20:16.790 --> 20:18.830
好最终这里会打印出多少呢

20:19.090 --> 20:22.170
我们这边我们来看一下啊其实大家心里都有答案啊

20:22.430 --> 20:23.970
这里最终的话会打印出

20:24.170 --> 20:25.210
是不是打印出10

20:25.970 --> 20:26.490
对不对

20:33.480 --> 20:34.260
是不是10

20:34.520 --> 20:36.040
那这个过程我们来理一下

20:36.560 --> 20:41.420
这边的话我要在这个c啊这边当我调用这个c这个函数的时候他这边会

20:41.680 --> 20:44.480
啊这边开启一个这个c这个函数作用预

20:44.740 --> 20:45.780
好大家我这边

20:46.040 --> 20:48.080
我的这个作用预里面有没有

20:49.360 --> 20:49.880
有没有

20:50.140 --> 20:50.880
是没有

20:51.140 --> 20:54.720
没有的话他就会干嘛呢他就会去从这个b

20:54.980 --> 20:56.780
这个函数作用预里面去找

20:57.040 --> 20:57.800
看有没有

20:57.900 --> 20:58.660
还是没有

20:58.920 --> 21:03.020
还是没有人家他就会去从这个a这个函数作用预里面去找

21:03.280 --> 21:07.880
这也没有那最终是干嘛呢最终从这个全局作用预里面去找

21:08.140 --> 21:09.160
啊然后架是吧

21:09.420 --> 21:09.940
找到了

21:10.700 --> 21:12.740
看到没有那是不是就是一层一层

21:13.000 --> 21:14.280
像链条一样

21:14.800 --> 21:16.580
对不对啊这个就是所谓的

21:16.840 --> 21:17.620
作用预链

21:18.120 --> 21:20.680
但是作用预链有一个很重要的指示点

21:20.940 --> 21:22.480
也是很关键的指示点

21:22.980 --> 21:24.780
就是我们这边的话我们刚才说过

21:25.760 --> 21:29.600
这里的话我们说他需要向他的副级作用预去寻找

21:29.860 --> 21:31.140
你看我这边写了个注意

21:31.400 --> 21:33.180
这种说法其实不严谨

21:33.440 --> 21:35.740
啊这种说法是不严谨的为什么

21:36.000 --> 21:37.280
他真的是他的副级吗

21:37.540 --> 21:39.060
啊这边的话不见得

21:39.320 --> 21:40.100
我们来看一下

21:41.880 --> 21:42.900
啊我们来看一下

21:43.920 --> 21:48.540
关于自由辩量的这个值啊上面提到是副作用预中取

21:48.800 --> 21:53.920
啊这种解释其实是会产生奇异的啊因为上面的话只是为了就是好

21:54.120 --> 21:58.120
好讲解所以暂时说的是就是向这个副级作用预去取

21:58.380 --> 21:59.380
其实是什么呢

21:59.640 --> 22:01.540
其实是像就是

22:02.060 --> 22:02.580
呃

22:03.100 --> 22:03.860
这里的话就是

22:04.620 --> 22:05.900
我想想这里该怎么说

22:07.180 --> 22:12.300
就是这里他的上一级作用预是在他创建的时候就这里

22:12.560 --> 22:14.620
创建的时候就决定了

22:14.860 --> 22:15.880
而不是

22:16.140 --> 22:17.180
调用的时候

22:17.940 --> 22:21.260
啊这就是杰斯里面作用预了一个这个特点他是静态的

22:22.020 --> 22:23.820
静态的什么意思啊来看代码

22:24.380 --> 22:29.260
比如我这边挖了一个x是10是吧好然后接下来这边是不是有一个这个fn

22:30.020 --> 22:35.660
好然后接下来我这边有一个这个秀秀的话然后加这边我定义了一个x是20

22:35.900 --> 22:40.260
然后接下来在这个立即执行函数里面我执行这个f

22:40.780 --> 22:42.820
f就是什么f是不是就是这个函数啊

22:43.860 --> 22:44.740
对不对这个函数

22:44.980 --> 22:46.900
好那接下来这边打印出多少呢

22:47.780 --> 22:53.300
啊有同学就是按正常情况来讲他可能会觉得哎这边的话他的上一级是20吗

22:53.800 --> 23:01.600
就应该打印出20吗但是是不对的为什么因为我创建这个函数是在哪里创建的是不是在这个位置创建的

23:02.160 --> 23:04.880
对不对我这个位置是属于什么了是不是调用阶段了

23:05.320 --> 23:07.840
这个位置才是什么是我创建的地方

23:08.360 --> 23:15.280
说创建的地方然后接下来看这边ok是啊ok是要针对这个地方的上一级是不是找到谁啊

23:15.520 --> 23:16.640
是不是找到10啊

23:17.000 --> 23:19.200
所以最终这里打印出的值是10

23:19.880 --> 23:22.320
看到没有啊我们把这段代码运行一下嘛

23:24.950 --> 23:26.070
把这注射掉

23:28.530 --> 23:29.410
我们这边来看一下

23:30.210 --> 23:32.210
看到没有最终是不是10啊

23:32.890 --> 23:36.490
啊你注意他是在创建的时候建立的时候

23:37.090 --> 23:42.250
确定的而不是在你调用的时候反复强调啊这个很重要

23:42.690 --> 23:50.770
你这个面试的时候你一定要把这一点打出来他其实考察就是考察你知不知道这一点啊我这边我还举了一个例子

23:51.330 --> 23:53.250
还举了一个例子我们这边来看一下

23:53.950 --> 24:03.550
呃这边看是的负的等于一个 rice 然后既然这边有一个这个一的这个函数啊这边的话是这个一的负的

24:04.230 --> 24:09.790
好然后接下来的话这里有一个立即执行函数人家这边调用eat eat 是不是是这个

24:10.190 --> 24:11.910
其实和上面的例子是不是是一样的

24:12.590 --> 24:15.470
对不对是这个好在这边最终打印出什么了

24:16.190 --> 24:19.310
他是打印出这个eat noodle吗

24:19.970 --> 24:25.410
啊不会他会打印出什么eat rice 为什么 因为对于这个eat

24:26.090 --> 24:35.210
这个函数来讲他是在这个位置创建的这个位置创建的话然后接下来他的这个负这个负的这个值他往外一层找是不找到这个 rice

24:36.330 --> 24:39.090
对不对 而不是取决于你这个调用阶段

24:39.730 --> 24:44.050
看到没有 那我如果我把这个代码我稍微改一下我怎么改一下呢 我改成这个样子

24:45.030 --> 24:50.910
我把这个就是eat 这个函数的这个创建也放到这个立即执行函数里面

24:51.550 --> 24:59.390
那这个时候他这个负的去找他的上一集是不是就找到这个noodle了 那这边是不是最终打印出就是eat noodle

25:00.390 --> 25:02.430
对不对啊你要注意啊

25:03.190 --> 25:10.230
就是这个点就是我们的这个作用预链他是静态的他的这个曲子是在创建阶段

25:11.010 --> 25:17.090
决定的而不是什么的而不是调用阶段啊一定切记啊

25:18.890 --> 25:26.890
好 最后最后的话说一下关于这个作用预和这个执行上下文这个的话也是就是很多同学容易

25:27.290 --> 25:32.210
搞搞混的一点啊就特别是对于就是刚开始学习的同学啊

25:32.890 --> 25:37.890
就是很容易就会觉得作用预和这个执行上下文是一个东西

25:38.350 --> 25:46.750
而他很多时候他确实是就是很相似很多很多时候都很相似啊所以说很多同学以为就是他是同一个东西但是其实

25:47.190 --> 25:51.150
不是的执行上下文他是什么呢他是动态的

25:52.030 --> 25:55.950
动态决定的他就根据什么根据你的这个调用的方式

25:56.630 --> 26:04.110
来决定这个字但是作用预不一样作用预的话在你创建的阶段他就定下来了一旦定下来他就

26:04.590 --> 26:06.750
不变了啊我们这边我们来看一下

26:07.730 --> 26:14.730
我们知道皆是属于解释性语言啊他分为两个阶段解释和执行阶段两个阶段做的事情不一样

26:15.290 --> 26:17.970
解释阶段要做的是词法分析然后

26:18.690 --> 26:22.210
语法分析作用预规则的确定你看在这个阶段

26:23.210 --> 26:27.250
在这个阶段我们的作用预他所对应的值是不是就已经确定下来了

26:27.770 --> 26:29.370
一旦确定下来他还会不会变

26:30.090 --> 26:30.970
他是不是就不会变了

26:31.670 --> 26:37.670
对不对好那家在执行阶段执行阶段然后家才干嘛呀才开始创建执行上下问

26:38.270 --> 26:45.270
啊人家这边执行代码垃圾回收也说在执行阶段他会根据你这边比如说调用函数的这个方式

26:45.990 --> 26:47.670
来决定这个具体的这个值

26:48.470 --> 26:49.710
是多少啊

26:51.150 --> 26:51.830
就说这个

26:52.670 --> 26:58.470
我们来看一下比如这边执行上下文最明显的就是瑞士的指向他是在执行时确定的

26:58.770 --> 27:05.730
反复强调执行上下文他是这个动态的他是在执行的时候才能确定这个值

27:06.290 --> 27:12.970
其实这个也很好理解就是上下文嘛你想想上下文就我们学语文语文里面是不是会有个上下文

27:13.490 --> 27:21.370
对不对那你不同的词语啊注意不同的词语你放在这个不同的上下文里面他的这个意思是不是不一样的

27:22.170 --> 27:26.970
对不对有些时候你的一个词语他究竟是什么意思你要看他的这个上下文环境

27:27.510 --> 27:32.030
才能够这个决定啊他是一个动态的而作用欲就不一样了

27:32.430 --> 27:36.550
作用欲的话是你在编写代码结构的时候就确定了

27:37.270 --> 27:43.990
所以两者最大的区别就是这个的话是动态的而这个的话是静态的定义的时候就确定了

27:44.710 --> 27:47.390
啊这其实也就是刚才我们这边所讲的

27:48.270 --> 27:50.910
你看这边比如说我这边调用这个f

27:51.890 --> 27:58.530
调用这个f他打印出实而不是二十为什么因为这边根据这个作用欲列他是不是在这个定义的时候

27:59.250 --> 28:02.250
是不是就决定了对不对这个x是取这个位置

28:02.970 --> 28:05.770
啊因为我为什么因为我这个函数是在这个位置创建的

28:06.410 --> 28:09.850
对不对他是静态的就这边这这里有个词静态的

28:10.370 --> 28:14.290
作用欲是静态的而执行上下文是动态的

28:15.170 --> 28:19.490
明白没有啊就就这个区别啊把两者要搞清楚啊

28:21.130 --> 28:25.210
好然后接下来话这个整体的这个解答什么是这个作用欲

28:25.890 --> 28:28.610
那你这个就按照按照这边来解答吗

28:29.130 --> 28:33.730
就是你首先解释一下什么是作用欲啊但是面试的时候不要一句话就完了

28:34.490 --> 28:40.490
你这边的话就是别人问你什么是作用欲那你首先解释了作用欲之后然后向你还顺便说一下这个

28:41.010 --> 28:46.490
作用欲他的这个类型对吧有什么全局作用欲韩式作用欲快捷作用欲

28:46.970 --> 28:50.650
啊全局作用欲的特点是什么韩式作用欲的特点是什么

28:51.330 --> 28:52.890
快捷作用欲的特点是什么

28:53.690 --> 28:59.370
对不对还在说一下就争取就是比如别人问你一个问题你能够说一个两三分钟

28:59.850 --> 29:04.090
而不是说就是你一句话就完了啊这样子的面试效果是最好的

29:04.690 --> 29:11.490
而第二个是作用欲恋那作用欲恋的话那就是你先解释一下就是什么是自由变量

29:12.570 --> 29:15.370
啊他访问自由变量就是通过什么是不通过作用欲恋

29:15.830 --> 29:20.990
然后既然一个很大的特点就是作用欲恋啊就是关于我们的这个作用欲他是静态的

29:21.510 --> 29:24.070
就这里他是静态的这个点一定要达到

29:24.830 --> 29:26.110
啊这个点一定要达到

29:26.630 --> 29:29.710
好吧啊这边所谓静态就是作用欲

29:30.230 --> 29:33.550
中的值一旦被确定永远不会变

29:33.790 --> 29:39.190
啊韩数你可以不被调用但是作用欲中的值你在韩数创建的时候就写入了

29:39.950 --> 29:42.750
啊并且存储在这个作用欲恋对象里面

29:43.270 --> 29:45.070
就是你在创建的时候他就已经确定了

29:45.590 --> 29:46.590
还是静态的

29:47.110 --> 29:47.630
好吧

29:48.150 --> 29:52.750
好这期课就先到这里啊大家下来再看一下啊拜拜

