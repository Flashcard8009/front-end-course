WEBVTT

00:00.690 --> 00:02.730
大家好 我是谢老师

00:03.250 --> 00:07.850
这期课的话 我们来看一下街市中也是一个非常常见的考点

00:08.110 --> 00:10.170
就是关于这个瑞士指向

00:10.930 --> 00:15.790
这里的话有一道经典的整体 他就直接问你这个瑞士的指向

00:16.310 --> 00:17.070
有几种

00:17.330 --> 00:20.150
关于这个瑞士的指向的话 看他怎么考

00:20.410 --> 00:23.470
有些时候他会问你就是瑞士的指向有几种

00:23.730 --> 00:26.550
有些时候他会通过像这样子的代码题

00:27.050 --> 00:29.110
来考察你这个瑞士的指向

00:29.510 --> 00:29.870
好吧

00:30.130 --> 00:31.410
好 那我们一点点来看

00:32.190 --> 00:35.770
瑞士关键字是一个非常重要的这个愚发点

00:36.270 --> 00:40.110
你不理解他的含义的话 大部分开发任务都无法完成

00:40.370 --> 00:41.390
那这个确实是这样

00:41.650 --> 00:44.730
对吧 所以说这个特别是又是街市里面的那个瑞士

00:44.990 --> 00:46.270
非常的灵活

00:47.290 --> 00:50.110
好 那瑞士的话他可以用在构造函数之中

00:50.370 --> 00:51.390
表示实力对象

00:51.890 --> 00:54.450
除此之外他还可以用在别的场合

00:54.970 --> 00:57.270
但是你注意 不管什么场合

00:57.470 --> 00:59.270
瑞士他都有一个共同点

00:59.530 --> 01:01.830
就是他总是反回一个对象

01:02.590 --> 01:05.150
当然这里的话是不考虑那个严格模式

01:05.410 --> 01:07.450
严格模式的话他反回的是undefine

01:07.710 --> 01:09.510
这里没有考虑那个严格模式

01:09.770 --> 01:11.050
好吧 这句话的话我们把它

01:11.310 --> 01:11.810
加出

01:13.610 --> 01:14.110
加出

01:16.960 --> 01:20.040
好 关于这个瑞士的指向的话 有一种这个说法

01:20.300 --> 01:22.080
就是谁调用他

01:22.600 --> 01:24.140
瑞士就指向谁

01:24.400 --> 01:26.180
这个的话其实没有太大问题

01:26.440 --> 01:27.980
但是呢 不够全面

01:28.180 --> 01:29.720
那我们这边的话我们来总结一下

01:29.980 --> 01:32.280
整体来讲的话这个瑞士就是这么

01:32.540 --> 01:33.300
五种情况

01:33.560 --> 01:34.340
我们来看一下

01:34.840 --> 01:36.640
如果你是在函数中调用

01:36.900 --> 01:39.200
不管你是显示调用还是影视调用

01:39.460 --> 01:41.500
只要你是以函数的形式调用

01:42.020 --> 01:45.340
那么严格模式下这个瑞士他反回的是undefine

01:45.600 --> 01:48.160
那非严格模式下他反回的是什么呢

01:48.420 --> 01:49.680
反回的是全局对象

01:50.460 --> 01:51.740
OK 以后我们会有实力

01:52.000 --> 01:52.760
会有实力

01:53.280 --> 01:54.040
好 那下一个

01:54.680 --> 01:58.340
如果就是你是使用这个new 方法调用构造函数

01:58.600 --> 02:00.080
那么这个瑞士指向什么呢

02:00.340 --> 02:02.700
指向就是新创建的对象

02:03.460 --> 02:05.780
就是我们只要用new 方法调用这个构造函数

02:06.020 --> 02:07.300
他是不是会创建一个新的对象

02:08.060 --> 02:08.580
对不对

02:08.840 --> 02:11.140
那这个瑞士就指向新创建的那个对象

02:12.940 --> 02:15.240
一般通过这个call

02:15.500 --> 02:19.080
apply bound的方法如果显示调用函数

02:19.340 --> 02:20.620
函数体内的瑞士

02:20.880 --> 02:23.180
他会被绑定到指定参数的

02:23.640 --> 02:24.360
对象上面

02:24.620 --> 02:26.200
这个我们一会也会有例子

02:26.460 --> 02:29.520
这个其实就是属于这个改变瑞士指向的

02:31.080 --> 02:34.400
然后一般通过上下文对象调用函数

02:34.660 --> 02:36.800
函数体内的这个瑞士

02:37.060 --> 02:39.520
会被绑定到该对象上面

02:39.780 --> 02:40.540
就是

02:40.800 --> 02:42.320
对象调方法

02:42.580 --> 02:45.160
调方法那方法里面的瑞士就是指向这个对象的

02:45.920 --> 02:47.960
最后一个就是这个键头函数

02:48.220 --> 02:50.520
键头函数的话他的瑞士指向

02:50.780 --> 02:53.080
他是由他的这个外层的这个作用域

02:53.640 --> 02:54.280
决定的

02:55.440 --> 02:57.820
好那我们这边的话我们就一点一点来看

02:58.080 --> 03:01.320
好吧首先从第一个全局环境中的瑞士

03:01.580 --> 03:03.620
我们通过这个立体来看一下

03:05.420 --> 03:07.720
好我们这边的话打开这个waste code

03:10.280 --> 03:11.920
把这个文件拖进去

03:18.900 --> 03:19.600
好就这个

03:19.700 --> 03:21.400
好我们把这个中端打开

03:26.810 --> 03:27.770
然后

03:29.370 --> 03:31.170
cd-dex-12

03:32.270 --> 03:33.270
诶诶

03:33.870 --> 03:34.370
what

03:34.870 --> 03:35.970
啊他跑到那边去了

03:37.570 --> 03:38.070
ok

03:42.160 --> 03:44.160
好我们把那个第一个例子怎么来写一下啊

03:44.260 --> 03:45.660
第一个例子这边function

03:45.760 --> 03:47.560
function一个fne

03:52.030 --> 03:53.530
fne

03:54.030 --> 03:56.430
然后这里面干嘛呢这里面很简单

03:56.530 --> 03:57.830
这边的话就log一下

03:58.230 --> 03:58.830
z

03:59.730 --> 04:03.130
好那接下来我这边我调用这个fne

04:03.730 --> 04:04.630
那这个很简单

04:05.530 --> 04:06.530
我这个函数

04:06.930 --> 04:10.430
这个函数是不是就是普普通通通过这个函数的形式来调用的

04:10.930 --> 04:11.430
对不对

04:11.530 --> 04:13.530
那么这个的话瑞士他就指向什么呢

04:13.630 --> 04:15.230
他就指向全局对象

04:17.880 --> 04:23.080
指向全局对象啊你注意只要这个函数

04:24.980 --> 04:28.380
只要这个函数是以什么呢

04:28.580 --> 04:33.080
是以普通函数的形式

04:33.480 --> 04:34.980
被调用

04:35.380 --> 04:37.380
那么他就指向全局对象

04:37.780 --> 04:41.280
啊但是全局对象根据你的这个数组环境

04:41.580 --> 04:42.280
他不一样

04:42.580 --> 04:44.980
如果是浏览器的话他就是window

04:45.380 --> 04:46.580
如果是那个

04:47.780 --> 04:49.780
如果是load的话他就是global

04:50.180 --> 04:52.080
对吧啊我们来运行一下

04:52.580 --> 04:53.180
load

04:54.080 --> 04:54.580
走

04:55.180 --> 04:55.780
看到没有

04:55.880 --> 04:57.880
是不是这个global的下啊

04:58.280 --> 04:58.680
好

04:59.180 --> 05:02.880
然后如果是以这个严格模式调用

05:03.180 --> 05:04.980
那么他就是一个antify

05:05.180 --> 05:06.780
那比如说我们这边再来写一下

05:07.180 --> 05:08.080
有function

05:08.680 --> 05:09.580
fn2

05:11.180 --> 05:12.480
好怎么开启严格模式

05:12.780 --> 05:15.180
我在函数里面是不是可以直接加一个User

05:15.480 --> 05:16.480
这个stract

05:17.480 --> 05:19.280
是不是代表我整个这个函数

05:19.480 --> 05:21.280
内部是不是采用的是严格模式

05:21.980 --> 05:24.280
对吧好然后接下来这边log

05:24.780 --> 05:25.680
log this

05:26.280 --> 05:28.580
好我们这边调用一下fn2

05:29.380 --> 05:32.580
这个仍然是以这个函数的形式调用的

05:33.080 --> 05:34.880
对不对好那接下来我们这边

05:35.980 --> 05:36.580
走

05:37.080 --> 05:39.480
你看是不是打印出来的是antify

05:39.680 --> 05:40.880
把上面那个触实掉

05:42.180 --> 05:42.680
走

05:43.080 --> 05:44.080
说的是antify

05:44.480 --> 05:47.280
看到没有哎也就是说如果是严格模式

05:48.380 --> 05:49.180
如果

05:52.690 --> 05:56.690
如果是严格模式

05:57.490 --> 05:59.590
那么这个z

06:00.590 --> 06:02.790
zz应该不是说他指向了

06:02.790 --> 06:06.790
z的值为antify

06:07.690 --> 06:08.090
ok

06:08.490 --> 06:10.190
这是就是第一个知识点

06:10.690 --> 06:11.490
回到我们这边

06:11.890 --> 06:13.490
就全局环境中的z

06:13.890 --> 06:14.990
非常的简单

06:15.490 --> 06:17.590
好然后要注意这边

06:17.790 --> 06:18.790
我们来看一下这道题

06:19.190 --> 06:21.590
这个的话其实就是上面题目的一种变形

06:21.790 --> 06:22.590
好我们来看一下

06:22.990 --> 06:24.290
我把这边的话注释掉

06:28.440 --> 06:28.840
好

06:31.240 --> 06:33.340
上面介绍了什么呢

06:33.340 --> 06:34.540
介绍了就是

06:35.140 --> 06:36.440
以函数的形式

06:38.240 --> 06:42.440
以函数的形式调用

06:42.640 --> 06:43.440
这个

06:43.940 --> 06:45.240
以函数的形式调用

06:45.240 --> 06:48.240
然后z的指向啊

06:48.240 --> 06:49.240
然后这种题目

06:50.140 --> 06:52.740
这种题目有一种什么呢

06:52.740 --> 06:55.040
有一种变形怎么变形啊

06:55.040 --> 06:55.840
我们来看一下

06:56.440 --> 06:59.440
我这边哇一个这个4

07:01.410 --> 07:02.210
啊我们这边呢

07:02.210 --> 07:03.410
比如说有一个这个bar

07:03.710 --> 07:05.210
对你有个值是10

07:05.410 --> 07:07.610
好大家这边的话有一个这个fn

07:07.810 --> 07:08.910
有一个funk吗

07:10.110 --> 07:11.110
有一个funk

07:11.710 --> 07:13.710
好在这个funk里面我们这边nog

07:14.910 --> 07:15.610
nog什么呢

07:15.610 --> 07:16.810
nog z

07:17.010 --> 07:18.810
以及z叠发

07:19.710 --> 07:22.410
好那我接下来的话我要做件事情

07:22.610 --> 07:23.410
什么事情呢

07:23.610 --> 07:24.810
我这边的话

07:25.110 --> 07:28.110
我忘一个这个比如说fn2

07:28.410 --> 07:30.410
等于一个4

07:31.610 --> 07:34.410
4点这个funk

07:35.210 --> 07:37.110
哎你看我这边做了一件事情我干吗呀

07:37.310 --> 07:39.310
4点funk是不是这个函数啊

07:39.910 --> 07:40.410
对不对

07:40.510 --> 07:43.810
有一种我把这个函数取出来负质给fn2

07:43.810 --> 07:45.210
然后接下来这边

07:45.510 --> 07:46.610
fn2

07:47.810 --> 07:48.410
看到没有

07:48.710 --> 07:49.710
那我这边就干吗呀

07:49.710 --> 07:51.110
是不是调用这个函数

07:51.510 --> 07:53.310
那这个函数就还是干吗的

07:53.710 --> 07:55.310
是不是还是以这个

07:55.810 --> 07:57.910
就是普通函数的形式调用的

07:58.210 --> 07:58.510
对不对

07:58.510 --> 07:59.910
所以这个z的话啊

07:59.910 --> 08:00.910
你不要看到这边的话

08:00.910 --> 08:03.210
他这个z是不是应该是指向这个4这个对象

08:03.210 --> 08:04.310
不是啊

08:04.510 --> 08:06.010
你这边的话这个函数

08:06.310 --> 08:08.810
其实你这里调用24行这边调用

08:08.810 --> 08:09.510
其实

08:10.110 --> 08:11.310
调用的这个函数

08:11.310 --> 08:12.910
就是普通形式的调用

08:12.910 --> 08:14.410
和上面没什么区别

08:14.910 --> 08:16.910
看到没有和你这样子调用没什么区别

08:17.210 --> 08:18.710
你在这里是不是写一个函数

08:18.710 --> 08:20.510
然后在这边说调用对不对

08:20.510 --> 08:22.310
这里的话我把这个函数

08:23.710 --> 08:26.010
取出来负质给fn2

08:26.110 --> 08:29.810
也就是说fn2就是一个单纯的这么一个函数而已

08:30.310 --> 08:32.010
啊所以说你这边调用就是一个

08:32.110 --> 08:34.210
普通的这个函数调用的形式

08:34.410 --> 08:35.910
啊说说我们这边我们来看一下

08:37.310 --> 08:37.710
走

08:38.310 --> 08:38.810
看到没有

08:39.210 --> 08:40.810
z是不是global

08:41.310 --> 08:42.510
然后接下这个bar

08:42.610 --> 08:43.910
bar的话没有没有的话

08:43.910 --> 08:45.310
他这边是不是unlify

08:45.610 --> 08:46.110
对不对

08:46.410 --> 08:48.310
但你如果是这样子调用他就不一样了

08:48.910 --> 08:50.410
比如说你这边的就是这个

08:50.910 --> 08:52.710
4点这个bar

08:54.510 --> 08:55.410
啊不是bar

08:56.910 --> 08:57.310
funk

08:58.210 --> 08:59.110
4点funk

08:59.510 --> 09:01.410
那这边是不是就是以对象的形式

09:01.810 --> 09:03.210
看到没有这个4对象啊

09:03.210 --> 09:05.610
对象的形式都要调用他自己的方法

09:05.710 --> 09:07.910
那这个z就是付这个对象

09:08.110 --> 09:10.410
然后加这个bar就是这个10

09:11.410 --> 09:12.110
好走

09:12.610 --> 09:13.910
看到没有啊

09:13.910 --> 09:14.510
你要注意哈

09:14.510 --> 09:16.710
这个就是上面的一种变形

09:17.910 --> 09:19.110
啊这个是这个

09:20.710 --> 09:22.610
好然后我们来看下一道题

09:24.650 --> 09:27.050
好下一道这里立体3

09:27.250 --> 09:28.850
这个就我们刚讲那个是吧

09:28.850 --> 09:29.850
这里以付

09:30.250 --> 09:32.550
以付这个对象来调这个fn

09:32.650 --> 09:33.550
啊那这边的话

09:33.550 --> 09:35.350
z就是这个付这个对象

09:35.550 --> 09:36.950
z点8就是10

09:37.250 --> 09:38.550
对吧啊这就不说了

09:38.850 --> 09:40.250
啊这就是第一点啊

09:40.250 --> 09:42.950
就是全局环境中的z

09:42.950 --> 09:44.150
总结起来就是什么

09:44.450 --> 09:45.850
是不是指向这个

09:46.250 --> 09:47.050
全局对象

09:47.550 --> 09:48.550
对不对啊

09:48.550 --> 09:50.550
然后如果是严格模式就是unlify

09:52.250 --> 09:53.050
好下一个

09:53.350 --> 09:54.850
上下文对象

09:55.350 --> 09:56.950
调用的这个z

09:57.050 --> 09:57.850
啊这个是什么呢

09:57.850 --> 09:59.250
这个其实我们刚已经看到了

09:59.450 --> 10:00.950
我们这边其实

10:00.950 --> 10:02.950
这边是不是就是一个上下文对象

10:03.650 --> 10:04.250
对不对

10:04.350 --> 10:06.550
好那现在我们这边把这个立体4

10:06.550 --> 10:07.550
啊我们来看一下

10:08.850 --> 10:10.350
好把这边出示了啊

10:14.920 --> 10:16.120
好这边这边的话

10:16.120 --> 10:17.520
然后挖一个

10:19.320 --> 10:20.220
stu

10:20.820 --> 10:22.220
他是一个什么他是个对象

10:22.320 --> 10:24.120
哈对象然后现在他有内幕

10:24.120 --> 10:25.020
内幕比如说

10:25.320 --> 10:25.820
张三

10:26.720 --> 10:28.320
然后他有一个这个方法

10:28.620 --> 10:29.220
fn

10:29.820 --> 10:31.920
好然后加这边log一下

10:32.320 --> 10:33.520
log不是log

10:33.520 --> 10:35.220
这边那就直接return this

10:36.620 --> 10:37.820
return this

10:38.020 --> 10:39.820
ok那这个z是的话

10:40.620 --> 10:41.520
我们刚才说过

10:41.620 --> 10:43.920
你如果比如说通过stu

10:44.420 --> 10:47.420
stu.fn

10:47.620 --> 10:48.720
这种形式调用

10:48.820 --> 10:50.120
调用的话他是不是返回这个z是

10:50.120 --> 10:51.420
那这个z就指向谁

10:51.520 --> 10:53.020
是不是指向这个stu

10:53.720 --> 10:54.220
对不对

10:54.320 --> 10:56.120
好那你这边的话你这边log

10:57.420 --> 10:58.220
log

10:58.920 --> 11:01.320
stu.fn

11:01.920 --> 11:03.020
他返回的这个z是

11:03.020 --> 11:06.520
那一定是全等于这个stu这个对象的

11:06.820 --> 11:08.520
啊你这边可以看一下走

11:08.920 --> 11:09.720
是不是tru

11:10.220 --> 11:11.320
看到没有啊

11:11.320 --> 11:12.620
说这边的话他这个

11:13.020 --> 11:16.620
函数哈这个函数如果以对象方法的形式调用

11:16.720 --> 11:18.520
那么这个z是指向这个对象

11:19.820 --> 11:25.330
如果如果一个函数

11:25.730 --> 11:26.730
是以什么呢

11:26.730 --> 11:31.130
是以对象的方法的形式

11:32.130 --> 11:34.030
的形式被调用

11:35.930 --> 11:39.330
那么z是指向什么呢

11:39.330 --> 11:41.530
指向该对象

11:42.330 --> 11:44.230
啊该对象好

11:44.730 --> 11:46.130
然后下一个

11:47.730 --> 11:49.830
下一个这个是不是是一样的

11:50.430 --> 11:50.730
对不对

11:50.730 --> 11:51.330
我们来看一下吧

11:51.330 --> 11:52.930
这边是st

11:53.030 --> 11:54.330
这道题稍微有点变形

11:54.330 --> 11:55.830
我们这边把这条题看一下

11:57.430 --> 11:58.830
好我把这注射

11:59.630 --> 12:00.830
好我们来看下一道题

12:05.220 --> 12:07.420
这边我们首先把刚才那个对象

12:07.520 --> 12:09.720
把他拉过来

12:11.520 --> 12:14.720
拉过来之后然后接下来他这个fn不是直接写在这的

12:14.820 --> 12:16.020
他有一个嵌套

12:16.120 --> 12:18.520
就比如说这个stu啊Name是张三

12:18.520 --> 12:19.720
他有一个儿子

12:20.720 --> 12:22.720
然后接下来对应的又是一个对象

12:23.020 --> 12:24.720
对象然后接下来这边name

12:25.220 --> 12:26.920
然后这个叫张小三

12:27.920 --> 12:30.220
好然后接下来话这边这个fn

12:30.420 --> 12:31.420
return this

12:32.720 --> 12:33.820
点name

12:34.220 --> 12:36.920
ok好那接下来我们这边log一下

12:37.120 --> 12:39.220
不用log了这边就直接stu

12:39.720 --> 12:41.220
然后点什么呢

12:41.620 --> 12:43.720
点这个上

12:44.320 --> 12:45.920
啊上然后有一个fn

12:47.900 --> 12:50.400
ok那这里的话应该是打印出什么

12:50.800 --> 12:52.000
啊这这里是return是吧

12:52.400 --> 12:53.600
return那就得log

12:56.220 --> 12:56.820
log

12:57.620 --> 12:59.920
ok好这里的话最终打印出什么

13:01.120 --> 13:01.620
看一看

13:02.220 --> 13:03.420
好我们来看一下这个fn

13:03.820 --> 13:06.420
fn的话他前面那个对象是谁

13:07.120 --> 13:10.220
你看他是stu是stu吗

13:10.420 --> 13:13.220
不是是stu点上

13:13.520 --> 13:15.020
也就是说是这个对象

13:16.120 --> 13:18.720
对不对你的fn这个方法

13:18.920 --> 13:21.320
是作为这个对象的一个方法

13:21.620 --> 13:23.520
被调用的说他的z

13:25.020 --> 13:27.820
z的话他就理所应当的指向哪里

13:27.920 --> 13:29.520
是不是指向这个对象

13:30.120 --> 13:33.120
看了没有说这个z点内幕就是这个对象点内幕

13:33.120 --> 13:34.620
所以应该是张小三

13:35.520 --> 13:37.720
而不是张三啊

13:37.920 --> 13:38.920
这边我们来运行一下

13:41.320 --> 13:42.220
这张小三

13:42.620 --> 13:44.520
你要注意这边的话他其实就是

13:45.120 --> 13:48.320
他是哪个对象的作为哪个对象的方法调用的

13:49.620 --> 13:54.020
我们这边的话这个fn是明显是作为这个stu点上

13:54.020 --> 13:54.720
这个对象

13:54.920 --> 13:58.520
点上这个上这个对象的方法来调用的

13:58.920 --> 14:00.420
说他的z就指向什么

14:00.420 --> 14:01.620
就指向这个对象

14:02.420 --> 14:03.120
明白没有啊

14:03.520 --> 14:05.520
啊这边的话注意啊注意

14:06.120 --> 14:08.320
好然后接下来我们下面下一道

14:09.320 --> 14:12.320
好来看一道高阶的题目

14:12.520 --> 14:13.120
好来嘛

14:13.120 --> 14:15.120
我们来把这个高阶的题目我们来看一下

14:15.920 --> 14:17.920
好回到这边把这注释掉

14:23.350 --> 14:27.450
好这里首先哇一个哇一个oe

14:27.850 --> 14:29.150
等于他是一个对象

14:29.150 --> 14:33.150
对象然后里面有这个text的对应的是oe

14:33.750 --> 14:35.450
好完事之后呢有一个方法

14:35.550 --> 14:38.350
fn fn里面然后就return

14:38.550 --> 14:41.450
这个z是点text

14:42.050 --> 14:43.550
ok这是oe这个对象

14:43.950 --> 14:45.450
好然后接下来还有一个什么呢

14:45.450 --> 14:46.950
还有一个o2这个对象

14:48.350 --> 14:50.450
o2的话这边text对应的是o2

14:50.450 --> 14:52.150
但是这边的话返回的是什么呢

14:52.550 --> 14:53.350
这边的话

14:53.850 --> 14:55.550
执行返回的是这个

14:57.150 --> 14:58.250
fn1

14:59.050 --> 15:00.050
不是o1

15:00.450 --> 15:02.750
o1点f

15:03.150 --> 15:04.550
你看这边不一样哦

15:04.950 --> 15:06.450
好然后接下来还有一个什么呢

15:06.550 --> 15:08.050
还有一个o3

15:09.050 --> 15:11.750
o3的话对应也是一个对象

15:11.750 --> 15:14.950
然后加这边text对应的是o3

15:15.450 --> 15:17.150
好然后接下来的话这里

15:18.050 --> 15:19.150
他的这个fn

15:19.850 --> 15:21.850
他的fn的话对应的是什么呢

15:21.950 --> 15:25.150
这里的话首先哇了一个这个fn2

15:25.750 --> 15:29.250
等于一个这个oe点fn

15:29.950 --> 15:31.350
把这个方法复制给他

15:31.450 --> 15:33.450
好然后接下来这边return

15:33.750 --> 15:35.250
returnfn2

15:36.350 --> 15:37.850
ok好最后的话

15:37.850 --> 15:39.850
我这边的我就答应啊

15:40.150 --> 15:40.750
nog

15:41.950 --> 15:42.850
nog什么呢

15:43.250 --> 15:45.850
调用oe点fn

15:46.250 --> 15:47.850
然后o2点fn

15:48.450 --> 15:51.150
以及o3点fn

15:51.750 --> 15:54.650
这里的话你可以自己先把这个视频先暂停了

15:54.950 --> 15:57.150
暂停了然后你自己分析一下

15:58.150 --> 15:59.150
这里值是多少

15:59.950 --> 16:00.650
分析一下

16:01.050 --> 16:03.950
就是第1个是多少第2个是多少第3个是多少

16:04.650 --> 16:06.850
你自己把视频暂停了自己看一看

16:07.050 --> 16:07.550
好吧

16:08.050 --> 16:10.450
好那我这边的话我就接小答案了哈

16:10.450 --> 16:11.950
我假设你已经暂停过了

16:12.450 --> 16:13.050
好走

16:13.650 --> 16:16.350
你看最终出来的只是oe

16:16.950 --> 16:19.550
oe然后以及一个undefine

16:20.350 --> 16:21.650
这边是oe

16:22.150 --> 16:23.950
这里也是oe

16:25.150 --> 16:26.550
这里是undefine

16:27.050 --> 16:29.650
这道题的话其实你应该是能够分析的出来的

16:30.050 --> 16:31.650
对吧这道题其实并补照

16:31.950 --> 16:34.750
我们来看一下首先这边f1 oe

16:34.750 --> 16:37.350
不是这边oe点fn

16:38.650 --> 16:39.750
oe是不是这个对象

16:40.350 --> 16:42.950
对不对然后调用他的这个fn这个方法

16:43.250 --> 16:45.350
那这个fn这个方法是也

16:45.650 --> 16:47.050
哪个对象的方法来调用的

16:47.250 --> 16:49.550
是不是oe的这个对象的方法来调用

16:49.850 --> 16:53.250
那这个r是不是就指向oe这个对象

16:53.850 --> 16:54.350
对不对

16:54.450 --> 16:55.750
所以这边的话打印出什么呢

16:55.850 --> 16:56.750
打印出oe

16:57.450 --> 17:00.050
好o2为什么也打印出oe呢

17:00.250 --> 17:01.850
其实很简单因为你什么呀

17:01.950 --> 17:04.950
因为你这边是不是在调这个oe点fn

17:05.350 --> 17:08.650
oe点fn我们通过上一步我们都知道这个时候反回的是oe

17:09.150 --> 17:11.050
说最终你这边反回的指就是什么

17:11.450 --> 17:12.750
是不是也是oe啊

17:13.550 --> 17:14.050
对不对

17:15.150 --> 17:15.950
好最后一个

17:17.250 --> 17:19.950
最后一个看上去这边稍微变了下

17:20.050 --> 17:21.750
但这个其实我们已经讲过了

17:22.850 --> 17:25.150
我们在最开始的时候讲那个变形的时候

17:25.550 --> 17:27.150
就是以函数的形式调用

17:27.250 --> 17:28.850
变形的时候是不是已经讲过了

17:29.250 --> 17:29.750
对不对

17:29.850 --> 17:33.450
你这边把oe点fn付给fn2

17:34.250 --> 17:35.050
也就是我把什么

17:35.150 --> 17:38.850
我是把这个函数单独抽出来复制给他

17:39.050 --> 17:40.950
然后接下来你这样子调用的话

17:42.050 --> 17:42.850
他就是什么呢

17:42.950 --> 17:45.050
他就相当于是全局调用

17:46.450 --> 17:47.050
这里

17:49.960 --> 17:55.960
这里就相当于是全局调用

17:56.560 --> 17:57.160
看到没有

17:57.260 --> 17:58.660
那既然是全局调用

17:58.660 --> 18:00.560
全局调用有没有这个text

18:01.160 --> 18:01.760
没有吧

18:02.160 --> 18:02.360
对不对

18:02.460 --> 18:03.560
所以我这边就是什么呢

18:03.660 --> 18:05.060
就是undefy

18:06.060 --> 18:07.860
所以说这道题你把它看一下

18:08.060 --> 18:10.060
你面试题有可能就会遇到这种题哦

18:10.660 --> 18:12.160
遇到这种题的话你一定

18:12.660 --> 18:13.460
就是不要慌

18:13.660 --> 18:14.660
你这边就看他什么呢

18:14.760 --> 18:15.560
就是看这个方法

18:15.660 --> 18:17.260
他以什么形式被调用的

18:18.060 --> 18:20.760
他如果是以对象方法的形式被调用

18:20.860 --> 18:21.060
好

18:21.160 --> 18:22.360
r是指向这个对象

18:22.760 --> 18:25.760
如果他是这个普通函数形式调用

18:26.760 --> 18:27.660
这边写错了

18:27.760 --> 18:29.960
就相当于是普通函数

18:30.960 --> 18:33.960
普通函数的形式被调用

18:35.560 --> 18:37.560
如果他是普通函数的形式被调用

18:38.060 --> 18:39.760
那这个r是不就指向全局

18:40.560 --> 18:40.960
看到没有

18:41.560 --> 18:42.960
所以说一定要注意

18:45.860 --> 18:46.760
回到我们这边

18:47.860 --> 18:48.760
好接下来下一个

18:49.260 --> 18:51.060
下一个就是关于这个r

18:51.660 --> 18:53.860
指向这个绑定事件的元素

18:54.060 --> 18:55.860
OK我们把这个我们来看一下

18:58.540 --> 19:01.540
当这个动物元素绑定事件时

19:02.040 --> 19:04.140
事件助理函数里面的这个r

19:04.340 --> 19:05.540
他指向的是什么呢

19:05.640 --> 19:08.140
指向的是绑定r的元素

19:08.140 --> 19:10.840
注意他指向的是绑定r的元素

19:11.340 --> 19:13.840
你一定要注意他和这个target的区别

19:14.140 --> 19:15.540
target他指向的是什么呢

19:15.640 --> 19:17.540
他指向的是触发事件的元素

19:17.940 --> 19:19.340
好比方我这边写了个例子

19:19.340 --> 19:20.740
好我们把这个例子我们来看一下

19:21.540 --> 19:22.840
我这边新建一个

19:25.750 --> 19:28.850
新建一个index.html

19:29.750 --> 19:30.550
我把这个关了

19:35.950 --> 19:38.650
OK好这代码的话我就直接拿过来

19:39.250 --> 19:40.750
这边的话有一个ur

19:42.950 --> 19:43.850
有一个ur

19:44.050 --> 19:45.550
ur下面有很多的例

19:45.750 --> 19:47.350
然后下这个ur是不是有个id

19:48.050 --> 19:50.150
好然后接下这边script

19:52.620 --> 19:56.700
这边拿过来

19:57.500 --> 19:59.200
我们来看一下这段代码做了些什么事

19:59.600 --> 20:02.700
首先的话这边document.getElementById

20:02.700 --> 20:04.700
carnalist是不获取了这个ur

20:05.400 --> 20:06.600
好大家我给怎么样

20:06.600 --> 20:08.200
我给这个ur是不绑定的

20:08.200 --> 20:09.300
这个点击事件

20:09.800 --> 20:11.800
这里是不是就涉及到事件委托

20:12.100 --> 20:13.900
对不对其实这里做了个事件委托

20:14.100 --> 20:16.000
好然后接下来这边分别打印什么

20:16.000 --> 20:20.400
分别打印z target和这个srcElement

20:21.300 --> 20:22.900
这两个其实是一样的

20:23.200 --> 20:26.800
就是这个以前在ie里面叫做srcElement

20:27.000 --> 20:29.300
现在动物标准统一都叫target

20:29.800 --> 20:31.100
好那我们这边我们来看一下

20:32.600 --> 20:33.400
我们打开

20:35.500 --> 20:38.400
好然后把这个控制器打开

20:38.900 --> 20:39.600
好我们来看

20:39.900 --> 20:41.500
当我点击这个立的时候

20:42.800 --> 20:44.500
点击这个立啊

20:44.600 --> 20:46.600
你看这边是不是区别已经出来了

20:47.100 --> 20:48.200
这里的话z

20:49.900 --> 20:51.100
始终反回的是什么

20:51.400 --> 20:53.100
说我绑定事件的元素

20:54.000 --> 20:55.900
对不对我事件绑在哪里的

20:56.000 --> 20:57.500
是绑在ur上面的

20:57.900 --> 20:59.500
所以你这边无论你点哪个

20:59.700 --> 21:01.700
我这边在清空给我点这个rid

21:01.800 --> 21:03.900
你看这边呢反回的都是谁

21:03.900 --> 21:06.000
这是ur但是这个target就不一样

21:06.000 --> 21:07.300
target的话你看这边

21:07.500 --> 21:09.600
所以就是你这个触发事件的元素

21:09.900 --> 21:12.300
对不对就是这个立啊

21:12.500 --> 21:14.500
当我这边的话我如果点击ur

21:15.200 --> 21:17.200
点击ur那三个就是一样的

21:17.300 --> 21:20.100
因为我现在的话我绑定事件的元素也是ur

21:20.300 --> 21:22.400
触发事件的元素是不是也是ur

21:23.000 --> 21:25.100
对不对啊这个要注意

21:26.300 --> 21:27.700
啊这个是这一点

21:30.300 --> 21:33.500
然后下面啊有些时候我们会遇到困扰

21:33.500 --> 21:37.000
这个困扰比如在这个div节点

21:37.100 --> 21:38.800
的这个事件函数内部

21:39.100 --> 21:40.400
啊就事件函数内部

21:40.600 --> 21:42.900
有一个什么有一个这个回调函数

21:43.500 --> 21:44.900
好然后该方法

21:45.100 --> 21:47.800
他被作为普通函数调用时

21:48.100 --> 21:50.800
类似指向全局的这个window

21:51.500 --> 21:52.800
这个是不是我们前面讲过的

21:53.100 --> 21:55.500
对不对你只要你的一个函数

21:55.700 --> 21:59.300
他是作为什么呢作为普通函数被调用

21:59.600 --> 22:01.800
那他的类似一定指向什么

22:01.900 --> 22:03.500
指向这个全局对象

22:04.500 --> 22:05.000
对不对

22:05.200 --> 22:07.700
指向全局对象好那我们这边我们来看一下哈

22:08.100 --> 22:10.100
啊这个例子这个例子我就不写了我们来看一下

22:10.100 --> 22:11.900
这边的话有这么一个div

22:12.200 --> 22:14.100
好大家这边window点id

22:14.100 --> 22:16.300
window给他加了一个属性上去

22:17.400 --> 22:20.100
然后我们给这个div加了一个点击事件

22:20.400 --> 22:24.700
好点击事件里面是不是这边又声明了一个这个函数

22:25.700 --> 22:28.300
看没有我这边相当于又声明了一个函数

22:28.500 --> 22:31.400
声明了一个函数之后然后接下来这边callback

22:31.800 --> 22:34.900
那callback调用这边相当于调用这个函数

22:35.700 --> 22:38.800
相当于就是什么呀是普通函数的调用方式

22:39.900 --> 22:42.400
对不对啊那你这个race就指向什么

22:42.600 --> 22:44.900
指向window说他最终答应出来就是什么呢

22:44.900 --> 22:46.700
答应出来就是这个window

22:47.700 --> 22:49.900
看了没有啊而不是这个id

22:50.400 --> 22:54.000
那怎么办啊那这里的话就是你可以用一个变量

22:54.100 --> 22:56.100
来保存这个race的指向

22:57.100 --> 22:59.000
看了没有你可以保存这个race的指向

22:59.000 --> 23:02.000
提前把它保存一下啊你现在的话

23:02.300 --> 23:03.700
就是这边分进来

23:04.100 --> 23:06.700
当前这个race是不是还指向这个动母节点的

23:07.200 --> 23:09.000
对不对那回头的话你这边

23:09.200 --> 23:11.500
把它保存在这个race这个变量里面

23:11.900 --> 23:13.600
然后接下来这边打印输出的话

23:13.600 --> 23:15.100
那这个race指向的就是什么

23:15.200 --> 23:17.400
是不是就是这个div1这个动母节点

23:18.000 --> 23:20.100
对不对啊这个例子你不信的话

23:20.100 --> 23:22.900
你可以下来写一些啊其实也是前面的知识

23:23.500 --> 23:25.400
啊也是前面的知识就是什么呀

23:25.400 --> 23:26.400
是不是这个函数

23:27.000 --> 23:31.200
调用的时候其实就是以普通函数的形式调用的

23:31.900 --> 23:33.200
是吧OK

23:34.200 --> 23:37.900
啊这就是关于这个race它的集中指向啊

23:38.300 --> 23:40.200
好然后接下来还有一个知识点

23:40.800 --> 23:43.200
什么呢就是我们如何来改变

23:43.800 --> 23:47.300
race的指向啊改变race的指向其实就通过什么呢

23:47.400 --> 23:50.500
通过这个call apply和band

23:51.000 --> 23:54.700
通过这三种方式这个方法可以改变

23:54.900 --> 23:58.100
race的指向啊但我这边还有一个这个箭头函数

23:58.200 --> 24:01.100
箭头函数倒不是说去改变race的指向啊

24:01.300 --> 24:03.300
它的这个race指向是指向外称的

24:03.300 --> 24:05.700
这个我们一会再说啊我们一个一个来看

24:07.100 --> 24:11.700
好首先这里由于gs中race它的指向受到什么

24:11.800 --> 24:14.500
受到这个函数运行怀机的影响

24:15.700 --> 24:18.600
这个指向经常会发生改变对吧

24:18.600 --> 24:19.800
比如说我们刚才这个例子

24:21.300 --> 24:23.100
刚才这个例子就是啊我这边

24:23.100 --> 24:25.200
这个函数的调用方式一变

24:25.400 --> 24:27.900
里面的这个race指向是不是就不一样了

24:28.100 --> 24:29.000
对不对啊

24:29.000 --> 24:31.700
所以说有些时候我们在比如说在做封装

24:31.700 --> 24:33.500
或者写一些复杂函数的时候

24:33.500 --> 24:35.600
我们要把这个race的指向干嘛呢

24:35.700 --> 24:38.900
我们要把它固定啊你要把它固定啊

24:38.900 --> 24:39.600
所以说就是什么呢

24:39.600 --> 24:44.000
就把它绑定死写死以免出现不必要的问题

24:44.500 --> 24:46.600
那如何把它就是绑定好呢

24:46.600 --> 24:48.200
或者说把它固定了啊

24:48.200 --> 24:51.700
你就可以通过call apply和band

24:52.500 --> 24:54.600
通过这三个方法就可以起到

24:54.600 --> 24:56.800
确定race指向的这个作用

24:57.100 --> 24:58.500
好那我们一个一个来看

24:58.500 --> 25:00.300
那首先的话是这个call

25:02.180 --> 25:05.580
call 方法可以指定race的指向

25:05.780 --> 25:08.480
然后再指定作用预周

25:08.480 --> 25:11.480
然后再指定的这个作用预周

25:11.680 --> 25:13.780
执行函数啊什么意思啊

25:13.780 --> 25:14.680
其实很简单

25:15.680 --> 25:16.680
然后来到我们这边

25:17.180 --> 25:18.580
然后把这儿注释掉

25:22.990 --> 25:24.890
好这边是关于这个call

25:25.090 --> 25:27.290
call它怎么呢基本的形式就是A

25:27.790 --> 25:29.090
点这个call

25:29.390 --> 25:30.890
然后接下来这边B

25:32.390 --> 25:32.990
看到没有

25:33.290 --> 25:34.390
好然后接下来这里的话

25:34.390 --> 25:36.590
这个A的话通常是个方法

25:37.190 --> 25:39.790
A通常是一个方法

25:41.090 --> 25:44.290
通常是一个方法

25:46.090 --> 25:47.290
比如说是个函数嘛

25:47.690 --> 25:48.090
对吧

25:48.290 --> 25:48.990
然后B

25:51.000 --> 25:53.900
B通常是一个什么呢

25:53.900 --> 25:55.200
是一个对象

25:55.700 --> 25:57.900
那我这边A点call B

25:57.900 --> 25:58.800
那也就是说

25:59.500 --> 26:01.100
调用A这个方法

26:01.300 --> 26:02.400
调用这个A这个方法

26:02.500 --> 26:04.700
它就存在一个race指向问题

26:05.000 --> 26:05.500
对不对

26:05.500 --> 26:08.100
那race指向那race取谁的race呢

26:08.100 --> 26:09.500
取这个B这个对象

26:09.600 --> 26:11.500
也就race指向B这个对象

26:11.900 --> 26:12.400
看到没有

26:13.000 --> 26:16.000
这里就是调用A方法

26:17.000 --> 26:17.700
A方法

26:17.900 --> 26:22.300
但是race指向这个B

26:22.800 --> 26:23.600
这个对象

26:25.540 --> 26:26.540
看到没有啊

26:26.540 --> 26:29.040
也就是说这边调用A方法

26:29.240 --> 26:32.140
但是race指向是以这个B这个对象

26:32.340 --> 26:35.240
最终这个race指向的是B这个对象

26:35.640 --> 26:37.140
那么这边我们可以来看一下

26:38.540 --> 26:39.140
不要这边

26:40.040 --> 26:41.940
挖一个这个obg

26:43.640 --> 26:45.340
obg等于一个什么呢

26:45.340 --> 26:46.240
等于一个空对象

26:46.640 --> 26:48.140
你看我这边有空对象对吧

26:48.440 --> 26:50.940
挖一个这边就写个方法嘛

26:51.340 --> 26:52.140
对方形

26:52.840 --> 26:54.240
然后f

26:56.150 --> 26:59.050
好然后接下来这边的话就是return this

26:59.550 --> 27:00.050
ok

27:00.450 --> 27:02.450
好我们都知道你这边如果你是

27:02.750 --> 27:03.850
普通形式调用

27:04.250 --> 27:05.350
就这种形式调用

27:05.350 --> 27:06.750
那这个race指向什么

27:07.950 --> 27:09.250
这么指向这个权局啊

27:09.650 --> 27:10.150
对不对

27:10.150 --> 27:11.450
那你这边可以这个样子

27:11.650 --> 27:12.350
nog

27:13.250 --> 27:15.550
这个然后等于等于什么呢

27:15.550 --> 27:16.850
等于这个global

27:18.250 --> 27:18.950
global

27:19.650 --> 27:20.650
那么来看一下

27:25.780 --> 27:26.480
cd

27:30.720 --> 27:31.320
ok

27:32.420 --> 27:32.920
走

27:33.820 --> 27:34.520
什么去啊

27:34.620 --> 27:35.020
对不对

27:35.020 --> 27:36.420
好那我现在要做一件事情

27:36.420 --> 27:37.120
什么事情呢

27:37.220 --> 27:38.620
然后我还是要调这个fn

27:39.320 --> 27:40.420
我要调这个fn

27:40.620 --> 27:42.520
但是呢我这边点call

27:43.120 --> 27:44.220
调call方法

27:44.720 --> 27:46.620
call方法啊相当于打电话吗

27:46.720 --> 27:48.120
你可以把想象上打电话

27:48.420 --> 27:48.720
对不对

27:48.720 --> 27:50.620
call就是呼叫的意思

27:51.020 --> 27:52.420
打电话打电话给谁呢

27:52.420 --> 27:54.220
打电话给这个obg

27:55.420 --> 27:56.020
看到没有

27:56.320 --> 27:57.720
也就是说那个我的race

27:57.720 --> 27:59.620
也就是我race的指向就是指向那里

27:59.620 --> 28:00.920
指向这个obg

28:01.520 --> 28:02.020
对不对

28:02.020 --> 28:04.320
那你最终你这个fn这边return this

28:04.420 --> 28:06.420
那得到了就是什么

28:06.420 --> 28:07.620
这不就是这个obg

28:08.220 --> 28:08.720
看到没有

28:08.720 --> 28:09.920
你这边可以看一下

28:10.320 --> 28:12.120
它是否等价于obg

28:13.020 --> 28:14.320
我们这边log一下

28:17.200 --> 28:17.600
走

28:18.100 --> 28:18.700
看到没有

28:19.000 --> 28:19.900
是不是也是去啊

28:20.500 --> 28:22.000
啊这就是一个这个call

28:22.200 --> 28:24.200
基本的这个用法啊

28:24.500 --> 28:25.400
回到我们这边

28:27.100 --> 28:28.500
呃上面的单码中啊

28:28.500 --> 28:29.400
全局韩

28:29.700 --> 28:32.900
这个全局环境运行这个韩数f的时候

28:33.000 --> 28:35.100
race指向全局环境

28:35.400 --> 28:35.800
对吧

28:36.000 --> 28:37.300
然后你以call的形式

28:37.400 --> 28:39.200
call它可以改变race的指向

28:39.400 --> 28:40.500
race就指向哪里呢

28:40.600 --> 28:43.000
就指向这个指向这个obg了

28:43.800 --> 28:45.400
啊所以说最终你这个race

28:45.700 --> 28:47.500
他指向的是obg

28:49.100 --> 28:51.000
好你把这个再看一下啊

28:51.000 --> 28:52.900
这个很重要的呦

28:53.000 --> 28:53.900
这个很重要的

28:54.300 --> 28:55.300
好那下面

28:56.700 --> 28:59.100
call方法的这个参数啊

28:59.100 --> 29:01.000
应该是这个一个对象

29:01.300 --> 29:02.400
啊应该是个对象

29:02.500 --> 29:04.200
但如果你的这个参数

29:05.200 --> 29:07.800
是空或者闹或者undefine

29:08.000 --> 29:09.000
那默认就是什么呢

29:09.000 --> 29:10.800
默认就是这个全局对象

29:11.000 --> 29:12.900
好那我们这边我们来试两个就可以了啊

29:13.200 --> 29:13.800
比如这边

29:14.900 --> 29:16.700
嗯回到我们这边

29:17.100 --> 29:19.200
好我们这边的话就是log

29:20.400 --> 29:22.200
log然后还是fn

29:22.700 --> 29:24.200
fn.call

29:24.800 --> 29:26.600
啊但是我现在的话我不给他传

29:27.000 --> 29:28.800
啊照理说我们这边是不可以传个对象

29:29.100 --> 29:31.500
传个对象race是不是就指向这个对象啊

29:31.500 --> 29:32.900
但我现在不给他传对象

29:33.200 --> 29:35.200
好就让他是空啊就让他是空的话

29:35.200 --> 29:37.500
那你这个fn相当于就还是

29:37.900 --> 29:40.000
是不是这个一普通还属性是调要

29:40.900 --> 29:43.300
对不对啊那这个race就指向什么呢

29:43.500 --> 29:45.300
指向这个全局对象

29:46.900 --> 29:47.900
下面的情况

29:50.300 --> 29:51.600
下面的情况

29:52.200 --> 29:57.000
race指向全局对象

29:57.300 --> 29:59.700
啊那么这边我们可以来看一下走啊

29:59.700 --> 30:00.900
把上面两个注释掉

30:01.900 --> 30:04.900
啊走看到没有

30:04.900 --> 30:07.300
这全局对象啊或者你这边

30:07.500 --> 30:08.500
传什么呢

30:08.900 --> 30:10.400
传这个no

30:11.100 --> 30:12.800
或者这个undefine

30:13.700 --> 30:16.200
undefine啊这些他都是全局对象

30:16.900 --> 30:18.300
走看到没有啊

30:19.300 --> 30:22.400
啊一个两个三个

30:23.000 --> 30:24.200
对吧OK

30:25.200 --> 30:28.100
啊包括你本身就传一个全局对象进去

30:28.300 --> 30:29.700
那你全局对象也是对象吗

30:29.800 --> 30:32.500
那race是不是就指向你传进去的这个对象

30:33.000 --> 30:34.300
对不对啊总之

30:35.000 --> 30:37.200
嗯这边总结一下吧

30:39.900 --> 30:52.680
总之总之race就指向你传进去的对象

30:53.780 --> 30:57.080
啊传入进去的对象就这么简单啊

30:58.380 --> 30:59.780
好然后回头继续

31:00.780 --> 31:03.180
嗯这个例子这个例子没什么啊

31:03.180 --> 31:05.180
这边这些都是123啊

31:05.180 --> 31:06.580
因为这个是全局对吧

31:06.580 --> 31:09.780
全局这边的话就是相当于全局点N123啊

31:09.780 --> 31:12.780
这个是全局123全局123全局123

31:12.780 --> 31:14.080
好这边是不是obj了

31:14.580 --> 31:16.380
race是不是就应该指向obj

31:16.480 --> 31:18.680
所以说456啊这个没什么

31:20.180 --> 31:23.780
好如果扣传参不是以上类型

31:24.080 --> 31:27.180
则会转化为包装对象啊

31:27.180 --> 31:29.880
但你这边就有个关键词叫做包装对象

31:30.480 --> 31:32.880
你首先得知道什么叫做包装对象啊

31:32.880 --> 31:35.080
你如果不知道的话把那个包装对象

31:35.380 --> 31:37.080
那一小节看一下啊

31:37.080 --> 31:40.380
这个我们专门花了一小节来讲这个包装对象的

31:40.680 --> 31:42.380
包装对象然后有number

31:42.580 --> 31:44.880
有stream 有bully对吧

31:44.980 --> 31:46.180
好那我们这边我们来看一下

31:47.480 --> 31:47.980
这边

31:49.080 --> 31:51.680
有这么一个方法啊也是反回race

31:51.880 --> 31:53.380
好那下这边的话传了个什么

31:53.380 --> 31:54.380
说传了个数字啊

31:54.880 --> 31:56.280
他就会把这个数字

31:56.780 --> 31:58.580
啊转成一个包装对象

31:58.580 --> 32:00.680
那也就是最终race指向的是什么

32:00.780 --> 32:02.880
指向的是5这个包装对象

32:03.580 --> 32:05.280
可不可以啊啊比如我们这边

32:06.480 --> 32:07.780
那试一试啊

32:08.680 --> 32:10.080
啊把这注释掉

32:11.080 --> 32:13.980
呃然后接下来这边fn

32:15.780 --> 32:17.480
啊这边还是log一下

32:19.670 --> 32:23.070
啊然后加这边fn.core啊大家

32:23.670 --> 32:26.470
呃本来的话这边应该传个对象进去

32:26.670 --> 32:28.870
对不对那race就指向你传入了这个对象

32:28.870 --> 32:30.770
好然后接下来我这边传一个什么呢

32:30.770 --> 32:32.870
我传一个布尔兹比如说

32:33.870 --> 32:36.070
那回头的话他就会自动把这个

32:36.570 --> 32:38.170
转成一个包装对象

32:38.370 --> 32:39.570
因为你要一个对象吗

32:39.870 --> 32:40.370
对吧

32:40.670 --> 32:42.470
你要一个对象让我给你传

32:42.470 --> 32:44.070
就是包装对象也是对象

32:44.070 --> 32:46.570
让我给你转成这个包装对象给你传进去

32:46.870 --> 32:48.670
啊所以回头的话他这边这个

32:48.870 --> 32:50.670
race啊我们这方法在执行的时候

32:50.670 --> 32:52.370
这边这个race指向的就是

32:52.370 --> 32:54.070
tru的这个包装对象

32:57.070 --> 32:58.670
走看到没有

32:58.970 --> 33:00.570
是不是就是这个布林tru

33:01.370 --> 33:03.670
看到没有啊啊就是这一点啊

33:03.770 --> 33:06.270
总之这边要一个什么要一个对象

33:06.470 --> 33:08.670
我不管你是全局对象也好啊

33:08.670 --> 33:09.970
还是你传的对象也好

33:10.070 --> 33:12.770
还是你传的是一个这个普通类型也好

33:12.770 --> 33:14.570
你普通类型我给你转成包装对象

33:15.070 --> 33:16.170
对不对啊

33:17.070 --> 33:17.470
好

33:17.870 --> 33:18.670
然后下面

33:19.670 --> 33:22.270
扩还可以接收多个参数

33:22.270 --> 33:24.870
啊第一个参数是race指向的对象

33:25.070 --> 33:27.070
之后的话之后的这个

33:27.070 --> 33:28.470
之后的这些参数

33:28.570 --> 33:30.470
就是你这个函数回调

33:30.870 --> 33:32.370
所需的这个参数啊

33:32.370 --> 33:33.570
那我们这边我们来看一下

33:34.170 --> 33:35.670
有把这个例子我们来写一下

33:40.080 --> 33:41.180
就是扩

33:42.580 --> 33:43.580
第一个参数

33:44.480 --> 33:49.180
是啊race指向的对象

33:49.380 --> 33:51.080
啊然后之后的参数

33:51.980 --> 33:55.080
之后的参数就是什么呢

33:55.280 --> 33:56.980
就是这个参数列表

33:57.580 --> 34:00.080
参数列表这些

34:01.180 --> 34:04.880
参数会传递给谁呢

34:04.880 --> 34:07.880
会传递给就前面的他这个A方法

34:08.280 --> 34:11.280
啊传递给前面

34:12.980 --> 34:14.780
前面的方法

34:16.080 --> 34:18.180
那比如说这边啊我们来举个例子

34:18.780 --> 34:21.180
啊这里的话我们有一个方形

34:22.480 --> 34:24.180
方形然后and

34:25.680 --> 34:28.580
啊不要他接收两个参数A和B

34:29.280 --> 34:30.980
怎么样大家这边哈return

34:31.380 --> 34:33.580
return A加一个B

34:34.480 --> 34:36.880
ok好那接下来话我这边那就

34:37.980 --> 34:40.180
and点扣啊

34:40.580 --> 34:42.580
好然后接下来话这里传

34:42.780 --> 34:45.180
这里其实race倒不是很重要

34:45.580 --> 34:47.680
对吧这个race你指向哪里都可以

34:47.680 --> 34:49.980
我这边主要是什么是不调这个方法

34:50.480 --> 34:52.880
啊调这个方法那你这边的话就可以

34:53.180 --> 34:54.680
啊race吧你可不传

34:54.980 --> 34:57.280
不传他指向这个全局嘛对吧

34:57.280 --> 35:00.380
因为我在这个方法里面是没有用到race

35:01.380 --> 35:03.480
对不对这个方法里面压根就没有用到race

35:03.880 --> 35:06.480
好然后接下来话这边啊你就可以传

35:06.880 --> 35:09.780
传参数比较传一个1传一个2

35:10.680 --> 35:11.980
那最终的话这个就是什么呢

35:11.980 --> 35:13.580
这个得到的值就是3

35:14.580 --> 35:15.680
哎哦没打印

35:17.680 --> 35:18.880
这边nog

35:19.680 --> 35:21.780
好最终得到的值就是3

35:22.680 --> 35:23.980
看到没有啊

35:24.380 --> 35:26.880
也就是说这边主要是给你演示就是扣

35:26.980 --> 35:28.080
除了第一个参数以外

35:28.080 --> 35:29.780
然后后面还可以接受参数的

35:30.280 --> 35:31.480
啊这边多打个分号

35:31.680 --> 35:33.480
这边还可以接受参数了

35:33.480 --> 35:35.080
这些参数就会作为这个

35:35.080 --> 35:37.280
他他不是在调用and这个方法吗

35:37.380 --> 35:39.080
and这个方法这边是不是接受参数啊

35:39.380 --> 35:41.580
对不对他就会作为这个and方法的参数

35:41.680 --> 35:43.180
传递给这个and方法

35:43.680 --> 35:45.380
怎么样怎么样啊就是这个

35:46.380 --> 35:48.980
好然后后面

35:51.750 --> 35:53.850
扣方法的一个应用

35:53.850 --> 35:57.550
就是调用这个对象的原生方法

35:57.650 --> 35:58.750
啊我们把这个例子

35:58.850 --> 36:00.550
把这个例子我们来看一下

36:02.150 --> 36:03.650
好回到我们这边

36:05.650 --> 36:08.150
回到这边啊扣

36:09.450 --> 36:13.950
扣一个经常的应用

36:14.450 --> 36:15.250
就是什么呢

36:15.250 --> 36:19.150
就是调用原生的方法

36:19.550 --> 36:21.050
啊当我这边呢取了个例子

36:21.050 --> 36:21.950
我们来看一下这个例子

36:22.850 --> 36:24.450
到这边哇一个opj

36:25.350 --> 36:26.150
等于一个什么呢

36:26.350 --> 36:27.250
等于一个空对象

36:27.750 --> 36:28.750
好然后接下来

36:28.750 --> 36:30.150
然后我们这边Nog一下

36:31.550 --> 36:34.150
obj 点这个 has

36:34.550 --> 36:35.650
oven property

36:37.150 --> 36:38.250
oven property

36:38.750 --> 36:40.650
这个pouperty

36:41.750 --> 36:43.650
啊pouperty写对秒

36:44.050 --> 36:44.750
对的是吧

36:44.950 --> 36:46.250
好然后接下来传入什么呢

36:46.250 --> 36:47.850
传入这个to stream

36:49.250 --> 36:49.950
传入to stream

36:50.250 --> 36:51.150
好这个时候啊

36:51.150 --> 36:52.150
他就会返回什么呢

36:52.350 --> 36:53.750
他会返回一个force

36:54.150 --> 36:54.750
为什么呢

36:54.850 --> 36:56.850
因为你这个 has oven property

36:56.950 --> 36:58.450
他是看你这个一个对象

36:58.550 --> 37:00.950
他他自身是否有这个to stream

37:00.950 --> 37:02.350
这个方法啊

37:02.550 --> 37:04.350
就是这个 has oven property

37:04.750 --> 37:05.450
这个方法

37:06.750 --> 37:07.850
就该方法

37:12.290 --> 37:14.590
该方法是

37:14.890 --> 37:17.990
查看一个对象

37:18.390 --> 37:23.490
是否有某一个这个属性

37:23.890 --> 37:26.690
或或者方法啊

37:27.990 --> 37:29.490
方法这个方法

37:30.090 --> 37:33.090
这个属性或者方法

37:33.890 --> 37:35.090
必须是什么呢

37:35.090 --> 37:37.990
必须是自身就有的

37:38.490 --> 37:39.590
而不是什么呢

37:39.690 --> 37:41.290
而不是继承而来的

37:42.290 --> 37:45.290
你看我现在我这个对象是不是空的

37:45.690 --> 37:46.390
啥都没有

37:46.790 --> 37:47.090
对不对

37:47.090 --> 37:49.290
他将我看你这个 has oven property

37:49.290 --> 37:50.490
to stream是否有

37:50.590 --> 37:51.690
你啥都没有吗

37:51.790 --> 37:52.190
对吧

37:52.290 --> 37:53.790
那我能不能调to stream呢

37:53.990 --> 37:54.790
我们来看一下

37:55.190 --> 37:56.390
这边比如说我们

37:57.790 --> 37:58.290
log吗

37:59.290 --> 38:02.690
log obj.to stream

38:03.690 --> 38:04.590
t2

38:04.990 --> 38:05.690
能不能调呢

38:05.690 --> 38:06.790
那肯定是可以调的

38:07.690 --> 38:08.190
可不可以啊

38:08.290 --> 38:09.390
这肯定是可以调的

38:09.590 --> 38:11.390
啊就给你转换成一个这个

38:11.890 --> 38:12.290
对不对

38:12.890 --> 38:14.190
啊也就是说通过上面的例子

38:14.190 --> 38:14.790
我们知道

38:17.220 --> 38:17.920
通过

38:19.220 --> 38:22.020
通过上面的例子

38:22.720 --> 38:24.820
我们可以知道

38:26.220 --> 38:27.220
可以知道什么呢

38:27.420 --> 38:28.920
就是这个obj

38:29.720 --> 38:30.720
能够调

38:31.420 --> 38:34.020
能够调用这个to stream

38:35.620 --> 38:38.320
啊但是to stream

38:39.820 --> 38:40.920
这个方法

38:41.520 --> 38:42.820
并不是什么呢

38:42.920 --> 38:45.320
并不是他自身所拥有的

38:46.820 --> 38:49.220
自身所拥有的

38:49.620 --> 38:51.620
那既然他不是他自身所拥有的

38:51.720 --> 38:52.920
他他来自于哪里啊

38:53.220 --> 38:54.920
说来自于他的原型对象上面

38:55.120 --> 38:55.720
对不对

38:56.020 --> 38:57.220
来自于

38:58.020 --> 39:00.220
他的原型

39:00.620 --> 39:01.320
对象

39:01.820 --> 39:02.820
上面啊

39:02.820 --> 39:04.620
但你如果不知道什么是原型对象

39:04.620 --> 39:06.520
你得先去把那个原型对象

39:06.720 --> 39:08.220
先搞清楚啊

39:08.420 --> 39:09.420
所以说你这边

39:10.320 --> 39:12.120
再打印 has own property 的时候

39:12.220 --> 39:13.220
所以这边是什么

39:13.620 --> 39:14.520
就是 false

39:16.020 --> 39:16.620
对不对

39:17.020 --> 39:18.620
好了那接下来的话我这边的话

39:19.820 --> 39:20.820
我做一个事情

39:21.120 --> 39:22.020
做什么事情呢

39:24.310 --> 39:26.910
我把这个 has own property 这个方法

39:27.110 --> 39:28.910
我给你这个覆盖掉

39:29.210 --> 39:30.610
就我这边的obj

39:31.110 --> 39:33.110
点这个 has own property

39:33.510 --> 39:34.610
然后接下来 function

39:36.520 --> 39:37.920
function啊我给你覆盖了

39:38.220 --> 39:39.220
我比较随便随

39:39.520 --> 39:41.120
随便返回点什么啊

39:41.120 --> 39:42.320
返回一个 a

39:42.520 --> 39:43.820
ok 好那完了

39:44.220 --> 39:46.520
那你之后你再调用这个

39:46.820 --> 39:48.020
再调用这个方法的时候

39:48.020 --> 39:49.020
他始终干嘛

39:49.220 --> 39:50.420
是返回的是 a a

39:50.620 --> 39:51.720
对不对用我们这边

39:53.020 --> 39:55.820
再次调用啊覆盖之后再次调用

39:56.920 --> 39:57.320
走

39:57.920 --> 40:00.420
你看就始终返回 a a

40:00.720 --> 40:01.320
对不对

40:02.220 --> 40:04.420
始终返回这个

40:07.500 --> 40:08.500
就上面

40:09.500 --> 40:14.200
上面我们对这个 has own property 这个方法

40:16.000 --> 40:18.600
啊我们对 has own property

40:19.100 --> 40:20.400
这个方法

40:21.200 --> 40:23.500
进行了什么呢进行了覆盖

40:24.200 --> 40:24.600
对不对

40:24.600 --> 40:28.000
所以你这边你调用obj点 has own property

40:28.100 --> 40:29.100
他始终是什么呢

40:29.100 --> 40:30.800
始终返回的是你这边啊

40:30.800 --> 40:32.000
调用的是这个函数

40:32.200 --> 40:33.300
对不对那怎么办呢

40:33.300 --> 40:35.400
如果我现在的话我这个又确实是

40:36.300 --> 40:37.400
不小心被覆盖了

40:37.900 --> 40:38.300
啊

40:38.500 --> 40:39.600
就有这种场景吗

40:40.000 --> 40:42.100
啊我这边确实是被覆盖了

40:42.100 --> 40:45.100
但是呢我又想调我就是以前的这个

40:45.200 --> 40:46.400
has a world property

40:46.500 --> 40:48.400
啊就调以前的这种他是判断

40:48.500 --> 40:50.500
是否就是这个属性或方法

40:50.600 --> 40:51.700
自身是否有的

40:51.700 --> 40:52.600
我想调这个

40:52.700 --> 40:54.500
而不是调你这个被覆盖后的

40:54.600 --> 40:55.300
怎么办呢

40:55.300 --> 40:57.600
好这个时候就可以使用过啊

40:58.200 --> 40:59.700
啊使用扣

41:01.400 --> 41:02.500
使用扣

41:02.900 --> 41:03.600
可以

41:04.100 --> 41:04.900
调用

41:05.300 --> 41:06.600
这个最原色

41:06.700 --> 41:08.300
就是调用原生的方法

41:09.300 --> 41:10.200
原生的方法

41:10.400 --> 41:11.400
啊那这个

41:11.500 --> 41:12.700
has a world property

41:12.700 --> 41:13.900
他是哪上面的呢

41:13.900 --> 41:15.500
他是这个object

41:16.100 --> 41:17.700
点这个portal type上面的

41:18.400 --> 41:20.500
啊这个你学过那个原型那一张

41:20.500 --> 41:21.800
这个你应该是看得懂的

41:22.300 --> 41:23.600
啊这个是不是就是那个

41:23.900 --> 41:25.200
仅次于那个now

41:25.300 --> 41:26.400
下面的那个对象

41:26.800 --> 41:29.000
对不对啊然后接下来哈这边

41:29.400 --> 41:30.800
我就调他的方法

41:31.800 --> 41:34.100
看了没有啊啊我要把这个方法

41:34.100 --> 41:36.100
这个是不是就相当于我们刚才写的那个 a

41:36.400 --> 41:38.300
我刚说吗 a 是不是一般是个方法

41:38.800 --> 41:39.300
对不对

41:39.300 --> 41:42.900
好我把这个方法应用在谁上面呢

41:43.000 --> 41:45.800
应用在obj 上面

41:46.600 --> 41:47.200
看了没有

41:47.300 --> 41:49.300
然后接下来把这边传一个参

41:49.800 --> 41:50.700
to stream

41:52.400 --> 41:52.800
啊

41:53.000 --> 41:54.700
你看是不是就把刚才的这个姿势

41:54.900 --> 41:55.900
全部连起来了

41:56.300 --> 41:57.000
第一个是什么

41:57.000 --> 41:58.200
第一个是你这个

41:58.500 --> 42:01.300
rc 指向的对象啊对象就是这个obj

42:01.400 --> 42:03.200
然后第二个是传了这个参数

42:03.700 --> 42:04.700
对不对好

42:04.700 --> 42:05.900
然后接下来这边走

42:06.900 --> 42:08.100
啊这边要打印哈

42:10.550 --> 42:11.850
这边log

42:13.660 --> 42:14.760
啊这边走

42:15.160 --> 42:16.660
看了没有啊是force

42:17.160 --> 42:19.460
对不对那说明我们这边成功了干嘛呀

42:19.560 --> 42:21.860
是不是成功的调用了原生的方法

42:22.860 --> 42:25.760
啊成功的就调用这个原生的方法

42:25.960 --> 42:28.560
啊一会那个apply你还会看到啊

42:29.660 --> 42:33.860
ok啊这是关于这个call啊关于这个call

42:34.360 --> 42:35.460
好接下来下一个

42:35.960 --> 42:38.460
下一个的话是这个apply

42:38.960 --> 42:41.360
apply和这个call基本上就一模一样

42:41.860 --> 42:42.860
啊只有什么区别呢

42:42.860 --> 42:44.260
就是后面这个区别

42:45.560 --> 42:46.560
就后面的区别

42:46.760 --> 42:48.960
我们call的话后面是接收的是什么

42:49.060 --> 42:50.160
是参数列表

42:51.060 --> 42:52.860
对不对就是一个一个的参数列表

42:52.960 --> 42:55.160
而这个apply他接收的是什么呢

42:55.160 --> 42:57.160
他接收的是一个这个数组

42:58.060 --> 42:59.860
他接收的是一个数组啊

42:59.860 --> 43:01.860
其他的话基本上就一模一样

43:02.160 --> 43:04.060
那我们来看一下这个apply的一个

43:04.360 --> 43:05.560
实际的这个应用

43:06.460 --> 43:09.160
呃实际的应用比如说就是求那个

43:09.560 --> 43:10.860
啊求最大值最小值

43:10.960 --> 43:11.860
比我们来看这个吗

43:14.250 --> 43:15.550
好我们这边写一下啊

43:15.750 --> 43:16.950
啊把这注射掉

43:20.140 --> 43:21.540
啊把这个也注射掉

43:22.540 --> 43:25.540
ok好接下来是关于这个apply

43:26.740 --> 43:29.840
applyapply方法该方法

43:30.840 --> 43:32.440
和什么呢和这个call

43:33.040 --> 43:36.040
基本上一模一样

43:36.640 --> 43:40.040
你注意他基本上和这个call他是一模一样的

43:40.140 --> 43:42.440
啊区别在哪里呢区别

43:42.640 --> 43:44.340
仅仅是什么呢

43:44.340 --> 43:49.440
仅仅是这个就是后面参数的区别

43:50.040 --> 43:53.040
啊call的话他后面是参数列表对吧

43:53.240 --> 43:57.640
call后面是参数列表

43:58.240 --> 43:59.640
而这个apply

44:01.040 --> 44:03.140
apply后面是什么呢

44:03.140 --> 44:04.440
是这个一个数组

44:05.040 --> 44:06.640
一个参数

44:07.540 --> 44:09.040
数组啊

44:09.440 --> 44:10.640
那利用这个apply的话

44:10.640 --> 44:13.240
我们经常就可以比如说调用这个原生方法

44:13.540 --> 44:14.940
比如我们刚说的这个call

44:15.040 --> 44:17.140
call的一个应用是不是就是调用原生方法

44:17.440 --> 44:19.740
对不对那你这个apply和call基本是一样的

44:19.940 --> 44:22.040
啊说经常使用这个apply

44:22.940 --> 44:23.640
apply

44:24.140 --> 44:27.040
就是调用原生方法

44:28.640 --> 44:29.640
比如我们这边举个例子

44:29.640 --> 44:32.440
比如说这边有个数组哇一个ar

44:33.040 --> 44:35.340
等于一个12345

44:35.640 --> 44:38.340
ok好再这样我这边我要干嘛呢

44:38.440 --> 44:39.940
我要找这个最大值

44:41.040 --> 44:43.040
我要找这个数组里面的最大值

44:43.340 --> 44:45.340
那以前的话是不是要自己来写方法

44:46.140 --> 44:48.140
对不对我先便利啊便利

44:48.140 --> 44:50.240
然后假设第一项是最大值

44:50.340 --> 44:53.340
然后接下来找到比我大的我就把值付给他

44:53.640 --> 44:54.840
啊整个便利完了

44:54.840 --> 44:56.440
然后就完了对不对

44:56.540 --> 44:59.440
但其实的话我们这个jess里面

44:59.940 --> 45:01.640
mess他有一个什么呢

45:01.640 --> 45:03.140
有一个这个max方法

45:03.540 --> 45:06.440
看到没有max方法他这边接收这么几个

45:06.740 --> 45:08.340
就是接收一堆数字

45:08.740 --> 45:11.040
好然后接下来的话他就会找出什么呢

45:11.240 --> 45:12.340
找出最大的

45:15.140 --> 45:17.840
他就会找出最大的啊比如我们这边走

45:19.040 --> 45:20.540
是不是这边8对不对

45:20.740 --> 45:22.040
好那这边怎么办呢

45:22.440 --> 45:25.740
让我这边的话我就可以这个样子

45:27.240 --> 45:29.640
我同样是调这个好这边log一下

45:30.040 --> 45:31.540
我同样是调这个max

45:31.540 --> 45:33.540
mess的什么呢max方法

45:34.940 --> 45:37.140
对不对好max方法好

45:37.140 --> 45:39.940
然后接下来的话这边点

45:40.240 --> 45:40.940
apply

45:41.940 --> 45:44.140
看到没有好大家这次指向

45:44.140 --> 45:45.340
这次指向其实无所谓

45:45.340 --> 45:46.540
所以我们这边传一个空

45:46.640 --> 45:48.240
让他指向全局都可以

45:48.340 --> 45:49.340
好然后下第二个参数

45:49.340 --> 45:51.140
第二个参数我是不就可以传入这个

45:51.340 --> 45:52.140
a2

45:53.440 --> 45:55.540
对不对传入这个a2

45:55.740 --> 45:57.340
那这个a2是不是就是这个数组

45:57.340 --> 45:58.340
因为我们apply

45:58.340 --> 46:00.540
他接收的就是一个什么数组

46:00.840 --> 46:02.940
好我们来看一下好不好使走

46:03.640 --> 46:04.340
是不出来了

46:04.840 --> 46:06.040
对不对出来了

46:06.240 --> 46:07.340
啊你看这边

46:07.440 --> 46:08.540
我们使用这个apply

46:08.740 --> 46:10.740
去调用这个原生的方法

46:12.840 --> 46:13.340
好

46:14.640 --> 46:16.240
然后apply其他的啊

46:16.240 --> 46:17.540
你把这个看一下

46:18.140 --> 46:20.040
apply和call作用类似啊

46:20.040 --> 46:21.640
也是改变类似的指向

46:21.840 --> 46:23.040
唯一的区别就是什么呢

46:23.040 --> 46:24.040
他接收的是

46:24.240 --> 46:27.840
数组啊其他的话就没什么好说的

46:28.440 --> 46:29.800
如果你第一个参数是

46:29.800 --> 46:30.940
now或者undefine

46:31.240 --> 46:33.040
他也是指定全局对象

46:33.040 --> 46:34.640
和刚刚那个call是不是一样的

46:35.240 --> 46:35.640
对吧

46:35.640 --> 46:37.440
然后第二个参数是一个数组

46:39.540 --> 46:40.940
好然后这里

46:41.140 --> 46:42.640
啊这里这里注意啊

46:42.740 --> 46:44.040
通过这个ply方法

46:44.140 --> 46:45.540
利用这个ore

46:45.540 --> 46:48.540
构造函数将数组的空元素变成这个

46:48.740 --> 46:49.540
undefine啊

46:49.540 --> 46:50.840
这里是一个实际应用

46:51.340 --> 46:51.840
可不可以啊

46:52.140 --> 46:53.940
这边要把这个a传进去

46:54.140 --> 46:54.640
a是什么

46:54.640 --> 46:55.540
a是这个数组

46:56.340 --> 46:57.840
a是这个数组传进去

46:57.940 --> 46:58.740
好大家这边

46:58.740 --> 47:00.740
他空元素变成这个undefine

47:02.440 --> 47:02.840
好

47:03.140 --> 47:05.540
那其他的话就没什么了

47:06.140 --> 47:06.840
啊其他用啊

47:06.840 --> 47:07.940
这个这个用的特别多

47:08.240 --> 47:08.740
看到没有

47:09.140 --> 47:10.640
使用这个slice方法

47:10.840 --> 47:12.840
将一个类数组对象

47:13.040 --> 47:14.540
转成真正的数组啊

47:14.540 --> 47:15.540
我们把这个看一下嘛

47:17.930 --> 47:19.330
啊当然这里的话前提

47:19.330 --> 47:22.030
首先你得知道这个slice这个方法

47:22.530 --> 47:24.730
这个方法的话是不是做一个这个

47:25.030 --> 47:26.530
数组的这个解决

47:27.030 --> 47:28.130
对不对啊解决

47:28.130 --> 47:29.930
让他会返回一个新的数组啊

47:29.930 --> 47:30.530
比如这边

47:30.730 --> 47:31.630
我们这边来看一下

47:32.030 --> 47:33.430
啊这里slice

47:33.730 --> 47:35.030
slice的话你看一下啊

47:35.530 --> 47:36.530
slice方法

47:36.930 --> 47:37.730
然后

47:38.230 --> 47:39.330
我直接看参数嘛

47:39.730 --> 47:41.230
啊首先他接受两个参数

47:41.230 --> 47:43.030
一个是start一个是end

47:43.330 --> 47:44.330
start代表什么呢

47:44.330 --> 47:46.630
代表你的骑士下标啊

47:46.630 --> 47:49.030
他会包含包含骑士下标end

47:50.030 --> 47:52.130
end的话是这个结束下标

47:52.530 --> 47:53.130
结束下标

47:53.130 --> 47:55.130
然后接下来他不包含这个结束下标

47:55.430 --> 47:56.130
然后你要注意

47:56.130 --> 47:58.230
他是返回一个新数组啊

47:58.230 --> 47:59.830
这里这里slice呢

47:59.830 --> 48:01.430
他会返回一个新数组

48:01.830 --> 48:03.530
可能没有新的数组对象

48:03.630 --> 48:05.030
他不会改变什么呢

48:05.030 --> 48:07.230
不会改变原始数组

48:07.630 --> 48:10.030
ok啊首先你要知道这个slice

48:10.130 --> 48:11.630
他的一个基本用法

48:11.830 --> 48:12.830
好知道之后

48:12.830 --> 48:14.330
然后这样我们回头我们来看一下这边

48:15.430 --> 48:16.430
这边的话

48:16.430 --> 48:17.130
orade

48:17.530 --> 48:19.930
这个portotype点slice

48:20.030 --> 48:20.630
那是不是这边

48:20.630 --> 48:22.630
我就是调用这个slice这个方法

48:23.130 --> 48:24.230
对不对那这个方法

48:24.230 --> 48:25.730
他一定会给我返回一个什么

48:25.830 --> 48:27.530
所以会给我返回一个新数组

48:28.030 --> 48:28.830
对不对然后接下来

48:28.830 --> 48:29.930
我这边传入什么呀

48:30.030 --> 48:33.230
这传入我要转换的这个内数组对象

48:34.430 --> 48:35.030
看没有

48:35.330 --> 48:36.230
转入这边

48:36.330 --> 48:39.130
传入这边这个要转换的内数组对象

48:39.330 --> 48:40.330
啊那下最终

48:40.330 --> 48:43.130
他一定会给我返回一个数组

48:43.330 --> 48:44.830
啊我们这边我们可以测试一下

48:45.930 --> 48:47.130
比如说来到我们这边

48:50.550 --> 48:52.650
好然后接下来这边log

48:54.150 --> 48:55.950
log一个orade

48:56.950 --> 48:58.650
点这个portotype

48:59.050 --> 49:00.450
点这个slice

49:00.850 --> 49:02.350
啊然后加这边apply

49:02.850 --> 49:04.250
把它应用到哪里呢

49:04.350 --> 49:07.150
应用到比如说这边一个内数组

49:07.750 --> 49:10.550
对象啊比如0410

49:10.950 --> 49:11.850
帽号1

49:12.150 --> 49:13.650
然后接下来好这边1

49:14.050 --> 49:15.650
对应的是这个2

49:16.250 --> 49:18.050
啊然后接下来这边2

49:18.250 --> 49:19.450
对应的是3

49:20.850 --> 49:22.650
看没有这个是不是一个内数组对象

49:22.950 --> 49:25.050
好那我们来看一下他能不能转成数组

49:26.450 --> 49:26.950
走

49:27.350 --> 49:28.350
就转成数组了

49:28.650 --> 49:30.350
对不对跟我返回一个空的

49:30.550 --> 49:34.350
数组对象啊让我这边让我如果这边再把那个

49:34.750 --> 49:36.350
再把这个认识属性加上

49:37.650 --> 49:39.250
啊因为我们刚刚没有认识属性

49:39.650 --> 49:41.850
把认识属性加上认识比如说是3

49:42.150 --> 49:43.450
ok走

49:44.350 --> 49:46.850
你看我们的那个argument是不是就长这个样子了

49:47.350 --> 49:50.450
对不对有零就是有具体的这个键值队

49:50.550 --> 49:52.150
那家这边有一个这个认识属性

49:52.450 --> 49:54.450
那家这边是不是123

49:55.150 --> 49:57.850
对不对123啊好

49:58.650 --> 50:01.550
但有的同学可能会很好奇他这边是怎么转的

50:02.050 --> 50:03.150
就是为什么这边

50:03.450 --> 50:07.150
这个我们apply第1个参数是不是就是你这个对象

50:07.550 --> 50:09.650
对不对然后我的瑞士就指向这个对象

50:09.950 --> 50:12.350
啊指向这个对象让我对这个对象应用什么呢

50:12.650 --> 50:16.050
应用这个slice这个方法为什么他就可以转成这个样子

50:16.650 --> 50:18.650
为什么我没有加这个认识

50:18.950 --> 50:22.050
没有加认识他就是空数组加了认识他就是

50:22.250 --> 50:24.650
这个样子啊甚至我这边的话我比如说

50:24.850 --> 50:27.250
我这边123是吧我认识我给他来个5

50:28.150 --> 50:29.050
啊然后走

50:29.450 --> 50:32.050
你看这边是不是123后面是不是有两个空点说

50:32.550 --> 50:34.250
看到没有啊为什么会这个样子

50:34.350 --> 50:37.950
那这个就涉及到就是你要去看这个slice这个方法

50:38.350 --> 50:41.150
他这个本身他是怎么实现的啊

50:41.150 --> 50:43.850
这边的话我们打印一下呢看能不能看得到吗

50:44.350 --> 50:45.150
这边log

50:45.950 --> 50:46.850
alright

50:48.350 --> 50:49.550
点portotype

50:50.050 --> 50:51.250
点slice

50:52.250 --> 50:54.850
走啊这边你看不到啊这边他

50:55.150 --> 50:57.150
就直接打印一个function slice

50:57.450 --> 51:00.850
啊总之这边让你就要去看这个他本身他的这个方法

51:00.850 --> 51:01.950
是怎么实现的

51:02.250 --> 51:04.650
你才知道他为什么会有这样的现象啊

51:06.350 --> 51:08.150
啊这是关于这个slice

51:08.850 --> 51:12.650
好然后接下来最后一个最后一个是这个band

51:13.450 --> 51:15.450
bandband他是干嘛的呢

51:15.550 --> 51:18.250
他是用来绑定这个race啊

51:18.250 --> 51:21.650
把这个race的指向强行的绑定到某个对象上面

51:22.050 --> 51:24.850
然后你注意他和刚才那两个有个区别就是什么呢

51:24.950 --> 51:27.950
他会返回一个新的函数

51:28.850 --> 51:31.750
可不可以啊他会返回一个新的函数啊

51:31.750 --> 51:33.150
比如说我们这边我们举个例子

51:34.750 --> 51:35.950
啊来到这边

51:38.440 --> 51:39.340
啊band

51:41.600 --> 51:42.400
band

51:42.700 --> 51:44.300
啊绑定race指向

51:45.600 --> 51:48.500
绑定race指向啊

51:48.500 --> 51:53.000
然后返回一个新的函数

51:53.800 --> 51:56.600
ok 那返回了这个新的函数他的race就是确定的

51:57.200 --> 51:58.600
啊他的race就是确定的

51:58.800 --> 52:00.200
啊比如我们这边我们举个例子

52:01.100 --> 52:03.100
比如这边哇一个这个d

52:04.300 --> 52:05.100
等于一个

52:06.200 --> 52:08.900
啊我们就举了那个客舰里面的那个啊

52:09.200 --> 52:10.200
比如这边dead

52:10.500 --> 52:12.300
啊这边呢是不是一个这个dead对象

52:12.500 --> 52:14.700
你这边你可以打印nog d

52:17.000 --> 52:17.800
啊拿过来的

52:19.900 --> 52:20.600
啊走

52:21.300 --> 52:23.100
看到没有是不是他是一个这个dead对象

52:23.200 --> 52:25.700
好dead对象然后接下来的话你这边可以干嘛呢

52:25.700 --> 52:27.400
你这边可以调方法

52:27.600 --> 52:29.400
有get time

52:30.600 --> 52:32.500
对不对啊然后就在这边走

52:33.000 --> 52:34.400
啊这边要打印一下

52:36.100 --> 52:41.810
nog走看到没有是不是出来了时间说对不对

52:41.910 --> 52:43.710
好那我现在我做一件事情

52:44.010 --> 52:46.810
我做什么事情呢我这边的话把这个d

52:47.710 --> 52:49.310
啊其实就是我们刚才做过的事情

52:49.610 --> 52:52.010
fn等于一个d.get time

52:52.010 --> 52:53.810
因为我们知道get time它是一个方法吗

52:54.010 --> 52:55.010
是一个函数吗

52:55.210 --> 52:57.410
对不对然后我把这个函数给这个fn

52:57.510 --> 52:59.510
然后接下来我调用这个fn

53:01.010 --> 53:02.910
那这这里的话就必然会干嘛呢

53:03.310 --> 53:05.210
你看这边必然会爆错

53:05.910 --> 53:09.010
为什么因为你这边的话把这个方法

53:09.010 --> 53:10.810
或者说这个函数给了fn

53:11.110 --> 53:15.110
那调用fn相当于是以普通函数的形式

53:15.410 --> 53:17.610
调用的那r是指向什么呀

53:17.810 --> 53:20.210
r是不是指向这个全局的

53:20.610 --> 53:23.610
这个对象对不对他就不像在这里啊

53:23.610 --> 53:25.310
你这里在调用这个get time的时候

53:25.410 --> 53:27.110
他的r是指向这个d

53:27.210 --> 53:29.010
这个对象也就是这个d.get对象

53:29.710 --> 53:30.910
明白没有啊

53:31.710 --> 53:32.310
就这边

53:33.210 --> 53:35.010
啊上面的调用方式

53:36.950 --> 53:40.050
上面的调用方式

53:41.050 --> 53:41.950
死的

53:43.250 --> 53:44.950
死的什么呢死的r

53:45.250 --> 53:48.550
指向了全局对象

53:50.810 --> 53:51.910
全局对象

53:52.210 --> 53:53.510
r非什么呢

53:53.610 --> 53:55.610
r非这个d.get对象

53:56.810 --> 53:59.110
d.get实力对象对不对

53:59.110 --> 54:01.010
就这么简单所以说他爆错了

54:01.010 --> 54:02.710
啊那我现在怎么办呢

54:02.710 --> 54:04.510
我现在就可以强行绑定

54:04.810 --> 54:05.910
啊比如说我这边

54:07.010 --> 54:08.210
我把这注释掉哈

54:08.610 --> 54:10.210
好下面

54:11.310 --> 54:13.110
使用这个bund

54:13.910 --> 54:17.510
来绑定啊怎么绑我们这样子

54:18.310 --> 54:22.910
好这边的话d.d.get time

54:23.110 --> 54:24.710
啊这个是不是你的那个

54:24.910 --> 54:26.410
还说对不对

54:26.410 --> 54:27.610
就是你的那个方法啊

54:27.610 --> 54:29.410
你的这个r是现在是指向什么

54:29.410 --> 54:30.610
是不是指向这个d的

54:31.010 --> 54:32.110
对不对d这个对象

54:32.210 --> 54:34.910
好然后接下来我这边点bund

54:36.410 --> 54:38.410
点bund绑定绑定

54:38.410 --> 54:41.110
然后传入你要绑定的这个r

54:41.310 --> 54:42.910
啊这个r是要指向哪个对象

54:42.910 --> 54:44.310
你把这个对象给我啊

54:44.310 --> 54:46.110
以后我r我就指向这个对象了

54:46.210 --> 54:47.510
我要求指向哪里的

54:47.510 --> 54:48.610
我就指向d

54:49.110 --> 54:49.710
可不可以啊

54:49.910 --> 54:51.710
那家整体他会返回一个什么

54:51.810 --> 54:53.210
说会给你返回一个函数啊

54:53.510 --> 54:55.110
对不对那我们这边仍然是

54:56.110 --> 54:58.110
这边啊接受一下

54:58.110 --> 55:00.110
好然后接下来你这边调用f

55:00.510 --> 55:02.110
你调用fnfn是什么

55:02.110 --> 55:04.710
是不是他这个bund的返回的这个函数

55:05.110 --> 55:06.810
bund返回的这个函数

55:06.810 --> 55:09.110
他的r始终指向什么

55:09.310 --> 55:11.410
是不是你这边跟我传过来的这个对象

55:11.810 --> 55:13.610
对不对相当于我就绑死了

55:13.910 --> 55:16.010
啊绑死了你这边要求我绑定这个是吧

55:16.010 --> 55:18.310
好让我以后r就都指向他

55:18.510 --> 55:20.610
说我这边的话即使我这样子调用

55:20.910 --> 55:22.110
啊我们这边我们来看一下

55:23.980 --> 55:24.480
走

55:25.480 --> 55:26.080
没答应

55:26.680 --> 55:27.880
好我们这边打印一下

55:28.680 --> 55:29.280
log

55:30.780 --> 55:32.480
好走你看

55:32.780 --> 55:34.280
是不是仍然是ok的

55:35.080 --> 55:35.680
看到没有

55:35.980 --> 55:39.280
仍然是ok的啊你看这个就是这个关于这个bund

55:39.580 --> 55:42.280
一个这个快速入门势力啊

55:42.780 --> 55:44.780
好那我们这边继续往后面看

55:46.380 --> 55:50.880
嗯bund接收的这个参数就是要绑定了这个对象

55:51.180 --> 55:52.580
啊这个我们关是不是已经看了

55:52.880 --> 55:54.680
对我们把这个例子也看一下嘛

55:55.680 --> 55:58.080
来到这边啊把那个例子也看一下

56:01.760 --> 56:03.860
啊bund4d2

56:07.210 --> 56:10.010
ok好这边的话首先有一个对象

56:10.410 --> 56:12.410
挖了一个这个controller

56:12.610 --> 56:13.810
他是一个对象

56:14.210 --> 56:17.610
啊这个对象里面啊抗扯对应的是0

56:18.210 --> 56:20.010
然后接下来话有一个这个

56:21.010 --> 56:21.810
and 方法

56:23.210 --> 56:26.010
好and 方法然后接下来这边就是z

56:26.310 --> 56:27.410
点这个抗扯

56:27.810 --> 56:30.410
加加啊很简单的一段代码对吧

56:30.410 --> 56:32.510
一个对象里面有一个属性有一个方法

56:32.610 --> 56:34.610
方法就是让这个属性支撑

56:34.910 --> 56:36.910
好然后接下来的话我这边

56:38.710 --> 56:39.410
controller

56:40.510 --> 56:42.210
点and啊

56:42.210 --> 56:44.310
然后如果我把这个方法直接干嘛呢

56:44.310 --> 56:47.010
直接给这个比如说我这边有个f

56:47.610 --> 56:49.110
啊这个我们大家都知道是吧

56:49.110 --> 56:50.910
这边你如果直接调的话

56:51.110 --> 56:54.310
相当于就是把这个函数以普通形式来调用

56:54.810 --> 56:57.310
那以普通形式来调用他这边Z是指向什么

56:57.510 --> 56:58.410
是全局对象

56:58.510 --> 57:01.310
全局对象没有这个那你这边加加他必然会什么

57:01.510 --> 57:02.310
是爆错呀

57:03.310 --> 57:04.710
哦这边没有打印

57:05.310 --> 57:05.910
log

57:08.010 --> 57:09.910
哦他这边好像还没爆错他这边

57:10.210 --> 57:11.710
相当于是undefy 加加了

57:12.010 --> 57:14.310
对不对你这边的话他是undefy undefy 加加

57:15.010 --> 57:16.010
那这边怎么办呢

57:16.110 --> 57:17.410
这边呢你就可以直接

57:17.610 --> 57:18.110
bund

57:18.710 --> 57:20.810
我来绑定这个z的指向

57:21.610 --> 57:22.610
z指向哪里呢

57:22.610 --> 57:24.110
就指向controller

57:24.310 --> 57:25.010
这个对象

57:25.410 --> 57:25.910
ok

57:26.110 --> 57:27.510
好那接下反回这个函数

57:27.710 --> 57:28.910
那接下来你这边在调用的话

57:28.910 --> 57:30.910
那这个z始终指向哪里

57:31.110 --> 57:32.410
是指向这个controller

57:32.510 --> 57:33.910
其实和刚才那个例子是

57:34.110 --> 57:34.810
是不一样的

57:36.110 --> 57:38.710
我看一下controller.bund fn

57:39.410 --> 57:40.910
然后调用

57:42.110 --> 57:43.910
调用这里啊我看一下

57:45.310 --> 57:47.410
这里这里写错了这里的话他是

57:48.610 --> 57:50.910
你调用这个方法调用这个方法他这边说

57:50.910 --> 57:53.310
加加加加加你打印他的属性啊

57:53.510 --> 57:54.310
这边log

57:54.510 --> 57:58.010
这个controller.cont

57:58.410 --> 57:59.310
ok走

57:59.610 --> 58:00.210
看见了

58:00.410 --> 58:01.110
什么加加了

58:01.710 --> 58:03.010
对不对 ok

58:04.110 --> 58:05.310
好这个是

58:07.110 --> 58:08.110
这段代码啊

58:09.010 --> 58:11.010
然后绑定到其他对象

58:11.910 --> 58:13.910
把这看一下吗啊这边稍微变了一下

58:14.110 --> 58:15.610
做了一个变形啊那我们

58:16.010 --> 58:16.710
来看一下

58:17.210 --> 58:19.110
这边的话然后除了

58:19.510 --> 58:21.010
这边有个controller以外

58:21.110 --> 58:23.210
这边的话然后还有一个这个obj

58:24.210 --> 58:26.310
哇一个这个obj

58:26.810 --> 58:28.510
等于啊这个又是个对象

58:32.150 --> 58:34.950
这个对象啊这个对象的话也有这个cont

58:35.950 --> 58:37.350
他cont的话他是从多少呢

58:37.450 --> 58:38.750
他是从100开始

58:38.950 --> 58:42.950
ok好那既然我这边controller.and

58:43.250 --> 58:47.150
这个方法bund好我把这个一改obj

58:47.650 --> 58:50.650
那也就说我这边的话这个z是指向指向的是哪里

58:51.250 --> 58:52.750
是不是指向的是这个

58:53.050 --> 58:53.850
是这个对象

58:54.050 --> 58:56.050
说我这边在执行这个fn的时候

58:56.050 --> 58:58.250
这边z是点counter加加其实是什么呢

58:58.350 --> 59:00.250
其实是这个counter加加啊

59:00.250 --> 59:02.050
你不信的话你把两个都打印出来

59:03.950 --> 59:05.150
你会发现这个没变

59:05.650 --> 59:07.250
这个controller的counter还是0

59:07.350 --> 59:09.750
那这个变成101了啊走

59:10.850 --> 59:11.450
可不可以啊

59:11.950 --> 59:13.250
为什么原因很简单

59:13.250 --> 59:15.250
你这边绑定的是obj

59:15.950 --> 59:17.250
你绑定是obj

59:17.650 --> 59:19.050
说这边z他指向什么呢

59:19.050 --> 59:20.450
就指向你这个对象

59:20.850 --> 59:22.050
啊指向这个对象

59:23.150 --> 59:23.650
ok

59:24.350 --> 59:24.750
啊

59:25.950 --> 59:27.150
然后bund

59:27.250 --> 59:30.550
bund还可以接收更多的这个参数

59:30.750 --> 59:31.950
啊就和那个core

59:32.350 --> 59:33.450
是不一样的对不对

59:33.450 --> 59:34.950
这边还可以接受这个参数

59:34.950 --> 59:38.250
第1个是你要绑定的这个z的指向的那个对象

59:38.550 --> 59:40.550
第2个就是接收的其他参数了

59:40.750 --> 59:42.250
那这个参数应该就是可以

59:42.350 --> 59:43.850
传到这个前面的这些

59:44.250 --> 59:47.350
啊就前面你这个要运行的这个函数里面啊

59:49.050 --> 59:52.650
啊然后bund的方法第1个参数如果是null和undefine

59:52.750 --> 59:55.150
那z就绑定到全局对象

59:55.250 --> 59:57.250
那这个和那个core和apply

59:57.450 --> 59:58.350
是不是一样的

59:59.050 --> 01:00:00.350
对不对不用我这边bund

01:00:00.550 --> 01:00:00.950
no

01:00:01.450 --> 01:00:04.350
那你这边那现在这个z他就指向全局对象

01:00:04.450 --> 01:00:05.950
那相当于这边就只是干嘛

01:00:05.950 --> 01:00:07.150
这只是传参而已

01:00:07.850 --> 01:00:09.050
对不对啊

01:00:09.550 --> 01:00:11.950
好下面一些注意点啊我们来看一下

01:00:12.150 --> 01:00:14.750
bund的方法有一些使用的注意点

01:00:15.450 --> 01:00:19.550
首先第1个每一次返回一个新的这个函数

01:00:20.450 --> 01:00:21.650
这刚我们是不是知道了

01:00:21.850 --> 01:00:23.950
对不对他是会返回一个新的函数

01:00:24.550 --> 01:00:28.450
好第2个结合这个回调函数使用

01:00:28.850 --> 01:00:29.650
让我们来看一下

01:00:30.450 --> 01:00:33.450
回调函数是接收最常用的模式之一啊

01:00:33.450 --> 01:00:35.550
但是一个常见的错误就是

01:00:36.050 --> 01:00:38.650
z是方法直接当回调函数哎

01:00:38.650 --> 01:00:39.850
这个我们刚才看过的

01:00:41.150 --> 01:00:44.450
这个我们刚才看过的你如果就是z方法

01:00:45.150 --> 01:00:47.050
啊直接当做这个回调函数

01:00:47.150 --> 01:00:49.650
那你这个z的话他就指向什么

01:00:49.750 --> 01:00:50.750
就指向全局了

01:00:51.450 --> 01:00:53.150
对不对啊我们把这个代码吗

01:00:53.150 --> 01:00:55.350
把这个代码我们来看一下啊

01:00:58.290 --> 01:01:00.090
啊来到我们这边啊

01:01:00.490 --> 01:01:02.390
我们把刚才那个代码我们来写一下

01:01:04.090 --> 01:01:05.790
呃这边不用全部

01:01:06.390 --> 01:01:07.790
这边先把这个复制一发

01:01:09.090 --> 01:01:10.590
好那把它注释掉

01:01:10.990 --> 01:01:12.390
好他这个代码是这个样子的

01:01:12.890 --> 01:01:14.890
就首先的话这边有一个这个controller

01:01:14.890 --> 01:01:17.490
accountsling好然后接下来的话这边

01:01:18.190 --> 01:01:19.090
严格模式

01:01:20.690 --> 01:01:21.990
use the strict

01:01:23.690 --> 01:01:26.090
好然后加这边this counter加加

01:01:26.390 --> 01:01:28.990
好然后完事之后然后加这边有一个这个

01:01:28.990 --> 01:01:29.490
function

01:01:29.990 --> 01:01:32.490
function然后是一个这个callback

01:01:33.590 --> 01:01:34.590
是一个回调函数

01:01:34.890 --> 01:01:36.390
回调函数然后接收一个什么呢

01:01:36.390 --> 01:01:37.390
接收一个一分

01:01:39.090 --> 01:01:40.990
好然后接下来的话这边执行这个

01:01:41.490 --> 01:01:42.990
接收到的这个回调函数

01:01:43.290 --> 01:01:44.690
好然后完事之后

01:01:45.090 --> 01:01:46.590
这边这个callback

01:01:47.690 --> 01:01:50.390
啊然后我们传入什么呢

01:01:50.490 --> 01:01:51.890
传入这个controller

01:01:53.390 --> 01:01:54.390
controller是这个对象

01:01:54.590 --> 01:01:56.390
然后接下来点这个end

01:01:56.690 --> 01:01:58.890
然后接下来的话这边bund

01:02:00.290 --> 01:02:03.790
然后把这个controller把它传进去

01:02:05.390 --> 01:02:07.990
ok稍微有点绕啊稍微有点绕

01:02:08.090 --> 01:02:09.990
好最后干嘛呢最后打印

01:02:10.290 --> 01:02:11.990
打印这个controller

01:02:12.890 --> 01:02:14.790
controller.cont

01:02:15.290 --> 01:02:17.590
ok好那我们这边的话我们来理一下

01:02:17.590 --> 01:02:19.790
这个代码究竟是怎么一回事

01:02:20.790 --> 01:02:23.790
好你这边首先我们来看这里啊

01:02:24.090 --> 01:02:27.090
controller.end是哪个方法

01:02:27.290 --> 01:02:28.090
是不是这个方法

01:02:28.490 --> 01:02:30.690
对不对这个方法好首先我们把这个方法

01:02:30.690 --> 01:02:33.290
取出来取出来他这边是这个严格模式

01:02:33.290 --> 01:02:35.490
他还故意扰乱你啊他告诉你注意哦

01:02:35.490 --> 01:02:38.290
我是严格模式呦啊好这个方法

01:02:38.390 --> 01:02:40.690
这个方法然后点bund

01:02:40.690 --> 01:02:42.390
好我要开始绑定这次指向了

01:02:42.490 --> 01:02:45.190
bund 然后绑定了这个这次指向的对象

01:02:45.190 --> 01:02:46.590
是谁controller

01:02:46.790 --> 01:02:48.090
controller始终是谁

01:02:48.290 --> 01:02:50.090
是不是始终是这个对象

01:02:51.090 --> 01:02:53.090
看到没有始终是这个对象

01:02:53.490 --> 01:02:55.390
啊然后接下来整体返回一个什么呢

01:02:55.590 --> 01:02:57.190
返回一个新的函数

01:02:57.390 --> 01:02:59.390
那新的这个函数作为这个

01:03:00.090 --> 01:03:01.890
就这边这个参数fn是不传进来

01:03:01.890 --> 01:03:02.690
然后执行

01:03:03.190 --> 01:03:04.790
也就是最终其实执行的就是什么

01:03:04.790 --> 01:03:05.690
是不是执行他的

01:03:05.990 --> 01:03:07.390
他的这个返回的这个函数啊

01:03:07.990 --> 01:03:10.390
对不对执行的就是他返回的这个函数

01:03:10.590 --> 01:03:12.390
那他返回的这个函数的话

01:03:13.190 --> 01:03:16.190
就是谁就是他只不过这次指向的是谁

01:03:16.190 --> 01:03:17.590
指向的是这个controller

01:03:18.190 --> 01:03:20.390
对不对所以这边racecontroller

01:03:20.490 --> 01:03:22.090
然后点counter是不是就拿到他

01:03:22.190 --> 01:03:23.790
然后加加就他变成a

01:03:23.990 --> 01:03:25.290
说最终这边打印的时候

01:03:25.290 --> 01:03:27.290
这边结果就应该是一

01:03:27.790 --> 01:03:29.990
看到没有啊我们这边走

01:03:30.590 --> 01:03:31.390
是不是就是a

01:03:31.890 --> 01:03:33.290
对不对好

01:03:33.490 --> 01:03:34.790
来到这边看一下哈

01:03:35.090 --> 01:03:36.990
上面的代码中啊这个的话

01:03:36.990 --> 01:03:38.890
他会调用回调函数

01:03:39.090 --> 01:03:41.390
这是如果直接把这个传入

01:03:42.190 --> 01:03:43.590
等你没绑定的情况下

01:03:43.790 --> 01:03:46.790
传入那么race他就会指向全局对象

01:03:46.790 --> 01:03:47.990
那什么意思就是这里

01:03:49.090 --> 01:03:50.990
这边这边我没有绑定

01:03:51.590 --> 01:03:52.690
没有绑定

01:03:53.090 --> 01:03:55.490
没有绑定了传入的是不是就是

01:03:56.090 --> 01:03:56.990
这个函数

01:03:56.990 --> 01:03:59.790
而且最终他是以什么是不以函数的形式来调用的

01:04:00.090 --> 01:04:02.490
对不对老套路了啊老套路

01:04:02.590 --> 01:04:04.190
这里的话就是传了个函数过来

01:04:04.190 --> 01:04:05.090
大家这边调用

01:04:05.190 --> 01:04:07.590
那他就是以普通函数的形式调用的

01:04:07.790 --> 01:04:09.290
那这次就指向什么

01:04:09.490 --> 01:04:10.690
是不是指向全局对象

01:04:11.290 --> 01:04:11.790
对不对

01:04:12.790 --> 01:04:14.390
你打印的话这边就还是0

01:04:15.290 --> 01:04:17.590
这边走啊这边抱错了

01:04:17.890 --> 01:04:20.590
因为这个全局没有这个没有抗产

01:04:20.890 --> 01:04:21.290
对吧

01:04:21.290 --> 01:04:22.090
他抱错了

01:04:26.490 --> 01:04:30.290
然后使用棒的啊把它绑定之后就不会有这个问题

01:04:30.290 --> 01:04:30.790
为什么呢

01:04:30.790 --> 01:04:32.790
因为race总是指向抗产的

01:04:34.090 --> 01:04:36.390
然后还有一种情况比较隐蔽

01:04:36.590 --> 01:04:40.390
就是某些数组方法可以接受一个函数

01:04:40.390 --> 01:04:41.390
这个函数

01:04:42.090 --> 01:04:43.690
当做这个参数

01:04:44.190 --> 01:04:45.490
比如这个for一起

01:04:46.490 --> 01:04:49.290
for一起是不是就是可以接受一个这个函数

01:04:49.490 --> 01:04:51.790
啊这个函数里面然后这样我们来看一下啊

01:04:51.990 --> 01:04:54.390
这个回掉函数里面然后就要打印这个

01:04:54.890 --> 01:04:56.290
z点内姆

01:04:57.190 --> 01:04:59.790
那这里的话打印出来什么没有任何输出啊

01:04:59.790 --> 01:05:00.990
我们这边可以把它看一下

01:05:02.190 --> 01:05:02.990
来到这边

01:05:05.990 --> 01:05:07.390
把这个例子看一下

01:05:09.490 --> 01:05:11.890
假设我们这边的话有这么一个对象

01:05:11.890 --> 01:05:13.390
我们就不写那么多啊

01:05:13.390 --> 01:05:15.290
我们就写一个简单的比如内姆

01:05:15.790 --> 01:05:17.290
内姆的话是张三

01:05:17.890 --> 01:05:18.390
ok

01:05:18.790 --> 01:05:20.690
好然后接下来的话我们这边

01:05:21.090 --> 01:05:23.890
我们还是得写个类似于数组的东西

01:05:24.290 --> 01:05:26.890
比如这边啊一会儿才好去便利

01:05:27.290 --> 01:05:29.290
比较一二三ok

01:05:29.690 --> 01:05:31.990
好然后接下来的话这边有一个方法

01:05:31.990 --> 01:05:33.190
叫做这个print

01:05:34.590 --> 01:05:36.490
print这个方法好理论上来讲

01:05:36.490 --> 01:05:38.090
这print方法里面有什么

01:05:38.190 --> 01:05:39.030
是不是有race

01:05:39.030 --> 01:05:40.190
race指向什么

01:05:40.190 --> 01:05:41.690
就指向这个obj

01:05:41.990 --> 01:05:43.590
对不对啊这个是没问题的

01:05:43.690 --> 01:05:44.590
好那现在正面

01:05:44.590 --> 01:05:45.990
z点

01:05:46.590 --> 01:05:47.690
这个啊

01:05:49.390 --> 01:05:49.990
哎呀啊

01:05:49.990 --> 01:05:51.390
然后接下来我调用什么呢

01:05:51.390 --> 01:05:52.990
调用for each

01:05:53.690 --> 01:05:54.190
看到没有

01:05:54.190 --> 01:05:55.390
因为race点哎呀

01:05:55.390 --> 01:05:56.490
是不是指向这个数组啊

01:05:57.090 --> 01:05:58.090
指向这个数组

01:05:58.090 --> 01:06:00.390
然后接下来的话这边for each

01:06:00.890 --> 01:06:03.190
for each是不接受一个回调函数啊

01:06:03.590 --> 01:06:04.090
对不对

01:06:04.090 --> 01:06:05.290
所以我这边的话function

01:06:06.590 --> 01:06:08.590
把数组的每一项

01:06:09.290 --> 01:06:11.190
传进来啊传进来之后

01:06:11.190 --> 01:06:12.690
然后这样我这边我打印什么呢

01:06:12.690 --> 01:06:13.890
我这边nog

01:06:14.390 --> 01:06:15.090
z

01:06:15.690 --> 01:06:16.090
点

01:06:16.190 --> 01:06:16.790
name

01:06:17.890 --> 01:06:19.790
啊你会发现这边的话就出问题了

01:06:20.190 --> 01:06:20.790
为什么呢

01:06:20.790 --> 01:06:22.890
因为你这个回调函数

01:06:23.490 --> 01:06:25.690
你这里的话是调这个回调函数是吧

01:06:25.790 --> 01:06:26.590
调这个回调函数

01:06:26.590 --> 01:06:27.390
这个回调函数

01:06:27.390 --> 01:06:29.990
他也是以普通函数的形式调用的

01:06:30.190 --> 01:06:31.090
说他这个race

01:06:31.090 --> 01:06:32.590
其实是指向的什么呢

01:06:32.690 --> 01:06:34.090
指向的全局

01:06:34.390 --> 01:06:35.090
啊那我们这边

01:06:35.090 --> 01:06:38.490
让我们来执行这个方法obj点print

01:06:39.990 --> 01:06:41.390
执行这个方法好

01:06:41.390 --> 01:06:42.390
这边走

01:06:43.290 --> 01:06:45.390
你看是不是on the fire

01:06:46.390 --> 01:06:47.090
对不对

01:06:47.090 --> 01:06:47.790
是on the fire

01:06:47.790 --> 01:06:49.790
并不是什么的并不是这个张三

01:06:50.190 --> 01:06:50.690
为什么

01:06:50.690 --> 01:06:52.690
因为你这个race已经变成什么了

01:06:52.690 --> 01:06:54.190
已经变成全局的了

01:06:54.190 --> 01:06:56.390
啊比我们这边再来nog

01:06:58.090 --> 01:06:58.690
race

01:06:59.290 --> 01:07:01.990
是否全等于这个global

01:07:03.590 --> 01:07:04.790
啊走

01:07:05.390 --> 01:07:05.990
看到没有

01:07:06.190 --> 01:07:06.990
是不是去啊

01:07:07.490 --> 01:07:07.990
对不对

01:07:08.290 --> 01:07:09.390
是去啊

01:07:09.390 --> 01:07:10.390
那这个怎么办呢

01:07:10.390 --> 01:07:12.590
那这个时候我们就可以通过这个bund

01:07:12.990 --> 01:07:14.990
我们来解决这个问题啊

01:07:15.090 --> 01:07:17.090
这边的你是这个for一起是吧

01:07:17.590 --> 01:07:18.790
啊我们这边我们来看一下

01:07:20.190 --> 01:07:21.290
啊这边这边的话

01:07:21.290 --> 01:07:23.690
呃这这这的race是不是对的

01:07:23.690 --> 01:07:23.990
对不对

01:07:23.990 --> 01:07:25.590
这的race是指向什么

01:07:25.590 --> 01:07:27.390
是不是指向整个这个obj的

01:07:27.690 --> 01:07:28.090
对不对

01:07:28.090 --> 01:07:29.890
那race点这个

01:07:30.190 --> 01:07:31.290
呃for一起

01:07:31.290 --> 01:07:33.390
然后加这个是你的这个回调函数啊

01:07:33.390 --> 01:07:34.890
回调函数我们在进去之前

01:07:34.890 --> 01:07:35.790
我们这边干嘛呢

01:07:35.790 --> 01:07:37.190
我们这边调这个bund

01:07:39.170 --> 01:07:40.570
看到没有调这个bund

01:07:40.570 --> 01:07:41.770
啊也就说我这边的话

01:07:41.970 --> 01:07:43.370
啊这个是我要执行的方法

01:07:43.470 --> 01:07:44.370
这个是我执行的方法

01:07:44.370 --> 01:07:45.070
然后加bund

01:07:45.070 --> 01:07:46.470
然后加这边是什么呢

01:07:46.470 --> 01:07:48.070
这边就是race

01:07:48.870 --> 01:07:49.770
啊绑定race

01:07:49.770 --> 01:07:51.170
这个race就等加于什么呢

01:07:51.170 --> 01:07:52.570
等加于这个race

01:07:52.870 --> 01:07:54.170
那回头你再来看的话

01:07:54.170 --> 01:07:56.370
这边的话race点内幕就是张三

01:07:56.570 --> 01:07:58.170
然后加这边的话就是force

01:07:58.470 --> 01:07:59.470
啊我们这边走

01:08:00.970 --> 01:08:01.570
看到没有

01:08:01.670 --> 01:08:03.470
是不是张三张三张三

01:08:03.470 --> 01:08:04.570
然后force

01:08:05.170 --> 01:08:06.370
啊这个的话都是

01:08:06.570 --> 01:08:08.470
一些就是平时做开发的时候

01:08:08.470 --> 01:08:09.870
经常会遇到的问题

01:08:10.070 --> 01:08:11.770
啊其实就是race指向的问题

01:08:12.270 --> 01:08:14.670
啊race一会只过去一会只过来

01:08:14.770 --> 01:08:16.470
一不小心你到了那个函数

01:08:16.570 --> 01:08:18.270
他就是以普通形式调用的

01:08:18.670 --> 01:08:20.470
他只要以普通函数形式调用

01:08:20.470 --> 01:08:22.370
他race就指向全局

01:08:22.670 --> 01:08:23.070
对不对

01:08:23.070 --> 01:08:24.370
那我就可以通过bund

01:08:24.470 --> 01:08:26.270
我给他绑定识啊

01:08:27.970 --> 01:08:29.870
啊这是关于这个bund

01:08:30.370 --> 01:08:31.870
啊其他就没什么了

01:08:32.670 --> 01:08:33.670
啊这里还有一个

01:08:34.270 --> 01:08:36.470
结合这个扣方法使用

01:08:36.870 --> 01:08:38.070
啊利用bund的方法

01:08:38.070 --> 01:08:39.510
可以改写一些

01:08:39.510 --> 01:08:41.970
接使原生方法的使用方式

01:08:42.270 --> 01:08:44.370
以数组slice为例

01:08:44.470 --> 01:08:45.570
啊比方我们这边有个数组

01:08:45.570 --> 01:08:47.270
数组这边是不是在解决

01:08:48.470 --> 01:08:50.370
对不对啊slice解决啊

01:08:50.370 --> 01:08:51.470
这边呢你就可以通过什么

01:08:51.470 --> 01:08:54.270
通过这个orade点port type点slice

01:08:54.270 --> 01:08:56.070
因为这个slice其实最终是在什么呢

01:08:56.070 --> 01:08:57.870
是在这个oradeport type上面

01:08:58.070 --> 01:09:00.070
啊然后接下来把它应用在哪里呢

01:09:00.070 --> 01:09:01.570
应用在这个地方

01:09:02.470 --> 01:09:04.170
然后接下来这边传参

01:09:04.770 --> 01:09:07.570
对不对传参这个时候我传入了第1个对象

01:09:07.770 --> 01:09:10.870
那第二个是什么我传的这个参数啊

01:09:12.370 --> 01:09:13.970
啊然后

01:09:14.770 --> 01:09:17.770
扣方法实质上啊就是调用

01:09:17.970 --> 01:09:19.870
这个方形port type

01:09:21.170 --> 01:09:23.570
扣啊因此上面的表达是

01:09:23.570 --> 01:09:25.870
可以用这个bund来改写啊

01:09:25.870 --> 01:09:28.470
这边呢就是function点port type点扣

01:09:28.470 --> 01:09:29.870
也就是这个扣这个方法

01:09:30.370 --> 01:09:31.870
扣这个方法其实是哪里呢

01:09:31.870 --> 01:09:33.970
是function点port type上面的

01:09:34.970 --> 01:09:35.570
看不看

01:09:35.570 --> 01:09:39.170
啊所以我这边就可以function点port type点扣

01:09:39.670 --> 01:09:40.770
啊把这个方法

01:09:40.870 --> 01:09:42.070
然后接下来bund

01:09:42.170 --> 01:09:45.370
绑到上面的绑到这个slice上面啊

01:09:45.370 --> 01:09:46.670
效果是一样的

01:09:48.670 --> 01:09:51.370
好然后这边调用

01:09:51.470 --> 01:09:53.270
不用我这边的话把这个扣

01:09:53.570 --> 01:09:56.070
绑定到这个数组的这个

01:09:56.170 --> 01:09:58.070
proxy上面啊我们把这个看一下嘛

01:09:59.670 --> 01:10:01.370
我们从上面开始理嘛啊

01:10:01.370 --> 01:10:02.570
从这边一点点来

01:10:03.170 --> 01:10:05.770
就是这个是结合扣方法使用是吧

01:10:06.470 --> 01:10:08.470
那这边我们把这个理一下

01:10:08.670 --> 01:10:09.170
嗯

01:10:12.870 --> 01:10:14.070
这个bund

01:10:16.070 --> 01:10:19.370
方法结合这个扣方法

01:10:20.170 --> 01:10:21.870
使用好我们一点一点来啊

01:10:22.070 --> 01:10:23.370
比如说我这边有个数组

01:10:23.970 --> 01:10:26.170
哇一个啊啊等于一个

01:10:26.470 --> 01:10:29.670
123ok很简单的一个数组对吧

01:10:29.870 --> 01:10:31.270
好了以前我们用数组的时候

01:10:31.270 --> 01:10:32.170
我们是不是可以这样子

01:10:32.470 --> 01:10:35.970
a啊啊点slice啊

01:10:35.970 --> 01:10:37.970
比如说这边的话01

01:10:38.370 --> 01:10:39.570
那我们知道这个是不是

01:10:39.570 --> 01:10:40.470
结取数组

01:10:41.470 --> 01:10:44.270
对不对结取这个数组啊01

01:10:44.370 --> 01:10:45.570
把结取结取了

01:10:45.570 --> 01:10:47.870
他会给你返回一个新的数组

01:10:48.170 --> 01:10:51.570
对吧用这边console.log

01:10:54.410 --> 01:10:54.810
走

01:10:55.310 --> 01:10:56.010
出来啊

01:10:56.310 --> 01:10:57.610
ok啊很简单

01:10:57.810 --> 01:10:59.110
好然后接下来话

01:11:00.410 --> 01:11:01.910
好接下来的话

01:11:02.010 --> 01:11:04.310
让我这个的话我可不可以直接这个样子

01:11:06.180 --> 01:11:07.680
可不可以直接

01:11:08.480 --> 01:11:10.280
啊这个不要这个变量

01:11:11.180 --> 01:11:11.680
可以吧

01:11:12.480 --> 01:11:14.580
对不对啊这边那是不是一样的

01:11:14.880 --> 01:11:15.280
走

01:11:15.580 --> 01:11:16.580
这也是一对不对

01:11:16.580 --> 01:11:18.580
我这边就直接在数组的基础上

01:11:18.780 --> 01:11:19.980
是不是来调用这个方法

01:11:20.280 --> 01:11:22.580
好然后接下来我们知道这个slice

01:11:22.680 --> 01:11:24.480
这个slice方法来源于哪里呢

01:11:25.780 --> 01:11:27.480
slice方法

01:11:27.680 --> 01:11:30.380
我这边一步一步再和你再给你理哈

01:11:30.380 --> 01:11:32.880
再推倒slice方法

01:11:34.280 --> 01:11:35.880
来源于

01:11:36.280 --> 01:11:37.080
是不是orade

01:11:37.380 --> 01:11:39.380
它是不是有个叫做orade构造函数

01:11:39.380 --> 01:11:41.680
那既然它是不是有一个圆形对象

01:11:43.850 --> 01:11:44.750
portal

01:11:45.550 --> 01:11:46.650
portal type

01:11:46.850 --> 01:11:49.150
这来源于orade点portal type

01:11:49.350 --> 01:11:50.550
就是这个对象上面

01:11:50.750 --> 01:11:53.050
对不对所以我们要调这个slice我们可以怎么调

01:11:53.150 --> 01:11:54.850
我们可以orade

01:11:55.850 --> 01:11:57.750
点portal type

01:11:57.950 --> 01:11:59.250
点slice

01:11:59.550 --> 01:12:03.350
对不对这个就等价于你这边这个数组调这个slice这个方法

01:12:03.850 --> 01:12:04.450
看到没有

01:12:04.550 --> 01:12:06.850
然后既然呢我把这个就应用在哪里呢

01:12:06.850 --> 01:12:08.750
这边点这个core

01:12:10.250 --> 01:12:11.850
点这个core调这个core

01:12:11.950 --> 01:12:16.050
core的话就是把这个方法应用到某个对象上面对不对

01:12:16.150 --> 01:12:17.350
我要应用到哪个对象呢

01:12:17.450 --> 01:12:20.650
要应用到我有一个叫做数组的对象123

01:12:20.950 --> 01:12:23.450
对不对大家后面是不是就是它的参数列表

01:12:23.550 --> 01:12:25.550
比如01

01:12:26.750 --> 01:12:29.050
啊好大家我们这边我们打印一下

01:12:29.050 --> 01:12:31.450
你会发现效果仍然是一样的

01:12:32.550 --> 01:12:33.150
log

01:12:34.650 --> 01:12:35.050
走

01:12:35.450 --> 01:12:36.050
看到没有

01:12:36.350 --> 01:12:39.250
是不是一模一样啊你首先的话把这一步搞清楚

01:12:39.950 --> 01:12:42.750
把这一步搞清楚这是怎么来的啊

01:12:42.950 --> 01:12:46.150
这边的就是把这个slice数组的slice方法

01:12:46.250 --> 01:12:48.950
应用到这个数组上面

01:12:49.050 --> 01:12:51.650
然后既然这边的话是传入的参数

01:12:52.550 --> 01:12:53.850
这边是传入的参数

01:12:54.150 --> 01:12:54.650
ok

01:12:55.050 --> 01:12:58.450
好那完了之后那即下我们再来研究这个core这个方法

01:12:59.250 --> 01:13:00.850
core这个方法来源于哪里呢

01:13:02.250 --> 01:13:03.550
把上面注释掉哈

01:13:04.050 --> 01:13:05.250
core这个方法

01:13:06.350 --> 01:13:09.350
啊我们slice方法是来源于oradeportal type

01:13:09.450 --> 01:13:11.250
好那core这个方法

01:13:14.340 --> 01:13:18.240
core这个方法来源于什么呢来源于function

01:13:18.840 --> 01:13:23.240
function.portal type上面有一个这个core这个方法

01:13:23.840 --> 01:13:26.240
ok好那接下来我就做一个绑定

01:13:26.740 --> 01:13:27.640
function

01:13:28.740 --> 01:13:29.640
portal type

01:13:30.540 --> 01:13:32.840
点core本质上就是就是什么

01:13:33.140 --> 01:13:34.340
是不是就是这个core方法

01:13:34.740 --> 01:13:36.140
对本质上就是这个core方法

01:13:36.240 --> 01:13:37.840
然后我把这个core方法

01:13:38.240 --> 01:13:39.640
我这边的话就是bund

01:13:41.980 --> 01:13:44.180
bundle到哪里呢bundle到这个orade

01:13:44.880 --> 01:13:47.180
orade点这个portal type

01:13:48.080 --> 01:13:49.780
点snice

01:13:50.480 --> 01:13:53.480
诶注意啊仔细理一理这边做了件什么事情

01:13:53.580 --> 01:13:54.680
首先我们这边我们来看

01:13:54.780 --> 01:13:55.780
这边是不是有个bund

01:13:56.680 --> 01:13:57.380
这边有个bund

01:13:57.680 --> 01:13:59.780
bund的话那他一定会反悔一个什么

01:13:59.880 --> 01:14:01.480
是反悔一个新的这个函数

01:14:01.880 --> 01:14:03.980
对不对那我们这边就接收一下

01:14:04.680 --> 01:14:06.680
哇一个snice

01:14:07.580 --> 01:14:10.280
接收一下好那他这边在做什么事情呢

01:14:10.380 --> 01:14:11.580
他这边的话是不是就是

01:14:11.680 --> 01:14:14.980
这边的话是绑定你的这个z的指向啊

01:14:15.380 --> 01:14:16.480
也就是我们的z

01:14:17.080 --> 01:14:18.080
始终是指向什么

01:14:18.180 --> 01:14:21.580
是不是指向的是这个oradeportal type这个原型

01:14:21.980 --> 01:14:23.380
对不对让他的这个snice

01:14:23.880 --> 01:14:25.780
然后接下来把这个core这个方法

01:14:26.080 --> 01:14:26.880
应用上去

01:14:27.380 --> 01:14:29.180
所以我们这边相当于就改写了什么呢

01:14:29.280 --> 01:14:32.080
改写了这个snice方法啊

01:14:32.080 --> 01:14:33.380
这里就相当于

01:14:36.410 --> 01:14:40.910
这里就相当于改写了

01:14:41.710 --> 01:14:42.810
snice方法

01:14:43.910 --> 01:14:45.610
我们以前用snice方法怎么用的

01:14:46.310 --> 01:14:50.210
以前用snice方法

01:14:51.510 --> 01:14:52.110
怎么样

01:14:52.210 --> 01:14:54.210
是不是你这边的话就有一个数组啊

01:14:54.910 --> 01:14:56.610
对不对让家这边123

01:14:56.710 --> 01:14:58.610
大家这边说调这个snice

01:14:58.910 --> 01:15:00.910
对不对01 ok

01:15:01.010 --> 01:15:02.110
好了接下来我们这边呢

01:15:02.110 --> 01:15:03.910
我们就用我们返回的这个函数

01:15:04.210 --> 01:15:05.210
返回的这个函数

01:15:05.910 --> 01:15:06.610
snice

01:15:07.810 --> 01:15:08.710
那这个函数的话

01:15:08.710 --> 01:15:10.110
你看这边是不是把这个core

01:15:10.610 --> 01:15:11.410
应用上去了

01:15:11.710 --> 01:15:13.110
对不对所以他这边的话就是传参

01:15:13.110 --> 01:15:15.410
就像这边你在调用core方法一样

01:15:15.710 --> 01:15:16.710
这边就直接

01:15:17.610 --> 01:15:19.010
1 2 3

01:15:19.110 --> 01:15:20.510
好让下第二个参数

01:15:20.710 --> 01:15:22.010
01

01:15:22.310 --> 01:15:24.910
你看这个是不是就像在调用这个core方法一样

01:15:25.810 --> 01:15:28.110
对不对啊因为你这边的话就是这个方形

01:15:28.110 --> 01:15:29.310
port type点core

01:15:29.410 --> 01:15:31.710
绑定到了这个snice上面

01:15:32.510 --> 01:15:35.110
看到没有啊把他绑定到snice上面

01:15:35.210 --> 01:15:36.810
好了这样我们这边我们来看好不好使

01:15:43.200 --> 01:15:44.500
好这边走

01:15:45.400 --> 01:15:46.200
是不是ok的

01:15:46.700 --> 01:15:47.900
对不对ok的

01:15:48.100 --> 01:15:50.600
啊所以你把这个啊把这个你再看一下

01:15:52.000 --> 01:15:53.400
好我们这边再来理一遍嘛

01:15:53.600 --> 01:15:57.400
你看这边方形点port type点core

01:15:57.900 --> 01:15:59.300
啊这个是不是一个整体

01:15:59.600 --> 01:16:01.100
这个是不是其实就是core方法

01:16:01.400 --> 01:16:03.700
对不对core方法然后接下来棒的

01:16:03.900 --> 01:16:06.500
你整体棒的是不是会返回一个函数啊

01:16:07.200 --> 01:16:08.400
对不对会返回一个方法

01:16:08.400 --> 01:16:10.000
然后加这个方法我们存储在哪里的

01:16:10.300 --> 01:16:11.700
存储在这个snice里面

01:16:12.000 --> 01:16:13.900
好那接下来的话你这边的话执行

01:16:14.100 --> 01:16:15.700
执行这个调用这个snice的话

01:16:15.700 --> 01:16:17.600
其实就是调用了什么是不是这个core

01:16:17.700 --> 01:16:20.600
所以你看这边传参的时候是不是以core的形式来传的

01:16:21.100 --> 01:16:23.700
对不对传了然后这边123

01:16:23.800 --> 01:16:26.400
这个数组再加这边0再加这边1

01:16:26.500 --> 01:16:28.800
传入到哪里去传入到这个snice里面

01:16:29.100 --> 01:16:29.900
进行执行

01:16:30.400 --> 01:16:32.600
好吧啊那你这个明白的话

01:16:32.600 --> 01:16:34.500
那后面这个改写就都是一样的

01:16:34.800 --> 01:16:35.300
这边

01:16:35.900 --> 01:16:38.100
方形点port type点core

01:16:38.200 --> 01:16:39.800
然后棒的啊这边

01:16:40.600 --> 01:16:42.200
orateport type push

01:16:42.400 --> 01:16:43.900
是不是改写了这个push方法

01:16:44.000 --> 01:16:45.700
那你回头调用这个push方法的时候

01:16:45.700 --> 01:16:48.000
是不是就是你这种core的形式来调用

01:16:48.200 --> 01:16:49.000
你看一下是不是

01:16:49.400 --> 01:16:50.300
比较第1个参数

01:16:50.500 --> 01:16:51.600
是不是接受一个数组

01:16:51.800 --> 01:16:54.400
第2个参数是不是就是你要推入的这个数字

01:16:55.100 --> 01:16:55.600
看到没啊

01:16:58.000 --> 01:17:01.000
如果再进一步这边可以将这个core方法

01:17:01.400 --> 01:17:03.500
绑定到这个bond上面啊

01:17:03.500 --> 01:17:06.600
意味着bond的调用形式也可以被改写

01:17:06.800 --> 01:17:07.800
我们这边我们来看一下

01:17:07.900 --> 01:17:09.300
比较这边有一个这个f

01:17:09.600 --> 01:17:12.000
这个函数啊这边答应z点v

01:17:12.300 --> 01:17:14.400
好然后接下来这边有一个o这个对象

01:17:14.600 --> 01:17:15.600
v是123

01:17:16.000 --> 01:17:17.600
好然后接下来我们这边

01:17:17.900 --> 01:17:19.300
这边是不是调用了这个bond

01:17:20.600 --> 01:17:21.600
调用了bond的方法

01:17:21.600 --> 01:17:23.900
大家这个bond的方法最终会给你返回一个

01:17:24.100 --> 01:17:25.200
是不是新的这个

01:17:25.700 --> 01:17:26.300
函数啊

01:17:26.500 --> 01:17:28.100
然后调用新的这个函数

01:17:28.400 --> 01:17:29.900
调用这个新的函数

01:17:29.900 --> 01:17:32.100
然后接下来的话这个函数

01:17:33.000 --> 01:17:34.000
其实调用的是什么

01:17:34.100 --> 01:17:35.000
是不调用的是core

01:17:35.900 --> 01:17:37.000
对不对调用的是core

01:17:37.000 --> 01:17:40.100
所以这边传参是以core的形式传进去了

01:17:40.400 --> 01:17:41.600
啊传进去之后

01:17:41.600 --> 01:17:42.900
然后加最后再调用

01:17:43.100 --> 01:17:44.600
然后得到这个123

01:17:44.700 --> 01:17:46.000
把这个例子我们看一下吧

01:17:55.500 --> 01:17:57.300
啊首先这边function

01:17:58.700 --> 01:18:00.200
方形一个fn

01:18:01.300 --> 01:18:03.200
啊可能有的人都已经晕掉了啊

01:18:03.700 --> 01:18:05.500
logz点v

01:18:06.300 --> 01:18:08.100
好然后接下来的话这边

01:18:09.100 --> 01:18:11.300
哇一个这个obg

01:18:11.900 --> 01:18:13.400
他有一个什么呢有一个v

01:18:13.500 --> 01:18:15.300
v对应的是123

01:18:15.600 --> 01:18:18.300
ok好然后接下来的话我们这边

01:18:18.300 --> 01:18:19.200
我们一步一步来理

01:18:19.300 --> 01:18:20.800
首先的话我们这边function

01:18:21.100 --> 01:18:24.100
方形点portal type点core

01:18:24.400 --> 01:18:25.300
好这个就是什么

01:18:25.900 --> 01:18:27.700
是不是这个就是你的这个core方法

01:18:27.900 --> 01:18:29.600
对不对然后接下来的话点

01:18:29.900 --> 01:18:30.600
bund

01:18:31.400 --> 01:18:32.100
这边的话

01:18:32.500 --> 01:18:33.300
function

01:18:35.360 --> 01:18:36.060
function

01:18:36.360 --> 01:18:37.860
点这个portal type

01:18:38.160 --> 01:18:39.360
点bund

01:18:39.660 --> 01:18:41.060
ok那我们一点点在那里

01:18:41.160 --> 01:18:42.260
首先你这个bund

01:18:42.560 --> 01:18:44.860
这个bund的话他最终返回一个什么

01:18:45.060 --> 01:18:46.160
是返回一个函数啊

01:18:46.460 --> 01:18:48.160
对不对所以你这边可以接受一下

01:18:48.160 --> 01:18:49.760
比如说这个funk

01:18:50.560 --> 01:18:51.160
接受一下

01:18:51.360 --> 01:18:52.160
好接受一下

01:18:52.160 --> 01:18:53.960
那接下来这个函数我是不可以调用

01:18:54.760 --> 01:18:55.160
对不对

01:18:55.560 --> 01:18:58.060
那调用的话让我这边传参怎么传

01:18:59.160 --> 01:18:59.760
怎么传

01:18:59.860 --> 01:19:02.460
那这边是不是就是以这个core的这个形式

01:19:02.960 --> 01:19:04.360
因为你这边的话是这个

01:19:05.060 --> 01:19:08.160
方形portal type点core啊这个绑定了这个core

01:19:08.260 --> 01:19:10.360
是不是是不是以这个core的形式来传

01:19:10.760 --> 01:19:11.160
对不对

01:19:11.260 --> 01:19:12.260
所以这边的话就是

01:19:12.660 --> 01:19:13.460
传入这个

01:19:14.260 --> 01:19:15.260
你的这个fn

01:19:16.060 --> 01:19:18.060
啊然后接下来的话这个obg

01:19:20.100 --> 01:19:21.000
怎么样传入

01:19:21.100 --> 01:19:23.500
传入然后接下来把这个应用到哪里去呢

01:19:23.600 --> 01:19:25.400
应用到这个bund里面

01:19:26.100 --> 01:19:29.700
那应用到bund那期也就说这个整体又会给我返回一个什么

01:19:29.900 --> 01:19:31.400
这又会返回一个函数啊

01:19:31.700 --> 01:19:33.200
对不对你这边可以log一下

01:19:33.600 --> 01:19:35.000
console.log

01:19:36.600 --> 01:19:38.100
他返回的就又是个函数

01:19:38.900 --> 01:19:41.400
看见没有又是个函数那我这边就可以干嘛

01:19:41.500 --> 01:19:43.500
是不是再一次对他进行调用

01:19:44.200 --> 01:19:45.900
对不对啊然后最后

01:19:46.100 --> 01:19:47.500
所以得到这个123

01:19:48.300 --> 01:19:49.800
答应这个123啊

01:19:50.600 --> 01:19:51.800
这边就不需要再答应了

01:19:52.800 --> 01:19:55.800
OK因为你这个函数没有返回值对吧

01:19:56.300 --> 01:20:00.000
啊这边123看到没有啊其实和上面是一样的

01:20:00.800 --> 01:20:02.300
和上面是一样的比如说你这边

01:20:03.100 --> 01:20:04.800
比如说我们刚才写那个

01:20:06.970 --> 01:20:07.570
有这个

01:20:08.570 --> 01:20:11.870
啊这个这个是不是就是方形点破的type点core

01:20:11.970 --> 01:20:14.770
然后接下来bund的你整体是不是返回一个这个

01:20:15.370 --> 01:20:18.570
函数对不对然后接下来然后我这边调用这个函数

01:20:19.270 --> 01:20:22.870
调用这个函数然后加这个函数传参是不是就是以core的形式啊

01:20:23.070 --> 01:20:26.870
对不对来传啊传啊传了之后然后接下来应用到哪去呢

01:20:26.970 --> 01:20:27.670
应用到这里

01:20:28.670 --> 01:20:31.870
对不对用到这里啊最终给你返回一个新的数组

01:20:31.970 --> 01:20:35.570
说你整整体一执行得到的是一个新的数组

01:20:36.270 --> 01:20:39.470
好吧啊你这一块的话你可以下来自己在理一理啊

01:20:39.770 --> 01:20:41.470
肯定有的同学都已经晕掉了

01:20:42.570 --> 01:20:45.570
你就像我刚才那样子吗一步一步你把打印出来比如这边

01:20:45.870 --> 01:20:48.770
你看他打印出来是什么吗这边打印出来是不是就是刚才那个

01:20:49.270 --> 01:20:50.070
是一个方形

01:20:50.670 --> 01:20:51.870
对不对啊

01:20:53.570 --> 01:20:58.470
好然后最后啊最后都已经讲了快一个半小时了是吧

01:20:58.870 --> 01:21:00.270
可能同学也已经累了

01:21:00.870 --> 01:21:04.070
那我们最后最后我们来看一下关于这个箭头函数的

01:21:04.370 --> 01:21:06.670
纸是指向啊这个的话就是什么呢

01:21:06.870 --> 01:21:07.970
我们箭头函数

01:21:08.770 --> 01:21:13.370
箭头函数的话他的这个纸是指向始终是外层作用语

01:21:14.670 --> 01:21:16.670
外层作用语好比我们来看这个例子

01:21:17.070 --> 01:21:19.670
好这边这个obc调这个taste的方法

01:21:19.870 --> 01:21:21.170
taste的方法这个纸是

01:21:21.370 --> 01:21:23.170
那是不是就是指向这个obc

01:21:23.670 --> 01:21:25.370
对不对让z是点一个4

01:21:25.970 --> 01:21:28.970
那就是10对吧那我如果这边

01:21:30.950 --> 01:21:33.450
呃这边这边我们来看这个箭头函数

01:21:33.750 --> 01:21:35.350
箭头函数的话这个z

01:21:35.750 --> 01:21:37.850
他就指向他的这个外一层

01:21:38.350 --> 01:21:42.350
啊外一层的话那就是什么呢就是这个全局啊对于我这个obc来讲

01:21:43.150 --> 01:21:45.550
obc来讲他的债外一层就是什么呀

01:21:45.950 --> 01:21:46.950
是不是就是这个

01:21:47.750 --> 01:21:48.450
全局的家

01:21:48.750 --> 01:21:50.150
那这边z点一个4

01:21:50.350 --> 01:21:54.550
是一个undefined啊但你如果你这个代码是在浏览器里面执行的话

01:21:54.650 --> 01:21:58.250
我这边是不是忘了一个x啊那这边的话就是啊20

01:21:58.750 --> 01:21:59.950
啊你这边你可以看一下

01:22:00.350 --> 01:22:01.950
把这个拿到浏览器里面

01:22:03.650 --> 01:22:05.750
我们这边直接这样子啊

01:22:10.500 --> 01:22:11.000
走

01:22:12.200 --> 01:22:17.800
看看啊他的z是的话就是他的外层obc的外层obc的外层还有什么没啥了

01:22:18.000 --> 01:22:19.100
没啥是不是就是window

01:22:19.400 --> 01:22:20.400
对全局的下

01:22:20.500 --> 01:22:22.500
大家这个x他就是20

01:22:22.600 --> 01:22:25.600
但你这代码如果是在漏的环境里面执行

01:22:25.700 --> 01:22:28.200
因为漏的话他不会把这个全局变量

01:22:28.500 --> 01:22:31.200
作为我这个全局对象的一个属性

01:22:31.200 --> 01:22:34.300
所以他这边的话是一个undefined啊不用把这个代码

01:22:35.100 --> 01:22:36.200
拿到这里

01:22:38.400 --> 01:22:39.200
拿到这边

01:22:39.700 --> 01:22:40.700
把这个注射掉

01:22:45.470 --> 01:22:47.570
啊这个就是最后啊箭头函数

01:22:52.230 --> 01:22:53.330
箭头函数

01:22:54.130 --> 01:22:54.730
z

01:22:55.130 --> 01:22:56.930
指向啊这边

01:22:57.730 --> 01:22:58.230
走

01:22:58.630 --> 01:23:00.530
看没有这就是一个这个

01:23:00.930 --> 01:23:02.830
空对象然后加一个undefined

01:23:03.530 --> 01:23:04.030
对不对

01:23:07.570 --> 01:23:10.970
好然后这里啊这里其实刚才那个例子

01:23:11.770 --> 01:23:14.670
刚才那个例子就是我们那个啊就这个就这个

01:23:15.070 --> 01:23:17.970
这个我们最早是不是使用的是这个棒的来解决的

01:23:18.270 --> 01:23:20.170
对不对那你这边呢其实就可以用用什么呢

01:23:20.170 --> 01:23:21.370
用这个箭头函数

01:23:21.670 --> 01:23:22.370
比如说我们这边

01:23:24.600 --> 01:23:25.800
把这个注射掉

01:23:28.550 --> 01:23:29.250
啊这里

01:23:29.650 --> 01:23:33.250
这里的话我们刚才第一次我们执行的时候

01:23:33.950 --> 01:23:34.850
这里是什么

01:23:35.550 --> 01:23:36.450
是没有输出啊

01:23:36.850 --> 01:23:39.750
对不对啊就几个undefined对不对那你这边就可以干嘛

01:23:39.750 --> 01:23:41.250
你把它改成箭头函数

01:23:41.950 --> 01:23:44.850
就仍然可以解决这个问题啊就不用这个棒的

01:23:49.160 --> 01:23:50.460
啊用这个箭头函数

01:23:50.560 --> 01:23:52.960
那箭头函数呢那z是不会指向他的外一层

01:23:52.960 --> 01:23:54.660
外一层是不是就是这个obj啊

01:23:55.260 --> 01:23:55.760
对不对

01:23:55.860 --> 01:23:57.160
说这边打印出来就是

01:23:57.460 --> 01:23:59.260
看没有张三啊

01:23:59.260 --> 01:24:01.960
这就是这个箭头函数的z指向

01:24:02.060 --> 01:24:03.660
他指向他的这个外一层

01:24:08.540 --> 01:24:10.140
然后下面

01:24:10.640 --> 01:24:11.740
下面我们来看一下哈

01:24:13.140 --> 01:24:13.940
呃

01:24:15.040 --> 01:24:19.140
刚才讲过啊箭头函数的z是指向于普通函数不一样

01:24:19.440 --> 01:24:22.340
他的z是指向始终指向外层作用于

01:24:22.840 --> 01:24:25.440
啊所以这里是指向这个全局的

01:24:26.440 --> 01:24:27.740
啊这个刚是不是已经看了

01:24:27.940 --> 01:24:29.840
啊然后像我们这边我们再来看一个例子

01:24:30.740 --> 01:24:32.840
啊这个例子这边的话有lamb

01:24:32.840 --> 01:24:34.540
然后接下来有一个这个taste

01:24:34.940 --> 01:24:35.840
taste的话

01:24:35.840 --> 01:24:37.640
然后接下来他里面是不是又有一个函数啊

01:24:38.740 --> 01:24:39.740
是不是又有个函数啊

01:24:39.840 --> 01:24:42.040
又有个函数在这边调用i的时候

01:24:42.040 --> 01:24:43.240
那这个函数就是什么呀

01:24:43.440 --> 01:24:44.840
是不是以普通形式调用的

01:24:45.040 --> 01:24:46.240
那这个z就是什么

01:24:46.440 --> 01:24:47.240
是不是全绝

01:24:47.640 --> 01:24:49.440
对不对那你如果是在浏览器里面

01:24:49.440 --> 01:24:51.440
他打印出来就是javascript

01:24:51.840 --> 01:24:53.640
啊比如说我们这边我们来打印一下

01:24:56.440 --> 01:24:57.540
来到浏览器

01:24:57.740 --> 01:24:58.840
把这个清空

01:25:00.240 --> 01:25:00.740
走

01:25:01.140 --> 01:25:01.640
你看

01:25:01.840 --> 01:25:03.440
说打印出来就是javascript

01:25:03.740 --> 01:25:06.440
为什么因为你这边的话你又定义了一个函数

01:25:06.440 --> 01:25:08.740
那加你这边调用啊这里调用

01:25:08.840 --> 01:25:10.840
其实这个函数就是以普通形式调用

01:25:11.040 --> 01:25:12.840
普通形式调用那z是就指向

01:25:13.040 --> 01:25:13.840
是不是全绝对象

01:25:14.340 --> 01:25:14.740
对不对

01:25:14.940 --> 01:25:17.040
好了接下来我把这个代表把它改一下

01:25:17.940 --> 01:25:19.140
我们就在浏览器里面吧

01:25:20.240 --> 01:25:21.640
呃我看怎么改

01:25:22.240 --> 01:25:25.140
这边的话把它改成一个什么的

01:25:25.640 --> 01:25:26.740
这个还不好改

01:25:26.940 --> 01:25:28.740
我们这边到这嘛到这来执行

01:25:30.540 --> 01:25:32.440
在我们的loader环境里面执行

01:25:32.440 --> 01:25:33.540
loader环境里面执行

01:25:33.540 --> 01:25:35.640
那这边他就不是这个javascript了

01:25:36.140 --> 01:25:39.940
因为这个这个边连他不会成为全绝对象的一个属性

01:25:39.940 --> 01:25:41.640
那这边他就应该是这个undefine

01:25:42.940 --> 01:25:43.440
对不对

01:25:43.540 --> 01:25:44.440
就应该是undefine

01:25:44.440 --> 01:25:46.940
让我这边把它改一下改成这个箭头函数

01:25:48.920 --> 01:25:50.020
改成箭头函数之后

01:25:50.020 --> 01:25:51.920
z的指向和它的外称相同

01:25:52.020 --> 01:25:53.020
外称就是谁

01:25:53.220 --> 01:25:54.220
是不是这个ob

01:25:55.120 --> 01:25:56.020
对不对啊

01:25:56.020 --> 01:25:57.120
所以说这边的话就是什么呢

01:25:57.120 --> 01:25:58.120
就是php

01:25:58.620 --> 01:25:59.120
走

01:25:59.620 --> 01:26:00.220
看到没有

01:26:00.620 --> 01:26:01.620
就是php

01:26:01.920 --> 01:26:04.120
啊这就是关于箭头函数

01:26:04.420 --> 01:26:06.420
里面的这个z指向啊

01:26:07.120 --> 01:26:08.620
最后要说一下就是箭头函数

01:26:08.620 --> 01:26:10.920
它是不能作为这个构造函数的

01:26:12.960 --> 01:26:14.760
它不能作为构造函数啊

01:26:14.960 --> 01:26:15.760
比如你看这边

01:26:16.060 --> 01:26:17.760
我们这边写了一个这个箭头函数

01:26:17.760 --> 01:26:18.960
然后接下来的话这边

01:26:19.560 --> 01:26:22.560
我们这边z打印这个z

01:26:22.860 --> 01:26:23.860
不是打印z

01:26:23.860 --> 01:26:26.460
这边的话就是构造函数z点name等于name

01:26:26.460 --> 01:26:27.760
z点h等于h

01:26:27.760 --> 01:26:29.760
这个是不是典型的是构造函数写法

01:26:29.860 --> 01:26:31.060
但唯一不同的是什么

01:26:31.860 --> 01:26:32.660
这边是什么

01:26:32.660 --> 01:26:34.160
是不是一个箭头函数啊

01:26:34.560 --> 01:26:35.660
到时候他就会报错

01:26:35.860 --> 01:26:37.360
报的是一个type error

01:26:37.960 --> 01:26:39.960
test is not a constructor

01:26:40.160 --> 01:26:41.560
它不是一个构造器

01:26:42.860 --> 01:26:43.960
这边你可以看一下

01:26:48.620 --> 01:26:49.920
好这边走

01:26:50.520 --> 01:26:51.020
看到没有

01:26:51.220 --> 01:26:52.920
test is not a constructor

01:26:53.320 --> 01:26:54.320
它不能作为

01:26:55.120 --> 01:26:56.520
就箭头函数

01:26:58.600 --> 01:27:04.200
箭头函数不能作为构造函数

01:27:04.600 --> 01:27:05.800
这最后一个点

01:27:06.500 --> 01:27:09.500
ok讲完了啊讲了一个半小时

01:27:09.700 --> 01:27:11.200
大家估计也挺累了啊

01:27:11.600 --> 01:27:14.100
好你下来的话自己把这个z的指向

01:27:14.300 --> 01:27:15.400
你把它总结一下

01:27:16.400 --> 01:27:18.100
这边的话就讲了这么多

01:27:18.500 --> 01:27:18.900
对不对

01:27:18.900 --> 01:27:20.500
z的指向有来几种

01:27:20.500 --> 01:27:21.600
那其实就是什么呀

01:27:22.400 --> 01:27:24.300
就是我们这边最开始的时候

01:27:24.900 --> 01:27:25.800
这边总结的

01:27:26.500 --> 01:27:27.000
对不对

01:27:27.100 --> 01:27:28.600
其实就这个你把这个

01:27:29.100 --> 01:27:30.100
把它打出来

01:27:30.100 --> 01:27:31.500
然后叫中间这一部分

01:27:31.800 --> 01:27:33.600
中间这部分其中我们就是干嘛

01:27:33.800 --> 01:27:35.700
是举了一些实际的例子来看啊

01:27:36.500 --> 01:27:37.700
对不对啊

01:27:38.100 --> 01:27:40.100
好这些课的话就先到这里

01:27:40.300 --> 01:27:42.600
下来大家把这个z的指向再看一看

01:27:42.600 --> 01:27:44.000
这个很重要啊

01:27:44.400 --> 01:27:45.200
好再见

