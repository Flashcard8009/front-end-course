WEBVTT

00:01.460 --> 00:03.500
大家好 我是谢老师

00:04.020 --> 00:06.060
这节课的话 我们来看一下这个

00:06.580 --> 00:09.140
JS里面的这个包装类型

00:09.400 --> 00:10.420
包装对象

00:11.180 --> 00:12.980
那首先的话 还是从一套

00:13.240 --> 00:16.300
从一到这个真实的这个面试题入手

00:16.820 --> 00:20.660
这面试题问的也很直白啊 就直接问你是否了解

00:20.900 --> 00:23.220
javascript中的包装类型

00:23.740 --> 00:25.780
那么来看一下什么是包装类型呢

00:26.040 --> 00:28.080
我们都知道在这个JS里面

00:28.340 --> 00:29.880
我们的数据

00:30.200 --> 00:31.680
可以分为两大类

00:32.180 --> 00:32.960
哪两大类呢

00:33.220 --> 00:35.260
一个是基本数据类型

00:35.780 --> 00:38.580
基本数据类型 一个是引用类型

00:39.860 --> 00:45.240
那么根据这个JS的这个标准的话 基本数据类型包含什么呢 包含这个undefine

00:45.500 --> 00:46.000
now

00:46.260 --> 00:48.560
然后booling number symbol

00:48.820 --> 00:49.840
和这个stream

00:50.100 --> 00:52.400
然后引用类型 引用类型其实就一个

00:53.180 --> 00:53.940
object

00:54.720 --> 00:57.260
只不过从这个引用类型

00:57.520 --> 00:59.320
又延伸出这个 array

00:59.540 --> 01:00.040
dat

01:00.300 --> 01:01.820
那家这个政则这些

01:02.080 --> 01:04.400
你去打印他们的这个类型的时候

01:04.640 --> 01:06.700
我们返回的其实都是 object

01:07.720 --> 01:10.800
然后基本数据类型和引用

01:11.060 --> 01:11.560
类型

01:12.080 --> 01:13.100
他们有一个最大的

01:13.360 --> 01:13.860
区别

01:14.380 --> 01:16.420
就是我们的这个引用类型

01:16.680 --> 01:18.480
他是因为他是这个对象

01:18.740 --> 01:21.020
说他是可以调用属性和方法的

01:22.060 --> 01:25.380
对不对 他有一些就是自己类制的方法

01:25.640 --> 01:27.440
然后呢也可以调用方法

01:28.300 --> 01:30.220
那么这里的话就是有一个问题

01:30.720 --> 01:33.280
那么我们的这个基本数据类型

01:34.060 --> 01:35.580
他就不能调方法吗

01:36.100 --> 01:38.920
啊 其实严格来讲的话 其实也不是这个样子的

01:39.420 --> 01:42.500
你对于部分基本数据类型来讲

01:42.760 --> 01:45.820
他是不能调方法的啊 比如说这个undefine

01:46.600 --> 01:47.360
now

01:47.880 --> 01:49.140
这两个是不是最明显

01:49.660 --> 01:51.460
这个他确实是没有属性和方法

01:51.720 --> 01:54.020
你调不了 对吧 经常你遇到的错误

01:54.280 --> 01:56.060
怎么counter rate property

01:56.260 --> 01:57.200
undefine

01:57.560 --> 02:00.360
说明这个undefine的话 他是没有这个属性和方法的

02:00.880 --> 02:03.940
那是对于部分基本数据类型来讲

02:04.200 --> 02:06.240
部分是指什么呢 是指的是这个

02:06.760 --> 02:07.880
就是 boolean

02:08.300 --> 02:09.060
lumber

02:09.320 --> 02:10.500
和这个stream

02:11.120 --> 02:12.900
他们其实对应了什么呢

02:13.160 --> 02:17.160
对应了就是相应的这个包装对象类

02:17.920 --> 02:19.560
啊 就是这个大写的 boolean

02:19.820 --> 02:20.540
lumber

02:20.800 --> 02:21.800
和这个stream

02:22.640 --> 02:23.140
看到没有

02:23.400 --> 02:25.200
你可以通过这种包装

02:25.920 --> 02:27.720
就是这三个构造函数

02:27.980 --> 02:32.780
啊 来创建这个对应的这个 boolean number和stream

02:33.040 --> 02:34.620
类型的这个对象

02:34.880 --> 02:36.920
啊 我举个例子 啊 举个例子

02:37.180 --> 02:38.220
比如说

02:39.480 --> 02:40.520
我们这边的话

02:41.020 --> 02:43.340
嗯 挖一个这个

02:43.840 --> 02:44.860
挖一个什么呢

02:45.380 --> 02:46.660
挖一个这个q

02:47.420 --> 02:49.220
挖一个 就是写个 str吧

02:49.980 --> 02:50.740
等于一个

02:51.000 --> 02:51.780
比如 hello

02:52.520 --> 02:53.020
你看

02:53.280 --> 02:55.920
我们平时创建一个制服创 是不是都是这样子创建的

02:56.600 --> 02:57.100
对不对

02:57.360 --> 02:59.420
那你这边还给你提供了一种方式

03:00.180 --> 03:01.200
str2

03:01.460 --> 03:02.980
等于一个new

03:04.280 --> 03:04.780
stream

03:05.560 --> 03:07.100
让你这边啊 传一个

03:08.120 --> 03:09.920
传一个这个这个制服创进去

03:10.160 --> 03:12.720
你看这个是不是就典型的这个面向对象里面的

03:12.980 --> 03:16.000
new 一个这个stream 是不是创建这个

03:16.440 --> 03:17.440
呃 实列

03:17.700 --> 03:19.960
对不对 这个stream的话一看就是是一个类

03:20.260 --> 03:23.240
或者说它是一个构造函数 让我new一下它

03:23.500 --> 03:26.580
new一下它 是不是创建一个它的这个实力对象出来

03:27.080 --> 03:27.580
看到没有

03:27.840 --> 03:28.840
不仅是这个

03:29.340 --> 03:32.460
啊 包括比如说我这边挖一个i 等于一个e

03:32.720 --> 03:33.980
啊 平时我们这边

03:35.020 --> 03:37.580
创建一个这个存出准数的这个变量

03:37.840 --> 03:40.380
啊 是不是很简单 对不对 那你这边的话也可以通过什么呢

03:40.640 --> 03:42.180
也可以通过这种方式

03:42.440 --> 03:44.220
比如说等于一个new

03:44.480 --> 03:45.260
lumber

03:47.410 --> 03:48.410
newlumber

03:48.670 --> 03:49.950
然后加这边的话2

03:50.990 --> 03:51.490
看到没有

03:51.710 --> 03:53.330
啊 包括那个就是

03:55.010 --> 03:57.570
包括这个布尔兹也是啊 比如我们这边

03:57.830 --> 03:58.330
q

03:58.710 --> 04:00.490
是吧 那你这边的话可以这个样子

04:01.010 --> 04:03.830
e is a pass 等于一个new

04:04.610 --> 04:05.110
布林

04:05.370 --> 04:07.930
啊 大家这边传一个这个force进去

04:08.690 --> 04:09.570
啊 也就是说

04:09.830 --> 04:11.250
呃 这个stream

04:11.770 --> 04:13.050
然后接下来lumber

04:13.310 --> 04:14.450
和这个布林

04:14.970 --> 04:16.370
啊 他们都有对应的什么

04:16.630 --> 04:18.170
都有对应的这个

04:18.430 --> 04:19.770
包装对象内

04:20.070 --> 04:24.790
你通过这个包装对象内的话 你就可以创建出对应的这个对象出来

04:25.050 --> 04:26.890
也就是说这边str2 他是个对象

04:27.150 --> 04:29.190
你注意这个接是个对象

04:29.450 --> 04:30.470
这个e is a pass

04:30.990 --> 04:31.750
是一个对象

04:32.270 --> 04:34.070
啊 那接下来是对象我就可以干嘛呀

04:34.310 --> 04:35.590
我是不是就可以调方法呀

04:36.350 --> 04:41.470
对不对 好 比如说我们以这个lumber为例嘛 比如说我这边我写一个3.1415

04:42.350 --> 04:43.270
926

04:44.030 --> 04:45.590
是吧 写个长一点的

04:45.830 --> 04:48.390
好 然后接下来我这边的话我就可以调方法

04:49.090 --> 04:51.930
调什么呢 接点to fixed

04:52.690 --> 04:55.250
看到没有 然后我保留两位

04:55.510 --> 04:57.570
啊 然后我们这边让我们来执行一下

04:57.810 --> 04:58.330
走

04:59.090 --> 05:01.910
看到没有 说很明显你看这里我是不是在调方法

05:02.930 --> 05:04.210
啊 在调用方法

05:04.470 --> 05:08.310
啊 这就是首先第一个 什么是这个包装对象

05:08.570 --> 05:11.630
啊 每一个 就是你的这个stream

05:11.890 --> 05:12.670
stream

05:12.930 --> 05:14.190
lumber和布林

05:14.450 --> 05:16.390
他们都有自己对应的

05:16.650 --> 05:17.530
包装对象内

05:17.830 --> 05:20.030
你可以通过这个包装对象内

05:20.290 --> 05:22.850
来实力化出对应内形的这个

05:23.370 --> 05:24.390
包装对象出来

05:24.650 --> 05:28.230
啊 有了这个包装对象 你就可以干嘛呢 你是不是就可以调方法了

05:28.990 --> 05:29.510
看到没有

05:29.770 --> 05:31.050
啊 这是第一点

05:31.810 --> 05:33.610
好 然后接下来我们继续往后面看啊

05:34.630 --> 05:40.270
有三个是e是提供了对应的特殊引用内心啊 包装内心就是布林lumber stream

05:40.530 --> 05:41.550
这个刚才是不是已经说了

05:42.830 --> 05:45.910
好 然后基本包装内心和其他引用内心一样

05:46.210 --> 05:51.750
拥有这个类制的方法可以对数据进行额外操作啊 这个刚才是不是也看了

05:52.530 --> 05:54.050
对不对啊 你看比如说这边

05:55.090 --> 05:56.610
这边就是我们这边这个接

05:56.870 --> 05:59.170
接的话 你看我们这边是不是就直接调方法了

05:59.430 --> 06:02.510
啊 但是我们这边我们要思考一个问题

06:03.010 --> 06:03.770
什么问题呢

06:04.030 --> 06:06.090
就是我这边的话 我的这个i

06:06.610 --> 06:09.170
i的话我是不是普通数据类型lumber

06:09.430 --> 06:11.210
对不对 那么他的话

06:11.470 --> 06:13.510
他就真的不能够调方法了吗

06:14.510 --> 06:16.710
他就不能够调方法了吗 包括这个

06:17.110 --> 06:19.350
这个是不是普通的数据类型布林

06:19.610 --> 06:21.650
这个是不是普通的数据类型street

06:21.910 --> 06:25.150
他就不能调方法了吗啊 比如说我们这边我们log一下

06:25.410 --> 06:28.310
console.log str

06:29.070 --> 06:34.710
我们来调一下他的这个方法啊 比如说就掉我那里面的那个例子char and

06:35.950 --> 06:41.870
有0 你看我这个str明明是一个什么 是不是是一个普通数据类型这个street

06:42.070 --> 06:44.510
但是我们来看一下这边调这个方法能不能成功

06:45.510 --> 06:51.310
能不能成功是不可以成功对来 包括这个包括这个i啊 我们这边来看一下

06:51.810 --> 06:56.270
console.log 1点有2fixed

06:56.810 --> 07:00.510
好 这边没有没有好像是要两个啊fixed

07:01.470 --> 07:03.070
好 比如说这边的话2

07:05.980 --> 07:10.880
是不是出来了 成功没有 这不成功了啊 有同学可能会觉得这边为什么要

07:11.360 --> 07:17.480
打两个点 打两个点是这样子的 你如果打打一个点的话 他可能会以为你这个是小数点

07:18.480 --> 07:25.080
对吧 因为我们这个小数点是不是也有一个点 对吧 既然你打两个点的话 他就会知道你这边是要调方法

07:25.440 --> 07:28.400
啊 所以这边呢 他就是ok的 你打一个点他就会爆错

07:29.320 --> 07:36.560
可不可以啊 他就会爆错啊 这边的话要打两个点 或者什么呢 或者还有一种方式就是把这个扩起来

07:37.560 --> 07:45.280
扩起来 你就可以打一个点了 因为扩起来的话 那这个这个点就肯定不是小数点 而是什么 是不是调用方法的那个点

07:46.080 --> 07:53.400
对不对 ok 好那现在的话 我们就很明显的看到什么呀啊 我这边写一下啊 就是通过上面

07:54.600 --> 08:04.090
通过通过上面 第什么呢 第十一行十二行十三行代码

08:05.490 --> 08:07.530
啊 我们惊讶的

08:08.130 --> 08:12.530
发现 发现什么 是普通数据内心也可以

08:13.890 --> 08:15.450
普通数据

08:16.410 --> 08:20.250
内心也可以调用方法

08:21.690 --> 08:24.130
或者访问这个属性 你这边比如说你打印这个

08:25.530 --> 08:28.450
st2.认识 那肯定也是可以把它的认识

08:29.010 --> 08:32.370
答应出来的 也可以这个访问属性

08:33.850 --> 08:37.490
啊 我这边就是就可以使用属性方法

08:38.250 --> 08:41.490
好吧 也可以使用属性方法 那为什么呢

08:42.410 --> 08:52.650
哎 我们这边我们要思考为什么 就你这边的话 你比如说针对str 针对这个接 针对这个啊 这边一字pars应该是二啊 针对这个一字pars二

08:53.250 --> 08:56.010
你使用这个属性和方法 我这个我是不好理解

08:57.130 --> 09:01.490
对不对 这个我很好理解 为什么 因为你这边是new的十准 new的number new的玻璃

09:01.890 --> 09:08.610
它是一个对象 但是你这个str 你的这个i 你的这个一字pars 他是不是普通数据内心

09:09.770 --> 09:14.210
普通数据内心他竟然也可以使用属性和方法 为什么呢

09:15.210 --> 09:16.970
原因很简单啊 因为

09:18.810 --> 09:25.650
因为当我们使用属性和方法的时候

09:26.650 --> 09:30.890
JS内部会自动

09:31.770 --> 09:34.330
进行一个转换

09:35.570 --> 09:38.570
进行什么转换呢 会自动

09:39.570 --> 09:42.850
生成一个包装对象

09:43.970 --> 09:45.570
看到没有 就这么简单

09:46.770 --> 09:54.250
因为他内部的话 他生成了一个对应的包装内象 比如说你这边st2 是吧 然后接下来我内部的话 我给你new了一个st2

09:54.770 --> 10:02.690
你这边是i 是吧 i是等于1 那这样我给你new了一个number啊 这边相当于就是什么呢 相当于我就是给你new了一个

10:03.410 --> 10:05.170
number 然后加这边的话是1

10:05.930 --> 10:14.290
看到没有 当我在调用这个方法的时候啊 调用方法或者使用属性的时候 它其实内部有一个这么一个这个操作啊 包括这边也是

10:16.090 --> 10:17.290
我这边写下哈 当

10:18.970 --> 10:22.130
使用属性方法时

10:23.130 --> 10:28.730
内部啊 内部调用什么呢 这个new number

10:29.410 --> 10:35.850
然后生成一个零食的包装对象

10:36.650 --> 10:40.250
看到没有 它其实是这个样子的啊 然后加这边也是一样

10:41.490 --> 10:44.090
这边也是一样 这边就是调用什么啊 是吧Stream

10:44.850 --> 10:46.370
然后加这边呢 是传了一个

10:47.370 --> 10:48.090
是吧哈喽

10:49.370 --> 10:54.850
看到没有啊 下面我这个就不写了啊 它其实有这么一个步骤

10:55.570 --> 10:58.370
可没有啊 我们这边回到我们的这个课件

10:59.850 --> 11:09.330
回到我们的课件 好 上面的stream是一个基本类型 我把这个代码看一下 这边的st2等于一个这个哈喽 是不是基本类型 然后加这边是不是在调用方法

11:10.050 --> 11:15.890
可没有这个其实就是我们刚才代码里面所说的 他也是可以调用方法的 为什么呢 原因很简单

11:16.490 --> 11:21.890
就是我们在执行第二行代码的时候 他后台其实做了这三个步骤

11:22.810 --> 11:28.770
哪三个步骤 我们一个一个来看 首先自动创建stream类型的一个实例

11:29.730 --> 11:34.570
注意哦 他和基本类型的籽不同啊 他是一个包装类像的籽 就是相当于new那个stream

11:35.330 --> 11:40.930
啊 就相当于newstream 好 再调用这个包装对象上面的指定的这个方法

11:41.770 --> 11:44.330
然后接下来注意 他还会销毁这个包装对象

11:45.250 --> 11:48.530
看到没有啊 然后再解释下来的话 其实就是这个样子的

11:49.690 --> 11:51.570
首先你这边是吧st2是哈喽

11:52.370 --> 11:57.290
好 然后注意你这边第二行代码 第二行代码你这边是不是在调用这个char enter了

11:57.970 --> 12:04.970
然后接下来他后台其实就会执行这三个步骤 然后相当于什么呢 首先他new一个stream

12:06.250 --> 12:10.890
看到没有 new一个stream 然后再直为什么呢 直为哈喽 然后再这个下滑线st2

12:11.290 --> 12:13.410
下滑线st2是不是他是一个包装对象

12:14.610 --> 12:21.450
对不对 他是个包装对象 那么他自然而然就可以干嘛呀 是不是调用属性的方法 好他叫我这边调用什么

12:21.850 --> 12:23.210
调用这个char end

12:23.850 --> 12:26.370
我查这儿写错了哈 这边少一个r

12:28.540 --> 12:30.060
这边我调用这个char end

12:31.100 --> 12:36.460
所以调用这个方法 调用这个方法 这样拿到结果 拿到结果 然后给谁 是不是给这个s2

12:36.980 --> 12:43.460
给了之后 还有最后一步 这个下滑线st2 就是我们生存的对应的包装对象 他会干嘛

12:43.900 --> 12:45.380
这会被销毁掉

12:46.620 --> 12:50.940
看到没有 他会被销毁掉啊 对应的其实就是这三个步骤

12:51.940 --> 12:53.660
明白没有啊

12:54.860 --> 13:06.660
好 下面 下面这边啊 我们这边继续来看嘛 基本内向的值虽然没有方法可以调用 但是后台临时创建的包装对象上有类似方法可以让我们调用方法

13:06.980 --> 13:12.900
sb就刚才所说的 对不对 他会创建一个包装对象啊 因此我们可以进行更多的操作

13:13.860 --> 13:21.500
好 这个不说了 然后什么时候后台会自动创建这个包装对象呢 这个的话是后台他自动完成的

13:22.180 --> 13:27.700
自动完成的啊 当你使用就是属性或者调用方法的时候 他就会创建

13:30.020 --> 13:34.540
好 然后还有一个 还有一个是什么呢 就是这边

13:35.220 --> 13:39.060
我们来看一下这个代码 挖了一个这个test 这个是一个制服串

13:39.540 --> 13:44.820
好 然后接下来的话 这边我们再打印他的这个值 打印他的值 然后接下来这边的话 他是我们在

13:45.340 --> 13:50.780
获取他的值 获取他的值的时候 他这边也会创建一个包装对象类型

13:51.700 --> 13:55.180
看到没有 也说你这边的话 其实你在读取他的这个值的时候

13:55.820 --> 14:02.900
他也是创建一个包装对象 然后接下来从这个包装对象上面 然后接下来调用这个方法

14:03.340 --> 14:06.180
比如value of 然后把这个值给你

14:07.060 --> 14:13.740
好 然后还有一个啊 这个其实是我重点要说的 就是我们的这个

14:14.580 --> 14:21.180
普通数据类型啊 你看我们普通数据类型和引用数据类型有个最大的区别 就是什么呢 你这边的话没有办法

14:21.580 --> 14:25.420
给他添加属性和方法啊 什么意思 比如说我们这边我们举个例子

14:27.260 --> 14:34.300
呃 上面呢 我就注释掉吧 比如我们这边就把它注释掉 比如我们这边

14:34.900 --> 14:43.940
哇 一个test 等于一个对象啊 那对象的话 我这边是不是上面随便添加东西啊 对不对啊 比如说lame

14:44.620 --> 14:52.110
等于一个细节 我再给他添加一个这个方法 test 点比如 say hello

14:53.630 --> 14:54.950
等于一个function

14:56.990 --> 14:59.750
log 好 然后加这边比如说Hello

15:00.390 --> 15:05.710
那我这边的话引用数据类型我是不是随便给他添属性和方法 对不对 比如我们这边的log一下

15:06.550 --> 15:13.550
log一下 test 点lame 啊 然后加这边调用一下 test 点 say hello

15:15.190 --> 15:25.690
好 我们这边让我们来运行一下 是不是OK的 对不对 但是你普通数据类型 这个普通数据类型就不行

15:26.090 --> 15:29.410
啊 比如我们这边让我们挖一个这个i 等于一个e

15:29.970 --> 15:36.370
那既然我这边我给这个i添加一个这个test 等于一个Hello

15:37.370 --> 15:42.810
啊 然后接下来我们这边log一下log一下 i 点test

15:44.130 --> 15:47.170
你会发现这边得到的是什么呢 得到了是undefine

15:48.330 --> 15:56.730
得到的是undefine 为什么呢 为什么他会得到是undefine呢啊 就是因为我们的这个i的话他是一个普通数据类型

15:57.370 --> 16:01.450
普通数据类型你是没办法给他添加属性和方法的

16:02.130 --> 16:08.250
啊 那就其他这个背后其实发生了什么呢 我们来看一下 它背后的话其实是这个样子的

16:09.130 --> 16:10.530
是这样子的啊 比如说我们这边

16:11.890 --> 16:14.650
嗯 这个st2 等于一个这个Hello

16:15.490 --> 16:23.290
对吧啊 这个是一个普通类型的支付创 那将我这边给他添加一个number 等于一个这个10啊 那他背后其实发生了什么事情呢

16:23.610 --> 16:30.890
背后当你这边你要给这个st2添加东西的时候 他后台的话他这边首先会生成一个

16:31.250 --> 16:32.370
包装对象

16:33.610 --> 16:37.250
看到没有 他会生成对应的这个包装对象 然后你的这个属性

16:38.370 --> 16:41.010
或者你的方法 其实是挂在哪上面的

16:42.450 --> 16:47.170
其实是挂在哪上面的 其实是挂在这个包装对象上面的

16:48.130 --> 16:55.170
看到没有啊 哎 其实是挂在这个包装对象上面的 所以说 然后最后你因为最后一步最后一步这个包装对象是不是又会被销毁掉

16:56.170 --> 17:04.210
没有没有 哎 说说你最终的话 你访问上他就是一个 啊 也就是说回到我们的这边代码 也就是说当我们执行29行代码的时候

17:04.570 --> 17:06.170
我这边写一下哈 当

17:08.090 --> 17:09.210
当执行

17:11.290 --> 17:13.610
执行29行

17:15.410 --> 17:18.450
代码的时候 实际上

17:19.450 --> 17:23.530
后台执行了以下的操作

17:26.480 --> 17:32.600
以下的操作 什么操作呢 他首先是吧 挖了一个下滑线

17:33.200 --> 17:34.200
等于一个这个new

17:35.280 --> 17:36.920
lumber 然后在这边

17:37.920 --> 17:38.280
是一

17:39.280 --> 17:41.920
对不对 然后接下来的话 你的这个下滑线

17:44.040 --> 17:48.720
下滑线 然后既然你是不给他挂了一个这个test 等于一个

17:49.400 --> 17:49.800
好了

17:50.600 --> 17:56.280
对不对 然后接下来的话 他最后一步他的这个对应的包装这个对象 他是会被销毁的

17:56.800 --> 17:58.760
说最终他这个等于一个这个空

17:59.480 --> 18:04.360
所以你最后再访问这个i的时候这个tester 他肯定就是一个unlify

18:05.840 --> 18:08.240
看到没有 肯定就是一个unlify

18:09.360 --> 18:15.240
那当然这个时候有的同学就会又会要问了 那我如果直接就是一个包装对象 那行不行了

18:15.720 --> 18:22.440
那肯定可以 你如果直接是一个包装对象 那肯定是没有问题的啊 比如我们这边我们可以来测试一下

18:23.600 --> 18:26.360
比如我这边 挖一个i等于的这个new

18:27.440 --> 18:32.240
lumber 啊 比较一 那他现在的话是不是就是你直接声明其实他就是一个对象

18:32.680 --> 18:36.080
好 那你现在的话是没有问题的啊 比如我们这边的话

18:37.680 --> 18:40.320
然后接下来的话 这边log id

18:40.960 --> 18:41.400
tester

18:42.320 --> 18:42.720
啊走

18:43.640 --> 18:47.560
这不可以了 对不对啊 你这样子是可以的 为什么 因为他就是个包装对象呀

18:48.240 --> 18:56.480
啊 他和你这个表你这个是是个基本数据内心 基本数据内心你往上面挂属性的时候 他背后其实是挂在他的包装对象上面的

18:57.560 --> 19:00.360
明不明啊 这边我们写下嘛 如果

19:02.400 --> 19:07.000
如果直接声明的时候就是

19:07.760 --> 19:10.560
包装对象内心

19:11.520 --> 19:11.960
那么

19:13.440 --> 19:17.720
是可以添加属性方法的

19:18.880 --> 19:23.600
啊 因为是一个对象 对吧 你包装对象最终他也是一个对象

19:24.480 --> 19:27.920
明白没啊 好 那接下来最后一个知识点

19:29.320 --> 19:31.520
最后一个知识点是什么呢 最后一个知识点就是

19:32.400 --> 19:38.480
那我们如何给这个基本内心 添加方法和属性呢 啊 比如说我现在的话我有一个

19:39.480 --> 19:46.720
比如刚才我们这个这个1 是吧 一然后将我要给他添加一个这个taste 那接下来我这边如何给他添加了

19:47.040 --> 19:52.440
好了 很简单 那就是把你的属性或者方法添加到哪里的添加到原型上面

19:53.360 --> 19:59.640
我们通过这个构造函数点这个port type 是不可以访问到他的这个原型

20:00.360 --> 20:05.400
对不对 那我们这边可以添加到他的这个原型上面 比如说我们这边的话就可以

20:06.400 --> 20:10.080
首先lumber 是我们的构造函数 然后加这边port type

20:10.920 --> 20:14.760
点什么点taste 等于一个Hello

20:15.760 --> 20:21.720
看到没有 那这个时候你就可以了 用这边log 那加这边i点taste

20:22.320 --> 20:27.920
啊 他这边的话 当你这个访问的时候 他仍然这边会生成一个什么 这会生成一个这个包装对象

20:28.640 --> 20:33.560
对不对 生成个包装对象 再加这边访问这个taste 由于你这个taste属性是挂在这个原型上面的

20:33.800 --> 20:36.080
他是可以访问的到的 所以打印出来

20:37.800 --> 20:42.040
啊 哦 这边你要声明一下 哇 一个i 等于一个e

20:43.840 --> 20:48.560
好 然后加这边我们重新来 是不是OK的

20:49.520 --> 20:55.840
看到没有 OK的啊 只要你把它挂在他的原型上面啊 挂在原型上面就OK了

20:56.880 --> 21:00.480
好 这是关于我们的这个包装对象内心

21:01.200 --> 21:07.960
好 然后再下面啊 下面是这个 这道题的参考答案 是否了解javascript中的包装内心

21:08.400 --> 21:10.520
啊 那其实就是上面我们所讲的

21:11.200 --> 21:14.520
对吧 你把上面所讲的你自己 最好用你自己的话

21:15.160 --> 21:18.160
把它总结一下啊 虽然我这边的话有这个参考

21:18.880 --> 21:22.360
有这个参考啊 包装对象就是以基本内心

21:23.160 --> 21:29.880
就是基本内心以对象的方式去使用啊 他会生成一个对应的包装内心啊 相当于另一个对象

21:30.280 --> 21:35.960
这边的话有一些这个参考的话 但是你最好就是什么呢 把上面讲的东西你自己理解了

21:36.560 --> 21:43.920
理解了之后 然后既然你用你自己的话 你把它概括出来 这样子是最好的 这样子你的记忆也是最深的

21:44.720 --> 21:48.120
对不对 好吧 好 这一课就先到这里 拜拜

