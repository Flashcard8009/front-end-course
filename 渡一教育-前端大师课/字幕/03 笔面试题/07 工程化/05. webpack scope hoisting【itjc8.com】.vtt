WEBVTT

00:00.370 --> 00:04.170
好 来说一下这个WeiPackScope Hoisting

00:04.170 --> 00:06.970
这个玩意呢 它其实就是一道面试题

00:06.970 --> 00:11.770
它会问你 请你介绍一下这个WeiPackScope Hoisting

00:11.770 --> 00:14.570
或者说这个玩意到底是干嘛用的

00:14.570 --> 00:16.570
其实这个东西还是比较简单的

00:16.570 --> 00:21.170
它是 它的全称叫做WeiPack作用预优化

00:21.170 --> 00:22.970
其实这个单词里面稍微翻译一下

00:22.970 --> 00:24.770
你能得到这个答案

00:24.770 --> 00:27.170
Scope什么意思 作用预

00:27.170 --> 00:30.570
对啊 Hoisting就是提升

00:30.570 --> 00:33.170
表示的是WeiPack作用预提升

00:33.170 --> 00:34.370
这是什么东西呢

00:34.370 --> 00:37.770
它其实就是一个WeiPack的优化手段

00:37.770 --> 00:40.170
简单来说的话就是

00:40.170 --> 00:43.170
咱们在使用这个WeiPack打包的时候

00:43.170 --> 00:46.770
比方说我们这里有一个小的demo程序

00:46.770 --> 00:48.370
安装的东西也很简单

00:48.370 --> 00:50.770
就安装了一个WeiPack 一个WeiPack Lee

00:50.770 --> 00:54.170
然后我配置了一下这个两个命令

00:54.170 --> 00:56.370
一个是生产环境打包

00:56.370 --> 00:58.770
一个是开发环境打包

00:58.770 --> 01:00.170
好 在默认情况下

01:00.170 --> 01:02.570
如果说你是一个开发环境打包的话

01:02.570 --> 01:03.970
比方说我们来run

01:03.970 --> 01:06.770
demo 是不是开发环境打包

01:06.770 --> 01:08.170
那么这个打包完成之后

01:08.170 --> 01:10.370
我们来看一下打包结果

01:10.370 --> 01:11.770
这个结果同学们之前

01:11.770 --> 01:14.170
学习课程的时候都已经看到过了

01:14.170 --> 01:18.170
它其实就是把每一个模块放到一个函数里边

01:18.170 --> 01:20.170
对吧 这样子隔离作用预

01:20.170 --> 01:21.170
这是一个函数

01:21.170 --> 01:23.570
这个index有点介石的模块

01:23.570 --> 01:24.470
然后另外一个模块

01:24.470 --> 01:25.870
你看我们这里有两个模块

01:25.870 --> 01:28.470
一个是module 得到一个随机数

01:28.470 --> 01:29.670
导出一个函数

01:29.670 --> 01:33.470
另外入口模块这里使用函数

01:33.470 --> 01:37.470
循环20次 每次循环得到一个随机数

01:37.470 --> 01:38.470
非常简单

01:38.470 --> 01:39.670
然后打包结果里边

01:39.670 --> 01:41.770
它就会把这两个模块分开

01:41.770 --> 01:43.870
一个是我们的入口模块

01:43.870 --> 01:44.470
一个函数

01:44.470 --> 01:45.970
对吧 不用去看里边了

01:45.970 --> 01:46.870
它是不是一个函数

01:46.870 --> 01:48.070
对吧 是个函数

01:48.070 --> 01:49.470
然后这个是module

01:49.470 --> 01:50.770
我们另外一个模块

01:50.770 --> 01:52.470
还会把它放到一个函数里边

01:52.470 --> 01:54.470
这是它的打包结果

01:54.470 --> 01:57.470
那么这样子一来 其实没有什么问题

01:57.470 --> 01:59.470
所以有什么问题 没有什么问题

01:59.470 --> 02:01.470
就应该这样做隔离作用预

02:01.470 --> 02:04.470
但是在运行的时候会产生两个问题

02:04.470 --> 02:06.070
一个问题函数太多了

02:06.070 --> 02:09.470
那势必会增加我们打包结果的代码

02:09.470 --> 02:10.470
你看两个函数

02:10.470 --> 02:12.470
你首先这么一坨得写吧

02:12.470 --> 02:14.070
对吧 这些东西都得写

02:14.070 --> 02:16.470
这些都会占用文件的尺寸

02:16.470 --> 02:18.470
会增加我们的代码的

02:18.470 --> 02:20.470
最终打包结果的尺寸

02:20.470 --> 02:21.470
这是一个

02:21.470 --> 02:23.470
那么第二个问题会影响

02:23.470 --> 02:27.470
或多或少会影响执行效率

02:27.470 --> 02:28.470
为什么呢 因为我们

02:28.470 --> 02:30.470
其实最高的执行效率是什么

02:30.470 --> 02:31.470
就没有函数

02:31.470 --> 02:33.470
就我们重复的执行到位

02:33.470 --> 02:35.470
当然这是不可能的 对吧

02:35.470 --> 02:37.470
因为我们要追求代码重用

02:37.470 --> 02:40.470
函数肯定得有 但是函数越少越好

02:40.470 --> 02:42.470
不要有这么多函数

02:42.470 --> 02:43.470
每一次函数调用

02:43.470 --> 02:45.470
根据我们之前学过的知识

02:45.470 --> 02:47.470
都会有哪些事情要做

02:47.470 --> 02:50.470
是不是要有一个执行站

02:50.470 --> 02:53.470
会创建执行上下文

02:53.470 --> 02:57.470
然后把执行上下文的添加到执行站

02:57.470 --> 03:00.470
执行上下文里边又有AOVO

03:00.470 --> 03:01.470
一大堆东西

03:01.470 --> 03:04.470
所以说要提高执行效率的话

03:04.470 --> 03:05.470
函数不能避免

03:05.470 --> 03:09.470
但是我们可以在打包的时候

03:09.470 --> 03:11.470
尽量优化我们的代码

03:11.470 --> 03:13.470
减少函数的生成

03:13.470 --> 03:15.470
那么这是我们

03:15.470 --> 03:16.470
如果说把它每个模块

03:16.470 --> 03:17.470
放到一个函数里面

03:17.470 --> 03:19.470
那么就会造成这两个问题

03:19.470 --> 03:22.470
一个就是代码尺寸会增加

03:22.470 --> 03:26.470
第二个是运行效率会有点低

03:26.470 --> 03:28.470
因为我们知道

03:28.470 --> 03:29.470
在真实的开发里边

03:29.470 --> 03:31.470
一个完成的工程

03:31.470 --> 03:33.470
模块多得不得了

03:33.470 --> 03:35.470
同学们做过一些项目了

03:35.470 --> 03:37.470
就是之前的维尤类项目

03:37.470 --> 03:38.470
这个项目里边

03:38.470 --> 03:39.470
给你看这个模块

03:39.470 --> 03:40.470
是不是特别特别多

03:40.470 --> 03:42.470
就是这么一个道理

03:42.470 --> 03:44.470
因此我们这一块要优化

03:44.470 --> 03:45.470
怎么优化呢

03:45.470 --> 03:48.470
其实就完全可以在打包

03:48.470 --> 03:49.470
不影响我们写代码

03:49.470 --> 03:51.470
写代码里该咋写咋写

03:51.470 --> 03:53.470
该分模块分模块

03:53.470 --> 03:55.470
该写函数写函数

03:55.470 --> 03:56.470
只是在打包的时候

03:56.470 --> 03:59.470
让VPAC自动帮我们优化

03:59.470 --> 04:01.470
其实我们什么也不用看

04:01.470 --> 04:02.470
啥也不用看

04:02.470 --> 04:05.470
VPAC自动帮我们完成了

04:05.470 --> 04:07.470
就是它在打包的时候

04:07.470 --> 04:09.470
它会把这些模块

04:09.470 --> 04:10.470
合并到一起

04:10.470 --> 04:12.470
就是这么个意思

04:12.470 --> 04:13.470
合并到一起了之后

04:13.470 --> 04:14.470
他们的作用预

04:14.470 --> 04:16.470
是不是就不再隔离了

04:16.470 --> 04:17.470
那么就相当于

04:17.470 --> 04:19.470
提升到了一个作用预里面

04:19.470 --> 04:21.470
这就要做作用预提升

04:21.470 --> 04:22.470
那么什么情况下

04:22.470 --> 04:25.470
VPAC会干这样的事呢

04:25.470 --> 04:26.470
非常简单

04:26.470 --> 04:28.470
你只要生产环境打包就可以了

04:28.470 --> 04:29.470
比方说我们现在

04:29.470 --> 04:31.470
因为我们最终代码写完之后

04:31.470 --> 04:33.470
要放到服务器

04:33.470 --> 04:36.470
是不是都会进行生产环境打包

04:36.470 --> 04:37.470
所以我们这里运行是

04:37.470 --> 04:42.610
NPM装备物的

04:42.610 --> 04:44.610
生产环境打包完成之后

04:44.610 --> 04:45.610
你看一下这个代码

04:45.610 --> 04:46.610
这个代码就

04:46.610 --> 04:48.610
首先它有一些压缩混淆

04:48.610 --> 04:49.610
已经变成一行了

04:49.610 --> 04:51.610
也不是一行

04:51.610 --> 04:52.610
其实只有一行

04:52.610 --> 04:53.610
你看着

04:53.610 --> 04:54.610
只有一行

04:54.610 --> 04:56.610
只是这里排不下了

04:56.610 --> 04:57.610
我们把它格式画一下

04:57.610 --> 04:59.610
保存格式画一下

04:59.610 --> 05:01.610
看这

05:01.610 --> 05:03.610
是不是我们刚才的代码

05:03.610 --> 05:06.610
得到一个随机数的函数变成N

05:06.610 --> 05:08.610
然后我们循环20次

05:08.610 --> 05:11.610
每次输出一个随机数

05:11.610 --> 05:12.610
会发现这个函数

05:12.610 --> 05:14.610
和我们打印随机数的代码

05:14.610 --> 05:15.610
是不是放到一起了

05:15.610 --> 05:18.610
这就是作用语提升

05:18.610 --> 05:19.610
就这么简单

05:19.610 --> 05:20.610
其他的里面杀了

05:20.610 --> 05:23.610
因此你这一块面试你怎么回答

05:23.610 --> 05:24.610
我给大家看一下

05:24.610 --> 05:27.610
Skob Heisting是VPAC的内置优化

05:27.610 --> 05:29.610
它针对模块的优化

05:29.610 --> 05:32.610
在生产环境打包的时候会自动开启

05:32.610 --> 05:33.610
在没有开启的时候

05:33.610 --> 05:36.610
VPAC会把每一个模块的代码

05:36.610 --> 05:38.610
放到一个独立的函数环境里边

05:38.610 --> 05:39.610
就我们之前看的

05:39.610 --> 05:40.610
每一个模块

05:40.610 --> 05:42.610
它会把它用函数来进行隔离

05:42.610 --> 05:46.610
保证作用语相互不影响

05:46.610 --> 05:48.610
而这个作用语提升的作用

05:48.610 --> 05:49.610
刚刚相反

05:49.610 --> 05:50.610
它是把多个模块的代码

05:50.610 --> 05:53.610
合并到一个函数环境里边

05:53.610 --> 05:54.610
就在这儿

05:54.610 --> 05:58.610
跑到一个函数环境里边去了

05:58.610 --> 06:00.610
当然它会做一些处理

06:00.610 --> 06:02.610
包括那些名字冲突了怎么办

06:02.610 --> 06:03.610
它会给你重新命名

06:03.610 --> 06:05.610
它都会进行处理

06:05.610 --> 06:07.610
那么这样的好处

06:07.610 --> 06:09.610
是为了减少函数的调用

06:09.610 --> 06:10.610
少了一些函数

06:10.610 --> 06:11.610
调用的函数少了

06:11.610 --> 06:13.610
自然运行效率就提升了

06:13.610 --> 06:15.610
同时也降低了打包体积

06:15.610 --> 06:17.610
但是这个玩意

06:17.610 --> 06:19.610
它的启用是有一些前提条件的

06:19.610 --> 06:21.610
如果说遇到一些比较特殊的情况

06:21.610 --> 06:22.610
比方说像某些模块

06:22.610 --> 06:25.610
多次被其他很多模块都在使用

06:25.610 --> 06:26.610
那么这个时候

06:26.610 --> 06:28.610
它就不好处理了

06:28.610 --> 06:30.610
还或者是你用了动态导入

06:30.610 --> 06:31.610
动态导入了

06:31.610 --> 06:33.610
因为它也不知道你

06:33.610 --> 06:35.610
到时候什么情况下会有依赖

06:35.610 --> 06:37.610
什么情况下会导入什么模块

06:37.610 --> 06:39.610
因为动态导入的时候

06:39.610 --> 06:41.610
我们知道动态导入的时候

06:41.610 --> 06:43.610
这个玩意还可以写个辩量

06:43.610 --> 06:44.610
对吧

06:44.610 --> 06:46.610
所以说这个玩意就不好

06:46.610 --> 06:47.610
不是很好办的

06:47.610 --> 06:49.610
还有一些时候

06:49.610 --> 06:50.610
还有一些就是那种

06:50.610 --> 06:51.610
非ES module

06:51.610 --> 06:53.610
就是用common.js的方式

06:53.610 --> 06:55.610
来进行导入导出

06:55.610 --> 06:57.610
因为用这种方式的话

06:57.610 --> 06:58.610
会

06:58.610 --> 06:59.610
本身就是动态的

06:59.610 --> 07:00.610
对吧

07:00.610 --> 07:01.610
因为我们知道common.js

07:01.610 --> 07:02.610
本身就是动态的

07:02.610 --> 07:03.610
所以说它也会有这样的一个问题

07:03.610 --> 07:04.610
那么这个时候

07:04.610 --> 07:05.610
它就会

07:05.610 --> 07:07.610
做一些其他处理

07:07.610 --> 07:09.610
就不能用这种方式了

07:09.610 --> 07:10.610
那么具体来说

07:10.610 --> 07:11.610
它到底是怎么处理

07:11.610 --> 07:13.610
什么情况下做什么处理的

07:13.610 --> 07:15.610
面试它不会问到

07:15.610 --> 07:16.610
因为这一块

07:16.610 --> 07:18.610
细节就非常非常细了

07:18.610 --> 07:19.610
如果说有兴趣的同学

07:19.610 --> 07:21.610
可以看这个文档

07:22.610 --> 07:23.610
这个文档里边

07:23.610 --> 07:24.610
它描述的很详细

07:24.610 --> 07:25.610
就这一块

07:25.610 --> 07:26.610
看这一块

07:26.610 --> 07:27.610
它告诉你

07:28.610 --> 07:29.610
如果说遇到这样的

07:29.610 --> 07:31.610
如果说它遇到不好处理的情况

07:31.610 --> 07:33.610
它会有两种模式

07:33.610 --> 07:34.610
一种叫做prevent

07:34.610 --> 07:35.610
叫阻止

07:35.610 --> 07:36.610
阻止模式

07:36.610 --> 07:37.610
阻止模式的话

07:37.610 --> 07:38.610
那就比较简单了

07:38.610 --> 07:39.610
它就是完全

07:39.610 --> 07:40.610
跟之前一样

07:40.610 --> 07:41.610
一个模块

07:41.610 --> 07:42.610
一个函数

07:42.610 --> 07:43.610
还有一种模式

07:43.610 --> 07:44.610
叫做root

07:45.610 --> 07:46.610
root模式

07:47.610 --> 07:48.610
root模式

07:48.610 --> 07:50.610
root模式是把那些

07:51.610 --> 07:52.610
这些模块

07:52.610 --> 07:53.610
把它合并到一起

07:53.610 --> 07:54.610
放到一个单

07:54.610 --> 07:56.610
放到一个函数玩具里边

07:56.610 --> 07:57.610
比方说

07:57.610 --> 07:58.610
我们这里有

07:58.610 --> 08:00.610
这么一些模块

08:01.610 --> 08:02.610
这么一些模块

08:02.610 --> 08:03.610
它突然发现

08:03.610 --> 08:04.610
这三个模块

08:04.610 --> 08:05.610
不好处理

08:05.610 --> 08:08.610
比方说你使用动态导入的

08:08.610 --> 08:10.610
或者是这三个模块

08:10.610 --> 08:12.610
被其他多个模块使用

08:12.610 --> 08:13.610
那么这个时候

08:13.610 --> 08:15.610
它不是很好处理的

08:15.610 --> 08:16.610
不是很好处理

08:16.610 --> 08:17.610
怎么办呢

08:17.610 --> 08:18.610
它也不会

08:18.610 --> 08:19.610
如果说使用

08:19.610 --> 08:21.610
如果说使用prevent模式的话

08:21.610 --> 08:22.610
那么它就会

08:22.610 --> 08:23.610
一个模块

08:23.610 --> 08:24.610
一个函数

08:24.610 --> 08:25.610
但是如果说

08:25.610 --> 08:27.610
使用那个root模式的话

08:27.610 --> 08:28.610
那么它就会把这三个模块

08:28.610 --> 08:30.610
合并成一个函数

08:30.610 --> 08:31.610
单独的函数

08:31.610 --> 08:32.610
进行打包

08:32.610 --> 08:34.610
那么具体用哪一种模式的话

08:34.610 --> 08:36.610
它下面有规范

08:36.610 --> 08:37.610
不是规范

08:37.610 --> 08:39.610
它下面有它的做法

08:39.610 --> 08:41.610
如果说非ES6的模块

08:41.610 --> 08:42.610
它使用这个模式

08:42.610 --> 08:43.610
等等

08:43.610 --> 08:44.610
你就可以自己去看一下

08:44.610 --> 08:45.610
比方说使用eva的话

08:45.610 --> 08:47.610
它会使用这种模式

08:47.610 --> 08:48.610
等等

08:48.610 --> 08:50.610
这一会就不再多说了

08:50.610 --> 08:51.610
因为我们这一块

08:51.610 --> 08:52.610
只是为了解决一个面试题

08:52.610 --> 08:53.610
根本平时开发

08:53.610 --> 08:54.610
没有任何关系

08:54.610 --> 08:56.610
因为它都是自动完成的

08:56.610 --> 08:57.610
好吧

08:57.610 --> 08:58.610
就说一下这个

