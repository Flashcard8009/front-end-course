WEBVTT

00:00.000 --> 00:02.000
好 接下来这几节课呢

00:02.000 --> 00:05.000
其实我们要那个mongodb里面要讲的都讲完了啊

00:05.000 --> 00:08.000
就是我们平时要用的API这些

00:08.000 --> 00:12.000
接下来几节课主要是把之前挖的坑给它填上啊

00:12.000 --> 00:15.000
首先这节课呢把这个冰发处理给它填上

00:15.000 --> 00:19.000
呃 主要是讲啥呢 主要是讲那个我们之前的数据库里边

00:19.000 --> 00:21.000
不是有一个东西吗 叫我们看一下啊

00:21.000 --> 00:27.000
数据库里边有一个玩意儿叫那个

00:27.000 --> 00:29.000
就这个玩

00:29.000 --> 00:31.000
就这个玩意儿 把这个东西说一下啊

00:31.000 --> 00:33.000
这个东西到底是个啥

00:33.000 --> 00:37.000
呃 这个玩意儿我们当时来说的话是来解决这个冰发冲突了

00:37.000 --> 00:42.000
对不对 实际上冰发呢这个东西是一个很大很大的话题啊

00:42.000 --> 00:45.000
呃 我们这里呢仅仅说一下mongodb里边的冰发就行了

00:45.000 --> 00:47.000
因为不然的话就说了 说了太深了

00:47.000 --> 00:53.000
因为这是相当于是数据库DBA它要详细了解的知识

00:53.000 --> 00:55.000
对于我们前端开发者来说的话

00:55.000 --> 00:57.000
这个冰发处理的话

00:57.000 --> 01:00.000
呃 我们目前就目前而言啊

01:00.000 --> 01:02.000
嗯 不需要太深的去理解

01:02.000 --> 01:05.000
我们把那个mongodb里边的冰发处理讲了

01:05.000 --> 01:09.000
其实还有很多的还有还有些冰发处理的是mongodb本身之代的冰发处理

01:09.000 --> 01:11.000
啊 我们在这里呢

01:11.000 --> 01:14.000
呃 就不再提了啊 把mongodb里边的冰发给它讲了

01:14.000 --> 01:19.000
就主要是解释一下那个下滑线V那个枝段到底是起一个什么样的作用

01:19.000 --> 01:23.000
将来呢 你们学工作了几年过后呢

01:23.000 --> 01:26.000
呃 慢慢的要了解一些后缘的知识啊

01:26.000 --> 01:29.000
包括服务器的一些呃 知识呢

01:29.000 --> 01:31.000
你可能会接触到冰发啊

01:31.000 --> 01:34.000
那一块呢 我们再来呃 详细的讲解吧

01:34.000 --> 01:37.000
我们将来在课程里边也可以再做一些更新啊

01:37.000 --> 01:39.000
加入一些高级内容

01:39.000 --> 01:42.000
好 咱们来看一下这里的这个一个场景啊

01:42.000 --> 01:45.000
比方说咱们数据库里边有一个数据

01:45.000 --> 01:49.000
能看见吗啊 有的三个属性NAM老给ID和A级

01:49.000 --> 01:51.000
然后我们用mongos呢

01:51.000 --> 01:54.000
呃 模型UserFantBuyID

01:54.000 --> 01:57.000
是不是通过ID来找到两个模型的实力

01:57.000 --> 02:00.000
对吧 那么我们分两次啊

02:00.000 --> 02:03.000
分别调用FantBuyID 是不是可以拿到两个模型实力

02:03.000 --> 02:07.000
而这两个模型实力在内存里边 是不是表现成两个对象

02:07.000 --> 02:10.000
对不对 数据库呢 在磁盘里边是这么一个东西

02:10.000 --> 02:14.000
啊 它的格式是bison的bjson binaryjson

02:14.000 --> 02:18.000
呃 拿到内存里边过后呢 变成了ts的两个对象

02:18.000 --> 02:21.000
但是两个位向地址是不一样的啊 是不一样的

02:21.000 --> 02:24.000
它本不是一个对象 就是你分两次用FantBuyID来找到

02:24.000 --> 02:28.000
那什么什么意思呢 我们用代码来表述的话 就是这样子

02:28.000 --> 02:32.000
哎 咱们把这个地方这样子写啊

02:32.000 --> 02:38.000
比方说我们这里用UserFantBuyID

02:38.000 --> 02:42.000
ID呢 我们去随便找一个ID吧 就这个ID

02:42.000 --> 02:44.000
FantBuyID

02:45.000 --> 02:48.000
就拿到一个User1 对吧

02:48.000 --> 02:51.000
那么同样的道理呢 我们是不是可以

02:51.000 --> 02:54.000
是不是可以拿一个User2 对吧 两个

02:54.000 --> 02:56.000
是不是两个不是一个对象 我们来看一下吧

02:56.000 --> 02:59.000
输出User1 是不是等于User2 肯定不一样的

02:59.000 --> 03:02.000
虽然那种是完全一样的 但是呢

03:02.000 --> 03:04.000
对象是不一样的

03:04.000 --> 03:07.000
NT Start

03:07.000 --> 03:11.000
呃 Force 对不对 这是这种情况

03:11.000 --> 03:15.000
然后接下来我们做了一个什么样的处理呢 接下来我们就玩的这么一件事

03:15.000 --> 03:18.000
我们把User1呢 Name变成乘哥

03:18.000 --> 03:21.000
LoginID变成乘哥 对吧 改了这两个属性

03:21.000 --> 03:24.000
然后呢 我们保存电网上的S5方法保存

03:24.000 --> 03:27.000
保存到了数据库 数据库是不是从原来的状态

03:27.000 --> 03:31.000
对吧 变成了一个新的状态 对吧 数据库更新了

03:31.000 --> 03:34.000
看到问题没 能想到问题吗

03:34.000 --> 03:37.000
那么数据库更新了过后了User2它并不知道

03:37.000 --> 03:40.000
它不知道数据库已经更新了

03:40.000 --> 03:44.000
于是User2它保持的是原来状态 以前得到了乘哥

03:44.000 --> 03:46.000
保持的是原来状态

03:46.000 --> 03:51.000
然后User2按照自己的理解 它把A级修改成了20

03:51.000 --> 03:54.000
那么这个时候User2再去保存

03:54.000 --> 03:58.000
这个时候呢 数据库是不是有点蒙了

03:58.000 --> 04:01.000
或者说蒙库是不是有点蒙了

04:01.000 --> 04:06.000
这个东西啊 我是年龄改成20

04:06.000 --> 04:08.000
倒是好理解

04:08.000 --> 04:11.000
那么这个Name和LogiID到底改不改呢

04:11.000 --> 04:13.000
要不要把它改回去呢

04:13.000 --> 04:16.000
这是一个问题对不对 因为跟数据库不一致了

04:16.000 --> 04:18.000
其实这个问题造成了根源的就是

04:18.000 --> 04:21.000
有多个异部函数同时在操作数据库

04:21.000 --> 04:25.000
也就是并发问题 并发就是一起在操作

04:25.000 --> 04:28.000
那么这里为什么说多个数据库在同时操作呢

04:28.000 --> 04:30.000
我们可以这样子来理解

04:30.000 --> 04:34.000
就是从数据库拿到一个数据

04:34.000 --> 04:36.000
然后做出一些修改

04:36.000 --> 04:39.000
然后再保存到数据库 这是一个完整的过程

04:39.000 --> 04:41.000
而在这个完整的过程

04:41.000 --> 04:45.000
它发生是不是需要一段时间

04:45.000 --> 04:47.000
在这个完整的过程中呢

04:47.000 --> 04:50.000
又插入了别的过程

04:50.000 --> 04:55.000
对User1来讲 它过去数据保存

04:55.000 --> 04:57.000
但是在这个过程中

04:57.000 --> 05:00.000
是不是又插入了User2过去数据

05:00.000 --> 05:02.000
User1还没有完全保存的时候

05:02.000 --> 05:05.000
User2又拿到了数据

05:05.000 --> 05:08.000
然后User1保存了过后User2

05:08.000 --> 05:10.000
又去保存了数据

05:10.000 --> 05:12.000
相当于是什么呢 给大家看一下吧

05:12.000 --> 05:13.000
一个完整流程

05:13.000 --> 05:16.000
在我们这里的一个完整流程是这样子的

05:16.000 --> 05:23.000
就是获取用户 修改数据 保存用户

05:23.000 --> 05:25.000
那么对于User1而言

05:25.000 --> 05:28.000
它是不是获取用户

05:28.000 --> 05:33.000
User1修改数据

05:33.000 --> 05:35.000
然后保存用户

05:35.000 --> 05:37.000
对于User1而言是这样子的

05:37.000 --> 05:39.000
这是一个完整过程

05:39.000 --> 05:41.000
并发什么意思呢

05:41.000 --> 05:43.000
就是在一个完整过程里边

05:43.000 --> 05:45.000
插入了别的过程

05:45.000 --> 05:46.000
比方说我们在这里

05:46.000 --> 05:47.000
在这个地方

05:47.000 --> 05:48.000
获取User1过后了

05:48.000 --> 05:50.000
是不是这里插入了另外一个就是

05:50.000 --> 05:52.000
获取User2

05:52.000 --> 05:53.000
对不对

05:53.000 --> 05:55.000
所以被别的过程干扰了

05:55.000 --> 05:56.000
就是这么个意思

05:56.000 --> 05:58.000
就是有两件完整的事

05:58.000 --> 05:59.000
它们同时发生了

05:59.000 --> 06:00.000
就是并发

06:00.000 --> 06:03.000
那么并发我们在具体的就是

06:03.000 --> 06:04.000
场景里边

06:04.000 --> 06:05.000
一般发生在什么时候呢

06:05.000 --> 06:07.000
一般是发生在这个

06:07.000 --> 06:09.000
并发请求里边

06:09.000 --> 06:12.000
就是同一个时间点来的很多个请求

06:12.000 --> 06:14.000
那么就可能会造成

06:14.000 --> 06:15.000
对于数据户而言

06:15.000 --> 06:16.000
就可能会造成这种情况

06:16.000 --> 06:18.000
有一个请求在获取User1

06:18.000 --> 06:20.000
有一个请求在获取User2

06:20.000 --> 06:22.000
可能会造成这种情况

06:22.000 --> 06:23.000
那么面对这种情况

06:23.000 --> 06:24.000
那么故事是怎么处理的呢

06:24.000 --> 06:26.000
它是做出这样的假设

06:26.000 --> 06:29.000
就是当我们修改一个文档的时候

06:29.000 --> 06:30.000
如果说

06:30.000 --> 06:31.000
某些字段呢

06:31.000 --> 06:33.000
不再和数据户对应

06:33.000 --> 06:34.000
比方说像这里

06:34.000 --> 06:37.000
当我们去修改这个User2的时候

06:37.000 --> 06:39.000
在保存的时候

06:39.000 --> 06:41.000
如果说它不再和这个数据

06:41.000 --> 06:42.000
就这里边的数据

06:42.000 --> 06:43.000
像Name,Molking,ID

06:43.000 --> 06:46.000
这两个数据是不再和数据户对应的

06:46.000 --> 06:48.000
那么这个数据呢

06:48.000 --> 06:49.000
我们把它认为是

06:49.000 --> 06:50.000
张数据

06:50.000 --> 06:51.000
叫DirtyData

06:51.000 --> 06:53.000
那么这样的张数据呢

06:53.000 --> 06:56.000
它是不应该对数据户产生影响的

06:56.000 --> 06:57.000
就不能

06:57.000 --> 07:00.000
这个数据相当于是已经过时了

07:00.000 --> 07:02.000
已经跟数据户不对应了

07:02.000 --> 07:03.000
那么这两个数据呢

07:03.000 --> 07:05.000
不应该对数据户产生影响

07:05.000 --> 07:07.000
它是基于这么一个假设

07:07.000 --> 07:08.000
也就是说呢

07:08.000 --> 07:10.000
在Mongus里面的处理方式呢

07:10.000 --> 07:11.000
就这两个数据呢

07:11.000 --> 07:13.000
它就不要去更新了

07:13.000 --> 07:15.000
然后当我们修改一个文档的时候

07:15.000 --> 07:17.000
如果说字段和数据户是对应的

07:17.000 --> 07:18.000
比方说Aged

07:18.000 --> 07:19.000
它一开始是10对吧

07:19.000 --> 07:20.000
那么这里的Aged是10

07:20.000 --> 07:21.000
你把它改成20了

07:21.000 --> 07:22.000
对不对

07:22.000 --> 07:23.000
那么Aged这个数据呢

07:23.000 --> 07:24.000
是对应的

07:24.000 --> 07:26.000
那么它不是张数据

07:26.000 --> 07:27.000
这个数据呢

07:27.000 --> 07:28.000
就可以正常的更新

07:28.000 --> 07:30.000
这就是User

07:30.000 --> 07:31.000
就是在Mongus里面

07:31.000 --> 07:32.000
它的处理方式

07:32.000 --> 07:34.000
比方说咱们来看一下吧

07:35.000 --> 07:37.000
我们这里也获取两个User1

07:37.000 --> 07:39.000
然后那么对User1的Name

07:39.000 --> 07:40.000
Name属性呢

07:40.000 --> 07:41.000
给它改成

07:41.000 --> 07:42.000
成歌

07:44.000 --> 07:47.000
它的那个User1的

07:48.000 --> 07:49.000
LoginID呢

07:49.000 --> 07:51.000
也该改成成歌

07:54.340 --> 07:55.340
然后呢

07:55.340 --> 07:56.340
我们把它保存一下

07:58.340 --> 08:00.340
UserAway

08:00.340 --> 08:01.340
等待

08:01.340 --> 08:02.340
User1 Save

08:02.340 --> 08:03.340
把它保存一下

08:03.340 --> 08:04.340
接下来

08:04.340 --> 08:08.340
那么再把User2.Aged改成

08:08.340 --> 08:09.340
看一下

08:09.340 --> 08:10.340
现在是多少

08:11.340 --> 08:12.340
现在是那个

08:16.340 --> 08:17.340
Aged 39

08:17.340 --> 08:18.340
对吧

08:18.340 --> 08:19.340
改成18

08:19.340 --> 08:20.340
然后呢

08:20.340 --> 08:23.340
User2.Aged.Save

08:25.340 --> 08:26.340
Away

08:26.340 --> 08:27.340
好

08:27.340 --> 08:28.340
User1

08:28.340 --> 08:29.340
User2

08:29.340 --> 08:31.340
接下来我们还要去看一下数据库

08:32.340 --> 08:33.340
保存

08:33.340 --> 08:35.340
我们在这里可以看到

08:35.340 --> 08:36.340
保存成功之后呢

08:36.340 --> 08:38.340
我们有两次保存的吧

08:38.340 --> 08:39.340
User1里面

08:39.340 --> 08:41.340
Aged 39

08:41.340 --> 08:42.340
保存完了过

08:42.340 --> 08:43.340
User1还是39

08:44.340 --> 08:45.340
然后呢

08:45.340 --> 08:46.340
User2呢

08:48.340 --> 08:49.340
User2呢

08:49.340 --> 08:50.340
User2呢

08:50.340 --> 08:51.340
它也

08:52.340 --> 08:54.340
User2

08:54.340 --> 08:55.340
来这

08:55.340 --> 08:56.340
User2

08:56.340 --> 08:58.340
最起变成的最新的数据是吧

08:58.340 --> 09:00.340
两个对象虽然不理智的

09:00.340 --> 09:02.340
然后User2里面

09:02.340 --> 09:03.340
它的就是

09:03.340 --> 09:05.340
LoginID

09:05.340 --> 09:06.340
Name

09:06.340 --> 09:07.340
又变成

09:07.340 --> 09:08.340
成歌了

09:08.340 --> 09:09.340
它又变成成歌了

09:09.340 --> 09:11.340
为什么它会变成成歌呢

09:11.340 --> 09:13.340
因为它保存了之后

09:13.340 --> 09:14.340
在这里

09:14.340 --> 09:15.340
User2保存了之后

09:15.340 --> 09:17.340
它会重新去同步数据库

09:17.340 --> 09:19.340
把数据库里面的结果重新同步回来

09:20.340 --> 09:21.340
明儿的意思吧

09:21.340 --> 09:23.340
你看User1

09:23.340 --> 09:24.340
改成这个东西的

09:24.340 --> 09:25.340
User2改没改

09:25.340 --> 09:26.340
它并没有改

09:26.340 --> 09:27.340
但是呢

09:27.340 --> 09:28.340
我在保存了之后

09:28.340 --> 09:29.340
它就会把User2

09:29.340 --> 09:30.340
它的章数据呢

09:30.340 --> 09:31.340
给它同步回来

09:32.340 --> 09:34.340
它的这种做法

09:37.340 --> 09:38.340
我下面怎么有个这个

09:39.340 --> 09:42.480
这什么玩意

09:43.480 --> 09:44.480
这什么玩意

09:44.480 --> 09:47.240
我要停止

09:48.240 --> 09:49.240
好 我来看一下

09:49.240 --> 09:50.240
我们的数据库呢

09:51.240 --> 09:52.240
刷新一下数据库

09:52.240 --> 09:53.240
数据库里面

09:53.240 --> 09:54.240
你看

09:54.240 --> 09:55.240
成歌

09:55.240 --> 09:56.240
然后呢

09:56.240 --> 09:57.240
A级的U18

09:57.240 --> 09:58.240
相当于是什么呢

09:58.240 --> 10:00.240
相当于是User1

10:00.240 --> 10:01.240
改了这两个数据

10:01.240 --> 10:02.240
User2呢

10:02.240 --> 10:03.240
改了这个数据

10:03.240 --> 10:04.240
对吧

10:04.240 --> 10:05.240
这个道理

10:05.240 --> 10:06.240
那么User1改了之后

10:06.240 --> 10:08.240
User2本来还是原来的数据的话

10:08.240 --> 10:09.240
原来的数据

10:09.240 --> 10:10.240
那么原来的数据

10:10.240 --> 10:11.240
是不是章数据

10:11.240 --> 10:12.240
看一下这个图

10:12.240 --> 10:13.240
这里需要绕一下

10:13.240 --> 10:14.240
看这个图

10:14.240 --> 10:15.240
这个章数据呢

10:15.240 --> 10:16.240
它并没有去影响数据库

10:16.240 --> 10:17.240
这是mongers里面的

10:17.240 --> 10:19.240
默认处理方式

10:20.240 --> 10:21.240
真正上面的场地

10:21.240 --> 10:22.240
下面一张图

10:22.240 --> 10:23.240
可以看得很清楚

10:23.240 --> 10:24.240
你看

10:24.240 --> 10:25.240
左边是一样的

10:25.240 --> 10:26.240
然后这边

10:26.240 --> 10:27.240
保存没问题

10:27.240 --> 10:29.240
然后User2在保存的时候呢

10:29.240 --> 10:30.240
他就把这个邓歌

10:30.240 --> 10:32.240
就是和

10:32.240 --> 10:33.240
这两个属性是章数据

10:33.240 --> 10:35.240
因此没有做任何处理

10:35.240 --> 10:37.240
然后把年龄更运去了

10:37.240 --> 10:38.240
这个做法呢

10:38.240 --> 10:39.240
倒是

10:39.240 --> 10:41.240
没有什么问题

10:42.240 --> 10:43.240
但是呢

10:43.240 --> 10:45.240
以后有一个

10:45.240 --> 10:47.240
有一个麻烦的点就在于

10:47.240 --> 10:49.240
mongers

10:49.240 --> 10:51.240
他对数组的操作呢

10:51.240 --> 10:53.240
不是这样子操作的

10:53.240 --> 10:54.240
就mongers

10:54.240 --> 10:55.240
他无法准确的判定

10:55.240 --> 10:56.240
数组是不是章数据

10:56.240 --> 10:58.240
这是他目前呢

10:58.240 --> 10:59.240
不是很处理的

10:59.240 --> 11:00.240
不是很理想的地方

11:00.240 --> 11:01.240
或者说呢

11:01.240 --> 11:02.240
数组这个处理呢

11:02.240 --> 11:04.240
他希望交给你来处理

11:04.240 --> 11:05.240
他不想处理

11:05.240 --> 11:07.240
因为数组里面的处理很灵活

11:07.240 --> 11:08.240
删除一个数据

11:08.240 --> 11:09.240
加入了一个新的数据

11:09.240 --> 11:10.240
改了一个数据

11:10.240 --> 11:11.240
对吧

11:11.240 --> 11:12.240
他的处理非常灵活

11:12.240 --> 11:14.240
因此他这个数组的处理呢

11:14.240 --> 11:16.240
如果说他发现数组

11:17.240 --> 11:18.240
出了问题

11:18.240 --> 11:19.240
那么他这个时候呢

11:19.240 --> 11:20.240
他就不再给你自行处理了

11:20.240 --> 11:22.240
而且是直接给你报仇

11:22.240 --> 11:23.240
那么mongers是怎么来发现

11:23.240 --> 11:24.240
数组出了问题呢

11:24.240 --> 11:25.240
他这样子

11:26.240 --> 11:28.240
他在新增稳当的时候呢

11:28.240 --> 11:30.240
会自动添加一个字段

11:30.240 --> 11:31.240
两个下滑线V

11:31.240 --> 11:32.240
用于记录版本号

11:32.240 --> 11:33.240
一开始都是0

11:34.240 --> 11:36.240
现在他一变成1了

11:36.240 --> 11:37.240
一开始都是0

11:37.240 --> 11:38.240
你看这也稳当

11:38.240 --> 11:39.240
所以一开始都是0

11:39.240 --> 11:41.240
他可以加这么一个版本号

11:41.240 --> 11:42.240
那么这个版本号呢

11:42.240 --> 11:43.240
他什么时候会变呢

11:43.240 --> 11:44.240
当我们

11:44.240 --> 11:46.240
通过那个模型实力

11:46.240 --> 11:48.240
调用C5方法之后

11:48.240 --> 11:49.240
就在这

11:49.240 --> 11:51.240
调用C5方法之后呢

11:51.240 --> 11:52.240
如果说我们改动了

11:52.240 --> 11:54.240
模型里面的数组

11:54.240 --> 11:56.240
那么他会掉

11:56.240 --> 11:57.240
他会在内部

11:57.240 --> 11:58.240
调用这个实力的

11:58.240 --> 12:00.240
increase increment函数

12:00.240 --> 12:01.240
他会调用这个函数

12:01.240 --> 12:03.240
每一个实力都有这个函数

12:03.240 --> 12:04.240
increase increment

12:04.240 --> 12:05.240
这个函数呢干嘛呢

12:05.240 --> 12:07.240
他就是把那个版本号加1

12:07.240 --> 12:08.240
就这么简单

12:09.240 --> 12:11.240
表示你改动了数组

12:11.240 --> 12:12.240
但是呢这里呢

12:12.240 --> 12:13.240
有个特殊情况

12:13.240 --> 12:15.240
虽然说你没有改动数组

12:15.240 --> 12:16.240
但是如果说你

12:16.240 --> 12:17.240
是第一次修改的话

12:17.240 --> 12:18.240
那么他也会给你加1

12:18.240 --> 12:19.240
你看我们现在是不是

12:19.240 --> 12:20.240
第一次修改

12:20.240 --> 12:22.240
他也会给你加1

12:22.240 --> 12:23.240
那么后续修改就不会了

12:23.240 --> 12:25.240
比方我们这里改成乘高2

12:25.240 --> 12:27.240
保存

12:27.240 --> 12:29.550
start

12:29.550 --> 12:33.120
你看是没有加1的

12:33.120 --> 12:34.120
对不对

12:35.120 --> 12:36.120
那么这里

12:36.120 --> 12:37.120
这是这一块

12:39.120 --> 12:41.500
那么现在呢

12:42.500 --> 12:43.500
改动数组或者是

12:43.500 --> 12:44.500
第一次改动

12:44.500 --> 12:46.500
他都会把版本号加1

12:46.500 --> 12:47.500
如果说其他模型

12:47.500 --> 12:48.500
也改动了数组

12:48.500 --> 12:49.500
保存的时候呢

12:49.500 --> 12:50.500
他会对比版本号

12:50.500 --> 12:51.500
如果说不一致的话

12:51.500 --> 12:52.500
他会引发一个错误

12:52.500 --> 12:54.500
叫version error

12:54.500 --> 12:55.500
给他看一下吧

12:55.500 --> 12:56.500
比方我们这个

12:56.500 --> 12:57.500
user 1里边

12:57.500 --> 12:58.500
有个love

12:58.500 --> 12:59.500
有个爱号

12:59.500 --> 13:00.500
我们把它改成

13:00.500 --> 13:01.500
求回

13:03.500 --> 13:04.500
然后呢

13:04.500 --> 13:05.500
另外一个user2

13:05.500 --> 13:06.500
改动数组

13:06.500 --> 13:07.500
love

13:07.500 --> 13:09.500
改成香菜

13:11.810 --> 13:12.810
保存

13:12.810 --> 13:13.810
接下来我们来看一下

13:13.810 --> 13:14.810
是不是报了个错误

13:14.810 --> 13:15.810
什么错误呢

13:15.810 --> 13:17.810
叫做version error

13:17.810 --> 13:20.810
对于这个id而言

13:20.810 --> 13:22.810
他的版本已经不一致了

13:22.810 --> 13:23.810
他无法进行更改

13:23.810 --> 13:25.810
我们来看一下数据库

13:25.810 --> 13:26.810
数据库呢

13:26.810 --> 13:28.810
只有第一个更改是成功的

13:28.810 --> 13:29.810
求回是成功的

13:29.810 --> 13:30.810
也就是说

13:30.810 --> 13:31.810
我们当我们user 1

13:31.810 --> 13:32.810
你看一下

13:32.810 --> 13:33.810
当我们user 1

13:33.810 --> 13:34.810
改了他过后

13:34.810 --> 13:35.810
那么user 2

13:35.810 --> 13:36.810
是不是还是原来的结果

13:36.810 --> 13:37.810
对吧

13:37.810 --> 13:38.810
来看一下吧

13:38.810 --> 13:40.810
比方说我们目前的情况

13:40.810 --> 13:41.810
这里呢

13:41.810 --> 13:42.810
改成a和b

13:42.810 --> 13:44.810
那么这里改成了

13:44.810 --> 13:46.810
c和d

13:46.810 --> 13:47.810
数据库原来的情况

13:47.810 --> 13:48.810
是不是求回

13:48.810 --> 13:49.810
对吧

13:49.810 --> 13:50.810
那么现在呢

13:50.810 --> 13:51.810
user 1改了过后呢

13:51.810 --> 13:52.810
以保存

13:52.810 --> 13:53.810
那么现在呢

13:53.810 --> 13:54.810
数据库的真实情况

13:54.810 --> 13:55.810
数据库

13:56.810 --> 13:57.810
真实情况

13:57.810 --> 13:58.810
那么是不是这个

14:00.810 --> 14:01.810
对不对

14:01.810 --> 14:02.810
好那么现在呢

14:02.810 --> 14:03.810
user 2去改这个labs呢

14:03.810 --> 14:05.810
数据库的真实情况

14:05.810 --> 14:06.810
是什么呢

14:06.810 --> 14:08.810
数据库的真实情况

14:09.810 --> 14:10.810
是什么呢

14:10.810 --> 14:11.810
是这个

14:11.810 --> 14:12.810
对不对

14:12.810 --> 14:14.810
而user 2

14:14.810 --> 14:16.810
原来的情况

14:16.810 --> 14:17.810
是什么呢

14:17.810 --> 14:19.810
是这个求回

14:20.810 --> 14:21.810
能力解法

14:21.810 --> 14:22.810
这里有点糟

14:22.810 --> 14:23.810
它是独的原论的数据

14:23.810 --> 14:24.810
求回

14:24.810 --> 14:25.810
它原来

14:25.810 --> 14:26.810
求回变成这个玩意了

14:26.810 --> 14:28.810
user 2相当于是要

14:28.810 --> 14:30.810
把原论的求回变成

14:30.810 --> 14:31.810
什么呢

14:31.810 --> 14:33.810
变成c和d

14:33.810 --> 14:34.810
对吧

14:34.810 --> 14:35.810
那么这里呢

14:35.810 --> 14:36.810
是把原论的求回变成这个a和b

14:36.810 --> 14:37.810
这个是没问题的

14:37.810 --> 14:38.810
那么现在呢

14:38.810 --> 14:39.810
是把原论的求回变成c和d

14:39.810 --> 14:40.810
但是数据库

14:40.810 --> 14:41.810
现在已经是a和b了

14:41.810 --> 14:42.810
不是原论的求回了

14:42.810 --> 14:43.810
那么这个时候

14:43.810 --> 14:44.810
是不是张数据

14:44.810 --> 14:46.810
对张数据进行更改

14:46.810 --> 14:47.810
那么这个时候呢

14:47.810 --> 14:48.810
他就认为呢

14:48.810 --> 14:49.810
可能会引发很多的问题了

14:49.810 --> 14:50.810
他就没有给你处理了

14:50.810 --> 14:52.810
为什么他认为会引发问题呢

14:52.810 --> 14:53.810
因为就说

14:53.810 --> 14:54.810
数据的操作呢

14:54.810 --> 14:56.810
我们往往可能会做这种操作

14:56.810 --> 14:57.810
就是根据原论的数据呢

14:57.810 --> 14:58.810
来删除一下

14:58.810 --> 14:59.810
根据原论的数据呢

14:59.810 --> 15:00.810
来增加一下

15:00.810 --> 15:01.810
对吧

15:01.810 --> 15:02.810
所以说你

15:02.810 --> 15:03.810
你这个数据很有可能是

15:03.810 --> 15:04.810
根据原论的数据得到的

15:04.810 --> 15:05.810
因此呢

15:05.810 --> 15:07.810
你再次做这种处理的话

15:07.810 --> 15:08.810
那么你就是根据

15:08.810 --> 15:09.810
张数据来得到的

15:09.810 --> 15:10.810
他认为这样子做的话

15:10.810 --> 15:12.810
可能不是你的意图

15:12.810 --> 15:13.810
因此他给你报出

15:13.810 --> 15:14.810
报出实际上是一个好事

15:14.810 --> 15:15.810
真的是一个好事

15:15.810 --> 15:16.810
他在提醒你

15:16.810 --> 15:17.810
你这个数据呢

15:17.810 --> 15:19.810
已经出现张数据了

15:19.810 --> 15:21.810
可能不是你期望的结果

15:22.810 --> 15:23.810
好

15:23.810 --> 15:24.810
那么这里呢就是

15:24.810 --> 15:25.810
比较多我们简单一点

15:25.810 --> 15:26.810
简单一点说就是

15:26.810 --> 15:27.810
如果说这里

15:27.810 --> 15:29.810
我们用U2的

15:29.810 --> 15:30.810
Love

15:30.810 --> 15:31.810
Surprise

15:31.810 --> 15:32.810
那么这里呢

15:32.810 --> 15:33.810
我们是切割数据

15:33.810 --> 15:35.810
删除数据的第1项

15:35.810 --> 15:36.810
0

15:36.810 --> 15:37.810
1

15:37.810 --> 15:38.810
你再为删除的

15:38.810 --> 15:39.810
去求回

15:39.810 --> 15:40.810
结果是删除的是什么呢

15:40.810 --> 15:41.810
结果删除的是这个东西

15:41.810 --> 15:42.810
对吧

15:42.810 --> 15:43.810
是不是跟你的预想不一致的

15:43.810 --> 15:45.810
所以说对数据的改动呢

15:45.810 --> 15:46.810
他做了这样的处理

15:46.810 --> 15:47.810
他就给你报错

15:47.810 --> 15:49.810
那么具体他的判定方式

15:49.810 --> 15:50.810
就通过这个版本

15:50.810 --> 15:51.810
好

15:51.810 --> 15:52.810
凡是对数据改动了过后呢

15:52.810 --> 15:53.810
他就会版本的话

15:53.810 --> 15:54.810
就会增加1

15:54.810 --> 15:55.810
你看一下

15:55.810 --> 15:56.810
版本号变成2了

15:56.810 --> 15:57.810
对数据的改动过后

15:57.810 --> 15:58.810
他的版本号就增加1

15:58.810 --> 15:59.810
那么他一看

15:59.810 --> 16:00.810
他改动过后

16:00.810 --> 16:02.810
本来一开始的版本号都是1的

16:02.810 --> 16:03.810
结果了

16:03.810 --> 16:04.810
他的改动过后

16:04.810 --> 16:05.810
他变成2了

16:05.810 --> 16:06.810
那么这个的地方的结果

16:06.810 --> 16:07.810
还是1

16:07.810 --> 16:08.810
版本号是不是不一致

16:08.810 --> 16:09.810
版本号不一致

16:09.810 --> 16:11.810
你又对数据做出了更改

16:11.810 --> 16:12.810
那么这个时候

16:12.810 --> 16:13.810
他就会报错

16:13.810 --> 16:14.810
对张数据做出了更改

16:14.810 --> 16:15.810
还就会报错

16:15.810 --> 16:16.810
就这么一个意思

16:16.810 --> 16:17.810
体会一下就行了

16:17.810 --> 16:19.810
我们不用过细的去了解

16:20.810 --> 16:21.810
那么现在呢

16:21.810 --> 16:22.810
对数据的数据是这样子

16:22.810 --> 16:23.810
当我们对

16:23.810 --> 16:24.810
张数据

16:24.810 --> 16:25.810
那不是进行更改过后

16:25.810 --> 16:26.810
一保存

16:26.810 --> 16:27.810
他就被出发了

16:28.810 --> 16:29.810
报错实际上是一个好事

16:29.810 --> 16:30.810
他在提醒你

16:30.810 --> 16:31.810
应该云气重视

16:31.810 --> 16:33.810
这里可能会出现张数据

16:33.810 --> 16:34.810
那么如果说

16:34.810 --> 16:35.810
我们作为开发者

16:35.810 --> 16:36.810
应该去怎么来处理

16:36.810 --> 16:37.810
这种情况呢

16:37.810 --> 16:38.810
比方说

16:38.810 --> 16:39.810
当我们报错的时候

16:39.810 --> 16:40.810
你就

16:40.810 --> 16:41.810
你至少你知道了

16:41.810 --> 16:42.810
这里出了问题了

16:42.810 --> 16:43.810
有张数据了

16:43.810 --> 16:44.810
保住一个Version

16:44.810 --> 16:45.810
版本不一致了

16:45.810 --> 16:46.810
那么这个时候

16:46.810 --> 16:47.810
你可以

16:47.810 --> 16:48.810
比方说你用Express

16:48.810 --> 16:49.810
做的话

16:49.810 --> 16:50.810
你可以在错误处理这里

16:50.810 --> 16:51.810
发现是这个错误的话

16:51.810 --> 16:52.810
你可以提示

16:52.810 --> 16:53.810
用户

16:53.810 --> 16:54.810
一个特别的错误消息

16:54.810 --> 16:55.810
比方说

16:56.810 --> 16:57.810
比方说什么

16:58.810 --> 16:59.810
500

16:59.810 --> 17:00.810
或者是403

17:00.810 --> 17:01.810
401

17:01.810 --> 17:02.810
给他一个错误的消息

17:02.810 --> 17:03.810
给他

17:03.810 --> 17:04.810
然后提示用户

17:04.810 --> 17:06.810
让他重新提交表达

17:06.810 --> 17:07.810
或者是呢

17:07.810 --> 17:08.810
我们在程序里面

17:08.810 --> 17:09.810
就自动处理的

17:09.810 --> 17:10.810
你现在不是版本错误吗

17:10.810 --> 17:11.810
OK

17:11.810 --> 17:13.810
那么重新去获取一下数据

17:13.810 --> 17:14.810
从数据过来

17:14.810 --> 17:15.810
重新更新一下最新数据

17:15.810 --> 17:17.810
然后再重新来保存

17:18.810 --> 17:19.810
没了意思吧

17:19.810 --> 17:21.810
这些都可以进行处理的

17:21.810 --> 17:22.810
总之他错误了

17:22.810 --> 17:23.810
也不仅是坏事

17:23.810 --> 17:24.810
如果说

17:25.810 --> 17:27.810
你在使用mongous的时候

17:27.810 --> 17:29.810
不仅希望对数据这样的操作

17:29.810 --> 17:31.810
而且希望对所有的制断

17:31.810 --> 17:33.810
都要进行版本的控制

17:33.810 --> 17:34.810
只要你发现张数据

17:34.810 --> 17:36.810
你就不能随便保存

17:36.810 --> 17:37.810
版本有问题

17:37.810 --> 17:38.810
就要随便不能随便保存

17:38.810 --> 17:39.810
那么这个时候

17:39.810 --> 17:40.810
你应该去按照

17:40.810 --> 17:41.810
官方文章的说法

17:41.810 --> 17:43.810
mongous自己是没有给你这样做的

17:43.810 --> 17:44.810
因为他自己的做法

17:44.810 --> 17:46.810
是用默认的做法

17:46.810 --> 17:47.810
他做出了假设的

17:47.810 --> 17:48.810
那么如果说

17:48.810 --> 17:49.810
你要对所有的制断

17:49.810 --> 17:51.810
都要进行控制的话

17:51.810 --> 17:53.810
那么建议你使用一个插件

17:53.810 --> 17:55.810
叫做mongous update if current

17:55.810 --> 17:56.810
那么这个插件怎么用呢

17:56.810 --> 17:57.810
就搜一下安装

18:01.380 --> 18:04.460
复制一下

18:07.020 --> 18:08.020
复制一下

18:08.020 --> 18:09.020
安装这个玩意

18:10.020 --> 18:11.020
安装进来

18:11.020 --> 18:12.020
安装进来过后

18:12.020 --> 18:13.020
他具体的使用方式

18:13.020 --> 18:14.020
是在github里面

18:14.020 --> 18:15.020
文档里面

18:16.020 --> 18:18.020
这个插件有一个bug

18:18.020 --> 18:19.020
以后我告诉大家

18:19.020 --> 18:20.020
怎么来改bug

18:20.020 --> 18:21.020
我刚才调试了一下

18:21.020 --> 18:22.020
接下来

18:23.020 --> 18:24.020
用一下吧

18:24.020 --> 18:26.020
用法的非常简单

18:26.020 --> 18:28.020
你就是导入

18:28.020 --> 18:29.020
在哪里导入呢

18:29.020 --> 18:30.020
在连接数据库这里

18:31.020 --> 18:33.020
在这里导入

18:33.020 --> 18:34.020
导入进来

18:34.020 --> 18:35.020
导入进来过后

18:35.020 --> 18:36.020
在这边去使用一下

18:36.020 --> 18:38.020
这个在这里

18:38.020 --> 18:39.020
mongous plugin

18:39.020 --> 18:40.020
通过这个海朔

18:40.020 --> 18:42.020
去使用一下这个插件

18:42.020 --> 18:43.020
用一下这个插件

18:43.020 --> 18:45.020
然后在模型里边

18:45.020 --> 18:46.020
在schema里边

18:46.020 --> 18:47.020
还要去用一下

18:48.020 --> 18:50.020
针对这个schema

18:50.020 --> 18:52.020
关键是看你要针对哪个schema

18:52.020 --> 18:53.020
针对这个schema

18:53.020 --> 18:55.020
你要去

18:55.020 --> 18:56.020
用这个无论

18:56.020 --> 18:57.020
就是无论如何都要去

18:57.020 --> 18:59.020
防止版本的冲突的

18:59.020 --> 19:00.020
不仅仅是针对数据

19:00.020 --> 19:01.020
OK

19:01.020 --> 19:02.020
那么就用起来了

19:02.020 --> 19:03.020
这个地方

19:03.020 --> 19:04.020
而且有点schema

19:04.020 --> 19:06.020
就是我们前面的schema

19:06.020 --> 19:07.020
使用这个schema

19:07.020 --> 19:08.020
去用这个插件

19:08.020 --> 19:09.020
好了

19:10.020 --> 19:11.020
用好了之后

19:11.020 --> 19:12.020
我们再来看

19:13.020 --> 19:14.020
现在我们在这里

19:14.020 --> 19:15.020
就保存别的字段

19:15.020 --> 19:16.020
比方说

19:16.020 --> 19:17.020
我们把它name

19:17.020 --> 19:18.020
改成

19:18.020 --> 19:19.020
动格

19:20.020 --> 19:21.020
那么这里

19:21.020 --> 19:22.020
User2的

19:23.020 --> 19:24.020
A级

19:25.020 --> 19:26.020
改成

19:27.020 --> 19:28.020
20

19:29.020 --> 19:30.020
接下来我们来看一下

19:31.020 --> 19:32.020
MTMistart

19:34.020 --> 19:35.020
那么这个时候爆错了

19:35.020 --> 19:36.020
它告诉你

19:36.020 --> 19:37.020
this increment

19:37.020 --> 19:38.020
increasement

19:38.020 --> 19:39.020
is not a function

19:39.020 --> 19:40.020
这是它的插件

19:40.020 --> 19:41.020
我看了它的元代

19:41.020 --> 19:42.020
这是它的插件

19:42.020 --> 19:43.020
它本身写的有问题

19:43.020 --> 19:44.020
因此你需要

19:44.020 --> 19:46.020
改动一下它的元代

19:47.020 --> 19:48.020
插件有段时间没更新了

19:48.020 --> 19:49.020
因为这个mongos

19:49.020 --> 19:50.020
更新了

19:50.020 --> 19:51.020
插件没有跟上

19:51.020 --> 19:52.020
那么可能你们用的时候

19:52.020 --> 19:53.020
就可能已经好了

19:53.020 --> 19:54.020
但是我用的时候

19:54.020 --> 19:55.020
还不行

19:55.020 --> 19:56.020
因此你们在这里

19:56.020 --> 19:57.020
找到这个插件

19:57.020 --> 19:58.020
找怎么去

19:58.020 --> 19:59.020
就这个插件

19:59.020 --> 20:00.020
load module里面

20:00.020 --> 20:01.020
搜索一下

20:01.020 --> 20:03.020
mongos updates if current

20:03.020 --> 20:04.020
在内部里面

20:04.020 --> 20:05.020
有这么一个文件

20:06.020 --> 20:07.020
有这么一个文件

20:08.020 --> 20:09.020
那么在这个文件里面

20:09.020 --> 20:11.020
你去导入一下

20:11.020 --> 20:12.020
或者是

20:12.020 --> 20:13.020
因为在这里

20:13.020 --> 20:14.020
改了过后没用

20:14.020 --> 20:15.020
因为你到时候

20:15.020 --> 20:16.020
在服务器那边

20:16.020 --> 20:17.020
你重新

20:17.020 --> 20:18.020
installed的时候

20:18.020 --> 20:19.020
它又变成元代的情况了

20:19.020 --> 20:20.020
所以说干脆你

20:20.020 --> 20:22.020
我就把这个复制一下吧

20:22.020 --> 20:24.020
复制放到跟目录下面

20:24.020 --> 20:25.020
放到这

20:25.020 --> 20:26.020
然后在这边

20:26.020 --> 20:27.020
我们就找到

20:27.020 --> 20:28.020
这个level

20:28.020 --> 20:30.020
level里面的这个就是

20:32.020 --> 20:33.020
version

20:35.020 --> 20:36.020
在这里面

20:36.020 --> 20:37.020
搜索一下

20:37.020 --> 20:38.020
就在这

20:38.020 --> 20:39.020
this increment

20:39.020 --> 20:40.020
但是这个错误

20:40.020 --> 20:41.020
怎么发生的呢

20:41.020 --> 20:42.020
因为在mongos里面

20:42.020 --> 20:43.020
有纸文档

20:43.020 --> 20:45.020
纸文档里面是没有这个函数的

20:45.020 --> 20:46.020
因此我们在这里的

20:46.020 --> 20:47.020
刀文判断一下

20:47.020 --> 20:48.020
this increment

20:48.020 --> 20:49.020
有没有纸

20:49.020 --> 20:50.020
如果说有纸的话

20:50.020 --> 20:51.020
去刀文这个东西

20:51.020 --> 20:52.020
如果说没有纸

20:52.020 --> 20:53.020
就不必要用

20:53.020 --> 20:54.020
把这个地方改一下

20:54.020 --> 20:55.020
其他就没啥了

20:55.020 --> 20:57.020
然后那么在这里边

20:57.020 --> 20:58.020
在使用这个

20:58.020 --> 20:59.020
插件的时候

20:59.020 --> 21:00.020
我们在这里

21:00.020 --> 21:01.020
导入的时候

21:01.020 --> 21:03.020
从这样的方式来导入

21:05.020 --> 21:06.020
从这样的方式来导入

21:07.020 --> 21:08.020
导入了什么呢

21:08.020 --> 21:09.020
导入的是

21:09.020 --> 21:10.020
这下面的

21:11.020 --> 21:12.020
这个index

21:13.020 --> 21:14.020
这样导入

21:14.020 --> 21:15.020
没办法

21:15.020 --> 21:16.020
目前只能这样子

21:17.020 --> 21:18.020
将就用一下

21:19.020 --> 21:20.020
如果说你需要

21:20.020 --> 21:21.020
首先你要

21:21.020 --> 21:22.020
如果说你需要这个功能的话

21:22.020 --> 21:23.020
先就用一下

21:23.020 --> 21:24.020
那么现在跟

21:24.020 --> 21:25.020
not much 就是你

21:25.020 --> 21:26.020
就没有什么关系了

21:26.020 --> 21:27.020
对吧

21:28.020 --> 21:29.020
分屏start

21:31.020 --> 21:32.020
这里什么

21:32.020 --> 21:33.020
那么现在是不是爆错了

21:33.020 --> 21:34.020
爆了一个version error

21:34.020 --> 21:35.020
这就是我们想要的

21:36.020 --> 21:37.020
对不对

21:37.020 --> 21:38.020
我们的版本已经

21:38.020 --> 21:39.020
已经冲突了

21:39.020 --> 21:40.020
这样子呢

21:40.020 --> 21:42.020
它就完全防止你

21:42.020 --> 21:43.020
同时去修改

21:43.020 --> 21:44.020
修改这个章数据

21:45.020 --> 21:46.020
比如说U2E

21:46.020 --> 21:47.020
保存了过后

21:47.020 --> 21:48.020
U2E就已经出了问题了

21:48.020 --> 21:49.020
这个对象已经

21:49.020 --> 21:50.020
已经出了问题了

21:50.020 --> 21:51.020
不正确了

21:51.020 --> 21:52.020
你做任何的修改保存

21:52.020 --> 21:53.020
我都不允许

21:53.020 --> 21:54.020
是不是比较严格了

21:54.020 --> 21:55.020
对不对

21:55.020 --> 21:56.020
它这样子

21:56.020 --> 21:57.020
如果说你需要这样的

21:57.020 --> 21:58.020
严格做法的话

21:58.020 --> 21:59.020
你可以把这个

21:59.020 --> 22:00.020
插件导入进来

22:00.020 --> 22:01.020
目前有一个bug

22:01.020 --> 22:03.020
稍微修改一下就完了

22:03.020 --> 22:05.020
这就是关于这个

22:07.020 --> 22:08.020
冲突管理

22:08.020 --> 22:10.020
它是用版本来控制的

22:10.020 --> 22:11.020
那么

22:11.020 --> 22:13.020
这是mongo's里面的管理方式

22:13.020 --> 22:14.020
不是mongo db

22:14.020 --> 22:15.020
mongo db

22:15.020 --> 22:16.020
有它的管理方式

22:16.020 --> 22:17.020
那么过于底层

22:17.020 --> 22:19.020
我们就不再去追溯了

22:19.020 --> 22:20.020
将来呢

22:20.020 --> 22:21.020
如果说我们出了一些

22:21.020 --> 22:22.020
高级的数据库课程的话

22:22.020 --> 22:23.020
可以在里面介绍

22:23.020 --> 22:24.020
其实

22:24.020 --> 22:26.020
数据库是一门方向

22:26.020 --> 22:27.020
它是一个

22:27.020 --> 22:28.020
它是一个职位

22:28.020 --> 22:29.020
知道吧

22:29.020 --> 22:30.020
我们作为开发

22:30.020 --> 22:31.020
前轮开发也好

22:31.020 --> 22:32.020
后轮开发也好

22:32.020 --> 22:33.020
了解的数据库

22:33.020 --> 22:34.020
实际上都比较浅的

22:34.020 --> 22:36.020
真正的数据库工程师

22:36.020 --> 22:37.020
里面聊的东西

22:37.020 --> 22:38.020
特别特别深

22:38.020 --> 22:39.020
好了

22:39.020 --> 22:40.020
我们这里就讲到这

22:40.020 --> 22:41.020
这是关于并马冲突

22:41.020 --> 22:42.020
作为扩展

22:42.020 --> 22:43.020
可能给大家介绍一下

