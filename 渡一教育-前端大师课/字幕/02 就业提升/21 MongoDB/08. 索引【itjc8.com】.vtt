WEBVTT

00:00.560 --> 00:04.560
这节课咱们说一下索印 这个概念大家了解一下

00:04.560 --> 00:07.560
其实这个概念还不仅仅是mongo DB里边

00:07.560 --> 00:10.560
还在那个mysgo里边也有这个概念

00:10.560 --> 00:12.560
包括我们前面讲的一个邮标 对吧

00:12.560 --> 00:14.560
一次移动了个邮标

00:14.560 --> 00:17.560
就是mysgo里边也有 这我们平时用不到而已

00:17.560 --> 00:20.560
mysgo里边 以其他的数据库

00:20.560 --> 00:22.560
他们都有索印这个概念

00:22.560 --> 00:24.560
索印是数据库里边的通用概念

00:24.560 --> 00:25.560
它用人家做什么呢

00:25.560 --> 00:27.560
它主要用来提高我们的查询速度

00:27.560 --> 00:30.560
特别是当我们数据量特别特别大的时候

00:30.560 --> 00:33.560
查询速度就会显著的降低

00:33.560 --> 00:35.560
整个数据库的查询方式有关系

00:35.560 --> 00:37.560
因此如果我们在大数据的时候

00:37.560 --> 00:41.560
通常会使用索印的方式来进行操作

00:41.560 --> 00:42.560
当然还有一些别的方式

00:42.560 --> 00:44.560
比如说像分布式这些东西

00:44.560 --> 00:47.560
那么这些东西就跟后端有关系了

00:47.560 --> 00:50.560
跟前端目前关系就不大

00:50.560 --> 00:52.560
大家说一下索印这个概念

00:52.560 --> 00:54.560
索印相当于是啥呢

00:54.560 --> 00:56.560
相当于是一个目录

00:56.560 --> 00:58.560
那么你在查这么阴汉池点

00:58.560 --> 01:00.560
新华字典的时候

01:00.560 --> 01:01.560
前面有个目录

01:01.560 --> 01:04.560
按偏旁部手查询按照拼音查询

01:04.560 --> 01:06.560
那么这样子它就非常有助于

01:06.560 --> 01:08.560
快速的定位到具体的内容

01:08.560 --> 01:10.560
如果说你想象一下

01:10.560 --> 01:12.560
如果说没有目录的话

01:12.560 --> 01:14.560
那么你查这个数据的

01:14.560 --> 01:15.560
是不是就非常麻烦

01:15.560 --> 01:16.560
是不是要逐条对比

01:16.560 --> 01:17.560
对不对

01:17.560 --> 01:18.560
所以有了目录的话

01:18.560 --> 01:20.560
就可以显著的提高查询效率

01:20.560 --> 01:22.560
咱们再看一下下面的当土

01:22.560 --> 01:24.560
如果说没有索印的话

01:24.560 --> 01:26.560
查询是一个什么样子

01:26.560 --> 01:27.560
我们如果说没有索印

01:27.560 --> 01:29.560
我们查询是这样子的

01:29.560 --> 01:31.560
逐条对比

01:31.560 --> 01:32.560
就第一条看一下

01:32.560 --> 01:33.560
比方我们查询用户

01:33.560 --> 01:36.560
年龄在十五到二十之间的用户

01:36.560 --> 01:37.560
那么就逐条对比

01:37.560 --> 01:39.560
第一条满不满足要求不满足

01:39.560 --> 01:41.560
第二条满不满足要求满足

01:41.560 --> 01:43.560
满足加入到查询结果

01:43.560 --> 01:44.560
第三条满不满足

01:44.560 --> 01:46.560
第四条满足加入到查询结果

01:46.560 --> 01:47.560
它是用这种对比方式的

01:47.560 --> 01:48.560
那你可以想象一下

01:48.560 --> 01:50.560
数据购如果说有

01:50.560 --> 01:52.560
十万条一百万条数据

01:52.560 --> 01:55.560
那么数据量特别特别巨大的时候

01:55.560 --> 01:57.560
这个查询速度就会显著的降低

01:57.560 --> 01:58.560
是不是这么回伤

01:58.560 --> 02:00.560
而且它存出的顺序

02:00.560 --> 02:02.560
那还是不一定的

02:02.560 --> 02:03.560
你可以想象字典里边

02:03.560 --> 02:05.560
默认情况下是不是按照拼音排序的

02:05.560 --> 02:08.560
实际上如果说你在字典里边

02:08.560 --> 02:09.560
它不是按照拼音排序的

02:09.560 --> 02:10.560
它是随便夹的

02:10.560 --> 02:12.560
那这个顺序就说不准了

02:12.560 --> 02:13.560
那里就很麻烦了

02:13.560 --> 02:16.560
你得真的一条一条对比

02:16.560 --> 02:17.560
非常麻烦

02:17.560 --> 02:20.560
这就是没有索印的时候的查询

02:21.560 --> 02:22.560
如果说你担了索印的话

02:22.560 --> 02:23.560
就变成这个样子了

02:23.560 --> 02:25.560
索印实际上就是一个目录

02:25.560 --> 02:27.560
它有一块耳外的存出空间

02:27.560 --> 02:28.560
那么在索印里边

02:28.560 --> 02:29.560
它始终是排好序的

02:29.560 --> 02:31.560
比方说我们针对年龄

02:31.560 --> 02:32.560
来创建了一个索印

02:32.560 --> 02:33.560
那么就相当于是

02:33.560 --> 02:36.560
创建了一块耳外的硬盘空间

02:36.560 --> 02:37.560
磁碳空间

02:37.560 --> 02:38.560
在空间里边

02:38.560 --> 02:39.560
我们就存出了

02:39.560 --> 02:40.560
年龄的一个排序

02:40.560 --> 02:41.560
生序排序

02:41.560 --> 02:42.560
先十一

02:42.560 --> 02:43.560
一共就这么些年龄

02:43.560 --> 02:44.560
十一十七十九

02:44.560 --> 02:45.560
那么每一个年龄

02:45.560 --> 02:47.560
它就对应真实的数据

02:47.560 --> 02:48.560
比方十一这个年龄

02:48.560 --> 02:49.560
它就对应到这条数据

02:49.560 --> 02:50.560
对应到这条数据

02:50.560 --> 02:51.560
你可以想想

02:51.560 --> 02:52.560
它里边有一个指针

02:52.560 --> 02:55.560
指向另外一块磁盘空间

02:55.560 --> 02:56.560
指向这个

02:56.560 --> 02:58.560
那么十七对指向这个

02:58.560 --> 02:59.560
十九指向这个

02:59.560 --> 03:00.560
那么我们在查的时候

03:00.560 --> 03:02.560
如果说我们的查询条件

03:02.560 --> 03:03.560
里边带了索印

03:03.560 --> 03:04.560
数据户的查询的时候

03:04.560 --> 03:05.560
它就会自动的

03:05.560 --> 03:06.560
去按照索印来查

03:06.560 --> 03:07.560
它怎么查呢

03:07.560 --> 03:08.560
它就不是逐条对比了

03:08.560 --> 03:10.560
不是在数据户里边逐条对比

03:10.560 --> 03:13.560
而是直接在年龄里边进行查询

03:13.560 --> 03:15.560
而且它这里边是排好序的

03:15.560 --> 03:16.560
里面都学过算法

03:16.560 --> 03:17.560
排好序过后

03:17.560 --> 03:20.560
是不是特别方便来定位

03:20.560 --> 03:21.560
我们要定位一个区间段

03:21.560 --> 03:23.560
或者是要定位某一个指示

03:23.560 --> 03:24.560
特别好定位

03:24.560 --> 03:25.560
你可以用择办查找

03:25.560 --> 03:27.560
也可以用那个就是

03:27.560 --> 03:30.560
计算出一个合适的位置

03:30.560 --> 03:32.560
在合适位置附近进行查找

03:32.560 --> 03:33.560
你可以非常快速的

03:33.560 --> 03:37.560
定位到它一个具体的位置

03:37.560 --> 03:39.560
那么比方说我们定位到哪了

03:39.560 --> 03:40.560
定位到十七十九

03:40.560 --> 03:42.560
十七十九是我们满足要求的

03:42.560 --> 03:43.560
很快就查出来了

03:43.560 --> 03:44.560
然后再根据十七十九

03:44.560 --> 03:45.560
它指向的空间

03:45.560 --> 03:46.560
然后找到对应的数据

03:46.560 --> 03:48.560
直接生成查询结果

03:48.560 --> 03:49.560
所以有了锁印过后

03:49.560 --> 03:50.560
查询速度就很快了

03:50.560 --> 03:51.560
那么这种做法呢

03:51.560 --> 03:53.560
其实就是用空间换时间

03:53.560 --> 03:54.560
对吧

03:54.560 --> 03:55.560
用一块额外的空间

03:55.560 --> 03:56.560
会换时间

03:56.560 --> 03:57.560
因此锁印的优缺点

03:57.560 --> 03:58.560
也非常明显

03:58.560 --> 04:00.560
优点就是能够显著的

04:00.560 --> 04:01.560
提高查询效率

04:01.560 --> 04:02.560
但是缺点的是什么呢

04:02.560 --> 04:05.560
会增加额外的存出空间

04:05.560 --> 04:07.560
这就是锁印

04:07.560 --> 04:09.560
它的这么概念

04:09.560 --> 04:10.560
那么在芒果地毕里边的

04:10.560 --> 04:11.560
锁印操作怎么来操作呢

04:11.560 --> 04:13.560
我们首先看一下

04:13.560 --> 04:14.560
首先是创建锁印

04:14.560 --> 04:15.560
那么在创建之前

04:15.560 --> 04:17.560
我们还是要来做一个测试

04:17.560 --> 04:19.560
以后给大家看一下效果

04:19.560 --> 04:20.560
因此呢

04:20.560 --> 04:22.560
我们要准备一个大的数据量

04:22.560 --> 04:23.560
现在的数据量呢

04:23.560 --> 04:24.560
肯定是

04:25.560 --> 04:27.560
现在数据量肯定是不够的

04:27.560 --> 04:28.560
比方说用户表

04:28.560 --> 04:29.560
用户这里呢

04:29.560 --> 04:30.560
我们看一下吧

04:30.560 --> 04:31.560
dbcult

04:32.560 --> 04:34.560
看一下一共有多少个用户

04:34.560 --> 04:35.560
运行

04:36.560 --> 04:37.560
users

04:38.560 --> 04:39.560
cult

04:40.560 --> 04:41.560
我看一下这结果

04:41.560 --> 04:42.560
403个用户

04:42.560 --> 04:43.560
这个是明显不够的

04:43.560 --> 04:44.560
我们再加一些吧

04:44.560 --> 04:45.560
新建个文件

04:46.560 --> 04:48.560
add test users

04:48.560 --> 04:49.560
再加一些吧

04:49.560 --> 04:50.560
那么我们这里写个函数

04:50.560 --> 04:51.560
我先导入吧

04:52.560 --> 04:55.870
require导入一个

04:56.870 --> 04:59.870
导入一个models

05:00.870 --> 05:01.870
user

05:01.870 --> 05:03.870
然后写个函数

05:03.870 --> 05:04.870
添加add

05:05.870 --> 05:06.870
我们这里取调这个函数

05:06.870 --> 05:07.870
add

05:07.870 --> 05:08.870
添加里边呢

05:08.870 --> 05:10.870
我们写上一个数据

05:10.870 --> 05:12.870
有多种添加方式

05:12.870 --> 05:13.870
我们一般就是用一个

05:13.870 --> 05:15.870
如果你要添加大量数据的话

05:15.870 --> 05:18.870
应该是先在内存里边准备好一个数据

05:18.870 --> 05:19.870
不要一条一条添加

05:19.870 --> 05:21.870
那这样子的话太慢了

05:21.870 --> 05:23.870
最好是先准备好一个数据

05:23.870 --> 05:24.870
比方添加多个数据

05:24.870 --> 05:25.870
然后呢

05:25.870 --> 05:26.870
循环

05:26.870 --> 05:28.870
我们再把数据填充吧

05:28.870 --> 05:30.870
比方说我们要添加10万条数据

05:31.870 --> 05:32.870
10万条

05:33.870 --> 05:35.870
然后我们给每一个数据里边加一下

05:35.870 --> 05:37.870
现在跟数据过没有关系对不对

05:37.870 --> 05:38.870
是在内存里边操作

05:38.870 --> 05:39.870
我们来

05:39.870 --> 05:40.870
locking id

05:40.870 --> 05:41.870
locking id有什么呢

05:41.870 --> 05:43.870
这也就是随便来一个吧

05:43.870 --> 05:44.870
有了下滑线

05:44.870 --> 05:45.870
拼接一个

05:46.870 --> 05:47.870
locking password

05:47.870 --> 05:49.870
密码的密码随便来一个吧

05:49.870 --> 05:51.870
我们就在这里随便找一个密码

05:51.870 --> 05:52.870
密码重复就行了

05:53.870 --> 05:54.870
copy by id

05:56.870 --> 05:57.870
密码

05:57.870 --> 05:59.870
然后连继呢

05:59.870 --> 06:00.870
连继我们随机吗

06:00.870 --> 06:02.870
我们这里写个随机函数

06:05.870 --> 06:06.870
东西

06:06.870 --> 06:07.870
min max

06:07.870 --> 06:09.870
这个函数不用讲了吧

06:10.870 --> 06:11.870
都学到这了

06:11.870 --> 06:13.870
这个函数应该是非常简单的

06:13.870 --> 06:14.870
right

06:14.870 --> 06:15.870
成义

06:15.870 --> 06:16.870
max

06:16.870 --> 06:17.870
解密

06:17.870 --> 06:22.020
加上密

06:22.020 --> 06:24.020
然后我们这里的使用right

06:26.020 --> 06:28.020
10到50

06:28.020 --> 06:30.020
10到50之间水机生成一个连继

06:31.020 --> 06:32.020
连继

06:32.020 --> 06:34.020
性名化我们就用test

06:34.020 --> 06:35.020
随便用一个名字

06:35.020 --> 06:36.020
因为我们主要是关注连继的查询

06:36.020 --> 06:38.020
我们要为连继来创建所谓

06:38.020 --> 06:40.020
然后我们这test

06:41.020 --> 06:43.020
这些都要经过验证

06:55.020 --> 06:56.020
那么输主是不是准备好了

06:56.020 --> 06:57.020
准备好了之后

06:57.020 --> 06:59.020
我们是不是可以利用模型里面的

06:59.020 --> 07:00.020
我们之前讲了

07:00.020 --> 07:01.020
create

07:01.020 --> 07:02.020
create方法把输主传进去

07:02.020 --> 07:03.020
对不对

07:03.020 --> 07:04.020
来添加多个用户

07:04.020 --> 07:05.020
但是我建议大家

07:05.020 --> 07:07.020
这里就尽量不要使用

07:08.020 --> 07:10.020
就尽量不要使用create函数了

07:10.020 --> 07:11.020
为什么呢

07:11.020 --> 07:13.020
为什么尽量不要使用create函数呢

07:13.020 --> 07:15.020
因为这个create函数我们之前讲过

07:15.020 --> 07:17.020
它能不能添加多少进入

07:17.020 --> 07:18.020
可以

07:18.020 --> 07:19.020
但它添加的方式是什么

07:19.020 --> 07:21.020
是不是在循环我们的输主

07:21.020 --> 07:22.020
每一次循环

07:22.020 --> 07:23.020
创建一个

07:23.020 --> 07:24.020
模型实地

07:24.020 --> 07:25.020
然后最终还是调用了

07:25.020 --> 07:26.020
模型实地的safe方法

07:26.020 --> 07:28.020
实际上它还是一条一条添加的

07:28.020 --> 07:29.020
对吧

07:29.020 --> 07:30.020
而我们的数据库

07:30.020 --> 07:31.020
里面是支持

07:31.020 --> 07:32.020
我们之前学过的

07:32.020 --> 07:33.020
直接在mongodb里面

07:33.020 --> 07:35.020
原生操作是不是有一个insert many

07:35.020 --> 07:36.020
对不对

07:36.020 --> 07:37.020
一下子添加多条

07:37.020 --> 07:38.020
那是真的

07:38.020 --> 07:39.020
一下子添加多条的

07:39.020 --> 07:40.020
所以说我们这里

07:40.020 --> 07:41.020
最好使用

07:41.020 --> 07:42.020
它提供了另外一个函数

07:42.020 --> 07:43.020
叫insert many

07:43.020 --> 07:44.020
就是如果说你添加数据量

07:44.020 --> 07:45.020
比较大的

07:45.020 --> 07:46.020
比方说

07:46.020 --> 07:47.020
超过了百条

07:47.020 --> 07:48.020
一千条

07:48.020 --> 07:49.020
上万条

07:49.020 --> 07:50.020
像我这个十万条数据

07:50.020 --> 07:51.020
比较大的

07:51.020 --> 07:52.020
我建议你使用这个insert many

07:52.020 --> 07:53.020
但是insert many

07:53.020 --> 07:55.020
它反回的是什么呢

07:55.020 --> 07:56.020
反回的

07:56.020 --> 07:58.020
其实还是一个

07:58.020 --> 07:59.020
数据

07:59.020 --> 08:00.020
差不多的

08:00.020 --> 08:01.020
所以说建议多条的数据的话

08:01.020 --> 08:02.020
还是建议大家

08:02.020 --> 08:04.020
使用这个insert many好一点

08:04.020 --> 08:05.020
我们这里

08:06.020 --> 08:07.020
是不是传进去

08:07.020 --> 08:08.020
然后我们这里是不是等待它

08:08.020 --> 08:09.020
对吧

08:09.020 --> 08:11.020
我不太希望它进行验证了

08:11.020 --> 08:13.020
因为验证会比较浪费时间

08:13.020 --> 08:14.020
我们毕竟有那么多

08:14.020 --> 08:15.020
这么多条数据

08:15.020 --> 08:16.020
验证比较浪费时间

08:16.020 --> 08:17.020
所以说我们看一下

08:17.020 --> 08:18.020
有OB形式

08:21.020 --> 08:22.020
装没有这个

08:22.020 --> 08:24.020
before the validator

08:24.020 --> 08:26.020
为什么没有呢

08:27.020 --> 08:28.020
算了吧

08:29.020 --> 08:30.020
可以查一下文档

08:30.020 --> 08:31.020
可以禁止它验证

08:31.020 --> 08:32.020
因为我们之前讲过了

08:32.020 --> 08:33.020
禁止它验证

08:33.020 --> 08:34.020
是不是可以在模型里面

08:34.020 --> 08:35.020
搜索一下

08:37.020 --> 08:38.020
模型里面

08:38.020 --> 08:39.020
叫做

08:39.020 --> 08:40.020
算了算了

08:40.020 --> 08:41.020
就直接来吧

08:41.020 --> 08:42.020
我之前讲过的

08:42.020 --> 08:44.020
我们这里就输出

08:44.020 --> 08:46.020
添加数据完成

08:46.020 --> 08:48.020
前面我们来输出一句

08:48.020 --> 08:49.020
输出一下

08:49.020 --> 08:50.020
这个就是

08:50.020 --> 08:52.020
构造数据完成

08:52.020 --> 08:54.020
我们先把数据

08:54.020 --> 08:55.020
构造完成

08:55.020 --> 08:56.020
然后再把数据添加进去

08:56.020 --> 08:57.020
好 写好了

08:57.020 --> 08:58.020
然后建议到运行

08:58.020 --> 09:00.020
load adds

09:00.020 --> 09:02.020
运行一下

09:02.020 --> 09:03.020
构造数据很快完成了

09:03.020 --> 09:04.020
你看可以

09:04.020 --> 09:05.020
直观的看得到

09:05.020 --> 09:06.020
在数据库的操作里面

09:06.020 --> 09:07.020
是比较慢的

09:07.020 --> 09:08.020
实际上它没有那么慢

09:08.020 --> 09:10.020
主要是它这里有验证

09:10.020 --> 09:11.020
这里有验证

09:11.020 --> 09:12.020
没有把验证关掉

09:12.020 --> 09:13.020
所以它很多时候

09:13.020 --> 09:16.020
是消耗在验证的数据那一块

09:17.020 --> 09:18.020
让它等吧

09:18.020 --> 09:19.020
等它添加完成

09:19.020 --> 09:20.020
十万条数据

09:20.020 --> 09:21.020
还是得等一会

09:22.020 --> 09:23.020
添加完成过后

09:23.020 --> 09:24.020
我们就可以

09:24.020 --> 09:25.020
我们在这边开始写

09:25.020 --> 09:26.020
得音这个声

09:26.020 --> 09:27.020
点击是里面开始写

09:27.020 --> 09:28.020
我们在这边写个函数

09:28.020 --> 09:30.020
来测试一下

09:30.020 --> 09:31.020
这么多数据

09:31.020 --> 09:32.020
里面我们去查询

09:32.020 --> 09:34.020
按照年龄来查询

09:34.020 --> 09:36.020
我们用扩子

09:36.020 --> 09:37.020
直接看一个数量

09:37.020 --> 09:38.020
因为你查到内存里面

09:38.020 --> 09:39.020
它在内存里面

09:39.020 --> 09:40.020
勾件还要一段时间

09:40.020 --> 09:41.020
对不对

09:41.020 --> 09:42.020
所以说我们在

09:42.020 --> 09:43.020
直接查一个数量

09:43.020 --> 09:45.020
那么对内存的消耗就比较少了

09:45.020 --> 09:46.020
它主要是在

09:46.020 --> 09:47.020
词汉里面操作

09:47.020 --> 09:48.020
那么我们的查询条件

09:48.020 --> 09:49.020
扩子里面

09:49.020 --> 09:51.020
也是可以跟查询条件的

09:51.020 --> 09:52.020
就看满足条件的

09:52.020 --> 09:53.020
有多少个

09:53.020 --> 09:54.020
我们查询条件

09:54.020 --> 09:56.020
就是跟一个年龄

09:56.020 --> 09:59.020
年龄在25到30之间

09:59.020 --> 10:00.020
GT

10:00.020 --> 10:01.020
25

10:01.020 --> 10:02.020
LT

10:02.020 --> 10:03.020
30

10:03.020 --> 10:04.020
小于30

10:04.020 --> 10:05.020
大于25

10:05.020 --> 10:06.020
在这之间

10:06.020 --> 10:07.020
我们来看一下

10:07.020 --> 10:08.020
一共有多少个

10:08.020 --> 10:10.020
Number

10:10.020 --> 10:11.020
为了看一下

10:11.020 --> 10:12.020
我们的查询效率

10:12.020 --> 10:13.020
我们在查询之前

10:13.020 --> 10:17.020
先来进入一个时间

10:17.020 --> 10:19.020
然后查询之后

10:19.020 --> 10:21.020
再来时间

10:21.020 --> 10:25.020
最后我们输出查询结果

10:25.020 --> 10:26.020
Number

10:26.020 --> 10:27.020
输出一共有多少个

10:27.020 --> 10:28.020
我们就写的话

10:28.020 --> 10:29.020
这么一个函数

10:31.460 --> 10:32.460
那么这里

10:32.460 --> 10:33.460
数据已经完成了

10:33.460 --> 10:34.460
我们来看一下

10:34.460 --> 10:35.460
我们的数据

10:35.460 --> 10:36.460
是不是有十万条了

10:36.460 --> 10:37.460
运行

10:37.460 --> 10:39.460
已经有十万多条数据了

10:39.460 --> 10:40.460
好

10:40.460 --> 10:41.460
接下来我们来运行

10:41.460 --> 10:42.460
这个查询

10:42.460 --> 10:43.460
看一下

10:43.460 --> 10:44.460
现在我们目前是

10:44.460 --> 10:45.460
没有所应的

10:45.460 --> 10:46.460
那么我们来运行

10:46.460 --> 10:47.460
这个查询

10:47.460 --> 10:48.460
Node Index

10:48.460 --> 10:49.460
Index

10:49.460 --> 10:50.460
查询的时间

10:50.460 --> 10:51.460
是多少

10:51.460 --> 10:52.460
有77毫秒

10:52.460 --> 10:53.460
还是没有那么夸张

10:53.460 --> 10:54.460
对吧

10:54.460 --> 10:55.460
Cost Document

10:55.460 --> 10:56.460
要报警告

10:58.460 --> 10:59.460
一共有76毫秒

10:59.460 --> 11:00.460
总之70

11:00.460 --> 11:01.460
再来一次

11:01.460 --> 11:02.460
评论时间

11:02.460 --> 11:04.460
大概就是70多毫秒

11:04.460 --> 11:05.460
70多毫秒的时间

11:05.460 --> 11:06.460
没有那么夸张

11:06.460 --> 11:07.460
因为我们的数据量

11:07.460 --> 11:08.460
毕竟还是有限

11:08.460 --> 11:09.460
只有十万条

11:09.460 --> 11:10.460
可以想象以后

11:10.460 --> 11:11.460
数据量不断的加

11:11.460 --> 11:12.460
不断的一条一条加

11:12.460 --> 11:13.460
对吧

11:13.460 --> 11:14.460
别看它一条一条加

11:15.460 --> 11:16.460
这个数据还是很快的

11:16.460 --> 11:18.460
一两就是几天过后

11:18.460 --> 11:19.460
可能数据变得很大了

11:19.460 --> 11:20.460
特别像有一些数据

11:20.460 --> 11:21.460
比如说

11:21.460 --> 11:22.460
操作基督的这种数据

11:22.460 --> 11:23.460
所以可能会变得

11:23.460 --> 11:24.460
非常非常大

11:24.460 --> 11:25.460
那么数据量

11:25.460 --> 11:26.460
比较大的过后

11:26.460 --> 11:27.460
我们查询的时间

11:27.460 --> 11:28.460
是70多毫秒

11:28.460 --> 11:29.460
接下来我们来创建索引

11:29.460 --> 11:31.460
看怎么来创建索引

11:31.460 --> 11:32.460
创建索引是用

11:32.460 --> 11:33.460
DB Connection

11:33.460 --> 11:34.460
Crazy Index

11:34.460 --> 11:35.460
当然我们在

11:35.460 --> 11:36.460
MongoDB里面创建索引

11:36.460 --> 11:37.460
是非常简单的

11:37.460 --> 11:38.460
就在模型里面

11:38.460 --> 11:39.460
比如说A级里面

11:39.460 --> 11:40.460
我们加一个配置

11:40.460 --> 11:41.460
Index为Q就行了

11:41.460 --> 11:42.460
这个很简单

11:42.460 --> 11:44.460
我们主要是看一下

11:44.460 --> 11:46.460
看一下在MongoDB里面

11:46.460 --> 11:47.460
原生环境里面

11:47.460 --> 11:48.460
怎么来创建索引

11:48.460 --> 11:49.460
我们先开一个

11:50.460 --> 11:51.460
Mongo

11:51.460 --> 11:53.460
然后创建索引的方式是

11:53.460 --> 11:54.460
DB

11:54.460 --> 11:55.460
后面是集合的名字

11:55.460 --> 11:56.460
我们用User是集合

11:56.460 --> 11:57.460
往这个集合里面

11:57.460 --> 11:58.460
创建一个索引

11:58.460 --> 11:59.460
你看

11:59.460 --> 12:00.460
看这个图

12:00.460 --> 12:01.460
对吧

12:01.460 --> 12:02.460
我们针对这个集合

12:02.460 --> 12:04.460
来创建一个索引

12:04.460 --> 12:05.460
其实就是创建一块

12:05.460 --> 12:06.460
磁盘区域

12:06.460 --> 12:07.460
这个区域里面

12:07.460 --> 12:08.460
记录了一些信息

12:08.460 --> 12:09.460
而且它是有排好序的

12:09.460 --> 12:10.460
那么这里是用

12:10.460 --> 12:11.460
Crazy Index

12:11.460 --> 12:12.460
以前是使用

12:12.460 --> 12:14.460
Infure Index

12:14.460 --> 12:15.460
那么现在改过了

12:15.460 --> 12:16.460
改成这个函数了

12:16.460 --> 12:17.460
Crazy Index

12:17.460 --> 12:18.460
这就是我们

12:18.460 --> 12:19.460
之前为什么这里包警告

12:19.460 --> 12:20.460
这个地方是不是包警告

12:20.460 --> 12:21.460
对吧

12:21.460 --> 12:22.460
以前的MongoDB版本

12:22.460 --> 12:23.460
它要使用

12:23.460 --> 12:24.460
Infure Index

12:24.460 --> 12:25.460
那么现在是使用

12:25.460 --> 12:26.460
这个函数

12:26.460 --> 12:28.460
然后里面有两个参数

12:28.460 --> 12:29.460
第一个参数就是一个对象

12:29.460 --> 12:30.460
你看

12:30.460 --> 12:32.460
第一个参数是一个对象

12:32.460 --> 12:33.460
这个对象里面

12:33.460 --> 12:34.460
进入了你索引的

12:34.460 --> 12:35.460
关联的之段

12:35.460 --> 12:36.460
比方说你看这里

12:36.460 --> 12:37.460
这个索引

12:37.460 --> 12:38.460
是不是关联的A几之段

12:38.460 --> 12:39.460
对不对

12:39.460 --> 12:40.460
而且它里面是不是有排序

12:40.460 --> 12:42.460
那么这里的记录说

12:42.460 --> 12:43.460
我关联A几之段

12:43.460 --> 12:44.460
排序为生序

12:44.460 --> 12:46.460
如果说是僵序的话

12:46.460 --> 12:47.460
就用附移

12:47.460 --> 12:48.460
那么生序和僵序

12:48.460 --> 12:49.460
会影响什么呢

12:49.460 --> 12:50.460
如果说你查询

12:50.460 --> 12:51.460
经常查询的

12:51.460 --> 12:52.460
比方说

12:52.460 --> 12:53.460
假设

12:53.460 --> 12:55.460
假设年龄端

12:55.460 --> 12:57.460
是0到1到100

12:57.460 --> 12:59.460
但是我们主要的查询年龄

12:59.460 --> 13:00.460
集中在什么

13:00.460 --> 13:02.460
集中在10到20岁

13:02.460 --> 13:03.460
或者是10到30岁

13:03.460 --> 13:04.460
是不是用生序排序

13:04.460 --> 13:06.460
就更加容易很快的命中

13:06.460 --> 13:08.460
我们想要查到的目标

13:08.460 --> 13:10.460
如果说用僵序排序的话

13:10.460 --> 13:11.460
那么前面的数据

13:11.460 --> 13:13.460
是不是我们不太常用的

13:13.460 --> 13:14.460
生序僵序

13:14.460 --> 13:15.460
来看具体情况

13:15.460 --> 13:16.460
那么我们这里

13:16.460 --> 13:18.460
按生序排序A几为1

13:18.460 --> 13:19.460
那么这里

13:19.460 --> 13:20.460
就可以创建索引了

13:20.460 --> 13:21.460
那么第二个参数

13:21.460 --> 13:22.460
是Obsing

13:22.460 --> 13:23.460
就是有些配置

13:23.460 --> 13:24.460
第一个参数

13:24.460 --> 13:25.460
A几为1

13:26.460 --> 13:27.460
那么后边的参数

13:27.460 --> 13:28.460
是一些配置

13:28.460 --> 13:29.460
比方说后边

13:29.460 --> 13:30.460
我们可以给索引取个名字

13:30.460 --> 13:31.460
随便给他取个名字

13:31.460 --> 13:32.460
比方说

13:32.460 --> 13:33.460
取个他的名字

13:33.460 --> 13:36.460
UserA几

13:36.460 --> 13:37.460
给索引取个名字

13:37.460 --> 13:38.460
还有什么

13:38.460 --> 13:40.460
还有什么Beground

13:40.460 --> 13:41.460
这个创建索引

13:41.460 --> 13:43.460
它需要一定过程

13:43.460 --> 13:44.460
你看它是跟尺盘打交道

13:44.460 --> 13:45.460
对不对

13:45.460 --> 13:46.460
是不是需要一定过程

13:46.460 --> 13:47.460
时间和过程

13:47.460 --> 13:48.460
那么在这个时间内

13:48.460 --> 13:50.460
有可能会主设

13:50.460 --> 13:51.460
数据库的其他操作

13:51.460 --> 13:52.460
就数据库不能动了

13:52.460 --> 13:53.460
然后这个时候

13:53.460 --> 13:54.460
有人来访问我们的网站

13:54.460 --> 13:55.460
他要用到数据库

13:55.460 --> 13:56.460
我们网站服务器

13:56.460 --> 13:57.460
要用到数据库

13:57.460 --> 13:58.460
那么这个时候

13:58.460 --> 14:00.460
又掐好我们在创建索引

14:00.460 --> 14:01.460
它可能会主设这个操作

14:01.460 --> 14:02.460
那么如果说

14:02.460 --> 14:03.460
你把这个东西设为处

14:03.460 --> 14:05.460
那么索引的创建过程

14:05.460 --> 14:06.460
是在后台完成的

14:06.460 --> 14:07.460
那么这个时候

14:07.460 --> 14:09.460
它是不会主设的

14:09.460 --> 14:10.460
没意思吧

14:10.460 --> 14:12.460
这是Obsing

14:12.460 --> 14:13.460
Beground的

14:13.460 --> 14:15.460
跟我们有没有多关系

14:15.460 --> 14:16.460
Ulico表示

14:16.460 --> 14:17.460
这个事物

14:17.460 --> 14:18.460
是不是唯一索引

14:18.460 --> 14:19.460
像我们之前

14:19.460 --> 14:20.460
在配置这个结构的时候

14:20.460 --> 14:21.460
这里用个Ulico

14:21.460 --> 14:22.460
对吧

14:22.460 --> 14:23.460
那么这个就表示的是

14:23.460 --> 14:24.460
使用唯一索引

14:24.460 --> 14:26.460
那边的就是索引的名称

14:26.460 --> 14:27.460
好

14:27.460 --> 14:28.460
那么这里就完了

14:28.460 --> 14:29.460
完事了

14:29.460 --> 14:30.460
唯一索引就是表示

14:30.460 --> 14:31.460
我们这个数据

14:31.460 --> 14:33.460
就索引这个区域的数据

14:33.460 --> 14:35.460
它必须唯一

14:35.460 --> 14:36.460
就这里面的数据

14:36.460 --> 14:37.460
它就这里面的索引

14:37.460 --> 14:39.460
它一个只能指向一个

14:39.460 --> 14:40.460
一个只能指向一个

14:40.460 --> 14:41.460
它不能指向多个

14:41.460 --> 14:42.460
就这么个意思

14:42.460 --> 14:43.460
好 那么这里

14:43.460 --> 14:44.460
我们这里

14:44.460 --> 14:45.460
给它取个名字就行了

14:45.460 --> 14:47.460
一回头

14:47.460 --> 14:49.460
索引就创建好了

14:49.460 --> 14:50.460
告诉你什么呢

14:50.460 --> 14:51.460
给我们的

14:51.460 --> 14:52.460
之前的索引有两个

14:52.460 --> 14:53.460
之后的

14:53.460 --> 14:54.460
创建之后

14:54.460 --> 14:55.460
索引有三个

14:55.460 --> 14:56.460
为什么有三个索引

14:56.460 --> 14:57.460
以后我们看

14:57.460 --> 14:58.460
OK 表示我们的

14:58.460 --> 14:59.460
创建完成

14:59.460 --> 15:00.460
没问题吧

15:00.460 --> 15:01.460
好 那么最后

15:01.460 --> 15:02.460
我们看一下

15:02.460 --> 15:03.460
后边的操作

15:03.460 --> 15:04.460
其他的索引

15:04.460 --> 15:05.460
不要说我们可以通过

15:05.460 --> 15:08.460
这个 db users gets indexes

15:08.460 --> 15:09.460
可以看到我们

15:09.460 --> 15:10.460
这个集合里面

15:10.460 --> 15:11.460
目前的索引

15:11.460 --> 15:12.460
你看有三个

15:12.460 --> 15:13.460
一个是id

15:13.460 --> 15:15.460
所有的表里边

15:15.460 --> 15:16.460
id 它会默认

15:16.460 --> 15:17.460
给你建一个索引

15:17.460 --> 15:19.460
因为我们经常都会

15:19.460 --> 15:20.460
id在查询

15:20.460 --> 15:21.460
组建我们查询的

15:21.460 --> 15:22.460
情况是比较多的

15:22.460 --> 15:23.460
特别是根据

15:23.460 --> 15:24.460
组建查询单条数据

15:24.460 --> 15:25.460
是不是非常多的

15:25.460 --> 15:26.460
所以id 它

15:26.460 --> 15:27.460
会自动给你建一个索引

15:27.460 --> 15:28.460
然后呢

15:28.460 --> 15:29.460
我们装建 id 是我们

15:29.460 --> 15:30.460
自己建的索引

15:30.460 --> 15:31.460
然后我们自己建的

15:31.460 --> 15:32.460
那个索引

15:32.460 --> 15:33.460
名字叫做 user age

15:33.460 --> 15:35.460
这是一个年龄

15:35.460 --> 15:37.460
关联的是年龄之段

15:37.460 --> 15:38.460
好了

15:38.460 --> 15:39.460
我们创建好索引过后

15:39.460 --> 15:40.460
我们再来进行查询

15:40.460 --> 15:41.460
查询那些方式

15:41.460 --> 15:42.460
代码就完全不变

15:42.460 --> 15:43.460
有了索引之后

15:43.460 --> 15:44.460
你看一下查询

15:44.460 --> 15:46.460
是不是就快了很多

15:46.460 --> 15:47.460
对吧 就快了很多

15:47.460 --> 15:48.460
而且这个

15:48.460 --> 15:49.460
速度呢

15:49.460 --> 15:51.460
就是数据量越大

15:51.460 --> 15:53.460
它提升的效率就越高

15:53.460 --> 15:54.460
数据量越大

15:54.460 --> 15:56.460
提升效率就越高

15:56.460 --> 15:57.460
你看

15:57.460 --> 15:59.460
对吧 是明显快了很多

15:59.460 --> 16:00.460
这就是索引

16:00.460 --> 16:01.460
当然呢

16:01.460 --> 16:03.460
也会占用额外的存储空间

16:03.460 --> 16:04.460
这是肯定的

16:04.460 --> 16:05.460
跟内存没有关系

16:05.460 --> 16:06.460
主要是跟磁盘

16:06.460 --> 16:07.460
会占用磁盘的存储空间

16:07.460 --> 16:08.460
不过呢

16:08.460 --> 16:09.460
我们现在磁盘呢

16:09.460 --> 16:11.460
都比较便宜了

16:11.460 --> 16:12.460
什么都比较低了

16:12.460 --> 16:13.460
所以说呢

16:13.460 --> 16:14.460
我们可以

16:14.460 --> 16:15.460
就是更多的

16:15.460 --> 16:16.460
会用到这个索引

16:16.460 --> 16:17.460
提升效率

16:17.460 --> 16:18.460
那索引的一些其他操作

16:18.460 --> 16:19.460
刚才我们看到了

16:19.460 --> 16:20.460
查询所谓的

16:20.460 --> 16:21.460
目前的某一个集合里面

16:21.460 --> 16:22.460
所谓的索引

16:22.460 --> 16:23.460
还可以看到这个DB

16:23.460 --> 16:26.460
U2是什么Total Index Size

16:26.460 --> 16:28.460
可以看到目前

16:28.460 --> 16:30.460
索引占用的磁盘空间

16:30.460 --> 16:31.460
占用多少空间呢

16:31.460 --> 16:34.460
占用了多少个字节呢

16:34.460 --> 16:35.460
占用了两兆多

16:35.460 --> 16:36.460
对吧 占用了两兆多

16:36.460 --> 16:37.460
这是

16:37.460 --> 16:39.460
这是K3

16:39.460 --> 16:40.460
三个EV

16:40.460 --> 16:41.460
三个EV

16:41.460 --> 16:43.460
这是500多KB

16:43.460 --> 16:44.460
2.5兆

16:44.460 --> 16:46.460
2.5兆的就是

16:46.460 --> 16:47.460
差不多

16:47.460 --> 16:49.460
因为这个金位单位是1024

16:49.460 --> 16:50.460
差不多是20

16:50.460 --> 16:52.460
就是2.5兆的

16:52.460 --> 16:54.460
磁盘空间

16:54.460 --> 16:55.460
我们的数据量

16:55.460 --> 16:56.460
会随着数据量越多

16:56.460 --> 16:58.460
我们的索引的占用的空间就越多

16:58.460 --> 16:59.460
比方说我们后边

16:59.460 --> 17:00.460
又继续往用户里边讲

17:00.460 --> 17:02.460
它会继续更新这个索引

17:02.460 --> 17:04.460
因此它会

17:04.460 --> 17:06.460
磁盘空间会越占越多

17:06.460 --> 17:07.460
然后我们要

17:07.460 --> 17:08.460
删除所有的索引的话

17:08.460 --> 17:09.460
我们就用Drop Index Size

17:09.460 --> 17:11.460
删除所有的索引

17:11.460 --> 17:13.460
就是把所有的索引全部删除

17:13.460 --> 17:14.460
然后呢

17:14.460 --> 17:15.460
如果说你只删除一个的话

17:15.460 --> 17:17.460
那么可以用Drop Index

17:17.460 --> 17:19.460
删除指定的所有名称

17:19.460 --> 17:20.460
索引名称

17:20.460 --> 17:21.460
我们刚才不是给索引取了个名字吗

17:21.460 --> 17:23.460
你可以通过这个来查看

17:24.460 --> 17:26.460
是不是每个索引都有个名字

17:26.460 --> 17:28.460
如果说你不指定名字的话

17:28.460 --> 17:29.460
它会给你用一个自动的名字

17:29.460 --> 17:31.460
你看这个东西就是自动的名字

17:31.460 --> 17:32.460
Login ID

17:32.460 --> 17:33.460
下滑线

17:33.460 --> 17:34.460
后面要跟上一个E

17:34.460 --> 17:35.460
对吧

17:35.460 --> 17:36.460
它的排序方式

17:37.460 --> 17:38.460
这是就是创建索引

17:38.460 --> 17:39.460
那么最后呢

17:39.460 --> 17:41.460
我们说一下关于这个索引

17:41.460 --> 17:42.460
跟我们写单码

17:42.460 --> 17:43.460
这也没什么关系

17:43.460 --> 17:44.460
对不对

17:44.460 --> 17:46.460
跟那个索引相关的一些

17:46.460 --> 17:47.460
最佳实践

17:47.460 --> 17:48.460
如果我们平时要用

17:48.460 --> 17:49.460
要创建索引的话怎么来

17:49.460 --> 17:50.460
什么情况下要去创建

17:50.460 --> 17:51.460
第一个呢

17:51.460 --> 17:52.460
就是数据量

17:52.460 --> 17:53.460
特别特别巨大的时候呢

17:53.460 --> 17:54.460
我们一般

17:54.460 --> 17:55.460
可以为它创建一些索引

17:55.460 --> 17:56.460
因为查询速度

17:56.460 --> 17:58.460
不可避免的不会变慢

17:58.460 --> 17:59.460
另外一个呢

17:59.460 --> 18:01.460
就是对我们常用的查询

18:01.460 --> 18:02.460
或者是排序

18:02.460 --> 18:03.460
排序也会用到索引的

18:03.460 --> 18:04.460
它会自动使用的

18:04.460 --> 18:07.460
对我们常用的查询条件

18:07.460 --> 18:08.460
或者是排序的制断

18:08.460 --> 18:09.460
来使用索引

18:09.460 --> 18:10.460
将我们年龄

18:10.460 --> 18:11.460
如果说

18:11.460 --> 18:12.460
用到年龄来进行查询

18:12.460 --> 18:13.460
那么我们可以

18:13.460 --> 18:15.460
对它使用索引

18:15.460 --> 18:16.460
然后呢

18:16.460 --> 18:17.460
第三个就是尽量避免

18:17.460 --> 18:19.460
在程序运行过程中

18:19.460 --> 18:21.460
频繁的创建和删除索引

18:21.460 --> 18:23.460
因为删除索引和创建索引

18:23.460 --> 18:24.460
特别是数据量

18:24.460 --> 18:25.460
比较巨大的时候

18:25.460 --> 18:26.460
它要去勾件

18:26.460 --> 18:27.460
另外一块时达空间

18:27.460 --> 18:29.460
这个还是需要一段过程的

18:29.460 --> 18:30.460
数据量越大

18:30.460 --> 18:31.460
勾建索引的时间

18:31.460 --> 18:32.460
就越长

18:32.460 --> 18:33.460
因此呢

18:33.460 --> 18:35.460
你在程序正在运行

18:35.460 --> 18:37.460
用户正在访问我们的网站

18:37.460 --> 18:38.460
正要用用数据户

18:38.460 --> 18:39.460
我们尽量的避免

18:39.460 --> 18:40.460
去创建和删除索引

18:41.460 --> 18:42.460
在网站维护期间

18:42.460 --> 18:43.460
就是网站停了

18:43.460 --> 18:44.460
或者是什么呢

18:44.460 --> 18:46.460
或者是我们网站上线之前

18:46.460 --> 18:48.460
就把这些东西创建好

18:48.460 --> 18:49.460
当然了

18:49.460 --> 18:51.460
现在不太有那种停网站的操作了

18:51.460 --> 18:53.460
我们一般的会在服务器端

18:53.460 --> 18:55.460
去打减一些分布式服务器

18:55.460 --> 18:56.460
就是我这台

18:56.460 --> 18:58.460
我现在在这一边

18:58.460 --> 18:59.460
就是我们在这一边

18:59.460 --> 19:00.460
部署服务器上

19:00.460 --> 19:01.460
先勾件索引

19:01.460 --> 19:02.460
然后呢

19:02.460 --> 19:03.460
把先把网站移动到

19:03.460 --> 19:04.460
另外一些服务器

19:04.460 --> 19:06.460
给用户提供访问

19:06.460 --> 19:07.460
然后我们勾件好

19:07.460 --> 19:08.460
索引的过程

19:08.460 --> 19:09.460
再把网站移过来

19:09.460 --> 19:10.460
这样就可以无缝交接了

19:10.460 --> 19:11.460
那么这些东西

19:11.460 --> 19:13.460
是属于服务器部署的一些知识

19:13.460 --> 19:15.460
以及服务器架构的一些知识

19:15.460 --> 19:16.460
我们这里前端

19:16.460 --> 19:18.460
就不做过得了了解了

19:18.460 --> 19:19.460
这里呢

19:19.460 --> 19:20.460
我就顺便再说一个

19:20.460 --> 19:21.460
就MangoDB里面

19:21.460 --> 19:22.460
所应的存储的结构

19:22.460 --> 19:23.460
是递减数

19:23.460 --> 19:24.460
是一个数据结构

19:24.460 --> 19:26.460
它不是二叉数

19:26.460 --> 19:27.460
B数呢

19:27.460 --> 19:28.460
它是一个

19:28.460 --> 19:29.460
B数呢

19:29.460 --> 19:30.460
是一个平衡数

19:30.460 --> 19:31.460
平衡数

19:31.460 --> 19:32.460
你们学过的数据

19:32.460 --> 19:33.460
数据结构

19:33.460 --> 19:34.460
它是个平衡数

19:34.460 --> 19:35.460
但是呢

19:35.460 --> 19:36.460
它不是一个二叉数

19:36.460 --> 19:37.460
总之呢

19:37.460 --> 19:38.460
它就是用数据结构

19:38.460 --> 19:39.460
来不进行排序的

19:40.460 --> 19:41.460
排序库呢

19:41.460 --> 19:42.460
它是比加速

19:42.460 --> 19:43.460
每个数据库

19:43.460 --> 19:44.460
它所应的结构呢

19:44.460 --> 19:47.460
是有一些小的区别的

19:47.460 --> 19:48.460
ok

19:48.460 --> 19:49.460
那么这就是

19:49.460 --> 19:50.460
所应了

19:50.460 --> 19:51.460
了解这个概念就行了

19:51.460 --> 19:52.460
其实很多时候

19:52.460 --> 19:53.460
你们创建所应的

19:53.460 --> 19:54.460
去维护数据库

19:54.460 --> 19:55.460
之类的东西呢

19:55.460 --> 19:57.460
特别是在大公司里面

19:57.460 --> 19:58.460
有专门的工程师

19:58.460 --> 20:00.460
就叫数据库管理员DBA

20:00.460 --> 20:01.460
他们在维护

20:01.460 --> 20:02.460
但是你要了解一下这个概念

20:02.460 --> 20:03.460
其他没啥

20:03.460 --> 20:04.460
说一下这个数据概念

