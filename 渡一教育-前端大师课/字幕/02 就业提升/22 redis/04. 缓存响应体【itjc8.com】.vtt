WEBVTT

00:00.300 --> 00:03.300
知识部分基本上就差不多了

00:03.300 --> 00:04.300
就这么一点点

00:04.300 --> 00:06.300
Redis本身也比较简单

00:07.300 --> 00:08.300
那么今天来两节课呢

00:08.300 --> 00:10.300
我们来说一些案例吧

00:10.300 --> 00:12.300
就在结合Express的时候呢

00:12.300 --> 00:14.300
如何来使用

00:14.300 --> 00:16.300
其实呢你们作为前段开发者呢

00:16.300 --> 00:18.300
不太会去接触Redis

00:18.300 --> 00:20.300
结合Express来使用的场景

00:20.300 --> 00:22.300
不太会接触

00:22.300 --> 00:24.300
只是通过这样的两节课呢

00:24.300 --> 00:26.300
你大概了解后段是怎么去开发的

00:26.300 --> 00:28.300
有这么一个概念就行了

00:28.300 --> 00:30.300
那么我们这节课呢来讲一讲

00:30.300 --> 00:32.300
这个缓存响应题

00:32.300 --> 00:33.300
这啥意思呢

00:33.300 --> 00:35.300
就是说如果这么一种情况啊

00:35.300 --> 00:37.300
咱们有一篇新闻

00:37.300 --> 00:40.300
就发布了一篇新闻

00:40.300 --> 00:42.300
那么这个新闻呢

00:42.300 --> 00:44.300
一篇新闻

00:44.300 --> 00:45.300
那么这个新闻呢

00:45.300 --> 00:47.300
它的请求地址呢是这样的地址

00:47.300 --> 00:49.300
比方说新闻的数据啊

00:49.300 --> 00:50.300
是这样的地址

00:50.300 --> 00:52.300
API News

00:52.300 --> 00:54.300
后边可以跟上这个新闻的ID

00:54.300 --> 00:57.300
比方说它是这么一个地址

00:57.300 --> 00:59.300
那么一个地址拿到之后呢

00:59.300 --> 01:01.300
我们是不是要从数据库

01:01.300 --> 01:02.300
对不对

01:02.300 --> 01:04.300
从数据库

01:04.300 --> 01:05.300
从数据库中

01:05.300 --> 01:07.300
比方说是麦斯克也好

01:07.300 --> 01:08.300
MangoDB也好

01:08.300 --> 01:10.300
总共你要从数据库中

01:10.300 --> 01:12.300
读取新闻数据

01:12.300 --> 01:14.300
然后呢

01:14.300 --> 01:16.300
想用给客户端

01:16.300 --> 01:17.300
对吧

01:17.300 --> 01:18.300
这是一个正常的流程

01:18.300 --> 01:20.300
好咱们把这个东西写一下啊

01:20.300 --> 01:22.300
于是呢我们这里可以安装

01:22.300 --> 01:24.300
安装一些

01:24.300 --> 01:26.300
安装一些那个相应的包

01:26.300 --> 01:28.300
比方说Express呢安装好

01:28.300 --> 01:30.300
I already say 顺便安装了吧

01:30.300 --> 01:34.020
安装一下

01:34.020 --> 01:36.020
我这里就简单说一下啊

01:36.020 --> 01:37.020
模拟一下这个场景

01:37.020 --> 01:39.020
然后呢再安装一个loader mode

01:39.020 --> 01:43.490
好这里呢我们就在这

01:43.490 --> 01:45.490
index.js里面

01:45.490 --> 01:47.490
我们写上一个导入

01:47.490 --> 01:48.490
Express

01:48.490 --> 01:52.700
然后这边我们

01:52.700 --> 01:54.700
当然还有可能有静态啊

01:54.700 --> 01:55.700
当然先要先要那个

01:55.700 --> 01:57.700
创建一个Express应用

01:57.700 --> 01:59.700
然后呢使用一个中间键

01:59.700 --> 02:01.700
Express静态资源

02:01.700 --> 02:03.700
静态资源呢我就就简单写一下啊

02:03.700 --> 02:05.700
别麻烦了啊简单写一下

02:05.700 --> 02:07.700
啊就比方说一个public目录

02:07.700 --> 02:08.700
他也没有静态资源对吧

02:08.700 --> 02:10.700
那么静态资源要不要做缓存呢

02:10.700 --> 02:12.700
静态资源我们可以不用做缓存

02:12.700 --> 02:14.700
因为一很多时候呢

02:14.700 --> 02:16.700
在部署的情况下呢静态资源呢

02:16.700 --> 02:18.700
我们一般会直接部署到CDN上面去

02:18.700 --> 02:19.700
就不需要你去做什么缓存了

02:19.700 --> 02:21.700
而且就算没有部署到CDN呢

02:21.700 --> 02:22.700
你在

02:22.700 --> 02:24.700
静态资源读取文件

02:24.700 --> 02:26.700
把文件内容响应过去

02:26.700 --> 02:27.700
实际上速度是很快的

02:27.700 --> 02:28.700
是很快的

02:28.700 --> 02:30.700
因为他毕竟没有数据库的

02:30.700 --> 02:31.700
数据量那么大对吧

02:31.700 --> 02:33.700
也没有什么复杂的查询

02:33.700 --> 02:35.700
因此他这个速度还是比较快的

02:35.700 --> 02:37.700
我们没有必要把它写到Redis里面去

02:37.700 --> 02:39.700
不过你要写的话也可以

02:39.700 --> 02:40.700
我一会说一下吧

02:40.700 --> 02:42.700
总之呢这是静态资源啊

02:42.700 --> 02:43.700
我们不用去管他

02:43.700 --> 02:45.700
然后呢下边呢我们有一个接口

02:45.700 --> 02:46.700
use

02:46.700 --> 02:48.700
比方说我们新闻数据

02:48.700 --> 02:50.700
API news

02:50.700 --> 02:52.700
新闻数据我交给他交给一个rotor

02:52.700 --> 02:53.700
去完成

02:53.700 --> 02:55.700
那么我们这里来写上一个rotor

02:56.700 --> 02:58.700
我就拿着去分文件了

02:58.700 --> 03:00.700
在这里写了

03:00.700 --> 03:02.700
扭一个rotor

03:02.700 --> 03:04.700
express

03:04.700 --> 03:05.700
rotor

03:05.700 --> 03:08.710
全扭一个

03:08.710 --> 03:11.710
不用扭直接创建一个rotor

03:11.710 --> 03:12.710
好创建好了过后

03:12.710 --> 03:14.710
我们直接把这个rotor放在

03:14.710 --> 03:15.710
rotor里面

03:15.710 --> 03:17.710
我们去写上一个请求规则

03:17.710 --> 03:19.710
比方说我们接受一个gats请求

03:19.710 --> 03:20.710
请求的路径呢是什么路径呢

03:20.710 --> 03:21.710
是这样的

03:21.710 --> 03:22.710
比方说他

03:22.710 --> 03:23.710
要给我一个id

03:23.710 --> 03:24.710
对不对

03:24.710 --> 03:25.710
是不是要给我一个id

03:25.710 --> 03:26.710
给我一个id

03:26.710 --> 03:28.710
然后呢

03:29.710 --> 03:31.710
这边呢我们就直接想一

03:31.710 --> 03:32.710
比方说我们这里

03:32.710 --> 03:33.710
从数据库

03:33.710 --> 03:35.710
从数据库中

03:35.710 --> 03:37.710
取出

03:37.710 --> 03:39.710
对应id的

03:39.710 --> 03:41.710
新闻数据

03:41.710 --> 03:42.710
可以这样子来取

03:42.710 --> 03:43.710
从数据库里面

03:43.710 --> 03:44.710
把新闻数据取出来

03:44.710 --> 03:46.710
取出来过后呢我们这里呢

03:46.710 --> 03:48.710
使用

03:50.710 --> 03:51.710
sint

03:51.710 --> 03:52.710
把个新闻数据给他

03:52.710 --> 03:54.710
比方说我们自己随便给一个吧

03:54.710 --> 03:56.710
新闻标题

03:56.710 --> 03:57.710
然后呢新闻内容

03:57.710 --> 03:58.710
content

03:58.710 --> 04:00.710
这是不想硬体对不对

04:00.710 --> 04:01.710
新闻内容

04:01.710 --> 04:02.710
对吧

04:02.710 --> 04:04.710
好那么现在我们就把这个东西

04:04.710 --> 04:05.710
写好了啊最后呢

04:05.710 --> 04:06.710
我们监听一下

04:06.710 --> 04:07.710
less

04:07.710 --> 04:09.710
把927

04:09.710 --> 04:12.090
监听一下

04:12.090 --> 04:14.090
接下来我们把其动起来啊

04:14.090 --> 04:16.090
load them

04:16.090 --> 04:17.090
index

04:17.090 --> 04:19.090
要写一个npx

04:19.090 --> 04:21.090
load them

04:21.090 --> 04:22.090
index

04:22.090 --> 04:23.090
把运营出来

04:23.090 --> 04:24.090
好监听好了过后呢

04:24.090 --> 04:26.090
我们在浏览区里去网用一下

04:26.090 --> 04:27.090
localhost

04:28.090 --> 04:29.090
9527

04:29.090 --> 04:30.090
api

04:30.090 --> 04:31.090
新闻

04:31.090 --> 04:32.090
哪篇新闻呢

04:32.090 --> 04:33.090
比方说id唯一的新闻

04:33.090 --> 04:34.090
对吧

04:34.090 --> 04:35.090
新闻标题

04:35.090 --> 04:36.090
那么新闻标题呢

04:36.090 --> 04:37.090
我们后面可以给

04:37.090 --> 04:38.090
跟上一个

04:38.090 --> 04:39.090
评阶上一个就是

04:39.090 --> 04:41.090
rig

04:41.090 --> 04:42.090
id

04:42.090 --> 04:43.090
然后呢

04:43.090 --> 04:44.090
这边新闻内容呢

04:44.090 --> 04:45.090
也可以给他评阶上一个

04:45.090 --> 04:46.090
好保存啊

04:46.090 --> 04:48.090
这边来刷新一下

04:48.090 --> 04:49.090
刷新

04:49.090 --> 04:50.090
没问题吧

04:50.090 --> 04:51.090
那么这个东西

04:51.090 --> 04:53.090
是不是我们就拿到了

04:53.090 --> 04:54.090
对吧

04:54.090 --> 04:55.090
把这些数据拿到了

04:55.090 --> 04:56.090
好了吗

04:56.090 --> 04:58.090
现在我们要做的事情是什么呢

04:58.090 --> 05:00.090
接下来我们要做的事情就是

05:00.090 --> 05:01.090
要这样子考虑

05:01.090 --> 05:03.090
就是假设我们的数据库啊

05:03.090 --> 05:04.090
内容比较多

05:04.090 --> 05:05.090
而且呢

05:05.090 --> 05:06.090
数据的查询规则

05:06.090 --> 05:08.090
特别特别复杂

05:08.090 --> 05:10.090
我们也就是想象一下

05:10.090 --> 05:11.090
从这个数据库里面

05:11.090 --> 05:13.090
去取这个新闻数据呢

05:13.090 --> 05:15.090
他可能会需要很长一段时间

05:15.090 --> 05:16.090
就夸张一点吧

05:16.090 --> 05:17.090
要取一天

05:17.090 --> 05:18.090
有点夸张了

05:18.090 --> 05:20.090
就这么去想象啊

05:20.090 --> 05:21.090
要取一天

05:21.090 --> 05:23.090
才能把一个新闻取出来

05:23.090 --> 05:24.090
那么大家想象一下

05:24.090 --> 05:26.090
现在有个什么样的问题呢

05:26.090 --> 05:27.090
比方说

05:27.090 --> 05:28.090
第一个用户请求过来

05:28.090 --> 05:30.090
要请求ID唯一的新闻

05:30.090 --> 05:32.090
那么我就把ID唯一的新闻

05:32.090 --> 05:33.090
查了一天

05:33.090 --> 05:34.090
把它查出来了

05:34.090 --> 05:35.090
发给用户

05:35.090 --> 05:36.090
对吧

05:36.090 --> 05:37.090
那么用户那边

05:37.090 --> 05:38.090
我可以用什么缓存

05:38.090 --> 05:39.090
用缓存技术

05:39.090 --> 05:40.090
让用户那边去缓存

05:40.090 --> 05:41.090
缓存起来

05:41.090 --> 05:42.090
好了

05:42.090 --> 05:43.090
那么现在第一个用户来

05:43.090 --> 05:44.090
请求过来了

05:44.090 --> 05:45.090
第一个用户他就缓存了

05:45.090 --> 05:46.090
他就不会再请求过来了

05:46.090 --> 05:47.090
对不对

05:47.090 --> 05:48.090
好

05:48.090 --> 05:49.090
第二个用户来了

05:49.090 --> 05:50.090
他也要看新闻ID唯一的新闻

05:50.090 --> 05:51.090
那么服务器

05:51.090 --> 05:52.090
因为第二个用户

05:52.090 --> 05:53.090
他电脑上没有缓存

05:54.090 --> 05:55.090
因此他必须要

05:55.090 --> 05:56.090
服务器就必须要

05:56.090 --> 05:57.090
给他这个新闻

05:57.090 --> 05:58.090
让他去缓存

05:58.090 --> 05:59.090
因此他又要

05:59.090 --> 06:00.090
从数据户里边去读一遍

06:01.090 --> 06:02.090
增加了服务器的压力

06:02.090 --> 06:03.090
而像如果说

06:03.090 --> 06:04.090
像这个新闻

06:04.090 --> 06:05.090
如果一个大的网站

06:05.090 --> 06:06.090
它里边可能

06:06.090 --> 06:08.090
频繁的读取这条新闻的话

06:08.090 --> 06:09.090
有很多人都要访问这条新闻

06:09.090 --> 06:10.090
尽管每个人

06:10.090 --> 06:11.090
他只需要访问一次

06:11.090 --> 06:12.090
他就有缓存了

06:12.090 --> 06:13.090
但是没有缓存的人

06:13.090 --> 06:14.090
是不是要继续访问

06:14.090 --> 06:16.090
服务器压力也挺大的

06:16.090 --> 06:17.090
像这样的接口

06:17.090 --> 06:18.090
如果说多了

06:19.090 --> 06:20.090
也会托曼服务器

06:20.090 --> 06:21.090
那怎么办呢

06:21.090 --> 06:22.090
我就可以在服务器端

06:22.090 --> 06:23.090
做一个缓存

06:24.090 --> 06:25.090
怎么缓存呢

06:25.090 --> 06:27.090
它的原理其实很简单

06:27.090 --> 06:28.090
原理是这样子的

06:30.090 --> 06:32.090
在请求某个请求之前

06:33.090 --> 06:36.090
在处理某个请求之前

06:38.090 --> 06:41.090
可以加上一个中间键

06:42.090 --> 06:43.090
比方说像在这里

06:43.090 --> 06:44.090
因为我们在知道

06:44.090 --> 06:45.090
在这里的

06:45.090 --> 06:46.090
可以加多个请求函数

06:46.090 --> 06:47.090
对不对

06:47.090 --> 06:48.090
那么这个地方

06:48.090 --> 06:49.090
可以加个中间键

06:49.090 --> 06:50.090
比方说我们在这里

06:51.090 --> 06:52.090
叫catch

06:53.090 --> 06:54.090
就catch吧

06:54.090 --> 06:55.090
catch

06:55.090 --> 06:56.090
那么这里导出export

06:56.090 --> 06:57.090
导出一个什么

06:57.090 --> 06:59.090
导出一个regress

06:59.090 --> 07:00.090
所以一个中间键

07:00.090 --> 07:01.090
对吧

07:01.090 --> 07:02.090
导出这么一个中间键

07:02.090 --> 07:03.090
我们现在简单一点

07:03.090 --> 07:04.090
那个直接往后移交

07:04.090 --> 07:06.090
那么现在我们在这里

07:06.090 --> 07:07.090
只需要写上一个require

07:08.090 --> 07:09.090
catch

07:09.090 --> 07:10.090
是不是写到这

07:10.090 --> 07:11.090
那么也表示

07:11.090 --> 07:13.090
我在这里是不是加了一个

07:13.090 --> 07:14.090
缓存验证

07:14.090 --> 07:15.090
对吧

07:15.090 --> 07:16.090
看一下我现在有没有

07:16.090 --> 07:17.090
比方这条新闻

07:17.090 --> 07:19.090
有没有相应的缓存呢

07:20.090 --> 07:21.090
如果说有的话

07:21.090 --> 07:24.090
我就直接给你缓存结果

07:24.090 --> 07:25.090
我就不要

07:25.090 --> 07:26.090
不要往后走了

07:26.090 --> 07:27.090
明白你的意思吧

07:27.090 --> 07:28.090
比方说我这里不往后走了

07:28.090 --> 07:30.090
我这里表示有缓存

07:30.090 --> 07:31.090
移交缓存结果

07:31.090 --> 07:34.090
移交缓存结果即可

07:34.090 --> 07:35.090
保存

07:35.090 --> 07:36.090
现在我们来看一下

07:36.090 --> 07:38.090
这边刷新

07:39.090 --> 07:40.090
你看现在就输出了

07:40.090 --> 07:41.090
这句话对吧

07:41.090 --> 07:42.090
移交缓存就行了

07:42.090 --> 07:43.090
它就没有往后移交了

07:43.090 --> 07:44.090
你看它是不是没有

07:44.090 --> 07:45.090
没有运行这个函数了

07:45.090 --> 07:46.090
对吧

07:46.090 --> 07:47.090
它就不会去查询数据库了

07:47.090 --> 07:49.090
那么也就说我这个

07:49.090 --> 07:51.090
中间键里面要做什么事呢

07:51.090 --> 07:52.090
是不是要检查

07:52.090 --> 07:53.090
有没有缓存

07:53.090 --> 07:54.090
对吧

07:54.090 --> 07:55.090
如果说有缓存怎么样

07:55.090 --> 07:57.090
我就直接移交缓存结果

07:57.090 --> 07:59.090
如果说没有缓存怎么样

07:59.090 --> 08:01.090
我就不移交缓存结果

08:01.090 --> 08:03.090
就这么简单

08:03.090 --> 08:04.090
好来吧

08:04.090 --> 08:05.090
那么我们现在

08:05.090 --> 08:06.090
比方说吧

08:06.090 --> 08:07.090
比方说我们现在

08:07.090 --> 08:09.090
要移交这个缓存

08:09.090 --> 08:10.090
比方说我们现在

08:10.090 --> 08:11.090
这里可以怎么显

08:11.090 --> 08:13.090
我们就可以用radius

08:13.090 --> 08:15.090
因为我们的缓存的数据

08:15.090 --> 08:16.090
在radius里面

08:16.090 --> 08:17.090
对吧

08:17.090 --> 08:18.090
所以我们这里可以用radius

08:18.090 --> 08:19.090
而radius呢

08:19.090 --> 08:20.090
创建一个客户端

08:20.090 --> 08:21.090
great client

08:21.090 --> 08:23.090
创建一个客户端

08:24.090 --> 08:25.090
好那么这边呢

08:25.090 --> 08:26.090
我就看一下

08:26.090 --> 08:27.090
有没有相应的缓存结果

08:27.090 --> 08:28.090
那么我们怎么来看

08:28.090 --> 08:29.090
有没有相应的缓存结果呢

08:29.090 --> 08:30.090
我们client里面

08:30.090 --> 08:31.090
不是有一个函数吗

08:31.090 --> 08:32.090
对吧

08:32.090 --> 08:33.090
叫做exist

08:33.090 --> 08:34.090
是不是

08:34.090 --> 08:36.090
包含了一个key值

08:36.090 --> 08:38.090
是不是包含了一个key值

08:38.090 --> 08:39.090
或者我们直接用get

08:39.090 --> 08:40.090
get

08:40.090 --> 08:41.090
通过一个key值去拿

08:41.090 --> 08:43.090
那么我们就必须要知道

08:43.090 --> 08:44.090
key值是啥

08:44.090 --> 08:46.090
key值我们可以用啥呢

08:46.090 --> 08:47.090
比方说我们就可以key值

08:47.090 --> 08:48.090
一个简单一点的话

08:48.090 --> 08:49.090
我们就可以用

08:49.090 --> 08:50.090
请求的

08:50.090 --> 08:52.090
比方说arranging

08:53.090 --> 08:54.090
url

08:54.090 --> 08:55.090
好像是这样写的

08:55.090 --> 08:56.090
我们输出看一下吧

08:56.090 --> 08:57.090
好像是这样写的

08:59.530 --> 09:00.530
就是它原式的

09:00.530 --> 09:01.530
原式的请求

09:01.530 --> 09:02.530
请求路径

09:02.530 --> 09:03.530
请求地址

09:06.530 --> 09:07.530
刷新

09:07.530 --> 09:08.530
你看一下

09:08.530 --> 09:09.530
indefend

09:09.530 --> 09:10.530
我这里写错了

09:11.530 --> 09:12.530
输出一下rake吧

09:12.530 --> 09:13.530
输出一下

09:13.530 --> 09:17.350
看一下这边

09:17.350 --> 09:19.350
它的原式请求路径

09:19.350 --> 09:21.350
原式请求路径

09:21.350 --> 09:22.350
在这

09:22.350 --> 09:23.350
arranging.url

09:23.350 --> 09:24.350
为什么不用PASS呢

09:24.350 --> 09:25.350
因为它我要防止

09:25.350 --> 09:27.350
它有什么地址栏处

09:27.350 --> 09:28.350
地址栏处不一样

09:28.350 --> 09:30.350
是不是缓存也应该不一样

09:30.350 --> 09:32.350
我要防止这个东西

09:32.350 --> 09:34.350
所以说arranging.url

09:34.350 --> 09:36.350
它会包含这个东西

09:37.350 --> 09:38.350
包存

09:38.350 --> 09:39.350
重新来

09:39.350 --> 09:40.350
清空

09:40.350 --> 09:41.350
再来

09:42.350 --> 09:43.350
刷新

09:43.350 --> 09:44.350
你看

09:44.350 --> 09:45.350
我们可以用这个东西

09:45.350 --> 09:46.350
来作为key值

09:47.350 --> 09:48.350
好

09:48.350 --> 09:49.350
那么我现在key值拿到了

09:49.350 --> 09:50.350
我们现在只需要

09:50.350 --> 09:51.350
从client

09:51.350 --> 09:52.350
get里边

09:52.350 --> 09:53.350
去看一下有没有缓存

09:53.350 --> 09:54.350
对吧

09:54.350 --> 09:55.350
所以可以看一下

09:55.350 --> 09:56.350
有没有缓存

09:56.350 --> 09:57.350
那么为了方便起见

09:57.350 --> 09:58.350
我这里可以

09:58.350 --> 09:59.350
把它做成一个

09:59.350 --> 10:00.350
就是异部函数

10:00.350 --> 10:01.350
然后我们导入

10:02.350 --> 10:03.350
从utl里边

10:05.350 --> 10:06.350
utl里边

10:06.350 --> 10:07.350
这里有一个

10:08.350 --> 10:09.350
promissivity

10:10.350 --> 10:11.350
我们这里得到一个get

10:11.350 --> 10:12.350
orthink

10:13.350 --> 10:14.350
得到是

10:14.350 --> 10:15.350
我们是上天说过的

10:15.350 --> 10:16.350
我们是上天都说过的

10:16.350 --> 10:17.350
对不对

10:17.350 --> 10:18.350
promissivity

10:18.350 --> 10:19.350
ready a client

10:20.350 --> 10:21.350
get

10:21.350 --> 10:22.350
然后绑定

10:22.350 --> 10:23.350
绑定什么

10:23.350 --> 10:24.350
client

10:24.350 --> 10:25.350
get

10:25.350 --> 10:26.350
然后set

10:26.350 --> 10:27.350
我们也拿到

10:27.350 --> 10:28.350
orthink

10:28.350 --> 10:29.350
promissivity

10:29.350 --> 10:30.350
client

10:30.350 --> 10:31.350
set

10:32.350 --> 10:33.350
band

10:33.350 --> 10:34.350
client

10:35.350 --> 10:36.350
好

10:36.350 --> 10:37.350
行了

10:37.350 --> 10:38.350
那么现在有get

10:38.350 --> 10:39.350
有set

10:39.350 --> 10:40.350
那么我们现在要做的事情

10:40.350 --> 10:41.350
就是

10:41.350 --> 10:42.350
首先用get

10:42.350 --> 10:43.350
orthink

10:43.350 --> 10:44.350
把key值传进去

10:44.350 --> 10:45.350
key值呢

10:45.350 --> 10:46.350
我就用这个key值

10:47.350 --> 10:48.350
得到

10:49.350 --> 10:50.350
得到什么内容

10:51.350 --> 10:52.350
await

10:53.350 --> 10:54.350
输出内容

10:54.350 --> 10:55.350
我们来看一下

10:55.350 --> 10:56.350
看有没有这个key值

10:58.350 --> 10:59.350
然后我们这里

10:59.350 --> 11:00.350
运行

11:00.350 --> 11:01.350
你看这里

11:01.350 --> 11:02.350
key值得到是now

11:02.350 --> 11:03.350
对不对

11:03.350 --> 11:04.350
说明没有这个key值

11:04.350 --> 11:05.350
对吧

11:05.350 --> 11:06.350
没有key值

11:06.350 --> 11:07.350
那么如果说

11:07.350 --> 11:08.350
康电车有值

11:08.350 --> 11:09.350
是不是有缓存

11:09.350 --> 11:10.350
对吧

11:10.350 --> 11:11.350
有缓存

11:11.350 --> 11:12.350
有缓存怎么样

11:12.350 --> 11:13.350
我就输出

11:13.350 --> 11:14.350
我就直接

11:14.350 --> 11:15.350
给它缓存就完成了

11:15.350 --> 11:16.350
res

11:17.350 --> 11:18.350
给它缓存

11:18.350 --> 11:19.350
那么这个缓存

11:19.350 --> 11:20.350
我们可以

11:21.350 --> 11:22.350
因为它是一个字不串

11:22.350 --> 11:23.350
对不对

11:23.350 --> 11:24.350
是不是一个字不串

11:24.350 --> 11:25.350
那么字不串

11:25.350 --> 11:26.350
因为它是一个字不串

11:26.350 --> 11:27.350
而且

11:27.350 --> 11:28.350
我觉得大部分时候

11:28.350 --> 11:29.350
像这个时候是节省

11:29.350 --> 11:30.350
对吧

11:30.350 --> 11:31.350
我们缓存的是节省格式

11:31.350 --> 11:32.350
当然这个情况

11:32.350 --> 11:33.350
你也可以

11:33.350 --> 11:34.350
把它做成一个函数

11:34.350 --> 11:35.350
一个高间函数

11:35.350 --> 11:36.350
告诉他

11:36.350 --> 11:37.350
我到底是一个

11:37.350 --> 11:38.350
要缓存什么样的格式

11:38.350 --> 11:39.350
方面这边解析

11:39.350 --> 11:40.350
那么

11:40.350 --> 11:41.350
这边我们要

11:41.350 --> 11:42.350
重新发送节省

11:42.350 --> 11:43.350
可以把它转换回来

11:43.350 --> 11:44.350
对吧

11:44.350 --> 11:45.350
用节省

11:45.350 --> 11:46.350
Pose

11:46.350 --> 11:47.350
康电车

11:47.350 --> 11:48.350
是不是把它转换回来

11:48.350 --> 11:49.350
那么有缓存的话

11:49.350 --> 11:50.350
我就直接给它扔过去了

11:50.350 --> 11:51.350
没有缓存的话

11:51.350 --> 11:53.350
我再去加缓存

11:53.350 --> 11:54.350
就形成这么一个逻辑了

11:54.350 --> 11:55.350
当然现在是没有缓存

11:55.350 --> 11:56.350
进不了这个判断

11:56.350 --> 11:58.350
那么我们现在可以去测试一下

11:58.350 --> 11:59.350
set

11:59.350 --> 12:00.350
去使用一个缓存

12:00.350 --> 12:02.350
key值就是这个key值

12:02.350 --> 12:04.350
key值就是这个key值

12:05.350 --> 12:07.350
这是key值

12:07.350 --> 12:08.350
然后内容

12:08.350 --> 12:09.350
内容

12:09.350 --> 12:10.350
我们就用那个

12:10.350 --> 12:11.350
缓存的内容

12:11.350 --> 12:12.350
我们就用一个字不算

12:12.350 --> 12:13.350
因为缓存都是用字不算

12:13.350 --> 12:14.350
对不对

12:14.350 --> 12:15.350
我们可以用节省

12:15.350 --> 12:16.350
shrinky fee

12:16.350 --> 12:18.350
把一个对象

12:18.350 --> 12:19.350
变成一个字不算

12:20.350 --> 12:21.350
好保存

12:23.350 --> 12:24.350
这边

12:24.350 --> 12:25.350
刷新

12:25.350 --> 12:26.350
你看是不是得到了

12:26.350 --> 12:27.350
对不对

12:27.350 --> 12:28.350
那么这东西哪来的

12:28.350 --> 12:29.350
是不是缓存里面来的

12:29.350 --> 12:30.350
对吧

12:30.350 --> 12:31.350
我们也可以在这里

12:31.350 --> 12:32.350
来测试一下

12:32.350 --> 12:34.350
我们看一下这个low

12:34.350 --> 12:35.350
radius

12:35.350 --> 12:36.350
cd

12:37.350 --> 12:38.350
得到

12:38.350 --> 12:39.350
get

12:41.350 --> 12:42.350
就这个

12:42.350 --> 12:43.350
你看

12:43.350 --> 12:44.350
是不是得到这个结构

12:44.350 --> 12:45.350
一个节省字不算

12:45.350 --> 12:46.350
对不对

12:46.350 --> 12:47.350
那么数据库

12:47.350 --> 12:48.350
就radius里面是不是有缓存

12:48.350 --> 12:49.350
缓存这个数据

12:49.350 --> 12:50.350
当然

12:50.350 --> 12:51.350
你还可以给它指定一些

12:51.350 --> 12:52.350
过期时间

12:52.350 --> 12:53.350
所以说

12:53.350 --> 12:54.350
我其实

12:54.350 --> 12:55.350
我比较建议大家

12:55.350 --> 12:56.350
就是在这个地方

12:56.350 --> 12:57.350
做一个高兼函数

12:57.350 --> 12:58.350
准备做高兼函数

12:58.350 --> 13:00.350
就是你写个函数

13:00.350 --> 13:01.350
这里面

13:01.350 --> 13:02.350
写上一个option

13:02.350 --> 13:03.350
你给我一些配置

13:03.350 --> 13:05.350
我这里可以返回的是一个函数

13:05.350 --> 13:06.350
返回了这个函数

13:06.350 --> 13:07.350
返回了这个函数

13:07.350 --> 13:08.350
才是真正的中间

13:08.350 --> 13:10.350
那么这边使用的时候

13:10.350 --> 13:11.350
我们应该去

13:11.350 --> 13:12.350
当成一个函数来调用

13:12.350 --> 13:13.350
告诉它一些配置

13:13.350 --> 13:14.350
配置什么呢

13:14.350 --> 13:15.350
比方说

13:15.350 --> 13:17.350
我这里配置可以给它一个默认值

13:18.350 --> 13:19.350
这个

13:19.350 --> 13:20.350
我们先给它一个默认对象

13:20.350 --> 13:21.350
如果说

13:21.350 --> 13:23.350
我们这里有一些默认值

13:23.350 --> 13:24.350
比方说内容格式

13:24.350 --> 13:26.350
就是一是节省

13:26.350 --> 13:27.350
是不是节省格式

13:27.350 --> 13:28.350
option

13:28.350 --> 13:30.350
一是节省

13:30.350 --> 13:31.350
如果说

13:31.350 --> 13:33.350
没有这个数据的话

13:33.350 --> 13:35.350
如果说它等于

13:35.350 --> 13:36.350
帮Defend

13:36.350 --> 13:37.350
就是没有传这个数据

13:37.350 --> 13:38.350
没有传这个数据的话

13:38.350 --> 13:40.350
默认就是

13:40.350 --> 13:42.350
默认就是

13:42.350 --> 13:43.350
否则的话就是它自身

13:43.350 --> 13:44.350
传过来的数据

13:44.350 --> 13:45.350
也是节省

13:45.350 --> 13:47.350
我们可以给它一些默认值

13:47.350 --> 13:48.350
也是节省

13:48.350 --> 13:49.350
是不是节省格式

13:49.350 --> 13:50.350
你的数据

13:50.350 --> 13:52.350
缓存的数据

13:52.350 --> 13:53.350
缓存的数据

13:53.350 --> 13:55.350
是否是节省格式

13:55.350 --> 13:57.350
我们这里配置比较简单

13:57.350 --> 13:58.350
然后呢

13:58.350 --> 14:00.350
再来一个配置

14:00.350 --> 14:01.350
配置啥

14:01.350 --> 14:03.350
刚才我想说啥

14:03.350 --> 14:05.350
配置啥

14:05.350 --> 14:06.350
我刚才写到说

14:06.350 --> 14:07.350
忘了

14:07.350 --> 14:08.350
我刚才要配置啥

14:08.350 --> 14:10.350
是不是节省格式

14:10.350 --> 14:11.350
这边呢

14:11.350 --> 14:12.350
比方说

14:12.350 --> 14:13.350
默认

14:13.350 --> 14:14.350
默认它就是4嘛

14:14.350 --> 14:15.350
我可以不改传

14:15.350 --> 14:17.350
然后还有一个配置

14:17.350 --> 14:19.350
我刚才想配置啥来着

14:19.350 --> 14:20.350
Pose

14:20.350 --> 14:21.350
都到那种

14:21.350 --> 14:22.350
我要想起来再说吧

14:22.350 --> 14:23.350
我现在就比方

14:23.350 --> 14:24.350
就这么一个配置

14:24.350 --> 14:25.350
我们把它写成这种模式

14:25.350 --> 14:26.350
这种模式呢

14:26.350 --> 14:27.350
我们就可以在这里

14:27.350 --> 14:28.350
调用这个函数

14:28.350 --> 14:29.350
然后是用一个

14:29.350 --> 14:30.350
高纤函数这种做法

14:30.350 --> 14:32.350
更加灵活一点

14:32.350 --> 14:37.390
那么现在是一样的效果

14:37.390 --> 14:39.390
这是我们的数据库

14:39.390 --> 14:41.390
这边刷新

14:41.390 --> 14:43.390
你看 是不是仍然是有缓存的

14:43.390 --> 14:46.390
对 仍然是有缓存的

14:46.390 --> 14:48.390
好 这是这种情况

14:48.390 --> 14:49.390
当然了

14:49.390 --> 14:51.390
这个缓存是我们测试的

14:51.390 --> 14:54.390
现在我们看另外一种情况

14:54.390 --> 14:56.390
另外一种情况就是

14:56.390 --> 14:58.390
没有缓存

15:00.390 --> 15:02.390
没有缓存

15:02.390 --> 15:03.390
没有缓存的时候

15:03.390 --> 15:04.390
我们应该怎么办呢

15:04.390 --> 15:05.390
我们是不是要

15:05.390 --> 15:06.390
往后移交

15:06.390 --> 15:07.390
让它去读数据

15:07.390 --> 15:10.390
把读完的数据缓存起来

15:10.390 --> 15:11.390
对不对

15:11.390 --> 15:12.390
那么往后移交

15:12.390 --> 15:14.390
实际上是很简单的

15:14.390 --> 15:15.390
往后移交就

15:15.390 --> 15:17.390
那个时候就往后移交了

15:17.390 --> 15:19.390
关键就是

15:19.390 --> 15:21.390
这里我们既然有了这个参数

15:21.390 --> 15:22.390
我们在这里呢

15:22.390 --> 15:24.390
应该去判断一下

15:26.390 --> 15:27.390
保底

15:27.390 --> 15:28.390
我们的响应题

15:28.390 --> 15:29.390
关键是取决于

15:29.390 --> 15:30.390
是不是接胜

15:30.390 --> 15:31.390
如果说你是个

15:31.390 --> 15:32.390
响应题是接胜格式的话

15:32.390 --> 15:34.390
那么我们这里呢

15:35.390 --> 15:36.390
缓存了

15:36.390 --> 15:37.390
就是把读出来过后来

15:37.390 --> 15:38.390
要把它解析成

15:38.390 --> 15:39.390
接成对象

15:39.390 --> 15:40.390
把它解成接视对象

15:40.390 --> 15:41.390
否则的话

15:41.390 --> 15:42.390
那就是一个普通的文本

15:42.390 --> 15:43.390
普通文本的话

15:43.390 --> 15:44.390
我们就用一个抗体

15:44.390 --> 15:48.090
把保底放进来

15:48.090 --> 15:50.090
一切这个模具

15:50.090 --> 15:51.090
因为你不一定

15:51.090 --> 15:53.090
缓存接胜格式的数据

15:53.090 --> 15:54.090
有可能就缓存一段

15:54.090 --> 15:55.090
一天没有

15:55.090 --> 15:56.090
或者是缓存一段存文本

15:56.090 --> 15:57.090
对吧

15:57.090 --> 15:58.090
一存文本拿出来过后

15:58.090 --> 16:00.090
你再去做解析成对象

16:00.090 --> 16:01.090
之后解析不了

16:01.090 --> 16:03.090
那你就是告诉我一下

16:03.090 --> 16:05.090
或者你不用传这个参数

16:05.090 --> 16:06.090
我来这里判断一下

16:06.090 --> 16:07.090
解析我就解析

16:07.090 --> 16:08.090
解析不了我就拉倒

16:08.090 --> 16:09.090
我就直接给你响应过了

16:09.090 --> 16:10.090
总归让你可以

16:10.090 --> 16:11.090
总之可以操作的

16:11.090 --> 16:12.090
现在我们关键还是看

16:12.090 --> 16:13.090
下面这个逻辑

16:13.090 --> 16:14.090
是没有缓存

16:14.090 --> 16:16.090
没有缓存的话

16:16.090 --> 16:17.090
我们是要往后移交

16:17.090 --> 16:18.090
让它去读数据

16:18.090 --> 16:19.090
读完数据

16:19.090 --> 16:20.090
它是不是有

16:20.090 --> 16:21.090
让它去往响应题

16:21.090 --> 16:22.090
里边写东西

16:22.090 --> 16:23.090
对不对

16:23.090 --> 16:25.090
那它写的东西过后呢

16:25.090 --> 16:26.090
我们需要把它写的东西

16:26.090 --> 16:27.090
缓存起来

16:27.090 --> 16:28.090
那么关键是

16:28.090 --> 16:29.090
这里怎么操作呢

16:29.090 --> 16:30.090
这就涉及到一个问题

16:30.090 --> 16:31.090
在这里如何读到

16:31.090 --> 16:33.090
后续的响应题

16:33.090 --> 16:34.090
对吧

16:34.090 --> 16:35.090
以前在这个接视里边

16:35.090 --> 16:36.090
是吧

16:36.090 --> 16:37.090
好像没说过

16:37.090 --> 16:38.090
对吧

16:38.090 --> 16:39.090
一个接视里面

16:39.090 --> 16:40.090
还没说过

16:40.090 --> 16:43.090
如何在后续的响应中

16:43.090 --> 16:47.090
如何获取

16:47.090 --> 16:50.090
后续响应中的响应题

16:50.090 --> 16:51.090
就是后续

16:51.090 --> 16:52.090
我交给它了

16:52.090 --> 16:53.090
那么它过去响应

16:53.090 --> 16:54.090
它响应完了

16:54.090 --> 16:55.090
总会有响应题

16:55.090 --> 16:56.090
对吧

16:56.090 --> 16:57.090
我要把这个响应题

16:57.090 --> 16:58.090
缓存起来

16:58.090 --> 16:59.090
那么如何过去

16:59.090 --> 17:00.090
这样的响应题呢

17:00.090 --> 17:01.090
如何过去呢

17:01.090 --> 17:02.090
那么这里呢

17:02.090 --> 17:03.090
有一些小技巧

17:03.090 --> 17:04.090
你得理解

17:04.090 --> 17:07.090
Express它写响应题

17:07.090 --> 17:11.090
Express写响应题

17:11.090 --> 17:14.090
最终是通过

17:14.090 --> 17:16.090
Race.rise

17:16.090 --> 17:18.090
盘数完成的

17:18.090 --> 17:19.090
就是Express里面

17:19.090 --> 17:21.090
它没有第一提供什么 API

17:21.090 --> 17:22.090
来获取这样的操作

17:22.090 --> 17:23.090
它没有提供

17:23.090 --> 17:24.090
我觉得

17:24.090 --> 17:26.090
这是它设计的一个缺陷吧

17:26.090 --> 17:27.090
应该是给你提供一下

17:27.090 --> 17:28.090
以下比较好

17:28.090 --> 17:30.090
那么我们现在只能通过

17:30.090 --> 17:31.090
别的方式来完成

17:31.090 --> 17:32.090
因为我们知道

17:32.090 --> 17:33.090
Race.

17:33.090 --> 17:34.090
最多是通过

17:34.090 --> 17:35.090
写入留的方式

17:35.090 --> 17:36.090
来完成响应的

17:36.090 --> 17:37.090
就是虽然说

17:37.090 --> 17:38.090
我们这里调用的是什么

17:38.090 --> 17:39.090
调用的是 send

17:39.090 --> 17:40.090
对吧

17:40.090 --> 17:41.090
虽然说我们调用的是 send

17:41.090 --> 17:42.090
但是实际上

17:42.090 --> 17:43.090
它在内部

17:43.090 --> 17:44.090
最终是通过

17:44.090 --> 17:45.090
Race.line完成的

17:45.090 --> 17:47.090
因此我们在这里

17:47.090 --> 17:49.090
就可以重写Race.line

17:49.090 --> 17:50.090
而且它完成响应过后

17:50.090 --> 17:51.090
是不是一定会调用 end

17:51.090 --> 17:52.090
对吧

17:52.090 --> 17:53.090
一定会调用 end

17:53.090 --> 17:54.090
那么这里

17:54.090 --> 17:55.090
我们可以重写Race.line

17:55.090 --> 17:56.090
那么怎么来重写呢

17:56.090 --> 17:57.090
我们看着

17:58.090 --> 17:59.090
我们可以这样子

17:59.090 --> 18:01.090
把它的Race.line

18:02.090 --> 18:03.090
Race

18:03.090 --> 18:04.090
就是 default

18:04.090 --> 18:05.090
Race

18:05.090 --> 18:06.090
把它的Race

18:06.090 --> 18:07.090
还说保存起来

18:09.090 --> 18:11.090
然后再绑

18:11.090 --> 18:12.090
保存起来

18:13.090 --> 18:14.090
再绑定 Race

18:14.090 --> 18:16.090
绑定 Race 到 Race

18:17.090 --> 18:18.090
因为它

18:18.090 --> 18:19.090
这一会儿我们

18:19.090 --> 18:20.090
直接调用它的话

18:20.090 --> 18:21.090
Race 的指向

18:21.090 --> 18:22.090
它不再指向它了

18:22.090 --> 18:23.090
对吧

18:23.090 --> 18:24.090
平时我们都是调用 Race.line

18:24.090 --> 18:26.090
所以说我们绑定这个 Race

18:26.090 --> 18:27.090
另外一个就是

18:27.090 --> 18:30.090
我还要得到 default end

18:30.090 --> 18:31.090
因为它还有一个 end 函数

18:31.090 --> 18:32.090
对吧

18:32.090 --> 18:33.090
因为我们响应完了过后

18:33.090 --> 18:34.090
一定要把个流

18:34.090 --> 18:35.090
不要告诉它

18:35.090 --> 18:36.090
我的流写完了

18:37.090 --> 18:38.090
那么这里呢

18:38.090 --> 18:39.090
我们绑定这个 end 函数

18:40.090 --> 18:42.090
这样怎么获取到了

18:42.090 --> 18:43.090
获取到了就是它

18:43.090 --> 18:44.090
原本的 Race 函数

18:44.090 --> 18:45.090
和 end 函数

18:45.090 --> 18:46.090
这两个函数

18:46.090 --> 18:47.090
才是真正响应的时候

18:47.090 --> 18:48.090
用的函数

18:48.090 --> 18:49.090
写完了过后

18:49.090 --> 18:50.090
调用 end

18:50.090 --> 18:51.090
对不对

18:51.090 --> 18:52.090
好

18:52.090 --> 18:53.090
那么接下来

18:53.090 --> 18:54.090
我们要做的事情就是

18:54.090 --> 18:56.090
重新给这个 Race 函数负责

18:56.090 --> 18:57.090
重写这个 Race 函数

18:58.090 --> 18:59.090
你 Race 的时候

18:59.090 --> 19:01.090
不是要给我一些数据吗

19:01.090 --> 19:02.090
对吧

19:02.090 --> 19:03.090
写入流吗

19:03.090 --> 19:04.090
要给我一些数据

19:04.090 --> 19:05.090
那我就把这个

19:05.090 --> 19:06.090
给我的数据保存起来

19:06.090 --> 19:07.090
我可以保存到数据里边

19:07.090 --> 19:09.090
因为它可能会 Race 多次

19:09.090 --> 19:11.090
所以说我可以用一个数据

19:11.090 --> 19:13.090
trunks 保存一下

19:14.090 --> 19:17.530
我把这个数据保存起来

19:17.530 --> 19:18.530
这里

19:19.530 --> 19:20.530
这样子

19:20.530 --> 19:21.530
trunks push

19:21.530 --> 19:22.530
把这个数据保存起来

19:22.530 --> 19:24.530
保存起来完了过后呢

19:24.530 --> 19:25.530
接下来呢

19:25.530 --> 19:28.530
再调用原本的 Default Race

19:29.530 --> 19:30.530
然后呢

19:30.530 --> 19:31.530
trunk 给它

19:32.530 --> 19:33.530
明白了意思吗

19:33.530 --> 19:35.530
我们可以用这种模式来做

19:35.530 --> 19:37.530
如果说后边还有函数的话

19:37.530 --> 19:38.530
那么我这里可以把

19:38.530 --> 19:40.530
这个后续的函数也给你

19:42.530 --> 19:44.530
如果说有的话我给你

19:44.530 --> 19:45.530
好这是 Race 函数

19:45.530 --> 19:47.530
那么 end 函数是一样的

19:48.530 --> 19:49.530
end 函数

19:49.530 --> 19:50.530
因为 end 函数里边呢

19:50.530 --> 19:51.530
它也是一样

19:51.530 --> 19:52.530
你写

19:52.530 --> 19:53.530
你调用 end 的时候

19:53.530 --> 19:55.530
它也有可能给你写入一些东西

19:55.530 --> 19:56.530
对吧

19:56.530 --> 19:57.530
以前我们学 Note 介绍的时候

19:57.530 --> 19:58.530
学过了

19:58.530 --> 19:59.530
那么我们这里判断一下

19:59.530 --> 20:00.530
如果说你 end 的时候

20:00.530 --> 20:01.530
给我写了一些东西的话

20:01.530 --> 20:02.530
那么我怎么样呢

20:02.530 --> 20:04.530
我还是要往 trunk 里边加

20:04.530 --> 20:05.530
push

20:05.530 --> 20:06.530
trunk 里边加

20:07.530 --> 20:08.530
加完了过后呢

20:08.530 --> 20:10.530
我们最终还是要调用 default

20:10.530 --> 20:12.530
end 这里有点糟

20:12.530 --> 20:14.530
反正这整个课程都是一个选修课

20:14.530 --> 20:15.530
我也不在选修课里边

20:15.530 --> 20:16.530
做什么扩展

20:20.440 --> 20:21.440
因为那个 Xpress

20:21.440 --> 20:23.440
它没有办法

20:23.440 --> 20:24.440
没有办法

20:24.440 --> 20:25.440
用一个 apn 让你得到

20:25.440 --> 20:26.440
后续的响应结果

20:26.440 --> 20:27.440
那么我们只能去改装

20:27.440 --> 20:28.440
改装这个函数

20:28.440 --> 20:29.440
好 你看

20:29.440 --> 20:30.440
我改装了这两个函数

20:30.440 --> 20:31.440
那么那个时候过后呢

20:31.440 --> 20:32.440
是不是交给后续运行

20:32.440 --> 20:33.440
后续在胜着的时候

20:33.440 --> 20:34.440
它的内部最终会

20:34.440 --> 20:35.440
调用 write 函数

20:35.440 --> 20:36.440
写东西

20:36.440 --> 20:37.440
往响应题里边写东西

20:37.440 --> 20:38.440
一写的话

20:38.440 --> 20:39.440
是不是调用的我们这个函数

20:39.440 --> 20:40.440
对吧

20:40.440 --> 20:41.440
该改过的这个函数

20:41.440 --> 20:42.440
然后它写的东西

20:42.440 --> 20:44.440
是不是加到这个数组里边去了

20:44.440 --> 20:45.440
这样子呢

20:45.440 --> 20:46.440
我们才能获取到

20:46.440 --> 20:47.440
后续给它加入的响应题

20:47.440 --> 20:48.440
好了吧

20:48.440 --> 20:49.440
当它写完了过后

20:49.440 --> 20:50.440
我们来看一下这个响应题

20:50.440 --> 20:51.440
输出这个trunk

20:52.440 --> 20:53.440
输出这个trunk

20:53.440 --> 20:54.440
咱们来看一下这个响应题

20:55.440 --> 20:56.440
这个响应题呢

20:57.440 --> 20:58.440
保存

20:58.440 --> 20:59.440
然后我们到这边

21:01.440 --> 21:02.440
刷新

21:02.440 --> 21:03.440
然后这边看一下

21:03.440 --> 21:04.440
有没有呢

21:04.440 --> 21:05.440
好像没意有

21:05.440 --> 21:06.440
这个没意有是怎么回事呢

21:06.440 --> 21:07.440
然后我们来

21:07.440 --> 21:08.440
这里点

21:08.440 --> 21:09.440
检查一下浏览器

21:09.440 --> 21:10.440
这个没意有呢

21:10.440 --> 21:12.440
其实是一个很小很小的细节

21:12.440 --> 21:13.440
因为它是304

21:13.440 --> 21:14.440
我们之前说过

21:14.440 --> 21:15.440
这个 express 呢

21:15.440 --> 21:16.440
它会自动

21:16.440 --> 21:17.440
同一个请求

21:17.440 --> 21:18.440
它会给你响应304

21:18.440 --> 21:20.440
那么304是

21:20.440 --> 21:22.440
这个东西实际上还是运行了的

21:22.440 --> 21:24.440
就是如果说没有响应题的话

21:24.440 --> 21:26.440
我们换一个路径

21:27.440 --> 21:28.440
我们把这个清空

21:28.440 --> 21:30.440
把这个redis那个keyz

21:30.440 --> 21:31.440
给它清除掉

21:33.440 --> 21:34.440
对

21:34.440 --> 21:35.440
keyz

21:36.440 --> 21:37.440
把这个keyz给它清除掉

21:42.140 --> 21:43.140
给它清除掉了

21:43.140 --> 21:44.140
那么现在呢

21:44.140 --> 21:45.140
我们来刷新

21:46.140 --> 21:47.140
刷新过后呢

21:47.140 --> 21:48.140
我们来看一下

21:48.140 --> 21:49.140
这边

21:49.140 --> 21:50.140
但是服务器呢

21:51.140 --> 21:52.140
服务器这边

21:52.140 --> 21:53.140
有没有数据呢

21:53.140 --> 21:54.140
现在倒是有数据

21:54.140 --> 21:55.140
因为数据改了

21:55.140 --> 21:56.140
变了

21:56.140 --> 21:57.140
然后我们再刷新

21:57.140 --> 21:58.140
再刷新

21:58.140 --> 21:59.140
它变成空数组了

21:59.140 --> 22:00.140
这是怎么回事呢

22:00.140 --> 22:01.140
这个不用去管它

22:01.140 --> 22:02.140
这是它因为是304

22:02.140 --> 22:03.140
因为 express

22:03.140 --> 22:05.140
它如果说那种没变化的话

22:05.140 --> 22:06.140
就是现在这个函数有没有运行

22:06.140 --> 22:07.140
就第二次请求的时候

22:07.140 --> 22:09.140
这个函数还是运行了的

22:09.140 --> 22:10.140
还是从数据库里面拿出

22:10.140 --> 22:11.140
拿了数据的

22:11.140 --> 22:12.140
只不过呢

22:12.140 --> 22:13.140
你看

22:13.140 --> 22:14.140
它往后移交吗

22:14.140 --> 22:15.140
它没有缓存吗

22:15.140 --> 22:16.140
我现在没有缓存

22:16.140 --> 22:17.140
没有缓存往后移交

22:17.140 --> 22:18.140
往后移交

22:18.140 --> 22:19.140
发送这个数据

22:19.140 --> 22:20.140
但是由于

22:20.140 --> 22:21.140
express一看

22:21.140 --> 22:22.140
这个数据跟之前发送的数据

22:22.140 --> 22:23.140
好像是一样的

22:23.140 --> 22:24.140
因为他得到的是

22:24.140 --> 22:25.140
之前讲过的

22:25.140 --> 22:27.140
他得到的是E-Tag

22:27.140 --> 22:28.140
他发现E-Tag是一样的

22:28.140 --> 22:29.140
一样的话

22:29.140 --> 22:31.140
他就不给你发送小硬体了

22:31.140 --> 22:33.140
由于他没有给你发送小硬体

22:33.140 --> 22:34.140
是不是他没有运行

22:34.140 --> 22:35.140
一个right寒数

22:35.140 --> 22:36.140
没有运行right寒数

22:36.140 --> 22:37.140
那么就导致

22:37.140 --> 22:39.140
我这个数组是空的

22:39.140 --> 22:40.140
就是这么个回事

22:40.140 --> 22:41.140
那么只要你

22:41.140 --> 22:42.140
比方说

22:42.140 --> 22:43.140
现在我们只要做这么一件事

22:43.140 --> 22:45.140
比方说把地址改一下

22:45.140 --> 22:46.140
b等于3

22:47.140 --> 22:48.140
路径变了

22:48.140 --> 22:49.140
对吧

22:49.140 --> 22:50.140
是不是可以拿到这个小硬体的

22:50.140 --> 22:51.140
对不对

22:51.140 --> 22:52.140
这个小硬体是有多段数据组成的

22:52.140 --> 22:53.140
那么这里

22:53.140 --> 22:55.140
我们要做的事情

22:55.140 --> 22:57.140
就是把这个trunk进行合并

22:57.140 --> 22:59.140
这数组合并起来

22:59.140 --> 23:00.140
那怎么来合并呢

23:00.140 --> 23:01.140
我们可以用这种方式

23:01.140 --> 23:03.140
trunk

23:03.140 --> 23:04.140
Mac

23:04.140 --> 23:06.140
把每一个trunk

23:06.140 --> 23:09.140
然后变成一个2 stream

23:09.140 --> 23:12.140
UTF-8边

23:12.140 --> 23:14.140
把它变成个置物串

23:14.140 --> 23:15.140
那么多个trunk

23:15.140 --> 23:18.140
再交连接起来

23:18.140 --> 23:22.140
那么这就是我们的保底内容

23:22.140 --> 23:23.140
保底

23:23.140 --> 23:24.140
看前面有没有写保底

23:24.140 --> 23:26.140
保底在这里定义

23:26.140 --> 23:29.140
我们这里输出保底

23:29.140 --> 23:30.140
保存

23:30.140 --> 23:32.140
现在我们再来看

23:32.140 --> 23:33.140
刷清

23:33.140 --> 23:34.140
现在没有输出

23:34.140 --> 23:35.140
没有输出

23:35.140 --> 23:36.140
因为它有304

23:36.140 --> 23:37.140
它没有往小硬体里面写数据

23:37.140 --> 23:39.140
比方等于4

23:39.140 --> 23:40.140
保底得到了

23:40.140 --> 23:41.140
得到一个置物串

23:41.140 --> 23:42.140
这是保底

23:42.140 --> 23:43.140
那就是个置物串了

23:43.140 --> 23:44.140
得到了保底

23:44.140 --> 23:45.140
那么现在我们要做的事情

23:45.140 --> 23:46.140
就是把保底缓存起来

23:46.140 --> 23:47.140
对吧

23:47.140 --> 23:48.140
那么我们这里可以使用

23:48.140 --> 23:49.140
client

23:49.140 --> 23:51.140
就是set a sync

23:51.140 --> 23:52.140
sync a sync

23:52.140 --> 23:54.140
缓存起来

23:54.140 --> 23:57.140
缓存起来

23:57.140 --> 24:00.140
然后这里直接缓存吧

24:00.140 --> 24:01.140
就是keyz

24:01.140 --> 24:04.140
然后保底缓存起来

24:04.140 --> 24:05.140
那么现在呢

24:05.140 --> 24:06.140
我给大家看一下

24:06.140 --> 24:07.140
为了让大家看得更加清楚

24:07.140 --> 24:09.140
我们如果说有缓存的话

24:09.140 --> 24:11.140
我们这里就写

24:11.140 --> 24:13.140
使用了缓存

24:13.140 --> 24:16.140
然后呢跟上一个keyz

24:16.140 --> 24:17.140
就是我们的请求路径

24:17.140 --> 24:19.140
对这个路径我们使用了缓存

24:19.140 --> 24:21.140
就没有往后移交了

24:21.140 --> 24:22.140
好

24:22.140 --> 24:23.140
如果说在这

24:23.140 --> 24:24.140
如果说代码到了这呢

24:24.140 --> 24:26.140
没有使用缓存

24:26.140 --> 24:27.140
对吧

24:27.140 --> 24:29.140
代码到了这是不是没有使用缓存

24:29.140 --> 24:31.140
没有使用缓存

24:31.140 --> 24:33.140
使用缓存

24:33.140 --> 24:34.140
我们这里得到

24:34.140 --> 24:35.140
rig

24:35.140 --> 24:37.140
orange in URL

24:37.140 --> 24:38.140
好了

24:38.140 --> 24:39.140
接下来我们来看一下

24:39.140 --> 24:41.140
我们的最后的效果

24:41.140 --> 24:43.140
成功

24:43.140 --> 24:44.140
然后呢

24:44.140 --> 24:45.140
这边

24:45.140 --> 24:47.140
从这里开始缓存

24:47.140 --> 24:48.140
一

24:48.140 --> 24:49.140
没有使用缓存的吧

24:49.140 --> 24:50.140
那么这个是

24:50.140 --> 24:51.140
就是真正的

24:51.140 --> 24:53.140
从数据库拿来的数据

24:53.140 --> 24:54.140
好

24:54.140 --> 24:55.140
接下来我们看一下

24:55.140 --> 24:56.140
二

24:56.140 --> 24:57.140
还是一

24:57.140 --> 24:59.140
下一次再缓存

24:59.140 --> 25:01.140
是不是使用了缓存

25:01.140 --> 25:02.140
对不对

25:02.140 --> 25:03.140
它从缓存里边拿了数据

25:03.140 --> 25:04.140
再来再缓存

25:04.140 --> 25:05.140
还是使用了缓存

25:05.140 --> 25:07.140
接下来我们关掉浏览器

25:07.140 --> 25:09.140
就是模拟另外一个用户

25:09.140 --> 25:11.140
或者说我们新鲜一个浏览器

25:11.140 --> 25:12.140
模拟另外一个用户

25:12.140 --> 25:14.140
一回车

25:14.140 --> 25:15.140
还是使用了缓存

25:15.140 --> 25:16.140
对吧

25:16.140 --> 25:17.140
相当于这篇新闻

25:17.140 --> 25:19.140
它就不再去读数据库了

25:19.140 --> 25:20.140
你看只读了一次数据库

25:20.140 --> 25:22.140
后面就一直使用缓存了

25:22.140 --> 25:23.140
刚才我想起来了

25:23.140 --> 25:24.140
这个地方

25:24.140 --> 25:25.140
你还可以配置时间

25:25.140 --> 25:27.140
TTL

25:27.140 --> 25:28.140
TTL

25:28.140 --> 25:29.140
不行

25:29.140 --> 25:31.140
你看看TTL有没有值

25:31.140 --> 25:32.140
如果说没有值的话

25:32.140 --> 25:33.140
那么我就默认为

25:33.140 --> 25:34.140
負一

25:34.140 --> 25:36.140
TTL就是

25:36.140 --> 25:38.140
永远不过期

25:38.140 --> 25:39.140
没有意思吧

25:39.140 --> 25:40.140
那么我们在

25:40.140 --> 25:41.140
设置缓存的时候

25:41.140 --> 25:43.140
我还可以一个设置TTL

25:43.140 --> 25:46.140
我记得

25:46.140 --> 25:47.140
Cleanse

25:47.140 --> 25:48.140
Cleanse试一下

25:48.140 --> 25:49.140
它这个set

25:49.140 --> 25:51.140
反处

25:51.140 --> 25:53.140
应该有TTL的

25:53.140 --> 25:57.450
应该是有的mode

25:57.450 --> 26:00.460
应该是这个

26:00.460 --> 26:02.460
mode就是es

26:02.460 --> 26:04.460
然后direction

26:04.460 --> 26:05.460
应该是这个

26:05.460 --> 26:08.030
进去看一下

26:08.030 --> 26:09.030
应该没问题

26:09.030 --> 26:11.030
我们这里设置一下

26:11.030 --> 26:12.030
set而sync

26:12.030 --> 26:13.030
那么这后面

26:13.030 --> 26:14.030
我们写上

26:14.030 --> 26:16.030
ex expire

26:16.030 --> 26:18.030
过期时间是什么

26:18.030 --> 26:20.030
TTL

26:20.030 --> 26:21.030
保存

26:21.030 --> 26:23.030
再来

26:23.030 --> 26:24.030
现在我们的访问2

26:24.030 --> 26:25.030
看一下访问2

26:25.030 --> 26:27.030
访问2的时候呢

26:29.030 --> 26:31.030
invade expire 10

26:31.030 --> 26:33.030
inset

26:33.030 --> 26:35.030
这里要查一下文档了

26:35.030 --> 26:37.030
要查一下文档了

26:37.030 --> 26:38.030
Redis

26:38.030 --> 26:40.030
直接从mpm去查询吧

26:40.030 --> 26:45.070
它过期时间

26:45.070 --> 26:46.070
设置方式呢

26:46.070 --> 26:48.070
难道跟那个

26:48.070 --> 26:50.070
原生的有点不一样吗

26:50.070 --> 26:51.070
看一下吧

26:51.070 --> 26:52.070
查一下就知道了

26:52.070 --> 26:53.070
这一种也

26:53.070 --> 26:54.070
解决不入

26:54.070 --> 26:58.920
它可以什么去查

27:01.920 --> 27:06.550
它包了一个错误

27:06.550 --> 27:09.550
它说无效的过期时间

27:09.550 --> 27:11.550
set里面有无效的过期时间

27:11.550 --> 27:14.990
附一这个值

27:14.990 --> 27:15.990
它可能不支持

27:15.990 --> 27:19.300
看一下吧

27:19.300 --> 27:21.300
我要找到它的完整的API

27:21.300 --> 27:27.110
对了对了

27:27.110 --> 27:30.450
对了对了

27:30.450 --> 27:32.450
没问题

27:32.450 --> 27:37.230
没问题

27:37.230 --> 27:39.230
API

27:39.230 --> 27:40.230
它就是说的

27:40.230 --> 27:42.230
就是对应那个

27:42.230 --> 27:45.230
Redis CD里面的API

27:45.230 --> 27:53.700
set

27:53.700 --> 27:55.700
它有没有一个完整的API文档

27:55.700 --> 27:58.700
它这里全是说明文档

27:58.700 --> 28:00.700
它们有API文档

28:00.700 --> 28:02.700
我看一下吧

28:02.700 --> 28:04.700
set和数

28:04.700 --> 28:05.700
这里不好查

28:05.700 --> 28:06.700
它没有可以写一个

28:06.700 --> 28:09.700
完整的API文档

28:09.700 --> 28:10.700
要找一找

28:10.700 --> 28:14.070
我要找一找

28:14.070 --> 28:15.070
create connect

28:15.070 --> 28:20.580
不是

28:20.580 --> 28:21.580
这全是跟

28:21.580 --> 28:23.580
针对那个刻骨端的操作的

28:23.580 --> 28:25.580
错误的操作

28:25.580 --> 28:27.580
这都没意义对我来说

28:27.580 --> 28:38.840
找一找set

28:38.840 --> 28:40.840
这些都没有意义

28:40.840 --> 28:41.840
它们有一个

28:41.840 --> 28:43.840
完整的API文档

28:46.340 --> 28:48.340
我试一下这样子

28:48.340 --> 28:50.340
我刚才我插注写错了吗

28:50.340 --> 28:52.340
应该是没问题的呀

28:52.340 --> 28:54.340
等于2

28:54.340 --> 28:56.340
1x

28:56.340 --> 28:58.340
-1

29:01.340 --> 29:03.340
你不能直接设置-1

29:03.340 --> 29:05.340
-1是不能作为

29:05.340 --> 29:07.340
直接设置-1是不行的

29:07.340 --> 29:08.340
这样子是可以的

29:08.340 --> 29:09.340
但是不能直接设置-1

29:09.340 --> 29:10.340
明白了

29:10.340 --> 29:12.340
它有一个API没问题

29:12.340 --> 29:14.340
是我这个-1是不能直接设置的

29:14.340 --> 29:16.340
如果说我们判断一下吧

29:16.340 --> 29:17.340
这个很简单

29:17.340 --> 29:19.340
TTL如果说小于0

29:19.340 --> 29:21.340
小于0的话

29:21.340 --> 29:23.340
咱们就这样子设置

29:23.340 --> 29:25.780
对吧

29:25.780 --> 29:26.780
永不过期吗

29:26.780 --> 29:27.780
L

29:27.780 --> 29:29.780
那么我就这样子设置

29:29.780 --> 29:30.780
对不对

29:30.780 --> 29:32.780
这样子处理一下就行了

29:32.780 --> 29:34.780
比方说我这里呢

29:34.780 --> 29:35.780
有个过期时间

29:35.780 --> 29:36.780
过期时间我们配置一下

29:36.780 --> 29:37.780
TTL

29:37.780 --> 29:40.780
配置10秒钟过期

29:40.780 --> 29:41.780
保存

29:41.780 --> 29:43.780
接下来再来看

29:44.780 --> 29:45.780
明白了

29:45.780 --> 29:46.780
好

29:46.780 --> 29:48.780
现在我们来一个新闻

29:48.780 --> 29:50.780
新闻3

29:50.780 --> 29:51.780
好

29:51.780 --> 29:52.780
那么现在呢

29:52.780 --> 29:53.780
是不是从数据库里面拿的

29:53.780 --> 29:54.780
然后再来刷新

29:54.780 --> 29:55.780
是使用了缓存

29:55.780 --> 29:56.780
对吧

29:56.780 --> 29:57.780
再来刷新

29:57.780 --> 29:58.780
还是使用了缓存

29:58.780 --> 29:59.780
对不对

29:59.780 --> 30:00.780
然后再来刷新

30:00.780 --> 30:01.780
是使用了缓存

30:01.780 --> 30:02.780
10秒钟应该到了

30:02.780 --> 30:03.780
再刷新

30:03.780 --> 30:04.780
是没有使用缓存了

30:04.780 --> 30:05.780
又从数据库拿了

30:05.780 --> 30:06.780
对不对

30:06.780 --> 30:07.780
就这么一回事

30:07.780 --> 30:08.780
就这么简单

30:08.780 --> 30:09.780
那么现在呢

30:09.780 --> 30:10.780
是不是就可以搞定这件事了

30:10.780 --> 30:12.780
这就是对于想硬体的缓存

30:12.780 --> 30:13.780
那么这种处理方式呢

30:13.780 --> 30:14.780
比较好的一点就是

30:14.780 --> 30:16.780
它对后续没有什么影响

30:16.780 --> 30:17.780
你看对后续的处理

30:17.780 --> 30:18.780
该怎么处理就怎么处理

30:18.780 --> 30:20.780
我就在前面给你加一层

30:20.780 --> 30:22.780
用缓存来进行控制

30:22.780 --> 30:23.780
请问加了一层

30:23.780 --> 30:24.780
当然这里边还可以写出

30:24.780 --> 30:26.780
更加丰富的代码

30:26.780 --> 30:27.780
根据具体的场景来了

30:27.780 --> 30:28.780
我就举个例子

30:28.780 --> 30:29.780
给他起个头

30:29.780 --> 30:30.780
这是关于

30:30.780 --> 30:32.780
这用那个Redis来实现

30:32.780 --> 30:34.780
Express的消息体的缓存

30:34.780 --> 30:36.780
下期后我们讲一下

30:36.780 --> 30:38.780
关于Session的缓存又差不多了

