WEBVTT

00:00.180 --> 00:03.000
这些课咱们讲那个TOA的API

00:03.500 --> 00:08.120
实际上对于我来说 我始终是觉得上一节课虽然没有任何代码

00:08.380 --> 00:11.440
比这节课更加重要 咱们学程序啊

00:11.700 --> 00:13.740
思维的层面一定要高一点

00:14.000 --> 00:18.620
不要天天就掀到代码里边去了 这代码呢就真正你在敲代码的时候

00:18.860 --> 00:20.660
这些API它只是个工具

00:21.180 --> 00:22.960
相当于是服务员 为你服务的

00:23.220 --> 00:27.060
你要不要用它 你怎么去用它 完全有你自己做决定

00:27.700 --> 00:31.420
那你怎么来判断要不要用它 怎么样去用它

00:31.920 --> 00:34.480
那么就需要概念性的东西 需要原理性的东西

00:35.000 --> 00:38.580
不过对于初学者的话 可能难以避免的会

00:38.840 --> 00:42.160
比较看重API而不是很看重的原理

00:42.680 --> 00:45.240
怎么说呢 慢慢来吧 我希望了

00:45.500 --> 00:49.580
大家慢慢去重视这个原理 原理其实比API重要多

00:50.360 --> 00:53.180
咱们这就和说API API其实是比较轻松的

00:53.380 --> 00:57.480
第一个就是创建QA应用 跟那个Express是一样的

00:57.740 --> 00:59.280
我们这里呢 直接来

01:00.560 --> 01:01.320
先安装吧

01:02.100 --> 01:04.400
MTMI QA

01:05.160 --> 01:07.220
顺便把那个安装了 把那个

01:07.720 --> 01:10.020
那个loader嘛 安装了 好比别名测试

01:10.280 --> 01:11.060
安装个loader嘛

01:11.820 --> 01:13.100
然后再安装一个那个吧

01:13.360 --> 01:14.120
Types load

01:16.570 --> 01:18.370
好了 把这两个安装好了

01:18.890 --> 01:21.970
它其实跟那个Express的用法呢 差不多

01:22.270 --> 01:26.030
特别是中间键的一块啊 用法特别像是Start

01:27.310 --> 01:29.350
这里边我们写上那个

01:30.110 --> 01:31.910
loader.index

01:33.190 --> 01:33.710
好 这边

01:34.710 --> 01:35.590
这边加一个文件

01:35.990 --> 01:37.030
index.js

01:37.790 --> 01:39.590
好 那它这么写呢 它是这样子啊

01:40.350 --> 01:42.390
两种写法 第一种呢就是

01:43.670 --> 01:45.470
通过ATDP这个模块啊

01:45.730 --> 01:47.530
loader的内置模块来创建一个服务器

01:47.790 --> 01:49.830
那么它怎么创建 看一下对比一下Express

01:49.830 --> 01:50.750
是不是差不多的 是吧

01:51.050 --> 01:52.010
得到一个Express

01:52.170 --> 01:54.650
然后呢 创建一个Express对象

01:54.770 --> 01:57.210
一个实力 那么就得到了一个Express应用

01:57.290 --> 01:59.090
那么这里得到的是KLA应用

02:00.090 --> 02:02.370
好 然后我们在Crease Server的时候呢

02:03.090 --> 02:04.650
把这个Express传进去

02:05.010 --> 02:07.570
对吧 那么这里的KLA的传法呢 是它里边有一个函数

02:07.570 --> 02:08.170
Coreback

02:08.610 --> 02:11.690
把Coreback函数啊 雕用之后呢 它返回另外一个函数啊

02:11.970 --> 02:12.890
它是个高间函数

02:13.250 --> 02:14.250
那么把它传进去

02:14.530 --> 02:16.690
然后接下来就是监听了啊 监听软口

02:16.810 --> 02:18.370
我们通过一个内置模块来监听软口

02:18.570 --> 02:19.890
那么比较这里9527

02:20.810 --> 02:22.650
Coreback就是监听完成之后啊

02:22.650 --> 02:23.770
它以来回调函数

02:24.050 --> 02:25.070
比较说我们这里输出

02:25.370 --> 02:26.690
server nation

02:29.200 --> 02:30.240
好 试一下吧

02:30.680 --> 02:32.240
接下来我们来这里呢 打开

02:34.770 --> 02:35.930
NPM Start

02:38.270 --> 02:39.990
诶 它这里 爆错了

02:40.430 --> 02:42.550
AGDP nation is not a function

02:43.830 --> 02:47.230
它说 哦 这里写错了 这里写错了

02:47.550 --> 02:49.030
这里呢 应该是这样子

02:49.830 --> 02:52.350
AGDP create server

02:52.350 --> 02:54.230
这边得到的是一个server对象

02:55.130 --> 02:56.170
这边是一个server对象

02:56.890 --> 02:58.690
然后通过这个server对象去监听

02:59.090 --> 02:59.810
应该是这样子

03:00.930 --> 03:01.450
写错了

03:02.010 --> 03:02.570
然后启动

03:02.730 --> 03:04.530
server联系你 对吧 就监听起来了

03:04.690 --> 03:06.170
然后我们去访问一下试一下呢

03:06.410 --> 03:09.570
比方说Nokohost 9527

03:09.810 --> 03:12.050
访问 你看这里写的呢 老是放的 对吧

03:12.050 --> 03:13.850
它不是没 它能不能访问到 能访问到

03:13.850 --> 03:15.330
而且给了我一个响应

03:15.330 --> 03:17.810
表示没有找到任何东西 但是也是响应嘛

03:18.130 --> 03:20.930
说明它 说明KOA给了我这个响应

03:21.010 --> 03:21.810
对吧 完成了

03:21.970 --> 03:24.170
这种方式啊 我这里把它稍微改一下

03:24.970 --> 03:25.850
这个地方应该是这样子

03:27.290 --> 03:27.690
server

03:28.730 --> 03:30.330
这边是通过server去监听

03:30.570 --> 03:31.970
那么这种写法呢 为什么

03:32.130 --> 03:35.850
有什么就想问啊 为什么要去使用原生的这个AGDP

03:36.330 --> 03:37.570
为什么要用这种做法

03:37.570 --> 03:39.490
你看express我们也没有用对不对

03:39.570 --> 03:41.570
那么有没有可能会用呢 是有可能的

03:41.930 --> 03:43.810
比方说你有的时候呢 会

03:44.610 --> 03:45.850
直接用原生的

03:46.090 --> 03:47.250
去做一些事

03:47.570 --> 03:49.050
那么这个时候呢 就可能会用原

03:49.210 --> 03:50.290
那么你不希望

03:50.490 --> 03:53.570
因为KOA还有些事可能没有原生的做的那么方便

03:53.670 --> 03:57.070
你可能是想直接通过这个原生的AGDP去做一些事

03:57.070 --> 03:59.630
比方说监听一些事件啊 这里边不是有事件嘛 对吧

03:59.910 --> 04:02.070
那么就想想去监听一些事件啊等等等等

04:02.230 --> 04:04.070
那么这个时候呢 你就可以用server

04:04.310 --> 04:06.430
用它来去做处理

04:06.870 --> 04:09.070
在它里面去融合这个KOA

04:10.070 --> 04:11.270
好 这种方式啊

04:11.430 --> 04:13.630
当然呢 你可以比方说 还有种情况就是

04:14.870 --> 04:17.830
你可能会用另外一个模块 叫AGPS

04:18.070 --> 04:19.510
对吧 是我们讲过的对不对

04:19.750 --> 04:22.630
那么我们可以 在AGPS里面我们可以

04:22.650 --> 04:26.370
就说我们的服务器呢 它既支持AGPS 也支持AGPS

04:26.650 --> 04:27.650
那么这种情况下

04:27.730 --> 04:31.130
那么我们是不是可以通过AGPS去创建一个服务器

04:31.250 --> 04:32.770
那么这个服务器呢 也跟那个

04:34.170 --> 04:35.250
AGPS的服务器

04:35.410 --> 04:37.650
使用同样的同一个KOA实力

04:37.810 --> 04:39.330
对吧 那么这样子是不是也可以 对吧

04:39.330 --> 04:41.010
这个得到一个AGPS server

04:41.130 --> 04:42.290
然后它去监听

04:42.530 --> 04:44.530
对吧 那么这些当然都可以联合处理的

04:45.210 --> 04:46.530
好 这是它跟那个

04:46.850 --> 04:49.770
这种方式啊 第一种方式要创建KOA应用

04:49.890 --> 04:51.970
第二种方式呢 就是跟Express很相似的

04:52.030 --> 04:54.230
就直接通过KOA来创建

04:54.910 --> 04:57.070
创建应用过后呢 直接通过KOA来监听

04:57.190 --> 04:58.870
那么这种方式呢 其实是一个

04:59.110 --> 05:00.230
你做了一个简化版

05:00.510 --> 05:03.990
在它那一步呢 实际上它就是帮你创建了AGPS

05:04.190 --> 05:05.790
然后呢 帮你创建了一个server

05:05.950 --> 05:07.910
然后通过server去监听你这个端口

05:08.190 --> 05:09.870
对吧 是一样的 好 咱们来看一下吧

05:10.230 --> 05:13.110
第二种情况呢 当然写了稍微常见一点

05:13.910 --> 05:15.630
我们这里直接复制一下吧

05:16.350 --> 05:16.870
复制一下

05:17.910 --> 05:18.790
好 再来啊

05:19.550 --> 05:21.310
第二种写法呢 就这样子

05:21.530 --> 05:22.650
直接adb.lesson

05:23.570 --> 05:24.330
效果是一样的

05:25.610 --> 05:27.930
对 Server.lesson.ly 对吧 这边刷新一下

05:28.810 --> 05:29.770
效果是一样的

05:29.970 --> 05:30.890
好 这是这种方式

05:31.010 --> 05:32.930
总之呢 我们可以创建一个KOA应用

05:33.050 --> 05:34.090
跟Express一样

05:34.530 --> 05:38.050
我们通常一个应用程序呢 只有一个KOA应用

05:39.410 --> 05:41.850
创建好了KOA应用过后呢 我们后边就

05:42.210 --> 05:44.850
KOA应用 我们知道KOA用法了就是

05:45.010 --> 05:47.050
注册中间间 他没有别的玩意儿了

05:47.170 --> 05:48.010
全是中间间

05:48.250 --> 05:49.770
而且呢 他没有什么路由规则

05:50.070 --> 05:52.470
那就是 ab.app.use 中间间

05:52.710 --> 05:54.230
use 中间间 2 中间间 3

05:54.630 --> 05:56.110
所以说他后边的写法就很简单

05:56.550 --> 05:57.790
然后在这里 我们可以写

05:58.030 --> 05:59.550
app.use 当然你可以分模块

05:59.670 --> 06:01.670
分到不同的模块里面 这些都是灵活处理

06:01.950 --> 06:04.190
那么第一个中间间 一个中间间实际上是一个什么

06:04.310 --> 06:05.230
实际上就是一个函数

06:05.430 --> 06:06.630
这个函数的格式是这样子的

06:06.950 --> 06:08.230
第一个材料是 context

06:08.550 --> 06:10.230
上一回讲了 对吧 第一个材料是 next

06:10.590 --> 06:11.430
就下一个中间

06:11.750 --> 06:14.070
如果说你这个中间间不需要往后边移交了

06:14.070 --> 06:16.110
那就可以不使用第二个材数

06:17.790 --> 06:18.350
它是这样子的

06:19.010 --> 06:19.610
第一个中间间

06:20.210 --> 06:21.210
made 1

06:22.690 --> 06:23.290
第二个中间间

06:24.170 --> 06:26.250
方形 cts next

06:27.170 --> 06:29.770
那么这个是 made 2

06:30.610 --> 06:32.330
就写完了

06:33.090 --> 06:34.810
保存好了 过后呢 我们来看一下

06:35.410 --> 06:36.130
我们把这个拼空

06:37.450 --> 06:38.970
然后在这个榴弹器里面刷新一下

06:39.610 --> 06:40.330
然后放着 对吧

06:40.450 --> 06:41.810
那么这里输出了made 1

06:41.930 --> 06:43.570
那么为什么没有输出made 2呢

06:43.770 --> 06:45.370
是因为我们这里没有叫 next

06:45.930 --> 06:46.250
对不对

06:46.850 --> 06:47.690
是不是没有叫 next

06:48.310 --> 06:49.390
那么掉到 next 过后了

06:49.390 --> 06:49.830
你看一下

06:50.470 --> 06:51.310
现在我们来看一下

06:52.230 --> 06:52.950
这边刷新

06:54.270 --> 06:55.550
这边made 1,made 2

06:55.990 --> 06:56.270
对不对

06:56.710 --> 06:58.670
这里是不是跟 express 就有区别了

06:58.790 --> 06:59.390
区别在哪呢

06:59.510 --> 07:00.950
express 像这种情况下

07:01.030 --> 07:02.190
你没有响应 对不对

07:02.230 --> 07:03.030
是不是没有响应

07:03.310 --> 07:04.150
没有响应的话

07:04.150 --> 07:05.790
那么客户员会不是一直等着

07:06.030 --> 07:06.990
一直在那里等着

07:07.550 --> 07:08.950
等着服务器给我响应

07:09.430 --> 07:11.990
那么在 QoA 里边还没有这样做

07:12.310 --> 07:14.110
QoA 它是一定会响应的

07:14.590 --> 07:15.590
如果说你没有响应的话

07:15.590 --> 07:16.590
它就是一个 404

07:17.090 --> 07:17.930
你没给它荣幸吗

07:17.930 --> 07:19.090
它就认为它没有资源

07:19.090 --> 07:20.090
它默认的情况

07:20.090 --> 07:21.090
它就是一个 404

07:22.290 --> 07:23.590
一个 404.0

07:23.930 --> 07:25.490
你看 next 过了刷新一下

07:26.290 --> 07:28.290
得到了响应嘛 404

07:28.690 --> 07:29.490
响应的消息体

07:29.490 --> 07:30.690
它就给你一个那次放的

07:31.290 --> 07:31.890
这是

07:34.090 --> 07:35.690
这是 QoA 的处理方式

07:36.090 --> 07:36.890
注册中间键

07:37.090 --> 07:40.090
那么接下来就我们这里刻了重点

07:40.090 --> 07:41.290
就是 context

07:41.690 --> 07:43.290
因为我们中间键里边那个时候

07:43.290 --> 07:44.490
还说是非常简单的

07:44.490 --> 07:44.890
对不对

07:44.990 --> 07:46.990
我们之前也上级可以看到过

07:47.190 --> 07:48.790
我们可以移交给下个中间键

07:48.790 --> 07:50.190
而且不同的是

07:50.190 --> 07:51.590
跟 Express 不同的是

07:51.590 --> 07:52.790
我们还可以等待它

07:52.990 --> 07:54.390
等待下一个中间键完成

07:55.190 --> 07:55.990
那么我们

07:56.390 --> 07:58.390
在关键时我们平时用的比较多的是

07:58.390 --> 07:59.190
地合参数

07:59.190 --> 08:00.390
地合参数就是 context

08:00.590 --> 08:01.390
上下文对象

08:01.590 --> 08:02.990
上下文对象里边是不是包含了

08:02.990 --> 08:04.390
请求和响应的信息

08:04.590 --> 08:04.990
对不对

08:05.290 --> 08:07.990
那么上下文对象里边到底有哪些 API

08:07.990 --> 08:09.590
哪些常用的 API 们来看一下

08:10.190 --> 08:13.190
当然我们这里可能不会做任何的练习

08:13.690 --> 08:14.790
不会做任何有意的练习

08:14.890 --> 08:17.290
因为这些东西我们在 Express 里边已经完全做过了

08:17.490 --> 08:19.690
我只是把那些常用的 API 给大家介绍一下

08:19.890 --> 08:20.690
大家对号入座

08:21.290 --> 08:22.490
要 Express 能做的事情

08:23.090 --> 08:24.290
KVA 里面该怎么去做

08:24.490 --> 08:25.490
对号入座就行了

08:25.690 --> 08:27.290
当然你们也不用去背

08:27.690 --> 08:28.690
当你们在开发的时候

08:28.690 --> 08:29.890
你们去看就行了

08:29.890 --> 08:31.690
我告诉大家如果说我来学这个 KVA

08:31.690 --> 08:32.890
如果说我以前没接触过

08:33.190 --> 08:35.690
比方说我没有接触过 Express

08:36.490 --> 08:38.090
那么我直接接触到 KVA

08:38.490 --> 08:39.290
那我怎么学呢

08:39.690 --> 08:40.690
我就把官方稳当

08:41.190 --> 08:42.090
快速的播一遍

08:42.490 --> 08:43.690
比方说一个小时

08:43.790 --> 08:45.590
最多一个小时就快速的过一遍

08:45.990 --> 08:46.790
过一遍过后

08:46.790 --> 08:47.590
我一个都记不住

08:47.990 --> 08:49.590
但是我记住了 KVA 的原理

08:49.590 --> 08:50.590
它到底是什么回事

08:50.990 --> 08:51.790
就我上去可想的

08:52.790 --> 08:55.790
然后当我有一天我要去在公司里边做开发

08:56.390 --> 08:58.990
当我们决定要使用 KVA 的时候

08:58.990 --> 09:02.390
我觉得KVA 虽然说生态没有 Express 强大

09:02.390 --> 09:03.790
因为 Express 它出来比较早

09:03.990 --> 09:04.390
对不对

09:04.390 --> 09:05.790
你看 Mpm 上的下载

09:06.290 --> 09:08.290
虽然说 KVA 我觉得它各方面做的

09:08.290 --> 09:09.790
已经比 Express 好了

09:09.990 --> 09:11.990
但是它的生态没有 Express 强大

09:12.090 --> 09:14.090
所以说在 Mpm 下载上来

09:14.090 --> 09:15.290
Express 还是要多一些

09:15.590 --> 09:18.090
以前网站以前是用 Express 做的

09:18.090 --> 09:20.090
它必须还要坚持使用它

09:20.290 --> 09:21.690
因为改动的成本还是蛮大的

09:23.090 --> 09:24.090
如果说一个新的项目

09:24.090 --> 09:26.490
当我决定选择用 KVA 来做的话

09:27.190 --> 09:28.090
我一点都不用担心

09:28.290 --> 09:29.490
我一个都记不住

09:29.490 --> 09:30.090
不用担心

09:30.090 --> 09:31.290
因为我知道它能做什么事

09:31.690 --> 09:32.290
我看到文档

09:32.290 --> 09:33.290
我知道它能做什么事

09:33.490 --> 09:34.490
心里边大概有数了

09:34.790 --> 09:36.290
当我做的时候去查备文档

09:36.290 --> 09:37.290
编查备文档编写

09:37.290 --> 09:38.890
写着现在就没给我什么问题了

09:39.890 --> 09:42.890
这是开发的一个思路

09:42.890 --> 09:44.390
就是位置占高一点

09:44.390 --> 09:45.890
不要去陷到 APN 里边去了

09:45.890 --> 09:47.890
这样子大家会轻松很多

09:49.890 --> 09:51.890
它里边是有四个重要对象

09:52.390 --> 09:52.890
哪四个呢

09:52.890 --> 09:53.890
一个是 Rake Race

09:53.890 --> 09:55.890
一个是 Request Response

09:55.890 --> 09:56.890
看上去有点像是

09:56.890 --> 09:58.390
Rake 表示请求对象

09:58.390 --> 09:59.390
Race 表示想用对象

09:59.390 --> 10:01.390
那么前面两个是跟 ATV 模块

10:01.390 --> 10:03.390
它是 ATV 模块内置的对象

10:03.390 --> 10:04.390
啥意思呢

10:05.390 --> 10:07.390
就这里边它 Rake 和 Race

10:09.200 --> 10:13.200
Rake 和 CTS Race

10:13.200 --> 10:14.700
这两个东西就相当于是

10:14.700 --> 10:16.200
因为它最终它内部

10:16.200 --> 10:18.700
它仍然是使用的是 ATV 模块

10:18.700 --> 10:19.200
对吧

10:19.200 --> 10:20.200
我刚才写了的

10:20.200 --> 10:21.200
就在这

10:22.700 --> 10:23.700
这个模块里边

10:23.700 --> 10:25.700
在这个位置是不是它会传递一个

10:25.700 --> 10:27.200
当任何请求到达的时候

10:27.200 --> 10:28.700
它会传递一个 Rake 和 Race

10:28.700 --> 10:29.200
对吧

10:29.200 --> 10:30.700
Request 和 Response

10:30.700 --> 10:31.700
两个对象传进来

10:31.700 --> 10:32.200
对不对

10:32.200 --> 10:32.700
还记得吗

10:32.700 --> 10:33.700
录了解释

10:33.700 --> 10:35.700
ATV Race Server 里边

10:35.700 --> 10:37.700
不是有两个东西传进来吗

10:37.700 --> 10:38.200
对不对

10:38.200 --> 10:39.200
那么这个

10:39.200 --> 10:41.200
这两个东西就会被保存到

10:41.200 --> 10:42.200
每一次请求到达过后

10:42.200 --> 10:44.200
它创建了上下文 Context

10:44.200 --> 10:46.200
它就会保存到上下文的 Rake 和 Race 里边

10:46.200 --> 10:47.200
对吧

10:47.200 --> 10:48.200
这是原生的

10:48.200 --> 10:49.200
就这么个意思

10:49.200 --> 10:50.200
那么这两个东西

10:50.200 --> 10:51.200
我建议大家不要去使用

10:51.200 --> 10:53.200
官方建议你尽量不要去使用

10:53.200 --> 10:55.200
除非你 KOA 办不到了

10:55.200 --> 10:56.200
你可以用它

10:56.200 --> 10:57.200
原生的去做一些事

10:57.200 --> 10:59.200
一般来说不要去使用

10:59.200 --> 11:01.200
它更加建议你去使用

11:01.200 --> 11:03.200
它给你封装好的就是 Request

11:03.200 --> 11:04.200
和 Response

11:04.200 --> 11:06.200
这两个是 KOA 封装好的

11:06.200 --> 11:07.200
就像那个 Express 一样

11:07.200 --> 11:09.200
Express 的 Rake 和 Race

11:09.200 --> 11:10.200
它不是原生的

11:10.200 --> 11:11.200
对吧

11:11.200 --> 11:12.200
它是给你封装好的

11:12.200 --> 11:13.200
对不对

11:13.200 --> 11:15.200
那么这是这两个

11:15.200 --> 11:17.200
它建议你使用这两个属性

11:17.200 --> 11:18.200
这是关于这个 Context

11:18.200 --> 11:19.200
大家说一下

11:19.200 --> 11:20.200
那么这两个属性里面

11:20.200 --> 11:21.200
到底有什么东西呢

11:21.200 --> 11:22.200
这个时候就看文档了

11:22.200 --> 11:23.200
我这里面完全列出来

11:23.200 --> 11:24.200
它里边东西比较多

11:24.200 --> 11:25.200
我们可以看一下

11:25.200 --> 11:26.200
官方和民间中文

11:26.200 --> 11:28.200
比较民间中文

11:28.200 --> 11:29.200
它里边东西

11:29.200 --> 11:31.200
这里边用中文嘛

11:31.200 --> 11:32.200
看起来舒服一点

11:32.200 --> 11:33.200
请求

11:33.200 --> 11:34.200
你看

11:34.200 --> 11:35.200
它这里告诉你

11:35.200 --> 11:36.200
引起了很清楚了

11:36.200 --> 11:37.200
怎么样呢

11:37.200 --> 11:38.200
你可以获取请求头

11:38.200 --> 11:39.200
来吧

11:39.200 --> 11:40.200
我们试一下

11:40.200 --> 11:41.200
这个东西

11:41.200 --> 11:42.200
你边看文档的时候

11:42.200 --> 11:44.200
比方说我在学习这个 KOA 的时候

11:44.200 --> 11:46.200
我可以大概看一下

11:46.200 --> 11:48.200
看一下那个文档里边

11:48.200 --> 11:49.200
Request 里边

11:49.200 --> 11:50.200
它有什么呢

11:50.200 --> 11:51.200
一个 Header

11:51.200 --> 11:52.200
可以获取什么呢

11:52.200 --> 11:53.200
获取请求头

11:53.200 --> 11:54.200
那么它告诉你的

11:54.200 --> 11:55.200
官方文档免去告诉你

11:55.200 --> 11:56.200
它跟那个 Incoming

11:56.200 --> 11:57.200
Incoming Message

11:57.200 --> 11:59.200
就是不是原生的那个 Rake

11:59.200 --> 12:00.200
对吧

12:00.200 --> 12:01.200
那原生的 Rake 上面的 Header

12:01.200 --> 12:02.200
是相同的

12:02.200 --> 12:03.200
就是一个对象

12:03.200 --> 12:06.770
好 咱们刷新一下

12:07.770 --> 12:08.770
你看 请求头

12:08.770 --> 12:09.770
对吧 就是一个对象

12:09.770 --> 12:10.770
有什么问题呢

12:10.770 --> 12:11.770
没什么问题对吧

12:11.770 --> 12:12.770
那么这里呢

12:12.770 --> 12:13.770
第二点

12:13.770 --> 12:14.770
它告诉你

12:14.770 --> 12:15.770
这个 Header 还可以复职

12:15.770 --> 12:16.770
这个写法就表示

12:16.770 --> 12:17.770
在文档里边

12:17.770 --> 12:18.770
这种写法就表示

12:18.770 --> 12:19.770
它是可以复职的

12:19.770 --> 12:22.770
给它设置一个请求头对象

12:22.770 --> 12:24.770
它为什么可以复职呢

12:24.770 --> 12:25.770
你想啊

12:25.770 --> 12:26.770
好好想一想

12:26.770 --> 12:28.770
我对请求头复职有什么意义

12:30.770 --> 12:32.770
我对请求头复职有什么意义

12:32.770 --> 12:33.770
比方说我在这里

12:33.770 --> 12:35.770
给请求头加一个

12:36.770 --> 12:38.770
Header 比方说 ABC 等于 123

12:38.770 --> 12:40.770
比方让我这样做

12:40.770 --> 12:44.210
好 这里没有

12:44.210 --> 12:45.210
点错了

12:46.210 --> 12:47.210
上映

12:48.210 --> 12:49.210
ABC加上

12:49.210 --> 12:52.210
往请求头里边加一个 ABC 123

12:52.210 --> 12:53.210
有什么意义呢

12:53.210 --> 12:54.210
好像说没有什么意义

12:54.210 --> 12:55.210
为什么呢

12:55.210 --> 12:57.210
因为请求已经到了服务器了

12:57.210 --> 12:59.210
然后服务器在运行这个代码

12:59.210 --> 13:01.210
对吧 已经到了服务器了

13:01.210 --> 13:02.210
它不会

13:02.210 --> 13:04.210
我往请求头里边加一个字段

13:04.210 --> 13:05.210
它就不会说重新发动请求

13:05.210 --> 13:06.210
跟客户说已经没关系了

13:06.210 --> 13:07.210
对吧

13:07.210 --> 13:09.210
那这个东西有什么意义呢

13:09.210 --> 13:10.210
它唯一的意义就是

13:10.210 --> 13:12.210
给后续的中间间看的

13:14.210 --> 13:15.210
比方说吧

13:15.210 --> 13:17.210
比方说我们后续的中间间

13:17.210 --> 13:18.210
举个例子

13:18.210 --> 13:19.210
我下举个例子

13:19.210 --> 13:20.210
比方说我后续的中间间

13:20.210 --> 13:21.210
要看一下

13:21.210 --> 13:23.210
它有没有就是都录过

13:23.210 --> 13:25.210
就它的Token 是不是合法的

13:25.210 --> 13:26.210
那么Token的格式呢

13:26.210 --> 13:27.210
可能有很多种

13:27.210 --> 13:29.210
比方说Token的格式

13:29.210 --> 13:30.210
第一种呢

13:30.210 --> 13:32.210
加上这个 Barrier

13:32.210 --> 13:33.210
对吧 我们是不是说过了

13:33.210 --> 13:34.210
后边是Token

13:34.210 --> 13:35.210
也可能是直接写Token

13:35.210 --> 13:36.210
对吧

13:36.210 --> 13:37.210
它格式可能有多种

13:37.210 --> 13:39.210
那么我在这里呢

13:39.210 --> 13:40.210
我就把这个格式呢

13:40.210 --> 13:41.210
给它统一

13:41.210 --> 13:42.210
无论是这一种

13:42.210 --> 13:43.210
还是这一种

13:43.210 --> 13:44.210
我都把它Token提取出来

13:44.210 --> 13:45.210
对吧

13:45.210 --> 13:46.210
我看情况

13:46.210 --> 13:47.210
如果是这一种的话

13:47.210 --> 13:48.210
我就取这一段

13:48.210 --> 13:49.210
如果是这一种的话

13:49.210 --> 13:50.210
我就直接取出来

13:50.210 --> 13:51.210
我把它放到黑打的Token里边

13:51.210 --> 13:53.210
那么后续的中间间

13:53.210 --> 13:54.210
使用的时候

13:54.210 --> 13:55.210
是不是读起来

13:55.210 --> 13:56.210
就更加方便了

13:56.210 --> 13:57.210
对不对

13:57.210 --> 13:58.210
是不是这个意思

13:58.210 --> 13:59.210
它是处于这么一个意思

13:59.210 --> 14:01.210
那么这个可以连合处理的

14:01.210 --> 14:02.210
有它可以复制的

14:02.210 --> 14:03.210
总之它可以支持的

14:03.210 --> 14:05.210
都是关于这一块

14:05.210 --> 14:07.210
好 那么这个Headers

14:07.210 --> 14:08.210
加那个复数

14:08.210 --> 14:09.210
Headers和Headers

14:09.210 --> 14:10.210
也可以复制

14:10.210 --> 14:11.210
那么这个东西呢

14:11.210 --> 14:12.210
它告诉你就是别名

14:12.210 --> 14:14.210
就跟Headers一样的

14:14.210 --> 14:15.210
没什么问题

14:15.210 --> 14:16.210
没事的不用说了吧

14:16.210 --> 14:17.210
请求方法

14:17.210 --> 14:19.210
请求方法也可以复制的

14:19.210 --> 14:20.210
那么这个请求方法

14:20.210 --> 14:21.210
为什么会复制呢

14:21.210 --> 14:22.210
一刻不端

14:22.210 --> 14:23.210
浏览器是用Gate的请求

14:23.210 --> 14:24.210
到了服务器

14:24.210 --> 14:26.210
服务器把个请求方法改了

14:26.210 --> 14:28.210
所以也是跟后续的中间间看的

14:28.210 --> 14:29.210
对不对

14:29.210 --> 14:30.210
也是跟后续的

14:30.210 --> 14:31.210
给后续的中间间看的

14:31.210 --> 14:32.210
明白了意思吗

14:32.210 --> 14:34.210
所以说它是

14:34.210 --> 14:36.210
做一些

14:36.210 --> 14:38.210
先做一些预先处理

14:38.210 --> 14:39.210
然后后续的中间间

14:39.210 --> 14:41.210
它可以进一步进行处理

14:41.210 --> 14:42.210
它是属于这么一回事

14:42.210 --> 14:43.210
不过平时呢

14:43.210 --> 14:44.210
跟我没有什么关系

14:44.210 --> 14:45.210
了解一下就可以了

14:45.210 --> 14:46.210
那意思呢

14:46.210 --> 14:47.210
就相当于是请求的时候

14:47.210 --> 14:48.210
比方说Pose的请求

14:48.210 --> 14:49.210
它的请求头里边

14:49.210 --> 14:50.210
不是个Content的那意思吗

14:50.210 --> 14:52.210
表示我的消息体力边

14:52.210 --> 14:54.210
我请求体力边

14:54.210 --> 14:56.210
它的字结束

14:56.210 --> 14:57.210
就这么个意思

14:57.210 --> 14:58.210
如果说没有的话

14:58.210 --> 14:59.210
得到了实内

14:59.210 --> 15:00.210
放低败的

15:00.210 --> 15:01.210
然后你是不是也可以

15:01.210 --> 15:02.210
从Headers里面得到

15:02.210 --> 15:03.210
对吧

15:03.210 --> 15:04.210
也可以

15:04.210 --> 15:05.210
这个UIL

15:05.210 --> 15:07.210
是获取请求的UIL

15:07.210 --> 15:08.210
那么这个UIL

15:08.210 --> 15:09.210
我们打印出来看一下

15:10.210 --> 15:11.210
City

15:11.210 --> 15:12.210
City

15:12.210 --> 15:15.210
City Request

15:16.210 --> 15:17.210
UIL

15:17.210 --> 15:18.210
把这个UIL

15:18.210 --> 15:19.210
输出来看一下

15:19.210 --> 15:20.210
我们在前面写一个

15:20.210 --> 15:23.210
因为它有几个得到的路径

15:24.210 --> 15:25.210
这个不要了

15:25.210 --> 15:27.780
不要了

15:28.780 --> 15:29.780
好

15:29.780 --> 15:30.780
保存

15:31.780 --> 15:32.780
好

15:32.780 --> 15:33.780
这边刷新

15:33.780 --> 15:34.780
比方说我们请求这样的地址

15:34.780 --> 15:36.780
A,B,C

15:36.780 --> 15:38.780
A等于

15:38.780 --> 15:39.780
B

15:39.780 --> 15:40.780
B等于

15:40.780 --> 15:41.780
2

15:41.780 --> 15:42.780
跟个哈希吗

15:42.780 --> 15:43.780
好

15:43.780 --> 15:44.780
回头

15:44.780 --> 15:45.780
那么这边得到的UIL

15:45.780 --> 15:46.780
是什么的

15:46.780 --> 15:47.780
是不是纸包函是吗

15:47.780 --> 15:48.780
PASS

15:48.780 --> 15:49.780
对吧

15:49.780 --> 15:50.780
是不是我们刷新一次

15:50.780 --> 15:51.780
再刷新一次

15:51.780 --> 15:52.780
是不是纸包函PASS

15:52.780 --> 15:53.780
和什么的

15:53.780 --> 15:54.780
和它的search

15:54.780 --> 15:55.780
对吧

15:55.780 --> 15:56.780
query

15:56.780 --> 15:57.780
是不是纸包函这一部分

15:57.780 --> 15:58.780
这是UIL

15:58.780 --> 15:59.780
厉害这个意思

15:59.780 --> 16:00.780
好

16:00.780 --> 16:01.780
那么接下来

16:01.780 --> 16:02.780
UIL是不是也可以复制

16:02.780 --> 16:03.780
对不对

16:03.780 --> 16:05.780
它可以实现UIL重写

16:05.780 --> 16:06.780
也可以复制

16:06.780 --> 16:07.780
那么这个东西跟我们

16:07.780 --> 16:08.780
也没多大关系

16:08.780 --> 16:10.780
有的时候有点用处

16:10.780 --> 16:12.780
OrangeUIL

16:12.780 --> 16:13.780
那么这个是原始UIL

16:13.780 --> 16:14.780
那啥意思呢

16:14.780 --> 16:15.780
怎么叫原始UIL呢

16:15.780 --> 16:17.780
我们来打印出来

16:17.780 --> 16:19.780
比方说这里是

16:19.780 --> 16:21.780
OrangeUIL

16:21.780 --> 16:22.780
那么这个地方

16:22.780 --> 16:23.780
我们写上

16:23.780 --> 16:24.780
OrangeUIL

16:24.780 --> 16:25.780
好

16:25.780 --> 16:26.780
保存

16:26.780 --> 16:30.240
这边刷新

16:31.240 --> 16:32.240
这边来看

16:32.240 --> 16:33.240
OrangeUIL

16:33.240 --> 16:34.240
你看上去

16:34.240 --> 16:35.240
现在这个UIL

16:35.240 --> 16:36.240
跟这个UIL是不是一样的

16:36.240 --> 16:38.240
好像是没有什么区别

16:38.240 --> 16:40.240
那么它们的区别在哪呢

16:40.240 --> 16:41.240
它们区别在这

16:41.240 --> 16:42.240
因为这个UIL

16:42.240 --> 16:43.240
是可以重新复制的

16:43.240 --> 16:45.240
是可以重新复制的

16:45.240 --> 16:46.240
方便在后

16:46.240 --> 16:48.240
可能这个重新复制过后

16:48.240 --> 16:49.240
是不是对后续的中间线

16:49.240 --> 16:50.240
会造成影响

16:50.240 --> 16:51.240
对不对

16:51.240 --> 16:52.240
是不是会造成影响

16:52.240 --> 16:53.240
比方说最简单的例子

16:53.240 --> 16:54.240
就是什么呢

16:54.240 --> 16:56.240
就是我们的单硬应用程序

16:56.240 --> 16:57.240
单硬应用程序里边

16:57.240 --> 16:58.240
我们请求任何路径

16:58.240 --> 16:59.240
是不是都要把它回

16:59.240 --> 17:01.240
都要把它理解为

17:01.240 --> 17:02.240
请求的是index

17:02.240 --> 17:03.240
对吧

17:03.240 --> 17:04.240
请求的是以同一个页面

17:04.240 --> 17:05.240
那么这个时候

17:05.240 --> 17:06.240
什么是我们在服务器端

17:06.240 --> 17:08.240
比方说我们请求的是

17:08.240 --> 17:09.240
这样的页面

17:09.240 --> 17:10.240
请求的是什么呢

17:10.240 --> 17:12.240
UIL本来是请求的是

17:14.240 --> 17:15.240
index

17:16.240 --> 17:18.240
本来是请求的是这个路径

17:18.240 --> 17:19.240
但是呢

17:19.240 --> 17:20.240
我们在这里

17:20.240 --> 17:21.240
可以给一个UIL复制

17:21.240 --> 17:22.240
它重新复制为什么呢

17:22.240 --> 17:24.240
复制为跟路径

17:24.240 --> 17:25.240
你看这个

17:25.240 --> 17:26.240
是不是重新复制为跟路径

17:26.240 --> 17:27.240
那么后续的中间

17:27.240 --> 17:28.240
它就会按照

17:28.240 --> 17:30.240
你请求的是跟路径来进行处理

17:30.240 --> 17:31.240
对吧

17:31.240 --> 17:32.240
跟客户关系没有什么关系的

17:32.240 --> 17:34.240
这就是UIL重新

17:34.240 --> 17:36.240
那么比方说我们去做了这么一件事

17:36.240 --> 17:38.240
接下来我们来刷新

17:38.240 --> 17:39.240
刷新过后了

17:39.240 --> 17:40.240
我们看这边

17:40.240 --> 17:41.240
UIL是不是被改动了

17:41.240 --> 17:42.240
对吧

17:42.240 --> 17:44.240
那么Original

17:44.240 --> 17:45.240
就是原始的UIL

17:45.240 --> 17:46.240
是不是还是被动

17:46.240 --> 17:47.240
那么也就是说

17:47.240 --> 17:48.240
这个东西它是不受影响的

17:48.240 --> 17:50.240
这个玩意离去测试就明白了

17:51.240 --> 17:52.240
所以说

17:52.240 --> 17:53.240
重点在哪

17:53.240 --> 17:54.240
你们学程序

17:54.240 --> 17:55.240
重点在于理解

17:55.240 --> 17:56.240
你看我

17:56.240 --> 17:58.240
如果说我理解这些东西

17:58.240 --> 18:00.240
我不用去

18:00.240 --> 18:01.240
我不用

18:01.240 --> 18:02.240
我就没有必要

18:02.240 --> 18:04.240
我在这里就不会产生困扰

18:04.240 --> 18:06.240
因为我理解它到底是怎么回事的

18:06.240 --> 18:08.240
这个不是说我熟悉这些API

18:08.240 --> 18:09.240
这些API我都不熟悉

18:09.240 --> 18:10.240
说实话

18:10.240 --> 18:11.240
我要看这文档我才知道

18:11.240 --> 18:12.240
那么

18:12.240 --> 18:14.240
但是我看文档是没有任何障碍的

18:14.240 --> 18:15.240
因为我知道它的原理

18:15.240 --> 18:17.240
我知道它背后的东西

18:18.240 --> 18:19.240
这个Original

18:19.240 --> 18:20.240
Original就得到

18:20.240 --> 18:21.240
就是UIL的来源

18:21.240 --> 18:23.240
它告诉你它包含什么

18:23.240 --> 18:24.240
Protocol Host

18:24.240 --> 18:25.240
那我们试一下就知道了

18:26.240 --> 18:27.240
我们这里说出

18:27.240 --> 18:29.240
Original

18:33.620 --> 18:34.620
Original

18:34.620 --> 18:35.620
City

18:35.620 --> 18:36.620
City is Request

18:37.620 --> 18:38.620
Original

18:42.210 --> 18:43.210
这里我们刷新

18:44.210 --> 18:45.210
刷新

18:45.210 --> 18:46.210
你看这边

18:46.210 --> 18:47.210
Original

18:47.210 --> 18:48.210
它就是协议

18:48.210 --> 18:49.210
Protocol

18:49.210 --> 18:50.210
协议

18:50.210 --> 18:51.210
Host

18:51.210 --> 18:52.210
主机

18:52.210 --> 18:53.210
还加上端口号

18:53.210 --> 18:54.210
它这里没有说端口号

18:54.210 --> 18:55.210
它实际上是有包含端口号的

18:55.210 --> 18:56.210
这是Original

18:56.210 --> 18:57.210
Ref

18:57.210 --> 18:58.210
完整的UIL

18:58.210 --> 18:59.210
那么我们来看一下

18:59.210 --> 19:00.210
Ref是有市场

19:00.210 --> 19:01.210
输出

19:01.210 --> 19:02.210
Ref

19:02.210 --> 19:03.210
那么一看到有些属性

19:03.210 --> 19:04.210
它是不能复制的

19:04.210 --> 19:05.210
你看这些东西

19:05.210 --> 19:06.210
不是不能复制的

19:06.210 --> 19:08.210
能复制的还会给你写个等

19:09.210 --> 19:10.210
那么这里我们就看

19:10.210 --> 19:11.210
City is Request

19:11.210 --> 19:12.210
这些东西你要去背

19:12.210 --> 19:13.210
你怎么背得住

19:15.210 --> 19:16.210
好 这边

19:16.210 --> 19:17.210
刷新

19:17.210 --> 19:18.210
你看这边

19:18.210 --> 19:19.210
Ref是不是有完整的

19:19.210 --> 19:20.210
对吧

19:20.210 --> 19:21.210
就是完整的

19:21.210 --> 19:22.210
没问题吧

19:22.210 --> 19:23.210
就没问题

19:24.210 --> 19:25.210
这是Ref

19:26.210 --> 19:27.210
接下来我们看一下

19:27.210 --> 19:28.210
PASS

19:28.210 --> 19:29.210
PASS就是请求路径名

19:29.210 --> 19:30.210
它只包含路径

19:31.210 --> 19:32.210
PASS

19:33.210 --> 19:34.210
City is Request

19:34.210 --> 19:35.210
PASS

19:36.210 --> 19:37.210
PASS也是可以

19:37.210 --> 19:38.210
被重新复制的

19:39.210 --> 19:42.030
这边

19:44.030 --> 19:45.030
我们看这边

19:45.030 --> 19:46.030
PASS

19:46.030 --> 19:47.030
PASS是有一个写的

19:47.030 --> 19:48.030
你看我们对UIL重新复制

19:48.030 --> 19:49.030
是不是会影响到PASS

19:49.030 --> 19:50.030
对不对

19:50.030 --> 19:51.030
它会影响到

19:51.030 --> 19:52.030
它们始终是保持了统一的

19:52.030 --> 19:53.030
你看UIL变了

19:53.030 --> 19:54.030
PASS也能变

19:54.030 --> 19:56.030
但是这个东西是不是没变

19:56.030 --> 19:57.030
对不对

19:57.030 --> 19:58.030
这是

19:58.030 --> 19:59.030
这个东西和这个东西

19:59.030 --> 20:00.030
是不是没变

20:01.030 --> 20:02.030
好 接下来我们再看看

20:03.030 --> 20:04.030
这边

20:06.600 --> 20:07.600
PASS

20:08.600 --> 20:09.600
原始字无创

20:09.600 --> 20:10.600
查询字无创

20:11.600 --> 20:12.600
输出

20:13.600 --> 20:14.600
City is Request

20:15.600 --> 20:16.600
PASS

20:16.600 --> 20:17.600
后边还有一个

20:17.600 --> 20:18.600
后边还有一个

20:19.600 --> 20:20.600
这两个也是可以复制的

20:20.600 --> 20:21.600
还有一个

20:22.600 --> 20:25.620
这边会写上

20:26.620 --> 20:27.620
看一下就明白了

20:27.620 --> 20:28.620
这东西一打印就明白了

20:30.620 --> 20:31.620
也不用去计

20:32.620 --> 20:33.620
刷新

20:33.620 --> 20:34.620
你看

20:34.620 --> 20:36.620
Karis军没有了

20:36.620 --> 20:39.620
我把UIL重写了

20:39.620 --> 20:40.620
重写了它当然没有了

20:41.620 --> 20:42.620
刷新

20:43.620 --> 20:47.180
刷新过后我们来看一下这边

20:47.180 --> 20:49.180
这边我们得到的结果是

20:50.180 --> 20:52.180
Karis军是这个

20:52.180 --> 20:53.180
City是这个

20:53.180 --> 20:54.180
也就是一个代问号

20:54.180 --> 20:55.180
一个不代问号

20:55.180 --> 20:56.180
就完事了

20:56.180 --> 20:57.180
下一个

20:57.180 --> 20:59.180
下一个是

20:59.180 --> 21:00.180
host的主机名

21:00.180 --> 21:02.180
主机和hostname

21:02.180 --> 21:03.180
主机名

21:03.180 --> 21:04.180
再看

21:05.180 --> 21:06.180
主机host

21:08.180 --> 21:09.180
hostname

21:10.180 --> 21:11.180
和主机名

21:14.780 --> 21:15.780
hostname

21:15.780 --> 21:16.780
好了

21:17.780 --> 21:18.780
刷新一下

21:19.780 --> 21:20.780
host

21:20.780 --> 21:21.780
包含短口

21:21.780 --> 21:22.780
hostname

21:22.780 --> 21:23.780
不包含短口

21:23.780 --> 21:25.780
你们需要的时候就去处理

21:25.780 --> 21:27.780
这个UIL

21:27.780 --> 21:29.780
解析UIL对象

21:29.780 --> 21:30.780
如果说你需要的话

21:30.780 --> 21:32.780
那么可以看一下吧

21:33.780 --> 21:35.780
它就是把一个UIL给解析出来

21:35.780 --> 21:36.780
大小的UIL

21:37.780 --> 21:38.780
Request

21:38.780 --> 21:39.780
UIL

21:39.780 --> 21:40.780
因为我们知道load解释里面

21:40.780 --> 21:41.780
有个类似模块

21:41.780 --> 21:42.780
对吧

21:42.780 --> 21:43.780
还可以解析UIL

21:43.780 --> 21:44.780
刷新

21:44.780 --> 21:45.780
可以看一下

21:45.780 --> 21:46.780
UIL是不是出来了

21:47.780 --> 21:48.780
看到这了

21:48.780 --> 21:50.780
其实有些同学就疑问了

21:50.780 --> 21:52.780
就是为什么我这里没有哈希

21:52.780 --> 21:53.780
你看我这里都写了哈希

21:53.780 --> 21:55.780
那这里为什么没有哈希呢

21:57.780 --> 21:58.780
为什么呢

21:59.780 --> 22:01.780
因为浏览器

22:01.780 --> 22:03.780
亚克就没有把哈希发送到服务器

22:03.780 --> 22:05.780
不能怪服务器了

22:05.780 --> 22:07.780
服务器那边那肯定是抽不到的

22:07.780 --> 22:08.780
刷新看一下吧

22:08.780 --> 22:09.780
这里是浏览器的请求

22:09.780 --> 22:11.780
你看有没有把哈希请求过去

22:11.780 --> 22:12.780
没有

22:12.780 --> 22:13.780
因为浏览器他认为

22:13.780 --> 22:14.780
哈希这个东西

22:14.780 --> 22:16.780
本来就是做毛链接的

22:16.780 --> 22:18.780
无刷新跳出来

22:18.780 --> 22:19.780
因此

22:19.780 --> 22:20.780
就是浏览器处理的

22:20.780 --> 22:21.780
跟服务器没有什么关系

22:21.780 --> 22:23.780
因此没有把哈希发送到服务器

22:23.780 --> 22:24.780
但是

22:24.780 --> 22:26.780
这并不代表说

22:26.780 --> 22:27.780
它不能有哈希

22:27.780 --> 22:28.780
URIO地址里面

22:28.780 --> 22:29.780
服务器不能获取哈希

22:29.780 --> 22:30.780
它是能获取哈希的

22:30.780 --> 22:31.780
只要你能把发过去

22:31.780 --> 22:32.780
但是呢

22:32.780 --> 22:33.780
绝大部分客户端

22:33.780 --> 22:34.780
不管是浏览器

22:34.780 --> 22:35.780
还是别的客户端也好

22:35.780 --> 22:37.780
它都不会给你发送哈希的

22:37.780 --> 22:38.780
这是一些

22:38.780 --> 22:40.780
这是我们这个行业里面

22:40.780 --> 22:41.780
普遍的规范

22:41.780 --> 22:42.780
规则

22:42.780 --> 22:44.780
它只是没有给你发送的哈希

22:44.780 --> 22:45.780
好 这是关于这一块

22:46.780 --> 22:47.780
好 进去看

22:47.780 --> 22:48.780
这是URIO

22:48.780 --> 22:49.780
然后呢

22:49.780 --> 22:50.780
后面还要去

22:50.780 --> 22:51.780
要不要去

22:51.780 --> 22:52.780
我们来看一下吧

22:52.780 --> 22:53.780
Type就相当于说

22:53.780 --> 22:54.780
获取什么呢

22:54.780 --> 22:55.780
获取content type

22:55.780 --> 22:56.780
它不包含charset

22:56.780 --> 22:57.780
这有怎么解释呢

22:57.780 --> 22:58.780
这有假解释呢

22:58.780 --> 23:00.780
因为我们知道content type里边

23:00.780 --> 23:01.780
就请求

23:01.780 --> 23:03.780
请求里面的content type是啥意思

23:04.780 --> 23:06.780
所以标识的是请求体的东西

23:07.780 --> 23:08.780
对不对

23:08.780 --> 23:09.780
标识的是请求体

23:09.780 --> 23:10.780
到底是一个什么玩意儿

23:10.780 --> 23:11.780
是一个接上

23:11.780 --> 23:13.780
还是一个文件

23:13.780 --> 23:14.780
还是一个什么玩意儿

23:15.780 --> 23:16.780
那么这个东西呢

23:16.780 --> 23:17.780
它一般有的时候呢

23:17.780 --> 23:19.780
请求content type后面

23:19.780 --> 23:20.780
会跟一个charset

23:20.780 --> 23:21.780
它的可能格式是这样子的

23:22.780 --> 23:24.780
它的格式可能是这样子的

23:25.780 --> 23:26.780
随便找个地方写

23:29.920 --> 23:30.920
随便找个地方写

23:31.920 --> 23:32.920
它的格式可能是这样子

23:33.920 --> 23:34.920
就是

23:35.920 --> 23:37.920
content type

23:37.920 --> 23:39.920
比方说application

23:39.920 --> 23:40.920
接上

23:40.920 --> 23:41.920
它告诉你

23:41.920 --> 23:42.920
我的请求消息体里边

23:42.920 --> 23:43.920
是一个接上格式

23:43.920 --> 23:45.920
后面它跟上一个charset

23:45.920 --> 23:46.920
UTF-8

23:46.920 --> 23:48.920
制服编码是UTF-8

23:48.920 --> 23:49.920
它可能会这样子写

23:49.920 --> 23:50.920
那么这个地方呢

23:50.920 --> 23:51.920
获取的是什么呢

23:51.920 --> 23:52.920
获取的就是

23:52.920 --> 23:54.920
application接上的一段

23:54.920 --> 23:55.920
就这么个意思

23:56.920 --> 23:57.920
是这样子的

23:57.920 --> 23:58.920
charset

23:58.920 --> 23:59.920
它就获取的是什么呢

23:59.920 --> 24:00.920
获取的是这一段

24:01.920 --> 24:02.920
这是这一段

24:02.920 --> 24:03.920
query

24:03.920 --> 24:04.920
query是什么

24:04.920 --> 24:05.920
就是把这个sort

24:05.920 --> 24:06.920
就是把这个查询支付刷

24:06.920 --> 24:07.920
解成什么

24:07.920 --> 24:08.920
解成对象

24:08.920 --> 24:09.920
没有

24:09.920 --> 24:11.920
query是可以重新复制的

24:11.920 --> 24:12.920
重新复制会对

24:12.920 --> 24:14.920
后续的熔炼键造成影响

24:15.920 --> 24:16.920
refresh这些东西

24:16.920 --> 24:18.920
是跟那个缓存有关的

24:18.920 --> 24:19.920
还有什么呢

24:19.920 --> 24:20.920
还有IP

24:20.920 --> 24:22.920
可以获取请求的IP地址

24:23.920 --> 24:24.920
还有什么呢

24:24.920 --> 24:25.920
跟我们没啥关系了

24:25.920 --> 24:26.920
没啥关系了

24:26.920 --> 24:27.920
没啥关系了

24:29.920 --> 24:30.920
这东西我倒知道是咋了

24:30.920 --> 24:32.920
但是这些东西跟我们没啥关系了

24:33.920 --> 24:34.920
好了这是请求

24:34.920 --> 24:36.920
好再看我们再看想用

24:36.920 --> 24:37.920
想用

24:37.920 --> 24:38.920
想用的头

24:38.920 --> 24:39.920
对吧

24:39.920 --> 24:40.920
设置想用头

24:41.920 --> 24:42.920
想用header时段

24:42.920 --> 24:43.920
header的别名

24:43.920 --> 24:45.920
这里可以设置想用头

24:45.920 --> 24:46.920
对不对

24:46.920 --> 24:47.920
socket

24:47.920 --> 24:48.920
这个东西我们用不到

24:48.920 --> 24:49.920
standards就状态

24:49.920 --> 24:50.920
想用状态

24:50.920 --> 24:52.920
它这里告诉你

24:52.920 --> 24:53.920
默认情况下

24:54.920 --> 24:57.920
它会把想用状态码设为404

24:58.920 --> 24:59.920
而不是凉拌

24:59.920 --> 25:01.920
你像expressor是凉拌对不对

25:01.920 --> 25:03.920
它找不到才会给你设置404

25:03.920 --> 25:05.920
那么这里的默认就是404

25:05.920 --> 25:06.920
所以说我们这里的

25:06.920 --> 25:08.920
由于没有改动这个想用码

25:08.920 --> 25:10.920
所以说它默认就是404

25:10.920 --> 25:11.920
404想用码过来过后呢

25:11.920 --> 25:13.920
这里自然得到的是404

25:14.920 --> 25:15.920
那么同样

25:15.920 --> 25:16.920
那么说明啥呢

25:16.920 --> 25:18.920
说明是不是我们可以设置想用码

25:18.920 --> 25:19.920
比方说

25:20.920 --> 25:21.920
我们来下面

25:21.920 --> 25:22.920
去设置一下这个想用码

25:23.920 --> 25:25.920
ctx response

25:25.920 --> 25:26.920
standards

25:28.920 --> 25:29.920
response

25:30.920 --> 25:31.920
standards

25:31.920 --> 25:32.920
等于凉拌

25:32.920 --> 25:33.920
对吧 完成了

25:33.920 --> 25:34.920
好 保存

25:34.920 --> 25:35.920
刷新

25:35.920 --> 25:36.920
你看不就ok了吗

25:36.920 --> 25:38.920
对吧 不是凉拌了吗

25:38.920 --> 25:39.920
凉拌

25:39.920 --> 25:41.920
它默认的消息体是ok

25:41.920 --> 25:42.920
ok

25:42.920 --> 25:43.920
这是这个响应码

25:44.920 --> 25:45.920
然后我们再看

25:45.920 --> 25:46.920
这个响应码是不是可以设置的

25:46.920 --> 25:47.920
对不对

25:47.920 --> 25:49.920
你看它这里给你列举的一些响应码

25:49.920 --> 25:51.920
这个响应码是ka的东西

25:51.920 --> 25:52.920
还是adp的东西

25:53.920 --> 25:54.920
肯定是adp的东西

25:54.920 --> 25:56.920
对吧 它这只给你列在这里

25:56.920 --> 25:57.920
对吧

25:58.920 --> 26:00.920
它说你不用太在意

26:00.920 --> 26:01.920
记住这些字幕刷

26:01.920 --> 26:02.920
这些字幕刷你不用去记

26:02.920 --> 26:03.920
不用去记的

26:03.920 --> 26:05.920
那么它会给你自行更正

26:05.920 --> 26:07.920
就是根据你的响应码

26:07.920 --> 26:08.920
会自行设置

26:08.920 --> 26:10.920
它的默认响应码是404

26:12.920 --> 26:13.920
那么这个时候呢

26:13.920 --> 26:14.920
我们接下来

26:14.920 --> 26:15.920
接下来我下看

26:15.920 --> 26:16.920
message是什么呢

26:17.920 --> 26:18.920
就是

26:18.920 --> 26:20.920
获取响应的状态消息

26:20.920 --> 26:23.920
比方说那个404的响应码

26:23.920 --> 26:24.920
应该是啥

26:24.920 --> 26:25.920
404的响应的消息

26:25.920 --> 26:26.920
应该是not found

26:26.920 --> 26:27.920
对不对

26:27.920 --> 26:29.920
你看我们的响应

26:29.920 --> 26:31.920
haters response

26:31.920 --> 26:32.920
200是不是ok

26:32.920 --> 26:33.920
那么200的ok

26:33.920 --> 26:35.920
如果说把message再重新设置一下

26:35.920 --> 26:36.920
response

26:38.920 --> 26:39.920
这个message

26:39.920 --> 26:40.920
我们一般也不去设他

26:40.920 --> 26:41.920
随便设一下

26:41.920 --> 26:42.920
保存

26:42.920 --> 26:43.920
你看一下

26:43.920 --> 26:44.920
刷新

26:45.920 --> 26:46.920
得到的是什么

26:46.920 --> 26:47.920
response

26:47.920 --> 26:48.920
response

26:50.920 --> 26:51.920
得到的是

26:51.920 --> 26:52.920
变这个玩意了

26:52.920 --> 26:53.920
对吧

26:53.920 --> 26:54.920
变这个玩意了

26:54.920 --> 26:56.920
我们一般不用去设置他

26:56.920 --> 26:57.920
message

26:57.920 --> 26:58.920
那么下面

26:58.920 --> 27:00.920
而且消息体他也会

27:00.920 --> 27:02.920
他也会给你更改成这个东西

27:02.920 --> 27:03.920
这样我想想看

27:03.920 --> 27:05.920
lens就是设置响应的消息

27:05.920 --> 27:06.920
containlens

27:06.920 --> 27:08.920
这个我们也不用一般不去设置

27:08.920 --> 27:09.920
关键是下面这个

27:09.920 --> 27:10.920
body

27:11.920 --> 27:12.920
我们现在知道了

27:12.920 --> 27:13.920
怎么去设置响应头

27:13.920 --> 27:14.920
我们也知道了

27:14.920 --> 27:15.920
怎么去设置响应体

27:16.920 --> 27:18.920
就是响应码

27:18.920 --> 27:19.920
现在我们关键是响应体

27:19.920 --> 27:20.920
怎么设置

27:20.920 --> 27:21.920
响应体就是给body负质

27:21.920 --> 27:22.920
负质就完事了

27:23.920 --> 27:24.920
他可以负什么质呢

27:24.920 --> 27:25.920
可以负字不串

27:25.920 --> 27:26.920
看得清楚吗

27:26.920 --> 27:28.920
他可以负质字不串

27:28.920 --> 27:29.920
可以负质buffer

27:29.920 --> 27:30.920
可以负质stream

27:30.920 --> 27:31.920
给他一个管道

27:31.920 --> 27:32.920
可以负质

27:32.920 --> 27:33.920
比方说文件

27:33.920 --> 27:34.920
文件是不是可以

27:34.920 --> 27:35.920
把这个stream给他负质过去

27:35.920 --> 27:36.920
那么他就会

27:36.920 --> 27:37.920
把这个文件留

27:37.920 --> 27:38.920
写入到客户中

27:38.920 --> 27:39.920
可以给他负质

27:39.920 --> 27:40.920
为一个对象

27:40.920 --> 27:42.920
一个质不串

27:42.920 --> 27:43.920
那么他就会

27:43.920 --> 27:44.920
把自动转发成接设

27:44.920 --> 27:45.920
可以给他负质为

27:45.920 --> 27:46.920
无响应内容

27:47.920 --> 27:48.920
那么他这里给你说了

27:48.920 --> 27:49.920
你对个body负质的时候

27:49.920 --> 27:50.920
就相当于是

27:50.920 --> 27:51.920
设置响应体

27:51.920 --> 27:55.920
cts response body

27:55.920 --> 27:56.920
比方说

27:56.920 --> 27:58.920
我们在里干设置一个

27:58.920 --> 27:59.920
设置个最完

28:02.920 --> 28:03.920
为什么没有智能提升

28:03.920 --> 28:04.920
没有智能提升

28:04.920 --> 28:05.920
我就比较这样吧

28:06.920 --> 28:07.920
设置个对象

28:07.920 --> 28:09.920
比方说

28:09.920 --> 28:10.920
AtoEB等于

28:10.920 --> 28:11.920
随便给他下写一个

28:11.920 --> 28:12.920
保存

28:12.920 --> 28:14.920
咱们在设里边刷新一下

28:14.920 --> 28:15.920
你看这里

28:15.920 --> 28:16.920
是不是得到一个节省格式

28:17.920 --> 28:18.920
而他自为自动给你

28:18.920 --> 28:19.920
设置一个content type

28:19.920 --> 28:20.920
为什么

28:20.920 --> 28:21.920
application接设

28:21.920 --> 28:22.920
自动给你设置

28:23.920 --> 28:24.920
然后我们看一下消息题

28:24.920 --> 28:25.920
消息题就是一个

28:25.920 --> 28:26.920
节省格式的支部串

28:27.920 --> 28:28.920
因此这个东西就相当于是什么

28:28.920 --> 28:30.920
相当于是express的send

28:30.920 --> 28:31.920
send函数

28:31.920 --> 28:32.920
发送消息

28:33.920 --> 28:34.920
而且他这里下面会告诉你

28:34.920 --> 28:35.920
下面会告诉你

28:36.920 --> 28:37.920
如果说

28:37.920 --> 28:38.920
你这个status

28:38.920 --> 28:39.920
未被设置

28:39.920 --> 28:41.920
就是没有设置个响应

28:41.920 --> 28:43.920
那么当你去设置body的时候

28:43.920 --> 28:44.920
KoA

28:44.920 --> 28:45.920
他会自动设置为200

28:46.920 --> 28:47.920
或者204

28:47.920 --> 28:48.920
啥意思

28:48.920 --> 28:49.920
就这个响应码本来是404的

28:49.920 --> 28:50.920
对吧

28:50.920 --> 28:51.920
默认是404

28:51.920 --> 28:53.920
但是如果说你只要给body一副值

28:53.920 --> 28:54.920
一副值过后

28:54.920 --> 28:55.920
你看这边

28:56.920 --> 28:57.920
副值过后

28:57.920 --> 28:59.920
他就会变成自动会变成两半

29:00.920 --> 29:01.920
那么什么时候变成204呢

29:01.920 --> 29:02.920
大家知道

29:02.920 --> 29:04.920
204是一个很古老的状态码了

29:04.920 --> 29:05.920
现在基本上没这么用了

29:05.920 --> 29:06.920
就是以前

29:06.920 --> 29:08.920
不是前后端分底的

29:08.920 --> 29:10.920
是用服系渲染的

29:10.920 --> 29:11.920
那么那个时候

29:11.920 --> 29:12.920
就是有的时候提交表单

29:12.920 --> 29:14.920
从一个地址提交到另一个地址

29:14.920 --> 29:15.920
另一个地址

29:15.920 --> 29:16.920
这个表单过后

29:16.920 --> 29:17.920
他可以不给这个响应题

29:17.920 --> 29:18.920
让浏览器

29:18.920 --> 29:19.920
不要挑的那个页面

29:20.920 --> 29:21.920
啥意思呢

29:21.920 --> 29:22.920
这东西有没有必要说一下

29:22.920 --> 29:23.920
说一下吧

29:23.920 --> 29:24.920
很古老啊

29:24.920 --> 29:25.920
你现在跟你没什么关系了

29:25.920 --> 29:27.920
就是204这个小型码是这样子

29:27.920 --> 29:28.920
比方说客户端

29:28.920 --> 29:29.920
我在这边写吧

29:38.940 --> 29:39.940
在这边写

29:39.940 --> 29:40.940
比方说客户端

29:40.940 --> 29:43.940
他的在这个页面

29:44.940 --> 29:45.940
在这个页面

29:45.940 --> 29:46.940
有一个表单

29:47.940 --> 29:48.940
一个表单

29:48.940 --> 29:50.940
页面有个表单

29:51.940 --> 29:52.940
这是古老的做法

29:52.940 --> 29:53.940
现在都是用阿迦克斯提交了

29:53.940 --> 29:54.940
对吧

29:54.940 --> 29:55.940
那么以前是一个风母表单

29:55.940 --> 29:56.940
风母提交

29:56.940 --> 29:57.940
风母的x 地址呢

29:57.940 --> 29:58.940
是这个地址

29:59.940 --> 30:00.940
提交的地址呢

30:00.940 --> 30:01.940
是这个

30:01.940 --> 30:02.940
它是跟浏览器的行为相关的

30:02.940 --> 30:03.940
比方登陆

30:03.940 --> 30:04.940
网址

30:04.940 --> 30:06.940
好那么一点提交

30:06.940 --> 30:08.940
它是不是会发生一个请求

30:08.940 --> 30:09.940
不要说Pose的请求

30:09.940 --> 30:10.940
到哪呢

30:10.940 --> 30:11.940
到了网址这个地址

30:11.940 --> 30:12.940
对不对

30:12.940 --> 30:13.940
到服系的网址地址

30:13.940 --> 30:14.940
那么服系

30:14.940 --> 30:15.940
如果说是按照正常的响应

30:15.940 --> 30:16.940
给他一个什么呢

30:16.940 --> 30:17.940
给他一个200

30:17.940 --> 30:18.940
ok的响应

30:18.940 --> 30:19.940
然后呢

30:19.940 --> 30:20.940
没有消息体

30:21.940 --> 30:23.940
那么浏览器会怎么样呢

30:23.940 --> 30:24.940
浏览器会挑转到

30:24.940 --> 30:25.940
这个挪柄的地址

30:25.940 --> 30:26.940
对不对

30:26.940 --> 30:27.940
是不是会挑转到

30:27.940 --> 30:28.940
挪柄的地址

30:28.940 --> 30:29.940
然后呢

30:29.940 --> 30:30.940
把这个响应体

30:30.940 --> 30:31.940
渲染出来

30:31.940 --> 30:32.940
响应体没有

30:32.940 --> 30:33.940
那是浏览器

30:33.940 --> 30:34.940
页面就是空的

30:34.940 --> 30:35.940
于是用户看到的就是

30:35.940 --> 30:36.940
什么呢

30:36.940 --> 30:37.940
有个表单

30:37.940 --> 30:38.940
我点击提交过后了

30:38.940 --> 30:39.940
一个白板

30:39.940 --> 30:40.940
啥都没有

30:40.940 --> 30:41.940
但是登陆已经成功了

30:41.940 --> 30:42.940
啥都没有

30:42.940 --> 30:43.940
看不到东西

30:43.940 --> 30:44.940
那么跟204是什么意思呢

30:44.940 --> 30:45.940
如果说看反回204

30:45.940 --> 30:46.940
浏览器

30:46.940 --> 30:47.940
一看到204的状态

30:47.940 --> 30:48.940
就是

30:48.940 --> 30:49.940
服系那边处理完了

30:49.940 --> 30:50.940
没有响应体

30:50.940 --> 30:52.940
没有响应体的时候

30:52.940 --> 30:53.940
那浏览器

30:53.940 --> 30:54.940
它就会保持这个

30:54.940 --> 30:55.940
液面不动

30:55.940 --> 30:56.940
不动

30:56.940 --> 30:57.940
之前是因这个事

30:57.940 --> 30:58.940
还是这个东西

30:58.940 --> 31:00.940
这里还是因这个事

31:00.940 --> 31:02.940
就这么个意思

31:02.940 --> 31:03.940
以前的用法

31:03.940 --> 31:05.940
现在没什么意义了

31:05.940 --> 31:06.940
以前我们给body

31:06.940 --> 31:07.940
复制的时候

31:07.940 --> 31:08.940
会自动去更改

31:08.940 --> 31:09.940
如果说你没有改动

31:09.940 --> 31:10.940
它的话

31:10.940 --> 31:11.940
会自动去更改

31:11.940 --> 31:12.940
这个standards

31:12.940 --> 31:14.940
都是这一块

31:14.940 --> 31:16.940
还有什么呢

31:16.940 --> 31:17.940
还有什么

31:17.940 --> 31:19.940
好像就没啥了

31:19.940 --> 31:21.940
而是跟那个响应头相关的

31:21.940 --> 31:23.940
看一下有没有得到一个响应头

31:23.940 --> 31:25.940
根据个响应头的名字

31:25.940 --> 31:26.940
得到一个响应头

31:26.940 --> 31:27.940
是不是有一个响应头里边

31:27.940 --> 31:28.940
是不是有一个字段

31:28.940 --> 31:29.940
有没有这个字段

31:29.940 --> 31:30.940
设置一个响应头

31:30.940 --> 31:31.940
当然也可以用

31:31.940 --> 31:32.940
上面那种方式

31:32.940 --> 31:33.940
它的方式有很多

31:33.940 --> 31:35.940
还有什么呢

31:35.940 --> 31:37.940
type是就设置content type

31:37.940 --> 31:39.940
这个人一般不用去手动设置

31:39.940 --> 31:40.940
一般不用去手动设置

31:40.940 --> 31:41.940
他让他帮你完成就完成

31:41.940 --> 31:42.940
redirector

31:42.940 --> 31:43.940
它就会就是一个简化版本

31:43.940 --> 31:45.940
它说自动把那个响应码

31:45.940 --> 31:47.940
那变成302

31:47.940 --> 31:49.940
然后呢

31:49.940 --> 31:51.940
挑转到指定的

31:51.940 --> 31:53.940
挑转到指定的地址

31:53.940 --> 31:55.940
明白这个意思吧

31:55.940 --> 31:57.940
当然那如果说

31:57.940 --> 31:58.940
你要用301的话

31:58.940 --> 31:59.940
你可以自己自行更改

31:59.940 --> 32:00.940
对不对

32:00.940 --> 32:03.940
这些都是attachment

32:03.940 --> 32:04.940
是不是添加附件

32:04.940 --> 32:06.940
跟那个express里边是一样的

32:06.940 --> 32:08.940
添加一个附件

32:08.940 --> 32:10.940
主要是用于下载文件的

32:10.940 --> 32:11.940
对吧

32:11.940 --> 32:12.940
那么这个是设置

32:12.940 --> 32:13.940
那是modified

32:13.940 --> 32:14.940
跟缓存相关的

32:14.940 --> 32:15.940
设置1 type

32:15.940 --> 32:16.940
跟缓存相关的

32:16.940 --> 32:17.940
还有啥呢

32:17.940 --> 32:18.940
对吧

32:18.940 --> 32:19.940
那么这就是response

32:19.940 --> 32:20.940
和request对象

32:20.940 --> 32:22.940
那么看到这两个对象之后

32:22.940 --> 32:24.940
我们再来看一下

32:24.940 --> 32:26.940
它跟express的对比

32:26.940 --> 32:33.480
看下面

32:33.480 --> 32:34.480
express是这样子的

32:34.480 --> 32:37.480
你们以前用express的时候

32:37.480 --> 32:38.480
你会发现

32:38.480 --> 32:40.480
只要express里边没有去设置

32:40.480 --> 32:42.480
没有去调那个send

32:42.480 --> 32:44.480
那么浏览器是不是一直就卡住

32:44.480 --> 32:45.480
一直等待浮气响应

32:45.480 --> 32:47.480
浮气一直没有给他发送消息体

32:47.480 --> 32:49.480
那么浏览器就一直等着

32:49.480 --> 32:51.480
但是kwa不一样

32:51.480 --> 32:53.480
kwa尽管你没有设置body

32:53.480 --> 32:55.480
那么它仍然是

32:55.480 --> 32:57.480
仍然是在这里的

32:57.480 --> 32:59.480
仍然是可以看到结果的

32:59.480 --> 33:01.480
说明浮气响应给它了

33:01.480 --> 33:02.480
那么是怎么回事呢

33:02.480 --> 33:03.480
它是这样子的

33:03.480 --> 33:05.480
kwa里边的做法是这样子的

33:05.480 --> 33:06.480
express我们知道对吧

33:06.480 --> 33:07.480
它调了send过后

33:07.480 --> 33:10.480
才会真正的发送消息到客户端

33:10.480 --> 33:11.480
那么没有调用的话

33:11.480 --> 33:12.480
就不会发送

33:12.480 --> 33:13.480
一直卡在那里

33:13.480 --> 33:15.480
那么kwa是这样子的

33:15.480 --> 33:16.480
请求到来过后

33:16.480 --> 33:17.480
它不是有很多中间线吗

33:17.480 --> 33:18.480
扬出模型

33:18.480 --> 33:19.480
一出了过后

33:19.480 --> 33:20.480
交给中间线二

33:20.480 --> 33:21.480
中间线二交给中间线三

33:21.480 --> 33:22.480
中间线三完了过

33:22.480 --> 33:23.480
就交换给中间线二

33:23.480 --> 33:24.480
中间线二交换

33:24.480 --> 33:25.480
完了过去交换给中间线一

33:25.480 --> 33:26.480
对吧

33:26.480 --> 33:27.480
总之呢

33:27.480 --> 33:28.480
它一开始把这个standers

33:28.480 --> 33:29.480
设为404

33:29.480 --> 33:31.480
状态把设为404

33:31.480 --> 33:32.480
然后经过一

33:32.480 --> 33:34.480
一趴拉中间线

33:34.480 --> 33:35.480
这个词你听懂吗

33:35.480 --> 33:36.480
一趴拉

33:36.480 --> 33:37.480
一大堆

33:37.480 --> 33:38.480
一大堆中间线

33:38.480 --> 33:39.480
经过了之后

33:39.480 --> 33:41.480
然后直接就发送了

33:41.480 --> 33:42.480
它这里不管你

33:42.480 --> 33:43.480
有没有设置body

33:43.480 --> 33:45.480
body没有设置就是空

33:45.480 --> 33:46.480
或者是它默认的

33:46.480 --> 33:47.480
比方说404就默认

33:48.480 --> 33:49.480
那么standers

33:49.480 --> 33:50.480
状态码

33:50.480 --> 33:51.480
根据它状态码

33:51.480 --> 33:52.480
根据你设置的响应头

33:52.480 --> 33:53.480
没有设置的话

33:53.480 --> 33:54.480
它就是默认的

33:54.480 --> 33:55.480
根据你设置的响应题

33:55.480 --> 33:57.480
发送到客户上

33:57.480 --> 33:58.480
它一定会发送的

33:58.480 --> 33:59.480
中间线运行完

33:59.480 --> 34:00.480
它就会发送

34:00.480 --> 34:01.480
它是这么一种逻辑

34:01.480 --> 34:02.480
那么中间

34:02.480 --> 34:04.480
我们在中间线的运行过程中

34:04.480 --> 34:05.480
只需要给body复制

34:05.480 --> 34:07.480
只需要去搞定standers

34:07.480 --> 34:08.480
只需要去搞定

34:08.480 --> 34:09.480
这个线二式就行了

34:09.480 --> 34:10.480
而且这些

34:10.480 --> 34:11.480
这些中间线可以

34:11.480 --> 34:12.480
混合起来一起来搞定

34:12.480 --> 34:13.480
你看我们

34:13.480 --> 34:14.480
express里边就不行

34:14.480 --> 34:15.480
express一个中间线

34:15.480 --> 34:17.480
其他中间线就不能响应了

34:17.480 --> 34:18.480
对吧

34:18.480 --> 34:19.480
因为它升的过后了

34:19.480 --> 34:20.480
升的

34:20.480 --> 34:21.480
因为它升的内部

34:21.480 --> 34:22.480
它掉了什么

34:22.480 --> 34:23.480
掉了end

34:23.480 --> 34:25.480
结束写入流

34:25.480 --> 34:26.480
是不是就结束了

34:26.480 --> 34:27.480
你没法再发送了

34:27.480 --> 34:28.480
但是呢

34:28.480 --> 34:29.480
ka不一样

34:29.480 --> 34:30.480
ka它只是给

34:30.480 --> 34:32.480
这个body属性复制

34:32.480 --> 34:33.480
所谓中间线运行完了过后

34:33.480 --> 34:34.480
这个时候

34:34.480 --> 34:35.480
还真正会把这个body发送过去

34:35.480 --> 34:36.480
因此

34:36.480 --> 34:37.480
在中间的运行过程中

34:37.480 --> 34:39.480
可以不断的往body里边加东西

34:39.480 --> 34:40.480
而且可以非常轻松的

34:40.480 --> 34:41.480
过去到body

34:41.480 --> 34:42.480
不要那么看一下

34:42.480 --> 34:43.480
这是我觉得

34:43.480 --> 34:45.480
ka里边

34:45.480 --> 34:46.480
用一个重大的区别

34:46.480 --> 34:47.480
跟那个express

34:47.480 --> 34:48.480
而且这个区别

34:48.480 --> 34:49.480
我觉得ka要做的

34:49.480 --> 34:51.480
要比express要好的东西

34:52.480 --> 34:53.480
好

34:53.480 --> 34:54.480
咱们来看一下

34:54.480 --> 34:55.480
response

34:55.480 --> 34:57.480
这里有个body

34:57.480 --> 34:58.480
比方说

34:58.480 --> 34:59.480
我们给它写上一个

34:59.480 --> 35:00.480
这样子

35:00.480 --> 35:01.480
什么

35:01.480 --> 35:02.480
比方说我们该写上一个

35:02.480 --> 35:06.500
he

35:06.500 --> 35:08.500
he

35:08.500 --> 35:09.500
比方说

35:09.500 --> 35:10.500
a

35:10.500 --> 35:11.500
随便来一个吧

35:11.500 --> 35:15.960
然后下个中间线

35:15.960 --> 35:16.960
下个中间线干嘛呢

35:16.960 --> 35:17.960
我们给它写上一个

35:17.960 --> 35:19.960
也写上个

35:19.960 --> 35:20.960
he

35:20.960 --> 35:21.960
b

35:21.960 --> 35:22.960
右下一个

35:22.960 --> 35:23.960
用添加嘛

35:23.960 --> 35:24.960
我们用加等于

35:24.960 --> 35:25.960
你看

35:25.960 --> 35:26.960
后续中间线

35:26.960 --> 35:27.960
是配在之前的基础上

35:27.960 --> 35:28.960
给它点哪一家

35:28.960 --> 35:29.960
对吧

35:29.960 --> 35:30.960
he

35:30.960 --> 35:31.960
c

35:31.960 --> 35:32.960
你看我写了

35:32.960 --> 35:33.960
三个中间线

35:33.960 --> 35:34.960
接下来我们来看一下

35:34.960 --> 35:35.960
刷新

35:35.960 --> 35:36.960
看到没

35:36.960 --> 35:37.960
这些中间线

35:37.960 --> 35:38.960
可以不断的

35:38.960 --> 35:40.960
去控制整个的body

35:40.960 --> 35:41.960
对吧

35:41.960 --> 35:42.960
因为它最终输出了

35:42.960 --> 35:44.960
也就是body这个属性值

35:44.960 --> 35:45.960
我们在这种中间线

35:45.960 --> 35:46.960
无非就是改动一个

35:46.960 --> 35:48.960
普普通通的属性而已

35:48.960 --> 35:49.960
在改动的过程中

35:49.960 --> 35:50.960
跟响应有没有关系

35:50.960 --> 35:51.960
没有关系

35:51.960 --> 35:53.960
等这些中间线运行完了过后

35:53.960 --> 35:55.960
它会把整个body拿去响应

35:55.960 --> 35:56.960
express不一样

35:56.960 --> 35:57.960
express里边比较后来

35:57.960 --> 35:58.960
这个位置调用了send

35:58.960 --> 35:59.960
响应就结束了

35:59.960 --> 36:01.960
就已经结束了

36:01.960 --> 36:02.960
那么后续中间线

36:02.960 --> 36:03.960
会不会运行

36:03.960 --> 36:04.960
会运行

36:04.960 --> 36:05.960
但是响应已经结束了

36:05.960 --> 36:06.960
没啥意思

36:06.960 --> 36:07.960
如果说你没有调用send

36:07.960 --> 36:08.960
那响应就一直卡在那

36:08.960 --> 36:09.960
跟这个东西

36:09.960 --> 36:10.960
就跟express

36:10.960 --> 36:11.960
就很大的区别了

36:11.960 --> 36:12.960
而这种发生的

36:12.960 --> 36:13.960
肯定是

36:13.960 --> 36:14.960
express要优压很多

36:15.960 --> 36:16.960
而且那后续中间线

36:16.960 --> 36:17.960
是可以非常轻松的

36:17.960 --> 36:18.960
获取到之前的body的

36:18.960 --> 36:19.960
你看一下

36:19.960 --> 36:20.960
直接获取

36:20.960 --> 36:21.960
它就是一个属性而已

36:21.960 --> 36:22.960
对吧

36:22.960 --> 36:24.960
response

36:24.960 --> 36:25.960
response

36:25.960 --> 36:26.960
我们上一课

36:26.960 --> 36:27.960
举了个例子

36:27.960 --> 36:28.960
过滤关键之在

36:28.960 --> 36:29.960
这里是不是可以过滤

36:29.960 --> 36:30.960
直接获取就完事了

36:30.960 --> 36:31.960
以上的express里面

36:31.960 --> 36:32.960
要获取之前

36:32.960 --> 36:34.960
那个中间线的响应结果

36:34.960 --> 36:35.960
这麻烦了

36:35.960 --> 36:36.960
那个东西不是觉得

36:36.960 --> 36:37.960
不是轻松可以搬到的

36:37.960 --> 36:38.960
你如果说

36:38.960 --> 36:39.960
听到我的radius课程的话

36:39.960 --> 36:40.960
你才知道

36:40.960 --> 36:41.960
这个地方肯定是比较麻烦的

36:42.960 --> 36:43.960
看到没

36:43.960 --> 36:44.960
是不是可以获取到之前的内容

36:44.960 --> 36:45.960
对吧

36:45.960 --> 36:46.960
好

36:46.960 --> 36:47.960
这是这一块

36:47.960 --> 36:48.960
那么这一块

36:48.960 --> 36:49.960
我们可以利用它来做

36:49.960 --> 36:50.960
干嘛呢

36:50.960 --> 36:51.960
你想想可以干嘛

36:52.960 --> 36:53.960
比方说我这里

36:53.960 --> 36:55.960
得到一些新闻

36:55.960 --> 36:56.960
得到一些新闻

36:56.960 --> 36:57.960
比方说title

36:57.960 --> 36:59.960
不用新闻吗

36:59.960 --> 37:00.960
得到一个

37:00.960 --> 37:01.960
当前登录的用户

37:01.960 --> 37:02.960
不要登录

37:02.960 --> 37:03.960
这是个登录的中间键

37:03.960 --> 37:04.960
它登录成功了

37:04.960 --> 37:05.960
当前登录的用户是什么呢

37:05.960 --> 37:06.960
login id

37:06.960 --> 37:07.960
等于dunk

37:09.960 --> 37:10.960
login password

37:10.960 --> 37:11.960
等于什么呢

37:12.960 --> 37:13.960
password

37:15.960 --> 37:16.960
比方说登录成功了

37:16.960 --> 37:17.960
我一个登录用户

37:17.960 --> 37:18.960
是不是给它复制个对象

37:18.960 --> 37:19.960
对不对

37:19.960 --> 37:20.960
好

37:20.960 --> 37:21.960
那么后续的中间键

37:21.960 --> 37:22.960
后续的中间键

37:22.960 --> 37:23.960
交给后续的中间键

37:23.960 --> 37:24.960
后续的中间键比方说有个中间键

37:24.960 --> 37:25.960
这个中间键

37:25.960 --> 37:27.960
专门是用来格式化消息

37:28.960 --> 37:32.460
格式化消息

37:32.460 --> 37:33.460
它专门用来格式化消息的

37:33.460 --> 37:34.460
就是什么意思呢

37:34.460 --> 37:36.460
就是把整个响应消息

37:36.460 --> 37:38.460
封装成一个统一的格式

37:38.460 --> 37:39.460
那它怎么来封装呢

37:39.460 --> 37:40.460
你看着

37:40.460 --> 37:41.460
我就可以这样

37:41.460 --> 37:42.460
这样封装

37:42.460 --> 37:44.460
我这里重新给这个body复制

37:46.460 --> 37:47.460
response body

37:47.460 --> 37:49.460
拿到这个body

37:51.460 --> 37:52.460
body嘛

37:52.460 --> 37:53.460
拿到这个body

37:53.460 --> 37:54.460
拿到这个body过后

37:54.460 --> 37:57.460
我们重新给这个response body复制

37:57.460 --> 37:58.460
复制为什么呢

37:58.460 --> 37:59.460
data等于body

37:59.460 --> 38:00.460
之前的body

38:00.460 --> 38:02.460
把它放到一个data属性里边来

38:02.460 --> 38:03.460
然后呢

38:03.460 --> 38:04.460
有code

38:04.460 --> 38:05.460
错误码为0

38:05.460 --> 38:06.460
message呢

38:06.460 --> 38:07.460
错误消息为空置5圈

38:07.460 --> 38:08.460
对吧

38:08.460 --> 38:10.460
我可以把它用一个中间键的形式

38:10.460 --> 38:11.460
把它冯装成

38:11.460 --> 38:12.460
把它写成一个

38:12.460 --> 38:13.460
中间键的形式

38:13.460 --> 38:15.460
来封装统一的消息格式

38:15.460 --> 38:16.460
那么这个中间键

38:16.460 --> 38:17.460
写好你不用去动它了

38:17.460 --> 38:18.460
我们只需要在这里

38:18.460 --> 38:20.460
改动不同的body就完成

38:20.460 --> 38:21.460
好咱们我们刷新一下

38:21.460 --> 38:22.460
你看

38:22.460 --> 38:23.460
是不是变成统一的消息格式了

38:23.460 --> 38:24.460
对不对

38:24.460 --> 38:25.460
那么这种写法

38:25.460 --> 38:26.460
我们之前是不是在express里面做过

38:26.460 --> 38:28.460
express里面是不是特别麻烦

38:28.460 --> 38:29.460
你要去自己封装

38:29.460 --> 38:30.460
喊什么落地八道的东西

38:30.460 --> 38:31.460
它中间键是不好实现的

38:31.460 --> 38:32.460
根本原因在哪

38:32.460 --> 38:33.460
根本原因在

38:33.460 --> 38:34.460
后续的中间键

38:34.460 --> 38:35.460
它无法获取到

38:35.460 --> 38:36.460
之前的body信息

38:36.460 --> 38:37.460
很难获取到

38:38.460 --> 38:40.460
因为它body小应有结束了

38:41.460 --> 38:42.460
有没有办法

38:42.460 --> 38:43.460
有办法非常恶心

38:43.460 --> 38:44.460
非常非常恶心

38:44.460 --> 38:45.460
那么在express里面

38:45.460 --> 38:47.460
在QA里面就非常非常自然

38:47.460 --> 38:48.460
而且这个东西

38:48.460 --> 38:49.460
还不一定作为后续中间键

38:49.460 --> 38:51.460
作为前置也可以

38:51.460 --> 38:52.460
神奇吧

38:52.460 --> 38:54.460
怎么可能作为前置呢

38:54.460 --> 38:55.460
你看到我这样子

38:55.460 --> 38:57.460
养冲模型

38:58.460 --> 38:59.460
先交给我

38:59.460 --> 39:00.460
我做一些事情

39:00.460 --> 39:02.460
我啥事情都不做

39:02.460 --> 39:03.460
然后呢

39:03.460 --> 39:05.460
控制旋往后移交

39:06.460 --> 39:07.460
我不管你后边

39:07.460 --> 39:08.460
是不是一步的

39:08.460 --> 39:09.460
反正我等你

39:09.460 --> 39:10.460
等你完成

39:10.460 --> 39:11.460
往后移交

39:11.460 --> 39:12.460
你移交完了过

39:12.460 --> 39:13.460
总归

39:13.460 --> 39:15.460
总归会给我一个消息体

39:15.460 --> 39:16.460
那么这个时候

39:16.460 --> 39:20.420
我再去做个格式化

39:20.420 --> 39:21.420
看到没

39:21.420 --> 39:23.420
是不是这个非常灵活

39:23.420 --> 39:24.420
养冲模型

39:24.420 --> 39:25.420
你好好看一下

39:25.420 --> 39:26.420
养冲模型

39:26.420 --> 39:27.420
就是你第一个中间键

39:27.420 --> 39:29.420
第一个进入的中间键

39:29.420 --> 39:31.420
它首先会接受到控制权

39:31.420 --> 39:32.420
而且必定

39:32.420 --> 39:34.420
它也能在最后一步

39:34.420 --> 39:35.420
接受到控制权

39:35.420 --> 39:36.420
第二个中间键

39:36.420 --> 39:37.420
它可能可以在

39:37.420 --> 39:38.420
第二个地方接受到控制权

39:38.420 --> 39:39.420
而且一定会在

39:39.420 --> 39:41.420
到处第二个地方接受到控制权

39:41.420 --> 39:42.420
那么这个是不是

39:42.420 --> 39:43.420
我们把作为第一个中间键

39:43.420 --> 39:44.420
它首先接受到控制权

39:44.420 --> 39:45.420
我什么都不做

39:45.420 --> 39:46.420
然后移交给后边

39:46.420 --> 39:47.420
那么后续我去

39:47.420 --> 39:48.420
一定这个大码

39:48.420 --> 39:49.420
是不是一定是

39:49.420 --> 39:51.420
作为最后一步完成的

39:51.420 --> 39:52.420
对吧

39:52.420 --> 39:53.420
最后一步上加上包里

39:53.420 --> 39:54.420
对吧

39:54.420 --> 39:55.420
这个是非常灵活的

39:55.420 --> 39:56.420
当然你可以把这个

39:56.420 --> 39:58.420
这个东西写成一个模块

39:58.420 --> 39:59.420
说到模块

39:59.420 --> 40:00.420
我顺便说一下

40:00.420 --> 40:02.420
这个CountX里边

40:02.420 --> 40:03.420
一个很神奇的东西

40:03.420 --> 40:06.240
就是APP

40:06.240 --> 40:07.240
这个CountX

40:07.240 --> 40:08.240
不仅CountX里边有APP

40:08.240 --> 40:10.240
还有Request里边

40:10.240 --> 40:11.240
也有APP

40:11.240 --> 40:12.240
看到没

40:13.240 --> 40:15.240
这个APP到底是啥玩意

40:15.240 --> 40:16.240
就是它

40:16.240 --> 40:18.240
这个APP就是它

40:18.240 --> 40:20.240
那大家想一想

40:20.240 --> 40:21.240
有意义吗

40:21.240 --> 40:23.240
我在CountX里边加上APP

40:23.240 --> 40:24.240
就是嘛这个玩意

40:24.240 --> 40:25.240
说说吧

40:25.240 --> 40:26.240
CountX是APP

40:26.240 --> 40:28.240
是不是等于这个APP

40:28.240 --> 40:29.240
保存

40:30.240 --> 40:31.240
刷新

40:32.240 --> 40:33.240
看到没

40:33.240 --> 40:35.240
那为什么它往CountX里边放

40:35.240 --> 40:36.240
当然这个问题

40:36.240 --> 40:37.240
很傻的

40:37.240 --> 40:38.240
很傻的问题

40:38.240 --> 40:39.240
你们写

40:39.240 --> 40:40.240
但是很多同学

40:40.240 --> 40:41.240
我就觉得都还不知道

40:42.240 --> 40:43.240
为什么

40:43.240 --> 40:44.240
你们觉得CountX是不是疯了

40:44.240 --> 40:45.240
它往这里边放啥

40:45.240 --> 40:46.240
它直接用APP

40:46.240 --> 40:47.240
不管了

40:47.240 --> 40:48.240
为什么往CountX里边放

40:48.240 --> 40:51.810
这叫设计

40:51.810 --> 40:54.810
这叫做程序结构设计

40:54.810 --> 40:55.810
它设计的时候

40:55.810 --> 40:56.810
要考虑到这一点

40:56.810 --> 40:57.810
为什么呢

40:57.810 --> 40:59.810
因为你这个玩意

40:59.810 --> 41:01.810
你是不是可以把它写成

41:01.810 --> 41:02.810
写成那个中间键

41:02.810 --> 41:03.810
对吧

41:03.810 --> 41:04.810
format

41:04.810 --> 41:06.810
我们format

41:07.810 --> 41:11.140
节省

41:11.140 --> 41:13.140
主要说没写成那个中间键

41:13.140 --> 41:15.140
这个中间键里边我们导出

41:15.140 --> 41:16.140
导出什么的

41:16.140 --> 41:17.140
中间键就是一个函数

41:17.140 --> 41:20.580
不就是一个函数

41:20.580 --> 41:22.580
那么请问你在这里边

41:22.580 --> 41:23.580
怎么去获取APP

41:23.580 --> 41:24.580
怎么去获取APP

41:24.580 --> 41:25.580
是不是这里有获取不到

41:25.580 --> 41:26.580
只能通过这样的方式来获取

41:26.580 --> 41:28.580
它就起着每个作用

41:28.580 --> 41:30.580
没那么复杂

41:30.580 --> 41:32.580
这边我们既然写成了中间键

41:32.580 --> 41:33.580
对吧

41:33.580 --> 41:34.580
我们就可以用使用了

41:34.580 --> 41:35.580
format

41:35.580 --> 41:36.580
节省

41:36.580 --> 41:38.580
格式化我们的节省

41:38.580 --> 41:40.580
节省的数据

41:40.580 --> 41:42.580
像我是一样的

41:42.580 --> 41:43.580
好

41:43.580 --> 41:45.580
这是这两个对象

41:45.580 --> 41:47.580
那么第1个就是响应流程

41:47.580 --> 41:48.580
我们刚才已经看了一下

41:48.580 --> 41:49.580
给Body复制的时候

41:49.580 --> 41:50.580
它会自动把Status复作为200

41:50.580 --> 41:51.580
或者204

41:51.580 --> 41:52.580
中间键无非就是

41:52.580 --> 41:53.580
改动Body

41:53.580 --> 41:54.580
改动Headers

41:54.580 --> 41:56.580
Headers无非就是个对象

41:56.580 --> 41:57.580
改动它完了过后

41:57.580 --> 41:58.580
中间键运行完了过后

41:58.580 --> 41:59.580
最后是响应

41:59.580 --> 42:00.580
下一个

42:00.580 --> 42:01.580
下一个我们要

42:01.580 --> 42:02.580
一个小的细节就是

42:02.580 --> 42:03.580
它会减化API

42:03.580 --> 42:05.580
因为QA它觉得

42:05.580 --> 42:07.580
通过这种方式来写API

42:07.580 --> 42:08.580
还是觉得繁殊

42:08.580 --> 42:10.580
因此它会把request

42:10.580 --> 42:11.580
和response中很多成员

42:11.580 --> 42:13.580
直接提到了context

42:13.580 --> 42:14.580
啥意思呢

42:14.580 --> 42:16.580
就是我们刚才在request里面

42:16.580 --> 42:17.580
不是要获取什么

42:17.580 --> 42:19.580
要获取什么request里面

42:19.580 --> 42:20.580
要获取pice

42:20.580 --> 42:21.580
对不对

42:21.580 --> 42:23.580
直接通过context来获取pice

42:23.580 --> 42:24.580
就完了一样的

42:24.580 --> 42:25.580
一模一样的

42:25.580 --> 42:26.580
那么这个pice是

42:26.580 --> 42:27.580
怎么了在这里边

42:27.580 --> 42:28.580
它其实就是一个

42:28.580 --> 42:30.580
它就是一个访问器

42:30.580 --> 42:31.580
它就是一个访问器

42:31.580 --> 42:33.580
什么叫访问器

42:33.580 --> 42:34.580
你可以理解为这个

42:34.580 --> 42:37.580
define objects

42:37.580 --> 42:39.580
define property

42:39.580 --> 42:42.580
往text上加了一个属性

42:42.580 --> 42:43.580
pice

42:43.580 --> 42:44.580
这个pice

42:44.580 --> 42:46.580
你给它复制的时候

42:46.580 --> 42:47.580
它又得到了是什么

42:47.580 --> 42:51.580
得到了request里面的pice

42:51.580 --> 42:53.580
你给它设置值的时候

42:53.580 --> 42:55.580
就相当于是

42:55.580 --> 42:58.580
给request里面的pice设置值

42:58.580 --> 42:59.580
不要这意思吧

42:59.580 --> 43:01.580
它就做了这么一件事

43:01.580 --> 43:03.580
因此你这个pice

43:03.580 --> 43:05.580
相当于是个别名

43:05.580 --> 43:06.580
对吧

43:06.580 --> 43:07.580
跟那边事情完全一样的

43:07.580 --> 43:08.580
那么我们来看一下

43:08.580 --> 43:10.580
它里面有哪些别名

43:11.580 --> 43:13.580
找到这

43:13.580 --> 43:17.600
context往下找

43:17.600 --> 43:19.600
它说下面的访问器

43:19.600 --> 43:21.600
跟request的别名等相

43:21.600 --> 43:22.600
header一样的

43:22.600 --> 43:23.600
你说context里面

43:23.600 --> 43:24.600
header是什么

43:24.600 --> 43:25.600
request的header

43:25.600 --> 43:26.600
有时候又开始背了

43:26.600 --> 43:28.600
request里面有header

43:28.600 --> 43:29.600
request里面有header

43:29.600 --> 43:30.600
但是context里面

43:30.600 --> 43:31.600
header是request

43:31.600 --> 43:33.600
我这背些东西干嘛

43:33.600 --> 43:34.600
一直背东西

43:34.600 --> 43:35.600
这个不累啊

43:35.600 --> 43:36.600
你不要去背它

43:36.600 --> 43:37.600
你插就完了嘛

43:37.600 --> 43:39.600
request里面有body

43:39.600 --> 43:40.600
这些都有对不对

43:40.600 --> 43:41.600
对都有

43:41.600 --> 43:42.600
写着现在就熟悉了

43:42.600 --> 43:43.600
不要去背它

43:43.600 --> 43:44.600
所以说绝大部分时候

43:44.600 --> 43:46.600
我们倒是真的还没有必要去用request

43:46.600 --> 43:48.600
直接用context就可以了

43:48.600 --> 43:49.600
包括这边

43:49.600 --> 43:53.940
直接用context就可以了

43:53.940 --> 43:55.940
直接用context就可以了

43:55.940 --> 43:56.940
明儿那意思吧

43:56.940 --> 43:57.940
你看这边

43:57.940 --> 43:58.940
双形完全一样

43:59.940 --> 44:00.940
好

44:00.940 --> 44:01.940
这是context里面的别名

44:01.940 --> 44:02.940
这是这个特点

44:02.940 --> 44:04.940
你们可以自己看一下

44:04.940 --> 44:05.940
下面Cookie我说一下

44:05.940 --> 44:07.940
因为Cookie里面的Cookie

44:07.940 --> 44:09.940
它是既不在request里面

44:09.940 --> 44:11.940
也不在resistance里面

44:11.940 --> 44:12.940
它是怎么想的呢

44:12.940 --> 44:14.940
我来模拟一下Cookie的想法

44:14.940 --> 44:15.940
当然我也不认识这帮

44:15.940 --> 44:16.940
那帮写Cookie的人

44:16.940 --> 44:18.940
我只是在通过一个

44:18.940 --> 44:21.940
心心相惜的程序而的思维角度

44:21.940 --> 44:23.940
去想象他们的想法

44:23.940 --> 44:25.940
因为我以前呢

44:25.940 --> 44:27.940
在以前读书的时候

44:27.940 --> 44:28.940
有那个Cookie的东西

44:28.940 --> 44:30.940
我也是有这个想法

44:30.940 --> 44:31.940
因为Cookie呢

44:31.940 --> 44:33.940
从大一码逻辑上来说

44:33.940 --> 44:35.940
它就是一个对象

44:35.940 --> 44:36.940
不就是一个对象吗

44:36.940 --> 44:37.940
对吧

44:37.940 --> 44:38.940
或者是一个集合

44:38.940 --> 44:39.940
有很多互聘

44:39.940 --> 44:41.940
那么既然是一个对象

44:41.940 --> 44:42.940
或者是一个集合

44:42.940 --> 44:44.940
或者是一个别的什么玩意儿

44:44.940 --> 44:46.940
它是可以复职

44:46.940 --> 44:48.940
也可以获取

44:48.940 --> 44:49.940
可以读取它的职

44:49.940 --> 44:50.940
也可以复职

44:50.940 --> 44:51.940
那么从逻辑上来说

44:51.940 --> 44:52.940
读它的职

44:52.940 --> 44:54.940
是不是相当于是

44:54.940 --> 44:56.940
从请求里面拿到

44:56.940 --> 44:57.940
给它复职

44:57.940 --> 44:58.940
相当于是不是

44:58.940 --> 45:00.940
把它写到响应里面去

45:00.940 --> 45:01.940
对吧

45:01.940 --> 45:03.940
那么如果从大一码的层面的意见

45:03.940 --> 45:05.940
而不从ADP的角度的理解的话

45:05.940 --> 45:07.940
它确实跟请求和响应无关

45:07.940 --> 45:09.940
或者说它是跨越了请求和响应

45:09.940 --> 45:11.940
读它的职就是读请求

45:11.940 --> 45:13.940
写它的职就是写到响应里面

45:13.940 --> 45:16.940
KoA它就是用这种方式来做的

45:16.940 --> 45:18.940
那么KoA它远程支持Cookie

45:18.940 --> 45:19.940
但是呢

45:19.940 --> 45:20.940
它不需要安装其他东西

45:20.940 --> 45:21.940
不需要安装别的任何东西

45:21.940 --> 45:22.940
它怎么来用的

45:22.940 --> 45:23.940
非常简单

45:23.940 --> 45:24.940
Cookie是Set

45:24.940 --> 45:26.940
Name,Value,Options

45:26.940 --> 45:28.940
读取Cookie的职

45:28.940 --> 45:29.940
Cookie是Get

45:29.940 --> 45:30.940
来获取Cookie

45:30.940 --> 45:31.940
就这么简单

45:31.940 --> 45:33.940
那么这个Options是什么东西呢

45:33.940 --> 45:34.940
设置Cookie的时候

45:34.940 --> 45:35.940
不是有很多的信息吗

45:35.940 --> 45:36.940
我们之前讲过

45:36.940 --> 45:37.940
不要把Cookie忘了

45:37.940 --> 45:38.940
所以说关键点是

45:38.940 --> 45:39.940
要把Cookie

45:39.940 --> 45:40.940
知道Cookie是什么

45:40.940 --> 45:41.940
然后再说的API

45:41.940 --> 45:42.940
API就很简单了

45:42.940 --> 45:44.940
不要说Cookie是

45:45.940 --> 45:46.940
你看

45:46.940 --> 45:48.940
它刚说你的Options

45:48.940 --> 45:50.940
不是在这

45:51.940 --> 45:52.940
Set

45:53.940 --> 45:54.940
Set

45:55.940 --> 45:56.940
这个格式都乱了

45:56.940 --> 45:58.940
还是换成官网吗

45:59.940 --> 46:00.940
QA

46:00.940 --> 46:07.640
官网格式不可能乱的

46:07.640 --> 46:08.640
下面

46:08.640 --> 46:10.640
那有哪些职可以复职呢

46:11.640 --> 46:12.640
Name,Value

46:12.640 --> 46:13.640
Cookie的名字

46:13.640 --> 46:14.640
Cookie的职

46:14.640 --> 46:15.640
Options,Mac, Sage

46:15.640 --> 46:16.640
不解释了

46:16.640 --> 46:17.640
Send 是不是加密

46:17.640 --> 46:18.640
Expire,Pass,DoMap

46:18.640 --> 46:19.640
都全部不解释了

46:19.640 --> 46:20.640
全部不解释了

46:20.640 --> 46:21.640
没什么好解释的

46:21.640 --> 46:22.640
就完了

46:22.640 --> 46:24.640
这是读取和获取

46:24.640 --> 46:25.640
就是设置Cookie

46:25.640 --> 46:26.640
使用Context

46:27.640 --> 46:28.640
Set

46:29.640 --> 46:31.640
读取Cookie使用

46:31.640 --> 46:32.640
这个Gate

46:32.640 --> 46:33.640
那么Cookie加密

46:33.640 --> 46:34.640
它原生也支持加密

46:34.640 --> 46:35.640
它怎么加密呢

46:35.640 --> 46:36.640
首先你要定义密钥

46:36.640 --> 46:37.640
怎么来定义密钥呢

46:37.640 --> 46:38.640
它是在App里面

46:38.640 --> 46:39.640
Test里面

46:39.640 --> 46:40.640
给它一个数组

46:40.640 --> 46:41.640
数组里面就放密钥

46:41.640 --> 46:42.640
第一个密钥

46:42.640 --> 46:43.640
第二个密钥

46:43.640 --> 46:44.640
可以放多个密钥

46:44.640 --> 46:45.640
然后

46:45.640 --> 46:46.640
你设置Cookie的时候

46:46.640 --> 46:47.640
你加上一个配置

46:47.640 --> 46:48.640
就Send to

46:48.640 --> 46:49.640
所以把它加密

46:49.640 --> 46:50.640
你把它加密的时候

46:50.640 --> 46:51.640
它就会用这些密钥金

46:51.640 --> 46:53.640
对Cookie的职进行加密

46:53.640 --> 46:54.640
Gate的时候

46:55.640 --> 46:56.640
你只要去试一下

46:56.640 --> 46:57.640
这些没什么好解释的

46:57.640 --> 46:59.640
你都读取一个加密过后的Cookie

46:59.640 --> 47:01.640
那么你要给它一个配置Send

47:01.640 --> 47:03.640
那么它会用对应的密钥

47:03.640 --> 47:04.640
解密过去

47:04.640 --> 47:05.640
就这么简单

47:05.640 --> 47:06.640
关键是这个问题

47:06.640 --> 47:07.640
要解理解的就是

47:07.640 --> 47:09.640
为什么会支持多个密钥

47:09.640 --> 47:10.640
根据官方文道的说法

47:10.640 --> 47:11.640
它是使用一个

47:11.640 --> 47:12.640
第三方库叫CakeGrip

47:12.640 --> 47:13.640
来完成的

47:13.640 --> 47:14.640
那么这个库

47:14.640 --> 47:16.640
它就是使用多个密钥

47:16.640 --> 47:18.640
轮流加密的

47:18.640 --> 47:19.640
比方地是用这个密钥加密

47:19.640 --> 47:20.640
Test用这个密钥加密

47:20.640 --> 47:21.640
我们把它叫做

47:21.640 --> 47:23.640
旋转加密算法

47:23.640 --> 47:25.640
它就是用不同的密钥来

47:25.640 --> 47:26.640
做加密

47:26.640 --> 47:27.640
然后解密的时候

47:27.640 --> 47:29.640
它会找到你的解

47:29.640 --> 47:31.640
我将会要使用哪一个密钥

47:31.640 --> 47:32.640
进行解密

47:32.640 --> 47:34.640
它会有算法进行寻找的

47:34.640 --> 47:36.640
那找不到的话就解密失败

47:36.640 --> 47:37.640
那么这种方式

47:37.640 --> 47:38.640
有什么好处呢

47:38.640 --> 47:39.640
更加安全

47:39.640 --> 47:40.640
你可以把这些不同的密钥

47:40.640 --> 47:42.640
保存到不同的地方

47:42.640 --> 47:43.640
然后通过某些方式

47:43.640 --> 47:44.640
在读去

47:44.640 --> 47:45.640
把密钥保存

47:45.640 --> 47:47.640
把这个密钥保存到一台服务器

47:47.640 --> 47:49.640
把这个密钥保存到另一台服务器

47:49.640 --> 47:50.640
保存多台服务器

47:50.640 --> 47:51.640
然后读的时候

47:51.640 --> 47:52.640
是不是通过原成请求

47:52.640 --> 47:53.640
从这个服务器

47:53.640 --> 47:54.640
读到这个密钥放到这

47:54.640 --> 47:55.640
从另一个服务器

47:55.640 --> 47:56.640
读到密钥放到这

47:56.640 --> 47:57.640
那么如果说

47:57.640 --> 47:59.640
一台服务器不幸中招了

48:00.640 --> 48:01.640
那么至少

48:01.640 --> 48:02.640
它还是不

48:02.640 --> 48:03.640
哪怕比方说

48:03.640 --> 48:05.640
这个还服务器的密钥

48:05.640 --> 48:06.640
这台服务器中招了

48:06.640 --> 48:07.640
密钥泄漏了

48:07.640 --> 48:08.640
其他过后

48:08.640 --> 48:09.640
它能解密我的

48:09.640 --> 48:10.640
字无穿吗

48:10.640 --> 48:11.640
解密不了

48:11.640 --> 48:12.640
为什么了

48:12.640 --> 48:13.640
它不一定是用这个密钥加密的

48:13.640 --> 48:15.640
可能是用别的密钥加密的

48:15.640 --> 48:17.640
它是更加安全一点

48:17.640 --> 48:18.640
选顺加密

48:19.640 --> 48:21.640
这是关于Cookie

48:21.640 --> 48:22.640
你可以至于试一下

48:22.640 --> 48:23.640
下面是自定义空间

48:23.640 --> 48:24.640
啥意思呢

48:24.640 --> 48:25.640
就是说

48:25.640 --> 48:26.640
这个KV说

48:26.640 --> 48:27.640
就是比方说你写个冬天线

48:27.640 --> 48:28.640
你写了个冬天线

48:28.640 --> 48:29.640
比方说我们写一个吧

48:30.640 --> 48:32.640
我们就在这写一个

48:33.640 --> 48:34.640
use a require

48:35.640 --> 48:37.640
这边直接写就行了

48:37.640 --> 48:39.640
比方说这个冬天线

48:41.640 --> 48:42.640
比方说这个冬天线

48:42.640 --> 48:43.640
用来干嘛的呢

48:43.640 --> 48:44.640
就是用来

48:44.640 --> 48:46.640
得到当前当中的用户的

48:46.640 --> 48:48.640
比方说得了一个用户

48:48.640 --> 48:49.640
假设吧

48:49.640 --> 48:50.640
我得到那个用户名

48:50.640 --> 48:51.640
叫做这个

48:51.640 --> 48:52.640
当前当中的用户

48:52.640 --> 48:54.640
那么现在不是登录了

48:54.640 --> 48:55.640
无所谓吧

48:55.640 --> 48:56.640
就随便来一个吧

48:56.640 --> 48:59.080
比方就是这个

48:59.080 --> 49:01.080
当前当中的用户是这个

49:01.080 --> 49:02.080
那么我们不要把

49:02.080 --> 49:04.080
这个东西放给后续的冬天线使用

49:04.080 --> 49:05.080
对不对

49:05.080 --> 49:06.080
那怎么来放呢

49:06.080 --> 49:07.080
怎么来放呢

49:07.080 --> 49:08.080
我们就可以使用

49:08.080 --> 49:09.080
这个是

49:09.080 --> 49:10.080
是不是可以把它放到这

49:10.080 --> 49:11.080
对吧

49:11.080 --> 49:12.080
可不可以放到这

49:12.080 --> 49:13.080
当然可以

49:13.080 --> 49:14.080
但它建议你不要这样的放

49:14.080 --> 49:15.080
因为它这样子

49:15.080 --> 49:16.080
容易造成重名

49:16.080 --> 49:17.080
因为我们知道

49:17.080 --> 49:19.080
它KV里面是不是有很多属性

49:19.080 --> 49:20.080
对不对

49:20.080 --> 49:21.080
那么如果你直接放到这的话

49:21.080 --> 49:22.080
容易造成重名

49:22.080 --> 49:23.080
那么它建议你把它放到这

49:23.080 --> 49:24.080
State

49:24.080 --> 49:25.080
State是个啥

49:25.080 --> 49:26.080
专门用来放各种

49:26.080 --> 49:27.080
乱七八糟的玩意儿的

49:27.080 --> 49:28.080
有什么玩意儿

49:28.080 --> 49:29.080
要给后续的冬天线使用

49:29.080 --> 49:30.080
你就说不准它

49:30.080 --> 49:31.080
是在请求里面

49:31.080 --> 49:32.080
还是在响应里面

49:32.080 --> 49:33.080
那么只是在

49:33.080 --> 49:34.080
请求的处理过程中

49:34.080 --> 49:35.080
要用到的

49:35.080 --> 49:36.080
那么就可以往State里面放

49:36.080 --> 49:38.080
那比方说放在U字

49:38.080 --> 49:39.080
那么在下个冬天线里面

49:39.080 --> 49:40.080
我们要输出这个U字

49:40.080 --> 49:41.080
你看

49:41.080 --> 49:42.080
输出

49:42.080 --> 49:43.080
看那个是

49:43.080 --> 49:44.080
State

49:45.080 --> 49:46.080
这个body

49:46.080 --> 49:47.080
我们就随便来一个吧

49:48.080 --> 49:51.540
好保存

49:51.540 --> 49:52.540
这边

49:52.540 --> 49:55.430
刷新

49:59.900 --> 50:00.900
问题在哪

50:00.900 --> 50:01.900
问题在哪

50:01.900 --> 50:02.900
我们调到next

50:03.900 --> 50:04.900
再来

50:05.900 --> 50:06.900
刷新

50:07.900 --> 50:08.900
你看

50:09.900 --> 50:11.900
这State是不是就出来了

50:11.900 --> 50:12.900
State就是来共享

50:12.900 --> 50:13.900
往后续的冬天线里面

50:13.900 --> 50:14.900
共享信息的

50:14.900 --> 50:15.900
就制定以空间

50:15.900 --> 50:16.900
相当于是个空间

50:16.900 --> 50:18.900
你可以自己往里面加东西

50:18.900 --> 50:19.900
但是每次

50:19.900 --> 50:20.900
每次请求之间是隔离的

50:20.900 --> 50:21.900
它每次请求

50:21.900 --> 50:22.900
它都放到

50:22.900 --> 50:23.900
context里面的

50:23.900 --> 50:24.900
context里面

50:24.900 --> 50:25.900
只每次请求隔离的

50:25.900 --> 50:26.900
那如果说你放到

50:26.900 --> 50:28.900
IP里面就是跨越请求的

50:28.900 --> 50:29.900
搞清楚

50:29.900 --> 50:30.900
下面这个错误处理

50:30.900 --> 50:31.900
它是这样子

50:31.900 --> 50:32.900
KOA它本身

50:32.900 --> 50:34.900
实现了event emitter

50:34.900 --> 50:35.900
这个东西是

50:35.900 --> 50:36.900
我们以前讲

50:36.900 --> 50:37.900
load解释的时候

50:37.900 --> 50:38.900
一个扩展课程

50:38.900 --> 50:39.900
就是一个事件处理机制

50:39.900 --> 50:40.900
如果没有听过的话

50:40.900 --> 50:41.900
也没关系

50:41.900 --> 50:42.900
只要知道怎么用就行了

50:43.900 --> 50:44.900
因此

50:44.900 --> 50:46.900
如果说我要去处理错误

50:46.900 --> 50:47.900
当然有的时候

50:47.900 --> 50:48.900
因为我们中间处理过程中

50:48.900 --> 50:49.900
可能会发生错误

50:49.900 --> 50:50.900
在这个过程中

50:50.900 --> 50:51.900
可能会发生错误

50:51.900 --> 50:52.900
那么错误的发生了

50:52.900 --> 50:53.900
它一定会导致

50:53.900 --> 50:54.900
代码中断

50:54.900 --> 50:55.900
你动中断了

50:55.900 --> 50:56.900
比方说

50:56.900 --> 50:57.900
这个句话发生了错误

50:57.900 --> 50:58.900
那还会往后面移交吗

50:58.900 --> 50:59.900
代码中断了

50:59.900 --> 51:00.900
肯定是中断了

51:00.900 --> 51:01.900
那么会导致

51:01.900 --> 51:02.900
这个中间线运行中断

51:02.900 --> 51:03.900
中断了过后

51:04.900 --> 51:05.900
那么KOA

51:05.900 --> 51:07.900
它会给你抛出一个错误

51:07.900 --> 51:09.900
你只需要抛出一个错误时间

51:09.900 --> 51:11.900
这个时间的名字叫做 error

51:11.900 --> 51:13.900
你只要通过这个app

51:13.900 --> 51:14.900
去向那个 error

51:14.900 --> 51:15.900
注册时间就完事了

51:15.900 --> 51:16.900
就这么简单

51:16.900 --> 51:17.900
比方说

51:17.900 --> 51:18.900
我们这里呢

51:18.900 --> 51:19.900
看一下

51:22.900 --> 51:24.900
如果说抛出错误的话

51:24.900 --> 51:28.100
那么

51:28.100 --> 51:29.100
输出这个 error

51:30.100 --> 51:31.100
比方说吧

51:31.100 --> 51:32.100
我们这里呢

51:32.100 --> 51:33.100
有一个辩量

51:33.100 --> 51:34.100
n

51:35.100 --> 51:36.100
我这里调用了

51:36.100 --> 51:37.100
n

51:37.100 --> 51:38.100
n的a

51:38.100 --> 51:39.100
输出

51:39.100 --> 51:40.100
n的a

51:41.100 --> 51:42.100
好

51:42.100 --> 51:43.100
保存

51:43.100 --> 51:44.100
刷新一下

51:44.100 --> 51:45.100
那么你看一下

51:45.100 --> 51:46.100
这里

51:46.100 --> 51:47.100
是不是

51:47.100 --> 51:48.100
报出了错误

51:48.100 --> 51:49.100
那么这个到底有没有运行的

51:49.100 --> 51:50.100
实际上还运行的

51:50.100 --> 51:51.100
还运行的

51:51.100 --> 51:52.100
我们比较到前面加一个吧

51:53.100 --> 51:55.100
加一个 error

51:56.100 --> 51:57.100
好

51:57.100 --> 51:58.100
刷新

51:59.100 --> 52:00.100
那么这里

52:00.100 --> 52:01.100
你看

52:01.100 --> 52:02.100
是不是运行的

52:02.100 --> 52:03.100
这个东西是我们输出的

52:03.100 --> 52:05.100
是我们这一块输出的

52:05.100 --> 52:06.100
这个 error

52:06.100 --> 52:07.100
它是个错误对象

52:07.100 --> 52:08.100
是我们自己这一块输出的

52:08.100 --> 52:09.100
而且呢

52:09.100 --> 52:10.100
你看一看到

52:10.100 --> 52:11.100
可以看到

52:11.100 --> 52:12.100
我们这是我们的

52:12.100 --> 52:13.100
详细的错误消息

52:13.100 --> 52:14.100
错误消息是什么呢

52:14.100 --> 52:15.100
无法读取

52:15.100 --> 52:16.100
从 a 里面

52:16.100 --> 52:18.100
从 null 里面读取这个属性 a

52:18.100 --> 52:19.100
你看

52:19.100 --> 52:21.100
无法从 null 里面读取这个属性 a

52:21.100 --> 52:22.100
对吧

52:22.100 --> 52:23.100
null 属性 a

52:23.100 --> 52:24.100
那么这是这个错误

52:24.100 --> 52:25.100
那么这个错误

52:25.100 --> 52:26.100
它有没有到客户端

52:26.100 --> 52:27.100
它没有到客户端

52:27.100 --> 52:28.100
客户端得到的是啥呢

52:28.100 --> 52:30.100
得到的是一个五百强硬码

52:30.100 --> 52:31.100
错误消息呢

52:31.100 --> 52:33.100
是 internal server error

52:33.100 --> 52:35.100
五百就是服务器内部错误

52:35.100 --> 52:37.100
那么我们如何来设置服务器的

52:37.100 --> 52:38.100
消息码呢

52:38.100 --> 52:40.100
如何来设置服务器的消息码

52:40.100 --> 52:41.100
非常简单

52:41.100 --> 52:42.100
非常简单

52:42.100 --> 52:44.100
你在拋出错误的时候呢

52:44.100 --> 52:45.100
你不要用

52:45.100 --> 52:46.100
比方说

52:46.100 --> 52:47.100
包了错

52:47.100 --> 52:48.100
它默认的情况下

52:48.100 --> 52:49.100
包了错的话

52:49.100 --> 52:50.100
它默认的情况下

52:50.100 --> 52:51.100
就是五百错误

52:51.100 --> 52:53.100
那么表示位置错误

52:53.100 --> 52:54.100
那么如果说

52:54.100 --> 52:55.100
这个错误是可控的

52:55.100 --> 52:56.100
那么你怎么来处理呢

52:56.100 --> 52:57.100
就是说

52:57.100 --> 52:58.100
然后这个地方

52:58.100 --> 52:59.100
我们可以用

52:59.100 --> 53:00.100
context说

53:01.100 --> 53:02.100
拋出错误

53:02.100 --> 53:03.100
第一个参数就是

53:03.100 --> 53:04.100
错误嘛

53:04.100 --> 53:05.100
比方说四百

53:05.100 --> 53:06.100
四零三

53:07.100 --> 53:08.100
第一个参数呢就是

53:09.100 --> 53:11.100
消息的文本

53:11.100 --> 53:12.100
就是

53:12.100 --> 53:14.100
not permit

53:16.480 --> 53:17.480
或者叫

53:17.480 --> 53:20.480
you have no permission

53:20.480 --> 53:21.480
你没有权限

53:22.480 --> 53:23.480
四零三

53:23.480 --> 53:24.480
好

53:24.480 --> 53:25.480
它是会拋出错误

53:25.480 --> 53:26.480
这个会在喊出

53:26.480 --> 53:27.480
会在内部拋出错误

53:27.480 --> 53:28.480
然后呢

53:28.480 --> 53:29.480
这个弹码会中断

53:29.480 --> 53:31.480
就这句话就直接拋出错误了

53:31.480 --> 53:33.480
那么就会引发错误事件

53:33.480 --> 53:34.480
no permission

53:34.480 --> 53:35.480
然后呢

53:35.480 --> 53:36.480
接下来

53:36.480 --> 53:38.480
我们后边还可以写上一些东西

53:38.480 --> 53:39.480
后边写上东西呢

53:39.480 --> 53:40.480
我们可以

53:40.480 --> 53:41.480
还叫做

53:41.480 --> 53:42.480
这个东西就是对应到这了

53:42.480 --> 53:43.480
就对象了

53:43.480 --> 53:45.480
比方说我们这里写上一个对象

53:45.480 --> 53:46.480
A等于

53:46.480 --> 53:47.480
A等于

53:47.480 --> 53:48.480
A等于

53:49.480 --> 53:50.480
或者是

53:50.480 --> 53:51.480
A等于嘛

53:51.480 --> 53:52.480
就写个A等于

53:53.480 --> 53:54.480
来看吧

53:54.480 --> 53:57.820
保存

53:57.820 --> 53:58.820
这种错误的做法

53:58.820 --> 53:59.820
你看you have permission

53:59.820 --> 54:00.820
客户他收到什么

54:00.820 --> 54:01.820
四零三

54:01.820 --> 54:02.820
响应嘛

54:02.820 --> 54:03.820
小音体呢

54:03.820 --> 54:04.820
是you have permission

54:04.820 --> 54:05.820
那么服务器这边错误

54:05.820 --> 54:06.820
收到的是什么呢

54:06.820 --> 54:07.820
收到的是这个错误的

54:07.820 --> 54:08.820
详细信息

54:08.820 --> 54:09.820
A等于3

54:11.820 --> 54:12.820
你看这错误在里边

54:12.820 --> 54:13.820
A等于1

54:13.820 --> 54:14.820
他错误对象里边

54:14.820 --> 54:15.820
是有个A等于1

54:15.820 --> 54:16.820
对吧

54:17.820 --> 54:18.820
就A等于1的错误

54:18.820 --> 54:19.820
就这么一个意思

54:20.820 --> 54:21.820
有些错误呢

54:21.820 --> 54:22.820
有些消息呢

54:22.820 --> 54:23.820
是服务器要用的

54:23.820 --> 54:25.820
那么这消息是给客户端的

54:25.820 --> 54:26.820
这是关于错误

54:26.820 --> 54:28.820
以及如何来手动引发错误

54:28.820 --> 54:29.820
那么什么情况下

54:29.820 --> 54:30.820
会手动引发错误

54:30.820 --> 54:31.820
很简单

54:31.820 --> 54:32.820
像那种

54:32.820 --> 54:34.820
一些验证错误对吧

54:34.820 --> 54:35.820
验证错误呢

54:35.820 --> 54:36.820
你可以验证发生的错误

54:36.820 --> 54:37.820
可以手动引发一个错误

54:38.820 --> 54:39.820
或者是

54:39.820 --> 54:40.820
别的

54:40.820 --> 54:41.820
表面没有权限

54:41.820 --> 54:42.820
我可以手动引发一个错误

54:43.820 --> 54:44.820
这些东西呢

54:44.820 --> 54:45.820
要错误处理

54:47.820 --> 54:48.820
后边呢

54:48.820 --> 54:49.820
由于KVS实验了

54:49.820 --> 54:50.820
InventAmmetal

54:50.820 --> 54:51.820
除了错误处理之外呢

54:51.820 --> 54:52.820
还可以用它做别的事情

54:52.820 --> 54:53.820
这个东西

54:53.820 --> 54:54.820
关键是瞭解

54:54.820 --> 54:55.820
学过了

54:55.820 --> 54:56.820
那一课

54:56.820 --> 54:57.820
InventAmmetal那一课

54:57.820 --> 54:58.820
如果你学过的话

54:58.820 --> 55:00.820
你自然都知道了

55:00.820 --> 55:01.820
这边有很多可以玩的

55:01.820 --> 55:03.820
如果不光是错误

55:03.820 --> 55:04.820
比方说我们这里太浮试一下

55:04.820 --> 55:05.820
随便就个例子了

55:05.820 --> 55:06.820
这个东西上的评设

55:06.820 --> 55:07.820
我们也不这么用得到

55:07.820 --> 55:08.820
就说一下吧

55:08.820 --> 55:09.820
有趣的一个点

55:09.820 --> 55:10.820
非常有趣的一个点

55:10.820 --> 55:11.820
比方说

55:11.820 --> 55:12.820
我们在这里注射个实验

55:13.820 --> 55:14.820
ABC实验

55:14.820 --> 55:15.820
data

55:16.820 --> 55:17.820
我也不知道这个实验干嘛

55:17.820 --> 55:18.820
你不要问我

55:18.820 --> 55:19.820
我就瞎写的

55:19.820 --> 55:20.820
比方说在某一次

55:20.820 --> 55:21.820
请求处理过程中

55:21.820 --> 55:22.820
我也可以引发这个实验

55:22.820 --> 55:23.820
对吧

55:23.820 --> 55:24.820
Ammetal

55:24.820 --> 55:25.820
因为它实验的

55:25.820 --> 55:26.820
InventAmmetal

55:26.820 --> 55:27.820
它一定有这个东西

55:27.820 --> 55:28.820
一定有这个东西

55:28.820 --> 55:30.820
它什么叫实验的

55:30.820 --> 55:31.820
ABC

55:31.820 --> 55:32.820
给它一个E23

55:32.820 --> 55:33.820
保存

55:36.640 --> 55:38.640
然后当我们受到小许

55:38.640 --> 55:39.640
是不是得到E23了

55:40.640 --> 55:41.640
对不对

55:41.640 --> 55:42.640
就得到这个E23了

55:42.640 --> 55:44.640
这个地方是这个数数的

55:44.640 --> 55:46.640
这个玩意是这个数数

55:47.640 --> 55:48.640
那么就是它实验的

55:48.640 --> 55:49.640
InventAmmetal

55:49.640 --> 55:50.640
随便是个写个实验名

55:50.640 --> 55:51.640
引发实验

55:51.640 --> 55:52.640
那么这个东西

55:52.640 --> 55:53.640
就连接到什么了

55:53.640 --> 55:54.640
连接到全局

55:54.640 --> 55:55.640
这是全局

55:55.640 --> 55:56.640
对吧

55:56.640 --> 55:58.640
已经每一次响应

55:58.640 --> 55:59.640
那么每一次响应

55:59.640 --> 56:01.640
可以通知一个消息到全局

56:01.640 --> 56:03.950
好了

56:03.950 --> 56:05.950
那么这就是

56:05.950 --> 56:07.950
Q&A里边的

56:07.950 --> 56:08.950
API

56:08.950 --> 56:09.950
不要去背

56:09.950 --> 56:10.950
东西有点多

56:10.950 --> 56:11.950
我背吧

56:11.950 --> 56:12.950
我绝对不背

56:12.950 --> 56:13.950
这东西我讲完了

56:13.950 --> 56:14.950
我就忘了

56:14.950 --> 56:15.950
但是我写的时候

56:15.950 --> 56:16.950
我又想起来了

56:16.950 --> 56:17.950
或者我想不起来

56:17.950 --> 56:18.950
我就看文章

56:18.950 --> 56:19.950
没有什么大不了

56:19.950 --> 56:20.950
不要去背

56:20.950 --> 56:21.950
记住它的核心理念

56:21.950 --> 56:22.950
它的原理

56:22.950 --> 56:23.950
这些东西是关键

56:23.950 --> 56:24.950
好了

56:24.950 --> 56:25.950
那么这些看文

56:25.950 --> 56:26.950
重要的点

56:26.950 --> 56:27.950
就是关于这一块

56:27.950 --> 56:28.950
这一块都要知道

56:28.950 --> 56:29.950
因为我上一课

56:29.950 --> 56:30.950
是不是讲了

56:30.950 --> 56:31.950
三个差一点

56:31.950 --> 56:32.950
那么这个是不是第四个

56:32.950 --> 56:33.950
第四个差一点

56:33.950 --> 56:34.950
好

56:34.950 --> 56:36.950
那么下后边两节课

56:36.950 --> 56:37.950
大部分我打算

56:37.950 --> 56:38.950
打算用两节课

56:38.950 --> 56:39.950
后边两节课

56:39.950 --> 56:40.950
我打算这样子来做

56:40.950 --> 56:41.950
第一节课

56:43.950 --> 56:45.950
熟悉一些中间线

56:45.950 --> 56:47.950
有点随便找一些

56:47.950 --> 56:48.950
找几个例子

56:48.950 --> 56:49.950
或者找一个例子就够了

56:49.950 --> 56:50.950
然后呢

56:50.950 --> 56:51.950
最后一节课

56:51.950 --> 56:52.950
我给大家介绍一下

56:52.950 --> 56:53.950
Q&A里边有哪些

56:53.950 --> 56:54.950
常用的中间线

56:54.950 --> 56:55.950
他们能做什么事情

56:55.950 --> 56:57.950
我们可以去看一下就行了

56:57.950 --> 56:58.950
或者是根本不用去看

56:58.950 --> 57:00.950
你在工作中

57:00.950 --> 57:02.950
用到老过后再说

57:02.950 --> 57:03.950
或者是在学习的过程中

57:03.950 --> 57:04.950
可以玩一玩都可以

57:04.950 --> 57:05.950
好

57:05.950 --> 57:06.950
最后我们到这了

