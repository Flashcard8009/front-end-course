WEBVTT

00:00.240 --> 00:03.240
好 来吧 把这个中间键说了

00:04.240 --> 00:07.240
中间键这一括呢 我不打算一个一个讲啊

00:07.240 --> 00:10.240
平时我们ka里边的用了中间键呢 也就这么一些

00:10.240 --> 00:13.240
但是呢 一个个讲没有什么意义了

00:13.240 --> 00:17.240
为啥呢 回顾一下啊 咱们学到学过的知识

00:17.240 --> 00:20.240
你看咱们之前在学习的任何知识的时候

00:20.240 --> 00:22.240
特别是你第一次接触的时候

00:22.240 --> 00:25.240
咱们一定是把这个原理部分给大家讲清楚了的

00:25.240 --> 00:28.240
包括我在路德街市里边说讲了个express的时候

00:28.240 --> 00:31.240
各种应用场景 对吧 我们首先是讲问题

00:31.240 --> 00:35.240
有什么问题啊 那么用什么样的方式去实现它

00:35.240 --> 00:38.240
那么这个方式呢 是跟具体的技术无关的

00:38.240 --> 00:42.240
你跟利用express来做和用ka来做

00:42.240 --> 00:45.240
它的原理部分都是一样的啊

00:45.240 --> 00:48.240
而且呢 我们现在也学过了ka到底是一个什么

00:48.240 --> 00:51.240
这样的东西 它的中间键的模型到底是什么样子的

00:51.240 --> 00:54.240
因此呢 现在就差最后一个东西了 有什么api

00:54.240 --> 00:57.240
对不对 你看这些中间键啊 解决这些问题

00:57.240 --> 01:00.240
像这个rotor 对吧 它是模拟那个express的rotor

01:00.240 --> 01:04.240
是不是解决同样的问题 对吧 解决的问题都是一样的

01:04.240 --> 01:07.240
原理呢也是一样的 只是呢api呢

01:07.240 --> 01:10.240
可能会有一点差异 甚至呢 很多时候api都没有差异

01:10.240 --> 01:14.240
因此呢 像这些东西没后必要 真的是没后必要一个去讲了

01:14.240 --> 01:17.240
那怎么办呢 怎么用呢 大家就插越这个文档就行了

01:17.240 --> 01:20.240
比方说现在我们的express在ka里边

01:20.240 --> 01:23.240
不是还没有路由吗 对不对

01:23.240 --> 01:25.240
因为我们ka里边只有使用中间键

01:25.240 --> 01:28.240
就中间键的时候呢 还不能给定这个就是路径

01:28.240 --> 01:31.240
没有路径这个东西 直接用中间键

01:31.240 --> 01:33.240
任何请求都会经过这个中间键

01:33.240 --> 01:35.240
所以说呢 我们就需要一个的路由

01:35.240 --> 01:38.240
这个路由里边其他的原理特别特别简单

01:38.240 --> 01:42.240
原理很简单的 就是你到了路由这个中间键过后

01:42.240 --> 01:44.240
路由里边 它根据它的配置

01:44.240 --> 01:47.240
什么路径 运行什么样的函数 什么路径 运行什么样的函数

01:47.240 --> 01:50.240
就完事了 这就是它的核心原理

01:50.240 --> 01:53.240
因此呢 我们直到原理过后呢 只需要去使用它就完事了

01:53.240 --> 01:56.240
那具体怎么使用 就可以看它的官方文档

01:56.240 --> 02:00.240
当然有同来说 官方文档呢 它是英文的啊 看上去投通

02:00.240 --> 02:03.240
那没关系啊 你没有让你去读这个英文文档

02:03.240 --> 02:06.240
那怎么看呢 你就读它的这个实例就行了

02:06.240 --> 02:11.240
比方说像这个API reference 它这里边有一个就是API文档嘛

02:11.240 --> 02:13.240
点击进去 你可以看到啊

02:13.240 --> 02:15.240
它这里边呢 就有一些实例

02:15.240 --> 02:17.240
把个代码一看 你基本上就明白了

02:17.240 --> 02:19.240
它怎么回事了 你看吧

02:19.240 --> 02:22.240
导入这个rotor 扭一个rotor 跟那个express 是不是一样的

02:22.240 --> 02:25.240
express 是不是导入一个rotor 然后扭一个rotor

02:25.240 --> 02:27.240
然后后边是不是配置 是吧

02:27.240 --> 02:30.240
这些诗路写法跟express是一样的 它还用说吗

02:30.240 --> 02:32.240
那最后怎么来应用这个中间键呢

02:32.240 --> 02:33.240
API use

02:33.240 --> 02:35.240
rotor里边有个函数叫rote

02:35.240 --> 02:38.240
通过调用这个函数 它会返回一个koa的中间键

02:38.240 --> 02:40.240
那么用了就完事了

02:40.240 --> 02:42.240
因为它说 后边怎么还用呢

02:42.240 --> 02:44.240
那么后边又点了一个use 说明了啥

02:44.240 --> 02:48.240
说明了在koa里边 它的use返回的是啥

02:48.240 --> 02:50.240
是不是还是这个app对象

02:50.240 --> 02:52.240
对吧 它是可以用练识调用的

02:52.240 --> 02:54.240
只是我们前面没有用而已

02:54.240 --> 02:56.240
那么这边我们又可以用一个中间键

02:56.240 --> 02:58.240
那么这个中间键是什么 error message

02:58.240 --> 03:00.240
因为它说就很好奇

03:00.240 --> 03:02.240
其实我们后边这个没有必要用了

03:02.240 --> 03:03.240
用前面的够了

03:03.240 --> 03:05.240
后边这个东西 有些人就好奇

03:05.240 --> 03:06.240
那这个玩意是什么呢

03:06.240 --> 03:08.240
那我如何在文章里边查询的

03:08.240 --> 03:09.240
一个非常简单的方式就是

03:09.240 --> 03:11.240
你把这个玩意复制一下

03:11.240 --> 03:13.240
error message复制一下

03:13.240 --> 03:16.240
contr加f 然后来找

03:16.240 --> 03:18.240
找到什么 找到这个error message的解释

03:18.240 --> 03:20.240
那它这里可以解释了

03:20.240 --> 03:22.240
对不对 是不是可以解释了

03:22.240 --> 03:24.240
那么这个解释 有些人因为看不懂

03:24.240 --> 03:27.240
翻译呗 总能找到办法了对不对

03:27.240 --> 03:28.240
那么其实你不用翻译

03:28.240 --> 03:30.240
都看了关键字什么

03:30.240 --> 03:33.240
options 让你想到了啥

03:33.240 --> 03:36.240
options 让你想到了啥

03:36.240 --> 03:39.620
想应给什么

03:39.620 --> 03:41.620
options的请求

03:41.620 --> 03:42.620
options的请求是啥

03:42.620 --> 03:44.620
是不是就是跨域的东西

03:44.620 --> 03:46.620
那么这个东西是不是跟跨域有关系的

03:46.620 --> 03:47.620
对不对

03:47.620 --> 03:49.620
就是跟跨域有关系的

03:49.620 --> 03:50.620
那么我们这里呢

03:50.620 --> 03:51.620
跟跨域 如果说你

03:51.620 --> 03:52.620
跟跨域你用

03:52.620 --> 03:53.620
我们之前

03:53.620 --> 03:55.620
这里还有一个中间键

03:55.620 --> 03:57.620
叫做CORS

03:57.620 --> 03:59.620
这个专门来处理跨域的中间键

03:59.620 --> 04:00.620
那么这个东西

04:00.620 --> 04:01.620
如果说你不想用它来

04:01.620 --> 04:03.620
跟跨域产生任何关系的话

04:03.620 --> 04:05.620
那么你不许使用它就完事了

04:05.620 --> 04:07.620
好 那么现在我们来用一下吧

04:07.620 --> 04:08.620
比方说你看到这个东西

04:08.620 --> 04:10.620
其实就很简单了

04:10.620 --> 04:11.620
我们去安装一下

04:11.620 --> 04:17.520
对 打开

04:17.520 --> 04:19.520
然后让我们安装一下

04:19.520 --> 04:20.520
安装

04:20.520 --> 04:22.520
这个库的名字叫做

04:22.520 --> 04:24.520
KOA Rotor

04:24.520 --> 04:26.520
KOA Rotor

04:26.520 --> 04:27.520
给大家说一下

04:27.520 --> 04:29.520
有一个

04:29.520 --> 04:30.520
尝试性的东西

04:30.520 --> 04:31.520
就是你安装一个包的时候

04:31.520 --> 04:32.520
一个库的时候呢

04:32.520 --> 04:34.520
你会发现它前面有个AT

04:34.520 --> 04:36.520
这个东西叫做秘密空间

04:36.520 --> 04:37.520
把我们以前讲过

04:37.520 --> 04:38.520
MPM的时候

04:38.520 --> 04:40.520
说过这个东西叫秘密空间

04:40.520 --> 04:41.520
那么这个秘密空间

04:41.520 --> 04:42.520
那就比较一般来说

04:42.520 --> 04:44.520
就表示的一个主库

04:44.520 --> 04:45.520
一个主库

04:45.520 --> 04:47.520
或者是一个公司的名字

04:47.520 --> 04:48.520
那这个KOA呢

04:48.520 --> 04:49.520
用这个秘密空间

04:49.520 --> 04:50.520
那么可以想象

04:50.520 --> 04:53.520
它肯定是官方出的一个库

04:53.520 --> 04:55.520
官方出的一个库叫Rotor

04:55.520 --> 04:56.520
那么这个库呢

04:56.520 --> 04:58.520
它其实以前叫KOA Rotor

04:58.520 --> 04:59.520
叫做这个库

04:59.520 --> 05:00.520
那么它接下来这个库

05:00.520 --> 05:02.520
也把它封装了一下

05:02.520 --> 05:03.520
好 我们这里回车

05:03.520 --> 05:05.520
安装一下这个库

05:05.520 --> 05:06.520
安装好了之后呢

05:06.520 --> 05:08.520
我们在这边去使用它

05:08.520 --> 05:10.520
我们跟那个Express一样

05:10.520 --> 05:11.520
也可以专门写个文件夹

05:11.520 --> 05:13.520
写一些文件来做路由

05:13.520 --> 05:14.520
比方说我们在这里写上

05:14.520 --> 05:16.520
一个Rote文件夹

05:16.520 --> 05:17.520
然后呢 这边写上一个

05:17.520 --> 05:19.520
比方说User.js

05:19.520 --> 05:25.520
这边我们导入RotorRequire

05:25.520 --> 05:28.520
然后呢 这里留一个Rotor

05:28.520 --> 05:32.980
Module Export

05:32.980 --> 05:33.980
导入Rotor的什么

05:33.980 --> 05:34.980
Rote

05:34.980 --> 05:37.980
这样子是不是返回个中间线

05:37.980 --> 05:38.980
刚才我们看到了

05:38.980 --> 05:39.980
灵活处理就行了

05:39.980 --> 05:40.980
那么这里可以看到

05:40.980 --> 05:41.980
这个玩意是不是中间线

05:41.980 --> 05:42.980
对吧 我们把个中间线

05:42.980 --> 05:43.980
导出就完事了

05:43.980 --> 05:44.980
好了

05:44.980 --> 05:45.980
那么这边呢

05:45.980 --> 05:46.980
是不是可以配置各种琴球了

05:46.980 --> 05:47.980
比方说Gate

05:47.980 --> 05:48.980
Gate的琴球比方说

05:48.980 --> 05:50.980
你请求API

05:50.980 --> 05:51.980
User

05:51.980 --> 05:52.980
后面要跟个ID

05:52.980 --> 05:54.980
然后我给你得到一个用户

05:54.980 --> 05:55.980
当然这个用户呢

05:55.980 --> 05:56.980
可以从数据户里面去查

05:56.980 --> 05:58.980
不过呢 我这里没有数据户

05:58.980 --> 05:59.980
我就随便写了

05:59.980 --> 06:00.980
好吧 这边呢

06:00.980 --> 06:01.980
我们怎么来处理呢

06:01.980 --> 06:03.980
当然这里还有一个Nex

06:03.980 --> 06:04.980
你要用的话就用

06:04.980 --> 06:05.980
不需要

06:05.980 --> 06:06.980
后面一要的话就不需要用了

06:06.980 --> 06:07.980
好 我们这里呢

06:07.980 --> 06:09.980
我们比方说Context

06:09.980 --> 06:12.980
这里得到输出嘛

06:12.980 --> 06:13.980
输出Context

06:13.980 --> 06:14.980
Parrance的ID

06:14.980 --> 06:16.980
那这个玩意是不是得到

06:16.980 --> 06:17.980
这个ID

06:17.980 --> 06:18.980
对不对

06:18.980 --> 06:19.980
好 那么我这里发挥

06:19.980 --> 06:20.980
一个响应

06:20.980 --> 06:21.980
响应说给Body复制

06:21.980 --> 06:23.980
比方说User

06:23.980 --> 06:24.980
LoginID

06:24.980 --> 06:27.980
乘个Nate

06:27.980 --> 06:31.420
乘个Az

06:31.420 --> 06:32.420
是吧

06:32.420 --> 06:33.420
这样子就完事了

06:33.420 --> 06:34.420
对不对

06:34.420 --> 06:35.420
这就是一个路由

06:35.420 --> 06:36.420
好了 那么这边

06:36.420 --> 06:38.420
准备去使用它的User

06:38.420 --> 06:40.420
然后这里Require

06:40.420 --> 06:41.420
Rows

06:41.420 --> 06:42.420
下边来什么呢

06:42.420 --> 06:43.420
User

06:43.420 --> 06:45.420
就使用完了

06:45.420 --> 06:46.420
MPVSTART

06:46.420 --> 06:47.420
运行出来

06:47.420 --> 06:49.420
好 接下来到浏览器里边去看一下

06:49.420 --> 06:50.420
Nokahost

06:50.420 --> 06:51.420
9527

06:51.420 --> 06:52.420
API

06:52.420 --> 06:53.420
User

06:53.420 --> 06:55.420
哎 好 还敢

