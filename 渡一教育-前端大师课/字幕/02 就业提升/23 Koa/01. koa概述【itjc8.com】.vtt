WEBVTT

00:00.430 --> 00:03.390
来吧 怎么样啊 还学动啊

00:04.670 --> 00:14.670
咱们前段就是这样子啊 东西是挺多的 但是呢 前段的东西呢 大部分是应用层面的 啊 应用层面 就是应用层面的东西呢

00:16.470 --> 00:23.070
是比较简单的啊 因为很多同学呢 可能会觉得应用 咱们前段东西很多 每个东西都很复杂

00:23.510 --> 00:30.350
实际上你仔细观察呢 你会发现前段很多东西都是相通的 比方数据库吧 咱们学了什么呢 数据库 数据库学了

00:30.910 --> 00:40.870
埋涉口 学到什么呢 芒果DB 啊 学到什么呢 学到还有数据库 对吧 那么其实你学了一个数据库过后再去学另外的其他数据库了

00:41.390 --> 00:49.510
基本上就差不多了 因为他们的书下说变化很大 但是呢 他们很多道理呢 是相通的 比方说都有什么了 都有驱动

00:50.270 --> 00:54.470
对不对 都有什么呢 还有一些像芒果DB和埋涉口 是不是都有模型

00:55.270 --> 01:03.750
对吧 芒果DB里面可以是不是可以那一笔 它的什么 它的那个文档相当于是埋涉口里面的表 这都可以那一笔的

01:04.630 --> 01:12.750
就是我们学习技术 最重要的是什么呢 最重要的是要理解原理 理解他的模型 理解他的原理 理解他的结构

01:13.470 --> 01:15.670
然后其次才是他的api

01:16.550 --> 01:21.750
API这东西呢 你忘了 我都说了 忘了API其实无所谓的 因为你只要查文档就可以查出来

01:22.110 --> 01:25.630
但是原理你如果说你忘了就很麻烦了 因为他就不是

01:26.630 --> 01:27.870
几分钟 或者是

01:29.230 --> 01:34.150
几十分钟能搞定的事情 他需要一些知识的沉淀和

01:34.830 --> 01:43.430
代码的沉淀 你才能慢慢去理解原理 原理是最重要的 你像咱们把ADP原理学习了过后呢 再去学习别的东西就非常轻松了

01:44.030 --> 01:48.590
包括我们这门客 kua 也是一样的 kua 他是作为

01:49.790 --> 01:54.950
一个新一代的web服务器框架 他是用于替代什么的替代xpress的

01:55.710 --> 02:00.230
所以说我们在学习kua的时候呢 我们已经学习过了xpress

02:00.910 --> 02:07.830
需不需要把xpress里边所有东西全 需不需要把kua里边所有东西全部讲一遍了 不需要 你看咱们之前讲xpress的时候

02:08.190 --> 02:11.750
我记得是第四个章节 对吧 那个结实 我讲了多少节目呢

02:12.070 --> 02:14.430
我好像讲了二十多节课

02:15.630 --> 02:21.310
然后这里边有非常非常多的场景 那么这些场景呢我是不是要用kua全部重新去做一遍了

02:22.030 --> 02:26.870
没必要 为啥没必要呢 因为kua和那个xpress在对比的话

02:27.670 --> 02:33.910
哪去和一个space在对比 那么我们会发现他里边有很多都是相通的 比方说kua他

02:34.830 --> 02:39.590
就算怎么无论他怎么变 attb协议不能变吧 这个玩意不能变吧

02:40.310 --> 02:44.070
还有什么不能变 还有那些就比方说啊 他里边

02:44.910 --> 02:46.110
一个是attb协议啊

02:46.910 --> 02:50.790
还有什么的 还有他也是基于loaded.js的吧loaded.js他没有变化吗

02:51.590 --> 02:57.350
还有什么的 他用到loaded.js里边哪个模块的 他内部使用的是attp模块 对吧 用的是这个模块

02:57.830 --> 03:06.270
所以也没有变化 而且kua那是基于中间键的 那么他的中间键呢他的使用上跟xpress差不多 所以说中间键

03:06.830 --> 03:08.110
我们不用去重新讲了吧

03:09.110 --> 03:17.830
很多东西都是相通的 而且像我们的常见常境 你看啊 我们回忆一下啊 咱们之前的常见常境每一节课讲的时候

03:18.390 --> 03:25.030
是不是都给大家说到原理的 就是说他的adp协议里边 他是怎么回事 那么我们如何再用xpress去实现

03:25.270 --> 03:28.470
也就是说 你只要知道他的原理 无论用什么技术

03:29.270 --> 03:35.950
他都能实现 xpress能实现 你以后如果说结束了加达加达也能实现 这下php都能实现 拍摄都能实现

03:36.830 --> 03:44.990
他都是去实验他的原理的 包括kua他也去用这个adp原理去实现这些常见常境 比较什么缓存啊 cookie啊事情啊 对吧

03:45.270 --> 03:48.830
都是基于这么这么一些东西 所以说常见常境怎么不讲了

03:49.590 --> 03:51.750
所以因此呢 我们去掉这些东西过后呢

03:52.510 --> 03:58.510
你再看kua他就很简单了 就是几个api一学习完事了 而且kua的api是非常简单的

04:00.350 --> 04:04.510
因此我们这门客讲kua他不会像express那样子 罗里巴说了

04:04.990 --> 04:09.390
讲一大堆 我们就简单的说一下 他跟kua和express的重要区别

04:10.190 --> 04:12.590
他为什么会出现 他到底为了解决什么样的问题

04:13.230 --> 04:15.870
以及呢 他里边的一些常见的api的用法

04:16.510 --> 04:23.510
以及呢 他的一些常见的中间键 我给大家列个表格出来啊 那么大家可以去查阅这些中间键 随便再讲几个调几个出来讲

04:23.870 --> 04:27.030
那么这些场景呢 你们就不用管了啊 我们在具体的

04:27.470 --> 04:34.430
开发中 如果说遇到了类似的场景 咱们去百度收一收 或者是看一下我的和给大家提供的文档里面 有没有对应的中间键能解决就完事了

04:35.070 --> 04:38.430
因此我们学习人家用这种方式来学 不然的话 你全去

04:39.150 --> 04:44.190
全去关注应用层面的东西完全不关注原理啊 就知道只需要知道怎么用就行了

04:44.270 --> 04:47.150
你会越学越痛苦 因为东西成出不穷越来越多

04:47.550 --> 04:50.750
现在是2020年你看到2021年又一大堆技术出来了

04:51.150 --> 04:56.670
两今年2020年就会出现无忧3.0 对吧 有很大的变化 还有什么呢 还有那个

04:57.790 --> 04:58.190
呃

04:59.150 --> 05:00.990
为派格无啊 也变化不小

05:01.550 --> 05:06.910
这些东西的经常都在变 但是变化了也只是应用层面 他的核心思路思想是没有变的

05:07.550 --> 05:12.670
好 说了这么多 咱们开始来学习这个kl啊 这几个呢 我们不设计到任何的代码编写

05:13.310 --> 05:17.550
只是来讲解 aka他为什么会出现他要解决什么问题 你看我们讲课都是要

05:18.670 --> 05:24.110
反复的题他为什么会出现他要解决什么样问题他的原理是什么 对吧 把这些东西核心的东西要理解清楚

05:24.430 --> 05:28.190
然后呢 其次才是ap 啊 咱们来看一下啊 所以他的官网

05:29.470 --> 05:32.910
官网呢 现在的官网这几天啊

05:33.870 --> 05:40.030
现在是2020年6月份 你们懂的啊 今年的2020年注定是一个不平凡的年 发生了很多

05:40.910 --> 05:48.430
大事啊 应该是有些有些上的近应该说是几百年啊 或者说说短一点啊 100年或者是50年内

05:48.910 --> 05:54.350
都不太会遇到的大事 原来现在最近这些技术网站啊 他们都变成了黑白的风格了

05:54.670 --> 05:57.870
而且呢 上面都加了一句话叫black lives matter

05:58.910 --> 06:04.590
support equal justice initial 打赌的 就是关注黑人的生命

06:05.310 --> 06:11.390
只此事法公正啊 这是对应了啥呢 对应到最近美国发生的这个美帝的风景线对不对

06:12.110 --> 06:16.910
啊 我们看我下看看啊 这是ka的官网网站 他里边的就一个网页 其他都没了

06:17.790 --> 06:21.550
也就他的api啊 就一个网页就搞定了 所以说他东西并不多

06:22.030 --> 06:25.790
而且你看这里有目录 目录的话也就是在这个网页里边用某链接翻来翻去的

06:26.270 --> 06:29.150
啊 因此还有他的他的这个中文网

06:29.870 --> 06:32.110
ka啊 明年中文网的也是一样

06:32.910 --> 06:35.150
啊 只有一个网页 那种并不多啊

06:35.790 --> 06:38.030
嗯 他怎么回事呢 他是一个微博框架

06:38.750 --> 06:42.830
也就是说他也是跟xpress是一样 他是xpress原办怎么打造的

06:43.470 --> 06:50.990
那就奇了怪了 xpress用的好好的 干嘛要去搞出一个ka呢 是因为xpress里边呢 他有一些问题呢得不到解决

06:51.470 --> 06:55.630
xpress他出现的比较早啊 路德结石出现过后了不久他就出现了xpress

06:56.190 --> 07:02.990
那么xpress出来之后呢 当时还没有出现es6 也就是还没有在2015年之前啊 还没有es6

07:03.550 --> 07:07.870
那么也就意味着呢 xpress他是无法考虑到将来会出现promise

07:08.110 --> 07:14.190
这样的api 也无法预料到将来会出现esync和预测这两个关键制

07:14.830 --> 07:19.550
由于他对这两个无法认无法预料到 因此造成一个什么问题呢

07:20.030 --> 07:21.790
他里边对一部的中间键

07:22.350 --> 07:26.030
支持不是很好啊 这些同学就开始提有疑问了

07:26.510 --> 07:30.830
因为老师你说xpress对一部中间键支持不是很好

07:31.390 --> 07:37.630
但是呢 我不这样子看 为啥呢 因为xpress里边呢 他不是可以支持一部吗

07:41.540 --> 07:43.460
这代码见过没 见过了吧

07:44.740 --> 07:51.780
或者说没有见过吧 你学了这么久xpress了啊 讲了20多节目了 应该肯定是见过了 对吧 他里边知不知是一部 肯定是一部对对

07:53.620 --> 07:59.460
那为什么说他对一部支持不是很好呢 我们一会就看到了啊 确实有些地方有问题

08:00.100 --> 08:03.540
啊 这是这个地方 他主要是一部支持不是很好

08:04.340 --> 08:06.660
呃 因此呢 基于这个重要的原因

08:07.380 --> 08:11.060
xpress的开发者他发现 要去改动的话 有点麻烦

08:11.300 --> 08:14.100
因为你要改动的话 你就必须要兼容以前的版本

08:14.340 --> 08:18.420
而以前的版本要去做兼容的话 就就麻烦了 他肯定是要大量的API改动

08:18.820 --> 08:24.820
所以说呢 他干脆啊 就抛弃了xpress框架 也不说抛弃吧 就就做了一个新的框架就是KVA

08:26.100 --> 08:31.620
也就是KVA的功能了 跟xpress一样 他主要是为了解决xpress里边的异部处理的问题

08:31.780 --> 08:37.460
他目前的版本呢 是KVA2 我这里说一下啊 KVA2和KVA1有什么区别

08:37.780 --> 08:43.860
现在基本上都用的是KVA2了 一的话 他是当一出来的时间 那是刚刚好

08:44.100 --> 08:48.660
也是溜出来的时间 那么那个时候呢 他是用的generator

08:48.900 --> 08:51.860
还记得吗 就是Retard是里边的 Retard是Saga

08:52.100 --> 08:57.220
他里边用的那种方式 就generator 就是用那个迭代器的那种方式来做的那个

08:57.380 --> 09:00.500
用生成器的那种方式来处理异部的

09:00.740 --> 09:05.700
而后来呢也是7里边出来的Async而位置 那么他KVA2呢就马上跟上了

09:05.940 --> 09:10.740
他就做成 他就把他支持了 支持成了Async和位置

09:10.980 --> 09:14.180
这是关于KVA到底是个什么东西 好 现在是对比的

09:14.580 --> 09:18.980
因为你们在以后面试的时候 会经常面试问问你

09:19.220 --> 09:22.820
KVA和xpress他们之间到底有什么样的区别

09:22.980 --> 09:26.980
以及KVA的优势在哪 那么你就可以从这个上面 三个方面去回答

09:27.380 --> 09:30.900
这三个方面呢 最重要的就是第三个 我们一会儿详细讲

09:31.140 --> 09:32.740
好 第一个 更轻量

09:33.300 --> 09:34.100
啥意思呢

09:34.340 --> 09:39.460
因为我们在xpress里的使用过程中 你可以看到xpress里边他是不是给你提供了很多的API

09:39.700 --> 09:43.060
哪些API我们随便举一些例子啊 比方说use

09:43.540 --> 09:47.780
还有什么呢 还有他里边有什么get post

09:47.940 --> 09:50.740
还有他里边有什么get post

09:52.020 --> 09:54.500
对不对 他是不是还有这些东西 还有什么呢

09:56.100 --> 10:00.820
还有就是他里边还是不是给你提供了xpress里边 还给你提供了Static

10:00.900 --> 10:04.180
对吧 内置的一些中间键 对吧 还有什么呢 xpress

10:04.580 --> 10:06.020
uil encoded

10:06.660 --> 10:08.340
解析消息体的

10:09.060 --> 10:12.020
接受对吧 解析消息体的 还有什么rotor

10:12.820 --> 10:16.820
对吧 所以给你提供了一些内置的中间键 那么这些东西呢在KVA里边都不存在

10:17.380 --> 10:18.180
啊 均不存在

10:20.180 --> 10:25.780
看一下啊 这些东西KVA里边没有内置的中间键 他为什么不内置啊呢 因为他考虑到

10:25.940 --> 10:28.020
他xpress他就得到了经验了

10:28.420 --> 10:34.340
哦 我这个东西出来过后呢 有这么强大的社区 那么这些社区他们会自己做一些非常优质的中间键

10:34.740 --> 10:37.540
啊 反正我是开源的嘛 让里面社区去搞定

10:37.940 --> 10:39.060
因此KVA啊

10:39.700 --> 10:40.980
他的API极少

10:41.620 --> 10:43.780
他就一个怎么了 就一个中间键处理模型

10:44.580 --> 10:45.700
啥意思呢 就这个

10:46.420 --> 10:49.300
比方说这里 在KVA里边呢 他只有这个东西

10:51.300 --> 10:52.020
又没了

10:52.820 --> 10:59.140
而且呢 他这里都不能不能不允许书写路径的啊 这里没有什么路径 他直接就是个中间键

11:00.980 --> 11:03.220
啊 直接就是就是个中间键 迷到位了

11:05.570 --> 11:06.530
没了意思吧

11:06.530 --> 11:11.970
KVA里边没有内置任何中间键 他全要你自己去写 当然你可以从社区上去下载一些已经写好的

11:11.970 --> 11:12.770
的一种连接

11:12.770 --> 11:15.250
对吧 KVA他只是给你搭了一个中间键模型

11:15.650 --> 11:16.930
其他东西少都没有 这个东西少

11:17.010 --> 11:19.250
啥都没有 更也不存在这些东西

11:19.250 --> 11:22.530
Gate Pulse Pulse都不存在 也没有路径书写

11:22.530 --> 11:24.930
说KVA的API要简化很多很多

11:25.330 --> 11:28.370
他这些东西全部交给社区 交给生态去完成了

11:28.850 --> 11:30.690
说KVA他是特别依赖生态的

11:31.330 --> 11:33.650
没有内置中间键 也没有提供路由匹配

11:34.690 --> 11:36.530
这是第一个特点 第二个特点

11:37.090 --> 11:39.410
更合理的对象结构 这个东西怎么理解呢

11:40.050 --> 11:42.610
在Express里面呢 我们常用的对象就这么一些

11:42.850 --> 11:43.570
一个是App

11:44.290 --> 11:45.810
一个是rig rig race

11:46.530 --> 11:51.410
Apple是什么呢 就是我们创建了Express的实力

11:51.810 --> 11:52.530
就这个玩意

11:55.680 --> 11:59.040
就这个玩意 比方说咱们在Express里面重新写个吧

12:00.160 --> 12:01.360
我们是不是得到这么一个东西

12:02.000 --> 12:03.040
Express对吧

12:03.200 --> 12:04.160
这个Apple就是这个东西

12:04.480 --> 12:06.320
那么这个玩意我们按照以前的习惯

12:06.320 --> 12:08.640
你是不是我们一个网站就一个

12:09.120 --> 12:09.520
对不对

12:10.240 --> 12:12.240
哪怕你一天收到一千万个请求

12:12.240 --> 12:14.560
那我还是都用的是同一个他的监听

12:14.800 --> 12:15.200
对不对

12:15.200 --> 12:16.000
是这么一个逻辑

12:16.960 --> 12:19.760
因此在Express里面呢 他只有一个App

12:20.160 --> 12:22.400
所以说任何请求都会被他处理

12:22.880 --> 12:24.320
所以他是跨越请求的

12:24.320 --> 12:25.760
因此呢 我们在Express里面

12:26.000 --> 12:27.920
如果说有什么样的共享的

12:28.320 --> 12:29.920
在请求之间共享的数据

12:30.160 --> 12:31.440
我们可以放到这个App里面

12:32.000 --> 12:32.720
这是个对象

12:33.120 --> 12:34.960
这个对象呢 我们用的还稍微少一点

12:35.040 --> 12:37.440
用的最多的是后面这两个rig race

12:37.840 --> 12:39.280
每一个请求来了之后

12:39.280 --> 12:40.720
他会运行一个函数对不对

12:40.720 --> 12:42.000
函数是不是有两个参数

12:42.000 --> 12:43.600
一个人请求对象

12:43.600 --> 12:44.800
一个想用对象

12:45.600 --> 12:46.080
对吧

12:46.080 --> 12:48.080
分辨用来或许请求里边的信息

12:48.080 --> 12:49.280
分辨用来作出想用

12:49.840 --> 12:51.840
每一个请求他都会对应两个

12:52.000 --> 12:52.960
每一个请求之间

12:52.960 --> 12:54.960
他们的两个是互不干擾的

12:55.200 --> 12:56.320
都是两个新的对象

12:56.640 --> 12:57.920
这就是他的模型

12:58.080 --> 12:59.760
那么这样的模型有什么样的问题呢

13:00.480 --> 13:02.400
按理说他其实也没多少多大的问题

13:02.400 --> 13:03.440
但是有一些小问题

13:04.480 --> 13:05.040
有些小问题

13:05.040 --> 13:06.880
这些小问题对一些强迫症患者

13:06.880 --> 13:08.960
比方说我这种人就不是很舒服

13:09.120 --> 13:10.400
比方说不要说一个例子

13:11.920 --> 13:13.200
我这里使用一个中间键

13:13.920 --> 13:15.360
中间键这么写的

13:17.360 --> 13:18.400
大家理解就行了

13:19.280 --> 13:20.960
我这里就不运行了

13:21.520 --> 13:23.360
这个中间我们以前也写过

13:23.360 --> 13:24.400
用来干嘛的呢

13:24.400 --> 13:27.120
用来获取当前用户的登录的对象

13:28.400 --> 13:33.040
用于获取当前登录的用户对象

13:33.520 --> 13:34.720
因为后续的中间键

13:34.720 --> 13:36.560
他有一些中间键他需要知道

13:37.120 --> 13:38.720
我当前用户有没有登录

13:38.960 --> 13:40.560
当前登录的到底是哪一个用户

13:40.640 --> 13:44.080
这个用户有没有权限操作我这个数据

13:44.400 --> 13:44.960
还有就是

13:46.000 --> 13:47.440
比方说我要得到用户信息

13:47.440 --> 13:49.280
那我知道我要知道当前用户是谁

13:50.400 --> 13:51.680
比方说我要发布一篇文章

13:51.680 --> 13:53.040
我得知道当前的用户是谁

13:53.040 --> 13:54.240
到底是谁发布的

13:54.240 --> 13:55.520
那么我们就可以写个中间键

13:56.240 --> 13:57.600
在所有的请求到来之前

13:57.600 --> 13:59.600
就是在处理其他中间键之前

13:59.600 --> 14:01.600
我们先获取到当前登录的用户

14:01.600 --> 14:02.800
那么我们以前打过去的

14:03.360 --> 14:05.120
从Cookie里面取出了什么

14:05.840 --> 14:06.560
取出了Token

14:07.440 --> 14:09.440
然后从Token里面解析出用户ID

14:10.160 --> 14:11.760
然后从用户ID里面打到

14:11.760 --> 14:13.520
从数据口里面查询出什么

14:13.520 --> 14:14.640
查询出用户对象

14:14.640 --> 14:15.680
那么比方说

14:15.680 --> 14:20.240
现在拿到了用户对象

14:21.360 --> 14:23.520
保存到了变将

14:24.000 --> 14:24.720
EU中

14:24.720 --> 14:25.920
比方说我们做到这件事

14:25.920 --> 14:27.040
已经拿到了用户对象

14:27.040 --> 14:28.480
从数据口里面拿到

14:28.960 --> 14:29.760
然后拿到过后

14:29.760 --> 14:31.440
我们保存到了变将EU里面

14:31.440 --> 14:32.640
然后接着我们怎么写的

14:32.640 --> 14:33.680
我觉得还是这样子写的

14:37.310 --> 14:37.950
对吧

14:37.950 --> 14:39.070
那么后续的中间键

14:39.070 --> 14:40.910
是不是可以获取到这个Rick的U字

14:41.070 --> 14:42.510
可以获取到当前登录的用户

14:42.510 --> 14:43.550
这是我们之前的写法

14:44.110 --> 14:45.470
那么这种写法有什么问题

14:45.470 --> 14:46.110
没有什么问题

14:47.230 --> 14:48.830
功能性没有任何问题

14:49.870 --> 14:51.790
就是强迫症患者看着不爽

14:52.430 --> 14:53.470
为啥不爽

14:53.950 --> 14:54.670
为啥不爽呢

14:55.150 --> 14:56.990
因为他要开始抬杠了

14:57.950 --> 15:00.110
强迫症患者往往有点钢筋的本色

15:00.110 --> 15:02.030
像这个地方就可以抬杠了

15:02.510 --> 15:03.790
凭什么保存到Rick里面

15:03.790 --> 15:04.990
为什么不保存到Rick里面

15:06.270 --> 15:06.670
对吧

15:06.670 --> 15:08.830
我相信有些钢筋同学

15:08.830 --> 15:10.190
跟我一样都有这样的疑问

15:10.350 --> 15:11.390
为什么要保存到这

15:12.350 --> 15:13.790
那你怎么解释的

15:13.790 --> 15:14.430
你说

15:14.430 --> 15:16.030
这个玩意是跟请求有关的吗

15:16.030 --> 15:16.910
跟请求没什么关系

15:16.910 --> 15:18.910
这个玩意不是从请求里面获取到的

15:18.910 --> 15:20.350
是从数据户里面拿到的

15:21.310 --> 15:21.630
对吧

15:21.630 --> 15:24.270
只不过它的用户埃及到是从请求里面拿到的

15:24.270 --> 15:25.230
Cookie里面拿到的

15:25.230 --> 15:26.750
但是这个用户对象是从数据户拿的

15:26.750 --> 15:27.790
凭什么放到请求里面

15:28.590 --> 15:29.230
那放到哪呢

15:29.230 --> 15:29.790
放到响应

15:29.790 --> 15:32.030
那这个东西又不会发送给客户端

15:32.750 --> 15:35.230
我们只是要在请求的处理过程中

15:36.030 --> 15:37.790
有可能会用到这个东西

15:38.270 --> 15:39.630
先把暂时保存到这

15:40.030 --> 15:41.710
方便后续的容量键使用

15:43.470 --> 15:44.750
那这个东西一直说是放到哪呢

15:44.750 --> 15:45.550
一放到它也不合适

15:45.550 --> 15:46.350
放到它也不合适

15:47.390 --> 15:49.310
对象模型它是有一些缺失的

15:49.790 --> 15:51.630
那么我们看一下KLA的处理方式

15:51.630 --> 15:53.470
KLA的处理方式非常简单

15:53.470 --> 15:54.670
它就在Request

15:55.230 --> 15:56.830
这个东西就相当于是就名字不一样

15:56.830 --> 15:57.230
Rick

15:57.230 --> 15:58.190
这个叫Request

15:58.190 --> 15:58.990
这个叫Response

15:59.550 --> 16:02.110
在这个请求和响应这两个对象

16:02.110 --> 16:04.110
前面加了一个context

16:04.110 --> 16:04.910
叫上下文

16:05.950 --> 16:07.150
前面都其他都一样

16:07.150 --> 16:09.390
每个请求共用的一个对象app

16:09.470 --> 16:10.750
然后每个请求来到过后

16:10.750 --> 16:12.270
我给你创建一个上下文

16:12.270 --> 16:14.270
上下文里边有请求有响应

16:15.230 --> 16:16.510
好每个上下文里边

16:16.510 --> 16:18.270
它可以除了是请求和响应之外

16:18.270 --> 16:18.830
可以包含

16:18.830 --> 16:19.710
当然可以它是个对象

16:19.710 --> 16:21.550
它当然可以包含别的数据

16:22.110 --> 16:23.310
所以说在KLA里边

16:24.510 --> 16:25.710
我们就可以怎么写了

16:25.710 --> 16:26.430
就可以这样子写

16:27.790 --> 16:28.910
你看KLA里面

16:31.150 --> 16:31.790
其他都一样

16:33.790 --> 16:34.510
那么这个地方

16:34.910 --> 16:35.870
叫做context

16:37.230 --> 16:38.670
它就不是Risk的

16:38.830 --> 16:39.790
那么这个地方我放了

16:41.070 --> 16:41.710
就这么简单

16:42.270 --> 16:43.470
那我请求的数据拿来了

16:43.470 --> 16:44.670
请求的数据从这个地方来

16:45.710 --> 16:46.990
响应的数据

16:46.990 --> 16:47.310
从这个

16:48.110 --> 16:48.430
响应

16:48.430 --> 16:49.870
我们要做响应的话就从这里

16:49.870 --> 16:50.510
去做响应

16:51.070 --> 16:51.870
那么其他的数据

16:52.510 --> 16:53.870
一既不是请求又不是响应

16:53.870 --> 16:55.470
是我们处理这个请求过程中

16:55.470 --> 16:56.190
要用到的东西

16:56.190 --> 16:56.910
我们就可以放到这

16:58.430 --> 16:59.950
好然后交给后续的中间键

16:59.950 --> 17:00.510
后续中间键

17:00.510 --> 17:01.470
是不是可以从这里边去拿到

17:01.470 --> 17:02.350
就给用户了

17:02.350 --> 17:02.510
对吧

17:02.510 --> 17:03.710
这样子更加合理一点

17:04.510 --> 17:05.630
这个东西叫做上下文

17:05.630 --> 17:06.670
什么叫上下文呢

17:06.750 --> 17:09.390
就是说跟某一个东西相关的

17:09.390 --> 17:10.750
这个东西有我就一占

17:10.750 --> 17:11.950
这个东西没有我就不占

17:11.950 --> 17:12.590
就是上下文

17:13.070 --> 17:13.950
这个请求来了

17:13.950 --> 17:14.750
我一个上下文

17:15.790 --> 17:16.670
我们后边的处理

17:16.670 --> 17:17.950
都是跟这个上下文相关的

17:17.950 --> 17:18.830
那么请求结束了

17:18.830 --> 17:20.910
我想用完了这个东西不存在了

17:20.910 --> 17:21.710
就这么个意思

17:22.350 --> 17:24.830
这就是对象结构有变化

17:24.830 --> 17:26.830
当然前面这两个都是小变化

17:27.310 --> 17:28.590
这都无上大雅了

17:29.310 --> 17:31.230
关键是最后一个就要命了

17:31.230 --> 17:32.430
最后一个是Express

17:32.430 --> 17:33.230
根本就没有

17:33.870 --> 17:34.430
KVA有

17:35.070 --> 17:36.350
这才是他们最重要的区别

17:36.830 --> 17:39.550
KVA对Express的最大优势

17:39.550 --> 17:41.470
就是它支持异步中间键

17:42.510 --> 17:43.390
从而呢

17:43.390 --> 17:44.990
以为它支持异步中间键

17:44.990 --> 17:48.030
从而提供了合理的中间键模型

17:48.030 --> 17:49.630
Express和中间键模型

17:49.630 --> 17:50.910
说实话是千疮百孔的

17:52.030 --> 17:53.470
其实它刚开始出来的时候

17:53.470 --> 17:55.630
并没有这样的那些东西

17:55.630 --> 17:57.310
大家觉得理所当然

17:57.310 --> 17:58.670
但是自从ES6

17:59.630 --> 18:00.750
Promise也好

18:00.750 --> 18:02.430
而Sync而位置出来之后

18:02.910 --> 18:04.990
那么Express中间键就完全没法看了

18:05.470 --> 18:07.310
所以我们看一下KVA的中间键

18:07.310 --> 18:09.630
所以我们要了解KVA的中间键

18:09.630 --> 18:11.550
就必须要了解Express中间键问题在哪

18:12.670 --> 18:14.110
如果说面试的时候问道理

18:14.110 --> 18:16.670
就是KVA跟Express最大的区别在哪

18:16.670 --> 18:17.630
你就一句话

18:17.630 --> 18:20.030
就是KVA它支持异步中间键

18:20.030 --> 18:21.390
那么它要让你详细说一下

18:21.390 --> 18:23.790
我们就可以把这些底解给它说出来

18:24.590 --> 18:25.150
来看一下

18:26.350 --> 18:27.630
Express的问题在哪呢

18:28.190 --> 18:28.830
下面一个代码

18:29.710 --> 18:31.310
这是一个函数

18:31.310 --> 18:32.990
给我传一段时间

18:32.990 --> 18:34.190
这个函数很简单

18:34.270 --> 18:36.030
我就主要是做测试的

18:36.030 --> 18:37.310
我就返回一个Promise

18:37.310 --> 18:38.990
这个Promise什么时候完成了

18:38.990 --> 18:40.190
就等待一段时间

18:40.190 --> 18:42.190
你紫禁的时间过后我就完成

18:42.190 --> 18:42.750
那就完了

18:43.630 --> 18:45.870
好那么现在我们看中间键1是怎么写的

18:45.870 --> 18:46.590
中间键1

18:47.310 --> 18:48.190
输出一个1

18:48.990 --> 18:49.870
交给下一个

18:50.750 --> 18:51.710
然后再输出4

18:52.590 --> 18:53.470
它的逻辑是什么呢

18:53.470 --> 18:54.990
它的逻辑应该是这样子的

18:54.990 --> 18:56.030
我输出1

18:56.030 --> 18:58.990
然后后边的中间键在运行

18:58.990 --> 19:00.510
等你后边的中间键运行完了

19:00.510 --> 19:01.390
我就输出4

19:02.110 --> 19:03.630
好我们看下个中间键

19:03.710 --> 19:04.830
下个中间键我们是这样写的

19:05.390 --> 19:06.110
输出2

19:06.110 --> 19:07.070
我等一秒钟

19:07.790 --> 19:08.750
那就模拟数据户

19:08.750 --> 19:09.710
比方数据户操作

19:09.710 --> 19:11.230
文件操作不是都是异部吗

19:11.230 --> 19:11.550
对不对

19:11.550 --> 19:12.430
我们就模拟一边

19:12.430 --> 19:13.310
我等呗

19:13.310 --> 19:14.350
我等一秒钟

19:14.350 --> 19:15.630
等一秒钟过后呢

19:15.630 --> 19:16.350
我就输出3

19:16.830 --> 19:19.310
那么这个输出的结果应该是什么呢

19:20.430 --> 19:21.150
下面都有答案了

19:23.230 --> 19:25.230
按理说应该是什么呢

19:25.870 --> 19:27.070
从讲道理

19:27.070 --> 19:30.830
讲道理说应该是1 2 3 4

19:31.310 --> 19:31.630
对不对

19:32.190 --> 19:33.070
所以应该讲道理吧

19:33.150 --> 19:34.910
讲道理是不是应该是这样子

19:34.910 --> 19:35.790
我输出1

19:36.190 --> 19:36.990
交给下个中间键

19:36.990 --> 19:38.190
我等他完成吧

19:38.190 --> 19:39.470
等他下个中间键完成

19:39.470 --> 19:40.990
他下个中间键是不是输出2 3

19:41.390 --> 19:42.030
然后呢

19:42.030 --> 19:43.470
我再又回到这里

19:43.470 --> 19:44.350
我再输出4

19:44.910 --> 19:45.390
对不对

19:45.710 --> 19:46.670
这是讲道理的

19:46.670 --> 19:47.710
但他不讲道理

19:47.710 --> 19:49.310
他输出的结果是1 2 4 3

19:49.630 --> 19:50.350
为啥呢

19:50.350 --> 19:52.590
就是因为他对异部的知识不是很好

19:53.070 --> 19:54.110
你看一下下面的图

19:54.830 --> 19:56.830
中间键1先运行输出1

19:57.310 --> 19:58.270
你看输出1

19:59.710 --> 20:00.430
交给下一个

20:00.910 --> 20:02.510
交给下一个是不是运行下个中间键

20:02.910 --> 20:03.390
对吧

20:03.390 --> 20:04.430
下个中间键输出什么了

20:04.430 --> 20:05.070
输出2

20:05.630 --> 20:06.430
输出2过后

20:06.430 --> 20:07.550
接下来是不是异部了

20:08.350 --> 20:09.310
这里是不是要等啊

20:09.870 --> 20:10.510
是不是要等

20:10.990 --> 20:12.110
那么这个等啊

20:12.110 --> 20:13.150
这个那个是方法

20:13.150 --> 20:14.830
就是中间键1他会不会等他了

20:14.830 --> 20:15.790
他不会等他

20:16.590 --> 20:17.950
中间键2里边会等

20:17.950 --> 20:20.110
在中间键1不会去等中间键2

20:20.110 --> 20:20.990
明白你的意思吧

20:21.870 --> 20:22.510
因此呢

20:22.990 --> 20:24.590
中间键2里边由于存在异部

20:24.590 --> 20:26.350
所以说他这里马上就结束了

20:26.350 --> 20:27.950
又回到中间键1只行了

20:27.950 --> 20:28.270
对吧

20:28.270 --> 20:28.830
输出4

20:29.550 --> 20:30.830
好等了一秒钟过后

20:31.550 --> 20:32.350
这等到了

20:32.350 --> 20:33.070
然后输出3

20:33.070 --> 20:34.270
他变成这种模式了

20:34.270 --> 20:35.870
就齐心怪状了

20:35.870 --> 20:36.190
对不对

20:36.750 --> 20:38.830
不是很符合我们的要求

20:38.830 --> 20:39.630
那么有一个同学说

20:39.630 --> 20:40.830
那我能不能这样子写呢

20:40.830 --> 20:42.590
我要中间键1里边把他写成一个异部

20:42.590 --> 20:43.630
还说然后这我等

20:43.630 --> 20:44.750
等他写不行呢

20:45.150 --> 20:46.430
我把中间键2等完

20:46.990 --> 20:47.630
不好意思

20:48.350 --> 20:49.470
就是这个问题啊

20:50.110 --> 20:51.230
Explains就是这个问题

20:51.230 --> 20:51.790
他解决不了

20:51.790 --> 20:52.670
他没有这样子出

20:52.670 --> 20:53.950
他不允许这样子处理

20:53.950 --> 20:55.070
这样子处理不会爆错

20:55.070 --> 20:55.630
但是呢

20:55.630 --> 20:56.750
达不到你想象的效果

20:56.750 --> 20:57.390
仍然是

20:57.950 --> 20:58.270
1

20:58.750 --> 20:59.230
2

20:59.230 --> 20:59.630
4

20:59.630 --> 21:00.350
马上输出

21:00.350 --> 21:01.550
等一秒钟过后输出3

21:01.550 --> 21:02.670
仍然是这样子

21:02.670 --> 21:03.550
为什么呢

21:03.550 --> 21:06.510
只要说到express里面

21:06.510 --> 21:08.350
他怎么去实现这个那个喊数的

21:08.350 --> 21:09.310
我这里写个伟代吧

21:10.670 --> 21:12.350
用个简单的方式来给大家解释

21:14.110 --> 21:14.670
在这边吧

21:17.490 --> 21:18.450
在express里面呢

21:18.450 --> 21:20.690
他我就用个伟代吧

21:20.690 --> 21:21.730
相当于是这样子写的

21:21.730 --> 21:22.130
那个是

21:24.590 --> 21:25.230
怎么写的呢

21:25.870 --> 21:26.830
非常简单

21:26.830 --> 21:28.190
调用下一个中间键

21:28.990 --> 21:29.630
made over

21:31.790 --> 21:32.510
他就这样写了

21:33.150 --> 21:34.430
当然他不是这样子写的

21:34.430 --> 21:35.950
我就是通过这样的方式来理解

21:36.750 --> 21:38.110
通过这种方式来理解

21:38.110 --> 21:38.830
他就这样子写的

21:39.390 --> 21:40.270
你看出问题没

21:41.150 --> 21:42.190
不说大家看出问题没

21:42.190 --> 21:43.150
我把他拿过来

21:44.590 --> 21:45.230
这个拿过来

21:45.870 --> 21:46.670
你看问题在哪

21:50.130 --> 21:52.370
在这边把这个取消掉

21:52.370 --> 21:53.170
你看问题在哪

21:53.970 --> 21:55.170
如果说express里面

21:55.170 --> 21:56.450
他是这样子写的

21:56.450 --> 21:58.050
你看这个我能等待他吗

21:59.090 --> 22:00.370
他是一部喊数吗

22:00.370 --> 22:01.410
他不是一部喊数

22:02.690 --> 22:03.410
但反过来是啥

22:03.410 --> 22:04.290
反过来是 undefined

22:04.290 --> 22:04.850
我等待他

22:04.850 --> 22:05.890
我等待undefined

22:05.890 --> 22:06.930
那等待于啥意义呢

22:06.930 --> 22:09.330
等不等待是没有区别

22:09.330 --> 22:09.650
对不对

22:10.530 --> 22:10.770
好

22:10.770 --> 22:12.450
他就说那这个东西是一部的呀

22:13.250 --> 22:13.970
没用啊

22:13.970 --> 22:15.410
这东西他底不要等一秒

22:15.410 --> 22:16.610
那我这个这个是喊数

22:16.610 --> 22:17.330
要不要等一秒

22:17.330 --> 22:18.370
他不等一秒

22:18.370 --> 22:20.690
就在这个喊数的运行过程中

22:20.690 --> 22:22.050
是马上又结束了

22:22.050 --> 22:23.250
他他返回了什么

22:23.250 --> 22:24.610
返回了是不是一个promise

22:24.610 --> 22:26.290
我们讲过的基础不能丢啊

22:27.090 --> 22:28.930
我们讲过的这个async喊数

22:28.930 --> 22:31.010
他返回了一定是一个promise

22:31.010 --> 22:32.610
说他返回的是个promise对吧

22:32.770 --> 22:35.010
只不过这个promise要一秒钟之后完成

22:35.010 --> 22:35.250
对吧

22:35.250 --> 22:36.610
那个喊数不会等待的

22:36.610 --> 22:37.890
它是个同步喊数

22:37.890 --> 22:39.650
说我这个等这个同步喊数有什么意义呢

22:39.650 --> 22:40.610
没有任何意义

22:40.610 --> 22:41.010
对吧

22:41.010 --> 22:42.050
我拿到这个那个是

22:42.050 --> 22:43.890
那个那个是返回的是undefined

22:43.890 --> 22:45.090
没有任何意义

22:45.090 --> 22:46.530
这就是express的问题

22:46.530 --> 22:47.410
因为他没有

22:47.410 --> 22:48.530
他以前不知道

22:48.530 --> 22:51.730
以将来会出现这个promise这个API

22:51.730 --> 22:53.570
也不知道将来会出现async

22:53.570 --> 22:54.370
orwait关键制

22:54.370 --> 22:55.330
根本就不知道

22:55.330 --> 22:55.890
所以说呢

22:56.770 --> 22:57.890
他没有办法处理这个问题

22:57.890 --> 23:00.610
我没有办法等后边的公交中间键完成

23:01.570 --> 23:03.490
但是KLA就可以

23:04.930 --> 23:06.290
express它不支持这个问题

23:06.290 --> 23:09.090
它会造成什么样的问题呢

23:09.090 --> 23:10.530
它的问题有很多

23:10.530 --> 23:11.570
比方说我给大家举个例子

23:12.370 --> 23:13.170
你看啊

23:13.170 --> 23:15.490
express里面如果说你遇到这样的成绩

23:15.490 --> 23:16.210
就很麻烦了

23:16.210 --> 23:17.250
就非常非常麻烦

23:17.250 --> 23:17.650
你看

23:19.170 --> 23:20.610
又是我写的冬天天

23:22.940 --> 23:24.140
这冬天天要干嘛呢

23:24.860 --> 23:25.660
要做这么一件事

23:29.140 --> 23:29.780
比方说过滤

23:30.820 --> 23:31.140
过滤

23:32.100 --> 23:33.460
这个过滤啊

23:33.460 --> 23:36.420
它涉及到请求过滤和享用过滤

23:36.420 --> 23:38.020
比方说咱们就开发一个网站

23:38.020 --> 23:39.060
这个网站呢

23:39.060 --> 23:41.860
咱们国家音乐众所周知的原因嘛

23:41.860 --> 23:43.940
因为要过滤一些关键制对不对

23:43.940 --> 23:45.780
比方说你们平时玩的游戏

23:45.780 --> 23:47.860
我游戏里边是不是经常出现星星

23:47.860 --> 23:48.580
对不对

23:48.580 --> 23:49.700
所以有人在骂你

23:49.700 --> 23:51.140
那么这是不是过滤啊

23:51.140 --> 23:52.900
用一个星星过滤了一些关键制

23:52.900 --> 23:53.540
好吧

23:53.540 --> 23:54.100
这个过滤呢

23:54.100 --> 23:56.020
不仅是从请求方面要过滤

23:56.020 --> 23:57.460
享用方面也要过滤

23:57.460 --> 23:58.820
也就是我们第一步

23:58.820 --> 24:00.020
第一步做啥呢

24:00.100 --> 24:00.740
第一步做啥呢

24:00.740 --> 24:01.540
做请求过滤

24:02.500 --> 24:04.180
请求过滤对吧

24:04.180 --> 24:05.060
请求过滤很简单

24:05.060 --> 24:06.260
我把请求体拿到

24:06.260 --> 24:08.420
看一下里面有用这么的表达数据匹配

24:08.420 --> 24:09.380
看一下哪些关键制

24:09.380 --> 24:11.220
我把T换成星星就完成了

24:11.220 --> 24:12.340
就请求过滤

24:12.340 --> 24:13.620
好请求过滤完了过后

24:13.620 --> 24:15.140
第二步是不是移交

24:16.260 --> 24:19.300
移交给后续中间键

24:19.300 --> 24:20.100
为啥呢

24:20.100 --> 24:21.940
因为后续中间键在做什么呢

24:21.940 --> 24:24.500
在添加在那做那个就是

24:25.140 --> 24:27.620
后续的中间键在做那个享用

24:27.620 --> 24:27.940
对吧

24:27.940 --> 24:29.140
所以我要移交

24:29.220 --> 24:31.700
让后续中间键去享用

24:31.700 --> 24:34.660
好等你享用完了过后第三步

24:34.660 --> 24:36.260
是不是就有享用体了

24:36.260 --> 24:36.820
对吧

24:36.820 --> 24:37.940
第三步干嘛呢

24:37.940 --> 24:38.660
第三步就是

24:41.540 --> 24:43.300
过滤什么享用

24:43.300 --> 24:43.860
对吧

24:43.860 --> 24:45.060
好移交给后续中间键

24:45.060 --> 24:46.660
然后等你享用完成

24:46.660 --> 24:48.020
然后过滤享用

24:48.020 --> 24:48.820
能办到吗

24:48.820 --> 24:50.100
根本就办不到

24:50.100 --> 24:50.900
你这样子的东西

24:50.900 --> 24:52.340
在一个splice里面根本就办不到

24:52.340 --> 24:52.820
为啥呢

24:53.700 --> 24:54.980
逻辑是完全没问题的

24:54.980 --> 24:56.500
但是就是办不到

24:56.500 --> 24:56.900
你看吧

24:56.900 --> 24:57.940
后续中间键是这样子的

25:00.800 --> 25:01.840
后续中间是什么样子的

25:02.800 --> 25:04.960
它是要从数据库里面去拿数据

25:06.080 --> 25:07.120
是个一步的

25:07.120 --> 25:08.080
比方说get news

25:08.880 --> 25:10.000
从数据库里面拿数据

25:10.800 --> 25:12.000
达到很多新闻

25:12.000 --> 25:12.880
然后呢把新闻

25:13.520 --> 25:15.840
发送到一个享应结果中

25:15.840 --> 25:16.720
send news

25:16.720 --> 25:16.960
对吧

25:16.960 --> 25:17.760
以前是不是这样子写的

25:18.480 --> 25:19.440
那不好意思

25:19.440 --> 25:20.560
这里是不是要等

25:20.560 --> 25:21.440
那我这里等吗

25:22.160 --> 25:23.040
我之前是不是讲过

25:23.040 --> 25:23.760
这个根本就不会等

25:23.760 --> 25:25.760
它掉进完事的反悔一个promise我就不管了

25:25.760 --> 25:26.400
对吧

25:26.400 --> 25:27.920
我管你怎么说完成

25:27.920 --> 25:28.400
啊

25:28.400 --> 25:29.760
我根本就没管这件事

25:29.840 --> 25:31.280
所以说这里根本就不会等

25:31.280 --> 25:32.480
马上就进入第三步

25:33.040 --> 25:33.840
那么也就是说

25:33.840 --> 25:35.360
当我们运行到第三步的时候

25:35.360 --> 25:36.320
有没有享应啊

25:36.320 --> 25:37.600
还没有享应这里还得等啊

25:38.320 --> 25:39.440
根本就没有享应结果

25:39.440 --> 25:40.400
那你怎么光举呢

25:41.360 --> 25:43.040
那你这里加二位车有用吗

25:43.040 --> 25:44.160
说跟刚才的情况一样

25:44.160 --> 25:45.200
根本就没用

25:45.200 --> 25:46.880
说这个问题就出来了

25:46.880 --> 25:47.920
很麻烦的问题

25:49.200 --> 25:50.160
很麻烦的这个问题

25:50.720 --> 25:52.400
而且这个问题不仅是在这

25:52.400 --> 25:53.600
还有在什么地方

25:53.600 --> 25:54.640
错误处理

25:54.640 --> 25:55.440
同样遇到问题

25:56.400 --> 25:56.960
错误处理

25:56.960 --> 25:57.280
比方说

25:58.560 --> 25:59.360
比方说就在这了

26:01.630 --> 26:03.230
在这里能不能拋出一个错误

26:03.230 --> 26:04.030
你有error

26:04.030 --> 26:04.670
拋出了错误

26:05.310 --> 26:06.510
我们不是在一个press里面

26:06.510 --> 26:07.870
有错误处理中间键吗

26:07.870 --> 26:08.190
对吧

26:08.190 --> 26:08.510
use

26:10.030 --> 26:10.910
error什么

26:10.910 --> 26:11.630
race

26:11.630 --> 26:12.270
race

26:12.270 --> 26:12.990
四个参数吧

26:15.230 --> 26:16.190
能受到这个错误吗

26:17.390 --> 26:18.350
肯定受不到

26:19.070 --> 26:19.630
为啥呢

26:20.430 --> 26:21.550
为啥受不到呢

26:21.550 --> 26:23.070
因为它不会等

26:23.070 --> 26:24.350
就这个原因

26:24.350 --> 26:24.990
你看啊

26:24.990 --> 26:25.630
运行它

26:26.350 --> 26:27.710
这个东西没有错误吗

26:27.710 --> 26:28.590
交给后续中间键

26:28.590 --> 26:29.470
后续中间键

26:29.550 --> 26:31.230
等我就不管了

26:31.230 --> 26:31.470
对吧

26:31.470 --> 26:31.950
不就管了

26:31.950 --> 26:32.670
没有错误吗

26:32.670 --> 26:32.910
好

26:32.910 --> 26:33.710
过滤响应

26:33.710 --> 26:34.670
没有响应结果

26:34.670 --> 26:36.990
当然过滤就什么都也不会发生

26:36.990 --> 26:37.710
也没有错误

26:37.710 --> 26:38.590
那就没有错误了

26:39.470 --> 26:41.310
等到你发生错误的时候

26:41.870 --> 26:42.670
什么时候了

26:43.470 --> 26:45.070
都跑了一步的长迹里面去了

26:45.630 --> 26:47.070
跑了一步的长迹里面去了

26:47.070 --> 26:49.310
那么这个错误是根本就获取不到的

26:49.310 --> 26:52.030
中间键的正常的含述执行已经完成了

26:53.550 --> 26:54.430
这就是这个问题

26:54.910 --> 26:55.630
就是这个问题

26:56.190 --> 26:56.910
所以说呢

26:57.870 --> 26:59.070
无论是错误处理

26:59.150 --> 26:59.870
还是这个地方

27:00.350 --> 27:01.870
还是前面来说的这个地方

27:01.870 --> 27:02.750
都会有点问题

27:03.230 --> 27:03.870
能不能解决

27:03.870 --> 27:04.670
倒是能解决

27:04.670 --> 27:05.550
这是很绕

27:05.550 --> 27:06.110
很麻烦

27:07.470 --> 27:09.230
但是KVA就非常简单了

27:09.230 --> 27:09.870
处理这些问题

27:09.870 --> 27:10.750
非常非常简单

27:10.750 --> 27:11.950
好咱们看KVA

27:11.950 --> 27:14.750
因为KVA是真正的支持一步中间键的

27:14.750 --> 27:15.230
看吧

27:15.230 --> 27:16.510
代码全的一样

27:16.510 --> 27:17.310
全一样

27:17.310 --> 27:18.430
跟一个确实都是一样的

27:19.710 --> 27:20.270
但是呢

27:20.270 --> 27:20.990
就是这个地方

27:20.990 --> 27:21.710
它可以等了

27:22.350 --> 27:23.390
它中间里面是真的

27:23.390 --> 27:24.430
可以等下一步完成

27:24.430 --> 27:25.870
这个就符合逻辑了

27:25.870 --> 27:26.990
我输出一

27:26.990 --> 27:27.790
交给下一个中间键

27:27.790 --> 27:28.830
我等它完成

27:28.910 --> 27:30.350
管理经过什么过程

27:30.350 --> 27:31.230
我等你完成

27:31.230 --> 27:31.710
然后呢

27:31.710 --> 27:32.350
我再输出4

27:33.150 --> 27:34.590
好后期中间就输出2

27:34.590 --> 27:34.990
输出3

27:34.990 --> 27:36.190
所以说在这里边就输出了

27:36.190 --> 27:37.070
是12

27:37.070 --> 27:37.710
马上输出

27:37.710 --> 27:38.030
对吧

27:38.030 --> 27:38.670
先输出1

27:38.670 --> 27:39.230
交给下一个

27:39.230 --> 27:40.110
先输出2

27:40.110 --> 27:40.350
12

27:40.350 --> 27:41.150
马上输出

27:41.150 --> 27:42.190
等一秒钟过后

27:42.190 --> 27:42.910
输出3

27:42.910 --> 27:43.230
好

27:43.230 --> 27:43.710
输出3过后

27:43.710 --> 27:44.190
它完成了

27:44.190 --> 27:44.990
然后接过来

27:44.990 --> 27:45.390
输出4

27:46.190 --> 27:46.430
对吧

27:46.430 --> 27:46.990
你看

27:46.990 --> 27:47.470
1

27:47.470 --> 27:48.190
下一个

27:48.190 --> 27:48.670
2

27:48.670 --> 27:49.310
等一秒钟

27:49.310 --> 27:49.870
3

27:49.870 --> 27:50.030
4

27:50.590 --> 27:52.270
这个逻辑是非常合理的

27:52.270 --> 27:53.070
对不对

27:53.070 --> 27:54.190
那么它是怎么办到的呢

27:54.190 --> 27:54.990
它办到的方式

27:54.990 --> 27:55.550
非常简单

27:56.270 --> 27:57.870
这是KLA里边的写法

27:57.870 --> 27:59.150
它不是它那边写法的

27:59.150 --> 27:59.950
伟代码

28:00.670 --> 28:02.460
完了

28:03.340 --> 28:04.540
就是下一个东西间

28:04.540 --> 28:05.820
那个是Midower

28:06.460 --> 28:07.100
完了

28:09.630 --> 28:10.910
加了一个是Return

28:10.910 --> 28:12.830
它把下个东西间的东西返回了

28:12.830 --> 28:13.870
那你返回了

28:13.870 --> 28:14.350
下个东西间

28:14.350 --> 28:15.630
如果说返回的是Promise

28:15.630 --> 28:16.670
这个内容返回来

28:16.670 --> 28:17.950
是不是也是Promise

28:17.950 --> 28:19.230
那么既然内容返回来

28:19.230 --> 28:19.790
是Promise

28:19.790 --> 28:20.750
那我这里是不是可以等

28:20.750 --> 28:22.590
那么这里就可以挣扎

28:22.590 --> 28:23.310
等它了

28:23.310 --> 28:25.070
等这个Promise完成

28:25.070 --> 28:25.630
完成了

28:25.630 --> 28:26.670
过后再输出4

28:26.670 --> 28:27.630
就完事了

28:27.710 --> 28:28.510
就完事了

28:28.510 --> 28:31.310
当然代码不是这样子写的

28:31.310 --> 28:32.990
但是含义是一样的

28:32.990 --> 28:34.030
含义是一样的

28:34.030 --> 28:36.590
总之我现在可以等这个那个则案出了

28:36.590 --> 28:37.870
没意思吧

28:37.870 --> 28:40.190
这是KLA的写法

28:40.190 --> 28:41.950
那么现在我们来继续看

28:43.230 --> 28:44.510
在KLA里边呢

28:44.510 --> 28:45.790
我们可以看到

28:45.790 --> 28:48.830
每一个中间件在完成了一些事的之后

28:48.830 --> 28:50.030
它可以非常优雅的

28:50.030 --> 28:51.550
把这个控制权往后移交

28:51.550 --> 28:52.670
你看我完成了一些事

28:52.670 --> 28:53.470
输出了1

28:53.470 --> 28:55.150
我把这个控制权往后移交

28:55.150 --> 28:56.910
然后我会等它完成

28:57.230 --> 28:58.990
我无论你后边经过了什么东西

28:58.990 --> 29:01.150
不要说中间件2又交给中间件3

29:01.150 --> 29:02.750
中间件3又交给中间件4

29:02.750 --> 29:03.310
无所谓

29:03.310 --> 29:04.750
我等你中间件2完成

29:04.750 --> 29:06.430
等你中间件2全部执行完

29:07.150 --> 29:09.390
然后又控制权又回到了我这

29:10.350 --> 29:12.510
我处理我移交回到我这

29:13.710 --> 29:14.830
它变成这样的模型了

29:14.830 --> 29:16.510
这个模型就叫做洋葱模型

29:17.630 --> 29:18.270
你看

29:18.270 --> 29:20.190
洋葱这不是一层一层的

29:20.190 --> 29:22.350
最外层是一个完成的洋葱壳

29:22.350 --> 29:22.830
对不对

29:22.830 --> 29:23.790
把包起来的

29:23.790 --> 29:24.430
最外层

29:24.990 --> 29:25.870
然后呢

29:25.870 --> 29:26.910
请求来了

29:26.910 --> 29:28.430
进入最外层

29:28.430 --> 29:29.790
最外层是不是中间件1

29:29.790 --> 29:30.430
对吧

29:30.430 --> 29:31.470
它进行处理

29:31.470 --> 29:32.590
处理完了过后

29:32.590 --> 29:33.630
往里边移交

29:33.630 --> 29:34.510
所以交给下一层

29:36.670 --> 29:37.790
下一层处理完了过后

29:37.790 --> 29:38.750
就是下一层

29:38.750 --> 29:40.030
不管你经过多少个步骤

29:40.030 --> 29:41.390
等我下一层会处理完

29:41.390 --> 29:42.110
处理完了过后

29:42.110 --> 29:43.310
是不是最后又回到上一层

29:44.110 --> 29:44.590
对吧

29:44.590 --> 29:45.310
又回到上一层

29:45.310 --> 29:45.870
最终完成

29:46.750 --> 29:47.310
就这样子

29:48.270 --> 29:49.310
处理下一层

29:50.270 --> 29:51.310
回到我这

29:51.310 --> 29:52.750
不管你后边经过多少过程

29:52.830 --> 29:53.710
会回到我这

29:53.710 --> 29:54.430
完成

29:54.430 --> 29:54.830
对吧

29:54.830 --> 29:55.310
回到我这

29:55.310 --> 29:55.950
我可以做一些事

29:55.950 --> 29:56.750
也可以不做一些事

29:56.750 --> 29:57.150
无所谓

29:58.110 --> 29:58.270
好

29:58.270 --> 29:59.630
那么对于下一层而言也是

29:59.630 --> 30:01.470
比较对这一层而言也是这样子

30:01.470 --> 30:02.430
然后第二层

30:03.230 --> 30:04.510
到了我这一层处理

30:04.510 --> 30:05.470
处理完了过后

30:05.470 --> 30:06.430
处理一些事情过后

30:06.430 --> 30:07.070
交给下一层

30:07.630 --> 30:07.790
好

30:07.790 --> 30:09.390
下一层不管你经过什么样的过程

30:09.390 --> 30:10.190
最终

30:10.190 --> 30:10.910
是要回到第二

30:10.910 --> 30:11.470
到处第二层

30:11.470 --> 30:11.710
对吧

30:11.710 --> 30:12.510
又回到我这一层

30:13.470 --> 30:14.350
要那意思吧

30:14.350 --> 30:15.470
那变成这样的模型了

30:16.590 --> 30:17.230
那你看

30:17.230 --> 30:18.670
最里层就是没有什么东西的

30:18.670 --> 30:20.270
里层交给我处理

30:20.270 --> 30:21.710
那我不没有下一层了

30:21.870 --> 30:22.990
不往后移交了

30:23.710 --> 30:24.750
处理完就完事了

30:25.470 --> 30:26.350
就这么个意思

30:26.350 --> 30:27.310
这是养成模型

30:28.030 --> 30:29.390
那么在Express里边

30:29.390 --> 30:30.430
能不能做成这样的模型呢

30:30.910 --> 30:32.510
如果说全部都是同步的话

30:32.510 --> 30:32.990
是可以的

30:33.950 --> 30:34.750
就Express里边

30:34.750 --> 30:36.430
如果说全部都是没有什么异步的话

30:36.430 --> 30:36.910
就可以的

30:36.910 --> 30:38.270
但是不可能没有异步

30:38.270 --> 30:38.830
对不对

30:38.830 --> 30:40.030
有异步的话就糟糕了

30:40.030 --> 30:41.630
然后这个控制权就全乱了

30:42.190 --> 30:42.830
所以说

30:42.830 --> 30:43.710
在QA呢

30:43.710 --> 30:44.990
它是一个非常完美的

30:44.990 --> 30:45.870
养成模型

30:46.590 --> 30:47.310
QA它

30:47.310 --> 30:48.670
你说QA它提供了啥

30:48.670 --> 30:49.390
啥都没提供

30:49.390 --> 30:50.110
它就给你提供了

30:50.110 --> 30:51.070
这种中间模型

30:52.030 --> 30:54.030
让你去写各种各样的中间键

30:54.030 --> 30:55.390
就完事了

30:55.390 --> 30:57.230
这就是QA的本质

30:57.230 --> 30:59.230
咱们这一刻认识了什么叫QA

30:59.230 --> 31:00.030
主要是

31:00.030 --> 31:01.870
理解它的里面的概念

31:01.870 --> 31:02.990
和它的核心思想

31:02.990 --> 31:04.510
然后下一节可开始

31:04.510 --> 31:05.630
咱们来写它的代码

