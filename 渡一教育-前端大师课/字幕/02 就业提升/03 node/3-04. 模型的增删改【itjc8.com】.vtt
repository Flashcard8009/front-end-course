WEBVTT

00:00.300 --> 00:03.100
好 咱们继续来学习这个OIME框架

00:03.100 --> 00:08.300
给大家说一下 这个OIME框架呢 它的内容特别多

00:08.300 --> 00:12.100
尽管这个sacrifice是前端的OIME框架

00:12.100 --> 00:15.900
只不过它写的还是后端 对吧 你都得接什么

00:15.900 --> 00:18.300
但它内容还是多

00:18.300 --> 00:21.100
所以我们不可能像后端那样子去学习

00:21.100 --> 00:24.300
后端学OIME框架它是要一整门课

00:24.300 --> 00:26.500
它不是说一章解就完事了

00:26.500 --> 00:28.900
它一定是一整门课 内容非常非常多

00:29.100 --> 00:32.500
功能很强大 但是我们作为前端人来说

00:32.500 --> 00:36.500
只需要了解它最核心的东西就可以了

00:36.500 --> 00:40.100
咱们这里可能讲这个模型的真三感

00:40.100 --> 00:43.300
我们上节课是不是把模型建立好了 对不对

00:43.300 --> 00:47.200
我之前加了一些数据 我把这个数据全部擀删掉

00:47.200 --> 00:50.300
我们这里可能自己来加这个数据

00:50.300 --> 00:51.700
通过代码来加这个数据

00:51.700 --> 00:54.500
我们来看一下OIME框架之后

00:54.500 --> 00:55.900
去怎么来加这个数据

00:55.900 --> 00:58.700
以及怎么来修改数据 以及怎么来删除数据

00:58.700 --> 01:02.700
这里我们介绍之前 首先给大家说一个概念

01:02.700 --> 01:05.100
叫做三层架构

01:05.100 --> 01:08.100
什么意思呢 如果说你多多少少接触过一点后端的话

01:08.100 --> 01:11.300
你多多少少听说过这么一个名词

01:11.300 --> 01:13.400
叫三层架构 它是什么意思呢

01:13.400 --> 01:18.300
它是指的是我们后端的项目的搭建

01:18.300 --> 01:23.800
应该用什么样的格式 用一种什么样的结构来搭建

01:23.800 --> 01:27.500
最常见的就是三层架构 它也是最简单的

01:27.500 --> 01:30.700
三层架构什么意思呢 它就说把我们的后端功能

01:30.700 --> 01:35.100
分成这么几个框 第一个框就是路由

01:35.100 --> 01:39.400
我们把它叫做路由层 当然以前把它叫做UI层

01:39.400 --> 01:42.400
不过现在后端一般不管UI了

01:42.400 --> 01:45.400
一般就是提供接口 所以说我们现在把它叫做路由层

01:45.400 --> 01:50.500
有些书籍或者教程里边的一把叫做API都可以

01:50.500 --> 01:53.500
或者叫服务层 在服务层我们有另外的含义

01:53.500 --> 01:57.200
叫路由层 路由层它做什么事情呢

01:57.200 --> 02:01.100
这一个层的事情它就是专门来对外提供API的访问接口

02:01.100 --> 02:04.900
它搭了一个服务器 就像用了一个ATDP模块

02:04.900 --> 02:07.900
搭了一个服务器 然后接收请求 请求来了过后

02:07.900 --> 02:11.200
根据你请求的不同地址 给你不同的阶层数据

02:11.200 --> 02:13.900
它就是这么一个 这一层就做这么一件事

02:13.900 --> 02:18.100
是一个独立的功能 好另外一层叫做服务层

02:18.100 --> 02:21.900
有的教程里边有可能它把第一层叫做服务层

02:21.900 --> 02:25.500
有把第二层叫做业务逻辑层都差不多

02:25.600 --> 02:27.600
意思都是反正你知道什么意思就行了

02:27.600 --> 02:30.600
我这里面把它叫做服务层 这一层干嘛呢

02:30.600 --> 02:34.400
这一层是提供业务逻辑的支持 什么叫业务逻辑

02:34.400 --> 02:38.600
业务逻辑是啥东西 就是功能 登陆是个功能吧

02:38.600 --> 02:42.900
对不对 学生建一本书 是不是功能 学生缓一本书 是不是功能

02:42.900 --> 02:46.600
对不对 客户去买一件东西 是不是功能

02:46.600 --> 02:49.400
这些都是功能性的东西 那么功能性的东西

02:49.400 --> 02:53.400
是放到业务逻辑层 是这么个意思

02:53.400 --> 02:57.100
第三层叫做数据访问层

02:57.100 --> 03:01.900
有的时候有的像夹大里边 它就把写成DAL

03:01.900 --> 03:05.400
Data Access Object 有些像cshap呢

03:05.400 --> 03:09.900
它把它写成DAL Data Access Layer

03:09.900 --> 03:13.800
一个意思叫数据访问层 那么这一层做什么事情呢

03:13.800 --> 03:16.200
这一层就是专门跟数据库

03:16.200 --> 03:19.900
或者是一些其他的持久性的存处设备

03:20.000 --> 03:23.800
比如说普通文件 这像这些东西

03:23.800 --> 03:26.700
是放到数据访问层给它打交道的

03:26.700 --> 03:30.400
那么它通过一种适配的机制 让我们的程序

03:30.400 --> 03:33.800
能够轻松的访问到我们数据库中的数据

03:33.800 --> 03:36.400
能够轻松跟数据库之间的数据进行操作

03:36.400 --> 03:38.500
而且是高效率的操作

03:38.500 --> 03:42.800
那么这一层 现在一般来说不太会去熟悉了

03:42.800 --> 03:45.400
一般来说我们都去使用OM框架

03:45.400 --> 03:48.000
所以说我们现在这一块相当于是

03:48.000 --> 03:53.000
这个sacred light它就充当了数据访问层

03:53.000 --> 03:54.700
那么这三个层是什么样的关系呢

03:54.700 --> 03:57.000
其实在夹大里边还有一个模型层

03:57.000 --> 03:59.300
因为夹大是强内形的 它不像介石

03:59.300 --> 04:00.500
介石弱内形的 对吧

04:00.500 --> 04:04.800
内形是可变化的 介石就不需要了

04:04.800 --> 04:07.000
介石的模型你可以认为是这个玩意

04:07.000 --> 04:09.100
这个玩意就是模型

04:09.100 --> 04:12.000
不过介石它不用去可以在乎这个东西

04:12.000 --> 04:14.000
那么这三层是什么关系

04:14.000 --> 04:15.000
给大家说一下

04:15.000 --> 04:17.900
业务逻辑层 它处理业务逻辑的时候

04:17.900 --> 04:20.000
它肯定要用到数据访问层

04:20.000 --> 04:22.600
所以说业务逻辑层就是服务层

04:22.600 --> 04:24.700
它会跟数据访问层打交道

04:24.700 --> 04:27.100
比较说你要做一个登录

04:27.100 --> 04:30.000
登录是不是一个业务功能 对不对

04:30.000 --> 04:33.000
那么这个功能它是不是要用到一个数据

04:33.000 --> 04:36.100
数据访问层的东西去查询数据库

04:36.100 --> 04:37.200
查询出来的结果

04:37.200 --> 04:39.000
然后根据结果不同的方式

04:39.000 --> 04:40.900
来进行相应的处理 对不对

04:40.900 --> 04:42.200
那么这是业务逻辑层

04:42.200 --> 04:45.400
它会跟数据访问层打交道

04:45.400 --> 04:47.800
路由层它会跟服务层打交道

04:47.800 --> 04:53.100
你看路由层是不会直接跟数据访问层打交道的

04:53.100 --> 04:55.500
它是直接跟服务层打交道

04:55.500 --> 04:58.500
因为它只是负责诱惑的请求来了

04:58.500 --> 04:59.600
我怎么来处理这个请求

04:59.600 --> 05:01.800
我应该给它一个什么样的格式的数据

05:01.800 --> 05:03.400
那么中间设计到哪些业务逻辑

05:03.400 --> 05:06.800
我去调用服务层的接口去完成功能

05:06.800 --> 05:08.800
这是经典的三层架构

05:08.800 --> 05:12.300
每一层之间它的界限非常的分明

05:12.300 --> 05:14.600
而且全世界都能理解

05:14.600 --> 05:16.200
这就是虽然它简单

05:16.200 --> 05:17.300
但它全世界都能理解

05:17.300 --> 05:21.100
因此就减少了很多不必要的沟通层门

05:21.100 --> 05:24.600
因此三层架构是非常经典的一个后端架构

05:24.600 --> 05:26.400
好了 那个三层架构

05:26.400 --> 05:29.000
我们这里在前端的路德街市里怎么表示呢

05:29.000 --> 05:30.600
就特别简单

05:30.600 --> 05:32.400
这个玩意其实就是个模型

05:32.400 --> 05:34.900
这个模型其实就相当于是ORM框架

05:34.900 --> 05:37.700
一个ORM框架给它做了一些模型配置

05:37.700 --> 05:39.700
那么这个东西就相当于是充当的是谁

05:39.700 --> 05:42.800
充当的是数据访问层

05:42.800 --> 05:44.500
感觉好像是模型层的话

05:44.500 --> 05:47.700
它的界限模型就不用去刻意在乎了

05:47.700 --> 05:49.800
所以说我们把它可以当成数据访问层

05:49.800 --> 05:51.800
因此这东西是不是跟表相关的

05:51.800 --> 05:52.300
对不对

05:52.300 --> 05:55.000
都是跟表 跟数据库相关的

05:55.000 --> 05:56.800
那么像服务层的话

05:56.800 --> 05:58.300
我们可以在这里新建个文件夹

05:58.300 --> 06:00.100
给它一个services

06:00.100 --> 06:03.000
这个地方就是放服务层里边的接口

06:03.000 --> 06:05.400
那么如果说将来我们肯定还要做那个

06:05.400 --> 06:06.900
还要做那个就是路由层

06:06.900 --> 06:08.500
那么我们可以放一个roads

06:08.500 --> 06:10.800
那么这里就放路由层的相应接口

06:10.800 --> 06:12.700
来处理各种请求

06:13.700 --> 06:17.700
或者把文件夹设作为API也可以

06:17.700 --> 06:20.700
这就是整个的工程结构

06:20.700 --> 06:21.900
那么这种结构

06:21.900 --> 06:24.100
我们学习的一点知识过后

06:24.100 --> 06:25.700
我们就利用这个services

06:25.700 --> 06:26.900
我们现在就可以用

06:26.900 --> 06:29.500
现在就来新建个文件

06:29.500 --> 06:31.400
我们看服务层写啥

06:31.400 --> 06:34.000
服务层又是跟我们的业务功能相关的

06:34.000 --> 06:37.600
那么我们这个系统里边有哪些业务功能呢

06:37.600 --> 06:40.700
不就是对我们这个业务功能很简的

06:40.700 --> 06:42.500
基本上没有什么业务功能

06:42.500 --> 06:45.200
就是对那个学生的增加

06:45.200 --> 06:46.900
增加一个学生修改一个学生

06:46.900 --> 06:48.100
删除一个学生

06:48.100 --> 06:50.900
增加一个用户修改一个管理员

06:50.900 --> 06:51.900
修改一个用户

06:51.900 --> 06:52.800
删除一个用户

06:52.800 --> 06:54.000
来帮我们来写一些

06:54.000 --> 06:56.100
来体验一下业务逻辑是怎么写的

06:56.100 --> 06:58.000
你们从来没写过后端对吧

06:58.000 --> 06:58.800
我们来体验一下吧

06:58.800 --> 07:00.500
其实根本不复杂

07:00.500 --> 07:01.900
咱们来比方说给大家写一个

07:01.900 --> 07:04.300
ArdminService

07:04.300 --> 07:08.100
ArdminService

07:08.100 --> 07:09.500
那么这里边我们就提供

07:09.500 --> 07:12.840
诶 名字写错了

07:12.840 --> 07:16.140
这里边就提供跟那个Ardmin这个模型

07:16.140 --> 07:17.840
相关的业务功能

07:17.840 --> 07:19.340
那么有什么样的业务功能呢

07:19.340 --> 07:21.140
我们就这样导出

07:21.140 --> 07:22.440
Export

07:22.440 --> 07:24.440
当然这个导出方式有多那么多样

07:24.440 --> 07:25.540
看你自己的

07:25.540 --> 07:28.040
总之我们要对外提供一些接口

07:28.040 --> 07:30.240
让他能够操作管理员

07:30.240 --> 07:31.040
来吧

07:31.040 --> 07:33.440
比方说添加一个管理员

07:33.440 --> 07:33.840
可不可以

07:33.840 --> 07:35.240
当然可以

07:35.240 --> 07:36.840
ADD

07:36.840 --> 07:37.940
Ardmin

07:37.940 --> 07:39.440
添加一个管理员

07:39.440 --> 07:39.740
对不对

07:39.740 --> 07:41.040
他是一个函数

07:41.040 --> 07:42.140
你给我传一个什么呢

07:42.140 --> 07:44.640
一个传一个管理员对象

07:44.640 --> 07:45.340
Ardmin

07:45.340 --> 07:46.140
OBG

07:46.140 --> 07:47.740
是不是添加一个管理员了

07:47.740 --> 07:48.040
对吧

07:48.040 --> 07:48.740
特别简单

07:48.740 --> 07:50.140
就添加一个管理员

07:50.140 --> 07:53.340
那么删除一个管理员

07:53.340 --> 07:55.140
DNet

07:55.140 --> 07:56.140
Ardmin

07:56.140 --> 07:57.640
是不是删除一个管理员

07:57.640 --> 07:59.240
Ardmin

07:59.240 --> 08:00.940
给我一个Ardmin ID

08:00.940 --> 08:02.440
给我一个管理员的ID

08:02.440 --> 08:05.140
我根据这个ID来删除一个管理员

08:05.140 --> 08:06.140
没问题吧

08:06.140 --> 08:07.340
好 那么再来啊

08:07.340 --> 08:08.940
修改一个管理员

08:08.940 --> 08:10.540
就是Update

08:10.540 --> 08:11.740
Ardmin

08:11.840 --> 08:13.040
是不是修改一个管理员

08:13.040 --> 08:13.540
对吧

08:13.540 --> 08:14.340
你给我一个什么呢

08:14.340 --> 08:15.440
Ardmin

08:15.440 --> 08:16.240
OBG

08:16.240 --> 08:18.740
那么我来这里修改一个管理员

08:18.740 --> 08:20.540
那么我们这个

08:20.540 --> 08:22.340
管理员的操作是不是就这三个

08:22.340 --> 08:24.040
添加一个 删除一个

08:24.040 --> 08:24.440
修改一个

08:24.440 --> 08:25.340
当然还有查询

08:25.340 --> 08:26.140
查询们

08:26.140 --> 08:29.140
后边的就是在进行相见

08:29.140 --> 08:31.240
我们这里可能只讲增三改

08:31.240 --> 08:33.740
增加删除修改

08:33.740 --> 08:36.240
那么这个东西不就是CRUD吗

08:36.240 --> 08:37.640
它是什么业务逻辑呢

08:37.640 --> 08:38.540
你看着啊

08:38.540 --> 08:40.340
再问我们想想这个道理

08:40.340 --> 08:42.340
当我们添加这个管理员的时候

08:42.340 --> 08:45.940
是不是要防止账号的名称不能重复

08:45.940 --> 08:48.140
管理员是有账号密码的

08:48.140 --> 08:48.740
对吧

08:48.740 --> 08:50.240
所以有账号密码的

08:50.240 --> 08:52.840
那么账号密码是不是不能重复的

08:52.840 --> 08:53.540
对不对

08:53.540 --> 08:54.840
那么这账号是不能重复的

08:54.840 --> 08:55.440
对不对

08:55.440 --> 08:57.340
那么这个东西是不是要在这里进行控制

08:57.340 --> 08:58.340
再进行验证

08:58.340 --> 09:00.940
这就是业务逻辑

09:00.940 --> 09:02.740
好 这是跟数据库无关的

09:02.740 --> 09:05.340
这是业务逻辑

09:05.340 --> 09:07.040
好 删除一个管理员

09:07.040 --> 09:08.340
能不能把管理员给我删完了

09:08.340 --> 09:10.440
上回来怎么来进行进这个系统呢

09:10.440 --> 09:11.440
这就是业务逻辑

09:11.440 --> 09:13.640
你至少得留一个

09:13.640 --> 09:14.340
对吧

09:14.340 --> 09:15.340
修改一个管理员

09:15.340 --> 09:16.640
对不起你不能修改账号

09:16.640 --> 09:17.840
你只能修改密码

09:17.840 --> 09:19.940
这就是业务逻辑

09:19.940 --> 09:20.840
不要认识吧

09:20.840 --> 09:21.840
有点像验证的

09:21.840 --> 09:22.340
业务逻辑

09:22.340 --> 09:24.840
验证是业务逻辑的一部分

09:24.840 --> 09:25.940
是非常重要的一部分

09:25.940 --> 09:27.840
因为我们这里面没有什么逻辑

09:27.840 --> 09:28.640
比较简单

09:28.640 --> 09:30.940
不可能给大家做一个真正的后端系统

09:30.940 --> 09:32.440
那二逻辑太复杂了

09:32.440 --> 09:33.140
大家也受不了

09:33.140 --> 09:34.440
你们也不是干这个

09:34.440 --> 09:35.540
所以我们简单说一下

09:35.540 --> 09:37.640
体验一下业务逻辑是什么意思

09:37.640 --> 09:39.840
那么我们要完成这三个方法

09:39.840 --> 09:42.040
要完成这三个方法

09:42.040 --> 09:43.340
我们这里是不是要知道

09:43.340 --> 09:44.740
怎么样去做增加

09:44.740 --> 09:45.640
怎么样去做删除

09:45.640 --> 09:46.840
怎么样去修改

09:46.840 --> 09:47.840
好 咱们来看一下

09:47.840 --> 09:49.740
为了让大家看得更加清楚

09:49.740 --> 09:52.340
我这里把这个收口语剧打开吧

09:52.340 --> 09:53.440
把这个收口语剧打开

09:53.440 --> 09:55.340
我们之前是把这个关掉了

09:55.340 --> 09:55.640
对吧

09:55.640 --> 09:56.440
都给你关掉了

09:56.440 --> 09:58.840
把它打开

09:58.840 --> 10:01.140
那么现在我们到银这个社里边来

10:01.140 --> 10:01.840
现在同步

10:01.840 --> 10:03.340
同步我们先不照这个同步

10:03.340 --> 10:05.440
反正之前已经同步过了

10:05.740 --> 10:07.540
我们现在来做一个增加

10:07.540 --> 10:09.740
你看一下在有了OLIM框架之后

10:09.740 --> 10:11.340
做一个对象的增加

10:11.340 --> 10:13.740
增加一个用户是多么的简单

10:13.740 --> 10:15.140
比方增加一个管理员

10:15.140 --> 10:15.940
怎么来增加呢

10:15.940 --> 10:17.840
我们可以这样子

10:17.840 --> 10:18.940
耳朵密

10:20.240 --> 10:21.140
导入这个模型

10:21.140 --> 10:22.640
我们之前是不是定一个模型

10:22.640 --> 10:23.040
对吧

10:23.040 --> 10:24.240
require

10:24.240 --> 10:26.540
第二鞋槓耳朵密

10:26.540 --> 10:28.340
models耳朵密

10:28.340 --> 10:29.040
对吧

10:29.040 --> 10:31.040
这是做增加

10:31.040 --> 10:32.140
增加

10:32.140 --> 10:34.840
那么增加有两种方式

10:34.840 --> 10:37.440
第一种方式是使用这个模型里边

10:37.440 --> 10:39.440
它可以提供的一个方法

10:39.440 --> 10:41.140
叫做create

10:41.140 --> 10:42.940
这个模型是我们自己定义的

10:42.940 --> 10:43.240
对吧

10:43.240 --> 10:43.640
导出了

10:43.640 --> 10:44.240
对不对

10:44.240 --> 10:45.140
那么这个模型里边

10:45.140 --> 10:46.540
它会自动通过这个地方

10:46.540 --> 10:47.440
得到一个模型

10:47.440 --> 10:48.540
那么这个模型里边

10:48.540 --> 10:51.640
它会有一个方法叫做build

10:51.640 --> 10:53.340
创就是构建一个模

10:53.340 --> 10:55.140
构建一个模型的实力

10:55.140 --> 10:57.440
这个方法的意思

10:57.440 --> 10:59.940
它是一个同步方法

10:59.940 --> 11:05.050
构建一个模型实力

11:05.050 --> 11:06.050
模型实力

11:06.050 --> 11:07.850
那么这个构建的模型实力

11:07.850 --> 11:08.850
它的数据是什么

11:08.850 --> 11:09.710
比方说你要

11:09.710 --> 11:10.950
墙外面是新建一个管理员

11:10.950 --> 11:11.850
就这么个意思

11:11.850 --> 11:13.450
那么这个新建的管理员的数据是什么

11:13.450 --> 11:14.650
你可以在这边写

11:14.650 --> 11:15.950
管理员不就是一个账号吗

11:15.950 --> 11:16.850
login id

11:16.850 --> 11:17.150
对吧

11:17.150 --> 11:17.450
abc

11:17.450 --> 11:18.550
我们随便写个吧

11:18.550 --> 11:19.350
然后密码

11:19.350 --> 11:20.750
login password

11:20.750 --> 11:21.750
密码的123

11:21.750 --> 11:23.050
随便写个吧

11:23.050 --> 11:26.350
这样子还会反而回一个模型的实力

11:26.350 --> 11:28.250
我们用instance来接收一下

11:28.250 --> 11:29.850
模型的实力

11:29.850 --> 11:31.150
那么这个实力

11:31.150 --> 11:32.350
它现在有数据库里面

11:32.350 --> 11:32.750
这样子

11:32.750 --> 11:33.750
运行了过后数据库里面

11:33.750 --> 11:34.450
有没有数据了

11:34.450 --> 11:35.350
没有

11:35.350 --> 11:36.950
它没有数据了

11:36.950 --> 11:39.050
它不会生成收口语剧去运行了

11:39.050 --> 11:40.450
只有当你去雕论

11:40.450 --> 11:43.150
这个实力的save方法

11:43.150 --> 11:44.150
那么这个时候

11:44.150 --> 11:46.350
它才会去运行收口语剧

11:46.350 --> 11:49.450
把这个模型存出到数据库里面

11:49.450 --> 11:50.750
当你雕论save之前

11:50.750 --> 11:52.350
你还可以在任何的时候

11:52.350 --> 11:53.950
去修改login id

11:53.950 --> 11:55.150
去修改它的任何东西

11:55.150 --> 11:56.150
比方bcd

11:56.150 --> 11:57.250
可以去进行修改

11:57.250 --> 11:59.450
然后最终save

11:59.450 --> 12:00.650
那么这个save

12:00.650 --> 12:01.650
它就是一个promise的

12:01.650 --> 12:02.150
看面

12:02.150 --> 12:03.450
它是个异步方法

12:03.450 --> 12:04.850
当它保存到数据库

12:04.850 --> 12:06.550
数据库肯定要经过一段过程

12:06.550 --> 12:07.650
数据库的执行速度

12:07.650 --> 12:09.150
肯定要比内存的

12:09.150 --> 12:11.150
什么边量地力这些慢太多了

12:11.150 --> 12:12.450
所以它一定是个异步的

12:12.450 --> 12:13.650
等数据库执行完了之后

12:13.650 --> 12:14.850
Promise结束

12:14.850 --> 12:15.850
所以在这里你可以用

12:15.850 --> 12:16.750
Async而位置

12:16.750 --> 12:17.750
或者是用Zin

12:17.750 --> 12:18.850
来等着它只结束

12:18.850 --> 12:20.050
你去做任何一些事情

12:20.050 --> 12:22.050
比方说我们可以用Zin

12:22.050 --> 12:24.150
当结束过后

12:24.150 --> 12:24.850
当结束过后

12:24.850 --> 12:26.350
我们输出

12:26.350 --> 12:27.050
输出什么呢

12:27.050 --> 12:32.650
输出那个新建管理员成功

12:32.650 --> 12:36.110
咱们来看一下

12:36.310 --> 12:39.410
我们运行load index

12:39.410 --> 12:41.410
新建管理员成功

12:41.410 --> 12:42.210
它运行到什么呢

12:42.210 --> 12:43.810
运行到是不是inserts into

12:43.810 --> 12:44.310
对不对

12:44.310 --> 12:46.110
而且它是不是给你加了问号

12:46.110 --> 12:47.310
加了问号说明什么

12:47.310 --> 12:49.510
说明是防止了射口诸诸

12:49.510 --> 12:50.610
就这么简单

12:50.610 --> 12:52.210
你什么都不用担心

12:52.210 --> 12:53.410
你有没有写射口语句

12:53.410 --> 12:54.810
没有

12:54.810 --> 12:55.810
没有写任何射口语句

12:55.810 --> 12:58.510
我们看一下数据库

12:58.510 --> 13:00.310
这里刷新

13:00.310 --> 13:01.710
到二的命里面去

13:01.710 --> 13:03.110
你看是不是有了

13:03.110 --> 13:04.910
只是什么BCD

13:05.610 --> 13:06.210
说明什么

13:06.210 --> 13:07.010
说明我们这里

13:07.010 --> 13:08.310
这一区有没有执行射口语句

13:08.310 --> 13:09.010
没有

13:09.010 --> 13:09.210
对吧

13:09.210 --> 13:10.410
刚才射口语句只有一条

13:10.410 --> 13:11.110
你看没

13:11.110 --> 13:11.710
得到的是

13:11.710 --> 13:13.210
它这里没有显示出来两个问号

13:13.210 --> 13:13.910
对吧

13:13.910 --> 13:15.010
射口语句它只运行到一条

13:15.010 --> 13:15.710
说明这一条

13:15.710 --> 13:17.410
它没有执行任何射口语句

13:17.410 --> 13:18.910
它只是创建一个实力

13:18.910 --> 13:19.710
通过这个实力区

13:19.710 --> 13:20.910
更改了一些属性过后

13:20.910 --> 13:21.910
save

13:21.910 --> 13:22.610
保存

13:22.610 --> 13:24.510
它就新增成功了

13:24.510 --> 13:27.510
说到新增是非常非常简单的

13:27.510 --> 13:29.110
这是这种方式来新增

13:29.110 --> 13:30.610
还有一种方式新增

13:30.610 --> 13:34.160
是用这种方式

13:34.260 --> 13:35.160
二的命

13:35.160 --> 13:36.460
叫做crate

13:36.460 --> 13:38.060
crate这种方式来新增

13:38.060 --> 13:39.560
它的区别就在于

13:39.560 --> 13:41.960
它就相当于是先运行了一个build

13:41.960 --> 13:44.660
然后来自动运行save

13:44.660 --> 13:45.260
就相当于是

13:45.260 --> 13:47.060
它直接就保存了

13:47.060 --> 13:48.460
它就不用等了

13:48.460 --> 13:49.760
那么这个地方用起来

13:49.760 --> 13:51.360
可能更加简单

13:51.360 --> 13:53.260
比方说

13:53.260 --> 13:55.160
二的命

13:55.160 --> 13:56.660
密码

13:56.660 --> 13:59.260
123456

13:59.260 --> 13:59.960
咱们来看一下吧

13:59.960 --> 14:00.960
我们这里

14:00.960 --> 14:02.060
它也是个promise

14:02.060 --> 14:03.260
想都可以想得到

14:04.260 --> 14:05.360
promise完成之后

14:05.360 --> 14:06.860
它会给了一个实力

14:06.860 --> 14:08.360
它实力在这

14:08.360 --> 14:11.360
我们这里输出新增

14:11.360 --> 14:12.860
我们看一下这个实力吧

14:12.860 --> 14:13.960
看一下这个实力

14:13.960 --> 14:17.960
这个实力它就是保存了新增的结果

14:17.960 --> 14:20.860
咱们运行一下

14:20.860 --> 14:22.560
你看一下

14:22.560 --> 14:23.460
一摄制into二的命

14:23.460 --> 14:24.760
是不是又运行了一次

14:24.760 --> 14:25.960
而现在得到这个实力里面

14:25.960 --> 14:27.160
你看

14:27.160 --> 14:28.060
它里面一个id

14:28.060 --> 14:30.360
id是不是二

14:30.360 --> 14:31.360
那么我们添加的时候

14:31.360 --> 14:31.860
没有给id

14:31.860 --> 14:32.560
它是自征的

14:32.660 --> 14:34.660
我们可以通过这个实力来得到它的id

14:34.660 --> 14:36.660
比方说我们这里输出

14:36.660 --> 14:37.560
点id

14:37.560 --> 14:40.360
然后 ints.loginid

14:40.360 --> 14:45.290
ints.loginpassword

14:45.290 --> 14:46.090
运行

14:50.090 --> 14:50.990
is not

14:50.990 --> 14:52.190
is is not defined

14:52.190 --> 14:56.240
哦 这里是 ints

14:56.240 --> 14:59.170
再来

14:59.170 --> 15:00.270
运行

15:00.270 --> 15:01.370
你看是不是得到了

15:01.370 --> 15:02.370
id为4

15:02.370 --> 15:03.370
帐号为这个

15:03.370 --> 15:04.470
密码为这个

15:04.470 --> 15:04.870
对不对

15:04.870 --> 15:06.770
我们新增的用户就可以得到了

15:06.870 --> 15:08.870
就刷新一次

15:08.870 --> 15:11.170
好 这就是它的两个新增方法

15:11.170 --> 15:11.970
一个是build

15:11.970 --> 15:13.170
一个是create

15:14.470 --> 15:14.770
好了吗

15:14.770 --> 15:15.870
我们知道了新增之后

15:15.870 --> 15:17.470
我们把这个复制一下

15:17.470 --> 15:18.270
知道了新增之后

15:18.270 --> 15:19.770
我们到这个surface里面来

15:19.770 --> 15:20.670
添加一个管理员

15:20.670 --> 15:21.870
是不是变得极其简单了

15:21.870 --> 15:23.370
你给我管理员的对象

15:24.470 --> 15:25.170
然后呢

15:25.170 --> 15:26.870
我在这里去完成添加

15:28.070 --> 15:30.070
那么完成添加的时候呢

15:30.070 --> 15:32.670
我这个地方有一些业务逻辑的判断

15:32.670 --> 15:35.070
那么我这里就直接写

15:35.070 --> 15:36.170
比方说我们就写了这

15:36.170 --> 15:37.170
并不去真正的判断

15:37.170 --> 15:39.470
我只是告诉大家什么叫业务逻辑而已

15:39.470 --> 15:40.470
就比方说

15:40.470 --> 15:42.670
应该判断

15:42.670 --> 15:43.970
就是管理员的

15:46.470 --> 15:48.470
的各种属性

15:48.470 --> 15:50.370
是否合理

15:50.370 --> 15:52.770
以及账号

15:52.770 --> 15:55.370
是否已存在

15:55.370 --> 15:55.870
对不对 是吧

15:55.870 --> 15:57.070
所以这些判断

15:57.070 --> 15:57.970
那有些朋友要问了

15:59.270 --> 16:03.070
说我这些判断不应该在页面上做吗

16:03.070 --> 16:04.570
这里大家注意啊

16:04.570 --> 16:05.970
我们的系统里边

16:05.970 --> 16:07.970
一个最安全的系统

16:07.970 --> 16:12.770
至少至少应该有一层判断

16:12.770 --> 16:15.170
这个判断一定要放在服务端

16:15.170 --> 16:17.070
而不是放到浏览器

16:17.070 --> 16:17.770
给大家说一下

16:22.010 --> 16:22.810
就是说

16:22.810 --> 16:28.610
这个东西怎么还在

16:28.610 --> 16:29.610
这怎么

16:29.610 --> 16:34.940
怎么说

16:34.940 --> 16:36.040
这上线太麻烦了吧

16:38.540 --> 16:39.340
就是说

16:39.340 --> 16:40.240
我们的系统

16:40.240 --> 16:43.140
一个完整的系统

16:43.140 --> 16:45.340
最重要的验证

16:45.340 --> 16:47.340
就是对数据验证

16:47.340 --> 16:49.440
一定是在服务器

16:49.440 --> 16:51.840
一定在服务器端

16:51.840 --> 16:53.540
而不是在客户端

16:53.540 --> 16:54.540
客户端的验证

16:54.540 --> 16:55.640
一般是做什么呢

16:55.640 --> 16:56.840
就是我们平时的验证

16:56.840 --> 16:58.840
一般有三层

16:58.840 --> 17:01.240
普通系统的话有两层

17:01.240 --> 17:02.140
更加复杂的

17:02.140 --> 17:02.840
更加安全性

17:02.840 --> 17:03.640
要求更高的系统

17:03.640 --> 17:04.640
需要三层

17:04.640 --> 17:05.840
就是三层验证

17:05.840 --> 17:08.040
第一层在客户端

17:08.040 --> 17:09.340
客户端就是浏览器

17:09.340 --> 17:11.040
或者是APP

17:11.040 --> 17:11.640
浏览器

17:11.640 --> 17:12.340
什么手机

17:12.840 --> 17:13.340
这些东西

17:13.340 --> 17:14.040
拍的

17:14.040 --> 17:14.640
平板

17:14.640 --> 17:15.640
小程序

17:15.640 --> 17:16.340
这些地方

17:16.340 --> 17:17.640
总之是中端设备

17:17.640 --> 17:18.640
就是我们前端的

17:18.640 --> 17:19.440
主要开发

17:19.440 --> 17:20.640
主要面向的目标

17:20.640 --> 17:22.440
那么这一层的验证

17:22.440 --> 17:23.740
客户端的验证

17:23.740 --> 17:24.640
它的主要目的

17:24.640 --> 17:26.540
事实上它不是安全

17:26.540 --> 17:28.840
它跟安全一毛钱关系没有

17:28.840 --> 17:30.440
它的验证目的是什么呢

17:30.440 --> 17:32.140
用户体验

17:32.140 --> 17:33.240
这是它的最重要目的

17:33.240 --> 17:34.740
所以它的验证一定要好看

17:34.740 --> 17:36.940
一定要用户体验的舒服

17:36.940 --> 17:39.240
它为什么跟安全没有关系呢

17:39.240 --> 17:40.340
你想一想

17:40.340 --> 17:42.140
最终的数据保存

17:42.140 --> 17:44.440
数据的处理是不是在服务期

17:44.440 --> 17:47.040
前端只是发送了一个阿迦克斯请求

17:47.040 --> 17:48.440
那你说用户

17:48.440 --> 17:50.440
稍微等于点技术的用户

17:50.440 --> 17:52.240
直接用个PoS慢就可以请求过来了

17:52.240 --> 17:54.240
它看板用浏览器了

17:54.240 --> 17:55.640
就完全照顾了浏览器了

17:55.640 --> 17:57.240
不是说它就老老实实用个浏览器

17:57.240 --> 17:58.440
给你去发送请求

17:58.440 --> 17:59.440
凭什么呢

17:59.440 --> 18:01.240
它甚至在浏览器的控制台里边

18:01.240 --> 18:02.440
直接利用个阿迦克斯请求

18:02.440 --> 18:03.140
啥都不用验证

18:03.140 --> 18:04.640
直接飞过来了

18:04.640 --> 18:05.840
那你就完蛋了

18:05.840 --> 18:07.740
你是觉得什么GS代码

18:07.740 --> 18:10.340
所以说前端的GS

18:10.340 --> 18:12.040
就在客户端的

18:12.040 --> 18:13.440
就是浏览器端的GS

18:13.440 --> 18:15.040
就不要说谈什么安全性的

18:15.040 --> 18:16.440
谈得不要谈这个问题

18:16.440 --> 18:19.040
第一个你到原代码是全部公开的

18:19.040 --> 18:20.840
第二个这个GS代码

18:20.840 --> 18:22.940
它随时在控制台里边可以用

18:22.940 --> 18:25.140
不要谈什么安全性的

18:25.140 --> 18:27.140
我们说的安全性的

18:27.140 --> 18:28.940
一般指的是服务端

18:28.940 --> 18:31.240
服务端要考虑安全性

18:31.240 --> 18:32.540
说客户端这一块

18:32.540 --> 18:34.740
主要是在乎的是用户体验

18:34.740 --> 18:35.840
不要搞错了

18:35.840 --> 18:37.040
不要说客户端那一块

18:37.040 --> 18:38.240
验责也是为了安全

18:38.240 --> 18:39.940
没有任何安全性可言

18:39.940 --> 18:41.140
好 第二个层面

18:41.140 --> 18:42.840
真正的安全性是在哪里做的

18:42.840 --> 18:44.840
是在服务端做的

18:44.840 --> 18:46.840
服务端的验证

18:46.840 --> 18:49.040
服务器端的逻辑验证

18:49.040 --> 18:49.840
逻辑的什么

18:49.840 --> 18:52.740
就是业务逻辑层的验证

18:52.740 --> 18:55.640
业务逻辑层的验证

18:55.640 --> 18:57.340
那么这一部分验证

18:57.340 --> 19:00.040
是真的是为了

19:00.040 --> 19:04.240
业务逻辑的完整性

19:04.240 --> 19:06.940
安全性

19:06.940 --> 19:08.040
完整性 安全性

19:08.040 --> 19:09.340
我们都需要

19:09.340 --> 19:11.240
那么什么叫完整性

19:11.240 --> 19:12.540
就是业务逻辑层

19:12.540 --> 19:14.140
还不是给你提供了一些方法吗

19:14.140 --> 19:15.740
你必须要保证

19:15.740 --> 19:17.540
属于一遍它怎么用这个方法

19:17.540 --> 19:19.340
属于一遍你怎么玩

19:19.340 --> 19:20.940
我的数据

19:20.940 --> 19:22.640
得到的数据一定是正确的

19:22.640 --> 19:23.840
一定是合理的

19:23.840 --> 19:25.640
一定是不会出现错乱的

19:25.640 --> 19:27.640
一定要保证这一点

19:27.640 --> 19:29.140
你不能运行着

19:29.140 --> 19:30.240
我的数据变成了什么

19:30.240 --> 19:32.140
变成了有个人有账号密码是

19:32.140 --> 19:33.440
密码是nau

19:33.440 --> 19:34.440
密码是undefined

19:34.440 --> 19:36.040
这东西就出来了

19:36.040 --> 19:38.540
这些就是数据的不完整

19:38.640 --> 19:39.540
没了意思吧

19:39.540 --> 19:42.840
就不是业务逻辑的不完整

19:42.840 --> 19:43.740
没了意思吧

19:43.740 --> 19:45.540
比方说我再举个例子

19:45.540 --> 19:47.740
每个用户都要有头像

19:47.740 --> 19:50.240
那么头像又是一张表

19:50.240 --> 19:52.740
头像的就是头像有一张图片地址

19:52.740 --> 19:54.340
有头像的名称对不对

19:54.340 --> 19:56.040
头像又是一张表

19:56.040 --> 19:57.540
那么如果说一个用户

19:57.540 --> 19:58.440
添加一个用户的时候

19:58.440 --> 19:59.140
一个用户注册了

19:59.140 --> 20:02.140
这个时候头像表还没有数据

20:02.140 --> 20:03.340
那么是不是完蛋了

20:03.340 --> 20:05.340
这个业务是不完整的

20:05.340 --> 20:07.740
所以说你至少要保证头像表

20:07.740 --> 20:08.940
至少有一张数据

20:08.940 --> 20:09.840
如果说业务逻辑成了

20:09.840 --> 20:11.240
他发现了头像表没有数据

20:11.240 --> 20:13.440
马上要加一条

20:13.440 --> 20:15.140
这就是业务逻辑

20:15.140 --> 20:18.140
他要验证业务逻辑的完整性

20:18.140 --> 20:19.140
这就是后端的东西

20:19.140 --> 20:20.440
我们了解一下

20:20.440 --> 20:22.740
你们为什么要很多公司要求

20:22.740 --> 20:24.140
你们会一点后端呢

20:24.140 --> 20:24.940
就是因为你到时候

20:24.940 --> 20:25.840
你们要跟后端共通

20:25.840 --> 20:27.940
后端是很容易理解前端的

20:27.940 --> 20:28.940
因为每个后端都要学习

20:28.940 --> 20:30.440
ATM和CSS的介绍

20:30.440 --> 20:32.940
只不过很多客人还不学一框架

20:32.940 --> 20:35.340
框架确实搞不定

20:35.340 --> 20:36.740
但是像这些基础东西

20:37.040 --> 20:38.140
基本上是了解的

20:38.140 --> 20:40.340
但是很多前端人是不了解后端的

20:40.340 --> 20:42.440
不知道后端要干嘛

20:42.440 --> 20:45.240
后端对这一部分要花很大的精力

20:45.240 --> 20:47.140
是要保证业务逻辑的完整性

20:47.140 --> 20:48.840
主要的精力就在这

20:48.840 --> 20:50.340
业务逻辑的完整性

20:50.340 --> 20:51.940
安全性 什么叫安全性

20:51.940 --> 20:53.240
谁能添加管理员

20:53.240 --> 20:54.840
谁能添加管理员

20:54.840 --> 20:55.940
是不是只有管理员

20:55.940 --> 20:58.140
才能添加管理员

20:58.140 --> 20:59.440
那如果说我这个方法

20:59.440 --> 21:01.140
就这样放在这

21:01.140 --> 21:02.640
任何人都可以调用这个方法

21:02.640 --> 21:03.740
我这个方法里面

21:03.740 --> 21:06.240
不去温一下是谁在操作我

21:06.240 --> 21:07.340
是不是不安全

21:07.340 --> 21:10.540
所以这个方法最合理的是

21:10.540 --> 21:11.540
还有一个什么呢

21:11.540 --> 21:13.840
operator ID

21:13.840 --> 21:15.640
谁在操作这个方法

21:15.640 --> 21:16.540
你告诉我

21:16.540 --> 21:19.040
谁把这个ID给我传过来

21:19.040 --> 21:20.140
谁在操作这个方法

21:20.140 --> 21:21.540
我要去验证一下这个ID

21:21.540 --> 21:23.740
他有没有权限去添加一个管理员

21:23.740 --> 21:26.240
这些东西都是业务逻辑

21:26.240 --> 21:28.940
只不过我们前端一般不去搞这个玩意

21:28.940 --> 21:31.340
一般不去搞这个对这后端的东西

21:31.340 --> 21:33.240
我给他说一下

21:33.240 --> 21:35.740
还有一层验证

21:35.740 --> 21:36.540
还有一层验证

21:36.540 --> 21:38.940
这是保证业务逻辑的完整性

21:38.940 --> 21:40.940
比方我们刚才就刚才说的例子

21:40.940 --> 21:43.540
你添加管理员必须要必须要是管理员

21:43.540 --> 21:44.640
才能添加管理员

21:44.640 --> 21:46.640
那是不是至少得有一个管理员

21:46.640 --> 21:49.940
那是不是在前面还应该做一个管理员初始化

21:49.940 --> 21:52.940
管理员初始化

21:52.940 --> 21:56.540
就是一开始判断一下数据库中

21:56.540 --> 22:02.240
判断数据库中是否有管理员

22:02.240 --> 22:08.240
如果没有自动添加一个默认管理员

22:08.240 --> 22:09.940
或者要超级管理员

22:09.940 --> 22:11.140
那至少得有一个吧

22:11.140 --> 22:11.740
一个都没有

22:11.740 --> 22:14.040
他怎么来一生二生三呢

22:14.040 --> 22:14.540
对不对

22:14.540 --> 22:15.740
这就是业务逻辑

22:15.740 --> 22:20.540
他保证的是业务逻辑的完整性以及安全性

22:20.540 --> 22:21.940
还有第三层

22:21.940 --> 22:25.440
第三层一般中小系统就不做了

22:25.440 --> 22:26.840
大系统是一定要做的

22:26.840 --> 22:29.940
叫做数据库验证

22:30.040 --> 22:32.340
数据库其实有很多的约束的

22:32.340 --> 22:35.140
比方说我们之前最简单的就是飞空约束

22:35.140 --> 22:36.640
你这个东西不能维空

22:36.640 --> 22:37.740
这就是飞空约束

22:37.740 --> 22:39.540
还有什么外界约束

22:39.540 --> 22:41.940
你这个地方你念双别的表示外界

22:41.940 --> 22:44.740
那么外界你不能填一个比方说

22:44.740 --> 22:48.040
学生他的班级是ID是5

22:48.040 --> 22:49.640
没有班级ID为5的班级

22:49.640 --> 22:51.540
就是外界约束

22:51.540 --> 22:55.140
那么这些东西就是数据库的验证

22:55.140 --> 22:59.040
数据库的验证是为了保证数据也完整性

22:59.040 --> 23:01.740
为了保证数据完整性

23:01.740 --> 23:04.830
为什么说

23:04.830 --> 23:06.930
为什么说服务期端的验证

23:06.930 --> 23:08.930
很多公司还是中小系系统

23:08.930 --> 23:10.430
一般这两个验证就够了

23:10.430 --> 23:11.030
为什么

23:11.030 --> 23:15.230
因为很多时候在服务端的逻辑验证这一块

23:15.230 --> 23:18.530
它就已经保证了数据完整性

23:18.530 --> 23:19.630
因为业务完整性

23:19.630 --> 23:23.030
往往就包含了数据完整性

23:23.030 --> 23:26.930
但是为什么还要来一个数据库的验证

23:26.930 --> 23:29.630
是因为有一些比较特殊的系统

23:29.630 --> 23:31.330
它可能会直接操纵数据库

23:31.330 --> 23:33.830
而跳过业务逻辑

23:33.830 --> 23:36.430
比方说威乱的里边有些套件

23:36.430 --> 23:38.630
我忘了以前用我的叫什么

23:38.630 --> 23:40.230
叫Porting Service

23:40.230 --> 23:42.330
直接操纵数据库的

23:42.330 --> 23:44.530
它不会改动数据库

23:44.530 --> 23:47.230
但是它会从数据库里面取一些数据

23:47.230 --> 23:49.530
然后可能会生成一些临时表

23:49.530 --> 23:50.630
来保存业数据

23:50.630 --> 23:52.230
那么这个时候

23:52.230 --> 23:55.130
万一它对数据造成的改动

23:55.130 --> 23:57.730
我们要保证数据至少是完整的

23:57.730 --> 24:00.130
这是有些系统它会直接操纵数据库的

24:00.130 --> 24:03.330
所以说它可能还会加一层数据库的验证

24:03.330 --> 24:07.930
那么数据库验证就完全跟前端完全没关系了

24:07.930 --> 24:10.030
这个东西离我们太远太远了

24:10.030 --> 24:11.330
如果说将来你有兴趣的话

24:11.330 --> 24:14.930
你可以至少你现在知道后端到底是怎么回事

24:14.930 --> 24:17.530
它的经历主要在什么地方

24:17.530 --> 24:19.730
这些东西是非常耗时的作业

24:19.730 --> 24:21.130
所以我们前端做不做呢

24:21.130 --> 24:22.130
我就不做了

24:22.130 --> 24:23.030
不做了

24:23.030 --> 24:25.230
我只是告诉大家有这么一个东西就行了

24:25.230 --> 24:26.230
东西就行了

24:26.230 --> 24:28.330
我们就不做这些东西了

24:28.330 --> 24:31.130
这事关于这个当然聊做的话其实也可以

24:31.130 --> 24:33.130
你就挨在验证呗

24:33.130 --> 24:34.830
挨在验证呗

24:34.830 --> 24:36.030
后边我会专门来一些课

24:36.030 --> 24:38.030
给大家介绍一个验证的

24:38.030 --> 24:39.630
一个验证的第三方库

24:39.630 --> 24:41.530
其实这个Secretize里边

24:41.530 --> 24:43.930
这个欧阳萌框架里边它也有验证

24:43.930 --> 24:47.130
它那个验证不是很灵活

24:47.130 --> 24:47.930
我不是很喜欢

24:47.930 --> 24:50.430
如果说有兴趣的话可以去看一下它的文档

24:50.430 --> 24:55.480
因为我们之前不是有把文档给大家看了吗

24:55.580 --> 24:56.580
看一下

25:01.070 --> 25:02.570
不是这个文档

25:02.570 --> 25:06.960
怎么这是英文文档

25:06.960 --> 25:09.060
Secretize

25:09.060 --> 25:10.860
这个民间中文网

25:10.860 --> 25:12.860
这个中文网做的可以的

25:12.860 --> 25:18.040
用这个中文网吧

25:18.040 --> 25:19.440
用这个中文网

25:19.440 --> 25:21.040
这个中文网里边有一个

25:21.040 --> 25:22.640
就是关于验证的

25:22.640 --> 25:23.840
我记得有的

25:23.840 --> 25:25.240
这里验证约束

25:25.240 --> 25:26.840
约束指的是数据库约束

25:26.840 --> 25:29.040
验证指的是业务验证

25:29.040 --> 25:30.240
它是可以支持的

25:30.240 --> 25:31.340
不过它可不太灵活

25:31.340 --> 25:32.340
我后面给大家介绍一个

25:32.340 --> 25:34.140
专门来做验证的库

25:34.140 --> 25:35.740
那个东西相当强大

25:35.740 --> 25:38.140
好 这是关于这个验证

25:38.140 --> 25:39.840
就是这里我们应该写啥

25:39.840 --> 25:40.940
但是我这里就不管了

25:40.940 --> 25:43.340
我就不管了这些啥

25:43.340 --> 25:44.640
我先直接来

25:44.640 --> 25:46.340
来什么呢

25:46.340 --> 25:48.540
这个地方我们就直接写

25:48.540 --> 25:50.140
不是操作耳朵密吗

25:50.140 --> 25:50.940
对不对

25:50.940 --> 25:51.640
耳朵密

25:51.640 --> 25:52.440
导入进来

25:52.440 --> 25:54.540
require

25:54.540 --> 25:57.940
然后是models耳朵密

25:57.940 --> 26:00.940
好 添加一个管理员

26:00.940 --> 26:02.540
我再给大家说一次

26:02.540 --> 26:04.540
按理说是应该要验证的

26:04.540 --> 26:05.840
只不过我这里难得做了

26:05.840 --> 26:07.240
我难得去做了

26:07.240 --> 26:08.140
如果说你们正儿吧

26:08.140 --> 26:08.940
你在公司里边

26:08.940 --> 26:11.540
如果说你要做一个非常小型的系统

26:11.540 --> 26:13.340
小型的系统里边

26:13.340 --> 26:15.640
你要去做这些简单的

26:15.640 --> 26:16.940
争产改杂CRUD

26:16.940 --> 26:18.640
对每一个操作都要验证的

26:18.640 --> 26:19.440
首先你要看一下

26:19.440 --> 26:20.840
他有没有权利验证这个

26:20.840 --> 26:22.340
他有没有权利做这个操作

26:22.340 --> 26:22.840
第二呢

26:22.840 --> 26:24.640
你要看一下他一个

26:24.640 --> 26:29.440
就是验证的数据是不是合理的

26:29.440 --> 26:30.340
他还要去验证

26:30.440 --> 26:32.640
后面会给大家建讨验证户

26:32.640 --> 26:34.940
我们这里就直接来create

26:34.940 --> 26:35.840
回去啥都不管了

26:35.840 --> 26:37.340
为谁不做任何验证

26:37.340 --> 26:38.040
就完了

26:38.040 --> 26:38.840
对不对

26:38.840 --> 26:39.640
这是一个异部的

26:39.640 --> 26:41.440
我们也把方法写成一个异部

26:41.440 --> 26:44.640
Elsink

26:44.640 --> 26:46.340
Await

26:46.340 --> 26:47.840
好 然后呢

26:47.840 --> 26:48.540
create完了过来

26:48.540 --> 26:50.640
是不是得到一个instance

26:50.640 --> 26:52.640
得到一个就是实力

26:52.640 --> 26:53.340
对不对

26:53.340 --> 26:54.240
这个实力里边

26:54.240 --> 26:56.340
它其实实力里边有很多内容

26:56.340 --> 26:57.740
还有一些方法

26:57.740 --> 26:59.440
但是我们更加希望

26:59.540 --> 27:00.440
这个函数

27:00.440 --> 27:01.440
添加一个管理员之后

27:01.440 --> 27:02.640
返回的东西呢

27:02.640 --> 27:04.240
是一个普普通通的

27:04.240 --> 27:05.540
就是一个平面对象

27:05.540 --> 27:07.140
它每个乱七八糟的方法

27:07.140 --> 27:08.140
因为我们知道实力里边

27:08.140 --> 27:09.640
是不是有什么safe方法

27:09.640 --> 27:10.140
对不对

27:10.140 --> 27:11.040
你看啊

27:11.040 --> 27:12.240
是不是有什么safe方法

27:12.240 --> 27:13.840
还要乱七八糟的一些东西

27:13.840 --> 27:15.740
我们如果说得到一个纯粹的对象的话

27:15.740 --> 27:18.240
我们可以调往它的to-jesson

27:18.240 --> 27:19.740
instance to-jesson

27:19.740 --> 27:20.840
这样子它会把它变成一个

27:20.840 --> 27:21.940
jesson格式的对象

27:21.940 --> 27:23.640
就是一个非常非常平面的对象

27:23.640 --> 27:24.940
你把它返回去完成

27:24.940 --> 27:25.640
对吧

27:25.640 --> 27:26.740
你看我们的业务逻辑

27:26.740 --> 27:28.040
是不是写得非常简单

27:28.040 --> 27:28.440
对不对

27:28.440 --> 27:30.040
因为我们啥都没管

27:30.040 --> 27:31.740
但是要管的时候就很多了

27:31.740 --> 27:32.640
我再说一次

27:32.640 --> 27:33.240
比方说

27:33.240 --> 27:34.740
你要看一下有谁有权限的

27:34.740 --> 27:35.340
天下管理员

27:35.340 --> 27:37.940
你必须要给我一个operator ID

27:37.940 --> 27:40.440
这是给我一个管理员ID

27:40.440 --> 27:41.840
那么我要验证这个ID

27:41.840 --> 27:43.040
在数据库里面存不存在

27:43.040 --> 27:44.740
有没有这个管理员

27:44.740 --> 27:45.440
有的话

27:45.440 --> 27:47.540
那么这个管理员

27:47.540 --> 27:48.340
如果说有的话

27:48.340 --> 27:49.140
比方说我这里的

27:49.140 --> 27:50.540
我没有设计什么超级管理员

27:50.540 --> 27:51.740
管理员还有类型的

27:51.740 --> 27:52.640
一个是普通管理员

27:52.640 --> 27:55.740
一个是超级管理员

27:55.740 --> 27:56.940
如果说有这个管理员的话

27:56.940 --> 27:57.840
我允许你添加

27:57.840 --> 27:59.040
那么我看一下一个对象里边

27:59.040 --> 28:00.740
是不是有至少有两个属性

28:00.740 --> 28:01.640
一个是locking ID

28:01.640 --> 28:02.440
一个locking password的

28:02.440 --> 28:04.640
我把一些不相干的属性全部去掉

28:04.640 --> 28:06.340
我只保留这两个属性

28:06.340 --> 28:07.240
然后再验证一下

28:07.240 --> 28:08.640
这两个属性是不是满足要求

28:08.640 --> 28:10.040
比方说账号必须要是多好位

28:10.040 --> 28:11.140
到多少位

28:11.140 --> 28:12.640
比方说账号是不是数据库里面

28:12.640 --> 28:13.540
已经存在了

28:13.540 --> 28:14.440
那就不能有重复了

28:14.440 --> 28:14.740
对吧

28:14.740 --> 28:16.240
要全部要一个个去验证

28:16.240 --> 28:17.440
非常繁硕的

28:17.440 --> 28:19.440
我们这里就不写

28:19.440 --> 28:21.440
我们这里就简单写一下

28:21.440 --> 28:22.740
所以说我们业务逻辑很简单

28:22.740 --> 28:24.440
但是为什么要写成这种格式

28:24.540 --> 28:26.040
因为业务逻辑就是要这种格式

28:26.040 --> 28:26.940
将来要改的话

28:26.940 --> 28:28.640
不要业务逻辑有修改

28:28.640 --> 28:29.740
只要接口不变

28:29.740 --> 28:30.740
那么我们在方法里边

28:30.740 --> 28:32.640
至于修改就行了

28:32.640 --> 28:34.240
这是添加

28:34.240 --> 28:36.540
我就给大家多扯了这么多

28:36.540 --> 28:37.040
添加过

28:37.040 --> 28:38.040
我们来试一下

28:38.040 --> 28:41.500
试一下那个添加

28:41.500 --> 28:44.400
require services

28:44.400 --> 28:47.400
admin service

28:47.400 --> 28:50.500
导入admin service

28:50.500 --> 28:52.200
然后我们这里边不是有一个方法吗

28:52.200 --> 28:52.500
对吧

28:52.500 --> 28:55.500
addadmin添加一个管理员

28:55.600 --> 28:56.500
我这里啥都没验证

28:56.500 --> 28:58.800
所以老老实实必须要把这些东西写好

28:58.800 --> 28:59.900
如果有验证的话

28:59.900 --> 29:00.400
你这里输

29:00.400 --> 29:01.400
一遍你这么瞎写

29:01.400 --> 29:03.000
他一定不会导致数据错乱的

29:03.000 --> 29:06.400
他该给你报出就报出

29:06.400 --> 29:08.400
一般验证通过的话

29:08.400 --> 29:11.200
这里就直接抛出错误

29:11.200 --> 29:12.100
那么这里

29:12.100 --> 29:12.700
添加一个

29:12.700 --> 29:17.300
随便写一个

29:17.300 --> 29:19.000
运行

29:19.000 --> 29:19.700
运行完了

29:19.700 --> 29:22.400
咱们来看一下数据库

29:22.400 --> 29:23.100
是不是有了

29:23.100 --> 29:23.500
OK

29:23.500 --> 29:24.900
这是添加

29:24.900 --> 29:26.200
那么删除

29:26.300 --> 29:28.300
删除也非常非常简单

29:28.300 --> 29:30.400
删除了有两种方式

29:30.400 --> 29:33.300
只要你如果说你手上已经有实力了

29:33.300 --> 29:35.200
已经有实力了

29:35.200 --> 29:37.400
那么就很简单很简单了

29:37.400 --> 29:39.300
你看怎么删

29:39.300 --> 29:40.800
比方说你已经有实力了

29:40.800 --> 29:41.700
给我传那个id进来

29:41.700 --> 29:42.100
对吧

29:42.100 --> 29:43.000
我根据id在删除

29:43.000 --> 29:44.300
同样是一步的

29:44.300 --> 29:46.700
跟数据库的操作权是一步的

29:46.700 --> 29:47.900
有两种方式

29:47.900 --> 29:49.000
方式一

29:49.000 --> 29:50.300
当这里边删除的时候

29:50.300 --> 29:51.200
你要判断

29:51.200 --> 29:52.700
如果说业务逻辑要考虑的话

29:52.700 --> 29:53.900
要判断一个管理员

29:53.900 --> 29:55.200
是不是只有最后一个

29:55.200 --> 29:56.200
最后一个就不能删了

29:56.200 --> 29:57.900
这些东西我就难得弄了

29:57.900 --> 29:59.000
这些东西都是业务逻辑

29:59.000 --> 30:00.000
我难得弄了

30:00.000 --> 30:00.200
好

30:00.200 --> 30:01.200
方式一

30:01.200 --> 30:03.400
方式一的话就是

30:03.400 --> 30:06.100
使用这种方式

30:06.100 --> 30:08.000
第一步

30:08.000 --> 30:09.900
得到实力

30:09.900 --> 30:11.100
如果说你已经有实力了

30:11.100 --> 30:12.400
比方说刚刚创建好了

30:12.400 --> 30:13.300
已经有一个实力了

30:13.300 --> 30:14.000
对吧

30:14.000 --> 30:15.200
那么这个就是实力

30:15.200 --> 30:16.000
这个实力里边

30:16.000 --> 30:17.500
本来就有方法可以删除

30:17.500 --> 30:19.000
所以说如果说你没有实力的话

30:19.000 --> 30:20.200
你d先去得到实力

30:20.200 --> 30:21.100
怎么得到实力呢

30:21.100 --> 30:22.600
我可以通过id来得到实力

30:22.600 --> 30:24.500
怎么来通过id得到实力呢

30:24.500 --> 30:25.400
这叫做查询

30:25.400 --> 30:26.600
查询我这里说一个吧

30:26.600 --> 30:28.500
我们后边会专门找你讲查询

30:28.500 --> 30:31.700
叫做fand1

30:31.700 --> 30:34.500
找一个

30:34.500 --> 30:37.300
应该是一个fandby id

30:37.300 --> 30:40.800
fandby pk

30:40.800 --> 30:43.300
通过组建primary key

30:43.300 --> 30:47.300
就组建通过组建去找一个用户

30:47.300 --> 30:48.700
传过来

30:48.700 --> 30:50.100
咱们来看一下吧

30:50.100 --> 30:51.700
always

30:51.700 --> 30:52.700
等待

30:52.700 --> 30:53.700
等待它完成

30:53.800 --> 30:55.700
能够得到实力

30:55.700 --> 30:56.700
我们输出实力

30:56.700 --> 30:58.500
它能不能找到管理员

30:58.500 --> 30:59.900
咱们来删一下

30:59.900 --> 31:04.130
现在我们使用

31:04.130 --> 31:07.630
eudemi-so-denet-eudemi

31:07.630 --> 31:08.630
给它传一个id

31:08.630 --> 31:09.930
看一下传哪个id呢

31:09.930 --> 31:12.130
传5这个id吧

31:12.130 --> 31:14.130
第三件是删除时间

31:14.130 --> 31:15.230
我们以后就看到了

31:15.230 --> 31:16.530
传一个5这个id

31:16.530 --> 31:17.230
传进去

31:17.230 --> 31:20.430
接下来我们来运行一下

31:20.430 --> 31:21.830
是不是打印出来了

31:21.830 --> 31:24.230
id为5的数据是不是打印出来了

31:24.330 --> 31:24.730
对不对

31:24.730 --> 31:25.630
你看打印出来了

31:25.630 --> 31:26.330
就非常简单

31:26.330 --> 31:27.830
这样子就把查询出来了

31:27.830 --> 31:29.430
查询在这里根本不用写什么

31:29.430 --> 31:30.330
深刻语句

31:30.330 --> 31:31.730
它会自动帮你生存深刻语句

31:31.730 --> 31:32.230
你看

31:32.230 --> 31:33.430
生存深刻语句就是那个是id

31:33.430 --> 31:35.230
对吧

31:35.230 --> 31:36.630
就可以查出来了

31:36.630 --> 31:37.730
那么得到实力过后

31:37.730 --> 31:39.730
那怎么来删呢

31:39.730 --> 31:40.930
怎么来删呢

31:40.930 --> 31:42.330
删除是用这种方式

31:42.330 --> 31:43.630
只要你能拿到实力

31:43.630 --> 31:45.130
我不管你从哪里拿到实力的

31:45.130 --> 31:46.130
比方说你创建过后

31:46.130 --> 31:47.030
不就是一个实力吗

31:47.030 --> 31:47.930
创建过后你把删了

31:47.930 --> 31:48.430
也可以

31:48.430 --> 31:49.730
只要你有实力

31:49.730 --> 31:50.830
非常简单

31:50.830 --> 31:51.930
删除

31:51.930 --> 31:52.630
怎么删除

31:52.630 --> 31:54.430
就是硬实

31:54.430 --> 31:55.530
destroy

31:55.530 --> 31:56.730
我们直接来吧

31:56.730 --> 31:59.630
删除实力

31:59.630 --> 32:02.660
destroy

32:02.660 --> 32:03.660
这就删了

32:03.660 --> 32:06.160
当然它是个异步的

32:06.160 --> 32:07.060
await

32:07.060 --> 32:07.760
这就删除了

32:07.760 --> 32:08.560
没有

32:08.560 --> 32:08.760
好

32:08.760 --> 32:11.700
重来看一下吧

32:11.700 --> 32:13.900
运行

32:13.900 --> 32:15.100
你看是不是运行了

32:15.100 --> 32:16.600
两条这个语句

32:16.600 --> 32:17.800
生那个成一条

32:17.800 --> 32:18.200
哎呀

32:18.200 --> 32:19.800
删除为什么是update呢

32:19.800 --> 32:22.600
因为我这个表是做到这个

32:22.600 --> 32:24.100
把它叫做偏制表

32:24.100 --> 32:26.100
我们把它叫做偏制表

32:26.100 --> 32:27.100
做一个偏制的

32:27.100 --> 32:29.500
就是这里有个dynatized

32:29.500 --> 32:30.600
所以说它删除的时候

32:30.600 --> 32:33.200
是我往这一列里边加一个东西

32:33.200 --> 32:33.500
看到没有

32:33.500 --> 32:35.000
是往这里边加一个东西

32:35.000 --> 32:36.900
它是用这种模式来做的

32:36.900 --> 32:38.000
没有意思吧

32:38.000 --> 32:40.800
这就是它不是真正的删除数据

32:40.800 --> 32:42.200
当然如果说你没有用偏制表

32:42.200 --> 32:43.100
就是这个配置

32:43.100 --> 32:43.600
还记得吗

32:43.600 --> 32:45.800
之前我们做了一个配置

32:45.800 --> 32:47.100
就是如果说你没有写这个

32:47.100 --> 32:48.900
那么它就真正的把它删除了

32:48.900 --> 32:50.700
当然我们更加希望是这么模式

32:50.700 --> 32:52.700
不要真正的去删除任何东西

32:52.700 --> 32:52.900
好

32:52.900 --> 32:53.500
删除过后

32:53.500 --> 32:54.700
你第二次再删除

32:54.700 --> 32:55.900
你就找不到了

32:55.900 --> 32:56.600
它找的时候

32:56.600 --> 32:58.800
它会自动的给你加上条件

32:58.800 --> 33:00.000
它会自动的给你加上条件

33:00.000 --> 33:00.700
你看

33:00.700 --> 33:03.100
加上条件是dynatized is now

33:03.100 --> 33:03.900
就是它查的时候

33:03.900 --> 33:04.700
所有的查询

33:04.700 --> 33:06.400
它都会给你加上这个条件

33:06.400 --> 33:07.500
is now

33:07.500 --> 33:08.700
表示的是

33:08.700 --> 33:11.200
它是没有被删除

33:11.200 --> 33:11.500
对吧

33:11.500 --> 33:12.800
它是now就不知道是没有被删除

33:12.800 --> 33:12.900
比较多

33:12.900 --> 33:15.600
我们现在再删除

33:15.600 --> 33:16.600
就爆错了

33:16.600 --> 33:18.400
它第一个东西都找不到

33:18.400 --> 33:20.200
Is now是不是找不到这个东西

33:20.200 --> 33:21.800
你看我们现在是

33:21.800 --> 33:22.500
它不是now了

33:22.600 --> 33:24.300
所以找不到这条纪录

33:24.300 --> 33:24.900
找不到这条纪录

33:24.900 --> 33:25.500
它得到的是什么

33:25.500 --> 33:26.500
得到的是now

33:26.500 --> 33:28.100
它报的说什么

33:28.100 --> 33:30.400
它无法调用Destroy

33:30.400 --> 33:32.000
通过now来调用Destroy

33:32.000 --> 33:33.100
那么这个地方是不是now

33:33.100 --> 33:35.100
所以我们这里可以判断一下

33:35.100 --> 33:36.300
这个都会比较业务逻辑

33:36.300 --> 33:37.900
这个东西要防止它爆错

33:37.900 --> 33:39.900
防止它爆的这种就是

33:39.900 --> 33:41.200
叫做错误处理

33:41.200 --> 33:43.300
这不叫业务逻辑

33:43.300 --> 33:44.300
好

33:44.300 --> 33:45.000
再删除实力

33:45.000 --> 33:46.200
对吧

33:46.200 --> 33:47.300
这是方式1

33:47.300 --> 33:48.400
这是方式1

33:48.400 --> 33:48.700
好

33:48.700 --> 33:50.000
第二种方式1

33:50.000 --> 33:52.000
它的好处就是什么呢

33:52.000 --> 33:55.100
如果说你手上已经有实力了

33:55.100 --> 33:56.700
那么你就直接用这种方式

33:56.700 --> 33:57.900
你不用去得到实力了

33:57.900 --> 33:59.400
直接删除就完成了

33:59.400 --> 34:01.300
如果你手上没有实力的话

34:01.300 --> 34:02.700
这种方式实际上不好的

34:02.700 --> 34:03.200
为什么

34:03.200 --> 34:05.200
因为它会执行两条涉口语句

34:05.200 --> 34:05.700
对不对

34:05.700 --> 34:07.100
第一条查询

34:07.100 --> 34:08.400
第二条去删除

34:08.400 --> 34:09.500
是不是执行两条

34:09.500 --> 34:12.200
而删除是不是只需要一条就够了

34:12.200 --> 34:12.400
对吧

34:12.400 --> 34:13.800
是不是只需要一条就够了

34:13.800 --> 34:15.700
而像我们这个方法里边是拿不到实力的

34:15.700 --> 34:15.900
对吧

34:15.900 --> 34:16.600
只有一个ID

34:16.600 --> 34:17.800
它拿不到实力

34:17.800 --> 34:19.100
那怎么办呢

34:19.100 --> 34:21.100
我们可以用方式2

34:21.100 --> 34:21.800
方式2呢

34:21.800 --> 34:23.300
我们就可以直接来删除

34:23.300 --> 34:24.100
怎么删除呢

34:24.100 --> 34:26.300
Denet

34:26.300 --> 34:26.900
对不对

34:26.900 --> 34:28.500
叫做Destroy

34:28.500 --> 34:29.400
直接调用Destroy

34:29.400 --> 34:31.100
它就不是实力调用了

34:31.100 --> 34:32.900
而是通过这个模型来调用

34:32.900 --> 34:34.500
那么这个时候调用的时候

34:34.500 --> 34:35.900
它要给它传

34:35.900 --> 34:36.600
传什么呢

34:36.600 --> 34:39.200
传条件

34:39.200 --> 34:40.400
传条件

34:40.400 --> 34:41.900
什么条件呢

34:41.900 --> 34:43.800
这里的一个ware

34:43.800 --> 34:44.500
ware是什么

34:44.500 --> 34:46.200
我要删除什么数据

34:46.200 --> 34:47.700
这叫查询条件

34:47.700 --> 34:48.700
我们后面讲查询的时候

34:48.700 --> 34:50.500
我还会详细说这个ware

34:50.600 --> 34:53.000
后面查询里面有能用的ware条件

34:53.000 --> 34:54.200
但这里都能用

34:54.200 --> 34:55.300
那么条件怎么写呢

34:55.300 --> 34:56.800
特别特别简单

34:56.800 --> 34:59.100
ID等于ErdermyID

34:59.100 --> 35:00.400
这个ID是什么意思

35:00.400 --> 35:04.200
就是模型里面的属性

35:04.200 --> 35:06.700
就是模型里面的属性

35:06.700 --> 35:08.000
就像对应到哪

35:08.000 --> 35:09.800
对应到这里

35:09.800 --> 35:11.400
组件它没有写

35:11.400 --> 35:13.200
那么ID是不是这个属性

35:13.200 --> 35:14.300
相当于是ID

35:14.300 --> 35:15.400
我要匹配什么了

35:15.400 --> 35:17.500
这里传过来的ID

35:17.500 --> 35:18.700
然后让它去删除

35:19.700 --> 35:20.200
没了

35:20.200 --> 35:21.100
一句话写完

35:21.100 --> 35:23.100
这样子它只会生成一条设可语句

35:23.100 --> 35:26.020
看一下

35:26.020 --> 35:27.220
你看是不是只生成一条

35:27.220 --> 35:28.920
当然它也不会生成delete

35:28.920 --> 35:30.320
它会生成update

35:30.320 --> 35:33.320
设置deleted ID

35:33.320 --> 35:34.620
这是删除

35:34.620 --> 35:35.420
对吧

35:35.420 --> 35:37.020
这是关于这个

35:37.020 --> 35:39.020
下面那个修改

35:39.020 --> 35:39.820
修改

35:39.820 --> 35:42.120
修改是一样的

35:42.120 --> 35:42.720
修改

35:42.720 --> 35:44.220
两种方式

35:44.220 --> 35:45.920
方式一

35:45.920 --> 35:48.120
方式一就是得到实力

35:48.120 --> 35:51.520
第一个方式得到实力

35:51.520 --> 35:52.520
得到实力

35:52.520 --> 35:54.220
因为它说这个东西是不是实力

35:54.220 --> 35:56.620
就是刚才我们不是用了一个ADD2的密码

35:56.620 --> 35:57.620
它返回了是不是实力

35:57.620 --> 35:58.620
它返回的不是

35:58.620 --> 36:01.120
它返回的是已经把它变成接成的一个普通对象了

36:01.120 --> 36:02.020
这个东西才是实力

36:02.020 --> 36:03.520
把它凸接成过后它就不是实力了

36:03.520 --> 36:04.920
它就是个平面对象

36:04.920 --> 36:06.220
play object

36:06.220 --> 36:06.920
得到实力

36:06.920 --> 36:07.720
那这里怎么得到呢

36:07.720 --> 36:09.020
这里也没拿不到实力

36:09.020 --> 36:09.620
对吧

36:09.620 --> 36:10.120
拿不到实力

36:10.120 --> 36:10.820
它不是实力

36:10.820 --> 36:12.920
它一般都是给它一个普通对象而已

36:12.920 --> 36:14.320
比方说咱们来做

36:14.320 --> 36:15.320
这个admin

36:15.320 --> 36:16.320
so

36:16.320 --> 36:17.720
updates.admin

36:17.720 --> 36:22.220
那么这边修改的时候一般要传两个数据

36:22.220 --> 36:23.120
一个是ID

36:23.120 --> 36:25.420
你要修改哪个管理员ID

36:25.420 --> 36:27.020
然后修改的就是内容

36:27.020 --> 36:29.120
那么我们要说我们修改ID为

36:29.120 --> 36:30.020
这个5好像没有了

36:30.020 --> 36:30.320
对吧

36:30.320 --> 36:31.620
5G没三了

36:31.620 --> 36:35.720
然后修改ID为4的

36:35.720 --> 36:37.020
修改ID为4

36:37.020 --> 36:37.620
内容是怎么拿

36:37.620 --> 36:42.960
我要把它的locking ID修改成哈哈

36:42.960 --> 36:44.560
我要做这么一件事

36:44.560 --> 36:46.460
那么这里来我们回到这

36:46.460 --> 36:48.060
那么第一步得到实力

36:48.060 --> 36:49.060
如果说方式一的话

36:49.060 --> 36:51.160
得到实力是不是一样了

36:51.160 --> 36:52.860
根据主键去找到用户

36:52.860 --> 36:53.660
对吧

36:53.660 --> 36:55.260
我们这里直接用ID

36:55.260 --> 36:56.060
对不对

36:56.060 --> 36:56.260
好

36:56.260 --> 36:57.060
然后呢

36:57.060 --> 36:58.760
第二步

36:58.760 --> 37:00.760
第二步就很简单了

37:00.760 --> 37:02.760
就一个个来呗

37:02.760 --> 37:04.460
比方说你要修改什么locking ID

37:04.460 --> 37:05.560
那么就因此

37:05.560 --> 37:07.960
locking ID

37:07.960 --> 37:10.060
等于什么admin obj

37:10.060 --> 37:11.360
locking ID

37:11.360 --> 37:11.960
对不对

37:11.960 --> 37:12.760
直接修改

37:12.760 --> 37:13.760
修改完了过后

37:13.760 --> 37:15.360
第二步

37:15.360 --> 37:18.160
包存 is save

37:18.160 --> 37:19.960
包存就完了

37:19.960 --> 37:20.560
是不是特别简单

37:20.560 --> 37:22.360
用了OIM框架之后

37:22.360 --> 37:24.560
而且一个代码非常有氧

37:24.560 --> 37:25.660
包错了

37:25.660 --> 37:26.760
什么

37:26.760 --> 37:30.510
sync

37:30.510 --> 37:31.610
好来

37:31.610 --> 37:33.610
你看是不是第一次查询

37:33.610 --> 37:35.810
第二次update修改

37:35.810 --> 37:36.210
对吧

37:36.210 --> 37:38.510
然后我们来看一下数据库

37:38.510 --> 37:39.610
刷新

37:39.610 --> 37:40.810
哈哈

37:40.810 --> 37:41.510
对不对

37:41.510 --> 37:41.610
好

37:41.610 --> 37:42.310
这个方式一啊

37:42.310 --> 37:43.510
但是方式一呢

37:43.510 --> 37:45.810
前的条件是你要有实力

37:45.810 --> 37:46.210
但是呢

37:46.210 --> 37:47.610
如果说你没有实力的话

37:47.610 --> 37:49.210
那么我们一般用方式二

37:49.210 --> 37:50.310
而且方式一呢

37:50.310 --> 37:51.210
如果说你没有实力的话

37:51.210 --> 37:51.710
用这种方式

37:51.710 --> 37:52.210
他会查

37:52.210 --> 37:52.910
他会查询

37:52.910 --> 37:54.210
查询一次修改一次

37:54.210 --> 37:54.610
对吧

37:54.610 --> 37:55.410
会运行两次

37:55.410 --> 37:56.510
影响效率

37:56.510 --> 37:58.310
这个就我们尽量少运行

37:58.310 --> 37:59.110
尽量少运行

37:59.110 --> 37:59.610
因为数据库

37:59.610 --> 38:01.810
他运行的数据确实有点慢

38:01.810 --> 38:03.910
但比文件处理要快一些啊

38:03.910 --> 38:04.410
但是呢

38:04.410 --> 38:06.410
还是有些慢啊

38:06.410 --> 38:07.110
然后第二种方式呢

38:07.110 --> 38:08.010
就直接修改

38:08.010 --> 38:10.510
同样的admin update

38:10.510 --> 38:12.810
通过这种方式来直接修改

38:12.810 --> 38:13.910
第一个参数团什么呢

38:13.910 --> 38:15.010
传令要修改什么数据

38:15.110 --> 38:16.810
admin obj直接登进去

38:16.810 --> 38:18.210
这种人直接登进去

38:18.210 --> 38:19.510
第二个参数传条件

38:19.510 --> 38:20.510
你要修改哪些数据

38:20.510 --> 38:21.010
不然的话

38:21.010 --> 38:22.610
他就把全表修改了

38:22.610 --> 38:23.410
传条件

38:23.410 --> 38:24.010
were

38:24.010 --> 38:24.110
对吧

38:24.110 --> 38:25.110
又一又一样了

38:25.110 --> 38:25.310
对吧

38:25.310 --> 38:26.010
id

38:26.010 --> 38:27.310
id放这

38:27.310 --> 38:28.410
说完了

38:28.410 --> 38:29.610
这是方式二

38:29.610 --> 38:31.010
对吧

38:31.010 --> 38:31.710
这方式二

38:31.710 --> 38:33.210
那又说他返回的是什么结果呢

38:33.210 --> 38:33.910
返回的结果呢

38:33.910 --> 38:36.110
它是一个对象

38:36.110 --> 38:38.510
我们看一下返回的结果吧

38:38.510 --> 38:41.280
result

38:41.280 --> 38:41.480
哎

38:41.480 --> 38:42.280
我都一点忘了

38:42.280 --> 38:43.980
他是对象还是受影响的行数

38:43.980 --> 38:46.080
他里边肯定有受影响的行数

38:46.080 --> 38:47.380
但是他是不是

38:47.380 --> 38:48.120
还有没有其他性

38:48.120 --> 38:49.380
我就一点起不住了

38:49.380 --> 38:50.180
返回吧

38:50.180 --> 38:51.780
返回就知道了

38:51.780 --> 38:53.080
这边我们可以用Z

38:53.080 --> 38:54.980
来得到R

38:54.980 --> 38:57.080
输出R

38:57.080 --> 39:00.140
看一下

39:00.140 --> 39:01.740
音响

39:01.740 --> 39:03.340
得到的是一个输主

39:03.340 --> 39:06.440
输主里边表示的是受影响的行数

39:06.440 --> 39:07.540
0

39:07.540 --> 39:08.340
受影响的行数

39:08.340 --> 39:08.540
0

39:08.540 --> 39:10.140
应该是受影响的行数

39:10.140 --> 39:11.140
不要说

39:11.140 --> 39:12.940
哎

39:12.940 --> 39:13.740
看一下

39:13.740 --> 39:15.040
应该是受影响的行数

39:15.040 --> 39:15.440
对

39:15.440 --> 39:16.440
受影响的行数

39:16.440 --> 39:17.140
1

39:17.240 --> 39:18.240
刚才是没有任何改动

39:18.240 --> 39:18.440
对吧

39:18.440 --> 39:19.440
现在有改动了

39:19.440 --> 39:20.840
那么现在就是受影响的行数

39:20.840 --> 39:21.640
是1

39:21.640 --> 39:23.640
他为什么是个输主呢

39:23.640 --> 39:24.940
为什么是个输主呢

39:24.940 --> 39:26.540
因为他不知道你这个收获语句

39:26.540 --> 39:27.640
到底写了多少条

39:27.640 --> 39:29.040
因为我们知道一次运行的话

39:29.040 --> 39:30.640
可以运行多少收获语句

39:30.640 --> 39:31.440
多少收获语句运行

39:31.440 --> 39:33.840
而过来他可能会多个受影响的行数

39:33.840 --> 39:35.940
所以他这里用的是一个输主

39:35.940 --> 39:41.760
然后是删除语句是一样的

39:41.760 --> 39:42.560
删除语句

39:42.560 --> 39:43.160
应该是一样的

39:43.160 --> 39:47.100
我们看一下吧

39:47.100 --> 39:48.500
输出R

39:48.500 --> 39:49.300
那么这里

39:49.300 --> 39:50.200
删除4

39:50.200 --> 39:54.360
ID为4的

39:54.460 --> 39:55.160
运行

39:55.160 --> 39:56.260
是不是

39:56.260 --> 39:57.060
删除语句

39:57.060 --> 39:58.260
他只有一个

39:58.260 --> 39:59.160
updates语句

39:59.160 --> 40:01.460
他也有给你弄了两个

40:01.460 --> 40:02.660
这是什么道理

40:02.660 --> 40:04.160
我也不知道这是什么规道理

40:04.160 --> 40:05.160
他这个地方是输主

40:05.160 --> 40:06.060
这个地方是一个数字

40:06.060 --> 40:06.660
总之他会得

40:06.660 --> 40:08.060
你可以得到受影响的行数

40:08.060 --> 40:10.060
但一般我们都用不到这些信息

40:10.060 --> 40:11.760
所以说我也没怎么关注

40:11.760 --> 40:11.960
好

40:11.960 --> 40:13.060
那么我们这就讲完了

40:13.060 --> 40:13.960
真伤感

40:13.960 --> 40:15.460
你们现在做什么了

40:15.460 --> 40:16.860
你们现在要做什么

40:16.860 --> 40:18.560
第一件事

40:18.560 --> 40:20.760
把这个二代命service写完

40:20.760 --> 40:21.560
第二件事

40:21.560 --> 40:24.160
把book class student

40:24.160 --> 40:25.160
全部写上

40:25.160 --> 40:29.260
对每一个模型进行争伤感

40:29.260 --> 40:30.860
不用去涉及任何的业务逻辑

40:30.860 --> 40:32.260
但是你脑袋里面可以想一想

40:32.260 --> 40:33.660
如果说他有业务逻辑的话

40:33.660 --> 40:36.460
他应该有什么样的业务逻辑

40:36.460 --> 40:39.160
主要从验证的角度去想

40:39.160 --> 40:41.260
你要说我给你解释很多

40:41.260 --> 40:42.560
很复杂的业务逻辑

40:42.560 --> 40:43.960
也没有必要

40:43.960 --> 40:45.660
我们如果说现在这个系统里面

40:45.660 --> 40:46.760
如果说要涉及业务逻辑的话

40:46.760 --> 40:48.460
它肯定就是跟验证相关的

40:48.460 --> 40:49.360
你可以自己去想一想

40:49.360 --> 40:50.460
但是你不用去写

40:50.460 --> 40:51.060
写起来麻烦

40:51.160 --> 40:54.360
我们前端不用关注这么深的东西

40:54.360 --> 40:56.760
这里是咱们service

40:56.760 --> 40:57.660
现在把写完

40:57.660 --> 41:00.160
我下节后就直接用写完的了

41:00.160 --> 41:01.360
这是这里刻的内容

