WEBVTT

00:00.370 --> 00:05.370
前面我们学习了Global 拳击对象

00:05.370 --> 00:09.370
NodeJS里边除了在拳击对象里面给你提供了一些API

00:09.370 --> 00:11.370
其实也没多少 我没看到过了

00:11.370 --> 00:15.370
但是我们会经常用到比方是Console 输出

00:15.370 --> 00:19.370
更多的时候NodeJS是把那些很多的API

00:19.370 --> 00:22.370
因为它是要让你完整的去控制你的操作系统

00:22.370 --> 00:24.370
所以说它会提供很多的API

00:24.370 --> 00:26.370
那么这些API

00:26.370 --> 00:29.370
虽然从我们很少需要用到跟操作系统相关的

00:29.370 --> 00:31.370
很少会用到

00:31.370 --> 00:34.370
但是它会把这些API封装到不同的模块里边

00:34.370 --> 00:38.370
分门别类的把它作为内置模块提供给你使用

00:38.370 --> 00:41.370
所以我们这里边来看一下一些基本的内置模块

00:41.370 --> 00:45.370
其实我们整个这一张都是在讲内置模块

00:45.370 --> 00:47.370
一个来 首先是个OS

00:47.370 --> 00:49.370
这个链接 进去

00:49.370 --> 00:53.370
这个OS它这个模块是提供跟操作系统相关的

00:53.370 --> 00:57.370
主要是读取操作系统的一些信息

00:57.370 --> 00:58.370
咱们来看一下

00:58.370 --> 01:01.370
这里边我们当然对面API太多了

01:01.370 --> 01:03.370
不可能说一个一个来 不可能的

01:03.370 --> 01:05.370
我们就还在那看一下

01:05.370 --> 01:07.370
看一下一些比较重要的

01:07.370 --> 01:08.370
这些谈不上重要

01:08.370 --> 01:10.370
我们平时经常用的

01:10.370 --> 01:13.370
我都可以用这个旗子给大家标出来

01:13.370 --> 01:15.370
其他的我们来了解一下就行了

01:15.370 --> 01:17.370
一个是EOL

01:17.370 --> 01:19.370
看这个主要是

01:19.370 --> 01:22.370
看这个EOL主要是了解一下它的概念

01:22.370 --> 01:25.370
那么这个玩意是什么呢 叫做End of Line

01:25.370 --> 01:26.370
什么意思呢

01:26.370 --> 01:29.370
就是一行结束的分割符

01:29.370 --> 01:30.370
一行结束的分割符

01:30.370 --> 01:32.370
原来说不是写钢N吗

01:32.370 --> 01:34.370
但是不同的操作系统是不一样的

01:34.370 --> 01:38.370
在Linux或者是Ulicus的一个体系下的操作系统

01:38.370 --> 01:39.370
它是一个写钢N

01:39.370 --> 01:40.370
包括我们的Mac电脑

01:40.370 --> 01:42.370
Mac电脑它也是写钢N

01:42.370 --> 01:46.370
Windows操作系统它是写钢R加写钢N

01:46.370 --> 01:48.370
所以说它也不一样的

01:48.370 --> 01:50.370
那如果说你要根据不同的操作系统

01:50.370 --> 01:51.370
使用不同的分割符的话

01:51.370 --> 01:53.370
那么可以使用这个长量

01:53.370 --> 01:54.370
OS EOL

01:54.370 --> 01:55.370
大家看一下吧

01:55.370 --> 01:58.370
我们这里导入这个OS

01:58.370 --> 01:59.370
Require

01:59.370 --> 02:00.370
OS

02:00.370 --> 02:03.370
输出这个OS EOL

02:03.370 --> 02:04.370
看一下

02:04.370 --> 02:06.370
Load index

02:06.370 --> 02:09.370
看不见 它已经转移了

02:09.370 --> 02:11.370
它是一个写钢R写钢N

02:11.370 --> 02:13.370
在Windows里边

02:13.370 --> 02:16.370
那么在Ulicus操作系统下面

02:16.370 --> 02:17.370
就是写钢N

02:17.370 --> 02:19.370
这是个长量

02:19.370 --> 02:21.370
然后再往下看

02:21.370 --> 02:23.370
下面我们看一下一个ARCH

02:23.370 --> 02:25.370
那么这个网页是什么

02:25.370 --> 02:30.370
这个网页是获取CPU的价购名

02:30.370 --> 02:32.370
目前的CPU价购名

02:32.370 --> 02:35.370
主要是集中在X32和X64

02:35.370 --> 02:38.370
如果说你想知道什么是价购名的话

02:38.370 --> 02:40.370
那么你可以去看一下我那个博客

02:40.370 --> 02:42.370
博客里边我专门有篇文章

02:42.370 --> 02:45.370
写到这个关于32位和64位

02:45.370 --> 02:46.370
到底是怎么回事

02:46.370 --> 02:47.370
你可以去看一下

02:47.370 --> 02:49.370
这里关于

02:49.370 --> 02:50.370
这是我们看一下吧

02:50.370 --> 02:52.370
我的CPU肯定是X64

02:52.370 --> 02:56.900
运销

02:56.900 --> 02:58.900
X64

02:58.900 --> 03:00.900
这是关于这个

03:00.900 --> 03:02.900
现在我们继续往后看

03:02.900 --> 03:03.900
一个是CPU S

03:03.900 --> 03:04.900
这个是网页是什么

03:04.900 --> 03:07.900
这个网页是获取CPU的

03:07.900 --> 03:09.900
每一个盒的信息

03:09.900 --> 03:12.900
当然你要对硬件有些了解

03:12.900 --> 03:13.900
你才知道它有些显示什么东西

03:13.900 --> 03:15.900
不过我们平时的一半对

03:15.900 --> 03:17.900
它是一个数组

03:17.900 --> 03:18.900
我们平时的一半都是用于

03:18.900 --> 03:20.900
获得它有多少个CPU内核

03:20.900 --> 03:22.900
咱们看一下

03:22.900 --> 03:23.900
我这里是八核的

03:23.900 --> 03:25.900
我们这里可以用这个数组点lens

03:25.900 --> 03:26.900
来找到

03:26.900 --> 03:29.900
它每一个信息都是一个对象

03:29.900 --> 03:31.900
包括它的就是

03:31.900 --> 03:33.900
主屏数

03:33.900 --> 03:34.900
主屏是多少

03:34.900 --> 03:35.900
那么我们这里来看

03:35.900 --> 03:36.900
是八核的

03:36.900 --> 03:38.900
那么这是关于这个

03:38.900 --> 03:40.900
FreeMan

03:40.900 --> 03:42.900
这个FreeMan是哪一样

03:42.900 --> 03:44.900
它是指的是

03:44.900 --> 03:46.900
得到我们当前

03:46.900 --> 03:49.900
还有多少空前的内存

03:49.900 --> 03:51.900
就我们内存还剩下多少

03:51.900 --> 03:52.900
可以用

03:52.900 --> 03:56.270
这是FreeMan

03:56.270 --> 03:57.270
看一下吧

04:00.270 --> 04:01.270
console

04:01.270 --> 04:02.270
这个是

04:02.270 --> 04:03.270
或许当前还有多少个内存

04:03.270 --> 04:04.270
当然它这个是字节

04:04.270 --> 04:05.270
打印出来是字节

04:05.270 --> 04:07.270
我们都是以字节

04:09.270 --> 04:11.270
OS

04:11.270 --> 04:12.270
打印出来都是字节

04:12.270 --> 04:13.270
那如果说你把换成

04:13.270 --> 04:14.270
其他单位的话

04:14.270 --> 04:15.270
你除非

04:15.270 --> 04:17.270
比方说你要把它换成

04:17.270 --> 04:19.270
KB就除以1024

04:19.270 --> 04:20.270
如果说你要换成

04:20.270 --> 04:21.270
MB

04:21.270 --> 04:22.270
多少兆

04:22.270 --> 04:25.270
除以1024的平方

04:25.270 --> 04:27.270
如果说你要换成

04:27.270 --> 04:28.270
多少G

04:28.270 --> 04:30.270
除以1024的3次方

04:30.270 --> 04:32.270
或者是除以

04:32.270 --> 04:34.270
因为1024就是2的14方

04:34.270 --> 04:35.270
对吧

04:35.270 --> 04:36.270
所以说我们再除以

04:36.270 --> 04:38.270
乘以2的30次方

04:38.270 --> 04:39.270
也可以

04:39.270 --> 04:40.270
OK

04:40.270 --> 04:41.270
那么我们看一下

04:41.270 --> 04:42.270
那么我这里

04:42.270 --> 04:44.270
还有8G的内存可以用

04:44.270 --> 04:47.650
这个HomeDL

04:47.650 --> 04:48.650
这个东西有的时候

04:48.650 --> 04:49.650
还可以

04:49.650 --> 04:51.650
这个还说还可以

04:51.650 --> 04:52.650
它是来获取什么呢

04:52.650 --> 04:53.650
它是来获取那个

04:53.650 --> 04:55.650
咱们的就是

04:56.650 --> 04:57.650
应该怎么来翻译呢

04:57.650 --> 04:59.650
HomeDL

05:00.650 --> 05:02.650
咱们的

05:03.650 --> 05:05.650
用户目录

05:06.650 --> 05:07.650
我们看一下我们的用户目录

05:07.650 --> 05:08.650
我的用户目录

05:08.650 --> 05:10.650
在C盘的User时间

05:10.650 --> 05:11.650
KB里边

05:11.650 --> 05:13.650
它是用来做这么一件事的

05:14.650 --> 05:16.650
下边这个呢

05:16.650 --> 05:17.650
是Holster内

05:18.650 --> 05:20.650
获取我们的主机名

05:21.650 --> 05:23.650
这些东西都是跟操作系统相关的

05:23.650 --> 05:24.650
Holster内

05:24.650 --> 05:26.650
获取我们的主机名

05:27.650 --> 05:28.650
保存

05:28.650 --> 05:29.650
看一下吧

05:29.650 --> 05:30.650
这是我的主机名

05:30.650 --> 05:31.650
那主机名在哪呢

05:31.650 --> 05:32.650
在这

05:32.650 --> 05:33.650
我的电脑点右键

05:33.650 --> 05:35.650
主机名主机名

05:35.650 --> 05:37.650
你看就做这个主机名

05:39.650 --> 05:40.650
然后我继续

05:40.650 --> 05:42.650
下边这个TamDL

05:42.650 --> 05:43.650
这个玩意还有点用

05:43.650 --> 05:45.650
就这两个玩意还有点用

05:45.650 --> 05:46.650
可能稍微用了多一点

05:46.650 --> 05:47.650
其实整个这个呢

05:47.650 --> 05:48.650
也用的很少

05:48.650 --> 05:49.650
稍微用的多点就是这样

05:49.650 --> 05:50.650
一个是呢

05:50.650 --> 05:51.650
我们可能会根据

05:51.650 --> 05:53.650
不同的CPU内核

05:53.650 --> 05:54.650
去开不同的线程

05:54.650 --> 05:55.650
那个漏的接式

05:55.650 --> 05:56.650
里边是可以开线程的

05:56.650 --> 05:57.650
是吧

05:57.650 --> 05:58.650
不过呢

05:58.650 --> 05:59.650
可能有点麻烦

05:59.650 --> 06:01.650
可能给大家想象的呢

06:01.650 --> 06:02.650
不太一样

06:02.650 --> 06:03.650
有点麻烦

06:03.650 --> 06:04.650
那么这个

06:04.650 --> 06:06.650
如果说你要开多个线程的话

06:06.650 --> 06:08.650
那么可以根据不同的CPU内核

06:08.650 --> 06:10.650
来去做一些特殊的处理

06:10.650 --> 06:11.650
因为我们漏的接式

06:11.650 --> 06:13.650
实际上是支持世界家插件的

06:13.650 --> 06:14.650
如果说你回世界家的话

06:14.650 --> 06:16.650
可以再用开发一些

06:16.650 --> 06:18.650
世界家插件给大家加进去

06:18.650 --> 06:19.650
这个TamDL

06:19.650 --> 06:20.650
这个东西是获取

06:20.650 --> 06:22.650
我们操作系统的临时目录

06:22.650 --> 06:23.650
因为有的时候

06:23.650 --> 06:25.650
可能会临时的保存一些文件

06:25.650 --> 06:27.650
临时保存一些文件的时候

06:27.650 --> 06:28.650
我们就可以把它保持到

06:28.650 --> 06:29.650
这个目录下面

06:29.650 --> 06:30.650
那么目录在哪呢

06:30.650 --> 06:31.650
不同的操作系统

06:31.650 --> 06:32.650
它临时目录不一样

06:32.650 --> 06:33.650
同一个操作系统

06:33.650 --> 06:34.650
不同的用户

06:34.650 --> 06:35.650
它的临时目录可能也不一样

06:35.650 --> 06:36.650
所以说

06:36.650 --> 06:37.650
我们可以通过这个东西

06:37.650 --> 06:38.650
来动态获取

06:38.650 --> 06:41.650
这个是OSTamDL

06:44.650 --> 06:45.650
什么呢

06:45.650 --> 06:47.650
叫什么来的

06:47.650 --> 06:48.650
TMP

06:48.650 --> 06:52.650
TamDL

06:52.650 --> 06:54.650
保存

06:54.650 --> 06:56.650
我在这

06:56.650 --> 06:58.650
那么这是关于

06:58.650 --> 07:01.650
操作系统的里边的一些信息

07:01.650 --> 07:06.650
AboutOS

07:06.650 --> 07:07.650
现在我们再看

07:07.650 --> 07:08.650
第二个

07:08.650 --> 07:09.650
第二个就是类似的模块

07:09.650 --> 07:10.650
就是PASS

07:10.650 --> 07:11.650
这个模块用的比较多了

07:11.650 --> 07:13.650
你们学过WePAC的话

07:13.650 --> 07:14.650
这个模块用的

07:14.650 --> 07:15.650
是非常非常多的

07:15.650 --> 07:16.650
咱们来看一下

07:16.650 --> 07:18.650
这里边的一些API

07:18.650 --> 07:19.650
打开

07:21.650 --> 07:22.650
我们这里看

07:22.650 --> 07:23.650
一个是BassName

07:23.650 --> 07:24.650
BassName是来干嘛的呢

07:24.650 --> 07:26.650
它是来获取

07:26.650 --> 07:27.650
你给它一个路径

07:27.650 --> 07:30.650
它来获取你的文件名

07:30.650 --> 07:32.650
文件的全名

07:32.650 --> 07:33.650
就这么个意思

07:33.650 --> 07:34.650
其实这个东西

07:34.650 --> 07:35.650
中文的翻译

07:35.650 --> 07:38.650
跟英文环境还不太一样

07:38.650 --> 07:39.650
我给它说一下吧

07:39.650 --> 07:41.650
我们平时说的FileName

07:41.650 --> 07:42.650
文件名指的是什么呢

07:42.650 --> 07:45.650
指的是文件的整个路径

07:45.650 --> 07:46.650
是整个路径

07:46.650 --> 07:47.650
而且是决定路径

07:47.650 --> 07:49.650
从某一个盘幅出发

07:49.650 --> 07:50.650
到某一个路径

07:50.650 --> 07:51.650
到某一个路径下面的

07:51.650 --> 07:52.650
某一个文件

07:52.650 --> 07:54.650
这叫做FileName

07:54.650 --> 07:57.650
但是我们把它翻译成文件路径

07:57.650 --> 07:58.650
对吧

07:58.650 --> 07:59.650
文件路径

07:59.650 --> 08:02.650
英文里面的PASS

08:02.650 --> 08:04.650
是一个更加广泛的意识

08:04.650 --> 08:05.650
是一个更加广泛的意识

08:05.650 --> 08:07.650
它往往是指的是Mulu

08:07.650 --> 08:09.650
或者是一个URL路径

08:09.650 --> 08:10.650
这种PASS

08:10.650 --> 08:11.650
URL路径里面

08:11.650 --> 08:12.650
这一部分

08:12.650 --> 08:14.650
这一部分叫做PASS

08:14.650 --> 08:15.650
还有一个东西

08:15.650 --> 08:16.650
叫做BassName

08:16.650 --> 08:17.650
BassName

08:17.650 --> 08:19.650
然后往往是指的是这一部分

08:19.650 --> 08:21.650
我们把它发

08:21.650 --> 08:22.650
这个东西看成文件名

08:22.650 --> 08:23.650
对吧

08:23.650 --> 08:25.650
这个环境余境不一样的话

08:25.650 --> 08:26.650
还真不好

08:26.650 --> 08:28.650
还真有一些差异

08:28.650 --> 08:29.650
大家知道有这么回事就行了

08:29.650 --> 08:30.650
BassName

08:30.650 --> 08:31.650
它是获取这一部分

08:31.650 --> 08:33.650
也就是获取整个路径里面的

08:33.650 --> 08:34.650
最后一个部分

08:34.650 --> 08:35.650
它就这么一个意识

08:35.650 --> 08:36.650
好

08:36.650 --> 08:37.650
咱们来试一下吧

08:37.650 --> 08:39.650
这里边我们导入PASS

08:40.650 --> 08:42.650
PASS

08:42.650 --> 08:44.650
PASS里边很多好像数都还是蛮有用的

08:44.650 --> 08:45.650
真的蛮有用的

08:45.650 --> 08:47.650
比方说我们这里随便给它写一些

08:47.650 --> 08:49.650
随便给它写一些

08:49.650 --> 08:50.650
它不会去找这个路径

08:50.650 --> 08:51.650
怎么也没有存在

08:51.650 --> 08:53.650
它不会去找了

08:53.650 --> 08:54.650
好

08:54.650 --> 08:55.650
咱们来看一下

08:55.650 --> 08:57.960
输出

08:57.960 --> 08:58.960
BassName

08:58.960 --> 08:59.960
输出

08:59.960 --> 09:00.960
BassName

09:00.960 --> 09:04.550
好 运行

09:04.550 --> 09:05.550
你看是不是得到A点A点没有

09:05.550 --> 09:06.550
对吧

09:06.550 --> 09:07.550
当然这个如果说你不写

09:07.550 --> 09:08.550
这个

09:08.550 --> 09:09.550
不写后日名的话

09:09.550 --> 09:10.550
那么它就得到A

09:10.550 --> 09:11.550
对吧

09:11.550 --> 09:12.550
是这么个意思吧

09:12.550 --> 09:13.550
OK

09:13.550 --> 09:14.550
那么第2个参数是怎么意思呢

09:14.550 --> 09:15.550
第2个参数是这样子

09:15.550 --> 09:17.550
第2个参数是那个

09:17.550 --> 09:20.550
就是它的文件的扩展名叫Extension

09:20.550 --> 09:21.550
如果说你传了的话

09:21.550 --> 09:23.550
比方说我传一个Extension

09:23.550 --> 09:25.550
那么我们来看一下这个结果

09:25.550 --> 09:26.550
它只得到A

09:26.550 --> 09:28.550
它就会去掉这个后日名

09:28.550 --> 09:29.550
对吧

09:29.550 --> 09:30.550
后日名匹配上了

09:30.550 --> 09:31.550
它就去掉

09:31.550 --> 09:32.550
如果说后日名没有匹配上了

09:32.550 --> 09:33.550
它就不去掉

09:33.550 --> 09:35.550
就这么一个意识

09:35.550 --> 09:36.550
这是BassName

09:36.550 --> 09:38.550
将来有可能会用到

09:38.550 --> 09:39.550
你要说现在我可以

09:39.550 --> 09:41.550
突然给你举一个什么样的长计

09:41.550 --> 09:42.550
还真不好举

09:42.550 --> 09:44.550
后边我们学到文件处理过后

09:44.550 --> 09:45.550
像这些Pass里边的东西

09:45.550 --> 09:47.550
我们还用的还是蛮多的

09:47.550 --> 09:48.550
这里

09:48.550 --> 09:49.550
我们现在就

09:49.550 --> 09:50.550
我们不要去背

09:50.550 --> 09:51.550
真正可以不用去背

09:51.550 --> 09:52.550
下来你可以像我这样子

09:52.550 --> 09:54.550
去一个一个试验一下

09:54.550 --> 09:55.550
感受一下

09:55.550 --> 09:56.550
有那么一种感觉就行了

09:56.550 --> 09:57.550
不用去背

09:57.550 --> 09:58.550
以后要用到的时候

09:58.550 --> 10:00.550
你至少脑袋里面知道

10:00.550 --> 10:01.550
好像是有音源

10:01.550 --> 10:03.550
记得好像是有那么一个工具函数

10:03.550 --> 10:04.550
可以帮我们做什么事

10:04.550 --> 10:06.550
然后去查一下文档

10:06.550 --> 10:07.550
就完事了

10:07.550 --> 10:08.550
然后

10:08.550 --> 10:09.550
这个是分割符

10:09.550 --> 10:10.550
这什么意思呢

10:10.550 --> 10:12.550
就是说我们的操作系统

10:12.550 --> 10:14.550
咱们的Ulicous操作系统下面

10:14.550 --> 10:15.550
就是MAC

10:15.550 --> 10:16.550
Linux

10:16.550 --> 10:18.550
这些都属于Ulicous操作系统体系

10:18.550 --> 10:19.550
在这个体系下面的分割符

10:19.550 --> 10:21.550
它是一个左鞋杠作为分割符

10:21.550 --> 10:23.550
但是我们的Windows操作系统

10:23.550 --> 10:24.550
是比较奇葩的

10:24.550 --> 10:25.550
它是右鞋杠分割符

10:25.550 --> 10:26.550
分割符不一样

10:26.550 --> 10:27.550
所以说

10:27.550 --> 10:28.550
它这里

10:28.550 --> 10:31.550
它可以通过Pass里边的一个属性

10:31.550 --> 10:32.550
叫Dynamator

10:32.550 --> 10:33.550
它告诉你

10:33.550 --> 10:35.550
我这个当前操作系统的分割符

10:35.550 --> 10:36.550
是什么

10:37.550 --> 10:39.550
哦这个东西还不是

10:39.550 --> 10:40.550
还不是这个分割符

10:40.550 --> 10:42.550
这个还不是这个分割符

10:42.550 --> 10:43.550
另外一个才是

10:43.550 --> 10:44.550
我这里记得

10:44.550 --> 10:46.550
一个叫Sig

10:46.550 --> 10:47.550
Sig

10:47.550 --> 10:48.550
这个属性才是

10:48.550 --> 10:50.550
才是分割符的意思

10:51.550 --> 10:55.440
这个属性才是

10:56.440 --> 10:57.440
不是吗

10:57.440 --> 10:59.440
我看一下这个

10:59.440 --> 11:01.440
哦Sep

11:02.440 --> 11:03.440
Seperate

11:03.440 --> 11:07.010
Seperate表示分割的意思

11:11.010 --> 11:14.010
Windows操作系统是不是这个鞋杠

11:14.010 --> 11:16.010
当然你如果在麦克上面运行的话

11:16.010 --> 11:17.010
就是左鞋杠

11:17.010 --> 11:19.010
它根据不同的操作系统

11:19.010 --> 11:21.010
它是用一个这个东西来进行记录

11:21.010 --> 11:22.010
所以说你如果说你以后

11:22.010 --> 11:23.010
要根据不同的

11:23.010 --> 11:25.010
要拼接路径的时候

11:25.010 --> 11:27.010
要使用分割符的时候

11:27.010 --> 11:28.010
那么你就完全可以

11:28.010 --> 11:30.010
用这个属性来作为分割符

11:30.010 --> 11:31.010
这样子就可以

11:31.010 --> 11:32.010
适用于不同的操作系统

11:32.010 --> 11:33.010
因为我们的Load程序

11:33.010 --> 11:35.010
它是划平台的

11:35.010 --> 11:37.010
它都是就托付给Load来运行

11:37.010 --> 11:38.010
有点像Java

11:38.010 --> 11:39.010
有点像Java虚礼机

11:39.010 --> 11:41.010
Java虚礼机运行Java程序

11:41.010 --> 11:42.010
那么它是这个东西

11:42.010 --> 11:44.010
是托付给Load运行的

11:44.010 --> 11:45.010
Load是划平台的

11:45.010 --> 11:46.010
Windows上的运行

11:46.010 --> 11:48.010
在Linux也能运行

11:48.010 --> 11:50.010
Microsoft也能运行

11:50.010 --> 11:51.010
是这么个意思

11:51.010 --> 11:52.010
那么Dynamator什么意思呢

11:52.010 --> 11:53.010
Dynamator

11:53.010 --> 11:56.010
单词的语境真不好翻译

11:57.010 --> 11:59.010
这个它也叫做分割

11:59.010 --> 12:01.010
它指的是一块一块的分割

12:01.010 --> 12:02.010
Seperate

12:02.010 --> 12:03.010
Seperate指的是

12:03.010 --> 12:05.010
同一块东西的内部分割

12:05.010 --> 12:06.010
Dynamator

12:06.010 --> 12:08.010
Dynamator它指的是

12:08.010 --> 12:10.010
不同的东西的分割

12:10.010 --> 12:12.010
比方说我们

12:12.010 --> 12:14.010
环境变量

12:14.010 --> 12:16.010
我们来看一下我们的环境变量

12:16.010 --> 12:17.010
我们之前学过的

12:17.010 --> 12:18.010
Process里边的M

12:18.010 --> 12:20.010
里边一个环境变量Pass

12:20.010 --> 12:22.010
我们来看一下吧

12:22.010 --> 12:23.010
你看Windows操作系统

12:23.010 --> 12:24.010
里边的环境变量

12:24.010 --> 12:26.010
它是用分号分割的

12:26.010 --> 12:28.010
每一个路径是用分号分割的

12:28.010 --> 12:30.010
这就是Dynamator

12:30.010 --> 12:32.010
那么在Linux操作系统

12:32.010 --> 12:33.010
就由那个操作系统下面

12:33.010 --> 12:34.010
它不是用分号分割

12:34.010 --> 12:35.010
它是用帽号分割

12:35.010 --> 12:37.010
分割符也不一样

12:37.010 --> 12:38.010
那么如果说我要分割

12:38.010 --> 12:39.010
我这个路径

12:39.010 --> 12:40.010
要在不同的操作系统里面

12:40.010 --> 12:41.010
都要运行的话

12:41.010 --> 12:42.010
我肯定不能这样子写

12:42.010 --> 12:43.010
不要让Seperate指

12:43.010 --> 12:44.010
我用一个分号来写

12:44.010 --> 12:45.010
那肯定不好

12:45.010 --> 12:47.010
因为到了Unicus操作系统

12:47.010 --> 12:48.010
就可能要出问题

12:48.010 --> 12:49.010
所以说我们可以用Pass

12:49.010 --> 12:51.010
Dynamator

12:51.010 --> 12:52.010
Dynamator

12:52.010 --> 12:53.010
它根据不同的操作系统

12:53.010 --> 12:54.010
当前操作系统

12:54.010 --> 12:55.010
应该用什么样的分割符

12:55.010 --> 12:56.010
那你用它来进行分割

12:56.010 --> 12:57.010
OK

12:57.010 --> 12:58.010
我们来看一下吧

12:58.010 --> 12:59.010
那么这样子

12:59.010 --> 13:01.010
是不是把路径就分割出来了

13:01.010 --> 13:02.010
OK

13:02.010 --> 13:04.010
这是关于这一个

13:04.010 --> 13:07.010
Dynamator

13:07.010 --> 13:09.010
DNR

13:09.010 --> 13:10.010
这个东西

13:10.010 --> 13:12.010
是我们来获取的

13:12.010 --> 13:13.010
我们的目录

13:13.010 --> 13:14.010
我们获取我们的目录

13:14.010 --> 13:15.010
给它一个路径

13:15.010 --> 13:17.010
它能获取路径里面的目录

13:17.010 --> 13:18.010
咱们来个

13:18.010 --> 13:19.010
随便来一个

13:19.010 --> 13:21.010
DNR

13:21.010 --> 13:23.010
它不去检查路径存不存在

13:23.010 --> 13:24.010
它根本不会检查的

13:24.010 --> 13:25.010
这里面

13:25.010 --> 13:26.010
PASS里面的所有东西

13:26.010 --> 13:27.010
都不会检查路径

13:27.010 --> 13:28.010
是不是存在的

13:28.010 --> 13:29.010
它只是根据你的规则

13:29.010 --> 13:31.010
路径规则来进行处理

13:31.010 --> 13:33.010
比方说给它一个路径

13:33.010 --> 13:34.010
ABC

13:34.010 --> 13:37.010
就是ABCD.GS

13:37.010 --> 13:38.010
对吧

13:38.010 --> 13:39.010
这是一个路径

13:39.010 --> 13:40.010
是个相对路径

13:40.010 --> 13:41.010
对吧

13:41.010 --> 13:42.010
然后我们来看一下

13:42.010 --> 13:43.010
得到了DNR是什么

13:43.010 --> 13:44.010
就是我给它一个路径

13:44.010 --> 13:46.010
它能够把路径里面的目录

13:46.010 --> 13:47.010
给我取出来

13:50.010 --> 13:51.010
不是Bassin

13:51.010 --> 13:54.540
DNR内

13:54.540 --> 13:55.540
好 运行

13:55.540 --> 13:56.540
是不是ABC

13:56.540 --> 13:57.540
对吧

13:57.540 --> 13:58.540
相当相对

13:58.540 --> 13:59.540
它就是做一个制服串处理

13:59.540 --> 14:01.540
把最后一块的可以去掉

14:01.540 --> 14:02.540
如果说ABCD

14:02.540 --> 14:03.540
如果是这样子

14:03.540 --> 14:04.540
它就认为D是一个

14:04.540 --> 14:05.540
无后罪名的文件

14:05.540 --> 14:06.540
那么从ABC

14:06.540 --> 14:07.540
得到了ABC

14:07.540 --> 14:08.540
没了意思吧

14:08.540 --> 14:09.540
OK

14:09.540 --> 14:12.540
那么这里关于DNR内

14:12.540 --> 14:13.540
它其实这里边也有例子

14:13.540 --> 14:14.540
你可以去看一下

14:14.540 --> 14:15.540
非常简单的

14:15.540 --> 14:16.540
好 下一个

14:16.540 --> 14:17.540
下一个

14:17.540 --> 14:19.540
extension name

14:19.540 --> 14:20.540
什么意思呢

14:20.540 --> 14:21.540
就是获取它的后罪名

14:21.540 --> 14:23.540
获取一个文件的后罪名

14:23.540 --> 14:24.540
这玩意

14:24.540 --> 14:25.540
有的时候

14:25.540 --> 14:26.540
我们在做文件处理的时候

14:26.540 --> 14:28.540
根据不同的后罪名

14:28.540 --> 14:29.540
来做不同的处理

14:29.540 --> 14:30.540
那么这个时候

14:30.540 --> 14:31.540
它还蛮有用的

14:32.540 --> 14:33.540
extname

14:33.540 --> 14:34.540
它都不会几简单

14:34.540 --> 14:35.540
是不是真的有这个文件

14:35.540 --> 14:37.540
它只是给你取出来

14:37.540 --> 14:38.540
从个制服串分期里面

14:38.540 --> 14:39.540
给你取出来

14:39.540 --> 14:40.540
那么我们来看一下

14:40.540 --> 14:41.540
给它这么一个路径

14:41.540 --> 14:43.540
它得到了后罪名是什么呢

14:43.540 --> 14:44.540
肯定是GS

14:44.540 --> 14:45.540
对吧

14:45.540 --> 14:46.540
OK 我们看一下

14:46.540 --> 14:47.540
叫GS

14:47.540 --> 14:48.540
它有一个点

14:48.540 --> 14:49.540
这是extname

14:49.540 --> 14:50.540
那如果说你没有了

14:50.540 --> 14:52.540
你没有后罪名呢

14:52.540 --> 14:53.540
没有后罪名

14:53.540 --> 14:54.540
它就空置不错

14:54.540 --> 14:55.540
它不上礼拜

14:55.540 --> 14:56.540
是空置不错

14:56.540 --> 14:57.540
OK

14:57.540 --> 14:58.540
那么大家看一下

14:58.540 --> 14:59.540
有东西试验一下

14:59.540 --> 15:00.540
也挺有意思

15:00.540 --> 15:01.540
很简单

15:01.540 --> 15:02.540
非常非常简单

15:02.540 --> 15:03.540
也没有必要去背

15:03.540 --> 15:04.540
那里还有什么心理压力呢

15:04.540 --> 15:05.540
没有什么压力

15:05.540 --> 15:06.540
只要你去试过一次

15:06.540 --> 15:08.540
你就有这么个印象

15:08.540 --> 15:09.540
将来遇到了过后

15:09.540 --> 15:10.540
你就知道

15:10.540 --> 15:11.540
大概我们要去查文档里面

15:11.540 --> 15:13.540
哪个地方来进行处理

15:13.540 --> 15:14.540
你可以看到

15:14.540 --> 15:16.540
这个文档是英文的

15:16.540 --> 15:17.540
我不认识

15:17.540 --> 15:18.540
一看地址

15:18.540 --> 15:19.540
直接看地址就完事了

15:19.540 --> 15:20.540
这个地址还不容易懂吗

15:20.540 --> 15:21.540
对吧

15:21.540 --> 15:22.540
dln

15:22.540 --> 15:24.540
然后这里边也传入一个东西

15:24.540 --> 15:25.540
然后它得到returns

15:25.540 --> 15:26.540
返回一个东西

15:26.540 --> 15:27.540
返回这个

15:27.540 --> 15:28.540
一看就明白了

15:28.540 --> 15:29.540
很简单

15:29.540 --> 15:30.540
已经说明

15:32.540 --> 15:33.540
OK

15:33.540 --> 15:35.540
那么这里是关于这一块

15:35.540 --> 15:36.540
然后这里

15:37.540 --> 15:38.540
下边这个

15:40.540 --> 15:41.540
join

15:41.540 --> 15:42.540
join

15:42.540 --> 15:44.540
join它是把多段路径

15:44.540 --> 15:46.540
拼接成一个完整的路径

15:46.540 --> 15:47.540
有的时候

15:47.540 --> 15:48.540
路径的处理

15:48.540 --> 15:49.540
可以来自于

15:49.540 --> 15:50.540
比方说

15:50.540 --> 15:51.540
我们有一个路径

15:51.540 --> 15:52.540
来自于别的地方

15:53.540 --> 15:54.540
我们先看例子

15:55.540 --> 15:56.540
join

15:56.540 --> 15:58.540
这个用的还蛮多的

16:00.540 --> 16:03.740
咱们来看一下

16:03.740 --> 16:05.740
我们这里有几段路径

16:05.740 --> 16:06.740
a

16:06.740 --> 16:08.740
下面我找b文件夹

16:08.740 --> 16:10.740
b文件下面我找c文件夹

16:10.740 --> 16:11.740
c文件夹

16:11.740 --> 16:14.740
然后我找d.js

16:14.740 --> 16:15.740
你看它会把这个东西

16:15.740 --> 16:17.740
给拼接成一个完整的路径

16:18.740 --> 16:19.740
abct.js

16:19.740 --> 16:20.740
而且分割符

16:20.740 --> 16:22.740
会按照操作系统的

16:22.740 --> 16:23.740
那种方式来进行分割

16:23.740 --> 16:24.740
对吧

16:24.740 --> 16:25.740
OK

16:25.740 --> 16:26.740
那么这是join

16:26.740 --> 16:27.740
这个join的里边

16:27.740 --> 16:28.740
还有很多神奇的功能

16:28.740 --> 16:29.740
比方说我这个c

16:29.740 --> 16:30.740
可以换成第二点

16:30.740 --> 16:32.740
第二点鞋杠

16:32.740 --> 16:33.740
什么意思

16:33.740 --> 16:34.740
返回上级目录

16:34.740 --> 16:35.740
就是a到b

16:35.740 --> 16:36.740
然后b再返回上级目录

16:36.740 --> 16:37.740
是不是变成a了

16:37.740 --> 16:39.740
然后下面的d.js

16:39.740 --> 16:40.740
再看一下

16:40.740 --> 16:41.740
那么变成了a

16:41.740 --> 16:42.740
下面的d.js

16:42.740 --> 16:43.740
它的好处在于什么呢

16:43.740 --> 16:44.740
好处在于

16:44.740 --> 16:46.740
我们以前有一个基础路径

16:46.740 --> 16:47.740
比方说

16:47.740 --> 16:48.740
我们可能

16:48.740 --> 16:49.740
可能通过一个函数

16:49.740 --> 16:50.740
或者是什么玩意

16:50.740 --> 16:51.740
得到一个基础路径

16:51.740 --> 16:53.740
这个路径可能是ab

16:53.740 --> 16:54.740
对吧

16:54.740 --> 16:55.740
可能是这么一个路径

16:55.740 --> 16:56.740
那么我们基于这个路径

16:56.740 --> 16:57.740
当然这个决定路径也支持

16:57.740 --> 16:58.740
什么路径都支持

16:58.740 --> 16:59.740
那么基于这个路径

16:59.740 --> 17:00.740
我们在这个路径基础上

17:00.740 --> 17:01.740
来进行分析

17:01.740 --> 17:03.740
那么我们希望在这个路径基础上

17:03.740 --> 17:04.740
返回上级目录

17:04.740 --> 17:06.740
然后再找这个地点解释

17:06.740 --> 17:08.740
它会生成一个完整路径

17:09.740 --> 17:10.740
你看

17:10.740 --> 17:11.740
不是那个完整路径

17:12.740 --> 17:13.740
这是它关于这个

17:13.740 --> 17:14.740
交易

17:14.740 --> 17:15.740
都很强大的

17:15.740 --> 17:16.740
这些方法

17:16.740 --> 17:17.740
要自己去写的话

17:17.740 --> 17:18.740
当然都可以写出来

17:18.740 --> 17:19.740
并不难的

17:19.740 --> 17:20.740
只是

17:20.740 --> 17:22.740
还是要考虑很多细节

17:23.740 --> 17:24.740
这是关于这一块

17:24.740 --> 17:26.740
下面这个Normalize

17:26.740 --> 17:27.740
Normalize

17:27.740 --> 17:28.740
我们看一下

17:28.740 --> 17:29.740
Normalize

17:29.740 --> 17:30.740
稍微用的少一点

17:30.740 --> 17:31.740
它是什么意思呢

17:31.740 --> 17:33.740
这是得到那个

17:33.740 --> 17:36.740
就是你给它一个完整的路径

17:36.740 --> 17:37.740
它给你把它

17:37.740 --> 17:39.740
规范化这个路径

17:39.740 --> 17:40.740
什么意思呢

17:40.740 --> 17:41.740
它这里有个例子

17:41.740 --> 17:42.740
你看

17:42.740 --> 17:43.740
Normalize

17:43.740 --> 17:44.740
这里边也写了一个路径

17:44.740 --> 17:45.740
对吧

17:45.740 --> 17:46.740
写了这么一个路径

17:46.740 --> 17:47.740
路径后面有两个点

17:47.740 --> 17:49.740
是不是返回上级目录

17:49.740 --> 17:50.740
那么它得到了路径

17:50.740 --> 17:51.740
是什么呢

17:51.740 --> 17:52.740
返回上级目录

17:52.740 --> 17:53.740
是不是这个路径

17:53.740 --> 17:54.740
就这么个意思

17:54.740 --> 17:55.740
你看它得到了

17:55.740 --> 17:57.740
在Windows操作系统里边

17:57.740 --> 17:58.740
它就会把它

17:58.740 --> 17:59.740
把它变成什么呢

17:59.740 --> 18:01.740
变成根据操作系统

18:01.740 --> 18:03.740
符合操作系统要求的

18:03.740 --> 18:04.740
那么一种鞋杠

18:04.740 --> 18:05.740
会把这里边的鞋杠

18:05.740 --> 18:06.740
变成符合操作系统

18:06.740 --> 18:07.740
要求的鞋杠

18:07.740 --> 18:08.740
那么这里

18:08.740 --> 18:09.740
看下就行了

18:09.740 --> 18:10.740
下一个

18:10.740 --> 18:11.740
Renate

18:12.740 --> 18:13.740
Renate

18:13.740 --> 18:14.740
我们找一找

18:14.740 --> 18:15.740
Renate在这

18:16.740 --> 18:17.740
这个东西

18:17.740 --> 18:18.740
还有蛮有意思的

18:18.740 --> 18:19.740
有的时候

18:19.740 --> 18:21.740
它能解决的很大的问题

18:21.740 --> 18:23.740
像我们Waypack里边

18:23.740 --> 18:25.740
如果说

18:25.740 --> 18:26.740
Waypack里边

18:26.740 --> 18:28.740
它里边就用到了这个东西

18:28.740 --> 18:29.740
Renate

18:30.740 --> 18:31.740
它是什么意思呢

18:31.740 --> 18:33.740
它就是根据两个路径

18:33.740 --> 18:35.740
就左边

18:35.740 --> 18:37.740
看一下右边的路径

18:37.740 --> 18:38.740
相对于左边

18:38.740 --> 18:40.740
得到相对于左边的相对路径

18:40.740 --> 18:41.740
什么意思呢

18:41.740 --> 18:43.740
我们就把代码复制一下吧

18:43.740 --> 18:44.740
你看吧

18:44.740 --> 18:48.210
得到

18:49.210 --> 18:50.210
Renate

18:50.210 --> 18:51.210
输出

18:51.210 --> 18:52.210
Renate

18:52.210 --> 18:53.210
看一下

18:53.210 --> 18:55.210
这是我们的路径对吧

18:55.210 --> 18:56.210
在这个路径下面

18:56.210 --> 18:57.210
那么就说

18:57.210 --> 18:58.210
我们后边又是一个路径

18:58.210 --> 18:59.210
那么这个路径

18:59.210 --> 19:01.210
相对于前面的路径

19:01.210 --> 19:02.210
是什么了

19:02.210 --> 19:03.210
相对路径

19:03.210 --> 19:04.210
那么就是这个路径

19:04.210 --> 19:05.210
相对于前面是什么了

19:05.210 --> 19:06.210
相对于前面

19:06.210 --> 19:07.210
相对于这个路径就是

19:07.210 --> 19:09.210
返回这个路径的上级目录

19:09.210 --> 19:10.210
返回上级目录

19:10.210 --> 19:12.210
然后再返回上级目录

19:12.210 --> 19:13.210
然后再找什么

19:13.210 --> 19:14.210
input下面的BBB

19:14.210 --> 19:15.210
对吧

19:15.210 --> 19:16.210
好

19:16.210 --> 19:19.350
咱们来看一下

19:19.350 --> 19:20.350
是不是这样子

19:20.350 --> 19:21.350
返回上级目录

19:21.350 --> 19:22.350
input下面的BBB

19:22.350 --> 19:23.350
对不对

19:23.350 --> 19:24.350
那么它可以

19:24.350 --> 19:26.350
把这两个路径

19:26.350 --> 19:28.350
把它换成相对路径的格式

19:28.350 --> 19:31.660
这是关于这一种

19:31.660 --> 19:32.660
好

19:32.660 --> 19:33.660
后边的result

19:33.660 --> 19:35.660
result我就是得到绝对路径的

19:35.660 --> 19:36.660
全部叫绝对路径

19:36.660 --> 19:38.660
就是我们的跟路径

19:38.660 --> 19:39.660
我们的跟路径

19:39.660 --> 19:40.660
就是

19:40.660 --> 19:41.660
从某个盘幅出发

19:41.660 --> 19:42.660
当然在mic里面

19:42.660 --> 19:43.660
不存在什么盘幅

19:43.660 --> 19:44.660
对吧

19:44.660 --> 19:45.660
它是指的是

19:45.660 --> 19:46.660
从一个跟目度出发

19:46.660 --> 19:47.660
到什么地方

19:47.660 --> 19:48.660
对不对

19:48.660 --> 19:50.660
那么这就是result

19:50.660 --> 19:52.660
把它转换成绝对路径

19:52.660 --> 19:53.660
那么这个路径

19:53.660 --> 19:54.660
大家用的比较多一点

19:54.660 --> 19:55.660
在repack里面

19:55.660 --> 19:56.660
比方说

19:56.660 --> 19:57.660
在repack上面

19:57.660 --> 19:59.660
写上一个斜杠

19:59.660 --> 20:00.660
a.js

20:00.660 --> 20:02.660
其实这也是个绝对路径

20:02.660 --> 20:03.660
在mic电脑上面

20:03.660 --> 20:04.660
或者是在unix上

20:04.660 --> 20:05.660
操作系统上面

20:05.660 --> 20:06.660
这不就是个绝对路径吗

20:06.660 --> 20:07.660
从跟目录出发

20:07.660 --> 20:09.660
找a.js

20:09.660 --> 20:11.660
那么在Windows操作系统里面

20:11.660 --> 20:12.660
因为它有个盘幅

20:12.660 --> 20:14.660
对不对

20:14.660 --> 20:15.660
Windows操作系统里面

20:15.660 --> 20:16.660
还有一个盘幅

20:16.660 --> 20:17.660
那么它这个盘幅

20:17.660 --> 20:18.660
就用我们当前

20:18.660 --> 20:19.660
系统的盘幅

20:19.660 --> 20:20.660
就当前我这个

20:20.660 --> 20:21.660
命令的盘幅

20:21.660 --> 20:22.660
命令的地盘

20:22.660 --> 20:23.660
地盘

20:23.660 --> 20:24.660
所以说

20:24.660 --> 20:25.660
地盘下面的a.js

20:25.660 --> 20:26.660
我们来看一下

20:26.660 --> 20:28.660
地盘下面的a.js

20:28.660 --> 20:30.660
那么这个地方

20:30.660 --> 20:31.660
如果说

20:31.660 --> 20:33.660
你也可以用相对路径

20:33.660 --> 20:34.660
也可以

20:34.660 --> 20:35.660
比方说

20:35.660 --> 20:37.660
地耳斜杠a.js

20:37.660 --> 20:38.660
那么看一下

20:38.660 --> 20:39.660
地耳斜杠a.js

20:39.660 --> 20:40.660
那么是不是

20:40.660 --> 20:42.660
当前目录下面的a.js

20:42.660 --> 20:43.660
但问题是

20:43.660 --> 20:44.660
当前目录是怎么定的呢

20:44.660 --> 20:45.660
怎么定的

20:45.660 --> 20:46.660
当前目录的

20:46.660 --> 20:48.660
看着我返回上一级目录

20:48.660 --> 20:50.660
那么这里我们漏的

20:50.660 --> 20:51.660
圆嘛

20:51.660 --> 20:52.660
然后呢

20:52.660 --> 20:53.660
a.js

20:53.660 --> 20:54.660
a.js

20:56.660 --> 20:58.660
a.js

20:58.660 --> 20:59.660
那么这个时候呢

20:59.660 --> 21:00.660
你看

21:00.660 --> 21:01.660
是不是圆嘛

21:01.660 --> 21:02.660
这个文件讲白了

21:02.660 --> 21:03.660
所以说相对路径

21:03.660 --> 21:04.660
它不是相对这个模块

21:04.660 --> 21:05.660
这个地耳斜杠

21:05.660 --> 21:06.660
它这个相对路径

21:06.660 --> 21:08.660
除了在require的时候

21:08.660 --> 21:09.660
是相对于模块的

21:09.660 --> 21:10.660
那么这个时候呢

21:10.660 --> 21:11.660
它不是相对于模块的

21:11.660 --> 21:12.660
它相对于谁呢

21:12.660 --> 21:13.660
它相对的是

21:13.660 --> 21:14.660
我们的命令行

21:14.660 --> 21:16.660
相对于是个process

21:16.660 --> 21:17.660
相对于这个

21:17.660 --> 21:18.660
process

21:18.660 --> 21:19.660
cwd

21:19.660 --> 21:20.660
对吧

21:20.660 --> 21:21.660
是不是相对于

21:21.660 --> 21:22.660
这个东西

21:22.660 --> 21:23.660
对不对

21:23.660 --> 21:24.660
但如果说

21:24.660 --> 21:25.660
你要相对于的是什么呢

21:25.660 --> 21:26.660
如果说

21:26.660 --> 21:27.660
你要相对于

21:27.660 --> 21:28.660
我们当前那个目录的话

21:28.660 --> 21:29.660
啊

21:29.660 --> 21:30.660
当前模块

21:30.660 --> 21:31.660
所在的目录的话

21:31.660 --> 21:32.660
那么你是不是

21:32.660 --> 21:33.660
前面加一个dln

21:33.660 --> 21:34.660
dln是什么

21:34.660 --> 21:35.660
是不是

21:35.660 --> 21:37.660
根据当前模块的路径

21:37.660 --> 21:38.660
对吧

21:38.660 --> 21:39.660
当前模块的路径

21:39.660 --> 21:40.660
对不对

21:40.660 --> 21:41.660
模块的目录

21:41.660 --> 21:43.660
在当前模块的目录下面的

21:43.660 --> 21:44.660
a.js

21:44.660 --> 21:45.660
那么这样子呢

21:45.660 --> 21:46.660
无论你是在哪个

21:46.660 --> 21:47.660
命令提示符

21:47.660 --> 21:48.660
下面运行的

21:48.660 --> 21:49.660
命令提示符的路径

21:49.660 --> 21:50.660
是什么

21:50.660 --> 21:51.660
那么都五官了

21:52.660 --> 21:53.660
好

21:53.660 --> 21:54.660
这里我们看一下

21:54.660 --> 21:55.660
是不是

21:55.660 --> 21:56.660
还是a.js

21:56.660 --> 21:57.660
对吧

21:57.660 --> 21:58.660
它这里也是有拼接功能的啊

21:58.660 --> 21:59.660
这个路径呢

21:59.660 --> 22:00.660
在拼接它这个路径

22:00.660 --> 22:01.660
后面依次可以拼接很多的

22:01.660 --> 22:02.660
还可以返回上级目录

22:02.660 --> 22:03.660
都可以

22:03.660 --> 22:04.660
对吧

22:04.660 --> 22:05.660
它会把它转换成

22:05.660 --> 22:06.660
总之呢

22:06.660 --> 22:07.660
它可以把它转换成决定路径

22:07.660 --> 22:08.660
ok

22:08.660 --> 22:10.660
那么这是关于这个pass

22:10.660 --> 22:12.660
这里边的内置模块

22:12.660 --> 22:13.660
好

22:13.660 --> 22:14.660
把这个

22:14.660 --> 22:15.660
复制出去啊

22:15.660 --> 22:16.660
这是 about

22:17.660 --> 22:18.660
pass

22:19.660 --> 22:20.660
下一个

22:21.660 --> 22:22.660
下个是url

22:23.660 --> 22:24.660
那么顾名思义呢

22:24.660 --> 22:25.660
它是跟那个

22:26.660 --> 22:28.660
就是我们的url地址

22:28.660 --> 22:29.660
相关处理的

22:29.660 --> 22:31.660
跟没什么请求也没关系

22:31.660 --> 22:33.660
它只是做制服串处理

22:33.660 --> 22:35.660
它里边给你提供了一个

22:35.660 --> 22:36.660
构造函数

22:36.660 --> 22:37.660
看下明白了

22:37.660 --> 22:38.660
class

22:38.660 --> 22:39.660
构造函数url

22:39.660 --> 22:41.660
六一个url就可以了

22:41.660 --> 22:42.660
对吧

22:42.660 --> 22:43.660
那么这里能不能导入

22:44.660 --> 22:46.660
url require

22:46.660 --> 22:47.660
url

22:48.660 --> 22:49.660
那么这里边呢

22:49.660 --> 22:50.660
可以使用一个

22:50.660 --> 22:51.660
六一个url

22:51.660 --> 22:52.660
那么这里边传入什么呢

22:52.660 --> 22:54.660
传入我们的6url地址

22:54.660 --> 22:55.660
我们就把这个传进去吧

22:55.660 --> 22:56.660
就把这个玩意传进去

22:56.660 --> 22:58.660
你看它给我们反悔什么了

22:58.660 --> 23:00.660
那肯定是反悔个对象呗

23:00.660 --> 23:01.660
还能反悔啥呢

23:02.660 --> 23:03.660
反悔对象呗

23:03.660 --> 23:04.660
我们来看一下

23:04.660 --> 23:05.660
对象里边有什么东西

23:05.660 --> 23:06.660
它就把这个

23:06.660 --> 23:07.660
它会把这个

23:07.660 --> 23:08.660
支不错的url地址给你分析出来

23:08.660 --> 23:09.660
形成一个对象

23:09.660 --> 23:10.660
好

23:10.660 --> 23:11.660
咱们来看一下吧

23:15.660 --> 23:16.660
进入一个

23:16.660 --> 23:20.170
应这个是

23:20.170 --> 23:21.170
这里出错了是吧

23:23.170 --> 23:24.170
它说url

23:26.170 --> 23:27.170
它里边

23:27.170 --> 23:28.170
它里边一个属性啊

23:29.170 --> 23:30.170
一个属性

23:30.170 --> 23:31.170
叫url

23:31.170 --> 23:32.170
这才是一个constructor

23:32.170 --> 23:33.170
这才是一个constructor

23:34.170 --> 23:35.170
它本身不是

23:35.170 --> 23:36.170
模块本身不是

23:36.170 --> 23:37.170
没看一下

23:37.170 --> 23:38.170
所以把它转换成对象的

23:38.170 --> 23:39.170
对吧

23:39.170 --> 23:40.170
你看

23:40.170 --> 23:41.170
我们的完整地址

23:41.170 --> 23:42.170
是不是这个地址

23:42.170 --> 23:43.170
对不对

23:43.170 --> 23:44.170
给它的

23:44.170 --> 23:45.170
然后呢orange

23:45.170 --> 23:46.170
是什么了

23:46.170 --> 23:47.170
就是它的协议

23:47.170 --> 23:48.170
加上它的主经名

23:48.170 --> 23:49.170
这些东西

23:49.170 --> 23:50.170
对不对

23:50.170 --> 23:51.170
那么放到这

23:51.170 --> 23:52.170
形成这个属性

23:52.170 --> 23:53.170
protocol

23:53.170 --> 23:54.170
这是什么

23:54.170 --> 23:55.170
就是我们的协议

23:55.170 --> 23:57.170
协议是不是atps

23:57.170 --> 23:58.170
username

23:58.170 --> 23:59.170
有的时候

23:59.170 --> 24:00.170
将有些协议

24:00.170 --> 24:03.170
它需要传递用户名和密码

24:03.170 --> 24:04.170
那么我们这里没有

24:04.170 --> 24:05.170
不管它host

24:05.170 --> 24:06.170
我们的主机名

24:06.170 --> 24:07.170
是不是在这一部分

24:07.170 --> 24:08.170
port 端口号

24:08.170 --> 24:09.170
端口号都没写

24:09.170 --> 24:10.170
没写

24:10.170 --> 24:11.170
那么它就没有分析出来

24:11.170 --> 24:12.170
hostname

24:12.170 --> 24:13.170
hostname

24:13.170 --> 24:14.170
那么这个也是

24:14.170 --> 24:15.170
也是就在这

24:16.170 --> 24:17.170
passname

24:17.170 --> 24:18.170
passname是不是

24:18.170 --> 24:19.170
后边的这一段

24:19.170 --> 24:20.170
好

24:20.170 --> 24:22.170
后边的什么search

24:22.170 --> 24:23.170
hash

24:23.170 --> 24:24.170
这就是什么东西

24:24.170 --> 24:25.170
那么比方说

24:25.170 --> 24:26.170
因为我们的完整的

24:26.170 --> 24:27.170
url 地址是这样子的

24:28.170 --> 24:29.170
c

24:30.170 --> 24:31.170
我们把端口号写上

24:31.170 --> 24:33.170
大家看得更加清楚一点

24:34.170 --> 24:35.170
你看看

24:35.170 --> 24:36.170
刚才有两个

24:36.170 --> 24:37.170
一个是host

24:37.170 --> 24:38.170
一个是hostname

24:38.170 --> 24:39.170
有差异的

24:39.170 --> 24:40.170
那么这里

24:40.170 --> 24:41.170
比方写上一个就是

24:41.170 --> 24:43.170
t 等于3

24:43.170 --> 24:45.170
u 等于5

24:45.170 --> 24:46.170
然后再写个

24:46.170 --> 24:47.170
hashz

24:47.170 --> 24:48.170
hashz

24:48.170 --> 24:49.170
abc

24:50.170 --> 24:51.170
我们看一下这个路径

24:53.930 --> 24:54.930
你看看

24:54.930 --> 24:55.930
host 是不是带端口号的

24:55.930 --> 24:56.930
hostname

24:56.930 --> 24:57.930
是没带端口号的

24:57.930 --> 24:58.930
就这么个意思

24:58.930 --> 24:59.930
port 80

24:59.930 --> 25:00.930
passname

25:00.930 --> 25:01.930
abc

25:01.930 --> 25:02.930
这是我们的完整地址

25:02.930 --> 25:03.930
abc

25:03.930 --> 25:04.930
search

25:04.930 --> 25:05.930
就是问号后边这一坨

25:05.930 --> 25:06.930
就是search

25:06.930 --> 25:07.930
hash

25:07.930 --> 25:08.930
就是警号后边这一坨

25:08.930 --> 25:09.930
就hash

25:09.930 --> 25:10.930
那么它还会自动的

25:10.930 --> 25:11.930
把search

25:11.930 --> 25:12.930
这一块给转化成

25:13.930 --> 25:14.930
它也不算对象

25:14.930 --> 25:15.930
它相当有点

25:15.930 --> 25:16.930
类似于一个map

25:16.930 --> 25:17.930
但它不是map

25:17.930 --> 25:18.930
不是一个map

25:18.930 --> 25:20.930
它有点类似于map

25:20.930 --> 25:21.930
因为

25:21.930 --> 25:22.930
当时呢

25:22.930 --> 25:23.930
load介绍出来的时候

25:23.930 --> 25:24.930
还没有map

25:24.930 --> 25:25.930
没有这个东西

25:25.930 --> 25:26.930
所以它自己给你

25:26.930 --> 25:27.930
做了一个类似的东西

25:27.930 --> 25:28.930
它为什么用

25:28.930 --> 25:29.930
这种格式来输出呢

25:29.930 --> 25:31.930
因为它给你重写了

25:31.930 --> 25:32.930
重写了

25:32.930 --> 25:33.930
重写了

25:33.930 --> 25:34.930
那么这里呢

25:34.930 --> 25:35.930
我们来看一下吧

25:35.930 --> 25:37.930
它里面的search parent

25:37.930 --> 25:38.930
search parent

25:38.930 --> 25:39.930
那么我们可以用一下

25:39.930 --> 25:40.930
UIL

25:40.930 --> 25:42.930
search parent

25:42.930 --> 25:43.930
就相当于是这个

25:43.930 --> 25:44.930
实际上是一个对象

25:44.930 --> 25:45.930
实际上是一个对象

25:45.930 --> 25:46.930
它通过这个构造函数

25:46.930 --> 25:47.930
这构造函数在哪呢

25:47.930 --> 25:48.930
在里面

25:48.930 --> 25:49.930
在这

25:49.930 --> 25:51.930
叫search parent

25:51.930 --> 25:52.930
对吧

25:52.930 --> 25:53.930
不是这个

25:53.930 --> 25:54.930
大写的

25:54.930 --> 25:55.930
search

25:55.930 --> 25:57.930
UILsearch parent

25:57.930 --> 25:58.930
这是个构造函数

25:58.930 --> 25:59.930
当然你也可以通过

25:59.930 --> 26:00.930
六一个它

26:00.930 --> 26:01.930
六一个它

26:01.930 --> 26:02.930
把这个search传进去

26:02.930 --> 26:03.930
然后传一个

26:03.930 --> 26:05.930
设计进去

26:05.930 --> 26:06.930
设计进去

26:06.930 --> 26:07.930
那么它会把它

26:07.930 --> 26:08.930
转换成这种对象格式

26:08.930 --> 26:09.930
会把它转换成

26:09.930 --> 26:10.930
这种对象格式

26:10.930 --> 26:11.930
那么它这个

26:11.930 --> 26:12.930
如果说你传一个

26:12.930 --> 26:13.930
完整的UIL

26:13.930 --> 26:14.930
通过UIL构造函数

26:14.930 --> 26:15.930
它会自动的

26:15.930 --> 26:16.930
帮你构造成

26:17.930 --> 26:18.930
好

26:18.930 --> 26:19.930
那么这里边

26:19.930 --> 26:20.930
我们可以用什么呢

26:20.930 --> 26:21.930
比方说

26:21.930 --> 26:22.930
有没有某一个key值

26:22.930 --> 26:23.930
比方说有没有a

26:23.930 --> 26:24.930
有没有a

26:24.930 --> 26:25.930
这个

26:25.930 --> 26:26.930
有没有a属性

26:26.930 --> 26:27.930
没有

26:27.930 --> 26:29.930
那么它肯定返回force

26:29.930 --> 26:32.690
它没输出

26:32.690 --> 26:33.690
外面的

26:33.690 --> 26:34.690
都叫得很欢的

26:36.690 --> 26:37.690
看一下

26:37.690 --> 26:38.690
印象

26:38.690 --> 26:39.690
那你看一下

26:39.690 --> 26:40.690
这里是不是force

26:40.690 --> 26:41.690
没有这个a

26:41.690 --> 26:42.690
对吧

26:42.690 --> 26:43.690
没有这个t

26:43.690 --> 26:44.690
是不是可以通过

26:44.690 --> 26:45.690
这个判断

26:45.690 --> 26:46.690
有没有某一个传递

26:46.690 --> 26:47.690
t是不是有

26:47.690 --> 26:48.690
对吧

26:48.690 --> 26:49.690
好了

26:49.690 --> 26:50.690
如果说我要豁取t的值

26:50.690 --> 26:51.690
我们就用git

26:51.690 --> 26:52.690
git

26:52.690 --> 26:53.690
是不是跟map的操作

26:53.690 --> 26:54.690
有点类似

26:54.690 --> 26:55.690
对吧

26:55.690 --> 26:56.690
非常类似

26:56.690 --> 26:57.690
你看

26:57.690 --> 26:58.690
是不是得到3

26:58.690 --> 26:59.690
t等于3

26:59.690 --> 27:00.690
对不对

27:00.690 --> 27:01.690
非常简单

27:01.690 --> 27:03.690
这是关于UIL解析

27:03.690 --> 27:04.690
那么它就可以

27:04.690 --> 27:05.690
把一个字幕创了

27:05.690 --> 27:06.690
就换成一个对象格式

27:06.690 --> 27:07.690
对象格式

27:07.690 --> 27:08.690
不是很好操作

27:08.690 --> 27:09.690
对不对

27:09.690 --> 27:11.690
那么换成对象格式之后

27:12.690 --> 27:13.690
说一下

27:13.690 --> 27:14.690
我们把它复制一下

27:14.690 --> 27:15.690
复制一下

27:15.690 --> 27:17.690
如果说你遇到这种情况

27:17.690 --> 27:18.690
其实他刚才这里

27:18.690 --> 27:19.690
还有一种邪法

27:19.690 --> 27:20.690
就是不用勾到函数

27:20.690 --> 27:22.690
可以用这种方式

27:22.690 --> 27:24.690
UIL

27:25.690 --> 27:26.690
也可以

27:26.690 --> 27:27.690
它实际上就是

27:27.690 --> 27:28.690
帮你调整勾到函数

27:28.690 --> 27:29.690
一样的

27:29.690 --> 27:30.690
是一样的

27:30.690 --> 27:31.690
对不对

27:31.690 --> 27:32.690
它只帮你调整勾到函数

27:33.690 --> 27:34.690
另外

27:34.690 --> 27:36.690
如果说你对象里边

27:36.690 --> 27:38.690
如果说你直接有一个对象

27:40.690 --> 27:41.690
就是那个对象

27:41.690 --> 27:42.690
你要把它转换成为

27:42.690 --> 27:43.690
当然这个地方

27:43.690 --> 27:44.690
我要

27:44.690 --> 27:45.690
把它转换成那个

27:45.690 --> 27:46.690
就是这个都不要了

27:46.690 --> 27:47.690
不要了

27:47.690 --> 27:50.690
我要把它转换成为一个字幕创

27:50.690 --> 27:52.690
那又怎么办呢

27:52.690 --> 27:53.690
我们就可以用这个

27:53.690 --> 27:55.690
叫做UIL

27:55.690 --> 27:57.690
叫做什么玩意

27:57.690 --> 27:58.690
format

27:58.690 --> 27:59.690
OBG

27:59.690 --> 28:01.690
它返回一个字幕创

28:01.690 --> 28:02.690
UIL

28:02.690 --> 28:04.690
输出UIL

28:04.690 --> 28:05.690
你看一下这个

28:05.690 --> 28:08.320
你看

28:08.320 --> 28:09.320
所以把它变成了字幕创了

28:09.320 --> 28:10.320
它可以返向转换的

28:10.320 --> 28:11.320
这里给它一个对象

28:11.320 --> 28:12.320
有的时候

28:12.320 --> 28:13.320
我们可能要起个对象

28:13.320 --> 28:15.320
配置玩了过后

28:15.320 --> 28:16.320
一个UIL

28:16.320 --> 28:17.320
就可以用这个方式

28:17.320 --> 28:18.320
format

28:18.320 --> 28:19.320
没问题吧

28:19.320 --> 28:20.320
都很简单

28:20.320 --> 28:21.320
但是下线下来了

28:21.320 --> 28:22.320
一光听

28:22.320 --> 28:23.320
没有任何感觉的

28:23.320 --> 28:24.320
你还是花不了多少时间

28:24.320 --> 28:26.320
最多最多一个小时

28:26.320 --> 28:27.320
上天了

28:29.320 --> 28:30.320
然后我们看一下

28:30.320 --> 28:31.320
下面这个UIL

28:31.320 --> 28:33.320
UIL是有一个工具包

28:33.320 --> 28:34.320
一个内置的工具库

28:34.320 --> 28:36.320
我们还是把它保存一下

28:37.320 --> 28:38.320
About

28:38.320 --> 28:39.320
有时候啥玩意

28:39.320 --> 28:40.320
UIL

28:42.820 --> 28:44.820
下面这个是UIL

28:44.820 --> 28:45.820
工具包

28:45.820 --> 28:46.820
其实含书还是蛮多的

28:46.820 --> 28:47.820
非常非常多

28:47.820 --> 28:49.820
我们这里用不到那么多

28:49.820 --> 28:50.820
我们平时用的

28:50.820 --> 28:51.820
也就这么几个

28:54.820 --> 28:55.820
什么意思呢

28:55.820 --> 28:56.820
它可以把一个Promise

28:56.820 --> 28:58.820
一个易部含书

28:58.820 --> 29:00.820
把它转换成一个CoreBike的形式

29:00.820 --> 29:01.820
有意思吧

29:01.820 --> 29:02.820
有的时候

29:02.820 --> 29:04.820
我们工程里面

29:04.820 --> 29:06.820
可能要统一我们的

29:06.820 --> 29:07.820
易部处理方式

29:07.820 --> 29:08.820
要么全部用CoreBike

29:08.820 --> 29:10.820
要么全部用Promise

29:10.820 --> 29:11.820
要统一

29:11.820 --> 29:12.820
所以说对于

29:12.820 --> 29:13.820
一些第三方库里面

29:13.820 --> 29:14.820
给你提供的易部含书

29:14.820 --> 29:15.820
我们可能要进行转换

29:15.820 --> 29:17.820
就可以用UIL包里面的东西

29:18.820 --> 29:19.820
UIL

29:19.820 --> 29:20.820
Require

29:20.820 --> 29:21.820
UIL

29:21.820 --> 29:23.820
比方说我们这里写个易部含书

29:23.820 --> 29:24.820
写个易部含书

29:24.820 --> 29:25.820
比方说

29:25.820 --> 29:26.820
只要你返回Promise

29:26.820 --> 29:27.820
不就是一个易部含书吗

29:27.820 --> 29:28.820
Test

29:29.820 --> 29:30.820
就Delay

29:30.820 --> 29:31.820
Delay

29:31.820 --> 29:33.820
传一个Delation进来

29:33.820 --> 29:34.820
这个含书

29:34.820 --> 29:35.820
应该我们写过很多次了

29:35.820 --> 29:36.820
对吧

29:36.820 --> 29:38.820
就是做一个延迟

29:38.820 --> 29:39.820
延迟的那么一个易部含书

29:39.820 --> 29:40.820
SetTimeout

29:40.820 --> 29:41.820
多少时间

29:41.820 --> 29:42.820
多少时间

29:42.820 --> 29:43.820
Delation

29:43.820 --> 29:44.820
然后干嘛呢

29:44.820 --> 29:45.820
Resolve

29:45.820 --> 29:46.820
对吧

29:46.820 --> 29:47.820
Resolve

29:47.820 --> 29:48.820
OK

29:48.820 --> 29:49.820
多少时间过后

29:49.820 --> 29:50.820
去做一些事

29:50.820 --> 29:51.820
对吧

29:51.820 --> 29:52.820
那么Resolve

29:52.820 --> 29:53.820
我就把

29:53.820 --> 29:54.820
干脆我Resolve的时候

29:54.820 --> 29:55.820
把这个时间传进去吧

29:55.820 --> 29:57.820
把这个时间传进去

29:57.820 --> 29:58.820
Resolve

29:58.820 --> 29:59.820
Delation

29:59.820 --> 30:00.820
就建个时间

30:00.820 --> 30:01.820
一个传进去

30:02.820 --> 30:03.820
没问题吧

30:03.820 --> 30:04.820
Delay

30:04.820 --> 30:05.820
那我们来用一下吧

30:05.820 --> 30:06.820
Delay怎么用呢

30:06.820 --> 30:07.820
Delay

30:09.820 --> 30:10.820
这里说一个时间

30:10.820 --> 30:11.820
D

30:11.820 --> 30:12.820
D

30:13.820 --> 30:14.820
好

30:14.820 --> 30:17.260
运行

30:18.260 --> 30:20.260
运行含书

30:21.260 --> 30:22.260
传入一个时间吧

30:22.260 --> 30:24.260
给他一个默认值吧

30:24.260 --> 30:25.260
1000

30:25.260 --> 30:26.260
传入一个

30:26.260 --> 30:27.260
500

30:27.260 --> 30:29.260
看一下吧

30:30.260 --> 30:31.260
500毫秒完了过后

30:31.260 --> 30:32.260
是不是运行我们的

30:32.260 --> 30:33.260
结束含书

30:33.260 --> 30:35.260
这个玩意还聊用得很熟

30:35.260 --> 30:36.260
到学到load的时候

30:36.260 --> 30:37.260
这个东西

30:37.260 --> 30:38.260
感觉好陌生啊

30:38.260 --> 30:39.260
那就完蛋了

30:39.260 --> 30:40.260
那就完蛋了

30:40.260 --> 30:41.260
兄弟

30:41.260 --> 30:42.260
你把这个

30:42.260 --> 30:43.260
无忧的东西都

30:43.260 --> 30:44.260
应该都学了吧

30:44.260 --> 30:45.260
我觉得应该都学了

30:45.260 --> 30:46.260
那这些东西

30:46.260 --> 30:48.260
就不应该有任何问题了

30:48.260 --> 30:49.260
因为用了那么久了

30:49.260 --> 30:50.260
好

30:50.260 --> 30:51.260
这是Delay

30:51.260 --> 30:53.260
这是我们的异部含书

30:53.260 --> 30:54.260
那么我们如果说

30:54.260 --> 30:55.260
要把它转换成

30:55.260 --> 30:56.260
callback的形式呢

30:56.260 --> 30:57.260
我们不也没有必要去

30:57.260 --> 30:58.260
专门重新写一个

30:58.260 --> 30:59.260
我们直接用这个Utl

30:59.260 --> 31:01.260
用什么callback field

31:02.260 --> 31:03.260
然后把我们的含书

31:03.260 --> 31:04.260
什么Delay传进去

31:04.260 --> 31:05.260
Delay传进去

31:06.260 --> 31:07.260
传来过后呢

31:07.260 --> 31:09.260
还会返回一个新的含书

31:09.260 --> 31:10.260
Delay

31:10.260 --> 31:11.260
callback

31:12.260 --> 31:13.260
就会返回一个新的含书

31:13.260 --> 31:15.260
就是它无非就是个高階含书

31:15.260 --> 31:16.260
对吧

31:16.260 --> 31:17.260
有兴趣的同学呢

31:17.260 --> 31:18.260
可以自己去写一下

31:18.260 --> 31:19.260
我们以前那一讲

31:19.260 --> 31:20.260
也讲过高階含书的

31:20.260 --> 31:21.260
对吧

31:21.260 --> 31:22.260
如果说你以前没学

31:22.260 --> 31:23.260
以后也会学

31:23.260 --> 31:24.260
我也不知道你们的课程安排

31:24.260 --> 31:25.260
到底是怎么弄的

31:25.260 --> 31:26.260
那个

31:26.260 --> 31:28.260
因为我们之前呢

31:28.260 --> 31:29.260
是要在一个

31:29.260 --> 31:30.260
进节里面去讲的

31:30.260 --> 31:31.260
但是呢

31:31.260 --> 31:32.260
好像是在一个

31:32.260 --> 31:33.260
设计模式里面有

31:33.260 --> 31:34.260
我也不知道你们

31:34.260 --> 31:35.260
目前的设计模式

31:35.260 --> 31:36.260
在什么位置

31:36.260 --> 31:37.260
所以说

31:37.260 --> 31:38.260
总之那一

31:38.260 --> 31:39.260
肯定是可以搞定的

31:40.260 --> 31:42.260
那么这个怎么用呢

31:42.260 --> 31:43.260
这个返回的新含书

31:43.260 --> 31:44.260
Delay callback

31:44.260 --> 31:45.260
传参书呗

31:45.260 --> 31:46.260
传什么呢

31:46.260 --> 31:47.260
传Duration

31:47.260 --> 31:48.260
对吧

31:48.260 --> 31:49.260
传那个参书

31:51.260 --> 31:52.260
callbackify

31:53.260 --> 31:54.260
看一下啊

31:56.700 --> 31:57.700
callbackify

31:57.700 --> 31:58.700
那么它这个参书怎么弄呢

31:58.700 --> 31:59.700
还有点忘了

31:59.700 --> 32:00.700
我们看一下

32:00.700 --> 32:01.700
看一下这里说的

32:04.530 --> 32:06.530
如果说有参书怎么弄呢

32:08.530 --> 32:10.530
如果说有参书

32:10.530 --> 32:14.180
我们先用一下吧

32:14.180 --> 32:15.180
先用一下

32:15.180 --> 32:16.180
到这里边直接传一个

32:16.180 --> 32:17.180
直接传一个

32:17.180 --> 32:18.180
回调

32:18.180 --> 32:19.180
回调

32:19.180 --> 32:20.180
那么回调的模式呢

32:20.180 --> 32:21.180
是load的模式

32:21.180 --> 32:22.180
就第一个

32:22.180 --> 32:23.180
第一个参书呢是错误

32:23.180 --> 32:25.180
当然我这里也没有什么错误

32:25.180 --> 32:26.180
对吧

32:26.180 --> 32:27.180
什么叫错误呢

32:27.180 --> 32:28.180
就是这个RE借个成的时候

32:28.180 --> 32:29.180
就是错误

32:29.180 --> 32:30.180
那么这个人

32:30.180 --> 32:31.180
第二个参书呢

32:31.180 --> 32:32.180
就是他真正的值

32:32.180 --> 32:33.180
我们这里输出

32:33.180 --> 32:34.180
这边回调模式

32:34.180 --> 32:35.180
对吧

32:35.180 --> 32:36.180
把它换成了回调模式

32:36.180 --> 32:37.180
把这个异部

32:37.180 --> 32:38.180
还说换成了回调模式

32:38.180 --> 32:39.180
咱们来试一下

32:41.180 --> 32:42.180
就是1000

32:42.180 --> 32:43.180
对吧

32:43.180 --> 32:44.180
就是传参书

32:44.180 --> 32:45.180
没有给他传一个间隔时间

32:45.180 --> 32:46.180
那么第一个参书

32:46.180 --> 32:47.180
给他传间隔时间

32:47.180 --> 32:48.180
我觉得应该是没问题的

32:48.180 --> 32:49.180
按逻辑来说是应该没问题的

32:49.180 --> 32:50.180
500

32:50.180 --> 32:53.520
500

32:53.520 --> 32:54.520
对吧

32:54.520 --> 32:55.520
其实这个函数很好写的

32:55.520 --> 32:57.520
你们可以自己去尝试一下

32:57.520 --> 32:58.520
给我一个函数

32:58.520 --> 32:59.520
给你发挥一个新的函数

32:59.520 --> 33:00.520
OK

33:00.520 --> 33:03.900
那么这是callback if

33:03.900 --> 33:04.900
好 都是这一块

33:04.900 --> 33:06.900
然后另外一个呢

33:06.900 --> 33:07.900
我们看一下一个

33:08.900 --> 33:09.900
把这个讲了

33:09.900 --> 33:10.900
先把这个讲了

33:10.900 --> 33:13.900
promise if

33:13.900 --> 33:14.900
那么这东西是相反的

33:14.900 --> 33:15.900
它是把一个回调模式

33:15.900 --> 33:17.900
转换成为

33:17.900 --> 33:18.900
一个异部模式

33:18.900 --> 33:22.900
promise if

33:22.900 --> 33:23.900
我们这里就来吧

33:23.900 --> 33:24.900
就只能来

33:24.900 --> 33:25.900
我们先写个回调模式

33:25.900 --> 33:27.900
不是异部了

33:27.900 --> 33:28.900
不是异部了

33:32.460 --> 33:33.460
方形

33:33.460 --> 33:34.460
dn

33:35.460 --> 33:37.460
callback

33:37.460 --> 33:38.460
它是个回调模式

33:38.460 --> 33:39.460
duration

33:39.460 --> 33:41.460
然后这个callback

33:41.460 --> 33:42.460
回调模式

33:42.460 --> 33:43.460
肯定是回调函数是最后一个

33:43.460 --> 33:44.460
对吧

33:44.460 --> 33:45.460
这是我们的规范

33:45.460 --> 33:46.460
而且回调函数里面

33:46.460 --> 33:47.460
第一个是

33:47.460 --> 33:48.460
第一个是错误

33:48.460 --> 33:49.460
第二个是直

33:49.460 --> 33:50.460
一般只有两个函数

33:50.460 --> 33:51.460
好 来吧

33:51.460 --> 33:53.460
这里set timeout

33:53.460 --> 33:54.460
duration

33:54.460 --> 33:56.460
等待这么一段时间过后

33:56.460 --> 33:57.460
我干嘛呢

33:57.460 --> 34:00.460
我要运行callback

34:00.460 --> 34:02.460
那么回调的错误是什么

34:02.460 --> 34:03.460
错误是now

34:03.460 --> 34:04.460
没有错误

34:04.460 --> 34:05.460
直是什么

34:05.460 --> 34:07.460
直是duration

34:07.460 --> 34:08.460
OK

34:08.460 --> 34:10.460
那么我们就写好回调模式了

34:10.460 --> 34:11.460
那么通过UTO

34:11.460 --> 34:14.460
它可以用promise if

34:14.460 --> 34:15.460
软换成为

34:15.460 --> 34:16.460
把这个delay callback

34:16.460 --> 34:17.460
函数传进去

34:17.460 --> 34:19.460
它可以返回一个新的函数

34:19.460 --> 34:22.460
软换成为一个异部函数

34:22.460 --> 34:23.460
那么这个异部函数

34:23.460 --> 34:24.460
我们就可以用之前的方式来调用了

34:24.460 --> 34:25.460
对吧

34:25.460 --> 34:26.460
z 返回一个promise

34:26.460 --> 34:27.460
对不对

34:27.460 --> 34:28.460
输出

34:28.460 --> 34:29.460
d

34:29.460 --> 34:30.460
这里能我们

34:30.460 --> 34:31.460
500毫秒

34:31.460 --> 34:32.460
这里可以

34:32.460 --> 34:33.460
一个默认值

34:33.460 --> 34:34.460
1000

34:34.460 --> 34:35.460
它第一个藏数有默认值

34:35.460 --> 34:36.460
里面啥意义

34:36.460 --> 34:37.460
好 来吧

34:37.460 --> 34:40.100
我们看一下

34:40.100 --> 34:41.100
是吧

34:41.100 --> 34:43.100
所以把它变成这种模式了

34:43.100 --> 34:45.100
就反过来了

34:45.100 --> 34:46.100
这个很好用的

34:46.100 --> 34:48.100
这个promise if还蛮好用的

34:48.100 --> 34:49.100
因为在note里边

34:49.100 --> 34:51.100
因为它出现的时间比es6早

34:51.100 --> 34:53.100
所以说以前的很多的API

34:53.100 --> 34:55.100
几乎都是用的回调模式

34:55.100 --> 34:56.100
包括我们后边学问了

34:56.100 --> 34:58.100
什么文件处理都是用回调模式

34:58.100 --> 34:59.100
但当然大家知道

34:59.100 --> 35:00.100
回调模式

35:00.100 --> 35:03.100
肯定没有什么es6的promise用的方便

35:03.100 --> 35:04.100
因为它可以结合es7

35:04.100 --> 35:06.100
里边而sync而位置关键制

35:06.100 --> 35:07.100
来使用

35:07.100 --> 35:08.100
对吧

35:08.100 --> 35:09.100
用就非常方便了

35:09.100 --> 35:10.100
你看这个玩意我就可以这样的用了

35:10.100 --> 35:11.100
对吧

35:11.100 --> 35:13.100
写一个立即字音韩数

35:13.100 --> 35:15.660
sync

35:16.660 --> 35:18.660
这里边我们就可以使用

35:18.660 --> 35:20.660
先得到

35:20.660 --> 35:21.660
delay

35:21.660 --> 35:23.660
转换一下

35:23.660 --> 35:25.660
proutil

35:25.660 --> 35:26.660
promise if

35:26.660 --> 35:28.660
delay

35:28.660 --> 35:29.660
delay

35:29.660 --> 35:31.660
nate callback

35:31.660 --> 35:33.660
然后这个delay这个韩数

35:33.660 --> 35:34.660
这个分号结束

35:34.660 --> 35:35.660
这个delay这个韩数

35:35.660 --> 35:36.660
我们就可以用await

35:36.660 --> 35:37.660
delay

35:37.660 --> 35:39.660
五百毫秒

35:39.660 --> 35:41.660
拿到结果

35:41.660 --> 35:42.660
输出

35:42.660 --> 35:43.660
是不是可以用这样的写

35:43.660 --> 35:46.660
这样的写的整个结构就变得很清楚了

35:47.660 --> 35:48.660
是一样的

35:48.660 --> 35:49.660
对吧

35:49.660 --> 35:50.660
因为它反过来是promise

35:50.660 --> 35:51.660
好

35:51.660 --> 35:52.660
这是关于这个

35:52.660 --> 35:53.660
这两个

35:53.660 --> 35:54.660
好

35:54.660 --> 35:55.660
下面这个

35:55.660 --> 35:56.660
inherit

35:56.660 --> 35:57.660
这东西呢

35:57.660 --> 35:58.660
现在也没什么用了

35:58.660 --> 35:59.660
以前还是蛮好用的

35:59.660 --> 36:00.660
在es6出来之前

36:00.660 --> 36:01.660
还是蛮好用的

36:01.660 --> 36:02.660
什么意思呢

36:02.660 --> 36:03.660
做继承的

36:03.660 --> 36:04.660
你看这个名字

36:04.660 --> 36:05.660
就是继承

36:05.660 --> 36:06.660
对吧

36:06.660 --> 36:07.660
第一个写指类

36:07.660 --> 36:08.660
第二个写副类

36:08.660 --> 36:09.660
你有两个勾到韩数吗

36:09.660 --> 36:10.660
比如说你一个勾到韩数

36:10.660 --> 36:11.660
两个勾到韩数

36:11.660 --> 36:12.660
那么我要希望

36:12.660 --> 36:13.660
怎么办呢

36:13.660 --> 36:14.660
你甭管这两个是什么

36:14.660 --> 36:15.660
总之两个勾到韩数

36:15.660 --> 36:16.660
那么

36:16.660 --> 36:18.660
指类放第1个参数

36:18.660 --> 36:19.660
副类放第2个参数

36:19.660 --> 36:20.660
对吧

36:20.660 --> 36:21.660
就副勾到韩数放第2个参数

36:21.660 --> 36:22.660
它就完成了

36:22.660 --> 36:23.660
远信念的继承

36:23.660 --> 36:24.660
用什么用

36:24.660 --> 36:25.660
我是

36:25.660 --> 36:26.660
那么现在肯定不需要了

36:26.660 --> 36:27.660
现在我们用什么

36:27.660 --> 36:28.660
用class

36:28.660 --> 36:29.660
多好

36:29.660 --> 36:30.660
多好的东西

36:30.660 --> 36:31.660
对不对

36:31.660 --> 36:32.660
不需要这个东西了

36:32.660 --> 36:33.660
了解一下就行了

36:33.660 --> 36:34.660
下面这个

36:34.660 --> 36:35.660
就是is deep

36:35.660 --> 36:37.660
strix equal

36:37.660 --> 36:38.660
什么意思呢

36:38.660 --> 36:39.660
它表示

36:39.660 --> 36:40.660
深度比较

36:40.660 --> 36:41.660
深度严格比较

36:41.660 --> 36:42.660
它将两个对象

36:42.660 --> 36:43.660
进行深度严格比较

36:43.660 --> 36:44.660
这个东西

36:44.660 --> 36:45.660
用的是蛮好用的

36:45.660 --> 36:46.660
比较这么这里

36:46.660 --> 36:47.660
有两个对象

36:48.660 --> 36:49.660
const

36:49.660 --> 36:50.660
obj1

36:51.660 --> 36:52.660
a等于1

36:52.660 --> 36:54.660
b等于一个对象

36:54.660 --> 36:55.660
c等于3

36:55.660 --> 36:56.660
d等于一个对象

36:56.660 --> 36:57.660
1等于5

37:00.660 --> 37:02.660
obj2也是一样的

37:02.660 --> 37:03.660
我们现在要比较

37:03.660 --> 37:04.660
这两个对象相不相等

37:04.660 --> 37:05.660
什么就比较了

37:05.660 --> 37:06.660
就是如果说

37:06.660 --> 37:07.660
遇到一些基本的类型

37:07.660 --> 37:09.660
我们就直接用严格相等

37:09.660 --> 37:10.660
如果说遇到对象

37:10.660 --> 37:11.660
我们就还要变异对象里面的

37:11.660 --> 37:12.660
所有的属性

37:12.660 --> 37:14.660
再来用同样的规则来比较

37:14.660 --> 37:15.660
是否严格相等

37:15.660 --> 37:16.660
对吧

37:16.660 --> 37:17.660
对每一个属性都要进行比较

37:17.660 --> 37:18.660
那么这个两个对象

37:18.660 --> 37:19.660
我们要比较起来

37:19.660 --> 37:20.660
还挺麻烦的

37:20.660 --> 37:21.660
对吧

37:21.660 --> 37:22.660
因为有可能你不知道

37:22.660 --> 37:23.660
这两个对象的深度是多少

37:23.660 --> 37:25.660
它又牵托了多少的属性

37:25.660 --> 37:26.660
那么这个时候

37:26.660 --> 37:27.660
就可以用ut

37:27.660 --> 37:28.660
第二什么

37:28.660 --> 37:29.660
strix

37:29.660 --> 37:30.660
is deep

37:30.660 --> 37:31.660
strix

37:31.660 --> 37:33.660
深度的严格的相等

37:33.660 --> 37:36.660
是否深度严格相等

37:36.660 --> 37:37.660
那么这里

37:37.660 --> 37:38.660
obj1

37:38.660 --> 37:39.660
obj2

37:42.300 --> 37:44.300
如果说你改动了一个对象

37:44.300 --> 37:46.300
当然如果都是严格相等

37:46.300 --> 37:47.300
所以说你改动类型

37:47.300 --> 37:48.300
它也会变得不相等

37:48.300 --> 37:49.300
forced

37:49.300 --> 37:51.300
当然如果说你去加什么属性

37:51.300 --> 37:52.300
加一个属性

37:52.300 --> 37:53.300
更加不要说了

37:53.300 --> 37:54.300
加个属性

37:54.300 --> 37:55.300
就forced

37:55.300 --> 37:56.300
OK

37:56.300 --> 37:57.300
那么这是关于

37:57.300 --> 37:58.300
这个函数

37:58.300 --> 37:59.300
总之

37:59.300 --> 38:00.300
整个UTO

38:00.300 --> 38:01.300
这个cool里面

38:01.300 --> 38:03.300
它就是提供的是

38:03.300 --> 38:05.300
很多的这种工具

38:05.300 --> 38:07.300
aboutUTO

38:07.300 --> 38:08.300
好

38:08.300 --> 38:09.300
那么这就看到

38:09.300 --> 38:11.300
介绍了这么四个

38:11.300 --> 38:12.300
基本的内置库

38:12.300 --> 38:14.300
内置库

38:14.300 --> 38:15.300
各有千秋

38:15.300 --> 38:16.300
各有各样的特点

38:16.300 --> 38:17.300
一个是

38:17.300 --> 38:18.300
看操作系统里面的信息的

38:18.300 --> 38:19.300
这个用的稍微少一点

38:19.300 --> 38:21.300
一个是看路径的

38:21.300 --> 38:23.300
我们的文件路径

38:23.300 --> 38:24.300
我们的相对路径

38:24.300 --> 38:25.300
这种东西

38:25.300 --> 38:26.300
一个是看UIL地址的

38:26.300 --> 38:27.300
来进行转换的

38:27.300 --> 38:28.300
转换对象

38:28.300 --> 38:29.300
对象转换的UIL地址

38:29.300 --> 38:31.300
一个是一些辅助含书

38:31.300 --> 38:32.300
UTO

38:32.300 --> 38:33.300
如果说有兴趣的话

38:33.300 --> 38:34.300
可以去看一下相应的文档

38:34.300 --> 38:35.300
其他都不复杂

38:35.300 --> 38:36.300
都不复杂

38:36.300 --> 38:37.300
它里面都有例子的

38:37.300 --> 38:38.300
一看就明白了

38:38.300 --> 38:39.300
好

38:39.300 --> 38:40.300
OK

38:40.300 --> 38:41.300
那这里就是关于

38:41.300 --> 38:42.300
做解课的东西

38:42.300 --> 38:43.300
基本的模块转换

38:43.300 --> 38:44.300
还是那句话

38:44.300 --> 38:46.300
下载的还是去写一遍

38:46.300 --> 38:49.300
不管有没有意义

38:49.300 --> 38:50.300
感觉好像没有什么意义

38:50.300 --> 38:51.300
代码也很简单

38:51.300 --> 38:52.300
但是一定要去写一遍

38:52.300 --> 38:53.300
不然的话

38:53.300 --> 38:54.300
一点人影响都没有

38:54.300 --> 38:55.300
一点人影响都没有就麻烦了

38:55.300 --> 38:57.300
将来遇到有问题的时候

38:57.300 --> 38:58.300
你都不知道路德里面

38:58.300 --> 39:00.300
能不能解决这个问题

39:00.300 --> 39:01.300
你写过一遍

39:01.300 --> 39:03.300
至少你有个感觉就是

39:03.300 --> 39:04.300
你知道它能解决

39:04.300 --> 39:05.300
但是不知道怎么解决的

39:05.300 --> 39:06.300
你可以查文档

39:06.300 --> 39:07.300
如果说你不知道

39:07.300 --> 39:08.300
它能不能解决

39:08.300 --> 39:09.300
那就麻烦了

39:09.300 --> 39:11.300
所以一定要去写一遍

39:11.300 --> 39:12.300
OK

39:12.300 --> 39:13.300
大师小姐的内容

