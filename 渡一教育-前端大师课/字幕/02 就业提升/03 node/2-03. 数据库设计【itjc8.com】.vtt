WEBVTT

00:00.620 --> 00:04.060
这就可能内容很多 数据库设计

00:04.060 --> 00:06.760
那么就开始正式的进入买搜索的学习了

00:06.760 --> 00:09.260
概念非常非常多 但是呢

00:09.260 --> 00:12.660
是比这些概念都比较好理解啊 下来过后了

00:12.660 --> 00:16.980
你们最好是跟着我的课堂上的东西呢 边看边 边做啊

00:16.980 --> 00:19.380
去体会一下这种感觉

00:19.380 --> 00:22.620
一个也是搜索 数据库东西很多很多啊

00:22.620 --> 00:26.220
我们很多东西点到极值 一个是搜索的概念

00:26.220 --> 00:29.740
搜索是什么呢 它叫做结构化查询语言

00:29.940 --> 00:33.260
它是一门语言了 它属于声明式语言 对吧

00:33.260 --> 00:36.060
我们平时写的结构呢 属于是命令式语言

00:36.060 --> 00:38.580
声明式语言去向ATM和CSA这种 对吧

00:38.580 --> 00:40.300
它直接可以表达含义的

00:40.300 --> 00:42.500
那么声明式语言学习起来还是比较简单的

00:42.500 --> 00:45.340
要比命令式语言学习起来简单多了

00:45.340 --> 00:48.460
所以说搜索呢 语言还是蛮简单的

00:48.460 --> 00:51.860
这个搜索啊 它不是说买搜索特有的

00:51.860 --> 00:56.820
几乎所有的关系型数据库都基本的拥有着一致的搜索语法

00:56.860 --> 00:58.580
所以说我们学了搜索之后呢

00:58.580 --> 01:00.500
你倒一用一些别的数据库啊

01:00.500 --> 01:03.540
像什么那个Oracle啊 或者是搜索设备啊

01:03.540 --> 01:04.980
都大致差不多啊

01:05.820 --> 01:08.380
在搜索语言里边呢 它有分为三个分支

01:08.380 --> 01:10.380
一个是DDL DDL是什么意思呢

01:10.380 --> 01:12.860
叫做数据定义语言

01:12.860 --> 01:14.900
它主要用来操作数据库对象

01:14.900 --> 01:16.700
什么叫操作过数据库对象呢

01:16.700 --> 01:20.460
数据库对象指的是 比方说我一个个有一个库

01:20.460 --> 01:22.780
像这种就是一个数据 这是个数据库 对吧

01:22.780 --> 01:24.380
这是一个数据库 这是一个数据库

01:24.380 --> 01:26.220
那么库就是个对象

01:26.220 --> 01:29.260
还不仅是库 还包括什么呢 还包括表

01:29.260 --> 01:31.260
我们不是有很多表组成吗 对吧

01:31.260 --> 01:35.460
库有先是数据库管理工具 对吧

01:35.460 --> 01:37.060
数据库管理工具 服务器

01:37.060 --> 01:38.540
然后里边有很多库

01:38.540 --> 01:41.460
每一个库呢 就相当于是你可以理解成一个一个摄像文件

01:41.460 --> 01:43.820
一个摄像文件里边是不是可以有很多表 对吧

01:43.820 --> 01:45.420
有很多很多的表

01:45.420 --> 01:48.220
那么每一个表呢 就是表

01:48.220 --> 01:50.820
那表也是数据库的对象

01:50.820 --> 01:52.380
还有后表我们要学习到试图

01:52.380 --> 01:53.460
存足过程我们不学啊

01:53.460 --> 01:55.860
那是后边的那是后端要学的

01:55.860 --> 01:59.660
我们前端要到试图就已经够了 就已经够了

01:59.660 --> 02:00.500
好 这是DDL

02:00.500 --> 02:02.260
它主要是在操作这些东西的

02:02.260 --> 02:04.620
比方删除一张表 添加一张表 添加一个库

02:04.620 --> 02:07.420
删除一个库 添加一个试图 删除一个试图

02:07.420 --> 02:08.660
它主要操作这些东西的

02:08.660 --> 02:11.860
我们这里和学习的是DDL

02:11.860 --> 02:13.220
第二个是DML

02:13.220 --> 02:15.660
我们后边主要学习DML

02:15.660 --> 02:17.300
这是对我们开发直接相关的

02:17.300 --> 02:20.820
DDL呢 我们简单的了解一下就行了

02:20.820 --> 02:22.900
DML是数据操纵语言

02:22.900 --> 02:23.860
它操作的是什么呢

02:23.860 --> 02:25.300
是数据库中的记录

02:25.340 --> 02:28.660
就相当于是咱们表格里边的行

02:28.660 --> 02:29.540
就这么个意思

02:29.540 --> 02:31.220
一张表里边是不是有很多行组成

02:31.220 --> 02:34.140
对吧 我删除一行 添加一行

02:34.140 --> 02:35.340
然后查找一些行

02:35.340 --> 02:38.740
那么这是DML 数据操纵语言

02:38.740 --> 02:41.540
第三个我们最后可以了解一下

02:41.540 --> 02:43.580
最了解就是控制权限

02:43.580 --> 02:46.940
控制用户权限叫DCL 数据控制语句

02:46.940 --> 02:49.020
那么它主要是分为这三个分支

02:49.020 --> 02:52.540
这三个分支 每个分支的语法是大致一致的

02:52.540 --> 02:54.940
比方说在操作DDL的时候

02:54.980 --> 02:56.340
我们这就和学习DDL

02:56.340 --> 02:58.140
它新建一个库和新建一张表

02:58.140 --> 02:58.860
新建一个试图

02:58.860 --> 03:00.660
它语法是基本一致的

03:00.660 --> 03:03.780
试图我们以后再说 这一个不着急

03:03.780 --> 03:04.820
好 那么这是射口

03:04.820 --> 03:05.780
我们简单的认识一下

03:05.780 --> 03:08.100
就是我们操作数据库实际上是用的是射口

03:08.100 --> 03:09.820
我们这里看到的图形界面

03:09.820 --> 03:11.460
这里面我们可以用鼠标点一点

03:11.460 --> 03:12.260
就可以操作了

03:12.260 --> 03:14.620
是因为它的内部帮我们生成了射口

03:14.620 --> 03:16.100
在那个迈射口命令行里边

03:16.100 --> 03:18.020
给我们直接运行了

03:18.020 --> 03:19.740
是因为这样子的

03:19.740 --> 03:20.940
然后我们首先来看

03:20.940 --> 03:22.100
怎么来管理一个库

03:22.100 --> 03:23.420
管理库的话就是创建库

03:23.420 --> 03:24.660
切换库和删除库

03:24.660 --> 03:26.100
我们首先来创建库

03:26.100 --> 03:26.860
创建库的话

03:26.860 --> 03:28.900
我们可以使用射口语句来创建

03:28.900 --> 03:30.500
比方说我们这里点击

03:30.500 --> 03:31.740
这里查询

03:31.740 --> 03:32.620
新建的查询

03:32.620 --> 03:34.980
那么在这里面就可以使用射口语句了

03:34.980 --> 03:35.860
放大一点

03:35.860 --> 03:36.780
按住康处有加尔

03:36.780 --> 03:38.980
鼠标稳轮就可以放大

03:38.980 --> 03:40.340
怎么来创建一个库呢

03:40.340 --> 03:41.980
我这里给他一个文档

03:41.980 --> 03:43.260
这个文档不是官方文档

03:43.260 --> 03:44.620
官方文档全英文的

03:44.620 --> 03:46.500
而且官方文档他讲的太过于详细了

03:46.500 --> 03:48.500
对我们前端来说根本就没有必要

03:48.500 --> 03:50.420
所以说通常情况下

03:50.420 --> 03:51.740
我是不建议看这种文档的

03:51.780 --> 03:53.980
这种文档太过于简单了

03:53.980 --> 03:55.380
但是因为我们前端

03:55.380 --> 03:57.180
买售个本身不是我们的主业

03:57.180 --> 04:00.260
所以说我们就可以简单了解一下

04:00.260 --> 04:00.660
就行了

04:00.660 --> 04:02.500
比方创建数据库非常简单

04:02.500 --> 04:03.340
create

04:03.340 --> 04:05.060
它的就是地底也有语句

04:05.060 --> 04:05.700
地底也有语句

04:05.700 --> 04:07.460
创建东西都自己create

04:07.460 --> 04:08.620
创建data base

04:08.620 --> 04:09.140
创建什么呢

04:09.140 --> 04:10.860
创建一个对象叫data base

04:10.860 --> 04:11.860
数据库对象

04:11.860 --> 04:13.940
后边跟上一个数据库的名字

04:13.940 --> 04:15.460
那么咱们来试一下

04:15.460 --> 04:17.380
create

04:17.380 --> 04:18.620
data base

04:18.620 --> 04:19.460
不存放大小写

04:19.460 --> 04:21.220
数据库里面是不存放大小写的

04:21.260 --> 04:23.020
然后数据库的名字

04:23.020 --> 04:23.940
好数据库的名字

04:23.940 --> 04:25.540
这里也可以直接写

04:25.540 --> 04:26.780
比如说abc

04:26.780 --> 04:28.660
你可以直接写

04:28.660 --> 04:29.540
分号结束

04:29.540 --> 04:30.780
那么怎么来运行呢

04:30.780 --> 04:31.860
这里还可以美化社会

04:31.860 --> 04:32.620
美化社会

04:32.620 --> 04:34.340
它把这些该

04:34.340 --> 04:36.540
就是规范里面转换成大写

04:36.540 --> 04:37.900
其实不许分大小写的

04:37.900 --> 04:39.180
咱们点赞运行

04:39.180 --> 04:42.420
也可以按ctr加r来进行运行

04:42.420 --> 04:43.620
运行完了

04:43.620 --> 04:45.700
那么现在是不是创建了一个库abc呢

04:45.700 --> 04:46.300
是的

04:46.300 --> 04:48.380
我们这里点击右键刷新

04:48.380 --> 04:49.980
你看是不是多了一个库abc

04:49.980 --> 04:50.780
就这么简单

04:50.780 --> 04:52.660
我们把删除掉

04:52.660 --> 04:54.540
当然了也可以用这种方式

04:54.540 --> 04:55.860
也可以用这种方式右键

04:55.860 --> 04:57.420
这里用图形界面的方式

04:57.420 --> 04:59.020
新键这样子更加方便一点

04:59.020 --> 05:01.020
数据库的我们给它写一个test

05:01.020 --> 05:01.900
比方说

05:01.900 --> 05:04.300
这里边可不可以点这个搜口语了

05:04.300 --> 05:06.020
是不是它给你生存了这个语句

05:06.020 --> 05:07.620
那么这个符号什么意思呢

05:07.620 --> 05:09.700
这个就是反应号

05:09.700 --> 05:11.140
在数据库里面

05:11.140 --> 05:13.860
它为了有一些我们自己命名的地方

05:13.860 --> 05:15.860
你看abc是不是我们自己命名

05:15.860 --> 05:16.780
自己命名的地方

05:16.780 --> 05:19.020
为了避免给它的关键字冲突

05:19.100 --> 05:21.060
所以说我们一般会把它变成字符串

05:21.060 --> 05:22.420
在搜口里面的字符串

05:22.420 --> 05:23.660
就买搜口的一边字符串

05:23.660 --> 05:25.740
是一个反应鞋杠

05:25.740 --> 05:27.020
这个东西表示一个字符串

05:27.020 --> 05:28.140
是这么个意思

05:28.140 --> 05:29.420
所以说你看它这里

05:29.420 --> 05:30.780
我们新建一个数据库

05:30.780 --> 05:33.180
这里ab就是用test

05:33.180 --> 05:34.420
我们点击搜口语了是不是

05:34.420 --> 05:35.300
它给你生存了这个语句

05:35.300 --> 05:37.380
所以说它跟它这里的操作

05:37.380 --> 05:39.740
就跟运行这个搜口语句

05:39.740 --> 05:41.540
效果是完全一样的

05:41.540 --> 05:42.060
那一个同学说

05:42.060 --> 05:43.820
那我这里既然可以这样子操作

05:43.820 --> 05:45.860
为什么我还要去学搜口语句呢

05:45.860 --> 05:48.220
是因为你们到时候真正操作数据库

05:49.180 --> 05:51.220
不是进入服务器

05:51.220 --> 05:53.460
在这里用鼠标点来点去操作的

05:53.460 --> 05:55.420
而是要通过程序自动操作的

05:55.420 --> 05:57.620
而程序是不是只能运行这样的命令

05:57.620 --> 05:58.300
我们漏得里边

05:58.300 --> 06:00.820
我们到时候会在漏得里边去运行这样的命令

06:00.820 --> 06:01.340
你来这意思吧

06:01.340 --> 06:03.340
所以说我们必须要学习这样的命令

06:03.340 --> 06:05.820
有的时候你的程序可能要自动的创建一个数据库

06:05.820 --> 06:07.420
自动的创建一些表格

06:07.420 --> 06:09.340
那么你就必须要知道这些命令

06:09.340 --> 06:11.500
不过这些命令我们简单了解一下

06:11.500 --> 06:14.180
因为我们如果说你要看一下

06:14.180 --> 06:17.100
它就是我们大部分时候是用这种操作

06:17.140 --> 06:19.180
因为实际有更多的情况下

06:19.180 --> 06:21.740
我们在工程里边

06:23.740 --> 06:25.180
工程里边它都是有权限的

06:25.180 --> 06:28.420
不会让你的程序是不能让你的程序

06:28.420 --> 06:29.860
有直接创建数据库的权利的

06:29.860 --> 06:31.900
我们的开发阶段的话无所谓

06:31.900 --> 06:33.300
到时候它可以你分配的用户账号

06:33.300 --> 06:34.620
你是不能创建数据库的

06:34.620 --> 06:35.620
不能创建表的

06:35.620 --> 06:38.220
所以说我们还是会使用

06:38.220 --> 06:39.900
要么就使用搜口

06:39.900 --> 06:42.420
要么就使用那个就是在这里

06:42.420 --> 06:45.460
用图形界面的方式来进行管理

06:45.500 --> 06:46.980
因此如果说你要知道搜口的话

06:46.980 --> 06:48.500
你切换到搜口你一看就知道了

06:48.500 --> 06:49.700
所以说为什么工具好用

06:49.700 --> 06:50.820
就是这个原因

06:50.820 --> 06:52.940
当然其实除了这个NiveKat

06:52.940 --> 06:53.660
还有一些工具

06:53.660 --> 06:54.660
比方说买搜口

06:54.660 --> 06:57.220
Edomain它也是一个管理数据库的工具

06:57.220 --> 06:59.140
不过这个东西就太简陋了

06:59.140 --> 07:01.380
这东西确实收费它确实好用

07:01.380 --> 07:02.900
咱们这里点击确定

07:02.900 --> 07:04.500
你看是不是也是创建了一个数据库

07:04.500 --> 07:05.660
它自动给你刷新了

07:05.660 --> 07:06.300
对不对

07:06.300 --> 07:08.820
这里创建数据库了

07:08.820 --> 07:10.340
都是创建数据库

07:10.340 --> 07:11.340
创建数据库了

07:11.340 --> 07:13.060
然后切换当前库

07:13.060 --> 07:14.300
什么叫切换当前库了

07:14.340 --> 07:15.260
你看一下

07:15.260 --> 07:16.500
我们目前的

07:16.500 --> 07:18.380
我们用的数据库是这个

07:18.380 --> 07:19.540
看一下这里是不是没有

07:19.540 --> 07:21.620
我们没有当前没有用任何的数据库

07:21.620 --> 07:22.940
比方说创建表

07:22.940 --> 07:23.860
创建表的时候

07:23.860 --> 07:25.140
往哪个数据库创建表

07:25.140 --> 07:25.820
他就不知道

07:25.820 --> 07:27.740
它是往当前的数据库创建表

07:27.740 --> 07:29.020
所以说你要切换一下

07:29.020 --> 07:29.820
当前的数据库

07:29.820 --> 07:30.580
最简单的是什么了

07:30.580 --> 07:31.780
最简单的就是在这里选

07:31.780 --> 07:32.540
对不对

07:32.540 --> 07:33.140
在这里选

07:33.140 --> 07:34.540
这里要把关了

07:34.540 --> 07:35.740
关了重新打开一次

07:36.420 --> 07:37.420
点查讯

07:38.300 --> 07:38.780
点查

07:38.780 --> 07:40.420
我这个数据库这边打开

07:40.420 --> 07:41.420
这边打开

07:42.860 --> 07:44.180
双击嘛打开

07:44.180 --> 07:44.980
点查讯

07:44.980 --> 07:45.700
新建查讯

07:45.700 --> 07:47.900
你看一下这个地方数据库是不是Test了

07:47.900 --> 07:49.140
对不对

07:49.140 --> 07:50.460
就切换到这个数据库了

07:50.460 --> 07:51.900
能不能用命令切换

07:51.900 --> 07:52.500
当然可以

07:52.500 --> 07:54.580
用一个Use命令

07:54.580 --> 07:55.540
使用什么数据库

07:55.540 --> 07:57.700
比方说使用SYIS分号

07:57.700 --> 07:59.220
方数加R运行

07:59.220 --> 08:00.580
那么现在我们就使用了

08:00.580 --> 08:02.740
是SYIS数据库

08:02.740 --> 08:04.140
那为什么这里没变呢

08:04.140 --> 08:06.180
因为这里是我们用窗口的方式

08:06.180 --> 08:06.940
操作的

08:06.940 --> 08:09.340
如果说你要使用命令的方式

08:09.340 --> 08:10.500
来切换数据库的话

08:10.500 --> 08:12.060
那么你后边就接着写代

08:12.060 --> 08:13.500
接着写后边的收口语句

08:13.540 --> 08:14.980
那么整个收口语句运行的时候

08:14.980 --> 08:16.380
它会切换到这个数据库

08:16.380 --> 08:17.300
然后运行完

08:17.300 --> 08:18.380
因为这个窗口的原因

08:18.380 --> 08:19.860
它给你切换过来了

08:19.860 --> 08:20.620
是这个原因

08:20.620 --> 08:22.140
但是这个命令是没问题的

08:22.140 --> 08:24.300
是用这种方式的命令来切换数据库

08:24.300 --> 08:24.820
OK

08:24.820 --> 08:26.860
这是关于选择数据库

08:26.860 --> 08:28.380
我们现在正在使用哪个数据库

08:28.380 --> 08:29.420
就这么个意思

08:29.420 --> 08:31.580
然后三处库非常简单

08:31.580 --> 08:32.460
三处库的话

08:32.460 --> 08:33.940
我们看可以点这里

08:33.940 --> 08:35.460
直接三处数据库

08:35.460 --> 08:35.860
对吧

08:35.860 --> 08:36.980
点击三处库三处了

08:36.980 --> 08:39.140
也可以使用这个地方

08:39.140 --> 08:40.100
新建一个查讯

08:40.100 --> 08:43.180
我们使用Job

08:43.220 --> 08:44.340
三处的数据库

08:44.340 --> 08:45.260
Job Database

08:47.340 --> 08:48.020
Database

08:48.020 --> 08:48.860
然后Test

08:50.100 --> 08:51.060
运行

08:51.060 --> 08:52.100
运行完了

08:52.100 --> 08:53.380
我们下面

08:53.380 --> 08:54.660
下面这个东西怎么放大呢

08:54.660 --> 08:56.220
我看一下

08:56.220 --> 08:58.220
下面这个东西怎么放大

08:58.220 --> 08:59.420
你们能不能看得清楚

09:02.660 --> 09:03.900
命令行

09:03.900 --> 09:05.820
我记得哪个地方可以查一下

09:07.660 --> 09:09.340
数据结构窗口

09:10.780 --> 09:12.700
就是我平时还没挑拨这个玩意

09:14.180 --> 09:17.860
查看信息窗格

09:17.860 --> 09:19.860
怎么调大了这个东西

09:19.860 --> 09:21.060
好像还调不大

09:21.060 --> 09:21.660
好像调不大

09:21.660 --> 09:22.860
调不大算了吧

09:22.860 --> 09:25.500
那么这里我们没一个看得清楚

09:25.500 --> 09:27.780
就是它这里执行时间是00008秒

09:27.780 --> 09:28.300
对吧

09:28.300 --> 09:29.460
那么又三处的数据库了

09:29.460 --> 09:30.300
我们这里刷新

09:30.300 --> 09:31.700
点击右键刷新

09:31.700 --> 09:32.900
你看是不是数据库没了

09:32.900 --> 09:33.420
对不对

09:33.420 --> 09:35.220
这就是创建库三处库

09:35.220 --> 09:36.860
而使用库

09:36.860 --> 09:38.780
我们这里还是把创建回去Test

09:40.380 --> 09:40.620
好

09:40.620 --> 09:41.980
那么这是这一块

09:42.140 --> 09:43.020
接下来我们继续看

09:43.020 --> 09:44.420
这是管理库

09:44.420 --> 09:47.340
更多的我们这些和最重要的是学习管理表

09:47.340 --> 09:49.220
因为我们真正的管理库很简单

09:49.220 --> 09:49.540
对吧

09:49.540 --> 09:50.700
直接操作一下就完了

09:50.700 --> 09:52.020
关键是怎么来管理表格

09:52.020 --> 09:54.060
因为我们知道一个库里边有很多的表格

09:54.060 --> 09:54.540
对不对

09:54.540 --> 09:55.780
我们首先来看创建表

09:56.940 --> 09:58.820
创建表的时候怎么来创建的

09:58.820 --> 10:00.380
我们也是用DDL语句

10:00.380 --> 10:02.260
当然也可以使用这里的

10:02.260 --> 10:03.620
把双击打开

10:03.620 --> 10:05.180
然后这里是不是有个表

10:05.180 --> 10:06.540
表里表我们点击右键

10:06.540 --> 10:08.060
新建一个表

10:08.060 --> 10:09.780
新建个表它就是弹出一个窗格

10:10.780 --> 10:11.900
你们能不能看清楚

10:11.900 --> 10:12.660
应该可以

10:12.660 --> 10:14.340
我这个录的还是比较清晰的

10:14.980 --> 10:15.940
这个窗格里边

10:15.940 --> 10:17.660
它这里边每一行表什么意思

10:17.660 --> 10:19.820
它不是编辑的表的行

10:19.820 --> 10:21.140
是编辑表的列

10:21.140 --> 10:21.940
我们自然说过

10:21.940 --> 10:22.940
咱们数据快表了

10:22.940 --> 10:24.420
它是列是固定的

10:24.420 --> 10:26.660
然后因此你要编辑每一列

10:27.300 --> 10:29.100
那么列里边有很多的很多的信息

10:29.100 --> 10:30.500
每一列都有很多信息

10:30.500 --> 10:31.220
这是第一列

10:31.220 --> 10:31.660
对吧

10:31.660 --> 10:32.780
如果说还有

10:33.780 --> 10:36.300
现在写完一列才能写下一列

10:36.300 --> 10:37.460
就是这是一列

10:37.460 --> 10:38.300
那么还有第二列

10:38.340 --> 10:40.340
第二行又是下一列

10:40.340 --> 10:41.380
有这么个意思

10:41.380 --> 10:43.660
每一列里边有很多的信息的

10:43.660 --> 10:44.620
有很多的信息

10:44.620 --> 10:46.260
我们先把图形界面搞清楚了

10:46.260 --> 10:48.180
过后我们再来看搜口语句

10:48.180 --> 10:49.620
列里边有很多信息

10:49.620 --> 10:50.620
第一个重要的信息

10:50.620 --> 10:53.060
就是每一列相当于是个字段

10:53.060 --> 10:54.820
我们在数据库里边把它叫做字段

10:54.820 --> 10:55.940
或者叫做属性

10:55.940 --> 10:57.700
有点像对象的里边属性

10:57.700 --> 10:58.260
对吧

10:58.260 --> 11:00.780
比方说我们的对象

11:00.780 --> 11:01.660
一个学生

11:01.660 --> 11:02.300
学生对象

11:02.300 --> 11:03.980
学生对象里边是不是有哪些属性

11:03.980 --> 11:05.140
有姓名

11:05.140 --> 11:06.420
年龄

11:06.860 --> 11:09.060
就是出生日期

11:09.060 --> 11:10.020
还有什么

11:10.020 --> 11:10.660
还有

11:11.420 --> 11:12.700
住址

11:12.700 --> 11:13.100
对不对

11:13.100 --> 11:14.380
所以有这么一些信息

11:14.380 --> 11:15.780
还有什么性别

11:15.780 --> 11:16.340
对不对

11:16.340 --> 11:18.060
那么这些事就相当于是属性

11:18.060 --> 11:19.260
它也叫做字段

11:19.260 --> 11:19.980
也叫做列

11:19.980 --> 11:21.340
都是一个意思

11:21.340 --> 11:23.300
那么这里我们第一个就是列的名字

11:24.580 --> 11:25.220
列的名字

11:26.700 --> 11:27.980
每个字段还有字段名

11:27.980 --> 11:29.220
就是列的名字

11:29.220 --> 11:30.340
列的名字我们写上了

11:30.340 --> 11:32.940
就肯定是用英文不能用中文

11:32.940 --> 11:35.620
一般是就用小写的英文

11:35.620 --> 11:37.940
比方说我们这里想列的名字

11:37.940 --> 11:39.060
我们学生名字

11:39.060 --> 11:39.660
列

11:39.660 --> 11:39.900
对吧

11:39.900 --> 11:41.420
就是列的名字

11:41.420 --> 11:41.980
好

11:41.980 --> 11:44.740
列的类型是指它的数据内型

11:44.740 --> 11:47.300
就像介石代码里边也不是有各种类型

11:47.300 --> 11:49.620
那么这里的类型你必须要指定它

11:49.620 --> 11:51.100
那么后边填数据的时候

11:51.100 --> 11:52.700
比方说填一个姓名

11:52.700 --> 11:53.820
姓名是一个字符串

11:53.820 --> 11:55.500
你不能填数字

11:55.500 --> 11:56.700
数字就算填数字

11:56.700 --> 11:58.380
它也办好会把它当成字符串

11:58.380 --> 11:59.300
明白吗

11:59.300 --> 12:01.060
那么列的类型比较需要指定

12:01.060 --> 12:03.900
我这里给大家列举了一些常见的类型

12:03.980 --> 12:06.820
那么其实它里边还有很多类型

12:06.820 --> 12:08.100
不过对我们前段来说

12:08.100 --> 12:09.980
了解这些常用的类型就够了

12:09.980 --> 12:10.700
一个是BET

12:10.700 --> 12:11.700
BET是什么意思呢

12:11.700 --> 12:14.140
它一般是它只占一位

12:14.140 --> 12:15.260
它占的空间比较小

12:15.260 --> 12:16.500
占的是硬盘空间

12:16.500 --> 12:17.460
现在不是内存了

12:17.460 --> 12:18.460
但硬盘空间比较小

12:18.460 --> 12:20.740
就零和一

12:20.740 --> 12:21.500
只占一位

12:21.500 --> 12:23.260
因此它可以存出那种Force

12:23.260 --> 12:24.100
就是布尔类型

12:24.100 --> 12:25.260
有点像类似于布尔

12:25.260 --> 12:26.260
它可以存出那种

12:26.260 --> 12:28.660
就是只需有两种情况的字

12:28.660 --> 12:29.540
比方说男和女

12:29.540 --> 12:29.940
对不对

12:29.940 --> 12:32.380
如果说没有什么性别保虑这些东西的话

12:32.420 --> 12:33.980
如果我的系统里面只能填蓝

12:33.980 --> 12:34.500
要么填蓝

12:34.500 --> 12:35.660
没有什么保密

12:35.660 --> 12:36.700
没有什么不填

12:36.700 --> 12:37.740
那么这种情况下

12:37.740 --> 12:40.820
我们就可以设置这种类型

12:40.820 --> 12:42.420
设置就是BET成类型

12:42.420 --> 12:44.300
那么名字肯定不行

12:44.300 --> 12:46.220
然后数字有这么几种

12:46.220 --> 12:47.260
这两种

12:47.260 --> 12:48.500
数字就是int

12:48.500 --> 12:49.660
int表示一个整数

12:49.660 --> 12:50.940
它占32位

12:50.940 --> 12:52.220
4个字节

12:52.220 --> 12:52.420
好

12:52.420 --> 12:53.340
如果说你有小

12:53.340 --> 12:54.380
它不能存小数的

12:54.380 --> 12:55.660
只能存整数

12:55.660 --> 12:57.460
如果说你是一个小数的话

12:57.460 --> 12:58.620
那么有Flows

12:58.620 --> 12:59.660
double这些类型

12:59.660 --> 13:00.860
但是我们比较常见的

13:00.860 --> 13:02.780
是用Decimal

13:02.780 --> 13:05.660
Decimal是一个精确数字

13:05.660 --> 13:06.300
因为我们知道

13:07.900 --> 13:09.860
计算机对小数的用算是不精确的

13:09.860 --> 13:10.100
对吧

13:10.100 --> 13:10.500
你们知道

13:10.500 --> 13:11.820
JS里面是这样子

13:11.820 --> 13:12.060
对吧

13:12.060 --> 13:13.020
那像Flows

13:13.020 --> 13:13.820
double

13:13.820 --> 13:17.100
JS里面的小数类型就有点类似于double

13:17.100 --> 13:19.980
64位的双经度小数

13:19.980 --> 13:20.780
对吧

13:20.780 --> 13:23.060
那么这里就是

13:23.060 --> 13:24.020
由于Flows

13:24.020 --> 13:24.340
double

13:24.340 --> 13:27.260
它计算的过程它都不精确

13:27.260 --> 13:29.540
我们如果说要精确的计算数据

13:29.540 --> 13:30.180
数字的话

13:30.220 --> 13:32.460
那么我们可以使用Decimal

13:32.460 --> 13:34.220
但是它的计算数都要慢一点

13:34.220 --> 13:36.300
但是它计算的结果是比较精确的

13:36.300 --> 13:38.180
它这里小框号里面要填两个东西

13:38.180 --> 13:39.140
一个mn

13:39.140 --> 13:40.100
mn什么意思呢

13:40.100 --> 13:42.780
m表示的是总的数字位数

13:42.780 --> 13:44.500
n是小数位数

13:44.500 --> 13:45.260
啥意思呢

13:45.260 --> 13:49.020
比方说我们这里3.14159

13:49.020 --> 13:50.020
那么这个数字

13:50.020 --> 13:51.020
它的m是多少呢

13:51.020 --> 13:54.380
m就是1 2 3 4 5 6

13:54.380 --> 13:55.220
6

13:55.220 --> 13:56.220
那么n是多少呢

13:56.220 --> 13:57.300
n就是5

13:57.300 --> 13:58.300
2的意思吧

13:58.300 --> 14:00.020
那么你这个mn是什么意思呢

14:00.020 --> 14:01.820
就是说你这个数字里面

14:01.820 --> 14:04.740
就是整个一共有多少个

14:04.740 --> 14:05.900
一共有多少位

14:05.900 --> 14:07.380
一共有6位吗

14:07.380 --> 14:09.180
小数后面有多少位

14:09.180 --> 14:09.620
5位

14:09.620 --> 14:12.060
那么你只一旦这样子写了过后

14:12.060 --> 14:14.500
那么就定时的

14:14.500 --> 14:16.940
那么你一共就只能是

14:16.940 --> 14:18.220
一共就只能是6位

14:18.220 --> 14:19.140
你超过6位的话

14:19.140 --> 14:20.380
还会给你解断

14:20.380 --> 14:21.220
没有意思吗

14:21.220 --> 14:22.460
就这么个意思

14:22.460 --> 14:23.420
Decimal

14:23.420 --> 14:25.540
那么这里我们也了解一下

14:25.540 --> 14:27.580
我们目前还用不到

14:27.580 --> 14:29.220
以后我们先表的时候用

14:29.420 --> 14:30.940
表示的是字符串

14:30.940 --> 14:31.700
字符串的话

14:31.700 --> 14:33.300
它有两种类型

14:33.300 --> 14:34.140
主要有两种类型

14:34.140 --> 14:35.420
其实有三种

14:35.420 --> 14:36.100
第一种是

14:36.100 --> 14:38.180
恰是指的是固定长度

14:38.180 --> 14:39.260
n位的字符

14:39.260 --> 14:40.020
什么意思呢

14:40.020 --> 14:41.700
就是说你这一列

14:41.700 --> 14:43.420
你必须要给我站满n位

14:43.420 --> 14:45.380
比方说我如果说我恰

14:45.380 --> 14:47.820
我这里写的是恰3

14:47.820 --> 14:48.900
那么如果说你给我

14:48.900 --> 14:50.500
给了我写了一个1

14:50.500 --> 14:51.460
写了一个a

14:51.460 --> 14:52.020
不好意思

14:52.020 --> 14:54.660
后面还给我自动给你加两个空格

14:54.660 --> 14:56.380
一定要抽购三位

14:56.380 --> 14:57.860
后面会自动给你加空格

14:57.860 --> 14:59.140
原来的意思吧

14:59.140 --> 14:59.340
好

14:59.340 --> 15:01.780
那么这是定长的字符串

15:01.780 --> 15:03.140
那么这个varchia

15:03.140 --> 15:04.860
是指的是不定长的字符串

15:04.860 --> 15:05.980
最大为n

15:05.980 --> 15:08.300
那如果说你是varchia的话

15:09.660 --> 15:11.140
varchia3

15:11.140 --> 15:12.460
那么这里我们

15:12.460 --> 15:13.860
后边如果你写个a

15:13.860 --> 15:15.060
那么它长度就是a

15:15.060 --> 15:16.100
长度就是a

15:16.100 --> 15:17.220
如果说你写个b

15:17.220 --> 15:18.540
ab那么长度就是2

15:18.540 --> 15:19.220
对吧

15:19.220 --> 15:19.860
写个3

15:19.860 --> 15:20.500
c个c

15:20.500 --> 15:21.860
abc就长度就是3

15:21.860 --> 15:23.100
写个d它纯不下了

15:23.100 --> 15:23.500
对吧

15:23.500 --> 15:24.740
超过就纯不下了

15:24.740 --> 15:26.300
这是长度可变的

15:26.420 --> 15:28.540
这个东西我们用的是最多的

15:28.540 --> 15:30.420
tags是大量字符

15:30.420 --> 15:31.300
这个一般存什么呢

15:31.300 --> 15:33.020
比方说文章内容

15:33.020 --> 15:34.180
它信息量非常非常大

15:34.180 --> 15:34.540
对吧

15:34.540 --> 15:36.500
你varchia可能存不下的

15:36.500 --> 15:38.180
tags你还能存得下

15:38.180 --> 15:39.580
其实tags里面又包含了什么

15:39.580 --> 15:40.460
tally tags

15:40.460 --> 15:41.500
media tags

15:41.500 --> 15:43.020
tags还有什么

15:43.020 --> 15:43.780
longer tags

15:43.780 --> 15:44.860
这些东西就是

15:44.860 --> 15:47.820
它的数字存的字符量不一定

15:47.820 --> 15:49.420
有兴趣的话可以往上收一下

15:49.420 --> 15:51.180
那么这里我们就直接说一下

15:51.180 --> 15:52.620
大量字符我们一般就用tags

15:52.620 --> 15:54.500
比方说文章内容

15:54.540 --> 15:57.860
tags是指一个日期

15:57.860 --> 15:58.980
只有日期没有时间

15:58.980 --> 16:01.980
tags是有日期有时间

16:01.980 --> 16:03.660
哪连哪月哪日

16:03.660 --> 16:04.620
多少小时多少分

16:04.620 --> 16:06.620
多少秒多少好秒都可以记录下来

16:06.620 --> 16:08.140
tags是指记录时间

16:08.140 --> 16:09.380
不记录日期

16:09.380 --> 16:11.420
就是常见了这么一些数据内容

16:11.420 --> 16:13.180
tags里面我们存什么

16:13.180 --> 16:15.300
飞机的起飞时刻

16:15.300 --> 16:17.020
每天七点龙起飞

16:17.020 --> 16:18.740
就这么一个或者是冬公交车的

16:18.740 --> 16:20.260
就是骑士时间

16:20.260 --> 16:22.180
就可以用这种方式来存

16:22.180 --> 16:23.340
这是自断内容

16:23.340 --> 16:24.700
每一个字段它有自断名

16:24.700 --> 16:25.740
有自断类型

16:25.740 --> 16:27.140
咱们来看一下

16:27.140 --> 16:29.420
这边我们names肯定是用varchar

16:29.420 --> 16:30.980
varchar表示一个字符算

16:30.980 --> 16:32.780
名字我们用个100

16:32.780 --> 16:33.980
长度有100

16:33.980 --> 16:35.740
长度100完全够了吧

16:35.740 --> 16:37.820
全世界有没有名字超过

16:37.820 --> 16:39.100
长度超过100了

16:39.100 --> 16:39.580
应该没有

16:39.580 --> 16:40.020
对不对

16:40.020 --> 16:40.780
应该没有

16:40.780 --> 16:43.780
那么这里是长度就写好了

16:43.780 --> 16:45.100
那么后边

16:45.100 --> 16:46.820
但是这个是变长的

16:46.820 --> 16:49.620
变长的话其实也无所谓了

16:49.620 --> 16:50.540
无所谓

16:50.540 --> 16:51.380
长一点就长一点

16:51.380 --> 16:54.140
反正你写多少是多少

16:54.140 --> 16:55.380
这里边还有一个

16:55.380 --> 16:56.540
是不是now

16:56.540 --> 16:57.460
是不是now就是什么

16:57.460 --> 16:59.900
就是这一列的数据

16:59.900 --> 17:01.220
是不是必须要填

17:01.220 --> 17:03.900
比方说你姓名是不是必须要填的

17:03.900 --> 17:05.180
不填就不行

17:05.180 --> 17:05.900
对吧

17:05.900 --> 17:08.100
那么如果说你把勾选上的话

17:08.100 --> 17:09.180
就不是now勾选上的话

17:09.180 --> 17:10.140
那么它就必须要填

17:10.140 --> 17:11.540
就这么个意思

17:11.540 --> 17:12.700
非常简单吗

17:12.700 --> 17:12.940
对吧

17:12.940 --> 17:14.740
非常简单

17:14.740 --> 17:15.260
好

17:15.260 --> 17:16.140
那么这是

17:16.140 --> 17:16.980
这里我讲一个

17:16.980 --> 17:19.940
是不是now

17:19.940 --> 17:22.980
是不是now

17:23.020 --> 17:25.620
那么我们接下来继续写

17:25.620 --> 17:27.060
那么比较多不是now

17:27.060 --> 17:29.220
接下来我们连临A级

17:29.220 --> 17:30.780
连临A级我们是不是可以用数字

17:30.780 --> 17:31.220
对不对

17:31.220 --> 17:32.780
int用数字

17:32.780 --> 17:34.180
连临也不能是now

17:34.180 --> 17:35.620
也不能是now

17:35.620 --> 17:36.380
对吧

17:36.380 --> 17:37.660
好

17:37.660 --> 17:39.700
接下来我们继续

17:39.700 --> 17:42.580
这里比方我们再来一个

17:42.580 --> 17:43.860
比方说

17:43.860 --> 17:45.500
哪个啥呢

17:45.500 --> 17:46.940
哪一个

17:46.940 --> 17:47.900
连临我们看用了什么

17:47.900 --> 17:48.900
出生日期

17:48.900 --> 17:50.140
birthday

17:50.140 --> 17:52.860
其实连临和出生日期一般只存一个就行了

17:53.180 --> 17:54.380
birthday

17:54.380 --> 17:55.180
只存一个就行了

17:55.180 --> 17:57.020
连临和出生日期一般

17:57.020 --> 17:59.340
出生日期一般

17:59.340 --> 18:00.860
birthday的话我们用date

18:00.860 --> 18:01.500
date嘛

18:01.500 --> 18:03.500
用date不用time

18:03.500 --> 18:04.140
好

18:04.140 --> 18:06.020
birthday存进来也不是now

18:06.020 --> 18:07.220
也不是now

18:07.220 --> 18:07.580
好

18:07.580 --> 18:09.380
然后再来

18:09.380 --> 18:10.900
比方性别

18:10.900 --> 18:13.260
性别

18:13.260 --> 18:14.140
6

18:14.140 --> 18:15.180
我们可以用bit

18:15.180 --> 18:15.500
对吧

18:15.500 --> 18:16.260
bit

18:16.260 --> 18:17.460
这个长度就无效了

18:17.460 --> 18:19.180
这个后面的长度就无效了

18:19.180 --> 18:21.340
那么bit它也不能是now

18:21.340 --> 18:21.740
对不对

18:21.740 --> 18:23.140
我们就写了这三个列

18:23.140 --> 18:24.620
就这么简单

18:24.620 --> 18:27.300
那么这个我们其实除了写这些东西之外

18:27.300 --> 18:30.060
我们还可以写一个是默认值

18:30.060 --> 18:31.380
就是说如果说你不写的话

18:31.380 --> 18:33.100
我们能有一个默认值

18:33.100 --> 18:33.580
这个是的话

18:33.580 --> 18:34.580
我可以给它默认值

18:34.580 --> 18:35.940
你看下面是不是有默认值

18:35.940 --> 18:37.580
比方说给它写个0

18:37.580 --> 18:39.100
默认为女

18:39.100 --> 18:39.980
或者是默认为男

18:39.980 --> 18:40.980
都行

18:40.980 --> 18:42.540
那么你看

18:42.540 --> 18:44.740
这里写个默认值

18:44.740 --> 18:45.860
对吧

18:45.860 --> 18:46.060
好

18:46.060 --> 18:47.820
那么还有一个

18:47.820 --> 18:50.660
比方说这是一个学生的学号

18:50.660 --> 18:51.300
学号

18:51.340 --> 18:52.820
学号没用数字

18:52.820 --> 18:54.100
比方说没用数字

18:54.100 --> 18:56.020
still number

18:56.020 --> 18:57.020
是一个数字

18:57.020 --> 18:57.980
学号的时候

18:57.980 --> 18:59.740
我们有可能希望它自征

18:59.740 --> 19:02.260
就是我们不用你写它自动给你编排

19:02.260 --> 19:03.180
第一个学生是1

19:03.180 --> 19:03.900
第二个学生是2

19:03.900 --> 19:05.060
第三个学生是3

19:05.060 --> 19:05.580
对吧

19:05.580 --> 19:06.980
那么希望它自动编排

19:06.980 --> 19:08.020
那么就是学号

19:08.020 --> 19:08.500
那么怎么样

19:08.500 --> 19:10.060
它自动自自动编排呢

19:10.060 --> 19:11.700
这就是把这个勾选上

19:11.700 --> 19:12.500
自动递征

19:12.500 --> 19:14.860
那么这里就是

19:14.860 --> 19:16.260
这里就是自征

19:16.260 --> 19:17.500
列是可以自征的

19:17.500 --> 19:17.700
对吧

19:17.700 --> 19:19.220
是不是我们这样子就可以把

19:19.220 --> 19:20.260
一个表里边的

19:20.300 --> 19:21.580
所有列设定出来了

19:21.580 --> 19:23.340
接下来我们看一下收口预览

19:23.340 --> 19:25.140
收口预览

19:25.140 --> 19:26.540
收口里面create table

19:26.540 --> 19:27.980
创建一个表

19:27.980 --> 19:29.780
实际上我们刚才这里做的事情

19:29.780 --> 19:31.460
跟那个运行这个收口预设议

19:31.460 --> 19:32.740
效果是一样的

19:32.740 --> 19:33.940
创建个表表示

19:33.940 --> 19:35.860
表示属于这个数据库的

19:35.860 --> 19:37.740
task数据库下面的这个表

19:37.740 --> 19:38.620
名字叫这个

19:38.620 --> 19:39.860
我们现在还没个名字

19:39.860 --> 19:40.500
他说一说

19:40.500 --> 19:42.140
所以说他这里可以写个antitled

19:42.140 --> 19:44.220
表示这个表还没有命名字

19:44.220 --> 19:45.860
那么这里名字里可以改一改

19:45.860 --> 19:46.380
对吧

19:46.380 --> 19:49.060
改成student都可以

19:49.100 --> 19:50.060
比方说我们这里

19:50.060 --> 19:51.340
还不允许的改

19:51.340 --> 19:53.940
当然我们可以把它复制一下

19:53.940 --> 19:55.340
导星见察学里边

19:55.340 --> 19:56.460
我们这里手动来

19:56.460 --> 19:57.540
用收口预览写

19:57.540 --> 19:57.740
对吧

19:57.740 --> 19:58.500
刚才是用见面

19:58.500 --> 19:59.460
见面我们还没有保存

19:59.460 --> 19:59.860
对吧

19:59.860 --> 20:00.700
见面没有保存的话

20:00.700 --> 20:01.940
它是没有生效的

20:01.940 --> 20:03.700
你看这个表里边还是空的

20:03.700 --> 20:05.780
那么这里边我们给他写一个表的名字

20:05.780 --> 20:08.140
比方说student

20:08.140 --> 20:09.100
一个学生表

20:09.100 --> 20:09.900
学生的姓名

20:09.900 --> 20:12.580
你看Varchia内形

20:12.580 --> 20:13.260
not now

20:13.260 --> 20:14.140
不为空

20:14.140 --> 20:17.700
Burstatet内形不为空

20:17.700 --> 20:19.020
six bit

20:19.060 --> 20:20.900
Burstatet我们就不要255了

20:20.900 --> 20:22.060
not now

20:22.060 --> 20:22.740
不为空

20:22.740 --> 20:24.300
不认识是0

20:24.300 --> 20:25.500
你看是不是很简单

20:25.500 --> 20:25.820
对吧

20:25.820 --> 20:27.740
声明是语言是很简单的

20:27.740 --> 20:28.820
很容易读冻的

20:28.820 --> 20:29.420
student

20:29.420 --> 20:30.620
这一列的名字

20:30.620 --> 20:31.900
然后它是intel内形

20:31.900 --> 20:32.780
它可以为空

20:32.780 --> 20:33.300
对吧

20:33.300 --> 20:35.660
但是它是自动增长的

20:35.660 --> 20:37.300
自动增长

20:37.300 --> 20:38.220
没了意思吧

20:38.220 --> 20:39.900
那么这里我们运运行

20:39.900 --> 20:40.900
运行完了

20:40.900 --> 20:41.380
运行完了

20:41.380 --> 20:42.380
过来下面成功了

20:42.380 --> 20:43.900
然后对了我们点击右键刷新

20:45.660 --> 20:45.980
刷新

20:46.980 --> 20:49.740
他这里说错了

20:49.740 --> 20:51.540
他这里有错误

20:51.540 --> 20:52.700
他说什么呢

20:52.700 --> 20:54.700
b1

20:54.700 --> 20:56.220
可能

20:56.220 --> 20:57.220
it must be

20:57.220 --> 21:00.340
因为我现在还没有讲到这儿来

21:00.340 --> 21:01.460
还没有讲到这儿来

21:01.460 --> 21:02.060
他是说

21:02.060 --> 21:04.140
如果说这一列必须要自增的话

21:04.140 --> 21:05.580
他必须要作为组建

21:05.580 --> 21:06.980
你把这个建点一下

21:06.980 --> 21:09.660
组建又是什么意思呢

21:09.660 --> 21:11.700
关键是组建又是啥意思呢

21:11.700 --> 21:13.380
组建意思我们一会再说

21:13.380 --> 21:14.660
如果说你要做自增的话

21:14.860 --> 21:17.060
必须要把它做成组建

21:17.060 --> 21:18.340
student

21:18.340 --> 21:19.780
现在我们再来运行一下

21:19.780 --> 21:20.180
运行

21:23.460 --> 21:26.520
然后什么呢

21:26.520 --> 21:28.400
这里这个去掉

21:28.400 --> 21:29.400
运行

21:29.400 --> 21:30.400
ok

21:30.400 --> 21:31.120
ok了

21:31.120 --> 21:32.680
再点击右键刷新

21:32.680 --> 21:34.080
你看一下是不是有张表了

21:34.080 --> 21:34.440
student

21:34.440 --> 21:35.200
我们双击这张表

21:35.200 --> 21:36.960
你看打开是不是打开一个表格

21:36.960 --> 21:37.280
对不对

21:37.280 --> 21:37.960
打开表格

21:37.960 --> 21:39.400
这个表格里面没有任何东西

21:39.400 --> 21:41.640
当然我们可以在这里面添加一些数据

21:41.640 --> 21:42.880
那么这个数据是什么呢

21:42.880 --> 21:44.440
这个数据是记录

21:44.440 --> 21:45.520
就是一行一行的数据

21:45.560 --> 21:46.720
你看是不是有数据

21:46.720 --> 21:47.240
对不对

21:47.240 --> 21:47.840
来吧

21:47.840 --> 21:49.120
我们第一个name

21:49.120 --> 21:49.840
a

21:49.840 --> 21:50.600
birthday

21:50.600 --> 21:51.800
你看一下

21:51.800 --> 21:52.520
birthday

21:52.520 --> 21:54.400
我们随便选一个吧

21:54.400 --> 21:56.080
就选这个点确定

21:56.080 --> 21:57.240
你是不是只有个日期

21:57.240 --> 21:58.320
这个是没有默认字

21:58.320 --> 21:59.560
它自动给你填好了

21:59.560 --> 22:00.800
当你可以也可以赶

22:00.800 --> 22:01.240
对吧

22:01.240 --> 22:01.680
1

22:01.680 --> 22:02.280
开成0

22:02.280 --> 22:03.000
都可以

22:03.000 --> 22:03.680
student

22:03.680 --> 22:04.240
它是自增的

22:04.240 --> 22:05.040
我们不用管它

22:05.040 --> 22:06.200
我们直接保存

22:06.200 --> 22:07.600
康处加s保存

22:07.600 --> 22:08.400
你看student

22:08.400 --> 22:09.440
是不是可以自增了

22:09.440 --> 22:09.680
对吧

22:09.680 --> 22:10.480
保存了一个

22:10.480 --> 22:12.320
然后我们接下来再加一点

22:12.320 --> 22:14.120
我们按光标下

22:14.120 --> 22:14.920
再加一点

22:15.000 --> 22:16.000
名字为b

22:16.000 --> 22:16.400
birthday

22:16.400 --> 22:18.440
我们随便选一个

22:18.440 --> 22:19.320
点确定

22:19.320 --> 22:21.000
这个是我们唯一

22:21.000 --> 22:21.480
student

22:21.480 --> 22:22.000
不管它

22:22.000 --> 22:23.760
我们保存康处加s

22:23.760 --> 22:24.760
你看

22:24.760 --> 22:25.920
是不是它自动给你编排

22:25.920 --> 22:26.200
对吧

22:26.200 --> 22:28.240
自增的

22:28.240 --> 22:29.400
就这么个意思

22:29.400 --> 22:30.600
我们在这里设计列

22:30.600 --> 22:31.640
所以说一个表

22:31.640 --> 22:32.680
首先得有列

22:32.680 --> 22:33.880
那么你在运行的过程中

22:33.880 --> 22:35.160
能不能动态的加一点

22:35.160 --> 22:35.720
不可能的

22:35.720 --> 22:36.480
不行的

22:36.480 --> 22:37.960
所以它的结构是写实的

22:37.960 --> 22:39.560
它列的结构是写实的

22:39.560 --> 22:40.600
每一列该填啥

22:40.600 --> 22:41.720
必须要写实

22:41.720 --> 22:43.960
这是关心型数据库的特点

22:44.000 --> 22:45.080
原来是吧

22:45.080 --> 22:46.920
那么这就是不是就建立一张表了

22:46.920 --> 22:48.480
当然我们刚才是用设可语去建立的

22:48.480 --> 22:49.480
但是这里

22:49.480 --> 22:51.000
如果说你利用这种方式来建立的话

22:51.000 --> 22:52.640
一样的

22:52.640 --> 22:53.800
比方说我这里点保存

22:53.800 --> 22:55.600
它就会让你输入表的名字

22:55.600 --> 22:56.200
那么这里

22:56.200 --> 22:57.480
student2

22:57.480 --> 22:58.040
你看是不是

23:00.520 --> 23:01.560
这个c

23:01.560 --> 23:03.680
这东西也去掉

23:03.680 --> 23:04.320
保存

23:04.320 --> 23:04.920
student2

23:04.920 --> 23:05.520
点确定

23:05.520 --> 23:06.760
你看是不是多了一张表

23:06.760 --> 23:07.240
对不对

23:07.240 --> 23:08.280
当然我们肯定

23:08.280 --> 23:09.920
如果说都是一个学生的话

23:09.920 --> 23:11.080
肯定只建一张表就行了

23:11.080 --> 23:12.320
不可能去建两张学生表

23:12.320 --> 23:13.440
是同样的意思

23:13.440 --> 23:14.520
我只是举个例子

23:14.520 --> 23:17.360
就两种方式都可以去创建一张表

23:17.360 --> 23:18.280
不要例子吧

23:18.280 --> 23:18.640
OK

23:18.640 --> 23:19.960
多得表三了

23:21.960 --> 23:22.680
回到段来

23:22.680 --> 23:24.080
这是创建表

23:24.080 --> 23:25.160
是不是非常简单

23:25.160 --> 23:26.840
然后是修改表

23:26.840 --> 23:27.840
修改表的话

23:27.840 --> 23:28.680
那怎么修改呢

23:28.680 --> 23:29.640
我们

23:29.640 --> 23:30.760
可以用见面的方式修改

23:30.760 --> 23:32.320
也可以用设可语去来修改

23:32.320 --> 23:34.320
当然用见面的方式来修改的话

23:34.320 --> 23:36.360
最终都是运行设可语去

23:36.360 --> 23:38.440
比方说我们点击右键设计表

23:38.440 --> 23:39.880
所以又重新把窗口打开了

23:39.880 --> 23:40.680
那这里该改了

23:40.680 --> 23:41.320
你可以改

23:41.320 --> 23:42.840
比方说我们把这个

23:42.840 --> 23:44.560
给它加一列

23:44.560 --> 23:45.280
加一列

23:45.280 --> 23:47.200
给它加啥呢

23:47.200 --> 23:48.920
学生还有啥信息

23:48.920 --> 23:50.440
学生除了学号

23:50.440 --> 23:52.040
这里还可以调整顺序

23:52.040 --> 23:53.520
调整顺序

23:53.520 --> 23:55.360
我这个往前面拉

23:55.360 --> 23:56.120
这里上移

23:57.400 --> 23:58.560
你看是不是把调到D

23:58.560 --> 23:59.880
顺序调到D一个去了

23:59.880 --> 24:00.240
对不对

24:00.240 --> 24:01.520
我们看一下设可语句

24:01.520 --> 24:02.440
它写的什么语句

24:02.440 --> 24:03.760
autor表示修改

24:03.760 --> 24:07.120
修改table里面的修改表

24:07.120 --> 24:08.840
数据库test里面的表

24:08.840 --> 24:09.960
students

24:09.960 --> 24:10.560
怎么修改

24:10.560 --> 24:11.600
修改什么内容

24:11.600 --> 24:12.800
modify

24:12.840 --> 24:14.520
修改

24:14.520 --> 24:15.720
column

24:15.720 --> 24:18.480
修改地把这个stune number

24:18.480 --> 24:19.440
intln

24:19.440 --> 24:20.800
not now

24:20.800 --> 24:21.640
outcremies

24:21.640 --> 24:22.840
把它修改到first

24:22.840 --> 24:25.160
把修改到第一个位置

24:25.160 --> 24:26.880
就这么个意思

24:26.880 --> 24:27.160
好

24:27.160 --> 24:28.640
那么这里我们再回到

24:28.640 --> 24:30.240
回到这

24:30.240 --> 24:31.760
给它加一列吧

24:31.760 --> 24:33.280
加一列

24:33.280 --> 24:34.880
学生里边还有啥信息

24:34.880 --> 24:36.800
学生的电话号码

24:36.800 --> 24:38.200
就是我们可以用

24:38.200 --> 24:39.280
挖掐

24:39.280 --> 24:40.040
11位

24:40.040 --> 24:41.520
电话号码固定11位

24:41.520 --> 24:42.520
不是 now

24:42.520 --> 24:44.080
对吧

24:44.080 --> 24:44.960
电话号码数据

24:44.960 --> 24:46.000
电话号码不是数字

24:46.000 --> 24:47.240
你千万不能写数字

24:47.240 --> 24:48.120
怎么来判断一个东西

24:48.120 --> 24:49.600
是数字还是字无算

24:49.600 --> 24:51.440
关键是看它怎么读

24:51.440 --> 24:52.560
你把它当成数字来读

24:52.560 --> 24:53.720
它就一定是数字

24:53.720 --> 24:54.760
你把它当成字不错来读

24:54.760 --> 24:56.080
它就一定是字无算

24:56.080 --> 24:57.280
什么意思

24:57.280 --> 25:03.860
电话号码你是怎么来读的

25:03.860 --> 25:04.540
你怎么读的

25:04.540 --> 25:07.460
你是读的135453

25:07.460 --> 25:07.700
对吧

25:07.700 --> 25:08.660
你是用这种方式来读的

25:08.660 --> 25:09.220
这种方式读

25:09.220 --> 25:11.020
就是字无算的读法

25:11.020 --> 25:11.820
数字该怎么读

25:11.820 --> 25:14.300
数字该读成135亿

25:14.340 --> 25:16.060
没有人这样读电话号码

25:16.060 --> 25:19.540
135亿55553333

25:19.540 --> 25:20.940
不可能这样读电话号码

25:20.940 --> 25:22.180
所以说它一定是字无算

25:22.180 --> 25:22.940
就看你怎么去读

25:22.940 --> 25:24.740
比方身份字号

25:24.740 --> 25:25.820
字无算还是数字

25:27.100 --> 25:28.100
字无算还是数字

25:28.100 --> 25:29.340
字无算

25:29.340 --> 25:31.980
对不对

25:31.980 --> 25:33.340
学号字无算是数字

25:33.340 --> 25:35.580
字无算还是数字

25:35.580 --> 25:37.420
学号按你说的应该是字无算了

25:37.420 --> 25:38.380
知道吧

25:38.380 --> 25:39.860
学号都不应该是数字的

25:39.860 --> 25:40.540
对不对

25:40.540 --> 25:41.740
比方说你学号1011

25:41.740 --> 25:41.900
对吧

25:41.900 --> 25:43.020
应该是这样读的

25:43.100 --> 25:44.420
我这里只是演示一下

25:44.420 --> 25:45.380
演示一下之争

25:46.660 --> 25:48.180
那么这里电话号码

25:48.180 --> 25:49.140
我们看一下

25:49.140 --> 25:50.140
看下身份的社口语句

25:50.140 --> 25:52.060
你看是不是又加了一个修改

25:52.060 --> 25:53.180
添加一个列

25:53.180 --> 25:55.660
foam把这些列的信息给它写上

25:55.660 --> 25:56.100
对吧

25:56.100 --> 25:56.940
然后after

25:56.940 --> 25:58.700
在6的列之后

26:00.060 --> 26:00.740
保存一下

26:00.740 --> 26:01.660
这样子保存了过后

26:01.660 --> 26:02.020
你看一下

26:02.020 --> 26:03.140
打开这个表

26:03.140 --> 26:04.940
是不是多了一列了

26:04.940 --> 26:05.580
对不对

26:05.580 --> 26:06.780
是不是多了一列了

26:06.780 --> 26:08.180
由于它不能是now

26:08.180 --> 26:09.060
由于它不能是now

26:09.060 --> 26:09.700
我说多了一列

26:09.700 --> 26:11.300
它会自动给你填充一个孔子无存

26:12.260 --> 26:12.980
不要认识吧

26:12.980 --> 26:14.140
这就是修改的

26:14.140 --> 26:16.460
修改的社口语句里面是用的是outer

26:18.140 --> 26:19.620
然后我们再看删除表

26:19.620 --> 26:20.660
删除表的话

26:20.660 --> 26:21.300
我们这里

26:22.740 --> 26:23.380
我们这里

26:24.380 --> 26:25.580
我们这里copy一个

26:25.580 --> 26:26.700
c,c,v

26:26.700 --> 26:27.900
copy一个表

26:27.900 --> 26:28.940
然后删除表的话

26:28.940 --> 26:29.660
是右键

26:31.340 --> 26:32.420
这里点击删除

26:32.420 --> 26:33.620
删除表就可以删除了

26:33.620 --> 26:34.300
非常简单

26:35.300 --> 26:35.580
对吧

26:35.580 --> 26:36.100
就删除了

26:37.220 --> 26:38.940
那么如果说用社口语句怎么来删

26:38.940 --> 26:41.940
删除表就是同样的

26:41.940 --> 26:44.500
drop table

26:45.620 --> 26:46.700
哪个表呢

26:46.700 --> 26:48.380
你可以写全test

26:48.940 --> 26:49.940
第二什么的

26:49.940 --> 26:51.140
它这里都有提示了

26:51.140 --> 26:51.460
对吧

26:51.460 --> 26:53.140
students 是不是这样子删

26:53.140 --> 26:54.020
删除表

26:54.020 --> 26:55.460
也可以不写前面的数据库

26:55.460 --> 26:57.260
因为你现在正在用的就是这个数据库

26:57.900 --> 26:59.780
如果说你现在用的不是这个数据库的话

26:59.780 --> 27:01.380
那么为了删除表的话

27:01.380 --> 27:03.260
你要必须把数据库名字写上

27:03.260 --> 27:04.420
你现在就在用这个数据库

27:04.420 --> 27:05.460
你可以不写名字

27:05.460 --> 27:06.340
分号结束

27:07.060 --> 27:08.780
删除假2运行

27:10.580 --> 27:11.580
运行完成

27:11.580 --> 27:13.220
那么我们这里刷新一式

27:13.220 --> 27:13.940
是不是

27:13.940 --> 27:15.140
我要去丢这个删了

27:15.140 --> 27:16.460
然后我这里改一下名字吧

27:16.460 --> 27:17.260
右键从命名

27:23.140 --> 27:26.260
那么现在就是怎么来控制表

27:26.260 --> 27:26.860
管理表

27:26.860 --> 27:27.900
是不是非常简单

27:27.900 --> 27:28.220
对不对

27:29.460 --> 27:33.500
好 现在来的有难度的了

27:33.500 --> 27:34.780
这个地方注意听

27:34.780 --> 27:35.300
用云

27:36.180 --> 27:37.780
表里表有一些关键性的东西

27:38.700 --> 27:39.940
叫做主键和外键

27:39.940 --> 27:40.780
我们一个个说

27:40.820 --> 27:42.500
首先主键 主键是比较简单的

27:44.300 --> 27:44.940
好

27:44.940 --> 27:46.700
主键里边是什么意思呢

27:46.700 --> 27:48.660
就是说他每一张表

27:48.660 --> 27:51.020
他必须要让你有一列

27:51.020 --> 27:52.020
那一列呢

27:52.020 --> 27:56.900
他要能够代表每一的代表每一个纪录

27:56.900 --> 27:57.660
这是什么意思呢

27:57.660 --> 27:58.540
我给大家举个例子

27:59.260 --> 28:00.700
比方说你有一个表

28:00.700 --> 28:01.700
有一个学生表

28:01.700 --> 28:02.700
学生的姓名

28:03.780 --> 28:05.420
学生的年龄

28:05.420 --> 28:07.660
学生的出生日期

28:07.660 --> 28:08.580
如果说你这个表

28:08.580 --> 28:09.500
感觉他很合理

28:09.980 --> 28:10.660
是不是很合理

28:11.260 --> 28:13.140
那如果说你这样子设计表的话

28:13.140 --> 28:14.740
会出现一个严重的问题

28:14.740 --> 28:15.380
什么问题呢

28:16.300 --> 28:18.780
他会可能会出现两个人的名字

28:18.780 --> 28:19.980
完全一样

28:19.980 --> 28:21.660
年龄完全一样

28:21.660 --> 28:24.460
出生日期也完全一样

28:25.540 --> 28:26.740
所以有可能会出现

28:26.740 --> 28:27.700
那么到时候呢

28:27.700 --> 28:30.860
这个哪个是我要找的张三呢

28:30.860 --> 28:31.460
就搞不成了

28:31.460 --> 28:33.780
比方说我要看一下张三发布的文章

28:33.780 --> 28:35.420
是不是两个张三都有

28:35.420 --> 28:35.860
对不对

28:35.860 --> 28:37.460
是不是两个张三都有

28:37.460 --> 28:39.140
那么到底是哪一个张三发布的文章

28:39.220 --> 28:40.500
我也搞不清楚了

28:40.500 --> 28:42.420
因此他不具有伪衣性

28:42.420 --> 28:43.300
知道吧

28:43.300 --> 28:45.020
所以说我们设计表的时候

28:45.020 --> 28:47.340
每一个表都必须要有个组件

28:47.340 --> 28:49.380
虽然说你可以可以允许的没有

28:49.380 --> 28:50.940
但是我们设计的原则上面

28:50.940 --> 28:52.220
都要有一个组件

28:52.220 --> 28:53.220
都必须要有组件

28:54.220 --> 28:55.620
这个组件是什么意思呢

28:55.620 --> 28:56.740
就是说他这个列

28:56.740 --> 28:58.220
他必须要保证伪衣

28:58.220 --> 29:00.140
不可能有重复的值

29:01.340 --> 29:02.540
比方说我们可以完全

29:02.540 --> 29:05.060
可以给他增加一个什么学号

29:05.060 --> 29:05.980
对不对

29:05.980 --> 29:06.580
那么这样子呢

29:06.580 --> 29:07.660
是不是伪衣了

29:07.660 --> 29:08.660
两个张三完全一样

29:08.660 --> 29:10.220
但是学号肯定不一样了

29:10.220 --> 29:10.540
对不对

29:10.540 --> 29:12.100
是不是就完全就可以

29:12.100 --> 29:14.220
那么我们可以通过组件

29:14.220 --> 29:15.740
来找到伪衣的信息

29:16.980 --> 29:19.500
但是学号能不能真的能做组件吗

29:19.500 --> 29:21.340
我们来看一下组件必须要满足的要求

29:22.780 --> 29:23.540
第一个伪衣

29:23.540 --> 29:24.340
这是毫无疑问的

29:24.340 --> 29:25.980
比方身份证号学号

29:25.980 --> 29:26.780
这些都是伪衣的

29:26.780 --> 29:27.060
对吧

29:27.060 --> 29:29.140
电话号码这些都是伪衣的

29:29.140 --> 29:30.660
但是组件组件

29:30.660 --> 29:32.260
伪衣就能做组件吗

29:32.260 --> 29:33.620
不一定

29:33.620 --> 29:34.780
组件还要怎么样了

29:34.780 --> 29:36.980
还要不能更改

29:37.100 --> 29:38.700
学号是不是有可能会改

29:39.540 --> 29:41.220
所以有可能会改学号

29:41.220 --> 29:42.060
哪怕几率很小

29:42.060 --> 29:43.100
是不是有可能会改

29:43.100 --> 29:44.820
电话号码是不是有可能会变

29:44.820 --> 29:45.420
对吧

29:45.420 --> 29:47.380
说这个学号是不允许做组件的

29:47.380 --> 29:49.380
身份证号也是有可能会变

29:49.380 --> 29:50.460
对不对

29:50.460 --> 29:51.500
那可能几十年后变

29:51.500 --> 29:52.540
那也有可能会变

29:52.540 --> 29:55.180
组件是绝不可能变的

29:55.180 --> 29:58.060
那么这就是不适合做组件

29:58.060 --> 30:00.460
第三个特点是无业务含义

30:00.460 --> 30:02.580
就是它没有现实的意义

30:02.580 --> 30:04.700
像没有现实的意义这个组件

30:04.700 --> 30:06.420
那么这个学号是有现实意义的

30:06.460 --> 30:06.980
对吧

30:06.980 --> 30:08.420
所以说它是不能做组件

30:08.420 --> 30:09.900
为什么它要这样去设计呢

30:09.900 --> 30:12.500
最终的目的就是第一唯一不能改

30:12.500 --> 30:14.300
因为有业务含义它就有可能会改

30:15.180 --> 30:16.340
它有可能会改

30:16.340 --> 30:18.140
因为业务会变化

30:18.140 --> 30:19.100
最终是不能改

30:19.100 --> 30:19.900
为什么不能改

30:19.900 --> 30:20.980
因为它组件

30:20.980 --> 30:22.420
它的内部的存储的时候

30:22.420 --> 30:25.220
是比较特殊的存储方式

30:25.220 --> 30:27.500
如果说你能够让你随意的去

30:27.500 --> 30:28.460
当然组件它能不能改

30:28.460 --> 30:30.260
它其实在表里面也能改

30:30.260 --> 30:33.300
但是我们设计的时候是不能让它改的

30:33.940 --> 30:36.900
第一个原因是因为它有特别的存储方式

30:36.900 --> 30:37.580
特别的存储方式

30:37.580 --> 30:39.260
它会建立一个索引能够加快

30:39.260 --> 30:40.380
用组件去查到的时候

30:40.380 --> 30:41.900
能够加快数一个查找

30:41.900 --> 30:44.660
第二个是我们一旦把它一个东西

30:44.660 --> 30:45.780
作为组件的时候

30:45.780 --> 30:47.940
我们可能在我们的设计的系统里边

30:47.940 --> 30:49.420
都要以这个组件为标准

30:50.220 --> 30:50.980
我举个例子吧

30:52.220 --> 30:54.340
比方说我们有一篇文章

30:54.340 --> 30:56.380
文章的组件是1

30:56.380 --> 30:57.620
这是文章标题

30:57.620 --> 30:58.620
这是文章内容

30:59.420 --> 31:00.460
那么我们在访问

31:00.460 --> 31:01.980
有可能我们做了一个系统

31:02.020 --> 31:03.740
这个访问网页这个网页的时候

31:03.740 --> 31:04.620
比方说举个例子

31:05.460 --> 31:07.180
在访问这个网页的时候

31:08.460 --> 31:09.700
news.com

31:10.860 --> 31:11.980
news.detail

31:11.980 --> 31:13.660
我们访问文章1

31:14.540 --> 31:15.580
访问这个地址

31:15.580 --> 31:16.700
为什么这里写个1

31:16.700 --> 31:19.140
这个1就是写的是不是组件

31:19.140 --> 31:19.780
对不对

31:19.780 --> 31:21.460
访问这个访问这一篇文章

31:21.460 --> 31:22.580
访问这篇文章

31:22.580 --> 31:23.220
访问它的时候

31:23.220 --> 31:24.380
我们是不是在服务器上

31:24.380 --> 31:26.460
就可以根据这个文章的ID

31:26.460 --> 31:27.260
那么去拿到

31:27.260 --> 31:28.900
从数据库里边拿到这个文章

31:28.900 --> 31:29.780
拿到这个文章过去

31:29.780 --> 31:32.220
是把文章那种就给那个浏览器

31:32.780 --> 31:33.780
对不对

31:33.780 --> 31:35.100
那如果说主倩编了

31:35.940 --> 31:37.260
而这个地址已经被

31:37.260 --> 31:39.300
这个地址以前的一些用户

31:39.300 --> 31:40.500
发现这个篇文章不错

31:40.500 --> 31:41.500
收藏起来了

31:41.500 --> 31:42.900
那么接下来他再访问这个地址

31:42.900 --> 31:45.180
是不是文章编了

31:45.180 --> 31:46.700
文章可能变成没有文章了

31:46.700 --> 31:47.940
有可能变成另外一篇文章了

31:47.940 --> 31:48.460
对不对

31:48.460 --> 31:50.500
所以说组件我们在设计原则里边

31:50.500 --> 31:51.580
就不能有业务含义

31:51.580 --> 31:52.500
不能更改

31:52.500 --> 31:53.820
所以说像学号这些东西

31:53.820 --> 31:54.820
身份证号

31:54.820 --> 31:57.220
像手机号是都不能做组件的

31:57.220 --> 31:59.020
那么组件应该是什么

31:59.020 --> 32:00.820
组件应该是单独的一个

32:00.820 --> 32:02.700
没有任何含义的意义

32:02.700 --> 32:03.580
意义的意义

32:03.580 --> 32:06.860
我们就通常把它叫做ID编号

32:06.860 --> 32:07.780
它名字就要编号

32:07.780 --> 32:09.220
没有任何现实意义

32:09.220 --> 32:12.020
只在系统里边有意义

32:12.020 --> 32:13.980
哪怕现在有个学号感觉上

32:13.980 --> 32:15.060
跟ID一样

32:15.060 --> 32:17.380
但是它能做组件

32:17.380 --> 32:18.340
它不能

32:18.340 --> 32:18.580
对吧

32:18.580 --> 32:19.500
因为它有业务含义

32:19.500 --> 32:20.700
它有可能会发生变化

32:20.700 --> 32:21.700
那么现在你随便变

32:21.700 --> 32:22.100
无所谓

32:22.100 --> 32:23.940
我组件是不会变的

32:23.940 --> 32:24.980
到时候我找学生的时候

32:24.980 --> 32:26.660
是按照组件去找

32:26.660 --> 32:27.540
没了意思吧

32:27.540 --> 32:28.420
所以说这里

32:28.460 --> 32:30.020
我们把这个表重新设计一下

32:30.020 --> 32:32.220
我们这个学生表设计

32:33.060 --> 32:34.700
我们这里把这个Steel Number

32:34.700 --> 32:35.700
我看这个键

32:35.700 --> 32:35.940
对吧

32:35.940 --> 32:37.100
是不是键

32:37.100 --> 32:38.460
那么它这里为什么一个1呢

32:38.460 --> 32:40.100
它是这样子

32:40.100 --> 32:40.700
有可以

32:40.700 --> 32:45.700
它允许用多列的组合来做一个组件

32:45.700 --> 32:47.100
比方说Steel Number和Name

32:47.100 --> 32:49.260
那么两列的数据

32:49.260 --> 32:50.580
就是两列的数据

32:50.580 --> 32:51.780
组合起来是唯一的

32:51.780 --> 32:53.580
它也可以用作组件

32:53.580 --> 32:54.860
当然我们通常情况下

32:54.860 --> 32:55.940
都不是这样子用的

32:55.940 --> 32:57.020
点击

32:57.020 --> 32:58.380
我们这里加一点

32:58.380 --> 32:59.060
加一点

33:00.180 --> 33:01.380
我们这里点击

33:01.380 --> 33:02.180
插入字段

33:02.180 --> 33:03.580
在这里加入一级ID

33:03.580 --> 33:05.060
所以说我们设计表的时候

33:05.060 --> 33:06.260
先啥都不管

33:06.260 --> 33:07.540
先写个ID出来再说

33:07.540 --> 33:09.020
然后点击这个组件

33:09.020 --> 33:10.540
然后把它设为自动自征

33:10.540 --> 33:13.660
组件一般来说也可以把它设为自动自征

33:13.660 --> 33:15.340
这里的自动自征我就把它去掉了

33:15.340 --> 33:17.860
组件的自动增长

33:17.860 --> 33:18.580
保存

33:18.580 --> 33:19.820
那么这样子

33:19.820 --> 33:21.300
你看我们数据库里边

33:21.300 --> 33:22.860
你看是不是有组件了

33:22.860 --> 33:24.100
对不对

33:24.100 --> 33:24.820
现在就有组件了

33:24.860 --> 33:28.020
我们把ID放前面去

33:29.140 --> 33:30.260
保存

33:30.820 --> 33:34.270
但放前面放后面无所谓的

33:34.270 --> 33:37.270
这就是关于组件的设计

33:37.270 --> 33:38.750
很好理解吧

33:38.750 --> 33:40.470
这是组件

33:40.470 --> 33:41.030
我想想

33:41.030 --> 33:42.070
组件里边还有什么

33:42.070 --> 33:44.550
其实组件你不一定是数字

33:44.550 --> 33:47.230
数字的原因我们主要是为了让它自征

33:47.230 --> 33:48.510
也可以是字母串

33:49.270 --> 33:50.710
也可以是UuID

33:50.710 --> 33:52.230
知不知道什么叫UuID

33:52.230 --> 33:53.430
UuID

33:53.470 --> 33:56.150
UuID是一个很长很长的一个字母串

33:57.030 --> 33:59.830
它可以通过一些算法

33:59.830 --> 34:01.350
来生成这个字母串

34:01.350 --> 34:02.710
而且是固定长度

34:02.710 --> 34:05.550
这个字母串每一次新建的字母串

34:05.550 --> 34:07.310
都能保证全球唯一

34:07.310 --> 34:09.150
这是UuID

34:09.150 --> 34:10.510
我们看一下吧

34:10.510 --> 34:11.430
买舌口里边

34:11.430 --> 34:14.070
我们给大家看一下UuID怎么来生成

34:14.070 --> 34:15.790
我们来查询里边

34:15.790 --> 34:17.070
print

34:19.430 --> 34:20.750
好像是print

34:20.750 --> 34:22.230
print

34:22.270 --> 34:28.340
是print吗

34:28.340 --> 34:29.100
print

34:29.100 --> 34:30.300
是acle

34:30.300 --> 34:31.660
还有什么呢

34:31.660 --> 34:33.780
我突然忘了

34:33.780 --> 34:36.620
买舌口里面怎么打印了

34:36.620 --> 34:38.820
买舌口查一下

34:38.820 --> 34:40.060
好久没用过了

34:40.060 --> 34:43.180
print 两个划口号

34:43.180 --> 34:46.940
print

34:46.940 --> 34:48.260
字母串

34:48.260 --> 34:49.220
单一号

34:49.220 --> 34:50.740
单一号作为字母串

34:50.740 --> 34:53.500
刚才这个东西

34:53.500 --> 34:54.580
我刚才还说错了

34:54.580 --> 34:55.660
这个东西它不是字母串

34:55.660 --> 34:57.420
它是指的是对象

34:57.500 --> 34:59.660
里面填的是对象名称

34:59.660 --> 35:00.140
知道吧

35:00.140 --> 35:01.220
这里面填的是对象名称

35:01.220 --> 35:04.960
字母串是用单一号

35:04.960 --> 35:07.160
不是吗

35:07.160 --> 35:10.920
小细操作

35:10.920 --> 35:11.800
怎么打印

35:11.800 --> 35:13.960
我突然忘了怎么打印了

35:13.960 --> 35:15.840
打印语句

35:15.840 --> 35:17.320
是用谁那个字

35:17.320 --> 35:19.240
用谁那个字来打印

35:19.240 --> 35:21.520
只用谁那个字

35:21.520 --> 35:23.280
用这个方式来打印

35:23.280 --> 35:24.920
谁那个字我们后面还会学

35:24.920 --> 35:25.680
你看什么打印出来

35:25.680 --> 35:26.280
a

35:26.280 --> 35:27.400
上面那个a不用管

35:27.440 --> 35:28.600
一旦看不见

35:28.600 --> 35:31.600
那么这里就是我们打印一个那个

35:31.600 --> 35:34.980
悠悠ID

35:34.980 --> 35:36.420
它是个函数

35:36.420 --> 35:38.340
我们大力运行一下

35:38.340 --> 35:39.260
你看看

35:39.260 --> 35:41.500
是不是生成了每个字母串

35:41.500 --> 35:41.820
对吧

35:41.820 --> 35:42.860
所以生成的都字母串

35:42.860 --> 35:44.700
而且每一次生成都不一样的

35:44.700 --> 35:48.380
你看每一次生成都不一样的

35:48.380 --> 35:50.060
都是有差别的

35:50.060 --> 35:53.180
所以它是可以申请全球唯一的字母串

35:53.180 --> 35:54.060
一样的意思吧

35:54.060 --> 35:55.260
这是不一定

35:55.260 --> 35:56.780
就是说组件它不一定是数字

35:56.780 --> 35:58.460
只不过我们通常是数字

35:58.500 --> 36:00.900
好接下来下一个外界

36:00.900 --> 36:03.900
这个东西就得好好理解一下了

36:03.900 --> 36:04.820
它用来干嘛呢

36:04.820 --> 36:07.580
它用来是产生表关系的一个列

36:07.580 --> 36:09.980
有些表它会多一个列

36:09.980 --> 36:12.900
这个列是用来跟其他表产生关系的

36:12.900 --> 36:14.060
什么意思呢

36:14.060 --> 36:15.300
我们举个例子

36:15.300 --> 36:16.780
比方说我们的数据库里面

36:16.780 --> 36:17.820
肯定是不只一张表

36:17.820 --> 36:19.140
一用一张表的话

36:19.140 --> 36:20.940
肯定用不到关系数据库了

36:20.940 --> 36:22.540
你直接用那个非关系数据库

36:22.540 --> 36:24.100
罗斯克数据库就行了

36:24.100 --> 36:26.500
我们往往是有很多张表

36:26.500 --> 36:28.140
一个大的项目里面有多少人表

36:28.180 --> 36:28.980
有几百张表

36:28.980 --> 36:30.020
多的很

36:30.020 --> 36:33.100
那么比方说我们这里创建一个班级表

36:33.780 --> 36:34.460
ID

36:35.060 --> 36:36.060
这个ID的命名

36:36.060 --> 36:38.340
有的看不同的公司

36:38.340 --> 36:39.340
有不同的命名方式

36:39.340 --> 36:41.020
比方说有加上一个表明的

36:41.020 --> 36:42.300
比方说class ID

36:42.300 --> 36:43.580
class ID

36:43.580 --> 36:46.460
或者是CID

36:46.460 --> 36:48.980
class的第一个字母

36:48.980 --> 36:51.380
我这里习惯上直接用个ID

36:51.380 --> 36:52.940
这个那么把它作为组件

36:52.940 --> 36:54.020
自动增长

36:54.020 --> 36:55.940
班级的名称

36:56.940 --> 36:58.940
然后班级的

36:59.940 --> 37:00.940
还有啥呢

37:01.940 --> 37:03.540
班级的创建时间

37:03.540 --> 37:04.580
create date

37:04.580 --> 37:07.820
create date

37:07.820 --> 37:09.820
在数据库里面

37:09.820 --> 37:11.820
你可以使用那个

37:11.820 --> 37:13.820
小图和命名方

37:13.820 --> 37:15.420
数据库

37:15.420 --> 37:17.420
它反正不区别大摇写的

37:17.420 --> 37:20.820
也有的命名方式是通过下滑线

37:20.820 --> 37:21.820
再看自己

37:21.820 --> 37:22.820
date

37:23.820 --> 37:24.820
保存

37:24.820 --> 37:26.820
这里我们使用class

37:27.820 --> 37:28.820
班级

37:28.820 --> 37:29.820
一个学生表一个班级表

37:29.820 --> 37:30.820
对不对 有两个表了

37:30.820 --> 37:32.820
那么你想一想学生和班级是不是有关系的

37:32.820 --> 37:33.820
对不对

37:33.820 --> 37:35.820
一个学生是不是属于一个点班级

37:35.820 --> 37:36.820
那么比方说我们打开学生表

37:36.820 --> 37:38.820
我们把一个学生表里面的数据清空

37:38.820 --> 37:43.630
清空吗

37:43.630 --> 37:44.630
保存

37:44.630 --> 37:47.630
学生表我们打开这个设计表

37:47.630 --> 37:48.630
学生表里面

37:48.630 --> 37:51.630
我们怎么样知道这个学生是属于哪个班级的呢

37:51.630 --> 37:52.630
你想一想

37:52.630 --> 37:53.630
如果说我们来做这个学生的话

37:53.630 --> 37:54.630
要做列的话

37:54.630 --> 37:55.630
是不是应该少

37:55.630 --> 37:56.630
它这里现在少了一列

37:56.630 --> 37:57.630
对吧

37:57.630 --> 37:58.630
是少了一列

37:58.630 --> 38:00.630
那么应该是属于

38:01.630 --> 38:04.630
属于哪个班级

38:04.630 --> 38:05.630
对不对

38:05.630 --> 38:06.630
是属于哪个班级

38:06.630 --> 38:07.630
那么属于哪个班级

38:07.630 --> 38:08.630
应该填什么呢

38:08.630 --> 38:10.630
原来说填班级名称就行了

38:10.630 --> 38:11.630
那名称

38:11.630 --> 38:14.630
我们知道名称它不具有唯一性

38:14.630 --> 38:15.630
知道吧

38:15.630 --> 38:17.630
名称不具有唯一性

38:17.630 --> 38:19.630
那么我们填名称是肯定是不好的

38:19.630 --> 38:20.630
当然更加不可能

38:20.630 --> 38:21.630
把班级的所有信息

38:21.630 --> 38:22.630
全部一式填在这

38:22.630 --> 38:24.630
那这样子数据是不是荣余了

38:24.630 --> 38:25.630
什么叫荣余

38:25.630 --> 38:26.630
就是多了一些数据出来了

38:26.630 --> 38:28.630
明明班级表里面有一些数据

38:28.630 --> 38:29.630
班级表里面

38:29.630 --> 38:30.630
本来就有一些数据

38:30.630 --> 38:32.630
班级一

38:32.630 --> 38:36.580
时间能不能随便写一个

38:36.580 --> 38:38.580
随便写个时间

38:38.580 --> 38:39.580
班级一

38:39.580 --> 38:40.580
本来就有数据

38:40.580 --> 38:41.580
你这里又过来填一个

38:41.580 --> 38:42.580
班级一又过来填一个

38:42.580 --> 38:43.580
那到时候数据重复了

38:43.580 --> 38:44.580
过后会展现什么问题呢

38:44.580 --> 38:46.580
比方说到班级里面

38:46.580 --> 38:47.580
班级一变成班级二

38:47.580 --> 38:48.580
那里看一下

38:48.580 --> 38:49.580
这些表是不是也要跟着变

38:49.580 --> 38:51.580
那就麻烦大了

38:51.580 --> 38:52.580
知道吧

38:52.580 --> 38:53.580
所以说我们既要保持数据

38:53.580 --> 38:54.580
既不荣余

38:54.580 --> 38:55.580
不要多一个数据出来

38:55.580 --> 38:56.580
不要重复数据

38:56.580 --> 38:57.580
班级表里面记住了

38:57.580 --> 38:58.580
你就不要写了

38:58.580 --> 39:00.580
一个同时保证数据的唯一性

39:00.580 --> 39:01.580
那用什么呢

39:01.580 --> 39:02.580
是不是用组件

39:02.580 --> 39:03.580
那么这个地方

39:03.580 --> 39:04.580
我们填什么呢

39:04.580 --> 39:05.580
填班级的组件

39:05.580 --> 39:07.580
比方说张三属于班级的组件

39:07.580 --> 39:09.580
属于一这个班级

39:09.580 --> 39:10.580
那么这个张三

39:10.580 --> 39:12.580
也属于一这个班级

39:12.580 --> 39:14.580
或者是他属于二这个班级

39:14.580 --> 39:15.580
当然现在没有二

39:15.580 --> 39:17.580
那么你看一下

39:17.580 --> 39:18.580
这个张三

39:18.580 --> 39:19.580
这个学生他是不是知道

39:19.580 --> 39:20.580
我属于哪个班级了

39:20.580 --> 39:21.580
属于id为一的班级

39:21.580 --> 39:22.580
那么是不是可以通过

39:22.580 --> 39:24.580
一去找到班级表的

39:24.580 --> 39:25.580
那个记录

39:25.580 --> 39:26.580
所有信息全部在了

39:26.580 --> 39:27.580
将来有一天

39:27.580 --> 39:29.580
他把这个东西变成了班级

39:29.580 --> 39:30.580
三

39:30.580 --> 39:31.580
有影响吗

39:31.580 --> 39:32.580
是不是对这个数据

39:32.580 --> 39:33.580
没有任何影响

39:33.580 --> 39:34.580
它还是属于班级

39:34.580 --> 39:36.580
还是属于id为一的班级

39:36.580 --> 39:37.580
通过这个id

39:37.580 --> 39:38.580
因为id是组件

39:38.580 --> 39:39.580
唯一性

39:39.580 --> 39:40.580
他就可以找到这个班级

39:40.580 --> 39:41.580
没了意思吧

39:41.580 --> 39:42.580
就好比说

39:42.580 --> 39:43.580
你们以后的公司

39:43.580 --> 39:44.580
里面去用excel

39:44.580 --> 39:46.580
做一些表格的时候

39:46.580 --> 39:47.580
像一些其他表

39:47.580 --> 39:48.580
比方说

39:48.580 --> 39:49.580
我们这个月的销售成绩

39:49.580 --> 39:50.580
那么这个销售成绩

39:50.580 --> 39:51.580
它是由一个表格

39:51.580 --> 39:52.580
一行一行组成的

39:52.580 --> 39:53.580
那么这一行

39:53.580 --> 39:55.580
那么这一个销售记录

39:55.580 --> 39:56.580
这个客户

39:56.580 --> 39:57.580
是哪个销售员

39:57.580 --> 39:58.580
人员带来的

39:58.580 --> 39:59.580
那么后面写的是

39:59.580 --> 40:00.580
它的功耗

40:00.580 --> 40:01.580
对不对

40:01.580 --> 40:02.580
功耗是最准确的

40:02.580 --> 40:03.580
我们只需要写个功耗

40:03.580 --> 40:04.580
那么

40:04.580 --> 40:05.580
通过这个功耗

40:05.580 --> 40:06.580
到后面一查

40:06.580 --> 40:07.580
这就可以查到了

40:07.580 --> 40:08.580
完整的信息了

40:08.580 --> 40:09.580
对不对

40:09.580 --> 40:10.580
它就是这么一个逻辑

40:10.580 --> 40:12.580
那么像这种情况下

40:12.580 --> 40:13.580
这个玩意

40:13.580 --> 40:14.580
这一列

40:14.580 --> 40:15.580
它就叫做

40:15.580 --> 40:17.580
学生表的外界

40:17.580 --> 40:18.580
外界什么意思

40:18.580 --> 40:19.580
就是它不是

40:19.580 --> 40:20.580
我这个表的组件

40:20.580 --> 40:22.580
它是别的表的组件

40:22.580 --> 40:23.580
我列明到别的表的

40:23.580 --> 40:24.580
对吧

40:24.580 --> 40:26.580
你看像这样子写

40:26.580 --> 40:27.580
然后这里

40:27.580 --> 40:28.580
试试

40:28.580 --> 40:29.580
二

40:29.580 --> 40:30.580
三

40:30.580 --> 40:32.580
那么这边学号

40:32.580 --> 40:33.580
名字

40:33.580 --> 40:34.580
那么这里

40:34.580 --> 40:35.580
它也有可能属于一般记忆

40:35.580 --> 40:36.580
对不对

40:36.580 --> 40:38.580
那么这里就是一个外界

40:38.580 --> 40:39.580
体会一下这个意思

40:39.580 --> 40:40.580
那么我们现在在

40:40.580 --> 40:41.580
学生表里面加一个外界

40:41.580 --> 40:42.580
怎么加呢

40:42.580 --> 40:43.580
我们在这里

40:43.580 --> 40:44.580
一般外界的写法

40:44.580 --> 40:45.580
就是

40:45.580 --> 40:46.580
表的名字

40:46.580 --> 40:47.580
引入到哪一个表

40:47.580 --> 40:48.580
Class

40:48.580 --> 40:50.580
引入到Class这个表

40:50.580 --> 40:51.580
下方线

40:51.580 --> 40:52.580
或者是直接小龙风秘密

40:52.580 --> 40:53.580
或者是管它的

40:53.580 --> 40:55.580
直接这样写

40:55.580 --> 40:56.580
都行

40:56.580 --> 40:57.580
那么Class ID

40:57.580 --> 40:58.580
表示的是

40:58.580 --> 40:59.580
我这个学生

40:59.580 --> 41:01.580
它属于哪一个班级

41:01.580 --> 41:02.580
它什么类型

41:02.580 --> 41:03.580
当然类型

41:03.580 --> 41:04.580
跟它的组件类型一致

41:04.580 --> 41:05.580
对吧

41:05.580 --> 41:06.580
因为它这里边

41:06.580 --> 41:07.580
填的是什么

41:07.580 --> 41:08.580
填的是班级表的组件

41:08.580 --> 41:09.580
所以它跟组件类型一致

41:09.580 --> 41:10.580
它可以是那好

41:10.580 --> 41:11.580
也可以不是那好

41:11.580 --> 41:13.580
比方是那好的情况下

41:13.580 --> 41:14.580
就表示一个学生

41:14.580 --> 41:15.580
一个学生是可以

41:15.580 --> 41:16.580
没有班级的

41:16.580 --> 41:17.580
如果说你的系统里边

41:17.580 --> 41:18.580
学生是可以没班级的

41:18.580 --> 41:19.580
就可以围绕

41:19.580 --> 41:21.580
那如果说你的系统里边

41:21.580 --> 41:22.580
每一个学生必须要有班级

41:22.580 --> 41:23.580
那就不能围绕

41:23.580 --> 41:24.580
这个东西

41:24.580 --> 41:25.580
是看你的具体情况的

41:25.580 --> 41:26.580
知道吧

41:26.580 --> 41:27.580
那么现在是不是加了一列

41:27.580 --> 41:28.580
对不对

41:28.580 --> 41:29.580
加了一列

41:29.580 --> 41:30.580
加了一列过后还没完

41:30.580 --> 41:32.580
它只是一个普通的列

41:32.580 --> 41:33.580
它并不是一个外件

41:33.580 --> 41:34.580
它只是一个普通的列

41:34.580 --> 41:36.580
里边可以填数字

41:36.580 --> 41:37.580
那么现在怎么把它

41:37.580 --> 41:38.580
收成外件

41:38.580 --> 41:39.580
你看这里是不是一个外件

41:39.580 --> 41:40.580
对不对

41:40.580 --> 41:41.580
外件的这里边

41:41.580 --> 41:42.580
我们可以写上

41:42.580 --> 41:43.580
字段名

41:45.580 --> 41:46.580
我们这里填什么

41:46.580 --> 41:47.580
字段名

41:47.580 --> 41:48.580
哪一列是外件

41:48.580 --> 41:49.580
Class ID是外件

41:49.580 --> 41:50.580
对吧

41:50.580 --> 41:51.580
好

41:51.580 --> 41:52.580
那么这边

41:52.580 --> 41:54.580
我们这里引用的副表

41:54.580 --> 41:56.580
就是它这个外件

41:56.580 --> 41:57.580
连接到哪一个表

41:57.580 --> 41:59.580
它连接到那个班级表

41:59.580 --> 42:00.580
对不对

42:00.580 --> 42:02.580
连到班级表的哪个字段

42:02.580 --> 42:04.580
肯定是主键ID

42:04.580 --> 42:05.580
对不对

42:05.580 --> 42:06.580
我们只需要知道

42:06.580 --> 42:07.580
三个关键信息就行了

42:07.580 --> 42:08.580
就是我自己的

42:08.580 --> 42:09.580
这个表的Class ID

42:09.580 --> 42:10.580
是一个外件

42:10.580 --> 42:11.580
它连接到哪里

42:11.580 --> 42:13.580
连接到Class表的ID

42:13.580 --> 42:14.580
把这个关系告诉它

42:14.580 --> 42:15.580
那么我看一下

42:15.580 --> 42:16.580
深厚的社会语句

42:16.580 --> 42:17.580
对吧

42:17.580 --> 42:18.580
是不是看一下

42:19.580 --> 42:21.580
这个数据不用管它

42:21.580 --> 42:23.580
然后这是我们加了一列

42:23.580 --> 42:25.580
然后加一个外件

42:25.580 --> 42:26.580
ADD foreign T

42:26.580 --> 42:27.580
加一个外件

42:27.580 --> 42:28.580
加什么外件呢

42:28.580 --> 42:29.580
Class ID这个外件

42:29.580 --> 42:30.580
连到哪呢

42:30.580 --> 42:32.580
连到特色数据库里面的

42:32.580 --> 42:33.580
Class这个表的ID

42:33.580 --> 42:34.580
这一列

42:34.580 --> 42:35.580
看没

42:35.580 --> 42:36.580
就非常简单

42:36.580 --> 42:37.580
我们这里保存一下

42:37.580 --> 42:38.580
数据关联起来了

42:38.580 --> 42:39.580
对不对

42:39.580 --> 42:40.580
关联起来了

42:40.580 --> 42:41.580
好

42:41.580 --> 42:42.580
接下来

42:42.580 --> 42:43.580
我们再往学生表里面

42:43.580 --> 42:44.580
加东西的时候

42:44.580 --> 42:45.580
你看

42:45.580 --> 42:46.580
学号

42:46.580 --> 42:47.580
名字随便写

42:48.580 --> 42:49.580
这个是

42:49.580 --> 42:50.580
外件

42:50.580 --> 42:51.580
刷新

42:51.580 --> 42:52.580
这里

42:52.580 --> 42:53.580
学号

42:53.580 --> 42:55.580
名字随便写

42:55.580 --> 42:57.580
Burst

42:57.580 --> 42:58.580
随便写

42:58.580 --> 42:59.580
这个是

42:59.580 --> 43:00.580
风

43:00.580 --> 43:01.580
随便写

43:01.580 --> 43:02.580
这里Class ID

43:02.580 --> 43:03.580
你看一下

43:03.580 --> 43:04.580
是不是它让你选择

43:04.580 --> 43:05.580
班级表的ID

43:05.580 --> 43:06.580
班级表

43:06.580 --> 43:07.580
现在是不是只有一个

43:08.580 --> 43:09.580
是不是只有一个班级

43:09.580 --> 43:10.580
如果再加一个班级

43:10.580 --> 43:11.580
班级是

43:11.580 --> 43:15.500
班级是

43:17.500 --> 43:18.500
2020

43:20.500 --> 43:21.500
4月3号

43:21.500 --> 43:22.500
保存

43:22.500 --> 43:23.500
好

43:23.500 --> 43:24.500
那么这边

43:24.500 --> 43:25.500
我们去加班级的时候

43:25.500 --> 43:26.500
是不是有两个外件

43:26.500 --> 43:27.500
它这边刷新

43:28.500 --> 43:29.500
刷新

43:30.500 --> 43:31.500
我这里刷新

43:31.500 --> 43:32.500
这些也没了

43:32.500 --> 43:33.500
刷新是吧

43:33.500 --> 43:34.500
主要看班级

43:36.500 --> 43:37.500
班级里面

43:37.500 --> 43:38.500
为什么只有一个

43:39.500 --> 43:40.500
我这边

43:40.500 --> 43:41.500
保存吗

43:42.500 --> 43:43.500
保存

43:43.500 --> 43:44.500
刷新

43:44.500 --> 43:46.500
班级表

43:46.500 --> 43:47.500
我看一下

43:48.500 --> 43:50.500
它为什么只有一个

43:50.500 --> 43:52.500
我这里写个2

43:52.500 --> 43:54.500
它是这里没有反应过来吗

43:54.500 --> 43:57.870
还是我之前设置错了

43:57.870 --> 43:58.870
保存

43:59.870 --> 44:00.870
是可以的对吧

44:00.870 --> 44:01.870
可以写2的

44:01.870 --> 44:02.870
说明没问题

44:02.870 --> 44:03.870
提示没反应过来

44:03.870 --> 44:04.870
当然

44:04.870 --> 44:05.870
我们平时给它加数据的时候

44:05.870 --> 44:06.870
肯定不会用这种方式来加

44:06.870 --> 44:07.870
我们后面会学习

44:07.870 --> 44:09.870
用搜扣语句来加数据

44:09.870 --> 44:11.870
我们这里只是说一下

44:11.870 --> 44:12.870
现在因为我们还没有学习

44:12.870 --> 44:13.870
搜扣语句

44:13.870 --> 44:15.870
没有学习DML

44:15.870 --> 44:17.870
没有学习数据操控语句

44:17.870 --> 44:18.870
没有学习

44:18.870 --> 44:19.870
就是如何在里面加数据

44:19.870 --> 44:20.870
三数据

44:20.870 --> 44:21.870
没有学习这些东西

44:21.870 --> 44:22.870
所以我们只能用这种方式

44:22.870 --> 44:24.870
以后我们不会用这种方式

44:24.870 --> 44:25.870
来看写译是不是也可以

44:25.870 --> 44:26.870
对吧

44:26.870 --> 44:28.870
但是写3行不行

44:28.870 --> 44:29.870
写3

44:29.870 --> 44:30.870
保存

44:30.870 --> 44:31.870
抱错了

44:31.870 --> 44:32.870
它告诉你

44:32.870 --> 44:33.870
我把声音关了

44:33.870 --> 44:34.870
它告诉你

44:34.870 --> 44:36.870
不能添加和修改

44:36.870 --> 44:37.870
这一行

44:37.870 --> 44:38.870
为什么呢

44:38.870 --> 44:40.870
因为它不满足外界约束

44:40.870 --> 44:41.870
因为你这个3

44:41.870 --> 44:42.870
在这个班级表

44:42.870 --> 44:43.870
是不是找不到这个外界

44:43.870 --> 44:45.870
班级表没有ID尾3的班级

44:45.870 --> 44:46.870
你这个学生

44:46.870 --> 44:48.870
属于ID尾3的班级

44:48.870 --> 44:49.870
哪有ID尾3的班级

44:49.870 --> 44:50.870
没有

44:50.870 --> 44:51.870
对不对

44:51.870 --> 44:52.870
那没有

44:52.870 --> 44:53.870
那没有的话就搞不定

44:53.870 --> 44:54.870
对不对

44:54.870 --> 44:55.870
那么把它设为2

44:55.870 --> 44:56.870
好

44:56.870 --> 44:58.870
而且形成了外界约束过后

44:58.870 --> 45:00.870
你还会看到一个很有意思的现象

45:00.870 --> 45:02.870
我们现在去删除班级2的

45:02.870 --> 45:03.870
这个班级

45:03.870 --> 45:04.870
去删除它

45:04.870 --> 45:06.870
点击右键删除记录

45:07.870 --> 45:09.870
它告诉你没发生

45:09.870 --> 45:10.870
为什么没发生

45:10.870 --> 45:11.870
你想这个逻辑

45:11.870 --> 45:13.870
如果说你把这个班级3了

45:14.870 --> 45:15.870
如果说你把这个班

45:15.870 --> 45:16.870
它允许你把这个班级3了

45:16.870 --> 45:18.870
那请问这个学生怎么办

45:18.870 --> 45:19.870
你把这个学生怎么办

45:19.870 --> 45:20.870
你让这个学生

45:20.870 --> 45:21.870
是不是数据不正确了

45:21.870 --> 45:22.870
对不对

45:22.870 --> 45:23.870
那个逻辑出问题了

45:23.870 --> 45:24.870
所以它不让你删除

45:24.870 --> 45:25.870
对吧

45:25.870 --> 45:26.870
如果说在这里点右键删除不掉

45:26.870 --> 45:27.870
这个班级1就可以删除

45:27.870 --> 45:28.870
对吧

45:28.870 --> 45:29.870
班级1没有任何人用它

45:29.870 --> 45:30.870
它就可以删除

45:30.870 --> 45:31.870
对不对

45:31.870 --> 45:32.870
班级2就删除不了

45:32.870 --> 45:33.870
这些都是符合逻辑的

45:33.870 --> 45:34.870
它不是给你找麻烦

45:34.870 --> 45:35.870
它是为了避免你麻烦

45:35.870 --> 45:36.870
不然的话

45:36.870 --> 45:37.870
就随便让你删除过后

45:37.870 --> 45:38.870
这里是不是出问题了

45:38.870 --> 45:40.870
这是表关系

45:40.870 --> 45:41.870
对吧

45:41.870 --> 45:42.870
用外界来建立关系

45:42.870 --> 45:43.870
那么这里

45:43.870 --> 45:44.870
我们还可以通过这么一个东西

45:44.870 --> 45:45.870
就是点这个表

45:45.870 --> 45:46.870
这里有一个对象

45:47.870 --> 45:48.870
我们这里

45:49.870 --> 45:51.870
选择右下角的

45:51.870 --> 45:52.870
对

45:52.870 --> 45:53.870
右下角的图

45:53.870 --> 45:54.870
这个图点这

45:54.870 --> 45:55.870
看到吗

45:55.870 --> 45:56.870
点这

45:56.870 --> 45:57.870
它就可以显示出

45:57.870 --> 45:58.870
它的表之间的关系

45:58.870 --> 45:59.870
看到没

45:59.870 --> 46:00.870
表之间的关系

46:00.870 --> 46:01.870
有两个表

46:01.870 --> 46:02.870
Class是一个Students

46:02.870 --> 46:03.870
他们之间是不是有个关系

46:03.870 --> 46:04.870
你指着这个系

46:04.870 --> 46:05.870
建筒的手里看一下

46:05.870 --> 46:06.870
是不是有连接过来了

46:06.870 --> 46:07.870
Students的ClassID

46:07.870 --> 46:08.870
连接到了什么

46:08.870 --> 46:10.870
连接到了ClassID

46:10.870 --> 46:11.870
哪个是外界

46:11.870 --> 46:12.870
ClassID是外界

46:12.870 --> 46:13.870
对吧

46:13.870 --> 46:14.870
你看是不是这个

46:14.870 --> 46:15.870
一个零型

46:15.870 --> 46:16.870
对吧

46:16.870 --> 46:17.870
表示外界

46:17.870 --> 46:18.870
还给你嫉妒下来了

46:18.870 --> 46:19.870
这就是

46:19.870 --> 46:21.870
用外界来表示

46:21.870 --> 46:23.870
表育表之间的关系

46:23.870 --> 46:25.870
多了的时候

46:25.870 --> 46:26.870
外界到处都是

46:26.870 --> 46:27.870
好

46:27.870 --> 46:28.870
接下来我们来重点

46:28.870 --> 46:29.870
研究一下表关系

46:29.870 --> 46:30.870
就是说

46:30.870 --> 46:31.870
我们平时来用它的时候

46:31.870 --> 46:33.870
就设计表的时候

46:33.870 --> 46:35.870
怎么来加外界

46:35.870 --> 46:36.870
往哪里加

46:36.870 --> 46:37.870
有些人说

46:37.870 --> 46:38.870
为什么不往班级表里面加

46:38.870 --> 46:40.870
为什么要往学生表里面加

46:40.870 --> 46:41.870
到底该怎么来加

46:41.870 --> 46:42.870
这个外界

46:42.870 --> 46:43.870
好

46:43.870 --> 46:44.870
我们这里分成

46:44.870 --> 46:45.870
三种情况来说

46:45.870 --> 46:47.870
大概99%的表设计了

46:47.870 --> 46:48.870
第一个情况是

46:48.870 --> 46:49.870
一对一关系

46:49.870 --> 46:50.870
怎么要一对一关系

46:50.870 --> 46:51.870
就是一个A

46:51.870 --> 46:52.870
就是A这张表

46:52.870 --> 46:53.870
它对一个A

46:53.870 --> 46:54.870
它对应一个B

46:54.870 --> 46:56.870
一个B对应一个A

46:56.870 --> 46:57.870
一定要把这个话说完

46:57.870 --> 46:58.870
一个话说一半

46:58.870 --> 47:00.870
是不能确定关系的

47:00.870 --> 47:01.870
话说一半是

47:01.870 --> 47:02.870
绝不能确定关系的

47:02.870 --> 47:03.870
一定要把这个话说完

47:03.870 --> 47:05.870
反过来要说一次

47:05.870 --> 47:08.870
比方说用户和用户信息

47:08.870 --> 47:10.870
比方说一个用户

47:10.870 --> 47:12.870
它对应一个用户信息

47:12.870 --> 47:14.870
用户是张浩密码

47:14.870 --> 47:15.870
用户信息是什么

47:15.870 --> 47:16.870
身份人号

47:16.870 --> 47:17.870
姓名

47:17.870 --> 47:18.870
年龄

47:18.870 --> 47:21.870
一个用户是不是对应一个用户信息

47:21.870 --> 47:22.870
其中一个用户信息

47:22.870 --> 47:24.870
是不是一定属于某一个用户

47:24.870 --> 47:27.870
那么他们之间就是一对一

47:27.870 --> 47:29.870
实际上很多时候

47:29.870 --> 47:30.870
一对一关系

47:30.870 --> 47:32.870
稍微要少建一点

47:32.870 --> 47:33.870
一对一关系

47:33.870 --> 47:34.870
因为一对一关系的话

47:34.870 --> 47:36.870
往往是可以设计成一张表的

47:36.870 --> 47:37.870
对吧

47:37.870 --> 47:38.870
我们把用户和用户信息

47:38.870 --> 47:40.870
弄到一张表里面去

47:40.870 --> 47:41.870
但是有的时候

47:41.870 --> 47:43.870
为了方便管理

47:43.870 --> 47:45.870
一张表不能信息太多了

47:45.870 --> 47:47.870
比方说一些大的系统里面

47:47.870 --> 47:49.870
一个用户的信息太多太多了

47:49.870 --> 47:50.870
我们可以把它分成多张表

47:50.870 --> 47:51.870
但是他们之间关系

47:51.870 --> 47:52.870
就是一对一关系

47:52.870 --> 47:53.870
那么这种关系

47:53.870 --> 47:54.870
我们来看一下吧

47:54.870 --> 47:56.870
我们设计一下

47:56.870 --> 47:57.870
就用简单的方式

47:57.870 --> 48:00.870
这个ID逐渐

48:00.870 --> 48:04.870
然后这里是用户的账号

48:07.870 --> 48:10.870
用户的密码

48:10.870 --> 48:12.870
login password

48:12.870 --> 48:13.870
这是用户账号

48:13.870 --> 48:15.870
用户密码

48:15.870 --> 48:16.870
这是组件

48:16.870 --> 48:19.870
组件自征

48:19.870 --> 48:20.870
保存

48:20.870 --> 48:22.870
那么这是用户表

48:22.870 --> 48:24.870
还有一个用户信息表

48:24.870 --> 48:30.870
user id

48:30.870 --> 48:32.870
组件

48:32.870 --> 48:33.870
这种征兆

48:33.870 --> 48:35.870
用户信息表

48:35.870 --> 48:38.870
就是新名

48:38.870 --> 48:40.870
然后年龄

48:41.870 --> 48:42.870
还有什么

48:42.870 --> 48:43.870
性别

48:45.870 --> 48:47.870
那么就设计这几个

48:47.870 --> 48:49.870
保存这是user info

48:49.870 --> 48:51.870
那么这里是个两个表

48:51.870 --> 48:52.870
user和user info

48:52.870 --> 48:53.870
他们只如何来表示

48:53.870 --> 48:55.870
一对一关系的

48:55.870 --> 48:57.870
如何来严格的表示一对一关系

48:57.870 --> 48:58.870
就是如果说你不干的一对一关系

48:58.870 --> 48:59.870
他就给你包错

48:59.870 --> 49:00.870
怎么来表示呢

49:00.870 --> 49:01.870
他这里用

49:01.870 --> 49:02.870
一般我们球员

49:02.870 --> 49:04.870
可以用这种表示方式

49:04.870 --> 49:05.870
把任意一张表的组件

49:05.870 --> 49:07.870
同时设置为外界

49:07.870 --> 49:09.870
神奇吧

49:09.870 --> 49:10.870
一看

49:10.870 --> 49:13.870
咱们现在可以用这种方式来做

49:13.870 --> 49:15.870
其实加外界还有一种方式

49:15.870 --> 49:16.870
知道吧

49:16.870 --> 49:17.870
点这

49:17.870 --> 49:19.870
这个版本面的

49:19.870 --> 49:20.870
点这看没

49:20.870 --> 49:21.870
点这

49:21.870 --> 49:22.870
一个箭头

49:22.870 --> 49:24.870
我们从外界这一列

49:24.870 --> 49:25.870
表示我要把这个id

49:25.870 --> 49:26.870
它是组件吧

49:26.870 --> 49:27.870
对吧

49:27.870 --> 49:29.870
同时它也是个外界

49:29.870 --> 49:30.870
同时它也是个外界

49:30.870 --> 49:31.870
或者说它是组件

49:31.870 --> 49:33.870
同时它又是个外界

49:33.870 --> 49:35.870
拿过来

49:35.870 --> 49:37.870
拿到这边组件来

49:37.870 --> 49:39.870
直接保存

49:39.870 --> 49:40.870
完了

49:40.870 --> 49:41.870
对吧

49:41.870 --> 49:42.870
你看这个

49:42.870 --> 49:43.870
关键起来了

49:43.870 --> 49:45.870
这个在UserInfo里边

49:45.870 --> 49:46.870
id既是它的组件

49:46.870 --> 49:48.870
同时又是它的外界

49:48.870 --> 49:49.870
你看一下

49:49.870 --> 49:51.870
现在是什么情况

49:51.870 --> 49:52.870
一种什么情况

49:52.870 --> 49:53.870
比方我在用户里边

49:53.870 --> 49:55.870
给它加一个locking id

49:55.870 --> 49:56.870
abc

49:56.870 --> 49:57.870
locking password的

49:57.870 --> 49:58.870
123

49:58.870 --> 49:59.870
保存

49:59.870 --> 50:01.870
然后加一个bcd

50:01.870 --> 50:02.870
123

50:02.870 --> 50:03.870
保存

50:03.870 --> 50:04.870
加两个用户

50:04.870 --> 50:05.870
那么我们看一下UserInfo

50:05.870 --> 50:07.870
怎么来表示一对一关系

50:09.870 --> 50:10.870
你看

50:10.870 --> 50:12.870
现在的id

50:12.870 --> 50:14.870
这个id

50:14.870 --> 50:16.870
我们这里内面随便写个吧

50:16.870 --> 50:17.870
年年11

50:17.870 --> 50:18.870
这个11

50:18.870 --> 50:20.870
那么id我们这里写它

50:20.870 --> 50:21.870
它是组件

50:21.870 --> 50:23.870
同时它又是个外界

50:23.870 --> 50:25.870
同时它又是个外界

50:25.870 --> 50:27.870
我们这里是不是写1

50:27.870 --> 50:29.870
那你想想这个道理

50:29.870 --> 50:31.870
我这里写的是1

50:31.870 --> 50:33.870
表示我这条记录

50:33.870 --> 50:34.870
id为1

50:34.870 --> 50:36.870
同时也表示

50:36.870 --> 50:37.870
我是一个外界

50:37.870 --> 50:38.870
同时我要是不要

50:38.870 --> 50:39.870
链到User里边

50:39.870 --> 50:41.870
id为1的这个用户

50:41.870 --> 50:42.870
对吧

50:42.870 --> 50:43.870
它基本上保证了

50:43.870 --> 50:45.870
自己是不重复的

50:45.870 --> 50:47.870
自己是不重复的

50:47.870 --> 50:48.870
那么同时又保证了

50:48.870 --> 50:49.870
能够准确的读到

50:49.870 --> 50:51.870
另一张表的信息

50:51.870 --> 50:53.870
所以这个逻辑上是说得通

50:53.870 --> 50:54.870
对不对

50:54.870 --> 50:56.870
这两个是不是对应一个纪录

50:56.870 --> 50:58.870
这里如果说写的是2

50:58.870 --> 50:59.870
保存

50:59.870 --> 51:00.870
那么这条记录

51:00.870 --> 51:01.870
是不是对应到这条

51:01.870 --> 51:02.870
对不对

51:02.870 --> 51:05.870
这就是一对一关系

51:05.870 --> 51:06.870
知道吗

51:06.870 --> 51:08.870
那我这里能不能

51:08.870 --> 51:09.870
写两条数据

51:09.870 --> 51:10.870
id都为2了

51:10.870 --> 51:11.870
肯定不行

51:11.870 --> 51:12.870
肯定不行

51:12.870 --> 51:13.870
它是主件

51:13.870 --> 51:14.870
如果说我要这样做怎么办

51:14.870 --> 51:15.870
要这样做

51:15.870 --> 51:17.870
那就不是一对一关系了

51:17.870 --> 51:18.870
那说明你这个用2

51:18.870 --> 51:20.870
这个用户有两个

51:20.870 --> 51:21.870
用户信息了

51:21.870 --> 51:22.870
它就不是一对一关系了

51:22.870 --> 51:23.870
一对一关系

51:23.870 --> 51:25.870
就才能这样做

51:25.870 --> 51:26.870
一对一比

51:26.870 --> 51:27.870
要少见一点

51:27.870 --> 51:28.870
最多的时候

51:28.870 --> 51:29.870
是什么呢

51:29.870 --> 51:30.870
一对多

51:30.870 --> 51:31.870
这是我们经常

51:31.870 --> 51:33.870
到处是这种关系

51:33.870 --> 51:35.870
它是怎么关系呢

51:35.870 --> 51:36.870
读一下

51:36.870 --> 51:38.870
一个A对应多个B

51:38.870 --> 51:41.870
一个B对应一个A

51:41.870 --> 51:42.870
一定要把它说完

51:42.870 --> 51:43.870
你不说完的话

51:43.870 --> 51:44.870
你是无法确定关系的

51:44.870 --> 51:45.870
我告诉你们

51:45.870 --> 51:48.870
数据库的表一旦错了

51:48.870 --> 51:50.870
你后边的所有

51:50.870 --> 51:51.870
做的事情

51:51.870 --> 51:52.870
包括你写什么

51:52.870 --> 51:53.870
杰斯代码写

51:53.870 --> 51:54.870
打什么漏的服务器

51:54.870 --> 51:55.870
做什么view

51:55.870 --> 51:56.870
reaction

51:56.870 --> 51:57.870
全错完了

51:57.870 --> 51:59.870
就没有一个证券

51:59.870 --> 52:01.870
这个表的逻辑正确

52:01.870 --> 52:03.870
是极其重要的

52:03.870 --> 52:04.870
表错了

52:04.870 --> 52:05.870
后面全部错完了

52:05.870 --> 52:06.870
因为你的数据

52:06.870 --> 52:07.870
全部是根据这个表来的

52:07.870 --> 52:08.870
知道吧

52:08.870 --> 52:10.870
所以表示一定不能错的

52:10.870 --> 52:12.870
不能犯那么大的逻辑错误

52:12.870 --> 52:13.870
千万是不能犯的

52:13.870 --> 52:14.870
那么这样错了过

52:14.870 --> 52:15.870
你做了后来

52:15.870 --> 52:16.870
改都没法改

52:16.870 --> 52:17.870
个系统只能打翻重做

52:17.870 --> 52:18.870
基本上打翻重做了

52:18.870 --> 52:19.870
没法改了

52:19.870 --> 52:20.870
说表设计的时候

52:20.870 --> 52:21.870
一定要谨慎谨慎

52:21.870 --> 52:23.870
再谨慎

52:23.870 --> 52:24.870
怎么来确定

52:24.870 --> 52:25.870
一对多关系

52:25.870 --> 52:26.870
一定要弄完

52:26.870 --> 52:27.870
一个A对应多个B

52:27.870 --> 52:28.870
一个B对应一个A

52:28.870 --> 52:29.870
那么这个时候

52:29.870 --> 52:31.870
A和B是一对多

52:31.870 --> 52:33.870
B和A是多对一

52:33.870 --> 52:34.870
就反过来吧

52:34.870 --> 52:35.870
相对的

52:35.870 --> 52:36.870
比方说

52:36.870 --> 52:38.870
班级和学生

52:38.870 --> 52:40.870
一个班级对应多个学生

52:40.870 --> 52:42.870
一个班级里面有多个学生

52:42.870 --> 52:46.870
一个学生属于一个班级

52:46.870 --> 52:49.870
所以说班级和学生是一对多

52:49.870 --> 52:50.870
一个班级有多个学生

52:50.870 --> 52:52.870
一个学生属于一个班级

52:52.870 --> 52:54.870
拥护和文章

52:54.870 --> 52:56.870
一个拥护可以发布多篇文章

52:56.870 --> 52:59.870
一篇文章只属于一个拥护

52:59.870 --> 53:00.870
是一对多

53:00.870 --> 53:01.870
对不对

53:01.870 --> 53:04.870
这种案例到处都是

53:04.870 --> 53:05.870
到处都是

53:05.870 --> 53:07.870
对吧

53:07.870 --> 53:09.870
比方说

53:09.870 --> 53:10.870
用户和购物

53:10.870 --> 53:12.870
就是个物车和商品

53:12.870 --> 53:14.870
一个购物车

53:14.870 --> 53:16.870
一个购物车

53:16.870 --> 53:17.870
这个还不能说

53:17.870 --> 53:18.870
这个还不能这样说

53:18.870 --> 53:19.870
因为一个商品

53:19.870 --> 53:20.870
它可以出现了

53:20.870 --> 53:22.870
多个不同的用户的购物车

53:22.870 --> 53:27.180
比方说

53:27.180 --> 53:29.180
这个情况太多了

53:29.180 --> 53:30.180
老大还蒙住了

53:30.180 --> 53:32.180
比方说

53:32.180 --> 53:38.180
用户和购买的产品

53:38.180 --> 53:39.180
购买的产品

53:39.180 --> 53:40.180
不行

53:40.180 --> 53:41.180
购买的产品

53:41.180 --> 53:43.180
也可能会属于多个用户

53:43.180 --> 53:45.180
反正懂我这个意思吧

53:45.180 --> 53:46.180
我拿着举例了

53:46.180 --> 53:47.180
老大蒙住了

53:47.180 --> 53:48.180
其实这个情况是很多的

53:48.180 --> 53:49.180
我们后边

53:49.180 --> 53:51.180
会给大家举一些数据库的例子

53:51.180 --> 53:53.180
那么这种情况是最多的

53:53.180 --> 53:54.180
那么这种情况

53:54.180 --> 53:56.180
是在怎么来去设置外界

53:56.180 --> 53:58.180
是要在多的那一端的表上

53:58.180 --> 53:59.180
设置外界

53:59.180 --> 54:00.180
对应到另一张表的组件

54:00.180 --> 54:01.180
比方说

54:01.180 --> 54:03.180
班级和学生是一对多

54:03.180 --> 54:04.180
那么学生是多的那一端

54:04.180 --> 54:05.180
对不对

54:05.180 --> 54:06.180
那么在学生表

54:06.180 --> 54:08.180
设置外界

54:08.180 --> 54:09.180
看一下刚才是不是这样做的

54:09.180 --> 54:10.180
是不是在学生表

54:10.180 --> 54:11.180
设置外界

54:11.180 --> 54:12.180
而不是在班级表

54:12.180 --> 54:14.180
用户和文章是一对多

54:14.180 --> 54:15.180
那么在文章表

54:15.180 --> 54:16.180
设置外界

54:16.180 --> 54:17.180
关联到用户表

54:17.180 --> 54:18.180
表示这篇文章

54:18.180 --> 54:19.180
是哪个用户的

54:19.180 --> 54:20.180
一定要这样做

54:20.180 --> 54:21.180
为什么

54:21.180 --> 54:22.180
为什么不能反过来了

54:22.180 --> 54:23.180
你想一想

54:23.180 --> 54:25.180
反过来的逻辑都不对了

54:25.180 --> 54:27.180
一在班级表里面

54:27.180 --> 54:28.180
比方加一列

54:29.180 --> 54:30.180
班级

54:31.180 --> 54:32.180
ID

54:32.180 --> 54:34.180
班级名称

54:34.180 --> 54:35.180
然后呢

54:36.180 --> 54:37.180
创立时间不写了

54:37.180 --> 54:39.180
然后加一个学生ID

54:40.180 --> 54:42.180
你看看这个怎么弄

54:42.180 --> 54:44.180
班级是班级1

54:44.180 --> 54:46.180
学生ID是不是有多个

54:46.180 --> 54:48.180
带着这里咋写

54:48.180 --> 54:50.180
外界数字只能写一个

54:50.180 --> 54:51.180
组件是个数字

54:51.180 --> 54:52.180
它只能写一个数字

54:52.180 --> 54:54.180
怎么写

54:54.180 --> 54:55.180
没法写了

54:55.180 --> 54:56.180
有时候说它写

54:56.180 --> 54:57.180
能不能有两个学生

54:57.180 --> 54:58.180
能不能

54:59.180 --> 55:00.180
复制一下呢

55:00.180 --> 55:01.180
复制一下就不对了

55:01.180 --> 55:02.180
那组件就重复了

55:02.180 --> 55:03.180
你没法写

55:03.180 --> 55:05.180
所以只能在多的那一端

55:05.180 --> 55:07.180
去加一个外界

55:07.180 --> 55:09.180
不能在1的那一端加

55:09.180 --> 55:11.180
这是一对多

55:11.180 --> 55:14.690
还有一个多对多关系

55:14.690 --> 55:16.690
就是一个A对应多个B

55:16.690 --> 55:17.690
一个B对应多个A

55:17.690 --> 55:18.690
这是什么情况

55:18.690 --> 55:20.690
比方学生和老师

55:20.690 --> 55:21.690
或者刚才举了一个

55:21.690 --> 55:23.690
课无策的例子

55:23.690 --> 55:25.690
一个学生

55:25.690 --> 55:27.690
可以上多个老师的课

55:27.690 --> 55:28.690
你们大学里边是不是

55:28.690 --> 55:29.690
这样子

55:29.690 --> 55:31.690
有多个老师在教你们

55:31.690 --> 55:33.690
一个老师又可以上多个

55:33.690 --> 55:34.690
多个学生

55:34.690 --> 55:35.690
对不对

55:35.690 --> 55:36.690
没问题吧

55:36.690 --> 55:37.690
或者是我们购物车

55:37.690 --> 55:38.690
一个购物车里边

55:38.690 --> 55:40.690
可以有多件商品

55:40.690 --> 55:41.690
一个商品

55:41.690 --> 55:43.690
可以属于多个购物车

55:43.690 --> 55:45.690
可以被多个

55:45.690 --> 55:47.690
加到多个购物车里边去

55:47.690 --> 55:48.690
对不对

55:48.690 --> 55:51.690
这些都是属于

55:51.690 --> 55:53.690
多对多关系

55:53.690 --> 55:55.690
多对多关系怎么来处理

55:55.690 --> 55:57.690
它需要新建一张关系表

55:57.690 --> 55:59.690
关系表里边包含

55:59.690 --> 56:00.690
两个外界分别对应

56:00.690 --> 56:01.690
两张表

56:01.690 --> 56:03.690
我给大家演示一下

56:03.690 --> 56:04.690
比方说

56:04.690 --> 56:06.690
我们这里有一个

56:06.690 --> 56:08.690
ID

56:08.690 --> 56:09.690
主键

56:09.690 --> 56:10.690
字针

56:10.690 --> 56:12.690
这里是产品

56:12.690 --> 56:16.130
Product

56:16.130 --> 56:17.130
就是Name

56:17.130 --> 56:18.130
产品名称

56:18.130 --> 56:19.130
我就写个名称就行了

56:19.130 --> 56:21.130
把关系表达出来就行了

56:21.130 --> 56:22.130
这是产品

56:22.130 --> 56:23.130
再建一个表

56:23.130 --> 56:25.130
这个表是购物车

56:25.130 --> 56:28.570
购物车这是主键

56:28.570 --> 56:30.570
购物车

56:30.570 --> 56:32.570
购物车跟那个用户有

56:32.570 --> 56:33.570
是一对一关系对吧

56:33.570 --> 56:34.570
所以一对一关系

56:34.570 --> 56:35.570
我们这里就不管了

56:35.570 --> 56:37.570
购物车的话

56:37.570 --> 56:38.570
我们就是

56:38.570 --> 56:40.570
购物车的创建时间

56:40.570 --> 56:41.570
购物车的创建时间

56:41.570 --> 56:42.570
购物车的名字

56:42.570 --> 56:44.570
当然购物车一般没有什么名字

56:44.570 --> 56:45.570
我就是举个例子

56:45.570 --> 56:47.570
这是Car

56:47.570 --> 56:48.570
那么来看一下

56:48.570 --> 56:50.570
我们两张表里边加一些内容

56:50.570 --> 56:52.570
这是购物车

56:52.570 --> 56:54.570
这是S班级

56:54.570 --> 56:56.570
这是产品

56:56.570 --> 56:58.570
来我们先加一个产品

56:58.570 --> 57:00.570
小米手机

57:00.570 --> 57:02.570
这是

57:02.570 --> 57:04.570
iPhone

57:04.570 --> 57:07.570
这两个产品

57:07.570 --> 57:09.570
然后在购物车里边

57:09.570 --> 57:11.570
我们加一个

57:13.570 --> 57:15.570
成哥的购物车

57:15.570 --> 57:17.570
就举个例子

57:17.570 --> 57:19.570
就是这两张表

57:19.570 --> 57:22.880
两张表

57:24.880 --> 57:26.880
然后来一个邓哥的购物车

57:26.880 --> 57:28.880
邓哥的购物车

57:28.880 --> 57:30.880
再来一个产品

57:30.880 --> 57:32.880
再来一个产品

57:32.880 --> 57:35.880
比方说iMac

57:35.880 --> 57:37.880
比方说

57:37.880 --> 57:39.880
华为

57:39.880 --> 57:40.880
有这么一些产品

57:40.880 --> 57:41.880
那么现在的

57:41.880 --> 57:43.880
成哥可以买这些产品对吧

57:43.880 --> 57:45.880
邓哥也可以买这些产品

57:45.880 --> 57:47.880
一个产品可以被多个用户买

57:47.880 --> 57:48.880
而且一个用户

57:48.880 --> 57:49.880
可以买多个产品

57:49.880 --> 57:50.880
那怎么办

57:50.880 --> 57:51.880
没法表示关系

57:51.880 --> 57:52.880
这两个表

57:52.880 --> 57:54.880
外界往哪个表家都不对

57:54.880 --> 57:55.880
你们自己去想

57:55.880 --> 57:56.880
哪个表家都不对

57:56.880 --> 57:57.880
那应该怎么做呢

57:57.880 --> 57:58.880
应该去新建一张表

57:58.880 --> 57:59.880
只能这样做

57:59.880 --> 58:00.880
多这个关系只能这样做

58:00.880 --> 58:02.880
新建的一张表

58:02.880 --> 58:04.880
有自己的ID

58:04.880 --> 58:06.880
自己的主件

58:06.880 --> 58:07.880
然后

58:07.880 --> 58:09.880
至少有两个外界

58:09.880 --> 58:10.880
其他的信息

58:10.880 --> 58:11.880
我们都不用管

58:11.880 --> 58:13.880
至少有两个外界

58:13.880 --> 58:16.880
一个外界是卡的ID

58:16.880 --> 58:18.880
就是购物车的ID

58:18.880 --> 58:20.880
一个是

58:20.880 --> 58:22.880
产品的ID

58:22.880 --> 58:24.880
至少有这两个外界

58:24.880 --> 58:25.880
那比方说

58:25.880 --> 58:27.880
我们还可以加上一些别的信息

58:27.880 --> 58:28.880
比方说

58:28.880 --> 58:29.880
他买这些产品的时间

58:29.880 --> 58:31.880
create debt

58:31.880 --> 58:33.880
买这些产品的时间

58:33.880 --> 58:34.880
是不是可以加上

58:34.880 --> 58:35.880
对吧

58:35.880 --> 58:36.880
对

58:36.880 --> 58:37.880
我们这里

58:37.880 --> 58:38.880
可以给他一个默认字

58:38.880 --> 58:39.880
根据当年的时间处更新

58:39.880 --> 58:40.880
保存

58:40.880 --> 58:41.880
然后这里

58:41.880 --> 58:43.880
我们写上一个就是

58:43.880 --> 58:45.880
我们平时

58:45.880 --> 58:46.880
如果说不知道表名的话

58:46.880 --> 58:47.880
比方说

58:47.880 --> 58:48.880
buy

58:48.880 --> 58:49.880
购买

58:49.880 --> 58:50.880
如果说我们知道

58:50.880 --> 58:51.880
这个逻辑含义的话

58:51.880 --> 58:52.880
就可以给他写上

58:52.880 --> 58:53.880
一个有逻辑含义的表名

58:53.880 --> 58:54.880
如果说不知道

58:54.880 --> 58:55.880
有逻辑含义的话

58:55.880 --> 58:56.880
那么我们就怎么写呢

58:56.880 --> 58:57.880
就可以写

58:57.880 --> 58:59.880
car product

58:59.880 --> 59:00.880
relation

59:00.880 --> 59:01.880
表示它关系表

59:01.880 --> 59:02.880
对不对

59:02.880 --> 59:03.880
那么我们这里

59:03.880 --> 59:04.880
有逻辑含义

59:04.880 --> 59:05.880
就比方说

59:05.880 --> 59:06.880
购买表

59:06.880 --> 59:07.880
好

59:07.880 --> 59:08.880
那么现在

59:08.880 --> 59:09.880
我们怎么来

59:09.880 --> 59:10.880
设置外界关系

59:10.880 --> 59:11.880
还没有设置

59:11.880 --> 59:12.880
一个外界是卡ID

59:12.880 --> 59:13.880
我们可以用

59:13.880 --> 59:14.880
这种方式来设置

59:14.880 --> 59:15.880
对象的那种方式

59:15.880 --> 59:16.880
好

59:16.880 --> 59:17.880
拜这里

59:18.880 --> 59:19.880
这里

59:19.880 --> 59:24.300
重新

59:24.300 --> 59:25.300
这个

59:25.300 --> 59:26.300
他能不能帮我

59:26.300 --> 59:27.300
自动排吧

59:27.300 --> 59:30.640
一下呢

59:30.640 --> 59:31.640
刷新

59:32.640 --> 59:33.640
OK

59:33.640 --> 59:34.640
好

59:34.640 --> 59:35.640
那么我们来这样子

59:35.640 --> 59:36.640
你看car

59:36.640 --> 59:37.640
这是那个购物车

59:37.640 --> 59:38.640
对吧

59:38.640 --> 59:39.640
这是那个产品

59:39.640 --> 59:40.640
那么这是

59:40.640 --> 59:41.640
购买表

59:41.640 --> 59:42.640
就是关系表

59:42.640 --> 59:43.640
那么我们来

59:43.640 --> 59:44.640
怎么来设置关系

59:44.640 --> 59:45.640
首先car ID

59:45.640 --> 59:46.640
是不是连接到car的ID

59:46.640 --> 59:47.640
对吧

59:47.640 --> 59:48.640
好

59:48.640 --> 59:49.640
保存

59:50.640 --> 59:51.640
然后

59:51.640 --> 59:52.640
produx ID

59:52.640 --> 59:53.640
是连接到produx的ID

59:53.640 --> 59:54.640
对吧

59:54.640 --> 59:55.640
当然你要删除的话

59:55.640 --> 59:56.640
点击右键马上

59:56.640 --> 59:57.640
那就行了

59:57.640 --> 59:58.640
保存

59:58.640 --> 59:59.640
好

59:59.640 --> 01:00:00.640
那么现在

01:00:00.640 --> 01:00:01.640
是不是两个关系

01:00:01.640 --> 01:00:02.640
连接下来

01:00:02.640 --> 01:00:03.640
那怎么来表示购买

01:00:03.640 --> 01:00:04.640
你看

01:00:04.640 --> 01:00:05.640
到购买表里边

01:00:05.640 --> 01:00:06.640
car ID比方

01:00:06.640 --> 01:00:07.640
成歌

01:00:07.640 --> 01:00:08.640
成歌ID

01:00:08.640 --> 01:00:09.640
就是成歌的购物车

01:00:09.640 --> 01:00:10.640
ID为1

01:00:10.640 --> 01:00:11.640
对吧

01:00:11.640 --> 01:00:12.640
他买了什么

01:00:12.640 --> 01:00:13.640
买了小密手机

01:00:13.640 --> 01:00:14.640
ID为1

01:00:14.640 --> 01:00:15.640
购买的时间是多少呢

01:00:15.640 --> 01:00:16.640
购买的时间

01:00:16.640 --> 01:00:17.640
是不是

01:00:17.640 --> 01:00:18.640
然后呢

01:00:18.640 --> 01:00:19.640
下一个

01:00:22.400 --> 01:00:23.400
ID没有自征

01:00:23.400 --> 01:00:24.400
我这里

01:00:24.400 --> 01:00:25.400
ID没有设置自征

01:00:25.400 --> 01:00:28.710
ID自动征兆

01:00:28.710 --> 01:00:29.710
买了字语

01:00:29.710 --> 01:00:30.710
买了字语去写

01:00:30.710 --> 01:00:33.340
OK

01:00:33.340 --> 01:00:34.340
这里写个1

01:00:34.340 --> 01:00:35.340
没有

01:00:36.340 --> 01:00:37.340
删除

01:00:38.340 --> 01:00:39.340
这里写个1

01:00:39.340 --> 01:00:40.340
保存

01:00:40.340 --> 01:00:41.340
我们再重新打开一次

01:00:41.340 --> 01:00:42.340
拜

01:00:42.340 --> 01:00:43.340
好

01:00:43.340 --> 01:00:44.340
那一看

01:00:44.340 --> 01:00:45.340
现在是不是就

01:00:45.340 --> 01:00:46.340
描述了

01:00:46.340 --> 01:00:47.340
成歌

01:00:47.340 --> 01:00:48.340
买了小密手机

01:00:48.340 --> 01:00:49.340
对吧

01:00:49.340 --> 01:00:50.340
然后在这个时间

01:00:50.340 --> 01:00:51.340
买了小密手机

01:00:51.340 --> 01:00:52.340
不仅可以买小密手机

01:00:52.340 --> 01:00:53.340
是不是还可以买一个

01:00:53.340 --> 01:00:54.340
华为手机

01:00:54.340 --> 01:00:55.340
对吧

01:00:56.340 --> 01:00:57.340
还可以买华为手机

01:00:58.340 --> 01:00:59.340
保存

01:00:59.340 --> 01:01:00.340
是不是

01:01:00.340 --> 01:01:01.340
一个成歌

01:01:01.340 --> 01:01:02.340
可以买多个手机

01:01:02.340 --> 01:01:03.340
另外呢

01:01:03.340 --> 01:01:04.340
登歌

01:01:04.340 --> 01:01:05.340
他也可以买

01:01:05.340 --> 01:01:06.340
什么小密手机

01:01:06.340 --> 01:01:07.340
对吧

01:01:07.340 --> 01:01:08.340
一个手机

01:01:08.340 --> 01:01:09.340
可以被多个用户更买

01:01:09.340 --> 01:01:10.340
是不是逻辑上就表达清楚了

01:01:10.340 --> 01:01:11.340
虽然看上去

01:01:11.340 --> 01:01:12.340
好像不是很好看

01:01:12.340 --> 01:01:13.340
对吧

01:01:13.340 --> 01:01:14.340
不符合我们人类的直观看法

01:01:14.340 --> 01:01:15.340
但是呢

01:01:15.340 --> 01:01:16.340
逻辑是不是表达清楚了

01:01:16.340 --> 01:01:17.340
我们终究要关注他的逻辑

01:01:17.340 --> 01:01:19.340
逻辑表达清楚了过后

01:01:20.340 --> 01:01:21.340
要把他查询出来好看

01:01:21.340 --> 01:01:22.340
那个太简单了

01:01:22.340 --> 01:01:23.340
我们后边就会学

01:01:24.340 --> 01:01:25.340
我们这个表里边

01:01:25.340 --> 01:01:27.340
一定要记录这个逻辑关系

01:01:27.340 --> 01:01:29.340
这就是三种关系的表达方式

01:01:29.340 --> 01:01:30.340
这是表关系

01:01:31.340 --> 01:01:32.340
好

01:01:32.340 --> 01:01:33.340
最后

01:01:33.340 --> 01:01:34.340
大家说一下

01:01:34.340 --> 01:01:35.340
数据库的三大设计方式

01:01:35.340 --> 01:01:36.340
就是设计表的时候

01:01:36.340 --> 01:01:39.340
你应该遵循一个什么样的标准

01:01:40.340 --> 01:01:41.340
才不至于出问题

01:01:41.340 --> 01:01:42.340
至少不至于出大问题

01:01:44.340 --> 01:01:45.340
第一个标准就是

01:01:45.340 --> 01:01:47.340
他要求每数据库的每一列

01:01:47.340 --> 01:01:48.340
是不可分割的原子

01:01:49.340 --> 01:01:50.340
数据像

01:01:50.340 --> 01:01:51.340
什么意思

01:01:51.340 --> 01:01:52.340
我们把它简称为

01:01:52.340 --> 01:01:53.340
列不可分割

01:01:53.340 --> 01:01:54.340
列不可分

01:01:54.340 --> 01:01:55.340
什么意思

01:01:55.340 --> 01:01:56.340
就比方说你可能会

01:01:56.340 --> 01:01:58.340
给我设计出这么一列

01:02:00.340 --> 01:02:01.340
设计出哪一列

01:02:01.340 --> 01:02:02.340
比方说那个

01:02:02.340 --> 01:02:03.340
设计出

01:02:05.340 --> 01:02:12.690
就在这里来加一列

01:02:12.690 --> 01:02:13.690
柱子

01:02:14.690 --> 01:02:15.690
柱子

01:02:15.690 --> 01:02:16.690
那么柱子这里填啥呢

01:02:16.690 --> 01:02:17.690
填

01:02:17.690 --> 01:02:18.690
中国

01:02:18.690 --> 01:02:19.690
四川省

01:02:19.690 --> 01:02:20.690
成都市

01:02:20.690 --> 01:02:22.690
哪条街道对吧

01:02:22.690 --> 01:02:23.690
我们的柱子

01:02:23.690 --> 01:02:24.690
那么你想一想

01:02:24.690 --> 01:02:25.690
这样的柱子是

01:02:25.690 --> 01:02:26.690
能不能进行分割

01:02:27.690 --> 01:02:28.690
能不能进行分割

01:02:29.690 --> 01:02:31.690
假如我们的界面上

01:02:31.690 --> 01:02:33.690
国家有一个下达列表

01:02:33.690 --> 01:02:35.690
省分有一个下达列表

01:02:35.690 --> 01:02:36.690
城市有一个下达列表

01:02:36.690 --> 01:02:37.690
那么你想一想

01:02:37.690 --> 01:02:38.690
逻辑上是不是可以分开的

01:02:38.690 --> 01:02:40.690
逻辑上是可以分开的

01:02:40.690 --> 01:02:41.690
你是不是把柔带一列去了

01:02:41.690 --> 01:02:42.690
这就叫做

01:02:42.690 --> 01:02:43.690
列可分

01:02:43.690 --> 01:02:45.690
列可分是不符合

01:02:45.690 --> 01:02:46.690
第一方式的

01:02:46.690 --> 01:02:47.690
没有意思吧

01:02:48.690 --> 01:02:49.690
当然这个要看

01:02:49.690 --> 01:02:50.690
具体情况

01:02:50.690 --> 01:02:51.690
如果说你的页面上

01:02:51.690 --> 01:02:52.690
文文框框

01:02:52.690 --> 01:02:54.690
我们就懒得去分了

01:02:54.690 --> 01:02:55.690
就直接给他一个文文框框

01:02:55.690 --> 01:02:56.690
让他填自己柱子

01:02:56.690 --> 01:02:57.690
他爱填啥填啥

01:02:57.690 --> 01:02:58.690
我们不管他

01:02:58.690 --> 01:02:59.690
不去限制他

01:02:59.690 --> 01:03:00.690
也不让他选

01:03:00.690 --> 01:03:01.690
那么这个地方

01:03:01.690 --> 01:03:02.690
我们就认为柱子

01:03:02.690 --> 01:03:03.690
是不可分割的

01:03:03.690 --> 01:03:04.690
看具体情况

01:03:04.690 --> 01:03:05.690
比方说

01:03:05.690 --> 01:03:06.690
但是有些严重的

01:03:06.690 --> 01:03:07.690
你不要犯

01:03:07.690 --> 01:03:08.690
比方说你学校和

01:03:08.690 --> 01:03:09.690
姓名连在一起一起

01:03:09.690 --> 01:03:10.690
那这个时候

01:03:10.690 --> 01:03:11.690
严重的错误

01:03:11.690 --> 01:03:12.690
是不能犯的

01:03:12.690 --> 01:03:13.690
一定要保证

01:03:13.690 --> 01:03:14.690
列是不能再分割的

01:03:14.690 --> 01:03:15.690
它有原之性

01:03:16.690 --> 01:03:17.690
第二是

01:03:17.690 --> 01:03:19.690
非主建列必须依赖

01:03:19.690 --> 01:03:20.690
主建列

01:03:20.690 --> 01:03:22.690
比方说你在学生表里面

01:03:22.690 --> 01:03:24.690
给我整出来这么一个玩意

01:03:24.690 --> 01:03:26.690
整出来一个

01:03:26.690 --> 01:03:27.690
这个

01:03:27.690 --> 01:03:28.690
比方说

01:03:28.690 --> 01:03:29.690
我举个例子

01:03:32.690 --> 01:03:36.320
广告名称

01:03:36.320 --> 01:03:37.320
是不是这一列

01:03:37.320 --> 01:03:42.780
它的信息就完全跟这个

01:03:42.780 --> 01:03:43.780
跟这个组建

01:03:43.780 --> 01:03:44.780
跟这个组建ID

01:03:44.780 --> 01:03:45.780
没有任何关系

01:03:45.780 --> 01:03:46.780
就是我们

01:03:46.780 --> 01:03:47.780
比方说我们网站上

01:03:47.780 --> 01:03:48.780
要打一些广告

01:03:48.780 --> 01:03:49.780
跟学生有什么关系

01:03:49.780 --> 01:03:50.780
没有什么关系

01:03:50.780 --> 01:03:52.780
那么你为什么要去依赖

01:03:52.780 --> 01:03:53.780
这个网站

01:03:53.780 --> 01:03:54.780
对不对

01:03:54.780 --> 01:03:55.780
那么你为什么要去依赖

01:03:55.780 --> 01:03:56.780
这个组建

01:03:56.780 --> 01:03:57.780
通过这个组建去找

01:03:57.780 --> 01:03:58.780
这个东西有什么意义

01:03:58.780 --> 01:03:59.780
对不对

01:03:59.780 --> 01:04:00.780
所以说

01:04:00.780 --> 01:04:01.780
第二方是

01:04:01.780 --> 01:04:03.780
不能有这个错误

01:04:03.780 --> 01:04:04.780
第三个方式是

01:04:04.780 --> 01:04:07.780
非主建列必须直接依赖

01:04:07.780 --> 01:04:08.780
主建列

01:04:08.780 --> 01:04:09.780
第二列是必须要依赖

01:04:09.780 --> 01:04:10.780
第三个是必须要直接依赖

01:04:10.780 --> 01:04:11.780
什么意思呢

01:04:11.780 --> 01:04:12.780
就比方说

01:04:12.780 --> 01:04:13.780
我们这里

01:04:13.780 --> 01:04:14.780
广告没有

01:04:14.780 --> 01:04:16.780
没有就是关系

01:04:16.780 --> 01:04:17.780
那这个班级名称

01:04:17.780 --> 01:04:18.780
是不是有关系

01:04:18.780 --> 01:04:19.780
这个学生属于哪个班级的

01:04:19.780 --> 01:04:20.780
是不是有关系

01:04:20.780 --> 01:04:21.780
对吧

01:04:21.780 --> 01:04:22.780
那这样子写行不行

01:04:22.780 --> 01:04:24.780
这样子写不满足第三方式

01:04:24.780 --> 01:04:26.780
为什么

01:04:26.780 --> 01:04:28.780
因为这个班级名称

01:04:28.780 --> 01:04:29.780
他直接依赖的是谁

01:04:29.780 --> 01:04:31.780
是班级表的主建

01:04:31.780 --> 01:04:32.780
对吧

01:04:32.780 --> 01:04:33.780
他直接依赖的

01:04:33.780 --> 01:04:34.780
不是学生表

01:04:34.780 --> 01:04:35.780
对不对

01:04:35.780 --> 01:04:36.780
他跟学生表是间接的关系

01:04:36.780 --> 01:04:37.780
比方说你学生

01:04:37.780 --> 01:04:38.780
学生这里应该是

01:04:38.780 --> 01:04:39.780
有个班级ID对不对

01:04:39.780 --> 01:04:41.780
所以应该有个班级ID

01:04:41.780 --> 01:04:42.780
班级ID为1

01:04:42.780 --> 01:04:43.780
那么他依赖的是

01:04:43.780 --> 01:04:44.780
一个间接关系

01:04:44.780 --> 01:04:45.780
依赖的是什么呢

01:04:45.780 --> 01:04:46.780
根据学生ID

01:04:46.780 --> 01:04:47.780
找到这个班级ID

01:04:47.780 --> 01:04:48.780
通过一个班级ID

01:04:48.780 --> 01:04:49.780
再去找到学生

01:04:49.780 --> 01:04:51.780
才是依赖这个班级名称

01:04:51.780 --> 01:04:52.780
班级名称一代的是他

01:04:52.780 --> 01:04:53.780
所以这种的是

01:04:53.780 --> 01:04:55.780
不满足第三方式的

01:04:55.780 --> 01:04:56.780
这是三个方式

01:04:56.780 --> 01:04:58.780
了解一下

01:04:58.780 --> 01:04:59.780
就是反正你们以后

01:04:59.780 --> 01:05:01.780
在前端的开发里面

01:05:01.780 --> 01:05:02.780
你们设计的数据

01:05:02.780 --> 01:05:03.780
肯定不会复杂

01:05:03.780 --> 01:05:04.780
复杂的数据

01:05:04.780 --> 01:05:06.780
肯定不会到里面去设计的

01:05:06.780 --> 01:05:07.780
简单的数据

01:05:07.780 --> 01:05:10.780
你要大概就基本的原则

01:05:10.780 --> 01:05:11.780
是什么

01:05:11.780 --> 01:05:12.780
另外就是说

01:05:12.780 --> 01:05:13.780
你们在设计数据

01:05:13.780 --> 01:05:14.780
或者时候

01:05:14.780 --> 01:05:15.780
尽量的避免

01:05:15.780 --> 01:05:16.780
数据荣誉

01:05:16.780 --> 01:05:17.780
尽量的避免一下

01:05:17.780 --> 01:05:18.780
有的时候

01:05:18.780 --> 01:05:19.780
数据荣誉

01:05:19.780 --> 01:05:20.780
也不一定是坏手

01:05:20.780 --> 01:05:21.780
尽量避免吧

01:05:21.780 --> 01:05:23.780
比较多这个年龄和出生日期

01:05:23.780 --> 01:05:25.780
是不是荣誉了

01:05:25.780 --> 01:05:26.780
你设置到出生日期

01:05:26.780 --> 01:05:28.780
不就有制造年龄了吗

01:05:28.780 --> 01:05:30.780
那么荣誉的会有什么坏处呢

01:05:30.780 --> 01:05:32.780
会有什么坏处呢

01:05:32.780 --> 01:05:34.780
你万一出生日期改了

01:05:34.780 --> 01:05:35.780
你如果说

01:05:35.780 --> 01:05:36.780
用户把出生日期改了

01:05:36.780 --> 01:05:38.780
你年龄是不是也得跟着改

01:05:38.780 --> 01:05:39.780
你得写一段代码

01:05:39.780 --> 01:05:40.780
自动地去更改年龄

01:05:40.780 --> 01:05:41.780
对吧

01:05:41.780 --> 01:05:43.780
所以说带来维护上的困难

01:05:43.780 --> 01:05:44.780
数据重复了

01:05:44.780 --> 01:05:46.780
有含义的重复

01:05:46.780 --> 01:05:47.780
它有没有好处呢

01:05:47.780 --> 01:05:48.780
肯定有好处

01:05:48.780 --> 01:05:49.780
好处什么呢

01:05:49.780 --> 01:05:50.780
就读

01:05:50.780 --> 01:05:51.780
我要算年龄的时候

01:05:51.780 --> 01:05:52.780
不用去算了

01:05:52.780 --> 01:05:53.780
直接读就读出来了

01:05:53.780 --> 01:05:54.780
这是数据荣誉的好处

01:05:54.780 --> 01:05:55.780
就有的时候

01:05:55.780 --> 01:05:57.780
我们为了读的方便

01:05:57.780 --> 01:05:59.780
往往会招一些数据荣誉出来

01:05:59.780 --> 01:06:00.780
就是数据荣誉

01:06:00.780 --> 01:06:02.780
它对我们读是很方便的

01:06:02.780 --> 01:06:03.780
但我们对我们写

01:06:03.780 --> 01:06:04.780
是要严格控制的

01:06:04.780 --> 01:06:05.780
它有好处

01:06:05.780 --> 01:06:06.780
有好处也有坏处

01:06:06.780 --> 01:06:07.780
它不在三个方式里边

01:06:07.780 --> 01:06:08.780
我给大家说一下

01:06:08.780 --> 01:06:09.780
尽量的

01:06:09.780 --> 01:06:10.780
尽量的

01:06:10.780 --> 01:06:11.780
没有必要的数据荣誉

01:06:11.780 --> 01:06:13.780
我们尽量的把它规避掉

01:06:13.780 --> 01:06:14.780
好吧

01:06:14.780 --> 01:06:15.780
这是关于这个

01:06:15.780 --> 01:06:16.780
数据库的设计

01:06:16.780 --> 01:06:17.780
那种比较多是吧

01:06:17.780 --> 01:06:18.780
好去梳理一下

01:06:18.780 --> 01:06:19.780
好去体验一下

01:06:19.780 --> 01:06:20.780
特别是如何去设置

01:06:20.780 --> 01:06:21.780
主件和外件

01:06:21.780 --> 01:06:23.780
特别是外件

01:06:23.780 --> 01:06:25.780
那么外件怎么设置

01:06:25.780 --> 01:06:27.780
根据这三种情况去设置

01:06:27.780 --> 01:06:28.780
好

01:06:28.780 --> 01:06:29.780
OK

01:06:29.780 --> 01:06:30.780
那这里是咱们的

01:06:30.780 --> 01:06:32.780
数据库的设计

