WEBVTT

00:01.200 --> 00:04.200
好 咱们进入第三章

00:04.200 --> 00:07.200
上一章中我们学了数据库 对吧

00:07.200 --> 00:09.200
学了马斯克的数据库

00:09.200 --> 00:11.200
我们不过是在数据库里边

00:11.200 --> 00:13.200
用了一个工具叫LeviCAD

00:13.200 --> 00:15.200
对它进行管理

00:15.200 --> 00:17.200
而实际上我们更多的时候

00:17.200 --> 00:20.200
需要在程序里面对数据库进行管理

00:20.200 --> 00:22.200
比方说我们之前不是学到逗的核心里

00:22.200 --> 00:24.200
不是学到搭一个服务器吗

00:24.200 --> 00:25.200
一个请求过来了

00:25.200 --> 00:26.200
我们这个时候

00:26.200 --> 00:29.200
比方说用户他给我发了一个请求地址

00:29.200 --> 00:32.200
我要去给他一些电影数据

00:32.200 --> 00:34.200
或者是我们的员工数据

00:34.200 --> 00:36.200
那么这个时候我们需要在程序里边

00:36.200 --> 00:38.200
对数据库进行操作

00:38.200 --> 00:40.200
比方说把数据库的数据取出来

00:40.200 --> 00:42.200
或者是给数据库加条数据

00:42.200 --> 00:44.200
那么如何在程序里面搞定的

00:44.200 --> 00:46.200
就是我们第三章的内容

00:46.200 --> 00:47.200
我们第三个学习的是

00:47.200 --> 00:50.200
叫做数据驱动和ORM

00:50.200 --> 00:52.200
那么这是两个东西

00:52.200 --> 00:54.200
这两个东西他们分别是啥呢

00:54.200 --> 00:56.200
我们在学习的过程中

00:56.200 --> 00:58.200
就一步一步来解释

00:58.200 --> 00:59.200
第一章我们地解课

00:59.200 --> 01:01.200
首先学习的买社会的驱动程序

01:01.200 --> 01:04.200
首先认识一下什么叫做驱动程序

01:04.200 --> 01:06.200
其实驱动程序特别简单

01:06.200 --> 01:09.200
你们平时就算不学习咱们的开发课程

01:09.200 --> 01:10.200
你们也知道

01:10.200 --> 01:12.200
驱动程序是啥呢

01:12.200 --> 01:14.200
你看你按一个什么

01:14.200 --> 01:18.200
早些时候按一个什么外接的鼠标

01:18.200 --> 01:19.200
对不对

01:19.200 --> 01:20.200
按一个鼠标驱动程序

01:20.200 --> 01:21.200
或者是你重装系统之后

01:21.200 --> 01:22.200
安装一些驱动程序

01:22.200 --> 01:24.200
什么叫驱动程序呢

01:24.200 --> 01:26.200
驱动程序是连接内存

01:26.200 --> 01:29.200
和其他存处介绍的调量

01:29.200 --> 01:31.200
比方说你搞了一个外设

01:31.200 --> 01:32.200
比方说你们搞了一个

01:32.200 --> 01:34.200
现在不是流行玩游戏的

01:34.200 --> 01:36.200
都是叫做那个啥

01:36.200 --> 01:37.200
啥键盘

01:37.200 --> 01:38.200
机械键盘对吧

01:38.200 --> 01:40.200
那么机械键盘要很好的运作

01:40.200 --> 01:42.200
就需要安装它的驱动程序

01:42.200 --> 01:44.200
比方说我用的这个逻辑鼠标

01:44.200 --> 01:45.200
这个逻辑鼠标

01:45.200 --> 01:46.200
它也需要安装驱动程序

01:46.200 --> 01:47.200
才能很好的运作

01:47.200 --> 01:48.200
你看这些设备

01:48.200 --> 01:50.200
他们是不是外部设备

01:50.200 --> 01:51.200
因为我们计算机能

01:51.200 --> 01:53.200
实际上真正运行的时候

01:53.200 --> 01:55.200
核心是CPU和内存

01:55.200 --> 01:56.200
其他的设备

01:56.200 --> 01:58.200
它要跟内存来打交道

01:58.200 --> 02:00.200
渐渐地把它的东西

02:00.200 --> 02:01.200
放到内存里边

02:01.200 --> 02:02.200
它就需要一个驱动程序

02:02.200 --> 02:04.200
这个驱动程序的主要的目的

02:04.200 --> 02:06.200
就是连接这个设备和内存之间

02:06.200 --> 02:08.200
这么一个操作

02:08.200 --> 02:09.200
就这么一个意思

02:09.200 --> 02:10.200
就是驱动程序

02:10.200 --> 02:11.200
那么麦斯后的驱动程序

02:11.200 --> 02:12.200
是什么意思呢

02:12.200 --> 02:13.200
因为我们的数据库

02:13.200 --> 02:15.200
它存在硬盘上的

02:15.200 --> 02:16.200
而且是一个

02:16.200 --> 02:18.200
非常非常特别的一些文件

02:18.200 --> 02:20.200
这些文件是数据库创建的

02:20.200 --> 02:21.200
它来进行管理

02:21.200 --> 02:22.200
我们都没有看过

02:22.200 --> 02:23.200
这些文件对吧

02:23.200 --> 02:24.200
没关系

02:24.200 --> 02:25.200
我们只需要知道

02:25.200 --> 02:27.200
它在内部是这么一些文件就行了

02:27.200 --> 02:29.200
这些文件是用数据库的

02:29.200 --> 02:31.200
驱动程序来进行管理的

02:31.200 --> 02:33.200
那么麦斯后的驱动程序就是

02:33.200 --> 02:36.200
连接内存数据和麦斯后数据的调量

02:36.200 --> 02:37.200
不然的话

02:37.200 --> 02:38.200
我们的搜口语句

02:38.200 --> 02:40.200
它怎么把数据读到内存呢

02:40.200 --> 02:41.200
对不对

02:41.200 --> 02:42.200
这就是需要一个

02:42.200 --> 02:43.200
麦斯后的驱动程序

02:43.200 --> 02:44.200
那么麦斯后驱动程序

02:44.200 --> 02:46.200
它是为了

02:46.200 --> 02:48.200
它是为不同的语言

02:48.200 --> 02:49.200
都准备了

02:49.200 --> 02:51.200
不同的驱动程序包

02:51.200 --> 02:53.200
比方说我们的

02:53.200 --> 02:54.200
JS

02:54.200 --> 02:55.200
NoteJS

02:55.200 --> 02:56.200
它也为NoteJS

02:56.200 --> 02:57.200
准备了一个驱动程序包

02:57.200 --> 02:58.200
那么你需要用

02:58.200 --> 03:00.200
NoteJS去操作数据库的话

03:00.200 --> 03:02.200
你就需要用到这个驱动程序包

03:02.200 --> 03:04.200
那么在我们Note里边

03:04.200 --> 03:05.200
使用的驱动程序

03:05.200 --> 03:06.200
通常有两个

03:06.200 --> 03:07.200
一个是麦斯后

03:07.200 --> 03:09.200
这是官方的驱动程序

03:09.200 --> 03:10.200
一个是麦斯后2

03:10.200 --> 03:12.200
这是一个第三方的驱动程序

03:12.200 --> 03:14.200
那么我们到底使用哪一个呢

03:14.200 --> 03:16.200
我比较推荐使用这个麦斯后2

03:16.200 --> 03:19.200
因为它的优化做得比较好

03:19.200 --> 03:21.200
一是运行效率比较高

03:22.200 --> 03:24.200
二是官方的

03:24.200 --> 03:26.200
有些东西确实不是那么好用

03:26.200 --> 03:28.200
不过这两个东西

03:28.200 --> 03:29.200
其实都差不多

03:29.200 --> 03:31.200
它们的接口基本上是一样的

03:31.200 --> 03:33.200
这两个东西的接口基本上是一样的

03:33.200 --> 03:34.200
所以说

03:34.200 --> 03:35.200
之前还有点不一样

03:35.200 --> 03:37.200
之前的麦斯后2

03:37.200 --> 03:39.200
它的前身叫做

03:39.200 --> 03:41.200
麦斯后Native

03:42.200 --> 03:44.200
不过现在把它变成

03:44.200 --> 03:45.200
麦斯后2了

03:45.200 --> 03:47.200
它现在跟麦斯后的团队

03:47.200 --> 03:49.200
有紧密的合作

03:49.200 --> 03:51.200
两者的接口基本上是一样的

03:51.200 --> 03:53.200
所以说你学习任何一个

03:53.200 --> 03:54.200
然后再去用另一个

03:54.200 --> 03:56.200
基本上是没有什么差异的

03:56.200 --> 03:57.200
所以说我们

03:57.200 --> 03:59.200
这里为了提高更好的效率

03:59.200 --> 04:01.200
所以说我们使用的是麦斯后2

04:01.200 --> 04:02.200
这是咱们这个

04:02.200 --> 04:04.200
那么麦斯后2怎么来使用呢

04:04.200 --> 04:05.200
就是咱们这里可以学习的

04:05.200 --> 04:07.200
咱们点开看

04:07.200 --> 04:09.200
看到官方文的

04:09.200 --> 04:11.200
其实它说的已经很清楚了

04:11.200 --> 04:14.200
它用起来基本使用也非常非常简单

04:14.200 --> 04:16.200
这个网税有点慢

04:16.200 --> 04:18.200
我们首先安装吧

04:18.200 --> 04:19.200
让它打开

04:19.200 --> 04:21.200
我们首先安装

04:21.200 --> 04:25.410
这里我们打开这个控制台

04:25.410 --> 04:27.410
这里已经有一个了

04:27.410 --> 04:29.410
然后我们这里先安装

04:29.410 --> 04:31.410
NPNI

04:31.410 --> 04:34.410
安装就是开发依赖

04:34.410 --> 04:35.410
就是普通依赖

04:35.410 --> 04:38.410
然后安装这个麦斯后2

04:38.410 --> 04:39.410
好 让它安装

04:39.410 --> 04:40.410
我们看一下打开没有

04:40.410 --> 04:41.410
好 打开了

04:41.410 --> 04:43.410
然后这里的github上面

04:43.410 --> 04:44.410
有它的说明稳当

04:44.410 --> 04:45.410
特别特别简单

04:45.410 --> 04:46.410
首先你安装

04:46.410 --> 04:47.410
麦斯后2

04:47.410 --> 04:48.410
安装之后

04:48.410 --> 04:49.410
当然我们之前

04:49.410 --> 04:51.410
在load里都还没有安装过

04:51.410 --> 04:52.410
第三方程序

04:52.410 --> 04:54.410
那么现在我们可以使用NPNI去安装

04:54.410 --> 04:55.410
一些第三方程序

04:55.410 --> 04:57.410
我这里还有个

04:57.410 --> 04:59.410
没问题

04:59.410 --> 05:00.410
没问题

05:00.410 --> 05:02.850
安装好了

05:02.850 --> 05:03.850
安装到哪儿去了呢

05:03.850 --> 05:05.850
我这里刷新一下

05:05.850 --> 05:07.850
出来了 安装好了

05:07.850 --> 05:09.850
看一下怎么来用

05:09.850 --> 05:11.850
其实它说的特别简单了

05:11.850 --> 05:12.850
第一个首先你导入

05:12.850 --> 05:13.850
导入这个包

05:13.850 --> 05:14.850
麦斯后2

05:14.850 --> 05:15.850
我们把它复制过来

05:15.850 --> 05:16.850
复制过来再解释

05:16.850 --> 05:20.380
到这个里面

05:20.380 --> 05:21.380
我们新建个文件

05:21.380 --> 05:24.380
就这个index的介绍

05:24.380 --> 05:25.380
张天过来

05:26.380 --> 05:27.380
看一下

05:27.380 --> 05:29.380
首先导入这个麦斯后2这个包

05:29.380 --> 05:30.380
那么它导入进来

05:30.380 --> 05:31.380
对吧

05:31.380 --> 05:32.380
通过这个对相

05:32.380 --> 05:34.380
它里面提供的一些方法

05:34.380 --> 05:35.380
特别是这个方法

05:35.380 --> 05:36.380
叫做create connection

05:36.380 --> 05:37.380
什么意思呢

05:37.380 --> 05:38.380
这个地方表示的是

05:38.380 --> 05:40.380
创建一个数据库连接

05:41.380 --> 05:42.380
这要我解释一下

05:42.380 --> 05:47.380
创建一个数据库连接

05:47.380 --> 05:48.380
那么什么叫做

05:48.380 --> 05:49.380
创建一个数据库连接

05:49.380 --> 05:50.380
这是什么意思呢

05:51.380 --> 05:52.380
要这样的想象

05:52.380 --> 05:53.380
咱们的硬盘

05:53.380 --> 05:54.380
是不是一块空间

05:55.380 --> 05:57.380
咱们的硬盘是一块空间

05:57.380 --> 05:58.380
对不对

05:58.380 --> 05:59.380
那么这里面存的是

05:59.380 --> 06:00.380
什么呢

06:00.380 --> 06:01.380
存的是数据库

06:01.380 --> 06:02.380
我们的内存

06:02.380 --> 06:03.380
是不是在这

06:03.380 --> 06:04.380
对不对

06:04.380 --> 06:06.380
那么这个硬盘和内存

06:06.380 --> 06:07.380
我们这里是在

06:07.380 --> 06:08.380
同一台计算机上

06:08.380 --> 06:09.380
对吧

06:09.380 --> 06:10.380
我们的麦斯后

06:10.380 --> 06:11.380
和我们的路德结石

06:11.380 --> 06:13.380
是在同一台计算机上

06:13.380 --> 06:15.380
实际上它完全是可以分开的

06:15.380 --> 06:16.380
就是我们的麦斯后

06:16.380 --> 06:17.380
是放到另一台计算机

06:17.380 --> 06:18.380
我们的路德程序

06:18.380 --> 06:20.380
是又在另一台计算机

06:20.380 --> 06:21.380
那么无论是在

06:21.380 --> 06:23.380
同一台计算机还是分开的

06:23.380 --> 06:25.380
他们之间要进行交互

06:25.380 --> 06:27.380
都必须要创建一个连接

06:27.380 --> 06:28.380
就有点像

06:28.380 --> 06:29.380
你可以把理解为

06:29.380 --> 06:31.380
就是一个网络的连接

06:31.380 --> 06:32.380
就是一个网络的连接

06:32.380 --> 06:33.380
所以说他们之间

06:33.380 --> 06:35.380
他们要创建一个连接通道

06:35.380 --> 06:36.380
那么在通道里边

06:36.380 --> 06:38.380
来传输这个数据

06:38.380 --> 06:39.380
怎么来传输呢

06:39.380 --> 06:40.380
其实特别简单

06:40.380 --> 06:41.380
就是我的路德程序

06:41.380 --> 06:43.380
把这个就是

06:43.380 --> 06:45.380
收口语句传过去

06:46.380 --> 06:47.380
收口语句传过去

06:47.380 --> 06:49.380
把收口语句传过去

06:49.380 --> 06:51.380
把收口语句传给他

06:51.380 --> 06:52.380
然后他这边

06:52.380 --> 06:54.380
把这个查询结果

06:54.380 --> 06:56.380
或者是运行的结果传给我

06:56.380 --> 06:58.380
就是这么一个交互过程

06:58.380 --> 06:59.380
那么这个交互过程

06:59.380 --> 07:01.380
都必须要依赖这个连接

07:04.690 --> 07:05.690
我把收口语句给他

07:05.690 --> 07:06.690
然后他把这个结果给我

07:06.690 --> 07:07.690
没了意思吧

07:07.690 --> 07:09.690
这就是他们整个的交互过程

07:09.690 --> 07:10.690
那么要进行这个交互

07:10.690 --> 07:12.690
就必须要有一个连接

07:12.690 --> 07:13.690
这就是连接

07:13.690 --> 07:14.690
非常简单对吧

07:14.690 --> 07:15.690
那么现在呢

07:15.690 --> 07:16.690
我们这里创建一个连接

07:16.690 --> 07:17.690
创建连接的时候

07:17.690 --> 07:18.690
他要提供一些东西

07:18.690 --> 07:20.690
首先你的主机

07:20.690 --> 07:21.690
你的数据库在哪

07:21.690 --> 07:22.690
在哪台计算机上

07:22.690 --> 07:23.690
是不是要提供一个IPR

07:23.690 --> 07:25.690
或者是域名都可以

07:25.690 --> 07:26.690
对吧

07:26.690 --> 07:27.690
我们如果说本机的话

07:27.690 --> 07:29.690
就用localhost表示本机

07:29.690 --> 07:30.690
我们这里就是本机

07:30.690 --> 07:32.690
或者是127.0.0.1也行

07:32.690 --> 07:33.690
好

07:33.690 --> 07:34.690
这个是表示没什么意思

07:34.690 --> 07:35.690
就是你要

07:35.690 --> 07:36.690
他连接的时候需要

07:36.690 --> 07:37.690
因为他要全线

07:37.690 --> 07:41.690
所以说需要数据库的账号入址

07:41.690 --> 07:43.690
密码是password

07:45.690 --> 07:47.690
这是数据库的密码

07:47.690 --> 07:49.690
这是数据库的密码

07:49.690 --> 07:50.690
密码的话

07:50.690 --> 07:51.690
我这里是啥

07:51.690 --> 07:53.690
我这里是

07:53.690 --> 07:55.690
我试一下这个

07:55.690 --> 07:57.690
这是密码

07:57.690 --> 07:58.690
然后这里是数据库的名字

07:58.690 --> 08:00.690
因为我们买售货里边

08:00.690 --> 08:01.690
有很多的数据库

08:01.690 --> 08:02.690
你到底要连到哪一颗数据库

08:02.690 --> 08:04.690
这是要给一个数据库名字

08:04.690 --> 08:05.690
那么我们这就连我们

08:05.690 --> 08:06.690
之前的

08:06.690 --> 08:08.690
上一章我们学的一个数据库吧

08:08.690 --> 08:12.830
我们打开这个

08:12.830 --> 08:13.830
打开一下

08:13.830 --> 08:14.830
上一章

08:14.830 --> 08:17.830
咱们学的数据库是这个

08:17.830 --> 08:18.830
company DB

08:18.830 --> 08:19.830
是不是这个

08:19.830 --> 08:22.830
那么咱们只有连这个

08:22.830 --> 08:24.830
company DB

08:24.830 --> 08:25.830
所以就完成连接了

08:25.830 --> 08:26.830
对不对

08:26.830 --> 08:28.830
这就是创建一个连接

08:28.830 --> 08:30.830
是不是特别简单

08:30.830 --> 08:32.830
那么创建了连接之后

08:32.830 --> 08:33.830
我们怎么办

08:33.830 --> 08:34.830
我们首先来创建一个

08:34.830 --> 08:35.830
把下面的注射掉

08:35.830 --> 08:36.830
看到有没有爆错

08:36.830 --> 08:37.830
如果不爆错的话

08:37.830 --> 08:39.830
那么就表示连接是没问题的

08:39.830 --> 08:40.830
咱们运行一下

08:40.830 --> 08:45.660
load index

08:45.660 --> 08:46.660
那么这里是不是没爆错

08:46.660 --> 08:47.660
对不对

08:47.660 --> 08:50.660
没有爆错说明是正确的

08:50.660 --> 08:52.660
那为什么没有结束呢程序

08:52.660 --> 08:54.660
程序没有结束是连接

08:54.660 --> 08:56.660
它一直在等待

08:56.660 --> 08:57.660
也要给它发送消息

08:57.660 --> 08:59.660
就像我们刚才画的图一样

08:59.660 --> 09:00.660
我们连接好了过后

09:00.660 --> 09:01.660
你要它要等待

09:01.660 --> 09:03.660
你给它发送一些收口语句

09:03.660 --> 09:04.660
然后它去运行

09:04.660 --> 09:05.660
那么这个时候

09:05.660 --> 09:06.660
由于我一直没有发送收口语句

09:06.660 --> 09:08.660
而且连接的又没有

09:08.660 --> 09:09.660
又没有断开

09:09.660 --> 09:10.660
又没有断开这个连接

09:10.660 --> 09:12.660
所以说它就一直在等待

09:12.660 --> 09:13.660
因此它没有结束

09:13.660 --> 09:14.660
如果说我们要自己

09:14.660 --> 09:15.660
断开连接的话

09:15.660 --> 09:16.660
我们就可以用什么

09:16.660 --> 09:18.660
connection

09:18.660 --> 09:19.660
end

09:19.660 --> 09:22.660
表示断开连接

09:22.660 --> 09:26.660
这里再停止运行

09:26.660 --> 09:27.660
你看是不是就结束了

09:27.660 --> 09:28.660
对不对

09:28.660 --> 09:29.660
那么就是创建连接

09:29.660 --> 09:31.660
和断开连接

09:31.660 --> 09:33.660
这里我们先不断开

09:33.660 --> 09:35.660
连接创建好了之后

09:35.660 --> 09:36.660
我们干嘛呢

09:36.660 --> 09:37.660
我们就开始运行收口语句了

09:37.660 --> 09:38.660
怎么来运行收口语句呢

09:38.660 --> 09:39.660
就通过这个连接对象

09:39.660 --> 09:41.660
它有一个函数叫query

09:41.660 --> 09:42.660
query就是一个查询语句

09:42.660 --> 09:43.660
它不一定是查询

09:43.660 --> 09:44.660
一定是查询

09:44.660 --> 09:45.660
任何的收口语句

09:45.660 --> 09:46.660
比如创建ddl

09:46.660 --> 09:47.660
dml都可以

09:47.660 --> 09:49.660
创建数据过对象

09:49.660 --> 09:50.660
或者是往

09:50.660 --> 09:52.660
标里边查出一条数据

09:52.660 --> 09:53.660
删除一条数据都可以

09:53.660 --> 09:54.660
所以说

09:54.660 --> 09:55.660
这里我们

09:55.660 --> 09:56.660
随便来一个

09:56.660 --> 09:57.660
比方说我们这里

09:57.660 --> 09:59.660
就查询所有的company

09:59.660 --> 10:01.660
就查询所有的company

10:01.660 --> 10:02.660
就查询

10:02.660 --> 10:04.660
这个数据少一点

10:04.660 --> 10:05.660
查询这个

10:05.660 --> 10:06.660
查询这个表

10:06.660 --> 10:07.660
后面写上ware

10:07.660 --> 10:08.660
它会说

10:08.660 --> 10:10.660
为什么用的是单印号

10:10.660 --> 10:11.660
为什么不用模板

10:11.660 --> 10:12.660
这不算很

10:12.660 --> 10:13.660
因为我们知道

10:13.660 --> 10:14.660
收口语句里边

10:14.660 --> 10:15.660
是有这个反引号

10:15.660 --> 10:16.660
对不对

10:16.660 --> 10:17.660
防止冲突

10:17.660 --> 10:18.660
当然你用

10:18.660 --> 10:19.660
如果说你用模板

10:19.660 --> 10:20.660
这不算的话

10:20.660 --> 10:21.660
你转移也可以

10:21.660 --> 10:22.660
总之它是一个字幕算

10:22.660 --> 10:23.660
我们的收口语句

10:23.660 --> 10:24.660
就运行的

10:24.660 --> 10:25.660
是个字幕算

10:25.660 --> 10:26.660
条件不给了

10:26.660 --> 10:27.660
我们就运行一个收口语句

10:27.660 --> 10:28.660
就写完了

10:28.660 --> 10:29.660
让它去运行

10:29.660 --> 10:30.660
这个收口语句

10:30.660 --> 10:31.660
就是第1个参数

10:31.660 --> 10:32.660
第2个参数

10:32.660 --> 10:34.660
是一个毁掉函数

10:34.660 --> 10:35.660
表示的是

10:35.660 --> 10:36.660
我查询完了过后

10:36.660 --> 10:37.660
我得到了结果

10:37.660 --> 10:39.660
那么第2个参数

10:39.660 --> 10:40.660
这里我们一般

10:40.660 --> 10:41.660
就用2个参数

10:41.660 --> 10:42.660
它有3个参数

10:42.660 --> 10:43.660
第3个参数表示元数

10:43.660 --> 10:44.660
我们一般都用不到

10:44.660 --> 10:46.660
我们就用2个参数一够了

10:46.660 --> 10:47.660
那么这个

10:47.660 --> 10:48.660
第一个是错误

10:48.660 --> 10:50.660
Error表示错误

10:50.660 --> 10:52.660
Error表示错误

10:52.660 --> 10:54.660
那么这个result表示

10:54.660 --> 10:55.660
查询结果

10:55.660 --> 10:58.660
查询结果

10:58.660 --> 11:00.660
可说一下

11:00.660 --> 11:01.660
看一下我们把result

11:01.660 --> 11:02.660
打印出来

11:02.660 --> 11:03.660
这个收口语句

11:03.660 --> 11:04.660
是没有错误的

11:04.660 --> 11:05.660
如果说有错误的话

11:05.660 --> 11:06.660
这个东西就不为空了

11:06.660 --> 11:07.660
没有错误的话就为空

11:07.660 --> 11:08.660
咱们看一下

11:08.660 --> 11:09.660
运行

11:09.660 --> 11:10.660
你看是不是查出来了

11:10.660 --> 11:11.660
对不对

11:11.660 --> 11:12.660
查算是个什么

11:12.660 --> 11:13.660
是不是个数主

11:13.660 --> 11:14.660
数主的每一项

11:14.660 --> 11:15.660
它给你封装了一个对象

11:15.660 --> 11:16.660
叫txtrow这个对象

11:16.660 --> 11:17.660
其实数主的每一项

11:17.660 --> 11:18.660
就是个对象

11:18.660 --> 11:19.660
对象里面是不是有id

11:19.660 --> 11:21.660
name location build date

11:21.660 --> 11:23.660
那么你拿这个数主过后干嘛

11:23.660 --> 11:24.660
就随便你了

11:24.660 --> 11:25.660
你爱干嘛干嘛

11:25.660 --> 11:26.660
是这么个意思

11:26.660 --> 11:27.660
这就是

11:27.660 --> 11:28.660
它做一个

11:28.660 --> 11:30.660
这个东西的用法

11:30.660 --> 11:31.660
就特别简单

11:31.660 --> 11:32.660
这当然这是查询语句

11:32.660 --> 11:33.660
还有什么语句呢

11:33.660 --> 11:34.660
还有争商感

11:34.660 --> 11:35.660
对吧

11:35.660 --> 11:36.660
我们平时就是CRUD

11:36.660 --> 11:37.660
争商感

11:37.660 --> 11:38.660
我们来试一下

11:39.660 --> 11:40.660
connection

11:40.660 --> 11:42.660
我们去增加一个公司

11:42.660 --> 11:43.660
还是用query

11:44.660 --> 11:46.660
收口语句来我们去写一个

11:47.660 --> 11:50.660
insert into company

11:51.660 --> 11:52.660
然后这里边写上

11:52.660 --> 11:54.660
company id不写了

11:54.660 --> 11:55.660
我们看它有哪些属性呢

11:55.660 --> 11:56.660
有name

11:58.660 --> 11:59.660
我们这个name

11:59.660 --> 12:00.660
它是一个那个

12:00.660 --> 12:01.660
我给它加上一个

12:01.660 --> 12:02.660
它是个关键字

12:02.660 --> 12:03.660
location

12:04.660 --> 12:05.660
如果说你要写全的话

12:05.660 --> 12:06.660
全部加上都可以

12:06.660 --> 12:07.660
location build date

12:07.660 --> 12:08.660
build date

12:09.660 --> 12:10.660
build date

12:10.660 --> 12:11.660
我们就像

12:11.660 --> 12:12.660
就这样吧

12:12.660 --> 12:13.660
然后给它一个values

12:14.660 --> 12:15.660
它的数据是什么呢

12:15.660 --> 12:16.660
最后分号结束

12:16.660 --> 12:17.660
数据是name

12:17.660 --> 12:18.660
我们加上一个

12:18.660 --> 12:19.660
公司名字

12:19.660 --> 12:20.660
公司名字

12:21.660 --> 12:22.660
abc

12:23.660 --> 12:25.660
然后后边location

12:25.660 --> 12:26.660
location

12:26.660 --> 12:27.660
地址

12:27.660 --> 12:28.660
地址随便写个

12:29.660 --> 12:30.660
第三个参数

12:30.660 --> 12:31.660
第三个参数

12:31.660 --> 12:32.660
是当前日期

12:32.660 --> 12:33.660
我们用当前日期

12:33.660 --> 12:34.660
我们用买收口的函数

12:34.660 --> 12:35.660
cur date

12:35.660 --> 12:36.660
买收口里面能写的东西

12:36.660 --> 12:37.660
这里都能写

12:37.660 --> 12:38.660
注意

12:38.660 --> 12:39.660
买收口里面能写的

12:39.660 --> 12:40.660
收口语句的函数

12:40.660 --> 12:41.660
这种东西都能写

12:41.660 --> 12:42.660
那么就运行这么一个

12:42.660 --> 12:43.660
收口语句

12:43.660 --> 12:44.660
接下来我们看一下

12:44.660 --> 12:45.660
第二个参数

12:45.660 --> 12:46.660
回到函数

12:46.660 --> 12:47.660
回到函数

12:47.660 --> 12:48.660
我们用个建筒函数

12:48.660 --> 12:49.660
第一个参数 error

12:49.660 --> 12:50.660
第三个参数result

12:52.660 --> 12:53.660
输出result

12:54.660 --> 12:55.660
格式化一样

12:55.660 --> 12:56.660
咱们来看一下

12:56.660 --> 12:57.660
这个结果

12:57.660 --> 12:59.660
新增一条数据

12:59.660 --> 13:00.660
运行

13:01.660 --> 13:02.660
它告诉我

13:02.660 --> 13:03.660
这个result里面

13:03.660 --> 13:04.660
告诉我一个什么

13:05.660 --> 13:06.660
首先是affected

13:06.660 --> 13:07.660
我们要用到的

13:07.660 --> 13:08.660
affected rows

13:08.660 --> 13:09.660
它就影响的函数

13:09.660 --> 13:10.660
因为我们现在运行的

13:10.660 --> 13:11.660
不是查讯语句

13:11.660 --> 13:12.660
是新增语句

13:12.660 --> 13:14.660
受影响的函数

13:14.660 --> 13:15.660
受影响的函数

13:15.660 --> 13:16.660
是不是一行

13:16.660 --> 13:17.660
一行受影响

13:17.660 --> 13:19.660
然后一个insert id

13:19.660 --> 13:21.660
表示新增的那个数据

13:21.660 --> 13:23.660
新增的那个组件 id

13:23.660 --> 13:25.660
因为它组件是自征的

13:25.660 --> 13:26.660
那么这个组件 id

13:26.660 --> 13:27.660
是不是给力的

13:27.660 --> 13:28.660
因为我们这里

13:28.660 --> 13:29.660
是不是没有写组件

13:29.660 --> 13:30.660
它组件的 id 也会给力的

13:30.660 --> 13:31.660
我们平时要用到的话

13:31.660 --> 13:33.660
也就用到这两个数据

13:33.660 --> 13:34.660
这里是新增

13:34.660 --> 13:35.660
特别简单

13:35.660 --> 13:36.660
对吧

13:36.660 --> 13:37.660
咱们来看一下吧

13:38.660 --> 13:39.660
我的navigate

13:40.660 --> 13:41.660
在这

13:41.660 --> 13:43.660
咱们看一下这个company表

13:43.660 --> 13:44.660
你看是不是多了一条数据

13:44.660 --> 13:45.660
现在我们就在程序里面

13:45.660 --> 13:47.660
说新增了一条数据

13:47.660 --> 13:48.660
对不对

13:48.660 --> 13:49.660
不删不删

13:49.660 --> 13:50.660
我们一会再来改

13:50.660 --> 13:52.660
好 接下来我们再来

13:54.660 --> 13:55.660
然后我们现在去运行

13:55.660 --> 13:57.660
一条修改语句

13:57.660 --> 13:58.660
是一样的

13:58.660 --> 13:59.660
完全一样的

14:00.660 --> 14:01.660
来吧

14:01.660 --> 14:02.660
update company

14:04.660 --> 14:05.660
set

14:05.660 --> 14:06.660
什么呢

14:06.660 --> 14:07.660
setname

14:07.660 --> 14:10.660
等于bcd

14:10.660 --> 14:11.660
ware 加个条件

14:11.660 --> 14:12.660
注意你修改和删除的时候

14:12.660 --> 14:13.660
一定要加条件

14:13.660 --> 14:15.660
不然就把整个表的影响了

14:15.660 --> 14:16.660
id 等于什么

14:16.660 --> 14:17.660
等于4

14:17.660 --> 14:18.660
试一下吧

14:18.660 --> 14:19.660
这里呢

14:19.660 --> 14:20.660
我们第二个参数

14:20.660 --> 14:21.660
错误result

14:22.660 --> 14:24.660
输出一下result

14:25.660 --> 14:26.660
看一下

14:26.660 --> 14:27.660
我们这里运行

14:27.660 --> 14:30.990
这边来

14:31.990 --> 14:32.990
过来

14:32.990 --> 14:34.990
这里我们清空一下

14:35.990 --> 14:36.990
运行

14:36.990 --> 14:38.990
这里受影响的杭数为1

14:38.990 --> 14:39.990
对不对

14:39.990 --> 14:41.990
受影响的杭数为1

14:41.990 --> 14:43.990
修改的杭也是1

14:43.990 --> 14:45.990
咱们停止

14:45.990 --> 14:46.990
这边我们刷新一下

14:46.990 --> 14:47.990
右键刷新

14:47.990 --> 14:49.990
你看是不是变成bcd了

14:49.990 --> 14:50.990
特别特别简单

14:50.990 --> 14:52.990
这是修改语句

14:52.990 --> 14:54.990
那么删除语句是完全一样的

14:54.990 --> 14:55.990
咱们直接来一个

14:55.990 --> 14:57.990
来一个删除语句

14:57.990 --> 14:59.990
复制一下

14:59.990 --> 15:01.990
把这个收口语句改一下就行了

15:01.990 --> 15:04.990
delete from company

15:04.990 --> 15:06.990
所以这些语句要用熟悉

15:06.990 --> 15:08.990
ware条件是id等于4

15:08.990 --> 15:09.990
咱们来看一下吧

15:09.990 --> 15:10.990
这边运行

15:11.990 --> 15:12.990
运行完了

15:12.990 --> 15:13.990
运行完了之后

15:13.990 --> 15:14.990
我们这里刷新

15:14.990 --> 15:16.990
你看是不是被删掉了

15:16.990 --> 15:17.990
对不对

15:17.990 --> 15:18.990
这是关于这里

15:18.990 --> 15:20.990
如何来去做一些增伤感查

15:20.990 --> 15:21.990
是不是全部搞定的

15:21.990 --> 15:22.990
你只需要用这个杭数就可以

15:22.990 --> 15:23.990
就够了

15:23.990 --> 15:24.990
这是关于这一块

15:25.990 --> 15:26.990
那么其实它这里

15:26.990 --> 15:27.990
还给你提供了一些

15:27.990 --> 15:28.990
另外的写法

15:29.990 --> 15:30.990
就是这

15:30.990 --> 15:31.990
看一下吧

15:31.990 --> 15:32.990
就是这

15:33.990 --> 15:34.990
第一个

15:34.990 --> 15:35.990
我们说一下这个

15:36.990 --> 15:37.990
我们看一下说哪呢

15:37.990 --> 15:38.990
先说这个吧

15:38.990 --> 15:39.990
先说这个

15:39.990 --> 15:40.990
就是它还给你提供了一些

15:40.990 --> 15:42.990
就是关于promise的写法

15:42.990 --> 15:43.990
因为它

15:43.990 --> 15:44.990
mySQL

15:44.990 --> 15:45.990
我记得是不支持promise的

15:45.990 --> 15:46.990
mySQL2是支持的

15:46.990 --> 15:47.990
因为我们知道

15:47.990 --> 15:48.990
用promise的

15:48.990 --> 15:49.990
用一个异步的方式

15:49.990 --> 15:50.990
是更加方便

15:50.990 --> 15:51.990
对吧

15:51.990 --> 15:52.990
刚才我们用的是回调

15:52.990 --> 15:53.990
回调没有那么方便

15:53.990 --> 15:54.990
用异步的话

15:54.990 --> 15:55.990
更加方便一点

15:55.990 --> 15:56.990
所以说它可以提供了

15:56.990 --> 15:57.990
这么一些方式require

15:57.990 --> 16:00.990
导入了什么mySQL2 promise

16:00.990 --> 16:01.990
导入了这么一个东西

16:01.990 --> 16:02.990
然后呢

16:02.990 --> 16:04.990
在这个东西里边

16:04.990 --> 16:05.990
它所有的接口

16:05.990 --> 16:06.990
全是promise的

16:06.990 --> 16:07.990
包括创建连接

16:07.990 --> 16:08.990
看呗

16:08.990 --> 16:09.990
是不是promise

16:09.990 --> 16:10.990
对不对

16:10.990 --> 16:11.990
用promise的方式来创建连接

16:11.990 --> 16:12.990
然后呢

16:12.990 --> 16:13.990
这里是

16:13.990 --> 16:14.990
执行

16:14.990 --> 16:15.990
这里是query

16:15.990 --> 16:16.990
可以写query

16:16.990 --> 16:17.990
那么这里也是异步的

16:17.990 --> 16:19.990
这样就避免了使用回调

16:19.990 --> 16:20.990
使用回调的方式

16:20.990 --> 16:21.990
好

16:21.990 --> 16:22.990
咱们来试一下吧

16:22.990 --> 16:23.990
这是我们把它保存一下

16:25.990 --> 16:26.990
比方说我们这里

16:26.990 --> 16:29.990
可以用mySQL2 promise

16:29.990 --> 16:30.990
可以用这个

16:31.990 --> 16:32.990
好

16:32.990 --> 16:33.990
接下来

16:33.990 --> 16:34.990
我们来这里写个函数

16:34.990 --> 16:35.990
方形

16:35.990 --> 16:36.990
test

16:36.990 --> 16:37.990
这么一个函数

16:37.990 --> 16:39.990
当然这是个异步函数

16:39.990 --> 16:40.990
async

16:40.990 --> 16:42.990
我们这里创建连接的时候

16:42.990 --> 16:45.990
我们就可以用

16:45.990 --> 16:47.990
用异步的方式来创建

16:47.990 --> 16:48.990
还是一样的

16:48.990 --> 16:49.990
完全一样的写法

16:49.990 --> 16:51.990
只它变成一个异步的位置

16:51.990 --> 16:52.990
等待它连接创建好

16:52.990 --> 16:53.990
创建好了之后

16:53.990 --> 16:54.990
我们去运行

16:54.990 --> 16:55.990
一个一条搜口语句

16:55.990 --> 16:56.990
你看一下

16:56.990 --> 16:57.990
运行条搜口语句

16:57.990 --> 16:58.990
是完全一样的

16:58.990 --> 16:59.990
只不过呢

16:59.990 --> 17:00.990
它这里呢

17:00.990 --> 17:02.990
就不是一个回调函数了

17:02.990 --> 17:03.990
而是用什么呢

17:03.990 --> 17:04.990
而是用await

17:04.990 --> 17:05.990
这样的鞋鞋更加清晰

17:05.990 --> 17:06.990
整个结构

17:06.990 --> 17:07.990
等待它

17:07.990 --> 17:08.990
等它完成过后

17:08.990 --> 17:09.990
它得到的是什么

17:09.990 --> 17:10.990
得到的是一个数组

17:10.990 --> 17:11.990
为什么是数组呢

17:11.990 --> 17:12.990
为什么是数组

17:12.990 --> 17:13.990
不是说它查询算是个数组

17:13.990 --> 17:14.990
因为我们知道

17:14.990 --> 17:15.990
这个回调函数

17:15.990 --> 17:16.990
不是有两个参数吗

17:16.990 --> 17:17.990
对不对

17:17.990 --> 17:18.990
它其实还有一个参数

17:18.990 --> 17:19.990
我们没用而已

17:19.990 --> 17:20.990
因为因此

17:20.990 --> 17:21.990
它把这两个参数

17:21.990 --> 17:22.990
放到一个数组里面

17:22.990 --> 17:23.990
第一个参数表示

17:23.990 --> 17:24.990
结果

17:24.990 --> 17:25.990
第二个参数表示

17:25.990 --> 17:26.990
原数据

17:26.990 --> 17:27.990
原税稳一般用不到

17:27.990 --> 17:28.990
所以我们这里

17:29.990 --> 17:30.990
好

17:30.990 --> 17:31.990
咱们输出一下

17:31.990 --> 17:32.990
result

17:32.990 --> 17:33.990
你看

17:33.990 --> 17:34.990
效果是一样的

17:34.990 --> 17:35.990
test

17:35.990 --> 17:36.990
最后我们把连接关闭

17:37.990 --> 17:38.990
connection

17:38.990 --> 17:39.990
end

17:40.990 --> 17:41.990
连接关闭

17:42.990 --> 17:43.990
好 写好了

17:43.990 --> 17:44.990
咱们来试一下

17:45.990 --> 17:46.990
我写的是哪

17:46.990 --> 17:47.990
对啊

17:48.990 --> 17:49.990
运行

17:49.990 --> 17:50.990
它都要爆错了

17:50.990 --> 17:51.990
它有什么呢

17:52.990 --> 17:54.990
connection is not defined

17:54.990 --> 17:56.990
它说这个connection

17:56.990 --> 17:58.990
是没有被定义的

17:59.990 --> 18:01.990
为什么没有被定义了

18:01.990 --> 18:02.990
我看一下

18:02.990 --> 18:04.990
我在哪里写错了

18:04.990 --> 18:08.500
great connection

18:08.500 --> 18:09.500
没问题啊

18:10.500 --> 18:13.810
my circle2 promise

18:13.810 --> 18:14.810
再来运行一次

18:19.980 --> 18:20.980
运行

18:20.980 --> 18:21.980
它还是说

18:21.980 --> 18:22.980
告诉我这个connection

18:22.980 --> 18:23.980
is not defined

18:23.980 --> 18:24.980
那我输出一下吧

18:24.980 --> 18:25.980
输出一下这个connection

18:25.980 --> 18:26.980
到底是啥

18:27.980 --> 18:31.630
connection

18:31.630 --> 18:35.420
运行

18:35.420 --> 18:37.420
什么都没有输出

18:37.420 --> 18:38.420
奇怪啊

18:39.420 --> 18:41.420
我改的适应这个是吧

18:41.420 --> 18:42.420
在下面

18:42.420 --> 18:43.420
在下面

18:43.420 --> 18:44.420
下面还有一条语句

18:44.420 --> 18:46.420
这个语句是没问题的

18:46.420 --> 18:47.420
运行

18:47.420 --> 18:48.420
你看

18:48.420 --> 18:49.420
是不是输出了

18:49.420 --> 18:51.420
把connection删了

18:51.420 --> 18:53.420
connection里面的东西还蛮多的

18:54.420 --> 18:58.780
重新来

18:58.780 --> 18:59.780
运行

18:59.780 --> 19:00.780
你看 是不是出来了

19:00.780 --> 19:01.780
效果是完全一样的

19:01.780 --> 19:02.780
包括争商改语句

19:02.780 --> 19:04.780
效果也是完全一样的

19:04.780 --> 19:06.780
这是关于这一块

19:06.780 --> 19:07.780
它如何

19:07.780 --> 19:09.780
使用Promise的方式

19:09.780 --> 19:10.780
操纵数据库

19:10.780 --> 19:11.780
这是这两个点

19:11.780 --> 19:13.780
那么大家喜欢用哪一个

19:13.780 --> 19:14.780
就用哪一个

19:14.780 --> 19:15.780
可以用回调

19:15.780 --> 19:16.780
也可以用这种模式

19:16.780 --> 19:17.780
我把它复制一下

19:17.780 --> 19:19.780
接下来我要讲的东西就是重点了

19:20.780 --> 19:21.780
重点是什么呢

19:21.780 --> 19:22.780
重点是你平时

19:22.780 --> 19:23.780
不能够是这样子的

19:23.780 --> 19:24.780
来写射口语句

19:24.780 --> 19:25.780
不能这样子写

19:25.780 --> 19:27.780
不能用crue的方式来写

19:27.780 --> 19:28.780
为什么呢

19:28.780 --> 19:29.780
我再给大家介绍一个

19:29.780 --> 19:31.780
在操作数据库的时候

19:31.780 --> 19:32.780
非常重要的一个概念

19:32.780 --> 19:33.780
跟安全性相关

19:33.780 --> 19:34.780
叫做

19:34.780 --> 19:35.780
射口注入

19:35.780 --> 19:36.780
要防止

19:36.780 --> 19:37.780
射口注入

19:37.780 --> 19:39.780
什么叫射口注入呢

19:39.780 --> 19:41.780
我们给大家演示一个例子

19:41.780 --> 19:42.780
就明白了

19:42.780 --> 19:43.780
你看一下会造成

19:43.780 --> 19:45.780
什么样灾难性的后果

19:45.780 --> 19:47.780
为了演示这个例子

19:47.780 --> 19:49.780
我这里要做一件事

19:49.780 --> 19:51.780
我这里先要去加一条数据

19:51.780 --> 19:52.780
通常的话

19:52.780 --> 19:54.780
我把之前的数据都删了

19:54.780 --> 19:55.780
我有点找不住

19:55.780 --> 19:57.780
我只随便加一条数据

19:58.780 --> 19:59.780
随便加一条

20:00.780 --> 20:01.780
我们再放大一条

20:02.780 --> 20:03.780
这里是日期

20:03.780 --> 20:04.780
日期我们就选择

20:04.780 --> 20:05.780
日期保存一次

20:06.780 --> 20:07.780
刷新一下

20:07.780 --> 20:08.780
加了一条数据

20:08.780 --> 20:10.780
接下来我们来演示一下

20:11.780 --> 20:12.780
演示什么呢

20:12.780 --> 20:13.780
我们看着

20:13.780 --> 20:14.780
我们这样子来玩

20:14.780 --> 20:18.280
这个TAS的函数

20:18.280 --> 20:20.280
它是做查询的

20:20.280 --> 20:21.280
查询什么呢

20:21.280 --> 20:23.280
查询ID等于

20:23.280 --> 20:25.280
某一个值的员工

20:25.280 --> 20:27.280
我们来做这个查询

20:27.280 --> 20:29.280
ID等于某一个值的员工

20:29.280 --> 20:30.280
你给我一个ID

20:30.280 --> 20:32.280
那么我来做一个查询

20:32.280 --> 20:33.280
就查询ID等于

20:33.280 --> 20:34.280
某一个值的员工

20:34.280 --> 20:35.280
怎么查呢

20:35.280 --> 20:36.280
非常简单

20:36.280 --> 20:37.280
新号

20:37.280 --> 20:38.280
from

20:38.280 --> 20:39.280
哪个标呢

20:39.280 --> 20:41.280
查询那个员工标

20:41.280 --> 20:42.280
employee

20:42.280 --> 20:43.280
对不对

20:43.280 --> 20:44.280
无缘一个条件

20:44.280 --> 20:46.280
ID等于某一个值

20:46.280 --> 20:47.280
那么这个是不是要

20:47.280 --> 20:48.280
做一个制服穿拼接

20:48.280 --> 20:49.280
对不对

20:49.280 --> 20:50.280
去拼接一下

20:50.280 --> 20:51.280
这个地方我们可以用

20:51.280 --> 20:52.280
模板制服穿拼接

20:54.280 --> 20:55.280
拼接这个ID

20:56.280 --> 20:57.280
没问题吧

20:57.280 --> 20:58.280
是不是很简单

20:58.280 --> 20:59.280
咱们来试一下

20:59.280 --> 21:00.280
我们给它传一个ID

21:00.280 --> 21:02.280
ID等于比方说等于5

21:02.280 --> 21:04.280
咱们来查询试一下

21:07.810 --> 21:08.810
运行

21:08.810 --> 21:11.380
你看是不是查出来了

21:11.380 --> 21:12.380
对吧

21:12.380 --> 21:13.380
一切都是好像挺好的

21:13.380 --> 21:14.380
也没有什么问题

21:14.380 --> 21:15.380
那么这里的问题

21:15.380 --> 21:16.380
主要在哪呢

21:16.380 --> 21:19.380
主要在这个ID的来源上

21:19.380 --> 21:21.380
你知不知道这个ID哪来的

21:21.380 --> 21:22.380
因为这个是个函数

21:22.380 --> 21:23.380
这个函数ID是别人

21:23.380 --> 21:24.380
传过来的

21:24.380 --> 21:26.380
它就有可能来自于

21:26.380 --> 21:27.380
用户的查询

21:27.380 --> 21:28.380
什么意思呢

21:29.380 --> 21:30.380
就是说

21:30.380 --> 21:32.380
我们用户在页面上

21:32.380 --> 21:34.380
发送了一个

21:34.380 --> 21:36.380
一个阿迦克斯请求

21:37.380 --> 21:38.380
页面发送阿迦克斯请求

21:38.380 --> 21:39.380
请求什么地址呢

21:39.380 --> 21:40.380
某一个地址

21:40.380 --> 21:41.380
它带了一个ID

21:41.380 --> 21:44.380
附带了一个查询的ID

21:45.380 --> 21:46.380
那么到了

21:46.380 --> 21:48.380
是不是把ID发送到了服务器

21:48.380 --> 21:49.380
ID到了了

21:49.380 --> 21:50.380
是不是到了服务器

21:50.380 --> 21:51.380
对不对

21:51.380 --> 21:52.380
好 服务器拿来干嘛

21:52.380 --> 21:55.380
服务器调用TES函数

21:55.380 --> 21:57.380
所以调用我们TES函数

21:57.380 --> 21:59.380
我就做了个简单的例子

21:59.380 --> 22:01.380
然后传入ID

22:01.380 --> 22:02.380
说明ID的最终来源

22:02.380 --> 22:03.380
是来自于

22:03.380 --> 22:05.380
什么来自于页面的

22:05.380 --> 22:07.380
那么页面的阿迦克斯请求

22:07.380 --> 22:08.380
是不是谁都可以做

22:08.380 --> 22:09.380
对不对

22:09.380 --> 22:10.380
是不是谁都可以做

22:10.380 --> 22:11.380
随便写一个

22:11.380 --> 22:13.380
不要打开一个控制台

22:13.380 --> 22:14.380
我们就可以直接写一个接口

22:14.380 --> 22:15.380
发送一个

22:15.380 --> 22:16.380
一个废棋API

22:16.380 --> 22:17.380
就可以发送一个阿迦克斯请求

22:17.380 --> 22:18.380
那么这是来自于

22:18.380 --> 22:19.380
用页面上的东西

22:19.380 --> 22:21.380
那么来自于页面的东西

22:21.380 --> 22:22.380
是不是完全就不知道

22:22.380 --> 22:23.380
它到底给我

22:23.380 --> 22:24.380
发了一个啥都过来

22:24.380 --> 22:25.380
对吧

22:25.380 --> 22:26.380
如果说是正常的情况下的话

22:26.380 --> 22:27.380
你给我发了一个1

22:27.380 --> 22:28.380
发了一个2

22:28.380 --> 22:29.380
这些都是正常的情况

22:29.380 --> 22:31.380
那么这些情况下

22:31.380 --> 22:32.380
倒是没有什么问题

22:32.380 --> 22:33.380
我就直接查出来了

22:33.380 --> 22:34.380
不会影响什么

22:34.380 --> 22:36.380
但万一用户给我发的是

22:36.380 --> 22:37.380
这么一个玩意儿呢

22:37.380 --> 22:38.380
你看着

22:38.380 --> 22:40.380
用户发的不是这么一个玩意儿

22:40.380 --> 22:42.380
它发的是这个东西

22:42.380 --> 22:44.380
你看着我怎么写

22:44.380 --> 22:46.380
我们怎么来写

22:46.380 --> 22:48.380
我怎么写呢

22:48.380 --> 22:49.380
我这样子写

22:49.380 --> 22:52.380
它发送的是一个

22:52.380 --> 22:55.260
看着啊

22:55.260 --> 22:56.260
我要去自行构建

22:56.260 --> 22:57.260
发送的是一个置物串

22:57.260 --> 22:59.260
这个置物串是这么写的

22:59.260 --> 23:02.900
第二

23:02.900 --> 23:04.900
一个引号

23:04.900 --> 23:06.900
再来一个引号

23:06.900 --> 23:08.900
然后呢

23:08.900 --> 23:10.900
一个分号

23:10.900 --> 23:14.900
delete from

23:14.900 --> 23:16.900
company

23:16.900 --> 23:17.900
ware

23:17.900 --> 23:19.900
id等于5

23:19.900 --> 23:22.780
想一想

23:22.780 --> 23:24.780
我们先不着急运行

23:24.780 --> 23:26.780
这个运行出来的结果

23:26.780 --> 23:27.780
是有点可怕的

23:27.780 --> 23:28.780
我们先把这个

23:28.780 --> 23:29.780
舍口语句

23:29.780 --> 23:30.780
给大家打印

23:30.780 --> 23:31.780
出来看一下

23:31.780 --> 23:32.780
它运行的舍口语句

23:32.780 --> 23:34.780
你懂我意思吗

23:34.780 --> 23:35.780
这个舍口语句

23:35.780 --> 23:37.780
再翻过去

23:37.780 --> 23:38.780
再翻过去

23:38.780 --> 23:39.780
这两行

23:39.780 --> 23:41.780
咱们先不着急运行

23:41.780 --> 23:42.780
你可以想一想

23:42.780 --> 23:43.780
我们这个舍口语句

23:43.780 --> 23:44.780
如果说它

23:44.780 --> 23:45.780
按照这样子拼接出来

23:45.780 --> 23:47.780
是一个什么样的结果

23:47.780 --> 23:48.780
给大家看一下

23:48.780 --> 23:52.930
运行

23:52.930 --> 23:53.930
看没

23:53.930 --> 23:55.930
这个舍口语句拼接出来

23:55.930 --> 23:56.930
就变成这个样子了

23:56.930 --> 23:57.930
你觉得这个样子的

23:57.930 --> 23:58.930
后果是什么

23:58.930 --> 23:59.930
第一个查询了

23:59.930 --> 24:01.930
一个id等于空的东西

24:01.930 --> 24:02.930
查不出来

24:02.930 --> 24:03.930
然后把这个数据库里边

24:03.930 --> 24:05.930
一个东西给我删掉了

24:05.930 --> 24:06.930
明明我做的是查询

24:06.930 --> 24:08.930
但是我接受了用户的这个东西

24:08.930 --> 24:11.930
导致了我预期的结果

24:11.930 --> 24:12.930
根本就不是查询了

24:12.930 --> 24:14.930
或者是有些额外的东西

24:14.930 --> 24:15.930
跑来

24:15.930 --> 24:16.930
你看

24:16.930 --> 24:18.930
咱们把这个加上

24:18.930 --> 24:20.930
接下来我们再来运行一下

24:20.930 --> 24:22.930
运行

24:22.930 --> 24:24.930
它这里爆错了

24:24.930 --> 24:25.930
是这样子

24:25.930 --> 24:26.930
默认的情况下

24:26.930 --> 24:28.930
它是不允许运行多条舍口语句的

24:28.930 --> 24:30.930
我们把这个加上

24:30.930 --> 24:31.930
在创建年纪的时候

24:31.930 --> 24:34.930
它只允许运行一条舍口语句

24:34.930 --> 24:35.930
如果说你要运行多条的话

24:35.930 --> 24:36.930
你要运行多条的话

24:36.930 --> 24:37.930
你把这个加上

24:37.930 --> 24:38.930
Multiple

24:38.930 --> 24:39.930
多个的意思

24:39.930 --> 24:41.930
statement

24:41.930 --> 24:44.930
然后把这个夹上

24:44.930 --> 24:45.930
夹上过后我们再来看

24:45.930 --> 24:47.930
那么它现在可以运行多条语句了

24:47.930 --> 24:48.930
有时候中国不夹就行了

24:48.930 --> 24:49.930
不夹

24:49.930 --> 24:50.930
但是有的时候

24:50.930 --> 24:51.930
你要运行多条的舍口语句

24:51.930 --> 24:52.930
运行不了

24:52.930 --> 24:56.940
咱们来看一下

24:56.940 --> 24:57.940
运行

24:57.940 --> 24:59.940
说没问题

24:59.940 --> 25:00.940
运行完了过后

25:00.940 --> 25:01.940
我们打开live开始

25:01.940 --> 25:02.940
你看一下

25:02.940 --> 25:03.940
刚才的数据是不是被删掉了

25:03.940 --> 25:04.940
对不对

25:04.940 --> 25:05.940
那个50个数据是不是被删掉了

25:05.940 --> 25:06.940
我们再来刷新看一下

25:07.940 --> 25:08.940
有时候还不符

25:08.940 --> 25:10.940
不符我们再来加一条数据吧

25:10.940 --> 25:11.940
我们来看

25:11.940 --> 25:13.940
我们这里可以写任何的舍口语句

25:13.940 --> 25:15.940
你看我在这里可以加一条舍口语句

25:15.940 --> 25:17.940
into company

25:17.940 --> 25:18.940
然后呢

25:21.940 --> 25:22.940
这里要转移

25:25.940 --> 25:27.940
location

25:27.940 --> 25:29.940
build that

25:29.940 --> 25:31.940
values

25:31.940 --> 25:32.940
名字

25:32.940 --> 25:34.940
我们随便写一个

25:34.940 --> 25:35.940
location

25:36.940 --> 25:38.940
credit

25:38.940 --> 25:39.940
看一下吧

25:39.940 --> 25:40.940
你看这个

25:40.940 --> 25:42.940
本来我是根据一个id来查员工的

25:42.940 --> 25:44.940
结果我的员工一查出来不得了

25:44.940 --> 25:47.940
结果我们来这边刷新一下

25:47.940 --> 25:49.940
多了条数据

25:49.940 --> 25:51.940
这就叫做舍口注入

25:51.940 --> 25:53.940
什么叫舍口注入呢

25:53.940 --> 25:54.940
这里我们总结一下

25:54.940 --> 25:56.940
什么叫舍口注入

25:57.940 --> 25:59.940
舍口注入的含义是

25:59.940 --> 26:01.940
用户

26:01.940 --> 26:03.940
通过

26:03.940 --> 26:04.940
注入

26:04.940 --> 26:06.940
舍口语句

26:06.940 --> 26:08.940
到最终查询中

26:08.940 --> 26:10.940
导致呢

26:10.940 --> 26:12.940
整个舍口

26:12.940 --> 26:13.940
与

26:13.940 --> 26:14.940
预期

26:14.940 --> 26:15.940
行为不符

26:15.940 --> 26:17.940
因为我们知道这个id

26:17.940 --> 26:19.940
他是可能是来自于用户的

26:19.940 --> 26:21.940
那么用户他肯定可以搞任何东西

26:21.940 --> 26:22.940
id进来

26:22.940 --> 26:24.940
id是来自于用户的

26:24.940 --> 26:26.940
那么用户可能因为导乱

26:26.940 --> 26:28.940
他的id里面写了任何

26:28.940 --> 26:30.940
就凭借了一段舍口语句

26:30.940 --> 26:31.940
导致你最终凭借到

26:31.940 --> 26:33.940
整体的舍口语句变了样子

26:33.940 --> 26:35.940
跟你的预期就不一样了

26:35.940 --> 26:37.940
导致了一些危险性的行为发生

26:37.940 --> 26:39.940
那么如何来避免这一点呢

26:39.940 --> 26:41.940
并不是说我把这个

26:41.940 --> 26:43.940
多条舍口语句去掉就不行

26:43.940 --> 26:44.940
就完事了

26:44.940 --> 26:45.940
因为去掉这个东西的时候

26:45.940 --> 26:46.940
有的时候他查询

26:46.940 --> 26:47.940
哪怕你不要说

26:47.940 --> 26:49.940
因为我们也可能会增加一条数据

26:49.940 --> 26:50.940
对不对

26:50.940 --> 26:51.940
可能会增加一条数据

26:51.940 --> 26:53.940
或者是修改一条数据

26:53.940 --> 26:55.940
比方我们修改一条数据的时候

26:55.940 --> 26:56.940
他可能会给你导乱

26:56.940 --> 26:58.940
给你改了一些东西进来

26:58.940 --> 27:00.940
因此我们总之

27:00.940 --> 27:01.940
我们不希望用户

27:01.940 --> 27:03.940
能够改动我们整个舍口语句

27:03.940 --> 27:04.940
我们希望这个地方

27:04.940 --> 27:05.940
随便你写啥

27:05.940 --> 27:06.940
你写啥无所谓

27:06.940 --> 27:07.940
但是呢

27:07.940 --> 27:09.940
我不是用制服串的拼接的方式

27:09.940 --> 27:10.940
因为拼接出来

27:10.940 --> 27:11.940
就是一个完整的舍口语句了

27:11.940 --> 27:13.940
我希望用的是什么呢

27:13.940 --> 27:15.940
用的是变量的方式

27:15.940 --> 27:17.940
在麦舍口里边

27:17.940 --> 27:19.940
麦舍口支持变量

27:21.940 --> 27:23.940
变量的内容

27:23.940 --> 27:25.940
变量的内容

27:25.940 --> 27:28.940
不作为任何舍口关键制

27:28.940 --> 27:30.940
就是变量里边随便写啥

27:30.940 --> 27:31.940
哪怕你写的这个东西

27:31.940 --> 27:32.940
就这个地方

27:32.940 --> 27:33.940
我们把它当成一个麦舍口的变量

27:33.940 --> 27:35.940
那么哪怕你写的这个东西

27:35.940 --> 27:36.940
他也是认为

27:36.940 --> 27:37.940
id

27:37.940 --> 27:39.940
我是一个查询语句

27:39.940 --> 27:40.940
查的是什么呢

27:40.940 --> 27:41.940
查的是id

27:41.940 --> 27:44.940
等于这个值的员工

27:44.940 --> 27:45.940
当然你这样子查不到

27:45.940 --> 27:46.940
对吧

27:46.940 --> 27:47.940
查不到的他并不影响

27:47.940 --> 27:49.940
整个舍口语句的功能

27:49.940 --> 27:50.940
明白这个意思吧

27:50.940 --> 27:51.940
他不像这样子

27:51.940 --> 27:52.940
就改变了整个舍口语句的功能了

27:52.940 --> 27:53.940
因为我们如果说

27:53.940 --> 27:54.940
一旦使用变量的话

27:54.940 --> 27:55.940
那么这个地方呢

27:55.940 --> 27:57.940
他只能是一个查询条件

27:57.940 --> 27:58.940
id等于某一个值

27:58.940 --> 27:59.940
他不会改变

27:59.940 --> 28:00.940
整个舍口语句的功能

28:00.940 --> 28:01.940
他就这么个意思

28:01.940 --> 28:03.940
我们学后段的时候

28:03.940 --> 28:04.940
会告诉大家

28:04.940 --> 28:05.940
这个东西叫做

28:05.940 --> 28:06.940
预编译舍口语句

28:06.940 --> 28:08.940
那么这个东西怎么来做呢

28:08.940 --> 28:09.940
在麦舍口这个loader

28:09.940 --> 28:10.940
cool里边怎么来做呢

28:10.940 --> 28:12.940
你看他的官方文章说明

28:12.940 --> 28:13.940
他告诉你

28:15.940 --> 28:16.940
在哪儿 在这儿

28:17.940 --> 28:18.940
他说使用prepared

28:18.940 --> 28:20.940
就是已经准备好的statement

28:20.940 --> 28:22.940
准备好的那个

28:23.940 --> 28:24.940
怎么翻译呢

28:24.940 --> 28:25.940
这个东西就叫做

28:25.940 --> 28:26.940
预编译的舍口语句

28:27.940 --> 28:28.940
那怎么来用呢

28:28.940 --> 28:29.940
其实非常简单

28:29.940 --> 28:31.940
你这里创建好连接一样的

28:31.940 --> 28:32.940
连接创建是一样的

28:32.940 --> 28:33.940
只不过你运行的时候

28:33.940 --> 28:34.940
你不再运行carrot

28:34.940 --> 28:36.940
你运行execute

28:36.940 --> 28:37.940
叫做执行

28:37.940 --> 28:38.940
看一下

28:38.940 --> 28:39.940
就说你运行的时候

28:39.940 --> 28:40.940
应该怎么运行呢

28:40.940 --> 28:42.940
应该运行的是execute

28:42.940 --> 28:43.940
执行

28:44.940 --> 28:45.940
执行的时候

28:45.940 --> 28:46.940
舍口语句里边

28:46.940 --> 28:47.940
是不能用拼接的

28:47.940 --> 28:49.940
凡是来自于外部的内容

28:49.940 --> 28:50.940
你应该来

28:50.940 --> 28:51.940
应该写个问号

28:52.940 --> 28:53.940
这个地方应该写个问号

28:53.940 --> 28:54.940
面对是吧

28:55.940 --> 28:56.940
那么这个问号位置

28:56.940 --> 28:57.940
是啥呢

28:57.940 --> 28:58.940
好

28:58.940 --> 28:59.940
第二个参数

28:59.940 --> 29:00.940
第二个参数

29:00.940 --> 29:01.940
就是一个数组

29:01.940 --> 29:02.940
这个数组呢

29:02.940 --> 29:03.940
一次指定

29:03.940 --> 29:04.940
每一个问号位置是啥

29:04.940 --> 29:05.940
因为这里边有可能有多个问号

29:05.940 --> 29:06.940
比如说

29:06.940 --> 29:08.940
还要可能根据名字来查询

29:08.940 --> 29:10.940
or什么name等于什么

29:10.940 --> 29:12.940
可能有多个东西

29:12.940 --> 29:13.940
因此呢

29:13.940 --> 29:14.940
你这里呢

29:14.940 --> 29:15.940
在数组里边

29:15.940 --> 29:16.940
一次来指定

29:16.940 --> 29:17.940
问号位置是什么

29:17.940 --> 29:18.940
比方说

29:18.940 --> 29:19.940
这个问号位置是什么呢

29:19.940 --> 29:20.940
id

29:20.940 --> 29:21.940
对不对

29:21.940 --> 29:22.940
他就把这个id

29:22.940 --> 29:23.940
给第一个问号

29:23.940 --> 29:24.940
注意哦

29:24.940 --> 29:25.940
他不是用制服装

29:25.940 --> 29:27.940
是用mysuckle的变量的模式

29:27.940 --> 29:28.940
那么变量模式到底怎么写的

29:28.940 --> 29:29.940
我们不用去深究

29:29.940 --> 29:30.940
那么在

29:30.940 --> 29:32.940
他用变量的模式广阵里边填

29:32.940 --> 29:33.940
填的时候他就不会

29:33.940 --> 29:34.940
因为这个搜索语句

29:34.940 --> 29:35.940
他的整个功能

29:35.940 --> 29:36.940
就已经预编译好了

29:36.940 --> 29:37.940
什么叫预编译

29:37.940 --> 29:38.940
就是我们先把它编译一次

29:38.940 --> 29:40.940
把这个搜索语句的功能

29:40.940 --> 29:41.940
在运行之前

29:41.940 --> 29:42.940
就把编译一次

29:42.940 --> 29:43.940
那么他的整个结构

29:43.940 --> 29:44.940
就出来了

29:44.940 --> 29:45.940
有setex

29:45.940 --> 29:46.940
setex什么的新号

29:46.940 --> 29:47.940
插达表

29:47.940 --> 29:48.940
插inploy表

29:48.940 --> 29:49.940
条件是什么呢

29:49.940 --> 29:50.940
id

29:50.940 --> 29:51.940
整个搜索语句的结构

29:51.940 --> 29:52.940
完全固定了

29:52.940 --> 29:53.940
然后再也不可能

29:53.940 --> 29:55.940
改变这个搜索语句的结构了

29:55.940 --> 29:56.940
原来是吧

29:56.940 --> 29:57.940
那么之后呢

29:57.940 --> 29:58.940
你随便这里写什么

29:58.940 --> 30:00.940
它只是当成一个普通的文笨

30:00.940 --> 30:01.940
那么放到这个位置

30:01.940 --> 30:02.940
这个时候呢

30:02.940 --> 30:03.940
还不可能出现刚才的情况了

30:03.940 --> 30:05.940
咱们来试一下

30:05.940 --> 30:07.940
表面变成exqt过后呢

30:07.940 --> 30:08.940
咱们来看一下

30:08.940 --> 30:10.940
会不会导致搜索语句

30:10.940 --> 30:13.940
打开我们的控制台

30:13.940 --> 30:14.940
运行

30:14.940 --> 30:15.940
你看

30:15.940 --> 30:16.940
是不是查出来一个空数组

30:16.940 --> 30:17.940
对吧

30:17.940 --> 30:18.940
查不出来的东西

30:18.940 --> 30:19.940
但是他没有改变

30:19.940 --> 30:20.940
这个查询语句的功能

30:20.940 --> 30:21.940
对不对

30:22.940 --> 30:23.940
因为你

30:23.940 --> 30:24.940
我这个就是个查询语句

30:24.940 --> 30:25.940
你永远只能

30:25.940 --> 30:26.940
把他当成查询语句

30:26.940 --> 30:27.940
只不过你给我写的字

30:27.940 --> 30:28.940
我查不出来

30:28.940 --> 30:29.940
查不出来

30:29.940 --> 30:30.940
无所谓吧

30:30.940 --> 30:31.940
对吧

30:31.940 --> 30:32.940
对我们也没什么影响

30:32.940 --> 30:33.940
这就是

30:33.940 --> 30:34.940
你们以后呢

30:34.940 --> 30:35.940
写搜索语句

30:35.940 --> 30:37.940
我就这里就直接规定了

30:37.940 --> 30:39.940
不能使用query

30:39.940 --> 30:40.940
应该去使用什么

30:40.940 --> 30:41.940
exqt

30:41.940 --> 30:42.940
对不对

30:42.940 --> 30:43.940
我这里给大家解释一下

30:43.940 --> 30:45.940
要防止搜索语句

30:45.940 --> 30:46.940
这是关于这个点

30:46.940 --> 30:47.940
另外一个点

30:47.940 --> 30:48.940
再说一下这个

30:48.940 --> 30:50.940
Connecting Pools

30:50.940 --> 30:53.940
这个东西是连接池

30:53.940 --> 30:54.940
啥意思呢

30:54.940 --> 30:55.940
就是说我们在做

30:55.940 --> 30:56.940
连接的时候

30:56.940 --> 30:57.940
我们刚才画个图

30:57.940 --> 30:59.940
我们在做连接的时候

30:59.940 --> 31:00.940
这是我们的load

31:00.940 --> 31:02.940
然后这是我们的数据库

31:02.940 --> 31:03.940
一个连接

31:03.940 --> 31:04.940
然后这里边

31:04.940 --> 31:05.940
是不是可以发送

31:05.940 --> 31:06.940
多条社会语句

31:06.940 --> 31:07.940
对不对

31:07.940 --> 31:09.940
我们可以用同一个连接

31:09.940 --> 31:11.940
用同一个连接

31:11.940 --> 31:12.940
我们这里运行一次

31:12.940 --> 31:13.940
可以再继续运行

31:13.940 --> 31:14.940
不运行的过去

31:14.940 --> 31:15.940
就把关掉

31:15.940 --> 31:16.940
对不对

31:16.940 --> 31:17.940
我们这里可以用这种模式

31:17.940 --> 31:19.940
那如果说

31:19.940 --> 31:21.940
我们一次用户的请求

31:21.940 --> 31:22.940
因为我们要根据用户请求

31:22.940 --> 31:23.940
请求到他们服务器

31:23.940 --> 31:24.940
服务器的时候

31:24.940 --> 31:25.940
那就会去操作数据库

31:25.940 --> 31:26.940
那这个时候同时

31:26.940 --> 31:28.940
来了50个用户请求

31:28.940 --> 31:29.940
那么我们服务器

31:29.940 --> 31:30.940
是不是要去运行这个函数

31:30.940 --> 31:32.940
一个请求叫运行

31:32.940 --> 31:33.940
是个函数

31:33.940 --> 31:34.940
查一个用户ID

31:34.940 --> 31:35.940
那么

31:35.940 --> 31:36.940
是不是服务器开了50个

31:36.940 --> 31:38.940
跟数据库之间的连接

31:38.940 --> 31:39.940
对不对

31:39.940 --> 31:40.940
开了很多很多的连接

31:40.940 --> 31:42.940
而这个连接呢

31:42.940 --> 31:43.940
如果说你不小心

31:43.940 --> 31:44.940
没有释放

31:44.940 --> 31:45.940
就是没有去N的

31:45.940 --> 31:46.940
那么这个连接呢

31:46.940 --> 31:47.940
会越来越多

31:47.940 --> 31:48.940
越来越多

31:48.940 --> 31:50.940
占用了大量的服务器支援

31:50.940 --> 31:52.940
这是肯定是不好的

31:52.940 --> 31:54.940
而且连接开多了过后

31:54.940 --> 31:56.940
也会导致服务器异常的卡顿

31:56.940 --> 31:58.940
那么这个时候怎么办呢

31:58.940 --> 31:59.940
这个时候呢

31:59.940 --> 32:00.940
他就告诉你

32:00.940 --> 32:02.940
你可以使用他的连接池

32:02.940 --> 32:03.940
什么叫连接池呢

32:03.940 --> 32:04.940
你可以把它想象成一个数组

32:04.940 --> 32:05.940
一个池子

32:05.940 --> 32:06.940
就是一个数组

32:06.940 --> 32:07.940
这个数组里面

32:07.940 --> 32:08.940
保存了很多的连接对象

32:08.940 --> 32:10.940
他帮你来进行管理

32:10.940 --> 32:11.940
然后呢

32:11.940 --> 32:12.940
这个连接

32:12.940 --> 32:13.940
这个数组里面有一个最大长度

32:13.940 --> 32:14.940
就是你不能超过这个长度

32:14.940 --> 32:15.940
比方说10个

32:15.940 --> 32:16.940
我们这个系统里面

32:16.940 --> 32:17.940
最多就是10个连接

32:17.940 --> 32:19.940
那么哪怕你50个用户过来了

32:19.940 --> 32:20.940
也要排队

32:20.940 --> 32:22.940
我这个10个连接里面

32:22.940 --> 32:23.940
有些连接空闲了

32:23.940 --> 32:24.940
然后呢就给力

32:24.940 --> 32:26.940
没有空闲的就过等着排队

32:26.940 --> 32:27.940
他是用这种模式

32:27.940 --> 32:29.940
这种模式就避免了服务器支援

32:29.940 --> 32:30.940
被大量的占用

32:30.940 --> 32:32.940
这是一种非常非常好的模式

32:32.940 --> 32:33.940
绝大部分的时候呢

32:33.940 --> 32:35.940
我们都要应该去使用连接池

32:35.940 --> 32:37.940
而不应该去直接使用连接

32:37.940 --> 32:38.940
其实建立连接池

32:38.940 --> 32:39.940
在 bicycle 2 里面

32:39.940 --> 32:40.940
特别特别简单

32:40.940 --> 32:42.940
就是一个 create pool

32:42.940 --> 32:43.940
那么这里

32:43.940 --> 32:44.940
你看啊

32:44.940 --> 32:46.940
我们就不是不是个

32:46.940 --> 32:47.940
create pool

32:47.940 --> 32:49.940
创建一个连接池

32:49.940 --> 32:51.940
从一个连接池里边

32:51.940 --> 32:52.940
去得到连接

32:52.940 --> 32:53.940
那么这个连接池

32:53.940 --> 32:55.940
实际上我们只需要

32:55.940 --> 32:56.940
一个就够了

32:56.940 --> 32:57.940
只需要一个就够了

32:57.940 --> 32:59.940
所以说我们这里完全可以

32:59.940 --> 33:00.940
写到这儿

33:00.940 --> 33:01.940
你看

33:01.940 --> 33:02.940
这里呢

33:02.940 --> 33:03.940
我们直接写到这儿

33:03.940 --> 33:04.940
复制一下

33:04.940 --> 33:08.320
我们这里呢

33:08.320 --> 33:14.170
得到一个 pool

33:14.170 --> 33:16.170
得到一个连接

33:16.170 --> 33:21.210
得到一个连接池

33:21.210 --> 33:22.210
那么之后呢

33:22.210 --> 33:24.210
我们就直接使用那个 pool

33:24.210 --> 33:26.210
我们要剩下的时候呢

33:26.210 --> 33:28.210
就全部使用同一个连接池

33:28.210 --> 33:30.210
来去搞定剩下的事情

33:30.210 --> 33:31.210
那怎么来使用呢

33:31.210 --> 33:33.210
使用的方式跟那个连接

33:33.210 --> 33:34.210
是完全一样的

33:34.210 --> 33:35.210
而且呢

33:35.210 --> 33:36.210
你不用去关闭

33:36.210 --> 33:38.210
它会自动帮你搞定

33:38.210 --> 33:39.210
搞定那个连接的

33:39.210 --> 33:40.210
就是连接池的回收

33:40.210 --> 33:41.210
以及重用

33:41.210 --> 33:42.210
它会自动帮你搞定

33:42.210 --> 33:43.210
你直接用就行了

33:43.210 --> 33:44.210
是不是特别简单

33:44.210 --> 33:45.210
这就是这一块

33:45.210 --> 33:46.210
使用那个 pool

33:46.210 --> 33:48.210
来帮助你完成查询

33:48.210 --> 33:49.210
咱们来试一下

33:49.210 --> 33:51.210
弄的运行

33:51.210 --> 33:52.210
你看

33:52.210 --> 33:53.210
是不是搞定了

33:53.210 --> 33:54.210
对不对

33:54.210 --> 33:56.210
那么这里呢

33:56.210 --> 33:57.210
停止

33:57.210 --> 33:59.210
所以完全一样的效果

33:59.210 --> 34:01.210
这是关于使用连接池

34:01.210 --> 34:02.210
特别简单

34:02.210 --> 34:03.210
这是 crazy pool

34:03.210 --> 34:04.210
连接池里边

34:04.210 --> 34:05.210
其实还有一些配置

34:05.210 --> 34:06.210
我给它说一下

34:06.210 --> 34:08.210
一个是 with for connection

34:08.210 --> 34:09.210
表示的是什么呢

34:09.210 --> 34:10.210
就是说

34:10.210 --> 34:11.210
如果说

34:11.210 --> 34:12.210
你的

34:12.210 --> 34:13.210
你的就是

34:13.210 --> 34:14.210
有个新的连接

34:14.210 --> 34:15.210
希望用一个新的连接

34:15.210 --> 34:17.210
但是连接池里边呢

34:17.210 --> 34:18.210
已经

34:18.210 --> 34:19.210
已经

34:19.210 --> 34:21.210
所有的连接都已经在被使用了

34:21.210 --> 34:22.210
要不要等待

34:22.210 --> 34:24.210
如果说你这里写的是 force

34:24.210 --> 34:25.210
它默认就是去

34:25.210 --> 34:26.210
一般来说我们都要等待的

34:26.210 --> 34:28.210
如果说你不等待的话

34:28.210 --> 34:29.210
那么这个这一次的连接

34:29.210 --> 34:30.210
就直接爆错了

34:30.210 --> 34:31.210
你用不了连接了

34:31.210 --> 34:32.210
没有可用的连接了

34:32.210 --> 34:33.210
好这个

34:33.210 --> 34:34.210
这个东西是怎么来的

34:34.210 --> 34:35.210
表示连接池里边

34:35.210 --> 34:36.210
最大的连接数量

34:36.210 --> 34:37.210
一般就是10个

34:37.210 --> 34:38.210
它默认直接是10个

34:38.210 --> 34:39.210
q

34:39.210 --> 34:40.210
limit

34:40.210 --> 34:41.210
表示什么意思呢

34:41.210 --> 34:42.210
就是排队

34:42.210 --> 34:43.210
如果说你

34:43.210 --> 34:44.210
连接不够用了

34:44.210 --> 34:45.210
那么后边来的东西

34:45.210 --> 34:46.210
你要得到连接

34:46.210 --> 34:47.210
你需要排队

34:47.210 --> 34:48.210
排队的时候呢

34:48.210 --> 34:50.210
队你也去队有多长

34:50.210 --> 34:51.210
能够排多少人

34:51.210 --> 34:52.210
咱也等

34:52.210 --> 34:54.210
那么如果说你写零的话

34:54.210 --> 34:55.210
不限制长度

34:55.210 --> 34:56.210
随便多长

34:56.210 --> 34:57.210
慢慢等呗

34:57.210 --> 34:58.210
我们一般就写零

34:58.210 --> 34:59.210
懂这个意思吧

34:59.210 --> 35:00.210
这几个参数

35:00.210 --> 35:01.210
一般不用去动它就可以了

35:01.210 --> 35:03.210
那就是使用连接池的方式

35:03.210 --> 35:04.210
ok

35:04.210 --> 35:06.210
那么这里是mysuckle的

35:06.210 --> 35:07.210
这么一个

35:07.210 --> 35:09.210
mysuckle2的这么一个使用方式

35:09.210 --> 35:10.210
对

35:10.210 --> 35:11.210
刚才还忘了说一个

35:11.210 --> 35:13.210
刚才还再说另外一个东西

35:13.210 --> 35:14.210
就是我们查询的时候

35:14.210 --> 35:15.210
有可能是模糊查询

35:15.210 --> 35:16.210
比方说

35:16.210 --> 35:18.210
咱们查询的是nate

35:18.210 --> 35:20.210
它是用了什么nike

35:20.210 --> 35:21.210
模糊查询

35:21.210 --> 35:22.210
然后模糊查询

35:22.210 --> 35:24.210
这里没转移

35:24.210 --> 35:26.210
模糊查询的时候呢

35:26.210 --> 35:27.210
不是这样的写的吗

35:27.210 --> 35:28.210
模糊查询

35:28.210 --> 35:30.210
就是两个百分号

35:30.210 --> 35:31.210
中间写一个东西

35:31.210 --> 35:32.210
那么这个时候

35:32.210 --> 35:33.210
你不能写问号了

35:33.210 --> 35:34.210
因为你是问号写到

35:34.210 --> 35:36.210
写到的是字无创里面

35:36.210 --> 35:37.210
那么它就查询的是什么呢

35:37.210 --> 35:39.210
包含问号的名字

35:39.210 --> 35:41.210
这就是这么一个意思

35:41.210 --> 35:42.210
所以这个问号

35:42.210 --> 35:43.210
你要把它当成变量

35:43.210 --> 35:44.210
怎么办呢

35:44.210 --> 35:45.210
你要这样子写

35:46.210 --> 35:47.210
所以我们讲过的

35:47.210 --> 35:48.210
数据库里面的

35:48.210 --> 35:49.210
康凯斯汉数

35:49.210 --> 35:50.210
连接一个百分号

35:50.210 --> 35:51.210
第二个是问号

35:51.210 --> 35:53.210
第三个又是百分号

35:53.210 --> 35:55.210
你要用这个方式来写

35:55.210 --> 35:56.210
咱们来试一下模糊查询

35:56.210 --> 35:57.210
那么这个tester

35:57.210 --> 35:59.210
我们写一个模糊查询

35:59.210 --> 36:01.210
模糊查询

36:01.210 --> 36:02.210
查询

36:02.210 --> 36:04.210
新元的

36:04.210 --> 36:07.520
我的名字

36:07.520 --> 36:12.050
在这

36:12.050 --> 36:14.050
试一下吧

36:14.050 --> 36:16.050
运行

36:16.050 --> 36:17.050
是不是查出来了

36:17.050 --> 36:19.050
所有包含语言这个字的

36:19.050 --> 36:20.050
所有学生

36:20.050 --> 36:21.050
所有的员工

36:21.050 --> 36:22.050
是不是都查出来了

36:22.050 --> 36:24.050
这是关于这一课

36:24.050 --> 36:26.050
那么mysuckle2就讲完了

36:26.050 --> 36:27.050
特别特别简单

36:27.050 --> 36:28.050
就是我们知道的

36:28.050 --> 36:29.050
漏的接询里面

36:29.050 --> 36:30.050
去操作说一课

36:30.050 --> 36:31.050
就这么简单

36:31.050 --> 36:33.050
直接使用它的接口

36:33.050 --> 36:34.050
然后发送收口语

36:34.050 --> 36:35.050
就完事了

36:35.050 --> 36:36.050
对不对

36:36.050 --> 36:37.050
那么我这里

36:37.050 --> 36:38.050
给大家预告一下

36:38.050 --> 36:39.050
那就讲完了

36:39.050 --> 36:40.050
其实也没啥了

36:40.050 --> 36:42.050
但是为什么我们平时

36:42.050 --> 36:44.050
直接使用mysuckle2的场景

36:44.050 --> 36:45.050
多不多

36:45.050 --> 36:47.050
其实没有那么多

36:47.050 --> 36:48.050
因为不好用

36:48.050 --> 36:49.050
还是不好用

36:49.050 --> 36:51.050
尽管它比mysuckle2

36:51.050 --> 36:52.050
多了一个promise

36:52.050 --> 36:53.050
还好用一些

36:53.050 --> 36:54.050
但是还是不好用

36:54.050 --> 36:55.050
为啥呢

36:55.050 --> 36:57.050
是这样子

36:57.050 --> 36:58.050
你要操作数据够

36:58.050 --> 37:00.050
你再建表吧

37:00.050 --> 37:01.050
对不对

37:01.050 --> 37:02.050
你是不是在建表

37:02.050 --> 37:03.050
建了表过后

37:03.050 --> 37:05.050
这里边是不是查出了对象

37:05.050 --> 37:06.050
对不对

37:06.050 --> 37:07.050
是不是查出了对象

37:07.050 --> 37:08.050
如果说你以后

37:08.050 --> 37:09.050
学了ts语言

37:09.050 --> 37:10.050
TypeScript

37:10.050 --> 37:11.050
那么我们是不是

37:11.050 --> 37:12.050
在程序里边

37:12.050 --> 37:13.050
还要去建立一个

37:13.050 --> 37:15.050
相关的对象的

37:15.050 --> 37:16.050
每一个字段的类型

37:16.050 --> 37:17.050
对不对

37:17.050 --> 37:18.050
还是不是要去对应一下

37:18.050 --> 37:19.050
就特别麻烦

37:19.050 --> 37:21.050
那有没有一种方式

37:21.050 --> 37:24.050
我们可以达到数据库

37:24.050 --> 37:27.050
跟我们的程序里面的对象

37:27.050 --> 37:28.050
是完全统一的呢

37:28.050 --> 37:29.050
你看我们这里

37:29.050 --> 37:30.050
查出来的对象

37:30.050 --> 37:31.050
凭什么是这个对象呢

37:31.050 --> 37:32.050
对不对

37:32.050 --> 37:33.050
我们程序里面

37:33.050 --> 37:34.050
有没有定义

37:34.050 --> 37:35.050
那如果说

37:35.050 --> 37:36.050
我们在程序里面

37:36.050 --> 37:37.050
定义了这个对象

37:37.050 --> 37:38.050
那数据库那边

37:38.050 --> 37:39.050
要跟数据库

37:39.050 --> 37:40.050
要完全一致

37:40.050 --> 37:41.050
那有没有一个东西

37:41.050 --> 37:42.050
就是我们只定义一次

37:42.050 --> 37:43.050
它既可以用在数据库

37:43.050 --> 37:44.050
又可以用在

37:44.050 --> 37:46.050
我们的那个程序里面的

37:46.050 --> 37:47.050
可能这样的描述

37:47.050 --> 37:48.050
大家还比较模糊

37:48.050 --> 37:49.050
我们下面可以

37:49.050 --> 37:50.050
详细的讲

37:50.050 --> 37:51.050
这些需要使用

37:51.050 --> 37:52.050
ORM框架

37:52.050 --> 37:54.050
所有的后端

37:54.050 --> 37:55.050
只要是一个

37:55.050 --> 37:56.050
成熟的后端语言

37:56.050 --> 37:59.050
它一定有ORM框架

37:59.050 --> 38:01.050
比方说那个

38:01.050 --> 38:03.050
Java里面的Hyperlates

38:03.050 --> 38:04.050
对不对

38:04.050 --> 38:05.050
或者是Csharp里面的

38:05.050 --> 38:06.050
NTTFreework

38:06.050 --> 38:07.050
都是ORM框架

38:07.050 --> 38:09.050
那么load.js里面

38:09.050 --> 38:11.050
也有ORM框架

38:11.050 --> 38:13.050
我们下面可以来详细的说

38:13.050 --> 38:14.050
ORM框架使用了之后

38:14.050 --> 38:16.050
它要比这种方式

38:16.050 --> 38:17.050
要优雅的多

38:17.050 --> 38:18.050
你也不用去直接

38:18.050 --> 38:19.050
写收口语去的

38:19.050 --> 38:21.050
我们下面可以慢慢来说

38:21.050 --> 38:22.050
为什么需要ORM框架

