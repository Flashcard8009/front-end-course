WEBVTT

00:00.560 --> 00:03.760
好 咱们这节课呢 学习文件 I.O

00:04.760 --> 00:08.560
呃 也就是说 说直白点啊 就是跟文件之间怎么来互操作

00:08.560 --> 00:12.260
怎么去读取一个文件 怎么去向文件里边写入内容

00:12.460 --> 00:15.660
因为我们漏的呢 是运行在操作系统上面的 对吧

00:15.660 --> 00:18.560
就是它可以去操作我们的操作系统里边的文件

00:18.960 --> 00:20.860
那这这个 I.O 是什么意思呢

00:20.860 --> 00:24.960
这个 I.O 呢 我解释一下啊 它叫做 Input Output

00:25.160 --> 00:28.160
就是输入输出 那我们把它统称为输入

00:28.160 --> 00:32.760
就是 I.O 设备 I.O 设备 就是重称为输入输出设备

00:33.360 --> 00:37.960
那么什么叫做输入输出设备呢 有哪些东西是输入输出设备呢

00:38.360 --> 00:42.160
凡是对外部设备的输入输出 我们都称为 I.O

00:43.060 --> 00:47.560
什么叫外部设备 就是不是计算机的 CPU 也不是内存

00:47.560 --> 00:50.360
对吧 我们的程序都是 CPU 跟内存之间打交道

00:50.460 --> 00:54.660
对吧 除了这两个之外 那么其他的东西呢 我们都可以称为外部设备

00:55.060 --> 00:57.960
比方说像我们的磁盘 我们的硬盘没想到吧

00:58.460 --> 01:00.860
它是一个外部设备 我们把它称为外部设备

01:00.960 --> 01:03.560
它可以持久的来存出我们的数据

01:04.560 --> 01:08.260
然后我们的网卡 对吧 利用网卡我们要上网

01:08.260 --> 01:12.160
肯定要通过网卡去发送一个请求去传输数据

01:12.360 --> 01:14.860
那么这里呢 它也是属于一个外部设备

01:14.960 --> 01:19.860
像显卡的外部设备 打印机或者其他玩意都属于外部设备

01:20.460 --> 01:23.460
那么像针对这对外部设备的

01:24.060 --> 01:26.260
传输数据呢 我们就称为 I.O

01:26.760 --> 01:30.460
像外部设备 表现像磁盘里边写入一个内容

01:30.860 --> 01:32.460
那么就是 input 对吧

01:33.060 --> 01:35.960
从磁盘里边读一个内容出来 那么就是 output

01:36.260 --> 01:40.760
针对外部设备里边的输入输出了 我们就称为 I.O

01:42.360 --> 01:45.060
那么我们这一课 肯定是学的是文件 I.O

01:45.060 --> 01:46.760
稍后呢 我们还会学习

01:47.660 --> 01:50.560
之后我们还会学习关于网卡的一部分 I.O

01:52.860 --> 01:54.660
然后当然这里肯定是学不完

01:54.660 --> 01:57.660
你说怎么去操作GPU 怎么去操作显卡 操作打印机

01:57.660 --> 02:00.260
这些东西我们就不扯了 不扯那么远了

02:00.660 --> 02:02.260
你跟我们这门客也没什么关系

02:02.860 --> 02:04.460
我们这里得学的是文件 I.O

02:04.660 --> 02:07.660
一个点了大家要注意 就是 I.O

02:07.660 --> 02:09.460
就是所有的 I.O 设备

02:10.060 --> 02:14.760
它的读写速度呢 往往是低于内存和 CPU 的交互速度

02:15.260 --> 02:16.860
就是我们内存的速度是很坏的

02:17.460 --> 02:19.460
CPU它只跟内存之间打交道

02:20.260 --> 02:23.660
你可能大家可能有误解 认为CPU还可以去读曲硬盘

02:23.860 --> 02:26.260
不会的 不会的 它不会去读曲硬盘的

02:26.960 --> 02:28.860
它CPU只跟内存之间打交道

02:29.260 --> 02:32.260
所以说我们要去通过跟 I.O 设备来交互的话

02:32.460 --> 02:35.060
我们得想办法把 I.O 设备的东西读到内存

02:36.060 --> 02:37.460
我们要写入 I.O 设备的话

02:37.460 --> 02:40.460
我们得把内存里边的东西放到 I.O 设备里边去

02:41.360 --> 02:42.660
CPU它只跟内存打交道

02:43.460 --> 02:45.060
如果说这个东西就点到为止了

02:45.060 --> 02:46.260
这个东西说起来就没完了

02:46.860 --> 02:48.060
我给大家推荐一本书

02:49.460 --> 02:51.060
如果说你们工作 现在不要看

02:51.060 --> 02:52.860
现在看你也会怀疑人生的

02:53.660 --> 02:57.660
你们将来工作了四到五年之后

02:57.860 --> 03:01.060
你还要往深入的方向去挖掘的话

03:01.060 --> 03:02.260
你可以看一下这本书

03:05.150 --> 03:06.550
就是现代操作系统

03:06.750 --> 03:09.750
那么这本书我建议大家去看那个原版

03:10.150 --> 03:10.950
看英文版

03:11.550 --> 03:13.350
不是现在 现在你肯定有点牢火

03:13.950 --> 03:15.950
四五年之后 你看一下这本书

03:15.950 --> 03:17.950
因为中文版我看了一下

03:18.350 --> 03:20.350
我家里面买过 中文版也买过英文版

03:21.350 --> 03:22.550
看了一下这个书

03:22.550 --> 03:24.150
中文版翻译的你可能看不懂

03:24.550 --> 03:25.750
你每一个字都认识

03:25.950 --> 03:27.150
就是不知道他在说啥

03:27.750 --> 03:28.350
翻译的

03:28.750 --> 03:30.350
就有些东西确实很难翻译

03:32.350 --> 03:33.950
我也希望咱们这国家

03:34.950 --> 03:38.750
随着发展 咱们技术水平越来越厉害

03:39.250 --> 03:42.250
以后我们领先全世界让全世界来学中文

03:42.250 --> 03:44.150
我也希望这里点到现在还做不到

03:44.650 --> 03:46.550
所以说你们建议大家看英文版

03:46.550 --> 03:49.250
因为原版的话它里边还是比较好懂的

03:49.850 --> 03:51.850
也没有用到特别深的句子

03:52.650 --> 03:54.150
这些我也随便说点题外话

03:54.150 --> 03:56.150
所以说这一块我们就点到极值

03:56.150 --> 03:58.450
不然的话就说起来就没完了

03:59.650 --> 04:01.450
然后我们这里学习的文件

04:01.450 --> 04:04.550
还有我们主要学习的是loads.js里边

04:04.550 --> 04:05.950
给我们提供了一个模块

04:05.950 --> 04:06.950
FS模块

04:07.050 --> 04:08.050
通过这个模块

04:08.050 --> 04:10.850
我们可以通过跟操作系统的文件系统

04:10.850 --> 04:11.650
来打交道

04:12.450 --> 04:14.250
这个模块里边我们主要学习

04:14.250 --> 04:16.950
它里面功能很多 非常非常多

04:17.150 --> 04:18.250
大家有兴趣的话

04:18.750 --> 04:20.150
可以去看一下它的官网

04:20.750 --> 04:22.450
我这里把个链接地址放过来吧

04:26.650 --> 04:27.850
在Docs

04:28.950 --> 04:29.550
这里边

04:30.450 --> 04:31.650
这是长期知识吧

04:32.350 --> 04:34.750
然后我们找到这个File System

04:34.950 --> 04:36.750
我们把这个地方复制一下

04:37.150 --> 04:37.750
拿过来

04:39.850 --> 04:41.350
大家可以看一下这个官网

04:41.350 --> 04:43.850
它里边API非常非常多 多的吓死人

04:44.650 --> 04:47.150
因为文件系统实际上是非常复杂的

04:47.250 --> 04:49.450
大家可能会觉得文件系统不究极很简单

04:49.450 --> 04:50.150
一个文件

04:50.750 --> 04:52.250
读 写 文件状态

04:53.050 --> 04:53.750
还有一个目录

04:54.250 --> 04:55.350
其实不是这样子的

04:55.350 --> 04:57.150
文件系统是非常非常复杂的

04:58.250 --> 04:59.850
你学了这个操作系统

04:59.850 --> 05:02.450
你如果说真的对操作系统了解得很深入的话

05:02.450 --> 05:04.250
你会知道文件系统不简单的

05:05.150 --> 05:08.950
因此我们这里肯定是不会那么深入去想起

05:09.050 --> 05:11.050
而且连后端都不会学到那么深

05:11.250 --> 05:12.050
何况文前端

05:13.150 --> 05:14.250
这里我跟大家说一下

05:14.250 --> 05:17.950
咱们只是学习FS模块里面的一些常用的API

05:17.950 --> 05:24.450
通过这些API能够满足99.9 前端的操作

05:25.050 --> 05:25.850
基本上就够了

05:26.550 --> 05:27.550
咱们来看一个

05:27.650 --> 05:29.550
一个来 第一个是read file

05:29.750 --> 05:30.350
这是什么意思呢

05:30.350 --> 05:31.550
就读一个文件

05:31.950 --> 05:34.050
咱们在代码里边给大家写一些

05:35.950 --> 05:37.950
先导入这个模块 FS

05:38.550 --> 05:40.850
比方说我这里有这么一个文件

05:42.850 --> 05:43.950
放一个目录吧

05:44.250 --> 05:48.250
files,myfiles

05:48.250 --> 05:52.250
目录下边我们给它写一些文件吧

05:52.250 --> 05:55.250
干脆在git一个load里面把它去掉

05:55.250 --> 05:57.250
上上拿着去掉了,files

05:57.250 --> 06:00.250
然后这里边写一个e.txt

06:00.250 --> 06:03.250
一个文本文件,随便写吧

06:03.250 --> 06:07.250
我要把文件内容把它读出来

06:07.250 --> 06:09.250
要做这么一件事

06:09.250 --> 06:11.250
那怎么来读呢,我们就可以利用

06:11.250 --> 06:13.250
fsreadfile

06:13.250 --> 06:16.250
那么这个readfile它要传入这么几个参数

06:16.250 --> 06:18.250
第一个是文件的路径

06:18.250 --> 06:22.250
路径的话我们就可以写相对路径

06:22.250 --> 06:24.250
但是你要清楚

06:24.250 --> 06:26.250
如果说你这样写相对路径的话

06:26.250 --> 06:27.250
它是相对于谁呢

06:27.250 --> 06:29.250
它是相对于我们的命令提示符

06:29.250 --> 06:31.250
它不是相对于这个文件

06:31.250 --> 06:33.250
它是相对于我们的命令提示符

06:33.250 --> 06:36.250
除了在require里边写上点儿写杠

06:36.250 --> 06:37.250
是相对于这个文件的

06:37.250 --> 06:39.250
其他的地方写点儿写杠

06:39.250 --> 06:41.250
都是相对于这个命令提示符的

06:41.250 --> 06:42.250
要搞清楚

06:42.250 --> 06:44.250
所以说如果说你丢用点儿写杠的话

06:44.250 --> 06:45.250
还是比较危险的

06:45.250 --> 06:48.250
因为你如果说命令提示符位置一边

06:48.250 --> 06:50.250
从别的命令提示符去运行

06:50.250 --> 06:52.250
那要出问题了,找不到文件了

06:52.250 --> 06:53.250
所以说我们一般情况下

06:53.250 --> 06:55.250
不太会去用相对路径

06:55.250 --> 06:56.250
相对路径怎么写呢

06:56.250 --> 06:58.250
就是myfiles

06:58.250 --> 07:01.250
然后写杠1.tst

07:01.250 --> 07:02.250
所以我这个文件

07:02.250 --> 07:04.250
但是我们不太会用相对路径

07:04.250 --> 07:06.250
因为它跟命令提示符有关

07:06.250 --> 07:08.250
我们希望在任何命令提示符下

07:08.250 --> 07:10.250
任何环境下运行

07:10.250 --> 07:11.250
可以读到同一个文件

07:11.250 --> 07:13.250
那么我们就必须要用绝对路径

07:13.250 --> 07:15.250
那么我们这里可以借助PASS模块

07:18.250 --> 07:19.250
就这个PASS模块

07:19.250 --> 07:21.250
PASS里不是一个resolve吗

07:21.250 --> 07:22.250
转换成解决的路径

07:22.250 --> 07:24.250
我把当前文件夹

07:24.250 --> 07:26.250
这个东西是绝对路径

07:26.250 --> 07:28.250
表示当前那个模块所在的文件夹

07:28.250 --> 07:31.250
然后后边去拼接一个这个部分

07:31.250 --> 07:32.250
对吧

07:33.250 --> 07:35.250
这个文件夹下面的myfiles

07:35.250 --> 07:37.250
这个地方

07:37.250 --> 07:39.250
我们通常都会这样来做

07:39.250 --> 07:40.250
什么的filing

07:40.250 --> 07:42.250
就是我们的整个文件路径

07:42.250 --> 07:43.250
是不是在这儿了

07:43.250 --> 07:44.250
我们把文件路径放进来

07:44.250 --> 07:45.250
读这个文件

07:45.250 --> 07:47.250
好,读的时候

07:47.250 --> 07:48.250
之后

07:48.250 --> 07:49.250
它后的第二个参数

07:49.250 --> 07:51.250
可以传入一个回调函数

07:51.250 --> 07:53.250
第二个参数其实上有两种写法

07:53.250 --> 07:55.250
一种写法是一个配置

07:55.250 --> 07:57.250
配置我们暂时不写

07:57.250 --> 07:58.250
那么我们第二个参数

07:58.250 --> 07:59.250
可以直接传一个回调函数

07:59.250 --> 08:01.250
这个回调函数的模式

08:01.250 --> 08:02.250
跟load里边

08:02.250 --> 08:04.250
所有的回调模式是一样的

08:04.250 --> 08:06.250
第一个参数是error

08:06.250 --> 08:07.250
表示有没有错误

08:07.250 --> 08:09.250
第二个参数是

08:09.250 --> 08:10.250
最终的结果

08:10.250 --> 08:11.250
就是你给力的数据

08:11.250 --> 08:13.250
给力的数据content

08:13.250 --> 08:15.250
咱们输出content

08:15.250 --> 08:16.250
看一下

08:16.250 --> 08:18.250
咱们来首先看一下

08:18.250 --> 08:20.250
然后再来来做一些解释

08:20.250 --> 08:21.250
这里我们打印出来看一下

08:21.250 --> 08:23.250
然后我们这里运行load

08:23.250 --> 08:24.250
index

08:24.250 --> 08:25.250
看一下

08:25.250 --> 08:27.250
就拿到结果了

08:27.250 --> 08:28.250
这是啥玩意儿

08:28.250 --> 08:29.250
这是个啥

08:29.250 --> 08:30.250
这是个buffer

08:30.250 --> 08:31.250
它拿到的是

08:31.250 --> 08:33.250
就是内存里边

08:33.250 --> 08:35.250
就是这个里边存的

08:35.250 --> 08:37.250
一个字节的数据

08:37.250 --> 08:38.250
每一个字节的数据

08:38.250 --> 08:39.250
因为我们知道

08:39.250 --> 08:40.250
计算基地表存东西

08:40.250 --> 08:42.250
存啥东西都是数字

08:42.250 --> 08:43.250
你写的文字

08:43.250 --> 08:44.250
它存过后

08:44.250 --> 08:45.250
用字符编码

08:45.250 --> 08:46.250
都把它转换成数字

08:46.250 --> 08:47.250
你存的是电影

08:47.250 --> 08:48.250
把它转换成编码

08:48.250 --> 08:49.250
又变成数字

08:49.250 --> 08:50.250
啥路数字

08:50.250 --> 08:51.250
除了数字

08:51.250 --> 08:52.250
它没法存

08:52.250 --> 08:54.250
计算机怎么能认识音频

08:54.250 --> 08:55.250
视频

08:55.250 --> 08:56.250
这些东西全部不认识

08:56.250 --> 08:58.250
声音视频影像

08:58.250 --> 08:59.250
以及我们的文字

08:59.250 --> 09:00.250
全部要转换成数字

09:00.250 --> 09:01.250
数字就更不要说了

09:01.250 --> 09:02.250
所以说我们内存里

09:02.250 --> 09:03.250
就是我们

09:03.250 --> 09:04.250
内存也好

09:04.250 --> 09:05.250
存的都是数字

09:05.250 --> 09:06.250
读出来就是一个

09:06.250 --> 09:07.250
二进字的

09:07.250 --> 09:09.250
把它转换成十六进字的

09:09.250 --> 09:10.250
你看

09:10.250 --> 09:11.250
两个十六进字

09:11.250 --> 09:12.250
就是一个字节

09:12.250 --> 09:13.250
两个十六进字

09:13.250 --> 09:14.250
就是一个字节

09:14.250 --> 09:15.250
它每一个字节读出来了

09:15.250 --> 09:16.250
OK

09:16.250 --> 09:17.250
那么这里就是

09:17.250 --> 09:18.250
这种读法

09:18.250 --> 09:19.250
好

09:19.250 --> 09:20.250
如果说有些同学说

09:20.250 --> 09:21.250
那我如果说

09:21.250 --> 09:22.250
我要得到它里边的字不错

09:22.250 --> 09:23.250
怎么办呢

09:23.250 --> 09:24.250
那很简单

09:24.250 --> 09:25.250
你们学过内形化数组

09:25.250 --> 09:27.250
那么这个东西里边

09:27.250 --> 09:28.250
得到的是字节

09:28.250 --> 09:29.250
字节

09:29.250 --> 09:30.250
一个字节数组

09:30.250 --> 09:31.250
那么我们这里

09:32.250 --> 09:33.250
你不要写上一个

09:33.250 --> 09:34.250
编码方式

09:34.250 --> 09:35.250
Utf8

09:35.250 --> 09:36.250
你把我这个数字

09:36.250 --> 09:37.250
用Utf8编码

09:37.250 --> 09:39.250
给我转换成文字

09:39.250 --> 09:41.250
给我转换成文字

09:41.250 --> 09:42.250
你看

09:42.250 --> 09:44.250
是不是读出来了

09:44.250 --> 09:45.250
就读出来了

09:45.250 --> 09:46.250
很简单的

09:46.250 --> 09:47.250
当然你也可以在这里

09:47.250 --> 09:48.250
它也可以提供

09:48.250 --> 09:49.250
第二个参数

09:49.250 --> 09:50.250
第二个参数是配置

09:50.250 --> 09:51.250
配置有两种写法

09:51.250 --> 09:52.250
一种是对象

09:52.250 --> 09:54.250
一种是编码的写法

09:54.250 --> 09:55.250
Utf-8

09:55.250 --> 09:56.250
你在这里

09:56.250 --> 09:58.250
如果说写上Utf-8的话

09:58.250 --> 09:59.250
它读出来就不是字节了

09:59.250 --> 10:00.250
它读出来就直接

10:00.250 --> 10:01.250
是一个字不错了

10:01.250 --> 10:02.250
它读出来的字节

10:02.250 --> 10:03.250
它会自动帮你

10:03.250 --> 10:04.250
完成编码的转换

10:04.250 --> 10:06.250
编成字不错

10:06.250 --> 10:07.250
你看

10:07.250 --> 10:08.250
是这样子是不是

10:08.250 --> 10:09.250
有这个content

10:09.250 --> 10:10.250
读出来的内容

10:10.250 --> 10:12.250
它有可能是一个buffer

10:12.250 --> 10:14.250
有可能是一个字不错

10:14.250 --> 10:15.250
看你传不传编码

10:15.250 --> 10:16.250
如果说你不传编码的话

10:16.250 --> 10:17.250
OK

10:17.250 --> 10:18.250
它就是一个buffer

10:18.250 --> 10:19.250
对吧

10:19.250 --> 10:20.250
buffer还是有用的

10:20.250 --> 10:21.250
比方说你读一些图片

10:21.250 --> 10:22.250
读图片

10:22.250 --> 10:23.250
你把转换的字不错干嘛

10:23.250 --> 10:24.250
转换字不错

10:24.250 --> 10:25.250
全是乱

10:25.250 --> 10:26.250
因为它不是

10:26.250 --> 10:28.250
它就是纯粹的二几字数据

10:28.250 --> 10:29.250
因此你就没有必要转换了

10:29.250 --> 10:30.250
就用buffer

10:30.250 --> 10:31.250
对不对

10:31.250 --> 10:32.250
OK

10:32.250 --> 10:33.250
那么这是读文件

10:33.250 --> 10:34.250
当然这个incoding

10:34.250 --> 10:35.250
这个就是

10:35.250 --> 10:36.250
这个叫编码

10:36.250 --> 10:37.250
编码方式

10:37.250 --> 10:38.250
incoding还可以有这种写法

10:38.250 --> 10:39.250
把它写成个对象

10:39.250 --> 10:40.250
配置对象里面

10:40.250 --> 10:41.250
写上一个incoding

10:41.250 --> 10:43.250
UTF-8

10:43.250 --> 10:44.250
也就是配置对象里面

10:44.250 --> 10:45.250
还有一些别的

10:45.250 --> 10:47.250
配置的一些别的方式

10:47.250 --> 10:48.250
只不过我们读文件的时候

10:48.250 --> 10:50.250
往往只需要一个配置

10:50.250 --> 10:51.250
UTF-8就行了

10:51.250 --> 10:54.820
所以说我们通常会这样子写

10:54.820 --> 10:55.820
通常会这样子写

10:55.820 --> 10:56.820
那么这就是读文件

10:56.820 --> 10:57.820
非常简单

10:57.820 --> 10:58.820
好

10:58.820 --> 10:59.820
那么这里有个疑问

10:59.820 --> 11:01.820
就是这里为什么要用回调函数呢

11:01.820 --> 11:03.820
有人说那为什么不直接反回

11:03.820 --> 11:04.820
一个内容就行了

11:04.820 --> 11:05.820
这样子看起来都爽

11:05.820 --> 11:06.820
是因为读文件

11:06.820 --> 11:08.820
它是需要一段时间的

11:08.820 --> 11:09.820
我们刚才说过

11:09.820 --> 11:10.820
读文件是什么

11:10.820 --> 11:11.820
是属于iO

11:11.820 --> 11:13.820
iO的处理时间

11:13.820 --> 11:15.820
远远大于

11:15.820 --> 11:18.820
内存跟CPU之间的交互时间

11:18.820 --> 11:20.820
如果说

11:20.820 --> 11:21.820
它给你返回

11:21.820 --> 11:22.820
那么就是同步的写法

11:22.820 --> 11:23.820
这不是异步了

11:23.820 --> 11:25.820
同步的写法

11:25.820 --> 11:27.820
那你单码是不是会卡住

11:27.820 --> 11:30.820
我给大家举一个很简单的例子

11:30.820 --> 11:33.820
比方说我的一条指令

11:33.820 --> 11:36.820
一条语句

11:36.820 --> 11:38.820
就是我们程序里面的一条语句

11:38.820 --> 11:43.820
运行的时间是0.001毫秒

11:43.820 --> 11:44.820
就是一纳秒了

11:44.820 --> 11:46.820
一微秒了

11:46.820 --> 11:49.820
那么我们如果说是一条

11:49.820 --> 11:54.820
读取文件的语句

11:54.820 --> 11:56.820
那么它有可能是10毫秒

11:56.820 --> 11:58.820
你看一下这个差距有多大

11:58.820 --> 12:00.820
差距是非常大的

12:00.820 --> 12:01.820
远远高于

12:01.820 --> 12:03.820
因为硬盘的运行速度很慢的

12:03.820 --> 12:06.820
时间就远远高于我们这个东西

12:06.820 --> 12:07.820
就跟我们平时用

12:07.820 --> 12:08.820
那个是请求一样

12:08.820 --> 12:09.820
请求是不是需要时间

12:09.820 --> 12:10.820
它要往那传输吗

12:10.820 --> 12:11.820
那么这个东西

12:11.820 --> 12:12.820
要跟硬盘之间传输

12:12.820 --> 12:14.820
它速度仍然是比较慢的

12:14.820 --> 12:16.820
所以说它必须要用异步的方式

12:16.820 --> 12:18.820
它不影响后续干嘛的执行

12:18.820 --> 12:21.820
有这个东西是在世界对立里面

12:21.820 --> 12:22.820
它是异步的

12:22.820 --> 12:23.820
没什么意思

12:23.820 --> 12:24.820
所以说如果说我问你

12:24.820 --> 12:25.820
这个地方我们输出一个1

12:25.820 --> 12:26.820
它肯定是它先输出

12:26.820 --> 12:27.820
然后再输出它

12:27.820 --> 12:28.820
它毫无疑问的

12:28.820 --> 12:29.820
对不对

12:29.820 --> 12:31.820
咱们来看一下吧

12:31.820 --> 12:32.820
是不是肯定是它先输出

12:32.820 --> 12:35.820
因为这个东西是异步的

12:35.820 --> 12:37.820
那么这里我再说一下

12:37.820 --> 12:39.820
在我们这个FS模块里面

12:39.820 --> 12:43.820
绝大部分API都是异步的

12:43.820 --> 12:44.820
都是异步的

12:44.820 --> 12:45.820
跟尺盘打枪的

12:45.820 --> 12:48.820
所以说你们都要用毁掉模式

12:48.820 --> 12:50.820
但是它同时给你提供了

12:50.820 --> 12:51.820
这么一些东西

12:51.820 --> 12:53.820
以之后我们这里

12:53.820 --> 12:54.820
去讲很多的API

12:54.820 --> 12:56.820
这些API都有一个贡献的特点

12:56.820 --> 12:58.820
就是它除了这个API本身之外

12:58.820 --> 13:01.820
它往往还可以给你提供这么一个东西

13:01.820 --> 13:05.820
FS red file

13:05.820 --> 13:06.820
你看后面一个sync

13:06.820 --> 13:07.820
sync什么意思

13:07.820 --> 13:08.820
同步

13:08.820 --> 13:09.820
同步

13:09.820 --> 13:10.820
加上一个后续同步

13:10.820 --> 13:12.820
那么比如说是同步读取文件

13:12.820 --> 13:13.820
那么这样子一来了

13:13.820 --> 13:16.820
你看我们就只需要传两个传输购了

13:16.820 --> 13:18.820
它就会用同步的方式

13:18.820 --> 13:19.820
就像有点类似于

13:19.820 --> 13:21.820
你们学的最初那个阿加克斯

13:21.820 --> 13:22.820
是不是有个同步的配置

13:22.820 --> 13:23.820
对吧

13:23.820 --> 13:24.820
它就卡着

13:24.820 --> 13:25.820
我整个程序就卡着

13:25.820 --> 13:26.820
我就在撒等

13:26.820 --> 13:30.820
本来我程序里边一条鱼只要001毫秒

13:30.820 --> 13:32.820
但是为了读这个文件

13:32.820 --> 13:33.820
要消耗10毫秒

13:33.820 --> 13:35.820
那我就等10毫秒在这

13:35.820 --> 13:36.820
干等

13:36.820 --> 13:38.820
那么我们这里就可以得到内容

13:38.820 --> 13:40.820
这看上去

13:40.820 --> 13:41.820
鞋法上很舒服

13:41.820 --> 13:43.820
但是你们千万不要去这样子鞋

13:43.820 --> 13:46.820
它是提供了这么一种方式的

13:46.820 --> 13:47.820
你看

13:47.820 --> 13:49.820
那如果说我在这里边

13:49.820 --> 13:50.820
输出一个E

13:50.820 --> 13:51.820
你们都懂得

13:51.820 --> 13:52.820
肯定是

13:52.820 --> 13:53.820
你看吧

13:53.820 --> 13:54.820
那就是同步运行

13:54.820 --> 13:55.820
对吧

13:55.820 --> 13:56.820
E放后边

13:56.820 --> 13:58.820
这个东西没啥好说的

13:58.820 --> 14:00.820
那肯定是同步运行

14:00.820 --> 14:02.820
这就是这种同步读取

14:02.820 --> 14:04.820
后边我们很多的APL都有这个

14:04.820 --> 14:05.820
后边我们讲什么

14:05.820 --> 14:06.820
Rise file

14:06.820 --> 14:07.820
有Rise file sync

14:07.820 --> 14:08.820
同步写文件

14:08.820 --> 14:09.820
State

14:09.820 --> 14:10.820
State sync

14:10.820 --> 14:12.820
同步读取文件信息

14:12.820 --> 14:13.820
那么这些东西

14:13.820 --> 14:15.820
都有一个Sync方法

14:15.820 --> 14:16.820
这是关于这一个

14:16.820 --> 14:17.820
那么之后

14:17.820 --> 14:18.820
我就不再重复来讲

14:18.820 --> 14:20.820
每个APL它都有一个对应的

14:20.820 --> 14:22.820
Sync最好不要用

14:22.820 --> 14:23.820
Sync有没有可能会要用

14:23.820 --> 14:26.820
有可能一般在做初始化的时候

14:26.820 --> 14:28.820
我这里打个注释

14:28.820 --> 14:30.820
Sync

14:30.820 --> 14:34.820
Sync函数是同步的

14:34.820 --> 14:36.820
会导致

14:36.820 --> 14:38.820
介石运行组设

14:38.820 --> 14:39.820
怎么叫组设呢

14:39.820 --> 14:40.820
就是卡在这里

14:40.820 --> 14:41.820
它比方说这里要读10号秒

14:41.820 --> 14:42.820
它就等在这里

14:42.820 --> 14:43.820
它不会往后走

14:43.820 --> 14:44.820
它要等10号秒

14:44.820 --> 14:45.820
我才能拿到内容

14:45.820 --> 14:47.820
它会导致介石运行组设

14:47.820 --> 14:50.820
极其影响性能

14:50.820 --> 14:52.820
所以说我们平时写代码的时候

14:52.820 --> 14:55.820
我说过不要过度关注优化

14:55.820 --> 14:56.820
一开始不要优化

14:56.820 --> 14:57.820
但是这种基本的东西

14:57.820 --> 14:58.820
你还是要知道

14:58.820 --> 14:59.820
这个影响性能

14:59.820 --> 15:00.820
影响太大的东西

15:00.820 --> 15:01.820
你还是要知道

15:01.820 --> 15:02.820
那么这里呢

15:02.820 --> 15:03.820
所以说我们Sync

15:03.820 --> 15:04.820
它不是说完全没用

15:04.820 --> 15:06.820
它一般在什么时候用呢

15:06.820 --> 15:13.820
一般通常在程序启动时

15:13.820 --> 15:17.820
运行有限的次数即可

15:17.820 --> 15:18.820
什么意思呢

15:18.820 --> 15:19.820
就是当我们弄的写号

15:19.820 --> 15:20.820
一个弄的程序

15:20.820 --> 15:21.820
我们程序运行的时候

15:21.820 --> 15:23.820
一开始做一些初始化操作的时候

15:23.820 --> 15:24.820
我们可能要去

15:24.820 --> 15:26.820
读学学文件内容

15:26.820 --> 15:27.820
对吧

15:27.820 --> 15:28.820
我们读不到的话

15:28.820 --> 15:29.820
我就没有办法

15:29.820 --> 15:30.820
做后面的事情

15:30.820 --> 15:31.820
不要把一配置文件

15:31.820 --> 15:32.820
乱七八糟的东西

15:32.820 --> 15:33.820
把读出来

15:33.820 --> 15:34.820
各种各样的事情

15:34.820 --> 15:35.820
要去做一些初始化的操作

15:35.820 --> 15:36.820
那么这些操作

15:36.820 --> 15:37.820
往往只做一次

15:37.820 --> 15:38.820
或者是一两次

15:38.820 --> 15:40.820
后续就再也不会做了

15:40.820 --> 15:41.820
那么像这个时候

15:41.820 --> 15:42.820
我们可以用Sync

15:42.820 --> 15:43.820
它影响

15:43.820 --> 15:45.820
它只是影响一开始启动的时间

15:45.820 --> 15:47.820
影响不了后边运行的时间

15:47.820 --> 15:49.820
千万不要

15:49.820 --> 15:50.820
把它放到什么情况下来

15:50.820 --> 15:52.820
比方说后面会写

15:52.820 --> 15:53.820
Note皆是会写一个

15:53.820 --> 15:55.820
网络监听网络的寻求

15:55.820 --> 15:56.820
就是我可能

15:56.820 --> 15:57.820
我这个程序会面向

15:57.820 --> 15:58.820
我是一个服务器

15:58.820 --> 15:59.820
我会面向很多的用户

15:59.820 --> 16:01.820
很多用户都要寻求我

16:01.820 --> 16:02.820
一个寻求来了

16:02.820 --> 16:03.820
我就用同步读一次文件

16:03.820 --> 16:04.820
那就完蛋了

16:04.820 --> 16:05.820
因为后边的寻求

16:05.820 --> 16:06.820
全部要等着

16:06.820 --> 16:07.820
要等着我

16:07.820 --> 16:08.820
因为皆是单线程的

16:08.820 --> 16:09.820
它要全部等着我

16:09.820 --> 16:11.820
我们后边还会详细讲

16:11.820 --> 16:12.820
所以说这个东西

16:12.820 --> 16:14.820
一定也非常危险

16:14.820 --> 16:15.820
一定要留意

16:15.820 --> 16:17.820
千万千万不要把它写到

16:17.820 --> 16:19.820
到处去写

16:19.820 --> 16:20.820
如果说你一开始拿不准

16:20.820 --> 16:21.820
如果说你拿不准

16:21.820 --> 16:22.820
你就用Ridified

16:22.820 --> 16:24.820
这绝对没问题的

16:24.820 --> 16:26.820
用这个东西一定要小心

16:26.820 --> 16:27.820
好 OK

16:27.820 --> 16:29.820
那么这是关于这个Sync

16:29.820 --> 16:30.820
另外

16:30.820 --> 16:33.820
好像在12这个版本之后

16:33.820 --> 16:34.820
Note12这个版本之后

16:34.820 --> 16:36.820
它开了这么一个东西

16:36.820 --> 16:37.820
就是FAS里边

16:37.820 --> 16:39.820
它开了这么一个Promises

16:39.820 --> 16:40.820
S6不是出来了吗

16:40.820 --> 16:41.820
S6出来了之后

16:41.820 --> 16:43.820
它就提供了Promise API了

16:43.820 --> 16:44.820
对不对

16:44.820 --> 16:45.820
但是呢

16:45.820 --> 16:46.820
它这个模块

16:46.820 --> 16:47.820
它不敢去改这个东西

16:47.820 --> 16:48.820
它不敢改

16:48.820 --> 16:49.820
为什么不敢改了

16:49.820 --> 16:51.820
就这个API不敢改

16:51.820 --> 16:52.820
因为改了过很多

16:52.820 --> 16:53.820
以前的模块就不兼容了

16:53.820 --> 16:55.820
遇到很多的问题

16:55.820 --> 16:57.820
就是很多API还不敢动

16:57.820 --> 16:58.820
都是因为有些历史原因

16:58.820 --> 16:59.820
所以说

16:59.820 --> 17:00.820
按理说

17:00.820 --> 17:01.820
它应该把它做成一个Promise的模式

17:01.820 --> 17:02.820
对吧

17:02.820 --> 17:03.820
它不敢改

17:03.820 --> 17:05.820
因此它就加了一个

17:05.820 --> 17:07.820
纸对象叫做Promises

17:07.820 --> 17:08.820
那么在这里边

17:08.820 --> 17:10.820
给你提供了同样的API

17:10.820 --> 17:11.820
Ridified

17:11.820 --> 17:12.820
那么这个东西

17:12.820 --> 17:13.820
它返回的是一个Promise

17:13.820 --> 17:14.820
对吧

17:14.820 --> 17:15.820
那么我们就可以怎么写呢

17:15.820 --> 17:16.820
就可以一样的写法

17:16.820 --> 17:17.820
对吧

17:17.820 --> 17:18.820
一样的写法

17:18.820 --> 17:19.820
那么这个返回的就是Promise

17:19.820 --> 17:20.820
那你就不要传回调了

17:20.820 --> 17:21.820
那么后边就应该是什么

17:21.820 --> 17:22.820
Zin对吧

17:22.820 --> 17:24.820
当然如果说你在一个函数里边

17:24.820 --> 17:25.820
你还可以用Away

17:25.820 --> 17:26.820
对不对

17:26.820 --> 17:27.820
Away

17:27.820 --> 17:28.820
那我们用个函数吧

17:28.820 --> 17:29.820
放个型

17:29.820 --> 17:32.510
Test

17:34.510 --> 17:36.510
这里是Async

17:36.510 --> 17:37.510
好

17:37.510 --> 17:38.510
那么这里呢

17:38.510 --> 17:39.510
就是Away

17:39.510 --> 17:40.510
也是一样的

17:40.510 --> 17:41.510
当然如果说爆错的话

17:41.510 --> 17:42.510
如果说爆错的话

17:42.510 --> 17:43.510
比方说文件不存在

17:43.510 --> 17:44.510
它要爆错

17:44.510 --> 17:45.510
爆错的话

17:45.510 --> 17:46.510
那么它就跑出

17:46.510 --> 17:47.510
就是rejected

17:47.510 --> 17:48.510
rejected是什么意思

17:48.510 --> 17:49.510
就跑出一场

17:49.510 --> 17:52.140
好 content

17:52.140 --> 17:53.140
输出

17:53.140 --> 17:54.140
content

17:54.140 --> 17:55.140
好

17:55.140 --> 17:56.140
保存

17:56.140 --> 17:59.520
这里我们运行Test

17:59.520 --> 18:00.520
你看是不是还是可以读取

18:00.520 --> 18:01.520
对吧

18:01.520 --> 18:02.520
OK

18:02.520 --> 18:03.520
那么这是读取文件

18:03.520 --> 18:04.520
非常非常的简单

18:04.520 --> 18:05.520
OK

18:05.520 --> 18:06.520
我把这里的保存

18:06.520 --> 18:07.520
复制

18:07.520 --> 18:08.520
粘贴到一个

18:08.520 --> 18:09.520
copy一下

18:09.520 --> 18:10.520
这是

18:10.520 --> 18:11.520
About

18:12.520 --> 18:13.520
就是

18:13.520 --> 18:15.520
这个应该是fsread

18:15.520 --> 18:16.520
File

18:17.520 --> 18:19.520
那么后续我演示的时候

18:19.520 --> 18:21.520
全部用这个Promise

18:21.520 --> 18:22.520
read

18:22.520 --> 18:23.520
就是Promise里面的

18:23.520 --> 18:24.520
API来演示了

18:24.520 --> 18:25.520
当然你要知道

18:25.520 --> 18:26.520
这些东西都是一样的

18:26.520 --> 18:28.520
比方说我们说下一个

18:29.520 --> 18:30.520
下一个呢

18:30.520 --> 18:31.520
是这个

18:31.520 --> 18:32.520
write file

18:32.520 --> 18:33.520
像文件里面写内容

18:33.520 --> 18:34.520
那么写内容的话

18:34.520 --> 18:35.520
那么也就是这个

18:35.520 --> 18:36.520
我们把这个复制一下

18:36.520 --> 18:38.520
前面两句话复制一下

18:38.520 --> 18:41.020
那么写内容就是

18:41.020 --> 18:42.020
有三个API

18:42.020 --> 18:43.020
对吧

18:43.020 --> 18:44.020
write file

18:44.020 --> 18:45.020
对吧

18:45.020 --> 18:46.020
还有个什么呢

18:46.020 --> 18:47.020
write file sync

18:47.020 --> 18:48.020
还有什么呢

18:48.020 --> 18:50.020
还有Promise

18:50.020 --> 18:51.020
Promise

18:51.020 --> 18:52.020
write file

18:52.020 --> 18:53.020
对吧

18:53.020 --> 18:54.020
对不对

18:54.020 --> 18:55.020
非常简单

18:55.020 --> 18:56.020
好

18:56.020 --> 18:58.020
那么这里是write file

18:58.020 --> 19:01.020
我写入一个文件

19:01.020 --> 19:02.020
写入文件的时候

19:02.020 --> 19:04.020
我们同样的

19:04.020 --> 19:06.020
我们把这个复制过来

19:07.020 --> 19:08.020
这个模式

19:08.020 --> 19:09.020
复制过来

19:10.020 --> 19:11.020
写入文件的时候

19:11.020 --> 19:12.020
一样的

19:12.020 --> 19:13.020
我们写入一个文件

19:13.020 --> 19:15.020
还是像同一个文件里面写吧

19:15.020 --> 19:17.020
像这个e.txt里面写

19:17.020 --> 19:18.020
write file

19:18.020 --> 19:20.020
那么第一个传文件的路径

19:20.020 --> 19:21.020
就是文件名

19:21.020 --> 19:22.020
完整的路径

19:22.020 --> 19:24.020
然后后边传的编码方式

19:24.020 --> 19:25.020
它默认就是

19:25.020 --> 19:27.020
后边传的是什么呢

19:27.020 --> 19:28.020
第二个参数

19:28.020 --> 19:29.020
第二参数传的是内容

19:29.020 --> 19:31.020
你要写什么内容

19:31.020 --> 19:32.020
什么内容呢

19:32.020 --> 19:34.020
我们比方说写一个abc

19:34.020 --> 19:36.020
是不是就这么一个内容

19:36.020 --> 19:37.020
它反回什么呢

19:37.020 --> 19:38.020
咱都不反回

19:38.020 --> 19:39.020
咱都不反回

19:39.020 --> 19:40.020
好写完了之后

19:40.020 --> 19:41.020
我们输出

19:41.020 --> 19:43.020
写入成功

19:43.020 --> 19:44.020
它又不是读文件

19:44.020 --> 19:45.020
所以它不反回

19:45.020 --> 19:46.020
写入成功

19:46.020 --> 19:48.020
那么写入一个abc

19:48.020 --> 19:49.020
那么第三个传说就是什么

19:49.020 --> 19:50.020
编码

19:50.020 --> 19:51.020
编码的话

19:51.020 --> 19:53.020
它默认就是utf-8

19:53.020 --> 19:54.020
默认就是utf-8

19:54.020 --> 19:56.020
所以说你不用去设置了

19:56.020 --> 19:57.020
保存

19:57.020 --> 19:59.020
接下来我们来看一下

20:01.020 --> 20:02.020
写入成功

20:02.020 --> 20:03.020
我们看一下e.txt

20:03.020 --> 20:04.020
什么abc

20:04.020 --> 20:05.020
对吧

20:06.020 --> 20:08.020
把之前的东西覆盖掉了

20:08.020 --> 20:09.020
可不覆盖掉了吗

20:09.020 --> 20:11.020
那如果说你不希望覆盖掉

20:11.020 --> 20:12.020
怎么办呢

20:12.020 --> 20:13.020
以后不要追加

20:13.020 --> 20:15.020
比方说我后面再写入一个

20:15.020 --> 20:17.020
再写入一个这些东西

20:17.020 --> 20:18.020
再写入一个这些东西

20:18.020 --> 20:19.020
那看一下

20:19.020 --> 20:20.020
我不想把这个abc覆盖掉

20:20.020 --> 20:21.020
我想追加怎么办呢

20:21.020 --> 20:22.020
那么你第三个参数

20:22.020 --> 20:23.020
你要这样传

20:24.020 --> 20:25.020
第三个参数

20:25.020 --> 20:26.020
那么传一个对象

20:26.020 --> 20:27.020
对象里面有音扣点

20:27.020 --> 20:28.020
编码

20:28.020 --> 20:29.020
我都可以不用设置了

20:29.020 --> 20:30.020
默认就是utf-8

20:30.020 --> 20:31.020
不用设置

20:31.020 --> 20:32.020
那么

20:32.020 --> 20:34.020
我们可以设置一下这个flag

20:34.020 --> 20:36.020
flag就是表示一个

20:36.020 --> 20:37.020
标识

20:37.020 --> 20:39.020
标识就是我怎么来操作这个文件

20:39.020 --> 20:41.020
那么这里写上a

20:41.020 --> 20:42.020
a什么意思呢

20:42.020 --> 20:44.020
就是append

20:44.020 --> 20:46.020
append就是追加内容

20:46.020 --> 20:47.020
而不是覆盖内容

20:47.020 --> 20:48.020
有这么一个意思

20:48.020 --> 20:50.020
表示追加内容

20:52.020 --> 20:53.020
而不是覆盖内容

20:53.020 --> 20:54.020
好

20:54.020 --> 20:55.020
保存

20:55.020 --> 20:56.020
我们来看一下

20:56.020 --> 20:57.020
现在我们写上这么一段a

20:57.020 --> 20:58.020
写上这么一段内容

20:58.020 --> 20:59.020
好

20:59.020 --> 21:00.020
写入成功

21:00.020 --> 21:01.020
写入成功我们看一下

21:01.020 --> 21:02.020
是不是加到后面了

21:02.020 --> 21:03.020
要换好你就刚n

21:03.020 --> 21:04.020
对吧

21:04.020 --> 21:05.020
但是最好用那个什么呢

21:05.020 --> 21:06.020
我们之前学过的

21:06.020 --> 21:07.020
OS里面

21:11.020 --> 21:13.020
我记得之前学的OS里面

21:13.020 --> 21:14.020
就是换行服

21:14.020 --> 21:16.020
EOL

21:16.020 --> 21:17.020
NWN

21:17.020 --> 21:19.020
用那个来替代刚n

21:19.020 --> 21:21.020
要根据操作系统来确定

21:21.020 --> 21:23.020
到底是刚n还是R刚n

21:23.020 --> 21:24.020
对吧

21:24.020 --> 21:25.020
那么这是往里边追加内容

21:25.020 --> 21:26.020
当然这是一种显法

21:26.020 --> 21:27.020
给它传字无创

21:27.020 --> 21:28.020
能不能去

21:28.020 --> 21:30.020
能不能这样子写呢

21:30.020 --> 21:32.020
能不能我们用一个buffer

21:32.020 --> 21:33.020
可以啊

21:33.020 --> 21:34.020
对吧

21:34.020 --> 21:35.020
我们buffer里面

21:35.020 --> 21:36.020
我们知道buffer可以给服装

21:36.020 --> 21:38.020
我们服装来自于一个

21:38.020 --> 21:40.020
ABCDE

21:40.020 --> 21:41.020
然后呢

21:41.020 --> 21:42.020
后边来自一个编码

21:42.020 --> 21:44.020
编码

21:44.020 --> 21:46.020
后边来自于一个编码

21:46.020 --> 21:48.020
UTF刚m

21:48.020 --> 21:49.020
好

21:49.020 --> 21:50.020
那么再来产生一个buffer

21:50.020 --> 21:52.020
我们往里面写个buffer

21:52.020 --> 21:53.020
可不可以呢

21:53.020 --> 21:54.020
当然可以

21:54.020 --> 21:55.020
FS还是一样

21:55.020 --> 21:58.660
我们第二次来说

21:58.660 --> 21:59.660
就传一个buffer

21:59.660 --> 22:01.660
就不是一个制服创了

22:01.660 --> 22:02.660
传一个buffer进去

22:02.660 --> 22:03.660
那能不能写呢

22:03.660 --> 22:04.660
当然可以

22:04.660 --> 22:05.660
咱们来看一下

22:05.660 --> 22:06.660
好

22:06.660 --> 22:07.660
咱们来换一个文件名吧

22:07.660 --> 22:08.660
换一个2.txt

22:08.660 --> 22:09.660
换一个文件名

22:09.660 --> 22:10.660
如果说文件不存在的话

22:10.660 --> 22:11.660
它就会新建

22:11.660 --> 22:13.660
它就会新建文件

22:13.660 --> 22:15.660
协助成功

22:15.660 --> 22:16.660
你看它是不是多了一个

22:16.660 --> 22:17.660
2.txt

22:17.660 --> 22:18.660
ABCDE写进来了

22:18.660 --> 22:19.660
对吧

22:19.660 --> 22:20.660
往里边写一个buffer

22:20.660 --> 22:21.660
它也是认识的

22:21.660 --> 22:22.660
都可以

22:22.660 --> 22:23.660
都可以

22:23.660 --> 22:24.660
好

22:24.660 --> 22:25.660
OK

22:25.660 --> 22:26.660
那么这是这一块

22:26.660 --> 22:27.660
这一块

22:27.660 --> 22:28.660
我再看看

22:28.660 --> 22:29.660
还有什么要讲的

22:29.660 --> 22:30.660
这里

22:30.660 --> 22:31.660
刚才我们

22:31.660 --> 22:32.660
会帮我们新建

22:32.660 --> 22:34.660
如果说我们没有这个目录

22:34.660 --> 22:35.660
比方说我们这个sub

22:35.660 --> 22:37.660
sub里边

22:37.660 --> 22:38.660
我们这边的sub

22:38.660 --> 22:40.660
比方说我要把文件保存在这

22:40.660 --> 22:41.660
sub

22:41.660 --> 22:42.660
保存在这

22:42.660 --> 22:44.660
所以连这个目录都没有

22:44.660 --> 22:45.660
目录都不存在

22:45.660 --> 22:46.660
那么目录不存在

22:46.660 --> 22:47.660
能不能写入成功呢

22:47.660 --> 22:49.660
我们来看一下

22:49.660 --> 22:50.660
所以抱错了

22:50.660 --> 22:53.660
它说no such file or directory

22:53.660 --> 22:54.660
它说这个

22:54.660 --> 22:55.660
目录都没存在

22:55.660 --> 22:56.660
它就进不了

22:56.660 --> 22:57.660
进不去这个目录了

22:57.660 --> 22:58.660
所以说它到时候

22:58.660 --> 22:59.660
它就会运行失败

22:59.660 --> 23:00.660
OK

23:01.660 --> 23:03.660
另外我们这里

23:03.660 --> 23:05.660
可以做一个小的粒子

23:05.660 --> 23:06.660
小的粒子

23:06.660 --> 23:08.660
做什么小的粒子呢

23:08.660 --> 23:10.660
我们这样子来玩一玩

23:10.660 --> 23:14.570
就这个吧

23:14.570 --> 23:15.570
这个东西

23:15.570 --> 23:17.570
我又不知道会不会侵犯版权

23:17.570 --> 23:20.570
但是我也没有管它的反正

23:20.570 --> 23:21.570
反正看

23:21.570 --> 23:22.570
它没看不到

23:23.570 --> 23:27.140
因为我们只是做技术的测试

23:27.140 --> 23:28.140
应该没事

23:29.140 --> 23:32.140
我们把图片放到我们的

23:33.140 --> 23:34.140
这里边去

23:34.140 --> 23:35.140
1.jpg

23:35.140 --> 23:36.140
放进去

23:36.140 --> 23:38.140
现在我们要复制一个文件

23:38.140 --> 23:39.140
虽然说这个fs

23:39.140 --> 23:40.140
它里边提供了一个

23:40.140 --> 23:41.140
API来复制文件

23:41.140 --> 23:42.140
copy

23:42.140 --> 23:43.140
copy file

23:43.140 --> 23:44.140
你们可以自己去玩一玩

23:44.140 --> 23:45.140
非常简单的

23:46.140 --> 23:47.140
但是我们现在想

23:47.140 --> 23:48.140
我们自己写代码来复制文件

23:48.140 --> 23:49.140
行不行

23:49.140 --> 23:50.140
当然可以

23:50.140 --> 23:51.140
我们怎么来复制

23:51.140 --> 23:53.140
就是我们把这个文件的内容

23:53.140 --> 23:54.140
读出来

23:54.140 --> 23:56.140
然后再写到

23:56.140 --> 23:58.140
另一个文件里边去

23:58.140 --> 23:59.140
对吧

23:59.140 --> 24:00.140
我们来试一下

24:00.140 --> 24:03.700
我们把这个地方

24:03.700 --> 24:05.700
我们把这个地方复制一下

24:05.700 --> 24:07.700
这是fs write file

24:07.700 --> 24:09.700
我们来做一个练习

24:10.700 --> 24:12.700
然后这边

24:12.700 --> 24:13.700
我们这样子写

24:13.700 --> 24:16.700
首先我们把原来的文件找到

24:16.700 --> 24:17.700
from

24:17.700 --> 24:19.700
这是file

24:19.700 --> 24:21.700
我们从哪一个文件来

24:21.700 --> 24:22.700
我们的数据从哪一个文件来了

24:22.700 --> 24:24.700
从my files

24:24.700 --> 24:26.700
就是1.jpg

24:26.700 --> 24:27.700
从这个来

24:27.700 --> 24:29.700
那么来了过后是不是要读

24:29.700 --> 24:30.700
是不是要读它

24:30.700 --> 24:32.700
read file

24:32.700 --> 24:33.700
promises

24:33.700 --> 24:34.700
promises

24:34.700 --> 24:36.700
read file

24:36.700 --> 24:37.700
from file

24:38.700 --> 24:39.700
读它

24:39.700 --> 24:40.700
那么这个时候

24:40.700 --> 24:41.700
肯定不能用utf干嘛来读

24:41.700 --> 24:42.700
读出来就乱了

24:42.700 --> 24:43.700
对不对

24:43.700 --> 24:44.700
我就保持buffer

24:44.700 --> 24:45.700
保持buffer

24:45.700 --> 24:46.700
await

24:47.700 --> 24:48.700
const

24:48.700 --> 24:49.700
buffer

24:49.700 --> 24:50.700
是吧

24:50.700 --> 24:51.700
把保持buffer

24:51.700 --> 24:52.700
好

24:52.700 --> 24:53.700
那么读出来了过后了

24:53.700 --> 24:54.700
我们来输出看一下吧

24:54.700 --> 24:55.700
我们看一下一个buffer

24:55.700 --> 24:56.700
那肯定就是二进

24:56.700 --> 24:57.700
也不是二进字

24:57.700 --> 24:59.700
转换成16进字的数字嘛

24:59.700 --> 25:01.700
对吧

25:01.700 --> 25:02.700
你看一下

25:02.700 --> 25:03.700
它说还有多少呢

25:03.700 --> 25:06.700
还有13200多个字节

25:06.700 --> 25:07.700
对吧

25:07.700 --> 25:08.700
所以我们文本文件

25:08.700 --> 25:09.700
其实装了

25:09.700 --> 25:10.700
我们代码

25:10.700 --> 25:12.700
平时我们安装一些程序的时候

25:12.700 --> 25:14.700
看着我一个程序好像有一个G

25:14.700 --> 25:15.700
两个G对吧

25:15.700 --> 25:16.700
一些游戏很大的

25:16.700 --> 25:17.700
其实它代码

25:17.700 --> 25:18.700
其实没有那么多的

25:18.700 --> 25:19.700
代码超过一个G

25:19.700 --> 25:20.700
那就不得了

25:20.700 --> 25:21.700
那就疯了

25:21.700 --> 25:22.700
太疯狂了

25:22.700 --> 25:23.700
因为我们的文

25:23.700 --> 25:24.700
代码是一个文本文件

25:24.700 --> 25:26.700
文本可能超过那么多

25:26.700 --> 25:28.700
一个文字才占多少字节嘛

25:28.700 --> 25:29.700
所以说它更多的时候

25:29.700 --> 25:30.700
是一些图片

25:30.700 --> 25:31.700
是一些资源

25:31.700 --> 25:32.700
音频

25:32.700 --> 25:33.700
视频

25:33.700 --> 25:34.700
一些数据在里面

25:34.700 --> 25:36.700
所以那个东西占空间

25:36.700 --> 25:37.700
好

25:37.700 --> 25:38.700
我们把buffer读出来了

25:38.700 --> 25:39.700
那么现在我们只需要

25:39.700 --> 25:40.700
把buffer写到另外一个文件

25:40.700 --> 25:41.700
就行了

25:41.700 --> 25:43.700
我们写一个to file name

25:43.700 --> 25:46.700
我们来result

25:46.700 --> 25:48.700
我这里刚才把

25:48.700 --> 25:50.700
把那个就是

25:50.700 --> 25:51.700
给出一个诺

25:51.700 --> 25:54.700
把这个my files

25:55.700 --> 25:57.700
my files去掉

25:57.700 --> 25:58.700
算了不去了

25:58.700 --> 25:59.700
免得里面那边

25:59.700 --> 26:00.700
看不到效果

26:00.700 --> 26:02.700
我们把这个dir name

26:02.700 --> 26:03.700
然后呢

26:03.700 --> 26:05.700
找到这个my files

26:05.700 --> 26:08.700
我们来一个e.copy.jpg

26:08.700 --> 26:10.700
我刚换一个文件名

26:10.700 --> 26:12.700
不然我就把这个文件覆盖了

26:12.700 --> 26:13.700
好

26:13.700 --> 26:14.700
把读出来

26:14.700 --> 26:15.700
读出来过后呢

26:15.700 --> 26:16.700
我们再把它写到

26:16.700 --> 26:17.700
另外一个文件里面去

26:17.700 --> 26:18.700
用什么呢

26:18.700 --> 26:20.700
await fs promises

26:20.700 --> 26:22.700
write file

26:22.700 --> 26:24.700
to file name

26:24.700 --> 26:25.700
然后呢

26:25.700 --> 26:27.700
字节buffer

26:27.700 --> 26:28.700
buffer输出

26:28.700 --> 26:29.700
该写进去

26:29.700 --> 26:31.700
那么我们最后输出呢

26:31.700 --> 26:32.700
copy

26:32.700 --> 26:34.700
这个sys

26:34.700 --> 26:36.700
保存

26:36.700 --> 26:38.700
咱们来运行一下

26:38.700 --> 26:39.700
copy这个sys

26:39.700 --> 26:40.700
你看

26:40.700 --> 26:42.700
是不是

26:42.700 --> 26:43.700
copy了一个文件了

26:43.700 --> 26:44.700
对不对

26:44.700 --> 26:45.700
当然呢

26:45.700 --> 26:46.700
fs里面实际上是有

26:46.700 --> 26:47.700
copy的api的

26:47.700 --> 26:49.700
这里呢

26:49.700 --> 26:51.700
都是

26:51.700 --> 26:53.700
手动复制文件

26:55.700 --> 26:56.700
好

26:56.700 --> 26:57.700
那么这个地方

26:57.700 --> 26:58.700
我们写好了

26:58.700 --> 26:59.700
OK

26:59.700 --> 27:00.700
我们再继续来

27:00.700 --> 27:05.360
file name

27:05.360 --> 27:06.360
现在呢

27:06.360 --> 27:07.360
我们来看一下别的

27:07.360 --> 27:08.360
看一下别的

27:08.360 --> 27:10.360
别的一些api

27:10.360 --> 27:11.360
下一个

27:11.360 --> 27:12.360
下一个呢

27:12.360 --> 27:13.360
是获取文件

27:13.360 --> 27:15.360
或者是目录的信息

27:15.360 --> 27:16.360
state

27:16.360 --> 27:17.360
state的状态

27:17.360 --> 27:18.360
获取文件和目录的

27:18.360 --> 27:19.360
一些状态信息

27:20.360 --> 27:21.360
那么咱们来

27:21.360 --> 27:22.360
这里呢

27:22.360 --> 27:23.360
是fs

27:23.360 --> 27:24.360
我们还是用promise

27:24.360 --> 27:25.360
state

27:26.360 --> 27:27.360
这里边只需要

27:27.360 --> 27:28.360
传一个路径就行了

27:28.360 --> 27:29.360
路径呢

27:29.360 --> 27:30.360
我们把这个file name传进来

27:30.360 --> 27:31.360
就是个图片文件

27:31.360 --> 27:32.360
1.jpg

27:32.360 --> 27:33.360
这个图片文件传进来

27:33.360 --> 27:34.360
传进来过后

27:34.360 --> 27:36.360
它会返回一个结果

27:36.360 --> 27:37.360
当然是一步的

27:37.360 --> 27:38.360
返回一个结果

27:38.360 --> 27:40.360
就是它的状态信息

27:40.360 --> 27:41.360
咱们打印一下

27:41.360 --> 27:42.360
状态信息

27:43.360 --> 27:45.360
打印一下

27:45.360 --> 27:46.360
保存

27:46.360 --> 27:47.360
运行

27:48.360 --> 27:50.360
我怎么写到这儿来了

27:50.360 --> 27:51.360
返回

27:55.060 --> 27:58.710
再来

28:00.710 --> 28:01.710
你看

28:01.710 --> 28:02.710
得到它的状态信息

28:02.710 --> 28:03.710
没有文件内容

28:03.710 --> 28:04.710
得到是文件的状态

28:04.710 --> 28:05.710
什么叫状态信息呢

28:05.710 --> 28:06.710
这里边有一些东西

28:06.710 --> 28:07.710
我没法跟你解释

28:07.710 --> 28:09.710
所以老操作系统的知识了

28:09.710 --> 28:11.710
我们这里解释这几个

28:11.710 --> 28:12.710
一个是size

28:12.710 --> 28:14.710
表示它占用了字结束

28:14.710 --> 28:15.710
它占用了字结束

28:15.710 --> 28:16.710
你看一下

28:16.710 --> 28:17.710
size

28:17.710 --> 28:20.710
是13000多个字节

28:20.710 --> 28:22.710
占用了字结束

28:22.710 --> 28:23.710
另外一个是

28:23.710 --> 28:25.710
这几个东西

28:25.710 --> 28:26.710
一个是atom

28:26.710 --> 28:27.710
atom是什么意思呢

28:27.710 --> 28:28.710
表示上一次

28:28.710 --> 28:30.710
访问这个文件的时间

28:30.710 --> 28:31.710
它是个时间戳

28:31.710 --> 28:32.710
这里写

28:32.710 --> 28:34.710
这个地方显示不出来

28:34.710 --> 28:35.710
是一个很长的数字

28:35.710 --> 28:36.710
时间戳

28:36.710 --> 28:38.710
atom是指的是

28:39.710 --> 28:40.710
上一次修改

28:40.710 --> 28:42.710
这个文件的时间戳

28:42.710 --> 28:43.710
setem

28:43.710 --> 28:44.710
指的是

28:44.710 --> 28:45.710
上一次改变

28:45.710 --> 28:46.710
这个文件状态的时间戳

28:46.710 --> 28:48.710
什么叫改变文件状态

28:48.710 --> 28:49.710
就是比方说你把文件的

28:49.710 --> 28:51.710
访问全线变了

28:51.710 --> 28:52.710
然后怎么样怎么样

28:52.710 --> 28:55.710
这些是访问状态的时间戳

28:55.710 --> 28:56.710
这个地方是

28:56.710 --> 28:57.710
Burst 10是

28:57.710 --> 28:59.710
这个文件的创建的时间戳

28:59.710 --> 29:00.710
我们这里

29:00.710 --> 29:01.710
如果说只输出一个的话

29:01.710 --> 29:02.710
它应该能输出出来

29:02.710 --> 29:03.710
这是控制台的问题

29:03.710 --> 29:07.600
它输出不出来

29:07.600 --> 29:08.600
输出不出来

29:08.600 --> 29:09.600
但是我们可以把它转换成

29:09.600 --> 29:11.600
new date

29:11.600 --> 29:13.600
new一个

29:14.600 --> 29:15.600
它是个时间戳

29:15.600 --> 29:20.770
这个毫无疑问的

29:20.770 --> 29:21.770
运行

29:22.770 --> 29:26.080
to no cost

29:26.080 --> 29:29.580
death stream

29:29.580 --> 29:30.580
所以3月25号

29:30.580 --> 29:31.580
就是我们今天

29:31.580 --> 29:33.580
创建时间

29:33.580 --> 29:34.580
我们都没有时间

29:34.580 --> 29:36.580
文用文用的是death stream

29:36.580 --> 29:38.580
它确实是一个时间戳

29:38.580 --> 29:39.580
还是控制台在这边

29:39.580 --> 29:40.580
显示不出来

29:40.580 --> 29:42.580
这是关于这个状态

29:42.580 --> 29:43.580
这个状态我说一下

29:43.580 --> 29:44.580
它不仅可以针对文件

29:44.580 --> 29:46.580
针对目录也可以

29:46.580 --> 29:47.580
针对目录也可以

29:47.580 --> 29:48.580
咱们来看一下

29:48.580 --> 29:50.580
针对目录

29:50.580 --> 29:52.580
你看目录是不是也有状态

29:52.580 --> 29:53.580
我们这里写的是一个目录

29:53.580 --> 29:56.580
目录里边有个很奇怪的现象

29:56.580 --> 29:58.580
可能违反大家的认知

29:58.580 --> 30:00.580
就是这个size它为0

30:00.580 --> 30:03.580
为什么size为0呢

30:03.580 --> 30:04.580
目录里边不是应该

30:04.580 --> 30:06.580
显示在目录里边

30:06.580 --> 30:08.580
总的就是占用的空间

30:08.580 --> 30:10.580
字节

30:10.580 --> 30:11.580
占用的字节数

30:11.580 --> 30:12.580
它为什么是0呢

30:12.580 --> 30:14.580
因为实际上是这样子的

30:14.580 --> 30:16.580
在操作系统里边

30:16.580 --> 30:18.580
文件夹

30:18.580 --> 30:20.580
也就是我们说的目录

30:20.580 --> 30:22.580
目录它其实只是一个

30:22.580 --> 30:24.580
非常非常简

30:24.580 --> 30:25.580
就是一个空的文件

30:25.580 --> 30:26.580
目录在操作系统里边

30:26.580 --> 30:28.580
实际上是一个文件

30:28.580 --> 30:29.580
跟普通的文件一样

30:29.580 --> 30:30.580
它只是一个文件

30:30.580 --> 30:31.580
只不过它这个文件里边

30:31.580 --> 30:32.580
比较特殊

30:32.580 --> 30:34.580
它里边记录了一个指针

30:34.580 --> 30:36.580
指针指向我们的

30:36.580 --> 30:38.580
其他文件的地址

30:38.580 --> 30:39.580
它是这么一个意思

30:39.580 --> 30:40.580
所以说打开目录

30:40.580 --> 30:42.580
实际上是通过这个指针

30:42.580 --> 30:44.580
去找到其他文件的地址

30:44.580 --> 30:46.580
因此它里边只记录指针

30:46.580 --> 30:48.580
它里边没有任何实质的数据

30:48.580 --> 30:49.580
实质的数据

30:49.580 --> 30:50.580
是这么个意思

30:50.580 --> 30:52.580
这是关于

30:52.580 --> 30:54.580
读取文件的

30:54.580 --> 30:56.580
状态信息

30:56.580 --> 30:57.580
OK

30:57.580 --> 30:59.580
我们把它复制一下

30:59.580 --> 31:01.580
这是fs.stat

31:02.580 --> 31:03.580
再下一个

31:08.940 --> 31:09.940
这里边还有个东西

31:09.940 --> 31:11.940
叫Ease Directory

31:11.940 --> 31:12.940
它返回一个布尔

31:12.940 --> 31:13.940
q的话

31:13.940 --> 31:14.940
那么就是一个stat

31:14.940 --> 31:15.940
就得到我们的这里

31:15.940 --> 31:17.940
还是再看一下吧

31:21.220 --> 31:24.220
是否是文件夹

31:24.220 --> 31:26.220
也就是是否是目录

31:26.220 --> 31:27.220
那么怎么来判断呢

31:27.220 --> 31:29.220
是可以通过这个来判断的

31:29.220 --> 31:30.220
stat

31:30.220 --> 31:31.220
就得到了状态信息里边的一个方法

31:31.220 --> 31:33.220
叫Ease Directory

31:34.220 --> 31:35.220
然后如果说

31:35.220 --> 31:36.220
它另外一个想法的

31:36.220 --> 31:37.220
是不是文件

31:37.220 --> 31:38.220
它可以判断出来

31:38.220 --> 31:39.220
文件和目录

31:39.220 --> 31:41.220
它有一个特殊的标记在里边

31:41.220 --> 31:42.220
在状态信息里边

31:42.220 --> 31:43.220
有特殊标记的

31:43.220 --> 31:45.220
Ease file

31:46.220 --> 31:47.220
保存

31:47.220 --> 31:49.220
看一下吧

31:49.220 --> 31:50.220
你看到

31:50.220 --> 31:51.220
是不是目录

31:51.220 --> 31:52.220
不是

31:52.220 --> 31:53.220
是不是文件

31:53.220 --> 31:54.220
这个一定是相反的

31:54.220 --> 31:55.220
对吧

31:55.220 --> 31:56.220
这里是文件

31:56.220 --> 31:57.220
那如果说我把这个删掉

31:57.220 --> 31:58.220
保存

31:59.220 --> 32:00.220
你看

32:00.220 --> 32:01.220
是不是目录

32:01.220 --> 32:02.220
是不是文件

32:02.220 --> 32:03.220
那么是不是目录

32:03.220 --> 32:04.220
还是文件

32:04.220 --> 32:05.220
我们就可以通过

32:05.220 --> 32:06.220
这种方式来判断

32:06.220 --> 32:07.220
这是关于stat

32:07.220 --> 32:08.220
否则

32:08.220 --> 32:09.220
再来过去

32:09.220 --> 32:11.220
你下载至于看

32:12.220 --> 32:14.220
这几刻我们完了之后

32:14.220 --> 32:15.220
我们也不做

32:15.220 --> 32:16.220
太过于复杂练习了

32:16.220 --> 32:17.220
我们就做一个

32:17.220 --> 32:18.220
简单的练习就行了

32:18.220 --> 32:19.220
这个练习

32:19.220 --> 32:21.220
其实也没有那么轻松了

32:21.220 --> 32:22.220
我们到时候来做

32:22.220 --> 32:23.220
你们下去过后

32:23.220 --> 32:24.220
还是要把这里面

32:24.220 --> 32:25.220
每一个API都去做一次

32:25.220 --> 32:26.220
至少做一次

32:26.220 --> 32:27.220
这个练习

32:27.220 --> 32:28.220
也跟着做一次

32:28.220 --> 32:29.220
就够了

32:29.220 --> 32:31.220
那么你对FS模块

32:31.220 --> 32:32.220
你至少不陌生了

32:32.220 --> 32:33.220
知道它到底怎么回事了

32:33.220 --> 32:35.220
凭什么用这个模块

32:35.220 --> 32:36.220
也不多

32:36.220 --> 32:37.220
有的时候会用到

32:37.220 --> 32:38.220
但是没有那么频繁

32:40.220 --> 32:41.220
毕竟我们是前端

32:41.220 --> 32:42.220
还有这个

32:44.220 --> 32:45.220
DIR什么意思

32:46.220 --> 32:47.220
表示目录的意思

32:47.220 --> 32:48.220
读取一个目录

32:49.220 --> 32:50.220
它可以得到什么

32:50.220 --> 32:51.220
得到这个目录里面

32:51.220 --> 32:52.220
一个数组

32:52.220 --> 32:53.220
一个制服刷的数组

32:53.220 --> 32:54.220
数组里面保存

32:54.220 --> 32:55.220
目录下边的

32:55.220 --> 32:57.220
指目录和指纹键

32:57.220 --> 32:58.220
比方说

32:58.220 --> 32:59.220
我举个例子

33:00.220 --> 33:02.220
这边我们写上一个目录

33:03.220 --> 33:04.220
DIR

33:06.220 --> 33:07.220
这个就是目录

33:07.220 --> 33:08.220
这边目录

33:08.220 --> 33:09.220
来吧

33:10.220 --> 33:11.220
目录的话

33:11.220 --> 33:13.220
我们就得到这个

33:13.220 --> 33:14.220
然后我们这边

33:14.220 --> 33:15.220
这样子写

33:16.220 --> 33:17.220
FS Promise

33:18.220 --> 33:19.220
然后

33:20.220 --> 33:21.220
DIR

33:21.220 --> 33:24.220
把目录的路径传进去

33:24.220 --> 33:25.220
它会返回

33:26.220 --> 33:27.220
返回一个什么

33:27.220 --> 33:28.220
它的指目录

33:28.220 --> 33:29.220
Passage

33:30.220 --> 33:31.220
我们今天后边的一个

33:31.220 --> 33:32.220
练习我们要用到这个东西

33:33.220 --> 33:35.220
我们打印这个Passage

33:35.220 --> 33:36.220
看一下

33:36.220 --> 33:40.170
你看它这里边是不是得到了

33:40.170 --> 33:42.170
这几个文件都得到了

33:42.170 --> 33:44.170
那里边不是文件

33:44.170 --> 33:45.170
还有目录呢

33:45.170 --> 33:46.170
我们来看一下

33:47.170 --> 33:48.170
它目录也能得到的

33:48.170 --> 33:49.170
对吧

33:49.170 --> 33:50.170
因为我们知道

33:50.170 --> 33:51.170
目录也是一个文件

33:51.170 --> 33:53.170
它只是一个特殊的文件而已

33:53.170 --> 33:54.170
所以它目录也会得到

33:54.170 --> 33:55.170
对吧

33:55.170 --> 33:56.170
就这么个意思

33:56.170 --> 33:59.540
那目录里边还有文件呢

33:59.540 --> 34:01.540
它能不能得到了

34:01.540 --> 34:02.540
得不到了

34:02.540 --> 34:04.540
它只能得到指的文件

34:04.540 --> 34:06.540
它指文件里边还有文件

34:06.540 --> 34:07.540
还得不到了

34:07.540 --> 34:08.540
OK

34:08.540 --> 34:09.540
那么这是

34:09.540 --> 34:10.540
RAID DR

34:11.540 --> 34:12.540
没问题吧

34:12.540 --> 34:13.540
得到的是什么

34:13.540 --> 34:14.540
一个数组

34:14.540 --> 34:15.540
数组里边保存了

34:15.540 --> 34:16.540
这些文件的名称

34:16.540 --> 34:17.540
对吧

34:17.540 --> 34:18.540
OK

34:18.540 --> 34:19.540
那么这是这一块

34:20.540 --> 34:21.540
好

34:21.540 --> 34:23.540
然后下面创建一个新的目录

34:23.540 --> 34:25.540
我们把这个复制一下

34:25.540 --> 34:27.540
FS

34:27.540 --> 34:28.540
这个是

34:28.540 --> 34:29.540
当然一个目录要存在

34:29.540 --> 34:30.540
一个存不存在的话

34:30.540 --> 34:31.540
肯定要爆错了

34:31.540 --> 34:33.540
这是RAID

34:33.540 --> 34:34.540
不

34:34.540 --> 34:37.540
这是RAID DR

34:37.540 --> 34:38.540
好

34:38.540 --> 34:39.540
再来

34:39.540 --> 34:40.540
下一个

34:40.540 --> 34:41.540
创建目录

34:41.540 --> 34:42.540
就是我们可以通过代码

34:42.540 --> 34:43.540
来创建目录

34:43.540 --> 34:44.540
比方说我来这里

34:44.540 --> 34:45.540
创建

34:45.540 --> 34:46.540
五个目录

34:46.540 --> 34:48.540
名字为1235

34:48.540 --> 34:49.540
来吧

34:49.540 --> 34:50.540
怎么来创建的

34:50.540 --> 34:51.540
非常简单

34:51.540 --> 34:53.540
佛循环

34:53.540 --> 34:54.540
i

34:54.540 --> 34:55.540
e

34:55.540 --> 34:57.540
小语等于5

34:57.540 --> 34:58.540
好

34:58.540 --> 34:59.540
来吧

34:59.540 --> 35:00.540
来创建吧

35:00.540 --> 35:01.540
我们要在这个目录下面

35:01.540 --> 35:02.540
创建

35:02.540 --> 35:03.540
创建

35:03.540 --> 35:04.540
算了

35:04.540 --> 35:06.540
我们先把最基本的说了吧

35:06.540 --> 35:07.540
基本的说了

35:07.540 --> 35:08.540
比方说我们的目录

35:08.540 --> 35:09.540
这里是一个e

35:09.540 --> 35:10.540
对吧

35:10.540 --> 35:11.540
这里是一个e

35:11.540 --> 35:12.540
好

35:12.540 --> 35:13.540
然后我们在这里

35:13.540 --> 35:15.540
使用MK DR

35:15.540 --> 35:17.540
把DRName传进去

35:17.540 --> 35:18.540
它反回怎么了

35:18.540 --> 35:19.540
它早都不反回

35:19.540 --> 35:20.540
早都不反回

35:20.540 --> 35:21.540
所以我们不用接受

35:21.540 --> 35:23.540
我们这里创建目录成功

35:23.540 --> 35:26.540
创建目录成功

35:26.540 --> 35:27.540
保存

35:27.540 --> 35:28.540
咱们来看一下

35:28.540 --> 35:29.540
运行

35:29.540 --> 35:30.540
创建目录成功

35:30.540 --> 35:31.540
是不是多了一个目录

35:31.540 --> 35:32.540
e

35:32.540 --> 35:33.540
非常简单

35:33.540 --> 35:34.540
是不是非常简单

35:34.540 --> 35:35.540
创建文件我不说了

35:35.540 --> 35:36.540
创建文件就是

35:36.540 --> 35:37.540
write file

35:37.540 --> 35:38.540
你写个空的东西进去

35:38.540 --> 35:39.540
就行了

35:39.540 --> 35:41.540
这是创建这个目录

35:41.540 --> 35:42.540
当然如果说

35:42.540 --> 35:43.540
你要一次创建

35:43.540 --> 35:44.540
1235来自己去搞电

35:44.540 --> 35:45.540
我不是说了

35:45.540 --> 35:46.540
这是关于这个

35:46.540 --> 35:47.540
把它复制一下

35:49.540 --> 35:50.540
这里是FS

35:50.540 --> 35:52.540
MK DR

35:53.540 --> 35:54.540
好

35:54.540 --> 35:56.540
下面是判断文件

35:56.540 --> 35:57.540
或者是目录存不存在

35:58.540 --> 35:59.540
那么我们来

35:59.540 --> 36:00.540
我们这里写个3

36:00.540 --> 36:01.540
比方说我们这里

36:01.540 --> 36:04.540
能使用一个z

36:05.540 --> 36:06.540
一个z

36:08.860 --> 36:09.860
一个z

36:10.860 --> 36:11.860
等一下

36:11.860 --> 36:13.860
这是同步方法吗

36:13.860 --> 36:15.860
不是同步方法

36:15.860 --> 36:16.860
是有callback

36:16.860 --> 36:17.860
那为什么他没有把

36:17.860 --> 36:18.860
这个东西做出来呢

36:20.860 --> 36:21.860
is

36:21.860 --> 36:22.860
一个z

36:22.860 --> 36:23.860
好真的我查一下

36:23.860 --> 36:25.860
因为这个新的API

36:25.860 --> 36:26.860
新的API

36:26.860 --> 36:27.860
他没有把一个z的

36:27.860 --> 36:28.860
做出来呢

36:28.860 --> 36:29.860
一个z

36:29.860 --> 36:33.130
他说这个depressed

36:33.130 --> 36:35.130
他说这个过时了

36:35.130 --> 36:36.130
他说现在已经过时了

36:36.130 --> 36:37.130
这个玩意

36:37.130 --> 36:39.130
那就按他说的办法

36:39.130 --> 36:41.130
我们用这个东西来替换

36:41.130 --> 36:42.130
但是我个人觉得

36:42.130 --> 36:44.130
他把这个API搞掉了

36:44.130 --> 36:45.130
我不是很满意

36:46.130 --> 36:47.130
但是我不满意

36:47.130 --> 36:48.130
他也没啥关系

36:49.130 --> 36:50.130
他也不会参考我的意见

36:50.130 --> 36:52.130
因为这个一个z

36:52.130 --> 36:53.130
还是蛮有用的

36:53.130 --> 36:54.130
因为有的时候

36:54.130 --> 36:56.130
我们要摔一仙的去判断

36:56.130 --> 36:57.130
有没有文件存在

36:57.130 --> 36:59.130
然后再去做一些别的事情

36:59.130 --> 37:00.130
他把这个API

37:00.130 --> 37:01.130
不应该去搞掉的

37:01.130 --> 37:03.130
我觉得他不应该去把搞掉的

37:03.130 --> 37:04.130
我不知道

37:04.130 --> 37:05.130
他是出于什么原因

37:05.130 --> 37:06.130
那好吧

37:06.130 --> 37:07.130
他现在就事实

37:07.130 --> 37:08.130
已经把这个API

37:08.130 --> 37:10.130
他已经把他标记为过时了

37:10.130 --> 37:11.130
但是还能用

37:11.130 --> 37:12.130
你只能用

37:12.130 --> 37:13.130
fs一个z还能用

37:13.130 --> 37:15.130
但是你不能再用那个了

37:15.130 --> 37:16.130
不能再用promises

37:16.130 --> 37:18.130
他不打算再支持这个API

37:18.130 --> 37:20.130
后面他可能会去掉

37:20.130 --> 37:22.130
那么现在我们就用这个吧

37:22.130 --> 37:24.130
现在还蛮有点麻烦

37:24.130 --> 37:27.130
我现在得去重新写一个辅助函数

37:27.130 --> 37:28.130
一个z

37:30.820 --> 37:32.820
然后给我一个name

37:32.820 --> 37:33.820
file name

37:33.820 --> 37:35.820
然后我这里只能这样做

37:35.820 --> 37:37.820
用一个check hatch

37:37.820 --> 37:40.820
我们这里用fsstat

37:40.820 --> 37:42.820
file name

37:42.820 --> 37:44.820
我们把这个东西拿去

37:44.820 --> 37:45.820
看一下他的状态

37:45.820 --> 37:46.820
看文件状态

37:46.820 --> 37:47.820
当然为什么会爆出

37:47.820 --> 37:48.820
文件不存在

37:48.820 --> 37:49.820
就会爆错

37:49.820 --> 37:50.820
对吧

37:50.820 --> 37:51.820
文件不存在就会爆错

37:51.820 --> 37:53.820
如果说能够拿到状态的话

37:53.820 --> 37:54.820
怎么样呢

37:54.820 --> 37:56.820
我这里用promises

37:58.820 --> 38:00.820
如果说能够拿到状态的话

38:00.820 --> 38:01.820
那么我就return to

38:01.820 --> 38:03.820
如果说拿不到状态的话

38:03.820 --> 38:04.820
catch

38:05.820 --> 38:06.820
他里边个arrow

38:06.820 --> 38:08.820
arrow里边有一个什么

38:08.820 --> 38:10.820
arrow里边有一个

38:10.820 --> 38:13.820
我看一下他这个arrow里边有一个

38:13.820 --> 38:14.820
把打印出来吧

38:15.820 --> 38:16.820
dir

38:16.820 --> 38:17.820
arrow

38:17.820 --> 38:19.820
看一个arrow里边是什么

38:19.820 --> 38:20.820
return force

38:20.820 --> 38:22.820
因为他这个读不到状态的话

38:22.820 --> 38:23.820
还有很多情况

38:23.820 --> 38:24.820
还有很多情况

38:24.820 --> 38:25.820
读不到这个状态

38:25.820 --> 38:26.820
咱们来看一下

38:26.820 --> 38:27.820
他怎么

38:27.820 --> 38:29.820
什么情况下是文件不存在

38:29.820 --> 38:31.820
我们这里调用一下

38:31.820 --> 38:33.820
调用一下这个exist

38:34.820 --> 38:36.820
dir

38:36.820 --> 38:37.820
传进去

38:37.820 --> 38:38.820
好吗

38:38.820 --> 38:40.820
现在他还得至于封装一个app

38:40.820 --> 38:42.820
看一下吧

38:42.820 --> 38:43.820
那么现在呢

38:43.820 --> 38:46.820
他写的是arrow code

38:46.820 --> 38:48.820
code等于

38:50.820 --> 38:51.820
就这个单词

38:51.820 --> 38:52.820
这个单词表示

38:52.820 --> 38:53.820
没有这个文件

38:53.820 --> 38:54.820
没有这个

38:54.820 --> 38:56.820
没有找不到这个目录或者文件

38:56.820 --> 38:57.820
咱们把它复制一下

38:57.820 --> 38:59.820
如果说我们判断

38:59.820 --> 39:01.820
判断code

39:01.820 --> 39:02.820
等于

39:03.820 --> 39:04.820
等于这个

39:06.820 --> 39:07.820
等于这个

39:07.820 --> 39:09.820
那么说明是文件不存在

39:09.820 --> 39:10.820
如果说是这种情况

39:10.820 --> 39:12.820
这种错误的话是文件不存在

39:12.820 --> 39:13.820
如果说是其他错误的话

39:13.820 --> 39:15.820
就是无权限独取之类的错误的话

39:16.820 --> 39:18.820
那么我们就先把这个返回

39:18.820 --> 39:19.820
如果说其他错误的话

39:19.820 --> 39:21.820
我们就继续把这个错误拨出

39:21.820 --> 39:23.820
我觉得不应该把这个app搞掉

39:23.820 --> 39:25.820
这个app是我觉得还蛮有用的

39:25.820 --> 39:26.820
好那么现在呢

39:26.820 --> 39:27.820
我们就可以看到

39:27.820 --> 39:29.820
用这个字节我们写的app

39:29.820 --> 39:30.820
字节写的函数来判断

39:30.820 --> 39:31.820
文件是不是存在

39:31.820 --> 39:32.820
如果说

39:32.820 --> 39:33.820
他得到一个结果

39:33.820 --> 39:34.820
得到一个

39:35.820 --> 39:36.820
结果

39:36.820 --> 39:37.820
那么这个结果呢

39:37.820 --> 39:40.970
输出

39:41.970 --> 39:42.970
看一下这个结果

39:43.970 --> 39:45.970
force表示文件不存在

39:45.970 --> 39:46.970
那么如果说

39:46.970 --> 39:48.970
他一个存在的目录的话

39:48.970 --> 39:49.970
输出

39:50.970 --> 39:52.970
那么这个东西我们可以有什么用的

39:52.970 --> 39:54.970
我们往往用这种方式

39:54.970 --> 39:56.970
来做这么一些事情

39:56.970 --> 39:58.970
我要从某一个目录里边

39:58.970 --> 39:59.970
去读东西

39:59.970 --> 40:00.970
但是我要首先看

40:00.970 --> 40:01.970
这个目录存不存在

40:01.970 --> 40:02.970
或者是我要保存一个东西

40:02.970 --> 40:03.970
到一个目录里边去

40:03.970 --> 40:04.970
我首先看一下

40:04.970 --> 40:05.970
一个目录存不存在

40:05.970 --> 40:06.970
如果不存在的话

40:06.970 --> 40:07.970
我去新建这个目录

40:07.970 --> 40:08.970
是这么个意思

40:08.970 --> 40:09.970
比方说我这里写个三

40:09.970 --> 40:11.970
那么现在呢我们判断一下

40:11.970 --> 40:12.970
判断一下

40:12.970 --> 40:14.970
如果说这个resout存在的话

40:14.970 --> 40:15.970
我就什么都不做了

40:15.970 --> 40:16.970
就是

40:16.970 --> 40:19.970
目录已存在

40:19.970 --> 40:21.970
无需操作

40:21.970 --> 40:25.470
那么现在 else

40:25.470 --> 40:26.470
就是目录不存在

40:26.470 --> 40:27.470
目录不存在

40:27.470 --> 40:28.470
我就创建了每个目录

40:28.470 --> 40:29.470
有await

40:29.470 --> 40:30.470
fx

40:30.470 --> 40:32.470
就是 mkdir

40:32.470 --> 40:34.470
dirl

40:34.470 --> 40:35.470
创建了每个目录

40:35.470 --> 40:36.470
然后我们就输出

40:36.470 --> 40:38.470
目录创建成功

40:38.470 --> 40:40.470
我们经常会有这么样的一个需求

40:40.470 --> 40:41.470
后边我们处理文件

40:41.470 --> 40:42.470
特别是处理

40:42.470 --> 40:43.470
怎么文件上传

40:43.470 --> 40:44.470
这些东西

40:44.470 --> 40:46.470
很有可能会有这么样的一个需求

40:46.470 --> 40:50.360
保存

40:50.360 --> 40:51.360
出问题了

40:51.360 --> 40:53.360
还有什么呢

40:53.360 --> 40:54.360
callback

40:54.360 --> 40:56.360
must be a function

40:56.360 --> 40:58.360
这里应该是用 promise

40:58.360 --> 41:02.630
promises

41:02.630 --> 41:03.630
目录创建成功

41:03.630 --> 41:04.630
那么第一次是没有这个目录

41:04.630 --> 41:05.630
然后该创建了

41:05.630 --> 41:07.630
后边就已经存在了

41:07.630 --> 41:08.630
无需操作了

41:08.630 --> 41:10.630
我们就可以动态的判断

41:10.630 --> 41:12.630
那么这是关于文件

41:12.630 --> 41:13.630
适逢存在

41:13.630 --> 41:15.630
熟悉

41:15.630 --> 41:16.630
exist

41:16.630 --> 41:17.630
现在害怕干掉了

41:17.630 --> 41:19.630
我们直接熟悉

41:19.630 --> 41:21.630
那是这一块东西

41:21.630 --> 41:24.630
然后再来看

41:24.630 --> 41:25.630
就没了

41:25.630 --> 41:26.630
我们平时要用的

41:26.630 --> 41:27.630
FS模块的东西

41:27.630 --> 41:29.630
就差不多是这么一些东西的

41:29.630 --> 41:31.630
现在让我们来做一个练习

41:31.630 --> 41:33.630
这个练习是来读取一个

41:33.630 --> 41:36.630
目录中的所有指目录和文件

41:36.630 --> 41:38.630
后边我们不会用到

41:38.630 --> 41:39.630
主要是练习一下

41:39.630 --> 41:40.630
我们这几课学习的FS模块

41:40.630 --> 41:42.630
现在大家要做的事情

41:42.630 --> 41:44.630
首先把这些东西自己

41:44.630 --> 41:45.630
去写一遍

41:45.630 --> 41:46.630
用一下

41:46.630 --> 41:47.630
第二就是做这么个练习

41:47.630 --> 41:48.630
读取一个目录中的

41:48.630 --> 41:50.630
所有指目录和文件

41:50.630 --> 41:51.630
什么意思呢

41:51.630 --> 41:52.630
就是说

41:52.630 --> 41:53.630
我后边有注释

41:53.630 --> 41:54.630
你们可以写的是可以参考一下

41:54.630 --> 41:56.630
每一个目录和文件

41:56.630 --> 41:58.630
我要把它整成一个对象

41:58.630 --> 42:00.630
这对象哪里有些属性

42:00.630 --> 42:02.630
有一些方法

42:02.630 --> 42:04.630
你看属性有什么呢

42:04.630 --> 42:06.630
文件名或者是目录名

42:06.630 --> 42:07.630
名字

42:07.630 --> 42:09.630
ST后罪名

42:09.630 --> 42:10.630
已经它是不是一个文件

42:10.630 --> 42:11.630
是文件还是目录

42:11.630 --> 42:12.630
还有什么呢

42:12.630 --> 42:14.630
是它的大小尺寸

42:14.630 --> 42:15.630
还有什么呢

42:15.630 --> 42:17.630
还有就是那个

42:17.630 --> 42:18.630
创建日期

42:18.630 --> 42:20.630
还有修改日期

42:20.630 --> 42:21.630
以及它两个方法

42:21.630 --> 42:23.630
一是 get children

42:23.630 --> 42:24.630
得到它的指目录

42:24.630 --> 42:26.630
或者是指文件

42:26.630 --> 42:27.630
get content

42:27.630 --> 42:28.630
如果是读文件的话

42:28.630 --> 42:29.630
那么它得到的是文件内容

42:29.630 --> 42:30.630
如果是目录的话

42:30.630 --> 42:31.630
返回那儿

42:31.630 --> 42:32.630
那么文件内容的话

42:32.630 --> 42:33.630
它有个意思

42:33.630 --> 42:34.630
buffer

42:34.630 --> 42:35.630
如果说你传入的是处

42:35.630 --> 42:36.630
我用buffer的方式

42:36.630 --> 42:37.630
给你返回

42:37.630 --> 42:38.630
如果说传入的是force的话

42:38.630 --> 42:39.630
我就用

42:39.630 --> 42:41.630
字不串的方式给你返回

42:41.630 --> 42:42.630
就这么个意思

42:42.630 --> 42:43.630
我们要写这么一个

42:43.630 --> 42:44.630
辅助函数

42:44.630 --> 42:45.630
来吧

42:45.630 --> 42:46.630
我们来玩一玩

42:48.630 --> 42:49.630
好 现在呢

42:49.630 --> 42:50.630
我们要做这么一件事

42:51.630 --> 42:52.630
当然行

42:52.630 --> 42:53.630
我们要写这么一个函数

42:53.630 --> 42:55.630
给它取个名字叫做

42:56.630 --> 42:57.630
rid

42:57.630 --> 42:59.630
也叫做rid.dl

42:59.630 --> 43:00.630
也叫做这个名字

43:00.630 --> 43:01.630
当然它是一个异步函数

43:01.630 --> 43:02.630
毫无疑问的

43:03.630 --> 43:04.630
异步函数

43:05.630 --> 43:07.630
你给我传一个目录的

43:07.630 --> 43:09.630
目录的就是路径

43:09.630 --> 43:10.630
你给我传一个

43:10.630 --> 43:12.630
然后我后面会给你返回

43:12.630 --> 43:13.630
比方说我到时候

43:13.630 --> 43:15.630
去调用这个东西

43:16.630 --> 43:17.630
test

43:18.630 --> 43:19.630
测试一下

43:19.630 --> 43:20.630
我们比方说去调用一下

43:20.630 --> 43:21.630
这个await

43:22.630 --> 43:24.630
这是每一个学习后端的人员

43:24.630 --> 43:25.630
都要做的一件事

43:25.630 --> 43:27.630
就是第1规律去目录里面的所有东西

43:27.630 --> 43:29.630
dl.lib

43:29.630 --> 43:30.630
比方说

43:30.630 --> 43:31.630
我们要做这么一件事

43:31.630 --> 43:33.630
把dl.lib

43:33.630 --> 43:35.630
这里写一个吧

43:35.630 --> 43:37.630
passresult

43:37.630 --> 43:39.630
当前目录的

43:39.630 --> 43:41.630
下边的myfiles

43:42.630 --> 43:44.630
我们要把dl.lib

43:44.630 --> 43:45.630
闯进去

43:45.630 --> 43:47.630
它就可以读这个目录里面的所有东西

43:47.630 --> 43:48.630
然后

43:48.630 --> 43:50.630
这里我们得到一个结果

43:50.630 --> 43:51.630
result

43:51.630 --> 43:53.630
这个结果大概是什么样子

43:53.630 --> 43:55.630
result输出

43:55.630 --> 43:56.630
我现在肯定少都没有

43:56.630 --> 43:58.630
这个提过应该是什么样子

43:58.630 --> 43:59.630
结果应该是这个样子

43:59.630 --> 44:05.420
它大概应该是一个数组

44:06.420 --> 44:07.420
因为这个目录下面

44:07.420 --> 44:09.420
是不是有很多的指目录

44:09.420 --> 44:10.420
是不是有很多的指目录

44:10.420 --> 44:11.420
以及指文件

44:11.420 --> 44:13.420
它应该是这么一个数组

44:13.420 --> 44:14.420
输出里面

44:14.420 --> 44:15.420
它是这个样子的

44:16.420 --> 44:17.420
输出里面每一项

44:17.420 --> 44:18.420
就是一个对象

44:18.420 --> 44:19.420
对象里面

44:19.420 --> 44:20.420
每一个对象里面

44:20.420 --> 44:21.420
比方说name

44:21.420 --> 44:22.420
name是什么呢

44:22.420 --> 44:23.420
第一个是name是1

44:23.420 --> 44:24.420
对吧

44:24.420 --> 44:25.420
name是1

44:25.420 --> 44:26.420
然后

44:27.420 --> 44:29.420
看一下还有哪些属性

44:30.420 --> 44:31.420
easefile

44:32.420 --> 44:33.420
easefile

44:33.420 --> 44:34.420
是什么force

44:34.420 --> 44:35.420
它是一个目录

44:35.420 --> 44:36.420
它不是file

44:36.420 --> 44:37.420
然后还有什么呢

44:37.420 --> 44:39.420
还有ext

44:39.420 --> 44:40.420
ext它是目录的话

44:40.420 --> 44:41.420
那就是一个空置不串

44:41.420 --> 44:42.420
啥都没有

44:42.420 --> 44:44.420
然后是size

44:44.420 --> 44:45.420
大小

44:45.420 --> 44:46.420
那么它是目录的话

44:46.420 --> 44:47.420
我们可以把它输入0

44:47.420 --> 44:48.420
下来过后

44:48.420 --> 44:49.420
大家可以自行思考

44:49.420 --> 44:50.420
如果说一个size

44:50.420 --> 44:51.420
我要得到的是

44:51.420 --> 44:52.420
它是指目录的

44:52.420 --> 44:54.420
指目录里面的所有文件的

44:54.420 --> 44:55.420
综合应该怎么办

44:55.420 --> 44:56.420
那个比较复杂

44:56.420 --> 44:57.420
你们可以自己去

44:57.420 --> 44:58.420
想一想该怎么去做

44:58.420 --> 44:59.420
我们这里就用0

44:59.420 --> 45:00.420
quiz10

45:00.420 --> 45:01.420
那这些不写了

45:01.420 --> 45:02.420
然后那两个方法

45:02.420 --> 45:03.420
getculturing

45:03.420 --> 45:04.420
已经getcontent

45:04.420 --> 45:06.420
它里面一个属性叫做culturing

45:06.420 --> 45:08.420
culturing又是一个数组

45:08.420 --> 45:09.420
它目前

45:09.420 --> 45:11.420
不是一个属性

45:11.420 --> 45:13.420
它要getculturing方法

45:14.420 --> 45:15.420
getculturing方法

45:15.420 --> 45:16.420
它调用过后

45:16.420 --> 45:18.420
是返回一个新的数组

45:18.420 --> 45:19.420
就是这个目录下面

45:19.420 --> 45:20.420
又有哪些东西

45:20.420 --> 45:21.420
又是一个数组

45:21.420 --> 45:22.420
不要这意思吧

45:22.420 --> 45:23.420
那么这是一个目录

45:23.420 --> 45:25.420
那么下面我们再写个文件

45:25.420 --> 45:26.420
它大概是这么一种结构

45:26.420 --> 45:28.420
我们要得到这么一个东西

45:28.420 --> 45:29.420
那边表面文件

45:29.420 --> 45:32.420
就是e.copy.jpeg

45:32.420 --> 45:34.420
然后easefile2

45:34.420 --> 45:36.420
east就是后绝名

45:36.420 --> 45:38.420
就是d.jpeg

45:38.420 --> 45:40.420
size就是多少

45:40.420 --> 45:42.420
刚才看到的是13303

45:42.420 --> 45:44.420
然后getculturing

45:44.420 --> 45:45.420
它getculturing的

45:45.420 --> 45:48.420
返回了肯定是一个空的数组

45:48.420 --> 45:50.420
因为它不是一个目录

45:50.420 --> 45:52.420
我们就大概要得到这么一个东西

45:52.420 --> 45:56.300
来,我们来写这个

45:56.300 --> 45:57.300
那么这个函数怎么写的

45:57.300 --> 45:58.300
我们首先要知道

45:58.300 --> 46:00.300
这里面是要有一个一个的对象

46:00.300 --> 46:01.300
对吧

46:01.300 --> 46:02.300
那么我们这里

46:02.300 --> 46:04.300
首先要搞定对象的窗间

46:04.300 --> 46:05.300
怎么来搞定对象的窗间呢

46:05.300 --> 46:07.300
我们这里可以写个内

46:07.300 --> 46:08.300
class

46:08.300 --> 46:09.300
叫做

46:09.300 --> 46:11.300
名字就该取个file吧

46:11.300 --> 46:12.300
一个file

46:12.300 --> 46:13.300
内

46:13.300 --> 46:15.300
constructor

46:15.300 --> 46:17.300
勾招器里面你给我传入一些什么呢

46:17.300 --> 46:18.300
其实非常简单

46:18.300 --> 46:20.300
你有哪些属性

46:20.300 --> 46:21.300
你给我传进来就行了

46:21.300 --> 46:22.300
比方说

46:22.300 --> 46:23.300
NAM

46:23.300 --> 46:24.300
你说给我传进来

46:24.300 --> 46:25.300
对不对

46:25.300 --> 46:26.300
NAM给我传进来

46:26.300 --> 46:27.300
还有什么呢

46:27.300 --> 46:28.300
后绝名

46:28.300 --> 46:30.300
其实后绝名的话

46:30.300 --> 46:31.300
我都可以用那个

46:31.300 --> 46:33.300
我们之前学过的PASS模块

46:33.300 --> 46:34.300
来进行分析了

46:34.300 --> 46:35.300
后绝名你不用给我传

46:35.300 --> 46:36.300
你给我传一个文件名义来

46:36.300 --> 46:37.300
就行了

46:37.300 --> 46:38.300
然后easefile

46:38.300 --> 46:39.300
这个东西

46:39.300 --> 46:40.300
你给我传进来

46:40.300 --> 46:42.300
干脆全部传吧

46:42.300 --> 46:43.300
easefile

46:43.300 --> 46:44.300
然后呢

46:44.300 --> 46:46.300
size

46:46.300 --> 46:48.300
crease10

46:48.300 --> 46:50.300
然后update10

46:50.300 --> 46:51.300
对吧

46:51.300 --> 46:52.300
把这些东西传进来

46:52.300 --> 46:53.300
然后保存起来

46:53.300 --> 46:54.300
内

46:54.300 --> 46:55.300
等于内

46:55.300 --> 46:56.300
this est

46:56.300 --> 46:57.300
w est

46:57.300 --> 46:59.300
this easefile

46:59.300 --> 47:01.300
等于es5

47:01.300 --> 47:03.300
this size

47:03.300 --> 47:05.300
w size

47:05.300 --> 47:07.300
this create10

47:07.300 --> 47:09.300
create10

47:09.300 --> 47:11.300
this update10

47:11.300 --> 47:12.300
那么现在目前这种写法呢

47:12.300 --> 47:13.300
这个函数呢

47:13.300 --> 47:14.300
就用起来很不方便

47:14.300 --> 47:16.300
这个构造器用起来很不方便

47:16.300 --> 47:17.300
我们其实呢

47:17.300 --> 47:18.300
你给我一个路径

47:18.300 --> 47:19.300
我就是不是把这些东西

47:19.300 --> 47:20.300
全部可以得到了

47:20.300 --> 47:21.300
文件名

47:21.300 --> 47:22.300
这些乱七八糟

47:22.300 --> 47:23.300
是不是全部可以得到了

47:23.300 --> 47:24.300
你只需要给我一个路径就行了

47:24.300 --> 47:25.300
那么我们这里呢

47:25.300 --> 47:27.300
可以写一个静态的方法

47:27.300 --> 47:29.300
think

47:29.300 --> 47:30.300
标记一下

47:30.300 --> 47:31.300
静态方法

47:31.300 --> 47:32.300
方可写

47:34.300 --> 47:36.300
静态的一个方法

47:36.300 --> 47:37.300
我们这里的给他取个方法名字

47:37.300 --> 47:40.300
叫做getfile

47:40.300 --> 47:41.300
getfile

47:41.300 --> 47:44.300
你只需要把一个路径传给我

47:44.300 --> 47:45.300
那么我就来帮助你

47:45.300 --> 47:46.300
构建一个file对象

47:46.300 --> 47:47.300
对吧

47:47.300 --> 47:48.300
我们写个静态的

47:48.300 --> 47:50.300
那么到时候我们来用的时候

47:50.300 --> 47:51.300
怎么用呢

47:51.300 --> 47:52.300
我们先一步一步测试

47:52.300 --> 47:53.300
这个不着急

47:53.300 --> 47:54.300
一步一步测试

47:54.300 --> 47:56.300
下面先出示掉

47:56.300 --> 47:58.300
到时候我们怎么用呢

47:58.300 --> 47:59.300
就是athink

47:59.300 --> 48:01.300
写个测试函数

48:01.300 --> 48:05.300
比方说我要给你的文件路径

48:05.300 --> 48:06.300
是这个

48:06.300 --> 48:08.300
file

48:08.300 --> 48:09.300
pass

48:09.300 --> 48:10.300
result

48:13.300 --> 48:15.300
当前myfile是下面的

48:15.300 --> 48:17.300
1.jpeg

48:20.300 --> 48:21.300
我给你这个

48:21.300 --> 48:22.300
那么我现在呢

48:22.300 --> 48:24.300
调用这个file里面的静态方法

48:24.300 --> 48:25.300
叫做getfile

48:25.300 --> 48:27.300
把这个file name传进去

48:27.300 --> 48:28.300
它是一个一步的

48:28.300 --> 48:29.300
它是一个一步的

48:29.300 --> 48:30.300
所以我要等待

48:30.300 --> 48:31.300
wait

48:31.300 --> 48:32.300
拿到过后呢

48:32.300 --> 48:33.300
是不是拿到一个file对象

48:33.300 --> 48:35.300
输出file对象

48:35.300 --> 48:36.300
因此这个函数里面

48:36.300 --> 48:37.300
要做的事情很简单

48:38.300 --> 48:39.300
最终呢

48:39.300 --> 48:40.300
最终我要干嘛

48:40.300 --> 48:41.300
最终我肯定是要

48:41.300 --> 48:42.300
6一个file

48:42.300 --> 48:43.300
我要6一个file

48:43.300 --> 48:44.300
把这些信息

48:44.300 --> 48:45.300
乱七八糟的信息

48:45.300 --> 48:46.300
一次传进去

48:46.300 --> 48:48.300
然后把6的file返回

48:48.300 --> 48:50.300
我一定要做这么一件事

48:50.300 --> 48:51.300
但是这个事情

48:51.300 --> 48:52.300
因为它里面

48:52.300 --> 48:53.300
要传很多的信息

48:53.300 --> 48:54.300
这些信息

48:54.300 --> 48:55.300
我是不是要一次去拿到

48:55.300 --> 48:57.300
是不是要一次拿到

48:57.300 --> 48:58.300
那怎么来拿到

48:58.300 --> 48:59.300
这些信息呢

48:59.300 --> 49:01.300
怎么来拿到呢

49:01.300 --> 49:02.300
我们是不是

49:02.300 --> 49:03.300
你看这里

49:03.300 --> 49:04.300
我们现在

49:04.300 --> 49:05.300
只有一个file name

49:05.300 --> 49:06.300
对不对

49:06.300 --> 49:07.300
file name

49:07.300 --> 49:08.300
是不是去找这个文件

49:08.300 --> 49:09.300
对吧

49:09.300 --> 49:10.300
所以要找这个文件

49:10.300 --> 49:11.300
来吧

49:11.300 --> 49:12.300
一个个找

49:12.300 --> 49:13.300
我们这个文件里面

49:13.300 --> 49:14.300
有很多的信息

49:14.300 --> 49:15.300
我们就可以利用

49:15.300 --> 49:16.300
这个fs模块里面的

49:16.300 --> 49:17.300
什么

49:17.300 --> 49:18.300
stat

49:18.300 --> 49:19.300
file name

49:19.300 --> 49:20.300
传进去

49:20.300 --> 49:21.300
这样子

49:21.300 --> 49:22.300
是不是可以拿到

49:22.300 --> 49:23.300
这个文件里面的所有信息

49:23.300 --> 49:24.300
wait

49:25.300 --> 49:26.300
stat

49:26.300 --> 49:27.300
来吧

49:27.300 --> 49:28.300
我们一个一个获取

49:28.300 --> 49:29.300
第一个是文件名

49:29.300 --> 49:30.300
文件名

49:30.300 --> 49:31.300
文件名

49:31.300 --> 49:32.300
是不是就是file name

49:32.300 --> 49:33.300
file name

49:33.300 --> 49:35.300
这里边应该还有一个

49:35.300 --> 49:36.300
还有一个属性

49:36.300 --> 49:38.300
你不能把他绝对路径搞丢了

49:40.300 --> 49:43.580
file name

49:43.580 --> 49:44.580
完整的路径

49:44.580 --> 49:45.580
完整的路径

49:45.580 --> 49:46.580
来吧

49:47.580 --> 49:48.580
这个name

49:48.580 --> 49:49.580
就是他只有文件名

49:49.580 --> 49:50.580
比方说我给他传了这个

49:50.580 --> 49:51.580
然后name

49:51.580 --> 49:52.580
他只有这一块

49:52.580 --> 49:53.580
对不对

49:53.580 --> 49:54.580
是不是只有这一块

49:54.580 --> 49:55.580
那么这个东西怎么来取呢

49:55.580 --> 49:56.580
我们是不是

49:56.580 --> 49:57.580
我们以前学过了

49:57.580 --> 49:58.580
pass里面有什么

49:59.580 --> 50:00.580
pass里面

50:00.580 --> 50:01.580
不是有一个东西

50:01.580 --> 50:02.580
叫做base name

50:02.580 --> 50:03.580
我们把file name

50:03.580 --> 50:04.580
传进去

50:04.580 --> 50:05.580
是不是就可以取到他的name

50:05.580 --> 50:06.580
一个个来

50:06.580 --> 50:07.580
name是不是就拿到了

50:07.580 --> 50:08.580
你看

50:08.580 --> 50:09.580
现在有两个数据

50:09.580 --> 50:10.580
file name 拿到了

50:10.580 --> 50:11.580
还有什么呢

50:11.580 --> 50:12.580
name 拿到了

50:12.580 --> 50:13.580
来看一下

50:13.580 --> 50:15.580
我们目前的效果

50:16.580 --> 50:18.890
来吧

50:18.890 --> 50:19.890
运行

50:19.890 --> 50:20.890
没输出是吧

50:20.890 --> 50:22.890
没运行tests

50:22.890 --> 50:26.900
他说什么呢

50:26.900 --> 50:27.900
callback

50:27.900 --> 50:28.900
这里要用那个

50:28.900 --> 50:30.900
promises

50:30.900 --> 50:33.790
你看

50:33.790 --> 50:34.790
是不是拿到file name

50:34.790 --> 50:35.790
和name

50:35.790 --> 50:36.790
是不是这样拿到了

50:36.790 --> 50:37.790
对不对

50:37.790 --> 50:38.790
好

50:38.790 --> 50:39.790
又来

50:40.790 --> 50:41.790
这两个拿到之后呢

50:41.790 --> 50:43.790
我们又干嘛呢

50:43.790 --> 50:44.790
我们现在的孩子

50:44.790 --> 50:45.790
还差什么信息

50:45.790 --> 50:46.790
还差est

50:46.790 --> 50:47.790
esd也很简单

50:47.790 --> 50:48.790
我们可以来自于

50:48.790 --> 50:49.790
pass

50:49.790 --> 50:50.790
stname

50:50.790 --> 50:51.790
把file name

50:51.790 --> 50:52.790
传进去

50:52.790 --> 50:53.790
是不是可以拿到这个

50:53.790 --> 50:54.790
后维名

50:54.790 --> 50:55.790
保存

50:57.790 --> 50:58.790
你看呀

50:58.790 --> 50:59.790
esd

50:59.790 --> 51:00.790
esd没传进去

51:00.790 --> 51:01.790
esd

51:02.790 --> 51:03.790
esd怎么拿到了

51:03.790 --> 51:04.790
调GPEG

51:04.790 --> 51:05.790
还有什么esfile

51:05.790 --> 51:07.790
他是不是一个文件

51:07.790 --> 51:08.790
是不是一个文件

51:08.790 --> 51:09.790
是不是我们可以通过这个

51:10.790 --> 51:11.790
esfile

51:11.790 --> 51:12.790
stat

51:12.790 --> 51:13.790
esfile

51:13.790 --> 51:14.790
对

51:14.790 --> 51:15.790
file

51:15.790 --> 51:16.790
对吧

51:16.790 --> 51:17.790
我们可以通过他来判断

51:17.790 --> 51:19.790
他到底是不是一个文件

51:19.790 --> 51:20.790
然后把他传进去

51:20.790 --> 51:21.790
esfile

51:23.790 --> 51:24.790
好 又来看

51:24.790 --> 51:25.790
我们一个个写

51:25.790 --> 51:26.790
一个个看

51:26.790 --> 51:27.790
esfile

51:27.790 --> 51:28.790
传进来了

51:28.790 --> 51:29.790
又来

51:29.790 --> 51:30.790
还有什么呢

51:30.790 --> 51:31.790
还有size

51:31.790 --> 51:32.790
size

51:32.790 --> 51:33.790
stat

51:34.790 --> 51:35.790
什么

51:35.790 --> 51:36.790
就是size

51:36.790 --> 51:37.790
字节

51:37.790 --> 51:41.060
放进去

51:41.060 --> 51:42.060
还有什么

51:42.060 --> 51:43.060
还有

51:43.060 --> 51:44.060
create 10

51:44.060 --> 51:45.060
update 10

51:45.060 --> 51:46.060
好 来吧

51:46.060 --> 51:48.060
create 10

51:48.060 --> 51:49.060
等于

51:49.060 --> 51:51.060
new一个stat

51:51.060 --> 51:52.060
stat

51:52.060 --> 51:53.060
叫做

51:53.060 --> 51:54.060
first 10

51:55.060 --> 51:57.060
然后还有就是update 10

51:58.060 --> 51:59.060
update 10

51:59.060 --> 52:00.060
那么这里来自于

52:00.060 --> 52:02.060
他的就是

52:03.060 --> 52:04.060
modify

52:04.060 --> 52:05.060
ametime

52:06.060 --> 52:07.060
create 10

52:08.060 --> 52:09.060
通过这种方式

52:09.060 --> 52:11.060
我们就可以非常轻松的

52:11.060 --> 52:12.060
一个通过一个静态方法

52:12.060 --> 52:13.060
只需要给我一个文件路径

52:13.060 --> 52:14.060
我就把这些信息

52:14.060 --> 52:15.060
全部拿到了

52:15.060 --> 52:16.060
好 保存

52:16.060 --> 52:18.440
你看

52:18.440 --> 52:19.440
是不是全部拿到了

52:19.440 --> 52:20.440
对不对

52:20.440 --> 52:21.440
而且他可以

52:21.440 --> 52:22.440
分辨目录

52:22.440 --> 52:23.440
还是文件

52:23.440 --> 52:24.440
比方说我们是一个

52:24.440 --> 52:25.440
一个目录

52:25.440 --> 52:26.440
他不是文件

52:27.440 --> 52:28.440
你看

52:28.440 --> 52:29.440
目录看是不是正确的

52:29.440 --> 52:30.440
esfile

52:30.440 --> 52:31.440
你看

52:31.440 --> 52:32.440
name目录的名称

52:32.440 --> 52:33.440
对不对

52:33.440 --> 52:34.440
然后 esfile

52:34.440 --> 52:35.440
force

52:35.440 --> 52:36.440
那么这些东西是不是都拿到了

52:36.440 --> 52:37.440
size 0

52:37.440 --> 52:38.440
create 10

52:38.440 --> 52:39.440
这个东西显示不出来

52:39.440 --> 52:41.440
好 那么现在属性是不是搞定了

52:41.440 --> 52:42.440
属性是不是搞定了

52:42.440 --> 52:43.440
通过这个东西来

52:43.440 --> 52:44.440
创建一个对象

52:44.440 --> 52:46.440
好 现在方法

52:46.440 --> 52:47.440
方法的话

52:47.440 --> 52:48.440
我们在这里边写上

52:48.440 --> 52:49.440
两个方法

52:49.440 --> 52:50.440
这里我们需要做两个方法

52:50.440 --> 52:51.440
一个skate solution

52:51.440 --> 52:52.440
一个skate content

52:52.440 --> 52:53.440
我们先来一个简单的

52:53.440 --> 52:54.440
get content

52:54.440 --> 52:56.440
现在这个方法

52:56.440 --> 52:57.440
就是把当前

52:57.440 --> 52:58.440
这个文件里边的内容

52:58.440 --> 52:59.440
给他读出来

52:59.440 --> 53:01.440
把文件内容读出来

53:01.440 --> 53:02.440
那么这个内容

53:02.440 --> 53:03.440
首先要判断一下

53:03.440 --> 53:05.440
我自己是文件

53:05.440 --> 53:06.440
还是目录

53:06.440 --> 53:08.440
如果说 this is file

53:08.440 --> 53:10.440
如果说我是一个文件的话

53:10.440 --> 53:12.440
我才能去读这个内容

53:12.440 --> 53:13.440
else

53:13.440 --> 53:14.440
如果说我不是文件的话

53:14.440 --> 53:15.440
我能读内容吗

53:15.440 --> 53:16.440
是读不了

53:16.440 --> 53:17.440
所以说这里怎么说的

53:17.440 --> 53:19.440
如果说我是一个

53:19.440 --> 53:20.440
目录的话

53:20.440 --> 53:21.440
那么返回law

53:21.440 --> 53:23.440
else 我就返回law

53:23.440 --> 53:25.440
我们直接在这里

53:25.440 --> 53:26.440
return

53:26.440 --> 53:28.440
那么如果是文件的话

53:28.440 --> 53:29.440
我才去读去文件内容

53:29.440 --> 53:31.440
那么这里还有一个参数

53:31.440 --> 53:32.440
叫做 is buffer

53:32.440 --> 53:34.440
我给大家一个默认值

53:34.440 --> 53:35.440
force

53:35.440 --> 53:36.440
他是一个buffer

53:36.440 --> 53:37.440
我们还要判断

53:37.440 --> 53:38.440
is buffer

53:38.440 --> 53:40.440
如果说我要用buffer的方式来读的话

53:40.440 --> 53:42.440
那么我们就用传统的读法

53:42.440 --> 53:44.440
with fs promises

53:44.440 --> 53:45.440
read file

53:45.440 --> 53:47.440
读去文件内容

53:47.440 --> 53:48.440
读去文件内容

53:48.440 --> 53:50.440
然后路径是什么呢

53:50.440 --> 53:51.440
路径是this.file.lay

53:51.440 --> 53:53.440
对吧 我们已经把路径保存下来了

53:53.440 --> 53:55.440
保存我们对象里面的file.lay里面

53:55.440 --> 53:56.440
里面把读出来

53:56.440 --> 53:58.440
好 读出来过后

53:58.440 --> 53:59.440
buffer就不甜了

53:59.440 --> 54:00.440
就是 encoding

54:00.440 --> 54:01.440
我们的就是那个

54:01.440 --> 54:03.440
编码就不甜了

54:03.440 --> 54:04.440
编码不甜的话就是

54:04.440 --> 54:05.440
buffer

54:05.440 --> 54:07.440
好 else

54:07.440 --> 54:08.440
那么我这里呢

54:08.440 --> 54:10.440
反而回到是

54:10.440 --> 54:12.440
要传一个buffer

54:12.440 --> 54:13.440
传一个 encoding

54:13.440 --> 54:14.440
UTF-8

54:14.440 --> 54:15.440
对吧

54:15.440 --> 54:16.440
那么这是get content

54:16.440 --> 54:17.440
咱们来试一下

54:17.440 --> 54:18.440
试一下看行不行

54:18.440 --> 54:19.440
好 我们把这个文件拿到

54:19.440 --> 54:21.440
比方说我们这里是

54:21.440 --> 54:23.440
e.tft

54:24.440 --> 54:25.440
看看

54:25.440 --> 54:27.440
文件是不是拿到了

54:27.440 --> 54:29.440
它文件里面还有一个方法

54:29.440 --> 54:30.440
还有一个方法

54:31.440 --> 54:33.440
file.get content

54:33.440 --> 54:34.440
当然它是一个异部的

54:34.440 --> 54:36.440
我们要用 await

54:36.440 --> 54:39.460
你看 是不是把内容

54:39.460 --> 54:40.460
也可以读出来了

54:40.460 --> 54:41.460
get content

54:41.460 --> 54:42.460
把这个文件的内容

54:42.460 --> 54:43.460
直接读出来

54:43.460 --> 54:44.460
是不是这样子用了

54:44.460 --> 54:45.460
用起来就非常方便了

54:45.460 --> 54:46.460
通过这个对象

54:46.460 --> 54:47.460
对吧

54:47.460 --> 54:49.460
那如果说你是一个目录的话

54:49.460 --> 54:51.460
如果是你是一个目录的话

54:51.460 --> 54:53.460
那么得到就是 now

54:53.460 --> 54:55.460
目录是没法读文件内容的

54:55.460 --> 54:56.460
没问题吧

54:56.460 --> 54:57.460
好 this is get content

54:57.460 --> 54:58.460
get content 的时候

54:58.460 --> 54:59.460
我们还可以传一个 true

54:59.460 --> 55:00.460
表示我们要用buffer的形式

55:00.460 --> 55:01.460
来读去

55:01.460 --> 55:03.460
这里我们还是写上e.tft

55:04.460 --> 55:05.460
你看

55:05.460 --> 55:06.460
那么读出来就是buffer

55:06.460 --> 55:07.460
对吧

55:07.460 --> 55:08.460
我们可以随意的指定

55:08.460 --> 55:10.460
我们希望的读取的方式

55:11.460 --> 55:13.460
好 this is get content

55:13.460 --> 55:14.460
接下来我们来看下一个

55:14.460 --> 55:15.460
think

55:15.460 --> 55:16.460
get children

55:19.460 --> 55:20.460
那么什么意思呢

55:20.460 --> 55:21.460
就是如果说

55:21.460 --> 55:22.460
我是一个目录的话

55:22.460 --> 55:24.460
目录里边是不是还有文件

55:24.460 --> 55:25.460
对吧

55:25.460 --> 55:26.460
那么我们要同样的方式

55:26.460 --> 55:28.460
要去创建一个数组返回

55:28.460 --> 55:29.460
好那么这个地方

55:29.460 --> 55:30.460
我要判断一下

55:30.460 --> 55:31.460
我到底是不是一个目录

55:31.460 --> 55:32.460
如果说 this is file

55:32.460 --> 55:33.460
它是一个文件

55:33.460 --> 55:35.460
那我很简单的返回个空数组

55:35.460 --> 55:36.460
啥都没有

55:36.460 --> 55:37.460
我是文件

55:37.460 --> 55:38.460
我就不可能

55:38.460 --> 55:39.460
文件不可能

55:39.460 --> 55:42.460
不可能有指文件

55:42.460 --> 55:44.460
是不可能有的

55:44.460 --> 55:45.460
好那么如果说

55:45.460 --> 55:46.460
我不是文件的话

55:46.460 --> 55:48.460
那么我是一个目录

55:48.460 --> 55:49.460
那目录的话

55:49.460 --> 55:50.460
我们是不是可以利用

55:50.460 --> 55:52.460
fx promises

55:52.460 --> 55:53.460
read dir

55:53.460 --> 55:55.460
我们把自己这个目录

55:55.460 --> 55:57.460
我们是一个目录

55:57.460 --> 55:58.460
我们是不是可以把一个目录

55:58.460 --> 55:59.460
读出来

55:59.460 --> 56:00.460
对吧

56:00.460 --> 56:02.460
读出来过后

56:02.460 --> 56:04.460
可以拿到一个就是数组

56:04.460 --> 56:05.460
对不对

56:05.460 --> 56:06.460
是不是可以拿到一个数组

56:06.460 --> 56:09.220
qo绝

56:09.220 --> 56:11.220
我们来输出一下这个qo绝

56:11.220 --> 56:12.220
比方说

56:12.220 --> 56:14.220
我这里刚传的是一个目录

56:14.220 --> 56:15.220
传的是一个目录的话

56:15.220 --> 56:17.220
然后我们调用

56:17.220 --> 56:19.220
得到这个对象

56:19.220 --> 56:21.220
然后我们在这里调用

56:21.220 --> 56:23.220
getqo绝

56:23.220 --> 56:24.220
qo绝

56:24.220 --> 56:25.220
方法

56:25.220 --> 56:26.220
那么它返回的

56:26.220 --> 56:27.220
返回的应该是这个数组

56:27.220 --> 56:29.220
返回的应该是这个数组

56:29.220 --> 56:30.220
怎么返回

56:31.220 --> 56:36.060
这里不输出了

56:36.060 --> 56:38.060
你看是不是返回这个数组

56:38.060 --> 56:39.060
返回里边的东西

56:39.060 --> 56:40.060
对吧

56:40.060 --> 56:42.060
然后我要干嘛

56:42.060 --> 56:43.060
我要干嘛

56:43.060 --> 56:44.060
我要的是不是这个数组

56:44.060 --> 56:45.060
不是

56:45.060 --> 56:46.060
我要的是数组里面

56:46.060 --> 56:47.060
每一个是一个对象

56:47.060 --> 56:49.060
又是一个这个对象

56:49.060 --> 56:50.060
对吧

56:50.060 --> 56:51.060
是不是又是一个这个对象

56:51.060 --> 56:52.060
那么我怎么办

56:52.060 --> 56:53.060
qo绝

56:53.060 --> 56:54.060
map

56:54.060 --> 56:55.060
你看

56:55.060 --> 56:57.060
这里把它变成nets

56:57.060 --> 56:59.060
重新给qo绝复制

56:59.060 --> 57:00.060
qo绝等于什么呢

57:00.060 --> 57:01.060
map

57:01.060 --> 57:02.060
映射

57:02.060 --> 57:04.060
把里边的每一个name

57:04.060 --> 57:05.060
来进行映射

57:05.060 --> 57:07.060
映射成为一个什么呢

57:07.060 --> 57:09.060
是不是我们又调用这个

57:09.060 --> 57:10.060
getfile

57:10.060 --> 57:11.060
是不是又调用它

57:11.060 --> 57:13.060
叫做file.getfile

57:13.060 --> 57:14.060
我们把什么传进去

57:14.060 --> 57:15.060
要把一个完整路径传进去

57:15.060 --> 57:17.060
但是这里是不是完整路径

57:17.060 --> 57:18.060
不是

57:18.060 --> 57:19.060
我要把这个路径

57:19.060 --> 57:20.060
跟我的当前路径

57:20.060 --> 57:21.060
是不是要进行拼接

57:21.060 --> 57:23.060
才能成为一个完整的路径

57:23.060 --> 57:24.060
那怎么来拼接呢

57:24.060 --> 57:25.060
非常简单

57:25.060 --> 57:26.060
我们可以用pass嘛

57:26.060 --> 57:27.060
passyou来吧

57:27.060 --> 57:28.060
resolve

57:28.060 --> 57:30.060
thisfile name

57:30.060 --> 57:31.060
然后呢

57:31.060 --> 57:32.060
name是不是来拼接

57:32.060 --> 57:33.060
对吧

57:33.060 --> 57:34.060
来得到一个什么呢

57:34.060 --> 57:37.570
就是result

57:37.570 --> 57:38.570
是不是这样子

57:38.570 --> 57:40.570
这样子呢

57:40.570 --> 57:42.570
得到了是不是一系列的promise

57:42.570 --> 57:43.570
对吧

57:43.570 --> 57:44.570
这样子映射出来

57:44.570 --> 57:45.570
因为这个东西是一个异步的

57:45.570 --> 57:46.570
对吧

57:46.570 --> 57:48.570
是不是得到一个很多的promise

57:48.570 --> 57:49.570
那么等这些promise

57:49.570 --> 57:51.570
全部解决完了过后

57:51.570 --> 57:52.570
是不是就完事了

57:52.570 --> 57:53.570
对不对

57:53.570 --> 57:54.570
因此呢

57:54.570 --> 57:55.570
我们这里返回什么呢

57:55.570 --> 57:56.570
返回promise

57:57.570 --> 57:59.570
所以说这些基础

58:00.570 --> 58:01.570
看不懂了

58:01.570 --> 58:02.570
基础可能不老

58:02.570 --> 58:04.570
这里得到了全是promise

58:04.570 --> 58:05.570
因为这里返回了

58:05.570 --> 58:07.570
返回了一个制服串

58:07.570 --> 58:08.570
我这里一个制服串

58:08.570 --> 58:09.570
拿到了过后呢

58:09.570 --> 58:10.570
比方说这个一

58:10.570 --> 58:11.570
一打到过后

58:11.570 --> 58:12.570
我是不是把这个路径

58:12.570 --> 58:13.570
把这个file

58:13.570 --> 58:15.570
把这个file里面的file name

58:15.570 --> 58:20.310
打印出来吧

58:20.310 --> 58:21.310
把这个file打印出来

58:21.310 --> 58:24.710
先把这个注射掉

58:24.710 --> 58:25.710
你看这个file里面

58:25.710 --> 58:26.710
是不是一个file name

58:26.710 --> 58:27.710
那么我们把这个file name

58:27.710 --> 58:28.710
是不是要跟这个

58:28.710 --> 58:29.710
这个name来进行拼接

58:29.710 --> 58:30.710
对吧

58:30.710 --> 58:31.710
是不是要进行拼接

58:31.710 --> 58:32.710
你看

58:32.710 --> 58:34.710
我们把我们自己的file name

58:34.710 --> 58:35.710
来进行拼接

58:35.710 --> 58:37.710
每一个拼接会

58:37.710 --> 58:38.710
是不是就完整路径了

58:38.710 --> 58:39.710
然后把完整路径

58:39.710 --> 58:40.710
又来传进去

58:40.710 --> 58:41.710
是不是又得到一个东西

58:41.710 --> 58:42.710
那么得到一个promise

58:42.710 --> 58:43.710
对吧

58:43.710 --> 58:44.710
那么这个玩意

58:44.710 --> 58:45.710
promise

58:45.710 --> 58:46.710
是不是

58:46.710 --> 58:47.710
这里就是个promise的宿主

58:47.710 --> 58:48.710
等这个promise

58:48.710 --> 58:49.710
全部完成之后

58:49.710 --> 58:51.710
那么整个promise再完成

58:51.710 --> 58:52.710
所以我们最后

58:52.710 --> 58:53.710
返回一个promise

58:53.710 --> 58:54.710
好

58:54.710 --> 58:58.240
最后我们来看一下

58:58.240 --> 58:59.240
能不能达到

58:59.240 --> 59:00.240
我们想要的效果

59:01.240 --> 59:02.240
你看

59:02.240 --> 59:03.240
说得到了

59:03.240 --> 59:04.240
我们的宿主里面

59:04.240 --> 59:06.240
是不是有一个一个的对象

59:06.240 --> 59:07.240
对吧

59:07.240 --> 59:08.240
是不是有一个对象

59:08.240 --> 59:09.240
这个是

59:09.240 --> 59:10.240
这个不是文件

59:10.240 --> 59:11.240
对吧

59:11.240 --> 59:12.240
这个是一个文件

59:12.240 --> 59:13.240
这个是一个文件

59:13.240 --> 59:15.240
这个是一个文件

59:15.240 --> 59:16.240
这个呢

59:16.240 --> 59:17.240
是一个文件

59:17.240 --> 59:18.240
这个呢

59:18.240 --> 59:19.240
不是一个文件

59:19.240 --> 59:20.240
对不对

59:20.240 --> 59:21.240
是吧

59:21.240 --> 59:22.240
很有意思吧

59:22.240 --> 59:23.240
OK

59:23.240 --> 59:24.240
那么现在呢

59:24.240 --> 59:25.240
我们就把它完成了

59:25.240 --> 59:26.240
好

59:26.240 --> 59:27.240
最后呢

59:27.240 --> 59:28.240
我们把落实到

59:28.240 --> 59:29.240
最后的方法

59:29.240 --> 59:30.240
落实到这一块

59:30.240 --> 59:31.240
因为我们最终

59:31.240 --> 59:32.240
是为了写这个方法

59:32.240 --> 59:33.240
对吧

59:33.240 --> 59:34.240
这个方法怎么写

59:34.240 --> 59:35.240
怎么写

59:35.240 --> 59:36.240
file

59:36.240 --> 59:37.240
get file

59:37.240 --> 59:38.240
del

59:38.240 --> 59:39.240
那传进去

59:39.240 --> 59:40.240
我们目录名字传进去

59:40.240 --> 59:41.240
返回什么呢

59:41.240 --> 59:42.240
返回 file

59:42.240 --> 59:43.240
get children

59:44.240 --> 59:45.240
这里用 await

59:46.240 --> 59:47.240
这里用 await

59:48.240 --> 59:49.240
最后呢

59:49.240 --> 59:50.240
来测试一下

59:52.240 --> 59:53.240
好

59:53.240 --> 59:55.240
我们要做的就这么一件事

59:55.240 --> 59:56.240
把del name传进去

59:56.240 --> 59:57.240
然后呢

59:57.240 --> 59:58.240
得到这个结果

59:58.240 --> 59:59.240
rid的del

59:59.240 --> 01:00:01.240
把riddel里面得到一个结果

01:00:01.240 --> 01:00:02.240
就是个宿主

01:00:03.240 --> 01:00:04.240
好

01:00:07.320 --> 01:00:08.320
是不得个宿主

01:00:08.320 --> 01:00:09.320
而且这个宿主呢

01:00:09.320 --> 01:00:10.320
还有无限地规能力

01:00:10.320 --> 01:00:11.320
比方说

01:00:11.320 --> 01:00:12.320
我们看一下

01:00:12.320 --> 01:00:14.320
得到这个宿主里面

01:00:14.320 --> 01:00:15.320
第1项

01:00:15.320 --> 01:00:16.320
第1项不是一个目录吗

01:00:16.320 --> 01:00:24.970
对吧

01:00:24.970 --> 01:00:25.970
好

01:00:25.970 --> 01:00:26.970
现在呢

01:00:26.970 --> 01:00:27.970
我们要把这个宿主的第1项

01:00:27.970 --> 01:00:29.970
result0

01:00:29.970 --> 01:00:30.970
当然那里

01:00:30.970 --> 01:00:31.970
也可以评判去做任何事情

01:00:31.970 --> 01:00:32.970
得到第1项

01:00:32.970 --> 01:00:33.970
第1项里面

01:00:33.970 --> 01:00:34.970
因为它是一个 file对象

01:00:34.970 --> 01:00:35.970
对吧

01:00:35.970 --> 01:00:36.970
而且它是一个目录

01:00:36.970 --> 01:00:37.970
它是一个目录

01:00:37.970 --> 01:00:38.970
我们又可以用get children

01:00:39.970 --> 01:00:40.970
又可以得到这个目录

01:00:40.970 --> 01:00:41.970
下面的东西

01:00:41.970 --> 01:00:42.970
Away

01:00:42.970 --> 01:00:43.970
就非常的方便

01:00:45.970 --> 01:00:46.970
data

01:00:46.970 --> 01:00:49.540
输出

01:00:49.540 --> 01:00:53.450
data

01:00:53.450 --> 01:00:54.450
你看

01:00:54.450 --> 01:00:55.450
是不是得到这两个

01:00:55.450 --> 01:00:56.450
对吧

01:00:56.450 --> 01:00:57.450
这个地方可能有点绕

01:00:57.450 --> 01:00:58.450
可能稍微有点绕

01:00:58.450 --> 01:00:59.450
其实呢

01:00:59.450 --> 01:01:00.450
锻炼的也是基础

01:01:00.450 --> 01:01:01.450
你把Promise

01:01:01.450 --> 01:01:02.450
像这些异部的东西

01:01:02.450 --> 01:01:03.450
搞清楚的话

01:01:03.450 --> 01:01:04.450
其实也没有多少

01:01:04.450 --> 01:01:05.450
OK

01:01:05.450 --> 01:01:07.450
那这是关于这一块

01:01:07.450 --> 01:01:08.450
然后你们下来了

01:01:08.450 --> 01:01:09.450
尽量吧

01:01:09.450 --> 01:01:10.450
尽自己的

01:01:10.450 --> 01:01:11.450
因为我觉得还是蛮简单的

01:01:11.450 --> 01:01:13.450
不知道你们会觉得怎么样

01:01:13.450 --> 01:01:14.450
尽量吧

01:01:14.450 --> 01:01:15.450
如果说你们觉得

01:01:15.450 --> 01:01:16.450
太复杂的话

01:01:16.450 --> 01:01:18.450
至少你要把这一块练习一遍

01:01:18.450 --> 01:01:19.450
不然的话

01:01:19.450 --> 01:01:20.450
后边是搞不清楚的

01:01:20.450 --> 01:01:21.450
因为后边

01:01:21.450 --> 01:01:22.450
我们可能会用到

01:01:22.450 --> 01:01:23.450
这个FS模块

01:01:23.450 --> 01:01:24.450
好了

01:01:24.450 --> 01:01:25.450
那这就是文件的IO

01:01:25.450 --> 01:01:26.450
下去练习一下

