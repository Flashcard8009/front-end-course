WEBVTT

00:00.370 --> 00:05.730
好 咱们能这一颗呢 把这个补充一下啊 之前呢 没有讲

00:09.170 --> 00:10.210
其实就把这个图片读懂

00:11.250 --> 00:16.690
这个图片呢 你们在网上呢 也可以看到啊 这是我刚才自己画的啊 在网上看到类似的图片 对吧

00:17.090 --> 00:20.530
但是呢 很少有博客把彻底的解释清楚 他到底是一个怎么回事

00:21.290 --> 00:25.650
大家看看中间什么个框框 看这个黑色的框框 把中间这一坨框起来

00:26.130 --> 00:29.010
这一部分就是漏的解释 他内部的东西

00:29.890 --> 00:38.690
然后上面呢 就是我们的代码 我们一块来说吧 首先看一下主要是看漏的是怎么回事啊 这个我们代码怎么去执行的 已经漏的里边还在组成部分

00:39.490 --> 00:43.890
呃 这个是我们的用户代码 我来边看图呢

00:44.930 --> 00:49.650
边把他 边把他那个就是说明一下啊 完全要不然我就把这个图

00:50.370 --> 00:53.810
出 出这一箱 然后粘过来

00:55.490 --> 00:59.250
粘过来了 粘过来了 粘过来了我这样了

01:00.450 --> 01:04.450
哎 他这个图片怎么弄的 格式图像

01:06.370 --> 01:09.490
插入图片 图片路径

01:11.010 --> 01:15.250
图片路径 我们就用看怎么怎么弄 图片路径

01:18.400 --> 01:20.080
呃 在这

01:21.600 --> 01:24.000
贼 呃 漏的解释

01:25.920 --> 01:29.600
呃 不行啊 你这个哦 可以啊 可以可以

01:30.960 --> 01:33.520
这这这这绝对路径啊 绝对路径也不行啊

01:34.240 --> 01:36.160
也不行啊 应该可以写相对路径的

01:36.880 --> 01:37.440
啊

01:38.800 --> 01:45.120
哦哦 哦 行啊 可以他这样自动创传到那个自动创传到我的 我那个就是网上去了啊 那行

01:45.120 --> 01:46.660
要把图片扔这

01:47.160 --> 01:48.960
扔这过后面在这下面也解释

01:49.220 --> 01:49.980
来吧

01:50.240 --> 01:52.020
我这边的图片不要了

01:53.820 --> 01:55.100
就把这图片搞清楚就行了

01:55.100 --> 01:56.140
第一个是拥护代码

01:59.810 --> 02:01.350
拥护代码是什么代码呢

02:01.610 --> 02:06.470
大家看这个绿色的这个蓝色的区域啊蓝色的区域都表示的是GS代码

02:06.730 --> 02:10.050
拥护代码呢我们一般来说啊写的是GS代码

02:11.680 --> 02:12.960
GS代码

02:19.210 --> 02:20.730
就是GS代码

02:20.990 --> 02:23.810
是谁编写的呢就是开发者

02:24.330 --> 02:25.090
编写的

02:25.730 --> 02:28.470
用我们之前写的什么服务器的代码对吧

02:28.730 --> 02:31.030
见了很多的GS文件啊就是我们的拥护代码

02:31.290 --> 02:32.050
这个很简单对不对

02:32.570 --> 02:35.630
拥护代码里边的他可能会用到第三方库的代码

02:35.890 --> 02:36.650
比如说Express

02:36.910 --> 02:37.950
是我们安装的第三方库

02:38.450 --> 02:42.810
第三方库的他其实绝大部分第三方库啊还是使用的是GS代码出写的

02:43.310 --> 02:45.110
所以说我们也用蓝色来标记

02:45.370 --> 02:49.450
安装过后是不是放到用NPM安装放到哪儿呢

02:49.710 --> 02:50.990
放到loaded margins目录下面去

02:51.250 --> 02:51.750
对吧

02:52.010 --> 02:53.050
那么第二个是那个

02:53.550 --> 02:54.070
第三方库

02:55.050 --> 02:56.830
大部分啊

02:57.090 --> 02:57.850
大部分

02:58.110 --> 02:58.890
仍然

02:59.150 --> 03:00.170
是GS代码

03:00.430 --> 03:01.710
有没有其他的情况呢有啊

03:01.970 --> 03:03.490
我们其他情况不在我们考虑之内

03:03.750 --> 03:05.290
大部分情况呢仍然是GS代码

03:06.050 --> 03:07.330
有其他开发者

03:08.870 --> 03:09.630
开发者

03:09.890 --> 03:10.650
编写

03:10.910 --> 03:13.990
其实对于loaded GS而言这两种代码并没有什么区别

03:14.250 --> 03:15.770
因为都是普通普通的GS代码

03:16.030 --> 03:19.370
只不过位置放的地方不一样对不对这个方式loaded margins目录是力量

03:19.630 --> 03:21.410
那么这个黑色的箭头表示什么意思

03:21.670 --> 03:23.210
黑色箭头表示调用的意思啊

03:23.670 --> 03:24.450
表示调用

03:24.710 --> 03:27.510
这里边调用了第三方代码就是通过require对不对

03:27.770 --> 03:29.310
把导入进来然后调用它里面的API

03:30.330 --> 03:33.150
好我们的用户代码也好第三方库代码也好

03:33.410 --> 03:34.430
他们还要调用什么呢

03:34.690 --> 03:36.730
有可能会调用loaded GS的本地代码

03:36.990 --> 03:38.010
本地模块代码

03:38.270 --> 03:40.570
我们以前把它叫做什么内置模块对吧

03:40.830 --> 03:42.870
实际上它的单车叫做native modules

03:43.650 --> 03:45.170
叫做本地模块

03:45.430 --> 03:47.990
我们也习惯了把叫内置模块也可以

03:48.510 --> 03:50.810
那么这个地方呢就是好像我们的FS啊

03:51.110 --> 03:51.970
pass啊

03:52.210 --> 03:52.810
atp

03:53.070 --> 03:53.310
net

03:53.570 --> 03:56.510
像我们这个内置代码的都是这个本地模块代码

03:56.770 --> 03:58.710
它其实也是用GS写的

03:58.970 --> 04:01.910
只不过它的处理方式呢稍微有点区别啊

04:02.170 --> 04:03.310
我们以后再详细再说

04:03.570 --> 04:06.110
用户代码它有可能用require FS

04:06.370 --> 04:08.910
第三方库的代码有可能用require net对不对

04:09.170 --> 04:10.110
都有可能使用啊

04:10.370 --> 04:11.510
所以说我们这边再寄

04:13.030 --> 04:13.810
就是内部

04:14.810 --> 04:17.310
本地本地模块代码

04:17.570 --> 04:19.310
它仍然是GS代码

04:20.270 --> 04:21.270
这仍然是GS代码

04:22.470 --> 04:23.470
好然后呢

04:24.470 --> 04:25.170
再往下看

04:26.010 --> 04:27.710
我们的v8引擎

04:28.110 --> 04:29.510
你看一下整个图里边

04:29.510 --> 04:32.370
v8引擎是不是处于一个风暴的中心对吧

04:32.570 --> 04:33.770
就用我们知道的

04:33.910 --> 04:36.270
loader接使实际上是用v8引擎来做的

04:37.170 --> 04:38.610
基于v8引擎的

04:38.670 --> 04:40.310
那么v8引擎到底是一个什么玩意

04:40.310 --> 04:41.270
它干什么事呢

04:42.110 --> 04:42.870
v8引擎

04:44.110 --> 04:45.710
大家可以看到这个图里边呢

04:45.870 --> 04:48.070
我把用了一个黄色的标记

04:48.470 --> 04:50.370
这个黄这个橙色的标记啊

04:50.370 --> 04:51.970
橙色的标记呢表示的是

04:51.970 --> 04:53.570
它的代码是用C加加

04:53.870 --> 04:55.970
或者是C代码出写的啊

04:55.970 --> 04:58.570
因为C和C加加两个语言是可以互相调用的啊

04:58.670 --> 04:59.670
是无缝调用的

04:59.770 --> 05:00.270
所以说呢

05:00.370 --> 05:02.070
我这里面也可能充斥C代码

05:02.070 --> 05:03.470
也可能充斥C加加代码

05:03.570 --> 05:05.870
就这些东西啊都是C和C加写的

05:06.070 --> 05:07.570
那么v8引擎是谁写的

05:07.830 --> 05:09.670
是那个谷歌公司的啊

05:09.870 --> 05:11.370
他写的他提供的v8引擎

05:11.370 --> 05:12.270
而且是开源的

05:12.270 --> 05:13.870
loader接使呢直接把它拉出来用

05:14.170 --> 05:15.970
那么v8引擎他做的是什么事呢

05:15.970 --> 05:16.570
他是C

05:17.470 --> 05:20.070
或者是C加加代码出写的

05:20.370 --> 05:21.370
他的作用是什么呢

05:21.670 --> 05:23.170
作用他其实非常简单

05:23.170 --> 05:25.270
你要说他里边的东西非常非常复杂

05:25.270 --> 05:26.570
他他作用很简单

05:26.870 --> 05:28.770
就就是解释

05:29.570 --> 05:29.970
啊

05:30.370 --> 05:31.770
就是把介式

05:32.370 --> 05:33.070
代码

05:33.370 --> 05:35.370
解释成为

05:35.870 --> 05:37.170
啊机器吗

05:37.670 --> 05:39.670
机器码就直接可以交给硬件执行了啊

05:39.670 --> 05:41.470
像cpu那样就可以直接用了

05:41.670 --> 05:42.570
就这么个意思

05:42.770 --> 05:44.970
他把介式代码直接解释成为机器吗

05:45.070 --> 05:47.270
让他解释的过程是非常非常复杂的啊

05:47.770 --> 05:49.070
那么这就是v8引擎

05:49.470 --> 05:51.570
我们当我们的代码运行的时候

05:51.570 --> 05:54.070
实际上是最终是交给这个v8引擎在运行

05:54.370 --> 05:55.670
啊你看为什么这有这么多键头

05:55.670 --> 05:56.770
这个红色的是什么意思

05:56.770 --> 05:58.770
红色的就表示交付啊

05:58.770 --> 06:00.070
把这个代码交付给谁

06:00.470 --> 06:01.470
我们的用启动的时候

06:01.470 --> 06:04.170
比方说loader我们运行命令loader因这个事

06:04.470 --> 06:06.170
那么是不是把用户代码就交给

06:06.370 --> 06:07.970
啊当然要启动一下loader啊

06:07.970 --> 06:08.670
启动loader过后呢

06:08.670 --> 06:10.370
他就把用户代码交给他吗

06:10.370 --> 06:12.370
v8引擎啊最终是交给v8引擎

06:12.570 --> 06:15.470
然后去编去那个解释执行我们的介式代码

06:15.870 --> 06:17.270
啊最终他他会把他

06:17.370 --> 06:20.270
把个代码变成机器码交付给硬件来执行

06:20.570 --> 06:22.670
就这么个意思啊用户代码

06:22.770 --> 06:24.870
因为我们用户代码里面有可能用到第三方库

06:24.870 --> 06:25.270
对不对

06:25.270 --> 06:26.370
所以第三方库的代码呢

06:26.370 --> 06:29.770
也会交付给v8引擎啊就这么个意思

06:30.070 --> 06:32.070
好如果说用到本地代码本地代码也是介式

06:32.070 --> 06:34.470
对吧也会交付给v8引擎啊

06:34.470 --> 06:36.670
只不过本地代码呢这里呢有一点点特殊啊

06:36.670 --> 06:37.970
我们以后再详细来说

06:39.270 --> 06:41.670
好然后呢我们再看这个这一部分看到了吧

06:41.970 --> 06:46.270
用户代码第三方库代码本地代码本地模后代码啊交付给

06:46.670 --> 06:50.370
v8引擎然后编然后把他解释成为机器码然后执行

06:50.470 --> 06:52.470
对吧但是他就想了一个问题没有

06:53.470 --> 06:55.670
v8引擎里面有没有提供什么接口啊

06:57.170 --> 07:01.370
是没有没有什么接口因为v8引擎它是标准化的

07:01.570 --> 07:02.570
它是那个

07:03.770 --> 07:05.970
仅能支持什么标准的语法对不对

07:05.970 --> 07:08.470
像ES就是ES官方标准的语法

07:08.770 --> 07:12.570
像什么一些新的API就是跟环境相关的API它是没有的

07:13.070 --> 07:16.070
它是没有的像世界循环它其实也没有啊也没有

07:16.670 --> 07:18.270
那么像这些东西呢

07:19.970 --> 07:24.770
v8引擎啊它是没有的比方说像Saturn Turbo像浏览器里面阿迦克斯

07:25.170 --> 07:27.970
对吧像这些像多姆操作对不对

07:27.970 --> 07:31.670
包括LOGGS里面什么FS这些操作啊跟文件相关的操作

07:31.770 --> 07:32.970
这些东西它是缺失的

07:33.770 --> 07:34.570
它是没有的

07:34.970 --> 07:38.370
那怎么办呢v8引擎它提供了一个功能就是可以扩展

07:38.570 --> 07:50.970
v8引擎啊就是可以通过v8引擎的某种机制

07:51.670 --> 07:57.670
扩展其功能啊扩展它的功能比方说像我们的浏览器端的多姆对象的操作

07:57.670 --> 08:00.970
对吧就是给在v8引擎上的扩展实际上就是扩展v8引擎它的核心

08:00.970 --> 08:03.970
实际上是跟那个环境是无关系的啊

08:04.070 --> 08:06.970
然后浏览器里面扩展了什么Saturn Turbo、Saturn Turbo、Timeout

08:06.970 --> 08:08.970
还有什么阿迦克斯跟扩展进去了

08:09.970 --> 08:13.670
那我们在LOGGS的环境里面肯定要设计到很多很多的新的API对不对

08:13.770 --> 08:16.170
跟LOGGS相关的API那么是不是要扩展它的功能

08:16.470 --> 08:17.470
它怎么来扩展的呢

08:17.470 --> 08:18.470
你看那个绿色的箭头

08:18.770 --> 08:20.370
它是通过一个内置模块

08:20.970 --> 08:23.370
内置模块代码叫Building Mode 90

08:23.370 --> 08:24.770
这个是用C和C加写的

08:25.070 --> 08:27.570
要扩展v8引擎你得用C和C加写

08:27.870 --> 08:29.870
知道吧你得用这个东西来写

08:30.270 --> 08:31.670
好那么这个地方

08:32.670 --> 08:34.170
它就扩展了v8引擎

08:35.170 --> 08:35.970
那相当于是

08:36.370 --> 08:38.170
它把这一个碗样

08:38.770 --> 08:41.270
和这一个碗样一起进行编译

08:41.670 --> 08:43.470
编译是不是把v8引擎增强了

08:43.470 --> 08:45.170
它里面有一些多的功能出来了

08:45.470 --> 08:45.970
对不对

08:46.170 --> 08:48.670
它为什么要它扩展了之后给谁用了这个内置模块

08:48.670 --> 08:50.970
它是C和C加写的我们实际是不能用的

08:51.270 --> 08:52.970
它是提供给它用的

08:53.470 --> 08:54.370
就是本地模块

08:55.070 --> 08:56.470
本地模块是不是用GS写的

08:56.670 --> 08:58.570
但是你想GS是个语言

08:58.570 --> 08:59.770
它只是一个语言而已

08:59.870 --> 09:02.670
它没有它不能进行系统功能

09:03.370 --> 09:05.570
那么系统功能比较像读取文件的这些东西

09:05.570 --> 09:07.770
是系统功能是超多系统底层的功能

09:08.070 --> 09:10.170
那么像比较说监听网络接口

09:10.170 --> 09:11.770
监听网络网卡

09:12.070 --> 09:14.770
然后像网卡去写一些数据发生到网络

09:14.770 --> 09:15.570
对吧响应嘛

09:15.970 --> 09:17.470
那这些东西都是系统功能

09:17.670 --> 09:18.770
GS代码是说不到的

09:19.070 --> 09:20.970
那么也就是说在这个它本地模块里边

09:20.970 --> 09:23.970
它实际上是调用了内置模块里边的接口

09:24.170 --> 09:25.570
它怎么调用它

09:25.970 --> 09:28.170
它就必须要把它编一到编一把引擎

09:28.170 --> 09:30.070
里边就把两个东西合并起来编译

09:30.470 --> 09:31.770
编译来进行编译

09:32.170 --> 09:33.570
而真实的情况是什么呢

09:33.570 --> 09:34.670
连这个东西

09:35.570 --> 09:37.570
我们平时下载的下载的漏了之后

09:37.570 --> 09:38.570
安装的漏了之后

09:38.570 --> 09:39.770
就连这个玩意

09:39.770 --> 09:41.370
它也是一起进行编译的

09:41.370 --> 09:42.570
它会把这个GS代码

09:43.370 --> 09:44.770
编译成为谁和谁要加代码

09:44.770 --> 09:48.370
然后把编译的结果跟它一起来组装

09:48.770 --> 09:50.070
一起来组装成一个结果

09:51.370 --> 09:51.970
是这么个意思

09:51.970 --> 09:53.170
但是它提供了一个圆码地图

09:53.170 --> 09:54.370
我就可以看到它的圆码

09:54.370 --> 09:55.770
对吧有些工具可以看到的

09:56.570 --> 09:57.170
没了意思吧

09:57.170 --> 09:58.170
它是这么回事

09:58.170 --> 10:00.570
所以说由于它也参与了编译

10:00.570 --> 10:04.070
因此它可以调用内置模块

10:04.070 --> 10:05.570
我们是根本就不能调用的

10:05.970 --> 10:07.570
我们是不能调用内置模块

10:07.570 --> 10:08.670
就是这里边东西的

10:08.670 --> 10:10.470
我们只能要使用内置的功能

10:10.470 --> 10:12.570
它只能通过它去使用

10:13.570 --> 10:14.070
没了意思吧

10:14.770 --> 10:16.370
这个绿色线上就是编译

10:16.770 --> 10:17.570
合并编译

10:18.070 --> 10:19.670
那么把它的功能进行扩展

10:21.170 --> 10:21.570
好了

10:21.570 --> 10:24.070
那么这个地方在内置模块的运行中

10:24.070 --> 10:26.370
那么这里边就涉及到一些系统功能了

10:26.870 --> 10:31.170
比方说获取当前操作系统的一些信息

10:31.370 --> 10:33.270
比方说读取文件对吧

10:33.270 --> 10:35.370
读写文件都处理操作系统的功能

10:35.470 --> 10:38.270
比方说进程线程管理

10:38.270 --> 10:39.870
咱们下里可说一下进程线程吧

10:40.570 --> 10:43.170
然后比方说网卡的监听

10:43.170 --> 10:47.070
然后来读取然后网卡的写入等等等等

10:47.570 --> 10:49.570
还有往磁盘里面的一些操作

10:49.870 --> 10:50.870
这些都是系统功能

10:51.170 --> 10:52.670
但是这一部分的代码

10:52.670 --> 10:55.370
它也是去调用别的来完成系统功能的

10:55.370 --> 10:56.170
它怎么调用的

10:56.170 --> 10:57.870
一个是调用操作系统的API

10:58.070 --> 10:59.070
我这里用的黑色

10:59.070 --> 11:00.270
因为我也不确定这个操作系统

11:00.270 --> 11:01.370
它就用什么代码写的

11:01.670 --> 11:02.870
操作系统有很多对吧

11:03.070 --> 11:03.970
它是跨平台的

11:03.970 --> 11:06.170
因此这一部分是在实现跨平台

11:06.370 --> 11:07.670
它针对不同的操作系统

11:07.870 --> 11:10.870
使用不同的调用方式去调用操作系统的API

11:11.670 --> 11:12.870
去调用操作系统的API

11:13.470 --> 11:14.170
没了意思吧

11:15.270 --> 11:17.470
然后它还有一个调用

11:17.470 --> 11:18.870
调用的是Neville UV

11:19.070 --> 11:20.070
有一些朋友可能听说过

11:20.070 --> 11:21.470
Neville UV是什么东西的

11:21.870 --> 11:23.470
它是一个C和C家的库

11:24.470 --> 11:25.470
它用来干嘛的呢

11:25.470 --> 11:28.870
它用来就是主要就是用异部操作的

11:28.970 --> 11:30.670
我们接视不是基于异部的吗

11:30.770 --> 11:31.270
对吧

11:31.370 --> 11:35.470
而且它就通过这个库来实现了一个视线循环

11:35.470 --> 11:37.170
就是我们node接视的视线循环

11:37.170 --> 11:38.370
是通过它来实现的

11:39.470 --> 11:40.170
明白的意思吧

11:40.170 --> 11:41.370
是通过它来实现的

11:41.470 --> 11:44.070
它主要是来提供异部操作的

11:44.470 --> 11:46.470
在C和C家管理系统里面提供异部操作

11:46.470 --> 11:47.670
但是它在执行过程中

11:47.670 --> 11:49.170
它也会调用到操作系统结构

11:49.970 --> 11:52.170
所以说因为V8引擎一编一它

11:52.170 --> 11:53.170
它又要调用它

11:53.170 --> 11:53.670
它又要调用它

11:53.670 --> 11:55.970
这一挖起八道东西是不是一起就编一了

11:57.170 --> 11:58.970
就放到V8引擎里面了

11:58.970 --> 12:00.170
就编一成一个整体了

12:00.470 --> 12:02.970
所以我们代码其实之所以有那么多的能力

12:02.970 --> 12:05.970
是因为我们这个也可以把它看成一个整体

12:06.170 --> 12:08.170
就这一个圈可以把它看成一个整体

12:08.770 --> 12:10.170
因此我们代码去执行的

12:10.170 --> 12:11.770
可以调到很多系统的功能

12:12.970 --> 12:13.770
就这么个意思

12:14.170 --> 12:16.470
最终它都是V8引擎把它解释成为

12:17.170 --> 12:18.670
机器码交给引擎执行

12:19.070 --> 12:19.870
大概就这么回事了

12:20.370 --> 12:23.370
这是这个地方我给大家介绍一下

12:24.070 --> 12:25.470
然后最后说一个点

12:25.470 --> 12:27.670
就是整个的就是这个地方

12:27.670 --> 12:30.470
就是本地模块我们要把它首先编一一次

12:30.470 --> 12:32.470
对吧编一成一个世界和世界加弹码

12:32.470 --> 12:34.470
然后这个世界和世界加弹码

12:34.470 --> 12:35.870
有能力去调用这些东西

12:35.870 --> 12:37.470
这些东西也要一起

12:38.470 --> 12:39.870
把V8引擎进行扩展

12:39.870 --> 12:41.470
要编一一次

12:41.470 --> 12:43.470
那么这个过程是通过一个工具

12:43.470 --> 12:44.270
叫load

12:45.670 --> 12:46.470
编一过程

12:47.470 --> 12:56.470
V8引擎的扩展和对扩展的编译

12:57.270 --> 12:58.870
是通过一个工具

13:00.070 --> 13:00.670
叫什么工具呢

13:01.270 --> 13:02.870
叫做gyp工具

13:04.270 --> 13:06.070
通过这个工具来完成的

13:07.070 --> 13:09.870
那么这个工具其实load里边也有个版本

13:09.870 --> 13:10.870
叫loadgyp

13:10.870 --> 13:12.470
它其实实际上是一个什么呢

13:12.470 --> 13:13.870
它实际上是一个构建工具

13:13.870 --> 13:15.470
它主要是针对一些

13:15.470 --> 13:16.470
就是后轮代码的

13:16.470 --> 13:18.470
比方说像世界和世界加弹码

13:18.470 --> 13:20.470
可以用它这个工具来进行构建

13:20.470 --> 13:22.470
你看不仅前转有构建工具

13:22.470 --> 13:23.870
V8还有别的构建工具

13:23.870 --> 13:24.270
对吧

13:24.270 --> 13:26.270
别的语言也有别的构建工具

13:26.270 --> 13:28.070
它通过这个工具来进行扩展的

13:28.670 --> 13:29.870
所以说有的时候有些同学

13:29.870 --> 13:31.070
安装一些第三方库的时候

13:31.070 --> 13:31.870
他给你包错

13:31.870 --> 13:34.270
说gyp error

13:34.270 --> 13:34.670
对吧

13:34.670 --> 13:36.870
那么就说明你安装了第三方库了

13:36.870 --> 13:39.070
他要通过一个构建工具来进行构建

13:39.470 --> 13:40.870
而你没有这个构建工具

13:40.870 --> 13:41.670
所以说他包错了

13:41.670 --> 13:43.070
你可以去安装一下

13:43.070 --> 13:44.070
安装一下load

13:44.470 --> 13:45.070
钢

13:46.270 --> 13:47.470
你可以去安装

13:47.470 --> 13:48.470
就是某些

13:48.470 --> 13:49.270
写的是吧

13:49.270 --> 13:51.070
某些第三方库

13:52.070 --> 13:56.670
需要使用load接load

13:56.670 --> 13:57.670
就顺便说一下

13:57.670 --> 14:00.470
这个东西工具进行构建

14:01.670 --> 14:07.070
因此需要先安装loadgyp

14:07.070 --> 14:07.670
怎么安装

14:07.670 --> 14:09.470
你去查Npn去查一下

14:09.470 --> 14:10.270
就是一个Npn

14:10.270 --> 14:12.470
还全具安装就完事了

14:12.470 --> 14:13.270
就是这个东西

14:14.470 --> 14:16.270
那么其他的就没啥了

14:16.270 --> 14:17.070
其他就没啥了

14:17.070 --> 14:19.070
整个就是load接里边的组成部分

14:19.070 --> 14:20.670
应该是讲清楚了

14:20.670 --> 14:22.070
当然你要去分其他元码

14:22.070 --> 14:22.670
没法分析

14:22.670 --> 14:24.070
因为这是世界和世界家的东西

14:25.470 --> 14:26.470
实际上这个V8引擎

14:26.470 --> 14:27.470
他还提供了功能

14:27.470 --> 14:29.670
就是你可以进一步对他扩展

14:29.670 --> 14:31.270
你只要写个世界和世界家代码

14:31.870 --> 14:33.270
你可以可以进一步进一步扩展

14:34.270 --> 14:34.870
明白了意思吗

14:35.670 --> 14:38.270
那么这是这一部分的原理

14:38.270 --> 14:38.870
就讲到这

14:38.870 --> 14:39.870
把这个步送进来

