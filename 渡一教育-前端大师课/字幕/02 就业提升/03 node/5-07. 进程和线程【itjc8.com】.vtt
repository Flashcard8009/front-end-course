WEBVTT

00:00.430 --> 00:03.430
好 把这个进程和线程讲了

00:10.320 --> 00:14.320
这一块呢 你们平时以后开发的时候啊 不会怎么去用

00:15.320 --> 00:18.320
就算要用 非常非常要谨慎

00:18.320 --> 00:23.320
你们学戒丝学的那么久了 一直告诉你们戒丝是一个单线程的预言 对吧

00:23.320 --> 00:25.320
它是通过一步的处理方式

00:25.320 --> 00:28.320
这已经把难度降到很低了

00:28.320 --> 00:31.320
如果说去接触那个线程的话

00:32.320 --> 00:35.320
你要对它控制得非常好才行

00:35.320 --> 00:37.320
不然的话就是灾难性的后果

00:37.320 --> 00:39.320
不要轻易去用

00:39.320 --> 00:43.320
来说一下这个概念 对你们以后可能会有帮助

00:43.320 --> 00:47.320
之前我给大家推荐了一本书叫做现代操作系统 对不对

00:47.320 --> 00:50.320
工作几年过后一定要去把它看了

00:50.320 --> 00:53.320
看了过后就进程和线程更加深刻了

00:53.320 --> 00:55.320
因为这是操作系统里边的概念

00:55.320 --> 00:58.320
操作系统是一个很深很深的领域

00:59.320 --> 01:02.320
这边我只该简单介绍一下就行了

01:02.320 --> 01:05.320
一个是进程 进程怎么来的呢

01:05.320 --> 01:08.320
你看我是Mac 对吧 还有Windows

01:08.320 --> 01:10.320
他们都有进程的概念

01:10.320 --> 01:12.320
进程它是通过操作系统产生的

01:12.320 --> 01:15.320
当操作系统去启动一个应用程序的时候

01:15.320 --> 01:17.320
它会给它分配一个进程

01:17.320 --> 01:19.320
那么应用程序有什么呢 比如说浏览器

01:19.320 --> 01:22.320
操作系统启动浏览器它会给它分配一个进程

01:22.320 --> 01:24.320
然后呢 操作系统启动漏的

01:24.320 --> 01:27.320
我们运行漏的命令 也就是运行一个应用程序

01:27.320 --> 01:30.320
那操作系统也会给它启动一个进程

01:30.320 --> 01:32.320
运行QQ 启动一个进程

01:32.320 --> 01:35.320
运行一个游戏 它会给它启动一个进程

01:35.320 --> 01:38.320
所有的应用程序它都是通过操作系统启动的

01:38.320 --> 01:42.320
而操作系统启动它的时候一定会给它分配一个进程

01:42.320 --> 01:46.320
一个进程它到底有什么意义呢

01:46.320 --> 01:49.320
一个进程实际上就代表着一块独立的内存空间

01:49.320 --> 01:51.320
它独立 而且可以伸缩

01:51.320 --> 01:52.320
什么叫可以伸缩呢

01:52.320 --> 01:54.320
就是说当它内存空间不够用的时候

01:54.320 --> 01:56.320
它就会问操作系统能不能再给我一点

01:56.320 --> 01:57.320
我确实不够用了

01:57.320 --> 01:59.320
操作系统根据当时的情况

01:59.320 --> 02:02.320
愿意给就给 不愿意不愿意给它就不给

02:02.320 --> 02:06.320
就这么个情况 就是它是可以伸缩的

02:06.320 --> 02:09.320
原则上一个进程产生了之后

02:09.320 --> 02:12.320
它不会受到其他进程的干扰

02:12.320 --> 02:15.320
这是进程出现的最重要的目的

02:15.320 --> 02:17.320
在最早的时候是没有进程的

02:17.320 --> 02:20.320
所有的应用程序在操作系统上

02:20.320 --> 02:23.320
都是共享整个内存空间

02:24.320 --> 02:27.320
然后只要有一个应用程序它崩溃了

02:27.320 --> 02:30.320
就可能会导致其他应用程序接到一连串的崩溃

02:30.320 --> 02:33.320
整个操作系统没法用了 只能重启

02:33.320 --> 02:35.320
但是后来为了解决这个问题

02:35.320 --> 02:37.320
引入了进程的概念

02:37.320 --> 02:39.320
概念引用之后 每一个程序

02:39.320 --> 02:40.320
我就给了一个房间

02:40.320 --> 02:42.320
你在这个房间里面自己玩 玩自己的

02:42.320 --> 02:44.320
你就把这个房间炸了

02:44.320 --> 02:46.320
也不会影响到隔壁的房间

02:46.320 --> 02:49.320
就是你在内存空间里面你随便玩

02:49.320 --> 02:51.320
你不能影响到别的应用程序

02:51.320 --> 02:53.320
所以现在操作系统 为什么非常的稳定

02:53.320 --> 02:55.320
一个应用程序崩溃了

02:55.320 --> 02:57.320
不会导致整个系统崩溃

02:57.320 --> 02:59.320
但是还是有这种情况

02:59.320 --> 03:01.320
还有一些特殊的情况

03:01.320 --> 03:02.320
一些特殊的情况

03:02.320 --> 03:04.320
我们不再考虑范围之列

03:04.320 --> 03:07.320
比方说修改了一些系统的核心数据

03:07.320 --> 03:09.320
这些数据是所有进程都要共享的

03:09.320 --> 03:12.320
或者是进程之间通信导致的一些问题

03:12.320 --> 03:14.320
但是绝大部分情况下

03:14.320 --> 03:15.320
一个进程出的问题

03:15.320 --> 03:17.320
它不会影响整个程序的

03:17.320 --> 03:18.320
整个操作系统的崩溃

03:18.320 --> 03:21.320
就是进程 它是隔离内存空间的

03:21.320 --> 03:24.320
进程之间其实是可以通信的

03:24.320 --> 03:25.320
不是说完全不能通信

03:25.320 --> 03:28.320
通信的方式叫随所一等的协议

03:28.320 --> 03:29.320
比方说IPC

03:29.320 --> 03:31.320
IPC就是一个进程之间通信的协议

03:31.320 --> 03:33.320
当然我不具体的讲

03:33.320 --> 03:35.320
其实我们还有别的协议

03:35.320 --> 03:36.320
比方说什么呢?

03:36.320 --> 03:37.320
ADDP

03:37.320 --> 03:38.320
没想到吧

03:38.320 --> 03:41.320
ADDP它也是可以在进程之间通信的

03:41.320 --> 03:42.320
你想象这个道理

03:42.320 --> 03:44.320
一个服务系实际上是一个啥

03:44.320 --> 03:47.320
一个服务系实际上就是一个应用程序

03:47.320 --> 03:49.320
不就是一个漏的应用程序吗

03:49.320 --> 03:50.320
对吧

03:50.320 --> 03:51.320
一个浏览器是啥

03:51.320 --> 03:52.320
也就是一个应用程序

03:52.320 --> 03:53.320
两个进程

03:53.320 --> 03:55.320
浏览器是不是可以访问我们

03:55.320 --> 03:56.320
漏的服务系的东西

03:56.320 --> 03:57.320
漏的服务系给它想一个数据

03:57.320 --> 03:58.320
对吧

03:58.320 --> 04:00.320
它也是一个进程间通信

04:00.320 --> 04:01.320
说什么本质的话

04:01.320 --> 04:03.320
我们的ADDP协议

04:03.320 --> 04:05.320
也是进程间通信的一个协议

04:05.320 --> 04:08.320
但是那个东西要通过网卡

04:08.320 --> 04:09.320
它会通过网卡

04:09.320 --> 04:11.320
可能传输的效率没有那么高

04:11.320 --> 04:12.320
如果说本级的应用程序之间

04:12.320 --> 04:13.320
进程之间

04:13.320 --> 04:16.320
你可以使用IPC协议进行通信

04:16.320 --> 04:18.320
那么我们计算机上有这么多应用程序

04:18.320 --> 04:19.320
都在启动

04:19.320 --> 04:21.320
他们各自要做各自的事情

04:21.320 --> 04:22.320
忙的要事

04:22.320 --> 04:24.320
那么我们的CPU只有一个

04:24.320 --> 04:25.320
那怎么办呢

04:25.320 --> 04:27.320
虽然说我们现在有什么

04:27.320 --> 04:28.320
4核8核

04:28.320 --> 04:30.320
10核12核

04:30.320 --> 04:31.320
无所谓

04:31.320 --> 04:33.320
但是你CPU的数量总是有限的

04:33.320 --> 04:34.320
对不对

04:34.320 --> 04:35.320
总是有限的

04:35.320 --> 04:37.320
那我有几百个应用程序

04:37.320 --> 04:38.320
你看我的电脑上

04:38.320 --> 04:40.320
一般来说一个开机

04:40.320 --> 04:42.320
基本上就运行了几十个应用程序了

04:42.320 --> 04:44.320
那么这几十个应用程序之间

04:44.320 --> 04:46.320
它都是CPU在运行

04:46.320 --> 04:48.320
CPU忙不过来

04:48.320 --> 04:50.320
所以说CPU需要在进程之间

04:50.320 --> 04:52.320
不断地进行切换

04:52.320 --> 04:54.320
这个切换是比较耗费效率的

04:54.320 --> 04:55.320
但是没有办法

04:55.320 --> 04:57.320
CPU数量少

04:57.320 --> 04:58.320
你不可能说一个进程

04:58.320 --> 04:59.320
给它分配一个CPU

04:59.320 --> 05:01.320
这也太浪费了

05:01.320 --> 05:03.320
一个应用程序执行一段

05:03.320 --> 05:04.320
执行一会

05:04.320 --> 05:05.320
执行一会

05:05.320 --> 05:06.320
这超多系统决定的

05:06.320 --> 05:08.320
超多系统在控制CPU的执行

05:08.320 --> 05:09.320
CPU执行一个应用程序

05:09.320 --> 05:10.320
执行一会比较QQ

05:10.320 --> 05:11.320
执行一会

05:11.320 --> 05:12.320
执行一会过后

05:12.320 --> 05:14.320
比方说执行的100毫秒

05:14.320 --> 05:15.320
肯定没有那么长时间

05:15.320 --> 05:16.320
一般就是

05:16.320 --> 05:17.320
时代毫秒

05:17.320 --> 05:18.320
20毫秒

05:18.320 --> 05:19.320
或者是几毫秒

05:19.320 --> 05:21.320
或者是1毫秒

05:21.320 --> 05:23.320
这个根据超多系统而定

05:23.320 --> 05:25.320
它在这个进程里边执行一段时间

05:25.320 --> 05:26.320
执行一段时间过后

05:26.320 --> 05:28.320
它就把这个进程的数据

05:28.320 --> 05:29.320
当时执行到哪儿了

05:29.320 --> 05:31.320
给它这个现场给它保留下来

05:31.320 --> 05:33.320
保留到一块内存空间里边去

05:33.320 --> 05:34.320
这是超多系统决定的

05:34.320 --> 05:35.320
然后马上切到下一个

05:35.320 --> 05:36.320
下一个又来

05:36.320 --> 05:37.320
又跑到下一个去

05:37.320 --> 05:38.320
有什么事

05:38.320 --> 05:39.320
我要做什么

05:39.320 --> 05:40.320
我来帮你执行

05:40.320 --> 05:41.320
执行一段时间

05:41.320 --> 05:42.320
然后切到下一个

05:42.320 --> 05:44.320
它就是这样子不断的切换执行的

05:44.320 --> 05:47.320
超多系统雕图进程之间的执行

05:47.320 --> 05:49.320
你想这个切换肯定是耗费时间的

05:49.320 --> 05:51.320
所以说要从效率上来说

05:51.320 --> 05:52.320
进程一定是越少越好

05:52.320 --> 05:54.320
但是没办法这个事情

05:54.320 --> 05:55.320
是没办法

05:55.320 --> 05:57.320
然后接下来我们再看

05:57.320 --> 05:58.320
一个应用程序

05:58.320 --> 05:59.320
在启动的时候

05:59.320 --> 06:00.320
只有一个进程

06:00.320 --> 06:01.320
我们刚才说了

06:01.320 --> 06:02.320
但是这个应用程序

06:02.320 --> 06:04.320
在运行的过程中

06:04.320 --> 06:05.320
因为每个应用程序

06:05.320 --> 06:06.320
是用代码写出来了

06:06.320 --> 06:07.320
它在代码的运行过程中

06:07.320 --> 06:10.320
它可能会产生新的进程

06:10.320 --> 06:12.320
之后进程与进程之间

06:12.320 --> 06:13.320
仍然保持相对独立

06:13.320 --> 06:14.320
但是我们这里的

06:14.320 --> 06:15.320
都有一个新的教法

06:15.320 --> 06:17.320
就是如果一个进程

06:17.320 --> 06:19.320
它直接有超多系统开启的

06:19.320 --> 06:21.320
比方说你双击一个QQ打开了

06:21.320 --> 06:23.320
那么就超多系统给你开启的

06:23.320 --> 06:24.320
那么它开启的进程

06:24.320 --> 06:26.320
叫做主进程

06:26.320 --> 06:28.320
然后在QQ的运行过程中

06:28.320 --> 06:30.320
它可能会产生新的进程

06:30.320 --> 06:32.320
比方说一个进程B

06:32.320 --> 06:34.320
是由进程A开启的

06:34.320 --> 06:35.320
那么A就是B的复进程

06:35.320 --> 06:36.320
B就是A的执行程

06:36.320 --> 06:38.320
比方说什么时候呢

06:38.320 --> 06:45.320
你在瀏覽器上网的过程中

06:45.320 --> 06:48.320
瀏覽器它会给你开多个进程的

06:48.320 --> 06:49.320
然后你访问百度

06:49.320 --> 06:51.320
它给你新开了一个进程

06:51.320 --> 06:53.320
然后再去渲染百度

06:53.320 --> 06:56.320
然后你又开启了一个新的标签页

06:56.320 --> 06:57.320
又访问百度

06:57.320 --> 06:58.320
你发现它同一个站点

06:58.320 --> 07:00.320
它就没有给你开新的进程

07:00.320 --> 07:01.320
不要累是吧

07:01.320 --> 07:02.320
这是谷歌瀏覽器的做法

07:02.320 --> 07:04.320
别的瀏覽器又可能不一样

07:04.320 --> 07:05.320
再比方说

07:05.320 --> 07:07.320
它又开了一个新的标签页

07:07.320 --> 07:08.320
但是你访问了谷歌

07:08.320 --> 07:09.320
那么这个时候

07:09.320 --> 07:11.320
它又给你开了一个新的进程

07:11.320 --> 07:12.320
因为域名不一样了

07:12.320 --> 07:13.320
就这么一回事

07:13.320 --> 07:15.320
这是谷歌标签的做法

07:15.320 --> 07:18.820
比方说你流量QQ

07:18.820 --> 07:19.820
别人给你发了一个文件过来

07:19.820 --> 07:21.820
你双击打开

07:21.820 --> 07:22.820
打开这个文件

07:22.820 --> 07:23.820
是不是比方说

07:23.820 --> 07:24.820
一个卧尔文大码的双击

07:24.820 --> 07:25.820
是不是启动了卧尔的进程

07:25.820 --> 07:26.820
对吧

07:26.820 --> 07:27.820
这个卧尔的进程是谁给你开启的

07:27.820 --> 07:29.820
是QQ一直个应用程序给你开启的

07:29.820 --> 07:30.820
所以说

07:30.820 --> 07:34.820
那个卧尔的进程是QQ进程的指进程

07:34.820 --> 07:37.820
虽然说有一个复指进程的这么一个教法

07:37.820 --> 07:38.820
但是呢

07:38.820 --> 07:40.820
实际上他们之间还是没有多少关系

07:40.820 --> 07:41.820
无非就是指进程

07:41.820 --> 07:45.820
他可能会继承复进程的一些信息

07:45.820 --> 07:46.820
但是呢

07:46.820 --> 07:48.820
他仍然保持相对独立

07:48.820 --> 07:50.820
你看你在QQ里边开启

07:50.820 --> 07:51.820
打双击

07:51.820 --> 07:52.820
别人发过来的文件

07:52.820 --> 07:53.820
打开了一个卧尔的

07:53.820 --> 07:55.820
卧尔的本来是QQ的指进程

07:55.820 --> 07:56.820
他们之间有啥关系呢

07:56.820 --> 07:57.820
没啥关系对不对

07:57.820 --> 07:59.820
仍然保持相对独立

07:59.820 --> 08:02.820
进程之间是非常非常独立的

08:02.820 --> 08:03.820
那么我们接下来看一下

08:03.820 --> 08:06.820
进程文介绍一下就行了

08:06.820 --> 08:08.820
所以我们终点是现成

08:08.820 --> 08:09.820
进程呢

08:09.820 --> 08:10.820
我们看一下吧

08:10.820 --> 08:12.820
如果说在note介绍里边

08:12.820 --> 08:13.820
你要开启一个进程的话

08:13.820 --> 08:15.820
就可以使用这样的代码

08:15.820 --> 08:16.820
把复指过来吧

08:16.820 --> 08:17.820
给他演示一下

08:17.820 --> 08:22.290
保留一个内置模块

08:22.290 --> 08:23.290
叫child process

08:23.290 --> 08:25.290
他这个模块呢

08:25.290 --> 08:26.290
我们上一课学了

08:26.290 --> 08:28.290
他会调用底层操作系统的模块

08:28.290 --> 08:29.290
开启进程

08:29.290 --> 08:31.290
我会命令操作系统去开启进程

08:31.290 --> 08:32.290
然后呢

08:32.290 --> 08:33.290
这个模块里面呢

08:33.290 --> 08:34.290
它有个函数

08:34.290 --> 08:35.290
它其实里面的东西还是蛮多的

08:35.290 --> 08:37.290
我们就简单介绍一下就行了

08:37.290 --> 08:38.290
以后我会说

08:38.290 --> 08:39.290
简单介绍

08:39.290 --> 08:41.290
这里边一个excuse

08:41.290 --> 08:42.290
表示的是执行

08:42.290 --> 08:43.290
执行什么

08:43.290 --> 08:44.290
执行一个命令

08:44.290 --> 08:45.290
当你

08:45.290 --> 08:48.290
就相当于是在控制台执行一个命令

08:48.290 --> 08:50.290
实际上你们的控制台功能很强大的

08:50.290 --> 08:51.290
不是

08:51.290 --> 08:54.290
因为我们平时用习惯的鼠标键盘操作

08:54.290 --> 08:55.290
鼠标操作

08:55.290 --> 08:57.290
用惯了这个UI界面

08:57.290 --> 08:58.290
实际上的UI界面

08:58.290 --> 09:00.290
是为了提高用户体验而做的

09:00.290 --> 09:01.290
它的控制台里面

09:01.290 --> 09:02.290
你只要用命令

09:02.290 --> 09:04.290
可以搞定所有的事情

09:04.290 --> 09:06.290
那么你可以执行在一个

09:06.290 --> 09:07.290
控制台里面执行一个命令

09:07.290 --> 09:09.290
那么这个命令

09:09.290 --> 09:11.290
你就可以完全是开启一个新进程

09:11.290 --> 09:13.290
实际上这个东西就是这个控制台本身

09:13.290 --> 09:15.290
那个系统本身就是一个

09:15.290 --> 09:17.290
就是进程

09:17.290 --> 09:19.290
然后它执行的结果

09:19.290 --> 09:21.290
就是这个程序的执行结果

09:21.290 --> 09:22.290
会反复到这样

09:22.290 --> 09:23.290
这是个回调函数

09:23.290 --> 09:25.290
但是回调函数肯定是一步的

09:25.290 --> 09:26.290
百分之百是一步的

09:26.290 --> 09:27.290
那么这个回调函数

09:27.290 --> 09:29.290
它会告诉你是哪些信息的

09:29.290 --> 09:30.290
它会告诉你

09:30.290 --> 09:32.290
开启进程过程中有没有发生错误

09:32.290 --> 09:34.290
有错误它就是一个错误对象

09:34.290 --> 09:35.290
如果说没有错误

09:35.290 --> 09:37.290
那么进程还有没有输出结果

09:37.290 --> 09:38.290
有输出结果它就是

09:38.290 --> 09:40.290
它把输出结果放到这儿

09:40.290 --> 09:42.290
那么进程有没有输出错误的内容呢

09:42.290 --> 09:43.290
如果说输出了结果

09:43.290 --> 09:44.290
它就运行没问题

09:44.290 --> 09:46.290
但是它输出了错误的内容

09:46.290 --> 09:47.290
它就放到这儿

09:47.290 --> 09:48.290
有没有意思

09:48.290 --> 09:49.290
但是你要注意

09:49.290 --> 09:50.290
这个东西设立到什么呢

09:50.290 --> 09:52.290
设立到进程间的通信了

09:52.290 --> 09:54.290
因为这个进程

09:54.290 --> 09:56.290
它发了一些消息

09:56.290 --> 09:58.290
到了我这个进程

09:58.290 --> 10:00.290
只进程发了消息到主进程

10:00.290 --> 10:01.290
对不对

10:01.290 --> 10:03.290
那么进程通信的你不用管

10:03.290 --> 10:05.290
它为什么可以把信息传过来了

10:05.290 --> 10:07.290
因为进程不是独立的吗

10:07.290 --> 10:08.290
它是通过IPC

10:08.290 --> 10:10.290
通信来完成的

10:10.290 --> 10:12.290
漏的接纸已经帮你处理了

10:12.290 --> 10:13.290
你不用管

10:13.290 --> 10:14.290
它总之最终会运行这个毁掉

10:14.290 --> 10:15.290
当然这个毁掉

10:15.290 --> 10:16.290
也是放到我们的

10:16.290 --> 10:18.290
漏道的事件循环里边去的

10:18.290 --> 10:19.290
而且你要注意

10:19.290 --> 10:21.290
只进程发生任何错误

10:21.290 --> 10:23.290
绝不会影响到复进程

10:23.290 --> 10:25.290
它们的内存容量是完全隔离的

10:25.290 --> 10:26.290
完全都没关系

10:26.290 --> 10:27.290
只进程就算崩溃了

10:27.290 --> 10:29.290
跟主进程一点关系都没有

10:29.290 --> 10:30.290
不是说主进程报出来

10:30.290 --> 10:31.290
我这就要报出

10:31.290 --> 10:33.290
什么关系都没有

10:33.290 --> 10:34.290
那么我们来试一下吧

10:34.290 --> 10:35.290
比方说我来这里

10:35.290 --> 10:37.290
可以开启一个谷歌流暗器

10:37.290 --> 10:39.290
如果你是Windows系统的话

10:39.290 --> 10:41.290
那那个Windows系统很简单

10:41.290 --> 10:42.290
Windows系统的话

10:42.290 --> 10:43.290
那个谷歌流暗器的命令就是

10:43.290 --> 10:44.290
没了

10:44.290 --> 10:45.290
没了

10:46.290 --> 10:47.290
我这个是麦克系统

10:47.290 --> 10:49.290
麦克系统的话

10:50.290 --> 10:51.290
我看一下吧

10:51.290 --> 10:52.290
麦克系统的话

10:52.290 --> 10:53.290
好像要用这种发射

10:53.290 --> 10:54.290
要Open

10:55.290 --> 10:56.290
然后呢

10:56.290 --> 10:58.290
我的谷歌在哪呢

10:58.290 --> 10:59.290
IPC

10:59.290 --> 11:00.290
谷歌

11:07.060 --> 11:08.060
试一下吧

11:08.060 --> 11:09.060
我先试一下

11:09.060 --> 11:12.140
不存在

11:12.140 --> 11:14.140
应该是IPC还是

11:16.140 --> 11:17.140
打开了

11:17.140 --> 11:19.140
打开谷歌流暗器了

11:19.140 --> 11:20.140
是不是就是一个命令

11:20.140 --> 11:22.140
那我把这个命令

11:22.140 --> 11:24.140
复制

11:24.140 --> 11:26.140
当Windows流暗器直接

11:26.140 --> 11:27.140
起个Crown就完成了

11:28.140 --> 11:29.140
保存

11:30.140 --> 11:31.140
保存过后

11:31.140 --> 11:32.140
我们来看一下

11:32.140 --> 11:34.140
现在我们就运行

11:34.140 --> 11:36.140
load index

11:37.140 --> 11:38.140
你看

11:38.140 --> 11:39.140
是不是打开谷歌了

11:39.140 --> 11:40.140
这个load

11:40.140 --> 11:41.140
运行load程序的时候

11:41.140 --> 11:42.140
它打开了一个新的进程

11:42.140 --> 11:43.140
对吧

11:43.140 --> 11:44.140
这是这个东西

11:44.140 --> 11:45.140
当然你还可以别的命令

11:45.140 --> 11:46.140
比方说

11:46.140 --> 11:47.140
Windows是DIR

11:47.140 --> 11:48.140
对吧

11:48.140 --> 11:49.140
查看当前目录

11:49.140 --> 11:52.140
那个麦克是LS

11:52.140 --> 11:53.140
我们来

11:53.140 --> 11:54.140
我们在这里输出一下吧

11:54.140 --> 11:55.140
输出个Out

11:57.700 --> 11:58.700
你看

11:58.700 --> 11:59.700
如果说我来这里运行LS

11:59.700 --> 12:00.700
那么就是得到这个东西

12:00.700 --> 12:01.700
对吧

12:01.700 --> 12:02.700
得到这个东西

12:02.700 --> 12:04.700
然后我们现在运行load

12:04.700 --> 12:05.700
用这个

12:05.700 --> 12:06.700
你看

12:06.700 --> 12:07.700
得到这个东西了

12:07.700 --> 12:08.700
得到这个东西了

12:08.700 --> 12:09.700
这个东西是哪来的

12:09.700 --> 12:10.700
就是个Out

12:10.700 --> 12:11.700
这个Out哪来的

12:11.700 --> 12:12.700
是我们运行的

12:12.700 --> 12:13.700
这个东西

12:13.700 --> 12:14.700
这个进程

12:14.700 --> 12:15.700
这个进程

12:15.700 --> 12:16.700
给它的输出结果

12:16.700 --> 12:17.700
它传遏了我的主进程

12:17.700 --> 12:19.700
它们之间是通过IPC通信的

12:19.700 --> 12:20.700
传过来

12:20.700 --> 12:21.700
没了意思

12:21.700 --> 12:23.700
这是关于启动进程

12:23.700 --> 12:24.700
为什么说这个进程

12:24.700 --> 12:25.700
这一块

12:25.700 --> 12:26.700
我就简单介绍了

12:26.700 --> 12:27.700
因为现在基本上不打用了

12:27.700 --> 12:28.700
你平时没啥

12:28.700 --> 12:29.700
没啥说

12:29.700 --> 12:30.700
启动一个进程干嘛

12:30.700 --> 12:31.700
这种情况比较少

12:32.700 --> 12:33.700
因为过去

12:33.700 --> 12:34.700
load index

12:34.700 --> 12:35.700
是没有给我提供

12:35.700 --> 12:37.700
现成的这个处理的

12:37.700 --> 12:38.700
所以说以前没有办法

12:38.700 --> 12:40.700
如果说我要去处理一些

12:40.700 --> 12:41.700
任务的时候

12:41.700 --> 12:42.700
我只能开进程

12:42.700 --> 12:43.700
没有办法

12:43.700 --> 12:45.700
当时loads.js

12:45.700 --> 12:46.700
它没有现成的东西

12:46.700 --> 12:47.700
没有现成给你提供

12:47.700 --> 12:48.700
它有现成

12:48.700 --> 12:49.700
它内部肯定是有现成的

12:49.700 --> 12:50.700
但是它没有给你提供开发者

12:50.700 --> 12:52.700
可以编辑的接口

12:53.700 --> 12:55.700
而且以前loads.js

12:55.700 --> 12:57.700
还提供了这个cluster

12:57.700 --> 12:58.700
这个模块

12:58.700 --> 12:59.700
这个模块是另一种模式

12:59.700 --> 13:00.700
来创建进程

13:00.700 --> 13:02.700
它是一个简化版本

13:02.700 --> 13:04.700
有兴趣的同学可以白头去了解一下

13:04.700 --> 13:05.700
因为这两个东西

13:05.700 --> 13:06.700
我们基本上没占用了

13:06.700 --> 13:07.700
为啥呢

13:07.700 --> 13:08.700
因为从loads.js

13:08.700 --> 13:10.700
使这个版本开始过后

13:10.700 --> 13:12.700
它就已经提供了现成模块了

13:12.700 --> 13:13.700
那么我们可以创建一个

13:13.700 --> 13:15.700
真实的现成

13:15.700 --> 13:18.700
因此对进程的操作就很少了

13:18.700 --> 13:20.700
因为我们为什么要创建

13:20.700 --> 13:21.700
现成为什么要创建进程

13:21.700 --> 13:22.700
是因为我们有

13:22.700 --> 13:23.700
很多任务

13:23.700 --> 13:24.700
希望它同时进行

13:24.700 --> 13:25.700
真正的同时进行

13:25.700 --> 13:26.700
而不是说

13:26.700 --> 13:27.700
一步的的方式

13:27.700 --> 13:28.700
感觉上的同时进行

13:28.700 --> 13:29.700
实际上是不是的

13:29.700 --> 13:30.700
实际上是用毁掉

13:30.700 --> 13:31.700
任务方式在处理的

13:31.700 --> 13:33.700
真正的同时进行

13:33.700 --> 13:34.700
那么我们可能要开

13:34.700 --> 13:35.700
现成和进程

13:35.700 --> 13:36.700
以前没有现成

13:36.700 --> 13:37.700
没办法真正开进程

13:37.700 --> 13:38.700
好,这是这个

13:38.700 --> 13:39.700
现成

13:39.700 --> 13:40.700
介绍一下

13:40.700 --> 13:41.700
现成一定要记住

13:41.700 --> 13:42.700
它的内存分裂是相对独立的

13:42.700 --> 13:44.700
是你完全两个应用了

13:44.700 --> 13:46.700
然后我们来开现成

13:46.700 --> 13:48.700
实际上的真实的情况是这样子

13:48.700 --> 13:50.700
操作系统启动了一个进程

13:50.700 --> 13:51.700
就启动了一个应用程序

13:51.700 --> 13:52.700
无论是主进程还是止进程

13:52.700 --> 13:53.700
总之一个进程

13:53.700 --> 13:54.700
就是一个应用程序

13:54.700 --> 13:55.700
开启一个应用程序

13:55.700 --> 13:56.700
开启一个进程

13:56.700 --> 13:58.700
然后不仅会开启一个进程

13:58.700 --> 14:00.700
而且会自动的

14:00.700 --> 14:02.700
它分配一个现成

14:02.700 --> 14:04.700
一个应用程序启动

14:04.700 --> 14:05.700
至少得有一个进程

14:05.700 --> 14:07.700
至少得有一个现成

14:07.700 --> 14:08.700
如果说这个现成结束了

14:08.700 --> 14:10.700
整个应用程序就结束了

14:10.700 --> 14:11.700
我们把这个现成

14:11.700 --> 14:12.700
称之为主现成

14:12.700 --> 14:14.700
这是操作系统给它的

14:14.700 --> 14:15.700
然后呢

14:15.700 --> 14:17.700
程序一定是在

14:17.700 --> 14:18.700
现成上运行

14:18.700 --> 14:19.700
就是我们运行的那些代码

14:19.700 --> 14:20.700
全在现成上

14:20.700 --> 14:21.700
现成可以想象的

14:21.700 --> 14:22.700
有一个时间线

14:22.700 --> 14:26.700
从第二行开始一直运行

14:26.700 --> 14:28.700
然后我们的程序

14:28.700 --> 14:29.700
在运行的过程中

14:29.700 --> 14:31.700
它可以自己的创建多个现成

14:31.700 --> 14:32.700
那么这个现成

14:32.700 --> 14:33.700
称为指现成

14:33.700 --> 14:36.700
就是现成可以创建别的现成

14:36.700 --> 14:37.700
怎么创建呢

14:37.700 --> 14:38.700
也是像操作系统申请

14:38.700 --> 14:39.700
操作系统给了它一个

14:39.700 --> 14:41.700
它用的用的不够用了

14:41.700 --> 14:42.700
兄弟

14:42.700 --> 14:43.700
能不能再给我一些

14:43.700 --> 14:44.700
你申请吧

14:44.700 --> 14:45.700
每个语言它都有接口

14:45.700 --> 14:46.700
调整这个接口

14:46.700 --> 14:48.700
它底层就是调整操作系统的

14:48.700 --> 14:49.700
接口去申请操作系统

14:49.700 --> 14:50.700
给我一个新的建成

14:50.700 --> 14:52.700
操作系统就给它了

14:52.700 --> 14:54.700
就这么个意思

14:54.700 --> 14:56.700
当CPU去执行一个进程的时候

14:56.700 --> 14:57.700
因为我们刚才说了

14:57.700 --> 14:59.700
比方说QQ执行一毫秒

14:59.700 --> 15:00.700
执行一毫秒的时候

15:00.700 --> 15:02.700
它发现QQ里面有很多的现成

15:02.700 --> 15:04.700
那么它会在一毫秒内

15:04.700 --> 15:06.700
它会在现成之间又去切换

15:06.700 --> 15:08.700
切换执行

15:08.700 --> 15:10.700
实际上执行的是

15:10.700 --> 15:13.700
在这个进程的多个现成中进行切换

15:13.700 --> 15:16.700
你看时间分得很短很短

15:16.700 --> 15:18.700
当然现成也是一样

15:18.700 --> 15:20.700
切换执行的时候也要保留

15:20.700 --> 15:21.700
执行的状态

15:21.700 --> 15:23.700
比方说我从现成一切到现成二

15:23.700 --> 15:25.700
那么现成一的状态我要保留下来

15:25.700 --> 15:27.700
下一执行我都不知道执行在哪了

15:27.700 --> 15:29.700
就是为什么说切换现成有开销

15:29.700 --> 15:31.700
就是它要保留现场

15:31.700 --> 15:33.700
还要恢复现场

15:33.700 --> 15:34.700
它有这么一个开销

15:34.700 --> 15:35.700
实际上它的过程

15:35.700 --> 15:37.700
原计其实很简单

15:37.700 --> 15:39.700
就是保留执行站

15:39.700 --> 15:41.700
就是保留执行站

15:41.700 --> 15:44.700
那么现成和进程其实很相似的

15:44.700 --> 15:46.700
它们都是独立运行

15:46.700 --> 15:47.700
最大的区别在于

15:47.700 --> 15:49.700
在于现成的内存空间

15:49.700 --> 15:51.700
它没有隔离

15:51.700 --> 15:54.700
它们都是共享进程的内存空间

15:54.700 --> 15:56.700
QQ一个内存空间

15:56.700 --> 15:58.700
然后它里面有10个现成

15:58.700 --> 16:00.700
它们都是共享的内存空间

16:00.700 --> 16:01.700
没了意思吧

16:01.700 --> 16:02.700
而且现成之间

16:02.700 --> 16:04.700
因此它有于它们的空间是共享的

16:04.700 --> 16:05.700
所以它们的数据

16:05.700 --> 16:08.700
现成与现成之间传输的数据

16:08.700 --> 16:10.700
它不遵守任何协议

16:10.700 --> 16:11.700
可以随意使用

16:11.700 --> 16:12.700
有一个公共的数据

16:12.700 --> 16:13.700
一个对象 一个数组

16:13.700 --> 16:14.700
这个现成可以用

16:14.700 --> 16:16.700
另一个现成也可以用

16:16.700 --> 16:18.700
而且由于它们可能

16:18.700 --> 16:19.700
它们的执行

16:19.700 --> 16:21.700
它根本一不就没有什么关系了

16:21.700 --> 16:22.700
它们是相互切换执行的

16:22.700 --> 16:24.700
你也不知道切到这个现成的时候

16:24.700 --> 16:25.700
之前的一个共享数据

16:25.700 --> 16:26.700
变成什么样子

16:26.700 --> 16:27.700
你根本就不知道

16:27.700 --> 16:29.700
而且在现成执行的时候

16:29.700 --> 16:31.700
有可能在切换的时候

16:31.700 --> 16:33.700
就是函数会被打断

16:33.700 --> 16:34.700
啥意思呢

16:34.700 --> 16:36.700
就是说有一个函数

16:36.700 --> 16:37.700
比方说

16:38.700 --> 16:39.700
funk

16:39.700 --> 16:40.700
test

16:40.700 --> 16:45.960
net

16:45.960 --> 16:47.960
n等于1

16:47.960 --> 16:48.960
然后test就是

16:48.960 --> 16:49.960
比方说

16:49.960 --> 16:54.770
我举个例子

16:54.770 --> 16:55.770
n++

16:55.770 --> 17:01.130
刚才还是把它写到这儿吧

17:01.130 --> 17:02.130
这啥玩意

17:02.130 --> 17:05.340
n++

17:06.340 --> 17:07.340
然后输出

17:10.420 --> 17:11.420
加加之前

17:11.420 --> 17:12.420
我也输出n

17:15.050 --> 17:16.050
如果是GS的话

17:16.050 --> 17:17.050
单现成的话

17:17.050 --> 17:18.050
那么这个不会有任何问题

17:18.050 --> 17:19.050
这个地方

17:19.050 --> 17:20.050
它一定被它多一个

17:20.050 --> 17:22.050
这是不会有任何问题的

17:22.050 --> 17:24.050
因为GS是基于逸步的

17:24.050 --> 17:26.050
一个函数必须要玩玩这种执行玩

17:26.050 --> 17:27.050
执行完了过后

17:27.050 --> 17:28.050
执行站里面弹出去

17:28.050 --> 17:29.050
弹出去过后再看

17:29.050 --> 17:30.050
有执行站里面

17:30.050 --> 17:31.050
有没有内容

17:31.050 --> 17:32.050
然后再进行毁掉

17:32.050 --> 17:33.050
执行逸步的

17:33.050 --> 17:34.050
在我们逸步对待里面去找

17:34.050 --> 17:35.050
我们之前讲过了一个

17:35.050 --> 17:36.050
事件循环

17:37.050 --> 17:38.050
但是有的现成就不一样了

17:38.050 --> 17:39.050
比方说这个函数

17:39.050 --> 17:41.050
有两个现成都在执行它

17:42.050 --> 17:43.050
现成1

17:44.050 --> 17:45.050
和现成2

17:45.050 --> 17:47.050
两个现成都在执行它

17:47.050 --> 17:48.050
那么就要出问题了

17:48.050 --> 17:49.050
它们都在共享数据

17:49.050 --> 17:50.050
现成1它要用到这个数据

17:50.050 --> 17:51.050
共享的数据n

17:51.050 --> 17:53.050
现成2也要执行这个函数

17:53.050 --> 17:55.050
也要用到共享数据n

17:55.050 --> 17:57.050
那就不知道怎么回事了

17:57.050 --> 17:59.050
有可能现成1这里输出了

17:59.050 --> 18:00.050
输出了1

18:00.050 --> 18:01.050
然后呢

18:01.050 --> 18:02.050
现成1刚要运行

18:02.050 --> 18:03.050
n++

18:03.050 --> 18:04.050
突然切换到现成2了

18:04.050 --> 18:06.050
你也不知道什么时候切换

18:06.050 --> 18:07.050
这句话运行完了等了

18:07.050 --> 18:09.050
突然切换到现成2了

18:09.050 --> 18:12.050
好 现成2又是一个完整的执行

18:12.050 --> 18:14.050
跟那个现成1就没有什么关系了

18:14.050 --> 18:16.050
但是共享数据还是一样的

18:16.050 --> 18:17.050
但是现成2又执行

18:17.050 --> 18:19.050
它又输出了1

18:19.050 --> 18:21.050
然后现成2运行了n++

18:21.050 --> 18:23.050
然后突然又切换到现成1了

18:23.050 --> 18:25.050
现成1又运行n++

18:25.050 --> 18:26.050
刚才恢复现场吧

18:26.050 --> 18:27.050
对吧

18:27.050 --> 18:28.050
然后又输出了n

18:28.050 --> 18:30.050
导致了现成1就变成了输出了1

18:30.050 --> 18:32.050
输出了3

18:32.050 --> 18:33.050
就感觉很奇怪

18:33.050 --> 18:34.050
所以说现成

18:34.050 --> 18:36.050
一旦使用了共享数据

18:36.050 --> 18:38.050
你稍微控制不好

18:38.050 --> 18:39.050
要出大问题的

18:39.050 --> 18:40.050
你整个程序乱了

18:40.050 --> 18:42.050
因为它现成你也不知道

18:42.050 --> 18:43.050
根本就不知道现成在什么时候切换

18:43.050 --> 18:45.050
所以要接触很多很多的技术

18:45.050 --> 18:46.050
包括数

18:46.050 --> 18:47.050
还有各种各样的数

18:47.050 --> 18:49.050
数还都还不一样的

18:49.050 --> 18:50.050
这些东西呢

18:50.050 --> 18:52.050
我们不用过路去了解

18:52.050 --> 18:55.050
我们这里就点到几日

18:55.050 --> 18:58.050
这是那个

18:58.050 --> 18:59.050
关于现场上的运行

18:59.050 --> 19:01.050
现场的切换执行

19:02.050 --> 19:04.050
我们现场跟进城有什么区别

19:04.050 --> 19:05.050
区别最大的区别就是这么一个

19:05.050 --> 19:06.050
就是

19:06.050 --> 19:09.050
进城之间的数据

19:09.050 --> 19:11.050
是相互独立的

19:11.050 --> 19:13.050
他们之间几乎是不交流的

19:13.050 --> 19:14.050
你运行你的

19:14.050 --> 19:15.050
我运行我的

19:15.050 --> 19:19.050
而现场之间的数据是完全共享的

19:19.050 --> 19:21.050
基本上是共享的

19:21.050 --> 19:22.050
所以说

19:22.050 --> 19:25.050
现场它非常依赖于良好的程序设计

19:25.050 --> 19:27.050
就连后来的开发者

19:27.050 --> 19:28.050
一般来说

19:28.050 --> 19:29.050
他都不会去碰现场的

19:29.050 --> 19:30.050
一般都是

19:30.050 --> 19:31.050
空调给你封装好了

19:31.050 --> 19:33.050
给你已经把你写好了

19:33.050 --> 19:34.050
让你尽量不要去

19:34.050 --> 19:35.050
自己去碰现场

19:35.050 --> 19:36.050
一碰的话就要出问题

19:36.050 --> 19:38.050
你像以前最早的时候

19:38.050 --> 19:40.050
谁也要加了一个开发者

19:40.050 --> 19:41.050
他们自己要碰现场的

19:41.050 --> 19:43.050
那个是很恐怖的

19:43.050 --> 19:44.050
重序写一会儿写着写着

19:44.050 --> 19:45.050
这就出问题了

19:45.050 --> 19:48.050
很多时间都在想办法

19:48.050 --> 19:49.050
来控制这个现场

19:49.050 --> 19:51.050
很不好控制

19:51.050 --> 19:53.050
为了避免现场之间

19:53.050 --> 19:55.050
执行的过程存在

19:55.050 --> 19:56.050
共享数据的才能到麻烦

19:56.050 --> 19:57.050
就刚上面觉得例子

19:57.050 --> 19:59.050
共享数据会产生很多麻烦的

19:59.050 --> 20:01.050
instagram loader接使呢

20:01.050 --> 20:03.050
他使用了一种比较独特的机制

20:03.050 --> 20:04.050
他给你开

20:04.050 --> 20:05.050
那么使这个版本之后

20:05.050 --> 20:07.050
loader接使允许你使用现场了

20:07.050 --> 20:08.050
但是呢

20:08.050 --> 20:09.050
他就怕你出问题

20:09.050 --> 20:10.050
就怕你出问题

20:10.050 --> 20:11.050
所以说呢

20:11.050 --> 20:12.050
他给你提供了一种机制呢

20:12.050 --> 20:14.050
尽力的来避免出问题

20:14.050 --> 20:15.050
但是如果去乱用的话

20:15.050 --> 20:16.050
还是会出问题

20:16.050 --> 20:17.050
就是说

20:17.050 --> 20:18.050
不要轻易去用这个

20:18.050 --> 20:19.050
那么我给大家说一下

20:19.050 --> 20:21.050
什么时候要用现场

20:22.050 --> 20:25.050
什么时候要使用现场

20:25.050 --> 20:26.050
有的朋友觉得这个现场

20:26.050 --> 20:28.050
一看上去很舒服

20:28.050 --> 20:29.050
很多东西同时执行

20:29.050 --> 20:30.050
不是很舒服吗

20:30.050 --> 20:32.050
但是你要想到

20:32.050 --> 20:34.050
这个同时执行是假的呀

20:34.050 --> 20:36.050
它是切换的

20:36.050 --> 20:37.050
因为CPU的数量是有限的

20:37.050 --> 20:38.050
无非呢

20:38.050 --> 20:40.050
我们用现场的时候呢

20:40.050 --> 20:42.050
主要是目的呀

20:42.050 --> 20:44.050
要搞清楚使用现场的主要目的

20:44.050 --> 20:46.050
现场的主要目的

20:46.050 --> 20:51.050
是为了充分使用多核CPU

20:51.050 --> 20:52.050
因为我们现在CPU

20:52.050 --> 20:53.050
都是多个核的

20:53.050 --> 20:54.050
比方说

20:54.050 --> 20:56.050
有CPU有8核

20:56.050 --> 20:59.050
那么这个实在是真正意义上的

20:59.050 --> 21:01.050
同时执行

21:01.050 --> 21:04.050
不同的核之间是没有关联的

21:04.050 --> 21:06.050
8个东西同时在执行

21:06.050 --> 21:09.050
每个核里面有自己的基存器

21:09.050 --> 21:10.050
它们同时执行

21:10.050 --> 21:11.050
顾不干涉

21:11.050 --> 21:13.050
是要充分利用多核的

21:13.050 --> 21:14.050
那么理论上

21:14.050 --> 21:15.050
最优的情况是什么呢

21:15.050 --> 21:16.050
最优的情况就是

21:16.050 --> 21:18.050
一个核一个现场

21:18.050 --> 21:19.050
一个核一个现场

21:19.050 --> 21:20.050
你不要再开多了

21:20.050 --> 21:22.050
再开多它还是要切换了

21:22.050 --> 21:23.050
那切换的时候

21:23.050 --> 21:24.050
是不是还是要浪费那个

21:24.050 --> 21:26.050
有时候开100个开200个

21:26.050 --> 21:27.050
不是很爽吗

21:27.050 --> 21:29.050
那这样子它切换的太频繁了

21:29.050 --> 21:30.050
切换它频繁了

21:30.050 --> 21:33.050
反而会降低执行效率

21:33.050 --> 21:36.050
而这是要充分利用多核CPU

21:36.050 --> 21:40.050
而且你现场的执行过程中

21:40.050 --> 21:44.050
现场执行过程中

21:44.050 --> 21:46.050
尽量的不要主色

21:46.050 --> 21:47.050
什么叫主色

21:47.050 --> 21:49.050
就是个现场没啥时候说

21:49.050 --> 21:51.050
要等就要主色

21:51.050 --> 21:53.050
比方说你读一个文件

21:53.050 --> 21:54.050
是不是IO

21:54.050 --> 21:55.050
对吧

21:55.050 --> 21:56.050
你要发出一个请求

21:56.050 --> 21:57.050
请求是不是IO

21:57.050 --> 21:59.050
这些IO操作

21:59.050 --> 22:01.050
都是非常花时间的

22:01.050 --> 22:02.050
举个夸张的例子

22:02.050 --> 22:04.050
如果整个程序100

22:04.050 --> 22:06.050
程序的运行时间是100

22:06.050 --> 22:07.050
IO的时间要占99

22:07.050 --> 22:09.050
就这么夸张

22:09.050 --> 22:10.050
包括读数据户

22:10.050 --> 22:11.050
这些都是IO

22:11.050 --> 22:13.050
IO操作非常占时间

22:13.050 --> 22:15.050
那么IO操作跟内存

22:15.050 --> 22:16.050
没有什么关系

22:16.050 --> 22:18.050
那么现场是不是在那里等

22:18.050 --> 22:19.050
等它的数据拿到

22:19.050 --> 22:20.050
就在那里干等

22:20.050 --> 22:21.050
就要主色

22:22.050 --> 22:23.050
你现场的执行过程中

22:23.050 --> 22:24.050
尽量不要主色

22:24.050 --> 22:26.050
为什么要不要主色呢

22:26.050 --> 22:28.050
你看你主色会发生什么情况

22:28.050 --> 22:30.050
CPU一看过来

22:30.050 --> 22:31.050
你还没好啊

22:31.050 --> 22:32.050
你还在等

22:32.050 --> 22:34.050
我到那里好不容易切关了

22:34.050 --> 22:35.050
发现你还在等

22:35.050 --> 22:36.050
我又要切走

22:36.050 --> 22:38.050
切走过以后我又切过来

22:38.050 --> 22:39.050
发现你还在等

22:39.050 --> 22:40.050
我又要切走

22:40.050 --> 22:42.050
这样子反而会浪费

22:42.050 --> 22:43.050
会浪费执行效率

22:43.050 --> 22:44.050
而且主色还有一些

22:44.050 --> 22:45.050
其他的不好的地方

22:45.050 --> 22:47.050
我就不讲神了

22:47.050 --> 22:48.050
包括操作系统底层

22:48.050 --> 22:50.050
关于主色的一些处理

22:50.050 --> 22:52.050
我们来看待主色现场的

22:52.050 --> 22:53.050
这些东西不讲神了

22:53.050 --> 22:55.050
总之主色不是一个好东西

22:55.050 --> 22:57.050
不是一个好现象

22:57.050 --> 22:58.050
它是一个现象

22:58.050 --> 22:59.050
但不是一个好现象

22:59.050 --> 23:01.050
尽量的不要主色

23:01.050 --> 23:03.050
也就是现场最好的效果

23:03.050 --> 23:04.050
就是什么呢

23:04.050 --> 23:10.050
第一个最理想的现场效果

23:10.050 --> 23:12.050
就第一个现场数

23:12.050 --> 23:14.050
就有一个进程的现场数

23:14.050 --> 23:18.050
等于CPU的数量

23:19.050 --> 23:22.940
等于CPU的数量

23:22.940 --> 23:23.940
有些电脑里面

23:23.940 --> 23:24.940
它可能有多个CPU

23:24.940 --> 23:25.940
那有多个CPU

23:25.940 --> 23:26.940
CPU的数量乘以

23:26.940 --> 23:28.940
每个CPU的核数

23:28.940 --> 23:29.940
夹起来

23:29.940 --> 23:30.940
这是最好的现场数

23:30.940 --> 23:31.940
最理想的情况

23:31.940 --> 23:32.940
第二个就是

23:32.940 --> 23:37.940
现场永不主色

23:37.940 --> 23:39.940
那么这种都是比较理想的

23:39.940 --> 23:41.940
但是有些后端开发的程序

23:41.940 --> 23:42.940
它已经把一个程序

23:42.940 --> 23:43.940
结构也就已经顾了下来

23:43.940 --> 23:45.940
它要主色也没办法

23:45.940 --> 23:48.940
但是现在很多

23:48.940 --> 23:50.940
包括服务器应用程序

23:50.940 --> 23:51.940
都在借鉴漏的

23:51.940 --> 23:53.940
结实那种异步的处理模式

23:53.940 --> 23:54.940
就尽量少开线程

23:54.940 --> 23:56.940
因为开线就非常容易主色

23:56.940 --> 23:58.940
理想的现场是永不主色的

23:58.940 --> 23:59.940
那么什么情况下

23:59.940 --> 24:01.940
现场是永不主色的呢

24:01.940 --> 24:03.940
没有IO

24:03.940 --> 24:08.940
只存在大量运算

24:08.940 --> 24:10.940
所以说我们

24:10.940 --> 24:12.940
我们通过这几个例子

24:12.940 --> 24:13.940
总结起来的话

24:13.940 --> 24:16.940
就是什么时候要使用线程

24:16.940 --> 24:27.140
一般处理CPU密集形操作

24:27.140 --> 24:31.140
就是运算操作

24:31.140 --> 24:33.140
我们要进行很多运算

24:33.140 --> 24:34.140
运算量太大了

24:34.140 --> 24:37.140
我们要用CPU密集形操作

24:37.140 --> 24:39.140
来开启线程

24:39.140 --> 24:40.140
那么一个线程去运行

24:40.140 --> 24:41.140
我举个例子

24:41.140 --> 24:43.140
比如说我用一万个文件

24:43.140 --> 24:45.140
需要打压缩

24:45.140 --> 24:46.140
压缩是一种算法

24:46.140 --> 24:48.140
这个算法还是蛮好时间的

24:48.140 --> 24:49.140
或者说加密

24:49.140 --> 24:52.140
因为一百个文件内容需要加密

24:52.140 --> 24:54.140
放到数组里面的

24:54.140 --> 24:55.140
五件内容已经读出来了

24:55.140 --> 24:57.140
放到数组里面的内容也不多

24:57.140 --> 24:58.140
那么我们需要加密

24:58.140 --> 24:59.140
加密是一个算法

24:59.140 --> 25:00.140
每个加密都是算法

25:00.140 --> 25:02.140
那么这些就非常适合用线程

25:02.140 --> 25:03.140
为什么呢

25:03.140 --> 25:05.140
你想我要加密

25:05.140 --> 25:07.140
它是不是就是运算

25:07.140 --> 25:08.140
是不是就是运算

25:08.140 --> 25:09.140
大量的密集形运算

25:09.140 --> 25:11.140
而且这些运算之间

25:11.140 --> 25:13.140
它们之间没有什么交固的

25:13.140 --> 25:14.140
所以我们离线的线程

25:14.140 --> 25:16.140
就是线程相对独立

25:16.140 --> 25:18.140
几乎不使用共享数据

25:18.140 --> 25:19.140
因为数据一共享的话

25:19.140 --> 25:21.140
就像出现刚才我们觉得的例子

25:21.140 --> 25:23.140
就会出现的那个非常诡异的问题

25:24.140 --> 25:26.140
几乎不使用共享数据

25:26.140 --> 25:28.140
你看刚才的一个例子就是加密

25:28.140 --> 25:29.140
加密的话

25:29.140 --> 25:31.140
我们有一万个数据需要加密

25:31.140 --> 25:32.140
每个数据加密

25:32.140 --> 25:33.140
它们各自加密就行了

25:33.140 --> 25:34.140
对吧

25:34.140 --> 25:35.140
我跟其他数据没什么关系

25:35.140 --> 25:36.140
相对独立吗

25:36.140 --> 25:37.140
对吧

25:37.140 --> 25:38.140
那么我们比较说

25:38.140 --> 25:39.140
我就开一共有八个

25:39.140 --> 25:40.140
八盒的CPU

25:40.140 --> 25:41.140
我第一个盒

25:41.140 --> 25:42.140
你出了一个两百条数据

25:42.140 --> 25:43.140
你出了一个一千条

25:43.140 --> 25:44.140
对吧

25:44.140 --> 25:45.140
你出了一个两百条数据

25:45.140 --> 25:46.140
你出了一个一千条

25:46.140 --> 25:47.140
你第二个盒

25:47.140 --> 25:48.140
你再出了一千五百条

25:48.140 --> 25:49.140
你第三个盒

25:49.140 --> 25:50.140
你再出了一千五百条

25:50.140 --> 25:52.140
你充分利用多盒CPU

25:52.140 --> 25:54.140
每个盒都去疯狂的运转

25:54.140 --> 25:56.140
帮我来进行加密处理

25:56.140 --> 25:57.140
然后最后

25:57.140 --> 25:58.140
加密完了过后

25:58.140 --> 26:00.140
每个线程回馈给我

26:00.140 --> 26:01.140
每个线程回馈给我

26:01.140 --> 26:02.140
主线程

26:02.140 --> 26:03.140
主线程把它汇总

26:03.140 --> 26:05.140
这样子是比较好的

26:05.140 --> 26:06.140
这样子的线程操作是比较好的

26:06.140 --> 26:08.140
千万不要再尽量的

26:08.140 --> 26:09.140
不要再尽量的

26:09.140 --> 26:11.140
不要在线程里面去搞什么IO操作

26:12.140 --> 26:14.140
这种是IO密集型

26:16.140 --> 26:19.140
和IO密集型操作

26:19.140 --> 26:22.140
不适合使用线程

26:22.140 --> 26:25.140
而适合使用异部

26:25.140 --> 26:26.140
因为异部只有一个线程

26:26.140 --> 26:27.140
对吧

26:27.140 --> 26:28.140
只有那么一个线程

26:28.140 --> 26:29.140
所以说呢

26:29.140 --> 26:31.140
没有线程之间的切换开销

26:31.140 --> 26:32.140
反正都要等

26:32.140 --> 26:34.140
我就让你等吧

26:34.140 --> 26:35.140
等完了给我一个回掉

26:35.140 --> 26:36.140
在我等的过程中

26:36.140 --> 26:38.140
我就不在那里敢等了

26:38.140 --> 26:40.140
我就马上去运行别的人

26:40.140 --> 26:41.140
等你完了过后

26:41.140 --> 26:43.140
我再去处理的回掉

26:43.140 --> 26:44.140
这是最适合的模式

26:44.140 --> 26:45.140
这就是为什么

26:45.140 --> 26:46.140
load.js

26:46.140 --> 26:48.140
它的IO性能非常非常高

26:48.140 --> 26:49.140
但是load.js

26:49.140 --> 26:51.140
不适合做这种CPU密集型

26:51.140 --> 26:52.140
就是计算密集型的操作

26:52.140 --> 26:53.140
因为它只有一个线程

26:53.140 --> 26:55.140
但是现在可以有多个线程

26:55.140 --> 26:57.140
而适合使用异部

26:57.140 --> 26:58.140
就是IO密集型

26:58.140 --> 27:00.140
我把这个说清楚

27:00.140 --> 27:02.140
那么最后我们说说load.js

27:02.140 --> 27:04.140
如何来开启线程

27:04.140 --> 27:06.140
来操作呢

27:06.140 --> 27:07.140
看一下吧

27:07.140 --> 27:09.140
我先阅读一下代码

27:09.140 --> 27:10.140
我们来举个例子

27:10.140 --> 27:13.140
比方说我们这里有一个

27:13.140 --> 27:14.140
它可以导入一个内置的库

27:14.140 --> 27:15.140
叫worker

27:15.140 --> 27:17.140
worker工作线程

27:17.140 --> 27:19.140
导入这么一个库

27:19.140 --> 27:20.140
它里边有一些信息

27:20.140 --> 27:22.140
我们就导入一个构造函数

27:22.140 --> 27:23.140
只要你创建那个构造函数

27:23.140 --> 27:25.140
相当于是创建了一个线程

27:25.140 --> 27:26.140
就这么个意思

27:26.140 --> 27:28.140
那么这里边要传两个参数

27:28.140 --> 27:29.140
第一个参数呢

27:29.140 --> 27:32.140
是线程的入口执行文件

27:32.140 --> 27:33.140
因为一旦一个线程产生了

27:33.140 --> 27:35.140
它的执行跟那个主线程之间

27:35.140 --> 27:36.140
跟这个线程之间

27:36.140 --> 27:37.140
就没有什么关系了

27:37.140 --> 27:38.140
它就是执行它的

27:38.140 --> 27:39.140
你执行你的

27:39.140 --> 27:42.140
只不过数据是可以共享的

27:42.140 --> 27:44.140
执行是没有任何关系的

27:44.140 --> 27:45.140
那么这里呢

27:45.140 --> 27:47.140
我们把个入口文件给它

27:47.140 --> 27:49.140
把这个线程的入口文件给它

27:49.140 --> 27:50.140
就要你要执行哪个文件

27:50.140 --> 27:51.140
你去执行

27:51.140 --> 27:52.140
你的意思吧

27:52.140 --> 27:55.140
比方说举个例子吧

27:55.140 --> 27:56.140
举个例子

27:56.140 --> 28:00.140
我们在这里

28:00.140 --> 28:07.780
把代码复制一下来吧

28:07.780 --> 28:08.780
那么这里呢

28:08.780 --> 28:10.780
我们就给它写个入口文件

28:10.780 --> 28:12.780
我们可以给它写个决定路径

28:12.780 --> 28:13.780
文件路径

28:13.780 --> 28:15.780
require pass

28:15.780 --> 28:16.780
好

28:16.780 --> 28:17.780
我这里开启一个线程

28:17.780 --> 28:18.780
你去执行啥呢

28:18.780 --> 28:20.780
你去执行

28:20.780 --> 28:23.780
第二列

28:23.780 --> 28:25.780
你去执行另外一个文件

28:25.780 --> 28:26.780
比方说我们这里

28:26.780 --> 28:27.780
去写个worker文件

28:27.780 --> 28:28.780
要介绍

28:28.780 --> 28:29.780
我们输出

28:29.780 --> 28:35.780
这是只线程输出的内容

28:35.780 --> 28:36.780
那么这里呢

28:36.780 --> 28:38.780
举起执行这个worker的介绍

28:38.780 --> 28:39.780
我把这个路径给你

28:39.780 --> 28:40.780
你去执行这个文件

28:40.780 --> 28:41.780
这个新的线程

28:41.780 --> 28:42.780
你去执行这个文件

28:42.780 --> 28:44.780
还是用路德介式执行

28:44.780 --> 28:45.780
然后我可能会给你

28:45.780 --> 28:46.780
传一些数据

28:46.780 --> 28:47.780
比如说传一个E23

28:47.780 --> 28:48.780
随便什么数据都可以

28:48.780 --> 28:50.780
我主线程可以传给你

28:50.780 --> 28:51.780
当然这个不是说

28:51.780 --> 28:52.780
超多系统就是这种模式

28:52.780 --> 28:54.780
超多系统不是这种模式的

28:54.780 --> 28:56.780
只是说路德介式

28:56.780 --> 28:58.780
它给你做成这样的API了

28:58.780 --> 28:59.780
比较清晰

28:59.780 --> 29:00.780
我把通过这个配置

29:00.780 --> 29:01.780
这个参数是个对象

29:01.780 --> 29:02.780
里面有配置的

29:02.780 --> 29:03.780
通过这个worker data

29:03.780 --> 29:05.780
把这个数据传给你

29:05.780 --> 29:06.780
传给你的线程

29:06.780 --> 29:07.780
那么我在主线程里

29:07.780 --> 29:09.780
就得到一个实地的

29:09.780 --> 29:10.780
那么主线程是不是执行了

29:10.780 --> 29:11.780
这个

29:11.780 --> 29:12.780
当我们去运行

29:15.780 --> 29:16.780
当我们去运行

29:16.780 --> 29:17.780
因这个事的时候

29:17.780 --> 29:19.780
那么我们开启的是主线程

29:19.780 --> 29:20.780
主线程执行的是这个

29:20.780 --> 29:21.780
对不对

29:21.780 --> 29:22.780
那么在主线程的执行过程中

29:22.780 --> 29:24.780
是不是新开了一个线程

29:24.780 --> 29:25.780
worker对吧

29:25.780 --> 29:27.780
就执行这个线程

29:27.780 --> 29:28.780
原来的意思

29:29.780 --> 29:30.780
来 运行

29:30.780 --> 29:31.780
你看是不是得到这个

29:31.780 --> 29:33.780
执行程输出的内容

29:33.780 --> 29:34.780
对吧

29:34.780 --> 29:36.780
那么有一个线程去执行它了

29:36.780 --> 29:38.780
就这么个意思

29:39.780 --> 29:41.780
好 我们继续看

29:41.780 --> 29:43.780
我又把夹码打开了

29:43.780 --> 29:44.780
然后主线程里边

29:44.780 --> 29:46.780
我们还可以通过一些方式

29:46.780 --> 29:49.100
主线程里面

29:49.100 --> 29:50.100
我们可以通过一些方式

29:50.100 --> 29:52.100
跟纸线程进行交互

29:52.100 --> 29:53.100
比方说

29:53.100 --> 29:55.100
我们可以监听纸线程里边退出

29:55.100 --> 29:58.100
如说纸线程退出了

29:58.100 --> 29:59.100
那么我们就可以

29:59.100 --> 30:01.100
这个时间就会运行

30:02.100 --> 30:03.100
我们来试一下吧

30:06.500 --> 30:08.500
纸线程退出的时候

30:08.500 --> 30:09.500
输出

30:10.500 --> 30:12.500
纸线程退出了

30:14.500 --> 30:15.500
保存

30:16.500 --> 30:17.500
接下来

30:17.500 --> 30:18.500
我们这里运行

30:18.500 --> 30:20.500
load index

30:20.500 --> 30:21.500
纸线程退出了

30:21.500 --> 30:22.500
是不是这里

30:22.500 --> 30:23.500
可以抽到这个消息

30:23.500 --> 30:24.500
对不对

30:24.500 --> 30:25.500
然后还要message

30:25.500 --> 30:26.500
就纸线程给我

30:26.500 --> 30:29.500
复线程发消息的时候

30:29.500 --> 30:30.500
因为线程这样要通信

30:30.500 --> 30:32.500
可以随意通信

30:32.500 --> 30:33.500
任何时候

30:33.500 --> 30:34.500
通信任何那种都可以

30:34.500 --> 30:35.500
发消息的时候

30:35.500 --> 30:37.500
它可以通过这个时间

30:37.500 --> 30:38.500
纸线程的消息

30:38.500 --> 30:39.500
然后复线程也可以

30:39.500 --> 30:40.500
给纸线程发消息

30:40.500 --> 30:41.500
任何消息

30:41.500 --> 30:42.500
这些东西

30:43.500 --> 30:44.500
它都不是操作系统

30:44.500 --> 30:45.500
线程特有的

30:45.500 --> 30:46.500
是load接下来

30:46.500 --> 30:47.500
给你搞出来的玩笑

30:47.500 --> 30:48.500
它是基于

30:48.500 --> 30:49.500
event emitter

30:49.500 --> 30:50.500
给你们做的

30:50.500 --> 30:51.500
做了这样一个

30:51.500 --> 30:52.500
这种方式

30:52.500 --> 30:54.500
然后复线程有权利

30:54.500 --> 30:56.500
把纸线程终止

30:56.500 --> 30:58.500
它有权利把纸线程终止

30:58.500 --> 30:59.500
否则的话

30:59.500 --> 31:00.500
纸线程就是运行完了

31:00.500 --> 31:01.500
我就终止了

31:01.500 --> 31:02.500
这么个意思

31:03.500 --> 31:04.500
那么纸线程

31:04.500 --> 31:05.500
纸线程里边

31:05.500 --> 31:06.500
有什么处理方式呢

31:06.500 --> 31:07.500
就在这边

31:07.500 --> 31:08.500
在纸线程里边

31:08.500 --> 31:09.500
纸线程在运行这个文件

31:09.500 --> 31:11.500
它把这个文件运行一次

31:11.500 --> 31:12.500
就完事了

31:12.500 --> 31:13.500
纸线程在运行它的时候

31:13.500 --> 31:14.500
它也有它的处理方式

31:14.500 --> 31:16.500
比方它可以通过这个

31:16.500 --> 31:18.500
来判断

31:18.500 --> 31:20.500
是否是主线程

31:20.500 --> 31:21.500
我这个线程是不是主线程

31:21.500 --> 31:23.500
可以通过它

31:23.500 --> 31:24.500
通过这个对象

31:24.500 --> 31:26.500
与复线程之间进行通信

31:26.500 --> 31:27.500
通过这个work data

31:27.500 --> 31:29.500
来获取复线程给我传的数据

31:29.500 --> 31:30.500
你看复线程

31:30.500 --> 31:31.500
是不是通过这个地方

31:31.500 --> 31:32.500
给它传数据过来了

31:32.500 --> 31:33.500
线程启动的时候

31:33.500 --> 31:34.500
给它传了一些数据

31:34.500 --> 31:35.500
那么纸线程

31:35.500 --> 31:36.500
就可以通过它来获取数据

31:36.500 --> 31:38.500
然后通过这个

31:38.500 --> 31:39.500
ID

31:39.500 --> 31:40.500
就是线程的意思

31:40.500 --> 31:42.500
每个线程是一个唯一编号的

31:42.500 --> 31:43.500
是一个唯一编号的

31:43.500 --> 31:45.500
那么可以获取这个线程的编号

31:45.500 --> 31:46.500
那么这里

31:46.500 --> 31:48.500
还可以收到复线程

31:48.500 --> 31:50.500
发过来的信息

31:50.500 --> 31:53.500
它还可以收到这个复线程

31:53.500 --> 31:54.500
复线程之前不是有个

31:54.500 --> 31:55.500
post message吗

31:55.500 --> 31:56.500
对吧

31:56.500 --> 31:57.500
它发消息过来

31:57.500 --> 31:58.500
那么可以通过这个东西

31:58.500 --> 31:59.500
来收到消息

31:59.500 --> 32:00.500
也可以给复线程发消息

32:00.500 --> 32:01.500
你看复线程

32:01.500 --> 32:02.500
就是一个可以接收消息

32:02.500 --> 32:03.500
对不对

32:03.500 --> 32:04.500
这是线程之间的通信

32:04.500 --> 32:05.500
总之那线程

32:05.500 --> 32:06.500
你给它一个文件

32:06.500 --> 32:07.500
它就把文件运行一遍

32:07.500 --> 32:08.500
就完事了

32:08.500 --> 32:09.500
运行的过程中

32:09.500 --> 32:10.500
可能给复线程进行通信

32:10.500 --> 32:11.500
好 那么

32:11.500 --> 32:12.500
现在我举一个例子

32:12.500 --> 32:13.500
给大家举个例子

32:13.500 --> 32:14.500
看一下什么情况下

32:14.500 --> 32:16.500
我们可能会使用线程

32:16.500 --> 32:18.500
就是计算密集性

32:18.500 --> 32:19.500
把这个复线程

32:19.500 --> 32:21.870
比方说

32:24.870 --> 32:26.870
我们写这么一个公共模块

32:30.870 --> 32:32.870
这个模块就导出

32:32.870 --> 32:34.870
你们一开始初学的时候

32:34.870 --> 32:35.870
应该写过这个玩意的吧

32:35.870 --> 32:36.870
最恶心的

32:36.870 --> 32:38.870
判断一个数是不是数数

32:38.870 --> 32:40.870
怎么叫数数

32:40.870 --> 32:42.870
有可能有些人都忘了

32:42.870 --> 32:44.870
就是只能被1和

32:44.870 --> 32:47.870
自身整除的数

32:47.870 --> 32:48.870
这个不是重点

32:48.870 --> 32:49.870
一点都不重要

32:49.870 --> 32:50.870
数数一点都不重要

32:50.870 --> 32:51.870
我们只通过这个例子

32:51.870 --> 32:52.870
来说明这个线程

32:52.870 --> 32:54.870
判断数数是比较

32:54.870 --> 32:55.870
是一个计算密集型

32:55.870 --> 32:56.870
对吧

32:56.870 --> 32:57.870
它要进行运算

32:57.870 --> 32:58.870
怎么判断呢

32:58.870 --> 32:59.870
首先判断一下

32:59.870 --> 33:00.870
n是不是小于2

33:00.870 --> 33:01.870
小于2的数

33:01.870 --> 33:02.870
肯定不是数数

33:02.870 --> 33:03.870
反而是

33:03.870 --> 33:04.870
那么接下来

33:04.870 --> 33:05.870
我用一种非常笨的办法

33:05.870 --> 33:06.870
我知道有些同学说

33:06.870 --> 33:07.870
跟耗2

33:07.870 --> 33:08.870
什么处于2

33:08.870 --> 33:09.870
也都可以

33:09.870 --> 33:10.870
为了表达它的计算

33:10.870 --> 33:11.870
是密集的

33:11.870 --> 33:14.870
我就用这种很笨的办法

33:14.870 --> 33:16.870
从2开始小于n

33:16.870 --> 33:19.870
看一下2到n-1之间

33:19.870 --> 33:21.870
有没有一个数能整除n

33:21.870 --> 33:22.870
如果说有的话

33:22.870 --> 33:23.870
它就不是数数

33:23.870 --> 33:24.870
因为它只能被2和

33:24.870 --> 33:25.870
自身整除

33:25.870 --> 33:26.870
这个东西不重要

33:26.870 --> 33:27.870
我在这里说

33:27.870 --> 33:29.870
数数怎么判断不重要

33:29.870 --> 33:30.870
我们只是说明

33:30.870 --> 33:31.870
这个线程的道理

33:31.870 --> 33:32.870
总之有这么一个函数

33:32.870 --> 33:33.870
给你写好了

33:33.870 --> 33:35.870
判断一个数是不是数数

33:35.870 --> 33:36.870
掉那个函数

33:36.870 --> 33:37.870
那么就是

33:37.870 --> 33:39.870
返回去就表示数数

33:39.870 --> 33:40.870
返回force就表示不是

33:40.870 --> 33:42.870
就假设有这么一个函数

33:42.870 --> 33:43.870
那么这边我导致进来

33:43.870 --> 33:44.870
ex-prime

33:49.870 --> 33:50.870
好

33:50.870 --> 33:52.870
那么我们这里输出

33:52.870 --> 33:53.870
看一下这个

33:53.870 --> 33:54.870
试一下

33:54.870 --> 33:55.870
看一下2是不是数数

33:55.870 --> 33:56.870
2肯定是数数

33:56.870 --> 33:58.870
用npm的start

33:58.870 --> 34:00.870
2是不是数数

34:00.870 --> 34:01.870
然后看一下

34:01.870 --> 34:03.870
6是不是数数呢

34:03.870 --> 34:04.870
6就不是

34:04.870 --> 34:05.870
看没

34:05.870 --> 34:06.870
就这么个意思

34:06.870 --> 34:07.870
那么接下来

34:07.870 --> 34:08.870
我们要这样子来玩

34:08.870 --> 34:10.870
我现在准备好一个数数

34:10.870 --> 34:12.870
这个数数很大很大

34:12.870 --> 34:14.870
为了模拟这个效果

34:14.870 --> 34:15.870
但是这个数数

34:15.870 --> 34:16.870
有可能是用数据固定的

34:16.870 --> 34:17.870
有可能是用网络

34:17.870 --> 34:18.870
请求过来的

34:18.870 --> 34:19.870
总之我不知道

34:19.870 --> 34:20.870
是什么玩意

34:20.870 --> 34:21.870
总之这个数数很大

34:21.870 --> 34:22.870
我这里就模拟

34:22.870 --> 34:23.870
1000条数据

34:23.870 --> 34:24.870
也不要加多了

34:24.870 --> 34:25.870
因为判断数数

34:25.870 --> 34:27.870
这边还有很多的运算

34:27.870 --> 34:28.870
然后这边

34:28.870 --> 34:29.870
每一次给它

34:29.870 --> 34:31.870
扣习一个

34:31.870 --> 34:33.870
加一个就是水积数

34:33.870 --> 34:34.870
水积数

34:34.870 --> 34:37.310
我们就用flop

34:37.310 --> 34:38.310
mess

34:38.310 --> 34:39.310
ret

34:39.310 --> 34:40.310
乘以

34:40.310 --> 34:41.310
不要乘以

34:41.310 --> 34:42.310
数字很大

34:42.310 --> 34:46.390
把乘以1个亿

34:46.390 --> 34:47.390
多了吗

34:47.390 --> 34:48.390
少了

34:48.390 --> 34:49.390
1 2 3

34:50.390 --> 34:51.390
就10亿

34:52.390 --> 34:53.390
总之这个数字

34:53.390 --> 34:54.390
数字可能很大

34:54.390 --> 34:55.390
数字可能很大

34:55.390 --> 34:56.390
那么就把它

34:56.390 --> 34:57.390
放到一个数组里边

34:57.390 --> 34:58.390
数组里边是不是装了

34:58.390 --> 34:59.390
1000个数字

34:59.390 --> 35:00.390
那么每一个数字

35:00.390 --> 35:01.390
它都很大

35:03.390 --> 35:04.390
老师

35:04.390 --> 35:05.390
来看一下

35:05.390 --> 35:06.390
所以有1000个数字

35:06.390 --> 35:07.390
每个数字的都很大

35:07.390 --> 35:08.390
那你想

35:08.390 --> 35:09.390
每一个很大的数字

35:09.390 --> 35:10.390
它判断它是不是

35:10.390 --> 35:11.390
数数是不是

35:11.390 --> 35:12.390
会经过很长的时间

35:12.390 --> 35:13.390
我们要得到的结果就是

35:13.390 --> 35:14.390
从这个数组中

35:14.390 --> 35:16.390
找出哪些数数

35:16.390 --> 35:18.390
把它放到一个新的数组里边

35:18.390 --> 35:20.390
new

35:22.390 --> 35:23.390
给它一个新的数数

35:23.390 --> 35:24.390
我们这里寄个10

35:24.390 --> 35:25.390
用console

35:25.390 --> 35:26.390
temp

35:26.390 --> 35:27.390
来寄10

35:27.390 --> 35:28.390
看一下

35:28.390 --> 35:29.390
运算需要花多好时间

35:30.390 --> 35:31.390
然后循环

35:32.390 --> 35:34.390
循环用follow

35:34.390 --> 35:36.390
循环每一个数字

35:36.390 --> 35:37.390
每一个数字

35:37.390 --> 35:38.390
我就判断一下

35:38.390 --> 35:39.390
easy plan

35:39.390 --> 35:40.390
你看这个判断

35:40.390 --> 35:41.390
肯定要经过很漫长的过程

35:41.390 --> 35:42.390
一个数字很大的话

35:42.390 --> 35:43.390
它就从2开始

35:43.390 --> 35:44.390
到2

35:44.390 --> 35:45.390
自身减1之间

35:45.390 --> 35:47.390
需要很长的时间

35:47.390 --> 35:48.390
判断

35:48.390 --> 35:49.390
而且有这么多数字

35:49.390 --> 35:50.390
然后那我们

35:51.390 --> 35:53.390
如果说4数数的话

35:53.390 --> 35:54.390
把它加进来

35:54.390 --> 35:55.390
最后我们输出

35:55.390 --> 35:56.390
看一下

35:57.390 --> 35:58.390
看一下它认识

35:59.390 --> 36:00.390
它的长度

36:00.390 --> 36:01.390
打印出来的话

36:01.390 --> 36:02.390
打印出来吧

36:03.390 --> 36:04.390
看一下哪些是数数

36:06.390 --> 36:07.390
最后不要忘记了

36:07.390 --> 36:08.390
我们写个time end

36:08.390 --> 36:09.390
就计时结束

36:10.390 --> 36:12.390
看一下中间会花多好时间

36:13.390 --> 36:14.390
停止

36:14.390 --> 36:16.390
load index

36:16.390 --> 36:17.390
等吧

36:18.390 --> 36:19.390
这就是计算密集性

36:19.390 --> 36:20.390
它没有什么IO

36:20.390 --> 36:21.390
就存运算

36:21.390 --> 36:23.390
大量的运算

36:24.390 --> 36:25.390
会耗费很多很多时间

36:26.390 --> 36:27.390
从这里开始

36:27.390 --> 36:28.390
我们前面是模拟的

36:28.390 --> 36:29.390
我们只关心这一步

36:29.390 --> 36:31.390
就是判断数数这一步

36:31.390 --> 36:32.390
把数数加入到新的数数

36:32.390 --> 36:34.390
就这一步需要花多少时间

36:34.390 --> 36:36.390
前面肯定会花不少的时间

36:37.390 --> 36:38.390
前面会花不少

36:40.390 --> 36:41.390
等一下

36:41.390 --> 36:42.390
时间有点长

36:42.390 --> 36:43.390
有点长

36:43.390 --> 36:46.960
这也太长了吧

36:46.960 --> 36:50.660
需要这么长的时间吗

36:50.660 --> 36:55.760
这时间也太长了吧

37:00.700 --> 37:01.700
我的天啊

37:02.700 --> 37:03.700
那这样子

37:03.700 --> 37:05.700
为了避免

37:05.700 --> 37:06.700
避免对这个

37:06.700 --> 37:08.700
最后的对比结果造成干了

37:08.700 --> 37:09.700
我干脆把这个ARR

37:09.700 --> 37:11.700
先保存到一个接生文件里边

37:12.700 --> 37:14.700
先保存到一个接生文件里边

37:14.700 --> 37:15.700
我们倒入这个file

37:18.330 --> 37:19.330
require fs

37:21.330 --> 37:22.330
然后呢

37:23.330 --> 37:25.330
用fswrite

37:25.330 --> 37:26.330
write file

37:26.330 --> 37:28.330
像一个文件里面写一个数据

37:28.330 --> 37:30.330
就写到那个就是

37:30.330 --> 37:31.330
numbers

37:31.330 --> 37:33.330
numbers叫接生

37:33.330 --> 37:34.330
就写到这么一个文件里面去

37:35.330 --> 37:36.330
就当前部路

37:36.330 --> 37:38.330
拿着写写写写的路径

37:38.330 --> 37:40.330
然后把这个ARR

37:41.330 --> 37:42.330
就是接生

37:42.330 --> 37:44.330
string give

37:44.330 --> 37:45.330
ARR

37:45.330 --> 37:47.640
写进去

37:47.640 --> 37:48.640
写进去

37:49.640 --> 37:50.640
来吧

37:51.640 --> 37:56.680
然后拿文运行

37:56.680 --> 37:58.680
load index

37:59.680 --> 38:00.680
什么呢

38:00.680 --> 38:01.680
callback

38:02.680 --> 38:04.680
它还有个callback

38:04.680 --> 38:09.720
还有个callback

38:16.960 --> 38:18.960
那么我们这里写上一个callback吧

38:20.960 --> 38:21.960
你啥都不用写

38:22.960 --> 38:23.960
运行

38:25.960 --> 38:28.960
这个接生格是numbers出来了

38:28.960 --> 38:30.960
那么有这么多数字的

38:30.960 --> 38:31.960
我们保持数字一样

38:31.960 --> 38:32.960
那么后边我们就

38:32.960 --> 38:33.960
AR来自于哪呢

38:33.960 --> 38:34.960
來自于require

38:38.590 --> 38:39.590
numbers

38:41.590 --> 38:42.590
numbers.json

38:42.590 --> 38:43.590
来自于这

38:46.930 --> 38:47.930
然后我们再来看

38:47.930 --> 38:48.930
这样子呢

38:49.930 --> 38:50.930
就把数字固定下来了

38:51.930 --> 38:52.930
运行

38:53.930 --> 38:54.930
还少很久

38:55.930 --> 38:56.930
这也太久了

39:00.140 --> 39:01.140
需要这么久吗

39:03.140 --> 39:04.140
需要这么久吗

39:04.140 --> 39:05.140
总之你可以看到

39:05.140 --> 39:07.140
这个CPU密集型的操作

39:07.140 --> 39:08.140
如果说单线程的话

39:08.140 --> 39:10.140
它处理起来确实困难

39:10.140 --> 39:12.140
它太忙了

39:12.140 --> 39:14.140
你看这么大的数字

39:14.140 --> 39:16.140
这么大的数字要循环多久

39:17.140 --> 39:18.140
numbers

39:18.140 --> 39:19.140
这个数字太大了

39:20.140 --> 39:21.140
太大了

39:21.140 --> 39:23.140
每一次都是极易式的循环

39:23.140 --> 39:24.140
每一次

39:29.140 --> 39:30.140
等下

39:30.140 --> 39:31.140
我们就扔这吧

39:31.140 --> 39:32.140
就扔这

39:32.140 --> 39:33.140
然后接下来

39:33.140 --> 39:34.140
我们来看一下那个

39:34.140 --> 39:36.140
它总不要运行出来的

39:38.580 --> 39:39.580
是不是这个数字太大了

39:39.580 --> 39:40.580
我把数字放小一点

39:40.580 --> 39:42.580
刚才把数字放小一点

39:42.580 --> 39:43.580
老是出不来

39:43.580 --> 39:44.580
结果有点烦

39:46.580 --> 39:49.580
我把这个数字放小一点

39:53.300 --> 39:54.300
不用十亿

39:54.300 --> 39:55.300
十亿有点夸张了

39:56.300 --> 39:57.300
用一

39:58.300 --> 39:59.300
一的数据

40:00.300 --> 40:02.300
一的数据应该好一些了

40:02.300 --> 40:03.300
应该好一些了

40:03.300 --> 40:05.300
然后我在这里

40:05.300 --> 40:06.300
把数数

40:07.300 --> 40:08.300
试一下

40:08.300 --> 40:09.300
我先试一下

40:09.300 --> 40:10.300
先试一下再说

40:10.300 --> 40:16.230
这个一的数据

40:16.230 --> 40:17.230
五秒钟

40:17.230 --> 40:18.230
五秒钟出来了

40:18.230 --> 40:19.230
那行

40:19.230 --> 40:20.230
五秒钟也行吧

40:20.230 --> 40:21.230
我们把它写到这里边

40:21.230 --> 40:22.230
那么之后

40:22.230 --> 40:23.230
我就把它

40:23.230 --> 40:24.230
这个单码更改一下

40:24.230 --> 40:26.230
就是快点

40:26.230 --> 40:27.230
numbers

40:27.230 --> 40:28.230
接上

40:30.230 --> 40:31.230
好

40:31.230 --> 40:32.230
咱们来看一下

40:33.230 --> 40:34.230
再来看一下

40:34.230 --> 40:35.230
如果说

40:35.230 --> 40:36.230
单线程运行的话

40:36.230 --> 40:37.230
这个时间是多久

40:40.700 --> 40:42.700
一共是5.65秒

40:42.700 --> 40:43.700
对吧

40:43.700 --> 40:44.700
一个是这么多时间

40:44.700 --> 40:45.700
那么这是得到了

40:45.700 --> 40:46.700
所谓的数数

40:46.700 --> 40:47.700
好

40:47.700 --> 40:48.700
那么接下来

40:48.700 --> 40:49.700
我现在使用多线程

40:49.700 --> 40:50.700
我把这个复制一下

40:50.700 --> 40:52.700
使用多线程

40:52.700 --> 40:53.700
多线程怎么玩呢

40:53.700 --> 40:54.700
我们把这个代码复

40:54.700 --> 40:55.700
扔过来

40:55.700 --> 40:56.700
就是开启

40:56.700 --> 40:57.700
就是我这边

40:57.700 --> 40:58.700
主线程的

40:58.700 --> 40:59.700
它不做任何运算

40:59.700 --> 41:00.700
我让纸线程去做运算

41:01.700 --> 41:02.700
好

41:02.700 --> 41:03.700
那么怎么开启

41:03.700 --> 41:04.700
纸线程就是用6W

41:04.700 --> 41:05.700
开启多个纸线

41:05.700 --> 41:06.700
多少个纸线程

41:06.700 --> 41:07.700
我要看一下

41:07.700 --> 41:08.700
我这个操作系统

41:08.700 --> 41:09.700
有多少个CPU

41:09.700 --> 41:11.700
有多少个CPU内核

41:11.700 --> 41:12.700
有多少个

41:12.700 --> 41:13.700
我就创建多少个纸线程

41:13.700 --> 41:14.700
那么我这里得到了

41:14.700 --> 41:15.700
得到了操作系统

41:15.700 --> 41:16.700
我们之前讲过了

41:16.700 --> 41:18.700
得到CPU的数量

41:19.700 --> 41:21.700
CPU number

41:21.700 --> 41:22.700
OS

41:22.700 --> 41:24.700
CPUS

41:24.700 --> 41:25.700
Burnance

41:25.700 --> 41:26.700
我们来说说看一下

41:26.700 --> 41:29.260
CPU number

41:29.260 --> 41:31.260
每个电脑都是不一样的

41:34.260 --> 41:35.260
index

41:35.260 --> 41:36.260
12个

41:36.260 --> 41:38.260
好那么不管你们电脑是多少

41:38.260 --> 41:39.260
然后我们就

41:39.260 --> 41:40.260
一个CPU内核

41:40.260 --> 41:41.260
我就

41:41.260 --> 41:43.260
使用一个线程

41:43.260 --> 41:44.260
好了怎么办

41:44.260 --> 41:46.260
我现在把数组准备好

41:46.260 --> 41:48.260
把刚才的数组准备好

41:48.260 --> 41:50.260
把这两个函数也准备好

41:52.260 --> 41:53.260
那么

41:53.260 --> 41:54.260
我们

41:54.260 --> 41:56.260
数组的长度是多少

41:56.260 --> 41:57.260
我并不知道

41:57.260 --> 41:59.260
我们刚才写了个数组长度

41:59.260 --> 42:00.260
好像是以前

42:00.260 --> 42:01.260
不一定

42:01.260 --> 42:02.260
我就把它平均分

42:03.260 --> 42:04.260
平均分成多少分

42:04.260 --> 42:05.260
分成

42:05.260 --> 42:07.260
这里有12个就平均分成12分

42:07.260 --> 42:09.260
有8个就平均分成8分

42:09.260 --> 42:10.260
每一份

42:10.260 --> 42:11.260
让一个线程去处理

42:11.260 --> 42:13.260
然后最后我在这里会走

42:13.260 --> 42:14.260
好那怎么来做

42:14.260 --> 42:15.260
我们这里可以得到一个

42:17.260 --> 42:19.260
就是AR.nance

42:19.260 --> 42:21.260
除以CPU的数量

42:21.260 --> 42:23.260
那么这个玩意得到的是什么

42:23.260 --> 42:25.260
我们得到的是一个数字

42:25.260 --> 42:26.260
得到的是

42:26.260 --> 42:28.260
得到每一个线程

42:28.260 --> 42:29.260
需要

42:30.260 --> 42:32.260
需要处理的

42:32.260 --> 42:34.260
数组的数量

42:35.260 --> 42:38.830
需要处理的数字数量

42:38.830 --> 42:39.830
然后平均分

42:39.830 --> 42:41.830
把整个数字平均分

42:41.830 --> 42:42.830
这里有可能是小数

42:42.830 --> 42:43.830
比方说

42:43.830 --> 42:44.830
每个线程要处理1.5个

42:44.830 --> 42:46.830
那就向上取整

42:46.830 --> 42:47.830
最后一个线程

42:47.830 --> 42:48.830
你可以轻松一点

42:48.830 --> 42:49.830
你可以处理少一点

42:49.830 --> 42:51.830
前面可以多分一点

42:51.830 --> 42:52.830
差别不到

42:53.830 --> 42:54.830
就得到这个

42:54.830 --> 42:55.830
那么接下来

42:55.830 --> 42:56.830
我们是不是可以

42:56.830 --> 42:57.830
可以来开启线程

42:57.830 --> 42:59.830
要开多少个线程

42:59.830 --> 43:00.830
它有多少个要开多少个

43:00.830 --> 43:01.830
是不是我们可以用循环

43:02.830 --> 43:03.830
i等于0

43:03.830 --> 43:05.830
i小于CPU number

43:07.830 --> 43:08.830
每循环一次

43:08.830 --> 43:10.830
开启一个新的线程

43:11.830 --> 43:12.830
开启一个新的线程

43:12.830 --> 43:13.830
那么新的线程

43:13.830 --> 43:14.830
我们要去运行

43:14.830 --> 43:15.830
另一个文件

43:15.830 --> 43:16.830
那么我就运行

43:16.830 --> 43:17.830
还是运行这个文件

43:17.830 --> 43:18.830
还是运行这个文件不变

43:18.830 --> 43:19.830
我们这里

43:19.830 --> 43:21.830
蓝色适用那个

43:21.830 --> 43:22.830
蓝色适用那个

43:22.830 --> 43:23.830
就是绝对都进了

43:23.830 --> 43:25.830
你们倒是用那个就是

43:26.830 --> 43:28.830
在当前目的运行就行了

43:28.830 --> 43:29.830
我可了解也是

43:29.830 --> 43:30.830
运行这个文件

43:30.830 --> 43:31.830
我给他什么数据

43:31.830 --> 43:32.830
问题是

43:32.830 --> 43:34.830
我给他什么数据

43:34.830 --> 43:37.830
我是不是把这个数组的一部分给他

43:37.830 --> 43:38.830
那么这个时候

43:38.830 --> 43:39.830
我给他的数据

43:39.830 --> 43:40.830
我可以得到

43:40.830 --> 43:41.830
给他什么数据

43:41.830 --> 43:42.830
我就把ARSNES

43:42.830 --> 43:44.830
切割一下

43:44.830 --> 43:45.830
从哪个位置开始

43:45.830 --> 43:46.830
第一份

43:46.830 --> 43:48.830
第一份是不是从下标零开始

43:48.830 --> 43:49.830
零是怎么来的

43:49.830 --> 43:50.830
不就是i成e

43:51.830 --> 43:52.830
第二份

43:52.830 --> 43:54.830
比较说这个这个长度是5

43:55.830 --> 43:57.830
第一份是不是取0到5

43:57.830 --> 43:58.830
第二份是不是取5到10

43:58.830 --> 43:59.830
对不对

43:59.830 --> 44:00.830
所以说这个地方该怎么写

44:01.830 --> 44:02.830
i成e n

44:02.830 --> 44:05.830
摸尾的就是i加1成e n

44:06.830 --> 44:07.830
对不对

44:07.830 --> 44:08.830
这样是不是把数组切割出来

44:08.830 --> 44:10.830
把这一部分的数据给力

44:10.830 --> 44:11.830
你这个县城去处理他

44:11.830 --> 44:12.830
对吧

44:12.830 --> 44:13.830
我开启多个县城

44:13.830 --> 44:14.830
这是一个县城

44:14.830 --> 44:15.830
那么你去处理他

44:15.830 --> 44:16.830
对吧

44:16.830 --> 44:17.830
你去处理他

44:17.830 --> 44:18.830
好

44:18.830 --> 44:19.830
接下来这个县城

44:19.830 --> 44:20.830
他最终会给我发消息

44:20.830 --> 44:21.830
对吧

44:21.830 --> 44:22.830
我要去坚定一下

44:22.830 --> 44:23.830
我这里去击个数

44:23.830 --> 44:25.830
我这里用个边上来击个数

44:25.830 --> 44:27.830
就是numbers

44:27.830 --> 44:29.830
目前的县城数量

44:29.830 --> 44:31.830
目前上线数量就是CPU数量

44:31.830 --> 44:33.830
目前的县城数量

44:33.830 --> 44:35.830
那么到时候处理完一个县城

44:35.830 --> 44:36.830
我就把这个数量减1

44:36.830 --> 44:37.830
处理完我就减1

44:37.830 --> 44:38.830
好

44:38.830 --> 44:40.830
这边我得开启一个新的县城

44:40.830 --> 44:41.830
然后呢我去监听他

44:43.830 --> 44:45.830
当你给我发一个消息的过来的时候

44:45.830 --> 44:46.830
表示什么意思呢

44:46.830 --> 44:48.830
表示你已经处理完了

44:48.830 --> 44:49.830
那么你到时候一定要

44:49.830 --> 44:50.830
把这个处理的结果告诉我

44:50.830 --> 44:51.830
结果就是一个数组

44:51.830 --> 44:53.830
因为你处理处理怎么

44:53.830 --> 44:54.830
就是我给力一个数组

44:54.830 --> 44:55.830
你去处理

44:55.830 --> 44:56.830
处理完了过后

44:56.830 --> 44:57.830
你告诉我哪些是数数

44:57.830 --> 44:58.830
你去运算

44:58.830 --> 45:00.830
我帮我运算哪些是数数

45:00.830 --> 45:02.830
那么我们这里渔绕测

45:02.830 --> 45:03.830
那么渔绕测就是

45:03.830 --> 45:04.830
我就希望双方约定

45:04.830 --> 45:05.830
你给我一个数组

45:05.830 --> 45:06.830
表示你处理完了

45:06.830 --> 45:08.830
这些东西都是数数

45:08.830 --> 45:10.830
于是我这里写一个

45:10.830 --> 45:13.830
6AR来保存最终的结果

45:13.830 --> 45:16.830
这是保存最终结果

45:17.830 --> 45:18.830
你看现在开发起来

45:18.830 --> 45:19.830
是不是比较糟

45:19.830 --> 45:20.830
扑起

45:20.830 --> 45:21.830
我们把这个展开

45:21.830 --> 45:24.140
对吧

45:24.140 --> 45:25.140
你把这个结果给我

45:25.140 --> 45:26.140
那么我就把它加了

45:26.140 --> 45:27.140
我就汇总

45:27.140 --> 45:28.140
汇总到这里边

45:28.140 --> 45:29.140
表示你处理完了

45:29.140 --> 45:30.140
不仅要汇总

45:30.140 --> 45:31.140
然后我们表示

45:31.140 --> 45:32.140
这个线程已经处理完了

45:32.140 --> 45:33.140
对吧

45:33.140 --> 45:34.140
numbers减减

45:34.140 --> 45:35.140
我已经处理完了

45:35.140 --> 45:37.140
然后处理完了

45:37.140 --> 45:39.140
过后我们这里

45:40.140 --> 45:41.140
再判断一下

45:41.140 --> 45:43.140
如果说所有的线程都处理完了

45:43.140 --> 45:44.140
变成零了

45:44.140 --> 45:45.140
对吧

45:45.140 --> 45:46.140
一共有12个线程

45:46.140 --> 45:47.140
那么每处理完一个

45:47.140 --> 45:48.140
我就减减

45:48.140 --> 45:49.140
那么变成零了

45:49.140 --> 45:50.140
是不是所有的线程都处理完了

45:50.140 --> 45:54.140
所有线程都处理结束

45:54.140 --> 45:55.140
干嘛呢

45:55.140 --> 45:57.140
我就输出6L2

45:57.140 --> 45:58.140
然后呢

45:58.140 --> 45:59.140
计时结束

45:59.140 --> 46:00.140
我们在这里计个10

46:00.140 --> 46:04.840
console 10

46:04.840 --> 46:05.840
计时开始

46:05.840 --> 46:06.840
那么这里处理结束了

46:06.840 --> 46:07.840
对吧

46:07.840 --> 46:09.840
console 10 and

46:09.840 --> 46:10.840
然后呢

46:10.840 --> 46:12.840
把这个最终的结果输出

46:12.840 --> 46:13.840
没啥意思吧

46:13.840 --> 46:15.840
输出最终结果

46:15.840 --> 46:17.840
输出最终结果

46:17.840 --> 46:18.840
最后呢

46:18.840 --> 46:19.840
我们不要忘记了

46:19.840 --> 46:20.840
那么每

46:20.840 --> 46:21.840
这个线程已经完成了

46:21.840 --> 46:22.840
给我发消息了

46:22.840 --> 46:24.840
我把这个线程手动结束

46:24.840 --> 46:25.840
手动结束

46:25.840 --> 46:26.840
好

46:26.840 --> 46:27.840
怎么来手动结束呢

46:27.840 --> 46:28.840
你可以用walker

46:28.840 --> 46:30.840
里面的terminate

46:30.840 --> 46:32.840
手动把结束了

46:32.840 --> 46:33.840
就写完了

46:33.840 --> 46:34.840
就写完了

46:34.840 --> 46:35.840
那么剩下的事情

46:35.840 --> 46:36.840
就是在线程里边了

46:36.840 --> 46:37.840
就要到这里边了

46:37.840 --> 46:38.840
好

46:38.840 --> 46:39.840
这里边我要干嘛呢

46:39.840 --> 46:41.840
我要把你给我的数数呢

46:41.840 --> 46:42.840
来去判断数数

46:42.840 --> 46:44.840
把你给我的数数判断数数

46:44.840 --> 46:45.840
那么这边

46:45.840 --> 46:46.840
把这个椅子放过来

46:51.540 --> 46:52.540
那么怎么来判断

46:52.540 --> 46:53.540
它是不是数数呢

46:53.540 --> 46:54.540
我们看看这个

46:54.540 --> 46:55.540
刚刚这边的代码

46:55.540 --> 46:56.540
你看这边

46:56.540 --> 46:57.540
我们可以得到什么

46:57.540 --> 46:58.540
就得到这么一些信息

46:59.540 --> 47:00.540
这个线程里边

47:00.540 --> 47:01.540
是不是主线程

47:01.540 --> 47:02.540
我们这里不需要这个东西

47:02.540 --> 47:03.540
不需要这个信息

47:03.540 --> 47:04.540
那么要与副线程通信

47:04.540 --> 47:05.540
我们需要

47:05.540 --> 47:06.540
然后呢

47:06.540 --> 47:07.540
walker data

47:07.540 --> 47:08.540
就是副线程给我传过来的数据

47:08.540 --> 47:09.540
这个walker data

47:09.540 --> 47:10.540
就相当于是这个

47:10.540 --> 47:11.540
就相当于是这个

47:11.540 --> 47:12.540
给我传过来的数据

47:12.540 --> 47:13.540
副线程给我传过来的

47:14.540 --> 47:15.540
这是我们的线程ID

47:15.540 --> 47:16.540
那么我们比较说

47:16.540 --> 47:17.540
我们这里输出一下吧

47:17.540 --> 47:18.540
输出一下

47:20.540 --> 47:21.540
输出什么呢

47:21.540 --> 47:24.540
3的ID

47:24.540 --> 47:25.540
然后呢

47:25.540 --> 47:26.540
walker data

47:26.540 --> 47:28.980
你看一下吧

47:28.980 --> 47:32.180
loading

47:32.180 --> 47:33.180
这个是开启

47:34.180 --> 47:35.180
你看

47:35.180 --> 47:37.180
现在有多少个线程

47:37.180 --> 47:38.180
有

47:38.180 --> 47:39.180
这是线程ID

47:39.180 --> 47:40.180
ID它是自动给你分配的

47:40.180 --> 47:41.180
你不用管

47:41.180 --> 47:45.180
2 3 4 6 7 9 10 12

47:45.180 --> 47:48.180
1 5 8 11

47:48.180 --> 47:50.180
那么这里呢

47:50.180 --> 47:51.180
这是一个线程的ID

47:51.180 --> 47:52.180
然后呢

47:52.180 --> 47:53.180
这个是它的数据

47:53.180 --> 47:54.180
线程3

47:54.180 --> 47:56.180
它处理这一部分的数据

47:56.180 --> 47:57.180
对吧

47:57.180 --> 47:58.180
每个线程是不是把这个代码

47:58.180 --> 47:59.180
重新运行一遍

47:59.180 --> 48:00.180
每个线程运行一遍

48:00.180 --> 48:01.180
每个线程运行一遍

48:01.180 --> 48:02.180
就这么个意思

48:02.180 --> 48:03.180
好 来吧

48:03.180 --> 48:04.180
我们现在呢

48:04.180 --> 48:05.180
我们给它线程取个名字吧

48:05.180 --> 48:06.180
线程的名字

48:06.180 --> 48:07.180
又等于什么呢

48:07.180 --> 48:11.670
都等于sreadID

48:11.670 --> 48:14.670
就是线程这么多

48:14.670 --> 48:15.670
sreadID

48:15.670 --> 48:16.670
还加上这个

48:16.670 --> 48:17.670
好

48:17.670 --> 48:19.670
然后我们这里干嘛呢

48:19.670 --> 48:20.670
就是刚才的代码

48:20.670 --> 48:21.670
把代码拿过来

48:21.670 --> 48:22.670
就是这个代码

48:26.520 --> 48:28.520
判断是不是输出

48:28.520 --> 48:29.520
我得到一个变

48:29.520 --> 48:30.520
用一个变量

48:30.520 --> 48:31.520
循环这个

48:31.520 --> 48:32.520
循环这个workdata

48:32.520 --> 48:33.520
然后呢

48:33.520 --> 48:34.520
每循环一次呢

48:34.520 --> 48:35.520
判一判那个数字

48:35.520 --> 48:36.520
n是不是输出

48:36.520 --> 48:37.520
4的话我就把它

48:37.520 --> 48:38.520
加到新输组里边去

48:38.520 --> 48:39.520
加完了过后

48:39.520 --> 48:40.520
加完了过后

48:40.520 --> 48:41.520
我们就输出一个结果

48:41.520 --> 48:42.520
一个线程处理完成了

48:42.520 --> 48:44.520
就是这个name

48:45.520 --> 48:47.520
处理完成

48:49.520 --> 48:52.520
并把结果给予了

48:52.520 --> 48:53.520
主线程

48:53.520 --> 48:54.520
好 怎么来给呢

48:54.520 --> 48:56.520
我们就可以用parentPort

48:56.520 --> 48:58.520
向副线程发动消息

48:58.520 --> 48:59.520
sendmessage

49:01.520 --> 49:02.520
把这个消息

49:02.520 --> 49:03.520
什么消息呢

49:03.520 --> 49:04.520
就是个新的输出

49:04.520 --> 49:05.520
发送给副线程

49:05.520 --> 49:06.520
现在就处理完了

49:06.520 --> 49:07.520
就这样处理

49:07.520 --> 49:08.520
然后主线程那边就汇总

49:08.520 --> 49:09.520
发这个消息过来

49:09.520 --> 49:10.520
我就把消息

49:10.520 --> 49:11.520
放到新输组里边去

49:11.520 --> 49:12.520
然后呢

49:12.520 --> 49:13.520
如果说

49:13.520 --> 49:14.520
所有线程都处理结束

49:14.520 --> 49:15.520
我就输出最终结果

49:15.520 --> 49:16.520
我们来看一下

49:16.520 --> 49:17.520
这种模式

49:17.520 --> 49:18.520
它的处理时间是多少

49:22.470 --> 49:23.470
1.685秒

49:23.470 --> 49:25.470
是不是要快得多

49:25.470 --> 49:26.470
对不对

49:26.470 --> 49:27.470
是不是要快得多

49:27.470 --> 49:28.470
因为我们把这些

49:28.470 --> 49:30.470
计算密集性的操作

49:30.470 --> 49:31.470
分配给了

49:31.470 --> 49:32.470
这样的线程

49:32.470 --> 49:33.470
他们可以同步运行

49:33.470 --> 49:34.470
是不是快得多了

49:34.470 --> 49:35.470
这就是

49:35.470 --> 49:37.470
这种处理模式

49:38.470 --> 49:39.470
好 那么单式

49:39.470 --> 49:40.470
你要知道

49:40.470 --> 49:41.470
我就像我刚才说的

49:41.470 --> 49:42.470
线程不能开多了

49:42.470 --> 49:43.470
开多了

49:43.470 --> 49:45.470
可能效率反而降低了

49:45.470 --> 49:46.470
比方说我这里

49:46.470 --> 49:47.470
开了线程

49:47.470 --> 49:48.470
刚才是CPU的数量

49:48.470 --> 49:50.470
最好就是CPU的数量

49:50.470 --> 49:51.470
如果说我这个CPU的数量

49:51.470 --> 49:53.470
我这里不是用这种方式

49:53.470 --> 49:54.470
我开了1000个线程

49:54.470 --> 49:55.470
1000个数字

49:55.470 --> 49:56.470
开一个1000个线程

49:56.470 --> 50:01.340
你看会怎么样

50:01.340 --> 50:02.340
不忍心看了

50:02.340 --> 50:04.340
我已经不忍心看了

50:04.340 --> 50:06.980
不看了

50:06.980 --> 50:07.980
不看了

50:07.980 --> 50:09.980
已经变得非常非常夸张了

50:09.980 --> 50:10.980
已经非常夸张了

50:10.980 --> 50:11.980
不要去这么干

50:11.980 --> 50:12.980
不要说开100个

50:12.980 --> 50:14.980
100个再体验一下

50:14.980 --> 50:20.080
变成2秒多

50:20.080 --> 50:22.080
还是比单线程处理快

50:22.080 --> 50:23.080
但是肯定是没有

50:23.080 --> 50:25.080
没有刚才的更好

50:25.080 --> 50:26.080
刚才的更好

50:26.080 --> 50:27.080
不要开多了

50:27.080 --> 50:28.080
线程就是CPU的数量

50:28.080 --> 50:29.080
是最好的

50:29.080 --> 50:31.080
而且这个好处是

50:31.080 --> 50:33.080
以CPU计算的密集性

50:33.080 --> 50:34.080
越高

50:34.080 --> 50:35.080
就是计算的量越大

50:35.080 --> 50:37.080
开线程的好处越大

50:37.080 --> 50:38.080
原来的意思

50:38.080 --> 50:38.580
这是

50:38.580 --> 50:39.080
但是呢

50:39.080 --> 50:40.080
现阶段的为什么说

50:40.080 --> 50:41.080
线程里面不太用得到了

50:41.080 --> 50:42.080
因为绝大部分

50:42.080 --> 50:44.080
操作密集型的东西

50:44.080 --> 50:46.080
一般不会让领导的解释来做

50:46.080 --> 50:47.080
一般就是后端

50:47.080 --> 50:49.080
什么加碼

50:49.080 --> 50:50.080
拍摄

50:50.080 --> 50:51.080
这就给你做了

50:51.080 --> 50:52.080
一般不用做

50:52.080 --> 50:53.080
所以说线程的

50:53.080 --> 50:54.080
你们一般来说都用不到

50:54.080 --> 50:56.080
线程和进程我就讲到这

