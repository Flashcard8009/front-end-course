WEBVTT

00:01.010 --> 00:04.810
咱们这节课来讲这个单表基本查询

00:04.810 --> 00:08.610
我们查询语剧是我们卖社会里面学习的重点

00:08.610 --> 00:09.810
重中之重

00:09.810 --> 00:12.410
因为我们以后如果说要用到数据库的话

00:12.410 --> 00:14.010
查询语剧是占绝大部分的

00:14.010 --> 00:15.610
当然还包括争产感语剧

00:15.610 --> 00:17.810
争产感语剧的它出现的频率也比较高

00:17.810 --> 00:20.410
但是没有查询语剧的出现频率高

00:20.410 --> 00:22.210
所以查询语剧一定要好好学

00:22.210 --> 00:24.410
我们这几页课都要占查询语剧

00:24.410 --> 00:26.210
而最重要的就是基本查询

00:26.210 --> 00:28.410
因为我们平时用的最多的也就是基本查询

00:29.410 --> 00:34.410
百分之八十的情况下都是用的是百分之二十的知识

00:34.410 --> 00:36.410
没有多复杂 很简单的

00:36.410 --> 00:38.410
而且你学了查询之后你会发现

00:38.410 --> 00:42.410
在数据库里面在社会语剧里面去做查询

00:42.410 --> 00:45.410
要比节词里面找书组在书组里面查询

00:45.410 --> 00:47.410
要强大几百倍

00:47.410 --> 00:49.410
强大到没必要了

00:49.410 --> 00:51.410
你把社会语剧的查询学会了过后

00:51.410 --> 00:54.410
你真的很多时候不像在书组里面去做查询了

00:54.410 --> 00:56.410
只要数据库能够做查询的话

00:57.410 --> 00:59.410
咱们来看一下

00:59.410 --> 01:01.410
我们这些课学的是单表基本查询

01:01.410 --> 01:03.410
就是只查一张表

01:03.410 --> 01:05.410
在一张表里面去做查询

01:05.410 --> 01:06.410
那么怎么来做呢

01:06.410 --> 01:07.410
我们来看一下

01:07.410 --> 01:09.410
基本的语法是这样子

01:09.410 --> 01:10.410
咱们学习之前

01:10.410 --> 01:11.410
我们还是把数据库加上吧

01:11.410 --> 01:13.410
因为我们之前的数据库太搞笑了

01:13.410 --> 01:15.410
没有什么多少数据

01:15.410 --> 01:17.410
也不方便来做测试

01:17.410 --> 01:22.410
最好我给大家准备了这么一个数据库

01:22.410 --> 01:24.410
你把这个复制到桌面上

01:24.410 --> 01:26.410
准备上我已经复制过来了

01:26.410 --> 01:28.410
那么我们这里直接新建一个数据库

01:30.410 --> 01:31.410
跟名字随便去

01:31.410 --> 01:32.410
名字随便去什么都可以

01:32.410 --> 01:33.410
亢不得低比吧

01:33.410 --> 01:34.410
我们用同样的名字

01:34.410 --> 01:35.410
然后打开这个数据库

01:35.410 --> 01:38.410
然后点击右键运行搜口文件

01:38.410 --> 01:40.410
这里我们选择

01:40.410 --> 01:42.410
搜口点击开始

01:42.410 --> 01:43.410
OK关闭

01:43.410 --> 01:45.410
现在我们可以看到右键刷新

01:45.410 --> 01:46.410
就表就出来了

01:46.410 --> 01:47.410
对不对

01:47.410 --> 01:48.410
表示不出来了

01:49.410 --> 01:50.410
我们排列一下吧

01:52.410 --> 01:53.410
不自动帮我排列

01:53.410 --> 01:54.410
那行吧

01:54.410 --> 01:55.410
那就这样吧

01:57.410 --> 01:59.410
现在我们表就这个样子

01:59.410 --> 02:01.410
他能不能自己帮我们排列一下

02:01.410 --> 02:05.620
好像不行

02:05.620 --> 02:06.620
OK

02:06.620 --> 02:07.620
算了吧

02:07.620 --> 02:08.620
就这样吧

02:08.620 --> 02:10.620
那么现在我们表结构就是这个样子

02:10.620 --> 02:12.620
这样子的一种表结构

02:12.620 --> 02:13.620
太臭了

02:13.620 --> 02:15.620
真的是太臭了

02:16.620 --> 02:17.620
我们来看一下

02:17.620 --> 02:19.620
这里面一共有四张表

02:19.620 --> 02:21.620
其中一张表是比较独立的

02:21.620 --> 02:22.620
它跟其他表都没有关系

02:22.620 --> 02:23.620
这张表我们是用户表

02:23.620 --> 02:26.620
主要是用来做一些简单的测试

02:26.620 --> 02:27.620
这个用户表

02:27.620 --> 02:28.620
它里面记录了什么

02:28.620 --> 02:29.620
就是我们登录的用户

02:29.620 --> 02:31.620
要进这个系统管理的话

02:31.620 --> 02:32.620
要登录一些用户

02:32.620 --> 02:33.620
那么这个用户

02:33.620 --> 02:34.620
我们这里有三个

02:34.620 --> 02:35.620
我随便写了三个

02:35.620 --> 02:36.620
耳朵密码

02:36.620 --> 02:37.620
账号密码

02:37.620 --> 02:38.620
账号密码

02:38.620 --> 02:39.620
对吧

02:39.620 --> 02:40.620
我们写了三个用户

02:40.620 --> 02:41.620
这个表很简单

02:42.620 --> 02:43.620
ID都是自认的

02:43.620 --> 02:44.620
然后接下来我们看一下

02:44.620 --> 02:45.620
这三张表

02:45.620 --> 02:46.620
首先我们看这个

02:46.620 --> 02:48.620
complete这个表

02:48.620 --> 02:50.620
这个表叫做公司表

02:50.620 --> 02:52.620
我们后面这几和都会

02:52.620 --> 02:53.620
用这几张表来做

02:53.620 --> 02:55.620
所以大家一定要把导入进去

02:55.620 --> 02:56.620
这是公司表

02:56.620 --> 02:57.620
公司表的话

02:57.620 --> 02:58.620
它记录了我们

02:58.620 --> 02:59.620
数据库里边有哪些公司

02:59.620 --> 03:00.620
保留到哪些公司

03:00.620 --> 03:01.620
我们来看一下

03:01.620 --> 03:02.620
这里有三个公司

03:02.620 --> 03:03.620
有三个公司

03:05.620 --> 03:06.620
公司的名称

03:06.620 --> 03:07.620
公司的地址

03:07.620 --> 03:08.620
公司的创建时间

03:08.620 --> 03:09.620
这里是随便写写的

03:09.620 --> 03:10.620
主要是用来做测试的

03:10.620 --> 03:12.620
另外一个是部门表

03:12.620 --> 03:15.620
部门表里边有部门的名称

03:15.620 --> 03:16.620
公司的ID

03:16.620 --> 03:17.620
这个是个外件

03:17.620 --> 03:18.620
这是一个外件

03:18.620 --> 03:19.620
公司的ID连接到

03:19.620 --> 03:21.620
部门里边有个公司的ID

03:21.620 --> 03:22.620
表示这个部门

03:22.620 --> 03:23.620
是属于哪个公司的

03:23.620 --> 03:24.620
一对多关系

03:25.620 --> 03:27.620
这里是部门的创建时间

03:27.620 --> 03:28.620
我这个名字小意思写错了

03:28.620 --> 03:29.620
你们把我改一下

03:29.620 --> 03:31.620
这个叫做Build date

03:36.620 --> 03:38.620
这个是有一个外件

03:38.620 --> 03:40.620
Complete ID连接到公司的ID

03:40.620 --> 03:42.620
这个是部门的创建时间

03:42.620 --> 03:43.620
我们看一下部门表

03:43.620 --> 03:44.620
你看这几个部门

03:44.620 --> 03:48.620
是不是ID为一的公司的

03:48.620 --> 03:50.620
这几个部门是ID为二的公司的

03:50.620 --> 03:52.620
这几个部门是ID为三的公司的

03:52.620 --> 03:54.620
这是部门表

03:54.620 --> 03:56.620
还有一个表就是员工表

03:56.620 --> 03:58.620
员工是属于哪个部门的

03:58.620 --> 03:59.620
一个说员工

03:59.620 --> 04:00.620
为什么跟公司没有关系呢

04:00.620 --> 04:02.620
因为部门跟公司有关系

04:02.620 --> 04:03.620
是不是间接关联了

04:03.620 --> 04:05.620
员工是属于哪个部门的

04:05.620 --> 04:06.620
员工的名字

04:06.620 --> 04:07.620
我们再打开看吧

04:07.620 --> 04:08.620
ID都是自尊的

04:08.620 --> 04:09.620
员工的姓名

04:09.620 --> 04:10.620
员工的住址

04:10.620 --> 04:12.620
员工的姓别

04:12.620 --> 04:13.620
我都用的是Ismail

04:13.620 --> 04:14.620
是不是男的

04:14.620 --> 04:15.620
1就是男

04:15.620 --> 04:16.620
1就是男

04:16.620 --> 04:17.620
0就是女

04:17.620 --> 04:18.620
这是姓别

04:18.620 --> 04:19.620
这是员工加入公司的日期

04:19.620 --> 04:21.620
这是员工的薪水

04:21.620 --> 04:23.620
这是员工的部门ID

04:23.620 --> 04:24.620
这是个外建

04:24.620 --> 04:25.620
连接到部门表

04:25.620 --> 04:27.620
这里是员工的生日

04:27.620 --> 04:29.620
这就是员工表

04:29.620 --> 04:31.620
一共有这么几张表格

04:31.620 --> 04:32.620
非常简单

04:32.620 --> 04:33.620
接下来我们来做查询

04:33.620 --> 04:35.620
主要是来查它里面的数据

04:35.620 --> 04:37.990
怎么来查

04:37.990 --> 04:38.990
来吧

04:38.990 --> 04:39.990
我们这里

04:39.990 --> 04:41.990
这节课会写很多的社科语句

04:41.990 --> 04:44.990
基本的查询的语句就是这样子

04:44.990 --> 04:46.990
咱们来首先来说一下

04:46.990 --> 04:48.990
这两个

04:48.990 --> 04:49.990
这两个是在怎么做查询

04:49.990 --> 04:50.990
其实特别简单

04:50.990 --> 04:52.990
比方说我们这里写一个

04:53.990 --> 04:54.990
这里写一个ID

04:54.990 --> 04:56.990
from user

04:56.990 --> 04:57.990
这什么意思呢

04:57.990 --> 04:58.990
这是指的是

04:58.990 --> 05:00.990
从user表里边

05:00.990 --> 05:02.990
把数据ID查出来

05:02.990 --> 05:03.990
我们来运行看一下

05:03.990 --> 05:06.990
你看是不是出来一列ID

05:06.990 --> 05:07.990
这一列就是ID

05:07.990 --> 05:09.990
那么把用户表里的数据查出来了

05:09.990 --> 05:11.990
你看用户表里边的数据

05:11.990 --> 05:12.990
是不是这个

05:12.990 --> 05:13.990
它到底是怎么查的呢

05:13.990 --> 05:15.990
它是这样子的

05:15.990 --> 05:17.990
你from后边跟的是数据员

05:17.990 --> 05:18.990
就从哪里去查

05:19.990 --> 05:21.990
from后面跟的东西是非常丰富的

05:21.990 --> 05:22.990
写法非常丰富

05:22.990 --> 05:23.990
不过我们这节课

05:23.990 --> 05:24.990
就直接写一张表就行了

05:24.990 --> 05:25.990
单表嘛

05:25.990 --> 05:26.990
单表基本查去

05:26.990 --> 05:27.990
所以我们直接写一张表就行了

05:27.990 --> 05:29.990
这里边写法很多的

05:29.990 --> 05:31.990
这里边我们写了一个用户表

05:31.990 --> 05:32.990
对不对

05:32.990 --> 05:33.990
那么它会怎么查呢

05:33.990 --> 05:35.990
它会把用户表读出来

05:35.990 --> 05:37.990
这是我们存在硬盘上的

05:37.990 --> 05:39.990
就存在硬盘上

05:39.990 --> 05:41.990
磁盘上的永久存出的一些数据

05:41.990 --> 05:43.990
它会把它查到内存里边

05:43.990 --> 05:45.990
这些东西都在内存里边

05:46.990 --> 05:48.990
这个东西是原始表

05:48.990 --> 05:49.990
叫物理表

05:49.990 --> 05:50.990
这个东西叫做

05:50.990 --> 05:51.990
结果表

05:51.990 --> 05:52.990
结果表在内存

05:52.990 --> 05:54.990
物理表在硬盘

05:56.990 --> 05:57.990
那怎么来查的呢

05:57.990 --> 05:58.990
它是这样子

05:58.990 --> 06:00.990
它把这个表从物理表中读

06:00.990 --> 06:02.990
它从第一行开始读

06:02.990 --> 06:03.990
第一行拿出来过后

06:03.990 --> 06:05.990
那么看一下是那个程里边

06:05.990 --> 06:07.990
你要读哪一列呢

06:07.990 --> 06:08.990
读id这一列

06:08.990 --> 06:10.990
所以说它把第一行的id

06:10.990 --> 06:11.990
放到结果表中

06:11.990 --> 06:12.990
生成一列

06:12.990 --> 06:13.990
名字叫id

06:13.990 --> 06:15.990
把这个e放到结果表中

06:15.990 --> 06:16.990
是不是就出来这么一个东西

06:16.990 --> 06:17.990
第一行就出来了

06:17.990 --> 06:18.990
结果表的第一行就出来了

06:18.990 --> 06:20.990
然后再把u的表的

06:20.990 --> 06:21.990
第二行拿出来

06:21.990 --> 06:22.990
你要查什么呢

06:22.990 --> 06:23.990
查id这一列

06:23.990 --> 06:24.990
把第二行这个东西

06:24.990 --> 06:25.990
结果表就出来了

06:25.990 --> 06:27.990
然后第三行是不是一次内推

06:27.990 --> 06:28.990
原来的意思吧

06:28.990 --> 06:29.990
首先搞清楚

06:29.990 --> 06:31.990
这是个结果表

06:31.990 --> 06:33.990
这个是物理表

06:33.990 --> 06:34.990
两个是不一样的

06:34.990 --> 06:36.990
我们结果表来自于物理表

06:36.990 --> 06:38.990
如果说你要查多列了

06:38.990 --> 06:39.990
怎么办呢

06:39.990 --> 06:40.990
多列

06:40.990 --> 06:41.990
这里我们比方说

06:41.990 --> 06:43.990
查的是还有个login id

06:44.990 --> 06:45.990
印象

06:45.990 --> 06:46.990
你看是不是查出来两列

06:46.990 --> 06:47.990
对吧

06:47.990 --> 06:48.990
查出来两列

06:48.990 --> 06:49.990
你要查三列怎么办呢

06:49.990 --> 06:51.990
login password

06:51.990 --> 06:53.990
是不是查出来三列

06:53.990 --> 06:55.990
那你要查四列怎么办呢

06:55.990 --> 06:57.990
你要看第四列你要查啥

06:57.990 --> 06:59.990
比方说就查一个长量

06:59.990 --> 07:01.990
第四列的值就是123

07:01.990 --> 07:02.990
可不可以呢

07:02.990 --> 07:03.990
当然可以

07:03.990 --> 07:05.990
你看第四列的值是不是就123

07:05.990 --> 07:06.990
比起它的列名

07:06.990 --> 07:07.990
也是自动的是123

07:07.990 --> 07:08.990
对吧

07:08.990 --> 07:09.990
就你要查多少列

07:09.990 --> 07:10.990
无所谓的

07:10.990 --> 07:11.990
ABC

07:13.990 --> 07:14.990
对吧

07:14.990 --> 07:15.990
这就生存到结果的一个

07:15.990 --> 07:16.990
那么它怎么查的

07:16.990 --> 07:18.990
把有的的第一行拿出来

07:18.990 --> 07:19.990
第一行拿出来

07:19.990 --> 07:21.990
id放到结果的第一行

07:21.990 --> 07:23.990
login id

07:23.990 --> 07:24.990
放到结果的第一行

07:24.990 --> 07:25.990
login password

07:25.990 --> 07:26.990
放到结果的第一行

07:26.990 --> 07:27.990
abc

07:27.990 --> 07:28.990
放到结果的

07:28.990 --> 07:30.990
第一行的第四列

07:30.990 --> 07:31.990
对吧

07:31.990 --> 07:32.990
它就这样查的

07:32.990 --> 07:34.990
这是这种最简单的查询

07:34.990 --> 07:36.990
那么在我们使用

07:36.990 --> 07:37.990
三列车的时候

07:37.990 --> 07:39.990
我们还可以给它定一些别名

07:39.990 --> 07:40.990
我们看一下是那个车的

07:40.990 --> 07:41.990
一些其他用法

07:41.990 --> 07:42.990
定别名

07:42.990 --> 07:44.990
定别名是什么意思呢

07:46.990 --> 07:47.990
看一下

07:47.990 --> 07:48.990
是那个车定别名

07:48.990 --> 07:49.990
比方说吧

07:49.990 --> 07:52.990
我们查这个表

07:52.990 --> 07:54.990
查这个用户这个表

07:54.990 --> 07:55.990
用户这个表

07:55.990 --> 07:57.990
不是 查员工那个表

07:57.990 --> 07:58.990
我们查什么了

07:58.990 --> 07:59.990
查ease mail

07:59.990 --> 08:00.990
它的性别

08:00.990 --> 08:01.990
from

08:01.990 --> 08:02.990
员工

08:02.990 --> 08:04.990
employee

08:04.990 --> 08:05.990
咱们来看一下

08:05.990 --> 08:08.370
这个查询

08:08.370 --> 08:10.370
你看 是不是只查出来一列

08:10.370 --> 08:11.370
那么这一列

08:11.370 --> 08:13.370
如果说我想把跟列名改一下

08:13.370 --> 08:14.370
怎么改呢

08:14.370 --> 08:15.370
有两种方式

08:15.370 --> 08:16.370
第一种方式就是用ease

08:16.370 --> 08:18.370
ease后边写上列的名称

08:18.370 --> 08:19.370
列的名称我们写个啥呢

08:19.370 --> 08:20.370
随便写个啥

08:20.370 --> 08:21.370
比方说性别

08:21.370 --> 08:22.370
我们还可以写中文

08:22.370 --> 08:24.370
一般不会写中文

08:24.370 --> 08:26.370
你看 是不是变成性别了

08:26.370 --> 08:27.370
对不对

08:27.370 --> 08:28.370
它也可以把它变成一个字部串

08:28.370 --> 08:29.370
都行

08:31.370 --> 08:32.370
性别

08:32.370 --> 08:34.370
是一样的效果

08:35.370 --> 08:36.370
你看 是不是一样

08:36.370 --> 08:37.370
第二种邪法

08:37.370 --> 08:38.370
就是可以省略这个ease

08:38.370 --> 08:39.370
它也能认识

08:39.370 --> 08:41.370
你看 是不是也是一样

08:41.370 --> 08:42.370
对不对

08:42.370 --> 08:43.370
都可以

08:43.370 --> 08:44.370
这是定别名

08:44.370 --> 08:45.370
那么一看

08:45.370 --> 08:46.370
刚才这个abc

08:46.370 --> 08:47.370
我们可以定别名

08:47.370 --> 08:48.370
二字

08:48.370 --> 08:50.370
页外的一列

08:51.370 --> 08:53.370
你看 这个查询出来

08:53.370 --> 08:54.370
是不是

08:54.370 --> 08:55.370
也可以定别名

08:55.370 --> 08:56.370
对不对

08:56.370 --> 08:57.370
非常非常简单

08:57.370 --> 08:58.370
这是定别名

08:58.370 --> 08:59.370
还有另外一种用法

08:59.370 --> 09:00.370
就是snext

09:00.370 --> 09:01.370
后面还可以跟新号

09:01.370 --> 09:03.370
新号表示查询所有列

09:03.370 --> 09:04.370
咱们来看一下

09:04.370 --> 09:05.370
snext

09:05.370 --> 09:06.370
新号

09:06.370 --> 09:07.370
from

09:07.370 --> 09:09.370
这里的邪法都不是很

09:09.370 --> 09:10.370
都不是很标准

09:10.370 --> 09:11.370
要么全部大邪

09:11.370 --> 09:12.370
要么全部小邪

09:12.370 --> 09:13.370
一会大邪

09:13.370 --> 09:14.370
一会小邪

09:14.370 --> 09:15.370
我们这搜刻就不晚了

09:15.370 --> 09:16.370
你们懂得就行了

09:16.370 --> 09:17.370
Inploy

09:18.370 --> 09:19.370
其实你可以点这个美化

09:19.370 --> 09:20.370
如果美化它过去

09:20.370 --> 09:21.370
你换房

09:21.370 --> 09:22.370
看上去更加不好看

09:22.370 --> 09:23.370
难得美化了

09:23.370 --> 09:24.370
它个美化

09:24.370 --> 09:25.370
我不是很喜欢

09:26.370 --> 09:27.370
from employee

09:27.370 --> 09:28.370
这样子

09:28.370 --> 09:29.370
我们就查询出

09:29.370 --> 09:31.370
这个表里边的所有列

09:31.370 --> 09:32.370
你看新号就表示

09:32.370 --> 09:33.370
匹配这个表里边

09:33.370 --> 09:35.370
数据元里边的所有列

09:35.370 --> 09:36.370
匹配这个数据元里边的所有列

09:36.370 --> 09:37.370
没有的意思

09:37.370 --> 09:39.370
当然你可以在这个基础上

09:39.370 --> 09:40.370
进一步增加

09:40.370 --> 09:41.370
进一步增加一列

09:41.370 --> 09:44.370
比方说增加abc

09:44.370 --> 09:45.370
随便增加一列

09:45.370 --> 09:46.370
你看看

09:46.370 --> 09:48.370
这样子它就多出了一列abc

09:48.370 --> 09:51.370
当然也可以给这个abc定别名

09:51.370 --> 09:52.370
extra

09:52.370 --> 09:53.370
而外的一列

09:53.370 --> 09:54.370
对不对

09:54.370 --> 09:56.370
咱们来看一下

09:56.370 --> 09:57.370
就去查出来

09:57.370 --> 09:58.370
对吧

09:58.370 --> 09:59.370
那么这里也是

09:59.370 --> 10:00.370
这种

10:00.370 --> 10:02.370
这里的这种邪法

10:03.370 --> 10:05.370
我们把这个东西保存一下

10:05.370 --> 10:06.370
保存到那个

10:06.370 --> 10:08.370
就是查询语句里边

10:08.370 --> 10:09.370
是那个字

10:12.680 --> 10:13.680
是那个字from

10:14.680 --> 10:15.680
我们讲一下

10:15.680 --> 10:17.680
简单的是那个字from的用法

10:17.680 --> 10:18.680
把放这

10:19.680 --> 10:20.680
去掉

10:20.680 --> 10:21.680
好 接下来

10:21.680 --> 10:22.680
我们来看一下

10:22.680 --> 10:23.680
这个查询

10:23.680 --> 10:24.680
test

10:24.680 --> 10:25.680
这是什么呢

10:25.680 --> 10:27.680
这是对某一列的数据

10:27.680 --> 10:29.680
进行进一步处理

10:29.680 --> 10:30.680
什么意思呢

10:30.680 --> 10:31.680
比方说

10:31.680 --> 10:33.680
咱们查的是exmail这一列

10:33.680 --> 10:34.680
比方说查id

10:34.680 --> 10:35.680
查name

10:36.680 --> 10:37.680
跟关键字重复了

10:37.680 --> 10:38.680
对吧

10:38.680 --> 10:39.680
我们把那个用个对象名

10:39.680 --> 10:40.680
把包起来

10:40.680 --> 10:42.680
然后查exmail

10:42.680 --> 10:43.680
然后还要查什么

10:43.680 --> 10:45.680
查sinary

10:47.680 --> 10:48.680
查这一列

10:48.680 --> 10:49.680
from

10:50.680 --> 10:51.680
查哪张表呢

10:51.680 --> 10:53.680
查imploid的张表

10:53.680 --> 10:54.680
咱们来查询

10:54.680 --> 10:55.680
是不是只查出来4列

10:55.680 --> 10:56.680
那么接下来

10:56.680 --> 10:58.680
我们要单独来处理一下

10:58.680 --> 10:59.680
这一列

10:59.680 --> 11:00.680
exmail这一列

11:00.680 --> 11:01.680
exmail这一列的

11:01.680 --> 11:03.680
首先我要把它

11:03.680 --> 11:04.680
改成男和女

11:04.680 --> 11:05.680
不想显示一和零

11:05.680 --> 11:06.680
对吧

11:06.680 --> 11:08.680
一和零是物理表里面存出的数据

11:08.680 --> 11:09.680
那么

11:09.680 --> 11:10.680
因为物理表的话

11:10.680 --> 11:12.680
要尽量的减少存出空间

11:12.680 --> 11:13.680
对吧

11:13.680 --> 11:14.680
所以说用的是配置

11:14.680 --> 11:15.680
但是我们在查询结果里

11:15.680 --> 11:16.680
不想用这个东西了

11:16.680 --> 11:17.680
查询结果里

11:17.680 --> 11:18.680
我想用男和女

11:18.680 --> 11:20.680
那这个东西怎么办呢

11:20.680 --> 11:21.680
怎么办呢

11:21.680 --> 11:22.680
我们就可以用case和win

11:22.680 --> 11:23.680
case指据

11:23.680 --> 11:24.680
怎么要case指据呢

11:24.680 --> 11:25.680
你看着

11:25.680 --> 11:27.680
case

11:27.680 --> 11:29.680
后边写上

11:29.680 --> 11:30.680
后边写上就是

11:30.680 --> 11:32.680
你要匹配的数据

11:32.680 --> 11:34.680
比如说这里有两种写法

11:34.680 --> 11:36.680
一种是直接写上匹配的数据

11:36.680 --> 11:37.680
exmail

11:37.680 --> 11:38.680
我要匹配exmail

11:38.680 --> 11:40.680
这一列的数据

11:40.680 --> 11:41.680
那么匹配的时候

11:41.680 --> 11:43.680
我要根据它不同的情况来说

11:43.680 --> 11:44.680
不同的显示

11:44.680 --> 11:46.680
那么如果说我case写完了

11:46.680 --> 11:48.680
一定要加上一个and

11:48.680 --> 11:49.680
一定要加上一个and

11:49.680 --> 11:51.680
表示我这个case写完了

11:51.680 --> 11:52.680
那么中间写什么呢

11:52.680 --> 11:53.680
中间写上是win

11:53.680 --> 11:54.680
当什么的时候

11:54.680 --> 11:55.680
当它等于1的时候

11:55.680 --> 11:57.680
我就zin

11:57.680 --> 11:58.680
zin

11:58.680 --> 12:00.680
我就输出男

12:00.680 --> 12:01.680
ls

12:01.680 --> 12:03.680
我就输出女

12:03.680 --> 12:04.680
就这么简单

12:04.680 --> 12:05.680
你看一下这个逻辑

12:05.680 --> 12:07.680
这是这一列的数据

12:07.680 --> 12:09.680
那么我们来运行看一下

12:09.680 --> 12:10.680
运行

12:10.680 --> 12:12.680
你看是不是输出了男和女

12:12.680 --> 12:14.680
但是它的列名

12:14.680 --> 12:15.680
是不是变成这个玩意了

12:15.680 --> 12:16.680
列名变成我们那个

12:16.680 --> 12:18.680
就这里写的列名了

12:18.680 --> 12:19.680
这是我们不喜欢看到的

12:19.680 --> 12:20.680
我们可以给它重新定个名字

12:20.680 --> 12:21.680
二字

12:21.680 --> 12:22.680
或者是直接写

12:22.680 --> 12:23.680
就是sex

12:23.680 --> 12:25.680
给它重新定一个列的名字

12:25.680 --> 12:27.680
都特别特别简单

12:27.680 --> 12:28.680
你看社科语句

12:28.680 --> 12:30.680
写得起来特别简单的

12:30.680 --> 12:31.680
等问题吧

12:31.680 --> 12:32.680
好了

12:32.680 --> 12:33.680
它怎么查的还是一样

12:33.680 --> 12:34.680
把物理表的数据拿出来

12:34.680 --> 12:36.680
拿出它第一行

12:36.680 --> 12:37.680
employee

12:37.680 --> 12:39.680
拿出它第一行

12:39.680 --> 12:40.680
第一行要查什么呢

12:40.680 --> 12:41.680
id

12:41.680 --> 12:42.680
id放这儿了

12:42.680 --> 12:43.680
然后查name

12:43.680 --> 12:44.680
name放这儿了

12:44.680 --> 12:46.680
然后查这一列

12:46.680 --> 12:47.680
这一列的列名是sex

12:47.680 --> 12:48.680
然后查这一列怎么查的呢

12:48.680 --> 12:50.680
它会把这一行的

12:50.680 --> 12:51.680
把这一行的意思

12:51.680 --> 12:52.680
没有拿出来

12:52.680 --> 12:53.680
拿出来过后

12:53.680 --> 12:54.680
跟1来比较

12:54.680 --> 12:55.680
是不是相等的

12:55.680 --> 12:56.680
如果相等的话

12:56.680 --> 12:57.680
设置为男

12:57.680 --> 12:58.680
那么就输出男

12:58.680 --> 12:59.680
如果说不相等的话

12:59.680 --> 13:00.680
就输出为女

13:00.680 --> 13:01.680
只有1和0

13:01.680 --> 13:02.680
两种情况

13:02.680 --> 13:03.680
就输出为女

13:03.680 --> 13:04.680
这就把第一行搞定了

13:04.680 --> 13:05.680
后边是sylery

13:05.680 --> 13:06.680
把第一行搞定了

13:06.680 --> 13:08.680
第二行也是一样

13:08.680 --> 13:09.680
第二行是不是

13:09.680 --> 13:10.680
也是一样的做法

13:10.680 --> 13:11.680
id拿出来

13:11.680 --> 13:12.680
name拿出来

13:12.680 --> 13:13.680
意思没有来比较

13:13.680 --> 13:14.680
这是这种写法

13:14.680 --> 13:15.680
好

13:15.680 --> 13:16.680
当然

13:16.680 --> 13:17.680
保存一下

13:20.680 --> 13:21.680
当然

13:21.680 --> 13:22.680
还有这种写法

13:22.680 --> 13:23.680
还有这种写法

13:23.680 --> 13:24.680
就是case

13:24.680 --> 13:25.680
后边不写东西

13:25.680 --> 13:26.680
我们在这里比较

13:26.680 --> 13:27.680
意思没有

13:27.680 --> 13:28.680
等于1

13:28.680 --> 13:29.680
那么就输出男

13:29.680 --> 13:31.680
否则的话输出女

13:31.680 --> 13:33.680
这样子也可以

13:33.680 --> 13:34.680
运行

13:34.680 --> 13:35.680
是不是一样的效果

13:35.680 --> 13:36.680
意思没有等于1

13:36.680 --> 13:37.680
输出男

13:37.680 --> 13:38.680
否则的话输出女

13:38.680 --> 13:39.680
不在这里写的

13:39.680 --> 13:40.680
都可以

13:40.680 --> 13:42.680
他的写法很灵活的

13:42.680 --> 13:43.680
好

13:43.680 --> 13:44.680
那么除了这个意思没有之外

13:44.680 --> 13:45.680
那么我们sylery

13:45.680 --> 13:46.680
比方说也要这样干

13:46.680 --> 13:48.680
比方说我们把工资

13:48.680 --> 13:51.680
高于1万5的

13:51.680 --> 13:52.680
1万5的

13:52.680 --> 13:53.680
高于10k的

13:53.680 --> 13:56.680
高于10k的算是高工资

13:56.680 --> 13:57.680
那么低于10k的

13:57.680 --> 13:58.680
到5000

13:58.680 --> 13:59.680
就是5000到10k的

13:59.680 --> 14:00.680
5k到10k

14:00.680 --> 14:01.680
那么我们认为是中等工资

14:01.680 --> 14:02.680
那么5k一下

14:02.680 --> 14:03.680
我们认为低工资

14:03.680 --> 14:04.680
那么我们把工资

14:04.680 --> 14:05.680
分几个级别

14:05.680 --> 14:06.680
那么怎么来查呢

14:06.680 --> 14:07.680
怎么来查呢

14:07.680 --> 14:08.680
也是一样

14:08.680 --> 14:09.680
我们也可以用case

14:09.680 --> 14:10.680
case过后要记得写

14:10.680 --> 14:11.680
必须要写上的

14:11.680 --> 14:12.680
好

14:12.680 --> 14:16.180
我们这里写上dev

14:16.180 --> 14:17.180
打上一个对象名

14:17.180 --> 14:19.180
关键字重复来打对象名

14:19.180 --> 14:20.180
好

14:20.180 --> 14:21.180
那么这里边问

14:21.180 --> 14:22.180
当什么呢

14:22.180 --> 14:23.180
当sylery

14:23.180 --> 14:24.180
大于了多少呢

14:24.180 --> 14:26.180
大于等于了

14:26.180 --> 14:27.180
1万

14:27.180 --> 14:30.180
我们就认高工资

14:30.180 --> 14:32.180
然后我们还有一个lc

14:32.180 --> 14:33.180
对吧

14:33.180 --> 14:34.180
又来一个问

14:34.180 --> 14:35.180
当sylery

14:35.180 --> 14:37.180
大于等于了5000

14:37.180 --> 14:41.820
我们就认中等工资

14:41.820 --> 14:42.820
然后lc

14:42.820 --> 14:44.820
我们就是低工资

14:44.820 --> 14:45.820
比方说我们这样子写

14:45.820 --> 14:47.820
我们来运行一下

14:47.820 --> 14:48.820
是不是

14:48.820 --> 14:49.820
就高中低

14:49.820 --> 14:50.820
是不是就分别

14:50.820 --> 14:51.820
显示出来了

14:51.820 --> 14:52.820
就没有显示那个东西

14:52.820 --> 14:53.820
是不是把显示出来了

14:53.820 --> 14:54.820
当然你后边

14:54.820 --> 14:55.820
还可以跟上一个sylery

14:55.820 --> 14:56.820
把sylery

14:56.820 --> 14:57.820
进一步详细的信息

14:57.820 --> 14:58.820
又显示出来

14:58.820 --> 14:59.820
对吧

14:59.820 --> 15:00.820
这是非常灵活的

15:00.820 --> 15:01.820
运行

15:01.820 --> 15:02.820
你看是不是多了一个sylery

15:02.820 --> 15:03.820
你像这个东西

15:03.820 --> 15:04.820
查学是不是很屌

15:04.820 --> 15:05.820
对吧

15:05.820 --> 15:06.820
很厉害的这个查学

15:06.820 --> 15:07.820
好

15:07.820 --> 15:08.820
你看一下吧

15:08.820 --> 15:09.820
是不是就对应上了

15:09.820 --> 15:10.820
对吧

15:10.820 --> 15:11.820
那么这里的判断方式

15:11.820 --> 15:13.820
跟那个Else衣服是一样的

15:13.820 --> 15:14.820
先判断这个

15:14.820 --> 15:15.820
这个为止

15:15.820 --> 15:16.820
它就后面就不判断了

15:16.820 --> 15:17.820
它是一行一行进行判断的

15:17.820 --> 15:18.820
一行一行

15:18.820 --> 15:19.820
把一行的sylery

15:19.820 --> 15:20.820
拿出来进行判断

15:20.820 --> 15:21.820
判断成功了

15:21.820 --> 15:22.820
它就不光后面判断了

15:22.820 --> 15:23.820
如果第一个不成功

15:23.820 --> 15:24.820
那么就是第二个

15:24.820 --> 15:25.820
OK

15:25.820 --> 15:27.820
这是这一个

15:27.820 --> 15:29.820
这里的揭发

15:29.820 --> 15:31.820
这是那个sylerx

15:31.820 --> 15:32.820
和foran

15:32.820 --> 15:33.820
foran后面很简单

15:33.820 --> 15:34.820
foran后面呢

15:34.820 --> 15:35.820
我们跟的是什么

15:35.820 --> 15:36.820
跟的是那个表明

15:36.820 --> 15:37.820
实际上呢

15:37.820 --> 15:38.820
这里的foran后面

15:38.820 --> 15:39.820
还有很多种揭发

15:39.820 --> 15:41.820
咱们不过这一节课

15:41.820 --> 15:42.820
咱们只是跟一个表明

15:42.820 --> 15:43.820
绝大部分时候

15:43.820 --> 15:44.820
我们也只是跟个表明

15:44.820 --> 15:45.820
这么简单

15:45.820 --> 15:46.820
也不会

15:46.820 --> 15:47.820
当然之后呢

15:47.820 --> 15:48.820
还有些其他揭发

15:48.820 --> 15:49.820
但是呢

15:49.820 --> 15:50.820
最多的情况是

15:50.820 --> 15:51.820
跟一个表明就完事了

15:51.820 --> 15:52.820
OK

15:52.820 --> 15:55.260
我们把这个保存一下

15:58.080 --> 15:59.080
这是这个

15:59.080 --> 16:00.080
最基本的sylerx

16:00.080 --> 16:01.080
foran查询

16:01.080 --> 16:02.080
好

16:02.080 --> 16:03.080
接下来我们看一下

16:03.080 --> 16:04.080
第三个

16:04.080 --> 16:05.080
第三个关键是ware

16:05.080 --> 16:06.080
这个是什么呢

16:06.080 --> 16:07.080
这是对查询的结果

16:07.080 --> 16:09.080
就是对原始表的东西

16:09.080 --> 16:11.080
进一步进行筛选

16:11.080 --> 16:13.080
那么我们来看一下

16:13.080 --> 16:14.080
这里呢

16:14.080 --> 16:16.080
我们去掉

16:16.080 --> 16:17.080
现在呢

16:17.080 --> 16:18.080
我们还是查员工

16:18.080 --> 16:19.080
还是查员工

16:19.080 --> 16:20.080
我们查什么呢

16:20.080 --> 16:23.080
查所有的男员工

16:23.080 --> 16:25.080
就性别等于一的员工

16:25.080 --> 16:26.080
那么怎么来查呢

16:26.080 --> 16:27.080
你看啊

16:27.080 --> 16:28.080
我们sylerx

16:28.080 --> 16:29.080
sylerx我这里就简单写

16:29.080 --> 16:30.080
sylerx的信号

16:30.080 --> 16:31.080
foran

16:31.080 --> 16:32.080
哪个表呢

16:32.080 --> 16:33.080
查员工表

16:33.080 --> 16:34.080
inploy

16:34.080 --> 16:35.080
好

16:35.080 --> 16:37.080
后边我可以跟上一个ware

16:37.080 --> 16:38.080
ware什么意思

16:38.080 --> 16:39.080
表示条件

16:39.080 --> 16:40.080
那么它是怎么运行的

16:40.080 --> 16:41.080
它是这样子

16:41.080 --> 16:42.080
比方说我们这里先写完

16:42.080 --> 16:43.080
我们查的是怎么了

16:43.080 --> 16:45.080
查的是Esmail

16:45.080 --> 16:46.080
等于1的

16:46.080 --> 16:47.080
对吧

16:47.080 --> 16:48.080
等于1的员工

16:48.080 --> 16:49.080
好咱们运行

16:49.080 --> 16:50.080
你看

16:50.080 --> 16:51.080
是不是查出来

16:51.080 --> 16:52.080
全是Esmail等于1的员工

16:52.080 --> 16:53.080
对不对

16:53.080 --> 16:54.080
对吧

16:54.080 --> 16:56.080
员工是不是就没有查出来了

16:56.080 --> 16:57.080
就这么简单

16:57.080 --> 16:58.080
它到底是怎么查的

16:58.080 --> 16:59.080
它的运行顺序是这样子

16:59.080 --> 17:02.080
我们把这里寄个笔记

17:02.080 --> 17:03.080
在这里寄

17:03.080 --> 17:07.080
运行顺序

17:07.080 --> 17:09.080
它是先什么呢

17:09.080 --> 17:11.080
先是运行的foran

17:11.080 --> 17:15.080
先把原始表拿出来

17:15.080 --> 17:17.080
它先把原始表拿出来

17:17.080 --> 17:18.080
拿出来过后

17:18.080 --> 17:20.080
每一行在查讯的时候

17:20.080 --> 17:22.080
一行一行的看

17:22.080 --> 17:23.080
每看一行的时候

17:23.080 --> 17:24.080
去匹配这个条件

17:24.080 --> 17:26.080
每一行都要去匹配这个条件

17:26.080 --> 17:28.080
然后再运行什么

17:28.080 --> 17:29.080
weir

17:29.080 --> 17:31.080
然后去匹配这个条件

17:31.080 --> 17:32.080
看条件满不满足

17:32.080 --> 17:34.080
如果说条件不满足的话

17:34.080 --> 17:35.080
那么这一行就直接抛弃了

17:35.080 --> 17:36.080
不要了

17:36.080 --> 17:38.080
整个这一行就不要了

17:38.080 --> 17:41.080
如果条件满足的情况下

17:41.080 --> 17:43.080
再去根据这里的snext

17:43.080 --> 17:45.080
来选择要

17:45.080 --> 17:47.080
显示到查询结果

17:47.080 --> 17:49.080
就是要生存到结果里边的D

17:49.080 --> 17:50.080
根据你这里的情况

17:50.080 --> 17:52.080
来生存到结果里边的D

17:52.080 --> 17:53.080
所以说再运行是什么

17:53.080 --> 17:54.080
是那个字

17:54.080 --> 17:56.080
它是用这种模式来运行的

17:56.080 --> 17:57.080
先运行foran

17:57.080 --> 17:58.080
再运行weir

17:58.080 --> 18:00.080
再运行是那个字

18:00.080 --> 18:01.080
也就是说什么呢

18:01.080 --> 18:03.080
也就是说你千万不能这样子写

18:03.080 --> 18:06.080
比方说我们刚才不是写了这么一个东西吗

18:06.080 --> 18:09.080
比方说我们男和女

18:09.080 --> 18:10.080
我们在这儿

18:10.080 --> 18:13.520
性别这里

18:13.520 --> 18:15.520
当时我们写了这么一个列

18:15.520 --> 18:16.520
加一点

18:16.520 --> 18:18.520
多了一个男和女这一点

18:18.520 --> 18:19.520
对不对

18:19.520 --> 18:21.520
那我这里能不能用这种方式来写呢

18:22.520 --> 18:23.520
等于

18:23.520 --> 18:24.520
男

18:24.520 --> 18:26.520
能不能这样子写呢

18:26.520 --> 18:27.520
能不能

18:27.520 --> 18:28.520
就不能这样子写

18:28.520 --> 18:29.520
你运行看一下

18:29.520 --> 18:31.520
所以他告诉你

18:31.520 --> 18:33.520
on the one clown

18:33.520 --> 18:34.520
就是未知的列

18:34.520 --> 18:35.520
sex

18:35.520 --> 18:36.520
sex是未知的

18:36.520 --> 18:37.520
对吧

18:37.520 --> 18:38.520
那么

18:38.520 --> 18:39.520
这里很要抱错的

18:39.520 --> 18:40.520
为什么呢

18:40.520 --> 18:41.520
就是因为它的运行顺序

18:41.520 --> 18:42.520
它于先运行的是foran

18:42.520 --> 18:43.520
foran后边

18:43.520 --> 18:44.520
我们第一行拿出来

18:44.520 --> 18:46.520
拿出来比较的weir的时候

18:46.520 --> 18:48.520
那么weir是不是要比较sex

18:48.520 --> 18:49.520
哪有sex

18:49.520 --> 18:50.520
是不是没有

18:50.520 --> 18:52.520
这个时候是把weir比较完了过后

18:52.520 --> 18:53.520
要显示了

18:53.520 --> 18:54.520
要显示到结果里面了

18:54.520 --> 18:55.520
的时候呢

18:55.520 --> 18:57.520
根据setex里面的逻辑来进行显示

18:57.520 --> 18:58.520
这个时候才有sex

18:58.520 --> 18:59.520
对吧

18:59.520 --> 19:00.520
所以这里要搞清楚

19:00.520 --> 19:02.520
这个地方是不能写sex的

19:02.520 --> 19:03.520
一定要搞清楚

19:03.520 --> 19:04.520
没有写什么

19:04.520 --> 19:05.520
意思没有

19:05.520 --> 19:06.520
那有时候说

19:06.520 --> 19:07.520
我就要这样

19:07.520 --> 19:08.520
实际这样的逻辑怎么办

19:08.520 --> 19:09.520
有办法

19:09.520 --> 19:10.520
但这几个和不涉及

19:11.520 --> 19:12.520
这里是

19:12.520 --> 19:13.520
关于这个

19:13.520 --> 19:14.520
加weir条件

19:14.520 --> 19:15.520
那么这个weir

19:16.520 --> 19:17.520
加weir条件

19:17.520 --> 19:19.520
没有写forans

19:19.520 --> 19:21.520
没有写forans

19:23.520 --> 19:24.520
那么这个weir条件

19:24.520 --> 19:25.520
还有很多种写法

19:25.520 --> 19:27.520
我这里干写了这么一些

19:27.520 --> 19:28.520
刚才我们用了等号

19:28.520 --> 19:29.520
比较相等

19:30.520 --> 19:31.520
一个等号就够了

19:31.520 --> 19:32.520
它不是复制

19:32.520 --> 19:33.520
在这里面不是复制

19:33.520 --> 19:34.520
还有什么呢

19:34.520 --> 19:35.520
还有in

19:35.520 --> 19:36.520
咱们来看一下

19:36.520 --> 19:37.520
in

19:37.520 --> 19:38.520
in又是什么玩意

19:38.520 --> 19:39.520
我们把这个复制一下

19:40.520 --> 19:42.520
加到weir

19:42.520 --> 19:43.520
这时候

19:43.520 --> 19:46.790
咱们来看一下

19:46.790 --> 19:47.790
in是什么玩意

19:47.790 --> 19:48.790
比方说吧

19:49.790 --> 19:50.790
我看一下

19:51.790 --> 19:53.790
我们查哪个表呢

19:54.790 --> 19:55.790
咱们查部门表

19:56.790 --> 19:57.790
我们查部门表

19:57.790 --> 19:59.790
我们要查一查

19:59.790 --> 20:00.790
属于

20:01.790 --> 20:03.790
id唯一和id唯二的公司的

20:04.790 --> 20:05.790
他们的就是

20:05.790 --> 20:06.790
所谓的部门

20:06.790 --> 20:07.790
我们查这个

20:08.790 --> 20:09.790
我们查的是部门表

20:10.790 --> 20:11.790
department

20:12.790 --> 20:13.790
我们查的是什么呢

20:13.790 --> 20:15.790
查的是company id

20:16.790 --> 20:17.790
cid

20:17.790 --> 20:18.790
这个写的是

20:19.790 --> 20:20.790
company id

20:20.790 --> 20:23.100
company id

20:25.100 --> 20:26.100
我们要查这个id

20:26.100 --> 20:27.100
它等于1

20:27.100 --> 20:28.100
或者是等于2

20:28.100 --> 20:29.100
这个时候我们就可以用in

20:31.100 --> 20:32.100
在什么之中

20:32.100 --> 20:33.100
in后边写上

20:33.100 --> 20:34.100
写上

20:34.100 --> 20:35.100
你要

20:35.100 --> 20:36.100
设置的就是哪些

20:36.100 --> 20:37.100
范围的值

20:37.100 --> 20:38.100
比方说1和2

20:38.100 --> 20:39.100
什么意思

20:39.100 --> 20:40.100
这个就是查询的是

20:40.100 --> 20:43.100
公司id在1和2中的部门

20:44.100 --> 20:45.100
咱们来运行一下

20:46.100 --> 20:47.100
你看

20:47.100 --> 20:48.100
公司id唯一

20:48.100 --> 20:49.100
或者是公司id唯二

20:49.100 --> 20:50.100
是不是都查出来了

20:50.100 --> 20:51.100
那3是不是查不出来

20:51.100 --> 20:52.100
对不对

20:52.100 --> 20:53.100
非常简单

20:53.100 --> 20:54.100
这是in

20:54.100 --> 20:55.100
后边写上一个范围

20:55.100 --> 20:56.100
范围的值

20:57.100 --> 20:58.100
这是这种写法

20:58.100 --> 20:59.100
我们把它复制一下

21:00.100 --> 21:01.100
都很简单

21:01.100 --> 21:02.100
只是你看一下

21:02.100 --> 21:03.100
一看下逻辑就明白了

21:04.100 --> 21:05.100
然后还有一个意思

21:05.100 --> 21:06.100
意思是什么意思呢

21:06.100 --> 21:07.100
意思是我们通常

21:07.100 --> 21:08.100
是来比较老的

21:09.100 --> 21:10.100
比方说

21:10.100 --> 21:11.100
我们要查的是员工

21:12.100 --> 21:13.100
from employee

21:15.100 --> 21:16.100
然后呢

21:16.100 --> 21:17.100
我们看一下吧

21:17.100 --> 21:18.100
员工的结果

21:20.100 --> 21:21.100
这里查询的时候

21:21.100 --> 21:22.100
可以不给分号

21:22.100 --> 21:23.100
但是最好吧

21:23.100 --> 21:24.100
分号跟上

21:24.100 --> 21:25.100
然后呢

21:25.100 --> 21:26.100
看一下员工里边

21:26.100 --> 21:27.100
我记得是有些值是

21:27.100 --> 21:28.100
now的

21:28.100 --> 21:29.100
你看location

21:29.100 --> 21:30.100
他就没有填地址

21:30.100 --> 21:31.100
有些员工是没有地址的

21:31.100 --> 21:32.100
没有填地址的

21:32.100 --> 21:33.100
那么我们要看一下

21:33.100 --> 21:35.100
哪些员工没有填地址

21:35.100 --> 21:36.100
我怎么来查呢

21:36.100 --> 21:37.100
就是为now的值

21:37.100 --> 21:38.100
它不是空置不串

21:38.100 --> 21:39.100
空置不串跟now

21:39.100 --> 21:40.100
是不一样的含义

21:40.100 --> 21:42.100
那么空置不串的话

21:42.100 --> 21:43.100
空置不串很简单

21:43.100 --> 21:44.100
空置不串就是ware

21:44.100 --> 21:45.100
location

21:45.100 --> 21:46.100
等于什么空置不串

21:47.100 --> 21:48.100
两个单一号

21:50.100 --> 21:52.100
现在怎么还捨够支持双一号了吗

21:53.100 --> 21:54.100
我记得以前是不支持

21:54.100 --> 21:55.100
现在还真支持了

21:55.100 --> 21:56.100
支持双一号

21:56.100 --> 21:58.100
现在以前是不支持

21:58.100 --> 21:59.100
单一号

22:00.100 --> 22:01.100
那么现在呢

22:01.100 --> 22:03.100
我们这里如果说要得到now的话

22:03.100 --> 22:04.100
得到now的话

22:04.100 --> 22:05.100
那么他这里是查不出来

22:05.100 --> 22:06.100
now的值

22:06.100 --> 22:07.100
我们要now的话怎么办呢

22:07.100 --> 22:09.100
我能不能用等于now呢

22:10.100 --> 22:11.100
是不是查不出来

22:11.100 --> 22:12.100
now是不能用等于的

22:12.100 --> 22:13.100
要用意思

22:14.100 --> 22:15.100
这样子是不是查出来了

22:15.100 --> 22:17.100
那么这些员工是不是都没有填地址

22:17.100 --> 22:18.100
对不对

22:18.100 --> 22:19.100
那么可以给他

22:19.100 --> 22:20.100
我们把查出来过后

22:20.100 --> 22:21.100
用系统给他发动一些邮件

22:21.100 --> 22:22.100
发动一些消息

22:22.100 --> 22:23.100
让他把地址填上

22:23.100 --> 22:24.100
对吧

22:24.100 --> 22:25.100
那么这里呢

22:25.100 --> 22:26.100
可以通过这个东西来进行查询

22:26.100 --> 22:27.100
意思

22:27.100 --> 22:28.100
那么相反的呢

22:28.100 --> 22:30.100
如果说我要查地址

22:30.100 --> 22:31.100
不是now的

22:31.100 --> 22:32.100
那么就是意思not

22:33.100 --> 22:34.100
这非常非常简单

22:34.100 --> 22:35.100
就是说这个东西查询

22:35.100 --> 22:36.100
是不是太强大了

22:36.100 --> 22:37.100
对吧

22:37.100 --> 22:38.100
譬如说介石

22:38.100 --> 22:39.100
那些数主查学

22:39.100 --> 22:40.100
强大太多太多了

22:40.100 --> 22:41.100
对不对

22:41.100 --> 22:42.100
简单了一个社会语句

22:42.100 --> 22:43.100
可以查出来

22:43.100 --> 22:44.100
这就是生命式语言

22:44.100 --> 22:45.100
可以体验的

22:45.100 --> 22:46.100
对吧

22:46.100 --> 22:48.100
像CSS

22:48.100 --> 22:49.100
生命式语言就是

22:49.100 --> 22:51.100
它非常符合现实逻辑

22:51.100 --> 22:53.100
而且写的时候呢

22:53.100 --> 22:54.100
非常舒服

22:55.100 --> 22:57.100
这次关于这个意思的查询

22:57.100 --> 23:01.670
咱们把这个复制一下吧

23:01.670 --> 23:02.670
再加上一个

23:02.670 --> 23:03.670
意思not

23:03.670 --> 23:04.670
和意思not

23:06.670 --> 23:07.670
好 这是这个

23:07.670 --> 23:08.670
那么接下来

23:08.670 --> 23:09.670
还有大于小于

23:09.670 --> 23:11.670
大于等于小于等于

23:12.670 --> 23:13.670
好理解吧

23:13.670 --> 23:14.670
这就不用说吧

23:14.670 --> 23:15.670
比方说櫻谱乐园

23:15.670 --> 23:16.670
我们看salary

23:17.670 --> 23:18.670
工资

23:18.670 --> 23:19.670
工资的话

23:19.670 --> 23:20.670
如果说我们要查询

23:20.670 --> 23:22.670
大于等于10k的

23:23.670 --> 23:24.670
对不对

23:24.670 --> 23:26.670
这是10k对吧

23:26.670 --> 23:27.670
那么运行

23:27.670 --> 23:28.670
你看这全部查出来了

23:28.670 --> 23:30.670
工资大于等于10k的

23:30.670 --> 23:31.670
对吧

23:31.670 --> 23:32.670
工资

23:32.670 --> 23:33.670
工资这一点你仔细看一下

23:33.670 --> 23:34.670
大于等于10k

23:34.670 --> 23:35.670
都查出来了

23:35.670 --> 23:36.670
对不对

23:36.670 --> 23:37.670
这是大于等于

23:37.670 --> 23:38.670
大于等于

23:38.670 --> 23:39.670
这个人不用说了

23:39.670 --> 23:40.670
你们都懂的

23:40.670 --> 23:41.670
B2

23:41.670 --> 23:42.670
B2是什么意思

23:42.670 --> 23:43.670
在什么之间

23:43.670 --> 23:44.670
那么这个东西

23:44.670 --> 23:45.670
我们先把它复制一下

23:50.780 --> 23:51.780
在什么之间

23:51.780 --> 23:52.780
比方说我想看一下

23:52.780 --> 23:55.780
工资在10k到12k之间的

23:55.780 --> 23:57.780
那么怎么选择

23:57.780 --> 23:58.780
B2

24:00.780 --> 24:01.780
大于等于10k

24:03.780 --> 24:04.780
and

24:04.780 --> 24:05.780
大于等于

24:05.780 --> 24:06.780
小于等于12k

24:06.780 --> 24:07.780
对吧

24:07.780 --> 24:08.780
就这么简单

24:08.780 --> 24:11.780
salary在10k和12k之间

24:12.780 --> 24:13.780
你看一下吧

24:13.780 --> 24:15.780
全部都是10k到12k的

24:15.780 --> 24:16.780
对吧

24:16.780 --> 24:17.780
说很简单

24:17.780 --> 24:18.780
特别简单

24:18.780 --> 24:19.780
这些查询的非常强大

24:19.780 --> 24:20.780
你想想

24:20.780 --> 24:21.780
介绍该怎么办

24:21.780 --> 24:22.780
介绍麻烦的要事

24:22.780 --> 24:23.780
那么现在呢

24:23.780 --> 24:24.780
就是还有那个耐克

24:24.780 --> 24:25.780
耐克做什么呢

24:25.780 --> 24:26.780
耐克做模糊查询

24:26.780 --> 24:27.780
把它复制一下

24:28.780 --> 24:30.780
耐克是做模糊查询的

24:30.780 --> 24:32.780
就是我们想什么

24:32.780 --> 24:33.780
对吧

24:33.780 --> 24:34.780
比方说吧

24:34.780 --> 24:36.780
我们看一下这个

24:37.780 --> 24:42.600
这个名字里边

24:42.600 --> 24:43.600
我看一下

24:43.600 --> 24:44.600
我这个地址

24:44.600 --> 24:45.600
全是程度的地址

24:45.600 --> 24:46.600
我就随便瞎写的

24:46.600 --> 24:47.600
引起了个程序

24:47.600 --> 24:48.600
把声称出来的

24:49.600 --> 24:52.600
我们看一下名字里边

24:52.600 --> 24:54.600
包含原这个字的

24:54.600 --> 24:56.600
包含原这个字的

24:56.600 --> 24:58.600
有哪些员工

24:58.600 --> 25:00.600
那么我们怎么来查呢

25:00.600 --> 25:01.600
我们不用查精确的匹配

25:01.600 --> 25:02.600
对吧

25:02.600 --> 25:03.600
我们要模糊匹配

25:03.600 --> 25:05.600
那么我们这里就可以用name

25:05.600 --> 25:06.600
名字

25:06.600 --> 25:07.600
名字有什么条件呢

25:07.600 --> 25:08.600
耐克

25:08.600 --> 25:09.600
像什么呢

25:09.600 --> 25:10.600
像

25:10.600 --> 25:11.600
后面这个字不算

25:11.600 --> 25:12.600
像什么呢

25:12.600 --> 25:14.600
包含原这个字

25:14.600 --> 25:15.600
你看一下

25:15.600 --> 25:16.600
我们这里怎么能查

25:16.600 --> 25:17.600
能不能查出来

25:17.600 --> 25:18.600
运行

25:18.600 --> 25:19.600
是不是查不出来

25:19.600 --> 25:20.600
为什么查不出来呢

25:20.600 --> 25:21.600
因为后面要写个

25:21.600 --> 25:23.600
模糊匹配的表达式

25:23.600 --> 25:24.600
那么模糊匹配的表达式

25:24.600 --> 25:25.600
怎么写呢

25:25.600 --> 25:26.600
就这里边

25:26.600 --> 25:27.600
你如果说你直接这样子写的话

25:27.600 --> 25:29.600
就相当于是name等于原

25:29.600 --> 25:30.600
那肯定是没有的

25:30.600 --> 25:31.600
那怎么写呢

25:31.600 --> 25:32.600
我们可以这样子写

25:32.600 --> 25:33.600
前面加个分号

25:33.600 --> 25:34.600
后面加个分号

25:34.600 --> 25:35.600
什么意思

25:35.600 --> 25:36.600
就是你原这个字

25:36.600 --> 25:38.600
前边可以匹配任意制服

25:38.600 --> 25:40.600
后边也可以匹配任意制服

25:41.600 --> 25:42.600
那么现在我们来看一下

25:42.600 --> 25:43.600
这个查询

25:44.600 --> 25:45.600
你看

25:45.600 --> 25:46.600
是不是查出来了

25:46.600 --> 25:47.600
对吧

25:47.600 --> 25:48.600
就查出来了

25:48.600 --> 25:50.600
咱们来看一下那个

25:51.600 --> 25:53.600
看一下那个就是

25:53.600 --> 25:55.600
有没有别的

25:58.490 --> 26:00.490
那如果说我们要查这个呢

26:00.490 --> 26:02.490
因为这里不好举例子了

26:02.490 --> 26:04.490
如果说我们要查那个就是

26:05.490 --> 26:06.490
新原的

26:06.490 --> 26:08.490
就是新原的中间有原不认

26:08.490 --> 26:09.490
只是新原的

26:09.490 --> 26:10.490
那么我们把前面的

26:10.490 --> 26:11.490
那个百分号去掉

26:12.490 --> 26:13.490
对不对

26:13.490 --> 26:14.490
是不是只是查出新原的

26:14.490 --> 26:15.490
对吧

26:15.490 --> 26:16.490
好

26:16.490 --> 26:18.490
如果说我们要查原在中间的

26:18.490 --> 26:19.490
就是

26:19.490 --> 26:21.490
原在后边的

26:21.490 --> 26:22.490
把后边的去掉

26:22.490 --> 26:23.490
原在最后一个

26:23.490 --> 26:24.490
是不是查不出来

26:24.490 --> 26:25.490
对不对

26:25.490 --> 26:26.490
好

26:26.490 --> 26:27.490
那么这里除了百分号之外

26:27.490 --> 26:28.490
其实还可以用下滑线

26:28.490 --> 26:30.490
下滑线表示匹配一个字符

26:30.490 --> 26:32.490
那么比方说我要查新原的

26:32.490 --> 26:34.490
并且它长度为2

26:34.490 --> 26:35.490
就是名字的长度为2

26:35.490 --> 26:37.490
是不是可以跟个下滑线

26:37.490 --> 26:38.490
你看

26:38.490 --> 26:39.490
是不是查出来两个字的

26:39.490 --> 26:40.490
对吧

26:40.490 --> 26:41.490
新原的

26:41.490 --> 26:42.490
对不对

26:42.490 --> 26:44.490
那么这群都是模糊查询的方式

26:44.490 --> 26:45.490
我们把它放过来

26:45.490 --> 26:46.490
就是那个

26:46.490 --> 26:47.490
特别特别简单

26:50.490 --> 26:51.490
百分号

26:52.490 --> 26:53.490
这是模糊查询

26:55.490 --> 26:56.490
这是这一块

26:56.490 --> 26:57.490
然后呢

26:57.490 --> 26:59.490
and all表示了多个条件的

26:59.490 --> 27:00.490
并列

27:00.490 --> 27:01.490
多个条件并列

27:01.490 --> 27:02.490
比方说吧

27:02.490 --> 27:03.490
我又来举个例子

27:03.490 --> 27:05.490
就这里边可以查询

27:05.490 --> 27:06.490
各种丰富的场景

27:06.490 --> 27:08.490
比方说我要查询

27:08.490 --> 27:09.490
姓张的

27:09.490 --> 27:11.490
就第一个字必须是张

27:11.490 --> 27:12.490
同时呢

27:13.490 --> 27:14.490
是女生

27:15.490 --> 27:16.490
同时呢

27:16.490 --> 27:17.490
薪水呢

27:17.490 --> 27:18.490
要在

27:19.490 --> 27:21.490
要在那个10k以上

27:21.490 --> 27:22.490
那怎么查呢

27:22.490 --> 27:23.490
你看啊

27:23.490 --> 27:25.490
我要姓张

27:25.490 --> 27:26.490
所以说name

27:27.490 --> 27:28.490
一个第一个条件

27:28.490 --> 27:29.490
是不是name

27:29.490 --> 27:30.490
like

27:30.490 --> 27:31.490
什么

27:31.490 --> 27:32.490
张对吧

27:32.490 --> 27:33.490
张开头

27:33.490 --> 27:34.490
后边呢

27:34.490 --> 27:35.490
无所谓

27:35.490 --> 27:36.490
好

27:36.490 --> 27:37.490
第二个条件

27:37.490 --> 27:38.490
and

27:38.490 --> 27:39.490
并列条件

27:39.490 --> 27:40.490
and

27:40.490 --> 27:41.490
第二个条件是什么呢

27:41.490 --> 27:42.490
第二条件是smail

27:42.490 --> 27:43.490
要等于什么呢

27:43.490 --> 27:44.490
等于女

27:44.490 --> 27:45.490
等于您

27:45.490 --> 27:46.490
还有什么条件呢

27:46.490 --> 27:47.490
还有一个条件

27:47.490 --> 27:48.490
sinary

27:49.490 --> 27:50.490
要大于什么呢

27:50.490 --> 27:52.490
大于等于12k

27:52.490 --> 27:53.490
就写完了

27:54.490 --> 27:55.490
对吧

27:55.490 --> 27:56.490
那么你看一下

27:56.490 --> 27:57.490
这些结果

27:57.490 --> 27:58.490
是不是都满足条件的

27:58.490 --> 27:59.490
对吧

27:59.490 --> 28:00.490
是不是都满足条件的

28:00.490 --> 28:01.490
那么这就是查询

28:01.490 --> 28:02.490
姓张的女生

28:02.490 --> 28:03.490
并且的工资

28:03.490 --> 28:04.490
要大于

28:05.490 --> 28:06.490
这就是查出来了

28:06.490 --> 28:07.490
那么还有一个or

28:07.490 --> 28:08.490
or就是或者

28:08.490 --> 28:09.490
对吧

28:09.490 --> 28:10.490
or就是或者

28:10.490 --> 28:11.490
比方说这个条件成立了

28:11.490 --> 28:13.490
或者是什么呢

28:13.490 --> 28:14.490
或者是

28:16.490 --> 28:17.490
出生日期

28:17.490 --> 28:18.490
还有一个出生日期

28:18.490 --> 28:20.490
出生日期呢

28:20.490 --> 28:25.490
是1992年的

28:25.490 --> 28:29.490
就是1996年之后的

28:29.490 --> 28:31.490
出生于1996年之后的

28:31.490 --> 28:33.490
那么我们这里就可以写个or

28:34.490 --> 28:35.490
换个好吗

28:35.490 --> 28:36.490
不然太多了

28:36.490 --> 28:38.990
Burst

28:38.990 --> 28:40.990
大于等于19

28:40.990 --> 28:42.990
那么这里的日期要这样写

28:42.990 --> 28:43.990
1992年

28:43.990 --> 28:44.990
1月1号

28:44.990 --> 28:45.990
大于这个值的

28:45.990 --> 28:47.990
那么都可以把它查出来

28:47.990 --> 28:48.990
就是说前面是一个条件

28:48.990 --> 28:50.990
and的优先级要比or高

28:50.990 --> 28:51.990
所以说他会把这个东西

28:51.990 --> 28:52.990
当成一个整体

28:52.990 --> 28:53.990
这是一个条件

28:53.990 --> 28:54.990
这是一个条件

28:54.990 --> 28:55.990
两个条件满足任何一个就行了

28:55.990 --> 28:56.990
运行

28:56.990 --> 28:57.990
就是查出来的东西要多一些

28:57.990 --> 28:58.990
你看

28:59.990 --> 29:00.990
这个写错了

29:00.990 --> 29:02.990
1996年

29:03.990 --> 29:04.990
你看

29:04.990 --> 29:06.990
虽然他不姓张

29:06.990 --> 29:08.990
并且工资也没有大于12k

29:08.990 --> 29:09.990
但是他满足

29:09.990 --> 29:10.990
第二个条件

29:10.990 --> 29:12.990
出生日期大于1996年

29:12.990 --> 29:14.990
那么是不是也可以查出来

29:14.990 --> 29:16.990
而且你还可以用

29:16.990 --> 29:18.990
扩号来去定义这些东西

29:18.990 --> 29:19.990
比方说

29:19.990 --> 29:20.990
这一个部分

29:20.990 --> 29:21.990
我必须要是姓张

29:21.990 --> 29:22.990
这个是一定要的条件

29:22.990 --> 29:23.990
但是

29:23.990 --> 29:24.990
我另外两个条件

29:24.990 --> 29:25.990
可以筛选

29:25.990 --> 29:26.990
比方说这个

29:26.990 --> 29:27.990
把扩起来

29:27.990 --> 29:28.990
你看看

29:28.990 --> 29:29.990
这就是什么意思呢

29:29.990 --> 29:31.990
就是说我必须要姓张

29:31.990 --> 29:32.990
同时

29:32.990 --> 29:33.990
另外的条件是什么呢

29:33.990 --> 29:34.990
另外还要满足个条件

29:34.990 --> 29:35.990
这个条件是

29:35.990 --> 29:38.990
要么是女工资大于1200

29:38.990 --> 29:40.990
要么是

29:40.990 --> 29:42.990
1996年之后出生的

29:42.990 --> 29:43.990
就这两个条件

29:43.990 --> 29:44.990
任意满足一个

29:44.990 --> 29:45.990
那么就满足了整个条件

29:45.990 --> 29:46.990
对吧

29:46.990 --> 29:48.990
就是可以组合各种

29:48.990 --> 29:49.990
各种的一个

29:49.990 --> 29:50.990
就是产品条件

29:50.990 --> 29:52.990
这是and和all

29:52.990 --> 29:55.300
对不对

29:55.300 --> 29:56.300
那么这一部分

29:56.300 --> 29:57.300
就是ware里边

29:57.300 --> 29:58.300
我们可以写的东西

29:58.300 --> 29:59.300
好吧

30:00.300 --> 30:02.300
好 接下来是order by

30:02.300 --> 30:03.300
order by是什么呢

30:03.300 --> 30:05.300
order by就是排序了

30:05.300 --> 30:06.300
order by是排序了

30:06.300 --> 30:08.300
order by是什么时候运行的

30:08.300 --> 30:09.300
它有两种一种是生序

30:09.300 --> 30:10.300
一种是像序

30:10.300 --> 30:11.300
order by它运行的顺序

30:11.300 --> 30:12.300
是在生那个时候之后

30:12.300 --> 30:13.300
所以说在order by里边

30:13.300 --> 30:15.300
是可以用生那个城里边的东西的

30:15.300 --> 30:16.300
知道吧

30:16.300 --> 30:17.300
好 那么来吧

30:17.300 --> 30:18.300
比方说

30:18.300 --> 30:19.300
我们这里呢

30:19.300 --> 30:20.300
把这个复制一下

30:20.300 --> 30:22.300
已经复制了

30:23.300 --> 30:24.300
比方说

30:24.300 --> 30:27.300
我现在要按照工资来排序

30:27.300 --> 30:28.300
这个查出来过后

30:28.300 --> 30:31.300
我们继续来order by

30:32.300 --> 30:35.300
order by

30:35.300 --> 30:36.300
要按照什么呢

30:36.300 --> 30:37.300
按照工资来排序

30:37.300 --> 30:39.300
senary

30:39.300 --> 30:41.300
那么我们就写个senary

30:41.300 --> 30:43.300
后边写排序的方式

30:43.300 --> 30:44.300
生序还是将序呢

30:44.300 --> 30:45.300
生序就写

30:45.300 --> 30:47.300
asc就可以了

30:47.300 --> 30:49.300
将序就是低生定

30:49.300 --> 30:51.300
那么就是将序排序

30:51.300 --> 30:52.300
不要说ascending

30:52.300 --> 30:53.300
运行一下

30:53.300 --> 30:55.300
你看是不是工资排序出来了

30:55.300 --> 30:56.300
对吧

30:56.300 --> 30:57.300
工资就排序出来了

30:57.300 --> 30:58.300
看没

30:58.300 --> 30:59.300
非常的舒服

30:59.300 --> 31:01.300
那如果说你要写将序的话

31:01.300 --> 31:02.300
desk

31:02.300 --> 31:03.300
运行

31:03.300 --> 31:04.300
是不是就将序排序了

31:04.300 --> 31:05.300
对不对

31:05.300 --> 31:06.300
对工资将序排序

31:07.300 --> 31:08.300
而且当然一个ware

31:08.300 --> 31:09.300
可以写可不写

31:09.300 --> 31:10.300
就是根据这些

31:10.300 --> 31:11.300
这些指据

31:11.300 --> 31:12.300
生那个是from

31:12.300 --> 31:13.300
我们一般要写

31:13.300 --> 31:14.300
然后后边的ware

31:14.300 --> 31:15.300
order by都可以

31:15.300 --> 31:16.300
不用写的

31:16.300 --> 31:18.300
那我们比方说

31:18.300 --> 31:19.300
我们怎么来验证

31:19.300 --> 31:21.300
order by是运行在生那个城之后的

31:21.300 --> 31:22.300
比方说生那个城

31:22.300 --> 31:23.300
我们加一点

31:23.300 --> 31:24.300
加一点我们之前不是写过吗

31:24.300 --> 31:25.300
写过那个

31:25.300 --> 31:26.300
性别这一点

31:26.300 --> 31:27.300
对吧

31:27.300 --> 31:28.300
把性别这一点拿过来

31:29.300 --> 31:30.300
我们加一点

31:31.300 --> 31:32.300
你看运行

31:32.300 --> 31:33.300
是不是多了个性别这一点

31:33.300 --> 31:34.300
那么我们现在

31:34.300 --> 31:36.300
要按照性别来排序

31:36.300 --> 31:37.300
对吧

31:37.300 --> 31:38.300
那么支不错怎么排序

31:38.300 --> 31:39.300
支不错的按照这个

31:39.300 --> 31:40.300
就是支不错的那个

31:40.300 --> 31:42.300
编码来排序的

31:42.300 --> 31:43.300
按照支不错编码来排序的

31:43.300 --> 31:44.300
我们来看一下吧

31:45.300 --> 31:46.300
按照性别

31:47.300 --> 31:48.300
默认就是生序

31:48.300 --> 31:49.300
你不写的话就是生序

31:49.300 --> 31:51.300
当然我们可以把写上

31:51.300 --> 31:52.300
运行是不是可以排序

31:52.300 --> 31:53.300
对吧

31:53.300 --> 31:54.300
是不是生序排序

31:55.300 --> 31:56.300
对不对

31:57.300 --> 31:58.300
那么如果说

31:59.300 --> 32:00.300
也就是说什么了

32:00.300 --> 32:01.300
比如说这个东西

32:01.300 --> 32:02.300
它运行在生那个城之后的

32:02.300 --> 32:04.300
因为只有生那个城运行的过后

32:04.300 --> 32:05.300
是不是才有生那个城

32:05.300 --> 32:06.300
对不对

32:06.300 --> 32:07.300
所以它运行顺序

32:07.300 --> 32:08.300
是在生那个城之后

32:08.300 --> 32:09.300
没了意思吧

32:09.300 --> 32:10.300
OK

32:10.300 --> 32:12.300
那么这是关于这个

32:14.300 --> 32:16.300
关于这个就是那个Audible

32:16.300 --> 32:17.300
Audible还可以给多条件

32:17.300 --> 32:18.300
比方说

32:18.300 --> 32:20.300
因为你给的条件里边

32:20.300 --> 32:21.300
有可能有相同的对吧

32:21.300 --> 32:22.300
比方说生那个城

32:22.300 --> 32:23.300
这里是不是有可能有相同的

32:23.300 --> 32:24.300
那么在相同的情况下

32:24.300 --> 32:25.300
在这个条件

32:25.300 --> 32:26.300
相同的情况下

32:26.300 --> 32:27.300
我们进一步进行排序

32:27.300 --> 32:28.300
那怎么做呢

32:28.300 --> 32:29.300
斗号

32:29.300 --> 32:30.300
继续写条件

32:30.300 --> 32:31.300
比方说Sanary

32:31.300 --> 32:33.300
Sanary

32:33.300 --> 32:34.300
我们这里

32:34.300 --> 32:35.300
伍尔就删掉吧

32:35.300 --> 32:37.300
给那个看上去太多了

32:37.300 --> 32:38.300
Sanary

32:38.300 --> 32:40.300
然后我们将序排序

32:40.300 --> 32:41.300
Desk

32:41.300 --> 32:42.300
什么意思

32:42.300 --> 32:45.300
表示的是按照新别的生序排序

32:45.300 --> 32:46.300
同时按照

32:46.300 --> 32:48.300
就是新别相同的情况下

32:48.300 --> 32:50.300
按照在新别相同的那一部分

32:50.300 --> 32:52.300
按照工资的将序排序

32:52.300 --> 32:53.300
运行你看

32:53.300 --> 32:55.300
在履相同的这一部分

32:55.300 --> 32:57.300
工资的将序排序了

32:57.300 --> 32:59.300
对不对

32:59.300 --> 33:02.300
对女生最低的工资

33:02.300 --> 33:03.300
在这里是309

33:03.300 --> 33:04.300
对吧

33:04.300 --> 33:05.300
然后对男这一部分

33:05.300 --> 33:06.300
是不是相同的

33:06.300 --> 33:07.300
又按照生序排序

33:07.300 --> 33:08.300
对吧

33:08.300 --> 33:09.300
就是第二个排序条件

33:09.300 --> 33:11.300
就这么个意思

33:11.300 --> 33:13.300
这是关于排序

33:13.300 --> 33:15.300
特别简单

33:15.300 --> 33:16.300
新建一个

33:16.300 --> 33:17.300
Order by

33:17.300 --> 33:21.470
好

33:21.470 --> 33:23.470
然后再来

33:23.470 --> 33:24.470
然后就是limit

33:24.470 --> 33:25.470
limit最后运行

33:25.470 --> 33:27.470
limit最后运行

33:27.470 --> 33:29.470
接着它这里边要写两个

33:29.470 --> 33:30.470
尤其两个数字

33:30.470 --> 33:31.470
一个数字都好另一个数字

33:31.470 --> 33:32.470
表示什么意思

33:32.470 --> 33:36.470
表示挑过N条数据取出M条数据

33:36.470 --> 33:39.470
挑过N条数据取出M条数据

33:39.470 --> 33:40.470
什么意思

33:40.470 --> 33:43.810
我们来看一下

33:43.810 --> 33:45.810
挑过N条数据比方说

33:45.810 --> 33:47.810
我们这里查员工

33:47.810 --> 33:49.810
写到最后的

33:49.810 --> 33:52.810
查员工fromemployee

33:52.810 --> 33:54.810
是不是全部查出来了

33:54.810 --> 33:56.810
那么我们现在要挑过

33:56.810 --> 33:58.810
前面两条数据

33:58.810 --> 34:01.810
我们就写limit2

34:01.810 --> 34:03.810
然后我挑过了前面两条

34:03.810 --> 34:04.810
我从第三条开始取

34:04.810 --> 34:05.810
取几条呢

34:05.810 --> 34:06.810
取三条

34:06.810 --> 34:07.810
是不是取出345

34:07.810 --> 34:09.810
我们逗号3

34:09.810 --> 34:11.810
那么就在结果里面

34:11.810 --> 34:12.810
去取出345了

34:12.810 --> 34:13.810
对不对

34:13.810 --> 34:14.810
好就是limit

34:14.810 --> 34:16.810
这不特别特别简单

34:16.810 --> 34:17.810
对吧

34:17.810 --> 34:19.810
特别特别简单

34:19.810 --> 34:22.820
limit

34:22.820 --> 34:23.820
好

34:23.820 --> 34:24.820
那么我们这一课的东西

34:24.820 --> 34:25.820
就讲完了

34:25.820 --> 34:27.820
我们做两个练习

34:27.820 --> 34:28.820
我们的练习呢

34:28.820 --> 34:29.820
也根据从实际情况出发

34:29.820 --> 34:31.820
我们实际情况里边

34:31.820 --> 34:33.820
通常有这么两个功能

34:33.820 --> 34:37.260
两个需求练习

34:37.260 --> 34:39.260
第一个需求是

34:39.260 --> 34:42.260
查询优热表

34:42.260 --> 34:43.260
查询优热表

34:43.260 --> 34:45.260
得到

34:45.260 --> 34:48.260
得到那个用

34:48.260 --> 34:51.260
得到账号为

34:51.260 --> 34:53.260
二的命

34:53.260 --> 34:57.260
密码为123456

34:57.260 --> 34:59.260
的用户

34:59.260 --> 35:00.260
查这个表

35:00.260 --> 35:01.260
那么这个我们来做什么呢

35:01.260 --> 35:02.260
实际上这个在做什么

35:02.260 --> 35:03.260
做登录

35:03.260 --> 35:04.260
登录就是在这样查的

35:04.260 --> 35:05.260
对吧

35:05.260 --> 35:06.260
你获取到

35:06.260 --> 35:07.260
你是不是程序能够获取到

35:07.260 --> 35:08.260
用户填的账号

35:08.260 --> 35:09.260
能够获取到用户填的密码

35:09.260 --> 35:10.260
对吧

35:10.260 --> 35:11.260
我们要看一下这个用户

35:11.260 --> 35:12.260
能不能真正成功

35:12.260 --> 35:13.260
怎么来看呢

35:13.260 --> 35:14.260
我们就去查询

35:14.260 --> 35:15.260
用户为这个

35:15.260 --> 35:16.260
密码为这个的用户

35:16.260 --> 35:17.260
存不存在

35:17.260 --> 35:18.260
对不对

35:18.260 --> 35:19.260
那怎么来查

35:19.260 --> 35:21.260
用深刻语句怎么来查

35:21.260 --> 35:23.260
就是select

35:23.260 --> 35:24.260
对吧

35:24.260 --> 35:25.260
信号

35:25.260 --> 35:26.260
from

35:26.260 --> 35:27.260
哪个标呢

35:27.260 --> 35:28.260
是不是那个u字表

35:28.260 --> 35:29.260
对吧

35:29.260 --> 35:30.260
u字表

35:30.260 --> 35:31.260
条件有没有呢

35:31.260 --> 35:32.260
有

35:32.260 --> 35:33.260
条件是什么呢

35:33.260 --> 35:35.260
条件是账号moginid

35:35.260 --> 35:36.260
等于

35:36.260 --> 35:37.260
什么呢

35:37.260 --> 35:38.260
等于我们用户填的账号

35:38.260 --> 35:39.260
填的账号是咋

35:39.260 --> 35:40.260
填的账号是

35:40.260 --> 35:42.260
二的命

35:42.260 --> 35:44.260
and

35:44.260 --> 35:45.260
填的密码是什么呢

35:45.260 --> 35:46.260
密码

35:46.260 --> 35:48.260
123456

35:48.260 --> 35:49.260
对吧

35:49.260 --> 35:50.260
来看一下运行

35:50.260 --> 35:51.260
是没有

35:51.260 --> 35:52.260
查不出来

35:52.260 --> 35:53.260
查不出来

35:53.260 --> 35:54.260
是不是说明登录不成功

35:54.260 --> 35:55.260
对不对

35:55.260 --> 35:56.260
就是个查询

35:56.260 --> 35:57.260
就这么个意思

35:57.260 --> 35:58.260
因为密码不正确

35:58.260 --> 35:59.260
123123

35:59.260 --> 36:00.260
密码不正确

36:00.260 --> 36:01.260
对吧

36:01.260 --> 36:02.260
登录成功了

36:02.260 --> 36:03.260
对吧

36:03.260 --> 36:04.260
那么这就是

36:04.260 --> 36:06.260
登录的查询

36:06.260 --> 36:07.260
好

36:07.260 --> 36:08.260
再来

36:08.260 --> 36:10.260
比方说我们现在要

36:10.260 --> 36:11.260
得到

36:11.260 --> 36:14.260
查询

36:14.260 --> 36:16.260
员工表

36:16.260 --> 36:20.260
按照员工的入职时间

36:20.260 --> 36:24.260
将续排序

36:24.260 --> 36:28.260
并且使用分页查询

36:28.260 --> 36:29.260
什么叫分页查询

36:29.260 --> 36:31.260
就是查询

36:31.260 --> 36:34.260
比方说第2页

36:34.260 --> 36:35.260
第2页

36:35.260 --> 36:37.260
每页10条

36:37.260 --> 36:38.260
那么这个是什么

36:38.260 --> 36:40.260
就是这个是页锁印

36:40.260 --> 36:41.260
这是页容量

36:41.260 --> 36:43.260
第二页每页10条数据

36:43.260 --> 36:45.260
那么这个东西怎么查

36:45.260 --> 36:47.260
我们首先查

36:47.260 --> 36:49.260
查员工表的

36:49.260 --> 36:52.260
查员工表

36:52.260 --> 36:54.260
它当然这里没有说

36:54.260 --> 36:55.260
我要得到哪些数据

36:55.260 --> 36:56.260
得到哪些列

36:56.260 --> 36:57.260
我们这里可以查所有列

36:57.260 --> 36:59.260
查员工表

36:59.260 --> 37:00.260
查员工表的时候

37:00.260 --> 37:01.260
它有个要求

37:01.260 --> 37:03.260
按照orderband

37:03.260 --> 37:06.260
按照入职时间

37:06.260 --> 37:07.260
交应代子

37:07.260 --> 37:08.260
有的时候你忘了列的话

37:08.260 --> 37:09.260
你可以自己看一下

37:09.260 --> 37:11.260
或者是你可以用这种方式

37:11.260 --> 37:12.260
inploy第二个什么

37:12.260 --> 37:13.260
对吧

37:13.260 --> 37:14.260
它这里有

37:14.260 --> 37:16.260
按照交应代子

37:16.260 --> 37:19.260
入职时间的将续排序

37:19.260 --> 37:21.260
你看一下

37:21.260 --> 37:23.260
是不是入职时间的将续排序出来了

37:23.260 --> 37:27.260
最晚入职2016年

37:27.260 --> 37:29.260
就出来了

37:29.260 --> 37:31.260
那么在这个结果的基础上

37:31.260 --> 37:32.260
我还要进行筛选

37:32.260 --> 37:33.260
怎么筛选呢

37:33.260 --> 37:35.260
我要得到第2页

37:35.260 --> 37:37.260
每页10条数据

37:37.260 --> 37:38.260
那是不是相当于

37:38.260 --> 37:39.260
是筛选出

37:39.260 --> 37:40.260
第1页的数据

37:40.260 --> 37:41.260
把第1页的数据不要了

37:41.260 --> 37:43.260
我们用查的是第2页

37:43.260 --> 37:44.260
那么第1页多少条数据

37:44.260 --> 37:46.260
第1页是不是也是10条

37:46.260 --> 37:47.260
每页10条数据

37:47.260 --> 37:48.260
所以说我们这里

37:48.260 --> 37:49.260
是不是可以用limit

37:49.260 --> 37:50.260
limit就专门用来

37:50.260 --> 37:52.260
通常我们都是用来分页的

37:52.260 --> 37:55.260
limit然后10

37:55.260 --> 37:56.260
对吧

37:56.260 --> 37:57.260
是不是10

37:57.260 --> 37:58.260
去掉10条数据

37:58.260 --> 38:00.260
然后找10条数据

38:00.260 --> 38:03.260
是不是就查出第2页了

38:03.260 --> 38:05.260
实际上limit这里

38:05.260 --> 38:07.260
它是有一个公式的

38:07.260 --> 38:08.260
limit这里你想一想

38:08.260 --> 38:10.260
limit这里是不是有一个公式

38:10.260 --> 38:12.260
什么公式呢

38:12.260 --> 38:16.260
就是limit这里写的是

38:16.260 --> 38:18.260
一个就是頁容量

38:18.260 --> 38:20.260
减去1乘1

38:20.260 --> 38:25.260
就是頁锁印减1乘1乘1配级size

38:25.260 --> 38:26.260
你想什么这个道理

38:26.260 --> 38:27.260
第一页

38:27.260 --> 38:28.260
第一个部分的数字

38:28.260 --> 38:29.260
是不是这个

38:29.260 --> 38:31.260
第二页是不是2-1乘1-10

38:31.260 --> 38:32.260
对吧

38:32.260 --> 38:33.260
为什么10

38:33.260 --> 38:34.260
这里是10条数据

38:34.260 --> 38:35.260
对吧

38:35.260 --> 38:36.260
那比方说这里是5条

38:36.260 --> 38:37.260
那这里就写5

38:37.260 --> 38:38.260
这里呢

38:38.260 --> 38:39.260
这里就写了什么

38:39.260 --> 38:40.260
写5

38:40.260 --> 38:42.260
2-1等于1

38:42.260 --> 38:43.260
然后第三页

38:43.260 --> 38:45.260
第三页是这里写10

38:45.260 --> 38:46.260
对不对

38:46.260 --> 38:47.260
就总之这个公式

38:47.260 --> 38:49.260
当前的页码减去1

38:49.260 --> 38:51.260
除乘1页容量

38:51.260 --> 38:52.260
这个就是页容量

38:52.260 --> 38:53.260
对吧

38:53.260 --> 38:54.260
那么就表示要挑过的数据

38:54.260 --> 38:55.260
然后兜号

38:55.260 --> 38:57.260
后边写上配级size

38:57.260 --> 38:59.260
这基本上就是它的公式

38:59.260 --> 39:00.260
这样子我们其实

39:00.260 --> 39:01.260
真正的在后段

39:01.260 --> 39:02.260
它怎么跟我们分页的

39:02.260 --> 39:04.260
它就是这样分页的

39:04.260 --> 39:05.260
去通过一个查讯来

39:05.260 --> 39:06.260
帮我们分页

39:06.260 --> 39:07.260
只不过你们目前

39:07.260 --> 39:08.260
还没有学到

39:08.260 --> 39:09.260
在load接式里面

39:09.260 --> 39:10.260
怎么来控制这个搜口语句

39:10.260 --> 39:11.260
以后就会学习

39:11.260 --> 39:12.260
现在把搜口语句

39:12.260 --> 39:13.260
要搞清楚

39:13.260 --> 39:14.260
先要学懂

39:14.260 --> 39:15.260
查询

39:15.260 --> 39:16.260
比方说

39:16.260 --> 39:17.260
我们现在又来一个查询

39:17.260 --> 39:19.260
多来几个练习

39:19.260 --> 39:23.260
查询

39:23.260 --> 39:28.260
工资最高的女员工

39:28.260 --> 39:29.260
又怎么查

39:29.260 --> 39:31.260
我要查询工资最高的女员工

39:31.260 --> 39:32.260
怎么查

39:32.260 --> 39:33.260
你看

39:33.260 --> 39:34.260
我就这样了

39:34.260 --> 39:35.260
这些东西

39:35.260 --> 39:36.260
你们都可以停下来

39:36.260 --> 39:37.260
想一想

39:37.260 --> 39:38.260
自己想一想怎么查

39:38.260 --> 39:40.260
然后再来看

39:40.260 --> 39:41.260
工资最高

39:41.260 --> 39:42.260
这个东西你开始不太熟悉

39:42.260 --> 39:43.260
后面慢慢就熟悉了

39:43.260 --> 39:44.260
查询员工表

39:44.260 --> 39:46.260
肯定是查的员工

39:46.260 --> 39:48.260
工资最高的

39:48.260 --> 39:49.260
我怎么想知道最高

39:49.260 --> 39:50.260
首先是女员工

39:50.260 --> 39:51.260
我们先把限制一下

39:51.260 --> 39:52.260
哪员工看都不看

39:52.260 --> 39:53.260
那么我们说

39:53.260 --> 39:54.260
我们就一直没有了

39:54.260 --> 39:55.260
等于零

39:55.260 --> 39:56.260
女员工

39:56.260 --> 39:57.260
只查女员工

39:57.260 --> 39:59.260
然后我们只查

39:59.260 --> 40:00.260
工资最高的

40:00.260 --> 40:01.260
是不是按照工资的

40:01.260 --> 40:02.260
导序排序

40:02.260 --> 40:03.260
我们可以

40:03.260 --> 40:07.260
order by salary

40:07.260 --> 40:08.260
desk

40:08.260 --> 40:09.260
按照去排序

40:09.260 --> 40:11.260
然后这样排出来

40:11.260 --> 40:12.260
排出来

40:12.260 --> 40:13.260
是不是我们只去

40:13.260 --> 40:14.260
第1个就行了

40:14.260 --> 40:15.260
第1个不就是女员工

40:15.260 --> 40:16.260
对不对

40:16.260 --> 40:17.260
去第1个就行了

40:17.260 --> 40:19.260
然后我们用nimate

40:19.260 --> 40:21.260
nimate01

40:21.260 --> 40:22.260
对不对

40:22.260 --> 40:23.260
去掉就是

40:23.260 --> 40:24.260
挑过0条

40:24.260 --> 40:25.260
但是只取1条

40:25.260 --> 40:26.260
是不是就查

40:26.260 --> 40:27.260
把个周指查出来了

40:27.260 --> 40:28.260
音响

40:28.260 --> 40:29.260
对不对

40:29.260 --> 40:30.260
这就是

40:30.260 --> 40:32.260
这个查询

40:32.260 --> 40:33.260
有意思

40:33.260 --> 40:36.260
这就是那些基本查询

40:36.260 --> 40:37.260
那么这三道题

40:37.260 --> 40:38.260
题也不多

40:38.260 --> 40:39.260
你们自己下去念一念

40:39.260 --> 40:40.260
把这个东西

40:40.260 --> 40:41.260
一定要写熟悉

40:41.260 --> 40:42.260
基本查询很简单的

40:42.260 --> 40:44.260
你要把写熟悉

40:44.260 --> 40:45.260
OK

40:45.260 --> 40:47.260
那么这是关于这一部分的

40:47.260 --> 40:49.260
只是单表的

40:49.260 --> 40:50.260
基本查询

