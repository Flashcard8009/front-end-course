WEBVTT

00:00.690 --> 00:06.690
好 同学们 咱们终于开始要重录露德结石课程了

00:06.690 --> 00:11.690
很多同学跟我说 什么时候录露德结石 那就是现在了

00:11.690 --> 00:15.690
这个露的讲起来要把握好分寸

00:15.690 --> 00:20.690
为什么呢 因为这个露的 大家知道它是什么

00:20.690 --> 00:26.690
它是后端 理论上加拿能做的事 露的全能做

00:26.690 --> 00:30.690
只不过是理论上 也不用理论上了

00:30.690 --> 00:33.690
加拿能做的事 露的就是全能做

00:33.690 --> 00:37.690
只不过有些事 露的做起来没有那么好

00:37.690 --> 00:41.690
没有加拿做的那么好 因为加拿毕竟生态太强大了

00:41.690 --> 00:46.690
露的还比较年轻 而现在它是一个解释性的语言

00:46.690 --> 00:49.690
介事是解释性的 露的也无法逃脱这一点

00:49.690 --> 00:54.690
因此解释性语言的一些原罪也无法避免

00:55.690 --> 00:58.690
也就是说这个露的 你要把它怎么讲呢

00:58.690 --> 01:02.690
要按照那个完整的后端来讲的话 不得了

01:02.690 --> 01:05.690
无穷无尽的指使生不见底

01:05.690 --> 01:10.690
那怎么讲呢 我们一定要以就是你们以后就业

01:10.690 --> 01:15.690
在公司里边真正用到的 会帮助你开发

01:15.690 --> 01:18.690
会帮助你就业的时候获得竞争优势

01:18.690 --> 01:22.690
按照这么一个目标来进行讲解 不能无穷无尽的讲

01:22.690 --> 01:25.690
不然的话这个话就说起来没完了

01:25.690 --> 01:28.690
不然的话讲了一讲到就跟加法差不多了

01:28.690 --> 01:32.690
然后这个露的要分为多少个章节

01:32.690 --> 01:36.690
大概我分为五个章节 这是我们的第一章

01:36.690 --> 01:39.690
露的核心 核心是什么呢

01:39.690 --> 01:41.690
就是说我们讲这个露的的时候

01:41.690 --> 01:43.690
就不用去安装什么第三方库了

01:43.690 --> 01:47.690
就用我们露的里面自带的功能来去完成

01:47.690 --> 01:50.690
就跟你们以前宣流烂期里面的介事开发的时候

01:50.690 --> 01:54.690
对吧 一开始学的时候是不是没有用任何的第三方库

01:54.690 --> 01:56.690
什么介块啊 这些东西都没有用

01:56.690 --> 01:59.690
对吧 全部都是自己手写

01:59.690 --> 02:05.690
来理解露的核心 它里面它提供了什么样的功能

02:05.690 --> 02:08.690
当它核心里面提供的功能非常非常多

02:08.690 --> 02:10.690
用不用得完了 肯定用不完

02:10.690 --> 02:13.690
你要把它用完了 那就是完整的一个后端学习了

02:13.690 --> 02:14.690
不得了的

02:14.690 --> 02:17.690
所以说我们还是要以实用的角度出发

02:17.690 --> 02:20.690
对里面有帮助的角度出发

02:20.690 --> 02:22.690
不然的话 课程就跟reaction一样

02:22.690 --> 02:24.690
我reaction录完了过后

02:24.690 --> 02:27.690
我自己都害怕了 怎么一百多节课

02:27.690 --> 02:29.690
那么同学们可能是吃不消的

02:29.690 --> 02:32.690
一定要确定一个目标了

02:32.690 --> 02:35.690
然后后边的课程可以明显的发现

02:35.690 --> 02:38.690
录了reaction之后 后边的课程我录的都是非常小心

02:38.690 --> 02:41.690
避免时间过长

02:41.690 --> 02:43.690
那么这个章节里面我们第一节课

02:43.690 --> 02:45.690
首先对露的做一个概述

02:45.690 --> 02:49.690
其实之前里面或多或少也接触过漏的

02:49.690 --> 02:53.690
你看 之前里面学习那个保管令器

02:53.690 --> 02:56.690
学习那个模块化 都是我做的课程

02:56.690 --> 02:58.690
那边是不是已经用了漏的了

02:58.690 --> 03:00.690
对吧 已经用了的

03:00.690 --> 03:02.690
所以说这个漏的

03:02.690 --> 03:05.690
大家相信了 大家只要学过之前的课程

03:05.690 --> 03:07.690
已经安装了 一定安装了

03:07.690 --> 03:09.690
因此怎么去安装 怎么去下载

03:09.690 --> 03:11.690
这些课程我就不扯了

03:11.690 --> 03:13.690
包括什么漏的的历史 这些废话我就不扯了

03:13.690 --> 03:15.690
没有兴趣的话 自己去查一下

03:15.690 --> 03:16.690
漏的历史是什么样子

03:16.690 --> 03:18.690
我好像以前也讲过

03:18.690 --> 03:20.690
我们就直接讲干户

03:20.690 --> 03:22.690
好 那么一个一个说

03:22.690 --> 03:24.690
其实我这节课就讲三个点

03:24.690 --> 03:26.690
一个是什么是漏的

03:26.690 --> 03:28.690
我之前也简单的介绍过

03:28.690 --> 03:31.690
这一次我再把它深入讲解一下

03:31.690 --> 03:33.690
首先我们要知道漏的是一个运行环境

03:33.690 --> 03:35.690
它跟浏览器一样

03:35.690 --> 03:37.690
浏览器也是一个运行环境

03:37.690 --> 03:39.690
咱们的GS代码写好了之后

03:39.690 --> 03:41.690
要放到浏览器里面才能运行

03:41.690 --> 03:43.690
脱裂的浏览器是没法运行的

03:43.690 --> 03:45.690
那么现在学了漏的之后

03:45.690 --> 03:47.690
我们又多了一个环境了

03:47.690 --> 03:49.690
不仅是浏览器能够运行GS

03:49.690 --> 03:51.690
漏的也能运行GS

03:51.690 --> 03:55.690
这里有一个约定俗层的这么一种说法

03:55.690 --> 03:57.690
不是说一定的

03:57.690 --> 03:59.690
以后你到了别的地方

03:59.690 --> 04:00.690
听到别人说

04:00.690 --> 04:02.690
怎么边缘老师讲的不一样

04:02.690 --> 04:04.690
这是个约定俗层的

04:04.690 --> 04:05.690
它不是一定的

04:05.690 --> 04:07.690
我们平时说的是JavaScript

04:07.690 --> 04:09.690
指的是什么呢

04:09.690 --> 04:11.690
指的是在浏览器端

04:11.690 --> 04:15.690
浏览器端运行的GS

04:15.690 --> 04:17.690
我们平时说的是漏的GS

04:17.690 --> 04:22.690
指的是在漏的环境运行的GS

04:22.690 --> 04:24.690
我们平时是这么说的

04:24.690 --> 04:25.690
漏的是一个环境

04:25.690 --> 04:27.690
漏的GS是在漏的环境里面

04:27.690 --> 04:28.690
写的GS代码

04:28.690 --> 04:30.690
它要交给漏的环境去运行

04:30.690 --> 04:32.690
当然这只是一个

04:32.690 --> 04:33.690
不是一个官方的说法

04:33.690 --> 04:35.690
只是我们平时这样子认为

04:35.690 --> 04:37.690
有的时候我们也可以简单的认为

04:37.690 --> 04:38.690
可以运行在

04:38.690 --> 04:40.690
浏览器也可以运行在漏的

04:40.690 --> 04:42.690
这是东西没有说

04:42.690 --> 04:44.690
一个特别准确的这么一个规定

04:44.690 --> 04:46.690
大家知道这么个意识就行了

04:46.690 --> 04:47.690
也就是说我们的代码

04:47.690 --> 04:48.690
是可以运行在

04:48.690 --> 04:51.690
浏览器也可以在运行在漏的

04:51.690 --> 04:53.690
那有什么样的区别呢

04:53.690 --> 04:54.690
浏览器里面也可以运行

04:54.690 --> 04:56.690
那为什么搞个漏的出来了

04:56.690 --> 04:58.690
因为漏的它拥有

04:58.690 --> 05:00.690
比浏览器更多的能力

05:00.690 --> 05:01.690
我们之前学到

05:01.690 --> 05:02.690
那么长时间的浏览器

05:02.690 --> 05:04.690
都是前段开发

05:04.690 --> 05:06.690
那么我们可以知道

05:06.690 --> 05:08.690
浏览器里面有很多事情是不能做的

05:08.690 --> 05:09.690
我们来看一下

05:09.690 --> 05:10.690
这里有张图

05:10.690 --> 05:13.690
我们浏览器里面的介石

05:13.690 --> 05:14.690
你看啊

05:14.690 --> 05:16.690
我们这比方是个加发script

05:16.690 --> 05:17.690
我们就在浏览器里面介石

05:17.690 --> 05:18.690
我们能用什么呢

05:18.690 --> 05:20.690
能写什么样的代码呢

05:20.690 --> 05:21.690
一个是acma script

05:21.690 --> 05:24.690
就是我们的介石语言标准

05:24.690 --> 05:26.690
你怎么去说话

05:26.690 --> 05:28.690
那么我们这一部分学的是

05:28.690 --> 05:29.690
acma script

05:29.690 --> 05:31.690
就是我们平时说的es

05:31.690 --> 05:33.690
es6,es5,es3

05:33.690 --> 05:34.690
es7,es8

05:34.690 --> 05:36.690
当然后面都是用联号编号

05:36.690 --> 05:38.690
es2016,es2017

05:38.690 --> 05:40.690
这些都是语言标准

05:40.690 --> 05:41.690
什么叫语言标准呢

05:41.690 --> 05:43.690
它跟环境没有关系

05:43.690 --> 05:45.690
你浏览器里面可以这样说话

05:45.690 --> 05:47.690
其他的环境里面也可以这样说话

05:47.690 --> 05:50.690
只要有一个介石的

05:50.690 --> 05:52.690
解释器去执行它就行了

05:52.690 --> 05:54.690
我们平时的V8引擎里面

05:54.690 --> 05:55.690
不就有解释器吗

05:55.690 --> 05:58.690
它能解释你说的到底是什么意思

05:58.690 --> 06:00.690
那浏览器一看你这样子说话

06:00.690 --> 06:02.690
它看着有点看得下去了

06:02.690 --> 06:04.690
你这个说话功能太弱了

06:04.690 --> 06:06.690
我给你提供一些功能吧

06:06.690 --> 06:09.690
于是能浏览器通过什么对象

06:09.690 --> 06:11.690
通过什么函数

06:11.690 --> 06:12.690
就给你提供了一些API

06:12.690 --> 06:14.690
我们把它叫做web API

06:14.690 --> 06:16.690
就浏览器给你提供的

06:16.690 --> 06:18.690
于是你通过web API

06:18.690 --> 06:20.690
比方说什么dorm操作

06:20.690 --> 06:22.690
borm操作对吧

06:22.690 --> 06:24.690
得到某个元素的尺寸

06:24.690 --> 06:26.690
颜色样式等等

06:26.690 --> 06:28.690
那么这些都是属于浏览器

06:28.690 --> 06:29.690
给你提供的

06:29.690 --> 06:31.690
包括什么set timeout

06:31.690 --> 06:33.690
set interval对吧

06:33.690 --> 06:34.690
后期课的同学呢

06:34.690 --> 06:36.690
因为你们都是VIP学员

06:36.690 --> 06:38.690
你们应该能够拿到我

06:38.690 --> 06:40.690
我给大家录的那个GS课程

06:40.690 --> 06:42.690
基础的GS课程

06:42.690 --> 06:43.690
你们应该知道

06:43.690 --> 06:46.690
里边我都是把分开讲的

06:46.690 --> 06:48.690
前面讲的是语言核心的东西

06:48.690 --> 06:49.690
后边讲的是浏览器

06:49.690 --> 06:51.690
给你注入的一些API

06:51.690 --> 06:53.690
因此我们GS可以在浏览器里边

06:53.690 --> 06:55.690
展现一些丰富的效果

06:55.690 --> 06:57.690
完成一些功能

06:57.690 --> 06:58.690
也就是说我们web API

06:58.690 --> 07:00.690
而它提供了

07:00.690 --> 07:02.690
我们的GS能够操作浏览器

07:02.690 --> 07:03.690
窗口和页面的能力

07:03.690 --> 07:04.690
包括哪些能力呢

07:04.690 --> 07:05.690
什么borm dom

07:05.690 --> 07:06.690
RTX

07:06.690 --> 07:08.690
这些都是浏览器的web API

07:08.690 --> 07:09.690
给你打给你的

07:09.690 --> 07:11.690
不要认为它是ES里边规定的

07:11.690 --> 07:13.690
因为它说ES6的

07:13.690 --> 07:16.690
ES6里边出来一个

07:16.690 --> 07:18.690
什么非起API

07:18.690 --> 07:20.690
这个东西一说一说

07:20.690 --> 07:21.690
都闹消化的

07:21.690 --> 07:23.690
这个非起API是web API

07:23.690 --> 07:24.690
里边的东西

07:24.690 --> 07:25.690
跟ES没有任何关系

07:25.690 --> 07:27.690
包括我在讲ES的时候

07:27.690 --> 07:28.690
说过什么非起API

07:28.690 --> 07:30.690
来自于ES6

07:30.690 --> 07:31.690
只不过ES6

07:31.690 --> 07:32.690
从来过后

07:32.690 --> 07:33.690
浏览器一看

07:33.690 --> 07:34.690
有这么好的东西出来了

07:34.690 --> 07:35.690
对吧

07:35.690 --> 07:37.690
我给你搞一个新的web API

07:37.690 --> 07:38.690
出来

07:38.690 --> 07:39.690
跟以前的RTX

07:39.690 --> 07:41.690
API有点区别

07:41.690 --> 07:43.690
以前是用XML ADDP request

07:43.690 --> 07:45.690
那么现在用Fetch

07:45.690 --> 07:47.690
这是浏览器搞出来的

07:47.690 --> 07:49.690
整个RTX都是浏览器搞出来的

07:49.690 --> 07:50.690
对吧

07:50.690 --> 07:52.690
把这个东西理解清楚

07:52.690 --> 07:54.690
然后我们这里说一下

07:54.690 --> 07:56.690
在浏览器里边的介绍

07:56.690 --> 07:59.690
实际上它的能力是非常有限的

07:59.690 --> 08:00.690
比方说

08:00.690 --> 08:02.690
我们会遇到很多困难

08:02.690 --> 08:03.690
比方说跨域的问题

08:03.690 --> 08:04.690
是个大问题

08:04.690 --> 08:05.690
跨域的问题怎么来的

08:05.690 --> 08:07.690
跨域的问题是ATDP

08:07.690 --> 08:09.690
请求带来的

08:09.690 --> 08:10.690
是吗

08:10.690 --> 08:11.690
跨域的问题是浏览器

08:11.690 --> 08:12.690
跟我们带来的

08:12.690 --> 08:13.690
是浏览器

08:13.690 --> 08:14.690
跟我们搞出来的

08:14.690 --> 08:15.690
什么同源策略

08:15.690 --> 08:16.690
它为了安全

08:16.690 --> 08:17.690
为了保护

08:17.690 --> 08:18.690
每个网站

08:18.690 --> 08:19.690
它自己的数据

08:19.690 --> 08:20.690
不要被其他网站

08:20.690 --> 08:21.690
随意获取

08:21.690 --> 08:22.690
所以说

08:22.690 --> 08:23.690
它搞出来这么一个东西

08:23.690 --> 08:24.690
叫同源策略

08:24.690 --> 08:25.690
有了同源策略

08:25.690 --> 08:27.690
就有了跨域问题

08:27.690 --> 08:28.690
是这么来的

08:28.690 --> 08:30.690
它不是说那个

08:30.690 --> 08:31.690
我们语言本身

08:31.690 --> 08:32.690
或者是ATDP协议

08:32.690 --> 08:33.690
ATDP协议

08:33.690 --> 08:34.690
从来没有什么跨域的概念

08:34.690 --> 08:36.690
概念都没有

08:36.690 --> 08:37.690
一个请求去了

08:37.690 --> 08:38.690
他就回来了

08:38.690 --> 08:39.690
响应结果拿到了

08:39.690 --> 08:40.690
是吧

08:40.690 --> 08:41.690
是浏览器拿到

08:41.690 --> 08:42.690
结果不给力

08:42.690 --> 08:43.690
他不给力自然获取不到

08:43.690 --> 08:44.690
这是跨域问题来了

08:44.690 --> 08:45.690
对吧

08:45.690 --> 08:46.690
还有文件读写

08:46.690 --> 08:47.690
你在浏览器里边写

08:47.690 --> 08:49.690
介石能读文件吗

08:49.690 --> 08:51.690
是不是读不了

08:51.690 --> 08:53.690
但是不代表介石语言

08:53.690 --> 08:54.690
它读不了文件

08:54.690 --> 08:55.690
介石语它只是

08:55.690 --> 08:56.690
告诉你怎么说话

08:56.690 --> 08:57.690
比方说我用中文

08:57.690 --> 08:58.690
我用中文说话

08:58.690 --> 08:59.690
我说我要读文件

08:59.690 --> 09:00.690
我能不能说吗

09:00.690 --> 09:02.690
我说了不会原地爆炸吗

09:02.690 --> 09:03.690
不会吗

09:03.690 --> 09:04.690
但是它不给我

09:04.690 --> 09:05.690
浏览器它不给我

09:05.690 --> 09:06.690
怎么办

09:06.690 --> 09:07.690
所以说

09:07.690 --> 09:08.690
浏览器它有一些

09:08.690 --> 09:09.690
安全性的考虑

09:09.690 --> 09:11.690
你想它肯定是不能给力的

09:11.690 --> 09:13.690
不然别人一上网

09:13.690 --> 09:14.690
一上一个网站

09:14.690 --> 09:16.690
你把它电脑里面的文件

09:16.690 --> 09:17.690
都给它获取了

09:17.690 --> 09:18.690
因为阿加克是传道理的服务器

09:18.690 --> 09:19.690
大得不得了

09:19.690 --> 09:21.690
是肯定是不允许的

09:21.690 --> 09:22.690
浏览器是不允许

09:22.690 --> 09:23.690
读写文件的

09:23.690 --> 09:26.690
当然它允许有限的文件读写

09:26.690 --> 09:27.690
比方说浏览器上面

09:27.690 --> 09:28.690
有一个按钮

09:28.690 --> 09:29.690
让你上传文件

09:29.690 --> 09:31.690
那既然用户都选择的文件了

09:31.690 --> 09:32.690
表示用户真的想上传了

09:32.690 --> 09:34.690
那么用户选择那个文件

09:34.690 --> 09:36.690
浏览器让你读

09:36.690 --> 09:37.690
可以让你读

09:37.690 --> 09:38.690
但是其他文件

09:38.690 --> 09:39.690
是不绝对不让你读的

09:39.690 --> 09:41.690
有限的文件读写能力

09:41.690 --> 09:43.690
写就跟不要说了

09:43.690 --> 09:44.690
想都不要想

09:44.690 --> 09:45.690
想往里边写东西

09:45.690 --> 09:46.690
最多让你写个Cookie

09:46.690 --> 09:48.690
让你写个Docal Storage

09:48.690 --> 09:49.690
那都不是文件

09:49.690 --> 09:52.690
最终还是一个文件形式

09:52.690 --> 09:54.690
但它不是一个独立的文件

09:54.690 --> 09:57.690
它不能让你随意的操控文件

09:57.690 --> 09:58.690
当然除此之外

09:58.690 --> 10:01.690
还有很多理想做的时候都做不了

10:01.690 --> 10:04.690
以前我遇到一个很有意思的

10:04.690 --> 10:06.690
以前我来公司里边

10:06.690 --> 10:09.690
这个产品经理

10:09.690 --> 10:11.690
但是我们关系很好

10:11.690 --> 10:14.690
它让我在网站里边

10:14.690 --> 10:15.690
就用户访问我这个网站

10:15.690 --> 10:17.690
我要把它QQ号读取到

10:17.690 --> 10:18.690
我说兄弟

10:18.690 --> 10:19.690
那这个东西我倒是能做

10:19.690 --> 10:21.690
但是我在开发病毒

10:21.690 --> 10:23.690
怎么让用户中毒

10:23.690 --> 10:24.690
这是个问题

10:24.690 --> 10:27.690
我要给它解释一下

10:27.690 --> 10:29.690
所以说你像要做很多事情

10:29.690 --> 10:30.690
比如说你要获取

10:30.690 --> 10:32.690
操作系统里面的进程

10:32.690 --> 10:33.690
你要获取

10:33.690 --> 10:35.690
操作系统里面目前运行了哪些程序

10:35.690 --> 10:36.690
开了哪些窗口

10:36.690 --> 10:37.690
你怎么可能获取到

10:37.690 --> 10:38.690
用GS

10:38.690 --> 10:40.690
不是说GS是语言

10:40.690 --> 10:41.690
它不能输

10:41.690 --> 10:42.690
它当然能输

10:42.690 --> 10:43.690
它就是个说话的东西

10:43.690 --> 10:44.690
我就说

10:44.690 --> 10:45.690
用汉语说

10:45.690 --> 10:47.690
我想获取那个窗口

10:47.690 --> 10:48.690
QQ那个窗口

10:48.690 --> 10:50.690
我要看一下窗口里面有哪些东西

10:50.690 --> 10:52.690
能不能说我能说

10:52.690 --> 10:53.690
但是留言器不给我看

10:53.690 --> 10:54.690
那怎么办

10:54.690 --> 10:58.690
所以说它的能力是非常悠闲

10:58.690 --> 11:00.690
但是 know the GS

11:00.690 --> 11:01.690
它就不一样了

11:01.690 --> 11:03.690
know the GS的能力

11:03.690 --> 11:04.690
我们可以认为

11:04.690 --> 11:05.690
它的能力

11:05.690 --> 11:08.690
远远超过流浪期

11:08.690 --> 11:09.690
know the GS

11:09.690 --> 11:10.690
我们看它的图

11:10.690 --> 11:12.690
它跟流浪期的结构差不多

11:12.690 --> 11:14.690
所有的用GS远远都差不多

11:14.690 --> 11:16.690
你们以后会学移动端

11:16.690 --> 11:18.690
移动端也是这样子

11:18.690 --> 11:20.690
你能不能用ES说话呢

11:20.690 --> 11:21.690
这说话还是这样子说

11:21.690 --> 11:22.690
你的循环啊

11:22.690 --> 11:23.690
判断啊

11:23.690 --> 11:24.690
还这么写

11:24.690 --> 11:25.690
定义辩量啊

11:25.690 --> 11:26.690
还是这么写的

11:26.690 --> 11:28.690
没有任何区别

11:28.690 --> 11:29.690
那么它只是

11:29.690 --> 11:30.690
这个东西不见了

11:30.690 --> 11:31.690
web API不见了

11:31.690 --> 11:32.690
因为web API

11:32.690 --> 11:33.690
是流浪期给你提供的

11:33.690 --> 11:35.690
那么这里根本就没有了

11:35.690 --> 11:37.690
那么 know the 环境里边

11:37.690 --> 11:39.690
给你提供了 know the API

11:39.690 --> 11:40.690
我们后边会学习一些

11:40.690 --> 11:41.690
know the API

11:41.690 --> 11:42.690
就是我们这一张

11:42.690 --> 11:43.690
学习了 know the 核心

11:43.690 --> 11:45.690
就会学习它的一些 API

11:45.690 --> 11:46.690
那么这个 API

11:46.690 --> 11:47.690
它给你提供了

11:47.690 --> 11:50.690
提供了几乎所有能做的事情

11:50.690 --> 11:52.690
什么叫所有能做的事情

11:52.690 --> 11:54.690
就是你运行的这个GS

11:54.690 --> 11:56.690
可以完整的控制你的电脑

11:56.690 --> 11:58.690
可怕吧 吓人吧

11:58.690 --> 11:59.690
那有人会说

11:59.690 --> 12:00.690
那这么强大

12:00.690 --> 12:01.690
那为什么不直接

12:01.690 --> 12:02.690
就用 know the 环境

12:02.690 --> 12:03.690
来写单吗就行了

12:03.690 --> 12:04.690
为什么还要在

12:04.690 --> 12:05.690
流浪期环境里边写GS

12:05.690 --> 12:06.690
那问题是

12:06.690 --> 12:08.690
用户不安装你这个啊

12:08.690 --> 12:09.690
你的GS

12:09.690 --> 12:10.690
你要这样子写GS

12:10.690 --> 12:11.690
写 know the GS的话

12:11.690 --> 12:13.690
你只能在 know the 环境里边运行

12:13.690 --> 12:14.690
对吧

12:14.690 --> 12:15.690
用户不安装你的 know the

12:15.690 --> 12:17.690
它凭什么安装 know the 环境运行的

12:17.690 --> 12:18.690
它在安装什么的

12:18.690 --> 12:20.690
它是不是得安装那个

12:20.690 --> 12:21.690
流浪期啊

12:21.690 --> 12:22.690
流浪期是不是用户安装的最多

12:22.690 --> 12:25.690
所以说我们对给用户用的东西呢

12:25.690 --> 12:26.690
给用户用的东西呢

12:26.690 --> 12:28.690
还肯定是流浪期的

12:28.690 --> 12:30.690
肯定是在流浪期里边的GS

12:30.690 --> 12:32.690
加把 script 但是呢

12:32.690 --> 12:34.690
有些东西是不用给用户的

12:34.690 --> 12:36.690
比方说我们服务器

12:36.690 --> 12:38.690
服务器是不是放在远程的

12:38.690 --> 12:39.690
单独于它集团机里边

12:39.690 --> 12:41.690
用户是不会直接用它的

12:41.690 --> 12:42.690
用户是请求它

12:42.690 --> 12:43.690
对不对

12:43.690 --> 12:45.690
这些服务器是我们自己的

12:45.690 --> 12:46.690
那我们自己是不是可以

12:46.690 --> 12:47.690
搭建任何环境

12:47.690 --> 12:49.690
那么我们就需要一个完整的

12:49.690 --> 12:51.690
能够控制整个计算机的

12:51.690 --> 12:52.690
这么一个程序

12:52.690 --> 12:54.690
我们要监听请求

12:54.690 --> 12:55.690
像这些东西流浪期

12:55.690 --> 12:56.690
怎么可能办得到

12:56.690 --> 12:58.690
监听请求 处理请求

12:58.690 --> 13:00.690
保存一些文件到服务期

13:00.690 --> 13:01.690
对不对

13:01.690 --> 13:02.690
像这些能力

13:02.690 --> 13:03.690
我就必须要控制

13:03.690 --> 13:04.690
整个流浪

13:04.690 --> 13:05.690
整个服务器环境

13:05.690 --> 13:06.690
那么就必须要使用

13:06.690 --> 13:07.690
loader接使了

13:07.690 --> 13:09.690
当然使用加把

13:09.690 --> 13:10.690
使用 c下

13:10.690 --> 13:11.690
使用 PHP

13:11.690 --> 13:12.690
这些后端语言都可以

13:12.690 --> 13:15.690
loader只是一种选择

13:15.690 --> 13:16.690
那么这里有个

13:16.690 --> 13:17.690
分层结构的对比图

13:17.690 --> 13:19.690
大家看一下吧

13:19.690 --> 13:21.690
这个这个图里面

13:21.690 --> 13:23.690
基本上看得很清楚了

13:23.690 --> 13:25.690
咱们的介石

13:25.690 --> 13:26.690
因为这个图

13:26.690 --> 13:27.690
我也不知道该怎么去

13:27.690 --> 13:28.690
化妆里面明白

13:28.690 --> 13:29.690
我就解释一下

13:29.690 --> 13:31.690
你看这个介石

13:31.690 --> 13:33.690
你介石里边写了一些代码

13:33.690 --> 13:34.690
代码会交给谁来运行

13:34.690 --> 13:35.690
交给流浪期

13:35.690 --> 13:36.690
流浪期他要解释

13:36.690 --> 13:37.690
把它解释成为什么

13:37.690 --> 13:40.690
别把它解释成为c代码

13:40.690 --> 13:41.690
c语言代码

13:41.690 --> 13:42.690
c加加语言代码

13:42.690 --> 13:43.690
那么这个代码

13:43.690 --> 13:44.690
是可以被操作系统识别的

13:44.690 --> 13:46.690
那么交给操作系统

13:46.690 --> 13:47.690
操作系统能运行

13:47.690 --> 13:48.690
操作系统干嘛呢

13:48.690 --> 13:49.690
他管理硬件

13:49.690 --> 13:51.690
这就是一个典型的分层结构

13:51.690 --> 13:52.690
我们的代码交给流浪期

13:52.690 --> 13:53.690
流浪期交给操作系统

13:53.690 --> 13:55.690
操作系统交给硬件

13:55.690 --> 13:56.690
那么我们这里的箭头

13:56.690 --> 13:57.690
是不是变得

13:57.690 --> 13:58.690
是不是比较细啊

13:58.690 --> 13:59.690
相对右边的头

13:59.690 --> 14:00.690
是不是比较细

14:00.690 --> 14:01.690
为什么比较细呢

14:01.690 --> 14:02.690
是因为我们能做的

14:02.690 --> 14:03.690
事情很少

14:03.690 --> 14:04.690
流浪期不准我们

14:04.690 --> 14:05.690
做了一些事

14:05.690 --> 14:06.690
比方说我要操作文件

14:07.690 --> 14:08.690
流浪期首先没有给我们

14:08.690 --> 14:09.690
提供这样的API

14:10.690 --> 14:12.690
那么你根本就没法写一个代码

14:12.690 --> 14:13.690
哪怕你强行写了一些

14:13.690 --> 14:15.690
你自创了一些API

14:15.690 --> 14:16.690
流浪期不认识

14:16.690 --> 14:17.690
不甩利

14:17.690 --> 14:18.690
它没给你提供这个功能

14:19.690 --> 14:20.690
而漏的环境不一样

14:20.690 --> 14:21.690
漏的环境

14:21.690 --> 14:22.690
我们做了能做很多事

14:22.690 --> 14:24.690
在这个比方出的箭头

14:24.690 --> 14:26.690
我们把代码写好了过

14:26.690 --> 14:27.690
交给漏斗运行

14:27.690 --> 14:29.690
漏斗它把它转换成

14:29.690 --> 14:30.690
它里面内置的一个

14:30.690 --> 14:31.690
微拔引擎

14:31.690 --> 14:32.690
就是

14:32.690 --> 14:33.690
谷歌流浪期里面的

14:33.690 --> 14:34.690
微拔引擎来进行解释

14:34.690 --> 14:35.690
它改过的

14:35.690 --> 14:36.690
还是不少的东西

14:37.690 --> 14:38.690
然后解释我们的解释语言

14:39.690 --> 14:41.690
并且它给你提供的API能力

14:41.690 --> 14:42.690
就很强了

14:42.690 --> 14:43.690
你可以用很多的API

14:43.690 --> 14:44.690
那么这些API呢

14:44.690 --> 14:45.690
漏的都能识别

14:45.690 --> 14:46.690
它把它转换成操作系统

14:46.690 --> 14:47.690
能认识的代码

14:47.690 --> 14:48.690
因为操作系统给你

14:48.690 --> 14:50.690
提供的能力是非常强大的

14:50.690 --> 14:51.690
其实我们流浪期

14:51.690 --> 14:53.690
它作为一个操作系统的应用

14:54.690 --> 14:55.690
跟什么QQ

14:55.690 --> 14:57.690
安装了什么360

14:57.690 --> 14:58.690
什么那个

15:00.690 --> 15:02.690
一些杀毒软件

15:02.690 --> 15:03.690
微信用对吧

15:04.690 --> 15:05.690
没有什么本质区别

15:05.690 --> 15:07.690
流浪期它是一个应用程序

15:08.690 --> 15:09.690
所以说你能安装流浪期的时候

15:09.690 --> 15:11.690
一定要安装那些大厂的

15:11.690 --> 15:13.690
别人认为流浪期很安全

15:13.690 --> 15:14.690
它不安全的

15:14.690 --> 15:16.690
因为它是在操作系统上

15:16.690 --> 15:17.690
安装的应用

15:17.690 --> 15:19.690
它可以完整的控制你操作系统的

15:19.690 --> 15:20.690
你知道吗

15:20.690 --> 15:22.690
如果说我写一个流浪期

15:22.690 --> 15:23.690
我可以把你操作系统里的

15:23.690 --> 15:24.690
所有的

15:24.690 --> 15:25.690
但我你也全部给你读到

15:26.690 --> 15:28.690
因为我是在操作系统上安装的

15:28.690 --> 15:30.690
因此你就要安装

15:30.690 --> 15:31.690
那种大厂的流浪期

15:31.690 --> 15:32.690
像什么

15:32.690 --> 15:33.690
而且大厂的

15:33.690 --> 15:34.690
还要经常那种

15:34.690 --> 15:35.690
信得过的

15:35.690 --> 15:36.690
比方说

15:36.690 --> 15:37.690
Kron

15:37.690 --> 15:38.690
Kron流浪期

15:38.690 --> 15:39.690
火葫

15:39.690 --> 15:40.690
这些

15:40.690 --> 15:41.690
被

15:41.690 --> 15:43.690
通用的这些流浪期

15:43.690 --> 15:45.690
像一些什么360流浪期

15:45.690 --> 15:46.690
我是不太建议安装的

15:46.690 --> 15:47.690
它可以做任何你想不到的事情

15:47.690 --> 15:49.690
你都不知道它干了什么

15:49.690 --> 15:50.690
因为它是个

15:50.690 --> 15:51.690
你不要认为流浪期

15:51.690 --> 15:52.690
能做的事情很有钱

15:52.690 --> 15:53.690
它啥都能做

15:53.690 --> 15:54.690
它是安装在操作系统上的

15:54.690 --> 15:55.690
同样的

15:55.690 --> 15:56.690
我们Loade

15:56.690 --> 15:57.690
是不是安装过的

15:57.690 --> 15:58.690
Loade环境是安装过的

15:58.690 --> 15:59.690
它也是安装在操作系统上的

15:59.690 --> 16:01.690
它也是可以完整的

16:01.690 --> 16:02.690
是操作系统的

16:02.690 --> 16:03.690
对吧

16:03.690 --> 16:04.690
因此我们的GS

16:04.690 --> 16:05.690
只要它认

16:05.690 --> 16:06.690
我们的GS的里面二代

16:06.690 --> 16:07.690
那么

16:07.690 --> 16:08.690
它就会把它翻译成

16:08.690 --> 16:09.690
操作系统的接口

16:09.690 --> 16:10.690
调整操作系统

16:10.690 --> 16:11.690
然后管理计算基因键

16:11.690 --> 16:12.690
因此Loade里面

16:12.690 --> 16:13.690
也可以做任何事情

16:13.690 --> 16:15.690
这边是因为

16:15.690 --> 16:16.690
流浪期不管

16:16.690 --> 16:18.690
你想做这些事情

16:18.690 --> 16:19.690
流浪期不甩利

16:19.690 --> 16:20.690
不让你做

16:20.690 --> 16:21.690
Loade它全部让你做的

16:21.690 --> 16:23.690
很多事情都让你做

16:23.690 --> 16:24.690
因此 Loade

16:24.690 --> 16:25.690
新建一个文件

16:25.690 --> 16:26.690
在C盘D盘

16:26.690 --> 16:27.690
新建一个文件

16:27.690 --> 16:28.690
甚至修改

16:28.690 --> 16:29.690
我们的系统注册表

16:29.690 --> 16:30.690
新建环境

16:30.690 --> 16:31.690
啥都能做

16:31.690 --> 16:32.690
啥都能做的

16:32.690 --> 16:33.690
我告诉你

16:33.690 --> 16:34.690
这就是

16:34.690 --> 16:36.690
它们的区别

16:36.690 --> 16:38.690
它的平台结构

16:38.690 --> 16:39.690
Loade

16:39.690 --> 16:40.690
因为它提供了

16:40.690 --> 16:41.690
完整的控制计算力能力

16:41.690 --> 16:42.690
我们几乎可以

16:42.690 --> 16:43.690
通过它提供的接口

16:43.690 --> 16:45.690
实现对整个操作系统的控制

16:45.690 --> 16:47.690
因为我们边写服务器应用

16:47.690 --> 16:48.690
我们一定要

16:48.690 --> 16:49.690
对整个操作系统

16:49.690 --> 16:50.690
控制的权限

16:51.690 --> 16:52.690
OK

16:52.690 --> 16:53.690
那么这就是

16:53.690 --> 16:54.690
Loade

16:54.690 --> 16:55.690
什么是Loade

16:55.690 --> 16:56.690
通过这两个方面

16:56.690 --> 16:57.690
给它解释

16:57.690 --> 16:58.690
一个是它运行线

16:58.690 --> 16:59.690
一个运行环境

16:59.690 --> 17:00.690
它到底怎么谈

17:00.690 --> 17:01.690
大家有兴趣去查一下

17:01.690 --> 17:02.690
咱们的

17:04.690 --> 17:05.690
它的历史

17:06.690 --> 17:07.690
那有些人就要问了

17:07.690 --> 17:09.690
那既然java

17:09.690 --> 17:11.690
可以开发一个服务器应用程序

17:11.690 --> 17:13.690
ccap也可以开发

17:13.690 --> 17:15.690
那为什么要用Loade

17:15.690 --> 17:17.690
为什么现在Loade那么火

17:17.690 --> 17:19.690
是因为这个原因

17:20.690 --> 17:21.690
Loade

17:21.690 --> 17:22.690
它是一个

17:22.690 --> 17:24.690
它是一个单线程的

17:24.690 --> 17:25.690
应该就是

17:25.690 --> 17:26.690
对

17:26.690 --> 17:27.690
它是一个单线程的

17:27.690 --> 17:28.690
应用程序

17:28.690 --> 17:29.690
它使用的是

17:29.690 --> 17:31.690
一步毁掉模式

17:31.690 --> 17:32.690
对吧

17:32.690 --> 17:33.690
一步模式

17:33.690 --> 17:35.690
单线程一步是它的特点

17:35.690 --> 17:37.690
单线程一步有个好处在于什么

17:37.690 --> 17:38.690
它没有那种

17:38.690 --> 17:39.690
线程之间的竞争

17:40.690 --> 17:41.690
线程之间的竞争

17:41.690 --> 17:42.690
这样的控制起来

17:42.690 --> 17:43.690
是要出很多问题的

17:43.690 --> 17:44.690
因此会导致java

17:44.690 --> 17:45.690
一些很多人

17:45.690 --> 17:46.690
以为难以控制

17:46.690 --> 17:48.690
但不是那么好写

17:48.690 --> 17:49.690
另外一个

17:50.690 --> 17:51.690
重要的原因

17:51.690 --> 17:52.690
由于单线程

17:52.690 --> 17:54.690
它的IO处理速度

17:54.690 --> 17:55.690
是非常快的

17:55.690 --> 17:56.690
怎么叫IO处理速度

17:57.690 --> 17:58.690
IO表示

17:59.690 --> 18:00.690
Input

18:01.690 --> 18:02.690
Output

18:03.690 --> 18:05.690
因为它没有线程之间的切换

18:05.690 --> 18:06.690
实际上Loade的环境里面

18:06.690 --> 18:07.690
是有很多线程的

18:07.690 --> 18:08.690
只不过我们在

18:08.690 --> 18:09.690
java里面代码

18:09.690 --> 18:11.690
是运行在一个线程里面的

18:11.690 --> 18:12.690
不过现在Loade的环境

18:12.690 --> 18:14.690
也支持开启多个线程的

18:14.690 --> 18:15.690
只不过我们平时

18:15.690 --> 18:16.690
不太会去用它

18:16.690 --> 18:17.690
我们了解一下就行了

18:17.690 --> 18:19.690
我们还是认为

18:19.690 --> 18:20.690
我们在Loade里面写的

18:20.690 --> 18:21.690
java代码

18:21.690 --> 18:22.690
还是在单个线程里面

18:22.690 --> 18:23.690
运行的

18:23.690 --> 18:24.690
主线程

18:24.690 --> 18:25.690
因此

18:25.690 --> 18:27.690
在主线程里面去操作一些文件

18:27.690 --> 18:28.690
操作网络

18:28.690 --> 18:30.690
网络的网卡

18:30.690 --> 18:31.690
这些东西

18:31.690 --> 18:32.690
由于在一个线程

18:32.690 --> 18:34.690
它不会在线程之间切换

18:34.690 --> 18:36.690
线程之间切换是比较耗费资源的

18:38.690 --> 18:39.690
有些人想问

18:39.690 --> 18:40.690
如果说多个线程

18:40.690 --> 18:41.690
我是不是可以

18:41.690 --> 18:43.690
充分地利用CPU的多核

18:43.690 --> 18:44.690
是可以的

18:44.690 --> 18:45.690
但是

18:45.690 --> 18:46.690
现在的Loade环境

18:46.690 --> 18:47.690
已经经过优化了

18:47.690 --> 18:49.690
它已经能够充分利用多核了

18:49.690 --> 18:50.690
一切代码

18:50.690 --> 18:51.690
虽然在一个线程里面

18:51.690 --> 18:52.690
它发现多个CPU的话

18:52.690 --> 18:54.690
它会给你进行处理的

18:54.690 --> 18:55.690
所以也不用担心了

18:55.690 --> 18:57.690
这些事情它都帮你做了

18:57.690 --> 18:58.690
因此

18:59.690 --> 19:01.690
我们在Loade环境里面

19:01.690 --> 19:03.690
IO的速度是比较快的

19:04.690 --> 19:06.690
它没有切换之间的开销

19:06.690 --> 19:08.690
而且没有这种线程之间的竞争

19:09.690 --> 19:10.690
因此

19:10.690 --> 19:12.690
如果说你做一个简单的服务器

19:12.690 --> 19:13.690
就是

19:13.690 --> 19:14.690
哪一个请求

19:14.690 --> 19:15.690
我给你一个文件的内容

19:15.690 --> 19:16.690
哪一个请求

19:16.690 --> 19:17.690
我给你一个文件的内容

19:17.690 --> 19:19.690
这样子做的话

19:19.690 --> 19:20.690
Loade的执行效率

19:20.690 --> 19:21.690
肯定要比加拿高

19:21.690 --> 19:22.690
这毫无疑问的

19:22.690 --> 19:24.690
但是Loade不适合做什么呢

19:24.690 --> 19:26.690
不适合做巨大的运算量

19:27.690 --> 19:28.690
要你哪一个请求

19:28.690 --> 19:30.690
我要经过十万次运算

19:30.690 --> 19:31.690
我才能拿到结果

19:31.690 --> 19:33.690
那么这种复杂的运算

19:33.690 --> 19:35.690
Loade不太适合做

19:35.690 --> 19:36.690
因为加碼

19:36.690 --> 19:38.690
它是可以多个线程来

19:38.690 --> 19:39.690
同时进行运算的

19:39.690 --> 19:40.690
叫并行运算

19:41.690 --> 19:42.690
而且它是

19:42.690 --> 19:43.690
它是那个什么

19:43.690 --> 19:44.690
编译型运言

19:44.690 --> 19:45.690
它的运算速度肯定要比

19:45.690 --> 19:46.690
Loade快

19:47.690 --> 19:48.690
我们平时说

19:48.690 --> 19:49.690
一个语言它快

19:49.690 --> 19:50.690
一个语言它慢

19:50.690 --> 19:51.690
不能单一的这样说的

19:51.690 --> 19:53.690
要分析它的角度的

19:53.690 --> 19:54.690
这样Loade的结实

19:54.690 --> 19:55.690
虽然它是解释型的语言

19:55.690 --> 19:56.690
它仍然是解释型的

19:56.690 --> 19:58.690
但是它IO速度快

19:58.690 --> 19:59.690
当时Loade出来

19:59.690 --> 20:00.690
还就是因为

20:00.690 --> 20:01.690
它要做一个

20:01.690 --> 20:03.690
它要做一个就是

20:04.690 --> 20:07.690
快速的IO的这么一个

20:07.690 --> 20:08.690
浮气应用

20:08.690 --> 20:09.690
所以说

20:09.690 --> 20:10.690
它最终选择了Loade

20:10.690 --> 20:11.690
这个单线程环境

20:11.690 --> 20:13.690
就结实个单线程环境

20:13.690 --> 20:15.690
Soio速度是非常快的

20:15.690 --> 20:17.690
那么但是它不好的地方在呢

20:17.690 --> 20:18.690
不好的地方在于

20:18.690 --> 20:20.690
它的运算速度不快

20:21.690 --> 20:22.690
你要拿到一个结果

20:22.690 --> 20:23.690
你要经过很多的运算

20:23.690 --> 20:24.690
它就没有那么快了

20:24.690 --> 20:25.690
我们要理解它的优势

20:25.690 --> 20:26.690
它的掠视

20:27.690 --> 20:28.690
然后我们看一下

20:28.690 --> 20:29.690
Loade的观望

20:30.690 --> 20:31.690
观望呢

20:31.690 --> 20:32.690
主要是告诉它怎么去下载

20:32.690 --> 20:33.690
相信了

20:33.690 --> 20:34.690
大家都现在都已经下载了

20:34.690 --> 20:35.690
你们点这个东西进去看就行了

20:35.690 --> 20:37.690
我这里不太过头说了

20:37.690 --> 20:38.690
这才观望

20:38.690 --> 20:39.690
然后还有一个民间中文网

20:39.690 --> 20:40.690
你们可以去看一下

20:40.690 --> 20:41.690
这是什么是Loade

20:42.690 --> 20:43.690
然后接下来我们来看一下

20:43.690 --> 20:45.690
那学的东西有什么用呢

20:45.690 --> 20:46.690
为什么现在这么多公司

20:46.690 --> 20:48.690
要求你会Loade

20:48.690 --> 20:49.690
也没有说要求

20:49.690 --> 20:50.690
当然你为了给我

20:50.690 --> 20:52.690
肯定会提升竞争力的

20:52.690 --> 20:56.690
很多异线的城市里边

20:56.690 --> 20:57.690
很多公司都要求你

20:57.690 --> 21:00.690
至少熟悉一门服务专技术

21:02.690 --> 21:04.690
那么你只要学习得着就行了

21:04.690 --> 21:05.690
有些公司让他要求你

21:05.690 --> 21:07.690
说你要会什么

21:07.690 --> 21:09.690
Java,CHAB,PHP

21:09.690 --> 21:10.690
当中的一种

21:10.690 --> 21:12.690
就是让你熟悉一个服务专

21:12.690 --> 21:13.690
你说一天回去慌了

21:13.690 --> 21:15.690
那我们没有学怎么办

21:15.690 --> 21:16.690
不用担心

21:16.690 --> 21:18.690
因为为什么我告诉大家为什么

21:18.690 --> 21:21.690
他要求你会Java,CHAB,PHP

21:21.690 --> 21:22.690
当中的一种

21:22.690 --> 21:24.690
就是要希望你熟悉一种

21:24.690 --> 21:26.690
后端技术

21:26.690 --> 21:27.690
为什么让你熟悉一种

21:27.690 --> 21:28.690
后端技术呢

21:28.690 --> 21:30.690
不是让你去写后端代吧

21:30.690 --> 21:32.690
而是让你以后

21:32.690 --> 21:33.690
到公司里边跟

21:33.690 --> 21:35.690
后端人员沟通的时候

21:35.690 --> 21:37.690
不至于产生太大的沟通障碍

21:37.690 --> 21:38.690
因为我们知道

21:38.690 --> 21:39.690
后端人员多多少少

21:39.690 --> 21:40.690
要学点前端的

21:40.690 --> 21:41.690
他学的当然很浮浅

21:41.690 --> 21:42.690
他只学了

21:42.690 --> 21:43.690
追击出来

21:43.690 --> 21:44.690
他们这些是介事

21:44.690 --> 21:45.690
对吧

21:45.690 --> 21:47.690
他其他人也搞不清楚了

21:47.690 --> 21:49.690
那么但是前端也是

21:49.690 --> 21:50.690
你要学点后端的东西

21:50.690 --> 21:52.690
这样子双方方面沟通

21:52.690 --> 21:53.690
你知道他在说什么

21:53.690 --> 21:54.690
他的困难在哪里

21:54.690 --> 21:56.690
他也知道你在说什么

21:56.690 --> 21:57.690
你的困难在哪里

21:57.690 --> 21:58.690
主要是方面沟通

21:58.690 --> 22:01.690
不是让你真正去写后端那种

22:01.690 --> 22:02.690
那么这个时候

22:02.690 --> 22:04.690
他要求你Java,CHAB,PHP

22:04.690 --> 22:06.690
其实他主要有很多

22:06.690 --> 22:07.690
很大一部分原因

22:07.690 --> 22:08.690
是因为我们前端

22:08.690 --> 22:10.690
会漏的比较少

22:10.690 --> 22:11.690
会漏的真的比较少

22:11.690 --> 22:13.690
很多人只是用漏的

22:13.690 --> 22:15.690
主要是用NPM安装一些东西

22:16.690 --> 22:18.690
他不是真的会用漏的

22:18.690 --> 22:19.690
所以说他会的比较少

22:19.690 --> 22:21.690
因此他可能公司

22:21.690 --> 22:23.690
他认为他默认你就不会漏的了

22:23.690 --> 22:24.690
当然你会漏的你肯定没问题

22:24.690 --> 22:26.690
他只要要求你前端会Java

22:26.690 --> 22:28.690
你会漏的一定没问题

22:28.690 --> 22:29.690
你不用担心

22:29.690 --> 22:31.690
前端肯定要用漏的

22:31.690 --> 22:33.690
肯定不用用Java的东西

22:33.690 --> 22:35.690
那么我们通常用漏的干嘛呢

22:35.690 --> 22:36.690
就像我们学的

22:36.690 --> 22:37.690
还是要有点用对吧

22:37.690 --> 22:38.690
除了沟通之外

22:38.690 --> 22:39.690
还要干嘛呢

22:39.690 --> 22:40.690
这里呢

22:40.690 --> 22:41.690
我给他说两个点

22:41.690 --> 22:43.690
一个是开发桌面应用程序

22:43.690 --> 22:46.690
比方说你你看VSCode

22:46.690 --> 22:48.690
咱们VSCode就是用漏的开发的

22:48.690 --> 22:50.690
漏的加上Electron

22:50.690 --> 22:51.690
对吧

22:51.690 --> 22:52.690
一个工具库

22:52.690 --> 22:55.690
那么他来一起来开发出这么一个桌面应用程序

22:55.690 --> 22:56.690
那么理论上

22:56.690 --> 22:58.690
你学了这个桌面应用开发的话

22:58.690 --> 23:00.690
你开发什么QQ

23:00.690 --> 23:02.690
微信这些都能开发的

23:02.690 --> 23:03.690
都能开发

23:03.690 --> 23:04.690
不过呢

23:04.690 --> 23:05.690
现在市面上

23:05.690 --> 23:08.690
要求你会用开发桌面应用程序的

23:08.690 --> 23:10.690
用前端会发开发桌面应用程序的

23:10.690 --> 23:11.690
还不多

23:11.690 --> 23:12.690
以后会不会躲起来

23:12.690 --> 23:13.690
我不知道

23:13.690 --> 23:14.690
我不知道

23:14.690 --> 23:15.690
看后边的发展

23:15.690 --> 23:16.690
现在呢

23:16.690 --> 23:17.690
还不多

23:17.690 --> 23:18.690
所以说呢

23:18.690 --> 23:19.690
我们这一门客呢

23:19.690 --> 23:20.690
肯定不会涉及

23:20.690 --> 23:21.690
如果说要学的话

23:21.690 --> 23:22.690
要单独开门课程

23:22.690 --> 23:23.690
好

23:23.690 --> 23:24.690
这个

23:24.690 --> 23:25.690
最重要的呢

23:25.690 --> 23:26.690
我们这一门客呢

23:26.690 --> 23:27.690
主要是学行漏的

23:27.690 --> 23:29.690
就是最常见的形式

23:29.690 --> 23:31.690
开发服务器应用程序

23:31.690 --> 23:32.690
那么这里什么意思呢

23:32.690 --> 23:33.690
感觉太抽象了

23:33.690 --> 23:35.690
给他分成两种来说

23:35.690 --> 23:37.690
就是我们以后到了公司里面呢

23:37.690 --> 23:39.690
通常会遇到这么两种

23:39.690 --> 23:41.690
前后端结构

23:41.690 --> 23:42.690
前后端分离

23:42.690 --> 23:44.690
如果说你以后去了一家公司

23:44.690 --> 23:45.690
它不是前后端分离

23:45.690 --> 23:47.690
还得用那种传统的方式

23:47.690 --> 23:48.690
那就有点兜了

23:48.690 --> 23:49.690
这公司有点兜了

23:49.690 --> 23:51.690
现在基本上都是前后端分离

23:51.690 --> 23:52.690
那么我们来看

23:52.690 --> 23:54.690
前后端分离的两种结构

23:54.690 --> 23:57.700
第一种结构

23:57.700 --> 23:59.700
要放大点

23:59.700 --> 24:01.700
第一种结构

24:01.700 --> 24:02.700
就是我们的浏览器

24:02.700 --> 24:03.700
当然不一定是浏览器

24:03.700 --> 24:04.700
也可能是手机应用

24:04.700 --> 24:05.700
无所谓的

24:05.700 --> 24:07.700
总之我们的客户端嘛

24:07.700 --> 24:10.700
它肯定是在任何的操作系统上

24:10.700 --> 24:12.700
也可能在Windows操作系统上

24:12.700 --> 24:14.700
也可能在Mac 苹果店上上

24:14.700 --> 24:16.700
因为你鬼知道用户在什么操作系统

24:16.700 --> 24:18.700
它只要有浏览器就行

24:18.700 --> 24:19.700
又可能在Android手机

24:19.700 --> 24:20.700
又可能在iOS就无所谓

24:20.700 --> 24:22.700
它总能发动请求嘛

24:22.700 --> 24:23.700
管它管理是啥玩意

24:23.700 --> 24:24.700
总能发动请求嘛

24:24.700 --> 24:25.700
它请求谁

24:25.700 --> 24:26.700
是不是请求服务器

24:26.700 --> 24:28.700
我们的Note服务器

24:28.700 --> 24:30.700
我们Note就充当一个服务器

24:30.700 --> 24:32.700
它直接跟我们的客户端进行交互

24:32.700 --> 24:34.700
就是它站在最前眼

24:34.700 --> 24:36.700
就是我们公司的最前台

24:36.700 --> 24:37.700
在面向客户的

24:37.700 --> 24:39.700
客户请求的就是我们的Note服务器

24:39.700 --> 24:41.700
说这个服务器得用Note来开发

24:41.700 --> 24:43.700
那么它一般运行在您那个操作系统上

24:43.700 --> 24:45.700
当然其他操作系统也可以

24:45.700 --> 24:46.700
比如说Windows

24:46.700 --> 24:47.700
当然Windows操作系统

24:47.700 --> 24:48.700
我不想吐槽了

24:48.700 --> 24:50.700
我之前买过一个服务器

24:50.700 --> 24:52.700
在阿利米尼上面

24:52.700 --> 24:53.700
今年给了多少钱

24:53.700 --> 24:55.700
一千块钱左右吧

24:55.700 --> 24:56.700
然后呢我之前

24:56.700 --> 24:57.700
以前没事

24:57.700 --> 24:59.700
我说要不他安个那个

24:59.700 --> 25:00.700
Windows操作系统上面去看一下

25:00.700 --> 25:01.700
打个Windows服务器

25:01.700 --> 25:02.700
Windows是可以打服务器的

25:02.700 --> 25:04.700
当然你可能不能用温室

25:04.700 --> 25:05.700
那些东西

25:05.700 --> 25:06.700
Windows Server

25:06.700 --> 25:08.700
我打了一个Windows Server2003

25:08.700 --> 25:09.700
还是比较早的

25:09.700 --> 25:10.700
结果一打完了

25:10.700 --> 25:12.700
看我的内存就啥都被安装

25:12.700 --> 25:14.700
我的内存已经占用了90%了

25:14.700 --> 25:16.700
我只有一级内存

25:16.700 --> 25:18.700
服务器我不可能买那么多内存

25:18.700 --> 25:19.700
服务器内存很贵的

25:19.700 --> 25:20.700
所以说

25:20.700 --> 25:21.700
我一看

25:21.700 --> 25:22.700
天啊

25:22.700 --> 25:23.700
吓死人了

25:23.700 --> 25:24.700
赶快把它卸载了

25:24.700 --> 25:25.700
现在杀了

25:25.700 --> 25:26.700
我们一般服务器

25:26.700 --> 25:27.700
都是Linux操作系统

25:27.700 --> 25:28.700
当然可以有别的操作系统

25:28.700 --> 25:30.700
我们的Note的

25:30.700 --> 25:31.700
我们写的代码

25:31.700 --> 25:33.700
就运行在这样的操作系统上

25:33.700 --> 25:34.700
那就是说

25:34.700 --> 25:35.700
现在学习期间

25:35.700 --> 25:36.700
我是不是要

25:36.700 --> 25:37.700
也要安装一个Linux操作系统

25:37.700 --> 25:38.700
不用

25:38.700 --> 25:39.700
学习期间你就用Windows

25:39.700 --> 25:41.700
它在Windows上也没问题

25:41.700 --> 25:42.700
因此

25:42.700 --> 25:43.700
你将来部署的时候

25:43.700 --> 25:45.700
因为我们还有一门客

25:45.700 --> 25:46.700
叫做部署

25:46.700 --> 25:48.700
有老师专门的录制

25:48.700 --> 25:50.700
我这里就不带过多说了

25:50.700 --> 25:51.700
我们写完了之后

25:51.700 --> 25:52.700
你放心

25:52.700 --> 25:53.700
你写得太满心情可以的

25:53.700 --> 25:54.700
Linux运行的

25:54.700 --> 25:55.700
没问题的

25:55.700 --> 25:57.700
我们就写好一个Note的应用

25:57.700 --> 25:59.700
放到Linux操作系统

25:59.700 --> 26:00.700
因为它对整个操作系统

26:00.700 --> 26:02.700
有完整的控制权限

26:02.700 --> 26:03.700
它什么都能做

26:03.700 --> 26:04.700
所以说

26:04.700 --> 26:05.700
它当然能够监听

26:05.700 --> 26:06.700
这个操作系统的网卡

26:06.700 --> 26:07.700
这个硬件网卡

26:07.700 --> 26:08.700
有被收到请求

26:08.700 --> 26:09.700
收到请求的话

26:09.700 --> 26:10.700
我进行处理

26:10.700 --> 26:11.700
处理请求通过网卡

26:11.700 --> 26:12.700
把数据发送回去

26:12.700 --> 26:14.700
而且在处理请求的过程中

26:14.700 --> 26:16.700
我还可以去访问数据库

26:16.700 --> 26:17.700
像这些东西在浏览器环境里面

26:17.700 --> 26:18.700
能运行吗

26:18.700 --> 26:19.700
你把它想象成

26:19.700 --> 26:20.700
这个操作系统里面

26:20.700 --> 26:21.700
服务器是个浏览器环境

26:21.700 --> 26:23.700
你想可能去操作什么数据库

26:23.700 --> 26:25.700
数据库来干嘛的

26:25.700 --> 26:26.700
来存处数据的

26:26.700 --> 26:28.700
把数据持久的存处下来

26:28.700 --> 26:30.700
像我们平时用的

26:30.700 --> 26:31.700
什么辨量的那些存处据

26:31.700 --> 26:32.700
都是在内存里面

26:32.700 --> 26:33.700
影视的

26:33.700 --> 26:34.700
一下就消失了

26:34.700 --> 26:36.700
我们要把持久的存处下来

26:36.700 --> 26:37.700
就必须要用一些文件

26:37.700 --> 26:38.700
文件系统

26:38.700 --> 26:39.700
那么数据库是一种

26:39.700 --> 26:40.700
非常优秀的管理

26:40.700 --> 26:42.700
文件里面数据的系统

26:43.700 --> 26:44.700
我们后面会说

26:44.700 --> 26:46.700
那么这里就是一个

26:46.700 --> 26:47.700
这是地种结构

26:47.700 --> 26:48.700
这种结构一般会出现在

26:48.700 --> 26:50.700
无一型的站点上

26:50.700 --> 26:52.700
非常非常小的站点

26:52.700 --> 26:53.700
比方说什么

26:53.700 --> 26:54.700
个人博客

26:54.700 --> 26:56.700
或者是公司的官网

26:56.700 --> 26:58.700
一个非常非常小的

26:58.700 --> 26:59.700
当然小公司的官网

26:59.700 --> 27:00.700
就一个什么

27:00.700 --> 27:01.700
做酒的

27:01.700 --> 27:03.700
卖酒的

27:03.700 --> 27:04.700
卖鞋的

27:04.700 --> 27:06.700
就搞一个官网出来

27:06.700 --> 27:09.700
那么这种系统不复杂

27:09.700 --> 27:11.700
那么不用后端人员参与

27:11.700 --> 27:12.700
前端开发者就直接把搞定了

27:12.700 --> 27:13.700
所以你们学了我们

27:13.700 --> 27:14.700
这门课之后

27:14.700 --> 27:15.700
你自己可以搞定整个网站

27:15.700 --> 27:16.700
没问题的

27:16.700 --> 27:18.700
你自己搭数据库

27:18.700 --> 27:19.700
然后自己写个服务器应用

27:19.700 --> 27:20.700
来处理请求

27:20.700 --> 27:21.700
然后再写浏览器

27:21.700 --> 27:22.700
就是我们以前的

27:22.700 --> 27:23.700
前端开发用VU写

27:23.700 --> 27:24.700
用Reactor写都可以

27:24.700 --> 27:25.700
然后他去请求

27:25.700 --> 27:26.700
我们自己的服务器

27:26.700 --> 27:27.700
服务器操作数据库

27:27.700 --> 27:28.700
导导数据

27:28.700 --> 27:29.700
然后组装结果

27:29.700 --> 27:30.700
给我们返回

27:30.700 --> 27:31.700
我们都可以做了

27:33.700 --> 27:35.700
那么这种场景

27:35.700 --> 27:36.700
我们漏的服务器

27:36.700 --> 27:37.700
还要做很多事情

27:37.700 --> 27:38.700
包括对请求的处理

27:38.700 --> 27:39.700
对吧 收到请求

27:39.700 --> 27:40.700
要怎么处理

27:40.700 --> 27:41.700
处理完要怎么去响应

27:41.700 --> 27:42.700
响应我们的请求

27:42.700 --> 27:44.700
给我们的浏览器

27:44.700 --> 27:45.700
已经跟数据库

27:45.700 --> 27:46.700
怎么去交互

27:46.700 --> 27:47.700
我们可能在处理的过程中

27:47.700 --> 27:49.700
要从数据库里面拿数据

27:49.700 --> 27:51.700
以及各种业务逻辑

27:51.700 --> 27:52.700
什么叫业务逻辑

27:52.700 --> 27:53.700
就是跟功能相关的

27:53.700 --> 27:54.700
登录

27:54.700 --> 27:55.700
全线

27:55.700 --> 27:56.700
对吧

27:56.700 --> 27:57.700
审核

27:57.700 --> 27:58.700
对不对

27:58.700 --> 27:59.700
发布一篇文章

27:59.700 --> 28:01.700
这些东西都是业务逻辑

28:01.700 --> 28:02.700
发布文章的时候

28:02.700 --> 28:03.700
数据怎么去验证

28:03.700 --> 28:04.700
这些东西

28:04.700 --> 28:05.700
全是业务逻辑

28:05.700 --> 28:06.700
那么这些东西

28:06.700 --> 28:07.700
我们都要在这个

28:07.700 --> 28:08.700
漏的服务器里面处理

28:08.700 --> 28:09.700
这是非常危险的单点

28:09.700 --> 28:11.700
访问的人也不多

28:11.700 --> 28:13.700
更加场景的是第二种结构

28:13.700 --> 28:14.700
你们以后到公司

28:14.700 --> 28:18.210
绝大部分是第二种结构

28:18.210 --> 28:20.210
我画了一个简易图

28:20.210 --> 28:21.210
就是我们的浏览器

28:21.210 --> 28:22.210
还是一样

28:22.210 --> 28:24.210
请求我们的前台

28:24.210 --> 28:26.210
我们的漏的服务器

28:26.210 --> 28:27.210
那么这个漏的服务器

28:27.210 --> 28:29.210
它当成一个中间层

28:29.210 --> 28:30.210
它是不是在中间

28:30.210 --> 28:31.210
在浏览器

28:31.210 --> 28:32.210
我们的后端服务器中间

28:32.210 --> 28:33.210
它当成一个中间层

28:33.210 --> 28:34.210
也就是它自己

28:34.210 --> 28:37.210
不做太多的事情

28:37.210 --> 28:39.210
不做太多的事情

28:39.210 --> 28:41.210
然后它只是简单的

28:41.210 --> 28:42.210
把我们的请求

28:42.210 --> 28:43.210
发给后端服务器

28:43.210 --> 28:44.210
后端服务器就是

28:44.210 --> 28:45.210
我们用Java

28:45.210 --> 28:46.210
C-Sharp

28:46.210 --> 28:47.210
PGP

28:47.210 --> 28:48.210
这种结构

28:48.210 --> 28:49.210
它不太用PGP

28:49.210 --> 28:50.210
一般互用Java

28:50.210 --> 28:51.210
或者是C-Sharp

28:51.210 --> 28:52.210
Java居多

28:52.210 --> 28:54.210
那么写这么一个后端服务器

28:54.210 --> 28:56.210
那我们的数据存在哪呢

28:56.210 --> 28:58.210
存在后端服务器上

28:58.210 --> 28:59.210
有烂气请求来了

28:59.210 --> 29:00.210
到我们这儿

29:00.210 --> 29:02.210
我们就是一个接待员

29:02.210 --> 29:03.210
你要干嘛

29:03.210 --> 29:04.210
你要搬你什么业务

29:04.210 --> 29:06.210
我要搬你一张银行卡

29:06.210 --> 29:07.210
那行吧

29:07.210 --> 29:08.210
我把你的要求

29:08.210 --> 29:09.210
交给我们后边的经理

29:09.210 --> 29:10.210
我们的后端服务器

29:10.210 --> 29:11.210
来处理这件事

29:11.210 --> 29:12.210
那么后端服务器

29:12.210 --> 29:13.210
里面是不是有数据库

29:13.210 --> 29:14.210
我这没画出来

29:14.210 --> 29:15.210
后端服务器

29:15.210 --> 29:16.210
它有自己的数据库

29:16.210 --> 29:17.210
一套完整的业务数据库

29:17.210 --> 29:18.210
那么它根据

29:18.210 --> 29:19.210
你这个用户

29:19.210 --> 29:20.210
是不是搬你过银行卡

29:20.210 --> 29:21.210
搬你过银行卡

29:21.210 --> 29:22.210
我不给你搬你了

29:22.210 --> 29:24.210
没有搬你过银行卡

29:24.210 --> 29:26.210
是不是有没有就是

29:26.210 --> 29:27.210
语气记录之类的

29:27.210 --> 29:28.210
忘记发烫的东西

29:28.210 --> 29:29.210
审核一下

29:29.210 --> 29:30.210
没问题了

29:30.210 --> 29:31.210
ok 那么我给你一个想法

29:31.210 --> 29:32.210
我告诉你

29:32.210 --> 29:33.210
什么时候可以搬完

29:33.210 --> 29:35.210
那么它就再转发一下

29:35.210 --> 29:36.210
我们老大说了

29:36.210 --> 29:37.210
什么时候可以搬完

29:37.210 --> 29:38.210
那么对于这个客户而言

29:38.210 --> 29:39.210
他是不知道的

29:39.210 --> 29:40.210
他认为很简单

29:40.210 --> 29:42.210
我要把银行卡交给他了

29:42.210 --> 29:43.210
他告诉我结果了

29:43.210 --> 29:44.210
我多久的

29:44.210 --> 29:45.210
多久可以拿到这个银行卡

29:45.210 --> 29:46.210
他就不知道

29:46.210 --> 29:47.210
后边有这么一套过程

29:47.210 --> 29:48.210
说跟

29:48.210 --> 29:50.210
也就我们的那个服务器

29:50.210 --> 29:51.210
充当一个前台的角色

29:51.210 --> 29:53.210
跟牛郎琪之前打交道

29:53.210 --> 29:54.210
轻松很多

29:54.210 --> 29:56.210
真正的后端庞大的

29:56.210 --> 29:58.210
业务逻辑是在后端写的

29:58.210 --> 29:59.210
那么我这里为什么

29:59.210 --> 30:00.210
还花了一个地避呢

30:00.210 --> 30:01.210
就数据控了

30:01.210 --> 30:02.210
因为我们这里呢

30:02.210 --> 30:03.210
可能还是要记录一些东西

30:03.210 --> 30:04.210
比方说用户

30:04.210 --> 30:06.210
有多少用户来了

30:06.210 --> 30:07.210
以及呢

30:07.210 --> 30:09.210
就是用户的请求日子

30:09.210 --> 30:10.210
我们报错了

30:10.210 --> 30:12.210
报错了错误日子

30:12.210 --> 30:13.210
都会记录在数据库里面

30:13.210 --> 30:15.210
包括用户的一些偏好设置

30:15.210 --> 30:17.210
我这个用户喜欢

30:17.210 --> 30:19.210
浏览什么哪些网页

30:19.210 --> 30:20.210
经常访问哪些网页

30:20.210 --> 30:21.210
一些偏好的设置呢

30:21.210 --> 30:23.210
我们可以帮到数据库里面

30:23.210 --> 30:24.210
比方说以广告

30:24.210 --> 30:25.210
我们要在页面上

30:25.210 --> 30:26.210
显示的广告对吧

30:26.210 --> 30:27.210
一些轻量级的数据呢

30:27.210 --> 30:29.210
我们可以有自己的数据库房进来

30:29.210 --> 30:30.210
主要的数据

30:30.210 --> 30:31.210
比如用户数据

30:31.210 --> 30:32.210
文章数据

30:32.210 --> 30:33.210
产品数据

30:33.210 --> 30:34.210
物流信息

30:34.210 --> 30:35.210
这些东西

30:35.210 --> 30:37.210
大量的数据是存在后端服务器的

30:37.210 --> 30:39.210
后端服务器它怎么做的

30:39.210 --> 30:40.210
用什么语言做的

30:40.210 --> 30:41.210
你无所谓

30:41.210 --> 30:43.210
而绝大部分是这种结构

30:43.210 --> 30:44.210
我们的漏的服务器呢

30:44.210 --> 30:46.210
它充当一个前台的角色

30:46.210 --> 30:47.210
一个中间程

30:47.210 --> 30:48.210
但是呢

30:48.210 --> 30:49.210
这个漏的服务器呢

30:51.210 --> 30:53.210
当然可以用假发型

30:53.210 --> 30:54.210
但是用漏的呢

30:54.210 --> 30:56.210
在这种场景下面是最好的

30:56.210 --> 30:57.210
为什么呢

30:57.210 --> 30:58.210
我们刚才说了

30:58.210 --> 31:00.210
漏的的强项在哪

31:00.210 --> 31:01.210
吞吐量对吧

31:01.210 --> 31:02.210
它能够接收

31:02.210 --> 31:04.210
同时接收大量的用户琴球

31:04.210 --> 31:06.210
因为它是用异部的那种模式

31:06.210 --> 31:08.210
没有进程切换的开销

31:08.210 --> 31:10.210
它不像后端服务器

31:10.210 --> 31:12.210
哪一个琴球一个线程

31:12.210 --> 31:13.210
哪一个琴球一个线程

31:13.210 --> 31:14.210
受不了的

31:14.210 --> 31:15.210
那种线程开销受不了的

31:15.210 --> 31:16.210
所以说呢

31:16.210 --> 31:17.210
我们往往呢会

31:17.210 --> 31:18.210
在这里呢

31:18.210 --> 31:20.210
用一个漏的服务器呢

31:20.210 --> 31:22.210
来快速的响应用户的琴球

31:22.210 --> 31:23.210
好

31:23.210 --> 31:24.210
咱们这个节奏往后看一下

31:24.210 --> 31:26.210
这个结构是最常见的

31:26.210 --> 31:28.210
所以说我们学漏的的时候呢

31:28.210 --> 31:29.210
要有重心

31:29.210 --> 31:30.210
重心在哪呢

31:30.210 --> 31:31.210
重心就是在我们漏的

31:31.210 --> 31:33.210
以后要做什么事呢

31:33.210 --> 31:35.210
轻量级的数据存出

31:35.210 --> 31:37.210
不太会存很多东西

31:37.210 --> 31:38.210
所以说数据库的一块

31:38.210 --> 31:39.210
我一定会说话

31:39.210 --> 31:40.210
不然的话没完没了

31:40.210 --> 31:42.210
数据库里面东西多的吓死人

31:42.210 --> 31:43.210
那就没完没了了

31:43.210 --> 31:45.210
所以说我们简单的了解一下

31:45.210 --> 31:46.210
数据库怎么回事

31:46.210 --> 31:48.210
我们能够取一些简单的数据进去

31:48.210 --> 31:50.210
并且能够操作数据就够了

31:51.210 --> 31:52.210
情况说是简单

31:52.210 --> 31:53.210
我到时候讲了

31:53.210 --> 31:55.210
可能你知道我个人吧

31:55.210 --> 31:56.210
一讲了就可能收不住

31:56.210 --> 31:58.210
可能还是会讲很多

31:59.210 --> 32:00.210
另外呢

32:00.210 --> 32:01.210
他不太会做

32:01.210 --> 32:02.210
跟业务逻辑相关的事

32:02.210 --> 32:03.210
然后登陆

32:03.210 --> 32:05.210
登陆要从数据库里面找

32:05.210 --> 32:06.210
哪些用户

32:06.210 --> 32:07.210
满足帐号密码的

32:07.210 --> 32:08.210
他找我找

32:08.210 --> 32:09.210
根本不找

32:09.210 --> 32:11.210
我的数据库里面根本不存用户的

32:11.210 --> 32:12.210
我们用户在这吧

32:12.210 --> 32:13.210
这边后撰服务器里面

32:13.210 --> 32:15.210
所以说让后撰服务器自己去搞定

32:15.210 --> 32:17.210
他不太会做这些事情

32:17.210 --> 32:18.210
登陆发布文

32:18.210 --> 32:19.210
他不太会做

32:19.210 --> 32:21.210
他只是做简单的转发请求

32:22.210 --> 32:24.210
但是可能会有一些额外的功能

32:24.210 --> 32:26.210
什么叫额外的功能的

32:26.210 --> 32:28.210
比如说简单的信息记录

32:28.210 --> 32:29.210
什么记录

32:29.210 --> 32:30.210
请求日子

32:30.210 --> 32:31.210
用户偏好

32:31.210 --> 32:32.210
广告信息这种

32:32.210 --> 32:33.210
还有什么静态资源托管

32:33.210 --> 32:34.210
就是我们写的页面

32:34.210 --> 32:35.210
页面都放上服务器

32:35.210 --> 32:36.210
才能访问

32:36.210 --> 32:38.210
我们不可能把页面

32:38.210 --> 32:40.210
发给每一个用户

32:40.210 --> 32:42.210
所以说我们要把我们的页面

32:42.210 --> 32:43.210
放到我们的漏断服务器上

32:43.210 --> 32:44.210
用户通过一个地址

32:44.210 --> 32:46.210
来请求我们的服务器

32:46.210 --> 32:47.210
可以拿到页面了

32:47.210 --> 32:48.210
包括一些GS

32:48.210 --> 32:49.210
CSS文件

32:49.210 --> 32:51.210
那么这些都是静态资源

32:51.210 --> 32:52.210
还有图片这些东西

32:52.210 --> 32:54.210
我们可以放到漏断服务器上进行托管

32:54.210 --> 32:55.210
还有缓存

32:55.210 --> 32:56.210
就是我们有些页面

32:56.210 --> 32:58.210
它访问的频率比较高

32:58.210 --> 32:59.210
我不希望每一次访问

32:59.210 --> 33:01.210
都从后端服务器去拿数据

33:01.210 --> 33:02.210
我们直接

33:02.210 --> 33:04.210
给一个缓存起来把这个页面

33:05.210 --> 33:07.210
我直接人给你就完成了

33:07.210 --> 33:08.210
像这些事情

33:08.210 --> 33:10.210
都可以让漏断服务器钱

33:10.210 --> 33:11.210
来进行处理

33:12.210 --> 33:13.210
总之

33:13.210 --> 33:14.210
它是我们

33:14.210 --> 33:15.210
充在前方的最前线

33:15.210 --> 33:16.210
我们前端

33:16.210 --> 33:17.210
我们的服务器也是

33:17.210 --> 33:18.210
尽管我们的前端

33:18.210 --> 33:19.210
也要写一件服务器

33:19.210 --> 33:20.210
那么服务器

33:20.210 --> 33:21.210
它也是充在最前线的

33:21.210 --> 33:22.210
直接跟用户打交道的

33:23.210 --> 33:24.210
这就是

33:24.210 --> 33:26.210
我们的常见的两种结构

33:26.210 --> 33:27.210
应用

33:27.210 --> 33:29.210
这是我们漏的能用的

33:29.210 --> 33:30.210
还干吗

33:30.210 --> 33:31.210
好 最后

33:31.210 --> 33:32.210
我说一下

33:32.210 --> 33:33.210
咱们的前置课程

33:33.210 --> 33:34.210
就是你要学这门课

33:34.210 --> 33:36.210
你需要什么样的知识

33:36.210 --> 33:38.210
一个人你得把网络的通信看了

33:38.210 --> 33:39.210
不说别的

33:39.210 --> 33:40.210
什么七成协议

33:40.210 --> 33:41.210
我不管你这些东西

33:41.210 --> 33:43.210
我至少得了解ATB协议

33:43.210 --> 33:44.210
的完整过程

33:44.210 --> 33:46.210
它到底是怎么回事

33:46.210 --> 33:47.210
你把这个囤一定要磁透

33:47.210 --> 33:48.210
不然的话

33:48.210 --> 33:50.210
你学到后面都不知道我的干嘛了

33:50.210 --> 33:51.210
你玩了ES6

33:51.210 --> 33:53.210
我是做了一个ES6课程

33:53.210 --> 33:54.210
你这个课程得看了

33:55.210 --> 33:56.210
还有的就是磨坏化

33:56.210 --> 33:57.210
这个课程必须要看

33:57.210 --> 33:59.210
包管理器必须要看

33:59.210 --> 34:01.210
那么这个东西看了过

34:01.210 --> 34:02.210
学漏的

34:02.210 --> 34:03.210
基本上没有什么障碍的

34:03.210 --> 34:04.210
不要认为这个门课

34:04.210 --> 34:05.210
好像很难

34:05.210 --> 34:06.210
真的不难的

34:06.210 --> 34:07.210
东西是有点多

34:07.210 --> 34:08.210
但是真的不难

34:08.210 --> 34:09.210
那么这就是

34:09.210 --> 34:10.210
我们咱们的第1节课

34:10.210 --> 34:11.210
漏的概述

34:11.210 --> 34:12.210
每次学完了之后

34:12.210 --> 34:13.210
有后面的课程

34:13.210 --> 34:14.210
打算用这种新的模式

34:14.210 --> 34:16.210
给大家做自己记这个笔记

34:16.210 --> 34:18.210
大家自己也不用记笔记了

34:18.210 --> 34:19.210
写完了一门课

34:19.210 --> 34:20.210
而一节课

34:20.210 --> 34:21.210
我就打一个符号

34:21.210 --> 34:23.210
表示我这节课学完了

34:23.210 --> 34:24.210
OK

34:24.210 --> 34:26.210
那么这次咱们第1节课

34:26.210 --> 34:27.210
漏的概述

