WEBVTT

00:00.940 --> 00:04.380
好 这节课呢 咱们来看一项load的模块画细节

00:05.100 --> 00:10.180
呃 我们之前呢 你在s6也好 保管那期模块画课程里边

00:10.300 --> 00:13.660
你肯定是接触过load里面的common介是模块画标准的 对吧

00:14.540 --> 00:20.260
当时呢 我们大概就讲了一下啊 呃 还是有些细节还没有讲 那么这里呢 我们既然是讲load的

00:20.540 --> 00:23.380
那么我们就把细节给他补充进来 好 咱们一个个看啊

00:24.540 --> 00:30.060
首先是这个模块的查照 咱们再来把它回顾一下吧 他是怎么去查到模块的

00:30.660 --> 00:36.380
这个模块呢 他 我们使用模块的时候怎么导入模块的 是不是用require对吧 用这种方式来导入模块的

00:36.700 --> 00:41.300
然后导入的时候呢 这里边是不是要写模块路径 那么这个路径呢 有几种写法

00:41.900 --> 00:44.620
一个来 首先呢 第一种呢 是决定路径

00:45.420 --> 00:52.620
没写过吧 决定路径可能大家没有写过 好这个决定路径怎么写呢 决定路径呢 我们比方说在这里呢 新建一个文件

00:53.340 --> 00:57.020
adder.js 我们这里输出一下marge

00:58.620 --> 01:04.060
ok 然后呢 这边我们可以用绝对路径去导入这个模块 有这个adder.js呢 它的

01:04.780 --> 01:10.300
我们在磁盘里边的物理路径 咱们找一找啊 这个adder.js我们把复制一下

01:11.060 --> 01:14.860
复制我们这个绝对路径 转移一下

01:16.780 --> 01:20.140
好 后边呢 跟上一个adder.js 看一下这样子能不能导入进来

01:20.700 --> 01:25.740
好 咱们运行load index 是不是可以导入进来 对吧 没问题

01:26.300 --> 01:30.300
所以决定路径是没有问题的啊 而且呢 不仅决定路径没有问题

01:31.020 --> 01:35.500
并且呢 其他的路径写法 最终都会转换成决定路径

01:36.220 --> 01:41.340
没了意思吧 因为他读取文件嘛 导入模块实际上是什么呢 就是读取我们的文件

01:41.660 --> 01:43.500
他读文件的话 需要用决定路径

01:44.300 --> 01:45.900
好 这是关于决定路径啊

01:46.620 --> 01:51.820
然后呢 相对路径呢 有两种写法 一种写法呢 是底耳鞋杠 或者是底耳对耳鞋杠开了

01:52.620 --> 01:59.660
那么这种相对路径呢 就是我们导入自己的模块了 对吧 那么他的相对是相对于谁呢 相对于当前模块 去到导入

02:00.300 --> 02:05.980
什么意思呢 就是说 我们一个index.js的这个模块在哪呢 在这个目录下面 对吧 在这个目录下面

02:06.300 --> 02:09.420
那么他在这个目录下面呢 去导入我们的adder.js

02:10.220 --> 02:11.420
比方说require

02:12.780 --> 02:22.060
require 底耳鞋杠adder.js 对吧 像这样子呢 也可以导入的 相对的是当前模块所在的目录 这个大家都懂啊 不用再多说了

02:23.180 --> 02:28.460
但是他导入的时候呢 同样的会把它转换成绝对路径 然后呢 去加在模块

02:29.660 --> 02:37.260
还有一种相对路径呢 是这种啊 就是没有底耳鞋杠和这点鞋杠开头的 那么比方说我们在loading module是目录下面

02:37.900 --> 02:39.100
我们这里新建个文件夹

02:40.060 --> 02:44.140
比方说我们在这里呢 有一个abc啊 有这么一个模块

02:45.820 --> 02:49.500
啊 这边呢 我们新建一个啊 index.js

02:51.100 --> 02:55.500
好 来吧 我们这里输出一下啊 load modules

02:56.380 --> 03:03.420
abc 好 然后我们在这边呢 去导入这个模块 我们就可以这样子写abc 对吧 可以这样子写的

03:03.900 --> 03:07.500
保存 好 接下来啊 运行 是不是可以导入

03:07.900 --> 03:12.060
所以我们npm安装的包 是不是全在这 对吧 因此呢 都可以用这种方式来导入

03:13.020 --> 03:15.980
那么这种鞋 这种做法他导 他的导入顺序的是这样子

03:16.540 --> 03:22.300
首先呢 他检查是不是内置模块 怎么样内置模块呢 就是安装loader之后呢 他自带的一些模块

03:22.620 --> 03:28.620
他有一些核心功能 像我们这一张学习的是什么loader核心 对吧 讲的会讲很多的内置模块

03:29.340 --> 03:33.420
那比方说 如果说我们的模块呢 他是fs 你看啊

03:34.140 --> 03:37.980
那么现在呢 我们导入fs 看一下行不行呢 现在loader

03:38.940 --> 03:43.020
哎 不能用abc 没保存啊 没保存好 再来

03:43.900 --> 03:48.860
你看 是不是就不会运行我们的模块了 对吧 因为他导入的是内置模块 内置模块fs

03:48.940 --> 03:50.940
所以他首先检查的是不是内置模块

03:51.660 --> 03:54.540
如果说他不是内置模块 ok 赶回来啊

03:55.260 --> 04:02.860
啊 这里变成apc 如果说他不是内置模块的话 那么他会检查当前目录里边的loader modules

04:03.500 --> 04:09.260
啊 那么他会检查我们这个模块index.js 所在的目录下面有没有一个loader module

04:09.660 --> 04:11.500
那么在这个目录里边去找 对吧

04:12.140 --> 04:17.500
啊 这他的找的方式啊 如果说当前目录没有的话 还会返回上一级目录去找啊

04:18.140 --> 04:23.980
那么最终的找到了过后 就会转换成决定图形加上模块 如果说找不到找不到的话怎么办啊 爆错

04:24.700 --> 04:27.660
好 这就是这两种相对路径的他的寻找方式

04:28.300 --> 04:31.740
大家都懂啊 都是学过的 所以说没有必要再过多解释了

04:32.220 --> 04:37.580
然后呢 他关于后续名呢 是这样子 你在导入模块的时候呢 是可以不给后续名的

04:38.220 --> 04:41.740
比方说这里啊 导入一个模块的时候呢 是可以不不给后续名的

04:42.060 --> 04:47.660
那么如果说不给后续名的话 他会找找什么呢 找那个他会自动给你补权后续名

04:48.060 --> 04:51.660
啊 比方说那个后续名呢 他给你补权怎么补权呢

04:52.140 --> 04:58.220
补杰也是看找不到的到啊 这是找不到啊 就ok 找不到的话就补权是接生也就是他可以写接生文件的

04:58.620 --> 05:00.940
比方说啊 我们这里呢 再建一个b点接生

05:01.900 --> 05:04.940
呃 我们这里直接写接生啊 a等于

05:05.740 --> 05:06.700
1啊b

05:08.060 --> 05:11.180
等于2 好 那么现在我们先把它改成a嘛

05:12.380 --> 05:14.060
好 接下来呢 我们来看一下啊

05:14.620 --> 05:19.900
呃 如果说他找到杰 杰也是他就会输出这么一句话 对吧 如果说找到杰生呢 我们来看一下啊

05:20.620 --> 05:22.620
result 打印一下result

05:23.340 --> 05:24.140
输出result

05:27.200 --> 05:31.920
那么你可以看到他得到的是哪个 得到的是a.js里边内容 对吧

05:32.480 --> 05:38.480
那如果说a.js找不到啊 这里的ab啊 找不到 那么他会读什么呢 他就会读接生的

05:38.560 --> 05:41.280
对吧 他就会读接生文件了 把得到一个对象

05:42.000 --> 05:44.800
啊 他会把接生自自动进行软化 来得到一个对象

05:45.520 --> 05:49.840
ok 这是关于他的后续名 他可以自动补权的啊 你可以补写后续名

05:50.240 --> 05:56.480
那么除了接生之外呢 还有这两种啊 这种呢 我们根本用不到啊 这个东西呢 后面呃 我们下期可再说

05:57.040 --> 05:59.520
好吧 这是关于的四种 他会自动补权的后续名

06:00.400 --> 06:03.280
呃 然后呢 关于文件名呢 他是这样子

06:04.000 --> 06:08.960
如果说你只提供目录 不提供文件名的话 那么这自动寻找

06:09.920 --> 06:13.840
该目录中啊 这写错了啊 该目录中的index.js

06:14.160 --> 06:15.440
怎么意思呢 给大家举个例子

06:15.840 --> 06:19.760
比方说我们这里有个src目录 我们在这里边写上一个index.js

06:19.920 --> 06:22.960
啊 我们这里输出srcindex module

06:24.080 --> 06:27.520
好 然后呢 回到这个index.js文件 我们把这个注释掉

06:28.240 --> 06:32.720
那么现在呢 我们去导入 导入什么了点src 我们可以直接这样子写

06:33.280 --> 06:37.040
这样子写的话 他会没有给文件名对吧 那么他的查到顺序是这样子的

06:37.600 --> 06:40.720
他首先查找当前目录下面有没有这个文件

06:41.680 --> 06:46.160
有没有这个文件啊 没有后续名的这个文件 发现没有对吧 他只有这个目录没有这个文件

06:46.720 --> 06:51.120
然后呢 去找什么呢 src.js 然后去找src.json

06:51.360 --> 06:55.120
然后呢 去找src.load 所有都没有 都找不到啊

06:56.480 --> 07:01.040
delload 然后呢 去找src.mjs

07:01.440 --> 07:08.000
说全部找不到 找不到过后呢 他发现啊 src是个目录 行吧 那我在目录里边去找 找一下这个东西

07:08.880 --> 07:13.840
看能不能找到 这个东西是不找到了 找到过后 ok 把它转换成绝对入境 然后加载出来

07:14.480 --> 07:15.280
好 咱们看一下啊

07:16.400 --> 07:18.960
英雄是不是可以得到了 src index module

07:19.680 --> 07:21.120
对不对 非常简单啊

07:21.840 --> 07:25.440
然后这边呢 我们再说一下 关于这个package.json里面的妹子段

07:25.760 --> 07:29.760
因为我们知道我们package.json里面是不是有这么一个东西 妹子段啊 我之前好像

07:30.400 --> 07:35.040
提过一个啊 好像也解释过的 我也忘了我当时 当时也没有解释 这妹子段是这样子的

07:37.870 --> 07:41.870
他表示的是我们整个包啊的默认入口

07:42.110 --> 07:50.430
当我们去执行一个包 或者是导入一个第三方包的时候呢 如果说只提供目录 那么则使用妹

07:50.750 --> 07:54.430
补权入口 他的默认只是index的解释 这是啥意思呢

07:55.310 --> 07:57.950
这是啥意思 没看懂对吧 然后呢 我们来看一下

07:58.510 --> 08:01.230
什么意思呢 比方说我们在这里运行的时候

08:01.790 --> 08:05.870
我们是不是运行一个包 我们自己写的包的入口 对吧 给他一个入口来运行

08:06.270 --> 08:10.350
漏的 然后后面是不是入口 好写入口的时候呢 我们可以只写个目录

08:10.910 --> 08:14.990
表写上是不是目录 那么这个目录是不是后面没有写什么 没有写文件名

08:15.630 --> 08:19.470
没有写文件名会怎么样呢 他会自动的去找

08:20.190 --> 08:22.910
这个index 就是妹子段里边指定的文件

08:23.630 --> 08:26.830
比方说啊 咱们运行 你看是不是仍然可以运行

08:27.550 --> 08:30.510
那如果说把妹子段改一下 改成ab点也是呢

08:31.150 --> 08:37.390
好 咱们来看一下啊 这就运行了margeaua 对吧 margeaua b嘛 是不是运行了这个

08:38.110 --> 08:39.710
对吧 margeaua b

08:40.350 --> 08:43.550
没问题吧 那么他表示的是入口啊 入口的查找方式

08:44.110 --> 08:49.550
那如果说我们load margeaua 是里边啊 在这里边 这里边的话 那么我们也有一个

08:49.710 --> 08:52.190
到了第三方库的时候呢 也有一个就是派点接生

08:53.070 --> 08:55.310
啊 mpm init 出示化一下

08:59.860 --> 09:01.860
好 嗯 这里

09:03.060 --> 09:07.220
出示化跑到去了 在这 刷新一下啊 我们这里呢也给他写个妹子段

09:07.940 --> 09:08.420
妹

09:09.060 --> 09:13.060
哦 这里写了对吧 如果不写的话 默认的就是index 里也是 你把删了他也是这个

09:13.300 --> 09:15.300
好 比方说我们这里能写成abc

09:16.420 --> 09:23.700
或者是我们dash目录下面的abc 调接式 那么给看一下啊 dash目录下面的

09:25.140 --> 09:33.060
abc 调接式 我们这里输出一下啊 margeaua abcdastabc

09:34.020 --> 09:37.380
好 咱们这样子 现在呢 我们到到我们的index里边去

09:38.260 --> 09:40.260
然后呢 我们这里导入abc

09:41.060 --> 09:44.740
看一下 现在又会怎么样啊 我们把这个改回来啊 改成index

09:45.460 --> 09:47.460
好 现在会怎么样

09:48.260 --> 09:52.980
load 运行我们的什么呢 运行我们的底儿鞋杠 对吧 我们只需要底儿鞋杠进行了啊

09:52.980 --> 09:57.140
你觉得他会自动去找 根据我们这个包 我们这个包里边mace不是index的节式

09:57.140 --> 09:59.380
那么他会找到这个节式 那么会运行他

09:59.860 --> 10:03.700
运行他的时候 他导入了一个第三方库 第三方库里边 是不是从load margeaua

10:03.700 --> 10:07.460
里边要去先找什么 先找有没有abc这个文件 再找这个load margeaua

10:07.460 --> 10:12.740
里边有没有这个abc 调接式 abc 调接顺 一是找找不到的话 那么就找这个目录下面的东西

10:13.140 --> 10:17.220
好 这个目录下面 本来他应该是去找这个index的节式的 对吧 但是由于

10:17.780 --> 10:22.660
用的是第三方库 他会找入口 入口根据谁来指定 根据拍个点节省来指定

10:23.460 --> 10:27.060
那么找到这个dash目录下面的abc.节式 于是他找到这个东西了

10:27.780 --> 10:29.860
原来是吧 咱们来运行一下

10:31.620 --> 10:38.020
运行 你看是不是得到abc abc对不对 他是指的是一个包的入口 指的是一个包的入口

10:38.020 --> 10:41.780
他不会影响我们自己的模块啊 比方说我们自己要导入这个src

10:42.980 --> 10:48.740
导入这个src 导入了还是这个index的节式 他导致的是第三方另外一个包他的入口

10:49.460 --> 10:53.220
当我们导入另外一个包的时候呢 他会受到影响 如果说你不指定文件名

10:53.540 --> 10:56.900
他会直接受到影响 当然说如果说你指定的文件名那就不一样

10:57.620 --> 11:02.740
啊 比方说abc 我们指定他去找什么了index 那这样子肯定是不一样了

11:03.220 --> 11:06.260
你看是不是都漏到marge的abc 对吧 到了index了

11:06.660 --> 11:11.140
如果说你不指定文件名的话 他会去根据那个呃packaging节省里边去找

11:11.620 --> 11:17.780
ok 这是他的查找顺序啊 这里边呢可能会用于出面识题啊 大家只需要记住这个规则

11:17.780 --> 11:21.220
那就没问题了啊 可以在面试之前呢去复习一下

11:22.100 --> 11:23.460
也很简单啊 非常简单

11:24.420 --> 11:28.180
然后现在呢 我们再说这两个东西 一个是marge对象 一个是require函数

11:28.660 --> 11:33.620
这我们都用过了 对吧 marge对象用来干嘛的 是marge点export来导出的 对不对

11:33.860 --> 11:38.820
require呢 是要导入一个模块的 那么这两个东西呢 其实他里边还有一些别的东西

11:38.820 --> 11:43.140
咱们来看一下啊 来过一下就知道了 其实非常简单的 非常非常简单的

11:43.540 --> 11:45.140
比方说我们在这里呢

11:46.260 --> 11:49.460
不不这样子输出了 我们输出一个什么呢 输出一个marge

11:50.420 --> 11:55.940
啊 marge不是个 我们平时怎么用的 平时都是这样子用的 对吧 marge点export 这样子来用的

11:56.340 --> 12:01.620
啊 我们这里呢 直接把marge是个对象嘛 他里边一个属性xport 他看一下他里边还有没有别的东西

12:02.580 --> 12:03.540
好 咱们来看一下啊

12:05.060 --> 12:08.740
呃 我们在index里边呢 去导入他require

12:10.180 --> 12:12.980
呃 点鞋杠src 看一下吧

12:13.540 --> 12:15.700
轻平啊 load index

12:16.340 --> 12:23.460
你会发现了 他里边除了有一个export 对吧 这种文品是用的 之外呢 还有一些别的东西 咱们来一个个看吧

12:23.460 --> 12:25.620
这个id呢 表示的是模块的编号

12:26.740 --> 12:35.220
啊 你看他是一个 通过构造函数marge来创建的一个对象 那么这个构造函数我们是不能用的啊 他是在内部使用的 我们是不能用这个玩意儿的啊

12:35.540 --> 12:39.860
呃 然后呢 这里边有一个id id呢 指的是什么呢 指的是这个模块

12:39.860 --> 12:46.340
指的是这个模块啊 他的绝对路径 你看他绝对路径 是不是src目录下面的index的ges 对吧

12:46.980 --> 12:51.700
以绝对路径作为id啊 那么他这里呢 以绝对路径作为这个模块的id

12:52.420 --> 12:59.940
啊 如果说我是入口模块的话 那么他的绝对路径呢 是一个点啊 是一个点 如果说入口模块啊 就是我们启动模块的话

13:00.100 --> 13:02.900
他的绝对 他这个id呢 他不是绝对路径了啊 他是一个点

13:03.780 --> 13:05.540
好 pass呢 就表示这个模块

13:06.180 --> 13:11.380
啊 我们用了 我们在哪个模块里面输出的啊 在这个模块里面输出的 说说他是跟这个模块相关的信息

13:11.860 --> 13:17.940
那么这个模块里边啊 你看啊 他的pass呢 指的是这个模块的 他的路径 他的目录

13:18.500 --> 13:20.660
对吧 export不用解释吧 他用来导出的

13:21.060 --> 13:24.500
好 parent是什么意思呢 就是现在是哪个模块在用他

13:25.140 --> 13:28.660
对吧 也就是我们在模块内部是可以知道到底是谁在导出他

13:29.620 --> 13:33.940
哪个模块在用他呢 他又是个marge对象 是不是我们的index就介绍这个模块

13:34.100 --> 13:39.460
对吧 file name 啊 file name 表示这个模块的路径 那么这个呢表示 当前啊 这个模块

13:39.780 --> 13:45.140
他的是哪一个模块 他的副模块是谁 是哪一个模块在导入他啊 id 是不是点

13:45.460 --> 13:52.580
为什么是点 因为他的副模块是不是入口模块的 入口模块就是点啊 pass 懂的啊 export 懂的啊 parent

13:52.740 --> 13:56.820
那入口模块是没有没有副模块的 对吧好 file name

13:57.060 --> 14:03.220
就指的是他的绝对路径啊这loaded 什么意思呢loaded 表示这个模块是不是加载完了

14:03.780 --> 14:09.940
是不是加载完了呢 他正在运行 肯定没有加载完 你想啊 我们的入口模块 你看啊 入口模块运行这句话

14:10.260 --> 14:14.500
对吧 正在运行中 那么正在运行中 是不是加载了这个模块 他又运行这句话

14:14.900 --> 14:20.820
对吧 那么后边有没有代码 他要他要运行完了之后才知道 那么现在输出的一个阶段 是不是还没有运行完

14:21.140 --> 14:27.380
对吧 由于这个模块没有运行完 那么这个模块呢 他自然也没有运行完 对吧 所以说loaded 呢为force 表示没有加载完

14:28.340 --> 14:37.300
求准 求准是什么呢 指的紫模块啊 紫模块 比方说我们的副模块里面 副模块的紫模块当然就是自己 对吧 他这个一个cursor

14:37.780 --> 14:45.380
cacutor 表示的是帝规啊 就是循环引用 表示这个求准呢 就是他自己啊 他里面有是个数组啊 他有哪些紫模块

14:45.620 --> 14:48.900
就是我这个模块里面导入了哪些紫模块 大家了解一下就行了

14:49.380 --> 14:51.940
好 passage 什么意思呢 passage 表示的是

14:52.580 --> 14:57.860
如果说我加我加在的是这种这种模式 那么我应该从哪些位置去找

14:58.580 --> 15:05.780
第三方coup 第三方模块 那么他的passage 这个数组里面就记录了 到时候他找的时候呢 他就可以根据这样的路进去找

15:06.180 --> 15:13.140
啊 先找 比方说副模块里面 先找这个loaded modules 走吧 对吧 找不到 然后返回上级目录 然后再返回上级目录 然后再返回上级目录

15:13.540 --> 15:17.220
对吧 他就找得到顺序 对吧 这些东西呢 你看我们自己的模块也是这样子

15:18.180 --> 15:25.220
也是这样子 那么通过这样的就是去查看他的就是对象结构呢 大概能明白他里边有哪些属性啊

15:25.380 --> 15:32.900
如果说你将来遇到一些特别特殊的需求可能会用到这些属性的话啊 那么你可以想到跟march里面还可以提供很多的信息

15:33.060 --> 15:35.780
就是我们当前模块的信息啊 给他记录一下吧

15:36.500 --> 15:38.260
他里边记录了

15:39.700 --> 15:45.540
当前模块的信息啊 包括了什么呢 包括这个模块是被谁引用的

15:45.940 --> 15:51.060
然后呢 我这个模块目前又引用了哪些纸模块啊 都可以记录下来 包括模块的id

15:51.940 --> 15:58.740
对吧 好 然后呢 我们再看下一个啊 require 函数 这个require呢 本来就很简单 他就是一个函数而已

15:59.300 --> 16:02.820
那么这个函数里边有没有别的东西呢 我们在主模块里边输出一下

16:05.300 --> 16:12.580
load index 好 你会发现这个函数里边呢 除了除了我们平时这样子用的对吧 require 这个函数 除了这样子用的

16:13.060 --> 16:18.100
那么他还有一别 他还有别的东西 就是函数有些静态的属性 我们来看一下吧

16:19.300 --> 16:22.500
result 这个东西是什么呢 这个东西呢 他是一个函数

16:23.380 --> 16:30.660
他能够把握我们的啊 一个给到的模块的路径 不管你用哪种路径显法 把它转换成一个绝对路径

16:31.380 --> 16:33.700
啥意思呢 比方说啊 我觉得例子

16:34.420 --> 16:36.820
require里边有一个函数叫result

16:37.780 --> 16:43.220
那么这里边 我们比方说 传一个点鞋杆src 你看他返回的是什么啊 可能是返回的是什么

16:45.220 --> 16:54.260
运行 返回的是不是一个绝对路径src里边index的介绍 对吧 那么他是得到这么一个路径 你看他有没有加载模块啊

16:54.980 --> 16:57.460
所以没有加载模块 完全没有加载模块

16:58.340 --> 17:02.420
原来意思吧 他完全没有加载模块了 他只是得到一个绝对路径result

17:03.380 --> 17:06.580
好 这是关于这个函数啊 我继续看这个require里边的东西

17:07.140 --> 17:10.820
这个require里边还有一个me me是我们的就是我们的主模块

17:11.780 --> 17:15.300
就主模块 我们的入口旗电用的是哪个模块

17:16.580 --> 17:23.860
好 比方说啊 我们这个输出语决在这 我们的输出语决在这个src的index里边

17:24.340 --> 17:28.100
好 然后呢 我们这里呢使用require导入这个src

17:29.380 --> 17:29.860
来看一下

17:31.540 --> 17:38.340
好 你可以看到入口模块是不是还是主模块 对吧 我们的 就是我们通过load命令运行的index

17:38.340 --> 17:42.820
这个入口模块 指的是这个啊 这个模块里边的信息 这个模块就像我们之前解释过了 对吧

17:43.220 --> 17:47.220
extension是什么意思呢 就表示它的扩展 扩展名的处理函数

17:47.700 --> 17:53.540
也就是如果说你是delGS结尾的 当然如果说没有的话会自动补权 对吧 如果说你是delGS的

17:54.020 --> 17:56.820
扩展名的话 那么它通过这个函数来进行处理

17:57.540 --> 18:00.900
如果说你是delGS的话 它通过这个函数来进行处理 对吧

18:01.620 --> 18:04.420
因为我们require的时候呢 不同的后阵名可能处理的方式不一样

18:04.660 --> 18:06.580
delGS呢 我们处理方式非常简单

18:07.460 --> 18:12.580
怎么简单法 就是我们以前说的 对吧 可以把它导出结构了 作为返回结构

18:12.980 --> 18:17.540
那么delGS呢 它是要把它进行接成解析 对吧 进行接成解析来进行运行

18:18.180 --> 18:20.340
那这意思吧 扩展名的处理函数

18:20.980 --> 18:25.220
啊 然后呢 下面是开启 开启表示什么意思呢 就是目前我们已经缓存的模块

18:25.540 --> 18:27.300
因为我们知道common.js是要缓存的

18:27.940 --> 18:29.940
啊 任何的模块的话 标准它都是要缓存的

18:30.340 --> 18:34.820
就我们这里边有哪些已经缓存的模块 你看每一个缓存是不是跟模块对象

18:35.300 --> 18:36.500
对不对 是不是跟模块对象

18:36.820 --> 18:39.700
那么就保证了之后呢 就不要再重新运行这个模块了

18:40.260 --> 18:44.340
那么它的属性名呢 是它的就是模块ID 也就是绝对路径

18:45.060 --> 18:47.860
啊 也是绝对路径作为 绝对路径作为它的模块ID

18:48.020 --> 18:50.980
然后呢 后边呢 就是它的缓存结果

18:51.940 --> 18:54.180
那样的意思吧 这里呢 就是关于

18:54.820 --> 18:56.420
当然这个开启呢 你还可以把删掉

18:56.900 --> 19:01.220
你用那个delGS删出一个属性 那么就可以删出缓存 不过呢 我们一般不是这样干

19:01.460 --> 19:04.100
就了解一下它里面 其实还有些别的东西

19:04.980 --> 19:07.780
我们如果说要用的话 最多就会用那个result

19:08.900 --> 19:11.140
会用这个函数 其他都不太 怎么会用

19:12.340 --> 19:14.020
ok 那么就是关于这个require

19:16.020 --> 19:18.980
好了 那么终点来了 终点是我们这一部分

19:20.020 --> 19:20.820
它的原理

19:22.100 --> 19:25.780
就是它怎么回事 它怎么能够導入模块化 怎么来实现变量

19:25.780 --> 19:29.060
就是我们的局部变量 模块里边的变量不污染全局的

19:29.700 --> 19:32.980
它怎么回事 那么它是这样子的 我给大家写个例子就明白了

19:34.900 --> 19:38.260
比方说吧 我们这里呢 建立一个

19:39.140 --> 19:39.620
文件

19:40.740 --> 19:42.180
叫做my module

19:43.140 --> 19:43.940
有这么一个文件

19:44.660 --> 19:49.780
好 这个文件里边呢 我们使用这么一个方式啊 输出

19:52.740 --> 19:54.980
当前模块路径

19:57.280 --> 19:58.400
del

19:58.400 --> 20:02.080
对吧 然后呢 当前模块文件

20:02.800 --> 20:04.800
这里呢 使用那个file name

20:04.800 --> 20:06.480
我们之前都写过的 对吧

20:07.200 --> 20:09.680
然后呢 我们导出结果 export

20:11.040 --> 20:14.640
导出结果 a 等于 b 等于 2

20:14.640 --> 20:17.120
然后呢 我们在这里呢 用export

20:17.120 --> 20:20.320
再把它设置为c 等于 3

20:21.520 --> 20:25.440
然后呢 我们在这里呢 再把这个z 设为

20:25.440 --> 20:26.560
这次的面词题

20:28.560 --> 20:31.550
m 等于 5

20:34.030 --> 20:35.630
好 请问

20:37.630 --> 20:39.230
这个模块导出什么

20:39.950 --> 20:41.950
别人同学看到前面的还知道 对吧

20:41.950 --> 20:45.550
这个z 搞不清楚了 有影响吗 有影响

20:46.990 --> 20:49.710
有影响 那么这个东西是怎么回事呢

20:50.270 --> 20:52.270
怎么回事呢 我给大家看一下啊

20:52.830 --> 20:55.950
它导出结果 首先跟大家说结果 导出结果是a 等于1 b 等于2

20:56.990 --> 20:58.990
啊 导出结果是a 等于1 b 等于2

20:58.990 --> 21:02.510
好 咱们来试一下啊 在index里边 我们把这个复制一下

21:05.020 --> 21:10.860
require 然后那点 my module result

21:11.500 --> 21:15.500
看一下吧 是不是 a result 是不是a 等于1 b 等于2

21:17.920 --> 21:20.240
对吧 a 等于1 b 等于2 然后说出这么两句话

21:20.240 --> 21:23.040
对吧 那如果说我们这里呢 是这样子写的

21:24.560 --> 21:27.120
那你看一下 又不一样了

21:28.720 --> 21:31.280
哎 等一下啊 我们这里也保存了没有呢

21:32.160 --> 21:33.920
保存了的啊 保存了的

21:34.400 --> 21:38.640
呃 我看一下啊 我们这边呢 把这个注册掉

21:39.680 --> 21:48.700
export a 等于1 module export b 等于2

21:51.150 --> 21:53.150
好 然后呢 你看是不是多了一个am

21:53.790 --> 21:57.470
啊 多了c 我们还可以理解 多了个am 对吧 这就不好理解了 对吧

21:57.870 --> 22:01.550
而且呢 到底刚才为什么有这个m 就出不来了 刚才个m

22:01.870 --> 22:06.350
有z 关键字呢 也值得我们注意 因为我们这里有好几个问题 这个东西哪来的

22:07.230 --> 22:10.910
这个东西哪来的 这个东西哪来的 这个东西z又是什么玩意

22:11.070 --> 22:13.390
对吧 这个这个玩意为什么又不起作用

22:14.190 --> 22:19.150
平时那么写单嘛 不要去用这种方式来写 我建议大家呢 要么就全部用它

22:19.470 --> 22:23.630
要么就全部用它 对吧z 就尽量不要用 但是呢 面试题又可能会考到

22:24.590 --> 22:29.390
那你要理解这个问题的话 那么就必须要知道 它到底是怎么回事

22:29.950 --> 22:33.310
到底是怎么去导入模块的 我给大家演示一下啊

22:34.030 --> 22:39.310
当我们运行这个require函数的时候 它到底在干嘛 我给大家模拟一下这个函数

22:40.030 --> 22:46.750
但我没有办法完全给大家实现啊 我只能说模拟它告诉大家 它怎么回事 因为它是在内部引擎里边实现的

22:47.230 --> 22:52.430
好 而且呢 这里如果说要我真的去实现它的话 还需要一些额外的指示啊 比如说文件处理啊 这些东西

22:53.790 --> 22:55.230
看一下它怎么回事

22:56.190 --> 22:58.030
比方说我们这里有个require函数

22:59.070 --> 23:03.630
它这个函数是怎么运作的呢 它是这样子 第一步啊 这是个路径

23:04.590 --> 23:05.150
module

23:06.910 --> 23:13.950
这是个模块路径 对吧 然后它干嘛呢 它要首先把这个模块路径转换成绝对路径 第一步

23:14.830 --> 23:20.270
将module pass转换为绝对路径

23:21.390 --> 23:27.710
也就是我们这里写的是相对路径 对吧 是不是转换成一个绝对路径了 绝对路径是啥 是不是 我们这个这个玩意

23:28.670 --> 23:37.230
呃 相当于是这个玩意儿 然后写钢 呃 买module点介绍 是不是绝对路径 对不对 好 然后第二步

23:39.550 --> 23:40.110
检查

23:41.550 --> 23:47.630
就是当然要做一系列检查 对吧 检查这个路径 这个转换成绝对路径不太简单

23:48.350 --> 23:56.830
就不 这这第一步不太简单啊 这第一步为什么不简单 因为第一步的时候是不是要做很多事情 首先看一下你是哪种路径书写方式

23:57.230 --> 24:07.390
对不对 然后呢 如果说你是第三方模块的这种书写方式 是不是要一去一去找 对不对 所谓说呢 因此呢 这里呢 第一步其实不简单的啊 但是最终呢 他一定会拿到一个绝对路径

24:07.950 --> 24:16.510
拿到绝对路径是不是就找到了 拿不到绝对路径他就抱错了 他就找不到找不到这个模块 那我们现在就就看就看那个主线啊 他能找到这个模块

24:16.910 --> 24:27.150
然后干嘛 是不是读取模块内容 还不着急 还不着急读取模块内容 判断是否该模块已有缓存

24:28.350 --> 24:34.750
是不是已经有缓存的 模块是有缓存的 对吧 那么怎么来判断呢 特别简单 他就判断这个

24:35.550 --> 24:38.510
require require里边有没有这个catch

24:40.670 --> 24:42.830
那么这个require这个函数里边肯定要加一个catch

24:43.230 --> 24:49.970
catch 是一个数数 对不对 不是 是一个对象

24:50.610 --> 24:55.330
catch 是个对象 那么他看一下这个catch里边 有没有什么呢 有没有一个属性

24:57.090 --> 25:04.800
有没有这个属性 当然他吧 他肯定是个变量啊 变量传回来了 转换成绝对路径看一下 有没有

25:05.280 --> 25:10.560
如果说有这个属性呢 怎么样呢 是不是就直接返回了 对吧 直接返回

25:11.280 --> 25:13.840
啊 直接返回这个模块的运行结果 啊 return

25:14.880 --> 25:16.560
就是这个模块的运行结果

25:18.640 --> 25:28.000
啊 模块的运行结果 我都是写的伟贷嘛啊 全部写的是伟贷嘛 大家明白这个意思就行了 如果说他有这个缓存 那么我们直接给你结果 我就不用去加载

25:28.800 --> 25:31.200
这样的意思吧 好 这是关于这一部分

25:32.320 --> 25:38.640
好 如果说没有缓存的话 那么后面是不是没有缓存了 好 如果说没有缓存怎么办呢

25:39.120 --> 25:45.440
没有缓存 我没想到要做这么一件事 就是家展就读取文件内容

25:46.960 --> 25:51.680
读取文件内容 哪个内容呢 就在这儿 是把这个内容读出来

25:52.960 --> 26:01.840
在这儿啊 把这个内容读出来 对不对 把个内容读出来 读出来过后呢 把它包裹到一个函数里面

26:02.080 --> 26:06.080
啊 包裹到一个函数中

26:07.920 --> 26:16.960
好了 怎么来包裹呢 我们可以这样子写这么函数啊 就是一个函数 我就是给他写的伟贷嘛 他大概是这么运行的

26:18.480 --> 26:23.600
就包 这样子 包裹起来 好 这个函数里面呢 他会给你一些参数什么 module

26:24.960 --> 26:28.720
export 什么这些参数 然后呢 d i r 内

26:29.680 --> 26:36.000
filing 这就是为什么函数里面可以直接使用这些东西 你看 为什么 他不是global里面的东西

26:36.000 --> 26:42.800
他是我们这个模块里面代码 他是放到函数里面执行的 那么函数的 他用的是什么呢 用的是函数这些参数

26:44.000 --> 26:50.000
好 那么这个函数要调用对吧 肯定要调用吧 required 是不是要调用 好 调用的时候呢 接下来第六步

26:50.960 --> 26:59.840
创建 module 对象啊 创建 module 对象 那么创建 module 对象有哪些东西 加进去对吧 他里面有很多属性 加进去

27:00.320 --> 27:03.840
对不对 好 然后呢 还有这个还有require

27:05.120 --> 27:09.760
require 对吧require 就是这个函数嘛 对吧 就把这个东西传进去

27:10.320 --> 27:16.160
好 然后呢 创建 module 对象 然后接下来就调用函数了 还调用函数的时候 他是这样调用的

27:16.720 --> 27:17.120
看着啊

27:18.240 --> 27:18.560
temp

27:20.000 --> 27:21.040
第二 call

27:22.080 --> 27:27.920
是吧 call 的时候可以绑定 z 是他 z 是绑定什么呢 z 是绑定的就是 module 也 export

27:29.360 --> 27:33.520
啊 那创建 module 对象的时候 他有个关键的步骤 就是 module

27:36.530 --> 27:40.130
他有个关键步骤 就是 module 也 export 呢 等于这个啊 然后呢

27:41.250 --> 27:43.490
export 再定一个变量啊 export

27:44.450 --> 27:47.650
等于这个 对于 module 叫 export

27:48.530 --> 27:53.250
没什么意思吧 那么他相当于是把这个对象呢 先创一个空的对象 把这个对象放到这

27:54.130 --> 27:59.730
然后呢 调用函数的时候呢 把这个 export 传进去啊 当当成 z 是绑定 z 是

27:59.730 --> 28:02.210
然后呢 再一次传什么呢 传 module

28:02.930 --> 28:05.330
再传什么呢 呃 上面的 export

28:06.290 --> 28:11.410
啊 再传这个 好 然后呢 再干嘛呢 再把这个require 就是我们自己这个函数传进去

28:11.890 --> 28:13.090
require 这个函数传进去

28:14.050 --> 28:19.490
啊 这个这个地方是动态的啊 这个地方不是写实的啊 是动态的啊 然后呢 再把这个 drlame

28:19.490 --> 28:25.330
drlame呢 就是模块的这个 id 对吧 来自于 module.id 对不对 是不是传进去

28:25.890 --> 28:29.170
啊 传进去 然后呢 这个 file name

28:29.730 --> 28:33.730
file name 那么就是 module.file name 是吧 一是传进去

28:34.290 --> 28:40.690
对不对 于是呢 在这个这个模块的运行过程中 是不是可以赌到当前路径呢 因为我给他传过去了啊 已经呢

28:41.170 --> 28:43.330
呃 不是 id sparse

28:45.170 --> 28:50.130
那么file name 是不是可以赌到了 对吧 这些东西都传进去了 好 那么require函数是不可以拿到了

28:50.450 --> 28:52.450
对不对 require函数是可以传进去了 拿到了

28:52.930 --> 28:59.330
好 然后我们这个 export 关键是看这两个 这几个 z 是我们绑定的是什么呢 z 是我们一开始绑定的是这个对象

28:59.490 --> 29:01.890
对吧 绑定了就把这个对象当成 z 传进去

29:02.450 --> 29:04.130
好 然后呢 export呢

29:04.770 --> 29:08.210
它也是这个对象 对吧 所以说呢 如果说我们在这里

29:09.090 --> 29:11.490
把这个组织掉啊 因为都是这些东西都是伟大嘛

29:12.450 --> 29:13.650
好 如果说我们在这里

29:14.530 --> 29:16.130
出面是题 它问你

29:17.490 --> 29:19.010
z 等不等于

29:19.730 --> 29:23.730
margeu 直接这样子写啊 export 等不等于呢 你想想等不等于

29:24.690 --> 29:25.650
啊 肯定等于啊

29:26.530 --> 29:29.570
是不是 true 对吧 肯定等于 那等不等于 export呢

29:30.050 --> 29:37.490
是不是肯定等于 他们一开始都是一样的 对吧 就是z export和这个 margeu的 export 全都是一样的啊

29:37.970 --> 29:42.930
在一开始的时候全都是一样的 因为一开始的时候是不是 z 就是这个对象 对吧 绑定于去

29:43.250 --> 29:44.130
好 然后 margeu

29:44.450 --> 29:48.370
这个 export 是不是还是个对象 export 还是个对象 对吧 三个是一样的

29:48.610 --> 29:52.210
但是后边你做操作的时候呢 如果说你乱操作就很容易出问题

29:53.010 --> 29:53.730
啊 比方说这里

29:54.290 --> 29:58.930
那么这个地方呢 是不是相当于是把这个对象里面加一个 c 对吧 加一个 c

29:59.410 --> 30:03.570
对不对 那么这里加上一个 c 打过后 z 是不是也有了 比方说我们这里

30:04.130 --> 30:06.770
你看啊 这里加一个 c 我们来看一下输出 z

30:08.940 --> 30:18.990
输出 z 你看 z 是不是也有 c 了 对吧 z 里面也有 c 了 为什么输出两层 因为这边还输出了一次

30:20.030 --> 30:24.910
z 也有 c 了 所以说呢 他们是同一个东西啊 只要你不去改他肯定是同一个东西

30:25.470 --> 30:27.470
但是呢 如果说你把改了就不一样了

30:28.190 --> 30:33.790
那么 因为我们这里呢 改了这个 export 是不是改了应该负责有一个新的对象了 从此以后

30:34.510 --> 30:40.750
一开始呢 这个就是 z 指向的还是原来的对象 对吧 export 也是指向了原来的对象

30:41.070 --> 30:44.510
但是这个东西是不是指向新的对象了 对不对 指向了新的对象了

30:45.230 --> 30:49.630
那么你后边改 z 是啊 改 export 是不是没用了 对不对 没用了 还是改的是原来的东西

30:49.870 --> 30:52.430
因为我们这个调用完了过后 最终返回的

30:53.230 --> 30:56.030
返回的是什么呢 Margeau.export 返回的是这个东西

30:57.230 --> 31:02.350
最终返回的 就是require 整个require 函数 返回的这个东西 也就是说这一遍 为什么能得到这个 result

31:02.670 --> 31:04.670
得到的是什么呢 得到的是 Margeau.export

31:05.630 --> 31:12.350
原来的意思吧 所以说呢 这个 z 是呢 你可以可以把它认为是什么呢 这个 z 是可以认为就是这个 export

31:12.830 --> 31:20.350
但是你不能认为它是 Margeau.export 对吧 因为 Margeau.export 一重新复制数就没了 对吧 这个 z 是跟指向就不一样了

31:20.590 --> 31:24.910
啊 你要 margeau.export 重新复制 你再看一下这个相等吗 肯定不相等

31:26.670 --> 31:31.390
对吧 好好去捋一捋啊 就这个地方呢 它凭是我们写带吧 肯定不会这样子乱搞

31:32.110 --> 31:39.230
啊 因为我们要么就用全部用它 要么就是用它 对吧 不会还会两个一起用 更加不太会用 z 是 特别容易造成困乱

31:40.030 --> 31:43.230
但是呢 我们平时呢 就是容易出现面试题

31:43.950 --> 31:48.910
那么面试 如果说你知道这个核心原理之过后呢 面试题怎么着理都办一着不知道啊

31:49.710 --> 31:55.150
只要他知道你这个代码到底是怎么去执行的 大概是怎么回事 就是就明白他到底是怎么运作的

31:56.030 --> 32:02.670
ok 那么这个 z 呢 你可以认为就是就是这个 export 啊 尽管这里改了 对吧 这个 z 还是等于 export 这个是毫无疑问的

32:05.310 --> 32:07.390
z 肯定是等于 export 但是呢

32:08.270 --> 32:13.550
以前是可以允许你重新给 export 复制的 以前是可以允许的 啊 现在呢

32:14.190 --> 32:21.550
现在好像也允许啊 如果说你加了 s nint的话 他会给你包错啊 你不不不 不让你这样做啊 不让你这样做啊 但是呢

32:22.510 --> 32:29.310
你永远不要这样做啊 有可能面试题会问你 那这个地方重新复制过后又怎么样 那又又不一样了 对吧 这两个又不一样

32:29.790 --> 32:31.950
所以说大家搞清楚啊 搞清楚

32:32.990 --> 32:33.870
这是关于这个

32:34.430 --> 32:37.790
这里边的这些到底是怎么回事 已经呢 他总会出现了面试题

32:38.510 --> 32:44.510
有可能呢 面试题还会直接问你 在一个漏的介石里边 z 啊 全局的 z 指向谁

32:45.470 --> 32:49.710
不是什么特殊的规则 因为模块的模块我们代码里边 z 呢

32:50.510 --> 32:55.710
他是放到一个函数里边执行的 放到函数里边执行的 他绑定的是一开始绑定的是 export

32:55.790 --> 32:58.830
但是你改动过后 export 改动过后呢 跟 z 是不一样

32:59.630 --> 33:00.510
他是这么一回事

33:01.230 --> 33:05.870
啊 大家好好去捋一捋啊 你看百度里边有很多的关于什么漏的介石里边

33:06.430 --> 33:12.350
呃 那个 z 的指向啊 全都没有说到底而上啊 还有很多什么详细讲解都没有说到底而上

33:12.510 --> 33:16.110
他真正的原因呢 是这样子啊 你把原码分析清楚了 你是当然明白的

33:16.670 --> 33:21.710
ok 那么这是关于 呃 这一块的知识 好 那么现在呢 我们就把一个漏的介石里边呢

33:22.270 --> 33:28.750
模块化的细节 讲就搞定了 对吧 呃 然后下一颗预告一下啊 下一颗 因为我们漏的里边呢

33:29.470 --> 33:35.470
还没有涉及到那个com 还没有涉及到 s6 的模块化 实际上是漏的呢 他也支持 s6 的模块化

33:35.710 --> 33:40.030
早期版本不支持 现在版本呢 支持了啊 但是呢 你要做一些特殊的处理

33:40.350 --> 33:44.990
因此呢 我们绝大部分情况下呢 不太会在漏的里边使用 s6 的模块化

33:45.390 --> 33:50.430
不太会用啊 要用 s6 的模块化的时候 往往会用wepack来帮我们打包

33:50.990 --> 33:56.270
嗯 但是呢 我还是把它做一个扩展课程 大家了解一下吧 好吧 好 OK 那么这里可能到这了

