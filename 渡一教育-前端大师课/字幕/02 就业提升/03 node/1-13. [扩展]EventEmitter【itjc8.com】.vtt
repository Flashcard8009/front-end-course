WEBVTT

00:01.010 --> 00:04.010
本章我们再扩展一点知识吧

00:04.010 --> 00:09.010
其实我们load里面的核心东西都已经讲完了

00:09.010 --> 00:11.010
平时我们用的就是这么些膜块

00:11.010 --> 00:14.010
但是load里面膜块特别多

00:14.010 --> 00:16.010
你要想它跟超多系统打交道的

00:16.010 --> 00:18.010
拉这个膜块吓死人了

00:18.010 --> 00:19.010
知道吧

00:19.010 --> 00:21.010
所以说我们要讲的话

00:21.010 --> 00:23.010
我一开始给大家说了水太深了

00:23.010 --> 00:25.010
一讲的话可能讲都没完了

00:25.010 --> 00:27.010
因此我们把核心的膜块讲了

00:27.010 --> 00:29.010
我们平时要用的不讲了

00:29.010 --> 00:31.010
基本上是平时不用的

00:31.010 --> 00:33.010
然后我这就可能选了一下

00:33.010 --> 00:35.010
就再讲一个膜块吧

00:35.010 --> 00:37.010
选了一下选来选去的话

00:37.010 --> 00:39.010
我决定讲这个eventson emitter

00:39.010 --> 00:43.010
这个膜块倒是以后你们有可能会用到

00:43.010 --> 00:46.010
其实load里面还有个膜块叫加密膜块

00:46.010 --> 00:49.010
那个膜块你们之后也可能会用到

00:49.010 --> 00:51.010
那个膜块我们后边一定会说的

00:51.010 --> 00:54.010
那个膜块还是会用到的膜块

00:54.010 --> 00:55.010
后面会说

00:55.010 --> 00:58.010
这一块我们讲的是eventson emitter

00:58.010 --> 01:00.010
你们平时不怎么会用

01:00.010 --> 01:01.010
除了它是一个扩展核心

01:01.010 --> 01:03.010
你不听的话不会影响后边的学习

01:03.010 --> 01:05.010
但是我们平时

01:05.010 --> 01:06.010
我不用这个膜

01:06.010 --> 01:07.010
不直接用这个膜块

01:07.010 --> 01:08.010
但是这个膜块里面

01:08.010 --> 01:11.010
经常会出现在我们代码里面

01:11.010 --> 01:13.010
我们前面都出现了很多很多次了

01:13.010 --> 01:14.010
只是你自己不知道

01:14.010 --> 01:15.010
它是来自于这个膜块的

01:15.010 --> 01:17.010
所以说这里把他拿出来说一下吧

01:17.010 --> 01:19.010
有的时候你写一些底层膜块

01:19.010 --> 01:21.010
或者是做一些公共膜块的时候

01:21.010 --> 01:22.010
你可能会用到它

01:22.010 --> 01:23.010
它是什么东西呢

01:23.010 --> 01:25.010
它是load里面的一个

01:25.010 --> 01:29.010
事件管理的一种通用管理机制

01:29.010 --> 01:32.010
还是经典笔记吧

01:32.010 --> 01:34.010
它是load介石中

01:34.010 --> 01:39.010
事件管理的通用机制

01:39.010 --> 01:40.010
什么意思呢

01:40.010 --> 01:43.010
你们之前一定写过这样的代码

01:43.010 --> 01:45.010
想用的一个对象里面

01:45.010 --> 01:46.010
on

01:46.010 --> 01:47.010
delta

01:47.010 --> 01:49.010
是不是这个代码

01:49.010 --> 01:50.010
对不对

01:50.010 --> 01:51.010
还有什么

01:51.010 --> 01:54.010
一个文件流里面的readstream

01:54.010 --> 01:56.010
里面的一个delta

01:56.010 --> 01:57.010
对吧

01:57.010 --> 01:58.010
还有什么呢

01:58.010 --> 02:00.010
还有什么socket

02:00.010 --> 02:01.010
啊

02:01.010 --> 02:03.010
socketson

02:03.010 --> 02:05.010
end

02:05.010 --> 02:06.010
close

02:06.010 --> 02:07.010
对不对

02:07.010 --> 02:08.010
所以有各种各样什么on

02:08.010 --> 02:10.010
on什么什么什么对吧

02:10.010 --> 02:11.010
我之前跟大家怎么说的

02:11.010 --> 02:13.010
这东西叫做注册事件

02:13.010 --> 02:14.010
注册一个事件

02:14.010 --> 02:15.010
监听一个事件

02:15.010 --> 02:17.010
有点类似于动物里面的add

02:17.010 --> 02:18.010
event messenger

02:18.010 --> 02:19.010
对不对

02:19.010 --> 02:20.010
当这个事件触发的时候

02:20.010 --> 02:22.010
它就会运行这个函数

02:22.010 --> 02:23.010
那么为什么这些东西都是

02:23.010 --> 02:24.010
统一的接口呢

02:24.010 --> 02:25.010
你看到没

02:25.010 --> 02:26.010
什么统一的接口

02:26.010 --> 02:27.010
为什么呢

02:27.010 --> 02:29.010
因为他们全部都是使用的

02:29.010 --> 02:31.010
这个模块

02:31.010 --> 02:32.010
叫做event emitter

02:32.010 --> 02:33.010
这个模块

02:33.010 --> 02:34.010
这个模块呢

02:34.010 --> 02:36.010
它跟什么文件流啊

02:36.010 --> 02:37.010
sockets

02:37.010 --> 02:38.010
什么response

02:38.010 --> 02:40.010
request都没有关系

02:40.010 --> 02:41.010
它就是

02:41.010 --> 02:43.010
一个事件管理机制

02:43.010 --> 02:45.010
那我们来用一下这个模块吧

02:45.010 --> 02:47.010
这个模块怎么用呢

02:47.010 --> 02:48.010
它是这样子

02:48.010 --> 02:52.640
导入这个模块event

02:52.640 --> 02:53.640
这个模块里面呢

02:53.640 --> 02:55.640
它有一个

02:55.640 --> 02:56.640
构造函数

02:56.640 --> 02:57.640
就是一个内

02:57.640 --> 02:58.640
这个内呢

02:58.640 --> 03:00.640
叫做event emitter

03:00.640 --> 03:01.640
是这么一个内

03:01.640 --> 03:02.640
对吧

03:02.640 --> 03:03.640
那么这个内怎么用呢

03:03.640 --> 03:04.640
它肯定是创建对象吧

03:04.640 --> 03:06.640
我们来拿一个对象

03:06.640 --> 03:08.640
event

03:08.640 --> 03:09.640
event

03:09.640 --> 03:11.640
或者叫event

03:11.640 --> 03:13.640
一亿嘛

03:13.640 --> 03:14.640
随便吧

03:14.640 --> 03:15.640
这里边

03:15.640 --> 03:16.640
有些配置

03:16.640 --> 03:17.640
我们都不用创配置了

03:17.640 --> 03:19.640
就创建了这么一个

03:19.640 --> 03:20.640
这个东西叫什么呢

03:20.640 --> 03:22.640
都要创建一个

03:22.640 --> 03:23.640
创建一个

03:23.640 --> 03:25.640
事件

03:25.640 --> 03:27.640
处理对象

03:27.640 --> 03:28.640
这个事件处理对象

03:28.640 --> 03:29.640
它能干嘛呢

03:29.640 --> 03:30.640
它的作用是

03:30.640 --> 03:33.640
可以注册事件

03:33.640 --> 03:34.640
可以

03:34.640 --> 03:36.640
触发事件

03:36.640 --> 03:37.640
可以触发事件

03:37.640 --> 03:38.640
那么什么意思

03:38.640 --> 03:39.640
怎么来用

03:39.640 --> 03:40.640
其实你们学到现在的

03:40.640 --> 03:41.640
应该很容易明白

03:41.640 --> 03:42.640
怎么来注册事件

03:42.640 --> 03:43.640
就用按注册事件

03:43.640 --> 03:45.640
它还有另外一种注册事件方式

03:45.640 --> 03:46.640
叫做ad d

03:46.640 --> 03:48.640
ad lessoner

03:48.640 --> 03:50.640
这种注册事件方式

03:50.640 --> 03:52.640
跟那个按是一样的

03:52.640 --> 03:53.640
是一样的

03:53.640 --> 03:55.640
所以说我们平时用按吧

03:55.640 --> 03:56.640
那么后边怎么写呢

03:56.640 --> 03:57.640
就是写事件名称

03:57.640 --> 03:59.640
这个事件名称是什么呢

03:59.640 --> 04:00.640
随便啥啥

04:00.640 --> 04:01.640
随便啥都可以

04:01.640 --> 04:02.640
所以abc

04:02.640 --> 04:03.640
都可以

04:03.640 --> 04:04.640
那么后边写的

04:04.640 --> 04:06.640
你的事件处理函数

04:06.640 --> 04:08.640
比方说这里写个

04:08.640 --> 04:11.640
abc事件触发了

04:11.640 --> 04:12.640
那就注册一个事件了

04:12.640 --> 04:14.640
就这么简单

04:14.640 --> 04:16.640
那么我来运行一下

04:16.640 --> 04:17.640
能看到效果吗

04:17.640 --> 04:18.640
肯定看不到

04:18.640 --> 04:19.640
为什么

04:19.640 --> 04:20.640
因为这个事件没有触发

04:20.640 --> 04:21.640
那你怎么来触发这个事件呢

04:21.640 --> 04:22.640
很简单

04:22.640 --> 04:23.640
你只要去调用

04:23.640 --> 04:25.640
调用这个amat

04:25.640 --> 04:26.640
amat是什么意思

04:26.640 --> 04:27.640
就触发事件

04:27.640 --> 04:28.640
如果说你学到现在

04:28.640 --> 04:30.640
如果说你学过view

04:30.640 --> 04:31.640
那你肯定知道amat是什么意思

04:31.640 --> 04:32.640
就触发事件

04:32.640 --> 04:33.640
对不对

04:33.640 --> 04:34.640
那么触发什么呢abc

04:34.640 --> 04:35.640
对吧

04:35.640 --> 04:36.640
事件名字叫abc

04:36.640 --> 04:37.640
这句话什么意思

04:37.640 --> 04:40.640
触发名为abc的事件

04:40.640 --> 04:43.640
就是你自己手动触发的

04:43.640 --> 04:44.640
只不过很多的

04:44.640 --> 04:46.640
我们之前用的那些东西

04:46.640 --> 04:47.640
想应对象

04:47.640 --> 04:48.640
请求对象

04:48.640 --> 04:49.640
什么on里边的事件

04:49.640 --> 04:50.640
它为什么可以自动触发

04:50.640 --> 04:52.640
因为它的那个东西

04:52.640 --> 04:54.640
你Burkley手动触发了

04:54.640 --> 04:55.640
你不用去触发了

04:55.640 --> 04:56.640
它自己也得触发了

04:56.640 --> 04:57.640
对不对

04:57.640 --> 04:58.640
好 咱们来看一下

04:58.640 --> 05:00.640
当你触发这个事件的时候

05:00.640 --> 05:01.640
它会怎么样了

05:01.640 --> 05:05.640
会一次运行注册的事件函数

05:05.640 --> 05:06.640
所以说这个东西就这么简单

05:06.640 --> 05:07.640
一个是注册事件

05:07.640 --> 05:08.640
用on

05:08.640 --> 05:09.640
一个是触发事件用amat

05:09.640 --> 05:10.640
对吧

05:10.640 --> 05:11.640
那么触发事件的时候

05:11.640 --> 05:12.640
它就会一次运行

05:12.640 --> 05:13.640
之前注册的哪些事件

05:13.640 --> 05:15.640
是不是就一次运行这些函数了

05:15.640 --> 05:16.640
就这么简单

05:16.640 --> 05:18.640
你看 是不是abc事件触发了

05:18.640 --> 05:19.640
那如果说你注册了

05:19.640 --> 05:22.640
多个时间触发函数了

05:22.640 --> 05:24.640
那就一次触发

05:24.640 --> 05:25.640
触发的时间的时候

05:25.640 --> 05:28.640
三个函数都运行

05:28.640 --> 05:29.640
是不是都运行

05:29.640 --> 05:30.640
对不对

05:30.640 --> 05:31.640
而且你还可以多次触发

05:31.640 --> 05:33.640
比方触发三次

05:33.640 --> 05:35.640
那么这些函数就一次运行三次

05:35.640 --> 05:36.640
你看 第一次触发

05:36.640 --> 05:37.640
第二次触发

05:37.640 --> 05:38.640
第三次触发

05:38.640 --> 05:39.640
就这么简单

05:39.640 --> 05:40.640
它就做了这么一个事

05:40.640 --> 05:41.640
它怎么做的呢

05:41.640 --> 05:43.640
其实会特别特别简单

05:43.640 --> 05:44.640
它怎么做的呢

05:44.640 --> 05:45.640
那一步呢 维护了

05:45.640 --> 05:50.640
那一步维护多个事件对立

05:50.640 --> 05:51.640
它就用这种方式来出

05:51.640 --> 05:53.640
这个事件对立

05:53.640 --> 05:54.640
跟那个生命周期

05:54.640 --> 05:56.640
就是那个异部事件对立

05:56.640 --> 05:57.640
不是一个马兆

05:57.640 --> 05:58.640
它就是一个数组

05:58.640 --> 05:59.640
它就是一个普通数组

05:59.640 --> 06:00.640
比方说吧

06:00.640 --> 06:02.640
那么你这里注册一个事件abc

06:02.640 --> 06:03.640
对吧

06:03.640 --> 06:04.640
abc的事件它相当于是什么呢

06:04.640 --> 06:05.640
相当于是在里面

06:05.640 --> 06:06.640
建那个数组

06:06.640 --> 06:07.640
一个对象

06:07.640 --> 06:08.640
这个对象里面

06:08.640 --> 06:10.640
属性名为abc

06:10.640 --> 06:11.640
这个abc是什么

06:11.640 --> 06:12.640
是一个数组

06:13.640 --> 06:14.640
里面有个函数1

06:14.640 --> 06:15.640
函数2

06:15.640 --> 06:16.640
函数3

06:16.640 --> 06:17.640
对吧

06:17.640 --> 06:18.640
当你调用这个mx

06:18.640 --> 06:19.640
abc的时候

06:19.640 --> 06:21.640
是不是找到这个对象的abc属性

06:21.640 --> 06:23.640
然后一次运行这些函数就完了

06:23.640 --> 06:24.640
就这么简单

06:25.640 --> 06:26.640
那如果说你

06:26.640 --> 06:28.640
当然你还可以注册别的事件

06:28.640 --> 06:29.640
bcd

06:29.640 --> 06:30.640
bcd 它现在能运行吗

06:30.640 --> 06:31.640
肯定不能运行

06:31.640 --> 06:33.640
因为你没有触发这个事件

06:33.640 --> 06:34.640
现在那就是

06:34.640 --> 06:35.640
相当于是

06:35.640 --> 06:36.640
又有一个属性了

06:36.640 --> 06:37.640
bcd

06:37.640 --> 06:38.640
你们都可以自己去

06:38.640 --> 06:40.640
把原码写出来

06:40.640 --> 06:41.640
bcd

06:41.640 --> 06:42.640
到时候触发bcd的时候

06:42.640 --> 06:43.640
是不是运行这个函数

06:43.640 --> 06:44.640
对不对

06:44.640 --> 06:45.640
那么现在肯定不会运行

06:45.640 --> 06:46.640
因为你没有

06:46.640 --> 06:48.640
没有那个触发bcd事件

06:48.640 --> 06:49.640
比方说我们触发一次

06:49.640 --> 06:53.020
bcd

06:53.020 --> 06:54.020
bcd

06:54.020 --> 06:55.020
来吧

06:55.020 --> 06:56.020
你看bcd触发了

06:56.020 --> 06:57.020
是不是就运行这个函数

06:57.020 --> 06:58.020
就这么简单

06:58.020 --> 06:59.020
对不对

06:59.020 --> 07:01.020
那如果看一下

07:01.020 --> 07:02.020
它这个事件是同步运行

07:02.020 --> 07:03.020
还是一步运行的

07:03.020 --> 07:05.020
这是script

07:05.020 --> 07:06.020
end

07:06.020 --> 07:08.020
来输出一下

07:08.020 --> 07:09.020
你就发现它是同步运行的

07:09.020 --> 07:10.020
对吧

07:10.020 --> 07:11.020
它就是一个循环

07:11.020 --> 07:12.020
循环这个数组

07:12.020 --> 07:13.020
特别特别简单

07:13.020 --> 07:15.020
这个内

07:15.020 --> 07:17.020
你都可以自己写出来

07:17.020 --> 07:19.020
当然它里边还提供了一些别的结构

07:19.020 --> 07:20.020
比方说

07:20.020 --> 07:21.020
有些事件

07:21.020 --> 07:24.020
我只触发一次

07:24.020 --> 07:25.020
万事

07:25.020 --> 07:26.020
万事什么意思

07:26.020 --> 07:27.020
我只触发一次

07:27.020 --> 07:28.020
abcd是说4件3

07:28.020 --> 07:30.020
该事件只触发一次

07:30.020 --> 07:35.020
该事件只触发一次

07:35.020 --> 07:36.020
触发一次过来

07:36.020 --> 07:37.020
它就把3了

07:37.020 --> 07:38.020
运行

07:38.020 --> 07:39.020
你看

07:39.020 --> 07:40.020
是不是这个事件只触发一次

07:40.020 --> 07:41.020
万事

07:41.020 --> 07:42.020
那它怎么回事

07:42.020 --> 07:43.020
就是第1次触发了过后

07:43.020 --> 07:44.020
它就把这个事件

07:44.020 --> 07:45.020
从这个数组里边删掉了

07:45.020 --> 07:46.020
对吧

07:46.020 --> 07:47.020
就特别简单

07:47.020 --> 07:48.020
有兴趣的同学

07:48.020 --> 07:49.020
真的可以自己写一下

07:49.020 --> 07:50.020
也特别有意思

07:50.020 --> 07:52.020
它其他什么事情那么做

07:52.020 --> 07:54.020
它就搞定这个事情

07:54.020 --> 07:55.020
那么有了

07:55.020 --> 07:56.020
这个东西存在过后

07:56.020 --> 07:57.020
你会发现

07:57.020 --> 07:58.020
它就形成了一种

07:58.020 --> 08:00.020
通用的事件模型

08:00.020 --> 08:01.020
这里还要说

08:01.020 --> 08:03.020
就是它如何来移除事件

08:03.020 --> 08:04.020
比方说第1次触发过后

08:04.020 --> 08:06.020
我把这个事件移除了

08:06.020 --> 08:08.020
叫off

08:08.020 --> 08:09.020
移除了之后

08:09.020 --> 08:10.020
第一次参数

08:10.020 --> 08:11.020
写事件名

08:11.020 --> 08:13.020
把abc事件里边的

08:13.020 --> 08:14.020
abc是不是对列

08:14.020 --> 08:16.020
把fn2移除

08:16.020 --> 08:17.020
fn2移除

08:17.020 --> 08:19.020
把这个事件移除

08:19.020 --> 08:20.020
那么这个事件怎么移除

08:20.020 --> 08:21.020
你要把这个移除的函数

08:21.020 --> 08:24.020
就跟那个DOM里面的remove

08:24.020 --> 08:25.020
eventing this and that

08:25.020 --> 08:26.020
是不是一样的

08:26.020 --> 08:28.020
你要把这个函数给它

08:28.020 --> 08:29.020
当然那个函数

08:29.020 --> 08:31.020
所以说你得保存下来

08:31.020 --> 08:36.310
fn2

08:36.310 --> 08:37.310
那么这里

08:37.310 --> 08:38.310
把函数放过去

08:38.310 --> 08:39.310
对不对

08:39.310 --> 08:40.310
那么就移除了

08:40.310 --> 08:41.310
触发一次过后就移除了

08:41.310 --> 08:43.310
咱们来看一下吧

08:43.310 --> 08:44.310
你看

08:44.310 --> 08:45.310
触发1 触发2

08:45.310 --> 08:47.310
那么后面就没有2了

08:47.310 --> 08:49.310
没问题吧

08:49.310 --> 08:52.310
这就是关于函数基本用法

08:52.310 --> 08:53.310
再来一个例子

08:53.310 --> 08:55.310
它触发事件的时候

08:55.310 --> 08:57.310
还可以给它传一些参数

08:57.310 --> 08:59.310
比方说我们注册一个事件abc

08:59.310 --> 09:01.310
那么如果说触发事件的时候

09:01.310 --> 09:02.310
这里还可以有一些参数

09:02.310 --> 09:04.310
比方data

09:04.310 --> 09:06.310
data

09:06.310 --> 09:07.310
那怎么来传呢

09:07.310 --> 09:09.310
跟那个view是一样的

09:09.310 --> 09:10.310
触发事件名

09:10.310 --> 09:11.310
然后那第二个参数

09:11.310 --> 09:13.310
就可以一次给它写

09:13.310 --> 09:15.310
触发事件的时候

09:15.310 --> 09:16.310
把数据给它

09:16.310 --> 09:17.310
对吧 123

09:17.310 --> 09:19.310
再来看一下

09:19.310 --> 09:20.310
对吧

09:20.310 --> 09:21.310
所以123拿到了

09:21.310 --> 09:22.310
对吧

09:22.310 --> 09:23.310
它这里123就拿到了

09:23.310 --> 09:24.310
就相当于触发事件的时候

09:24.310 --> 09:25.310
它不是运行这些函数吗

09:25.310 --> 09:26.310
函数的参数

09:26.310 --> 09:27.310
它就给它传入后边的数据

09:27.310 --> 09:28.310
当然还可以传多个

09:28.310 --> 09:29.310
456

09:29.310 --> 09:30.310
那么这里

09:30.310 --> 09:31.310
比方说data1

09:31.310 --> 09:33.310
data2

09:33.310 --> 09:34.310
data1

09:34.310 --> 09:37.310
data2

09:37.310 --> 09:38.310
运行

09:38.310 --> 09:39.310
123456

09:39.310 --> 09:40.310
对吧

09:40.310 --> 09:41.310
好 那你用这个东西

09:41.310 --> 09:43.310
我们平时能用它的干嘛呢

09:43.310 --> 09:44.310
我举个例子吧

09:44.310 --> 09:45.310
随便举个例子

09:47.310 --> 09:50.310
比方说我们可以封装一个myrequest

09:50.310 --> 09:53.310
用它的统一的事件处理模型

09:53.310 --> 09:55.310
来封装一个myrequest

09:55.310 --> 09:56.310
就是平时我们用那个

09:56.310 --> 09:57.310
attp请求

09:57.310 --> 09:58.310
觉得特别麻烦

09:58.310 --> 09:59.310
我能不能用一种

09:59.310 --> 10:01.310
简单的方式来请求呢

10:01.310 --> 10:02.310
可以啊

10:02.310 --> 10:03.310
我们就可以自己封装一个嘛

10:03.310 --> 10:04.310
来吧

10:04.310 --> 10:05.310
我们来看怎么来写

10:05.310 --> 10:06.310
attp模块倒入进来

10:06.310 --> 10:07.310
attp

10:08.310 --> 10:10.310
再来一个就是

10:11.310 --> 10:12.310
还有什么模块呢

10:12.310 --> 10:15.310
就是event emitter

10:15.310 --> 10:17.310
event 事件嘛

10:17.310 --> 10:19.310
事件的触发器

10:19.310 --> 10:20.310
这叫事件触发器

10:20.310 --> 10:21.310
好 我们导出

10:21.310 --> 10:22.310
merge export

10:22.310 --> 10:23.310
导出什么呢

10:23.310 --> 10:24.310
导出一个内 class

10:24.310 --> 10:25.310
extend

10:25.310 --> 10:27.310
继承制什么呢

10:27.310 --> 10:29.310
继承制event emitter

10:29.310 --> 10:30.310
那么继承过后

10:30.310 --> 10:31.310
它是不是

10:31.310 --> 10:32.310
它里边也有那些

10:32.310 --> 10:33.310
乱七八的东西了

10:33.310 --> 10:34.310
对吧

10:34.310 --> 10:35.310
有什么呢

10:35.310 --> 10:36.310
按方法

10:36.310 --> 10:37.310
AMS方法都有了

10:37.310 --> 10:38.310
对不对

10:38.310 --> 10:39.310
那么这里面

10:39.310 --> 10:40.310
我们构造器里边

10:41.310 --> 10:43.310
因为我们这个是

10:43.310 --> 10:45.310
一个辅助请求的模块吧

10:45.310 --> 10:46.310
对吧

10:46.310 --> 10:47.310
请求模块

10:47.310 --> 10:49.310
就是发送一个

10:49.310 --> 10:50.310
网络请求的模块

10:52.750 --> 10:53.750
那么也就是说

10:53.750 --> 10:54.750
你要给我传一个

10:54.750 --> 10:55.750
传一个UIL地址

10:55.750 --> 10:56.750
你要请求哪一个地址

10:56.750 --> 10:57.750
你要给我

10:57.750 --> 10:58.750
还有一些请求的参数

10:58.750 --> 10:59.750
对吧

10:59.750 --> 11:00.750
什么请求方法

11:00.750 --> 11:01.750
你乱七八的东西

11:01.750 --> 11:02.750
都传给我

11:02.750 --> 11:03.750
好 那么这里面

11:03.750 --> 11:04.750
我们怎么玩呢

11:04.750 --> 11:05.750
我就把这些东西

11:05.750 --> 11:06.750
保存下来

11:06.750 --> 11:07.750
UIL地址

11:07.750 --> 11:08.750
保存下来

11:08.750 --> 11:09.750
保存下来

11:09.750 --> 11:10.750
没写完了

11:10.750 --> 11:11.750
你知道什么意思了

11:11.750 --> 11:13.750
保存下来

11:13.750 --> 11:14.750
好 保存下来过后

11:14.750 --> 11:15.750
我希望到时候

11:15.750 --> 11:16.750
到时候你这样子用

11:16.750 --> 11:18.750
当然这个是

11:18.750 --> 11:19.750
继承吧

11:19.750 --> 11:21.750
一定要调用修盘

11:21.750 --> 11:22.750
调用复利的各种函数

11:22.750 --> 11:23.750
好 那到时候

11:23.750 --> 11:24.750
我们希望怎么用呢

11:24.750 --> 11:25.750
我们希望这样子

11:25.750 --> 11:27.750
就是my request

11:27.750 --> 11:29.750
my request

11:29.750 --> 11:30.750
request

11:30.750 --> 11:32.750
sorry

11:32.750 --> 11:33.750
我希望这样子用

11:33.750 --> 11:37.750
就是我创建一个my request

11:37.750 --> 11:39.750
比方说我们请求

11:39.750 --> 11:41.750
请求你怎么了

11:41.750 --> 11:42.750
wsd2

11:42.750 --> 11:44.750
do1

11:44.750 --> 11:45.750
edu

11:45.750 --> 11:47.750
cqq.com

11:47.750 --> 11:48.750
请求这个地址

11:48.750 --> 11:49.750
我没有什么产量

11:49.750 --> 11:50.750
就一个拯人的

11:50.750 --> 11:52.750
全部拯人的配置就行了

11:52.750 --> 11:53.750
那么到时候

11:53.750 --> 11:54.750
你怎么来请求呢

11:54.750 --> 11:55.750
我希望你

11:55.750 --> 11:56.750
我这里可以调用send

11:56.750 --> 11:57.750
发送一个请求

11:57.750 --> 11:58.750
可以把请求体写进去

11:58.750 --> 12:00.750
是不是你类似于阿加克斯

12:00.750 --> 12:02.750
可以把请求体写进去

12:02.750 --> 12:04.030
然后就没有请求题

12:04.030 --> 12:06.330
那么我这样子我还可以监听

12:06.330 --> 12:07.350
监听什么呢

12:07.350 --> 12:10.170
还可以用request on来监听

12:10.170 --> 12:11.710
监听那个

12:11.710 --> 12:12.990
什么呢

12:12.990 --> 12:15.810
来自于data的事件

12:15.810 --> 12:17.610
来自于response嘛

12:17.610 --> 12:19.390
监听response事件

12:19.390 --> 12:20.930
监听response事件

12:20.930 --> 12:21.950
我们或者是

12:21.950 --> 12:23.490
这个事件短一点

12:23.490 --> 12:26.050
那么他会把这个响应结果拿给我

12:26.050 --> 12:26.810
我直接拿到响应结果了

12:26.810 --> 12:28.610
这样子写是不是简单很多了

12:28.610 --> 12:29.370
对不对

12:29.370 --> 12:31.410
当我们触发response事件的时候

12:31.610 --> 12:32.690
拿到这个响应结果

12:32.690 --> 12:34.690
我们就希望做成这个样子

12:34.690 --> 12:35.810
那怎么写呢

12:35.810 --> 12:38.090
那你这里肯定要写个圣的方法

12:38.090 --> 12:39.490
圣的方法

12:39.490 --> 12:40.690
你给我传一个body对吧

12:40.690 --> 12:41.890
给他一个默认值嘛

12:41.890 --> 12:42.650
body的话

12:42.650 --> 12:44.490
默认值一个控制不错

12:44.490 --> 12:45.410
那这里怎么玩呢

12:45.410 --> 12:47.890
无非就是创建一个request嘛

12:47.890 --> 12:48.090
对吧

12:48.090 --> 12:50.690
我们利用attp模块

12:50.690 --> 12:51.570
request

12:51.570 --> 12:54.370
所以把zster URL传进去

12:54.370 --> 12:56.170
zster options传进去

12:56.170 --> 12:56.370
对吧

12:56.370 --> 12:57.890
创建一个request

12:57.890 --> 12:59.330
然后request里边

12:59.330 --> 13:01.090
我们是不是可以用一个

13:01.250 --> 13:02.450
这里还有一个第三个函数

13:02.450 --> 13:03.210
回调函数

13:03.210 --> 13:06.210
就那收到收到响应过后的回调函数

13:06.210 --> 13:08.210
收到响应过后的回调函数

13:08.210 --> 13:08.770
好收到

13:08.770 --> 13:11.610
然后这里边我们就request就发出请求嘛

13:11.610 --> 13:12.650
就是write

13:12.650 --> 13:15.330
write什么的body对吧

13:15.330 --> 13:17.610
然后request

13:17.610 --> 13:18.210
the end

13:20.010 --> 13:21.210
我们就这样做

13:21.210 --> 13:24.010
我们要写入一些消息体

13:24.010 --> 13:25.370
然后就end

13:25.370 --> 13:26.850
好那么

13:26.850 --> 13:28.050
响应结果里边

13:28.050 --> 13:29.250
我们希望这边能收到

13:29.250 --> 13:30.730
就是直接是响应题

13:30.770 --> 13:33.170
响应头那些我都不要了

13:33.170 --> 13:34.610
头那些你也要吧

13:34.610 --> 13:35.570
也要吧

13:35.570 --> 13:37.170
你通过两个穿着穿给我

13:37.170 --> 13:39.570
一个是响应头headers

13:39.570 --> 13:40.970
一个是body对吧

13:40.970 --> 13:41.850
两个都给我

13:41.850 --> 13:45.520
我把这两个都输出

13:45.520 --> 13:47.040
输出body

13:47.040 --> 13:48.240
两个都给我

13:48.240 --> 13:48.960
那怎么来玩呢

13:48.960 --> 13:50.680
这个事情

13:50.680 --> 13:52.720
那这里呢我们就可以这样子

13:52.720 --> 13:54.520
request里边我们响应头很好说

13:54.520 --> 13:55.080
对吧

13:55.080 --> 13:56.000
响应头很好说

13:56.000 --> 13:57.640
我们得到一个辩量嘛

13:57.640 --> 13:58.680
headers对吧

13:58.680 --> 13:59.920
request点什么headers

13:59.920 --> 14:00.120
对吧

14:00.120 --> 14:00.720
都是都有的

14:00.720 --> 14:02.360
我都挡着得到辩量了

14:02.360 --> 14:03.560
然后主要是响应题

14:03.560 --> 14:05.440
响应题是不是要分断来传输

14:05.440 --> 14:06.120
那么我们这里呢

14:06.120 --> 14:07.080
是不是可以用一个

14:07.080 --> 14:08.480
我们之前都写过的results

14:08.480 --> 14:09.520
一个字符串

14:09.520 --> 14:11.040
然后request on

14:11.040 --> 14:12.560
他里边也是利用了

14:12.560 --> 14:13.840
inventor emitter的

14:13.840 --> 14:14.920
on data

14:14.920 --> 14:16.520
每一次得到一部分数据

14:16.520 --> 14:17.120
对不对

14:17.120 --> 14:19.040
然后我们把拼接到results里边

14:19.040 --> 14:20.080
trunk

14:20.080 --> 14:21.400
txt

14:21.400 --> 14:23.480
utf-8

14:23.480 --> 14:24.400
然后呢

14:24.400 --> 14:27.000
当他数据拿完了之后

14:27.000 --> 14:27.680
end

14:27.680 --> 14:28.400
拿完了之后

14:28.400 --> 14:29.600
我干嘛呢

14:29.680 --> 14:31.360
那么这个时候数据是不是拿完了

14:31.360 --> 14:31.920
拿完了过后

14:31.920 --> 14:32.800
我自己是不是

14:32.800 --> 14:34.240
我自己也是一个eventor emitter

14:34.240 --> 14:34.640
对吧

14:34.640 --> 14:35.600
是个触发器

14:35.600 --> 14:38.600
我就可以触发res emitter

14:38.600 --> 14:40.560
我自己就是一个eventor emitter吧

14:40.560 --> 14:41.800
我自己去触发什么呢

14:41.800 --> 14:42.640
触发

14:42.640 --> 14:44.720
那个res时间

14:44.720 --> 14:46.000
我们就是触发这个时间

14:46.000 --> 14:48.240
那么这边注册的时间是不是可以运行的

14:48.240 --> 14:48.520
对不对

14:48.520 --> 14:49.440
触发这个时间

14:49.440 --> 14:49.880
并且呢

14:49.880 --> 14:51.240
我把header传给你

14:51.240 --> 14:52.840
res headers传给你

14:52.840 --> 14:53.280
并且呢

14:53.280 --> 14:55.440
我把这个body就是results传给你

14:55.440 --> 14:56.640
对吧

14:56.640 --> 14:57.400
是不是有写完了

14:57.400 --> 14:58.600
就这么简单

14:58.680 --> 14:59.880
我就可以自己做了一个

14:59.880 --> 15:02.560
类似于这个世界触发器出来

15:02.560 --> 15:03.960
那么使用了loader接式里面

15:03.960 --> 15:05.880
通用了世界模型

15:05.880 --> 15:07.040
它就是起这么一个作用

15:07.040 --> 15:07.600
就可以

15:07.600 --> 15:08.880
你可以灵活的去开发

15:08.880 --> 15:11.320
你想要的任何的世界模型的东西

15:11.320 --> 15:12.400
那我们来看一下吧

15:12.400 --> 15:12.920
那么现在呢

15:12.920 --> 15:14.080
我们去发送一个请求

15:14.080 --> 15:17.220
对吧

15:17.220 --> 15:18.140
运行

15:18.140 --> 15:19.820
你看是不是拿到结果了

15:19.820 --> 15:20.820
拿到了消息体

15:20.820 --> 15:21.020
对吧

15:21.020 --> 15:21.820
完整的消息体

15:24.820 --> 15:26.220
前面又拿到了想印头

15:26.220 --> 15:26.540
对不对

15:26.540 --> 15:27.500
是不是都拿到了

15:27.500 --> 15:30.460
当然还可以给他传一些别的东西进来

15:30.500 --> 15:31.660
这就是这么一回事

15:31.660 --> 15:33.020
其实没有什么复杂的

15:33.020 --> 15:33.860
就是你可以

15:33.860 --> 15:35.220
于是我们学习这个东西

15:35.220 --> 15:35.980
主要是

15:35.980 --> 15:38.620
将来你可能会自己去封装一些模块

15:38.620 --> 15:40.820
并且想使用loader接式里面

15:40.820 --> 15:42.260
通用了这种世界

15:42.260 --> 15:43.620
世界监听模型

15:43.620 --> 15:45.660
那么就可以用这种方式了

15:45.660 --> 15:45.860
好

15:45.860 --> 15:47.740
可以去好好看下这个代码

15:47.740 --> 15:49.380
其他的我没有什么好说的了

15:49.380 --> 15:52.340
loader核心部部分就讲完了

15:52.340 --> 15:52.980
那么下一张

15:52.980 --> 15:53.940
我们去讲

15:53.940 --> 15:54.820
因为我们学习loader了

15:54.820 --> 15:56.540
不仅要学习loader本身

15:56.540 --> 15:57.860
还要学习一些

15:57.860 --> 15:59.220
我们在loader的开发过程中

15:59.260 --> 16:01.100
可能要用到一些别的技术

16:01.100 --> 16:03.620
那些技术有可能跟loader没有直接关系

16:03.620 --> 16:06.220
但是我们在因为loader毕竟是后干

16:06.220 --> 16:10.260
后来它还不仅仅是设计代码

16:10.260 --> 16:12.020
还设计到其他的一些技术

16:12.020 --> 16:13.820
那么我们可能会设计到一些其他技术

16:13.820 --> 16:16.100
或者是一些第三方模块之类的东西

16:16.100 --> 16:17.500
我们下一张节

16:17.500 --> 16:19.260
后续张节慢慢讲解吧

16:19.260 --> 16:19.460
OK

16:19.460 --> 16:20.660
那么这一张我们就到此结束了

