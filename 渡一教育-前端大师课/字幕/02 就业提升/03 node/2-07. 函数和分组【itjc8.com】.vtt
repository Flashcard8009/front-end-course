WEBVTT

00:01.900 --> 00:05.900
这节课我们再来看一下函数和分组

00:06.900 --> 00:11.900
这一部分呢 我当时想了一下我想把它作为扩展课程吧

00:11.900 --> 00:15.900
但是函数这个东西 函数这个东西是必须要学习的

00:15.900 --> 00:18.900
分组呢 你尽量听吧

00:18.900 --> 00:20.900
分组是有一点复杂的

00:20.900 --> 00:22.900
它其实语法并不复杂

00:22.900 --> 00:25.900
主要是它在不同的应用场景里边

00:25.900 --> 00:27.900
它就做了一些复杂的查询

00:27.900 --> 00:28.900
我们尽量讲吧

00:28.900 --> 00:30.900
因为咱们也不是学后段吧

00:31.900 --> 00:34.900
我们先把函数看了 函数是比较简单的

00:34.900 --> 00:36.900
好看函数啊

00:36.900 --> 00:39.900
在麦斯克里边的函数分为两种

00:39.900 --> 00:41.900
用法都是一样的

00:41.900 --> 00:43.900
一种是内置函数 一种是自定义函数

00:43.900 --> 00:45.900
跟这个GS是不一样的

00:45.900 --> 00:47.900
GS里边说你可以这个

00:47.900 --> 00:49.900
就系统给你提供了一些函数

00:49.900 --> 00:51.900
支部串函数啊 速度函数 对吧

00:51.900 --> 00:53.900
那么自己呢 也可以学一些函数

00:53.900 --> 00:55.900
麦斯克也是这样子

00:55.900 --> 00:59.900
只不过呢 我们这里可能是不学习自定义函数的

00:59.900 --> 01:01.900
因为你们毕竟不是后端

01:01.900 --> 01:03.900
也用不到那么复杂的一些查询

01:03.900 --> 01:05.900
所以说我们不学自定义函数

01:05.900 --> 01:07.900
我们来看一下它里边提供了内置函数

01:07.900 --> 01:08.900
就可以了

01:08.900 --> 01:10.900
好 内置函数咱们看一下

01:10.900 --> 01:12.900
我给它分成这么几个方面

01:12.900 --> 01:15.900
一个是数学 一个是聚合 一个是制服 一个是日期

01:15.900 --> 01:17.900
一个个说吧

01:17.900 --> 01:19.900
首先说这个数学

01:19.900 --> 01:21.900
数学这个函数我们了解一下

01:21.900 --> 01:25.900
可能极少的情况下有可能会用到

01:25.900 --> 01:28.900
我把这些常见的数学函数给它列出来了

01:28.900 --> 01:30.900
实际上呢 数学函数呢

01:30.900 --> 01:32.900
这里边还有很多很多

01:32.900 --> 01:34.900
大家有兴趣的话可以在网上去查一下

01:34.900 --> 01:36.900
买这个函数一收出来一大堆

01:36.900 --> 01:39.900
咱们来看一下几个可能会用到的

01:39.900 --> 01:41.900
本身数学就用到比较少

01:41.900 --> 01:43.900
可能会用到的 一个是ABS

01:43.900 --> 01:46.900
反而回来是什么呢 反而回来是x 绝对值

01:46.900 --> 01:47.900
absolute

01:47.900 --> 01:48.900
那么这个东西很简单 对吧

01:48.900 --> 01:49.900
一看就明白了

01:49.900 --> 01:53.470
比方说我们举个例子

01:53.470 --> 01:54.470
是那个字

01:54.470 --> 01:57.780
我们就直接打一个东西吧

01:57.780 --> 01:59.780
比方说一个

01:59.780 --> 02:01.780
我们写个abs

02:01.780 --> 02:03.780
这里写个-1

02:03.780 --> 02:05.780
咱们来运行一下

02:05.780 --> 02:07.780
你看 是不是就是1

02:07.780 --> 02:09.780
对吧 表还变成绝对值的

02:09.780 --> 02:10.780
就起这么一个作用

02:10.780 --> 02:12.780
这是abs

02:12.780 --> 02:14.780
cylin就表示cylin

02:14.780 --> 02:16.780
向上取整 咱们来看一下吧

02:16.780 --> 02:19.780
是那个是cylin sale

02:19.780 --> 02:21.780
它有个别名叫sale

02:21.780 --> 02:23.780
跟那个js

02:23.780 --> 02:25.780
js的sale还是一样的

02:25.780 --> 02:27.780
比方说咱们1.4

02:27.780 --> 02:29.780
向上取整 我们来看一下

02:29.780 --> 02:31.780
得到结果是多少

02:35.780 --> 02:37.780
是不是2 对不对

02:37.780 --> 02:38.780
2 非常简单

02:38.780 --> 02:40.780
for all 向下取整 不说了

02:40.780 --> 02:43.780
mod取模相当于是

02:43.780 --> 02:44.780
求与数 对吧

02:44.780 --> 02:46.780
x 除以y的与数

02:46.780 --> 02:47.780
至于是

02:47.780 --> 02:49.780
这个是π 得到圆周率

02:49.780 --> 02:52.780
这个是Ridon 得到0到1之间的随机数

02:52.780 --> 02:54.780
这个是wrong的

02:54.780 --> 02:56.780
4折5入 把x

02:56.780 --> 02:58.780
我们来看一下wrong的吧

03:00.780 --> 03:01.780
wrong的

03:01.780 --> 03:03.780
比方说我们这里写个1.5

03:03.780 --> 03:06.780
1.5的话 咱们来看一下这句话

03:06.780 --> 03:08.780
1.5的话 得到的结果是2

03:08.780 --> 03:10.780
4折5入

03:10.780 --> 03:13.780
如果说 你不写第二个参数的话

03:13.780 --> 03:15.780
那么相当于是

03:15.780 --> 03:16.780
值保留整数

03:16.780 --> 03:18.780
如果说你写第二个参数的话

03:18.780 --> 03:19.780
比方说我们这里

03:19.780 --> 03:21.780
3.1415926

03:21.780 --> 03:23.780
咱们如果说直接运行

03:23.780 --> 03:24.780
那么得到的是多少呢

03:24.780 --> 03:25.780
13 对吧

03:25.780 --> 03:27.780
因为对于后边的小数4折5入

03:27.780 --> 03:29.780
那么得到一个整数3

03:29.780 --> 03:31.780
那如果说你后边写第二个参数的话

03:31.780 --> 03:33.780
你可以问他保留几位小数

03:33.780 --> 03:34.780
比方说保留两位

03:34.780 --> 03:35.780
那么得到的是什么呢

03:35.780 --> 03:36.780
3.14

03:36.780 --> 03:37.780
就这么简单

03:37.780 --> 03:39.780
非常简单 是4折5入

03:39.780 --> 03:40.780
wrong

03:40.780 --> 03:42.780
trunket

03:42.780 --> 03:45.780
返回数字 结断为y位的小数结果

03:45.780 --> 03:47.780
这个东西有的时候还蛮有用的

03:47.780 --> 03:50.780
比方说trunket

03:50.780 --> 03:53.780
比方说我们这里3.1415926

03:53.780 --> 03:56.780
我们这里取几位呢

03:56.780 --> 03:58.780
取三位小数

03:58.780 --> 03:59.780
我们来看一下吧

03:59.780 --> 04:00.780
取三位小数

04:00.780 --> 04:02.780
那么这里也取三位小数

04:02.780 --> 04:03.780
咱们看一下这一部分

04:03.780 --> 04:04.780
它打赢了结果

04:04.780 --> 04:06.780
那么第一个打赢结个wrong的

04:06.780 --> 04:07.780
它得到的是3.142

04:07.780 --> 04:08.780
对吧 为什么

04:08.780 --> 04:09.780
4折5入了吗

04:09.780 --> 04:10.780
对不对 进一

04:10.780 --> 04:11.780
那么第二个呢

04:11.780 --> 04:12.780
就是我们的trunket

04:12.780 --> 04:13.780
得到的是3.141

04:13.780 --> 04:14.780
一个是结断

04:14.780 --> 04:15.780
一个是4折5入

04:15.780 --> 04:16.780
就这么简单

04:16.780 --> 04:18.780
这是trunket

04:18.780 --> 04:19.780
trunket有的时候有什么用的

04:19.780 --> 04:20.780
它是这样子

04:20.780 --> 04:21.780
比方说我们trunket

04:21.780 --> 04:23.780
那个trunket

04:23.780 --> 04:26.780
用户的薪水的时候

04:26.780 --> 04:28.780
我们保留两位小数

04:28.780 --> 04:29.780
对吧

04:29.780 --> 04:30.780
我们比方说sinary

04:30.780 --> 04:33.780
我们这可以用trunket

04:33.780 --> 04:35.780
结断

04:35.780 --> 04:36.780
sinary

04:36.780 --> 04:37.780
对吧 把sinary放这

04:37.780 --> 04:39.780
然后呢 保留几位小数呢

04:39.780 --> 04:40.780
保留两位小数

04:40.780 --> 04:41.780
trunket

04:41.780 --> 04:42.780
trunket

04:42.780 --> 04:43.780
那个表呢

04:43.780 --> 04:44.780
咱们来看一下吧

04:44.780 --> 04:46.780
我们这一年呢

04:46.780 --> 04:47.780
trunket

04:47.780 --> 04:48.780
保留了两位小数

04:48.780 --> 04:50.780
如果说你只想保留整数的话

04:50.780 --> 04:51.780
那么这里就写

04:51.780 --> 04:52.780
不写 对吧

04:52.780 --> 04:54.780
不写就保留整数

04:54.780 --> 04:56.780
必须得写个0嘛

04:56.780 --> 05:00.220
是不是保留整数

05:00.220 --> 05:01.220
对不对

05:01.220 --> 05:02.220
写0的话

05:02.220 --> 05:03.220
那还不是用sale

05:03.220 --> 05:04.220
对吧 直接截断

05:04.220 --> 05:06.220
直接去掉是一样的

05:06.220 --> 05:08.220
好 这是用Floor

05:08.220 --> 05:09.220
是一样的

05:09.220 --> 05:10.220
这是这一部分

05:10.220 --> 05:12.220
再帮大家保存一下

05:12.220 --> 05:16.300
这是数学函数

05:16.300 --> 05:19.300
数学函数

05:19.300 --> 05:21.300
我现在这个系统又换成mic了

05:21.300 --> 05:22.300
不然的话

05:22.300 --> 05:23.300
我现在还在讲夹吧

05:23.300 --> 05:24.300
一会讲夹吧

05:24.300 --> 05:26.300
一会讲前端

05:26.300 --> 05:27.300
一会讲了

05:27.300 --> 05:28.300
一会用mic

05:28.300 --> 05:29.300
一会用windows

05:29.300 --> 05:30.300
我人都快疯掉了

05:30.300 --> 05:32.300
所以我现在同一换成mic

05:32.300 --> 05:33.300
不过是一样的

05:33.300 --> 05:34.300
都一样的

05:34.300 --> 05:35.300
这是这一部分

05:35.300 --> 05:36.300
数学函数

05:39.300 --> 05:40.300
下一个

05:40.300 --> 05:41.300
下一个是聚合

05:41.300 --> 05:44.300
聚合函数是用的最多的

05:44.300 --> 05:45.300
如果说你们

05:45.300 --> 05:46.300
我们这一张

05:46.300 --> 05:48.300
纯粹就是为了学它的

05:48.300 --> 05:50.300
生产的东西都是额外丰盛的

05:50.300 --> 05:52.300
所以这一部分要注意听

05:52.300 --> 05:53.300
其他地方我们了解一下

05:53.300 --> 05:54.300
听了之后就行了

05:54.300 --> 05:56.300
聚合函数是最重要的

05:56.300 --> 05:58.300
而且这几个聚合函数

05:58.300 --> 06:01.300
相对于其他函数用的都比较多

06:01.300 --> 06:03.300
而这些聚合函数里面

06:03.300 --> 06:05.300
用的最多最多的就是cult

06:05.300 --> 06:06.300
咱们一个个说

06:06.300 --> 06:08.300
首先说Average

06:08.300 --> 06:09.300
Avg

06:09.300 --> 06:10.300
什么意思呢

06:10.300 --> 06:11.300
聚合函数

06:11.300 --> 06:12.300
我们要一般用的

06:12.300 --> 06:14.300
就是查询表的时候

06:14.300 --> 06:16.300
这个聚合函数表示

06:16.300 --> 06:19.300
得到指定列的平均值

06:19.300 --> 06:20.300
很好理解

06:20.300 --> 06:21.300
Average

06:21.300 --> 06:23.300
比方说select

06:23.300 --> 06:25.300
咱们用一个Avg

06:25.300 --> 06:27.300
这里边还可以写distinct

06:27.300 --> 06:28.300
去掉重复

06:28.300 --> 06:30.300
再来求绝对的平均值

06:30.300 --> 06:32.300
我们这里比方说写个salary

06:33.300 --> 06:36.300
是不是求薪水的平均值

06:36.300 --> 06:37.300
查询哪个表

06:37.300 --> 06:40.300
查询employee表

06:41.300 --> 06:42.300
你看

06:42.300 --> 06:44.300
是不是得到了employee

06:45.300 --> 06:48.300
所有的员工薪水的平均值

06:48.300 --> 06:49.300
对不对

06:49.300 --> 06:51.300
那么这里的聚合函数

06:51.300 --> 06:52.300
发现一个特点没有

06:52.300 --> 06:54.300
是不是所有的行

06:54.300 --> 06:55.300
变成一行了

06:55.300 --> 06:57.300
聚合在一起了

06:57.300 --> 06:58.300
就像一个汇总一样

06:58.300 --> 07:00.300
汇总求平均值

07:00.300 --> 07:01.300
那么这样子

07:02.300 --> 07:03.300
还可以给他订个别名

07:03.300 --> 07:04.300
给他订个别名

07:04.300 --> 07:06.300
就叫做Avg

07:08.300 --> 07:10.300
订个别名Avg

07:11.300 --> 07:13.300
但是这样子一来了

07:13.300 --> 07:14.300
就找这个结果

07:14.300 --> 07:16.300
你能不能查其他链

07:16.300 --> 07:18.300
你看一下我如果说查其他链

07:18.300 --> 07:19.300
是爆错了

07:19.300 --> 07:21.300
聚合函数

07:21.300 --> 07:22.300
这里在查询的时候

07:22.300 --> 07:25.300
你不能跟其他链在这里混用

07:25.300 --> 07:26.300
为什么

07:26.300 --> 07:27.300
因为其他

07:27.300 --> 07:28.300
我们聚合函数

07:28.300 --> 07:29.300
所有东西都聚在一起了

07:29.300 --> 07:30.300
对吧

07:30.300 --> 07:31.300
比方说你在这里查ID

07:31.300 --> 07:32.300
看那个逻辑就不对了

07:32.300 --> 07:34.300
ID查出来应该是什么玩意

07:34.300 --> 07:35.300
你看看

07:35.300 --> 07:37.300
所以有很多行

07:37.300 --> 07:38.300
有很多个ID

07:38.300 --> 07:39.300
那么现在

07:39.300 --> 07:41.300
我把所有的行聚合在一起了

07:41.300 --> 07:42.300
这个ID取哪一个

07:42.300 --> 07:43.300
你告诉我取哪一个

07:43.300 --> 07:45.300
取张参的还是取理事的

07:45.300 --> 07:46.300
这么去没法取了

07:46.300 --> 07:47.300
对不对

07:47.300 --> 07:48.300
所以说这个聚合函数

07:48.300 --> 07:49.300
通常我们用的时候

07:49.300 --> 07:50.300
在这种简单查询里面

07:50.300 --> 07:51.300
用的时候

07:51.300 --> 07:54.300
我们就一般就用一个靠车

07:54.300 --> 07:55.300
用一个Avg

07:55.300 --> 07:57.300
去查一个东西出来就行了

07:57.300 --> 07:58.300
对吧

07:58.300 --> 08:00.300
这是Avg

08:00.300 --> 08:01.300
然后这个Cort

08:01.300 --> 08:02.300
Cort指的是什么呢

08:02.300 --> 08:05.300
指的是查询指定列中的

08:05.300 --> 08:07.300
Final值的个数

08:07.300 --> 08:08.300
这是啥意思

08:08.300 --> 08:09.300
说的好抽象

08:09.300 --> 08:10.300
这是啥意思

08:10.300 --> 08:11.300
是那个

08:11.300 --> 08:14.300
我们先用个Cort

08:14.300 --> 08:16.300
我们不用写那么多

08:16.300 --> 08:21.300
我们这里就写一个ID

08:21.300 --> 08:22.300
Final

08:22.300 --> 08:23.300
Employ

08:23.300 --> 08:25.300
这是得到的是什么呢

08:25.300 --> 08:26.300
得到的是

08:26.300 --> 08:27.300
我们比方说

08:27.300 --> 08:28.300
我们直接这样子查

08:28.300 --> 08:29.300
直接这样子查的话

08:29.300 --> 08:30.300
等下有一发不正确

08:30.300 --> 08:31.300
直接这样子查的话

08:31.300 --> 08:32.300
是不是把

08:32.300 --> 08:34.300
员工的所有的员工

08:34.300 --> 08:35.300
全部查出来

08:35.300 --> 08:36.300
对不对

08:36.300 --> 08:38.300
然后我们这里用个Cort

08:38.300 --> 08:39.300
它去数一数

08:39.300 --> 08:41.300
这些员工当中

08:41.300 --> 08:43.300
哪些是有ID的

08:43.300 --> 08:45.300
有ID的有多少个

08:45.300 --> 08:46.300
就这么个意思

08:46.300 --> 08:47.300
比方说

08:47.300 --> 08:50.300
咱们把所有的员工查出来

08:50.300 --> 08:52.300
查出来是不是有很多数据

08:52.300 --> 08:53.300
那么一行一行去数一数

08:53.300 --> 08:54.300
第一个有没有ID

08:54.300 --> 08:55.300
有算一个

08:55.300 --> 08:56.300
第二个有没有ID

08:56.300 --> 08:57.300
算两个

08:57.300 --> 08:58.300
第三个有没有ID

08:58.300 --> 08:59.300
算三个

08:59.300 --> 09:00.300
对不对

09:00.300 --> 09:02.300
我们这里看Cort

09:02.300 --> 09:04.300
它就会把这个ID

09:04.300 --> 09:05.300
它就把这个ID

09:05.300 --> 09:07.300
所有有ID的员工

09:07.300 --> 09:09.300
的数量是不是查出来了

09:09.300 --> 09:10.300
那么这个东西

09:10.300 --> 09:12.300
是不是就是员工的数量

09:12.300 --> 09:13.300
是不是

09:13.300 --> 09:14.300
当然就是

09:14.300 --> 09:15.300
对吧

09:15.300 --> 09:16.300
哪个员工没有ID呢

09:16.300 --> 09:17.300
ID是组件

09:17.300 --> 09:18.300
必须不能围空的

09:18.300 --> 09:19.300
对吧

09:19.300 --> 09:20.300
组件是不能围空的

09:20.300 --> 09:21.300
那么这里肯定就是

09:21.300 --> 09:22.300
把员工的数量查出来了

09:22.300 --> 09:23.300
相当于这一部分查询的是

09:23.300 --> 09:25.300
查询员工的数量

09:25.300 --> 09:27.300
员工的数量

09:27.300 --> 09:29.300
那么这里我要说一下

09:29.300 --> 09:31.300
就是这里有几个疑问

09:31.300 --> 09:32.300
有些同学说

09:32.300 --> 09:33.300
那这个数量

09:33.300 --> 09:34.300
我可以不用

09:34.300 --> 09:35.300
这种方式来查询

09:35.300 --> 09:36.300
有些同学很聪明

09:36.300 --> 09:38.300
它是这样子来查询

09:38.300 --> 09:39.300
比方说

09:39.300 --> 09:42.300
我们查询ID

09:42.300 --> 09:45.300
from employee

09:45.300 --> 09:47.300
然后再加个order by

09:47.300 --> 09:49.300
然后这里来写上一个

09:49.300 --> 09:50.300
就是ID

09:50.300 --> 09:51.300
ID的什么

09:51.300 --> 09:53.300
ID的导讯

09:53.300 --> 09:54.300
desk导讯

09:54.300 --> 09:56.300
然后我们来用limit

09:56.300 --> 09:57.300
取一个

09:57.300 --> 09:58.300
对吧

09:58.300 --> 10:00.300
挑过0个

10:00.300 --> 10:01.300
取一个

10:01.300 --> 10:02.300
有时候很聪明

10:02.300 --> 10:03.300
它说这种方式

10:03.300 --> 10:04.300
是不是也能查询

10:04.300 --> 10:06.300
员工的数量

10:06.300 --> 10:07.300
是不是

10:07.300 --> 10:08.300
这东西能不能查

10:08.300 --> 10:10.300
员工的数量

10:10.300 --> 10:11.300
不行

10:11.300 --> 10:12.300
这个东西是不行的

10:12.300 --> 10:13.300
为什么

10:13.300 --> 10:14.300
因为你的这个地方

10:14.300 --> 10:15.300
做了一个假设

10:15.300 --> 10:18.300
假设是ID是连续的

10:18.300 --> 10:20.300
并且是从一开始的

10:20.300 --> 10:22.300
是不是做了这么一个假设

10:22.300 --> 10:23.300
那凭什么

10:23.300 --> 10:24.300
ID是可以不连续的

10:24.300 --> 10:25.300
ID是个组件

10:25.300 --> 10:26.300
ID不能变

10:26.300 --> 10:27.300
中间不要说

10:27.300 --> 10:28.300
你把这个东西删了

10:28.300 --> 10:30.300
删出纪录

10:30.300 --> 10:31.300
确定

10:31.300 --> 10:33.300
这次你怎么办

10:33.300 --> 10:34.300
你看

10:34.300 --> 10:35.300
这样子查询出来

10:35.300 --> 10:36.300
查询出来

10:36.300 --> 10:37.300
是不是还是欺败

10:37.300 --> 10:38.300
那么真实的员工数量

10:38.300 --> 10:39.300
是不是699

10:39.300 --> 10:40.300
对吧

10:40.300 --> 10:41.300
所以说你不能用这种查询

10:41.300 --> 10:42.300
你应该用这种查询

10:42.300 --> 10:43.300
下面这个查询是错误的

10:43.300 --> 10:45.300
不能用这种方式来查询

10:45.300 --> 10:46.300
这是

10:46.300 --> 10:47.300
查询员工的数量

10:47.300 --> 10:48.300
另外我再说一下

10:48.300 --> 10:49.300
这里边

10:49.300 --> 10:51.300
你还可以写多个里

10:51.300 --> 10:52.300
比方说你写这样子写

10:52.300 --> 10:54.300
这样子写是怎么意思呢

10:54.300 --> 10:55.300
这样子写

10:55.300 --> 10:56.300
这样子写的话

10:56.300 --> 10:57.300
查的就是

10:57.300 --> 10:59.300
我们看一下吧

11:00.300 --> 11:02.300
又还有 error

11:02.300 --> 11:04.300
check the menu

11:04.300 --> 11:08.730
看一下

11:08.730 --> 11:09.730
哪里写错了

11:09.730 --> 11:13.620
它还不允许这样子写

11:13.620 --> 11:15.620
还不允许这样子写

11:15.620 --> 11:16.620
我看一下

11:16.620 --> 11:18.620
我记得可以

11:18.620 --> 11:20.620
本来说我是可以这样子写的

11:23.620 --> 11:24.620
这里写表达式

11:24.620 --> 11:25.620
它也不能这样子写

11:25.620 --> 11:26.620
我再说一下这个

11:26.620 --> 11:27.620
新号

11:27.620 --> 11:29.620
新号是可以写的

11:29.620 --> 11:30.620
新号是可以写的

11:30.620 --> 11:31.620
那么这个查新号

11:31.620 --> 11:32.620
是什么意思呢

11:33.620 --> 11:34.620
有的时候

11:34.620 --> 11:36.620
以前做后段的时候

11:36.620 --> 11:37.620
会有经常问题

11:37.620 --> 11:38.620
这个东西

11:38.620 --> 11:39.620
地方查 ID 跟查新号

11:39.620 --> 11:40.620
或者是查

11:40.620 --> 11:41.620
其他列跟查新号

11:41.620 --> 11:43.620
有什么样的区别

11:43.620 --> 11:45.620
刚才为什么我记成了

11:45.620 --> 11:46.620
多个列呢

11:46.620 --> 11:47.620
因为

11:47.620 --> 11:48.620
蛇口语句

11:48.620 --> 11:50.620
在不同的数据库里边

11:50.620 --> 11:52.620
有一些细微的差别

11:52.620 --> 11:53.620
有的数据库是

11:53.620 --> 11:54.620
支持这种查法的

11:54.620 --> 11:55.620
买蛇口来不支持

11:55.620 --> 11:56.620
不支持就算了

11:56.620 --> 11:57.620
但是这个东西

11:57.620 --> 11:58.620
支持的

11:58.620 --> 11:59.620
新号

11:59.620 --> 12:00.620
那么这个新号

12:00.620 --> 12:01.620
是什么意思呢

12:01.620 --> 12:03.620
如果说你写的是新号的话

12:03.620 --> 12:04.620
它是这样子查的

12:04.620 --> 12:05.620
它就去查什么呢

12:05.620 --> 12:07.620
查 employee 新号

12:07.620 --> 12:08.620
它就去查这个

12:08.620 --> 12:10.620
它先把这个东西查出来

12:10.620 --> 12:11.620
然后一行一行数

12:11.620 --> 12:12.620
看第一行里边

12:12.620 --> 12:15.620
是不是所有的东西都有值

12:15.620 --> 12:16.620
看第一行里边

12:16.620 --> 12:18.620
是不是至少有一个东西有值

12:18.620 --> 12:20.620
只要你有一个东西有值

12:20.620 --> 12:21.620
那么

12:21.620 --> 12:22.620
我就算

12:22.620 --> 12:23.620
我就算一个

12:23.620 --> 12:24.620
这个地方

12:24.620 --> 12:27.620
只要至少有一个有值

12:27.620 --> 12:28.620
至少有一个我就算一个

12:28.620 --> 12:29.620
那么由于

12:29.620 --> 12:30.620
我们查的新号里边

12:30.620 --> 12:31.620
是不是包含ID

12:31.620 --> 12:32.620
ID一定有值的

12:32.620 --> 12:34.620
因此靠扯新号

12:34.620 --> 12:35.620
跟靠扯ID的结果

12:35.620 --> 12:37.620
是完全一样的

12:37.620 --> 12:39.620
结果是完全一样的

12:39.620 --> 12:40.620
明白了意思吧

12:40.620 --> 12:41.620
699

12:41.620 --> 12:42.620
那么这里的新号

12:42.620 --> 12:43.620
我们也看一下

12:43.620 --> 12:45.620
也是699一样的

12:45.620 --> 12:47.620
但是

12:47.620 --> 12:49.620
尽量不要用新号

12:49.620 --> 12:50.620
为什么呢

12:50.620 --> 12:51.620
新号是不是

12:51.620 --> 12:52.620
数的东西太多了

12:52.620 --> 12:53.620
它一行里边

12:53.620 --> 12:54.620
要数很多很多的

12:54.620 --> 12:55.620
把它全部列出

12:55.620 --> 12:56.620
去数一遍

12:56.620 --> 12:57.620
是不是要全部去数一遍

12:57.620 --> 12:58.620
因此

12:58.620 --> 12:59.620
尽量的不要用新号

12:59.620 --> 13:00.620
而且它查询

13:00.620 --> 13:01.620
它查询的结果

13:01.620 --> 13:02.620
它的内存里边

13:02.620 --> 13:03.620
它去

13:03.620 --> 13:04.620
用那个

13:04.620 --> 13:05.620
可以想象一个指针

13:05.620 --> 13:06.620
在一行一行去数的时候

13:06.620 --> 13:08.620
它把全部列过一遍

13:08.620 --> 13:09.620
它就是这样运作的

13:09.620 --> 13:10.620
所以说

13:10.620 --> 13:11.620
尽量不要用新号

13:11.620 --> 13:12.620
用ID

13:12.620 --> 13:14.620
但是有的时候那么写

13:14.620 --> 13:15.620
有的时候

13:15.620 --> 13:17.620
有些人写写习惯了

13:17.620 --> 13:18.620
也会用新号

13:18.620 --> 13:19.620
但是新号的效率

13:19.620 --> 13:20.620
确实要低一些

13:20.620 --> 13:21.620
这是关于查询

13:21.620 --> 13:22.620
员工的数量

13:22.620 --> 13:24.620
这是靠扯ID

13:24.620 --> 13:25.620
当然

13:25.620 --> 13:26.620
最小值

13:26.620 --> 13:27.620
最大值

13:27.620 --> 13:28.620
上

13:28.620 --> 13:30.620
咱们来直接来一个综合的

13:30.620 --> 13:31.620
这里我们

13:31.620 --> 13:32.620
select

13:32.620 --> 13:33.620
一个

13:33.620 --> 13:36.620
靠扯ID

13:36.620 --> 13:37.620
这是什么呢

13:37.620 --> 13:38.620
员工数量

13:38.620 --> 13:39.620
我们用中人

13:40.620 --> 13:42.620
员工数量

13:43.620 --> 13:44.620
这是第一个

13:46.620 --> 13:47.620
它写不过来了

13:48.620 --> 13:49.620
然后我们

13:49.620 --> 13:51.620
聚合的查询

13:51.620 --> 13:52.620
我们可以写多个聚合

13:52.620 --> 13:53.620
因为他们都是聚合

13:53.620 --> 13:54.620
都是把所有东西

13:54.620 --> 13:55.620
压扁

13:55.620 --> 13:56.620
对不对

13:56.620 --> 13:57.620
所以说

13:57.620 --> 13:58.620
我们可以写多个聚合

13:58.620 --> 13:59.620
但是你不能写展开的

13:59.620 --> 14:00.620
就是你不能写普通的

14:00.620 --> 14:01.620
写普通的

14:01.620 --> 14:02.620
肯定要爆出

14:02.620 --> 14:04.620
咱们来看一下Average

14:04.620 --> 14:05.620
刚才写过了

14:05.620 --> 14:06.620
Sanary

14:06.620 --> 14:07.620
这个是什么呢

14:07.620 --> 14:10.620
这个是平均新字

14:12.620 --> 14:13.620
再来一个

14:13.620 --> 14:14.620
上

14:14.620 --> 14:15.620
总新字

14:15.620 --> 14:17.620
就是一个月的支出

14:18.620 --> 14:20.620
总新字

14:20.620 --> 14:22.620
全部写一个聚合

14:22.620 --> 14:23.620
会种

14:23.620 --> 14:25.620
然后再写

14:25.620 --> 14:28.990
最小新字

14:28.990 --> 14:30.990
最小新字

14:30.990 --> 14:32.990
然后再写Max

14:32.990 --> 14:33.990
Sanary

14:33.990 --> 14:35.990
这是最大的新字

14:35.990 --> 14:39.300
然后再来一个

14:39.300 --> 14:40.300
没了

14:40.300 --> 14:41.300
没了

14:41.300 --> 14:42.300
好

14:42.300 --> 14:43.300
咱们来查一下

14:43.300 --> 14:45.300
from employee

14:46.300 --> 14:47.300
运销

14:48.300 --> 14:49.300
你看

14:49.300 --> 14:50.300
是不是都可以查出来

14:50.300 --> 14:51.300
说聚合的查询

14:51.300 --> 14:52.300
是可以一起写的

14:52.300 --> 14:54.300
这是关于聚合

14:54.300 --> 14:55.300
聚合函数

14:55.300 --> 14:57.300
这里保存一下

14:57.300 --> 14:59.300
聚合函数

14:59.300 --> 15:06.140
这是聚合

15:06.140 --> 15:08.140
然后接下来是

15:08.140 --> 15:10.140
制服

15:10.140 --> 15:12.140
就是一些制服的处理

15:12.140 --> 15:13.140
坑开着

15:13.140 --> 15:15.140
将多个东西

15:15.140 --> 15:17.140
连成一个制服串

15:17.140 --> 15:18.140
那么这个东西

15:18.140 --> 15:19.140
第二个是

15:19.140 --> 15:20.140
将连成制服串

15:20.140 --> 15:21.140
并且使用

15:21.140 --> 15:22.140
第一个参数

15:22.140 --> 15:23.140
来进行分割

15:23.140 --> 15:25.140
比方说吧

15:25.140 --> 15:26.140
举个例子

15:26.140 --> 15:27.140
这个随便下举个例子

15:27.140 --> 15:29.140
这个东西用的比较少

15:29.140 --> 15:30.140
比方说

15:30.140 --> 15:31.140
我们要查询

15:31.140 --> 15:33.140
把员工的姓名

15:33.140 --> 15:35.140
和员工的

15:37.140 --> 15:38.140
把员工的姓名

15:38.140 --> 15:40.140
和员工的

15:41.140 --> 15:42.140
薪水

15:42.140 --> 15:44.140
一查到一列里边去

15:44.140 --> 15:45.140
我们就可以这样子写

15:45.140 --> 15:47.140
坑开着

15:47.140 --> 15:48.140
拼接

15:48.140 --> 15:50.140
员工的姓名

15:52.140 --> 15:53.140
这一列

15:53.140 --> 15:55.140
然后员工的薪水

15:55.140 --> 15:57.140
finally

15:57.140 --> 15:59.140
那么我们这里

15:59.140 --> 16:00.140
查询

16:00.140 --> 16:01.140
查询哪个表呢

16:01.140 --> 16:02.140
Improved表

16:02.140 --> 16:03.140
运行

16:03.140 --> 16:04.140
那里看

16:04.140 --> 16:05.140
所以把它拼成一列

16:05.140 --> 16:07.140
当然你可以给它指定别名

16:07.140 --> 16:08.140
只坑开着

16:08.140 --> 16:09.140
那如果说你只用

16:09.140 --> 16:10.140
坑开着

16:10.140 --> 16:11.140
这个

16:11.140 --> 16:12.140
那么第一个参数

16:12.140 --> 16:13.140
你可以写分割服务

16:13.140 --> 16:14.140
比方说

16:14.140 --> 16:16.140
我们用一个A塔分割

16:16.140 --> 16:17.140
咱们来查一下

16:17.140 --> 16:18.140
是不是

16:18.140 --> 16:19.140
名字和性别之间

16:19.140 --> 16:21.140
就用一个A塔来分割

16:21.140 --> 16:22.140
对不对

16:22.140 --> 16:23.140
就这么简单

16:23.140 --> 16:24.140
这是这个

16:24.140 --> 16:25.140
tune

16:25.140 --> 16:26.140
自己去是

16:26.140 --> 16:27.140
去掉似乎说

16:27.140 --> 16:28.140
手部和尾部的所有空格

16:28.140 --> 16:29.140
l-tune

16:29.140 --> 16:30.140
去掉开头的空格

16:30.140 --> 16:31.140
right-tune

16:31.140 --> 16:32.140
去掉这个

16:32.140 --> 16:33.140
结尾的空格

16:33.140 --> 16:34.140
这制服

16:34.140 --> 16:36.140
接下来日期

16:36.140 --> 16:37.140
日期这里

16:37.140 --> 16:38.140
有的时候

16:38.140 --> 16:39.140
可能会用到一点点

16:39.140 --> 16:40.140
这curred date

16:40.140 --> 16:42.140
或者是current date

16:42.140 --> 16:44.140
反过来是当前日期

16:44.140 --> 16:45.140
两个函数是完全一样的

16:45.140 --> 16:47.140
咱们来看一下

16:47.140 --> 16:48.140
snext

16:48.140 --> 16:50.140
curred date

16:50.140 --> 16:52.140
这个函数

16:52.140 --> 16:53.140
运行

16:53.140 --> 16:54.140
你看

16:54.140 --> 16:55.140
到当前

16:55.140 --> 16:56.140
是这个日期

16:56.140 --> 16:57.140
对不对

16:57.140 --> 16:58.140
如果是curred date

16:58.140 --> 16:59.140
是一样的

16:59.140 --> 17:00.140
另外两个函数

17:00.140 --> 17:01.140
就是一个别名

17:01.140 --> 17:02.140
curred date

17:02.140 --> 17:05.090
是一样的

17:05.090 --> 17:06.090
这里

17:06.090 --> 17:07.090
咱们运行

17:07.090 --> 17:08.090
你看

17:08.090 --> 17:09.090
是不是没问题

17:09.090 --> 17:10.090
这个curred time

17:10.090 --> 17:11.090
和current time

17:11.090 --> 17:12.090
得到当前时间

17:12.090 --> 17:14.090
咱们来看一下

17:14.090 --> 17:15.090
特别

17:15.090 --> 17:16.090
我们有个练习

17:16.090 --> 17:17.090
练习

17:17.090 --> 17:20.780
curred time

17:20.780 --> 17:22.780
这里运行

17:22.780 --> 17:23.780
是吧

17:23.780 --> 17:24.780
上午10点

17:24.780 --> 17:25.780
14分

17:25.780 --> 17:26.780
这是curred time

17:26.780 --> 17:28.780
这个是

17:28.780 --> 17:30.780
time stamp

17:30.780 --> 17:31.780
时间戳

17:31.780 --> 17:32.780
def

17:32.780 --> 17:33.780
def什么意思

17:33.780 --> 17:34.780
def表示的是

17:34.780 --> 17:35.780
那个差异

17:35.780 --> 17:37.780
相差的多少

17:37.780 --> 17:38.780
一个

17:38.780 --> 17:39.780
第一个地方是part

17:39.780 --> 17:40.780
就是两个日期之间

17:40.780 --> 17:41.780
相差多少

17:41.780 --> 17:42.780
第一个日期

17:42.780 --> 17:43.780
到第二个日期之间

17:43.780 --> 17:44.780
相差多少

17:44.780 --> 17:46.780
它是间隔的结果

17:46.780 --> 17:47.780
那么这个part

17:47.780 --> 17:48.780
可以写啥呢

17:48.780 --> 17:49.780
可以写这么一些东西

17:49.780 --> 17:50.780
分别表示

17:50.780 --> 17:51.780
毫秒秒

17:51.780 --> 17:52.780
分小时

17:52.780 --> 17:53.780
天 周 月

17:53.780 --> 17:55.780
季度 年

17:55.780 --> 17:56.780
好

17:56.780 --> 17:57.780
咱们来试一下吧

17:57.780 --> 17:58.780
那么这里

17:58.780 --> 17:59.780
比方说

17:59.780 --> 18:01.780
我们写一个time

18:01.780 --> 18:02.780
是那个

18:02.780 --> 18:03.780
time

18:03.780 --> 18:04.780
是那个主要是把它打印出来

18:04.780 --> 18:06.780
time stamp

18:06.780 --> 18:08.780
def

18:08.780 --> 18:09.780
好

18:09.780 --> 18:10.780
第一个

18:10.780 --> 18:11.780
单位

18:11.780 --> 18:12.780
单位的话比方说

18:12.780 --> 18:13.780
我们写一个

18:13.780 --> 18:15.780
相差的小时

18:15.780 --> 18:17.780
hour

18:17.780 --> 18:18.780
好

18:18.780 --> 18:19.780
这个地方

18:19.780 --> 18:20.780
我们写上一个

18:20.780 --> 18:21.780
一个日期

18:21.780 --> 18:22.780
第一个日期

18:22.780 --> 18:24.780
是2010年

18:24.780 --> 18:25.780
1月1号

18:25.780 --> 18:27.780
11点

18:27.780 --> 18:28.780
11分

18:28.780 --> 18:29.780
11秒

18:29.780 --> 18:30.780
比方说吧

18:31.780 --> 18:32.780
那么这个地方

18:32.780 --> 18:33.780
我们写上

18:33.780 --> 18:36.780
2010年

18:36.780 --> 18:38.780
或者2010年

18:38.780 --> 18:40.780
1月2号

18:40.780 --> 18:41.780
11点

18:41.780 --> 18:42.780
11分

18:42.780 --> 18:43.780
11秒

18:43.780 --> 18:44.780
来看一下这个相差多少

18:44.780 --> 18:45.780
所以相差一天

18:45.780 --> 18:46.780
一天是不是24个小时

18:46.780 --> 18:47.780
对不对

18:47.780 --> 18:48.780
得到9是不是

18:48.780 --> 18:49.780
24

18:49.780 --> 18:50.780
相差24个小时

18:50.780 --> 18:51.780
好

18:51.780 --> 18:52.780
那如果说这里

18:52.780 --> 18:54.780
我写上一个10呢

18:54.780 --> 18:55.780
还没有到两时

18:55.780 --> 18:56.780
24个小时

18:56.780 --> 18:57.780
那它怎么办

18:57.780 --> 18:58.780
变成23个小时了

18:58.780 --> 18:59.780
还没到

19:00.780 --> 19:01.780
这是这个部分

19:01.780 --> 19:02.780
对吧

19:02.780 --> 19:04.780
那么如果说我们这里写的是

19:04.780 --> 19:06.780
比方写的12

19:06.780 --> 19:07.780
24个小时

19:07.780 --> 19:08.780
那么这里比方说

19:08.780 --> 19:10.780
我们写的是day

19:10.780 --> 19:11.780
所以查询的是天

19:11.780 --> 19:12.780
对不对

19:12.780 --> 19:13.780
相差多少天

19:13.780 --> 19:14.780
所以相差一天

19:14.780 --> 19:15.780
对不对

19:15.780 --> 19:16.780
特别简单

19:16.780 --> 19:17.780
好那么这个地方

19:17.780 --> 19:18.780
我们可以用它来干嘛呢

19:18.780 --> 19:20.780
我们主要是用它来查

19:20.780 --> 19:21.780
一般来说我们查询

19:21.780 --> 19:22.780
用它的时候

19:22.780 --> 19:24.780
一般是来查询它的什么

19:24.780 --> 19:25.780
连领

19:25.780 --> 19:27.780
比方说咱们看一下员工

19:27.780 --> 19:29.780
from employee

19:29.780 --> 19:31.780
它有一个出生日期

19:31.780 --> 19:32.780
看没

19:32.780 --> 19:33.780
说一个birthday

19:33.780 --> 19:34.780
但是没有连领

19:34.780 --> 19:35.780
对吧

19:35.780 --> 19:37.780
那如果说我要显示连领怎么办呢

19:37.780 --> 19:39.780
是不是可以通过出生日期来算

19:39.780 --> 19:40.780
那么这个怎么来算呢

19:40.780 --> 19:41.780
我们就可以这样子

19:41.780 --> 19:43.780
使用一个

19:43.780 --> 19:44.780
temp

19:44.780 --> 19:45.780
temp

19:45.780 --> 19:46.780
然后def

19:46.780 --> 19:48.780
第一个单位填什么呢

19:48.780 --> 19:49.780
是不是填连

19:49.780 --> 19:51.780
相隔多少连

19:51.780 --> 19:52.780
从哪一个地方呢

19:52.780 --> 19:53.780
从哪个开始呢

19:53.780 --> 19:54.780
是不是从那个

19:54.780 --> 19:57.780
从那个birthday

19:57.780 --> 19:58.780
从birthday开始

19:58.780 --> 19:59.780
到哪呢

19:59.780 --> 20:00.780
是不是到当前时间

20:00.780 --> 20:03.780
当前时间是不是curred date

20:03.780 --> 20:04.780
对不对

20:04.780 --> 20:05.780
那么这样子一算出来

20:05.780 --> 20:08.780
是不是就是相差了多少连

20:08.780 --> 20:09.780
连领

20:09.780 --> 20:10.780
我们给它定个别名

20:10.780 --> 20:11.780
mage

20:11.780 --> 20:12.780
运行

20:12.780 --> 20:13.780
你看

20:13.780 --> 20:14.780
什么连领用查出来了

20:14.780 --> 20:15.780
对不对

20:15.780 --> 20:16.780
通过这种简单的方式

20:16.780 --> 20:18.780
就可以把它连领查出来

20:18.780 --> 20:19.780
没问题吧

20:19.780 --> 20:20.780
然后我们后边还可以排序

20:20.780 --> 20:22.780
按照连领来排序

20:22.780 --> 20:23.780
order by

20:23.780 --> 20:24.780
连按照怎么

20:24.780 --> 20:25.780
ag

20:25.780 --> 20:26.780
生序排序

20:26.780 --> 20:28.780
ok 运行

20:28.780 --> 20:29.780
什么连领

20:29.780 --> 20:30.780
生序就出来了

20:30.780 --> 20:31.780
对吧

20:31.780 --> 20:33.780
好 这是这一部分

20:33.780 --> 20:39.210
我把它保存一下

20:39.210 --> 20:41.210
这是

20:41.210 --> 20:42.210
这是什么

20:42.210 --> 20:43.210
什么还说

20:43.210 --> 20:44.210
日期

20:44.210 --> 20:45.210
制服串和日期函数

20:45.210 --> 20:49.210
制服串和日期函数

20:49.210 --> 20:51.210
好 咱们函数这一块就讲完了

20:51.210 --> 20:55.840
函数这一块就讲完了

20:55.840 --> 20:57.840
那么函数学了过后

20:57.840 --> 20:59.840
接下来自你还说我们不讲了

20:59.840 --> 21:01.840
接下来我们讲分组

21:01.840 --> 21:02.840
分组这个东西

21:02.840 --> 21:03.840
你

21:03.840 --> 21:04.840
如果说你不想学

21:04.840 --> 21:05.840
觉得这个

21:05.840 --> 21:06.840
因为我们比绝大部分时候

21:06.840 --> 21:07.840
对于前段来说

21:07.840 --> 21:09.840
像这些查询都已经够用了

21:09.840 --> 21:10.840
如果说你分组不想学的话

21:10.840 --> 21:11.840
你就直接挑过吧

21:11.840 --> 21:12.840
没关系的

21:12.840 --> 21:13.840
没关系的

21:13.840 --> 21:14.840
分组这里

21:14.840 --> 21:16.840
实际上用应对一些

21:16.840 --> 21:18.840
比较复杂的查询

21:18.840 --> 21:20.840
比较复杂的查询

21:21.840 --> 21:23.840
那么分组这里

21:23.840 --> 21:25.840
我给他举例一些例子

21:25.840 --> 21:26.840
我给他直接举例子

21:27.840 --> 21:29.840
比方说我们要查这个东西

21:31.840 --> 21:35.840
查询员工的

21:38.840 --> 21:42.840
员工的员工分布的居住地

21:43.840 --> 21:47.840
以及每个居住地

21:48.840 --> 21:51.840
有多少名员工

21:54.840 --> 21:55.840
有多少名员工

21:55.840 --> 21:56.840
什么意思

21:56.840 --> 21:57.840
我要查出来这么一个东西

21:57.840 --> 22:00.840
比方说我们这里天府山街

22:00.840 --> 22:02.840
这边后面写个山

22:02.840 --> 22:03.840
就表示

22:03.840 --> 22:04.840
第一列天府山街

22:04.840 --> 22:05.840
居住了多少个员工呢

22:05.840 --> 22:06.840
山

22:07.840 --> 22:08.840
指的是这么个意思

22:09.840 --> 22:11.840
也就是说什么呢

22:11.840 --> 22:12.840
有一些列的数据

22:12.840 --> 22:13.840
它有重复

22:13.840 --> 22:15.840
我们要把重复的东西

22:15.840 --> 22:16.840
合并到一起

22:16.840 --> 22:18.840
比方这两个合并成一行

22:18.840 --> 22:19.840
那么后面

22:19.840 --> 22:22.840
我们对这一部分来进行汇总

22:22.840 --> 22:23.840
比方说这一部分有多少个

22:23.840 --> 22:25.840
这一部分的平均值等等

22:27.840 --> 22:29.840
对他来进行汇总

22:29.840 --> 22:30.840
没什么意思吧

22:31.840 --> 22:33.840
那么这个地方怎么来查呢

22:33.840 --> 22:34.840
这个地方

22:34.840 --> 22:35.840
我们可以这样

22:36.840 --> 22:37.840
是那个

22:38.840 --> 22:40.840
然后我们这里的信号

22:43.840 --> 22:44.840
哪个表

22:45.840 --> 22:46.840
然后边

22:46.840 --> 22:47.840
我们可以加上一个东西

22:47.840 --> 22:48.840
叫做

22:50.840 --> 22:51.840
分组

22:51.840 --> 22:52.840
分什么叫分组

22:52.840 --> 22:54.840
就是比方说男同学为一组

22:54.840 --> 22:55.840
女同学为一组

22:55.840 --> 22:57.840
是不是按性别分组

22:57.840 --> 22:58.840
对不对

22:58.840 --> 23:00.840
30岁以上的为一组

23:00.840 --> 23:01.840
30岁以下的为一组

23:01.840 --> 23:02.840
是不是按年龄来分组

23:02.840 --> 23:03.840
那么分组的

23:03.840 --> 23:04.840
过后

23:04.840 --> 23:05.840
每一个组里边

23:05.840 --> 23:06.840
是不是有多条数据

23:06.840 --> 23:07.840
那么我们这里

23:07.840 --> 23:08.840
可以按什么来分组呢

23:08.840 --> 23:09.840
我们这里

23:09.840 --> 23:10.840
是不是可以按这个

23:10.840 --> 23:12.840
location来分组

23:12.840 --> 23:13.840
对不对

23:13.840 --> 23:14.840
我们就写上

23:14.840 --> 23:15.840
我们按什么分组

23:15.840 --> 23:17.840
按location来分组

23:17.840 --> 23:18.840
那么这样子

23:18.840 --> 23:19.840
他就会把location

23:19.840 --> 23:21.840
相同的分成一个组

23:21.840 --> 23:22.840
那么现在呢

23:22.840 --> 23:23.840
我们这里查

23:23.840 --> 23:24.840
能不能查了

23:24.840 --> 23:25.840
查不了了

23:25.840 --> 23:26.840
为什么呢

23:27.840 --> 23:28.840
逻辑出问题了

23:28.840 --> 23:30.840
你叫他怎么显示

23:30.840 --> 23:31.840
请问他

23:31.840 --> 23:32.840
如果说你这样子查的话

23:32.840 --> 23:33.840
你叫他怎么显示

23:34.840 --> 23:35.840
有些

23:35.840 --> 23:37.840
他是两个是相同的

23:37.840 --> 23:38.840
你看这

23:38.840 --> 23:40.840
周长石和那个

23:40.840 --> 23:42.840
柳胡志刚

23:42.840 --> 23:43.840
这名字是随机生成的

23:43.840 --> 23:45.840
很奇特

23:45.840 --> 23:46.840
他们两个分到一组了

23:46.840 --> 23:47.840
过后

23:47.840 --> 23:49.840
那么是变成一行了

23:49.840 --> 23:51.840
你要显示所有的

23:51.840 --> 23:53.840
你要显示所有的

23:53.840 --> 23:55.840
那请问名字怎么显示

23:55.840 --> 23:57.840
名字我到底显示啥

23:57.840 --> 23:59.840
显示周长石还是显示柳胡志刚吗

23:59.840 --> 24:01.840
ID我显示啥

24:01.840 --> 24:02.840
ISMAO显示啥

24:02.840 --> 24:03.840
JONDEX我显示啥

24:03.840 --> 24:04.840
我没法显示了

24:04.840 --> 24:05.840
明白这个意思吗

24:05.840 --> 24:07.840
他分成一个组了

24:07.840 --> 24:09.840
所以说这个逻辑就说不通了

24:09.840 --> 24:10.840
因此你这里分了组过后

24:10.840 --> 24:11.840
你查讯的时候

24:11.840 --> 24:13.840
只能查什么

24:13.840 --> 24:14.840
分组之后

24:14.840 --> 24:16.840
我再挤个笔记吧

24:16.840 --> 24:20.470
分组后

24:20.470 --> 24:22.470
查讯

24:24.470 --> 24:26.470
只能查讯

24:27.470 --> 24:29.470
分组的列

24:29.470 --> 24:30.470
和

24:30.470 --> 24:31.470
什么了

24:31.470 --> 24:32.470
和聚合列

24:33.470 --> 24:34.470
要说这里

24:34.470 --> 24:35.470
我们可以查什么了

24:35.470 --> 24:36.470
按照逻辑来说

24:36.470 --> 24:37.470
可以查都可以显

24:37.470 --> 24:38.470
运动可以显示一组了

24:38.470 --> 24:40.470
不甭外有多少个行

24:40.470 --> 24:41.470
分成一个组

24:41.470 --> 24:42.470
会总统到一行

24:42.470 --> 24:43.470
那可以显示一定一样的

24:43.470 --> 24:44.470
对不对

24:44.470 --> 24:45.470
所以一定是一样的

24:45.470 --> 24:47.470
因此我们这里

24:47.470 --> 24:48.470
这样子

24:48.470 --> 24:49.470
是可以查出来的

24:49.470 --> 24:50.470
你看

24:50.470 --> 24:51.470
是可以查出来的

24:51.470 --> 24:52.470
对吧

24:52.470 --> 24:53.470
包括一个NOW

24:53.470 --> 24:54.470
NOW也是有相同的

24:54.470 --> 24:55.470
相同也会分到一个组

24:55.470 --> 24:56.470
那么还可以查什么了

24:56.470 --> 24:58.470
还可以查聚合列

24:58.470 --> 24:59.470
比方说我们这里

24:59.470 --> 25:00.470
可以查看

25:00.470 --> 25:02.470
每一个分组里边

25:02.470 --> 25:05.470
有多少个ID

25:05.470 --> 25:06.470
每一个分组里边

25:06.470 --> 25:08.470
有多少个员工

25:08.470 --> 25:12.680
员工数量

25:12.680 --> 25:13.680
这个也可以查出来

25:13.680 --> 25:15.680
可以看到天赋山街有

25:15.680 --> 25:16.680
37个员工

25:16.680 --> 25:17.680
人民北路有31个员工

25:17.680 --> 25:19.680
就这么简单

25:19.680 --> 25:20.680
就这么简单

25:20.680 --> 25:22.680
明白我的意思吗

25:22.680 --> 25:23.680
好

25:23.680 --> 25:24.680
那么接下来我们再来看

25:24.680 --> 25:26.680
我们这里换成一个AMP

25:26.680 --> 25:27.680
NUMBER

25:27.680 --> 25:30.990
接下来我们再来看

25:30.990 --> 25:31.990
这就是分组

25:31.990 --> 25:32.990
这特别特别简单

25:32.990 --> 25:33.990
其实分组

25:33.990 --> 25:34.990
我们也可以用

25:34.990 --> 25:35.990
多种方式来分组

25:35.990 --> 25:36.990
多种方式来分组

25:36.990 --> 25:37.990
还可以用什么了

25:37.990 --> 25:38.990
比方说我们豆浩

25:38.990 --> 25:39.990
没有

25:39.990 --> 25:41.990
就是意思没有

25:41.990 --> 25:42.990
所以按照两例来分组

25:42.990 --> 25:44.990
就两例必须要一样

25:44.990 --> 25:45.990
我才能分到一个组

25:45.990 --> 25:46.990
那么我这里查的时候

25:46.990 --> 25:48.990
是不是还可以多查一列出来

25:48.990 --> 25:49.990
意思没有

25:49.990 --> 25:51.990
咱们来看一下

25:51.990 --> 25:53.990
你可以看到天赋山街只有

25:53.990 --> 25:55.990
天赋山街

25:55.990 --> 25:59.990
就是天赋山街的男生是18个

25:59.990 --> 26:00.990
就是南员工是18个

26:00.990 --> 26:03.990
人民北路的女员工是18个

26:03.990 --> 26:05.990
天赋一线的女员工是11个

26:05.990 --> 26:06.990
是吧

26:06.990 --> 26:08.990
可以按照多个条件来分组

26:08.990 --> 26:10.990
我们这里把他去掉

26:10.990 --> 26:12.990
再说一下这个点

26:12.990 --> 26:14.990
好 今天我们再来看

26:14.990 --> 26:17.990
那如果说我在分组的基础上

26:17.990 --> 26:19.990
我还要进行筛选

26:19.990 --> 26:21.990
怎么办呢

26:21.990 --> 26:23.990
那比如说谁写威尔

26:23.990 --> 26:25.990
你威尔是写这儿的

26:25.990 --> 26:26.990
我们是写这儿的

26:26.990 --> 26:28.990
那如果说威尔怎么写呢

26:28.990 --> 26:29.990
比方说我要查去的是

26:29.990 --> 26:33.990
员工数量大于30的居住地

26:33.990 --> 26:37.990
员工数量大于50吗

26:37.990 --> 26:38.990
大于40吗

26:38.990 --> 26:40.990
大于40的居住地

26:40.990 --> 26:41.990
那我怎么查呢

26:41.990 --> 26:42.990
是不是ample number

26:42.990 --> 26:43.990
能这样查吗

26:43.990 --> 26:44.990
好好想一想

26:44.990 --> 26:45.990
大于40

26:45.990 --> 26:47.990
能不能这样查

26:47.990 --> 26:48.990
肯定不行

26:48.990 --> 26:49.990
为什么呢

26:49.990 --> 26:51.990
他说根本就不存在

26:51.990 --> 26:52.990
在运行威尔的时候

26:52.990 --> 26:54.990
这个东西根本就不存在

26:54.990 --> 26:55.990
对吧

26:55.990 --> 26:57.990
是不是不能这样子查

26:57.990 --> 26:59.990
因为我们这个筛选的时候先运行

26:59.990 --> 27:01.990
不 威尔是不是先运行

27:01.990 --> 27:02.990
先运行服务在运行威尔

27:02.990 --> 27:03.990
对吧

27:03.990 --> 27:04.990
威尔先运行

27:04.990 --> 27:05.990
那么这个时候有没有这个ample number

27:05.990 --> 27:06.990
没有

27:06.990 --> 27:07.990
对不对

27:07.990 --> 27:10.990
所以说这个地方是不能这样子查的

27:10.990 --> 27:11.990
好 那么这个时候呢

27:11.990 --> 27:13.990
我们能不能用这种方式来查呢

27:13.990 --> 27:14.990
能不能用聚合的方式来查呢

27:14.990 --> 27:17.990
id

27:17.990 --> 27:18.990
我来看一下

27:18.990 --> 27:19.990
能不能用这方式

27:19.990 --> 27:20.990
是不是还是不行

27:20.990 --> 27:21.990
为什么呢

27:21.990 --> 27:23.990
因为就是运行顺序的问题

27:23.990 --> 27:25.990
运行顺序是不是

27:25.990 --> 27:27.990
服务运行威尔

27:27.990 --> 27:28.990
对不对

27:28.990 --> 27:29.990
运行威尔

27:29.990 --> 27:30.990
威尔运行了过后

27:30.990 --> 27:32.990
那么这个地方

27:32.990 --> 27:34.990
这个地方caught id

27:34.990 --> 27:35.990
那么这个地方

27:35.990 --> 27:36.990
先运行服务

27:36.990 --> 27:37.990
运行威尔

27:37.990 --> 27:38.990
那么这个时候还没有分组

27:38.990 --> 27:39.990
对不对

27:39.990 --> 27:40.990
还没有分组

27:40.990 --> 27:41.990
它肯定是得不到的

27:41.990 --> 27:43.990
这个肯定要出问题的

27:43.990 --> 27:44.990
好 那么这里呢

27:44.990 --> 27:45.990
所以说

27:45.990 --> 27:47.990
这里不能用威尔来进行筛选了

27:47.990 --> 27:50.990
当我们对它进行分组之后

27:50.990 --> 27:51.990
我们要怎么筛选呢

27:51.990 --> 27:53.990
我们要使用Heaven

27:53.990 --> 27:54.990
Heaven

27:54.990 --> 27:56.990
那Heaven能不能这样子写呢

27:56.990 --> 27:58.990
inplumber

27:58.990 --> 27:59.990
我们要看一下

27:59.990 --> 28:01.990
大约等于40

28:01.990 --> 28:04.690
看见不行

28:04.690 --> 28:05.690
运行

28:05.690 --> 28:06.690
是不是可以了

28:06.690 --> 28:07.690
对不对

28:07.690 --> 28:08.690
可以了

28:08.690 --> 28:10.690
那么这就是Heaven职据

28:10.690 --> 28:11.690
Heaven职据

28:11.690 --> 28:12.690
Heaven职据它运行的时间

28:12.690 --> 28:14.690
是在这个时候了

28:14.690 --> 28:15.690
其实这个地方

28:15.690 --> 28:16.690
我说一个点

28:16.690 --> 28:17.690
不同的数据空了

28:17.690 --> 28:18.690
这个Heaven职据

28:18.690 --> 28:19.690
运行的时间点

28:19.690 --> 28:20.690
有些细微的差异

28:20.690 --> 28:21.690
有些是把Heaven运行完了

28:21.690 --> 28:22.690
再运行是那个时候

28:22.690 --> 28:23.690
那么这样子的

28:23.690 --> 28:24.690
有些数据空里面

28:24.690 --> 28:25.690
它就必须要得

28:25.690 --> 28:26.690
得这样子写

28:26.690 --> 28:28.690
得这样子写才行

28:28.690 --> 28:32.690
有些是在那个

28:32.690 --> 28:33.690
那个时候运行完了

28:33.690 --> 28:35.690
才运行Heaven

28:35.690 --> 28:36.690
你就可以直接使用

28:36.690 --> 28:37.690
是那个车里面的东西

28:37.690 --> 28:39.690
当然都看不同的数据空

28:39.690 --> 28:40.690
那么买车后

28:40.690 --> 28:41.690
我们看一下

28:41.690 --> 28:42.690
买车后的运行顺序

28:42.690 --> 28:43.690
买车后的运行顺序

28:43.690 --> 28:44.690
我这里写错了是吧

28:44.690 --> 28:45.690
我这里

28:45.690 --> 28:46.690
换一个

28:46.690 --> 28:48.690
先运行Front

28:48.690 --> 28:49.690
然后来运行交易

28:49.690 --> 28:50.690
就连标查询

28:50.690 --> 28:51.690
Front后面有连标

28:51.690 --> 28:52.690
然后再运行Wear

28:52.690 --> 28:53.690
再运行GroupBuy

28:53.690 --> 28:54.690
先运行Wear

28:54.690 --> 28:55.690
再运行GroupBuy

28:55.690 --> 28:56.690
然后再运行什么

28:56.690 --> 28:57.690
是那个车

28:57.690 --> 28:58.690
再运行Heaven

28:58.690 --> 28:59.690
再运行OrderBuy

28:59.690 --> 29:00.690
它是这样的运行顺序

29:00.690 --> 29:01.690
所以Heaven的准讯

29:01.690 --> 29:02.690
我们通常用来干嘛呢

29:02.690 --> 29:04.690
用来对分组之后的东西

29:04.690 --> 29:05.690
进行筛选

29:05.690 --> 29:07.690
对分组之后的东西进行筛选

29:07.690 --> 29:09.690
这是使用Heaven准讯

29:12.690 --> 29:13.690
其他的没啥了

29:13.690 --> 29:14.690
所以说

29:14.690 --> 29:15.690
有的人说

29:15.690 --> 29:16.690
那Wear在分组里面

29:16.690 --> 29:17.690
是不是没用了

29:18.690 --> 29:19.690
不一样

29:19.690 --> 29:20.690
含义都不一样

29:20.690 --> 29:21.690
比方说

29:21.690 --> 29:23.690
我们又来做这么一个查询

29:28.130 --> 29:29.130
查询

29:29.130 --> 29:31.130
查询什么呢

29:32.130 --> 29:34.130
那么当时

29:34.130 --> 29:35.130
Heaven里面要说一下

29:35.130 --> 29:37.130
Heaven里面这个地方

29:37.130 --> 29:38.130
我们要使用的是

29:38.130 --> 29:39.130
那个车里面的东西

29:40.130 --> 29:41.130
查询是什么呢

29:42.130 --> 29:43.130
查询是

29:43.130 --> 29:45.130
我们要查询一个

29:45.130 --> 29:50.400
所有薪水

29:51.400 --> 29:52.400
在

29:53.400 --> 29:55.400
一万以上的

29:56.400 --> 29:57.400
员工

29:58.400 --> 30:01.400
的分布的居住地

30:01.400 --> 30:02.400
什么意思

30:03.400 --> 30:04.400
什么意思

30:04.400 --> 30:05.400
就是说

30:05.400 --> 30:06.400
实课一下的员工

30:06.400 --> 30:07.400
我先不看

30:08.400 --> 30:09.400
我先统计一下

30:09.400 --> 30:11.400
实课以上的

30:11.400 --> 30:12.400
就是员工

30:12.400 --> 30:14.400
他们居住在哪些地方

30:14.400 --> 30:15.400
这些地方

30:15.400 --> 30:16.400
每个地方有多少人

30:16.400 --> 30:18.400
我们要统计一下这个

30:18.400 --> 30:19.400
那么这个时候

30:19.400 --> 30:20.400
Wear就用了

30:20.400 --> 30:21.400
是那个车

30:21.400 --> 30:22.400
你看着

30:22.400 --> 30:23.400
我们先不着急

30:23.400 --> 30:24.400
写这个什么

30:24.400 --> 30:25.400
好不容易

30:25.400 --> 30:26.400
那么这个时候

30:26.400 --> 30:28.400
如果说你直接进行分组

30:28.400 --> 30:29.400
是不是对所有员工进行分组了

30:29.400 --> 30:30.400
对吧

30:30.400 --> 30:32.400
但是我想把一个员工过滤掉

30:32.400 --> 30:33.400
不要他们进行分组

30:33.400 --> 30:34.400
那么这个时候就要用Wear了

30:34.400 --> 30:36.400
Wear是运行在分组之前

30:36.400 --> 30:38.400
比方说我们在Wear之前

30:38.400 --> 30:39.400
我们就把Sinary

30:40.400 --> 30:41.400
是不是大于等于一万

30:41.400 --> 30:42.400
对吧

30:42.400 --> 30:43.400
把剩下的员工过滤掉

30:43.400 --> 30:44.400
然后再来按照

30:44.400 --> 30:45.400
Location来分组

30:45.400 --> 30:46.400
对不对

30:46.400 --> 30:48.400
然后再用Haven指据

30:48.400 --> 30:49.400
当然这个时候

30:49.400 --> 30:50.400
要Haven就要

30:50.400 --> 30:51.400
不要就打到

30:52.400 --> 30:53.400
比方说

30:53.400 --> 30:54.400
我们要

30:54.400 --> 30:55.400
然后

30:56.400 --> 30:58.400
仅得到

31:00.400 --> 31:02.400
聚集

31:02.400 --> 31:03.400
地

31:04.400 --> 31:05.400
大于

31:05.400 --> 31:06.400
三十的

31:07.400 --> 31:08.400
结果

31:08.400 --> 31:09.400
那么这个时候

31:09.400 --> 31:10.400
我们就用Haven了

31:10.400 --> 31:11.400
Haven

31:12.400 --> 31:13.400
我们这里写了Code

31:13.400 --> 31:14.400
ID

31:15.400 --> 31:17.400
大于等于三十

31:17.400 --> 31:18.400
好那么这里

31:18.400 --> 31:19.400
我们就写个Location

31:19.400 --> 31:20.400
然后Code

31:20.400 --> 31:21.400
然后后面可以写

31:21.400 --> 31:22.400
多个句号还说

31:23.400 --> 31:24.400
Code ID

31:27.400 --> 31:32.120
好这里是

31:33.120 --> 31:34.120
运行

31:34.120 --> 31:35.120
看一下

31:35.120 --> 31:36.120
是不是三远出来了

31:36.120 --> 31:37.120
对不对

31:37.120 --> 31:38.120
就是这样的查询结果

31:39.120 --> 31:41.120
这就是我们的分组之剧

31:41.120 --> 31:43.120
分组以及Haven之剧

31:45.120 --> 31:46.120
分组

31:47.120 --> 31:48.120
好接下来他们说

31:48.120 --> 31:49.120
练习题

31:50.120 --> 31:51.120
我把练习题搞不见了

31:51.120 --> 31:52.120
我把练习题搞不见了

31:52.120 --> 31:53.120
我去把练习题找一找

31:53.120 --> 31:54.120
找回来

31:54.120 --> 31:55.120
咱们来看一下

31:55.120 --> 31:56.120
这几道练习题

31:56.120 --> 31:57.120
我建议

31:57.120 --> 31:58.120
每一道题

31:59.120 --> 32:01.120
我解释了意识之后

32:01.120 --> 32:03.120
你们可以自行去

32:03.120 --> 32:04.120
做一下

32:04.120 --> 32:05.120
尝试一下

32:05.120 --> 32:06.120
不简单的

32:06.120 --> 32:07.120
因为分组的话

32:07.120 --> 32:09.120
这一节课的舍口语句

32:09.120 --> 32:10.120
写出来了

32:10.120 --> 32:11.120
这一题的写出来了

32:11.120 --> 32:12.120
都比较多

32:12.120 --> 32:14.120
而且不是那么容易

32:14.120 --> 32:15.120
练习一下吧

32:15.120 --> 32:16.120
但后段的话

32:16.120 --> 32:17.120
学后段的话是必须

32:17.120 --> 32:18.120
必须要掌握

32:18.120 --> 32:19.120
这是毫无疑问的

32:19.120 --> 32:20.120
前段我们可以

32:20.120 --> 32:22.120
要求的放宽松一点

32:22.120 --> 32:23.120
第一个

32:23.120 --> 32:24.120
查询度一

32:24.120 --> 32:26.120
每一个部门的员工数量

32:27.120 --> 32:28.120
度一不是有很多部门吗

32:28.120 --> 32:29.120
对吧

32:29.120 --> 32:30.120
咱们度一

32:30.120 --> 32:33.120
看一下

32:33.120 --> 32:34.120
度一那边

32:34.120 --> 32:35.120
不是有很多的部门吗

32:35.120 --> 32:36.120
对不对

32:36.120 --> 32:37.120
度一ID为二的

32:37.120 --> 32:38.120
对吧

32:38.120 --> 32:39.120
是不是有这些部门

32:39.120 --> 32:40.120
每一个部门有多少员工

32:40.120 --> 32:41.120
所以查出来

32:41.120 --> 32:42.120
应该有几行

32:42.120 --> 32:43.120
是不是有四行

32:43.120 --> 32:45.120
那怎么怎么查呢

32:45.120 --> 32:46.120
好

32:46.120 --> 32:47.120
你可以自行思考一下

32:47.120 --> 32:48.120
好 看到我怎么查

32:49.120 --> 32:50.120
首先

32:50.120 --> 32:51.120
这里肯定要设计到

32:51.120 --> 32:52.120
连表

32:52.120 --> 32:53.120
这是毫无疑问的

32:53.120 --> 32:54.120
查询什么呢

32:54.120 --> 32:55.120
我们先连表

32:56.120 --> 32:58.120
一个是company表

32:58.120 --> 32:59.120
员工表

32:59.120 --> 33:00.120
员工表

33:00.120 --> 33:01.120
公司表

33:01.120 --> 33:02.120
C

33:02.120 --> 33:03.120
join

33:03.120 --> 33:05.120
inajoin

33:05.120 --> 33:06.120
查了查

33:06.120 --> 33:07.120
连什么呢

33:07.120 --> 33:09.120
连department

33:09.120 --> 33:10.120
连那个部门表

33:10.120 --> 33:11.120
对吧

33:11.120 --> 33:12.120
条件是什么

33:12.120 --> 33:13.120
条件是C的

33:15.120 --> 33:17.120
depart

33:18.120 --> 33:19.120
C的

33:19.120 --> 33:20.120
叫什么

33:20.120 --> 33:21.120
debtID

33:23.120 --> 33:24.120
还是个

33:24.120 --> 33:25.120
显示定别名吧

33:25.120 --> 33:27.120
不然他们没有智能提示

33:27.120 --> 33:28.120
C的什么呢

33:28.120 --> 33:30.120
这个就是

33:30.120 --> 33:32.120
ID等于

33:32.120 --> 33:33.120
D的

33:33.120 --> 33:34.120
什么呢

33:35.120 --> 33:37.120
D的companyID

33:37.120 --> 33:38.120
对吧

33:38.120 --> 33:39.120
把它连起来

33:39.120 --> 33:40.120
然后继续连接

33:40.120 --> 33:41.120
innerjoin

33:41.120 --> 33:42.120
连什么表呢

33:42.120 --> 33:43.120
连员工表

33:43.120 --> 33:44.120
employee

33:44.120 --> 33:45.120
sde

33:45.120 --> 33:46.120
好

33:46.120 --> 33:48.120
然后是部门的ID

33:48.120 --> 33:50.120
等于

33:50.120 --> 33:51.120
员工的

33:51.120 --> 33:52.120
这里是

33:52.120 --> 33:54.120
应该有

33:54.120 --> 33:55.120
部门的ID

33:55.120 --> 33:57.120
等于员工的

33:57.120 --> 33:58.120
什么

33:58.120 --> 33:59.120
departID

33:59.120 --> 34:00.120
是吧

34:00.120 --> 34:01.120
这样子

34:01.120 --> 34:02.120
就把三个表

34:02.120 --> 34:03.120
全部连接起来了

34:03.120 --> 34:04.120
连接起来

34:04.120 --> 34:05.120
就数据有很多了

34:05.120 --> 34:06.120
就在这些数据里面

34:06.120 --> 34:07.120
进行筛选

34:07.120 --> 34:09.120
我们只取哪个数据呢

34:09.120 --> 34:10.120
只需要取到

34:10.120 --> 34:11.120
doe

34:11.120 --> 34:12.120
就行了

34:12.120 --> 34:13.120
所以我们查什么呢

34:13.120 --> 34:14.120
ware公司的名字

34:14.120 --> 34:15.120
name

34:15.120 --> 34:16.120
stdl name

34:16.120 --> 34:17.120
对不对

34:17.120 --> 34:18.120
好等于什么呢

34:18.120 --> 34:19.120
等于

34:19.120 --> 34:20.120
或者用like

34:21.120 --> 34:22.120
模糊查询

34:22.120 --> 34:23.120
查什么

34:23.120 --> 34:24.120
doe

34:24.120 --> 34:25.120
对不对

34:25.120 --> 34:26.120
第一的

34:26.120 --> 34:27.120
所有的员工

34:27.120 --> 34:28.120
所有的部门

34:28.120 --> 34:29.120
全部查出来了

34:29.120 --> 34:30.120
你看

34:30.120 --> 34:31.120
所以查到

34:31.120 --> 34:32.120
doe教育

34:32.120 --> 34:33.120
所有的员工

34:33.120 --> 34:34.120
所有的部门

34:34.120 --> 34:35.120
好

34:35.120 --> 34:36.120
那么在这个基础上

34:36.120 --> 34:37.120
我们要干嘛呢

34:37.120 --> 34:38.120
我们要按照什么来分组

34:38.120 --> 34:40.120
要按照部门来分组

34:40.120 --> 34:41.120
因此

34:41.120 --> 34:42.120
我们用group by

34:42.120 --> 34:43.120
按照什么分组

34:43.120 --> 34:44.120
按照部门

34:44.120 --> 34:45.120
department

34:45.120 --> 34:46.120
就是d

34:46.120 --> 34:47.120
dl

34:47.120 --> 34:48.120
ID

34:48.120 --> 34:49.120
来进行分组

34:49.120 --> 34:51.120
我们最好用ID分组

34:51.120 --> 34:52.120
因为有的部门的名字

34:52.120 --> 34:53.120
是一样的

34:53.120 --> 34:54.120
显示部门的名字

34:54.120 --> 34:55.120
怎么办呢

34:55.120 --> 34:56.120
我们要显示部门的名字的话

34:56.120 --> 34:57.120
我们再来一个

34:57.120 --> 34:58.120
分组的条件

34:58.120 --> 34:59.120
就是d叫name

34:59.120 --> 35:00.120
两个条件

35:00.120 --> 35:01.120
ID和name

35:01.120 --> 35:02.120
都要相同的情况下

35:02.120 --> 35:04.120
我们才分成一个组

35:04.120 --> 35:05.120
那么你看

35:05.120 --> 35:06.120
部门的ID有相同的

35:06.120 --> 35:07.120
对吧

35:07.120 --> 35:08.120
因为万一部门的名字

35:08.120 --> 35:09.120
有相同的

35:09.120 --> 35:10.120
那万一呢

35:10.120 --> 35:11.120
我们有写社会局的

35:11.120 --> 35:12.120
尽量

35:12.120 --> 35:13.120
要考虑更多一点

35:13.120 --> 35:14.120
好

35:14.120 --> 35:15.120
那么这样子

35:15.120 --> 35:16.120
查询出来

35:16.120 --> 35:17.120
是不是按照部门的ID

35:17.120 --> 35:18.120
和部门的名称分组

35:18.120 --> 35:19.120
好

35:19.120 --> 35:20.120
那么这个地方

35:20.120 --> 35:21.120
我们就可以写

35:21.120 --> 35:22.120
我们查的时候

35:22.120 --> 35:23.120
原供的数量

35:23.120 --> 35:24.120
靠

35:24.120 --> 35:25.120
靠是ID

35:25.120 --> 35:26.120
对不对

35:29.120 --> 35:30.120
好

35:30.120 --> 35:31.120
那么这样子

35:31.120 --> 35:33.120
我们查出来过

35:33.120 --> 35:34.120
查什么ID

35:34.120 --> 35:35.120
这个ID啊

35:35.120 --> 35:36.120
注意啊

35:36.120 --> 35:37.120
这个ID有很多的都是ID

35:37.120 --> 35:38.120
对吧

35:38.120 --> 35:39.120
我们要查的是

35:39.120 --> 35:40.120
原供的ID

35:40.120 --> 35:41.120
原供的ID有多少个

35:41.120 --> 35:43.120
原供数量

35:43.120 --> 35:44.120
好

35:44.120 --> 35:46.120
这样我们运行一下

35:46.120 --> 35:47.120
就查出来了

35:47.120 --> 35:48.120
就查出来

35:48.120 --> 35:49.120
所有的

35:51.120 --> 35:52.120
部门

35:52.120 --> 35:53.120
以及每个部门的

35:53.120 --> 35:54.120
原供数量

35:54.120 --> 35:57.430
这是第一个查询一句

35:57.430 --> 35:58.430
好

35:58.430 --> 35:59.430
我们切回去

35:59.430 --> 36:00.430
把它写到这儿

36:00.430 --> 36:03.320
好

36:03.320 --> 36:04.320
第二个

36:04.320 --> 36:05.320
查询每一个公司的

36:05.320 --> 36:06.320
原供数量

36:06.320 --> 36:08.320
现在我们只需要公司的

36:08.320 --> 36:09.320
查询每一个公司的

36:09.320 --> 36:10.320
原供数量

36:10.320 --> 36:11.320
那么我们幽兰

36:11.320 --> 36:12.320
你可以自己去想想

36:12.320 --> 36:13.320
怎么写

36:13.320 --> 36:14.320
有了第1道提的提示过后

36:14.320 --> 36:15.320
第2道提的写下来

36:15.320 --> 36:16.320
就没有那么复杂了

36:16.320 --> 36:17.320
好

36:17.320 --> 36:18.320
我们查询

36:18.320 --> 36:19.320
每一个公司的

36:19.320 --> 36:20.320
原供数量

36:20.320 --> 36:21.320
要加个部门

36:21.320 --> 36:22.320
要连接

36:22.320 --> 36:23.320
三表连接

36:23.320 --> 36:24.320
连接过后

36:24.320 --> 36:25.320
没有Ware条件

36:25.320 --> 36:26.320
然后group by的时候

36:26.320 --> 36:27.320
我们按照什么来分组

36:27.320 --> 36:28.320
是吧

36:28.320 --> 36:29.320
按照公司的ID

36:29.320 --> 36:31.320
和公司的名字

36:31.320 --> 36:32.320
按照它来分组

36:32.320 --> 36:33.320
然后我们查的时候

36:33.320 --> 36:34.320
是不是查公司的名字

36:34.320 --> 36:35.320
以及

36:35.320 --> 36:36.320
每个公司的

36:36.320 --> 36:37.320
原供数量

36:37.320 --> 36:38.320
对不对

36:38.320 --> 36:39.320
看一下

36:39.320 --> 36:40.320
是吧

36:40.320 --> 36:41.320
这样子查出来了

36:41.320 --> 36:42.320
每个公司

36:42.320 --> 36:44.320
以及它的原供数量

36:44.320 --> 36:45.320
复制一下

36:46.320 --> 36:47.320
第二道提

36:47.320 --> 36:48.320
好

36:48.320 --> 36:49.320
第三道提

36:49.320 --> 36:51.320
选所有公司

36:51.320 --> 36:54.320
5年内入职的

36:54.320 --> 36:56.320
居住在万家湾的

36:56.320 --> 36:57.320
女员工数量

37:00.890 --> 37:01.890
是不是还是要查

37:01.890 --> 37:02.890
每个公司的

37:02.890 --> 37:03.890
员工数量

37:03.890 --> 37:04.890
对吧

37:04.890 --> 37:05.890
查到还是

37:05.890 --> 37:06.890
每个公司的

37:06.890 --> 37:07.890
员工数量

37:07.890 --> 37:08.890
但是有个条件

37:08.890 --> 37:09.890
什么条件呢

37:09.890 --> 37:11.890
就在分组之前的条件

37:11.890 --> 37:12.890
有些员工

37:12.890 --> 37:13.890
我要去掉

37:13.890 --> 37:14.890
我不要

37:14.890 --> 37:15.890
我只要哪些员工

37:15.890 --> 37:16.890
只要5年内入职

37:16.890 --> 37:18.890
怎么来查5年内入职

37:19.890 --> 37:21.890
怎么来查5年内入职

37:21.890 --> 37:22.890
是不是要用时间函数

37:22.890 --> 37:23.890
对不对

37:23.890 --> 37:24.890
temp

37:24.890 --> 37:25.890
stamp

37:25.890 --> 37:26.890
diff

37:26.890 --> 37:27.890
查什么呢

37:27.890 --> 37:28.890
连

37:29.890 --> 37:30.890
从哪个日期开始

37:30.890 --> 37:31.890
从入职时间

37:31.890 --> 37:32.890
对吧

37:32.890 --> 37:33.890
一点什么

37:34.890 --> 37:35.890
加入公司的时间

37:35.890 --> 37:36.890
到什么

37:36.890 --> 37:37.890
到当前时间

37:39.890 --> 37:40.890
这个时间

37:40.890 --> 37:41.890
到这个时间之间的连份

37:41.890 --> 37:42.890
然后这个连份

37:42.890 --> 37:44.890
要小于等于5

37:45.890 --> 37:46.890
是5年内入职

37:46.890 --> 37:47.890
并且

37:47.890 --> 37:48.890
还有个条件

37:48.890 --> 37:49.890
and

37:49.890 --> 37:50.890
还有什么条件呢

37:50.890 --> 37:51.890
还有就是那个

37:51.890 --> 37:52.890
居住地

37:52.890 --> 37:54.890
就是location

37:54.890 --> 37:55.890
leg

37:56.890 --> 37:57.890
万加万

38:02.950 --> 38:03.950
好

38:03.950 --> 38:04.950
那么现在运销

38:06.950 --> 38:07.950
爆错了是吧

38:07.950 --> 38:08.950
我看哪里出问题

38:08.950 --> 38:09.950
clown

38:09.950 --> 38:10.950
location

38:10.950 --> 38:12.950
is

38:12.950 --> 38:13.950
这里

38:13.950 --> 38:14.950
location

38:14.950 --> 38:15.950
我们用一点

38:19.950 --> 38:20.950
运销

38:21.950 --> 38:22.950
你看

38:22.950 --> 38:23.950
现在

38:23.950 --> 38:24.950
只有一个公司

38:24.950 --> 38:25.950
对不对

38:25.950 --> 38:27.950
因为为什么只有一个公司呢

38:27.950 --> 38:28.950
是因为其他公司

38:28.950 --> 38:30.950
没有居住在万加万的

38:30.950 --> 38:31.950
那如果说

38:31.950 --> 38:32.950
比方说我们

38:32.950 --> 38:33.950
我们来测试一下吧

38:33.950 --> 38:34.950
我们来看一下

38:34.950 --> 38:35.950
from

38:35.950 --> 38:36.950
那个employee

38:36.950 --> 38:37.950
where

38:37.950 --> 38:38.950
什么

38:38.950 --> 38:39.950
location

38:40.950 --> 38:41.950
然后

38:41.950 --> 38:46.250
leg

38:46.250 --> 38:47.250
万加万

38:47.250 --> 38:50.520
好

38:50.520 --> 38:51.520
我们运销一下这个

38:51.520 --> 38:52.520
看一下有多少个员工

38:54.520 --> 38:55.520
这些万加万

38:55.520 --> 38:56.520
倒是有员工比较多

38:56.520 --> 38:57.520
但是在五连内入职

38:57.520 --> 38:58.520
那就没有那么多了

38:58.520 --> 38:59.520
在五连内入职

38:59.520 --> 39:00.520
那就没有那么多了

39:00.520 --> 39:01.520
我们加上这个条件

39:01.520 --> 39:02.520
and

39:02.520 --> 39:04.520
五连内入职

39:05.520 --> 39:06.520
看一下

39:06.520 --> 39:07.520
运销

39:07.520 --> 39:08.520
诶

39:08.520 --> 39:09.520
这里又出问题了

39:10.520 --> 39:11.520
看一下

39:11.520 --> 39:13.520
这里没有意了

39:13.520 --> 39:15.830
运销

39:15.830 --> 39:16.830
好

39:16.830 --> 39:17.830
是不是只有三个

39:17.830 --> 39:18.830
其他公司就没了

39:18.830 --> 39:19.830
好那么这个时候

39:19.830 --> 39:20.830
又出一个问题

39:20.830 --> 39:21.830
如果说

39:21.830 --> 39:22.830
我希望其他公司

39:22.830 --> 39:23.830
还是要给我显示出来

39:23.830 --> 39:24.830
哪怕显示个number 0

39:24.830 --> 39:25.830
一套给我显示出来

39:25.830 --> 39:26.830
那又怎么办呢

39:27.830 --> 39:29.830
那这个地方就不能用什么了

39:29.830 --> 39:31.830
不能用inner join

39:31.830 --> 39:33.830
不能用了

39:33.830 --> 39:34.830
你得用什么呢

39:34.830 --> 39:35.830
你得用neft join

39:35.830 --> 39:36.830
保证什么呢

39:36.830 --> 39:38.830
保证每一个公司

39:38.830 --> 39:40.830
保证每一个公司

39:40.830 --> 39:42.830
它都要显示出来

39:42.830 --> 39:43.830
没二点是吧

39:43.830 --> 39:44.830
你得这样子写了

39:44.830 --> 39:45.830
所以说这个地方

39:45.830 --> 39:46.830
我们写什么

39:46.830 --> 39:47.830
neft join

39:48.830 --> 39:49.830
左连接

39:49.830 --> 39:50.830
左连接是不是保证左表

39:50.830 --> 39:51.830
一定每一个东西都要显示

39:51.830 --> 39:52.830
运行

39:53.830 --> 39:54.830
等一下

39:54.830 --> 39:55.830
公司连接部门表

39:55.830 --> 39:56.830
连接了部门表

39:56.830 --> 39:57.830
连接了部门表

39:57.830 --> 39:58.830
过后了

39:59.830 --> 40:00.830
我这里威尔逸

40:00.830 --> 40:02.830
又把它筛选掉了

40:02.830 --> 40:04.830
又把它威尔逸

40:04.830 --> 40:05.830
把它筛选掉了

40:05.830 --> 40:06.830
我想想

40:06.830 --> 40:08.830
我想想这个怎么连接

40:08.830 --> 40:09.830
我看一下前面的

40:10.830 --> 40:11.830
这个保证了

40:11.830 --> 40:12.830
每一个公司都有

40:12.830 --> 40:13.830
都有值

40:15.830 --> 40:16.830
我想想

40:16.830 --> 40:17.830
保证了

40:17.830 --> 40:18.830
每一个公司都有值

40:18.830 --> 40:19.830
然后了

40:19.830 --> 40:20.830
其实刚才的美国公司

40:20.830 --> 40:21.830
也有值的对吧

40:21.830 --> 40:22.830
刚才因为美国

40:22.830 --> 40:23.830
所有公司都有

40:23.830 --> 40:24.830
都有这个员工

40:24.830 --> 40:25.830
neft join

40:25.830 --> 40:26.830
肯定是neft join

40:26.830 --> 40:27.830
还是要要的

40:27.830 --> 40:28.830
因为万一

40:28.830 --> 40:29.830
一个公司没有部门了

40:29.830 --> 40:30.830
对不对

40:31.830 --> 40:32.830
保证每个东西都有值

40:32.830 --> 40:35.830
然后我在这个地方的时候

40:35.830 --> 40:36.830
把它筛选掉了

40:36.830 --> 40:37.830
对吧

40:37.830 --> 40:38.830
在这个地方的时候

40:38.830 --> 40:39.830
把它筛选掉了

40:41.830 --> 40:43.830
这个地方要用止查群

40:43.830 --> 40:44.830
要用止查群

40:44.830 --> 40:46.830
止查群那个就复杂了

40:47.830 --> 40:48.830
知道吧

40:48.830 --> 40:49.830
止查群就复杂了

40:50.830 --> 40:51.830
止查群的话

40:51.830 --> 40:52.830
我给他说一下

40:52.830 --> 40:53.830
说一下

40:53.830 --> 40:54.830
什么叫止查群

40:54.830 --> 40:55.830
因为以后有一些题

40:55.830 --> 40:57.830
他也会用到止查群

40:57.830 --> 40:58.830
止查群是这样子

40:58.830 --> 41:00.830
我们这里换成一个交易

41:00.830 --> 41:02.830
就是我们把一个查群结果

41:02.830 --> 41:03.830
当成一张表

41:03.830 --> 41:06.830
然后对这张表进一步进行查群

41:06.830 --> 41:07.830
就是止查群

41:07.830 --> 41:08.830
你看

41:08.830 --> 41:10.830
这个东西我们把id也查出来

41:11.830 --> 41:12.830
说一下吧

41:12.830 --> 41:13.830
那么这样子

41:13.830 --> 41:14.830
就是查询了

41:14.830 --> 41:15.830
所有每一个公司

41:15.830 --> 41:16.830
只要有一个

41:16.830 --> 41:18.830
就是在这个条件下

41:18.830 --> 41:20.830
他的就是员工数量

41:20.830 --> 41:22.830
在这个条件下的员工数量

41:22.830 --> 41:23.830
是不是查出来一张表格

41:23.830 --> 41:25.830
那么对于这张表格的话

41:25.830 --> 41:27.830
对于这张表格的话

41:27.830 --> 41:28.830
我们这里怎么样了

41:28.830 --> 41:29.830
我们这里这样子

41:32.830 --> 41:33.830
我们把这张表格

41:33.830 --> 41:34.830
就是这个查群的结果

41:34.830 --> 41:36.830
当成一张表格

41:36.830 --> 41:37.830
然后呢

41:37.830 --> 41:39.830
我们用这种方式来查

41:40.830 --> 41:41.830
这有点复杂了

41:42.830 --> 41:43.830
查群什么呢

41:44.830 --> 41:45.830
我们查什么

41:45.830 --> 41:47.830
用扩好扩起来

41:47.830 --> 41:48.830
查这个东西

41:48.830 --> 41:49.830
这是一张表

41:49.830 --> 41:50.830
这就要止查群

41:50.830 --> 41:52.830
把它作为一张表

41:52.830 --> 41:53.830
把整个东西作为一张表

41:53.830 --> 41:54.830
当成一个查群

41:54.830 --> 41:56.830
那么这个是

41:56.830 --> 41:57.830
result

41:57.830 --> 41:59.830
这个是定个别名

41:59.830 --> 42:01.830
把这张表定成一个别名

42:01.830 --> 42:02.830
就是我们这里查

42:02.830 --> 42:03.830
所有的列

42:03.830 --> 42:04.830
从哪张表查呢

42:04.830 --> 42:05.830
从这张表里边查

42:05.830 --> 42:06.830
那么这个是不是又是个查群

42:06.830 --> 42:08.830
那么这个东西叫做止查群

42:08.830 --> 42:10.830
止查群可以放到位置很多了

42:10.830 --> 42:11.830
它用起来非常灵活

42:11.830 --> 42:12.830
那么这样子我们来看一下

42:12.830 --> 42:13.830
是不是一样的效果

42:13.830 --> 42:14.830
对不对

42:14.830 --> 42:16.830
那么形成这样子的过后

42:16.830 --> 42:17.830
我们又怎么来玩呢

42:17.830 --> 42:18.830
你看

42:18.830 --> 42:19.830
这是一张表

42:19.830 --> 42:21.830
我们又可以用公司表去联系它

42:21.830 --> 42:22.830
你看

42:22.830 --> 42:23.830
我们用company

42:23.830 --> 42:24.830
c

42:24.830 --> 42:25.830
用一个c

42:25.830 --> 42:27.830
就外面的查群用个c

42:27.830 --> 42:28.830
然后呢

42:28.830 --> 42:30.830
in a left join

42:30.830 --> 42:33.830
left join

42:33.830 --> 42:36.830
是不是用这张表去联接这张表

42:36.830 --> 42:37.830
这张表的名字叫什么

42:37.830 --> 42:38.830
叫result

42:38.830 --> 42:39.830
对吧

42:39.830 --> 42:40.830
我们就给R

42:40.830 --> 42:42.830
联接的条件是什么呢

42:42.830 --> 42:45.830
c.id等于R的id

42:45.830 --> 42:47.830
两个公司id是一样的

42:47.830 --> 42:48.830
对不对

42:48.830 --> 42:49.830
那么这样子呢

42:49.830 --> 42:50.830
是不是就左连接出来了

42:50.830 --> 42:51.830
对吧

42:51.830 --> 42:52.830
每个公司

42:52.830 --> 42:54.830
以及这一张表

42:54.830 --> 42:56.830
跟这一张表来进行联接

42:56.830 --> 42:58.830
左连接的话必须保证左表有值

42:58.830 --> 42:59.830
对不对

42:59.830 --> 43:01.830
那么查出来过后呢

43:01.830 --> 43:02.830
有些列是now

43:02.830 --> 43:03.830
对不对

43:03.830 --> 43:04.830
有些列是now

43:04.830 --> 43:05.830
那么我们只需要取

43:05.830 --> 43:06.830
部分列就行了

43:06.830 --> 43:08.830
比方说公司的名字

43:08.830 --> 43:09.830
c.n

43:09.830 --> 43:11.830
以及公司的number

43:11.830 --> 43:15.140
以及R.number

43:15.140 --> 43:16.140
运行

43:16.140 --> 43:18.140
你看是不是查出来这个东西了

43:18.140 --> 43:19.140
对不对

43:19.140 --> 43:20.140
那么我们现在无非就是

43:20.140 --> 43:22.140
把now这一列

43:22.140 --> 43:23.140
变成什么呢

43:23.140 --> 43:24.140
变成0对吧

43:24.140 --> 43:25.140
如果说你是now

43:25.140 --> 43:26.140
把它变成0

43:26.140 --> 43:27.140
那么这里怎么办

43:27.140 --> 43:29.140
我们是不是可以用case

43:29.140 --> 43:30.140
case

43:30.140 --> 43:32.140
case

43:32.140 --> 43:34.140
当这个number

43:34.140 --> 43:35.140
win

43:35.140 --> 43:38.520
这样子

43:38.520 --> 43:39.520
当什么呢

43:39.520 --> 43:41.520
当这个R.number

43:41.520 --> 43:42.520
意思

43:42.520 --> 43:43.520
now的时候

43:43.520 --> 43:44.520
当它是now的时候

43:44.520 --> 43:45.520
怎么样呢

43:45.520 --> 43:47.520
我就取什么呢

43:47.520 --> 43:48.520
取0

43:48.520 --> 43:49.520
else我就取什么

43:49.520 --> 43:50.520
R.number

43:51.520 --> 43:52.520
对吧

43:52.520 --> 43:54.520
然后给这一列

43:54.520 --> 43:55.520
订个别名

43:55.520 --> 43:56.520
还是number

43:57.520 --> 43:58.520
运行

43:58.520 --> 44:00.520
是不是就查出来了

44:00.520 --> 44:02.520
你要排序就自己排

44:02.520 --> 44:04.520
这个要复杂一点

44:04.520 --> 44:06.520
当然你能理解就理解

44:06.520 --> 44:08.520
因为我们毕竟是学前端的

44:08.520 --> 44:09.520
如果说

44:09.520 --> 44:10.520
你实在理解不了的话

44:10.520 --> 44:11.520
就把这个东西看一下

44:11.520 --> 44:13.520
这个东西实在理解不了的话就算了

44:13.520 --> 44:14.520
咱们平时也用不到

44:14.520 --> 44:16.520
这么复杂的查询必须

44:16.520 --> 44:18.520
这是这一部分

44:19.520 --> 44:21.520
好 下面

44:21.520 --> 44:23.520
查询杜一的所有员工

44:23.520 --> 44:25.520
分布在哪些居住地

44:25.520 --> 44:28.520
每个居住地的数量

44:28.520 --> 44:30.520
杜一的所有员工分布

44:30.520 --> 44:31.520
哪些居住地

44:31.520 --> 44:32.520
每个居住地的数量

44:32.520 --> 44:33.520
那么这个东西

44:33.520 --> 44:35.520
跟我们之前的那个聚合

44:35.520 --> 44:37.520
还说差不多的

44:37.520 --> 44:39.520
我看一下

44:39.520 --> 44:40.520
分组

44:41.520 --> 44:43.520
是不是差不多的

44:43.520 --> 44:45.520
我们来看一下吧

44:45.520 --> 44:48.600
查询什么

44:48.600 --> 44:49.600
查询居住地

44:49.600 --> 44:52.600
以及居住地的员工数量

44:52.600 --> 44:53.600
是不是差不多的

44:53.600 --> 44:54.600
查询员工表

44:54.600 --> 44:55.600
按照居住地来分组

44:55.600 --> 44:56.600
只是没有这个条件了

44:56.600 --> 44:58.600
但是我们只查杜一的

44:58.600 --> 44:59.600
那怎么办呢

44:59.600 --> 45:00.600
是不是又要连接

45:00.600 --> 45:01.600
对不对 又要连接

45:01.600 --> 45:02.600
所以说我们这里

45:02.600 --> 45:06.600
把之前的连接这里

45:06.600 --> 45:08.600
拿过来

45:08.600 --> 45:12.640
在这里

45:12.640 --> 45:13.640
好 这里

45:13.640 --> 45:14.640
是不连接

45:14.640 --> 45:15.640
把三个表连接在一起

45:15.640 --> 45:16.640
因为我们要三选杜一

45:16.640 --> 45:17.640
对不对

45:17.640 --> 45:18.640
按照什么来分组

45:18.640 --> 45:19.640
按照那个

45:19.640 --> 45:21.640
1.location来分组

45:21.640 --> 45:22.640
我们查到什么呢

45:22.640 --> 45:23.640
1.location

45:23.640 --> 45:24.640
以及

45:24.640 --> 45:26.640
查到的是1.id

45:26.640 --> 45:27.640
那么这里

45:27.640 --> 45:28.640
我们再加上一个ware

45:28.640 --> 45:29.640
ware条件是什么呢

45:29.640 --> 45:31.640
条件是c.nate

45:31.640 --> 45:32.640
公司的名称

45:32.640 --> 45:33.640
要是什么呢

45:33.640 --> 45:34.640
杜一

45:38.620 --> 45:39.620
运行

45:40.620 --> 45:41.620
是不是查出来了

45:41.620 --> 45:42.620
对不对

45:42.620 --> 45:44.620
没有居住地的有四个

45:44.620 --> 45:45.620
这是这一块

45:46.620 --> 45:47.620
把它复制一下

45:47.620 --> 45:54.540
就这道题

45:54.540 --> 45:55.540
好 下一题

45:57.540 --> 45:59.540
查询员工人数

46:00.540 --> 46:05.540
大于200的公司信息

46:06.540 --> 46:08.540
查询员工人数

46:08.540 --> 46:09.540
大于200的公司信息

46:09.540 --> 46:11.540
这个要用到指查询

46:11.540 --> 46:12.540
刚才我们查询

46:12.540 --> 46:15.540
查询出来的就是一个公司的

46:15.540 --> 46:17.540
就这个东西

46:17.540 --> 46:19.540
员工人数

46:19.540 --> 46:20.540
查询每一个公司的员工数量

46:20.540 --> 46:21.540
对吧

46:21.540 --> 46:23.540
我们刚才有这么一个查询

46:23.540 --> 46:24.540
复制过来

46:24.540 --> 46:25.540
好 这里

46:25.540 --> 46:26.540
我们继续用这个查询

46:26.540 --> 46:27.540
查

46:27.540 --> 46:28.540
那每一个公司的员工数量

46:28.540 --> 46:29.540
是不是查出来了

46:29.540 --> 46:30.540
但是我们只需要得到

46:30.540 --> 46:31.540
什么大于200的

46:31.540 --> 46:33.540
是不是用haven指句

46:33.540 --> 46:34.540
haven

46:34.540 --> 46:35.540
什么呢

46:35.540 --> 46:36.540
number

46:37.540 --> 46:38.540
number

46:38.540 --> 46:39.540
大于叫什么

46:39.540 --> 46:41.540
大于等于200

46:41.540 --> 46:42.540
所以只查出来一个

46:42.540 --> 46:43.540
对不对

46:43.540 --> 46:44.540
一个公司

46:44.540 --> 46:45.540
但是我要得到的是什么

46:45.540 --> 46:46.540
得到了不是这个公司的名字

46:46.540 --> 46:47.540
我要得到公司信息

46:47.540 --> 46:48.540
ID

46:48.540 --> 46:49.540
公司的名字

46:49.540 --> 46:50.540
公司的创建时间

46:50.540 --> 46:51.540
得到的是这些东西

46:51.540 --> 46:52.540
那怎么办

46:52.540 --> 46:54.540
你看我们又可以用指查询

46:54.540 --> 46:55.540
C.ID

46:56.540 --> 46:57.540
你看

46:58.540 --> 46:59.540
我们这个是不是查出来了

46:59.540 --> 47:00.540
把公司的ID

47:00.540 --> 47:01.540
公司的名字

47:01.540 --> 47:02.540
和公司的数量都查出来了

47:02.540 --> 47:03.540
因为我们这里

47:03.540 --> 47:04.540
分组的时候也有ID

47:04.540 --> 47:05.540
所以可以把ID写在这里

47:05.540 --> 47:06.540
对吧

47:06.540 --> 47:08.540
把这些东西都查出来了

47:08.540 --> 47:09.540
当我们这个时候

47:09.540 --> 47:10.540
Name就可以不要了

47:13.620 --> 47:15.620
我们只需要公司信息

47:15.620 --> 47:16.620
对吧

47:16.620 --> 47:17.620
甚至我们这个number都不要了

47:17.620 --> 47:18.620
number都不要了

47:18.620 --> 47:19.620
不要的话

47:19.620 --> 47:20.620
那么这个地方

47:20.620 --> 47:21.620
改成什么呢

47:21.620 --> 47:22.620
改成Cut

47:22.620 --> 47:23.620
Cut

47:23.620 --> 47:25.620
E.ID

47:27.620 --> 47:28.620
行

47:28.620 --> 47:29.620
是不是还是

47:29.620 --> 47:30.620
那么我就把这样子的查询

47:30.620 --> 47:31.620
把所有的

47:31.620 --> 47:32.620
员工数量

47:32.620 --> 47:33.620
大于200的公司ID

47:33.620 --> 47:34.620
就全部查出来了

47:34.620 --> 47:35.620
好

47:35.620 --> 47:36.620
这个查出来过后

47:36.620 --> 47:37.620
把这个ID

47:37.620 --> 47:38.620
我们又干什么了

47:38.620 --> 47:39.620
做一个指查询

47:39.620 --> 47:40.620
做一个指查询

47:40.620 --> 47:42.620
接下来我们去查这个

47:42.620 --> 47:44.620
指查询是非常非常灵活的

47:44.620 --> 47:45.620
查什么表

47:45.620 --> 47:46.620
查imployee

47:46.620 --> 47:47.620
不 查员

47:47.620 --> 47:48.620
查公司表

47:48.620 --> 47:49.620
把公司的所有信息查出来

47:49.620 --> 47:50.620
给个条件

47:50.620 --> 47:51.620
where

47:51.620 --> 47:52.620
什么条件呢

47:52.620 --> 47:55.620
公司表的ID

47:55.620 --> 47:57.620
它必须要在什么之中

47:57.620 --> 47:58.620
在什么之中

47:58.620 --> 48:00.620
在这个查询结果之中

48:00.620 --> 48:01.620
这个查询结果

48:01.620 --> 48:02.620
是不是只有一列

48:02.620 --> 48:03.620
就是全是ID

48:03.620 --> 48:04.620
这个ID必须要在

48:04.620 --> 48:05.620
这个查询结果当中

48:05.620 --> 48:06.620
因为这里有可能

48:06.620 --> 48:08.620
有可能会查询多个出来

48:08.620 --> 48:09.620
你要注意

48:09.620 --> 48:10.620
这个有可能会查询多个

48:10.620 --> 48:11.620
影响

48:11.620 --> 48:13.620
出来指查出一个

48:13.620 --> 48:14.620
那么这就查询的结果就是

48:14.620 --> 48:16.620
员工数量大于

48:16.620 --> 48:19.620
等于200的公司信息

48:19.620 --> 48:21.620
你看指查询是非常灵活的

48:21.620 --> 48:23.620
我们把它复制一下

48:24.620 --> 48:25.620
然后指查询写出来的话

48:25.620 --> 48:27.620
也会把思维局写得很复杂

48:29.620 --> 48:30.620
这一块

48:30.620 --> 48:31.620
接下来再看

48:31.620 --> 48:34.620
查询度一公司里

48:35.620 --> 48:38.620
比它平均工资高的员工

48:38.620 --> 48:39.620
就哪些

48:39.620 --> 48:40.620
我们查的是什么

48:40.620 --> 48:41.620
查的是员工

48:41.620 --> 48:42.620
哪个公司的员工

48:42.620 --> 48:43.620
度一的员工

48:43.620 --> 48:45.620
度一的员工

48:45.620 --> 48:48.620
它的工资要大于等于什么呢

48:48.620 --> 48:53.130
大于度一的平均信息

48:53.130 --> 48:54.130
看上去很合理

48:54.130 --> 48:55.130
逻辑很合理

48:55.130 --> 48:56.130
逻辑很美好

48:56.130 --> 48:57.130
但是写起来不是那么好写

48:57.130 --> 48:58.130
其实

48:58.130 --> 48:59.130
这个东西

48:59.130 --> 49:00.130
对后段开发人来说

49:00.130 --> 49:01.130
这个人写起来

49:01.130 --> 49:02.130
就比较轻松了

49:02.130 --> 49:04.130
对前段开发还不适应

49:04.130 --> 49:05.130
不适应这个社会语句

49:05.130 --> 49:06.130
咱们查的是什么

49:06.130 --> 49:07.130
查的是公司

49:07.130 --> 49:09.130
查的是员工

49:09.130 --> 49:11.130
所以我们把这个东西先写出来

49:11.130 --> 49:12.130
这是我们查询的结果

49:12.130 --> 49:14.130
查询的就是员工

49:14.130 --> 49:16.130
员工还有个条件

49:16.130 --> 49:17.130
什么条件呢

49:17.130 --> 49:19.130
它必须要再度一

49:19.130 --> 49:20.130
对吧

49:20.130 --> 49:21.130
因为我们查的是度一公司里

49:21.130 --> 49:22.130
它必须要再度一

49:22.130 --> 49:24.130
又不是所有公司

49:24.130 --> 49:25.130
那么我们要查度一的话

49:25.130 --> 49:27.130
我们这里是不是又来了

49:27.130 --> 49:29.130
有个联邦要查询的

49:29.130 --> 49:31.130
直接复制

49:31.130 --> 49:32.130
直接复制

49:32.130 --> 49:33.130
这里还可以这样写

49:33.130 --> 49:36.130
我们只查员工信息

49:36.130 --> 49:37.130
只查员工信息

49:37.130 --> 49:38.130
所以说我们这里可以写这样子写

49:38.130 --> 49:39.130
一点信号

49:39.130 --> 49:42.130
是不是查员工的所有信息

49:42.130 --> 49:43.130
运行看一下

49:43.130 --> 49:44.130
这样子是不是查了

49:44.130 --> 49:46.130
度一的所有员工信息

49:46.130 --> 49:48.130
这些都是度一的员工信息

49:48.130 --> 49:50.130
对不对

49:50.130 --> 49:52.130
那么这个还有个条件

49:52.130 --> 49:53.130
and

49:53.130 --> 49:54.130
还有什么条件呢

49:54.130 --> 49:57.130
员工的 salary 薪水

49:57.130 --> 49:58.130
要大于什么呢

49:58.130 --> 50:01.130
大于度一的平均薪资

50:01.130 --> 50:03.130
那我现在是不是要写个指查询

50:03.130 --> 50:05.130
这个指查询干嘛

50:05.130 --> 50:06.130
这个指查询

50:06.130 --> 50:08.130
要查询度一的平均薪资

50:08.130 --> 50:09.130
对吧

50:09.130 --> 50:11.130
查询度一的

50:11.130 --> 50:12.130
度一

50:15.130 --> 50:18.080
有

50:18.080 --> 50:22.290
度一

50:22.290 --> 50:25.290
我的书法呢

50:25.290 --> 50:26.290
这个苹果的书法

50:26.290 --> 50:27.290
不是那么好用

50:27.290 --> 50:33.010
查询度一的平均薪资

50:33.010 --> 50:34.010
平均薪资

50:34.010 --> 50:36.010
我刚才下来换个书法

50:36.010 --> 50:37.010
得了

50:37.010 --> 50:38.010
那么这里怎么查

50:38.010 --> 50:39.010
度一的平均薪资

50:39.010 --> 50:40.010
是很好查的

50:40.010 --> 50:41.010
我们这里呢

50:41.010 --> 50:43.010
又来又是不是又要查度一了

50:43.010 --> 50:44.010
对不对

50:44.010 --> 50:45.010
我们三表连接

50:45.010 --> 50:47.010
因为我们要从员工表去

50:47.010 --> 50:48.010
获得平均薪资

50:48.010 --> 50:49.010
三表连接

50:49.010 --> 50:50.010
而且呢

50:50.010 --> 50:52.010
公司的名字等于度一的

50:52.010 --> 50:53.010
那么查什么呢

50:53.010 --> 50:54.010
查它的平均薪资

50:54.010 --> 50:56.010
查语员工的

50:57.010 --> 50:58.010
查语员工的

50:58.010 --> 50:59.010
1.3

51:00.010 --> 51:01.010
对吧

51:01.010 --> 51:02.010
就是查员工的平均薪资

51:02.010 --> 51:03.010
那么这样子你看

51:03.010 --> 51:05.010
度一的平均薪资是12k

51:05.010 --> 51:06.010
对吧

51:06.010 --> 51:07.010
那么这里呢

51:07.010 --> 51:08.010
我们要查的是

51:08.010 --> 51:09.010
度一的员工里边

51:09.010 --> 51:11.010
它的薪资要大于平均薪资的

51:11.010 --> 51:12.010
运行

51:13.010 --> 51:15.010
这里哪里出了问题

51:15.010 --> 51:16.010
他说

51:16.010 --> 51:17.010
on low-end column

51:17.010 --> 51:20.010
c.3

51:20.010 --> 51:23.380
这个是1.3

51:23.380 --> 51:24.380
对吧

51:24.380 --> 51:25.380
这样子你看

51:25.380 --> 51:26.380
都是度一的

51:26.380 --> 51:27.380
而且呢

51:27.380 --> 51:28.380
它的平均薪资都是比

51:28.380 --> 51:29.380
1.2大的

51:30.380 --> 51:31.380
对不对

51:31.380 --> 51:40.200
这是这一块的好奇

51:41.200 --> 51:42.200
我的那个

51:43.200 --> 51:44.200
其他的那个

51:45.200 --> 51:46.200
还有一点

51:46.200 --> 51:47.200
从温度是刚转过来

51:47.200 --> 51:49.640
还有一点不熟悉

51:49.640 --> 51:51.640
这是这道题

51:51.640 --> 51:52.640
第七题

51:53.640 --> 51:55.640
查询度一所有名字

51:55.640 --> 51:57.640
为两个字

51:57.640 --> 51:59.640
和三个字的员工

51:59.640 --> 52:00.640
对人数

52:00.640 --> 52:02.640
越来越奇葩了

52:02.640 --> 52:03.640
首先查的是谁

52:03.640 --> 52:04.640
查的是度一

52:04.640 --> 52:05.640
所以说我们把这个连表

52:05.640 --> 52:06.640
先拿过来

52:06.640 --> 52:08.640
而现在是跟员工的名字相关的

52:08.640 --> 52:09.640
所以说肯定要连员工表

52:09.640 --> 52:10.640
这是毫无疑问的

52:11.640 --> 52:12.640
来吧

52:14.640 --> 52:15.640
这查的是什么

52:15.640 --> 52:16.640
查的是

52:16.640 --> 52:17.640
三表连接对吧

52:18.640 --> 52:20.640
三表连接的时候

52:20.640 --> 52:21.640
信息很多

52:21.640 --> 52:22.640
每一个公司

52:22.640 --> 52:23.640
每一个部门

52:23.640 --> 52:24.640
以及每一个员工全在这

52:25.640 --> 52:26.640
然后呢

52:26.640 --> 52:27.640
我们现在要查的是什么

52:27.640 --> 52:29.640
查的是两个字和三个字

52:29.640 --> 52:30.640
就名字为两个字

52:30.640 --> 52:31.640
和三个字的员工

52:32.640 --> 52:33.640
对应人数

52:33.640 --> 52:34.640
那么这个时候

52:34.640 --> 52:35.640
我们按照什么分组

52:36.640 --> 52:38.640
按照名字的长度来分组

52:38.640 --> 52:40.640
那么怎么来取名字的长度呢

52:40.640 --> 52:41.640
这里呢

52:41.640 --> 52:42.640
我给大家介绍一个

52:43.640 --> 52:45.640
字不错的长度

52:45.640 --> 52:46.640
字不错的长度

52:46.640 --> 52:47.640
你看

52:47.640 --> 52:48.640
这个长度为

52:48.640 --> 52:49.640
一

52:49.640 --> 52:50.640
比方说一个中文

52:52.640 --> 52:53.640
长度为三

52:54.640 --> 52:55.640
它是中文长度为三

52:55.640 --> 52:56.640
因为它是

52:56.640 --> 52:57.640
得到了的是什么

52:57.640 --> 52:58.640
得到了的是那个

52:58.640 --> 52:59.640
字节的数量

52:59.640 --> 53:00.640
因为我们这里是

53:00.640 --> 53:01.640
UTF8编码

53:01.640 --> 53:03.640
所以得到了的是字节的数量

53:03.640 --> 53:04.640
那我记得

53:04.640 --> 53:05.640
字符的数量是

53:08.640 --> 53:09.640
Charliens

53:11.640 --> 53:12.640
得到字符创

53:12.640 --> 53:14.640
得到字符创的长度

53:16.640 --> 53:17.640
那么这样子呢

53:17.640 --> 53:21.940
一

53:21.940 --> 53:22.940
对吧

53:22.940 --> 53:23.940
A

53:23.940 --> 53:24.940
得到字符创的长度

53:24.940 --> 53:25.940
所以说我们这里按什么分组

53:26.940 --> 53:27.940
按什么分组

53:27.940 --> 53:28.940
按照那个名字的

53:28.940 --> 53:30.940
长度来分组

53:30.940 --> 53:31.940
拿个名字

53:31.940 --> 53:32.940
1.0

53:32.940 --> 53:33.940
员工的名字

53:33.940 --> 53:34.940
长度来分组

53:35.940 --> 53:36.940
那么这样子

53:36.940 --> 53:37.940
按照这样的分组

53:37.940 --> 53:38.940
你这里能查那个吗

53:38.940 --> 53:39.940
不能查了

53:39.940 --> 53:40.940
你只能查什么

53:40.940 --> 53:41.940
Charliens

53:41.940 --> 53:42.940
只能查这个

53:42.940 --> 53:43.940
只能查这个

53:47.310 --> 53:48.310
这里只能查

53:48.310 --> 53:50.310
Charliens

53:50.310 --> 53:51.310
复制一下

53:52.310 --> 53:53.310
只能查这个

53:53.310 --> 53:54.310
给他取个名名

53:54.310 --> 53:56.310
姓名长度

53:56.310 --> 53:57.310
姓名长度

53:59.310 --> 54:00.310
运行

54:00.310 --> 54:01.310
有三个字的

54:01.310 --> 54:02.310
对吧

54:02.310 --> 54:03.310
那么每一个长度

54:03.310 --> 54:04.310
他对你的员工数量呢

54:04.310 --> 54:05.310
是不是用了

54:05.310 --> 54:06.310
用了

54:06.310 --> 54:07.310
又来用靠彻剧和

54:07.310 --> 54:08.310
1.ID

54:13.950 --> 54:14.950
这是

54:14.950 --> 54:15.950
员工数量

54:18.580 --> 54:19.580
运行

54:20.580 --> 54:21.580
这查度一的

54:22.580 --> 54:23.580
姓名长度

54:23.580 --> 54:25.580
不同的员工数量

54:25.580 --> 54:26.580
这这个

54:27.580 --> 54:28.580
两个

54:28.580 --> 54:29.580
那如果说

54:29.580 --> 54:30.580
因为他有名字的话

54:30.580 --> 54:31.580
有可能有四个字

54:31.580 --> 54:32.580
有可能有五个字对吧

54:32.580 --> 54:33.580
然后我只需要两个字

54:33.580 --> 54:34.580
和三个字

54:34.580 --> 54:35.580
是不是有haven纸剧

54:35.580 --> 54:36.580
对不对

54:36.580 --> 54:37.580
haven

54:38.580 --> 54:40.580
因为我们尽量考虑完善一点

54:40.580 --> 54:41.580
复制他大于什么呢

54:41.580 --> 54:42.580
大于等于2

54:42.580 --> 54:43.580
对吧

54:43.580 --> 54:44.580
大于2

54:44.580 --> 54:45.580
或者是

54:45.580 --> 54:46.580
1

54:46.580 --> 54:47.580
2

54:47.580 --> 54:48.580
2和3之间

54:48.580 --> 54:49.580
就是2和3

54:49.580 --> 54:50.580
在2和3的

54:50.580 --> 54:51.580
这个对立里边

54:51.580 --> 54:52.580
要么取一个

54:53.580 --> 54:54.580
运行

54:55.580 --> 54:56.580
写错了

54:56.580 --> 54:59.470
是吧

54:59.470 --> 55:00.470
unlow in

55:00.470 --> 55:01.470
可能

55:02.470 --> 55:03.470
1.0

55:03.470 --> 55:04.470
这里要写这个

55:04.470 --> 55:05.470
姓名长度

55:05.470 --> 55:06.470
要写这个

55:06.470 --> 55:07.470
这个地方

55:07.470 --> 55:08.470
要么写聚合

55:08.470 --> 55:09.470
要么写聚合

55:09.470 --> 55:10.470
你不能再用这个

55:10.470 --> 55:12.470
再取不到1了

55:12.470 --> 55:13.470
取不到1这个东西了

55:15.470 --> 55:16.470
取不到这个

55:16.470 --> 55:17.470
就是1点

55:17.470 --> 55:18.470
1点其他信息了

55:18.470 --> 55:19.470
因为他已经分组完了

55:19.470 --> 55:20.470
你取不到了

55:20.470 --> 55:21.470
那么这里

55:21.470 --> 55:22.470
可以了

55:22.470 --> 55:23.470
这是这个

55:26.040 --> 55:27.040
有点复杂是吧

55:28.040 --> 55:29.040
再来

55:29.040 --> 55:30.040
你可以想想

55:30.040 --> 55:31.040
后段里面

55:31.040 --> 55:32.040
他激励的什么

55:32.040 --> 55:33.040
这还是后段的其中

55:33.040 --> 55:35.040
一小部分而已

55:36.040 --> 55:37.040
查取每一个公司的

55:37.040 --> 55:38.040
每个月的总支出薪水

55:38.040 --> 55:41.040
便按照从低到高的薪水来排序

55:42.040 --> 55:43.040
懂我的意思吧

55:43.040 --> 55:44.040
公司的名字

55:44.040 --> 55:46.040
总支出薪水一共两列

55:46.040 --> 55:47.040
公司的名字

55:47.040 --> 55:49.040
以及每个月的总支出薪水

55:49.040 --> 55:50.040
来吧

55:50.040 --> 55:51.040
查取

55:51.040 --> 55:53.040
是不是又是3秒连接

55:53.040 --> 55:54.040
因为他要查薪水

55:54.040 --> 55:55.040
薪水在哪里

55:55.040 --> 55:56.040
是不是在员工表

55:56.040 --> 55:57.040
这里肯定是3秒连接

55:57.040 --> 55:58.040
我们把连接的

55:58.040 --> 56:00.040
连接的语句写过来

56:00.040 --> 56:01.040
这里我们

56:01.040 --> 56:02.040
for

56:02.040 --> 56:04.040
这3秒连接了

56:04.040 --> 56:06.040
然后我们按照什么分组呢

56:07.040 --> 56:09.040
公司的ID来分组

56:09.040 --> 56:10.040
公司ID

56:10.040 --> 56:12.040
以及公司的名字

56:12.040 --> 56:14.040
因为我们要查公司的名字

56:14.040 --> 56:15.040
所以把名字也加上

56:15.040 --> 56:16.040
我们查的是什么呢

56:16.040 --> 56:17.040
查的是公司名字

56:18.040 --> 56:20.040
然后每个公司的

56:20.040 --> 56:21.040
平均薪资

56:21.040 --> 56:22.040
是什么平均薪资吧

56:22.040 --> 56:23.040
总支出薪资

56:23.040 --> 56:24.040
上

56:24.040 --> 56:25.040
每个公司的

56:25.040 --> 56:27.040
每个月的总支出薪资

56:27.040 --> 56:28.040
那么这里

56:28.040 --> 56:29.040
我们查的是1.3

56:29.040 --> 56:30.040
员工的

56:30.040 --> 56:32.040
把员工的就是薪资来汇总

56:32.040 --> 56:34.040
给他取个别名

56:34.040 --> 56:35.040
总支出

56:36.040 --> 56:38.040
sum of salary吧

56:39.040 --> 56:40.040
咱们来看一下

56:41.040 --> 56:42.040
每个公司的总支出薪资

56:42.040 --> 56:43.040
就查出来了

56:44.040 --> 56:46.040
每个公司的总支出薪资

56:46.040 --> 56:47.040
还是不少的

56:47.040 --> 56:48.040
然后我们接下来

56:48.040 --> 56:49.040
我们还要进行筛选

56:50.040 --> 56:51.040
不是筛选

56:51.040 --> 56:52.040
按照从地道高来排序

56:52.040 --> 56:53.040
是不是用order办

56:54.040 --> 56:55.040
按照从地道高

56:55.040 --> 56:56.040
按照什么

56:56.040 --> 56:57.040
对什么排序

56:57.040 --> 56:58.040
因为我们知道

56:58.040 --> 57:00.040
order办是运行在最后的

57:00.040 --> 57:01.040
所以说我们这里

57:01.040 --> 57:03.040
就可以按照薪资来排序

57:03.040 --> 57:04.040
从地道高

57:04.040 --> 57:05.040
而sum of salary可以不写

57:05.040 --> 57:07.040
它部分就是运行

57:08.040 --> 57:09.040
就出来了

57:09.040 --> 57:10.040
对不对

57:10.040 --> 57:11.040
这是这一部分

57:11.040 --> 57:12.040
负责

57:13.040 --> 57:14.040
再来一块

57:15.040 --> 57:16.040
好

57:16.040 --> 57:17.040
这就是咱们这一块内容

57:17.040 --> 57:18.040
是不是有点复杂

57:18.040 --> 57:19.040
因为这里

57:19.040 --> 57:20.040
我们这里

57:20.040 --> 57:21.040
这一块内容是不复杂

57:21.040 --> 57:22.040
这一题有点复杂

57:22.040 --> 57:24.040
这一题是我以前讲后段的时候

57:24.040 --> 57:27.040
给那些后段开发者准备的

57:27.040 --> 57:28.040
而且

57:28.040 --> 57:29.040
这一题都还是其中一部分

57:29.040 --> 57:30.040
还有更复杂的

57:30.040 --> 57:31.040
还有更复杂的

57:31.040 --> 57:33.040
这是咱们这一块

57:33.040 --> 57:35.040
主要是了解一下分处

57:35.040 --> 57:37.040
最重要的是了解一下聚合函数

57:37.040 --> 57:38.040
好吧

57:38.040 --> 57:39.040
那么至此

57:39.040 --> 57:40.040
我们是个捨口语句

57:40.040 --> 57:41.040
就讲到此结束了

57:41.040 --> 57:43.040
我们下节课

57:43.040 --> 57:44.040
可以再加个扩展课

57:44.040 --> 57:45.040
讲一讲试图

57:45.040 --> 57:46.040
就那个也很简单

57:46.040 --> 57:47.040
虽然是扩展课

57:47.040 --> 57:48.040
你可以看一下

57:48.040 --> 57:50.040
这是咱们买捨口的

57:50.040 --> 57:52.040
最常见的捨口语句

