WEBVTT

00:00.820 --> 00:03.820
上一课我们讲了一个单标查询

00:03.820 --> 00:06.820
然后这一课我们讲一个连标查询

00:06.820 --> 00:09.820
呃 讲连标查询之前呢

00:09.820 --> 00:11.820
我补充一个上一课的知识啊

00:11.820 --> 00:12.820
上一课有个地方呢

00:12.820 --> 00:13.820
有个小的点呢

00:13.820 --> 00:14.820
忘了啊

00:14.820 --> 00:15.820
就是在那个车里边呢

00:15.820 --> 00:16.820
它还有一个啊

00:16.820 --> 00:18.820
还有一个Distinct

00:18.820 --> 00:21.820
Distinct是去重 去掉重复

00:21.820 --> 00:23.820
把这个格式改一下

00:23.820 --> 00:25.820
诶

00:25.820 --> 00:28.820
格式 样式

00:28.820 --> 00:29.820
改一下啊

00:29.820 --> 00:30.820
去重是什么意思呢

00:30.820 --> 00:32.820
我给大家举个例子啊

00:32.820 --> 00:33.820
就是比方说啊

00:33.820 --> 00:35.820
我们查 我们要查什么呢

00:35.820 --> 00:37.820
我们查这个啊

00:37.820 --> 00:38.820
呃

00:38.820 --> 00:42.820
所有员工分布的地址

00:42.820 --> 00:43.820
啊

00:43.820 --> 00:45.820
我们要查一下所有的员工分布的地址

00:45.820 --> 00:46.820
那么这里呢

00:46.820 --> 00:49.820
有些可能员工的地址是重复的

00:49.820 --> 00:50.820
对吧

00:50.820 --> 00:51.820
那么我们是那个社

00:51.820 --> 00:53.820
这里可能不是那么看的

00:53.820 --> 00:54.820
好看的清楚啊

00:54.820 --> 00:55.820
我们查那个地址啊

00:55.820 --> 00:56.820
location

00:56.820 --> 00:58.820
from employee

00:59.820 --> 01:01.820
啊 运行

01:01.820 --> 01:03.820
有些地址肯定是重复的

01:03.820 --> 01:04.820
我们找一找吧

01:04.820 --> 01:05.820
我们order by嘛

01:05.820 --> 01:06.820
order by一下啊

01:06.820 --> 01:07.820
order by

01:07.820 --> 01:09.820
location

01:09.820 --> 01:11.820
运行

01:11.820 --> 01:12.820
有些地址一看

01:12.820 --> 01:13.820
now 是不是重复的

01:13.820 --> 01:14.820
对吧 青阳工是不是重复的

01:14.820 --> 01:15.820
对不对

01:15.820 --> 01:16.820
所以有重复的

01:16.820 --> 01:17.820
好 那么我们主要是看一下

01:17.820 --> 01:18.820
分布的地址是什么

01:18.820 --> 01:19.820
所以说

01:19.820 --> 01:20.820
我不希望重复的出现

01:20.820 --> 01:21.820
那这个时候怎么办呢

01:21.820 --> 01:22.820
其实很简单

01:22.820 --> 01:23.820
我们在前面加这个

01:23.820 --> 01:25.820
加上一个Distinct

01:25.820 --> 01:26.820
就完事了

01:26.820 --> 01:27.820
就完事了

01:27.820 --> 01:29.820
保存 运行

01:29.820 --> 01:30.820
你看

01:30.820 --> 01:31.820
那么显示出来的都是

01:31.820 --> 01:32.820
不重复的地址

01:32.820 --> 01:33.820
对吧 不重复的地址

01:33.820 --> 01:34.820
那注意啊

01:34.820 --> 01:35.820
你用Distinct的时候呢

01:35.820 --> 01:37.820
你一定要注意

01:37.820 --> 01:38.820
Distinct的时候

01:38.820 --> 01:39.820
我们通常呢

01:39.820 --> 01:40.820
只有一列

01:40.820 --> 01:41.820
只查一列

01:41.820 --> 01:42.820
不会查多列的

01:42.820 --> 01:43.820
为什么呢

01:43.820 --> 01:45.820
比方说我给他查一个ID

01:46.820 --> 01:47.820
那么这样子的

01:47.820 --> 01:48.820
查出来ID的话

01:48.820 --> 01:50.820
到底有没有逻辑问题呢

01:50.820 --> 01:52.820
那肯定是有逻辑问题了

01:52.820 --> 01:53.820
因为为什么呢

01:53.820 --> 01:55.820
我们来看一下吧

01:55.820 --> 01:56.820
我们再来order by

01:57.820 --> 01:59.820
order by location

02:00.820 --> 02:01.820
看一下

02:01.820 --> 02:03.820
你看地址是不是又重复了

02:03.820 --> 02:04.820
对吧 为什么

02:04.820 --> 02:05.820
不是去掉重复吗

02:05.820 --> 02:06.820
注意啊

02:06.820 --> 02:07.820
去掉重复是指的是

02:07.820 --> 02:09.820
后边的查询的所有东西

02:09.820 --> 02:10.820
去掉重复

02:10.820 --> 02:11.820
所以Distinct的时候

02:11.820 --> 02:12.820
一定要写最前面

02:12.820 --> 02:13.820
你不能在这里

02:13.820 --> 02:14.820
比方说

02:14.820 --> 02:15.820
比方说你不能这样

02:15.820 --> 02:16.820
这样子写

02:16.820 --> 02:18.820
你不能先查ID

02:18.820 --> 02:19.820
然后呢

02:19.820 --> 02:20.820
我去Distinct的时候

02:20.820 --> 02:21.820
那是不是有问题的

02:21.820 --> 02:22.820
逻辑都不对了

02:22.820 --> 02:23.820
对吧

02:23.820 --> 02:24.820
因为它有可能

02:24.820 --> 02:25.820
同一个地址

02:25.820 --> 02:26.820
那多个ID

02:26.820 --> 02:27.820
它怎么显示呢

02:27.820 --> 02:28.820
没法显示的

02:28.820 --> 02:29.820
逻辑不对了

02:29.820 --> 02:30.820
Distinct一定是写最前面

02:30.820 --> 02:32.820
指的是后边的查询

02:32.820 --> 02:34.820
如果说全部完全相同

02:34.820 --> 02:36.820
那么我就去掉重复

02:36.820 --> 02:37.820
当然了

02:37.820 --> 02:38.820
如果说你加那个ID

02:38.820 --> 02:40.820
是不是就不会完全相同了

02:40.820 --> 02:41.820
这个Distinct没有意义的

02:41.820 --> 02:43.820
所以我们一般来查一列

02:43.820 --> 02:44.820
或者是两列完全相同的

02:44.820 --> 02:46.820
我们把它去掉

02:46.820 --> 02:48.820
或者是我们再这样子写个吧

02:48.820 --> 02:49.820
意思没有

02:49.820 --> 02:50.820
去掉什么呢

02:50.820 --> 02:51.820
去掉就是

02:51.820 --> 02:52.820
所有员工分布的地址

02:52.820 --> 02:53.820
那么同时

02:53.820 --> 02:54.820
如果说

02:54.820 --> 02:55.820
所有的

02:55.820 --> 02:57.820
性别和地址都相同的

02:57.820 --> 02:59.820
我们把重复的去掉

02:59.820 --> 03:01.820
性别和地址都相同的

03:01.820 --> 03:02.820
我们把重复的去掉

03:02.820 --> 03:03.820
变成这么一个逻辑了

03:03.820 --> 03:04.820
这是Distinct

03:04.820 --> 03:06.820
这里说一下

03:06.820 --> 03:07.820
加进来

03:07.820 --> 03:08.820
Distinct

03:08.820 --> 03:12.220
OK

03:12.220 --> 03:14.220
这是这一部分

03:14.220 --> 03:15.220
补充一下

03:15.220 --> 03:17.220
那么这些和我们来学习多表查询

03:17.220 --> 03:19.220
多表查询是不是很复杂呢

03:19.220 --> 03:20.220
一点都不复杂

03:20.220 --> 03:21.220
很简单的

03:21.220 --> 03:23.220
就是写的肯定要多一点

03:23.220 --> 03:25.220
多表查询有好几种

03:25.220 --> 03:26.220
方式

03:26.220 --> 03:27.220
其实我这里只给按键了

03:27.220 --> 03:29.220
我们平时会用到的方式

03:29.220 --> 03:31.220
用到的最多的就是内连接

03:31.220 --> 03:33.220
其他的这几个能用的都还少一点

03:33.220 --> 03:35.220
当然还有一些连接的查询

03:35.220 --> 03:37.220
不过那些我们基本上不用的

03:37.220 --> 03:38.220
所以说不说了

03:38.220 --> 03:40.220
我们毕竟是前端嘛

03:40.220 --> 03:41.220
连票查询里表

03:41.220 --> 03:42.220
我们首先看一下

03:42.220 --> 03:44.220
简单的看一下这三个

03:44.220 --> 03:45.220
这三个用的不常见

03:45.220 --> 03:47.220
没有那么多

03:47.220 --> 03:48.220
有的社会可能会用的

03:48.220 --> 03:50.220
比方说第1个全连接

03:50.220 --> 03:51.220
我们把它叫做

03:51.220 --> 03:53.220
应该不叫全连接

03:53.220 --> 03:54.220
就叫做Dcard集

03:54.220 --> 03:55.220
Dcard集是什么意思呢

03:55.220 --> 03:57.220
我们这里写个例子

03:57.220 --> 03:58.220
它是这样子写的

03:58.220 --> 04:00.220
from 哪个表

04:00.220 --> 04:02.220
比方我们查一个U字表

04:02.220 --> 04:04.220
再查一个dou号

04:04.220 --> 04:05.220
再查一个company表

04:05.220 --> 04:06.220
你看看它怎么

04:06.220 --> 04:09.590
它会查出一个什么玩意

04:09.590 --> 04:10.590
很生气

04:10.590 --> 04:11.590
很生气

04:11.590 --> 04:12.590
那查出来啥玩意啊

04:12.590 --> 04:13.590
这个是

04:13.590 --> 04:14.590
它是这样子的

04:14.590 --> 04:16.590
这就叫做Dcard集

04:16.590 --> 04:17.590
这个Dcard集

04:17.590 --> 04:18.590
它是什么意思呢

04:18.590 --> 04:19.590
它指的是

04:19.590 --> 04:21.590
我们不是有个U字表吗

04:21.590 --> 04:23.590
from 后面写的是数据员

04:23.590 --> 04:24.590
我们的U字表里面

04:24.590 --> 04:25.590
不是有三行数据吗

04:25.590 --> 04:26.590
它这样子

04:26.590 --> 04:28.590
它把第1行数据拿出来

04:28.590 --> 04:30.590
然后对应

04:30.590 --> 04:32.590
company的每一行数据

04:32.590 --> 04:34.590
它就对应company的

04:34.590 --> 04:36.590
每一行数据

04:36.590 --> 04:37.590
懂得意思吗

04:37.590 --> 04:38.590
它对应这里面

04:38.590 --> 04:39.590
每一行数据

04:39.590 --> 04:40.590
也就是说

04:40.590 --> 04:41.590
我们U字表的第1行

04:41.590 --> 04:42.590
是不是对应company的

04:42.590 --> 04:43.590
每一行

04:43.590 --> 04:44.590
对不对

04:44.590 --> 04:46.590
那么是不是第1行

04:46.590 --> 04:47.590
你看我们查出来的

04:47.590 --> 04:48.590
第1行是不是

04:48.590 --> 04:49.590
二的命这个账号

04:49.590 --> 04:50.590
对应三个

04:50.590 --> 04:51.590
对不对

04:51.590 --> 04:52.590
对应三个

04:52.590 --> 04:54.590
我给你讲这个表示

04:54.590 --> 04:56.590
第二行账号是不是对应

04:56.590 --> 04:57.590
又对应三个

04:57.590 --> 04:59.590
第三行账号是不是又对应三个

04:59.590 --> 05:00.590
对不对

05:00.590 --> 05:01.590
它就这样子

05:01.590 --> 05:02.590
所以说Dcard集查出来

05:02.590 --> 05:04.590
就是两张表的数量相乘

05:04.590 --> 05:06.590
查出来就这样的结果

05:06.590 --> 05:07.590
没了意思吧

05:07.590 --> 05:08.590
这是Dcard集

05:08.590 --> 05:09.590
了解一下就行了

05:09.590 --> 05:10.590
那么Dcard集

05:10.590 --> 05:11.590
有的时候可以做什么呢

05:11.590 --> 05:12.590
我想来想去

05:12.590 --> 05:13.590
可能有这么一个例子

05:13.590 --> 05:15.590
这里其实也是一道面试题

05:15.590 --> 05:16.590
这个面试题

05:16.590 --> 05:17.590
它说你们钱都不会考

05:17.590 --> 05:19.590
钱都不会考这些面试题

05:19.590 --> 05:20.590
或者是后端考的

05:20.590 --> 05:22.590
后端对数据库这一块

05:22.590 --> 05:23.590
有详细的考察

05:23.590 --> 05:24.590
那么比方说

05:24.590 --> 05:26.590
我们让你创建一张Tim表

05:26.590 --> 05:27.590
我觉得这道题

05:27.590 --> 05:28.590
也蛮有意思的

05:29.590 --> 05:31.590
我们这里创建一张Tim表吧

05:31.590 --> 05:32.590
这种真正的

05:32.590 --> 05:34.590
然后我们这里写个Name

05:34.590 --> 05:36.590
Tim的名称保存

05:36.590 --> 05:37.590
OK

05:37.590 --> 05:38.590
那么这里创建了Tim表

05:38.590 --> 05:39.590
好来吧

05:39.590 --> 05:40.590
这个Tim表里边记录啥呢

05:40.590 --> 05:41.590
记录我们主持队

05:41.590 --> 05:43.590
比方说我们的曼联

05:45.590 --> 05:46.590
还有什么呢

05:47.590 --> 05:48.590
黄马

05:48.590 --> 05:49.590
我知道的主持队也不多

05:49.590 --> 05:50.590
黄马

05:50.590 --> 05:51.590
什么巴萨

05:52.590 --> 05:53.590
巴萨

05:55.590 --> 05:56.590
然后呢

05:56.590 --> 05:57.590
阿森娜

05:58.590 --> 05:59.590
阿森娜

06:02.030 --> 06:03.030
然后呢

06:03.030 --> 06:04.030
还有一个就是

06:06.030 --> 06:07.030
再来一个

06:07.030 --> 06:08.030
再来一个易甲的

06:08.030 --> 06:09.030
易甲的

06:10.030 --> 06:11.030
游文图事

06:12.030 --> 06:13.030
游文

06:14.030 --> 06:16.030
这是几支足球队

06:17.030 --> 06:18.030
那么比方说吧

06:18.030 --> 06:19.030
咱们这个表里面

06:19.030 --> 06:22.030
就是欧冠的一个联赛的一个分组

06:22.030 --> 06:24.030
这个组里面有五支足球队

06:24.030 --> 06:27.030
那么现在想让你去列出他们的对症表

06:27.030 --> 06:28.030
就是什么意思呢

06:28.030 --> 06:30.030
我们要查询出这样的一个结果

06:30.030 --> 06:31.030
对症表

06:31.030 --> 06:33.030
就是曼联

06:34.030 --> 06:35.030
然后对什么

06:35.030 --> 06:36.030
对黄马

06:36.030 --> 06:37.030
然后呢

06:37.030 --> 06:38.030
曼联

06:38.030 --> 06:39.030
他不能对自己对吧

06:39.030 --> 06:40.030
对巴萨

06:41.030 --> 06:42.030
然后呢

06:42.030 --> 06:43.030
曼联

06:43.030 --> 06:44.030
对那个阿森娜

06:45.030 --> 06:46.030
然后曼联

06:46.030 --> 06:48.030
对那个易文图事

06:49.030 --> 06:50.030
懂我的意思吗

06:50.030 --> 06:51.030
对不对

06:51.030 --> 06:52.030
那么这是足场

06:52.030 --> 06:53.030
这是客场

06:53.030 --> 06:55.030
那么反过来也有黄马

06:55.030 --> 06:56.030
足场

06:56.030 --> 06:57.030
然后呢

06:57.030 --> 06:58.030
对曼联

06:58.030 --> 06:59.030
黄马

06:59.030 --> 07:00.030
又对那个巴萨

07:00.030 --> 07:01.030
对吧

07:01.030 --> 07:03.030
是不是就列出这么一种对症表

07:03.030 --> 07:05.030
一词一词列举

07:05.030 --> 07:06.030
是这么一个意思

07:06.030 --> 07:07.030
那怎么来查呢

07:07.030 --> 07:08.030
这个时候就可以用抵卡耳机了

07:08.030 --> 07:09.030
好

07:09.030 --> 07:10.030
这个时候你们可以自己想一想

07:10.030 --> 07:11.030
自己去建装表

07:11.030 --> 07:12.030
想一想没坏处的

07:12.030 --> 07:13.030
这些都是非常有意思

07:14.030 --> 07:15.030
怎么来查

07:15.030 --> 07:16.030
我们可以这样

07:19.030 --> 07:20.030
看着啊

07:20.030 --> 07:22.030
我们去查哪两张表呢

07:22.030 --> 07:23.030
查这两张表

07:23.030 --> 07:25.030
就是查一张Tim表

07:26.030 --> 07:27.030
再一查一张Tim表

07:28.030 --> 07:29.030
查两个Tim表

07:29.030 --> 07:30.030
一查出来

07:30.030 --> 07:31.030
你看一下

07:31.030 --> 07:32.030
他这里报

07:32.030 --> 07:33.030
报错了

07:33.030 --> 07:34.030
他说两张表不能一样

07:35.030 --> 07:36.030
为什么不能一样

07:36.030 --> 07:37.030
他名字一样了

07:37.030 --> 07:38.030
名字一样很好说

07:38.030 --> 07:39.030
我们给他定一个别名

07:40.030 --> 07:41.030
表也是可以定别名的

07:41.030 --> 07:42.030
不仅是列可以定别名

07:42.030 --> 07:43.030
表也可以定别名

07:43.030 --> 07:44.030
T1

07:45.030 --> 07:46.030
T2

07:47.030 --> 07:48.030
咱们运行

07:48.030 --> 07:49.030
你看

07:49.030 --> 07:51.030
是不是就查出一个抵卡耳机了

07:51.030 --> 07:52.030
慢连是不是

07:53.030 --> 07:54.030
我们看一下

07:54.030 --> 07:55.030
慢连是不是对应所有的

07:55.030 --> 07:56.030
对不对

07:56.030 --> 07:57.030
他包括他对应自己

07:57.030 --> 07:58.030
对吧

07:58.030 --> 07:59.030
但是为了不让他对应自己

08:00.030 --> 08:01.030
我可以加上一个where

08:01.030 --> 08:02.030
where什么呢

08:02.030 --> 08:03.030
T1的

08:03.030 --> 08:04.030
这里显示的时候

08:04.030 --> 08:06.030
这两列实际上名字是一样的

08:06.030 --> 08:07.030
名字是一样的

08:07.030 --> 08:08.030
两列的名字一样的

08:09.030 --> 08:10.030
只不过显示的时候

08:10.030 --> 08:11.030
给你加了个扩号而已

08:11.030 --> 08:12.030
实际上名字是一样的

08:13.030 --> 08:14.030
我们这里呢

08:14.030 --> 08:15.030
要把名字

08:15.030 --> 08:17.030
用这种表明点列名

08:17.030 --> 08:18.030
这样子来区分

08:18.030 --> 08:21.030
我们的T1的ID不能等于

08:22.030 --> 08:24.030
不等于是扩号

08:24.030 --> 08:26.030
T2的ID

08:26.030 --> 08:27.030
加上这么一个条件

08:27.030 --> 08:28.030
那么这样加条件过后

08:28.030 --> 08:30.030
是不是这种数据就去掉了

08:30.030 --> 08:31.030
对吧

08:31.030 --> 08:32.030
我们把这个表

08:32.030 --> 08:33.030
这是我们最终查询的表格

08:33.030 --> 08:34.030
对不对

08:34.030 --> 08:35.030
整个表格是这样子

08:35.030 --> 08:36.030
我们把这个表格里面

08:36.030 --> 08:37.030
进一步来进行筛选

08:37.030 --> 08:38.030
where

08:38.030 --> 08:40.030
T1ID不等于T2的ID

08:40.030 --> 08:41.030
那么这样子一运行出来

08:41.030 --> 08:42.030
你看

08:42.030 --> 08:43.030
慢连是不是不会对自己了

08:43.030 --> 08:44.030
对不对

08:44.030 --> 08:45.030
是不是只对其他的

08:45.030 --> 08:46.030
然后我们查询的结果里面

08:46.030 --> 08:47.030
我们可以这样子

08:47.030 --> 08:49.030
T1.NET

08:49.030 --> 08:50.030
我们把它认为是

08:50.030 --> 08:52.030
T1.NET

08:52.030 --> 08:53.030
我们认为是主场

08:53.030 --> 08:54.030
给它订个别名

08:54.030 --> 08:57.340
主场

08:57.340 --> 09:02.340
然后T2.NET是客厂运行

09:02.340 --> 09:04.340
主客厂关系就出来了

09:04.340 --> 09:05.340
对不对

09:05.340 --> 09:06.340
主客厂关系就出来了

09:07.340 --> 09:09.340
你自己可以看一下

09:09.340 --> 09:10.340
主客厂关系就出来了

09:10.340 --> 09:11.340
好

09:11.340 --> 09:12.340
那么这里就是自动查询

09:12.340 --> 09:13.340
把发到这

09:13.340 --> 09:17.190
好

09:17.190 --> 09:18.190
那么这里呢

09:18.190 --> 09:19.190
我们继续来讲

09:19.190 --> 09:20.190
后边的内容

09:20.190 --> 09:22.190
然后还有左连接和右连接

09:22.190 --> 09:24.190
你只要学一个另一个就知道了

09:24.190 --> 09:25.190
什么意思呢

09:25.190 --> 09:26.190
它是指

09:26.190 --> 09:28.190
以其中一张表为基准

09:28.190 --> 09:30.190
然后去连接另一张表

09:30.190 --> 09:31.190
每次连接的时候

09:31.190 --> 09:32.190
判断条件是否满足

09:32.190 --> 09:33.190
什么意思

09:34.190 --> 09:35.190
信号

09:35.190 --> 09:36.190
for

09:36.190 --> 09:37.190
比方说吧

09:37.190 --> 09:40.190
我们去查询一个部门表

09:42.190 --> 09:43.190
for

09:44.190 --> 09:45.190
查询一个部门表

09:45.190 --> 09:46.190
department

09:48.190 --> 09:49.190
查询部门表

09:49.190 --> 09:51.190
查询部门表的时候

09:51.190 --> 09:52.190
我们给它一个别名

09:52.190 --> 09:53.190
20D

09:53.190 --> 09:54.190
或者是

09:54.190 --> 09:55.190
就一个D

09:56.190 --> 09:57.190
这样子20D也行

09:57.190 --> 09:58.190
好

09:58.190 --> 09:59.190
那么用这张表

09:59.190 --> 10:01.190
然后我们使用

10:01.190 --> 10:02.190
左连接到另一张表

10:02.190 --> 10:03.190
另一张表比方说

10:03.190 --> 10:04.190
连接到什么

10:04.190 --> 10:06.190
连接到员工表

10:06.190 --> 10:07.190
employee

10:09.190 --> 10:10.190
20E

10:10.190 --> 10:11.190
跟另一个别名

10:11.190 --> 10:12.190
一个D

10:12.190 --> 10:14.190
这个表连接到员工表

10:14.190 --> 10:15.190
是一个E

10:15.190 --> 10:16.190
跟它定个别名

10:16.190 --> 10:17.190
好

10:18.190 --> 10:19.190
条件

10:19.190 --> 10:20.190
连接的时候

10:20.190 --> 10:21.190
它怎么连接

10:21.190 --> 10:22.190
它是这样子

10:22.190 --> 10:24.190
把department的表拿出来

10:25.190 --> 10:27.190
把department的表拿出来

10:27.190 --> 10:28.190
这一行

10:28.190 --> 10:29.190
看一下

10:29.190 --> 10:30.190
这一行

10:30.190 --> 10:32.190
是否连接到另一张表的时候

10:32.190 --> 10:33.190
是否能满足条件

10:33.190 --> 10:35.190
能不能连接

10:35.190 --> 10:36.190
能不能连接

10:36.190 --> 10:37.190
这一行能不能连接到

10:37.190 --> 10:39.190
另外一张表的

10:39.190 --> 10:40.190
每一行的

10:40.190 --> 10:42.190
连接到另一张表的哪一行

10:42.190 --> 10:43.190
就这么个意思

10:43.190 --> 10:44.190
我们就写完吧

10:44.190 --> 10:45.190
写完才能解释

10:45.190 --> 10:46.190
我们这样子写

10:46.190 --> 10:47.190
d.id

10:47.190 --> 10:48.190
等于什么呢

10:48.190 --> 10:50.190
e.departmentid

10:52.190 --> 10:53.190
好 咱们先看结果

10:55.190 --> 10:56.190
就连起来了

10:56.190 --> 10:57.190
我们这里有部门

10:57.190 --> 10:58.190
有部门的信息

10:58.190 --> 10:59.190
你看这一部分

10:59.190 --> 11:00.190
是不是部门的信息

11:01.190 --> 11:02.190
你动它干嘛呢

11:02.190 --> 11:03.190
我们这一部分

11:03.190 --> 11:04.190
是不是部门的信息

11:04.190 --> 11:05.190
这一部分

11:05.190 --> 11:06.190
是不是员工的信息

11:06.190 --> 11:07.190
它到底是怎么连接的呢

11:07.190 --> 11:08.190
它是这样子

11:08.190 --> 11:10.190
把部门表拿出来

11:10.190 --> 11:11.190
左连接

11:11.190 --> 11:12.190
把部门表拿出来

11:13.190 --> 11:14.190
然后

11:15.190 --> 11:16.190
我们把部门表的

11:16.190 --> 11:18.190
第一行拿出来

11:18.190 --> 11:19.190
一次去判断

11:19.190 --> 11:20.190
一次去判断

11:20.190 --> 11:22.190
那个就是

11:22.190 --> 11:23.190
employee表

11:23.190 --> 11:24.190
每一行

11:24.190 --> 11:26.190
看哪一行能够

11:26.190 --> 11:28.190
能够就是满足这个条件

11:28.190 --> 11:30.190
看哪一行能满足条件

11:30.190 --> 11:31.190
结果他发现有很多

11:31.190 --> 11:32.190
员工的满足条件

11:32.190 --> 11:34.190
每满足一个条件

11:34.190 --> 11:35.190
生存一行

11:35.190 --> 11:36.190
生存结果表的一行

11:36.190 --> 11:37.190
我们再来运行

11:38.190 --> 11:39.190
要慢慢领会

11:40.190 --> 11:41.190
第一行是不是销售部

11:41.190 --> 11:42.190
我们看一下d.part

11:42.190 --> 11:43.190
是不是销售部

11:43.190 --> 11:45.190
销售部拿出来过后

11:45.190 --> 11:46.190
我们来怎么样

11:46.190 --> 11:47.190
我们去看一下

11:47.190 --> 11:48.190
员工里边

11:48.190 --> 11:50.190
哪一个d.part id

11:50.190 --> 11:52.190
等于销售部的id是什么

11:52.190 --> 11:53.190
销售部id是1

11:53.190 --> 11:54.190
我们去看一下

11:54.190 --> 11:56.190
员工表的哪一个d.part id是1

11:56.190 --> 11:58.190
那么是不是查出来很多员工

11:58.190 --> 11:59.190
那么把这些东西

11:59.190 --> 12:01.190
全部加入到结果里边

12:01.190 --> 12:03.190
全部加入到结果里边

12:03.190 --> 12:04.190
没有意思吧

12:04.190 --> 12:05.190
那么销售部就有很多员工了

12:05.190 --> 12:07.190
开发部也是一样的道理

12:07.190 --> 12:09.190
看一下哪些员工的d.part id

12:09.190 --> 12:10.190
你看一下这个id为2

12:10.190 --> 12:12.190
那么这些员工的d.part id

12:12.190 --> 12:13.190
不都是2

12:13.190 --> 12:14.190
d.part id还是不都是2

12:14.190 --> 12:15.190
对不对

12:15.190 --> 12:16.190
这是左连接

12:16.190 --> 12:17.190
而左连接的时候

12:17.190 --> 12:18.190
它有一个特点就是

12:18.190 --> 12:19.190
如果说找不到怎么办

12:19.190 --> 12:21.190
关键在于它找不到怎么办

12:21.190 --> 12:23.190
找不到的话它是这样子

12:23.190 --> 12:24.190
左连接

12:24.190 --> 12:26.190
它找不到的话

12:26.190 --> 12:28.190
我们比方说加一个部门

12:28.190 --> 12:30.190
加一个部门

12:32.190 --> 12:33.190
测试

12:34.190 --> 12:35.190
component id还是3

12:36.190 --> 12:37.190
这里随便写一个吧

12:39.190 --> 12:40.190
新部门

12:40.190 --> 12:44.100
保存

12:44.100 --> 12:45.100
关键是

12:46.100 --> 12:47.100
它找不到怎么办

12:47.100 --> 12:48.100
找不到的话

12:48.100 --> 12:50.100
左连接它至少得有银行

12:50.100 --> 12:51.100
至少得有银行

12:51.100 --> 12:54.100
哪怕一个条件满足的都没有

12:54.100 --> 12:55.100
它都会至少有银行

12:55.100 --> 12:56.100
那么后面全用

12:56.100 --> 12:57.100
那我来表示

12:57.100 --> 12:58.100
这是左连接的特点

12:58.100 --> 12:59.100
那么同样的道理

12:59.100 --> 13:00.100
右连接呢

13:00.100 --> 13:02.100
右连接就是以右表为基准

13:02.100 --> 13:04.100
如果说这个条件满足不了

13:04.100 --> 13:05.100
满足不了的话

13:05.100 --> 13:06.100
比方说我们反过来写

13:06.100 --> 13:10.060
employee

13:10.060 --> 13:11.060
employee

13:11.060 --> 13:12.060
E

13:12.060 --> 13:14.060
right join

13:15.060 --> 13:16.060
二是什么呢

13:16.060 --> 13:18.060
就是 join

13:18.060 --> 13:19.060
department

13:19.060 --> 13:21.060
二是d

13:21.060 --> 13:22.060
反过来写

13:22.060 --> 13:24.060
那么即使以右表为基准

13:24.060 --> 13:26.060
右表为基准满足不了条件

13:26.060 --> 13:28.060
那个右表必须要至少出现一次

13:28.060 --> 13:30.060
右表的这条基准必须要出现一次

13:30.060 --> 13:31.060
运行

13:31.060 --> 13:32.060
好,来看一下吧

13:32.060 --> 13:33.060
最后

13:33.060 --> 13:34.060
你看

13:34.060 --> 13:35.060
是不是

13:36.060 --> 13:38.060
右表它至少要出现一次

13:38.060 --> 13:39.060
对不对

13:39.060 --> 13:40.060
哪怕没有满足条件

13:40.060 --> 13:42.060
右表它至少要出现一次

13:42.060 --> 13:43.060
它指的是这个

13:43.060 --> 13:44.060
右连接是差不多的

13:44.060 --> 13:45.060
都可以互换的

13:45.060 --> 13:46.060
我只需要学一种就行了

13:46.060 --> 13:48.060
这种用的稍微少一点

13:48.060 --> 13:49.060
用的最多的

13:49.060 --> 13:52.560
我们把它复制一下

13:52.560 --> 13:54.560
连接

13:54.560 --> 13:56.560
short

13:56.560 --> 13:57.560
这是

13:57.560 --> 13:58.560
右连接对吧

13:58.560 --> 14:02.060
左连接

14:02.060 --> 14:03.060
左连接

14:03.060 --> 14:05.060
left join

14:05.060 --> 14:06.060
department

14:06.060 --> 14:07.060
这个写前面

14:07.060 --> 14:11.400
这个写后面

14:12.400 --> 14:14.400
关键是我们用的最多的是什么呢

14:14.400 --> 14:15.400
是内连接

14:15.400 --> 14:16.400
这是用的最多的

14:16.400 --> 14:17.400
内连接是什么呢

14:17.400 --> 14:19.400
就是条件必须要满足

14:19.400 --> 14:21.400
如果说满足不了条件

14:21.400 --> 14:22.400
那就不能出现

14:22.400 --> 14:23.400
比方说

14:23.400 --> 14:24.400
我们这里用内连接

14:24.400 --> 14:25.400
那么哪个表放左

14:25.400 --> 14:26.400
哪个表放右无所谓了

14:26.400 --> 14:28.400
只是显示顺序不一样

14:28.400 --> 14:30.400
顺序我们这里可以调整的对吧

14:30.400 --> 14:32.400
那么这里我们用内连接看一下

14:32.400 --> 14:34.400
是不是这个新部门出不来了

14:34.400 --> 14:36.400
新部门就肯定出不来了

14:36.400 --> 14:38.400
新部门出不来了

14:38.400 --> 14:39.400
这就是内连接

14:39.400 --> 14:40.400
我们这个是用的最多的

14:40.400 --> 14:42.400
这是连接

14:42.400 --> 14:43.400
表

14:43.400 --> 14:44.400
来进行查询

14:44.400 --> 14:46.400
当然这个结果里面东西很多

14:46.400 --> 14:47.400
当然你可以在那个车里面

14:47.400 --> 14:49.400
对整个这张表

14:49.400 --> 14:50.400
筛选一些数据出来

14:50.400 --> 14:51.400
我们不希望显示那么多

14:51.400 --> 14:52.400
我们可能只希望显示内

14:52.400 --> 14:53.400
显示内

14:53.400 --> 14:55.400
最后这个Name是不是有重复

14:55.400 --> 14:56.400
是有重复

14:56.400 --> 14:58.400
他说ClownName

14:58.400 --> 14:59.400
他说有重复了

14:59.400 --> 15:01.400
不知道要显示哪个Name

15:01.400 --> 15:02.400
所以说这里最好给个表明

15:02.400 --> 15:03.400
比方说

15:03.400 --> 15:05.400
我们要显示部门的名称

15:05.400 --> 15:06.400
给他一个别名

15:06.400 --> 15:08.400
就是Depart

15:08.400 --> 15:10.400
DepartName

15:10.400 --> 15:13.400
然后还要显示员工的名称

15:13.400 --> 15:15.400
这是员工名称

15:16.400 --> 15:18.400
然后部门的名称

15:18.400 --> 15:21.400
第一点Name

15:21.400 --> 15:24.400
DepartName

15:24.400 --> 15:25.400
你看

15:25.400 --> 15:26.400
是不是只显示两连

15:26.400 --> 15:28.400
每个员工的说出了部门

15:28.400 --> 15:29.400
是不是都可以查询出来

15:29.400 --> 15:30.400
非常灵活的

15:30.400 --> 15:32.400
这就是连表查询

15:32.400 --> 15:34.400
当然我们这里只是连了两张表

15:34.400 --> 15:35.400
对不对

15:35.400 --> 15:37.400
是不是还可以连多张表

15:37.400 --> 15:39.400
那么这是连出来的一张表

15:39.400 --> 15:40.400
我们连了一次

15:40.400 --> 15:42.400
我们还可以继续连

15:42.400 --> 15:43.400
还可以继续连

15:43.400 --> 15:44.400
连什么

15:44.400 --> 15:46.400
连那个公司表

15:46.400 --> 15:47.400
我们又来音乐交易

15:47.400 --> 15:48.400
后面又继续写

15:48.400 --> 15:49.400
连什么

15:49.400 --> 15:50.400
连公司表

15:52.400 --> 15:53.400
条件是什么

15:53.400 --> 15:54.400
条件是前面

15:54.400 --> 15:55.400
这已经连好了

15:55.400 --> 15:56.400
前面已经连好了表了

15:56.400 --> 15:58.400
这个时候才在运行浮浪

15:58.400 --> 15:59.400
先运行浮浪

16:02.400 --> 16:04.400
连表的时候出现了

16:07.400 --> 16:08.400
然后我们继续连接

16:08.400 --> 16:10.400
这是一次连接的

16:10.400 --> 16:12.400
连接到另一个表

16:12.400 --> 16:13.400
然后继续连接

16:13.400 --> 16:14.400
连接什么

16:14.400 --> 16:15.400
连接到公司

16:16.400 --> 16:17.400
连接到公司

16:17.400 --> 16:18.400
条件是什么

16:18.400 --> 16:19.400
条件是

16:20.400 --> 16:22.400
部门表的公式ID

16:22.400 --> 16:24.400
部门表不是一个公式ID吗

16:24.400 --> 16:26.400
等于什么公式表的ID

16:26.400 --> 16:28.400
通常情况下都是外界连接

16:28.400 --> 16:29.400
连接出来

16:29.400 --> 16:30.400
那么我们选的时候

16:30.400 --> 16:31.400
我们是不是可以

16:31.400 --> 16:33.400
我们先这样子

16:35.400 --> 16:36.400
看一下

16:36.400 --> 16:37.400
那么现在信息有很多了

16:37.400 --> 16:38.400
有员工的信息

16:38.400 --> 16:39.400
有部门的信息

16:39.400 --> 16:41.400
是不是还有公司的信息

16:41.400 --> 16:42.400
对不对

16:42.400 --> 16:43.400
那么我们这里

16:43.400 --> 16:44.400
就可以写上

16:44.400 --> 16:45.400
员工的名字

16:45.400 --> 16:46.400
部门的名字

16:46.400 --> 16:47.400
以及公司的名字

16:47.400 --> 16:48.400
都可以拿出来了

16:48.400 --> 16:49.400
C.NET

16:50.400 --> 16:51.400
NET

16:51.400 --> 16:52.400
OS

16:52.400 --> 16:53.400
company

16:53.400 --> 16:54.400
NET

16:55.400 --> 16:56.400
对吧

16:56.400 --> 16:57.400
那一看

16:57.400 --> 16:58.400
是不是显示出来了

16:58.400 --> 17:02.180
对吧

17:03.180 --> 17:04.180
对不对

17:04.180 --> 17:06.180
这是连表查询

17:06.180 --> 17:08.180
就可以从多张表里面去取数据

17:08.180 --> 17:09.180
它的概念

17:09.180 --> 17:11.180
其实语法都很简单

17:11.180 --> 17:12.180
我们来

17:12.180 --> 17:13.180
关键是要多做一些练习

17:13.180 --> 17:14.180
凭什么用的

17:14.180 --> 17:16.180
比较用的多的

17:16.180 --> 17:18.180
一些常见的查询

17:18.180 --> 17:19.180
第一个

17:19.180 --> 17:21.180
显示出

17:21.180 --> 17:22.180
员工的姓名

17:22.180 --> 17:23.180
姓别入职时间

17:23.180 --> 17:24.180
薪水

17:24.180 --> 17:25.180
所属部门

17:25.180 --> 17:26.180
所属公司

17:27.180 --> 17:28.180
好来吧

17:28.180 --> 17:29.180
我们做一下这道题

17:29.180 --> 17:30.180
你们可以自己

17:30.180 --> 17:31.180
自己先做一下

17:31.180 --> 17:32.180
再来听我讲

17:33.180 --> 17:34.180
来吧

17:34.180 --> 17:35.180
来做一下这道题

17:38.180 --> 17:39.180
我们要查询

17:39.180 --> 17:41.180
查询的是员工表

17:41.180 --> 17:43.180
我们先写出来

17:43.180 --> 17:44.180
查询什么

17:44.180 --> 17:45.180
查询 employee

17:45.180 --> 17:46.180
员工表

17:46.180 --> 17:47.180
要显示什么

17:47.180 --> 17:48.180
员工的姓名

17:48.180 --> 17:49.180
对吧

17:49.180 --> 17:50.180
我给它个别名翼

17:50.180 --> 17:51.180
员工的姓名

17:51.180 --> 17:52.180
那么我们这里

17:52.180 --> 17:53.180
翼

17:55.180 --> 17:56.180
员工的姓名

17:56.180 --> 17:57.180
我们用中文嘛

17:57.180 --> 17:58.180
姓名

17:59.180 --> 18:00.180
还有显示什么呢

18:00.180 --> 18:01.180
员工的姓别

18:01.180 --> 18:02.180
是用男和女的显示

18:02.180 --> 18:03.180
那么我们这里

18:03.180 --> 18:04.180
是不是用case

18:04.180 --> 18:05.180
上点科学的

18:05.180 --> 18:06.180
case什么

18:06.180 --> 18:07.180
意思没有

18:09.180 --> 18:10.180
我们就写成一行吧

18:10.180 --> 18:11.180
当什么的时候

18:11.180 --> 18:13.180
当那个唯一的时候

18:13.180 --> 18:14.180
我们显示什么呢

18:14.180 --> 18:15.180
显示男

18:16.180 --> 18:17.180
然后呢

18:19.180 --> 18:20.180
z else

18:20.180 --> 18:21.180
显示女

18:21.180 --> 18:22.180
对不对

18:22.180 --> 18:23.180
end

18:23.180 --> 18:24.180
不要忘记了

18:24.180 --> 18:25.180
end

18:25.180 --> 18:26.180
给它个定个别名吧

18:26.180 --> 18:27.180
姓别

18:27.180 --> 18:28.180
你看一下

18:28.180 --> 18:29.180
现在是不是查询了

18:29.180 --> 18:30.180
两列出来了

18:30.180 --> 18:31.180
对不对

18:31.180 --> 18:32.180
入职时间

18:32.180 --> 18:34.180
入职时间就是 join date

18:35.180 --> 18:36.180
入职时间

18:36.180 --> 18:37.180
我们

18:37.180 --> 18:38.180
用1点有 join date

18:38.180 --> 18:39.180
这样更加明确一点

18:39.180 --> 18:40.180
然后呢

18:40.180 --> 18:41.180
这里是入职时间

18:41.180 --> 18:42.180
我们把它写成中文嘛

18:42.180 --> 18:43.180
入职时间

18:43.180 --> 18:44.180
通常以后也不是中文

18:44.180 --> 18:45.180
通常我们都是

18:45.180 --> 18:46.180
要定别名的话

18:46.180 --> 18:47.180
也是用英文的

18:48.180 --> 18:49.180
入职时间

18:49.180 --> 18:50.180
我们一看

18:50.180 --> 18:51.180
就入职时间出来了

18:51.180 --> 18:52.180
薪水

18:53.180 --> 18:54.180
1点什么 salary

18:55.180 --> 18:56.180
薪水

18:56.180 --> 19:00.420
多的都好

19:01.420 --> 19:02.420
薪水是不是出来了

19:02.420 --> 19:03.420
对不对

19:03.420 --> 19:04.420
所属部门

19:04.420 --> 19:05.420
而部门的名称

19:06.420 --> 19:07.420
在哪张表

19:07.420 --> 19:08.420
它不在这张表对吧

19:08.420 --> 19:09.420
部门的名称是不在这张表

19:09.420 --> 19:10.420
是不是在另外一张表

19:10.420 --> 19:11.420
在部门表里边

19:11.420 --> 19:12.420
我们要看一下

19:12.420 --> 19:14.420
每一个员工属于哪个部门

19:14.420 --> 19:15.420
那怎么办呢

19:15.420 --> 19:16.420
是不是要用连接

19:16.420 --> 19:17.420
对吧

19:17.420 --> 19:18.420
我们用 inner join

19:18.420 --> 19:19.420
这是用的最多的

19:19.420 --> 19:20.420
就连接到哪张表

19:20.420 --> 19:21.420
连接到我们的部门表

19:21.420 --> 19:22.420
department

19:23.420 --> 19:24.420
d

19:24.420 --> 19:25.420
给它定个别名

19:25.420 --> 19:26.420
换一行

19:26.420 --> 19:27.420
换行随便在哪里换

19:27.420 --> 19:28.420
然后条件是

19:28.420 --> 19:29.420
1点什么呢

19:29.420 --> 19:31.420
1点的 depart id

19:31.420 --> 19:32.420
等于

19:32.420 --> 19:33.420
1点 id

19:33.420 --> 19:34.420
对不对

19:34.420 --> 19:35.420
好那么这样的部门

19:35.420 --> 19:36.420
是不是连接起来了

19:36.420 --> 19:37.420
但是我们现在只是

19:37.420 --> 19:38.420
部门显示不出来

19:38.420 --> 19:39.420
但连可能连接起来了

19:39.420 --> 19:40.420
它是一张很大的表

19:40.420 --> 19:41.420
我们在大的表里边

19:41.420 --> 19:42.420
只删选了这些数据

19:42.420 --> 19:43.420
出来显示

19:43.420 --> 19:44.420
我们这里

19:44.420 --> 19:45.420
可以完全就可以

19:45.420 --> 19:46.420
把这个部门显示出来

19:46.420 --> 19:47.420
1点内

19:48.420 --> 19:49.420
这是部门

19:49.420 --> 19:50.420
理由称

19:52.420 --> 19:53.420
运行

19:53.420 --> 19:54.420
每个员工的部门

19:54.420 --> 19:55.420
明显是不是出来了

19:55.420 --> 19:56.420
对吧

19:56.420 --> 19:57.420
然后还要显示什么

19:57.420 --> 19:59.420
还要显示所属公司

19:59.420 --> 20:00.420
那么我们这里

20:00.420 --> 20:01.420
是不是又来inner join

20:02.420 --> 20:03.420
company

20:04.420 --> 20:05.420
C

20:06.420 --> 20:07.420
部门的

20:08.420 --> 20:09.420
因为部门的

20:09.420 --> 20:11.420
公司 id 等于公司的 id

20:11.420 --> 20:12.420
对吧

20:12.420 --> 20:13.420
因为这两个是外界

20:13.420 --> 20:14.420
我们把部门

20:14.420 --> 20:16.420
就是员工连到部门

20:16.420 --> 20:17.420
你看

20:17.420 --> 20:19.420
员工通过这个 depart id

20:19.420 --> 20:20.420
相当于把这一列

20:20.420 --> 20:21.420
就展开成一个部门表了

20:21.420 --> 20:22.420
放到这

20:22.420 --> 20:23.420
id 为五的部门

20:23.420 --> 20:24.420
放到这一行

20:24.420 --> 20:25.420
id 为五的部门

20:25.420 --> 20:26.420
放到这一行

20:26.420 --> 20:27.420
id 为五的部门

20:27.420 --> 20:28.420
放到这一行

20:28.420 --> 20:29.420
那么放过来过后

20:29.420 --> 20:30.420
部门表是不是有company id

20:30.420 --> 20:32.420
company id 为一的

20:32.420 --> 20:33.420
把公司的放到这一行

20:33.420 --> 20:34.420
把公司 id 为一的

20:34.420 --> 20:35.420
放到这一行

20:35.420 --> 20:36.420
对吧

20:36.420 --> 20:37.420
就这么个意思

20:37.420 --> 20:38.420
然后我们在

20:38.420 --> 20:39.420
这里写上

20:39.420 --> 20:40.420
sidear

20:40.420 --> 20:41.420
name

20:41.420 --> 20:42.420
这是公司名称

20:43.420 --> 20:44.420
运行

20:44.420 --> 20:45.420
你看

20:45.420 --> 20:46.420
是不是就查出来了

20:46.420 --> 20:47.420
每个员工

20:47.420 --> 20:48.420
所属的部门

20:48.420 --> 20:49.420
以及公司的名称

20:49.420 --> 20:50.420
对不对

20:50.420 --> 20:51.420
这个你的顺序

20:51.420 --> 20:52.420
按照 select 的顺序来显示

20:52.420 --> 20:54.420
这是这道题的做法

20:55.420 --> 20:56.420
复制一下

20:56.420 --> 21:01.650
接下来我们再看

21:01.650 --> 21:02.650
我们现在要查询出

21:02.650 --> 21:04.650
腾讯和

21:04.650 --> 21:06.650
蚂蚁金服的

21:06.650 --> 21:07.650
所有姓名

21:07.650 --> 21:08.650
姓别入职时间

21:08.650 --> 21:10.650
部门公司名

21:11.650 --> 21:12.650
对吧

21:12.650 --> 21:13.650
查询的信息还是这些信息

21:13.650 --> 21:14.650
对不对

21:14.650 --> 21:15.650
那么我们太简单了

21:15.650 --> 21:16.650
我们直接把这个复制一下

21:16.650 --> 21:20.790
直接复制一下

21:20.790 --> 21:21.790
无非就在这种情况下

21:21.790 --> 21:23.790
再进行篩选

21:23.790 --> 21:24.790
先运行服装

21:24.790 --> 21:25.790
把这些表连起来

21:25.790 --> 21:27.790
在连了之后

21:27.790 --> 21:28.790
我们再进行篩选

21:28.790 --> 21:29.790
where

21:29.790 --> 21:30.790
篩选

21:30.790 --> 21:31.790
篩选什么呢

21:31.790 --> 21:32.790
我们篩选公司的名称

21:32.790 --> 21:33.790
注意

21:33.790 --> 21:34.790
不是说你

21:34.790 --> 21:35.790
不是说你是那个

21:35.790 --> 21:36.790
成了公司的名称

21:36.790 --> 21:37.790
你才能篩选公司名称

21:37.790 --> 21:38.790
where 是先运行的

21:38.790 --> 21:39.790
对吧

21:39.790 --> 21:40.790
现在这个结果基础上

21:40.790 --> 21:41.790
很大的一张表里边

21:41.790 --> 21:42.790
再进行篩选

21:42.790 --> 21:43.790
把那些不要的行

21:43.790 --> 21:44.790
篩选掉

21:44.790 --> 21:45.790
然后再来篩选那个称

21:45.790 --> 21:46.790
说这里哪里

21:46.790 --> 21:47.790
哪怕一些没有显示出来的列

21:47.790 --> 21:48.790
你仍然可以用的

21:48.790 --> 21:50.790
只要这个查询出来的结果里边有

21:50.790 --> 21:51.790
where

21:51.790 --> 21:53.790
里边我们公司的名称

21:53.790 --> 21:55.790
公司的名称是

21:55.790 --> 21:56.790
seed.name

21:56.790 --> 21:57.790
对吧

21:57.790 --> 21:58.790
公司的名称

21:58.790 --> 21:59.790
公司的名称是什么呢

21:59.790 --> 22:01.790
公司的名称

22:01.790 --> 22:03.790
是腾讯

22:03.790 --> 22:04.790
和蚂蚁金服

22:04.790 --> 22:05.790
也就是说

22:05.790 --> 22:06.790
公司的名称既可以是腾讯

22:06.790 --> 22:07.790
也可以是蚂蚁金服

22:07.790 --> 22:09.790
所以我们可以用印

22:09.790 --> 22:11.790
腾讯

22:11.790 --> 22:13.790
腾讯我们这里是腾讯科技

22:13.790 --> 22:15.790
对吧

22:15.790 --> 22:16.790
和什么呢

22:16.790 --> 22:20.170
和蚂蚁金服

22:20.170 --> 22:21.170
对不对

22:21.170 --> 22:22.170
运行

22:22.170 --> 22:23.170
那么现在是不是只显示到

22:23.170 --> 22:24.170
腾讯和蚂蚁金服了

22:24.170 --> 22:25.170
对吧

22:25.170 --> 22:26.170
肚子已经没有显示出来了

22:26.170 --> 22:27.170
就是这道题

22:27.170 --> 22:29.740
特别简单

22:29.740 --> 22:30.740
那么下一道题

22:30.740 --> 22:31.740
下一道题

22:31.740 --> 22:32.740
其实我们也可以用

22:32.740 --> 22:35.050
这个查询来做

22:35.050 --> 22:36.050
下一道题是什么呢

22:36.050 --> 22:37.050
下一道题是

22:37.050 --> 22:40.050
查询肚医教学部的

22:40.050 --> 22:42.050
所有员工姓名

22:42.050 --> 22:43.050
姓别公司的这些东西

22:43.050 --> 22:44.050
对吧

22:44.050 --> 22:45.050
那么这个C那個是不一样的

22:45.050 --> 22:46.050
C那个是不变

22:46.050 --> 22:48.050
连表也不变

22:48.050 --> 22:49.050
无非就条件变一下

22:49.050 --> 22:50.050
对吧

22:50.050 --> 22:51.050
条件是什么呢

22:51.050 --> 22:53.050
公司的名称

22:53.050 --> 22:54.050
调链

22:54.050 --> 22:55.050
公司的名称

22:55.050 --> 22:56.050
必须要是什么呢

22:56.050 --> 22:57.050
必须要是肚医

22:57.050 --> 22:59.050
我们可以用耐克模糊匹配

22:59.050 --> 23:00.050
也可以用等号

23:00.050 --> 23:02.050
看你的具体的情况

23:02.050 --> 23:03.050
必须是肚医

23:03.050 --> 23:04.050
对吧

23:04.050 --> 23:05.050
我们只查肚医的

23:05.050 --> 23:06.050
运行出来

23:06.050 --> 23:07.050
是不是只查肚医教学的

23:07.050 --> 23:09.050
但是我们只查教学部

23:09.050 --> 23:10.050
还有一个and的条件

23:10.050 --> 23:12.050
只有教学部就是

23:12.050 --> 23:14.050
部门的名称

23:14.050 --> 23:15.050
必须要等于什么呢

23:15.050 --> 23:17.050
等于教学部

23:20.050 --> 23:21.050
你看是不是只查了

23:21.050 --> 23:23.050
肚医教学部的

23:23.050 --> 23:25.050
这名字是假的

23:25.050 --> 23:26.050
不用看了

23:26.050 --> 23:27.050
只查肚医教学部的

23:27.050 --> 23:28.050
所有员工

23:28.050 --> 23:29.050
对不对

23:29.050 --> 23:30.050
那有同学说

23:30.050 --> 23:31.050
有同学可能对数据

23:31.050 --> 23:33.050
也比较看了一下数据

23:33.050 --> 23:34.050
就是我们的部门里面

23:34.050 --> 23:35.050
不是

23:35.050 --> 23:36.050
只有肚医才有教学部吗

23:36.050 --> 23:37.050
其他部门没有教学部

23:37.050 --> 23:38.050
你不能这样假设的

23:39.050 --> 23:41.050
这个数据会增加的

23:41.050 --> 23:42.050
会被管理的

23:42.050 --> 23:44.050
不要让我们程序增加了一些部门

23:44.050 --> 23:45.050
它又出不准

23:45.050 --> 23:47.050
所以说一定要按照这个逻辑

23:47.050 --> 23:48.050
把信息写全

23:48.050 --> 23:49.050
那万一别的公司

23:49.050 --> 23:50.050
也有教学部了

23:50.050 --> 23:51.050
对不对

23:51.050 --> 23:52.050
所以说

23:52.050 --> 23:53.050
写全

23:53.050 --> 23:54.050
复制

23:54.050 --> 23:55.050
整体过来

23:55.050 --> 23:56.050
这是这道题

23:57.050 --> 23:58.050
都去写一下

23:58.050 --> 23:59.050
不写的话

23:59.050 --> 24:00.050
你光听了

24:00.050 --> 24:01.050
你不写的话

24:01.050 --> 24:02.050
根本就记不住

24:02.050 --> 24:04.050
这东西一晃眼就忘了

24:04.050 --> 24:06.050
列出所有

24:06.050 --> 24:07.050
公司员工居住的地址

24:07.050 --> 24:08.050
要去掉重复

24:08.050 --> 24:09.050
我们是不是做过的

24:09.050 --> 24:10.050
对不对

24:10.050 --> 24:11.050
做过的

24:11.050 --> 24:12.050
第一次听个词

24:12.050 --> 24:13.050
对不对

24:13.050 --> 24:14.050
做过的

24:14.050 --> 24:15.050
OK

24:15.050 --> 24:16.050
那么这里就是

24:16.050 --> 24:17.050
我们这个捷克

24:17.050 --> 24:18.050
讲了多表查询

24:18.050 --> 24:20.050
多表查询和单表查询

24:20.050 --> 24:21.050
这些都是基本查询

24:21.050 --> 24:24.050
而且用的非常非常广泛

24:24.050 --> 24:26.050
一定要把它用熟

24:26.050 --> 24:27.050
因为不然的话

24:27.050 --> 24:28.050
到时候用熟以后

24:28.050 --> 24:29.050
一些查询写不出来就麻烦了

24:29.050 --> 24:30.050
其实都很简单

24:30.050 --> 24:31.050
一点都不复杂

24:31.050 --> 24:33.050
你下去把这题念一念

