WEBVTT

00:00.880 --> 00:05.360
这些课呢 咱们来学习webhack的安装和使用

00:06.640 --> 00:13.360
webhack干嘛的 它是构建工具 它用来干嘛 它是把我们开发的时候写的很爽的代码

00:14.160 --> 00:18.000
然后把它转变成运行的时候很爽的代码 就做这么一件事

00:19.480 --> 00:27.880
好 首先那webhack的官网呢 是这个地址啊 这个地址呢 大家我建议大家呢 最好把它收藏起来啊 收藏到自己的就是标权囊啊 就是那个

00:28.440 --> 00:35.400
收藏在里边啊 以后呢 我会经常到这个网站里边给大家看一下他的中文文档啊 这个文档

00:36.360 --> 00:41.960
从这门课开始呢 大家要逐渐的学会去阅读文档啊 要有这么一个能力

00:42.280 --> 00:48.600
因为并不是老师在课程中能够把所有的apn啊 所谓的配置呢 全部讲完 这是不可能做到的

00:49.560 --> 00:56.360
所以说有些呢 如果说遇到一些特殊的情况呢 你们需要到他的官网里边去找他的相关的apn或者是相关的配置

00:57.160 --> 01:02.280
ok 这是他的中文文档 首先让我们看一下首页啊 首先就这个东西 他干嘛 打包所有的资源

01:02.840 --> 01:11.960
ok 目前他的最新版本呢 是webhack 4 啊 这个版本 其实我们这门课呢 就直接讲最新版本就可以了

01:12.440 --> 01:19.080
啊 以前讲这个课呢 还挺麻烦的 因为以前呢 刚刚升到的40个版本呢 还要去讲一讲

01:19.800 --> 01:22.760
webhack 3 如何去升级到webhack 4 啊 因为

01:23.320 --> 01:30.040
webhack 3和webhack 4呢 有一个非常大的差异啊 很多对方都不一样了 所以说要讲一下 怎么是去升级

01:30.440 --> 01:36.280
那么现在的不用了啊 因为我们现在呢 已经过了这么长时间了啊 webhack 4呢 基本上全部普及

01:36.600 --> 01:39.800
普及开来了 所以说我们直接学习最新版本就可以了

01:41.320 --> 01:44.440
好 接下来我们先对这个webhack 做一个简单的介绍啊

01:45.480 --> 01:48.280
他是基于一个模块化的打包工具

01:49.480 --> 01:56.680
他把一切都视为模块 这是 这是什么意思呢 就是说你看啊 这边打包 左边就是我们的开发时代

01:56.760 --> 01:59.800
对吧 开发的开发的时候呢 我们就写左边代码

02:00.440 --> 02:06.120
然后右边呢 就是他通过这个webhack 中间就是webhack啊 通过webhack之后呢 还会打包成为

02:06.440 --> 02:11.640
一个 也就是构建成为一个运行时代的东西 就运行时代我们需要的东西

02:12.520 --> 02:18.200
那么在webhack里边呢 他把我们开发时代里边的所有东西全部视为模块

02:19.160 --> 02:23.240
不管是你的GS代码啊 还是什么

02:23.880 --> 02:25.080
呃 图片

02:25.880 --> 02:32.040
或者是什么呢 这些啊SARS代码SARS 大家还没有学过啊 可能还没学过 我们这门课会讲解

02:33.400 --> 02:38.440
就是他里边的所有什么css 乱七八糟的所有东西 他全部视为模块

02:39.320 --> 02:43.240
也就是说在webhack里边的模块啊 他的概念的范畴是

02:43.800 --> 02:46.360
要比我们之前学习的模块的范畴要大

02:47.000 --> 02:48.520
他把所有东西全部视为模块

02:49.320 --> 02:53.720
哎 至于他为什么要这样做 哎 如果说一个图片他作为一个模块

02:54.120 --> 02:59.960
他又是怎么回事呢 他为什么要这样去做呢 后边呢 我们讲到什么css模块

03:00.360 --> 03:07.480
讲到图片模块或者是一些其他的普通文件模块的时候呢 大家就明白了啊 他为什么要去这样子处理

03:07.880 --> 03:12.040
他是要考虑很多的 总之呢 在webhack里边他把一切都视为模块

03:12.760 --> 03:13.080
ok

03:14.040 --> 03:16.600
好 那么他要做的就是对一些模块进行打包

03:17.320 --> 03:24.120
啊 他怎么来打包呢 他是通过一个开发时胎的入口模块作为起点啊 通常是一个介石文件

03:24.760 --> 03:26.600
然后他这里啊 他怎么来做的

03:28.280 --> 03:31.320
他就通过一个入口文件比方这个 这就是个入口文件

03:31.960 --> 03:35.240
啊 他通过这个入口文件 你当然你要告诉他入口文件是啥

03:35.720 --> 03:39.960
啊 就跟我们运行斗的介石要启动一个入口对吧 一个启动启动文件

03:40.520 --> 03:44.520
啊 他就是告诉了一个入口 那么他通过这个入口呢 把他当成一个模块

03:44.760 --> 03:47.720
他来分析这些模块的依赖关系 他比方他发现

03:48.200 --> 03:53.000
这个模块呢 他依赖这个模块 这个模块又依赖这个模块 这个模块又依赖这个 有的依赖这个

03:53.400 --> 03:58.600
总之他会分析出一种依赖关系 他怎么来分析的 非常简单 你不是一个模块吗

03:59.480 --> 04:01.160
你模块里边一定会用一些

04:01.880 --> 04:05.960
倒入代码对吧 比方说require 是不是一个倒入代码 那么这个东西是不是依赖

04:06.920 --> 04:12.120
或者说你用了什么 import 啥啥 france 啥啥对吧 那么这个东西是不是依赖

04:12.840 --> 04:15.480
他就会从你这个模块里边 他把读取出来

04:16.360 --> 04:23.400
来读取这个模块的内容 那么把内容读出来过后 他分析里边有哪些这种语句 那么是不是就把依赖分析出来了

04:23.880 --> 04:29.160
好 依赖分析出来过后呢 他就从这个模块 依赖的模块里边再一次进行分析 这是一个帝规的过程

04:29.640 --> 04:30.920
他分析出所有依赖

04:32.360 --> 04:38.600
然后怎么办呢 然后经过一系列的过程 就在中间这一部分 经过一系列的过程 他做了很多事情

04:39.320 --> 04:44.280
那么 比方说压缩啊 把这些依赖的所有的模块 把他压缩在一起进行合并

04:45.080 --> 04:50.600
最终生成了运行事态的文件 那么你可以认为 你可以简单的认为他做了什么事情呢

04:51.160 --> 04:56.280
比方说这里有很多的GS啊 然后这里啊 a这个GS呢依赖b

04:56.840 --> 05:03.720
b呢又依赖c c又依赖d 他一分析出这个依赖关系 他把abc的四个文件全部压缩合并成为一个文件

05:04.440 --> 05:10.200
那么运行事态是不是就文件越少越好 对吧 文件体积越小越好 那么他这样一做

05:10.520 --> 05:16.120
哎 他生成一个最终可以运行的GS文件 所以说我们左边的代码是不是要运行的

05:16.840 --> 05:24.760
不运行 我们只运行后右边代码啊 只运行右边代码 只不过呢 右边代码的跟左边代码的是

05:25.160 --> 05:31.160
功能是一样的啊 只不过呢 他压缩了过后呢 运行运行起来了 浏览器就比较喜欢了

05:32.120 --> 05:34.680
哦 这是未拍卡的核心原理啊 就这么简单

05:36.040 --> 05:39.960
好 接下来我们来说一下未拍卡的特点啊 他就有跟其他的

05:40.520 --> 05:47.480
呃 构建工具呢 他有一些差异的地方啊 他的独特的特点 第一个呢 他是为前端工程化而生

05:48.360 --> 05:50.280
他的出现了就是在解决

05:51.080 --> 05:53.320
前端工程化的 他出现的时间很早

05:54.280 --> 05:58.120
呃 在八年前吧 也就是一二年啊 一二年

05:58.680 --> 06:04.920
一二年的时候呢 未拍卡出现 那么那个时候连es6都没有对吧 但后来他又出来es6了啊

06:05.320 --> 06:09.000
他经过了很多的版本更迭 他出现了最开始出现的目的

06:09.560 --> 06:15.640
就是为了解决前端工程化的问题啊 特别是浏览器端工程化遇到的问题

06:16.280 --> 06:25.000
实际上Node端 有工程化 有没有遇到问题也有啊 其实Node端也可以用未拍卡 只是呢 我们可能用了少一点啊 主要是在浏览器端使用

06:25.960 --> 06:28.920
让他的主要的目的是让开发者

06:29.640 --> 06:34.680
有了未拍卡之后呢 你就集中精力开发你的业务代码 开发你的功能

06:35.080 --> 06:40.680
不要去考虑什么兼容性啊 什么执行效率啊 这些问题 全部教会未拍卡的处理

06:42.440 --> 06:49.960
那么他的作用就是起到什么一个作用 让开发者呢 把把的把他的时间放到业务代码的开发上

06:50.280 --> 06:58.120
这个特点呢 是简单易用 简单到什么程度呢 你安装好了过后 什么代码的一行代码都不用写

06:58.520 --> 07:04.200
一行额外的代码都不用写 直接就可以使用了啊 他可以支持零配置 什么配置都不用

07:04.680 --> 07:10.790
啊 那么直接可以使用未拍卡 还有这么简单 同时呢 还有非常的

07:12.070 --> 07:13.430
灵活和强大

07:14.710 --> 07:20.550
你要说你自己什么配置都不写 他可能功能就全部都是默认的 如果说你不想使用这些默认的功能

07:20.550 --> 07:21.830
ok 你可以进行配置

07:22.630 --> 07:25.670
而且呢 未拍卡呢 是高度可以扩展的

07:26.310 --> 07:30.790
他因为未拍的本身 那我们学习的过后就知道了啊 他本身的功能 他其实并不多

07:31.830 --> 07:35.510
只不过呢 他提供了一些机制 他可以扩展这些功能

07:35.990 --> 07:39.430
那么可以通过一些第三方库 能不能来扩展未拍的功能

07:39.830 --> 07:42.550
这一第三方库呢 可以融入到未拍卡中 那么

07:42.950 --> 07:49.750
你想啊 他相当于是提供了一个平台 那么这个平台里边可以融入其他很多东西 就形成了一个整个的生态环境

07:50.390 --> 07:56.390
目前的未拍卡的社区啊和他的生态是极其活跃的啊 相对于其他的构建工具来说

07:56.710 --> 07:57.910
他的生态了

07:58.390 --> 08:02.390
他的就是生态环境的是比其他的构建工具要活跃得多

08:03.830 --> 08:11.190
好 下个特点啊 他是基于露得结实的 这个地方费重点 一定要理解他是基于露得结实的 为什么

08:12.390 --> 08:17.830
为什么 你看他怎么的工作的原理是什么 工作的原理是不是要把这个入口文件的内容读出来

08:18.310 --> 08:26.550
他是不是要读文件内容啊 他要把这个内容读出来 把这个代码内容读出来 读出来过后呢 才能分析出里边用了怎么一个快儿语句

08:26.950 --> 08:30.310
用了import语句 那么他才能分析依赖关系

08:30.710 --> 08:36.550
分析在依赖关系过后呢 他要把他依赖的文件再一次读出来 读出来过后是不是又要分析依赖关系

08:36.870 --> 08:39.990
对吧 因此他的整个过程是要读文件的

08:40.950 --> 08:45.190
那如果说你在他的界势是在浏览器里面运行的 他能不能读文件啊

08:45.830 --> 08:47.270
读不了 读不了 对吧

08:48.230 --> 08:55.590
他只有在漏的环境里边才能读文件 所以说呢 他中间这个过程啊 就打包的过程呢 他需要漏的环境

08:56.550 --> 09:00.550
这个地方大家一定要理解啊 并不是说我们这个代码

09:01.590 --> 09:04.550
不是说我们这个代码必须要在漏的环境里边运行

09:04.790 --> 09:09.030
那有什么意义呢 我们的目的就是要在解决浏览器端的工程化问题 对吧

09:09.190 --> 09:15.270
所以我们写的代码呢 比方说我们可不可以用bucket名字 可不可以用温度对象可以啊 没问题啊 对吧

09:15.750 --> 09:19.750
我们可以写一些在浏览器端运行的代码 没问题

09:20.230 --> 09:24.950
只不过呢 他中间的这个过程 他勾件的这个过程是在漏的环境里边运行的

09:25.910 --> 09:30.470
他要在漏的环境里边把我们的代码进行打包 打包生成最终的文件

09:31.350 --> 09:32.390
听懂这个意思了吗

09:33.350 --> 09:39.750
这个一定要理解啊 指的是中间这个过程呢 他需要漏的环境 因为他要读文件

09:40.150 --> 09:46.070
他把文件内容读出来来分析应赖关系啊 那么打并且呢 还要生成文件 生成文件

09:46.390 --> 09:51.110
既也是肯定做不到对吧 在浏览器端肯定做不到的 只有在漏的环境里边是可以生成文件的

09:51.670 --> 09:56.070
啊 因此呢 他中间的过程是需要漏的环境支持的 因此呢 他运行

09:56.230 --> 10:01.910
web pack本身运行在漏的环境里边 并不是说我们的代码必须要运行在漏的环境里边

10:02.550 --> 10:07.350
我们代码可以运行 我们代码运行其实它不运行 运行的是这个 打包结果

10:07.510 --> 10:10.950
只不过打包结果的代码的功能呢 跟我们的功能是一样的啊

10:11.510 --> 10:17.430
所以说 我们现在代码到底在什么环境运行 那取决你代码的写的东西 比方说你代码里边写的

10:18.230 --> 10:20.390
比方说啊 你的代码里边写的啊

10:21.350 --> 10:24.710
写的什么呢 写的就是那个用到了fs

10:25.830 --> 10:28.790
啊 用到了漏的环境里边的东西 对吧 这是漏的环境的

10:29.030 --> 10:37.830
漏的环境的 那么你最终你最终到这边呢 是不是也是用的漏的环境里边东西 对吧

10:38.630 --> 10:41.430
最终到到深圳到打包过后呢 是不是也用的环境

10:42.310 --> 10:48.150
如果说你的代码里边用到了什么温度啊 温度对象啊 那么这是什么 浏览器环境

10:49.830 --> 10:56.790
那么你最终通过web pack打包到这边是不是也是浏览器环境 对吧 所以说你到底你的代码到底运行在漏的还是

10:56.950 --> 11:02.310
浏览器 就看你的代码怎么写啊 你希望你的代码运行在漏的环境 那就可以使用漏的环境里边的东西

11:02.550 --> 11:09.910
你希望你的代码运行在浏览器就可以使用浏览器的东西 他跟你的代码功能没关系 我只是说中间这一部分

11:11.430 --> 11:15.910
啊 他打包的过程中需要用到的环境这个很重要啊 大家一定要理解清楚

11:17.110 --> 11:18.310
好 这是基于漏的的

11:19.350 --> 11:26.150
好 下面的是基于模块化的是什么意思呢 因为他在构建过程中还要分析依赖关系他的分析怎么来分析呢

11:26.790 --> 11:30.550
他分析的方式是通过模块化的导入语句进行分析的

11:31.430 --> 11:35.110
他要读取你文件中的导入语句 什么导入语句 比方说require

11:35.830 --> 11:40.710
require是个导入语句 还有什么import是种导入语句 他要分析这些特殊的语句

11:41.110 --> 11:43.750
通过这些特殊的语句来分析出他的依赖关系

11:44.870 --> 11:48.070
那么最终来形成打包 因为他打包的过程呢 他需要

11:48.710 --> 11:54.390
知道你这个入口文件一带了哪些东西 没有一带的我就不打包了 他只打包了一些一带的东西

11:54.950 --> 12:02.710
他这么回事啊 所以说他是基于模块化的 因为只有模块化的话他才知道啊 哪些模块化导入语句是表示依赖

12:03.990 --> 12:08.630
他支持哪些模块化呢 他支持common.js 支持es6

12:09.190 --> 12:12.390
模块化 他都支持 所以说你在这边的代码里边

12:13.350 --> 12:16.550
你在这一部分代码里边 你可不可以写common.js可以

12:17.110 --> 12:18.710
可不可以写es6可以

12:19.670 --> 12:24.150
可以 当然了这些 因为这些模块化的代码他会被谁读取

12:24.470 --> 12:29.990
他不是被node.js读取 也不是被浏览器读取 他是被wip pack读取

12:30.790 --> 12:33.270
他是被他来读取 他来分析他的依赖

12:34.390 --> 12:39.110
因此他支持什么 他支持所有的模块化 还包括什么amd cmd 他都支持

12:39.590 --> 12:45.510
只不过呢 我们根本就没有必要用的那种很node的那种模块化标准了啊 我们一般就用common.js和es6模块化

12:46.470 --> 12:51.110
这样导致的结果是什么呢 哪怕一些第三方库 我们要在这边使用一些第三方库

12:51.510 --> 12:55.110
在这边要去依赖一些第三方库 第三方库是common.js使用的

12:55.750 --> 12:56.790
是common.js的

12:57.350 --> 13:01.190
ok 没问题啊 我可以用 为什么 因为这些东西都会交给wip pack来处理

13:01.510 --> 13:03.350
他会进行分析 他能分析得出来

13:03.910 --> 13:08.230
node能不能分析出来 node可以 但是浏览器分析不出来对吧 那如果说这边你

13:08.550 --> 13:12.470
这边的第三方库是使用的是es6模块化 那么node分析不出来

13:13.430 --> 13:17.750
浏览器分析得出来 这些都没关系 因为我们根本就不是交给node交给浏览器

13:17.750 --> 13:22.710
这个一定要搞清楚啊 我们这边他把不是交给node或者浏览器执行 是交给wip pack

13:23.110 --> 13:29.030
wip pack还不会把它打包 打包成最终的文件 这个文件才会交给浏览器或者是node的执行

13:29.670 --> 13:31.990
听懂了吗 那么这个文件到底是啥啊

13:32.630 --> 13:38.070
我告诉大家啊 我虽然可以提前告诉大家 这个文件里边他既没有node的

13:38.630 --> 13:41.350
既不是common.js又又不是

13:43.190 --> 13:46.870
es6模块化 都不是 是啥呀 是一个普通函数

13:47.430 --> 13:50.550
所以他就是可以通用了 这边这边代码是可以通用的

13:51.430 --> 13:58.790
因此呢 你在这边写代码的时候 不用去担心什么common.js模块化还是es6模块完全不用担心 因为wip pack都支持

14:01.030 --> 14:07.750
ok 你就可以在开发阶段的选择里 任何喜欢的模块化标准 随便用

14:08.470 --> 14:12.550
开发的时候就非常happy了 不用去考虑这些问题 这些问题交给wip pack的处理

14:13.910 --> 14:17.590
ok 好 这是wip pack的特点啊 那么接下来就就是

14:18.390 --> 14:19.910
啊 它安装了

14:21.030 --> 14:22.230
那么wip pack怎么安装呢

14:23.110 --> 14:29.910
它要通过npm的安装啊 它也是通过在发布的npm上的啊 因为它要运行的时候在node环境里面运行

14:30.950 --> 14:35.430
他提供了两个包 一个是呢wip pack啊 这个本身的包叫做核心包

14:36.150 --> 14:41.830
这个核心包里面呢 它包含了wip pack的构建 它要构建过这个整个工程嘛 对吧 构建我们的开发时代

14:42.310 --> 14:47.830
那么构建的时候呢 肯定这过程肯定是极其复杂的啊 只不过呢 我们不会讲的那么复杂

14:48.710 --> 14:55.430
那么这个过程中呢 会用到很多的代码来完成构建过程 那么这代码呢 都是跟构建相关的

14:55.750 --> 14:59.590
它跟这边有没有关系 没有 一旦构建完成就没有关系了

15:00.070 --> 15:08.550
它是在构建的过程中 要用到这些代码 那么构建的过程中 它要用到很多的API 比如一些对象啊 一些函数啊 那么这个包里面就包含了这些API

15:09.270 --> 15:14.070
它是来处理构建过程的 以后面呢 我们会多多少少接触一点

15:15.030 --> 15:23.030
然后呢 另外一个呢 就是wip pack city啊 那么这个以前是没有分开的啊 以前就是一个包 那么现在把它分开了

15:23.430 --> 15:28.390
那么这个包呢 它是提供了一个简单的 就是个命令行 控制台命令行 一个命令

15:29.110 --> 15:35.830
那么通过这个命令呢 它能够在内部去调用这个wip pack里边的核心的API来完成构建过程

15:36.630 --> 15:39.190
也就是说真正的构建是谁来完成的 是他来完成的

15:39.830 --> 15:45.670
理论上来说 只要你能够读懂wip pack的核心包里边的原代嘛 你能够把它分析一次啊

15:46.070 --> 15:51.190
当然我们这本课肯定不会分析它的原代吧 太复杂了啊 也不会有任何的一个公司

15:51.910 --> 15:55.750
在现在都还会问你啊 我会问问你这这些问题啊 不用担心

15:56.310 --> 16:00.070
如果说假设啊 你能够把wip pack的原代码全部吃透

16:01.030 --> 16:03.110
你可不可以不安装第二个 可以

16:03.830 --> 16:09.670
你自己直接写一段介石代码 那能够就可以调用它的核心包的API就可以完成构建

16:10.710 --> 16:15.830
当然可以不用去不用去安装这个 但是没必要吧 我们他已经给你写好了 我们直接用就行了

16:16.230 --> 16:21.750
所以说我们安装wip pack的时候安装几个 安装第一个他是最最重要的 然后呢安装他

16:22.150 --> 16:25.670
他的出现的主要是为了方便我们用一个命令来进行构建

16:25.830 --> 16:29.590
不然的话你要自己写介石代码 雕用这些API来构建 那太麻烦了

16:30.150 --> 16:34.950
好 那么安装的时候我们到底是全局安装还是本地安装的啊

16:35.270 --> 16:40.150
全局安装的他有个特点我们之前都说过啊 比方说有一些心理命令有一些就是

16:41.910 --> 16:45.430
控制台命令啊 他如果需要全局使用的话可以全局安装

16:46.150 --> 16:50.950
但是呢 这些呢都以前都是因为没有这个东西没有什么呢 没有npx

16:51.670 --> 16:55.670
没有他没有他没办法我只能全局安装才能使用这个命令

16:55.910 --> 17:00.150
但是现在有了他了过后还用得到全局吗 用不着了啊

17:00.630 --> 17:03.990
因为全局的他版本是不太容易控制的 他只有一个版本

17:04.470 --> 17:07.350
比方说你以后很多工程都是通过wip pack来搭建的

17:07.750 --> 17:11.030
那么搭建过好 考了过后一个工程可能对应一个wip pack版本

17:11.270 --> 17:15.110
那么如果说你全局安装的话全部都是使用统一版本了 他就没有办法

17:15.350 --> 17:17.430
为每一个工程对应一个版本了

17:17.990 --> 17:22.790
因此呢 我们最好使用本地安装 那么这样子呢每个项目都有自己的wip pack版本

17:23.190 --> 17:27.110
那么我们怎么在本地安装呢 很简单

17:27.270 --> 17:29.910
比方说这一刻啊 我们要安装个wip pack来吧

17:31.030 --> 17:34.310
好 这里我们还是用那个这种方式啊 还是用bash吧

17:35.190 --> 17:39.030
因为他wip pack里边他显示东西很多啊 不然大家看不清楚

17:40.710 --> 17:42.230
还是在这 长大一点

17:43.190 --> 17:48.070
好 这里呢 我们首先初始化一下 npm inlet

17:52.340 --> 17:53.860
ok yeah

17:57.220 --> 17:58.100
重来啊 重来

17:58.980 --> 18:00.020
npm inlet

18:02.790 --> 18:03.510
test

18:07.020 --> 18:10.220
好 我这里往右边移动一点啊

18:13.160 --> 18:17.320
然后呢 我们这里呢 使用 npm i

18:18.600 --> 18:19.560
横杠地

18:20.200 --> 18:21.000
wip pack

18:21.880 --> 18:23.160
wip pack cd

18:23.720 --> 18:24.840
首先我简示一下啊

18:25.320 --> 18:26.840
这个东西没什么好说的啊 安装

18:27.560 --> 18:31.080
我们安装两个包 一个是wip pack核心包 一个是wip pack cd

18:31.080 --> 18:32.920
啊 都是本地安装 并没有权娶

18:33.160 --> 18:34.840
为什么我要加这个横杠地呢

18:36.040 --> 18:41.080
为什么要是开发一代而不是而不是生产环境的一代呢 你想这个道理

18:42.440 --> 18:47.400
我们生产环境里边 就是我们这最重要运行的是谁 是不是他

18:48.120 --> 18:51.880
他是不是已经构建完成的代码 我们最终运行的是不是他

18:52.520 --> 18:54.520
是不是他已经是构建完成的代码

18:55.320 --> 18:57.240
那么都已经构建完成了

18:57.640 --> 19:02.680
那还还需要 这个在这个阶段啊 就是已经构建完成之后还需要wip pack吗

19:03.160 --> 19:04.760
还需要wip pack参与运行吗

19:05.480 --> 19:09.800
不需要了 对吧 wip pack他只是在构建过程中起作用

19:10.040 --> 19:12.600
他一旦构建完成跟他没关系了

19:13.400 --> 19:17.000
所以说构建的过程呢 是我们在开发阶段才需要的东西

19:17.400 --> 19:21.960
啊 我们开发状态写代码写完了过后呢 通过wip pack构建 构建完了过后呢

19:22.200 --> 19:25.240
就直接可以运行了啊 这个代码就可以直接运行了

19:25.400 --> 19:28.200
一会我们就可以看到了 直接运行 他不需要wip pack了

19:28.520 --> 19:32.760
所以说我们安装wip pack的时候呢 应该使用什么呢 应该使用开发异弹

19:33.320 --> 19:37.400
因为他生产环境里边啊 真正的生产环境里边运行的时候根本就不需要wip pack

19:37.800 --> 19:41.160
所以说怎么来区分开发异弹和生产环境异弹

19:41.160 --> 19:43.080
就是你在运行的时候到底需不需要他

19:43.640 --> 19:45.560
运行的时候不需要他 他就是开发异弹

19:46.200 --> 19:47.160
OK 我们这里回车

19:47.880 --> 19:52.090
安装 稍等一下啊

19:53.050 --> 19:59.370
我也不知道为什么 这个Gatebash啊 这个控制命令行的他总是感觉慢一点

19:59.370 --> 20:01.370
我也不知道为什么

20:01.370 --> 20:03.370
我又不知道为什么 着急一下

20:04.250 --> 20:06.250
他这半天半天反应不过来

20:11.000 --> 20:13.000
稍等一下吧 喝口水

20:21.190 --> 20:24.890
啥意思啊 这不出来了吗

20:29.560 --> 20:31.560
等一下啊 他还没安装完成

20:35.430 --> 20:37.430
停止一下 停止一下 重来

20:37.590 --> 20:38.150
重来

20:46.780 --> 20:49.660
这Gatebash啊 我有的时候他会出现那种情况啊

20:49.660 --> 20:51.180
其实我真的不知道为什么

20:51.660 --> 20:52.540
真的不知道为什么

20:52.940 --> 20:54.460
他就卡住不动了

20:54.460 --> 20:55.100
OK

20:55.580 --> 20:56.860
OK 好了啊 好了

20:57.660 --> 21:01.260
好 那么他告诉你安装了两个wip pack cd和wip pack

21:01.260 --> 21:02.700
你看 是不是40个版本

21:03.020 --> 21:05.740
这个命令行工具呢是3个版本 命令行工具无所谓

21:05.740 --> 21:06.380
主要是这个

21:06.780 --> 21:07.740
我们是wip pack 4

21:08.220 --> 21:11.420
好 那么控制台里边看一下啊 那么他这里边有很多依赖对吧

21:11.420 --> 21:12.780
依赖了一大堆东西啊

21:13.020 --> 21:15.340
当然如果说你用pnpm的安装的话

21:15.340 --> 21:17.340
那么他这里边看不到那么多 乱七八糟的玩意儿

21:17.740 --> 21:19.260
OK 总之呢 你安装好了

21:19.740 --> 21:21.580
安装好了过后呢 你会看到

21:21.580 --> 21:24.300
这个目录下面呢 他给你提供了一个wip pack cd

21:24.620 --> 21:27.260
wip pack这个命令对吧 他提供了这么一个命令

21:27.500 --> 21:29.420
其实这个命令里边他就是调用的是什么

21:29.420 --> 21:30.620
调用的是wip pack的界

21:30.620 --> 21:32.620
wip pack的就是API

21:32.620 --> 21:34.060
咱们不用去管他

21:34.460 --> 21:36.460
好 接下来我们怎么来用了这个wip pack

21:37.580 --> 21:38.460
怎么来用呢

21:38.460 --> 21:39.660
好 接下来我们看使用

21:40.620 --> 21:44.220
使用了方式简单的令人发指

21:44.940 --> 21:46.940
直接一个命令wip pack的玩意儿

21:46.940 --> 21:48.940
他会怎么做呢

21:48.940 --> 21:53.420
他会以src目录下面的index的解释

21:53.420 --> 21:55.420
作为入口文件

21:55.420 --> 21:56.780
我们刚才说不是说了吗

21:56.780 --> 21:57.900
他要分析依赖对吧

21:57.900 --> 21:59.900
他要在开发时代里边分析依赖

21:59.900 --> 22:02.380
那么他一定会要给他一个入口文件来分析

22:02.380 --> 22:04.380
那么这个入口文件他会读谁呢

22:04.380 --> 22:05.660
默认情况下

22:05.660 --> 22:08.780
他会读这个src目录下面的index的解释

22:09.500 --> 22:11.500
也就是说你必须要有这个东西

22:11.500 --> 22:13.500
我们这里的新建设文件是src

22:14.380 --> 22:17.100
那么在这里边的新建设文件也是index的解释

22:17.100 --> 22:19.100
那么就输出一句话吧

22:19.100 --> 22:21.100
Hello

22:21.100 --> 22:23.100
Hello wip pack

22:23.100 --> 22:25.100
就输出这么一句话

22:25.100 --> 22:27.900
那么他就会以这个文件为入口来分析依赖关系

22:27.900 --> 22:29.900
当然我这个文件也没有依赖谁

22:29.900 --> 22:31.900
就一个文件

22:31.900 --> 22:33.900
然后他会做什么呢

22:33.900 --> 22:35.900
他会把这个文件分析完依赖关系过后

22:35.900 --> 22:37.900
最终会打包

22:37.900 --> 22:39.900
是不是打包到这边

22:39.900 --> 22:41.900
形成什么呢

22:41.900 --> 22:43.900
形成最重要运行的

22:43.900 --> 22:45.900
运行环境里边的东西

22:45.900 --> 22:47.900
那么

22:47.900 --> 22:49.900
就是打包结果

22:49.900 --> 22:51.900
他会把打包结果放到哪呢

22:51.900 --> 22:53.900
放到dest的目录

22:53.900 --> 22:55.900
为什么是src

22:55.900 --> 22:57.900
src表示source

22:57.900 --> 22:59.900
代码就是原代码的意思

22:59.900 --> 23:01.900
就是我们开发建设的原代码

23:01.900 --> 23:03.900
dest什么意思

23:03.900 --> 23:05.900
dest表示目标

23:05.900 --> 23:07.900
这种名字

23:07.900 --> 23:09.900
目标是什么

23:09.900 --> 23:11.900
目标门法放到dest目录下面的bondle.js

23:11.900 --> 23:13.900
这个文件中

23:13.900 --> 23:15.900
好来吧

23:15.900 --> 23:17.900
试一下

23:17.900 --> 23:19.900
来

23:19.900 --> 23:21.900
清空一下

23:21.900 --> 23:23.900
直接使用wip pack mini

23:23.900 --> 23:25.900
我们wip pack mini要在哪里运行

23:25.900 --> 23:27.900
注意提示服

23:27.900 --> 23:29.900
你要在你的工程跟目录下面去运行

23:29.900 --> 23:31.900
那么他会读取跟目录下面的src5念甲

23:31.900 --> 23:33.900
下面的index

23:33.900 --> 23:35.900
他肯定要包错了

23:35.900 --> 23:37.900
好

23:37.900 --> 23:39.900
要用什么

23:39.900 --> 23:43.910
npx

23:43.910 --> 23:45.910
完成

23:45.910 --> 23:47.910
完成

23:47.910 --> 23:49.910
那么这里边

23:49.910 --> 23:51.910
很多东西

23:51.910 --> 23:53.910
后边会看

23:53.910 --> 23:55.910
现在不用太多过于关心

23:55.910 --> 23:57.910
那么表示完成了

23:57.910 --> 23:59.910
完成了过后你看

23:59.910 --> 24:01.910
是不是生成一个dest目录

24:01.910 --> 24:03.910
我这里写错了

24:03.910 --> 24:05.910
不是bondle

24:05.910 --> 24:07.910
是madele.js

24:07.910 --> 24:11.990
这个无所谓

24:11.990 --> 24:13.990
他放了madele.js

24:13.990 --> 24:15.990
你看

24:15.990 --> 24:17.990
dest目录下面多了一个js

24:17.990 --> 24:19.990
这madele哪来的

24:19.990 --> 24:21.990
他就通过打包打包了结果

24:21.990 --> 24:23.990
这边我们看一下

24:23.990 --> 24:25.990
为什么会多出这么多代码

24:25.990 --> 24:27.990
我们不只是输出wip pack

24:27.990 --> 24:29.990
我们之后会讲

24:29.990 --> 24:33.990
为什么会多出这么一段代码

24:33.990 --> 24:35.990
其实多的也不多

24:35.990 --> 24:37.990
只多了一点点

24:37.990 --> 24:39.990
那么我们代码在哪

24:39.990 --> 24:41.990
Hello Wip Pack

24:41.990 --> 24:43.990
这就是他们打包的结果

24:43.990 --> 24:45.990
那么打包的结果能不能运行

24:45.990 --> 24:47.990
无论是在流浪期中运行

24:47.990 --> 24:49.990
在dol.js运行里面都可以运行

24:49.990 --> 24:51.990
因为我这里并没有使用到

24:51.990 --> 24:53.990
特殊的流浪期的API

24:53.990 --> 24:55.990
所以说这个代码是通用的

24:55.990 --> 24:57.990
流浪期可以运行这个代码

24:57.990 --> 24:59.990
为dol.js也可以运行这个代码

24:59.990 --> 25:01.990
我们来运行一下

25:01.990 --> 25:03.990
dol.js是运行的

25:03.990 --> 25:05.990
在dol.js运行可以运行

25:05.990 --> 25:07.990
那流浪期能不能运行

25:07.990 --> 25:09.990
流浪期也可以运行

25:09.990 --> 25:11.990
我们在电视里面

25:11.990 --> 25:13.990
比较新建个页面

25:13.990 --> 25:15.990
新建个页面

25:15.990 --> 25:17.990
我们引用一个端GS

25:17.990 --> 25:19.990
GS是什么

25:19.990 --> 25:21.990
MadeleGS

25:21.990 --> 25:23.990
引用

25:23.990 --> 25:25.990
接下来我们运行流浪期

25:25.990 --> 25:27.990
检查

25:27.990 --> 25:29.990
你看是不是一个Hello Wip Pack

25:29.990 --> 25:30.990
就运行的

25:30.990 --> 25:31.990
就这么简单

25:31.990 --> 25:32.990
所以说这种结构

25:32.990 --> 25:33.990
一旦出来过后

25:33.990 --> 25:34.990
你看一下以后

25:34.990 --> 25:35.990
是不是

25:35.990 --> 25:37.990
这个太舒服了

25:37.990 --> 25:38.990
我们以后

25:38.990 --> 25:40.990
我们在开发时代

25:40.990 --> 25:41.990
写哪里的代码

25:41.990 --> 25:43.990
写这个src目录下面的代码

25:43.990 --> 25:45.990
在这里面写代码

25:45.990 --> 25:46.990
写完了过后

25:46.990 --> 25:49.990
我们只要以运行为派个命令

25:49.990 --> 25:50.990
是不是它就会打包

25:50.990 --> 25:52.990
形成最终可以运行的代码

25:52.990 --> 25:54.990
到电视里面

25:54.990 --> 25:55.990
比方说

25:55.990 --> 25:56.990
我们在这里面就可以随便写

25:56.990 --> 25:57.990
随便写

25:57.990 --> 25:58.990
比方说我们这里写啥

25:58.990 --> 26:00.990
写一个

26:00.990 --> 26:02.990
另外一个模块

26:02.990 --> 26:04.990
导出

26:04.990 --> 26:06.990
这里输出

26:06.990 --> 26:08.990
我们先来个输出

26:08.990 --> 26:10.990
输出

26:10.990 --> 26:12.990
叫margeau

26:12.990 --> 26:14.990
margeau

26:14.990 --> 26:16.990
然后

26:16.990 --> 26:18.990
我们在里导出

26:18.990 --> 26:20.990
margeau

26:20.990 --> 26:22.990
in这个式里面导入

26:22.990 --> 26:24.990
require

26:24.990 --> 26:26.990
比方说我们这里都

26:26.990 --> 26:28.990
难得导出了

26:28.990 --> 26:29.990
require表示我们依赖

26:29.990 --> 26:30.990
a模块

26:30.990 --> 26:33.990
a模块里面有依赖b模块

26:33.990 --> 26:35.990
我们这里也要用相对路径

26:35.990 --> 26:36.990
相对路径

26:36.990 --> 26:37.990
a模块

26:37.990 --> 26:42.010
a模块要依赖b模块

26:42.010 --> 26:44.010
b模块

26:44.010 --> 26:47.010
那么 b模块

26:47.010 --> 26:48.010
这里输出

26:48.010 --> 26:51.010
b margeau

26:51.010 --> 26:54.010
margeau b

26:54.010 --> 26:55.010
你看

26:55.010 --> 26:56.010
会不会可以形成一代关系的

26:56.010 --> 26:58.010
我们在开发时代里面

26:58.010 --> 27:00.010
输出部分的写入

27:00.010 --> 27:02.010
论模块

27:02.010 --> 27:04.010
b就依赖c

27:04.010 --> 27:06.010
表示c的模块

27:06.010 --> 27:08.010
我们使用es6的方式来导出

27:08.010 --> 27:10.010
default

27:10.010 --> 27:12.010
c

27:12.010 --> 27:14.010
default

27:14.010 --> 27:16.010
c里面就没东西了

27:16.010 --> 27:18.010
输出

27:18.010 --> 27:20.010
es6

27:20.010 --> 27:22.010
margeau c

27:22.010 --> 27:24.010
b模块是不是可以用

27:24.010 --> 27:28.020
c import

27:28.020 --> 27:30.020
c

27:30.020 --> 27:31.020
b模块

27:31.020 --> 27:32.020
e代c

27:32.020 --> 27:33.020
a模块

27:33.020 --> 27:35.020
e代b

27:35.020 --> 27:37.020
c不e代

27:37.020 --> 27:38.020
index 1代a

27:38.020 --> 27:39.020
是不是就形成1代关系的

27:39.020 --> 27:40.020
eta

27:40.020 --> 27:41.020
index 1代a

27:41.020 --> 27:42.020
e代b

27:42.020 --> 27:43.020
e代c

27:43.020 --> 27:44.020
而且它支持各种模块化

27:44.020 --> 27:45.020
es6模块化

27:45.020 --> 27:47.020
和common.js模块化都行

27:47.020 --> 27:49.020
因为这些东西

27:49.020 --> 27:51.020
它并不会参与运行的

27:51.020 --> 27:53.020
这些东西我们都不会运行的

27:53.020 --> 27:54.020
它会交给谁

27:54.020 --> 27:55.020
交给vipack来处理

27:55.020 --> 27:56.020
比方我们现在打包

27:56.020 --> 27:57.020
再来一次打包

27:57.020 --> 27:58.020
clear

27:58.020 --> 28:00.020
vipack

28:00.020 --> 28:02.020
npx

28:02.020 --> 28:05.170
vipack

28:05.170 --> 28:06.170
打包

28:06.170 --> 28:07.170
打包完了过后你看一下

28:07.170 --> 28:09.170
最终是不是还是只有一个文件

28:09.170 --> 28:11.170
我们明明开发时代

28:11.170 --> 28:12.170
我们写的4个文件

28:12.170 --> 28:13.170
它是不是最终只有一个文件

28:13.170 --> 28:14.170
对吧

28:14.170 --> 28:15.170
只有一个文件

28:15.170 --> 28:16.170
你看一下这个文件里面

28:16.170 --> 28:17.170
是不是有HelloVipack

28:17.170 --> 28:18.170
有Module

28:18.170 --> 28:19.170
AM

28:19.170 --> 28:20.170
对吧

28:20.170 --> 28:21.170
有这个东西

28:21.170 --> 28:23.170
所以有这个东西

28:23.170 --> 28:25.170
那么这里边有没有es6的模块化

28:25.170 --> 28:27.170
有没有common.js模块化

28:27.170 --> 28:28.170
对不起没有

28:29.170 --> 28:30.170
没有

28:30.170 --> 28:32.170
这里边就是普通的ges韩束

28:32.170 --> 28:33.170
它能做到的

28:33.170 --> 28:35.170
也就是为什么会多出这么一些代码

28:35.170 --> 28:36.170
它就是为了

28:36.170 --> 28:40.170
把common.js代码和es6模块化代码

28:40.170 --> 28:41.170
进行一下转换

28:41.170 --> 28:43.170
转换成一个普通的ges韩束

28:43.170 --> 28:44.170
所以说

28:44.170 --> 28:46.170
这种东西它可以通用运行

28:46.170 --> 28:47.170
比方我们这里右键

28:47.170 --> 28:48.170
装扣的

28:48.170 --> 28:49.170
你看

28:49.170 --> 28:50.170
是不是可以运行

28:50.170 --> 28:51.170
node.js没问题

28:51.170 --> 28:53.170
node.js本来不只是es6模块化

28:53.170 --> 28:54.170
仍然可以运行

28:54.170 --> 28:55.170
因为这里边根本就没有

28:55.170 --> 28:56.170
es6模块化

28:56.170 --> 28:57.170
也没有common.js

28:57.170 --> 28:58.170
node.js能不能运行

28:58.170 --> 29:01.170
你看node.js有没有使用到什么type等于

29:01.170 --> 29:02.170
马旧需不需要用这个

29:02.170 --> 29:03.170
不需要

29:03.170 --> 29:05.170
它就是一个普通的ges韩束文件

29:06.170 --> 29:07.170
需不需要用这个

29:07.170 --> 29:08.170
不需要

29:08.170 --> 29:10.170
这个东西还有兼容性问题对吧

29:10.170 --> 29:11.170
就版本node.js还不支持

29:11.170 --> 29:13.170
这个普通的ges韩束文件

29:13.170 --> 29:14.170
肯定可以支持

29:14.170 --> 29:15.170
你看node.js

29:15.170 --> 29:16.170
当然可以运行

29:16.170 --> 29:17.170
因此这就一个好处

29:17.170 --> 29:19.170
就是我们之后开发

29:19.170 --> 29:22.170
就是集中注意力去开发那种

29:22.170 --> 29:23.170
开发时代的东西

29:23.170 --> 29:24.170
怎么方便怎么来

29:24.170 --> 29:25.170
怎么模块化

29:25.170 --> 29:26.170
怎么细分模块怎么来

29:26.170 --> 29:28.170
因为有webhack的存在

29:28.170 --> 29:29.170
所以说我们开发完了过后

29:29.170 --> 29:30.170
以打包

29:30.170 --> 29:31.170
以用webhack打包

29:31.170 --> 29:33.170
它就会生成一个运行时代的东西

29:33.170 --> 29:34.170
运行时代的东西

29:34.170 --> 29:35.170
我们都可以

29:35.170 --> 29:36.170
不用去看看代码

29:36.170 --> 29:37.170
它一定是可以运行的

29:37.170 --> 29:38.170
功能一定是正常的

29:38.170 --> 29:39.170
你只需要在瀏覽器里面

29:39.170 --> 29:41.170
去引用它就行了

29:41.170 --> 29:42.170
所以就非常简单了

29:42.170 --> 29:43.170
对吧

29:43.170 --> 29:44.170
我们再来

29:44.170 --> 29:45.170
第三方库

29:46.170 --> 29:47.170
我们要用get quarry

29:47.170 --> 29:48.170
来吧

29:48.170 --> 29:49.170
get quarry

29:49.170 --> 29:50.170
安装有get quarry

29:51.170 --> 29:52.170
npmi

29:52.170 --> 29:53.170
因为get quarry

29:53.170 --> 29:55.170
这里应该是开发一带

29:55.170 --> 29:58.170
还是生产环境一带

29:58.170 --> 30:00.930
好好想一想

30:00.930 --> 30:01.930
get quarry

30:01.930 --> 30:02.930
应该我们这里安装的时候

30:02.930 --> 30:04.930
开发一带还是生产环境一带

30:04.930 --> 30:05.930
注意

30:05.930 --> 30:08.930
只要要参与最终运行的

30:08.930 --> 30:10.930
它一定是生产环境一带

30:10.930 --> 30:12.930
就是普通一带

30:12.930 --> 30:14.930
不参与最终运行的

30:14.930 --> 30:16.930
那么是开发环境一带

30:16.930 --> 30:17.930
所以搞清楚

30:17.930 --> 30:19.930
因此这个get quarry

30:19.930 --> 30:20.930
要不要参与运行

30:20.930 --> 30:21.930
要

30:21.930 --> 30:22.930
所以说我们这里

30:22.930 --> 30:23.930
就是普通一带了

30:24.930 --> 30:25.930
安装get quarry

30:25.930 --> 30:28.690
我也不知道为啥

30:29.690 --> 30:30.690
他等待半天

30:30.690 --> 30:31.690
OK

30:31.690 --> 30:32.690
那么安装好了

30:32.690 --> 30:33.690
get quarry的

30:33.690 --> 30:34.690
这里边有get quarry的

30:34.690 --> 30:35.690
我拿它去看了

30:35.690 --> 30:36.690
比方我们C里边

30:36.690 --> 30:37.690
它要用到get quarry

30:37.690 --> 30:38.690
来吧

30:38.690 --> 30:40.690
我们用什么呢

30:40.690 --> 30:43.690
用import $ fromget quarry

30:43.690 --> 30:44.690
get quarry

30:44.690 --> 30:45.690
我们刚才之前

30:45.690 --> 30:46.690
给大家演示过

30:46.690 --> 30:47.690
它是用common介石写的

30:47.690 --> 30:48.690
对吧

30:48.690 --> 30:49.690
是用common介石写的

30:49.690 --> 30:50.690
用common介石写的

30:50.690 --> 30:51.690
居然可以用

30:51.690 --> 30:53.690
es6的模块导入进来

30:53.690 --> 30:54.690
所以

30:54.690 --> 30:56.690
因为wepack全部会处理这些问题

30:56.690 --> 30:57.690
交给wepack来处理

30:57.690 --> 30:58.690
具体怎么处理的

30:58.690 --> 30:59.690
我们后面会说

30:59.690 --> 31:01.690
比方我们输出这个多了

31:01.690 --> 31:02.690
看一下能不能输出呢

31:02.690 --> 31:04.690
能不能输出一个多了呢

31:04.690 --> 31:05.690
保存

31:05.690 --> 31:06.690
好 接下来

31:06.690 --> 31:09.190
我再问一下大家

31:09.190 --> 31:11.190
再问一下这个问题

31:11.190 --> 31:12.190
大家理解没有

31:12.190 --> 31:13.190
这个代码会不会参与

31:13.190 --> 31:14.190
最终运行

31:14.190 --> 31:15.190
这个代码会不会参与

31:15.190 --> 31:16.190
最终运行

31:17.190 --> 31:18.190
不会

31:18.190 --> 31:19.190
不会

31:19.190 --> 31:21.190
它会交给wepack进行打包

31:21.190 --> 31:22.190
这个东西是交给wepack来分析

31:22.190 --> 31:23.190
一带关系的

31:23.190 --> 31:24.190
好 接下来我们来看

31:25.190 --> 31:27.190
wepack运行

31:27.190 --> 31:28.190
打包

31:28.190 --> 31:29.190
重新打包一次

31:31.190 --> 31:32.190
打包完成

31:32.190 --> 31:34.190
打包完成了过后

31:34.190 --> 31:35.190
你不看到

31:35.190 --> 31:37.190
Media介石里边东西多了很多了

31:37.190 --> 31:38.190
对吧

31:38.190 --> 31:39.190
因为他发现了

31:39.190 --> 31:40.190
他依赖接宽瑞

31:40.190 --> 31:41.190
他又会把接宽瑞的内容

31:41.190 --> 31:42.190
全部加进来

31:42.190 --> 31:43.190
因此

31:43.190 --> 31:44.190
他就是一个普通的介石文件

31:44.190 --> 31:45.190
接下来我们来看一下

31:45.190 --> 31:47.190
接宽瑞能不能输出

31:47.190 --> 31:48.190
是不是能输出

31:48.190 --> 31:49.190
这不就是

31:49.190 --> 31:50.190
接宽瑞的函数吗

31:50.190 --> 31:51.190
对吧

31:51.190 --> 31:52.190
能输出

31:52.190 --> 31:53.190
因此这里可以大胆的

31:53.190 --> 31:54.190
使用接宽瑞

31:54.190 --> 31:57.190
这就让我们以后在开发阶段

31:57.190 --> 31:59.190
就是在我们开发的时代

31:59.190 --> 32:00.190
开发的时候

32:00.190 --> 32:02.190
不用去关心什么模块化

32:02.190 --> 32:03.190
兼容那些问题

32:03.190 --> 32:05.190
因为wepack全部兼容

32:05.190 --> 32:06.190
随便你怎么写

32:06.190 --> 32:08.190
你看NPM是不可以使用的

32:08.190 --> 32:09.190
NPM是可以使用的

32:09.190 --> 32:11.190
这东西全部会交给wepack来处理

32:11.190 --> 32:12.190
wepack一看

32:12.190 --> 32:14.190
你这里依赖接宽瑞

32:14.190 --> 32:15.190
而且这个接宽瑞

32:15.190 --> 32:16.190
你没有加点鞋杠

32:16.190 --> 32:17.190
对吧

32:17.190 --> 32:18.190
wepack会进行分析的

32:18.190 --> 32:19.190
这些分析不是用load介石分析

32:19.190 --> 32:21.190
它是用wepack来进行分析的

32:21.190 --> 32:22.190
他会发现

32:22.190 --> 32:23.190
你这里没有加点鞋杠

32:23.190 --> 32:24.190
说明啥呢

32:24.190 --> 32:25.190
说明你这个依赖

32:25.190 --> 32:27.190
应该在loadmarch 90目录下面

32:27.190 --> 32:28.190
他就会从这里边去找

32:28.190 --> 32:30.190
找到这个接宽瑞的文件

32:30.190 --> 32:31.190
找到过后

32:31.190 --> 32:32.190
又把他那个文件

32:32.190 --> 32:33.190
又分析依赖关系

32:33.190 --> 32:34.190
如果他没有什么依赖关系

32:34.190 --> 32:35.190
OK

32:35.190 --> 32:36.190
把他那个文件

32:36.190 --> 32:37.190
又形成打包结果

32:37.190 --> 32:40.190
它会放到最终的结果里边

32:40.190 --> 32:42.190
这个最终的生存的文件里边

32:42.190 --> 32:44.190
你不用去看它里边写的是啥

32:44.190 --> 32:46.190
总之这个最终的结果文件里边

32:46.190 --> 32:47.190
它就包含了

32:47.190 --> 32:48.190
所有你要运行的代码

32:48.190 --> 32:49.190
而且都是一个一个

32:49.190 --> 32:51.190
非常普通的介石函数

32:52.190 --> 32:53.190
不会存在什么

32:53.190 --> 32:54.190
common.js

32:54.190 --> 32:55.190
不会存在什么

32:55.190 --> 32:56.190
ES6模块化

32:56.190 --> 32:57.190
根本就不会存在

32:58.190 --> 32:59.190
它就可以直接运行

33:00.190 --> 33:01.190
听懂了这个意思

33:02.190 --> 33:03.190
这就是

33:03.190 --> 33:04.190
以后的我们开发的好处

33:04.190 --> 33:06.190
我们开发就会集中精力开发

33:06.190 --> 33:07.190
第一层的目录

33:07.190 --> 33:08.190
管都不用管

33:08.190 --> 33:09.190
只要去

33:09.190 --> 33:10.190
我们要做的事情就是

33:10.190 --> 33:11.190
把这个地方写好了过后

33:11.190 --> 33:12.190
运行一下命令

33:12.190 --> 33:13.190
什么

33:13.190 --> 33:14.190
npx,vipack

33:15.190 --> 33:16.190
当然平时呢

33:16.190 --> 33:17.190
我们用很多时候

33:17.190 --> 33:18.190
也会这样来做

33:18.190 --> 33:19.190
就是

33:20.190 --> 33:21.190
我们会在这个

33:21.190 --> 33:22.190
pack.json里边

33:22.190 --> 33:23.190
我们以前学过脚本

33:23.190 --> 33:24.190
对吧

33:24.190 --> 33:25.190
大家这里去配置一些脚本

33:25.190 --> 33:26.190
比方说我们配这个build

33:26.190 --> 33:27.190
打包

33:27.190 --> 33:28.190
打包里边

33:28.190 --> 33:29.190
我们去运行什么

33:29.190 --> 33:30.190
vipack

33:30.190 --> 33:31.190
那么这样子呢

33:31.190 --> 33:32.190
我们可以使用一个统一的命令

33:33.190 --> 33:34.190
npx

33:34.190 --> 33:36.190
npmron build

33:36.190 --> 33:38.190
build就构建

33:38.190 --> 33:39.190
构建

33:39.190 --> 33:41.190
这个名字怎么这么骚呢

33:41.190 --> 33:42.190
构建

33:42.190 --> 33:43.190
构建

33:43.190 --> 33:44.190
就是

33:44.190 --> 33:45.190
打包

33:45.190 --> 33:46.190
那么它就是

33:46.190 --> 33:47.190
那么相当于运行这个

33:47.190 --> 33:48.190
相当于是运行的

33:48.190 --> 33:49.190
现在这些东西

33:49.190 --> 33:50.190
这些信息不用管

33:50.190 --> 33:51.190
不用管

33:51.190 --> 33:52.190
我们之后会说

33:52.190 --> 33:53.190
那么我完成打包

33:53.190 --> 33:54.190
我们开发

33:54.190 --> 33:55.190
开发完了过后

33:55.190 --> 33:56.190
运行一下这个命令

33:56.190 --> 33:57.190
完成打包就完事了

33:57.190 --> 33:59.190
它就可以直接运行了

33:59.190 --> 34:00.190
这样子就把

34:00.190 --> 34:02.190
把我们开发时态

34:02.190 --> 34:03.190
和运行时态

34:03.190 --> 34:04.190
彻底的分开了

34:04.190 --> 34:06.190
我们开发的时候

34:06.190 --> 34:07.190
开发者不用去关心

34:07.190 --> 34:09.190
运行时态的东西

34:09.190 --> 34:10.190
我们只关注

34:10.190 --> 34:11.190
开发时态里边

34:11.190 --> 34:12.190
代码的優雅度

34:12.190 --> 34:13.190
可维护性

34:13.190 --> 34:15.190
只关心这些东西就行了

34:15.190 --> 34:17.190
剩下的东西交给vipack

34:18.190 --> 34:19.190
那么这些可能

34:19.190 --> 34:20.190
我们再说一个

34:20.190 --> 34:22.190
再说一个额外的内容

34:22.190 --> 34:23.190
这个内容也很简单

34:23.190 --> 34:25.190
我们再大概说一下

34:25.190 --> 34:26.190
就说我们刚才

34:26.190 --> 34:27.190
运行这个vipack的时候

34:27.190 --> 34:29.190
它其实跟我们的一个警告

34:29.190 --> 34:30.190
叫做warding

34:30.190 --> 34:32.190
inconfiguration

34:32.190 --> 34:34.190
在那边

34:34.190 --> 34:35.190
它什么意思呢

34:35.190 --> 34:36.190
它就说

34:36.190 --> 34:38.190
我们这里运行的vipack

34:38.190 --> 34:40.190
缺少一个参数

34:40.190 --> 34:41.190
叫做mod

34:41.190 --> 34:43.190
缺少这么一个参数

34:43.190 --> 34:45.190
这个参数干嘛的呢

34:45.190 --> 34:47.190
这个参数可以表示的是

34:47.190 --> 34:49.190
你打包的时候

34:49.190 --> 34:50.190
就打包完了

34:50.190 --> 34:51.190
不是有个结果吗

34:51.190 --> 34:53.190
这个结果

34:53.190 --> 34:56.190
是在生产环境运行

34:56.190 --> 34:58.190
还是在开发环境运行

34:58.190 --> 35:00.190
是这么个意思

35:00.190 --> 35:01.190
有些人搞晕了

35:01.190 --> 35:03.190
也不说这边是开发环境

35:03.190 --> 35:04.190
这边不叫开发环境

35:04.190 --> 35:05.190
这叫开发阶段

35:05.190 --> 35:06.190
这是我们写代码的时候

35:06.190 --> 35:08.190
写代码的阶段

35:08.190 --> 35:09.190
那么我们写完代码

35:09.190 --> 35:10.190
是不是要测试一下

35:10.190 --> 35:11.190
我们写的代码

35:11.190 --> 35:12.190
这么正确

35:12.190 --> 35:13.190
是不是要运行

35:13.190 --> 35:14.190
运行是不是要打包

35:14.190 --> 35:15.190
你不能直接运行这个代码

35:15.190 --> 35:16.190
要通过vipack打包

35:16.190 --> 35:17.190
打包了过后

35:17.190 --> 35:18.190
是不是才能运行

35:18.190 --> 35:20.190
那么这个运行

35:20.190 --> 35:22.190
是在开发阶段

35:22.190 --> 35:24.190
还是在生产环境

35:24.190 --> 35:25.190
什么意思

35:25.190 --> 35:26.190
就说如果说

35:26.190 --> 35:28.190
你的代码全部写完了

35:28.190 --> 35:29.190
就是我们的功能

35:29.190 --> 35:31.190
已经全部实现了

35:31.190 --> 35:32.190
全部实现了

35:32.190 --> 35:33.190
我打包完了的代码

35:33.190 --> 35:34.190
就打包了代码

35:34.190 --> 35:36.190
我们可能要放到服务器

35:36.190 --> 35:37.190
比方说我们

35:37.190 --> 35:38.190
以后呢部署到服务器

35:38.190 --> 35:39.190
部署哪一个

35:39.190 --> 35:40.190
肯定是不是部署

35:40.190 --> 35:41.190
这一个

35:41.190 --> 35:42.190
肯定上传到服务器

35:42.190 --> 35:43.190
上传的不是这个

35:43.190 --> 35:44.190
上传的是这一部分

35:44.190 --> 35:46.190
这才是我们要运行的东西

35:46.190 --> 35:47.190
上传的是这一部分

35:47.190 --> 35:48.190
所以说

35:48.190 --> 35:49.190
我们要上传

35:49.190 --> 35:50.190
我们的代码呢

35:50.190 --> 35:52.190
是不是已经全部写完了

35:52.190 --> 35:53.190
要上传到服务器

35:53.190 --> 35:54.190
如果说要这个代码

35:54.190 --> 35:56.190
要放到服务器去运行的话

35:56.190 --> 35:58.190
那么代码要处于生产环境

35:58.190 --> 36:00.190
你在这个意思吗

36:00.190 --> 36:02.190
他要到服务器去运行

36:02.190 --> 36:04.190
那么还有一种情况

36:04.190 --> 36:05.190
就是我的代码

36:05.190 --> 36:06.190
还没有写完

36:06.190 --> 36:07.190
只是写了一点点

36:07.190 --> 36:08.190
我们要测试一下

36:08.190 --> 36:09.190
它的功能这么正确

36:09.190 --> 36:10.190
是不是也在运行

36:10.190 --> 36:11.190
那么也在运行

36:11.190 --> 36:13.190
是不是也在打包

36:13.190 --> 36:16.190
我们刚才写了一些测试

36:16.190 --> 36:17.190
功能肯定没有写完

36:17.190 --> 36:19.190
但是我们要运行看一下效果

36:19.190 --> 36:21.190
那么这个时候是不是也在打包

36:21.190 --> 36:23.190
也通过微派的打包

36:23.190 --> 36:24.190
打包完了过

36:24.190 --> 36:26.190
那么这个时候运行的时候

36:26.190 --> 36:27.190
是什么

36:27.190 --> 36:28.190
是开发环境

36:28.190 --> 36:30.190
是我们在测试的时候才运行

36:30.190 --> 36:31.190
听到这个意思吗

36:31.190 --> 36:33.190
就是我们最终生成的代码

36:33.190 --> 36:34.190
它也有运行环境

36:34.190 --> 36:36.190
它有可能是在开发环境里面运行

36:36.190 --> 36:38.190
只是我们做一些测试

36:38.190 --> 36:39.190
做一些调试

36:39.190 --> 36:41.190
看我们的功能这么正确

36:41.190 --> 36:42.190
不正确我们还要改

36:42.190 --> 36:43.190
还要改动这一面代码

36:43.190 --> 36:45.190
改动了过后重新打包

36:45.190 --> 36:46.190
重新再测试

36:46.190 --> 36:47.190
还有一种情况就是

36:47.190 --> 36:48.190
我们已经写完了

36:48.190 --> 36:49.190
已经测试了没问题了

36:49.190 --> 36:50.190
打包完了过后

36:50.190 --> 36:52.190
这些代码就是要放到服务器上运行的

36:52.190 --> 36:53.190
那就是生产环境

36:53.190 --> 36:55.190
那么它这里的说的意思就是说

36:55.190 --> 36:57.190
它要问你

36:57.190 --> 36:59.190
你这个打包出来的结果

36:59.190 --> 37:02.190
到底要在哪个环境里面运行

37:02.190 --> 37:04.190
如果说你要在生产环境里面运行

37:04.190 --> 37:06.190
就这个代码要在生产环境

37:06.190 --> 37:08.190
就是要部署到服务器运行的话

37:08.190 --> 37:10.190
那么它会给你做一些优化

37:10.190 --> 37:12.190
比方说压缩

37:12.190 --> 37:14.190
就是尽量的减少体积

37:14.190 --> 37:16.190
这些东西是不是要进行优化

37:16.190 --> 37:18.190
如果说你是在开发环境里面运行的话

37:18.190 --> 37:20.190
那么它会尽量让你调试起来

37:20.190 --> 37:21.190
方便一点

37:21.190 --> 37:23.190
至于怎么方便

37:23.190 --> 37:24.190
我们后面会说不着急

37:24.190 --> 37:26.190
总之它要区分一下你这个代码

37:26.190 --> 37:28.190
生产出来的代码的运行环境

37:28.190 --> 37:29.190
听懂了吗

37:29.190 --> 37:30.190
它要区分你这个代码

37:30.190 --> 37:31.190
你这个运行的代码

37:31.190 --> 37:33.190
它的运行环境是什么

37:33.190 --> 37:35.190
它这里报的警告就是这么个意思

37:35.190 --> 37:36.190
它告诉你

37:36.190 --> 37:38.190
它现在不知道你的环境是什么

37:38.190 --> 37:40.190
那么它默认

37:40.190 --> 37:43.190
它认为你是生产环境

37:43.190 --> 37:44.190
那么怎么

37:44.190 --> 37:45.190
因此它报了这么一个警告

37:45.190 --> 37:47.190
它说你最好给我指定一下

37:47.190 --> 37:48.190
告诉我一下

37:48.190 --> 37:49.190
我生产出来的这个结果

37:49.190 --> 37:51.190
到底是一个什么环境

37:51.190 --> 37:52.190
那么怎么来告诉呢

37:52.190 --> 37:53.190
非常简单

37:53.190 --> 37:56.190
通过一个命令

37:56.190 --> 37:58.190
NPX Webpack

37:58.190 --> 38:00.190
里面有个参数叫做MOD

38:00.190 --> 38:02.190
MOD就是模式

38:02.190 --> 38:04.190
给它配置

38:04.190 --> 38:07.190
如果说你给它等于一个Development

38:07.190 --> 38:08.190
只有这么几个单词

38:08.190 --> 38:10.190
一个是Development

38:10.190 --> 38:11.190
这个单词还要记住

38:11.190 --> 38:12.190
写得非常熟悉

38:12.190 --> 38:15.190
就表示你这是生产环境

38:15.190 --> 38:17.190
就表示你是开发环境

38:17.190 --> 38:18.190
你看一下

38:18.190 --> 38:19.190
我用这种模式打包出来

38:19.190 --> 38:21.190
一看结果都不一样

38:21.190 --> 38:23.190
也打包完成了

38:23.190 --> 38:25.190
看现在是不是没有警告了

38:25.190 --> 38:26.190
没有警告了

38:26.190 --> 38:27.190
这些东西我们后面会说

38:27.190 --> 38:28.190
你看一下

38:28.190 --> 38:29.190
这边

38:29.190 --> 38:31.190
密条件是什么不一样

38:31.190 --> 38:33.190
代码会感觉格式

38:33.190 --> 38:35.190
舒服了很多

38:36.190 --> 38:37.190
那么这个格式

38:37.190 --> 38:38.190
是不是舒服了很多

38:38.190 --> 38:39.190
对不对

38:39.190 --> 38:41.190
舒服了很多很多

38:41.190 --> 38:43.190
这就是它的格式

38:43.190 --> 38:45.190
那么有了这种格式的话

38:45.190 --> 38:47.190
就方便我们调试

38:47.190 --> 38:48.190
至于怎么方便调试

38:48.190 --> 38:50.190
我们后面会说不着急

38:50.190 --> 38:52.190
只要开发环境是不一样的

38:52.190 --> 38:54.190
还有很多注释

38:54.190 --> 38:56.190
好 接下来我们再来看一下

38:56.190 --> 38:58.190
如果说我用

38:58.190 --> 39:00.190
默认的就是Production

39:00.190 --> 39:01.190
Production表示什么意思

39:01.190 --> 39:02.190
生产环境

39:02.190 --> 39:04.190
Production表示产品的意思

39:04.190 --> 39:05.190
生产环境

39:05.190 --> 39:06.190
那么表示我们代码

39:06.190 --> 39:08.190
最终运行的环境

39:08.190 --> 39:10.190
就是要服务器运行了

39:10.190 --> 39:11.190
那么这个时候

39:11.190 --> 39:13.190
它打包出来的结果不太一样的

39:13.190 --> 39:14.190
你看

39:14.190 --> 39:15.190
打包出来的结果

39:15.190 --> 39:17.190
就是我们之前的结果

39:17.190 --> 39:18.190
之前的这种结果

39:18.190 --> 39:19.190
看都看不懂的

39:19.190 --> 39:20.190
它不要求你看懂

39:20.190 --> 39:22.190
它只要能运行就行了

39:22.190 --> 39:25.190
这就是两种环境的打包方式

39:25.190 --> 39:27.190
这是必须要指定的

39:27.190 --> 39:29.190
因此我们通常会怎么做

39:29.190 --> 39:32.190
我们通常也会这样子来处理

39:32.190 --> 39:35.190
就是我们在脚本里边

39:35.190 --> 39:37.190
可以配置两个

39:37.190 --> 39:38.190
一个是Build

39:38.190 --> 39:40.190
这个表示生产环境

39:40.190 --> 39:41.190
我们这里加上一个Mode

39:41.190 --> 39:43.190
等于Production

39:44.190 --> 39:47.190
然后再加上一个Dev

39:47.190 --> 39:50.190
表示开发环境的打包

39:50.190 --> 39:51.190
Mode

39:53.190 --> 39:55.190
Development

39:56.190 --> 39:58.190
这两个当时也得记住

39:59.190 --> 40:01.190
那么之后就很方便了

40:02.190 --> 40:04.190
你看NPM脚本就起这么一个作用

40:04.190 --> 40:06.190
我们不用去记得那些乱七八糟的命令

40:06.190 --> 40:07.190
只需要能用同一的就行了

40:07.190 --> 40:09.190
NPM RunBuild

40:09.190 --> 40:10.190
那就肯定是生产环境

40:10.190 --> 40:12.190
打包出来一定是生产环境

40:12.190 --> 40:13.190
你看

40:13.190 --> 40:14.190
生产环境

40:14.190 --> 40:16.190
如果说我们使用

40:17.190 --> 40:19.190
NPM RunDev

40:19.190 --> 40:22.190
那么打包出来一定是开发环境

40:23.190 --> 40:24.190
厉害

40:25.190 --> 40:27.190
看就是开发环境

40:28.190 --> 40:30.190
这就是Webhack的打包

40:30.190 --> 40:32.190
体验一下它的安装

40:32.190 --> 40:33.190
以及它的打包过程

40:34.190 --> 40:36.190
这些靠的东西好好去评一下

40:36.190 --> 40:38.190
什么叫做Webhack

40:38.190 --> 40:40.190
它要在Lode环境里面执行

40:40.190 --> 40:41.190
这个该怎么去理解

40:41.190 --> 40:43.190
指的是这一部分

40:43.190 --> 40:46.190
打包的过程需要Lode环境

40:46.190 --> 40:48.190
并不说你的代码必须要在Lode环境

40:48.190 --> 40:50.190
不是这个意思

40:50.190 --> 40:51.190
我们运行的是什么

40:51.190 --> 40:52.190
运行的是这个

40:52.190 --> 40:53.190
运行的根本不是这个

40:53.190 --> 40:56.190
尽管这边的东西跟它的功能是一样的

40:56.190 --> 40:59.190
但是它运行的实际上是这边的东西

40:59.190 --> 41:04.190
什么叫做开发环境和生产环境

41:04.190 --> 41:08.190
指的是最终的代码是运行的环境是什么

41:08.190 --> 41:09.190
一定要理解清楚这个

41:09.190 --> 41:12.190
不然学到学到就学晕了

41:12.190 --> 41:14.190
这是这几课咱们要讲的东西

41:14.190 --> 41:16.190
我讲可能是讲的比较细的

41:16.190 --> 41:18.190
因为我知道很多学生有些东西

41:18.190 --> 41:19.190
他理解不清楚

41:19.190 --> 41:21.190
所以说我把也不清楚的地方

41:21.190 --> 41:22.190
来给大家讲清楚

