WEBVTT

00:00.690 --> 00:07.690
这一张内容特别多

00:07.690 --> 00:14.690
而且讲的某一些内容又特别细致

00:14.690 --> 00:16.690
细致到什么程度呢

00:16.690 --> 00:19.690
细致到有些地方你们根本就想不到会有这样的问题

00:19.690 --> 00:21.690
那么都要去解决

00:21.690 --> 00:24.690
所以说这一张可能复杂度来说

00:24.690 --> 00:27.690
应该是比较高的

00:27.690 --> 00:29.690
我之前想了又想

00:29.690 --> 00:33.690
我说这一张能不能作为一个扩展章节呢

00:33.690 --> 00:35.690
想了一想好像又不行

00:35.690 --> 00:36.690
为啥呢

00:36.690 --> 00:40.690
因为你们以后虽然说本张的内容呢

00:40.690 --> 00:44.690
不太会在实际的开发中应用到

00:44.690 --> 00:46.690
因为你们刚刚出于工作嘛

00:46.690 --> 00:48.690
一开始的话

00:48.690 --> 00:50.690
很多东西都给你配好了的

00:50.690 --> 00:52.690
连未拍可能你们以后出去了

00:52.690 --> 00:54.690
一开始工作的时候都不会太接触到

00:54.690 --> 00:56.690
更不要说性能优化了

00:56.690 --> 00:59.690
另外很多时候性能优化是

00:59.690 --> 01:03.690
往往是在项目的尾声的时候

01:03.690 --> 01:05.690
在测试的阶段发现某一些地方

01:05.690 --> 01:08.690
确实有一些性能问题需要去处理的

01:08.690 --> 01:12.690
因此你性能优化这一块呢

01:12.690 --> 01:15.690
在实际的开发中帮助不大

01:15.690 --> 01:19.690
但是它有可能在面试的时候可能会问道理

01:19.690 --> 01:22.690
因为你要去跟很多的

01:22.690 --> 01:24.690
市面上的很多开发者去竞争

01:24.690 --> 01:26.690
竞争这个岗位

01:26.690 --> 01:28.690
那么其他开发者可能有了一两年的

01:28.690 --> 01:30.690
工作经验

01:30.690 --> 01:32.690
他肯定会遇到一些性能的问题

01:32.690 --> 01:33.690
所以说呢

01:33.690 --> 01:35.690
面试官为了考虑

01:35.690 --> 01:37.690
有没有这一方面的经验

01:37.690 --> 01:39.690
可能会问道理性能优化这一块的问题

01:39.690 --> 01:40.690
所以说呢

01:40.690 --> 01:42.690
这一张也不能作为扩展课程

01:42.690 --> 01:43.690
什么样扩展课程

01:43.690 --> 01:44.690
就是你可以看

01:44.690 --> 01:46.690
也可以不看

01:46.690 --> 01:49.690
那么这一张怎么来学习呢

01:49.690 --> 01:51.690
还是老生常谈的

01:51.690 --> 01:53.690
就是说你呢

01:53.690 --> 01:56.690
你要知道出现了哪些问题

01:56.690 --> 01:57.690
这些问题呢

01:57.690 --> 02:00.690
我们大概的解决思路是什么样子

02:00.690 --> 02:02.690
可能你这一张学完了

02:02.690 --> 02:03.690
连这个东西都记不住

02:03.690 --> 02:05.690
记不住也没有关系

02:05.690 --> 02:08.690
你有那么一点点印象就行了

02:08.690 --> 02:10.690
以后呢在面试之前呢

02:10.690 --> 02:12.690
稍微的复习一下

02:12.690 --> 02:14.690
看一下我这里给大家的思维导徒

02:14.690 --> 02:15.690
看一下相关的课件

02:15.690 --> 02:16.690
也不用同意看视频呢

02:16.690 --> 02:19.690
大概了了解一下也就够了

02:19.690 --> 02:20.690
来对付一下面试

02:20.690 --> 02:21.690
另外呢

02:21.690 --> 02:23.690
如果说你们以后在工作中

02:23.690 --> 02:25.690
确实遇到了一些性能问题

02:25.690 --> 02:26.690
需要处理

02:26.690 --> 02:28.690
我们这一张会设计得比较全

02:28.690 --> 02:29.690
因此呢

02:29.690 --> 02:31.690
你肯定可以再做一张

02:31.690 --> 02:32.690
不说肯定吧

02:32.690 --> 02:33.690
百分之九十以上

02:33.690 --> 02:35.690
你都可以在这一张

02:35.690 --> 02:37.690
找到解决的办法

02:37.690 --> 02:38.690
所以说这一张出

02:38.690 --> 02:39.690
出现的目的

02:39.690 --> 02:41.690
一是为了面试

02:41.690 --> 02:42.690
二是为了今后

02:42.690 --> 02:43.690
开发了你可能

02:43.690 --> 02:44.690
工作了一两年过后

02:44.690 --> 02:46.690
遇到了一些性能的问题

02:46.690 --> 02:47.690
需要解决

02:47.690 --> 02:48.690
需要处理

02:48.690 --> 02:49.690
OK

02:49.690 --> 02:50.690
那么回到这一张

02:50.690 --> 02:51.690
相关的章节

02:51.690 --> 02:52.690
看一下思维导徒

02:52.690 --> 02:53.690
看一下课件

02:53.690 --> 02:54.690
能不能帮助你

02:54.690 --> 02:56.690
解决这样的问题

02:56.690 --> 02:58.690
那么目前我们在学习阶段

02:58.690 --> 02:59.690
学习这一张的时候

02:59.690 --> 03:01.690
把一个什么样的心态呢

03:01.690 --> 03:04.690
就建立一个

03:04.690 --> 03:05.690
看故事

03:05.690 --> 03:07.690
看热了

03:07.690 --> 03:09.690
看小说这么一个心态

03:09.690 --> 03:10.690
看一看

03:10.690 --> 03:11.690
甚至呢

03:11.690 --> 03:12.690
我都不要求大家

03:12.690 --> 03:13.690
下来去练一遍

03:13.690 --> 03:14.690
我都不要求

03:14.690 --> 03:15.690
因为

03:15.690 --> 03:17.690
有些东西确实太细了

03:17.690 --> 03:18.690
太细致了

03:18.690 --> 03:19.690
所以说这一块

03:19.690 --> 03:21.690
大家心态放轻松

03:21.690 --> 03:22.690
大家放心

03:22.690 --> 03:24.690
我们这一张的考试题

03:24.690 --> 03:26.690
也会比较简单

03:26.690 --> 03:27.690
你只要把整个课程

03:27.690 --> 03:28.690
完整听一遍

03:28.690 --> 03:30.690
你肯定是能够做出来的

03:30.690 --> 03:31.690
哪怕对照思维导徒

03:31.690 --> 03:32.690
对照课件

03:32.690 --> 03:34.690
你也是能够做出来的

03:34.690 --> 03:35.690
不要有什么心理压力

03:35.690 --> 03:36.690
这一张的内容

03:36.690 --> 03:37.690
比较多

03:37.690 --> 03:38.690
看热了

03:38.690 --> 03:39.690
玩一玩

03:39.690 --> 03:40.690
其实也挺有的时候

03:40.690 --> 03:41.690
你会发现

03:41.690 --> 03:42.690
有一些细节

03:42.690 --> 03:43.690
我们平时都没有考虑的

03:43.690 --> 03:45.690
欧元的软件开发里边

03:45.690 --> 03:47.690
还有这些细节要考虑

03:47.690 --> 03:48.690
你会发现

03:48.690 --> 03:50.690
这个世界之大

03:50.690 --> 03:52.690
也是蛮令人惊奇的

03:52.690 --> 03:54.690
所以说给大家灌一点鸡汤

03:54.690 --> 03:58.060
不要有太大的心理压力

03:58.060 --> 04:01.060
因为我为什么老是去说这些问题呢

04:01.060 --> 04:03.060
我老怕同学们学习的时候

04:03.060 --> 04:04.060
就感觉

04:04.060 --> 04:06.060
快要英勇就义

04:06.060 --> 04:07.060
很多同学学的时候

04:07.060 --> 04:09.060
你看我在线下上课的时候

04:09.060 --> 04:11.060
就老是这种感觉

04:11.060 --> 04:13.060
每次要讲到一些复杂的问题

04:13.060 --> 04:15.060
有些同学就直接睡着了

04:15.060 --> 04:16.060
我把他叫起来

04:16.060 --> 04:17.060
有些同学呢

04:17.060 --> 04:18.060
在认真听

04:18.060 --> 04:19.060
但是呢

04:19.060 --> 04:21.060
总感觉一副苦大仇生的样子

04:21.060 --> 04:23.060
这种学习状态不太好

04:23.060 --> 04:24.060
我觉得学习呢

04:24.060 --> 04:26.060
无论你遇到多么复杂的事情

04:26.060 --> 04:28.060
心态上至少要轻松一点

04:28.060 --> 04:29.060
对吧

04:29.060 --> 04:31.060
战略上表示他

04:31.060 --> 04:33.060
战术上重视他

04:33.060 --> 04:35.060
保持这么一个良好的心态

04:35.060 --> 04:36.060
再复杂的问题呢

04:36.060 --> 04:39.060
也总归能解决了

04:39.060 --> 04:40.060
现在解决不了

04:40.060 --> 04:41.060
现在我们看个热闹就行了

04:42.060 --> 04:43.060
性能优化

04:43.060 --> 04:45.060
我们上节课说了

04:45.060 --> 04:47.060
性能优化这一块呢

04:47.060 --> 04:48.060
有三个方面

04:48.060 --> 04:49.060
哪三个方面呢

04:49.060 --> 04:51.060
第一个是

04:51.060 --> 04:53.060
构建性的

04:53.060 --> 04:55.060
什么要构建性的

04:55.060 --> 04:58.060
它是影响我们的开发效率

04:58.060 --> 05:00.060
你每一次打个包

05:00.060 --> 05:01.060
花几十分钟

05:01.060 --> 05:02.060
或者是一两分钟

05:02.060 --> 05:03.060
我受不了

05:03.060 --> 05:04.060
根本就受不了

05:04.060 --> 05:06.060
那么这个开发效率太低了

05:06.060 --> 05:07.060
因为我们开发的过程中

05:07.060 --> 05:09.060
肯定是不断的打包的

05:09.060 --> 05:11.060
改良两行代码要打包一次

05:11.060 --> 05:12.060
所以说呢

05:12.060 --> 05:16.060
构建性能主要是影响开发阶段

05:16.060 --> 05:17.060
生产环境

05:17.060 --> 05:19.060
存不存在什么构建性能

05:19.060 --> 05:20.060
根本就不存在

05:20.060 --> 05:22.060
生产环境可能一周打包一次

05:22.060 --> 05:23.060
那存在什么构建性能呢

05:23.060 --> 05:25.060
打包两分就打包两分钟

05:25.060 --> 05:26.060
所以说这个构建性能

05:26.060 --> 05:29.060
我们只关注开发阶段

05:29.060 --> 05:30.060
而这构建性能

05:30.060 --> 05:32.060
时间越短越好

05:32.060 --> 05:33.060
这样子呢

05:33.060 --> 05:34.060
我们开发起来就比较流畅

05:34.060 --> 05:35.060
比较舒服

05:35.060 --> 05:37.060
不要小看这个东西

05:37.060 --> 05:39.060
你比方说你一个小时

05:39.060 --> 05:42.060
你构建个二十次

05:42.060 --> 05:43.060
不多吧

05:43.060 --> 05:44.060
构建二十次

05:44.060 --> 05:45.060
其实肯定不止

05:45.060 --> 05:47.060
因为你每一次打开代码

05:47.060 --> 05:49.060
因为你用那个开发服务器

05:49.060 --> 05:50.060
你每改东西是代码

05:50.060 --> 05:51.060
就要构建一次

05:51.060 --> 05:52.060
肯定不止二十次

05:52.060 --> 05:54.060
可能几百次的

05:54.060 --> 05:57.060
所以说如果说每一个小时

05:57.060 --> 05:58.060
如果说每一次构建

05:58.060 --> 06:01.060
你多了十秒钟

06:01.060 --> 06:02.060
那么你想一想

06:02.060 --> 06:04.060
一小时可以多好时间

06:04.060 --> 06:05.060
而且你整个开发体验

06:05.060 --> 06:06.060
是非常糟糕的

06:06.060 --> 06:07.060
感觉整个很卡

06:07.060 --> 06:08.060
不流畅

06:08.060 --> 06:09.060
你改了代码

06:09.060 --> 06:10.060
不能立即看到效果

06:10.060 --> 06:12.060
每次要构建一次

06:12.060 --> 06:13.060
这是构建性能

06:13.060 --> 06:14.060
我们要考虑的事情

06:14.060 --> 06:16.060
然后上期我们还说了

06:16.060 --> 06:17.060
还有什么性能呢

06:17.060 --> 06:19.060
还有传输性能

06:19.060 --> 06:21.060
传输性能就是

06:21.060 --> 06:22.060
我们打包的结果

06:22.060 --> 06:24.060
在真实的运行环境里边

06:24.060 --> 06:26.060
在运行的时候

06:26.060 --> 06:29.060
我们希望它尽可能的快

06:29.060 --> 06:32.060
就是把我们的GS代码

06:32.060 --> 06:33.060
这东西

06:33.060 --> 06:34.060
CSC代码

06:34.060 --> 06:35.060
能够快速的

06:35.060 --> 06:36.060
让它从服务器到达客户端

06:36.060 --> 06:37.060
那么这样子

06:37.060 --> 06:38.060
于要求

06:38.060 --> 06:40.060
尽量的利用浏览器的缓存

06:40.060 --> 06:42.060
尽量的让我们打包结果

06:42.060 --> 06:44.060
体积更小

06:44.060 --> 06:46.060
这是传输性能

06:46.060 --> 06:48.060
然后还有一个是什么呢

06:48.060 --> 06:51.060
还有一个是那个

06:51.060 --> 06:53.060
运行性能

06:53.060 --> 06:55.060
运行性能

06:55.060 --> 06:57.060
运行性能的这个东西

06:57.060 --> 06:59.060
我们这个章节

06:59.060 --> 07:01.060
不涉及

07:01.060 --> 07:02.060
为什么呢

07:02.060 --> 07:03.060
因为运行性能

07:03.060 --> 07:06.060
是跟你写代码有关系

07:06.060 --> 07:07.060
写的

07:07.060 --> 07:10.060
写代码有关系

07:10.060 --> 07:11.060
就是说

07:11.060 --> 07:13.060
如何写一个扬好的代码

07:13.060 --> 07:14.060
那么这个东西

07:14.060 --> 07:16.060
需要在具体的课程里边具体分析

07:16.060 --> 07:18.060
你看诚哥的一些介石技术课

07:18.060 --> 07:20.060
包括我的一些课程

07:20.060 --> 07:21.060
也说到了

07:21.060 --> 07:23.060
这样做和电样做的一些

07:23.060 --> 07:24.060
性能上的差异

07:24.060 --> 07:26.060
这些都是运行性能

07:26.060 --> 07:28.060
就跟你什么写代码有关系

07:28.060 --> 07:29.060
跟webpack

07:29.060 --> 07:31.060
跟构建工具是没有任何关系的

07:31.060 --> 07:33.060
这个运行性能这一块

07:33.060 --> 07:35.060
我们不涉及

07:35.060 --> 07:37.060
我们这里给它标一个图标

07:37.060 --> 07:39.060
表示我们不涉及

07:39.060 --> 07:41.060
不涉及

07:43.060 --> 07:44.060
所以我们主要关注点在

07:44.060 --> 07:46.060
构建性能和传输性能

07:46.060 --> 07:48.060
之后我讲完了这两个之后

07:48.060 --> 07:50.060
我还会讲一个

07:50.060 --> 07:52.060
关于一些

07:52.060 --> 07:54.060
其他的优化

07:54.060 --> 07:56.060
其他优化

07:56.060 --> 07:57.060
其他优化其实很简单

07:57.060 --> 07:58.060
那一块就很简单

07:58.060 --> 07:59.060
我们再讲一个

08:00.060 --> 08:01.060
放过来吧

08:01.060 --> 08:03.060
我们首先来关注

08:03.060 --> 08:04.060
构建性能

08:04.060 --> 08:05.060
有哪些手段

08:05.060 --> 08:07.060
我们可以提高

08:07.060 --> 08:08.060
构建的性能

08:08.060 --> 08:10.060
让我们开发更加顺畅

08:11.060 --> 08:13.060
那么这里有好几种手段

08:13.060 --> 08:15.060
这就和我们讲其中一种手段

08:15.060 --> 08:17.060
叫做

08:17.060 --> 08:19.060
不解析磨块

08:21.060 --> 08:23.060
就减少磨块解析

08:23.060 --> 08:25.060
减少磨块解析

08:25.060 --> 08:27.060
大家看这个示威倒图的时候

08:27.060 --> 08:29.060
我用这个示威倒图是能够

08:29.060 --> 08:31.060
希望用这个示威倒图

08:31.060 --> 08:33.060
能够帮助大家建立

08:33.060 --> 08:35.060
知识点的体系

08:35.060 --> 08:37.060
因为之前的知识点的体系

08:37.060 --> 08:38.060
它没有那么复杂

08:38.060 --> 08:39.060
而这一块性能优化

08:39.060 --> 08:41.060
它知识点的体系

08:41.060 --> 08:42.060
浅透得比较深

08:42.060 --> 08:43.060
比较复杂

08:43.060 --> 08:44.060
所以说

08:44.060 --> 08:45.060
要用这个示威倒图

08:45.060 --> 08:46.060
给大家构建一下

08:46.060 --> 08:48.060
给大家展示一下

08:48.060 --> 08:50.060
它的知识点体系

08:50.060 --> 08:52.060
那么遇到具体的课程

08:52.060 --> 08:53.060
我们还是在

08:53.060 --> 08:54.060
课件里面

08:54.060 --> 08:55.060
来搞定它

08:55.060 --> 08:56.060
比如说我们这里

08:56.060 --> 08:57.060
构建性能的

08:57.060 --> 08:59.060
提高构建性能的地种方式

08:59.060 --> 09:01.060
就是减少磨块的解析

09:01.060 --> 09:03.060
那么这种方式

09:03.060 --> 09:05.060
我们就在具体的课程里面讲了

09:05.060 --> 09:08.060
于是我这里标注一个

09:08.060 --> 09:10.060
标注个啥玩意儿

09:10.060 --> 09:12.060
标注一个红色吧

09:12.060 --> 09:13.060
标注一个红色

09:13.060 --> 09:15.060
大家看到这个示威倒图里面

09:15.060 --> 09:16.060
一个红色的标注

09:16.060 --> 09:17.060
就表示

09:17.060 --> 09:18.060
这个东西

09:18.060 --> 09:20.060
它对应到我们的课程

09:20.060 --> 09:22.060
对应到这个课程

09:22.060 --> 09:23.060
减少磨块解析

09:23.060 --> 09:24.060
就到这个课程里面

09:24.060 --> 09:25.060
具体的看

09:26.060 --> 09:27.060
那么这一块

09:27.060 --> 09:28.060
我们学习的是

09:28.060 --> 09:30.060
如何减少磨块解析

09:30.060 --> 09:31.060
其实这一块很简单

09:31.060 --> 09:33.060
今天我们这一节课很简单

09:33.060 --> 09:35.060
我们看一下我们的课件

09:35.060 --> 09:36.060
打开它

09:36.060 --> 09:40.550
减少磨块解析

09:40.550 --> 09:42.550
我把这个目录去掉吧

09:42.550 --> 09:44.550
把第一个目录去掉

09:44.550 --> 09:45.550
一个落

09:45.550 --> 09:47.550
马可当的语法

09:47.550 --> 09:48.550
去掉过后

09:48.550 --> 09:49.550
我们这里点击这个目录

09:49.550 --> 09:51.550
它就不会出现这个标题了

09:53.550 --> 09:55.550
怎么来做

09:55.550 --> 09:56.550
我们首先认识一下

09:56.550 --> 09:58.550
什么叫做磨块解析

09:58.550 --> 10:00.550
你不是要减少磨块解析吗

10:00.550 --> 10:01.550
什么叫做磨块解析呢

10:01.550 --> 10:02.550
我们之前学过

10:02.550 --> 10:03.550
这个编译的

10:03.550 --> 10:05.550
未判可的编译原理

10:05.550 --> 10:06.550
怎么来做

10:06.550 --> 10:07.550
快速回顾一下

10:07.550 --> 10:09.550
找到一个磨块文件

10:09.550 --> 10:10.550
对吧

10:10.550 --> 10:11.550
入口文件

10:11.550 --> 10:12.550
从入口文件开始

10:12.550 --> 10:13.550
找磨块文件

10:13.550 --> 10:14.550
包括入口文件

10:14.550 --> 10:15.550
有其他依赖

10:15.550 --> 10:16.550
其他依赖也是个磨块

10:16.550 --> 10:17.550
还是要从头开始

10:17.550 --> 10:18.550
来找磨块文件

10:18.550 --> 10:20.550
找到这个磨块文件之后

10:20.550 --> 10:21.550
首先看一下

10:21.550 --> 10:22.550
之前有没有记录过

10:22.550 --> 10:24.550
这个磨块的内容

10:24.550 --> 10:27.550
就是编译过后的元代

10:27.550 --> 10:28.550
有没有记录

10:28.550 --> 10:31.550
有记录就直接得到结果了

10:31.550 --> 10:32.550
没有记录

10:32.550 --> 10:34.550
没有记录继续

10:34.550 --> 10:36.550
把文件内容读去出来

10:36.550 --> 10:37.550
然后应用楼段

10:37.550 --> 10:38.550
如果说你有楼段的话

10:38.550 --> 10:39.550
那么应用楼段

10:39.550 --> 10:41.550
楼段应用完了过后

10:41.550 --> 10:43.550
是不是最终给我另一块代码

10:43.550 --> 10:44.550
把这个代码进行

10:44.550 --> 10:45.550
做什么

10:45.550 --> 10:47.550
抽象语法数分析

10:47.550 --> 10:48.550
分析完了过后

10:48.550 --> 10:50.550
在语法数里面

10:50.550 --> 10:51.550
数型结构里面

10:51.550 --> 10:52.550
变例找到哪些东西

10:52.550 --> 10:53.550
是依赖

10:53.550 --> 10:55.550
把依赖记录下来

10:55.550 --> 10:57.550
然后在抽象语法数里面

10:57.550 --> 10:59.550
把一些导入函数

10:59.550 --> 11:00.550
Import

11:00.550 --> 11:01.550
Require

11:01.550 --> 11:03.550
这些东西是不是要替换一下

11:03.550 --> 11:05.550
把替换一下

11:05.550 --> 11:08.550
那么这个过程叫做磨块解析

11:08.550 --> 11:10.550
我给它框出来了

11:10.550 --> 11:12.550
替换完了之后

11:12.550 --> 11:14.550
就形成了磨块的最终的代码

11:14.550 --> 11:16.550
把这个代码记录一下

11:16.550 --> 11:17.550
当下一次

11:17.550 --> 11:19.550
如果说再看这个磨块的时候

11:19.550 --> 11:21.550
就不用重新解析了

11:21.550 --> 11:26.550
这就是磨块解析

11:26.550 --> 11:27.550
解析完了过后

11:27.550 --> 11:28.550
它还要根据

11:28.550 --> 11:29.550
这个磨块

11:29.550 --> 11:31.550
它依赖了别的哪些磨块

11:31.550 --> 11:32.550
依赖了别的哪些磨块

11:32.550 --> 11:33.550
对正向的磨块

11:33.550 --> 11:34.550
依赖的磨块

11:34.550 --> 11:35.550
也要重新来一次

11:35.550 --> 11:37.550
最终的把所有的一代磨块

11:37.550 --> 11:38.550
都要记录下来

11:38.550 --> 11:39.550
磨块的ID

11:39.550 --> 11:40.550
就是磨块的路径

11:40.550 --> 11:42.550
以及磨块的对应的内容

11:42.550 --> 11:45.550
这是我们以前讲的编译原理

11:45.550 --> 11:46.550
磨块解析

11:46.550 --> 11:47.550
包含哪些东西

11:47.550 --> 11:49.550
包含抽象语法数分析

11:49.550 --> 11:50.550
包含依赖分析

11:50.550 --> 11:53.550
包含磨块语法替换

11:53.550 --> 11:54.550
包含这些东西

11:54.550 --> 11:55.550
这是第一个

11:55.550 --> 11:58.550
什么叫做磨块解析

11:58.550 --> 11:59.550
我们这些个说

11:59.550 --> 12:00.550
减少磨块解析

12:00.550 --> 12:01.550
什么意思呢

12:01.550 --> 12:02.550
就是如果说有些磨块

12:02.550 --> 12:04.550
不解析会怎么样

12:04.550 --> 12:05.550
那就很简单了

12:05.550 --> 12:06.550
如果说一个磨块

12:06.550 --> 12:07.550
不对它进行解析

12:07.550 --> 12:08.550
它会怎么样呢

12:08.550 --> 12:09.550
处理完了之后

12:09.550 --> 12:11.550
就直接变成最终的代码了

12:11.550 --> 12:13.550
不会去分析它的依赖关系

12:13.550 --> 12:15.550
不会去替换它里边的其他东西了

12:15.550 --> 12:18.550
就直接成最终的代码了

12:18.550 --> 12:19.550
就是不解析

12:19.550 --> 12:22.550
如果某一个磨块不解析的话

12:22.550 --> 12:23.550
那么这个磨块

12:23.550 --> 12:24.550
经过楼段处理过后的代码

12:24.550 --> 12:25.550
就是最终代码

12:25.550 --> 12:26.550
那如果说

12:26.550 --> 12:27.550
你没有对这个磨块使用

12:27.550 --> 12:28.550
任何楼段的话

12:28.550 --> 12:30.550
那么这个磨块的原代码

12:30.550 --> 12:33.550
就是最终打包的结果

12:33.550 --> 12:34.550
当然从这个图里边

12:34.550 --> 12:35.550
你可以看到

12:35.550 --> 12:36.550
如果说对某一个磨块

12:36.550 --> 12:38.550
不进行解析的话

12:38.550 --> 12:39.550
可以缩断什么

12:39.550 --> 12:40.550
勾件实现

12:40.550 --> 12:42.550
所以说我们这里新能

12:42.550 --> 12:43.550
勾件新能

12:43.550 --> 12:44.550
是不是可以提高

12:44.550 --> 12:46.550
缩断勾件的时间

12:46.550 --> 12:48.550
好 接下来再看

12:49.550 --> 12:50.550
思考提到

12:50.550 --> 12:51.550
所以我们这一刻

12:51.550 --> 12:53.550
就这一个章节都是这样子

12:53.550 --> 12:55.550
有些地方需要大家理解

12:55.550 --> 12:56.550
而不是说

12:56.550 --> 12:58.550
我还要记得它怎么去用

12:58.550 --> 13:00.550
它怎么用其实是无所谓的

13:00.550 --> 13:02.550
我忘了可以再查一下就行了

13:02.550 --> 13:03.550
主要是要理解

13:03.550 --> 13:05.550
那么哪些磨块不需要解析呢

13:05.550 --> 13:06.550
因为这个东西你背不住的

13:06.550 --> 13:08.550
你只能理解

13:08.550 --> 13:09.550
根据这个原理

13:09.550 --> 13:12.550
你觉得哪些磨块不要解析

13:12.550 --> 13:13.550
不要解析

13:13.550 --> 13:15.990
那就想一想

13:15.990 --> 13:16.990
这个磨块解析

13:16.990 --> 13:17.990
它是不是省略到什么

13:17.990 --> 13:19.990
省略到车房有法属分析

13:19.990 --> 13:21.990
也就是它不分析依赖了

13:21.990 --> 13:23.990
它不分析磨块里面的依赖了

13:23.990 --> 13:24.990
所以说

13:24.990 --> 13:25.990
如果说它对这个磨块

13:25.990 --> 13:26.990
不进行解析的话

13:26.990 --> 13:27.990
是不是这个磨块里面

13:27.990 --> 13:28.990
如果说有依赖

13:28.990 --> 13:29.990
它分析不出来

13:29.990 --> 13:30.990
对不对

13:30.990 --> 13:32.990
是不是这么一个逻辑在里面

13:32.990 --> 13:34.990
因此哪些磨块不用解析呢

13:34.990 --> 13:35.990
你可以想到

13:35.990 --> 13:37.990
第一种不用解析的磨块

13:42.300 --> 13:45.300
磨块中无其它依赖

13:45.300 --> 13:47.300
就这个磨块就没有任何

13:47.300 --> 13:49.300
不再依赖其它任何磨块了

13:49.300 --> 13:51.300
就这个磨块文件里面

13:51.300 --> 13:53.300
不去依赖其它任何磨块

13:53.300 --> 13:54.300
无其它依赖

13:54.300 --> 13:55.300
这样的磨块是不是可以

13:55.300 --> 13:56.300
不需要解析

13:56.300 --> 13:57.300
对吧

13:57.300 --> 13:58.300
对不对

13:58.300 --> 14:00.300
因为我们解析不就是在

14:00.300 --> 14:01.300
做依赖分析吗

14:01.300 --> 14:02.300
分析这个磨块的依赖

14:02.300 --> 14:03.300
它本身就不依赖其它的

14:03.300 --> 14:05.300
就不用去分析了

14:05.300 --> 14:07.300
所以这个磨块是不用解析的

14:07.300 --> 14:09.300
还有什么磨块不用解析呢

14:09.300 --> 14:11.300
你看磨块解析里面

14:11.300 --> 14:12.300
还是不是还要做一个

14:12.300 --> 14:14.300
替换依赖函数

14:14.300 --> 14:16.300
替换依赖函数

14:16.300 --> 14:17.300
那么也就是说

14:17.300 --> 14:19.300
这个磨块里边

14:19.300 --> 14:21.300
这个磨块里边

14:21.300 --> 14:24.300
它没有

14:24.300 --> 14:26.300
当然也

14:26.300 --> 14:27.300
这个磨块它已经是

14:27.300 --> 14:28.300
不需要解析

14:28.300 --> 14:29.300
已经是没有解析的了

14:29.300 --> 14:31.300
对吧

14:31.300 --> 14:33.300
那就没了

14:33.300 --> 14:34.300
那就没了

14:34.300 --> 14:36.300
磨块都无其它依赖

14:36.300 --> 14:37.300
那么这种磨块

14:37.300 --> 14:39.300
往往是什么磨块的

14:39.300 --> 14:40.300
这种磨块

14:40.300 --> 14:41.300
往往就是

14:41.300 --> 14:44.300
一些已经

14:44.300 --> 14:46.300
打包好的

14:46.300 --> 14:47.300
好的

14:47.300 --> 14:49.300
第三方磨块

14:49.300 --> 14:50.300
第三方磨

14:51.300 --> 14:52.300
已经打包好的

14:52.300 --> 14:53.300
第三方磨

14:53.300 --> 14:54.300
比方说

14:54.300 --> 14:55.300
比如

14:55.300 --> 14:56.300
解析

14:56.300 --> 14:58.300
解析这个磨块

14:58.300 --> 14:59.300
是不是就已经打包好了

14:59.300 --> 15:01.300
不信我们来安装试一下

15:01.300 --> 15:02.300
来看一下吧

15:02.300 --> 15:08.050
我们来看一下

15:08.050 --> 15:10.050
NPM

15:10.050 --> 15:15.880
NIT

15:15.880 --> 15:16.880
然后

15:16.880 --> 15:18.880
I 横杠D 解析

15:18.880 --> 15:20.880
其实这个横杠D

15:20.880 --> 15:21.880
加不加

15:21.880 --> 15:22.880
这些东西都无所谓

15:22.880 --> 15:23.880
因为在构建工具里边

15:23.880 --> 15:24.880
加不加都无所谓

15:24.880 --> 15:25.880
因为我们最终

15:25.880 --> 15:26.880
打包结构里面

15:26.880 --> 15:27.880
跟这些库都没关系了

15:27.880 --> 15:29.880
全在打包结构里边去了

15:29.880 --> 15:32.880
解析安装好了

15:32.880 --> 15:35.880
然后你看一下这个库

15:35.880 --> 15:36.880
我们看一下它的

15:36.880 --> 15:37.880
Pikic解析

15:37.880 --> 15:38.880
就是我们使用

15:38.880 --> 15:39.880
解析的时候

15:39.880 --> 15:41.880
使用的是哪一个磨块文件

15:41.880 --> 15:42.880
使用的是哪呢

15:42.880 --> 15:43.880
我们看一下解析的类

15:43.880 --> 15:44.880
它指向的是哪

15:44.880 --> 15:45.880
指向的是

15:45.880 --> 15:47.880
它的Pikic解析里边

15:47.880 --> 15:48.880
它指向的是

15:48.880 --> 15:49.880
DS目录下面的

15:49.880 --> 15:50.880
解析

15:50.880 --> 15:51.880
是不是这里边的

15:51.880 --> 15:52.880
这个文件

15:52.880 --> 15:53.880
也就是我们使用

15:53.880 --> 15:54.880
解析这个磨块的时候

15:54.880 --> 15:56.880
使用的是这个磨块

15:56.880 --> 15:58.880
那么看一下这个磨块

15:58.880 --> 15:59.880
这个磨块有依赖吗

15:59.880 --> 16:00.880
你看一下

16:00.880 --> 16:01.880
它就是一个

16:01.880 --> 16:04.880
立即执行函数

16:04.880 --> 16:05.880
代表太多了

16:05.880 --> 16:08.880
折叠不起来

16:08.880 --> 16:11.880
它就是一个立即执行函数

16:11.880 --> 16:12.880
你看吧

16:12.880 --> 16:14.880
最终函数结尾

16:14.880 --> 16:15.880
它就是一个

16:15.880 --> 16:17.880
立即执行函数

16:17.880 --> 16:19.880
那么这个磨块里边

16:19.880 --> 16:20.880
有什么依赖吗

16:20.880 --> 16:21.880
有什么依赖吗

16:21.880 --> 16:22.880
我们来查一下吧

16:22.880 --> 16:23.880
搜索

16:23.880 --> 16:24.880
Import

16:24.880 --> 16:25.880
有吗

16:25.880 --> 16:26.880
没有吧

16:26.880 --> 16:27.880
有没有Require

16:27.880 --> 16:29.880
你看的是注释

16:29.880 --> 16:30.880
对不对

16:30.880 --> 16:31.880
注释

16:31.880 --> 16:32.880
不是

16:32.880 --> 16:33.880
没有Require

16:33.880 --> 16:34.880
没有Import

16:34.880 --> 16:35.880
是不是它不依赖

16:35.880 --> 16:36.880
其他任何东西

16:36.880 --> 16:37.880
对吧

16:37.880 --> 16:38.880
它不依赖其他任何东西

16:38.880 --> 16:39.880
所以说

16:39.880 --> 16:40.880
这个磨块

16:40.880 --> 16:42.880
这个磨块

16:42.880 --> 16:43.880
需不需要解析呢

16:43.880 --> 16:44.880
它就不需要解析了

16:44.880 --> 16:45.880
解析它干嘛呢

16:45.880 --> 16:46.880
它又没有其他依赖

16:46.880 --> 16:47.880
对吧

16:47.880 --> 16:48.880
也不需要去替换

16:48.880 --> 16:49.880
它的依赖函数

16:49.880 --> 16:50.880
它没有依赖

16:50.880 --> 16:51.880
替换怎么依赖函数呢

16:51.880 --> 16:52.880
所以说

16:52.880 --> 16:53.880
它不需要解析了

16:53.880 --> 16:54.880
那么

16:54.880 --> 16:55.880
这是结块位

16:55.880 --> 16:56.880
那么我们就可以

16:56.880 --> 16:58.880
对某这些磨块

16:58.880 --> 16:59.880
不进行解析

16:59.880 --> 17:01.880
可以提高

17:01.880 --> 17:02.880
构建效率

17:02.880 --> 17:04.880
那么怎么来不进行解析呢

17:04.880 --> 17:05.880
我们先把这个

17:05.880 --> 17:06.880
先把这个

17:06.880 --> 17:07.880
VPEG安装好

17:07.880 --> 17:09.880
VPEG VPEG CD

17:09.880 --> 17:13.450
安装好

17:13.450 --> 17:14.450
好 这里呢

17:14.450 --> 17:15.450
我们建立一个

17:15.450 --> 17:17.450
VPEG

17:17.450 --> 17:18.450
VPEG.js

17:18.450 --> 17:19.450
Module

17:19.450 --> 17:20.450
Export

17:20.450 --> 17:23.890
Mode

17:23.890 --> 17:24.890
Mode

17:24.890 --> 17:26.890
Development

17:26.890 --> 17:27.890
然后呢

17:29.890 --> 17:30.890
它也不写了吧

17:30.890 --> 17:31.890
好 怎么呢

17:31.890 --> 17:32.890
不让它解析

17:32.890 --> 17:33.890
我们看一下

17:33.890 --> 17:34.890
有写个代码

17:34.890 --> 17:35.890
SRC

17:35.890 --> 17:36.890
我们的入口文件

17:36.890 --> 17:37.890
入口文件

17:37.890 --> 17:38.890
它依赖了什么

17:38.890 --> 17:39.890
依赖了结块位

17:40.890 --> 17:41.890
就是这里

17:41.890 --> 17:43.890
我们用Import嘛

17:43.890 --> 17:44.890
到了

17:44.890 --> 17:45.890
Front结块位

17:45.890 --> 17:47.890
我们输出嘛

17:47.890 --> 17:48.890
多了

17:49.890 --> 17:50.890
输出

17:50.890 --> 17:54.200
好 那么这个时候呢

17:54.200 --> 17:55.200
由于我们入口文件

17:55.200 --> 17:56.200
是不是依赖了结块位

17:56.200 --> 17:57.200
OK

17:57.200 --> 17:59.200
它是不是会去解析这个结块位

17:59.200 --> 18:01.200
对吧 除了解析我们自己的磨块之外

18:01.200 --> 18:02.200
它还会去解析结块位

18:02.200 --> 18:03.200
那么我们现在呢

18:03.200 --> 18:05.200
知道了结块位呢

18:05.200 --> 18:06.200
是不需要解析的

18:06.200 --> 18:07.200
是不需要解析的

18:07.200 --> 18:08.200
所以说呢

18:08.200 --> 18:11.200
你可以在VPEG.conf.js里边

18:11.200 --> 18:12.200
加一个配置

18:12.200 --> 18:13.200
怎么配置呢

18:13.200 --> 18:14.200
配置方式非常简单

18:14.200 --> 18:15.200
就是我们之前学过的

18:15.200 --> 18:17.200
就是Module里边配置一个

18:17.200 --> 18:18.200
low port

18:18.200 --> 18:19.200
可能大家忘记了

18:20.200 --> 18:21.200
就在这里

18:21.200 --> 18:24.200
Module里边配置一个low port

18:24.200 --> 18:25.200
这个配置为什么呢

18:25.200 --> 18:26.200
配置为正得表达式

18:26.200 --> 18:28.200
凡是被这个正得表达式

18:28.200 --> 18:29.200
所匹配的磨块

18:29.200 --> 18:31.200
它就不会进行解析

18:31.200 --> 18:33.200
那么不会解析

18:33.200 --> 18:34.200
是不是说这个磨块

18:34.200 --> 18:36.200
不会形成最终打包结果

18:36.200 --> 18:37.200
是不是

18:37.200 --> 18:38.200
好好想一想

18:38.200 --> 18:39.200
不是

18:39.200 --> 18:41.200
它真的会形成打包结果

18:41.200 --> 18:43.200
只是它没有这一部分

18:43.200 --> 18:44.200
只是你在结果上

18:44.200 --> 18:45.200
看到上

18:45.200 --> 18:46.200
看上去呢

18:46.200 --> 18:47.200
也不大

18:47.200 --> 18:49.200
那么只是没有这一部分的

18:49.200 --> 18:50.200
只是没有这一部分的

18:50.200 --> 18:51.200
所以说呢

18:51.200 --> 18:53.200
它只是能提高构建效率

18:53.200 --> 18:54.200
对某些磨块

18:54.200 --> 18:55.200
比方说我们这里

18:55.200 --> 18:56.200
结块儿

18:56.200 --> 18:57.200
对结块儿这一块

18:57.200 --> 18:58.200
我们就不需要解析了

18:58.200 --> 18:59.200
你直接成为

18:59.200 --> 19:00.200
你的代码就拿过来

19:00.200 --> 19:02.200
成为打包结果就行了

19:02.200 --> 19:03.200
看一下吧

19:03.200 --> 19:07.200
npmx

19:07.200 --> 19:09.900
vpeg

19:09.900 --> 19:10.900
打包

19:10.900 --> 19:11.900
打包完成

19:11.900 --> 19:12.900
284毫秒

19:12.900 --> 19:13.900
好

19:13.900 --> 19:14.900
那么如果说

19:14.900 --> 19:15.900
我们看一下结果

19:15.900 --> 19:16.900
结块儿还是在

19:16.900 --> 19:17.900
你看这么多

19:17.900 --> 19:18.900
结块儿还是在的

19:18.900 --> 19:19.900
还在的

19:19.900 --> 19:20.900
那么只不过

19:20.900 --> 19:21.900
它对结块儿的代码

19:21.900 --> 19:22.900
就没有再进行

19:22.900 --> 19:23.900
抽象与发出分析了

19:23.900 --> 19:24.900
直接拿过来

19:24.900 --> 19:25.900
好

19:25.900 --> 19:26.900
那如果说

19:26.900 --> 19:27.900
你看我把这个

19:27.900 --> 19:29.900
npmx去掉

19:29.900 --> 19:30.900
虽然这里可能影响不大

19:30.900 --> 19:31.900
可能影响不大

19:31.900 --> 19:34.900
因为只有这么一个文件

19:34.900 --> 19:36.900
打包一下

19:36.900 --> 19:37.900
是不是

19:37.900 --> 19:38.900
时间要多一些

19:38.900 --> 19:39.900
对吧

19:39.900 --> 19:40.900
要多一些

19:40.900 --> 19:41.900
当然这只是一个

19:41.900 --> 19:42.900
如果说

19:42.900 --> 19:43.900
你可以去除掉

19:43.900 --> 19:44.900
很多个这样的

19:44.900 --> 19:45.900
不需要解析的

19:45.900 --> 19:46.900
效率自然提高了

19:46.900 --> 19:47.900
这么的表达是

19:47.900 --> 19:48.900
当然可以匹配多个

19:48.900 --> 19:49.900
对吧

19:49.900 --> 19:50.900
OK

19:50.900 --> 19:51.900
那么我们再来看一下

19:53.900 --> 19:55.900
你这个东西能不能耐用了

19:55.900 --> 19:56.900
不能耐用的

19:56.900 --> 19:57.900
因为你知道

19:57.900 --> 19:58.900
它原理过后

19:58.900 --> 19:59.900
你不能耐用了

19:59.900 --> 20:00.900
比方说

20:00.900 --> 20:01.900
这里自己写了一个模块

20:01.900 --> 20:02.900
或者是

20:02.900 --> 20:03.900
我们就是一个

20:03.900 --> 20:04.900
第三方模块

20:04.900 --> 20:06.900
我们就会自己写一个吧

20:06.900 --> 20:07.900
比方说

20:07.900 --> 20:08.900
你要对某些模块

20:08.900 --> 20:09.900
比方一个TES的介绍

20:09.900 --> 20:10.900
对这个模块

20:10.900 --> 20:12.900
你不需要它解析

20:12.900 --> 20:13.900
比方说

20:13.900 --> 20:14.900
TES模块里面

20:14.900 --> 20:15.900
Import

20:16.900 --> 20:17.900
Dollar

20:18.900 --> 20:19.900
解析

20:19.900 --> 20:20.900
看一下会成

20:20.900 --> 20:21.900
一个什么样的结果

20:22.900 --> 20:23.900
好

20:23.900 --> 20:24.900
那么现在

20:24.900 --> 20:25.900
我们在In这个设计

20:25.900 --> 20:26.900
JS里面

20:26.900 --> 20:27.900
没有使用解析

20:27.900 --> 20:28.900
没有使用解析

20:28.900 --> 20:29.900
我们使用的是什么呢

20:29.900 --> 20:31.900
使用的是Test

20:33.900 --> 20:35.900
这里我们把

20:36.900 --> 20:37.900
这里导出

20:37.900 --> 20:38.900
导出

20:39.900 --> 20:40.900
Export

20:40.900 --> 20:41.900
Default

20:41.900 --> 20:42.900
Dollar

20:42.900 --> 20:43.900
导出

20:43.900 --> 20:44.900
那么这里

20:44.900 --> 20:45.900
我们用Import

20:45.900 --> 20:46.900
Dollar

20:47.900 --> 20:48.900
Test

20:49.900 --> 20:50.900
现在看一下

20:50.900 --> 20:51.900
我这个入口文件

20:51.900 --> 20:53.900
一代的是Test的模块

20:53.900 --> 20:54.900
那如果说

20:54.900 --> 20:55.900
你在配置的时候

20:55.900 --> 20:56.900
对Test的这个模块

20:56.900 --> 20:58.900
不解析会怎么样

20:58.900 --> 20:59.900
会怎么样呢

20:59.900 --> 21:00.900
你自己在脑袋里面

21:00.900 --> 21:01.900
想一想

21:01.900 --> 21:02.900
最终打包结果

21:02.900 --> 21:04.900
会是一个什么样的效果

21:04.900 --> 21:05.900
对它是要解析的

21:05.900 --> 21:06.900
对吧

21:06.900 --> 21:07.900
我们只是不解析它

21:07.900 --> 21:08.900
那么会成了

21:08.900 --> 21:09.900
一个什么样的结果呢

21:10.900 --> 21:11.900
npx

21:11.900 --> 21:12.900
vpack

21:12.900 --> 21:15.980
打包完成了

21:15.980 --> 21:16.980
很快

21:16.980 --> 21:17.980
106毫秒

21:17.980 --> 21:18.980
就打包完成了

21:18.980 --> 21:19.980
看一下最终结果

21:20.980 --> 21:21.980
你会发现这个结果里面

21:21.980 --> 21:22.980
有接query吗

21:23.980 --> 21:24.980
有接query吗

21:24.980 --> 21:25.980
是没有

21:25.980 --> 21:26.980
没有接query

21:26.980 --> 21:27.980
对吧

21:27.980 --> 21:28.980
没有解query

21:28.980 --> 21:29.980
如果说

21:29.980 --> 21:30.980
那么代码是什么呢

21:30.980 --> 21:31.980
我把这个打开

21:31.980 --> 21:32.980
大家看得清楚一点

21:32.980 --> 21:34.980
del2 source map

21:34.980 --> 21:35.980
这样子

21:35.980 --> 21:36.980
打包文件里面

21:36.980 --> 21:37.980
它就不是用evo了

21:40.350 --> 21:41.350
打包

21:42.350 --> 21:43.350
打包完成

21:43.350 --> 21:44.350
打包完成

21:44.350 --> 21:45.350
我们看一下

21:45.350 --> 21:46.350
如果说没有接query了

21:46.350 --> 21:47.350
过后是什么呢

21:47.350 --> 21:48.350
你看一下

21:48.350 --> 21:49.350
index.js

21:49.350 --> 21:50.350
它是要解析的

21:50.350 --> 21:52.350
所以说index.js里面

21:52.350 --> 21:53.350
什么导入模块代码

21:53.350 --> 21:54.350
对吧

21:54.350 --> 21:55.350
它会把它替换掉

21:55.350 --> 21:56.350
你看一下

21:56.350 --> 21:57.350
index.js里面

21:57.350 --> 21:59.350
所以把导入模块代码

21:59.350 --> 22:00.350
进行了一下替换

22:00.350 --> 22:01.350
对吧

22:01.350 --> 22:02.350
因为这是一些特殊的愚法

22:02.350 --> 22:03.350
它要进行替换的

22:03.350 --> 22:05.350
而我们txt.js

22:05.350 --> 22:06.350
你看一下

22:06.350 --> 22:07.350
替换了吗

22:07.350 --> 22:09.350
是没有替换

22:09.350 --> 22:11.350
对txt.js这个模块

22:11.350 --> 22:13.350
它做了什么事情呢

22:13.350 --> 22:15.350
没有抽象愚法数分析

22:15.350 --> 22:17.350
没有抽象愚法数分析

22:17.350 --> 22:19.350
它就没有记录e9

22:19.350 --> 22:21.350
它根本就不知道这个模块一代别的

22:21.350 --> 22:22.350
它根本就不知道

22:22.350 --> 22:23.350
我们整个项目里面

22:23.350 --> 22:24.350
还一代接query

22:24.350 --> 22:25.350
它不知道

22:25.350 --> 22:26.350
因为它对代码是没有进行分析的

22:26.350 --> 22:27.350
它就没有分析出

22:27.350 --> 22:28.350
e9的接query

22:28.350 --> 22:31.350
对这个模块是没有分析的

22:31.350 --> 22:32.350
那么

22:32.350 --> 22:33.350
进兵前

22:33.350 --> 22:34.350
它没有抽象愚法数分析

22:34.350 --> 22:36.350
它就无法在愚法数里面

22:36.350 --> 22:38.350
替换那些e9愚法

22:38.350 --> 22:39.350
像这些愚法

22:39.350 --> 22:41.350
都是应该要被t换掉的

22:41.350 --> 22:42.350
这些愚法都要被t换掉

22:42.350 --> 22:44.350
结果它没有去做一个t换

22:44.350 --> 22:45.350
所以说

22:45.350 --> 22:48.350
你在用这个模块解析的时候

22:48.350 --> 22:50.350
在用这个模块的解析的时候

22:50.350 --> 22:51.350
要注意一下

22:51.350 --> 22:52.350
不是说

22:52.350 --> 22:53.350
所有的模块都要

22:53.350 --> 22:55.350
都能够不让它解析

22:55.350 --> 22:56.350
它没有一代的模块

22:56.350 --> 22:58.350
并且它里面不需要去

22:58.350 --> 23:00.350
有那些模块化代码

23:00.350 --> 23:01.350
不需要t换的模块

23:01.350 --> 23:02.350
那么

23:02.350 --> 23:04.350
才不需要去进行解析

23:04.350 --> 23:05.350
ok

23:05.350 --> 23:07.350
那么这是关于

23:07.350 --> 23:08.350
这种方式

23:08.350 --> 23:09.350
来减少模块解析

23:09.350 --> 23:10.350
从而提高

23:10.350 --> 23:11.350
构建性能

23:11.350 --> 23:13.350
从而提高构建性能

23:13.350 --> 23:14.350
好

23:14.350 --> 23:16.350
那么这是这几颗东西

