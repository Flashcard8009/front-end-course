WEBVTT

00:01.390 --> 00:04.830
好 同学们 那咱们继续来学习性能优化

00:05.830 --> 00:09.710
构建性能这一块呢 咱们分成三节课来讲 对吧 有三种方式

00:09.710 --> 00:12.550
构建性能呢 就暂时的告一段落了

00:12.550 --> 00:16.310
那么接下来呢 还有一些方面 一些的性能的优化

00:16.310 --> 00:18.830
就是传输性能 以及一些其他优化

00:18.830 --> 00:23.150
再说一说 关于运行性能的话 是跟我们携带吧 有关系

00:23.150 --> 00:26.230
所以说 这一块呢 不在我们这门课的考虑范围之列

00:26.230 --> 00:30.390
是在你们学习具体的技术的时候呢 去做这些优化

00:30.870 --> 00:33.270
好 咱们来看一下 传输性能

00:34.430 --> 00:37.750
所谓的传输性能就是说 我们打包出来的介石呢

00:37.750 --> 00:42.510
体积应该尽可能的小 避免传输太多的东西

00:42.510 --> 00:47.990
另外呢 还有就是 我们尽量的把那些变动的比较少的代码呢

00:49.510 --> 00:52.710
合并到一个文件 单独的一个文件里边去

00:52.710 --> 00:55.190
这样子呢 可以充分的利用浏览器缓存

00:55.190 --> 00:57.190
因为它变动比较少嘛 对吧 也不怎么变

00:58.070 --> 01:03.190
好 那么关于传输性能这一块呢 有几种方式啊 可以实现优化

01:03.190 --> 01:05.910
我们首先呢 来看一下这个方式 就是关于分包

01:07.550 --> 01:10.630
什么叫分包呢 顾名思义啊 什么叫分包

01:10.630 --> 01:14.750
就是把一个整体的代码分不到不同的打包文件里边去

01:15.710 --> 01:18.910
默认的情况下呢 未派可是不会进行分包的

01:18.910 --> 01:21.270
比方说 我们看一下 我们目前的代码

01:22.630 --> 01:26.710
在我们的这个 看一下我们的目前的工程 有一个模办啊

01:26.750 --> 01:29.110
这个没什么好说的 配置文件看一下吧

01:30.030 --> 01:32.430
对吧 非常简单一个配置文件 也没什么好说的

01:33.430 --> 01:37.230
然后呢 我们的src入口文件里边呢 我们写上这么一段代码

01:37.950 --> 01:42.870
比方说 我们这个入口模块里边 就是我们的自己的工程里边 要用到两个公共模块

01:43.430 --> 01:44.870
一个呢 是杰克瑞

01:46.750 --> 01:47.710
一个呢 是

01:48.590 --> 01:53.410
都在我们写个什么样的代码呢 我们比方说啊

01:54.410 --> 01:54.890
这写错了

01:56.450 --> 01:57.610
我们比方说 我们这样子写

01:58.290 --> 02:02.330
杰克瑞的话 我读去页面上的所有的内名为Red的元素

02:02.850 --> 02:06.330
啊 读出来 读出来是一个尾数组 对吧 是一个内数组

02:06.770 --> 02:10.570
那么我们来用楼单一起来判断一下啊 他是不是一个真正的数组

02:10.890 --> 02:12.850
我们随便写些代码吧 随便写一点

02:13.930 --> 02:17.330
ok 好 写进去啊 接下来我们得到一个结果

02:17.930 --> 02:18.290
result

02:19.410 --> 02:22.370
输出啊 输出下这个结果 接下来我们来打包一下 看一下

02:23.210 --> 02:29.090
在我们这里找到工程 打开我们的控制台

02:30.970 --> 02:37.370
好 打包一次啊 打包的命令呢 我已经配置在这个为PAC里面 这个PAC的介绍介绍里面了啊

02:38.370 --> 02:38.930
好 npm

02:40.210 --> 02:42.010
装对好 然后打一次包

02:44.700 --> 02:49.580
好 咱们观察一下啊 打包完成了 观察一下最终打包结果 这个Made.js里边

02:50.020 --> 02:54.140
这个里边呢 你会看到所有的no-dash代码的全部到里边去了

02:54.660 --> 03:03.420
啊 你看一下吧 我们的结块的代码进来了 哎呀 两万七千多行 对吧 结块的代码进来了啊 然后呢 都带起的代码也进来了

03:04.060 --> 03:12.900
说明了什么呢 说明了 我们由于他有依赖 所以说为PAC 他是把所有的依赖的代码全部合并到一个文件里边啊 完成最终打包

03:13.540 --> 03:18.980
啊 就是相当于是怎么说 用专业的话来说 把所有的依赖代码全部合并到

03:19.940 --> 03:22.420
bond里边 对吧 把了合并到一个文件里边

03:23.740 --> 03:29.340
但是呢 这样子呢 其实并不是很好 因为像我们如果说 像开发一个多页面的应用程序

03:30.180 --> 03:35.020
你看有多个页面的话 可能每一个页面呢 都要用到一些代码 啊 比方说这是我们的

03:35.540 --> 03:36.060
主页的

03:36.620 --> 03:43.860
介石文件 有可能的别的介石文件呢 比方说另外一个啊 other的介石 那么这个介石文件里边呢 他可能也会用到

03:44.420 --> 03:50.180
介块位都带起 那么我们另一个页面也要用 他就是我们要有两个入口啊 有两个创改

03:50.780 --> 04:02.580
那么这个创改了 他是不是也会加入介块位和那带起的代码 那么就会导致两个创改生成的文件里边呢 最终生成的文件里边 我看一下吧 说了半天 大家不知道什么意思啊 看一下N2

04:04.420 --> 04:08.740
啊 比方说我们有两个 一个呢 是index 啊 一个是妹嘛 妹

04:10.020 --> 04:13.380
index 来自于src index的介石

04:13.940 --> 04:20.900
啊 一个呢 是other 来自于src other 第二介石 啊 当然两个页面我就不写了啊 没必要了嘛

04:21.420 --> 04:23.940
好 那么这有两个啊 然后我们输出一下output

04:24.740 --> 04:25.300
啊 output

04:26.580 --> 04:30.420
呃 在我们输出的输出里边呢 我们有 比方说我们输出一下file name

04:31.860 --> 04:34.100
为什么呢 呃 为name

04:35.620 --> 04:36.700
啊 第二哈希

04:37.580 --> 04:41.540
第二介石啊 简单写一下 好 保存啊 咱们打包 打包一下

04:46.460 --> 04:51.180
稍等一下啊 完成 那么你会看到呢 这两个介石文件里边 它都包含了

04:52.140 --> 04:55.020
介query和楼代写单嘛 那你看一下吧

04:55.900 --> 04:59.340
两万多行 对吧 那么这边other 第二介石也是两万

05:00.380 --> 05:06.060
other 第二介石呢 哦 这没保存 没保存 重新来一次 啊 肯定会出现的啊 这毫无疑问的

05:07.820 --> 05:10.860
啊 再重新打包一次啊 再看一下啊other 第二介石

05:11.660 --> 05:15.820
是不是也有 对吧 两万多行啊 没点介石 所以也有两万多行

05:16.300 --> 05:22.460
那么在这种情况下呢 这会是不是大量的增加了最终打包结果里边的重复代码

05:23.340 --> 05:27.900
虽然说并不会影响我们的元代码 我们元代码里面不可能有重复代码的啊

05:28.380 --> 05:33.260
嗯 但是呢 打包结果里边会有大量的重复代码 这就增加了文件的体积

05:33.660 --> 05:34.460
不利于传输

05:35.420 --> 05:41.100
另外呢 像这些公共代码 像jquery啊 或者snowdown下 我们经常会用到的这些公共代码呢

05:41.340 --> 05:44.220
我们最希望的是把它单独的打包成一个文件

05:44.620 --> 05:47.420
因为呢 这样子可以充分的利用浏览器的缓存

05:47.980 --> 05:50.860
对吧 浏览器读取这个文件之后呢 因为它不怎么变动

05:51.180 --> 05:56.620
说它可以把它缓存下来 那么下一次呢 浏览器就不会真实的从服务器里边去传输了

05:56.860 --> 06:00.060
啊 我们希望打到这么一个效果 所以说我们要分包

06:00.780 --> 06:02.300
好 再我们再回去看啊

06:02.860 --> 06:04.540
呃 什么叫分包 就是把一个整体的代码

06:04.860 --> 06:08.940
你看现在是整体 对吧 我们把它分开 分成不同的打包结果

06:10.060 --> 06:13.500
啊 当然它肯定是不会影响到我们的原代码

06:13.900 --> 06:18.300
我们这些优化呀 要尽可能的不要影响我们原代码的编写

06:18.460 --> 06:20.460
就是我们该怎么写代码 还是怎么写

06:20.860 --> 06:27.900
写代码的方式不变 只是呢 我们通过wepack的各种配置啊 各种方式能够让我们的生存结果更加优化

06:28.140 --> 06:29.420
啊 你不能因为

06:30.140 --> 06:34.860
为了性能啊 去改动了大量的改动原代码 这样子不太好啊 不太好

06:36.220 --> 06:42.540
好 那么这里 呃 为什么要分包呢 我刚刚解释了啊 一个是减少公共代码降低从的总的体积

06:42.620 --> 06:47.180
你看像在现在啊 是不是总的体积增加了 把两个接手间的总体积加起来增加了

06:47.900 --> 06:50.700
呃 另外呢 可以充分的利用流量器的缓存

06:52.060 --> 06:57.900
好 那么我们什么时候要分包呢 自然而然就是你知道为什么要分包 你知道什么时候要分包了

06:58.540 --> 07:06.460
比方说像多个创举 引用了相同的公共模块 像我们这里是不是两个入口 两个创举 引用了相同的公共模块这块位都大

07:07.580 --> 07:09.340
而且这个公共模块呢 还体积比较大

07:10.140 --> 07:16.860
像有几万行 那么而且呢 它会出现比较少的改动 基本上也不会改动它 你改动它干嘛了 对吧

07:17.020 --> 07:25.100
偶尔呢 就是对它升级一下啊 其实大部分呢 也很少很少升级 可能慢点了一年一次 很少很少升级啊 除非有一些bug 我们需要

07:25.820 --> 07:34.300
官方修复之后呢 我可能要升级一下 很少改动 它并不像我们的元代码那样子 经常会改动 那么这个时候呢 我们尽量的能够分包就分包

07:35.500 --> 07:43.420
再回事啊 分包的话 尽量的不要影响我们的元代码编写 因为你分包的方式 要不要分包 分包的怎么来分包 可能都会

07:43.900 --> 07:52.380
在我们的具体的开发过程中啊 具体的不搭建的过程中呢 都可能会变化 你如果说影响元代码的话 那么一改一改一发生变动

07:52.540 --> 07:56.620
那么我们的元代码也会跟着改 这样太麻烦了 所以尽量不会影响元代码

07:57.340 --> 08:05.420
好 那么分包有两种方式啊 那么这个时候呢 才会进入到具体的课程 我们这节课呢 讲的是手动分包

08:06.620 --> 08:09.420
下节课呢 我们讲自动分包啊 两种方式

08:09.980 --> 08:15.420
那么这两种方式的分别是两个课程 反是加红点的地方呢 就表示他要进入具体的课程了

08:15.980 --> 08:18.140
好 我们这里说 先讲手动分包

08:19.100 --> 08:24.700
好 那么这里呢 我再说一下啊 不是说呢 手动分包好像就是要麻烦一点啊

08:25.740 --> 08:32.060
我们学的手动分包呢 好像就是更加能够理解自动分包 自动分包就是自动帮我们做 不是这个意思啊

08:32.780 --> 08:36.700
手动分包确实要麻烦一点 但是他的方式跟自动分包是完全两罢算

08:37.020 --> 08:42.540
就不是一个一个原理啊 所以说他们完全是两罢算 我只是呢 从这样的写信来呢

08:42.860 --> 08:47.660
给他一个直观的感觉啊 觉得自己手动分包肯定要自己手动写很多配置 对吧

08:48.540 --> 08:52.780
好 咱们看一下手动分包 接下来我们来进入今天的啊 咱们具体的课程

08:54.460 --> 08:56.620
首先我们来了解手动分包的原理

08:59.150 --> 09:00.750
手动分包的原理来看一下啊

09:01.630 --> 09:06.350
它基本原理 我们原理理解清楚之后呢 再看它怎么来进行配置编写

09:07.230 --> 09:10.110
好 原理呢 总体的尸度分为两个步骤

09:10.990 --> 09:17.310
啊 第一步呢 是先单独的打包公共模块 就对于接框位啊 或者是楼大写啊 这里呢

09:17.950 --> 09:24.430
这里好像它的编号 上面的编号有点问题啊 这里是二

09:25.230 --> 09:25.870
好 重新来一次

09:30.990 --> 09:35.950
好 第一个啊 基本原理 就是我们首先把这些公共模块 就是经常要用到的

09:35.950 --> 09:39.070
编冻有很少的 而且体积比较大的 这些公共模块呢

09:39.550 --> 09:44.190
把它打包单独来进行打包 也就是它的打包过程呢 跟我们的主模块

09:44.430 --> 09:48.430
就是跟我们自己的模块打包 完全是两罢算啊 就不是在一起做的

09:48.670 --> 09:49.470
就这么个意思

09:50.110 --> 09:54.190
你看啊 我们目前呢 是打包是放在一起做的 是吧 一个配置文件里边

09:54.590 --> 09:58.670
那么对于东共模块呢 你肯定要单独去建一个配置文件啊 单独进行打包

09:59.550 --> 10:05.470
好 这是第一步 第二步呢 就是根据入口模块呢 进行正常打包啊 就是我们对我们的自己的代码

10:05.710 --> 10:09.790
对我们自己src里边的代码 然后再进行正常打包 也说打包呢 它分为两个步骤

10:10.190 --> 10:14.670
第一步呢 先单独的去打包公共模块 然后呢再再打包我们自己的代码

10:14.990 --> 10:17.630
啊 是这么意思 好 我们来看一下它的原理啊 第一步

10:18.590 --> 10:22.750
首先呢 单独打包公共模块 怎么打包呢 它要形成这么一种

10:23.790 --> 10:27.790
方式 就是把我们的公共代码呢 单独打包之后呢 放到

10:28.350 --> 10:33.070
不管有多少个吧啊 我们用不同的创可嘛 进行打包 打包过后放到不同的文件里边

10:33.070 --> 10:36.510
对吧 这是我们目前啊 都会做的 就非常简单

10:37.230 --> 10:39.870
然后呢 一个额外的点 就是要生成一个

10:40.430 --> 10:41.230
描述文件

10:42.110 --> 10:45.630
啊 有两个额外的点啊 第一个呢 是打包结果里边要包住电量

10:46.350 --> 10:50.750
结块位 比方说 这个文件里边 暴露了一个变量 公共变量啊 你可以理解为

10:50.750 --> 10:52.830
这个文件里边有这么一个东西 结块位

10:53.950 --> 10:58.910
等于什么什么什么 啊 暴露一个变量啊 于或者怎么怎么来暴露 我们以后来具体说

10:59.710 --> 11:04.030
好 另外一个呢 就是楼单系里边啊 另外一个楼单系里边 它也会暴露一个公共变量

11:04.830 --> 11:06.910
说这样子 变量就暴露出来了 对吧

11:07.470 --> 11:10.430
好 暴露出来了过后 然后呢 我们要生成一个

11:10.990 --> 11:15.630
支援清单 这个清单里边要描述什么呢 哪个模块

11:16.190 --> 11:22.350
暴露出来了什么样的变量 那个模块的文件 打包的文件在哪 要把这些东西记录一下

11:23.070 --> 11:30.510
啊 那么一会呢 我会告诉大家 大家怎么来生成一个支援清单啊 一会就知道了 这个支援清单非常重要了啊 没有这个支援清单 第二步就做不了

11:32.430 --> 11:38.590
这个支援清单 比方说啊 你看一下啊 我们这里就可以描述 我简单的写了一下啊 比方说 这个结块位这个模块啊

11:39.310 --> 11:45.070
这个模块呢 其实它完整的写发了应该是这样子啊 结块位 就是在note

11:47.950 --> 11:52.030
margeuse这个目录下边的结块位这个模块

11:53.150 --> 11:59.310
然后呢 它里边暴露的全局变量是什么呢 是结块位 所以把这个描述出来了 对吧 描述出来

11:59.870 --> 12:05.550
哎 那么它的文件在哪呢 比方说我保存的这个包的文件在DLM目录下面的结块位

12:06.510 --> 12:08.590
DLM件事 那么这里呢就把描述出来

12:09.310 --> 12:13.230
啊 不要弄蛋写在这 那么就把描述出来 那么总之形成一个支援清单

12:13.710 --> 12:18.990
你记住啊 支援清单里边它提供了什么信息 哪个模块

12:19.390 --> 12:26.190
包入了什么变量 然后呢 模块打包打包的代码在哪 在哪个位置 包入出来这么一些信息

12:26.990 --> 12:32.270
好 包入出来过后呢 后续的我们打包的时候呢 就可以进行优化了

12:32.990 --> 12:38.350
必须要包得出来这么一个文件 我们自己的打包的时候怎么优化了 比方说你参考一下这个代码

12:39.150 --> 12:40.270
跟我们写的差不多 上台

12:41.550 --> 12:49.310
啊 这个代码 这个代码呢 我们 我们的模块里边导入了结块位 对吧 导入了的蛋写 使用了结块位和蛋写里边的东西

12:50.510 --> 12:57.230
那么这个时候呢 如果我们就希望他打包的时候参考一下这个文件 你看他怎么参考 他就这样参考

12:57.710 --> 13:01.550
哎 你我打包的打包这个东西的时候 你看我这里不是依赖一个模块吗

13:02.030 --> 13:11.470
我一检查 我发现资源清单里边已经有了这个模块的描述了 这个模块已经完成打包了 我不需要再对这个模块再把它合并到我们的文件里边 就像这样子

13:12.750 --> 13:18.190
我们是不是现在合并了 对吧 合并了 那么他后来呢 有了这个清单文件之后呢 他就觉得

13:18.670 --> 13:23.070
我没有必要合并了 因为他已经的完成打包了 所以说他就不会合并

13:23.630 --> 13:29.710
懂我这个意思吧 他要去检查这个资源清单文件的 也就是说这个资源清单文件是给谁用的

13:30.270 --> 13:35.870
他不是说打包完了过后 在浏览器里面用 浏览器用都不用他 用都不会用他的

13:36.510 --> 13:42.030
那么他是给谁用的 他是给正常打包 就第二步的时候 我们正常打包的时候用的

13:42.750 --> 13:50.990
用的时候他就会读这个资源清单文件 那么查看一下我们的资源清单里边有哪些模块进行了 对哪些模块进行的描述

13:51.710 --> 13:57.150
值得是这么的意思啊 当然我这里写的比较简洁啊 一会具体做的时候 还要多多少少有些差异

13:57.950 --> 14:05.790
好 那么我们来看一下啊 那么这样子一来还打包结果会变成什么样子呢 大概的看一下他的原代吧啊 这部分是要原理的

14:06.430 --> 14:09.230
你看我们的index的接视文件其实没有发生变化

14:10.110 --> 14:15.710
根本就没有变化 还是我们这里简单的简单的写了一些啊 我虽然我们用的是ES6的方式

14:15.870 --> 14:23.470
啊 这里是用了ES6的方式导入的 肯定是有差异的 那么我这里为了简洁啊 给大家说一下啊 这里其实呢简单的说就是用的是

14:24.030 --> 14:30.670
导入嘛 总之是导入啊 我这里就用的是个common.js它的转换方式啊 就没有用 它ES6肯定要单独处理的

14:31.070 --> 14:36.110
啊 没关系啊 我们就把一个意思说到就行了 就是我们的index的.js呢 其实它没有发生任何变化

14:37.630 --> 14:39.950
只不过了对于另外两个模块啊 你看这里

14:40.510 --> 14:46.830
这个模块 接壶的模块和nodec的模块 本来呢 这里边是不是要放置所有接壶的代码

14:47.550 --> 14:49.470
这里边是不是要放置所有的nodec代码

14:50.190 --> 14:57.150
哎 他没了 他把接壶的代码放 变成什么呢 变成这个东西 直接导出一个全局变量接壶

14:57.550 --> 15:00.430
他怎么知道全局变量是接壶呢 是因为这个清单描述的

15:00.830 --> 15:04.910
啊 这个字变清单描述了 接壶的这个模块 它暴露的全局变量是接壶

15:05.310 --> 15:07.630
那当然这个模块呢 暴露的全局变量是nodec

15:07.870 --> 15:10.110
所以说呢 他就直接把这个全局变量导出了

15:10.430 --> 15:13.790
啊 就形成了这么一个结果 那么实际上在这里导入的时候

15:14.430 --> 15:20.030
导入的时候 是不是导 相当于是把他的导入的是他 他是不是导出的是什么全局变量

15:20.510 --> 15:24.190
是这么个意思 是这么个意思 大家好好看一下这个原代码的原理

15:25.150 --> 15:26.270
那么就这样子的就可以

15:27.070 --> 15:32.910
极大的优化我们的主模块 就是我们自己的模块的打包结果 就不会再有这些公共代码

15:33.710 --> 15:36.830
还是用这么一种方式来完成的 这是它的基本原理

15:37.390 --> 15:41.710
好 一会呢 我们在具体的使用的时候呢 再反复来去看这个基本原理

15:42.350 --> 15:44.350
好 接下来我们来看具体的怎么来打包

15:45.630 --> 15:50.590
那么它既然分为两步 它自然我们要分两步来做第一步的打包公共模块

15:50.750 --> 15:54.910
那么这个是一个独立的包裹程 所以说呢 我们这里呢 肯定是要

15:55.390 --> 16:00.270
单独的去建一个配纸文件 来完成打包 好 比方说啊 我们这里单独建一个

16:01.790 --> 16:08.110
啊 又建新建一个啊 我也派这个名字里随便去啊 随便去个什么名字啊 比方说dl

16:09.070 --> 16:11.070
config.js

16:11.470 --> 16:17.230
写这么一个文件 好 这个文件呢 我们写一个marge.export 当然这个文件要启作用

16:17.550 --> 16:21.310
啊 以后我们打包的时候要启作用 那肯定它不会默认的读这个文件的

16:21.550 --> 16:24.430
那么你自然要配置一下啊 比方说我们在这里再写个命令嘛

16:25.150 --> 16:26.590
啊 比方说我们这里dl吧

16:27.150 --> 16:29.310
这个命令 那么运行的是wepak

16:29.870 --> 16:33.870
啊 给它指定一个配置文件 用什么配置文件呢 用wepak.dl

16:34.990 --> 16:37.150
config.js 那我解释一下这个dl吧

16:37.550 --> 16:39.550
这个dl呢 叫做动态链接库

16:41.470 --> 16:44.510
啊 这个dl 叫做dynamic

16:45.230 --> 16:48.270
动态的link 链接library

16:49.630 --> 16:52.110
这个词呢 是很早很早一些

16:52.830 --> 16:56.910
早期的语言啊 cr cr加压 还有csharp这些语言

16:57.230 --> 17:03.070
它出现了一个词动态链接库 表示什么意思呢 大概的意思就是说有一个东西啊 有一个文件

17:03.230 --> 17:08.270
生成了一个文件 这个文件呢 暴露了一些API 那么你随时可以把这个文件里边的东西拿出来用

17:09.470 --> 17:12.590
大概就说这么个意思啊 这个文件那里可以把它认为是动态链接库

17:12.750 --> 17:17.630
它只是接用了这个概念啊 实际上动态链接库的原本的意思呢还不 还不仅仅是这样子

17:17.870 --> 17:20.350
我给大家解释一下啊 它只是沿用了这个概念

17:20.670 --> 17:23.470
那么你可以认为就是一个打包的文件就行了

17:24.190 --> 17:28.750
啊 那么我们这里呢 就是单独的去打包一些公共模块 形成一个文件 形成动态链接库

17:29.070 --> 17:32.510
啊 我这里呢 配置一下 第二个命令 那么使用的是这个配置文件

17:33.470 --> 17:38.430
那么一会呢 我要单独完成的公共模块打包就使用这个命令啊 以后我就会输入

17:39.710 --> 17:44.990
npm装 第二啊 那么输这个东西 那么完成公共模块打包

17:45.950 --> 17:48.830
好 那么这里边怎么配置呢 我把这个配置复制过来啊 再解释

17:52.220 --> 17:53.260
好 看一下

17:53.980 --> 17:56.780
这个配置里边其实很简单 我一个个说吧 首先mode

17:57.820 --> 18:03.660
就是我们的打包方式 打包方式呢 往往这里呢 肯定是选用 为什么呢

18:04.220 --> 18:10.300
当然选用development这些 也行啊 无所谓的 只不过呢 因为它是个公共模块 不是我们自己写的带嘛

18:10.700 --> 18:16.300
我们要调试也调试不到它 对吧 也不会去带它里面去怎么去去调试 另外呢

18:17.340 --> 18:25.900
它生成出来就不是给我们看的啊 就是来用它的名耳功能的 所以说呢 它就直接用那个生产环境的方式来打包就行了啊 用最小化的方式来打包

18:26.460 --> 18:27.020
好 这么mode

18:28.060 --> 18:33.580
好 那么这里n圈呢 有那么这里呢 就是你有几个公共模块需要打包 那么你就写几个

18:33.820 --> 18:38.620
我们知道这里就是入口 对吧 要比较说我们要打包两个 一个是get query 一个是notepad

18:38.780 --> 18:41.180
那么你就打包这两个啊 写两个trunk

18:41.900 --> 18:43.420
每个trunk的单独去打包一个文件

18:44.060 --> 18:46.620
output 你看这配置没有什么区别的吧 output

18:46.940 --> 18:50.220
我们打打包的结果呢 放到哪来 随便放到哪 想放哪放哪

18:50.540 --> 18:56.220
那么我这里呢 就放一个单独的目录吧 放到输出目录里边dl里边啊 使用trunk的名字

18:57.260 --> 18:58.620
好 那么这个东西是干嘛的

18:59.260 --> 19:04.940
这个东西 我以前讲过没有 好像讲过啊 我也有在不太记得了 那么如果如果没讲过的话说一下

19:05.260 --> 19:07.900
这个就是暴露的啊 每个

19:08.460 --> 19:08.860
bundle

19:09.660 --> 19:10.300
暴露的

19:11.420 --> 19:12.940
暴露的全局

19:13.500 --> 19:14.060
变量米

19:15.340 --> 19:20.860
那么我这里呢 使用了一个站位服 因为我们有两个trunk嘛 每个trunk的暴露的全局变量力不能一样

19:21.100 --> 19:24.220
所以说我们这里呢 直接使用trunk的名字作为全局变量米

19:24.700 --> 19:26.540
get query 你暴露的全局变量就get query

19:26.940 --> 19:31.100
那么那单系呢 你暴露的全局变量就是那单系 好 接下来我们来打包一次看一下啊

19:31.820 --> 19:33.260
就这么简单 没有什么复杂的

19:35.300 --> 19:38.900
好 打包一次 完成了 你看一下电视目录下面 是不是多了个文件夹

19:39.220 --> 19:43.780
dl 对吧 那么get query 是不是打包出来了 对吧 跟以前学的东西是一样的 没有什么区别

19:44.020 --> 19:46.980
只不过呢 他多了什么 一个get query 是暴露出来了全局变量

19:47.460 --> 19:51.300
哇 get query 等于什么 等于后面一个立即执行函数 对吧 我们之前都分析过原码

19:51.380 --> 19:55.540
就是一个立即执行函数 执行完了过后 他把这个执行的结果放到get query里边

19:55.860 --> 19:59.620
就暴露出来了 对吧 把结块的代码就 结块的API就暴露出来了

20:00.180 --> 20:05.300
好 那么多单系呢 我们看一下 是吧 暴露出来了 对吧 那么这个配置呢 就起这么一个作用

20:05.940 --> 20:10.100
啊 就起这么一个作用 那么这里呢 我再顺便说一下啊 其实在这里呢 还有一个配置

20:10.580 --> 20:13.700
叫做nebrary target

20:14.180 --> 20:18.740
这是暴露的方式啊 他默认之中是用一个全局变量来暴露

20:19.140 --> 20:22.260
还有什么呢 还有什么umd 对吧 用那种

20:22.820 --> 20:29.620
统一的模块发的方式啊 那么来暴露啊 有是一些老的一些暴露的技术啊 总之呢 他可以把暴露出来啊 默认就用

20:29.780 --> 20:31.700
那就行了 把它暴露成一个全局变量

20:32.820 --> 20:37.380
就完了 那你看一下是不是单独打包了吗 肯定是单独打包了 对吧

20:38.180 --> 20:43.060
只不过呢 目前呢 还差一个东西 怕什么东西呢 你看我们之前原来的图 是不是少了一个

20:43.460 --> 20:48.900
这个东西 对吧 少了一个清单 没有这个清单的话 那么第二步呢 他就没法正常进行

20:49.300 --> 20:56.500
所以说呢 我们还要去生成一个清单 那么生成那个清单的话 就需要一个插件了啊 这个插件呢 是wpaq自带的插件叫

20:56.820 --> 20:58.820
deal plucking 那么来生成什么

20:59.300 --> 21:06.900
资源清单 其实说如果说打包的话 我们已经完成了啊 已经完成打包了 只不过呢 没有清单 没有清单的话 会影响后续的使用

21:07.700 --> 21:12.500
好 接下来我们来生成一下清单 清单的话 我们要使用wpaq里边一个自带的插件

21:13.620 --> 21:14.180
require

21:15.460 --> 21:17.940
倒进来 那么这里边呢 我们使用一个plucking

21:21.870 --> 21:27.550
是一个wpaq 它自带的插件啊 叫做deal plucking

21:28.110 --> 21:33.950
啊 这个插件里边有些配置 那么这个配置里边呢 我们只需要关心两个 一个spac

21:34.670 --> 21:38.430
你这个清单文件 资源清单文件保存在哪 它是这样子

21:39.230 --> 21:45.230
每一个创可它会生成一个清单文件 那么这里呢 上面的图呢 画的有点不是很准确啊 我只是跟他

21:45.470 --> 21:49.790
告诉他 告诉大家这里有个资源清单文件 因为画太复杂了 一开始大家也理解不了

21:50.270 --> 21:55.070
啊 总之呢 它会有清单文件 但是实际上呢 是每一个创可它会生成一个清单文件

21:55.790 --> 21:58.750
好 那么这个清单文件放哪呢 这里要给他一个决定路径

21:59.390 --> 22:02.190
啊 既然要用决定路径呢 我们可以使用一个cool啊 叫pass

22:04.540 --> 22:08.860
pass 用这个cool来告诉他 清单文件保存在哪 保存在哪呢

22:09.420 --> 22:13.340
pass result 啊 生成一个决定路径 随即便保存在哪

22:14.300 --> 22:16.300
问大家一个问题啊 看有没有认真听科

22:17.180 --> 22:20.220
这个清单文件是不是必须要保持在保存在电神目录

22:20.540 --> 22:25.580
是不是 不是的 电神目录是什么

22:26.540 --> 22:30.860
使我们最终要运行的代码 这个清单文件要不要运行

22:31.980 --> 22:35.340
需不需要最终我们在浏览器里面运行这个清单 不需要

22:35.980 --> 22:41.580
它是我们后续打包我们自己的代码的时候 在打包的过程中要运行的

22:42.700 --> 22:45.900
好好体会一下这句话啊 他不是说我们最终要运行的

22:46.220 --> 22:48.940
所以说呢 他也是在打包过程中才有作用的

22:49.260 --> 22:52.780
所以说他没有必要放到这个电神目录下面 当然你放进去也无所谓

22:53.180 --> 22:57.260
只不过没有必要 所以说呢 我们放到哪呢 随便放哪啊 随便放哪

22:57.580 --> 23:02.460
比方说我们就放到这个目录吧 我们先个目录 放到第二这个这个目录

23:02.780 --> 23:07.580
你看这两个文件啊 虽然都是第二目录 这个第二目录是我们打包的结果 是我们要用的啊

23:07.580 --> 23:11.500
最终要运行的 要参与运行的 那么这个东西呢只是只是呢

23:13.180 --> 23:16.540
我们影响后续打包的啊 他不会参与最终运行

23:16.940 --> 23:21.980
所以我们放这吧 随便放哪啊 那么当前目录啊 下面的哪个呢 第二

23:22.460 --> 23:26.700
然后放什么文件名呢 文件名字随便写 通常呢 我们使用这样的文件名

23:30.140 --> 23:30.540
manifest

23:30.540 --> 23:33.020
manifest就资源的意思啊 资源清单的意思

23:33.260 --> 23:35.580
点儿节省 因为它本身是一个阶层格式的

23:35.820 --> 23:38.620
文件里边的内容本身是一个阶层格式的描述服啊

23:38.620 --> 23:42.700
所以说我们一般来说用这个阶层啊后续啊 资源清单

23:43.020 --> 23:46.860
那么谁的资源清单呢 前面加上一个站位服啊 这里表示创渴的名字

23:47.020 --> 23:50.300
每个创渴呢 会生成一个资源清单啊 这保存的路径

23:50.940 --> 23:53.980
好 资源清单里边还有一个东西要配置一下啊 就是

23:56.940 --> 23:58.620
资源清单中暴露的变量名

23:59.500 --> 24:04.460
啊 就是你的资源 什么意思呢 就是说你每一个资源清单是代表了一个创渴嘛 对吧

24:04.460 --> 24:07.980
结魁瑞他生成一个资源清单 那么结魁瑞他暴露的变量名是什么呢

24:08.620 --> 24:14.140
暴露的变量名呢 因为他不知道啊 他这里不知道 是让我们看打包结果 他就知道了 对吧

24:14.140 --> 24:18.700
他不会去看打包结果的啊 那么这里呢 你要告诉他啊 暴露的变量名是什么

24:18.700 --> 24:25.580
那么我们这里呢 通常呢 跟那个liberary呢 写成一字啊 写成一字就行了 你这里边是啥 我这边就是啥

24:25.580 --> 24:27.180
你暴露的是什么 我这边就是什么

24:28.060 --> 24:31.500
好 写完了 写完了 让我们来看一下吧 他这样子完了过后了 又会怎么样

24:33.100 --> 24:38.430
好 npm 说对 好 哎 抱错了是吧

24:39.310 --> 24:46.190
那supply array as entry 哎 怎么了

24:47.470 --> 25:00.180
他说什么呢 我看一下啊 看一下supply array as entry

25:00.980 --> 25:04.020
哦 他这里要写成 要写成那个

25:05.300 --> 25:08.100
呃 要写成那个就是

25:09.460 --> 25:12.900
数组啊 好像是这样子啊 不行的话我一下查一下查一下文章

25:13.860 --> 25:16.260
看一下吧 还是不行

25:17.300 --> 25:21.700
invited options 啊 查一下文章啊 这里可有一点忘了 会拍

25:23.620 --> 25:32.300
查一下文章啊 因为他是自带的啊 自带的插件 叫做deal plugin啊 看一下吧 看一下啊

25:34.560 --> 25:37.200
他没有例子吗 呃name

25:39.120 --> 25:42.240
啊name 啊name 他要写个数组啊 他要写个数组

25:45.100 --> 25:50.930
第二点还说名 哎不对啊 他不是数组啊 不是数组啊

25:52.690 --> 25:57.810
呃 哎 这里呢 他没有势力啊 他没有势力

25:59.570 --> 26:02.290
我看一下啊 他这个错误是包的是

26:03.650 --> 26:08.370
呃 plugin invalid options 我们重新把这个换成这个 要看一下刚才这个错误是什么

26:12.050 --> 26:14.290
这个文档写的不是很详细他的文档

26:14.850 --> 26:17.730
supply array as entry

26:18.210 --> 26:27.010
他是呢 我们啊 明白了明白了 我想起来了 他是意思是就是说 他这样的打包的话 他有一个要求啊 他有一个要求

26:27.250 --> 26:31.170
他要求你呢 n 圈里边呢 每一个创可呢 你必须要是一个数组

26:32.130 --> 26:33.250
啊 你必须要是个数组

26:34.770 --> 26:35.330
为什么呢

26:36.130 --> 26:39.810
因为他是这样子想的啊 因为他读的时候呢 是把他当成数组来读的

26:40.210 --> 26:45.170
他是这样子想的 他说说呢 你每一个创可呢 他有可能用很多的其他的

26:45.490 --> 26:49.890
其他的扣带里边 只不过最终导出呢 导出的是数组的最后一项 这是我们以前讲过的啊

26:50.050 --> 26:54.610
就是一个创可呢 他可以配一个数组 那么他导出的是最后一项

26:54.930 --> 26:55.410
但是呢

26:56.050 --> 27:01.730
前面的箱呢 他会打 他会形成打包结果啊 是这么个意思啊 不过呢 跟我们这里的好像没什么关系

27:01.890 --> 27:06.530
啊 没办法写成个数组吧啊 运行一下

27:10.460 --> 27:12.860
啊 我把这里 课件改一下啊 课件改一下

27:13.580 --> 27:15.420
课件这里呢 也有一个

27:16.940 --> 27:17.580
写成个数组

27:20.960 --> 27:21.360
ok

27:22.080 --> 27:28.160
好 打包完成 打包完成之后呢 你看一下电神目录下面第二位 这里边实际上是不不会有任何影响的

27:28.160 --> 27:33.600
这里跟之前是一样的啊 没有任何影响 因为这一部分是谁的功能 这一部分是这一块

27:34.320 --> 27:36.640
是这一块的功能啊 这一块打包

27:36.960 --> 27:38.480
所以跟这里没什么关系

27:38.880 --> 27:40.960
但是呢 他会多出一些文件 就在这里

27:41.440 --> 27:44.240
根据我们的配置会多出两个文件 对吧 一个接query

27:44.560 --> 27:45.680
一个呢 什么le dash

27:46.000 --> 27:50.240
那么这两个就是对接query模块和le dash模块的资源清单描述

27:50.800 --> 27:55.040
好 我们看一下吧 看一下资源清单 它其实描述非常简单 我们看一下关键信息就行了

27:55.600 --> 27:58.560
它的模块路径在哪呢 模块路径在这

27:58.960 --> 28:04.320
对吧 我们使用的就是模块的id啊 这相对于是模块的id 我们知道啊 之前分析过那个微拍的

28:04.960 --> 28:08.800
编译原理 那模块id就是模块的相对路径 对吧 相对工程的路径

28:09.840 --> 28:14.720
好 然后呢 它包裹的变量名是什么呢 包裹的变量名叫做接query

28:15.520 --> 28:18.240
啊 包裹的变量名叫接query 就这么个意思

28:19.200 --> 28:24.000
啊 明白这个意思吧 啊 特别特别简单啊 包裹的变量名叫接query

28:24.800 --> 28:32.000
好了 看一下le dash le dash里面其实也一样啊 也一样啊 还有一些 包含了一些别的模块吗 不管

28:32.320 --> 28:34.960
我们看一下这个模块 这个模块呢 我们是不是

28:35.760 --> 28:41.040
呃 就是le dash的模块 对吧 模块id 那么模块id它包裹的变量名是什么呢 le dash

28:41.760 --> 28:43.600
啊 就这么简单啊 就这么简单

28:44.560 --> 28:47.920
好 接下来呢 我们来看一下 这样子有了这个清单之后

28:48.240 --> 28:52.480
会怎么样影响我们后边的打包 好 接下来我们看第二步

28:53.760 --> 29:02.060
现在我们就已经完成了公共模块的打包了啊 喝喝水 接下来我们来使用

29:03.020 --> 29:08.380
公共模块 怎么使用呢 肯定是不会影响我们的原代码 原代码不变

29:09.180 --> 29:17.660
原代码不变 我们这里呢 我要说明清楚啊 我们先暂时的换成单模块啊 我们一会再变把它变成多模块 是一样的

29:18.540 --> 29:20.860
啊 原代码不变 单模块打包

29:21.900 --> 29:27.180
好 首先你第一步要做的事情是要在页面中手动的引入公共模块

29:27.820 --> 29:34.940
什么意思 就是我们要在页面里边手动的去引入我们的公共模块 是不是在这儿 对吧 公共模块是不会发生变动的啊

29:34.940 --> 29:39.900
你不用担心它的文件名变了啊 不用去做这个担心 很少会发生变动 直接引用就行了

29:40.620 --> 29:49.340
用了在哪呢 因为我们知道这个页面最终会生成到哪 会生成到这个跌审目录下边 对吧 这个页面会生成到跌审目录下边 所以说我们这里呢 不用再去写什么

29:49.820 --> 29:57.980
跌审目录了啊 直接是跌油啊 也就是我们这个页面相当于是在这个根目录下面啊 我们跌油啊 下面的什么接query

29:58.540 --> 30:02.060
叫解释 是吧 把引用进来 然后呢再引用什么呢 no dash

30:03.180 --> 30:08.940
要手动引用没办法 没办法 他鬼知道你要用哪些模块 他不知道啊 你在手动引用

30:09.980 --> 30:15.820
那么手动引用就完了吗 肯定还没完 因为为啥呢 他会影响打包结果吗 npm 状态

30:17.260 --> 30:22.940
完成我们自己的模块打包 会影响打包结果吗 啊 他肯定不会影响啊 该是这个样子

30:23.660 --> 30:32.060
他结块为何呢 但是还是会进来 因为他并不知道聊干嘛 还是会进来 因为我们这个配置是不是非常干净的 对吧 他仍然会进来

30:32.460 --> 30:37.660
那又怎么办呢 好 我慢慢来啊 先解决一些前前面的问题 然后呢

30:38.140 --> 30:44.540
还要重新设置这个clean webpack plugin 因为这个插件呢 他会清空这个垫色目录 就是说

30:46.060 --> 30:49.580
当然你没有使用这个插件 倒是无所谓 如果说你使用了

30:50.060 --> 30:55.820
他会有一个动作 就是把这个目录清空 这一清空不要紧 是连我们这个公共模块也够清空了

30:56.220 --> 31:01.020
对吧 他也把这个东西清空了 那怎么办呢 对不对 我们是不希望他清空这个

31:01.420 --> 31:07.340
所以说我们要单独去控制一下啊 那么这个clean webpack plugin里面呢 他一看他的文档啊 他里面是有描述的

31:07.340 --> 31:09.660
他有这个功能 你只要对他做一下配置就行了

31:11.500 --> 31:15.020
啊 配置一下他 就是忽略掉什么呢 你可以清空

31:15.740 --> 31:18.700
啊 清空所有目录下面的所有文件

31:19.580 --> 31:26.620
但是要排除掉dll目录 以及 这里写错了啊 以及dll里边的所有的文件

31:27.420 --> 31:28.300
把这两个排除掉

31:29.660 --> 31:32.820
改一下啊 这里改一下

31:33.780 --> 31:35.460
就是把这两个东西排除掉

31:36.180 --> 31:39.380
啊 就是你要清空可以 其中其他文件都可以 但是不要清空这两个

31:39.780 --> 31:46.260
那么这是什么样的语法呢 这个语法呢 叫做globbing partners 啊 以后呢 大家还会看到这样的类似的语法

31:46.820 --> 31:51.460
啊 那么大家看一下吧 如果说有兴趣的话 可以聊一下 特别特别简单啊 他的语法

31:52.020 --> 31:59.300
用型号呢 能够匹配任何的制服 但是呢 不包括鞋杠啊 不配匹配鞋杠

32:00.020 --> 32:01.860
用问号呢 匹配单个制服

32:03.140 --> 32:07.620
型号可以匹配任意数量的制服 问号匹配单个制服 但是呢 也不包含鞋杠

32:08.260 --> 32:10.100
两个型号呢 匹配任意

32:10.820 --> 32:13.780
有点类似于正的表达是 但是有不太像 也不是

32:15.940 --> 32:17.460
两个型号呢 也匹配的是

32:18.580 --> 32:22.100
任意数量的制服 包括鞋杠 包括鞋杠

32:22.980 --> 32:28.820
两个大货号呢 你可以使用一些表达式啊 一些这个 就是分割的表达式

32:29.620 --> 32:36.100
感叹号呢 就是不匹配后边的东西 就这么个意思 当然他还有一些别的用法啊 我们这里呢 简单说一下

32:37.700 --> 32:44.500
就这么个意思啊 用这样的一个描述服来告诉他怎么来匹配 这样子的他就不会删除这个文件 整个文件夹啊 这里写错了

32:45.780 --> 32:46.420
重新打开一次

32:55.780 --> 33:00.420
这样子他就不会删除这两个文件 这个文件夹 不会删除文件夹本身 也不会删除这个文件夹里面的文件

33:00.980 --> 33:02.100
好 咱们来看一下吧

33:06.690 --> 33:09.890
我们这里配置一下 配置一下 配置好了 接下来我们来看一下

33:11.570 --> 33:18.210
打包 打包完了 你看这个文件夹是不是没有删除

33:19.170 --> 33:24.770
如果说你没有这样的配置的话 就会出问题 你看吧 没有配置的话 他这两个文件 这个文件夹也没了

33:27.810 --> 33:32.050
你看是不是没了 对吧 可以清除掉 我这里重新运行一下啊 第二

33:33.330 --> 33:39.410
把公共模块打包 反正我公共模块有就行了啊 有了就行了 先不要每一次运行的时候都重新打包这个公共模块 没必要

33:39.490 --> 33:42.050
打包一次就行了 因为他没有变动 没有变动就不需要打包

33:43.010 --> 33:45.970
只有变动了之后了还需要打包 我们这里把他加上

33:46.930 --> 33:49.170
好 这是第二步 解决一下前置问题

33:50.530 --> 33:51.010
好 打包

33:51.810 --> 33:53.330
那么这样子就没有清楚这个部路了

33:54.050 --> 33:59.410
但是呢 现在还是问题还是依旧 就是街坏的代码呢 很多大体的代码还是进来了 对吧 因为他并不知道

33:59.890 --> 34:05.650
有公共模块来这 他还是进来了 所以说代码很多 那怎么办呢 接下来最重要的 使用第三步

34:06.450 --> 34:12.610
要使用一个插件叫做deal reference 引用 就是动态链接库引用插件

34:13.650 --> 34:18.910
啊 这个插件 这他怎么用呢 我们先复制过来再解释 好 看一下

34:20.590 --> 34:21.870
非常简单 插件

34:23.710 --> 34:26.750
啊 他也是wepack里面的功能啊 自带的插件 wepack

34:27.390 --> 34:27.870
require

34:29.900 --> 34:33.340
好 那么这个插件里边呢 他有一个配置叫做manifest

34:34.060 --> 34:40.140
什么意思呢 就是告诉他支援清单在哪 他要去检查支援清单 你看我们之前的说的原理啊

34:40.780 --> 34:48.060
他是不是在第二步打包的时候 正常打包的时候呢 是不是要检查支援清单 对吧 他看什么呢 看支援清单里边有没有

34:48.140 --> 34:51.820
有没有匹配上 就是我们的元代码里边 有没有匹配上支援清单里边的模块

34:52.300 --> 34:53.340
好 接下来我们看一下吧

34:54.780 --> 34:59.020
怎么弄啊 比方说我们这里呢 他这个配置有很多方式 可以配置一个

34:59.340 --> 35:04.380
文件的决定路径也可以配置一个就是接成格式 那我们这里用接成格式嘛 直接把一个接成

35:04.780 --> 35:09.580
因为我们知道在load接式里边用require一个接成文件的话 他相当于是把直接把一个接成格式

35:09.900 --> 35:13.100
导出一个对象 那么我这里呢就相当于是导出一个接成对象

35:13.820 --> 35:20.780
啊 导入了什么呢 导入DL目录下面的接query.manifest接成 是不是把接query导入了

35:21.260 --> 35:25.340
好 那么这个东西有什么用呢 到时候他在打包我们的代码的时候呢

35:25.820 --> 35:32.060
他就会留个新样了 你看啊 他打包我们的代码的时候 他一看 哦 原来也在用接query这个模块

35:32.540 --> 35:40.220
哎 正好我们的支援清单里边 正好描述了我们有这个模块 因为我们知道wepack打包了的时候呢

35:40.300 --> 35:45.340
wepack在分析模块的时候呢 他会把这个模块一定会转换成一个模块id 他会转换成这种格式

35:46.860 --> 35:48.380
load modules

35:49.100 --> 35:57.740
然后呢 什么 接query 对吧 然后呢 根据接query里边的package的节省 那么指定他的入口文件在哪 在哪呢 接query里边在这 在这

35:59.100 --> 36:04.300
对吧 接query里边在这 那么他会把转换成这种格式 那么就刚好匹配上了这个

36:04.700 --> 36:09.660
对吧 是不是刚好匹配上了 他的模块id是一样的 那么他发现了 既然这个模块

36:10.140 --> 36:14.220
资源文件资源的清单里边有 说明这个模块呢 是不需要

36:14.860 --> 36:18.460
再加再进入到我们的最终代码 这不需要进入到最终代码

36:19.500 --> 36:25.420
于是呢 他就把这个模块会忽略掉啊 然后把他转换成什么格式呢 我们打包看一下

36:26.380 --> 36:29.660
他会把他转换成什么格式 好 接下来我们看一下啊

36:30.940 --> 36:31.340
np

36:36.270 --> 36:38.670
英雄打包完成 你看一下 每条街市里边

36:39.310 --> 36:45.870
是不是明天少了 之前是2万多号 现在是17000多号 对吧 因为楼单显没有 还没有消除掉啊 楼单显没有消除掉 来看一下吧

36:46.830 --> 36:49.710
啊 结块 你看结块的代码就变得非常简单了

36:50.510 --> 36:58.030
结块的代码变成什么呢 变成直接导出导出什么呢 导出什么呢 啊 导出

36:59.710 --> 37:03.310
一个全局变量啊 结块跑哪去了

37:05.470 --> 37:11.630
导出 导入的是dll reference啊 导入这么的 他是绕了个文啊 导入了这么一个东西

37:12.190 --> 37:15.950
没关系 我们来看一下吧 导入这么一个东西 这个东西导出了是不是一个结块

37:16.270 --> 37:19.710
这个东西哪来的 没有地方来 你看 整个文件里面找不到这个结块 你看吧

37:20.830 --> 37:26.030
整个文件里面代码里面啊 17个嘛 我们看一下 好多是注释啊 结块啊 这个是他的

37:26.750 --> 37:29.710
属性名 对吧 变量你看有没有出现结块的变量

37:30.590 --> 37:33.950
啊 有没有出现结块的变量 是根本就没有的啊 没有的 都是一些

37:34.590 --> 37:37.950
其他的东西 没有出现结块的变量 那么这个变量哪来的

37:38.510 --> 37:45.470
因为这个资源清单表出来的 他就说 你反而是遇到这样的模块呢 你把你就把结块的代码呢 就不要放里边的

37:45.950 --> 37:48.590
然后把它变成直接导出这么一个全局变量 就完事了

37:49.390 --> 37:56.910
就这么个意思 所以说你为什么一面上必须要引用它 一一面上不引用有这个全局变量嘛 就没有包露出这个全局变量 是这么个意思

37:57.950 --> 38:03.710
当然现在我们呢 楼单写没有写决 对吧 楼单写没楼单写能不能再写一个呗 再写一个

38:04.110 --> 38:06.350
楼单写 好 保存 你再看

38:08.430 --> 38:09.550
对 英雄

38:11.630 --> 38:14.270
好 打包完成 打包完成之后呢 你看一下 这边

38:15.070 --> 38:16.030
哎 我们的

38:17.070 --> 38:25.710
整个代码只有100多行 对吧 结块也变成了这样子啊 直接导出一个结块的全局变量 楼单写呢 变成了这样子 导出一个全局变量楼单写

38:26.030 --> 38:30.990
它并不会影响我们的原代码啊 那么这两个变了哪来的 资源清单里面 描述出来的

38:31.470 --> 38:35.870
潜力条件你必须要在一面上沉重引用 好 咱们来看一下吧 能不能运行啊

38:37.550 --> 38:37.790
检查

38:38.750 --> 38:43.470
控制台 你看 是不是得到结果了 Force 表示什么意思呢 表示说

38:44.270 --> 38:44.910
我这个呢

38:46.590 --> 38:49.790
它不是一个数主 不是一个数主 是不是两个发挥作用了

38:50.350 --> 38:55.550
好 当然如果说多入口文件的话是一样的 就是多个窗口的话是一样的

38:56.110 --> 38:59.470
啊 比方说我们这里呢 写个多窗口吧 多个窗口

39:00.910 --> 39:04.750
没有什么区别啊 没有什么区别 n 确 一个窗口呢是妹

39:05.710 --> 39:07.550
来自于src

39:08.350 --> 39:11.630
下面的index的解释啊 一个是呢 other

39:12.190 --> 39:13.310
来自于src

39:13.870 --> 39:14.430
other

39:14.430 --> 39:14.990
解释

39:15.870 --> 39:17.630
啊 然后呢 output

39:20.450 --> 39:20.930
filing

39:22.210 --> 39:23.650
对什么呢 name

39:24.690 --> 39:25.090
第二

39:25.730 --> 39:26.210
哈希

39:26.770 --> 39:27.410
解释

39:27.810 --> 39:28.210
ok

39:29.010 --> 39:31.010
是一样的啊 其他没有做任何改动

39:31.410 --> 39:35.330
那么它只要在分析模后的时候 那两个插件呢 那个插件呢就会发挥作用

39:35.650 --> 39:39.170
它只要看到职员清单里面有的 它就不会进入打包结果 好你看

39:39.890 --> 39:43.730
这两个文件代码都比较少 你看这个代码什么都比较少

39:44.770 --> 39:45.730
啊 就这么个意思

39:46.530 --> 39:47.170
能理解吗

39:48.210 --> 39:52.930
ok 那么这就是关于啊 这一块的啊 这一块的就是

39:53.810 --> 39:55.570
啊 手动分包的方式

39:56.210 --> 39:58.690
好 接下来回到课件 最后做个总结啊

39:59.650 --> 40:01.570
怎么来打包的 首先怎么来操作

40:02.530 --> 40:07.890
首先要分成两步来做 第一步呢 打包打包公共模块 这个这个过程只做一次就行了

40:08.210 --> 40:13.090
除非以后公共模块有变斗 或者是一些新的公共模块需要打包 否则的话只做一次

40:13.970 --> 40:18.210
怎么具体怎么做呢 开启output library 首先呢 包入公共模块

40:18.930 --> 40:20.450
啊 通常使用拳击边上来暴露

40:21.410 --> 40:22.530
然后呢 通过dl

40:23.010 --> 40:25.650
plugin主要是 用它主要是来创建资源清单的

40:26.450 --> 40:31.010
因为呢 以后呢 我们在用的时候呢 会使用这个插件 要使用资源清单

40:32.290 --> 40:33.890
ok 这手动打包的过程

40:34.370 --> 40:35.970
那么要注意的事项呢 就是

40:36.850 --> 40:41.250
资源清单这个东西呢 它是不参与运行的 就到了流产期已经跟它没关系了

40:41.490 --> 40:43.970
它只是影响那个正常的打包过程

40:44.610 --> 40:49.730
所以说呢 你可以不用放到打包 打包木炉里边去 也没有必要放到打包木炉里边去

40:50.930 --> 40:55.330
啊 另外呢 如果说 这个介石你需要手动引用

40:55.650 --> 40:57.730
啊 因为你如果说你不引用啊 你不引用

40:58.130 --> 40:59.730
那么就问题来了

41:00.530 --> 41:01.490
不引用 你看吧

41:05.100 --> 41:06.860
他就保存了 他说介块也不存在

41:07.740 --> 41:11.020
还有那个 如果说介块不保存的话 楼单系要保存 对吧 都存在

41:11.340 --> 41:14.220
没有没有暴露出这个权具变量 你不是说好了吗

41:14.540 --> 41:16.060
因为他这个后续的打包

41:16.540 --> 41:20.540
他这个插件都是基于一个前提条件 就是你已经暴露了相关变量了

41:20.780 --> 41:24.540
所以说我才敢不把这个介块和楼单系放进来

41:24.780 --> 41:25.980
因为你已经暴露出来了

41:26.460 --> 41:29.660
所以说他基于这么一个前提 但是如果说你没有暴露的话 自然出问题

41:30.140 --> 41:31.100
啊 自然要出问题

41:32.060 --> 41:33.340
OK 这是关于这一块

41:35.340 --> 41:37.580
啊 为什么两个 因为我这里需要两个窗口啊

41:38.700 --> 41:42.860
然后呢 不要对小型的公共库使用

41:43.180 --> 41:46.780
啊 不要对小型的公共库使用 因为一些小型的公共库它代码本来就没多少

41:46.940 --> 41:49.820
合并也 虽然是有重复 体积也增加不了多少

41:50.060 --> 41:55.660
不然的话 如果说对很多的小型公共库 而且非常小的一个公共库都使用这样的方式的话

41:55.900 --> 42:00.380
那么反而不好 增加了文件的数量 增加了请求的数量

42:01.580 --> 42:02.540
所以说要试可合制

42:03.420 --> 42:07.500
它的优点自然是不言耳语的 还可以降低文件的体积

42:08.460 --> 42:09.020
提升了

42:09.740 --> 42:13.340
自身模块的打包速度 为什么自身的模块打包速度可以提升

42:13.580 --> 42:15.820
因为我们自身模块呢 根本就不需要去

42:16.220 --> 42:18.060
结块 结块也是不是不需要参与了

42:18.700 --> 42:20.380
啊 楼单系是不是不需要参与了

42:20.780 --> 42:22.860
对吧 直接暴露一个全球变量流行事了

42:23.020 --> 42:25.340
它的代码都不会放进来了 所以说它打包速度呢

42:25.980 --> 42:29.420
打包的东西就很少 所以说它打包的速度会极大地提升

42:30.380 --> 42:33.180
另外呢 它可以缩小自身文件的体积

42:33.340 --> 42:34.780
你看 公共代码提去出去了

42:34.940 --> 42:36.700
如果说过我们有很多的创可

42:36.700 --> 42:38.380
那么每个创可都要用那些公共代码

42:38.780 --> 42:40.300
文件的体积就大幅度缩小了

42:40.460 --> 42:42.700
因为这些创可里面是不包含公共代码的

42:44.140 --> 42:48.060
而且它有利于浏览器缓存第三方库的公共代码

42:48.300 --> 42:49.260
有利于缓存

42:51.020 --> 42:52.300
其他还有一个优点

42:52.620 --> 42:55.980
还有优点是什么呢 就是我们这个可能比较少见一点

42:56.460 --> 43:00.940
就是我们可能自己呢 不去打包任何一个

43:04.320 --> 43:05.840
就是公共的库

43:06.160 --> 43:08.960
不去打包一个任何 就是我们自己不手中去打包公共库

43:08.960 --> 43:10.320
只是生成一个资源清单

43:10.720 --> 43:12.560
哪怕我们自己手写一个资源清单

43:13.360 --> 43:15.680
然后呢 就利用 在页面上利用什么呢

43:15.920 --> 43:19.600
直接去引用 从CDN 从远程去引用一个接块位

43:19.680 --> 43:21.760
或者直接把接块位下载下来 下载到这儿

43:22.000 --> 43:22.960
那些下载到这儿

43:23.120 --> 43:25.120
然后用原式的方式引用 它是不是也可以

43:25.280 --> 43:27.120
对吧 你只总归前面的两句话

43:27.280 --> 43:29.440
只是为了暴露一个权聚变量而已

43:29.760 --> 43:32.240
只是为了暴露权聚变量 其他的没什么

43:33.920 --> 43:36.080
然后它的缺点呢 其实也非常明显

43:36.160 --> 43:37.040
第一个就是凡数

43:37.600 --> 43:38.880
你首先要打包公共代码

43:39.200 --> 43:42.080
然后呢 还要去在页面上手动引用

43:42.560 --> 43:43.280
还要怎么样呢

43:43.440 --> 43:45.760
还要去控制一下这个清除

43:46.080 --> 43:49.600
清除这个查件 避免把一个公共模块清除

43:50.080 --> 43:52.080
这都要手动控制 特别麻烦

43:52.880 --> 43:54.640
而且呢 还会遇到一种情况就是

43:54.960 --> 43:57.760
第三方库中 如果说包含了复杂的依赖关系

43:57.920 --> 43:59.200
那么一个效果又不太明显了

43:59.440 --> 44:01.280
比如说我们比方说 举个例子

44:01.600 --> 44:02.960
我们有A B两个库

44:03.440 --> 44:05.120
要进行单独打包

44:05.600 --> 44:07.440
但是那A呢 又依赖C

44:08.880 --> 44:09.760
又依赖C

44:10.240 --> 44:11.280
C又依赖D

44:11.520 --> 44:12.960
D又依赖F

44:13.600 --> 44:14.400
那么B呢

44:14.640 --> 44:16.160
因为这样子的A里面是不是包装

44:16.320 --> 44:18.320
A打包完了过后是不是会包含CDF

44:18.480 --> 44:20.560
对吧 那么B呢 会依赖D

44:20.720 --> 44:21.520
D又会依赖F

44:21.680 --> 44:24.000
那么B打包完了是不是又要依赖D和F

44:24.320 --> 44:26.560
那么这样子呢 如果说你手动打包就很麻烦了

44:26.880 --> 44:27.840
你还得考虑

44:28.320 --> 44:31.920
再来一个 你还要单独的去再把D要先打包

44:34.160 --> 44:36.160
然后呢 还要单独引用 对吧 意愿上

44:36.480 --> 44:39.600
然后呢 又要让A呢 再去引用C

44:39.760 --> 44:41.280
然后呢 还要同时使用什么

44:41.520 --> 44:43.680
使用刚才的那种方式 使用这边的那种方式

44:44.000 --> 44:47.040
就在打包A和B的时候呢

44:47.200 --> 44:48.160
还要去使用这个东西

44:48.800 --> 44:50.720
避免把D打包进来

44:51.200 --> 44:52.400
就特别特别麻烦

44:52.480 --> 44:53.680
如果说这种依赖关系复杂了

44:54.480 --> 44:56.080
所以说呢 它的应用范围呢

44:56.480 --> 44:58.880
其实比较有限啊 比较有限

44:59.040 --> 45:02.480
不过呢 它不思为一种优化的方式

45:04.000 --> 45:05.200
它最大的好处在于什么

45:05.520 --> 45:08.000
在于可以极大地提升自身模块的打包速度

45:08.080 --> 45:11.520
其实它对那种构建性能呢 也是会产生好处的

45:12.400 --> 45:13.840
它自己的模块就没有必要那么

45:14.160 --> 45:16.560
反复地去打包公共模块了

45:17.200 --> 45:18.320
这是关于手动分包

45:19.200 --> 45:20.720
OK 那么讲到这儿

45:21.360 --> 45:22.720
大家下来去试一下啊

