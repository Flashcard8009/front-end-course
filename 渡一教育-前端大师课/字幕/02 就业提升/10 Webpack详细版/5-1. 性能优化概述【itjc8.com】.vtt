WEBVTT

00:00.690 --> 00:03.690
这一章咱们学习性能优化

00:03.690 --> 00:07.690
性能优化我们这节课首先对它做一个概述

00:07.690 --> 00:09.690
因为很多同学在开发的时候

00:09.690 --> 00:12.690
他既想去提高性能

00:12.690 --> 00:15.690
但是又不知道从何入手

00:15.690 --> 00:17.690
包括我在上公开直播课的时候

00:17.690 --> 00:21.690
发言很多同学也对性能这一课也特别的在意

00:21.690 --> 00:28.690
这可能是一些初学者对性能这一块

00:28.690 --> 00:31.690
不是特别的了解

00:31.690 --> 00:34.690
可能比较关注于性能

00:34.690 --> 00:35.690
当然这是个好事

00:35.690 --> 00:37.690
因为你对不了解的东西充满了好奇

00:37.690 --> 00:40.690
那么我们这节课对性能这一块

00:40.690 --> 00:42.690
给大家提一些基本的概念

00:42.690 --> 00:44.690
要知道我们性能的话

00:44.690 --> 00:47.690
主要从哪些方面去入手去考虑

00:47.690 --> 00:50.690
接下来我们来看一下我们这里的课件

00:50.690 --> 00:53.690
我们在WePAC这一章就是

00:53.690 --> 00:56.690
这个课程里边所说的性能优化

00:56.690 --> 00:59.690
其实性能优化是一个非常大的一个概念

00:59.690 --> 01:01.690
它涉及到方方面面

01:01.690 --> 01:05.690
而很多时候它跟具体的情况是有关系的

01:05.690 --> 01:07.690
就是我们谈性能的话

01:07.690 --> 01:10.690
你不能光谈一个抽象的东西

01:10.690 --> 01:12.690
应该是在具体的情况里边

01:12.690 --> 01:14.690
我们来去谈性能

01:14.690 --> 01:17.690
而我们在这个WePAC这个课程里边

01:17.690 --> 01:20.690
它的性能主要体现在这三个方面

01:20.690 --> 01:21.690
一个是构建性的

01:21.690 --> 01:23.690
一个是传输性的

01:23.690 --> 01:25.690
一个是运行性的

01:25.690 --> 01:27.690
我们来分别看一下

01:27.690 --> 01:29.690
这三个方面分别代表什么样的意识

01:29.690 --> 01:31.690
所谓的性能就是

01:31.690 --> 01:33.690
我们尽量的让某一个人建事情

01:33.690 --> 01:35.690
它的时间减少

01:35.690 --> 01:36.690
就是性能

01:36.690 --> 01:38.690
我们这里首先看构建性能

01:38.690 --> 01:40.690
构建性能是什么意思呢

01:40.690 --> 01:43.690
就是说我们在开发阶段

01:43.690 --> 01:45.690
不是经常会打包吗

01:45.690 --> 01:46.690
对吧

01:46.690 --> 01:47.690
用WePAC来打包

01:47.690 --> 01:49.690
或者是用WePAC的dev server

01:49.690 --> 01:50.690
用开发服务器

01:50.690 --> 01:51.690
它也是在打包

01:51.690 --> 01:54.690
它只不过把它搭建成一个服务器而已

01:54.690 --> 01:58.690
我们指的主要是开发阶段的构建性能

01:58.690 --> 02:01.690
而不是生产环境下的构建性能

02:01.690 --> 02:02.690
为什么呢

02:02.690 --> 02:04.690
大家想想为什么

02:04.690 --> 02:06.690
构建性能是什么意思

02:06.690 --> 02:08.690
就是我们运行一个命令

02:08.690 --> 02:10.690
NPS Webpack

02:10.690 --> 02:12.690
运行这么一个命令

02:12.690 --> 02:17.690
或者是NPS Webpack Dev Server

02:17.690 --> 02:18.690
运行这么一个命令

02:18.690 --> 02:20.690
这个东西是不是纯粹开发阶段的

02:20.690 --> 02:23.690
而这个东西是可以用于生产环境的

02:23.690 --> 02:25.690
生产环境肯定是要用这个命令

02:25.690 --> 02:29.690
那么为什么我们不关注生产环境的构建性能呢

02:29.690 --> 02:33.690
因为我们生产环境的打包是不是很少啊

02:33.690 --> 02:35.690
就是我们开发完了

02:35.690 --> 02:38.690
我们比较说我们一个项目

02:38.690 --> 02:41.690
我们开发完了过后测试了过后都没问题了

02:41.690 --> 02:45.690
我们这个时候才会进行生产环境的构建

02:45.690 --> 02:48.690
或者说我们已经上线了

02:48.690 --> 02:50.690
但是有些功能需要修改

02:50.690 --> 02:52.690
需要增加

02:52.690 --> 02:53.690
需要维护

02:53.690 --> 02:55.690
那么这里我们修改了一些功能

02:55.690 --> 02:56.690
增加了一些功能

02:56.690 --> 02:57.690
测试完了之后

02:57.690 --> 02:59.690
我们再进行生产环境的打包

02:59.690 --> 03:01.690
那么生产环境的打包呢

03:01.690 --> 03:04.690
实际上它的时间是很少的

03:04.690 --> 03:07.690
就是我们很少去进行生产环境的打包

03:07.690 --> 03:10.690
那么哪怕你生产环境打包的时候

03:10.690 --> 03:12.690
打包过一个小时

03:12.690 --> 03:14.690
对你的影响也不会特别的大

03:14.690 --> 03:16.690
因为我们很少

03:16.690 --> 03:20.690
所以说我们主要关注的是开发阶段的构建性能

03:21.690 --> 03:23.690
而开发阶段的构建性能

03:23.690 --> 03:26.690
构建的这个动作是出现的比较频繁的

03:26.690 --> 03:28.690
你看你写一两行代码

03:28.690 --> 03:29.690
可能要看一下效果

03:29.690 --> 03:30.690
是不是要构建一次

03:30.690 --> 03:31.690
要打包一次

03:31.690 --> 03:33.690
写两行代码发现错误了

03:33.690 --> 03:34.690
要改了一下

03:34.690 --> 03:35.690
改了一下你就要看效果

03:35.690 --> 03:37.690
所以说是会频繁的进行打包

03:37.690 --> 03:38.690
可能呢

03:38.690 --> 03:39.690
一个小时内

03:39.690 --> 03:41.690
可能要打包打包个二三十次

03:41.690 --> 03:43.690
那么这个时候呢

03:43.690 --> 03:46.690
如果说你打包的速度过慢的

03:46.690 --> 03:48.690
比如说每次打包夸上一点

03:48.690 --> 03:49.690
要个一分钟

03:49.690 --> 03:51.690
那么这个时候是不是会严重的

03:51.690 --> 03:53.690
影响你开发的效率

03:53.690 --> 03:56.690
所以说我们构建性能这一块

03:56.690 --> 03:58.690
主要关注开发阶段的构建性能

03:58.690 --> 04:00.690
因为它会影响到什么呢

04:00.690 --> 04:02.690
它会影响到我们的开发效率

04:02.690 --> 04:04.690
你不能构建的速度太慢

04:04.690 --> 04:05.690
太慢的话

04:05.690 --> 04:07.690
我们写的大码要看效果

04:07.690 --> 04:08.690
要等慢点

04:08.690 --> 04:09.690
那么这样子呢

04:09.690 --> 04:10.690
会影响我们开发的效率

04:10.690 --> 04:13.690
所以我们构建性能的优化的目标

04:13.690 --> 04:15.690
是降低

04:15.690 --> 04:16.690
从打包开始

04:16.690 --> 04:18.690
就是运行某一个命令

04:18.690 --> 04:19.690
这个命令也好

04:19.690 --> 04:20.690
这个命令也好

04:20.690 --> 04:21.690
运行某一个命令

04:21.690 --> 04:22.690
从打包开始

04:22.690 --> 04:25.690
到代码的效果呈现出来

04:25.690 --> 04:26.690
就是我们能看到

04:26.690 --> 04:27.690
我们代码的出现的效果

04:27.690 --> 04:29.690
就这个阶段的时间

04:29.690 --> 04:30.690
我们要尽量把它降低

04:30.690 --> 04:32.690
这就是构建性能要做的事情

04:32.690 --> 04:34.690
所以我们一切要从实际出发

04:34.690 --> 04:36.690
不能去盲目的追求性能

04:36.690 --> 04:37.690
比方说

04:37.690 --> 04:38.690
有的人说

04:38.690 --> 04:39.690
我们追求开发阶段的构建性能

04:39.690 --> 04:41.690
没有任何意义

04:41.690 --> 04:42.690
因为你开发阶段平时

04:42.690 --> 04:43.690
打包的就没有那么多

04:43.690 --> 04:45.690
就那么偶尔打包一次

04:45.690 --> 04:47.690
可能就几天打包一次

04:48.690 --> 04:49.690
慢一点就慢一点

04:49.690 --> 04:50.690
开发阶段的性能

04:50.690 --> 04:51.690
不在我们的考虑范围之列

04:51.690 --> 04:53.690
我们只关注

04:53.690 --> 04:55.690
生产环境的构建性能

04:56.690 --> 04:57.690
那么这个构建性能

04:57.690 --> 05:00.690
它主要是影响开发效率

05:00.690 --> 05:01.690
我们构建性能越高

05:01.690 --> 05:03.690
那么开发中浪费的时间就越少

05:03.690 --> 05:04.690
因为我们等待这个命令

05:04.690 --> 05:06.690
完成的时间就越少

05:06.690 --> 05:07.690
看到效果的事

05:07.690 --> 05:09.690
距离看到效果的时间就越少

05:09.690 --> 05:10.690
这是构建性能

05:10.690 --> 05:11.690
我们要考虑的事情

05:11.690 --> 05:12.690
所以这个阶段

05:12.690 --> 05:14.690
主要是影响的是开发阶段的构建

05:14.690 --> 05:15.690
开发阶段

05:15.690 --> 05:16.690
而不是生产环节

05:18.690 --> 05:19.690
第二个

05:19.690 --> 05:20.690
传输性能

05:21.690 --> 05:23.690
传输性能影响的是什么呢

05:23.690 --> 05:24.690
它指的是

05:24.690 --> 05:26.690
我们打包之后的一个介石代码

05:26.690 --> 05:29.690
那个东西是最终运行的介石代码

05:29.690 --> 05:30.690
对吧

05:30.690 --> 05:31.690
那个代码放到哪的

05:31.690 --> 05:32.690
是不是放到服务器的

05:32.690 --> 05:33.690
无论是我们的开发服务器

05:33.690 --> 05:36.690
还是在生产环境之后

05:36.690 --> 05:37.690
到了生产环境之后

05:37.690 --> 05:38.690
我们把一个代码

05:38.690 --> 05:39.690
部署到真正的服务器上

05:39.690 --> 05:41.690
我们浏览器访问页面过后

05:41.690 --> 05:43.690
是不是我们的页面里边

05:43.690 --> 05:45.690
我们的ATM页面里边

05:45.690 --> 05:46.690
用过这个scripps元素

05:46.690 --> 05:48.690
去引入一些介石

05:48.690 --> 05:49.690
对吧

05:49.690 --> 05:51.690
是不是去引入

05:51.690 --> 05:54.690
可能有多个元素

05:54.690 --> 05:56.690
可能要去引用一些介石

05:56.690 --> 05:57.690
那么

05:57.690 --> 05:58.690
如果要引用了两个介石

05:58.690 --> 05:59.690
它就要传输两个介石

05:59.690 --> 06:00.690
对吧

06:00.690 --> 06:01.690
这就是传输性能

06:01.690 --> 06:02.690
指的是

06:02.690 --> 06:03.690
我们的介石代码

06:03.690 --> 06:05.690
从服务器传输到浏览器

06:05.690 --> 06:07.690
经过的时间

06:07.690 --> 06:08.690
那么就相当于是网络了

06:08.690 --> 06:09.690
当然这个东西

06:09.690 --> 06:11.690
是不是受到网络环境的影响

06:11.690 --> 06:12.690
对不对

06:12.690 --> 06:13.690
那这个东西怎么优化了

06:13.690 --> 06:14.690
你不能说

06:14.690 --> 06:15.690
跑到用户的电脑上

06:15.690 --> 06:16.690
把它帮它了

06:16.690 --> 06:17.690
把网络环境优化一下

06:17.690 --> 06:18.690
这个做不到的

06:18.690 --> 06:19.690
因此

06:19.690 --> 06:21.690
我们能够做的事情

06:21.690 --> 06:23.690
主要是以下三点

06:23.690 --> 06:26.690
一个是控制总传输量

06:26.690 --> 06:28.690
就是我们最终生成的

06:28.690 --> 06:30.690
介石代码体积越小

06:30.690 --> 06:32.690
是不是传输的东西就越少

06:32.690 --> 06:33.690
传输的东西越少

06:33.690 --> 06:34.690
那么

06:34.690 --> 06:35.690
当然自然而

06:35.690 --> 06:37.690
它的传输的效率

06:37.690 --> 06:38.690
就相对而言

06:38.690 --> 06:39.690
更高一些

06:39.690 --> 06:40.690
就说我们

06:40.690 --> 06:41.690
无论有多少个介石

06:41.690 --> 06:42.690
生成的多少个介石

06:42.690 --> 06:44.690
它的所有内容加起来

06:44.690 --> 06:46.690
就是我们的总传输量

06:46.690 --> 06:48.690
那么你的重复代码

06:48.690 --> 06:49.690
如果越少

06:49.690 --> 06:50.690
那么总传输量就越少

06:50.690 --> 06:51.690
对吧

06:51.690 --> 06:52.690
这就是

06:52.690 --> 06:55.690
我们要控制的传输的性能

06:55.690 --> 06:56.690
好

06:56.690 --> 06:59.690
第二个就是文件的数量

06:59.690 --> 07:00.690
文件的数量

07:00.690 --> 07:03.690
当我们访问页面的时候

07:03.690 --> 07:04.690
如果说你页面

07:04.690 --> 07:05.690
引用了很多的介石

07:05.690 --> 07:06.690
比方说二三十个介石

07:06.690 --> 07:07.690
那么这个时候

07:07.690 --> 07:08.690
介石的传输文件

07:08.690 --> 07:09.690
是不是特别多

07:09.690 --> 07:11.690
而传输的文件很多的话

07:11.690 --> 07:13.690
ATP请求就会越多

07:13.690 --> 07:14.690
我们知道

07:14.690 --> 07:15.690
ATP请求是要经过

07:15.690 --> 07:16.690
三次握手

07:16.690 --> 07:17.690
事实挥手的

07:17.690 --> 07:19.690
那么经过这么

07:19.690 --> 07:21.690
前面这个前奏之后

07:21.690 --> 07:24.690
再去完成具体内容的传输

07:24.690 --> 07:26.690
因此你如果说

07:26.690 --> 07:27.690
请求开的越多

07:27.690 --> 07:30.690
那么它建立连接

07:30.690 --> 07:31.690
三次握手

07:31.690 --> 07:32.690
事实挥手

07:32.690 --> 07:33.690
那么建立连接所

07:33.690 --> 07:35.690
消耗的时间

07:35.690 --> 07:36.690
就会越长

07:36.690 --> 07:37.690
因此

07:37.690 --> 07:38.690
我们还要尽量的

07:38.690 --> 07:41.690
控制一下文件的数量

07:41.690 --> 07:43.690
同时我们又要考虑到

07:43.690 --> 07:44.690
另外一个问题

07:44.690 --> 07:46.690
就是浏览器的缓存

07:46.690 --> 07:50.690
当我们介石文件

07:50.690 --> 07:52.690
被浏览器读取到过后

07:52.690 --> 07:53.690
很多浏览器

07:53.690 --> 07:55.690
它都会把文件缓存起来

07:55.690 --> 07:56.690
让之后

07:56.690 --> 07:58.690
就不要再从服务器去拿了

07:58.690 --> 08:00.690
直接用本地缓存

08:00.690 --> 08:01.690
那么这个问题

08:01.690 --> 08:02.690
我们也要考虑到

08:02.690 --> 08:04.690
可以充分地利用浏览器缓存

08:04.690 --> 08:06.690
让缓存的文件

08:06.690 --> 08:07.690
不再进行传输

08:07.690 --> 08:08.690
这是我们传输性能

08:08.690 --> 08:09.690
要考虑的东西

08:09.690 --> 08:11.690
当然我们要具体讲的时候

08:11.690 --> 08:13.690
才具体地说怎么来去处理

08:13.690 --> 08:15.690
我们目前就打开认识一下

08:15.690 --> 08:18.690
我们性能优化了三个维度

08:18.690 --> 08:21.690
最后一个就是运行性能

08:21.690 --> 08:22.690
这是什么意思呢

08:22.690 --> 08:24.690
就是我们写好的建设

08:24.690 --> 08:25.690
打包之后的假代

08:25.690 --> 08:28.690
它的运行速度

08:28.690 --> 08:29.690
那么这一块

08:29.690 --> 08:31.690
跟WAP倒是关系不大

08:31.690 --> 08:33.690
WAP它只是个打包工具

08:33.690 --> 08:35.690
这个这一方面的性能

08:35.690 --> 08:36.690
主要是取决于

08:36.690 --> 08:39.690
我们如何来输写高性能的代码

08:39.690 --> 08:43.690
比方说我们写一个一万次的循环

08:43.690 --> 08:46.690
就不如写一个一次的循环

08:46.690 --> 08:48.690
或者就没有循环

08:48.690 --> 08:51.690
因为循环它可以反复的运行

08:51.690 --> 08:53.690
它会反复的运行

08:53.690 --> 08:55.690
就是我们如何去优化我们的代码

08:55.690 --> 08:56.690
那么这一块

08:56.690 --> 08:58.690
跟我们这个课程没啥关系了

08:58.690 --> 09:00.690
这主要是取决于我们怎么去写代码

09:00.690 --> 09:01.690
但是这一点

09:01.690 --> 09:03.690
我为什么要提这个运行性能呢

09:03.690 --> 09:05.690
就是因为以前很多同学都在

09:05.690 --> 09:07.690
特别关注于性能这一块

09:07.690 --> 09:09.690
但是我这里要说的

09:09.690 --> 09:10.690
给大家告诉大家的是

09:10.690 --> 09:13.690
永远不要过早的去关注于性能

09:15.690 --> 09:17.690
因为你在开发的时候

09:17.690 --> 09:19.690
你是无法预料

09:19.690 --> 09:22.690
开发完了过后是什么样子

09:22.690 --> 09:23.690
开发完了过后

09:23.690 --> 09:25.690
你这个代码到底会不会影响性能

09:25.690 --> 09:27.690
你是很难预料的

09:27.690 --> 09:29.690
那么你如果说

09:29.690 --> 09:31.690
过早的关注性能的话

09:31.690 --> 09:34.690
就会极大的降低开发效率

09:34.690 --> 09:36.690
我不是给大家开玩笑的

09:36.690 --> 09:37.690
你就往上去收一下

09:37.690 --> 09:39.690
或者是问一下你们开发的

09:39.690 --> 09:40.690
有朋友的话

09:40.690 --> 09:42.690
问一下给你们开发的前辈

09:42.690 --> 09:44.690
单凡真正了解性能优化的

09:44.690 --> 09:46.690
他一定会告诉你

09:46.690 --> 09:48.690
不要过早的去关注于性能

09:48.690 --> 09:50.690
你平时写代码的时候

09:50.690 --> 09:52.690
该怎么写就怎么写

09:52.690 --> 09:53.690
你怎么写

09:53.690 --> 09:54.690
你写代码的时候

09:54.690 --> 09:55.690
你自己觉得

09:55.690 --> 09:58.690
怎么写的舒服你就怎么写

09:58.690 --> 10:00.690
你觉得怎么写的代码优雅

10:00.690 --> 10:02.690
你就怎么写

10:02.690 --> 10:04.690
不要去考虑性能

10:04.690 --> 10:06.690
那么什么时候考虑性能呢

10:06.690 --> 10:08.690
当我们的运行效率

10:08.690 --> 10:10.690
出现问题的时候

10:10.690 --> 10:11.690
你去考虑

10:11.690 --> 10:13.690
我举个例子吧

10:13.690 --> 10:15.690
比方说

10:15.690 --> 10:17.690
有一个代码

10:17.690 --> 10:19.690
你写了一万次循环

10:19.690 --> 10:21.690
一个功能

10:21.690 --> 10:23.690
你写了一万次循环

10:23.690 --> 10:25.690
把它完成了

10:25.690 --> 10:27.690
但是你如果说

10:27.690 --> 10:29.690
你仔细思考的话

10:29.690 --> 10:31.690
你的功能是不需要循环的

10:31.690 --> 10:33.690
可能你可能一百次循环

10:33.690 --> 10:35.690
或者十次循环就可以搞定

10:35.690 --> 10:38.690
这是理想情况

10:38.690 --> 10:40.690
十次循环就可以搞定

10:40.690 --> 10:43.690
但是你书写的实际情况

10:43.690 --> 10:45.690
是一万次循环

10:45.690 --> 10:47.690
那么当时你没有想到

10:47.690 --> 10:48.690
十次循环搞定

10:48.690 --> 10:50.690
那么这个时候

10:50.690 --> 10:52.690
你应该是这样的一种

10:52.690 --> 10:53.690
感觉

10:53.690 --> 10:55.690
就是你写代码的时候

10:55.690 --> 10:57.690
你就写一万次循环

10:57.690 --> 10:59.690
它好写,好理解

10:59.690 --> 11:01.690
而且我容易想到这种书写方式

11:01.690 --> 11:03.690
那么我们用最笨的办法

11:03.690 --> 11:05.690
写一个一万次循环

11:05.690 --> 11:07.690
那么当我们将来运行的时候

11:07.690 --> 11:09.690
通常发现

11:09.690 --> 11:11.690
好像怎么这么卡的那个软件

11:11.690 --> 11:13.690
怎么感觉

11:13.690 --> 11:15.690
感觉就是运行不流畅

11:15.690 --> 11:17.690
有运行效率的问题

11:17.690 --> 11:18.690
那么那个时候

11:18.690 --> 11:19.690
我们再来检查

11:19.690 --> 11:21.690
到底是哪一块出现了运行效率

11:21.690 --> 11:23.690
哪一块耗的时间比较多

11:23.690 --> 11:25.690
我们可以用

11:26.690 --> 11:28.690
time and time start

11:28.690 --> 11:30.690
之类的方式来进行检查

11:30.690 --> 11:32.690
检查每一个函数的运行时间

11:32.690 --> 11:34.690
那么检查完了之后

11:34.690 --> 11:35.690
发现了

11:35.690 --> 11:37.690
原来就是我这个函数

11:37.690 --> 11:39.690
这个函数里面有一万次循环

11:39.690 --> 11:41.690
这个函数里面出现了运行效率的问题

11:41.690 --> 11:43.690
我们再单独来优化这个函数

11:43.690 --> 11:45.690
而当时再来想

11:45.690 --> 11:47.690
这个函数原来可以简化一下

11:47.690 --> 11:49.690
写成十次循环就会搞定

11:49.690 --> 11:50.690
然后效率就优化了

11:50.690 --> 11:52.690
不要过早的去

11:52.690 --> 11:54.690
做这件事情

11:54.690 --> 11:55.690
可能很复杂

11:55.690 --> 11:56.690
你可能不太容易想到

11:56.690 --> 11:57.690
可能会花很多时间

11:57.690 --> 11:59.690
包括整个团队的时间

11:59.690 --> 12:01.690
都会在好在地边

12:01.690 --> 12:03.690
因为有可能会出现这种情况就是

12:03.690 --> 12:05.690
你到时候最终运行的时候发现

12:05.690 --> 12:07.690
没有效率问题

12:07.690 --> 12:08.690
运行的很流畅的

12:08.690 --> 12:09.690
总的运行时间

12:09.690 --> 12:10.690
响应时间

12:10.690 --> 12:12.690
都是符合我们产品的最终要求的

12:12.690 --> 12:13.690
那就没有问题了

12:13.690 --> 12:15.690
一万十一就一万次循环

12:15.690 --> 12:16.690
怎么样

12:16.690 --> 12:17.690
它提高了我们的开发效率

12:17.690 --> 12:19.690
让我们的代码更加好理解

12:19.690 --> 12:20.690
对不对

12:20.690 --> 12:22.690
所以说我们不用

12:22.690 --> 12:25.690
过于去在意这个事情

12:25.690 --> 12:27.690
而且对于初学者而言

12:27.690 --> 12:29.690
性能优化这一块

12:29.690 --> 12:32.690
往往是在最后做的

12:32.690 --> 12:33.690
最后做的

12:33.690 --> 12:34.690
而对于初学者而言

12:34.690 --> 12:36.690
刚刚到了公司

12:36.690 --> 12:37.690
刚刚入职

12:37.690 --> 12:40.690
他不太会让你去做这个性能优化

12:40.690 --> 12:41.690
不太会让你去做

12:41.690 --> 12:42.690
所以说你们写代码

12:42.690 --> 12:43.690
一定要多从什么

12:43.690 --> 12:45.690
代码的优雅程度

12:45.690 --> 12:47.690
魔幻花粉是不是合适

12:47.690 --> 12:48.690
已经我们代码

12:48.690 --> 12:49.690
是不是容易被阅读

12:49.690 --> 12:51.690
一定要多从这方面去入省

12:51.690 --> 12:53.690
而不要老是去想着性能

12:53.690 --> 12:55.690
包括我们之前说

12:55.690 --> 12:56.690
地规

12:56.690 --> 12:59.690
地规是不是有个伪地规优化

12:59.690 --> 13:00.690
伪地规优化

13:00.690 --> 13:01.690
你写地规的时候

13:01.690 --> 13:03.690
要不要去直接用伪地规优化

13:03.690 --> 13:04.690
不要千万不要

13:04.690 --> 13:05.690
我求求你们了

13:05.690 --> 13:06.690
千万不要

13:06.690 --> 13:07.690
因为伪地规优化出来的代码

13:07.690 --> 13:09.690
是很难阅读的

13:09.690 --> 13:10.690
相当难以阅读

13:10.690 --> 13:11.690
那就是

13:11.690 --> 13:13.690
不是人读的代码

13:13.690 --> 13:15.690
所以说你不要去写

13:15.690 --> 13:16.690
伪地规优化

13:16.690 --> 13:18.690
当它真正的出现问题的时候

13:18.690 --> 13:19.690
我发现这个地规

13:19.690 --> 13:20.690
好像

13:20.690 --> 13:22.690
确实出现问题的

13:22.690 --> 13:24.690
包括了执行站你都溢出了

13:24.690 --> 13:25.690
那么这个时候

13:25.690 --> 13:27.690
你再去考虑伪地规优化

13:27.690 --> 13:29.690
不要过早的去做这件事

13:29.690 --> 13:30.690
过早的去关注性能

13:30.690 --> 13:32.690
是灾难的开始

13:33.690 --> 13:34.690
所以说

13:34.690 --> 13:35.690
运行性能

13:35.690 --> 13:37.690
我单独拎出来讲一下

13:37.690 --> 13:38.690
就是

13:38.690 --> 13:40.690
给大家说明这个道理

13:40.690 --> 13:41.690
不要过早的去关注性能

13:41.690 --> 13:43.690
代码怎么优雅怎么写

13:43.690 --> 13:45.690
结构怎么合适怎么写

13:45.690 --> 13:47.690
怎么好阅读怎么写

13:47.690 --> 13:48.690
怎么好维护怎么写

13:48.690 --> 13:49.690
不要关注性能

13:49.690 --> 13:51.690
性能最后做

13:51.690 --> 13:52.690
运行性能

13:52.690 --> 13:53.690
不在我们

13:53.690 --> 13:55.690
vipack的好对范围之间

13:57.690 --> 13:58.690
我们的

13:58.690 --> 13:59.690
vipack的性能优化

13:59.690 --> 14:01.690
主要从上面三个维度作手

14:01.690 --> 14:02.690
主要是这两个维度

14:02.690 --> 14:04.690
构建性能和传输性能

14:04.690 --> 14:05.690
性能优化

14:05.690 --> 14:06.690
首先告诉大家

14:06.690 --> 14:08.690
是没有完美解决办法的

14:08.690 --> 14:09.690
因为不能

14:09.690 --> 14:10.690
不能问

14:10.690 --> 14:11.690
就是性能优化

14:11.690 --> 14:12.690
最好的办法是什么

14:12.690 --> 14:14.690
没有这个答案

14:14.690 --> 14:15.690
因为它一定是具体情况

14:15.690 --> 14:16.690
具体分析

14:16.690 --> 14:17.690
你想一想

14:17.690 --> 14:18.690
如果说性能优化

14:18.690 --> 14:20.690
有完美的解决办法

14:20.690 --> 14:21.690
你们都不用学了

14:21.690 --> 14:22.690
学都不用学了

14:22.690 --> 14:23.690
因为已经有一些

14:23.690 --> 14:24.690
第三方工具

14:24.690 --> 14:25.690
全部给你做好了

14:25.690 --> 14:27.690
vipack都直接给你做好了

14:28.690 --> 14:29.690
就是因为它没有

14:29.690 --> 14:30.690
完美的解决办法

14:30.690 --> 14:31.690
需要具体情况

14:31.690 --> 14:32.690
具体分析

14:32.690 --> 14:33.690
因此

14:34.690 --> 14:36.690
它才需要你们学习

14:36.690 --> 14:38.690
vipack有些第三方库

14:38.690 --> 14:39.690
才没有帮你解决

14:39.690 --> 14:40.690
这些东西

14:40.690 --> 14:41.690
因为它解决不了

14:41.690 --> 14:42.690
它不知道你

14:42.690 --> 14:43.690
是具体什么情况

14:43.690 --> 14:44.690
当然我们这一张

14:44.690 --> 14:46.690
学习的性能优化

14:46.690 --> 14:48.690
可能对大家来说

14:48.690 --> 14:49.690
也只是扩展一下

14:49.690 --> 14:51.690
事业多了解一些东西

14:51.690 --> 14:52.690
有可能的面试的时候

14:52.690 --> 14:54.690
有可能会问到

14:54.690 --> 14:55.690
等到真的

14:55.690 --> 14:56.690
真的在你们以后

14:56.690 --> 14:57.690
具体的开发中

14:57.690 --> 14:59.690
实际上用的不多

14:59.690 --> 15:00.690
当然你们实际上

15:00.690 --> 15:01.690
是初级开发者

15:01.690 --> 15:02.690
以后成为

15:02.690 --> 15:03.690
高级科工程师过后

15:03.690 --> 15:04.690
肯定要考虑

15:04.690 --> 15:05.690
但是刚开始的时候

15:05.690 --> 15:07.690
刚开始入职的时候

15:07.690 --> 15:08.690
不用你去考虑

15:08.690 --> 15:09.690
这些问题

15:09.690 --> 15:10.690
当然你要了解

15:10.690 --> 15:12.690
了解得越多越好

15:12.690 --> 15:13.690
这是关于

15:13.690 --> 15:15.690
我们为Pack的性能优化

15:15.690 --> 15:16.690
主要是构建性能

15:16.690 --> 15:17.690
和传输性能

15:17.690 --> 15:18.690
就是想办法

15:18.690 --> 15:20.690
怎么样打包了速度更快

15:20.690 --> 15:21.690
又要想办法

15:21.690 --> 15:23.690
要尽量的保证

15:23.690 --> 15:25.690
文件的体积越小

15:25.690 --> 15:26.690
已经充分的利用

15:26.690 --> 15:28.690
流量性缓存

15:28.690 --> 15:29.690
为什么说没有

15:29.690 --> 15:30.690
完美的解决方案

15:30.690 --> 15:32.690
因为他们会相互影响

15:32.690 --> 15:33.690
有的时候

15:33.690 --> 15:35.690
你要提高传输性能

15:35.690 --> 15:37.690
你就要牺牲构建性能

15:37.690 --> 15:39.690
有的时候你提高构建性能

15:39.690 --> 15:41.690
你要牺牲传输性能

15:41.690 --> 15:43.690
没有那种完美的办法

15:43.690 --> 15:44.690
OK

15:44.690 --> 15:45.690
那么这次关于这几颗

15:45.690 --> 15:47.690
简单介绍一下关于性能优化

15:47.690 --> 15:48.690
因为很多同学对一些东西

15:48.690 --> 15:49.690
是没有概念的

