WEBVTT

00:00.690 --> 00:06.690
说实话 我呢不是很想讲这节课

00:06.690 --> 00:11.690
但是呢 之前老师有同学在问

00:11.690 --> 00:16.690
就是说Yes and Yes7里边那个而Think await

00:16.690 --> 00:18.690
到底是怎么实现的

00:18.690 --> 00:21.690
因为我们知道Yes5它是没有这样的语法的

00:21.690 --> 00:24.690
它肯定要把它转换成相应的API

00:24.690 --> 00:26.690
因为这个语法它就不支持

00:26.690 --> 00:28.690
它只能把这个语法去掉

00:28.690 --> 00:31.690
给它转换成相应的API来实现

00:31.690 --> 00:34.690
这个玩意特别复杂

00:34.690 --> 00:36.690
可能这节课

00:36.690 --> 00:38.690
因为这个课首先是个扩展课

00:38.690 --> 00:39.690
大家不要有任何的心理压力

00:39.690 --> 00:41.690
看不懂就算了

00:41.690 --> 00:46.690
因为我是要解答一些好奇心比较重的同学

00:46.690 --> 00:48.690
当然我首先赞扬这样的行为

00:48.690 --> 00:51.690
好奇心重 喜欢技术

00:51.690 --> 00:53.690
真的是一件非常非常棒的一件事

00:53.690 --> 00:57.690
但是技术它确实你学习的时候

00:57.690 --> 00:59.690
它也需要一个过程

00:59.690 --> 01:02.690
因为大家现在是初学者

01:02.690 --> 01:05.690
因此你现在去理解这个

01:05.690 --> 01:07.690
太难了 真的是太难了

01:07.690 --> 01:10.690
可能这节课能够有1%的同学能听懂

01:10.690 --> 01:13.690
就非常非常不错了

01:13.690 --> 01:15.690
我们之前其实呢

01:15.690 --> 01:19.690
实现过而Think await这样的一个东西

01:19.690 --> 01:21.690
不知道大家还记不记得

01:21.690 --> 01:25.690
我在讲那个Yes6的时候

01:25.690 --> 01:28.690
我讲过一个东西叫做迭代器和生成器

01:28.690 --> 01:29.690
可能有些同学呢

01:29.690 --> 01:30.690
这个东西都忘了差不多了

01:30.690 --> 01:31.690
因为这个确实啊

01:31.690 --> 01:33.690
这个东西平时也没这么用

01:33.690 --> 01:36.690
当时我特别说了这么一句话

01:36.690 --> 01:37.690
就说我说啊

01:37.690 --> 01:40.690
Yes7出来之前

01:40.690 --> 01:42.690
我们要实现而Think await

01:42.690 --> 01:44.690
当时还没有这个都教法

01:44.690 --> 01:45.690
对吧

01:45.690 --> 01:46.690
我们为了解

01:46.690 --> 01:49.690
为了更加方便的来处理

01:49.690 --> 01:50.690
这些东西

01:50.690 --> 01:53.690
我们往往会利用这个生成器

01:53.690 --> 01:55.690
我们当时还写断代嘛

01:55.690 --> 01:56.690
大家记得吗

01:56.690 --> 02:00.690
就是我用eo的来代表而Think await

02:00.690 --> 02:02.690
这东西来代表而wait

02:02.690 --> 02:05.690
就是用这个eo的来代表而wait

02:05.690 --> 02:07.690
用这个型号呢

02:07.690 --> 02:08.690
来表示而Think

02:08.690 --> 02:10.690
我就这么个意思

02:10.690 --> 02:12.690
用这种方式呢

02:12.690 --> 02:15.690
就是用这个eo的来代表而wait

02:15.690 --> 02:17.690
用这个型号呢

02:18.690 --> 02:20.690
用这种方式呢

02:20.690 --> 02:22.690
你看我们用fetchapi对吧

02:22.690 --> 02:24.690
这里反回的也是个promise

02:24.690 --> 02:27.690
那么仍然可以实现异步的控制

02:27.690 --> 02:30.690
不用毁掉寒树来实现异步控制

02:30.690 --> 02:32.690
当时我们是用了一个寒树

02:32.690 --> 02:33.690
我们自己写了一个寒树

02:33.690 --> 02:35.690
这一会可能有些人已经忘了

02:35.690 --> 02:37.690
可以自己去发言一下

02:37.690 --> 02:39.690
其实这个寒树的实现呢

02:39.690 --> 02:42.690
它的原理其实特别简单

02:42.690 --> 02:43.690
什么原理呢

02:43.690 --> 02:45.690
就是不断的调用这个生成器

02:45.690 --> 02:47.690
它不是反回一个迭代器吗

02:47.690 --> 02:48.690
它不断的迭代

02:48.690 --> 02:49.690
下一步 下一步 下一步

02:49.690 --> 02:50.690
直到它完了

02:50.690 --> 02:51.690
完了过后干嘛呢

02:51.690 --> 02:53.690
完了过后我就result

02:53.690 --> 02:55.690
我就结束

02:55.690 --> 02:58.690
其实我们就是利用这样的思路来实现的

02:58.690 --> 02:59.690
你看一下这

02:59.690 --> 03:01.690
这里我们写了一个寒树

03:01.690 --> 03:02.690
这个寒树反回一个promise

03:02.690 --> 03:04.690
一秒钟之后呢result53

03:04.690 --> 03:05.690
这个寒树没什么好说的

03:05.690 --> 03:07.690
这个寒树在bibol里边

03:07.690 --> 03:08.690
进行转化

03:08.690 --> 03:09.690
转化啥呀

03:09.690 --> 03:11.690
我看一下吧

03:11.690 --> 03:14.690
这个寒树其实它不会进行任何的转化

03:15.690 --> 03:18.380
试一试

03:33.140 --> 03:36.140
你看它这个寒树它其实不会进行任何的转化

03:36.140 --> 03:38.140
不要放大一点

03:38.140 --> 03:39.140
为什么不转化呢

03:39.140 --> 03:40.140
我们之前也说过

03:40.140 --> 03:42.140
bibol它对这种新的API

03:42.140 --> 03:44.140
它不会做转化的

03:44.140 --> 03:46.140
如果说你要对新的API

03:46.140 --> 03:49.140
你怕一些老版本的流弹器有问题

03:49.140 --> 03:50.140
OK你使用什么

03:50.140 --> 03:52.140
使用什么库来支持

03:54.140 --> 03:56.140
是不是要使用这个core.js

03:56.140 --> 03:59.140
core.js里边它就对那些新的API

03:59.140 --> 04:00.140
全部都有实现

04:00.140 --> 04:02.140
它也把这个promise

04:02.140 --> 04:03.140
也可以重新写过了

04:03.140 --> 04:05.140
那么关于promise怎么写

04:05.140 --> 04:07.140
是不是我在es6的时候就讲过了

04:07.140 --> 04:09.140
我在es6的时候

04:09.140 --> 04:11.140
我就讲过这个promise怎么写

04:11.140 --> 04:13.140
一不处理

04:13.140 --> 04:14.140
说promise呢

04:14.140 --> 04:16.140
熟悉promise我之前讲过的

04:16.140 --> 04:18.140
所以说不再重复了

04:18.140 --> 04:21.140
当然我之前讲的版本了比较简单

04:21.140 --> 04:24.140
也没有完整的把所有的API

04:24.140 --> 04:25.140
全部实现

04:25.140 --> 04:26.140
就是给大家提供这么一个思路

04:26.140 --> 04:28.140
它就是按照这样的思路来实现的

04:28.140 --> 04:29.140
要说复杂吧

04:29.140 --> 04:30.140
也确实复杂

04:30.140 --> 04:32.140
因为那个课程也是一个扩展课程

04:32.140 --> 04:33.140
总之呢

04:33.140 --> 04:35.140
这个promise是可以实现的

04:35.140 --> 04:37.140
可以手动实现的

04:37.140 --> 04:39.140
它就是一个构造函数而已

04:39.140 --> 04:41.140
installbibol它不会对这种东西进行转化

04:41.140 --> 04:43.140
它转化的主要是语法

04:44.140 --> 04:46.140
那么你就说这个函数

04:46.140 --> 04:47.140
promise

04:47.140 --> 04:49.140
bibol是不会进行转换的

04:49.140 --> 04:51.140
这个函数它会转换

04:51.140 --> 04:53.140
这个函数它一定会转换

04:53.140 --> 04:55.140
因为这个函数呢

04:55.140 --> 04:57.140
它怎么转换呢

04:57.140 --> 04:58.140
其实它的思路

04:58.140 --> 05:00.140
我之前好像在哪节课的时候说过

05:00.140 --> 05:03.140
凡是遇到ersync而wait这种函数

05:03.140 --> 05:05.140
它的思路就是

05:05.140 --> 05:08.140
搞一个生成器出来

05:08.140 --> 05:10.140
用我们之前学过的

05:10.140 --> 05:12.140
利用生成器这种

05:13.140 --> 05:15.140
里边有什么e or the next

05:15.140 --> 05:16.140
这种东西对吧

05:16.140 --> 05:17.140
来完成异部控制

05:17.140 --> 05:20.140
它就是按照这样的思路来做的

05:20.140 --> 05:21.140
比方说吧

05:21.140 --> 05:23.140
我们就这个函数

05:23.140 --> 05:25.140
就这个函数它会把它变成一个啥玩意儿呢

05:25.140 --> 05:29.670
它会把它变成这么一个东西

05:29.670 --> 05:31.670
它会把它变成这个

05:35.370 --> 05:36.370
变成这么一个东西

05:36.370 --> 05:38.370
当然最终转换出来的单码不是这个

05:38.370 --> 05:39.370
我再说一下

05:39.370 --> 05:41.370
它就它原理上

05:41.370 --> 05:42.370
它就会把它变成这个东西

05:42.370 --> 05:43.370
比方说有这么一个函数

05:43.370 --> 05:45.370
你看一下我们怎么做

05:45.370 --> 05:47.370
就是没有sync

05:47.370 --> 05:48.370
没有e or wait

05:48.370 --> 05:49.370
它就是这么一个函数

05:49.370 --> 05:51.370
这是一个生成器函数

05:51.370 --> 05:53.370
那它怎么来实现异部控制呢

05:53.370 --> 05:54.370
它就这样子

05:54.370 --> 05:56.370
我们来模拟它的处理方式

05:56.370 --> 05:57.370
它怎么处理呢

05:57.370 --> 05:58.370
它首先调用这个函数

05:58.370 --> 06:00.370
是不是可以生成一个生成器

06:00.370 --> 06:01.370
对吧

06:01.370 --> 06:02.370
我们知道

06:02.370 --> 06:03.370
它并不会

06:03.370 --> 06:04.370
这个单码有没有执行

06:04.370 --> 06:05.370
回顾一下

06:05.370 --> 06:06.370
是不是没有执行

06:06.370 --> 06:08.370
它只是得到一个生成器而已

06:08.370 --> 06:09.370
好 得到这个生成器过后

06:09.370 --> 06:11.370
这个生成器里边不是有 next

06:11.370 --> 06:13.370
调用一次

06:13.370 --> 06:14.370
这里a 是吧

06:14.370 --> 06:15.370
a 这个函数还没写进来

06:15.370 --> 06:16.370
好 来吧

06:16.370 --> 06:18.370
我们把这个a 放过来

06:19.370 --> 06:21.370
这里重新来一次

06:21.370 --> 06:23.370
关了

06:23.370 --> 06:24.370
这边呢

06:24.370 --> 06:26.370
这一块很复杂

06:26.370 --> 06:28.370
大家不要有什么压力

06:28.370 --> 06:29.370
这块不懂

06:29.370 --> 06:30.370
完全不懂的话

06:30.370 --> 06:31.370
我刚刚告诉你

06:31.370 --> 06:32.370
99%的成员

06:32.370 --> 06:33.370
它都没搞清楚

06:33.370 --> 06:34.370
它怎么去实现

06:34.370 --> 06:37.370
不用我们的一个特别在意

06:37.370 --> 06:38.370
那么这里呢

06:38.370 --> 06:39.370
我们得到一个

06:39.370 --> 06:41.370
b

06:41.370 --> 06:42.370
得到一个生成器

06:42.370 --> 06:43.370
对吧

06:43.370 --> 06:44.370
这个生成器

06:44.370 --> 06:45.370
好 接下来呢

06:45.370 --> 06:46.370
我们来继续看

06:46.370 --> 06:47.370
它生成器里边

06:47.370 --> 06:48.370
是不是

06:48.370 --> 06:49.370
生成器里边不是有一个 next

06:49.370 --> 06:50.370
方法吗

06:50.370 --> 06:51.370
那个是方法

06:51.370 --> 06:52.370
一定要用

06:52.370 --> 06:53.370
是不是得到一个 value

06:53.370 --> 06:54.370
是不是得到这个结果

06:54.370 --> 06:55.370
对吧

06:55.370 --> 06:56.370
是不是得到这个结果

06:56.370 --> 06:57.370
对不对

06:57.370 --> 06:59.370
是不是得到一个

06:59.370 --> 07:01.370
是不是得到这个结果

07:01.370 --> 07:02.370
promise

07:02.370 --> 07:03.370
对吧

07:03.370 --> 07:04.370
得到 promise

07:04.370 --> 07:05.370
好 来吧

07:05.370 --> 07:06.370
如果说

07:06.370 --> 07:08.370
这个 promise 完成之后

07:08.370 --> 07:09.370
这个 promise 我等它完成

07:09.370 --> 07:10.370
完成之后

07:10.370 --> 07:11.370
那么我把

07:11.370 --> 07:13.370
结果放到 b 里边

07:13.370 --> 07:14.370
对吧

07:14.370 --> 07:15.370
放到这个表

07:15.370 --> 07:16.370
是里边

07:16.370 --> 07:17.370
那怎么写就代码

07:17.370 --> 07:18.370
接下来怎么写

07:18.370 --> 07:20.370
我已经重新来一次

07:20.370 --> 07:21.370
重新来一次

07:21.370 --> 07:25.000
好 先把这个东西

07:25.000 --> 07:26.000
放过来

07:26.000 --> 07:27.000
然后得到一个生成器

07:27.000 --> 07:30.000
b

07:30.000 --> 07:31.000
得到一个生成器 b

07:31.000 --> 07:33.000
得到生成器过后

07:33.000 --> 07:34.000
生成器就可以

07:34.000 --> 07:35.000
调用 next 方法

07:35.000 --> 07:36.000
首次调用

07:36.000 --> 07:37.000
我们把结果

07:37.000 --> 07:38.000
放到一个

07:38.000 --> 07:39.000
值里边

07:40.000 --> 07:45.000
得到 next value

07:45.000 --> 07:47.000
通过生成器调用 next

07:47.000 --> 07:48.000
对吧

07:48.000 --> 07:49.000
得到 next

07:49.000 --> 07:50.000
那么我们看一下

07:50.000 --> 07:51.000
这个变量值

07:51.000 --> 07:52.000
是不是这个东西

07:52.000 --> 07:53.000
对吧

07:53.000 --> 07:54.000
这里边

07:54.000 --> 07:55.000
它的值是不是这个

07:55.000 --> 07:56.000
A

07:56.000 --> 07:57.000
是不是这个东西

07:57.000 --> 07:58.000
这个东西返回的结果

07:58.000 --> 07:59.000
对吧

07:59.000 --> 08:00.000
还记得吗

08:00.000 --> 08:01.000
当然表示 force

08:01.000 --> 08:02.000
还没完成

08:02.000 --> 08:03.000
就整个还说

08:03.000 --> 08:04.000
还没有执行完

08:04.000 --> 08:06.000
那么这个 promise 完成之后

08:06.000 --> 08:07.000
我是不是要把

08:07.000 --> 08:08.000
这个 promise 完成之后

08:08.000 --> 08:09.000
把整个值

08:09.000 --> 08:10.000
放到这儿

08:10.000 --> 08:11.000
继续给 b 付值

08:11.000 --> 08:12.000
好 来吧

08:12.000 --> 08:13.000
我们怎么来做呢

08:13.000 --> 08:17.000
就可以利用 promise result

08:17.000 --> 08:20.000
把 next value

08:20.000 --> 08:22.000
第二 value 传进去

08:22.000 --> 08:23.000
这样子

08:23.000 --> 08:24.000
是不是产生一个

08:24.000 --> 08:27.000
产生一个就是

08:27.000 --> 08:28.000
其实这样子

08:28.000 --> 08:29.000
好像有点多余

08:29.000 --> 08:30.000
对吧

08:30.000 --> 08:31.000
那么这种协防

08:31.000 --> 08:32.000
我们之前讲过

08:32.000 --> 08:33.000
这种协防跟那个

08:33.000 --> 08:34.000
跟这个协防是一样的

08:34.000 --> 08:35.000
对吧

08:35.000 --> 08:36.000
因为你

08:36.000 --> 08:37.000
如果说你传那个 promise 进去

08:37.000 --> 08:38.000
这个整个还说

08:38.000 --> 08:39.000
它返回来就是一个 promise

08:39.000 --> 08:41.000
就是你传的那个 promise

08:41.000 --> 08:42.000
那么就相当于

08:42.000 --> 08:44.000
这个东西是不是 promise

08:44.000 --> 08:45.000
promise 完

08:45.000 --> 08:46.000
那如果说你那个

08:46.000 --> 08:47.000
当然如果说这个 value

08:47.000 --> 08:48.000
它不是 promise

08:48.000 --> 08:50.000
比方说这里写了个 e

08:50.000 --> 08:52.000
比方说这里写了个 e

08:52.000 --> 08:53.000
那么这里

08:53.000 --> 08:54.000
那就相当于是个 e

08:54.000 --> 08:56.000
那么就是产生一个 promise

08:56.000 --> 08:57.000
结果就是直接

08:57.000 --> 08:58.000
就是完成的 promise

08:58.000 --> 09:00.000
那么它的 value 值就是 e

09:00.000 --> 09:01.000
完成之后

09:01.000 --> 09:02.000
resolve 的值就是 e

09:02.000 --> 09:03.000
然后如果说

09:03.000 --> 09:04.000
你传了一个 promise 进去

09:04.000 --> 09:05.000
那么得到的远方

09:05.000 --> 09:06.000
不弄的就是 promise

09:06.000 --> 09:07.000
那么这样的远方

09:07.000 --> 09:09.000
还可以保证整个代码

09:09.000 --> 09:10.000
它一定返回 a promise

09:10.000 --> 09:11.000
对吧

09:11.000 --> 09:12.000
它就不用去判断

09:12.000 --> 09:13.000
这个东西到底是不是 promise

09:13.000 --> 09:14.000
它一定返回 a promise

09:14.000 --> 09:15.000
好

09:15.000 --> 09:16.000
那么这样子的

09:16.000 --> 09:17.000
是不是得到 a promise

09:17.000 --> 09:18.000
那么这个 promise

09:18.000 --> 09:19.000
我等它完成

09:19.000 --> 09:20.000
完成之后

09:20.000 --> 09:21.000
怎么办呢

09:21.000 --> 09:22.000
完成之后

09:22.000 --> 09:23.000
好

09:23.000 --> 09:24.000
完成之后

09:24.000 --> 09:25.000
我是不是把这个

09:25.000 --> 09:26.000
完成的值

09:26.000 --> 09:28.000
传给下一个 next

09:28.000 --> 09:29.000
对吧

09:29.000 --> 09:30.000
next

09:30.000 --> 09:32.000
对不对

09:32.000 --> 09:35.000
然后我给这个

09:35.000 --> 09:37.000
我又得到一个 next value

09:37.000 --> 09:38.000
对不对

09:38.000 --> 09:40.000
是不是这样子的

09:40.000 --> 09:41.000
好

09:41.000 --> 09:42.000
那么现在接下来

09:42.000 --> 09:43.000
我们来看一下

09:43.000 --> 09:46.000
这个 next value

09:46.000 --> 09:47.000
是吧

09:47.000 --> 09:48.000
是不是又得到 a promise

09:48.000 --> 09:49.000
那么这个时候

09:49.000 --> 09:50.000
我们

09:50.000 --> 09:52.000
因为交流量下一次

09:52.000 --> 09:53.000
都把倒到这了

09:53.000 --> 09:54.000
又是一个 a

09:54.000 --> 09:55.000
对不对

09:55.000 --> 09:56.000
又是一个 a

09:56.000 --> 09:57.000
那么又是 a promise

09:57.000 --> 09:58.000
那么我们是不是

09:58.000 --> 09:59.000
又来一次

09:59.000 --> 10:00.000
又来一次

10:00.000 --> 10:01.000
反复了这样来

10:01.000 --> 10:02.000
好

10:02.000 --> 10:03.000
然后我们再看

10:04.000 --> 10:05.000
啊

10:05.000 --> 10:06.000
那个是 value

10:06.000 --> 10:10.020
那么现在是不是得到 6

10:10.020 --> 10:11.020
对吧

10:11.020 --> 10:12.020
3加3

10:12.020 --> 10:13.020
没事

10:13.020 --> 10:14.020
3 是不是等于 6

10:14.020 --> 10:15.020
那么这个时候

10:15.020 --> 10:16.020
当为出了

10:16.020 --> 10:17.020
好 当为出干嘛

10:17.020 --> 10:18.020
干嘛呢

10:18.020 --> 10:19.020
就整个就结束了

10:19.020 --> 10:20.020
整个的失路

10:20.020 --> 10:21.020
它就是按照这样来说的

10:21.020 --> 10:23.020
说它手根肯定要

10:23.020 --> 10:24.020
搬到一件事

10:24.020 --> 10:26.020
就是要把这个东西

10:26.020 --> 10:28.020
就是要把这个东西

10:28.020 --> 10:29.020
把我们的 async

10:29.020 --> 10:30.020
而未成的东西

10:30.020 --> 10:33.020
转换成这种格式

10:33.020 --> 10:34.020
但是这种格式

10:34.020 --> 10:36.020
是不是也是新余法

10:36.020 --> 10:37.020
也是无力表

10:37.020 --> 10:38.020
有这种余法吗

10:38.020 --> 10:39.020
是没有

10:39.020 --> 10:40.020
没有这种余法

10:40.020 --> 10:41.020
对吧

10:41.020 --> 10:42.020
也是无力表

10:42.020 --> 10:43.020
是没有这种余法的

10:43.020 --> 10:44.020
哎

10:44.020 --> 10:45.020
那这种余法

10:45.020 --> 10:46.020
又怎么办呢

10:46.020 --> 10:47.020
那么这种余法

10:47.020 --> 10:48.020
它又要进行转换

10:48.020 --> 10:49.020
所以它又

10:49.020 --> 10:50.020
它要怎么集中

10:50.020 --> 10:51.020
转换步骤

10:51.020 --> 10:52.020
首先它要把这个东西

10:52.020 --> 10:53.020
转换成它

10:53.020 --> 10:54.020
然后再把它又来

10:54.020 --> 10:55.020
进行转换

10:55.020 --> 10:56.020
那这个东西

10:56.020 --> 10:57.020
转换过后又是啥呢

10:57.020 --> 10:58.020
这个东西

10:58.020 --> 10:59.020
转换过后又是啥呢

10:59.020 --> 11:00.020
给大家看一下

11:00.020 --> 11:01.020
这个东西

11:01.020 --> 11:02.020
转换过后

11:02.020 --> 11:03.020
它是怎么玩的

11:03.020 --> 11:05.020
这个东西转换之后

11:05.020 --> 11:06.020
它变成了

11:06.020 --> 11:07.020
这么一坨代码

11:07.020 --> 11:09.020
这个代码大家看得懂吗

11:09.020 --> 11:10.020
对不起

11:10.020 --> 11:11.020
大家看不懂

11:11.020 --> 11:12.020
看不懂

11:12.020 --> 11:14.020
为什么代码大家看不懂呢

11:14.020 --> 11:16.020
因为它里边用到了

11:16.020 --> 11:18.020
首先我们学过的

11:18.020 --> 11:19.020
有什么

11:19.020 --> 11:20.020
迭代器

11:20.020 --> 11:22.020
迭代器的知识

11:22.020 --> 11:23.020
还有就是

11:23.020 --> 11:24.020
可迭代协议

11:24.020 --> 11:26.020
协议的知识

11:26.020 --> 11:27.020
这两个是我们学过的

11:27.020 --> 11:28.020
如果说仅仅是

11:28.020 --> 11:29.020
这两个东西的话

11:29.020 --> 11:30.020
还没啥

11:30.020 --> 11:31.020
还有一个东西叫做

11:31.020 --> 11:32.020
状态机

11:32.020 --> 11:33.020
状态机呢

11:33.020 --> 11:35.020
是学习后端语言加把

11:35.020 --> 11:36.020
而且都要学习到很深很深

11:36.020 --> 11:38.020
所以学到很多底层原理的时候

11:38.020 --> 11:40.020
你才会设计

11:40.020 --> 11:42.020
这个东西

11:42.020 --> 11:45.020
你不太容易理解得了

11:45.020 --> 11:47.020
它是用这种东西来

11:47.020 --> 11:50.020
实现生成器

11:50.020 --> 11:54.020
生成器

11:54.020 --> 11:55.020
也就是说

11:55.020 --> 11:56.020
它要把这个

11:56.020 --> 11:57.020
刚才我们看到的生成器

11:57.020 --> 11:58.020
这种函数

11:58.020 --> 11:59.020
就是把这种函数

11:59.020 --> 12:01.020
要转换成

12:01.020 --> 12:03.020
迭代器

12:03.020 --> 12:04.020
可迭代协议

12:04.020 --> 12:05.020
加状态机

12:05.020 --> 12:06.020
这种模式

12:06.020 --> 12:08.020
因为这都是新的语法

12:08.020 --> 12:10.020
然后转换的方式

12:10.020 --> 12:11.020
它是利用了一个API

12:11.020 --> 12:13.020
叫做Generator Runtime

12:13.020 --> 12:14.020
是不是

12:14.020 --> 12:15.020
Regenerator Runtime

12:15.020 --> 12:17.020
是不是学过的

12:17.020 --> 12:18.020
看一下

12:18.020 --> 12:20.020
我们之前讲那个

12:20.020 --> 12:22.020
讲那个

12:22.020 --> 12:23.020
百步预设

12:23.020 --> 12:25.020
是不是就安装过这个

12:25.020 --> 12:26.020
那么现在我们知道了

12:26.020 --> 12:27.020
这个东西干嘛的

12:27.020 --> 12:29.020
这个东西就是为了

12:29.020 --> 12:31.020
转换生成器而服务的

12:31.020 --> 12:32.020
你看Generator

12:32.020 --> 12:33.020
Generator这个名字

12:33.020 --> 12:34.020
不就是生成器

12:34.020 --> 12:37.020
Generator运行时

12:37.020 --> 12:39.020
REGenerator什么意思

12:39.020 --> 12:40.020
就是

12:40.020 --> 12:41.020
你没有Generator

12:41.020 --> 12:42.020
我给你勾造一个Generator

12:42.020 --> 12:43.020
RE表示

12:43.020 --> 12:45.020
重新勾造的意思

12:45.020 --> 12:46.020
那么

12:46.020 --> 12:49.020
就是我勾造一个Generator的运行时

12:49.020 --> 12:50.020
那么这里边

12:50.020 --> 12:51.020
就提供了一些API

12:51.020 --> 12:52.020
能够帮助你

12:52.020 --> 12:54.020
转换Generator函数

12:54.020 --> 12:56.020
它就是在做这么一件事的

12:56.020 --> 12:57.020
现在我们把

12:57.020 --> 12:58.020
逻辑线就理清楚了

12:58.020 --> 12:59.020
对吧

12:59.020 --> 13:01.020
为什么

13:01.020 --> 13:02.020
以后呢

13:02.020 --> 13:04.020
你们变得非常非常牛逼的时候呢

13:04.020 --> 13:06.020
你们就可以跟别人去炫耀

13:06.020 --> 13:07.020
包括我听完这些课的声音

13:07.020 --> 13:09.020
你们就可以跟别人去炫耀了

13:09.020 --> 13:11.020
你知道为什么

13:11.020 --> 13:15.020
sync和awake需要

13:15.020 --> 13:16.020
就是你在

13:16.020 --> 13:18.020
为什么使用bible的时候

13:18.020 --> 13:21.020
使用bible是

13:21.020 --> 13:25.780
如果要转换

13:25.780 --> 13:27.780
sync和awake

13:27.780 --> 13:29.780
需要安装

13:29.780 --> 13:30.780
安装什么呢

13:30.780 --> 13:32.780
安装regenerator runtime

13:32.780 --> 13:33.780
这个库

13:33.780 --> 13:35.780
为什么

13:35.780 --> 13:37.780
那么这个逻辑线是这样子的

13:37.780 --> 13:38.780
因为

13:38.780 --> 13:41.780
sync和awake

13:41.780 --> 13:44.780
需要转换为

13:44.780 --> 13:47.780
需要转换为生成器

13:47.780 --> 13:50.780
需要转换为生成器

13:50.780 --> 13:51.780
我们之前解释过了

13:51.780 --> 13:52.780
转换生成器过后

13:52.780 --> 13:53.780
就可以利用我们之前

13:53.780 --> 13:54.780
学过的

13:54.780 --> 13:56.780
s6里面的那种方式

13:56.780 --> 13:58.780
生成器那种控制异步的方式

13:58.780 --> 13:59.780
来进行控制了

13:59.780 --> 14:01.780
所以它把它转换成生成器

14:01.780 --> 14:04.780
而生成器的

14:04.780 --> 14:07.780
生成器的愚法

14:07.780 --> 14:12.090
也属于新愚法

14:12.090 --> 14:15.090
又是新愚法

14:15.090 --> 14:18.090
也需要进行转换

14:18.090 --> 14:20.090
它也需要进行转换

14:20.090 --> 14:25.090
而转换生成器的

14:26.090 --> 14:29.090
需要一个库的支持

14:29.090 --> 14:30.090
这个库

14:30.090 --> 14:32.090
就是regenerator runtime

14:32.090 --> 14:33.090
所以这个库

14:33.090 --> 14:34.090
它本身不是在转换

14:34.090 --> 14:35.090
而生成器的

14:35.090 --> 14:36.090
它是在转换什么呢

14:36.090 --> 14:37.090
它主要的目的

14:37.090 --> 14:40.090
是来转换生成器的

14:40.090 --> 14:41.090
但是我们的生成器

14:41.090 --> 14:43.090
要转换成生成器

14:43.090 --> 14:45.090
生成器又要转换

14:45.090 --> 14:46.090
又要进行转换

14:46.090 --> 14:47.090
那么就需要这个库的支持了

14:47.090 --> 14:49.090
是这么一个逻辑线

14:49.090 --> 14:51.090
它可以100%肯定

14:51.090 --> 14:52.090
你面试的时候

14:52.090 --> 14:53.090
绝对不会用到这个问题

14:54.090 --> 14:56.090
它只知道这个库的

14:56.090 --> 14:57.090
又要转换生成器

14:57.090 --> 14:58.090
它不知道怎么去转换

14:58.090 --> 15:00.090
这里面比较复杂

15:01.090 --> 15:02.090
好 来吧

15:02.090 --> 15:04.090
它到底是怎么转换的呢

15:04.090 --> 15:05.090
也就是说

15:05.090 --> 15:07.090
我们看到这样的代码

15:07.090 --> 15:08.090
看到这个

15:08.090 --> 15:09.090
Wild, ER

15:09.090 --> 15:10.090
这些东西

15:10.090 --> 15:11.090
乱七八糟的一大堆一堆

15:11.090 --> 15:12.090
看到这样的代码

15:12.090 --> 15:13.090
其实它就对应这个代码

15:13.090 --> 15:14.090
对应一个生成器代码

15:14.090 --> 15:15.090
然后接下来

15:15.090 --> 15:17.090
我们再把我们这个代码

15:17.090 --> 15:19.090
我们而Sink and Weasler代码

15:19.090 --> 15:20.090
放过去

15:20.090 --> 15:21.090
我们再来看

15:21.090 --> 15:23.910
它转换的原代码

15:23.910 --> 15:24.910
放这边

15:25.910 --> 15:26.910
一大堆

15:26.910 --> 15:27.910
一大堆

15:27.910 --> 15:28.910
特别繁琐

15:28.910 --> 15:30.910
但是我们注意看这里

15:31.910 --> 15:32.910
四成相似

15:32.910 --> 15:33.910
是不是

15:33.910 --> 15:34.910
四成相似

15:34.910 --> 15:35.910
这一块

15:35.910 --> 15:36.910
这一块不就是

15:36.910 --> 15:38.910
刚才那个生成器的代码吗

15:38.910 --> 15:39.910
不就是吗

15:39.910 --> 15:40.910
我们把这些东西去掉

15:41.910 --> 15:42.910
这些东西去掉

15:42.910 --> 15:44.910
这里换成EL的

15:45.910 --> 15:46.910
这里换成EL的

15:47.910 --> 15:48.910
这里去掉

15:48.910 --> 15:49.910
这里换成新号

15:49.910 --> 15:51.910
不就是这个东西吗

15:51.910 --> 15:52.910
对不对

15:52.910 --> 15:53.910
所以说

15:53.910 --> 15:55.910
它是经过这么两次转换

15:55.910 --> 15:57.910
就从形成了这么一样的结果

15:57.910 --> 15:59.910
这就是我们而Sink

15:59.910 --> 16:00.910
而Weasler它的转换方式

16:00.910 --> 16:01.910
那么接下来

16:01.910 --> 16:03.910
我们来分析这一块代码

16:03.910 --> 16:05.910
这块代码特别特别复杂

16:05.910 --> 16:06.910
我们在分析的过程中

16:06.910 --> 16:07.910
要不断地对它进行减化

16:07.910 --> 16:09.910
不然的话根本就看不动

16:09.910 --> 16:10.910
首先运行一下

16:10.910 --> 16:11.910
我们首先运行

16:11.910 --> 16:12.910
看能不能运行

16:12.910 --> 16:13.910
你转换过程度的运行

16:13.910 --> 16:15.910
我们这里不是

16:15.910 --> 16:16.910
调用必含说

16:16.910 --> 16:17.910
它不是返回个Promise

16:17.910 --> 16:18.910
而Sink

16:18.910 --> 16:19.910
完成之后

16:19.910 --> 16:20.910
我要输出这个结果

16:20.910 --> 16:21.910
输出肯定是6

16:21.910 --> 16:22.910
对不对

16:22.910 --> 16:24.910
你看一下我们这里Runcode

16:24.910 --> 16:25.910
我们把这个取消

16:25.910 --> 16:27.910
之前的输出取消

16:27.910 --> 16:28.910
Runcode

16:28.910 --> 16:30.910
一秒钟之后

16:30.910 --> 16:31.910
输出6

16:31.910 --> 16:32.910
没问题吧

16:32.910 --> 16:33.910
那我们这边代码

16:33.910 --> 16:34.910
是不是也在这样运行呢

16:34.910 --> 16:36.910
这里我们来看一下

16:36.910 --> 16:37.910
Runcode

16:37.910 --> 16:39.910
爆错了

16:39.910 --> 16:41.910
这个错误好像不太对

16:41.910 --> 16:43.910
我看一下

16:43.910 --> 16:45.910
我没复制完

16:45.910 --> 16:46.910
我看一下

16:46.910 --> 16:48.910
这上面还有几句话没复制完

16:48.910 --> 16:50.910
重新来一次

16:50.910 --> 16:51.910
上天

16:51.910 --> 16:53.910
我就说这个错误好像不太对

16:53.910 --> 16:54.910
好

16:54.910 --> 16:55.910
那么其实这样子

16:55.910 --> 16:56.910
我们再来运行

16:56.910 --> 16:57.910
再来运行

16:57.910 --> 16:58.910
好

16:58.910 --> 16:59.910
那么这个时候

16:59.910 --> 17:00.910
这个错误才对

17:00.910 --> 17:01.910
他说

17:01.910 --> 17:02.910
Cannot find a module

17:02.910 --> 17:03.910
这个东西

17:03.910 --> 17:04.910
说明啥

17:04.910 --> 17:06.910
你看一下我们代码

17:06.910 --> 17:08.910
我们代码在最上边

17:08.910 --> 17:09.910
我再说一下

17:09.910 --> 17:10.910
在最上边

17:10.910 --> 17:11.910
是不是有几个require

17:11.910 --> 17:12.910
对吧

17:12.910 --> 17:13.910
就是我们要实现

17:13.910 --> 17:15.910
这个generator的转换

17:15.910 --> 17:17.910
已经Promise的API的提供

17:17.910 --> 17:18.910
是不是要利用到一些

17:18.910 --> 17:19.910
core.js这个cool

17:19.910 --> 17:21.910
generator runtime这个cool

17:21.910 --> 17:22.910
对吧

17:22.910 --> 17:23.910
要用这个cool里边的东西

17:23.910 --> 17:24.910
这个cool里边

17:24.910 --> 17:25.910
它给你注入了

17:25.910 --> 17:26.910
往全局对象里边

17:26.910 --> 17:27.910
注入了一些API

17:27.910 --> 17:29.910
什么Promise这个API

17:29.910 --> 17:30.910
还有什么generator

17:30.910 --> 17:32.910
这些相关的生成函数

17:32.910 --> 17:33.910
这些东西

17:33.910 --> 17:34.910
对吧

17:34.910 --> 17:35.910
它才能完成转换

17:35.910 --> 17:36.910
所以说我们

17:36.910 --> 17:37.910
为了让这个代码运行出来了

17:37.910 --> 17:38.910
我还要去安装

17:38.910 --> 17:39.910
两个cool

17:39.910 --> 17:41.910
一个是regenerator runtime

17:41.910 --> 17:43.910
一个是core.js

17:43.910 --> 17:45.910
所以这个core.js的版本是2

17:45.910 --> 17:47.910
因为我是在网站上

17:47.910 --> 17:48.910
就是转换的

17:48.910 --> 17:50.910
它默认使用的是2的个版本

17:50.910 --> 17:52.910
目前税性版本是3了

17:52.910 --> 17:53.910
所以说那里安装的时候

17:53.910 --> 17:55.910
得安装2的个版本

17:55.910 --> 17:56.910
那么我们这里干脆这样吧

17:56.910 --> 17:58.910
我们在这里新建一个

17:58.910 --> 17:59.910
我们现在干嘛

17:59.910 --> 18:00.910
现在在这个

18:00.910 --> 18:01.910
让这个最终转换出来

18:01.910 --> 18:02.910
代码要把它跑不起来

18:02.910 --> 18:03.910
看能不能跑不起来

18:03.910 --> 18:05.910
因为它要用到一些额外的cool

18:05.910 --> 18:10.500
所以说我们现在要去安装

18:10.500 --> 18:11.500
它这个转换了

18:11.500 --> 18:12.500
就需要用到额外的cool了

18:12.500 --> 18:15.500
就不是直接就可以运行了

18:15.500 --> 18:16.500
安装

18:16.500 --> 18:17.500
我们就

18:17.500 --> 18:18.500
直接拍个几点

18:18.500 --> 18:19.500
接上里面写吧

18:19.500 --> 18:20.500
在这里写吧

18:20.500 --> 18:24.010
叫Dependences

18:24.010 --> 18:29.900
然后这里是一个core.js

18:29.900 --> 18:32.900
它的版本是我们就用这个符号

18:32.900 --> 18:35.900
2的个版本以上

18:35.900 --> 18:36.900
你随便

18:36.900 --> 18:39.900
接下来还有一个cool就是

18:39.900 --> 18:41.900
叫做Gian

18:41.900 --> 18:43.900
复制过来

18:43.900 --> 18:45.900
regenerator runtime

18:45.900 --> 18:48.900
这个cool你用最新版本就行了

18:48.900 --> 18:50.900
latest

18:50.900 --> 18:51.900
OK

18:51.900 --> 18:52.900
好来吧

18:52.900 --> 18:53.900
安装

18:53.900 --> 18:55.900
给它安装完了之后

18:55.900 --> 18:57.900
我们再来运行一下

18:57.900 --> 18:59.900
看它是不是能够运行出来

18:59.900 --> 19:01.900
运行

19:01.900 --> 19:02.900
这里

19:02.900 --> 19:04.900
清除叔叔

19:04.900 --> 19:06.900
它这里爆错了是吧

19:06.900 --> 19:07.900
它说什么意思

19:07.900 --> 19:09.900
它说

19:09.900 --> 19:10.900
这是个警告

19:10.900 --> 19:13.900
它说现在2这个版本已经过时了

19:13.900 --> 19:14.900
建议你升级到3这个版本

19:14.900 --> 19:15.900
但是我无所谓

19:15.900 --> 19:17.900
因为我现在就是要用

19:17.900 --> 19:19.900
就是要用这个2这个版本

19:19.900 --> 19:20.900
但是它

19:20.900 --> 19:22.900
这什么意思

19:22.900 --> 19:24.900
这个是来自错误

19:24.900 --> 19:26.900
code

19:29.900 --> 19:32.900
我刚才应该是

19:32.900 --> 19:34.900
multi version

19:34.900 --> 19:36.900
found for generator

19:36.900 --> 19:38.900
latest

19:38.900 --> 19:40.900
是这样写吗

19:40.900 --> 19:41.900
看一下啊

19:41.900 --> 19:43.900
latest是这样写吗

19:43.900 --> 19:45.900
最新版本

19:45.900 --> 19:47.900
最新版本

19:47.900 --> 19:48.900
咋写的

19:48.900 --> 19:49.900
我一下忘了

19:49.900 --> 19:51.900
一下忘了

19:51.900 --> 19:53.900
现在

19:53.900 --> 19:55.900
generator runtime这个版本

19:55.900 --> 19:56.900
看一下吧

19:56.900 --> 19:57.900
我们单独来安装吧

19:57.900 --> 19:59.900
我现在也不去纠结这个东西了

19:59.900 --> 20:00.900
突然又忘了

20:00.900 --> 20:01.900
这个需要查一下

20:01.900 --> 20:02.900
npm

20:02.900 --> 20:03.900
我先把这个

20:03.900 --> 20:04.900
code介绍安装了

20:04.900 --> 20:05.900
然后我们再单独去安装

20:05.900 --> 20:07.900
generator runtime

20:07.900 --> 20:09.900
好先把它安装了

20:09.900 --> 20:10.900
安装了之后

20:10.900 --> 20:11.900
我们再来安装

20:11.900 --> 20:13.900
generator runtime

20:13.900 --> 20:21.710
这样

20:21.710 --> 20:23.710
这里

20:23.710 --> 20:24.710
把这个复制一下

20:24.710 --> 20:26.710
再单独安装

20:26.710 --> 20:30.620
最新版本咋写的

20:30.620 --> 20:32.620
安装好了

20:32.620 --> 20:34.620
安装好了之后

20:34.620 --> 20:35.620
我们现在再来运行

20:35.620 --> 20:36.620
有个load margins目录了

20:36.620 --> 20:37.620
再来运行

20:37.620 --> 20:41.830
6是不是出来了

20:41.830 --> 20:42.830
说明它转换之后的代码

20:42.830 --> 20:43.830
是可以运行的

20:43.830 --> 20:45.830
它尽管没有我们这个语法

20:45.830 --> 20:46.830
没有什么erthinker

20:46.830 --> 20:47.830
arrest这个语法

20:47.830 --> 20:48.830
它仍然是可以运行的

20:48.830 --> 20:50.830
接下来我们就来做的事情就是

20:50.830 --> 20:52.830
来研究它到底是怎么回事

20:52.830 --> 20:54.830
这个代码特别复杂

20:54.830 --> 20:57.830
我们为了让我们更加好分析

20:57.830 --> 21:00.830
首先我们把这一部分代码

21:00.830 --> 21:01.830
因为我们刚才知道

21:01.830 --> 21:03.830
这一部分代码来干嘛的

21:03.830 --> 21:06.830
这一坨代码来干嘛的

21:06.830 --> 21:09.830
这一坨代码就是来生成

21:09.830 --> 21:12.830
一个什么来转换生成器的

21:12.830 --> 21:14.830
所以为了我们方便来分析

21:14.830 --> 21:17.830
我们现在不用去分析生成器

21:17.830 --> 21:18.830
生成器该怎么去转换

21:18.830 --> 21:20.830
生成器等下太复杂了

21:20.830 --> 21:22.830
超出很远了

21:22.830 --> 21:23.830
超出大纲很远了

21:23.830 --> 21:25.830
所以我们这一块不分析了

21:25.830 --> 21:27.830
我们就把它写成生成器

21:27.830 --> 21:29.830
因为我们的动作它也是支持生成器的

21:29.830 --> 21:31.830
就把它写成一个生成器

21:31.830 --> 21:32.830
那么我们把这个函数写进来

21:32.830 --> 21:34.830
它不是就是转换这个玩意吗

21:34.830 --> 21:35.830
对吧

21:35.830 --> 21:36.830
不是就是转换这个玩意吗

21:36.830 --> 21:37.830
把它写成一个匿名函数

21:37.830 --> 21:39.830
那么就不再是erthink函数了

21:39.830 --> 21:41.830
把这个东西它是一个生成器

21:41.830 --> 21:44.830
那么这个erv成了变成eo的

21:44.830 --> 21:45.830
变成eo的

21:45.830 --> 21:46.830
把这一块改一下

21:46.830 --> 21:47.830
一看一下

21:47.830 --> 21:48.830
改了之后它能不能

21:48.830 --> 21:50.830
我们把这个这样子写

21:50.830 --> 21:51.830
再看清楚一点

21:51.830 --> 21:52.830
传了一个函数进去

21:52.830 --> 21:53.830
这个函数

21:53.830 --> 21:54.830
它把这一部分代码

21:54.830 --> 21:55.830
就是转换生成器的语法

21:55.830 --> 21:57.830
那么我们把它写成生成器的语法

21:57.830 --> 21:59.830
这样大家好理解一点

21:59.830 --> 22:00.830
保存一下

22:00.830 --> 22:01.830
我们再来运行

22:01.830 --> 22:03.830
看看怎么能运行出来

22:03.830 --> 22:05.830
是不是还是可以

22:05.830 --> 22:06.830
这再一次印证了

22:06.830 --> 22:07.830
刚才那一驼代码

22:07.830 --> 22:08.830
一大堆代码

22:08.830 --> 22:09.830
其实就是用来

22:09.830 --> 22:11.830
转换这个生成器的

22:11.830 --> 22:13.830
其实它就是用来转换生成器的

22:13.830 --> 22:14.830
那么现在我们不需要

22:14.830 --> 22:15.830
你转换生成器的

22:15.830 --> 22:16.830
那我这个裤是不是都可以不要了

22:16.830 --> 22:17.830
对吧

22:17.830 --> 22:18.830
这个裤都可以不要了

22:18.830 --> 22:19.830
对不对

22:19.830 --> 22:20.830
我们来看一下

22:20.830 --> 22:23.400
装扣的

22:23.400 --> 22:24.400
6

22:24.400 --> 22:25.400
说明啥

22:25.400 --> 22:26.400
刚才那个裤其实就是来

22:26.400 --> 22:27.400
转换生成器的

22:27.400 --> 22:28.400
如果说你不需要

22:28.400 --> 22:29.400
转换生成器

22:29.400 --> 22:30.400
OK 那就不需要它了

22:30.400 --> 22:31.400
就完全不需要它了

22:31.400 --> 22:33.400
那么像这两个裤

22:33.400 --> 22:34.400
像这两个裤

22:34.400 --> 22:35.400
其实我们也可以不需要

22:35.400 --> 22:36.400
为什么呢

22:36.400 --> 22:37.400
因为这个两个裤

22:37.400 --> 22:38.400
这个裤是转换

22:38.400 --> 22:39.400
是来提供Promise的

22:39.400 --> 22:41.400
我们的路德里边是有Promise的

22:41.400 --> 22:42.400
对吧

22:42.400 --> 22:43.400
这个裤是来提供一个

22:43.400 --> 22:44.400
什么Object to Student的

22:44.400 --> 22:45.400
我们现在

22:45.400 --> 22:46.400
这个工具裤

22:46.400 --> 22:47.400
也没什么意义

22:47.400 --> 22:48.400
那么这两个裤不要

22:48.400 --> 22:49.400
我们仍然可以运行

22:49.400 --> 22:51.400
我们主要

22:51.400 --> 22:52.400
我们就尽量的

22:52.400 --> 22:54.400
再代码去减化

22:54.400 --> 22:55.400
减化之后

22:55.400 --> 22:56.400
我们来分析它

22:56.400 --> 22:57.400
这个谨慎的代码里边

22:57.400 --> 22:59.400
是怎么来玩这个事情的

22:59.400 --> 23:01.400
好 接下来我们来看

23:01.400 --> 23:03.400
这个函数是不是完全没动

23:03.400 --> 23:04.400
看一下

23:04.400 --> 23:05.400
这个函数

23:05.400 --> 23:06.400
在结果里边是不是

23:06.400 --> 23:07.400
完全就没动

23:07.400 --> 23:08.400
对吧

23:08.400 --> 23:09.400
无非就是Promise

23:09.400 --> 23:10.400
它可能没有这样的API

23:10.400 --> 23:11.400
刚才的这个东西

23:11.400 --> 23:12.400
它就提供了这个API

23:12.400 --> 23:13.400
对吧

23:13.400 --> 23:15.400
它这个东西完全没动

23:15.400 --> 23:16.400
那么B这个函数

23:16.400 --> 23:17.400
你看一下

23:17.400 --> 23:18.400
它就玩的花样就出来了

23:18.400 --> 23:19.400
B这个函数

23:19.400 --> 23:20.400
它对应到这

23:21.400 --> 23:23.400
然后这个B的函数

23:23.400 --> 23:24.400
里边干了什么事呢

23:24.400 --> 23:25.400
干了什么事呢

23:25.400 --> 23:27.400
它就做了这么一件事

23:27.400 --> 23:29.400
它去调用了另外一个函数

23:29.400 --> 23:30.400
对吧

23:30.400 --> 23:31.400
你这样子

23:31.400 --> 23:33.400
是为了把参数传过去

23:33.400 --> 23:34.400
把这里的参数

23:34.400 --> 23:36.400
给大家传到这个函数里边去

23:36.400 --> 23:38.400
因为它没有使用形参

23:38.400 --> 23:40.400
它的目的是要把这个函数传过去

23:40.400 --> 23:41.400
那么我们这里

23:41.400 --> 23:42.400
由于这个B这个函数

23:42.400 --> 23:43.400
本身就没有参数

23:43.400 --> 23:44.400
所以说我们可以

23:44.400 --> 23:45.400
把减化一下

23:45.400 --> 23:46.400
去尽量减化

23:46.400 --> 23:47.400
不然的话太复杂了

23:47.400 --> 23:49.400
那么这里呢

23:49.400 --> 23:50.400
所以调用B这个函数

23:50.400 --> 23:51.400
对吧

23:51.400 --> 23:52.400
它无非就是调用B这个函数

23:52.400 --> 23:54.400
而B这个函数在干嘛呢

23:54.400 --> 23:55.400
那么我们是不是就可以

23:55.400 --> 23:56.400
这样认为

23:56.400 --> 23:57.400
它这里边是不是

23:57.400 --> 23:58.400
就可以把B的代码

23:58.400 --> 23:59.400
直接复制过来

23:59.400 --> 24:00.400
粘过来

24:00.400 --> 24:01.400
那么我们看一下

24:01.400 --> 24:02.400
B的代码在干嘛

24:02.400 --> 24:03.400
B的代码在调用另外一个函数

24:03.400 --> 24:05.400
这个函数是上面提供的

24:05.400 --> 24:06.400
是这个函数

24:06.400 --> 24:07.400
调用这个函数

24:07.400 --> 24:09.400
然后传了一个生存器具进去

24:09.400 --> 24:10.400
然后把这个函

24:10.400 --> 24:11.400
甭管它什么意思

24:11.400 --> 24:12.400
先不管它什么意思

24:12.400 --> 24:14.400
把这个函数的返回结果了

24:14.400 --> 24:15.400
又重新给这个

24:15.400 --> 24:16.400
下滑线B复制

24:16.400 --> 24:18.400
也就说这里返回的东西

24:18.400 --> 24:19.400
复制给它

24:19.400 --> 24:20.400
对吧

24:20.400 --> 24:21.400
然后呢

24:21.400 --> 24:22.400
这里又是

24:22.400 --> 24:23.400
下滑线B

24:23.400 --> 24:24.400
是不是又要调用函数

24:24.400 --> 24:25.400
那么调用函数

24:25.400 --> 24:26.400
是不是要传传数的一东西

24:26.400 --> 24:27.400
那么我们这里没有传数

24:27.400 --> 24:29.400
所以说我这里就尽量简化

24:29.400 --> 24:30.400
好

24:30.400 --> 24:32.400
这个代码应该能看懂了

24:32.400 --> 24:34.400
什么意思呢

24:34.400 --> 24:35.400
调用一个函数

24:35.400 --> 24:37.400
传了一个东西进去

24:37.400 --> 24:38.400
管它什么东西

24:38.400 --> 24:39.400
我现在不用去管它

24:39.400 --> 24:40.400
调用一个函数

24:40.400 --> 24:41.400
传了一个东西进去

24:41.400 --> 24:43.400
然后它返回了一个东西

24:43.400 --> 24:44.400
保存起来

24:44.400 --> 24:45.400
然后呢

24:45.400 --> 24:47.400
把返回的东西

24:47.400 --> 24:48.400
当成函数调用

24:48.400 --> 24:50.400
说明它返回的是啥

24:50.400 --> 24:51.400
你不用管别的

24:51.400 --> 24:52.400
你看一下那个代码

24:52.400 --> 24:53.400
它返回的是啥

24:53.400 --> 24:55.400
返回的是不是一个函数

24:55.400 --> 24:56.400
对吧

24:56.400 --> 24:57.400
返回的它就是一个函数

24:57.400 --> 24:58.400
好

24:58.400 --> 24:59.400
那么它返回的既然是函数

24:59.400 --> 25:00.400
那么这里

25:00.400 --> 25:01.400
是不是可以调用函数

25:01.400 --> 25:02.400
到返回结果

25:02.400 --> 25:03.400
那么它就是

25:03.400 --> 25:04.400
那么这个调用

25:04.400 --> 25:05.400
是不是就B的返回结果

25:05.400 --> 25:06.400
那么它的就返回结果

25:06.400 --> 25:07.400
是不是就是它的返回结果

25:07.400 --> 25:08.400
所以说

25:08.400 --> 25:09.400
这个代码呢

25:09.400 --> 25:10.400
我们可以进一步转换

25:10.400 --> 25:12.400
我们把这个代码直接放过来

25:12.400 --> 25:13.400
对吧

25:13.400 --> 25:14.400
是不是可以直接放过来

25:14.400 --> 25:15.400
我们这里呢

25:15.400 --> 25:17.400
可以用一个变量

25:17.400 --> 25:18.400
一个变量

25:19.400 --> 25:20.400
下滑线B

25:20.400 --> 25:21.400
那么调用它

25:21.400 --> 25:23.400
这个函数是不是可以不用了

25:23.400 --> 25:24.400
不要了

25:24.400 --> 25:25.400
那么这样子

25:25.400 --> 25:26.400
是不是可以正常运行的

25:26.400 --> 25:28.400
又来试一下

25:28.400 --> 25:29.400
当以后你们越读元代码

25:29.400 --> 25:30.400
当遇到元代码

25:30.400 --> 25:31.400
比较复杂的时候

25:31.400 --> 25:32.400
就可以利用这种方式

25:32.400 --> 25:33.400
简化它

25:33.400 --> 25:34.400
不断的简化它

25:34.400 --> 25:35.400
看它的核心思想

25:35.400 --> 25:37.400
核心结构

25:37.400 --> 25:39.400
那么你看我们的B这个函数

25:39.400 --> 25:40.400
我们B这个函数

25:40.400 --> 25:42.400
是不是变成了这样子了

25:42.400 --> 25:43.400
所以变成这样子了

25:43.400 --> 25:44.400
而B里边的代码

25:44.400 --> 25:45.400
变成了什么了

25:45.400 --> 25:47.400
变成了生成器函数里边的这种代码

25:47.400 --> 25:48.400
B里边的代码

25:48.400 --> 25:50.400
它变成了生成器函数的这种代码

25:50.400 --> 25:51.400
看没有

25:51.400 --> 25:52.400
它就这样子了

25:52.400 --> 25:53.400
好

25:53.400 --> 25:54.400
接下来我们就要

25:54.400 --> 25:56.400
后边的代码你看都没变化

25:56.400 --> 25:57.400
调用B

25:57.400 --> 25:58.400
RIN什么

25:58.400 --> 25:59.400
对吧

25:59.400 --> 26:00.400
你看调用B

26:00.400 --> 26:01.400
RIN把它变成了

26:01.400 --> 26:02.400
无非把简讨函数变成了方式

26:02.400 --> 26:03.400
现在都没变化

26:03.400 --> 26:05.400
那么现在的关键的问题

26:05.400 --> 26:06.400
就是在分析这一图

26:06.400 --> 26:08.970
也就是说

26:08.970 --> 26:09.970
这个函数

26:09.970 --> 26:11.970
它真正的起作用

26:11.970 --> 26:13.970
是不是在调用它

26:14.970 --> 26:16.970
而它哪来的

26:16.970 --> 26:18.970
是不是调用它来的

26:18.970 --> 26:20.970
那么这个函数在干嘛呢

26:20.970 --> 26:21.970
就上面这个函数

26:21.970 --> 26:22.970
它又在干嘛呢

26:22.970 --> 26:23.970
好

26:23.970 --> 26:25.970
接下来我们把这个函数

26:25.970 --> 26:27.970
改展开来展开

26:28.970 --> 26:34.330
要看这个函数在干嘛

26:34.330 --> 26:35.330
好

26:35.330 --> 26:36.330
来吧

26:36.330 --> 26:38.330
各说话一下

26:38.330 --> 26:41.900
各说话一下

26:41.900 --> 26:42.900
各说话一下

26:42.900 --> 26:43.900
这个函数

26:43.900 --> 26:44.900
我们看代码

26:44.900 --> 26:45.900
一定要是

26:45.900 --> 26:47.900
要从整体结构上去分析

26:47.900 --> 26:48.900
先用细节的话

26:48.900 --> 26:49.900
一脑袋就晕了

26:49.900 --> 26:50.900
你看看这个函数

26:50.900 --> 26:51.900
FN

26:51.900 --> 26:53.900
是不是你要传一个函数给我

26:53.900 --> 26:55.900
这个函数干嘛的

26:55.900 --> 26:57.900
他是把Essink

26:57.900 --> 26:58.900
就转换成监

26:58.900 --> 27:00.900
就是Generic的那种形式

27:00.900 --> 27:01.900
他就在做这么一件事

27:01.900 --> 27:03.900
你给我一个函数

27:03.900 --> 27:04.900
给他是不是

27:04.900 --> 27:05.900
给他一个函数

27:05.900 --> 27:06.900
这里是不是给他一个函数

27:06.900 --> 27:07.900
这个函数是什么

27:07.900 --> 27:08.900
生存器函数

27:08.900 --> 27:09.900
你给我一个函数

27:09.900 --> 27:11.900
我不拉不拉不拉不拉

27:11.900 --> 27:13.900
然后给你转换成另外一个函数

27:13.900 --> 27:15.900
是不是这么一个意思

27:15.900 --> 27:16.900
是不是就是这个意思

27:16.900 --> 27:17.900
你给我一个函数

27:17.900 --> 27:19.900
然后把它转换成另外一个函数

27:19.900 --> 27:20.900
对吧

27:20.900 --> 27:21.900
那么这个函数是不是负责给

27:21.900 --> 27:23.900
就这个他转换出来的

27:23.900 --> 27:25.900
就是他返回到这个函数

27:25.900 --> 27:27.900
是不是负责给了下环线币

27:27.900 --> 27:29.900
是不是负责给了他

27:29.900 --> 27:30.900
那么调用这个函数

27:30.900 --> 27:31.900
是不是得到结果

27:31.900 --> 27:32.900
你看到吗

27:32.900 --> 27:33.900
这个函数

27:33.900 --> 27:35.900
他返回了一个函数

27:35.900 --> 27:36.900
你甭管什么意思

27:36.900 --> 27:38.900
我们现在要减化他

27:38.900 --> 27:39.900
你不减化他

27:39.900 --> 27:40.900
也很难你减什么意思

27:40.900 --> 27:42.900
就是你给我一个函数

27:42.900 --> 27:43.900
我给你返回一个函数

27:43.900 --> 27:44.900
你看

27:44.900 --> 27:45.900
我给你一个函数

27:45.900 --> 27:47.900
然后他给我返回了一个函数

27:47.900 --> 27:49.900
然后我就调用这个函数

27:49.900 --> 27:50.900
是不是这个意思

27:50.900 --> 27:51.900
没问题吧

27:51.900 --> 27:52.900
没问题吧

27:52.900 --> 27:53.900
那既然

27:53.900 --> 27:54.900
哪里看啊

27:54.900 --> 27:56.900
我调用这个函数

27:56.900 --> 27:57.900
调用这个函数

27:57.900 --> 27:58.900
实际上在调用什么

27:58.900 --> 27:59.900
是不是要调用这个函数

27:59.900 --> 28:02.900
而调用这个函数的返回结果

28:02.900 --> 28:04.900
调用这个函数的返回结果

28:04.900 --> 28:06.900
是不是一个promise

28:06.900 --> 28:07.900
说明了啥

28:07.900 --> 28:09.900
说明了我们这个币

28:09.900 --> 28:11.900
这个下环线币调用之后

28:11.900 --> 28:12.900
这个东西

28:12.900 --> 28:13.900
你看这个表达是

28:13.900 --> 28:14.900
调用之后

28:14.900 --> 28:16.900
是不是就相当于是他调用之后

28:16.900 --> 28:17.900
他调用之后是不是得到一个promise

28:17.900 --> 28:18.900
这就是

28:18.900 --> 28:20.900
我们之前说的

28:20.900 --> 28:22.900
而sync标记的过后

28:22.900 --> 28:23.900
他返回的

28:23.900 --> 28:25.900
这个函数返回的一定是promise

28:25.900 --> 28:26.900
你看啊

28:26.900 --> 28:27.900
是不是这样子

28:27.900 --> 28:28.900
下环线币调用之后

28:28.900 --> 28:30.900
是不是得到一个promise

28:30.900 --> 28:31.900
对吧

28:31.900 --> 28:33.900
所以说我们可以认为

28:33.900 --> 28:36.900
这个函数的执行

28:36.900 --> 28:37.900
这个函数的执行

28:37.900 --> 28:38.900
是不是就相当于是

28:38.900 --> 28:42.590
这个函数的执行

28:42.590 --> 28:43.590
你看啊

28:43.590 --> 28:44.590
这个函数在执行

28:44.590 --> 28:45.590
得到一个函数

28:45.590 --> 28:46.590
调用这个函数

28:46.590 --> 28:47.590
调用这个函数

28:47.590 --> 28:48.590
是不是就是这个函数

28:48.590 --> 28:49.590
是不是就是这个函数的执行

28:49.590 --> 28:50.590
那好

28:50.590 --> 28:51.590
我就包底一点

28:51.590 --> 28:52.590
我直接把这个函数拿过来

28:52.590 --> 28:53.590
因为你执行

28:53.590 --> 28:54.590
它无非就是执行它嘛

28:54.590 --> 28:55.590
对吧

28:55.590 --> 28:56.590
执行下面这一坨

28:56.590 --> 28:57.590
无非就是执行它嘛

28:57.590 --> 28:58.590
我直接把这个函数拿过来

28:58.590 --> 29:00.590
把一些位置的东西

29:00.590 --> 29:01.590
拿给它写上

29:01.590 --> 29:02.590
这个fn

29:02.590 --> 29:03.590
fn不是这个

29:03.590 --> 29:04.590
不是这个函数的参数吗

29:04.590 --> 29:05.590
fn对吧

29:05.590 --> 29:06.590
fn哪来的

29:06.590 --> 29:07.590
fn是不是我们传进去的

29:07.590 --> 29:09.590
那么我们这里直接写一个fn

29:09.590 --> 29:11.590
直接写个fn

29:11.590 --> 29:13.590
等于这个

29:13.590 --> 29:14.590
可不可以

29:14.590 --> 29:15.590
那么就变成这样

29:15.590 --> 29:16.590
又变成这种形式了

29:16.590 --> 29:17.590
对吧

29:17.590 --> 29:18.590
好

29:18.590 --> 29:19.590
咱们来看一下

29:19.590 --> 29:20.590
这种形式呢就好理解多了

29:20.590 --> 29:21.590
我们把b这个函数呢

29:21.590 --> 29:23.590
就变成了这种形式了

29:23.590 --> 29:24.590
软扣的

29:24.590 --> 29:27.480
看一下

29:27.480 --> 29:28.480
是不是还是可以得到

29:28.480 --> 29:29.480
对吧

29:29.480 --> 29:30.480
那就没问题了

29:30.480 --> 29:32.480
把它转成这种格式了

29:32.480 --> 29:33.480
好

29:33.480 --> 29:34.480
那么就可以清楚的看到

29:34.480 --> 29:35.480
b这个函数

29:35.480 --> 29:36.480
我们明明没有返回什么Promise

29:36.480 --> 29:37.480
但是它这里

29:37.480 --> 29:39.480
返回的一定是Promise

29:39.480 --> 29:40.480
那么这个返回

29:40.480 --> 29:41.480
是不是就对应到

29:41.480 --> 29:43.480
转化了这个sync

29:43.480 --> 29:44.480
对吧

29:44.480 --> 29:45.480
转化了这个sync

29:45.480 --> 29:46.480
好

29:46.480 --> 29:47.480
我们继续来

29:47.480 --> 29:48.480
这个比较复杂

29:48.480 --> 29:49.480
然后呢

29:49.480 --> 29:50.480
我们这里的看一下

29:50.480 --> 29:51.480
这句话

29:51.480 --> 29:52.480
返回Promise

29:52.480 --> 29:53.480
Promise里面总得

29:53.480 --> 29:54.480
执行一个任务吧

29:54.480 --> 29:55.480
对吧

29:55.480 --> 29:56.480
那么执行任务干嘛呢

29:56.480 --> 29:57.480
fn

29:57.480 --> 29:58.480
fn函数

29:58.480 --> 29:59.480
对吧

29:59.480 --> 30:00.480
什么绑定z

30:00.480 --> 30:01.480
传参

30:01.480 --> 30:02.480
因为我们这里

30:02.480 --> 30:03.480
根本就没有参数

30:03.480 --> 30:04.480
z跟我们也没啥关系

30:04.480 --> 30:05.480
所以说

30:05.480 --> 30:06.480
根本就不要这个了

30:06.480 --> 30:07.480
直接就函用就行了

30:07.480 --> 30:08.480
尽量把它减化一下

30:08.480 --> 30:09.480
函数

30:09.480 --> 30:10.480
函数

30:10.480 --> 30:11.480
函数

30:11.480 --> 30:12.480
然后转换之后

30:12.480 --> 30:13.480
我们每一步

30:13.480 --> 30:14.480
还是运行一下吧

30:14.480 --> 30:15.480
看一下是不是正常的

30:15.480 --> 30:17.480
是不是得到6

30:17.480 --> 30:18.480
正常的

30:18.480 --> 30:19.480
我们再来一次

30:19.480 --> 30:20.480
软扣

30:20.480 --> 30:23.620
得到6

30:23.620 --> 30:24.620
是不是正常的

30:24.620 --> 30:25.620
还是正常的

30:25.620 --> 30:26.620
对吧

30:26.620 --> 30:27.620
好

30:27.620 --> 30:28.620
那么我们来看一下

30:28.620 --> 30:29.620
它怎么来做的

30:29.620 --> 30:30.620
怎么来做的

30:30.620 --> 30:31.620
接下来是核心点了

30:31.620 --> 30:32.620
我们真正的

30:32.620 --> 30:33.620
b的函数

30:33.620 --> 30:35.620
真正的b里面的代码

30:35.620 --> 30:36.620
它被它转化

30:36.620 --> 30:37.620
成了这样的代码

30:37.620 --> 30:38.620
然后b

30:38.620 --> 30:40.620
它返回了一个Promise

30:40.620 --> 30:41.620
接下来

30:41.620 --> 30:42.620
我们要做的是

30:42.620 --> 30:43.620
什么事情呢

30:43.620 --> 30:44.620
它做的事情就是

30:44.620 --> 30:46.620
这是一个生存器函数

30:46.620 --> 30:48.620
第二个用生存器函数

30:48.620 --> 30:50.620
是不是得到一个Generator

30:50.620 --> 30:51.620
对吧

30:51.620 --> 30:52.620
掉了生存器函数

30:52.620 --> 30:53.620
就是得到一个生存器

30:53.620 --> 30:54.620
生存器里面

30:54.620 --> 30:55.620
是不是可以

30:55.620 --> 30:56.620
那个是那个是不断的去执行任务

30:56.620 --> 30:57.620
每执行一个类似的

30:57.620 --> 30:58.620
是不是得到一个

30:58.620 --> 30:59.620
医药的

30:59.620 --> 31:01.620
医药的表达式结果

31:01.620 --> 31:02.620
对吧

31:02.620 --> 31:03.620
为了更加方便的

31:03.620 --> 31:04.620
去执行

31:04.620 --> 31:05.620
执行这个

31:05.620 --> 31:06.620
执行这个生存器

31:06.620 --> 31:08.620
你看它做了什么事情

31:08.620 --> 31:09.620
它又掉了另外一个函数

31:09.620 --> 31:11.620
它这里提供了两个函数

31:11.620 --> 31:12.620
那个是

31:12.620 --> 31:13.620
那个是

31:13.620 --> 31:15.620
提供了这么两个函数

31:15.620 --> 31:16.620
因为这个函数

31:16.620 --> 31:17.620
是不是根本没用到

31:17.620 --> 31:18.620
根本没有用到

31:18.620 --> 31:19.620
没有用到

31:19.620 --> 31:20.620
我就不要了

31:20.620 --> 31:21.620
你看我这里是不是

31:21.620 --> 31:22.620
掉了那个是函数

31:22.620 --> 31:23.620
根本没有

31:23.620 --> 31:24.620
掉了那个是函数

31:24.620 --> 31:25.620
所以说我根本没用到

31:25.620 --> 31:26.620
没有用到

31:26.620 --> 31:27.620
我就把它去掉

31:27.620 --> 31:29.620
尽量的减化

31:29.620 --> 31:30.620
那么这里

31:30.620 --> 31:31.620
以为这个那个是函数

31:31.620 --> 31:32.620
就一句话

31:32.620 --> 31:33.620
所以说我还不如

31:33.620 --> 31:34.620
直接把这个一句话拿过来

31:34.620 --> 31:35.620
那么这个Value

31:35.620 --> 31:36.620
它放到这的

31:36.620 --> 31:37.620
Value

31:37.620 --> 31:38.620
你看Value

31:38.620 --> 31:39.620
我们先不管它是啥

31:39.620 --> 31:40.620
Value这个产生放到这的

31:40.620 --> 31:41.620
那么我们就直接来

31:41.620 --> 31:42.620
所以把这样子写

31:46.190 --> 31:47.190
实际上这个还是我们

31:47.190 --> 31:48.190
就传那个

31:48.190 --> 31:49.190
undefend

31:49.190 --> 31:50.190
undefend

31:50.190 --> 31:51.190
不要

31:51.190 --> 31:52.190
那么这里Value

31:52.190 --> 31:53.190
Value是什么

31:53.190 --> 31:55.700
undefend

31:55.700 --> 31:56.700
把它变成这种格式

31:56.700 --> 31:57.700
看一下能不能运行

31:58.700 --> 32:00.700
那个是it's not defined

32:03.780 --> 32:04.780
对对

32:04.780 --> 32:05.780
不行不行

32:05.780 --> 32:07.780
它要把自身传进去

32:07.780 --> 32:08.780
不行

32:08.780 --> 32:09.780
还要把自身传进去

32:09.780 --> 32:10.780
那么我们这些

32:10.780 --> 32:11.780
都保留吧

32:11.780 --> 32:13.780
其实也不复杂了

32:13.780 --> 32:15.780
到这一步就不复杂了

32:15.780 --> 32:16.780
这里边提供了

32:16.780 --> 32:17.780
两个函数

32:17.780 --> 32:18.780
一个是Negas

32:18.780 --> 32:19.780
一个是Srow

32:19.780 --> 32:20.780
那么这两个函数

32:20.780 --> 32:21.780
是在干嘛用的呢

32:21.780 --> 32:22.780
然后这里边去

32:22.780 --> 32:23.780
调用了一下Negas

32:23.780 --> 32:24.780
这两个函数

32:24.780 --> 32:25.780
还蛮用的呢

32:25.780 --> 32:26.780
就是让这个生成器

32:26.780 --> 32:27.780
不断的下一步

32:27.780 --> 32:28.780
下一步

32:28.780 --> 32:29.780
下一步

32:29.780 --> 32:30.780
不停的执行

32:30.780 --> 32:31.780
因为它执行过程中

32:31.780 --> 32:32.780
有可能会爆错

32:32.780 --> 32:33.780
所以说它还提供了

32:33.780 --> 32:34.780
一个Srow函数

32:34.780 --> 32:35.780
如果说爆错的话

32:35.780 --> 32:36.780
就调用这个函数

32:36.780 --> 32:37.780
Srow函数

32:37.780 --> 32:38.780
爆错了是不是

32:38.780 --> 32:39.780
应该就reject了

32:39.780 --> 32:40.780
对吧

32:40.780 --> 32:41.780
就应该就是结束了

32:41.780 --> 32:42.780
那么其实

32:42.780 --> 32:44.780
它就调用这个生成器函数

32:44.780 --> 32:45.780
下一步

32:45.780 --> 32:46.780
下一步

32:46.780 --> 32:47.780
直到它完成

32:47.780 --> 32:48.780
它生成器完成了

32:48.780 --> 32:49.780
生成器完成了

32:49.780 --> 32:50.780
整个Promise就完成了

32:50.780 --> 32:51.780
生成器在运行的过程中

32:51.780 --> 32:52.780
爆错了

32:52.780 --> 32:53.780
整个Promise就reject了

32:53.780 --> 32:54.780
就这么个意思

32:54.780 --> 32:55.780
生成器完成

32:55.780 --> 32:56.780
Promise Resolve

32:56.780 --> 32:57.780
生成器没有完成

32:57.780 --> 32:58.780
生成器

32:58.780 --> 32:59.780
爆错了

32:59.780 --> 33:00.780
出了问题

33:00.780 --> 33:02.780
那么这里就reject了

33:02.780 --> 33:03.780
它就是这么做的

33:03.780 --> 33:04.780
那么一开始

33:04.780 --> 33:05.780
是不是调用Negas

33:05.780 --> 33:06.780
开始了

33:06.780 --> 33:07.780
开始任务

33:07.780 --> 33:08.780
好

33:08.780 --> 33:09.780
那这里的它的实现

33:09.780 --> 33:10.780
它是一拖与另外一个

33:10.780 --> 33:11.780
函数来实现的

33:11.780 --> 33:12.780
这个函数

33:12.780 --> 33:13.780
要告诉它这么一些东西

33:13.780 --> 33:14.780
告诉它

33:14.780 --> 33:15.780
因为它要不断的去Negas

33:15.780 --> 33:16.780
Negas

33:16.780 --> 33:17.780
Negas

33:17.780 --> 33:18.780
要不断的去下一步

33:18.780 --> 33:19.780
生成器告诉它

33:19.780 --> 33:20.780
要把这个

33:20.780 --> 33:21.780
因为它完成

33:21.780 --> 33:22.780
最重要完成

33:22.780 --> 33:23.780
完成了过后

33:23.780 --> 33:24.780
它要调用一个函数来完成

33:24.780 --> 33:26.780
我们把resolve函数给它

33:26.780 --> 33:27.780
它才知道

33:27.780 --> 33:28.780
我完成了之后

33:28.780 --> 33:30.780
我要调用这个函数resolve

33:30.780 --> 33:31.780
还有如果说

33:31.780 --> 33:32.780
出了问题的话

33:32.780 --> 33:33.780
我就要调用reject

33:33.780 --> 33:34.780
reject这个函数给它

33:35.780 --> 33:36.780
那么由于它要不断的

33:36.780 --> 33:37.780
下一步

33:37.780 --> 33:38.780
下一步是要帝规

33:38.780 --> 33:39.780
那么要把Negas

33:39.780 --> 33:41.780
这个函数本身要给它

33:41.780 --> 33:42.780
它要帮助它帝规

33:43.780 --> 33:44.780
如果说中间有问题

33:44.780 --> 33:45.780
出了问题

33:45.780 --> 33:47.780
它要调用这个函数

33:48.780 --> 33:49.780
中间可能要

33:49.780 --> 33:50.780
抛出一个错误

33:50.780 --> 33:52.780
那么这个地方

33:52.780 --> 33:53.780
就要告诉它

33:53.780 --> 33:54.780
到底是调用Negas

33:54.780 --> 33:55.780
还是要调用Stroke

33:55.780 --> 33:56.780
到底是调用Negas

33:56.780 --> 33:57.780
还是调用Stroke

33:59.780 --> 34:00.780
那么

34:00.780 --> 34:01.780
后面就是相关的数据

34:01.780 --> 34:03.780
就是resolve的时候的数据

34:03.780 --> 34:05.780
或者是错误的时候的error

34:05.780 --> 34:07.780
就是resolve的时候的数据

34:07.780 --> 34:08.780
错误的时候error

34:08.780 --> 34:09.780
给它

34:09.780 --> 34:10.780
然后我们启动

34:10.780 --> 34:11.780
下一步

34:11.780 --> 34:12.780
就是任何报处

34:12.780 --> 34:13.780
所以说

34:13.780 --> 34:14.780
它只是直接Negas

34:14.780 --> 34:15.780
开始

34:15.780 --> 34:16.780
那么我们来看一下

34:16.780 --> 34:19.150
这个函数的实现

34:19.150 --> 34:20.150
这个函数其实

34:20.150 --> 34:21.150
这个函数其实没用了

34:21.150 --> 34:22.150
是吧

34:22.150 --> 34:23.150
是不是没用了

34:24.150 --> 34:25.150
好像是没用了

34:25.150 --> 34:26.150
我们把它去掉

34:26.150 --> 34:27.150
看一下

34:27.150 --> 34:28.150
应该是没用的

34:28.150 --> 34:31.230
运行看一下

34:31.230 --> 34:32.230
6

34:32.230 --> 34:33.230
对吧

34:33.230 --> 34:34.230
6得到了

34:34.230 --> 34:35.230
得到结果了

34:37.230 --> 34:38.230
咱们看一下这个函数

34:39.230 --> 34:40.230
这个函数

34:40.230 --> 34:41.230
它其实这个函数代码

34:41.230 --> 34:46.360
就不复杂了

34:46.360 --> 34:49.360
我们格式化一下

34:49.360 --> 34:51.360
格式化一下

34:51.360 --> 34:52.360
好

34:52.360 --> 34:53.360
离开一下吧

34:53.360 --> 34:54.360
给我生成器

34:54.360 --> 34:55.360
给我resolve函数

34:55.360 --> 34:56.360
给我regex函数

34:56.360 --> 34:58.360
给我继续执行

34:58.360 --> 34:59.360
下一步的函数

34:59.360 --> 35:00.360
或者是报错的函数

35:00.360 --> 35:01.360
给我

35:01.360 --> 35:02.360
你到底要执行Negas

35:02.360 --> 35:04.360
还是要执行Stroke

35:04.360 --> 35:06.360
就是个key值

35:06.360 --> 35:07.360
要么就传Negas

35:07.360 --> 35:09.360
要么就传Stroke

35:09.360 --> 35:10.360
然后呢

35:10.360 --> 35:11.360
给我就是

35:11.360 --> 35:12.360
剩余的数据

35:12.360 --> 35:13.360
就是完成的时候

35:13.360 --> 35:15.360
或者是错误的时候

35:16.360 --> 35:18.360
它怎么执行的呢

35:18.360 --> 35:20.360
generator key

35:20.360 --> 35:21.360
调用这个函数

35:21.360 --> 35:23.360
把这个数据传进去

35:23.360 --> 35:25.360
是不是就相当于是我们

35:25.360 --> 35:26.360
刚才那个

35:26.360 --> 35:28.360
如果说这个key是Negas

35:28.360 --> 35:29.360
那么是不是就调用

35:29.360 --> 35:30.360
相当于是调用Negas

35:30.360 --> 35:32.360
如果说这个key是Stroke

35:32.360 --> 35:34.360
是不是相当于是调用Stroke

35:34.360 --> 35:35.360
对吧

35:35.360 --> 35:36.360
那么我们肯定这里没有错误

35:36.360 --> 35:38.360
相当于是去调用Negas

35:38.360 --> 35:39.360
对吧

35:39.360 --> 35:40.360
那么我们把它换成Negas

35:40.360 --> 35:41.360
行不行呢

35:41.360 --> 35:42.360
换成Negas

35:42.360 --> 35:43.360
来减换一下

35:43.360 --> 35:46.250
软扣的

35:46.250 --> 35:47.250
是不是还是可以

35:47.250 --> 35:48.250
因为我们这里不存在有错误

35:48.250 --> 35:49.250
对吧

35:49.250 --> 35:50.250
那个时候

35:50.250 --> 35:51.250
那么我们尽量进一步转化

35:51.250 --> 35:52.250
因为我们现在不关心

35:52.250 --> 35:53.250
什么错误

35:53.250 --> 35:54.250
不关心什么错误

35:54.250 --> 35:55.250
所以这个Stroke

35:55.250 --> 35:56.250
这个Stroke

35:56.250 --> 35:57.250
其实都可以不要了

35:57.250 --> 35:58.250
都可以不要了

35:58.250 --> 35:59.250
Stroke

35:59.250 --> 36:00.250
可以不要了

36:00.250 --> 36:01.250
这个key也可以不要了

36:01.250 --> 36:02.250
这个Stroke

36:02.250 --> 36:03.250
也可以不要了

36:04.250 --> 36:05.250
不要了

36:06.250 --> 36:07.250
那么这样子

36:07.250 --> 36:08.250
看得更加清楚一点

36:08.250 --> 36:09.250
看得更加清楚一点

36:09.250 --> 36:10.250
然后呢

36:10.250 --> 36:11.250
这里的函数参数变成了5个

36:11.250 --> 36:12.250
对吧

36:12.250 --> 36:13.250
5个

36:13.250 --> 36:14.250
那么我们这里呢

36:14.250 --> 36:15.250
也稍微写一下

36:15.250 --> 36:16.250
Stroke这个函数了

36:16.250 --> 36:17.250
那么我们就相当于是

36:17.250 --> 36:18.250
Resolver

36:18.250 --> 36:19.250
Gekers

36:19.250 --> 36:20.250
Negas

36:20.250 --> 36:21.250
然后Value

36:21.250 --> 36:22.250
就完了

36:22.250 --> 36:24.250
就是不断的下一步

36:24.250 --> 36:25.250
下一步

36:26.250 --> 36:27.250
来吧

36:27.250 --> 36:28.250
我们来看一下吧

36:28.250 --> 36:29.250
这样传过去

36:29.250 --> 36:30.250
好

36:30.250 --> 36:31.250
那么这边就很好理解了

36:31.250 --> 36:32.250
这边干嘛用的呢

36:32.250 --> 36:33.250
就是

36:33.250 --> 36:34.250
下一步

36:34.250 --> 36:36.250
执行到下一个eO的

36:36.250 --> 36:37.250
下一个eO的位置

36:37.250 --> 36:38.250
好

36:38.250 --> 36:39.250
得到一个东西

36:39.250 --> 36:40.250
得到一个东西

36:40.250 --> 36:42.250
那么一个东西的Value值取出来

36:42.250 --> 36:43.250
就是我们把我们之前

36:43.250 --> 36:44.250
还说的Value值取出来

36:44.250 --> 36:46.250
就eO的后边的

36:46.250 --> 36:47.250
就是eO的

36:47.250 --> 36:48.250
eO的后边这个东西的

36:48.250 --> 36:49.250
值取出来

36:49.250 --> 36:50.250
取出来过后

36:50.250 --> 36:52.250
如果说这个过程中有错误

36:52.250 --> 36:53.250
那么干嘛

36:54.250 --> 36:57.250
就直接结束了

36:57.250 --> 36:58.250
好

36:58.250 --> 36:59.250
如果说没有错误

36:59.250 --> 37:00.250
没有错误干嘛呢

37:00.250 --> 37:01.250
没有错误

37:01.250 --> 37:02.250
我看一下

37:02.250 --> 37:03.250
是不是完成了呀

37:03.250 --> 37:04.250
是不是整个生存器完成了呀

37:04.250 --> 37:05.250
任务完成了呀

37:05.250 --> 37:07.250
如果说已经完成了

37:07.250 --> 37:08.250
我们就Resolver

37:08.250 --> 37:09.250
看到没

37:09.250 --> 37:10.250
就这么一个逻辑

37:10.250 --> 37:11.250
好

37:11.250 --> 37:12.250
如果说没有完成的话

37:12.250 --> 37:13.250
没有完成是不是

37:13.250 --> 37:14.250
继续要进行下一步

37:14.250 --> 37:15.250
对吧

37:15.250 --> 37:16.250
继续要进行下一步

37:16.250 --> 37:17.250
你看它怎么做的

37:17.250 --> 37:18.250
我不管你这个Value

37:18.250 --> 37:19.250
这个Value

37:19.250 --> 37:20.250
它有可能是一个Promise

37:20.250 --> 37:21.250
有可能是一个普通的东西

37:21.250 --> 37:22.250
对吧

37:22.250 --> 37:23.250
我都把它转换成Promise

37:23.250 --> 37:24.250
通过这种方式

37:24.250 --> 37:25.250
就可以把任何一个数据

37:25.250 --> 37:26.250
转换成Promise

37:26.250 --> 37:27.250
好

37:27.250 --> 37:28.250
转换成Promise过后

37:28.250 --> 37:30.250
这个Promise完成之后

37:30.250 --> 37:32.250
如果说它本身是Promise的话

37:32.250 --> 37:34.250
那么它等它完成之后

37:34.250 --> 37:35.250
完成之后干嘛呢

37:35.250 --> 37:36.250
是不是又来下一步

37:36.250 --> 37:37.250
又下一步

37:37.250 --> 37:38.250
这个下一步哪来的

37:38.250 --> 37:39.250
下一步是不是它

37:39.250 --> 37:40.250
对吧

37:40.250 --> 37:41.250
又下一步

37:41.250 --> 37:43.250
那么把Promise的结果

37:43.250 --> 37:44.250
是不是拿过来了

37:44.250 --> 37:45.250
Promise的结果

37:45.250 --> 37:46.250
是不是拿过来了

37:46.250 --> 37:47.250
这里的写法就相当于是

37:47.250 --> 37:49.250
拿到Promise的数据

37:49.250 --> 37:51.250
然后我又调用那个词程

37:51.250 --> 37:52.250
对吧

37:52.250 --> 37:54.250
是不是相当于这样的写法

37:54.250 --> 37:56.250
又调用它

37:56.250 --> 37:57.250
那么这样子

37:57.250 --> 37:58.250
是不是又

37:58.250 --> 37:59.250
那么它里边又去调用它

37:59.250 --> 38:00.250
是不是又来下一步

38:00.250 --> 38:01.250
下一步

38:01.250 --> 38:02.250
对吧

38:02.250 --> 38:03.250
又来下一步了

38:03.250 --> 38:04.250
又调用这个函数了

38:04.250 --> 38:05.250
又来下一步

38:05.250 --> 38:06.250
来吧

38:06.250 --> 38:07.250
就这样

38:07.250 --> 38:08.250
这样

38:08.250 --> 38:09.250
不行的下去

38:09.250 --> 38:10.250
不行的进行下去

38:10.250 --> 38:11.250
那么这样子的

38:11.250 --> 38:13.250
直到它完成为止

38:13.250 --> 38:14.250
对吧

38:14.250 --> 38:15.250
它完成了

38:15.250 --> 38:16.250
它完成的时候

38:16.250 --> 38:17.250
它就会调用Resolve

38:17.250 --> 38:18.250
那么Resolve为调用

38:18.250 --> 38:20.250
是不是Promise就完成了

38:20.250 --> 38:21.250
对吧

38:21.250 --> 38:22.250
它就是用这种模式

38:22.250 --> 38:23.250
它整个失路了

38:23.250 --> 38:24.250
跟我们之前讲

38:24.250 --> 38:25.250
ES6的时候

38:25.250 --> 38:26.250
那个生成器

38:26.250 --> 38:28.250
来控制一部任务的失路

38:28.250 --> 38:29.250
是一样的

38:29.250 --> 38:30.250
就是一个地规的方式

38:30.250 --> 38:31.250
不断的下一步

38:31.250 --> 38:32.250
直到它完成

38:32.250 --> 38:33.250
中间有错误

38:33.250 --> 38:34.250
就Reject

38:34.250 --> 38:36.250
那么就完

38:36.250 --> 38:37.250
看

38:37.250 --> 38:38.250
最后

38:38.250 --> 38:39.250
结果

38:40.250 --> 38:41.250
这就是

38:41.250 --> 38:42.250
在Bible里边

38:42.250 --> 38:44.250
它如何来处理

38:44.250 --> 38:46.250
Essink位置的

38:46.250 --> 38:48.250
整体的失路就很简单

38:48.250 --> 38:50.250
先转换成生成器

38:50.250 --> 38:52.250
然后生成器的预防

38:52.250 --> 38:53.250
又需要转换

38:53.250 --> 38:55.250
再把生成器转换成一个

38:55.250 --> 38:57.250
生成器使用Regenerator

38:57.250 --> 38:59.250
Runtime里面提供的API

38:59.250 --> 39:01.250
来完成转换

39:01.250 --> 39:03.250
整个的失路就是这样子

39:03.250 --> 39:04.250
OK

39:04.250 --> 39:05.250
这是关于

39:05.250 --> 39:07.250
Essink而位置的转换

39:07.250 --> 39:08.250
这个东西

39:08.250 --> 39:09.250
有啥意义呢

39:09.250 --> 39:10.250
没啥意义

39:10.250 --> 39:11.250
给大家看一下

39:11.250 --> 39:13.250
它的失路是怎么样子的

39:14.250 --> 39:16.250
给大家开会一下眼界

39:16.250 --> 39:17.250
那么这一张

39:17.250 --> 39:18.250
这东西就结束了

39:18.250 --> 39:19.250
其实你要说

39:19.250 --> 39:20.250
要讲

39:20.250 --> 39:21.250
讲Bible里面

39:21.250 --> 39:23.250
对各种代码的转换

39:23.250 --> 39:24.250
还可以讲很多

39:24.250 --> 39:26.250
如果说你有兴趣

39:26.250 --> 39:27.250
当然这个兴趣

39:27.250 --> 39:28.250
首先说这个兴趣

39:28.250 --> 39:29.250
是非常好的事情

39:29.250 --> 39:30.250
只不过

39:30.250 --> 39:31.250
由于你们现在

39:31.250 --> 39:32.250
你要考虑一个问题

39:32.250 --> 39:34.250
就是将来的

39:34.250 --> 39:35.250
就业

39:35.250 --> 39:37.250
就业的时间

39:37.250 --> 39:38.250
你要考虑这个问题

39:38.250 --> 39:39.250
你不能花

39:39.250 --> 39:41.250
最好不要花太多的时间

39:41.250 --> 39:42.250
在这上面

39:42.250 --> 39:44.250
等到你们以后工作了

39:44.250 --> 39:45.250
工作了过后

39:45.250 --> 39:46.250
平时像周末放假

39:46.250 --> 39:47.250
有一些额外的时间

39:47.250 --> 39:49.250
你对技术很有兴趣吗

39:49.250 --> 39:50.250
我们就来讨论一下

39:50.250 --> 39:51.250
这些问题

39:51.250 --> 39:52.250
或者是往上去看一下

39:52.250 --> 39:54.250
这些相关的问题

39:54.250 --> 39:55.250
以前没有搞清楚的

39:55.250 --> 39:56.250
利用这些空语的时间

39:56.250 --> 39:57.250
去搞清楚

39:57.250 --> 39:58.250
现阶段

39:58.250 --> 39:59.250
我们主要是

39:59.250 --> 40:00.250
还要面向就业

40:00.250 --> 40:01.250
因此这些东西

40:01.250 --> 40:02.250
跟就业没有什么帮助

40:02.250 --> 40:04.250
你可以花时间

40:04.250 --> 40:06.250
开花一下眼界

40:06.250 --> 40:08.250
但是不要花太多的时间

40:08.250 --> 40:10.250
把主线任务

40:10.250 --> 40:11.250
给耽误了

40:11.250 --> 40:12.250
直线任务可以做

40:12.250 --> 40:14.250
主线任务不要耽误

40:14.250 --> 40:15.250
这是我们这一张

40:15.250 --> 40:16.250
讲的

40:16.250 --> 40:17.250
介石 建东西

