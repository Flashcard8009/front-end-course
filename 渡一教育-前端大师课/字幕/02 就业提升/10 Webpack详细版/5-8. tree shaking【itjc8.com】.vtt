WEBVTT

00:00.690 --> 00:03.690
咱们再一次强调一次

00:03.690 --> 00:07.690
就说这个优化的章节它东西特别多

00:07.690 --> 00:12.690
但是没有必要去全部的记忆

00:12.690 --> 00:13.690
没有意义

00:13.690 --> 00:15.690
当你们以后遇到了一些性能问题

00:15.690 --> 00:18.690
比较说你要单独来处理性能优化

00:18.690 --> 00:19.690
那么这个时候呢

00:19.690 --> 00:22.690
我们这个章节来查阅一下

00:22.690 --> 00:23.690
有哪些手段呀

00:23.690 --> 00:27.690
什么手段能够适应我目前的工作

00:27.690 --> 00:29.690
应该是起车妹的效果

00:29.690 --> 00:31.690
不用去记忆

00:31.690 --> 00:33.690
好 咱们继续来讲传输性能里面

00:33.690 --> 00:36.690
另一个方面 单模块体积优化

00:36.690 --> 00:38.690
之前咱们讲的代码压缩

00:38.690 --> 00:40.690
靠工具这种完成的

00:40.690 --> 00:43.690
那么这节课咱们讲另外一个叫垂斜键

00:43.690 --> 00:47.690
因为代码压缩起的作用

00:47.690 --> 00:49.690
它指的是一个模块里边

00:49.690 --> 00:51.690
代码的格式给它改一下

00:51.690 --> 00:52.690
电量铭改一下

00:52.690 --> 00:53.690
方法铭

00:53.690 --> 00:54.690
参数铭改一下

00:54.690 --> 00:57.690
尽量的让我们的制服数量更少

00:57.690 --> 01:01.690
你达到减少模块里边的体积的目的

01:01.690 --> 01:04.690
那么缺斜键来解决什么样的问题呢

01:04.690 --> 01:07.690
好 咱们来看这节课的课件

01:07.690 --> 01:09.690
我们的那个代码压缩

01:09.690 --> 01:12.690
可以移除模块内部的无效代码

01:12.690 --> 01:14.690
包括改一些电量铭之类的东西

01:14.690 --> 01:16.690
缺斜键呢

01:16.690 --> 01:19.690
它也是用来移除无效代码的

01:19.690 --> 01:22.690
但它可以移除模块之间的无效代码

01:22.690 --> 01:23.690
啥意思呢

01:23.690 --> 01:25.690
下边有一个非常形象的图

01:25.690 --> 01:27.690
缺斜键就一棵树

01:27.690 --> 01:28.690
斜键就斗洞

01:28.690 --> 01:31.690
你看一棵树斗洞是不是把那些

01:31.690 --> 01:36.690
已经什么快要撑不住的一些果实

01:36.690 --> 01:37.690
就把斗落下来了

01:37.690 --> 01:39.690
就是那些没用的东西就把斗落下来了

01:39.690 --> 01:41.690
就缺斜键非常的形象

01:41.690 --> 01:43.690
那么我们来一次来看一下

01:43.690 --> 01:45.690
这一块比较重要

01:45.690 --> 01:47.690
如果说这一块你用的好的话

01:47.690 --> 01:51.690
你可以极大地缩减你的最终的保护体积

01:51.690 --> 01:53.690
非常明显的感觉到

01:53.690 --> 01:55.690
那个缩减的就不是

01:55.690 --> 01:57.690
那幅度是非常非常大的

01:57.690 --> 01:59.690
因为我们比方说某些模块

01:59.690 --> 02:00.690
它导出代码的

02:00.690 --> 02:02.690
它可能不一定用到

02:02.690 --> 02:03.690
比方说这个模块

02:03.690 --> 02:04.690
我们有这么一个模块

02:04.690 --> 02:05.690
MineMass.js

02:05.690 --> 02:07.690
我们把它写一下吧

02:07.690 --> 02:09.690
在src里面简简的一个

02:11.690 --> 02:12.690
然后这里

02:12.690 --> 02:16.690
我们这里的写放过来

02:16.690 --> 02:17.690
这是我们这个模块

02:17.690 --> 02:19.690
MineMass这个模块

02:19.690 --> 02:21.690
那么这个模块提供两个方法

02:21.690 --> 02:22.690
导出了两个方法

02:22.690 --> 02:23.690
但是到这两个方法

02:23.690 --> 02:24.690
它不一定用到

02:24.690 --> 02:25.690
比方说我们这里的

02:25.690 --> 02:26.690
index.js里面

02:26.690 --> 02:28.690
它有这么一段代码

02:31.690 --> 02:32.690
index.js

02:34.690 --> 02:35.690
你看这个代码里面

02:35.690 --> 02:36.690
是不是只用到了MineMass里面的

02:36.690 --> 02:38.690
一个add add的方法

02:38.690 --> 02:40.690
它是sub

02:40.690 --> 02:41.690
就是减这个方法

02:41.690 --> 02:42.690
它是不是没有用到

02:42.690 --> 02:43.690
这就很类似于

02:43.690 --> 02:45.690
我们用一些第三方库的时候

02:45.690 --> 02:47.690
那么这些第三方库

02:47.690 --> 02:49.690
它提供了很多很多的API

02:49.690 --> 02:50.690
你看楼代型里面

02:50.690 --> 02:52.690
提供了好多好多的API

02:52.690 --> 02:53.690
它有一万多方代码

02:53.690 --> 02:54.690
但是我们其实

02:54.690 --> 02:56.690
并用不到那么多API

02:56.690 --> 02:58.690
我们只需要用那么一点点

02:58.690 --> 02:59.690
结果它一打包

02:59.690 --> 03:00.690
把全部给我打包进去了

03:00.690 --> 03:02.690
这就是造成了困难

03:02.690 --> 03:04.690
那么吹鞋杆

03:04.690 --> 03:05.690
就用来解决这个事

03:05.690 --> 03:06.690
就是一个模块

03:06.690 --> 03:08.690
它虽然导出了很多东西

03:08.690 --> 03:09.690
但是我别人

03:09.690 --> 03:10.690
其他的模块

03:10.690 --> 03:12.690
只是用到了其中一小部分

03:12.690 --> 03:14.690
只是用到其中一小部分

03:14.690 --> 03:16.690
那么这个时候

03:16.690 --> 03:17.690
实际上是没有必要

03:17.690 --> 03:19.690
把所有东西都打包的

03:19.690 --> 03:20.690
打包了一些

03:20.690 --> 03:21.690
我们要用到的部分

03:21.690 --> 03:23.690
只是这么个意思

03:23.690 --> 03:24.690
只是它的背景

03:24.690 --> 03:27.690
那么来看它的使用

03:27.690 --> 03:28.690
使用

03:28.690 --> 03:29.690
其实在VPAC2的

03:29.690 --> 03:31.690
还是就支持了

03:31.690 --> 03:32.690
吹鞋杆的

03:32.690 --> 03:33.690
吹鞋杆这个技术

03:33.690 --> 03:35.690
最早还不是VPAC

03:35.690 --> 03:36.690
VPAC出来的

03:36.690 --> 03:37.690
是别的技术出来的

03:37.690 --> 03:39.690
那VPAC2学过来了

03:39.690 --> 03:40.690
我告诉大家

03:40.690 --> 03:41.690
吹鞋杆这个技术

03:41.690 --> 03:42.690
什么时候出来的

03:42.690 --> 03:45.690
是上个世纪八十年代

03:45.690 --> 03:46.690
你说

03:46.690 --> 03:47.690
有的时候觉得美国

03:47.690 --> 03:49.690
真的是太厉害了

03:49.690 --> 03:50.690
我们在分立追赶

03:50.690 --> 03:53.690
现在不能说赶潮吧

03:53.690 --> 03:55.690
有并驾其趋的

03:55.690 --> 03:56.690
这么一个趋势

03:56.690 --> 03:57.690
还是有点距离

03:57.690 --> 03:58.690
咱们中国加油

03:58.690 --> 03:59.690
太厉害了

03:59.690 --> 04:01.690
上个世纪八十年代

04:01.690 --> 04:02.690
我们还来干吗

04:02.690 --> 04:03.690
我们那个时候连电脑

04:03.690 --> 04:04.690
家用电脑都没有

04:04.690 --> 04:05.690
他们吹鞋杆这个技术

04:05.690 --> 04:07.690
都已经出来了

04:07.690 --> 04:08.690
当然是在

04:08.690 --> 04:09.690
其他语言的话

04:09.690 --> 04:10.690
已经里面提出来了

04:10.690 --> 04:11.690
它就是这么一个意思

04:11.690 --> 04:12.690
模块之间斗动

04:12.690 --> 04:14.690
然后把一些无效的代码

04:14.690 --> 04:16.690
不要到打包结果

04:16.690 --> 04:18.690
那么在为拍颗里面

04:18.690 --> 04:19.690
其在二开始

04:19.690 --> 04:21.690
你不用去手动做什么

04:21.690 --> 04:23.690
你只要是一个生产环境

04:23.690 --> 04:25.690
吹鞋杆它自动启动

04:25.690 --> 04:26.690
它认为你这个是生产环境的

04:26.690 --> 04:28.690
因为我们这个吹鞋杆

04:28.690 --> 04:30.690
也只是在生产环境用一下

04:30.690 --> 04:31.690
你像我们的开发环境用它吗

04:31.690 --> 04:32.690
也没啥意义

04:32.690 --> 04:33.690
用它也没啥意义

04:33.690 --> 04:34.690
开发环境

04:34.690 --> 04:36.690
也不存在什么传修效率

04:36.690 --> 04:37.690
这些效率

04:37.690 --> 04:38.690
都不存在太大的问题

04:38.690 --> 04:39.690
所以说吹鞋杆

04:39.690 --> 04:41.690
一般不在开发环境里边使用

04:41.690 --> 04:43.690
一般在生产环境里边使用

04:43.690 --> 04:45.690
也说我们这里要

04:45.690 --> 04:47.690
当微拍2开始过

04:47.690 --> 04:48.690
就支持吹鞋杆

04:48.690 --> 04:50.690
但是它支持的很不完善

04:50.690 --> 04:51.690
它有很多很多的问题

04:51.690 --> 04:52.690
那么不断的改进

04:52.690 --> 04:53.690
微拍3

04:53.690 --> 04:54.690
微拍4不断的改进

04:54.690 --> 04:56.690
到现在是不是完美了

04:56.690 --> 04:57.690
也不是完美

04:57.690 --> 04:58.690
还是有很多的问题

04:58.690 --> 05:00.690
因为这一块确实比较麻烦

05:00.690 --> 05:01.690
比较复杂

05:01.690 --> 05:02.690
要解决起来不太容易

05:02.690 --> 05:04.690
但是还在尽力的解决

05:04.690 --> 05:06.690
那么我们看一下

05:06.690 --> 05:07.690
在微拍里边

05:07.690 --> 05:09.690
我们这里已经写好了一个配置了

05:09.690 --> 05:11.690
Mode就是Production

05:11.690 --> 05:14.690
Plugin是就一个Clean微拍Plugin

05:14.690 --> 05:16.690
那么这里拍个Clean接成里面

05:16.690 --> 05:17.690
我们把换个名字

05:17.690 --> 05:18.690
Build

05:18.690 --> 05:19.690
咱们来看一下

05:19.690 --> 05:21.690
我们现在就用生产环境打包

05:21.690 --> 05:23.690
看一下能不能把那些无效的代码

05:23.690 --> 05:25.690
抖动掉了

05:25.690 --> 05:27.690
我们使用NPM

05:27.690 --> 05:30.690
ZoneBuild

05:30.690 --> 05:35.470
等它打包完成

05:37.470 --> 05:40.470
就说我们现在的模块

05:40.470 --> 05:41.470
我们模块是这个

05:41.470 --> 05:43.470
这个方法是没有用到的

05:43.470 --> 05:44.470
那么我们看一下

05:44.470 --> 05:45.470
这个方法会不会出现在

05:45.470 --> 05:46.470
打包结果里边

05:46.470 --> 05:47.470
我们就搜什么

05:47.470 --> 05:48.470
搜这个SUB

05:48.470 --> 05:49.470
因为它方法名可能会变

05:49.470 --> 05:50.470
那个制服串是变不了的

05:50.470 --> 05:52.470
我们就搜这个

05:52.470 --> 05:53.470
在这里边

05:53.470 --> 05:54.470
我们搜一下

05:54.470 --> 05:55.470
是没有

05:55.470 --> 05:56.470
你看ADD

05:56.470 --> 05:57.470
是不是有

05:57.470 --> 05:58.470
SUB是不是没有

05:58.470 --> 05:59.470
说明了啥

05:59.470 --> 06:00.470
崔仙坤已经启动了

06:00.470 --> 06:02.470
它已经自动完成了

06:02.470 --> 06:04.470
你要说我们怎么去使用崔仙坤

06:04.470 --> 06:05.470
没有了

06:05.470 --> 06:06.470
没有什么怎么使用

06:06.470 --> 06:07.470
它自行完成了

06:07.470 --> 06:08.470
那为什么要学这个呢

06:08.470 --> 06:10.470
因为崔仙坤还有问题

06:10.470 --> 06:11.470
我们在写代码的时候

06:11.470 --> 06:13.470
要注意一下

06:13.470 --> 06:15.470
这是我们在U化阶段的话

06:15.470 --> 06:17.470
为数不多的

06:17.470 --> 06:20.470
会影响我们写代码的部分

06:20.470 --> 06:21.470
你看我们之前的U化

06:21.470 --> 06:23.470
代码你随便写

06:23.470 --> 06:24.470
剩下的东西交给工具

06:24.470 --> 06:25.470
这是最好的

06:25.470 --> 06:26.470
最好的现象就是这样子

06:26.470 --> 06:28.470
但是呢

06:28.470 --> 06:30.470
这个崔仙坤

06:30.470 --> 06:32.470
它会影响我们的写代码

06:32.470 --> 06:33.470
它影响了不多

06:33.470 --> 06:36.470
因为它目前没有

06:36.470 --> 06:37.470
无限的智能

06:37.470 --> 06:39.470
它智能是有限的

06:39.470 --> 06:40.470
所以说没办法

06:40.470 --> 06:42.470
我们来看一下原理

06:42.470 --> 06:44.470
它的原理认识清楚了过后

06:44.470 --> 06:46.470
原本理单码应该怎么写

06:46.470 --> 06:48.470
VPAC我们知道它打包

06:48.470 --> 06:49.470
是通过入口模块

06:49.470 --> 06:50.470
去寻找依赖关系

06:50.470 --> 06:52.470
比方说我们这里的入口模块

06:52.470 --> 06:53.470
入口模块是index

06:53.470 --> 06:54.470
它通过这个模块

06:54.470 --> 06:56.470
去寻找依赖关系

06:56.470 --> 06:57.470
那么怎么来寻找呢

06:57.470 --> 06:59.470
它解析一个模块的时候

06:59.470 --> 07:00.470
它会根据

07:00.470 --> 07:02.470
就是我们当初去写写

07:02.470 --> 07:03.470
VPAC会根据

07:03.470 --> 07:06.470
ES6的模块导入语句来判断

07:06.470 --> 07:07.470
你看index.js里面

07:07.470 --> 07:08.470
是不是有

07:08.470 --> 07:09.470
ES6

07:09.470 --> 07:11.470
这是一个ES6的模块导入语句

07:11.470 --> 07:12.470
那么它会通过

07:12.470 --> 07:14.470
这个模块导入的语句来判断

07:14.470 --> 07:16.470
我依赖哪个模块

07:16.470 --> 07:18.470
我依赖mymas这个模块

07:18.470 --> 07:22.470
我依赖mymas这个模块

07:22.470 --> 07:23.470
我依赖啥呢

07:23.470 --> 07:25.470
依赖这个模块里面的一个东西

07:25.470 --> 07:26.470
ADD

07:26.470 --> 07:27.470
那么这个时候呢

07:27.470 --> 07:28.470
VPAC就会做标记

07:28.470 --> 07:29.470
标记一个

07:29.470 --> 07:31.470
你可以简单的想象一下

07:31.470 --> 07:33.470
它会在有一个表格

07:33.470 --> 07:34.470
它里面记录了

07:34.470 --> 07:35.470
有人

07:35.470 --> 07:36.470
我们现在找到了一个依赖

07:36.470 --> 07:38.470
就是这个模块里面的ADD

07:38.470 --> 07:39.470
是要用的

07:39.470 --> 07:40.470
这是我们要用的

07:41.470 --> 07:43.470
它跟Deadcode不一样

07:43.470 --> 07:45.470
Deadcode是检测了一些不用的

07:45.470 --> 07:48.470
TreatCode是检测了一些要用的

07:48.470 --> 07:50.470
它这个思路是有点相反的

07:50.470 --> 07:52.470
那么它就把这个东西标记一下

07:52.470 --> 07:53.470
我这个东西有人用

07:53.470 --> 07:55.470
它就做了一个标记

07:55.470 --> 07:56.470
那么再看

07:58.470 --> 08:02.470
它为什么要选择ES6模块的

08:02.470 --> 08:04.470
为什么不是common.js呢

08:04.470 --> 08:05.470
你看它这个依赖

08:05.470 --> 08:06.470
我们刚才说

08:06.470 --> 08:08.470
它选择的是ES6的模块导入语句

08:08.470 --> 08:09.470
为什么不是common.js呢

08:09.470 --> 08:11.470
因为它ES6模块

08:11.470 --> 08:12.470
它有这么几个特点

08:12.470 --> 08:14.470
咱们之前学过模块画的时候都讲过

08:14.470 --> 08:18.470
一个导入导出语句只能是顶层语句

08:18.470 --> 08:19.470
这我们说过

08:19.470 --> 08:22.470
咱们的导入语句必须放到顶层

08:22.470 --> 08:23.470
而且按照标准来说

08:23.470 --> 08:25.470
要放到全部在最上面

08:25.470 --> 08:29.470
导出语句也不能在一个循环里边

08:29.470 --> 08:31.470
也不能在一个判断里边

08:31.470 --> 08:32.470
也必须要放到顶层

08:32.470 --> 08:34.470
它导入导出语句放到顶层的

08:34.470 --> 08:36.470
那么就意味着什么呢

08:36.470 --> 08:37.470
意味着

08:38.470 --> 08:40.470
这个代码不用运行

08:40.470 --> 08:41.470
就是我们这些代码不用运行

08:41.470 --> 08:43.470
它就知道了哪些依赖

08:43.470 --> 08:44.470
说这个道理

08:44.470 --> 08:46.470
那如果说common.js的话

08:46.470 --> 08:47.470
问题就来了

08:47.470 --> 08:49.470
common.js完全可能会出现这种情况

08:49.470 --> 08:54.470
判断一个

08:54.470 --> 08:55.470
判断一个

08:55.470 --> 08:56.470
如果说满足条件

08:56.470 --> 08:57.470
我才去导入

08:57.470 --> 08:58.470
那么这个玩意儿

08:58.470 --> 09:00.470
由于我们代码在打包期间

09:00.470 --> 09:01.470
就是为拍个构建期间

09:01.470 --> 09:03.470
它是不会运行的

09:03.470 --> 09:04.470
那么这个代码它到底要不要运行

09:04.470 --> 09:06.470
到底有没有依赖

09:06.470 --> 09:07.470
它就蒙了

09:07.470 --> 09:09.470
那个微拍就蒙了

09:09.470 --> 09:11.470
所以说它没有办法针对common.js

09:11.470 --> 09:12.470
来实现这个优化

09:12.470 --> 09:13.470
只能针对野石流

09:13.470 --> 09:14.470
因为野石是有静态的

09:14.470 --> 09:15.470
你看

09:15.470 --> 09:16.470
这些东西

09:16.470 --> 09:18.470
你可以知道那些

09:18.470 --> 09:20.470
标准制定的人

09:20.470 --> 09:22.470
它牺牲了灵活度

09:22.470 --> 09:24.470
牺牲了那个模块的一旦的灵活度

09:24.470 --> 09:25.470
但是增加了什么

09:25.470 --> 09:28.470
可独性和优化能力

09:28.470 --> 09:30.470
那么第二个

09:30.470 --> 09:32.470
Inports的模块名

09:32.470 --> 09:33.470
只能是制服上的常量

09:33.470 --> 09:34.470
什么意思呢

09:34.470 --> 09:35.470
就是我们这些导入模块

09:35.470 --> 09:36.470
你这个东西不能来自于一个变量

09:36.470 --> 09:38.470
比方说我定一个变量

09:38.470 --> 09:39.470
把变量放在这儿

09:39.470 --> 09:40.470
不可能

09:40.470 --> 09:42.470
那么common.js是不是可以

09:42.470 --> 09:44.470
common.js无非就是个函数调用

09:44.470 --> 09:46.470
它跟所有的函数调用是一样的

09:46.470 --> 09:48.470
那common.js就可以

09:48.470 --> 09:50.470
那么这也是同样的保证了

09:50.470 --> 09:52.470
我不用运行这个代码

09:52.470 --> 09:53.470
我就知道确切的依赖

09:53.470 --> 09:55.470
common.js就不行

09:55.470 --> 09:56.470
因为它可能来自于变量

09:56.470 --> 09:57.470
那变量是什么

09:57.470 --> 09:58.470
要运行

09:58.470 --> 09:59.470
是这么个道理

09:59.470 --> 10:00.470
第三个原因

10:00.470 --> 10:02.470
是Inports的绑定的变量

10:02.470 --> 10:03.470
是不可变的

10:03.470 --> 10:04.470
什么意思呢

10:04.470 --> 10:05.470
就是我们

10:05.470 --> 10:06.470
这里的导入过后

10:06.470 --> 10:08.470
你能给add重新复制了吗

10:08.470 --> 10:09.470
是不能

10:09.470 --> 10:11.470
common.js是不是可以

10:11.470 --> 10:12.470
common.js

10:12.470 --> 10:14.470
如果说你只要不是用concept定义的

10:14.470 --> 10:16.470
不是用concept定义的常量

10:16.470 --> 10:17.470
那么这里呢

10:17.470 --> 10:18.470
你就可以随便给它重新复制

10:18.470 --> 10:19.470
但这里是不行的

10:19.470 --> 10:20.470
是不可变的

10:20.470 --> 10:21.470
那么不可变的

10:21.470 --> 10:22.470
进一步保证了

10:22.470 --> 10:23.470
这个东西的稳定

10:23.470 --> 10:25.470
就是我真的是依赖这个东西

10:25.470 --> 10:26.470
而不是别的

10:26.470 --> 10:28.470
因为我不可能改动它

10:28.470 --> 10:29.470
对吧

10:29.470 --> 10:30.470
而包括我们知道

10:30.470 --> 10:32.470
如果说你用新号

10:32.470 --> 10:33.470
就是obj

10:33.470 --> 10:35.470
那么obj里面的所有东西也是不可变的

10:35.470 --> 10:37.470
它的属性也是不可变的

10:37.470 --> 10:38.470
对吧

10:38.470 --> 10:39.470
ok

10:39.470 --> 10:40.470
那么这就是

10:40.470 --> 10:41.470
它为什么要依赖es6

10:41.470 --> 10:43.470
而不是common.js

10:45.470 --> 10:46.470
那么由于这些特征呢

10:46.470 --> 10:49.470
它都非常边与分析一代

10:49.470 --> 10:50.470
不是说common.js

10:50.470 --> 10:51.470
它不能分析

10:51.470 --> 10:53.470
你想一想办法

10:53.470 --> 10:54.470
总能找到办法

10:54.470 --> 10:55.470
但是它一复杂

10:55.470 --> 10:56.470
太麻烦了

10:56.470 --> 10:58.470
目前没有很好的办法

10:58.470 --> 11:00.470
目前没有很好的办法

11:00.470 --> 11:02.470
那么vipack坚持的原则

11:02.470 --> 11:03.470
就在分析的遗难的时候

11:03.470 --> 11:04.470
还坚持的原则就是

11:04.470 --> 11:06.470
尽量的要保证代码正常运行

11:06.470 --> 11:07.470
就是这个前提

11:07.470 --> 11:09.470
就是我不能因为优化

11:09.470 --> 11:10.470
导致到代码

11:10.470 --> 11:11.470
到时候除了区区过去

11:11.470 --> 11:12.470
不能运行了

11:12.470 --> 11:13.470
这个vipack是受不了的

11:13.470 --> 11:14.470
拉它被骂产

11:14.470 --> 11:15.470
所以说

11:15.470 --> 11:16.470
它必须要保证代码正常运行

11:16.470 --> 11:18.470
因此你再使用

11:18.470 --> 11:19.470
去shaking的时候

11:19.470 --> 11:21.470
不用过于担心

11:21.470 --> 11:22.470
有的时候

11:22.470 --> 11:23.470
要担心那一点点

11:23.470 --> 11:24.470
我以后就会说

11:24.470 --> 11:26.470
如果说你不做操作

11:26.470 --> 11:27.470
不做任何配置

11:27.470 --> 11:28.470
不做任何操作的话

11:28.470 --> 11:29.470
那么你完全不用担心

11:29.470 --> 11:30.470
它代码是不能运行的

11:30.470 --> 11:31.470
它一定能运行

11:31.470 --> 11:32.470
可能呢

11:32.470 --> 11:33.470
优化没有撑那么彻底

11:33.470 --> 11:34.470
它倒要保证运行

11:34.470 --> 11:35.470
所以说

11:35.470 --> 11:36.470
你在用去shaking的时候

11:36.470 --> 11:37.470
不用害怕

11:37.470 --> 11:38.470
只要你不去动它

11:38.470 --> 11:39.470
也不用害怕

11:39.470 --> 11:41.470
然后在保证代码运行的

11:41.470 --> 11:42.470
能够正常运行的基础上

11:42.470 --> 11:43.470
再去尽量的去shaking

11:43.470 --> 11:44.470
去shaking就是

11:44.470 --> 11:45.470
删除代码

11:45.470 --> 11:46.470
删除无效的代码

11:46.470 --> 11:47.470
模块之间

11:47.470 --> 11:48.470
没有用到的代码

11:48.470 --> 11:49.470
就是删除掉

11:49.470 --> 11:50.470
删代码的时候

11:50.470 --> 11:51.470
是非常非常小心的

11:52.470 --> 11:53.470
所以说呢

11:53.470 --> 11:54.470
如果说你依赖的是

11:54.470 --> 11:55.470
一个导出的对象

11:55.470 --> 11:57.470
由于JS语言的动态特性

11:57.470 --> 11:58.470
以及为排海不够智能

11:58.470 --> 11:59.470
为了保得代码运行的

11:59.470 --> 12:00.470
它不会移除

12:00.470 --> 12:02.470
对象里边的任何信息

12:02.470 --> 12:03.470
什么意思呢

12:03.470 --> 12:04.470
就说如果说

12:04.470 --> 12:06.470
咱们在麦麦室里边

12:06.470 --> 12:07.470
不是这样导出的

12:08.470 --> 12:09.470
我是这样导出的

12:09.470 --> 12:12.810
你看着

12:12.810 --> 12:13.810
我是这样导出的

12:14.810 --> 12:15.810
有一个add

12:16.810 --> 12:17.810
我们把这个

12:17.810 --> 12:20.310
这个复制一下吧

12:21.310 --> 12:23.310
我们这里是这样导出的

12:23.310 --> 12:24.310
就是用default的方式

12:24.310 --> 12:25.310
来导出

12:25.310 --> 12:26.310
你看一下有什么不一样

12:26.310 --> 12:28.310
因为它有这个原则存在

12:31.260 --> 12:32.260
OK

12:32.260 --> 12:33.260
我们用这种方式导出

12:33.260 --> 12:34.260
那么这边怎么来导入呢

12:34.260 --> 12:36.260
就是obj

12:38.260 --> 12:40.260
我们只用了obj.add

12:40.260 --> 12:41.260
只用了它

12:41.260 --> 12:42.260
对不对

12:42.260 --> 12:43.260
那么我们来看一下

12:43.260 --> 12:44.260
它sub会不会到

12:44.260 --> 12:46.260
最终结果里面去

12:46.260 --> 12:50.370
等一下

12:50.370 --> 12:51.370
出来了

12:51.370 --> 12:52.370
你看一下

12:52.370 --> 12:53.370
sub

12:53.370 --> 12:54.370
这个东西还分

12:54.370 --> 12:56.370
它能够分析的出来

12:58.370 --> 12:59.370
我想想

12:59.370 --> 13:02.830
不至于吧

13:02.830 --> 13:03.830
我觉得应该

13:03.830 --> 13:04.830
肯定要进去了

13:04.830 --> 13:05.830
肯定要进去了

13:11.740 --> 13:12.740
sub

13:12.740 --> 13:13.740
你看

13:13.740 --> 13:14.740
是这样子

13:14.740 --> 13:15.740
我这里输出了这个对象

13:15.740 --> 13:16.740
我们刚才没有输出

13:16.740 --> 13:17.740
没有输出的话

13:17.740 --> 13:18.740
没有输出的话

13:18.740 --> 13:19.740
它这个简单

13:19.740 --> 13:20.740
比较简单的时候

13:20.740 --> 13:21.740
它还能够分析的出来

13:21.740 --> 13:23.740
它能够分析的出来

13:23.740 --> 13:24.740
稍微多一点

13:24.740 --> 13:25.740
它就分析不出来了

13:25.740 --> 13:26.740
那么我们这里

13:26.740 --> 13:27.740
还是把这个加上

13:28.740 --> 13:30.740
我们可能要用到这个对象

13:31.740 --> 13:32.740
可能要用到这个对象

13:32.740 --> 13:33.740
那么这个时候

13:33.740 --> 13:34.740
它是

13:34.740 --> 13:35.740
如果说简单的话

13:35.740 --> 13:36.740
它能够100%确定

13:36.740 --> 13:37.740
你没有用到这个sub

13:37.740 --> 13:38.740
它还能消掉

13:38.740 --> 13:39.740
但是很多情况下

13:39.740 --> 13:40.740
因为我们的代码比较简单

13:40.740 --> 13:41.740
很多情况下

13:41.740 --> 13:42.740
它是无法确定的

13:43.740 --> 13:44.740
那么它不敢

13:44.740 --> 13:45.740
不敢这样子消除

13:45.740 --> 13:47.740
它是不敢这样子消除的

13:47.740 --> 13:48.740
如果说你是一个

13:48.740 --> 13:49.740
整个对象的话

13:49.740 --> 13:50.740
它是不敢消除的

13:51.740 --> 13:52.740
为什么呢

13:52.740 --> 13:53.740
因为它始终担心你

13:53.740 --> 13:55.740
这个对象里边

13:55.740 --> 13:57.740
你使用了一些动态的东西

13:57.740 --> 13:58.740
比方说吧

13:58.740 --> 13:59.740
我们这里的

13:59.740 --> 14:00.740
比方说写这么样的代码

14:00.740 --> 14:01.740
name

14:02.740 --> 14:03.740
mess

14:03.740 --> 14:04.740
the write

14:05.740 --> 14:06.740
我们就模拟

14:06.740 --> 14:08.740
有些东西它无法分析出来了

14:08.740 --> 14:09.740
比方说小于0.5

14:09.740 --> 14:10.740
小于0.5的时候

14:10.740 --> 14:12.740
我们使用add

14:12.740 --> 14:14.740
然后会有使用sub

14:14.740 --> 14:15.740
那比方说

14:15.740 --> 14:16.740
我们把个name放这

14:16.740 --> 14:20.250
你说它知道

14:20.250 --> 14:22.250
它知道那个

14:23.250 --> 14:25.250
我到底要用什么方法

14:25.250 --> 14:26.250
它就完全懵了

14:26.250 --> 14:27.250
它就完全懵了

14:27.250 --> 14:29.250
除非它能够100%确定

14:29.250 --> 14:31.250
它很多时候都不能100%确定

14:31.250 --> 14:32.250
我们刚才看到的现象

14:32.250 --> 14:34.250
比较简单

14:34.250 --> 14:35.250
很多时候代码一多

14:35.250 --> 14:36.250
它根本就无法100%确定

14:36.250 --> 14:37.250
你要不要用到它

14:37.250 --> 14:38.250
所以说

14:38.250 --> 14:39.250
它只能全部打包进去

14:39.250 --> 14:41.250
它无法确定的

14:41.250 --> 14:42.250
所以说

14:42.250 --> 14:43.250
这里

14:43.250 --> 14:44.250
由于介石语言

14:44.250 --> 14:45.250
它的特性是动态的

14:45.250 --> 14:46.250
它经常的属性

14:46.250 --> 14:48.250
你搞不清楚它要用什么

14:48.250 --> 14:49.250
所以说

14:49.250 --> 14:50.250
它为了保证这一点

14:50.250 --> 14:51.250
我们还没有用 for in 循环

14:51.250 --> 14:53.250
搞不清楚都要了干嘛

14:53.250 --> 14:54.250
这个时候

14:54.250 --> 14:56.250
vpec 是要尽量的保证

14:56.250 --> 14:58.250
尽量的保证

15:00.250 --> 15:02.250
就是

15:02.250 --> 15:03.250
把代码

15:03.250 --> 15:05.250
让代码能够正常运行

15:05.250 --> 15:07.250
所以它要尽大成

15:07.250 --> 15:09.250
最大成功的打包

15:09.250 --> 15:10.250
那么随说

15:10.250 --> 15:11.250
我们在编写代码的时候

15:11.250 --> 15:12.250
如果说你为了

15:12.250 --> 15:14.250
更加好的优化

15:14.250 --> 15:15.250
那么我们编写代码

15:15.250 --> 15:16.250
是要受到一定影响的

15:16.250 --> 15:18.250
就说你不能

15:18.250 --> 15:19.250
你不能就是

15:19.250 --> 15:20.250
用刚才那种写法写

15:20.250 --> 15:22.250
也不能用这种写法写

15:22.250 --> 15:23.250
这种写法

15:23.250 --> 15:25.250
就可能不太利于

15:25.250 --> 15:26.250
吹血菌

15:26.250 --> 15:27.250
除非代码比较简单

15:27.250 --> 15:29.250
咱们来看一下

15:29.250 --> 15:30.250
我们写代码的时候

15:30.250 --> 15:31.250
应该满足一个

15:31.250 --> 15:32.250
就是什么样的规范的

15:32.250 --> 15:34.250
就是我们导出的时候

15:34.250 --> 15:36.250
尽量用这种导出

15:36.250 --> 15:37.250
而不用default导出

15:37.250 --> 15:38.250
为什么

15:38.250 --> 15:39.250
用default导出导出

15:39.250 --> 15:40.250
一个整个东西

15:40.250 --> 15:41.250
那一导入的时候

15:41.250 --> 15:42.250
可能只用到

15:42.250 --> 15:43.250
整个对象里面的一部分

15:43.250 --> 15:44.250
但是它由于

15:44.250 --> 15:45.250
没有办法分析出

15:45.250 --> 15:46.250
我到底要用

15:46.250 --> 15:47.250
这个对象哪部分

15:47.250 --> 15:48.250
它可能有的时候

15:48.250 --> 15:49.250
就分析不出来了

15:49.250 --> 15:50.250
所以说导制

15:50.250 --> 15:51.250
它整个去打包了

15:51.250 --> 15:52.250
应该尽量用

15:52.250 --> 15:54.250
import这个导出

15:54.250 --> 15:56.250
懂我这个意思吧

15:56.250 --> 15:57.250
而不使用这个东西导出

15:57.250 --> 15:58.250
是为了避免

15:58.250 --> 15:59.250
导入的时候

15:59.250 --> 16:00.250
用这个东西导入

16:00.250 --> 16:01.250
当然你如果说

16:01.250 --> 16:02.250
用它导出

16:02.250 --> 16:03.250
但是不用它

16:03.250 --> 16:04.250
不用默认的方式导入

16:05.250 --> 16:06.250
什么问题

16:06.250 --> 16:07.250
第二就是关键点

16:07.250 --> 16:08.250
就是导入

16:08.250 --> 16:10.250
导入的时候

16:10.250 --> 16:11.250
我们要使用这种方式

16:11.250 --> 16:12.250
这种方式导入

16:12.250 --> 16:13.250
其实这种方式

16:13.250 --> 16:14.250
都最好不要用

16:14.250 --> 16:15.250
算了

16:15.250 --> 16:16.250
这种方式都最好不要用

16:16.250 --> 16:17.250
那么它的问题

16:17.250 --> 16:18.250
跟这个问题差不多

16:18.250 --> 16:19.250
这种

16:19.250 --> 16:20.250
第二种方式

16:20.250 --> 16:21.250
要稍微好一点

16:21.250 --> 16:22.250
这种方式要稍微好一点

16:22.250 --> 16:23.250
因为这个东西

16:23.250 --> 16:24.250
这个玩意

16:24.250 --> 16:25.250
是一个魔幻发对象

16:25.250 --> 16:26.250
是一个魔幻发对象

16:26.250 --> 16:27.250
未拍可知道

16:27.250 --> 16:28.250
一个新号

16:28.250 --> 16:29.250
而是查查查

16:29.250 --> 16:30.250
那么它知道

16:30.250 --> 16:31.250
你要用到

16:31.250 --> 16:32.250
就是你把里面的

16:32.250 --> 16:33.250
所有的这种东西

16:33.250 --> 16:34.250
导入到过后

16:34.250 --> 16:35.250
它可以观测

16:35.250 --> 16:36.250
因为这个里面的东西

16:36.250 --> 16:37.250
是不可辨的

16:37.250 --> 16:39.250
大家知道这个区别吗

16:39.250 --> 16:40.250
就说如果说

16:40.250 --> 16:41.250
我们用这种

16:41.250 --> 16:42.250
D4式的方式导入

16:42.250 --> 16:43.250
OB介里面

16:43.250 --> 16:44.250
这个东西是可以辨的

16:44.250 --> 16:45.250
是可以辨的

16:45.250 --> 16:47.250
因为它是个普通对象而已

16:47.250 --> 16:48.250
你看OB介

16:48.250 --> 16:50.250
它是一个普普通通的对象

16:50.250 --> 16:51.250
它当然可以改变它的属性

16:51.250 --> 16:52.250
但是如果说

16:52.250 --> 16:53.250
你用这种方式导出

16:53.250 --> 16:54.250
你是不能辨的

16:54.250 --> 16:56.250
你用这种方式导出

16:57.250 --> 16:58.250
OB介

16:58.250 --> 16:59.250
你是不能辨的

17:01.250 --> 17:02.250
我们看一下

17:04.250 --> 17:05.250
OB介.add

17:05.250 --> 17:06.250
方形

17:07.250 --> 17:08.250
你是不能不允许地

17:08.250 --> 17:09.250
不允许地改动的

17:09.250 --> 17:10.250
是不允许地改动的

17:11.250 --> 17:12.250
当然我们现在

17:12.250 --> 17:13.250
就是

17:13.250 --> 17:14.250
如果说打包的话

17:14.250 --> 17:15.250
看不到这个效果

17:15.250 --> 17:16.250
因为打包过后

17:16.250 --> 17:17.250
它就不存在ES6这个东西了

17:17.250 --> 17:18.250
对吧

17:18.250 --> 17:19.250
它就不存在ES6这个东西了

17:19.250 --> 17:21.250
但是在真实的ES6环境里面

17:21.250 --> 17:22.250
是不能辨的

17:22.250 --> 17:23.250
我们用这种方式来吧

17:23.250 --> 17:24.250
我们这种方式

17:24.250 --> 17:25.250
给大家演示一下

17:25.250 --> 17:26.250
在这里写个index

17:26.250 --> 17:27.250
用传统的方式

17:27.250 --> 17:28.250
来给大家演示一下

17:30.250 --> 17:31.250
index

17:31.250 --> 17:32.250
介式

17:33.250 --> 17:34.250
module

17:34.250 --> 17:35.250
好 咱们来看一下吧

17:36.250 --> 17:37.250
this is never server

17:37.250 --> 17:41.290
你看

17:43.290 --> 17:47.200
这里一代

17:47.200 --> 17:49.200
这里要改成这个

17:49.200 --> 17:51.200
改成第二介式

17:51.200 --> 17:52.200
OK

17:52.200 --> 17:53.200
好 成

17:53.200 --> 17:54.200
好 是吧

17:54.200 --> 17:56.200
cannot assign to read only property

17:56.200 --> 17:57.200
add

17:57.200 --> 17:58.200
OB介

17:58.200 --> 17:59.200
所以这个东西不能改

17:59.200 --> 18:00.200
对吧 这个东西不能改的

18:00.200 --> 18:01.200
对

18:01.200 --> 18:02.200
它区别在这

18:02.200 --> 18:03.200
如果说你是

18:03.200 --> 18:04.200
你是用这种方式导出的话

18:04.200 --> 18:05.200
那么它是可以改的

18:05.200 --> 18:06.200
对象里

18:06.200 --> 18:07.200
它是个辅充对象

18:07.200 --> 18:08.200
那么这个玩意

18:08.200 --> 18:09.200
不是个普通对象

18:09.200 --> 18:10.200
这是把所有的

18:10.200 --> 18:11.200
这个普通导出

18:11.200 --> 18:13.200
给你合并成为一个磨块对象

18:13.200 --> 18:14.200
这个磨块对象里面

18:14.200 --> 18:15.200
所有的东西是不能改的

18:15.200 --> 18:17.200
它就说有这么个区别

18:17.200 --> 18:18.200
因此用这种方式来导入

18:18.200 --> 18:20.200
要比用default的方式来导入

18:20.200 --> 18:21.200
要稍微好一点

18:21.200 --> 18:23.200
它还能够帮助它分析一点

18:23.200 --> 18:24.200
但是其实也不是很好

18:24.200 --> 18:26.200
最好的是使用什么呢

18:26.200 --> 18:27.200
最好的

18:27.200 --> 18:29.200
我们把这个稍微改一下

18:29.200 --> 18:32.770
最好的是使用这种方式来导入

18:32.770 --> 18:34.770
这种方式是注意变运

18:34.770 --> 18:36.770
它清晰的分析依赖关系的

18:36.770 --> 18:37.770
非常清晰的

18:37.770 --> 18:39.770
就可以分析出依赖关系

18:40.770 --> 18:41.770
那么

18:41.770 --> 18:42.770
看一下

18:43.770 --> 18:46.770
最好的是使用这种方式来导入

18:46.770 --> 18:47.770
这种方式

18:47.770 --> 18:48.770
对

18:48.770 --> 18:49.770
再重新打开一次

18:49.770 --> 18:54.060
重新打开

18:54.060 --> 18:58.230
下面

18:58.230 --> 19:00.230
最好的方式就是使用这种方式

19:00.230 --> 19:01.230
所以说

19:01.230 --> 19:03.230
我们如果说要让VPAC

19:03.230 --> 19:05.230
就是获得最佳的缺席

19:05.230 --> 19:06.230
那么导出

19:06.230 --> 19:07.230
用这个导入

19:07.230 --> 19:08.230
导入用这个导入

19:08.230 --> 19:09.230
没了意思吧

19:09.230 --> 19:11.230
那么VPAC它就分析

19:11.230 --> 19:12.230
我导入的时候

19:12.230 --> 19:13.230
一旦了这个磨块的

19:13.230 --> 19:14.230
哪些东西呢

19:14.230 --> 19:15.230
它就一个一个记录

19:15.230 --> 19:16.230
一个记录

19:16.230 --> 19:17.230
那么分析其他磨块的时候

19:17.230 --> 19:18.230
也有一次记录

19:18.230 --> 19:20.230
那么把所有的磨块分析完了

19:20.230 --> 19:21.230
过后

19:21.230 --> 19:22.230
是不是就每一个磨块

19:22.230 --> 19:23.230
哪些东西要用到

19:23.230 --> 19:24.230
就特别清楚了

19:24.230 --> 19:25.230
对吧

19:25.230 --> 19:26.230
特别清楚了

19:26.230 --> 19:27.230
那么这个时候

19:27.230 --> 19:28.230
它做了一件事

19:28.230 --> 19:29.230
它就是把

19:29.230 --> 19:30.230
用到了地方了

19:30.230 --> 19:31.230
就不管

19:31.230 --> 19:32.230
没有用到的磨块

19:32.230 --> 19:33.230
它就给你标记一个

19:33.230 --> 19:34.230
戴的扣的

19:34.230 --> 19:36.230
它会给你进行标记

19:36.230 --> 19:37.230
然后

19:37.230 --> 19:39.230
它不会真正的把它移出

19:39.230 --> 19:40.230
它不会真正的移出

19:40.230 --> 19:41.230
它只是做一个标记

19:41.230 --> 19:42.230
用一种注释的形式

19:42.230 --> 19:43.230
做一个标记

19:43.230 --> 19:44.230
标记完了过后

19:44.230 --> 19:46.230
戴码压缩攻击

19:46.230 --> 19:47.230
它会自己处理

19:47.230 --> 19:48.230
比方我们上联合学的Terror

19:48.230 --> 19:50.230
那么做了标记过后

19:50.230 --> 19:51.230
它会自动给你

19:51.230 --> 19:52.230
把这些标记的代码

19:52.230 --> 19:53.230
全部给你移出

19:53.230 --> 19:54.230
所以说

19:54.230 --> 19:55.230
它要真正的发挥

19:55.230 --> 19:56.230
总有还要依赖于那些

19:56.230 --> 19:57.230
戴码压缩攻击

19:57.230 --> 19:58.230
比方说ArchetyphiGS

19:58.230 --> 19:59.230
还有Terror

19:59.230 --> 20:00.230
我们知道

20:00.230 --> 20:01.230
Terror跟ArchetyphiGS

20:01.230 --> 20:02.230
差不多

20:02.230 --> 20:03.230
只不过它支持ES6

20:03.230 --> 20:04.230
没有这些

20:04.230 --> 20:05.230
好

20:05.230 --> 20:06.230
那么这是它的原理

20:06.230 --> 20:07.230
好

20:07.230 --> 20:08.230
接下来我们来看一下

20:08.230 --> 20:09.230
如果说

20:09.230 --> 20:10.230
我们自己的写代码

20:10.230 --> 20:11.230
到时候可以按照这个规范

20:12.230 --> 20:13.230
那么自己的写代码

20:13.230 --> 20:14.230
按照这个规范来写

20:14.230 --> 20:15.230
就不会出现这么问题

20:15.230 --> 20:16.230
但是问题就出现在这

20:16.230 --> 20:18.230
第三方库

20:18.230 --> 20:20.230
因为有些第三方库

20:20.230 --> 20:22.230
用的是common介石的方式

20:22.230 --> 20:23.230
来导出

20:23.230 --> 20:25.230
它不是用漏的介石

20:25.230 --> 20:27.230
不是用ES6

20:27.230 --> 20:29.230
那你又想了

20:29.230 --> 20:30.230
这些第三方库

20:30.230 --> 20:32.230
不是吃饱了撑子吗

20:32.230 --> 20:34.230
它干嘛用common介石呢

20:34.230 --> 20:37.230
你觉得它干嘛用common介石

20:37.230 --> 20:38.230
它其实

20:38.230 --> 20:39.230
所有的魔幻

20:39.230 --> 20:41.230
它必须要支持

20:41.230 --> 20:43.230
那么最稳健的

20:43.230 --> 20:44.230
就是common介石

20:44.230 --> 20:45.230
因为你在

20:45.230 --> 20:46.230
有些库呢

20:46.230 --> 20:48.230
它要在漏的环境里边运行的

20:48.230 --> 20:50.230
common介石是最好检测的

20:50.230 --> 20:51.230
你知道吗

20:51.230 --> 20:52.230
我就判断一下

20:52.230 --> 20:54.230
margeu存不存在就完事了

20:54.230 --> 20:55.230
margeu.exports存不存在

20:55.230 --> 20:57.230
存在的话就导出

20:57.230 --> 20:58.230
最好检测的

20:58.230 --> 20:59.230
而且呢

20:59.230 --> 21:01.230
它可以适用于漏的环境

21:01.230 --> 21:03.230
而且common介石是动态的

21:03.230 --> 21:04.230
它可以在码里边判断

21:04.230 --> 21:06.230
判断有一个common介石

21:06.230 --> 21:07.230
是common介石环境

21:07.230 --> 21:08.230
我在这种common介石导出

21:08.230 --> 21:10.230
那么它是用动态的环境

21:10.230 --> 21:11.230
它不像es6

21:11.230 --> 21:12.230
如果说到一个

21:12.230 --> 21:13.230
不支持es6的环境

21:13.230 --> 21:14.230
它一旦使用es6的代码

21:14.230 --> 21:15.230
它就要爆出

21:15.230 --> 21:16.230
因为它是于法

21:16.230 --> 21:18.230
es6的导出语句是于法

21:18.230 --> 21:19.230
因为这个

21:19.230 --> 21:21.230
不能识别这个于法的地方

21:21.230 --> 21:22.230
马上就爆出了

21:22.230 --> 21:23.230
整个的于法就错误了

21:23.230 --> 21:24.230
所以common介石

21:24.230 --> 21:25.230
它不是于法

21:25.230 --> 21:26.230
它是一个含说API

21:26.230 --> 21:28.230
所以它common介石导出是

21:28.230 --> 21:29.230
最能够兼容各种环境的

21:29.230 --> 21:30.230
漏的环境啊

21:30.230 --> 21:32.230
流浪期环境都能兼容

21:32.230 --> 21:33.230
因为流浪期环境

21:33.230 --> 21:34.230
经过一检测

21:34.230 --> 21:35.230
不是common介石ok

21:35.230 --> 21:36.230
它用别的方式

21:36.230 --> 21:37.230
比如说amd,cmd,umd

21:37.230 --> 21:38.230
就是提供一个全局辨量

21:38.230 --> 21:39.230
它都可以

21:41.230 --> 21:43.230
es6是不太兼容的

21:43.230 --> 21:45.230
对环境来说不太兼容的

21:45.230 --> 21:46.230
因为它不能假设

21:46.230 --> 21:47.230
你一定要用vpeg

21:47.230 --> 21:48.230
它不能去做这个假设的

21:48.230 --> 21:49.230
所以它没办法

21:49.230 --> 21:50.230
它用common介石导出

21:50.230 --> 21:52.230
很多模糊的会这样子

21:53.230 --> 21:54.230
那么

21:54.230 --> 21:55.230
这个时候

21:55.230 --> 21:57.230
它又没有提供那种普通的

21:57.230 --> 21:59.230
或者是它用了es6导出

21:59.230 --> 22:01.230
但是它没有提供普通的es6导出

22:01.230 --> 22:03.230
它是用了这种方式导出

22:04.230 --> 22:06.230
那就是一些很早期的过程

22:06.230 --> 22:07.230
早期的过程

22:07.230 --> 22:08.230
它根本就没有管缺确件

22:08.230 --> 22:09.230
也早期的过程

22:09.230 --> 22:10.230
那么对这些过程

22:10.230 --> 22:12.230
缺确件是很难发挥作用的

22:12.230 --> 22:13.230
对common介石

22:13.230 --> 22:14.230
是完全没法发挥作用

22:15.230 --> 22:16.230
对es6

22:16.230 --> 22:18.230
如果是用普通导出

22:18.230 --> 22:19.230
倒是能够发挥

22:19.230 --> 22:20.230
那么一点点作用

22:20.230 --> 22:22.230
它很容易检测不出来

22:22.230 --> 22:24.230
比方说nodec

22:24.230 --> 22:25.230
我们就看nodec

22:27.230 --> 22:29.230
nodec就是一个严重的问题

22:29.230 --> 22:31.230
好,咱们来安装一下

22:31.230 --> 22:33.230
安装nodec

22:34.230 --> 22:35.230
就用这个吧

22:36.230 --> 22:37.230
nodec

22:38.230 --> 22:39.230
安装

22:40.230 --> 22:41.230
咱们看看有意思的

22:42.230 --> 22:44.230
就在index的介石里边

22:45.230 --> 22:47.230
咱们去导入一个nodec

22:48.230 --> 22:49.230
导入什么呢

22:50.230 --> 22:51.230
导入

22:53.230 --> 22:54.230
nodec

22:54.230 --> 22:56.230
我们还是用这个相同的方式来导入

22:56.230 --> 22:58.230
比方说它里边有一些方法

22:59.230 --> 23:00.230
比方说这个chunk

23:01.230 --> 23:02.230
chunk方法

23:02.230 --> 23:04.230
我们输出一下

23:04.230 --> 23:05.230
chunk方法

23:05.230 --> 23:06.230
我们就用这个方法

23:06.230 --> 23:07.230
第一个传一个数组

23:07.230 --> 23:08.230
传一个数组

23:09.230 --> 23:10.230
传个方法干嘛的

23:10.230 --> 23:11.230
以后一看就知道了

23:11.230 --> 23:12.230
第二个方式

23:12.230 --> 23:14.230
传一个数字

23:16.230 --> 23:17.230
我们用到nodec

23:17.230 --> 23:19.230
而且它只用了它里边一个方法

23:19.230 --> 23:20.230
那我们来打包一下

23:20.230 --> 23:21.230
你看一下

23:21.230 --> 23:22.230
npm

23:22.230 --> 23:23.230
rombuild

23:29.210 --> 23:30.210
72kb

23:31.210 --> 23:32.210
我就用了它一个chunk方法

23:32.210 --> 23:34.210
就用它一个API

23:34.210 --> 23:35.210
我打错了

23:35.210 --> 23:36.210
打爆出来72kb

23:36.210 --> 23:37.210
大家运行看一下吧

23:37.210 --> 23:38.210
顺便看一下

23:39.210 --> 23:40.210
所以没两个一组

23:40.210 --> 23:41.210
没两个一组

23:41.210 --> 23:43.210
把一个数组再进一步进一分组

23:43.210 --> 23:44.210
后面没有两个了

23:44.210 --> 23:45.210
就没办法了

23:45.210 --> 23:46.210
就这么个意思

23:47.210 --> 23:48.210
那么你看一下

23:48.210 --> 23:49.210
这里边肯定有chunk

23:50.210 --> 23:52.210
还肯定有那个其他的API

23:52.210 --> 23:53.210
easy array

23:54.210 --> 23:55.210
有很多很多的API

23:55.210 --> 23:56.210
全部在里边

23:56.210 --> 23:57.210
全部在里边

23:57.210 --> 23:58.210
有必要吗

23:58.210 --> 23:59.210
没必要

23:59.210 --> 24:00.210
但是它没办法

24:00.210 --> 24:01.210
因为nodec

24:01.210 --> 24:02.210
它这个模块

24:02.210 --> 24:04.210
它就是通过mcmdx导出的

24:05.210 --> 24:06.210
那怎么办呢

24:06.210 --> 24:07.210
变成这样的模块

24:08.210 --> 24:09.210
其实

24:10.210 --> 24:12.210
好的事情在于

24:12.210 --> 24:13.210
很多时候

24:13.210 --> 24:15.210
这种比较流行的

24:15.210 --> 24:16.210
一般来说

24:16.210 --> 24:17.210
流行的就是使用的

24:17.210 --> 24:19.210
越多的那种裤

24:19.210 --> 24:20.210
它一般比较流行

24:20.210 --> 24:21.210
比较流行

24:21.210 --> 24:22.210
它为什么比较流行

24:22.210 --> 24:23.210
因为它维护的速度快

24:23.210 --> 24:24.210
一有问题

24:24.210 --> 24:25.210
该提出

24:25.210 --> 24:26.210
它几个小时

24:26.210 --> 24:27.210
可能一两天就给你解决了

24:27.210 --> 24:29.210
大家平时用第三方裤的时候

24:29.210 --> 24:31.210
特别是以后在公司里边

24:31.210 --> 24:32.210
你们以后的这个地

24:33.210 --> 24:34.210
可能开发

24:34.210 --> 24:36.210
就是在公司里边的位置上升了

24:36.210 --> 24:37.210
之后

24:37.210 --> 24:39.210
可能要做一些技术选择的时候

24:39.210 --> 24:40.210
大家一定要注意一点

24:40.210 --> 24:41.210
不能忽视一点

24:41.210 --> 24:43.210
你不光看这个技术有多么理由逼

24:43.210 --> 24:44.210
多么好

24:44.210 --> 24:45.210
它一定有问题

24:45.210 --> 24:46.210
没有任何一个技术是没问题的

24:46.210 --> 24:47.210
一定有问题的

24:47.210 --> 24:48.210
那么如果说

24:48.210 --> 24:49.210
这个你看一下

24:49.210 --> 24:50.210
大家get the hop

24:50.210 --> 24:51.210
上面去看一下

24:51.210 --> 24:53.210
它更新的屏幕频繁

24:53.210 --> 24:55.210
它解决问题的速度快不快

24:55.210 --> 24:56.210
如果说

24:56.210 --> 24:57.210
这个裤

24:57.210 --> 24:59.210
它一开始发现不了问题

24:59.210 --> 25:00.210
它如果长期

25:00.210 --> 25:01.210
不更新

25:01.210 --> 25:02.210
长期

25:02.210 --> 25:03.210
不解决问题

25:03.210 --> 25:05.210
那么这个裤用起来是非常危险的

25:05.210 --> 25:06.210
你到时候用的

25:06.210 --> 25:07.210
除了一些严重的问题

25:07.210 --> 25:08.210
解不就不了了

25:08.210 --> 25:09.210
麻烦了

25:09.210 --> 25:10.210
它不解决

25:10.210 --> 25:11.210
完全看不到

25:11.210 --> 25:12.210
或者是完全不解决

25:12.210 --> 25:14.210
说大家平时用一些

25:14.210 --> 25:15.210
看上去不错的第三方裤

25:15.210 --> 25:17.210
一定要去关注它这一点

25:17.210 --> 25:18.210
有些地方

25:18.210 --> 25:19.210
说我们像劉拉奇这种裤

25:19.210 --> 25:21.210
它就是更新非常频繁的

25:21.210 --> 25:23.210
像这些裤

25:23.210 --> 25:24.210
因此

25:24.210 --> 25:25.210
我们像一些流行的裤

25:25.210 --> 25:27.210
它维护的比较积极

25:27.210 --> 25:28.210
像这个劉拉奇这个裤

25:28.210 --> 25:29.210
它没有

25:29.210 --> 25:30.210
虽然说

25:30.210 --> 25:31.210
它是它同样的

25:31.210 --> 25:32.210
为了解决这个问题

25:32.210 --> 25:33.210
它早就出来了一个

25:33.210 --> 25:34.210
ES6的版本

25:34.210 --> 25:35.210
劉拉奇ES

25:35.210 --> 25:37.210
说你用这个版本就完事了

25:37.210 --> 25:39.210
这么看一下

25:39.210 --> 25:40.210
安装一个

25:40.210 --> 25:41.210
不安装劉拉奇

25:41.210 --> 25:43.210
安装劉拉奇ES

25:44.210 --> 25:45.210
这些流行的裤

25:45.210 --> 25:46.210
有人维护的裤

25:46.210 --> 25:48.210
说是比较舒服

25:48.210 --> 25:50.210
它的问题可以马上得到解决

25:50.210 --> 25:51.210
就是比方说

25:51.210 --> 25:53.210
就你自己在公司里面开发

25:53.210 --> 25:54.210
开发

25:54.210 --> 25:55.210
出来出现的问题

25:55.210 --> 25:56.210
你马上给它提

25:56.210 --> 25:57.210
只要有一个提到问题

25:57.210 --> 25:58.210
就是确决实实存在的

25:58.210 --> 25:59.210
它一减延存在

25:59.210 --> 26:00.210
很快就可以解决了

26:00.210 --> 26:02.210
打个補定

26:02.210 --> 26:03.210
当然这个东西

26:03.210 --> 26:04.210
不是補定了

26:04.210 --> 26:05.210
是完全出了一个另外一个裤

26:05.210 --> 26:06.210
其实那个裤很简单

26:06.210 --> 26:07.210
还就是把

26:07.210 --> 26:08.210
换了一种方式导出就完了

26:08.210 --> 26:09.210
代码还是那些代码

26:09.210 --> 26:10.210
换了一种方式导出

26:10.210 --> 26:11.210
没看

26:11.210 --> 26:12.210
我把它改成ES

26:12.210 --> 26:13.210
你现在再感受一下

26:13.210 --> 26:14.210
刚才是72KB

26:14.210 --> 26:15.210
对吧

26:15.210 --> 26:16.210
NPM

26:16.210 --> 26:17.210
ROUND BUDE

26:19.210 --> 26:22.990
3KB

26:23.990 --> 26:24.990
所以一下子代码

26:24.990 --> 26:25.990
体积就小了非常非常多

26:25.990 --> 26:26.990
对吧

26:26.990 --> 26:27.990
就小了非常多

26:28.990 --> 26:29.990
有些公共API

26:29.990 --> 26:30.990
还要导出进展

26:30.990 --> 26:31.990
其实你看一下

26:31.990 --> 26:33.990
其实没多少东西了对吧

26:33.990 --> 26:35.990
这就是使用那个有锤斜选

26:35.990 --> 26:38.990
你看锤斜的力量是非常强大

26:39.990 --> 26:41.990
它会压极大的压数

26:41.990 --> 26:42.990
极大的压数

26:42.990 --> 26:43.990
好

26:43.990 --> 26:44.990
那么我们来看一下

26:44.990 --> 26:45.990
下一个问题

26:45.990 --> 26:46.990
就作用余分析

26:46.990 --> 26:48.990
这个问题呢

26:48.990 --> 26:49.990
WiPack2

26:49.990 --> 26:50.990
确实

26:50.990 --> 26:52.990
WiPack目前都还没有

26:52.990 --> 26:53.990
解决的特别好

26:53.990 --> 26:54.990
它有部分解决

26:54.990 --> 26:55.990
部分解决了

26:55.990 --> 26:57.990
没有解决的特别好

26:57.990 --> 26:59.990
所以还是遇到问题

26:59.990 --> 27:00.990
就缺先想

27:00.990 --> 27:02.990
它没有一个完善的作用余分析

27:02.990 --> 27:04.990
就可能会出现这么一种现象

27:04.990 --> 27:06.990
在一些Deadcode的大函数里边

27:06.990 --> 27:08.990
它的遗难仍然会被视为遗难

27:08.990 --> 27:09.990
什么意思呢

27:09.990 --> 27:10.990
我给大家看一下

27:10.990 --> 27:11.990
这个情况

27:11.990 --> 27:14.990
就是我们这里引用的是MimeMesh

27:14.990 --> 27:16.990
引用的是MimeMesh

27:16.990 --> 27:18.990
MimeMesh里边我们只用到ADD

27:18.990 --> 27:23.460
我们只用到它的ADD

27:23.460 --> 27:25.460
然后MimeMesh里边

27:25.460 --> 27:27.460
它用到了楼代型

27:27.460 --> 27:29.460
这种情况是很常见的对吧

27:29.460 --> 27:30.460
另一个遗难并不是

27:30.460 --> 27:31.460
要用到它

27:31.460 --> 27:33.460
另一个一代一代用到它

27:33.460 --> 27:34.460
用到它里边什么呢

27:34.460 --> 27:35.460
Trunk

27:35.460 --> 27:36.460
好

27:36.460 --> 27:38.460
我们到自己导出一个方式

27:38.460 --> 27:40.460
MineTrunk

27:40.460 --> 27:41.460
MineTrunk

27:41.460 --> 27:44.460
ArrayNumber

27:44.460 --> 27:47.460
其实就是在雕用一下MineTrunk

27:47.460 --> 27:50.460
就是雕用一下Trunk

27:50.460 --> 27:52.460
空装一下

27:52.460 --> 27:54.460
ArrayNumber

27:54.460 --> 27:55.460
好

27:55.460 --> 27:56.460
你看

27:56.460 --> 27:57.460
这个玩意

27:57.460 --> 27:58.460
其实它分析出来的话

27:58.460 --> 28:00.460
这个玩意应该是dead code对吧

28:00.460 --> 28:03.460
是不是应该是始作用于时代

28:03.460 --> 28:04.460
对不对

28:04.460 --> 28:05.460
我们只用到ADD

28:05.460 --> 28:06.460
这个玩意是不是不会

28:06.460 --> 28:08.460
经常到打包结果

28:08.460 --> 28:11.460
但是这个里边由于用到了Trunk

28:11.460 --> 28:13.460
由于用到了Trunk

28:13.460 --> 28:15.460
那么WebHack4

28:15.460 --> 28:17.460
它没有那么智能

28:17.460 --> 28:19.460
它简单长期下可能会分析得出来

28:19.460 --> 28:21.460
如果说稍微

28:21.460 --> 28:22.460
捣个弯

28:22.460 --> 28:23.460
它可能就蒙了

28:23.460 --> 28:24.460
像这种情况

28:24.460 --> 28:26.460
它仍然认为这个文件

28:26.460 --> 28:27.460
它依赖Trunk

28:27.460 --> 28:29.460
其实我们整个工程是不依赖

28:29.460 --> 28:30.460
不依赖什么了

28:30.460 --> 28:31.460
不依赖楼弹器的

28:31.460 --> 28:32.460
你看英这个设计里边

28:32.460 --> 28:33.460
只用到ADD

28:33.460 --> 28:34.460
ADD里边没有用到楼弹器

28:34.460 --> 28:35.460
所以整个工程实际上是没有

28:35.460 --> 28:36.460
依赖楼弹器的

28:36.460 --> 28:37.460
但是

28:37.460 --> 28:39.460
我们来看一下

28:39.460 --> 28:41.460
npmraw

28:41.460 --> 28:45.110
build

28:45.110 --> 28:46.110
你看

28:46.110 --> 28:48.110
1.48kb

28:48.110 --> 28:49.110
那你看

28:49.110 --> 28:50.110
我们如果说

28:50.110 --> 28:51.110
在这边

28:51.110 --> 28:53.110
没有这个东西

28:53.110 --> 28:54.110
没有这个东西

28:54.110 --> 28:55.110
你看一下

28:55.110 --> 28:58.830
它那个大小是多少

28:58.830 --> 28:59.830
是不是

28:59.830 --> 29:01.830
刚刚好1kb

29:01.830 --> 29:02.830
1024还没到

29:02.830 --> 29:03.830
刚刚好1kb

29:03.830 --> 29:04.830
那么刚才那个是

29:04.830 --> 29:06.830
1.48kb

29:06.830 --> 29:07.830
这说明什么呢

29:07.830 --> 29:08.830
说明了

29:08.830 --> 29:10.830
说明了楼弹器的代码

29:10.830 --> 29:11.830
还是这样子的话

29:11.830 --> 29:12.830
楼弹器的代码

29:12.830 --> 29:13.830
还是有一部分进入到了

29:13.830 --> 29:15.830
我们的追踪打包结果

29:15.830 --> 29:16.830
楼弹器的还算温柔

29:16.830 --> 29:17.830
那么其他的裤

29:17.830 --> 29:18.830
我们就说不准有多少了

29:18.830 --> 29:19.830
我们来看一下吧

29:19.830 --> 29:20.830
虽然说

29:20.830 --> 29:21.830
我们那个函数

29:21.830 --> 29:22.830
卖Trunk

29:22.830 --> 29:23.830
已经没了

29:23.830 --> 29:24.830
但是楼弹器里边

29:24.830 --> 29:25.830
有些代码

29:25.830 --> 29:26.830
进来了

29:26.830 --> 29:27.830
有些代码肯定是楼弹器的

29:27.830 --> 29:28.830
你看看

29:28.830 --> 29:29.830
看一下

29:29.830 --> 29:30.830
哪个代码

29:30.830 --> 29:31.830
楼弹器的

29:31.830 --> 29:32.830
这个东西

29:32.830 --> 29:33.830
Prototype

29:33.830 --> 29:34.830
再得到Prototype

29:34.830 --> 29:35.830
那么像这种类似的代码

29:35.830 --> 29:37.830
它都属于是楼弹器的代码

29:37.830 --> 29:38.830
它还是有一部分进来了

29:38.830 --> 29:40.830
还是有一部分进来了

29:40.830 --> 29:41.830
这个就是因为

29:41.830 --> 29:42.830
它缺少作用率分析

29:42.830 --> 29:43.830
在楼弹器的内部

29:43.830 --> 29:45.830
它到底做了什么事情

29:45.830 --> 29:46.830
它没有

29:46.830 --> 29:47.830
那么楼弹器的内部

29:47.830 --> 29:48.830
它那些代码

29:48.830 --> 29:49.830
到底要不要进来

29:49.830 --> 29:52.830
它没有再进一步进行分析

29:52.830 --> 29:53.830
再进一步进行分析

29:53.830 --> 29:54.830
没有了

29:54.830 --> 29:55.830
那么这个时候

29:55.830 --> 29:56.830
我们可以利用

29:56.830 --> 29:58.830
有一个库

29:58.830 --> 30:00.830
叫做Waypack Deep Sculpt Plucking

30:00.830 --> 30:01.830
这个库

30:01.830 --> 30:02.830
但是这个库

30:02.830 --> 30:03.830
我说一下

30:03.830 --> 30:04.830
这个库是一个个人开发的库

30:04.830 --> 30:06.830
它的维护的

30:06.830 --> 30:07.830
速度

30:07.830 --> 30:08.830
维护的效率

30:08.830 --> 30:09.830
没有那么高

30:09.830 --> 30:10.830
它可能

30:10.830 --> 30:12.830
几个月维护一次吧

30:12.830 --> 30:13.830
反正我看

30:13.830 --> 30:14.830
刚才

30:14.830 --> 30:15.830
上课之前

30:15.830 --> 30:16.830
我看了一下

30:16.830 --> 30:17.830
这个库

30:17.830 --> 30:18.830
它是有7个月前

30:18.830 --> 30:19.830
好像维护了一次

30:19.830 --> 30:20.830
这个库

30:20.830 --> 30:21.830
可以解决这个问题

30:21.830 --> 30:22.830
但是它里边

30:22.830 --> 30:23.830
有一些小的bug

30:23.830 --> 30:24.830
有些小的bug

30:24.830 --> 30:25.830
不过说

30:25.830 --> 30:26.830
用这个库

30:26.830 --> 30:27.830
大家还是要慎重一点

30:27.830 --> 30:28.830
我们来看一下

30:28.830 --> 30:29.830
那么其实它这个东西

30:29.830 --> 30:30.830
影响大不大呢

30:30.830 --> 30:31.830
其实影响也没有那么大

30:31.830 --> 30:32.830
有一部分

30:32.830 --> 30:33.830
小部分代码进来了

30:33.830 --> 30:34.830
但是

30:34.830 --> 30:35.830
这就是

30:35.830 --> 30:36.830
这就是吹鞋琴

30:36.830 --> 30:37.830
我说的

30:37.830 --> 30:39.830
还需要很大的玩扇

30:39.830 --> 30:41.830
也就是我们优化的章节里边

30:41.830 --> 30:42.830
如果说

30:42.830 --> 30:44.830
最需要玩扇的

30:44.830 --> 30:45.830
就是这个吹鞋琴

30:45.830 --> 30:47.830
还需要进一步玩扇

30:47.830 --> 30:49.830
咱们来安装一下这个库

30:49.830 --> 30:51.830
按钢地

30:51.830 --> 30:57.800
站过来

30:57.800 --> 30:59.800
然后我们在Waypack Deep

30:59.800 --> 31:00.800
plugin的用法

31:00.800 --> 31:01.800
大家都知道

31:01.800 --> 31:02.800
就这么个用法

31:02.800 --> 31:04.800
我们就用

31:04.800 --> 31:05.800
该取个名字吧

31:05.800 --> 31:06.800
简单的名字

31:06.800 --> 31:07.800
deep scope

31:07.800 --> 31:09.800
深度作用率分析

31:09.800 --> 31:10.800
它会做什么呢

31:10.800 --> 31:11.800
就Waypack

31:11.800 --> 31:12.800
它没有对这种

31:12.800 --> 31:14.800
含述内部的依赖

31:14.800 --> 31:16.800
内部的就是怎么去用的

31:16.800 --> 31:18.800
用到哪些东西

31:18.800 --> 31:19.800
那么这些含述内部

31:19.800 --> 31:20.800
又用到了哪些东西

31:20.800 --> 31:21.800
它没有去做这种分析

31:21.800 --> 31:23.800
没有做这种分析

31:23.800 --> 31:24.800
这种太深度的分析

31:24.800 --> 31:25.800
它没有去做

31:25.800 --> 31:26.800
那么这里

31:26.800 --> 31:28.800
我们把它导入进来

31:28.800 --> 31:31.800
叫做Waypack DeepScope Plugin

31:31.800 --> 31:33.800
Pugin里面

31:33.800 --> 31:34.800
我们夹住进来

31:34.800 --> 31:35.800
New一个

31:35.800 --> 31:36.800
OK

31:36.800 --> 31:37.800
我们再看一下

31:37.800 --> 31:41.900
RoundBuild

31:45.280 --> 31:46.280
什么了

31:46.280 --> 31:49.230
这是什么

31:49.230 --> 31:51.230
Deep Snot Structure

31:51.230 --> 31:52.230
这里

31:52.230 --> 31:54.230
它是用es6的方式导出的

31:54.230 --> 31:55.230
我们这里要

31:55.230 --> 31:56.230
loaded.es

31:56.230 --> 31:58.230
要用加一个default

31:58.230 --> 32:03.230
好不好

32:03.230 --> 32:04.230
你看

32:04.230 --> 32:06.230
是不还原到最初的状态了

32:06.230 --> 32:07.230
对吧

32:07.230 --> 32:08.230
大小的代码一个都没有了

32:08.230 --> 32:10.230
一个都没有了

32:10.230 --> 32:11.230
原来这意思

32:11.230 --> 32:12.230
这就是

32:12.230 --> 32:14.230
加入这个空可以有助于我们

32:14.230 --> 32:16.230
进行深度的分析

32:16.230 --> 32:18.230
这个空有一些小的bug

32:18.230 --> 32:19.230
小的bug也不太会影响啥

32:19.230 --> 32:21.230
至少要比那个好一点

32:21.230 --> 32:23.230
要比Waypack本身的

32:23.230 --> 32:25.230
Trade Shaking的家族过河要好一点

32:25.230 --> 32:26.230
当然它肯定会增加

32:26.230 --> 32:27.230
构建速度

32:27.230 --> 32:29.230
构建速度肯定会降低

32:29.230 --> 32:30.230
这个是好

32:30.230 --> 32:31.230
没办法

32:31.230 --> 32:32.230
它要深度分析

32:32.230 --> 32:33.230
它要分析抽象与发出

32:33.230 --> 32:34.230
要到函数作用

32:34.230 --> 32:35.230
域里面去分析去了

32:35.230 --> 32:36.230
这是关于这一块

32:36.230 --> 32:37.230
这一块

32:37.230 --> 32:39.230
这个问题怎么去解决

32:39.230 --> 32:40.230
第二个问题是

32:40.230 --> 32:42.230
关于副作用的问题

32:42.230 --> 32:43.230
就是缺斜性的时候

32:43.230 --> 32:44.230
有一个原则

32:44.230 --> 32:46.230
它一定要保证代码正确运行

32:46.230 --> 32:48.230
那么在满足感染症的居手上

32:48.230 --> 32:50.230
再来决定如何来缺斜性

32:50.230 --> 32:51.230
如何来删代

32:51.230 --> 32:52.230
所以说

32:52.230 --> 32:53.230
如果说Waypack

32:53.230 --> 32:54.230
它无法确定某个模块

32:54.230 --> 32:56.230
是否有副作用的时候

32:56.230 --> 32:59.230
它往往会视其为有副作用

32:59.230 --> 33:00.230
比方说

33:00.230 --> 33:01.230
我们有些情况

33:01.230 --> 33:02.230
并不是我们想要的

33:02.230 --> 33:03.230
你看

33:03.230 --> 33:04.230
比方说我们这里

33:04.230 --> 33:05.230
有一个解释

33:10.230 --> 33:11.230
这个解释

33:11.230 --> 33:12.230
我们就做了这么一件事

33:12.230 --> 33:13.230
这个解释

33:13.230 --> 33:14.230
都没有导出

33:14.230 --> 33:16.230
就这么一句话

33:16.230 --> 33:17.230
就这么一句话

33:17.230 --> 33:20.230
然后我们输出N

33:20.230 --> 33:21.230
或者不输出

33:21.230 --> 33:22.230
不输出N都行

33:22.230 --> 33:24.230
然后我们在index里面

33:24.230 --> 33:25.230
我们去导入它

33:25.230 --> 33:26.230
Import

33:26.230 --> 33:27.230
我们用这种方式导入

33:29.230 --> 33:30.230
这种方式导入

33:30.230 --> 33:31.230
是不是我们对它

33:31.230 --> 33:32.230
没有任何依赖

33:32.230 --> 33:33.230
不用它任何导出的东西

33:34.230 --> 33:35.230
没有任何依赖

33:35.230 --> 33:36.230
比方说我们像什么地方

33:36.230 --> 33:37.230
像央时

33:37.230 --> 33:38.230
是不是就这样导入的

33:39.230 --> 33:40.230
我们依赖它

33:40.230 --> 33:42.230
但是我不使用它里面的任何导出

33:42.230 --> 33:44.230
那么这个时候

33:44.230 --> 33:45.230
Waypack会怎么样

33:45.230 --> 33:47.230
它要不要把这个模块代码

33:47.230 --> 33:48.230
夹入到最终代码

33:49.230 --> 33:51.230
它要有个很大的问号了

33:51.230 --> 33:52.230
如果说

33:52.230 --> 33:53.230
我把这个模块代码

33:53.230 --> 33:55.230
不进入打包结果

33:55.230 --> 33:56.230
那么就意味着

33:56.230 --> 33:58.230
这些代码就不会运行

33:58.230 --> 33:59.230
那么这些代码

33:59.230 --> 34:00.230
不会运行的话

34:00.230 --> 34:02.230
因为它不到打包结果

34:02.230 --> 34:03.230
这里依赖它肯定要运行的

34:03.230 --> 34:04.230
对吧

34:04.230 --> 34:05.230
我们要知道

34:05.230 --> 34:06.230
这个代码

34:06.230 --> 34:07.230
会导致这句话运行的

34:07.230 --> 34:08.230
那么不到打包结果里边

34:08.230 --> 34:09.230
它这个东西是不是不会运行

34:09.230 --> 34:11.230
那么它就必须要知道

34:11.230 --> 34:12.230
这个东西有没有副作用

34:13.230 --> 34:14.230
什么叫副作用呢

34:14.230 --> 34:15.230
我们之前讲过

34:15.230 --> 34:16.230
就说你这个代码运行的过

34:16.230 --> 34:18.230
会不会对外部产生影响

34:18.230 --> 34:20.230
对这个模块的外部产生影响

34:20.230 --> 34:21.230
它要知道

34:21.230 --> 34:22.230
比方说你这里发生了

34:22.230 --> 34:23.230
阿迦克斯请求

34:23.230 --> 34:24.230
它不敢去

34:24.230 --> 34:26.230
你去那个过去请求没了

34:26.230 --> 34:27.230
懂这个意思吧

34:27.230 --> 34:28.230
或者是这里的

34:28.230 --> 34:30.230
对一些其他的模块外部

34:31.230 --> 34:33.230
那么这个时候不敢去

34:33.230 --> 34:34.230
它实在不敢

34:34.230 --> 34:36.230
那么这个时候怎么办呢

34:36.230 --> 34:37.230
它就必须要知道

34:37.230 --> 34:38.230
有没有副作用

34:38.230 --> 34:39.230
如果说没有副作用

34:39.230 --> 34:40.230
是存的代码

34:40.230 --> 34:41.230
不对外部造成任何影响

34:41.230 --> 34:42.230
那么一个代码运行的

34:42.230 --> 34:43.230
跟没运行是一样的

34:43.230 --> 34:44.230
那它就可以

34:44.230 --> 34:45.230
它就可以无所谓

34:45.230 --> 34:46.230
可以

34:46.230 --> 34:47.230
就是这个代码

34:47.230 --> 34:49.230
它就可以去掉

34:49.230 --> 34:51.230
但是如果说有副作用的话

34:51.230 --> 34:52.230
那么它就不能去掉

34:52.230 --> 34:53.230
因此呢

34:53.230 --> 34:55.230
它就要分析它的副作用

34:55.230 --> 34:56.230
它一分析

34:56.230 --> 34:57.230
它分析不出来

34:57.230 --> 34:58.230
它可以简单的分析

34:58.230 --> 35:00.230
但它一旦分析不出来

35:00.230 --> 35:01.230
它就蒙了

35:01.230 --> 35:02.230
蒙了过后它怎么办

35:02.230 --> 35:03.230
它就把它当成有副作用

35:03.230 --> 35:04.230
它不敢去

35:04.230 --> 35:05.230
它一定要保证代码运行

35:05.230 --> 35:06.230
它怕代码出问题

35:06.230 --> 35:08.230
所以说你看一下这个

35:08.230 --> 35:09.230
Mass.retter

35:09.230 --> 35:11.230
我们这里加进去

35:11.230 --> 35:14.890
Build

35:14.890 --> 35:15.890
加进去

35:15.890 --> 35:16.890
你看多了一点点

35:16.890 --> 35:18.890
你看我们看一下

35:18.890 --> 35:19.890
Mass.retter

35:19.890 --> 35:20.890
是不是出现了

35:20.890 --> 35:21.890
它把这个N去掉了

35:21.890 --> 35:22.890
因为它知道N是没用的

35:22.890 --> 35:24.890
因为这个压缩工具它可以去掉

35:24.890 --> 35:26.890
因为它是两个东西一起来作用

35:26.890 --> 35:27.890
压缩工具它发现

35:27.890 --> 35:28.890
这个N确实是没用的

35:28.890 --> 35:29.890
跟我们之前是不是一样的问题

35:29.890 --> 35:31.890
发现这个有副作用的代码

35:31.890 --> 35:32.890
这个是副作用

35:32.890 --> 35:33.890
它不知道

35:33.890 --> 35:34.890
跟我们之前上级科是一样的问题

35:34.890 --> 35:36.890
但它这个东西得保留

35:36.890 --> 35:37.890
它没坏代码不敢去掉

35:37.890 --> 35:38.890
不敢去掉

35:38.890 --> 35:40.890
那么上级科的时候

35:40.890 --> 35:41.890
我们怎么解决的

35:41.890 --> 35:42.890
是不是在这里加一个注释

35:42.890 --> 35:43.890
对吧

35:43.890 --> 35:45.890
仍然可以在这里加个注释

35:45.890 --> 35:47.890
那么在区区区里面

35:47.890 --> 35:48.890
还有一种方式

35:48.890 --> 35:49.890
还有什么方式呢

35:49.890 --> 35:52.890
就是在Padding.json里边

35:52.890 --> 35:54.890
在这里面配置一下

35:54.890 --> 35:56.890
配置一下

35:56.890 --> 35:58.890
有一个配置叫side而fax

35:58.890 --> 36:01.890
它能够标识我们整个工程里边

36:01.890 --> 36:03.890
就是我们自己的工程里边

36:03.890 --> 36:04.890
有没有副作用

36:04.890 --> 36:06.890
它能够做出这个标识

36:06.890 --> 36:07.890
有没有副作用

36:07.890 --> 36:09.890
如果说你把标识为force

36:09.890 --> 36:10.890
表示我们整个工程

36:10.890 --> 36:11.890
是没有任何副作用的

36:11.890 --> 36:13.890
其实不管不光是我这里

36:13.890 --> 36:15.890
其实很多第三方

36:15.890 --> 36:16.890
它也会加这个东西

36:16.890 --> 36:17.890
它为了实现缺接king

36:17.890 --> 36:19.890
你看Loudash的es

36:19.890 --> 36:21.890
Loudash

36:21.890 --> 36:22.890
es

36:22.890 --> 36:24.890
它也会加这个东西

36:24.890 --> 36:26.890
看一下它的Padding.json

36:29.970 --> 36:31.970
Padding.json

36:32.970 --> 36:33.970
side而fax

36:33.970 --> 36:34.970
force

36:34.970 --> 36:36.970
因为Loudash它确实没有任何副作用

36:36.970 --> 36:38.970
它里边全是做运算的

36:38.970 --> 36:39.970
全是做一些辅助

36:39.970 --> 36:40.970
还说运算的

36:40.970 --> 36:41.970
它没有任何副作用

36:41.970 --> 36:42.970
但是我们这个工程里边

36:42.970 --> 36:44.970
我给大家加上side而fax

36:44.970 --> 36:45.970
side而fax就副作用的意思

36:45.970 --> 36:46.970
force表示没有副作用

36:46.970 --> 36:47.970
没有副作用

36:47.970 --> 36:48.970
它胆子就比较大了

36:48.970 --> 36:49.970
胆子大得很

36:49.970 --> 36:50.970
它没有副作用

36:50.970 --> 36:51.970
它既然没有副作用的话

36:51.970 --> 36:52.970
拉我担心啥

36:52.970 --> 36:54.970
你这样子根本没有用到

36:54.970 --> 36:55.970
它导出的东西

36:55.970 --> 36:57.970
我拉我就不担心了

36:57.970 --> 36:58.970
就不担心了

36:59.970 --> 37:03.690
你看

37:03.690 --> 37:04.690
再回来

37:04.690 --> 37:05.690
mess.radar

37:05.690 --> 37:06.690
是没了

37:06.690 --> 37:07.690
对吧

37:07.690 --> 37:08.690
整个工程都没有副作用

37:08.690 --> 37:09.690
拉我担心啥了

37:09.690 --> 37:11.690
因此它可以更加

37:11.690 --> 37:13.690
对代码来进行修化

37:13.690 --> 37:14.690
就更加大胆的

37:14.690 --> 37:15.690
对代码进行修化

37:15.690 --> 37:16.690
但是如果说你这里

37:16.690 --> 37:17.690
真的有副作用

37:17.690 --> 37:18.690
大家要出问题了

37:18.690 --> 37:19.690
也而这里有阿迦克斯

37:19.690 --> 37:20.690
请求是不是要出问题

37:20.690 --> 37:21.690
对吧

37:21.690 --> 37:22.690
因此我们可以在

37:22.690 --> 37:23.690
Padding.json里边

37:23.690 --> 37:24.690
可以进行这样的配置

37:24.690 --> 37:25.690
当然这个配置

37:25.690 --> 37:26.690
比较粗略

37:26.690 --> 37:27.690
比较粗略

37:27.690 --> 37:28.690
因为它这样子

37:28.690 --> 37:29.690
太暴力了吧

37:29.690 --> 37:30.690
所谓的文件

37:30.690 --> 37:31.690
所谓的模合

37:31.690 --> 37:32.690
它当成没有副作用

37:32.690 --> 37:33.690
太暴力了

37:34.690 --> 37:35.690
那么有没有

37:35.690 --> 37:36.690
更加精确的配置方式呢

37:36.690 --> 37:38.690
它还可以配置为一个数组

37:38.690 --> 37:39.690
除了配置为forced之外

37:39.690 --> 37:40.690
还可以配置为一个数组

37:40.690 --> 37:42.690
数组里边就告诉他

37:42.690 --> 37:44.690
哪些文件是有副作用的

37:44.690 --> 37:45.690
就告诉他

37:45.690 --> 37:46.690
哪些文件有副作用的

37:46.690 --> 37:47.690
其他文件就没有副作用

37:47.690 --> 37:49.690
那么比方我们可以这样配置

37:49.690 --> 37:50.690
这样配置

37:50.690 --> 37:51.690
它就是glob

37:51.690 --> 37:52.690
globplugging

37:52.690 --> 37:54.690
globpartons

37:54.690 --> 37:55.690
我们已经讲过了

37:55.690 --> 37:56.690
就是一个

37:56.690 --> 37:58.690
类似于真的表达式的那种方式

37:58.690 --> 37:59.690
好像在哪个地方讲过了

37:59.690 --> 38:00.690
加个桿套在前边

38:00.690 --> 38:01.690
表示

38:01.690 --> 38:03.690
除了src.com.js

38:03.690 --> 38:04.690
这个文件之外

38:04.690 --> 38:06.690
其他文件都是有副作用的

38:06.690 --> 38:07.690
除了这个文件之外

38:07.690 --> 38:08.690
都是有副作用的

38:08.690 --> 38:09.690
那么一个反之

38:09.690 --> 38:10.690
就告诉他

38:10.690 --> 38:11.690
这个文件是没有副作用的

38:11.690 --> 38:12.690
那么这样子

38:12.690 --> 38:13.690
对其他文件不造成影响

38:13.690 --> 38:15.690
比方说一些央视文件

38:15.690 --> 38:17.690
你把央视都搞没了

38:17.690 --> 38:18.690
你把央视都搞没了

38:18.690 --> 38:19.690
说央视文件

38:19.690 --> 38:20.690
就会出问题

38:20.690 --> 38:21.690
所以你这样配置

38:21.690 --> 38:22.690
那就好一点

38:22.690 --> 38:23.690
这样配置

38:23.690 --> 38:24.690
它只是告诉他

38:24.690 --> 38:25.690
这个文件是没有副作用的

38:25.690 --> 38:26.690
你看一下吧

38:31.300 --> 38:32.300
1.1.1.0

38:32.300 --> 38:33.300
那么我们不用看了

38:33.300 --> 38:34.300
1.1.1.0

38:34.300 --> 38:35.300
说明肯定没在里面

38:35.300 --> 38:37.300
OK 这是关于

38:37.300 --> 38:39.300
就是这个副作用的问题

38:39.300 --> 38:41.300
其实一般情况下

38:41.300 --> 38:42.300
我们不做处理

38:42.300 --> 38:43.300
因为我们代码

38:43.300 --> 38:45.300
如果说我们整个工程里面

38:45.300 --> 38:46.300
要代码

38:46.300 --> 38:47.300
最终打包了结果里面

38:47.300 --> 38:49.300
我们代码肯定是占小部分

38:49.300 --> 38:50.300
我们自己写的代码

38:50.300 --> 38:51.300
更多的是第三方库

38:51.300 --> 38:52.300
而第三方库

38:52.300 --> 38:53.300
已经给你处理好了

38:53.300 --> 38:54.300
哪些文件有副作用

38:54.300 --> 38:55.300
哪些文件没有副作用

38:55.300 --> 38:57.300
它第三方库

38:57.300 --> 38:58.300
已经给你处理好了

38:58.300 --> 39:00.300
只要它是一个负责任的

39:00.300 --> 39:01.300
流行的第三方库

39:01.300 --> 39:02.300
它一般都给你处理好

39:02.300 --> 39:03.300
OK

39:04.300 --> 39:05.300
那么最后

39:05.300 --> 39:06.300
我们来看一下

39:06.300 --> 39:08.300
关于CSS的缺隙性

39:08.300 --> 39:09.300
因为VPAC

39:09.300 --> 39:12.300
它是针对GS的ES6模块化

39:12.300 --> 39:13.300
来进行缺隙性的

39:13.300 --> 39:15.300
那CSS它就完全搞不定的

39:15.300 --> 39:17.300
因为CSS跟ES6

39:17.300 --> 39:18.300
没有包免半毛钱关系

39:18.300 --> 39:19.300
一点关系都没有

39:19.300 --> 39:21.300
见过哪里CSS里面

39:21.300 --> 39:22.300
用了ES6的代码

39:22.300 --> 39:24.300
不可能有这半年关系的

39:24.300 --> 39:25.300
所以说CSS

39:25.300 --> 39:26.300
它就完全没法处理的

39:26.300 --> 39:27.300
完全没法处理

39:27.300 --> 39:29.300
而且CSS它本身就有副作用

39:29.300 --> 39:30.300
对吧

39:30.300 --> 39:31.300
你就不能把它当成没有副作用

39:31.300 --> 39:32.300
它本身就有副作用

39:32.300 --> 39:34.300
它是要影响在页面上的样式的

39:34.300 --> 39:35.300
它是有外部影响的

39:35.300 --> 39:37.300
因此对CSS

39:37.300 --> 39:38.300
你不能把它当成没有副作用

39:38.300 --> 39:39.300
像这样子

39:39.300 --> 39:40.300
如果说你用一个CSS

39:40.300 --> 39:42.300
我们比方说写一个吧

39:42.300 --> 39:45.300
写一个index的CSS

39:45.300 --> 39:47.300
这里我们有个body

39:47.300 --> 39:50.300
比方说我们这里有个body

39:51.300 --> 39:52.300
这里

39:53.300 --> 39:56.300
白光的

40:00.300 --> 40:01.300
散热沾

40:02.300 --> 40:03.300
color

40:03.300 --> 40:04.300
ff

40:04.300 --> 40:06.300
我们这里写一些页面

40:06.300 --> 40:07.300
写个页面

40:07.300 --> 40:09.870
public

40:09.870 --> 40:10.870
index

40:13.310 --> 40:14.310
页面里边

40:15.310 --> 40:17.310
样式它让它自己加进去

40:17.310 --> 40:18.310
让它自己加进去

40:18.310 --> 40:19.310
然后我们这个body里边

40:19.310 --> 40:20.310
有个p元素

40:20.310 --> 40:21.310
一个p元素

40:21.310 --> 40:23.310
或者一个H元素

40:23.310 --> 40:24.310
H元素

40:25.310 --> 40:26.310
那么这里边

40:26.310 --> 40:28.310
我们CSS里边再写一个

40:30.310 --> 40:31.310
H元素

40:31.310 --> 40:33.310
然后来给它说一个字体大小

40:33.310 --> 40:34.310
fun size

40:34.310 --> 40:35.310
4en

40:35.310 --> 40:37.310
然后再写两个类样式吧

40:37.310 --> 40:38.310
red

40:38.310 --> 40:39.310
color

40:39.310 --> 40:41.620
red

40:41.620 --> 40:42.620
green

40:43.620 --> 40:44.620
color

40:45.620 --> 40:46.620
green

40:46.620 --> 40:47.620
OK

40:47.620 --> 40:48.620
我们写了这么一些类样式

40:48.620 --> 40:49.620
好

40:49.620 --> 40:50.620
接下来我们要做的事情就是

40:50.620 --> 40:52.620
我们希望打包这个CSS

40:52.620 --> 40:53.620
对吧

40:53.620 --> 40:55.620
我们在index.js里边去导入它

40:55.620 --> 40:56.620
import

40:56.620 --> 40:57.620
导入这个

40:58.620 --> 41:00.620
index.css

41:00.620 --> 41:01.620
是不是导入它

41:01.620 --> 41:02.620
好导入它过后

41:02.620 --> 41:04.620
我们让我们之前学过的

41:04.620 --> 41:05.620
什么loader

41:05.620 --> 41:06.620
还有plugging

41:06.620 --> 41:07.620
把它帮我生成

41:07.620 --> 41:08.620
css文件

41:08.620 --> 41:09.620
来吧

41:12.620 --> 41:13.620
叫做

41:13.620 --> 41:15.620
mini.css

41:15.620 --> 41:16.620
我就简单写一下

41:16.620 --> 41:17.620
require

41:17.620 --> 41:19.620
mini.css extract

41:19.620 --> 41:20.620
plugging

41:20.620 --> 41:22.620
那么这里我们加进来

41:22.620 --> 41:25.320
加进来

41:25.320 --> 41:26.320
然后marge

41:26.320 --> 41:31.040
这里我们是写一个

41:31.040 --> 41:32.040
ros

41:34.040 --> 41:35.040
然后这里每一个规则

41:35.040 --> 41:36.040
test

41:36.040 --> 41:37.040
反而是

41:37.040 --> 41:38.040
css文件

41:38.040 --> 41:40.040
我交给loader

41:40.040 --> 41:41.040
哪个loader呢

41:41.040 --> 41:42.040
use

41:42.040 --> 41:43.040
use

41:43.040 --> 41:46.040
第一个loader是mini.css的loader

41:46.040 --> 41:48.040
第二个loader是cssloader

41:48.040 --> 41:49.040
加进来

41:49.040 --> 41:50.040
我这些都安装了

41:50.040 --> 41:52.040
接下来我们来看一下

41:52.040 --> 41:53.040
它会生成css文件

41:53.040 --> 41:54.040
那么css文件

41:54.040 --> 41:55.040
它有没有把那些

41:55.040 --> 41:57.040
没有用的样式去掉了

42:03.590 --> 42:04.590
稍等一下

42:04.590 --> 42:05.590
那么看一下

42:05.590 --> 42:06.590
有没有去掉了

42:06.590 --> 42:07.590
是不是没有去掉

42:07.590 --> 42:08.590
这个东西搞不定

42:08.590 --> 42:10.590
去shaking肯定是搞不定的

42:10.590 --> 42:11.590
他们还有es6代

42:11.590 --> 42:12.590
肯定搞不定的

42:12.590 --> 42:13.590
他不知道哪些有用

42:13.590 --> 42:14.590
哪些没用的

42:14.590 --> 42:16.590
那么为了完成类似的效果

42:16.590 --> 42:17.590
其实对css

42:17.590 --> 42:19.590
已经不叫做去shaking了

42:19.590 --> 42:21.590
要叫的这样子叫了也无所谓

42:21.590 --> 42:23.590
它只是一种说法而已

42:23.590 --> 42:25.590
也就是一出没有用的css代

42:25.590 --> 42:27.590
那么这个东西要怎么做呢

42:27.590 --> 42:29.590
就需要以一个第三方库

42:29.590 --> 42:30.590
叫做

42:30.590 --> 42:33.590
就是perky css

42:33.590 --> 42:34.590
这么多

42:34.590 --> 42:35.590
为pack parking

42:35.590 --> 42:36.590
要用到这么一个插件

42:36.590 --> 42:41.440
我们安装一下

42:41.440 --> 42:43.440
它怎么搞定的呢

42:43.440 --> 42:45.440
它搞定的方式呢

42:45.440 --> 42:47.440
就是通过政策匹配

42:47.440 --> 42:49.440
你不是生成了css文件吗

42:49.440 --> 42:51.440
那么css文件

42:51.440 --> 42:53.440
跟一些东西去匹配

42:53.440 --> 42:54.440
比方说跟页面去匹配

42:54.440 --> 42:56.440
匹配一下页面

42:56.440 --> 42:58.440
页面中哪些

42:58.440 --> 43:01.440
就是页面中哪些地方用到了

43:01.440 --> 43:03.440
我们的css里面的样式

43:03.440 --> 43:04.440
就是匹配上了

43:04.440 --> 43:05.440
比方说我这里写的body

43:05.440 --> 43:06.440
元素选择器

43:06.440 --> 43:08.440
那么页面上有没有body元素

43:08.440 --> 43:09.440
有了body元素

43:09.440 --> 43:10.440
它就真的表达匹配

43:10.440 --> 43:11.440
诶匹配到了

43:11.440 --> 43:12.440
ok 那么就这个东西要用

43:12.440 --> 43:15.440
它就用这种粗暴的简单的方式来说的

43:15.440 --> 43:17.440
那么有没有用到A7医元素呢

43:17.440 --> 43:18.440
有用到A7医元素

43:18.440 --> 43:19.440
那么就用

43:19.440 --> 43:20.440
有没有用到这个内样式呢

43:20.440 --> 43:21.440
没有 那就区掉

43:21.440 --> 43:22.440
没有用到这个内样式就区掉

43:22.440 --> 43:24.440
它就是根据一个东西来匹配

43:24.440 --> 43:26.440
来匹配我们的css里面代码

43:26.440 --> 43:27.440
哪些要用 哪些不用

43:27.440 --> 43:28.440
它就用政策匹配的

43:31.440 --> 43:32.440
安装好了过程了

43:32.440 --> 43:33.440
我们来在这里用一下

43:34.440 --> 43:37.260
在这里用一下

43:38.260 --> 43:40.260
你有一个 诶 倒进来

43:42.260 --> 43:43.260
叫做

43:43.260 --> 43:44.260
叫啥言

43:45.260 --> 43:46.260
叫啥言

43:47.260 --> 43:49.260
这个progress

43:49.260 --> 43:50.260
progress

43:50.260 --> 43:51.260
就这个吧

43:53.260 --> 43:54.260
require

43:55.260 --> 43:57.260
pro-css

43:57.260 --> 43:58.260
什么东西

43:58.260 --> 43:59.260
查一下吧

43:59.260 --> 44:00.260
这个单词

44:00.260 --> 44:01.260
虽然我也学习一下

44:01.260 --> 44:02.260
单词啥意思

44:07.300 --> 44:08.300
pro-g

44:09.300 --> 44:10.300
pro-g游戏里边有个单词

44:10.300 --> 44:11.300
pro-g进化

44:12.300 --> 44:13.300
pro-g css

44:14.300 --> 44:17.300
好 那么这里我们使用它

44:17.300 --> 44:18.300
使用它

44:18.300 --> 44:20.300
那么它那边有一些配置

44:20.300 --> 44:21.300
它那边是有配置的

44:22.300 --> 44:23.300
我们看一下

44:23.300 --> 44:24.300
它那边有个什么配置呢

44:24.300 --> 44:25.300
我们来查一下它的文档

44:25.300 --> 44:26.300
这些API的

44:26.300 --> 44:27.300
请原谅

44:27.300 --> 44:29.300
我是经常忘的

44:29.300 --> 44:30.300
大家记得住

44:31.300 --> 44:32.300
查一下

44:32.300 --> 44:37.430
进去

44:38.430 --> 44:41.640
回忆一下

44:41.640 --> 44:42.640
他们回忆起来

44:42.640 --> 44:43.640
这里边

44:43.640 --> 44:44.640
passes

44:44.640 --> 44:45.640
就这个玩意

44:45.640 --> 44:46.640
passes

44:46.640 --> 44:47.640
passes它配置为一个什么呢

44:48.640 --> 44:49.640
配置为一个数组

44:50.640 --> 44:51.640
这个数组里边

44:51.640 --> 44:53.640
你要写一些绝对路径

44:53.640 --> 44:55.640
就这里边要写绝对路径的

44:56.640 --> 44:57.640
明白了意思吧

44:57.640 --> 44:58.640
它要写写绝对路径的

44:58.640 --> 44:59.640
比方说

44:59.640 --> 45:00.640
这个绝对路径是什么意思呢

45:00.640 --> 45:02.640
就绝对路径的

45:05.640 --> 45:06.640
绝对路径

45:06.640 --> 45:07.640
就是说

45:07.640 --> 45:08.640
它这个CSS

45:08.640 --> 45:09.640
要跟哪些文件

45:09.640 --> 45:10.640
进行匹配

45:10.640 --> 45:11.640
看有没有用到

45:12.640 --> 45:13.640
比方说我这里写这么一个

45:13.640 --> 45:14.640
ATM页面

45:14.640 --> 45:15.640
这个路径

45:15.640 --> 45:16.640
给它写进去

45:16.640 --> 45:17.640
比方说

45:17.640 --> 45:18.640
我给它写这么一个路径

45:18.640 --> 45:19.640
这个路径

45:19.640 --> 45:20.640
是绝对路径

45:20.640 --> 45:21.640
绝对路径

45:21.640 --> 45:22.640
我们要用pass

45:22.640 --> 45:23.640
来生成

45:23.640 --> 45:24.640
pass

45:24.640 --> 45:25.640
require

45:26.640 --> 45:29.020
pass

45:30.020 --> 45:31.020
passresult

45:31.020 --> 45:32.020
把变成绝对路径

45:32.020 --> 45:33.020
DIRLin

45:33.020 --> 45:35.020
当前路径下面的

45:35.020 --> 45:36.020
哪个目录呢

45:36.020 --> 45:37.020
public

45:37.020 --> 45:38.020
目录下面的

45:39.020 --> 45:40.020
它要

45:40.020 --> 45:41.020
那么就告诉他

45:41.020 --> 45:42.020
我们最终的CSS

45:42.020 --> 45:43.020
生成的CSS

45:43.020 --> 45:45.020
要跟这个文件进行对比

45:45.020 --> 45:46.020
看一下这个文件里边

45:46.020 --> 45:47.020
哪些地方

45:47.020 --> 45:48.020
用到了CSS里边的东西

45:48.020 --> 45:49.020
哪些地方

45:49.020 --> 45:50.020
没有用到

45:50.020 --> 45:51.020
它一对比

45:51.020 --> 45:52.020
你看

45:52.020 --> 45:53.020
CSS文件的东西有这么多

45:53.020 --> 45:54.020
它一对比这个文件

45:54.020 --> 45:55.020
一对比

45:55.020 --> 45:56.020
发现我只用到了body

45:56.020 --> 45:57.020
和H1

45:57.020 --> 45:58.020
只有这两个在这个文件里面

45:58.020 --> 45:59.020
发挥多用

45:59.020 --> 46:00.020
就这个文件里面

46:00.020 --> 46:01.020
只用到了body和H1

46:01.020 --> 46:02.020
那么这两个是没有用到的

46:02.020 --> 46:03.020
没用到

46:03.020 --> 46:04.020
它就去掉了

46:04.020 --> 46:06.020
一定要绝对路径

46:06.020 --> 46:07.020
是一个输

46:10.740 --> 46:15.220
完毕了

46:15.220 --> 46:16.220
打包完成

46:16.220 --> 46:17.220
你看

46:17.220 --> 46:18.220
是把这两个去掉了

46:18.220 --> 46:19.220
对吧

46:19.220 --> 46:20.220
给他一个绝对路径就完事了

46:20.220 --> 46:22.220
给他一个绝对路径就完事了

46:22.220 --> 46:24.220
当然有些时候

46:25.220 --> 46:26.220
有些时候

46:26.220 --> 46:27.220
还有一个问题就是

46:27.220 --> 46:28.220
我们要在

46:28.220 --> 46:29.220
CS里面玩

46:29.220 --> 46:31.220
CS里面要动态生成

46:31.220 --> 46:32.220
很多时候都动态生成的

46:32.220 --> 46:33.220
比方说我们在这里

46:34.220 --> 46:36.220
我们手动生成一个div

46:37.220 --> 46:39.220
div document

46:39.220 --> 46:40.220
create elements

46:40.220 --> 46:41.220
create elements

46:41.220 --> 46:42.220
div

46:44.220 --> 46:45.220
div

46:45.220 --> 46:47.220
我们给他设置一个InnerTags

46:47.220 --> 46:48.220
mydiv

46:48.220 --> 46:50.220
那么给他加入到

46:50.220 --> 46:52.220
document body

46:52.220 --> 46:53.220
repent child

46:53.220 --> 46:54.220
div加进去

46:54.220 --> 46:56.220
这个地方有强迫症

46:57.220 --> 46:58.220
然后div

46:58.220 --> 47:00.220
要用到class name

47:00.220 --> 47:01.220
要用到这个

47:01.220 --> 47:02.220
read央视

47:02.220 --> 47:03.220
你看

47:03.220 --> 47:04.220
这里要用到read央视

47:04.220 --> 47:05.220
那么这样子

47:05.220 --> 47:06.220
read央视有没有消除掉了

47:06.220 --> 47:07.220
它还是会消除掉

47:07.220 --> 47:08.220
因为它为什么

47:08.220 --> 47:09.220
它只跟这个文件对比

47:09.220 --> 47:10.220
它跟我们的介绍文件

47:10.220 --> 47:11.220
没有它关系

47:11.220 --> 47:12.220
这是我们来看一下吧

47:15.220 --> 47:16.220
npm run build

47:19.220 --> 47:20.220
看最终的CS

47:20.220 --> 47:21.220
CS

47:22.220 --> 47:23.220
还是给我去掉了

47:23.220 --> 47:24.220
明明我这里用到了

47:24.220 --> 47:25.220
这个样式

47:25.220 --> 47:26.220
还是去掉了

47:26.220 --> 47:27.220
那么到时候介视运行

47:27.220 --> 47:28.220
生成的div

47:28.220 --> 47:29.220
是不是就没有这个样式了

47:29.220 --> 47:30.220
对吧

47:30.220 --> 47:31.220
没了意思

47:31.220 --> 47:32.220
因此

47:32.220 --> 47:33.220
我们这一块

47:33.220 --> 47:35.220
还要去告诉他

47:35.220 --> 47:36.220
就是因为他为什么

47:36.220 --> 47:37.220
是个数组

47:37.220 --> 47:38.220
所以他对比

47:38.220 --> 47:39.220
对比多个文件

47:39.220 --> 47:40.220
光对比这个文件

47:40.220 --> 47:41.220
介视文件

47:41.220 --> 47:42.220
那么我们这里是不是

47:42.220 --> 47:43.220
还可以加上一个数数

47:43.220 --> 47:44.220
加上一项

47:44.220 --> 47:47.220
passresult

47:47.220 --> 47:48.220
dln

47:48.220 --> 47:50.220
还要去加上一个

47:50.220 --> 47:52.220
src下面的

47:52.220 --> 47:53.220
哪个呢

47:53.220 --> 47:55.220
index叫介视

47:55.220 --> 47:56.220
还要去到index

47:56.220 --> 47:57.220
介视里面

47:57.220 --> 47:58.220
这个介视里面

47:58.220 --> 47:59.220
用正轴表达数据匹配

47:59.220 --> 48:00.220
看有没有read的东西出现

48:00.220 --> 48:01.220
也出现了read

48:01.220 --> 48:02.220
那么这里边

48:02.220 --> 48:03.220
read就要保留

48:03.220 --> 48:04.220
这里的read就要保留

48:04.220 --> 48:05.220
看一下吧

48:05.220 --> 48:07.660
run build

48:11.510 --> 48:12.510
你看

48:13.510 --> 48:14.510
咱们在这边

48:14.510 --> 48:16.510
css里面是不是有read的了

48:16.510 --> 48:17.510
对吧

48:17.510 --> 48:18.510
他就是用正轴表达

48:18.510 --> 48:19.510
是对比的

48:19.510 --> 48:20.510
非常的粗暴

48:20.510 --> 48:21.510
非常的粗暴

48:21.510 --> 48:22.510
然后了

48:22.510 --> 48:23.510
这里边

48:23.510 --> 48:24.510
我再说一下

48:24.510 --> 48:25.510
这个邪法的问题

48:25.510 --> 48:26.510
这个邪法

48:26.510 --> 48:27.510
确实太

48:27.510 --> 48:28.510
太麻烦了

48:28.510 --> 48:29.510
因为我们这里边

48:29.510 --> 48:31.510
说不好有很多的介视

48:31.510 --> 48:32.510
都要去index.css

48:32.510 --> 48:33.510
都要去

48:33.510 --> 48:34.510
都要去

48:34.510 --> 48:36.510
使用它里面的样式

48:36.510 --> 48:37.510
所以说

48:37.510 --> 48:38.510
我们一般希望

48:38.510 --> 48:40.510
用这个东西

48:40.510 --> 48:41.510
用globe

48:42.510 --> 48:43.510
puffers

48:43.510 --> 48:45.510
用这个东西来进行匹配

48:45.510 --> 48:46.510
但是问题是

48:46.510 --> 48:47.510
它这个插件

48:47.510 --> 48:48.510
它不支持这样的匹配

48:48.510 --> 48:49.510
于是

48:49.510 --> 48:50.510
我们又要用到

48:50.510 --> 48:51.510
另外一个第三方库

48:51.510 --> 48:52.510
叫做globe

48:57.510 --> 48:58.510
这个玩意可以干嘛呢

48:58.510 --> 49:00.510
它可以把一个globe表达式

49:00.510 --> 49:03.510
就类似于这个东西

49:03.510 --> 49:05.510
类似于这种表达式

49:05.510 --> 49:07.510
把它转换成

49:07.510 --> 49:08.510
一个

49:08.510 --> 49:10.510
转换成匹配到了路径

49:10.510 --> 49:11.510
再看一下吧

49:11.510 --> 49:12.510
这个库

49:12.510 --> 49:13.510
其实它还有一个对应的库

49:13.510 --> 49:14.510
叫globe

49:14.510 --> 49:15.510
globe

49:15.510 --> 49:17.510
globe那个库

49:17.510 --> 49:18.510
它是匹配

49:18.510 --> 49:20.510
它是单个规则

49:20.510 --> 49:21.510
就是一用单个规则

49:21.510 --> 49:22.510
它是匹配

49:22.510 --> 49:23.510
globe2这个库

49:23.510 --> 49:24.510
它可以用多个规则

49:24.510 --> 49:25.510
来进行匹配

49:25.510 --> 49:27.510
咱们来看一下吧

49:27.510 --> 49:28.510
看一下就明白了

49:28.510 --> 49:29.510
globe2

49:29.510 --> 49:30.510
globe2

49:30.510 --> 49:32.510
它里面有一个函数叫sync

49:32.510 --> 49:33.510
这里边

49:33.510 --> 49:34.510
你可以写个数组

49:34.510 --> 49:36.510
如果你是globe

49:36.510 --> 49:37.510
这个库的话

49:37.510 --> 49:38.510
你这里面

49:38.510 --> 49:40.510
只能写个字幕券

49:40.510 --> 49:41.510
我们这里能用globe

49:41.510 --> 49:42.510
它可以写个数组

49:42.510 --> 49:44.510
就是你可以给它一个多个规则

49:44.510 --> 49:46.510
比方说我给它两个规则

49:46.510 --> 49:47.510
一个规则是

49:47.510 --> 49:48.510
是什么呢

49:48.510 --> 49:49.510
是那个

49:49.510 --> 49:53.340
是这个

49:53.340 --> 49:54.340
是这个东西

49:54.340 --> 49:56.340
我们把这个东西

49:56.340 --> 49:58.340
DiRName

49:58.340 --> 50:00.340
拼接

50:00.340 --> 50:01.340
第一个字幕券

50:01.340 --> 50:02.340
就是一个匹配字幕券

50:02.340 --> 50:03.340
因为它必须要匹配到

50:03.340 --> 50:04.340
绝对都进

50:04.340 --> 50:05.340
所以说我们用DiRName

50:05.340 --> 50:06.340
表示绝对都进

50:06.340 --> 50:07.340
当前的绝对都进

50:07.340 --> 50:08.340
当然我们也可以用pass

50:08.340 --> 50:09.340
把当前的绝对

50:09.340 --> 50:10.340
当前的

50:10.340 --> 50:11.340
src的绝对路径

50:11.340 --> 50:13.340
给它写出来

50:13.340 --> 50:14.340
src

50:14.340 --> 50:15.340
ibs

50:15.340 --> 50:17.340
用pass

50:17.340 --> 50:18.340
result

50:18.340 --> 50:19.340
diRName

50:19.340 --> 50:20.340
src

50:20.340 --> 50:21.340
那么得到什么

50:21.340 --> 50:24.340
得到src的绝对路径

50:24.340 --> 50:26.340
给到src的绝对路径

50:26.340 --> 50:28.340
然后把src的绝对路径

50:28.340 --> 50:29.340
给它加进去

50:29.340 --> 50:30.340
第一个字幕券

50:30.340 --> 50:31.340
我们可以用这样的方式

50:31.340 --> 50:32.340
方式来写

50:32.340 --> 50:33.340
src的绝对路径

50:33.340 --> 50:34.340
然后后面就是

50:34.340 --> 50:35.340
两个信号

50:35.340 --> 50:36.340
一个信号一个gs

50:36.340 --> 50:37.340
那么这样子

50:37.340 --> 50:39.340
它就去匹配

50:39.340 --> 50:40.340
src目录下面的

50:40.340 --> 50:41.340
所有的目录

50:41.340 --> 50:42.340
所有的指目录

50:42.340 --> 50:44.340
无论有多少的指目录

50:44.340 --> 50:45.340
多少成绩

50:45.340 --> 50:46.340
所有的gs文件

50:46.340 --> 50:47.340
全部找出来

50:47.340 --> 50:49.340
那么然后再来一个

50:49.340 --> 50:50.340
再来一个是什么

50:50.340 --> 50:52.340
再来一个是

50:52.340 --> 50:54.340
public目录下面的index

50:54.340 --> 50:56.340
public目录下面index

50:56.340 --> 50:57.340
那么这个我们就可以用

50:57.340 --> 50:58.340
diRName

50:58.340 --> 51:00.340
当前的目录的绝对路径

51:00.340 --> 51:01.340
然后

51:01.340 --> 51:04.340
public

51:04.340 --> 51:06.340
然后下面的index

51:06.340 --> 51:07.340
对吧

51:07.340 --> 51:08.340
好

51:08.340 --> 51:09.340
咱们来看一下

51:09.340 --> 51:10.340
匹配的结果

51:10.340 --> 51:11.340
passes

51:11.340 --> 51:13.340
匹配的结果

51:13.340 --> 51:14.340
输出

51:14.340 --> 51:23.650
passes

51:23.650 --> 51:24.650
运行

51:24.650 --> 51:25.650
看一下输出的目录

51:25.650 --> 51:26.650
输出的东西

51:26.650 --> 51:27.650
你看

51:27.650 --> 51:28.650
它是不是得到一个输出

51:28.650 --> 51:29.650
这个输出

51:29.650 --> 51:30.650
就是匹配到了

51:30.650 --> 51:31.650
所有的绝对路径

51:31.650 --> 51:32.650
匹配到了什么

51:32.650 --> 51:33.650
匹配到了common.js

51:33.650 --> 51:34.650
匹配到了index.js

51:34.650 --> 51:36.650
匹配到了mimes.js

51:36.650 --> 51:37.650
我们的index

51:38.650 --> 51:41.650
这里是要加上一个

51:41.650 --> 51:43.650
diRName

51:43.650 --> 51:45.650
diRName是当前的目录

51:45.650 --> 51:47.650
当前的目录

51:47.650 --> 51:49.650
diRName是当前的目录

51:49.650 --> 51:51.650
我看一下

51:51.650 --> 51:53.650
diRName是当前的目录

51:53.650 --> 51:58.300
缺协讯

51:58.300 --> 52:00.300
它的目录结构

52:00.300 --> 52:02.300
因为它用的是右鞋杠

52:02.300 --> 52:03.300
我们用的是左鞋杠

52:03.300 --> 52:05.300
还是用passresolve一下

52:05.300 --> 52:07.300
atmail

52:07.300 --> 52:09.300
passresolve一下

52:09.300 --> 52:11.300
diRName

52:11.300 --> 52:12.300
public

52:12.300 --> 52:13.300
下面的index.js

52:13.300 --> 52:15.300
它会根据不同的操作系统

52:15.300 --> 52:17.300
来优化这个路径

52:17.300 --> 52:18.300
我们把这个放进来

52:18.300 --> 52:19.300
然后给它两个

52:19.300 --> 52:20.300
一个是atmail的路径

52:20.300 --> 52:22.300
一个是所有的js的规则

52:22.300 --> 52:25.300
然后它帮我生成一个路径

52:25.300 --> 52:29.020
看一下

52:29.020 --> 52:30.020
你看

52:30.020 --> 52:31.020
是不是我们所有的

52:31.020 --> 52:32.020
需要对比的文件

52:32.020 --> 52:33.020
就形成了一个数组了

52:33.020 --> 52:35.020
通过这个枯球完成

52:35.020 --> 52:36.020
通过这个枯球完成

52:36.020 --> 52:38.020
那么我们把这个passres

52:38.020 --> 52:40.020
放进来

52:40.020 --> 52:41.020
放到这来

52:41.020 --> 52:43.020
有点麻烦

52:43.020 --> 52:44.020
有点麻烦

52:44.020 --> 52:45.020
你可以单独去

52:45.020 --> 52:47.020
开一个模块来做这个事

52:47.020 --> 52:49.020
我们来看一下

52:49.020 --> 52:50.020
run build

52:50.020 --> 52:53.550
这样子

52:53.550 --> 52:55.550
它对比了所有的js

52:55.550 --> 52:56.550
然后还对比了

52:56.550 --> 52:57.550
我们的atmail

52:57.550 --> 52:58.550
这样子我们的css

52:58.550 --> 52:59.550
就比较合适了

52:59.550 --> 53:00.550
里边的东西

53:00.550 --> 53:01.550
OK

53:01.550 --> 53:04.550
这就是关于css的缺协讯

53:04.550 --> 53:06.550
这里还有一个点要注意

53:06.550 --> 53:08.550
如果说你用这个枯的话

53:08.550 --> 53:10.550
对css module是无能为力的

53:10.550 --> 53:11.550
为啥呢

53:11.550 --> 53:13.550
因为它是用征则对比的

53:13.550 --> 53:14.550
它对比的是啥

53:14.550 --> 53:16.550
对比的是这个玩意儿

53:16.550 --> 53:18.550
它对比的是这种red

53:18.550 --> 53:20.550
你如果说你开起了css module

53:20.550 --> 53:22.550
那么这里边是不是red

53:22.550 --> 53:24.550
它肯定不是生成了一个乱七八糟的玩意儿了

53:24.550 --> 53:26.550
就生成了一个乱七八糟的玩意儿了

53:26.550 --> 53:28.550
它就搞不定了

53:28.550 --> 53:29.550
它有些处理办法

53:29.550 --> 53:30.550
不过处理办法

53:30.550 --> 53:32.550
我看了一下不太好

53:32.550 --> 53:33.550
所以说css module

53:33.550 --> 53:35.550
这个东西始终是一个问题

53:35.550 --> 53:38.550
这个问题有待于将来解决吧

53:38.550 --> 53:41.550
所有的问题也现在也不是很好解决

53:41.550 --> 53:43.550
所以我们写css的时候

53:43.550 --> 53:44.550
还是尽量的

53:44.550 --> 53:46.550
需要用到哪些 写哪些

53:46.550 --> 53:47.550
OK

53:47.550 --> 53:51.550
那么这就是我们这一块的缺协讯

53:51.550 --> 53:53.550
平时我们怎么用呢

53:53.550 --> 53:54.550
再总结一下

53:54.550 --> 53:57.550
平时我们对我们的开发影响的话

53:57.550 --> 53:58.550
也就是说我们写代码的时候

53:58.550 --> 54:00.550
模块导出使用这种方式

54:00.550 --> 54:03.550
模块导入尽量使用这种方式

54:03.550 --> 54:05.550
这是我们对我们写代码的影响

54:05.550 --> 54:06.550
然后呢

54:06.550 --> 54:08.550
为了让它更加

54:08.550 --> 54:10.550
更加就是那个

54:10.550 --> 54:11.550
好的发挥作用呢

54:11.550 --> 54:13.550
我们有可能

54:13.550 --> 54:14.550
会加入这个插件

54:14.550 --> 54:16.550
但是加入这个插件呢

54:16.550 --> 54:17.550
实话给你们说吧

54:17.550 --> 54:19.550
如果说我开发项目我不敢加

54:19.550 --> 54:21.550
我不敢加这个插件

54:21.550 --> 54:22.550
因为它一旦出了问题

54:22.550 --> 54:24.550
没什么人解决

54:24.550 --> 54:25.550
因为不更新了

54:25.550 --> 54:27.550
这是个非常牢火的事情

54:27.550 --> 54:29.550
所以说我加这个插件

54:29.550 --> 54:30.550
我不是很敢加

54:30.550 --> 54:32.550
其实不加它的话

54:32.550 --> 54:34.550
影响也没有大家想象的那么大

54:34.550 --> 54:36.550
OK 那么就是这一块的血清

