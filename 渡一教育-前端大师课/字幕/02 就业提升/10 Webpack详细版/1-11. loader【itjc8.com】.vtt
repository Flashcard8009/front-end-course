WEBVTT

00:01.070 --> 00:04.070
这些课咱们来讲一个非常重要的概念

00:04.070 --> 00:05.070
就是loader

00:05.070 --> 00:07.070
那么loader到底是什么东西呢

00:07.070 --> 00:11.070
我们来回顾一下webpack到底做什么事

00:11.070 --> 00:13.070
webpack它做什么事呢

00:13.070 --> 00:17.070
它就是希望让我们写原代码开开新新的写

00:17.070 --> 00:18.070
你想咋写咋写

00:18.070 --> 00:21.070
你不用去担心这个代码能不能运行

00:21.070 --> 00:23.070
因为经过loaderpack的编译

00:23.070 --> 00:25.070
最终的代码它一定能运行

00:25.070 --> 00:29.070
所以说loaderpack做了很多事情

00:29.070 --> 00:32.070
比方说我们之前讲过了它的整个流程

00:32.070 --> 00:38.070
它会根据依赖关系把我们的模块进行合并

00:38.070 --> 00:39.070
打包进行合并

00:39.070 --> 00:42.070
先分析出整个模块然后打包进行合并

00:42.070 --> 00:46.070
当然还可能会产生map文件

00:46.070 --> 00:48.070
那么最终生成资源列表然后输出

00:48.070 --> 00:51.070
所以webpack它做的事情其实特别简单

00:51.070 --> 00:53.070
它就是说根据我们的

00:53.070 --> 00:55.070
它分解成很多是trunk

00:55.070 --> 00:57.070
我们根据配置来分解成trunk

00:57.070 --> 01:00.070
那么每个trunk根据一个入口的模块

01:00.070 --> 01:02.070
或者是几个入口的模块

01:02.070 --> 01:05.070
然后分析出这些模块一旦哪些模块把它分析出来

01:05.070 --> 01:08.070
最终会形成资源列表

01:08.070 --> 01:10.070
最终打不到指定的文件中

01:10.070 --> 01:12.070
这就是webpack做的事情

01:12.070 --> 01:14.070
那么更多的功能呢

01:14.070 --> 01:15.070
webpack就没有做了

01:15.070 --> 01:18.070
因为它也不知道你将来会需要什么样的功能

01:18.070 --> 01:20.070
因此它就提供了两个扩展点

01:20.070 --> 01:21.070
一个是loader

01:21.070 --> 01:23.070
一个是plugins

01:23.070 --> 01:24.070
一个叫做夹载器

01:24.070 --> 01:26.070
一个叫做插件

01:26.070 --> 01:28.070
我们平时都直接用英文来表述

01:28.070 --> 01:29.070
一个是loader

01:29.070 --> 01:30.070
一个是plugin

01:30.070 --> 01:33.070
那么这两个实际上就是webpack的扩展

01:33.070 --> 01:35.070
你要扩展它的功能

01:35.070 --> 01:36.070
它里边其实没有什么功能

01:36.070 --> 01:37.070
它就是一个打包

01:37.070 --> 01:40.070
把合并给它很多的GS模块

01:40.070 --> 01:41.070
把它合并在一起

01:41.070 --> 01:43.070
它无非就做这么一些事

01:43.070 --> 01:44.070
那么更多的功能呢

01:44.070 --> 01:46.070
你要靠这两个扩展来扩展它的功能

01:46.070 --> 01:49.070
那么这就可能我们先来学习loader

01:49.070 --> 01:51.070
那么loader是什么呢

01:51.070 --> 01:52.070
loader其实特别简单

01:52.070 --> 01:54.070
它本质上就是一个函数

01:54.070 --> 01:58.070
它的作用是在webpack打包的过程中

01:58.070 --> 02:00.070
将某个圆码制服串

02:00.070 --> 02:03.070
转换成另一个圆码制服串返回

02:03.070 --> 02:04.070
举个例子吧

02:04.070 --> 02:06.070
比方说我们的工程里边

02:06.070 --> 02:08.070
我已经把配置好了

02:08.070 --> 02:10.070
这些东西我就把删了

02:10.070 --> 02:11.070
删了

02:11.070 --> 02:12.070
OK

02:12.070 --> 02:14.070
你看我们之前是这样的配置的

02:14.070 --> 02:15.070
对吧

02:15.070 --> 02:18.070
那么现在我在圆码

02:18.070 --> 02:20.070
就是我的入口文件里边

02:20.070 --> 02:22.070
我写上这么一句代码

02:22.070 --> 02:24.070
我觉得平时写变量的时候

02:24.070 --> 02:25.070
这样子写我不舒服

02:25.070 --> 02:27.070
举个例子

02:27.070 --> 02:29.070
我在怎么写才舒服呢

02:29.070 --> 02:31.070
因为它webpack的作用就是让你写起来

02:31.070 --> 02:32.070
尽量的舒服

02:32.070 --> 02:34.070
那我怎么写才能舒服呢

02:34.070 --> 02:35.070
我这样子写

02:35.070 --> 02:37.070
我举个例子随便下去个例子

02:37.070 --> 02:40.070
我在这样子写我才觉得舒服

02:40.070 --> 02:42.070
那么这样的代码webpack

02:42.070 --> 02:43.070
能不能打包呢

02:43.070 --> 02:45.070
我们来试一下吧

02:45.070 --> 02:48.070
比方说我们这里是用npxwebpack

02:48.070 --> 02:49.070
打包

02:49.070 --> 02:50.070
来

02:50.070 --> 02:51.070
打包一下

02:51.070 --> 02:53.070
它说什么呢

02:53.070 --> 02:55.070
它打包完成了

02:55.070 --> 02:57.070
打包完成了

02:57.070 --> 02:58.070
但是呢

02:58.070 --> 02:59.070
它包了一个错

02:59.070 --> 03:00.070
打包的过程中包了一错

03:00.070 --> 03:01.070
打包实际上完成了

03:01.070 --> 03:02.070
但是打包过程中包了错

03:02.070 --> 03:05.070
所以说打包结果你是也没法用的

03:05.070 --> 03:06.070
它什么错误呢

03:06.070 --> 03:07.070
它是这样子

03:07.070 --> 03:08.070
它告诉你

03:08.070 --> 03:09.070
它说

03:09.070 --> 03:14.070
它在模块的解析过程中出现了错误

03:14.070 --> 03:16.070
为什么出现了错误呢

03:16.070 --> 03:17.070
因为它把这个东西当成

03:17.070 --> 03:19.070
既也是模块来解析

03:19.070 --> 03:20.070
它不是运行

03:20.070 --> 03:22.070
是来解析这个模块

03:22.070 --> 03:23.070
那么解析的过程中

03:23.070 --> 03:25.070
它遇到了一些根本看不懂的东西

03:25.070 --> 03:26.070
比方说这个东西

03:26.070 --> 03:27.070
看不懂了

03:27.070 --> 03:28.070
因此它包了错

03:28.070 --> 03:29.070
那么这个错误

03:29.070 --> 03:31.070
在我们之前学的webpack流程里边

03:31.070 --> 03:33.070
是哪一步发生了错误呢

03:33.070 --> 03:34.070
咱们来看一下

03:34.070 --> 03:36.070
回顾一下之前的流程

03:36.070 --> 03:37.070
我们之前说

03:37.070 --> 03:38.070
webpack的种流程

03:38.070 --> 03:39.070
初始化

03:39.070 --> 03:40.070
然后了编译

03:40.070 --> 03:41.070
创可

03:41.070 --> 03:42.070
大家在心里边回顾一下

03:42.070 --> 03:43.070
这个东西很重要的

03:43.070 --> 03:45.070
最终生成了支援力表

03:45.070 --> 03:46.070
然后呢

03:46.070 --> 03:47.070
在这个整个流程里边呢

03:47.070 --> 03:48.070
其中有一部分流程

03:48.070 --> 03:49.070
就是在生成模块

03:49.070 --> 03:50.070
生成模块

03:50.070 --> 03:51.070
根据你的入口文件

03:51.070 --> 03:52.070
来生成

03:53.070 --> 03:54.070
到底依赖哪些模块

03:54.070 --> 03:55.070
是不是生成这个地方

03:55.070 --> 03:56.070
在生成这个玩意儿

03:56.070 --> 03:57.070
那么我们来看一下

03:57.070 --> 03:58.070
再回顾一下

04:02.700 --> 04:03.700
这个地方

04:04.700 --> 04:05.700
创可中

04:05.700 --> 04:06.700
就是每一个创可里边都要的

04:06.700 --> 04:07.700
解析模块的流程

04:07.700 --> 04:08.700
就在解析这一部分

04:08.700 --> 04:11.700
它是怎么把这些模块分解出来的

04:11.700 --> 04:13.700
就是把这一部分模块

04:13.700 --> 04:14.700
它是怎么来分解出来的

04:14.700 --> 04:15.700
它这么知道有这么一些模块

04:15.700 --> 04:16.700
它怎么分解呢

04:16.700 --> 04:17.700
我们来再回顾一下

04:17.700 --> 04:19.700
首先找到模块文件

04:19.700 --> 04:20.700
你不是给了一个路径吗

04:20.700 --> 04:21.700
找了一个模块文件

04:21.700 --> 04:23.700
也找到模块文件过后呢

04:23.700 --> 04:24.700
如果这个模块文件

04:24.700 --> 04:25.700
在最终的模块记录里边

04:25.700 --> 04:26.700
就在这里边

04:26.700 --> 04:27.700
这个表格里边

04:27.700 --> 04:28.700
如果说已经记录了

04:28.700 --> 04:29.700
那么就直接结束

04:29.700 --> 04:30.700
如果没有记录的话

04:30.700 --> 04:32.700
那么就要记录这个模块

04:32.700 --> 04:33.700
怎么记录呢

04:33.700 --> 04:34.700
首先把这个文件内容读出来

04:34.700 --> 04:36.700
是不是把这个文件内容读出来了

04:36.700 --> 04:37.700
然后做了什么事呢

04:37.700 --> 04:40.700
是不是在做抽象与法术分析

04:40.700 --> 04:41.700
是不是在做这么一件事

04:41.700 --> 04:44.700
它就在这一步发生了问题

04:44.700 --> 04:45.700
因为它没有办法

04:45.700 --> 04:47.700
把这个东西变成一个抽象与法术

04:47.700 --> 04:48.700
它变不出来

04:48.700 --> 04:49.700
为什么变不出来呢

04:49.700 --> 04:50.700
因为这个代码是错误的

04:50.700 --> 04:51.700
它不满足与法

04:51.700 --> 04:52.700
它解析不出来

04:52.700 --> 04:54.700
说我们这个代码呢

04:54.700 --> 04:55.700
它在哪里犯了错呢

04:55.700 --> 04:57.700
它在这里发生了错误

04:57.700 --> 04:58.700
它解析不出来

04:58.700 --> 04:59.700
这个抽象与法术

04:59.700 --> 05:00.700
那么解析不出来

05:00.700 --> 05:01.700
抽象与法术

05:01.700 --> 05:02.700
它就是

05:02.700 --> 05:03.700
它就没有办法去找依赖

05:03.700 --> 05:04.700
对吧

05:04.700 --> 05:05.700
找这个模块的依赖

05:05.700 --> 05:06.700
也没有办法去替换依赖函术

05:06.700 --> 05:08.700
虽然我们这里没有写依赖函术

05:09.700 --> 05:10.700
那么这里

05:10.700 --> 05:11.700
是不是就造成了这个问题

05:11.700 --> 05:12.700
因为这里不是一个

05:12.700 --> 05:13.700
不合法的代码

05:13.700 --> 05:14.700
原理是吗

05:14.700 --> 05:15.700
它是把它当成

05:15.700 --> 05:16.700
借代码来进行解析

05:16.700 --> 05:18.700
这个代码不合法

05:18.700 --> 05:19.700
那么它就解析不出来

05:19.700 --> 05:20.700
因此呢

05:20.700 --> 05:21.700
它就发直接

05:21.700 --> 05:22.700
它做了一件事

05:22.700 --> 05:23.700
它直接

05:23.700 --> 05:24.700
但这件事呢

05:24.700 --> 05:25.700
我们也

05:25.700 --> 05:26.700
做不做其实都无所谓

05:26.700 --> 05:27.700
因为肯定错了

05:27.700 --> 05:28.700
它就把直接

05:28.700 --> 05:29.700
抛出一个错误

05:29.700 --> 05:30.700
它认为这个模块

05:30.700 --> 05:32.700
直接应该抛出一个错误

05:32.700 --> 05:34.700
变成这个样子

05:34.700 --> 05:35.700
听懂这个意思吗

05:35.700 --> 05:36.700
它是在这一步

05:36.700 --> 05:37.700
与法分析的时候

05:37.700 --> 05:38.700
出现了错误

05:38.700 --> 05:39.700
那么如果说

05:39.700 --> 05:40.700
假如说

05:40.700 --> 05:41.700
我们代码

05:41.700 --> 05:42.700
我就希望这样子写

05:42.700 --> 05:43.700
我不想

05:43.700 --> 05:45.700
就是用那个VAR

05:45.700 --> 05:46.700
我就想这样子写

05:46.700 --> 05:47.700
你VIPAC

05:47.700 --> 05:48.700
不是让我们代码

05:48.700 --> 05:49.700
怎么爽怎么写吗

05:49.700 --> 05:50.700
OK

05:50.700 --> 05:51.700
那你能不能解决一下呢

05:51.700 --> 05:52.700
就是把这个代码变成

05:52.700 --> 05:53.700
你自动打包的时候

05:53.700 --> 05:54.700
变成一个正确代码

05:54.700 --> 05:55.700
能不能呢

05:55.700 --> 05:56.700
VIPAC

05:56.700 --> 05:58.700
它自己不做这件事

05:58.700 --> 05:59.700
但是它提供了一个

05:59.700 --> 06:00.700
扩展机制

06:00.700 --> 06:01.700
让你来做这件事

06:01.700 --> 06:03.700
你是可以做这件事的

06:03.700 --> 06:04.700
那么怎么来

06:04.700 --> 06:05.700
做这件事呢

06:05.700 --> 06:06.700
就要使用loader

06:06.700 --> 06:07.700
loader本质上

06:07.700 --> 06:08.700
其实很简单

06:08.700 --> 06:09.700
就是一个函数

06:09.700 --> 06:10.700
它就是一个函数

06:10.700 --> 06:11.700
我们通常的

06:11.700 --> 06:12.700
把loader

06:12.700 --> 06:13.700
写到一个模块

06:13.700 --> 06:14.700
比方说我在这里

06:14.700 --> 06:15.700
建一个文件夹

06:15.700 --> 06:17.700
这里我们写上一个loader

06:17.700 --> 06:18.700
当然

06:18.700 --> 06:19.700
可以任意写到

06:19.700 --> 06:20.700
写到任何位置

06:20.700 --> 06:21.700
那么这里边

06:21.700 --> 06:22.700
它提供

06:22.700 --> 06:23.700
提供一些模块

06:23.700 --> 06:24.700
比方说我们这里

06:24.700 --> 06:26.700
用一个testloader

06:26.700 --> 06:28.700
一个测试的loader

06:28.700 --> 06:29.700
它就是一个模块

06:29.700 --> 06:30.700
那么这个模块

06:30.700 --> 06:33.700
它要导出一个函数

06:33.700 --> 06:34.700
因为模块

06:34.700 --> 06:35.700
loader本质上

06:35.700 --> 06:36.700
就是一个函数

06:36.700 --> 06:37.700
这个函数

06:37.700 --> 06:39.700
传入一个参数

06:39.700 --> 06:41.700
source code

06:41.700 --> 06:44.700
然后返回一个制幅串

06:44.700 --> 06:46.700
返回一个制幅串

06:46.700 --> 06:47.700
那么我说一下

06:47.700 --> 06:48.700
这个参数和这个返回

06:48.700 --> 06:49.700
到底是什么东西

06:49.700 --> 06:50.700
那么这个函数

06:50.700 --> 06:51.700
到时候会被

06:51.700 --> 06:52.700
微派打包过程中

06:52.700 --> 06:54.700
它会调用这个函数

06:54.700 --> 06:55.700
怎么调用呢

06:55.700 --> 06:56.700
它就会把

06:56.700 --> 06:57.700
你的原代码

06:57.700 --> 06:58.700
给你传进来

06:58.700 --> 06:59.700
作为制幅串

06:59.700 --> 07:00.700
给你传进来

07:00.700 --> 07:01.700
于是这个source code

07:01.700 --> 07:02.700
相当于是什么呢

07:02.700 --> 07:03.700
这source code

07:03.700 --> 07:05.700
相当于是

07:05.700 --> 07:06.700
我们就这个

07:06.700 --> 07:07.700
就这个东西

07:07.700 --> 07:08.700
相当于是这个东西

07:08.700 --> 07:09.700
它会把这个原代码

07:09.700 --> 07:10.700
这个制幅串给你传进来

07:10.700 --> 07:11.700
然后呢

07:11.700 --> 07:12.700
以这个函数

07:12.700 --> 07:13.700
会返回一个结果

07:13.700 --> 07:15.700
返回就是新的代码格式

07:15.700 --> 07:16.700
当然你也可以

07:16.700 --> 07:17.700
远方不动的返回

07:17.700 --> 07:18.700
都无所谓

07:18.700 --> 07:19.700
总之呢你返回一个

07:19.700 --> 07:20.700
新的代码格式

07:20.700 --> 07:22.700
那么它会把新的代码格式

07:22.700 --> 07:23.700
然后拿去

07:23.700 --> 07:25.700
做抽象与法术分析

07:25.700 --> 07:27.700
所以说我们load的位置在哪

07:27.700 --> 07:28.700
在这对吧

07:28.700 --> 07:29.700
它把文件内容读出来

07:29.700 --> 07:30.700
然后把这个

07:30.700 --> 07:32.700
文件内容传给你的函数

07:32.700 --> 07:33.700
然后呢

07:33.700 --> 07:34.700
把这个函数的返回结果

07:34.700 --> 07:36.700
拿去做抽象与法术分析

07:36.700 --> 07:37.700
那么load就是在这里

07:37.700 --> 07:39.700
进行扩展

07:39.700 --> 07:41.700
就比方说我们返回

07:41.700 --> 07:42.700
返回一个

07:42.700 --> 07:44.700
挖

07:44.700 --> 07:46.700
A等于1

07:46.700 --> 07:48.700
那么这样子一来了

07:48.700 --> 07:49.700
它就是把

07:49.700 --> 07:50.700
这个原代码

07:50.700 --> 07:51.700
是不是要转换成它了

07:51.700 --> 07:52.700
对不对

07:52.700 --> 07:54.700
那么我们现在在运行

07:54.700 --> 07:55.700
可不可以了

07:55.700 --> 07:56.700
好好想一想

07:56.700 --> 07:58.700
你觉得可不可以

07:58.700 --> 07:59.700
现在在运行

07:59.700 --> 08:00.700
可不可以了

08:00.700 --> 08:01.700
我们来试一下吧

08:01.700 --> 08:03.700
肯定是不行的

08:03.700 --> 08:05.700
但是我们load是

08:05.700 --> 08:06.700
这样子写的

08:06.700 --> 08:07.700
load确实是这样子写的

08:07.700 --> 08:08.700
没问题

08:08.700 --> 08:09.700
同样的错误

08:09.700 --> 08:10.700
对吧

08:10.700 --> 08:11.700
还是同样的错误

08:11.700 --> 08:12.700
它说你这个边

08:12.700 --> 08:13.700
识别不了

08:13.700 --> 08:14.700
为什么呢

08:14.700 --> 08:15.700
因为你这个loader

08:15.700 --> 08:16.700
没有应用进去

08:16.700 --> 08:17.700
未判的

08:17.700 --> 08:18.700
在打包的过程中

08:18.700 --> 08:19.700
它并不知道

08:19.700 --> 08:20.700
你这个地方就是个loader

08:20.700 --> 08:21.700
你这个地方

08:21.700 --> 08:22.700
不会就是一个函数

08:22.700 --> 08:24.700
它确实满足loader的协法

08:24.700 --> 08:25.700
那么loader的协法

08:25.700 --> 08:26.700
确实是满足的

08:26.700 --> 08:27.700
就是一个函数

08:27.700 --> 08:28.700
给它一个字母

08:28.700 --> 08:29.700
说它返回一个代码字母串

08:29.700 --> 08:30.700
但是它并不知道

08:30.700 --> 08:31.700
要

08:31.700 --> 08:32.700
这个函数就是loader

08:32.700 --> 08:33.700
它并不知道

08:33.700 --> 08:34.700
要去调用这个函数

08:34.700 --> 08:35.700
因为你这个代码里边

08:35.700 --> 08:36.700
你写得很

08:36.700 --> 08:37.700
你不是说

08:37.700 --> 08:38.700
这个文件夹是

08:38.700 --> 08:39.700
随便取的名字

08:39.700 --> 08:40.700
想怎么取就能取

08:40.700 --> 08:42.700
你这个loader这个模块

08:42.700 --> 08:43.700
可以放在任何地方

08:43.700 --> 08:44.700
对吧

08:44.700 --> 08:45.700
有这么多模块

08:45.700 --> 08:46.700
它怎么知道这个是loader呢

08:46.700 --> 08:47.700
所以说

08:47.700 --> 08:49.700
我们需要告诉

08:49.700 --> 08:50.700
Webpack

08:50.700 --> 08:51.700
那么这个就是我们loader

08:51.700 --> 08:52.700
那么怎么告诉呢

08:52.700 --> 08:53.700
那么Webpack又是

08:53.700 --> 08:54.700
怎么来用这个loader呢

08:54.700 --> 08:55.700
那么接下来

08:55.700 --> 08:56.700
我们来看一下

08:56.700 --> 08:58.700
它具体的过程

08:58.700 --> 08:59.700
那么之前

08:59.700 --> 09:00.700
我们试学过了

09:00.700 --> 09:01.700
Webpack的权

09:01.700 --> 09:02.700
打包的权流程

09:02.700 --> 09:04.700
已经在分析模块的时候

09:04.700 --> 09:05.700
在解析模块的时候

09:05.700 --> 09:06.700
具体流程

09:06.700 --> 09:07.700
对吧

09:07.700 --> 09:08.700
重点是

09:08.700 --> 09:09.700
现在我们放到这了

09:09.700 --> 09:10.700
就怎么来解析模块的

09:10.700 --> 09:11.700
就是在做愚法分析

09:11.700 --> 09:12.700
分析依赖

09:12.700 --> 09:13.700
然后呢

09:13.700 --> 09:15.700
把我们的代码进行转换

09:15.700 --> 09:16.700
转换过

09:16.700 --> 09:17.700
保存到一个表格里边

09:17.700 --> 09:18.700
最终会形成

09:18.700 --> 09:19.700
一个一个的模块

09:19.700 --> 09:20.700
那么

09:20.700 --> 09:21.700
然后再把这些模块

09:21.700 --> 09:22.700
打包

09:22.700 --> 09:23.700
把它

09:23.700 --> 09:24.700
捆绑在一起

09:24.700 --> 09:25.700
形成一个单独的解析文件

09:25.700 --> 09:26.700
叫做Bondle

09:26.700 --> 09:27.700
对吧

09:27.700 --> 09:28.700
那么接下来

09:28.700 --> 09:29.700
我们继续

09:29.700 --> 09:30.700
那么在打包模块的时候

09:30.700 --> 09:32.700
还有一个更详细的流程

09:32.700 --> 09:33.700
就在这一部分

09:33.700 --> 09:34.700
就是我们之前没有讲

09:34.700 --> 09:35.700
因为之前还不涉及到loader

09:35.700 --> 09:36.700
那么其实呢

09:36.700 --> 09:37.700
我们现在就可以讲了

09:37.700 --> 09:38.700
其实非常简单

09:38.700 --> 09:39.700
就改一个东西

09:39.700 --> 09:40.700
什么东西呢

09:40.700 --> 09:42.700
在读取到了文件内容之后

09:42.700 --> 09:45.700
在分析抽象愚法数之前

09:45.700 --> 09:47.700
就在这么一个位置

09:47.700 --> 09:48.700
那么这个时候呢

09:48.700 --> 09:50.700
它会处理loaders

09:50.700 --> 09:52.700
它这个时候会处理loaders

09:52.700 --> 09:54.700
那么这个时候loaders

09:54.700 --> 09:55.700
怎么处理的呢

09:55.700 --> 09:56.700
其实很简单

09:56.700 --> 09:58.700
就是整个流程的

09:58.700 --> 09:59.700
就是说

09:59.700 --> 10:00.700
我把这个文件内容给力

10:00.700 --> 10:02.700
把模块的文件内容给力

10:02.700 --> 10:04.700
然后经过这一步过后

10:04.700 --> 10:05.700
你怎么复杂

10:05.700 --> 10:07.700
怎么做了啥那些事情

10:07.700 --> 10:08.700
总之你最终

10:08.700 --> 10:10.700
要给我形成一个转换后的代码

10:10.700 --> 10:13.700
最终要形成一个转换后的代码

10:13.700 --> 10:15.700
那么形成转换后的代码过后

10:15.700 --> 10:17.700
再交给抽象愚法数来分析

10:17.700 --> 10:18.700
然后再记录一代

10:18.700 --> 10:20.700
所以在这里加了一个扩展点

10:20.700 --> 10:22.700
那么它这里怎么来处理loaders呢

10:22.700 --> 10:24.700
好 咱们来看一下

10:24.700 --> 10:27.700
其实过程也没有那么的复杂

10:27.700 --> 10:28.700
它做什么事呢

10:28.700 --> 10:30.700
它首先判断规则

10:30.700 --> 10:31.700
就是我这个模块

10:31.700 --> 10:33.700
是不是满足某个规则

10:33.700 --> 10:35.700
比方说我们这个模块是什么呢

10:35.700 --> 10:37.700
是index.js这个模块

10:37.700 --> 10:39.700
对吧 这是入口模块嘛

10:39.700 --> 10:40.700
那么这个模块

10:40.700 --> 10:43.700
是不是需要交给loader来处理呢

10:43.700 --> 10:45.700
它在做这个匹配

10:45.700 --> 10:48.700
它就有没有loader来处理这个模块

10:48.700 --> 10:50.700
有没有处理这个模块

10:50.700 --> 10:52.700
也就是说

10:52.700 --> 10:54.700
它并不是每一个模块

10:54.700 --> 10:56.700
都需要经过loader来处理

10:56.700 --> 10:58.700
并不是每一个模块都需要处理

10:58.700 --> 10:59.700
那么这个东西是可以配置的

10:59.700 --> 11:02.700
哪些模块需要经过loaders来进行处理

11:02.700 --> 11:04.700
那么它在做这个匹配

11:04.700 --> 11:07.700
那么是不是模块要经过某个规则

11:07.700 --> 11:10.700
如果这个模块不需要经过某个

11:10.700 --> 11:11.700
就是loaders

11:11.700 --> 11:13.700
OK 那么它就得到一个空速组

11:13.700 --> 11:15.700
就是loaders的空速组

11:15.700 --> 11:17.700
就是没有东西需要处理这个模块

11:17.700 --> 11:19.700
空速组以后循环的时候

11:19.700 --> 11:21.700
它自然不会做任何事情

11:21.700 --> 11:22.700
那么可以认为

11:22.700 --> 11:23.700
这个模块就是远方不动的

11:23.700 --> 11:25.700
把代码拿去分析

11:25.700 --> 11:26.700
远方不动的拿去分析

11:26.700 --> 11:27.700
像目前这样子

11:27.700 --> 11:28.700
目前就是这种情况

11:28.700 --> 11:29.700
对吧 它并不知道

11:29.700 --> 11:31.700
这个模块需要交给loader处理

11:31.700 --> 11:32.700
那么它就会

11:32.700 --> 11:34.700
loader就会形成一个空速组

11:34.700 --> 11:36.700
那么在循环这个空速组的时候

11:36.700 --> 11:37.700
它没有做任何事情

11:37.700 --> 11:38.700
因为循环进不了

11:38.700 --> 11:41.700
因此它就直接把这个圆代码拿去

11:41.700 --> 11:43.700
做愚法书分析了 能理解了

11:43.700 --> 11:46.700
好 如果说根据我们的配置

11:46.700 --> 11:47.700
这东西需要配置的

11:47.700 --> 11:48.700
我们一会讲配置

11:48.700 --> 11:50.700
那么根据这个模块的配置

11:50.700 --> 11:51.700
如果说这个模块

11:51.700 --> 11:53.700
确实需要loader来处理

11:53.700 --> 11:54.700
那么这个时候

11:54.700 --> 11:56.700
它会从规则里边

11:56.700 --> 11:57.700
也就是在配置里边

11:57.700 --> 11:59.700
读取一个loaders数组

11:59.700 --> 12:01.700
配置里边就要写一个数组

12:01.700 --> 12:04.700
就这个模块要经过哪些loaders处理

12:04.700 --> 12:06.700
那么它会形成一个loaders数组

12:06.700 --> 12:08.700
一过了我们还会再详细看这个图

12:08.700 --> 12:09.700
这个图要反复看

12:09.700 --> 12:11.700
那么形成loaders数组过后

12:11.700 --> 12:12.700
那么看下面的那张图

12:12.700 --> 12:14.700
接下来就让loaders数组里边

12:14.700 --> 12:15.700
每一个loader

12:15.700 --> 12:16.700
每一个loader是什么

12:16.700 --> 12:18.700
每一个loader就是一个函数

12:18.700 --> 12:19.700
就这么一个函数

12:19.700 --> 12:20.700
让这里边

12:20.700 --> 12:21.700
每一个loader来进行处理

12:21.700 --> 12:22.700
怎么处理呢

12:22.700 --> 12:24.700
它首先把文件内容给它

12:24.700 --> 12:26.700
你看 之前读到文件内容了

12:26.700 --> 12:28.700
把这个文件内容交给它

12:28.700 --> 12:31.700
交给数组里边最后一个loader

12:31.700 --> 12:33.700
然后它这个loader是不是

12:33.700 --> 12:35.700
返回一个新的代码

12:35.700 --> 12:36.700
把原来代码给它

12:36.700 --> 12:38.700
然后返回一个新的代码

12:38.700 --> 12:39.700
那么你又把新的代码

12:39.700 --> 12:41.700
交给上一个loader

12:41.700 --> 12:42.700
然后这个loader

12:42.700 --> 12:44.700
是不是又返回一个新的代码

12:44.700 --> 12:45.700
然后再交给上一个loader

12:45.700 --> 12:47.700
那么就是数组的第一个loader了

12:47.700 --> 12:49.700
那么它又得到一个新的代码

12:49.700 --> 12:51.700
那么它得到了最终的代码

12:51.700 --> 12:53.700
就是我们整个loader产生的原代码

12:53.700 --> 12:54.700
那么也就是说

12:54.700 --> 12:55.700
然后最后一个就是

12:55.700 --> 12:56.700
第一个loader完成过后

12:56.700 --> 12:57.700
它就得到一个最终的原代码

12:57.700 --> 12:59.700
然后再进行抽象与法术分析

12:59.700 --> 13:01.700
如果说你只有一个loader的话

13:01.700 --> 13:02.700
那也可以

13:02.700 --> 13:05.700
它是经过这么一段过程来应用loader

13:05.700 --> 13:07.700
好 那么接下来

13:07.700 --> 13:09.700
这里边说设计到了很多的配置

13:09.700 --> 13:11.700
就是说我这里要进行配置

13:11.700 --> 13:12.700
不能说

13:12.700 --> 13:14.700
它也不知道

13:14.700 --> 13:15.700
这个模块要不要交给loader

13:15.700 --> 13:16.700
要交给哪些loader

13:16.700 --> 13:18.700
因为这个loader可以写很多模块

13:18.700 --> 13:19.700
比方说这是一个loader

13:19.700 --> 13:21.700
然后再可以写一个文件

13:21.700 --> 13:23.700
来形成一个loader

13:23.700 --> 13:24.700
它并不知道要交给哪些loader

13:24.700 --> 13:27.700
因此那么这里需要配置

13:27.700 --> 13:28.700
好 那么怎么来配置呢

13:28.700 --> 13:30.700
我们首先看完整配置

13:30.700 --> 13:32.700
首先看完整配置

13:32.700 --> 13:34.700
这完整配置好像看起来比较复杂

13:34.700 --> 13:36.700
我们一块块解释就明白了

13:36.700 --> 13:37.700
这不就是配置吗

13:37.700 --> 13:39.700
伪拍的配置 你看

13:39.700 --> 13:40.700
伪拍的配置

13:40.700 --> 13:42.700
或者说我们在这

13:42.700 --> 13:43.700
不在这看吧

13:43.700 --> 13:45.700
我们在这里看

13:45.700 --> 13:47.700
那么怎么来配置loader呢

13:47.700 --> 13:48.700
首先配置这个东西

13:48.700 --> 13:49.700
marge

13:49.700 --> 13:50.700
marge就是什么 就是模块

13:50.700 --> 13:53.700
对模块怎么去解析

13:53.700 --> 13:55.700
解析的过程中要经过哪些loader

13:55.700 --> 13:57.700
那么这些就在这个地方来配置

13:57.700 --> 13:59.700
它是一个什么呢

13:59.700 --> 14:00.700
它是一个对相

14:00.700 --> 14:01.700
这个对相里面

14:01.700 --> 14:03.700
目前它只能配置两个东西

14:03.700 --> 14:06.700
一个是

14:06.700 --> 14:07.700
它是一个什么呢

14:07.700 --> 14:09.700
它是一个数组

14:09.700 --> 14:10.700
它是个数组

14:10.700 --> 14:11.700
它表示什么意思呢

14:11.700 --> 14:14.700
表示模块的匹配规则

14:14.700 --> 14:16.700
那么这个规则对应什么呢

14:16.700 --> 14:17.700
对应到这

14:17.700 --> 14:21.700
当前模块是否满足某个规则

14:21.700 --> 14:22.700
那么规则就在这

14:22.700 --> 14:24.700
它有很多规则可以配置

14:24.700 --> 14:25.700
那么规则就在这

14:25.700 --> 14:27.700
以后我们再继续详细些

14:27.700 --> 14:28.700
还有一个配置呢

14:28.700 --> 14:29.700
是我们以后要说的

14:29.700 --> 14:30.700
现在我们不管

14:30.700 --> 14:33.700
叫做low pause

14:33.700 --> 14:34.700
是否

14:34.700 --> 14:35.700
它表示什么意思呢

14:35.700 --> 14:40.700
是否不要解析某个模块

14:40.700 --> 14:42.700
某个模块

14:42.700 --> 14:43.700
这个我们以后再说

14:43.700 --> 14:44.700
就是它里面有两个配置

14:44.700 --> 14:45.700
这个东西我们以后再说

14:45.700 --> 14:46.700
现在不用管

14:46.700 --> 14:48.700
那么我们现在只关注这个

14:48.700 --> 14:50.700
模块的匹配规则

14:51.700 --> 14:52.700
规则有很多个

14:52.700 --> 14:53.700
并不是只有一个

14:53.700 --> 14:54.700
那么它会把这个规则

14:54.700 --> 14:55.700
全部读出来

14:55.700 --> 14:56.700
一个一个看

14:56.700 --> 14:58.700
我模块是不是满足

14:58.700 --> 14:59.700
第一个规则

15:01.700 --> 15:02.700
规则1

15:03.700 --> 15:04.700
规则1

15:04.700 --> 15:05.700
还有一个规则2

15:05.700 --> 15:06.700
那么它怎么来看呢

15:06.700 --> 15:07.700
它首先看

15:07.700 --> 15:09.700
能不能满足规则1呢

15:09.700 --> 15:11.700
它实际上是这样看的

15:11.700 --> 15:13.700
它从下往上看的

15:13.700 --> 15:14.700
满足规则2

15:14.700 --> 15:16.700
满足规则1

15:16.700 --> 15:18.700
它是这样子来看的

15:18.700 --> 15:19.700
从后边往前面看

15:19.700 --> 15:20.700
如果满足规则2

15:20.700 --> 15:21.700
OK

15:21.700 --> 15:22.700
那么我们就使用

15:22.700 --> 15:23.700
规则2里面的东西

15:23.700 --> 15:25.700
匹配的东西来进行

15:25.700 --> 15:27.700
来进行读寻

15:27.700 --> 15:28.700
楼导式数数

15:28.700 --> 15:29.700
然后呢

15:29.700 --> 15:30.700
是不是满足规则1呢

15:30.700 --> 15:31.700
如果满足规则1

15:31.700 --> 15:32.700
它也使用规则1中

15:32.700 --> 15:34.700
对你的楼导式来处理

15:34.700 --> 15:35.700
就这么一回事

15:35.700 --> 15:37.700
那么这里就写规则

15:37.700 --> 15:38.700
那每一个规则是什么呢

15:38.700 --> 15:39.700
每一个规则

15:39.700 --> 15:40.700
实际上就是个对象

15:41.700 --> 15:42.700
每一个规则

15:42.700 --> 15:43.700
就是个对象

15:43.700 --> 15:47.660
这个东西你一开始肯定

15:47.660 --> 15:48.660
觉得好绕

15:48.660 --> 15:49.660
好不太熟悉

15:49.660 --> 15:50.660
你多去想

15:50.660 --> 15:51.660
而且呢

15:51.660 --> 15:52.660
我们后边呢

15:52.660 --> 15:53.660
要经常用到这个东西

15:53.660 --> 15:54.660
慢慢就熟悉了

15:54.660 --> 15:55.660
没关系

15:55.660 --> 15:56.660
这个东西是一点点来的

15:56.660 --> 15:57.660
规则1规则2

15:57.660 --> 15:58.660
每个规则就是个对象

15:58.660 --> 15:59.660
好那么比方说

15:59.660 --> 16:00.660
我们现在只皮

16:00.660 --> 16:01.660
只有一个规则

16:01.660 --> 16:02.660
只有一个规则

16:02.660 --> 16:03.660
那不是

16:03.660 --> 16:04.660
只有一个对象

16:04.660 --> 16:05.660
对吧

16:05.660 --> 16:07.660
好那么规则里面写什么呢

16:07.660 --> 16:08.660
规则里面写什么呢

16:08.660 --> 16:10.660
规则里面叫你去匹配了

16:10.660 --> 16:11.660
首先是规则

16:11.660 --> 16:12.660
一个TES这个属性

16:12.660 --> 16:13.660
这个东西是什么呢

16:13.660 --> 16:14.660
是一个正则表达式

16:15.660 --> 16:17.660
正则表达式

16:17.660 --> 16:18.660
匹配什么呢

16:18.660 --> 16:19.660
匹配模块的路径

16:19.660 --> 16:20.660
模块的路径

16:20.660 --> 16:22.660
匹配模块的路径

16:22.660 --> 16:23.660
它会把模块的路径

16:23.660 --> 16:24.660
拿去跟这个

16:24.660 --> 16:25.660
正则表达式进行匹配

16:25.660 --> 16:27.660
比方说像这个入口文件

16:27.660 --> 16:28.660
index了ges

16:28.660 --> 16:29.660
它的路径是什么

16:29.660 --> 16:30.660
它的路径就是

16:30.660 --> 16:31.660
第二鞋杠

16:31.660 --> 16:32.660
src

16:32.660 --> 16:33.660
index了ges

16:33.660 --> 16:34.660
就是它的路径

16:34.660 --> 16:36.660
相当于就是模块ID

16:36.660 --> 16:37.660
那么这个东西

16:37.660 --> 16:38.660
词本拿去

16:38.660 --> 16:39.660
跟这个正则表达式

16:39.660 --> 16:40.660
来匹配

16:40.660 --> 16:41.660
看能不能匹配上

16:41.660 --> 16:42.660
如果说能匹配上的话

16:42.660 --> 16:43.660
OK那么这个模块

16:43.660 --> 16:45.660
就要使用

16:45.660 --> 16:47.660
对应的loaders

16:47.660 --> 16:48.660
就这么简单

16:48.660 --> 16:49.660
就这么简单

16:49.660 --> 16:50.660
就这么简单

16:50.660 --> 16:51.660
好那么这里

16:51.660 --> 16:52.660
test

16:52.660 --> 16:53.660
就是一个正则表达式

16:53.660 --> 16:54.660
正则表达式怎么简单

16:54.660 --> 16:55.660
我们就可以直接写上一个

16:56.660 --> 16:57.660
index

16:57.660 --> 16:58.660
鞋杠点

16:58.660 --> 16:59.660
ges

16:59.660 --> 17:00.660
就相当于这样写

17:00.660 --> 17:01.660
然后结束

17:01.660 --> 17:02.660
结束

17:02.660 --> 17:03.660
就是字不说结束

17:04.660 --> 17:05.660
好那么这样子

17:05.660 --> 17:06.660
是不是就是匹配什么

17:06.660 --> 17:07.660
匹配index

17:07.660 --> 17:08.660
后边的

17:08.660 --> 17:09.660
这个要转移

17:09.660 --> 17:10.660
不然点的话

17:10.660 --> 17:11.660
在正则表达式里

17:11.660 --> 17:12.660
唯有特殊的含义

17:12.660 --> 17:13.660
那么就表示我要匹配

17:13.660 --> 17:14.660
什么index.ges

17:14.660 --> 17:16.660
说要匹配这样的模块

17:16.660 --> 17:17.660
好匹配到了过后

17:17.660 --> 17:18.660
你要告诉他

17:18.660 --> 17:19.660
这个匹配到了过后

17:19.660 --> 17:20.660
你要应用的哪些loaders

17:20.660 --> 17:22.660
就是你要应用哪些

17:22.660 --> 17:23.660
加载器

17:23.660 --> 17:25.660
那么这个东西怎么来使用

17:25.660 --> 17:27.660
后面还有个属性

17:27.660 --> 17:28.660
叫做use

17:28.660 --> 17:29.660
使用

17:29.660 --> 17:30.660
是不是很好理解

17:30.660 --> 17:31.660
使用什么

17:31.660 --> 17:32.660
一个数组

17:32.660 --> 17:35.660
匹配到了之后

17:35.660 --> 17:39.660
使用哪些加载器

17:39.660 --> 17:40.660
使用哪些加载器

17:40.660 --> 17:41.660
使用哪些loaders

17:41.660 --> 17:43.660
就这么个意思

17:43.660 --> 17:44.660
能理解吗

17:44.660 --> 17:46.660
我这里有很多的规则

17:46.660 --> 17:48.660
那么他去首先看一下

17:48.660 --> 17:49.660
他就去读取

17:49.660 --> 17:50.660
一个一个的规则对象

17:50.660 --> 17:52.660
看一下有没有哪个规则

17:52.660 --> 17:54.660
能匹配到我这个模块的

17:54.660 --> 17:55.660
他怎么来匹配的

17:55.660 --> 17:56.660
对每一个规则使用

17:56.660 --> 17:58.660
把路径跟这个正的表达式

17:58.660 --> 17:59.660
拿去匹配

17:59.660 --> 18:00.660
那么如果说匹配到了

18:00.660 --> 18:01.660
ok

18:01.660 --> 18:02.660
那么就表示这个模块

18:02.660 --> 18:04.660
是需要使用那个规则的

18:04.660 --> 18:06.660
是需要使用这个规则的

18:06.660 --> 18:07.660
能理解吗

18:07.660 --> 18:08.660
那么需要使用那个规则

18:08.660 --> 18:09.660
ok

18:09.660 --> 18:10.660
use

18:10.660 --> 18:11.660
那么这里边

18:11.660 --> 18:13.660
他就会匹用对应的规则

18:13.660 --> 18:15.660
好那么对应的规则里边

18:15.660 --> 18:16.660
每一个数组里面

18:16.660 --> 18:17.660
每一个像是什么呢

18:17.660 --> 18:18.660
每一个像

18:18.660 --> 18:21.660
就表示要使用的夹展器

18:21.660 --> 18:23.660
每一个像就是一个对象

18:23.660 --> 18:24.660
就是要用哪

18:24.660 --> 18:26.660
这里表示要用哪些夹展器

18:26.660 --> 18:28.660
每个夹展器就是一个对象

18:28.660 --> 18:29.660
好

18:29.660 --> 18:33.660
每个夹展器

18:33.660 --> 18:35.660
器的使用

18:35.660 --> 18:38.660
是一个对象

18:38.660 --> 18:40.660
那么对象里面有写什么呢

18:40.660 --> 18:42.660
又写loader

18:42.660 --> 18:43.660
表示什么意思呢

18:43.660 --> 18:47.660
表示夹展器的路径

18:47.660 --> 18:48.660
路径

18:48.660 --> 18:49.660
那么这个

18:49.660 --> 18:50.660
比方说我们这里可以怎么写呢

18:50.660 --> 18:51.660
我夹展器在哪

18:51.660 --> 18:53.660
夹展器在loader

18:53.660 --> 18:56.660
史目录下面的testloader

18:56.660 --> 18:58.660
就这么简单

18:58.660 --> 18:59.660
是不是一个夹展器

18:59.660 --> 19:00.660
对吧一个夹展器

19:00.660 --> 19:02.660
在这里面就可以这样子写

19:02.660 --> 19:03.660
夹展器的路径

19:03.660 --> 19:04.660
那么这个路径

19:04.660 --> 19:05.660
他到时候呢

19:05.660 --> 19:06.660
他怎么来把loader夹展出来呢

19:06.660 --> 19:07.660
非常简单

19:07.660 --> 19:08.660
他就用这种方式

19:08.660 --> 19:10.660
他到时候就用一个require

19:10.660 --> 19:12.660
他到时候就会用的内部

19:12.660 --> 19:13.660
他就会用一个require

19:13.660 --> 19:15.660
直接把你一个路径包含进去

19:15.660 --> 19:17.660
是不是就可以把loader夹展出来了

19:17.660 --> 19:18.660
对吧

19:18.660 --> 19:19.660
直接把loader

19:19.660 --> 19:20.660
导出的东西就夹展出来了

19:20.660 --> 19:21.660
你不用写

19:21.660 --> 19:23.660
这个东西你只需要写一个路径就行了

19:23.660 --> 19:24.660
他自动会

19:24.660 --> 19:25.660
自己在后边

19:25.660 --> 19:26.660
会使用require

19:26.660 --> 19:28.660
把loader夹展出来

19:28.660 --> 19:29.660
好

19:29.660 --> 19:30.660
夹展出来过后呢

19:30.660 --> 19:31.660
那就很简单了

19:31.660 --> 19:32.660
他就会经过这么一个过程

19:32.660 --> 19:33.660
他放到这个数组里边

19:33.660 --> 19:34.660
然后代码给他

19:34.660 --> 19:36.660
然后运行这个loader函数

19:36.660 --> 19:39.660
然后loader就把这个东西输出

19:39.660 --> 19:40.660
没问题吧

19:40.660 --> 19:41.660
好那么这里呢

19:41.660 --> 19:43.660
这样子写了之后

19:43.660 --> 19:45.660
就写完了

19:45.660 --> 19:46.660
就写完了

19:46.660 --> 19:47.660
那咱们来试一下吧

19:47.660 --> 19:49.660
再试一下

19:51.660 --> 19:52.660
好

19:52.660 --> 19:53.660
现在呢我们再来看

19:54.660 --> 19:55.660
打包

19:56.660 --> 19:58.660
没爆错了看了没

19:58.660 --> 19:59.660
是没爆错了

19:59.660 --> 20:01.660
没爆错了过后呢你看

20:01.660 --> 20:03.660
我们这个函数

20:04.660 --> 20:06.660
反而回到是这个varA等于1

20:06.660 --> 20:08.660
那么我们看最终的打包结果

20:09.660 --> 20:11.660
你看是varA等于1

20:11.660 --> 20:12.660
对吧

20:12.660 --> 20:13.660
这就是打包结果

20:13.660 --> 20:14.660
怎么说的呢

20:14.660 --> 20:15.660
我们再来看一下

20:15.660 --> 20:16.660
再来看一下

20:16.660 --> 20:17.660
我们看他整个的过程

20:17.660 --> 20:18.660
处理的

20:18.660 --> 20:20.660
那么把文件内容读出来过后

20:20.660 --> 20:22.660
把模块的文件内容读出来过后

20:22.660 --> 20:24.660
然后接下来处理loader

20:24.660 --> 20:26.660
处理什么夹展器怎么处理的

20:26.660 --> 20:28.660
首先从配置里边去看

20:28.660 --> 20:30.660
我这个模块满不满住模块

20:30.660 --> 20:31.660
我这个模块是这个模块

20:31.660 --> 20:32.660
它满不满住模块

20:32.660 --> 20:33.660
来一个个看

20:33.660 --> 20:35.660
那么整个规则数组里边

20:35.660 --> 20:37.660
目前只有一个对象

20:37.660 --> 20:38.660
只有一个对象

20:38.660 --> 20:39.660
就是只有一个规则

20:39.660 --> 20:40.660
它就把一个对象的test

20:40.660 --> 20:41.660
属性读出来

20:41.660 --> 20:42.660
读出来看一下

20:42.660 --> 20:44.660
我这个模块路径

20:44.660 --> 20:46.660
去用这个证则表达

20:46.660 --> 20:48.660
是去调用一下test

20:48.660 --> 20:50.660
看能不能匹配到我这个东西

20:50.660 --> 20:51.660
我这个模块路径

20:51.660 --> 20:52.660
能不能匹配到

20:52.660 --> 20:53.660
发现它可以匹配到

20:53.660 --> 20:55.660
那么是不是就可以

20:55.660 --> 20:57.660
把这个东西夹展出来

20:57.660 --> 20:58.660
这个东西

20:58.660 --> 20:59.660
每一个loader就拿到了

20:59.660 --> 21:00.660
所以把每一个loader就拿到了

21:00.660 --> 21:02.660
这里可能有很多个loader

21:02.660 --> 21:03.660
那么这儿

21:03.660 --> 21:04.660
是不是就把loader的

21:04.660 --> 21:05.660
放到一个数组里边

21:05.660 --> 21:06.660
对吧

21:06.660 --> 21:07.660
那么接下来

21:07.660 --> 21:08.660
它就把文件内容

21:08.660 --> 21:09.660
之前读出来的文件内容

21:09.660 --> 21:10.660
交给这个loader

21:10.660 --> 21:11.660
当然我们这里只有一个

21:11.660 --> 21:12.660
交给这个loader

21:12.660 --> 21:13.660
然后这个loader

21:13.660 --> 21:14.660
会返回一个结果

21:14.660 --> 21:16.660
返回一个字幕刷

21:16.660 --> 21:17.660
那么这个字幕刷

21:17.660 --> 21:18.660
它会把这个新的字幕刷

21:18.660 --> 21:19.660
作为圆码

21:19.660 --> 21:20.660
又交给抽象与法术分析

21:20.660 --> 21:21.660
对吧

21:21.660 --> 21:22.660
可以把它作为圆码

21:22.660 --> 21:23.660
又交给这个

21:23.660 --> 21:24.660
抽象与法术

21:24.660 --> 21:25.660
进行分析

21:25.660 --> 21:27.660
把这种返回来圆码

21:27.660 --> 21:29.660
那比方说我这里

21:29.660 --> 21:30.660
再换一个

21:30.660 --> 21:32.660
我把它写成这种

21:32.660 --> 21:34.660
console.log

21:34.660 --> 21:35.660
123

21:35.660 --> 21:36.660
可不可以

21:36.660 --> 21:37.660
当然可以

21:37.660 --> 21:38.660
我们来看一下

21:38.660 --> 21:41.480
打包

21:41.480 --> 21:42.480
那么给你看一下

21:42.480 --> 21:43.480
所以变成这个东西了

21:43.480 --> 21:44.480
对吧

21:44.480 --> 21:45.480
所以说

21:45.480 --> 21:46.480
它loader

21:46.480 --> 21:47.480
它就起到一个什么作用

21:47.480 --> 21:48.480
它可以改动圆码

21:48.480 --> 21:49.480
它可以把我们圆码

21:49.480 --> 21:50.480
变化

21:50.480 --> 21:52.480
变成任何我们想要的形式

21:52.480 --> 21:53.480
比方说我这里

21:53.480 --> 21:54.480
可以完全可以

21:54.480 --> 21:55.480
这样子写

21:55.480 --> 21:56.480
你看着

21:56.480 --> 21:58.480
我们这里还可以输出

21:58.480 --> 22:00.480
loader1

22:00.480 --> 22:02.480
运行了

22:02.480 --> 22:04.480
loader

22:04.480 --> 22:06.480
这个把它叫做Test

22:06.480 --> 22:09.480
loader运行了

22:09.480 --> 22:10.480
那么这里

22:10.480 --> 22:11.480
我们返

22:11.480 --> 22:12.480
我们返回什么

22:12.480 --> 22:13.480
我们就把圆码里

22:13.480 --> 22:14.480
把所有的变量

22:14.480 --> 22:15.480
这两个字改成VAR

22:15.480 --> 22:16.480
你看着

22:16.480 --> 22:17.480
我们关键可以用

22:17.480 --> 22:18.480
这么的表达是

22:18.480 --> 22:19.480
你看

22:19.480 --> 22:21.480
source code replace

22:21.480 --> 22:22.480
对吧

22:22.480 --> 22:23.480
它是个置物串

22:23.480 --> 22:24.480
我们用置物串处理

22:24.480 --> 22:26.480
用一个全局的匹配

22:26.480 --> 22:28.480
把变量这两个字

22:28.480 --> 22:29.480
变成什么

22:29.480 --> 22:31.480
变成VAR

22:31.480 --> 22:32.480
变成VAR

22:32.480 --> 22:33.480
好

22:33.480 --> 22:34.480
接下来我们来看一下

22:34.480 --> 22:40.310
好

22:40.310 --> 22:41.310
再来我们来看

22:41.310 --> 22:46.570
你看

22:46.570 --> 22:47.570
Test loader运行了

22:47.570 --> 22:48.570
对吧

22:48.570 --> 22:49.570
它是不是真的运行了

22:49.570 --> 22:50.570
这个函数

22:50.570 --> 22:51.570
然后我们看最终结果

22:51.570 --> 22:52.570
变成VAR了

22:52.570 --> 22:53.570
那这样子

22:53.570 --> 22:55.570
里面就可以随便写了

22:55.570 --> 22:56.570
再来一个

22:56.570 --> 22:59.570
变量B等于3

22:59.570 --> 23:00.570
你看一下

23:00.570 --> 23:01.570
它能让能够转换

23:01.570 --> 23:02.570
因为我们是

23:02.570 --> 23:03.570
把这个置物串

23:03.570 --> 23:04.570
它其实就是一个置物串

23:04.570 --> 23:05.570
交给loader的

23:05.570 --> 23:06.570
就是把这个东西

23:06.570 --> 23:07.570
置物串交给它

23:07.570 --> 23:08.570
OK 没问题

23:08.570 --> 23:09.570
你看

23:09.570 --> 23:10.570
VARA等于1

23:10.570 --> 23:11.570
VARB等于3

23:11.570 --> 23:12.570
就形成了这么一个效果

23:12.570 --> 23:13.570
这就是loader

23:13.570 --> 23:14.570
特别简单

23:14.570 --> 23:15.570
它就是把一个代码

23:15.570 --> 23:16.570
变成另一个代码

23:16.570 --> 23:17.570
如果说你对这些

23:17.570 --> 23:19.570
整个流程的话

23:19.570 --> 23:20.570
认识的

23:20.570 --> 23:21.570
就是模模糊糊

23:21.570 --> 23:22.570
那么下来多去想一想

23:22.570 --> 23:24.570
但是你一定要理解

23:24.570 --> 23:26.570
就是loader其实特别简单

23:26.570 --> 23:27.570
它就是把一个代码

23:27.570 --> 23:28.570
变成另一个代码

23:28.570 --> 23:30.570
然后经过一些配置

23:30.570 --> 23:31.570
你就可以把loader

23:31.570 --> 23:32.570
应用进去了

23:32.570 --> 23:34.570
经过这些配置

23:34.570 --> 23:35.570
好 接下来

23:35.570 --> 23:36.570
我们再来看

23:37.570 --> 23:39.570
那么如果说

23:39.570 --> 23:41.570
如果说loader

23:41.570 --> 23:43.570
它如果说还可以

23:43.570 --> 23:44.570
就是在运行

23:44.570 --> 23:45.570
这个函数的时候

23:45.570 --> 23:46.570
它还可以给它一些

23:46.570 --> 23:47.570
额外的信息

23:47.570 --> 23:48.570
比方说

23:48.570 --> 23:49.570
我不一定改变的是

23:49.570 --> 23:50.570
这两个字

23:50.570 --> 23:51.570
我可能改变的是

23:51.570 --> 23:52.570
别的两个字

23:52.570 --> 23:54.570
不知道大家懂不懂

23:54.570 --> 23:55.570
我一个意思

23:55.570 --> 23:56.570
我改变的是可能是

23:56.570 --> 23:57.570
别的两个字

23:57.570 --> 23:58.570
不是要把变量变成VAR

23:58.570 --> 23:59.570
而是要把

23:59.570 --> 24:00.570
另外一个比方说

24:00.570 --> 24:01.570
耐扯变成VAR

24:01.570 --> 24:02.570
那么到底

24:02.570 --> 24:04.570
把什么东西变成VAR

24:04.570 --> 24:05.570
那么这里

24:05.570 --> 24:08.570
你可以给loader写参数

24:08.570 --> 24:09.570
参数怎么写

24:09.570 --> 24:10.570
Options

24:11.570 --> 24:12.570
就是参数

24:12.570 --> 24:13.570
每一个loader

24:13.570 --> 24:14.570
它每一个loader

24:14.570 --> 24:15.570
它会对应一些参数

24:15.570 --> 24:16.570
当然你没有参数的话

24:16.570 --> 24:17.570
就不用写

24:17.570 --> 24:18.570
那么怎么来写

24:18.570 --> 24:19.570
Options

24:19.570 --> 24:20.570
我们就可以这样子

24:20.570 --> 24:21.570
这个东西自行规定的

24:21.570 --> 24:22.570
自行规定

24:22.570 --> 24:23.570
比方说我们这里

24:23.570 --> 24:24.570
就写上

24:25.570 --> 24:26.570
Change

24:27.570 --> 24:28.570
VAR

24:28.570 --> 24:29.570
把什么东西变成VAR

24:29.570 --> 24:31.570
比方说我们把这个

24:33.570 --> 24:34.570
位置数

24:34.570 --> 24:35.570
把这三个字

24:35.570 --> 24:36.570
把这三个字

24:36.570 --> 24:37.570
要变成VAR关键字

24:37.570 --> 24:39.570
所以说我们这里

24:39.570 --> 24:40.570
loader里面

24:40.570 --> 24:41.570
它就不是只固定的

24:41.570 --> 24:42.570
把变量变成VAR了

24:42.570 --> 24:43.570
而是什么

24:43.570 --> 24:45.570
把它传过来这个东西

24:45.570 --> 24:46.570
用传过来这个东西

24:46.570 --> 24:47.570
来去匹配

24:47.570 --> 24:48.570
把它变成VAR

24:48.570 --> 24:49.570
那么这样子

24:49.570 --> 24:50.570
问题在哪来了

24:50.570 --> 24:52.570
我们这里怎么来获得

24:52.570 --> 24:54.570
它传过来这个东西呢

24:54.570 --> 24:55.570
怎么来获得呢

24:55.570 --> 24:56.570
你这里

24:56.570 --> 24:57.570
实际上

24:57.570 --> 24:58.570
我给他说一下

24:58.570 --> 25:00.570
这个我们了解就行了

25:00.570 --> 25:01.570
你在这个参数里面

25:01.570 --> 25:02.570
获取不到

25:02.570 --> 25:03.570
获取不到这个配

25:03.570 --> 25:05.570
就是个这里的Options

25:05.570 --> 25:06.570
获取不到的

25:06.570 --> 25:07.570
那么在哪里获取呢

25:07.570 --> 25:08.570
要在Z里面获取

25:08.570 --> 25:10.570
在运行loader函数的时候

25:10.570 --> 25:11.570
它会绑定一个Z

25:11.570 --> 25:12.570
这个Z叫做

25:12.570 --> 25:13.570
上下文

25:13.570 --> 25:14.570
这个了解就行了

25:14.570 --> 25:15.570
这个东西

25:15.570 --> 25:16.570
要受到很深的东西了

25:16.570 --> 25:18.570
在VPAC打包过程中

25:18.570 --> 25:19.570
它会形成一个上下文

25:19.570 --> 25:20.570
它会形成一个上下文对象

25:20.570 --> 25:21.570
这个对象里面

25:21.570 --> 25:22.570
有很多很多东西

25:22.570 --> 25:23.570
超级多

25:23.570 --> 25:24.570
我们来看一下

25:26.570 --> 25:28.570
那么现在我们输出Z

25:28.570 --> 25:29.570
VPAC运行

25:30.570 --> 25:31.570
这不是爆错

25:31.570 --> 25:32.570
你看我正确打包了

25:32.570 --> 25:33.570
那么前面

25:33.570 --> 25:34.570
是我们loader里面的输出

25:34.570 --> 25:35.570
你看这里面

25:35.570 --> 25:37.570
东西是不是特别特别多

25:37.570 --> 25:38.570
而且你会看到

25:38.570 --> 25:40.570
loader是在这里面

25:40.570 --> 25:41.570
配置里面

25:41.570 --> 25:43.570
是不是给拿到配置里面的Options

25:43.570 --> 25:44.570
那么这样去拿的话

25:44.570 --> 25:45.570
太不方便了

25:45.570 --> 25:46.570
因此我们往往

25:46.570 --> 25:48.570
如果说你自己写loader的话

25:48.570 --> 25:50.570
我其实讲这些课的目的

25:50.570 --> 25:51.570
也不是说

25:51.570 --> 25:52.570
要让大家以后

25:52.570 --> 25:53.570
去自己去写loader

25:53.570 --> 25:55.570
实际上你们以后在开发中

25:56.570 --> 25:58.570
不会去自己写loader

25:59.570 --> 26:00.570
能力还不够

26:00.570 --> 26:01.570
可能要开发很多的

26:01.570 --> 26:02.570
两个经验过后

26:02.570 --> 26:04.570
你可能还去写这些底层的东西

26:04.570 --> 26:05.570
不过我这些课

26:05.570 --> 26:06.570
主要是让大家

26:06.570 --> 26:07.570
认识这个loader

26:07.570 --> 26:08.570
其实它并不复杂

26:08.570 --> 26:09.570
就是一个代码给我

26:09.570 --> 26:10.570
我给你返回一个新的代码

26:10.570 --> 26:11.570
那么现在的问题

26:11.570 --> 26:12.570
关键是在于

26:12.570 --> 26:13.570
我们在如何在loader里面

26:13.570 --> 26:15.570
去得到这个Options

26:15.570 --> 26:16.570
去得到这个玩意

26:16.570 --> 26:17.570
它传过来这个东西

26:17.570 --> 26:18.570
因为我要把传过来

26:18.570 --> 26:19.570
这个圈级碗

26:19.570 --> 26:20.570
变成了

26:20.570 --> 26:21.570
变成这个碗

26:21.570 --> 26:22.570
因此我怎么得到呢

26:22.570 --> 26:23.570
我们可以

26:23.570 --> 26:25.570
最终得到的位置

26:25.570 --> 26:26.570
肯定是在这次里面

26:26.570 --> 26:27.570
只不过这次里面

26:27.570 --> 26:28.570
东西太多了

26:28.570 --> 26:29.570
也特别难以分析

26:29.570 --> 26:31.570
因此有一个第三方库

26:31.570 --> 26:33.570
他能够帮助我们

26:34.570 --> 26:37.570
来解析这个Options

26:37.570 --> 26:38.570
哪个第三方库呢

26:38.570 --> 26:39.570
第三方库的名字

26:39.570 --> 26:40.570
我给大家这个东西

26:40.570 --> 26:41.570
了解就行了

26:41.570 --> 26:42.570
了解就行了

26:42.570 --> 26:43.570
看个这了

26:43.570 --> 26:44.570
这三方库的名字

26:44.570 --> 26:45.570
叫做这个

26:45.570 --> 26:47.570
安装一下

26:47.570 --> 26:49.570
NPMI 很刚的

26:49.570 --> 26:51.570
那么这里的第三方库叫做

26:51.570 --> 26:53.570
loader

26:53.570 --> 26:55.570
Utos

26:55.570 --> 26:56.570
Utos

26:56.570 --> 26:57.570
就这个第三方库

26:57.570 --> 26:58.570
就是

26:58.570 --> 26:59.570
对loader的

26:59.570 --> 27:01.570
loader的就是一个工具包

27:01.570 --> 27:02.570
一个工具包

27:02.570 --> 27:03.570
安装

27:03.570 --> 27:04.570
安装好了之后

27:04.570 --> 27:05.570
这里面

27:05.570 --> 27:07.570
我们就可以用require

27:07.570 --> 27:09.570
然后loader

27:09.570 --> 27:11.570
Utos

27:12.570 --> 27:13.570
拿过来

27:13.570 --> 27:15.570
拿过来是一个对象

27:15.570 --> 27:17.570
loader

27:17.570 --> 27:18.570
Utos

27:18.570 --> 27:19.570
拿过来是个对象

27:19.570 --> 27:20.570
那么这个对象

27:20.570 --> 27:22.570
它里面提供了一个方法

27:22.570 --> 27:23.570
什么方法呢

27:23.570 --> 27:24.570
叫getOptions

27:24.570 --> 27:26.570
得到一个Options配置

27:26.570 --> 27:27.570
把什么传进去

27:27.570 --> 27:28.570
把ZS传进去

27:28.570 --> 27:29.570
把上下文传进去

27:29.570 --> 27:32.570
那么它会返回一个Options

27:32.570 --> 27:34.570
输出Options

27:34.570 --> 27:35.570
来看

27:35.570 --> 27:36.570
现在我们再看一下

27:36.570 --> 27:37.570
不靠

27:37.570 --> 27:39.570
还没下载完

27:39.570 --> 27:40.570
等一下

27:40.570 --> 27:42.570
OK 下载完了

27:42.570 --> 27:45.570
好 那么接下来

27:45.570 --> 27:49.570
这里用npxwebpack

27:49.570 --> 27:50.570
打包

27:50.570 --> 27:51.570
来看

27:51.570 --> 27:52.570
现在我们输出了Options

27:52.570 --> 27:53.570
在打包过程中

27:53.570 --> 27:55.570
看到没

27:55.570 --> 27:56.570
是不是得到了

27:56.570 --> 27:58.570
得到这个Options对象了

27:58.570 --> 27:59.570
那么这里面

27:59.570 --> 28:00.570
我们是可以读取到对象里面的

28:00.570 --> 28:01.570
千几万

28:01.570 --> 28:03.570
是可以读取到千几万

28:03.570 --> 28:04.570
千几万

28:04.570 --> 28:06.570
来 再打包看一下

28:06.570 --> 28:10.100
读取到什么

28:10.100 --> 28:11.100
这位置是说

28:11.100 --> 28:12.100
就把它读出来了

28:12.100 --> 28:13.100
那读出来还不好说吗

28:13.100 --> 28:14.100
接下来

28:14.100 --> 28:16.100
我们来得到一个什么

28:16.100 --> 28:17.100
得到一个这么的表达式

28:17.100 --> 28:18.100
这么的表达式

28:18.100 --> 28:20.100
reg

28:20.100 --> 28:21.100
一个reg

28:21.100 --> 28:22.100
expression

28:22.100 --> 28:24.100
然后把这么的表达式的内容

28:24.100 --> 28:25.100
传进去

28:25.100 --> 28:26.100
就匹配它

28:26.100 --> 28:28.100
然后flex传一个

28:28.100 --> 28:29.100
g

28:29.100 --> 28:30.100
全具匹配

28:30.100 --> 28:31.100
匹配它

28:31.100 --> 28:32.100
全具匹配

28:32.100 --> 28:33.100
然后

28:33.100 --> 28:35.100
接下来是不是就replace

28:35.100 --> 28:37.100
source code

28:37.100 --> 28:38.100
replace

28:38.100 --> 28:40.100
然后把这么的表达式

28:40.100 --> 28:41.100
传进去

28:41.100 --> 28:42.100
变成什么了

28:42.100 --> 28:43.100
那么这样子

28:43.100 --> 28:44.100
我们这个

28:44.100 --> 28:46.100
加载器是不是更加灵活了

28:46.100 --> 28:47.100
是不是更加灵活了

28:47.100 --> 28:49.100
我们把这个Options输出

28:49.100 --> 28:51.100
Options输出

28:51.100 --> 28:53.100
就更加灵活了

28:53.100 --> 28:54.100
你看

28:54.100 --> 28:55.100
我们现在到index里

28:55.100 --> 28:56.100
就是比方说

28:56.100 --> 28:57.100
以后不像用变量这两个字

28:57.100 --> 28:58.100
我想用位置数

28:58.100 --> 29:00.100
数学里面的位置数

29:02.100 --> 29:04.100
位置数

29:04.100 --> 29:05.100
那么这样子写

29:05.100 --> 29:06.100
能不能转换了

29:06.100 --> 29:10.200
你看着

29:10.200 --> 29:11.200
OK

29:11.200 --> 29:12.200
也能转换

29:12.200 --> 29:13.200
你看

29:13.200 --> 29:14.200
转换的结果

29:14.200 --> 29:15.200
是不是变成挖了

29:15.200 --> 29:16.200
那么这样子

29:16.200 --> 29:17.200
就高度可配了

29:17.200 --> 29:18.200
就不说我们以后

29:18.200 --> 29:19.200
为不同的东西

29:19.200 --> 29:20.200
都要去写个loader

29:20.200 --> 29:21.200
就可以

29:21.200 --> 29:22.200
把有些功能相似的loader

29:22.200 --> 29:24.200
就可以通过参数来进行配置

29:24.200 --> 29:25.200
就这么个意思

29:25.200 --> 29:26.200
当然这里还可以加一些

29:26.200 --> 29:27.200
其他参数

29:27.200 --> 29:28.200
就说这么个意思有效

29:28.200 --> 29:29.200
那么在loader里面

29:29.200 --> 29:30.200
是可以写参数的

29:30.200 --> 29:32.200
就这么个意思

29:32.200 --> 29:33.200
那么这个参数

29:33.200 --> 29:35.200
除了往这里加

29:35.200 --> 29:37.200
这里加是比较完整的写法

29:37.200 --> 29:38.200
其他还可以往哪里加呢

29:38.200 --> 29:40.200
还可以往这里加

29:40.200 --> 29:41.200
往这里加

29:41.200 --> 29:42.200
这里怎么加呢

29:42.200 --> 29:43.200
这里我们使用

29:43.200 --> 29:44.200
query这种形式

29:44.200 --> 29:45.200
它也能读出来

29:45.200 --> 29:46.200
也能读出来

29:46.200 --> 29:48.200
就通过这个UTO的话

29:48.200 --> 29:49.200
也能读出来

29:49.200 --> 29:50.200
关键是它怎么去读

29:50.200 --> 29:51.200
当然这里

29:51.200 --> 29:52.200
我们比方说

29:52.200 --> 29:53.200
我们用change var

29:53.200 --> 29:56.200
等于位置数

29:56.200 --> 29:58.200
我们再用那种query的

29:58.200 --> 29:59.200
这种方式

30:00.200 --> 30:02.200
其实就是一种格式

30:02.200 --> 30:03.200
那么

30:03.200 --> 30:04.200
就是把这个东西交给你

30:04.200 --> 30:05.200
看你怎么去读

30:05.200 --> 30:06.200
你还怎么读怎么读

30:06.200 --> 30:07.200
你要读它

30:07.200 --> 30:08.200
你就读它

30:08.200 --> 30:09.200
你不读它就不读它

30:09.200 --> 30:10.200
只不过我跟大家说的是

30:10.200 --> 30:11.200
这是一种习惯

30:11.200 --> 30:13.200
就是一些简单的参数配置

30:13.200 --> 30:14.200
我们可以直接写到这

30:14.200 --> 30:15.200
也可以

30:15.200 --> 30:16.200
也没问题

30:16.200 --> 30:17.200
那么这样子

30:17.200 --> 30:18.200
这个UTO库

30:18.200 --> 30:19.200
它仍然可以把它读出来

30:19.200 --> 30:23.500
好 咱们来看一下

30:23.500 --> 30:24.500
仍然打包

30:24.500 --> 30:25.500
打包正常一看

30:25.500 --> 30:26.500
它读出来的就是

30:26.500 --> 30:27.500
参数是不是

30:27.500 --> 30:28.500
也可以把它读成一个对象

30:28.500 --> 30:29.500
对吧

30:29.500 --> 30:31.500
对象里面有一个什么呢

30:31.500 --> 30:32.500
对象里面有一个change var

30:32.500 --> 30:33.500
对吧

30:33.500 --> 30:34.500
它也可以读出来

30:35.500 --> 30:36.500
ok

30:36.500 --> 30:38.500
这就是loader它的配置

30:38.500 --> 30:39.500
那么如果说

30:39.500 --> 30:41.500
你配置loader的时候

30:41.500 --> 30:43.500
如果说你配置loader的时候

30:43.500 --> 30:44.500
这个loader

30:44.500 --> 30:45.500
它只有一个字不串

30:45.500 --> 30:46.500
只有一个字不串

30:46.500 --> 30:47.500
作为loader

30:47.500 --> 30:48.500
那么这个时候

30:48.500 --> 30:49.500
你可以简化

30:49.500 --> 30:50.500
你没有必要去写

30:50.500 --> 30:51.500
一个完整的对象

30:51.500 --> 30:52.500
没有必要去写

30:52.500 --> 30:53.500
一个完整的对象

30:53.500 --> 30:54.500
你怎么写呢

30:54.500 --> 30:55.500
你直接把这个字不串

30:55.500 --> 30:57.500
作为数组的一项就行了

30:57.500 --> 30:58.500
这个数组里面

30:58.500 --> 30:59.500
每一项可以是个对象

30:59.500 --> 31:00.500
可以是个完整的配置

31:00.500 --> 31:01.500
表示一个loader

31:01.500 --> 31:05.130
也可以是一个字不串

31:05.130 --> 31:06.130
也可以是个字不串

31:06.130 --> 31:07.130
那么这样子

31:07.130 --> 31:10.130
看上去就更加简洁了一些了

31:10.130 --> 31:16.130
更加简洁了一些

31:16.130 --> 31:17.130
那么这个loader

31:17.130 --> 31:19.130
是不是看上去更加简洁了

31:19.130 --> 31:20.130
更加简洁了

31:20.130 --> 31:21.130
读一遍

31:21.130 --> 31:23.130
对模块的配置

31:23.130 --> 31:24.130
模块里面有两个配置

31:24.130 --> 31:25.130
其中一个配置

31:25.130 --> 31:26.130
我们以后再说

31:26.130 --> 31:27.130
其中一个配置叫做

31:27.130 --> 31:28.130
如果是规则

31:28.130 --> 31:29.130
就怎么来匹配这个模块

31:29.130 --> 31:30.130
匹配到过后

31:30.130 --> 31:31.130
我要用哪些加载器

31:31.130 --> 31:32.130
就是规则

31:32.130 --> 31:33.130
每一个规则

31:33.130 --> 31:34.130
两个规则

31:34.130 --> 31:35.130
很多规则都可以再写到这

31:35.130 --> 31:36.130
那么每个规则里面

31:36.130 --> 31:38.130
有一个正的表达是

31:38.130 --> 31:39.130
来匹配模块的路径

31:39.130 --> 31:40.130
只要匹配到了过后

31:40.130 --> 31:42.130
让它去应用哪些loader

31:42.130 --> 31:43.130
来处理它的元代

31:43.130 --> 31:45.130
下来好好去理一下

31:45.130 --> 31:46.130
梳理一下

31:46.130 --> 31:47.130
把这块认识清楚

31:47.130 --> 31:49.130
那么现在我们站在运行

31:50.130 --> 31:52.130
你看这样子写也可以

31:52.130 --> 31:53.130
你看是不是还是可以

31:53.130 --> 31:54.130
对吧

31:54.130 --> 31:55.130
因此这个配置有两种写法

31:55.130 --> 31:56.130
看下面

31:56.130 --> 31:57.130
一个是完整的配置

31:57.130 --> 31:58.130
你自己去看

31:59.130 --> 32:01.130
有一个是简化配置

32:01.130 --> 32:02.130
就直接这样子

32:03.130 --> 32:05.130
目前我们好像还没有

32:05.130 --> 32:07.130
还没有写到就是

32:07.130 --> 32:08.130
更多的loader

32:08.130 --> 32:10.130
我们多来几个loader

32:10.130 --> 32:13.130
然后loader1.js

32:13.130 --> 32:14.130
这里边

32:14.130 --> 32:16.130
我们复制一下

32:16.130 --> 32:18.130
过来简单一点

32:18.130 --> 32:19.130
简单一点

32:19.130 --> 32:21.130
那么这里我们直接就简单一点

32:21.130 --> 32:23.130
运行

32:23.130 --> 32:25.130
运行

32:25.130 --> 32:27.130
出出loader1

32:29.130 --> 32:31.130
然后这里返回

32:31.130 --> 32:33.130
还是返回 source code

32:33.130 --> 32:35.130
然后再来

32:35.130 --> 32:38.130
loader2.js

32:38.130 --> 32:40.130
我们把loader1复制一下

32:40.130 --> 32:42.130
我们看它主要关注它的运行顺序

32:42.130 --> 32:44.130
loader2

32:44.130 --> 32:46.130
然后loader3

32:46.130 --> 32:49.590
这里是loader3

32:49.590 --> 32:50.590
4个

32:50.590 --> 32:51.590
我们写4个

32:51.590 --> 32:52.590
loader4

32:52.590 --> 32:55.480
loader4

32:55.480 --> 32:56.480
OK

32:56.480 --> 32:58.480
那么是不是写了4个loader

32:58.480 --> 32:59.480
对吧

32:59.480 --> 33:00.480
好 接下来

33:00.480 --> 33:02.480
我们在in这个社里边

33:02.480 --> 33:04.480
改成正确了

33:04.480 --> 33:06.480
输出

33:06.480 --> 33:08.480
也不用输出了

33:08.480 --> 33:09.480
就啥都不写吧

33:09.480 --> 33:10.480
这有啥是好写的

33:10.480 --> 33:12.480
我们主要看loader的运行顺序

33:12.480 --> 33:13.480
那么这里边

33:13.480 --> 33:14.480
到这边

33:14.480 --> 33:15.480
use的时候

33:15.480 --> 33:17.480
你看我第一次匹配到了

33:17.480 --> 33:19.480
use 什么呢

33:19.480 --> 33:21.480
loader1

33:21.480 --> 33:23.480
loader2

33:23.480 --> 33:24.480
这样子写

33:24.480 --> 33:26.480
那么我们再来一个规则

33:26.480 --> 33:28.480
多写两个规则

33:29.480 --> 33:31.480
规则2

33:31.480 --> 33:33.480
这是规则1 规则2

33:34.480 --> 33:35.480
规则2

33:35.480 --> 33:36.480
我们这规则真正表示

33:36.480 --> 33:37.480
也可以一样

33:37.480 --> 33:38.480
也可以不一样

33:38.480 --> 33:39.480
无所谓

33:39.480 --> 33:40.480
那么这规则我改一下吧

33:40.480 --> 33:41.480
只要匹配到js就行

33:41.480 --> 33:43.480
只要匹配到js就行

33:43.480 --> 33:44.480
好 那么现在

33:44.480 --> 33:45.480
这里是loader3

33:45.480 --> 33:46.480
loader4

33:46.480 --> 33:47.480
咱们来看一下

33:47.480 --> 33:48.480
loader的运行顺序

33:48.480 --> 33:51.480
那么当我们进行入口模块的时候

33:51.480 --> 33:52.480
那么这个入口模块

33:52.480 --> 33:53.480
是不是既能匹配到这个规则

33:53.480 --> 33:54.480
又能匹配到这个规则

33:54.480 --> 33:55.480
对吧

33:55.480 --> 33:56.480
好

33:56.480 --> 33:57.480
那么每个规则里边

33:57.480 --> 33:58.480
是不是有两个loader

33:58.480 --> 34:00.480
那么它最终一定会运行4个

34:00.480 --> 34:01.480
loader一定会

34:01.480 --> 34:02.480
就这里

34:02.480 --> 34:03.480
它一定会有4个loader

34:03.480 --> 34:04.480
因为都能匹配到

34:04.480 --> 34:05.480
那么我们看它

34:05.480 --> 34:07.480
主要关系它的运行顺序

34:07.480 --> 34:10.620
运行

34:12.620 --> 34:13.620
什么

34:15.620 --> 34:17.620
这里没保存说

34:18.620 --> 34:19.620
关闭其他

34:19.620 --> 34:20.620
OK 再来

34:20.620 --> 34:24.280
它说怎么了

34:26.280 --> 34:30.910
arguments on load entry

34:30.910 --> 34:34.910
它说在解形loader1的时候

34:34.910 --> 34:35.910
除了问题

34:35.910 --> 34:36.910
解形loader1

34:37.910 --> 34:39.910
解形loader1的时候除了问题

34:40.910 --> 34:41.910
明白了

34:41.910 --> 34:42.910
明白了

34:42.910 --> 34:43.910
这里不能这样写

34:43.910 --> 34:44.910
因为我这些loader

34:44.910 --> 34:46.910
并不在loaded modules里面

34:46.910 --> 34:47.910
如果说你在loaded

34:47.910 --> 34:49.910
直接放到loaded modules里面

34:49.910 --> 34:50.910
是不是require了

34:50.910 --> 34:51.910
这个时候

34:51.910 --> 34:52.910
它就会从loaded modules里面去找

34:52.910 --> 34:53.910
对吧

34:53.910 --> 34:54.910
但是我并不在这里面

34:54.910 --> 34:55.910
所以说我要写

34:55.910 --> 34:56.910
你始终记住

34:56.910 --> 34:57.910
这个字幕算是

34:57.910 --> 34:58.910
要被require的

34:58.910 --> 35:00.910
它会放到require里面

35:00.910 --> 35:01.910
那么你这样写的话

35:01.910 --> 35:02.910
就是相当于require loader1

35:02.910 --> 35:03.910
它是不是要在这里面去找

35:03.910 --> 35:04.910
它找不到

35:04.910 --> 35:06.910
所以它无法解析这个模块

35:06.910 --> 35:07.910
因此我们要这里

35:07.910 --> 35:08.910
要写相对路径

35:08.910 --> 35:09.910
loaders

35:11.910 --> 35:17.420
再来

35:22.810 --> 35:23.810
我这里

35:23.810 --> 35:24.810
这里是3

35:25.810 --> 35:26.810
这里是4

35:27.810 --> 35:28.810
loader4

35:28.810 --> 35:29.810
2

35:29.810 --> 35:30.810
1

35:30.810 --> 35:31.810
然后这里

35:31.810 --> 35:32.810
loader3

35:32.810 --> 35:33.810
loader4

35:33.810 --> 35:34.810
OK 再来

35:34.810 --> 35:37.760
再重新来

35:37.760 --> 35:38.760
再找吧

35:38.760 --> 35:39.760
看一下

35:39.760 --> 35:41.760
是不是4 3 2 1

35:41.760 --> 35:42.760
怎么来的

35:42.760 --> 35:43.760
怎么来的

35:43.760 --> 35:44.760
好像跟我们写的

35:44.760 --> 35:45.760
相反对吧

35:45.760 --> 35:46.760
它就是相反的

35:46.760 --> 35:49.760
它是从下往上去匹配规则

35:49.760 --> 35:50.760
比方说第一次

35:50.760 --> 35:52.760
读到一个规则

35:52.760 --> 35:53.760
你看着

35:53.760 --> 35:54.760
它第一次读到一个规则

35:54.760 --> 35:55.760
是不是读到一个数组

35:55.760 --> 35:56.760
匹配到了吗

35:56.760 --> 35:57.760
第二个规则

35:57.760 --> 35:58.760
从下往上去匹配规则

35:58.760 --> 35:59.760
第二个规则是不是匹配到了

35:59.760 --> 36:01.760
匹配到了是不是读到一个数组

36:01.760 --> 36:02.760
对吧

36:02.760 --> 36:03.760
是读到一个数组

36:03.760 --> 36:06.650
OK

36:06.650 --> 36:07.650
其实也不是

36:07.650 --> 36:08.650
因为这样子

36:08.650 --> 36:09.650
我觉得好讲一点

36:09.650 --> 36:10.650
其实这样子来讲

36:10.650 --> 36:12.650
实际上规则匹配

36:12.650 --> 36:13.650
它确实是从上往下匹配的

36:13.650 --> 36:15.650
但是运行的时候是相反的

36:15.650 --> 36:16.650
规则的时候

36:16.650 --> 36:18.650
实际上是从上往下匹配的

36:18.650 --> 36:19.650
我觉得好

36:19.650 --> 36:21.650
从下往上跑匹配

36:21.650 --> 36:22.650
给你们好讲一点

36:22.650 --> 36:23.650
不过它实际上

36:23.650 --> 36:24.650
是从上往下匹配的

36:24.650 --> 36:25.650
那么它匹配的

36:25.650 --> 36:26.650
它是这样来做的

36:26.650 --> 36:28.650
感觉我就说详细点

36:28.650 --> 36:29.650
它是这样来做的

36:29.650 --> 36:30.650
第一次

36:30.650 --> 36:31.650
第一个是不是匹配到了

36:31.650 --> 36:32.650
匹配到了过后干嘛

36:32.650 --> 36:33.650
是不是拿到一个数组

36:33.650 --> 36:34.650
你看着

36:34.650 --> 36:35.650
是不是拿到一个数组

36:35.650 --> 36:36.650
拿到这个数组过后

36:36.650 --> 36:37.650
再去匹配第二规则

36:37.650 --> 36:39.650
是不是也匹配到了

36:39.650 --> 36:40.650
也匹配到了

36:40.650 --> 36:41.650
那么匹配到了过后

36:41.650 --> 36:42.650
是不是也拿到一个数组

36:42.650 --> 36:43.650
其实

36:43.650 --> 36:44.650
我们不用去把简化

36:44.650 --> 36:45.650
这样子

36:45.650 --> 36:47.650
大家可能更好理解一点

36:47.650 --> 36:48.650
那么这样子

36:48.650 --> 36:49.650
它会合并这两个数组

36:49.650 --> 36:51.650
就是把第二个匹配到了数组

36:51.650 --> 36:53.650
加入到第一个匹配到了数组

36:53.650 --> 36:54.650
它会这样子来做

36:54.650 --> 36:55.650
加进去

36:55.650 --> 36:56.650
其实

36:56.650 --> 36:57.650
一开始

36:57.650 --> 36:58.650
可以这样认为

36:58.650 --> 36:59.650
它一开始

36:59.650 --> 37:01.650
放了一个空数组进来

37:01.650 --> 37:02.650
一个空数组

37:02.650 --> 37:03.650
node是数组

37:03.650 --> 37:04.650
如果一个都没有匹配

37:04.650 --> 37:05.650
它就是空数组

37:05.650 --> 37:06.650
如果一个都没有匹配

37:06.650 --> 37:07.650
它就是空数组

37:07.650 --> 37:08.650
先放一个空数组

37:08.650 --> 37:10.650
然后从第一个规则开始

37:10.650 --> 37:11.650
匹配第一个规则

37:11.650 --> 37:12.650
第一个规则是不是一个数组

37:12.650 --> 37:13.650
把这个数组的所有东西

37:13.650 --> 37:15.650
是不是加到这个空数组里面来

37:15.650 --> 37:16.650
把这个数组里面所有东西

37:16.650 --> 37:18.650
加到这个空数组里面来

37:18.650 --> 37:19.650
怎么就显node1吗

37:19.650 --> 37:21.650
node1

37:21.650 --> 37:22.650
node2

37:22.650 --> 37:23.650
是不是加进来

37:23.650 --> 37:24.650
好

37:24.650 --> 37:25.650
然后再去匹配第二个规则

37:25.650 --> 37:26.650
是不是也匹配上了

37:26.650 --> 37:27.650
然后再把第二个规则里面的东西

37:27.650 --> 37:28.650
加进来

37:28.650 --> 37:30.650
node3

37:30.650 --> 37:32.650
node4

37:32.650 --> 37:33.650
就形成了这么一个数组

37:33.650 --> 37:34.650
那么这些node

37:34.650 --> 37:36.650
每个加载出来都是一个函数

37:36.650 --> 37:37.650
然后拥的时候怎么用呢

37:37.650 --> 37:39.650
关键是在拥的时候

37:39.650 --> 37:40.650
拥的时候

37:40.650 --> 37:41.650
它是反向的

37:41.650 --> 37:43.650
它先把我们的文件内容

37:43.650 --> 37:44.650
交给node4

37:44.650 --> 37:46.650
然后再把node4的内容

37:46.650 --> 37:47.650
返回的内容交给node3

37:47.650 --> 37:48.650
再把node3的内容

37:48.650 --> 37:50.650
交给返回的内容交给node2

37:50.650 --> 37:52.650
再把node2的返回的内容

37:52.650 --> 37:53.650
交给node1

37:53.650 --> 37:54.650
就是一层一层处理的

37:54.650 --> 37:55.650
然后node1

37:55.650 --> 37:58.650
最终得到这么一个结果

37:58.650 --> 38:00.650
就是我们最终要进行抽象

38:00.650 --> 38:02.650
语法数分析的原码

38:02.650 --> 38:04.650
它是用这么方式在运行的

38:04.650 --> 38:05.650
那么最终的也就是说

38:05.650 --> 38:07.650
你看到了是4 3 2 1

38:07.650 --> 38:12.110
4 3 2 1

38:12.110 --> 38:14.110
是不是4 3 2 1

38:14.110 --> 38:15.110
OK

38:15.110 --> 38:16.110
那么接下来我们比方说

38:16.110 --> 38:18.110
我们再写一个

38:18.110 --> 38:20.110
adder解释

38:20.110 --> 38:23.110
那么index里边去require

38:23.110 --> 38:25.110
adder

38:25.110 --> 38:28.110
这样子大家来分析一下

38:28.110 --> 38:29.110
比方说这是一道面试题

38:29.110 --> 38:31.110
那如果说面试出到这种程度

38:31.110 --> 38:32.110
就非常深了

38:32.110 --> 38:35.110
它要理要理解node的运行原理

38:35.110 --> 38:36.110
那么这样子

38:36.110 --> 38:39.940
它会输出什么样的结果

38:39.940 --> 38:40.940
好 这个东西你老在里面

38:40.940 --> 38:42.940
想想就想不出来了

38:42.940 --> 38:44.940
好好去看这张图

38:44.940 --> 38:45.940
看这张图

38:45.940 --> 38:47.940
结合这张图

38:47.940 --> 38:49.940
好好去看

38:49.940 --> 38:51.940
里面手上应该有原单

38:51.940 --> 38:52.940
你们好好去看

38:52.940 --> 38:54.940
这些课件都有的

38:54.940 --> 38:55.940
会输出什么结果呢

38:55.940 --> 38:58.940
你看着咱们来分析一下

38:58.940 --> 39:00.940
首先它运行的是入口模块

39:00.940 --> 39:02.940
入口模块要先进行node

39:02.940 --> 39:04.940
它首先是运行入口模块

39:04.940 --> 39:05.940
模块里边

39:05.940 --> 39:06.940
是不是要读取文件那种

39:06.940 --> 39:07.940
处理nodes

39:07.940 --> 39:08.940
处理nodes

39:08.940 --> 39:10.940
那么在处理nodes的过程中

39:10.940 --> 39:11.940
是不是匹配到两个规则

39:11.940 --> 39:13.940
那么是不是4321

39:13.940 --> 39:14.940
我们之前分析过了

39:14.940 --> 39:15.940
要运行

39:15.940 --> 39:16.940
要输出

39:16.940 --> 39:18.940
要输出

39:18.940 --> 39:20.940
这是对于什么index的

39:20.940 --> 39:21.940
JS模块

39:21.940 --> 39:22.940
是不是要输出

39:22.940 --> 39:24.940
这个是要运行node

39:24.940 --> 39:26.940
就是简单写

39:26.940 --> 39:27.940
4321

39:27.940 --> 39:29.940
是不是要输出这个东西

39:29.940 --> 39:30.940
好 那么输出完了过后

39:30.940 --> 39:32.940
是不是要对它进行抽象与法族分析

39:32.940 --> 39:33.940
要记住enite

39:33.940 --> 39:34.940
对吧

39:34.940 --> 39:35.940
enite里边一代谁

39:35.940 --> 39:36.940
一代a

39:36.940 --> 39:38.940
然后替换自己的一代函数

39:39.940 --> 39:41.940
替换成webpackrequire

39:41.940 --> 39:42.940
好 替换完了过后

39:42.940 --> 39:44.940
那么接下来是不是要处理一代了

39:44.940 --> 39:46.940
那么处理一代是不是要处理a模块

39:46.940 --> 39:47.940
又回来处理a模块

39:47.940 --> 39:49.940
a模块是不是又要读取文件那种

39:49.940 --> 39:50.940
读出来过后

39:50.940 --> 39:51.940
要处理nodes

39:51.940 --> 39:52.940
怎么处理nodes

39:52.940 --> 39:53.940
是不是要进行规则分析

39:53.940 --> 39:55.940
那么a能匹配到什么呢

39:55.940 --> 39:56.940
现在处理模块a了

39:56.940 --> 39:58.940
处理模块a

39:58.940 --> 39:59.940
a能匹配到什么呢

39:59.940 --> 40:01.940
a是不是只能匹配到这个

40:01.940 --> 40:03.940
匹配不到规则1

40:03.940 --> 40:04.940
因此a是不是只有3和4

40:04.940 --> 40:05.940
对吧

40:05.940 --> 40:06.940
a里边的规则

40:06.940 --> 40:10.940
它里边只有nodes3和nodes4

40:10.940 --> 40:13.940
那么现在运行ap票的nodes

40:13.940 --> 40:15.940
把a的元代也交给nodes去处理

40:15.940 --> 40:17.940
那么4

40:17.940 --> 40:18.940
是不是先输出4

40:18.940 --> 40:19.940
再输出3

40:19.940 --> 40:22.940
那么最终输出结果是432143

40:22.940 --> 40:23.940
怎么来看一下

40:23.940 --> 40:29.550
432143

40:29.550 --> 40:30.550
看没

40:30.550 --> 40:32.550
要搞清楚nodes是怎么来的

40:32.550 --> 40:34.550
它在整个的流程里面是哪一步

40:34.550 --> 40:35.550
它在做什么事情

40:35.550 --> 40:37.550
它能够起什么作用

40:37.550 --> 40:39.550
它能够替换我们的元代

40:39.550 --> 40:40.550
它怎么来替换呢

40:40.550 --> 40:41.550
就是读规则

40:41.550 --> 40:42.550
读规则

40:43.550 --> 40:44.550
我相信我这样讲了过后

40:44.550 --> 40:46.550
大家应该对这个很清楚了吧

40:46.550 --> 40:48.550
虽然说讲的好像有点深

40:48.550 --> 40:50.550
但是这样讲的过程里

40:50.550 --> 40:52.550
特别清楚nodes是干嘛用的

40:52.550 --> 40:53.550
那么以后呢

40:53.550 --> 40:54.550
其实nodes以后里面

40:54.550 --> 40:55.550
我没有要不要自己写

40:55.550 --> 40:56.550
不用自己写

40:56.550 --> 40:57.550
别人好多nodes

40:57.550 --> 40:58.550
现在wepac里面

40:58.550 --> 40:59.550
整个生态圈里面

40:59.550 --> 41:00.550
很多很多nodes

41:00.550 --> 41:01.550
他们已经能处理

41:01.550 --> 41:02.550
可以说99%

41:02.550 --> 41:04.550
咱们开发里面遇到的东西了

41:04.550 --> 41:06.550
还是不够自信

41:06.550 --> 41:07.550
100%

41:07.550 --> 41:08.550
开发里面遇到的东西

41:08.550 --> 41:10.550
除非你特别特别奇葩的一些东西

41:10.550 --> 41:11.550
像我们这种

41:11.550 --> 41:13.550
你要在这里面写这种东西

41:13.550 --> 41:14.550
就类似的这种

41:14.550 --> 41:15.550
特别奇葩

41:15.550 --> 41:17.550
不是那种正规做法的这种东西

41:17.550 --> 41:18.550
可能没有nodes

41:18.550 --> 41:19.550
你要自己写

41:19.550 --> 41:21.550
否则的话

41:21.550 --> 41:22.550
否则的话

41:22.550 --> 41:24.550
你都不用去自己写nodes

41:24.550 --> 41:25.550
都可以用第三方的

41:25.550 --> 41:26.550
别人写好的nodes

41:26.550 --> 41:27.550
但是你要清楚nodes

41:27.550 --> 41:28.550
其实是什么

41:28.550 --> 41:29.550
就是一个函数

41:29.550 --> 41:30.550
你理解了这些东西过后

41:30.550 --> 41:31.550
我们后边讲

41:31.550 --> 41:32.550
其他nodes的时候

41:32.550 --> 41:34.550
你特别容易理解

41:34.550 --> 41:35.550
它其实就是个函数

41:35.550 --> 41:36.550
把元代给你转

41:36.550 --> 41:37.550
就没事

41:38.550 --> 41:39.550
好

41:39.550 --> 41:40.550
那么这一课

41:40.550 --> 41:42.550
最后我给大家一个问题

41:42.550 --> 41:44.550
对这一课的内容的理解程度

41:45.550 --> 41:47.550
nodes中

41:47.550 --> 41:49.550
是否可以使用

41:49.550 --> 41:53.310
import

41:53.310 --> 41:56.310
使用esnew module

41:56.310 --> 41:59.880
可不可以呢

41:59.880 --> 42:01.880
是否可以使用esnew module

42:02.880 --> 42:03.880
说不可以

42:03.880 --> 42:04.880
为啥不可以

42:04.880 --> 42:05.880
必须要用common解释

42:05.880 --> 42:06.880
为啥

42:07.880 --> 42:09.880
很简单

42:09.880 --> 42:11.880
因为nodes是在哪里运行的

42:11.880 --> 42:12.880
是不是

42:12.880 --> 42:13.880
最终代码里面

42:13.880 --> 42:14.880
有没有nodes

42:14.880 --> 42:15.880
最终代码里面

42:15.880 --> 42:16.880
这怎么有没有nodes

42:16.880 --> 42:17.880
没有

42:17.880 --> 42:18.880
nodes只是在

42:18.880 --> 42:20.880
未拍的打包过程中

42:21.880 --> 42:22.880
运行的

42:22.880 --> 42:23.880
他把

42:23.880 --> 42:26.880
读取到文件的内容

42:26.880 --> 42:27.880
交给nodes

42:27.880 --> 42:28.880
nodes返回新的内容

42:28.880 --> 42:30.880
对新的内容进行愉化数分析

42:30.880 --> 42:32.880
他无非在做这么一件事

42:32.880 --> 42:33.880
所以说

42:33.880 --> 42:34.880
他跟什么

42:34.880 --> 42:37.880
他是在node环境里面

42:37.880 --> 42:38.880
运行的

42:38.880 --> 42:39.880
而且呢

42:39.880 --> 42:40.880
未拍的他nodes环境里面

42:40.880 --> 42:42.880
nodes环境其实支持esnew module

42:42.880 --> 42:43.880
只不过

42:43.880 --> 42:45.880
要绕一些圈

42:45.880 --> 42:46.880
而且呢对文件

42:46.880 --> 42:47.880
代码结构了

42:47.880 --> 42:49.880
也要做出一些相应的改变

42:49.880 --> 42:50.880
因此呢

42:50.880 --> 42:52.880
未拍的他并没有用到

42:52.880 --> 42:53.880
esnew的模块化

42:53.880 --> 42:55.880
因此未拍的他里面用的是

42:55.880 --> 42:56.880
用的是用required的方式

42:56.880 --> 42:57.880
用common解释的方式

42:57.880 --> 42:58.880
对不起

42:58.880 --> 42:59.880
对不起

42:59.880 --> 43:00.880
你只能使用common解释

43:00.880 --> 43:01.880
在这里面

43:01.880 --> 43:03.880
你不可能是通过

43:03.880 --> 43:07.320
esnew模块打出来吧

43:07.320 --> 43:08.320
default

43:08.320 --> 43:10.320
你看这样子

43:10.320 --> 43:11.320
未拍肯定导不进来

43:11.320 --> 43:13.320
因为他在node环境里面运行的

43:14.320 --> 43:15.320
导不进来

43:15.320 --> 43:17.320
根本就没法识别的

43:17.320 --> 43:18.320
expects export

43:18.320 --> 43:20.320
根本就识别不了这个玩意

43:20.320 --> 43:22.320
所以说你不能这样子用

43:22.320 --> 43:24.320
但是你要搞清楚他原因是什么

43:24.320 --> 43:25.320
原因这个node

43:25.320 --> 43:26.320
他说运行

43:26.320 --> 43:28.320
他说未拍打包的过程中

43:28.320 --> 43:29.320
用到的

43:29.320 --> 43:30.320
反而你看

43:30.320 --> 43:31.320
这个我们配置文件

43:31.320 --> 43:32.320
是不是在打包过程中用到的

43:32.320 --> 43:34.320
node是在打包过程中用到的

43:34.320 --> 43:35.320
打包过程中用到的东西

43:35.320 --> 43:37.320
肯定是node环境

43:37.320 --> 43:39.320
那肯定是common解释

43:39.320 --> 43:41.320
所以说有些同学呢

43:41.320 --> 43:42.320
学到未拍

43:42.320 --> 43:44.320
如果说你学得不够深入的话

43:44.320 --> 43:46.320
你就会造成一个很模糊的感觉

43:46.320 --> 43:47.320
为什么有些代码

43:47.320 --> 43:48.320
我可以用es6

43:48.320 --> 43:50.320
像这些地方我用es6

43:50.320 --> 43:51.320
那些都没问题

43:51.320 --> 43:53.320
但是到有些地方

43:53.320 --> 43:54.320
我就不能用es6

43:54.320 --> 43:56.320
就搞得感觉很模糊

43:56.320 --> 43:57.320
关键看什么了

43:57.320 --> 43:58.320
看你这个

43:58.320 --> 44:00.320
你如果是元代码

44:00.320 --> 44:01.320
不会运行的

44:01.320 --> 44:02.320
就是在打包过程中

44:02.320 --> 44:03.320
不会运行的东西

44:03.320 --> 44:04.320
那么随便

44:04.320 --> 44:05.320
你就es6

44:05.320 --> 44:06.320
随便怎么模糊的话

44:06.320 --> 44:08.320
哪怕amd cmd他都支持

44:08.320 --> 44:10.320
但是呢

44:10.320 --> 44:12.320
如果说你在元代码的

44:12.320 --> 44:13.320
你是要在node打包过程

44:13.320 --> 44:15.320
就是未拍个打包过程中要运行的代码

44:15.320 --> 44:16.320
那必须是node环境里面

44:16.320 --> 44:18.320
common解释代码

44:18.320 --> 44:19.320
这里边能不能使用温度对象

44:19.320 --> 44:20.320
哪有温度对象

44:20.320 --> 44:22.320
node环境里面运行的

44:22.320 --> 44:24.320
这些也要搞清楚

44:26.320 --> 44:29.320
这次关于这个loader

44:29.320 --> 44:31.700
loader

44:31.700 --> 44:33.700
那么其他我想想

44:33.700 --> 44:35.700
其他目前也没杀了

44:36.700 --> 44:38.700
那么下节课

44:38.700 --> 44:40.700
咱们利用loader

44:40.700 --> 44:41.700
它的原理

44:41.700 --> 44:43.700
来实现一个自己写的loader

44:43.700 --> 44:45.700
来实现一个特别有趣的效果

44:45.700 --> 44:46.700
这些

44:46.700 --> 44:48.700
这些和的内容

