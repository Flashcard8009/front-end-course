WEBVTT

00:00.820 --> 00:04.620
这节课呢 咱们来讲这个自动分包

00:05.420 --> 00:10.020
慢慢讲啊 因为我凡是说慢慢讲的话里面懂的啊

00:10.020 --> 00:12.620
这一节课呢 就不是那么简单了

00:13.020 --> 00:16.820
自动分包呢 是我们在用webpack的时候呢

00:16.820 --> 00:18.420
进行传输性能优化

00:18.420 --> 00:22.220
就特别是分包这一款呢 最常见的使用方式

00:22.620 --> 00:26.220
因为呢 他一旦配置好了 基本上是不用去改他的

00:26.420 --> 00:28.420
不像手动分包 一旦有新的包的话

00:28.420 --> 00:31.220
你自己还要去手动去处理 特别麻烦

00:31.620 --> 00:34.220
自动分包一旦配好了 那么就不需要去改动了

00:34.420 --> 00:37.020
让他按照他的规则 进行自动分包就行了

00:37.420 --> 00:39.420
他跟手动分包来相比的话

00:39.420 --> 00:43.220
他的以后没有缺陷呢 他实际上有缺陷

00:43.620 --> 00:46.620
手动分包可以极大的提高我们的

00:47.420 --> 00:50.620
编译啊 有什么模块的就是构建 构建速度

00:51.020 --> 00:54.620
但自动分包呢 他构建速度呢 就是构建性能的会降低

00:55.020 --> 00:57.420
但是他好处呢 也是不言而喻的啊

00:57.420 --> 01:01.420
好处就是我们开发效率其实上是提升了

01:01.620 --> 01:05.420
不然因为我们构建性能 无非就是关心的是开发效率吧

01:06.420 --> 01:08.820
一旦有一些新的模块引入了之后呢

01:08.820 --> 01:11.420
我们不用去手动处理了 他自动就完成了

01:12.220 --> 01:14.020
那么这里头我们来学习自动分包

01:14.220 --> 01:16.420
其实自动分包里要说他很难吧

01:17.420 --> 01:20.020
如果说你仅仅在乎的是使用的话

01:20.020 --> 01:22.020
就怎么去用他 他特别简单

01:22.020 --> 01:24.020
按照我的方式配就行了 没有几行待

01:24.420 --> 01:26.420
注意一些小的细节 就完事了

01:26.420 --> 01:30.420
没有什么东西 但是说你要理解他是怎么运作的的话

01:30.420 --> 01:33.420
那么他每个东西 每个配置是什么意思的话

01:33.820 --> 01:37.020
那可能会有一点糟 他要说特别复杂吧

01:37.020 --> 01:39.020
也没有那么复杂 主要是有一点糟

01:39.420 --> 01:41.020
好 这自动分包 自动分包呢

01:41.020 --> 01:42.620
我们首先来看他的基本原理

01:42.620 --> 01:45.220
他最简单的先讲一讲 他怎么回事

01:46.020 --> 01:49.420
跟那个手动分包呢 他的概念就完全不一样

01:49.820 --> 01:51.620
自动分包跟什么共同态链接库

01:51.620 --> 01:54.420
那些东西都没有什么关系 他是什么意思呢

01:54.420 --> 01:57.420
他是一个从实际的角度出发

01:57.420 --> 02:00.420
就是我们实际开发中 为什么需要分包

02:00.420 --> 02:02.420
无非就是公共代码提出去

02:03.420 --> 02:05.420
我也不管他是什么公共代码

02:05.420 --> 02:08.420
还是接库里的公共代码 还是楼下的公共代码

02:08.420 --> 02:10.420
无所谓 反正是公共代码提出去

02:10.420 --> 02:14.420
多个窗口之间 我们多个入口之间有公共模块

02:14.420 --> 02:16.420
那么就提出去

02:16.420 --> 02:20.420
他是从一个非常宏观的角度来控制分包

02:21.420 --> 02:24.420
他能不能进行精细的控制呢 也可以

02:24.420 --> 02:27.420
只不过我们一般是不会这样去做的

02:27.420 --> 02:29.420
我们一般从一个宏观的角度来控制他

02:29.420 --> 02:32.420
那他剩下的事情就交给他来完成

02:33.420 --> 02:37.420
就好比说你是一个国家的领导人

02:37.420 --> 02:41.420
那么你不会去处理那些非常精细的操作

02:41.420 --> 02:44.420
那么你只是下达一些指示 提倡一些精神

02:44.420 --> 02:46.420
开个会 就完事了

02:46.420 --> 02:48.420
就这么个意思

02:48.420 --> 02:51.420
他一般不会对哪具体的哪个包要分出去进行控制

02:51.420 --> 02:53.420
一般不会的

02:53.420 --> 02:55.420
因此你要使用自动分包呢

02:55.420 --> 02:58.420
其实你使用起来的是特别方便的

02:58.420 --> 03:01.420
它比较贴合实际的开发需要

03:01.420 --> 03:03.420
那么我们要控制自动分包

03:03.420 --> 03:07.420
关键是要配置一个合理的分包策略

03:07.420 --> 03:09.420
其实我们整杰克讲的是什么呢

03:09.420 --> 03:11.420
讲的就是这个分包策略

03:11.420 --> 03:13.420
因为他的分包是自动完成的

03:13.420 --> 03:15.420
那么他怎么来分包呢

03:15.420 --> 03:17.420
他是按照分包策略来进行分包的

03:18.420 --> 03:20.420
只要有了分包策略

03:20.420 --> 03:22.420
那么你不需要安装额外的任何插件

03:22.420 --> 03:24.420
维派克会自动按照策略来进行分包

03:24.420 --> 03:26.420
就这么回事

03:26.420 --> 03:29.420
这里我简单的说一下 提个题外话

03:29.420 --> 03:33.420
实际上维派克使用的是Split Trunks Plugging来进行分包的

03:33.420 --> 03:35.420
使用的是他来进行分包的

03:35.420 --> 03:38.420
真正起分包的重要的是他

03:38.420 --> 03:39.420
给他看一下吧

03:39.420 --> 03:42.420
其实你们以后看官网的话

03:42.420 --> 03:44.420
我说为什么不要去看中文文档

03:44.420 --> 03:47.420
因为中文文档他有些时候翻译有些问题

03:47.420 --> 03:49.420
而且他有些地方有些缺失

03:49.420 --> 03:53.420
能够英文不错的同学尽量去看英文文档

03:53.420 --> 03:55.420
你看那个配置里边

03:55.420 --> 03:57.420
我们这里可要讲到一个配置

03:57.420 --> 03:59.420
就是优化配置

03:59.420 --> 04:01.420
那么这里边是没有这个配置箱的

04:01.420 --> 04:02.420
中文文档里面

04:02.420 --> 04:04.420
但是英文官网里面是有的

04:04.420 --> 04:05.420
因为他这个东西不是官网

04:05.420 --> 04:07.420
我们看一下英文官网

04:07.420 --> 04:09.420
连接还出去了

04:09.420 --> 04:12.730
我们看他文档

04:12.730 --> 04:14.730
他的配置

04:14.730 --> 04:16.730
那么这里是我们要用到的配置

04:16.730 --> 04:17.730
你看中文官网里面就没有

04:17.730 --> 04:19.730
那么这个配置里边

04:19.730 --> 04:20.730
我们要用到什么配置

04:20.730 --> 04:21.730
叫splittrunk

04:21.730 --> 04:23.730
这个配置在这

04:23.730 --> 04:24.730
他就告诉你

04:24.730 --> 04:26.730
这个配置其实上

04:26.730 --> 04:29.730
它就是配置一个分包策略

04:29.730 --> 04:31.730
那么这个策略具体怎么配置呢

04:31.730 --> 04:33.730
它让你去建这个插件

04:33.730 --> 04:34.730
说明啥呀

04:34.730 --> 04:35.730
说明它的配置实际上

04:35.730 --> 04:37.730
就是这个插件去完成的

04:37.730 --> 04:38.730
它实际上那一步

04:38.730 --> 04:40.730
是使用了这个插件的功能

04:40.730 --> 04:41.730
就这么个意思

04:41.730 --> 04:43.730
说点到就是了

04:43.730 --> 04:44.730
那么具体

04:44.730 --> 04:46.730
这里还有一个小的细节

04:46.730 --> 04:47.730
我说一下

04:47.730 --> 04:48.730
就是过去

04:48.730 --> 04:50.730
我们这个插件是新的插件

04:50.730 --> 04:52.730
过去是用用的是另外一个插件

04:52.730 --> 04:54.730
叫做commence trunk plug-in

04:54.730 --> 04:56.730
有些以后你们的公司里面

04:56.730 --> 04:58.730
可能看到一些老的项目

04:58.730 --> 04:59.730
可能还在用这个插件

04:59.730 --> 05:02.730
不过这个插件到了wepack4之后

05:02.730 --> 05:03.730
就已经被取代了

05:03.730 --> 05:04.730
因为这个插件里面

05:04.730 --> 05:05.730
有一些东西的功能

05:05.730 --> 05:06.730
不是很稳

05:06.730 --> 05:08.730
晚上会有一些小的问题

05:08.730 --> 05:10.730
那么现在已经被这个插件所取代了

05:10.730 --> 05:12.730
而现在跟那个wepack

05:12.730 --> 05:13.730
到了wepack4之后

05:13.730 --> 05:16.730
你甚至不用去手动的使用插件

05:16.730 --> 05:17.730
它自动在

05:17.730 --> 05:19.730
你直接需要在wepack里面配置

05:19.730 --> 05:21.730
它自动就启用了

05:21.730 --> 05:24.730
那么它具体的分包过程是这样子的

05:24.730 --> 05:26.730
比方说有两个入口

05:26.730 --> 05:27.730
trunk2

05:27.730 --> 05:28.730
trunk1

05:28.730 --> 05:29.730
trunk2

05:29.730 --> 05:30.730
有两个入口

05:30.730 --> 05:31.730
那么这两个入口里面

05:31.730 --> 05:32.730
可能使用了一些

05:32.730 --> 05:33.730
公共的模块

05:33.730 --> 05:34.730
公共代码

05:34.730 --> 05:35.730
比方说介块锐

05:35.730 --> 05:36.730
耳朵大小的公共代码

05:36.730 --> 05:38.730
我们只要配置好一个分包策略

05:38.730 --> 05:40.730
那么它在打包的过程中

05:40.730 --> 05:42.730
它就可能

05:42.730 --> 05:43.730
在你具体的看一分包策略

05:43.730 --> 05:44.730
怎么去配置

05:44.730 --> 05:45.730
那么它就可能

05:45.730 --> 05:47.730
会把这些公共代码

05:47.730 --> 05:49.730
提出来形成一个新的 trunk

05:49.730 --> 05:51.730
这是一个新的 trunk

05:51.730 --> 05:52.730
还不是一个文件

05:52.730 --> 05:53.730
它是一个新的 trunk

05:53.730 --> 05:55.730
那么我们 trunk1

05:55.730 --> 05:56.730
trunk2 里面

05:56.730 --> 05:58.730
它就不包含这些公共代码

05:58.730 --> 06:00.730
公共代码形成一个新的 trunk

06:00.730 --> 06:01.730
那么三个 trunk 打包结果

06:01.730 --> 06:02.730
那么自然就是形成了

06:02.730 --> 06:03.730
三个文件

06:03.730 --> 06:04.730
对吧

06:04.730 --> 06:05.730
trunk1 的文件

06:05.730 --> 06:06.730
trunk2 的文件

06:06.730 --> 06:07.730
以及一个公共文件

06:07.730 --> 06:08.730
就形成这么一个结果

06:08.730 --> 06:11.730
这就是它最基本的一个原理

06:12.730 --> 06:15.730
那么从这个原理结构图里边

06:15.730 --> 06:17.730
可以看出

06:17.730 --> 06:19.730
我们要做的是什么

06:19.730 --> 06:21.730
控制分包策略

06:21.730 --> 06:23.730
因为分包策略就影响到了

06:23.730 --> 06:25.730
它是具体怎么去分理新的 trunk

06:25.730 --> 06:26.730
它不一定是一个

06:26.730 --> 06:28.730
它有可能会产生多个

06:28.730 --> 06:29.730
那么具体怎么来控制

06:29.730 --> 06:30.730
分包策略

06:30.730 --> 06:31.730
另外一个呢

06:31.730 --> 06:32.730
我们可以看到

06:32.730 --> 06:34.730
它提取的分包的时候

06:34.730 --> 06:35.730
提取公共代码

06:35.730 --> 06:37.730
是新建了一个 trunk

06:37.730 --> 06:38.730
这一定要搞清楚

06:38.730 --> 06:39.730
因为我们配置的时候

06:39.730 --> 06:40.730
时刻可以看到

06:40.730 --> 06:42.730
它是一个新的 trunk

06:42.730 --> 06:44.730
对分裂的模型打包

06:44.730 --> 06:45.730
然后呢

06:45.730 --> 06:46.730
它打包过后呢

06:46.730 --> 06:48.730
它会形成一个单独的文件

06:48.730 --> 06:49.730
还有这个单独的文件

06:49.730 --> 06:50.730
这个单独文件

06:50.730 --> 06:52.730
是个 trunk 的产物

06:52.730 --> 06:53.730
那么这就是它的简单的

06:53.730 --> 06:56.730
一个分包的简单的流程

06:56.730 --> 06:57.730
而且让我们来看具体的配置

06:57.730 --> 06:59.730
怎么来配置分包策略

06:59.730 --> 07:01.730
我们来看一下基本配置

07:01.730 --> 07:02.730
其实如果说

07:02.730 --> 07:05.730
从使用的角度来出发的话

07:05.730 --> 07:07.730
基本配置特别简单

07:07.730 --> 07:08.730
怎么配置呢

07:08.730 --> 07:09.730
你就在 webpack 里面

07:09.730 --> 07:10.730
提供这么一个配置项

07:10.730 --> 07:11.730
然后呢

07:11.730 --> 07:12.730
里边有

07:12.730 --> 07:13.730
这个东西叫什么呢

07:13.730 --> 07:14.730
optimization

07:14.730 --> 07:15.730
叫做 u 化

07:15.730 --> 07:17.730
这是个 u 化配置项

07:17.730 --> 07:18.730
那么这个 u 化配置项

07:18.730 --> 07:19.730
我们后边还会见到

07:19.730 --> 07:20.730
还有一些其他配置

07:20.730 --> 07:21.730
其中有一项配置

07:21.730 --> 07:23.730
叫做 split trunk

07:23.730 --> 07:24.730
split 什么意思

07:24.730 --> 07:25.730
分割 trunk

07:25.730 --> 07:26.730
就分割 trunk

07:26.730 --> 07:28.730
把 trunk 有公共的部分

07:28.730 --> 07:30.730
分割出来形成一个新的 trunk

07:30.730 --> 07:32.730
那么就配置这个东西就行了

07:32.730 --> 07:33.730
那么在这个里边

07:33.730 --> 07:34.730
去配置分包策略

07:34.730 --> 07:37.730
这就是我们简单的配置方式

07:37.730 --> 07:38.730
这里呢

07:38.730 --> 07:39.730
我给大家看一下吧

07:39.730 --> 07:40.730
我们的工程里边

07:40.730 --> 07:42.730
一个 工程里边

07:42.730 --> 07:43.730
这是

07:43.730 --> 07:45.730
我们的配置简单接受

07:45.730 --> 07:46.730
看一下

07:46.730 --> 07:47.730
dm 就是 webpack

07:47.730 --> 07:48.730
这个没什么好说的

07:48.730 --> 07:49.730
然后呢

07:49.730 --> 07:50.730
我们的配置文件

07:50.730 --> 07:51.730
配置文件呢

07:51.730 --> 07:52.730
我用了一个

07:52.730 --> 07:53.730
这两个都见过了

07:53.730 --> 07:54.730
一个是清除

07:54.730 --> 07:55.730
输出目录

07:55.730 --> 07:56.730
一个是生成一个itm 文件

07:56.730 --> 07:57.730
这个先放着吧

07:57.730 --> 07:58.730
先放着

07:58.730 --> 07:59.730
生成itm 文件

07:59.730 --> 08:00.730
我就先不要吧

08:00.730 --> 08:01.730
先不要

08:01.730 --> 08:02.730
先不要这个

08:03.730 --> 08:04.730
我们一会再加上

08:04.730 --> 08:05.730
先不要

08:05.730 --> 08:06.730
尽量简单一点

08:06.730 --> 08:07.730
现在呢

08:07.730 --> 08:08.730
使用了一个东西

08:08.730 --> 08:09.730
要做ProductX

08:10.730 --> 08:11.730
为什么要使用它的

08:11.730 --> 08:12.730
为什么呢

08:13.730 --> 08:14.730
因为

08:14.730 --> 08:16.730
我们在开发阶段

08:16.730 --> 08:17.730
实际上是

08:18.730 --> 08:19.730
不需要分包

08:19.730 --> 08:20.730
对吧

08:20.730 --> 08:21.730
我们分包的目的是

08:21.730 --> 08:22.730
减少体积

08:22.730 --> 08:23.730
减少传输

08:23.730 --> 08:25.730
体现的是传输的性能

08:25.730 --> 08:26.730
实际上

08:26.730 --> 08:27.730
我们的开发阶段

08:27.730 --> 08:28.730
是不需要

08:28.730 --> 08:29.730
不需要做这个

08:29.730 --> 08:30.730
就是分包的

08:30.730 --> 08:31.730
为什么呢

08:31.730 --> 08:32.730
为什么不需要做分包呢

08:32.730 --> 08:33.730
因为

08:33.730 --> 08:34.730
我们开发阶段

08:34.730 --> 08:35.730
传输性能

08:35.730 --> 08:36.730
有的就是

08:36.730 --> 08:38.730
就是那个热梯罐之后

08:38.730 --> 08:39.730
传输性能就不成什么问题了

08:39.730 --> 08:40.730
所以说呢

08:40.730 --> 08:41.730
它的体积大级大贝

08:41.730 --> 08:42.730
几兆也无所谓

08:42.730 --> 08:43.730
反正是本机嘛

08:43.730 --> 08:44.730
对吧

08:44.730 --> 08:45.730
福西都在本机

08:45.730 --> 08:46.730
所以说

08:46.730 --> 08:47.730
我们通常是在

08:47.730 --> 08:49.730
生产环境里边

08:49.730 --> 08:50.730
要去体现分包

08:50.730 --> 08:51.730
包括里面以后

08:51.730 --> 08:52.730
学到什么

08:52.730 --> 08:53.730
5u 学到rex

08:53.730 --> 08:54.730
他们的一些

08:54.730 --> 08:55.730
脚手架工具

08:55.730 --> 08:56.730
他们也是这样子

08:56.730 --> 08:57.730
在开发阶段

08:57.730 --> 08:58.730
很懒得给你分

08:58.730 --> 08:59.730
也不想给你分

08:59.730 --> 09:00.730
那么

09:00.730 --> 09:01.730
一般到了生产环境里边

09:01.730 --> 09:02.730
还才给你分包

09:03.730 --> 09:04.730
还会自动给你完成

09:04.730 --> 09:05.730
给你配置好

09:05.730 --> 09:06.730
好了

09:06.730 --> 09:07.730
所以说

09:07.730 --> 09:08.730
我们这里的是生产环境

09:08.730 --> 09:09.730
好

09:09.730 --> 09:10.730
那么这里的是我们的工程

09:10.730 --> 09:11.730
我们怎么来配置分包呢

09:11.730 --> 09:12.730
分包策略呢

09:12.730 --> 09:13.730
就这个东西

09:13.730 --> 09:14.730
这个单词呢

09:14.730 --> 09:15.730
叫做

09:15.730 --> 09:17.730
Optimization

09:17.730 --> 09:18.730
优化项

09:18.730 --> 09:19.730
优化项里边有很多优化项

09:19.730 --> 09:21.730
我们这几课学习的

09:21.730 --> 09:22.730
是分包

09:22.730 --> 09:23.730
那么后边还有一些别的

09:23.730 --> 09:25.730
Split Trunks

09:25.730 --> 09:27.730
这么个东西

09:27.730 --> 09:28.730
那么这里边

09:28.730 --> 09:30.730
就是分包配置了

09:30.730 --> 09:31.730
实际上

09:31.730 --> 09:32.730
那个分包配置

09:32.730 --> 09:33.730
需不需要

09:33.730 --> 09:34.730
那么不需要

09:34.730 --> 09:35.730
因为分包配置

09:35.730 --> 09:36.730
都是有默认值的

09:36.730 --> 09:38.730
它默认的情况下

09:38.730 --> 09:39.730
VPAC就已经给你

09:39.730 --> 09:41.730
做了一个最好的配置

09:41.730 --> 09:42.730
也不说最好的吧

09:42.730 --> 09:44.730
绝大

09:44.730 --> 09:46.730
绝大部分情况下

09:46.730 --> 09:48.730
都能够使用的配置

09:48.730 --> 09:49.730
所以说

09:49.730 --> 09:50.730
这个东西你配不配置

09:50.730 --> 09:52.730
甚至可以不配置

09:52.730 --> 09:53.730
只不过

09:53.730 --> 09:54.730
你不配置

09:54.730 --> 09:55.730
看一下能不能分包呢

09:55.730 --> 09:56.730
我们来看一下吧

09:56.730 --> 09:57.730
比方说

09:57.730 --> 09:58.730
我们这里有

09:58.730 --> 09:59.730
两个文件

09:59.730 --> 10:01.730
一个是

10:02.730 --> 10:04.730
两个Trunk

10:04.730 --> 10:05.730
一个是

10:05.730 --> 10:06.730
入口1

10:06.730 --> 10:08.730
Mate1.js

10:08.730 --> 10:10.730
一个是Mate2.js

10:10.730 --> 10:12.730
有两个入口

10:12.730 --> 10:14.730
两个入口

10:14.730 --> 10:15.730
或者是我们用配级1吧

10:15.730 --> 10:17.730
配级1.js

10:17.730 --> 10:18.730
配级2.js

10:18.730 --> 10:19.730
有两个页面

10:19.730 --> 10:20.730
每个页面一个Trunk

10:20.730 --> 10:22.730
一般会这样做

10:22.730 --> 10:23.730
那么这里

10:23.730 --> 10:24.730
我们配级1里边

10:24.730 --> 10:25.730
要用接夸位

10:25.730 --> 10:26.730
是不是公共代

10:26.730 --> 10:27.730
是吧

10:27.730 --> 10:28.730
我们现在

10:28.730 --> 10:29.730
自动分包了

10:29.730 --> 10:31.730
要用多大

10:32.730 --> 10:33.730
是不是有两个公共代

10:33.730 --> 10:35.730
这两个都是不是公共代

10:35.730 --> 10:38.730
两个Trunk都会用的

10:38.730 --> 10:39.730
这两个模块

10:39.730 --> 10:41.730
是Trunk的入口模块

10:41.730 --> 10:42.730
那么这里

10:42.730 --> 10:43.730
我们是随便来一个

10:43.730 --> 10:45.730
随便输出配级1

10:45.730 --> 10:48.730
然后这里输出配级2

10:48.730 --> 10:49.730
所以说

10:49.730 --> 10:50.730
我们这两个

10:50.730 --> 10:51.730
两个Trunk

10:51.730 --> 10:52.730
都依赖

10:52.730 --> 10:53.730
到时候打包的时候

10:53.730 --> 10:54.730
都依赖

10:54.730 --> 10:55.730
一些公共库

10:55.730 --> 10:56.730
接夸位都要一起

10:56.730 --> 10:58.730
它能各自有各自的代码

10:58.730 --> 10:59.730
没问题吧

10:59.730 --> 11:00.730
OK

11:00.730 --> 11:01.730
那么这是

11:01.730 --> 11:02.730
有些公共库

11:02.730 --> 11:03.730
好 接下来

11:03.730 --> 11:04.730
我们来看一下

11:04.730 --> 11:05.730
来看一下

11:05.730 --> 11:06.730
我们在这里

11:06.730 --> 11:07.730
需要进行配置

11:07.730 --> 11:08.730
就是我们入口了

11:08.730 --> 11:09.730
肯定要配置成两个

11:09.730 --> 11:11.730
一个是Trunk1

11:11.730 --> 11:14.730
我们就用配级1

11:14.730 --> 11:17.730
它来自于SRC配级1.js

11:17.730 --> 11:19.730
配级2

11:19.730 --> 11:22.730
SRC配级2.js

11:22.730 --> 11:23.730
写着个DLJS

11:23.730 --> 11:24.730
都可以不用写

11:24.730 --> 11:26.730
它自己知道加厚嘴的

11:26.730 --> 11:27.730
那么这里

11:27.730 --> 11:29.730
这是我们的两个Trunk

11:29.730 --> 11:31.730
然后我们配置一下Output

11:31.730 --> 11:32.730
输出

11:32.730 --> 11:33.730
输出的文件

11:33.730 --> 11:35.730
File in

11:35.730 --> 11:38.730
这是我们以前学过的东西

11:38.730 --> 11:40.730
DLJS

11:43.730 --> 11:44.730
其他的没啥了

11:44.730 --> 11:45.730
没啥了 就行了

11:45.730 --> 11:46.730
好 我们来看一下

11:46.730 --> 11:47.730
我们啥都不配置

11:47.730 --> 11:48.730
我都注释了

11:48.730 --> 11:50.730
它能不能进行分包呢

11:50.730 --> 11:51.730
因为我们两个Trunk

11:51.730 --> 11:52.730
都用了公共库

11:52.730 --> 11:53.730
能不能进行分包呢

11:53.730 --> 11:54.730
它有默认配置

11:54.730 --> 11:55.730
我们来看一下

11:55.730 --> 12:00.000
NPM

12:00.000 --> 12:01.000
RUN

12:01.000 --> 12:02.000
DEV

12:02.000 --> 12:03.000
运行

12:03.000 --> 12:08.100
等下打包

12:08.100 --> 12:13.040
打包完成

12:13.040 --> 12:14.040
打包完成之后

12:14.040 --> 12:15.040
我们来看一下

12:15.040 --> 12:16.040
有没有分包

12:16.040 --> 12:17.040
还是一个配级1

12:17.040 --> 12:18.040
里边有所谓的

12:18.040 --> 12:20.040
Jquery楼下期待吧

12:20.040 --> 12:22.040
然后配级2

12:22.040 --> 12:23.040
你看一下

12:23.040 --> 12:24.040
资源清单就行了

12:24.040 --> 12:26.040
其实你看一下这里

12:26.040 --> 12:27.040
这个资源清单

12:27.040 --> 12:28.040
我为了看

12:28.040 --> 12:29.040
你们看的方便

12:29.040 --> 12:30.040
我把这个提示

12:30.040 --> 12:32.040
因为这些客人内容比较多

12:32.040 --> 12:34.040
所以我尽量的

12:35.040 --> 12:36.040
把它写一下

12:36.040 --> 12:37.040
就是这个提示

12:37.040 --> 12:38.040
叫啥名字的

12:38.040 --> 12:39.040
对于忘了

12:40.040 --> 12:41.040
稍微有一段时间

12:41.040 --> 12:42.040
没用就忘了

12:43.040 --> 12:44.040
这里呢

12:44.040 --> 12:45.040
就是统计信息

12:45.040 --> 12:46.040
Stats

12:47.040 --> 12:48.040
对了

12:48.040 --> 12:49.040
然后呢

12:49.040 --> 12:50.040
把卡那个加上

12:51.040 --> 12:52.040
然后呢

12:56.040 --> 12:58.860
再来

12:58.860 --> 12:59.860
我主要是看资源清单

13:00.860 --> 13:01.860
有个写错了

13:02.860 --> 13:04.860
有个写错了

13:04.860 --> 13:05.860
叫做Module

13:05.860 --> 13:06.860
Module

13:07.860 --> 13:08.860
应该是没有S

13:08.860 --> 13:12.840
好

13:12.840 --> 13:13.840
看一下啊

13:13.840 --> 13:16.980
来

13:16.980 --> 13:17.980
看一下

13:17.980 --> 13:18.980
哦

13:18.980 --> 13:19.980
这个Trunk Modules

13:21.980 --> 13:22.980
稍微Force

13:22.980 --> 13:23.980
就不要让它显示

13:23.980 --> 13:24.980
跟每个模块

13:24.980 --> 13:25.980
打包哪些模块

13:25.980 --> 13:26.980
这个显示太烦了

13:28.980 --> 13:29.980
Trunk

13:29.980 --> 13:31.980
将构建

13:31.980 --> 13:32.980
不是

13:32.980 --> 13:33.980
Trunk

13:33.980 --> 13:35.980
Trunk是吧

13:35.980 --> 13:36.980
是这个吗

13:37.980 --> 13:38.980
设置为Force

13:38.980 --> 13:40.980
把Trunk是设置为Force

13:40.980 --> 13:43.810
看一下

13:45.810 --> 13:49.270
它什么意思

13:49.270 --> 13:50.270
我看一下

13:50.270 --> 13:51.270
看一下它的什么

13:51.270 --> 13:52.270
什么错误

13:52.270 --> 13:53.270
它的Color有问题

13:53.270 --> 13:54.270
Color有问题

13:55.270 --> 13:56.270
这个

13:56.270 --> 13:57.270
Color是啥呢

13:59.270 --> 14:00.270
我记得有一个Color

14:01.270 --> 14:02.270
ColorS

14:03.270 --> 14:04.270
是这个的问题

14:04.270 --> 14:05.270
是这个的问题

14:05.270 --> 14:10.340
再来

14:10.340 --> 14:11.340
那么现在呢

14:11.340 --> 14:12.340
我拿包了

14:12.340 --> 14:13.340
那么这些东西

14:13.340 --> 14:14.340
这些东西

14:14.340 --> 14:15.340
好像是Modules

14:15.340 --> 14:16.340
Modules Force

14:18.340 --> 14:19.340
OK

14:19.340 --> 14:23.060
好看一下吧

14:24.060 --> 14:25.060
那么这样子

14:25.060 --> 14:26.060
看上去就比较简洁了

14:26.060 --> 14:27.060
就比较简洁了

14:27.060 --> 14:28.060
没问题吧

14:28.060 --> 14:29.060
好

14:29.060 --> 14:30.060
那么现在打包了两个文件

14:30.060 --> 14:31.060
一个159KB

14:31.060 --> 14:32.060
一个159KB

14:32.060 --> 14:33.060
两个文件里面

14:33.060 --> 14:34.060
都有公共带

14:34.060 --> 14:35.060
对吧

14:35.060 --> 14:36.060
总体积太大了

14:36.060 --> 14:37.060
那么这个时候

14:37.060 --> 14:38.060
我要进行分包

14:38.060 --> 14:39.060
默认情况下

14:39.060 --> 14:40.060
它有分包策略

14:40.060 --> 14:41.060
但是它为什么

14:41.060 --> 14:42.060
就没有完成分包呢

14:42.060 --> 14:43.060
是因为这样子的

14:44.060 --> 14:46.060
它有一个配置

14:46.060 --> 14:47.060
这里面有个分包策略

14:47.060 --> 14:48.060
有很多配置

14:48.060 --> 14:49.060
其中一个配置要Trunk

14:49.060 --> 14:50.060
这个配置

14:50.060 --> 14:51.060
它有一个默认值

14:51.060 --> 14:53.060
那么是因为这个默认值

14:53.060 --> 14:54.060
造成了

14:54.060 --> 14:55.060
它现在没有分包

14:55.060 --> 14:56.060
那么我们来看一下

14:56.060 --> 14:57.060
这个配置到底是什么东西

14:57.060 --> 14:58.060
这个配置箱

14:58.060 --> 15:00.060
它主要是用于配置那些

15:00.060 --> 15:03.060
需要应用分包策略的Trunk

15:03.060 --> 15:05.060
它主要是配置这个东西

15:05.060 --> 15:08.060
要应用分包策略的Trunk

15:08.060 --> 15:09.060
什么意思呢

15:09.060 --> 15:10.060
就是说我们这里

15:10.060 --> 15:11.060
不是有两个Trunk吗

15:11.060 --> 15:12.060
对吧

15:12.060 --> 15:14.060
那么哪些Trunk需要用到

15:14.060 --> 15:15.060
分包策略

15:15.060 --> 15:16.060
就是我们要进行分包

15:16.060 --> 15:18.060
那么这里的配置箱

15:18.060 --> 15:20.060
有三种

15:20.060 --> 15:21.060
一种是All

15:21.060 --> 15:22.060
就是对所有的Trunk

15:22.060 --> 15:23.060
都要应用分包策略

15:23.060 --> 15:25.060
第二种是默认值

15:25.060 --> 15:26.060
Async

15:26.060 --> 15:27.060
这个东西我们还没有学过

15:27.060 --> 15:28.060
我们可能在下节课

15:28.060 --> 15:30.060
或者是下节课就要学

15:30.060 --> 15:31.060
这个东西是什么呢

15:31.060 --> 15:32.060
它只针对那些

15:32.060 --> 15:33.060
一步Trunk

15:33.060 --> 15:34.060
要应用分包策略

15:34.060 --> 15:35.060
所以它是默认值

15:35.060 --> 15:37.060
因此由于我们这两个Trunk

15:37.060 --> 15:39.060
都不是一步Trunk

15:39.060 --> 15:40.060
什么叫一步Trunk

15:40.060 --> 15:41.060
我们后边会学

15:42.060 --> 15:43.060
会不会学

15:43.060 --> 15:45.060
就相当于是蓝加债

15:45.060 --> 15:46.060
就有些Trunk一开始

15:46.060 --> 15:47.060
我不加债他

15:47.060 --> 15:49.060
但是后续我在运行的过程中

15:49.060 --> 15:50.060
再去加债

15:50.060 --> 15:52.060
是这么个意思

15:52.060 --> 15:54.060
所以说我这里

15:54.060 --> 15:55.060
由于

15:55.060 --> 15:57.060
它的默认值是这个

15:57.060 --> 15:58.060
所以说我没有办法

15:58.060 --> 15:59.060
因为这两个都不是一步

15:59.060 --> 16:00.060
所以他们两个

16:00.060 --> 16:02.060
没有应用分包策略

16:02.060 --> 16:03.060
那么这个东西

16:03.060 --> 16:04.060
Async就是普通Trunk了

16:04.060 --> 16:05.060
就是我们的普通Trunk

16:05.060 --> 16:06.060
要应用分包策略

16:06.060 --> 16:07.060
那么我们这里

16:07.060 --> 16:08.060
一般配置为啥呢

16:08.060 --> 16:09.060
一般配置为All

16:09.060 --> 16:10.060
就可以了

16:10.060 --> 16:12.060
因此我们在这里配置一下

16:12.060 --> 16:13.060
把默认值该改一下

16:13.060 --> 16:14.060
分包策略该改成什么呢

16:14.060 --> 16:15.060
Trunk

16:16.060 --> 16:17.060
把改为All

16:18.060 --> 16:19.060
好改成All之后

16:19.060 --> 16:20.060
再看一下

16:21.060 --> 16:22.060
运行

16:22.060 --> 16:23.060
就不做任何其他配置

16:23.060 --> 16:24.060
你看它能不能分包

16:26.750 --> 16:27.750
好看一下吧

16:27.750 --> 16:30.380
你看

16:30.380 --> 16:31.380
是不是三个文件生成出来了

16:32.380 --> 16:33.380
对吧

16:33.380 --> 16:34.380
而且你会看到有一个

16:35.380 --> 16:38.020
它就没放

16:38.020 --> 16:39.020
它就没放

16:39.020 --> 16:40.020
重新适应了

16:40.020 --> 16:41.020
再来一次

16:41.020 --> 16:43.020
我们看一下它Trunk的名称

16:43.020 --> 16:44.020
本来我们是

16:44.020 --> 16:45.020
我们只有两个Trunk

16:45.020 --> 16:46.020
一个是配级一

16:46.020 --> 16:47.020
一个是配级二

16:47.020 --> 16:48.020
对吧

16:48.020 --> 16:49.020
本来只有两个Trunk

16:49.020 --> 16:50.020
那么现在呢

16:50.020 --> 16:51.020
加入了分包策略之后

16:51.020 --> 16:52.020
有一对我们这两个Trunk

16:52.020 --> 16:53.020
要进行分包

16:53.020 --> 16:54.020
它就会出现

16:54.020 --> 16:55.020
自动的分包出来

16:55.020 --> 16:56.020
一个新的Trunk

16:56.020 --> 16:57.020
它发现了一个公共代码

16:57.020 --> 16:58.020
它提取出来了

16:58.020 --> 16:59.020
叫Vendors

16:59.020 --> 17:01.020
那么它自动的命名方式

17:01.020 --> 17:02.020
Vendors

17:02.020 --> 17:03.020
一个飘飘

17:03.020 --> 17:04.020
这个东西叫啥

17:04.020 --> 17:05.020
这个连接符

17:05.020 --> 17:06.020
配级一 配级二

17:06.020 --> 17:07.020
说明我们配级一

17:07.020 --> 17:08.020
从那个名称上

17:08.020 --> 17:09.020
可以看出

17:09.020 --> 17:11.020
这是它新生成的一个Trunk

17:11.020 --> 17:12.020
那么这个新的Trunk

17:12.020 --> 17:13.020
名字呢

17:13.020 --> 17:14.020
是

17:14.020 --> 17:15.020
就是包含那个

17:15.020 --> 17:16.020
公共代码的Trunk的名字

17:16.020 --> 17:17.020
连接起来

17:17.020 --> 17:18.020
配级一 配级二

17:18.020 --> 17:19.020
对吧

17:19.020 --> 17:20.020
然后呢

17:20.020 --> 17:21.020
这个Vendors

17:21.020 --> 17:22.020
Vendors是什么意思呢

17:22.020 --> 17:23.020
就是一些第三方库

17:23.020 --> 17:24.020
就是在No the Marjors

17:24.020 --> 17:25.020
里边的第三方库

17:25.020 --> 17:26.020
它出现这么一个东西

17:26.020 --> 17:27.020
Vendors

17:27.020 --> 17:28.020
也就是说

17:28.020 --> 17:29.020
我们这个分包

17:29.020 --> 17:30.020
其实很简单

17:30.020 --> 17:31.020
我们只需要把这个Trunk

17:31.020 --> 17:32.020
改回

17:32.020 --> 17:33.020
就完事了

17:33.020 --> 17:34.020
对吧

17:34.020 --> 17:35.020
就完事了

17:35.020 --> 17:36.020
如果说你要

17:36.020 --> 17:37.020
就只管用的话

17:37.020 --> 17:38.020
那么就ok了

17:38.020 --> 17:39.020
就ok了

17:39.020 --> 17:40.020
那么后面我们再来看一下

17:40.020 --> 17:41.020
它这里呢

17:41.020 --> 17:42.020
这是什么意思呢

17:42.020 --> 17:43.020
就这个东西啊

17:43.020 --> 17:44.020
有可能呢

17:44.020 --> 17:45.020
你看看

17:45.020 --> 17:46.020
它分包出来的

17:46.020 --> 17:47.020
还是比较大

17:47.020 --> 17:48.020
158个KB

17:48.020 --> 17:49.020
对吧

17:49.020 --> 17:50.020
看的不爽了

17:50.020 --> 17:52.020
怎么分包出来还是比较大的

17:52.020 --> 17:53.020
因为你配级一 配级二

17:53.020 --> 17:54.020
其实它只有

17:54.020 --> 17:55.020
只有它里边代码了

17:55.020 --> 17:56.020
配级一 配级二

17:56.020 --> 17:57.020
它其实代码已经很少了

17:57.020 --> 17:58.020
它只有配级一 配级二

17:58.020 --> 17:59.020
里边代码

17:59.020 --> 18:00.020
你看

18:00.020 --> 18:01.020
输出配级一

18:01.020 --> 18:02.020
对吧

18:02.020 --> 18:03.020
还有配级二

18:03.020 --> 18:04.020
我们看了

18:04.020 --> 18:05.020
配级一 配级二

18:05.020 --> 18:06.020
其实它只有里边代码了

18:06.020 --> 18:07.020
那么公共代码

18:07.020 --> 18:08.020
全部提到这儿

18:08.020 --> 18:09.020
这个文件来了

18:09.020 --> 18:10.020
全部提到这儿来了

18:10.020 --> 18:11.020
那么它的产生一个新的窗口

18:11.020 --> 18:13.020
但是新的窗口还是比较大

18:13.020 --> 18:14.020
那么这个时候呢

18:14.020 --> 18:16.020
如果说你对一些

18:16.020 --> 18:17.020
你还要做一些控制

18:17.020 --> 18:19.020
就是说

18:19.020 --> 18:20.020
某一个包

18:20.020 --> 18:22.020
如果说超过了一个大小

18:22.020 --> 18:23.020
你还要对它进行划分

18:23.020 --> 18:25.020
那么就可以使用这个配置

18:25.020 --> 18:26.020
MaxSize

18:26.020 --> 18:27.020
那么这个配置呢

18:27.020 --> 18:29.020
可以控制包的最大字节数

18:29.020 --> 18:31.020
它的单位是字节

18:31.020 --> 18:32.020
我们知道

18:32.020 --> 18:33.020
1020个字节等于1KB

18:33.020 --> 18:34.020
你们自己去算

18:34.020 --> 18:35.020
所以说

18:35.020 --> 18:36.020
如果说某个包

18:36.020 --> 18:37.020
超过了这个纸

18:37.020 --> 18:38.020
如果说你配置呢

18:38.020 --> 18:40.020
维派克罗会尽可能的

18:40.020 --> 18:42.020
进查自己最大的努力

18:42.020 --> 18:43.020
将其分立为多个包

18:43.020 --> 18:44.020
比方说

18:44.020 --> 18:46.330
我们来看一下

18:46.330 --> 18:48.330
我们这里配置一下MaxSize

18:48.330 --> 18:50.330
比方说我们配置一下

18:50.330 --> 18:51.330
60KB

18:51.330 --> 18:53.330
就是60×1024

18:53.330 --> 18:55.330
或者我们简单一点

18:55.330 --> 18:56.330
就用1000来表示

18:56.330 --> 18:57.330
60KB

18:57.330 --> 18:58.330
大约60KB

18:58.330 --> 18:59.330
那么我们这样的配置

18:59.330 --> 19:00.330
只要这个包

19:00.330 --> 19:01.330
超过了60KB

19:01.330 --> 19:02.330
它还要划分

19:02.330 --> 19:03.330
所以说这样子

19:03.330 --> 19:06.600
一配置呢

19:06.600 --> 19:07.600
你看一下

19:07.600 --> 19:11.770
这样子配置之后呢

19:11.770 --> 19:12.770
稍微等待一下

19:12.770 --> 19:13.770
是不是又一个东西出现了

19:13.770 --> 19:14.770
对吧

19:14.770 --> 19:15.770
又出现了四个文件了

19:15.770 --> 19:16.770
你看

19:16.770 --> 19:17.770
是不是四个文件

19:17.770 --> 19:18.770
看着看着很清楚

19:18.770 --> 19:19.770
对吧

19:19.770 --> 19:20.770
这一个文件

19:20.770 --> 19:21.770
这一个文件

19:21.770 --> 19:22.770
那么这两个就被分开了

19:22.770 --> 19:23.770
分开了

19:23.770 --> 19:24.770
一个呢

19:24.770 --> 19:25.770
是

19:25.770 --> 19:26.770
那么它自动的

19:26.770 --> 19:27.770
因为它有可能会出现

19:27.770 --> 19:28.770
相同的窗壳

19:28.770 --> 19:29.770
怕避免

19:29.770 --> 19:30.770
避免那个窗壳的名称相同

19:30.770 --> 19:31.770
因此呢

19:31.770 --> 19:33.770
它后面会出现一些哈希纸

19:33.770 --> 19:34.770
会出现那个

19:34.770 --> 19:36.770
每个包的哈希纸

19:36.770 --> 19:37.770
包括我们自己的窗壳

19:37.770 --> 19:38.770
也会出现

19:38.770 --> 19:39.770
因此呢

19:39.770 --> 19:40.770
我们的窗壳的哈希纸

19:40.770 --> 19:41.770
会变

19:41.770 --> 19:42.770
哈希纸会变化

19:42.770 --> 19:43.770
对吧

19:43.770 --> 19:44.770
它又对这个

19:44.770 --> 19:45.770
抽离的公共模块

19:45.770 --> 19:46.770
因为它超过了这个尺寸

19:46.770 --> 19:48.770
它又进行分立的

19:48.770 --> 19:49.770
是这么个意思

19:49.770 --> 19:50.770
那么实际上

19:50.770 --> 19:51.770
它就是把接区域啊

19:51.770 --> 19:53.770
和勒扎希两个分开了

19:53.770 --> 19:55.770
那有些細心的同学

19:55.770 --> 19:56.770
可以看到

19:56.770 --> 19:57.770
我明明设置的是六十KB

19:57.770 --> 19:58.770
那么这个东西

19:58.770 --> 20:00.770
还是超过了六十KB了

20:00.770 --> 20:01.770
它为什么没有再细分呢

20:01.770 --> 20:03.770
是因为这个样子

20:03.770 --> 20:04.770
分包的时候呢

20:04.770 --> 20:07.770
它的基础单位是模块

20:07.770 --> 20:08.770
如果说

20:08.770 --> 20:09.770
你就一个完整的模块

20:09.770 --> 20:10.770
像接区域

20:10.770 --> 20:11.770
接区域就一个文件

20:11.770 --> 20:12.770
那个完整的模块里面

20:12.770 --> 20:13.770
它就超过了这个体积了

20:13.770 --> 20:14.770
它不可能把这个模块

20:14.770 --> 20:15.770
给你切分成两半

20:15.770 --> 20:16.770
它做不到的

20:16.770 --> 20:17.770
这个东西

20:17.770 --> 20:18.770
它就把单一把给你分割了

20:18.770 --> 20:19.770
没办法

20:19.770 --> 20:21.770
它只能是按模块分割

20:21.770 --> 20:22.770
模块是最小单位了

20:22.770 --> 20:23.770
因此呢

20:23.770 --> 20:24.770
如果说一个模块

20:24.770 --> 20:25.770
非常非常大

20:25.770 --> 20:26.770
它就没有办法再做到再分割了

20:26.770 --> 20:28.770
是这么个意思

20:28.770 --> 20:29.770
因此呢

20:29.770 --> 20:30.770
尽管使用了这个配置呢

20:30.770 --> 20:31.770
完全有可能会出现

20:31.770 --> 20:32.770
某个包的体积呢

20:32.770 --> 20:33.770
还是会超过

20:33.770 --> 20:35.770
还是会超过你配置的体积

20:35.770 --> 20:37.770
这个是没办法的

20:37.770 --> 20:38.770
其实呢

20:38.770 --> 20:39.770
像这个东西呢

20:39.770 --> 20:40.770
我为什么要说

20:40.770 --> 20:41.770
其实它的意义呢

20:41.770 --> 20:43.770
并不大

20:43.770 --> 20:44.770
它的意义其实并不大

20:44.770 --> 20:46.770
为什么我还要拿出来

20:46.770 --> 20:47.770
说一下这个东西呢

20:47.770 --> 20:49.770
是因为

20:49.770 --> 20:51.770
这个玩意啊

20:51.770 --> 20:52.770
为什么说它意义呢

20:52.770 --> 20:53.770
它有意义

20:53.770 --> 20:55.770
但是它意义并不大

20:55.770 --> 20:57.770
因为呢

20:57.770 --> 20:58.770
你这样子分开过后

20:58.770 --> 21:00.770
你有没有改变

21:00.770 --> 21:02.770
改变总体积

21:02.770 --> 21:04.770
总体积是不是没有变化

21:04.770 --> 21:05.770
对吧

21:05.770 --> 21:06.770
你不会把它插成两个文件

21:06.770 --> 21:07.770
无非在浏览器里面

21:07.770 --> 21:08.770
会多进行一次

21:08.770 --> 21:09.770
ACDP请求

21:09.770 --> 21:10.770
它传输的内容

21:10.770 --> 21:11.770
还是不还是那么多

21:11.770 --> 21:12.770
对吧

21:12.770 --> 21:13.770
还是那么多

21:13.770 --> 21:15.770
没有什么实际的意义

21:15.770 --> 21:16.770
那么为什么说

21:16.770 --> 21:17.770
它还是有点意义呢

21:17.770 --> 21:18.770
它有点意义就在于呢

21:18.770 --> 21:20.770
有些浏览器呢

21:20.770 --> 21:22.770
它支持多线程

21:22.770 --> 21:24.770
就是多线程同步下载

21:24.770 --> 21:26.770
充分利用带宽同步下载

21:26.770 --> 21:27.770
那么

21:27.770 --> 21:28.770
在这种情况下呢

21:28.770 --> 21:29.770
你把分成多个文件的

21:29.770 --> 21:31.770
好像还有那么一点意义

21:31.770 --> 21:32.770
但是呢你注意啊

21:32.770 --> 21:33.770
分成多个文件的

21:33.770 --> 21:34.770
实际上呢

21:34.770 --> 21:35.770
它是有风险的

21:35.770 --> 21:36.770
风险的在于

21:36.770 --> 21:37.770
因为你反正要传输这么多

21:37.770 --> 21:38.770
你分成一个文件

21:38.770 --> 21:39.770
传输和两个文件

21:39.770 --> 21:40.770
传输都是一样的

21:40.770 --> 21:41.770
那么

21:41.770 --> 21:42.770
无非就是利用一下

21:42.770 --> 21:43.770
并行下载

21:43.770 --> 21:44.770
那如果说那些浏览器

21:44.770 --> 21:46.770
它不支持并行下载

21:46.770 --> 21:47.770
那么就会导致

21:47.770 --> 21:50.770
它还要多开一个ACDP请求

21:50.770 --> 21:51.770
那么这个东西呢

21:51.770 --> 21:52.770
可能得无尝失了

21:52.770 --> 21:53.770
所以说这个东西

21:53.770 --> 21:54.770
升用吧

21:54.770 --> 21:55.770
升用

21:55.770 --> 21:57.770
因为我们分包的最大目的

21:57.770 --> 21:59.770
是要提取的公共代码

21:59.770 --> 22:00.770
你分一个文件

22:00.770 --> 22:01.770
提取的公共代码

22:01.770 --> 22:02.770
分两个文件

22:02.770 --> 22:03.770
还是提取的公共代码

22:03.770 --> 22:04.770
所以说呢

22:04.770 --> 22:05.770
这一块呢

22:05.770 --> 22:06.770
升用就行了

22:06.770 --> 22:08.770
当然你得担心是有道理的

22:08.770 --> 22:09.770
你担心

22:09.770 --> 22:11.770
就是说我们其实呢

22:11.770 --> 22:13.770
不配置它吧

22:13.770 --> 22:14.770
不配置它

22:15.770 --> 22:16.770
其实呢

22:16.770 --> 22:17.770
有一同学担心呢

22:17.770 --> 22:18.770
就是说

22:18.770 --> 22:19.770
我这个公共的模块

22:19.770 --> 22:21.770
怎么还有那么大的体积

22:21.770 --> 22:22.770
那么我们传输的时候

22:22.770 --> 22:24.770
158K比其实也不小了

22:24.770 --> 22:25.770
对吧

22:25.770 --> 22:26.770
我们传输的时候

22:26.770 --> 22:27.770
因为我们这里

22:27.770 --> 22:28.770
才用到两个公共库

22:28.770 --> 22:29.770
那么以后

22:29.770 --> 22:30.770
还会用到更多的公共库

22:30.770 --> 22:31.770
那么一个公共库的

22:31.770 --> 22:33.770
就是公共第三方库的体积太大

22:33.770 --> 22:34.770
虽然跟我们没什么关系

22:34.770 --> 22:35.770
但是没办法

22:35.770 --> 22:36.770
公共库的体积太大

22:36.770 --> 22:37.770
那么这个时候呢

22:37.770 --> 22:38.770
会影响传输效率

22:38.770 --> 22:39.770
确实会影响

22:39.770 --> 22:40.770
那么这个问题呢

22:40.770 --> 22:42.770
要后表我们学习的解决

22:42.770 --> 22:43.770
一个是压缩

22:43.770 --> 22:44.770
压缩其实很简单

22:44.770 --> 22:46.770
一开启这个生产环境

22:46.770 --> 22:47.770
它就会压缩

22:47.770 --> 22:48.770
它已经压缩了

22:48.770 --> 22:49.770
另外一个呢

22:49.770 --> 22:50.770
就是缺卸品

22:50.770 --> 22:51.770
我们后边会讲

22:51.770 --> 22:52.770
这个东西呢

22:52.770 --> 22:53.770
可以极大的优化

22:53.770 --> 22:54.770
我们的就是

22:54.770 --> 22:55.770
第三方库

22:55.770 --> 22:56.770
我们后边来说

22:56.770 --> 22:57.770
下节课吧

22:57.770 --> 22:59.770
下节课还是下节课

22:59.770 --> 23:00.770
我们到时候安排吧

23:00.770 --> 23:01.770
这是关于它的就是

23:01.770 --> 23:02.770
两个基本配置

23:02.770 --> 23:03.770
我们平时呢

23:03.770 --> 23:04.770
用这个东西呢

23:04.770 --> 23:05.770
就是生用吧

23:05.770 --> 23:06.770
这个东西呢

23:06.770 --> 23:07.770
我们必须要配置的

23:07.770 --> 23:08.770
因为不配置的话

23:08.770 --> 23:09.770
它默认是Async

23:09.770 --> 23:10.770
那就没办法了

23:10.770 --> 23:12.770
这是关于基本配置

23:12.770 --> 23:13.770
然后我们再看一下

23:13.770 --> 23:14.770
其他配置

23:14.770 --> 23:15.770
其他配置呢

23:15.770 --> 23:16.770
它都是有默认值

23:16.770 --> 23:17.770
它的其实

23:17.770 --> 23:18.770
其他配置比较多

23:18.770 --> 23:19.770
刚才给大家看了

23:19.770 --> 23:20.770
官方稳当

23:20.770 --> 23:21.770
如果有兴趣的话

23:21.770 --> 23:22.770
去看一下Split Trunks

23:22.770 --> 23:24.770
Plugging的一个插件

23:24.770 --> 23:25.770
就这个插件

23:25.770 --> 23:26.770
那么这个插件里边的配置

23:26.770 --> 23:27.770
就是这里的配置

23:27.770 --> 23:28.770
那么其他的配置

23:28.770 --> 23:29.770
我简单说几个吧

23:29.770 --> 23:31.770
一个是这个配置

23:31.770 --> 23:32.770
这个配置呢

23:32.770 --> 23:33.770
它指的是

23:33.770 --> 23:34.770
新的Trunk的名称

23:34.770 --> 23:35.770
它是自动的

23:35.770 --> 23:36.770
你看看

23:36.770 --> 23:37.770
这个Trunk的名称

23:37.770 --> 23:38.770
它是自动的

23:38.770 --> 23:39.770
那么第1个

23:39.770 --> 23:40.770
我先不说吧

23:40.770 --> 23:41.770
第1个

23:41.770 --> 23:42.770
我们就

23:42.770 --> 23:43.770
认为是固定的吧

23:43.770 --> 23:44.770
以后就知道了

23:44.770 --> 23:45.770
第2个呢

23:45.770 --> 23:46.770
第3个就是它

23:46.770 --> 23:47.770
哪些

23:47.770 --> 23:48.770
从哪些Trunk里面

23:48.770 --> 23:49.770
提出来的公共模块

23:49.770 --> 23:50.770
那么中间呢

23:50.770 --> 23:51.770
会用一个分割符

23:51.770 --> 23:52.770
那么这个配置呢

23:52.770 --> 23:53.770
就是控制分割符的

23:53.770 --> 23:54.770
其实没啥

23:54.770 --> 23:55.770
就是控制分割符的

23:55.770 --> 23:59.080
让我们看一下吧

23:59.080 --> 24:00.080
比方说

24:00.080 --> 24:01.080
把配置成底

24:01.080 --> 24:04.420
看一下

24:04.420 --> 24:05.420
就是配置

24:05.420 --> 24:06.420
新的Trunk的分割符

24:07.420 --> 24:08.420
就这么个意思

24:08.420 --> 24:09.420
就这么个意思

24:09.420 --> 24:10.420
它就是分割符

24:10.420 --> 24:12.420
这是关于这一块

24:12.420 --> 24:13.420
另一个呢

24:13.420 --> 24:14.420
叫Mintrunk

24:15.420 --> 24:16.420
就这个

24:16.420 --> 24:17.420
Mintrunk

24:17.420 --> 24:18.420
这个是配置什么呢

24:18.420 --> 24:19.420
它指的是

24:19.420 --> 24:20.420
注意小的

24:20.420 --> 24:22.420
创可引用数

24:22.420 --> 24:24.420
因为它在分包的时候

24:24.420 --> 24:26.420
它要提取公共代

24:26.420 --> 24:28.420
什么叫做公共代

24:28.420 --> 24:29.420
就是被多少个

24:29.420 --> 24:30.420
创可引用了

24:30.420 --> 24:31.420
才叫公共代

24:31.420 --> 24:32.420
它注意

24:32.420 --> 24:33.420
不是被模块引用

24:33.420 --> 24:34.420
是被创可引用

24:34.420 --> 24:35.420
比方说吧

24:35.420 --> 24:37.420
我们这个配置的创可

24:37.420 --> 24:39.420
这里配置的创可

24:39.420 --> 24:41.420
这里配置的创可

24:41.420 --> 24:42.420
什么两个创可

24:42.420 --> 24:43.420
配置1

24:43.420 --> 24:44.420
那么配置1里面

24:44.420 --> 24:45.420
不管一些模块

24:45.420 --> 24:47.420
有多复杂的一代关系

24:47.420 --> 24:49.420
整个创可里面

24:49.420 --> 24:51.420
只要用到了接块位

24:51.420 --> 24:53.420
那么就算是一个

24:53.420 --> 24:55.420
一个创可用到了接块位

24:55.420 --> 24:56.420
那么如果说

24:56.420 --> 24:57.420
这个创可里面

24:57.420 --> 24:58.420
不管它里面

24:58.420 --> 24:59.420
设置到多少模块

24:59.420 --> 25:00.420
这是个入口模块吧

25:00.420 --> 25:01.420
它里面

25:01.420 --> 25:02.420
肯定要有其他模块

25:02.420 --> 25:03.420
设置到很多模块

25:03.420 --> 25:04.420
那么不管有多少模块

25:04.420 --> 25:05.420
只要用到了接块位

25:05.420 --> 25:07.420
那么这又算是一个

25:07.420 --> 25:08.420
接块就用了两次

25:08.420 --> 25:09.420
原来那意思吧

25:09.420 --> 25:11.420
它就这么个意思

25:11.420 --> 25:12.420
民创始

25:12.420 --> 25:15.420
只要是

25:15.420 --> 25:17.420
被用到了几次

25:17.420 --> 25:19.420
我才要分包

25:19.420 --> 25:20.420
默认值为1

25:20.420 --> 25:22.420
默认值为1是什么意思呢

25:22.420 --> 25:23.420
就只要用到了一次

25:23.420 --> 25:25.420
我都要进行分包

25:25.420 --> 25:26.420
只要用到了一次

25:26.420 --> 25:27.420
我都要进行分包

25:27.420 --> 25:29.420
那么既然默认值为1

25:29.420 --> 25:30.420
我们来看一下

25:30.420 --> 25:31.420
一个神奇的现象

25:31.420 --> 25:32.420
比方说我们这里

25:32.420 --> 25:33.420
自己写一个代码

25:33.420 --> 25:34.420
它不是第三方的

25:34.420 --> 25:36.420
它不是说一定要分个第三方

25:36.420 --> 25:38.420
它说我们不是第三方的

25:38.420 --> 25:39.420
那么我们不是第三方

25:39.420 --> 25:40.420
我们来看一下

25:40.420 --> 25:42.420
commands.js

25:42.420 --> 25:43.420
我们这里就

25:43.420 --> 25:45.420
module export

25:45.420 --> 25:47.420
输出一个command

25:47.420 --> 25:48.420
那么配级

25:48.420 --> 25:49.420
要不要用它

25:49.420 --> 25:50.420
要用它

25:50.420 --> 25:53.420
command from

25:53.420 --> 25:54.420
就是我们自己的公共模块

25:54.420 --> 25:55.420
它怎么能分出去呢

25:55.420 --> 25:56.420
它当然也是一样

25:56.420 --> 25:57.420
它并不去区分

25:57.420 --> 26:00.420
什么第三方和自己的

26:00.420 --> 26:01.420
那么现在

26:01.420 --> 26:03.420
既然你的就是

26:03.420 --> 26:04.420
为1

26:04.420 --> 26:05.420
既然你为1

26:05.420 --> 26:06.420
那么我们这个command

26:06.420 --> 26:07.420
是不是用了两次

26:07.420 --> 26:08.420
对吧

26:08.420 --> 26:09.420
用了两次

26:09.420 --> 26:10.420
用了两次

26:10.420 --> 26:11.420
自然而然要进行分包了

26:11.420 --> 26:12.420
对吧

26:12.420 --> 26:13.420
那么我们来看一下

26:13.420 --> 26:14.420
command会不会进行分包

26:14.420 --> 26:19.860
好

26:19.860 --> 26:20.860
打包完成

26:20.860 --> 26:21.860
那么现在我们怎么来知道

26:21.860 --> 26:22.860
这个里面有没有

26:22.860 --> 26:23.860
我们的command代码呢

26:23.860 --> 26:24.860
有没有我们的command代码

26:24.860 --> 26:25.860
我们进去

26:25.860 --> 26:27.860
查找一下

26:27.860 --> 26:28.860
command

26:28.860 --> 26:29.860
因为我们导出的是command

26:29.860 --> 26:30.860
对吧

26:30.860 --> 26:31.860
是不是无结果

26:31.860 --> 26:32.860
所以说我们的command代码

26:32.860 --> 26:33.860
是不是没有在这个

26:33.860 --> 26:34.860
分包结果里面

26:34.860 --> 26:35.860
在我们具体的模块里面

26:35.860 --> 26:37.860
出现了重复的command代码

26:37.860 --> 26:38.860
对吧

26:38.860 --> 26:40.860
出现了重复的command代码

26:40.860 --> 26:42.860
因此command是没有进行分包的

26:42.860 --> 26:44.860
那就奇了怪了

26:44.860 --> 26:45.860
那就奇了怪了

26:45.860 --> 26:46.860
我们这个名创的是

26:46.860 --> 26:48.860
默认值是1

26:48.860 --> 26:49.860
我们看一下吧

26:49.860 --> 26:50.860
我们这个默认值是1

26:50.860 --> 26:52.860
你不写的话也是1

26:52.860 --> 26:53.860
那么凭什么

26:53.860 --> 26:54.860
第三方的库可以分包

26:54.860 --> 26:55.860
而我们自己的库

26:55.860 --> 26:57.860
它就不能分出去了

26:57.860 --> 26:58.860
我们自己的库

26:58.860 --> 26:59.860
还用了两次对吧

26:59.860 --> 27:01.860
那么这个时候呢

27:01.860 --> 27:03.860
就是另外一个配置起作用

27:04.860 --> 27:06.860
就是它还有一个条件

27:06.860 --> 27:07.860
什么条件呢

27:07.860 --> 27:08.860
这个条件是非常重要的

27:08.860 --> 27:09.860
就是当你一个分包

27:09.860 --> 27:10.860
如果说我分出去了

27:10.860 --> 27:12.860
这个太小了没意义

27:12.860 --> 27:13.860
因为我们知道

27:13.860 --> 27:14.860
你如果说一个

27:14.860 --> 27:15.860
非常非常小的文件

27:15.860 --> 27:17.860
你有必要把它做成一个

27:17.860 --> 27:19.860
单独的文件吧

27:19.860 --> 27:20.860
这样子增加一次

27:20.860 --> 27:22.860
额外的请求和必呢

27:22.860 --> 27:24.860
本来代码就不多

27:24.860 --> 27:25.860
重复就重复

27:25.860 --> 27:26.860
也影响不了多少

27:26.860 --> 27:27.860
连1kb

27:27.860 --> 27:29.860
可能连几十个字节都没有

27:29.860 --> 27:31.860
因此你把它分出去干满了

27:31.860 --> 27:32.860
所以说呢

27:32.860 --> 27:34.860
它要受到这个东西的控制

27:34.860 --> 27:36.860
Minsize

27:36.860 --> 27:38.860
来吧看一下这个东西

27:38.860 --> 27:40.860
Minsize

27:40.860 --> 27:43.860
它的值的是30kb

27:43.860 --> 27:45.860
就是3万个字节

27:45.860 --> 27:46.860
30kb

27:46.860 --> 27:47.860
那么30kb

27:47.860 --> 27:48.860
就是你分包过后

27:48.860 --> 27:49.860
达到了30kb

27:49.860 --> 27:50.860
我才要分包

27:50.860 --> 27:52.860
那么它跟MarkzSize不一样

27:52.860 --> 27:53.860
它们MarkzSize就是

27:53.860 --> 27:55.860
你超过了多少

27:55.860 --> 27:56.860
我要分包

27:56.860 --> 27:57.860
那么这个是你达到了多少

27:57.860 --> 27:58.860
我才要分包

27:58.860 --> 27:59.860
一个是上线

27:59.860 --> 28:01.860
一个是下线

28:01.860 --> 28:02.860
那么你如果说你

28:02.860 --> 28:03.860
没有达到30kb

28:03.860 --> 28:04.860
我就不分包了

28:04.860 --> 28:05.860
因此由于我们的

28:05.860 --> 28:06.860
CommonJet是个代码

28:06.860 --> 28:08.860
肯定没有达到30kb

28:08.860 --> 28:09.860
因此它不分包

28:09.860 --> 28:11.860
那如果说我这样子来

28:11.860 --> 28:12.860
我这样子来

28:12.860 --> 28:14.860
我把它写为0你看一下

28:14.860 --> 28:19.010
把它写为0你看一下

28:19.010 --> 28:25.330
会出现什么效果

28:25.330 --> 28:27.330
稍等

28:27.330 --> 28:29.330
写成0之后

28:29.330 --> 28:30.330
你看一下

28:30.330 --> 28:31.330
是不是就多了一个东西出来了

28:31.330 --> 28:33.330
配级1配级2

28:33.330 --> 28:34.330
对吧

28:34.330 --> 28:35.330
是不是多了一个包出来了

28:35.330 --> 28:37.330
那么这个配级1配级2里边

28:38.330 --> 28:39.330
在哪呢

28:41.330 --> 28:44.330
文件是配级1配级2

28:44.330 --> 28:46.330
配级1点配级2

28:46.330 --> 28:47.330
那么你看一下

28:47.330 --> 28:48.330
Common

28:48.330 --> 28:49.330
是不是有了

28:49.330 --> 28:50.330
我们Common是不知道

28:50.330 --> 28:51.330
到这里边来了

28:51.330 --> 28:52.330
那么我们再看一下

28:52.330 --> 28:54.330
配级1里边有没有Common

28:54.330 --> 28:55.330
是不是没有了

28:55.330 --> 28:56.330
所以说它Common就

28:56.330 --> 28:57.330
提取出去了

28:57.330 --> 28:59.330
是这么一个意思

28:59.330 --> 29:01.330
因为它有这个东西先知

29:01.330 --> 29:02.330
所以说它现在

29:02.330 --> 29:03.330
就分成两个包了

29:03.330 --> 29:04.330
Common也提取出来了

29:04.330 --> 29:06.330
然后第三方的

29:06.330 --> 29:07.330
也提取出来了

29:07.330 --> 29:09.330
就这么个意思

29:09.330 --> 29:11.330
那么这是关于这一块

29:11.330 --> 29:12.330
这一块

29:12.330 --> 29:13.330
那么这两个

29:13.330 --> 29:14.330
我们一般都不用去动它

29:14.330 --> 29:16.330
30kb是一个非常不错的值

29:16.330 --> 29:18.330
我们不用去动它就行了

29:18.330 --> 29:21.640
也就是说

29:21.640 --> 29:22.640
如果说你以后的

29:22.640 --> 29:23.640
自己的元代

29:23.640 --> 29:24.640
你写了很多的元代

29:24.640 --> 29:25.640
当然这个超过30kb

29:25.640 --> 29:26.640
是很正常的

29:26.640 --> 29:27.640
那么有一些

29:27.640 --> 29:28.640
公共的模块

29:28.640 --> 29:29.640
它就会超过30kb

29:29.640 --> 29:30.640
那么公共模块

29:30.640 --> 29:31.640
就会被提出去

29:31.640 --> 29:32.640
是这么个意思

29:32.640 --> 29:34.640
这是关于

29:34.640 --> 29:35.640
这一块

29:35.640 --> 29:36.640
分包了其他一些配置

29:36.640 --> 29:38.640
我们一般不会去改动它

29:38.640 --> 29:39.640
好 现在我们看一下

29:39.640 --> 29:41.640
分包里面一个非常重要的概念

29:41.640 --> 29:43.640
叫做缓存组

29:43.640 --> 29:45.640
因为我们之前的分包策略

29:45.640 --> 29:46.640
像这些分包策略

29:46.640 --> 29:48.640
实际上是全局策略

29:48.640 --> 29:50.640
都是一些全局策略

29:50.640 --> 29:52.640
那么我们其实

29:52.640 --> 29:53.640
它实际上

29:53.640 --> 29:54.640
它在应用这些策略的时候

29:54.640 --> 29:56.640
是基于缓存组的

29:56.640 --> 29:57.640
就是一个组

29:57.640 --> 29:58.640
每个组一个策略

29:58.640 --> 29:59.640
每个组一个策略

29:59.640 --> 30:01.640
是一个一个组织应用的

30:01.640 --> 30:02.640
应用完一个组的策略

30:02.640 --> 30:04.640
再应用下一个组的策略

30:04.640 --> 30:05.640
每个缓存组

30:05.640 --> 30:07.640
提供一套独有的策略

30:07.640 --> 30:09.640
VIPAC按照缓存组的优先级

30:09.640 --> 30:11.640
每个缓存组有优先级

30:11.640 --> 30:13.640
那么你到时候配置缓存组的时候

30:13.640 --> 30:14.640
要配置

30:14.640 --> 30:16.640
那么依次来处理每个缓存组

30:16.640 --> 30:18.640
被缓存组处理过的分包

30:18.640 --> 30:20.640
就不需要再次分包了

30:20.640 --> 30:21.640
默认的情况下

30:21.640 --> 30:23.640
VIPAC提供了两个缓存组

30:23.640 --> 30:25.640
我给大家看一下

30:25.640 --> 30:27.640
把它复制过来

30:27.640 --> 30:28.640
到这边来

30:28.640 --> 30:30.640
你们看得清楚一点

30:30.640 --> 30:32.640
这就是配置缓存组

30:32.640 --> 30:33.640
缓存组是个对象

30:33.640 --> 30:34.640
对象里面每一个属性

30:34.640 --> 30:35.640
就是个缓存组

30:35.640 --> 30:36.640
这是两个缓存组

30:36.640 --> 30:37.640
默认的情况下

30:37.640 --> 30:39.640
它就有这么两个缓存组

30:39.640 --> 30:40.640
就是你不写

30:40.640 --> 30:41.640
它也就有两个

30:41.640 --> 30:42.640
你写了

30:42.640 --> 30:43.640
它还是有这两个

30:43.640 --> 30:45.640
总之它有这两个缓存组

30:45.640 --> 30:46.640
你看一下

30:46.640 --> 30:47.640
为什么它能够

30:47.640 --> 30:49.640
把我们的第三方库

30:49.640 --> 30:51.640
把我们的第三方库

30:51.640 --> 30:53.640
和我们自己的公共代码

30:53.640 --> 30:54.640
它要分开提群了

30:54.640 --> 30:56.640
因为它有两个缓存组

30:56.640 --> 30:58.640
Vendors

30:58.640 --> 31:00.640
就是缓存组的

31:00.640 --> 31:01.640
每个属性的名称

31:01.640 --> 31:03.640
就是缓存组的名称

31:03.640 --> 31:04.640
那么这个名称

31:04.640 --> 31:06.640
会影响到分包的创可名

31:06.640 --> 31:07.640
你看一下这个创可的名字

31:07.640 --> 31:09.640
Vendors点配级

31:09.640 --> 31:10.640
1配级2

31:10.640 --> 31:11.640
那么为什么是Vendors

31:11.640 --> 31:12.640
就是因为它是

31:12.640 --> 31:14.640
有默认的这么一个缓存组

31:14.640 --> 31:15.640
Vendors

31:15.640 --> 31:17.640
它用这一套规则来进行分包

31:17.640 --> 31:18.640
那么这个分包里面

31:18.640 --> 31:19.640
它进行了怎么样的处理呢

31:19.640 --> 31:20.640
它这样处理的

31:20.640 --> 31:21.640
它有这么一个属性

31:21.640 --> 31:22.640
这个缓存组里面

31:22.640 --> 31:23.640
有很多配置

31:23.640 --> 31:24.640
这些配置

31:24.640 --> 31:26.640
全是继承制

31:26.640 --> 31:28.640
权聚配置

31:28.640 --> 31:29.640
如果说你这里不配置的话

31:29.640 --> 31:31.640
它就继承制权聚配置

31:31.640 --> 31:32.640
如果说你配置的话

31:32.640 --> 31:34.640
你就会覆盖权聚配置

31:34.640 --> 31:35.640
但是它里面有一些

31:35.640 --> 31:36.640
自己特殊的配置

31:36.640 --> 31:37.640
我们来看一下

31:37.640 --> 31:39.640
Test是缓存组的特殊配置

31:39.640 --> 31:41.640
它表示一个证则表达式

31:41.640 --> 31:43.640
凡是能够匹配到

31:43.640 --> 31:44.640
这个证则表达式的

31:44.640 --> 31:45.640
就是在前面的条件

31:45.640 --> 31:47.640
都满足的情况下

31:47.640 --> 31:48.640
又匹配到了

31:48.640 --> 31:49.640
这个证则表达式

31:49.640 --> 31:51.640
对它进行单独分包

31:51.640 --> 31:52.640
是这么个意思

31:52.640 --> 31:53.640
那么匹配什么呢

31:53.640 --> 31:54.640
你看这里怎么写的

31:54.640 --> 31:55.640
一个证则表达式

31:55.640 --> 31:56.640
一个中货号就是

31:56.640 --> 31:58.640
可以是一个左鞋杠

31:58.640 --> 31:59.640
可以是一个右鞋杠

31:59.640 --> 32:00.640
因为它要适应

32:00.640 --> 32:01.640
零那个是

32:01.640 --> 32:02.640
或者是

32:02.640 --> 32:03.640
那个Windows的环境

32:03.640 --> 32:05.640
Windows是右鞋杠

32:05.640 --> 32:07.640
零那个是左鞋杠

32:07.640 --> 32:08.640
两个环境都要使用

32:08.640 --> 32:09.640
无论是左鞋杠还是右鞋杠

32:09.640 --> 32:11.640
中间一个都得码就是

32:11.640 --> 32:12.640
然后无论是一个左鞋杠

32:12.640 --> 32:13.640
还是右鞋杠

32:13.640 --> 32:14.640
那么如果说满足

32:14.640 --> 32:15.640
这个证则表达式

32:15.640 --> 32:16.640
就相当于是

32:16.640 --> 32:17.640
这里面的包

32:17.640 --> 32:18.640
你满足了条件

32:18.640 --> 32:20.640
你达到了30KB

32:20.640 --> 32:21.640
你达到了这个冰创式

32:21.640 --> 32:22.640
OK

32:22.640 --> 32:23.640
那么我就要

32:23.640 --> 32:24.640
如果说有满足这个条件

32:24.640 --> 32:26.640
那么我对你进行单独分包

32:26.640 --> 32:28.640
那么这里有一个邮先级

32:28.640 --> 32:29.640
默认值

32:29.640 --> 32:30.640
它这里的写的是副实

32:30.640 --> 32:31.640
默认如果不写的话

32:31.640 --> 32:32.640
默认值就是零

32:33.640 --> 32:34.640
这是一个

32:34.640 --> 32:36.640
所以说了我们的第三方库

32:36.640 --> 32:37.640
你看

32:37.640 --> 32:38.640
是不是因为这个缓存组的存在

32:38.640 --> 32:39.640
它开了一个创可

32:39.640 --> 32:40.640
对吧

32:40.640 --> 32:41.640
Windows配GPG2

32:41.640 --> 32:43.640
是不是开了这么一个创可

32:43.640 --> 32:44.640
开了这个创可

32:44.640 --> 32:45.640
是不是打包出来了一些公众代码

32:45.640 --> 32:47.640
怎么一些query都在这里边

32:47.640 --> 32:48.640
对吧

32:49.640 --> 32:51.640
那么这个D4就是

32:51.640 --> 32:52.640
它的邮先级要低一点

32:52.640 --> 32:53.640
对吧

32:53.640 --> 32:54.640
它的邮先级副20要低一点

32:54.640 --> 32:55.640
那么也就是

32:55.640 --> 32:56.640
它打包完了之后

32:56.640 --> 32:57.640
再去打包它

32:57.640 --> 32:58.640
再去搞定它

32:58.640 --> 32:59.640
那么这个缓存组

32:59.640 --> 33:01.640
你看它改动了这个迷创式

33:01.640 --> 33:03.640
改动了这个迷创式

33:03.640 --> 33:05.640
也就是它必须要有两个引用

33:05.640 --> 33:06.640
那么就相当于是

33:06.640 --> 33:09.640
除了这个里面的东西

33:09.640 --> 33:10.640
除了这个里面的东西

33:10.640 --> 33:11.640
那么其他的东西

33:11.640 --> 33:12.640
就是我们自己写的单码

33:12.640 --> 33:15.640
至少得有两个创可在引用它

33:15.640 --> 33:16.640
那么一个创可在引用的

33:16.640 --> 33:17.640
这个command级也是

33:17.640 --> 33:18.640
它不会打包的

33:18.640 --> 33:20.640
但是你像这个loading module

33:20.640 --> 33:21.640
是一不一样的

33:21.640 --> 33:23.640
那么哪怕只有一个引用

33:23.640 --> 33:24.640
它都可以打包

33:24.640 --> 33:25.640
它都可以打包

33:25.640 --> 33:26.640
因为它这里没有改造

33:26.640 --> 33:28.640
因为它的默认值是1

33:28.640 --> 33:29.640
对不对

33:29.640 --> 33:30.640
那么这里你看

33:30.640 --> 33:31.640
覆盖了对吧

33:31.640 --> 33:32.640
简单看一下

33:32.640 --> 33:33.640
又这是邮先级

33:33.640 --> 33:34.640
它邮先级要低一点

33:34.640 --> 33:35.640
那么这个是什么意思呢

33:35.640 --> 33:36.640
就是已经被分包出去的东西

33:36.640 --> 33:39.640
就不要再重新分离了

33:39.640 --> 33:40.640
就不要再重新分离了

33:40.640 --> 33:41.640
避免重新分离一些

33:41.640 --> 33:44.640
相同的公共模块

33:44.640 --> 33:45.640
OK

33:45.640 --> 33:46.640
那么这就一块

33:46.640 --> 33:47.640
它就是它的默认配置

33:47.640 --> 33:48.640
有两个缓存组

33:48.640 --> 33:50.640
其实绝大部分情况下

33:50.640 --> 33:52.640
缓存组对我们而言

33:52.640 --> 33:54.640
是没有啥太大的意义的

33:54.640 --> 33:55.640
因为它这两个缓存值

33:55.640 --> 33:57.640
已经配置的相当不错了

33:57.640 --> 33:58.640
我们就按照它一个配置

33:58.640 --> 34:00.640
来玩就行了

34:00.640 --> 34:02.640
不需要太过多去管它

34:02.640 --> 34:04.640
但是有的时候

34:04.640 --> 34:05.640
可能会做一些事

34:05.640 --> 34:06.640
比方说我们要抽取一些

34:06.640 --> 34:08.640
公共的样式

34:08.640 --> 34:10.640
这个时候就要缓存出了

34:10.640 --> 34:11.640
因为我们知道

34:11.640 --> 34:12.640
公共的样式

34:12.640 --> 34:13.640
它也是一些模块

34:13.640 --> 34:14.640
也要把它分出去

34:14.640 --> 34:15.640
那么这个时候

34:15.640 --> 34:16.640
就需要缓存出了

34:16.640 --> 34:17.640
比方说举个例子

34:17.640 --> 34:19.640
这里我们写一些样式

34:19.640 --> 34:20.640
比方说我们这里

34:20.640 --> 34:25.640
有一个common.css

34:27.640 --> 34:28.640
保利

34:29.640 --> 34:31.640
白光黑色

34:31.640 --> 34:33.640
一个黑色位置

34:34.640 --> 34:38.640
然后有一个配级1.css

34:39.640 --> 34:40.640
你看这是公共的css

34:40.640 --> 34:41.640
配级1.css

34:41.640 --> 34:42.640
它有这个东西

34:42.640 --> 34:44.640
随便写一个

34:44.640 --> 34:47.640
然后有一个配级2.css

34:48.640 --> 34:49.640
当然两个文件都很小

34:50.640 --> 34:51.640
也没必要分包

34:51.640 --> 34:52.640
但是我们就说明这个道理

34:52.640 --> 34:53.640
是可以分的

34:57.640 --> 34:58.640
那看

34:58.640 --> 34:59.640
我们配级1里边

34:59.640 --> 35:06.640
要用到common.css

35:06.640 --> 35:07.640
要用到这个

35:07.640 --> 35:08.640
那么同样的

35:08.640 --> 35:11.640
它还要用到配级1.css

35:11.640 --> 35:12.640
它又要用到公共的

35:12.640 --> 35:13.640
又要用到自己的

35:13.640 --> 35:18.640
那么配级2里边

35:18.640 --> 35:19.640
那么它用到

35:19.640 --> 35:20.640
中共的

35:20.640 --> 35:21.640
也要用到自己的

35:21.640 --> 35:22.640
对吧

35:22.640 --> 35:23.640
这是我们目前的配置

35:23.640 --> 35:24.640
好

35:24.640 --> 35:25.640
我们最终

35:25.640 --> 35:26.640
这个css

35:26.640 --> 35:27.640
需要生存到文件里边去

35:27.640 --> 35:28.640
对吧

35:28.640 --> 35:29.640
是不是要生存文件

35:29.640 --> 35:30.640
那么我们怎么来生存文件

35:30.640 --> 35:31.640
是不是要利用一个插件

35:33.640 --> 35:34.640
Const

35:34.640 --> 35:39.640
叫做mini.css extract plug-in

35:39.640 --> 35:40.640
我学过了

35:40.640 --> 35:41.640
忘了过后

35:41.640 --> 35:43.640
我又经常会忘

35:43.640 --> 35:44.640
忘了没关系

35:44.640 --> 35:45.640
查一下就行了

35:45.640 --> 35:46.640
这个插件

35:46.640 --> 35:47.640
那么是不是还要配置一下

35:47.640 --> 35:49.640
那么module

35:49.640 --> 35:53.020
这里的rules

35:53.020 --> 35:55.840
test

35:55.840 --> 35:56.840
比方匹配到

35:56.840 --> 35:59.840
凡是匹配到css文件的话

35:59.840 --> 36:01.840
我们use

36:01.840 --> 36:03.840
use

36:03.840 --> 36:05.840
使用两个

36:05.840 --> 36:06.840
两个loader

36:06.840 --> 36:07.840
一个是cssloader

36:07.840 --> 36:09.840
然后使用它之后

36:09.840 --> 36:11.840
再用这个

36:11.840 --> 36:13.840
这个点的loader

36:13.840 --> 36:15.840
那么为了生存文件

36:15.840 --> 36:17.840
我们是不是还在proxy里边

36:17.840 --> 36:18.840
还要去写一个插件

36:18.840 --> 36:19.840
对吧

36:23.940 --> 36:24.940
new

36:24.940 --> 36:26.940
一个mini.css extract plug-in

36:26.940 --> 36:29.940
这里边我们写上一个file-in

36:30.940 --> 36:31.940
file-in的话

36:31.940 --> 36:33.940
我们就用窗口的名字

36:33.940 --> 36:36.940
然后就是

36:36.940 --> 36:38.940
花析吧

36:38.940 --> 36:39.940
css

36:39.940 --> 36:40.940
OK

36:40.940 --> 36:41.940
我们来看一下

36:41.940 --> 36:42.940
它有没有分包呢

36:42.940 --> 36:43.940
对

36:43.940 --> 36:48.110
看一下

36:48.110 --> 36:49.110
它有没有分包

36:49.110 --> 36:54.690
你看一下

36:54.690 --> 36:55.690
是不是没有分包

36:55.690 --> 36:56.690
它的css

36:56.690 --> 36:57.690
是不是只有两个

36:57.690 --> 36:58.690
配级1 css

36:58.690 --> 36:59.690
配级2 css

36:59.690 --> 37:00.690
我们看一下内容

37:00.690 --> 37:01.690
配级1 css

37:01.690 --> 37:02.690
配级2 css

37:02.690 --> 37:03.690
配级2 css

37:03.690 --> 37:05.690
它把一代关系分子一出来

37:05.690 --> 37:06.690
一合并就变成这个样子了

37:06.690 --> 37:07.690
是不是没有分包

37:07.690 --> 37:08.690
那么这个时候

37:08.690 --> 37:10.690
我们就可以利用

37:10.690 --> 37:11.690
catchgroups

37:11.690 --> 37:13.690
给它对css模块

37:13.690 --> 37:15.690
css它也是个模块嘛

37:15.690 --> 37:16.690
对它模块

37:16.690 --> 37:17.690
单独来进行

37:17.690 --> 37:18.690
一个规则处理

37:18.690 --> 37:19.690
策略处理

37:19.690 --> 37:20.690
比方说我们这里

37:20.690 --> 37:22.690
给它取个名字叫做styles

37:23.690 --> 37:24.690
对这一个东西

37:24.690 --> 37:25.690
来进行一些规则

37:25.690 --> 37:26.690
给它加一个分组

37:26.690 --> 37:28.690
那么什么规则呢

37:28.690 --> 37:29.690
首先给它个min size

37:29.690 --> 37:30.690
这个min size一般来说

37:30.690 --> 37:31.690
不用改的

37:31.690 --> 37:32.690
但是以为我这里

37:32.690 --> 37:33.690
实在是难得去写

37:33.690 --> 37:34.690
30kb的文件

37:35.690 --> 37:36.690
不改了吧

37:36.690 --> 37:38.690
然后test

37:38.690 --> 37:40.690
它的就是

37:40.690 --> 37:41.690
匹配的是什么

37:41.690 --> 37:42.690
css

37:42.690 --> 37:44.690
匹配的是这样的模块

37:44.690 --> 37:46.690
匹配的这样的模块

37:46.690 --> 37:47.690
然后呢

37:47.690 --> 37:48.690
我们再看一下

37:48.690 --> 37:49.690
还有什么要配置的呢

37:49.690 --> 37:51.690
还有一个min trunks

37:51.690 --> 37:52.690
只要有两个

37:52.690 --> 37:54.690
创可在用相同的

37:54.690 --> 37:55.690
这个模块

37:55.690 --> 37:57.690
那么对它也要进行分包

37:57.690 --> 37:58.690
那么我们来看一下

37:59.690 --> 38:00.690
运行

38:02.690 --> 38:03.690
我们这里没有写优先级

38:03.690 --> 38:04.690
优先级是0

38:05.690 --> 38:06.690
那么它是0

38:06.690 --> 38:07.690
因为我们知道

38:07.690 --> 38:08.690
之前那个是-10

38:08.690 --> 38:09.690
-20

38:09.690 --> 38:10.690
所以说它是0的话

38:10.690 --> 38:12.690
那么一定是可以分出来了

38:12.690 --> 38:14.690
优先级一定是最高的

38:14.690 --> 38:15.690
所以说先用它

38:15.690 --> 38:16.690
那么可以看到

38:16.690 --> 38:17.690
这里呢

38:17.690 --> 38:18.690
我们可以看到

38:18.690 --> 38:20.690
有多了一个css出来

38:20.690 --> 38:21.690
对吧

38:21.690 --> 38:22.690
是不是这个css

38:22.690 --> 38:23.690
对不对

38:23.690 --> 38:24.690
这个css

38:24.690 --> 38:25.690
那么这个css出来了

38:25.690 --> 38:27.690
是不是把公共代码就提出来了

38:27.690 --> 38:28.690
对吧

38:28.690 --> 38:29.690
那么这里你看

38:29.690 --> 38:30.690
就分出来了

38:30.690 --> 38:32.690
这样子也可以

38:32.690 --> 38:33.690
那么有些同学可以发现

38:33.690 --> 38:35.690
那么这里还多了一个css

38:35.690 --> 38:37.690
还多了这么一个css

38:37.690 --> 38:38.690
那么这也是怎么回事呢

38:38.690 --> 38:39.690
是这样子

38:39.690 --> 38:40.690
它多这个css呢

38:40.690 --> 38:41.690
因为我们知道

38:41.690 --> 38:43.690
这个commoncss里边

38:43.690 --> 38:45.690
是有那个

38:46.690 --> 38:48.690
那个就是开启了这个东西

38:48.690 --> 38:49.690
开启了就是

38:49.690 --> 38:51.690
有可能会开启css module

38:51.690 --> 38:52.690
对吧

38:52.690 --> 38:53.690
它说要导出一个对象

38:53.690 --> 38:54.690
它说要给它一个对象

38:54.690 --> 38:55.690
给它一个对象

38:55.690 --> 38:56.690
因此呢

38:56.690 --> 38:57.690
它的这个gss

38:57.690 --> 38:58.690
是为了

38:58.690 --> 39:00.690
是为了去满足这个css module的

39:00.690 --> 39:01.690
对吧

39:01.690 --> 39:02.690
它是为了满足这个

39:02.690 --> 39:04.690
ok 那么它就分出去了

39:04.690 --> 39:05.690
这是对css打包

39:05.690 --> 39:06.690
那么这个时候

39:06.690 --> 39:08.690
就可以利用一个分组策略

39:08.690 --> 39:09.690
ok

39:10.690 --> 39:11.690
其他的没啥

39:12.690 --> 39:13.690
这里再说一个

39:13.690 --> 39:14.690
就是我们之前

39:14.690 --> 39:16.690
有学那个mini css extract

39:16.690 --> 39:17.690
plugging的时候

39:17.690 --> 39:18.690
当时我没有讲一个东西

39:18.690 --> 39:19.690
就这个东西

39:19.690 --> 39:20.690
这个东西呢

39:20.690 --> 39:21.690
因为当时讲不了

39:21.690 --> 39:22.690
当时没有学习分包

39:22.690 --> 39:23.690
就讲不了

39:23.690 --> 39:24.690
是为了控制分包的

39:24.690 --> 39:25.690
那个文件名字的

39:25.690 --> 39:26.690
不然的话

39:26.690 --> 39:27.690
默认的文件名

39:27.690 --> 39:28.690
就是跟那个trunk的名字

39:28.690 --> 39:29.690
是一样的

39:29.690 --> 39:30.690
加了一个hash

39:30.690 --> 39:31.690
对吧

39:31.690 --> 39:32.690
前面就是trunk的名字

39:32.690 --> 39:33.690
因为我们这里设置的是

39:33.690 --> 39:34.690
设置的文件名是

39:34.690 --> 39:35.690
trunk的名字

39:35.690 --> 39:37.690
加上hash加gss

39:37.690 --> 39:38.690
css呢

39:38.690 --> 39:39.690
css呢

39:39.690 --> 39:40.690
它用的是这个

39:40.690 --> 39:41.690
trunk的名字

39:41.690 --> 39:42.690
加hash加css

39:42.690 --> 39:43.690
对吧

39:43.690 --> 39:44.690
默认是用这个名字

39:44.690 --> 39:45.690
如果说你对公共的那一部分

39:45.690 --> 39:47.690
需要单独来设置名字的话

39:47.690 --> 39:49.690
那么你可以配置一个trunk file

39:49.690 --> 39:51.690
你可以配置这个东西

39:51.690 --> 39:52.690
这个东西

39:52.690 --> 39:53.690
出去的这个包呢

39:53.690 --> 39:55.690
配置一下它的文件名

39:55.690 --> 39:56.690
比方说我们这里

39:56.690 --> 39:58.690
可以用个加前面加个common

39:58.690 --> 39:59.690
然后呢

39:59.690 --> 40:00.690
加上一个hash

40:00.690 --> 40:02.690
gss

40:02.690 --> 40:03.690
好

40:03.690 --> 40:04.690
保存

40:04.690 --> 40:07.260
看一下

40:07.260 --> 40:10.140
印象

40:10.140 --> 40:11.140
好

40:11.140 --> 40:12.140
你看

40:12.140 --> 40:13.140
是不是公共母

40:13.140 --> 40:14.140
公共母会变成这个了

40:14.140 --> 40:15.140
对吧

40:15.140 --> 40:16.140
分割出来了

40:16.140 --> 40:17.140
包的名字

40:17.140 --> 40:18.140
trunk的名字没变

40:18.140 --> 40:19.140
trunk的名字是一样的

40:19.140 --> 40:20.140
trunk的名字还是styles

40:20.140 --> 40:21.140
配起1

40:21.140 --> 40:22.140
配起2

40:22.140 --> 40:23.140
这个是没变的

40:23.140 --> 40:24.140
只不过呢

40:24.140 --> 40:25.140
这个东西变

40:25.140 --> 40:26.140
是这么个意思

40:26.140 --> 40:27.140
OK

40:27.140 --> 40:28.140
这是关于

40:28.140 --> 40:30.140
这个央视的分报

40:30.140 --> 40:31.140
好

40:31.140 --> 40:32.140
接下来是

40:32.140 --> 40:34.140
关于多页应用程序

40:34.140 --> 40:35.140
这里边呢

40:35.140 --> 40:37.140
其实本来应该是没问题的

40:37.140 --> 40:38.140
但是呢

40:38.140 --> 40:39.140
由于这个atmvpackplugin

40:39.140 --> 40:40.140
这个插件呢

40:40.140 --> 40:42.140
它没有那么的完善

40:42.140 --> 40:43.140
导致到这个问题了

40:43.140 --> 40:45.140
因为我们目前呢

40:45.140 --> 40:46.140
单页应用程序

40:46.140 --> 40:47.140
一定是主流

40:47.140 --> 40:48.140
后边呢

40:48.140 --> 40:49.140
你们学5u啊react

40:49.140 --> 40:50.140
都是你开发

40:50.140 --> 40:51.140
单页应用程序的力气

40:51.140 --> 40:52.140
但是呢

40:52.140 --> 40:53.140
有可能呢

40:53.140 --> 40:54.140
你们以后还是会遇到

40:54.140 --> 40:55.140
那么在多页应用的话

40:55.140 --> 40:56.140
比方说我们这里

40:56.140 --> 40:57.140
两个trunk就有可能

40:57.140 --> 40:58.140
会产生两个页面

40:58.140 --> 40:59.140
对吧

40:59.140 --> 41:00.140
两个页面

41:00.140 --> 41:01.140
那么就可能会出现一种情况

41:01.140 --> 41:02.140
哎

41:02.140 --> 41:03.140
我们现在要把多页

41:03.140 --> 41:04.140
这个插件拿起来了

41:04.140 --> 41:06.140
atmv

41:06.140 --> 41:08.140
就是叫做plugin

41:08.140 --> 41:12.140
vpackplugin

41:12.140 --> 41:13.140
require

41:13.140 --> 41:14.140
atmv

41:14.140 --> 41:15.140
vpackplugin

41:15.140 --> 41:16.140
那么这里

41:16.140 --> 41:18.140
把插件应用进去

41:18.140 --> 41:20.140
它就会出现一种情况

41:20.140 --> 41:21.140
因为我们这里

41:21.140 --> 41:22.140
要配置template

41:22.140 --> 41:23.140
比方说这是一个页面

41:23.140 --> 41:26.140
这个页面的模板是在public

41:26.140 --> 41:27.140
index.atmv

41:27.140 --> 41:30.140
那么它生成的

41:30.140 --> 41:31.140
这个页面中

41:31.140 --> 41:32.140
因为我们这里有两个trunk

41:32.140 --> 41:34.140
它也有可能会出现这种情况

41:34.140 --> 41:35.140
这个页面呢

41:35.140 --> 41:36.140
因为是多页应用程序

41:36.140 --> 41:37.140
每个页面呢

41:37.140 --> 41:38.140
它可能应用的

41:38.140 --> 41:39.140
打包的结果不一样

41:39.140 --> 41:40.140
那么这个页面呢

41:40.140 --> 41:42.140
它不希望全部引用进来

41:42.140 --> 41:43.140
你看一下

41:43.140 --> 41:46.710
如果说不做处理的话

41:46.710 --> 41:51.750
我们看一下这个页面

41:51.750 --> 41:52.750
打包完成

41:52.750 --> 41:53.750
页面也生成出来了

41:53.750 --> 41:54.750
我们来看一下这个页面

41:54.750 --> 41:55.750
这个页面呢

41:55.750 --> 41:56.750
它就会做这么一个处理

41:56.750 --> 41:59.750
就是它把所有的CSS

41:59.750 --> 42:00.750
全部给打进来了

42:00.750 --> 42:01.750
配级1,配级2

42:01.750 --> 42:03.750
配级1,配级2的JS

42:03.750 --> 42:05.750
所有的团圈都全部给打进来了

42:05.750 --> 42:06.750
那么这样子呢

42:06.750 --> 42:07.750
可能不是我们想要的

42:07.750 --> 42:08.750
因此呢

42:08.750 --> 42:09.750
我们以前说过

42:09.750 --> 42:10.750
怎么配置呢

42:10.750 --> 42:11.750
是不是配置trunk

42:11.750 --> 42:12.750
配置trunk

42:12.750 --> 42:13.750
那么这个配置trunk

42:13.750 --> 42:14.750
的时候呢

42:14.750 --> 42:15.750
就会出现问题

42:15.750 --> 42:16.750
因为呢

42:16.750 --> 42:17.750
你到底要用哪些

42:17.750 --> 42:18.750
trunk生成的文件呢

42:18.750 --> 42:20.750
是不是除了你自己的trunk之外

42:20.750 --> 42:22.750
配级1的trunk之外

42:22.750 --> 42:24.750
配级1的trunk之外

42:24.750 --> 42:25.750
还要用什么

42:25.750 --> 42:27.750
还要用到这个东西

42:27.750 --> 42:28.750
所以还要用到这个东西

42:28.750 --> 42:29.750
对吧

42:29.750 --> 42:30.750
所以说你配置的时候

42:30.750 --> 42:31.750
就比较麻烦

42:31.750 --> 42:32.750
你还要把这个东西配置进去

42:32.750 --> 42:33.750
这个东西配置进去

42:33.750 --> 42:34.750
这个东西就是

42:34.750 --> 42:35.750
你要用到的trunk

42:35.750 --> 42:36.750
挨摘的配置进去

42:36.750 --> 42:37.750
就特别麻烦

42:37.750 --> 42:38.750
而且呢

42:38.750 --> 42:39.750
这些东西是动态生成的

42:39.750 --> 42:40.750
实在打包过程中

42:40.750 --> 42:41.750
动态生成的trunk

42:41.750 --> 42:42.750
你不去看这个东西

42:42.750 --> 42:43.750
你都不知道

42:43.750 --> 42:44.750
它trunk名字是啥

42:44.750 --> 42:45.750
所以说呢

42:45.750 --> 42:46.750
你到时候配置的时候

42:46.750 --> 42:47.750
就特别麻烦

42:47.750 --> 42:48.750
而且呢

42:48.750 --> 42:49.750
如果说动态生成规则一遍

42:49.750 --> 42:50.750
那么这里呢

42:50.750 --> 42:51.750
要去设一道修改

42:51.750 --> 42:53.750
就特别麻烦

42:53.750 --> 42:54.750
那么目前呢

42:54.750 --> 42:55.750
未拍可

42:55.750 --> 42:56.750
这个插件是没有解决

42:56.750 --> 42:57.750
这个问题的

42:57.750 --> 42:58.750
目前是没有解决这个问题的

42:58.750 --> 42:59.750
但是呢

42:59.750 --> 43:01.750
它的下一个版本会解决

43:01.750 --> 43:02.750
目前那个下一个版本呢

43:02.750 --> 43:03.750
就是新版本

43:03.750 --> 43:05.750
它人人还在测试阶段

43:05.750 --> 43:06.750
还没有发布

43:06.750 --> 43:07.750
所以说呢

43:07.750 --> 43:08.750
你可以暂时的用它

43:08.750 --> 43:09.750
可以暂时的用它

43:09.750 --> 43:10.750
那么怎么安装呢

43:10.750 --> 43:11.750
就是安装

43:11.750 --> 43:12.750
安装的时候呢

43:12.750 --> 43:13.750
加一个at next

43:13.750 --> 43:14.750
这是一个就是

43:14.750 --> 43:16.750
叫做语异化

43:16.750 --> 43:17.750
语异化符号

43:17.750 --> 43:18.750
加上一个net

43:18.750 --> 43:19.750
表示是用它的下一个版本

43:19.750 --> 43:20.750
就是新版本

43:20.750 --> 43:21.750
它正在开

43:21.750 --> 43:22.750
正在测试当中

43:22.750 --> 43:23.750
还没有正式发布

43:23.750 --> 43:24.750
如果说你安装

43:24.750 --> 43:26.750
当然我这里已经安装了

43:26.750 --> 43:27.750
安装这个新版本之后

43:27.750 --> 43:28.750
那就没问题了

43:28.750 --> 43:30.750
那么你只需要用到这个创可

43:30.750 --> 43:31.750
只需要用到这个主

43:31.750 --> 43:33.750
就是我们这里配置的模块

43:33.750 --> 43:34.750
配集

43:34.750 --> 43:36.750
我们这个模块就行了

43:36.750 --> 43:38.750
那么它会把这个模块里边分出去的

43:38.750 --> 43:39.750
这些

43:39.750 --> 43:41.750
分出去的一些创可呢

43:41.750 --> 43:42.750
也会加入进来

43:42.750 --> 43:44.750
看一下吧

43:44.750 --> 43:46.750
我这里没法跟你们演示

43:46.750 --> 43:47.750
就是

43:47.750 --> 43:48.750
不是新版本会怎么样

43:48.750 --> 43:49.750
你们可以直接自行去演示

43:49.750 --> 43:51.750
如果说你不安装新版本

43:51.750 --> 43:53.750
就是个测试版本的话

43:53.750 --> 43:54.750
那么会出现那个问题

43:54.750 --> 43:55.750
到时候它只会引用

43:55.750 --> 43:56.750
配集1.js

43:56.750 --> 43:57.750
其他都没有了

43:57.750 --> 43:58.750
你看

43:58.750 --> 43:59.750
现在就没问题

43:59.750 --> 44:01.750
跟配集1相关的

44:01.750 --> 44:02.750
什么都引用进来了

44:02.750 --> 44:04.750
CSS1.js1.js都引进来了

44:04.750 --> 44:05.750
因为它知道

44:05.750 --> 44:07.750
因为它知道这些创可

44:07.750 --> 44:10.750
它是配集1里边分离出去的

44:10.750 --> 44:11.750
那么它知道

44:11.750 --> 44:12.750
它就会引用进来

44:12.750 --> 44:14.750
但是目前的版本是没有的

44:14.750 --> 44:15.750
这功能

44:15.750 --> 44:16.750
OK

44:16.750 --> 44:17.750
好

44:17.750 --> 44:19.750
最后我们说一下

44:20.750 --> 44:21.750
它的原理

44:21.750 --> 44:22.750
这个

44:22.750 --> 44:23.750
没有办法进行原码分析的

44:23.750 --> 44:24.750
原码分析的

44:24.750 --> 44:25.750
它就太复杂了

44:25.750 --> 44:26.750
复杂到没边了

44:26.750 --> 44:27.750
那么我们这里

44:27.750 --> 44:28.750
就简单说一下

44:28.750 --> 44:29.750
这个原理

44:29.750 --> 44:31.750
其实也比较好理解

44:31.750 --> 44:32.750
简单说一下

44:32.750 --> 44:33.750
它的失路的话

44:33.750 --> 44:35.750
它失路其实没有那么复杂

44:35.750 --> 44:36.750
它怎么来做的

44:36.750 --> 44:37.750
是你看

44:37.750 --> 44:38.750
我们之前

44:38.750 --> 44:39.750
未拍的打包

44:39.750 --> 44:40.750
是不是每一个创可

44:40.750 --> 44:42.750
会生成一个支援清单

44:42.750 --> 44:43.750
对不对

44:43.750 --> 44:44.750
会生成一个支援清单

44:44.750 --> 44:45.750
就是会生成一个表格

44:45.750 --> 44:46.750
每一个创可

44:46.750 --> 44:47.750
会生成一个表格

44:47.750 --> 44:48.750
就是这个创可

44:48.750 --> 44:49.750
里面有哪些模块

44:49.750 --> 44:51.750
模块里面

44:51.750 --> 44:53.750
模块里面的代码是什么

44:53.750 --> 44:54.750
因为我们之前

44:54.750 --> 44:55.750
我再把那个打开

44:55.750 --> 44:57.750
再把以前那个核心功能

44:57.750 --> 44:59.750
最重要的就是这个别意莫乘

45:00.750 --> 45:01.750
看一下吧

45:01.750 --> 45:05.540
对吧

45:05.540 --> 45:06.540
我就看这

45:06.540 --> 45:08.540
是不是每个创可都会生成这个东西

45:08.540 --> 45:09.540
是不是

45:09.540 --> 45:10.540
上面

45:10.540 --> 45:11.540
这

45:11.540 --> 45:12.540
每个创可

45:12.540 --> 45:13.540
会生成这个东西

45:13.540 --> 45:14.540
模块ID

45:14.540 --> 45:15.540
转化后的代码

45:15.540 --> 45:16.540
对吧

45:16.540 --> 45:17.540
转化后的代码就是一个函数

45:17.540 --> 45:18.540
对不对

45:18.540 --> 45:19.540
就是一个函数

45:19.540 --> 45:20.540
每个创可都会生成这么一个东西

45:20.540 --> 45:22.540
每个创可都会生成

45:22.540 --> 45:23.540
对吧

45:23.540 --> 45:24.540
好的

45:24.540 --> 45:25.540
那么它的做法就是

45:25.540 --> 45:26.540
把每个创可生成的东西

45:26.540 --> 45:27.540
读出来

45:27.540 --> 45:28.540
是不是可以读出来

45:28.540 --> 45:30.540
每个创可的别意结果

45:30.540 --> 45:31.540
读出来

45:31.540 --> 45:32.540
然后根据分包策略

45:32.540 --> 45:33.540
看一下

45:33.540 --> 45:34.540
如果说

45:34.540 --> 45:35.540
比方说吧

45:37.540 --> 45:38.540
创可1

45:38.540 --> 45:40.540
它里面用到了模块

45:40.540 --> 45:41.540
就是在哪呢

45:41.540 --> 45:43.540
在load the modules

45:43.540 --> 45:45.540
怎么接query

45:46.540 --> 45:47.540
什么

45:47.540 --> 45:48.540
就因这个事了

45:48.540 --> 45:49.540
我也不知道

45:49.540 --> 45:50.540
它里面

45:50.540 --> 45:51.540
它是一个函数

45:51.540 --> 45:52.540
里面有代码

45:52.540 --> 45:53.540
函数

45:55.540 --> 45:56.540
函数就是这种

45:56.540 --> 45:58.540
就是 module

45:59.540 --> 46:00.540
export

46:01.540 --> 46:02.540
然后是

46:04.540 --> 46:05.540
webpack

46:05.540 --> 46:06.540
require

46:06.540 --> 46:07.540
对吧

46:07.540 --> 46:08.540
每个函数都这样子

46:08.540 --> 46:09.540
对不对

46:09.540 --> 46:11.540
后面就简写个fn

46:11.540 --> 46:12.540
code

46:12.540 --> 46:13.540
code

46:13.540 --> 46:15.540
那么这是接query的代码

46:15.540 --> 46:16.540
要用到这个模块

46:16.540 --> 46:17.540
然后这个创可

46:17.540 --> 46:19.540
它还会用到入口模块

46:19.540 --> 46:20.540
那个模块

46:20.540 --> 46:22.540
就是它的src配级1

46:22.540 --> 46:23.540
对吧

46:23.540 --> 46:24.540
我们这里是配级1

46:25.540 --> 46:26.540
配级1

46:26.540 --> 46:27.540
然后

46:27.540 --> 46:28.540
叫j

46:28.540 --> 46:29.540
那么它是coded

46:29.540 --> 46:30.540
它的代码

46:30.540 --> 46:32.540
然后它还会用到

46:32.540 --> 46:34.540
load the modules

46:34.540 --> 46:35.540
就它这些模块

46:35.540 --> 46:36.540
它都会用到的

46:36.540 --> 46:37.540
load as

46:38.540 --> 46:39.540
load as

46:39.540 --> 46:40.540
因这个事

46:40.540 --> 46:41.540
j

46:41.540 --> 46:42.540
coded

46:42.540 --> 46:43.540
对吧

46:43.540 --> 46:44.540
那么还有什么呢

46:44.540 --> 46:46.540
还有就是load modules

46:46.540 --> 46:47.540
还有什么

46:47.540 --> 46:48.540
src

46:50.540 --> 46:51.540
common

46:51.540 --> 46:52.540
css

46:52.540 --> 46:53.540
这个模块

46:54.540 --> 46:55.540
被loader

46:55.540 --> 46:56.540
转换后的接式代码

46:56.540 --> 46:57.540
对吧

46:57.540 --> 46:58.540
都会用到

46:58.540 --> 46:59.540
好

46:59.540 --> 47:00.540
那么配级2

47:00.540 --> 47:01.540
配级2

47:02.540 --> 47:03.540
看一下

47:04.540 --> 47:05.540
配级2

47:05.540 --> 47:06.540
这里是配级2

47:06.540 --> 47:07.540
对吧

47:07.540 --> 47:08.540
那么这里

47:08.540 --> 47:09.540
也是一样的

47:09.540 --> 47:10.540
那么它一检查

47:10.540 --> 47:11.540
第二步

47:11.540 --> 47:13.540
它就根据分包策略

47:13.540 --> 47:14.540
查到了一下

47:14.540 --> 47:16.540
这里有两个创可

47:16.540 --> 47:17.540
那么这个每个创可里边

47:17.540 --> 47:18.540
有这么多模块

47:18.540 --> 47:19.540
那么这些模块

47:19.540 --> 47:21.540
哪些模块是满足策略

47:21.540 --> 47:22.540
是满足策略的

47:22.540 --> 47:23.540
比如说策略要求

47:23.540 --> 47:24.540
只要有两次被引用

47:24.540 --> 47:25.540
那么这里

47:25.540 --> 47:26.540
所以引用了一次

47:26.540 --> 47:27.540
引用了两次

47:27.540 --> 47:28.540
两次被引用

47:28.540 --> 47:29.540
或者是你的

47:30.540 --> 47:31.540
大小尺寸

47:31.540 --> 47:32.540
超过了盟的值

47:32.540 --> 47:33.540
等等

47:33.540 --> 47:34.540
那么这样子

47:34.540 --> 47:35.540
是不是就

47:35.540 --> 47:36.540
找到

47:36.540 --> 47:37.540
需要分出去了的东西

47:37.540 --> 47:38.540
找到了

47:38.540 --> 47:40.540
那么它找到过后怎么办呢

47:40.540 --> 47:42.540
它就会新建一个创可

47:42.540 --> 47:44.540
它就这里就新建一个创可

47:44.540 --> 47:46.540
创可的名字叫做

47:48.540 --> 47:50.540
讲原论只能这样讲了

47:50.540 --> 47:52.540
要去分析到它具体的代码的话

47:52.540 --> 47:53.540
那就太复杂复杂

47:53.540 --> 47:54.540
放到上天了

47:54.540 --> 47:55.540
common

47:55.540 --> 47:56.540
比方

47:56.540 --> 47:58.540
vendors

47:59.540 --> 48:01.540
这也是根据配置策略来的

48:01.540 --> 48:02.540
vendors

48:02.540 --> 48:03.540
然后配起1

48:03.540 --> 48:05.540
它就新开一个创可

48:05.540 --> 48:06.540
配起2

48:06.540 --> 48:07.540
那么这个创可里边

48:07.540 --> 48:08.540
直接给它3个

48:08.540 --> 48:10.540
3个就是入口文件

48:10.540 --> 48:11.540
直接给它

48:11.540 --> 48:13.540
就自然而然必须去打包了

48:13.540 --> 48:14.540
那么然后

48:14.540 --> 48:16.540
把以前的一些东西

48:16.540 --> 48:18.540
从之前的创可里边删除掉

48:18.540 --> 48:20.540
从之前的创可里边删除掉

48:20.540 --> 48:22.540
这是第二步

48:22.540 --> 48:23.540
第三步

48:23.540 --> 48:24.540
生成新的创可

48:24.540 --> 48:25.540
来打包这些模块

48:25.540 --> 48:26.540
但是

48:26.540 --> 48:27.540
这些

48:27.540 --> 48:28.540
然后从原事模块里边移出

48:28.540 --> 48:29.540
但是这些代码

48:29.540 --> 48:30.540
会影响

48:30.540 --> 48:31.540
会受到影响

48:31.540 --> 48:32.540
就是同时以后

48:32.540 --> 48:33.540
有了这个分包之后

48:33.540 --> 48:34.540
配起1里边

48:34.540 --> 48:35.540
生成的最终代码

48:35.540 --> 48:36.540
和配起2生成最终代码

48:36.540 --> 48:38.540
会多多少少有些差别

48:38.540 --> 48:39.540
跟以前不分包的时候

48:39.540 --> 48:40.540
就有一些差别了

48:40.540 --> 48:41.540
那么这个分

48:41.540 --> 48:43.540
单独分包出来的代码

48:43.540 --> 48:44.540
又有些差别

48:44.540 --> 48:45.540
跟我们以前做的代码分析

48:45.540 --> 48:46.540
就有一些差别了

48:46.540 --> 48:47.540
那么它具体

48:47.540 --> 48:48.540
会形成什么样的代码结构呢

48:48.540 --> 48:49.540
它是这样子

48:49.540 --> 48:51.540
它是让分包里边的代码

48:51.540 --> 48:52.540
去加入一个全局变量

48:52.540 --> 48:54.540
它是让这个分包里边

48:54.540 --> 48:55.540
就是这个分包最终打

48:55.540 --> 48:56.540
最终合并

48:56.540 --> 48:57.540
合并这些包

48:57.540 --> 48:58.540
打包出来一个介石

48:58.540 --> 48:59.540
那么这个介石里边

48:59.540 --> 49:00.540
它去

49:00.540 --> 49:01.540
添加了一个全局变量

49:01.540 --> 49:03.540
就是注入到温度里边

49:03.540 --> 49:04.540
你看一下吧

49:04.540 --> 49:07.910
在这里

49:08.910 --> 49:09.910
我们看一下分包

49:09.910 --> 49:12.350
你看

49:12.350 --> 49:13.350
是不是在检查

49:13.350 --> 49:14.350
一个全局变量

49:14.350 --> 49:15.350
对吧

49:15.350 --> 49:16.350
这个全局变的名称叫做

49:16.350 --> 49:17.350
WAPI-JSNP

49:17.350 --> 49:19.350
我们来看一下吧

49:19.350 --> 49:20.350
打开

49:20.350 --> 49:21.350
打开

49:21.350 --> 49:22.350
我们一样是原因

49:22.350 --> 49:23.350
打开一面

49:23.350 --> 49:24.350
我们看一下

49:24.350 --> 49:25.350
它其实就是个竖竹

49:25.350 --> 49:26.350
它会

49:26.350 --> 49:27.350
这个分包的动作

49:27.350 --> 49:28.350
就是分出来的包

49:28.350 --> 49:29.350
它会往这个竖竹里边

49:29.350 --> 49:30.350
它代码

49:30.350 --> 49:31.350
跟以前的代码

49:31.350 --> 49:32.350
就不太一样了

49:32.350 --> 49:33.350
它会往竖竹里边

49:33.350 --> 49:34.350
加入一些

49:34.350 --> 49:35.350
就加入我们这里的

49:35.350 --> 49:36.350
每一个模块

49:36.350 --> 49:37.350
就这个包里边的

49:37.350 --> 49:38.350
每一个模块的代码

49:38.350 --> 49:39.350
你看一下吧

49:40.350 --> 49:41.350
这里边有什么东西

49:41.350 --> 49:42.350
它是个竖竹

49:43.350 --> 49:44.350
竖竹的第一项

49:44.350 --> 49:45.350
是其中

49:47.350 --> 49:48.350
这个是CSS

49:48.350 --> 49:49.350
打包出来的

49:49.350 --> 49:50.350
CSS的代码

49:50.350 --> 49:51.350
那么这个是GS的

49:53.350 --> 49:54.350
是GS的

49:56.350 --> 49:57.350
第一个是模块ID

49:57.350 --> 49:58.350
这是模块ID

49:58.350 --> 49:59.350
那么这里

50:00.350 --> 50:01.350
你看

50:01.350 --> 50:03.350
这其中有Jekarade

50:03.350 --> 50:04.350
有Lowdash的

50:04.350 --> 50:05.350
还有两个

50:05.350 --> 50:06.350
是跟WAPI相关的

50:06.350 --> 50:07.350
因为WAPI

50:07.350 --> 50:08.350
Jekarade有Lowdash

50:08.350 --> 50:09.350
它里边有

50:09.350 --> 50:10.350
会用到

50:10.350 --> 50:11.350
它在打包的时候

50:11.350 --> 50:12.350
会用到WAPI里边的东西

50:12.350 --> 50:13.350
也会有依赖

50:13.350 --> 50:14.350
所以说也该加进去了

50:14.350 --> 50:15.350
一个加进去了

50:15.350 --> 50:16.350
那么这些东西

50:16.350 --> 50:17.350
都是

50:17.350 --> 50:18.350
总之这个竖竹里边

50:18.350 --> 50:19.350
它就包含了

50:20.350 --> 50:21.350
分包出去过后的

50:21.350 --> 50:22.350
这些东西

50:22.350 --> 50:23.350
它会把它加入到竖竹中

50:23.350 --> 50:25.350
那么既然加入到竖竹中之后

50:25.350 --> 50:26.350
在原始包里边

50:26.350 --> 50:27.350
就在我们这个包里边

50:27.350 --> 50:28.350
是不是可以从竖竹里边

50:28.350 --> 50:29.350
取出来这些函数

50:29.350 --> 50:30.350
然后去雕容它

50:31.350 --> 50:33.350
这些包就不用去写到

50:33.350 --> 50:35.350
这个两个模块里边去了

50:35.350 --> 50:36.350
也就是简单的说

50:36.350 --> 50:37.350
它往竖竹里边加东西

50:37.350 --> 50:39.350
它在从竖竹里边读东西

50:39.350 --> 50:40.350
它往竖竹里边加啥

50:40.350 --> 50:41.350
加模块代码

50:41.350 --> 50:42.350
那么这个从竖竹里边

50:42.350 --> 50:43.350
去读模块代码

50:43.350 --> 50:45.350
那么通过这样的原理

50:45.350 --> 50:46.350
通过这样的思路

50:46.350 --> 50:47.350
来去完成的

50:47.350 --> 50:49.350
就是当然它的细节里边

50:49.350 --> 50:51.350
还有很多丰富的细节

50:51.350 --> 50:52.350
不过我们知道它的

50:52.350 --> 50:54.350
主线原理就可以了

50:54.350 --> 50:55.350
OK 这是关于

50:55.350 --> 50:56.350
自动分包策率

50:56.350 --> 50:57.350
其实对于我们

50:57.350 --> 50:58.350
平时来说配置的话

50:58.350 --> 50:59.350
配置成这个样子

50:59.350 --> 51:00.350
也就差不多了

51:01.350 --> 51:02.350
好了 这是关于分包

