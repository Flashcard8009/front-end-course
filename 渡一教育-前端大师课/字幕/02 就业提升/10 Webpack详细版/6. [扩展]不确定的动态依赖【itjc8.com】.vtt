WEBVTT

00:00.690 --> 00:05.690
这一张补充与案例给大家补充一些知识

00:05.690 --> 00:08.690
顺便把之前挖的坑给大家填上

00:08.690 --> 00:13.690
之前不是说在那个VIPAC里边我要去讲很多案例吗

00:13.690 --> 00:16.690
一直没有给大家补 忙别的事情

00:16.690 --> 00:20.690
这一次给大家补上 把这个改一下

00:21.690 --> 00:26.690
你我们之前讲VIPAC已经过了一段时间了

00:26.690 --> 00:31.690
现在的VIPAC5正在紧锣密补的制作当中

00:31.690 --> 00:35.690
不是说我 官方正在紧锣密补的制作当中

00:35.690 --> 00:37.690
那么等它出来正式发布了之后

00:37.690 --> 00:40.690
VIPAC5会给大家重新更新

00:40.690 --> 00:43.690
会讲一些跟VIPAC4的一些区别

00:43.690 --> 00:46.690
那么这里我们首先第1节课补充一下

00:46.690 --> 00:50.690
关于不确定的动态宜兰

00:50.690 --> 00:52.690
听这个名字就好像很高端 对吧

00:52.690 --> 00:55.690
那么我们来说一下它是一个什么样的情况

00:55.690 --> 00:59.690
是有的时候我们可能依赖关系是这样子的

00:59.690 --> 01:02.690
一方说 咱们的index.js里边

01:02.690 --> 01:05.690
我先看一下配置吧 这拍个点接式里边啥都没有

01:05.690 --> 01:09.690
VIPACCD 啥都没有 配置很简单

01:09.690 --> 01:11.690
有个war2 有个source map

01:11.690 --> 01:14.690
这些都是我为了便于我们分析的模式

01:14.690 --> 01:19.690
没有了 然后在index.js里边有可能我们的依赖是这样子的

01:19.690 --> 01:23.690
怎么样子的呢 就是比方说咱们Utl里边不是有Adder.js吗

01:24.690 --> 01:26.690
来做这么一个例子

01:26.690 --> 01:29.690
然后在index.js里边它有可能会依赖A

01:29.690 --> 01:31.690
有可能不会依赖A

01:31.690 --> 01:34.690
什么情况呢 比方说我们这样子写

01:34.690 --> 01:37.690
master.radle小于0.5

01:37.690 --> 01:41.690
然后我们在这里边来去得到一个require

01:41.690 --> 01:44.690
Utl

01:44.690 --> 01:46.690
那么我想请问大家

01:46.690 --> 01:50.690
这样子 然后让VIPAC4进行打包

01:50.690 --> 01:53.690
打包之后呢 它里边会不会包含A

01:53.690 --> 01:57.060
这是考一个基础知识啊

01:57.060 --> 01:59.060
这是我们之前微拍讲过的

01:59.060 --> 02:00.060
会不会包含A呢

02:00.060 --> 02:02.060
是不是一定会包含A

02:02.060 --> 02:05.060
对吧 这个东西叫做动态依赖

02:09.060 --> 02:11.060
什么叫做动态依赖的 就是

02:11.060 --> 02:14.060
它这个依赖关系啊 它只有运行代码

02:14.060 --> 02:17.060
才能确定它的依赖关系

02:17.060 --> 02:20.060
它这个代码不运行 它无法确定依赖关系

02:20.060 --> 02:22.060
你看这个代码 如果说这个master.radle

02:22.060 --> 02:24.060
它不运行出来 你怎么知道它是多少

02:24.060 --> 02:26.060
你也不清楚它到底是多少

02:26.060 --> 02:28.060
所以说呢 它只有运行的过后才知道

02:28.060 --> 02:30.060
是不是小于0.5

02:30.060 --> 02:32.060
如果说小于0.5的话 我才会去依赖它

02:32.060 --> 02:34.060
那么面对动态依赖呢

02:34.060 --> 02:36.060
微拍是能够处理的

02:36.060 --> 02:38.060
它怎么处理的 它才不管那么多

02:38.060 --> 02:40.060
它只要看到有依赖 那我就认为依赖它

02:40.060 --> 02:42.060
尽管呢 我们按理说

02:42.060 --> 02:44.060
这个代码是要在运行过程中

02:44.060 --> 02:46.060
我才能确定要不要把这个A夹出来

02:46.060 --> 02:48.060
但是微拍没办法

02:48.060 --> 02:50.060
它不会运行我们的代码 对吧

02:50.060 --> 02:52.060
微拍它会分析我们的代码结构

02:52.060 --> 02:54.060
但是它不会运行我们的代码

02:54.060 --> 02:56.060
因此呢 听过微拍打包出来过后

02:56.060 --> 02:58.060
一定有这个A

02:58.060 --> 03:00.060
那么对于动态依赖

03:00.060 --> 03:02.060
纯粹的动态依赖呢 它是可以处理的

03:02.060 --> 03:04.060
这是我们之前讲过的

03:04.060 --> 03:06.060
然后我们打开中桩看一下

03:06.060 --> 03:08.060
这边呢 我们使用NPS

03:08.060 --> 03:10.060
微拍的 运行一下

03:10.060 --> 03:12.060
好 运行完了过后呢

03:12.060 --> 03:14.060
我们在电视部落下面去看一下这个Made.js

03:14.060 --> 03:16.060
你看这里边是不是有这个A

03:16.060 --> 03:18.060
非常非常正常的一个代码

03:18.060 --> 03:20.060
之前我们也分析过

03:20.060 --> 03:22.060
有这个Made.js 这个Made.js 这个Made.js

03:22.060 --> 03:24.060
它会把它夹出来

03:24.060 --> 03:26.060
这是我们之前讲的 它做语法分析的时候

03:26.060 --> 03:28.060
它发现有这个一代关系

03:28.060 --> 03:30.060
它不管你再不再判断里面

03:30.060 --> 03:32.060
再不再循环里面 无所谓

03:32.060 --> 03:34.060
甚至你在一个函数里面 它也无所谓

03:34.060 --> 03:36.060
什么叫做不确定的动态依赖呢

03:36.060 --> 03:38.060
大家再来看

03:38.060 --> 03:40.060
下面这个事情就有点意思了

03:40.060 --> 03:42.060
下面这个事情是这样子的

03:42.060 --> 03:44.060
我这个A

03:44.060 --> 03:46.060
它可能会是这样子写的

03:46.060 --> 03:48.060
你看着

03:48.060 --> 03:50.060
可能是来自于用户的一个输入

03:50.060 --> 03:52.060
marge

03:52.060 --> 03:54.060
document

03:54.060 --> 03:56.060
get element

03:56.060 --> 03:58.060
比方说有页面

03:58.060 --> 04:00.060
我们现在虽然说没有页面

04:00.060 --> 04:02.060
但是比方说有页面

04:02.060 --> 04:04.060
那么我们一个页面上有一个文本框

04:04.060 --> 04:06.060
有一个文本框

04:06.060 --> 04:08.060
然后根据文本框的值

04:08.060 --> 04:10.060
来得到这个模块的名字

04:10.060 --> 04:12.060
我举一个非常非常极端的例子

04:12.060 --> 04:14.060
这个地方我们拼接的是什么呢

04:14.060 --> 04:16.060
拼接的是一个模块名字

04:16.060 --> 04:18.060
这就有意思了

04:18.060 --> 04:20.060
那么这个时候呢

04:20.060 --> 04:22.060
你说它能分析出来吗

04:22.060 --> 04:24.060
你把它逼疯了 它都没法分析出来

04:24.060 --> 04:26.060
因为它打包的时候

04:26.060 --> 04:28.060
用户根本就没有输入

04:28.060 --> 04:30.060
它没有输入 它就无法确定

04:30.060 --> 04:32.060
它到底要一旦什么模块

04:32.060 --> 04:34.060
这样子叫做不确定的动态依赖

04:34.060 --> 04:36.060
它是动态依赖

04:36.060 --> 04:38.060
它要运行的时候

04:38.060 --> 04:40.060
才能确定依赖关系

04:40.060 --> 04:42.060
那关系是不确定的 无法确定

04:42.060 --> 04:44.060
那么这就是不确定的动态依赖

04:44.060 --> 04:46.060
那么面对不确定的动态依赖怎么办呢

04:46.060 --> 04:48.060
微pike呢

04:48.060 --> 04:50.060
它做法是非常非常粗暴的

04:50.060 --> 04:52.060
咱们来看一下 它怎么来做的

04:52.060 --> 04:54.060
这里呢 由于我加了watch

04:54.060 --> 04:56.060
它已经重新打包了

04:56.060 --> 04:58.060
我们来看一下媒体的解释里面

04:58.060 --> 05:00.060
你看一下

05:00.060 --> 05:02.060
这个下面呢 它把A导入进来了

05:02.060 --> 05:04.060
看呗 是不是导入了A

05:04.060 --> 05:06.060
是不是导入了B

05:06.060 --> 05:08.060
是不是导入了C

05:08.060 --> 05:10.060
还导入了Utl.index.js

05:10.060 --> 05:12.060
是不是也导入进来了

05:12.060 --> 05:14.060
它没有办法

05:14.060 --> 05:16.060
它不敢不导入进来

05:16.060 --> 05:18.060
如果说它不导入进来的话

05:18.060 --> 05:20.060
是不是导入了我们打包的结果里面

05:20.060 --> 05:22.060
有模块有缺失

05:22.060 --> 05:24.060
那万一用户输入的是

05:24.060 --> 05:26.060
比方说是C.js

05:26.060 --> 05:28.060
那么是不是导包有缺失

05:28.060 --> 05:30.060
那么它这种做法呢

05:30.060 --> 05:32.060
它就是 它是怎么来处理的呢

05:32.060 --> 05:34.060
它看到你这里来用支付出来拼接

05:34.060 --> 05:36.060
它是通过语法分析的

05:36.060 --> 05:38.060
它的模块 它一定在这个目录下面

05:38.060 --> 05:40.060
是不是一定在这个目录下面

05:40.060 --> 05:42.060
而如果说一定在这个目录下面

05:42.060 --> 05:43.060
那么怎么办呢

05:43.060 --> 05:45.060
它就快把这个目录下面的所有东西

05:45.060 --> 05:47.060
全部给生成到打包结果

05:47.060 --> 05:49.060
保证在运行的时候呢

05:49.060 --> 05:51.060
可以得到这个数据

05:51.060 --> 05:53.060
面儿的意思吧

05:53.060 --> 05:55.060
它是用这种方式来处理的

05:55.060 --> 05:57.060
而且它在打包结果里面呢

05:57.060 --> 05:59.060
还给你生成了这么一个东西

05:59.060 --> 06:01.060
给你生成这么一个函数

06:01.060 --> 06:03.060
这个函数呢 它就记录了这个模块里边

06:03.060 --> 06:05.060
它有可能会使用了导入

06:05.060 --> 06:06.060
用屌鞋杠导入

06:06.060 --> 06:07.060
就导入这个模块的

06:07.060 --> 06:09.060
跟目录下面的硬带个手的接式

06:09.060 --> 06:10.060
有可能会导入

06:10.060 --> 06:11.060
A 那么就是默认就是

06:11.060 --> 06:13.060
它有个对应关系啊

06:13.060 --> 06:14.060
对应这个模块的具体地址

06:14.060 --> 06:16.060
它有可能会使用了导入

06:16.060 --> 06:18.060
它就会给全部给记录在这儿

06:18.060 --> 06:20.060
它是不是用这种方式来处理的

06:20.060 --> 06:22.060
那如果说我连这个前面都没显了

06:22.060 --> 06:23.060
那又会怎么样呢

06:23.060 --> 06:24.060
好 咱们保存一下

06:24.060 --> 06:26.060
看点媒典接式

06:26.060 --> 06:27.060
那么这个时候呢

06:27.060 --> 06:28.060
你看 是不是

06:28.060 --> 06:29.060
这个时候呢

06:29.060 --> 06:30.060
它就不会给你生成了

06:30.060 --> 06:32.060
它不敢 它就不敢处理的

06:32.060 --> 06:33.060
它真不知道该怎么处理的

06:33.060 --> 06:34.060
你看那意思吧

06:34.060 --> 06:36.060
它现在是怎么敢处理的

06:36.060 --> 06:37.060
没有办法处理的

06:37.060 --> 06:38.060
所以说我们

06:38.060 --> 06:41.060
如果说变成这种不确定的动态依赖

06:41.060 --> 06:42.060
那么怎么办呢

06:42.060 --> 06:43.060
我们应该

06:43.060 --> 06:46.060
手动的要确定这个依赖的位置

06:46.060 --> 06:48.060
大概位置在怎么地方

06:48.060 --> 06:50.060
那么确定了一个大概位置之后

06:50.060 --> 06:52.060
通过这种制补刷拼接

06:52.060 --> 06:53.060
会被外派给分析出来

06:53.060 --> 06:55.060
它分析出来之后呢

06:55.060 --> 06:57.060
它又会形成到打包结果里边

06:57.060 --> 06:59.060
把这个所有的依赖关系形成到里边

06:59.060 --> 07:00.060
那么我们先讲一下

07:00.060 --> 07:01.060
它的本质是什么

07:01.060 --> 07:02.060
这句话的本质啊

07:02.060 --> 07:03.060
它实际上是这样子写的

07:03.060 --> 07:05.060
就是它会把这个代码的

07:05.060 --> 07:06.060
给你转换一下

07:06.060 --> 07:08.060
转换成另外一种形式

07:08.060 --> 07:09.060
什么样的形式呢

07:09.060 --> 07:11.060
它会转换成这种形式

07:11.060 --> 07:12.060
你看一下

07:12.060 --> 07:13.060
上面那个代码

07:13.060 --> 07:15.060
它实际上会给你转换成这种形式

07:15.060 --> 07:17.060
就是这样

07:17.060 --> 07:18.060
就这句话

07:18.060 --> 07:20.060
还可以转换成Require

07:20.060 --> 07:22.060
里边有个函数叫context

07:22.060 --> 07:23.060
叫做上下文

07:23.060 --> 07:25.060
就是我不能确定我到底在哪

07:25.060 --> 07:27.060
但是我大概确定了一个位置

07:27.060 --> 07:29.060
那么大概的位置在哪呢

07:29.060 --> 07:31.060
在这个UTO

07:31.060 --> 07:33.060
UTO是里边

07:33.060 --> 07:34.060
我们在这个位置

07:34.060 --> 07:35.060
好 咱们保存

07:35.060 --> 07:37.060
保存了之后你看一下

07:37.060 --> 07:38.060
这个打包结构

07:38.060 --> 07:39.060
是不是一样的

07:39.060 --> 07:40.060
对不对

07:40.060 --> 07:41.060
你看一下是不是一样的

07:41.060 --> 07:42.060
打包出来

07:42.060 --> 07:43.060
是不是有了

07:43.060 --> 07:44.060
必点解释有了

07:44.060 --> 07:45.060
谁点解释

07:45.060 --> 07:46.060
是不是都有了

07:46.060 --> 07:47.060
打包结构里边都有了

07:47.060 --> 07:48.060
那么这个

07:48.060 --> 07:49.060
它其实

07:49.060 --> 07:50.060
其实这句话

07:50.060 --> 07:51.060
它分析出来过后呢

07:51.060 --> 07:53.060
它就可以把它变成这条语句

07:53.060 --> 07:54.060
帮你去

07:54.060 --> 07:55.060
帮你去运行一下

07:55.060 --> 07:56.060
这条语句

07:56.060 --> 07:57.060
那么这条语句运行过后

07:57.060 --> 07:58.060
这条语句仅在

07:58.060 --> 07:59.060
为派的中留效

07:59.060 --> 08:00.060
仅在

08:00.060 --> 08:01.060
为派

08:01.060 --> 08:04.060
运行过程中留效

08:04.060 --> 08:05.060
那么运

08:05.060 --> 08:06.060
打包完了过后

08:06.060 --> 08:07.060
它有没有东西呢

08:07.060 --> 08:08.060
就说require

08:08.060 --> 08:09.060
它有没有这个require的contact

08:09.060 --> 08:10.060
根本就没有了

08:10.060 --> 08:11.060
对吧

08:11.060 --> 08:12.060
只是我们在

08:12.060 --> 08:13.060
打包的过程中

08:13.060 --> 08:14.060
它会有效的

08:14.060 --> 08:15.060
那么它是告诉为派

08:15.060 --> 08:16.060
你把情力

08:16.060 --> 08:18.060
把这个目录下面的东西

08:18.060 --> 08:19.060
帮我进行打包

08:19.060 --> 08:20.060
这个函数呢

08:20.060 --> 08:21.060
有多个函数

08:21.060 --> 08:22.060
第一个函数呢

08:22.060 --> 08:23.060
是缺定一个目录

08:23.060 --> 08:25.060
告诉我哪一个目录下面的模块

08:25.060 --> 08:26.060
都要进

08:26.060 --> 08:27.060
都要放放到打包结构里边

08:27.060 --> 08:29.060
第二个函数呢是

08:30.060 --> 08:32.060
是一个物耳直

08:32.060 --> 08:34.060
如果说是甜的是Q

08:34.060 --> 08:35.060
我们一个个说吧

08:35.060 --> 08:36.060
打个注射

08:36.060 --> 08:39.060
参数一表示目录

08:39.060 --> 08:41.060
哪个模块下

08:41.060 --> 08:44.060
哪个目录中

08:44.060 --> 08:46.060
这就可是个扩展课程

08:46.060 --> 08:47.060
顺便说一下

08:47.060 --> 08:48.060
就算你不听的话

08:48.060 --> 08:49.060
也没事

08:49.060 --> 08:52.060
哪个目录中的模块

08:53.060 --> 08:57.060
需要添加到打包结构

08:57.060 --> 08:58.060
这个我contact的时候

08:58.060 --> 08:59.060
这个我contact的时候

08:59.060 --> 09:00.060
这个函数是告诉

09:00.060 --> 09:01.060
是webhack的

09:01.060 --> 09:02.060
以后在里面学习了

09:02.060 --> 09:03.060
loader.js里边

09:03.060 --> 09:04.060
loader.js的时候

09:04.060 --> 09:05.060
根本没有这个函数的

09:05.060 --> 09:07.060
这webhack里边在加的

09:07.060 --> 09:09.060
是哪些模块需要

09:09.060 --> 09:10.060
添加到打包结构里边

09:10.060 --> 09:11.060
第二个参数

09:11.060 --> 09:13.060
参数二

09:13.060 --> 09:15.060
表示一个就是

09:15.060 --> 09:16.060
是否

09:16.060 --> 09:18.060
第一规寻找

09:18.060 --> 09:19.060
寻找指目录

09:19.060 --> 09:22.460
什么意思呢

09:22.460 --> 09:23.460
就是说

09:23.460 --> 09:24.460
如果说这个目录下面

09:24.460 --> 09:25.460
它还有指目录

09:25.460 --> 09:26.460
是不是要把指目录下面的东西

09:26.460 --> 09:28.460
也要加入到打包结构

09:29.460 --> 09:31.460
摸认为

09:31.460 --> 09:32.460
摸认好像是force来说

09:32.460 --> 09:33.460
我也忘了

09:33.460 --> 09:34.460
把大家写上吧

09:34.460 --> 09:35.460
如果说为

09:37.460 --> 09:39.460
表示

09:40.460 --> 09:44.460
需要寻找指目录

09:44.460 --> 09:45.460
它就不行

09:45.460 --> 09:46.460
你是把这个目录下面

09:46.460 --> 09:47.460
还要包括它的指目录下面的东西

09:47.460 --> 09:49.460
也要放到打包结构

09:49.460 --> 09:52.460
参数三

09:52.460 --> 09:54.460
参数三是什么呢

09:54.460 --> 09:55.460
是将

09:56.460 --> 09:58.460
就是一个证则表达是

10:01.460 --> 10:02.460
就是匹配

10:02.460 --> 10:03.460
如果说不写的话

10:03.460 --> 10:04.460
就匹配所有的

10:04.460 --> 10:05.460
就是这个文件讲

10:05.460 --> 10:06.460
里面所有的东西

10:06.460 --> 10:07.460
都把它形成模块

10:07.460 --> 10:08.460
进入打包结构

10:08.460 --> 10:10.460
不管你是有什么图片

10:10.460 --> 10:12.460
都要形成打包结构

10:12.460 --> 10:13.460
不要说我们这里

10:13.460 --> 10:14.460
添加个CSS去看一下

10:14.460 --> 10:15.460
1.CSS

10:17.460 --> 10:18.460
好

10:18.460 --> 10:19.460
这边保存

10:19.460 --> 10:20.460
保存看一下打包

10:20.460 --> 10:21.460
我们看一下这边

10:21.460 --> 10:23.460
CSS

10:24.460 --> 10:25.460
CSS

10:25.460 --> 10:26.460
你看

10:26.460 --> 10:27.460
是不是也到打包结构里面了

10:27.460 --> 10:28.460
当然你如果说

10:28.460 --> 10:29.460
这里边你写上一些

10:29.460 --> 10:30.460
真实的CSS代码

10:30.460 --> 10:31.460
是不是要爆错

10:31.460 --> 10:32.460
因为我们现在没有

10:32.460 --> 10:33.460
CSS楼凳

10:33.460 --> 10:34.460
对不对

10:34.460 --> 10:35.460
是不是要爆错的

10:35.460 --> 10:36.460
爆存

10:36.460 --> 10:37.460
你看

10:37.460 --> 10:38.460
打包是不是爆错了

10:38.460 --> 10:39.460
CSS解析不了

10:39.460 --> 10:40.460
当然你这里

10:40.460 --> 10:41.460
就需要去添加楼凳了

10:41.460 --> 10:43.460
你说这么个意思

10:44.460 --> 10:45.460
那么现在

10:45.460 --> 10:46.460
我们在这边再来看

10:46.460 --> 10:47.460
就证则表

10:47.460 --> 10:49.460
就是证则表达是

10:49.460 --> 10:52.460
凡是匹配的

10:53.460 --> 10:55.460
才会加入到

10:55.460 --> 10:56.460
打包结构

10:56.460 --> 10:57.460
比方说

10:57.460 --> 10:58.460
我们刚才这里

10:58.460 --> 10:59.460
不是有CSS吗

10:59.460 --> 11:00.460
如果说CSS

11:00.460 --> 11:01.460
我不想加

11:01.460 --> 11:02.460
我只想加GS怎么办

11:02.460 --> 11:03.460
那么我们只

11:03.460 --> 11:04.460
就需要写个证则表达是

11:04.460 --> 11:05.460
比方说

11:05.460 --> 11:06.460
我们这里可以这样写

11:06.460 --> 11:07.460
第二

11:07.460 --> 11:08.460
GS结尾

11:08.460 --> 11:09.460
保存

11:09.460 --> 11:10.460
好在看Made.GS里面

11:10.460 --> 11:11.460
它就不会有CSS了

11:11.460 --> 11:13.460
咱们来把它折叠一下

11:14.460 --> 11:15.460
印这个是OK

11:17.460 --> 11:18.460
然后

11:18.460 --> 11:20.460
A.GS OK

11:20.460 --> 11:21.460
B.GS OK

11:21.460 --> 11:23.460
C.GS OK

11:23.460 --> 11:24.460
没问题吧

11:24.460 --> 11:25.460
你看它只有GS

11:25.460 --> 11:26.460
没有CSS

11:26.460 --> 11:27.460
那么它就是

11:27.460 --> 11:28.460
其实我们刚才这种

11:28.460 --> 11:29.460
不确定的动态依赖

11:29.460 --> 11:30.460
那么它就会

11:30.460 --> 11:31.460
形成这种方式

11:31.460 --> 11:32.460
来给你调用

11:32.460 --> 11:33.460
调用之后

11:33.460 --> 11:34.460
把这个目录下面的

11:34.460 --> 11:36.460
按照要求的满足的

11:36.460 --> 11:37.460
全部给你

11:37.460 --> 11:38.460
弄到打包结构

11:39.460 --> 11:40.460
好

11:40.460 --> 11:41.460
然后我们再说一下

11:41.460 --> 11:42.460
这个Context

11:42.460 --> 11:43.460
它反回什么

11:43.460 --> 11:45.460
实际上运行这个函数

11:45.460 --> 11:46.460
你看一下我们打包结构

11:48.780 --> 11:49.780
印这个是里面

11:50.780 --> 11:51.780
它实际上

11:51.780 --> 11:52.780
我们这边在

11:52.780 --> 11:53.780
调用这个Context的时候

11:53.780 --> 11:54.780
它在这边生成的代码

11:54.780 --> 11:55.780
还是一个Require

11:55.780 --> 11:56.780
它Require谁呢

11:56.780 --> 11:57.780
Require这个东西

11:58.780 --> 11:59.780
这个东西是什么东西

11:59.780 --> 12:00.780
你看一下

12:00.780 --> 12:02.780
这个目录下面的同步

12:02.780 --> 12:03.780
默认都是同步

12:03.780 --> 12:04.780
我们一步就不讲

12:04.780 --> 12:05.780
一步的情况比较少

12:05.780 --> 12:07.780
Request表示我要

12:07.780 --> 12:08.780
查询它的止目录

12:08.780 --> 12:09.780
是不是我们这里的配置

12:10.780 --> 12:11.780
这是我们的目录

12:11.780 --> 12:12.780
查询止目录

12:12.780 --> 12:13.780
你看这是我们的目录

12:13.780 --> 12:14.780
查询止目录

12:14.780 --> 12:15.780
然后我们的证则表达是

12:15.780 --> 12:16.780
你看是不是写到后边了

12:16.780 --> 12:17.780
它以这个东西

12:17.780 --> 12:18.780
作为模块ID

12:19.780 --> 12:20.780
它不帮你生成了

12:20.780 --> 12:21.780
一个模块

12:21.780 --> 12:22.780
这个模块里面就是什么呢

12:22.780 --> 12:24.780
这个模块里面就记录了

12:24.780 --> 12:26.780
所有的可能的

12:26.780 --> 12:27.780
会引用到的JS

12:27.780 --> 12:29.780
那么我们这句话的代码

12:29.780 --> 12:30.780
就这句代码

12:30.780 --> 12:32.780
翻译到打包结果里面

12:32.780 --> 12:33.780
其实就是一个Require

12:34.780 --> 12:35.780
所以说这结合是个扩展合成

12:35.780 --> 12:37.780
你要对原理有很清楚的认识

12:38.780 --> 12:39.780
它就是一个Require

12:39.780 --> 12:40.780
那么这个Require的结果

12:40.780 --> 12:41.780
返回的结果是什么呢

12:41.780 --> 12:42.780
返回的结果

12:42.780 --> 12:43.780
是不是就是这里

12:43.780 --> 12:44.780
打包结果

12:44.780 --> 12:45.780
打包的Mortial Export

12:45.780 --> 12:46.780
你看一下

12:46.780 --> 12:47.780
这里的Mortial Export

12:47.780 --> 12:48.780
是什么

12:48.780 --> 12:49.780
是一个函数

12:49.780 --> 12:51.780
好,咱们来认识一下这个函数

12:51.780 --> 12:52.780
它返回的

12:52.780 --> 12:53.780
也说这边的代码

12:53.780 --> 12:54.780
生成了打包结果里面

12:54.780 --> 12:55.780
它返回的就是一个函数

13:02.780 --> 13:03.780
那么这个函数怎么来用呢

13:03.780 --> 13:05.780
这个函数非常简单

13:05.780 --> 13:07.780
这个函数就是以这个目录为基准

13:07.780 --> 13:08.780
然后呢

13:08.780 --> 13:11.780
去使用这个目录下面的东西

13:11.780 --> 13:13.780
比方说我们再使用

13:13.780 --> 13:14.780
A点JS

13:15.780 --> 13:16.780
这里不能省略JS

13:16.780 --> 13:17.780
因为这边没有省略

13:17.780 --> 13:18.780
主要是看这里

13:18.780 --> 13:19.780
因为这里呢

13:19.780 --> 13:20.780
我们通过那个

13:20.780 --> 13:21.780
政策表达式写来过后

13:21.780 --> 13:23.780
它跟A点JS是不能省的

13:23.780 --> 13:24.780
因为这边

13:24.780 --> 13:25.780
你看这里是不是没有

13:25.780 --> 13:26.780
去掉JS的情况

13:26.780 --> 13:28.780
它就是通过这个兼职队去匹配的

13:28.780 --> 13:29.780
如果说你直接写个斜杠

13:29.780 --> 13:30.780
A的话是匹配不到

13:30.780 --> 13:31.780
那么这里呢

13:31.780 --> 13:33.780
通过A点JS

13:33.780 --> 13:35.780
那么这里是不是可以拿到

13:35.780 --> 13:36.780
A这个模块

13:36.780 --> 13:37.780
我们输出一下A这个模块

13:37.780 --> 13:38.780
保存

13:38.780 --> 13:39.780
那么这边呢

13:39.780 --> 13:40.780
我们来运行一下

13:40.780 --> 13:41.780
点击右键运行

13:41.780 --> 13:43.780
点击右键运行的是

13:43.780 --> 13:44.780
安装一个插线

13:44.780 --> 13:48.150
叫做Code Run

13:48.150 --> 13:50.150
这是在load的环境里面运行

13:50.150 --> 13:51.150
Code Run

13:51.150 --> 13:52.150
当然你在浏览器环境里面运行

13:52.150 --> 13:53.150
也是一样

13:53.150 --> 13:54.150
就是你在这里的新建个页面

13:54.150 --> 13:55.150
页面上去

13:55.150 --> 13:56.150
你用这个媒体JS

13:56.150 --> 13:57.150
再把页面打开

13:57.150 --> 13:59.150
看结果也是一样的

13:59.150 --> 14:00.150
就是看打爆结果嘛

14:00.150 --> 14:01.150
我们以前说过的

14:01.150 --> 14:02.150
那么这里呢

14:02.150 --> 14:03.150
为了方便

14:03.150 --> 14:04.150
我们点击右键 RunCode

14:04.150 --> 14:05.150
用了这个插线过后

14:05.150 --> 14:06.150
就可以直接在控制台里边看

14:06.150 --> 14:07.150
所以得到一个A

14:07.150 --> 14:08.150
看到没

14:08.150 --> 14:09.150
输出了一个A

14:09.150 --> 14:10.150
说明它啥呢

14:10.150 --> 14:11.150
说明这个contact这个函数

14:11.150 --> 14:12.150
有什么用

14:12.150 --> 14:13.150
我们生存到一个上下文

14:13.150 --> 14:14.150
对吧

14:14.150 --> 14:15.150
那么这个上下文里边的

14:15.150 --> 14:16.150
所有东西

14:16.150 --> 14:17.150
都会新生存打爆结果

14:17.150 --> 14:18.150
我们也可以通过

14:18.150 --> 14:19.150
它返回的函数

14:19.150 --> 14:21.150
来去具体的找某一个模块

14:21.150 --> 14:22.150
这个目录下面的模块

14:22.150 --> 14:24.150
而且目录不用填了

14:24.150 --> 14:25.150
因为它的环境

14:25.150 --> 14:26.150
就是这个目录下面的

14:26.150 --> 14:27.150
直接从这个目录下面去找

14:27.150 --> 14:28.150
A点解释

14:28.150 --> 14:29.150
是不是找到这个模块了

14:29.150 --> 14:31.150
是不是把这个东西导入进来了

14:31.150 --> 14:32.150
对不对

14:32.150 --> 14:33.150
没问题吧

14:33.150 --> 14:34.150
就是这个

14:34.150 --> 14:35.150
而且这个contact室里边

14:35.150 --> 14:37.150
它还给你记录了什么东西呢

14:37.150 --> 14:39.150
还给你记录了这个Kiss

14:40.150 --> 14:41.150
有这么一个函数

14:41.150 --> 14:42.150
这个函数有什么用的

14:42.150 --> 14:43.150
保存一下

14:43.150 --> 14:44.150
让它重新打爆

14:44.150 --> 14:45.150
好 接下来我们在

14:45.150 --> 14:46.150
Made解释里面运行

14:47.150 --> 14:48.150
然后你看一下

14:48.150 --> 14:49.150
它返回的是一个数组

14:49.150 --> 14:50.150
表示的是

14:50.150 --> 14:55.150
它找到的所有的模块

14:55.150 --> 14:57.150
它找到的所有的

14:57.150 --> 14:59.150
就是这个目录下面的所有模块

14:59.150 --> 15:00.150
它哪些模块

15:00.150 --> 15:02.150
把它打爆进来了

15:02.150 --> 15:03.150
按照你的要求

15:03.150 --> 15:04.150
按照你的表达式的要求

15:04.150 --> 15:06.150
它把哪些模块打爆进来了

15:06.150 --> 15:07.150
那么这每一个模块

15:07.150 --> 15:08.150
它是一个

15:08.150 --> 15:09.150
在这里边是一个键

15:09.150 --> 15:10.150
对吧

15:10.150 --> 15:11.150
它对你一个就是

15:11.150 --> 15:12.150
它的就是模块ID

15:13.150 --> 15:15.150
那么说了半天

15:15.150 --> 15:16.150
这个玩意有啥用呢

15:16.150 --> 15:18.150
除了我们在不确定的时候

15:18.150 --> 15:20.150
还会自动帮你完成

15:20.150 --> 15:21.150
对吧

15:21.150 --> 15:22.150
不确定的时候

15:22.150 --> 15:23.150
会自动帮你完成

15:23.150 --> 15:24.150
那么除了这种情况

15:24.150 --> 15:25.150
这种情况非常少见

15:25.150 --> 15:26.150
对不对

15:26.150 --> 15:27.150
哪有这种情况

15:27.150 --> 15:30.150
有的时候倒是有可能会发生

15:30.150 --> 15:31.150
比方说什么情况

15:31.150 --> 15:32.150
就是你的marge

15:32.150 --> 15:34.150
名字是一个水积数

15:34.150 --> 15:36.150
通过一个水积来得到的

15:36.150 --> 15:37.150
你也不知道用了哪一个

15:37.150 --> 15:38.150
它不运行也不知道

15:38.150 --> 15:39.150
那么这个时候

15:39.150 --> 15:41.150
会形成不确定的动态依赖

15:41.150 --> 15:42.150
除了这种情况的时候

15:42.150 --> 15:43.150
有的时候

15:43.150 --> 15:44.150
我们可以利用contact

15:44.150 --> 15:46.150
来做这么一些事情

15:46.150 --> 15:47.150
好

15:47.150 --> 15:48.150
比方说

15:48.150 --> 15:49.150
你看我们的UTO

15:49.150 --> 15:50.150
是目录下面

15:50.150 --> 15:51.150
当然我这个东西

15:51.150 --> 15:52.150
你们如果说

15:52.150 --> 15:54.150
你在学习这个课的话

15:54.150 --> 15:56.150
除了这一课有两个目的

15:56.150 --> 15:57.150
一个是

15:57.150 --> 15:58.150
就是讲contact

15:58.150 --> 15:59.150
这种情况

15:59.150 --> 16:01.150
以及不确定的动态依赖

16:01.150 --> 16:02.150
到底是一个什么样的情况

16:02.150 --> 16:03.150
第二个

16:03.150 --> 16:05.150
更加希望的是大家

16:05.150 --> 16:06.150
了解这一课的知识过后

16:06.150 --> 16:07.150
在将来的课程中

16:07.150 --> 16:09.150
能够去灵活的运用

16:09.150 --> 16:11.150
这个质疑点是很难很难的

16:11.150 --> 16:12.150
特别是对初学者

16:12.150 --> 16:13.150
要灵活的运用指示

16:13.150 --> 16:14.150
是特别特别难的

16:14.150 --> 16:16.150
因为毕竟你们

16:16.150 --> 16:18.150
代码量还不足够

16:18.150 --> 16:19.150
这是很正常的

16:19.150 --> 16:20.150
大家不用担心

16:20.150 --> 16:21.150
学到时间的推议

16:21.150 --> 16:22.150
慢慢就

16:22.150 --> 16:24.150
这是一个循序迁进的过程

16:24.150 --> 16:25.150
不用太过于担心

16:25.150 --> 16:26.150
不过呢

16:26.150 --> 16:28.150
我在这里给大家提到

16:28.150 --> 16:29.150
这么一个知识点的过后

16:29.150 --> 16:30.150
有可能

16:30.150 --> 16:31.150
将来工作了一年

16:31.150 --> 16:32.150
工作了两年过后

16:32.150 --> 16:33.150
突然想起来

16:33.150 --> 16:34.150
以前袁老师好像讲过

16:34.150 --> 16:35.150
有一个东西

16:35.150 --> 16:36.150
能不能解决

16:36.150 --> 16:37.150
目前手上的问题呢

16:37.150 --> 16:39.150
如果说能够帮助你们

16:39.150 --> 16:40.150
有这么一点帮助的话

16:40.150 --> 16:41.150
那这个可能

16:41.150 --> 16:43.150
目的呢也就达到了

16:43.150 --> 16:44.150
好

16:44.150 --> 16:45.150
现在我们来看一下

16:45.150 --> 16:46.150
这种情况

16:46.150 --> 16:47.150
在UTO的文件夹

16:47.150 --> 16:48.150
下面可能会有

16:48.150 --> 16:50.150
很多很多的模块

16:50.150 --> 16:52.150
将来还会增加一些模块

16:52.150 --> 16:53.150
我现在

16:53.150 --> 16:56.150
但是UTO的文件夹里边的东西

16:56.150 --> 16:57.150
实际上我想把它

16:57.150 --> 17:00.150
合并成一个整体导出

17:00.150 --> 17:01.150
懂我的意思吗

17:01.150 --> 17:03.150
它这里边分散成很多模块

17:03.150 --> 17:04.150
因为为什么要分散

17:04.150 --> 17:05.150
这样子好维护

17:05.150 --> 17:06.150
我不想把它

17:06.150 --> 17:08.150
全部写到一个文件里边去

17:08.150 --> 17:09.150
但是我用的时候呢

17:09.150 --> 17:10.150
十字八九

17:10.150 --> 17:11.150
我是把它联合起来

17:11.150 --> 17:12.150
一起用的

17:12.150 --> 17:14.150
比方说整个这个文件夹下面

17:14.150 --> 17:15.150
就是完成一个功能

17:15.150 --> 17:16.150
但这个功能太复杂了

17:16.150 --> 17:17.150
我要把它分成

17:17.150 --> 17:19.150
很多很多的模块来写

17:19.150 --> 17:20.150
但是我导出的时候呢

17:20.150 --> 17:21.150
我要把这些模块

17:21.150 --> 17:22.150
全部合并出来导出

17:22.150 --> 17:24.150
比方说有这么一个要求

17:24.150 --> 17:26.150
因这个事文件里边

17:26.150 --> 17:27.150
在这个因这个事里边

17:27.150 --> 17:28.150
我们希望

17:28.150 --> 17:30.150
把这个UTO文件夹下面的

17:30.150 --> 17:31.150
所有模块全部导出

17:31.150 --> 17:32.150
那怎么办呢

17:32.150 --> 17:33.150
这个时候呢

17:33.150 --> 17:34.150
你怎么写的

17:34.150 --> 17:35.150
你怎么写的都不对

17:35.150 --> 17:36.150
那比方说你

17:36.150 --> 17:37.150
我就这样子写

17:37.150 --> 17:38.150
没问题啊

17:38.150 --> 17:39.150
对吧

17:39.150 --> 17:40.150
exportA

17:40.150 --> 17:41.150
然后呢

17:41.150 --> 17:42.150
我们这里require

17:44.150 --> 17:45.150
A

17:45.150 --> 17:46.150
导出A吗

17:46.150 --> 17:47.150
A模块导入

17:47.150 --> 17:48.150
导入A模块的东西

17:48.150 --> 17:50.150
把它作为整体

17:50.150 --> 17:52.150
把这个变量A来导出

17:52.150 --> 17:54.150
exportB

17:54.150 --> 17:56.150
require

17:56.150 --> 17:57.150
B

17:57.150 --> 17:58.150
说这样子写

17:58.150 --> 17:59.150
那么这样子写

17:59.150 --> 18:00.150
好像也没有什么问题

18:00.150 --> 18:01.150
但是这样写写

18:01.150 --> 18:03.150
有个不是很好的地方

18:03.150 --> 18:04.150
就是维护起来比较困的

18:04.150 --> 18:05.150
假设有一天

18:05.150 --> 18:07.150
以外这个文件明改了

18:07.150 --> 18:08.150
那这里是不是也要改

18:08.150 --> 18:10.150
假设一天你把这个文件位置改了

18:10.150 --> 18:11.150
这里是不是也要改

18:11.150 --> 18:13.150
假设有一天你这里增加了

18:13.150 --> 18:14.150
一些模块

18:14.150 --> 18:15.150
那么这边是不是也要改

18:15.150 --> 18:17.150
它是不是不好维护啊

18:17.150 --> 18:19.150
那么我们能不能想到

18:19.150 --> 18:21.150
一种更好的办法呢

18:21.150 --> 18:23.150
我们这里就可以用这个conTex

18:23.150 --> 18:24.150
我们让

18:24.150 --> 18:25.150
因为反正我们知道

18:25.150 --> 18:26.150
这个UTO里边的东西

18:26.150 --> 18:27.150
全部都是要一代的

18:27.150 --> 18:28.150
对不对

18:28.150 --> 18:29.150
是不是全部要一代的

18:29.150 --> 18:31.150
那么我干脆让它require

18:31.150 --> 18:32.150
conTex

18:32.150 --> 18:33.150
直接粗暴一点

18:33.150 --> 18:35.150
麻烦你把当前目录下面的

18:35.150 --> 18:36.150
所有东西全部打包

18:36.150 --> 18:38.150
都包一代关系里边去

18:38.150 --> 18:39.150
包括纸目录

18:39.150 --> 18:41.150
但是其他文件就不要了

18:41.150 --> 18:43.150
我只要GS

18:43.150 --> 18:44.150
点GS

18:44.150 --> 18:48.680
有这个还说是

18:48.680 --> 18:52.700
用起来是非常非常灵活的

18:52.700 --> 18:53.700
conTex

18:53.700 --> 18:55.700
那么这个时候呢

18:55.700 --> 18:57.700
接下来我们来输出一下

18:57.700 --> 18:59.700
conTex

18:59.700 --> 19:00.700
你看一下

19:00.700 --> 19:01.700
保存

19:01.700 --> 19:03.700
我们在这边去一代

19:03.700 --> 19:04.700
一代这边

19:04.700 --> 19:06.700
得到

19:06.700 --> 19:08.700
UTO

19:08.700 --> 19:09.700
require

19:09.700 --> 19:12.780
就要解构

19:12.780 --> 19:13.780
UTO

19:13.780 --> 19:14.780
好

19:14.780 --> 19:15.780
保存

19:15.780 --> 19:16.780
那咱们这边来

19:16.780 --> 19:18.780
made.js 里面去运行一下

19:20.780 --> 19:21.780
去运行一下

19:21.780 --> 19:23.780
那么现在是不是得到这个东西

19:23.780 --> 19:24.780
是不是得到这么一个数数

19:24.780 --> 19:25.780
你看啊

19:25.780 --> 19:26.780
我们在这个

19:26.780 --> 19:27.780
入口模块里边

19:27.780 --> 19:28.780
我们去一代的UTO模块

19:28.780 --> 19:29.780
那么UTO模块里边

19:29.780 --> 19:30.780
我们得到了

19:30.780 --> 19:31.780
当前目录下面的

19:31.780 --> 19:32.780
所有模块进打包结果

19:32.780 --> 19:34.780
然后看一下哪些模块进入打包结果

19:34.780 --> 19:35.780
说出了一个key

19:35.780 --> 19:36.780
然后接下来

19:36.780 --> 19:37.780
然后接下来

19:37.780 --> 19:39.780
我们是不是可以循环这个key

19:39.780 --> 19:42.780
循环这个key

19:42.780 --> 19:44.780
循环的key过后

19:44.780 --> 19:45.780
每一个key

19:45.780 --> 19:47.780
输出key

19:47.780 --> 19:49.780
made.js 里面打包管

19:49.780 --> 19:52.660
去看一下

19:52.660 --> 19:54.660
这是conTex的key

19:54.660 --> 19:56.660
一个函数

19:56.660 --> 19:58.660
打包结果里面去运行一下

19:58.660 --> 19:59.660
你看是吧

19:59.660 --> 20:00.660
所有的模块拿出来了

20:00.660 --> 20:01.660
对不对

20:01.660 --> 20:02.660
然后接下来我要做什么呢

20:02.660 --> 20:03.660
接下来我要

20:03.660 --> 20:04.660
除了这个模块之外

20:04.660 --> 20:05.660
对吧

20:05.660 --> 20:06.660
除了它自己本身之外

20:06.660 --> 20:07.660
其他的模块

20:07.660 --> 20:08.660
是不是都要形成到打包结果

20:08.660 --> 20:09.660
所以我们判断一下

20:09.660 --> 20:12.660
如果说key不等于

20:12.660 --> 20:14.660
第二鞋杠index.js

20:14.660 --> 20:15.660
如果要不等于这个

20:15.660 --> 20:16.660
除了自己之外

20:16.660 --> 20:17.660
那么我们这个模块

20:17.660 --> 20:18.660
要进入打包

20:18.660 --> 20:19.660
要把它打出

20:19.660 --> 20:20.660
接下来

20:20.660 --> 20:21.660
我们这里

20:21.660 --> 20:22.660
到这边来

20:22.660 --> 20:23.660
然后

20:23.660 --> 20:24.660
你看是不是A

20:24.660 --> 20:25.660
是不是这三个模块了

20:25.660 --> 20:26.660
对吧

20:26.660 --> 20:27.660
那么我们现在就动态

20:27.660 --> 20:28.660
这些全是动态的

20:28.660 --> 20:29.660
对不对

20:29.660 --> 20:30.660
那么我们这个地方

20:30.660 --> 20:31.660
我们可以这样子起

20:31.660 --> 20:32.660
比方说

20:32.660 --> 20:33.660
我们这里呢

20:33.660 --> 20:34.660
就是在

20:34.660 --> 20:35.660
可以使用

20:35.660 --> 20:36.660
把它处理一下

20:36.660 --> 20:37.660
把它变成什么呢

20:37.660 --> 20:38.660
把它就把

20:38.660 --> 20:39.660
这个第二鞋杠index.js

20:39.660 --> 20:40.660
变成什么呢

20:40.660 --> 20:41.660
变成A

20:41.660 --> 20:42.660
把这个第二鞋杠index.js

20:42.660 --> 20:43.660
变成B

20:43.660 --> 20:44.660
这样子呢

20:44.660 --> 20:45.660
我们把它打出的时候

20:45.660 --> 20:46.660
我们就这样子起

20:46.660 --> 20:47.660
比方说

20:47.660 --> 20:49.660
exports.a等于啥

20:49.660 --> 20:50.660
对吧

20:50.660 --> 20:51.660
B等于啥

20:51.660 --> 20:52.660
对吧

20:52.660 --> 20:53.660
所以说把这个模块

20:53.660 --> 20:54.660
就是文件名拿到

20:54.660 --> 20:55.660
对不对

20:55.660 --> 20:59.680
拿到这个模块的文件名

20:59.680 --> 21:01.680
finally

21:01.680 --> 21:02.680
文件名

21:02.680 --> 21:03.680
文件名怎么拿到呢

21:03.680 --> 21:04.680
我们就可以用

21:04.680 --> 21:05.680
这种方式

21:05.680 --> 21:06.680
tsubstream

21:06.680 --> 21:07.680
从前面两个不要了

21:07.680 --> 21:08.680
对吧

21:08.680 --> 21:09.680
吊鞋杠不要了

21:09.680 --> 21:10.680
吊鞋杠我们从

21:10.680 --> 21:11.680
下标为二的地方

21:11.680 --> 21:12.680
开始去

21:12.680 --> 21:13.680
从这里开始去

21:13.680 --> 21:14.680
对不对

21:14.680 --> 21:15.680
好

21:15.680 --> 21:16.680
然后继续

21:17.680 --> 21:18.680
然后呢

21:18.680 --> 21:20.680
我们输出这个finally

21:21.680 --> 21:23.680
好保存

21:23.680 --> 21:24.680
runcode

21:24.680 --> 21:25.680
你看是不是变成这个样子了

21:25.680 --> 21:26.680
好那么接下来

21:26.680 --> 21:27.680
我们去掉后边

21:27.680 --> 21:28.680
三个制服

21:28.680 --> 21:29.680
去掉后边

21:29.680 --> 21:30.680
三个制服很简单

21:30.680 --> 21:31.680
finally

21:31.680 --> 21:32.680
对什么

21:32.680 --> 21:33.680
对不对

21:33.680 --> 21:34.680
它当前的值

21:34.680 --> 21:35.680
然后substream

21:35.680 --> 21:36.680
长度呢

21:36.680 --> 21:38.680
长度就是它自身的长度

21:38.680 --> 21:39.680
减3

21:39.680 --> 21:41.680
去掉后面三个制服

21:42.680 --> 21:43.680
是不是从零开始

21:43.680 --> 21:44.680
去掉长度减3

21:44.680 --> 21:45.680
是不是去到这个位置

21:45.680 --> 21:46.680
到这个位置

21:46.680 --> 21:47.680
但是不包含这个位置

21:47.680 --> 21:48.680
对不对

21:48.680 --> 21:50.680
好那么我们来输出一下finally

21:52.680 --> 21:53.680
运行

21:53.680 --> 21:54.680
你看是不是abc出来了

21:54.680 --> 21:55.680
那么这个东西

21:55.680 --> 21:56.680
是不是我们要

21:56.680 --> 21:58.680
导出的属性名字

21:58.680 --> 21:59.680
asport

21:59.680 --> 22:00.680
什么

22:00.680 --> 22:02.680
finally

22:02.680 --> 22:04.680
所以要导出的属性名字

22:04.680 --> 22:05.680
那么属性的值是什么呢

22:05.680 --> 22:06.680
属性的值

22:06.680 --> 22:07.680
是不是来自于

22:07.680 --> 22:08.680
这个context里面的东西

22:08.680 --> 22:09.680
对吧

22:09.680 --> 22:10.680
context里面是什么

22:10.680 --> 22:11.680
t

22:11.680 --> 22:12.680
context

22:12.680 --> 22:13.680
导入

22:13.680 --> 22:14.680
导入这个上下文里面的

22:14.680 --> 22:15.680
打个字

22:15.680 --> 22:16.680
t

22:16.680 --> 22:17.680
把这个d2-a

22:17.680 --> 22:18.680
d2-s传进去

22:18.680 --> 22:19.680
d2-b

22:19.680 --> 22:20.680
d2-c

22:20.680 --> 22:21.680
d2-c

22:21.680 --> 22:22.680
把它的结果导入

22:22.680 --> 22:23.680
对吧

22:23.680 --> 22:24.680
导入进来过后

22:24.680 --> 22:25.680
是不是把它放到

22:25.680 --> 22:26.680
这个esport里面

22:26.680 --> 22:27.680
那么就写完了

22:27.680 --> 22:28.680
好写完了之后

22:28.680 --> 22:29.680
我们在这边

22:29.680 --> 22:30.680
in这个社里面

22:30.680 --> 22:31.680
我们来输出一下这个ut

22:31.680 --> 22:32.680
你看一下是不是没想要的

22:32.680 --> 22:33.680
保存

22:33.680 --> 22:34.680
然后了

22:34.680 --> 22:35.680
这边

22:35.680 --> 22:36.680
runcode

22:36.680 --> 22:37.680
你看是不是

22:37.680 --> 22:38.680
就把这个utl模块里面

22:38.680 --> 22:39.680
所有东西

22:39.680 --> 22:40.680
全部导出了

22:40.680 --> 22:41.680
对不对

22:41.680 --> 22:42.680
通过一个文件

22:42.680 --> 22:43.680
全部导出了

22:43.680 --> 22:44.680
那么我们在这里的ut

22:44.680 --> 22:45.680
里面

22:45.680 --> 22:46.680
我们比方说将来

22:46.680 --> 22:47.680
又加了一个d2-gs

22:49.680 --> 22:50.680
d2-gs

22:50.680 --> 22:51.680
好

22:51.680 --> 22:52.680
d2-gs

22:52.680 --> 22:53.680
我们这里的

22:53.680 --> 22:54.680
比如说用varjo

22:56.680 --> 22:57.680
叫export

22:58.680 --> 22:59.680
导出一个d

22:59.680 --> 23:00.680
好保存

23:00.680 --> 23:01.680
我们看一下

23:01.680 --> 23:02.680
runcode

23:02.680 --> 23:03.680
是不是自动表达

23:03.680 --> 23:04.680
第几千年进来了

23:04.680 --> 23:05.680
对吧

23:05.680 --> 23:06.680
我们不用去改动

23:06.680 --> 23:07.680
in这个社里的gst

23:07.680 --> 23:08.680
也不用去改动其他代

23:08.680 --> 23:09.680
对不对

23:09.680 --> 23:10.680
那么这个

23:10.680 --> 23:13.180
扩展性是不是

23:13.180 --> 23:14.180
非常非常好

23:14.180 --> 23:15.180
将来

23:15.180 --> 23:16.180
你们如果说

23:16.180 --> 23:17.180
遇到一种情况

23:17.180 --> 23:18.180
你们将来可能会遇到

23:18.180 --> 23:19.180
当然你如果说

23:19.180 --> 23:20.180
你不用那种状况

23:20.180 --> 23:21.180
能不能写

23:21.180 --> 23:22.180
当然能写的话

23:22.180 --> 23:23.180
你就是写的麻烦一点

23:23.180 --> 23:24.180
能能能写

23:24.180 --> 23:25.180
就是你将来

23:25.180 --> 23:26.180
如果说

23:26.180 --> 23:27.180
在vrreactor的

23:27.180 --> 23:28.180
学习的过程中

23:28.180 --> 23:29.180
遇到一种情况

23:29.180 --> 23:30.180
就是某一个文件

23:30.180 --> 23:31.180
下面

23:31.180 --> 23:32.180
你不用去想了

23:32.180 --> 23:34.180
而且它是作为一个整体

23:34.180 --> 23:35.180
比方说

23:35.180 --> 23:36.180
它里面所谓的东西

23:36.180 --> 23:38.180
我们分成各个不同的模块来写

23:38.180 --> 23:40.180
只是为了维护方便

23:40.180 --> 23:41.180
但它实际上是一个整体

23:41.180 --> 23:42.180
比方说里面学到

23:42.180 --> 23:43.180
后面什么VU的路由

23:43.180 --> 23:45.180
什么VUX

23:45.180 --> 23:46.180
这些东西对不对

23:46.180 --> 23:47.180
那么我们就可以

23:47.180 --> 23:48.180
用这种模式

23:48.180 --> 23:49.180
直接把它全部

23:49.180 --> 23:50.180
弄到打包结果里面

23:50.180 --> 23:51.180
然后

23:51.180 --> 23:52.180
通过一个模块

23:52.180 --> 23:53.180
把它合并

23:53.180 --> 23:54.180
把它合并

23:54.180 --> 23:55.180
当然合并的方式

23:55.180 --> 23:56.180
不一定是这种方式

23:56.180 --> 23:57.180
但是你心里边

23:57.180 --> 23:58.180
有这么一个印象就行了

23:58.180 --> 23:59.180
将来如果说

23:59.180 --> 24:00.180
遇到一种场景

24:00.180 --> 24:01.180
一个目录下面

24:01.180 --> 24:02.180
它有所有东西

24:02.180 --> 24:04.180
它都是为一个功能服务的

24:04.180 --> 24:06.180
它只是把人为的裁缝开了

24:06.180 --> 24:07.180
一定是全部都有遗难

24:07.180 --> 24:09.180
那么我们要在一个地方

24:09.180 --> 24:10.180
把它把所有的遗难

24:10.180 --> 24:11.180
全部找到

24:11.180 --> 24:13.180
那么就可以用这个Context

24:13.180 --> 24:15.180
另外我们在这一刻

24:15.180 --> 24:16.180
也可以认识到

24:16.180 --> 24:17.180
在WePAC里面

24:17.180 --> 24:19.180
如果说出现了

24:19.180 --> 24:20.180
不确定的动态遗难

24:20.180 --> 24:21.180
它能够确定

24:21.180 --> 24:22.180
这个目录的话

24:22.180 --> 24:23.180
那么它会帮我们

24:23.180 --> 24:24.180
来做这个Context

24:24.180 --> 24:25.180
OK

24:25.180 --> 24:26.180
那么这是这里

24:26.180 --> 24:28.180
我们要补充了一个

24:28.180 --> 24:29.180
小知识

