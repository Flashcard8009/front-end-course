WEBVTT

00:01.010 --> 00:04.450
这些课咱们再聊一聊 懒家债

00:05.090 --> 00:08.450
啥意思呢?就是说 传说信仰这一块啊

00:08.450 --> 00:09.810
分包也分了

00:10.210 --> 00:14.450
单模块体积也优化了 压缩也有压缩了 吹鞋劾也吹鞋劾了

00:14.930 --> 00:17.090
但是它还是太大了

00:17.410 --> 00:21.570
那么这个时候呢 我们可能会想到 还有啥手段呢

00:21.570 --> 00:23.410
就说我们可能会想到啊

00:23.410 --> 00:27.890
页面一开始运行的时候 实际上要不了那么多解释

00:28.610 --> 00:32.530
很多时候呢 我们可能有些事情啊 是用户做了某些操作

00:32.530 --> 00:35.890
或者是页面夹载完了之后 我们才需要去用的

00:36.450 --> 00:40.690
那么这个时候呢 我们就可以用这样的识录 我一开始给力的解释很少

00:41.330 --> 00:44.050
而且把这东西分开 其实也是分包了一种吧

00:44.610 --> 00:46.530
就说我一开始给力的解释很少

00:46.930 --> 00:51.250
但是呢 你做了某个操作过后 我再去动态的去夹载 我们要用的解释

00:51.490 --> 00:52.450
这就是懒家债

00:53.730 --> 00:57.570
那么懒家债呢 你就可以把它理解为一些异部的创客

00:58.050 --> 01:01.330
就是说有些创客打包出来的文件呢 他不是一开始到页面里面去的

01:01.890 --> 01:05.410
他只要等一下 等之后有些操作之后呢 再到页面里面去

01:05.650 --> 01:07.330
我们之前讲分包的时候还记得吗

01:07.570 --> 01:12.210
咱们讲的是自动分包的时候 有一个异部对吧 一个异部的创客

01:12.370 --> 01:15.330
那么当时呢 我们说后边会学习 那么就是懒家债这一部分

01:15.410 --> 01:18.530
他会打包成一个异部的创客 咱们来举个例子就明白了

01:19.010 --> 01:23.490
这一部分呢 我也没有什么课件啊 因为这个很简单 特别简单 我说一下就行了

01:24.450 --> 01:28.850
页面上的比方说 我们有个按钮啊 点击这个按钮了之后呢 我们要去做一些事

01:29.250 --> 01:33.330
所以说我们的介石代码里面怎么写的 介石代码里面我们就来一个

01:34.370 --> 01:36.450
document query selector

01:37.250 --> 01:37.650
按钮

01:39.410 --> 01:40.370
哎 我们得得到

01:40.930 --> 01:43.890
毕天 我们希望点击这个按钮之后

01:45.490 --> 01:50.530
哎 我再去比方说 我们用楼大喜去实现一个简单的功能吧 就像我们之前的创客

01:51.250 --> 01:56.610
啊 是用楼大喜去实现一个创客的功 就是创客喊出的功能 如果说按照我们以前的做法

01:57.970 --> 01:59.250
啊 我们是不是要用这种方式

02:00.450 --> 02:06.770
对吧 no dash yes啊 那么这里呢 我们创客啊 创客什么呢 创客一个

02:07.570 --> 02:11.890
数数吧 随便写个啊 随便写一个 好 然后呢 把它两个两个分组

02:13.170 --> 02:18.130
二 without 输出 without 那么这样子当然可以实现功能啊 咱们来看一下

02:18.450 --> 02:20.850
不过呢 这样子的功能 它不好的地方在哪呢

02:21.250 --> 02:25.570
它不好的地方呢 就在于把这个东西一开始就加到我们的包里边去了 因为这是

02:25.970 --> 02:30.690
一开始就有依赖 对吧 一开始加到我们包里边去了 所以我们一个介石文件啊里边就包含了

02:31.250 --> 02:36.930
说他也不大吧 也没有那么大啊 你看那个混沌条一看混沌条都看得出来 没有那么大 因为我们用了吹鞋挺

02:37.490 --> 02:39.010
呃 他加进去了

02:39.810 --> 02:45.890
但是呢 实际上的功能一开始有用吗 一开始实际上是没用的啊 看一下里面啊 肯定功能肯定是有

02:46.610 --> 02:49.970
啊 检查 控制台 放大一点

02:50.930 --> 02:56.370
好 我们点击 你看 是不是一样的 对吧 分组了 但是一开始它实际上是没什么用的

02:56.690 --> 03:01.730
而我们是要点击之后才用它 那如果我们假设夸张一点啊 像这个库呢 如果说它

03:02.210 --> 03:07.250
这个我们要用的里边东西特别特别多 而这些东西呢 我一开始都不用 而是我们点了之后才用

03:07.570 --> 03:13.570
那么就说我们一开始没有必要去加在它 那么这个时候怎么办呢 这个时候呢 我们可以使用这种模式来操作

03:13.970 --> 03:17.410
把他去了 我们点了之后再去动态

03:19.010 --> 03:25.410
动态加在 动态加在你不能用require啊 你不能用require啊 require它是要分析一代的 它发现这里还是有一代

03:25.570 --> 03:30.690
不要说用require吧 啊require楼代系 因为require是支持动态的 对吧 啊楼代系

03:31.250 --> 03:35.010
也是啊 那么这里呢 导入进来啊 导入进来

03:37.380 --> 03:40.260
啊 那么这个创客呢 创客我们就

03:41.700 --> 03:42.900
创客等于

03:43.620 --> 03:44.420
第二 创客

03:44.980 --> 03:50.580
ok 那么这样子 第一他肯定用不到requirekin 确切肯定没了啊 我们来看一下

03:51.540 --> 03:54.900
他打包出来的文件 看主要看他打包出来几个文件就明白了

03:55.780 --> 04:00.100
那你要一步加在哪里肯定要多一个文件啊 对吧 一个文件要动态加在 是不是还是一个

04:00.420 --> 04:05.140
对吧 因为这个require呢 他是他是要分析那个抽象与法数的 发现有require 他就表示有一代

04:05.620 --> 04:10.660
他必须要使用一种特殊的语法才行 什么语法呢 这个语法呢 叫这样子 import

04:11.380 --> 04:12.900
啊 把当成一个函数调用

04:13.620 --> 04:15.300
当成一个函数调用 什么函数呢

04:15.940 --> 04:17.860
就就是一个函数啊 里边你写上你要

04:18.420 --> 04:19.940
加带的模块 都带一些es

04:20.260 --> 04:26.900
啊 你现在加这个模 加了这么一个模块 那么大家注意啊 这个import呢 他这个是不是es的标准呢 他实际上是

04:27.380 --> 04:30.020
啊 他是es6的草案

04:31.220 --> 04:31.620
草案

04:32.420 --> 04:36.580
啊 他不是一个正式的标准啊 就是到了那么多年了 还是个草案

04:36.820 --> 04:40.260
所以说呢 正规的流产期呢 他不 他不不认这个东西啊

04:40.420 --> 04:43.860
他是个草案嘛 他不是比真的要准 但是呢 微pike他是认的

04:44.260 --> 04:46.420
那么微pike他就把他当成是一个一步家战

04:46.740 --> 04:53.140
说明什么呢 他说明说你这里要动态的去加载一个ges 加载一个模块 那个模块呢 一开始是可以没有的

04:54.020 --> 04:58.580
那么如果说微pike遇到这个东西的时候呢 他不会把把这个模块呢 他认为他是

04:58.900 --> 05:05.060
他认为是index的依赖 但是呢 他不认为是index一开始就 他不认为要打包到index里边去

05:05.460 --> 05:06.900
他会单独对他进行打包

05:07.540 --> 05:15.540
而且这个家战这个这句话呢 会造成一个什么现象呢 他会造成 就是我们浏览器会去远程去读一个解释 你可以理解为接生p

05:16.180 --> 05:19.060
你可以理解接生p啊 就是浏览器

05:21.140 --> 05:23.540
会使用接生p的方式

05:24.260 --> 05:28.580
远程去读取一个解释啊模块

05:29.860 --> 05:34.660
那么这个时候呢 如果遇到这句话 那么他就会打包成为一个单独的解释

05:35.380 --> 05:38.820
既然是远程 那么是不是异步的 他会返回一个promise

05:40.500 --> 05:40.980
import

05:42.020 --> 05:44.260
会返回一个promise

05:44.980 --> 05:45.540
promise

05:46.420 --> 05:50.500
那么这个promise呢 呃promise返回的结果就类似类似于这个东西

05:50.980 --> 05:53.620
类似于新号而是obj 类似于这个东西

05:54.340 --> 05:58.180
返回这么一个东西 那么我既然是异步的 然后返回promise 我们是不是可以等待

05:58.180 --> 06:04.020
对吧 把他形成异步的sync 可以等待他 当然也可以用rand的方式啊 就看你自己喜欢哪种 当然这种方式更加方便

06:04.740 --> 06:09.940
那么这样子的把nodec打过来了 对吧 拿过来了 拿过来了 我们这里的 甚至在这里可以解构

06:11.220 --> 06:11.700
在这里解构

06:13.220 --> 06:13.780
明儿的意思吧

06:14.580 --> 06:19.380
好 那么这样子的 我们来看一下啊 来看一下 现在是不是可以满足要求呢 打包一次

06:26.780 --> 06:27.340
好 稍等啊

06:28.620 --> 06:33.260
好 打包完成 是不是有两个解释了 对吧 一点解释 这个一打来的就是nodec的代码

06:33.740 --> 06:36.780
你看他chrnclames 他没有chrnclames 他没有chrnclames

06:37.020 --> 06:39.980
如果说你要给他指定一个chrnclames 也可以啊 也可以

06:40.620 --> 06:40.860
在这

06:41.900 --> 06:47.500
加上一个注释 这个有点麻烦啊 这个我觉得没啥必要 这个解释名字而已啊 没啥必要

06:47.900 --> 06:50.860
好像像webpackchrnclames

06:53.820 --> 06:55.900
是nodec

06:56.700 --> 06:57.980
好像是这样chrnclames

06:59.420 --> 07:01.340
好像是这样写的啊 我们试一下吧

07:10.020 --> 07:14.180
啊 那么他这里就显示了啊 他的chrnclames前面可以加那个前维vendors nodec

07:14.260 --> 07:15.620
对吧 vendors nodec

07:15.700 --> 07:19.300
那么这里呢 你看 名字就出来了啊 就这么个意思啊 就这么个意思

07:19.380 --> 07:22.020
他也没有必要去写这个玩意

07:22.740 --> 07:25.540
那么现在呢 我们来看一下啊 现在呢 我们这里

07:26.180 --> 07:30.100
点击 你看啊 一开始我们夹载到gfs啊 我们看一下sources

07:30.420 --> 07:32.980
一开始的gfs呢 实际上只有media.js 看没

07:33.220 --> 07:34.260
是不是只有media.js

07:34.500 --> 07:36.580
然后我们点击过后呢 他会有一个网络传输

07:37.380 --> 07:37.940
啊 你看吧

07:38.900 --> 07:41.780
一开始只有media.js 点击过后是不是 夹载了这个gfs

07:42.100 --> 07:46.980
他会发送一个网络传输 那么使用节省必得方式来完成模块的夹载

07:47.300 --> 07:50.100
啊 啊 点击过后啊 你看 是不是还是

07:50.340 --> 07:54.260
那么当然这个传输只需要传输一次啊 他不需要反复传输 他又缓存的

07:54.900 --> 07:58.340
那他到底是怎么做的呢 其实做的方法跟我们之前的分包是一样的

07:58.660 --> 08:01.540
他一开始呢 他会准备好一个数组啊 叫做

08:02.180 --> 08:06.980
叫做我们之前看过啊 微拍一个GNP这么一个数组 这个数组里面没有没有什么异布的东西 对吧

08:07.220 --> 08:08.260
只有主模和的东西

08:08.580 --> 08:13.140
当我们点击过后呢 他远程夹载完了过后呢 那个远程的代码呢 他会把这个

08:13.380 --> 08:15.060
东西呢 往这个全局辩量里面放

08:15.620 --> 08:20.180
啊 你看 现在再看这个微拍的GNP 是不是有了模块有出来了 对吧 模块出来了 在这里边

08:20.980 --> 08:23.220
好 那么他会把远程的模块呢 往这里边放

08:23.620 --> 08:28.420
那么这样子呢 组模和就放完了之后呢 组模和就可以使用它了啊 其实就按照这种思路来做的

08:29.060 --> 08:35.540
那么我们这边呢 其实你要 你要注意的就是 我们如果说要使用异布夹载 你使用这样的愚法

08:35.940 --> 08:38.340
啊 那么这个愚法呢 他反回的是一个promise

08:38.660 --> 08:40.740
那么promise呢 那么再去用

08:41.460 --> 08:44.980
好 就说到这里其实没了 但是呢 这里面又有一个问题出现了

08:45.380 --> 08:49.860
就是他的缺斜系统没了 为什么 因为他这个东西不是静态的 对吧 是不是静态的

08:50.340 --> 08:54.340
不是静态的 他就分析不出来了 他就分析不出来了 他鬼知道里后不要用哪些东西

08:54.580 --> 08:56.900
因为他这个要代码的运行过程中才能确定

08:57.140 --> 09:02.580
他不知道了 因为他不是静态的导注 不像我们之前传统的标准的s6导入愚法

09:02.820 --> 09:04.180
所以他这个东西没有缺斜系统

09:05.060 --> 09:08.500
那如果说我们要用缺斜系统怎么办呢 这个时候呢 你得想想办法

09:09.700 --> 09:12.180
他的问题在哪 他的问题就在于他没有

09:12.900 --> 09:17.460
没有什么的 没有那个就是静态的导入 对吧 没有静态的依赖

09:17.940 --> 09:20.980
那么我们把搞成静态的依赖就行了 比方说我们可以在这

09:22.020 --> 09:23.700
src里边我们写上一个

09:25.460 --> 09:30.340
写上一个就是utl吧 utl.js 写上一个这个东西

09:32.020 --> 09:35.940
清空一下 utl.js里边我们这里把它写成静态依赖

09:36.820 --> 09:37.140
trunk

09:38.100 --> 09:40.420
我们这里会这样吧 简单一点

09:40.980 --> 09:43.540
export 直接导出 导出什么trunk

09:43.940 --> 09:46.580
从哪个地方导出呢 从lowsdash

09:48.660 --> 09:53.300
lowsdash es里面导出 那么这个模块里面是不是只把

09:53.860 --> 09:57.940
用了一个静态的方式把lowsdash es里面只导出了一个这个东西

09:58.100 --> 10:00.740
那么这边呢 我们去用什么呢 我们这边这样用

10:05.410 --> 10:06.930
trunk

10:09.540 --> 10:13.060
await 我们去导入我们自己的那个模块utl

10:13.700 --> 10:17.780
那么这样子呢 就是不是就搞定了 对吧 一开始的utl根本就不到我们的包里面去

10:17.860 --> 10:20.020
但是在分析utl的时候呢 一分析

10:20.580 --> 10:22.020
这个一部模块里面 一分析

10:22.020 --> 10:26.420
哦原来我utl里边已经说明了 我只用到了什么这个窗口

10:26.740 --> 10:31.140
说这样子呢 一转弯 拐个弯 那么可以实现缺隙性

10:31.620 --> 10:32.980
但是这个肯定要麻烦一点

10:33.780 --> 10:38.420
就像这个懒家寨也好 还有缺隙性也好 都会影响到我们的代码的

10:38.500 --> 10:43.700
你看 现在就小多了 对吧 之前是890kb 现在就小多了

10:44.500 --> 10:46.820
啊 这个一部模块 那么现在效果是一样

10:47.780 --> 10:51.620
啊 这就是 如果说你要用trekken的话 肯定要麻烦一点

10:51.700 --> 10:54.260
trekken也好 懒家寨也好 都会影响到我们的代码

10:54.580 --> 10:57.940
当然呢 不得不说 这是不好的啊 这是我们不希望看到的

10:57.940 --> 11:00.180
我们希望看到的就是 我们代码随便怎么玩

11:00.340 --> 11:04.020
它自动给你优化 但是呢 现在呢 确实还达不到啊

11:04.020 --> 11:07.860
前端的 前端的场景 有的时候呢 它的运行环境啊

11:08.180 --> 11:09.700
它比后端可能还要复杂

11:10.660 --> 11:13.460
所以说 它现在目前达不到啊 这就是懒家寨

11:14.580 --> 11:15.780
准备了

