WEBVTT

00:00.050 --> 00:03.450
这里说一下大剑漏的英勇

00:04.950 --> 00:08.950
当然这些课你要学习了漏的之后再来看

00:09.650 --> 00:13.450
老回去我这个呢已经把这个工程的放到这上面了

00:13.450 --> 00:14.950
直接把它复制下来

00:16.520 --> 00:18.520
到这个桌面上去

00:20.020 --> 00:22.120
然后给一只可乐

00:22.420 --> 00:23.520
复制过来啊

00:24.720 --> 00:27.220
这里我要说一下为什么

00:27.520 --> 00:30.720
在漏的里面 如果说你学了漏的之后

00:30.820 --> 00:32.020
来看这个课的话

00:32.420 --> 00:35.520
因为我们漏的它是直接可以运行的

00:36.120 --> 00:39.520
那为什么在漏的里面还要去用这个Webpack呢

00:39.820 --> 00:41.320
但是那首先大家要知道啊

00:41.320 --> 00:44.320
不是说一定要用这个Webpack可以不用的

00:44.520 --> 00:47.520
就我们在使用这个漏的程序的时候呢

00:47.720 --> 00:51.120
有这么两种用法给他说一下

00:52.020 --> 00:53.620
我这里已经拿过来了啊

00:53.620 --> 00:55.820
这里把它放在

00:57.520 --> 00:59.320
哎我们先来看一下啊

01:00.320 --> 01:03.220
就是在漏的开发的时候呢

01:03.220 --> 01:05.220
有这么几种模式啊

01:05.220 --> 01:07.420
就地动模式呢就是直接开发

01:08.920 --> 01:10.120
啊直接部署

01:11.120 --> 01:11.920
啥意思呢

01:12.120 --> 01:14.220
因为我们漏的开发的是服务端程序吗

01:14.220 --> 01:15.220
直接开发直接部署呢

01:15.220 --> 01:16.420
他就这样子来做的

01:16.720 --> 01:18.920
第一步呢就是直接开发

01:18.920 --> 01:21.120
对吧搭建漏的工程

01:21.920 --> 01:23.420
啊直接开发

01:24.320 --> 01:26.120
啊比方你安装一些漏的猛啊

01:26.120 --> 01:26.820
这些东西对吧

01:26.820 --> 01:28.220
你们学了漏的应该知道啊

01:28.220 --> 01:29.220
直接开发就行了

01:29.320 --> 01:31.520
包括我们讲漏的那个课程里面

01:31.520 --> 01:32.620
也是直接开发的

01:33.420 --> 01:34.220
啊但是呢

01:34.520 --> 01:37.320
开发的过程呢使用啊开发过程中

01:38.720 --> 01:40.820
使用geek进行管理

01:41.320 --> 01:42.520
啊用geek进行管理

01:43.020 --> 01:44.020
啊比方说你在

01:44.120 --> 01:46.120
你们公司有一个私有仓库

01:46.120 --> 01:47.220
那你把你的代码呢

01:47.220 --> 01:49.520
放到一个私有仓库里面进行管理

01:50.120 --> 01:51.720
然后开发完了过后呢

01:51.720 --> 01:53.320
当然要经过一系列的步骤啊

01:53.320 --> 01:54.920
比方说审核啊对吧

01:54.920 --> 01:56.420
代码评审等等等等啊

01:56.820 --> 01:57.820
开发完成后

01:58.820 --> 02:01.020
啊经过了一些步骤之后呢

02:01.020 --> 02:02.720
决定啊这个版本没有问题了啊

02:02.720 --> 02:04.320
我们要把它合并到

02:04.520 --> 02:06.120
主分支里边去然后去合并

02:06.120 --> 02:07.220
合并完了过后呢

02:07.220 --> 02:08.420
就提交啊

02:08.820 --> 02:09.920
提交geek

02:10.420 --> 02:12.120
那么提交geek是不是到了服务器上去了

02:12.120 --> 02:12.720
这个代码

02:13.320 --> 02:14.820
然后呢我们进入我们的

02:15.020 --> 02:17.620
啊就是当然到底的代码仓库服务器上去了

02:17.920 --> 02:20.120
然后进入你的真实的服务器啊

02:20.220 --> 02:21.920
就是进入部署服务器

02:23.120 --> 02:25.120
然后从geek中

02:25.720 --> 02:27.120
拿取最新代码

02:28.520 --> 02:29.620
也就是说啥呢

02:29.620 --> 02:30.920
就这种模式啊

02:31.120 --> 02:33.320
啊你本地写的东西呢

02:33.820 --> 02:35.820
啊不要说安装什么依赖啊

02:35.820 --> 02:36.920
那些忘记发的东西呢

02:36.920 --> 02:38.120
整个工程结构

02:38.120 --> 02:40.220
跟那个服务器是完全一样的

02:40.720 --> 02:41.520
啊从计册

02:41.520 --> 02:43.320
那么服务器里边从计册拿取最新代码

02:43.320 --> 02:44.520
然后干嘛呢啊

02:44.520 --> 02:45.120
然后

02:45.820 --> 02:46.820
npm install

02:48.320 --> 02:50.120
然后就是进行

02:50.520 --> 02:51.420
安装依赖

02:51.520 --> 02:52.920
那么服务器那边的工程结构

02:52.920 --> 02:54.320
跟你这边是一样的啊

02:54.320 --> 02:56.420
就是这种模式直接开发直接部署

02:56.920 --> 02:58.520
这种模式呢倒是

02:59.120 --> 03:00.620
也没有什么问题啊

03:00.620 --> 03:01.320
主要是呢

03:01.820 --> 03:04.220
因为你要npm install

03:04.220 --> 03:05.520
那个服务器的安装呢

03:05.520 --> 03:06.920
可能需要一段时间

03:07.220 --> 03:07.720
对不对

03:07.720 --> 03:08.920
因为我们依赖的你知道

03:08.920 --> 03:10.320
依赖包是很大的啊

03:10.520 --> 03:12.120
需要一段时间啊

03:12.120 --> 03:12.520
因此呢

03:12.520 --> 03:14.220
我们可以产生第二种方式

03:14.520 --> 03:16.120
我们说一下这种方式的问题吧

03:17.820 --> 03:18.920
这个方式问题在哪呢

03:22.150 --> 03:24.450
它的问题呢主要是有这么几个方面

03:25.150 --> 03:25.950
当然这些问题呢

03:25.950 --> 03:27.650
也不是说特别特别严重啊

03:27.650 --> 03:29.450
很多东西还是可以用这种方式的

03:29.750 --> 03:31.050
它的问题哪些方面呢

03:31.050 --> 03:32.450
第一个就是服务器

03:33.350 --> 03:35.650
呃在npm install

03:36.550 --> 03:37.550
的过程中

03:38.250 --> 03:40.250
啊虽然那个时间不长啊

03:40.250 --> 03:40.650
但是呢

03:40.650 --> 03:42.950
毕竟会占用一些网络资源啊

03:43.150 --> 03:46.650
会占用比较大的网络资源

03:46.850 --> 03:48.650
服务器的网络资源很珍贵的

03:48.850 --> 03:51.750
就虽然只有那么可能只有十几二十秒啊

03:51.750 --> 03:52.050
但是呢

03:52.050 --> 03:53.350
毕竟会占用而且呢

03:53.350 --> 03:54.850
npm install的过程中呢

03:54.850 --> 03:56.750
服务器呢CPUR内存呢

03:56.750 --> 03:58.550
也会占用的比较多啊

03:58.550 --> 03:59.750
这是第一个问题啊

04:00.150 --> 04:01.650
嗯第二个问题呢就是

04:03.350 --> 04:04.350
代码啊

04:05.150 --> 04:06.050
没有压缩

04:06.850 --> 04:08.750
没有压缩会导致什么问题呢

04:08.750 --> 04:10.250
也不会导致太大的问题

04:10.750 --> 04:12.950
因为这个东西毕竟是在服务中运行的啊

04:12.950 --> 04:13.550
他不是说

04:14.050 --> 04:15.850
像浏览器没有压缩就很严重了

04:15.850 --> 04:16.850
对吧因为那个浏览器

04:16.850 --> 04:18.250
浏览器代码没有压缩的话

04:18.250 --> 04:20.050
他从服务器传到浏览器

04:20.050 --> 04:21.450
它是一个传输过程

04:22.050 --> 04:23.450
那我们这代码呢压

04:23.450 --> 04:24.050
没有压缩呢

04:24.050 --> 04:26.650
它只是我上传到服务器的时候

04:27.150 --> 04:29.050
我的代码是不是就只上传一次

04:29.050 --> 04:31.450
对吧用户要不要用我的代码

04:31.450 --> 04:33.150
这是服务器的程序啊

04:33.250 --> 04:34.950
这是我们搭建服务器的程序用户

04:34.950 --> 04:36.050
根本就用不到这个代码

04:36.050 --> 04:36.950
它不会去下载的

04:36.950 --> 04:38.150
它不可能下载

04:38.250 --> 04:39.450
也没有权力下载

04:39.550 --> 04:41.350
对吧它是在运行在服务器上的

04:41.550 --> 04:43.350
就是我们编写好代码之后呢

04:43.650 --> 04:47.450
嗯呃服务器那边使用计程拉去的时候

04:47.450 --> 04:50.150
所以拉去的是一种元色代码格式

04:50.250 --> 04:51.550
它是没有压缩的

04:51.650 --> 04:54.350
所以说呢拉取的速度可能会比较慢

04:54.350 --> 04:57.950
当然了也只是可能也只是占用一两分钟啊

04:58.250 --> 05:00.450
拉取速度啊浇慢

05:02.050 --> 05:03.250
这种这种情况

05:03.950 --> 05:06.150
还有呢还有什么情况呢

05:06.350 --> 05:08.650
还有其中情况就是那个呃

05:09.650 --> 05:12.050
在漏的开发的就是开发过程中啊

05:12.350 --> 05:13.650
在开发过程中

05:14.950 --> 05:18.350
呃无法使用叫新的

05:19.650 --> 05:20.150
呃

05:20.750 --> 05:21.250
叫

05:21.750 --> 05:23.150
新的语法

05:23.250 --> 05:26.050
因为你使用的语法规则必须要漏的支持

05:26.250 --> 05:27.850
漏的不支持的语法呀

05:27.850 --> 05:30.250
不支持的API比较比较新的API呢

05:30.250 --> 05:31.550
它是无法识别的

05:32.350 --> 05:34.050
还有还有什么还有什么问题呢

05:34.050 --> 05:35.750
就是开发过程中啊

05:35.750 --> 05:36.450
这个问题呢

05:36.550 --> 05:37.550
就最后一个问题呢

05:37.550 --> 05:39.150
还是有点麻烦的啊

05:39.850 --> 05:41.150
主要是最后一个问题

05:41.750 --> 05:45.950
始终无法使用ES6模块化

05:46.150 --> 05:47.550
对吧因为有些工程呢

05:47.550 --> 05:49.150
他有自己的名为规定啊

05:49.150 --> 05:50.550
尽量使用ES6

05:50.550 --> 05:53.150
然后全公司使用标准的模块化方式

05:53.150 --> 05:53.950
来编写代码

05:54.050 --> 05:55.650
他无法使用ES6的模块化

05:56.550 --> 05:58.450
因为也不是说无法使用吧

05:58.450 --> 06:00.650
其实在漏的GS里边是可以使用的

06:00.650 --> 06:02.050
对吧我们之前也讲过

06:02.050 --> 06:03.550
在讲漏的的时候也讲过

06:03.850 --> 06:05.750
呃但是呢他使用起来呢

06:05.750 --> 06:06.850
意思比较麻烦

06:06.950 --> 06:08.350
而是呢就算你使用了呢

06:08.350 --> 06:09.650
他是很难跟那个

06:09.950 --> 06:11.150
他原本的模块化

06:11.150 --> 06:12.350
就是common.js呢

06:12.450 --> 06:14.450
进行混合使用的啊

06:14.450 --> 06:15.950
但是我们知道在未派克里边说的

06:15.950 --> 06:16.850
可以混合使用

06:17.250 --> 06:19.050
所以说我们就产生了第二种模式

06:19.750 --> 06:20.150
啊

06:20.850 --> 06:22.250
呃直接开发

06:23.450 --> 06:25.450
然后呢用未派克打包

06:27.550 --> 06:27.950
啊

06:28.750 --> 06:29.550
然后部署

06:31.150 --> 06:31.850
啥意思呢

06:32.150 --> 06:33.950
就是我们就他是这种模式的啊

06:34.050 --> 06:35.150
搭建漏的工程

06:36.150 --> 06:38.750
漏的就加上未派克工程

06:39.650 --> 06:40.050
啊

06:40.550 --> 06:41.950
大家这样子这样的工程

06:42.350 --> 06:43.850
开我们开发后

06:45.450 --> 06:48.050
使用未派克打包啊

06:48.050 --> 06:49.550
使用这样的方式来打包

06:49.850 --> 06:51.650
打包过后呢是不是形成了非常

06:52.050 --> 06:53.550
呃乱的代码啊

06:53.550 --> 06:54.750
以及比较小的文件

06:54.750 --> 06:55.850
他毕竟有压缩嘛

06:55.950 --> 06:57.650
对不对啊比较小的文件

06:57.850 --> 06:58.950
打包之后呢

06:59.850 --> 07:00.750
呃然后呢

07:01.250 --> 07:02.450
将打包结果

07:04.660 --> 07:05.260
结果

07:06.260 --> 07:08.060
上传到服务器

07:08.460 --> 07:09.660
啊服务器直接运行

07:10.960 --> 07:12.460
对吧他就变成这种模式了

07:12.460 --> 07:13.460
也就是他这个东西呢

07:13.460 --> 07:14.160
他的服务器呢

07:14.160 --> 07:16.160
就不需要去用什么npm install啊

07:16.160 --> 07:16.760
没有了

07:17.060 --> 07:18.160
直接发个打包结果

07:18.260 --> 07:20.060
就是个原始文件直接扔到服务器

07:20.660 --> 07:22.360
比方说我们在漏的里边

07:22.560 --> 07:23.260
要用到

07:24.060 --> 07:26.560
直接获得间接依赖300多个库

07:27.560 --> 07:29.360
那么按照传统的做法

07:29.460 --> 07:31.860
是不是把我们的元代码进行计设管理过后

07:31.860 --> 07:33.460
服务器从计程拿去元代码

07:33.560 --> 07:34.860
然后用npm install

07:34.960 --> 07:36.460
去安装了300多个库

07:36.660 --> 07:38.660
对不对那么这个安装的比较慢的

07:38.860 --> 07:40.160
那这种方式就不一样了

07:40.260 --> 07:41.660
这种方式我们使用未派打包

07:41.660 --> 07:43.260
因为我们知道未派打包过后呢

07:43.460 --> 07:44.560
他无论多少依赖

07:44.860 --> 07:46.260
那么他就最终会到那个

07:46.260 --> 07:47.560
我们打包的结果里边

07:48.260 --> 07:50.660
他漏的毛90的目录对对运行的时候

07:50.660 --> 07:51.960
就没有意义任何意义了

07:52.260 --> 07:54.760
那么我们把打包的结果里边直接上传到服务器

07:54.860 --> 07:56.260
那么这个上传过后呢

07:56.260 --> 07:57.860
服务器是不是就可以直接用了

07:58.160 --> 07:59.760
对不对就可以直接运行那个代码

08:00.160 --> 08:01.060
而且在这个过程中

08:01.060 --> 08:02.460
还支持那个缺鞋铭

08:02.460 --> 08:05.160
来进一步减少那个压缩代码

08:05.460 --> 08:07.860
因为未派可是支持那个缺鞋铭的

08:07.860 --> 08:08.360
对不对

08:09.360 --> 08:10.460
好那么我们基于这

08:10.460 --> 08:12.860
当然这个不是说一定要得这么做啊

08:13.060 --> 08:14.060
不要把他学死了

08:14.460 --> 08:16.160
他只是说这是一种方案

08:16.560 --> 08:17.660
好咱们来看一下吧

08:17.660 --> 08:18.760
我们这拿去过后呢

08:18.760 --> 08:20.460
其实这里边其实很简单

08:20.660 --> 08:22.560
我们的为我们之后的漏的代码

08:22.560 --> 08:24.060
就可以写到这个src里边

08:24.460 --> 08:25.360
就可以写到这里边

08:25.760 --> 08:27.360
当然这里边我就随便写了一些

08:27.360 --> 08:28.560
你看漏的代码里边

08:28.560 --> 08:29.760
我们现在也可以使用

08:30.260 --> 08:31.460
es6的模块化了

08:31.460 --> 08:33.760
比方说我们使用漏的内置模块

08:33.760 --> 08:35.860
我们可以使用es6的方式带导入

08:36.560 --> 08:37.260
那么这里呢

08:37.260 --> 08:38.560
我们之前也讲过吹吸紧

08:38.560 --> 08:39.760
对吧我们这里是用漏带

08:39.760 --> 08:42.060
写es啊这个模里边去导入这个

08:42.460 --> 08:42.860
创口

08:43.460 --> 08:44.260
这样随便的

08:44.260 --> 08:44.860
不要这里呢

08:44.860 --> 08:46.260
我们使用内置模块去读取

08:46.260 --> 08:47.960
当前目录下面的所有内容

08:48.160 --> 08:50.160
然后呢使用创口这个函数啊等等

08:50.160 --> 08:51.360
当然这里边也可以使用什么

08:51.360 --> 08:53.660
express啊那些东西都可以使用

08:53.960 --> 08:54.860
都可以使用的

08:55.660 --> 08:56.360
好那么这里呢

08:56.360 --> 08:57.760
我们比方说这就是漏的代码

08:58.360 --> 08:59.360
然后呢我们到

08:59.560 --> 09:01.460
我们看一下我们这个pac.json

09:01.860 --> 09:03.960
这里边让我们订印了这么一些脚本啊

09:03.960 --> 09:04.460
这些脚本呢

09:04.460 --> 09:05.760
看上去好像很复杂的样子

09:05.760 --> 09:06.760
我一个说一下吧

09:06.960 --> 09:07.760
首先说build

09:08.260 --> 09:11.060
build很简单就是生产环境打包

09:11.960 --> 09:13.460
我这里安装一个crossing

09:13.560 --> 09:14.560
所以以前讲过的

09:14.660 --> 09:17.160
在讲那个就是包管理器的时候就讲过了

09:17.260 --> 09:20.560
就是跨平台的去设置环境片架

09:20.560 --> 09:22.960
我们设置漏的n5v production

09:23.960 --> 09:25.260
那么然后打包

09:25.860 --> 09:26.660
这就很完了

09:26.660 --> 09:28.460
build的模式就是这种模式

09:28.560 --> 09:29.560
好咱们来看一下吧

09:31.660 --> 09:32.860
首先安装一旦啊

09:34.160 --> 09:34.860
安装一旦

09:40.280 --> 09:41.280
好安装完成了

09:42.780 --> 09:45.080
好接来们打包啊用build来打包

09:47.580 --> 09:49.780
好这里是用npm装build

09:52.720 --> 09:54.020
好你看是不是打包出来了

09:54.420 --> 09:55.120
好打包出来了

09:55.120 --> 09:57.820
你看第四目录里边就是一个index.js了

09:59.520 --> 10:00.720
然后呢现在我们就运行一下

10:00.720 --> 10:02.720
index.js呢

10:04.420 --> 10:07.320
就电视目录下面的index.js

10:07.420 --> 10:08.020
运行一下

10:08.220 --> 10:09.220
所以可以运行对吧

10:09.220 --> 10:10.720
当前目录的所有文件

10:10.920 --> 10:13.420
还有就是创可寒出的结果

10:13.920 --> 10:14.720
所以可以运行

10:15.020 --> 10:15.920
那么运行的是啊

10:15.920 --> 10:16.920
运行的就是这个

10:16.920 --> 10:18.720
现在我们src是远代版部录

10:18.720 --> 10:19.920
然后最终运行的是这个

10:19.920 --> 10:20.920
这个电视目录对吧

10:20.920 --> 10:21.520
是一样的

10:21.520 --> 10:23.420
只是他不在浏览器里边运行的

10:23.520 --> 10:24.920
是在load环境里边运行

10:25.720 --> 10:26.620
好继续看啊

10:27.020 --> 10:28.720
嗯下一个呢就是这个

10:29.520 --> 10:30.020
嗯

10:31.520 --> 10:33.220
dev就是开发模式

10:33.420 --> 10:34.620
开发模式呢

10:34.620 --> 10:36.920
就生产环境的部属呢很简单

10:36.920 --> 10:38.520
就是打包打包就完事了啊

10:38.920 --> 10:41.320
最终最终不要说我们要把上传到服务系

10:41.320 --> 10:41.920
就上了啥

10:41.920 --> 10:43.420
就上传这个文件的样子里边的内容

10:43.420 --> 10:45.220
其他东西跟服务系没什么关系

10:45.320 --> 10:46.920
最终运行的也只是运行它

10:46.920 --> 10:47.320
对吧

10:47.320 --> 10:48.820
其他部属里没有关系了

10:49.220 --> 10:50.420
那么生产环境呢

10:50.620 --> 10:52.420
生产环境呢我们可以直接运行这个

10:52.420 --> 10:54.520
当然最好了我们跟服务器保持一致

10:54.520 --> 10:56.720
还是运行运行电神部路下面的

10:57.020 --> 10:57.920
那怎么运行的

10:58.120 --> 10:59.620
你看啊我们的逻辑是什么

10:59.920 --> 11:00.720
生产环境

11:00.820 --> 11:01.720
大家说一下啊

11:04.770 --> 11:05.570
生产

11:06.670 --> 11:08.270
环境的运行

11:09.370 --> 11:09.770
啊

11:10.170 --> 11:11.070
第一步干嘛呢

11:11.070 --> 11:13.070
第一步就是设置环境辨量

11:14.070 --> 11:14.570
为

11:14.870 --> 11:15.670
生产环境

11:15.970 --> 11:17.570
而为什么要设置这个环境辨量

11:17.670 --> 11:19.370
其实也不是说必须要设置啊

11:19.370 --> 11:20.970
只是我这里的这么一种处理

11:20.970 --> 11:22.870
因为我这个生产环境的打包呢

11:22.870 --> 11:25.370
跟那个开发模式的打包呢

11:25.370 --> 11:26.570
毕竟有一些差异啊

11:26.570 --> 11:28.370
所以说我在卫派航飞隔里边呢

11:28.370 --> 11:30.070
我要去读习这个环境辨量

11:30.070 --> 11:32.170
然后根据不同的环境辨量呢

11:32.170 --> 11:33.670
来做一些不同的配置啊

11:33.670 --> 11:35.070
主要是区域这么一个目的

11:35.370 --> 11:36.570
所以说我们这里的第一步

11:36.570 --> 11:38.370
设置环境辨量为生产环境

11:38.870 --> 11:39.670
好第二步呢

11:39.670 --> 11:40.270
你看是不是

11:43.070 --> 11:44.270
然后要监控

11:45.070 --> 11:45.570
我

11:45.970 --> 11:47.970
把这个顺序按照我这里的写法来写吧

11:47.970 --> 11:48.970
我这个逻辑是

11:49.070 --> 11:51.770
首先用load 监控src目录

11:51.770 --> 11:53.270
这是原代码目录对吧

11:53.670 --> 11:56.170
监控原代码目录

11:56.170 --> 11:58.170
那么如果说原代码有改动字

11:58.170 --> 11:59.370
有改动的时候呢

11:59.370 --> 12:00.770
干嘛让我执行一个命令

12:00.970 --> 12:02.170
这个命令是什么呢

12:02.170 --> 12:03.370
先执行这个

12:04.170 --> 12:05.170
先执行这个

12:05.670 --> 12:06.970
然后再执行

12:07.770 --> 12:08.270
这个

12:09.170 --> 12:11.770
是不是这里执行下面两个脚本

12:11.970 --> 12:13.570
按照顺序先执行这个

12:13.570 --> 12:14.470
再执行这个

12:14.970 --> 12:16.570
如果说原代码有改动

12:17.170 --> 12:19.570
如果原代码有变动

12:19.570 --> 12:21.170
或者是一开始的时候

12:21.170 --> 12:22.570
一开始要运行的命令

12:23.070 --> 12:24.970
好那么接下来我执行两条命令

12:24.970 --> 12:25.670
第一条

12:27.070 --> 12:28.070
第一条是什么呢

12:28.070 --> 12:28.970
第一条是

12:29.270 --> 12:33.370
将环境辨量设置为

12:34.370 --> 12:35.370
development

12:36.870 --> 12:38.270
好然后呢

12:38.770 --> 12:39.570
进行打包

12:40.470 --> 12:42.170
然后进行打包

12:42.370 --> 12:42.870
你看

12:43.370 --> 12:44.270
先执行它

12:44.270 --> 12:46.070
把环境变量设为DVD development

12:46.070 --> 12:47.070
然后进行打包

12:47.670 --> 12:49.270
然后接下来第二件事呢

12:49.270 --> 12:49.970
是干嘛呢

12:50.070 --> 12:52.470
是运行打包结果里边东西

12:53.070 --> 12:53.670
运行

12:55.070 --> 12:56.170
打包结果

12:57.370 --> 12:58.470
那么这上次是不是

12:58.870 --> 13:00.570
就优下来就非常方便了

13:00.670 --> 13:02.370
我们当我们使用这个命令的时候

13:02.570 --> 13:04.170
它会监控src目录

13:04.270 --> 13:05.670
只要这里边东西一变动

13:05.670 --> 13:06.470
然后就打包

13:06.470 --> 13:07.370
然后就运行

13:07.670 --> 13:08.570
然后我们改代码

13:08.570 --> 13:09.170
改完了不好

13:09.170 --> 13:10.770
它又重新打包又重新运行

13:11.070 --> 13:11.570
对吧

13:11.870 --> 13:12.870
它是一样的

13:12.970 --> 13:14.270
好这样让我们看一下吧

13:14.670 --> 13:16.270
npm

13:19.680 --> 13:20.080
好

13:20.580 --> 13:21.780
你看是不是运行出来了

13:21.980 --> 13:23.680
好接下来我们来改动一下代码

13:23.780 --> 13:24.780
在这边

13:24.780 --> 13:25.780
比方说我们这里

13:26.080 --> 13:27.780
写成三三个一组

13:27.980 --> 13:28.580
保存

13:28.780 --> 13:30.380
那么这边重新打包

13:30.380 --> 13:31.180
重新运行

13:31.680 --> 13:32.180
对吧

13:32.680 --> 13:33.480
说很简单

13:35.180 --> 13:36.380
那么这人的也可以

13:36.480 --> 13:38.180
也可以在开发模式里边

13:38.180 --> 13:40.180
我不想看到这么多乱七八糟的输出

13:40.180 --> 13:41.180
vpac里边

13:41.180 --> 13:42.680
不想看到那么多乱七八糟的输出

13:42.680 --> 13:44.580
我们这里可以把这个

13:44.980 --> 13:45.580
stage

13:46.580 --> 13:47.180
设为什么了

13:47.180 --> 13:47.780
设为呢

13:49.680 --> 13:51.280
不要给我发生这么的消息

13:51.780 --> 13:52.780
那么重新运行

13:53.580 --> 13:54.080
这样子呢

13:54.080 --> 13:54.480
消息呢

13:54.480 --> 13:55.380
就会少很多

13:56.180 --> 13:56.580
好了

13:56.980 --> 13:58.380
那么就是生产环境打包

13:58.780 --> 14:00.480
最后我们来看一下vpac的配置

14:00.780 --> 14:01.380
配置里边呢

14:01.380 --> 14:02.880
其实有一个关键点

14:03.180 --> 14:03.780
就是什么呢

14:03.780 --> 14:04.880
其他都差不多

14:04.880 --> 14:05.480
什么dev2

14:05.480 --> 14:06.180
不用讲了

14:06.180 --> 14:06.580
是吧

14:06.780 --> 14:08.580
如果这里我得到一个辩量

14:08.580 --> 14:10.980
看它是不是开发模式

14:10.980 --> 14:12.280
如果说是开发模式的话

14:12.280 --> 14:12.980
那么我们这里写

14:13.980 --> 14:15.080
否则的话就写

14:15.080 --> 14:17.080
如果说这里呢

14:18.080 --> 14:18.880
看一下下面

14:18.880 --> 14:19.880
这一个别名

14:19.880 --> 14:20.080
对吧

14:20.080 --> 14:21.080
还可以定义别名

14:21.580 --> 14:22.580
然后这边

14:23.580 --> 14:24.280
dev2

14:24.280 --> 14:25.680
如果说是开发模式的话

14:25.680 --> 14:26.680
我就加上 source map

14:26.780 --> 14:28.080
所以否则的话我就不加

14:28.880 --> 14:29.280
n群呢

14:29.280 --> 14:31.180
都是src下面的index的介绍

14:31.180 --> 14:32.180
关键有一个地方

14:32.180 --> 14:33.680
就是 target 等于 load

14:34.180 --> 14:35.480
因为这个东西我们以前讲过

14:35.680 --> 14:36.880
默认是什么web

14:37.980 --> 14:39.280
默认是在浏览性环境

14:39.280 --> 14:41.280
打包的结果是在浏览性环境里边运行

14:41.480 --> 14:42.380
如果说告诉他

14:42.480 --> 14:43.780
我们在 load 环境里边运行

14:43.980 --> 14:45.080
这里需要告诉他

14:45.280 --> 14:47.080
那么如果说不告诉他怎么办呢

14:47.280 --> 14:48.080
不告诉他的话

14:48.080 --> 14:49.180
这东西就出问题了

14:49.580 --> 14:50.880
他找不到 fs

14:50.980 --> 14:51.780
他会去哪里找呢

14:51.780 --> 14:52.580
他会去这里找

14:52.880 --> 14:54.980
因为他不知道 fs 是一个内置模块

14:55.080 --> 14:56.080
那浏览性环境

14:56.280 --> 14:56.580
对吧

14:56.580 --> 14:57.980
他认为是在 load 90 里边

14:58.380 --> 14:59.780
那么在 wepike 里边的

14:59.780 --> 15:01.080
就是在 load 环境里边的

15:01.180 --> 15:02.280
一般他设置为 load 环境

15:02.280 --> 15:02.880
他就知道了

15:02.880 --> 15:05.580
原来 fs 是一个内置模块

15:05.780 --> 15:07.380
它只是一个内置模块

15:07.380 --> 15:08.680
那么他是怎么来处理呢

15:08.680 --> 15:09.580
一看一下这里

15:10.380 --> 15:11.380
针对 fs

15:13.380 --> 15:13.980
看一下吧

15:15.980 --> 15:16.780
针对

15:17.480 --> 15:18.080
折起来

15:18.080 --> 15:20.080
这些都是 load 的 es 里面的一些遗难

15:21.280 --> 15:22.780
我先把这些这样吧

15:22.980 --> 15:24.480
我把 load 把这个东西去掉

15:25.480 --> 15:26.080
注释一下

15:29.790 --> 15:30.590
重新运行啊

15:33.120 --> 15:33.920
好 看一下这边

15:34.220 --> 15:35.420
这边代码就少很多了

15:35.620 --> 15:37.220
然后我们看一下这个 fs 模块

15:37.620 --> 15:38.920
折叠一下

15:39.320 --> 15:40.020
in 这个时代

15:40.020 --> 15:41.620
我们是不是导入了 fs

15:41.620 --> 15:41.820
对吧

15:41.820 --> 15:43.020
导入 fs 模块

15:43.020 --> 15:44.220
然后 fs 模块呢

15:44.320 --> 15:45.220
他导出了什么呢

15:45.220 --> 15:46.720
他导出了就是 fs

15:46.720 --> 15:47.120
对吧

15:47.120 --> 15:48.520
他知道他是一个内置模块

15:49.620 --> 15:50.520
他就完事了

15:50.520 --> 15:53.220
这就是这种的 load 环境里边

15:53.420 --> 15:54.520
纯 load 环境里边

15:54.520 --> 15:56.420
我们可以使用这种模式来进行打包

15:56.520 --> 15:57.820
当然 load 环境呢

15:57.820 --> 15:59.920
有很多的应用场景

16:00.020 --> 16:02.520
比方说将来我们讲到的 rex ssr

16:03.120 --> 16:03.420
对不对

16:03.420 --> 16:04.520
也是个 load 环境嘛

16:04.520 --> 16:05.820
那么他的打包方式呢

16:05.820 --> 16:06.420
又有一

16:06.420 --> 16:07.720
他也要用到 webhack

16:07.720 --> 16:08.520
那么打包方式呢

16:08.520 --> 16:09.720
就会有一些差异

16:09.720 --> 16:12.120
因为他毕竟有一些 rex 在里边

16:12.920 --> 16:14.120
那么到时候你们学到过后呢

16:14.120 --> 16:15.720
我到当时会讲

16:16.720 --> 16:18.220
还有一种情况呢

16:18.220 --> 16:19.120
我们下节课再说

16:19.120 --> 16:21.920
就 load 跟那个前端一起来连用

16:21.920 --> 16:23.420
比方说 load 和 load

16:23.420 --> 16:24.620
没有机要搭服务器

16:24.620 --> 16:25.920
因为 load 搭搭服务器

16:25.920 --> 16:27.220
又要编写 load 代码

16:27.220 --> 16:28.120
那么这种情况呢

16:28.120 --> 16:29.420
工程又该怎么去设置

16:29.920 --> 16:30.420
当然这些呢

16:30.420 --> 16:32.820
都没有什么固定的

16:33.120 --> 16:34.420
都是比较灵活的

16:34.720 --> 16:35.220
根据以后

16:35.220 --> 16:36.920
你们根据公司里边的具体情况

16:36.920 --> 16:37.820
具体在处理

16:37.920 --> 16:39.920
看每个公司上又有点不一样

16:39.920 --> 16:40.820
我这里只是

16:41.020 --> 16:41.520
下节课呢

16:41.520 --> 16:42.520
只是给大家提些

16:42.520 --> 16:44.920
像我们这么几节课

16:45.020 --> 16:46.620
就像案例这么几节课

16:46.620 --> 16:48.020
不是说是固定的

16:48.220 --> 16:49.820
学东西不要把他学死了

16:49.820 --> 16:51.420
只给他提供一种思路

16:51.420 --> 16:52.620
让他能够理解

16:52.620 --> 16:53.620
这是怎么回事

16:53.920 --> 16:55.220
OK 这是关于 load 的的

16:55.220 --> 16:56.420
就是位牌打包

