WEBVTT

00:00.750 --> 00:04.750
好 咱们这一课做一个扩展课程

00:04.750 --> 00:06.750
研究一下这个bible

00:06.750 --> 00:08.750
它对内是怎么进行转换的

00:08.750 --> 00:11.750
因为我们知道内是一个ES6的语法

00:11.750 --> 00:15.750
那么把它转换成一个通用的ES5的语法

00:15.750 --> 00:17.750
或者是更低版本的ES语法

00:17.750 --> 00:19.750
那么应该就这么做

00:19.750 --> 00:22.750
凡是我的课程里边

00:22.750 --> 00:26.750
课程名称前边写了一个扩展这两个字的

00:26.750 --> 00:27.750
大家都懂的

00:27.750 --> 00:29.750
就是说你可以不看

00:29.750 --> 00:32.750
你自己的需要选择性的观看

00:32.750 --> 00:35.750
因为扩展课程难度比较高

00:35.750 --> 00:38.750
更重要的是在线阶段

00:38.750 --> 00:40.750
就是作为一个初学者来说

00:40.750 --> 00:42.750
那么扩展课程对你们的帮助

00:42.750 --> 00:46.750
也可能是仅仅先于拓展你们的思维

00:46.750 --> 00:48.750
拓展你们的眼界

00:48.750 --> 00:49.750
就这么一点帮助

00:49.750 --> 00:51.750
它对你实际的去找工作

00:51.750 --> 00:53.750
可能意义不大

00:53.750 --> 00:55.750
所以说大家如果说有兴趣

00:55.750 --> 00:58.750
也想知道一些内部的

00:58.750 --> 01:00.750
就是比较深入的事情

01:00.750 --> 01:02.750
那么可以去看一看扩展课程

01:02.750 --> 01:04.750
否则的话就选择性的观看吧

01:04.750 --> 01:07.750
因为这个地方确实有点打击人

01:07.750 --> 01:12.750
因为它需要非常非常扎实的程序基础

01:12.750 --> 01:15.750
就是你前面如果说你基础非常非常扎实

01:15.750 --> 01:17.750
那么你看这个扩展课程

01:17.750 --> 01:18.750
也能看得懂

01:18.750 --> 01:19.750
如果说你前面基础

01:19.750 --> 01:20.750
没有那么扎实的话

01:20.750 --> 01:22.750
特别是初学者基础

01:22.750 --> 01:25.750
多多少少都会有一些问题

01:25.750 --> 01:26.750
所以说看扩展课程

01:26.750 --> 01:28.750
很多人会比较吃力

01:28.750 --> 01:29.750
那么这一刻咱们来看一下

01:29.750 --> 01:31.750
它对内是怎么转换的

01:31.750 --> 01:33.750
这里我写了一个GS

01:33.750 --> 01:34.750
写了这个GS

01:34.750 --> 01:36.750
这个GS我就使用了ES6的语法

01:36.750 --> 01:37.750
一个内

01:37.750 --> 01:40.750
并且里边我还使用了ES7的语法

01:40.750 --> 01:42.750
对内的字端进行初始化

01:42.750 --> 01:44.750
初始化一个字端

01:44.750 --> 01:45.750
然后这内的构造器

01:45.750 --> 01:47.750
构造器里边我顺便还使用了

01:47.750 --> 01:48.750
一个默正参数

01:48.750 --> 01:50.750
你看参数默认值

01:50.750 --> 01:51.750
是不是也是ES6的语法

01:51.750 --> 01:52.750
顺便去看一看

01:52.750 --> 01:53.750
参数默认值

01:53.750 --> 01:54.750
它又是怎么做的

01:54.750 --> 01:57.750
然后构造器里边

01:57.750 --> 01:58.750
我给一个属性负值

01:58.750 --> 02:00.750
属性2负值为B

02:00.750 --> 02:03.750
接下来我写了四个方法

02:03.750 --> 02:05.750
这四个方法

02:05.750 --> 02:07.750
分别是普通方法

02:07.750 --> 02:10.750
然后是一个箭头函数方法

02:10.750 --> 02:12.750
箭头函数方法

02:12.750 --> 02:14.750
函数方法里边

02:14.750 --> 02:16.750
我还用了ES6的圣语参数

02:16.750 --> 02:18.750
你看这些东西都需要转换

02:18.750 --> 02:22.750
然后还使用了一个就是静态方法

02:23.750 --> 02:25.750
这里边还使用了静态方法

02:25.750 --> 02:26.750
里边使用了Z

02:26.750 --> 02:28.750
然后还使用了一个静态的

02:28.750 --> 02:30.750
箭头函数方法

02:30.750 --> 02:32.750
里边也使用了Z

02:32.750 --> 02:34.750
这就是我们的元代

02:34.750 --> 02:36.750
这个代码肯定是需要转换的

02:36.750 --> 02:37.750
那怎么转换呢

02:37.750 --> 02:39.750
我们可以在这里安装

02:39.750 --> 02:40.750
Bible来进行转换

02:40.750 --> 02:41.750
也可以

02:41.750 --> 02:43.750
因为我现在是研究它的转换结果

02:43.750 --> 02:44.750
所以说

02:44.750 --> 02:46.750
Bible我们已经学习完了

02:46.750 --> 02:48.750
所以说没有必要再去安装Bible了

02:48.750 --> 02:50.750
那么我们怎么转换呢

02:50.750 --> 02:53.750
我们也可以去到Bible的官方网站

02:53.750 --> 02:55.750
我这里不去官网了

02:55.750 --> 02:57.750
就去个民间的中文网

02:57.750 --> 02:58.750
这个网站里边

02:58.750 --> 03:00.750
其实它就有一个地方就可以转换了

03:00.750 --> 03:01.750
你看这里

03:01.750 --> 03:03.750
你看这里我写CounselA.V

03:03.750 --> 03:05.750
你看它转换成VAR了

03:05.750 --> 03:06.750
对吧

03:06.750 --> 03:07.750
它其实这里就可以

03:07.750 --> 03:09.750
它这里其实就使用的是Bible

03:09.750 --> 03:10.750
进行转换的

03:10.750 --> 03:11.750
可以在这里进行试验

03:11.750 --> 03:13.750
查看它的转换结果

03:13.750 --> 03:14.750
不过呢

03:14.750 --> 03:16.750
如果说你在这个首页里边进行转换的话

03:16.750 --> 03:17.750
它这个

03:17.750 --> 03:19.750
转换的只能做最基本的转换

03:19.750 --> 03:20.750
像一些比较

03:20.750 --> 03:22.750
一些需要一些额外的API的地方

03:22.750 --> 03:23.750
它就

03:23.750 --> 03:25.750
转换的时候可能要爆错

03:25.750 --> 03:27.750
所以说我们要使用Bible的完整的转换

03:27.750 --> 03:29.750
我们点这个试试

03:30.750 --> 03:31.750
试试吧

03:32.750 --> 03:33.750
点击它

03:34.750 --> 03:36.750
然后我们把这个代码直接复制过来

03:41.130 --> 03:42.130
等一下

03:43.130 --> 03:45.950
把这个东西关了

03:46.950 --> 03:48.950
刚才我已经拿过来了

03:48.950 --> 03:49.950
把这个代码放过来

03:49.950 --> 03:51.950
放过来之后你看到

03:51.950 --> 03:52.950
我们再放一试吧

03:58.350 --> 03:59.350
然后呢展开过来

03:59.350 --> 04:02.350
你就会看到右边有它的转换结果

04:02.350 --> 04:04.350
这个转换结果怎么这么复杂

04:04.350 --> 04:06.350
这节课咱们就来分析这个转换结果

04:06.350 --> 04:07.350
它到底是怎么做的

04:07.350 --> 04:09.350
其实也是在交给大家

04:09.350 --> 04:12.350
如何来阅读元代码

04:12.350 --> 04:15.350
阅读元代码最关键点在于什么呢

04:15.350 --> 04:18.350
最关键点你要找到它的

04:18.350 --> 04:21.350
起最重要作用的地方

04:21.350 --> 04:23.350
那你怎么来找到的

04:23.350 --> 04:26.350
这个东西真没有规律

04:26.350 --> 04:28.350
具体情况具体分析吧

04:29.350 --> 04:31.350
首先这个元代码看起来就非常不好看

04:31.350 --> 04:32.350
对吧

04:32.350 --> 04:34.350
我们这里的我一般会怎么样做呢

04:34.350 --> 04:37.350
我一般如果说在网页上看到一段元代码

04:37.350 --> 04:39.350
我一般会直接把它全部复制

04:40.350 --> 04:42.350
粘贴到一个介绍文件里面

04:42.350 --> 04:43.350
这样子我也可以格式化

04:43.350 --> 04:45.350
也可以进行折叠非常方便

04:45.350 --> 04:46.350
Target

04:46.350 --> 04:48.350
这是它转换之后的代码

04:49.350 --> 04:51.350
然后我们把粘贴型的

04:51.350 --> 04:52.350
格式化一下

04:53.350 --> 04:55.350
这是它转换之后的元代码

04:55.350 --> 04:56.350
转换之后的元代码

04:56.350 --> 04:58.350
我们说读元代码的最重要的是

04:58.350 --> 05:01.350
要找到它起最核心作用的地方

05:01.350 --> 05:02.350
那怎么来找呢

05:02.350 --> 05:03.350
我就这样子想

05:03.350 --> 05:05.350
我这里不是有个内A吗

05:05.350 --> 05:07.350
我先不管内里边是啥东西

05:07.350 --> 05:10.350
你总得把内E给我做出来吧

05:10.350 --> 05:11.350
那么这里

05:11.350 --> 05:14.350
我就看元代码里边哪个地方是A

05:14.350 --> 05:15.350
是不是看到这

05:15.350 --> 05:16.350
看到这

05:16.350 --> 05:17.350
它给一个A复制

05:17.350 --> 05:19.350
那么我就可以大胆的猜想

05:19.350 --> 05:22.350
这个A肯定是对应我边这边的A

05:22.350 --> 05:23.350
对吧

05:23.350 --> 05:24.350
肯定是对应这里的A

05:24.350 --> 05:26.350
那么这个A它给它复制

05:26.350 --> 05:27.350
复制为一个什么呢

05:27.350 --> 05:29.350
因为看到它复制为一个函数

05:29.350 --> 05:31.350
而且是一个另一面函数

05:31.350 --> 05:33.350
另一面函数里面还有一个函数A

05:33.350 --> 05:35.350
我把它折叠一下

05:35.350 --> 05:36.350
你会看到

05:36.350 --> 05:38.350
它给它复制为一个啥呀

05:38.350 --> 05:40.350
给它复制为一个立即执行函数

05:40.350 --> 05:41.350
看到没

05:41.350 --> 05:43.350
所以给它复制为一个立即执行函数

05:43.350 --> 05:46.350
这个立即执行函数的结果

05:46.350 --> 05:47.350
你看立即执行

05:47.350 --> 05:48.350
执行的反而回结果

05:48.350 --> 05:50.350
你其他地方不要看

05:50.350 --> 05:51.350
你越读元旦

05:51.350 --> 05:52.350
如果说你这样读

05:52.350 --> 05:53.350
你一定死定了

05:53.350 --> 05:54.350
你从第一行开始读

05:54.350 --> 05:55.350
你一定死了

05:55.350 --> 05:57.350
这个东西没法读的

05:57.350 --> 05:58.350
你都不知道它的干嘛

05:58.350 --> 05:59.350
所以说一定要找它

05:59.350 --> 06:01.350
核心到关键的点

06:01.350 --> 06:02.350
这个东西呢

06:02.350 --> 06:04.350
我虽然说我现在给大家讲

06:04.350 --> 06:05.350
怎么去读元旦嘛

06:05.350 --> 06:07.350
但是你没有

06:07.350 --> 06:09.350
很多的程序

06:09.350 --> 06:11.350
开发经验的话

06:11.350 --> 06:12.350
这一块读习还是痛苦

06:12.350 --> 06:13.350
没关系

06:13.350 --> 06:14.350
我跟着我读吧

06:14.350 --> 06:15.350
慢慢看吧

06:15.350 --> 06:16.350
你早晚要学会的

06:16.350 --> 06:17.350
这个东西其实

06:17.350 --> 06:18.350
我学过没有呢

06:18.350 --> 06:19.350
我也没有学过

06:19.350 --> 06:20.350
我都是自己去

06:20.350 --> 06:21.350
慢慢琢磨研究的

06:21.350 --> 06:22.350
不然的话元旦嘛

06:22.350 --> 06:24.350
确实不太容易读

06:24.350 --> 06:25.350
这里呢我们看一下

06:25.350 --> 06:26.350
它给F值

06:26.350 --> 06:27.350
那么肯定是给

06:27.350 --> 06:28.350
给它复制对吧

06:28.350 --> 06:29.350
给它复制

06:29.350 --> 06:30.350
那么复制为什么呢

06:30.350 --> 06:31.350
我们知道

06:31.350 --> 06:33.350
原来复制为一个立即执行函数

06:33.350 --> 06:34.350
那么我们就可以知道

06:34.350 --> 06:38.350
干立即执行函数的反回结果

06:38.350 --> 06:40.350
这个函数立即执行的

06:40.350 --> 06:41.350
执行的反回结果

06:41.350 --> 06:43.350
应该是一个

06:43.350 --> 06:45.350
构造函数A

06:45.350 --> 06:46.350
你看是不是个逻辑

06:46.350 --> 06:48.350
因为你ES6的内部

06:48.350 --> 06:50.350
就是ES5的构造函数

06:50.350 --> 06:51.350
对不对

06:51.350 --> 06:52.350
就是一个方可形

06:52.350 --> 06:53.350
那么这里

06:53.350 --> 06:54.350
这个立即执行函数

06:54.350 --> 06:55.350
它反回的必须是个方可形

06:55.350 --> 06:57.350
我不用看里边待吧

06:57.350 --> 06:58.350
我都知道它反回的

06:58.350 --> 06:59.350
一定是一个方可形

06:59.350 --> 07:01.350
咱们展开看一下

07:01.350 --> 07:02.350
反回的是不是一个方可形

07:02.350 --> 07:03.350
那你看

07:03.350 --> 07:04.350
里边是不是定义了一个方可形A

07:04.350 --> 07:05.350
然后呢

07:05.350 --> 07:06.350
后边做了一大堆事情

07:06.350 --> 07:07.350
管它做啥事吧

07:07.350 --> 07:08.350
我们先不管它

07:08.350 --> 07:09.350
最后反回了是不是这个A

07:09.350 --> 07:10.350
对吧

07:10.350 --> 07:12.350
我们的内是不是把它

07:12.350 --> 07:14.350
转换成了一个普通的函数A

07:14.350 --> 07:15.350
对不对

07:16.350 --> 07:17.350
那么

07:17.350 --> 07:19.350
但是函数A里边

07:19.350 --> 07:20.350
因为我们的内里边

07:20.350 --> 07:21.350
是可以有很多限制的

07:21.350 --> 07:22.350
比方说你不能把

07:22.350 --> 07:24.350
你不能把一个内

07:24.350 --> 07:25.350
当成一个普通函数调用

07:25.350 --> 07:26.350
对吧

07:26.350 --> 07:27.350
这些事情呢

07:27.350 --> 07:28.350
这些限制呢

07:28.350 --> 07:29.350
它都必须要实现

07:29.350 --> 07:31.350
那么它怎么来实现呢

07:31.350 --> 07:32.350
你看啊

07:32.350 --> 07:33.350
我这里呢

07:33.350 --> 07:34.350
它这里定了一个普通函数A

07:34.350 --> 07:35.350
就是构造函数A

07:35.350 --> 07:36.350
你看

07:36.350 --> 07:38.350
构造函数A

07:38.350 --> 07:39.350
那么这个东西

07:39.350 --> 07:41.350
是不是要对应

07:41.350 --> 07:43.350
内中的什么

07:43.350 --> 07:44.350
内中的啥

07:44.350 --> 07:45.350
应该对应啥

07:45.350 --> 07:46.350
对应这个structure

07:46.350 --> 07:47.350
对吧

07:47.350 --> 07:48.350
内中的构造器

07:48.350 --> 07:49.350
是不是要对应这个

07:49.350 --> 07:50.350
有这个

07:50.350 --> 07:51.350
这个里边的代码

07:51.350 --> 07:52.350
是不是要对应这个

07:52.350 --> 07:53.350
constructor里面的代码

07:53.350 --> 07:54.350
对不对

07:54.350 --> 07:55.350
那肯定要做这件事啊

07:55.350 --> 07:56.350
对不对

07:56.350 --> 07:57.350
那么

07:57.350 --> 07:58.350
下面这个是干嘛的呢

07:58.350 --> 07:59.350
下面这个

07:59.350 --> 08:01.350
这个create class

08:01.350 --> 08:02.350
是干嘛的呢

08:02.350 --> 08:03.350
你看的啊

08:03.350 --> 08:04.350
我们把它展开一下

08:04.350 --> 08:05.350
你看

08:05.350 --> 08:06.350
我们先不用去看

08:06.350 --> 08:07.350
它里面怎么实现的

08:07.350 --> 08:08.350
有个什么输足

08:08.350 --> 08:09.350
有个什么对象

08:09.350 --> 08:10.350
我们看都不看这些东西

08:10.350 --> 08:11.350
我们看关键点

08:11.350 --> 08:13.350
一个messager1

08:14.350 --> 08:15.350
还有一个啥呀

08:15.350 --> 08:17.350
还有个messager3

08:17.350 --> 08:18.350
是什么呢

08:18.350 --> 08:19.350
messager1是啥

08:19.350 --> 08:20.350
普通方法

08:20.350 --> 08:21.350
messager3呢

08:21.350 --> 08:23.350
静态方法

08:23.350 --> 08:24.350
说明这一块

08:24.350 --> 08:26.350
它在做什么事啊

08:26.350 --> 08:27.350
在做什么事

08:27.350 --> 08:28.350
为

08:28.350 --> 08:29.350
它在为一个

08:29.350 --> 08:30.350
为什么

08:30.350 --> 08:31.350
为

08:31.350 --> 08:34.350
构造函数A

08:34.350 --> 08:36.350
定义普通方法

08:36.350 --> 08:37.350
也就是

08:37.350 --> 08:38.350
普通方法是什么

08:38.350 --> 08:39.350
就是圆形方法

08:39.350 --> 08:40.350
对吧

08:40.350 --> 08:42.350
以及静态方法

08:42.350 --> 08:44.350
静态方法就是

08:44.350 --> 08:45.350
构造函数A

08:45.350 --> 08:46.350
本身的自带的方法

08:46.350 --> 08:47.350
就在

08:47.350 --> 08:48.350
构造函数A

08:48.350 --> 08:49.350
本身上面的方法

08:49.350 --> 08:50.350
我们以前学过GS

08:50.350 --> 08:51.350
所以说这一块

08:51.350 --> 08:53.350
需要杂词的基础

08:53.350 --> 08:54.350
是吧

08:54.350 --> 08:55.350
做这么一件事

08:55.350 --> 08:56.350
你看

08:56.350 --> 08:58.350
我有一个内

08:58.350 --> 08:59.350
有了构造函数本身

08:59.350 --> 09:00.350
有了constructor

09:00.350 --> 09:02.350
有了普通方法

09:02.350 --> 09:03.350
有了静态方法之后

09:03.350 --> 09:04.350
是不是跟内

09:04.350 --> 09:05.350
基本上构建完了

09:05.350 --> 09:06.350
然后把这个内返回

09:06.350 --> 09:07.350
对吧

09:07.350 --> 09:08.350
其他地方我们先不看

09:08.350 --> 09:09.350
好

09:09.350 --> 09:10.350
接下来我们再一步一步

09:10.350 --> 09:11.350
往里边看

09:11.350 --> 09:12.350
的话就展开这个A

09:12.350 --> 09:13.350
写了一大堆带

09:13.350 --> 09:15.350
你看我们这边的constructor

09:15.350 --> 09:16.350
里边不就一行带吗

09:16.350 --> 09:18.350
它变得这么多

09:18.350 --> 09:19.350
不着急

09:19.350 --> 09:20.350
慢慢来

09:20.350 --> 09:21.350
因为我们知道这个A

09:21.350 --> 09:22.350
因为我们调个构造函数

09:22.350 --> 09:23.350
一定是6一个A

09:23.350 --> 09:24.350
对吧

09:24.350 --> 09:25.350
6一个A它一定执行这一段带

09:25.350 --> 09:26.350
所以说它这里边

09:26.350 --> 09:27.350
一定是对应这里边

09:27.350 --> 09:28.350
那时候毫无疑问的

09:28.350 --> 09:29.350
那么它这里边

09:29.350 --> 09:30.350
为什么会多出这么多的带

09:30.350 --> 09:31.350
一步一步看

09:31.350 --> 09:32.350
首先看它第一行

09:32.350 --> 09:34.350
第一行说的啥事

09:34.350 --> 09:37.350
它通过一个argument

09:37.350 --> 09:39.350
来通过argument

09:39.350 --> 09:40.350
有没有东西

09:40.350 --> 09:41.350
有东西的

09:41.350 --> 09:42.350
argument有没有东西

09:42.350 --> 09:43.350
长大于0

09:43.350 --> 09:44.350
对吧

09:44.350 --> 09:45.350
有东西的话

09:45.350 --> 09:46.350
并且第1个东西

09:46.350 --> 09:48.350
就第1个参数

09:48.350 --> 09:50.350
不等于空

09:50.350 --> 09:52.350
也就是第1个参数有值

09:52.350 --> 09:53.350
就它有参数

09:53.350 --> 09:54.350
并且第1个参数

09:54.350 --> 09:55.350
也是有值的

09:55.350 --> 09:57.350
那么我就取第1个参数

09:57.350 --> 09:59.350
否则的话就取2

09:59.350 --> 10:01.350
这一块是在实现啥

10:01.350 --> 10:02.350
是在实现啥

10:02.350 --> 10:04.350
是在实现这个东西

10:04.350 --> 10:06.350
所以说我们这1个行带

10:06.350 --> 10:07.350
它其实跟什么

10:07.350 --> 10:09.350
跟那个内的转换

10:09.350 --> 10:10.350
没有任何关系

10:10.350 --> 10:11.350
它是转换什么的

10:11.350 --> 10:13.350
它是转换参数默认值的

10:13.350 --> 10:14.350
你看吧

10:14.350 --> 10:16.350
如果说你给我了参数

10:16.350 --> 10:18.350
这个是不是给我了第1个参数

10:18.350 --> 10:20.350
我就取第1个参数

10:20.350 --> 10:21.350
你给我了第1个参数

10:21.350 --> 10:22.350
我就取第1个参数

10:22.350 --> 10:24.350
如果说你没有给我参数

10:24.350 --> 10:25.350
我就给它一个默认值2

10:25.350 --> 10:26.350
对吧

10:26.350 --> 10:28.350
这就用三目运算服务

10:28.350 --> 10:30.350
来把这个东西进行转换

10:30.350 --> 10:32.350
首先转换这个

10:32.350 --> 10:34.350
然后再转换

10:34.350 --> 10:36.350
再做点啥事

10:36.350 --> 10:38.350
叫做class call check

10:38.350 --> 10:41.860
这一步是转换

10:41.860 --> 10:43.860
转换

10:43.860 --> 10:45.860
默认

10:45.860 --> 10:49.810
参数默认值

10:49.810 --> 10:50.810
那么之后下一步做什么呢

10:50.810 --> 10:52.810
下一步你看这个函数的名

10:52.810 --> 10:53.810
它调了那个函数

10:53.810 --> 10:54.810
这是100%的

10:54.810 --> 10:55.810
这是一个函数调用

10:55.810 --> 10:56.810
那么那个函数调用

10:56.810 --> 10:57.810
它是什么意思呢

10:57.810 --> 10:58.810
你千万不要着急去看

10:58.810 --> 10:59.810
这个函数的内部的代码

10:59.810 --> 11:01.810
一看就把实为给打乱了

11:01.810 --> 11:03.810
你首先看这个函数的名字

11:03.810 --> 11:05.810
它的命名都是不是乱命名的

11:05.810 --> 11:06.810
它的命名是什么

11:06.810 --> 11:07.810
一个下方线下方线不用看

11:07.810 --> 11:08.810
class

11:08.810 --> 11:11.810
内 call check

11:11.810 --> 11:13.810
啥意思

11:13.810 --> 11:16.810
内调用检查

11:16.810 --> 11:17.810
对吧

11:17.810 --> 11:19.810
它叫内调用检查

11:19.810 --> 11:21.810
为什么要检查呢

11:21.810 --> 11:22.810
因为我们知道

11:22.810 --> 11:24.810
s6里面内的调用

11:24.810 --> 11:26.810
它是不是只能这样调用

11:26.810 --> 11:27.810
是不是只能这样调用

11:27.810 --> 11:28.810
你不能这样调用

11:28.810 --> 11:29.810
对吧

11:29.810 --> 11:30.810
s6是不是不能错过的

11:30.810 --> 11:31.810
对吧

11:31.810 --> 11:32.810
是要包错的

11:32.810 --> 11:33.810
你看一下

11:33.810 --> 11:34.810
装扣的

11:34.810 --> 11:35.810
是不是包错的

11:35.810 --> 11:36.810
class structure A

11:36.810 --> 11:38.810
invotes调用

11:38.810 --> 11:39.810
without new

11:39.810 --> 11:40.810
对吧

11:40.810 --> 11:41.810
它不能说托零6来调用

11:41.810 --> 11:43.810
所以说你s6里面有这样的功能

11:43.810 --> 11:45.810
s5就必须要去实现这样的功能

11:45.810 --> 11:46.810
s5里面没有内

11:46.810 --> 11:48.810
但是它又必须要去实现

11:48.810 --> 11:49.810
因此

11:49.810 --> 11:50.810
s5里面

11:50.810 --> 11:51.810
它就是一个普通函数

11:51.810 --> 11:52.810
你当然可以直接调用

11:52.810 --> 11:54.810
为了实现检查

11:54.810 --> 11:55.810
它就要去

11:55.810 --> 11:57.810
专门对这个调用进行检查

11:57.810 --> 11:58.810
那么你看

11:58.810 --> 12:00.810
这个函数它就是来做检查的

12:00.810 --> 12:01.810
传了两个参数进去

12:01.810 --> 12:02.810
一个是Z

12:02.810 --> 12:04.810
一个是A

12:04.810 --> 12:05.810
那它怎么检查的呢

12:05.810 --> 12:07.810
你看看它怎么检查的

12:07.810 --> 12:08.810
就这个函数

12:08.810 --> 12:09.810
class core check

12:09.810 --> 12:10.810
instance

12:10.810 --> 12:11.810
什么意思

12:11.810 --> 12:12.810
实力

12:12.810 --> 12:13.810
contract 什么意思

12:13.810 --> 12:14.810
构造器

12:14.810 --> 12:15.810
那么

12:15.810 --> 12:16.810
我们看它里边的代码

12:16.810 --> 12:18.810
这个里边的代码一下就不明白了

12:18.810 --> 12:20.810
并不复杂

12:20.810 --> 12:21.810
你看吧

12:21.810 --> 12:22.810
怎么检查的

12:22.810 --> 12:24.810
它就检查你这个东西

12:24.810 --> 12:28.810
是不是它的实力

12:28.810 --> 12:30.810
那它怎么来判断

12:30.810 --> 12:31.810
是不是它的实力呢

12:31.810 --> 12:32.810
如果说不是

12:32.810 --> 12:33.810
我们看

12:33.810 --> 12:35.810
独代码一定要一块一块独立

12:35.810 --> 12:36.810
不要是独到这个函数码上去

12:36.810 --> 12:37.810
看这个函数

12:37.810 --> 12:38.810
老大就晕了

12:38.810 --> 12:40.810
你身上的函数意识搞清楚

12:40.810 --> 12:42.810
我先不用看它里边怎么实现的

12:42.810 --> 12:43.810
我先看把它的意识搞清楚

12:43.810 --> 12:45.810
意识的名字就知道它什么意思

12:45.810 --> 12:46.810
instance有什么意思呢

12:46.810 --> 12:48.810
就表示的是

12:48.810 --> 12:50.810
判断

12:50.810 --> 12:51.810
instance

12:51.810 --> 12:53.810
是不是

12:53.810 --> 12:55.810
constructor

12:55.810 --> 12:56.810
的实力

12:56.810 --> 12:57.810
什么叫实力

12:57.810 --> 12:58.810
就是它是不是

12:58.810 --> 13:00.810
通过六它来构建出来的

13:00.810 --> 13:01.810
如果不是的话

13:01.810 --> 13:03.810
我就拋出一个函数

13:03.810 --> 13:04.810
它说

13:04.810 --> 13:05.810
错误的信息

13:05.810 --> 13:06.810
跟那个ex留不太一样

13:06.810 --> 13:07.810
名字叫做

13:08.810 --> 13:09.810
cannot

13:09.810 --> 13:11.810
不能调用一个class as a function

13:11.810 --> 13:12.810
不能把一个class

13:12.810 --> 13:14.810
当成一个普通函数来调用

13:14.810 --> 13:16.810
它如果说不是实力的话

13:16.810 --> 13:18.810
这就完成了检查了

13:18.810 --> 13:20.810
那么具体的

13:20.810 --> 13:22.810
它到底是怎么来判断

13:22.810 --> 13:23.810
这个东西

13:23.810 --> 13:24.810
是不是这个东西的实力呢

13:24.810 --> 13:25.810
它又是调用这个函数来判断

13:25.810 --> 13:26.810
left right

13:26.810 --> 13:27.810
来吧

13:27.810 --> 13:30.810
我一看这个函数怎么判断的

13:30.810 --> 13:35.590
一看这个函数怎么判断的

13:35.590 --> 13:36.590
可实话一下

13:36.590 --> 13:37.590
你看吧

13:37.590 --> 13:38.590
它怎么来判断的

13:38.590 --> 13:39.590
首先呢

13:39.590 --> 13:41.590
判断right

13:41.590 --> 13:43.590
如果说这边的东西

13:43.590 --> 13:44.590
相当于是构造器了

13:44.590 --> 13:47.590
如果说构造器不等于空

13:47.590 --> 13:49.590
就是有构造器

13:49.590 --> 13:50.590
并且呢

13:50.590 --> 13:52.590
看一下有没有symbol

13:52.590 --> 13:53.590
有没有symbol

13:53.590 --> 13:54.590
symbol什么意思

13:54.590 --> 13:55.590
就是我们之前

13:55.590 --> 13:56.590
也是六讲的东西

13:56.590 --> 13:58.590
也是六讲的那个

13:58.590 --> 14:00.590
symbol API

14:00.590 --> 14:02.590
有没有这个symbol

14:02.590 --> 14:04.590
说有symbol

14:04.590 --> 14:05.590
有symbol

14:05.590 --> 14:07.590
那么

14:07.590 --> 14:08.590
并且呢

14:08.590 --> 14:09.590
因为我们知道

14:09.590 --> 14:10.590
也是六里面的

14:10.590 --> 14:12.590
所有的内

14:12.590 --> 14:13.590
所有的内

14:13.590 --> 14:14.590
它都有一个symbol

14:14.590 --> 14:16.590
叫做Hash Instance

14:16.590 --> 14:17.590
Hash Instance

14:17.590 --> 14:18.590
这么一个symbol

14:18.590 --> 14:20.590
如果说它又有这个东西

14:20.590 --> 14:21.590
那么就表示

14:21.590 --> 14:22.590
右边的是一个内

14:22.590 --> 14:24.590
表示右边的是一个内

14:24.590 --> 14:26.590
如果说右边的是一个内的话

14:26.590 --> 14:27.590
那么

14:27.590 --> 14:29.590
它又是怎么来判断的呢

14:29.590 --> 14:30.590
两个杆它就是

14:30.590 --> 14:31.590
转换成布尔

14:31.590 --> 14:32.590
转换成布尔

14:32.590 --> 14:33.590
那么

14:33.590 --> 14:34.590
它就看一下

14:34.590 --> 14:35.590
这个东西

14:35.590 --> 14:37.590
调用这个symbol函数

14:37.590 --> 14:38.590
那么把lib传进去

14:38.590 --> 14:40.590
看它是不是它的实力

14:40.590 --> 14:41.590
当时我好像讲

14:41.590 --> 14:42.590
也是六的时候

14:42.590 --> 14:43.590
好像没有讲这个

14:43.590 --> 14:45.590
这个就是公共符号

14:45.590 --> 14:47.590
公共符号是什么意思呢

14:47.590 --> 14:48.590
就是所有的内

14:48.590 --> 14:49.590
它都会有公共符号

14:49.590 --> 14:50.590
给它看一下

14:50.590 --> 14:54.350
平时我们也用不到

14:54.350 --> 14:56.350
比方说我们写一个内

14:56.350 --> 14:57.350
class A

15:01.660 --> 15:02.660
class A

15:02.660 --> 15:03.660
class A

15:03.660 --> 15:04.660
你看

15:04.660 --> 15:05.660
A里边

15:05.660 --> 15:07.660
我们看把A打印出来

15:08.660 --> 15:09.660
这里

15:09.660 --> 15:10.660
这样吧

15:10.660 --> 15:11.660
console

15:11.660 --> 15:12.660
DiR

15:12.660 --> 15:13.660
A

15:13.660 --> 15:14.660
A打印出来

15:14.660 --> 15:15.660
A里边

15:15.660 --> 15:16.660
它就有一个符号

15:17.660 --> 15:19.660
Prototype

15:19.660 --> 15:20.660
Prot

15:21.660 --> 15:23.660
这个符号

15:23.660 --> 15:24.660
看不到

15:24.660 --> 15:26.660
看不到这个符号

15:27.660 --> 15:28.660
这样吧

15:28.660 --> 15:29.660
我们在这里

15:29.660 --> 15:30.660
这样子看

15:30.660 --> 15:31.660
A里边一个symbol

15:33.660 --> 15:38.540
symbol

15:38.540 --> 15:39.540
直接复制过来

15:39.540 --> 15:40.540
直接复制过来

15:40.540 --> 15:43.300
你看

15:43.300 --> 15:44.300
这有个symbol

15:44.300 --> 15:45.300
那么这个symbol是什么

15:45.300 --> 15:46.300
是一个函数

15:46.300 --> 15:47.300
这个知名符号

15:47.300 --> 15:48.300
就是它作为一个

15:48.300 --> 15:49.300
作为所有内

15:49.300 --> 15:50.300
只要是ES6构建的内

15:50.300 --> 15:52.300
它都会有这个symbol

15:52.300 --> 15:53.300
有这个符号属性

15:53.300 --> 15:54.300
那么这个符号属性

15:54.300 --> 15:55.300
实际上是什么呢

15:55.300 --> 15:56.300
这个属性

15:56.300 --> 15:57.300
它是一个函数

15:57.300 --> 15:58.300
这个函数用来干嘛的

15:58.300 --> 15:59.300
用来判断一个对象

15:59.300 --> 16:01.300
是不是由它构建出来的

16:01.300 --> 16:03.300
是不是根据它构建出来的

16:03.300 --> 16:05.300
它就来做这样的判定

16:05.300 --> 16:06.300
比方说

16:06.300 --> 16:07.300
咱们用一个A

16:07.300 --> 16:09.300
等于6一个A

16:09.300 --> 16:10.300
咱们接下来

16:10.300 --> 16:11.300
我们用这个函数

16:11.300 --> 16:12.300
来判断一下

16:12.300 --> 16:14.300
这个A是不是构建出来的呢

16:14.300 --> 16:15.300
你会发现是q

16:15.300 --> 16:17.300
是用它构建出来的

16:17.300 --> 16:18.300
如果说

16:18.300 --> 16:19.300
你一个普通的对象

16:19.300 --> 16:20.300
obj

16:20.300 --> 16:21.300
那么这个对象

16:21.300 --> 16:24.300
是不是根据A来构建出来的呢

16:24.300 --> 16:25.300
你可以通过它

16:25.300 --> 16:26.300
来判断普通的对象

16:26.300 --> 16:27.300
是不是构建出来的

16:27.300 --> 16:28.300
force

16:28.300 --> 16:29.300
所以说

16:29.300 --> 16:30.300
它这一部分在干嘛呢

16:30.300 --> 16:32.300
它这一部分就在判断

16:32.300 --> 16:33.300
它万一你执行的环境

16:33.300 --> 16:34.300
是ES6了

16:34.300 --> 16:35.300
那么我就可以

16:35.300 --> 16:39.300
通过ES6的方式来判断

16:39.300 --> 16:40.300
你这个玩意儿

16:40.300 --> 16:41.300
是不是根据我构建出来的

16:41.300 --> 16:42.300
如果是的话就是

16:42.300 --> 16:44.300
如果不是的话就不是

16:44.300 --> 16:45.300
OK

16:45.300 --> 16:47.300
那么它就把结果返回了

16:47.300 --> 16:48.300
有的人说

16:48.300 --> 16:49.300
那为什么

16:49.300 --> 16:50.300
它还要加两个感叹号呢

16:50.300 --> 16:51.300
像这一种一下

16:51.300 --> 16:52.300
都非常的细节

16:52.300 --> 16:53.300
非常的深

16:53.300 --> 16:54.300
它这个不就是

16:54.300 --> 16:55.300
不就是一个布尔了吗

16:55.300 --> 16:56.300
true and false

16:56.300 --> 16:57.300
把返回就行了

16:57.300 --> 16:59.300
干嘛还加两个感叹号呢

16:59.300 --> 17:00.300
为什么呢

17:00.300 --> 17:02.300
是因为它担心

17:03.300 --> 17:04.300
是因为它担心呢

17:04.300 --> 17:05.300
这个地方

17:05.300 --> 17:06.300
这个symbol

17:06.300 --> 17:08.300
它不是来自于ES6的symbol

17:08.300 --> 17:09.300
它是自己构建的

17:09.300 --> 17:12.300
用ES5构建的一个构造函数symbol

17:12.300 --> 17:13.300
那么这个东西

17:13.300 --> 17:14.300
它就不知道

17:14.300 --> 17:15.300
不一定返回的

17:15.300 --> 17:16.300
一定是布尔了

17:16.300 --> 17:17.300
所以说呢

17:17.300 --> 17:18.300
它就给加个两个感叹号

17:18.300 --> 17:20.300
保证万无一失

17:20.300 --> 17:22.300
转换成布尔

17:22.300 --> 17:23.300
那么它自己用

17:23.300 --> 17:24.300
这种转换方式

17:24.300 --> 17:25.300
如果说你是ES6的话

17:25.300 --> 17:27.300
它用ES6的判断方式

17:27.300 --> 17:28.300
否则的话

17:28.300 --> 17:29.300
它就用ES5的判断方式

17:29.300 --> 17:30.300
简单判断一下

17:30.300 --> 17:32.300
是不是instance of right

17:32.300 --> 17:33.300
它是不是它的实力

17:33.300 --> 17:34.300
总之呢

17:34.300 --> 17:35.300
整个函数

17:35.300 --> 17:36.300
你就算不搞清楚

17:36.300 --> 17:37.300
它里边怎么写的

17:37.300 --> 17:38.300
你也要知道

17:38.300 --> 17:39.300
它在干什么

17:39.300 --> 17:40.300
它在干什么呢

17:40.300 --> 17:41.300
就是判断这个东西

17:41.300 --> 17:43.300
是不是根据它来构建出来的

17:43.300 --> 17:44.300
那么这个函数

17:44.300 --> 17:45.300
就要调用它

17:45.300 --> 17:47.300
来判断检查

17:47.300 --> 17:49.300
它是不是根据

17:49.300 --> 17:50.300
它来构建出来的呢

17:50.300 --> 17:51.300
如果不是

17:51.300 --> 17:52.300
我就跑出错误

17:52.300 --> 17:54.300
这就是关于内的检查

17:54.300 --> 17:56.300
那么再回到这

17:56.300 --> 17:57.300
我知道了

17:57.300 --> 17:58.300
它完成了

17:58.300 --> 17:59.300
参数了默认值

17:59.300 --> 18:00.300
搞定了之后

18:00.300 --> 18:02.300
它就要做内的检查了

18:02.300 --> 18:03.300
要检查内了

18:04.300 --> 18:06.300
检查完内了之后

18:06.300 --> 18:08.300
现在总干复职了吧

18:08.300 --> 18:09.300
总干复职了吧

18:09.300 --> 18:10.300
你看它复职了吗

18:10.300 --> 18:12.300
还没有复职

18:12.300 --> 18:13.300
它的人干嘛呀

18:13.300 --> 18:15.300
它现在得给property

18:15.300 --> 18:16.300
E复职

18:16.300 --> 18:17.300
你看这些property

18:17.300 --> 18:18.300
E

18:18.300 --> 18:19.300
那么你明显知道

18:19.300 --> 18:20.300
它在复职对不对

18:20.300 --> 18:21.300
你只要看到

18:21.300 --> 18:22.300
这两个关键点

18:22.300 --> 18:23.300
因为我们写代码的时候

18:23.300 --> 18:24.300
就是property等于E

18:24.300 --> 18:25.300
所以说

18:25.300 --> 18:26.300
它还要对这种

18:26.300 --> 18:28.300
我们的初始化之段进一复职

18:28.300 --> 18:29.300
它要把这样的代码

18:29.300 --> 18:31.300
放到构造器里边去

18:31.300 --> 18:32.300
那么这一部分

18:32.300 --> 18:33.300
它在干嘛呢

18:33.300 --> 18:34.300
你看我们还是一样的

18:34.300 --> 18:35.300
读它的什么呢

18:35.300 --> 18:36.300
读它的函数名称

18:36.300 --> 18:38.300
Defan 定义

18:38.300 --> 18:40.300
定义一个属性

18:40.300 --> 18:41.300
这个函数在帮助什么

18:41.300 --> 18:44.300
帮助你定义一个属性

18:44.300 --> 18:46.300
Z 传进去

18:46.300 --> 18:47.300
就当前对象传进去

18:47.300 --> 18:48.300
property

18:48.300 --> 18:49.300
传进去

18:49.300 --> 18:50.300
E

18:50.300 --> 18:51.300
那么什么意思呢

18:51.300 --> 18:52.300
读这个函数的E

18:52.300 --> 18:53.300
都明白了

18:53.300 --> 18:54.300
给

18:54.300 --> 18:57.300
当给Z的属性

18:57.300 --> 18:58.300
叫property

18:58.300 --> 19:00.300
E复职

19:00.300 --> 19:04.300
复职为E

19:04.300 --> 19:05.300
应该这样说

19:05.300 --> 19:06.300
给Z

19:06.300 --> 19:08.300
定义一个属性

19:08.300 --> 19:09.300
property

19:09.300 --> 19:12.300
复职为E

19:12.300 --> 19:13.300
对不对

19:13.300 --> 19:15.300
那么就有点类似于

19:15.300 --> 19:17.300
类似于Z

19:17.300 --> 19:19.300
property等于E

19:19.300 --> 19:21.300
类似于这样的代码

19:21.300 --> 19:22.300
它为什么要这么简单

19:22.300 --> 19:24.300
它为什么干嘛去写个函数呢

19:24.300 --> 19:25.300
我们来看一下吧

19:25.300 --> 19:26.300
我们刚刚讲过

19:26.300 --> 19:27.300
在bibol里边

19:27.300 --> 19:29.300
它其实可以

19:29.300 --> 19:30.300
有一个属性叫做lose

19:30.300 --> 19:31.300
对吧

19:31.300 --> 19:32.300
l-o-o-s-e

19:32.300 --> 19:33.300
lose

19:33.300 --> 19:34.300
那么lose吧

19:34.300 --> 19:35.300
作为true的时候

19:35.300 --> 19:36.300
它就变成这种格式了

19:36.300 --> 19:37.300
不过呢

19:37.300 --> 19:38.300
我们看一下

19:38.300 --> 19:39.300
它原式的做法吧

19:39.300 --> 19:40.300
原式的话

19:40.300 --> 19:41.300
它是叫做一个

19:41.300 --> 19:43.300
辅助函数叫define property

19:43.300 --> 19:44.300
define property

19:44.300 --> 19:45.300
那么这个函数干嘛呢

19:45.300 --> 19:46.300
我们来看一下

19:46.300 --> 19:47.300
它怎么实现的

19:47.300 --> 19:49.300
其实没有那么复杂

19:49.300 --> 19:50.300
这没有那么复杂

19:50.300 --> 19:51.300
特别简单

19:51.300 --> 19:56.180
它怎么实现的呢

19:56.180 --> 19:58.180
它就做了这么一件事

19:58.180 --> 20:00.180
做了这么一件事

20:00.180 --> 20:01.180
就是你给我传一个对象

20:01.180 --> 20:03.180
我给这个对象定一个属性

20:03.180 --> 20:05.180
这个属性的值是啥

20:05.180 --> 20:07.180
那么它分成两种情况

20:07.180 --> 20:08.180
第一种情况

20:08.180 --> 20:09.180
就是这个属性

20:09.180 --> 20:12.180
这个对象已经有这个属性了

20:12.180 --> 20:14.180
已经有这个属性的时候

20:14.180 --> 20:16.180
它是使用的是define property

20:16.180 --> 20:18.180
用这种方式来定义的

20:18.180 --> 20:19.180
用这种方式来定义的

20:19.180 --> 20:21.180
那么它定义的时候

20:21.180 --> 20:22.180
把它的什么enumerable

20:22.180 --> 20:23.180
设为true

20:23.180 --> 20:25.180
因为它为什么要用这种方式

20:25.180 --> 20:27.180
是因为它担心你这个属性的

20:27.180 --> 20:29.180
是不能被埋一举的

20:29.180 --> 20:30.180
那你定义了新的属性的

20:30.180 --> 20:31.180
它是要把它保证

20:31.180 --> 20:33.180
这个新的属性能够被埋一举

20:33.180 --> 20:35.180
也就是说能够在否硬循环里边

20:35.180 --> 20:37.180
把它循环出来

20:37.180 --> 20:38.180
然后enumerable

20:38.180 --> 20:39.180
设为true

20:39.180 --> 20:40.180
configurable

20:40.180 --> 20:41.180
设为true

20:41.180 --> 20:42.180
rightable

20:42.180 --> 20:43.180
它也是可写的

20:43.180 --> 20:44.180
能够被埋一举

20:44.180 --> 20:46.180
能够被重新修改值

20:46.180 --> 20:48.180
能够重新修改整个配置

20:48.180 --> 20:49.180
对吧

20:49.180 --> 20:51.180
我们之前学过这个define property

20:51.180 --> 20:52.180
它这一部分

20:52.180 --> 20:54.180
主要是保证你新定义的属性

20:54.180 --> 20:56.180
一定要是可以埋据的

20:56.180 --> 20:58.180
一定要是可以重新修改的

20:58.180 --> 21:00.180
哪怕你之前有相同的属性

21:00.180 --> 21:02.180
那么它就要重新改过

21:02.180 --> 21:04.180
那如果说你之前没有这个相同的属性

21:04.180 --> 21:05.180
那就简单了

21:05.180 --> 21:06.180
那直接给它复制就行了

21:06.180 --> 21:08.180
因为我们知道直接给

21:08.180 --> 21:10.180
直接用这种方式给一个属性复制的话

21:10.180 --> 21:12.180
那么这个属性一定是可以被埋据的

21:12.180 --> 21:14.180
一定是可以被重写的

21:14.180 --> 21:15.180
对吧

21:15.180 --> 21:17.180
所以说它就用这种方式来定义属性

21:17.180 --> 21:19.180
其实我们如果说

21:19.180 --> 21:20.180
不去扣这个细节的话

21:20.180 --> 21:22.180
我们可以认为

21:22.180 --> 21:24.180
可以非常非常简单的认为

21:24.180 --> 21:26.180
这个东西就是这句话

21:26.180 --> 21:28.180
就是这句话

21:28.180 --> 21:30.180
可以非常简单的这样认为

21:30.180 --> 21:32.180
它下面的无非就是保证

21:32.180 --> 21:33.180
它能被埋据

21:33.180 --> 21:34.180
能被重写

21:34.180 --> 21:35.180
所以我们有的时候

21:35.180 --> 21:36.180
独代码要把它进行减化

21:36.180 --> 21:38.180
不然的话你头脑是乱的

21:38.180 --> 21:40.180
这是define property

21:40.180 --> 21:41.180
定一个属性

21:41.180 --> 21:42.180
对不对

21:42.180 --> 21:44.180
这个对好理解

21:44.180 --> 21:46.180
我先够到韩说里边

21:46.180 --> 21:47.180
先搞定默认值

21:47.180 --> 21:49.180
然后检查你这个雕容方式

21:49.180 --> 21:50.180
然后再定义属性

21:50.180 --> 21:51.180
proper1等于1

21:51.180 --> 21:53.180
后面是不是又重新调用这个方法

21:53.180 --> 21:54.180
对吧

21:54.180 --> 21:56.180
又定义属性什么

21:56.180 --> 21:58.180
method2等于一个韩数

21:58.180 --> 22:00.180
这个韩数里边我们先补看

22:00.180 --> 22:01.180
那么method2

22:01.180 --> 22:02.180
我们的原代码是啥

22:02.180 --> 22:04.180
是不是箭头韩数

22:04.180 --> 22:05.180
对不对

22:05.180 --> 22:06.180
是不是箭头韩数

22:06.180 --> 22:08.180
我们现在明白了

22:08.180 --> 22:11.180
原来内里边的箭头韩数

22:11.180 --> 22:13.180
就是啥呀

22:13.180 --> 22:17.180
就是一个普通属性

22:17.180 --> 22:19.180
就是一个普通属性

22:19.180 --> 22:20.180
原来的意思吗

22:20.180 --> 22:21.180
箭头

22:21.180 --> 22:26.180
在6里边的箭头韩数

22:26.180 --> 22:28.180
实际上就是一个普通属性

22:28.180 --> 22:29.180
你这样子写

22:29.180 --> 22:32.180
跟这样子写是一样的

22:32.180 --> 22:33.180
是一样的

22:33.180 --> 22:35.180
懂这个意思吗

22:35.180 --> 22:36.180
OK

22:36.180 --> 22:39.180
那么这里定一个method2

22:39.180 --> 22:40.180
是不是普通属性

22:40.180 --> 22:41.180
也就是这个箭头韩数

22:41.180 --> 22:43.180
在不在原型上面

22:43.180 --> 22:45.180
它就不在原型上面

22:45.180 --> 22:46.180
对不对

22:46.180 --> 22:47.180
它就不在

22:47.180 --> 22:48.180
它就是一个普通属性而已

22:48.180 --> 22:51.180
跟property一样的

22:51.180 --> 22:52.180
好来吧

22:52.180 --> 22:53.180
method2

22:53.180 --> 22:54.180
那么method2把它定一个韩数

22:54.180 --> 22:55.180
你看

22:55.180 --> 22:56.180
因为我们这边是韩数

22:56.180 --> 22:57.180
对不对

22:57.180 --> 22:58.180
我们这边是韩数

22:58.180 --> 23:00.180
那么这边也肯定是韩数

23:00.180 --> 23:01.180
肯定是韩数

23:01.180 --> 23:02.180
好

23:02.180 --> 23:03.180
那么这个韩数

23:03.180 --> 23:04.180
里面怎么多了这么多代码

23:04.180 --> 23:05.180
我们这个韩数里面

23:05.180 --> 23:06.180
不就是一句话吗

23:06.180 --> 23:07.180
它怎么多了这么多代码

23:07.180 --> 23:09.180
无非就是对它来进行转换

23:09.180 --> 23:11.180
生与参数是不是ES6的

23:11.180 --> 23:12.180
对吧

23:12.180 --> 23:13.180
生与参数是ES6的

23:13.180 --> 23:15.180
它要对生与参数这个argues

23:15.180 --> 23:16.180
进行转换

23:16.180 --> 23:17.180
那它怎么转换的呢

23:17.180 --> 23:19.180
你看它转换的方式也挺简单的

23:19.180 --> 23:21.180
就一个风循环

23:21.180 --> 23:23.180
然后定一个argues等于什么

23:23.180 --> 23:25.180
等于一个数组

23:25.180 --> 23:26.180
因为我们这边得到了argues

23:26.180 --> 23:27.180
不就是个数组吗

23:27.180 --> 23:28.180
对吧

23:28.180 --> 23:30.180
那么这是个数组

23:30.180 --> 23:31.180
它其实要干嘛

23:31.180 --> 23:33.180
它其实特别简单

23:33.180 --> 23:35.180
它的目的就是要把这个东西

23:35.180 --> 23:36.180
变成这个数组

23:36.180 --> 23:38.180
放到这个数组里边来

23:38.180 --> 23:39.180
所以说

23:39.180 --> 23:42.180
首先取这个argues的长度

23:42.180 --> 23:44.180
然后定一个等长的数组

23:44.180 --> 23:45.180
argues

23:45.180 --> 23:46.180
然后t

23:46.180 --> 23:48.180
t就相当于一个循环变两i

23:48.180 --> 23:49.180
等于0

23:49.180 --> 23:50.180
小于数组的长度

23:50.180 --> 23:51.180
对吧

23:51.180 --> 23:52.180
不就是在循环这个数组吗

23:52.180 --> 23:54.180
每循环一次把这个数组里边的东西取出来

23:54.180 --> 23:56.180
复制给这个数组的相应者一项

23:56.180 --> 23:57.180
对吧

23:57.180 --> 23:58.180
它就是

23:58.180 --> 23:59.180
无非就是把这个伪数组里边的东西

23:59.180 --> 24:01.180
放到这个真数组里边来

24:01.180 --> 24:03.180
然后这一段代码就转换了什么

24:03.180 --> 24:04.180
转换了这个东西

24:04.180 --> 24:05.180
对吧

24:05.180 --> 24:06.180
然后再输出它

24:06.180 --> 24:07.180
就没事了

24:07.180 --> 24:08.180
好

24:08.180 --> 24:09.180
那么勾造器里边

24:09.180 --> 24:11.180
这两部分

24:11.180 --> 24:13.180
这是处理

24:13.180 --> 24:15.180
将

24:15.180 --> 24:17.180
箭头函数方法

24:17.180 --> 24:20.180
作为普通属性定义

24:20.180 --> 24:22.180
所以说

24:22.180 --> 24:25.180
箭头函数方法

24:25.180 --> 24:26.180
并不在

24:26.180 --> 24:27.180
不在了

24:27.180 --> 24:29.180
不在那个元雄上

24:29.180 --> 24:32.260
好

24:32.260 --> 24:33.260
好

24:33.260 --> 24:34.260
最后呢

24:34.260 --> 24:35.260
最后就是我们勾造函数的代码了

24:35.260 --> 24:36.260
对吧

24:36.260 --> 24:37.260
就是这里边代码

24:37.260 --> 24:38.260
这里边

24:38.260 --> 24:39.260
这句话是不需要转换的

24:39.260 --> 24:40.260
这句话需要什么转换的

24:40.260 --> 24:41.260
这句话不需要转换

24:41.260 --> 24:42.260
所以直接放过来

24:42.260 --> 24:43.260
好

24:43.260 --> 24:44.260
那么这一部分

24:44.260 --> 24:45.260
对勾造函数

24:45.260 --> 24:46.260
对这个康斯抓特的转换

24:46.260 --> 24:47.260
当然也包含它

24:47.260 --> 24:49.260
它本来就应该在康斯抓特里边

24:49.260 --> 24:50.260
只不过呢

24:50.260 --> 24:52.260
ES7的语法允许我们写出去

24:52.260 --> 24:54.260
它本来也应该在勾造函数里边

24:54.260 --> 24:55.260
只不过呢

24:55.260 --> 24:57.260
ES6的语法允许我们写在这

24:57.260 --> 24:58.260
ES7

24:58.260 --> 24:59.260
这是ES7的语法

24:59.260 --> 25:00.260
允许我们写在这

25:00.260 --> 25:01.260
其实你看一下

25:01.260 --> 25:02.260
这个代码跟这个代码

25:02.260 --> 25:03.260
是不是一样的

25:03.260 --> 25:04.260
含义是不是一样的

25:04.260 --> 25:05.260
属相等于值

25:05.260 --> 25:07.260
属相等于值

25:07.260 --> 25:08.260
是不是一样的

25:08.260 --> 25:09.260
它一样的

25:09.260 --> 25:11.260
一样的

25:11.260 --> 25:12.260
OK

25:12.260 --> 25:13.260
好

25:13.260 --> 25:14.260
这一部分搞定了

25:14.260 --> 25:15.260
勾造函数搞定了

25:15.260 --> 25:16.260
是不是要定义原型了

25:16.260 --> 25:17.260
定义静态方法了

25:17.260 --> 25:18.260
那么这一部分

25:18.260 --> 25:19.260
它是怎么来做的呢

25:19.260 --> 25:22.260
它是通过一个

25:22.260 --> 25:24.260
函数来完成的

25:24.260 --> 25:25.260
Chris class

25:25.260 --> 25:27.260
你把勾造函数传进去

25:27.260 --> 25:28.260
这里传了一个数组

25:28.260 --> 25:29.260
你拆下这个数组里边

25:29.260 --> 25:31.260
每一项是个啥

25:31.260 --> 25:33.260
每一项是个啥

25:33.260 --> 25:35.260
它每一项

25:35.260 --> 25:36.260
当然是个对象

25:36.260 --> 25:37.260
当然是个对象

25:37.260 --> 25:39.260
它每一项应该是一个属性

25:39.260 --> 25:40.260
一个就是

25:40.260 --> 25:41.260
这个数组里边

25:41.260 --> 25:43.260
每一项应该是一个圆形

25:43.260 --> 25:44.260
对吧

25:44.260 --> 25:46.260
圆形上的东西

25:46.260 --> 25:48.260
圆形上的箭

25:48.260 --> 25:50.260
圆形上的第一个东西

25:50.260 --> 25:51.260
是什么

25:51.260 --> 25:52.260
属性名为message1

25:52.260 --> 25:54.260
属性的值是一个函数

25:54.260 --> 25:55.260
对吧

25:55.260 --> 25:57.260
这是圆形上的第一个东西

25:57.260 --> 25:59.260
那如果说你这里有多个圆形的方法

25:59.260 --> 26:01.260
那么这个数组里边是不是有多个

26:01.260 --> 26:02.260
好

26:02.260 --> 26:03.260
那么下面这个数组

26:03.260 --> 26:04.260
message3

26:04.260 --> 26:05.260
是不是静态方法

26:05.260 --> 26:06.260
静态方法

26:06.260 --> 26:07.260
那么静态方法

26:07.260 --> 26:08.260
它也是个数组

26:08.260 --> 26:10.260
因为有可能有多个静态方法

26:10.260 --> 26:12.260
那么每一个就是静态的属性

26:12.260 --> 26:14.260
1静态的属性值是什么

26:14.260 --> 26:15.260
对吧

26:15.260 --> 26:16.260
好

26:16.260 --> 26:17.260
那么把这个东西全部

26:17.260 --> 26:18.260
全部的传进去

26:18.260 --> 26:20.260
让它这个函数来完成

26:20.260 --> 26:21.260
那么我们来看一下这个函数

26:21.260 --> 26:23.260
这个函数特别简单

26:23.260 --> 26:25.260
给我一个构造函数

26:25.260 --> 26:26.260
proto props

26:26.260 --> 26:28.260
这个还不够明显吗

26:28.260 --> 26:30.260
圆形属性

26:30.260 --> 26:31.260
对吧

26:31.260 --> 26:32.260
构造函数

26:32.260 --> 26:33.260
给它加一些圆形属性

26:33.260 --> 26:34.260
数组

26:34.260 --> 26:36.260
给它加一些静态属性

26:36.260 --> 26:37.260
对吧

26:37.260 --> 26:38.260
特别简单

26:38.260 --> 26:40.260
那么来看一下它里面怎么实现的

26:44.050 --> 26:45.050
解决它吧

26:45.050 --> 26:46.050
就实现

26:46.050 --> 26:47.050
它说什么呢

26:47.050 --> 26:50.050
如果说你给我传了这个proto props

26:50.050 --> 26:52.050
如果说你给我传了这个圆形属性

26:52.050 --> 26:53.050
ok

26:53.050 --> 26:54.050
我就

26:54.050 --> 26:56.050
我就define properties

26:56.050 --> 26:58.050
我们之前使用的是define property

26:58.050 --> 26:59.050
对吧

26:59.050 --> 27:00.050
定义单个属性

27:00.050 --> 27:02.050
那么这里拿定义的properties

27:02.050 --> 27:04.050
定义多个属性

27:04.050 --> 27:06.050
那看一下定义多个属性怎么写的吧

27:06.050 --> 27:07.050
定义多个属性

27:07.050 --> 27:08.050
你看吧

27:08.050 --> 27:10.050
你都能够猜到它怎么写的了

27:10.050 --> 27:11.050
对吧

27:11.050 --> 27:12.050
它无非就是做了一个循环

27:12.050 --> 27:13.050
它还能怎么样

27:14.050 --> 27:16.050
它无非就是做了一个循环

27:17.050 --> 27:18.050
我们来看一下

27:19.050 --> 27:20.050
看上去好像

27:20.050 --> 27:21.050
代码很复杂的样子

27:21.050 --> 27:24.940
别说一定不复杂

27:24.940 --> 27:25.940
我们一定要把代码

27:25.940 --> 27:27.940
就是在脑袋里面把它转换

27:27.940 --> 27:28.940
你看

27:28.940 --> 27:29.940
给我一个这个东西

27:29.940 --> 27:30.940
定义一些属性

27:30.940 --> 27:31.940
来吧

27:31.940 --> 27:32.940
循环

27:32.940 --> 27:33.940
循环

27:33.940 --> 27:34.940
没循环一次

27:34.940 --> 27:35.940
我们上面的啥都不看

27:35.940 --> 27:37.940
啥都不看

27:37.940 --> 27:38.940
那么看最后一行

27:38.940 --> 27:40.940
没循环一次干了什么事

27:40.940 --> 27:41.940
是不是就来了

27:41.940 --> 27:42.940
对吧

27:42.940 --> 27:43.940
就来了

27:44.940 --> 27:45.940
我就定义

27:45.940 --> 27:46.940
没循环一次定义一个属性

27:46.940 --> 27:48.940
你给我了很多个属性

27:48.940 --> 27:50.940
我们没循环一次定义一个属性

27:51.940 --> 27:53.940
属性的名称是什么

27:53.940 --> 27:54.940
这里数组里面

27:54.940 --> 27:55.940
第一项是个对象

27:55.940 --> 27:56.940
第一项是个对象

27:56.940 --> 27:57.940
每项是个对象

27:57.940 --> 27:58.940
对象的一个key值

27:58.940 --> 27:59.940
对吧

27:59.940 --> 28:00.940
一个key值

28:00.940 --> 28:01.940
那么属性的名字

28:01.940 --> 28:03.940
乃至于它的key值

28:03.940 --> 28:04.940
乃至于它的key值

28:04.940 --> 28:05.940
那么属性的

28:05.940 --> 28:06.940
属性的值是什么呢

28:06.940 --> 28:08.940
就是这个描述服

28:08.940 --> 28:09.940
描述服

28:09.940 --> 28:10.940
哪来的呢

28:10.940 --> 28:11.940
你看一下

28:11.940 --> 28:12.940
描述服是不是从

28:12.940 --> 28:13.940
我们看一下这个property是啥

28:13.940 --> 28:14.940
property

28:14.940 --> 28:15.940
其实我们刚才看到过的

28:15.940 --> 28:17.940
看到过的

28:17.940 --> 28:19.940
就是一个key

28:20.940 --> 28:22.940
value

28:23.940 --> 28:24.940
value啥啥

28:24.940 --> 28:25.940
对吧

28:25.940 --> 28:26.940
就是这么一种格式

28:26.940 --> 28:27.940
property

28:27.940 --> 28:28.940
就是这么一种格式

28:28.940 --> 28:29.940
当然有可能

28:29.940 --> 28:31.940
value也是一个方可形

28:31.940 --> 28:32.940
说不准是啥

28:32.940 --> 28:33.940
那么这个property

28:33.940 --> 28:34.940
就这种格式

28:34.940 --> 28:35.940
那么循环这个数组

28:35.940 --> 28:37.940
每循环一次是个对象

28:37.940 --> 28:38.940
拿到这个对象

28:38.940 --> 28:39.940
然后你看

28:39.940 --> 28:40.940
这个对象里面

28:40.940 --> 28:41.940
是不是就已经有了key

28:41.940 --> 28:42.940
有了value了

28:42.940 --> 28:43.940
已经有了key

28:43.940 --> 28:44.940
有了value了

28:44.940 --> 28:45.940
属性的值

28:45.940 --> 28:46.940
属性的值

28:46.940 --> 28:47.940
是不是都有了

28:47.940 --> 28:48.940
都有了

28:48.940 --> 28:49.940
那么只差什么

28:49.940 --> 28:50.940
innumerable

28:50.940 --> 28:51.940
还有什么configable

28:51.940 --> 28:52.940
还有什么writeable

28:52.940 --> 28:53.940
对不对

28:53.940 --> 28:54.940
那么这些东西

28:54.940 --> 28:55.940
是不是一样的

28:55.940 --> 28:56.940
来进行构建

28:57.940 --> 28:58.940
来进行构建

28:58.940 --> 28:59.940
那么defineproperty

28:59.940 --> 29:00.940
拿过来放过去

29:00.940 --> 29:02.940
跟这边是不是一样的

29:02.940 --> 29:03.940
之前

29:03.940 --> 29:04.940
我这里还不是

29:04.940 --> 29:05.940
调用这个defineproperty

29:05.940 --> 29:06.940
只调用的是objects

29:06.940 --> 29:07.940
defineproperty

29:07.940 --> 29:08.940
那么把它构建进去

29:08.940 --> 29:09.940
就完事了

29:11.940 --> 29:12.940
没问题吧

29:12.940 --> 29:13.940
就是定义多个属性

29:13.940 --> 29:14.940
好

29:14.940 --> 29:15.940
我们知道了

29:15.940 --> 29:16.940
这个函数是来干嘛的呢

29:16.940 --> 29:17.940
定义

29:17.940 --> 29:18.940
给一个对象

29:18.940 --> 29:19.940
定义多个属性的

29:19.940 --> 29:20.940
那这边来

29:20.940 --> 29:21.940
你看啊

29:21.940 --> 29:22.940
就很好理解了

29:22.940 --> 29:24.940
创建一个类的时候

29:24.940 --> 29:25.940
你给我一个构造函数

29:25.940 --> 29:27.940
给我一个它的元雄属性

29:27.940 --> 29:28.940
给我一个静态属性

29:28.940 --> 29:30.940
如果说你给了我元雄属性

29:30.940 --> 29:31.940
我就把他

29:31.940 --> 29:32.940
这些元雄属性

29:32.940 --> 29:33.940
定到哪

29:33.940 --> 29:34.940
定到它的元雄上边

29:35.940 --> 29:36.940
如果说你给了我静态属性

29:36.940 --> 29:37.940
就直接把它定义到

29:37.940 --> 29:38.940
构造函数里面

29:38.940 --> 29:39.940
然后最后呢

29:39.940 --> 29:40.940
反回

29:40.940 --> 29:41.940
定义完了过后

29:41.940 --> 29:42.940
再反回这个constructor

29:43.940 --> 29:44.940
当然这个反回了

29:44.940 --> 29:45.940
我也没用

29:45.940 --> 29:46.940
不说会

29:46.940 --> 29:47.940
那么经过这一步

29:47.940 --> 29:48.940
是不是有了元雄方法

29:48.940 --> 29:49.940
有了静态方法了

29:49.940 --> 29:50.940
对不对

29:50.940 --> 29:51.940
好

29:51.940 --> 29:52.940
那么最后反回这个构造函数

29:52.940 --> 29:53.940
是不是就得到了

29:54.940 --> 29:55.940
那么最后呢

29:55.940 --> 29:56.940
就差最后一个东西

29:56.940 --> 29:57.940
就是箭头函数

29:57.940 --> 29:58.940
箭头函数

29:58.940 --> 29:59.940
跟这个东西有什么区别呢

29:59.940 --> 30:00.940
其实没啥区别

30:00.940 --> 30:01.940
区别在哪呢

30:01.940 --> 30:03.940
我可以在区别在哪呢

30:03.940 --> 30:05.940
箭头函数的话

30:08.440 --> 30:09.440
它一定是

30:09.440 --> 30:11.440
其实区别并不大

30:11.440 --> 30:12.440
箭头函数的话

30:12.440 --> 30:13.440
它一定是历史

30:13.440 --> 30:14.440
是一定是固定的

30:14.440 --> 30:16.440
它不会出现额外的情况

30:16.440 --> 30:17.440
它不会说

30:17.440 --> 30:18.440
那个历史

30:18.440 --> 30:19.440
它取决于怎么去

30:19.440 --> 30:20.440
调问这个方法

30:20.440 --> 30:21.440
不取决于

30:21.440 --> 30:22.440
它一定是固定的

30:22.440 --> 30:23.440
那么它做了唯一的做法

30:23.440 --> 30:24.440
你看

30:24.440 --> 30:25.440
就是还是

30:25.440 --> 30:26.440
还是把这个方法

30:26.440 --> 30:27.440
没事的事

30:27.440 --> 30:29.440
是放到这个构造函数里面去了

30:29.440 --> 30:30.440
跟没事3是一样的

30:30.440 --> 30:31.440
还是把这个方法

30:31.440 --> 30:32.440
放到构造函数里面去了

30:32.440 --> 30:33.440
只不过呢

30:33.440 --> 30:34.440
这个函数里面的历史呢

30:34.440 --> 30:36.440
它把直接把它转成了

30:36.440 --> 30:38.440
直接转换成了这个构造函

30:38.440 --> 30:39.440
这样子呢

30:39.440 --> 30:41.440
你虽然在这里使用的历史

30:41.440 --> 30:42.440
但是呢在这边

30:42.440 --> 30:43.440
就直接是这个A了

30:43.440 --> 30:44.440
它为了

30:44.440 --> 30:46.440
它通过这样子来保证

30:46.440 --> 30:47.440
它始终

30:47.440 --> 30:48.440
这个历史始终指向

30:48.440 --> 30:50.440
这个构造函数

30:50.440 --> 30:51.440
其他都没啥

30:51.440 --> 30:52.440
这就是整个的

30:52.440 --> 30:53.440
它的转换过程

30:53.440 --> 30:54.440
其实这个东西

30:54.440 --> 30:55.440
这么重要了

30:55.440 --> 30:56.440
一点都不重要

30:56.440 --> 30:57.440
一点都不重要

30:57.440 --> 30:58.440
跟我们学习开发一啥关系呢

30:58.440 --> 30:59.440
都没啥关系

30:59.440 --> 31:00.440
看这个东西呢

31:00.440 --> 31:02.440
只是看一下

31:02.440 --> 31:04.440
面对这种场景

31:04.440 --> 31:05.440
面对这种转化

31:05.440 --> 31:07.440
感觉上好像很不可思议的样子

31:07.440 --> 31:08.440
无非就是这些代码

31:08.440 --> 31:10.440
就可以给你转换过来

31:10.440 --> 31:11.440
另外呢

31:11.440 --> 31:12.440
也可以给大家看一看

31:12.440 --> 31:13.440
不代码

31:13.440 --> 31:14.440
应该去怎么读

31:14.440 --> 31:16.440
要找关键点

31:16.440 --> 31:18.440
找到关键点过后呢

31:18.440 --> 31:19.440
就好读了

31:19.440 --> 31:21.440
ok 这就是关于这个

31:21.440 --> 31:22.440
内的转换

31:22.440 --> 31:23.440
聊一下就行了

31:23.440 --> 31:24.440
听着热闹

31:24.440 --> 31:25.440
如果说直接听不懂

31:25.440 --> 31:26.440
没关系

31:26.440 --> 31:27.440
这是扩展课程

31:27.440 --> 31:28.440
不要纠结

