WEBVTT

00:00.690 --> 00:03.690
这一课咱们来讲入口和出口

00:03.690 --> 00:06.690
就这一块知识虽然很简单

00:06.690 --> 00:12.690
但是我发现了很多的开发者对这一块东西都没有彻底的搞清楚

00:12.690 --> 00:13.690
比较模糊

00:13.690 --> 00:16.690
但是有了我们上一课的编译过程之后

00:16.690 --> 00:20.690
再来学习出口和入口就很好理解了

00:20.690 --> 00:22.690
我们在学习之前

00:22.690 --> 00:26.690
首先我给大家介绍一下漏的环境里面的一些必要的代码

00:26.690 --> 00:29.690
虽然说我们现在还没有完整的去学习漏的解释

00:30.690 --> 00:34.690
但是由于我们为PAC在编译过程中要用到漏的解释一边

00:34.690 --> 00:37.690
某些东西可能我们需要一点点知识

00:37.690 --> 00:40.690
只有一点点 没有用到哪一块就讲那一块

00:40.690 --> 00:44.690
我们这里首先说一下漏的环境里面的有一个东西

00:44.690 --> 00:46.690
我们这里新建个文件夹

00:47.690 --> 00:48.690
就是漏的

00:49.690 --> 00:54.690
这个文件夹里面我们新建一个就是关于DLN的解释

00:57.130 --> 00:58.130
我说一个什么呢

00:58.130 --> 01:00.130
就是说在漏的环境下边

01:02.130 --> 01:06.130
DLN协杠表示什么意思

01:12.140 --> 01:14.140
在漏的环境里面DLN协杠

01:14.140 --> 01:17.140
可能大家认为DLN协杠很简单

01:17.140 --> 01:19.140
这个DLN协杠表示的是

01:19.140 --> 01:22.140
当前路 就是当前这个界是文件夹

01:22.140 --> 01:24.140
文件所在的目录

01:24.140 --> 01:26.140
也就是说在这个漏的目录

01:26.140 --> 01:27.140
DLN协杠

01:27.140 --> 01:29.140
这个不一定的

01:29.140 --> 01:30.140
因为其实这个东西

01:30.140 --> 01:32.140
是以后里面学新漏的的时候要详细学的

01:32.140 --> 01:34.140
我们这里大概说一下

01:34.140 --> 01:36.140
因为有些同学可能搞不清楚

01:36.140 --> 01:38.140
那么这个DLN协杠表示什么意思呢

01:38.140 --> 01:39.140
它有两种情况

01:39.140 --> 01:46.140
第一种情况是磨块化代码中

01:46.140 --> 01:51.140
就是什么代码中比如在require的时候

01:51.140 --> 01:53.140
require的时候这个DLN协杠

01:53.140 --> 01:54.140
这个DLN协杠表示什么意思呢

01:54.140 --> 02:01.140
那么它表示当前界是文件所在的目录

02:01.140 --> 02:03.140
就跟我们以前学习的一样的

02:03.140 --> 02:04.140
在磨块化代码里边

02:04.140 --> 02:06.140
你可以这样表示没问题

02:06.140 --> 02:08.140
就表示界是文件所在的目录

02:08.140 --> 02:09.140
就这个目录

02:09.140 --> 02:12.140
那么如果说不是在这种情况下

02:12.140 --> 02:14.140
在文件处理的时候

02:14.140 --> 02:17.140
当然你们现在还没有学过文件处理

02:17.140 --> 02:19.140
一会你们会发现

02:19.140 --> 02:21.140
一会我们会举个例子

02:21.140 --> 02:22.140
现在先理解

02:22.140 --> 02:23.140
第二种情况

02:23.140 --> 02:30.140
就是说在路径或文件处理中

02:30.140 --> 02:34.140
这个DLN协杠表示什么意思呢

02:34.140 --> 02:40.100
这个DLN协杠表示

02:40.100 --> 02:41.100
也不说文件处理

02:41.100 --> 02:42.100
就算路径

02:42.100 --> 02:44.100
因为我们现在只关心路径

02:44.100 --> 02:46.100
在路径处理中

02:46.100 --> 02:48.100
那么什么叫路径处理中

02:48.100 --> 02:49.100
一会我们会举例子

02:49.100 --> 02:51.100
什么叫做路径处理

02:51.100 --> 02:52.100
一会我们会举例子

02:52.100 --> 02:53.100
现在还没有学

02:53.100 --> 02:55.100
因此我们先把这个DLN协杠认识一下

02:55.100 --> 02:57.100
这个DLN协杠还不是表示

02:57.100 --> 02:58.100
界是文件处理的当前目录

02:58.100 --> 02:59.100
而是表示什么呢

02:59.100 --> 03:03.100
表示路的运行目录

03:03.100 --> 03:05.100
什么叫路的运行目录

03:05.100 --> 03:07.100
比方说我们在这点击右键

03:07.100 --> 03:09.100
字中间打开

03:09.100 --> 03:11.100
表示我们在这里使用路的命令

03:11.100 --> 03:12.100
运行这个什么呢

03:12.100 --> 03:16.100
运行路的下边的这个DLN协杠

03:16.100 --> 03:17.100
就运行这个协杠

03:17.100 --> 03:19.100
那么这个时候

03:19.100 --> 03:21.100
这个GX中代码中的DLN协杠

03:21.100 --> 03:22.100
表示什么呢

03:22.100 --> 03:24.100
它的路径表示这个路径

03:24.100 --> 03:26.100
表示这个目录

03:26.100 --> 03:29.100
而不再表示下边的路的目录

03:29.100 --> 03:30.100
注意哦

03:30.100 --> 03:32.100
好好区分一下

03:32.100 --> 03:34.100
如果在模块化代码中

03:34.100 --> 03:35.100
那就没问题

03:35.100 --> 03:36.100
GX在哪儿

03:36.100 --> 03:37.100
我就跟在哪儿

03:37.100 --> 03:38.100
但是如果说

03:38.100 --> 03:40.100
你是不是在模块化代码中

03:40.100 --> 03:41.100
在路径处理中

03:41.100 --> 03:42.100
那么这个DLN协杠

03:42.100 --> 03:44.100
表示路的运行目录

03:44.100 --> 03:45.100
也就是说在这种情况下

03:45.100 --> 03:47.100
那路的是哪个目录运行的

03:47.100 --> 03:48.100
是在这个目录运行的

03:48.100 --> 03:50.100
那么无论你这个GX藏在哪

03:50.100 --> 03:52.100
藏在多少个指纹家

03:52.100 --> 03:53.100
文件夹里边

03:53.100 --> 03:54.100
那么它里边的

03:54.100 --> 03:55.100
路径处理中的协杠

03:55.100 --> 03:57.100
都表示的运行目录

03:57.100 --> 03:58.100
是这么个意思

03:58.100 --> 04:00.100
那么下面

04:00.100 --> 04:01.100
还有一个东西叫

04:01.100 --> 04:02.100
全局辩量

04:02.100 --> 04:04.100
DLN

04:04.100 --> 04:05.100
这个东西呢

04:05.100 --> 04:06.100
他表示的

04:06.100 --> 04:09.100
这个东西在所有情况下

04:09.100 --> 04:12.100
所有情况下

04:12.100 --> 04:13.100
都表示

04:13.100 --> 04:17.100
当前运行的GX文件

04:17.100 --> 04:19.100
所在的目录

04:19.100 --> 04:20.100
在所有情况下

04:20.100 --> 04:22.100
他表示在这个目录

04:22.100 --> 04:23.100
不过呢

04:23.100 --> 04:25.100
它是一个绝对路径

04:25.100 --> 04:27.100
它是一个绝对路径

04:27.100 --> 04:28.100
什么叫绝对路径呢

04:28.100 --> 04:29.100
就是从某一个盘幅开始

04:29.100 --> 04:30.100
然后一直到哪

04:30.100 --> 04:31.100
比方说我们这里

04:31.100 --> 04:32.100
可以输出一下

04:32.100 --> 04:33.100
输出

04:33.100 --> 04:35.100
DLN

04:35.100 --> 04:36.100
你看一下吧

04:36.100 --> 04:37.100
我们就在这里输出

04:37.100 --> 04:38.100
回车

04:38.100 --> 04:39.100
你看

04:39.100 --> 04:40.100
它打印出来的结果

04:40.100 --> 04:41.100
是不是一个字幕串

04:41.100 --> 04:42.100
它就是一个字幕串

04:42.100 --> 04:43.100
它表示当前

04:43.100 --> 04:44.100
那个GX文件

04:44.100 --> 04:45.100
所在的目录

04:45.100 --> 04:46.100
它就在这

04:46.100 --> 04:47.100
在我们的第一盘

04:47.100 --> 04:48.100
哪个文件夹

04:48.100 --> 04:49.100
总之要找到

04:49.100 --> 04:50.100
这个GX文件所在的目录

04:50.100 --> 04:51.100
那比方说

04:51.100 --> 04:52.100
我们把这个GX文件

04:52.100 --> 04:53.100
放哪呢

04:53.100 --> 04:54.100
放到一个SARB文件夹里边

04:54.100 --> 04:55.100
复制一下吧

04:55.100 --> 04:56.100
暂时过来

04:56.100 --> 04:58.100
那么我们运行的时候

04:58.100 --> 04:59.100
我们还是在这里运行

04:59.100 --> 05:00.100
漏的下面的

05:00.100 --> 05:01.100
漏的文件夹

05:01.100 --> 05:02.100
下面的SARB

05:02.100 --> 05:04.100
下面的DLN

05:04.100 --> 05:05.100
回车

05:05.100 --> 05:06.100
你看

05:06.100 --> 05:07.100
所以得到这个目录

05:07.100 --> 05:08.100
对吧

05:08.100 --> 05:09.100
它会跟着GX文件走

05:09.100 --> 05:11.100
而且它是一个绝对路径

05:11.100 --> 05:12.100
这是DLN

05:12.100 --> 05:13.100
那么举起钢�

05:13.100 --> 05:14.100
现在我们没法测试

05:14.100 --> 05:15.100
没法测试

05:15.100 --> 05:16.100
这是关于

05:16.100 --> 05:18.100
这是关于我这一点要说的

05:18.100 --> 05:19.100
好

05:19.100 --> 05:20.100
另外一个

05:20.100 --> 05:21.100
我要介绍一下

05:21.100 --> 05:22.100
漏的里边的一个模块

05:22.100 --> 05:24.100
叫做PASS模块

05:24.100 --> 05:26.100
这个是一个漏的内置模块

05:26.100 --> 05:27.100
不需要安装

05:27.100 --> 05:28.100
安装好了漏的过后

05:28.100 --> 05:29.100
就可以直接使用

05:29.100 --> 05:30.100
好

05:30.100 --> 05:31.100
那么我们这里的一个文档

05:31.100 --> 05:33.100
漏的里面其实有很多的模块

05:33.100 --> 05:34.100
你们以后学习

05:34.100 --> 05:35.100
漏的解释的时候

05:35.100 --> 05:36.100
会详细学习

05:36.100 --> 05:37.100
那么我们这里只介绍PASS模块

05:37.100 --> 05:39.100
这PASS模块怎么用呢

05:39.100 --> 05:41.100
我们这里新建个文件

05:41.100 --> 05:42.100
就比方说

05:42.100 --> 05:43.100
我们取个名字

05:43.100 --> 05:45.100
PASS

05:46.100 --> 05:48.100
那么怎么用内置模块

05:48.100 --> 05:49.100
内置模块使用的方式

05:49.100 --> 05:50.100
非常简单

05:50.100 --> 05:51.100
就REQUIRE

05:51.100 --> 05:53.100
里边写上模块的名称

05:53.100 --> 05:55.100
PASS就完事了

05:55.100 --> 05:56.100
因为

05:56.100 --> 05:57.100
漏的环境里面

05:57.100 --> 05:58.100
去运行代码的时候

05:58.100 --> 05:59.100
它会去找

05:59.100 --> 06:00.100
它首先发现

06:00.100 --> 06:01.100
你这个不是相对路径

06:01.100 --> 06:02.100
对吧

06:02.100 --> 06:03.100
不是叼鞋钢盒

06:03.100 --> 06:04.100
叼着鞋钢开头

06:04.100 --> 06:05.100
那么说明啥

06:05.100 --> 06:06.100
说明这个模块

06:06.100 --> 06:07.100
我要先找一下

06:07.100 --> 06:08.100
它是不是内置模块

06:08.100 --> 06:09.100
如果是的话

06:09.100 --> 06:10.100
就直接使用了

06:10.100 --> 06:11.100
如果不是内置模块的话

06:11.100 --> 06:12.100
那么我们才从漏的码

06:12.100 --> 06:13.100
就是里面去找

06:14.100 --> 06:15.100
那么现在它肯定

06:15.100 --> 06:16.100
它肯定是一个内置模块

06:16.100 --> 06:17.100
它就会返回内置模块

06:17.100 --> 06:18.100
导出的东西

06:18.100 --> 06:19.100
导出什么呢

06:19.100 --> 06:20.100
导出一个对象

06:20.100 --> 06:21.100
这个对象里面

06:22.100 --> 06:23.100
导出了一个对象

06:23.100 --> 06:25.100
这个对象里面是什么呢

06:26.100 --> 06:27.100
该对象中

06:28.100 --> 06:32.100
提供了大量路径

06:32.100 --> 06:34.100
处理的函数

06:34.100 --> 06:35.100
提供了很多的函数

06:35.100 --> 06:37.100
对路径进行处理

06:37.100 --> 06:38.100
那么有哪些函数呢

06:38.100 --> 06:40.100
我们现在只学习一个就行了

06:40.100 --> 06:41.100
因为我们只用到

06:41.100 --> 06:43.100
这一个就是resolve

06:43.100 --> 06:44.100
那么我们来看一下

06:44.100 --> 06:45.100
这个函数

06:45.100 --> 06:46.100
它的描述

06:46.100 --> 06:47.100
它说

06:49.100 --> 06:51.100
它解决一个什么问题呢

06:51.100 --> 06:53.100
它可以把多个

06:53.100 --> 06:55.100
一系列的路径

06:55.100 --> 06:59.100
或者是一系列的路径的片段

06:59.100 --> 07:01.100
把它组装成一个绝对路径

07:01.100 --> 07:03.100
也就这个函数来干什么的

07:03.100 --> 07:04.100
它就是来组装绝对路径的

07:04.100 --> 07:05.100
什么意思

07:05.100 --> 07:06.100
咱们来看一下吧

07:06.100 --> 07:08.100
PASS里面有个resolve函数

07:08.100 --> 07:09.100
这个函数

07:09.100 --> 07:11.100
函数的地方说我随便举个例子

07:11.100 --> 07:13.100
我在这里写上一个

07:13.100 --> 07:15.100
比方说

07:15.100 --> 07:17.100
child

07:17.100 --> 07:19.100
比方说这里是

07:19.100 --> 07:20.100
一个底儿学一杠

07:20.100 --> 07:21.100
一个底儿学一杠

07:21.100 --> 07:23.100
然后有一个child

07:23.100 --> 07:25.100
再写一个abc

07:25.100 --> 07:27.100
再写一个123

07:27.100 --> 07:28.100
就这里面参数里

07:28.100 --> 07:29.100
随便传多少都可以

07:29.100 --> 07:30.100
0个或多个

07:30.100 --> 07:32.100
那么返回resolve

07:32.100 --> 07:34.100
我们输出一下这个resolve

07:34.100 --> 07:35.100
你看一下吧

07:35.100 --> 07:36.100
它是一个什么样的结果

07:36.100 --> 07:38.100
好 这里我们打开

07:38.100 --> 07:39.100
clear

07:39.100 --> 07:40.100
load

07:40.100 --> 07:41.100
运行

07:41.100 --> 07:42.100
运行load

07:42.100 --> 07:43.100
load 5念甲

07:43.100 --> 07:44.100
下面的sub 5念甲

07:44.100 --> 07:46.100
下面的pass

07:46.100 --> 07:47.100
test

07:47.100 --> 07:48.100
不对

07:48.100 --> 07:49.100
load 环境

07:49.100 --> 07:51.100
下面的pass

07:51.100 --> 07:52.100
test

07:52.100 --> 07:53.100
好 回上

07:53.100 --> 07:54.100
你看一下

07:54.100 --> 07:55.100
好 首先

07:55.100 --> 07:57.100
它是什么人理解的

07:57.100 --> 07:58.100
它说你第一开始

07:58.100 --> 07:59.100
给我了一个相对路径

07:59.100 --> 08:00.100
对吧

08:00.100 --> 08:01.100
那么这个相对路径代表了

08:01.100 --> 08:03.100
是什么5念甲

08:03.100 --> 08:04.100
刚才我们说过的

08:04.100 --> 08:05.100
是什么5念甲

08:05.100 --> 08:06.100
就在路径处理的过程中

08:06.100 --> 08:07.100
这个调鞋杠表示什么

08:07.100 --> 08:09.100
表示的是

08:09.100 --> 08:10.100
当前

08:10.100 --> 08:12.100
就是当前漏的环境的目录

08:12.100 --> 08:13.100
就表示这个目录

08:13.100 --> 08:14.100
对吧

08:14.100 --> 08:15.100
它是表示这个目录

08:15.100 --> 08:16.100
好

08:16.100 --> 08:17.100
那么这个目录

08:17.100 --> 08:18.100
后边又加上了一个child

08:18.100 --> 08:19.100
那么OK

08:19.100 --> 08:20.100
你看

08:20.100 --> 08:21.100
它一开始是这个目录

08:21.100 --> 08:22.100
然后又加上一个child

08:22.100 --> 08:23.100
你看

08:23.100 --> 08:25.100
又加上一个abc

08:25.100 --> 08:26.100
你看

08:26.100 --> 08:27.100
又加上一个123

08:27.100 --> 08:28.100
你看

08:28.100 --> 08:30.100
就形成这样的一个绝对路径了

08:30.100 --> 08:32.100
那么它就给你返回这么一个绝对路径

08:32.100 --> 08:33.100
它这个方法

08:33.100 --> 08:35.100
对于得到一个绝对路径

08:35.100 --> 08:37.100
是非常好用的

08:37.100 --> 08:39.100
它可以把多个多段的路径

08:39.100 --> 08:40.100
把它组装起来

08:40.100 --> 08:42.100
形成一个完整的绝对路径

08:42.100 --> 08:44.100
而且这个绝对路径是跨平台的

08:44.100 --> 08:45.100
什么意思呢

08:45.100 --> 08:46.100
也就是我们这个代码

08:46.100 --> 08:49.100
运行在不同的操作系统里边

08:49.100 --> 08:51.100
它的路径出来的规则

08:51.100 --> 08:53.100
是根据不同的操作系统有变化的

08:53.100 --> 08:54.100
你看Windows的操作系统

08:54.100 --> 08:55.100
它是用的是U协杠

08:55.100 --> 08:56.100
对吧

08:56.100 --> 08:57.100
那么这个东西

08:57.100 --> 08:59.100
如果说运行在inux上面

08:59.100 --> 09:00.100
运行在mic上面

09:00.100 --> 09:01.100
还会变成左协杠

09:01.100 --> 09:03.100
总之它会适应不同的操作系统

09:03.100 --> 09:04.100
这个方法非常好用

09:04.100 --> 09:06.100
它生成一个绝对路径

09:06.100 --> 09:08.100
那么绝对路径有什么好处呢

09:08.100 --> 09:09.100
以后我们就可以看到了

09:09.100 --> 09:11.100
因为有些地方的时候

09:11.100 --> 09:13.100
有些地方我们必须要用绝对路径

09:13.100 --> 09:14.100
还不能用相对路径

09:14.100 --> 09:15.100
它有要求的

09:15.100 --> 09:16.100
这是关于这个

09:16.100 --> 09:19.100
那如果说我们平时写的时候

09:19.100 --> 09:20.100
我们不想用点儿鞋杠

09:20.100 --> 09:22.100
因为点儿鞋杠用的是环境

09:22.100 --> 09:23.100
对吧

09:23.100 --> 09:24.100
我希望跟环境无关

09:24.100 --> 09:25.100
我就要从

09:25.100 --> 09:27.100
这个GS文件的误路开始

09:27.100 --> 09:28.100
那怎么办呢

09:28.100 --> 09:30.100
我们可以用这种方式

09:30.100 --> 09:31.100
Result

09:31.100 --> 09:32.100
用什么

09:32.100 --> 09:33.100
DRLame

09:33.100 --> 09:34.100
对吧

09:34.100 --> 09:35.100
我跟环境无关

09:35.100 --> 09:36.100
不管你在环境哪里运行

09:36.100 --> 09:37.100
对吧

09:37.100 --> 09:38.100
我们用DRLame

09:38.100 --> 09:40.100
就表示一定是这个GS

09:40.100 --> 09:41.100
所在的文件夹

09:41.100 --> 09:42.100
对吧

09:42.100 --> 09:43.100
然后我们再写一些

09:43.100 --> 09:45.100
比方说src

09:45.100 --> 09:46.100
不管这个目录

09:46.100 --> 09:47.100
它不管这个目录存不存在

09:47.100 --> 09:48.100
它不管的

09:48.100 --> 09:50.100
它只是做自不错处理的

09:50.100 --> 09:52.100
它其实就说白了

09:52.100 --> 09:53.100
就是一个自不错处理函数

09:53.100 --> 09:55.100
然后我们再运行

09:55.100 --> 09:56.100
那么就是

09:56.100 --> 09:57.100
在low的目录下面的

09:57.100 --> 09:59.100
什么src

09:59.100 --> 10:00.100
你看

10:00.100 --> 10:02.100
这个目录是不是low的目录

10:02.100 --> 10:03.100
这个前级也是文件

10:03.100 --> 10:04.100
所在的目录

10:04.100 --> 10:05.100
然后下面的src

10:05.100 --> 10:07.100
把它变成一个绝对路径

10:07.100 --> 10:08.100
就是它可以根据多段路径

10:08.100 --> 10:10.100
来返回一个绝对路径

10:10.100 --> 10:12.100
这就是我在讲入口和出口之前

10:12.100 --> 10:15.100
要补充了一个low的GS的姿势

10:15.100 --> 10:20.110
OK

10:20.110 --> 10:21.110
当然我们运行的话

10:21.110 --> 10:22.110
运行的话

10:22.110 --> 10:23.110
用这种方式运行

10:23.110 --> 10:26.110
也是一样的

10:26.110 --> 10:27.110
不过用这种方式运行的话

10:27.110 --> 10:28.110
它是指的是

10:28.110 --> 10:30.110
整个就在这个目录下面

10:30.110 --> 10:33.110
作为low的运行环境

10:33.110 --> 10:36.110
OK

10:36.110 --> 10:37.110
好

10:37.110 --> 10:39.110
接下来我们来说

10:39.110 --> 10:41.110
我们今天的重题

10:41.110 --> 10:43.110
就是主题入口和出口

10:43.110 --> 10:45.110
那么入口和出口是什么呢

10:45.110 --> 10:47.110
其实配置的是什么

10:47.110 --> 10:48.110
我们一个个说

10:48.110 --> 10:50.110
出口这里配置的是什么呢

10:50.110 --> 10:52.110
配置的是这

10:52.110 --> 10:54.110
配置的是这一块

10:54.110 --> 10:57.110
就是它生成的支援结果

10:57.110 --> 10:59.110
那么它的文件名

10:59.110 --> 11:00.110
文件夹的规则是什么

11:00.110 --> 11:02.110
就配置的是这些东西

11:02.110 --> 11:03.110
这是出口

11:03.110 --> 11:04.110
那么它的配置怎么配置呢

11:04.110 --> 11:05.110
通过output来配置

11:05.110 --> 11:07.110
我们先大概看一下

11:07.110 --> 11:09.110
那么入口配置的是什么呢

11:09.110 --> 11:11.110
这一块是特别容易搞混笑的

11:11.110 --> 11:12.110
很多同学觉得

11:12.110 --> 11:13.110
之前可能接触过

11:13.110 --> 11:15.110
我被拍的一些开发者

11:15.110 --> 11:17.110
他觉得入口配置的是什么

11:17.110 --> 11:18.110
入口文件

11:18.110 --> 11:19.110
入口模块

11:19.110 --> 11:20.110
实际上不是的

11:20.110 --> 11:21.110
入口真正配置的是什么

11:21.110 --> 11:23.110
配置的是这个trunk

11:23.110 --> 11:25.110
有哪些trunk

11:25.110 --> 11:26.110
配置的是这个东西

11:26.110 --> 11:27.110
这才是它的入口

11:27.110 --> 11:29.110
真正配置的东西

11:29.110 --> 11:30.110
所以这个搞清楚了

11:30.110 --> 11:31.110
我们先大概说一下

11:31.110 --> 11:32.110
出口配置的是它

11:32.110 --> 11:34.110
这个生成的支援

11:34.110 --> 11:35.110
入口的配置的是它

11:35.110 --> 11:36.110
这个trunk

11:36.110 --> 11:37.110
好

11:37.110 --> 11:39.110
我们这里来看一下怎么来配置

11:39.110 --> 11:41.110
首先我们来看出口

11:41.110 --> 11:42.110
这个东西要点

11:42.110 --> 11:43.110
结合起来讲

11:43.110 --> 11:44.110
它没法单独来讲

11:44.110 --> 11:46.110
一个是出口

11:46.110 --> 11:47.110
我们通过怎么来配置呢

11:47.110 --> 11:49.110
通过output来配置

11:49.110 --> 11:51.110
output来配置

11:51.110 --> 11:52.110
那么这个output

11:52.110 --> 11:53.110
是个什么东西呢

11:53.110 --> 11:54.110
它是一个对象

11:54.110 --> 11:55.110
它是个对象

11:55.110 --> 11:57.110
这里面有哪些配置呢

11:57.110 --> 11:58.110
这里面配置就超级多了

11:58.110 --> 12:00.110
可以看一下文档

12:00.110 --> 12:01.110
这里面中文文档

12:01.110 --> 12:03.110
里面配置

12:03.110 --> 12:04.110
输出output

12:04.110 --> 12:05.110
你看

12:05.110 --> 12:06.110
这里面配置

12:06.110 --> 12:07.110
全都是它的配置

12:07.110 --> 12:08.110
不过中文文档

12:08.110 --> 12:10.110
我全段时间看了一下

12:10.110 --> 12:11.110
就觉得中文文档

12:11.110 --> 12:13.110
好像写的有些地方

12:13.110 --> 12:14.110
写的有毛病

12:14.110 --> 12:15.110
写的不是很全

12:15.110 --> 12:16.110
大家能看英文文档

12:16.110 --> 12:17.110
经常看英文文档

12:17.110 --> 12:19.110
当然我现在也不会

12:19.110 --> 12:21.110
真的让你们去看一遍文档

12:21.110 --> 12:22.110
我就是说一下

12:22.110 --> 12:23.110
文档里面是有

12:23.110 --> 12:25.110
但是其他里面配置很多

12:25.110 --> 12:27.110
但是我们平时用的时候

12:27.110 --> 12:28.110
一般就用两个

12:28.110 --> 12:30.110
第一个我们是什么呢

12:30.110 --> 12:31.110
是pass

12:31.110 --> 12:32.110
就它的路径

12:32.110 --> 12:34.110
那么这个地方配置什么呢

12:34.110 --> 12:37.110
必须配置一个

12:37.110 --> 12:39.110
绝对路径

12:39.110 --> 12:40.110
就这里必须要配置一个

12:40.110 --> 12:41.110
绝对路径

12:41.110 --> 12:42.110
从哪个盘幅开始

12:42.110 --> 12:43.110
到哪哪哪哪

12:43.110 --> 12:45.110
那么表示

12:45.110 --> 12:47.110
资源

12:47.110 --> 12:49.110
放置的文件夹

12:49.110 --> 12:50.110
什么意思

12:50.110 --> 12:52.110
就表示我们这一块东西

12:52.110 --> 12:53.110
就我们最终会

12:53.110 --> 12:54.110
打包会生成一些资源

12:54.110 --> 12:55.110
对吧

12:55.110 --> 12:56.110
那么这些资源

12:56.110 --> 12:57.110
放到哪去

12:57.110 --> 12:58.110
放到哪个文件夹留下去

12:58.110 --> 13:00.110
那么默认是什么呢

13:00.110 --> 13:01.110
默认

13:01.110 --> 13:03.110
是dest

13:03.110 --> 13:05.110
当然我这里只是简写

13:05.110 --> 13:06.110
它其实是一个完整的

13:06.110 --> 13:07.110
绝对路径

13:07.110 --> 13:08.110
dest

13:08.110 --> 13:09.110
好那么这里怎么来

13:09.110 --> 13:10.110
配置一个绝对路径呢

13:10.110 --> 13:11.110
你能不能就是

13:11.110 --> 13:13.110
直接在手写绝对路径呢

13:13.110 --> 13:14.110
比方说我们

13:14.110 --> 13:15.110
现在在地盘

13:15.110 --> 13:16.110
我这里在地盘

13:16.110 --> 13:17.110
地盘下面的

13:17.110 --> 13:18.110
webpad

13:18.110 --> 13:19.110
好像我的文件

13:19.110 --> 13:21.110
叫repository

13:21.110 --> 13:22.110
能不能这样子写呢

13:22.110 --> 13:24.110
绝对路径

13:24.110 --> 13:25.110
然后我们自己配置

13:25.110 --> 13:26.110
一个dest

13:26.110 --> 13:27.110
写钢吧

13:27.110 --> 13:28.110
写钢要有写两个

13:28.110 --> 13:29.110
专一

13:30.110 --> 13:31.110
那么能不能这样子写呢

13:31.110 --> 13:32.110
这样子写不好

13:32.110 --> 13:34.110
有哪些不好的地方呢

13:35.110 --> 13:36.110
第一点

13:37.110 --> 13:38.110
不同的操作系统

13:38.110 --> 13:39.110
是不是这个

13:39.110 --> 13:40.110
写钢的写法不一样

13:41.110 --> 13:42.110
对吧

13:42.110 --> 13:43.110
虽然说现在的

13:43.110 --> 13:44.110
Windows操作系统

13:44.110 --> 13:45.110
也支持我写钢了

13:45.110 --> 13:46.110
也支持正写钢了

13:46.110 --> 13:47.110
可以不用反写钢了

13:47.110 --> 13:48.110
不过呢

13:48.110 --> 13:49.110
一些早期的操作系统里边

13:49.110 --> 13:50.110
是不是

13:50.110 --> 13:51.110
它支持的不一样

13:51.110 --> 13:52.110
那么

13:52.110 --> 13:53.110
就会导致你一个代码的

13:53.110 --> 13:54.110
如果说放到一些

13:54.110 --> 13:56.110
不支持这种方式的

13:56.110 --> 13:57.110
环境里边

13:57.110 --> 13:58.110
它是不是就运行不了

13:58.110 --> 13:59.110
就要包错

14:00.110 --> 14:01.110
第二个

14:01.110 --> 14:02.110
你这个工程

14:02.110 --> 14:03.110
是不是有可能会移动啊

14:03.110 --> 14:04.110
它不一定在这个位置

14:04.110 --> 14:05.110
将来是不是要可能

14:05.110 --> 14:06.110
会移动到别的位置

14:06.110 --> 14:07.110
移动到别的位置过后

14:07.110 --> 14:08.110
这个路径写实了

14:08.110 --> 14:09.110
是不是又得改

14:09.110 --> 14:10.110
就特别麻烦

14:10.110 --> 14:11.110
因此呢我们这里

14:11.110 --> 14:12.110
绝对路径可以这样子写

14:12.110 --> 14:13.110
但是呢我们通常

14:13.110 --> 14:14.110
不这样子写

14:14.110 --> 14:15.110
我们会怎么写呢

14:15.110 --> 14:16.110
如果说你要配置

14:16.110 --> 14:17.110
这个东西的话

14:17.110 --> 14:18.110
当然不配置的话

14:18.110 --> 14:19.110
就是电神部路

14:19.110 --> 14:20.110
如果说你要配置的

14:20.110 --> 14:21.110
这个东西的话

14:21.110 --> 14:22.110
那么你应该使用

14:22.110 --> 14:23.110
因为这个代码

14:23.110 --> 14:24.110
是在漏德环境里边执行的

14:24.110 --> 14:25.110
所以说我们可以使用

14:25.110 --> 14:26.110
漏德里边要提供的

14:26.110 --> 14:28.110
这个PASS

14:28.110 --> 14:29.110
内置模块

14:29.110 --> 14:30.110
用它来帮我们

14:30.110 --> 14:32.110
处理绝对路径

14:32.110 --> 14:34.110
我们希望它

14:34.110 --> 14:35.110
通过这个PASS

14:35.110 --> 14:37.110
通过它来resolve

14:37.110 --> 14:39.110
来产生一个绝对路径

14:39.110 --> 14:40.110
从哪一开始呢

14:40.110 --> 14:42.110
从我们这个文件

14:42.110 --> 14:43.110
因为我不知道它那个漏德

14:43.110 --> 14:44.110
为PAC这个命令

14:44.110 --> 14:46.110
是在哪里运行的

14:46.110 --> 14:47.110
所以说呢我们

14:47.110 --> 14:48.110
应该从这个文件

14:48.110 --> 14:49.110
所在的目录

14:49.110 --> 14:51.110
开始来进行查找

14:51.110 --> 14:52.110
我们通常都是这样子

14:52.110 --> 14:53.110
我们肯定是

14:53.110 --> 14:54.110
希望放到这里边

14:54.110 --> 14:55.110
然后呢

14:55.110 --> 14:56.110
我们希望放到

14:56.110 --> 14:57.110
这个目录下面的哪里呢

14:57.110 --> 14:59.110
比方说放到这个Target

14:59.110 --> 15:00.110
放到这个目录下面

15:00.110 --> 15:01.110
就表示什么意思呢

15:01.110 --> 15:02.110
就表示的是

15:02.110 --> 15:04.110
我生成一个绝对路径

15:04.110 --> 15:05.110
这个绝对路径

15:05.110 --> 15:06.110
是以这个目录为起点

15:06.110 --> 15:07.110
就是这个GS

15:07.110 --> 15:08.110
就是这个GS

15:08.110 --> 15:10.110
它所在的目录为起点

15:10.110 --> 15:11.110
然后呢找它下面的

15:11.110 --> 15:12.110
Target这个文件夹

15:12.110 --> 15:13.110
生成一个绝对路径

15:13.110 --> 15:14.110
把这个绝对路径给它

15:14.110 --> 15:15.110
对吧

15:15.110 --> 15:16.110
是不是通过它

15:16.110 --> 15:17.110
就可以处理了

15:17.110 --> 15:18.110
好接下来我们

15:18.110 --> 15:19.110
处理好了过后

15:19.110 --> 15:21.110
来运行一下

15:21.110 --> 15:22.110
NPX围派

15:27.110 --> 15:28.110
上转一下

15:32.110 --> 15:33.110
它说

15:33.110 --> 15:35.110
没有发现NT

15:35.110 --> 15:37.110
没有发现NT

15:37.110 --> 15:38.110
因为它我这里改动了

15:38.110 --> 15:39.110
Output

15:39.110 --> 15:41.110
我们把NT加一下NT

15:41.110 --> 15:43.110
就是我们的入口

15:43.110 --> 15:44.110
入口我们之前说过

15:44.110 --> 15:46.110
入口我们先直接这样子写

15:47.110 --> 15:48.110
不是说没有配置这个

15:48.110 --> 15:49.110
是我们这里

15:49.110 --> 15:51.110
SRC目录下面没有NT

15:51.110 --> 15:52.110
可以不用配置这个

15:52.110 --> 15:53.110
我就说了

15:53.110 --> 15:54.110
可以不用配置这个

15:54.110 --> 15:55.110
是我们这里没有写

15:55.110 --> 15:56.110
没有写

15:56.110 --> 15:57.110
比方我们就写个GS

15:57.110 --> 15:59.110
什么都不单码都没有

15:59.110 --> 16:00.110
特地

16:00.110 --> 16:02.740
看一下

16:02.740 --> 16:03.740
你看是不是生成了

16:03.740 --> 16:05.740
好那么生成在哪的

16:06.740 --> 16:07.740
是不是生成的

16:07.740 --> 16:08.740
不是在垫手目录的

16:08.740 --> 16:09.740
变成了什么

16:09.740 --> 16:10.740
变成Target

16:10.740 --> 16:11.740
这个东西

16:11.740 --> 16:12.740
它就是配置了

16:12.740 --> 16:13.740
是什么

16:13.740 --> 16:14.740
我们出口

16:14.740 --> 16:15.740
就配置了

16:15.740 --> 16:16.740
是这些资源

16:16.740 --> 16:18.740
它的一些信息

16:18.740 --> 16:19.740
我们刚才看到的

16:19.740 --> 16:20.740
其中一个配置就是PASS

16:20.740 --> 16:21.740
就这些最终生成的资源

16:21.740 --> 16:23.740
它放到哪个文件夹下面

16:23.740 --> 16:24.740
PASS

16:25.740 --> 16:26.740
好那么

16:26.740 --> 16:27.740
其中还有第二个配置

16:27.740 --> 16:29.740
叫做FILENATE

16:29.740 --> 16:30.740
FILENATE

16:30.740 --> 16:32.740
这个配置的是什么呢

16:32.740 --> 16:35.740
配置的是资源的文件名

16:35.740 --> 16:37.740
配置的是资源的文件名

16:37.740 --> 16:38.740
那么配置

16:38.740 --> 16:39.740
这里这么多资源

16:39.740 --> 16:40.740
那么配置的是哪个

16:40.740 --> 16:42.740
资源的文件名呢

16:42.740 --> 16:43.740
注意

16:43.740 --> 16:44.740
注意听

16:44.740 --> 16:45.740
它这里

16:45.740 --> 16:47.740
要理解一下

16:47.740 --> 16:49.740
因为我们这些资源哪来的

16:49.740 --> 16:51.740
是不是来自于创渴

16:51.740 --> 16:52.740
创渴产生的资源

16:52.740 --> 16:53.740
合并到这了

16:53.740 --> 16:55.740
那么创渴的资源哪来的

16:55.740 --> 16:56.740
是不是来自于模块

16:56.740 --> 16:57.740
合并的结果

16:57.740 --> 16:58.740
你看

16:58.740 --> 16:59.740
我这里的图

16:59.740 --> 17:00.740
画的是非常小心的

17:00.740 --> 17:01.740
我这个创渴

17:01.740 --> 17:02.740
每一个创渴里边

17:02.740 --> 17:04.740
你看我是不是画了两个

17:04.740 --> 17:05.740
对吧

17:05.740 --> 17:06.740
我每一个创渴

17:06.740 --> 17:07.740
是不是画了两个

17:07.740 --> 17:08.740
两个资源

17:08.740 --> 17:09.740
好那么

17:09.740 --> 17:10.740
为什么我画了两个

17:10.740 --> 17:11.740
没有画多个呢

17:11.740 --> 17:12.740
是因为我们目前

17:12.740 --> 17:13.740
你会发现

17:13.740 --> 17:15.740
有一个情况就是

17:15.740 --> 17:17.740
每一个创渴里边

17:17.740 --> 17:18.740
它打包

17:18.740 --> 17:20.740
它进行生成资源列表

17:20.740 --> 17:22.740
那么其中一定有一个资源

17:22.740 --> 17:23.740
是什么了

17:23.740 --> 17:25.740
其中有一个资源是

17:25.740 --> 17:29.740
合并模块后的

17:29.740 --> 17:32.740
GS代码文件

17:32.740 --> 17:33.740
对吧

17:33.740 --> 17:34.740
它一定有一个文件

17:34.740 --> 17:35.740
是合并模块后的

17:35.740 --> 17:36.740
GS代码文件

17:36.740 --> 17:37.740
就把多个模块

17:37.740 --> 17:39.740
合并成一个GS

17:39.740 --> 17:40.740
那么还有一个可能

17:40.740 --> 17:41.740
还有一个可能是什么文件的

17:41.740 --> 17:43.740
就是对应的

17:44.740 --> 17:46.740
对应的MAP文件

17:46.740 --> 17:47.740
就是一些

17:47.740 --> 17:49.740
其他的乱七八糟的文件

17:49.740 --> 17:50.740
那么这里也是

17:50.740 --> 17:53.740
这里也是

17:53.740 --> 17:54.740
这里也是

17:54.740 --> 17:56.740
这里一个创渴

17:56.740 --> 17:57.740
它有可能生成

17:57.740 --> 17:58.740
有合并之后的

17:58.740 --> 17:59.740
GS代码文件

17:59.740 --> 18:00.740
已经对应的MAP文件

18:00.740 --> 18:01.740
我们目前只有

18:01.740 --> 18:02.740
这么两种情况

18:02.740 --> 18:05.740
那么这里的file name

18:05.740 --> 18:06.740
这个file name

18:06.740 --> 18:07.740
配置的是啥呢

18:07.740 --> 18:09.740
配置的是这个东西

18:09.740 --> 18:10.740
配置的是这个东西

18:10.740 --> 18:12.740
生成了这个东西

18:12.740 --> 18:13.740
听懂了吗

18:13.740 --> 18:14.740
它配置的是生成了

18:14.740 --> 18:15.740
这个东西

18:15.740 --> 18:16.740
那么以后呢

18:16.740 --> 18:17.740
有没有可能

18:17.740 --> 18:18.740
更多的文件

18:18.740 --> 18:19.740
我们以后再说

18:19.740 --> 18:20.740
但是现在它是

18:20.740 --> 18:21.740
你现在不能通过

18:21.740 --> 18:22.740
这个file name

18:22.740 --> 18:23.740
配置这个MAP文件

18:23.740 --> 18:24.740
不能配置它

18:24.740 --> 18:25.740
但是你可以配置的是它

18:25.740 --> 18:27.740
因为这才是我们

18:27.740 --> 18:28.740
需要关心的

18:28.740 --> 18:29.740
其他的我们

18:29.740 --> 18:30.740
care不care

18:30.740 --> 18:31.740
其他的像map文件

18:31.740 --> 18:32.740
这种东西

18:32.740 --> 18:33.740
它这种生成就行了

18:33.740 --> 18:34.740
跟我们没啥关系

18:34.740 --> 18:35.740
能不能配置

18:35.740 --> 18:36.740
能配置

18:36.740 --> 18:37.740
只不过我们一般

18:37.740 --> 18:38.740
不去配置它

18:38.740 --> 18:39.740
通过另外一个配置

18:39.740 --> 18:40.740
我们要关心的是

18:40.740 --> 18:42.740
这个GS代码文件

18:43.740 --> 18:44.740
因此我们这个file name

18:44.740 --> 18:45.740
配置的是它

18:45.740 --> 18:47.740
所以它这个

18:47.740 --> 18:48.740
那么这个file name

18:48.740 --> 18:49.740
它有可能有多个

18:49.740 --> 18:50.740
因为它有可能有多个

18:50.740 --> 18:51.740
创可对吧

18:51.740 --> 18:52.740
那么它不管

18:52.740 --> 18:54.740
它只配置一个字符创

18:54.740 --> 18:55.740
它只配置一个

18:55.740 --> 18:56.740
那么这个字符创

18:56.740 --> 18:57.740
叫做规则

18:57.740 --> 18:58.740
叫做规则

18:58.740 --> 18:59.740
配置的是什么

18:59.740 --> 19:00.740
配置的是

19:00.740 --> 19:05.740
合并的解释文件的规则

19:05.740 --> 19:06.740
那么这个规则

19:06.740 --> 19:07.740
怎么写的

19:07.740 --> 19:08.740
有很多种写法

19:08.740 --> 19:09.740
其中一种写法

19:09.740 --> 19:11.740
就是静态的写法

19:11.740 --> 19:12.740
什么叫静态的写法

19:12.740 --> 19:15.740
就是直接写上一个

19:15.740 --> 19:16.740
比方说

19:16.740 --> 19:17.740
bondle的解释

19:17.740 --> 19:18.740
就直接写上一个文件名

19:18.740 --> 19:19.740
就行了

19:19.740 --> 19:20.740
这是最简单的写法

19:20.740 --> 19:22.740
我们这里

19:22.740 --> 19:25.740
把妹的GS删掉

19:25.740 --> 19:27.740
现在我们再运行

19:27.740 --> 19:31.340
你看一下

19:31.340 --> 19:32.340
你看合并的GS

19:32.340 --> 19:33.340
是bondle的解释

19:33.340 --> 19:34.340
对吧

19:34.340 --> 19:35.340
它就文件名就改了

19:35.340 --> 19:37.340
改成我们这个样子了

19:37.340 --> 19:38.340
静态的写法

19:38.340 --> 19:39.340
我们慢慢来

19:39.340 --> 19:40.340
不着急

19:40.340 --> 19:42.340
如果说我希望

19:42.340 --> 19:43.340
我不想把这个GS

19:43.340 --> 19:44.340
放到跟目录下边

19:44.340 --> 19:45.340
因为我们到时候

19:45.340 --> 19:46.340
会把这个目录

19:46.340 --> 19:47.340
直接上传到服务器

19:47.340 --> 19:48.340
对吧

19:48.340 --> 19:49.340
这就是我们

19:49.340 --> 19:51.340
最重要运行的文件夹

19:51.340 --> 19:52.340
那么我希望

19:52.340 --> 19:53.340
把它放到某一个

19:53.340 --> 19:54.340
指文件夹里边

19:54.340 --> 19:55.340
可不可以呢

19:55.340 --> 19:56.340
比方说我们可以这样写

19:56.340 --> 19:57.340
scripps写抗

19:57.340 --> 19:59.340
或者是GS写抗

19:59.340 --> 20:00.340
那么就把它放到

20:00.340 --> 20:01.340
指文件夹里边去了

20:01.340 --> 20:02.340
看一下

20:02.340 --> 20:05.220
clear

20:05.220 --> 20:06.220
运行

20:07.220 --> 20:08.220
你看

20:08.220 --> 20:09.220
所以就放到

20:09.220 --> 20:10.220
这个文件夹里边去了

20:10.220 --> 20:12.220
就任意放到什么地方

20:12.220 --> 20:13.220
就放到这个

20:13.220 --> 20:14.220
PASS目录的什么地方

20:14.220 --> 20:15.220
你自己随便写

20:15.220 --> 20:16.220
这是file

20:16.220 --> 20:17.220
听懂了吗

20:17.220 --> 20:18.220
当然还可以有

20:18.220 --> 20:19.220
指文件夹

20:19.220 --> 20:20.220
abc都可以

20:20.220 --> 20:21.220
再看一下

20:25.970 --> 20:26.970
正常出来

20:26.970 --> 20:28.970
你看是不是跑出来了

20:28.970 --> 20:29.970
总之呢

20:29.970 --> 20:30.970
它配置的是什么呢

20:30.970 --> 20:31.970
配置的是那个

20:31.970 --> 20:33.970
合并的GS的文件名的规则

20:33.970 --> 20:35.970
它怎么来生成一个文件名

20:37.970 --> 20:38.970
那么我们知道

20:38.970 --> 20:39.970
这些资源都属于邦斗

20:39.970 --> 20:40.970
对吧

20:40.970 --> 20:41.970
当然这个邦斗

20:41.970 --> 20:43.970
也可以不用取这个名字

20:43.970 --> 20:44.970
任意名字都可以

20:45.970 --> 20:46.970
ok

20:47.970 --> 20:48.970
那么这是file

20:48.970 --> 20:50.970
这是静态的规则

20:51.970 --> 20:52.970
好

20:52.970 --> 20:53.970
那么先说到这

20:53.970 --> 20:55.970
那么还有没有动态的规则呢

20:55.970 --> 20:56.970
动态的规则有

20:56.970 --> 20:57.970
不过呢

20:57.970 --> 20:58.970
我们暂时呢

20:58.970 --> 20:59.970
因为说了不好举例子

20:59.970 --> 21:00.970
说了不好举例子

21:00.970 --> 21:01.970
所以说呢

21:01.970 --> 21:03.970
我们还要去讲一讲出口

21:03.970 --> 21:04.970
入口

21:04.970 --> 21:05.970
把入口讲了之后

21:05.970 --> 21:06.970
我们就可以

21:06.970 --> 21:08.970
回过头去讲出口的动态配置

21:08.970 --> 21:09.970
动态规则

21:09.970 --> 21:11.970
好 现在我们再看入口

21:12.970 --> 21:13.970
把这个去掉

21:13.970 --> 21:14.970
abc去掉

21:16.970 --> 21:17.970
把这个去掉

21:18.970 --> 21:20.970
我们再看入口

21:20.970 --> 21:21.970
入口通过什么来配置

21:21.970 --> 21:22.970
通过entry

21:22.970 --> 21:23.970
入口实际上配置的是什么呢

21:23.970 --> 21:25.970
配置的它应该也是一个对象

21:26.970 --> 21:27.970
应该也是一个对象

21:27.970 --> 21:29.970
那么这个入口里边怎么来配置呢

21:29.970 --> 21:31.970
它是这样的一个写法

21:31.970 --> 21:32.970
配置的是什么呢

21:32.970 --> 21:34.970
它配置的是trunk

21:34.970 --> 21:35.970
配置的是这个

21:35.970 --> 21:37.970
有几个trunk

21:37.970 --> 21:38.970
有几个trunk

21:38.970 --> 21:40.970
默认肯定是只有一个

21:40.970 --> 21:42.970
那么trunk的名称

21:42.970 --> 21:44.970
它就是一个属性名

21:44.970 --> 21:45.970
一个属性值

21:45.970 --> 21:46.970
一个属性值

21:46.970 --> 21:48.970
那么属性名写什么呢

21:48.970 --> 21:49.970
属性名表示

21:49.970 --> 21:50.970
trunk的名称

21:51.970 --> 21:53.970
不是每个trunk都有名称吗

21:53.970 --> 21:55.970
那么trunk的名称是啥

21:55.970 --> 21:56.970
默认情况下

21:56.970 --> 21:58.970
这里的配置是怎么写的呢

21:58.970 --> 21:59.970
默认的情况下

21:59.970 --> 22:01.970
这里的配置是这样子的

22:01.970 --> 22:03.970
trunk的名称为Mate

22:03.970 --> 22:04.970
那么后边写什么呢

22:04.970 --> 22:05.970
后边写这个trunk

22:05.970 --> 22:06.970
你看trunk里边

22:06.970 --> 22:08.970
是不是要根据一个入口模块

22:08.970 --> 22:09.970
来生存资源

22:09.970 --> 22:11.970
后边写的是什么呢

22:11.970 --> 22:12.970
后边写的是

22:12.970 --> 22:14.970
这个trunk对应的入口模块

22:16.970 --> 22:17.970
src int

22:17.970 --> 22:18.970
这里可以写相对度计

22:18.970 --> 22:19.970
要解释

22:20.970 --> 22:24.280
它默认情况就是这样子写的

22:24.280 --> 22:26.280
你可以这样理解

22:26.280 --> 22:28.280
那我跟我们之前学的配置不一样

22:28.280 --> 22:30.280
之前的配置我们是怎么写的

22:30.280 --> 22:32.280
之前的配置是不是这样子写的

22:32.280 --> 22:33.280
对吧

22:33.280 --> 22:35.280
这样的写法

22:35.280 --> 22:37.280
它就会把它转换成为

22:37.280 --> 22:38.280
这种写法

22:38.280 --> 22:40.280
这种写法还是规范的写法

22:40.280 --> 22:42.280
才是正确的写法

22:42.280 --> 22:43.280
听懂了吗

22:43.280 --> 22:44.280
它默认的trunk名称就是这个

22:44.280 --> 22:46.280
那么用这种写法

22:46.280 --> 22:48.280
那么就相当于是

22:48.280 --> 22:49.280
这种写法

22:49.280 --> 22:50.280
我再打个注释

22:50.280 --> 22:51.280
什么意思

22:51.280 --> 22:52.280
属性名

22:52.280 --> 22:53.280
表示

22:53.280 --> 22:55.280
属性名指的是

22:55.280 --> 22:57.280
trunk的名称

22:57.280 --> 22:59.280
然后属性值

22:59.280 --> 23:01.280
是入口模块

23:01.280 --> 23:03.280
trunk内部

23:03.280 --> 23:04.280
它不是要打包吗

23:04.280 --> 23:05.280
它根据入口模块去找到

23:05.280 --> 23:06.280
找到一代关系

23:06.280 --> 23:08.280
在这个trunk内

23:08.280 --> 23:10.280
形成有很多个模块列表

23:10.280 --> 23:11.280
一个模块列表

23:11.280 --> 23:12.280
那么

23:12.280 --> 23:14.280
它要通过哪个入口模块去找

23:14.280 --> 23:16.280
那么这就是这个意思

23:16.280 --> 23:18.280
所以我们这里说的入口指的是trunk

23:18.280 --> 23:20.280
指的是trunk

23:20.280 --> 23:21.280
就有哪些trunk

23:21.280 --> 23:22.280
那么trunk

23:22.280 --> 23:23.280
每个trunk对应的东西

23:23.280 --> 23:24.280
才是我们

23:24.280 --> 23:27.280
感觉上的入口模块

23:27.280 --> 23:28.280
是这么个意思

23:28.280 --> 23:29.280
是这么个意思

23:29.280 --> 23:30.280
其实这个地方

23:30.280 --> 23:31.280
我们也可以把它叫做启动模块

23:31.280 --> 23:33.280
都是一个意思

23:34.280 --> 23:35.280
好 那么这样子写

23:35.280 --> 23:36.280
我们来看一下

23:36.280 --> 23:40.130
来打包看一下

23:40.130 --> 23:41.130
你看一下

23:41.130 --> 23:43.130
我们这里说的是什么呢

23:43.130 --> 23:45.130
说的是N-point

23:45.130 --> 23:46.130
你看

23:46.130 --> 23:47.130
入口这里 是不是me

23:47.130 --> 23:48.130
说明是我们的trunk是什么

23:48.130 --> 23:49.130
me

23:49.130 --> 23:50.130
你看trunk name是me

23:50.130 --> 23:51.130
trunk的id

23:51.130 --> 23:52.130
因为我们是开发环境

23:52.130 --> 23:54.130
所以说trunk的id跟这个名字

23:54.130 --> 23:55.130
是一样的

23:55.130 --> 23:56.130
是一样的

23:57.130 --> 23:58.130
看到这个意思吗

23:58.130 --> 23:59.130
OK

23:59.130 --> 24:01.130
好 那么这里

24:01.130 --> 24:03.130
可以有一个入口

24:03.130 --> 24:05.130
那能不能有多个入口呢

24:05.130 --> 24:06.130
当然可以

24:06.130 --> 24:08.130
就是能不能有多个trunk呢

24:08.130 --> 24:09.130
当然可以

24:09.130 --> 24:10.130
你看我们的图

24:10.130 --> 24:11.130
是不是可以有多个trunk

24:11.130 --> 24:12.130
那么你想

24:12.130 --> 24:13.130
有多个trunk

24:13.130 --> 24:15.130
是不是会形成多个介石文件

24:15.130 --> 24:16.130
每个trunk

24:16.130 --> 24:17.130
它会打包一个介石

24:17.130 --> 24:18.130
每个trunk

24:18.130 --> 24:19.130
会打包一个介石

24:19.130 --> 24:20.130
就是每个trunk对应一个帮斗

24:20.130 --> 24:21.130
每个trunk对应一个帮斗

24:21.130 --> 24:22.130
好 那么现在呢

24:22.130 --> 24:23.130
我们再看

24:23.130 --> 24:25.130
如果说我这里配置多个

24:25.130 --> 24:26.130
比方说

24:27.130 --> 24:28.130
我们这里

24:28.130 --> 24:29.130
配置一个

24:29.130 --> 24:31.130
c.js

24:31.130 --> 24:32.130
我的a.js

24:32.130 --> 24:33.130
a.js

24:33.130 --> 24:34.130
好 OK

24:34.130 --> 24:35.130
那么在这里

24:35.130 --> 24:36.130
我们再配置一个

24:36.130 --> 24:37.130
因为这是个对象

24:37.130 --> 24:38.130
它一定可以配置多个

24:38.130 --> 24:40.130
比方说配置一个a

24:40.130 --> 24:42.130
src

24:42.130 --> 24:43.130
这里

24:43.130 --> 24:44.130
我们入口呢

24:44.130 --> 24:45.130
就是入口模块

24:45.130 --> 24:46.130
在哪里

24:46.130 --> 24:47.130
a.js

24:48.130 --> 24:50.130
好 那么这个东西

24:50.130 --> 24:51.130
可不可以呢

24:51.130 --> 24:52.130
可以

24:52.130 --> 24:53.130
这样子的话

24:53.130 --> 24:54.130
它怎么来生成资源

24:54.130 --> 24:55.130
它生成资源的话

24:55.130 --> 24:57.130
就是我通过me

24:57.130 --> 24:59.130
是不是通过这个index.js

24:59.130 --> 25:01.130
通过这个index.js

25:01.130 --> 25:02.130
去找依赖关系

25:02.130 --> 25:04.130
找到一大堆模块

25:04.130 --> 25:05.130
然后生成资源

25:05.130 --> 25:07.130
把合并到一个介石里边

25:07.130 --> 25:08.130
然后我另一个trunk

25:08.130 --> 25:09.130
两个trunk

25:09.130 --> 25:10.130
单独运行

25:10.130 --> 25:11.130
互不干扰

25:11.130 --> 25:12.130
你运行你的

25:12.130 --> 25:14.130
我运行我的

25:14.130 --> 25:15.130
那么我这个a

25:15.130 --> 25:17.130
它又去通过这个a.js

25:17.130 --> 25:19.130
通过它为入口模块

25:19.130 --> 25:20.130
来去找

25:20.130 --> 25:21.130
那么是不是它也要

25:21.130 --> 25:22.130
打包成一个介石

25:22.130 --> 25:23.130
对吧

25:23.130 --> 25:25.130
那么就形成了两个trunk

25:25.130 --> 25:26.130
好 大家好好想一想

25:26.130 --> 25:28.130
在我们目前那个配置下面

25:28.130 --> 25:30.130
我现在运行会不会出问题

25:30.130 --> 25:32.130
好好想想那个逻辑

25:32.130 --> 25:34.130
就这里边其实是有逻辑的

25:34.130 --> 25:35.130
不是说

25:35.130 --> 25:36.130
我该怎么去配置就这么去

25:36.130 --> 25:37.130
想那么配置就怎么配置

25:37.130 --> 25:39.130
这边有逻辑的

25:39.130 --> 25:40.130
会不会出问题呢

25:40.130 --> 25:44.140
咱们看一下

25:44.140 --> 25:45.140
运行

25:45.140 --> 25:47.140
好 那么它这里

25:47.140 --> 25:48.140
给你说了一个东西

25:48.140 --> 25:49.140
arrow

25:49.140 --> 25:50.140
啊 它说

25:50.140 --> 25:51.140
什么 爆错了

25:51.140 --> 25:52.140
啊 它说

25:52.140 --> 25:54.140
怎么回事呢

25:54.140 --> 25:55.140
conflate

25:55.140 --> 25:56.140
conflate

25:56.140 --> 25:57.140
冲突

25:57.140 --> 25:58.140
冲突 什么冲突呢

25:58.140 --> 26:00.140
它说要有多个trunk

26:00.140 --> 26:01.140
multiple trunk

26:01.140 --> 26:02.140
生成的mx

26:02.140 --> 26:03.140
就生成

26:03.140 --> 26:04.140
生成的资源

26:04.140 --> 26:06.140
对吧 trunk xs

26:06.140 --> 26:07.140
到了一个什么

26:07.140 --> 26:09.140
到了一个相同的文件名

26:09.140 --> 26:11.140
帮到的介石里边

26:11.140 --> 26:12.140
它就爆了这么一个出

26:12.140 --> 26:13.140
是不是好理解了

26:13.140 --> 26:14.140
我们有多个trunk

26:14.140 --> 26:15.140
那么就是不是就意味着

26:15.140 --> 26:16.140
每个trunk

26:16.140 --> 26:17.140
它会生成一个介石

26:17.140 --> 26:19.140
现在你们就把它当成

26:19.140 --> 26:20.140
一个介石文件就行了

26:20.140 --> 26:21.140
每个trunk

26:21.140 --> 26:22.140
是不是生成一个帮助

26:22.140 --> 26:24.140
因为我这里没有设置map

26:24.140 --> 26:25.140
设置map是一样的

26:25.140 --> 26:26.140
设置map是一样的

26:26.140 --> 26:28.140
比方说我们设置上map

26:28.140 --> 26:30.140
to sourcemap

26:30.140 --> 26:32.140
你看吧 是一样的

26:32.140 --> 26:34.140
如果说你只有一个的话

26:34.140 --> 26:35.140
没问题

26:35.140 --> 26:39.180
只有一个

26:39.180 --> 26:40.180
好 只有一个 你看

26:40.180 --> 26:41.180
它多了一个

26:41.180 --> 26:43.180
就是以这个介石文件名

26:43.180 --> 26:45.180
然后再加上一个后续名map

26:45.180 --> 26:46.180
它就形成个map文件

26:46.180 --> 26:47.180
但是你有多个的时候

26:47.180 --> 26:48.180
还是会出问题

26:48.180 --> 26:50.180
因为它介石文件名重复了

26:50.180 --> 26:51.180
因为现在用两个trunk

26:51.180 --> 26:53.180
你不能用一个静态的规则了

26:53.180 --> 26:55.180
当你有多个入口的时候

26:55.180 --> 26:57.180
你就不应该用一个静态的规则了

26:57.180 --> 26:58.180
应该用什么

26:58.180 --> 26:59.180
要用动态规则

26:59.180 --> 27:00.180
就是你每一个trunk

27:00.180 --> 27:01.180
生成的文件名

27:01.180 --> 27:03.180
它肯定是不一样的

27:03.180 --> 27:04.180
那么怎么来指定的

27:04.180 --> 27:05.180
你当然不是在这里

27:05.180 --> 27:06.180
为每一个trunk

27:06.180 --> 27:07.180
去配置一个文件名

27:07.180 --> 27:08.180
那是太麻烦了

27:08.180 --> 27:09.180
它也不建议你这样做

27:09.180 --> 27:11.180
它也不提供你这种做法

27:11.180 --> 27:12.180
那么它觉得

27:12.180 --> 27:13.180
最正确的做法

27:13.180 --> 27:14.180
应该是你这里

27:14.180 --> 27:15.180
配置一个规则

27:15.180 --> 27:17.180
这个规则可以适应

27:17.180 --> 27:18.180
每一个trunk

27:18.180 --> 27:19.180
可以把这个规则

27:19.180 --> 27:20.180
用到每一个trunk里边

27:20.180 --> 27:21.180
那么这个规则怎么写呢

27:21.180 --> 27:24.180
就是在你写的文件名里边

27:24.180 --> 27:26.180
你在合适的地方

27:26.180 --> 27:29.180
去加上一个中货号

27:29.180 --> 27:31.180
中货号里面就配这个规则

27:31.180 --> 27:32.180
那么到时候

27:32.180 --> 27:33.180
它会再应用到

27:33.180 --> 27:34.180
每一个trunk的时候

27:34.180 --> 27:35.180
它会把这个规则

27:35.180 --> 27:36.180
给你替换掉

27:36.180 --> 27:37.180
给你替换掉

27:37.180 --> 27:39.180
好 比方说

27:39.180 --> 27:41.180
这个里面可以写什么东西呢

27:41.180 --> 27:43.180
我这些就在笔记里面

27:43.180 --> 27:45.750
借一借一下

27:45.750 --> 27:46.750
这里有个规则

27:46.750 --> 27:48.750
规则其实还有不少

27:48.750 --> 27:50.750
我们这里讲常用的

27:50.750 --> 27:51.750
第一个NAME

27:51.750 --> 27:52.750
NAME是什么呢

27:52.750 --> 27:56.750
就指的是trunk的NAME

27:56.750 --> 27:59.750
它被trunk的NAME替换

27:59.750 --> 28:00.750
指的是trunkNAME

28:00.750 --> 28:01.750
就这样写就行了

28:01.750 --> 28:02.750
你就理解了

28:02.750 --> 28:03.750
什么意思

28:03.750 --> 28:05.750
我们这里可以写个NAME

28:05.750 --> 28:07.750
不用这个帮助了

28:07.750 --> 28:09.750
那么这样你来了

28:09.750 --> 28:10.750
它这个规则

28:10.750 --> 28:11.750
会应用到这个trunk

28:11.750 --> 28:12.750
也会应用到这个trunk

28:12.750 --> 28:13.750
那么在这个trunk

28:13.750 --> 28:14.750
生成资源的时候

28:14.750 --> 28:15.750
那么这个GS文件名

28:15.750 --> 28:16.750
它就会应用到什么

28:16.750 --> 28:18.750
它就会把这个trunkNAME

28:18.750 --> 28:19.750
替换到这个位置

28:19.750 --> 28:20.750
那么这个trunk

28:20.750 --> 28:22.750
在生成它的资源的时候

28:22.750 --> 28:23.750
它会把它的trunkNAME

28:23.750 --> 28:24.750
替换到这个位置

28:24.750 --> 28:25.750
好 现在我们再看一下

28:25.750 --> 28:27.750
我们把它给它删除一下

28:27.750 --> 28:28.750
OK

28:28.750 --> 28:29.750
我们再摆英雄

28:29.750 --> 28:33.090
NPX

28:33.090 --> 28:34.090
英雄

28:34.090 --> 28:36.090
好 你看

28:36.090 --> 28:37.090
是不是有个A点GS

28:37.090 --> 28:38.090
有个Mate点GS

28:38.090 --> 28:39.090
对吧

28:39.090 --> 28:40.090
哪来的

28:40.090 --> 28:41.090
是不是A就是我们的trunkNAME

28:41.090 --> 28:42.090
Mate就是我们的trunkNAME

28:42.090 --> 28:43.090
对吧

28:43.090 --> 28:45.090
好 我们再看一下

28:45.090 --> 28:46.090
它生成的东西

28:46.090 --> 28:48.090
哈希Version不用说了

28:48.090 --> 28:49.090
Time不用说了

28:49.090 --> 28:51.090
那么支援A点GS

28:51.090 --> 28:52.090
来自哪个trunk

28:52.090 --> 28:53.090
来自这个trunk

28:53.090 --> 28:54.090
A点GS.map

28:54.090 --> 28:55.090
来自这个trunk

28:55.090 --> 28:56.090
你看 是不是不同的

28:56.090 --> 28:57.090
trunk生成的

28:57.090 --> 28:58.090
对吧

28:58.090 --> 29:00.090
好 那么这是关于

29:00.090 --> 29:02.090
入口是不是有两个

29:02.090 --> 29:03.090
一个trunk

29:03.090 --> 29:04.090
一个trunk

29:04.090 --> 29:05.090
那么这个trunk生成的

29:05.090 --> 29:06.090
文件是这个

29:06.090 --> 29:07.090
两个

29:07.090 --> 29:08.090
这个trunk生成的文件

29:08.090 --> 29:09.090
是这样一个

29:09.090 --> 29:10.090
下面就是

29:10.090 --> 29:11.090
所有的文件

29:11.090 --> 29:12.090
它的勾件过程

29:12.090 --> 29:13.090
有哪些文件参与勾件

29:13.090 --> 29:14.090
每个文件

29:14.090 --> 29:15.090
它对应的trunk

29:16.090 --> 29:17.090
OK

29:17.090 --> 29:18.090
那么这就是

29:22.090 --> 29:23.090
多个trunk

29:23.090 --> 29:24.090
多个trunk

29:24.090 --> 29:25.090
那么这里可以写NAME的规则

29:25.090 --> 29:26.090
当然这里面

29:26.090 --> 29:27.090
也不能说

29:27.090 --> 29:28.090
也不能说只能这样写

29:28.090 --> 29:29.090
这些随便怎么写吧

29:29.090 --> 29:30.090
比方说前面随便敲一些

29:30.090 --> 29:31.090
后面随便敲一些

29:31.090 --> 29:32.090
中间再随便敲一些

29:32.090 --> 29:33.090
随便写

29:33.090 --> 29:34.090
随便写

29:34.090 --> 29:35.090
后面再加个NAME

29:35.090 --> 29:36.090
就随便写

29:36.090 --> 29:37.090
总之它会替换

29:37.090 --> 29:38.090
替换掉这个NAME就行了

29:38.090 --> 29:40.090
好 咱们再看一下吧

29:41.090 --> 29:45.260
删出

29:45.260 --> 29:46.260
音响

29:47.260 --> 29:48.260
你看吧

29:48.260 --> 29:49.260
你自己看

29:49.260 --> 29:50.260
自己去对应

29:50.260 --> 29:51.260
把这个NAME就替换掉了

29:51.260 --> 29:52.260
替换掉了

29:52.260 --> 29:53.260
这是个NAME这个规则

29:53.260 --> 29:55.260
相当于是个站位服务而已

29:55.260 --> 29:56.260
这是NAME

29:57.260 --> 29:58.260
好 接下来来说一个

29:58.260 --> 29:59.260
特别有意思的

29:59.260 --> 30:01.260
叫做哈希

30:02.260 --> 30:03.260
这个东西是什么呢

30:03.260 --> 30:06.260
是指的是总的资源哈希

30:06.260 --> 30:08.260
总的资源哈希

30:08.260 --> 30:09.260
那么这个哈希是什么意思呢

30:09.260 --> 30:11.260
为什么我们在这里

30:11.260 --> 30:13.260
可能会需要用到哈希呢

30:13.260 --> 30:15.260
为什么可能会有这么一个需求呢

30:15.260 --> 30:16.260
是因为这个样子

30:16.260 --> 30:17.260
我举个例子

30:19.570 --> 30:20.570
比方说

30:20.570 --> 30:21.570
这个例子呢

30:21.570 --> 30:22.570
我现在不是很好给你们掩饰

30:22.570 --> 30:23.570
因为它是在

30:23.570 --> 30:24.570
一般会在真实的服务系上

30:24.570 --> 30:25.570
才会遇到这个问题

30:25.570 --> 30:28.570
像我们目前运行的页面上呢

30:28.570 --> 30:30.570
是在本地打开的

30:30.570 --> 30:32.570
一般还不会遇到这个问题

30:32.570 --> 30:33.570
我们这里

30:33.570 --> 30:35.570
我只是解释清楚就行了

30:35.570 --> 30:36.570
比方说我们

30:36.570 --> 30:37.570
如果说我们这样子来做

30:37.570 --> 30:39.570
会有一个什么样的问题呢

30:39.570 --> 30:40.570
就是你

30:40.570 --> 30:41.570
我们通过这个课程

30:41.570 --> 30:42.570
不仅学习了VIP

30:42.570 --> 30:44.570
也可以看到很多

30:44.570 --> 30:46.570
在工程化的过程中

30:46.570 --> 30:47.570
我们要去考虑

30:47.570 --> 30:48.570
以前要很麻烦

30:48.570 --> 30:50.570
就是很棘手的

30:50.570 --> 30:52.570
要去考虑到一些问题

30:52.570 --> 30:53.570
你看啊

30:53.570 --> 30:55.570
我们现在是不是生成了一些介绍

30:55.570 --> 30:56.570
为了看来方便

30:56.570 --> 30:57.570
我们把这个dev to去掉吧

30:57.570 --> 30:58.570
看

30:58.570 --> 31:04.080
太老火了

31:04.080 --> 31:05.080
好 生成

31:06.080 --> 31:07.080
好 生成出来了

31:07.080 --> 31:08.080
这么两个介绍

31:08.080 --> 31:09.080
OK

31:09.080 --> 31:10.080
那么现在呢

31:10.080 --> 31:12.080
我们可能有个页面

31:12.080 --> 31:14.080
银这个是叫ATM

31:15.080 --> 31:19.800
就那么的思路走啊

31:19.800 --> 31:20.800
我们这个页面上

31:20.800 --> 31:21.800
引用了ADL介绍

31:21.800 --> 31:22.800
有两个介绍吗

31:22.800 --> 31:24.800
我就再引用一个

31:24.800 --> 31:25.800
Madele介绍

31:25.800 --> 31:26.800
有吧

31:26.800 --> 31:27.800
可能有两个介绍要用

31:28.800 --> 31:29.800
OK

31:29.800 --> 31:30.800
当然

31:30.800 --> 31:31.800
如果说一个页面

31:31.800 --> 31:32.800
引用两个介绍的话

31:32.800 --> 31:33.800
一般情况下

31:33.800 --> 31:34.800
你直接打包成一个就行了

31:34.800 --> 31:36.800
不用去像我们这样子去

31:36.800 --> 31:37.800
打包成两个

31:37.800 --> 31:38.800
没必要

31:38.800 --> 31:39.800
没关系

31:39.800 --> 31:40.800
我们现在说的这么个意思

31:40.800 --> 31:42.800
现在我们有这么个页面

31:42.800 --> 31:43.800
这个页面上

31:43.800 --> 31:44.800
引用了两个介绍

31:44.800 --> 31:45.800
好

31:45.800 --> 31:46.800
你看一下这个路径

31:46.800 --> 31:47.800
你看一下我们浏览器

31:47.800 --> 31:48.800
是怎么来解析的

31:48.800 --> 31:49.800
当我们

31:49.800 --> 31:50.800
真的访问的

31:50.800 --> 31:51.800
部署到服务器过后了

31:51.800 --> 31:53.800
它会形成这么一个现象

31:53.800 --> 31:55.800
就是我们是不是请求这个页面

31:57.800 --> 31:59.800
浏览器会做什么处理呢

31:59.800 --> 32:00.800
浏览器

32:00.800 --> 32:01.800
它会请求

32:01.800 --> 32:02.800
请求什么

32:02.800 --> 32:04.800
银这个是ATM

32:05.800 --> 32:06.800
那么请求完了过后

32:06.800 --> 32:07.800
是不拿到ATM元

32:07.800 --> 32:08.800
来进行分析

32:09.800 --> 32:10.800
分析出来的

32:10.800 --> 32:11.800
它又有两个介绍

32:11.800 --> 32:13.800
是不是又要去请求

32:13.800 --> 32:14.800
请求两个介绍

32:14.800 --> 32:15.800
对吧

32:15.800 --> 32:16.800
请求什么

32:16.800 --> 32:17.800
ADL介绍和什么

32:17.800 --> 32:18.800
Madele介绍

32:18.800 --> 32:19.800
是不是请求这两个

32:19.800 --> 32:20.800
好

32:20.800 --> 32:21.800
请求完了过后

32:21.800 --> 32:23.800
浏览器为了避免

32:23.800 --> 32:24.800
以后

32:24.800 --> 32:25.800
对吧

32:25.800 --> 32:26.800
真实的服务器环境里边

32:26.800 --> 32:27.800
还要跟服务器配合的

32:27.800 --> 32:28.800
因为有些服务器

32:28.800 --> 32:29.800
告诉你不要缓存

32:29.800 --> 32:31.800
我这就要说缓存的问题

32:31.800 --> 32:32.800
那么请求完了过后

32:32.800 --> 32:33.800
它会做一个事情

32:33.800 --> 32:34.800
就是把这些文件

32:34.800 --> 32:36.800
缓存起来

32:36.800 --> 32:40.500
缓存到浏览器里边

32:40.500 --> 32:41.500
缓存

32:42.500 --> 32:43.500
好

32:43.500 --> 32:44.500
那么下一次

32:44.500 --> 32:45.500
再去请求

32:45.500 --> 32:47.500
index.js

32:47.500 --> 32:49.500
再去请求这个页面的时候

32:49.500 --> 32:51.500
拿到页面结果一看

32:51.500 --> 32:52.500
还是这两个GS

32:52.500 --> 32:54.500
它发现文件明没有变

32:54.500 --> 32:56.500
它发现了我的缓存里边有

32:56.500 --> 32:58.500
于是它就不再去请求了

32:58.500 --> 33:00.500
其实要不要请求

33:00.500 --> 33:02.500
有的时候还是要去请求一次

33:02.500 --> 33:04.500
这个东西跟浏览器配置有关系

33:04.500 --> 33:06.500
还跟服务器那边配置有关系

33:06.500 --> 33:08.500
这个东西要说起来还蛮复杂的

33:08.500 --> 33:10.500
不过我们现在没有想服务器

33:10.500 --> 33:11.500
不用去过多研究

33:11.500 --> 33:12.500
那么现在我们只需要

33:12.500 --> 33:13.500
知道一个现象

33:13.500 --> 33:15.500
就是它有可能会使用缓存

33:15.500 --> 33:17.500
不再去请求了

33:17.500 --> 33:18.500
有可能会使用缓存

33:18.500 --> 33:20.500
那么就造成了一个什么样的结果

33:20.500 --> 33:22.500
就是后面我们使用的那个页面

33:22.500 --> 33:23.500
它都用来去

33:23.500 --> 33:24.500
内部都用的是缓存

33:25.500 --> 33:26.500
就会造成一个什么样的结果

33:26.500 --> 33:27.500
有一天

33:27.500 --> 33:29.500
我们这个src

33:30.500 --> 33:31.500
内容变了

33:32.500 --> 33:33.500
看着

33:33.500 --> 33:34.500
我们输出了一个

33:36.500 --> 33:38.500
现在我们再打包

33:38.500 --> 33:41.700
再打包

33:42.700 --> 33:43.700
内容是不是变了

33:43.700 --> 33:44.700
对吧

33:44.700 --> 33:46.700
打包了结果里边

33:46.700 --> 33:47.700
肯定是变了

33:47.700 --> 33:48.700
输出

33:48.700 --> 33:49.700
对吧

33:49.700 --> 33:50.700
变了过后

33:50.700 --> 33:51.700
我再把这个东西

33:51.700 --> 33:52.700
上传到服务器

33:52.700 --> 33:53.700
再把这个文件夹里边的东西

33:53.700 --> 33:54.700
上传到服务器

33:54.700 --> 33:55.700
但是

33:55.700 --> 33:56.700
由于浏览器

33:56.700 --> 33:58.700
它有这两个介石的缓存

33:58.700 --> 34:00.700
就会造成一个问题

34:00.700 --> 34:02.700
虽然说我的服务器的代码更新了

34:02.700 --> 34:03.700
但是浏览器

34:03.700 --> 34:04.700
能不能应用到新的代码

34:04.700 --> 34:05.700
用不到

34:05.700 --> 34:06.700
因为它还是用的是

34:06.700 --> 34:08.700
之前的缓存结果

34:08.700 --> 34:09.700
听懂这个意思吗

34:10.700 --> 34:11.700
听懂这个意思吗

34:11.700 --> 34:12.700
所以说

34:12.700 --> 34:14.700
我们这里必须要想个办法

34:15.700 --> 34:17.700
当我们文件更新了之后

34:17.700 --> 34:20.700
我要让它的文件名发生变化

34:21.700 --> 34:23.700
我要让它的文件名发生变化

34:23.700 --> 34:25.700
那么文件名发生变化了之后

34:25.700 --> 34:28.700
浏览器就造缓存就造失败了

34:28.700 --> 34:30.700
那么它就会应用新的东西

34:30.700 --> 34:32.700
那么我们怎么来让文件名

34:32.700 --> 34:35.700
根据我们的内容改变

34:35.700 --> 34:36.700
而发生变化了

34:36.700 --> 34:37.700
这就要用到哈希了

34:37.700 --> 34:40.700
因为哈希是在好不过的方式了

34:40.700 --> 34:42.700
哈希 我们这里记录一下

34:43.700 --> 34:47.700
通常用于解决缓存问题

34:48.700 --> 34:49.700
为什么呢

34:49.700 --> 34:51.700
因为哈希是怎么来生成出来的

34:51.700 --> 34:53.700
就是根据文件内容生成出来的

34:53.700 --> 34:54.700
文件内容一变

34:54.700 --> 34:55.700
它就会跟着变

34:55.700 --> 34:56.700
文件内容不变

34:56.700 --> 34:57.700
它就不变

34:57.700 --> 34:58.700
它就有这么一个好处

34:58.700 --> 35:00.700
所以说我们在这里

35:00.700 --> 35:01.700
可以使用一个哈希

35:02.700 --> 35:03.700
比方说我们一般会怎么写

35:03.700 --> 35:04.700
那横杆

35:04.700 --> 35:06.700
后边哈希

35:06.700 --> 35:07.700
当然这个横杆

35:07.700 --> 35:08.700
要不要写随便

35:08.700 --> 35:09.700
或者是点也行

35:09.700 --> 35:10.700
或者是中间随便写什么

35:10.700 --> 35:11.700
无所谓

35:11.700 --> 35:13.700
总之一个站位服恶意

35:13.700 --> 35:14.700
一个站位服恶意

35:14.700 --> 35:15.700
我们用横杆

35:15.700 --> 35:17.700
或者用点也行

35:17.700 --> 35:19.700
那么我们这样子来生成

35:19.700 --> 35:22.020
接下来我们看一下

35:22.020 --> 35:25.460
把这个两个GSE删掉

35:26.460 --> 35:27.460
运行

35:28.460 --> 35:29.460
你看

35:29.460 --> 35:31.460
是不是生成了两个GSE

35:31.460 --> 35:32.460
而这两个GSE的哈希值

35:32.460 --> 35:34.460
你看是不是总的哈希值

35:34.460 --> 35:35.460
对吧

35:35.460 --> 35:36.460
所以总的哈希值

35:36.460 --> 35:38.460
就这个哈希值

35:38.460 --> 35:40.460
那么你看到

35:40.460 --> 35:41.460
看到没

35:41.460 --> 35:42.460
那么现在这个页面上

35:43.460 --> 35:44.460
引用的是

35:45.460 --> 35:46.460
点这个GSE

35:46.460 --> 35:47.460
然后

35:48.460 --> 35:49.460
点这个GSE

35:50.460 --> 35:51.460
没问题吧

35:51.460 --> 35:52.460
引用这两个GSE

35:52.460 --> 35:53.460
好

35:53.460 --> 35:54.460
我们来看

35:55.460 --> 35:57.460
那么只要文件内容

35:57.460 --> 35:58.460
没有变

35:58.460 --> 35:59.460
我再重新打包一次

36:01.460 --> 36:02.460
只要文件内容没变

36:02.460 --> 36:04.460
你看哈希值变没

36:04.460 --> 36:05.460
是不是还是没变

36:05.460 --> 36:06.460
你看这个文件

36:06.460 --> 36:07.460
有没有多多文件出来

36:07.460 --> 36:08.460
没有吧

36:08.460 --> 36:09.460
哈希值没变

36:09.460 --> 36:10.460
那么这样子

36:10.460 --> 36:11.460
浏览器是不是就用到

36:11.460 --> 36:12.460
还是用的是缓存

36:12.460 --> 36:13.460
对吧

36:13.460 --> 36:14.460
因为你没变

36:14.460 --> 36:15.460
没变我就用缓存

36:15.460 --> 36:16.460
浏览器用的是怎么缓存

36:16.460 --> 36:18.460
浏览器用的

36:18.460 --> 36:19.460
浏览器用的是这两个

36:19.460 --> 36:20.460
一个是这个

36:21.460 --> 36:23.460
浏览器缓存的是这个

36:24.460 --> 36:25.460
还有一个是这个

36:25.460 --> 36:28.730
所以缓存的是这个

36:29.730 --> 36:30.730
有没有重新打包之后

36:30.730 --> 36:31.730
文件内容没变

36:31.730 --> 36:32.730
是不是浏览器

36:32.730 --> 36:34.730
直接使用之前的缓存优称了

36:34.730 --> 36:35.730
对吧

36:35.730 --> 36:36.730
直接使用之前的缓存

36:37.730 --> 36:39.730
直接使用之前的缓存优称了

36:40.730 --> 36:41.730
那么有一天

36:41.730 --> 36:42.730
内容变了呢

36:42.730 --> 36:43.730
比方说我这里加上一个E

36:44.730 --> 36:45.730
你想啊

36:45.730 --> 36:46.730
文件内容变了

36:46.730 --> 36:47.730
是不是哈希就一定变了

36:47.730 --> 36:48.730
对吧

36:48.730 --> 36:49.730
总哈希就一定变了

36:49.730 --> 36:50.730
我们现在再来打包

36:50.730 --> 36:54.320
派克

36:55.320 --> 36:56.320
好你看

36:56.320 --> 36:57.320
是不是多了两个文件

36:58.320 --> 36:59.320
多了这两个文件

36:59.320 --> 37:00.320
对吧

37:00.320 --> 37:01.320
总哈希是不是变了

37:01.320 --> 37:02.320
那么我们之前的文件

37:02.320 --> 37:03.320
是不是用不到了

37:03.320 --> 37:04.320
用不到了

37:04.320 --> 37:05.320
我们就要引去

37:05.320 --> 37:06.320
引用新的文件了

37:06.320 --> 37:07.320
对吧

37:07.320 --> 37:08.320
引用新的文件了

37:08.320 --> 37:09.320
当然这些东西

37:09.320 --> 37:10.320
我觉得手动改起来很麻烦

37:10.320 --> 37:11.320
对吧

37:11.320 --> 37:12.320
以后我们有办法解决

37:12.320 --> 37:13.320
手动改起来很麻烦

37:13.320 --> 37:14.320
不过呢

37:14.320 --> 37:15.320
我们是不是可以引用新的文件了

37:15.320 --> 37:16.320
对不对

37:16.320 --> 37:17.320
好了

37:17.320 --> 37:18.320
那么这个文件名发生变化了

37:18.320 --> 37:19.320
那么现在瀏覽器

37:20.320 --> 37:22.320
看一下能不能还能不能使用缓存

37:22.320 --> 37:24.320
他再去寢求这个英那个社

37:24.320 --> 37:25.320
再去寢求英那个社页面

37:25.320 --> 37:26.320
他发现这个页面里面

37:26.320 --> 37:28.320
根本没有用以前的那个解释文件了

37:28.320 --> 37:29.320
用的是这两个

37:29.320 --> 37:31.320
而这两个有没有缓存

37:32.320 --> 37:33.320
而这两个文件有没有缓存

37:33.320 --> 37:34.320
在瀏覽器里面

37:34.320 --> 37:36.320
是没有瀏覽器缓存出的这个东西

37:36.320 --> 37:37.320
找不到缓存

37:37.320 --> 37:40.320
因此他要去重新寢求新的

37:40.320 --> 37:42.320
需要重新寢求新的

37:42.320 --> 37:43.320
就是新的了

37:43.320 --> 37:44.320
就不行了

37:44.320 --> 37:45.320
就新的了

37:45.320 --> 37:47.320
然后再把新的缓存起来

37:47.320 --> 37:48.320
就这么一个意思

37:48.320 --> 37:49.320
所以说这个东西就是

37:49.320 --> 37:51.320
为了解决缓存的问题

37:51.320 --> 37:52.320
当然现在我们是

37:52.320 --> 37:54.320
这一代我们要手动的

37:54.320 --> 37:55.320
在页面里面去引用

37:55.320 --> 37:56.320
就特别麻烦

37:56.320 --> 37:57.320
而且之前的东西还在

37:57.320 --> 37:58.320
没有清楚

37:58.320 --> 38:00.320
这些问题我们以后都会得到解决的

38:00.320 --> 38:01.320
不用担心

38:01.320 --> 38:02.320
那么现在我们主要是

38:02.320 --> 38:06.320
你要理解哈希是用来解决缓存问题的

38:06.320 --> 38:07.320
好

38:07.320 --> 38:08.320
那么这是官员哈希

38:08.320 --> 38:10.320
那么哈希太长了

38:10.320 --> 38:11.320
这个文件很丑陋

38:11.320 --> 38:13.320
很难看

38:13.320 --> 38:15.320
其实我们一般来说的话

38:15.320 --> 38:17.320
哈希不需要这么长

38:17.320 --> 38:18.320
哈希不需要这么长

38:18.320 --> 38:21.320
我们取哈希的值的前几位就可以了

38:21.320 --> 38:23.320
那么这个东西怎么做呢

38:23.320 --> 38:24.320
实际上它的规则里

38:24.320 --> 38:26.320
后边可以跟上一个冒号

38:26.320 --> 38:28.320
冒号后边可以写上一个数字

38:28.320 --> 38:31.320
这个数字表示取几位

38:31.320 --> 38:32.320
取几位

38:32.320 --> 38:33.320
比方我们写个5

38:33.320 --> 38:35.320
写个5

38:35.320 --> 38:38.460
看一下

38:38.460 --> 38:42.220
可以删除的

38:42.220 --> 38:45.750
然后我们再来运行

38:45.750 --> 38:47.750
因为发现它生存的文件你看了没

38:47.750 --> 38:48.750
是不是就简洁很多了

38:48.750 --> 38:50.750
它这个哈希是不是只取了前5位

38:50.750 --> 38:51.750
只取了前5位

38:51.750 --> 38:53.750
它不需要取那么多

38:53.750 --> 38:54.750
因为这个哈希值的

38:54.750 --> 38:55.750
不是说你改少一点

38:55.750 --> 38:57.750
它都变弄少一点

38:57.750 --> 38:58.750
完全不一样的

38:58.750 --> 39:00.750
因为哈希算法的特点就是

39:00.750 --> 39:02.750
哪怕你改一丁点的地方

39:02.750 --> 39:05.750
它整个哈希值会变化很大

39:05.750 --> 39:07.750
所以说你不用去担心

39:07.750 --> 39:08.750
有重复

39:08.750 --> 39:10.750
哈希值不用太担心有重复

39:10.750 --> 39:11.750
OK

39:11.750 --> 39:12.750
那么这里是不是可以

39:12.750 --> 39:14.750
就非常简洁的这两个文件

39:14.750 --> 39:15.750
哈希值

39:15.750 --> 39:16.750
那么哈希值就可以反映

39:16.750 --> 39:17.750
这个文件内容

39:17.750 --> 39:18.750
它到底没有变化

39:18.750 --> 39:21.750
它就反映了文件内容的变化

39:21.750 --> 39:22.750
好

39:22.750 --> 39:23.750
那么注意

39:23.750 --> 39:24.750
这种写法

39:24.750 --> 39:25.750
我们使用这种哈希

39:25.750 --> 39:26.750
指的是总的哈希

39:26.750 --> 39:28.750
总的资源哈希

39:28.750 --> 39:30.750
总的资源哈希是什么意思呢

39:30.750 --> 39:32.750
总的资源哈希

39:32.750 --> 39:33.750
它的特点就是

39:33.750 --> 39:34.750
一变

39:34.750 --> 39:35.750
全部都变

39:35.750 --> 39:36.750
因为我A变了

39:36.750 --> 39:37.750
是不是总的资源

39:37.750 --> 39:39.750
所有的内容加起来也跟着变了

39:39.750 --> 39:40.750
对不对

39:40.750 --> 39:41.750
因此

39:41.750 --> 39:43.750
它每一个所有的哈希都会变

39:43.750 --> 39:44.750
A变了

39:44.750 --> 39:45.750
你看

39:45.750 --> 39:46.750
Mate也会跟着变

39:46.750 --> 39:47.750
之前我们都看到过

39:47.750 --> 39:48.750
它是用了总的哈希

39:48.750 --> 39:49.750
那么这里

39:49.750 --> 39:52.750
能不能用每一个创可的哈希呢

39:52.750 --> 39:53.750
可以

39:53.750 --> 39:54.750
我们看一下这张图

39:54.750 --> 39:56.750
每一个创可里面不是有哈希吗

39:56.750 --> 39:58.750
它是各自创可里面的哈希

39:58.750 --> 39:59.750
能不能用这个呢

39:59.750 --> 40:00.750
让每一个创可的哈希

40:00.750 --> 40:01.750
互不干扰

40:01.750 --> 40:02.750
可不可以呢

40:02.750 --> 40:03.750
可以

40:03.750 --> 40:04.750
那么这里还有另外一个

40:04.750 --> 40:06.750
就是创可哈希

40:06.750 --> 40:07.750
创可哈希

40:07.750 --> 40:09.750
使用

40:09.750 --> 40:10.750
创可哈希

40:10.750 --> 40:11.750
就是创可哈希

40:11.750 --> 40:12.750
这个没什么好解释的

40:12.750 --> 40:13.750
好

40:13.750 --> 40:14.750
那么这里呢

40:14.750 --> 40:15.750
我们就比方说

40:15.750 --> 40:16.750
我们这里使用

40:16.750 --> 40:17.750
创

40:17.750 --> 40:18.750
哈希

40:18.750 --> 40:24.520
好

40:24.520 --> 40:25.520
我们再来看一下

40:25.520 --> 40:26.520
好

40:26.520 --> 40:27.520
OK

40:27.520 --> 40:28.520
影响

40:28.520 --> 40:29.520
创可哈希

40:29.520 --> 40:30.520
你看

40:30.520 --> 40:31.520
是不是两个就不一样了

40:31.520 --> 40:32.520
它就不再是用了总的哈希

40:32.520 --> 40:33.520
只了

40:33.520 --> 40:35.520
而是每一个创可里面的哈希

40:35.520 --> 40:36.520
那么这样做有什么好处呢

40:36.520 --> 40:37.520
大家看一下

40:37.520 --> 40:38.520
好处在于

40:38.520 --> 40:40.520
用了创可哈希过后呢

40:40.520 --> 40:42.520
它变化不是全部变

40:42.520 --> 40:44.520
它只变化了一个创可里面

40:44.520 --> 40:45.520
如果说某一个创可变了

40:45.520 --> 40:46.520
里面的东西变了

40:46.520 --> 40:48.520
它变成创可里面的东西

40:48.520 --> 40:49.520
你看一下就行了

40:49.520 --> 40:51.520
比方说A掉接S

40:51.520 --> 40:52.520
这样子写了

40:52.520 --> 40:53.520
是不是A掉接S变了

40:53.520 --> 40:54.520
对吧

40:54.520 --> 40:56.520
那么它会影响哪个创可

40:56.520 --> 40:58.520
是不是影响A那个创可

40:58.520 --> 41:00.520
影响到A的这个创可

41:00.520 --> 41:04.280
创可名字是随便取的

41:04.280 --> 41:06.280
运行

41:06.280 --> 41:07.280
你会发现

41:07.280 --> 41:08.280
是不是只有A变了

41:08.280 --> 41:09.280
这个没变没变

41:09.280 --> 41:11.280
没这个创可它并没有变

41:11.280 --> 41:12.280
因为没这个创可里面

41:12.280 --> 41:14.280
它跟A没有关系

41:14.280 --> 41:16.280
跟A是没有关系的

41:16.280 --> 41:17.280
听懂这个意思吗

41:17.280 --> 41:19.280
我们这就和先学新理论

41:19.280 --> 41:20.280
先学新理论

41:20.280 --> 41:22.280
我们下集可能再来说一下

41:22.280 --> 41:23.280
入口和出口配置

41:23.280 --> 41:25.280
跟我们实际开发中

41:25.280 --> 41:27.280
会怎么样应用

41:27.280 --> 41:29.280
我们这就和先学新理论

41:29.280 --> 41:30.280
OK

41:30.280 --> 41:31.280
那么这里呢

41:31.280 --> 41:32.280
是不是也跟那边了

41:32.280 --> 41:34.280
都是关于这个

41:34.280 --> 41:36.280
这里的配置

41:36.280 --> 41:37.280
好 接下来我们再说一个

41:37.280 --> 41:39.280
接下来的东西

41:39.280 --> 41:40.280
也挺有意思的

41:40.280 --> 41:41.280
虽然我们用的并不多

41:41.280 --> 41:43.280
也挺有意思的

41:43.280 --> 41:45.280
就什么呢

41:45.280 --> 41:46.280
就是说我们这里呢

41:46.280 --> 41:48.280
除了配置多个创可之外

41:48.280 --> 41:50.280
我们这几颗先学学习这个知识

41:50.280 --> 41:51.280
下几颗再来说

41:51.280 --> 41:53.280
具体怎么去应用

41:53.280 --> 41:55.280
我们除了配置多个创可之外

41:55.280 --> 41:57.280
我们还有一种做法

41:57.280 --> 41:59.280
就特别有意思的

41:59.280 --> 42:01.280
还有一种做法是

42:01.280 --> 42:03.280
我们可以配置

42:03.280 --> 42:07.280
一个创可下标的多个文件

42:07.280 --> 42:09.280
多个入口

42:09.280 --> 42:10.280
入口模块

42:10.280 --> 42:12.280
什么意思呢

42:12.280 --> 42:14.280
看着

42:14.280 --> 42:15.280
我们在in那个设里面

42:15.280 --> 42:17.280
出出in那个设

42:17.280 --> 42:20.280
在a里面出出a

42:20.280 --> 42:23.360
OK

42:23.360 --> 42:24.360
可以上了

42:24.360 --> 42:26.360
现在我们这样子

42:26.360 --> 42:28.360
我把这个a呢

42:28.360 --> 42:30.360
给它变成一个数组

42:30.360 --> 42:32.360
它还可以是一个数组

42:32.360 --> 42:33.360
这个数组里面

42:33.360 --> 42:36.360
我们可以再写一个src in这个设

42:36.360 --> 42:37.360
你先别管这一样子

42:37.360 --> 42:38.360
有什么意义

42:38.360 --> 42:39.360
我们解释清楚

42:39.360 --> 42:41.360
这个是什么意思就行了

42:41.360 --> 42:42.360
那么这样子

42:42.360 --> 42:44.360
会做出一个什么效果呢

42:44.360 --> 42:45.360
一个创可里面

42:45.360 --> 42:46.360
它比以前

42:46.360 --> 42:47.360
是不是只有一个

42:47.360 --> 42:49.360
从一个入口模块开始

42:49.360 --> 42:50.360
来找

42:50.360 --> 42:51.360
找它的什么

42:51.360 --> 42:52.360
找它的就是

42:52.360 --> 42:54.360
依赖关系

42:54.360 --> 42:55.360
是不是通过一个入口模块

42:55.360 --> 42:57.360
来找它的依赖关系

42:57.360 --> 42:58.360
那么现在

42:58.360 --> 42:59.360
一个创可

42:59.360 --> 43:00.360
你这样的配置

43:00.360 --> 43:01.360
成一个数组过后呢

43:01.360 --> 43:02.360
有可能的

43:02.360 --> 43:03.360
它就会造成这个创可里面

43:03.360 --> 43:05.360
有两个入口模块

43:05.360 --> 43:07.360
通过两个入口模块

43:07.360 --> 43:09.360
来找到一个模块列表

43:09.360 --> 43:10.360
比方说你看

43:10.360 --> 43:12.360
因为这个a没有一代其他东西

43:12.360 --> 43:13.360
in那个是没有一代其他东西

43:13.360 --> 43:14.360
那么这样子

43:14.360 --> 43:15.360
非常简单

43:15.360 --> 43:16.360
出来了a的这个创可里面

43:16.360 --> 43:17.360
模块列表

43:17.360 --> 43:18.360
是不是就一个a

43:18.360 --> 43:19.360
一个in那个是

43:19.360 --> 43:20.360
有两个模块

43:20.360 --> 43:21.360
而且这两个模块

43:21.360 --> 43:22.360
都是出于

43:22.360 --> 43:24.360
都是启动模块

43:24.360 --> 43:27.360
启动模块

43:27.360 --> 43:28.360
有两个

43:28.360 --> 43:29.360
有两个

43:29.360 --> 43:31.360
咱们来打包看一下

43:31.360 --> 43:32.360
首先问大家一个问题

43:32.360 --> 43:33.360
那么有两个启动模块

43:33.360 --> 43:35.360
它生成出来的就是

43:35.360 --> 43:36.360
合并出来代码

43:36.360 --> 43:37.360
就是它模块

43:37.360 --> 43:39.360
列表里面有两个启动模块

43:39.360 --> 43:41.360
那么它合并出来的就是

43:41.360 --> 43:42.360
资源

43:42.360 --> 43:43.360
我们只看介石

43:43.360 --> 43:45.360
什么map就不用管了

43:45.360 --> 43:46.360
那么合并出来的介石

43:46.360 --> 43:49.440
有几个

43:49.440 --> 43:50.440
合并出来的介石

43:50.440 --> 43:51.440
考验你们之前

43:51.440 --> 43:52.440
对之前的

43:52.440 --> 43:54.440
原力的理解程度

43:54.440 --> 43:55.440
有几个

43:55.440 --> 43:57.440
说还有一个

43:57.440 --> 43:58.440
还是只有一个

43:58.440 --> 43:59.440
为什么呢

43:59.440 --> 44:00.440
为什么还是只有一个呢

44:00.440 --> 44:02.440
因为它只是通过这个入口

44:02.440 --> 44:03.440
去找一代关系

44:03.440 --> 44:05.440
把你找出一个模块列表

44:05.440 --> 44:06.440
那么找出一个模块列表

44:06.440 --> 44:07.440
一下子全部把

44:07.440 --> 44:08.440
合并到一个模块里面去

44:08.440 --> 44:10.440
它只做这么一件事

44:10.440 --> 44:11.440
所以说有几个模块

44:11.440 --> 44:12.440
都无所谓

44:12.440 --> 44:13.440
有几个入口模块

44:13.440 --> 44:14.440
只是

44:14.440 --> 44:15.440
让它找的可能

44:15.440 --> 44:16.440
范围更广的一点

44:16.440 --> 44:17.440
对吧

44:17.440 --> 44:18.440
让它生成的模块列表

44:18.440 --> 44:19.440
更多的一点

44:19.440 --> 44:21.440
只不过是有这么一个

44:21.440 --> 44:22.440
现象

44:22.440 --> 44:23.440
并不会影响它

44:23.440 --> 44:24.440
最多生成的介石

44:24.440 --> 44:25.440
我们也只有一个

44:25.440 --> 44:26.440
并不会影响这个规则

44:26.440 --> 44:27.440
所以说

44:27.440 --> 44:28.440
把这个东西理解到过后

44:28.440 --> 44:30.440
它跟这个出口配置

44:30.440 --> 44:31.440
有没有关系

44:31.440 --> 44:32.440
没有什么关系

44:32.440 --> 44:36.140
跟这个wap

44:38.140 --> 44:40.140
还是有两个文件

44:40.140 --> 44:41.140
但是我们看一下

44:41.140 --> 44:43.140
A条介石就有意思的

44:43.140 --> 44:44.140
因为它有两个入口模块

44:44.140 --> 44:45.140
不可模块

44:45.140 --> 44:46.140
因此

44:46.140 --> 44:47.140
它做了这么一件

44:47.140 --> 44:48.140
一种处理

44:49.140 --> 44:50.140
它做了这么一种处理

44:50.140 --> 44:52.140
就是在这里

44:52.140 --> 44:54.140
什么处理呢

44:54.140 --> 44:55.140
我们这样吧

44:55.140 --> 44:56.140
我们这样子

44:56.140 --> 44:58.140
用这个遗忘看不太清楚

44:58.140 --> 44:59.140
我们用dev2

44:59.140 --> 45:00.140
把这个加上

45:00.140 --> 45:04.220
这样看得清楚一点

45:04.220 --> 45:09.130
你看就明白了

45:09.130 --> 45:10.130
那么这里

45:10.130 --> 45:11.130
就是A条介石

45:11.130 --> 45:14.140
现在再看

45:14.140 --> 45:16.140
它做了什么处理

45:16.140 --> 45:18.140
它要先去运行A条介石

45:18.140 --> 45:20.140
然后再去运行

45:20.140 --> 45:21.140
这个导书不用看了

45:21.140 --> 45:22.140
它先去运行A条介石

45:22.140 --> 45:24.140
再去运行Index的介石

45:24.140 --> 45:26.140
所以两个介石都要运行

45:26.140 --> 45:28.140
而且运行的顺序

45:28.140 --> 45:30.140
跟这边的顺序是不一样的

45:30.140 --> 45:31.140
说明什么

45:31.140 --> 45:32.140
怎么来理解这个东西

45:32.140 --> 45:34.140
就表示我这个创渴里边

45:34.140 --> 45:35.140
打不出来的结果

45:35.140 --> 45:36.140
要同时运行

45:36.140 --> 45:37.140
我们原码里边

45:37.140 --> 45:39.140
两个介石文件都要运行

45:39.140 --> 45:40.140
因为启动楼会有两个

45:40.140 --> 45:41.140
两个都要运行

45:41.140 --> 45:42.140
所以说

45:42.140 --> 45:43.140
如果说你用一个页面

45:43.140 --> 45:45.140
在这里写个页面

45:45.140 --> 45:46.140
index

45:47.140 --> 45:48.140
有

45:48.140 --> 45:50.140
这里我们找到A

45:50.140 --> 45:53.970
然后找到Mate

45:53.970 --> 45:54.970
不用Mate了

45:54.970 --> 45:55.970
Mate我们不需要

45:55.970 --> 45:56.970
我们找到A这个模块

45:56.970 --> 46:00.690
运行

46:00.690 --> 46:01.690
它应该只用了一个介石

46:01.690 --> 46:02.690
你看是不是两个都输出了

46:02.690 --> 46:03.690
输出了A

46:03.690 --> 46:04.690
输出了Index

46:05.690 --> 46:06.690
就这么个意思

46:08.690 --> 46:09.690
这是

46:09.690 --> 46:11.690
它用这种方式来进行处理

46:13.690 --> 46:14.690
你要说这个东西

46:14.690 --> 46:15.690
特别不常见

46:15.690 --> 46:16.690
它有的时候

46:16.690 --> 46:17.690
还只要有这样子用

46:17.690 --> 46:18.690
我们下个头就会举例子

46:19.690 --> 46:20.690
OK

46:20.690 --> 46:22.690
这几个我们就介绍了入口和出口

46:22.690 --> 46:23.690
就这么一些规则了

46:23.690 --> 46:25.690
你再多就没了

46:26.690 --> 46:27.690
然后

46:27.690 --> 46:29.690
还有一个小的点

46:29.690 --> 46:30.690
就是这个规则里边

46:30.690 --> 46:31.690
还有一个东西就是ID

46:31.690 --> 46:32.690
使用创口ID

46:33.690 --> 46:34.690
建议不要用这个东西

46:34.690 --> 46:35.690
建议不用

46:35.690 --> 46:36.690
不推荐

46:36.690 --> 46:37.690
为什么不推荐呢

46:37.690 --> 46:38.690
因为我们说过

46:38.690 --> 46:39.690
这个创口ID

46:39.690 --> 46:41.690
如果说你用ID

46:41.690 --> 46:42.690
用那个创口ID

46:42.690 --> 46:44.690
它有一个很诡异的现象

46:44.690 --> 46:45.690
就是

46:45.690 --> 46:46.690
以开发模式

46:46.690 --> 46:47.690
它的ID是名字

46:48.690 --> 46:49.690
生产环境的

46:49.690 --> 46:50.690
它是一个数字

46:50.690 --> 46:52.690
就是你会导致生产环境

46:52.690 --> 46:54.690
跟那个开发环境的不一致

46:54.690 --> 46:55.690
我们这里改通过了

46:55.690 --> 46:56.690
对吧

46:56.690 --> 46:57.690
OK

46:57.690 --> 47:00.510
我们这里重新来一次

47:00.510 --> 47:06.730
相处

47:06.730 --> 47:07.730
好看一下

47:08.730 --> 47:09.730
你看

47:09.730 --> 47:10.730
这是

47:10.730 --> 47:11.730
开发环境

47:11.730 --> 47:12.730
对吧

47:12.730 --> 47:13.730
开发环境

47:13.730 --> 47:14.730
然后呢

47:14.730 --> 47:15.730
我们再来看生产环境

47:17.730 --> 47:18.730
PRODUCTION

47:18.730 --> 47:19.730
生产环境

47:28.890 --> 47:29.890
你看一下

47:29.890 --> 47:30.890
是不是变成数字了

47:30.890 --> 47:31.890
对吧

47:31.890 --> 47:32.890
变成数字了

47:32.890 --> 47:33.890
因此呢

47:33.890 --> 47:34.890
不一样

47:34.890 --> 47:35.890
不一样

47:35.890 --> 47:36.890
好

47:36.890 --> 47:37.890
那么这里呢

47:37.890 --> 47:38.890
可能有些人可以问

47:38.890 --> 47:39.890
你不是用创口RC吗

47:39.890 --> 47:40.890
创口RC这里边没有变动

47:40.890 --> 47:42.890
每个创口没有变动

47:42.890 --> 47:43.890
就说一说

47:43.890 --> 47:45.890
我们之前讲原理那一块

47:45.890 --> 47:46.890
它只能简化了讲

47:46.890 --> 47:48.890
不能沾往什么讲了

47:48.890 --> 47:50.890
实际上真实的情况是什么呢

47:50.890 --> 47:51.890
这个RC值得运算

47:51.890 --> 47:53.890
它还不光要根据这个资源

47:53.890 --> 47:55.890
还要根据一些其他东西

47:55.890 --> 47:56.890
还要根据一些其他东西

47:56.890 --> 47:57.890
所以这个

47:57.890 --> 47:58.890
还要跟我们配置文件

47:58.890 --> 47:59.890
都还有一些关系

47:59.890 --> 48:00.890
因此

48:00.890 --> 48:02.890
我们这也不用去过多深究

48:02.890 --> 48:03.890
不过你们只要知道

48:03.890 --> 48:04.890
这个创口RC

48:04.890 --> 48:05.890
它反映的是

48:05.890 --> 48:06.890
创口的内容变化就行了

48:06.890 --> 48:08.890
只要你配置和写好了

48:08.890 --> 48:09.890
不要去做其他地方的改动

48:09.890 --> 48:11.890
那么我们的创口RC

48:11.890 --> 48:12.890
就表示的是

48:12.890 --> 48:14.890
根据创口文件的内容方式变化

48:14.890 --> 48:16.890
OK 这是关于

48:16.890 --> 48:18.890
咱们这里可讲的东西

48:18.890 --> 48:19.890
一个是入口

48:19.890 --> 48:20.890
一个是出口

48:20.890 --> 48:21.890
没了

48:21.890 --> 48:22.890
没了

48:22.890 --> 48:24.890
OK 那么这些东西

48:24.890 --> 48:26.890
我们感觉很繁琐的吧

48:26.890 --> 48:27.890
有很多的规则

48:27.890 --> 48:28.890
那么凭什么开发的时候

48:28.890 --> 48:29.890
到底该怎么去配呢

48:29.890 --> 48:31.890
用哪种方式配比较好呢

48:31.890 --> 48:33.890
有没有什么最佳时间呢

48:33.890 --> 48:34.890
我们下期可就来讲一讲

48:34.890 --> 48:36.890
用一个实际的例子来讲一讲

48:36.890 --> 48:38.890
NTRE 和OUTPUT

48:38.890 --> 48:40.890
那么具体该怎么去配置

48:40.890 --> 48:42.890
举一些例子来讲一讲

