WEBVTT

00:01.390 --> 00:03.390
上课了

00:03.390 --> 00:07.390
有的时候我真的会发现

00:07.390 --> 00:10.390
你要把课讲好的话

00:10.390 --> 00:14.390
光技术过关还真不够

00:14.390 --> 00:16.390
你还要去思考很多东西

00:16.390 --> 00:18.390
像我这个课

00:18.390 --> 00:20.390
微派的课是真不好讲

00:20.390 --> 00:22.390
大家可能觉得

00:22.390 --> 00:25.390
我这个课不是讲得挺随意吗

00:25.390 --> 00:27.390
我们讲了多少节课了

00:27.390 --> 00:28.390
七节课了

00:28.390 --> 00:31.390
里边好像一会来一点

00:31.390 --> 00:32.390
讲完编译结果

00:32.390 --> 00:33.390
又讲配置文件

00:33.390 --> 00:34.390
又讲Dev2

00:34.390 --> 00:35.390
好像是挺随意的

00:35.390 --> 00:38.390
实际上大家可能感受不到

00:38.390 --> 00:39.390
这个顺序

00:39.390 --> 00:41.390
我是经过了多少的心思

00:41.390 --> 00:44.390
才给大家用这种顺序来讲的

00:44.390 --> 00:47.390
这种顺序安排我都是有考量的

00:47.390 --> 00:48.390
包括这节课

00:48.390 --> 00:50.390
这节课咱们讲微派课的编译过程

00:50.390 --> 00:51.390
那为什么放这节课呢

00:51.390 --> 00:52.390
为什么不之前

00:52.390 --> 00:54.390
在前一年讲的

00:54.390 --> 00:56.390
那都是没办法的事情

00:56.390 --> 00:59.390
而且像这节课讲编译过程

00:59.390 --> 01:01.390
我到底是先讲完

01:01.390 --> 01:03.390
下节课我们要讲的入口和出口

01:03.390 --> 01:05.390
我到底是先讲入口和出口

01:05.390 --> 01:07.390
还是先讲编译过程

01:07.390 --> 01:09.390
我都是反复的去思考

01:09.390 --> 01:11.390
到底先讲哪一个好

01:11.390 --> 01:13.390
可能大家过几年

01:13.390 --> 01:14.390
工作了之后

01:14.390 --> 01:15.390
在回过头来看这个课

01:15.390 --> 01:16.390
你又知道了

01:16.390 --> 01:18.390
这里边其实花了很多的心思

01:18.390 --> 01:20.390
我讲课比较慢

01:20.390 --> 01:22.390
我也不知道大家能不能适应

01:22.390 --> 01:23.390
因为我想把每一个东西

01:23.390 --> 01:24.390
来讲清楚

01:24.390 --> 01:25.390
这一课咱们来学习

01:25.390 --> 01:27.390
这个微派课的编译过程

01:27.390 --> 01:29.390
为什么要学习这一块呢

01:29.390 --> 01:31.390
实际上呢不学

01:31.390 --> 01:33.390
他能不能用微派课

01:33.390 --> 01:34.390
能不能用他呢

01:34.390 --> 01:35.390
他也能用

01:35.390 --> 01:36.390
只不过呢

01:36.390 --> 01:37.390
如果说你不学的话

01:37.390 --> 01:38.390
对微派课里边的很多东西

01:38.390 --> 01:40.390
就感觉到莫名其妙的

01:40.390 --> 01:41.390
你不知道他怎么回事

01:41.390 --> 01:42.390
你对他的理解

01:42.390 --> 01:43.390
就没有那么的深刻

01:43.390 --> 01:45.390
什么叫做编译过程呢

01:45.390 --> 01:47.390
只要我们看一下这张图

01:47.390 --> 01:48.390
这张图呢

01:48.390 --> 01:49.390
就是微派课官网的

01:49.390 --> 01:50.390
给我们的这张图

01:50.390 --> 01:51.390
对吧

01:51.390 --> 01:52.390
我们经常在看

01:52.390 --> 01:53.390
那么这张图呢

01:53.390 --> 01:54.390
简单来说

01:54.390 --> 01:55.390
就是根据一个入口文件

01:55.390 --> 01:57.390
来进行打包

01:57.390 --> 01:58.390
打包

01:58.390 --> 02:00.390
成一个结果

02:00.390 --> 02:01.390
那么中间

02:01.390 --> 02:03.390
经过了微派课来打打包

02:03.390 --> 02:04.390
那么这个打包的过程呢

02:04.390 --> 02:06.390
我就把它叫做编译

02:06.390 --> 02:07.390
微派的作用呢

02:07.390 --> 02:09.390
他就是把我们的元代

02:09.390 --> 02:10.390
左边的元代

02:10.390 --> 02:12.390
把它打包成为最中代

02:12.390 --> 02:13.390
就是右边的最中代

02:13.390 --> 02:15.390
中间的过程就叫做编译

02:15.390 --> 02:16.390
我们也可以把它叫做构建

02:16.390 --> 02:17.390
也可以把它叫做打包

02:17.390 --> 02:19.390
是一个意思

02:19.390 --> 02:20.390
那么我们这里看了

02:20.390 --> 02:21.390
主要是来研究

02:21.390 --> 02:22.390
它中间到底经过了

02:22.390 --> 02:23.390
怎么样一个步骤

02:23.390 --> 02:25.390
它是怎么把我们的元代

02:25.390 --> 02:27.390
生成到最中代吧里边的

02:27.390 --> 02:28.390
这个过程呢

02:28.390 --> 02:30.390
我把它简化了一下

02:30.390 --> 02:31.390
因为它里边

02:31.390 --> 02:32.390
真实的过程

02:32.390 --> 02:34.390
实在是太过于复杂了

02:34.390 --> 02:35.390
那复杂度之前

02:35.390 --> 02:37.390
对对对初学者而言

02:37.390 --> 02:39.390
简直就突破天际了

02:39.390 --> 02:40.390
所以说呢

02:40.390 --> 02:42.390
我们我给大家简化了一下

02:42.390 --> 02:43.390
不过大家放心

02:43.390 --> 02:44.390
简化过后呢

02:44.390 --> 02:46.390
都已经能够

02:46.390 --> 02:49.390
应付99%的公司的面试了

02:49.390 --> 02:50.390
你再一声的话

02:50.390 --> 02:52.390
可能很多公司里面

02:52.390 --> 02:53.390
他们都没搞清楚了

02:53.390 --> 02:54.390
所以说呢

02:54.390 --> 02:56.390
我们也不用去研究的那么的声

02:56.390 --> 02:58.390
因为我们毕竟呢

02:58.390 --> 03:00.390
在Webhack这一块呢

03:00.390 --> 03:02.390
主要还是要测重于使用

03:02.390 --> 03:04.390
我们通过了解这个过程

03:04.390 --> 03:05.390
对它使用的时候呢

03:05.390 --> 03:06.390
它怎么去做的

03:06.390 --> 03:08.390
有了一个认识

03:08.390 --> 03:10.390
理解起来深刻一点

03:10.390 --> 03:12.390
这个过程大致贵

03:12.390 --> 03:13.390
分为三个步骤

03:13.390 --> 03:14.390
一个是初始化

03:14.390 --> 03:15.390
一个是编译

03:15.390 --> 03:17.390
第三个步骤就是初初

03:17.390 --> 03:19.390
我这里画一张简单的图

03:19.390 --> 03:20.390
对吧

03:20.390 --> 03:22.390
先初始化再编译再初出

03:22.390 --> 03:23.390
好

03:23.390 --> 03:25.390
那么这三个步骤完成了之后呢

03:25.390 --> 03:26.390
它就能够把我们的原代码

03:26.390 --> 03:28.390
打包成为最终代码

03:28.390 --> 03:29.390
我们一个一个看

03:29.390 --> 03:30.390
首先看初始化

03:30.390 --> 03:32.390
这个阶段是很简单的

03:32.390 --> 03:33.390
非常非常简单

03:33.390 --> 03:34.390
它做什么事呢

03:34.390 --> 03:36.390
因为我们用Webhack是怎么用的

03:36.390 --> 03:37.390
是不是运行个命令

03:37.390 --> 03:38.390
对吧

03:38.390 --> 03:40.390
运行个命令就是

03:40.390 --> 03:41.390
我们安装Webhack的时候

03:41.390 --> 03:43.390
安装了一个两个包嘛

03:43.390 --> 03:45.390
一个是Webhack本身的核心包

03:45.390 --> 03:46.390
这是什么呢

03:46.390 --> 03:47.390
Webhack City

03:47.390 --> 03:49.390
我们是通过这个Webhack City

03:49.390 --> 03:50.390
这里边根本

03:50.390 --> 03:52.390
就它给我们提供了一个命令

03:52.390 --> 03:53.390
什么命令呢

03:53.390 --> 03:55.390
就是Webhack命令

03:55.390 --> 03:57.390
Webhack命令

03:57.390 --> 03:58.390
那么通过这个命令呢

03:58.390 --> 03:59.390
来启动Webhack

03:59.390 --> 04:00.390
那么它里边

04:00.390 --> 04:01.390
这个命令里边做了什么事呢

04:01.390 --> 04:02.390
它其实就是

04:02.390 --> 04:03.390
调问核心包里边的功能

04:03.390 --> 04:05.390
核心包里边有很多对象

04:05.390 --> 04:06.390
构造函数

04:06.390 --> 04:07.390
那些八道的东西

04:07.390 --> 04:09.390
它也调用里边的功能

04:09.390 --> 04:10.390
那么首先

04:10.390 --> 04:12.390
它一开始要做的事情就是

04:12.390 --> 04:13.390
初始化

04:13.390 --> 04:14.390
怎么要初始化呢

04:14.390 --> 04:15.390
它做什么事呢

04:15.390 --> 04:17.390
它会将我们的CD参数

04:17.390 --> 04:18.390
什么叫CD参数

04:18.390 --> 04:19.390
就是我们运行

04:19.390 --> 04:20.390
这个Webhack命令的时候

04:20.390 --> 04:22.390
我们怎么运行的Webhack

04:22.390 --> 04:23.390
对吧

04:23.390 --> 04:25.390
后边是不是可以跟一些参数

04:25.390 --> 04:26.390
对吧

04:26.390 --> 04:27.390
那么这些东西呢

04:27.390 --> 04:28.390
就不行了

04:28.390 --> 04:29.390
就是参数

04:29.390 --> 04:30.390
甚至还可以跟配置文件

04:30.390 --> 04:31.390
对不对

04:31.390 --> 04:32.390
这些东西就是参数

04:32.390 --> 04:33.390
你看

04:33.390 --> 04:34.390
一个参数

04:34.390 --> 04:35.390
两个参数

04:35.390 --> 04:36.390
这就是参数

04:36.390 --> 04:37.390
那么这些东西是CD参数

04:37.390 --> 04:38.390
和什么呢

04:38.390 --> 04:40.390
和我们的配置文件

04:40.390 --> 04:41.390
就是我们在这里边

04:41.390 --> 04:43.390
比方说我们新建个文件

04:43.390 --> 04:45.390
Webhack

04:45.390 --> 04:46.390
叫Config

04:46.390 --> 04:47.390
叫JS

04:47.390 --> 04:48.390
这就是我们的配置文件

04:48.390 --> 04:49.390
对吧

04:49.390 --> 04:50.390
既然写到这了

04:50.390 --> 04:51.390
我们就顺便把它

04:51.390 --> 04:53.390
把它的环境搭一下吧

04:53.390 --> 04:54.390
搭一下这个环境

04:54.390 --> 04:56.390
首先

04:56.390 --> 05:00.390
npm init

05:00.390 --> 05:03.390
初始化一下

05:03.390 --> 05:05.390
反正它有个过程

05:05.390 --> 05:07.390
我们这里先把安装着

05:07.390 --> 05:08.390
一会儿呢

05:08.390 --> 05:10.390
它等一会儿才能安装完成

05:10.390 --> 05:12.390
让它安装吧

05:12.390 --> 05:14.390
不用管它了

05:14.390 --> 05:15.390
回到这

05:15.390 --> 05:16.390
那么还有我们的

05:16.390 --> 05:17.390
配置文件里面的配置

05:17.390 --> 05:18.390
因为你看

05:18.390 --> 05:19.390
我们配置文件里面

05:19.390 --> 05:20.390
是不是可以写一些配置

05:20.390 --> 05:21.390
marge your export

05:21.390 --> 05:23.390
可以在这里面去写一些配置

05:23.390 --> 05:24.390
那么它会把我们的

05:24.390 --> 05:25.390
CD参数配置文件

05:25.390 --> 05:26.390
已经呢

05:26.390 --> 05:28.390
我们没有用到的配置

05:28.390 --> 05:29.390
比方说

05:29.390 --> 05:30.390
我们很多都有默认值

05:30.390 --> 05:31.390
比方说入口

05:31.390 --> 05:32.390
我们之前说过对吧

05:32.390 --> 05:33.390
入口它是有默认值的

05:33.390 --> 05:34.390
它什么默认值

05:34.390 --> 05:35.390
入口的默认值

05:35.390 --> 05:36.390
是不是

05:37.390 --> 05:38.390
src

05:38.390 --> 05:39.390
下面的index

05:39.390 --> 05:40.390
src

05:40.390 --> 05:41.390
对吧

05:41.390 --> 05:42.390
它就这样的默认值

05:42.390 --> 05:43.390
那么它会把我们的

05:43.390 --> 05:44.390
这些东西

05:44.390 --> 05:45.390
全部进行融合

05:45.390 --> 05:46.390
形成一个

05:46.390 --> 05:48.390
最终的配置对象

05:48.390 --> 05:49.390
这有点像啥呢

05:49.390 --> 05:52.390
其实它有点像那个

05:52.390 --> 05:54.390
就是css

05:54.390 --> 05:55.390
css的样式表里面

05:55.390 --> 05:56.390
是吧

05:56.390 --> 05:57.390
我们自己写的样式

05:57.390 --> 05:59.390
已经浏览起的默认样式

05:59.390 --> 06:00.390
已经

06:00.390 --> 06:01.390
如果没有设计到的样式

06:01.390 --> 06:02.390
它就给你使用默认值

06:02.390 --> 06:04.390
最终会融合一张

06:04.390 --> 06:05.390
很大的一张样式表

06:05.390 --> 06:06.390
那么这里也是一样

06:06.390 --> 06:08.390
src参数配置文件

06:08.390 --> 06:09.390
里边的东西

06:09.390 --> 06:10.390
已经默认配置

06:10.390 --> 06:11.390
它进行融合

06:11.390 --> 06:13.390
形成一个完整的配置对象

06:13.390 --> 06:15.390
那么它这个过程

06:15.390 --> 06:16.390
它是一脱于一个

06:16.390 --> 06:17.390
第三方库

06:17.390 --> 06:18.390
这个了解一下就行了

06:18.390 --> 06:19.390
因为你们以后

06:19.390 --> 06:20.390
虽然说你们自己

06:20.390 --> 06:21.390
不会必须用这个库

06:21.390 --> 06:23.390
我们自己不会去用这个库

06:23.390 --> 06:24.390
除非你要自己去开发

06:24.390 --> 06:26.390
一些很底层的东西

06:26.390 --> 06:27.390
否则的话

06:27.390 --> 06:28.390
你是不会去用这个库的

06:28.390 --> 06:29.390
这个库来干嘛的呢

06:29.390 --> 06:31.390
这个库它就是用来

06:31.390 --> 06:33.390
融合配置的

06:33.390 --> 06:34.390
它就是来可以

06:34.390 --> 06:35.390
帮助你融合配置

06:35.390 --> 06:36.390
你看一下你安装好了

06:36.390 --> 06:37.390
我也派了之后

06:37.390 --> 06:38.390
你会发现

06:38.390 --> 06:39.390
它这里边用到了

06:39.390 --> 06:40.390
很多的其他库对吧

06:40.390 --> 06:42.390
其中有一个库呢就是

06:42.390 --> 06:44.390
这个样式

06:44.390 --> 06:45.390
跑了一圈

06:45.390 --> 06:46.390
就在这儿

06:46.390 --> 06:47.390
它用到这个库

06:47.390 --> 06:48.390
那么这个库呢

06:48.390 --> 06:49.390
它其实就是在

06:49.390 --> 06:51.390
帮助你融合整个的配置的

06:51.390 --> 06:52.390
总之呢

06:52.390 --> 06:53.390
初始化阶段

06:53.390 --> 06:54.390
它做的非常重要的一件事情

06:54.390 --> 06:56.390
就是读取配置

06:56.390 --> 06:58.390
所以说为什么我们说

06:58.390 --> 07:00.390
在编译期间那个配置文件

07:00.390 --> 07:01.390
必须要用

07:01.390 --> 07:03.390
努德的代码来编写呢

07:03.390 --> 07:04.390
因为它会读取

07:04.390 --> 07:05.390
它会运行那个代码

07:05.390 --> 07:07.390
运行这个代码

07:07.390 --> 07:09.390
然后使用它导出的这个配置

07:09.390 --> 07:11.390
来进行融合

07:11.390 --> 07:13.390
就会产生一个最重要的配置对象

07:13.390 --> 07:15.390
那么产生了配置对象过后

07:15.390 --> 07:16.390
其实它还有一些事情做

07:16.390 --> 07:17.390
还要做

07:17.390 --> 07:18.390
不过我们目前这个阶段呢

07:18.390 --> 07:19.390
不用去管了

07:19.390 --> 07:20.390
初始化呢

07:20.390 --> 07:21.390
我们目前就认为

07:21.390 --> 07:22.390
它就是在融合配置的

07:22.390 --> 07:24.390
好配置融合了之后呢

07:24.390 --> 07:26.390
接下来进入下个阶段

07:26.390 --> 07:27.390
编译

07:27.390 --> 07:28.390
我们来看一下

07:28.390 --> 07:29.390
编译

07:29.390 --> 07:31.390
就这一块是做的事情是最多的

07:31.390 --> 07:33.390
它会经过哪些过程

07:33.390 --> 07:34.390
它第一步

07:34.390 --> 07:36.390
要创建一个东西叫做

07:36.390 --> 07:37.390
Trunk

07:37.390 --> 07:38.390
一个新概念

07:38.390 --> 07:40.390
这个概念还蛮重要的

07:40.390 --> 07:41.390
Trunk是什么东西呢

07:41.390 --> 07:43.390
Trunk它把它翻译成为

07:43.390 --> 07:45.390
我们真的不好翻译这个东西

07:45.390 --> 07:46.390
就是一个Quir

07:46.390 --> 07:47.390
一个Quir

07:47.390 --> 07:49.390
一Quir东西就是个Trunk

07:49.390 --> 07:50.390
Trunk是在WeiPack

07:50.390 --> 07:52.390
内部勾件的时候

07:52.390 --> 07:54.390
产生了一个东西

07:54.390 --> 07:55.390
最终你看不见的

07:55.390 --> 07:56.390
最终代码里边

07:56.390 --> 07:57.390
就是最终

07:57.390 --> 07:58.390
你使用了WeiPack之后

07:58.390 --> 07:59.390
你打包

07:59.390 --> 08:00.390
打包完成之后

08:00.390 --> 08:01.390
你就看不见它了

08:01.390 --> 08:02.390
它是打包的过程中

08:02.390 --> 08:04.390
产生了一个东西叫Trunk

08:04.390 --> 08:06.390
你可以把它简单的认为

08:06.390 --> 08:08.390
就是我们不是

08:08.390 --> 08:10.390
勾件的一个代码

08:10.390 --> 08:11.390
原代码的时候

08:11.390 --> 08:13.390
它要通过一个入口来勾件吗

08:13.390 --> 08:15.390
比方说咱们举个例子

08:15.390 --> 08:17.390
这里有个index.js

08:17.390 --> 08:19.390
这里有个add.js

08:19.390 --> 08:21.390
index.js里边去

08:21.390 --> 08:23.390
要导入a

08:23.390 --> 08:24.390
要导入a

08:24.390 --> 08:26.390
a里边俗出一句话

08:26.390 --> 08:27.390
就输出a

08:27.390 --> 08:29.390
然后这里导出一个a

08:29.390 --> 08:30.390
export

08:30.390 --> 08:32.390
导出一个a

08:32.390 --> 08:33.390
比方说随便

08:33.390 --> 08:34.390
随便瞎写一些

08:34.390 --> 08:37.700
比方说a里边还导入b

08:37.700 --> 08:38.700
b

08:38.700 --> 08:40.700
这里边还需要一条写纲

08:40.700 --> 08:41.700
导入b

08:41.700 --> 08:42.700
a里边导入b

08:42.700 --> 08:43.700
那么再写个b

08:43.700 --> 08:45.700
b.js

08:45.700 --> 08:46.700
那么这里

08:46.700 --> 08:48.700
就输出一下b

08:48.700 --> 08:49.700
输出一下b

08:49.700 --> 08:51.700
然后码就叫export

08:51.700 --> 08:52.700
b

08:52.700 --> 08:54.700
就随便写一些代码

08:54.700 --> 08:55.700
那么它入口认识谁

08:55.700 --> 08:56.700
入口认识不是index.js

08:57.700 --> 08:58.700
那么通过入口

08:58.700 --> 09:00.700
是不是可以找到3个模块

09:00.700 --> 09:01.700
因为它依赖a

09:01.700 --> 09:02.700
a有依赖b

09:02.700 --> 09:03.700
是不是可以通过入口

09:03.700 --> 09:04.700
找到3个模块

09:04.700 --> 09:06.700
那么这3个模块

09:06.700 --> 09:08.700
统称为一个trunk

09:08.700 --> 09:09.700
就这么个意思

09:09.700 --> 09:11.700
也就是trunk用来干嘛的

09:11.700 --> 09:12.700
trunk就是一个quart

09:12.700 --> 09:14.700
这个quart它从一个入口开始

09:14.700 --> 09:15.700
来分析整个依赖关系

09:15.700 --> 09:16.700
这就是个trunk

09:17.700 --> 09:19.700
你想刚才那个情况

09:19.700 --> 09:20.700
那么它就是

09:20.700 --> 09:22.700
根据入口模块

09:22.700 --> 09:24.700
默认是不是这个位置

09:24.700 --> 09:25.700
当然可以改

09:25.700 --> 09:26.700
对吧

09:26.700 --> 09:27.700
我们知道通过intre

09:27.700 --> 09:28.700
那么可以改的

09:28.700 --> 09:29.700
当然默认就是它

09:29.700 --> 09:30.700
那么通过这个模块

09:30.700 --> 09:31.700
它就是个模块

09:31.700 --> 09:32.700
对吧

09:32.700 --> 09:33.700
我们自己的模块

09:33.700 --> 09:34.700
来创建一个trunk

09:34.700 --> 09:35.700
一个trunk

09:35.700 --> 09:37.700
而且每一个trunk

09:37.700 --> 09:38.700
它是有名字的

09:38.700 --> 09:39.700
注意这句话

09:39.700 --> 09:41.700
每一个trunk就有名字的

09:41.700 --> 09:42.700
也就是说意味着

09:42.700 --> 09:44.700
trunk它是有可能

09:44.700 --> 09:45.700
会有多个的

09:46.700 --> 09:47.700
怎么会有多个呢

09:47.700 --> 09:49.700
不是只有一个入口文件吗

09:49.700 --> 09:50.700
我们目前是

09:50.700 --> 09:52.700
确实只有一个trunk

09:52.700 --> 09:53.700
因为只有一个入口文件

09:53.700 --> 09:54.700
实际上那入口文件

09:54.700 --> 09:56.700
它是可以有多个入口的

09:56.700 --> 09:57.700
我们下节课就会想

09:57.700 --> 09:58.700
可以有多个入口

09:59.700 --> 10:00.700
因此trunk

10:00.700 --> 10:02.700
它有可能会有多个

10:02.700 --> 10:03.700
那么目前我们只有一个

10:03.700 --> 10:05.700
但是大家心里面要知道

10:05.700 --> 10:06.700
它是有可能有多个的

10:06.700 --> 10:07.700
到底怎么来

10:07.700 --> 10:08.700
有多个trunk

10:08.700 --> 10:09.700
我们下节课再说

10:10.700 --> 10:11.700
那么默认情况下

10:11.700 --> 10:12.700
它是不是只有一个trunk

10:12.700 --> 10:13.700
OK

10:13.700 --> 10:15.700
那么由于它有可能会有多个

10:15.700 --> 10:16.700
因此每一个trunk

10:16.700 --> 10:17.700
它要给它取个名字

10:18.700 --> 10:19.700
默认情况下

10:19.700 --> 10:20.700
你只要没有配置

10:20.700 --> 10:21.700
默认情况下

10:21.700 --> 10:22.700
由于它只有一个trunk

10:22.700 --> 10:23.700
它的默认名字

10:24.700 --> 10:25.700
是妹

10:25.700 --> 10:27.700
默认名字是不是很熟悉的

10:27.700 --> 10:28.700
不着急

10:28.700 --> 10:29.700
慢慢来

10:29.700 --> 10:31.700
默认的名字就是妹

10:31.700 --> 10:33.700
trunk除了有名字之外

10:33.700 --> 10:34.700
还有一个东西

10:34.700 --> 10:35.700
叫id

10:35.700 --> 10:36.700
它是一个编号

10:36.700 --> 10:38.700
就好像你们学生有学号

10:38.700 --> 10:42.700
我们作为一个国家的公民

10:42.700 --> 10:43.700
有身份证号

10:43.700 --> 10:44.700
将来有一个编号

10:44.700 --> 10:46.700
那么这个编号

10:46.700 --> 10:47.700
它是这样子的

10:47.700 --> 10:48.700
它是有这么一个规则

10:48.700 --> 10:49.700
在开发环境里边

10:49.700 --> 10:51.700
如果说你的模式

10:51.700 --> 10:53.700
如果说你使用的模式

10:53.700 --> 10:55.700
是开发环境

10:55.700 --> 10:56.700
development

10:56.700 --> 10:57.700
那么这样子

10:57.700 --> 10:58.700
它就是一个什么

10:58.700 --> 10:59.700
它的编号

11:00.700 --> 11:01.700
它的编号

11:01.700 --> 11:03.700
编号跟这个name是一样的

11:03.700 --> 11:04.700
name是妹

11:04.700 --> 11:05.700
那编号就是妹

11:05.700 --> 11:07.700
但是如果你是一个生产环境的话

11:07.700 --> 11:08.700
它是一个数字

11:08.700 --> 11:10.700
它是从0开始进行编号的

11:10.700 --> 11:11.700
比如说第1个trunk就是0

11:11.700 --> 11:13.700
第2个trunk就是1

11:13.700 --> 11:14.700
当然现在你们还没有

11:14.700 --> 11:15.700
遇到过多个trunk

11:15.700 --> 11:17.700
我们下一个课会说

11:17.700 --> 11:18.700
这是它做的第1个步骤

11:18.700 --> 11:20.700
要创建一个trunk

11:21.700 --> 11:23.700
当然有可能会创建多个

11:23.700 --> 11:25.700
多个现在我们只是没遇到

11:25.700 --> 11:27.700
我们现在就按一个来说吧

11:27.700 --> 11:28.700
好

11:28.700 --> 11:29.700
接下来

11:29.700 --> 11:30.700
第2步

11:30.700 --> 11:31.700
第2步是比较复杂的

11:31.700 --> 11:33.700
我把这个图放大一点

11:33.700 --> 11:34.700
那么它现在

11:34.700 --> 11:36.700
由于有了一个trunk之后

11:36.700 --> 11:38.700
它要开始来构建一代了

11:38.700 --> 11:39.700
因为它的目的是什么了

11:39.700 --> 11:40.700
目的是要把这些

11:40.700 --> 11:42.700
所有的依赖全部加进来

11:42.700 --> 11:43.700
对吧

11:43.700 --> 11:44.700
你这里边

11:44.700 --> 11:45.700
原代码里边

11:45.700 --> 11:46.700
设计到了哪些模块

11:46.700 --> 11:47.700
那么那些模块

11:47.700 --> 11:49.700
哪些又依赖谁

11:49.700 --> 11:51.700
它把它全部加在进来

11:51.700 --> 11:52.700
那么第2步就是

11:52.700 --> 11:54.700
构建所有的依赖模块

11:54.700 --> 11:55.700
通过入口来构建

11:55.700 --> 11:56.700
那么这个过程相对是

11:56.700 --> 11:57.700
比较复杂的

11:57.700 --> 11:59.700
我们来看一下这个过程

11:59.700 --> 12:00.700
这个过程我会

12:00.700 --> 12:02.700
用这个代码来进行解释

12:02.700 --> 12:04.700
来看一下这个过程

12:04.700 --> 12:06.700
首先它怎么来做的

12:06.700 --> 12:07.700
首先它根据

12:07.700 --> 12:09.700
它手上拿到的是什么

12:09.700 --> 12:11.700
拿到的是一个入口模块

12:11.700 --> 12:12.700
它只有这个东西

12:12.700 --> 12:13.700
没有别的了

12:13.700 --> 12:14.700
它就根据入口模块

12:14.700 --> 12:16.700
开始来进行构建

12:16.700 --> 12:18.700
怎么来做的呢

12:18.700 --> 12:22.700
首先它看到的是一个模块文件

12:22.700 --> 12:24.700
那么拿到这个模块文件

12:24.700 --> 12:25.700
它的模块文件

12:25.700 --> 12:27.700
它是有一个路径的

12:27.700 --> 12:29.700
比方说我们入口模块的

12:29.700 --> 12:31.700
是不是SRC index的解释

12:31.700 --> 12:32.700
对吧

12:32.700 --> 12:33.700
是不是有个路径

12:33.700 --> 12:34.700
好

12:34.700 --> 12:35.700
那么它用这个路径

12:35.700 --> 12:37.700
首先检查一下

12:37.700 --> 12:38.700
这个模块是不是

12:38.700 --> 12:40.700
已经夹载过了

12:40.700 --> 12:42.700
注意它不是运行这个模块

12:42.700 --> 12:44.700
它是把这个文件内容读出来

12:44.700 --> 12:45.700
我们一会会说

12:45.700 --> 12:46.700
它看一下这个模块

12:46.700 --> 12:47.700
是不是已经夹载过了

12:47.700 --> 12:48.700
你可能现在觉得

12:48.700 --> 12:49.700
为什么要看这个东西

12:49.700 --> 12:50.700
在哪里去看

12:50.700 --> 12:51.700
有点模糊

12:51.700 --> 12:52.700
不着急

12:52.700 --> 12:53.700
我要把它全部解释完了

12:53.700 --> 12:54.700
过后里就明白了

12:54.700 --> 12:56.700
那么它首先检查一下

12:56.700 --> 12:57.700
记录在哪里检查

12:57.700 --> 12:58.700
在这里检查

12:58.700 --> 13:00.700
它这里有一张表格

13:00.700 --> 13:01.700
有张表格

13:01.700 --> 13:02.700
这里边记录了啥

13:02.700 --> 13:03.700
一开始肯定是空的

13:03.700 --> 13:05.700
一开始表格里边什么内容都没有

13:05.700 --> 13:06.700
一开始这个表格里边

13:06.700 --> 13:07.700
什么内容都没有

13:07.700 --> 13:09.700
所以说这个表格里边是空的

13:09.700 --> 13:10.700
没关系

13:10.700 --> 13:12.700
总之检查一下

13:12.700 --> 13:13.700
这个表格里边

13:13.700 --> 13:15.700
模块ID是什么

13:15.700 --> 13:16.700
ID就是模块的路径

13:16.700 --> 13:18.700
因为每一个模块的路径

13:18.700 --> 13:19.700
一定是唯一的

13:19.700 --> 13:21.700
所以模块ID就是模块的路径

13:21.700 --> 13:23.700
然后后面是模块里边的代码

13:23.700 --> 13:24.700
就是里边的代码

13:24.700 --> 13:25.700
它不会运行代码的

13:25.700 --> 13:27.700
它只是把个代码记录在这

13:27.700 --> 13:28.700
那么它首先检查一下

13:28.700 --> 13:29.700
这个模块是不是已经夹载过了

13:29.700 --> 13:31.700
一开始这个表格是空的

13:31.700 --> 13:33.700
所以说一开始肯定没有夹载过

13:33.700 --> 13:35.700
如果说已经夹载过了

13:35.700 --> 13:36.700
已经记录过了

13:36.700 --> 13:37.700
那么就结束了

13:37.700 --> 13:38.700
如果说没有记录

13:38.700 --> 13:39.700
那么它继续说明这个模块

13:39.700 --> 13:40.700
需要夹载

13:40.700 --> 13:41.700
好

13:41.700 --> 13:42.700
怎么夹载呢

13:42.700 --> 13:43.700
它怎么这么做的

13:43.700 --> 13:45.700
把这个模块的内容读出来

13:45.700 --> 13:46.700
你看

13:46.700 --> 13:47.700
内容是不是

13:47.700 --> 13:48.700
这就是文件内容

13:48.700 --> 13:51.700
漏的环境里边是可以读文件的

13:51.700 --> 13:53.700
浏览机环境里边不行

13:53.700 --> 13:55.700
漏的环境里边是可以读文件的

13:55.700 --> 13:56.700
所以说为什么

13:56.700 --> 13:58.700
未拍的必须要在漏的环境下运行

13:58.700 --> 13:59.700
因为它要读文件

13:59.700 --> 14:00.700
它要把我们这个文件

14:00.700 --> 14:02.700
它发现这个文件没有夹载

14:02.700 --> 14:03.700
对不对

14:03.700 --> 14:04.700
未夹载

14:05.700 --> 14:06.700
那干嘛呢

14:06.700 --> 14:08.700
把它的文件内容读出来

14:08.700 --> 14:10.700
内容是不是这个

14:10.700 --> 14:11.700
对吧

14:11.700 --> 14:12.700
内容读出来

14:12.700 --> 14:13.700
过后了

14:13.700 --> 14:15.700
它要做一件事情

14:15.700 --> 14:17.700
语法分析

14:17.700 --> 14:19.700
为什么要进行语法分析呢

14:19.700 --> 14:20.700
很奇怪

14:20.700 --> 14:22.700
因为它要做一件事

14:22.700 --> 14:24.700
就是要知道这个模块

14:24.700 --> 14:25.700
它要依赖谁

14:25.700 --> 14:27.700
它怎么样知道依赖谁

14:27.700 --> 14:29.700
它必须要把文件内容读出来

14:29.700 --> 14:30.700
才能知道要依赖谁

14:30.700 --> 14:31.700
比方说这个文件里边

14:31.700 --> 14:32.700
还有一些其他代码

14:32.700 --> 14:33.700
还有循环判断

14:33.700 --> 14:34.700
对吧

14:34.700 --> 14:36.700
你写了一些乱七八糟的代码

14:36.700 --> 14:38.700
比方说这样子

14:38.700 --> 14:40.700
你可能写了很多的代码

14:40.700 --> 14:42.700
那么它从这些代码中分析出

14:42.700 --> 14:43.700
到底这个模块

14:43.700 --> 14:45.700
要不要依赖其他模块

14:45.700 --> 14:46.700
那怎么来分析呢

14:46.700 --> 14:47.700
它要通过

14:47.700 --> 14:49.700
语法分析

14:49.700 --> 14:50.700
怎么来进行语法分析呢

14:50.700 --> 14:53.700
它会把它转换成一个抽象语法书

14:53.700 --> 14:55.700
这个抽象语法书是啥呢

14:55.700 --> 14:56.700
看下面

14:56.700 --> 14:57.700
这里有个网址

14:57.700 --> 14:58.700
这个网址

14:58.700 --> 14:59.700
大家可以去测试一下

14:59.700 --> 15:02.700
这就是一个抽象语法书的

15:02.700 --> 15:04.700
它的英文说起叫做AST

15:04.700 --> 15:08.700
这是一个抽象语法书的这么一个测试工具

15:08.700 --> 15:09.700
好

15:09.700 --> 15:10.700
比方说就是我们刚才这两句代码

15:10.700 --> 15:12.700
我们来看一下

15:12.700 --> 15:13.700
我们把这里

15:13.700 --> 15:14.700
把个代码小字

15:14.700 --> 15:15.700
小字

15:15.700 --> 15:16.700
你看一下

15:16.700 --> 15:17.700
它分析出来

15:17.700 --> 15:18.700
它就形成了这么一个对象

15:18.700 --> 15:19.700
你看

15:19.700 --> 15:20.700
一个很

15:20.700 --> 15:21.700
相当于是个塑形结构的对象

15:21.700 --> 15:22.700
首先它整个

15:22.700 --> 15:24.700
它告诉我

15:24.700 --> 15:26.700
好像没有开始分析

15:26.700 --> 15:27.700
是吧

15:27.700 --> 15:31.780
跑拉去了

15:31.780 --> 15:32.780
对了

15:32.780 --> 15:33.780
就这个

15:33.780 --> 15:35.780
那么你可以看到

15:35.780 --> 15:36.780
它分析出来

15:36.780 --> 15:38.780
就是我们整个是一个程序

15:38.780 --> 15:40.780
然后程序的主体里边有两段

15:40.780 --> 15:41.780
你看

15:41.780 --> 15:42.780
是不是有两段

15:42.780 --> 15:43.780
把这列起来

15:43.780 --> 15:44.780
第一段你看左边

15:44.780 --> 15:45.780
放大一点

15:45.780 --> 15:46.780
能不能放大

15:46.780 --> 15:47.780
放大一点

15:47.780 --> 15:48.780
你看第一段

15:48.780 --> 15:49.780
是不是左边的

15:49.780 --> 15:50.780
就是背景变成黄色的

15:50.780 --> 15:51.780
第二段

15:51.780 --> 15:52.780
好

15:52.780 --> 15:53.780
左边的展开又是个对象

15:53.780 --> 15:55.780
这个对象里边是一个什么呢

15:55.780 --> 15:56.780
它告诉我

15:56.780 --> 15:59.780
是一个叫做Core Expression

15:59.780 --> 16:00.780
表示什么意思

16:00.780 --> 16:02.780
表示一个函数调用

16:02.780 --> 16:03.780
对吧

16:03.780 --> 16:04.780
这是一个函数调用

16:04.780 --> 16:05.780
那么这里边

16:05.780 --> 16:06.780
我们再继续找

16:07.780 --> 16:10.780
它告诉我

16:10.780 --> 16:12.780
它有一个参数

16:12.780 --> 16:13.780
参数的值呢

16:13.780 --> 16:14.780
是index

16:14.780 --> 16:16.780
value是index

16:16.780 --> 16:17.780
那么它就会把它分析成

16:17.780 --> 16:18.780
这么一种对象结构

16:18.780 --> 16:20.780
你看一下这个对象结构

16:20.780 --> 16:22.780
我们看第二段对象结构

16:22.780 --> 16:25.480
把这个展开

16:25.480 --> 16:26.480
你看

16:26.480 --> 16:27.480
它对象结构里边

16:27.480 --> 16:28.480
它就记录了

16:28.480 --> 16:29.480
我这里有哪些地方

16:29.480 --> 16:31.480
是在做函数调用

16:31.480 --> 16:32.480
那么哪些地方

16:32.480 --> 16:33.480
函数调用的名字

16:33.480 --> 16:34.480
叫做Require

16:34.480 --> 16:35.480
看到没

16:35.480 --> 16:36.480
它是不是可以分析出来

16:36.480 --> 16:37.480
它把它变成

16:37.480 --> 16:39.480
变成这种数形结构过后

16:39.480 --> 16:40.480
利用算法

16:40.480 --> 16:43.480
来进行一个数形结构的便利

16:43.480 --> 16:44.480
是不是可以分析出

16:44.480 --> 16:46.480
我哪些地方调用了Require函数

16:46.480 --> 16:47.480
对吧

16:47.480 --> 16:48.480
是不是可以分析出来

16:48.480 --> 16:49.480
它主要是起这么一个目的

16:49.480 --> 16:51.480
比方说我们这里用的

16:51.480 --> 16:52.480
不是Require

16:52.480 --> 16:53.480
用的是什么呢

16:53.480 --> 16:54.480
一些语法

16:54.480 --> 16:55.480
Importer

16:55.480 --> 16:56.480
比方说什么呢

16:56.480 --> 16:57.480
随便写吧

16:57.480 --> 16:59.480
from

17:00.480 --> 17:01.480
你看

17:01.480 --> 17:02.480
它真正可以分析出来

17:02.480 --> 17:03.480
真正可以分析出来

17:03.480 --> 17:04.480
它叫做

17:04.480 --> 17:05.480
有一个Importer

17:05.480 --> 17:08.480
Declareation

17:08.480 --> 17:09.480
怎么读的

17:09.480 --> 17:10.480
这个叫声名

17:10.480 --> 17:11.480
怎么读的

17:11.480 --> 17:12.480
Declareation

17:12.480 --> 17:13.480
叫声名

17:13.480 --> 17:14.480
表示Importer声名

17:14.480 --> 17:15.480
那么它只要能够发现

17:15.480 --> 17:16.480
这个抽象语法数

17:16.480 --> 17:18.480
形成这么一个对象结构里面

17:18.480 --> 17:19.480
发现了这个东西

17:19.480 --> 17:20.480
说明啥

17:20.480 --> 17:21.480
是不是也有导入

17:21.480 --> 17:22.480
对吧

17:22.480 --> 17:23.480
也有依赖

17:23.480 --> 17:24.480
那么它就可以从依赖中

17:24.480 --> 17:25.480
准确找到你依赖的东西

17:25.480 --> 17:26.480
是什么

17:26.480 --> 17:27.480
这个解释

17:27.480 --> 17:28.480
它可以做到这么一个

17:28.480 --> 17:29.480
效果

17:29.480 --> 17:30.480
因此

17:30.480 --> 17:31.480
它这里就是

17:31.480 --> 17:32.480
它为什么要把它分析成

17:32.480 --> 17:33.480
抽象语法数

17:33.480 --> 17:34.480
就是要分析

17:34.480 --> 17:35.480
把它变成抽象语法数

17:35.480 --> 17:36.480
过后

17:36.480 --> 17:38.480
要分析它里面的依赖关系

17:38.480 --> 17:39.480
那么它就会

17:39.480 --> 17:40.480
接下来会怎么样

17:40.480 --> 17:42.480
接下来它就开始来记录

17:42.480 --> 17:43.480
记录

17:43.480 --> 17:47.050
就是把它变成抽象语法数

17:47.050 --> 17:48.050
AST

17:48.050 --> 17:49.050
把它变成这个

17:49.050 --> 17:50.050
然后从中

17:50.050 --> 17:51.050
是不是要进行

17:51.050 --> 17:52.050
塑形结构的遍地

17:52.050 --> 17:53.050
这是算法

17:53.050 --> 17:54.050
你们应该学过

17:54.050 --> 17:56.050
这是塑形

17:56.050 --> 17:57.050
当然你没学过也没关系

17:57.050 --> 17:58.050
反正它就这样做了

17:58.050 --> 17:59.050
塑形结构

17:59.050 --> 18:00.050
遍地

18:00.050 --> 18:03.050
找到所有依赖

18:03.050 --> 18:04.050
找到所有依赖

18:04.050 --> 18:05.050
那么它把这依赖

18:05.050 --> 18:06.050
记录到哪呢

18:06.050 --> 18:07.050
记录到一个竖竹里边

18:07.050 --> 18:08.050
叫dependency

18:08.050 --> 18:09.050
那么我们记录

18:09.050 --> 18:11.050
记录到一个竖竹里边

18:11.050 --> 18:12.050
好这个竖竹里边

18:12.050 --> 18:13.050
就是它依赖的东西

18:13.050 --> 18:14.050
比方说我们这里

18:14.050 --> 18:15.050
依赖谁呢

18:15.050 --> 18:16.050
是依赖A.GS

18:16.050 --> 18:17.050
但它记录的时候

18:17.050 --> 18:19.050
它不会这样的记录

18:19.050 --> 18:21.050
它不会直接把这个

18:21.050 --> 18:23.050
它不会直接把这个

18:23.050 --> 18:24.050
A.GS这样的记录下来

18:24.050 --> 18:25.050
它会记录什么呢

18:25.050 --> 18:27.050
记录它的完整相对路径

18:27.050 --> 18:28.050
它会这样的记录

18:28.050 --> 18:30.050
叫GS

18:30.050 --> 18:32.050
就是用摩扩ID的

18:32.050 --> 18:33.050
这种方式来进行记录

18:33.050 --> 18:34.050
你可以想

18:34.050 --> 18:35.050
它就是一个

18:35.050 --> 18:36.050
可以想象这个dependency

18:36.050 --> 18:38.050
它就是一个普通的

18:38.050 --> 18:39.050
制服创

18:39.050 --> 18:40.050
制服创述组

18:40.050 --> 18:41.050
当然它肯定不是那么简单

18:41.050 --> 18:42.050
但是我们可以这样想象

18:42.050 --> 18:43.050
它是一个普通的

18:43.050 --> 18:44.050
制服创述组

18:44.050 --> 18:45.050
那么你依赖了这个

18:45.050 --> 18:46.050
对吧

18:46.050 --> 18:47.050
如果说你还

18:47.050 --> 18:48.050
比方说你这里边还

18:48.050 --> 18:49.050
require了什么

18:49.050 --> 18:50.050
表写钢B

18:50.050 --> 18:52.050
比方说你还依赖了B

18:52.050 --> 18:54.050
那么这里又记录

18:54.050 --> 18:56.870
比方说

18:56.870 --> 18:58.870
它读出来的原代码

18:58.870 --> 18:59.870
但它要不要运行这个代码

18:59.870 --> 19:00.870
它不运行

19:00.870 --> 19:01.870
它只是把它做成一个

19:01.870 --> 19:03.870
制服创来进行分析

19:03.870 --> 19:04.870
就像这边一样

19:04.870 --> 19:06.870
你给它一个制服创

19:06.870 --> 19:07.870
把它复制过来

19:07.870 --> 19:08.870
你给它一个制服创

19:08.870 --> 19:10.870
它会把它分析成一个

19:10.870 --> 19:11.870
对象结构

19:11.870 --> 19:12.870
它只是在做这个

19:12.870 --> 19:14.870
文件内容的分析

19:14.870 --> 19:16.870
它并不会运行这个代码

19:16.870 --> 19:17.870
那么它这样的分析出来

19:17.870 --> 19:18.870
是不是有两个依赖

19:18.870 --> 19:19.870
对吧

19:19.870 --> 19:20.870
src

19:20.870 --> 19:22.870
b.js

19:22.870 --> 19:23.870
是不是有

19:23.870 --> 19:24.870
它会有两个依赖

19:24.870 --> 19:25.870
而且它会把它记录到

19:25.870 --> 19:26.870
什么

19:26.870 --> 19:27.870
记录到dependency

19:27.870 --> 19:28.870
这个数族里边

19:28.870 --> 19:30.870
好 接下来继续

19:30.870 --> 19:31.870
接下来

19:31.870 --> 19:34.870
它要替换依赖函数

19:34.870 --> 19:35.870
什么意思

19:35.870 --> 19:37.870
它会把这些有依赖的地方

19:37.870 --> 19:39.870
它把它编一种代码格式

19:39.870 --> 19:40.870
变成什么

19:40.870 --> 19:42.870
它变成这种格式

19:42.870 --> 19:44.870
它不会改文件内容

19:44.870 --> 19:45.870
文件内容是不会改的

19:45.870 --> 19:46.870
它都是在内存里边

19:46.870 --> 19:48.870
你看读出来不就是个制服创吗

19:48.870 --> 19:50.870
内容就是一个制服创

19:51.870 --> 19:52.870
那么它把它分析成

19:52.870 --> 19:53.870
抽象与法术

19:53.870 --> 19:54.870
然后读到依赖了

19:54.870 --> 19:55.870
对吧

19:55.870 --> 19:57.870
接下来它把制服创里边的内容改了

19:57.870 --> 19:58.870
把这个require

19:58.870 --> 19:59.870
这个地方改成了

19:59.870 --> 20:00.870
什么呢

20:00.870 --> 20:02.870
改成了webpackrequire

20:02.870 --> 20:04.870
那么这个地方

20:04.870 --> 20:06.870
改成了webpackrequire

20:06.870 --> 20:07.870
然后把这个地方

20:07.870 --> 20:08.870
改成了什么

20:08.870 --> 20:10.870
改成了模块的ID

20:10.870 --> 20:12.870
改成了模块的ID

20:12.870 --> 20:14.870
是不是有点感觉了

20:14.870 --> 20:15.870
这跟我们之前分析的

20:15.870 --> 20:16.870
那个编译结果

20:16.870 --> 20:18.870
是不是有点相似了

20:18.870 --> 20:19.870
对吧

20:19.870 --> 20:20.870
它把它改成这个样子

20:20.870 --> 20:21.870
那么我们把这个

20:21.870 --> 20:22.870
改动之后的

20:22.870 --> 20:25.870
叫做转换后的代码

20:25.870 --> 20:30.210
叫做转换

20:30.210 --> 20:32.210
或者是我们不在这写吧

20:32.210 --> 20:33.210
算了

20:33.210 --> 20:34.210
我们不在这写

20:34.210 --> 20:36.210
可能以为是改动文件

20:36.210 --> 20:38.210
根本就没有改动文件

20:38.210 --> 20:39.210
它在里边读出来过

20:39.210 --> 20:40.210
变成一个制服创

20:40.210 --> 20:41.210
制服创里边的进行更改

20:41.210 --> 20:42.210
它改成什么呢

20:42.210 --> 20:43.210
改成下面这个样子

20:48.380 --> 20:50.380
webpackrequire

20:50.380 --> 20:51.380
那么这边呢

20:51.380 --> 20:53.880
是这个

20:53.880 --> 20:54.880
这边

20:54.880 --> 20:56.880
webpackrequire

20:56.880 --> 20:57.880
现在跟什么

20:57.880 --> 20:58.880
最终生成的文件

20:58.880 --> 20:59.880
都还没关系

20:59.880 --> 21:02.880
它只是在内存里边更改

21:02.880 --> 21:03.880
它把内容改成这个样子

21:03.880 --> 21:05.880
那么这个东西叫做

21:05.880 --> 21:08.880
转换后的代码

21:08.880 --> 21:09.880
那么这是一个制服创

21:09.880 --> 21:12.880
仍然是一个制服创而已

21:12.880 --> 21:13.880
好

21:13.880 --> 21:14.880
那么这就是

21:14.880 --> 21:15.880
这一步要做的事情

21:15.880 --> 21:16.880
替换依赖函数

21:16.880 --> 21:18.880
它把它替换掉了

21:18.880 --> 21:19.880
接下来呢

21:19.880 --> 21:21.880
它会把这个

21:21.880 --> 21:22.880
它会把我们

21:22.880 --> 21:24.880
转换后的模块代码

21:24.880 --> 21:25.880
进行保存

21:25.880 --> 21:26.880
保存到哪

21:26.880 --> 21:28.880
保存到一个表格里边

21:28.880 --> 21:29.880
你可以认为

21:29.880 --> 21:30.880
就是一个数组

21:30.880 --> 21:31.880
这个数组里边

21:31.880 --> 21:32.880
每一个项是一个对象

21:32.880 --> 21:33.880
里边记录了模块的ID

21:33.880 --> 21:34.880
和转换后的代码

21:34.880 --> 21:35.880
那么它会保存到哪呢

21:35.880 --> 21:38.880
我们另外开一个

21:38.880 --> 21:39.880
它就会

21:39.880 --> 21:40.880
往这个数组里边

21:40.880 --> 21:42.880
就是这个表格里边

21:42.880 --> 21:44.880
表格里边记录

21:44.880 --> 21:45.880
我们就用这样子写吧

21:45.880 --> 21:46.880
这样子写好一点

21:46.880 --> 21:50.880
模块ID

21:50.880 --> 21:51.880
为什么呢

21:51.880 --> 21:53.880
为srcintx

21:53.880 --> 21:54.880
因为我们目前加载的是

21:54.880 --> 21:55.880
这个模块

21:55.880 --> 21:56.880
加载的是这个模块

21:56.880 --> 21:58.880
那么它的转换后的代码

21:58.880 --> 22:00.880
转换后的代码

22:00.880 --> 22:01.880
是什么呢

22:02.880 --> 22:04.880
就是这边这个

22:04.880 --> 22:06.880
它就会把它记录下来

22:06.880 --> 22:07.880
OK

22:07.880 --> 22:08.880
那么这个表格里边

22:08.880 --> 22:09.880
是有一行

22:09.880 --> 22:10.880
对吧

22:10.880 --> 22:11.880
模块ID和转换后的代码

22:11.880 --> 22:12.880
记录下来

22:12.880 --> 22:13.880
好

22:13.880 --> 22:14.880
接下来它还没完

22:14.880 --> 22:15.880
因为这个模块

22:15.880 --> 22:16.880
它还有依赖

22:16.880 --> 22:17.880
还有依赖干嘛呢

22:17.880 --> 22:18.880
它接下来要循环

22:18.880 --> 22:19.880
刚才我们保存的

22:19.880 --> 22:21.880
那个dependencies

22:21.880 --> 22:22.880
是不是要循环这个依赖

22:22.880 --> 22:23.880
好

22:23.880 --> 22:24.880
循环依赖过后

22:24.880 --> 22:25.880
又重新来加载

22:25.880 --> 22:26.880
这些模块

22:26.880 --> 22:28.880
懂这个意思吗

22:28.880 --> 22:29.880
也就是说

22:29.880 --> 22:30.880
它最终一定要形成

22:30.880 --> 22:31.880
这么一种表格

22:31.880 --> 22:33.880
有一个模块ID

22:33.880 --> 22:34.880
有个转换后的代码

22:34.880 --> 22:36.880
它怎么来形成这个表格

22:36.880 --> 22:37.880
就通过依赖来形成的

22:37.880 --> 22:39.880
通过找依赖来形成的

22:39.880 --> 22:40.880
好

22:40.880 --> 22:41.880
那么我们又来看

22:41.880 --> 22:42.880
接下来

22:42.880 --> 22:44.880
它是不是要搞定A点GS

22:44.880 --> 22:45.880
对吧

22:45.880 --> 22:46.880
因为这个数组里边有两项

22:46.880 --> 22:47.880
对吧

22:47.880 --> 22:48.880
现在我们加在index的GS

22:48.880 --> 22:49.880
还没完

22:49.880 --> 22:50.880
只是把自己的模块代码

22:50.880 --> 22:51.880
处理得好了

22:51.880 --> 22:52.880
但是这个地方

22:52.880 --> 22:53.880
是不是还没完

22:53.880 --> 22:54.880
OK

22:54.880 --> 22:55.880
现在我们又开一个技术

22:55.880 --> 22:56.880
把窗口

22:56.880 --> 22:57.880
现在又来搞定它

22:57.880 --> 22:59.880
又来看这个A点GS

22:59.880 --> 23:00.880
你看

23:00.880 --> 23:02.880
是不是要看它

23:02.880 --> 23:03.880
相当于是个地规的过程

23:03.880 --> 23:07.960
先看它

23:07.960 --> 23:09.960
我们把这个说小

23:09.960 --> 23:10.960
那么又来一遍

23:10.960 --> 23:11.960
我们多来几遍

23:11.960 --> 23:12.960
有没有加载呢

23:12.960 --> 23:13.960
你看

23:13.960 --> 23:15.960
现在我们就查越这个表格

23:15.960 --> 23:16.960
就查越这个表格

23:16.960 --> 23:17.960
对吧

23:17.960 --> 23:18.960
现在表格是不是只有一项

23:18.960 --> 23:20.960
有没有加载过这个A点GS呢

23:20.960 --> 23:22.960
是没有加载过

23:22.960 --> 23:23.960
注意它不是运行模块

23:23.960 --> 23:25.960
它只是在加载模块

23:25.960 --> 23:26.960
加载模块里边的内容

23:26.960 --> 23:27.960
有没有加载过呢

23:27.960 --> 23:28.960
没有加载过

23:28.960 --> 23:29.960
没有加载过

23:29.960 --> 23:30.960
那么去开始加载

23:30.960 --> 23:32.960
加载怎么加载

23:32.960 --> 23:33.960
一样的

23:33.960 --> 23:34.960
读去文件内容

23:34.960 --> 23:35.960
来吧

23:35.960 --> 23:36.960
A点GS又把读出来

23:36.960 --> 23:37.960
是不是这个

23:37.960 --> 23:39.960
他不管内容是啥

23:39.960 --> 23:41.960
他直接把文件内容读出来

23:41.960 --> 23:42.960
读出来过后做什么

23:42.960 --> 23:44.960
做语法数分析

23:44.960 --> 23:45.960
语法数分析

23:45.960 --> 23:46.960
分析出来是不是找到依赖了

23:46.960 --> 23:48.960
那么他的依赖

23:48.960 --> 23:51.960
是不是只有一个SRC

23:51.960 --> 23:53.960
掉鞋杠

23:53.960 --> 23:55.960
SRC必掉GS

23:55.960 --> 23:56.960
对吧

23:56.960 --> 23:57.960
是不是只有这一个

23:57.960 --> 23:58.960
没有别的了

23:58.960 --> 24:00.960
保存到这个依赖箱里面

24:00.960 --> 24:01.960
竖竹里边

24:01.960 --> 24:02.960
然后接下来

24:02.960 --> 24:03.960
他是不是又来替换依赖函数

24:03.960 --> 24:04.960
对吧

24:04.960 --> 24:05.960
替换依赖函数

24:05.960 --> 24:06.960
替换依赖函数

24:06.960 --> 24:08.960
是不是又把这个东西

24:08.960 --> 24:10.960
require替换成了什么

24:10.960 --> 24:11.960
替换成了

24:11.960 --> 24:13.960
webpackrequire

24:13.960 --> 24:14.960
然后把这个地方替换成了什么

24:14.960 --> 24:17.960
SRC必掉GS

24:17.960 --> 24:18.960
替换完了

24:18.960 --> 24:20.960
替换完了之后干嘛呢

24:20.960 --> 24:22.960
当然如果说ES6的话

24:22.960 --> 24:23.960
又有点不一样

24:23.960 --> 24:25.960
不过大体上都差不多

24:25.960 --> 24:26.960
就是这么个意思

24:26.960 --> 24:27.960
我们主要是研究它的过程

24:27.960 --> 24:29.960
好那么接下来干嘛呢

24:29.960 --> 24:30.960
接下来是不是要把

24:30.960 --> 24:31.960
转换后的代码保存起来

24:31.960 --> 24:32.960
好

24:32.960 --> 24:33.960
那么这里是不是又多了一项

24:33.960 --> 24:35.960
现在就是摩

24:35.960 --> 24:37.960
摩扩ID

24:37.960 --> 24:39.960
摩扩ID是什么呢

24:39.960 --> 24:40.960
第二鞋杠

24:40.960 --> 24:42.960
SRC Index

24:42.960 --> 24:44.960
A2GS

24:44.960 --> 24:45.960
对吧

24:45.960 --> 24:46.960
我们目前的摩扩

24:46.960 --> 24:47.960
是A这个摩扩

24:47.960 --> 24:48.960
对不对

24:48.960 --> 24:49.960
A这个摩扩

24:49.960 --> 24:50.960
OK

24:50.960 --> 24:51.960
那么现在呢

24:51.960 --> 24:52.960
转换后的代码

24:52.960 --> 24:53.960
A这个摩扩转换后的代码

24:53.960 --> 24:54.960
是不是变成这个样子

24:54.960 --> 24:56.960
这就是一个制服串

24:56.960 --> 24:57.960
没有什么特别的

24:57.960 --> 24:59.960
这个网页对WiPack来说

24:59.960 --> 25:00.960
就是一个制服串而已

25:00.960 --> 25:01.960
它就是一个制服串

25:01.960 --> 25:03.960
把记录下来

25:03.960 --> 25:04.960
你可以想象

25:04.960 --> 25:05.960
就是一个数组

25:05.960 --> 25:06.960
数组里边有个对象

25:06.960 --> 25:07.960
对象里边有两个属性

25:07.960 --> 25:08.960
一个是ID

25:08.960 --> 25:09.960
一个是摩扩后的代码

25:09.960 --> 25:10.960
当然还有一些其他信息

25:10.960 --> 25:12.960
只不过我们目前只关心这些

25:12.960 --> 25:14.960
好又记录下来了对吧

25:14.960 --> 25:15.960
然后接下来是不是又来

25:15.960 --> 25:17.960
又来找A摩扩的东西

25:17.960 --> 25:19.960
A摩扩是不是一奈B

25:19.960 --> 25:22.960
又来看B

25:22.960 --> 25:24.960
整个过程走一遍

25:24.960 --> 25:25.960
你就明白了

25:25.960 --> 25:26.960
那么现在又去找摩扩

25:26.960 --> 25:27.960
什么呢

25:27.960 --> 25:29.960
DL-SRC-B.JS

25:29.960 --> 25:30.960
有没有夹载过

25:30.960 --> 25:32.960
看这里有没有夹载过

25:32.960 --> 25:33.960
没有夹载过

25:33.960 --> 25:34.960
OK 夹载

25:34.960 --> 25:36.960
这也是Wi加载

25:36.960 --> 25:38.960
夹载一样的

25:38.960 --> 25:41.960
又把B的什么内容读出来

25:41.960 --> 25:45.530
内容读出来

25:45.530 --> 25:46.530
就是B的内容

25:46.530 --> 25:47.530
读出来过后找

25:47.530 --> 25:48.530
然后语法书分析

25:48.530 --> 25:49.530
分析完了过后

25:49.530 --> 25:50.530
找依赖关系

25:50.530 --> 25:51.530
有没有依赖关系

25:51.530 --> 25:52.530
是不是又没有了

25:52.530 --> 25:54.530
B不依赖其他任何摩扩

25:54.530 --> 25:55.530
找不到依赖关系的

25:56.530 --> 25:57.530
依赖关系

25:57.530 --> 25:58.530
也就是说这里是个空数组

25:58.530 --> 25:59.530
Dipendence也是个空数组

25:59.530 --> 26:00.530
没东西

26:00.530 --> 26:01.530
无所谓

26:01.530 --> 26:03.530
接下来替换依赖函数

26:03.530 --> 26:04.530
接下来是不是把这个东西

26:04.530 --> 26:06.530
变成转换后的代码

26:06.530 --> 26:07.530
转换后的代码

26:07.530 --> 26:08.530
由于它没有require

26:08.530 --> 26:09.530
没有导入

26:09.530 --> 26:10.530
所以说不变

26:10.530 --> 26:12.530
这个代码不变

26:12.530 --> 26:13.530
没问题吧

26:13.530 --> 26:14.530
OK

26:14.530 --> 26:15.530
那么接下来

26:15.530 --> 26:16.530
是不是又把这个转换后的代码

26:16.530 --> 26:17.530
保存到哪

26:17.530 --> 26:19.530
保存到这个模块列表中

26:19.530 --> 26:21.530
模块ID

26:21.530 --> 26:23.530
模块ID

26:24.530 --> 26:26.530
SRC

26:26.530 --> 26:29.530
那么转换后的代码

26:29.530 --> 26:30.530
是不是记得到这

26:30.530 --> 26:31.530
对吧

26:31.530 --> 26:32.530
那么你看这样子一来

26:32.530 --> 26:34.530
是不是这个表格里边

26:34.530 --> 26:35.530
但是这里写的

26:35.530 --> 26:36.530
我不好写表格

26:36.530 --> 26:37.530
这个写的表

26:37.530 --> 26:39.530
其实它就是一个表格

26:39.530 --> 26:41.530
一个ID对一段代码

26:41.530 --> 26:43.530
一个ID对一段代码

26:43.530 --> 26:45.530
其实就是一个支付串而已

26:45.530 --> 26:46.530
那么这个表格里边

26:46.530 --> 26:47.530
是不是就记录了

26:47.530 --> 26:48.530
每一个模块的

26:48.530 --> 26:49.530
所有转换后的代码

26:49.530 --> 26:50.530
全部记录进来了

26:50.530 --> 26:51.530
对吧

26:51.530 --> 26:52.530
全部记录进来了

26:52.530 --> 26:53.530
OK

26:53.530 --> 26:54.530
那么接下来还没完

26:54.530 --> 26:55.530
你看我们现在是不是

26:55.530 --> 26:56.530
把B模块加载完了

26:56.530 --> 26:58.530
B模块为什么加载完了

26:58.530 --> 27:00.530
是因为我们之前是要A模块

27:00.530 --> 27:01.530
A模块里边一代B

27:01.530 --> 27:02.530
所以说我要去加载B模块

27:02.530 --> 27:03.530
那么现在A模块

27:03.530 --> 27:04.530
是不是加载完了

27:04.530 --> 27:05.530
好

27:05.530 --> 27:06.530
A模块加载完了

27:06.530 --> 27:07.530
这就是地规

27:07.530 --> 27:08.530
好 接下来又回到

27:08.530 --> 27:09.530
回到Index的介石

27:09.530 --> 27:11.530
Index的介石一开始

27:11.530 --> 27:12.530
去加载的A

27:12.530 --> 27:13.530
对吧

27:13.530 --> 27:14.530
但是它没有加载B

27:14.530 --> 27:16.530
所以说还要去加载一次B

27:16.530 --> 27:17.530
好 于是

27:17.530 --> 27:20.530
它现在又要去加载B

27:20.530 --> 27:21.530
又要加载B

27:22.530 --> 27:23.530
B点介石

27:23.530 --> 27:24.530
好 那么这个B点介石

27:24.530 --> 27:25.530
那么这里就

27:25.530 --> 27:26.530
你看这里就有用了

27:26.530 --> 27:28.530
它首先就要检查一下

27:28.530 --> 27:30.530
模块的最终表格里面

27:30.530 --> 27:32.530
有没有记录这个B

27:32.530 --> 27:33.530
它是不是就把这个东西

27:33.530 --> 27:34.530
拿去看一下

27:34.530 --> 27:35.530
用模块ID去匹配一下

27:35.530 --> 27:36.530
有没有记录这个B

27:36.530 --> 27:37.530
是不是有

27:37.530 --> 27:38.530
那么有记录的话

27:38.530 --> 27:39.530
它还要不要去加载

27:39.530 --> 27:40.530
就不加载了

27:40.530 --> 27:42.530
以记录

27:42.530 --> 27:44.530
不加载

27:44.530 --> 27:46.530
这就是它整个模块加载过程

27:46.530 --> 27:47.530
注意中

27:47.530 --> 27:50.530
它一切做这一系列动作的目的

27:50.530 --> 27:53.530
都是为了形成这个表格

27:53.530 --> 27:55.530
都是为了形成这个表格

27:55.530 --> 27:56.530
这点我可能只

27:56.530 --> 27:57.530
我只写了两个

27:57.530 --> 27:58.530
A点介石

27:58.530 --> 27:59.530
但是还有

27:59.530 --> 28:00.530
如果还有其他一代的话

28:00.530 --> 28:01.530
还要加载

28:01.530 --> 28:02.530
那如果说还引用了

28:02.530 --> 28:03.530
第三方过的话

28:03.530 --> 28:04.530
又一样的

28:04.530 --> 28:05.530
引用了第三方过的话

28:05.530 --> 28:06.530
它又从loaded module

28:06.530 --> 28:07.530
里面去加载

28:07.530 --> 28:08.530
总之它把每一个模块的

28:08.530 --> 28:09.530
转换后的代码

28:09.530 --> 28:10.530
一定要全部加载进来

28:10.530 --> 28:13.530
形成一个列表

28:13.530 --> 28:14.530
这就是

28:14.530 --> 28:17.530
这一部分做的事情

28:17.530 --> 28:19.530
这一部分是最复杂的

28:19.530 --> 28:21.530
它要做这么一系列事情

28:21.530 --> 28:24.530
那么才能最终形成这么一个表格

28:24.530 --> 28:26.530
下面有张简图

28:26.530 --> 28:27.530
简图就很简单了

28:27.530 --> 28:28.530
就是什么呢

28:28.530 --> 28:29.530
我们这一步

28:29.530 --> 28:31.530
总之这一步完成之后

28:31.530 --> 28:32.530
它就会形成

28:32.530 --> 28:33.530
在创刻里边

28:33.530 --> 28:36.530
在整个这个块里边

28:36.530 --> 28:37.530
它会形成什么呢

28:37.530 --> 28:38.530
会形成多个模块

28:38.530 --> 28:40.530
会形成多个模块

28:40.530 --> 28:42.530
这多个模块怎么来的

28:42.530 --> 28:43.530
就是通过入口模块

28:43.530 --> 28:45.530
一个一个去加载出来的

28:45.530 --> 28:46.530
形成了一个表格

28:46.530 --> 28:47.530
形成了多个模块

28:47.530 --> 28:48.530
每个模块里边

28:48.530 --> 28:49.530
它击入了模块

28:49.530 --> 28:51.530
模块转换之后的代码

28:51.530 --> 28:52.530
简图就是这样子

28:52.530 --> 28:53.530
但是它实际的过程

28:53.530 --> 28:54.530
就是经过这么一个过程

28:54.530 --> 28:56.530
它就怎么来得到这个结果的

28:56.530 --> 28:58.530
它就通过这个过程来得到的

28:58.530 --> 28:59.530
听懂了吗

28:59.530 --> 29:01.530
我不打算给大家

29:01.530 --> 29:02.530
用代码

29:02.530 --> 29:03.530
一个个去敲写出来

29:03.530 --> 29:04.530
能不能写出来

29:04.530 --> 29:05.530
能写出来

29:05.530 --> 29:06.530
不过很多同学要云

29:06.530 --> 29:07.530
特别复杂

29:07.530 --> 29:09.530
那么没必要

29:09.530 --> 29:11.530
我们知道它这个过程就行了

29:11.530 --> 29:12.530
就已经能够非常深入的

29:12.530 --> 29:13.530
去理解它了

29:13.530 --> 29:15.530
这是它第二步的做的事情

29:15.530 --> 29:17.530
构建所有的依赖模块

29:17.530 --> 29:18.530
依赖模块

29:18.530 --> 29:19.530
好

29:19.530 --> 29:21.530
第三步

29:21.530 --> 29:22.530
产生

29:22.530 --> 29:23.530
创造

29:23.530 --> 29:27.530
构建

29:27.530 --> 29:29.530
在第二步完成之后

29:29.530 --> 29:30.530
你会发现

29:30.530 --> 29:32.530
这个块里面就形成了多个模块

29:32.530 --> 29:33.530
就形成了这么一个东西了

29:33.530 --> 29:35.530
模块ID转换后的代码

29:35.530 --> 29:36.530
模块ID转换后的代码

29:36.530 --> 29:37.530
对吧

29:37.530 --> 29:38.530
是不是形成这么一个东西

29:38.530 --> 29:39.530
那么这个东西

29:39.530 --> 29:40.530
第二步完成之后

29:40.530 --> 29:42.530
会形成个模块列表

29:42.530 --> 29:43.530
列表都包含了模块

29:43.530 --> 29:44.530
ID和模块转换后的代码

29:44.530 --> 29:45.530
那么接下来

29:45.530 --> 29:47.530
为派会会根据配置

29:47.530 --> 29:50.530
为Trunk生成一个资源列表

29:50.530 --> 29:52.530
叫做Trunk Assets

29:53.530 --> 29:55.530
那么这个Trunk Assets

29:55.530 --> 29:56.530
是什么东西呢

29:56.530 --> 29:58.530
Trunk Assets你可以理解为

29:58.530 --> 30:01.530
就是要生成到最终文件的

30:01.530 --> 30:03.530
文件名和文件内容

30:03.530 --> 30:04.530
也就是说

30:04.530 --> 30:06.530
它要把这个东西变成啥呢

30:06.530 --> 30:08.530
它要变成这个

30:08.530 --> 30:10.530
又是一个数组

30:10.530 --> 30:11.530
又是个数组

30:11.530 --> 30:13.530
文件名

30:14.530 --> 30:17.290
文件名

30:17.290 --> 30:18.290
Dest

30:20.290 --> 30:21.290
Mate

30:21.290 --> 30:22.290
叫JS

30:22.290 --> 30:24.290
这是文件名

30:24.290 --> 30:25.290
文件内容

30:25.290 --> 30:26.290
文件内容是什么呢

30:26.290 --> 30:28.290
那就是我们之前写的那个了

30:28.290 --> 30:29.290
Function

30:29.290 --> 30:31.290
然后Module是

30:31.290 --> 30:32.290
我们之前做的一个圆骂分析

30:32.290 --> 30:33.290
还记得吗

30:33.290 --> 30:35.290
之前我们做过一次圆骂分析

30:35.290 --> 30:37.290
就是这个编译结果分析

30:37.290 --> 30:40.290
然后这里是不是写上一个对象

30:40.290 --> 30:41.290
对吧

30:41.290 --> 30:43.290
对象怎么去构建出来的

30:43.290 --> 30:45.290
它是不是就循环这边的

30:45.290 --> 30:47.290
循环这边的数组

30:47.290 --> 30:48.290
数组的第一项

30:48.290 --> 30:49.290
srca对吧

30:49.290 --> 30:51.290
然后把它写个方式

30:51.290 --> 30:53.290
然后这里是啥啥

30:53.290 --> 30:54.290
好

30:54.290 --> 30:55.290
然后这里边

30:55.290 --> 30:57.290
是不是就放这个转发后的代码

30:57.290 --> 30:58.290
它有几种方式

30:58.290 --> 31:00.290
它可以把这个代码

31:00.290 --> 31:01.290
放到Eva里边

31:01.290 --> 31:02.290
可以把这个字幕出来

31:02.290 --> 31:03.290
放到Eva里边

31:03.290 --> 31:04.290
也可以

31:04.290 --> 31:05.290
直接把它写到这

31:05.290 --> 31:06.290
都行

31:06.290 --> 31:07.290
因为我们可以通过Dev2

31:07.290 --> 31:08.290
来配置

31:08.290 --> 31:09.290
它这里的东西

31:09.290 --> 31:10.290
就千千百块了

31:10.290 --> 31:12.290
就各种写法了

31:12.290 --> 31:13.290
总之呢

31:13.290 --> 31:15.290
理论上就可以通过

31:15.290 --> 31:16.290
我们这些代码

31:16.290 --> 31:17.290
就是这些东西

31:17.290 --> 31:18.290
就是我们最终打包的

31:18.290 --> 31:19.290
就是这些模块

31:19.290 --> 31:20.290
对吧

31:20.290 --> 31:22.290
然后把它放到一个模板里边

31:22.290 --> 31:23.290
就是这次的模板

31:23.290 --> 31:24.290
把它放到一个模板里边

31:24.290 --> 31:25.290
那么就是不是

31:25.290 --> 31:26.290
形成了一个文件内容

31:26.290 --> 31:27.290
你看吧

31:27.290 --> 31:28.290
我们再打包一次

31:28.290 --> 31:31.180
npx

31:31.180 --> 31:32.180
vpec

31:32.180 --> 31:34.180
打包一次吧

31:34.180 --> 31:36.180
打包完了

31:36.180 --> 31:37.180
你看

31:37.180 --> 31:39.180
MediaJS里边

31:39.180 --> 31:40.180
你看这些

31:40.180 --> 31:41.180
很多代码

31:41.180 --> 31:42.180
你看这些代码

31:42.180 --> 31:43.180
都是固定不变的

31:43.180 --> 31:45.180
变化的是不是就是这里

31:45.180 --> 31:47.180
这里你看

31:47.180 --> 31:48.180
id

31:48.180 --> 31:49.180
对吧

31:49.180 --> 31:50.180
模块id

31:50.180 --> 31:51.180
然后模块里边代码

31:51.180 --> 31:52.180
对吧

31:52.180 --> 31:53.180
它读出来就是个制服串

31:53.180 --> 31:54.180
它这种做法很简单

31:54.180 --> 31:55.180
就是这里一个id

31:55.180 --> 31:56.180
把制服串放这

31:56.180 --> 31:57.180
完了

31:57.180 --> 31:58.180
这里一个id

31:58.180 --> 31:59.180
然后呢

31:59.180 --> 32:00.180
你看吧

32:00.180 --> 32:01.180
跑哪去了

32:01.180 --> 32:02.180
这

32:02.180 --> 32:03.180
id

32:03.180 --> 32:04.180
然后呢

32:04.180 --> 32:05.180
制服串

32:05.180 --> 32:06.180
对吧

32:06.180 --> 32:07.180
id

32:07.180 --> 32:08.180
制服串

32:08.180 --> 32:10.180
所以就往这里放就完事了

32:10.180 --> 32:11.180
于是呢

32:11.180 --> 32:12.180
至于这一步

32:12.180 --> 32:14.180
就是根据

32:14.180 --> 32:16.180
我们之前生存的这个模块列表

32:16.180 --> 32:17.180
这是我们的模块列表

32:17.180 --> 32:20.180
然后形成文件列表

32:20.180 --> 32:21.180
文件列表

32:21.180 --> 32:22.180
文件列表

32:22.180 --> 32:23.180
就在这

32:23.180 --> 32:24.180
文件名是这个

32:24.180 --> 32:26.180
文件内容就是这一长串

32:26.180 --> 32:27.180
一长串

32:27.180 --> 32:28.180
就不写了

32:28.180 --> 32:29.180
就不写了

32:29.180 --> 32:32.180
那为什么叫做文件列表呢

32:32.180 --> 32:33.180
而这次要是资源

32:33.180 --> 32:35.180
为什么叫做文件列表呢

32:35.180 --> 32:37.180
它不是单个文件吗

32:37.180 --> 32:39.180
它有可能是多个文件

32:39.180 --> 32:41.180
还有可能是什么文件

32:41.180 --> 32:43.180
这就是给大家说的

32:43.180 --> 32:46.180
为什么这个课程不好讲

32:46.180 --> 32:49.180
为什么要去非常重视这个顺序

32:49.180 --> 32:53.770
是不是还有可能是这种文件

32:53.770 --> 32:54.770
是不是还有可能这种文件

32:54.770 --> 32:55.770
对吧

32:55.770 --> 32:57.770
它是不是也有文件内容

32:57.770 --> 32:58.770
对不对

32:58.770 --> 32:59.770
是不是也有可能

32:59.770 --> 33:00.770
说这两个文件

33:00.770 --> 33:02.770
是不是都是同一个创可来生存出来的

33:02.770 --> 33:04.770
都是同一个块来生存出来的

33:04.770 --> 33:05.770
所以它叫做资源列表

33:05.770 --> 33:06.770
后面呢

33:06.770 --> 33:07.770
我们还会接触到

33:07.770 --> 33:08.770
可能还有别的文件

33:08.770 --> 33:09.770
都有可能会发生

33:09.770 --> 33:11.770
它不一定是一个文件

33:11.770 --> 33:12.770
就是通常情况下

33:12.770 --> 33:13.770
如果说你没有配置的话

33:13.770 --> 33:14.770
那确实是一个文件

33:14.770 --> 33:15.770
它是有没有可能是多个

33:15.770 --> 33:17.770
当然有可能是多个

33:17.770 --> 33:18.770
有可能是多个

33:18.770 --> 33:19.770
那么总之呢

33:19.770 --> 33:21.770
它会生存一个创可而sets

33:21.770 --> 33:22.770
就是一个支援

33:22.770 --> 33:24.770
创可的支援列表

33:24.770 --> 33:25.770
就是这个创可生存的支援列表

33:25.770 --> 33:26.770
那么下面呢

33:26.770 --> 33:27.770
我有个例子大家看一下吧

33:27.770 --> 33:29.770
之前我们不是得到一个表格吗

33:29.770 --> 33:30.770
对吧

33:30.770 --> 33:31.770
因这个时候我就磨块

33:31.770 --> 33:32.770
那么它会把磨块呢

33:32.770 --> 33:35.770
最终形成一个文件名

33:35.770 --> 33:37.770
文件名的默认的名称

33:37.770 --> 33:40.770
跟那个创可的名字是一样的

33:40.770 --> 33:42.770
然后有它的文件内容

33:42.770 --> 33:43.770
但是它有没有生存文件

33:43.770 --> 33:44.770
没有

33:44.770 --> 33:45.770
现在还没有生存文件

33:45.770 --> 33:47.770
那么这里可以把简单理解

33:47.770 --> 33:48.770
我就是个数主

33:48.770 --> 33:50.770
数主的第一项是个对象

33:50.770 --> 33:51.770
对象的文件名是这个

33:51.770 --> 33:54.770
对象的文件内容是这个

33:54.770 --> 33:55.770
第二呢

33:55.770 --> 33:56.770
它有可能有个map文件

33:56.770 --> 33:57.770
有可能有有可能没有

33:57.770 --> 33:59.770
看你的配置如何

33:59.770 --> 34:01.770
那么它这里会生成一个文件内容

34:01.770 --> 34:02.770
好 注意看

34:02.770 --> 34:03.770
下面还有一个东西

34:03.770 --> 34:05.770
叫做创可哈希

34:05.770 --> 34:07.770
这个是什么玩意

34:07.770 --> 34:09.770
创可哈希是什么东西呢

34:09.770 --> 34:11.770
哈希实际上就是

34:11.770 --> 34:12.770
我们首先了解一下

34:12.770 --> 34:13.770
哈希是什么东西

34:13.770 --> 34:15.770
哈希实际上是一种算法

34:15.770 --> 34:16.770
它具体有很多的

34:16.770 --> 34:17.770
哈希算法

34:17.770 --> 34:19.770
具体的算法有很多

34:19.770 --> 34:21.770
它的每一种算法的特点都是一样的

34:21.770 --> 34:24.770
都是能够将一个任意长度的制服串

34:24.770 --> 34:26.770
转换成一个固定长度的制服串

34:26.770 --> 34:28.770
大家看一下吧

34:28.770 --> 34:30.770
我这里有没有给链接

34:30.770 --> 34:32.770
我们摆对一下吧

34:32.770 --> 34:35.770
哈希工具

34:35.770 --> 34:37.770
就在这吧

34:38.770 --> 34:40.770
随便找一个

34:40.770 --> 34:42.770
那么这里不要我们随便写一个

34:42.770 --> 34:44.770
随便下写一个

34:44.770 --> 34:47.770
无论你这个制服串有多少

34:47.770 --> 34:48.770
无论你有多少

34:48.770 --> 34:50.770
这里我们点一下

34:50.770 --> 34:52.770
哈希算法是不是有很多的

34:52.770 --> 34:53.770
随便选一种

34:53.770 --> 34:54.770
点加密

34:54.770 --> 34:55.770
你看

34:55.770 --> 34:57.770
是不是生成了一个固定长度的制服串

34:57.770 --> 34:58.770
它能做到

34:58.770 --> 35:01.770
而且只要你原始的那种没有发生变化

35:01.770 --> 35:03.770
你每一次

35:03.770 --> 35:05.770
可以叫加密

35:05.770 --> 35:06.770
也可以叫做

35:06.770 --> 35:08.770
就是取一个哈希值

35:08.770 --> 35:10.770
那么你每一次取哈希值

35:10.770 --> 35:12.770
它是不会变化的

35:12.770 --> 35:15.770
但是只要你原始那种变化一点点

35:15.770 --> 35:18.770
你看一下哈希值就不一样了

35:18.770 --> 35:20.770
所以说哈希值有什么用了

35:20.770 --> 35:21.770
这个哈希值

35:21.770 --> 35:22.770
后边我们会有用

35:22.770 --> 35:23.770
现在没用

35:23.770 --> 35:24.770
现在对我们来说没用

35:24.770 --> 35:25.770
但是后边会有用

35:25.770 --> 35:29.770
后边是不是可以根据不同的文件内容

35:29.770 --> 35:31.770
来使用不同的哈希值

35:31.770 --> 35:32.770
哈希值后边会有用

35:32.770 --> 35:34.770
因为它能够反映文件内容

35:34.770 --> 35:35.770
有没有变

35:35.770 --> 35:36.770
如果文件内容没变

35:36.770 --> 35:38.770
它的哈希值就是一定是固定的

35:38.770 --> 35:39.770
如果说文件内容变了

35:39.770 --> 35:41.770
那么哈希值它就会变化

35:41.770 --> 35:43.770
哪怕有这个文件内容变了一点点

35:43.770 --> 35:45.770
哈希值它都会发生很大的变化

35:45.770 --> 35:46.770
比方说

35:46.770 --> 35:48.770
而且这个哈希值

35:48.770 --> 35:49.770
它的字如创长度是固定的

35:49.770 --> 35:50.770
比方说我们这里写个1

35:50.770 --> 35:52.770
你看生出来的哈希值还是这个

35:52.770 --> 35:55.770
就是这么一种神奇的算法

35:55.770 --> 35:57.770
这个学后端的同学

35:57.770 --> 35:59.770
这个东西肯定要学习的

35:59.770 --> 36:02.770
要学前端的话了解一下就行了

36:02.770 --> 36:04.770
那么也就是说哈希它可以

36:04.770 --> 36:06.770
它可以用来

36:06.770 --> 36:08.770
印证一个什么了

36:08.770 --> 36:10.770
印证一个文件它有没有变化

36:10.770 --> 36:11.770
目前没有用

36:11.770 --> 36:12.770
目前我们学到这儿是没有用的

36:12.770 --> 36:13.770
但是我们知道

36:13.770 --> 36:15.770
它这里要生成一个哈希就行了

36:15.770 --> 36:16.770
那么它这里怎么来生成这个哈希呢

36:16.770 --> 36:18.770
它是这样子生成的

36:18.770 --> 36:20.770
它是把我们的资源列表

36:20.770 --> 36:21.770
你看每一个资源

36:21.770 --> 36:22.770
就不是一个文件名

36:22.770 --> 36:23.770
一个文件内容吗

36:23.770 --> 36:24.770
它把所有的文件内容

36:24.770 --> 36:26.770
全部联合起来

36:26.770 --> 36:27.770
相当于可以把它做一个

36:27.770 --> 36:28.770
做一个字不算拼接

36:28.770 --> 36:29.770
你可以这样理解

36:29.770 --> 36:31.770
把它全部联合起来

36:31.770 --> 36:32.770
通过一个哈希算法

36:32.770 --> 36:34.770
生成一个固定长度的支部串

36:34.770 --> 36:36.770
这个长度大概就是

36:36.770 --> 36:38.770
因为不同的算法的哈希

36:38.770 --> 36:39.770
长度不太一样

36:39.770 --> 36:41.770
二十四位

36:41.770 --> 36:42.770
大概二十四位

36:42.770 --> 36:44.770
多少文明去仔细去看过

36:44.770 --> 36:45.770
无所谓吧

36:45.770 --> 36:46.770
总之就是一个定长的

36:46.770 --> 36:49.770
哈希支部串

36:49.770 --> 36:50.770
就这么个意思

36:50.770 --> 36:51.770
这个东西有什么用

36:51.770 --> 36:52.770
我们后边会说

36:52.770 --> 36:53.770
现在我们只需要知道

36:53.770 --> 36:54.770
这个东西叫做

36:54.770 --> 36:55.770
创可哈希

36:55.770 --> 36:56.770
就是在一个创可里边

36:56.770 --> 36:57.770
它生成了资源列表

36:57.770 --> 37:00.770
我们把它给它一个哈希字

37:00.770 --> 37:01.770
这就是这一部分做的事情

37:01.770 --> 37:03.770
下面一张简图

37:03.770 --> 37:04.770
你看我们之前不就是

37:04.770 --> 37:06.770
通过入口来得到

37:06.770 --> 37:07.770
所有的模块吗

37:07.770 --> 37:08.770
目的就是得到

37:08.770 --> 37:09.770
所有的模块的这种格式

37:09.770 --> 37:10.770
每个模块ID

37:10.770 --> 37:12.770
然后对应一段代码

37:12.770 --> 37:13.770
然后呢

37:13.770 --> 37:14.770
通过这些模块

37:14.770 --> 37:16.770
然后最终生成一个

37:16.770 --> 37:17.770
生成一个什么呢

37:17.770 --> 37:19.770
生成一个资源列表

37:19.770 --> 37:20.770
就是我要最终

37:20.770 --> 37:21.770
要形成的文件

37:21.770 --> 37:23.770
这么一个资源列表

37:23.770 --> 37:24.770
其实呢这里呢

37:24.770 --> 37:26.770
我这里还忘了写一个数语

37:26.770 --> 37:27.770
这里其实有个数语

37:27.770 --> 37:28.770
叫做邦斗

37:28.770 --> 37:29.770
邦斗表示什么意思

37:29.770 --> 37:31.770
表示一个捆的意思

37:31.770 --> 37:32.770
一捆

37:32.770 --> 37:34.770
那么每一个资源

37:34.770 --> 37:35.770
我们可以认为

37:35.770 --> 37:36.770
它就是一个邦斗

37:36.770 --> 37:37.770
每一个资源

37:37.770 --> 37:38.770
它就可以认为是一个邦斗

37:38.770 --> 37:40.770
这是这么一个数语

37:40.770 --> 37:41.770
那么这里呢

37:41.770 --> 37:43.770
还会形成一个哈希

37:43.770 --> 37:45.770
这一个步骤要做的事情

37:45.770 --> 37:47.770
接下来第四步

37:47.770 --> 37:49.770
也就是编译的最后一个步骤

37:49.770 --> 37:51.770
因为我们有可能

37:51.770 --> 37:52.770
之后的学习呢

37:52.770 --> 37:54.770
它有可能会产生多个创可

37:54.770 --> 37:56.770
它可能不止一个

37:56.770 --> 37:57.770
我们目前肯定是只能

37:57.770 --> 37:58.770
只接触了一个

37:58.770 --> 37:59.770
没有接触过多个

37:59.770 --> 38:00.770
但是以后呢

38:00.770 --> 38:01.770
可能会接触过多个创可

38:01.770 --> 38:02.770
那么每一个创可

38:02.770 --> 38:04.770
是不是都按照之前的分析

38:04.770 --> 38:06.770
它都有可能会形成这种结构

38:06.770 --> 38:07.770
对吧都有可能

38:07.770 --> 38:08.770
根据入口来找到一些模块

38:08.770 --> 38:09.770
然后生成一些资源列表

38:09.770 --> 38:11.770
每一个创可是不是都有

38:11.770 --> 38:12.770
有可能有资源列表

38:12.770 --> 38:13.770
每一个创可有自己的哈希

38:13.770 --> 38:14.770
对吧

38:14.770 --> 38:15.770
每个创可的资源列表不一样

38:15.770 --> 38:16.770
还有自己的哈希

38:16.770 --> 38:18.770
那么第四步就要做的是什么呢

38:18.770 --> 38:19.770
非常简单

38:19.770 --> 38:20.770
就是把每一个

38:20.770 --> 38:21.770
所有的创可的资源

38:21.770 --> 38:22.770
合并起来

38:22.770 --> 38:25.770
形成一个总的资源列表

38:25.770 --> 38:27.770
形成一个总的资源列表

38:27.770 --> 38:28.770
然后呢

38:28.770 --> 38:30.770
在对总的资源列表的内容

38:30.770 --> 38:32.770
全部在统一生成一个哈希

38:32.770 --> 38:34.770
那么这个东西叫做总的哈希

38:34.770 --> 38:36.770
这是这一步要做的事情

38:36.770 --> 38:38.770
那么整个编印过程就完了

38:38.770 --> 38:39.770
就没了

38:39.770 --> 38:41.770
经过了四个步骤

38:41.770 --> 38:43.770
主要的目的

38:43.770 --> 38:44.770
主要的目标是什么

38:44.770 --> 38:46.770
目标生成一个总的

38:46.770 --> 38:47.770
总的资源列表

38:47.770 --> 38:48.770
总的资源列表哪来的

38:48.770 --> 38:50.770
每一个创可给我的

38:50.770 --> 38:51.770
当然目前我们只用了

38:51.770 --> 38:52.770
一个创可

38:52.770 --> 38:54.770
后面我们会说多个创可

38:54.770 --> 38:55.770
那么这个

38:55.770 --> 38:57.770
每一个创可里面资源哪来的

38:57.770 --> 38:58.770
是通过模块

38:58.770 --> 39:00.770
已经我们的配置生成出来的

39:00.770 --> 39:01.770
那么他怎么来找到

39:01.770 --> 39:02.770
这些模块的

39:02.770 --> 39:04.770
怎么来找到这些模块的

39:04.770 --> 39:06.770
他就通过前面这种方式

39:06.770 --> 39:08.770
来找到每一个模块的

39:08.770 --> 39:10.770
而且耿耿的模块里面代码

39:10.770 --> 39:11.770
转换后都代码

39:11.770 --> 39:12.770
ok

39:12.770 --> 39:13.770
这就是第二步

39:13.770 --> 39:15.770
编意要做的事情

39:15.770 --> 39:17.770
好第三步就是输出

39:17.770 --> 39:18.770
最后就是输出

39:18.770 --> 39:20.770
输出就很简单了

39:20.770 --> 39:21.770
你不是已经给我了

39:21.770 --> 39:22.770
一个总的资源列表了吗

39:22.770 --> 39:24.770
我要做的是很简单

39:24.770 --> 39:26.770
因为微拍在漏的环境里面运行

39:26.770 --> 39:27.770
因此他可以使用

39:27.770 --> 39:29.770
fs我好像以前模块号的时候讲的时候

39:29.770 --> 39:31.770
好像介绍过对吧

39:31.770 --> 39:33.770
就是一个文件模块

39:33.770 --> 39:34.770
你没学过也没关系

39:34.770 --> 39:36.770
以后里面学漏的要学的

39:36.770 --> 39:38.770
他可以进行文件处理

39:38.770 --> 39:39.770
读文件要用它

39:39.770 --> 39:40.770
写文件

39:40.770 --> 39:41.770
创建文件

39:41.770 --> 39:42.770
删除文件都要用它

39:42.770 --> 39:43.770
因此他可以利用

39:43.770 --> 39:44.770
漏的里面的这个模块

39:44.770 --> 39:45.770
内置模块

39:45.770 --> 39:46.770
fs

39:46.770 --> 39:47.770
那么来做什么呢

39:47.770 --> 39:49.770
来创建相应的文件

39:49.770 --> 39:50.770
根据什么的创建

39:50.770 --> 39:51.770
根据它里面的文件名

39:51.770 --> 39:53.770
和文件内容来创建

39:53.770 --> 39:54.770
那么

39:54.770 --> 39:56.770
生成相应的文件就完成了

39:56.770 --> 39:57.770
说说输出很简单

39:57.770 --> 39:58.770
输出的过程

39:58.770 --> 39:59.770
有个英文单词叫做

39:59.770 --> 40:00.770
amat

40:01.770 --> 40:02.770
都输出

40:02.770 --> 40:03.770
输出

40:03.770 --> 40:04.770
有的叫做生成

40:04.770 --> 40:06.770
有的叫做发射

40:06.770 --> 40:09.770
发射就翻译的就太直接了

40:09.770 --> 40:10.770
我们一般叫做输出

40:10.770 --> 40:11.770
amat

40:11.770 --> 40:13.770
那么他就会把我们

40:13.770 --> 40:14.770
这个数组里面的

40:14.770 --> 40:16.770
记录的文件名和文件内容

40:16.770 --> 40:18.770
真的把它输出到文件

40:18.770 --> 40:19.770
最终我们就可以看到

40:19.770 --> 40:21.770
这里面的结果了

40:21.770 --> 40:23.770
这就是他整个的便衣过程

40:23.770 --> 40:25.770
分成三个步骤

40:25.770 --> 40:26.770
最后来我们来总结一下

40:26.770 --> 40:28.770
总结一下他的整个过程

40:28.770 --> 40:29.770
当我们敲下

40:29.770 --> 40:30.770
为派个这个命令之后

40:30.770 --> 40:31.770
首先干嘛

40:31.770 --> 40:32.770
初始化

40:32.770 --> 40:33.770
初始化

40:33.770 --> 40:35.770
读取命令参数

40:35.770 --> 40:37.770
读取命令行参数

40:37.770 --> 40:39.770
然后合并的

40:39.770 --> 40:40.770
就是导入配置文件

40:40.770 --> 40:41.770
合并配置对象

40:41.770 --> 40:43.770
总之要形成一个配置对象

40:43.770 --> 40:45.770
然后把这个配置对象交给谁

40:45.770 --> 40:46.770
交给便衣期

40:46.770 --> 40:48.770
便衣期他做什么事情

40:48.770 --> 40:50.770
他可能会有一个创客

40:50.770 --> 40:51.770
有可能会有多个创客

40:51.770 --> 40:53.770
在至少肯定有一个

40:53.770 --> 40:55.770
他可能有一个可能有多个

40:55.770 --> 40:56.770
目前我们只有一个

40:56.770 --> 40:57.770
那么每一个创客里边

40:57.770 --> 40:59.770
他要构建好自己的模块

40:59.770 --> 41:00.770
他把所有的模块

41:00.770 --> 41:01.770
这个创客里边所有的模块

41:01.770 --> 41:03.770
相关的模块找到

41:03.770 --> 41:04.770
怎么找通过入口文件

41:04.770 --> 41:05.770
一个个去找

41:05.770 --> 41:07.770
找到相关的模块之后

41:07.770 --> 41:09.770
他会生成一个资源列表

41:09.770 --> 41:11.770
就是我要最终这个创客

41:11.770 --> 41:13.770
这个块最终会对应哪些资源

41:13.770 --> 41:14.770
生成出来

41:14.770 --> 41:16.770
那么他会有一个什么

41:16.770 --> 41:17.770
每个创客会有自己的ID

41:17.770 --> 41:19.770
名字和哈希

41:19.770 --> 41:21.770
哈希是根据资源列表

41:21.770 --> 41:22.770
来算出来的

41:22.770 --> 41:23.770
好 最后

41:23.770 --> 41:25.770
然后把每一个创客生成的

41:25.770 --> 41:26.770
生成的资源

41:26.770 --> 41:28.770
合并成一个完整的资源

41:28.770 --> 41:30.770
并且生成一个完整的哈希

41:30.770 --> 41:32.770
最终根据完整的资源列表

41:32.770 --> 41:34.770
输出到文件

41:34.770 --> 41:36.770
因为这里边就记录得很详细了

41:36.770 --> 41:37.770
文件名是啥

41:37.770 --> 41:38.770
文件内容是啥

41:38.770 --> 41:40.770
就很容易就输出到文件了

41:40.770 --> 41:41.770
这是整个Webpack

41:41.770 --> 41:43.770
它的编印的过程

41:43.770 --> 41:45.770
然后如果说要详细说的话

41:45.770 --> 41:47.770
那么就是这一部分比较复杂

41:47.770 --> 41:49.770
就是它如何来得到

41:49.770 --> 41:50.770
这么多模块的

41:50.770 --> 41:51.770
因为它只有一个入口文件

41:51.770 --> 41:52.770
它怎么知道

41:52.770 --> 41:54.770
怎么样通过入口文件

41:54.770 --> 41:56.770
来得到这么多模块的

41:56.770 --> 41:58.770
它怎么来做的呢

41:58.770 --> 41:59.770
就是下面那个过程

41:59.770 --> 42:00.770
所以我们刚才很复杂的过程

42:00.770 --> 42:02.770
实际上它解决了什么问题

42:02.770 --> 42:03.770
解决了是这个地方的问题

42:03.770 --> 42:05.770
就如何来生成一个模块的

42:05.770 --> 42:06.770
对应表格

42:06.770 --> 42:07.770
模块ID和模块转换和代码

42:07.770 --> 42:09.770
怎么来生成出来的

42:09.770 --> 42:11.770
因为只有有了模块ID

42:11.770 --> 42:12.770
和模块转换和代码

42:12.770 --> 42:13.770
只有有了这个东西

42:13.770 --> 42:15.770
它才能把它合并到一个文件

42:15.770 --> 42:16.770
才能生成一个文件内容

42:16.770 --> 42:18.770
才能合并到这个文件里边去

42:18.770 --> 42:22.770
它能生成对应的就是支援清单

42:22.770 --> 42:24.770
OK 这就是它整个过程

42:24.770 --> 42:26.770
那么这个过程中它涉及到很多数语

42:26.770 --> 42:28.770
我们再来重新认识一下

42:28.770 --> 42:29.770
这个数语我们每个都讲过了

42:29.770 --> 42:30.770
一个是模块

42:30.770 --> 42:31.770
模块没什么好说的

42:31.770 --> 42:32.770
就是我们GX代码

42:32.770 --> 42:34.770
就是每一个GX文件就是个模块

42:34.770 --> 42:35.770
当然在WebPike里边

42:35.770 --> 42:37.770
它的模块的范畴更广

42:37.770 --> 42:40.770
有可能它不仅仅是一个GS

42:40.770 --> 42:42.770
有可能它不仅仅是一个GS

42:42.770 --> 42:43.770
它有可能是别的

42:43.770 --> 42:45.770
比如说图片 CSS

42:45.770 --> 42:46.770
都可以作为模块

42:46.770 --> 42:47.770
都可以作为模块

42:47.770 --> 42:49.770
那么 CSS 图片这些东西怎么处理

42:49.770 --> 42:51.770
我们后边再说

42:51.770 --> 42:53.770
它可以是任何内容的文件

42:53.770 --> 42:54.770
不仅仅是一个GS

42:54.770 --> 42:55.770
创口是什么呢

42:55.770 --> 42:57.770
创口是WebPike

42:57.770 --> 42:58.770
构建模块的一个块

42:58.770 --> 42:59.770
它就是一个块

42:59.770 --> 43:00.770
你用中文的话

43:00.770 --> 43:01.770
真不知道怎么解释

43:01.770 --> 43:02.770
就是个创口

43:02.770 --> 43:04.770
一个创口它包含多个模块

43:04.770 --> 43:05.770
那么这些模块哪来的

43:05.770 --> 43:08.770
这些模块是通过入口模块分析得来的

43:08.770 --> 43:09.770
所以说我们可以认为

43:09.770 --> 43:11.770
一个创口它一定要对应一个入口模块

43:11.770 --> 43:12.770
它没有入口模块的话

43:12.770 --> 43:13.770
它就不知道

43:13.770 --> 43:15.770
怎么来分析它里面有哪些模块了

43:15.770 --> 43:16.770
对吧

43:16.770 --> 43:17.770
好 怎么叫bondor呢

43:17.770 --> 43:19.770
bondor叫一个捆

43:19.770 --> 43:21.770
就是创口构建好过后

43:21.770 --> 43:23.770
它会生成一个资源清单对吧

43:23.770 --> 43:26.770
你看 这里是不是生成一个资源清单

43:26.770 --> 43:27.770
这个资源清单里面

43:27.770 --> 43:29.770
每一个资源它就称之为一个bondor

43:29.770 --> 43:30.770
就这么简单

43:30.770 --> 43:31.770
你可以认为bondor

43:31.770 --> 43:32.770
就是最重要生成的文件

43:32.770 --> 43:34.770
你看这个文件就是一个bondor

43:34.770 --> 43:35.770
我们就可以认为它是个bondor

43:35.770 --> 43:36.770
只是一个数语

43:36.770 --> 43:39.770
这么一种教法

43:39.770 --> 43:40.770
你可以很形象

43:40.770 --> 43:41.770
你可以很形象

43:41.770 --> 43:42.770
一捆 怎么叫一捆

43:42.770 --> 43:44.770
就是把我们的很多文件捆在一起的

43:44.770 --> 43:45.770
对吧

43:45.770 --> 43:46.770
成了一个文件 就是一捆

43:46.770 --> 43:48.770
bondor 就是捆的意思

43:48.770 --> 43:49.770
哈希

43:49.770 --> 43:51.770
我们平时在微拍颗里面说哈希

43:51.770 --> 43:52.770
一般说的是什么呢

43:52.770 --> 43:56.770
说的是最终的资源清单里面生成了哈希

43:56.770 --> 43:58.770
指的是这个

43:58.770 --> 44:02.770
最终的资源清单里面生成了哈希

44:02.770 --> 44:04.770
那么还有一种叫做创口哈希

44:04.770 --> 44:07.770
指的是某一个创口里面

44:07.770 --> 44:09.770
它生成的资源清单里面的

44:09.770 --> 44:11.770
对应哈希

44:11.770 --> 44:13.770
这两种教法要熟悉

44:13.770 --> 44:14.770
还有一个是创口内

44:14.770 --> 44:16.770
每一个创口还有一个名字

44:16.770 --> 44:17.770
如果说默认情况下

44:17.770 --> 44:18.770
它是叫做妹

44:18.770 --> 44:20.770
如果说没有使用配置叫做妹

44:20.770 --> 44:21.770
这个名字

44:21.770 --> 44:22.770
好 ID

44:22.770 --> 44:24.770
每一个创口有一个唯一编号

44:24.770 --> 44:25.770
如果是开发环境的话

44:25.770 --> 44:27.770
它跟那个创口的名字是一样的

44:27.770 --> 44:28.770
如果是生产环境的话

44:28.770 --> 44:30.770
它是一个从零开始的数字

44:30.770 --> 44:33.770
这就是我们这一刻要讲的编印过程

44:33.770 --> 44:35.770
这里我刚刚想起来了

44:35.770 --> 44:37.770
还有一个小的地方

44:37.770 --> 44:38.770
我说一下就行了

44:38.770 --> 44:39.770
就说什么呢

44:39.770 --> 44:43.770
如果说我们开启了什么Watch

44:43.770 --> 44:46.770
我们之前是不是做过监控对吧

44:46.770 --> 44:48.770
开启监控 监控文件变化

44:48.770 --> 44:50.770
那么如果说开启了Watch之后

44:50.770 --> 44:53.770
你每一次文件变化

44:53.770 --> 44:55.770
我在这里画一下就行了

44:55.770 --> 44:59.270
你每一次的文件变化

44:59.270 --> 45:01.270
这当文件发生变化之后

45:01.270 --> 45:05.270
它又会从这里开始

45:05.270 --> 45:07.270
它不会再从初始化开始了

45:07.270 --> 45:08.270
初始化的工作不做了

45:08.270 --> 45:10.270
它又会重新进行编译

45:10.270 --> 45:14.030
比如说这里

45:18.030 --> 45:20.030
只当文件发生变化的时候

45:20.030 --> 45:22.030
它又会重新编译一次

45:22.030 --> 45:23.030
重新走一次的这个过程

45:23.030 --> 45:26.030
就这么个意思

45:26.030 --> 45:28.030
这就是关于它的编译过程

45:28.030 --> 45:30.030
那么最后我们来看一下

45:30.030 --> 45:33.030
我现在配置文件里边

45:33.030 --> 45:36.030
改动一个东西叫dev2

45:36.030 --> 45:38.030
取个名字

45:39.030 --> 45:41.030
就SourceMap

45:41.030 --> 45:43.030
比方说我们这样配置到之后

45:43.030 --> 45:45.030
我们现在再来看一次

45:45.030 --> 45:46.030
为了派对打包过程

45:46.030 --> 45:47.030
你就会发现了很多东西

45:47.030 --> 45:50.730
你能看得明白了

45:50.730 --> 45:53.730
来 一个一行一行看

45:53.730 --> 45:55.730
这是我们的书的命令对吧

45:55.730 --> 45:57.730
第一行哈希

45:57.730 --> 45:58.730
什么意思

45:58.730 --> 46:01.730
就是指的是最终的

46:01.730 --> 46:03.730
最终的这个地方

46:03.730 --> 46:05.730
最终的支援列表生成了哈希字

46:05.730 --> 46:07.730
就这么个意思

46:08.730 --> 46:09.730
Version什么意思

46:09.730 --> 46:10.730
Version表示我们使用了

46:10.730 --> 46:12.730
Webpack的版本

46:12.730 --> 46:14.730
Time这个很简单

46:14.730 --> 46:15.730
用了多少时间

46:15.730 --> 46:16.730
用了111毫秒

46:16.730 --> 46:17.730
完成了构建

46:17.730 --> 46:19.730
构建的时间点在这

46:19.730 --> 46:21.730
这是我们目前的电脑时间

46:21.730 --> 46:22.730
接下来有个表格

46:22.730 --> 46:23.730
这个表格看着

46:23.730 --> 46:25.730
这个表格就很有意思了

46:25.730 --> 46:26.730
二Set什么意思

46:26.730 --> 46:28.730
资源对吧

46:28.730 --> 46:29.730
来看这个表格的标题

46:29.730 --> 46:31.730
这是我们的资源名字

46:31.730 --> 46:33.730
它相当于这个表格里边是啥

46:33.730 --> 46:35.730
这个表格里边就是这个资源清单

46:35.730 --> 46:36.730
它就可以打印出来的

46:36.730 --> 46:38.730
这边的资源清单

46:38.730 --> 46:39.730
来吧

46:39.730 --> 46:40.730
看一下

46:40.730 --> 46:42.730
这是我们的资源size

46:42.730 --> 46:43.730
表这个资源的大小

46:43.730 --> 46:44.730
多少kb

46:44.730 --> 46:45.730
Trunk

46:45.730 --> 46:46.730
什么意思

46:46.730 --> 46:49.730
这里边指的是Trunk的ID

46:49.730 --> 46:51.730
这一列是Trunk的ID

46:51.730 --> 46:52.730
就是你这个资源

46:52.730 --> 46:53.730
是来自于哪一个Trunk

46:53.730 --> 46:55.730
你看因为我们这里的资源清单

46:55.730 --> 46:56.730
是不是都是Trunk给我们的

46:56.730 --> 46:57.730
对吧

46:57.730 --> 46:58.730
是不是都是Trunk

46:58.730 --> 47:00.730
通过Trunk给我们的资源清单

47:00.730 --> 47:01.730
对吧

47:01.730 --> 47:02.730
那么你每一个资源

47:02.730 --> 47:03.730
它一定是有一个Trunk

47:03.730 --> 47:04.730
来自于一个Trunk

47:04.730 --> 47:05.730
但是也不一定

47:05.730 --> 47:06.730
我们后续会学习

47:06.730 --> 47:07.730
有些资源

47:07.730 --> 47:08.730
它可以没有Trunk生成

47:08.730 --> 47:09.730
我们后表会说

47:09.730 --> 47:10.730
后表会说

47:10.730 --> 47:11.730
现在不用管

47:11.730 --> 47:12.730
那么现在我们看到

47:12.730 --> 47:14.730
每一个资源它都有个TrunkID

47:14.730 --> 47:15.730
AMH的表示的意思

47:15.730 --> 47:16.730
表示

47:16.730 --> 47:18.730
是否已经

47:18.730 --> 47:20.730
生成了

47:20.730 --> 47:21.730
AMH表示生成

47:21.730 --> 47:23.730
或者是叫做输出

47:23.730 --> 47:24.730
是否已经输出成文件

47:24.730 --> 47:25.730
它是个过去完成时

47:25.730 --> 47:26.730
对吧

47:26.730 --> 47:27.730
表示这个资源

47:27.730 --> 47:28.730
已经输出成了文件

47:28.730 --> 47:29.730
当然这个不是标题

47:29.730 --> 47:30.730
把标题看完

47:30.730 --> 47:31.730
TrunkNames表示什么

47:31.730 --> 47:33.730
它Trunk对你的名称

47:34.730 --> 47:35.730
咱们看一下

47:35.730 --> 47:36.730
这个表格的内容

47:36.730 --> 47:40.730
第一行

47:40.730 --> 47:41.730
资源名字

47:41.730 --> 47:43.730
然后尺寸

47:43.730 --> 47:44.730
四点几KB

47:44.730 --> 47:46.730
然后它的ID是什么

47:46.730 --> 47:47.730
我们知道

47:47.730 --> 47:49.730
在开发环境下边

47:49.730 --> 47:50.730
这种环境下边

47:50.730 --> 47:53.730
它的ID跟名字是一样的

47:53.730 --> 47:54.730
是不是跟Trunk的名字

47:54.730 --> 47:55.730
是一样的

47:55.730 --> 47:56.730
你看这两个文件

47:56.730 --> 47:57.730
是不是都是同一个Trunk

47:57.730 --> 47:58.730
来构建出来的

47:58.730 --> 47:59.730
所以他们的Trunk的名字

47:59.730 --> 48:00.730
和ID

48:00.730 --> 48:01.730
Trunk名字

48:01.730 --> 48:02.730
TrunkID

48:02.730 --> 48:04.730
它的ID跟名字是一样的

48:04.730 --> 48:05.730
下面是不是这个文件

48:05.730 --> 48:07.730
也是三个多KB

48:07.730 --> 48:09.730
然后它的TrunkID是这个

48:09.730 --> 48:10.730
名字也是这个

48:10.730 --> 48:11.730
因为开发环境

48:11.730 --> 48:12.730
也生成出来了

48:12.730 --> 48:14.730
后面他给你加了一个电影

48:14.730 --> 48:15.730
表示这个东西

48:15.730 --> 48:17.730
是用来做开发调试的

48:17.730 --> 48:19.730
还给加了这么一个属性在这

48:19.730 --> 48:20.730
接下来我们下面

48:20.730 --> 48:21.730
再看一下

48:21.730 --> 48:23.730
EntryPoint

48:23.730 --> 48:25.730
EntryPoint表示什么意思

48:25.730 --> 48:26.730
表示入口

48:26.730 --> 48:28.730
表示入口的意思

48:28.730 --> 48:30.730
入口是什么

48:30.730 --> 48:31.730
入口是Mate

48:31.730 --> 48:32.730
Mate这个Trunk

48:32.730 --> 48:34.730
它这里指的是Trunk的名字

48:34.730 --> 48:35.730
Trunk的名字

48:35.730 --> 48:36.730
我们使用Trunk

48:36.730 --> 48:37.730
Mate这个Trunk作为入口

48:37.730 --> 48:38.730
你没有配置它的

48:38.730 --> 48:40.730
默认名字就是Mate

48:40.730 --> 48:41.730
它只有一个入口

48:41.730 --> 48:43.730
就是Mate这个Trunk

48:43.730 --> 48:44.730
那么这个Trunk里面

48:44.730 --> 48:46.730
它最终对应生成出来的文件有哪些

48:46.730 --> 48:47.730
有Mate.js

48:47.730 --> 48:48.730
Mate.js

48:48.730 --> 48:49.730
Map

48:49.730 --> 48:50.730
它就这么个意思

48:50.730 --> 48:51.730
就是这个是入口

48:51.730 --> 48:52.730
然后这是它的输出

48:52.730 --> 48:54.730
这是一个简化版本

48:54.730 --> 48:56.730
那么它具体的构建过程

48:56.730 --> 48:58.730
它怎么构建的呢

48:58.730 --> 48:59.730
那么它加载过程是

48:59.730 --> 49:00.730
地规加载的

49:00.730 --> 49:01.730
它加载的三个模块

49:01.730 --> 49:03.730
A B C

49:03.730 --> 49:04.730
你看这个东西是不是

49:04.730 --> 49:05.730
模块的ID

49:05.730 --> 49:06.730
模块的ID

49:06.730 --> 49:07.730
模块的ID

49:07.730 --> 49:08.730
对吧

49:08.730 --> 49:09.730
每个模块的字节

49:09.730 --> 49:10.730
字节

49:10.730 --> 49:11.730
就这么个意思

49:12.730 --> 49:13.730
Mate就是它

49:13.730 --> 49:14.730
这个模块是谁

49:14.730 --> 49:15.730
哪个Trunk来构建的

49:15.730 --> 49:16.730
是Mate

49:16.730 --> 49:17.730
这个Trunk来构建的

49:17.730 --> 49:18.730
比如说就表示

49:18.730 --> 49:19.730
已经完成构建了

49:19.730 --> 49:21.730
你看

49:21.730 --> 49:22.730
好像这个东西

49:22.730 --> 49:23.730
好像很复杂的样子

49:23.730 --> 49:24.730
那么我们了解了

49:24.730 --> 49:25.730
原理之后

49:25.730 --> 49:26.730
看这个玩意

49:26.730 --> 49:27.730
是不是非常清楚了

49:27.730 --> 49:28.730
明了

49:28.730 --> 49:30.730
就可以看得到结果了

49:30.730 --> 49:31.730
ok

49:31.730 --> 49:32.730
这就是

49:33.730 --> 49:34.730
vipack

49:34.730 --> 49:35.730
它的编译过程

49:35.730 --> 49:36.730
以及vipack

49:36.730 --> 49:37.730
它的输出

49:37.730 --> 49:38.730
它到底是什么意思

49:38.730 --> 49:39.730
这东西很重要的

49:39.730 --> 49:41.730
因为我其实

49:41.730 --> 49:42.730
我讲课

49:42.730 --> 49:43.730
特别重视原理

49:43.730 --> 49:44.730
我原理这一块

49:44.730 --> 49:46.730
我尽量啰嗦一点都没关系

49:46.730 --> 49:47.730
我觉得

49:47.730 --> 49:48.730
像什么API这一块

49:48.730 --> 49:49.730
API

49:49.730 --> 49:50.730
什么单词

49:50.730 --> 49:51.730
什么方法

49:51.730 --> 49:52.730
这些我觉得一点都不重要

49:52.730 --> 49:53.730
你学完就忘了

49:53.730 --> 49:54.730
都没关系

49:54.730 --> 49:56.730
因为你只要抓住了

49:56.730 --> 49:57.730
就抓住了核心

49:57.730 --> 49:59.730
API忘了一查文档

49:59.730 --> 50:02.730
但是你文档里边很难查到原理的

50:02.730 --> 50:03.730
所以这个东西

50:03.730 --> 50:05.730
这结果我建大家

50:05.730 --> 50:07.730
至少听两遍

50:07.730 --> 50:09.730
而且听两遍之后

50:09.730 --> 50:10.730
还不要玩就玩

50:10.730 --> 50:11.730
就把算了

50:11.730 --> 50:12.730
因为这是原理

50:12.730 --> 50:13.730
你没事的时候

50:13.730 --> 50:14.730
不要在公交车上

50:14.730 --> 50:15.730
在地铁上

50:15.730 --> 50:16.730
或者是你寝室里面

50:16.730 --> 50:17.730
西德纳

50:17.730 --> 50:18.730
晚上你没啥事

50:18.730 --> 50:20.730
你脑袋里面就回忆一下

50:20.730 --> 50:21.730
vipack的编译过程

50:21.730 --> 50:23.730
多去回忆一下这个编译过程

50:23.730 --> 50:25.730
如果说你在脑袋里面

50:25.730 --> 50:26.730
把这个编译过程

50:26.730 --> 50:28.730
非常熟练的

50:28.730 --> 50:29.730
就能够回忆出来

50:29.730 --> 50:31.730
它整个过程是什么回事

50:31.730 --> 50:32.730
非常熟练的回说

50:32.730 --> 50:33.730
其实就看这两张图

50:33.730 --> 50:34.730
这张图

50:34.730 --> 50:35.730
整个过程的图

50:35.730 --> 50:36.730
已经了

50:36.730 --> 50:38.730
这里是指的是

50:38.730 --> 50:40.730
这一块怎么出来的

50:40.730 --> 50:41.730
这一块怎么出来的

50:41.730 --> 50:43.730
把这张图再好好想一想

50:43.730 --> 50:44.730
那么你如果说你脑袋里面

50:44.730 --> 50:46.730
能够形成这两张图的话

50:46.730 --> 50:48.730
对它就非常熟悉了

50:48.730 --> 50:49.730
那么你后边学习

50:49.730 --> 50:50.730
什么夹载器

50:50.730 --> 50:52.730
而且插件的就非常简单了

50:52.730 --> 50:53.730
就非常容易理解了

50:53.730 --> 50:56.730
这是关于wipack的编译过程

50:56.730 --> 50:57.730
很重要

50:57.730 --> 50:58.730
大家多看两遍

