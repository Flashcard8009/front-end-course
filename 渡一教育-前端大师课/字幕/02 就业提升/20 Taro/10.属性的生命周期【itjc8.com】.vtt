WEBVTT

00:00.050 --> 00:02.410
好 我们继续讲解Tarot的系列课程

00:02.410 --> 00:05.570
系列课呢 给大家讲解一下组件的生命周期

00:05.570 --> 00:08.690
在上一节课中呢 我们简单给大家介绍到了

00:08.690 --> 00:11.490
我们怎么样在Tarot中呢 去调用我们的组件

00:11.490 --> 00:15.090
并且去做组件的一些数据传送

00:15.090 --> 00:16.810
我们怎么样把数据传进去

00:16.810 --> 00:19.490
通过我们的Tutorial模式

00:19.490 --> 00:22.250
或者是通过Priority的直接属性格式

00:22.250 --> 00:26.130
我们都可以把我们现在的一些数据传送进去

00:26.130 --> 00:27.250
那么在组件中呢

00:27.250 --> 00:31.330
我们还有一些和我们页面中不一样的生命周期

00:31.330 --> 00:33.450
那么在这节课呢 给大家讲一下

00:33.450 --> 00:36.410
组件的生命周期呢 主要是有几个内容

00:36.410 --> 00:38.810
那包括是它有Amount

00:38.810 --> 00:41.890
表示的是它现在的一个触发

00:41.890 --> 00:44.410
或者说称之为渲染的一个点

00:44.410 --> 00:48.490
同时呢 它是有它加载 装载的一个点

00:48.490 --> 00:51.690
同时它有更新的点和它的一个卸载点

00:51.690 --> 00:53.090
好 我们现在呢

00:53.090 --> 01:02.340
先打开我们的程序 我们来看一下

01:02.340 --> 01:04.940
首先我们在我们之前的项目中

01:04.940 --> 01:06.740
我们可以有一个小组件

01:06.740 --> 01:07.860
这个组件很简单

01:07.860 --> 01:11.340
我们只是做了一个简单的显示

01:11.340 --> 01:12.980
然后在这个显示过程中呢

01:12.980 --> 01:16.060
我们做了几件事 我们简单看一看

01:16.060 --> 01:17.340
首先 第一个

01:17.340 --> 01:20.500
我们组件的写法和我们做页面的时候是一样的

01:20.500 --> 01:23.900
都是通过Component的方式把值传进来

01:23.900 --> 01:25.580
Component的方式做继承

01:25.580 --> 01:26.540
继承以后的话呢

01:26.540 --> 01:29.860
我们传直的方式依然用This.Purpose

01:29.860 --> 01:31.140
这样的方式来做

01:31.140 --> 01:32.540
This.Purpose的话呢

01:32.540 --> 01:33.940
我们后面可以跟上

01:33.940 --> 01:36.700
1 你自行定义的组件的名称

01:36.700 --> 01:37.980
属性名称

01:37.980 --> 01:39.220
属性名称在哪里呢

01:39.220 --> 01:42.180
我们只需要把它组件写完以后

01:42.180 --> 01:43.820
然后在使用方

01:43.820 --> 01:46.060
也就是我们所谓的调用点上

01:46.060 --> 01:47.500
我们来做这个事情

01:47.500 --> 01:48.620
调用点的第一步呢

01:48.620 --> 01:50.420
我们需要去引入组件

01:50.420 --> 01:51.500
引入组件的方式

01:51.500 --> 01:53.220
利用Import方式来做

01:53.220 --> 01:53.820
第二步呢

01:53.820 --> 01:57.100
我们通过你现在的引入组件以后的名称

01:57.100 --> 01:58.740
Dialogue 我现在起的是

01:58.740 --> 02:00.620
所以我们就可以把它给展示出来

02:00.660 --> 02:01.260
同时呢

02:01.260 --> 02:03.740
我们可以后面自行设定一些属性

02:03.740 --> 02:05.620
那么在我们其他的一些

02:05.620 --> 02:06.140
呃

02:06.140 --> 02:06.460
那个

02:06.460 --> 02:08.220
比如说在我们的npview中呢

02:08.220 --> 02:09.940
我们还需要去做什么

02:09.940 --> 02:11.140
Component的全局定义

02:11.140 --> 02:11.820
View意义里面

02:11.820 --> 02:12.420
对吧

02:12.420 --> 02:13.660
然后再去做这个事情

02:13.660 --> 02:14.260
在属性里面

02:14.260 --> 02:16.020
还有Purpose的一个定义

02:16.020 --> 02:16.820
但是在这边呢

02:16.820 --> 02:18.380
我们只需要直接写上去

02:18.380 --> 02:19.020
写好以后

02:19.020 --> 02:20.780
我们直接在组件里面

02:20.780 --> 02:21.700
直接用就行了

02:21.700 --> 02:24.140
直接Purpose的拿出来就可以用到

02:24.140 --> 02:25.740
这是非常方便的一种

02:25.740 --> 02:26.180
第二种呢

02:26.180 --> 02:27.100
我们刚才看到的

02:27.100 --> 02:28.060
这边有个Qtune

02:28.060 --> 02:29.260
Qtune的方式是指

02:29.260 --> 02:32.060
我们可以去拿取这个组件的

02:32.060 --> 02:33.180
紫节点

02:33.180 --> 02:33.620
所以呢

02:33.620 --> 02:35.700
我们看到我们里面有个Button按钮

02:35.700 --> 02:36.860
我们这Button按钮呢

02:36.860 --> 02:39.660
就直接通过这样的标签的方式

02:39.660 --> 02:41.980
它就可以显示在我们组件里面

02:41.980 --> 02:44.100
看到这边有一个啊

02:44.100 --> 02:44.820
这个按钮啊

02:44.820 --> 02:45.580
Button

02:45.580 --> 02:47.300
这按钮可以显示出来

02:47.300 --> 02:48.180
同样的

02:48.180 --> 02:48.940
我们看一下

02:48.940 --> 02:50.220
我们刷新一下

02:51.500 --> 02:52.380
同样的这个按钮

02:52.380 --> 02:53.700
你看是可以的

02:53.700 --> 02:54.620
我们里面做实践

02:54.620 --> 02:55.540
依然是可以啊

02:55.540 --> 02:57.180
只是我们现在先把它放进来

02:57.180 --> 02:58.300
那么接下来

02:58.340 --> 03:00.020
我们来看一下我们的

03:01.260 --> 03:02.940
组件里面生命周期

03:02.940 --> 03:04.380
我们在之前的话呢

03:04.380 --> 03:05.100
我们说过

03:05.100 --> 03:07.100
组件本身是继承自我们的

03:07.100 --> 03:08.060
component的

03:08.060 --> 03:08.780
也就意味着

03:08.780 --> 03:13.060
它依然是要有触发和完成这样一个状态

03:13.060 --> 03:13.420
所以呢

03:13.420 --> 03:14.940
我们这边来写一下

03:14.940 --> 03:18.420
我们把之前在PPT上的几个分别来说一下

03:18.420 --> 03:25.920
组件的生命周期

03:25.920 --> 03:27.000
首先第一个

03:27.000 --> 03:28.000
我们写一下啊

03:28.000 --> 03:29.520
看他的提示非常全

03:30.400 --> 03:31.320
component

03:32.400 --> 03:34.120
well mount

03:34.160 --> 03:42.340
这样的一个

03:42.340 --> 03:43.260
我们写一下

03:43.260 --> 03:48.000
他是叫做组件

03:48.000 --> 03:50.040
加载时出发的

03:51.560 --> 03:55.060
他一个组件

03:55.060 --> 04:01.000
他只会组件只会掉一次

04:02.760 --> 04:08.740
那么在此期间

04:08.740 --> 04:09.620
动

04:09.620 --> 04:16.420
也就是我们的页面的结构

04:16.420 --> 04:17.020
还未

04:18.780 --> 04:19.300
准备好

04:20.860 --> 04:21.300
所以

04:22.500 --> 04:23.660
不能和试图

04:25.020 --> 04:26.420
进行互动

04:26.420 --> 04:27.460
这点你需要知道

04:27.460 --> 04:28.820
不能和试图进行互动

04:28.820 --> 04:32.540
所以一些所谓的页面的数据改变啊

04:32.540 --> 04:33.980
什么你都不能在这里面做

04:33.980 --> 04:36.500
他只是作为我们组件

04:36.500 --> 04:38.780
开始进入组件的一个通知

04:39.460 --> 04:41.140
所以我们一般性在里面

04:41.140 --> 04:42.460
只做一些

04:43.460 --> 04:44.340
记录啊

04:44.340 --> 04:47.640
或者说提示啊

04:47.640 --> 04:49.360
组件开始

04:50.000 --> 04:50.840
运行

04:51.520 --> 04:53.000
做这样的一个提示

04:53.720 --> 04:55.840
不和界面元素有关的就可以

04:56.760 --> 04:57.600
那么第二个

04:59.200 --> 05:00.080
component

05:02.820 --> 05:04.820
component did a mount

05:07.740 --> 05:08.660
component did a mount

05:09.100 --> 05:10.500
我们console了点log

05:11.060 --> 05:12.420
然后我们写上的是

05:12.420 --> 05:14.420
这里边是什么呢

05:14.420 --> 05:27.800
叫做初次宣染完成

05:29.400 --> 05:30.680
所以我们在上面写一下

05:35.110 --> 05:36.630
初次宣染完成以后

05:37.670 --> 05:38.230
出发

05:39.150 --> 05:40.350
那么一个组件

05:41.470 --> 05:42.270
指挥

05:43.750 --> 05:44.550
调用一次

05:45.070 --> 05:48.380
它代表一下

05:48.380 --> 05:49.700
叫做组件

05:50.540 --> 05:56.210
已经准备完毕

05:58.010 --> 06:01.900
可以和试图

06:03.260 --> 06:04.140
进行交互

06:05.980 --> 06:07.660
所有的一些交互操作

06:07.660 --> 06:09.500
从它一起来说

06:09.500 --> 06:10.860
你是可以进行

06:10.860 --> 06:12.300
代码的一些书写了

06:13.300 --> 06:14.700
我们继续往下啊

06:14.700 --> 06:15.580
这两个的话呢

06:15.580 --> 06:16.660
都是完成一次的

06:17.500 --> 06:18.860
那么下面这个呢

06:18.860 --> 06:19.780
我们讲啊

06:19.780 --> 06:20.860
我们有一个叫做

06:21.500 --> 06:23.700
倒是属于我们在运行之前

06:23.700 --> 06:25.620
可以预夹在一些数据的

06:26.300 --> 06:28.100
叫做component

06:29.980 --> 06:30.580
well

06:34.620 --> 06:35.380
receive

06:35.860 --> 06:36.460
purpose

06:37.100 --> 06:38.140
receive purpose

06:38.660 --> 06:40.740
它可以有一个叫做nexter

06:43.660 --> 06:45.100
purpose的参数接受

06:45.660 --> 06:46.780
它是干嘛用的呢

06:47.340 --> 06:48.420
它其实是

06:50.060 --> 06:51.820
已经装载

06:54.030 --> 06:55.710
已经装载的组件

06:57.270 --> 06:59.070
在接收到

07:01.940 --> 07:04.260
新的属性

07:04.660 --> 07:05.900
前调用

07:08.710 --> 07:09.710
理解这个逻辑

07:10.270 --> 07:13.030
我们属性在显示完成以后的话

07:13.390 --> 07:14.950
它显示内容没有关系

07:15.310 --> 07:18.150
但是一旦我现在外部

07:18.550 --> 07:20.510
有一个新的属性值

07:20.670 --> 07:22.790
需要对它进行修改

07:22.790 --> 07:24.950
和再次传入数据的时候

07:24.950 --> 07:26.430
那么它会被触发

07:27.150 --> 07:27.910
咱们举例

07:28.030 --> 07:31.190
就是说我们本身有一个显示属性

07:31.190 --> 07:31.910
my tester

07:31.910 --> 07:32.550
我的文本

07:32.550 --> 07:33.270
或这样的

07:33.470 --> 07:33.910
但是呢

07:33.910 --> 07:34.990
你突然在这边说

07:34.990 --> 07:36.310
我改变了我的文本

07:36.310 --> 07:37.230
那这种时候呢

07:37.230 --> 07:38.870
它就会触发这样的一个内容

07:39.230 --> 07:39.590
所以呢

07:39.590 --> 07:40.710
我们这边里面呢

07:40.710 --> 07:42.670
我们先给它做个提示

07:42.670 --> 07:43.470
看一下

07:45.300 --> 07:46.580
我们显示一下

07:48.260 --> 07:54.630
这是接收到新数据时

07:55.390 --> 07:55.790
的

07:57.760 --> 07:58.760
做这个动作

07:59.960 --> 08:01.880
我们前面当前属性有两个

08:01.920 --> 08:03.800
当前的组件有两个属性

08:03.800 --> 08:04.280
对吧

08:04.280 --> 08:06.240
我们现在打开的时候

08:06.240 --> 08:07.200
它里面的值

08:07.200 --> 08:08.520
它第一次接收的时候

08:08.520 --> 08:09.280
就是我的文本

08:09.280 --> 08:09.360
啊

08:09.360 --> 08:09.680
杰森

08:09.680 --> 08:10.080
呢

08:10.080 --> 08:10.760
传进来

08:10.760 --> 08:12.360
那么它肯定是不会触发的

08:12.360 --> 08:13.360
我们来运行一下

08:13.360 --> 08:15.160
看一下接收到新数据时

08:18.770 --> 08:19.810
看有没有

08:19.970 --> 08:21.690
中文接收到新数据时

08:21.770 --> 08:22.410
没有

08:22.690 --> 08:23.570
那就表示的是

08:23.570 --> 08:25.810
它现在属于一个正常的状态

08:25.970 --> 08:26.850
不会触发

08:27.130 --> 08:29.370
它只有接收到新数据的时候

08:29.370 --> 08:30.610
它才会进行触发

08:30.770 --> 08:31.970
它是在这个点上

08:32.090 --> 08:33.930
那么新数据怎么怎么做呢

08:33.930 --> 08:34.650
我们这样

08:34.650 --> 08:36.610
你看我这边写一个改变

08:36.610 --> 08:38.250
我写一个方法出来

08:38.250 --> 08:40.850
写一个我们简单的一个按钮

08:41.170 --> 08:42.450
这个按钮我们点下去

08:42.450 --> 08:43.530
我们改变一个值

08:43.530 --> 08:44.410
ChangerValue

08:44.530 --> 08:45.530
我们往上

08:45.890 --> 08:48.090
我们看到这边有一个ChangerValue

08:48.090 --> 08:50.130
我们去对一个Login去改变

08:51.930 --> 08:53.850
改变后的值

08:54.530 --> 08:55.930
那么Login的

08:55.930 --> 08:56.970
Login的话呢

08:56.970 --> 08:57.450
在哪里

08:57.450 --> 08:58.730
我们做的Status

08:58.730 --> 08:59.850
所以我们往上看

09:00.290 --> 09:02.410
我们上面有一个Status里面

09:02.610 --> 09:04.210
本身存储了一个Login

09:04.250 --> 09:05.250
叫做还有内容

09:05.250 --> 09:06.650
是在我们前面案例中的

09:06.970 --> 09:09.050
所以我们把这个值给改了

09:09.050 --> 09:10.210
我们不是我的文本

09:10.490 --> 09:11.850
我们把它变成的是

09:12.010 --> 09:12.970
this点

09:17.860 --> 09:18.660
this点

09:19.540 --> 09:20.900
status点

09:21.460 --> 09:22.100
Login

09:22.780 --> 09:25.260
这时候你刚开始传进去的时候

09:25.260 --> 09:26.740
里面应该显示还有文本

09:27.700 --> 09:28.100
对吧

09:28.100 --> 09:28.820
还有内容

09:28.900 --> 09:29.660
还有内容

09:29.980 --> 09:32.580
但是当我在点击这个按钮的时候

09:32.580 --> 09:33.860
一旦我在点击这个按钮的时候

09:33.860 --> 09:36.660
它触发了我们现在的ChangerValue

09:36.980 --> 09:39.580
ChangerValue里面直接改变了Login的值

09:39.580 --> 09:41.100
而Login的值得一改变

09:41.100 --> 09:42.660
由于我们采用了

09:42.660 --> 09:44.140
我们现在的一个模式

09:44.140 --> 09:45.260
就是Status的值

09:45.260 --> 09:46.700
它会自动来完成

09:46.700 --> 09:48.660
你现在这里面数据的改变

09:48.660 --> 09:52.020
所以意味着主键里面的MyTest的这个属性

09:52.020 --> 09:54.180
它重新得到了一个新值

09:54.180 --> 09:55.380
那么这就意味着

09:55.380 --> 09:57.140
它在接收到数据以后

09:57.140 --> 09:58.860
那么应该是这个内容

09:58.860 --> 09:59.860
会已经触发了

09:59.860 --> 10:00.780
我们来看一下

10:03.300 --> 10:04.020
打开

10:05.740 --> 10:06.740
这按钮在后面

10:06.820 --> 10:08.860
我们把这个框再往下一点

10:08.860 --> 10:10.500
我们把框再往下一点

10:11.620 --> 10:12.740
我们进到这里面

10:12.740 --> 10:13.940
我们把它高度

10:14.940 --> 10:17.620
框的高度往下调400

10:18.540 --> 10:19.740
这样大家看得见

10:22.460 --> 10:23.020
对吧

10:23.020 --> 10:24.220
有一个改变

10:24.740 --> 10:26.220
我把这边全部删掉

10:26.220 --> 10:28.100
这边保持一个Consolord的清空

10:28.100 --> 10:28.940
点下去

10:29.220 --> 10:29.940
咱们看

10:30.060 --> 10:31.420
改变后的值

10:31.420 --> 10:33.620
是不是组件里面的这部分内容

10:33.620 --> 10:34.580
进行变化了

10:34.820 --> 10:37.660
那么这是我在我调用端

10:37.780 --> 10:40.660
直接完成了一个State值的调用的改变

10:40.660 --> 10:43.100
但是它直接影响到了组件里面的

10:43.100 --> 10:44.380
这是很正常的过程

10:44.380 --> 10:45.460
但是你看这边

10:45.660 --> 10:46.980
接收到新数据时

10:46.980 --> 10:48.820
是不是这个所谓的

10:48.820 --> 10:51.580
叫做well received perverts

10:51.580 --> 10:52.580
进行了操作

10:53.060 --> 10:55.260
那么它操作以后的话

10:55.260 --> 10:56.740
它可以得到什么

10:56.940 --> 11:00.140
它可以得到你当前的属性里面的

11:00.140 --> 11:01.260
一个运行值

11:01.380 --> 11:02.420
我们来看一下

11:04.920 --> 11:06.840
我们把这个值拿出来

11:07.040 --> 11:08.080
或者我们直接写在后面

11:15.740 --> 11:16.700
咱们就点开

11:17.460 --> 11:17.700
好

11:17.700 --> 11:18.500
咱们来看这边

11:19.060 --> 11:19.780
主要是这个

11:19.780 --> 11:21.220
接收到数据后面的值

11:21.500 --> 11:24.700
它是指拿到你当前属性里面

11:24.700 --> 11:25.820
改变后的值

11:26.060 --> 11:28.260
看到我属性有两个

11:28.260 --> 11:30.100
一个是我没有变化过的

11:30.100 --> 11:31.620
my name是个json

11:31.820 --> 11:34.300
第二个是我改变以后的

11:34.420 --> 11:35.860
我原来的值是要什么

11:35.860 --> 11:36.780
还有内容

11:36.860 --> 11:39.900
而我改变以后的值变成了改变后的值

11:39.900 --> 11:41.500
它会得到这个数据

11:41.700 --> 11:44.860
那么在得到这个数据的那个时候

11:44.940 --> 11:45.820
说一下

11:45.980 --> 11:47.980
在你得到这个数据的时候

11:48.100 --> 11:49.060
那么注意

11:49.220 --> 11:51.220
还没有去改变

11:51.220 --> 11:53.300
还没有去改变你现在

11:53.300 --> 11:56.660
页面中的整个的属性里面的这个操作

11:56.820 --> 11:57.820
它还没有改变

11:58.020 --> 11:58.700
注意一下

11:58.700 --> 11:59.820
是在这个点上

12:00.500 --> 12:01.900
它是前调用的

12:01.900 --> 12:03.580
所以你在改变之前

12:03.580 --> 12:05.140
你这边可以做一些事

12:05.620 --> 12:07.860
当然我们还有一个属性

12:07.860 --> 12:08.740
更有意思

12:08.740 --> 12:10.340
或者称为生命周期

12:10.620 --> 12:13.020
它并不是我们平时大家看到的

12:13.020 --> 12:14.580
就是component的开头

12:14.780 --> 12:16.380
那么在我的PPG我也写到了

12:16.380 --> 12:17.660
如果你注意到的话

12:17.860 --> 12:19.220
它shed的开头

12:19.780 --> 12:21.380
shed component update

12:21.380 --> 12:23.260
它会有一个这个次出现

12:23.940 --> 12:27.460
它的名称叫做是否可以改变

12:27.620 --> 12:30.980
或者组件是否需要更新

12:31.500 --> 12:33.060
它有这样的一个操作

12:33.340 --> 12:35.780
那么我们可以在里面

12:36.420 --> 12:40.780
当然它也能去得到我们现在的叫做nexter purpose

12:41.420 --> 12:43.580
得到的方式和你现在这个是一样

12:43.980 --> 12:47.580
我们这边依然是可以使用这样的语句来显示

12:47.580 --> 12:50.980
你得到的最新的需要改变的那个值

12:51.820 --> 12:52.700
这个叫做

12:53.780 --> 12:54.860
我们就把它写出来

12:55.380 --> 12:59.020
shed components update

13:00.900 --> 13:02.780
当你得到这个数据的时候

13:02.980 --> 13:04.140
我们把这个写下来

13:05.260 --> 13:06.940
当你得到这个数据的时候的话

13:07.100 --> 13:09.980
那么结构点和它是在一个位置上

13:09.980 --> 13:12.300
它也是在改变之前

13:12.540 --> 13:13.780
但是它有个特点

13:13.780 --> 13:16.300
我们先来看它是否能够弹出

13:17.940 --> 13:18.420
对吧

13:18.620 --> 13:19.340
弹出来了

13:19.340 --> 13:21.340
它的改得到的值和你是一样的

13:21.700 --> 13:23.420
但是它有一个特点是什么

13:23.620 --> 13:26.060
它可以做一个return的返回

13:26.860 --> 13:28.580
它可以做一个return的返回

13:28.820 --> 13:30.100
这个return返回

13:30.100 --> 13:32.660
是要告知我们现在的组件

13:32.820 --> 13:34.900
你是否可以更新

13:35.220 --> 13:37.420
像我们刚才看到我什么都没打它

13:37.420 --> 13:38.180
我们不刷新

13:38.380 --> 13:39.260
我们看页面

13:39.580 --> 13:40.660
我们这出来以后

13:40.700 --> 13:42.580
这边是不是变成了改变后的值

13:42.580 --> 13:44.020
代表你点下去以后

13:44.020 --> 13:46.100
的确完成了属性里面

13:46.180 --> 13:47.700
这个展示文本的改变

13:47.860 --> 13:48.820
这个是ok的

13:49.060 --> 13:52.020
但是如果说我现在在这个位置上

13:52.020 --> 13:53.020
我给它return

13:53.900 --> 13:55.180
给它一个first

13:55.500 --> 13:57.020
当你这样打的话

13:57.100 --> 14:00.780
那么纯蓄它会接收到你叫改变的值

14:00.780 --> 14:03.860
但是它不会对属性里面进行变化

14:04.020 --> 14:04.700
你来看

14:04.820 --> 14:06.420
这是还有内容这行字

14:06.420 --> 14:07.780
然后我点击改变

14:08.140 --> 14:10.140
咱们看到它已经接收到了

14:10.140 --> 14:11.660
但是这边没有变化

14:11.900 --> 14:14.380
所以这个叫做shedcomponent updater

14:14.540 --> 14:17.460
它其实是能够在你改变

14:17.460 --> 14:19.620
或者说操纵于属性里面

14:19.620 --> 14:21.460
属键里面内容的时候

14:21.460 --> 14:23.300
之前的一个判断

14:24.380 --> 14:28.540
那么我们就可以利用它来做一些验证

14:29.060 --> 14:33.140
或者说数据准确性这样的一些操作

14:33.380 --> 14:36.260
如果你的数据不是我所想要的

14:36.260 --> 14:38.140
那么我就不允许你进行改变

14:38.580 --> 14:40.020
类似于这样的一个过程

14:40.180 --> 14:42.100
那么对于上面这个来讲的话

14:42.100 --> 14:45.580
它只是在你的之前属性前调用

14:45.580 --> 14:48.860
它无法来禁止你的后续行为

14:49.220 --> 14:50.180
理解这两个逻辑

14:50.340 --> 14:52.140
同时我们来看一下

14:52.660 --> 14:55.060
它是先做前面这个

14:55.060 --> 14:56.060
也就意味着

14:56.220 --> 14:59.020
在我们完成这样的一个叫做

14:59.140 --> 15:01.660
well received or burst的情况下

15:01.700 --> 15:04.620
它再去做我们的shedcomponent updater

15:05.060 --> 15:06.980
所以这样的话我们导致

15:06.980 --> 15:08.100
我们就可以看懂

15:08.580 --> 15:11.180
它的属性的接收的生命周期

15:11.540 --> 15:13.060
先做前面这一步

15:13.220 --> 15:16.020
然后完成以后再可以接收

15:16.020 --> 15:17.740
那么你这时候就要看你的

15:18.260 --> 15:19.460
程序的业务逻辑了

15:19.860 --> 15:21.660
你的业务逻辑需要在这进行

15:21.660 --> 15:22.820
所谓的一个判断吗

15:22.820 --> 15:24.140
判断你就在这边接

15:24.380 --> 15:26.100
如果说你只需要做记录

15:26.100 --> 15:29.340
或者说做一些更新前的准备

15:29.340 --> 15:30.540
那你就可以在上面接

15:33.220 --> 15:34.700
有同学也会说

15:34.700 --> 15:36.020
既然这个也能接

15:36.020 --> 15:36.980
为什么这边的话

15:36.980 --> 15:38.140
不能把所有东西做到这

15:38.140 --> 15:38.980
这不要它了

15:39.260 --> 15:40.540
因为这两个

15:40.540 --> 15:43.420
它本身在定义生命周期的时候

15:43.420 --> 15:45.580
它的功能是不一样的

15:45.820 --> 15:49.100
所以我们在做严谨的一些开发的时候

15:49.100 --> 15:52.740
我们还是希望能根据它特定的功能定义

15:52.740 --> 15:55.300
来完成你现在所显示出来的

15:55.300 --> 15:56.460
这样的一些代码

15:57.220 --> 15:59.900
那业务处理在上面

15:59.900 --> 16:01.940
是否可更新在下面

16:02.540 --> 16:03.220
OK吧

16:03.220 --> 16:03.740
好

16:03.740 --> 16:04.540
那么紧接着

16:05.020 --> 16:06.180
我们继续往下来看

16:06.500 --> 16:09.340
那么我们这边是否可更新

16:09.340 --> 16:14.420
这边是属于我们在属性操作回之前

16:14.420 --> 16:16.300
在我们接收数据之前

16:16.300 --> 16:17.220
它做的事情

16:17.220 --> 16:20.660
那么接下来真正的更新前后操作

16:20.660 --> 16:21.340
在下面

16:23.810 --> 16:25.010
component

16:26.010 --> 16:26.970
component

16:28.050 --> 16:29.730
where update

16:30.810 --> 16:32.570
component where update

16:33.370 --> 16:34.210
格式一样

16:34.210 --> 16:35.410
它也可以接收

16:36.330 --> 16:37.730
我就不再显示了

16:37.730 --> 16:39.210
因为这个内容是一样的

16:39.650 --> 16:40.690
它是干嘛

16:40.690 --> 16:41.770
它是指的是

16:42.370 --> 16:42.970
在

16:43.490 --> 16:44.530
组建

16:46.380 --> 16:46.860
组

16:48.420 --> 16:49.140
组建

16:51.100 --> 16:52.820
更新前

16:55.190 --> 16:55.790
操作

16:56.870 --> 16:57.630
操作

16:58.790 --> 16:59.630
在组建

16:59.630 --> 17:01.150
更新前的操作

17:01.670 --> 17:06.470
那么我们就直接可以把你组建需要更新的数据往这里边放了

17:08.620 --> 17:09.420
组建

17:09.420 --> 17:10.740
更新前

17:11.940 --> 17:13.780
同样我们把下面的也写出来

17:19.900 --> 17:20.900
component

17:22.880 --> 17:23.360
did

17:25.040 --> 17:25.720
update

17:26.720 --> 17:28.040
这是组建

17:28.040 --> 17:28.680
更新

17:28.680 --> 17:29.920
完毕以后

17:47.880 --> 17:49.280
然后再来

17:54.060 --> 17:54.860
component

17:55.500 --> 17:56.180
where

17:58.180 --> 17:59.100
组建在

18:03.150 --> 18:04.110
卸载时

18:24.910 --> 18:25.310
好

18:25.310 --> 18:26.510
形成这样的结构

18:27.990 --> 18:28.310
解

18:28.310 --> 18:30.230
但是这两项注意一下区别

18:33.060 --> 18:34.220
我们把它写一下

18:38.300 --> 18:39.260
我们在这

18:39.260 --> 18:41.060
这个是接收数据

18:41.060 --> 18:43.300
这个是接收数据

18:43.300 --> 18:45.340
接收属性数据是前

18:45.700 --> 18:47.260
这个是更新前

18:47.900 --> 18:49.340
我可以接收到数据

18:49.340 --> 18:50.300
不一定要更新

18:50.740 --> 18:51.260
理解吧

18:51.260 --> 18:51.860
这一次

18:52.540 --> 18:53.660
接收数据前

18:53.660 --> 18:54.340
preparedest

18:54.340 --> 18:55.300
可以接收

18:55.300 --> 18:56.740
那么看它的顺序

18:56.740 --> 18:58.700
它一定是接收到数据以后

18:58.700 --> 19:00.540
再完成它的数据更新

19:00.780 --> 19:02.540
我们来看一下它的逻辑

19:03.420 --> 19:05.540
这两个的时间点是不一样的

19:05.780 --> 19:08.980
那么作为我们现在的属性来讲的话

19:08.980 --> 19:11.300
它一定是属于生命周期来讲

19:11.300 --> 19:12.820
它一定会分得很细

19:12.820 --> 19:13.460
这就是

19:15.780 --> 19:17.460
我们可以看到我们

19:17.900 --> 19:18.620
做这个

19:18.980 --> 19:20.820
我们看一下它的结构

19:21.140 --> 19:22.940
它是接收性数据

19:22.940 --> 19:23.460
对吧

19:23.460 --> 19:24.660
然后来说是

19:24.860 --> 19:26.660
这边接收到新数据时

19:26.660 --> 19:27.260
然后

19:27.500 --> 19:28.100
还有内容

19:28.260 --> 19:29.340
我们这边设了一个force

19:29.340 --> 19:29.740
对吧

19:31.060 --> 19:31.700
我们想

19:32.660 --> 19:33.500
我们做个force

19:33.500 --> 19:35.820
所以想下面的更新它没有出来

19:36.140 --> 19:37.140
那么同样的话

19:37.140 --> 19:38.260
这样你就会看到

19:38.420 --> 19:39.980
我虽然设了force

19:39.980 --> 19:40.700
但是

19:40.700 --> 19:41.900
它下面没有执行

19:41.900 --> 19:42.620
没有更新

19:42.620 --> 19:44.060
但是它已经接收到了

19:44.220 --> 19:46.260
所以我们做这个操作

19:46.460 --> 19:47.380
你这时候看

19:47.500 --> 19:49.180
接收数据依然完成了

19:49.180 --> 19:51.820
但是接收前和接收后由于我执行了

19:51.820 --> 19:53.140
所以它这个也会出来

19:53.380 --> 19:54.180
看到了吗

19:54.780 --> 19:57.300
所以这部操作无论怎么样都能接收

19:57.300 --> 19:59.180
同时再讲授一下

19:59.180 --> 20:01.540
就是它接的数据

20:01.540 --> 20:02.900
它接的数据

20:02.900 --> 20:05.100
只有是它的属性

20:05.260 --> 20:08.220
如果说你是用q定方式来获取的话

20:08.620 --> 20:10.220
那么它是无法接收到的

20:10.340 --> 20:11.660
我们刚才已经看到了

20:11.660 --> 20:13.940
它里面只能拿到我的两个属性

20:13.940 --> 20:14.700
OK吧

20:14.900 --> 20:15.820
这样的格式

20:15.820 --> 20:19.780
那么这个就是生命周期它的一个点

20:20.140 --> 20:21.540
那么生命周期的话

20:21.740 --> 20:23.580
我们有时候我们注意一下

20:23.580 --> 20:25.460
这一部操作上面

20:25.460 --> 20:28.500
我们不能有任何的和页面的交互

20:28.500 --> 20:29.780
然后后面就可以

20:30.220 --> 20:32.020
这个时候大家可以注意一下

20:32.020 --> 20:34.540
然后了解一下它整个生命周期里面的

20:34.540 --> 20:35.740
一个运作的逻辑

20:35.740 --> 20:37.860
和它里面的一些细微的区分点

20:38.020 --> 20:40.780
特别是生命周期很少我们看到

20:40.780 --> 20:42.300
会有这样的返回

20:42.300 --> 20:43.780
那么这里也记住一下

20:43.780 --> 20:44.340
OK

20:44.340 --> 20:46.420
这就是属性的生命周期

20:46.420 --> 20:46.820
好

20:46.820 --> 20:48.540
我们这期课就先到这里

