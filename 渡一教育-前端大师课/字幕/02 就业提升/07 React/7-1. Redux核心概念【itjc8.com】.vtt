WEBVTT

00:00.820 --> 00:06.820
这次呢 咱们rex 这里呢 已经学了两大套件了对吧

00:06.820 --> 00:11.820
rex 全家同一边呢 一共就包含了这么四个东西

00:11.820 --> 00:15.820
大块啊 我说大块的话就包含这么四个东西

00:15.820 --> 00:20.820
一个呢 就是rex 本身 还提供了一个就是UI 解决方案

00:20.820 --> 00:26.580
也就是它解决什么问题呢 它只是解决你给我一套数据

00:26.580 --> 00:30.580
我给你宣传一个UI 界面 宣传一个就是用户界面

00:30.580 --> 00:33.580
它只做这么一件事 其他的很多事情呢

00:33.580 --> 00:37.580
都需要靠第三方的一些库来帮助它完成

00:37.580 --> 00:40.580
就是它本身呢 没有去解决其他的问题

00:40.580 --> 00:44.580
其实这个呢 地方我多说几句啊 其实这也是

00:44.580 --> 00:48.580
一个产品 它的一种

00:48.580 --> 00:53.580
哲学思想吧 因为有些产品呢 它可能比较激进一点

00:53.580 --> 00:56.580
比方说像UIU 它相对来说比较激进一点

00:56.580 --> 00:59.580
对 它给你做了很多的事情UIU里边

00:59.580 --> 01:04.580
为了方便你使用 它做了什么指令啊 还有什么

01:04.580 --> 01:09.580
包括UIU ROTAR UIU X都是官方出品的 对吧

01:09.580 --> 01:14.580
所以它给你做了很多的套件 让你直接用它那一整套的解决方案

01:14.580 --> 01:18.580
就可以几乎可以解决所有的问题

01:18.580 --> 01:22.580
但是有一些产品呢 它相对来说比较保守一点

01:22.580 --> 01:24.580
比方说rex 它就相对保守一点

01:24.580 --> 01:28.580
因为它认为 现在前端的最佳实践

01:28.580 --> 01:32.580
还没有出来 大家不知道大家有没有听过这个词啊 叫做最佳实践

01:32.580 --> 01:38.210
最佳实践呢 就是在我们具体的开发过程中

01:38.210 --> 01:42.210
形成的一种共识 如果说你之前

01:42.210 --> 01:45.210
接触过什么加码语言啊 一些后端语言的话

01:45.210 --> 01:48.210
你可能会听说过三层架构 对吧 那么像这些东西呢

01:48.210 --> 01:52.210
就是具体的开发中形成的一种共识

01:52.210 --> 01:56.210
那么这种共识呢 长连累月的积累

01:56.210 --> 02:00.210
慢慢的呢 几乎是所有的公司

02:00.210 --> 02:04.210
或者是所有的项目 他们都会使用这种方案

02:04.210 --> 02:08.210
那么这种方案呢 就是我们就把它叫做最佳实践

02:08.210 --> 02:12.210
如果一个技术呢 它形成了最佳实践呢

02:12.210 --> 02:15.210
那么它的产品 就是一个技术相关的产品呢

02:15.210 --> 02:18.210
它可能做的东西呢 就会成套一些

02:18.210 --> 02:21.210
比方说数据库的解决方案啊 什么架构的解决方案呢

02:21.210 --> 02:24.210
都比较成熟了 大家都这么用 于是呢 就会出现一些

02:24.210 --> 02:27.210
非常非常成熟的产品出来 但是有的技术呢

02:27.210 --> 02:30.210
它可能出现了时间没有那么

02:30.210 --> 02:33.210
没有那么早啊 可能才

02:33.210 --> 02:37.210
一个是 可能在市面上的话 算是一个新技术

02:37.210 --> 02:40.210
时间呢稍微短一点 所以说呢

02:40.210 --> 02:43.210
那个时候呢 还没有形成最佳实践

02:43.210 --> 02:46.210
就是这个公司呢 这样去使用 另外一个公司呢 另外一种方式

02:46.210 --> 02:49.210
去使用 因此呢 对这个技术本身而言呢

02:49.210 --> 02:52.210
它就会需要保持它的灵活度

02:52.210 --> 02:55.210
它不能 很多地方呢 不能把它写死吧

02:55.210 --> 02:58.210
所以说呢 Reax 它的社会实际上是 在形成最佳实践之前

02:58.210 --> 03:01.210
我现在呢 就做很简单很简单一个事 非常非常的纯粹

03:01.210 --> 03:05.210
我就是给你提供一个UI解决方案 怎么去宣展啊

03:05.210 --> 03:08.210
我给你提高宣展效率 我给你做一些

03:08.210 --> 03:11.210
组建化的 融入一些组建化的思想进去

03:11.210 --> 03:14.210
啊 剩下的事情呢 怎么去做 你来决定

03:14.210 --> 03:17.210
所以说很多的事情呢 需要需要

03:17.210 --> 03:20.210
一脱鱼第三方库 比方说过了几年

03:20.210 --> 03:23.210
咱们之前那个Rotor 不知道路由吗

03:23.210 --> 03:26.210
那个路由 又有了更好的解决办法

03:26.210 --> 03:29.210
那么替换了就行了 对Rex本身呢

03:29.210 --> 03:32.210
也不会产生太大的影响 是这么个意思

03:32.210 --> 03:35.210
所以我们之前学过的Rex呢 它是一个UI解决方案

03:35.210 --> 03:38.210
仅此而已 后边呢 我们又学习了

03:38.210 --> 03:41.210
Rex Rotor 是Rex社区

03:41.210 --> 03:44.210
出品的一种路由解决方案

03:44.210 --> 03:48.210
它是用于解决路由问题

03:48.210 --> 03:51.210
点路由问题 就是不同的地址

03:51.210 --> 03:54.210
我给你显示不同的组建 它主要是为了解决这样的问题

03:54.210 --> 03:56.210
好 那还有什么问题呢

03:56.210 --> 03:59.210
还有一个问题呢 其实跟UIO那一块呢

03:59.210 --> 04:01.210
UIO有的时候呢 也把叫做UIO 1

04:01.210 --> 04:04.210
我是采用官方的教法吧 叫做UIO

04:04.210 --> 04:07.210
Rex 就是除了这两种之外呢

04:07.210 --> 04:10.210
还有一种 还有一个问题需要解决

04:10.210 --> 04:12.210
就是数据的问题 数据的问题

04:12.210 --> 04:14.210
换了我们会相信来说 它有什么样的问题

04:14.210 --> 04:17.210
那么这个数据的问题呢 在UIO里边 它是用UIO X

04:17.210 --> 04:21.210
对吧 那么在Rex里边呢 它是用的是Rei 就是ReDux

04:21.210 --> 04:25.210
主要是用ReDux 当然也可以结合一些

04:25.210 --> 04:28.210
其他的数据解决方案 是不过现在呢

04:28.210 --> 04:31.210
公司里面用的最多的就是ReDux

04:31.210 --> 04:36.210
它是处理一个就是数据的解决方案

04:36.210 --> 04:40.210
那么最后呢 Rex全家桶里边还有一个UI库

04:40.210 --> 04:42.210
就是我们做一些后台管理系统啊

04:42.210 --> 04:46.210
可能没有设计师可以去设计后台管理系统的界面

04:46.210 --> 04:49.210
因此呢 需要你自己去搭 那么自己搭的很麻烦

04:49.210 --> 04:52.210
所以说它会有一些市面上会有一些UI库

04:52.210 --> 04:54.210
UI库来解决这样的问题

04:54.210 --> 04:56.210
那么这个UI库呢 到时候我们和学习这个安DZ

04:56.210 --> 04:58.210
我们简称安D

04:58.210 --> 05:01.210
那么它是 它是一个就是UI库

05:01.210 --> 05:05.900
Rex全家桶大概就这么这些东西

05:05.900 --> 05:07.900
当然还有一些细致末节的

05:07.900 --> 05:09.900
比方说像什么 脚受架之类的

05:10.900 --> 05:12.900
好 那这一张开始啊

05:12.900 --> 05:15.900
咱们开始来学习第三个ReDux

05:15.900 --> 05:17.900
也就是数据的解决方案

05:17.900 --> 05:19.900
这一张的第一节课呢

05:19.900 --> 05:22.900
我们是讲ReDux的核心概念

05:22.900 --> 05:24.900
讲什么东西呢

05:24.900 --> 05:26.900
我们讲这个ReDux 它的由来

05:26.900 --> 05:28.900
它到底要解决一个什么样的问题

05:28.900 --> 05:30.900
那么之前遇到了什么样的问题

05:30.900 --> 05:31.900
需要解决

05:31.900 --> 05:32.900
好 这一课呢

05:32.900 --> 05:34.900
你别看是讲核心概念

05:34.900 --> 05:36.900
结果这一课讲的东西还是蛮多的

05:36.900 --> 05:37.900
因为很多同学呢

05:37.900 --> 05:40.900
其实我以前在线下授课的时候呢

05:40.900 --> 05:41.900
时间比较短一点

05:41.900 --> 05:43.900
所以说我每次讲ReDux

05:43.900 --> 05:45.900
同学们给我的反馈就是

05:45.900 --> 05:47.900
接受起来非常非常困难

05:47.900 --> 05:50.900
他不知道为什么要用这种方式来做

05:50.900 --> 05:52.900
当然我之前在线下授课的时候呢

05:52.900 --> 05:54.900
是先讲ReDux

05:54.900 --> 05:55.900
ReAx

05:55.900 --> 05:56.900
然后再讲了5U

05:56.900 --> 05:58.900
所以说先把蓝的ReAx先讲了

05:58.900 --> 06:00.900
然后再讲简单的5U

06:00.900 --> 06:02.900
因此呢 是这种讲的过程

06:02.900 --> 06:03.900
所以说他们第一次

06:03.900 --> 06:05.900
结束这种数据解决方案的时候

06:05.900 --> 06:06.900
就感觉很奇怪

06:06.900 --> 06:08.900
他为什么要这样去做

06:08.900 --> 06:10.900
不过呢 对于目前

06:10.900 --> 06:13.900
独一的同学们来说的话

06:13.900 --> 06:15.900
你们应该是先学的5U 对吧

06:15.900 --> 06:17.900
你们应该是先学的5U

06:17.900 --> 06:18.900
那么学的5U过程

06:18.900 --> 06:20.900
再来接受这个数据解决方案呢

06:20.900 --> 06:21.900
要轻松很多

06:21.900 --> 06:22.900
不过呢

06:22.900 --> 06:24.900
ReDux里面的数据解决方案呢

06:24.900 --> 06:26.900
他的理念跟ReAx差不多

06:26.900 --> 06:29.900
他也是只做了很简单很简单的事情

06:29.900 --> 06:31.900
很多事情他都没有做

06:31.900 --> 06:32.900
因此呢

06:32.900 --> 06:35.900
他保持了他的纯净性 简洁性

06:35.900 --> 06:37.900
但是学习显然的可能

06:37.900 --> 06:39.900
稍微难度有点高

06:40.900 --> 06:41.900
那这里这样子吧

06:41.900 --> 06:43.900
我们就种这第1节课的时间

06:43.900 --> 06:45.900
就第1节课

06:45.900 --> 06:46.900
咱们来讲这个ReDux

06:46.900 --> 06:47.900
它是怎么来的

06:47.900 --> 06:48.900
它到底要解决什么样的问题

06:48.900 --> 06:50.900
所以说我们多花点时间

06:50.900 --> 06:51.900
我觉得这个东西是有必要的

06:51.900 --> 06:52.900
不然的话

06:52.900 --> 06:53.900
以前很多同学学了

06:53.900 --> 06:55.900
不知道为什么要这样去干

06:55.900 --> 06:56.900
一点点来说

06:56.900 --> 06:58.900
其实ReDux里边的核心概念

06:58.900 --> 07:00.900
这节课我们一共就引出这么3个东西

07:00.900 --> 07:02.900
一个是Action

07:02.900 --> 07:03.900
一个是Reducer

07:03.900 --> 07:05.900
一个是Stone

07:05.900 --> 07:06.900
就引出这个3个东西

07:06.900 --> 07:08.900
其实ReDux里边最核心的

07:08.900 --> 07:09.900
也就是这3个东西的

07:09.900 --> 07:11.900
咱们后边

07:11.900 --> 07:13.900
这一张节

07:13.900 --> 07:15.900
后边开始学习的时候了

07:15.900 --> 07:16.900
我们也会

07:16.900 --> 07:18.900
重点就是学习这3个

07:18.900 --> 07:19.900
这3个学习完

07:19.900 --> 07:21.900
其实ReDux也就差不多了

07:21.900 --> 07:23.900
大不了还有一个中间键

07:23.900 --> 07:24.900
我们后边会说

07:24.900 --> 07:25.900
一个个来

07:25.900 --> 07:28.900
首先我们来理一下

07:28.900 --> 07:29.900
ReDux到底要解决一个

07:29.900 --> 07:30.900
什么样的问题

07:30.900 --> 07:32.900
这个事情说来有点话长

07:32.900 --> 07:34.900
我啰嗦几点

07:34.900 --> 07:35.900
首先我要给大家介绍的是一个

07:35.900 --> 07:36.900
这个东西

07:36.900 --> 07:39.900
叫做MVC

07:39.900 --> 07:40.900
就是MVC

07:40.900 --> 07:42.900
其实有些同学应该听过

07:42.900 --> 07:44.900
应该你们都听过这个词吧

07:44.900 --> 07:45.900
MVC

07:45.900 --> 07:47.900
它是一种解决方案

07:47.900 --> 07:48.900
它是一种解决方案

07:48.900 --> 07:50.900
它用来解决什么呢

07:50.900 --> 07:54.900
用来解决UI的

07:54.900 --> 07:57.900
它也是一种UI的解决方案

07:57.900 --> 07:58.900
UI的解决方案

07:58.900 --> 08:00.900
UI界面的解决方案

08:00.900 --> 08:05.900
它是一个UI的解决方案

08:05.900 --> 08:06.900
它来解决

08:06.900 --> 08:09.900
它用于降低UI的复杂度

08:09.900 --> 08:20.900
用于降低UI以及UI关联的数据的复杂度

08:20.900 --> 08:22.900
它是用来解决这个问题的

08:22.900 --> 08:23.900
那么这样子说起来

08:23.900 --> 08:24.900
是比较抽象的

08:24.900 --> 08:26.900
那要解释清楚MVC的话

08:26.900 --> 08:30.900
你必须多多少少对服务器有点了解

08:30.900 --> 08:34.900
因为MVC这种模式最早的应用场景

08:34.900 --> 08:37.900
就是最广方的应用场景

08:37.900 --> 08:38.900
就是服务器

08:38.900 --> 08:40.900
服务器端的应用场景

08:40.900 --> 08:42.900
那么这里我给大家说一下

08:42.900 --> 08:43.900
服务器端的UI解决

08:43.900 --> 08:44.900
MVC

08:44.900 --> 08:47.900
服务器端的MVC

08:47.900 --> 08:50.900
因为你们现在可能还没有接触到服务器端

08:50.900 --> 08:52.900
因为你们现在还没有学习斗的解释

08:52.900 --> 08:53.900
可能你听说过

08:53.900 --> 08:55.900
但是你还没有学习到

08:55.900 --> 08:58.900
所以说对服务器那一块可能比较陌生

08:58.900 --> 09:00.900
包括以前上什么加瓦

09:00.900 --> 09:01.900
C++

09:01.900 --> 09:03.900
PHP

09:03.900 --> 09:04.900
这些服务端语言

09:04.900 --> 09:06.900
可能大家也没有节目接触过

09:06.900 --> 09:08.900
所以说这一块我多花点时间

09:08.900 --> 09:10.900
来讲一讲服务器端的MVC

09:10.900 --> 09:12.900
为什么要讲这个东西呢

09:12.900 --> 09:13.900
其实这个东西跟我们目前学的

09:13.900 --> 09:15.900
Ridak是没有任何关系

09:15.900 --> 09:16.900
没有任何关系

09:16.900 --> 09:18.900
那为什么要讲这个东西呢

09:18.900 --> 09:19.900
通过讲这个东西

09:19.900 --> 09:21.900
你认识到这个MVC的概念之后

09:21.900 --> 09:23.900
你才能慢慢的理会到

09:23.900 --> 09:26.900
这个Ridak它经历了怎么样的痛苦

09:26.900 --> 09:29.900
为什么要出现这个Ridak

09:29.900 --> 09:31.900
它是有一些历史远远的

09:31.900 --> 09:32.900
咱们来挨在来讲

09:32.900 --> 09:34.900
其实我觉得这一块呢

09:34.900 --> 09:37.900
我包括看网上的一些文章

09:37.900 --> 09:39.900
我发现不少的人

09:39.900 --> 09:40.900
哪怕工作了很多年的人

09:40.900 --> 09:43.900
对这一块都多少少是有一些误解的

09:43.900 --> 09:45.900
我们这里慢慢说

09:45.900 --> 09:47.900
首先说服务端的MVC

09:47.900 --> 09:48.900
它到底是怎么回事

09:48.900 --> 09:50.900
这里我给大家画一个图

09:51.900 --> 09:52.900
我们使用PPT

09:52.900 --> 09:53.900
给大家画一个图

09:53.900 --> 09:57.430
稍等一下

10:01.900 --> 10:03.900
首先大家要了解

10:03.900 --> 10:05.900
什么叫做服务器

10:05.900 --> 10:07.900
服务器是什么呢

10:07.900 --> 10:09.900
服务器就是给你提供支援的东西

10:09.900 --> 10:11.900
服务器就是给你提供支援的东西

10:11.900 --> 10:13.900
我这里画个图吧

10:13.900 --> 10:14.900
我们这里呢

10:14.900 --> 10:15.900
比方说吧

10:15.900 --> 10:17.900
我们这里呢是一个浏览器

10:17.900 --> 10:18.900
浏览器的文艺

10:18.900 --> 10:20.900
把它叫做客户端

10:20.900 --> 10:21.900
浏览器

10:21.900 --> 10:22.900
浏览器用来干嘛的

10:22.900 --> 10:24.900
是不是用来执行JS

10:24.900 --> 10:25.900
执行ATM

10:25.900 --> 10:26.900
执行CSS

10:26.900 --> 10:27.900
对吧

10:27.900 --> 10:28.900
渲染页面

10:28.900 --> 10:29.900
然后执行页面中的JS

10:29.900 --> 10:30.900
它的主要作用是这个

10:30.900 --> 10:32.900
那么还可以渲染什么

10:32.900 --> 10:33.900
还可以渲染图片

10:33.900 --> 10:34.900
对不对

10:34.900 --> 10:36.900
还可以渲染什么SVG

10:36.900 --> 10:37.900
等等

10:37.900 --> 10:39.900
这是浏览器的作用

10:39.900 --> 10:40.900
但是浏览器它要读取

10:40.900 --> 10:42.900
它要执行JS代码

10:42.900 --> 10:43.900
它要执行ATM代码

10:43.900 --> 10:45.900
只要执行CSS代码

10:45.900 --> 10:46.900
它代码哪来的呢

10:46.900 --> 10:47.900
哪来的呢

10:47.900 --> 10:49.900
但是以前在最早的时候呢

10:49.900 --> 10:50.900
我们是在本地

10:50.900 --> 10:51.900
写这个ATM页面

10:51.900 --> 10:53.900
双击页面打开的对吧

10:53.900 --> 10:54.900
这种方式

10:54.900 --> 10:55.900
但是平时上网的时候

10:55.900 --> 10:56.900
我们可不是用这种方式

10:56.900 --> 10:57.900
我们平时上网的时候

10:57.900 --> 10:58.900
是不是在浏览器里面

10:58.900 --> 10:59.900
输入一个地址啊

10:59.900 --> 11:00.900
比方你输入百度

11:00.900 --> 11:01.900
对吧

11:01.900 --> 11:02.900
那么就要输入3W点

11:02.900 --> 11:03.900
百度点com

11:03.900 --> 11:04.900
输入一个地址

11:04.900 --> 11:05.900
那百度那个页面

11:05.900 --> 11:07.900
在你的技能上一场有没有呢

11:07.900 --> 11:09.900
是不是没有

11:09.900 --> 11:10.900
百度这个页面是别人的

11:10.900 --> 11:11.900
对吧

11:11.900 --> 11:12.900
在别人的电脑上

11:12.900 --> 11:13.900
不在你的电脑上

11:13.900 --> 11:14.900
你有没有去自己写一个

11:14.900 --> 11:15.900
百度的ATM页面

11:15.900 --> 11:16.900
没有嘛

11:16.900 --> 11:17.900
对吧

11:17.900 --> 11:18.900
CSS也不是你写的嘛

11:18.900 --> 11:19.900
里边的JS也不是你写的嘛

11:19.900 --> 11:20.900
那它东西哪来的呢

11:20.900 --> 11:21.900
它又没有安装

11:21.900 --> 11:22.900
对吧

11:22.900 --> 11:23.900
你又没有下载任何东西

11:23.900 --> 11:24.900
就下了一个浏览器

11:24.900 --> 11:26.900
就可以访问任何一个网站了

11:26.900 --> 11:27.900
那么这些网站的资源

11:27.900 --> 11:29.900
页面资源哪来的

11:29.900 --> 11:30.900
JS资源

11:30.900 --> 11:31.900
CSS资源哪来的

11:31.900 --> 11:33.900
全部都在服务器上

11:33.900 --> 11:35.900
所以说我们浏览器

11:35.900 --> 11:36.900
是我们的客户端

11:36.900 --> 11:37.900
我们把它认为客户端

11:37.900 --> 11:39.900
是在我们的电脑上的

11:39.900 --> 11:41.900
然后服务

11:41.900 --> 11:42.900
还有一个服务器端

11:42.900 --> 11:44.900
服务器

11:44.900 --> 11:46.900
当然这个服务器

11:46.900 --> 11:47.900
它不一定是别人的电脑

11:47.900 --> 11:48.900
比方说这个服务器

11:48.900 --> 11:49.900
我们可不可以

11:49.900 --> 11:51.900
就搭在自己的电脑上了

11:51.900 --> 11:52.900
实际上是可以的

11:52.900 --> 11:53.900
像我们安装的那个

11:53.900 --> 11:55.900
之前大家安装的那个插件

11:55.900 --> 11:56.900
叫做

11:56.900 --> 11:57.900
应该很多人安装的

11:57.900 --> 11:59.900
叫NavServer

11:59.900 --> 12:01.900
这个插件

12:01.900 --> 12:02.900
这个插件其实就是在本机

12:02.900 --> 12:04.900
搭了一个服务器

12:04.900 --> 12:05.900
那么我们浏览器

12:05.900 --> 12:06.900
是连接的本机

12:06.900 --> 12:08.900
本机的服务器

12:08.900 --> 12:10.900
当然我们像React

12:10.900 --> 12:11.900
这个工程

12:11.900 --> 12:12.900
这个脚授架搭出来的工程

12:12.900 --> 12:14.900
就是CreaseReactApp

12:14.900 --> 12:16.900
这个官方脚授架

12:16.900 --> 12:17.900
搭出来的工程

12:17.900 --> 12:19.900
也是类似的一个服务器

12:19.900 --> 12:20.900
当时我们访问的时候

12:20.900 --> 12:22.900
是3000个端口

12:22.900 --> 12:24.900
这些大家多多少少都会

12:24.900 --> 12:26.900
有一些支持的

12:26.900 --> 12:27.900
服务器用来干嘛的呢

12:27.900 --> 12:31.900
它是用来提供资源

12:31.900 --> 12:32.900
那么这个资源

12:32.900 --> 12:34.900
就是说我浏览器

12:34.900 --> 12:36.900
访问这个服务器的时候

12:36.900 --> 12:37.900
服务器给它一个资源

12:37.900 --> 12:38.900
那么浏览器

12:38.900 --> 12:39.900
通过什么来访问

12:39.900 --> 12:41.900
是不是通过一个地址

12:41.900 --> 12:43.900
是通过一个地址来访问

12:43.900 --> 12:46.900
它是通过一个URL地址

12:47.900 --> 12:50.900
通过一个地址去访问这个服务器

12:50.900 --> 12:52.900
然后不同的地址

12:52.900 --> 12:54.900
服务器会给它不同的资源

12:54.900 --> 12:55.900
就这么个意思

12:55.900 --> 12:57.900
非常非常简单

12:57.900 --> 12:58.900
访问一个地址

12:58.900 --> 12:59.900
到了服务器

12:59.900 --> 13:01.900
服务器经过一系列的操作

13:01.900 --> 13:05.900
最终会给它一个资源

13:05.900 --> 13:07.900
会给它一个资源

13:07.900 --> 13:08.900
那么这里是资源

13:08.900 --> 13:10.900
这个资源可能是一张图片

13:10.900 --> 13:11.900
可能是一个页面

13:11.900 --> 13:13.900
可能是一个CSS

13:13.900 --> 13:14.900
可能是一个GS

13:14.900 --> 13:15.900
说不准

13:15.900 --> 13:17.900
看你访问的是什么地址

13:17.900 --> 13:18.900
给它一个资源

13:18.900 --> 13:21.900
所以说我们浏览器跟服务器之间交互

13:21.900 --> 13:22.900
我们就往往

13:22.900 --> 13:25.900
往往就会经过这么两个步骤

13:25.900 --> 13:26.900
一个是

13:26.900 --> 13:27.900
第一个步骤是

13:27.900 --> 13:30.900
通过一个URL地址去访问这个服务器

13:30.900 --> 13:32.900
在浏览器里面输入一个地址

13:32.900 --> 13:34.900
一回车服务器就访问到了

13:34.900 --> 13:35.900
访问这个服务器

13:35.900 --> 13:37.900
那么服务器经过一系列处理

13:37.900 --> 13:38.900
不管它怎么处理

13:38.900 --> 13:40.900
它最终会给你一个资源

13:40.900 --> 13:42.900
会给你返回一个资源

13:42.900 --> 13:43.900
那么我们其实这里

13:43.900 --> 13:46.900
把第一步叫做请求

13:46.900 --> 13:48.900
叫做请求

13:48.900 --> 13:49.900
其实你们学过

13:49.900 --> 13:51.900
阿迦克斯应该知道什么意思

13:51.900 --> 13:53.900
第二步叫做想应

13:53.900 --> 13:56.900
服务器给你想应一个结果

13:56.900 --> 13:57.900
想应的是一个资源

13:57.900 --> 13:58.900
当然那个资源还包括

13:58.900 --> 13:59.900
包括什么

13:59.900 --> 14:00.900
接上格式的一个支付串

14:00.900 --> 14:01.900
对不对

14:01.900 --> 14:02.900
都有可能

14:02.900 --> 14:03.900
什么资源都有可能

14:03.900 --> 14:05.900
总之会给你想应一个资源

14:05.900 --> 14:07.900
如果你再去深挖一下

14:07.900 --> 14:08.900
你们之前学到

14:08.900 --> 14:09.900
阿迦克斯的知识的话

14:09.900 --> 14:10.900
应该知道这个资源

14:10.900 --> 14:12.900
到底是什么类型的资源

14:12.900 --> 14:14.900
通过想应的想应头

14:14.900 --> 14:15.900
对吧

14:15.900 --> 14:16.900
header里边的东西

14:16.900 --> 14:17.900
content type

14:17.900 --> 14:18.900
对吧

14:18.900 --> 14:19.900
通过这个东西的告诉你

14:19.900 --> 14:20.900
你给的资源是什么资源

14:20.900 --> 14:21.900
总之大体上的

14:21.900 --> 14:23.900
会分为这么两个步骤

14:23.900 --> 14:24.900
请求到服务器

14:24.900 --> 14:25.900
服务器收到这个请求了

14:25.900 --> 14:27.900
经过处理处理处理处理

14:27.900 --> 14:28.900
做了一大堆事情

14:28.900 --> 14:29.900
然后给你一个资源

14:29.900 --> 14:31.900
就有非常像一个啥呢

14:31.900 --> 14:33.900
非常像你叫外卖

14:33.900 --> 14:34.900
你叫外卖就是拨打

14:34.900 --> 14:35.900
不同的电话号码

14:35.900 --> 14:37.900
是不是就是不同的请求地址

14:37.900 --> 14:38.900
对吧

14:38.900 --> 14:39.900
然后在拨打通了过程里

14:39.900 --> 14:40.900
告诉他你要什么

14:40.900 --> 14:42.900
其实这也是URL地址的一部分

14:42.900 --> 14:44.900
URL地址里边就表示了

14:44.900 --> 14:46.900
你要向谁发送请求

14:46.900 --> 14:48.900
你要请求什么东西

14:48.900 --> 14:50.900
那么他会告诉服务器

14:50.900 --> 14:51.900
那么服务器拿到这个请求之后

14:51.900 --> 14:52.900
他进行处理

14:52.900 --> 14:54.900
比方说饭店里面就开始做饭了

14:54.900 --> 14:56.900
然后外卖公司

14:56.900 --> 14:58.900
就是送餐公司

14:58.900 --> 14:59.900
比方说饿了吗

14:59.900 --> 15:00.900
或者是美团

15:00.900 --> 15:01.900
对吧

15:01.900 --> 15:03.900
他就会派人到那边去

15:03.900 --> 15:04.900
给你拿东西

15:04.900 --> 15:06.900
哪里的就是用餐的

15:06.900 --> 15:08.900
用餐的就是资源

15:08.900 --> 15:10.900
那么最终会把你点的外卖

15:10.900 --> 15:11.900
送到你手中

15:11.900 --> 15:13.900
这个整个过程的就是响应

15:13.900 --> 15:15.900
从商家那边到你家里边

15:15.900 --> 15:16.900
就是一个响应

15:16.900 --> 15:18.900
就总共就会经过这么两个步骤

15:18.900 --> 15:20.900
一个请求一个响应

15:20.900 --> 15:21.900
那么这里呢

15:21.900 --> 15:23.900
我们终点是说一下

15:23.900 --> 15:25.900
关于ATM页面

15:25.900 --> 15:27.900
关于ATM页面的请求

15:27.900 --> 15:29.900
当我们去从服务器去

15:29.900 --> 15:30.900
请求一个地址的时候

15:30.900 --> 15:32.900
比方说咱们去请求一个地址

15:32.900 --> 15:35.900
请求W.QQ.com

15:35.900 --> 15:36.900
对吧

15:36.900 --> 15:37.900
请求一个网页地址

15:37.900 --> 15:39.900
那么服务员发现

15:39.900 --> 15:40.900
你给我的

15:40.900 --> 15:41.900
你请求这个地址

15:41.900 --> 15:43.900
我应该给你一个ATM页面

15:43.900 --> 15:45.900
于是他响应的结果是什么呢

15:45.900 --> 15:47.900
他直接把这个ATM页面

15:47.900 --> 15:49.900
整个ATM页面的元代码

15:49.900 --> 15:50.900
给你响应过来了

15:50.900 --> 15:53.900
ATM页面的元代码

15:53.900 --> 15:55.900
整个把ATM元代码

15:55.900 --> 15:56.900
响应给你

15:56.900 --> 15:58.900
是这么个意思

15:58.900 --> 16:00.900
这是传统的方式

16:00.900 --> 16:02.900
很多很多年前就是这种方式

16:02.900 --> 16:04.900
包括现在有一些

16:04.900 --> 16:06.900
有一些公司

16:06.900 --> 16:07.900
还在用这种方式

16:07.900 --> 16:08.900
很旧的方式

16:08.900 --> 16:10.900
请求一个URL地址

16:10.900 --> 16:12.900
给你一个ATM元代码

16:12.900 --> 16:13.900
给你一个ATM元代码

16:13.900 --> 16:15.900
那么这种方式随处可见

16:15.900 --> 16:16.900
我们比方说吧

16:16.900 --> 16:18.900
我们访问一下新浪

16:18.900 --> 16:20.900
新浪

16:20.900 --> 16:22.900
这是个新浪网

16:22.900 --> 16:23.900
好

16:23.900 --> 16:24.900
然后现在

16:24.900 --> 16:25.900
我们怎么来看一下

16:25.900 --> 16:26.900
服务器给我们是什么东西呢

16:26.900 --> 16:29.900
我们这里点击右键检查

16:29.900 --> 16:30.900
然后呢

16:30.900 --> 16:33.900
这里我们使用network

16:33.900 --> 16:35.900
network

16:35.900 --> 16:36.900
里面就记录了

16:36.900 --> 16:38.900
就是跟服务器之间的

16:38.900 --> 16:39.900
请求数量

16:39.900 --> 16:40.900
就发送了多少支请求

16:40.900 --> 16:41.900
你看全在这

16:41.900 --> 16:42.900
全在这

16:42.900 --> 16:44.900
这里边我们找一下

16:44.900 --> 16:46.900
我们这里重新刷新一下吧

16:46.900 --> 16:47.900
刷新

16:47.900 --> 16:48.900
重新刷新一下

16:48.900 --> 16:49.900
你看

16:49.900 --> 16:51.900
这一次刷新有这么多请求怎么来的

16:51.900 --> 16:53.900
其实我以前好像也讲过

16:53.900 --> 16:54.900
就是你拿到这个

16:54.900 --> 16:55.900
本来只有一个请求的

16:55.900 --> 16:57.900
就拿这个ATM页面

16:57.900 --> 16:58.900
拿到之后呢

16:58.900 --> 16:59.900
这个页面中

16:59.900 --> 17:00.900
不是要进行解析吗

17:00.900 --> 17:01.900
这个页面中的图片

17:01.900 --> 17:03.900
是不是要重新去拿

17:03.900 --> 17:05.900
这个页面中包含的CSS

17:05.900 --> 17:06.900
是不是要重新去拿

17:06.900 --> 17:07.900
包含的GS

17:07.900 --> 17:08.900
是不是要重新去拿

17:08.900 --> 17:09.900
就这么个意思

17:09.900 --> 17:10.900
就这么个意思

17:10.900 --> 17:11.900
咱们发到第一个

17:11.900 --> 17:12.900
你看

17:12.900 --> 17:13.900
第一个就是我们这里

17:13.900 --> 17:14.900
请求的页面

17:14.900 --> 17:15.900
请求的页面

17:15.900 --> 17:17.900
那么请求了页面之后呢

17:17.900 --> 17:18.900
这些页面的资源相关资源

17:18.900 --> 17:20.900
因为它的解析这个页面呆满了

17:20.900 --> 17:22.900
江湾资源它要重新去拿

17:22.900 --> 17:23.900
所以说得重新发送请求

17:23.900 --> 17:24.900
因此呢

17:24.900 --> 17:25.900
哪怕你只请求一个页面

17:25.900 --> 17:27.900
实际上发送了很多请求

17:27.900 --> 17:28.900
这是很正常的

17:28.900 --> 17:29.900
咱们主要是看一下

17:29.900 --> 17:31.900
你请求这个地址的时候

17:31.900 --> 17:33.900
服务器给力的返回的是什么

17:33.900 --> 17:34.900
电脑呢

17:34.900 --> 17:35.900
点这个response

17:35.900 --> 17:36.900
点这

17:36.900 --> 17:38.900
你看这是服务器返回的结果

17:38.900 --> 17:40.900
你看很多东西

17:40.900 --> 17:41.900
这个页面的所有的代码

17:41.900 --> 17:42.900
是不是服务器

17:42.900 --> 17:43.900
服装给力的

17:43.900 --> 17:44.900
对吧

17:44.900 --> 17:45.900
整个服务装计划

17:45.900 --> 17:46.900
会把整个东西全部给力

17:46.900 --> 17:47.900
你看

17:47.900 --> 17:48.900
7000多行代码

17:48.900 --> 17:49.900
全部给力

17:49.900 --> 17:50.900
那么扭烂器拿到这个代码

17:50.900 --> 17:51.900
是不是可以渲染了

17:51.900 --> 17:52.900
对不对

17:52.900 --> 17:53.900
渲染的过程中

17:53.900 --> 17:54.900
遇到了什么

17:54.900 --> 17:55.900
你看一下

17:55.900 --> 17:56.900
是不是一个link

17:56.900 --> 17:57.900
一个link

17:57.900 --> 17:59.900
link能连接到一张图片

17:59.900 --> 18:00.900
连接到一张图片

18:00.900 --> 18:01.900
它是不是要重新请求

18:01.900 --> 18:03.900
去拿这张图片

18:03.900 --> 18:05.900
包括什么

18:05.900 --> 18:07.900
下面的一些

18:07.900 --> 18:08.900
GS

18:08.900 --> 18:09.900
对吧

18:09.900 --> 18:10.900
有个srcGS

18:10.900 --> 18:11.900
那么服务器

18:11.900 --> 18:12.900
是不是要重新去拿这个GS

18:12.900 --> 18:13.900
重新请求这个地址

18:13.900 --> 18:14.900
是这么来的

18:14.900 --> 18:16.900
这些GS是这么来的

18:16.900 --> 18:18.900
都是传统的解决办法

18:18.900 --> 18:19.900
传统的解决办法

18:19.900 --> 18:21.900
那么在传统的解决办法中

18:21.900 --> 18:22.900
它有这么一个特点

18:22.900 --> 18:24.900
就是

18:26.900 --> 18:29.900
传统的服务器装的MVC模式

18:29.900 --> 18:30.900
我们再说一下

18:30.900 --> 18:32.900
它的就是环境

18:32.900 --> 18:33.900
环境是什么呢

18:33.900 --> 18:35.900
就是服务端

18:35.900 --> 18:37.900
需要返回

18:37.900 --> 18:39.900
需要想用

18:39.900 --> 18:41.900
一个完整的

18:41.900 --> 18:42.900
ATM

18:42.900 --> 18:45.900
需要想用一个完整的ATM

18:45.900 --> 18:47.900
该

18:47.900 --> 18:49.900
ATM中

18:49.900 --> 18:51.900
需要包含

18:51.900 --> 18:53.900
页面需要的数据

18:53.900 --> 18:55.900
这个页面中

18:55.900 --> 18:57.900
它包含了页面中需要的数据

18:57.900 --> 18:58.900
这什么意思呢

18:58.900 --> 19:00.900
就比方说这个新浪网站

19:00.900 --> 19:01.900
你看一下这里

19:01.900 --> 19:02.900
这些新闻

19:02.900 --> 19:03.900
那么看一下

19:03.900 --> 19:04.900
这里是什么

19:04.900 --> 19:06.900
中国旅游团在老窝

19:06.900 --> 19:07.900
我们这里搜索一下

19:07.900 --> 19:09.900
康兽加F

19:09.900 --> 19:13.900
中国旅游团

19:13.900 --> 19:15.900
其实大家已经看到了

19:15.900 --> 19:17.900
你看在服务器的响应结果里边

19:17.900 --> 19:19.900
是不是这个数据就已经带进来了

19:19.900 --> 19:21.900
就已经带进来了

19:21.900 --> 19:23.900
这个页面就已经给你拼完了

19:23.900 --> 19:24.900
一个完整的ATM页面

19:24.900 --> 19:25.900
就全部东西都有了

19:25.900 --> 19:27.900
包括服务器的这些数据

19:27.900 --> 19:28.900
全部都有了

19:28.900 --> 19:29.900
一起给地方

19:29.900 --> 19:30.900
响应到客户团

19:30.900 --> 19:31.900
那么浏览器要做的事情

19:31.900 --> 19:32.900
其实就是简单的

19:32.900 --> 19:34.900
把这个页面宣传出来就完了

19:34.900 --> 19:36.900
这就是最传统的那种

19:36.900 --> 19:37.900
做法

19:37.900 --> 19:39.900
它就用这种模式来做的

19:40.900 --> 19:41.900
那么这种模式

19:41.900 --> 19:42.900
肯定跟现在不一样

19:42.900 --> 19:44.900
现在的模式是什么呢

19:44.900 --> 19:45.900
我们后边来说

19:45.900 --> 19:46.900
说到的时候再说

19:47.900 --> 19:50.900
因此我们在以前的处理当中

19:50.900 --> 19:51.900
就是服务端

19:51.900 --> 19:53.900
要想用一个完整的ATM

19:53.900 --> 19:54.900
这个ATM

19:54.900 --> 19:56.900
还要包含页面中需要的数据

19:56.900 --> 19:57.900
全部都包含进来

19:57.900 --> 19:59.900
然后整个一起发送到客户端

19:59.900 --> 20:01.900
那么客户端直接把宣传出来就完事了

20:01.900 --> 20:03.900
就是浏览器

20:03.900 --> 20:06.900
浏览器仅承担

20:06.900 --> 20:08.900
承担

20:08.900 --> 20:10.900
宣传页面的作用

20:12.900 --> 20:14.900
如果说要执行介石的话

20:14.900 --> 20:16.900
都是执行一些少量的

20:16.900 --> 20:17.900
一些效果的一些介石

20:17.900 --> 20:18.900
比方说

20:18.900 --> 20:19.900
换灯片的轮波

20:19.900 --> 20:21.900
就是轮波图

20:21.900 --> 20:23.900
比方说一些滚动效果

20:23.900 --> 20:26.900
这些就是一些简单的视觉动效

20:26.900 --> 20:28.900
这是介石要承担的作用

20:28.900 --> 20:30.900
大部分这些什么数据

20:30.900 --> 20:32.900
页面中有哪些元素

20:32.900 --> 20:34.900
全部是服务端给你渲染好的

20:34.900 --> 20:37.900
我们把整个过程叫做服务端渲染

20:38.900 --> 20:44.660
以上的这种方式

20:44.660 --> 20:47.660
叫做服务端渲染

20:48.660 --> 20:49.660
什么意思呢

20:49.660 --> 20:50.660
什么叫服务端渲染

20:50.660 --> 20:51.660
就是济

20:51.660 --> 20:53.660
服务器端

20:53.660 --> 20:55.660
将页面

20:55.660 --> 20:57.660
将完整的页面

20:57.660 --> 21:00.660
页面组装好之后

21:02.660 --> 21:06.660
一起发送给客户端

21:06.660 --> 21:07.660
就是给客户端的就是

21:07.660 --> 21:09.660
已经是一个完整的页面了

21:09.660 --> 21:10.660
就已经是一个完整的页面了

21:10.660 --> 21:11.660
你看这里

21:11.660 --> 21:13.660
就是一个非常非常完整的页面

21:13.660 --> 21:14.660
它就没有元素

21:14.660 --> 21:15.660
有数据

21:15.660 --> 21:17.660
客户端这边基本不要去动这个元素

21:17.660 --> 21:19.660
只做一些动效就行了

21:19.660 --> 21:20.660
比方说这里

21:20.660 --> 21:21.660
主要以上去切换

21:21.660 --> 21:22.660
只做这些事情就行了

21:23.660 --> 21:26.660
这是传统的这种方式

21:26.660 --> 21:27.660
那么传统的方式

21:27.660 --> 21:30.660
服务器就要承担很多很多的职能

21:30.660 --> 21:32.660
因为它要去组装这个页面

21:32.660 --> 21:34.660
组装页面是很复杂的过程

21:34.660 --> 21:35.660
你想我们现在学什么

21:35.660 --> 21:36.660
组建化开发

21:36.660 --> 21:37.660
react

21:37.660 --> 21:38.660
它不就是在组装页面

21:38.660 --> 21:39.660
对吧

21:39.660 --> 21:40.660
但是它是不是服务器

21:40.660 --> 21:41.660
它不是服务器

21:41.660 --> 21:42.660
它不是服务器

21:42.660 --> 21:43.660
它是在客户端

21:43.660 --> 21:44.660
所以现在的方式

21:44.660 --> 21:45.660
跟以前不太一样了

21:45.660 --> 21:46.660
以前是要在服务器端

21:46.660 --> 21:48.660
组装一个完整的页面

21:48.660 --> 21:49.660
所以以前的服务器端

21:49.660 --> 21:51.660
要承担很多很多的工作

21:51.660 --> 21:53.660
因此以前的后台

21:53.660 --> 21:54.660
后端的开发人员

21:54.660 --> 21:56.660
薪水待遇是要高一些

21:56.660 --> 21:58.660
因为他们要学很多很多的知识

21:58.660 --> 21:59.660
不光要学后端的知识

21:59.660 --> 22:02.660
还要学很多跟页面相关的知识

22:02.660 --> 22:04.660
因为页面也是在后端组装的

22:04.660 --> 22:06.660
在服务器端组装的

22:06.660 --> 22:07.660
但是现在不一样了

22:07.660 --> 22:08.660
现在为什么前端的薪水待遇

22:08.660 --> 22:09.660
一下子就起来了

22:09.660 --> 22:10.660
因为这些事情

22:10.660 --> 22:11.660
要前端来做了

22:11.660 --> 22:12.660
不要服务器来做了

22:12.660 --> 22:14.660
这是现在跟以前的不同

22:14.660 --> 22:15.660
但是以前的东西

22:15.660 --> 22:16.660
我再说一下

22:16.660 --> 22:17.660
你才能理解MVC

22:17.660 --> 22:20.660
因此这个过程是非常复杂的

22:20.660 --> 22:23.660
就是服务器端

22:23.660 --> 22:29.970
就是需要处理UI中

22:29.970 --> 22:33.970
UI中需要要用到的数据

22:33.970 --> 22:34.970
这个数据的处理

22:34.970 --> 22:36.970
它是有一定复杂度的

22:36.970 --> 22:40.970
并且要将数据

22:40.970 --> 22:44.970
迁入到页面中

22:44.970 --> 22:45.970
最终生成一个

22:45.970 --> 22:49.970
最终生成一个完整的

22:50.970 --> 22:51.970
页面

22:51.970 --> 22:53.970
这是服务器要做的事情

22:53.970 --> 22:54.970
它既要拿数据

22:54.970 --> 22:57.970
又要把数据放到页面里边

22:57.970 --> 22:59.970
又要把数据和页面联合起来

22:59.970 --> 23:01.970
生成一个完整的

23:01.970 --> 23:02.970
最终来进行响应

23:02.970 --> 23:04.970
这个过程是比较复杂的

23:04.970 --> 23:08.970
为了解决

23:08.970 --> 23:13.970
这个过程的复杂度

23:13.970 --> 23:14.970
应该说这个

23:14.970 --> 23:18.970
为了降低

23:18.970 --> 23:21.970
处理这个过程的复杂度

23:21.970 --> 23:24.970
出现了MVC模式

23:24.970 --> 23:25.970
出现了这个模式

23:25.970 --> 23:26.970
这个模式的出现

23:26.970 --> 23:28.970
就是为了解决这个复杂度的

23:28.970 --> 23:30.970
那么这个模式到底是怎么回事呢

23:30.970 --> 23:32.970
现在我们就生入到服务器端

23:32.970 --> 23:33.970
看一下服务器端

23:33.970 --> 23:35.970
我们对于浏览器而言

23:35.970 --> 23:36.970
感觉很神奇

23:36.970 --> 23:38.970
我请求了一个地址

23:38.970 --> 23:39.970
他就直接给我了一个

23:39.970 --> 23:40.970
ATM页面了

23:40.970 --> 23:42.970
那么他到底经过了啥事情

23:42.970 --> 23:44.970
才把这个ATM页面给我了呢

23:44.970 --> 23:47.970
现在我们生入到这个服务器里边

23:47.970 --> 23:49.970
看一下它是怎么做的

23:49.970 --> 23:51.970
从你给我一个地址

23:51.970 --> 23:52.970
给我请求个地址

23:52.970 --> 23:54.970
到服务器收到这个请求

23:54.970 --> 23:57.970
那么再到这个服务器

23:57.970 --> 24:00.970
享用这个ATM元代码

24:00.970 --> 24:01.970
它中间经过了那些事情

24:01.970 --> 24:05.970
我们先开一个联系

24:05.970 --> 24:07.970
现在我们去掉科普端

24:07.970 --> 24:09.970
只看服务器

24:09.970 --> 24:10.970
服务器这里边

24:10.970 --> 24:12.970
它经过了这么几件事情

24:12.970 --> 24:13.970
看一下MVC模式

24:13.970 --> 24:14.970
它是怎么处理的

24:14.970 --> 24:16.970
经过了这么几件事

24:16.970 --> 24:19.970
第一件事就是

24:19.970 --> 24:21.970
收到一个请求地址

24:21.970 --> 24:24.970
收到一个请求地址

24:24.970 --> 24:27.970
收到一个请求

24:27.970 --> 24:30.970
它服务器首先触发这个东西

24:30.970 --> 24:31.970
你可以认为它是一个事件

24:31.970 --> 24:34.970
在服务器端它突然收到了一个请求

24:34.970 --> 24:35.970
那么请求拿到过后

24:35.970 --> 24:36.970
要做什么事情

24:36.970 --> 24:37.970
它其实并不知道

24:37.970 --> 24:38.970
并不知道

24:38.970 --> 24:41.970
那么这个时候还会做这么一个处理

24:41.970 --> 24:45.970
就是将不同的请求

24:46.970 --> 24:48.970
什么叫不同的请求

24:48.970 --> 24:49.970
就请求地址不一样

24:49.970 --> 24:51.970
或者是请求方法不一样

24:51.970 --> 24:52.970
有的时候是盖着请求

24:52.970 --> 24:53.970
有的时候是PoSer请求

24:53.970 --> 24:54.970
对吧

24:54.970 --> 24:56.970
将不同的请求

24:56.970 --> 24:59.970
分发到对应的

24:59.970 --> 25:01.970
Controller

25:01.970 --> 25:03.970
叫做控制器

25:03.970 --> 25:04.970
如果你比方说

25:04.970 --> 25:05.970
我们举个例子

25:05.970 --> 25:06.970
比方说在服务器端

25:06.970 --> 25:08.970
它显了三个控制器

25:08.970 --> 25:09.970
每个控制器

25:09.970 --> 25:11.970
还要对应不同的请求地址

25:11.970 --> 25:13.970
那么到时候服务器

25:13.970 --> 25:14.970
收到一个请求地址的时候

25:14.970 --> 25:16.970
它就会把它交给

25:16.970 --> 25:17.970
相应的控制器来处理

25:17.970 --> 25:19.970
那那个控制器怎么写

25:19.970 --> 25:20.970
你现在不用管

25:20.970 --> 25:22.970
你只需要知道这个控制器

25:22.970 --> 25:23.970
它是来做什么的

25:23.970 --> 25:25.970
它是用来处理请求的

25:25.970 --> 25:27.970
不同的控制器

25:27.970 --> 25:29.970
它能对应不同的UIL地址

25:29.970 --> 25:30.970
你请求这个地址

25:30.970 --> 25:31.970
它到这个控制器

25:31.970 --> 25:32.970
请求另外一个地址

25:32.970 --> 25:33.970
到另一个控制器

25:33.970 --> 25:34.970
当然这件事

25:34.970 --> 25:35.970
对于我们客户端而言

25:35.970 --> 25:37.970
它是完全不知道的

25:37.970 --> 25:38.970
它只知道

25:38.970 --> 25:40.970
我最终给了我一个

25:40.970 --> 25:41.970
剩下的事情

25:41.970 --> 25:42.970
它啥都不知道

25:42.970 --> 25:43.970
但是这个服务器端

25:43.970 --> 25:46.970
它是会分发到一个控制器

25:46.970 --> 25:50.410
知道有请求地址

25:50.410 --> 25:52.410
那么它把分发到对应的

25:52.410 --> 25:53.410
扛除了

25:53.410 --> 25:54.410
那么这个玩意

25:54.410 --> 25:55.410
我们就把它叫做

25:55.410 --> 25:56.410
扛除了

25:56.410 --> 25:58.410
叫做控制器

25:58.410 --> 26:01.410
扛除了

26:01.410 --> 26:02.410
它也叫啥了

26:02.410 --> 26:05.780
控制器

26:05.780 --> 26:07.780
干脆我把这些东西

26:07.780 --> 26:10.780
都给它截图发下来

26:10.780 --> 26:18.900
给它截图发下来

26:18.900 --> 26:19.900
等一下

26:19.900 --> 26:22.530
我用Q截图

26:22.530 --> 26:23.530
这里呢

26:23.530 --> 26:27.930
截图

26:27.930 --> 26:29.930
这是这里

26:29.930 --> 26:31.930
这里放一张图片

26:33.930 --> 26:34.930
然后这里

26:34.930 --> 26:35.930
我们这里画完了

26:35.930 --> 26:37.930
过后再放一张图片

26:37.930 --> 26:38.930
到了这个控制器

26:38.930 --> 26:40.930
好 控制器干嘛的呢

26:40.930 --> 26:41.930
控制器有什么作用呢

26:41.930 --> 26:43.930
好 我这里记彼

26:43.930 --> 26:45.930
控制器的作用

26:45.930 --> 26:47.930
扛除了

26:47.930 --> 26:49.930
控制器的作用

26:49.930 --> 26:50.930
什么作用呢

26:50.930 --> 26:53.930
控制器它是用来处理请求

26:53.930 --> 26:55.930
处理请求

26:55.930 --> 26:57.930
就是你这个请求来了

26:57.930 --> 26:59.930
我到底要干嘛

26:59.930 --> 27:01.930
干嘛 它是来处理请求

27:01.930 --> 27:03.930
那么处理请求过程中

27:03.930 --> 27:04.930
具体来说

27:04.930 --> 27:06.930
这个处理的过程中

27:06.930 --> 27:09.930
一般来说它是要组装数据

27:09.930 --> 27:11.930
组装这次请求

27:11.930 --> 27:13.930
需要的数据

27:13.930 --> 27:14.930
那么组装数据

27:14.930 --> 27:16.930
是在控制器里面完成的

27:16.930 --> 27:18.930
控制器里面完成的

27:18.930 --> 27:20.930
那么这个数据是什么呢

27:20.930 --> 27:21.930
这个数据

27:21.930 --> 27:23.930
就是我们说的模型

27:23.930 --> 27:25.930
Model

27:25.930 --> 27:27.930
Model是什么呢

27:27.930 --> 27:33.930
就是需要用于UI渲染的模型

27:33.930 --> 27:35.930
需要用于UI渲染的

27:35.930 --> 27:36.930
就是数据模型

27:36.930 --> 27:38.930
就是比方说我们这个页面

27:38.930 --> 27:39.930
比方说我们这个页面

27:39.930 --> 27:41.930
这个页面中是不是有很多新闻

27:41.930 --> 27:42.930
对吧

27:42.930 --> 27:43.930
那么肯定得有一个新闻数据

27:43.930 --> 27:45.930
那么这个新闻数据就是数据

27:45.930 --> 27:46.930
就这么个意思

27:46.930 --> 27:48.930
那么这个数据是谁组装的呢

27:48.930 --> 27:49.930
这个数据

27:49.930 --> 27:51.930
这个数据是由来Controller来组装的

27:51.930 --> 27:53.930
因为首先是他收到请求

27:53.930 --> 27:54.930
对吧

27:54.930 --> 27:55.930
他收到请求

27:55.930 --> 27:57.930
那么这个请求我先不考虑界面

27:57.930 --> 27:58.930
我先想一想

27:58.930 --> 28:01.930
这个请求我要给你什么样的数据

28:01.930 --> 28:02.930
我要给你什么样的数据

28:02.930 --> 28:03.930
我先把个数据给你组装出来

28:03.930 --> 28:05.930
这个数据是Model

28:05.930 --> 28:10.930
于是控制器会组装出来一个数据

28:10.930 --> 28:13.930
这个数据是一个Model

28:13.930 --> 28:15.930
是一个Model

28:15.930 --> 28:18.930
它会产生一个数据

28:19.930 --> 28:22.930
Model叫做模型

28:22.930 --> 28:25.930
数据模型

28:25.930 --> 28:26.930
好

28:26.930 --> 28:28.930
那么这个数据模型产生之后

28:28.930 --> 28:29.930
这个模型交给谁呢

28:29.930 --> 28:31.930
因为最终我要的不是数据

28:31.930 --> 28:32.930
我要的也不是数据

28:32.930 --> 28:33.930
我要的你看一下

28:33.930 --> 28:35.930
是不是整个ATM页面

28:35.930 --> 28:36.930
对吧

28:36.930 --> 28:37.930
我是要的是不是这个玩意

28:37.930 --> 28:38.930
是吧

28:38.930 --> 28:39.930
是个整个ATM页面

28:39.930 --> 28:40.930
所以说

28:40.930 --> 28:42.930
你这个数据模型产生之后

28:42.930 --> 28:43.930
还没完

28:43.930 --> 28:45.930
这个数据模型呢

28:45.930 --> 28:46.930
它得把它交给一个东西

28:46.930 --> 28:48.930
叫做仕图

28:49.930 --> 28:50.930
对吧

28:50.930 --> 28:51.930
这个数据模型交给一个东西

28:51.930 --> 28:53.930
叫做仕图

28:53.930 --> 28:54.930
你看

28:54.930 --> 28:55.930
控制器来产生数据

28:55.930 --> 28:56.930
好

28:56.930 --> 28:57.930
数据呢

28:57.930 --> 28:58.930
把这个东西交给谁呢

28:58.930 --> 28:59.930
交给伍佑

28:59.930 --> 29:01.930
交给仕图

29:01.930 --> 29:02.930
交给仕图

29:02.930 --> 29:04.930
这个东西叫做仕图

29:04.930 --> 29:05.930
交给仕图过后

29:05.930 --> 29:09.930
仕图最终生成ATM

29:09.930 --> 29:11.930
仕图最终生成ATM

29:11.930 --> 29:12.930
那么返回给

29:12.930 --> 29:14.930
返回给就是客服端

29:14.930 --> 29:16.930
最终仕图这里

29:16.930 --> 29:17.930
它生成

29:17.930 --> 29:18.930
生成ATM

29:18.930 --> 29:20.930
就整个ATM元代

29:20.930 --> 29:21.930
因为仕图是用来干嘛的

29:21.930 --> 29:23.930
仕图就是用来

29:23.930 --> 29:25.930
就是用于显示的界面

29:25.930 --> 29:27.930
就是仕图

29:27.930 --> 29:30.930
完整的ATM

29:30.930 --> 29:32.930
它把整个完整的ATM

29:32.930 --> 29:34.930
返回给客服端

29:34.930 --> 29:35.930
那么最终

29:35.930 --> 29:36.930
对于客服端而言

29:36.930 --> 29:37.930
它不知道这个过程经济了什么

29:37.930 --> 29:38.930
但是呢

29:38.930 --> 29:39.930
实际上

29:39.930 --> 29:40.930
服务器内部

29:40.930 --> 29:41.930
它是经过这么一些事情的

29:41.930 --> 29:42.930
说到请求控制器处理

29:42.930 --> 29:44.930
那么它生成数据

29:44.930 --> 29:45.930
比方说很多新闻

29:45.930 --> 29:46.930
比方说当前登入的用户

29:46.930 --> 29:47.930
对吧

29:47.930 --> 29:48.930
生成很多数据

29:48.930 --> 29:50.930
那么把这个数据

29:50.930 --> 29:51.930
人给仕图

29:51.930 --> 29:52.930
仕图里面有啥呢

29:52.930 --> 29:54.930
仕图里面就有各种元素

29:54.930 --> 29:56.930
有什么CSS代码

29:56.930 --> 29:57.930
有什么GS代码

29:57.930 --> 29:59.930
就是这种东西

29:59.930 --> 30:01.930
全是在服务器组组装完成的

30:01.930 --> 30:02.930
但是仕图里面缺少啥

30:02.930 --> 30:04.930
缺少数据

30:04.930 --> 30:06.930
我现在把数据给定了

30:06.930 --> 30:07.930
仕图里面就可以把数据的东西

30:07.930 --> 30:08.930
拿出来

30:08.930 --> 30:09.930
放到相应的位置

30:09.930 --> 30:10.930
比方说你看

30:10.930 --> 30:14.930
这些新闻

30:14.930 --> 30:15.930
不是有很多标题吗

30:15.930 --> 30:16.930
还有连接地址

30:16.930 --> 30:17.930
对吧

30:17.930 --> 30:18.930
这些新闻

30:18.930 --> 30:19.930
把放下来

30:19.930 --> 30:20.930
这里有很多新闻

30:20.930 --> 30:21.930
你看每一个新闻是Li

30:21.930 --> 30:23.930
那么这些Li元素

30:23.930 --> 30:24.930
就是仕图里面的东西

30:24.930 --> 30:26.930
仕图里面要渲染的东西

30:26.930 --> 30:27.930
就在这里

30:27.930 --> 30:29.930
在仕图里面进行拼接

30:29.930 --> 30:30.930
那么拼接的时候

30:30.930 --> 30:31.930
Li里面

30:31.930 --> 30:33.930
它是新闻的标题市场

30:33.930 --> 30:34.930
它不知道

30:34.930 --> 30:35.930
不知道

30:35.930 --> 30:36.930
那么是不是模型里面

30:36.930 --> 30:37.930
它就给力了

30:37.930 --> 30:39.930
控制器它来组装数据模型

30:39.930 --> 30:40.930
把数据给力了过后

30:40.930 --> 30:41.930
你就可以在这里面

30:41.930 --> 30:43.930
把数据里面的东西取出来

30:43.930 --> 30:44.930
拼接到

30:44.930 --> 30:46.930
你可以认为就是拼接

30:46.930 --> 30:47.930
拼接到这些元素里面

30:47.930 --> 30:48.930
那么就形成数据了

30:48.930 --> 30:50.930
最终把数据也拼接进去了

30:50.930 --> 30:52.930
元素本身就带的

30:52.930 --> 30:53.930
然后

30:53.930 --> 30:54.930
把整个完整的itema

30:54.930 --> 30:55.930
就返回

30:55.930 --> 30:56.930
给客户端了

30:56.930 --> 30:57.930
这服务器

30:57.930 --> 30:59.930
经过了这么一些系列的操作

30:59.930 --> 31:03.930
这就是服务器端的MVC模式

31:03.930 --> 31:05.930
控制器组装数据

31:05.930 --> 31:07.930
数据传递给仕图

31:07.930 --> 31:08.930
仕图完成一个

31:08.930 --> 31:09.930
整个界面的组装

31:09.930 --> 31:11.930
然后一起扔回个客户端

31:11.930 --> 31:13.930
那么有一天客户端那边

31:13.930 --> 31:14.930
比方说点了一个按钮

31:14.930 --> 31:15.930
对吧

31:15.930 --> 31:16.930
或者是又有一个

31:16.930 --> 31:17.930
凤姆表单提交

31:17.930 --> 31:18.930
或者是又点了一个A元素

31:18.930 --> 31:20.930
是不是又来重新来一次

31:20.930 --> 31:21.930
又来请求服务器

31:21.930 --> 31:23.930
那么这又重新分配到一个ctr

31:23.930 --> 31:24.930
对吧

31:24.930 --> 31:25.930
又重新分配到一个ctr

31:25.930 --> 31:27.930
又来组装数据

31:27.930 --> 31:30.930
又把这个数据又扔给对应的仕图

31:30.930 --> 31:31.930
又对应的仕图

31:31.930 --> 31:32.930
那么对应的仕图

31:32.930 --> 31:33.930
又来组装这个数据

31:33.930 --> 31:34.930
但是仕图有很多

31:34.930 --> 31:36.930
不同页面有不同的仕图

31:36.930 --> 31:38.930
那么最终又返回客户端

31:38.930 --> 31:40.930
这就是传统的服务端模式

31:40.930 --> 31:42.930
这种模式其实应用了

31:42.930 --> 31:43.930
多很多年了

31:43.930 --> 31:45.930
这种模式它的边界非常非常清楚

31:45.930 --> 31:47.930
比方说那种控制器

31:47.930 --> 31:49.930
控制器它只处理什么

31:49.930 --> 31:51.930
处理功能逻辑

31:51.930 --> 31:53.930
它控制器只来处理功能逻辑

31:53.930 --> 31:55.930
刚才还没有记这个仕图

31:55.930 --> 31:56.930
对吧

31:56.930 --> 31:57.930
无诱

31:57.930 --> 32:00.930
它表示仕图

32:00.930 --> 32:03.930
用于将模型

32:03.930 --> 32:07.930
组装到界面中

32:07.930 --> 32:09.930
它是要关心界面的

32:09.930 --> 32:10.930
你看看这个功能

32:10.930 --> 32:12.930
各个地方的职责非常明确

32:12.930 --> 32:14.930
控制器用来干嘛的

32:14.930 --> 32:16.930
控制器用来处理请求的

32:16.930 --> 32:17.930
它只在乎功能

32:17.930 --> 32:18.930
你给我的

32:18.930 --> 32:20.930
我要实现一个什么样的功能

32:20.930 --> 32:22.930
界面是什么样子

32:22.930 --> 32:23.930
管的不管

32:23.930 --> 32:24.930
管的界面是啥样子

32:24.930 --> 32:26.930
我只来处理功能

32:26.930 --> 32:28.930
比方说你请求的一个地址

32:28.930 --> 32:30.930
比方说

32:30.930 --> 32:32.930
你请求的一个地址是Poser请求

32:32.930 --> 32:34.930
你请求的这个地址Login

32:34.930 --> 32:35.930
表示登录

32:35.930 --> 32:38.930
然后消息体里面写到一个数据

32:38.930 --> 32:39.930
比方说帐号

32:39.930 --> 32:40.930
比方说在这里

32:40.930 --> 32:43.930
消息体里面这样写的Login ID

32:43.930 --> 32:45.930
帐号你写了一个

32:45.930 --> 32:46.930
比方说Ername

32:46.930 --> 32:48.930
然后Login Password

32:48.930 --> 32:51.930
密码你写了一个就是123123

32:51.930 --> 32:53.930
那么这是它写在的数据

32:53.930 --> 32:55.930
这是Poser请求请求方法

32:55.930 --> 32:56.930
请求地址是Login

32:56.930 --> 32:58.930
于是到福西乱

32:58.930 --> 33:00.930
它就会分配到一个控制器来处理

33:00.930 --> 33:02.930
控制器来处理这个请求的时候

33:02.930 --> 33:03.930
它就知道了

33:03.930 --> 33:04.930
你现在我要做登录

33:04.930 --> 33:06.930
那么我要判断你到底能不能登录成功

33:06.930 --> 33:08.930
那么我是不是要拿这个Ername

33:08.930 --> 33:10.930
拿这个密码来判断一下

33:10.930 --> 33:12.930
要不要能不能登录成功

33:12.930 --> 33:15.930
那么我只处理能不能登录成功这件事

33:15.930 --> 33:17.930
明白这个意思吗

33:17.930 --> 33:19.930
登录失败我给力啥我不管

33:19.930 --> 33:21.930
登录成功我又给力啥我不管

33:21.930 --> 33:23.930
我只处理能不能登录成功这件事

33:23.930 --> 33:25.930
处理完了过后

33:25.930 --> 33:28.930
我就会形成一个相应的数据

33:28.930 --> 33:30.930
就是数据模型

33:30.930 --> 33:32.930
比方说举个例子

33:32.930 --> 33:33.930
比方说登录成功

33:33.930 --> 33:35.930
我就形成这么一个数据

33:35.930 --> 33:36.930
举个例子

33:36.930 --> 33:37.930
Status

33:37.930 --> 33:39.930
比方说

33:39.930 --> 33:40.930
sys

33:40.930 --> 33:42.930
表示登录成功了

33:42.930 --> 33:43.930
然后message

33:43.930 --> 33:45.930
是登录成功

33:45.930 --> 33:46.930
登录成功

33:46.930 --> 33:47.930
举个例子

33:47.930 --> 33:49.930
比方说这是登录成功

33:49.930 --> 33:50.930
它的期待的数据

33:50.930 --> 33:51.930
这就是个模型

33:51.930 --> 33:53.930
好如果说登录失败

33:53.930 --> 33:54.930
登录失败的话

33:54.930 --> 33:55.930
比方说我们是另外一个数据

33:55.930 --> 33:56.930
叫做feal

33:56.930 --> 33:57.930
feal

33:57.930 --> 33:58.930
登录失败

33:58.930 --> 33:59.930
那么这里

33:59.930 --> 34:00.930
message那是登录失败

34:00.930 --> 34:01.930
帐号密码

34:01.930 --> 34:02.930
或者是帐号错误

34:02.930 --> 34:03.930
或者是密码错误

34:03.930 --> 34:04.930
等等等等

34:04.930 --> 34:06.930
就是说我可以通过模型

34:06.930 --> 34:08.930
来反映我的功能

34:08.930 --> 34:09.930
操作的结果

34:09.930 --> 34:10.930
对吧

34:10.930 --> 34:12.930
这是控制其他完成功能

34:12.930 --> 34:13.930
他来处理寻求

34:13.930 --> 34:14.930
然后模型

34:14.930 --> 34:16.930
他来反映我处理的结果

34:16.930 --> 34:17.930
最后这个模型

34:17.930 --> 34:18.930
会交给仕图

34:18.930 --> 34:19.930
那么仕图

34:19.930 --> 34:21.930
根据我处理的结果

34:21.930 --> 34:22.930
把它渲染出来

34:22.930 --> 34:23.930
对不对

34:23.930 --> 34:24.930
是有点感觉了

34:24.930 --> 34:25.930
听着听着

34:25.930 --> 34:26.930
是有点感觉了

34:26.930 --> 34:27.930
好

34:27.930 --> 34:28.930
那么这就是以前

34:28.930 --> 34:31.930
传统的服务端的MVC模式

34:31.930 --> 34:33.930
登录一下吧

34:33.930 --> 34:34.930
好

34:34.930 --> 34:37.930
那么为什么要讲这个东西呢

34:37.930 --> 34:39.930
是因为后来

34:39.930 --> 34:41.930
后来服务端的MVC模式

34:41.930 --> 34:43.930
它要应用到前端了

34:43.930 --> 34:54.030
前端MVC模式的困难

34:54.030 --> 34:55.030
既然标题这样子去

34:55.030 --> 34:56.030
你肯定知道

34:56.030 --> 34:58.030
前端要用MVC模式

34:58.030 --> 35:00.030
难度是很高的

35:00.030 --> 35:02.030
而且不太好

35:02.030 --> 35:03.030
我们来讲一讲

35:03.030 --> 35:06.030
它为什么在现代的前端里边

35:06.030 --> 35:08.030
想用这个MVC模式

35:08.030 --> 35:10.030
它为什么要出问题

35:10.030 --> 35:11.030
好

35:11.030 --> 35:12.030
咱们来看一下

35:12.030 --> 35:15.030
前端MVC模式为什么会困难

35:15.030 --> 35:16.030
就是说

35:16.030 --> 35:17.030
首先我们从刚才

35:17.030 --> 35:18.030
刚才那种服务端

35:18.030 --> 35:19.030
这种模式

35:19.030 --> 35:21.030
为起点继续讲

35:21.030 --> 35:24.030
突然有一天

35:24.030 --> 35:26.030
ES6出现了

35:26.030 --> 35:27.030
突然有一天

35:27.030 --> 35:28.030
Webpack出现了

35:28.030 --> 35:31.030
然后突然有一天Ragged出现了

35:31.030 --> 35:32.030
还有Viu出现了

35:32.030 --> 35:35.030
前端开始迅速的发展

35:35.030 --> 35:37.030
以前传统意义上

35:37.030 --> 35:39.030
在服务器这端的

35:39.030 --> 35:41.030
去组装这个仕图

35:41.030 --> 35:43.030
在服务器端组装那个仕图的功能

35:43.030 --> 35:44.030
服务器觉得

35:44.030 --> 35:46.030
哎呀我这个东西太烦了

35:46.030 --> 35:49.030
前端又出来那么多东西

35:49.030 --> 35:50.030
我一个后端开发人员

35:50.030 --> 35:52.030
我既要去学数据库

35:52.030 --> 35:55.030
又要去写什么各种服务器优化方案

35:55.030 --> 35:57.030
什么缓存啊

35:57.030 --> 35:58.030
什么session啊

35:58.030 --> 36:01.030
什么那个就是那个那个那个

36:01.030 --> 36:02.030
分布式啊

36:02.030 --> 36:03.030
对吧

36:03.030 --> 36:04.030
还有什么

36:04.030 --> 36:05.030
真正式啊

36:05.030 --> 36:06.030
乱七八糟的技术

36:06.030 --> 36:07.030
一大堆就已经够我烦的了

36:07.030 --> 36:08.030
还学什么

36:08.030 --> 36:10.030
说安法设计模式一大堆

36:10.030 --> 36:11.030
我已经够烦了

36:11.030 --> 36:12.030
你好吧

36:12.030 --> 36:13.030
你现在一个前端

36:13.030 --> 36:14.030
又出来那么多东西

36:14.030 --> 36:15.030
我哪受得了

36:15.030 --> 36:17.030
我真的是受不了了

36:17.030 --> 36:18.030
于是呢

36:18.030 --> 36:21.030
后端开发人员是不堪重后

36:21.030 --> 36:24.030
于是他希望这件事情

36:24.030 --> 36:27.030
就是跟见面相关的事情呢

36:27.030 --> 36:29.030
能不能前端

36:29.030 --> 36:31.030
专业的前端开发人员来搞定

36:31.030 --> 36:32.030
我不儿了

36:32.030 --> 36:34.030
这件事情我真的是我而不了了

36:34.030 --> 36:35.030
于是呢

36:35.030 --> 36:36.030
就形成了

36:36.030 --> 36:39.030
前后端分离模式

36:39.030 --> 36:41.030
把这个图给他复制一下

36:41.030 --> 36:45.140
这里

36:45.140 --> 36:48.980
好

36:48.980 --> 36:49.980
现在让我们看一下

36:49.980 --> 36:51.980
前后端分离模式

36:51.980 --> 36:53.980
以前的不是这种模式

36:53.980 --> 36:54.980
以前是服务器质疑的小银

36:54.980 --> 36:56.980
也听没原代吗

36:56.980 --> 36:59.980
看一下前后端分离模式

36:59.980 --> 37:02.980
前后端分离模式是这样子的

37:02.980 --> 37:04.980
我们还是以这个图为例

37:04.980 --> 37:05.980
先从减入

37:05.980 --> 37:06.980
从凡入减吧

37:06.980 --> 37:08.980
从减入凡

37:08.980 --> 37:09.980
第一个请求一样的

37:09.980 --> 37:11.980
请求一个UIL地址

37:11.980 --> 37:13.980
那么服务器响应的是什么呢

37:13.980 --> 37:15.980
响应的不是ATM原代吗

37:15.980 --> 37:17.980
响应的是一个

37:17.980 --> 37:20.980
基本的注意基础的

37:20.980 --> 37:23.980
ATM结构

37:23.980 --> 37:25.980
响应的是注意基础的ATM结构

37:25.980 --> 37:26.980
然后呢

37:26.980 --> 37:28.980
附带

37:28.980 --> 37:30.980
附带GS

37:30.980 --> 37:34.300
附带GS营用

37:34.300 --> 37:35.300
好

37:35.300 --> 37:36.300
这是服务器响应的结构

37:36.300 --> 37:37.300
响应的最基础

37:37.300 --> 37:38.300
以后我们会看

37:38.300 --> 37:40.300
会响应的最基础的ATM结构

37:40.300 --> 37:41.300
附带GS营用

37:41.300 --> 37:43.300
在浏览器这一端

37:43.300 --> 37:45.300
那么这个基础结构

37:45.300 --> 37:46.300
到了浏览器这一端

37:46.300 --> 37:47.300
它是不是可以把这个基础结构

37:47.300 --> 37:48.300
渲染出来

37:48.300 --> 37:49.300
然后有个GS营用

37:49.300 --> 37:51.300
是不是要把GS重新拿到

37:51.300 --> 37:52.300
拿到个GS

37:52.300 --> 37:53.300
第三步

37:53.300 --> 37:54.300
在浏览器端

37:54.300 --> 37:56.300
执行GS

37:56.300 --> 37:58.300
执行GS

37:58.300 --> 38:00.300
用GS

38:00.300 --> 38:02.300
渲染出

38:02.300 --> 38:05.300
GS动态的

38:05.300 --> 38:08.300
就是控制页面元素

38:08.300 --> 38:09.300
对吧

38:09.300 --> 38:10.300
这就是View啊

38:10.300 --> 38:11.300
像React这些框架要做的事情

38:11.300 --> 38:13.300
框架要做这件事情

38:13.300 --> 38:15.300
ReactView 框架在做这件事情

38:15.300 --> 38:16.300
好 咱们来看一下吧

38:16.300 --> 38:17.300
一看你就明白了

38:17.300 --> 38:18.300
好 这里呢

38:18.300 --> 38:20.300
我们保存一下

38:20.300 --> 38:22.300
好 我这里进入这个

38:22.300 --> 38:23.300
我们之前不是用过React那吗

38:23.300 --> 38:24.300
对吧

38:24.300 --> 38:25.300
React这个工程

38:25.300 --> 38:26.300
React工程里

38:26.300 --> 38:28.300
把我们这里随便写一个吧

38:28.300 --> 38:29.300
随便写一个

38:29.300 --> 38:30.300
A7议员书吧

38:30.300 --> 38:31.300
Hello React

38:31.300 --> 38:34.670
这里随便写一个

38:34.670 --> 38:35.670
咱们把它运行出来

38:36.670 --> 38:37.670
看一下吧

38:37.670 --> 38:38.670
看一下

38:38.670 --> 38:39.670
现在这种模式

38:39.670 --> 38:41.670
跟以前的传统的服务器模式

38:41.670 --> 38:43.670
有什么样的不同

38:43.670 --> 38:44.670
我们这里写了个DIV

38:44.670 --> 38:46.670
DIV里面的A7议员书

38:48.670 --> 38:49.670
这里让它现场出来

38:56.910 --> 38:58.910
点击右键检查

38:58.910 --> 38:59.910
这里呢

38:59.910 --> 39:01.910
仍然是找到这个network

39:01.910 --> 39:03.910
看一下跟服务器端交互

39:03.910 --> 39:04.910
这里有没有服务器呢

39:04.910 --> 39:05.910
有的

39:05.910 --> 39:06.910
这个教授家会在本级里

39:06.910 --> 39:07.910
搭一个服务器

39:07.910 --> 39:08.910
服务器的请求地址

39:08.910 --> 39:09.910
就是Local House

39:10.910 --> 39:11.910
端口号是3000

39:11.910 --> 39:12.910
咱们刷新一下

39:12.910 --> 39:13.910
你看一下

39:13.910 --> 39:14.910
第一个是不是请求一个地址

39:14.910 --> 39:15.910
好

39:15.910 --> 39:16.910
咱们来打开这个地址

39:16.910 --> 39:17.910
看一下这个地址

39:18.910 --> 39:19.910
服务器的响应结果

39:19.910 --> 39:20.910
你看一下

39:21.910 --> 39:23.910
服务器的响应结果里面

39:23.910 --> 39:24.910
有这个玩意吗

39:25.910 --> 39:26.910
有吗

39:26.910 --> 39:27.910
有这个DIV吗

39:27.910 --> 39:28.910
有这个A7吗

39:28.910 --> 39:29.910
有吗

39:29.910 --> 39:30.910
是没有

39:30.910 --> 39:32.910
服务器的响应结果是哪

39:32.910 --> 39:33.910
是这个

39:33.910 --> 39:34.910
这是服务器的响应结果

39:35.910 --> 39:36.910
那这个玩意

39:36.910 --> 39:37.910
你回忆一下

39:37.910 --> 39:38.910
我们之前在React开发过程中

39:38.910 --> 39:39.910
动没动这个玩意

39:39.910 --> 39:40.910
几乎没动

39:40.910 --> 39:41.910
没有去动它

39:41.910 --> 39:42.910
对不对

39:42.910 --> 39:43.910
没有去动这个玩意

39:43.910 --> 39:45.910
服务器给我的是这个东西

39:45.910 --> 39:46.910
他给我们的是这个东西

39:46.910 --> 39:48.910
那凭什么我们页面上能出现这个玩意

39:48.910 --> 39:50.910
他的逻辑是这样子的

39:50.910 --> 39:52.910
他给了我一个DIV

39:52.910 --> 39:53.910
给了我这个东西

39:53.910 --> 39:54.910
同时呢

39:54.910 --> 39:55.910
有一些介石

39:55.910 --> 39:56.910
在里面

39:56.910 --> 39:57.910
到时候呢

39:57.910 --> 39:58.910
我们React写完了

39:58.910 --> 39:59.910
打包之后呢

39:59.910 --> 40:00.910
他会给我们生成一些

40:00.910 --> 40:01.910
打包的介石文件

40:01.910 --> 40:02.910
对吧

40:02.910 --> 40:03.910
他会把个介石文件注入到这里

40:03.910 --> 40:05.910
注入到这个页面里边

40:05.910 --> 40:06.910
于是在一个页面里面

40:06.910 --> 40:07.910
就带入了这些东西了

40:07.910 --> 40:08.910
对吧

40:08.910 --> 40:09.910
有些介石

40:09.910 --> 40:10.910
一看这

40:10.910 --> 40:11.910
服务器提供的是一个

40:11.910 --> 40:12.910
最基础的一个结构

40:12.910 --> 40:13.910
就是这种结构

40:13.910 --> 40:14.910
就是这个玩意

40:14.910 --> 40:15.910
这是服务器提供给我们的

40:15.910 --> 40:17.910
就这个东西

40:17.910 --> 40:18.910
然后这个介石

40:18.910 --> 40:20.910
这个页面中呢

40:20.910 --> 40:21.910
打包之后

40:21.910 --> 40:22.910
他会给你生成一个就是介石

40:22.910 --> 40:23.910
对吧

40:23.910 --> 40:25.910
有一个介石在里边

40:25.910 --> 40:26.910
这个页面东西

40:26.910 --> 40:27.910
还有个介石

40:27.910 --> 40:28.910
于是呢

40:28.910 --> 40:29.910
在我们去请求这个地址的时候

40:29.910 --> 40:30.910
那是不是可以拿到这些介石

40:30.910 --> 40:31.910
对吧

40:31.910 --> 40:32.910
他又会

40:32.910 --> 40:33.910
重新请求这个介石

40:33.910 --> 40:34.910
这些介石代码

40:34.910 --> 40:35.910
重新从服务器拿到了

40:35.910 --> 40:36.910
对吧

40:36.910 --> 40:38.910
那么浏览器剩下的工作

40:38.910 --> 40:40.910
服务器不参与了

40:40.910 --> 40:42.910
剩下的服务器不参与了

40:42.910 --> 40:44.910
也就是现在服务器变得极其简单了

40:44.910 --> 40:45.910
至少在UI这个层面

40:45.910 --> 40:47.910
服务器完全不管了

40:47.910 --> 40:48.910
服务器完全不管了

40:48.910 --> 40:50.910
服务器这里就是给你提供一个

40:50.910 --> 40:51.910
非常简单的页面

40:51.910 --> 40:53.910
就这个玩意

40:53.910 --> 40:54.910
好

40:54.910 --> 40:55.910
剩下的事他不管了

40:55.910 --> 40:56.910
剩下的事情

40:56.910 --> 40:57.910
全部让介石代完成

40:57.910 --> 40:59.910
浏览器这一端执行介石

40:59.910 --> 41:01.910
你不是引用了介石吗

41:01.910 --> 41:02.910
执行你这些介石

41:02.910 --> 41:03.910
把这个介石里边

41:03.910 --> 41:05.910
是不是有很多代码可以控制

41:05.910 --> 41:06.910
我们之前讲了那么多

41:06.910 --> 41:07.910
对吧

41:07.910 --> 41:08.910
RECT是渲染原理

41:08.910 --> 41:09.910
它怎么去渲染页面的

41:09.910 --> 41:11.910
它就可以通过介石来操作动物元素

41:11.910 --> 41:14.910
来生成页面里边各种内容

41:14.910 --> 41:15.910
需要数据的地方

41:15.910 --> 41:17.910
我们可以使用阿迦克斯请求

41:17.910 --> 41:19.910
从服务器去拿数据

41:19.910 --> 41:20.910
拿数据过后

41:20.910 --> 41:22.910
本地用介石把这个数据

41:22.910 --> 41:24.910
组装到我们的页面中

41:24.910 --> 41:26.910
因此我们现在的

41:26.910 --> 41:29.910
完整的页面不再服务器端

41:29.910 --> 41:30.910
是在浏览器端

41:30.910 --> 41:32.910
就是在客户端这里组装的

41:32.910 --> 41:34.910
这就是前后端分离模式

41:34.910 --> 41:35.910
为什么叫分离

41:35.910 --> 41:37.910
服务器只提供数据

41:37.910 --> 41:39.910
你要请求学生

41:39.910 --> 41:40.910
我给你学生数据

41:40.910 --> 41:41.910
一个数据

41:41.910 --> 41:43.910
你要见面是咋样子

41:43.910 --> 41:44.910
我管都不管

41:44.910 --> 41:46.910
我压格就不管

41:46.910 --> 41:48.910
所以说现在

41:48.910 --> 41:50.910
把UI的复杂度

41:50.910 --> 41:52.910
提皮球

41:52.910 --> 41:54.910
又提给了浏览器了

41:54.910 --> 41:56.910
浏览器现在

41:56.910 --> 41:58.910
它现在又要来解决

41:58.910 --> 41:59.910
UI的复杂度了

41:59.910 --> 42:00.910
你看RECT是不是

42:00.910 --> 42:01.910
在解决UI的复杂度

42:01.910 --> 42:02.910
对吧

42:02.910 --> 42:03.910
因为能用这么多东西

42:03.910 --> 42:05.910
我怎么去渲染

42:05.910 --> 42:06.910
怎么来做到互补干扰

42:06.910 --> 42:08.910
怎么写出来高效的代码

42:08.910 --> 42:09.910
优雅的代码

42:09.910 --> 42:10.910
怎么来写一个代码

42:10.910 --> 42:11.910
更加容易维护

42:11.910 --> 42:13.910
这是不是复杂度的问题

42:13.910 --> 42:15.910
那么RECT不是在解决这个问题吗

42:15.910 --> 42:16.910
对不对

42:16.910 --> 42:17.910
就在解决这个问题

42:17.910 --> 42:18.910
好 于是

42:18.910 --> 42:21.910
把这个问题又扔回给浏览器过后

42:21.910 --> 42:23.910
浏览器是属于我们前端范畴

42:23.910 --> 42:25.910
那么前端的开发人员

42:25.910 --> 42:27.910
他又开始在想办法

42:27.910 --> 42:28.910
来解决这个复杂度了

42:28.910 --> 42:29.910
以前在服务器解决的

42:29.910 --> 42:30.910
那么现在前端

42:30.910 --> 42:31.910
要解决这个复杂度

42:31.910 --> 42:33.910
我们前端有这么多数据

42:33.910 --> 42:35.910
前端的数据比服务器更复杂

42:35.910 --> 42:38.910
服务器你还不会记录用户

42:38.910 --> 42:40.910
点没点这个按钮

42:40.910 --> 42:42.910
像这些东西不用去计

42:42.910 --> 42:44.910
服务器只记得那种核心数据

42:44.910 --> 42:46.910
那么前端里边有很多零食数据

42:46.910 --> 42:48.910
不要说用户有没有点这个按钮

42:48.910 --> 42:49.910
这个地方需不需要隐藏

42:49.910 --> 42:50.910
需不需要显示

42:50.910 --> 42:52.910
服务端以前是不记得这些玩意的

42:52.910 --> 42:54.910
服务器端只记得那些

42:54.910 --> 42:56.910
需要纯到数据库的数据

42:56.910 --> 42:57.910
像什么

42:57.910 --> 42:58.910
有多少用户

42:58.910 --> 42:59.910
有哪些用户

42:59.910 --> 43:00.910
有多少新闻

43:00.910 --> 43:02.910
像这些数据需要持久化

43:02.910 --> 43:03.910
纯到数据库里边的数据

43:03.910 --> 43:06.910
但是前端里边还有很多

43:06.910 --> 43:08.910
很多那种索税的数据

43:08.910 --> 43:10.910
就是零散的数据

43:10.910 --> 43:11.910
那么前端里边

43:11.910 --> 43:13.910
他要用MVC你会发现

43:13.910 --> 43:15.910
麻烦出现了

43:15.910 --> 43:16.910
咱们来画一下

43:16.910 --> 43:18.910
前端里边他的MVC

43:18.910 --> 43:21.910
又该怎么来理解

43:21.910 --> 43:23.910
现在到浏览器端了

43:23.910 --> 43:25.910
这是浏览器端的MVC

43:25.910 --> 43:26.910
那么首先比方说

43:26.910 --> 43:28.910
我是一个开发人员

43:28.910 --> 43:29.910
现在还没有

43:29.910 --> 43:30.910
现在前端刚刚新起

43:30.910 --> 43:32.910
比方说现在前端刚刚新起

43:32.910 --> 43:35.910
我现在尝试着利用服务器端

43:35.910 --> 43:38.910
利用服务器端这种模式

43:38.910 --> 43:41.910
MVC模式来解决

43:41.910 --> 43:45.910
来解决前端的UIF复杂度

43:45.910 --> 43:47.910
怎么来解决呢

43:47.910 --> 43:48.910
我首先想

43:48.910 --> 43:50.910
先不看控制器

43:50.910 --> 43:53.910
先想模型和试图

43:53.910 --> 43:55.910
想模型和试图

43:55.910 --> 43:58.910
我发现这一块区域挺简单的

43:58.910 --> 43:59.910
区域对前端来说

43:59.910 --> 44:01.910
真的是超级自然

44:01.910 --> 44:02.910
你给我一个数据

44:02.910 --> 44:05.910
我就给你渲染一个东西

44:05.910 --> 44:06.910
比较一个DIV

44:06.910 --> 44:08.910
一个HE元素

44:08.910 --> 44:09.910
一个很大的一个表达

44:09.910 --> 44:10.910
你给我一个数据

44:10.910 --> 44:11.910
一套数据

44:11.910 --> 44:12.910
我会根据数据

44:12.910 --> 44:13.910
给你渲染出一个

44:13.910 --> 44:15.910
可以看得见的东西

44:15.910 --> 44:16.910
就是试图

44:16.910 --> 44:17.910
我把数据加到我们试图的

44:17.910 --> 44:19.910
合适的位置

44:19.910 --> 44:20.910
之前我们学

44:20.910 --> 44:22.910
Ragson是全在做的一件事

44:22.910 --> 44:24.910
因此Ragson

44:24.910 --> 44:25.910
他解决的是什么问题呢

44:25.910 --> 44:29.910
数据到试图的问题

44:29.910 --> 44:36.910
Ragson解决了数据到试图的问题

44:36.910 --> 44:41.820
他解决了这个问题

44:41.820 --> 44:42.820
数据到试图的问题

44:42.820 --> 44:43.820
你给他一个数据

44:43.820 --> 44:44.820
我通过组件

44:44.820 --> 44:45.820
是不是可以把试图

44:45.820 --> 44:46.820
该渲染出来

44:46.820 --> 44:47.820
比方一个韩数组件

44:47.820 --> 44:48.820
你看吧

44:48.820 --> 44:49.820
我们之前不是写一个韩

44:49.820 --> 44:51.820
不是写一个韩数组件吗

44:51.820 --> 44:53.820
MyComp这么一个组件

44:53.820 --> 44:54.820
这个组件里面不是

44:54.820 --> 44:56.820
这个属性是不是你给我的数据

44:56.820 --> 44:57.820
对吧

44:57.820 --> 44:58.820
它属性就是模型

44:58.820 --> 45:00.820
就可以认为是模型

45:00.820 --> 45:01.820
你给我一些数据

45:01.820 --> 45:03.820
OK那我给你返回一个界面

45:03.820 --> 45:05.820
怎么给你返回一个界面

45:05.820 --> 45:06.820
你看没有

45:06.820 --> 45:08.820
这就是试图

45:08.820 --> 45:09.820
这就是数据

45:09.820 --> 45:10.820
你给我一个数据

45:10.820 --> 45:12.820
我就给你返回个试图

45:12.820 --> 45:14.820
我把数据的相应

45:14.820 --> 45:15.820
东西比方说

45:15.820 --> 45:17.820
数据的标题我放这

45:17.820 --> 45:19.820
对不对

45:19.820 --> 45:21.820
其他东西放了合适的位置

45:21.820 --> 45:22.820
你看

45:22.820 --> 45:23.820
数据解决了

45:23.820 --> 45:24.820
Ragson解决的就是这个问题

45:24.820 --> 45:26.820
所以很多时候

45:26.820 --> 45:28.820
你会在一些资料里面看到了

45:28.820 --> 45:30.820
说Ragson解决了什么问题

45:30.820 --> 45:32.820
解决了MVC中的V

45:32.820 --> 45:33.820
你给我一个数据

45:33.820 --> 45:34.820
数据哪来的我不知道

45:34.820 --> 45:35.820
反正你给我一个数据

45:35.820 --> 45:36.820
我给你返回一个试图

45:36.820 --> 45:38.820
它解决的是MVC

45:38.820 --> 45:39.820
M表示模型

45:39.820 --> 45:40.820
V表示试图

45:40.820 --> 45:41.820
C表示控制器

45:41.820 --> 45:42.820
它解决了MVC

45:42.820 --> 45:44.820
这么模型的V这个层面的东西

45:44.820 --> 45:46.820
我如何根据一个数据

45:46.820 --> 45:47.820
来返回一个试图

45:47.820 --> 45:48.820
它解决的是这个东西

45:48.820 --> 45:49.820
你可以这样理解

45:49.820 --> 45:50.820
但是你这几刻

45:50.820 --> 45:51.820
你听完之后

45:51.820 --> 45:52.820
你会发现

45:52.820 --> 45:54.820
前端

45:54.820 --> 45:56.820
这个MVC

45:56.820 --> 45:57.820
实际上Ragson跟前

45:57.820 --> 45:59.820
MVC是没什么关系的

45:59.820 --> 46:01.820
没什么关系的

46:01.820 --> 46:02.820
它只能解决

46:02.820 --> 46:03.820
因为MVC它是一个整体

46:03.820 --> 46:05.820
你只能解决试图

46:05.820 --> 46:06.820
你不能说

46:06.820 --> 46:08.820
因为这个试图这么模式

46:08.820 --> 46:10.820
它不是说MVC它才有的

46:10.820 --> 46:13.820
很多地方它都有这么模式

46:13.820 --> 46:14.820
所以说你不能说

46:14.820 --> 46:15.820
它就解决一个试图

46:15.820 --> 46:17.820
它就是MVC的一环了

46:17.820 --> 46:19.820
因为Ragson官方

46:19.820 --> 46:20.820
从来没有说自己

46:20.820 --> 46:21.820
它是要整个

46:21.820 --> 46:23.820
要提供一个MVC的解决方案

46:23.820 --> 46:24.820
从来没有

46:24.820 --> 46:25.820
从来没有

46:25.820 --> 46:26.820
因为就是后边

46:26.820 --> 46:27.820
它发现了问题所在

46:27.820 --> 46:29.820
麻烦的问题来了

46:29.820 --> 46:31.820
麻烦在哪呢

46:31.820 --> 46:33.820
麻烦在这

46:33.820 --> 46:35.820
前端的试图

46:35.820 --> 46:36.820
是不是要操作

46:36.820 --> 46:37.820
你想想

46:37.820 --> 46:38.820
是不是要操作

46:38.820 --> 46:39.820
一个按钮

46:39.820 --> 46:40.820
是不是要点

46:40.820 --> 46:41.820
一个文文框

46:41.820 --> 46:42.820
是不是有聚焦事件

46:42.820 --> 46:43.820
移开事件

46:43.820 --> 46:45.820
有鼠标移入事件

46:45.820 --> 46:46.820
键盘按下事件

46:46.820 --> 46:48.820
是不是有很多事件

46:48.820 --> 46:49.820
试图里边

46:49.820 --> 46:52.820
当发生某一件事的时候

46:52.820 --> 46:53.820
是不是有可能

46:53.820 --> 46:56.820
要重新处理数据

46:56.820 --> 46:57.820
是不是要可能重新处理

46:57.820 --> 46:58.820
这种情况

46:58.820 --> 46:59.820
我们遇到太多了

46:59.820 --> 47:00.820
是不是遇到太多了

47:00.820 --> 47:03.820
我们比方说点击一个按钮

47:03.820 --> 47:05.820
点击一个按钮

47:05.820 --> 47:06.820
那么这个按钮

47:06.820 --> 47:08.820
要进行登录

47:08.820 --> 47:09.820
要处理登录数据

47:09.820 --> 47:10.820
对不对

47:10.820 --> 47:11.820
是不是要重新处理数据

47:11.820 --> 47:12.820
登录数据一遍

47:12.820 --> 47:13.820
它的相关数据一遍

47:13.820 --> 47:15.820
是不是要重新券展试图

47:15.820 --> 47:16.820
那么服务器端那边

47:16.820 --> 47:17.820
看一下是不是一样的

47:17.820 --> 47:19.820
我把这个试图给的客服端

47:19.820 --> 47:20.820
客服端提交

47:20.820 --> 47:22.820
还把重新到达服务器

47:22.820 --> 47:23.820
这是传统的做法

47:23.820 --> 47:24.820
重新到达服务器

47:24.820 --> 47:26.820
服务器是不是又要新过控制器

47:26.820 --> 47:27.820
又要重新得到模型

47:27.820 --> 47:29.820
又把模型又重新给另外一个试图

47:29.820 --> 47:31.820
另外一个试图是不是又要渲染出来

47:31.820 --> 47:32.820
又给客服端

47:32.820 --> 47:33.820
客服端做了某个操作过后

47:33.820 --> 47:34.820
又到达控制器

47:34.820 --> 47:36.820
又来进行

47:36.820 --> 47:37.820
那为什么这么模式

47:37.820 --> 47:38.820
要前端不行呢

47:38.820 --> 47:39.820
咱们来看一下

47:39.820 --> 47:40.820
如果说可以的话

47:40.820 --> 47:42.820
那么前端应该是这个样子

47:42.820 --> 47:43.820
跟服务器端一样

47:43.820 --> 47:44.820
跟服务器端一样

47:44.820 --> 47:48.200
就是试图里边

47:48.200 --> 47:50.200
它做了某种操作

47:50.200 --> 47:52.200
那么操作呢

47:52.200 --> 47:54.200
我们就把它交给控制器

47:54.200 --> 47:56.200
某种操作

47:56.200 --> 47:57.200
我们把这个操作

47:57.200 --> 48:00.200
又交回给这个控制器

48:00.200 --> 48:02.200
那么这个控制器相当于是啥呢

48:02.200 --> 48:03.200
对于前端而言

48:03.200 --> 48:05.200
这个控制器就相当于是

48:05.200 --> 48:08.200
事件处理程序

48:08.200 --> 48:10.200
就相当于是这个

48:10.200 --> 48:11.200
事件处理程序

48:11.200 --> 48:13.200
当然它不仅事件处理程序

48:13.200 --> 48:14.200
比方说什么

48:14.200 --> 48:17.200
组建挂载完成过后

48:17.200 --> 48:19.200
可能又有一些数据要改变

48:19.200 --> 48:21.200
要去改变一些数据

48:21.200 --> 48:22.200
等等等等

48:22.200 --> 48:23.200
总之呢

48:23.200 --> 48:24.200
这个数据呢

48:24.200 --> 48:25.200
我们要改变数据

48:25.200 --> 48:26.200
都要通过控制器

48:26.200 --> 48:28.200
总之这个控制器

48:28.200 --> 48:30.200
我们需要通过它来改变数据

48:30.200 --> 48:31.200
那么在我们的react里边

48:31.200 --> 48:33.200
是不是好像是相当于

48:33.200 --> 48:35.200
是什么事件处理程序对吧

48:35.200 --> 48:36.200
在点击过后呢

48:36.200 --> 48:37.200
我们比方说一个数字要加一

48:37.200 --> 48:39.200
我们在事件处理程序里边

48:39.200 --> 48:40.200
事件处理函数里边

48:40.200 --> 48:41.200
给它加一

48:41.200 --> 48:43.200
但是我从来没有在react

48:43.200 --> 48:45.200
讲的过程中给你们说过控制器吧

48:45.200 --> 48:46.200
没有吧

48:46.200 --> 48:48.200
为什么没有

48:48.200 --> 48:49.200
因为它会发现

48:49.200 --> 48:51.200
你把这个东西当成控制器

48:51.200 --> 48:53.200
天下大乱了

48:53.200 --> 48:55.200
因为控制器的出现

48:55.200 --> 48:58.200
它是为了解决降低复杂度

48:58.200 --> 48:59.200
你这里能降低复杂度吗

48:59.200 --> 49:02.200
压格就不能降低复杂度

49:02.200 --> 49:03.200
为什么不能降低复杂度

49:03.200 --> 49:06.200
我给大家解释一个现象你就明白了

49:06.200 --> 49:09.200
我们页面上

49:09.200 --> 49:12.200
我们页面上有100个组建

49:12.200 --> 49:14.200
100个组建

49:14.200 --> 49:16.200
每个组建呢

49:16.200 --> 49:18.200
每个组建平均下来

49:18.200 --> 49:21.200
每个组建有平均

49:21.200 --> 49:26.200
每个组建有两个世界

49:26.200 --> 49:27.200
也不说多了

49:27.200 --> 49:30.200
就两个世界

49:30.200 --> 49:34.200
其中有50个

49:34.200 --> 49:36.200
有30个组建

49:36.200 --> 49:38.200
有30个组建

49:38.200 --> 49:42.200
进行了某种操作之后

49:42.200 --> 49:45.200
需要改变

49:45.200 --> 49:50.340
改变同一块数据

49:50.340 --> 49:51.340
这是我们的场景

49:51.340 --> 49:52.340
100个组建

49:52.340 --> 49:54.340
平均每个组建有两个世界

49:54.340 --> 49:56.340
其中有30个组建

49:56.340 --> 49:58.340
这三个组建各有各的操作

49:58.340 --> 50:00.340
比较一个组建它是属于一入世界

50:00.340 --> 50:02.340
一个组建它是按有点击世界

50:02.340 --> 50:03.340
一个组建它是

50:03.340 --> 50:05.340
隔了几秒钟它就要触发的世界

50:05.340 --> 50:06.340
所以time out

50:06.340 --> 50:08.340
总之进行了某种操作之后

50:08.340 --> 50:10.340
它们都要改变同一个数据

50:10.340 --> 50:12.340
改变同一块数据

50:12.340 --> 50:14.340
那里看一下

50:14.340 --> 50:16.340
重复代码是不是一大堆

50:16.340 --> 50:17.340
一大堆

50:17.340 --> 50:19.340
对不对

50:19.340 --> 50:22.340
而且重复代码是很难提取的

50:22.340 --> 50:23.340
为什么

50:23.340 --> 50:25.340
世界处理函数你再写到里边吧

50:25.340 --> 50:27.340
一世界处理函数

50:27.340 --> 50:30.340
世界处理程序就是函数

50:30.340 --> 50:32.340
你再写进去吧

50:32.340 --> 50:33.340
你这个东西解决不了吧

50:33.340 --> 50:34.340
还有什么呢

50:34.340 --> 50:36.340
还有什么就是

50:36.340 --> 50:38.340
比较说有些组建

50:38.340 --> 50:39.340
但是它一不完全一样

50:39.340 --> 50:40.340
比较改变数据

50:40.340 --> 50:41.340
它一不完全一样

50:41.340 --> 50:44.340
有些组建它是改变了这么一点点

50:44.340 --> 50:45.340
另外一个数据是改变了那个数据

50:45.340 --> 50:47.340
一个对象里面的各种属性

50:47.340 --> 50:48.340
改变了另外一个属性一点点

50:48.340 --> 50:49.340
对吧

50:49.340 --> 50:50.340
它一不一样

50:50.340 --> 50:52.340
你要提取也不是很好提取

50:52.340 --> 50:53.340
你看一下

50:53.340 --> 50:55.340
这样一下来的话

50:55.340 --> 50:56.340
Rx发现

50:56.340 --> 50:59.340
控制器会变得极其复杂和庞大

50:59.340 --> 51:01.340
这个控制器

51:01.340 --> 51:03.340
会变得极其复杂和庞大

51:03.340 --> 51:05.340
为什么以前

51:05.340 --> 51:06.340
服务器端的那个控制器

51:06.340 --> 51:07.340
可以保持非常简洁

51:07.340 --> 51:08.340
一旦到了钱

51:08.340 --> 51:11.340
那控制器就很麻烦了

51:11.340 --> 51:13.340
究其根本原因

51:13.340 --> 51:16.340
是因为以前在服务器端的那个控制器

51:16.340 --> 51:19.340
它只是根据不同的请求

51:19.340 --> 51:22.340
分发到不同的控制器

51:22.340 --> 51:25.340
因为你请求不同的地址

51:25.340 --> 51:26.340
是不是就意味着

51:26.340 --> 51:28.340
你要进行不同

51:28.340 --> 51:31.340
你要得到不同的资源

51:31.340 --> 51:33.340
我不管你你这个得到资源

51:33.340 --> 51:35.340
是点到A元数也好

51:35.340 --> 51:37.340
还是你用GS代码请求过来的也好

51:37.340 --> 51:39.340
还是你是一个阿加克斯请求

51:39.340 --> 51:41.340
我管都不管

51:41.340 --> 51:44.340
你只要请求这个地址

51:44.340 --> 51:46.340
就说明你要这个资源

51:46.340 --> 51:48.340
我就把这个资源给你

51:48.340 --> 51:50.340
但是到了钱端就不一样了

51:50.340 --> 51:53.340
情况复杂太多了

51:53.340 --> 51:56.340
用户鼠标移入的时候

51:56.340 --> 51:58.340
你可能是一种操作

51:58.340 --> 51:59.340
都差不多

51:59.340 --> 52:00.340
但是又有区别

52:00.340 --> 52:03.340
然后用户鼠标移入是一个

52:03.340 --> 52:04.340
是一个事件

52:04.340 --> 52:06.340
点击按钮是一个事件

52:06.340 --> 52:09.340
set timeout过后又有一个事件

52:09.340 --> 52:12.340
数件挂展完成又有事件

52:12.340 --> 52:13.340
到处都是情况

52:13.340 --> 52:15.340
到处都有可能改变数据

52:15.340 --> 52:18.340
控制器会变得极其复杂

52:18.340 --> 52:20.340
你如果说之前你跟着我那个

52:20.340 --> 52:21.340
read学习

52:21.340 --> 52:22.340
你觉得复杂在哪

52:22.340 --> 52:23.340
你觉得内组件复杂

52:23.340 --> 52:25.340
还是还是组件复杂

52:25.340 --> 52:26.340
为什么

52:26.340 --> 52:27.340
因为内组件里面有数据

52:27.340 --> 52:30.340
它要去维护这个数据的状态

52:30.340 --> 52:32.340
点击过后我要把状态给它改了

52:32.340 --> 52:34.340
改状态是不是挺麻烦的

52:34.340 --> 52:36.340
改状态是最麻烦的

52:36.340 --> 52:38.340
如果说它根本就不改状态的话

52:38.340 --> 52:40.340
就一切都很简单了

52:40.340 --> 52:42.340
所以说reaction

52:42.340 --> 52:44.340
它没有去解决

52:44.340 --> 52:46.340
控制器这一块的问题

52:46.340 --> 52:48.340
因为它根本就没法解决

52:48.340 --> 52:49.340
它不知道该怎么解决

52:49.340 --> 52:50.340
也不说不知道

52:50.340 --> 52:51.340
它觉得这个解决方案

52:51.340 --> 52:52.340
可能现在还不成熟

52:52.340 --> 52:53.340
以后有更好的方案

52:53.340 --> 52:54.340
所以它没有去解决这个问题

52:54.340 --> 52:56.340
因此它只做了界面

52:56.340 --> 52:58.340
只搞定了界面

52:58.340 --> 52:59.340
你界面做了某一个操作之后

52:59.340 --> 53:01.340
你要去怎么来处理数据

53:01.340 --> 53:02.340
它没法管

53:02.340 --> 53:04.340
没法管了

53:04.340 --> 53:06.340
这是它第一个问题

53:06.340 --> 53:08.340
我们看一下问题

53:08.340 --> 53:09.340
问题在哪

53:09.340 --> 53:12.340
第一个问题

53:12.340 --> 53:14.340
controller

53:14.340 --> 53:16.340
前端的controller

53:16.340 --> 53:18.340
前端的controller

53:18.340 --> 53:20.340
要比服务器

53:20.340 --> 53:22.340
复杂很多

53:22.340 --> 53:24.340
因为前端

53:24.340 --> 53:27.340
前端中的controller

53:27.340 --> 53:31.340
就是处理的是用户的操作

53:31.340 --> 53:34.340
而服务器是请求

53:34.340 --> 53:35.340
不管用户做了什么操作

53:35.340 --> 53:37.340
只要你最终请求过来

53:37.340 --> 53:39.340
那么我就要给你什么东西

53:39.340 --> 53:40.340
这是服务器端

53:40.340 --> 53:41.340
但是前端的话

53:41.340 --> 53:43.340
我们用户的什么操作

53:43.340 --> 53:44.340
我可能都要处理

53:44.340 --> 53:46.340
所以它的情况要复杂太多了

53:46.340 --> 53:49.340
处理的是用户的操作

53:49.340 --> 53:51.340
用户的操作

53:51.340 --> 53:57.340
而用户的操作场景

53:57.340 --> 54:00.340
是复杂的

54:00.340 --> 54:03.340
这是第一个问题

54:03.340 --> 54:04.340
明白这个意思吧

54:04.340 --> 54:05.340
所以说前端

54:05.340 --> 54:07.340
之前我还看到一篇文章

54:07.340 --> 54:08.340
很早以前的

54:08.340 --> 54:10.340
reactor就是官方的开发人员

54:10.340 --> 54:11.340
写的一篇

54:11.340 --> 54:13.340
就是Facebook里边的内部开发人员

54:13.340 --> 54:15.340
叫什么名字来着

54:15.340 --> 54:16.340
记得还挺有名的

54:16.340 --> 54:17.340
突然忘了

54:17.340 --> 54:18.340
现在想不起来了

54:18.340 --> 54:19.340
它写了一篇

54:19.340 --> 54:21.340
在博客里边给它写了一篇文章

54:21.340 --> 54:22.340
就是说

54:22.340 --> 54:24.340
前端的mvc模式一死

54:24.340 --> 54:26.340
它告诉你前端用不了这个玩意

54:26.340 --> 54:28.340
就是问题的根源不是在模型

54:28.340 --> 54:30.340
模型很简单就组装一个对象

54:30.340 --> 54:32.340
模型在对于前端来说是非常简单的

54:32.340 --> 54:34.340
试图也没问题

54:34.340 --> 54:35.340
试图的话

54:35.340 --> 54:36.340
我们就是由reactor

54:36.340 --> 54:38.340
vue是不是都可以搞定试图

54:38.340 --> 54:39.340
见面了一会儿

54:39.340 --> 54:41.340
关键就在于控制器

54:41.340 --> 54:43.340
没法做这个玩意

54:43.340 --> 54:46.340
情况太多了

54:46.340 --> 54:48.340
因此前端需要一种新的

54:48.340 --> 54:51.340
就是展新的

54:51.340 --> 54:52.340
那个

54:52.340 --> 54:54.340
数据处理模式

54:54.340 --> 54:55.340
当然数据处理模式

54:55.340 --> 54:57.340
它是借鉴了mvc

54:57.340 --> 55:00.340
好 这是第一个mvc模式的困难

55:00.340 --> 55:02.340
第二个

55:02.340 --> 55:04.340
对于那些

55:04.340 --> 55:06.340
组建化的

55:06.340 --> 55:08.340
就是

55:08.340 --> 55:10.340
框架

55:10.340 --> 55:11.340
比如

55:11.340 --> 55:12.340
vue

55:12.340 --> 55:14.340
reactor

55:14.340 --> 55:16.340
他们的数据

55:16.340 --> 55:18.340
他们的数据

55:18.340 --> 55:20.340
他们使用的是

55:20.340 --> 55:22.340
单向数据流

55:22.340 --> 55:24.340
对吧

55:24.340 --> 55:26.340
reactor我们反复强调了

55:26.340 --> 55:28.340
reactor的数据是单向的

55:28.340 --> 55:29.340
你给我一个数据

55:29.340 --> 55:30.340
我给你一个解冕

55:30.340 --> 55:31.340
你给我一个数据

55:31.340 --> 55:32.340
我给你一个解冕

55:32.340 --> 55:34.340
就是单向数据流

55:34.340 --> 55:36.340
其实vue也是单向的

55:36.340 --> 55:38.340
原来说vue哪是单向的

55:38.340 --> 55:40.340
vue不是有vmode吗

55:40.340 --> 55:42.340
vmode你是不是余法堂

55:42.340 --> 55:44.340
它是个余法堂

55:44.340 --> 55:46.340
根源最根本的还是单向的

55:46.340 --> 55:48.340
它是数据还是单向的

55:48.340 --> 55:50.340
为什么需要单向数据流

55:50.340 --> 55:52.340
因为单向数据流是最简单的

55:52.340 --> 55:54.340
理解起来好理解

55:54.340 --> 55:56.340
它不容易出问题

55:56.340 --> 55:58.340
偶合度又低

55:58.340 --> 56:00.340
单向数据流的好处

56:00.340 --> 56:02.340
其实我们

56:02.340 --> 56:04.340
不知道大家还记不记得

56:04.340 --> 56:06.340
以前你们学函数的时候

56:06.340 --> 56:11.510
一定见过这个函数

56:11.510 --> 56:13.510
这个函数就是要见过的

56:13.510 --> 56:15.510
我都不用解释了

56:15.510 --> 56:17.510
给我一个a和b

56:17.510 --> 56:19.510
反回一个a加b

56:19.510 --> 56:21.510
为什么它变得如此简单

56:21.510 --> 56:23.510
就是因为函数的数据流是单向的

56:23.510 --> 56:25.510
你给我一个数据

56:25.510 --> 56:29.510
它非常符合人类的思维模式

56:29.510 --> 56:31.510
单向数据流最好控制

56:31.510 --> 56:33.510
而且最不容易出错

56:33.510 --> 56:35.510
无论是vue还是reggit

56:35.510 --> 56:37.510
他们使用的都是单向数据流

56:37.510 --> 56:41.510
由于他们是单向数据流

56:41.510 --> 56:43.510
需要

56:43.510 --> 56:47.510
若需要共享数据

56:47.510 --> 56:53.510
则必须将数据提升到顶层逐渐

56:53.510 --> 56:55.510
顶层逐渐

56:55.510 --> 56:57.510
这是什么意思呢

56:57.510 --> 56:59.510
比方说

56:59.510 --> 57:01.510
我举个例子吧

57:01.510 --> 57:03.510
比方说我们这里

57:03.510 --> 57:05.510
根逐渐是i的

57:05.510 --> 57:07.510
根逐渐下面有两个逐渐

57:07.510 --> 57:09.510
comp1和comp2

57:09.510 --> 57:11.510
这两个逐渐下面

57:11.510 --> 57:13.510
是不是形成一个数

57:13.510 --> 57:15.510
c1

57:15.510 --> 57:17.510
c2

57:17.510 --> 57:19.510
下面这个就是b1

57:19.510 --> 57:21.510
b2

57:21.510 --> 57:23.510
比方说我举个例子

57:23.510 --> 57:25.510
这个组建和这个组建要共享数据

57:25.510 --> 57:29.510
这个组建和这个组建要共享数据

57:29.510 --> 57:31.510
这两个组建都有相同的数据

57:31.510 --> 57:33.510
那怎么办呢

57:33.510 --> 57:35.510
我们是不是把这个数据提升

57:35.510 --> 57:37.510
把他的数据放到他的副组建

57:37.510 --> 57:39.510
因为他的数据他就不能自己维护了

57:39.510 --> 57:41.510
因为他自己维护我b2得不到

57:41.510 --> 57:43.510
b2自己维护c2得不到

57:43.510 --> 57:45.510
他们自己的状态

57:45.510 --> 57:47.510
所以说就必须要从上级传过来

57:47.510 --> 57:49.510
那么要从他把数据传给c2

57:49.510 --> 57:51.510
他把数据传给b2

57:51.510 --> 57:53.510
那么他们两个就是要有相同的数据传过去

57:53.510 --> 57:55.510
那么他们两个也没法实现相同的数据

57:55.510 --> 57:57.510
因为继续提升提升到跟组建

57:57.510 --> 57:59.510
跟组建把自己的数据组装好

57:59.510 --> 58:01.510
然后把数据传给他

58:01.510 --> 58:03.510
他又把数据传给他

58:03.510 --> 58:05.510
跟组建把数据传给他

58:05.510 --> 58:07.510
这样才能共享数据

58:07.510 --> 58:09.510
才能共享数据

58:09.510 --> 58:11.510
但是这样子的话数据传递是不是极其繁殊

58:13.510 --> 58:15.510
数据传递是不是极其繁殊

58:15.510 --> 58:17.510
对不对

58:17.510 --> 58:19.510
是不是这样子

58:19.510 --> 58:21.510
数据传递就极其的繁殊

58:21.510 --> 58:23.510
如果说组建层次一生

58:23.510 --> 58:25.510
我才花了几层吧

58:25.510 --> 58:27.510
如果说数据层次一生

58:27.510 --> 58:29.510
比方说18层

58:29.510 --> 58:31.510
那就是18层地域

58:31.510 --> 58:33.510
他要传过来

58:33.510 --> 58:35.510
他要传过去

58:35.510 --> 58:37.510
他要传过去

58:37.510 --> 58:39.510
一是往后边的传

58:39.510 --> 58:41.510
哪怕有一天比方说

58:41.510 --> 58:43.510
b2是第18层组建

58:43.510 --> 58:45.510
他需要多一个数据

58:45.510 --> 58:47.510
那么之前是不是要一层一层

58:47.510 --> 58:49.510
要传过来

58:49.510 --> 58:51.510
就非常非常的麻烦

58:51.510 --> 58:54.820
建层

58:54.820 --> 58:56.820
然后数据在

58:56.820 --> 58:58.820
一层

58:58.820 --> 59:00.820
一层传递

59:00.820 --> 59:02.820
极其繁殊

59:02.820 --> 59:04.820
极其繁殊

59:04.820 --> 59:06.820
那为什么服务器端MMVS模式

59:06.820 --> 59:08.820
没有遇到这样的问题呢

59:08.820 --> 59:10.820
因为服务器端的数据是存在数据库的

59:10.820 --> 59:12.820
数据库是全聚可以共享的

59:12.820 --> 59:14.820
随时可以取

59:14.820 --> 59:16.820
所以说根本就不会遇到这样的问题

59:16.820 --> 59:18.820
什么数据我拿不到了

59:18.820 --> 59:20.820
没有这样的问题

59:20.820 --> 59:22.820
但是在前端

59:22.820 --> 59:24.820
他为了降低UIF大度

59:24.820 --> 59:26.820
他使用的是单向数据流

59:26.820 --> 59:28.820
他就会出现这样的问题

59:28.820 --> 59:30.820
那么有没有解决办法呢

59:30.820 --> 59:32.820
当然可以有解决办法

59:32.820 --> 59:34.820
虽然可以使用上下文

59:34.820 --> 59:36.820
来提供共享数据

59:36.820 --> 59:38.820
来提供共享数据

59:38.820 --> 59:40.820
来提供共享数据

59:40.820 --> 59:42.820
虽然说能够提供一个上下文

59:42.820 --> 59:44.820
比方说我们在这里

59:44.820 --> 59:48.390
我们在这里

59:48.390 --> 59:50.390
在APP里面注入一个上下文

59:50.390 --> 59:53.700
上下文的Value里面

59:53.700 --> 59:55.700
来提供数据

59:55.700 --> 59:57.700
在这里面提供数据

59:57.700 --> 01:00:01.080
所以在Value里面可以提供数据

01:00:01.080 --> 01:00:03.080
那么这样子的他是不是可以访问上下文的数据

01:00:03.080 --> 01:00:05.080
他是不是可以访问

01:00:05.080 --> 01:00:07.080
任何人都可以访问

01:00:07.080 --> 01:00:09.080
是不是可以共享了

01:00:09.080 --> 01:00:11.080
虽然说可以使用上下文来提供

01:00:11.080 --> 01:00:13.080
共享数据

01:00:13.080 --> 01:00:15.080
但是

01:00:15.080 --> 01:00:17.080
对数据的改变

01:00:17.080 --> 01:00:19.080
对数据的操作

01:00:19.080 --> 01:00:21.080
难以监控

01:00:21.080 --> 01:00:23.080
难以监控

01:00:23.080 --> 01:00:25.080
会容易导致

01:00:25.080 --> 01:00:27.080
容易导致

01:00:27.080 --> 01:00:29.080
数据

01:00:29.080 --> 01:00:31.080
容易导致

01:00:31.080 --> 01:00:33.080
调试错误的困难

01:00:35.080 --> 01:00:37.080
困难

01:00:37.080 --> 01:00:39.080
以及数据

01:00:39.080 --> 01:00:41.080
还原的困难

01:00:43.080 --> 01:00:45.080
什么意思我解释一下

01:00:45.080 --> 01:00:47.080
这就写到一起吧

01:00:47.080 --> 01:00:49.080
解释一下什么意思

01:00:51.080 --> 01:00:53.080
上下文里面可以提供一个数据

01:00:53.080 --> 01:00:55.080
好,那么现在来

01:00:55.080 --> 01:00:57.080
我们来看一下

01:00:57.080 --> 01:00:59.080
还有一个问题

01:00:59.080 --> 01:01:01.080
我们一起来说完说完一起解释

01:01:01.080 --> 01:01:03.080
并且

01:01:03.080 --> 01:01:05.080
若开发一个大型项目

01:01:05.080 --> 01:01:07.080
大中型项目

01:01:07.080 --> 01:01:09.080
大中型

01:01:09.080 --> 01:01:11.080
项目

01:01:11.080 --> 01:01:13.080
共享的数据很多

01:01:13.080 --> 01:01:15.080
需要共享的数据很多

01:01:15.080 --> 01:01:17.080
会导致

01:01:17.080 --> 01:01:19.080
上下文中的数据

01:01:19.080 --> 01:01:21.080
变得非常复杂

01:01:21.080 --> 01:01:24.520
好,我们先看这个

01:01:24.520 --> 01:01:26.520
先看这个

01:01:26.520 --> 01:01:28.520
先不说什么数据多少的问题

01:01:28.520 --> 01:01:30.520
先看这个

01:01:30.520 --> 01:01:32.520
我把数据放到上下文里面

01:01:32.520 --> 01:01:34.520
比方说是一个对象

01:01:34.520 --> 01:01:36.520
举个例子,这个白柳是一个对象

01:01:36.520 --> 01:01:38.520
这个对象里边

01:01:38.520 --> 01:01:40.520
它有很多的有些属性

01:01:40.520 --> 01:01:42.520
比方说一个name属性

01:01:42.520 --> 01:01:44.520
有个a级属性

01:01:44.520 --> 01:01:46.520
有个什么

01:01:46.520 --> 01:01:48.520
address 地址

01:01:48.520 --> 01:01:50.520
有个地址属性

01:01:50.520 --> 01:01:52.520
有个地址属性

01:01:52.520 --> 01:01:54.520
然后

01:01:54.520 --> 01:01:56.520
这里边

01:01:56.520 --> 01:01:58.520
这是个用户数组

01:01:58.520 --> 01:02:00.520
比方说是个用户数组

01:02:00.520 --> 01:02:04.790
这是一个用户数组

01:02:04.790 --> 01:02:06.790
举个例子

01:02:06.790 --> 01:02:08.790
这是一个用户数组

01:02:08.790 --> 01:02:10.790
还张号密码的东西

01:02:10.790 --> 01:02:12.790
好,现在这个上下文里边

01:02:12.790 --> 01:02:14.790
它还给你提供了

01:02:14.790 --> 01:02:16.790
这是user

01:02:16.790 --> 01:02:18.790
user

01:02:18.790 --> 01:02:20.790
我们这里写过来吧,写过来

01:02:20.790 --> 01:02:28.740
比如

01:02:28.740 --> 01:02:30.740
比如

01:02:30.740 --> 01:02:32.740
上下文中

01:02:32.740 --> 01:02:34.740
有

01:02:34.740 --> 01:02:36.740
如下格式的数据

01:02:36.740 --> 01:02:38.740
什么数据呢?

01:02:38.740 --> 01:02:40.740
比方说数据的格式是这样子

01:02:40.740 --> 01:02:45.020
接什么?

01:02:45.020 --> 01:02:47.020
格式是这样子

01:02:47.020 --> 01:02:49.020
用户数组

01:02:49.020 --> 01:02:51.020
user

01:02:51.020 --> 01:02:53.020
它里边有很多用户

01:02:53.020 --> 01:02:55.020
有很多用户

01:02:55.020 --> 01:02:57.020
我就用打火号来表示了

01:02:57.020 --> 01:02:59.020
然后

01:02:59.020 --> 01:03:01.020
还有一个

01:03:01.020 --> 01:03:03.020
添加用户

01:03:03.020 --> 01:03:05.020
添加用户的方法

01:03:05.020 --> 01:03:07.020
adduser

01:03:07.020 --> 01:03:09.020
还得写解释

01:03:09.020 --> 01:03:11.020
adduser

01:03:11.020 --> 01:03:13.020
它是一个方法

01:03:13.020 --> 01:03:15.020
用来添加一个用户

01:03:15.020 --> 01:03:17.020
添加一个用户

01:03:23.160 --> 01:03:25.160
上下文的数据

01:03:25.160 --> 01:03:27.160
一个方法

01:03:27.160 --> 01:03:29.160
用于添加用户

01:03:29.160 --> 01:03:31.160
当然你要传一个新用户进来

01:03:31.160 --> 01:03:33.160
比方说有三出用户

01:03:33.160 --> 01:03:35.160
三出用户,一个方法

01:03:35.160 --> 01:03:37.160
一个方法

01:03:37.160 --> 01:03:39.160
然后还有就是

01:03:39.160 --> 01:03:41.160
比如说有修改用户

01:03:41.160 --> 01:03:43.160
updates user

01:03:43.160 --> 01:03:45.160
修改用户

01:03:45.160 --> 01:03:49.820
举个例子

01:03:49.820 --> 01:03:51.820
上下文提供了这么一些东西

01:03:51.820 --> 01:03:53.820
那么

01:03:53.820 --> 01:03:55.820
现在我问大家一个问题

01:03:55.820 --> 01:03:57.820
有一天

01:03:57.820 --> 01:03:59.820
出了问题,就是出了错了

01:03:59.820 --> 01:04:01.820
包了一个错,可能没包错

01:04:01.820 --> 01:04:03.820
可能见面出了问题

01:04:03.820 --> 01:04:05.820
于是你去调试

01:04:05.820 --> 01:04:07.820
你去调试

01:04:07.820 --> 01:04:09.820
你找了半天

01:04:09.820 --> 01:04:11.820
你发现了,原来问题出在哪呢

01:04:11.820 --> 01:04:13.820
问题出在用户数组里边

01:04:13.820 --> 01:04:15.820
第二个用户

01:04:15.820 --> 01:04:17.820
第二个用户

01:04:17.820 --> 01:04:19.820
它问题出在这

01:04:19.820 --> 01:04:21.820
用户数组里边,第二个用户

01:04:21.820 --> 01:04:23.820
第二个用户里边

01:04:23.820 --> 01:04:25.820
有个属性值出了问题

01:04:25.820 --> 01:04:27.820
一个属性值本来该有值的

01:04:27.820 --> 01:04:29.820
它是undefend

01:04:29.820 --> 01:04:31.820
再听一次

01:04:31.820 --> 01:04:33.820
有一天你见面出了问题

01:04:33.820 --> 01:04:35.820
你会发现问题出现在点在哪呢

01:04:35.820 --> 01:04:37.820
是在于用户数组里边

01:04:37.820 --> 01:04:39.820
第二个用户,其中一个属性

01:04:39.820 --> 01:04:41.820
本来它有值

01:04:41.820 --> 01:04:43.820
本来它应该有值,但它现在的值

01:04:43.820 --> 01:04:45.820
undefend,问题在这

01:04:45.820 --> 01:04:47.820
那么请问你

01:04:47.820 --> 01:04:49.820
你怎么知道这个值

01:04:49.820 --> 01:04:51.820
为什么是undefend

01:04:51.820 --> 01:04:53.820
注意哦,你这个是

01:04:53.820 --> 01:04:55.820
上下文里边的数据

01:04:55.820 --> 01:04:57.820
上下文的数据

01:04:57.820 --> 01:04:59.820
上下文的数据

01:04:59.820 --> 01:05:01.820
它又提供了这么一些方法

01:05:01.820 --> 01:05:03.820
那是不是下边的所有的

01:05:03.820 --> 01:05:05.820
组件都有可能会

01:05:05.820 --> 01:05:07.820
调问这个方法,改动这个数据

01:05:07.820 --> 01:05:09.820
是不是都有可能

01:05:09.820 --> 01:05:11.820
下面我告诉你,一个大型项目里面

01:05:11.820 --> 01:05:13.820
实际上正在运行的

01:05:13.820 --> 01:05:15.820
可能有3000个组件

01:05:15.820 --> 01:05:17.820
来吧,你去给我找

01:05:17.820 --> 01:05:19.820
就3000个,那我们说

01:05:19.820 --> 01:05:21.820
说那个吧,所以不说那么夸张吧

01:05:21.820 --> 01:05:23.820
3000个正在运行的组件

01:05:23.820 --> 01:05:25.820
就是组件实例

01:05:25.820 --> 01:05:27.820
那么组件内行的话,比方说就

01:05:27.820 --> 01:05:29.820
100个嘛

01:05:29.820 --> 01:05:31.820
100个组件

01:05:31.820 --> 01:05:33.820
这里边由于都是跟组件的

01:05:33.820 --> 01:05:35.820
处于跟组件的上下文

01:05:35.820 --> 01:05:37.820
这100个组件是不是都有可能

01:05:37.820 --> 01:05:39.820
都有可能

01:05:39.820 --> 01:05:41.820
去调用

01:05:41.820 --> 01:05:43.820
添加方法

01:05:43.820 --> 01:05:45.820
调用删除方法,调用修改方法

01:05:45.820 --> 01:05:47.820
他们都有可能去调用这些东西

01:05:47.820 --> 01:05:49.820
那么你给我找

01:05:49.820 --> 01:05:51.820
你怎么知道

01:05:51.820 --> 01:05:53.820
首先你不知道它是调哪个方法出的问题

01:05:53.820 --> 01:05:55.820
那是添加用户

01:05:55.820 --> 01:05:57.820
添加用户的时候出的问题吗

01:05:57.820 --> 01:05:59.820
还是修改用户的时候出的问题吗

01:05:59.820 --> 01:06:01.820
还是说删除的时候没删掉

01:06:01.820 --> 01:06:03.820
它出了问题,然后导致了这个结果

01:06:03.820 --> 01:06:05.820
你根本连添加删除修改是哪个方法出的问题

01:06:05.820 --> 01:06:07.820
你都不知道

01:06:07.820 --> 01:06:09.820
不要说是哪个组件出的问题

01:06:09.820 --> 01:06:11.820
这么多组件你怎么调

01:06:11.820 --> 01:06:13.820
调都没法调

01:06:13.820 --> 01:06:15.820
而且以后谁的项目的就是工程量

01:06:15.820 --> 01:06:17.820
工程复杂度

01:06:17.820 --> 01:06:19.820
或者是工程的体量真大

01:06:19.820 --> 01:06:21.820
这个问题会越来越严重

01:06:21.820 --> 01:06:23.820
越来越严重,眼中的不得了

01:06:23.820 --> 01:06:25.820
到后面都要发一逼疯

01:06:25.820 --> 01:06:27.820
到后面你真的是只有一个

01:06:27.820 --> 01:06:29.820
一个想法就是离职

01:06:29.820 --> 01:06:31.820
你真的是没法解决问题了

01:06:31.820 --> 01:06:33.820
只要你最怕的就是

01:06:33.820 --> 01:06:35.820
有人告诉你今天有八个

01:06:35.820 --> 01:06:37.820
大条,因为你只看到了问题

01:06:37.820 --> 01:06:39.820
你知道问题在哪,数据出了问题

01:06:39.820 --> 01:06:41.820
但是你就是不知道个数据,它怎么出问题的

01:06:41.820 --> 01:06:43.820
因为每一个组件都有可能会使用这些东西

01:06:45.820 --> 01:06:47.820
你看数据是不是复杂度

01:06:47.820 --> 01:06:49.820
因为我讲这些东西就是告诉你

01:06:49.820 --> 01:06:51.820
数据是复杂的

01:06:51.820 --> 01:06:53.820
它需要一套方案来降低这个复杂度

01:06:53.820 --> 01:06:55.820
没有方案的话

01:06:55.820 --> 01:06:57.820
这个数据的复杂度

01:06:57.820 --> 01:06:59.820
到后面会把你逼疯

01:06:59.820 --> 01:07:01.820
因为如果说一个小型项目

01:07:01.820 --> 01:07:03.820
无所谓

01:07:03.820 --> 01:07:05.820
或者说就有一些简单的对象

01:07:05.820 --> 01:07:07.820
哪有那么多共享数据

01:07:07.820 --> 01:07:09.820
就比方说你们以后

01:07:09.820 --> 01:07:11.820
做一个后台的管理系统

01:07:11.820 --> 01:07:13.820
也没有什么共享数据

01:07:13.820 --> 01:07:15.820
没有共享数据

01:07:15.820 --> 01:07:17.820
它不需要数据解决方案

01:07:17.820 --> 01:07:19.820
它不需要Redux

01:07:19.820 --> 01:07:21.820
你就用上下文都可以搞定

01:07:21.820 --> 01:07:23.820
非常简单,非常清楚就搞定了

01:07:23.820 --> 01:07:25.820
因为它数据简单

01:07:25.820 --> 01:07:27.820
但是实际上在大中型项目里边

01:07:27.820 --> 01:07:29.820
数据是复杂的

01:07:29.820 --> 01:07:31.820
共享的数据都非常非常复杂

01:07:31.820 --> 01:07:33.820
比方说就一个门户网站

01:07:33.820 --> 01:07:35.820
它有新闻

01:07:35.820 --> 01:07:37.820
要共享,有数据要共享

01:07:37.820 --> 01:07:39.820
有地理,位置要共享

01:07:39.820 --> 01:07:41.820
地理位置指责社,就是城市

01:07:41.820 --> 01:07:43.820
城市的数据要共享

01:07:43.820 --> 01:07:45.820
这个组织要用城市,另外的组织也要用哪些城市

01:07:45.820 --> 01:07:47.820
省份,这些数据油编

01:07:47.820 --> 01:07:49.820
还有什么热门新闻

01:07:49.820 --> 01:07:51.820
最近发生的热点等等等等

01:07:51.820 --> 01:07:55.820
有很多很多复杂的共享数据

01:07:55.820 --> 01:07:57.820
你把这些数据全部扔到上下文吗

01:07:57.820 --> 01:07:59.820
那里肯定疯掉了

01:07:59.820 --> 01:08:01.820
然后说一个数据出问题

01:08:01.820 --> 01:08:03.820
压根就找不到,到底是怎么回事

01:08:03.820 --> 01:08:05.820
因为你没有一个方案来解决这个问题

01:08:05.820 --> 01:08:07.820
明白的意思吗

01:08:07.820 --> 01:08:09.820
明白的意思吗

01:08:09.820 --> 01:08:11.820
以前服务端为什么没遇到这个问题呢

01:08:11.820 --> 01:08:13.820
因为服务端以前的数据是存在数据库的

01:08:13.820 --> 01:08:15.820
数据库本来就是分表存储

01:08:15.820 --> 01:08:17.820
本来就是给你分开的

01:08:17.820 --> 01:08:19.820
数据库的复杂度有很多的方案解决数据的复杂度

01:08:19.820 --> 01:08:21.820
你根本就不用担心

01:08:21.820 --> 01:08:23.820
但是我现在讨论的问题是

01:08:23.820 --> 01:08:25.820
前段的数据的框架存在reaction里面

01:08:25.820 --> 01:08:27.820
5u里面都是这样的问题

01:08:27.820 --> 01:08:29.820
它就导致你要把共享的数据

01:08:29.820 --> 01:08:31.820
必须要提到根组件

01:08:31.820 --> 01:08:33.820
你就必须要把共享的数据提到根组件

01:08:33.820 --> 01:08:35.820
你不提到根组件是没法的

01:08:35.820 --> 01:08:37.820
那怎么共享呢

01:08:37.820 --> 01:08:39.820
那不在这个上下文里面的数据

01:08:39.820 --> 01:08:41.820
逐渐怎么来共享这个数据呢

01:08:41.820 --> 01:08:43.820
你必须要提到根组件

01:08:43.820 --> 01:08:45.820
一提到根组件的数据一下子复杂度巨整

01:08:45.820 --> 01:08:47.820
任何一个组件都会改变这个数据

01:08:47.820 --> 01:08:49.820
你都不知道谁改的

01:08:49.820 --> 01:08:51.820
所以说

01:08:51.820 --> 01:08:53.820
我说了这么多东西

01:08:53.820 --> 01:08:55.820
告诉你前段mmvc模式遇到了两个困难

01:08:55.820 --> 01:08:57.820
一个是

01:08:57.820 --> 01:08:59.820
数据的复杂度

01:08:59.820 --> 01:09:01.820
因此呢

01:09:01.820 --> 01:09:03.820
说了半天我要告诉你的是

01:09:03.820 --> 01:09:05.820
前段

01:09:05.820 --> 01:09:07.820
它特别特别需要

01:09:07.820 --> 01:09:09.820
一个

01:09:09.820 --> 01:09:11.820
独立的数据解决方案

01:09:11.820 --> 01:09:13.820
前段

01:09:13.820 --> 01:09:15.820
需要一个独立的

01:09:15.820 --> 01:09:17.820
数据解决方案

01:09:17.820 --> 01:09:19.820
什么叫独立的数据解决方案

01:09:19.820 --> 01:09:21.820
就是跟什么5u没关系

01:09:21.820 --> 01:09:23.820
跟reaction没关系

01:09:23.820 --> 01:09:25.820
它仅来处理数据

01:09:25.820 --> 01:09:27.820
什么界面无所谓

01:09:27.820 --> 01:09:29.820
你用的是什么vue方价

01:09:29.820 --> 01:09:31.820
reaction无所谓我管都不管你

01:09:31.820 --> 01:09:33.820
我只需要一个数据解决方案

01:09:33.820 --> 01:09:35.820
来降低数据复杂度

01:09:35.820 --> 01:09:37.820
只需要做这件事情

01:09:37.820 --> 01:09:39.820
因此

01:09:39.820 --> 01:09:41.820
我们这里学到redax也好

01:09:41.820 --> 01:09:43.820
你们之前

01:09:43.820 --> 01:09:45.820
理论上来说学到vuex也好

01:09:45.820 --> 01:09:47.820
它都跟具体的

01:09:47.820 --> 01:09:49.820
就是uikool是无关的

01:09:49.820 --> 01:09:51.820
给uikool无关

01:09:51.820 --> 01:09:53.820
比方redax它跟reaction有关系吗

01:09:53.820 --> 01:09:55.820
没有任何关系

01:09:55.820 --> 01:09:57.820
所以说我们这一张学习redax的时候

01:09:57.820 --> 01:09:59.820
几乎

01:09:59.820 --> 01:10:01.820
特别是前期

01:10:01.820 --> 01:10:03.820
应该说我会

01:10:03.820 --> 01:10:05.820
跟reaction结合的时候

01:10:05.820 --> 01:10:07.820
来拉张几来

01:10:07.820 --> 01:10:09.820
那我就这样明说吧

01:10:09.820 --> 01:10:11.820
这一张我们就不会学习redax

01:10:11.820 --> 01:10:13.820
跟reaction就没有任何关系

01:10:13.820 --> 01:10:15.820
我们甚至到时候会专门来开一个工程

01:10:15.820 --> 01:10:17.820
新开一个工程

01:10:17.820 --> 01:10:19.820
来学习redax

01:10:20.820 --> 01:10:22.820
没有这意思吗

01:10:22.820 --> 01:10:24.820
所以说我们需要一个独立的数据解决方案

01:10:24.820 --> 01:10:26.820
是解决数据的复杂度的

01:10:26.820 --> 01:10:28.820
数据的复杂度

01:10:28.820 --> 01:10:30.820
我们刚才说的问题就是

01:10:30.820 --> 01:10:32.820
它的根源就是数据的复杂

01:10:32.820 --> 01:10:33.820
太过于复杂了

01:10:33.820 --> 01:10:35.820
要共享的数据过于复杂了

01:10:35.820 --> 01:10:37.820
所以说我们需要一个套方案

01:10:37.820 --> 01:10:39.820
于是这套方案

01:10:39.820 --> 01:10:41.820
最早的时候

01:10:41.820 --> 01:10:43.820
是由facebook

01:10:43.820 --> 01:10:45.820
官方提出了一个方案叫flux

01:10:45.820 --> 01:10:48.820
所以说我们这里先讲flux方案

01:10:48.820 --> 01:10:50.820
这就是一个数据解决方案

01:10:50.820 --> 01:10:52.820
我们来看一下flux

01:10:52.820 --> 01:10:54.820
它是怎么来降低数据复杂度的

01:10:54.820 --> 01:10:57.820
然后我们再来引出于dax

01:10:57.820 --> 01:11:00.820
它是又是怎么来降低数据复杂度的

01:11:00.820 --> 01:11:02.820
分两部分来讲

01:11:02.820 --> 01:11:05.820
flux可能现在

01:11:05.820 --> 01:11:07.820
你们不怎么会看得到

01:11:07.820 --> 01:11:09.820
因为它这个东西

01:11:09.820 --> 01:11:11.820
它不是一个什么第三方库

01:11:11.820 --> 01:11:13.820
它有对应的第三方库

01:11:13.820 --> 01:11:15.820
但是它不是说什么库

01:11:15.820 --> 01:11:17.820
它是一种方案

01:11:17.820 --> 01:11:19.820
这个方案最大的作用是它的历史作用

01:11:19.820 --> 01:11:21.820
它的历史上作用很大

01:11:21.820 --> 01:11:24.820
因为现在像现在的就是瑞达格斯

01:11:24.820 --> 01:11:27.820
它就是在flux的方案上的演化

01:11:27.820 --> 01:11:30.820
包括那个vue里面的vuex

01:11:30.820 --> 01:11:32.820
它也是界线的这种方案

01:11:32.820 --> 01:11:35.820
flux的这种方案是facebook提出的

01:11:35.820 --> 01:11:42.820
facebook提出的数据解决方案

01:11:42.820 --> 01:11:45.820
它的最大的作用就是

01:11:46.820 --> 01:11:51.820
它的最大的历史意义

01:11:51.820 --> 01:11:53.820
历史意义

01:11:53.820 --> 01:11:58.820
在于它引入了x

01:11:58.820 --> 01:12:00.820
x的概念

01:12:00.820 --> 01:12:01.820
为什么

01:12:01.820 --> 01:12:03.820
你看真的是

01:12:03.820 --> 01:12:05.820
每次看到这些框架

01:12:05.820 --> 01:12:07.820
就是那种模式框架

01:12:07.820 --> 01:12:09.820
有的时候你会真的是由心的佩服

01:12:09.820 --> 01:12:12.820
佩服那些设计者

01:12:12.820 --> 01:12:14.820
它的两口用心

01:12:14.820 --> 01:12:16.820
它真的是想了很久很久

01:12:16.820 --> 01:12:18.820
为什么mvc模式在前端不能用

01:12:18.820 --> 01:12:21.820
因为mvc模式它其中一个很大的原因

01:12:21.820 --> 01:12:23.820
就是控制器太过于复杂了

01:12:23.820 --> 01:12:25.820
为什么控制器复杂

01:12:25.820 --> 01:12:27.820
是因为控制器它是要响应操作的

01:12:27.820 --> 01:12:29.820
而操作是复杂的

01:12:29.820 --> 01:12:32.820
那我们能不能加一个中间层来

01:12:32.820 --> 01:12:34.820
降低它的复杂度呢

01:12:34.820 --> 01:12:36.820
可以 这个就是x

01:12:36.820 --> 01:12:38.820
那为什么服务器端不复杂呢

01:12:38.820 --> 01:12:40.820
你想一个道理

01:12:40.820 --> 01:12:41.820
为什么不复杂呢

01:12:41.820 --> 01:12:42.820
它的控制器很简单的

01:12:42.820 --> 01:12:44.820
因为服务端它是根据不同的请求地址

01:12:44.820 --> 01:12:46.820
你说这个请求地址有多少个吗

01:12:46.820 --> 01:12:48.820
你们之前都做过了个学生管理系统

01:12:48.820 --> 01:12:50.820
你请求哪些地址

01:12:50.820 --> 01:12:51.820
添加学生

01:12:51.820 --> 01:12:53.820
还有什么

01:12:53.820 --> 01:12:55.820
还有分析的到学生

01:12:55.820 --> 01:12:57.820
还有三重学生修改学生

01:12:57.820 --> 01:12:59.820
就这么几个地址没了对吧

01:12:59.820 --> 01:13:01.820
那么理论上来说

01:13:01.820 --> 01:13:03.820
四个控制器是不是可以解决了

01:13:03.820 --> 01:13:04.820
对吧

01:13:04.820 --> 01:13:05.820
当然了

01:13:05.820 --> 01:13:07.820
你要理解服务端的那边控制器内部的话

01:13:07.820 --> 01:13:09.820
其实你知道一个控制器可以解决了

01:13:09.820 --> 01:13:11.820
一个控制器的不同x就可以解决了

01:13:11.820 --> 01:13:12.820
别这个东西不重要

01:13:12.820 --> 01:13:14.820
咱们也不用去深入到服务器内部

01:13:14.820 --> 01:13:15.820
那么你就可以想象成为

01:13:15.820 --> 01:13:18.820
四个控制器就可以解决这个问题了

01:13:18.820 --> 01:13:19.820
有多少呢

01:13:19.820 --> 01:13:21.820
没有多少很简单嘛对不对

01:13:21.820 --> 01:13:24.820
为什么到了一到的前段就变得非常复杂了

01:13:24.820 --> 01:13:26.820
因为前端比方说添加一个学生

01:13:26.820 --> 01:13:28.820
你可以谈个双口出来添加

01:13:28.820 --> 01:13:30.820
点这个按钮要添加

01:13:30.820 --> 01:13:31.820
以后呢

01:13:31.820 --> 01:13:33.820
它可能还要自动添加

01:13:33.820 --> 01:13:34.820
我们举个例子嘛

01:13:34.820 --> 01:13:35.820
每隔一段时间自动添加

01:13:35.820 --> 01:13:36.820
是不是set time out

01:13:36.820 --> 01:13:37.820
还要自动添加

01:13:37.820 --> 01:13:40.820
有可能你在那个修改学生的时候

01:13:40.820 --> 01:13:42.820
如果你写了一个学生没有的账号

01:13:42.820 --> 01:13:44.820
或者是没有的id

01:13:44.820 --> 01:13:45.820
那么它就会自动添加

01:13:45.820 --> 01:13:46.820
对吧 它可能性太多了

01:13:46.820 --> 01:13:47.820
拥护的操作

01:13:47.820 --> 01:13:49.820
各种可能性都有

01:13:49.820 --> 01:13:50.820
因为拥护的操作是复杂的

01:13:50.820 --> 01:13:52.820
你为了要提高拥护体验

01:13:52.820 --> 01:13:55.820
所以你会给它各种各样的方便它来操作

01:13:55.820 --> 01:13:58.820
各种操作都可能会产生同样的功能

01:13:58.820 --> 01:13:59.820
所以说呢

01:13:59.820 --> 01:14:00.820
你现在呢

01:14:00.820 --> 01:14:02.820
前端的控制器它不是复杂吗

01:14:02.820 --> 01:14:03.820
它不是情况多吗

01:14:03.820 --> 01:14:05.820
OK 我们这样再做

01:14:06.820 --> 01:14:08.820
我引入一个x型的概念

01:14:08.820 --> 01:14:10.820
x型表示什么意思呢

01:14:10.820 --> 01:14:13.820
x型是一个普通的对象

01:14:13.820 --> 01:14:14.820
它就是个对象

01:14:14.820 --> 01:14:17.820
用于描述

01:14:17.820 --> 01:14:21.820
描述要干什么

01:14:21.820 --> 01:14:23.820
你要干什么

01:14:23.820 --> 01:14:26.820
它是用来描述这个事情的

01:14:26.820 --> 01:14:27.820
以前服务器端

01:14:27.820 --> 01:14:29.820
为什么扛错的变得很简单

01:14:29.820 --> 01:14:31.820
因为服务器端就有一个东西

01:14:31.820 --> 01:14:33.820
它们描述了我要干嘛

01:14:33.820 --> 01:14:34.820
什么东西啊

01:14:34.820 --> 01:14:35.820
大家能不能知道

01:14:35.820 --> 01:14:37.820
服务器端控制器里边

01:14:37.820 --> 01:14:38.820
它是什么东西

01:14:38.820 --> 01:14:40.820
描述了我要干嘛

01:14:40.820 --> 01:14:41.820
什么东西

01:14:41.820 --> 01:14:42.820
就是请求地址

01:14:42.820 --> 01:14:44.820
你请求这个地址

01:14:44.820 --> 01:14:45.820
用这个方法

01:14:45.820 --> 01:14:46.820
请求这个地址

01:14:46.820 --> 01:14:48.820
比方说

01:14:48.820 --> 01:14:50.820
我们用这个方法

01:14:50.820 --> 01:14:51.820
posed方法

01:14:51.820 --> 01:14:52.820
请求这个地址

01:14:52.820 --> 01:14:53.820
我要干嘛

01:14:53.820 --> 01:14:54.820
我是不是要添加血

01:14:54.820 --> 01:14:56.820
我是不是要登录

01:14:56.820 --> 01:14:57.820
你说是不是要登录

01:14:57.820 --> 01:14:58.820
对吧

01:14:58.820 --> 01:14:59.820
请求这个地址

01:14:59.820 --> 01:15:00.820
用的是posed方法

01:15:00.820 --> 01:15:01.820
是不是要登录

01:15:01.820 --> 01:15:02.820
对不对

01:15:02.820 --> 01:15:03.820
那我用这个方法

01:15:03.820 --> 01:15:05.820
来请求这个地址呢

01:15:05.820 --> 01:15:06.820
我们要做的是

01:15:06.820 --> 01:15:08.820
我们是要得到一个登录页面

01:15:08.820 --> 01:15:09.820
我不是要多登录

01:15:09.820 --> 01:15:11.820
但是我要得到一个登录页面

01:15:11.820 --> 01:15:12.820
这个东西

01:15:12.820 --> 01:15:13.820
我是要把登录数据给你

01:15:13.820 --> 01:15:14.820
帐号给你密码给你

01:15:14.820 --> 01:15:15.820
我要多登录

01:15:15.820 --> 01:15:16.820
对吧

01:15:16.820 --> 01:15:18.820
所以说以前服务器端那边

01:15:18.820 --> 01:15:19.820
很简单

01:15:19.820 --> 01:15:20.820
为什么

01:15:20.820 --> 01:15:22.820
因为它跟操作没有关系

01:15:22.820 --> 01:15:23.820
你只需要告诉我

01:15:23.820 --> 01:15:24.820
你要干嘛

01:15:24.820 --> 01:15:25.820
你到底要干嘛

01:15:25.820 --> 01:15:26.820
我不管你是什么操作来的

01:15:26.820 --> 01:15:27.820
你是点按钮来的

01:15:27.820 --> 01:15:28.820
鼠标移入来的

01:15:28.820 --> 01:15:29.820
失去焦点来的

01:15:29.820 --> 01:15:30.820
不管都不管

01:15:30.820 --> 01:15:31.820
你只要请求这个地址

01:15:31.820 --> 01:15:32.820
表示你要登录

01:15:34.820 --> 01:15:35.820
那么现在到了前端

01:15:35.820 --> 01:15:36.820
它复杂了

01:15:36.820 --> 01:15:38.820
因为它操作的情况很多

01:15:38.820 --> 01:15:40.820
但是我们现在引出一个x型概念

01:15:40.820 --> 01:15:42.820
我甭管你啥操作

01:15:42.820 --> 01:15:44.820
只要你功能是一样的

01:15:44.820 --> 01:15:46.820
你结果生成同一个x型

01:15:46.820 --> 01:15:47.820
x型就描述了

01:15:47.820 --> 01:15:48.820
你要干嘛

01:15:48.820 --> 01:15:49.820
比方说

01:15:49.820 --> 01:15:50.820
比方举个例子

01:15:50.820 --> 01:15:51.820
举个例子

01:15:51.820 --> 01:15:52.820
还是登录

01:15:52.820 --> 01:16:00.670
势力

01:16:00.670 --> 01:16:01.670
比方说你要登录

01:16:01.670 --> 01:16:03.670
我可以用一个对象来描述

01:16:03.670 --> 01:16:05.670
x型

01:16:05.670 --> 01:16:06.670
用一个对象来描述

01:16:06.670 --> 01:16:07.670
描述

01:16:07.670 --> 01:16:09.670
描述就是我要干嘛

01:16:09.670 --> 01:16:10.670
那么那一型

01:16:10.670 --> 01:16:11.670
我要干嘛

01:16:11.670 --> 01:16:12.670
我要登录

01:16:12.670 --> 01:16:13.670
好

01:16:13.670 --> 01:16:14.670
数据

01:16:14.670 --> 01:16:15.670
数据我们会放到这

01:16:15.670 --> 01:16:16.670
配录的

01:16:16.670 --> 01:16:17.670
都是举例子

01:16:17.670 --> 01:16:18.670
举例子

01:16:18.670 --> 01:16:20.670
我们现在还没有具体来自学

01:16:20.670 --> 01:16:21.670
举例子就是

01:16:21.670 --> 01:16:22.670
login id

01:16:22.670 --> 01:16:23.670
等于二代命

01:16:23.670 --> 01:16:24.670
pass

01:16:24.670 --> 01:16:25.670
login

01:16:25.670 --> 01:16:26.670
password

01:16:26.670 --> 01:16:27.670
等于123

01:16:27.670 --> 01:16:28.670
123

01:16:28.670 --> 01:16:30.670
这就描述了我要登录

01:16:30.670 --> 01:16:31.670
通过这个对象

01:16:31.670 --> 01:16:32.670
是不是描述了我要干嘛

01:16:32.670 --> 01:16:33.670
具体怎么登录

01:16:33.670 --> 01:16:34.670
我不管

01:16:34.670 --> 01:16:35.670
我只是来描述我要干嘛

01:16:35.670 --> 01:16:36.670
那么这样子一来

01:16:36.670 --> 01:16:37.670
是不是

01:16:37.670 --> 01:16:38.670
就隐藏了

01:16:38.670 --> 01:16:39.670
什么

01:16:39.670 --> 01:16:40.670
就隐藏了

01:16:40.670 --> 01:16:41.670
具体的操作

01:16:41.670 --> 01:16:43.670
跟操作就没关系了

01:16:43.670 --> 01:16:45.670
跟操作之间的偶和

01:16:45.670 --> 01:16:46.670
该断开了

01:16:46.670 --> 01:16:47.670
以前我们的控制器

01:16:47.670 --> 01:16:48.670
全都要用MVC

01:16:48.670 --> 01:16:49.670
为什么困难

01:16:49.670 --> 01:16:51.670
因为控制器跟操作挂钩

01:16:51.670 --> 01:16:52.670
就太困难了

01:16:52.670 --> 01:16:53.670
因为操作情况

01:16:53.670 --> 01:16:54.670
太多了

01:16:54.670 --> 01:16:55.670
太丰富了

01:16:55.670 --> 01:16:56.670
那控制器变得

01:16:56.670 --> 01:16:57.670
太过于复杂

01:16:57.670 --> 01:16:59.670
但是我们只要一断开

01:16:59.670 --> 01:17:01.670
只要一断开就发现

01:17:01.670 --> 01:17:03.670
这个事情一下就变得简单了

01:17:06.180 --> 01:17:07.180
在仕途里边

01:17:07.180 --> 01:17:10.180
可以做各种各样的操作

01:17:10.180 --> 01:17:11.180
但是只要你功能一样

01:17:11.180 --> 01:17:12.180
就行

01:17:12.180 --> 01:17:13.180
你功能一样

01:17:14.180 --> 01:17:15.180
所以操作一

01:17:18.180 --> 01:17:19.180
操作二

01:17:20.180 --> 01:17:21.180
九粒怎么

01:17:23.180 --> 01:17:24.180
操作三

01:17:24.180 --> 01:17:25.180
那么他们都有可能

01:17:25.180 --> 01:17:27.180
是一样的功能

01:17:27.180 --> 01:17:28.180
他们会生成

01:17:28.180 --> 01:17:30.180
会生可能

01:17:30.180 --> 01:17:31.180
可能

01:17:31.180 --> 01:17:32.180
功能不一样的话

01:17:32.180 --> 01:17:33.180
也生成不同的一个性能

01:17:33.180 --> 01:17:34.180
如果说他们功能一样

01:17:34.180 --> 01:17:36.180
那么我们会生成

01:17:36.180 --> 01:17:38.180
同一个X

01:17:38.180 --> 01:17:40.180
会生成同一个X

01:17:40.180 --> 01:17:42.620
同一个X

01:17:42.620 --> 01:17:43.620
对吧

01:17:43.620 --> 01:17:44.620
你只要给我生成

01:17:44.620 --> 01:17:45.620
同一个X就行了

01:17:45.620 --> 01:17:47.620
那么我再把这个X

01:17:47.620 --> 01:17:48.620
交给这个控制器

01:17:50.620 --> 01:17:52.620
他现在变成这么一种结构了

01:17:52.620 --> 01:17:54.620
用X来封装那个复杂度

01:17:54.620 --> 01:17:55.620
那么这样子

01:17:55.620 --> 01:17:56.620
有了X过后

01:17:56.620 --> 01:17:57.620
是不是跟具体的仕途

01:17:57.620 --> 01:17:58.620
操作就断开了

01:17:58.620 --> 01:18:00.620
跟操作就没关系了

01:18:00.620 --> 01:18:01.620
根本就没有什么关系了

01:18:01.620 --> 01:18:02.620
那你看

01:18:02.620 --> 01:18:03.620
我只要有了X之后

01:18:03.620 --> 01:18:04.620
管他这个X怎么来的

01:18:04.620 --> 01:18:06.620
他就是个普通对象

01:18:06.620 --> 01:18:07.620
你要做什么功能

01:18:07.620 --> 01:18:09.620
你给我生成个普通对象就行了

01:18:09.620 --> 01:18:10.620
这个X相当于是

01:18:10.620 --> 01:18:12.620
以前的请求地址

01:18:12.620 --> 01:18:13.620
就像那样是这个

01:18:13.620 --> 01:18:14.620
请求的地址

01:18:14.620 --> 01:18:15.620
对于服务端而言

01:18:15.620 --> 01:18:16.620
就像那一笔

01:18:16.620 --> 01:18:17.620
就相当于是请求的地址

01:18:17.620 --> 01:18:18.620
请求的方法

01:18:18.620 --> 01:18:19.620
附带的数据

01:18:19.620 --> 01:18:21.620
就相当于是这个意思

01:18:21.620 --> 01:18:22.620
因为以前服务端

01:18:22.620 --> 01:18:23.620
控制器能保持存进

01:18:23.620 --> 01:18:24.620
能保持简单

01:18:24.620 --> 01:18:25.620
是因为

01:18:25.620 --> 01:18:26.620
服务端通过地址

01:18:26.620 --> 01:18:27.620
和请求方法

01:18:27.620 --> 01:18:28.620
就能够分配到

01:18:28.620 --> 01:18:29.620
对应的控制器

01:18:29.620 --> 01:18:30.620
因为这个东西

01:18:30.620 --> 01:18:31.620
它并不复杂

01:18:31.620 --> 01:18:32.620
而且情况就那么多

01:18:32.620 --> 01:18:33.620
没有多少情况

01:18:33.620 --> 01:18:34.620
没有多少情况

01:18:34.620 --> 01:18:35.620
但是现在到前端

01:18:35.620 --> 01:18:36.620
非常复杂

01:18:36.620 --> 01:18:37.620
为什么非常复杂

01:18:37.620 --> 01:18:38.620
是因为前端里边的

01:18:38.620 --> 01:18:40.620
操作很多

01:18:40.620 --> 01:18:41.620
操作很复杂

01:18:41.620 --> 01:18:43.620
所以导致了控制器的复杂

01:18:43.620 --> 01:18:44.620
那么现在我们只需要

01:18:44.620 --> 01:18:45.620
做一件很简单的事情

01:18:45.620 --> 01:18:48.620
用多一个层X

01:18:48.620 --> 01:18:49.620
你甭管你进行什么操作

01:18:49.620 --> 01:18:50.620
只要个生成统一个X

01:18:50.620 --> 01:18:51.620
就用玩笑了

01:18:51.620 --> 01:18:52.620
那么我给你扔到

01:18:52.620 --> 01:18:53.620
控制器里面去

01:18:53.620 --> 01:18:54.620
对吧

01:18:54.620 --> 01:18:55.620
好

01:18:55.620 --> 01:18:56.620
于是最重要的东西

01:18:56.620 --> 01:18:57.620
就是引入了X

01:18:57.620 --> 01:18:59.620
它能用来表述要干什么

01:18:59.620 --> 01:19:00.620
这样子一来的话

01:19:00.620 --> 01:19:01.620
那么是不是跟仕图

01:19:01.620 --> 01:19:02.620
就无关了

01:19:02.620 --> 01:19:03.620
你要干什么

01:19:03.620 --> 01:19:04.620
一个生成X就行了

01:19:04.620 --> 01:19:06.620
跟仕图就没有什么关系了

01:19:06.620 --> 01:19:07.620
就没有什么关系了

01:19:07.620 --> 01:19:09.620
原来的意思吧

01:19:09.620 --> 01:19:10.620
好

01:19:10.620 --> 01:19:11.620
它引入这么一个概念

01:19:11.620 --> 01:19:12.620
好

01:19:12.620 --> 01:19:13.620
于是我再把他说完

01:19:13.620 --> 01:19:15.620
有了X过后

01:19:15.620 --> 01:19:16.620
有了X过后

01:19:16.620 --> 01:19:18.620
X交给谁呢

01:19:18.620 --> 01:19:19.620
它是交给一个东西

01:19:19.620 --> 01:19:23.620
叫做数据仓库

01:19:23.620 --> 01:19:24.620
我们把这个

01:19:24.620 --> 01:19:25.620
我们把这个过程

01:19:25.620 --> 01:19:26.620
叫做分发

01:19:26.620 --> 01:19:29.620
叫做分发Dispatch

01:19:29.620 --> 01:19:31.620
Dispatch

01:19:31.620 --> 01:19:32.620
我们把这个X

01:19:32.620 --> 01:19:35.620
X交给数据仓库来处理

01:19:35.620 --> 01:19:38.620
这个过程叫做分发

01:19:38.620 --> 01:19:40.620
Dispatch的单词就是个意思

01:19:40.620 --> 01:19:41.620
分发

01:19:41.620 --> 01:19:42.620
分发的是啥

01:19:42.620 --> 01:19:43.620
分发的是X

01:19:43.620 --> 01:19:44.620
X被分发到哪

01:19:44.620 --> 01:19:46.620
分发到数据仓库

01:19:46.620 --> 01:19:47.620
分发到数据仓库

01:19:47.620 --> 01:19:49.620
数据仓库来干嘛呢

01:19:49.620 --> 01:19:52.620
它数据仓库是用于

01:19:52.620 --> 01:19:54.620
还有一个就是Stone

01:19:54.620 --> 01:19:57.620
表示数据仓库

01:19:57.620 --> 01:20:00.620
用于存储共享数据

01:20:00.620 --> 01:20:02.620
就是我们整个网站里边

01:20:02.620 --> 01:20:03.620
整个系统里边

01:20:03.620 --> 01:20:04.620
哪些数据是需要

01:20:04.620 --> 01:20:05.620
多个组件共享的

01:20:05.620 --> 01:20:06.620
我们把需要

01:20:06.620 --> 01:20:08.620
共享的数据放到这里边来

01:20:08.620 --> 01:20:09.620
也不用把所有的数据

01:20:09.620 --> 01:20:10.620
因为共享的数据

01:20:10.620 --> 01:20:11.620
才是很关心的

01:20:11.620 --> 01:20:13.620
比如说有些组件

01:20:13.620 --> 01:20:15.620
它只有这个组件里边使用

01:20:15.620 --> 01:20:16.620
哪怕它再复杂

01:20:16.620 --> 01:20:18.620
它影响的范围也很小

01:20:18.620 --> 01:20:19.620
只会影响这个组件

01:20:19.620 --> 01:20:20.620
所以说也无所谓

01:20:20.620 --> 01:20:21.620
我们不太会

01:20:21.620 --> 01:20:22.620
把这样的数据提出来

01:20:22.620 --> 01:20:23.620
我们要提到

01:20:23.620 --> 01:20:24.620
一般都是共享数据

01:20:24.620 --> 01:20:26.620
当前用户登陆状态

01:20:26.620 --> 01:20:28.620
有些省份城市

01:20:28.620 --> 01:20:30.620
包括现在就是

01:20:30.620 --> 01:20:32.620
当前登陆的用户信息

01:20:32.620 --> 01:20:35.620
还有目前的拥有的权限

01:20:35.620 --> 01:20:37.620
还有一些共享的

01:20:37.620 --> 01:20:38.620
比如说

01:20:38.620 --> 01:20:39.620
学生所在的年级

01:20:39.620 --> 01:20:40.620
这些到处都要用的

01:20:40.620 --> 01:20:42.620
经常要用到的数据

01:20:42.620 --> 01:20:43.620
共享的数据

01:20:43.620 --> 01:20:44.620
我们就把它放到数据仓库里边

01:20:44.620 --> 01:20:46.620
存起来

01:20:46.620 --> 01:20:48.620
当一个x型

01:20:48.620 --> 01:20:49.620
分发到数据仓库的时候

01:20:49.620 --> 01:20:51.620
数据仓库拿到这个x型

01:20:51.620 --> 01:20:52.620
x型描述的也要做什么

01:20:52.620 --> 01:20:53.620
数据仓库里边

01:20:53.620 --> 01:20:56.620
改变自己的数据

01:20:56.620 --> 01:20:57.620
它根据什么

01:20:57.620 --> 01:20:59.620
还要根据

01:20:59.620 --> 01:21:01.620
还可以根据

01:21:01.620 --> 01:21:03.620
不同的x型

01:21:03.620 --> 01:21:05.620
更改

01:21:05.620 --> 01:21:07.620
仓库中的数据

01:21:07.620 --> 01:21:09.620
中的数据

01:21:09.620 --> 01:21:11.620
比方都举个例子

01:21:11.620 --> 01:21:13.620
像刚才这个x型

01:21:13.620 --> 01:21:14.620
这个x型给谁了

01:21:14.620 --> 01:21:15.620
是不是给这个数据仓库了

01:21:15.620 --> 01:21:16.620
数据仓库

01:21:16.620 --> 01:21:17.620
一看拿到一个x型

01:21:17.620 --> 01:21:18.620
一看你的类型

01:21:18.620 --> 01:21:19.620
你类型是要登陆

01:21:19.620 --> 01:21:20.620
OK

01:21:20.620 --> 01:21:21.620
我们就来做登陆功能

01:21:21.620 --> 01:21:22.620
看一下你的账号密码

01:21:22.620 --> 01:21:23.620
是不是正确的

01:21:23.620 --> 01:21:24.620
如果正确的话

01:21:24.620 --> 01:21:26.620
我在仓库里边

01:21:26.620 --> 01:21:27.620
就记录一下

01:21:27.620 --> 01:21:28.620
你这个用户登陆成功了

01:21:28.620 --> 01:21:29.620
用一个变量

01:21:29.620 --> 01:21:30.620
比方说布尔来记录一下

01:21:30.620 --> 01:21:31.620
你登陆成功了

01:21:31.620 --> 01:21:33.620
如果说你失败了过后

01:21:33.620 --> 01:21:34.620
我用一个东西来记录一下

01:21:34.620 --> 01:21:35.620
你登陆失败了

01:21:35.620 --> 01:21:36.620
就这么个意思

01:21:36.620 --> 01:21:37.620
不要这个意思

01:21:37.620 --> 01:21:39.620
我们通过x型来记录

01:21:39.620 --> 01:21:40.620
再比方说

01:21:40.620 --> 01:21:41.620
这是x型1

01:21:41.620 --> 01:21:43.620
比方说我们要

01:21:43.620 --> 01:21:44.620
删除一个用户

01:21:44.620 --> 01:21:46.620
x型2

01:21:46.620 --> 01:21:47.620
我们这里换一个

01:21:47.620 --> 01:21:49.620
这是lockingx型

01:21:51.620 --> 01:21:52.620
这个是

01:21:53.620 --> 01:21:54.620
就是

01:21:55.620 --> 01:21:56.620
deletex

01:21:56.620 --> 01:21:58.620
删除用户

01:21:58.620 --> 01:22:00.620
类型是delete

01:22:00.620 --> 01:22:01.620
panel的

01:22:01.620 --> 01:22:03.620
就是附加的数据

01:22:03.620 --> 01:22:04.620
就是一个用户的id

01:22:04.620 --> 01:22:05.620
比方说

01:22:06.620 --> 01:22:08.620
e

01:22:08.620 --> 01:22:09.620
表示用户id

01:22:09.620 --> 01:22:13.120
e

01:22:13.120 --> 01:22:16.120
用户id为e

01:22:16.120 --> 01:22:17.120
这么个意思

01:22:17.120 --> 01:22:18.120
不要这个意思

01:22:18.120 --> 01:22:20.120
通过x型来描述

01:22:20.120 --> 01:22:21.120
我要干嘛

01:22:21.120 --> 01:22:22.120
这个概念一定要理解

01:22:22.120 --> 01:22:23.120
这是我们今天的一个概念

01:22:24.120 --> 01:22:25.120
x型

01:22:26.120 --> 01:22:27.120
这就是Flex

01:22:27.120 --> 01:22:29.120
它非常简洁的一种数据方案

01:22:29.120 --> 01:22:31.120
它就提出一个x型的概念

01:22:31.120 --> 01:22:32.120
这个x型

01:22:32.120 --> 01:22:33.120
通过分发

01:22:33.120 --> 01:22:34.120
它可以到

01:22:34.120 --> 01:22:35.120
仓库可以接受到这个x型

01:22:35.120 --> 01:22:36.120
然后这个x型过后

01:22:36.120 --> 01:22:38.120
它来更改自己的数据

01:22:39.120 --> 01:22:40.120
好了

01:22:40.120 --> 01:22:42.120
Flex讲完了

01:22:42.120 --> 01:22:43.120
那么到了这个x里边

01:22:43.120 --> 01:22:46.120
它继续做进一步的优化

01:22:46.120 --> 01:22:48.120
因为它发现

01:22:49.120 --> 01:22:51.120
虽然说我们用了x型

01:22:51.120 --> 01:22:52.120
但是

01:22:52.120 --> 01:22:53.120
毕竟有那么的

01:22:53.120 --> 01:22:54.120
以前的服务器

01:22:54.120 --> 01:22:55.120
毕竟有很多地址

01:22:55.120 --> 01:22:56.120
对不对

01:22:56.120 --> 01:22:57.120
有不同的地址

01:22:57.120 --> 01:22:58.120
请求不同的地址

01:22:58.120 --> 01:22:59.120
是不是要进入不同的控制器

01:22:59.120 --> 01:23:00.120
对吧

01:23:00.120 --> 01:23:01.120
我们之前讲过的

01:23:01.120 --> 01:23:02.120
不同的地址

01:23:02.120 --> 01:23:03.120
不同的方法

01:23:03.120 --> 01:23:04.120
可能要进入不同的控制器

01:23:04.120 --> 01:23:05.120
来处理

01:23:05.120 --> 01:23:06.120
那么如果说

01:23:06.120 --> 01:23:07.120
你仅有一个数据仓库

01:23:07.120 --> 01:23:08.120
在这的话

01:23:08.120 --> 01:23:09.120
它处理的事情

01:23:09.120 --> 01:23:10.120
太过于复杂了

01:23:10.120 --> 01:23:11.120
它又太麻烦了

01:23:11.120 --> 01:23:12.120
它要加

01:23:12.120 --> 01:23:13.120
它这里面数据很多

01:23:13.120 --> 01:23:14.120
有相当多的数据

01:23:14.120 --> 01:23:15.120
而且数据的处理方式

01:23:15.120 --> 01:23:16.120
有各有不一样

01:23:16.120 --> 01:23:17.120
不同的x型

01:23:17.120 --> 01:23:18.120
要不同的处理

01:23:18.120 --> 01:23:19.120
它处理起来也很麻烦

01:23:19.120 --> 01:23:20.120
于是

01:23:20.120 --> 01:23:24.120
在flex基础上

01:23:24.120 --> 01:23:29.120
引入了reducer的概念

01:23:29.120 --> 01:23:31.120
reducer什么意思呢

01:23:31.120 --> 01:23:36.120
reducer可以表示一个处理器

01:23:36.120 --> 01:23:43.120
用于根据x型来处理数据

01:23:43.120 --> 01:23:44.120
就是专门有一个模块

01:23:44.120 --> 01:23:46.120
来处理数据

01:23:46.120 --> 01:23:49.120
然后处理后的数据

01:23:49.120 --> 01:23:56.120
会被仓库重新保存

01:23:56.120 --> 01:23:59.120
就是reducer的处理方式

01:23:59.120 --> 01:24:01.120
来看一下

01:24:01.120 --> 01:24:02.120
那么现在

01:24:02.120 --> 01:24:03.120
我们再画个图

01:24:03.120 --> 01:24:05.120
看一下Redux的方案

01:24:05.120 --> 01:24:06.120
它是这样子

01:24:06.120 --> 01:24:08.120
Redux它同样的

01:24:08.120 --> 01:24:09.120
跟flex一样

01:24:09.120 --> 01:24:10.120
它有x型

01:24:10.120 --> 01:24:11.120
你要做什么

01:24:11.120 --> 01:24:12.120
要描述出来

01:24:12.120 --> 01:24:13.120
描述过后

01:24:13.120 --> 01:24:14.120
我们通过分发

01:24:14.120 --> 01:24:15.120
分发到哪儿呢

01:24:15.120 --> 01:24:17.120
分发到数据仓库

01:24:17.120 --> 01:24:18.120
但是数据仓库

01:24:18.120 --> 01:24:22.120
数据仓库

01:24:22.120 --> 01:24:25.120
它不直接改变里面的数据

01:24:25.120 --> 01:24:26.120
它是这样子

01:24:26.120 --> 01:24:27.120
数据仓库

01:24:27.120 --> 01:24:28.120
它里面不直接改变那数据

01:24:28.120 --> 01:24:31.120
它会把这个x型交给谁呢

01:24:31.120 --> 01:24:32.120
它会把这个x型

01:24:32.120 --> 01:24:34.120
这样子来处理

01:24:34.120 --> 01:24:37.780
这样子画

01:24:37.780 --> 01:24:40.780
就是这里是1

01:24:40.780 --> 01:24:41.780
dispatch

01:24:41.780 --> 01:24:43.780
分发一个x型

01:24:43.780 --> 01:24:44.780
分发x型之后

01:24:44.780 --> 01:24:45.780
那么数据仓库

01:24:45.780 --> 01:24:46.780
拿到了x型

01:24:46.780 --> 01:24:47.780
它会把x型交给谁呢

01:24:47.780 --> 01:24:48.780
交给reducer来处理

01:24:48.780 --> 01:24:49.780
多了一个程

01:24:50.780 --> 01:24:51.780
reducer还是专门来处理数据的

01:24:51.780 --> 01:24:52.780
以前flags里面

01:24:52.780 --> 01:24:54.780
就是仓库里面直接处理

01:24:54.780 --> 01:24:56.780
那么复杂度

01:24:56.780 --> 01:24:57.780
对于仓库而言

01:24:57.780 --> 01:24:58.780
复杂度就变高了

01:24:58.780 --> 01:24:59.780
那么它专门放一个模块

01:24:59.780 --> 01:25:00.780
叫reducer

01:25:00.780 --> 01:25:01.780
它来处理数据

01:25:01.780 --> 01:25:03.780
它会把x型传过去

01:25:06.780 --> 01:25:07.780
第二

01:25:07.780 --> 01:25:08.780
传递

01:25:08.780 --> 01:25:10.780
传递x型

01:25:10.780 --> 01:25:12.780
到reducer里面

01:25:13.780 --> 01:25:15.780
那么reducer来处理这个数据

01:25:15.780 --> 01:25:17.780
那么reducer处理完了过后

01:25:18.780 --> 01:25:19.780
因为reducer拿到这个x型

01:25:19.780 --> 01:25:20.780
它就知道要怎么来处理的

01:25:20.780 --> 01:25:21.780
你要登陆

01:25:21.780 --> 01:25:22.780
你还是要添加选择

01:25:22.780 --> 01:25:23.780
还要找三数学

01:25:23.780 --> 01:25:24.780
它就知道怎么处理的

01:25:24.780 --> 01:25:25.780
而且它可以分模块

01:25:25.780 --> 01:25:26.780
我们后面会详细讲

01:25:26.780 --> 01:25:27.780
处理完了过后

01:25:27.780 --> 01:25:29.780
是不是可以拿到一个数据

01:25:30.780 --> 01:25:31.780
得到

01:25:32.780 --> 01:25:33.780
得到

01:25:33.780 --> 01:25:35.780
得到新数据

01:25:35.780 --> 01:25:36.780
拿到一个新的数据过后

01:25:36.780 --> 01:25:37.780
实动

01:25:37.780 --> 01:25:39.780
是不是可以拿到一个新的数据了

01:25:39.780 --> 01:25:41.780
那么第四

01:25:41.780 --> 01:25:43.780
第四步

01:25:44.780 --> 01:25:46.780
保存新数据

01:25:46.780 --> 01:25:47.780
保存新数据

01:25:47.780 --> 01:25:48.780
到仓库里面

01:25:49.780 --> 01:25:51.780
这就是redux的方案

01:25:51.780 --> 01:25:52.780
redux里面

01:25:52.780 --> 01:25:54.780
我们说有这三个东西

01:25:54.780 --> 01:25:55.780
看一下

01:25:55.780 --> 01:25:56.780
就这三个东西

01:25:57.780 --> 01:25:59.780
首先产生一个x型

01:25:59.780 --> 01:26:00.780
你要做一件事

01:26:00.780 --> 01:26:01.780
你要改变数据

01:26:01.780 --> 01:26:02.780
你要动数据

01:26:02.780 --> 01:26:03.780
产生x型

01:26:03.780 --> 01:26:04.780
那么通过分发

01:26:04.780 --> 01:26:05.780
怎么分发

01:26:05.780 --> 01:26:06.780
我们以后会讲

01:26:06.780 --> 01:26:07.780
通过分发

01:26:07.780 --> 01:26:08.780
把x型交给仓库

01:26:08.780 --> 01:26:10.780
x型它会自动的

01:26:10.780 --> 01:26:12.780
它会自动的把x型传给reducer

01:26:12.780 --> 01:26:14.780
reducer要用干嘛的处理器

01:26:14.780 --> 01:26:15.780
用来

01:26:15.780 --> 01:26:16.780
就是得到新数据的

01:26:16.780 --> 01:26:18.780
根据不同的x型来得到新数据

01:26:18.780 --> 01:26:19.780
那么这样子

01:26:19.780 --> 01:26:20.780
新的数据

01:26:20.780 --> 01:26:21.780
又会被仓库拿到

01:26:21.780 --> 01:26:22.780
它来保存新数据

01:26:22.780 --> 01:26:24.780
这就是整个redux的处理方案

01:26:26.780 --> 01:26:27.780
要改变数据

01:26:27.780 --> 01:26:28.780
谁来处理

01:26:28.780 --> 01:26:29.780
reducer

01:26:29.780 --> 01:26:30.780
要干什么

01:26:30.780 --> 01:26:31.780
产生什么

01:26:31.780 --> 01:26:32.780
产生x型

01:26:32.780 --> 01:26:34.780
x型只剩描述了我要干嘛

01:26:34.780 --> 01:26:36.780
它不做具体改变数据

01:26:36.780 --> 01:26:38.780
它只剩描述我要干嘛

01:26:38.780 --> 01:26:39.780
reducer

01:26:39.780 --> 01:26:40.780
它是根据你要干嘛

01:26:40.780 --> 01:26:41.780
来改变数据

01:26:41.780 --> 01:26:42.780
得到新的数据

01:26:43.780 --> 01:26:44.780
仓库

01:26:44.780 --> 01:26:46.780
一键算就是来存数据

01:26:46.780 --> 01:26:47.780
没了

01:26:48.780 --> 01:26:52.780
变成了一个非常非常简洁的一种方案

01:26:52.780 --> 01:26:54.780
你说这种方案呢

01:26:54.780 --> 01:26:55.780
是mvc吗

01:26:55.780 --> 01:26:56.780
不是

01:26:56.780 --> 01:26:57.780
也不是mvc对不对

01:26:57.780 --> 01:26:59.780
但是它肯定是

01:26:59.780 --> 01:27:01.780
融入了一些mvc的思想

01:27:01.780 --> 01:27:02.780
不要说我刚才讲到的

01:27:02.780 --> 01:27:03.780
controller复杂怎么办

01:27:03.780 --> 01:27:05.780
复杂了就引入x型

01:27:05.780 --> 01:27:06.780
来降低它的复杂度

01:27:06.780 --> 01:27:08.780
其实你要强行说的话

01:27:08.780 --> 01:27:10.780
这个reducer就是controller

01:27:10.780 --> 01:27:11.780
就是控制器

01:27:11.780 --> 01:27:13.780
因为它来处理数据的

01:27:13.780 --> 01:27:14.780
x型相当于什么

01:27:14.780 --> 01:27:17.780
x型相当于以前服务端的请求地址

01:27:17.780 --> 01:27:18.780
根据不同的请求地址

01:27:18.780 --> 01:27:20.780
请求方法和附来的数据

01:27:20.780 --> 01:27:22.780
我要去做一些特别的事情

01:27:22.780 --> 01:27:23.780
最终交给谁来处理呢

01:27:23.780 --> 01:27:25.780
交给reducer来处理

01:27:25.780 --> 01:27:26.780
那么store相当于什么呢

01:27:26.780 --> 01:27:28.780
相当于是服务器以前的数据库

01:27:28.780 --> 01:27:30.780
当然这个数据库还是有区别的

01:27:30.780 --> 01:27:31.780
因为前端的这个数据

01:27:31.780 --> 01:27:32.780
是在内存里边

01:27:32.780 --> 01:27:34.780
一刷新页面就没了

01:27:35.780 --> 01:27:36.780
没了意思吧

01:27:36.780 --> 01:27:37.780
好 OK

01:27:37.780 --> 01:27:40.780
我们这节课讲了半天就是要讲这个东西

01:27:40.780 --> 01:27:42.780
就是把这个东西引入进来

01:27:42.780 --> 01:27:43.780
当然你要说

01:27:43.780 --> 01:27:45.780
对它你通过这么一节课

01:27:45.780 --> 01:27:46.780
一个多小时的讲解

01:27:46.780 --> 01:27:48.780
你要对它了解的非常非常深刻吧

01:27:48.780 --> 01:27:49.780
也不至于

01:27:49.780 --> 01:27:52.780
但是你至现在至少也应该知道

01:27:52.780 --> 01:27:54.780
这一块是不是有三个东西组成的

01:27:54.780 --> 01:27:56.780
reducer是有三个东西组成的

01:27:56.780 --> 01:27:58.780
并且你看一下这个图里边

01:27:58.780 --> 01:27:59.780
跟react有没有关系

01:27:59.780 --> 01:28:00.780
是没有任何关系

01:28:00.780 --> 01:28:01.780
到时候我们讲的时候

01:28:01.780 --> 01:28:03.780
跟react都不会用react来讲

01:28:03.780 --> 01:28:04.780
都不会用react来讲

01:28:04.780 --> 01:28:06.780
我们就讲它的数据处理方案

01:28:06.780 --> 01:28:07.780
讲完了之后

01:28:07.780 --> 01:28:08.780
我们后边讲完了

01:28:08.780 --> 01:28:09.780
我们再来讲

01:28:09.780 --> 01:28:11.780
它怎么跟react来结合

01:28:11.780 --> 01:28:13.780
怎么来讲 怎么结合

01:28:13.780 --> 01:28:14.780
所以我们一开始只讲数据

01:28:14.780 --> 01:28:17.780
关心最纯粹的数据怎么来处理

01:28:18.780 --> 01:28:20.780
好吧 是不是没问题的

01:28:20.780 --> 01:28:22.780
我们首先把这个三个概念

01:28:22.780 --> 01:28:23.780
简单的认识一下

01:28:23.780 --> 01:28:24.780
我们后边会响应说

01:28:24.780 --> 01:28:26.780
这里边有很多很多的细节

01:28:26.780 --> 01:28:27.780
在react室里边

01:28:27.780 --> 01:28:29.780
以前flex没有要求那么严格

01:28:29.780 --> 01:28:30.780
但是react室里边

01:28:30.780 --> 01:28:32.780
对有些细节地方要求很严格

01:28:32.780 --> 01:28:35.780
咱们后边一点点说

01:28:35.780 --> 01:28:37.780
总之我们这一切react室

01:28:37.780 --> 01:28:38.780
为什么要产生

01:28:38.780 --> 01:28:39.780
我们再总结一下

01:28:39.780 --> 01:28:40.780
react室为什么要产生

01:28:40.780 --> 01:28:41.780
flex为什么要提出来

01:28:41.780 --> 01:28:43.780
就是因为前端的数据复杂度

01:28:43.780 --> 01:28:44.780
没有人来处理

01:28:45.780 --> 01:28:47.780
没有人来处理前端的数据复杂度

01:28:47.780 --> 01:28:49.780
包括我们刚才还说了

01:28:49.780 --> 01:28:50.780
就是什么

01:28:50.780 --> 01:28:51.780
mvc里面

01:28:51.780 --> 01:28:52.780
前端mvc的困难里面

01:28:52.780 --> 01:28:54.780
还说到一个就是

01:28:54.780 --> 01:28:56.780
数据难以还原

01:28:56.780 --> 01:28:57.780
什么意思呢

01:28:57.780 --> 01:28:58.780
就是你发现数据变了变了变了

01:28:58.780 --> 01:29:00.780
我想回头到之前的一种状态

01:29:00.780 --> 01:29:02.780
之前怎么变化的

01:29:02.780 --> 01:29:03.780
怎么从一开始

01:29:03.780 --> 01:29:05.780
比方说它一开始是个空数组

01:29:05.780 --> 01:29:07.780
一刷新页面过后

01:29:07.780 --> 01:29:08.780
它变成这个样子

01:29:08.780 --> 01:29:09.780
它中间经过了几次变化

01:29:09.780 --> 01:29:11.780
因为任何一个组织都可能

01:29:11.780 --> 01:29:12.780
可能会改动它

01:29:12.780 --> 01:29:13.780
它经过哪些变化

01:29:13.780 --> 01:29:14.780
我是无法跟踪的

01:29:14.780 --> 01:29:15.780
那么跟踪

01:29:15.780 --> 01:29:17.780
我就自然无法回退到之前的状态

01:29:17.780 --> 01:29:18.780
对吧

01:29:18.780 --> 01:29:19.780
这是很难的

01:29:19.780 --> 01:29:20.780
但是有了react室过后

01:29:20.780 --> 01:29:21.780
你会发现很容易处理

01:29:21.780 --> 01:29:22.780
因为它每一个

01:29:22.780 --> 01:29:23.780
每一个数据的变化

01:29:23.780 --> 01:29:25.780
是不是都要通过x型

01:29:25.780 --> 01:29:27.780
有没有可能直接改数据

01:29:27.780 --> 01:29:28.780
不可能

01:29:28.780 --> 01:29:29.780
你要改数据必须要通过x型

01:29:29.780 --> 01:29:31.780
这就跟服务器一样的

01:29:31.780 --> 01:29:33.780
服务器你要做什么事情

01:29:33.780 --> 01:29:34.780
你是不是必须要请求

01:29:34.780 --> 01:29:35.780
请求服务器

01:29:35.780 --> 01:29:36.780
你不请求

01:29:36.780 --> 01:29:37.780
它怎么能改动数据呢

01:29:37.780 --> 01:29:39.780
你必须要经过控制器

01:29:39.780 --> 01:29:40.780
你要经过控制器

01:29:40.780 --> 01:29:41.780
你就必须要请求

01:29:41.780 --> 01:29:42.780
那这里是一样的

01:29:42.780 --> 01:29:43.780
你要改变数据

01:29:43.780 --> 01:29:45.780
你要必须要经过reducer

01:29:45.780 --> 01:29:46.780
你要经过reducer

01:29:46.780 --> 01:29:47.780
你必须要有x型

01:29:47.780 --> 01:29:49.780
必须要有x型

01:29:49.780 --> 01:29:51.780
x型是改变数据的唯一原因

01:29:51.780 --> 01:29:53.780
这里再几笔

01:29:53.780 --> 01:29:55.780
要是干什么

01:29:55.780 --> 01:29:59.780
x型是触发

01:29:59.780 --> 01:30:04.780
触发数据变化的唯一原因

01:30:04.780 --> 01:30:06.780
你要数据要变化

01:30:06.780 --> 01:30:08.780
一定是有x型发生

01:30:08.780 --> 01:30:10.780
到时候我们要调试就非常方便

01:30:10.780 --> 01:30:12.780
我看一下数据怎么变成这样子的

01:30:12.780 --> 01:30:15.780
我就看一下它经过了多少个x型

01:30:15.780 --> 01:30:16.780
它经过了多少个x型

01:30:16.780 --> 01:30:17.780
怎么样一步一步

01:30:17.780 --> 01:30:19.780
到了这样一个数据

01:30:19.780 --> 01:30:21.780
我们就可以根据一不同的x型

01:30:21.780 --> 01:30:23.780
哪一个x型触发过后

01:30:23.780 --> 01:30:24.780
数据产生的问题

01:30:24.780 --> 01:30:25.780
我们都可以跟踪的

01:30:25.780 --> 01:30:26.780
都可以记录的

01:30:26.780 --> 01:30:27.780
而且我们到时候数据回退

01:30:27.780 --> 01:30:28.780
也非常方便

01:30:28.780 --> 01:30:30.780
我们之后就会掩饰的

01:30:30.780 --> 01:30:32.780
OK 这是关于

01:30:32.780 --> 01:30:33.780
这个x型

01:30:33.780 --> 01:30:35.780
store和reducer

01:30:35.780 --> 01:30:37.780
讲了这么多时间

01:30:37.780 --> 01:30:39.780
目的就是因为

01:30:39.780 --> 01:30:41.780
以前我讲课了过后

01:30:41.780 --> 01:30:43.780
很多同学对这个课理解很模糊

01:30:43.780 --> 01:30:45.780
我先用这么多时间来

01:30:45.780 --> 01:30:46.780
给大家做个铺垫

01:30:46.780 --> 01:30:47.780
后面我们挨在学习的时候

01:30:47.780 --> 01:30:50.780
你才对他们不至于那么陌生

01:30:50.780 --> 01:30:52.780
这是我们的第一节课

01:30:52.780 --> 01:30:55.780
讲一些reducer的概念

