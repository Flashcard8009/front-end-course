WEBVTT

00:00.500 --> 00:05.100
咱们呢 这节课呢 来看一个非常重要的hook

00:05.500 --> 00:10.500
大家手里先 心里面要清楚啊 hook是什么东西啊 hook就是一个函数

00:10.800 --> 00:14.800
这个函数呢 你不能在内组件里面使用 内组件里面使用它要爆错的啊

00:15.200 --> 00:18.500
你只能在函数组件里面 组件里面使用这个hook

00:19.200 --> 00:24.200
它就是一个函数 它提供了各种各样的函数 那么这节课呢 咱们学习其中一个函数

00:24.500 --> 00:28.700
这个函数用来干嘛呢 这个函数呢 它叫做state hook啊

00:29.700 --> 00:42.010
state hook是一个在函数组件中使用的函数 它本来是个函数 这个函数呢 只能在函数组件里面使用

00:43.010 --> 00:49.010
它的函数名称叫做use state 我们之前说过 hook呢 都是用use开头的啊

00:50.010 --> 00:59.010
这么一个函数 这个函数用来干嘛呢 用于在函数组件中使用状态

01:00.010 --> 01:05.810
函数组件不是没有状态吗 好 有了这个 hook 之后呢 咱们在函数组件里面也可以使用状态了

01:07.010 --> 01:13.610
咱们呢 学习 hook 呢 它是这样子啊 我们首先有这么个印象 就是说 hook 呢 它用来增强函数组件的功能

01:14.810 --> 01:21.010
啊 用于呢 就是跟内组件来媲美 对吧 内组件有的它也有 它也都有

01:21.410 --> 01:26.410
并且呢 大家学的过程中呢 会逐渐发现 哇 这个 hook 这个东西呢 不仅说可以

01:27.410 --> 01:35.410
模拟一个内组件的功能 而且说在有的时候呢 很多时候啊 都比内组件还要好用啊 而且会发现一些惊喜

01:35.810 --> 01:42.010
以前内组件很麻烦的事情啊 有些很纠结的一些点 在函数组件里面可以轻松的解决

01:42.710 --> 01:44.910
好 咱们先看一下啊 这个 hook 怎么来用

01:45.910 --> 01:53.110
首先说我们来说一下这个函数 这个函数呢 它是这样子 use state 函数

01:53.910 --> 01:57.310
有一个参数 啊 一个参数

01:59.010 --> 02:05.710
啊 这个参数呢 这个参数的墨 这个参数的值 表示

02:06.910 --> 02:17.910
状态的默认值 不是内组件里边不是有个状态吗 对吧啊 那么这个状态的默认值就是这个参数的值 好 咱们直接来带嘛

02:18.910 --> 02:23.910
这里呢 咱们找到这个 app 啊 在这里边 嗯 怎么弄呢

02:25.110 --> 02:28.910
这不就是个组件吗 对吧 这不就是个函数组件吗 好 就用它嘛 就用它

02:29.710 --> 02:36.510
函数组件里面不是没有状态吗 对吧 这是一个很普通的函数 他不是没有状态吗 ok 我们可以使用

02:36.910 --> 02:42.510
use 就这东西 use state 给他添加一个状态 给这个函数组件添加一个状态

02:42.910 --> 02:46.510
好 咱们来看一下啊 怎么来用这个东西 咱们导入的时候呢

02:47.110 --> 02:52.710
加上一个 use state 加上这么一个函数 那么这个函数这个函数呢 就是 hook

02:53.410 --> 03:02.510
这个函数你注意哦 你不能在外边调用 千万不能这样子写哦 你这样子写是不行的啊 比方说我们在这里写一个吧 写个 use state 咱们来看一下吧

03:03.110 --> 03:06.510
啊 这个函数呢 随便给一个默认值嘛 你嘛 随便写一个啊

03:07.510 --> 03:08.510
啊

03:09.510 --> 03:11.110
cdreact

03:11.910 --> 03:19.110
no y'all start啊 就是使用 hook的时候呢 不曉得同学呢 容易犯这个错误啊 他想在一开始一把的状态得到

03:19.910 --> 03:27.380
实际上都是不行的啊 是不行的 咱们来看一下吧 这里检查啊 右键 我看一下控制台

03:31.430 --> 03:39.230
稍等一下啊 你看 是不是爆错了 他说什么 他说invited hook call 他说你就是无销的 hook调用

03:39.630 --> 03:48.430
他说 hook 只能 can only be called 只能再被调用 在什么地方被调用呢 inside of body function component

03:49.030 --> 03:53.230
在一个函数组件的函数体中被调用

03:54.030 --> 04:01.830
啊 所以说呢 你这个代码呢 写出来是无效的啊 你不能这样写 你必须要把这个函数呢放到这里边啊 放到这里边

04:02.630 --> 04:08.430
比方说我们要做一个什么样的效果呢 假设我们要做这么一个效果 这里边呢 有这么一个

04:09.230 --> 04:22.230
按钮啊 有这么一个按钮 这是减啊 减少 然后呢 这个按钮呢 这是加啊 增加中间呢 有个数字啊 中间有个数字啊 一个数字呢 它显示一个数字 比方说显示0吗

04:22.730 --> 04:30.530
保存 你看一下啊 咱们要做出这么一个效果 点加的话 这个数字增加点减的话 这个数字减少啊 减少就这么减的

04:31.430 --> 04:38.230
好 那么怎么做呢 这东西 好 接下来 因为他肯定要有状态 对吧 他要有数据嘛 这个地方肯定要选择数据

04:39.030 --> 04:46.430
但是呢 我们现在没有数据 对吧 以前呢 我们韩束组建没有办法 只能让别人把数据传给我 对不对 通过属性来传给我

04:46.730 --> 04:55.430
那么先 因为以前韩束组建没有状态嘛 那么现在韩束组建可以有自己的状态了 如果我们分析出 哎 这个组建呢 它确实可以有自己的数据

04:55.990 --> 05:03.030
那么这个时候呢 我们以前只能使用内组建 现在可以使用韩束组建了 好在韩束组建里面使用状态 use state

05:04.030 --> 05:13.030
好 那么这个里边的参数填啥呢 你可以不填 可以不填 不填的话 那么这个状态的默认值就是 undefined

05:13.830 --> 05:21.030
就是 undefined 如果你填写一个值的话 那么这个你给的值是什么 那么这个状态的值就是什么

05:21.910 --> 05:28.390
哎 通过这一点可以大家可以发现啊 一会我们再总结啊 他跟那个state的区别 通过这一点我们可以发现的

05:29.390 --> 05:34.150
我们在韩束组建里面 那个状态啊 是不是可以是一个那个

05:35.190 --> 05:41.510
原始内形看到没 他可以是一个原始内形而我们在喊在内组建里面状态是不是必须是一个对象

05:41.910 --> 05:47.230
对吧 我虽然之前没有明说啊 但是肯定必须是一个对象 因为到时候还要合并对象嘛 对不对

05:48.310 --> 05:53.190
好 那么这里 use state 这里传入一个默认值0 那么就是啊

05:54.070 --> 05:58.790
新增一个状态 不能叫新增啊 使用一个状态

06:00.710 --> 06:04.310
该状态的默认值是0

06:05.750 --> 06:12.070
接下来我们来看一下这个韩束它反回什么东西 雕用这个韩束它会它会反回一个结果 它会反回一个什么东西呢

06:14.230 --> 06:21.350
这个韩束有一个参数这是参数 另外呢 韩束的反回结果 韩束的反回值

06:22.310 --> 06:27.510
是一个数组 它会反回个数组 就很奇怪 它为什么会反回个数组呢

06:28.310 --> 06:34.630
它是这样子 这个数组里面包含两项 该数组 说完你就知道了 该数组

06:35.670 --> 06:38.150
一定包含两项

06:39.670 --> 06:47.190
它不可能是0 长度不可能是0 也不可能是更多 它只能可能是2 长度一定是2包含两项 那么第一项

06:48.150 --> 06:55.190
第一项是什么呢 就是状态 当前状态的值 当前状态的值

06:56.470 --> 07:02.310
第二项 得到了是什么呢 改变状态的韩束

07:03.030 --> 07:10.470
也就是它会得到两个东西 你使用状态 又是表示使用嘛 使用状态默认值是0 于是它反回一个数组

07:11.430 --> 07:21.190
这个数组里面有两项 第一项是什么呢 是状态的值 比方说咱们用一个n来表示

07:22.070 --> 07:23.030
表示个状态的值

07:26.230 --> 07:28.630
比较得到状态的值

07:29.990 --> 07:32.230
状态的值目前就是0 对不对 目前就是0

07:32.870 --> 07:33.590
好 然后呢

07:34.550 --> 07:43.270
第二项呢 这个数组的第二项呢 是一个韩束 比方说用给变量来接收 韩束也是对象嘛 对不对 当然可以接收一下 对不对

07:44.070 --> 07:48.870
那么我们这里用6n嘛 6n 就是来改变这个状态的值的韩束

07:49.430 --> 07:56.470
你到时候状态要发生变化怎么办呢 你就掉用这个韩束 这个韩束哪来的 它反回给你的 反回到在哪的 反回在数组里面

07:57.430 --> 08:05.110
数组的第二项 这是得到什么 得到一个韩束 该韩束用于改变状态

08:06.710 --> 08:13.510
就相当于是这个set state 对吧 相当于是这么一个韩束 第一个是状态的值 这又是状态的韩 改变状态的韩束

08:14.230 --> 08:20.150
好了 那么接下来我们怎么来完成这个功能呢 怎么来完成了 比方这里 是不是要显示状态的值

08:20.710 --> 08:26.790
哎 我们在这里就直接写上一个n 对吧 写上一个n 是不是可以把状态的值显示出来了

08:27.350 --> 08:32.230
好 那么怎么来改变状态呢 比方说这个韩束都点这个按钮的时候啊 点加嘛

08:33.110 --> 08:41.670
点这个按钮的时候onclick 是不是重测时间 对吧 哎 重测时间 点击这个按钮的时候干嘛呢 是不是要改变这个n的值

08:41.990 --> 08:46.710
ok 我们就怎么怎么来改变 掉用这个数组里边的这个韩束set n

08:47.590 --> 08:55.590
啊 掉用这个韩束 这个名字随便你取啊 随便你取啥名字 只不过命名上的我们习惯上啊 把这个状态的名字呢 取个名字

08:55.670 --> 09:00.630
然后呢 韩束的给他命名为set 同样的名字啊 用小通风命名法

09:01.270 --> 09:06.630
好set n 把新的值传进去 新的值是啥呢 新的值是n加1

09:07.430 --> 09:14.470
对不对 增加嘛 他原来的值加上1对不对 把新的值给他传进去 那么这里减少了onclick

09:16.660 --> 09:20.020
啊 这里 我们就使用set n 然后n-1

09:20.740 --> 09:28.900
对吧 就这么简单 就完了 没了 就没了 保存你看一下吧 你看他的状态就出来了 看到没

09:29.860 --> 09:34.660
啊 就可以改变了 这就是韩束组建的写法 你仔细观察一下

09:35.380 --> 09:41.140
是不是比内组建要简洁太多了 对不对 那里看一下咱们内组建要写多少 多少袋嘛

09:41.860 --> 09:45.300
啊 咱们写个内组建啊 class app

09:46.500 --> 09:51.460
一个天子 还要先继承 对吧react component 然后呢

09:52.580 --> 09:58.500
如果不使用那个yes 那个是语法的话 咱们还要写什么 构造韩束probs

09:59.380 --> 10:05.220
还要写这个东西 然后呢还要声明状态 对吧 this state 声明状态

10:07.540 --> 10:09.860
状态是什么呢 状态是有个n

10:10.580 --> 10:18.900
n 是什么 默认指示0 然后还要写个什么 还要写个render render返回 返回什么呢 返回这一坨 对吧

10:20.260 --> 10:22.260
哎 咱们内组建是不是要这样子写

10:23.860 --> 10:27.300
啊 返回这一坨 然后呢 这里要用什么set state

10:28.020 --> 10:34.740
啊 然后这里要传个对象 这个对象呢 来自于n的指呢 来自于this state 点n加1

10:35.460 --> 10:38.260
n-1 对不对 啊 这里还要用this

10:39.220 --> 10:44.820
啊 而且你要注意这里的类似指向 你只能写现场韩束 或者是写那个啊 这里

10:45.700 --> 10:49.940
n加1 对不对 这是内组建的写法 啊 这里呢来自于this

10:50.900 --> 10:55.860
state 点n 是繁琐很多啊 内组建 一看韩束组建是不是变得非常非常简洁

10:56.500 --> 11:03.540
啊 这是从那种最直观的方式来看到啊 这个韩束组建使用那个啊 使用这个u state 之后呢

11:04.580 --> 11:07.620
既有了状态 而且变得非常非常简洁 看没

11:08.340 --> 11:18.980
再来过一次啊 使用状态啊 使用状态 然后呢 得到一个数组 这个数组的第一项呢 是状态当成了值 第二项呢 是什么呢 是

11:20.180 --> 11:22.420
用于改变状态的一个韩束

11:23.460 --> 11:27.060
好 那么 我们到时候要改变状态 就直接调用这个韩束就完事了

11:27.540 --> 11:31.300
好 要获取这个状态的值 直接使用这个变量就完事了 就这么简单

11:31.700 --> 11:39.220
这就是在韩束组建里面所指用状态 并且呢 我们为了可以使用那个s6里边不是有解构的语法吗

11:39.700 --> 11:41.860
对不对 哎 这个玩意儿 你看着啊

11:43.300 --> 11:44.660
这个玩意儿 use state

11:46.420 --> 11:50.500
0啊 是使用一个状态 干状态的mortem只是0

11:50.980 --> 11:55.220
那么我们可以使用解构的语法 他得到的不是数组吗 直接在这里解构

11:55.780 --> 11:58.820
啊 这是常 我们使用后壳的时候常见的一种方案

11:59.300 --> 12:04.020
直接直接在这里解构 不是返回数组里面两个东西吗 第一个东西呢 我用变量n来接收

12:04.580 --> 12:10.260
第二个东西呢 我们用setsn来接收 对吧 一句话就写完了 对吧 使用状态 默认只是0

12:10.820 --> 12:16.180
哎 然后呢 这是我们当前的状态值 这是我们改变状态的韩束 对吧 一句话就写完了

12:16.980 --> 12:20.820
这样子更加简洁了啊 我们前面三句话就可以不要了 是不是更加简洁了

12:21.380 --> 12:22.900
好 保存你看一下是一样的效果

12:24.260 --> 12:25.860
看来 对吧 是一样的效果

12:26.820 --> 12:34.820
没问题吧 嘿 这这这就是咱们这个啊 这个就是在韩束组件里边使用状态的这种方式

12:35.860 --> 12:40.740
好 这是关于use state 他最基本的使用方式

12:42.020 --> 12:47.460
另外一点呢 大家还要注意 他肯定是有一些区别的啊 跟内组件里边的状态还有一些区别的

12:48.020 --> 12:54.180
呃 就是说在韩束组件里边就是使用这个state hook 他有这么一个特点啊

12:54.900 --> 13:00.820
一个韩束组件中一个韩束组件中可以有多个状态

13:01.620 --> 13:07.460
是不是跟内组件不一样了 内组件是不是只能有一个状态 甭管你有多少数据 你必须要全部放到对象里边

13:08.180 --> 13:14.100
但还在单是在韩束组件里边你使用 hook 来表示状态的话 你可以使用多个状态

13:14.500 --> 13:20.260
这样子的就非常有利于啊 这种做法非常有利于

13:22.340 --> 13:26.340
有利于横向切分关注点

13:27.220 --> 13:33.220
因为我们有的时候呢 一个一个组件里边 他状态可能非常非常多啊 有什么当前是第几页

13:33.860 --> 13:41.220
比方说一个分业组件 当前是第几页 然后呢 总的数据量每页钱是多少条 对吧 有很多很多的状态

13:41.940 --> 13:46.180
那么这些状态非常非常多 如果说你把它全部混在一个对象里边呢

13:46.660 --> 13:49.300
会把整个结构变得非常非常复杂

13:49.860 --> 13:54.660
但是呢 在韩束组件里边使用 hook 的话 你可以把它分开成为不同的状态

13:55.700 --> 14:01.780
这样子呢 就有利于呢 我们每一次只关注其中一个状态的变化就行了 比方说吧 举个例子

14:03.060 --> 14:07.380
嗯 那就随便举个例子 比方说这里呢 假设啊 还有一个按钮

14:08.260 --> 14:15.460
还有一个按钮 显示隐藏啊 显示和隐藏 他用于显示和隐藏上面的P元数

14:16.580 --> 14:20.580
啊 上面一个P元数 把整个包起来 他用于显示和隐藏上面的P元数

14:21.780 --> 14:26.100
那是不是要多一个状态 对不对 哎 保存 让我们来看一下啊 下面一个按钮了啊

14:26.660 --> 14:31.220
显示和隐藏 那么用于显示隐藏这个这个区域 那这个时候怎么做呢

14:31.700 --> 14:33.300
这个时候 我们就可以使用

14:34.820 --> 14:40.420
另外一个状态 我们没有必要啊 当然能不能在这里写个对象 能不能 我们两种做法都做一下吧

14:40.900 --> 14:45.140
两种做法都都做一下 能不能在这里呢 使用一个对象呢 可以

14:46.100 --> 14:52.260
只是呢 官方他不推荐你这么做 他认为呢 就是说你不同的状态 表达的是不同的逻辑含义的话

14:52.900 --> 14:58.260
逻辑含义不是一块东西的话 那么你尽量把它拆分 这样子呢 写出来代码了 更加优质

14:58.820 --> 15:04.100
所以说呢 另外一个东西呢 跟这个没有什么关系 跟他有啥关系呢 他就用来控制显示隐藏的

15:04.580 --> 15:08.020
我再写一个状态啊 我们两种做法都做一下吧啊

15:08.580 --> 15:16.100
不是 n啊 随便给他个名字吧 这个边量名字的随便去 比方说是否显示visible啊 然后呢 这里用set

15:16.740 --> 15:19.300
visible啊 这里use state

15:20.180 --> 15:25.620
默认值 默认值是啥呢 默认值啊 随便给一个吧啊 默认值呢 我们使用

15:26.180 --> 15:26.580
嗯

15:27.860 --> 15:28.180
force

15:29.940 --> 15:34.260
丑嘛啊 表示默认是显示的 对吧 我们就又加了一个状态

15:34.900 --> 15:39.540
啊 这个状态的值 碰到这个边量里边啊 状态改变的含书 碰到这

15:40.660 --> 15:43.860
好 接下来呢 我们这当然可以自己熟悉啊 也可以利用这个插件

15:44.100 --> 15:48.340
咱们vscode安装了一个es6那个 就是那个很长一转那个玩意

15:48.900 --> 15:56.660
就这个玩意啊 就这个插件啊 es7rx rdx 这个插件对吧 那么按这个插件之后呢 我们可以直接使用use state

15:57.140 --> 16:01.700
啊 最选第二个啊 选第二个 第二个就是个代码段啊 选第二个

16:02.420 --> 16:08.100
你看 是不是直接给你生成出来了啊 那么这个地方呢 我们直接写一个啊 直接写一个visible

16:08.420 --> 16:13.780
你看 直接给写出来了啊 按一下type件切换 切换到这啊 默认值 默认值是去

16:14.500 --> 16:20.820
对 就完了 好 然后这个东西写出来之后呢 比方说这里vp 要不要显示

16:21.300 --> 16:26.180
要不要显示取决于这个visible的值 对不对啊 取决他的值 咱们就给他写个

16:26.740 --> 16:33.140
style嘛啊 我们之前讲过那个性能优 就是渲染原理这里啊 一个性能优化 就是尽量的不要后装

16:33.460 --> 16:35.940
如果一个元一个元素他经常的

16:36.660 --> 16:42.580
显示和隐藏的话 那么尽量不要把这个元素搞得消失啊 不让他消失避免就是

16:43.540 --> 16:48.580
整个多母数不一致 所以说我们经常的最好的是把他用成style来进行隐藏

16:49.060 --> 16:54.260
好了 那么这个display属性 他是否显示呢 取决于什么 取决于visible的值

16:55.060 --> 17:00.740
如果这个visible为true啊 如果这个visible为true 那么是不是要显示 对吧 display block

17:01.940 --> 17:07.780
显示 否则的话干嘛呢 否则的话是不是要隐藏 对不对 隐藏display呢

17:08.500 --> 17:15.060
我们用display来控制 当然也可以用也可以用那个visible来控 就是整个元素让他不出现也可以

17:16.100 --> 17:23.620
好 那么这个p元素受控于这个状态 那么点击这个按钮的时候 咱们干嘛呢 点击这个按钮的时候 我们就可以

17:24.660 --> 17:32.420
使用set visible set visible 然后呢 把它设置为什么 跟当前的visible不一样 对吧 取反

17:32.820 --> 17:40.100
对不对 当前是true呢 就把它变成force给他传进去 当前是force呢 把它变成true传进去 这样子呢 就改变了状态了

17:41.140 --> 17:48.740
你看一下 这个过程啊 非常非常舒服 啊 状态是切分开的 这里只控制visible 好 保存 你看一下啊

17:49.620 --> 17:55.460
那么这里显示隐藏 你看 这里是不是可以控制的啊 这里可以控制的 并且这里呢 互不干擾

17:56.260 --> 18:01.060
而且从代码的逻辑上也是完全把它分开的 并没有把它揉在一起

18:01.860 --> 18:07.700
也就是我们的 在函数里边是可以使用多个状态的 使用多个状态 没问题吧

18:08.740 --> 18:16.740
哎啊 一会儿呢 我们再重新做一个 就是把它合并的一个 把它合并的一个结果 合并成一个对象的结果 以后我们再做一个

18:17.380 --> 18:24.180
好 这是 认识到这一个点啊 state hook 可以有多个状态 好 那么接下来呢 我们就要讲

18:24.900 --> 18:30.820
就是state hook原理 它到底是怎么来实现的

18:31.860 --> 18:39.140
因为感觉上的有点奇怪 非常奇怪啊 我不知道有没有同学啊 注意到这个点 就是这个东西它非常奇怪

18:40.020 --> 18:44.340
函数组件它不是每一次渲染都会重新运行函数吗

18:45.460 --> 18:53.620
哎 这个一重新运行不就又把它变成0了吗 因为函数会全部重新运行 你不能说我运行这个函数 其中一些代码不运行 那不可能

18:54.420 --> 18:55.220
很那不可能的

18:56.500 --> 19:02.820
比如那里边就可以控制 对吧 那里边像勾到函数里边只运行一次 然后呢那些初始化自断只运行一次

19:03.620 --> 19:10.900
我们平时后面在运行的都只是重新运行 软的对不对 但是函数之间它就一个函数啊 它就只有一个函数

19:11.620 --> 19:18.020
那么这个函数每一次渲染它全部要重新运行一次 那第二次运行的时候是不是又把它初始化为0了

19:18.820 --> 19:24.020
那这个东西怎么来控制呢 那为什么会发生变化呢 为什么这里会看到变化呢

19:24.580 --> 19:27.780
只要讲讲它的原理 咱们挨着挨着来说

19:28.660 --> 19:33.140
它是怎么回事呢 我们这里肯定要画图啊 它是这样子

19:34.340 --> 19:34.740
如果

19:37.140 --> 19:40.340
当运行一个函数组件

19:41.780 --> 19:43.140
函数组件

19:43.780 --> 19:49.220
时 就是运行这个函数 运行函函数 调用函数时

19:52.600 --> 19:55.400
首先搞清楚是谁在调用这个函数

19:56.280 --> 19:58.280
谁在调用呢 是一个节点

19:59.080 --> 20:06.120
我们之前讲了个渲染过程对吧 会生成那个虚拟动物数 这个虚拟动物数呢 每一个地方是不是个节点对不对

20:07.320 --> 20:12.040
这个虚拟动物数的节点里边是不是可以 它持有了这个rekt元素

20:12.600 --> 20:17.560
咱们要画个图啊 顺便回顾一下之前咱们讲的一块儿 渲染原理那一块儿的知识啊

20:18.360 --> 20:20.360
这是state hook原理

20:22.900 --> 20:23.940
它是怎么来实现的啊

20:30.100 --> 20:35.620
首先呢 我们比较说啊 生成那个在那个社里边不是一个不是一个节点吗 对吧 app

20:36.100 --> 20:42.340
好 app 这个节点 那么使用这个节点的时候会是不是会生成一个节点对吧 什么节点是不是组件节点

20:43.300 --> 20:46.900
对不对 组件节点 app

20:47.380 --> 20:52.900
生成这么一个节点 好 那么这个节点里边是不是持有了 它一定会持有一个引用

20:53.300 --> 21:02.820
什么引用呢 因为我们知道这个东西是一个啥 是通过这个rekt create element 对吧 通过它来创建的这么一个rekt元素

21:03.460 --> 21:05.940
对不对 于是呢 它会持有这么一个元素

21:08.440 --> 21:12.760
好 咱们来画一个啊 它会持有这么这么一个元素对象

21:16.440 --> 21:16.840
这里

21:18.440 --> 21:21.320
节点啊 它会持有这么一个元素对象

21:22.440 --> 21:24.120
元素对象 就是rekt元素

21:24.680 --> 21:28.760
rekt element 好这个rekt element里边不是

21:29.080 --> 21:32.680
它是不是就可以找到这个函数了 它到底对应的是哪个函数 是不是可以找到了

21:33.800 --> 21:36.040
能理解吧 比方说啊咱们 app

21:37.080 --> 21:40.040
看一下 我们把这个生成出来放到这

21:41.000 --> 21:47.240
好 这里呢 我们输出 这是我们之前演示过的啊 保存你看一下 那么这里输出的结果你看

21:47.640 --> 21:52.280
这里它是一个rekt元素 这个元素里边这个type值 你看是不是这个函数

21:52.760 --> 21:56.680
对吧 就是这个函数组件 这个函数本身对不对 就是这个函数

21:57.080 --> 22:01.480
所以它会持有这个函数的引用啊 会持有这个函数的引用

22:02.360 --> 22:08.180
那么也就是说这里面呢 它会有一个函数啊 咱们再来画一个啊

22:08.900 --> 22:11.060
就是方可形 app

22:11.940 --> 22:15.700
会持有这个函数的引用 对吧 它是这么一种层次结构

22:17.060 --> 22:22.180
所以说呢 我们通过这个节点呢 通过这个节点对象呢 是不是可以找到这个rekt element

22:22.580 --> 22:27.860
可以找到这个函数 于是呢 它既然是一个节点 它是一个函数组件嘛 函数组件 我们之前说过

22:28.180 --> 22:31.700
在我们的宣传过程中非常非常简单 就是运行这个函数就完事了

22:32.660 --> 22:36.340
好 那么这个时候我讲一讲 它运行这个函数的时候干了干了什么事情

22:37.220 --> 22:42.180
好 运行这个函数 首先运行到第一句话 第一句话在调用什么 调用useState

22:42.900 --> 22:46.260
对吧 调用useState 那么它怎么来调用的呢 它是这样子

22:47.300 --> 22:49.860
它会useState呢 它会做这么一些事情

22:50.580 --> 22:56.260
看一下啊 我们在这里 第一步 useState

22:58.420 --> 23:06.180
调用useState 那么就调用useState的时候 它干嘛呢 它首先检查

23:07.060 --> 23:11.540
该节点的状态表格

23:13.700 --> 23:16.340
什么意思呢 我们之前说

23:17.300 --> 23:20.180
在创建一个节点的时候 实际上做了很多事情的

23:20.980 --> 23:24.980
只不过呢 这些事情呢 我们之前呢 因为知识不够

23:25.220 --> 23:29.780
useState还没有设计到圆码层面 我们只是说简单的就说就创了一个节点对象

23:30.100 --> 23:33.780
实际上它还有很多事情要做 在创建这个节点的时候呢

23:34.340 --> 23:37.860
比较说创新建这个节点的时候呢 它会生成一个表格

23:38.580 --> 23:43.380
如果是第一次创建这个节点 它会生成一个表格 这个表格呢 我们在这里画了这

23:44.980 --> 23:45.380
画了这

23:46.340 --> 23:48.100
换个颜色

23:51.780 --> 23:52.980
用个啥颜色

23:53.780 --> 23:54.900
随便吧 随便

23:55.300 --> 23:57.620
有这个颜色吧 它会生成这么一个表格

23:58.340 --> 24:01.380
这个表格里边 我们把它叫做状态表格

24:03.490 --> 24:06.210
表格 这个表格默认是空的

24:06.930 --> 24:11.090
那么这个时候呢 它会检查这个节点的状态表格 看状态表格里面有没有东西

24:11.970 --> 24:12.690
有没有东西

24:13.810 --> 24:15.170
如果说没有东西

24:17.810 --> 24:18.370
状态

24:19.730 --> 24:20.610
状态

24:20.850 --> 24:21.810
表格中

24:21.970 --> 24:22.610
无内容

24:23.090 --> 24:24.450
如果说没有内容

24:25.250 --> 24:25.970
没有内容

24:26.130 --> 24:27.250
那么这个时候怎么办呢

24:27.970 --> 24:29.810
它会就是使用默认值

24:30.610 --> 24:31.650
使用默认值

24:32.210 --> 24:33.810
创建一个状态

24:34.370 --> 24:37.250
这个时候它会使 就是这个Ustate这个还是它做的事情

24:37.570 --> 24:40.610
它要检查 它不是说一定创建状态

24:41.010 --> 24:45.650
它也要检查这个节点的状态表格里边 有没有对应的状态

24:46.130 --> 24:48.050
如果没有对应的状态的话 那么

24:48.850 --> 24:51.010
它就使用默认值创建一个状态

24:51.730 --> 24:53.090
将该状态

24:53.090 --> 24:56.210
然后将该状态状态加入到表格中

24:57.730 --> 24:58.370
表格中

24:59.250 --> 25:00.450
它会做这么一件事情

25:00.850 --> 25:03.010
好 于是那个状态表格以前是没有的 对吧

25:03.010 --> 25:04.130
现在是不是空的

25:04.370 --> 25:05.970
空的之后呢 现在呢 是不是

25:06.610 --> 25:07.810
加入了一个状态 对不对

25:08.210 --> 25:09.570
OK 那么加入了什么状态

25:10.130 --> 25:10.850
加入了什么状态

25:11.330 --> 25:12.210
好 那么这里呢

25:13.250 --> 25:14.610
状态的默认值是零

25:14.610 --> 25:16.130
于是呢 它多了一个状态了

25:16.610 --> 25:18.690
什么状态呢 就是零这个状态

25:19.570 --> 25:22.930
就是这个下标为零

25:23.810 --> 25:27.010
下标零

25:27.410 --> 25:29.090
它是一个表格 它相当于是个数组

25:29.090 --> 25:30.050
下标为零

25:30.530 --> 25:31.730
然后呢 状态值

25:32.290 --> 25:33.810
状态值为什么呢 也为零

25:34.690 --> 25:37.570
对吧 是用默认值创建往这个表格里边

25:38.130 --> 25:39.250
将来是状态数组嘛

25:40.050 --> 25:40.530
用数组

25:41.170 --> 25:42.290
数组好理解一点

25:44.850 --> 25:46.530
实际上它这里边还不止这两个东西

25:46.530 --> 25:47.970
不过跟我们没有什么关系了

25:48.930 --> 25:50.690
加上到状态数组中

25:51.330 --> 25:53.650
这个数组里边上下标为零

25:53.650 --> 25:54.850
状态值呢 是零

25:55.250 --> 25:55.650
看没

25:56.290 --> 25:59.170
OK 那么这就是状态数组

25:59.170 --> 26:01.010
那么接下来啊 第一句话运行完了

26:01.570 --> 26:02.690
第一句话运行完了

26:02.690 --> 26:04.450
然后接下来运行第二句话

26:04.450 --> 26:05.970
是不是还是优势State

26:07.010 --> 26:08.930
这是第二次调用优势State

26:08.930 --> 26:10.370
那么第二次调用的时候

26:10.370 --> 26:11.890
它是这样子 我已经不好写了

26:11.890 --> 26:13.090
这个东西不好写了

26:13.090 --> 26:14.850
我就注意听我说就行了

26:14.850 --> 26:16.130
刚才呢是第一

26:16.290 --> 26:17.970
就是在运行这个函数的时候

26:18.690 --> 26:20.290
第一次调用优势State

26:20.290 --> 26:23.250
于是呢 它看一下这个状态数组里边

26:23.250 --> 26:24.450
有没有下标零

26:25.250 --> 26:26.290
有没有下标零

26:26.290 --> 26:27.410
如果没有的话

26:29.250 --> 26:29.810
这样说吧

26:30.370 --> 26:31.090
第N次

26:31.890 --> 26:34.130
第N次调用优势State

26:34.130 --> 26:36.370
那么检查该检查的状态数组

26:36.370 --> 26:37.890
是否存在

26:39.330 --> 26:39.570
N

26:40.770 --> 26:41.410
下标N

26:42.930 --> 26:44.450
是否存在下标N

26:44.450 --> 26:45.890
如果说不存在的话

26:46.690 --> 26:47.890
如果说不存在的话

26:49.890 --> 26:50.370
不存在

26:53.520 --> 26:54.240
这样子

26:54.240 --> 26:55.440
如果是不存在的话

26:55.440 --> 26:57.760
那么就使用默认值创建一个状态

26:57.760 --> 27:00.400
那么把该状态加入到状态数组中

27:00.400 --> 27:01.120
下标为N

27:03.640 --> 27:04.360
比较重要 比较重要

27:04.360 --> 27:06.760
刚才是第几次调用优势State

27:06.760 --> 27:08.120
是不是运行这个函数的时候

27:08.120 --> 27:08.680
第一次

27:08.680 --> 27:09.320
对吧

27:09.320 --> 27:10.200
运行这个函数的时候

27:10.200 --> 27:11.800
第一次调用这个优势State

27:11.800 --> 27:12.680
于是呢

27:12.680 --> 27:14.120
它发现这个数组里边

27:15.320 --> 27:17.160
那么就检查第一次

27:17.160 --> 27:17.960
下标就是零嘛

27:17.960 --> 27:18.600
对不对

27:18.600 --> 27:19.640
下标零的位置

27:19.640 --> 27:20.840
有没有数据

27:21.400 --> 27:22.200
下标为0的位置

27:22.200 --> 27:22.920
有没有数据

27:22.920 --> 27:24.120
发现如果没有数据

27:24.120 --> 27:24.680
于是呢

27:25.960 --> 27:26.920
把这个数据加上

27:26.920 --> 27:27.960
下标为0

27:27.960 --> 27:28.840
然后呢

27:28.840 --> 27:29.640
状态值呢

27:29.640 --> 27:31.560
是N使用默认值作为状态

27:32.520 --> 27:33.640
没问题吧

27:33.640 --> 27:35.000
当然它会对应一个函数

27:35.000 --> 27:36.040
它会给你生成一个函数

27:36.040 --> 27:38.520
StateN会生成这么一个函数

27:38.520 --> 27:39.160
这个函数呢

27:39.160 --> 27:40.520
到时候就可以改变

27:40.520 --> 27:41.640
对应的这个状态

27:41.640 --> 27:42.520
改变的是这个状态

27:43.720 --> 27:44.120
好那么

27:44.760 --> 27:45.640
然后再看

27:45.640 --> 27:47.400
后面我们继续调用优势State

27:47.400 --> 27:48.280
是不是第二次的

27:48.280 --> 27:48.600
对吧

27:48.600 --> 27:49.560
调用这个函数中

27:49.560 --> 27:51.320
第一句话第一次用了优势State

27:51.320 --> 27:52.840
第二次调用了优势State

27:52.840 --> 27:53.240
于是呢

27:53.240 --> 27:54.920
第二次调用优势State的时候呢

27:55.480 --> 27:56.760
那么他就发现

27:56.760 --> 27:58.040
下标为1的时候

27:58.040 --> 27:59.320
下标为1从不存在呢

27:59.320 --> 28:00.840
所以还是不存在

28:00.840 --> 28:01.880
还是不存在的话

28:01.880 --> 28:03.080
是不是又要的这个过程

28:03.080 --> 28:04.760
使用默认值创建一个状态

28:05.480 --> 28:06.200
使用默认值

28:06.200 --> 28:08.840
那么就下标为解为1

28:08.840 --> 28:10.120
那么状态值呢

28:10.120 --> 28:10.760
是什么

28:10.760 --> 28:11.640
是不是True

28:11.640 --> 28:11.960
对吧

28:12.920 --> 28:13.880
状态值就是True

28:14.680 --> 28:15.160
你看呀

28:15.880 --> 28:17.000
我这里这样子

28:17.000 --> 28:17.880
靠左的一起吧

28:18.440 --> 28:19.640
好来看一下这边

28:19.640 --> 28:21.320
好第二次优势State的时候

28:21.320 --> 28:22.600
那么数组里面没东西

28:22.600 --> 28:23.880
那么状态为True

28:23.880 --> 28:24.360
于是呢

28:24.360 --> 28:25.080
他放到这了

28:25.800 --> 28:26.040
对吧

28:26.040 --> 28:27.080
这就是第一次调用

28:27.080 --> 28:27.720
好第一次调用

28:27.720 --> 28:28.920
开始渲染到节点

28:28.920 --> 28:29.880
渲染出来是什么

28:29.880 --> 28:31.400
那个P是不是可以显示

28:31.400 --> 28:31.960
对不对

28:31.960 --> 28:32.760
因为从

28:32.760 --> 28:34.200
这个变量是哪来的

28:34.200 --> 28:35.640
这个变量是不是就从这来的

28:35.640 --> 28:36.120
对吧

28:36.120 --> 28:37.080
从这个状态值来的

28:37.080 --> 28:38.040
零和True

28:38.040 --> 28:39.880
那么第一次是不是P元素显示

28:39.880 --> 28:41.320
然后这里显示0

28:41.320 --> 28:42.040
对不对

28:42.040 --> 28:43.720
这里显示0

28:43.720 --> 28:44.840
没问题

28:44.920 --> 28:45.400
没问题吧

28:46.200 --> 28:47.000
好这是第一次

28:47.800 --> 28:48.920
好咱们来看第二次

28:49.800 --> 28:50.920
接下来呢

28:50.920 --> 28:51.720
比方说

28:51.720 --> 28:54.040
我们点击了这个显示隐藏

28:54.920 --> 28:55.800
点击到这个

28:55.800 --> 28:56.600
它发生了什么事

28:57.560 --> 28:59.320
点击了之后你看一下

28:59.320 --> 29:00.600
它是不是运行到这个函数

29:00.600 --> 29:01.160
4Gm嘛

29:01.160 --> 29:02.680
哎运行到这个函数

29:02.680 --> 29:03.320
对吧

29:03.320 --> 29:05.000
它运行到这个SetVisible

29:05.000 --> 29:06.440
是不是改变状态值

29:06.440 --> 29:08.440
只要以改变状态值

29:08.440 --> 29:09.960
它一定会重新渲染

29:11.240 --> 29:12.680
状态值被改变之后

29:12.680 --> 29:13.880
它一定会重新渲染

29:14.920 --> 29:16.280
好重新渲染的时候

29:16.280 --> 29:18.120
是不是又较用这个函数

29:18.120 --> 29:18.440
对吧

29:19.400 --> 29:20.520
重新渲染是不是要

29:20.520 --> 29:21.640
我们之前说过函数组件

29:22.360 --> 29:23.560
只要重新渲染

29:23.560 --> 29:24.840
是不是一定会调用这个函数

29:25.800 --> 29:27.960
那么这个时候第二次调用这个函数

29:27.960 --> 29:29.560
是不是要重新运行一遍这个函数

29:30.360 --> 29:30.680
对不对

29:30.680 --> 29:31.720
重新运行一遍这个函数

29:31.720 --> 29:33.080
得到新的节点数

29:33.560 --> 29:34.440
好那么这里呢

29:34.440 --> 29:35.320
重新运行这个函数

29:35.320 --> 29:36.840
你看又来调用Ustate

29:37.720 --> 29:38.120
好

29:38.120 --> 29:39.080
于是是不是又来一遍

29:40.360 --> 29:41.720
第N次调用Ustate

29:41.720 --> 29:42.280
第几次呢

29:42.280 --> 29:44.120
现在是不是第三次

29:44.200 --> 29:45.880
每一次函数调用都是独立的

29:45.880 --> 29:47.800
每一次函数调用都是独立的

29:47.800 --> 29:48.760
于是这里

29:48.760 --> 29:50.600
调用这个App函数

29:50.600 --> 29:51.960
那么这里是第几次调用

29:51.960 --> 29:53.080
是不是第0次

29:53.080 --> 29:53.800
下标为0

29:53.800 --> 29:54.040
对吧

29:54.040 --> 29:55.080
第一次调用

29:55.080 --> 29:55.400
好

29:55.400 --> 29:55.880
第一次调用

29:55.880 --> 29:56.840
现在来看一下

29:56.840 --> 29:58.440
检查该节点的状态数组

29:58.440 --> 30:00.680
是不是存在下标0

30:00.680 --> 30:01.640
是不是已经存在了

30:02.760 --> 30:04.200
这个节点是不是已经存在了

30:04.200 --> 30:05.320
下标为0

30:05.320 --> 30:05.640
好

30:05.640 --> 30:07.000
存在了之后

30:08.360 --> 30:09.640
存在了之后

30:09.640 --> 30:10.520
干嘛呢

30:10.520 --> 30:11.880
刚才是不存在的情况

30:11.880 --> 30:12.840
那么现在说存在

30:13.800 --> 30:14.840
存在的是

30:14.840 --> 30:15.640
之后干嘛呢

30:16.440 --> 30:17.320
忽略掉

30:18.280 --> 30:19.160
默认值

30:19.160 --> 30:20.680
就是默认值没用了

30:20.680 --> 30:22.040
因为这个状态数组已经存在了

30:22.680 --> 30:24.200
这就是为什么第二次调用

30:24.200 --> 30:26.120
它没有又重新给我出指的话

30:26.120 --> 30:27.560
因为它会忽略掉默认值

30:28.440 --> 30:29.480
直接返回

30:30.840 --> 30:32.680
直接得到

30:33.960 --> 30:34.600
状态

30:36.280 --> 30:37.160
指

30:37.160 --> 30:38.360
也就是说这个函数

30:38.360 --> 30:39.480
它返回了状态值

30:39.480 --> 30:41.160
第一个数据不是状态值吗

30:42.120 --> 30:43.480
它这个状态值

30:43.480 --> 30:44.200
这个函数

30:44.200 --> 30:46.120
它会直接从这个表格里边

30:46.120 --> 30:47.320
把个状态值给你

30:47.960 --> 30:48.520
对吧

30:48.520 --> 30:49.480
状态值给你

30:49.480 --> 30:50.280
吃完了

30:50.280 --> 30:52.440
然后对应一个就是

30:52.440 --> 30:53.480
改变状态的函数

30:54.520 --> 30:55.240
另外呢

30:55.240 --> 30:55.640
就是说

30:56.920 --> 30:57.880
第二次调用

30:57.880 --> 30:58.360
你看一下

30:58.360 --> 30:58.920
第二次调用

30:58.920 --> 31:00.200
是不是有这个下标1

31:00.760 --> 31:01.320
对不对

31:01.320 --> 31:02.120
下标1的话

31:02.120 --> 31:04.280
那么它就不会忽略掉这个默认值

31:04.280 --> 31:06.920
那么直接把这个下标1的

31:06.920 --> 31:08.200
状态数据给你返回

31:08.200 --> 31:09.080
那么就返回了2

31:09.640 --> 31:10.200
对不对

31:10.360 --> 31:11.160
返回了2

31:11.160 --> 31:11.960
返回了2

31:11.960 --> 31:12.520
不过呢

31:12.520 --> 31:13.080
现在呢

31:13.080 --> 31:14.760
改变的状态是不是把它变成了Force

31:14.760 --> 31:15.320
对不对

31:15.320 --> 31:16.200
因为我们刚才说一次

31:16.200 --> 31:17.640
为了我是不是把它变成了Force

31:18.360 --> 31:19.480
把它变成了Force

31:19.480 --> 31:21.080
改变的是这个表格里边的数据

31:21.720 --> 31:22.760
改变成了Force

31:22.760 --> 31:24.120
那么这个时候返回的是什么

31:24.120 --> 31:25.000
返回的是Force

31:25.640 --> 31:27.880
然后再得到这个节点数

31:27.880 --> 31:29.080
是不是就变成隐藏了

31:29.960 --> 31:31.240
就这么简单

31:31.240 --> 31:32.600
能听懂这个道理吧

31:32.600 --> 31:33.320
现在隐藏了

31:33.880 --> 31:35.160
然后再点显示

31:35.160 --> 31:35.880
点了过后呢

31:35.880 --> 31:36.600
你看一下

31:36.600 --> 31:37.320
点了过后呢

31:37.320 --> 31:38.920
实际上它改变的是这个

31:39.000 --> 31:40.440
又改变了那个表格里边的数据

31:40.440 --> 31:41.320
改成处

31:41.320 --> 31:43.000
然后呢又重新运行这个函数

31:43.480 --> 31:44.840
重新运行这个函数是不是

31:44.840 --> 31:45.560
之前已经

31:45.560 --> 31:47.240
表格里边已经有状态了

31:47.240 --> 31:49.560
所以说它不会重新去生成状态

31:50.440 --> 31:50.840
因此呢

31:50.840 --> 31:52.600
它会得到之前的状态结果

31:53.000 --> 31:54.440
它会忽略掉默认值

31:54.440 --> 31:55.400
明白的意思吗

31:55.400 --> 31:56.840
所以感觉就很神奇

31:56.840 --> 31:57.880
每次运行这个函数

31:58.520 --> 31:59.880
其实它做的事情是不一样的

31:59.880 --> 32:01.640
你可以认为这个函数里边有个判断

32:01.640 --> 32:02.520
判断表格是否

32:02.520 --> 32:04.120
表格中是否有对应值

32:04.120 --> 32:05.800
没有对应值加入默认值

32:05.800 --> 32:06.920
如果有对应值的话

32:06.920 --> 32:08.040
直接取出就完成了

32:09.160 --> 32:12.920
包括是这些点加点减是一样的道理

32:12.920 --> 32:14.520
你可以自行去分析一下

32:15.320 --> 32:15.960
这就是

32:16.360 --> 32:16.760
hook

32:17.400 --> 32:18.360
它运行的原理

32:20.040 --> 32:21.160
好那么这样子一来

32:21.160 --> 32:22.360
我们再解释另外一个现象

32:23.640 --> 32:24.520
也就是说呢

32:25.320 --> 32:26.280
我们这里呢

32:28.520 --> 32:32.600
如果说我在index里边加了两个app

32:34.200 --> 32:36.520
比方说我这个里边加了两个app

32:37.000 --> 32:37.640
不是一个

32:38.120 --> 32:39.720
他们的状态会不会共享呢

32:40.280 --> 32:41.000
想这么一个道理

32:41.560 --> 32:42.520
它会不会共享

32:42.760 --> 32:44.360
这两个组建的状态会不会共享

32:45.560 --> 32:46.440
会不会共享了

32:47.400 --> 32:48.680
来看一下吧

32:49.160 --> 32:50.040
你看会不会共享

32:50.600 --> 32:52.360
这完全独立的对吧

32:52.360 --> 32:53.320
完全独立的

32:53.320 --> 32:55.000
为什么能实现这一点呢

32:55.000 --> 32:57.240
是因为表格附着在哪的

32:57.240 --> 32:59.080
附着在节点上面的

32:59.640 --> 33:02.120
你建了两个app是不是两个节点

33:02.760 --> 33:03.160
对吧

33:03.720 --> 33:05.720
你建了两个app就是两个节点

33:06.440 --> 33:07.880
虽然说这个东西是共用的

33:07.880 --> 33:09.960
这个东西应该是一个

33:09.960 --> 33:11.400
因为它是同一个函数

33:11.400 --> 33:11.880
函数

33:11.880 --> 33:12.840
同一个函数引用

33:14.520 --> 33:15.880
这个东西是同一个

33:17.160 --> 33:17.640
这个玩意儿

33:19.000 --> 33:19.720
我这样子连

33:22.000 --> 33:22.560
这样子连

33:27.520 --> 33:28.640
其实我这个头一划出来

33:28.640 --> 33:29.760
你应该知道什么意思了

33:30.800 --> 33:33.360
那么他们虽然是用的是同一个函数

33:33.360 --> 33:35.280
但他们的表格是不是两套表格

33:35.840 --> 33:36.240
对吧

33:36.800 --> 33:37.920
是不是两套表格

33:37.920 --> 33:39.680
两套表格各自有各自的状态数

33:39.680 --> 33:40.080
数组

33:40.080 --> 33:41.200
所以说互不干了

33:41.920 --> 33:42.640
互不干擾

33:42.640 --> 33:43.920
你雕用这个组件的

33:43.920 --> 33:45.200
UZDET的时候

33:45.200 --> 33:46.720
它找的是这个表格

33:46.720 --> 33:48.080
雕用这个组件的

33:48.080 --> 33:49.760
节点的UZDET的时候

33:49.760 --> 33:51.360
它在雕用的时候找的是这个表格

33:51.360 --> 33:52.400
表格是不一样的

33:53.200 --> 33:55.120
所以说状态是不会共享的

33:56.080 --> 33:56.880
这个东西

33:56.880 --> 33:59.040
这个图我也不发下来了

33:59.040 --> 33:59.840
也不发下来

33:59.840 --> 34:01.200
大家看这个视频看一下

34:01.200 --> 34:02.480
因为主要是靠理解

34:02.480 --> 34:03.280
你光看这个图

34:03.280 --> 34:04.160
它也不知道我在说啥

34:04.880 --> 34:07.520
所以说大家主要是要理解这个区域

34:07.520 --> 34:09.280
所以说他们是互不干擾的

34:09.440 --> 34:10.560
这就是reactor

34:10.560 --> 34:12.320
它实现这个状态的

34:12.320 --> 34:13.280
在函数组件里面

34:13.280 --> 34:14.800
是用StateHook

34:14.800 --> 34:15.920
它的核心原理

34:17.440 --> 34:17.920
核心原理

34:17.920 --> 34:18.400
就这样子

34:19.120 --> 34:20.560
大家使用这个Hook的时候

34:20.560 --> 34:21.600
头脑里面想象

34:21.600 --> 34:23.600
每个组件它有一个状态数组

34:23.600 --> 34:24.720
来记录这些状态

34:24.720 --> 34:26.720
这就是它为什么可以使用多个状态

34:26.720 --> 34:28.960
以及它为什么可以

34:29.920 --> 34:32.000
每一次交通的时候能用不同的状态

34:32.960 --> 34:34.800
这也解释了为什么

34:34.800 --> 34:35.600
它在这里

34:35.600 --> 34:36.800
它的名字

34:36.800 --> 34:38.400
它用的是UZDET

34:38.480 --> 34:40.000
它用的不是crazy state

34:40.720 --> 34:41.440
crazy是什么

34:42.320 --> 34:44.400
crazy单词表示新建的意思

34:45.120 --> 34:46.720
那这里含义是不是新建

34:46.720 --> 34:47.920
它不一定是新建

34:47.920 --> 34:49.440
只有第一次是新建

34:49.440 --> 34:51.360
后边它就不再新建了

34:51.360 --> 34:52.640
给你得到结果就完事了

34:53.760 --> 34:54.400
没那意思吧

34:55.440 --> 34:57.200
所以说这里叫做UZ

34:57.200 --> 34:57.920
而不是crazy

34:58.560 --> 34:59.520
非常讲究的

34:59.520 --> 35:00.640
这些命名非常讲究的

35:03.280 --> 35:03.920
我们这里

35:05.920 --> 35:07.840
接下来来说一下

35:07.920 --> 35:09.520
使用这个UZDET的时候

35:09.520 --> 35:10.400
与些注意点

35:10.400 --> 35:12.320
这些注意点都跟它的原理有关系

35:13.120 --> 35:14.320
跟它的原理有关系

35:15.200 --> 35:16.480
咱们来挨带来说一下

35:18.400 --> 35:20.880
这个原理我就不写了

35:21.360 --> 35:22.560
大家听明白就行了

35:22.560 --> 35:23.440
听明白就行了

35:24.400 --> 35:25.600
如果有时候你忘了

35:25.600 --> 35:26.480
重新看一下这个视频

35:26.480 --> 35:27.200
听明白就行了

35:28.000 --> 35:28.800
那么就是注意点

35:30.960 --> 35:32.720
注意的细节

35:32.720 --> 35:33.680
这些细节都跟它的

35:34.240 --> 35:36.080
多多少少跟它的原理有关系

35:36.080 --> 35:36.880
咱们挨带来说

35:37.840 --> 35:39.120
好 第一个细节

35:39.520 --> 35:41.360
非常非常重要的

35:42.080 --> 35:42.880
什么细节呢

35:42.880 --> 35:43.520
就是关于

35:46.080 --> 35:46.800
状态

35:48.880 --> 35:50.560
就是UZDET

35:51.440 --> 35:52.240
不可以

35:52.960 --> 35:55.520
就是最好写到

35:56.640 --> 35:58.960
寒树的骑士位置

35:59.840 --> 36:01.360
就是在寒树的一开始

36:01.360 --> 36:02.800
你要使用哪些状态

36:02.800 --> 36:04.080
你最好一开始就写好

36:04.720 --> 36:05.280
这样子

36:05.280 --> 36:06.320
我们一看这个寒树

36:06.560 --> 36:08.160
它用了哪些状态就看得非常明白

36:09.200 --> 36:10.160
主要是边于阅读

36:11.280 --> 36:11.680
这是

36:13.040 --> 36:14.640
边于阅读

36:15.920 --> 36:16.480
第二点

36:17.360 --> 36:18.560
UZDET

36:19.120 --> 36:23.520
严禁出现在判断中

36:24.400 --> 36:27.120
严禁出现在判断循环中

36:28.720 --> 36:29.840
或者叫做代码块中

36:31.940 --> 36:32.660
代码块

36:34.020 --> 36:34.980
比方判断

36:34.980 --> 36:36.100
循环在这里边

36:36.100 --> 36:37.140
严禁出现在这里边

36:37.620 --> 36:38.820
为什么严禁出现

36:39.780 --> 36:40.820
跟它的原理有关系

36:41.380 --> 36:42.100
比方说

36:42.740 --> 36:43.380
我举个例子

36:45.330 --> 36:46.210
我们这里写成一个

36:47.410 --> 36:48.050
三个来说

36:49.570 --> 36:50.930
为什么不能出现在判断里面

36:51.650 --> 36:51.970
好

36:51.970 --> 36:53.170
比方说举个例子

36:54.290 --> 36:54.690
看着

36:56.790 --> 36:57.110
if

36:59.670 --> 37:00.230
这样子吧

37:01.750 --> 37:02.230
这样子

37:04.390 --> 37:07.510
我们这里加上一个状态

37:07.510 --> 37:07.990
判断

37:08.550 --> 37:10.070
判断了什么呢

37:10.070 --> 37:10.790
判断

37:11.910 --> 37:12.710
这样吧

37:12.710 --> 37:13.590
我这个写下来

37:15.350 --> 37:15.670
if

37:17.510 --> 37:18.230
visible

37:18.230 --> 37:20.310
如果它为q的话

37:20.310 --> 37:22.070
我们新增一个状态

37:22.070 --> 37:23.030
新增一个状态

37:24.390 --> 37:25.430
名字叫做

37:25.430 --> 37:25.990
set

37:26.550 --> 37:26.950
set

37:27.990 --> 37:28.790
我们用挖嘛

37:29.270 --> 37:30.470
挖的话有个变量提升

37:31.510 --> 37:31.830
就是

37:33.750 --> 37:34.150
set

37:34.630 --> 37:35.190
不

37:35.190 --> 37:36.150
UZDET

37:38.150 --> 37:39.030
UZDET

37:41.430 --> 37:41.750
DETA

37:42.470 --> 37:42.870
DETA

37:43.430 --> 37:44.870
初始值是10

37:45.830 --> 37:46.710
举个例子

37:46.710 --> 37:47.590
举个例子

37:47.590 --> 37:48.230
UZDET

37:49.030 --> 37:51.830
其他之前就已经给你爆错了

37:51.830 --> 37:52.310
爆错了

37:53.110 --> 37:54.790
当然咱们就强行写吧

37:54.790 --> 37:55.750
咱们就强行写

37:56.710 --> 37:58.230
这里再加上一个

37:59.510 --> 38:00.630
再加上一个必原数

38:00.630 --> 38:01.350
显示DETA

38:03.860 --> 38:04.420
显示DETA

38:06.820 --> 38:08.100
看一下会有什么样的问题

38:08.740 --> 38:09.860
这里把它写成挖嘛

38:10.500 --> 38:11.460
会有什么样的问题

38:11.460 --> 38:12.260
保存看一下

38:13.220 --> 38:13.460
不行

38:14.020 --> 38:15.460
根本不当你这样做

38:15.460 --> 38:16.980
它为什么不当你这样做呢

38:17.700 --> 38:18.900
大家看一下它的原理

38:19.540 --> 38:20.340
它现在是这样子

38:21.460 --> 38:23.860
比方说它现在第一次调用

38:25.300 --> 38:26.260
第一次调用这个函数

38:27.540 --> 38:28.420
是不是没有下标

38:28.420 --> 38:28.740
对吧

38:28.740 --> 38:29.940
下标全是没有的

38:30.500 --> 38:30.740
好

38:30.740 --> 38:31.380
那么我们这里

38:31.940 --> 38:32.740
这样子写

38:32.740 --> 38:33.860
第一次调用的时候

38:33.860 --> 38:34.420
vivable

38:35.220 --> 38:36.260
是不是在第一个状态

38:36.260 --> 38:36.500
对吧

38:36.500 --> 38:37.540
调用了UZDET

38:37.540 --> 38:39.060
调用了UZDET

38:39.060 --> 38:39.700
那么这里呢

38:40.020 --> 38:40.980
下标为0的位置

38:40.980 --> 38:42.100
是不是一个q

38:42.100 --> 38:42.580
对吧

38:42.580 --> 38:43.140
是一个q

38:43.780 --> 38:44.180
对不对

38:44.820 --> 38:45.700
下标为0的位置

38:45.700 --> 38:46.500
使用默认字

38:46.500 --> 38:47.700
生成一个新的状态

38:48.580 --> 38:48.820
好

38:48.820 --> 38:49.140
于是呢

38:49.140 --> 38:50.580
这判断vivable为q

38:50.580 --> 38:52.500
vivable为q的时候呢

38:52.500 --> 38:54.180
那么现在是不是又调用了一次

38:54.180 --> 38:54.580
对吧

38:54.580 --> 38:55.620
第二次调用

38:55.620 --> 38:56.260
于是呢

38:56.260 --> 38:57.860
下标唯一的位置

38:57.860 --> 38:58.900
它写了一个什么呢

38:58.900 --> 39:00.660
写了一个就是10

39:01.780 --> 39:02.580
写了一个10

39:03.540 --> 39:05.300
所以已经发现一个问题了

39:05.300 --> 39:05.540
好

39:05.540 --> 39:06.260
接下来再来

39:07.220 --> 39:07.780
然后呢

39:07.780 --> 39:08.660
现在下标

39:08.660 --> 39:10.260
再调用第三次调用了

39:10.260 --> 39:11.380
那么默认字是0

39:12.180 --> 39:12.900
第三次调用

39:13.940 --> 39:14.820
默认字是0

39:15.860 --> 39:16.660
能看清楚吗

39:18.820 --> 39:20.260
现在状态数数是不是这样子

39:21.300 --> 39:23.380
假设它允许你这样做

39:23.380 --> 39:24.340
会发生什么问题

39:24.900 --> 39:25.940
如果当将来

39:25.940 --> 39:27.060
我点击这个按钮

39:27.060 --> 39:27.860
显示隐藏

39:28.420 --> 39:29.060
点了之后

39:29.060 --> 39:30.100
是不是把这个vivable

39:30.820 --> 39:31.540
把第一个

39:32.100 --> 39:33.460
第一个字设为了forced

39:33.460 --> 39:34.100
对吧

39:34.100 --> 39:35.220
第一个字设为了forced

39:35.860 --> 39:36.100
好

39:36.100 --> 39:37.620
于是重新运行这个函数

39:38.340 --> 39:39.300
重运运行的时候

39:39.300 --> 39:40.020
你看就要出问题了

39:40.740 --> 39:41.300
什么问题呢

39:41.300 --> 39:41.860
第一次

39:41.860 --> 39:43.220
第一次调用Ustata

39:43.780 --> 39:44.660
那么我们看一下

39:44.660 --> 39:46.100
有没有对应的0呢

39:46.100 --> 39:46.740
发现有

39:46.740 --> 39:47.060
OK

39:47.060 --> 39:47.460
没问题

39:47.460 --> 39:48.500
我得到一个forced

39:48.500 --> 39:49.540
把这个forced给谁

39:49.540 --> 39:50.100
给vivable

39:51.220 --> 39:51.460
好

39:51.460 --> 39:53.380
那么判断vivable是判断不成功

39:53.380 --> 39:54.260
判断不成功

39:54.260 --> 39:55.540
这个衣服判断进不去

39:55.540 --> 39:55.860
好

39:55.860 --> 39:56.900
那么这再调用

39:56.900 --> 39:57.940
是不是第二次调用现在

39:58.660 --> 39:59.700
之前是第三次调用

39:59.700 --> 40:01.060
现在变成第二次调用了

40:01.060 --> 40:02.580
第二次调用就看什么

40:02.580 --> 40:04.100
看下标1这个位置

40:04.820 --> 40:06.500
那么它就会把下标1这个位置

40:06.660 --> 40:08.100
实附这个n

40:09.220 --> 40:10.420
就不导致出问题了

40:10.420 --> 40:11.380
状态不对硬了

40:12.580 --> 40:13.540
所以说

40:13.540 --> 40:15.620
它是绝对不能出现在

40:15.620 --> 40:16.980
判断什么循环里边的

40:16.980 --> 40:18.500
因为循环也危险

40:18.500 --> 40:19.300
循环的话

40:19.300 --> 40:20.260
因为它会

40:20.260 --> 40:21.860
你不知道它循环多少次

40:21.860 --> 40:23.460
它循环多少次是不一定的

40:23.460 --> 40:24.260
所以说

40:24.260 --> 40:25.380
你不要出现在这里边

40:26.260 --> 40:27.780
应该是并排来写

40:28.340 --> 40:28.980
并排来写

40:29.860 --> 40:30.500
没有这意思啊

40:31.380 --> 40:32.100
OK

40:32.100 --> 40:34.100
这你能把这个说清楚就行了

40:34.100 --> 40:35.220
这是这个注意点

40:35.300 --> 40:37.540
千万不要写在判断里边去了

40:37.540 --> 40:38.980
这是第二个叫注意的细节

40:40.980 --> 40:41.540
下一个点

40:42.260 --> 40:43.540
下一个点的话就是

40:44.340 --> 40:46.420
好像也不是什么注意的细节

40:46.420 --> 40:47.780
也不是什么注意箱

40:47.780 --> 40:48.820
它是这样子

40:48.820 --> 40:50.340
它说这个U字state

40:51.700 --> 40:53.540
返回的函数

40:54.660 --> 40:55.780
返回的函数

40:55.780 --> 40:57.300
它不是返回两个东西吗

40:57.300 --> 40:58.180
一个是数据

40:58.180 --> 40:58.580
对吧

40:59.860 --> 41:01.060
一个是不是函数

41:01.060 --> 41:01.940
对不对

41:01.940 --> 41:02.980
返回的函数

41:02.980 --> 41:04.420
就是数组的第二项

41:04.500 --> 41:05.620
数组的第二项

41:08.100 --> 41:08.900
引用不变

41:09.780 --> 41:10.740
引用不变

41:10.740 --> 41:12.340
它是为了提高

41:13.220 --> 41:15.380
就是节约内存空间

41:16.020 --> 41:17.300
它是为了节约内存空间

41:17.300 --> 41:18.740
因为你每次创建一个新的

41:18.740 --> 41:20.340
它每次去创建一个新的函数

41:20.340 --> 41:22.100
会导致额外的内存出现

41:22.100 --> 41:22.420
对吧

41:22.420 --> 41:23.700
它没有必要每次于新建

41:23.700 --> 41:25.380
就返回之前的函数就行了

41:25.380 --> 41:27.300
因为函数它不会变化的

41:27.300 --> 41:28.420
没有必要让它变化

41:28.900 --> 41:30.660
那么怎么来验证这个点呢

41:30.660 --> 41:31.940
我们可以这样做吗

41:32.900 --> 41:33.940
我们可以这样做

41:34.020 --> 41:34.980
我这里能写个数组

41:36.020 --> 41:36.740
写个数组

41:36.740 --> 41:37.780
写到外面

41:37.780 --> 41:39.380
然后每次执行

41:39.380 --> 41:40.420
不是得到一个函数吗

41:40.420 --> 41:41.780
比方就是setn嘛

41:41.780 --> 41:43.140
我们把它加到数组里边去

41:43.940 --> 41:44.900
加到这个数组里边去

41:44.900 --> 41:46.900
这个数组干脆放到window里边

41:46.900 --> 41:48.260
window.arr

41:49.460 --> 41:51.620
那么这个window.arr

41:51.620 --> 41:52.260
poohy

41:52.260 --> 41:53.140
poohy什么呢

41:53.140 --> 41:53.700
setn

41:55.780 --> 41:56.100
对吧

41:56.100 --> 41:57.220
把这个函数放进去

41:57.220 --> 41:58.660
放到这个数组里边去

41:58.660 --> 41:59.460
保存看一下

42:00.420 --> 42:01.540
接下来我们检查一下

42:02.500 --> 42:03.860
然后我们这里

42:04.580 --> 42:06.100
现在的数组里面肯定有东西了

42:06.100 --> 42:07.380
因为第一次它已经调用了

42:07.380 --> 42:08.020
对吧

42:08.020 --> 42:08.580
ar

42:09.300 --> 42:10.820
你看一下是不是一个函数了

42:10.820 --> 42:11.220
对吧

42:11.220 --> 42:13.220
然后我们再加1加1加1

42:13.220 --> 42:13.940
点了三次

42:13.940 --> 42:14.900
再看这个数组

42:14.900 --> 42:16.180
所以有四个函数了

42:16.180 --> 42:16.340
好

42:16.340 --> 42:17.460
咱们来看一下这个数组的函数

42:17.460 --> 42:18.500
是不是一样的地址

42:19.060 --> 42:20.740
是不是等于ar1

42:20.740 --> 42:21.860
你看一下就是ch

42:21.860 --> 42:22.740
对吧

42:22.740 --> 42:23.540
就这么个意思

42:23.540 --> 42:24.580
后边全是相等的

42:24.580 --> 42:25.780
它是为了解决内存空间

42:25.780 --> 42:26.900
这个好理解吧

42:26.900 --> 42:27.460
对不对

42:27.460 --> 42:28.660
这个对我们写代嘛

42:28.660 --> 42:29.700
也没有什么意义

42:29.700 --> 42:30.580
就是说一下这个点

42:31.620 --> 42:31.780
好吧

42:31.780 --> 42:32.740
这是关于这个点

42:33.380 --> 42:33.620
好

42:33.620 --> 42:34.180
另外一个

42:34.180 --> 42:35.380
下面细节还是蛮多的

42:36.100 --> 42:37.780
如果说使用函数

42:38.500 --> 42:41.140
当如果使用函数

42:42.420 --> 42:43.540
改变数据

42:45.920 --> 42:52.560
若数据和之前的数据完全相等

42:53.360 --> 42:54.160
完全相等

42:54.800 --> 42:55.840
什么叫完全相等呢

42:55.840 --> 42:56.720
它是使用

42:56.720 --> 42:57.760
使用object

42:58.400 --> 42:59.680
使用object

42:59.680 --> 43:01.040
意义比较

43:01.040 --> 43:02.480
比较两个数据是不是相等的

43:03.120 --> 43:04.560
如果相等的话

43:04.560 --> 43:06.800
不会导致重新宣展

43:06.800 --> 43:08.640
这个东西跟那个

43:08.640 --> 43:10.960
跟那个就是内组件就不一样了

43:10.960 --> 43:12.320
内组件里边是不是

43:12.320 --> 43:14.320
只要你调用了set state

43:14.320 --> 43:16.160
哪怕你传了一个空队向进去

43:16.160 --> 43:17.040
它都会重新宣展

43:17.040 --> 43:17.600
对吧

43:17.600 --> 43:18.000
但是呢

43:18.000 --> 43:18.480
这个不会

43:19.600 --> 43:21.600
如果两个数据完全一样

43:21.600 --> 43:22.800
它就不会导致重新宣展

43:22.800 --> 43:23.280
比方说

43:24.160 --> 43:24.880
我们这里呢

43:26.080 --> 43:27.200
set variable的时候

43:27.200 --> 43:28.080
不取反

43:28.080 --> 43:29.040
不取反

43:29.040 --> 43:30.080
这里还是复制一下吧

43:31.680 --> 43:32.560
如果我不取反

43:32.560 --> 43:33.840
就是使用之前的variable

43:34.560 --> 43:35.680
如果是这样子

43:35.680 --> 43:36.240
我们来看一下

43:36.240 --> 43:37.280
它会不会重新宣展

43:39.560 --> 43:40.200
这里呢

43:40.200 --> 43:41.400
我们在这里输出一句话

43:43.720 --> 43:45.160
app render

43:46.120 --> 43:47.480
渲染这个app组件

43:47.480 --> 43:49.000
它会不会调用这个函数重新宣展

43:49.800 --> 43:51.000
就因为像这些函数

43:51.000 --> 43:52.680
它跟set state有类似的功能

43:52.680 --> 43:52.920
对吧

43:52.920 --> 43:53.480
一调用它

43:53.480 --> 43:54.520
它就会重新宣展

43:54.520 --> 43:54.920
但是呢

43:54.920 --> 43:57.080
如果它的值跟之前的值是一样的

43:57.080 --> 43:58.280
之前的值为q嘛

43:58.280 --> 43:58.680
对吧

43:58.680 --> 43:59.960
你再调用它的时候

43:59.960 --> 44:01.160
如果两个值相等

44:01.160 --> 44:02.120
它不会重新宣展

44:02.840 --> 44:03.560
接下来

44:03.560 --> 44:04.360
第一次重新宣展了

44:04.360 --> 44:04.840
对吧

44:04.840 --> 44:05.560
第一次宣展了

44:05.560 --> 44:06.440
因为它要显示

44:07.000 --> 44:07.960
然后我们现在点这个

44:07.960 --> 44:08.360
你看一下

44:08.360 --> 44:09.480
是不是没有运行了

44:09.480 --> 44:10.920
没有运行的轮点方法

44:10.920 --> 44:11.160
对吧

44:11.720 --> 44:12.840
所以它没有重新宣展

44:12.840 --> 44:13.080
对吧

44:13.080 --> 44:14.600
因为它觉得没有必要

44:14.600 --> 44:16.200
两个状态都是一致的

44:16.200 --> 44:17.000
没有必要

44:17.000 --> 44:18.520
所以它不会进行重新宣展

44:19.400 --> 44:20.040
没什么意思吧

44:21.160 --> 44:22.520
所以以达到

44:22.520 --> 44:23.640
以达到

44:23.640 --> 44:24.440
效

44:24.440 --> 44:25.000
以达到

44:26.760 --> 44:27.320
优化

44:28.520 --> 44:29.800
以达到

44:30.360 --> 44:31.000
优化

44:32.040 --> 44:33.160
效率的目的

44:34.520 --> 44:35.000
好

44:35.000 --> 44:35.800
这是关于这个点

44:37.240 --> 44:37.480
好

44:37.480 --> 44:38.200
第五个点

44:38.760 --> 44:40.920
第五个点要特别特别注意的

44:41.880 --> 44:43.960
就是使用韩数

44:45.640 --> 44:46.920
改变数据

44:46.920 --> 44:48.840
当你使用韩数改变数据的时候

44:50.120 --> 44:51.400
那么这个时候呢

44:51.400 --> 44:52.680
传入的值

44:53.800 --> 44:54.440
传入的值

44:54.440 --> 44:55.720
就是你传入的新数据

44:55.720 --> 44:56.520
就这个数据

44:56.520 --> 44:57.480
你不是要改变数据吗

44:57.480 --> 44:58.360
传入一个新的值

44:59.000 --> 44:59.800
传入的值

45:02.200 --> 45:02.840
不会

45:03.800 --> 45:04.520
和

45:04.520 --> 45:06.440
原来的数据

45:06.440 --> 45:07.720
进行合并

45:07.720 --> 45:09.160
它不会进行合并

45:09.160 --> 45:11.000
而是直接替换

45:12.200 --> 45:14.040
而是直接替换原来的数据

45:14.040 --> 45:15.240
它跟那个setState不一样

45:15.240 --> 45:16.840
setState是不是合并

45:16.840 --> 45:17.320
混合

45:17.320 --> 45:17.960
对吧

45:17.960 --> 45:19.960
你不要说状态里边有10条数据

45:19.960 --> 45:21.160
你只改变其中一条

45:21.160 --> 45:21.880
对不对

45:21.880 --> 45:22.760
只改变其中一条

45:22.760 --> 45:24.200
那么它会把这一条数据

45:24.200 --> 45:26.200
混合到之前的数据里边

45:26.200 --> 45:27.880
但是又是set不会

45:28.520 --> 45:29.560
为什么它不会呢

45:30.440 --> 45:31.640
如果你有这么多数据的话

45:31.640 --> 45:32.760
它建议你分开

45:32.760 --> 45:33.160
切分

45:33.800 --> 45:34.680
对它进行切分

45:34.680 --> 45:35.560
而不要放在一起

45:36.520 --> 45:39.640
就是不同逻辑上是不一样的数据

45:39.640 --> 45:40.680
你把它切分开

45:40.680 --> 45:42.040
逻辑上是一样的数据

45:42.040 --> 45:43.000
是一个整体的话

45:43.000 --> 45:43.880
你把它合并

45:43.880 --> 45:45.160
Lexo又可以

45:45.160 --> 45:46.040
但是它到时候

45:46.760 --> 45:48.840
传入的值会直接把原来的数据改变

45:49.560 --> 45:50.280
什么意思呢

45:50.280 --> 45:51.400
给大家举个例子

45:51.400 --> 45:52.280
我们再复制一个

45:53.320 --> 45:53.960
给大家举个例子

45:55.160 --> 45:56.280
比方说吧

45:57.160 --> 45:58.840
我们这里使用状态的时候

45:58.840 --> 45:59.480
这样子使用

46:00.600 --> 46:01.880
就随便写一个吧

46:01.880 --> 46:02.200
Data

46:02.920 --> 46:04.120
setData

46:06.800 --> 46:07.600
这里的数据

46:07.600 --> 46:08.240
我们用对象

46:09.040 --> 46:12.800
对象x1y等于2

46:12.800 --> 46:13.760
就随便写一个

46:13.760 --> 46:14.320
下写一个

46:15.280 --> 46:17.120
这里边我们就这样吧

46:19.920 --> 46:20.400
这里边

46:21.440 --> 46:22.000
显示

46:24.160 --> 46:28.080
x为data.x

46:28.080 --> 46:28.480
对吧

46:28.480 --> 46:29.360
它得到一个对象了

46:29.360 --> 46:30.000
对不对

46:30.000 --> 46:31.440
得到一个对象了

46:31.440 --> 46:32.160
data.x

46:32.800 --> 46:33.280
y呢

46:34.080 --> 46:35.280
因为我们把它放到对象里边了

46:35.600 --> 46:36.480
data.y

46:38.560 --> 46:38.800
好

46:38.800 --> 46:40.160
然后我们现在改变状态

46:41.040 --> 46:41.200
好

46:41.200 --> 46:42.960
现在我们setData改变状态

46:45.040 --> 46:46.320
这里是x加1

46:47.840 --> 46:49.520
那么这里怎么来设置x加1呢

46:50.080 --> 46:51.200
比方说我们这里

46:51.680 --> 46:52.400
这样子设置

46:53.600 --> 46:55.120
如果x等于什么呢

46:55.120 --> 46:57.360
等于data.x加1

46:57.360 --> 46:57.680
对吧

46:57.680 --> 46:58.240
x加1

46:58.240 --> 46:59.280
看一下会不会有问题

47:00.320 --> 47:01.760
看一下会不会有问题

47:01.760 --> 47:02.160
保存

47:02.880 --> 47:03.280
看一下吧

47:03.840 --> 47:04.400
x加1

47:05.520 --> 47:06.320
y是不是没了

47:07.280 --> 47:08.080
y跑哪去了

47:08.640 --> 47:09.360
y是不是没了

47:09.920 --> 47:11.280
为什么会这样子呢

47:11.280 --> 47:12.320
你看一下这里原理

47:12.880 --> 47:13.680
那么现在呢

47:13.680 --> 47:14.800
下标为0的位置

47:14.800 --> 47:16.000
一开始是不是个对象

47:16.000 --> 47:16.560
对吧

47:16.560 --> 47:18.480
这个对象x是等于1

47:18.480 --> 47:19.520
y等于2

47:19.520 --> 47:20.240
对不对

47:20.240 --> 47:21.520
对象一开始是这个样子

47:22.080 --> 47:22.640
然后呢

47:22.640 --> 47:24.000
现在我们点击这个按钮

47:24.000 --> 47:24.560
点了过后

47:24.560 --> 47:25.920
我们给它创了一个新的对象

47:26.960 --> 47:28.560
它不会进行混合

47:28.560 --> 47:30.400
它是直接把这个对象就扔过去了

47:31.440 --> 47:31.920
于是呢

47:31.920 --> 47:32.960
第二次改变之后

47:33.600 --> 47:34.400
改变的是什么呢

47:34.480 --> 47:36.320
它就直接改变成这个对象了

47:36.320 --> 47:37.120
x等于2

47:38.160 --> 47:39.200
它是这样子改变的

47:39.840 --> 47:41.040
这样子改变的

47:41.040 --> 47:41.600
所以说呢

47:41.600 --> 47:42.640
这就导致了什么呢

47:42.640 --> 47:44.000
导致了y不见了

47:44.960 --> 47:45.600
所以因此呢

47:45.600 --> 47:46.800
这一点大家要特别注意

47:47.200 --> 47:48.240
就说如果了

47:48.240 --> 47:49.920
这两个数据是不相干的

47:49.920 --> 47:52.240
你应该全把它整体分开

47:52.240 --> 47:53.120
然后写成这样子

47:54.240 --> 47:56.160
use state x

47:58.000 --> 47:59.280
然后这里写上1

47:59.280 --> 47:59.920
对吧

47:59.920 --> 48:00.720
完全把它分开

48:01.520 --> 48:03.040
然后再use state

48:03.040 --> 48:04.000
这才是正确的做法

48:04.480 --> 48:04.960
y

48:05.600 --> 48:06.720
那么这里写上2

48:06.720 --> 48:07.120
对吧

48:07.120 --> 48:08.160
那么这里改变x

48:08.160 --> 48:09.040
就是sets x

48:09.440 --> 48:10.240
就是sets x

48:11.040 --> 48:12.720
x等于啥呢

48:12.720 --> 48:15.120
等于x加1

48:15.120 --> 48:15.600
对吧

48:15.600 --> 48:16.800
应该是用这种方式来做

48:18.560 --> 48:19.840
如果说这两个数据

48:19.840 --> 48:21.040
它确实应该是

48:21.040 --> 48:22.080
比方说它是个坐标

48:22.080 --> 48:23.440
x y是一个坐标

48:23.440 --> 48:24.880
那么它确实是一个整体

48:24.880 --> 48:26.480
应该用一个对象来表示的话

48:26.480 --> 48:27.440
你应该这样子写

48:28.320 --> 48:30.320
你产生了这个新对象了

48:30.320 --> 48:31.280
产生了这个新对象

48:31.840 --> 48:32.240
应该

48:33.200 --> 48:34.560
把原来的对象展开

48:35.200 --> 48:37.040
然后覆盖掉它这个x数据

48:37.760 --> 48:38.880
应该用这种方式来写

48:39.440 --> 48:40.720
这样子才不会有问题

48:40.720 --> 48:42.000
因为原来数据展开之后

48:42.000 --> 48:43.280
它就包含了x而y

48:43.280 --> 48:45.120
然后再把x的纸给它覆盖掉

48:45.120 --> 48:45.360
对吧

48:45.360 --> 48:46.960
用展开为运算符

48:46.960 --> 48:48.000
应该用这种方式写

48:49.200 --> 48:49.920
这里

48:49.920 --> 48:50.880
点击点击点击

48:51.680 --> 48:52.400
现在没问题了

48:53.280 --> 48:53.680
注意啊

48:54.160 --> 48:54.480
就

48:55.200 --> 48:56.480
特别注意对象这一块

48:56.480 --> 48:57.840
跟那个sets data是不一样的

48:57.840 --> 48:58.560
它不是混合

48:58.560 --> 48:59.360
是直接替换

49:00.000 --> 49:00.720
是直接替换

49:02.720 --> 49:02.880
好

49:02.880 --> 49:03.680
那么这里呢

49:06.160 --> 49:06.800
说一个点

49:07.600 --> 49:08.000
就是说

49:08.640 --> 49:11.280
千万跟那个rex之前那组件一样

49:11.280 --> 49:14.240
千万不要去直接改变对象

49:14.240 --> 49:15.920
千万千万不要去这样做

49:16.480 --> 49:17.840
千万不要直接改变对象

49:19.120 --> 49:19.680
因为

49:19.680 --> 49:21.360
这是不符合理念的

49:21.360 --> 49:21.760
就是

49:23.200 --> 49:24.880
就是rex组件的理念

49:24.880 --> 49:26.560
rex它始终坚信

49:27.040 --> 49:28.000
一个组件

49:28.000 --> 49:29.360
它应该保持存进

49:29.360 --> 49:30.960
它的数据应该保持存进

49:31.040 --> 49:32.800
如果你要改变数据的话

49:32.800 --> 49:33.680
应该改变的

49:33.680 --> 49:35.200
应该得到的是一个新的数据

49:36.160 --> 49:37.680
之前的如果是个对象的话

49:37.680 --> 49:39.440
它的数据是不可变的

49:39.440 --> 49:40.480
你不要去这样做

49:40.480 --> 49:41.200
不要去这样做

49:42.080 --> 49:43.440
而且这样做了也容易

49:43.440 --> 49:44.720
特别容易导致bug

49:44.720 --> 49:46.240
特别容易导致bug

49:46.240 --> 49:47.360
不要去这样做就完事了

49:48.240 --> 49:50.560
跟那个rex的那个道理

49:50.560 --> 49:52.400
能力组件的道理一样的

49:52.400 --> 49:53.040
它是

49:53.040 --> 49:54.720
后面如果要有优化的话

49:54.720 --> 49:55.520
不便于优化

49:56.400 --> 49:56.640
好

49:56.640 --> 49:57.120
这是这一块

49:58.320 --> 49:58.560
好

49:58.560 --> 49:59.200
另外呢

49:59.520 --> 50:01.760
根据之前的特点

50:01.760 --> 50:02.800
这么一种特点的话

50:02.800 --> 50:04.720
如果要实现

50:04.720 --> 50:08.720
如果要实现强制刷新

50:08.720 --> 50:12.320
如果要实现强制刷新组件

50:12.320 --> 50:15.520
那么这种情况该怎么来做呢

50:15.520 --> 50:17.360
在内组件中

50:17.360 --> 50:19.120
内组件我们之前没讲过

50:19.120 --> 50:19.280
对吧

50:19.280 --> 50:20.720
使用那个函数

50:20.720 --> 50:27.700
使用ForceUpdate函数

50:27.700 --> 50:28.580
对吧

50:28.580 --> 50:29.940
它可以进行强制刷新

50:30.500 --> 50:31.300
之前没讲过

50:31.300 --> 50:32.100
现在把提一下

50:32.100 --> 50:34.180
因为这种情况遇到太少了

50:34.180 --> 50:35.860
rex也不推荐你这么去做

50:35.860 --> 50:37.620
不推荐你去强制刷新

50:37.620 --> 50:39.220
如果你要用强制刷新的话

50:39.220 --> 50:40.660
那如果你是个内组件的话

50:42.020 --> 50:43.300
那么如果你要强制刷新

50:43.300 --> 50:44.260
比较说一个按钮

50:44.260 --> 50:44.980
点了过后呢

50:44.980 --> 50:45.780
我啥都不想干

50:45.780 --> 50:46.340
就想强

50:46.340 --> 50:47.620
就想刷新一次这个组件

50:48.580 --> 50:49.860
强制刷新

50:51.300 --> 50:51.780
如果说

50:53.860 --> 50:55.300
要强制刷新的话

50:55.300 --> 50:56.260
那么这里点击

50:56.900 --> 50:57.380
onclick

50:59.140 --> 50:59.620
onclick

51:00.260 --> 51:01.540
那么就怎么来刷新呢

51:01.540 --> 51:04.180
thisForceUpdate

51:04.180 --> 51:04.500
对吧

51:04.500 --> 51:05.620
就是强制刷新

51:05.620 --> 51:08.020
那么强制让那个组件运行Render

51:08.020 --> 51:08.980
那么强制刷新

51:08.980 --> 51:09.780
它有这么一个特点

51:09.780 --> 51:11.460
这里打个注射说一下

51:11.460 --> 51:13.060
因为之前没讲过

51:13.060 --> 51:15.540
因为基本上基本上是不会用的

51:15.540 --> 51:18.980
它的生命周期里面是这样子的

51:18.980 --> 51:20.900
如果你是强制刷新的话

51:20.900 --> 51:21.780
它不会运行这个

51:22.660 --> 51:24.740
不会运行suitComponentUpdate

51:24.740 --> 51:25.860
因为你都强制刷新了

51:25.860 --> 51:28.500
我还要判断你到底要不要渲染嘛

51:28.500 --> 51:29.300
对不对

51:29.380 --> 51:31.380
所以说不会运行

51:31.380 --> 51:32.260
不会运行

51:32.260 --> 51:33.220
不会运行什么呢

51:33.220 --> 51:34.980
suitComponentUpdate

51:34.980 --> 51:35.860
如果是强制刷新

51:36.580 --> 51:37.540
这是强制刷新

51:40.020 --> 51:41.220
强制重新渲染

51:42.100 --> 51:43.300
这是内组件的方式

51:44.660 --> 51:46.980
函数组件它没有这种方式

51:46.980 --> 51:48.820
函数组件就是用Ustate的话

51:48.820 --> 51:51.540
它没有让函数组件强制重新刷新

51:51.540 --> 51:52.820
那么它是对比咋

51:52.820 --> 51:54.820
对比你的set这个函数

51:54.820 --> 51:56.260
它里面传入的东西

51:56.260 --> 51:59.460
到底是不是之前的那个东西

51:59.460 --> 52:02.260
如果你说有些某些特殊情况下

52:02.260 --> 52:03.780
如果你要强制刷新的话

52:04.420 --> 52:05.700
强制刷新

52:05.700 --> 52:06.820
就是函数组件

52:08.420 --> 52:13.220
可以使用一个空对向的Ustate

52:13.220 --> 52:14.340
什么意思呢

52:14.340 --> 52:14.820
什么意思呢

52:14.820 --> 52:15.540
我这里没法

52:15.540 --> 52:16.580
因为要写代嘛

52:16.580 --> 52:17.700
我这里没法演示

52:17.700 --> 52:19.700
你可以换一种方式来得到

52:21.060 --> 52:21.700
比方说

52:22.660 --> 52:23.780
我们这里用这种方式吧

52:24.900 --> 52:25.380
Const

52:26.100 --> 52:26.580
这里呢

52:27.380 --> 52:28.500
useness

52:28.500 --> 52:29.220
没用的数据

52:29.300 --> 52:30.180
这个数据是没用的

52:31.300 --> 52:31.940
这里面呢

52:32.580 --> 52:33.220
没用的数据

52:33.220 --> 52:34.340
我们是不是可以不用辨量

52:34.340 --> 52:34.820
对吧

52:34.820 --> 52:35.540
直接用第二个

52:36.180 --> 52:37.940
就是ForceUpdate

52:38.660 --> 52:39.620
比方说我们写个辨量

52:39.620 --> 52:40.820
来接收它的函数

52:42.020 --> 52:43.060
这个Ustate呢

52:43.060 --> 52:44.820
我们直接用一个空函数

52:44.820 --> 52:45.780
直接用一个空函数

52:46.820 --> 52:47.220
对吧

52:47.220 --> 52:47.700
空对向

52:48.100 --> 52:48.580
空对向

52:49.140 --> 52:50.660
那么这样子一来呢

52:50.660 --> 52:51.700
如果说我们要强制

52:53.540 --> 52:54.260
这样子最好报

52:54.740 --> 52:55.220
还是把

52:56.820 --> 52:57.780
这样子等一下

52:57.860 --> 52:59.540
我们把这个数据不能扔掉

52:59.940 --> 53:00.660
复制粘贴一个

53:02.020 --> 53:03.620
这个数据里边这个不要了

53:06.020 --> 53:07.140
如果说要强制刷新啊

53:07.140 --> 53:07.540
现在看

53:08.180 --> 53:08.900
那么这里呢

53:08.900 --> 53:10.100
我们就用这个不要

53:10.100 --> 53:11.460
不要第一个

53:11.460 --> 53:12.660
第一个数据的第一项

53:12.660 --> 53:13.060
我们不要

53:13.060 --> 53:13.940
要第一项干嘛呢

53:13.940 --> 53:14.260
没用

53:14.900 --> 53:15.620
第二个呢

53:15.620 --> 53:17.060
是一个函数给他取个名字

53:17.060 --> 53:18.180
这个函数给他取个名字

53:18.180 --> 53:18.980
ForceUpdate

53:20.420 --> 53:21.060
那么这样子

53:21.620 --> 53:22.180
它的数据呢

53:22.180 --> 53:22.900
就是个空对向

53:23.860 --> 53:25.780
如果说我们要强制刷新

53:25.780 --> 53:26.740
这个要强制刷新

53:29.300 --> 53:30.660
强制刷新

53:31.300 --> 53:31.940
那么这样子

53:31.940 --> 53:33.060
我们这样子来玩

53:33.620 --> 53:34.900
ForceUpdate

53:36.420 --> 53:37.780
写个空对向就行了

53:37.780 --> 53:40.340
为什么这样子可以实现强制刷新呢

53:40.340 --> 53:41.860
因为你每一传的对象

53:41.860 --> 53:43.060
是不是一个新的对象

53:43.060 --> 53:43.940
两个对象的地址

53:43.940 --> 53:45.540
跟之前的地址是不是不一样

53:45.540 --> 53:46.740
不一样是不是要重新选的

53:47.780 --> 53:48.100
对吧

53:48.100 --> 53:48.820
它叫重新选的

53:50.020 --> 53:52.420
它不会去比较对象里面的属性

53:52.420 --> 53:54.420
它不会去比较对象里面的属性

53:54.420 --> 53:55.860
它只会重新选的

53:55.860 --> 53:56.900
只要看到这个玩意儿

53:56.900 --> 53:58.340
因为它跟之前的地址不一样

53:58.340 --> 53:59.140
我们之前说过

53:59.940 --> 54:00.340
就是

54:01.860 --> 54:03.940
如果传的值和原来的自己

54:03.940 --> 54:04.580
不是

54:05.220 --> 54:07.060
如果是完全相等的话

54:07.060 --> 54:08.180
不会导致重新选的

54:08.180 --> 54:09.220
那如果不相等的话

54:09.220 --> 54:10.660
它是用Object是意志比较

54:10.660 --> 54:11.620
如果它返回Force

54:12.260 --> 54:14.180
因为对象两个地址不一样

54:14.180 --> 54:16.180
所以说它会导致它重新选的

54:16.180 --> 54:16.980
保存你看一下吧

54:18.420 --> 54:19.700
它呀是不是强制刷新的

54:19.700 --> 54:20.340
对吧

54:20.340 --> 54:21.940
它是用这种方式来做的

54:22.420 --> 54:24.100
它是用这种方式来做强制刷新的

54:24.740 --> 54:25.540
没问题吧

54:26.580 --> 54:27.540
这是关于这一块

54:28.500 --> 54:29.940
如果要强制刷新

54:29.940 --> 54:31.700
当然不太会用的

54:31.700 --> 54:32.500
不太会用的

54:33.380 --> 54:33.620
好

54:33.620 --> 54:34.100
下一个点

54:34.100 --> 54:34.900
下一个点的话

54:36.180 --> 54:37.060
之前说过的

54:37.060 --> 54:38.260
就是如果

54:40.260 --> 54:41.300
某些状态

54:43.220 --> 54:46.100
之间没有必然的联系

54:47.380 --> 54:48.260
比方说刚才那个

54:48.260 --> 54:50.500
一个数字是否可见

54:50.500 --> 54:50.900
对吧

54:50.900 --> 54:52.660
那个东西没有必然的联系

54:52.660 --> 54:56.020
应该分化为不同的状态

54:56.980 --> 54:58.180
这才是正确的做法

54:58.900 --> 55:00.340
实际上之前的内是

55:00.340 --> 55:02.340
内组件那种做法实际上是不好的

55:03.060 --> 55:03.940
把它写到一起了

55:03.940 --> 55:05.140
但内组件它没有办法

55:06.340 --> 55:07.540
它的函数组件

55:08.340 --> 55:10.100
你可以使用U state

55:10.100 --> 55:11.460
把它分化成不同的状态

55:12.420 --> 55:16.660
而不要合并成一个对象

55:18.420 --> 55:19.060
一个对象

55:19.060 --> 55:20.740
这是特别特别容易注意

55:20.740 --> 55:21.540
特别特别容易

55:21.540 --> 55:22.340
也就是初学者

55:22.340 --> 55:22.900
对

55:22.900 --> 55:24.740
在刚刚结束后可的时候

55:24.900 --> 55:26.020
特别容易犯了一个错误

55:26.900 --> 55:27.940
也不能叫错误

55:28.340 --> 55:29.540
你当然可以合并成对象

55:30.020 --> 55:30.980
只不过不好

55:31.860 --> 55:33.860
因为U state的出现

55:33.860 --> 55:35.460
它是为了横切关注点

55:35.460 --> 55:37.220
就是把这些功能一个一个分开

55:37.220 --> 55:38.100
分开来写

55:38.100 --> 55:39.780
因为我们学程序学了这么久了

55:39.780 --> 55:42.340
大家应该有这么一个感觉

55:42.340 --> 55:42.820
就是说

55:43.380 --> 55:47.540
程序里边的东西分得越细越好

55:47.540 --> 55:49.300
偶和度越低越好

55:49.300 --> 55:50.820
所以说尽量把这些状态分开

55:50.820 --> 55:52.260
而不要把它合并成一个对象

55:52.980 --> 55:53.780
关于这个点

55:53.780 --> 55:54.340
我说一下

55:55.700 --> 55:57.780
另外第八个点了

55:57.780 --> 55:58.580
就是说

55:58.580 --> 56:00.180
跟那个和内组件一样

56:01.140 --> 56:03.380
和内组件的状态一样

56:05.140 --> 56:07.060
函数组件中的

56:10.340 --> 56:11.140
函数组件中

56:12.020 --> 56:13.140
改变状态

56:14.260 --> 56:15.780
可能是异步的

56:16.660 --> 56:17.940
什么情况要是异步的呢

56:17.940 --> 56:19.140
就是在世界中

56:19.940 --> 56:21.620
在动物世界中

56:23.220 --> 56:24.020
它是异步的

56:24.660 --> 56:26.900
那么如果是异步的情况下

56:26.900 --> 56:33.940
那么多个状态变化可能就是会合并

56:33.940 --> 56:35.140
就是如果它是异步的话

56:35.140 --> 56:35.780
它会合并

56:36.660 --> 56:37.620
以提高效率

56:38.420 --> 56:39.540
以提高效率

56:40.180 --> 56:41.300
它不会每一次改变

56:41.300 --> 56:42.180
现在一次每一次改变

56:42.180 --> 56:42.980
现在一次

56:42.980 --> 56:44.260
它会多个状态变化

56:44.260 --> 56:44.900
会合并

56:44.900 --> 56:46.020
以提高效率

56:46.020 --> 56:46.980
那么这个时候

56:48.260 --> 56:48.900
大家注意

56:50.660 --> 56:51.220
此时

56:52.340 --> 56:53.540
不能信任

56:54.340 --> 56:55.220
不能信任

56:56.580 --> 56:57.620
之前的状态

56:58.980 --> 56:59.460
状态

57:00.740 --> 57:03.460
而应该使用

57:04.420 --> 57:06.500
毁掉函数的方式

57:07.460 --> 57:08.180
改变状态

57:08.740 --> 57:09.220
什么意思

57:09.220 --> 57:10.020
说了这么长句话

57:10.020 --> 57:10.740
什么意思

57:10.740 --> 57:11.220
就到这

57:13.060 --> 57:14.420
找到那个copy码

57:14.420 --> 57:14.820
就这个

57:15.540 --> 57:16.020
这个呢

57:16.020 --> 57:18.420
咱们把这个复制一下

57:18.980 --> 57:20.020
这个玩意重新

57:20.980 --> 57:22.020
重新复制过来

57:22.980 --> 57:23.700
好 看着

57:25.460 --> 57:26.100
把这个去掉

57:26.900 --> 57:27.780
那边去掉

57:28.420 --> 57:29.380
好 那么这里呢

57:29.380 --> 57:30.020
就一个n

57:30.020 --> 57:30.820
就一个n嘛

57:30.820 --> 57:31.780
比方说

57:31.780 --> 57:32.420
我们这里呢

57:32.420 --> 57:33.540
要减两次

57:33.540 --> 57:34.580
就假设嘛

57:34.580 --> 57:35.460
要减两次

57:36.020 --> 57:36.660
你看一下

57:36.660 --> 57:37.140
能不能

57:37.700 --> 57:38.980
减两次n-1

57:39.540 --> 57:41.780
你看上去好像没问题啊

57:41.780 --> 57:42.420
n-1

57:42.420 --> 57:43.540
一开始n是0嘛

57:43.540 --> 57:44.580
减1过后是不是-1

57:45.060 --> 57:45.940
n变成-1了

57:45.940 --> 57:46.820
-1--1

57:46.820 --> 57:48.020
再减1是不是-2

57:48.020 --> 57:48.660
是不是减了2

57:48.660 --> 57:49.140
对吧

57:49.140 --> 57:50.180
那么假设又这么样的

57:50.180 --> 57:50.980
这么样的需求

57:51.140 --> 57:52.580
如果要改变多次的话

57:52.580 --> 57:53.300
那么加呢

57:53.300 --> 57:54.500
也是加两次

57:54.500 --> 57:55.140
好 这里呢

57:55.140 --> 57:56.180
我们这里输出

57:56.180 --> 57:57.700
输出app

57:57.700 --> 57:58.740
vindar

57:58.740 --> 57:59.700
好 保存你看一下

58:00.580 --> 58:01.700
那么一开始运行了一次

58:01.700 --> 58:02.260
对吧

58:02.260 --> 58:03.460
好 现在我们点击加

58:04.260 --> 58:05.380
它只运行了一次

58:06.820 --> 58:07.940
而且数字是1

58:07.940 --> 58:09.140
这怎么回事呢

58:09.140 --> 58:09.940
就是因为

58:09.940 --> 58:11.860
它在dome世界里边

58:11.860 --> 58:13.140
这个改变状态了

58:13.140 --> 58:14.260
跟那个内主件是一样的

58:14.260 --> 58:15.140
它会合并

58:15.140 --> 58:16.580
比方说你一开始n

58:17.140 --> 58:17.780
n-1

58:17.780 --> 58:18.180
对吧

58:18.180 --> 58:19.460
一次要给它传了一个解

58:19.460 --> 58:20.740
n一开始是0

58:20.820 --> 58:22.180
0加1是1

58:22.180 --> 58:23.540
给它传了一个1进去

58:24.500 --> 58:24.740
好

58:24.740 --> 58:25.540
那么这个时候呢

58:25.540 --> 58:27.060
它不会立即改变状态

58:28.500 --> 58:29.620
不会立即改变

58:31.460 --> 58:34.020
要这个事件运行完了之后才会改变

58:34.020 --> 58:36.340
事件运行完成之后

58:37.300 --> 58:38.020
一起改变

58:38.900 --> 58:39.540
统一改变

58:40.100 --> 58:41.380
那么事件后边呢

58:41.380 --> 58:42.500
它又运行了这句话

58:42.500 --> 58:44.180
那么n是不是还是之前的值

58:44.980 --> 58:46.500
n是不是还是之前的值0

58:46.500 --> 58:47.060
对吧

58:47.060 --> 58:48.500
又把它改成1了

58:48.500 --> 58:52.660
所以说此时n的值仍然是0

58:53.300 --> 58:53.940
对不对

58:53.940 --> 58:55.220
所以说它得到了结果

58:55.220 --> 58:56.500
就0加1等于1

58:56.500 --> 58:57.300
把它设置为1

58:57.300 --> 58:58.740
然后又是0加1

58:58.740 --> 59:00.340
还是1还是把它设置为1

59:00.340 --> 59:03.220
然后这两次状态变化了

59:03.220 --> 59:04.580
虽然都是把它设置为1

59:04.580 --> 59:05.380
但是呢

59:05.380 --> 59:06.260
它会合并

59:06.260 --> 59:07.300
合并成一个

59:07.300 --> 59:08.260
合并成一个

59:08.260 --> 59:09.780
最终是把它设置为1嘛

59:09.780 --> 59:10.180
对不对

59:10.180 --> 59:11.140
最终把它设置为1

59:11.140 --> 59:13.380
那么最终它只是把它变成1

59:13.380 --> 59:13.940
因此呢

59:13.940 --> 59:15.300
它只运行了一次

59:15.300 --> 59:17.380
跟那个内主件是一样的

59:17.460 --> 59:18.580
它会进行合并

59:18.580 --> 59:19.780
所以说如果你要实现

59:19.780 --> 59:20.900
这样一种情况的话

59:20.900 --> 59:21.940
应该怎么来实现呢

59:21.940 --> 59:23.540
应该使用回调函数

59:23.540 --> 59:25.460
它这里边是支持回调函数的

59:25.460 --> 59:27.220
那么跟那个内主件是一样的

59:27.220 --> 59:29.060
这是之前的值

59:29.060 --> 59:30.340
之前的值

59:30.340 --> 59:32.180
以返回一个之后的值

59:32.180 --> 59:34.420
prn加1

59:34.420 --> 59:36.980
那么这个函数什么时候运行的

59:36.980 --> 59:38.980
它是事件完成之后

59:38.980 --> 59:40.980
传入的函数

59:40.980 --> 59:44.740
在事件完成之后

59:44.740 --> 59:46.260
统一运行

59:46.260 --> 59:47.300
统一运行

59:47.780 --> 59:48.740
那么这里

59:49.860 --> 59:50.820
第二个函数

59:50.820 --> 59:53.220
prn返回

59:53.860 --> 59:54.500
返回什么呢

59:54.500 --> 59:55.780
prn加1

59:57.380 --> 59:58.820
那么这个时候就没问题了

59:59.540 --> 59:59.780
好

59:59.780 --> 01:00:01.780
到时候它就会一次运行这个函数

01:00:01.780 --> 01:00:03.220
你这是不传那个函数进来吗

01:00:03.220 --> 01:00:03.620
好

01:00:03.620 --> 01:00:04.980
我先运行这个函数

01:00:04.980 --> 01:00:06.580
把之前的凌传进去

01:00:06.580 --> 01:00:07.700
凌传进去

01:00:07.700 --> 01:00:09.380
0加1是不是返回了一个1

01:00:09.380 --> 01:00:09.620
好

01:00:09.620 --> 01:00:11.140
我先把状态的暂时

01:00:11.140 --> 01:00:12.420
用个凌式辨量

01:00:12.420 --> 01:00:13.060
用个凌式辨量

01:00:13.060 --> 01:00:15.380
先把它暂时设为1

01:00:15.380 --> 01:00:16.820
然后又运行这个函数

01:00:16.900 --> 01:00:19.140
又把之前的得到的结果1传进去

01:00:19.140 --> 01:00:20.580
1加1等于2

01:00:20.580 --> 01:00:22.420
又把状态的凌式设为2

01:00:22.420 --> 01:00:22.820
好

01:00:22.820 --> 01:00:25.060
后来发现没有什么函数可以运行了

01:00:25.060 --> 01:00:25.460
OK

01:00:25.460 --> 01:00:28.020
那么我们把状态统一设置为2

01:00:28.020 --> 01:00:29.220
这个东西只运行一次

01:00:29.860 --> 01:00:30.420
但是呢

01:00:30.420 --> 01:00:32.260
这个两个函数分别都运行了

01:00:32.980 --> 01:00:33.380
对吧

01:00:33.380 --> 01:00:33.940
没问题吧

01:00:33.940 --> 01:00:34.820
我们之前讲过了

01:00:34.820 --> 01:00:36.180
所以我不带去运输了

01:00:36.180 --> 01:00:36.900
那么点击

01:00:36.900 --> 01:00:38.420
你看是不是还是只运行了一次

01:00:38.420 --> 01:00:39.380
合并运行

01:00:39.380 --> 01:00:40.820
合并是一定会合并的

01:00:40.820 --> 01:00:41.220
函

01:00:41.220 --> 01:00:41.780
但是呢

01:00:41.780 --> 01:00:44.500
我们这里函数里边就可以得到之前的值了

01:00:44.500 --> 01:00:46.420
因为函数它是循环一直调用的

01:00:46.580 --> 01:00:48.580
它会把这些函数加入一个数组里边

01:00:48.580 --> 01:00:50.020
循环一次调用这些函数

01:00:50.980 --> 01:00:52.660
先把第一次函数调用的结果

01:00:52.660 --> 01:00:54.100
作为函数传到第二次

01:00:54.100 --> 01:00:55.380
第二个函数的函数里边

01:00:55.380 --> 01:00:57.060
然后再调用这个函数

01:00:57.060 --> 01:00:57.700
调用完了过后

01:00:57.700 --> 01:01:00.980
把最后一个函数得到的结果来来重新选择

01:01:02.020 --> 01:01:03.060
它是用这种方式

01:01:03.060 --> 01:01:04.260
它是为了提高效率

01:01:04.260 --> 01:01:04.740
包括这里

01:01:05.380 --> 01:01:06.740
减1是不是一样的道理

01:01:06.740 --> 01:01:07.060
对吧

01:01:08.020 --> 01:01:09.460
减1是一样的道理

01:01:09.460 --> 01:01:10.660
如果你要特别注意

01:01:10.660 --> 01:01:11.700
就是在世界里面

01:01:11.700 --> 01:01:13.540
你要多次改变状态的话

01:01:13.540 --> 01:01:14.900
那么应该是用函数

01:01:14.900 --> 01:01:16.180
那一次是无所谓的

01:01:16.260 --> 01:01:17.380
大家可以想象这个道理

01:01:17.940 --> 01:01:19.460
如果你多次调用的时候

01:01:19.460 --> 01:01:21.460
你要用到之前的状态值

01:01:21.460 --> 01:01:22.980
那么你应该是用函数

01:01:22.980 --> 01:01:24.180
当然如果你说

01:01:24.180 --> 01:01:25.460
你出书的有使用函数

01:01:25.460 --> 01:01:26.500
没有任何问题

01:01:26.500 --> 01:01:27.620
那就万无一失了

01:01:27.620 --> 01:01:28.660
万无一失

01:01:28.660 --> 01:01:29.700
就是说如果

01:01:31.700 --> 01:01:32.660
如果

01:01:33.300 --> 01:01:35.540
如果状态变化

01:01:35.540 --> 01:01:39.060
要使用到之前的状态

01:01:39.060 --> 01:01:41.220
根据之前的状态来进行变化

01:01:41.220 --> 01:01:43.540
尽量使用

01:01:43.540 --> 01:01:45.300
尽量传递

01:01:45.380 --> 01:01:46.900
就这么个意思

01:01:46.900 --> 01:01:47.620
当然了

01:01:47.620 --> 01:01:49.780
如果你一次只有一次调用的话

01:01:50.420 --> 01:01:52.180
我有的设计难得去写函数

01:01:52.180 --> 01:01:53.380
多写点那一码

01:01:53.380 --> 01:01:54.020
麻烦

01:01:54.020 --> 01:01:55.620
所以我就直接写了

01:01:55.620 --> 01:01:57.220
但是你一定要注意

01:01:57.220 --> 01:01:59.220
除非你自己要把握得很准

01:01:59.220 --> 01:02:00.420
如果你把握不准的话

01:02:00.420 --> 01:02:01.780
最好就写函数

01:02:01.780 --> 01:02:03.700
有的时候我想偷懒

01:02:03.700 --> 01:02:05.220
谁还不想偷懒了

01:02:05.220 --> 01:02:06.260
不想偷懒的程序员

01:02:06.260 --> 01:02:07.460
不是好程序员吗

01:02:07.460 --> 01:02:08.500
所以说

01:02:08.500 --> 01:02:10.340
我有的设计我有了麻烦

01:02:10.340 --> 01:02:11.220
就直接写了

01:02:11.220 --> 01:02:12.340
但是你一定要清楚

01:02:12.340 --> 01:02:14.180
只有掉以一次的时候

01:02:14.340 --> 01:02:15.380
掉以一次的时候

01:02:15.380 --> 01:02:16.740
你才能干出这种事情

01:02:16.740 --> 01:02:18.420
有的时候你不确定能调用几次

01:02:18.420 --> 01:02:19.940
比方说你这里调用了别的函数

01:02:19.940 --> 01:02:21.700
别的函数你不要可能会改变状态

01:02:21.700 --> 01:02:22.340
那么

01:02:22.340 --> 01:02:23.460
你注意好

01:02:23.460 --> 01:02:24.420
注意好

01:02:24.420 --> 01:02:26.100
使用

01:02:26.100 --> 01:02:27.300
这种方式

01:02:27.300 --> 01:02:29.960
最保险

01:02:29.960 --> 01:02:32.520
还有啥呢

01:02:32.520 --> 01:02:33.640
就没啥了

01:02:33.640 --> 01:02:34.280
就没啥了

01:02:34.280 --> 01:02:36.120
这就是State Hook

01:02:36.120 --> 01:02:37.320
State Hook

01:02:37.320 --> 01:02:39.080
它的就是

01:02:39.080 --> 01:02:40.600
这种做法

01:02:40.600 --> 01:02:42.920
好 下来大家把它这些东西

01:02:42.920 --> 01:02:44.120
这些细节

01:02:44.120 --> 01:02:45.000
这些相关的单码

01:02:45.000 --> 01:02:46.360
咱们课堂不是写了一些单码吗

01:02:46.360 --> 01:02:48.200
虽然没有什么实际意义

01:02:48.200 --> 01:02:50.440
但是你一定要去练一下

01:02:50.440 --> 01:02:51.800
咱们学习这东西

01:02:51.800 --> 01:02:53.800
有的时候听起来很简单

01:02:53.800 --> 01:02:54.200
因为

01:02:54.200 --> 01:02:55.640
Hook它其实并不复杂

01:02:55.640 --> 01:02:56.920
它非常简单

01:02:56.920 --> 01:02:58.440
因为它的出现的目的

01:02:58.440 --> 01:03:00.120
就是为了简化内逐渐的

01:03:00.120 --> 01:03:01.880
所以它一定是非常简单的

01:03:01.880 --> 01:03:03.080
但是它听起来很简单

01:03:03.080 --> 01:03:05.240
但是这些API那里的熟悉

01:03:05.240 --> 01:03:06.440
有的时候你看着

01:03:06.440 --> 01:03:07.400
感觉好像没问题

01:03:07.400 --> 01:03:09.080
但是你自己写的时候

01:03:09.080 --> 01:03:10.520
你会有一些疑问

01:03:10.520 --> 01:03:11.960
或者说有一些不熟悉的地方

01:03:11.960 --> 01:03:13.560
然后再结合视频看一下

01:03:13.640 --> 01:03:15.640
你会聊越得更加深刻了

01:03:15.640 --> 01:03:17.320
所以说一定要去写一遍

01:03:17.320 --> 01:03:19.080
所以写的话就像我这样子

01:03:19.080 --> 01:03:20.360
自己去写一些练习

01:03:20.360 --> 01:03:22.760
就像模拟我这上课的写的单码

01:03:22.760 --> 01:03:24.200
自己去写一些练习

01:03:24.200 --> 01:03:25.480
特别关注一下

01:03:25.480 --> 01:03:28.520
笔记里面我们提到了这些点

01:03:28.520 --> 01:03:29.160
好吧

01:03:29.160 --> 01:03:30.680
好 OK 这是State Hook

