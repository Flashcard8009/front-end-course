WEBVTT

00:00.560 --> 00:06.960
这就看了咱们讲那个叫做pure,pure component

00:06.960 --> 00:10.360
也称之为纯主件

00:10.360 --> 00:13.360
pure就是纯粹的意思

00:13.360 --> 00:15.560
它是一个什么东西呢

00:15.560 --> 00:21.560
它是用于避免不必要的渲染

00:21.560 --> 00:23.560
不必要的渲染

00:23.560 --> 00:24.560
渲染是什么

00:24.560 --> 00:28.560
渲染其实就是运行Render函数

00:29.560 --> 00:31.560
实际上渲染就是运行Render函数

00:31.560 --> 00:33.560
我们说改变状态

00:33.560 --> 00:36.560
改变的属性它会重新运行Render

00:36.560 --> 00:38.560
重新渲染就是这么个意思

00:38.560 --> 00:42.560
纯主件它可以用于避免不必要的渲染

00:42.560 --> 00:47.560
从而提高效率

00:47.560 --> 00:50.560
虽然说咱们之前说过

00:50.560 --> 00:52.560
Rex里边的那些组件

00:52.560 --> 00:55.560
那些元素他们都是虚拟的动物

00:55.560 --> 00:57.560
本质上都是介绍对象

00:57.560 --> 00:59.560
但是你避免了

00:59.560 --> 01:01.560
从不必要的渲染

01:01.560 --> 01:03.560
你少去运行一些Render

01:03.560 --> 01:06.560
那么它构建虚拟的动物对象

01:06.560 --> 01:08.560
也会需要一点时间

01:08.560 --> 01:09.560
构建虚拟动物对象

01:09.560 --> 01:11.560
我们后边还会专门来一些课

01:11.560 --> 01:13.560
来详细说虚拟动物对象

01:13.560 --> 01:14.560
以及真实动物对象

01:14.560 --> 01:16.560
他们是怎么样去对应的

01:16.560 --> 01:18.560
总之你可以

01:18.560 --> 01:20.560
如果你不运行Render

01:20.560 --> 01:22.560
那么它就不会重新去构建

01:22.560 --> 01:24.560
这个虚拟对象

01:24.560 --> 01:26.560
那么从而达到了提高效率的目的

01:27.560 --> 01:29.560
我们这里最好画个图

01:29.560 --> 01:31.560
给大家画个图来解释一下

01:32.560 --> 01:34.560
我这里有还是用PVT

01:35.560 --> 01:38.560
就在我们的Rex里边

01:38.560 --> 01:40.560
它最终会形成一个组件数

01:40.560 --> 01:42.560
每一个组件它有属像

01:42.560 --> 01:45.560
或者是有那个

01:45.560 --> 01:47.560
状态

01:47.560 --> 01:49.560
有属像有状态

01:49.560 --> 01:51.560
会形成这么一个属件数

01:51.560 --> 01:53.560
花几成就行了

01:54.560 --> 01:55.560
我说这么个意思

01:55.560 --> 01:57.560
大家可以在头脑里面想象一下

01:57.560 --> 01:59.560
它可能这个组件数会比较深

01:59.560 --> 02:01.560
不仅仅是只有这么一点

02:01.560 --> 02:03.560
它可能东西比较多

02:03.560 --> 02:05.560
形成这么一个组件数

02:06.560 --> 02:08.560
那么每一个组件里边

02:08.560 --> 02:10.560
它可能会有自己的属像

02:10.560 --> 02:12.560
可能会有自己的

02:13.560 --> 02:18.980
状态

02:18.980 --> 02:23.830
稍微连一下

02:23.830 --> 02:25.830
我下来我还是直接画一个组件数吧

02:25.830 --> 02:28.830
Render以后可能会反复用到的

02:31.460 --> 02:33.460
形成这么一个组件数

02:33.460 --> 02:35.460
那么比方说

02:35.460 --> 02:37.460
这个组件它的状态改变了

02:37.460 --> 02:39.460
比方说它的这个组件

02:39.460 --> 02:41.460
它的状态改变了

02:41.460 --> 02:43.460
那么它的状态改变了会怎么样了

02:43.460 --> 02:45.460
是不是会运行Render

02:45.460 --> 02:47.460
它运行Render那么会不会影响

02:47.460 --> 02:49.460
它跟它没有什么关系

02:49.460 --> 02:51.460
跟它没有什么关系

02:51.460 --> 02:53.460
只是它的状态变了

02:53.460 --> 02:55.460
那么它的状态变化过后

02:55.460 --> 02:57.460
它会运行Render

02:57.460 --> 02:59.460
那么运行Render的时候

02:59.460 --> 03:01.460
它会同时渲染这些组件

03:01.460 --> 03:03.460
那么于是

03:03.460 --> 03:05.460
这个组件运行Render的过程中

03:05.460 --> 03:07.460
那么同时又导致了

03:07.460 --> 03:09.460
这些组件又被重新渲染了

03:09.460 --> 03:11.460
那么这一部分

03:11.460 --> 03:13.460
组件数它全部要重新渲染

03:13.460 --> 03:15.460
这就是Reaction

03:15.460 --> 03:17.460
默认情况下的工作模式

03:17.460 --> 03:19.460
那么一样的意思吧

03:19.460 --> 03:21.460
它的状态变了

03:21.460 --> 03:23.460
那么导致它的重新渲染

03:23.460 --> 03:25.460
重新渲染过后

03:25.460 --> 03:27.460
这些东西也会跟着重新渲染

03:27.460 --> 03:29.460
这些玩意儿也会跟着去运行Render

03:29.460 --> 03:31.460
就这么个意思

03:31.460 --> 03:33.460
但是我们知道

03:33.460 --> 03:35.460
在Reaction里面

03:35.460 --> 03:37.460
它的生命周期里面有一个方法

03:37.460 --> 03:39.460
有个啥方法呢比方说

03:39.460 --> 03:41.460
我看这的

03:41.460 --> 03:43.460
叫做Shield Component Update的方法

03:43.460 --> 03:45.460
这是个性能优化点

03:45.460 --> 03:47.460
这个方法默认情况下

03:47.460 --> 03:49.460
它是直接返回去的

03:49.460 --> 03:51.460
那么如果这个方法直接返回去的话

03:51.460 --> 03:53.460
每一次组件的变化

03:53.460 --> 03:55.460
它都会导致

03:55.460 --> 03:57.460
组件重新渲染

03:57.460 --> 03:59.460
都会导致重新渲染

03:59.460 --> 04:01.460
哪怕它的属性

04:01.460 --> 04:03.460
它的属性值一个都没变

04:03.460 --> 04:05.460
它的状态值一个都没变

04:05.460 --> 04:07.460
比方说这里

04:07.460 --> 04:09.460
我这里就雕了这么一句

04:09.460 --> 04:11.460
set status

04:11.460 --> 04:13.460
然后传来个空对象

04:13.460 --> 04:15.460
哪怕我就做了这么一件事

04:15.460 --> 04:17.460
传来个空对象进去

04:17.460 --> 04:19.460
它仍然会导致

04:19.460 --> 04:21.460
仍然会导致它重新渲染

04:21.460 --> 04:23.460
你只要雕了set status

04:23.460 --> 04:25.460
它就会重新渲染

04:25.460 --> 04:27.460
那么重新渲染之前

04:27.460 --> 04:29.460
它会运行这个函数

04:29.460 --> 04:31.460
Shield Component Update

04:31.460 --> 04:33.460
运行这个函数

04:33.460 --> 04:35.460
这个函数默认情况下

04:35.460 --> 04:37.460
它直接返回去

04:37.460 --> 04:39.460
它一定会重新渲染

04:39.460 --> 04:41.460
那么它渲染的时候

04:41.460 --> 04:43.460
它又会导致它要进入生命周期

04:43.460 --> 04:45.460
又会运行这个组件的

04:45.460 --> 04:47.460
这个函数

04:47.460 --> 04:49.460
那么这个函数它默认情况下

04:49.460 --> 04:51.460
直接返回去

04:51.460 --> 04:53.460
因此它会重新渲染

04:53.460 --> 04:55.460
它现在的时候又会导致它的织组件

04:55.460 --> 04:57.460
又去运行这个函数

04:57.460 --> 04:59.460
重新渲染

04:59.460 --> 05:01.460
那么假设我们要做性能优化的话

05:01.460 --> 05:03.460
我们应该怎么来做呢

05:03.460 --> 05:05.460
就是我们可以在适当的时候

05:05.460 --> 05:07.460
在这个函数里边

05:07.460 --> 05:09.460
在适当的时候返回一个force

05:09.460 --> 05:11.460
什么适当的时候

05:11.460 --> 05:13.460
你觉得它没有必要重新渲染的时候

05:13.460 --> 05:15.460
你返回一个force

05:15.460 --> 05:17.460
那么你返回了force之后

05:17.460 --> 05:19.460
比方说这个东西

05:19.460 --> 05:21.460
我们就should

05:21.460 --> 05:23.460
component updates

05:23.460 --> 05:25.460
我们用scu

05:25.460 --> 05:27.460
减写一下

05:27.460 --> 05:29.460
如果它返回到force

05:29.460 --> 05:31.460
那么它会不会重新渲染

05:31.460 --> 05:33.460
它就不会重新渲染

05:33.460 --> 05:35.460
它不会重新渲染

05:35.460 --> 05:37.460
从而就导致了

05:37.460 --> 05:39.460
由于它没有运行Render

05:39.460 --> 05:41.460
那么导致了它也没有运行Render

05:41.460 --> 05:43.460
就导致了它也没有运行Render

05:43.460 --> 05:45.460
那么它也不会重新渲染

05:45.460 --> 05:47.460
那么就形成了

05:47.460 --> 05:49.460
没有需要渲染的部分了

05:49.460 --> 05:51.460
它就没有渲染

05:51.460 --> 05:53.460
这样子可以提高执行效率

05:53.460 --> 05:55.460
这些课本主要是研究这个

05:55.460 --> 05:57.460
这里我给大家几个例子

05:57.460 --> 05:59.460
几个例子就非常清楚了

05:59.460 --> 06:01.460
我们这里写上这么一个组件

06:03.460 --> 06:05.460
component里面

06:05.460 --> 06:07.460
写上这么一个组件

06:07.460 --> 06:09.460
名字叫做

06:09.460 --> 06:11.460
一个task

06:13.460 --> 06:15.460
表示一个任务

06:15.460 --> 06:17.460
它其实就是一个文本

06:17.460 --> 06:19.460
一个任务就是一个文本

06:19.460 --> 06:21.460
然后包含一个状态适逢完成

06:21.460 --> 06:23.460
包含这么一个状态适逢完成

06:23.460 --> 06:25.460
然后我们这里写上

06:25.460 --> 06:27.460
这么一个组件就是

06:27.460 --> 06:29.460
RCC

06:29.460 --> 06:31.460
这个组件里面

06:31.460 --> 06:33.460
你要告诉我一个属性

06:33.460 --> 06:35.460
你要告诉我一个属性

06:35.460 --> 06:37.460
proper types

06:37.460 --> 06:39.460
什么属性呢

06:39.460 --> 06:41.460
一个任务吧,你要告诉我一个任务对象

06:41.460 --> 06:43.460
你把任务对象告诉我

06:43.460 --> 06:45.460
这里我们倒入进来

06:45.460 --> 06:47.460
proper types

06:47.460 --> 06:49.460
proper types

06:51.460 --> 06:53.460
任务对象里面

06:53.460 --> 06:55.460
它有一个属性

06:55.460 --> 06:57.460
叫做任务的名称

06:57.460 --> 06:59.460
任务的名称的话

06:59.460 --> 07:01.460
它就是一个支付创

07:01.460 --> 07:03.460
is required

07:03.460 --> 07:05.460
这是任务的名称

07:05.460 --> 07:07.460
任务名称

07:07.460 --> 07:09.460
然后还要告诉我一个属性叫做

07:09.460 --> 07:11.460
任务适逢完成

07:11.460 --> 07:13.460
任务适逢完成

07:13.460 --> 07:15.460
is task

07:15.460 --> 07:17.460
is finish

07:17.460 --> 07:19.460
表示任务适逢完成

07:19.460 --> 07:21.460
他是一个布尔

07:21.460 --> 07:23.460
布林

07:23.460 --> 07:25.460
is required

07:25.460 --> 07:27.460
这是任务适逢

07:27.460 --> 07:29.460
完成

07:29.460 --> 07:31.460
总之你要告诉我这么两个属性

07:31.460 --> 07:33.460
你告诉我这两个属性之后

07:33.460 --> 07:35.460
咱们在这个组件里面

07:35.460 --> 07:37.460
就给它做这么一个显示

07:37.460 --> 07:39.460
就显示一个li

07:39.460 --> 07:41.460
这个li里面就写上

07:41.460 --> 07:43.460
任务的名称

07:43.460 --> 07:45.460
proper types

07:47.460 --> 07:49.460
nate

07:49.460 --> 07:51.460
props.nate

07:51.460 --> 07:53.460
任务的名称

07:53.460 --> 07:55.460
然后任务适逢完成

07:55.460 --> 07:57.460
如果它完成的话

07:57.460 --> 07:59.460
给它一个那样式

07:59.460 --> 08:01.460
比方说我们就这样吧

08:01.460 --> 08:03.460
class name

08:05.460 --> 08:07.460
写上

08:07.460 --> 08:09.460
this props

08:09.460 --> 08:11.460
is finish

08:11.460 --> 08:13.460
如果它为finish

08:13.460 --> 08:15.460
如果完成的话

08:15.460 --> 08:17.460
把它设置为finish

08:17.460 --> 08:19.460
否则的话就没有任何

08:19.460 --> 08:21.460
没有任何没人样式了

08:21.460 --> 08:23.460
给它一个class name

08:23.460 --> 08:25.460
为了看到效果

08:25.460 --> 08:27.460
我们这里去写这么一个

08:27.460 --> 08:29.460
css

08:29.460 --> 08:31.460
这里写这么一个css

08:31.460 --> 08:33.460
finish

08:33.460 --> 08:35.460
如果完成的话

08:35.460 --> 08:37.460
把它设置为绿色

08:37.460 --> 08:39.460
好 行了

08:39.460 --> 08:43.160
咱们这里把css导致

08:47.160 --> 08:49.160
我们就写好了这么一个组件

08:49.160 --> 08:51.160
非常非常简单的这么一个组件

08:51.160 --> 08:53.160
你告诉我任务名称

08:53.160 --> 08:55.160
告诉我任务适逢完成

08:55.160 --> 08:57.160
我就根据你设置的结果来进行显示

08:57.160 --> 08:59.160
就这么一个组件

08:59.160 --> 09:01.160
现在我再写一个task list

09:01.160 --> 09:03.160
task list这么一个组件

09:03.160 --> 09:05.160
这个组件里面

09:05.160 --> 09:07.160
提供任务的数据

09:07.160 --> 09:09.160
然后把整个任务显示出来

09:09.160 --> 09:11.160
我们

09:11.160 --> 09:13.160
这里写上一个类组件

09:13.160 --> 09:15.160
或者是韩式组件也行

09:15.160 --> 09:17.160
类组件

09:17.160 --> 09:19.160
它也需要一个数项

09:19.160 --> 09:21.160
你要告诉我什么呢

09:21.160 --> 09:23.160
你要告诉我一个任务的数组

09:23.160 --> 09:25.160
你要告诉我一个任务的数组

09:25.160 --> 09:27.160
我们这里写上这么一个数项

09:27.160 --> 09:29.160
static

09:29.160 --> 09:31.160
prob types

09:31.160 --> 09:33.160
我们把它形成一个组件的结构

09:33.160 --> 09:35.160
你需要告诉我一个task

09:35.160 --> 09:37.160
task

09:37.160 --> 09:39.160
它是个什么呢

09:39.160 --> 09:41.160
它是一个数组

09:41.160 --> 09:43.160
import

09:43.160 --> 09:45.160
prob types

09:45.160 --> 09:47.160
from

09:47.160 --> 09:49.160
react

09:49.160 --> 09:51.160
prob types

09:51.160 --> 09:53.160
这是个任务的数据

09:53.160 --> 09:55.160
你需要告诉我

09:55.160 --> 09:57.160
它是一个prob types

09:57.160 --> 09:59.160
arrino

09:59.160 --> 10:01.160
什么类型的数据

10:01.160 --> 10:03.160
是一个对象

10:03.160 --> 10:06.600
每一个数据的每一项是一个对象

10:06.600 --> 10:08.600
shape

10:08.600 --> 10:10.600
这个对象里边

10:10.600 --> 10:12.600
每个对象里边有哪些数据

10:12.600 --> 10:14.600
有两个数据

10:14.600 --> 10:16.600
name数据

10:16.600 --> 10:18.600
你必须要是

10:18.600 --> 10:20.600
字幕刷

10:20.600 --> 10:22.600
stune isRequired

10:22.600 --> 10:24.600
然后

10:24.600 --> 10:26.600
e isFelix

10:26.600 --> 10:28.600
你必须要是一个布尔数据

10:28.600 --> 10:30.600
isRequired

10:30.600 --> 10:32.600
isRequired

10:32.600 --> 10:34.600
好了

10:34.600 --> 10:36.600
有了这个数组过后

10:36.600 --> 10:38.600
我这个task list

10:38.600 --> 10:40.600
它就负责把这个数组渲染出来

10:40.600 --> 10:42.600
那么渲染的时候是不是要用到一个单个组件

10:42.600 --> 10:44.600
单个任务对象

10:44.600 --> 10:46.600
单个任务task from

10:46.600 --> 10:48.600
task

10:48.600 --> 10:50.600
咱们把这个图还是画一下

10:50.600 --> 10:52.600
编写变化

10:52.600 --> 10:54.600
我们现在的场景是这样子的

10:54.600 --> 10:58.490
我们现在有这么一个组件

10:58.490 --> 11:00.490
有这么一套组件

11:00.490 --> 11:02.490
task list

11:02.490 --> 11:04.490
然后组下面一个组件

11:04.490 --> 11:06.490
叫做 nest

11:06.490 --> 11:08.490
有这么两个组件

11:08.490 --> 11:10.490
形成这么一种结构

11:10.490 --> 11:12.490
这里需要一个数组

11:12.490 --> 11:14.490
任务数组

11:14.490 --> 11:16.490
然后它会拿到这个数组

11:16.490 --> 11:18.490
拿到这个数组之后

11:18.490 --> 11:20.490
它会循环渲染这个东西

11:20.490 --> 11:22.490
那么咱们这里就写一个辨量

11:22.490 --> 11:24.490
ts

11:24.490 --> 11:26.490
ts

11:26.490 --> 11:28.490
然后Z props

11:28.490 --> 11:30.490
task

11:30.490 --> 11:32.490
我们的拿到这个数组

11:32.490 --> 11:34.490
通过map

11:34.490 --> 11:36.490
把它映射成为一个什么对象的

11:36.490 --> 11:38.490
一个task的对象

11:38.490 --> 11:40.490
一个task的节点

11:40.490 --> 11:42.490
那么这里肯定要给什么key

11:42.490 --> 11:44.490
我们挨着写

11:44.490 --> 11:46.490
给什么key

11:46.490 --> 11:48.490
key的话我们就用什么呢

11:48.490 --> 11:50.490
就用下标

11:50.490 --> 11:52.490
给一个key

11:52.490 --> 11:54.490
给这么个东西

11:54.490 --> 11:56.490
然后再给一个啥呢

11:56.490 --> 11:58.490
它不是要name属性吗

11:58.490 --> 12:00.490
name属性呢就为什么

12:00.490 --> 12:02.490
name

12:02.490 --> 12:04.490
或者是我们把这个东西展开

12:04.490 --> 12:06.490
把这个玩意展开

12:06.490 --> 12:08.490
没问题吧

12:08.490 --> 12:10.490
能看懂吗

12:10.490 --> 12:12.490
它这个数组里面每一项是不是个

12:12.490 --> 12:14.490
这里说的是个数组

12:14.490 --> 12:16.490
数组里面每一项是个对象

12:16.490 --> 12:18.490
对象里面是有name属性

12:18.490 --> 12:20.490
那么这个组件

12:20.490 --> 12:22.490
它不就是要这两个属性吗

12:22.490 --> 12:24.490
OK 我把这两个属性

12:24.490 --> 12:26.490
好 我们这里就得到这么一个

12:26.490 --> 12:28.490
组件的就是个节点的集合

12:28.490 --> 12:30.490
把它放到UL里边

12:30.490 --> 12:32.490
把它放到UL里边

12:32.490 --> 12:34.490
TS 放进去

12:34.490 --> 12:36.490
这些组件都非常非常简单

12:36.490 --> 12:38.490
没有什么好说的

12:38.490 --> 12:40.490
那么这里就把这个组件写好了

12:40.490 --> 12:42.490
接下来我们再写一个组件

12:42.490 --> 12:43.490
再写一个组件

12:43.490 --> 12:45.490
这个组件就要提供各种各样的数据了

12:45.490 --> 12:47.490
就要提供数据了

12:48.490 --> 12:50.490
task container

12:50.490 --> 12:52.490
一个任务的容器

12:52.490 --> 12:54.490
这个组件它来负责提供数据

12:54.490 --> 12:56.490
然后把这些东西渲染出来

12:56.490 --> 12:58.490
那么这里我们写个类组件

12:58.490 --> 13:00.490
因为它里面有数据

13:00.490 --> 13:02.490
刚才那两个组件可以写成韩束组件

13:02.490 --> 13:04.490
我们一会再说韩束组件

13:04.490 --> 13:06.490
然后task container

13:06.490 --> 13:08.490
把它写成一个容器

13:08.490 --> 13:10.490
然后这个容器里面我们写上这么一个状态

13:10.490 --> 13:13.490
状态里面有一个task的集合

13:13.490 --> 13:15.490
task的集合

13:15.490 --> 13:17.490
有这么一个东西

13:17.490 --> 13:19.490
然后它里面

13:20.490 --> 13:22.490
我想想

13:22.490 --> 13:23.490
没啥了

13:23.490 --> 13:24.490
就没啥了

13:24.490 --> 13:25.490
就一个task的集合

13:25.490 --> 13:27.490
然后我们给它做一些初始化

13:27.490 --> 13:29.490
component statement

13:29.490 --> 13:31.490
做一些初始化

13:31.490 --> 13:33.490
当我们完成

13:33.490 --> 13:35.490
迁入的时候

13:35.490 --> 13:37.490
当我们组件夹在好了之后

13:37.490 --> 13:38.490
我给这个数据

13:38.490 --> 13:40.490
附一些加一些东西

13:40.490 --> 13:42.490
这个数据加一些东西

13:42.490 --> 13:45.490
这里我们写上一个ts

13:45.490 --> 13:46.490
整个数据

13:46.490 --> 13:48.490
然后我们这里写个循环

13:48.490 --> 13:50.490
给它夹个10个任务

13:50.490 --> 13:52.490
给它夹10个任务

13:52.490 --> 13:54.490
小余的认识

13:54.490 --> 13:56.490
这里从一开始循环

14:02.490 --> 14:05.930
每一次循环

14:05.930 --> 14:07.930
我们往这个数据里面

14:07.930 --> 14:09.930
铺写一个新加入一项

14:09.930 --> 14:11.930
新加入一项数据

14:11.930 --> 14:13.930
什么数据呢

14:13.930 --> 14:15.930
任务的名称

14:15.930 --> 14:17.930
我们就用这个名称

14:17.930 --> 14:19.930
任务

14:19.930 --> 14:21.930
设讽完成的话

14:21.930 --> 14:23.930
也是废得起

14:23.930 --> 14:25.930
我们这里

14:25.930 --> 14:27.930
设讽完成随机

14:27.930 --> 14:29.930
随机用个mass

14:29.930 --> 14:31.930
是不是大于

14:31.930 --> 14:33.930
0.5

14:33.930 --> 14:35.930
用这个东西来随机

14:35.930 --> 14:37.930
总之呢创建这么一个数据

14:37.930 --> 14:39.930
然后我们把这个数据

14:39.930 --> 14:41.930
夹到状态里边去

14:41.930 --> 14:43.930
this set state

14:43.930 --> 14:45.930
夹到状态里边去

14:45.930 --> 14:46.930
task

14:46.930 --> 14:48.930
夹进去

14:48.930 --> 14:50.930
那么是不是就有这个数据了

14:50.930 --> 14:52.930
就有数据了

14:52.930 --> 14:54.930
那么现在我们在

14:54.930 --> 14:56.930
Render里面去选择什么呢

14:56.930 --> 14:58.930
选择这个task list

14:58.930 --> 15:00.930
选择这个东西

15:00.930 --> 15:02.930
from task

15:06.930 --> 15:08.930
task list

15:08.930 --> 15:13.140
这边我们就直接选择这个东西

15:13.140 --> 15:15.140
task list

15:16.140 --> 15:18.140
咱们先看一下吧

15:18.140 --> 15:19.140
把task给它传进去

15:19.140 --> 15:20.140
它不是要一个属性吗

15:20.140 --> 15:22.140
把这个属性给它传进去

15:22.140 --> 15:24.140
来自于我状态里边的这个属性

15:24.140 --> 15:26.140
task

15:26.140 --> 15:28.140
来自我状态里边的这个属性

15:28.140 --> 15:30.140
OK 我把这个属性传给你

15:30.140 --> 15:32.140
行了 咱们来看一下

15:32.140 --> 15:34.140
在app里面我们导入

15:34.140 --> 15:37.140
task container

15:37.140 --> 15:39.140
from component

15:39.140 --> 15:41.140
task container

15:41.140 --> 15:43.140
OK 我们在这里呢

15:43.140 --> 15:47.220
这个逐渐

15:47.220 --> 15:49.220
好 保存

15:49.220 --> 15:51.220
那咱们运行出来看一下

15:51.220 --> 15:53.220
一二二start

15:53.220 --> 15:56.720
看一下是一个什么样的结果

15:56.720 --> 16:14.750
好 出来了

16:14.750 --> 16:16.750
那么你可以看到这里面

16:16.750 --> 16:18.750
有些任务是完成了的

16:18.750 --> 16:20.750
用一个绿色显示

16:20.750 --> 16:22.750
好像看的不是很清楚的吧

16:22.750 --> 16:24.750
那么我们这里换一个颜色

16:24.750 --> 16:26.750
换一个颜色就用grame

16:26.750 --> 16:28.750
grame

16:28.750 --> 16:30.750
还是看的不是很清楚

16:30.750 --> 16:32.750
那普通任务的话

16:32.750 --> 16:34.750
我们就用另外一个颜色

16:34.750 --> 16:36.750
用一个666

16:36.750 --> 16:42.340
能看清楚了吧

16:42.340 --> 16:44.340
因为我这个录屏

16:44.340 --> 16:46.340
应该可以分得清楚吧

16:46.340 --> 16:48.340
应该可以分得清楚

16:48.340 --> 16:50.340
任务完成了的话我就用这个显示

16:50.340 --> 16:52.340
任务没完成 干脆这样

16:52.340 --> 16:54.340
任务没完成的话我用f40

16:54.340 --> 16:56.340
用个红色来显示

16:56.340 --> 16:58.340
这样看那个颜色的分辨率就很高了

16:58.340 --> 17:00.340
好 那么我们现在就渲染出来这么一个结果

17:00.340 --> 17:03.340
对吧 那么现在我问大家一个问题

17:03.340 --> 17:05.340
这里边

17:05.340 --> 17:07.340
我们现在形成了这么一种组件结构

17:07.340 --> 17:11.350
app

17:11.350 --> 17:13.350
下面有个什么呢

17:13.350 --> 17:15.350
有个task container

17:15.350 --> 17:17.350
task container

17:17.350 --> 17:19.350
有这么一个组件

17:19.350 --> 17:21.350
那么形成了这么一个组件结构

17:21.350 --> 17:23.350
我们的组件是不是这样子的

17:23.350 --> 17:25.350
我们可以通过调制工具了

17:25.350 --> 17:27.350
也可以看得很清楚

17:27.350 --> 17:29.350
那么大家现在思考一个问题

17:29.350 --> 17:31.350
每一个组件的

17:31.350 --> 17:33.350
先目前每一个组件的

17:33.350 --> 17:35.350
vendor运行的多少次

17:35.350 --> 17:37.350
每一个组件的vendor

17:37.350 --> 17:39.350
运行的多少次

17:39.350 --> 17:41.350
那么这个task里面

17:41.350 --> 17:43.350
task

17:43.350 --> 17:45.350
那么这里面肯定有很多个task对吧

17:45.350 --> 17:47.350
肯定有很多个

17:47.350 --> 17:49.350
我这里只画了一个

17:49.350 --> 17:55.510
实际上肯定是有很多个的

17:55.510 --> 17:57.510
这样说

17:57.510 --> 17:59.510
画三个就行了

17:59.510 --> 18:01.510
肯定是有很多个的

18:01.510 --> 18:03.510
那么大家想一想

18:03.510 --> 18:05.510
每一个组件

18:05.510 --> 18:07.510
vendor

18:07.510 --> 18:09.510
运行的多少次

18:09.510 --> 18:11.510
或者说如果面试题问题

18:11.510 --> 18:13.510
就这么一个东西

18:13.510 --> 18:15.510
所有的组件vendor加起来

18:15.510 --> 18:17.510
一共运行的多少次

18:17.510 --> 18:19.510
你能不能回答出来这个问题

18:19.510 --> 18:21.510
那么你要回答出来这个问题的话

18:21.510 --> 18:23.510
你就需要对生命周期

18:23.510 --> 18:25.510
有非常透彻的理解

18:25.510 --> 18:27.510
能不能回答出来这个问题

18:27.510 --> 18:29.510
好好想一想

18:29.510 --> 18:31.510
我们这边先再看一下组件数

18:31.510 --> 18:33.510
再看一下这个组件数

18:33.510 --> 18:35.510
它包错了

18:35.510 --> 18:37.510
这里

18:37.510 --> 18:39.510
这里写错了

18:39.510 --> 18:41.510
task列子

18:41.510 --> 18:43.510
对了

18:43.510 --> 18:45.510
它说什么

18:45.510 --> 18:47.510
让我用一个静态的属性

18:47.510 --> 18:49.510
让我用一个静态的属性

18:49.510 --> 18:51.510
来定义propertypes

18:51.510 --> 18:53.510
propertypes defined as instance

18:53.510 --> 18:55.510
它说我哪个地方写的有问题

18:55.510 --> 18:57.510
它没有包圆码的错误

18:57.510 --> 18:59.510
它没有包圆码的错误

18:59.510 --> 19:01.510
在这

19:02.510 --> 19:04.510
把这个抽签解决

19:04.510 --> 19:06.510
那么现在我们看一下

19:06.510 --> 19:08.510
Render的组件结构

19:08.510 --> 19:09.510
就是我们刚才说的结构

19:09.510 --> 19:11.510
App下面是不是task container

19:11.510 --> 19:13.510
下面是task nest

19:13.510 --> 19:15.510
下面是task

19:15.510 --> 19:17.510
这些内置的组件我就不管了

19:17.510 --> 19:19.510
我们只说我们自己的组件

19:19.510 --> 19:21.510
形成了这么一种组件数

19:21.510 --> 19:23.510
每个组件

19:23.510 --> 19:25.510
vendor运行多少次呢

19:25.510 --> 19:27.510
首先

19:27.510 --> 19:29.510
咱们来看一下这个组件的vendor

19:29.510 --> 19:31.510
它运行了多少次呢

19:31.510 --> 19:33.510
在这里看一下

19:33.510 --> 19:35.510
App这个组件

19:35.510 --> 19:37.510
就是根组件吧

19:37.510 --> 19:39.510
它那边是一个函数组件

19:39.510 --> 19:41.510
那么这个函数

19:41.510 --> 19:43.510
可以认为这个函数就是vendor

19:43.510 --> 19:45.510
就渲染

19:45.510 --> 19:47.510
这个函数组件运行了多少次呢

19:47.510 --> 19:49.510
我们输出一下

19:49.510 --> 19:51.510
App Vendor

19:51.510 --> 19:53.510
看一下它运行了多少次

19:53.510 --> 19:55.510
它是不是只运行了一次

19:55.510 --> 19:57.510
为什么这个组件要导致重新渲染

19:57.510 --> 19:59.510
只有一种情况

19:59.510 --> 20:01.510
因为它是函数组件吧

20:01.510 --> 20:03.510
它没有状态

20:03.510 --> 20:05.510
它要重新渲染怎么办呢

20:05.510 --> 20:07.510
是不是必须要是

20:07.510 --> 20:09.510
它的副组件重新渲染

20:09.510 --> 20:11.510
那么它才会跟着重新渲染

20:11.510 --> 20:13.510
才会重新调整这个函数

20:13.510 --> 20:15.510
它又没有副组件

20:15.510 --> 20:17.510
它就没有副组件了

20:17.510 --> 20:19.510
它已经是根组件了

20:19.510 --> 20:21.510
我们在index里直接使用它来进行渲染

20:21.510 --> 20:23.510
它就是根了

20:23.510 --> 20:25.510
所以说它不可能不可能重新渲染

20:25.510 --> 20:27.510
那里看一下

20:27.510 --> 20:29.510
App 它只会运行一次

20:29.510 --> 20:31.510
然后我们继续往下看

20:31.510 --> 20:33.510
继续往下看

20:33.510 --> 20:35.510
然后这边

20:35.510 --> 20:37.510
到这个组件里面来

20:37.510 --> 20:39.510
Task Container

20:39.510 --> 20:41.510
这个组件里面来

20:41.510 --> 20:43.510
它里面有个Render

20:43.510 --> 20:45.510
它是个内组件

20:45.510 --> 20:47.510
这个组件里面的Render

20:47.510 --> 20:49.510
它会运行多少次呢

20:49.510 --> 20:51.510
Task Container Render

20:51.510 --> 20:53.510
会运行多少次呢

20:53.510 --> 20:55.510
首先第一次 第一次加载

20:55.510 --> 20:57.510
它副组件

20:57.510 --> 20:59.510
App里面使用它

20:59.510 --> 21:01.510
在App里面使用它

21:01.510 --> 21:03.510
因此它第一次加载了

21:03.510 --> 21:05.510
是不是

21:05.510 --> 21:07.510
会运行一次Render

21:07.510 --> 21:09.510
会运行出Render

21:09.510 --> 21:11.510
Render运行完了之后

21:11.510 --> 21:13.510
第一次运行Render

21:13.510 --> 21:15.510
运行完了之后

21:15.510 --> 21:17.510
然后是不是要进入生命周期

21:17.510 --> 21:19.510
第一次挂载阶段

21:19.510 --> 21:21.510
Render完了之后

21:21.510 --> 21:23.510
就是要运行生命周期函数

21:23.510 --> 21:25.510
ComponentDMount

21:25.510 --> 21:27.510
运行生命周期函数

21:27.510 --> 21:29.510
运行这个函数的时候

21:29.510 --> 21:31.510
那么这个函数里面它最终是不是改变了状态

21:31.510 --> 21:33.510
改变了状态是不是又要重新运行Render

21:33.510 --> 21:35.510
对不对

21:35.510 --> 21:37.510
所以它会渲染两次

21:37.510 --> 21:39.510
第一次渲染的时候它是个空数组

21:39.510 --> 21:41.510
第一次渲染的时候是个空数组

21:41.510 --> 21:43.510
后边我们这里

21:43.510 --> 21:45.510
这样子写吧

21:45.510 --> 21:47.510
数组长度

21:47.510 --> 21:49.510
为什么呢

21:49.510 --> 21:51.510
第二次渲染的时候

21:51.510 --> 21:53.510
它第一次渲染的时候是个空数组

21:53.510 --> 21:55.510
它第一次渲染的时候是个空数组

21:55.510 --> 21:57.510
那么后边我们DMount里

21:57.510 --> 21:59.510
比方说这里是阿加克斯请求

21:59.510 --> 22:01.510
得到了一些数据了

22:01.510 --> 22:03.510
那么过一会我就再次再次

22:03.510 --> 22:05.510
把一个新的数据给它

22:05.510 --> 22:07.510
那么这样子一来它数据

22:07.510 --> 22:09.510
它又要导致重新渲染

22:09.510 --> 22:11.510
因为状态变了

22:11.510 --> 22:13.510
你看它是不是渲染两次

22:13.510 --> 22:15.510
第一次渲染的时候长度为0

22:15.510 --> 22:17.510
第二次渲染的时候长度为10

22:17.510 --> 22:19.510
是效率优化

22:19.510 --> 22:21.510
它运行的几次都要搞签要搞清楚

22:21.510 --> 22:23.510
你也是命周期都没有搞清楚的话

22:23.510 --> 22:25.510
那更加谈不上什么新的优化了

22:25.510 --> 22:27.510
接下来是下里边了

22:27.510 --> 22:29.510
它里边不是一个task list

22:29.510 --> 22:31.510
对吧

22:31.510 --> 22:33.510
有这么一个就是这个东西

22:33.510 --> 22:35.510
就这么一个组件

22:35.510 --> 22:37.510
这个组件倒是没有状态

22:37.510 --> 22:39.510
那么它里边有什么

22:39.510 --> 22:41.510
有那个署项

22:41.510 --> 22:43.510
那么task container

22:43.510 --> 22:45.510
在渲染的时候是不是也会导致

22:45.510 --> 22:47.510
它也跟着渲染

22:47.510 --> 22:49.510
你在渲染的时候你不是要反悔它吗

22:49.510 --> 22:51.510
反悔它是不是要重新渲染一次

22:51.510 --> 22:53.510
对不对

22:53.510 --> 22:55.510
于是它也会跟着重新渲染

22:55.510 --> 22:57.510
它也会跟着重新渲染

22:57.510 --> 22:59.510
那么它又怎么去来渲染呢

22:59.510 --> 23:03.400
它渲染多少次呢

23:03.400 --> 23:05.400
我们这里打印一下

23:05.400 --> 23:07.400
这里就是task list

23:07.400 --> 23:09.400
它在重新渲染

23:09.400 --> 23:11.400
我们来看它渲染了几次

23:11.400 --> 23:13.400
你觉得它渲染了几次

23:13.400 --> 23:15.400
倒出来

23:15.400 --> 23:17.400
为什么渲染了两次

23:17.400 --> 23:19.400
因为它的副组件task container

23:19.400 --> 23:21.400
渲染了

23:21.400 --> 23:23.400
那么导致了它重新渲染

23:23.400 --> 23:25.400
对吧

23:25.400 --> 23:27.400
所以说我们这里重新渲染这一块

23:27.400 --> 23:29.400
目前是由谁触发的

23:29.400 --> 23:31.400
最终的根本原因是由它触发的

23:31.400 --> 23:33.400
它重新渲染了

23:33.400 --> 23:35.400
导致了它也跟着重新渲染

23:35.400 --> 23:37.400
那么它重新渲染的时候

23:37.400 --> 23:39.400
我们再看下面

23:39.400 --> 23:41.400
它在重新渲染的时候干了什么事呢

23:41.400 --> 23:43.400
它是不是又跟用map

23:43.400 --> 23:45.400
又生成了一串这个东西

23:45.400 --> 23:47.400
对不对

23:47.400 --> 23:49.400
用map又生成了这么一串这个东西

23:49.400 --> 23:51.400
于是呢

23:51.400 --> 23:53.400
于是呢

23:53.400 --> 23:55.400
这个玩意儿

23:55.400 --> 23:57.400
是不是又要到这里边来了

23:57.400 --> 23:59.400
对吧 要到这里边来了

23:59.400 --> 24:01.400
到这里边来它又要导致重新渲染

24:01.400 --> 24:03.400
输出

24:03.400 --> 24:05.400
不要说task

24:05.400 --> 24:07.400
那么它会重新渲染几次呢

24:07.400 --> 24:09.400
你看着

24:09.400 --> 24:11.400
你看的是这样子

24:11.400 --> 24:13.400
结果它渲染了10次

24:13.400 --> 24:15.400
为什么不是20次呢

24:15.400 --> 24:17.400
不是渲染了两次吗

24:17.400 --> 24:19.400
第一次渲染的时候长度为0

24:19.400 --> 24:21.400
长度是0

24:21.400 --> 24:23.400
长度是0的话

24:23.400 --> 24:25.400
那么你在渲染这个东西的时候

24:25.400 --> 24:27.400
是不是得不到任何一个task

24:27.400 --> 24:29.400
第一次是得不到任何一个task

24:29.400 --> 24:31.400
得不到这个组件对吧

24:31.400 --> 24:33.400
那么就结束了对不对

24:33.400 --> 24:35.400
那么后边第二次渲染的时候

24:35.400 --> 24:37.400
因为它的数组长度为10

24:37.400 --> 24:39.400
给它加了一些数据

24:39.400 --> 24:41.400
它已经渲染的时候了

24:41.400 --> 24:43.400
渲染了这个组件

24:43.400 --> 24:45.400
它里边的组件就有10个了

24:45.400 --> 24:47.400
这里边就有10个了

24:47.400 --> 24:49.400
我这里划不下来就划3个

24:49.400 --> 24:51.400
那么这里边每一个是不是相当于是

24:51.400 --> 24:53.400
第一次渲染对吧

24:53.400 --> 24:55.400
这里边每一个就相当于是第一次渲染

24:55.400 --> 24:57.400
那么这里的它也算渲染了

24:57.400 --> 24:59.400
没问题吧

24:59.400 --> 25:01.400
这就是我们的目前的渲染过程

25:01.400 --> 25:03.400
其实目前渲染过程没有什么问题

25:03.400 --> 25:05.400
你觉得现在目前需要新能油化吗

25:05.400 --> 25:07.400
不需要

25:07.400 --> 25:09.400
非常正常你看它里边

25:09.400 --> 25:11.400
你看它改变了数据

25:11.400 --> 25:13.400
你说它要不要选与重新宣传

25:13.400 --> 25:15.400
你说对于它而言

25:15.400 --> 25:17.400
它这个数据变了

25:17.400 --> 25:19.400
要不要重新宣传

25:19.400 --> 25:21.400
肯定要重新宣传

25:21.400 --> 25:23.400
你不能去阻止它

25:23.400 --> 25:25.400
那么这个渲染过程是正常的

25:25.400 --> 25:27.400
就该重新宣传一次

25:27.400 --> 25:29.400
那么这样子你给它的数组变化了

25:29.400 --> 25:31.400
你看给它的数组变化了

25:31.400 --> 25:33.400
那么它的数组变化了

25:33.400 --> 25:35.400
它是不是要重新宣传

25:35.400 --> 25:37.400
它是没有什么问题的

25:37.400 --> 25:39.400
关键的问题在后边

25:39.400 --> 25:41.400
我们给这个组建

25:41.400 --> 25:43.400
Task Container

25:43.400 --> 25:45.400
给这个组建加上一个东西

25:45.400 --> 25:47.400
加上啥呢

25:47.400 --> 25:49.400
给它加上这么一个东西

25:49.400 --> 25:51.400
我们再写一个组建

25:51.400 --> 25:53.400
因为我要解释清楚这个现象

25:53.400 --> 25:55.400
我就必须要把组建多写一点

25:55.400 --> 25:57.400
形成这么一种结构

25:57.400 --> 25:59.400
这个组建是为了添加

25:59.400 --> 26:01.400
ADD

26:01.400 --> 26:03.400
添加一个任务

26:03.400 --> 26:05.400
那么这里

26:05.400 --> 26:07.400
我们写上这么一个内组建

26:07.400 --> 26:09.400
这个地方

26:09.400 --> 26:11.400
里边我们写上一个DIV

26:11.400 --> 26:13.400
这个DIV里面就有一个Input元素

26:13.400 --> 26:15.400
然后把它变成一个受控的

26:15.400 --> 26:17.400
State

26:17.400 --> 26:19.400
变成一个受控的

26:19.400 --> 26:21.400
然后这里边写上

26:21.400 --> 26:23.400
当前的任务名称

26:23.400 --> 26:25.400
任务名称就有支付串

26:25.400 --> 26:27.400
那么这里我们就写上

26:27.400 --> 26:29.400
Name

26:29.400 --> 26:31.400
Value

26:31.400 --> 26:33.400
Name

26:33.400 --> 26:35.400
Value这个字

26:35.400 --> 26:37.400
接下来

26:37.400 --> 26:39.400
我们这里再写上

26:39.400 --> 26:41.400
受控嘛对不对

26:41.400 --> 26:43.400
当我们改变的时候干嘛呢

26:43.400 --> 26:45.400
改变的时候

26:45.400 --> 26:47.400
我们要重新设置这个字

26:47.400 --> 26:49.400
重新设置这个字

26:49.400 --> 26:51.400
就是ZsetState

26:51.400 --> 26:53.400
Name

26:53.400 --> 26:55.400
要重新设置

26:55.400 --> 26:57.400
设置为多少?1点

26:57.400 --> 26:59.400
Target

26:59.400 --> 27:01.400
简单一点

27:01.400 --> 27:03.400
那么重新设置这个字

27:03.400 --> 27:05.400
然后呢再干嘛呢

27:05.400 --> 27:07.400
我们后面加个按钮

27:07.400 --> 27:09.400
加个按钮

27:09.400 --> 27:11.400
添加任务

27:11.400 --> 27:13.400
当我们点击这个按钮的时候

27:13.400 --> 27:15.400
干嘛呢

27:15.400 --> 27:17.400
当我们点击这个按钮的时候

27:17.400 --> 27:19.400
我要做一些事情来添加任务

27:19.400 --> 27:21.400
那么添加任务我做不了

27:21.400 --> 27:23.400
我只能通过事件扔出去

27:23.400 --> 27:25.400
那么这种写法我们是不是

27:25.400 --> 27:27.400
经常写过了

27:27.400 --> 27:29.400
属性里面有没有个事件

27:29.400 --> 27:31.400
NATD有没有这个事件

27:31.400 --> 27:33.400
如果有的话那么我调用一下这个事件

27:33.400 --> 27:35.400
我把这个任务

27:35.400 --> 27:37.400
我给你传一个任务对象进来

27:37.400 --> 27:39.400
任务对象呢就Name的属性了

27:39.400 --> 27:41.400
为什么呢

27:41.400 --> 27:43.400
就是ZsetState

27:43.400 --> 27:45.400
就是任务对象的任务的名称

27:45.400 --> 27:47.400
是否完成了那么就给他个默认值嘛

27:47.400 --> 27:49.400
没有完成新加的任务都是没有完成的

27:49.400 --> 27:51.400
能看懂吗

27:51.400 --> 27:53.400
好好看一下

27:53.400 --> 27:55.400
这个还蛮你得看懂啊

27:55.400 --> 27:57.400
当我们点击的时候呢

27:57.400 --> 27:59.400
如果你有这个事件

27:59.400 --> 28:01.400
那么我调用这个事件

28:01.400 --> 28:03.400
给他传一个对象进去

28:03.400 --> 28:05.400
那边注册事件的人

28:05.400 --> 28:07.400
就可以接受到这个对象了

28:07.400 --> 28:09.400
为了方便

28:09.400 --> 28:11.400
我们后面还可以把这个就是

28:11.400 --> 28:13.400
任务的名称清空嘛

28:13.400 --> 28:15.400
ZsetState

28:15.400 --> 28:17.400
把任务的名称清空

28:17.400 --> 28:19.400
Name一把清空

28:19.400 --> 28:21.400
那么我们就写好这么一个组件了

28:21.400 --> 28:23.400
AgedTask这个组件

28:23.400 --> 28:25.400
我们就去使用这个组件

28:25.400 --> 28:27.400
现在组件数又变了

28:27.400 --> 28:29.400
Task

28:29.400 --> 28:31.400
AgedTask

28:31.400 --> 28:33.400
这一边呢

28:33.400 --> 28:35.400
我们再加上一个AgedTask

28:35.400 --> 28:37.400
加上这么一个组件

28:37.400 --> 28:39.400
这个组件里面呢

28:39.400 --> 28:41.400
我们该提供一个事件

28:41.400 --> 28:43.400
叫做OnAged

28:43.400 --> 28:45.400
当我们

28:45.400 --> 28:47.400
添加任务的时候

28:47.400 --> 28:49.400
你会给我传一个任务对象进来

28:49.400 --> 28:51.400
你会给我新传一个任务对象进来

28:51.400 --> 28:53.400
加到这个数组里面

28:53.400 --> 28:55.400
但是你最好不要这样写

28:55.400 --> 28:57.400
他不是说不能

28:57.400 --> 28:59.400
这里和我们会解释原因

28:59.400 --> 29:01.400
为什么不推荐大家这样写

29:01.400 --> 29:03.400
当然你可以这样写

29:03.400 --> 29:05.400
再重新调用ZsetState

29:05.400 --> 29:07.400
但是最好不要

29:07.400 --> 29:09.400
我们这里用这种写法

29:09.400 --> 29:11.400
我们这里和就知道原因了

29:11.400 --> 29:13.400
不着急

29:13.400 --> 29:15.400
Task

29:15.400 --> 29:17.400
复制一个新的数组

29:17.400 --> 29:19.400
把原来的数组展开

29:19.400 --> 29:21.400
设置新的

29:21.400 --> 29:23.400
新的状态

29:23.400 --> 29:25.400
保存

29:25.400 --> 29:28.900
再来看一下

29:28.900 --> 29:30.900
这是之前Render的情况

29:30.900 --> 29:32.900
接下来我们再看

29:32.900 --> 29:34.900
添加任务

29:34.900 --> 29:36.900
我们先把这个组件数画一下

29:36.900 --> 29:40.540
现在组件数里面变成这种情况

29:40.540 --> 29:42.540
现在组件数里面变成这种情况

29:42.540 --> 29:44.540
现在多了一个组件了

29:44.540 --> 29:46.540
名字叫做AdTask

29:46.540 --> 29:55.100
多了这么一个组件

29:55.100 --> 29:57.100
接下来

29:57.100 --> 29:59.100
我们看着

29:59.100 --> 30:01.100
当我们点击这个按钮的时候

30:01.100 --> 30:03.100
是不是最终

30:03.100 --> 30:05.100
它会做一件事,就是setState

30:05.100 --> 30:07.100
点击这个按钮的时候

30:07.100 --> 30:09.100
它最终会触发这个时间

30:09.100 --> 30:11.100
它会调整这个东西

30:11.100 --> 30:13.100
于是

30:13.100 --> 30:15.100
状态是不是变了

30:15.100 --> 30:17.100
状态变了,它是不是要重新选择

30:17.100 --> 30:19.100
我们在这里也加上

30:19.100 --> 30:21.100
AdTask

30:21.100 --> 30:23.100
Render

30:23.100 --> 30:25.100
保存

30:25.100 --> 30:27.100
看着

30:27.100 --> 30:29.100
目前AdTask Render

30:29.100 --> 30:31.100
它运行了两次

30:31.100 --> 30:33.100
因为它的副组件运行了两次

30:33.100 --> 30:35.100
好,接下来再来再看

30:35.100 --> 30:37.100
其实现在已经发现一些问题了

30:37.100 --> 30:39.100
你看第二次运行这个东西有没有必要

30:39.100 --> 30:41.100
第一次运行

30:41.100 --> 30:43.100
把它渲染出来,AdTask就这一部分

30:43.100 --> 30:45.100
要知道是哪一部分

30:45.100 --> 30:47.100
这一部分

30:47.100 --> 30:49.100
这一部分

30:49.100 --> 30:51.100
那么它渲染出来

30:51.100 --> 30:53.100
是不是运行了一次,第一次没问题

30:53.100 --> 30:55.100
那么第二次有没有必要重新选择

30:55.100 --> 30:57.100
你觉得有没有必要重新选择

30:57.100 --> 30:59.100
它没有变化

30:59.100 --> 31:01.100
但是虽然说它的状态发生变化

31:01.100 --> 31:03.100
导致了它自己重新选择,没问题

31:03.100 --> 31:05.100
但是它的状态没变化

31:05.100 --> 31:07.100
其实已经没有必要重新选择了

31:07.100 --> 31:09.100
好,那么接下来我们再看一下

31:09.100 --> 31:11.100
这里我们写上一个任务

31:11.100 --> 31:13.100
随便写一个

31:13.100 --> 31:15.100
你会发现的,这个任务里面

31:15.100 --> 31:17.100
我们写的这个东西,它不断的在重新选择

31:17.100 --> 31:19.100
AdTask

31:19.100 --> 31:21.100
这个没问题吧,这个是没问题的,这个是正常的

31:21.100 --> 31:23.100
为什么呢,因为它里面有受控组建

31:23.100 --> 31:25.100
AdTask里面

31:25.100 --> 31:27.100
你改变了这个文门框的数据

31:27.100 --> 31:29.100
你改变了这个数据,实际上是改变了啥呢

31:29.100 --> 31:31.100
改变了这个name,对吧

31:31.100 --> 31:33.100
改变了这个状态过后,它是应该重新选择

31:33.100 --> 31:35.100
它自己的状态发生变化了

31:35.100 --> 31:37.100
它肯定要重新选择

31:37.100 --> 31:39.100
不重新选择的话,这个input里面就看不到东西了

31:39.100 --> 31:41.100
这个没问题,这个是没问题的

31:41.100 --> 31:44.790
关键是我们点添加任务

31:44.790 --> 31:46.790
点添加任务

31:46.790 --> 31:48.790
点了添加任务过后

31:48.790 --> 31:50.790
副组建重新选择了

31:50.790 --> 31:52.790
这个状态数组变多了

31:52.790 --> 31:54.790
它自己要重新选择,没问题

31:54.790 --> 31:56.790
它

31:56.790 --> 31:58.790
要重新选择,它要重新选择也行吧

31:58.790 --> 32:00.790
也行

32:00.790 --> 32:02.790
为什么说也行呢,因为我这里把这个东西清空了

32:02.790 --> 32:04.790
把这个name清空了

32:04.790 --> 32:06.790
点击过后把自己的状态也清空了

32:06.790 --> 32:08.790
它重新选择也行吧,也说得过去

32:08.790 --> 32:10.790
那么task list重新选择

32:10.790 --> 32:12.790
肯定它里面要数组变了

32:12.790 --> 32:14.790
它要重新选择,也说得过去

32:14.790 --> 32:16.790
但是下面的task,它选择了11次

32:16.790 --> 32:18.790
有这个必要吗

32:18.790 --> 32:20.790
就下面的每一个task

32:20.790 --> 32:22.790
它又重新选择了一次

32:22.790 --> 32:24.790
你看任务1变变

32:24.790 --> 32:26.790
任务2变变

32:26.790 --> 32:28.790
这时候都没变化

32:28.790 --> 32:30.790
没有变化,你干嘛去重新选择呢

32:30.790 --> 32:32.790
没有必要

32:32.790 --> 32:34.790
你没有必要重新去选择,明白这个意思吗

32:34.790 --> 32:36.790
你只是多了一项而已

32:36.790 --> 32:38.790
你没有必要重新选择

32:38.790 --> 32:40.790
我们就要说明这个问题

32:40.790 --> 32:42.790
那么比方说

32:42.790 --> 32:44.790
我这个添加任务这个组建里边

32:44.790 --> 32:46.790
它没有这句话

32:46.790 --> 32:48.790
设置新的状态的句话

32:48.790 --> 32:50.790
不用清空,假设不用清空

32:50.790 --> 32:52.790
看着啊

32:52.790 --> 32:54.790
我这里写个任务

32:54.790 --> 32:56.790
添加任务

32:56.790 --> 32:58.790
你看它还是重新选择了,那么它变化了吗

32:58.790 --> 33:00.790
它是不是没有变化呀

33:00.790 --> 33:02.790
这个玩意它自己没有发生任何变化

33:02.790 --> 33:04.790
但是它也跟着重新选择了

33:04.790 --> 33:06.790
大家现在呢

33:06.790 --> 33:08.790
我建议你啊

33:08.790 --> 33:10.790
如果你停着有点晕的话

33:10.790 --> 33:12.790
那么你肯定是没把这个组建结构

33:12.790 --> 33:14.790
我们这里的组建结构搞清楚

33:14.790 --> 33:16.790
不要着急往下看

33:16.790 --> 33:18.790
你先把自己把写一遍

33:18.790 --> 33:20.790
就是这个东西简单的功能先写一遍

33:20.790 --> 33:22.790
写完了之后再接着往下看

33:22.790 --> 33:24.790
好吧,把这个组建结构

33:24.790 --> 33:26.790
我这里写的粒子这个组建结构搞清楚

33:26.790 --> 33:28.790
那么现在的情况是

33:28.790 --> 33:30.790
它的状态发生了变化

33:30.790 --> 33:32.790
它就不管3721

33:32.790 --> 33:34.790
它里边下面不管是什么东西

33:34.790 --> 33:36.790
你只要是我的组建

33:36.790 --> 33:38.790
后来组建,全部发生变化

33:38.790 --> 33:40.790
首先它的组建发生变化

33:40.790 --> 33:42.790
重新选择了

33:42.790 --> 33:44.790
直接组建了也跟着重新选择

33:44.790 --> 33:46.790
全部重新选择了

33:46.790 --> 33:48.790
它会导致这么一个

33:48.790 --> 33:50.790
整个这个动物树

33:50.790 --> 33:52.790
这个虚拟动物树跟着重新选择

33:52.790 --> 33:54.790
跟着重新选择了一遍

33:54.790 --> 33:56.790
但是实际上我们刚才可以看到

33:56.790 --> 33:58.790
它没有发生变化的时候

33:58.790 --> 34:00.790
就不要重新选择了

34:00.790 --> 34:02.790
而它里边,Task里边没有发生变化的时候

34:02.790 --> 34:04.790
就不要重新选择了

34:04.790 --> 34:06.790
所以说我们现在要做什么呢

34:06.790 --> 34:08.790
其实我们现在要做的是这么一件事

34:08.790 --> 34:10.790
优化

34:10.790 --> 34:12.790
怎么来优化呢

34:12.790 --> 34:16.790
就是如果一个组建的属性和货

34:16.790 --> 34:18.790
和状态

34:18.790 --> 34:22.790
属性和状态都没有发生变化

34:22.790 --> 34:28.790
该组建的渲染是没有必要的

34:28.790 --> 34:30.790
该组建重新渲染

34:30.790 --> 34:32.790
就重新渲染

34:32.790 --> 34:34.790
该组建是没有必要的

34:34.790 --> 34:36.790
你觉得是不是这个道理

34:36.790 --> 34:38.790
你看啊

34:38.790 --> 34:40.790
我们这里这个任务

34:40.790 --> 34:42.790
那么它里边有一个

34:42.790 --> 34:44.790
有一个状态

34:44.790 --> 34:46.790
有一个属性

34:46.790 --> 34:48.790
就是任务的名称任务的适合完成

34:48.790 --> 34:50.790
只要属性没有发生变化

34:50.790 --> 34:52.790
你选择干嘛呢

34:52.790 --> 34:54.790
重新选择干嘛呢

34:54.790 --> 34:56.790
你就用之前的呗

34:56.790 --> 34:58.790
你干嘛要重新选择的

34:58.790 --> 35:00.790
是不是没有必要重新选择

35:00.790 --> 35:02.790
我们现在就要做这么一件事

35:02.790 --> 35:04.790
那么现在我们要研究的是

35:04.790 --> 35:06.790
什么叫做变化呢

35:06.790 --> 35:08.790
我们就这样子来处理

35:08.790 --> 35:10.790
就是说它里面不相等变化就是不相等

35:10.790 --> 35:12.790
那么现在呢

35:12.790 --> 35:14.790
我来优化一下这个task逐渐

35:14.790 --> 35:16.790
来优化一下这个task逐渐

35:16.790 --> 35:18.790
怎么来优化呢

35:18.790 --> 35:20.790
我们直接使用生命周期函数

35:20.790 --> 35:24.790
叫做component should update

35:24.790 --> 35:26.790
对的

35:26.790 --> 35:28.790
component should

35:28.790 --> 35:32.230
叫什么

35:32.230 --> 35:34.230
should component update

35:34.230 --> 35:36.230
写这么一个函数

35:36.230 --> 35:38.230
这个函数里面我们之前是不是说过

35:38.230 --> 35:40.230
一个生命周期函数

35:40.230 --> 35:42.230
它返回什么返回 to

35:42.230 --> 35:44.230
或者是force

35:44.230 --> 35:46.230
当它返回force的时候呢

35:46.230 --> 35:48.230
那么就不会导致重新选择

35:48.230 --> 35:50.230
那么我们现在要做的就是

35:50.230 --> 35:52.230
判断在适当的情况下

35:52.230 --> 35:54.230
我就不要返回 to了

35:54.230 --> 35:56.230
返回force

35:56.230 --> 35:58.230
它默认情况下还是什么都不管

35:58.230 --> 36:00.230
直接返回 to

36:00.230 --> 36:02.230
在这里边有些数据我们可以用

36:02.230 --> 36:04.230
什么数据呢

36:04.230 --> 36:06.230
这个地方呢

36:06.230 --> 36:08.230
这个东西呢就是你现在的属性

36:08.230 --> 36:10.230
然后呢

36:10.230 --> 36:12.230
这个东西呢就是你现在的状态

36:12.230 --> 36:14.230
对吧

36:14.230 --> 36:16.230
当然它这里边没有状态

36:16.230 --> 36:18.230
那么我们假设它有状态吗

36:18.230 --> 36:20.230
我们尽量的把它写成一个通用的东西

36:20.230 --> 36:22.230
尽量写成一个通用的东西

36:22.230 --> 36:24.230
那么比方说我们这里写代码的话

36:24.230 --> 36:26.230
怎么来写

36:26.230 --> 36:28.230
其实文就是什么

36:28.230 --> 36:31.670
如果

36:31.670 --> 36:33.670
不相等

36:33.670 --> 36:38.140
就是

36:38.140 --> 36:40.140
this props

36:40.140 --> 36:42.140
和什么 next props

36:42.140 --> 36:44.140
这两个属性

36:44.140 --> 36:46.140
比较出来

36:46.140 --> 36:48.140
它们是没有变化的

36:48.140 --> 36:50.140
就是不相等的

36:50.140 --> 36:52.140
或者说

36:52.140 --> 36:54.140
或者这样吧

36:54.140 --> 36:56.140
它们两个是相等的

36:56.140 --> 36:58.140
它们两个没有变化

36:58.140 --> 37:01.700
如果它们两个没有变化

37:01.700 --> 37:03.700
并且呢

37:03.700 --> 37:05.700
这个 next state

37:05.700 --> 37:07.700
和什么呢

37:07.700 --> 37:09.700
this state

37:09.700 --> 37:11.700
它们两个也没有变化

37:11.700 --> 37:13.700
如果这两个东西都没有变化

37:13.700 --> 37:15.700
是不是反回 force

37:15.700 --> 37:17.700
对吧否则的话反回去

37:17.700 --> 37:19.700
我们只要做这么一件事

37:19.700 --> 37:21.700
要做的事情就这么一件事

37:21.700 --> 37:23.700
那么其实我们要比较的是啥

37:23.700 --> 37:25.700
就是两个对象

37:25.700 --> 37:27.700
比较的就是两个对象是否

37:27.700 --> 37:29.700
相等

37:29.700 --> 37:31.700
比较的就是两个对象是否相等

37:31.700 --> 37:33.700
那么怎么比较呢

37:33.700 --> 37:35.700
写上这么一个就是

37:35.700 --> 37:37.700
帮助含书

37:37.700 --> 37:39.700
帮助含书

37:39.700 --> 37:41.700
给它取媒 help

37:41.700 --> 37:43.700
这边导说一个含书

37:43.700 --> 37:45.700
导说一个含书叫做 equal

37:45.700 --> 37:47.700
objects

37:47.700 --> 37:51.270
equal

37:51.270 --> 37:56.120
写上这么一个含书

37:56.120 --> 37:58.120
你给我两个对象

37:58.120 --> 38:00.120
obj1obj2我来判断

38:00.120 --> 38:02.120
帮你判断两个对象是否相等

38:02.120 --> 38:04.120
这里我们咋比较呢

38:04.120 --> 38:06.120
这里比较的话

38:06.120 --> 38:08.120
最简单最简单的方式

38:08.120 --> 38:10.120
我们就可以用这种方式

38:10.120 --> 38:12.120
便利obj1的所有

38:12.120 --> 38:14.120
数相

38:14.120 --> 38:16.120
便利obj1的所有数相

38:16.120 --> 38:18.120
如果我发现obj1的

38:18.120 --> 38:20.120
数相跟obj2的

38:20.120 --> 38:22.120
数相不一样

38:22.120 --> 38:24.120
跟obj2的数相不一样

38:24.120 --> 38:26.120
发现这两个数性的值不一样

38:26.120 --> 38:28.120
那么是不是两个对象有差异

38:28.120 --> 38:30.120
对不对

38:30.120 --> 38:32.120
是有差异

38:32.120 --> 38:34.120
有差异的话我们反回 force

38:34.120 --> 38:36.120
当然这两个我们也可以使用

38:36.120 --> 38:38.120
obj1的

38:38.120 --> 38:40.120
obj1的

38:40.120 --> 38:42.120
obj1的

38:42.120 --> 38:44.120
这个数相

38:44.120 --> 38:46.120
obj2的这个数相

38:46.120 --> 38:48.120
得到

38:48.120 --> 38:50.120
如果这两个数相不相等

38:50.120 --> 38:52.120
不相等的话我们反回 force

38:52.120 --> 38:54.120
就完成了

38:54.120 --> 38:56.120
只要有一个数性不相等

38:56.120 --> 38:58.120
我们就认为这两个都一样不一样

38:58.120 --> 39:00.120
如果比较晚了过后都没有进入

39:00.120 --> 39:02.120
判断都没有反回 force

39:02.120 --> 39:04.120
好我们就这样做

39:04.120 --> 39:06.120
那么你看一下我们这种做法

39:06.120 --> 39:08.120
它只比较了这个对象的

39:08.120 --> 39:10.120
一层的数相

39:10.120 --> 39:12.120
如果这个数相它还是又是个对象

39:12.120 --> 39:14.120
比方它这个东西又是个对象

39:14.120 --> 39:16.120
那么这个对象里边

39:16.120 --> 39:18.120
它有什么数相我们就没有比较了

39:18.120 --> 39:20.120
比方说吧我们这里的对象是这个样子

39:20.120 --> 39:22.120
NAMS

39:22.120 --> 39:24.120
然后还有什么EASYFELICY

39:24.120 --> 39:26.120
对吧

39:26.120 --> 39:28.120
是这么一个对象

39:28.120 --> 39:30.120
比较对象的时候我们只比较这个数相值

39:30.120 --> 39:32.120
那如果这个对象里边还有一个数相

39:32.120 --> 39:34.120
它又是个对象

39:34.120 --> 39:36.120
这个对象里边还有对象

39:36.120 --> 39:38.120
那么像这个东西我们就没有比较了

39:38.120 --> 39:40.120
我们只比较这个值是不是一样的

39:40.120 --> 39:42.120
如果它是一个对象的话

39:42.120 --> 39:44.120
里边是什么东西我们就没有比较了

39:44.120 --> 39:46.120
这种比较的方式叫做前比较

39:48.120 --> 39:50.120
叫做前比较

39:52.120 --> 39:54.120
只比较对象的第一层数相

39:54.120 --> 39:56.120
只比较对象的

39:56.120 --> 39:58.120
第一层

39:58.120 --> 40:00.120
数相

40:00.120 --> 40:02.120
好

40:02.120 --> 40:04.120
看着我们现在已经写好了

40:04.120 --> 40:06.120
那么这边我们来用一下

40:06.120 --> 40:08.120
把导入进来

40:10.120 --> 40:12.120
返回上级目楼

40:12.120 --> 40:14.120
有Tears

40:14.120 --> 40:16.120
这里面有个Objects

40:16.120 --> 40:18.120
一括

40:18.120 --> 40:20.120
把这两个放这

40:20.120 --> 40:22.120
那么现在我们就写了

40:22.120 --> 40:24.120
就进行了一下优化

40:24.120 --> 40:26.120
如果人两个对象是一样的

40:26.120 --> 40:28.120
那我就返回Force

40:28.120 --> 40:30.120
你就不用更新了

40:30.120 --> 40:32.120
不用重新写来了

40:32.120 --> 40:34.120
否则的话就重新写了

40:34.120 --> 40:36.120
保存

40:36.120 --> 40:40.070
那么我们现在看到Task里面

40:40.070 --> 40:42.070
第一次选量的实施没问题吧

40:42.070 --> 40:44.070
Task选量的实施

40:44.070 --> 40:46.070
第一次选量的实施

40:46.070 --> 40:48.070
为什么要选量的实施

40:48.070 --> 40:50.070
因为有这么一些10个任务

40:50.070 --> 40:52.070
有10个任务出现了

40:52.070 --> 40:54.070
这个时候都还没有用到这个函数

40:54.070 --> 40:56.070
都还没有用到这个函数

40:56.070 --> 41:00.070
是否要重新选的

41:00.070 --> 41:02.070
就是这个

41:02.070 --> 41:03.070
叫什么

41:03.070 --> 41:04.070
叫做Task

41:04.070 --> 41:05.070
是否要重新选的

41:05.070 --> 41:06.070
你看一下

41:06.070 --> 41:08.070
是不是没有运行这个函数

41:08.070 --> 41:10.070
这是Task第一次选的

41:10.070 --> 41:12.070
好,接下来我们再看

41:12.070 --> 41:14.070
添加任务

41:14.070 --> 41:16.070
随便写个

41:16.070 --> 41:18.070
点添加

41:18.070 --> 41:22.280
大家可以看到

41:22.280 --> 41:24.280
我们运行的10次Task

41:24.280 --> 41:26.280
是否要重新选的

41:26.280 --> 41:27.280
Task任务吗

41:27.280 --> 41:28.280
多了一个

41:28.280 --> 41:29.280
多了一个是不是第一次选量的

41:29.280 --> 41:30.280
一个新的组件

41:30.280 --> 41:32.280
它是用你看这里

41:32.280 --> 41:34.280
Task List里面

41:34.280 --> 41:35.280
Task List里面

41:35.280 --> 41:36.280
你看这里

41:36.280 --> 41:37.280
是不是Maple

41:37.280 --> 41:38.280
它多了一个东西

41:38.280 --> 41:40.280
根据数组来映射出来

41:40.280 --> 41:41.280
数组变成11项了

41:41.280 --> 41:42.280
与此它多了一个组件了

41:42.280 --> 41:44.280
那么之前的组件

41:44.280 --> 41:46.280
它是要更新

41:46.280 --> 41:47.280
而不是要新

41:47.280 --> 41:48.280
不是要新增

41:48.280 --> 41:49.280
而是要更新

41:49.280 --> 41:50.280
之前的10个

41:50.280 --> 41:52.280
以前应存在的10个组件

41:52.280 --> 41:54.280
它要决定是否要更新

41:54.280 --> 41:55.280
那么它会运行

41:55.280 --> 41:57.280
Shoot Component Update

41:57.280 --> 41:58.280
这个函数

41:58.280 --> 41:59.280
它运行的10次

41:59.280 --> 42:01.280
但是新的组件是第一次选择的

42:01.280 --> 42:03.280
所以新的组件有一个Task Render

42:03.280 --> 42:04.280
那么你看一下

42:04.280 --> 42:06.280
之前的组件有没有更新

42:06.280 --> 42:08.280
之前的组件有没有更新

42:08.280 --> 42:10.280
它只运行了一次Task Render

42:10.280 --> 42:12.280
那如果你看我们之前

42:12.280 --> 42:13.280
把这个函数

42:13.280 --> 42:14.280
如果没有这样的写

42:14.280 --> 42:15.280
没有这样的写

42:15.280 --> 42:16.280
就像以前一样

42:16.280 --> 42:17.280
默认情况下直接访为处的话

42:17.280 --> 42:20.280
那么你看一下这个结果

42:20.280 --> 42:21.280
我们这里随便写一个

42:21.280 --> 42:22.280
添加

42:22.280 --> 42:23.280
你看是不是运行了11次

42:23.280 --> 42:24.280
宣传的11次

42:24.280 --> 42:25.280
对不对

42:25.280 --> 42:26.280
以前的也重新宣传了

42:26.280 --> 42:27.280
但是现在呢

42:27.280 --> 42:29.280
我们加上这个判断之后

42:29.280 --> 42:31.280
那么现在呢

42:31.280 --> 42:33.280
这里新加一个任务

42:33.280 --> 42:36.280
你看它只运行的宣传了一次

42:36.280 --> 42:37.280
所以说现在呢

42:37.280 --> 42:38.280
我们的情况是这样子

42:38.280 --> 42:39.280
它的数据变了

42:39.280 --> 42:41.280
那么这些东西重新宣传

42:41.280 --> 42:42.280
宣传吧

42:42.280 --> 42:43.280
那么这些呢

42:43.280 --> 42:45.280
以前的就没有宣传了

42:45.280 --> 42:47.280
以前的就没有重新宣传了

42:47.280 --> 42:49.280
只宣传了最后一个

42:49.280 --> 42:50.280
看到没

42:50.280 --> 42:51.280
为什么没有重新宣传了

42:51.280 --> 42:53.280
因为以前里边的数据没有发生变化

42:53.280 --> 42:55.280
它的属性没有发生变化

42:55.280 --> 42:57.280
它的状态当然它没有状态

42:57.280 --> 42:58.280
它的状态也没有发生变化

42:58.280 --> 42:59.280
我们就可以通过这个

42:59.280 --> 43:01.280
should components updates

43:01.280 --> 43:03.280
对它进行的优化

43:03.280 --> 43:04.280
没问题吧

43:04.280 --> 43:05.280
对吧

43:05.280 --> 43:06.280
我们熟悉代码都可以搞定

43:06.280 --> 43:07.280
对不对

43:07.280 --> 43:08.280
实际上呢

43:08.280 --> 43:10.280
我们有没有必要重新熟悉代码

43:10.280 --> 43:11.280
没有必要

43:11.280 --> 43:12.280
没有必要

43:12.280 --> 43:14.280
pure components

43:14.280 --> 43:16.280
component

43:16.280 --> 43:20.280
是一个

43:20.280 --> 43:21.280
组件

43:21.280 --> 43:22.280
是一个组件

43:22.280 --> 43:24.280
如果

43:24.280 --> 43:27.280
某个组件继承自它

43:27.280 --> 43:29.280
继承自

43:29.280 --> 43:32.280
该组件

43:32.280 --> 43:39.280
则该组件的should components updates

43:39.280 --> 43:41.280
会

43:41.280 --> 43:43.280
会进行优化

43:43.280 --> 43:44.280
怎么的优化呢

43:44.280 --> 43:49.280
就是对属性和状态进行前比较

43:49.280 --> 43:53.660
前比较

43:53.660 --> 43:54.660
前比较

43:54.660 --> 43:56.660
如果相等

43:56.660 --> 43:59.660
则不会重新宣传

43:59.660 --> 44:00.660
就这么简单

44:00.660 --> 44:01.660
就这么简单

44:01.660 --> 44:02.660
pure components

44:02.660 --> 44:03.660
这个组件

44:03.660 --> 44:04.660
我们完全可以自己写

44:04.660 --> 44:06.660
完全可以自己写一个

44:06.660 --> 44:07.660
比方说吧

44:07.660 --> 44:08.660
我们这里就可以完全写一个

44:08.660 --> 44:09.660
自己的component组件

44:09.660 --> 44:10.660
你看

44:10.660 --> 44:11.660
做出来类似的效果

44:11.660 --> 44:12.660
对吧

44:12.660 --> 44:13.660
就是should components updates

44:13.660 --> 44:15.660
它不会就是做这么一件事

44:15.660 --> 44:17.660
那我们怎么来用呢

44:17.660 --> 44:18.660
用法非常非常简单

44:18.660 --> 44:20.660
你把这个东西导入进来

44:20.660 --> 44:22.660
不用导入component

44:22.660 --> 44:25.660
导入pure components

44:25.660 --> 44:27.660
你去继承它就完事了

44:27.660 --> 44:28.660
你去继承它就完事了

44:28.660 --> 44:29.660
所以说这个东西

44:29.660 --> 44:30.660
我就不用写了

44:30.660 --> 44:31.660
就不用写了

44:31.660 --> 44:32.660
这个东西也不用写了

44:32.660 --> 44:33.660
对吧

44:33.660 --> 44:34.660
也不用写了

44:34.660 --> 44:35.660
就完了

44:35.660 --> 44:36.660
就这么简单

44:36.660 --> 44:37.660
那么这个东西怎么做的呢

44:37.660 --> 44:38.660
就相当于是

44:38.660 --> 44:39.660
我们自己写的一个class

44:39.660 --> 44:41.660
pure components

44:41.660 --> 44:46.660
然后继承自component

44:46.660 --> 44:47.660
对吧

44:47.660 --> 44:48.660
然后写了一个

44:48.660 --> 44:49.660
这什么东西

44:49.660 --> 44:51.660
写了一个就是should components updates

44:51.660 --> 44:53.660
然后把刚才对代码写了一遍

44:53.660 --> 44:54.660
对不对

44:54.660 --> 44:55.660
那么它的纸类去继承自它

44:55.660 --> 44:57.660
那么是不是拥有了这东西

44:57.660 --> 44:58.660
就这么简单

44:58.660 --> 45:00.660
一点都不复杂

45:00.660 --> 45:01.660
我们自己写的话

45:01.660 --> 45:03.660
完全可以写一套东西出来

45:03.660 --> 45:04.660
保存

45:04.660 --> 45:05.660
咱们来看一下

45:05.660 --> 45:07.660
我们把它变成一个存柱建国后

45:07.660 --> 45:08.660
你看一下

45:08.660 --> 45:10.660
是不是可以拿到一样的效果

45:10.660 --> 45:11.660
天降任务你看

45:11.660 --> 45:12.660
是不是只是

45:12.660 --> 45:13.660
只运行的一次

45:13.660 --> 45:14.660
task render

45:14.660 --> 45:15.660
是吧

45:15.660 --> 45:16.660
只运行的一次

45:16.660 --> 45:17.660
那么同样的道理

45:17.660 --> 45:19.660
我们把存柱建也放到这

45:19.660 --> 45:22.660
放到task list里边来

45:22.660 --> 45:24.660
把它变成存柱建

45:24.660 --> 45:25.660
pure components

45:25.660 --> 45:27.660
把它变成存柱建

45:27.660 --> 45:28.660
那么它就可以保证什么

45:28.660 --> 45:30.660
task list

45:30.660 --> 45:32.660
task list它的数据没有更新的时候

45:32.660 --> 45:34.660
它是不会渲染的

45:34.660 --> 45:35.660
那么同样的道理

45:35.660 --> 45:37.660
我们把它放到ad task里边来

45:37.660 --> 45:41.660
把它这里写成一个pure component

45:41.660 --> 45:42.660
写成这个

45:42.660 --> 45:43.660
那么也可以保证

45:43.660 --> 45:45.660
它的状态只要没发生变化

45:45.660 --> 45:47.660
它的属性只要没发生变化

45:47.660 --> 45:49.660
那么它也不会更新

45:49.660 --> 45:51.660
好保存

45:51.660 --> 45:53.660
咱们再看一下

45:53.660 --> 45:55.660
一开始那里看

45:55.660 --> 45:59.660
pure components

45:59.660 --> 46:03.220
等一下

46:03.220 --> 46:05.220
为什么这个地方它运行的两次

46:05.220 --> 46:07.220
它不应该运行两次的

46:07.220 --> 46:08.220
它应该只运行一次

46:08.220 --> 46:09.220
你看这里运行的两次

46:09.220 --> 46:11.220
长度为0运行的一次

46:11.220 --> 46:13.220
速度长度为10运行的一次

46:13.220 --> 46:16.220
但是它属性没有发生变化

46:16.220 --> 46:18.220
状态也没有发生变化

46:18.220 --> 46:20.220
它为什么会运行两次呢

46:23.730 --> 46:25.730
明白了

46:25.730 --> 46:28.730
这个问题是我以前说过的一个问题

46:28.730 --> 46:30.730
就在这

46:30.730 --> 46:32.730
是这个玩意儿导致的

46:32.730 --> 46:34.730
这个玩意儿是不是它的属性

46:34.730 --> 46:35.730
对吧

46:35.730 --> 46:36.730
它不是需要属性吗

46:36.730 --> 46:37.730
对不对

46:37.730 --> 46:38.730
属性是个对象

46:38.730 --> 46:40.730
它的属性里边有一个unadd

46:40.730 --> 46:42.730
你这个unadd

46:42.730 --> 46:45.730
它是不是每一次传递的是一个新的函数

46:45.730 --> 46:46.730
对吧

46:46.730 --> 46:47.730
你这样子写的话

46:47.730 --> 46:49.730
它每一次传递的是一个新的函数

46:49.730 --> 46:51.730
所以说它导致了

46:51.730 --> 46:52.730
unadd每一次

46:52.730 --> 46:54.730
虽然说函数长的是一样的

46:54.730 --> 46:55.730
但是呢

46:55.730 --> 46:57.730
实际上地址是不一样的

46:57.730 --> 46:58.730
它在进行前比较的时候

46:58.730 --> 46:59.730
它就比较

46:59.730 --> 47:01.730
这个东西是不是跟这个

47:01.730 --> 47:03.730
你新传递的这个属性unadd

47:03.730 --> 47:04.730
是不是一样的

47:04.730 --> 47:05.730
就是旧的属性

47:05.730 --> 47:06.730
这是新的属性

47:06.730 --> 47:07.730
那它比较到这两个时候

47:07.730 --> 47:09.730
是不是地址不一样

47:09.730 --> 47:11.730
所以说我们之前说过这个问题

47:11.730 --> 47:12.730
就尽量的把这个函数

47:12.730 --> 47:13.730
不要写到这

47:13.730 --> 47:15.730
为了测试方便你可以这样做

47:15.730 --> 47:16.730
但是更多的时候

47:16.730 --> 47:18.730
你应该在这里写

47:18.730 --> 47:20.730
handle

47:20.730 --> 47:22.730
handleadd

47:22.730 --> 47:23.730
应该在这里写

47:23.730 --> 47:26.730
new task

47:26.730 --> 47:29.100
把写过来

47:29.100 --> 47:31.100
这样子就保证它的引用

47:31.100 --> 47:33.100
每一次给它的引用是一样的

47:33.100 --> 47:35.100
this handleadd

47:35.100 --> 47:36.100
保存

47:36.100 --> 47:37.100
你看一下

47:37.100 --> 47:39.100
那么现在add task

47:39.100 --> 47:40.100
是不是只运行了一次

47:40.100 --> 47:41.100
你看add task

47:41.100 --> 47:42.100
就这个组件

47:42.100 --> 47:43.100
它只运行了一次

47:43.100 --> 47:44.100
这个组件

47:44.100 --> 47:45.100
它运行两次

47:45.100 --> 47:46.100
因为没办法

47:46.100 --> 47:47.100
一开始数组长度为0

47:47.100 --> 47:48.100
给它的一个长度为0的数组

47:48.100 --> 47:50.100
后边来给它的长度为10的数组

47:50.100 --> 47:51.100
那数组那种都变了

47:51.100 --> 47:52.100
它肯定要重新选择

47:52.100 --> 47:53.100
对吧

47:53.100 --> 47:55.100
那里面它导致了10次这个渲染

47:55.100 --> 47:56.100
没问题

47:56.100 --> 47:57.100
一开始它要把

47:57.100 --> 47:58.100
初始化渲染出来

47:58.100 --> 47:59.100
对不对

47:59.100 --> 48:00.100
一开始没有这个10个组件

48:00.100 --> 48:01.100
一开始长度为0

48:01.100 --> 48:02.100
它没有这10个组件

48:02.100 --> 48:03.100
现在多了10个了

48:03.100 --> 48:05.100
那么它要创建一些组件

48:05.100 --> 48:06.100
它肯定要选择

48:06.100 --> 48:07.100
没问题

48:07.100 --> 48:08.100
好 接下来我们再看

48:08.100 --> 48:10.100
我们在这里改变

48:10.100 --> 48:11.100
那么这个东西重新选择

48:11.100 --> 48:12.100
这个没问题

48:14.100 --> 48:15.100
点添加任务

48:15.100 --> 48:16.100
你看一下

48:16.100 --> 48:17.100
是不是现在很少

48:17.100 --> 48:18.100
它自己有没有重新选择

48:18.100 --> 48:19.100
ADD TASK

48:19.100 --> 48:20.100
它没有重新选择

48:20.100 --> 48:21.100
它的数据没变

48:21.100 --> 48:22.100
它的状态也没变

48:22.100 --> 48:23.100
因此它自己没有重新选择

48:23.100 --> 48:24.100
我们点添加任务

48:24.100 --> 48:25.100
没有重新选择

48:25.100 --> 48:27.100
然后这个长度为11

48:27.100 --> 48:28.100
重新选择了

48:28.100 --> 48:29.100
这个没问题

48:29.100 --> 48:30.100
因为它的数据变了

48:30.100 --> 48:31.100
然后对于它而言

48:31.100 --> 48:32.100
它的数

48:32.100 --> 48:33.100
它的数据变了

48:33.100 --> 48:34.100
是不是也要重新选择

48:34.100 --> 48:35.100
对吧

48:35.100 --> 48:36.100
也要重新选择

48:36.100 --> 48:37.100
好 那么这个东西变了

48:37.100 --> 48:38.100
这个TASK变了

48:38.100 --> 48:39.100
是不是

48:39.100 --> 48:41.100
就只有一个重新选择

48:41.100 --> 48:42.100
就是新增了那一个

48:42.100 --> 48:43.100
但是其他的地方

48:43.100 --> 48:44.100
是不是没有变化

48:44.100 --> 48:46.100
那么其他10个都没有重新选择

48:46.100 --> 48:47.100
你看

48:47.100 --> 48:49.100
现在选择的是不是非常精简的

48:49.100 --> 48:50.100
我们再写

48:50.100 --> 48:51.100
再添加

48:51.100 --> 48:52.100
你看

48:52.100 --> 48:54.100
只有需要的部分重新选择了

48:54.100 --> 48:55.100
你看不

48:55.100 --> 48:56.100
你看点这个东西

48:56.100 --> 48:57.100
需要重新选择啥

48:57.100 --> 48:58.100
需要重新选择这个东西

48:58.100 --> 48:59.100
需要重新选择这个东西

48:59.100 --> 49:00.100
对吧

49:00.100 --> 49:01.100
那么现在的情况

49:01.100 --> 49:02.100
就是ADD TASK

49:02.100 --> 49:04.100
它也有可能不重新选择

49:04.100 --> 49:05.100
它也有可能

49:05.100 --> 49:06.100
那么这样子

49:06.100 --> 49:07.100
是不是达到优化的目的了

49:07.100 --> 49:08.100
对不对

49:08.100 --> 49:10.100
自己可能就想这个东西

49:11.100 --> 49:13.100
这里我们再说一下

49:13.100 --> 49:14.100
学到这个东西过后

49:14.100 --> 49:18.100
肯定是以后能够用Pure Component

49:18.100 --> 49:20.100
就尽量用Pure Component

49:20.100 --> 49:21.100
但是你要注意

49:23.100 --> 49:24.100
注意什么呢

49:24.100 --> 49:28.100
就是Pure Component

49:28.100 --> 49:31.100
进行的是前比较

49:31.100 --> 49:33.100
进行的是前比较

49:33.100 --> 49:36.100
那么如果它进行的是前比较的话

49:36.100 --> 49:38.100
你像你这样的代码就要出问题

49:38.100 --> 49:39.100
比方说

49:39.100 --> 49:40.100
在这里

49:40.100 --> 49:41.100
如果我的代码不是这样子写的

49:41.100 --> 49:42.100
你看着

49:42.100 --> 49:43.100
我是这样子玩的

49:43.100 --> 49:46.100
我先给这个Stats里边的TASK

49:46.100 --> 49:47.100
铺起一个

49:47.100 --> 49:48.100
增加一个

49:48.100 --> 49:52.100
增加一个新的任务

49:52.100 --> 49:54.100
然后把这个TASK重新复制回去

49:54.100 --> 49:56.100
用Stats重新复制回去

49:56.100 --> 49:57.100
你看一下

49:57.100 --> 49:59.100
这样子会有一个什么样的结果

49:59.100 --> 50:00.100
刀出

50:00.100 --> 50:01.100
看着吧

50:04.100 --> 50:06.100
然后我们这里

50:06.100 --> 50:08.100
你会看到了

50:08.100 --> 50:11.100
我们在写上一个新的任务

50:11.100 --> 50:12.100
点添加

50:13.100 --> 50:15.100
数字的长度为11

50:15.100 --> 50:18.100
但是你看一下后边

50:18.100 --> 50:20.100
数据出来了吗

50:20.100 --> 50:22.100
是不是没有出来

50:22.100 --> 50:23.100
为什么没有出来

50:23.100 --> 50:24.100
你看一下

50:24.100 --> 50:25.100
它到这一程

50:25.100 --> 50:26.100
它这个重新选了

50:26.100 --> 50:27.100
没问题

50:27.100 --> 50:28.100
到这一程都没有重新选了

50:28.100 --> 50:29.100
为什么它没有重新选的

50:29.100 --> 50:30.100
因为它发现

50:30.100 --> 50:32.100
你给我的新的数字

50:32.100 --> 50:33.100
跟之前的数字

50:33.100 --> 50:35.100
它地址是不是一样的

50:35.100 --> 50:36.100
有没有新的数字产生

50:36.100 --> 50:37.100
没有新的数字产生

50:37.100 --> 50:38.100
你只是在

50:38.100 --> 50:40.100
你给我的还是之前的数据

50:40.100 --> 50:42.100
所以说在这个TASK列手里边

50:42.100 --> 50:43.100
它一比较

50:43.100 --> 50:44.100
一进行前比较

50:44.100 --> 50:45.100
你看吧

50:45.100 --> 50:46.100
你给我的属性是TASK

50:46.100 --> 50:47.100
对吧

50:47.100 --> 50:49.100
你之前给我的是这个TASK

50:50.100 --> 50:51.100
是一个数据

50:51.100 --> 50:52.100
然后呢

50:52.100 --> 50:53.100
现在呢

50:53.100 --> 50:54.100
就给我了一个

50:54.100 --> 50:55.100
这个属性

50:55.100 --> 50:56.100
数据

50:56.100 --> 50:59.100
但是这两个数据的地址是一样的

50:59.100 --> 51:00.100
比方这里是3

51:00.100 --> 51:01.100
然后这里呢

51:01.100 --> 51:02.100
给它加了一下3和4

51:02.100 --> 51:03.100
但是这两个数据

51:03.100 --> 51:04.100
实际上是一样的

51:04.100 --> 51:05.100
你给它加的时候

51:05.100 --> 51:06.100
它也变化了

51:06.100 --> 51:07.100
对吧

51:07.100 --> 51:08.100
它也变化了

51:08.100 --> 51:09.100
两个地址是一样的

51:09.100 --> 51:10.100
那么就导致了这样的问题

51:10.100 --> 51:11.100
回过头来再看

51:11.100 --> 51:13.100
你看我有没有产生新的数据

51:13.100 --> 51:14.100
怎么来看

51:14.100 --> 51:15.100
有没有产生新的数据

51:15.100 --> 51:16.100
你使用6而为

51:16.100 --> 51:18.100
会产生一个新的数据

51:18.100 --> 51:19.100
你使用两个中阔号

51:19.100 --> 51:20.100
会产生新的数据

51:20.100 --> 51:21.100
这里有没有

51:21.100 --> 51:22.100
是没有

51:22.100 --> 51:23.100
对吧

51:23.100 --> 51:24.100
它并没有产生新的数据

51:24.100 --> 51:25.100
它只是改变了原来的数据

51:25.100 --> 51:27.100
因此地址一样

51:27.100 --> 51:29.100
地址一样的情况下

51:29.100 --> 51:30.100
它认为

51:30.100 --> 51:31.100
数据没有变化

51:31.100 --> 51:33.100
因此TASK列手

51:33.100 --> 51:34.100
没有

51:34.100 --> 51:35.100
重新宣展

51:35.100 --> 51:37.100
零贯说数据已经给它了

51:37.100 --> 51:38.100
你看

51:38.100 --> 51:39.100
数据已经正常了

51:39.100 --> 51:42.100
你看数据是11项

51:42.100 --> 51:43.100
但是由于TASK列手

51:43.100 --> 51:45.100
它是一个存住键

51:45.100 --> 51:46.100
一个Pure Component

51:46.100 --> 51:48.100
它进行前比较的时候

51:48.100 --> 51:49.100
它比较这个属性

51:49.100 --> 51:50.100
跟这些属于是一样的

51:50.100 --> 51:51.100
所以说

51:51.100 --> 51:53.100
它没有进行重新宣展

51:53.100 --> 51:54.100
这就是为什么

51:54.100 --> 51:56.100
我要大家一开始写代码的时候

51:56.100 --> 51:59.100
都尽量不要去改动之前的东西

51:59.100 --> 52:01.100
一定要去新建一个东西

52:01.100 --> 52:03.100
不要去改动之前的

52:03.100 --> 52:05.100
因为你改动了之前的

52:05.100 --> 52:07.100
它的地址是没有变化的

52:07.100 --> 52:08.100
地址没有变化的

52:08.100 --> 52:10.100
不管你这个东西是一个对象也好

52:10.100 --> 52:12.100
还是一个数据也好

52:12.100 --> 52:14.100
你都应该去产生一个新的

52:14.100 --> 52:17.100
而不应该使用之前的对象

52:17.100 --> 52:19.100
在之前的对象进行操作

52:19.100 --> 52:21.100
所以说为了

52:21.100 --> 52:23.100
为了效率

52:23.100 --> 52:24.100
基于这个

52:24.100 --> 52:26.100
它由于是前比较的时候

52:26.100 --> 52:27.100
由于它是前比较

52:27.100 --> 52:29.100
前比较效率是最高的

52:29.100 --> 52:31.100
当然你要做成生比较的话

52:31.100 --> 52:32.100
也可以

52:32.100 --> 52:34.100
这样的话效率反而更低了

52:34.100 --> 52:36.100
它本来就是为了提高效率的

52:36.100 --> 52:37.100
你把它效率又降低了

52:37.100 --> 52:38.100
没有什么意义

52:38.100 --> 52:40.100
就是为了效率

52:40.100 --> 52:43.100
应该尽量使用

52:43.100 --> 52:45.100
不说一定

52:45.100 --> 52:48.100
应该尽量使用这个

52:48.100 --> 52:50.100
这就要求

52:50.100 --> 52:53.100
不要改动

52:53.100 --> 52:54.100
之前的状态

52:54.100 --> 52:56.100
你之前的状态是不能改动的

52:56.100 --> 52:57.100
不能用任何改动的

52:57.100 --> 52:59.100
永远是

52:59.100 --> 53:03.100
创建新的状态

53:03.100 --> 53:05.100
覆盖之前的状态

53:05.100 --> 53:07.100
你不要在之前的状态里面

53:07.100 --> 53:08.100
做任何改动

53:08.100 --> 53:09.100
你永远是创建新的

53:09.100 --> 53:10.100
所以说我们之前

53:10.100 --> 53:11.100
为什么要这样子写

53:11.100 --> 53:13.100
把它变成一个新的

53:13.100 --> 53:14.100
新的数组

53:14.100 --> 53:15.100
新的数组

53:15.100 --> 53:17.100
把之前的数组的象拿过来

53:17.100 --> 53:20.100
然后再把新的象加进去

53:20.100 --> 53:22.100
这样子做的目的是保证

53:22.100 --> 53:25.100
你给它的是一个新的数组

53:25.100 --> 53:26.100
没问题吧

53:26.100 --> 53:27.100
或者说我们用什么

53:27.100 --> 53:28.100
用这个也可以

53:28.100 --> 53:30.100
Z state

53:30.100 --> 53:31.100
task是concrete

53:31.100 --> 53:33.100
数组里面这个函数

53:33.100 --> 53:35.100
concrete new task

53:35.100 --> 53:36.100
这样做是不是也可以

53:36.100 --> 53:37.100
这样做也可以

53:37.100 --> 53:39.100
因为这个数组里面这个函数

53:39.100 --> 53:40.100
它不会改动数组本身

53:40.100 --> 53:42.100
它会产生一个新的数组

53:42.100 --> 53:45.100
把这个新的象拼接进去

53:45.100 --> 53:46.100
这里看

53:46.100 --> 53:49.480
我们这里写一下

53:49.480 --> 53:50.480
点添加

53:50.480 --> 53:51.480
你看

53:51.480 --> 53:52.480
也可以显示

53:52.480 --> 53:54.480
总之你要永远给它新的东西

53:54.480 --> 53:55.480
不要改动之前的东西

53:55.480 --> 53:57.480
这种做法

53:57.480 --> 53:59.480
有一个数语叫做

53:59.480 --> 54:02.480
immutable

54:02.480 --> 54:04.480
叫做不可变对象

54:04.480 --> 54:06.480
就是保证

54:06.480 --> 54:08.480
保证之前创建的数组也好

54:08.480 --> 54:09.480
数组也是对象

54:09.480 --> 54:10.480
数组也好

54:10.480 --> 54:12.480
还有一个普通对象也好

54:12.480 --> 54:15.480
它的对象本身永远是不可变的

54:15.480 --> 54:16.480
永远是不能改动它的

54:16.480 --> 54:17.480
你要改动它

54:17.480 --> 54:18.480
只能产生一个新的对象

54:18.480 --> 54:20.480
对之前的对象是不能做改动的

54:20.480 --> 54:21.480
这是为了进行

54:21.480 --> 54:22.480
在react里面

54:22.480 --> 54:24.480
是为了进行效率的优化

54:24.480 --> 54:25.480
包括我们后面讲

54:25.480 --> 54:26.480
redax的时候也有这个要求

54:27.480 --> 54:28.480
所以说

54:28.480 --> 54:29.480
大家写的时候

54:29.480 --> 54:30.480
尽量使用这个

54:30.480 --> 54:31.480
可以提高效率

54:31.480 --> 54:33.480
那么要使用这个有一个权利条件

54:33.480 --> 54:35.480
你必须要使用不可变对象

54:35.480 --> 54:36.480
你不能改动之前的东西

54:36.480 --> 54:37.480
比方说

54:37.480 --> 54:38.480
那么这里

54:38.480 --> 54:39.480
举个例子

54:39.480 --> 54:41.480
我这里就不多演示了

54:41.480 --> 54:42.480
比方说这里

54:42.480 --> 54:43.480
状态这里边

54:43.480 --> 54:44.480
还有一个对象

54:46.480 --> 54:48.480
这对象里边有些属相

54:49.480 --> 54:50.480
有些属相

54:51.480 --> 54:53.480
比方说我们要把B改成500

54:53.480 --> 54:54.480
把B改成500

54:54.480 --> 54:55.480
我们应该怎么写

54:55.480 --> 54:56.480
应该怎么写

54:56.480 --> 54:57.480
千万不要这样子写

54:57.480 --> 54:58.480
这是State

54:58.480 --> 54:59.480
obj

54:59.480 --> 55:00.480
B

55:00.480 --> 55:01.480
把它变成500

55:01.480 --> 55:03.480
那么这样子是不是改动了

55:03.480 --> 55:05.480
改动了这个对象的数据了

55:05.480 --> 55:06.480
对吧

55:06.480 --> 55:07.480
这是不合理的

55:07.480 --> 55:09.480
这个对象应该是不可变的

55:09.480 --> 55:10.480
它永远不能变化

55:10.480 --> 55:11.480
它写的什么数据

55:11.480 --> 55:12.480
就是什么数据

55:12.480 --> 55:13.480
你要改动它的话

55:13.480 --> 55:15.480
一定要产生一个新的对象

55:15.480 --> 55:16.480
比方说obj

55:16.480 --> 55:18.480
产生一个新的对象

55:18.480 --> 55:20.480
两个大口号说新的对象

55:20.480 --> 55:22.480
把之前的对象展开

55:22.480 --> 55:23.480
之前的对象展开

55:23.480 --> 55:25.480
然后把B重新复制

55:25.480 --> 55:26.480
复制成500

55:26.480 --> 55:27.480
复改过去

55:27.480 --> 55:28.480
对吧

55:28.480 --> 55:29.480
或者是利用什么

55:29.480 --> 55:31.480
或者是利用obj的设

55:31.480 --> 55:32.480
而散

55:33.480 --> 55:35.480
这个我应该说过了吧

55:35.480 --> 55:36.480
一个新的对象

55:36.480 --> 55:37.480
复改新的对象

55:37.480 --> 55:38.480
然后这里写上什么

55:38.480 --> 55:41.480
写上就是thisState

55:41.480 --> 55:42.480
就是obj

55:42.480 --> 55:44.480
然后一个新的对象

55:44.480 --> 55:45.480
就是B为500

55:45.480 --> 55:46.480
这样子也可以

55:46.480 --> 55:47.480
当这样子

55:47.480 --> 55:48.480
没有展开运串符

55:48.480 --> 55:49.480
写得那么简洁

55:49.480 --> 55:51.480
总之不要改动原来的对象

55:52.480 --> 55:53.480
甚至说

55:53.480 --> 55:54.480
我这里给大家介绍一下吧

55:54.480 --> 55:57.480
就是在有一个第三方库

55:58.480 --> 56:01.480
有一个第三方库

56:01.480 --> 56:02.480
第三方介石库

56:02.480 --> 56:04.480
这门客我们就不设计了

56:04.480 --> 56:06.480
以后我可以专门拿一门客来讲

56:06.480 --> 56:07.480
叫做immutable

56:08.480 --> 56:11.480
这库还蛮庞大的介石

56:11.480 --> 56:12.480
有个第三方库

56:12.480 --> 56:15.480
他专门用于处理

56:15.480 --> 56:17.480
专门用于制作

56:17.480 --> 56:18.480
不可变对象

56:19.480 --> 56:21.480
你用他做出来的对象

56:21.480 --> 56:22.480
你想变都不可能

56:22.480 --> 56:23.480
绝对不可能

56:23.480 --> 56:24.480
你想都不要想改变他的对象

56:24.480 --> 56:25.480
一改变就要报处

56:25.480 --> 56:27.480
根本不允许你改变他里面的东西

56:27.480 --> 56:29.480
你只能去产生一个新的对象来改变

56:30.480 --> 56:32.480
他就专门一个第三方库来做这个事情

56:33.480 --> 56:34.480
这是第一个点要注意的

56:35.480 --> 56:36.480
这就是为什么

56:36.480 --> 56:37.480
我们之前强调

56:37.480 --> 56:38.480
反过强调

56:38.480 --> 56:39.480
状态

56:39.480 --> 56:40.480
你不要去改动他

56:40.480 --> 56:42.480
应该去覆盖他

56:42.480 --> 56:43.480
就是这个原因

56:43.480 --> 56:44.480
这是为了提高效率

56:44.480 --> 56:45.480
因为到时候

56:45.480 --> 56:46.480
我们要用pure component

56:46.480 --> 56:47.480
如果你养成习惯了

56:47.480 --> 56:48.480
那么后面改过来就很麻烦了

56:48.480 --> 56:50.480
就一开始要养成好的习惯

56:50.480 --> 56:51.480
不要去改动状态

56:51.480 --> 56:53.480
一定要覆盖他

56:54.480 --> 56:56.480
这是第一个点

56:56.480 --> 56:58.480
第二点是关于寒树组件

56:58.480 --> 57:00.480
寒树式组件

57:00.480 --> 57:01.480
如果是寒树组件

57:01.480 --> 57:03.480
如果你要把它做成一个存住件的话

57:03.480 --> 57:06.480
使用rex

57:07.480 --> 57:08.480
调什么

57:08.480 --> 57:13.480
Memo寒树制作存住件

57:15.480 --> 57:16.480
比方说

57:17.480 --> 57:19.480
换一个没有状态的

57:19.480 --> 57:20.480
因为寒树组件没有状态

57:20.480 --> 57:21.480
比方说这个task

57:22.480 --> 57:24.480
他就可以使用寒树组件

57:24.480 --> 57:25.480
对吧

57:25.480 --> 57:26.480
他可以使用寒树组件

57:26.480 --> 57:27.480
那行吧

57:27.480 --> 57:28.480
把它写成个寒树组件

57:28.480 --> 57:29.480
把这个取掉

57:31.980 --> 57:33.980
寒树组件

57:34.980 --> 57:35.980
方形

57:35.980 --> 57:36.980
export

57:36.980 --> 57:37.980
default

57:37.980 --> 57:38.980
方形

57:38.980 --> 57:39.980
寒树组件

57:39.980 --> 57:40.980
名字叫task

57:41.980 --> 57:42.980
props

57:43.980 --> 57:44.980
那么这里

57:44.980 --> 57:45.980
我们还是可以给寒树组件

57:45.980 --> 57:47.980
加一个props

57:47.980 --> 57:48.980
proptaps

57:48.980 --> 57:49.980
加上这个

57:49.980 --> 57:50.980
约束

57:50.980 --> 57:51.980
约束一下你有哪些属性

57:51.980 --> 57:53.980
要给我这两个属性

57:53.980 --> 57:54.980
这个没什么问题

57:55.980 --> 57:56.980
然后这个寒树组件里面

57:56.980 --> 57:57.980
它的写法

57:57.980 --> 57:58.980
是不是就是这句话

57:58.980 --> 57:59.980
对不对

57:59.980 --> 58:00.980
一样的

58:02.980 --> 58:03.980
由于寒树组件

58:03.980 --> 58:04.980
它没有

58:04.980 --> 58:05.980
目前我们学习的寒树组件

58:05.980 --> 58:06.980
是没有生命周期的

58:07.980 --> 58:08.980
它由于没有生命周期

58:09.980 --> 58:10.980
好错

58:11.980 --> 58:13.980
我这里面写结束表姐

58:14.980 --> 58:15.980
没复制完

58:16.980 --> 58:19.680
没复制完

58:19.680 --> 58:21.680
就这里写结束表姐一晚上

58:22.680 --> 58:23.680
由于这个寒树组件

58:23.680 --> 58:25.680
它是没有生命周期的

58:25.680 --> 58:26.680
没有生命周期

58:26.680 --> 58:27.680
所以说它不存在

58:27.680 --> 58:28.680
suit component update

58:28.680 --> 58:30.680
那么它怎么来做成存组件

58:30.680 --> 58:31.680
因为我们知道

58:31.680 --> 58:32.680
寒树组件没有生命周期

58:32.680 --> 58:33.680
它每一次

58:33.680 --> 58:35.680
宣展的时候都是重新调用寒树

58:35.680 --> 58:36.680
那么怎么来防止

58:36.680 --> 58:37.680
它重新调用寒树呢

58:37.680 --> 58:38.680
是这样子

58:38.680 --> 58:39.680
react

58:39.680 --> 58:40.680
给你提供了一个高阶寒树

58:40.680 --> 58:41.680
叫做memo

58:41.680 --> 58:42.680
高阶寒树

58:42.680 --> 58:44.680
非常非常简单

58:44.680 --> 58:46.680
你传过去一个寒树就完事了

58:46.680 --> 58:48.680
你传过去一个组件

58:48.680 --> 58:49.680
你完事了

58:49.680 --> 58:50.680
把寒树组件传给它

58:51.680 --> 58:52.680
它会返回一个新的组件

58:52.680 --> 58:54.680
这个新的组件呢

58:54.680 --> 58:55.680
就是一个存组件

58:55.680 --> 58:56.680
所以说你导出的时候

58:56.680 --> 58:57.680
把这个东西导出去完事了

58:58.680 --> 59:00.680
新的组件就是一个存组件

59:00.680 --> 59:01.680
你把这个东西导出去完事了

59:02.680 --> 59:03.680
保存

59:03.680 --> 59:04.680
你看一下吧

59:04.680 --> 59:05.680
是一样的

59:07.680 --> 59:08.680
保存了

59:08.680 --> 59:09.680
保存了

59:09.680 --> 59:10.680
它说

59:10.680 --> 59:12.680
connards read property props

59:12.680 --> 59:13.680
明白了

59:13.680 --> 59:14.680
没有认识

59:14.680 --> 59:15.680
它这里不存在认识

59:18.760 --> 59:22.290
多了

59:22.290 --> 59:23.290
把认识删掉

59:24.290 --> 59:25.290
保存

59:27.290 --> 59:28.290
这里写天下任务

59:28.290 --> 59:29.290
你看

59:29.290 --> 59:30.290
task render

59:30.290 --> 59:31.290
是不是只运行一次

59:31.290 --> 59:33.290
之前那10个没有重新宣传

59:33.290 --> 59:34.290
它怎么做到的呢

59:34.290 --> 59:35.290
其实非常非常简单

59:35.290 --> 59:37.290
它是个高阶组件

59:37.290 --> 59:38.290
我说到高阶组件

59:38.290 --> 59:39.290
你应该就明白它什么意思了

59:40.290 --> 59:41.290
你看一下

59:41.290 --> 59:42.290
它是不是外面给掏了一个

59:42.290 --> 59:44.290
掏了一个叫做memo

59:44.290 --> 59:45.290
掏了一个这个组件

59:45.290 --> 59:46.290
这个组件是什么

59:46.290 --> 59:47.290
就是个内组件

59:47.290 --> 59:49.290
这个组件就是个内组件

59:49.290 --> 59:51.290
它给掏了这么一个玩意

59:51.290 --> 59:53.290
给掏了这么一个玩意

59:53.290 --> 59:54.290
就这么简单

59:54.290 --> 59:55.290
它怎么做

59:55.290 --> 59:56.290
它怎么玩的呢

59:56.290 --> 59:57.290
它是怎么玩的呢

59:57.290 --> 59:58.290
它是这样子玩的

59:58.290 --> 59:59.290
如果你要自己写的话

59:59.290 --> 01:00:00.290
你也可以自己写

01:00:00.290 --> 01:00:01.290
也可以自己写

01:00:01.290 --> 01:00:02.290
它怎么简单的

01:00:02.290 --> 01:00:03.290
我给大家写一下吧

01:00:03.290 --> 01:00:05.290
写这么一个class

01:00:06.290 --> 01:00:07.290
写这么一个函数

01:00:07.290 --> 01:00:09.290
叫做memo

01:00:09.290 --> 01:00:10.290
memo函数

01:00:11.290 --> 01:00:12.290
这个函数里边

01:00:12.290 --> 01:00:14.290
你给我传一个组件进来

01:00:14.290 --> 01:00:16.290
给我传一个函数组件进来

01:00:16.290 --> 01:00:18.290
funk

01:00:18.290 --> 01:00:19.290
传个函数组件进来

01:00:19.290 --> 01:00:21.290
我给你反回了是什么呢

01:00:21.290 --> 01:00:23.290
给你反回了是一个内组件

01:00:23.290 --> 01:00:24.290
memo

01:00:24.290 --> 01:00:26.290
extence

01:00:26.290 --> 01:00:27.290
pure component

01:00:27.290 --> 01:00:29.290
就这么简单

01:00:29.290 --> 01:00:31.290
跑了去了

01:00:31.290 --> 01:00:33.290
跑了去了

01:00:33.290 --> 01:00:34.290
这里

01:00:34.290 --> 01:00:36.290
没有把导入进来

01:00:36.290 --> 01:00:38.290
Import

01:00:38.290 --> 01:00:40.290
这里

01:00:40.290 --> 01:00:42.290
pure component

01:00:42.290 --> 01:00:46.790
它反回了就是一个新的内组件

01:00:46.790 --> 01:00:49.790
内组件继承pure component

01:00:49.790 --> 01:00:50.790
内组件里边

01:00:50.790 --> 01:00:51.790
它一个render

01:00:51.790 --> 01:00:53.790
render里边做什么了

01:00:53.790 --> 01:00:54.790
render里边做啥了

01:00:54.790 --> 01:00:56.790
render里边做的事情就是

01:00:56.790 --> 01:00:58.790
反回啥了

01:00:58.790 --> 01:01:00.790
反回

01:01:00.790 --> 01:01:01.790
这个函数组件

01:01:01.790 --> 01:01:03.790
反回函数组件

01:01:03.790 --> 01:01:04.790
funk

01:01:04.790 --> 01:01:05.790
反回函数组件

01:01:05.790 --> 01:01:07.790
然后把我的属性全部给你

01:01:07.790 --> 01:01:09.790
this props

01:01:09.790 --> 01:01:10.790
把我的属性全部给你

01:01:10.790 --> 01:01:12.790
就这么简单

01:01:13.790 --> 01:01:14.790
把我的属性全部给你

01:01:14.790 --> 01:01:15.790
就完事了

01:01:16.790 --> 01:01:17.790
就没了

01:01:17.790 --> 01:01:19.790
或者说它反回的是什么东西

01:01:19.790 --> 01:01:20.790
因为它的结构

01:01:20.790 --> 01:01:21.790
它反回的是这个

01:01:21.790 --> 01:01:22.790
反回的是

01:01:22.790 --> 01:01:23.790
实际上是这个

01:01:23.790 --> 01:01:25.790
反回的是一个空的

01:01:25.790 --> 01:01:27.790
空的

01:01:27.790 --> 01:01:28.790
空的节点

01:01:28.790 --> 01:01:30.790
然后这里边去调用

01:01:30.790 --> 01:01:32.790
调用函数组件

01:01:32.790 --> 01:01:33.790
它不是函数吗

01:01:33.790 --> 01:01:34.790
我调用它

01:01:34.790 --> 01:01:36.790
把我的props传进去

01:01:36.790 --> 01:01:37.790
就完了

01:01:37.790 --> 01:01:39.790
它把函数组件

01:01:39.790 --> 01:01:40.790
反回的结构就放在这儿了

01:01:40.790 --> 01:01:42.790
它一掏了一层就完了

01:01:42.790 --> 01:01:44.790
你看我们用这个玩意儿

01:01:44.790 --> 01:01:45.790
用我们自己的写的函数

01:01:45.790 --> 01:01:46.790
可以达到一模一样的效果

01:01:46.790 --> 01:01:48.790
完全一样的效果

01:01:48.790 --> 01:01:49.790
完全一样的效果

01:01:49.790 --> 01:01:50.790
包穿

01:01:51.790 --> 01:01:52.790
你看一下

01:01:52.790 --> 01:01:53.790
这里

01:01:53.790 --> 01:01:54.790
空台

01:01:54.790 --> 01:01:55.790
这里没写一个

01:01:55.790 --> 01:01:56.790
添添浆

01:01:56.790 --> 01:01:57.790
是不是只运行了一次

01:01:57.790 --> 01:01:58.790
对吧

01:01:58.790 --> 01:01:59.790
完全一样的效果

01:01:59.790 --> 01:02:00.790
就是给它操了一层

01:02:00.790 --> 01:02:01.790
非常非常简单

01:02:01.790 --> 01:02:03.790
它的做法非常简单

01:02:03.790 --> 01:02:05.790
这是它的实现原理

01:02:05.790 --> 01:02:07.790
对函数组件就可以用这个

01:02:07.790 --> 01:02:08.790
就没了

01:02:08.790 --> 01:02:10.790
这一刻我们就讲这些东西

01:02:10.790 --> 01:02:11.790
其实东西很简单

01:02:11.790 --> 01:02:12.790
东西很简单

01:02:12.790 --> 01:02:13.790
关键是对它的理解

01:02:13.790 --> 01:02:14.790
它在理解上

01:02:14.790 --> 01:02:15.790
你要设立到生命周期

01:02:15.790 --> 01:02:16.790
你要知道

01:02:16.790 --> 01:02:17.790
组件它怎么更新的

01:02:17.790 --> 01:02:19.790
它第一次挖载阶段

01:02:19.790 --> 01:02:20.790
挖载阶段它肯定

01:02:20.790 --> 01:02:21.790
这个你阻止不了

01:02:21.790 --> 01:02:22.790
你挖载阶段

01:02:22.790 --> 01:02:23.790
你肯定要渲染

01:02:23.790 --> 01:02:24.790
不渲染

01:02:24.790 --> 01:02:25.790
我显示啥了

01:02:25.790 --> 01:02:26.790
对不对

01:02:26.790 --> 01:02:27.790
显示啥了

01:02:27.790 --> 01:02:28.790
没法显示

01:02:28.790 --> 01:02:29.790
关键是后边更新

01:02:29.790 --> 01:02:30.790
它一摸正情况下

01:02:30.790 --> 01:02:31.790
它是一定渲染的

01:02:31.790 --> 01:02:32.790
一定重新渲染

01:02:32.790 --> 01:02:33.790
但是我们发现

01:02:33.790 --> 01:02:34.790
实际上很多时候

01:02:34.790 --> 01:02:35.790
是没有必要的

01:02:35.790 --> 01:02:36.790
我们希望它的数据

01:02:36.790 --> 01:02:37.790
没有变动的时候

01:02:37.790 --> 01:02:38.790
就不要重新渲染了

01:02:38.790 --> 01:02:39.790
所以说我们可以使用

01:02:39.790 --> 01:02:40.790
纯组件

01:02:40.790 --> 01:02:41.790
但是你要注意

01:02:41.790 --> 01:02:43.790
它是前比较

01:02:43.790 --> 01:02:44.790
因此你要保证

01:02:44.790 --> 01:02:45.790
使用纯组件的时候

01:02:45.790 --> 01:02:47.790
尽量养成一个良好的习惯

01:02:47.790 --> 01:02:49.790
就是在使用状态的时候

01:02:49.790 --> 01:02:53.790
你一定不要改变

01:02:53.790 --> 01:02:54.790
之前的状态

01:02:54.790 --> 01:02:55.790
一定要去覆改

01:02:55.790 --> 01:02:56.790
产生一个新的对象

01:02:56.790 --> 01:02:57.790
产生一个新的宿主

01:02:57.790 --> 01:02:58.790
去覆改

01:02:58.790 --> 01:02:59.790
而不要去改动

01:02:59.790 --> 01:03:01.790
对于它的第一层属性

01:03:01.790 --> 01:03:03.790
对于它的第一层属性

01:03:03.790 --> 01:03:04.790
不要做任何的改动

01:03:04.790 --> 01:03:07.100
好

01:03:07.100 --> 01:03:08.100
那么这是这里和的东西

01:03:08.100 --> 01:03:09.100
这里有个警告

01:03:09.100 --> 01:03:10.100
这个警告是因为

01:03:10.100 --> 01:03:11.100
我这个地方没用了

01:03:12.100 --> 01:03:13.100
我们把写下来

01:03:13.100 --> 01:03:14.100
把写下来注释掉

01:03:19.100 --> 01:03:20.100
好了

01:03:20.100 --> 01:03:21.100
大家下来

01:03:21.100 --> 01:03:22.100
做一次

01:03:22.100 --> 01:03:23.100
这个地方

01:03:23.100 --> 01:03:24.100
也没有什么demo

01:03:24.100 --> 01:03:25.100
可以跟我们练习

01:03:25.100 --> 01:03:26.100
就是我们以后

01:03:26.100 --> 01:03:27.100
写代码的时候

01:03:27.100 --> 01:03:28.100
就尽量使用纯组件了

