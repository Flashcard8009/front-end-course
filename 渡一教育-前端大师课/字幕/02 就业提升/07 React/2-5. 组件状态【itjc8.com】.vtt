WEBVTT

00:00.300 --> 00:04.140
上节课咱们讲到了这个属性

00:04.140 --> 00:09.260
属性对一个组件而言它不是自己的数据

00:09.260 --> 00:11.040
是别人给它的数据

00:11.040 --> 00:14.640
因此它对这个数据是没有任何权限的

00:14.640 --> 00:16.680
它只能说根据这个数据

00:16.680 --> 00:18.740
这个数据是这个样子我显示一个界面

00:18.740 --> 00:21.540
这个数据是另外一个样子我显示另外一个界面

00:21.540 --> 00:26.160
它只能说根据这个数据我来做出不同的UI显示

00:26.160 --> 00:28.960
这也是Rex它的核心思想对吧

00:29.120 --> 00:31.520
Rex它不就是解决UI的复杂度吗

00:31.520 --> 00:36.320
你不同的数据它就会做出不同的UI的反应

00:36.320 --> 00:39.200
但是有的时候有些组件

00:39.200 --> 00:42.920
它确实有自己可以操控的数据

00:42.920 --> 00:44.000
举个例子

00:44.000 --> 00:47.240
这里我们举个例子写一个非常简单的组件

00:47.240 --> 00:50.400
比方说我们这里建个楼间压Component

00:50.400 --> 00:55.560
然后这里边我们建立一个组件叫做Tick

00:55.560 --> 00:57.400
叫做倒计时期

00:57.440 --> 00:59.520
它是一个计时器

00:59.520 --> 01:01.680
计时器倒计时的

01:01.680 --> 01:04.280
它是用作倒计时的

01:06.040 --> 01:09.480
那么这里的计时器我们写这么一个内组件

01:09.480 --> 01:11.040
其实函数组件内组件都无所谓

01:11.040 --> 01:13.440
这里写这么个内组件

01:13.440 --> 01:16.040
这个内组件里边它就很简单

01:16.040 --> 01:17.640
就一个H1元数

01:17.640 --> 01:23.200
H1元数我们这里写上倒计时

01:23.280 --> 01:27.720
倒计时目前还有多少剩下的时间

01:27.720 --> 01:30.520
就是倒计时剩余时间

01:30.520 --> 01:35.040
剩余时间

01:35.040 --> 01:37.120
那么这个地方是不是要填一个数据

01:37.120 --> 01:40.240
要填一个数字来表示时间

01:40.240 --> 01:41.960
按照我们之前学习的知识

01:41.960 --> 01:43.800
那这里是不是应该填一个属性

01:43.800 --> 01:45.440
数据我不知道啥数据

01:45.440 --> 01:46.640
那我又填一个属性

01:46.640 --> 01:47.200
对不对

01:47.200 --> 01:50.200
ZProps比方说Lumber

01:50.200 --> 01:51.920
填上这么一个数据

01:52.120 --> 01:54.160
接下来咱们来拥一下这个组件

01:54.160 --> 01:58.320
看一下会遇到一个什么样的一个问题

01:58.320 --> 02:00.120
它也不能教说问题吧

02:00.120 --> 02:02.280
就觉得总是不觉得

02:02.280 --> 02:04.000
觉得它不是很舒服

02:04.000 --> 02:06.600
咱们看一下

02:06.600 --> 02:08.640
Tick导入进来

02:08.640 --> 02:12.120
点儿写缸ComponentTick导入进来

02:12.120 --> 02:14.960
那这里我们写这么一个函数

02:14.960 --> 02:18.480
Start倒计时

02:18.480 --> 02:19.880
写这么一个函数

02:19.880 --> 02:21.520
好这个函数里边我们干嘛

02:21.560 --> 02:22.680
我们这里写个辨量

02:22.680 --> 02:27.920
从60开始

02:27.920 --> 02:30.320
好于是每一次Start

02:30.320 --> 02:32.320
我们就是Start函数里面

02:32.320 --> 02:38.010
我们Set toInterval

02:38.010 --> 02:41.610
然后每个一秒钟干嘛

02:41.610 --> 02:45.010
把这个Lumber减减

02:45.010 --> 02:46.090
减1

02:46.090 --> 02:48.170
减1过后了我们是不是重新渲染

02:48.170 --> 02:48.890
对吧

02:48.890 --> 02:50.570
重新渲染一次

02:50.570 --> 02:52.090
减1过后了我们重新渲染一次

02:52.130 --> 02:55.370
这也是我们之前使用的一种做法

02:55.370 --> 02:58.250
Tick重新渲染一次

02:58.250 --> 02:59.010
给它一个属性

02:59.010 --> 02:59.570
什么属性呢

02:59.570 --> 03:00.570
就是Number

03:00.570 --> 03:01.490
不是要这个属性吗

03:01.490 --> 03:02.850
那我给你

03:02.850 --> 03:04.130
把我们的数字给你

03:04.130 --> 03:05.490
重新渲染你看一下

03:05.490 --> 03:06.410
属性给它之后

03:06.410 --> 03:08.290
它是不是重新得到新的数字

03:08.290 --> 03:09.170
重新渲染一边了

03:09.170 --> 03:11.450
重新运行Render

03:11.450 --> 03:12.370
重新渲染

03:12.370 --> 03:13.410
重新运行Render

03:13.410 --> 03:15.530
那么得到了新的数据

03:15.530 --> 03:16.770
这是我们之前的做法

03:16.770 --> 03:18.170
对吧

03:18.170 --> 03:20.090
好那么这里我们还可以判断一下

03:20.090 --> 03:21.170
还可以判断一下

03:21.210 --> 03:23.170
不要让这里我们设置个Time

03:24.370 --> 03:25.490
你看我又忘了

03:25.490 --> 03:26.890
要用这个Const

03:27.610 --> 03:28.530
这里要用Net

03:29.410 --> 03:31.170
这里比方说我们这里

03:33.170 --> 03:35.090
如果减少之后

03:35.090 --> 03:37.530
如果小于0

03:37.530 --> 03:38.610
如果小于0

03:38.610 --> 03:39.890
减到0以下了

03:39.890 --> 03:40.850
那我还渲染吗

03:40.850 --> 03:41.770
是不渲染了

03:41.770 --> 03:42.210
对吧

03:42.210 --> 03:43.330
清空Time

03:44.090 --> 03:45.170
ClearInterval

03:45.170 --> 03:46.210
清空Time

03:46.210 --> 03:47.090
然后Return

03:47.090 --> 03:47.890
结束这个函数

03:47.890 --> 03:49.250
就不要运行了

03:49.250 --> 03:50.890
如果是0以上

03:50.930 --> 03:51.450
包括0

03:51.450 --> 03:53.330
我们都要重新渲染一遍

03:53.330 --> 03:54.570
就写这么一个函数

03:54.570 --> 03:55.410
Start

03:55.410 --> 03:56.210
调用一下

03:56.210 --> 03:57.930
这个函数也非常非常好理解

03:57.930 --> 03:59.610
大家看一下这个函数

03:59.610 --> 04:00.650
非常非常好理解

04:00.650 --> 04:02.450
就是启动一个计时器

04:02.450 --> 04:04.010
然后开始渲染

04:04.010 --> 04:05.050
改变一个数据

04:05.050 --> 04:05.930
重新渲染一次

04:05.930 --> 04:07.690
改变一个数据重新渲染一次

04:07.690 --> 04:08.330
每次渲染的

04:08.330 --> 04:09.850
它就会重新运行Render

04:09.850 --> 04:11.170
对吧

04:11.170 --> 04:12.330
咱们来运行出来

04:12.330 --> 04:13.050
看一下

04:13.050 --> 04:14.330
那这个60秒太长了

04:14.330 --> 04:15.330
10秒钟

04:15.330 --> 04:16.530
10秒钟

04:16.530 --> 04:18.930
1 2 Start

04:18.930 --> 04:20.450
我这里又开了一个分支了

04:20.490 --> 04:22.770
总之我们每一届客栏都是一个新的分支

04:23.770 --> 04:24.650
看一下

04:25.290 --> 04:26.370
在我们浏览器里面

04:26.370 --> 04:27.770
它会发生什么样的事

04:29.820 --> 04:31.260
功能肯定是没问题的

04:31.260 --> 04:32.580
这个功能有啥问题的

04:32.980 --> 04:34.460
功能是肯定没问题的

04:35.460 --> 04:35.620
好

04:35.620 --> 04:36.500
你看吧

04:36.500 --> 04:41.540
8 7 6 5 4 3

04:42.860 --> 04:43.780
看呀

04:44.460 --> 04:45.300
是不是结束了

04:45.300 --> 04:45.700
对吧

04:45.700 --> 04:47.220
清空的计时器就结束了

04:47.660 --> 04:50.260
但是总感觉不太舒服

04:50.900 --> 04:52.660
为什么感觉不太舒服呢

04:53.460 --> 04:54.220
你想一想

04:54.220 --> 04:55.300
这个计时器干嘛呀

04:55.980 --> 04:57.420
它用做倒计时的

04:57.740 --> 04:58.580
它倒计时呢

04:58.980 --> 05:00.540
它倒计时跑哪去了呢

05:00.540 --> 05:01.460
它又没有倒计时

05:01.460 --> 05:02.740
它又完全没有倒计时

05:02.740 --> 05:04.460
它就给你显示一个A7E元素

05:04.980 --> 05:05.740
有什么倒计时

05:05.740 --> 05:06.500
有狗屁倒计时

05:07.500 --> 05:08.820
不太舒服

05:08.820 --> 05:09.700
你不是说了

05:09.700 --> 05:10.900
你就是个倒计时吗

05:10.900 --> 05:11.460
对不对

05:11.460 --> 05:12.980
你自己去倒计时不完了吗

05:12.980 --> 05:13.540
对不对

05:13.540 --> 05:15.140
干嘛让我来参与呢

05:15.140 --> 05:16.820
我还给你做倒计时的功能

05:16.820 --> 05:17.780
我累死了

05:17.780 --> 05:20.180
你不就是个倒计时组建吗

05:20.260 --> 05:22.060
你去完成倒计时就行了吧

05:22.060 --> 05:23.180
我现在告诉你

05:23.180 --> 05:24.580
一共的总时间是多少

05:24.580 --> 05:25.740
总时间就是60毫秒

05:25.740 --> 05:26.700
10秒钟

05:26.700 --> 05:27.500
我告诉你

05:27.860 --> 05:28.220
好

05:28.460 --> 05:30.300
你去完成倒计时不完了吗

05:30.300 --> 05:32.060
你干嘛让我来参与呢

05:32.060 --> 05:33.540
我来帮你做倒计时呢

05:33.860 --> 05:34.980
就感觉很奇怪

05:35.340 --> 05:36.900
就说说一说有的时候

05:36.900 --> 05:38.660
组建会遇到这么一种情况

05:38.660 --> 05:41.900
它确实有自己需要维护的数据

05:42.100 --> 05:43.060
这个数据呢

05:43.060 --> 05:44.580
不是别人告诉我的

05:44.740 --> 05:46.500
是我自己又可以维护

05:46.740 --> 05:48.180
那么这样的数据呢

05:48.220 --> 05:50.380
就叫做组建状态

05:52.090 --> 05:55.650
我们这里可讲的就是组建状态

05:56.210 --> 05:57.850
什么叫做组建状态

05:58.170 --> 05:59.690
就是组建

06:00.090 --> 06:03.410
可以自行维护的数据

06:03.410 --> 06:04.250
就是这个数据呢

06:04.250 --> 06:05.170
不是别人的

06:05.170 --> 06:06.370
就是它自己的

06:06.490 --> 06:08.890
我们之前说数据属于谁

06:09.010 --> 06:10.650
谁就有控制权

06:10.850 --> 06:13.410
那么这个数据就是属于这个组建的

06:13.530 --> 06:15.170
你是倒计时组建

06:15.170 --> 06:16.050
那么生于时间

06:16.050 --> 06:16.850
你自己都不知道

06:16.850 --> 06:17.610
在谁知道了

06:17.610 --> 06:19.170
你还要让别人告诉你

06:19.330 --> 06:20.770
那你是不是太懒了呢

06:20.970 --> 06:21.490
对吧

06:21.650 --> 06:24.690
所以说我们希望有这么一种数据

06:24.690 --> 06:26.570
它可以自行维护

06:26.570 --> 06:29.690
这种数据就叫做组建状态

06:30.290 --> 06:32.250
就是有的时候组建它有些数据

06:32.250 --> 06:33.330
它确实不知道

06:33.530 --> 06:34.450
它也不能知道

06:34.450 --> 06:34.890
对吧

06:34.890 --> 06:36.010
是别人给它的

06:36.010 --> 06:37.610
比方说我们之前讲的学生

06:37.810 --> 06:39.210
学生就是一个小DEMON

06:39.210 --> 06:39.610
对吧

06:39.610 --> 06:40.770
那个学生一个组建

06:40.770 --> 06:41.450
一个学生组建

06:41.450 --> 06:42.650
他怎么知道学生是啥的

06:42.650 --> 06:43.650
他不知道

06:43.850 --> 06:45.250
所以说要别人给他

06:45.410 --> 06:47.250
但是有的时候组建有些数据

06:47.250 --> 06:48.250
确实是知道的

06:48.410 --> 06:49.570
它是生于时间

06:49.570 --> 06:50.250
是不是知道的

06:50.250 --> 06:51.250
我肯定知道了

06:51.690 --> 06:53.250
那不然我什么倒计时呢

06:53.970 --> 06:55.010
所以说这一块

06:55.010 --> 06:56.690
它是有自己的数据的

06:56.690 --> 06:59.090
那么我们把这里叫做组建状态

06:59.090 --> 07:01.330
有的时候也简称为状态

07:02.610 --> 07:04.090
那么这个状态这个数据

07:04.090 --> 07:04.850
大家要注意

07:05.690 --> 07:07.130
组建状态

07:09.050 --> 07:09.970
仅在

07:10.970 --> 07:13.970
仅在内组建中有效

07:14.570 --> 07:16.130
所以说一旦一个组建

07:16.130 --> 07:17.930
它涉及到有自己维护的数据

07:17.970 --> 07:19.130
它有状态的话

07:19.130 --> 07:22.210
那么只有内组建里边才能用状态

07:23.330 --> 07:25.050
函数组建能不能用状态了

07:25.690 --> 07:27.690
实际上函数组建它也能用

07:27.690 --> 07:29.010
不过我们目前的知识

07:29.010 --> 07:30.330
还没有设计到的一块

07:30.730 --> 07:31.410
我们

07:31.410 --> 07:33.410
rex的新版门里边

07:33.410 --> 07:35.370
已经加入了一个东西叫做hooks

07:35.690 --> 07:36.930
叫勾指函数

07:36.930 --> 07:38.490
那么那个东西有了之后

07:38.770 --> 07:41.450
在函数组建里边也可以使用状态了

07:41.450 --> 07:43.850
这也是为什么rex现在提倡

07:43.850 --> 07:45.130
尽量用函数组建

07:45.130 --> 07:47.650
但是目前我们还没有学习到那一块

07:47.690 --> 07:48.730
那个东西还早

07:48.970 --> 07:50.530
跟我们目前的知识还早

07:50.770 --> 07:52.650
所以说目前我们可以认为

07:52.650 --> 07:55.530
只有内组建里边才有效

07:55.530 --> 07:56.930
才能够使用状态

07:56.930 --> 07:58.410
所以说不设计到函数组建了

07:59.570 --> 08:01.890
因此我们这里函数组建不说了

08:02.290 --> 08:05.250
只说内组建里边怎么去使用状态

08:05.810 --> 08:06.090
好

08:06.090 --> 08:07.690
那么我们看一下状态的本质

08:07.930 --> 08:08.570
状态

08:08.570 --> 08:09.930
它的单词叫做stat

08:11.330 --> 08:16.330
本质上是内组建的一个属性

08:16.530 --> 08:18.050
它本质上就是一个属性

08:18.650 --> 08:20.370
我们之前说了个probs

08:20.370 --> 08:20.810
对吧

08:20.810 --> 08:21.450
probs

08:21.690 --> 08:22.650
是不是它的属性

08:22.650 --> 08:25.130
是不是对象内的对象的一个属性

08:25.130 --> 08:25.650
对吧

08:25.970 --> 08:26.930
好stat

08:26.930 --> 08:28.610
它也是对象的一个属性

08:28.770 --> 08:31.090
只不过这个属性要我们自行控制

08:31.370 --> 08:32.570
不是别人传过来的

08:32.570 --> 08:33.810
是我们自己控制的

08:34.570 --> 08:36.410
那么我们这里的这里到一个问题

08:36.530 --> 08:38.810
就是对状态的初始化

08:39.690 --> 08:40.930
状态初始化

08:40.930 --> 08:42.650
因为我们是我们自己的数据

08:42.810 --> 08:43.730
不是别人给我的

08:43.730 --> 08:44.810
所以说你肯定要初始化

08:46.810 --> 08:48.530
那么这里还要说一句

08:48.530 --> 08:49.570
就是说这个状态

08:49.570 --> 08:50.770
它是一个对象

08:50.770 --> 08:51.810
是一个对象

08:51.810 --> 08:54.290
你不能把它整成一个什么制服创的一种

08:54.290 --> 08:55.050
就不要来了

08:55.050 --> 08:55.850
它是一个对象

08:55.850 --> 08:56.730
是个对象

08:57.410 --> 08:59.130
那么这个状态初始化

08:59.130 --> 08:59.930
怎么来初始化

09:00.290 --> 09:02.250
有两种初始化方式

09:02.770 --> 09:03.690
第一种初始化方式

09:03.890 --> 09:06.050
是我们在勾造函数里面

09:06.050 --> 09:07.210
对它进行初始化

09:07.810 --> 09:08.970
勾造函数里边

09:09.970 --> 09:10.730
勾造函数里边

09:10.730 --> 09:11.610
我们之前不是写过吗

09:11.610 --> 09:12.130
对吧

09:12.130 --> 09:12.890
安部机会班

09:12.890 --> 09:14.250
先把前辆行写好

09:14.450 --> 09:15.530
写好之后

09:15.850 --> 09:18.490
我们就可以对这个状态进行初始化了

09:18.810 --> 09:20.570
怎么初始化就非常简单

09:20.570 --> 09:21.570
res state

09:21.570 --> 09:22.410
等于一个对象

09:22.410 --> 09:22.930
完事了

09:23.250 --> 09:23.730
完了

09:23.730 --> 09:24.250
没了

09:25.130 --> 09:26.930
如果对象里面有属性的话

09:26.930 --> 09:28.650
那你给它写上属性流行了

09:29.170 --> 09:29.930
这个状态里面

09:29.930 --> 09:31.210
这是初始化状态

09:31.730 --> 09:32.890
初始化状态

09:33.450 --> 09:35.130
如果这个状态里面有些属性

09:35.130 --> 09:36.650
比方说剩余时间

09:36.650 --> 09:38.290
是不是我们的数据

09:38.290 --> 09:38.570
对吧

09:38.570 --> 09:40.130
属于我自己的倒计时

09:40.130 --> 09:41.050
组建的数据

09:41.770 --> 09:42.570
剩余时间多少

09:42.570 --> 09:43.290
我还不知道吗

09:43.290 --> 09:44.130
那谁知道了

09:44.570 --> 09:45.410
剩余时间

09:45.490 --> 09:46.330
Left

09:47.130 --> 09:48.210
剩余时间

09:48.570 --> 09:49.570
一开始等于啥

09:49.570 --> 09:51.170
一开始是不是等于可以

09:51.170 --> 09:52.530
它传过来的值

09:52.530 --> 09:53.170
对吧

09:53.570 --> 09:55.530
一开始等于它传过来的值

09:55.530 --> 09:56.210
对不对

09:56.650 --> 09:58.050
我们可以这样子设置

09:58.090 --> 10:00.290
一开始等于它传过来的值

10:02.090 --> 10:04.450
然后我们这里倒计时的剩余时间

10:04.450 --> 10:06.170
是不是我们这里就可以使用状态了

10:06.170 --> 10:07.450
就不再使用属性了

10:07.450 --> 10:07.810
对吧

10:07.810 --> 10:09.250
它的数据来自于哪呢

10:09.250 --> 10:12.410
来自于这个State里边的Left

10:12.410 --> 10:14.090
来自于这个剩余时间

10:14.650 --> 10:15.370
来自于这

10:15.450 --> 10:17.130
这是我们自己的数据

10:17.130 --> 10:18.810
只不过初实化的时候

10:18.810 --> 10:20.690
一开始来自于属性

10:20.690 --> 10:22.370
当然这个有的时候

10:22.370 --> 10:24.210
也一开始来自于一个固定的值

10:24.210 --> 10:25.050
也无所谓

10:25.050 --> 10:27.690
比方说倒计时就固定60秒

10:27.970 --> 10:29.330
不允许别人设置

10:29.330 --> 10:30.530
就固定为60秒

10:30.530 --> 10:31.010
那OK

10:31.010 --> 10:32.690
那直接设置60就完事了

10:32.690 --> 10:33.290
对吧

10:33.290 --> 10:34.490
是根据灵活处理

10:34.490 --> 10:36.650
总之这里要初实化状态

10:36.650 --> 10:38.690
状态是必须要初实化的

10:39.050 --> 10:39.890
必须要初实化

10:39.890 --> 10:40.410
否则的话

10:40.410 --> 10:41.610
这个属性为Undefend

10:42.050 --> 10:43.490
附内的构造函数里边

10:43.530 --> 10:45.530
并不会给你进行任何的初实化

10:45.530 --> 10:47.330
你必须要自行进行初实化

10:47.970 --> 10:48.210
好

10:48.210 --> 10:49.210
初实化状态

10:49.210 --> 10:51.690
然后这里我们直接显示状态就完事了

10:52.410 --> 10:54.170
所以说这边使用的时候

10:54.170 --> 10:55.210
还需不需要这样用

10:55.210 --> 10:56.690
不需要了

10:57.530 --> 10:58.370
不需要了

10:58.690 --> 11:01.290
咱们直接给他一个数字就行了

11:01.290 --> 11:03.210
比方说10秒钟

11:03.770 --> 11:05.090
总时间就是10秒钟

11:05.090 --> 11:06.090
那你去吧

11:06.490 --> 11:07.730
比卡丘你去吧

11:07.730 --> 11:08.730
去倒计时吧

11:09.010 --> 11:11.090
那么他就剩下的事情交给他了

11:11.090 --> 11:11.850
他有一个状态

11:11.850 --> 11:13.010
一开始就是10秒

11:13.370 --> 11:14.170
然后呢

11:14.610 --> 11:15.250
倒计时

11:16.410 --> 11:16.610
好

11:16.610 --> 11:19.130
那么怎么来每一秒钟变化一次呢

11:19.130 --> 11:21.050
是不是就可以直接写到构造函数里边

11:21.250 --> 11:21.730
对吧

11:21.730 --> 11:23.290
直接写到构造函数里边

11:23.810 --> 11:24.050
好

11:24.050 --> 11:24.850
构造函数里边

11:24.850 --> 11:26.050
我们可以这样的写啊

11:26.570 --> 11:27.250
Z

11:27.970 --> 11:28.770
Timer

11:28.770 --> 11:29.490
加个Timer

11:29.490 --> 11:30.690
就是这个是个对相嘛

11:30.690 --> 11:32.850
这个对相里边随便写啥属性都行

11:32.850 --> 11:34.370
只是这个属性的比较特殊

11:34.370 --> 11:35.290
这个属性比较特殊

11:35.290 --> 11:36.330
这两个属性你不要动

11:36.330 --> 11:37.570
其他属性你随便写

11:38.050 --> 11:38.290
好

11:38.290 --> 11:39.210
set interval

11:39.890 --> 11:40.850
set interval

11:41.850 --> 11:44.290
每隔一段时间

11:44.290 --> 11:46.810
每隔一秒钟干嘛了

11:46.810 --> 11:47.970
干嘛了

11:47.970 --> 11:51.970
是不是把这个Z step里边的Left减减

11:51.970 --> 11:52.690
对吧

11:52.690 --> 11:54.010
是不是这样减减

11:54.010 --> 11:55.130
对不对

11:55.130 --> 11:56.330
减减之后呢

11:56.330 --> 11:57.930
是不是要重新渲染

11:58.530 --> 12:00.410
重新渲染一次

12:00.410 --> 12:01.090
对吧

12:01.090 --> 12:02.130
是不是要重新渲染

12:02.130 --> 12:03.770
那问题是怎么重新渲染的

12:03.770 --> 12:05.970
有时候要说掉一次Render

12:06.650 --> 12:08.210
你掉一次Render没用

12:08.210 --> 12:08.930
没用

12:08.930 --> 12:10.530
因为这个Render这个函数

12:10.690 --> 12:12.050
它要重新渲染了

12:12.050 --> 12:14.610
它是要追Ax这个库

12:14.610 --> 12:15.650
它自己去调用

12:15.650 --> 12:16.930
你自己调用没用的

12:16.930 --> 12:17.610
没用的

12:17.610 --> 12:18.610
它不会衰离了

12:18.610 --> 12:20.450
因为这个Render它有返回值

12:20.450 --> 12:20.970
对吧

12:20.970 --> 12:23.730
Rex它会自动的去调用Render

12:23.730 --> 12:24.530
合适的时候

12:24.530 --> 12:25.890
它会自动去调用Render

12:25.890 --> 12:28.050
把它的返回值来进行重新渲染

12:28.050 --> 12:29.610
你这里调用没用的

12:30.010 --> 12:31.210
那这个是怎么办的

12:31.930 --> 12:34.330
这要我们引出另外一个支持点

12:35.210 --> 12:35.770
好

12:35.770 --> 12:37.410
就是初说刚才我们说的

12:37.410 --> 12:39.970
一个是状态的变化

12:41.250 --> 12:42.370
状态的变化

12:43.090 --> 12:46.690
状态它是属于我们组建自己的数据

12:46.690 --> 12:48.690
我自己的数据当然可以随便变

12:48.690 --> 12:50.130
我的东西

12:50.130 --> 12:51.810
我的东西当然可能随便动

12:51.810 --> 12:53.530
我爱干嘛干嘛

12:53.530 --> 12:54.250
对吧

12:54.250 --> 12:56.450
那么状态它的变化了

12:56.450 --> 12:58.650
你不能直接这样子做

12:58.650 --> 12:59.970
不能直接这样子改变

13:00.970 --> 13:01.570
跑哪去了

13:01.570 --> 13:02.770
刚才写了这个

13:02.770 --> 13:04.010
你不能直接这样做

13:04.010 --> 13:05.410
千万千万不能

13:05.410 --> 13:07.170
在无忧里面你随便这样子玩

13:07.170 --> 13:08.250
它是可以识别的

13:08.250 --> 13:10.090
它可以完成响应式

13:10.170 --> 13:12.130
因为Review里面它使用了一些魔法

13:12.130 --> 13:14.130
它可以给你进行的特殊处理

13:14.130 --> 13:17.090
但是Review X里面它没有任何魔法

13:17.090 --> 13:20.090
所以说你这样直接改变数据

13:20.090 --> 13:22.530
它并不知道数据变了

13:22.530 --> 13:23.650
不知道数据变了

13:23.650 --> 13:25.890
它就不知道要重新渲染

13:25.890 --> 13:26.970
那怎么办呢

13:26.970 --> 13:28.850
这里状态的变化

13:28.850 --> 13:31.770
你必须使用必须使用

13:32.970 --> 13:34.650
this set state

13:36.490 --> 13:39.210
使用这种方式改变状态

13:40.370 --> 13:42.050
必须要这样做

13:42.050 --> 13:45.410
尽管有些同学可能学过Review X一段时间

13:45.410 --> 13:46.370
他知道

13:46.370 --> 13:48.690
能不能其实也可以直接改变

13:48.690 --> 13:50.290
也可以实现类似的效果

13:50.290 --> 13:52.250
但是千万不要这样做

13:52.250 --> 13:53.290
危险

13:53.290 --> 13:54.130
为什么危险

13:54.130 --> 13:56.450
我们后边讲到原理部分的时候

13:56.450 --> 13:57.770
就会详细说

13:57.770 --> 13:59.610
当然听到这里可能会

13:59.610 --> 14:02.450
之前我讲的这几节课

14:02.450 --> 14:05.610
基本上就没给大家避免了很多东西

14:05.610 --> 14:08.010
都尽量的没有提一些原理性的东西

14:08.010 --> 14:09.170
因为我们之前说过

14:09.210 --> 14:10.770
咱们的课程先用

14:10.770 --> 14:11.690
用起来的过程

14:11.690 --> 14:13.810
后面再讲它的原理

14:14.650 --> 14:15.530
包括它的原代

14:16.690 --> 14:17.650
之前的我课程

14:17.650 --> 14:18.410
其实有个地方

14:18.410 --> 14:20.890
我没有考虑的特别周到

14:20.890 --> 14:22.330
就是我过早的去提到了

14:22.330 --> 14:23.810
怎么组建对象

14:23.810 --> 14:25.890
以及react元素

14:25.890 --> 14:27.530
就是很多同学有可能用音搞晕

14:27.530 --> 14:29.330
react元素

14:29.330 --> 14:30.530
跟那个组建对象

14:30.530 --> 14:31.850
不是我们一个内组件吗

14:31.850 --> 14:33.810
内组件的对象就是溜了一个

14:33.810 --> 14:35.210
内的对象对吧

14:35.210 --> 14:37.610
但它们之间有什么联系和区别呢

14:37.690 --> 14:39.330
就可能那块用音

14:39.330 --> 14:41.050
如果你真的能想到这一点

14:41.050 --> 14:43.090
我非常非常佩服你

14:43.090 --> 14:46.890
你的思维非常的整立和气质

14:46.890 --> 14:50.410
但是现在我确实不太好给你解释

14:50.410 --> 14:51.090
没关系

14:51.090 --> 14:53.130
大家这样的疑问把它记录下来

14:53.130 --> 14:54.250
就当这件事

14:54.250 --> 14:55.090
把记录下来过后

14:55.090 --> 14:56.570
就当这件事没有发生过

14:56.570 --> 14:58.330
把这一页给它掀过去

14:58.330 --> 15:00.210
咱们后边讲原理的时候

15:00.210 --> 15:02.890
我一定会给你解释的非常清楚

15:02.890 --> 15:04.810
所以大家不用担心

15:04.810 --> 15:05.850
你现在只需要知道

15:05.890 --> 15:06.890
内组件怎么写

15:06.890 --> 15:07.810
内组件怎么用

15:07.810 --> 15:08.650
韩束组件怎么写

15:08.650 --> 15:09.530
韩束组件怎么用

15:09.530 --> 15:09.890
就行了

15:09.890 --> 15:11.290
我们现在主要是讲应用

15:12.650 --> 15:14.210
好那么这里我们刚才说了

15:15.290 --> 15:17.730
状态不能直接改变

15:17.730 --> 15:20.370
不能直接改变状态

15:20.370 --> 15:22.330
为什么不能直接改变状态

15:22.330 --> 15:26.730
因为react无法监控到

15:26.730 --> 15:30.850
无法监控到状态发生了变化

15:30.850 --> 15:32.170
它不知道状态发生了变化

15:32.170 --> 15:34.490
你只是给一个对象的属性负责

15:34.530 --> 15:35.770
故意才知道你干了吗

15:35.770 --> 15:36.770
干了什么东西

15:36.770 --> 15:38.010
它不像无忧的样子

15:38.010 --> 15:40.410
无忧它是用define property

15:40.410 --> 15:41.410
对吧

15:41.410 --> 15:42.770
当然无忧3.0过后

15:42.770 --> 15:44.810
好像说要用proxy代理

15:44.810 --> 15:46.010
对象代理

15:46.010 --> 15:48.250
总之它是可以监控属性变化的

15:48.250 --> 15:50.010
但是react它没有魔法

15:50.010 --> 15:51.970
那些东西都称之为魔法

15:51.970 --> 15:53.530
它没有这些魔法

15:53.530 --> 15:54.890
所以它比较纯粹

15:54.890 --> 15:56.930
因此你直接改变数据

15:56.930 --> 15:58.370
它是不知道的变了

15:58.370 --> 15:59.570
它不会重新渲染

15:59.570 --> 16:00.370
那怎么办

16:00.370 --> 16:01.690
你要用这个东西

16:01.690 --> 16:03.250
set state

16:03.290 --> 16:04.330
这个东西哪来的

16:04.330 --> 16:05.810
来自于负类里边

16:05.810 --> 16:07.010
来自于负类里边

16:07.010 --> 16:08.730
负类里面给你提供了这个函数

16:08.730 --> 16:10.490
所以说你这里可以直接使用

16:10.490 --> 16:12.690
this set state

16:12.690 --> 16:13.810
表什么意思

16:13.810 --> 16:16.010
表示设置状态

16:16.010 --> 16:17.370
重新设置状态

16:17.370 --> 16:19.050
它指的是这么一个意思

16:19.050 --> 16:21.090
重新设置状态

16:21.090 --> 16:25.090
一旦调用了这个函数不得了

16:25.090 --> 16:30.210
一旦调用了this set state

16:30.250 --> 16:34.650
会导致组建重新渲染

16:34.650 --> 16:37.010
会导致组建重新渲染

16:37.010 --> 16:38.450
就这么个意思

16:38.450 --> 16:40.250
只要你调用这个set state

16:40.250 --> 16:41.530
它就会重新渲染

16:41.530 --> 16:45.730
那这个set state里边该传啥参数呢

16:45.730 --> 16:48.250
它是这样子的

16:48.250 --> 16:51.850
set state里边它的参数表示的是

16:51.850 --> 16:54.970
我们的state不是个对象吗

16:54.970 --> 16:56.690
你要改变状态

16:56.690 --> 16:59.570
你要重新给它一个对象

16:59.570 --> 17:01.210
重新给它一个对象

17:01.210 --> 17:02.450
它会怎么样呢

17:02.450 --> 17:05.090
它会把你给定的对象

17:05.090 --> 17:09.360
跟之前的对象进行混合

17:09.360 --> 17:11.040
了解什么叫混合吗

17:11.040 --> 17:12.520
mixing

17:12.520 --> 17:15.080
我以前讲的介石的时候是不是也讲过

17:15.080 --> 17:16.880
最基础的课程

17:16.880 --> 17:17.800
公开课里边

17:17.800 --> 17:18.680
公益课程

17:18.680 --> 17:20.080
免费的课程里边

17:20.080 --> 17:22.440
也讲过 要混合

17:22.440 --> 17:23.840
相当于就是用了个

17:23.840 --> 17:27.120
opt这个词

17:27.120 --> 17:28.600
o3

17:28.600 --> 17:30.640
来对它进行混合

17:30.640 --> 17:32.560
把这一个东西的数据

17:32.560 --> 17:34.440
覆盖掉原来的数据

17:34.440 --> 17:36.080
当然有相同属性就覆盖

17:36.080 --> 17:39.240
没有相同属性的就不管了

17:39.240 --> 17:40.640
它是这么个意思

17:40.640 --> 17:45.320
它会把这个数据混合到这一块

17:45.320 --> 17:46.160
那比方说

17:46.160 --> 17:48.320
这个数据叫做a

17:48.320 --> 17:49.240
比方说叫做a

17:49.240 --> 17:51.840
那么它会这样子来处理

17:51.840 --> 17:52.640
不解个词

17:52.640 --> 17:54.040
o3

17:54.040 --> 17:55.360
我们这里先简单些

17:55.360 --> 17:57.840
就是set state

17:57.840 --> 17:59.560
然后比方说

17:59.560 --> 18:01.440
我们这个差数叫对象a

18:01.440 --> 18:04.040
那么它会把a混合到这里边

18:04.040 --> 18:05.480
明白这个意思吧

18:05.480 --> 18:07.840
所以说这里我们设置的数据

18:07.840 --> 18:11.880
就相当于是把之前的数据进行了覆盖

18:11.880 --> 18:13.040
我们要改变谁的数据

18:13.040 --> 18:14.640
是不是改变left的数据

18:14.640 --> 18:15.400
对吧

18:15.400 --> 18:16.480
改变成什么

18:16.480 --> 18:19.360
改变成this props

18:19.360 --> 18:23.040
改变成之前的状态

18:23.040 --> 18:24.160
之前的状态是吧

18:24.160 --> 18:26.280
-1 对不对

18:26.320 --> 18:29.480
永远不要去直接改变状态

18:29.480 --> 18:31.600
改变状态一定要用调用函数

18:31.600 --> 18:33.680
因为你只有雕用了这个函数

18:33.680 --> 18:35.160
right才知道

18:35.160 --> 18:36.160
你雕用这个函数

18:36.160 --> 18:37.480
函数里边可以做任何事情

18:37.480 --> 18:37.840
对吧

18:37.840 --> 18:38.680
它马上就知道了

18:38.680 --> 18:40.800
雕这个函数就是要重新宣展

18:40.800 --> 18:42.240
那么它会进行混合

18:42.240 --> 18:43.560
把这个数据先覆盖

18:43.560 --> 18:45.480
覆盖过后重新宣展

18:45.480 --> 18:47.720
会自动重新宣展

18:47.720 --> 18:52.480
触发自动的重新宣展

18:52.480 --> 18:54.400
触发自动的重新宣展

18:54.400 --> 18:55.560
保存 咱们来看一下

18:57.480 --> 18:58.360
你看

18:58.360 --> 18:59.320
这完成了

18:59.320 --> 19:01.600
它就变成自我维护了

19:01.600 --> 19:03.440
因为状态是它自己的数据

19:03.440 --> 19:05.320
所以说它会自我维护

19:05.320 --> 19:07.520
当然这个宣展过后了

19:07.520 --> 19:08.600
导致了什么问题

19:08.600 --> 19:11.240
导致了它这个数据变成负疑了

19:11.240 --> 19:11.640
对吧

19:11.640 --> 19:12.840
变成负疑了

19:12.840 --> 19:14.920
因为我们一会来解决这个问题

19:14.920 --> 19:17.120
总之你看一下现在的结构

19:17.120 --> 19:19.560
看下这边对主见的使用者而言

19:19.560 --> 19:20.920
是不是非常简单了

19:20.920 --> 19:23.520
而且整个程序非常符合逻辑

19:23.560 --> 19:25.520
你是一个倒计时主见

19:25.520 --> 19:27.520
因此我只需要给你一个什么

19:27.520 --> 19:29.240
给你一个总时间

19:29.240 --> 19:30.560
总时间给力

19:30.560 --> 19:32.680
给力了之后你自己去倒计时

19:32.680 --> 19:33.520
关我啥事了

19:33.520 --> 19:34.480
关我屁事

19:34.480 --> 19:35.920
你不是倒计时主见吗

19:35.920 --> 19:36.960
你自己都不能倒计时

19:36.960 --> 19:39.000
然后我还要我来帮你

19:39.000 --> 19:40.640
那有什么意义的一个主见

19:40.640 --> 19:41.720
所以说这个主见

19:41.720 --> 19:43.880
它可能会需要自己的状态

19:43.880 --> 19:47.080
于是它自己状态里面进行了处理

19:48.480 --> 19:48.720
好

19:48.720 --> 19:49.640
这是第一种

19:49.640 --> 19:50.760
第一种

19:50.760 --> 19:52.400
刚才我们说到状态的初始化

19:52.400 --> 19:53.560
是在构造函数里面

19:53.560 --> 19:54.200
对吧

19:54.200 --> 19:56.080
这样的一种初始化方式

19:56.080 --> 19:58.640
那有没有别的初始化方式呢

19:58.640 --> 20:01.240
实际上还有一种初始化方式

20:01.240 --> 20:04.280
也是咱们非常常见的一种方式

20:04.280 --> 20:08.160
这种方式目前还出于试验性阶段

20:08.160 --> 20:10.200
还不是介式的标准

20:10.200 --> 20:13.600
就是说我们在介式内里面写属性了

20:13.600 --> 20:16.120
它可以这样子写在这里写

20:16.120 --> 20:17.760
也可以在这里写

20:17.760 --> 20:19.360
在这里直接写属性

20:19.360 --> 20:20.240
State

20:20.240 --> 20:21.320
等于

20:21.360 --> 20:22.120
等于啥呢

20:22.120 --> 20:23.280
直接在这里写

20:24.280 --> 20:25.360
也可以

20:25.360 --> 20:26.640
也可以

20:26.640 --> 20:28.200
那这句话就不要了

20:29.120 --> 20:29.760
这里呢

20:29.760 --> 20:31.480
它也是初始化状态

20:31.480 --> 20:32.880
另外一种方式

20:32.880 --> 20:33.720
初始化状态

20:33.720 --> 20:34.440
没问题

20:34.440 --> 20:35.240
没问题

20:35.240 --> 20:37.120
那么这个代码说在什么时候运行呢

20:37.120 --> 20:38.320
它是在SUPER

20:38.320 --> 20:39.680
它会自动给你加构造函数

20:39.680 --> 20:40.200
对吧

20:40.200 --> 20:41.480
在SUPER后边运行

20:41.480 --> 20:42.240
这个代码

20:42.240 --> 20:43.680
它在SUPER后边运行的

20:44.680 --> 20:44.920
好

20:44.920 --> 20:46.400
那就完事了

20:46.400 --> 20:46.840
对吧

20:46.840 --> 20:47.880
那就完事了

20:47.880 --> 20:48.800
那咱们看一下吧

20:49.800 --> 20:51.080
是不是一样的效果

20:51.080 --> 20:51.560
对吧

20:51.560 --> 20:53.040
完全一样的效果

20:53.040 --> 20:54.360
没有任何区别

20:54.360 --> 20:55.880
这是初始化状态

20:55.880 --> 20:57.760
你可以写到构造函数里边

20:57.760 --> 20:58.640
也可以使用

20:58.640 --> 20:59.800
这个是语法叫做

20:59.800 --> 21:03.600
这个是介式

21:03.600 --> 21:04.680
next

21:04.680 --> 21:06.240
语法

21:06.240 --> 21:09.040
就是下一代介式版本的语法

21:09.040 --> 21:12.640
目前出于试验阶段

21:12.640 --> 21:13.880
试验阶段

21:13.880 --> 21:15.400
并没有正式成为标准

21:15.400 --> 21:15.960
那有点说

21:15.960 --> 21:17.240
那没有正式成为标准

21:17.240 --> 21:18.400
那是不是要谨慎使用

21:18.440 --> 21:19.360
不能用啊

21:19.360 --> 21:20.360
不是的

21:20.360 --> 21:21.160
为什么不是

21:21.160 --> 21:22.680
因为我们有bable

21:22.680 --> 21:23.840
它可以进行编译

21:23.840 --> 21:26.080
把它编译成为正常的语法

21:26.080 --> 21:27.760
所以说根本不用担心

21:27.760 --> 21:30.160
包括内它都会给你进行编译

21:30.160 --> 21:31.960
编译成构造函数

21:31.960 --> 21:33.920
所以根本不用担心

21:33.920 --> 21:34.800
这是这一块

21:37.160 --> 21:39.440
这就是setState的作用

21:39.440 --> 21:40.560
它可以怎么样了

21:40.560 --> 21:43.320
它可以重新设置状态

21:43.320 --> 21:44.440
因为是我自己的数据

21:44.440 --> 21:46.320
所以说我有权利来维护

21:46.360 --> 21:48.360
并且它设置状态的时候

21:48.360 --> 21:50.280
会导致自动触发重新宣

21:52.120 --> 21:52.320
好

21:52.320 --> 21:54.840
接下来咱们要处理一个问题

21:55.600 --> 21:57.080
什么问题呢

21:57.080 --> 22:00.480
就是说我们这个NLIFT值

22:01.200 --> 22:02.360
NLIFT值

22:03.360 --> 22:07.280
当它等于零的时候

22:07.280 --> 22:08.920
当它等于零的时候

22:08.920 --> 22:10.680
我们要干嘛呢

22:10.680 --> 22:12.720
我们要把这个计时器停止

22:12.720 --> 22:14.040
就不能再计时了

22:14.040 --> 22:14.800
不能再计时了

22:14.840 --> 22:16.800
把这个计时器停止

22:16.800 --> 22:17.800
好比方说

22:19.800 --> 22:20.600
当它设置状态

22:20.600 --> 22:21.200
你设置呗

22:21.200 --> 22:22.720
你自己去设置

22:22.720 --> 22:24.320
设置完了过后

22:24.320 --> 22:29.480
如果ZestStateNLIFT

22:29.480 --> 22:31.800
如果等于了零

22:33.040 --> 22:34.160
是不是要停止计时器

22:34.160 --> 22:34.680
对吧

22:34.680 --> 22:39.000
停止计时器

22:39.000 --> 22:39.240
好

22:39.240 --> 22:41.000
怎么来停止呢

22:41.800 --> 22:44.200
Zest.Timer

22:44.200 --> 22:46.800
就是ClearInterval

22:46.800 --> 22:48.200
Zest.Timer

22:48.200 --> 22:49.400
把计时器停止

22:50.400 --> 22:51.600
咱们来看一下

22:51.600 --> 22:52.200
保存

22:53.000 --> 22:53.600
看一下

22:54.000 --> 22:54.400
小心

22:56.400 --> 22:57.200
我喝口水

22:57.200 --> 22:57.800
大家看一下

22:58.800 --> 22:59.600
是不是成功了

23:05.740 --> 23:06.540
是不是完事了

23:06.740 --> 23:07.140
对吧

23:07.140 --> 23:07.740
就完事了

23:07.740 --> 23:09.940
这是关于Zestate

23:11.540 --> 23:13.140
那么这里可以

23:13.540 --> 23:16.340
自动触发重新宣展

23:16.740 --> 23:18.540
这是关于Zestate

23:19.540 --> 23:20.140
好了

23:20.140 --> 23:21.940
那么我们就可以

23:21.940 --> 23:23.340
其实就非常简单

23:23.340 --> 23:24.540
就差不多完了

23:24.540 --> 23:26.140
这个ZestateDate里面

23:26.140 --> 23:27.740
其实还有很多很多的东西

23:28.740 --> 23:30.340
目前我们现在讲不到

23:30.340 --> 23:32.140
因为它还涉及到事件

23:32.140 --> 23:33.140
还涉及到事件

23:33.140 --> 23:34.940
所以说目前我们还讲不到

23:34.940 --> 23:36.740
等我们讲了事件过后

23:36.740 --> 23:38.540
我们还会回过头来

23:38.540 --> 23:40.140
来说Zestate

23:40.140 --> 23:41.340
但现在我们这里

23:41.340 --> 23:42.740
其实已经差不多了

23:42.740 --> 23:44.140
我们现在只需要知道

23:44.140 --> 23:44.940
一个组件

23:44.940 --> 23:47.940
它有可能有自己的状态

23:47.940 --> 23:49.740
那么如果一个组件有自己的状态

23:49.740 --> 23:51.140
它必须是内组件

23:51.340 --> 23:52.940
这个状态需要出实化

23:52.940 --> 23:54.940
可以在勾到函数里面进行出实化

23:54.940 --> 23:57.540
也可以在这里进行出实化

23:57.940 --> 23:58.940
它会进行

23:58.940 --> 24:02.740
它会在背部里边进行编译

24:02.940 --> 24:04.540
编译成为正常的语法

24:04.740 --> 24:06.540
那么我们这里就可以

24:06.740 --> 24:09.340
在组件内部来控制数据了

24:09.540 --> 24:10.540
控制数据的方式

24:10.540 --> 24:12.140
不能直接改变数据

24:12.740 --> 24:15.540
你要使用Zestate来改变数据

24:15.540 --> 24:17.740
它会把之前的数据进行覆盖

24:18.140 --> 24:18.940
进行覆盖

24:19.140 --> 24:20.340
那比方说这个数据里边

24:20.340 --> 24:21.340
还有别的东西

24:21.340 --> 24:22.540
比方说还有个N

24:22.740 --> 24:24.140
比方说123

24:24.140 --> 24:25.140
就随便想写一个

24:25.540 --> 24:26.340
还有个N

24:26.740 --> 24:28.540
那么我们再输出N

24:29.140 --> 24:29.940
比方说

24:31.140 --> 24:32.540
这里我们写着这个东西

24:35.340 --> 24:38.140
再输出一个P元数N

24:38.340 --> 24:40.140
你看一下N会不会受影响

24:40.140 --> 24:41.340
它当然要这样子写

24:41.340 --> 24:43.740
ZestateN

24:44.140 --> 24:45.740
看一下N会不会受影响

24:46.740 --> 24:47.540
是不是不会受影响

24:47.540 --> 24:48.140
对吧

24:48.540 --> 24:49.940
不是说我们到时候

24:49.940 --> 24:52.740
把这个对象重新给State复制

24:52.740 --> 24:54.340
不是的

24:54.340 --> 24:56.740
它是把这里边的数据覆盖过去

24:56.740 --> 24:58.940
有相同的数据进行覆盖

24:59.140 --> 25:00.140
是这么回事

25:01.340 --> 25:03.140
所以说N它不会受影响

25:03.940 --> 25:04.940
关于State

25:04.940 --> 25:06.540
State里边还有很多东西

25:06.540 --> 25:08.340
我们后边才能讲

25:09.340 --> 25:13.140
然后我们这里就可以清楚的知道

25:13.140 --> 25:14.540
由于StateState

25:14.540 --> 25:16.740
它会导致重新渲染

25:17.540 --> 25:20.340
那么它就会导致这么一个问题

25:20.340 --> 25:21.340
不适合问题

25:21.340 --> 25:22.940
它就会有这么一个现象

25:23.340 --> 25:23.940
看着

25:24.940 --> 25:28.740
我们这里定义了一个Test

25:28.940 --> 25:30.340
Test点介绍

25:30.740 --> 25:32.740
这里边我们提供了三个组件

25:33.140 --> 25:33.740
CC

25:34.140 --> 25:35.140
这是一个组件

25:35.940 --> 25:36.540
内组件

25:37.140 --> 25:40.340
它里边有一个State属性

25:41.340 --> 25:42.340
State属性

25:42.340 --> 25:43.740
比方说就一个N

25:44.140 --> 25:44.940
就一个N

25:45.140 --> 25:45.740
123

25:47.140 --> 25:47.940
有这么一个属性

25:49.140 --> 25:50.140
它里边

25:50.340 --> 25:51.740
我们这里再写个组件

25:51.940 --> 25:52.740
方形B

25:53.540 --> 25:54.740
就是一个函数组件

25:55.140 --> 25:55.940
方形B

25:56.340 --> 26:00.740
这个B它返回的是一个DIV

26:00.740 --> 26:01.940
返回一个DIV

26:02.340 --> 26:03.140
这是B组件

26:04.140 --> 26:04.940
B组件

26:05.940 --> 26:07.340
B组件里边

26:07.540 --> 26:08.540
它有个属性

26:08.540 --> 26:10.140
它来自于一个属性的值

26:11.740 --> 26:15.740
把属性里边的N拿到

26:15.740 --> 26:17.140
把属性里面N拿到

26:17.140 --> 26:18.340
我们先写完

26:18.340 --> 26:19.340
我们再看现象

26:20.140 --> 26:20.940
Props

26:22.340 --> 26:23.540
这里边有个组件

26:23.540 --> 26:24.140
Return

26:24.740 --> 26:25.340
DIV

26:26.340 --> 26:27.340
这是C组件

26:27.940 --> 26:28.740
C组件

26:28.740 --> 26:30.540
里边有个属性Props

26:30.740 --> 26:31.140
N

26:31.740 --> 26:32.940
它有个属性N

26:35.140 --> 26:36.140
这里为什么保错了

26:36.140 --> 26:37.140
我这里写的

26:37.540 --> 26:38.140
我的天啊

26:38.140 --> 26:38.740
写的是啥

26:39.740 --> 26:42.540
然后B里边去使用了C组件

26:42.940 --> 26:44.540
B里边去使用了C组件

26:44.540 --> 26:46.540
所以说B里边它可能会这样子写

26:47.140 --> 26:47.740
C

26:48.540 --> 26:49.140
C组件

26:49.340 --> 26:50.740
然后给它传递一个属性

26:50.740 --> 26:52.140
它不知道需要个属性N吗

26:52.140 --> 26:52.540
对吧

26:52.540 --> 26:53.540
我传递给它

26:53.540 --> 26:54.540
怎么传递给它

26:54.540 --> 26:56.740
我把自己的属性N也传给它

26:57.340 --> 26:59.140
把自己的属性N传给它

26:59.940 --> 27:00.540
没问题吧

27:01.140 --> 27:02.140
这个数据传递

27:02.140 --> 27:02.540
对吧

27:02.540 --> 27:03.740
别人给我的数据

27:03.740 --> 27:05.340
那我也把这个数据给你

27:05.340 --> 27:05.840
对不对

27:05.840 --> 27:06.340
给你

27:06.940 --> 27:08.140
这是组件C

27:08.140 --> 27:09.940
当然这个没有什么实际意义

27:09.940 --> 27:11.540
我这里只是说明一个问题

27:11.740 --> 27:11.940
好

27:11.940 --> 27:13.540
那么这里我们使用B组件

27:14.540 --> 27:15.140
B组件

27:15.140 --> 27:16.340
那我这里就把

27:16.340 --> 27:18.440
它不是需要一个属性N吗

27:18.440 --> 27:19.940
我这里N来自于哪呢

27:19.940 --> 27:20.940
来自于State

27:21.640 --> 27:23.140
RestorStateN

27:23.940 --> 27:25.140
看一下这个结构

27:25.640 --> 27:27.740
咱们来看一下这个组件A的结构

27:27.940 --> 27:29.340
这个A里边有一个状态

27:29.340 --> 27:30.940
它是属于A的数据

27:31.140 --> 27:32.740
属于组件A的数据

27:33.140 --> 27:33.940
然后呢

27:33.940 --> 27:35.740
我们把这个N

27:35.740 --> 27:38.340
通过属性传递给组件B

27:38.940 --> 27:40.540
然后组件B里边呢

27:40.740 --> 27:43.940
又把这个获得的属性里边的数据呢

27:43.940 --> 27:46.540
又通过属性N传递给C

27:46.740 --> 27:48.340
C里边的数据就把它显示出来

27:48.540 --> 27:51.740
形成了这么一个数据传递的这种结构

27:51.740 --> 27:53.140
数据的源头在哪

27:53.140 --> 27:54.740
源头是不是在A里边

27:55.140 --> 27:56.140
这是它自己的数据

27:56.140 --> 27:57.140
属于它的数据

27:57.140 --> 27:58.140
源头在这

27:58.640 --> 27:59.340
然后呢

27:59.340 --> 28:00.540
我们把这个数据呢

28:00.540 --> 28:01.540
就一层一层

28:01.540 --> 28:03.140
传递给它的组织件B

28:03.140 --> 28:05.140
B又传递给它的组织件C

28:05.140 --> 28:07.740
你看是不是一个从上到下的传递

28:07.740 --> 28:08.340
对吧

28:08.340 --> 28:10.340
单向数据流传递过去

28:10.540 --> 28:13.340
然后接下来我们在A里边写个构造函数

28:15.630 --> 28:16.230
super

28:17.630 --> 28:18.230
proper

28:18.830 --> 28:20.630
然后呢这里set interval

28:23.540 --> 28:24.340
set interval

28:24.740 --> 28:24.840
好

28:24.840 --> 28:25.540
这边呢

28:25.940 --> 28:27.740
每个一秒钟

28:27.740 --> 28:28.640
每个一秒钟

28:28.640 --> 28:29.340
干嘛呢

28:30.140 --> 28:31.740
重新设置状态

28:32.540 --> 28:34.440
把N的值重新设置为啥

28:35.040 --> 28:37.740
之前的值N的值减去1

28:37.740 --> 28:39.740
之前的N的值减去1

28:40.540 --> 28:40.640
好

28:40.640 --> 28:41.840
这样子重新设置一下

28:42.440 --> 28:43.240
这个能看懂吗

28:43.740 --> 28:45.440
我改变自己的状态

28:45.440 --> 28:45.740
对吧

28:45.740 --> 28:46.740
改变自己的状态

28:46.740 --> 28:48.940
我们来看一下会发生什么样的现象

28:49.640 --> 28:49.840
好

28:49.840 --> 28:50.540
我们这里呢

28:50.540 --> 28:51.640
先把这个注射掉啊

28:52.040 --> 28:53.140
这个注射掉

28:53.740 --> 28:54.840
这里导入什么

28:54.840 --> 28:56.240
导入这个组件A

28:56.640 --> 28:57.840
导入这个组件A

28:57.840 --> 29:00.540
from component test

29:01.440 --> 29:02.540
导入这个组件A

29:02.940 --> 29:04.640
这个因为这个组件A是导出的

29:04.640 --> 29:04.940
对吧

29:04.940 --> 29:05.640
导出的

29:05.640 --> 29:05.940
好

29:05.940 --> 29:06.940
导入这个组件A

29:06.940 --> 29:07.940
那咱们呢这里呢

29:07.940 --> 29:08.840
react動

29:09.340 --> 29:10.640
最终渲染什么呢

29:10.640 --> 29:14.140
渲染的是这个A这个组件

29:14.540 --> 29:15.140
A这个组件

29:15.140 --> 29:15.840
它没有数据

29:15.840 --> 29:17.040
因为它自己有状态

29:17.040 --> 29:18.240
自我维护数据

29:18.540 --> 29:18.640
好

29:18.640 --> 29:18.940
这里呢

29:18.940 --> 29:20.940
我们把这个容器加进去

29:22.140 --> 29:22.640
保存

29:22.640 --> 29:23.440
咱们来看一下

29:25.140 --> 29:27.540
你看是不是所有的组件都跟着变化了

29:27.940 --> 29:29.040
怎么回事呢

29:29.040 --> 29:29.540
咱们来

29:30.040 --> 29:30.740
检查

29:30.940 --> 29:32.640
这里使用react调试

29:32.640 --> 29:33.740
你看一下组件结构

29:34.640 --> 29:36.240
最Y层的是不是A组件

29:36.240 --> 29:36.640
对吧

29:36.640 --> 29:38.440
咱们最顶层的是A组件

29:38.540 --> 29:40.840
我用一个A组件里面说一个State一个数据

29:40.840 --> 29:41.140
对吧

29:41.140 --> 29:41.640
一个数据

29:41.640 --> 29:43.340
这个数据呢不断的被改变

29:43.940 --> 29:44.540
然后呢

29:44.540 --> 29:45.940
它里边有一些直组件

29:45.940 --> 29:46.440
对吧

29:46.440 --> 29:47.640
B这个直组件

29:47.640 --> 29:48.140
啊

29:48.140 --> 29:50.140
这个直组件里面又有个C的直组件

29:50.140 --> 29:50.740
看没有

29:51.040 --> 29:51.540
好

29:51.540 --> 29:52.340
那么怎么呢

29:52.340 --> 29:53.640
理解这个行为呢

29:53.640 --> 29:55.640
我们把这里一个设置啊

29:55.640 --> 29:56.640
这个设置打开

29:56.740 --> 29:59.140
这里有个HighLandUpdate

29:59.640 --> 30:01.440
什么就是高量更新

30:01.440 --> 30:02.140
什么意思

30:02.140 --> 30:02.840
就是

30:03.340 --> 30:05.340
当我们数据发生变化的时候

30:05.340 --> 30:07.640
哪些组件重新渲染了

30:07.940 --> 30:08.640
把勾上

30:09.340 --> 30:10.140
把勾上

30:11.040 --> 30:11.440
啊

30:11.540 --> 30:12.740
当我们数据更新的时候

30:12.740 --> 30:13.740
哪些组件重新渲染了

30:13.740 --> 30:15.840
你看B组件是不是重新渲染了

30:16.240 --> 30:18.040
C组件是不是也重新渲染了

30:18.140 --> 30:19.140
怎么回事呢

30:19.440 --> 30:21.340
我们可以这样要这样子理解

30:21.740 --> 30:23.840
当我们调用setState的时候

30:24.740 --> 30:25.540
改变了谁

30:25.640 --> 30:27.540
改变了A的状态对吧

30:27.640 --> 30:28.740
A的状态发生改变

30:28.740 --> 30:29.640
我们之前说过

30:30.040 --> 30:32.740
一旦状态发生改变

30:32.940 --> 30:35.840
会导致当前组件重新渲染

30:36.140 --> 30:36.940
哪个是当前组件

30:36.940 --> 30:38.040
是不是A这个组件

30:38.140 --> 30:39.540
它会重新渲染

30:39.740 --> 30:41.440
那么是不是会运行Render

30:41.540 --> 30:41.940
对吧

30:41.940 --> 30:43.640
我们来Render里面输出一下啊

30:43.740 --> 30:44.540
输出一下

30:44.940 --> 30:47.740
A组件重新渲染了

30:48.940 --> 30:50.640
渲染的

30:51.140 --> 30:51.740
保存啊

30:51.740 --> 30:52.740
咱们来看一下啊

30:53.240 --> 30:54.540
你看是不是不断的输出

30:54.740 --> 30:55.080
对吧

30:55.080 --> 30:56.040
不断的输出

30:56.540 --> 30:58.240
每一次调用setState

30:58.240 --> 31:00.040
是不是导致A组件重新渲染

31:00.240 --> 31:01.640
好A组件去渲染的时候

31:01.640 --> 31:04.640
你一看是不是要重新构建这个结构

31:05.340 --> 31:07.040
重新构建结构的时候

31:07.040 --> 31:10.140
是不是导致了B组件的属性值发生的变化

31:10.440 --> 31:10.940
对吧

31:11.140 --> 31:12.740
B组件是不是要重新构建

31:13.440 --> 31:14.740
是不是重新构建

31:15.040 --> 31:16.240
我们之前不是

31:17.240 --> 31:19.640
写了一个set7setinterval在index里面写的

31:19.640 --> 31:20.040
对吧

31:20.040 --> 31:21.740
不断的重新Render重新渲染

31:21.740 --> 31:21.940
对吧

31:21.940 --> 31:23.040
这里是一样的道理

31:23.040 --> 31:24.140
是一样的道理

31:24.740 --> 31:26.040
当它调用Render的时候

31:26.040 --> 31:28.040
是不是导致这里边也要重新渲染

31:28.440 --> 31:30.340
于是它又会导致B的重新渲染

31:30.340 --> 31:31.340
因为B在它里边

31:32.340 --> 31:33.440
B重新渲染的时候

31:33.440 --> 31:35.240
是不是就导致了C有重新渲染

31:35.740 --> 31:36.340
对不对

31:36.340 --> 31:38.240
它是一层一层传递过去的

31:38.640 --> 31:40.840
所以说当A组件渲染的时候

31:41.040 --> 31:42.440
B组件也跟着渲染了

31:42.840 --> 31:43.640
也跟着渲染了

31:44.240 --> 31:45.040
是这么回事

31:45.440 --> 31:46.740
那么我们这一块

31:47.340 --> 31:48.440
渲染的根在哪

31:48.440 --> 31:49.440
渲染的根在A

31:49.640 --> 31:50.740
A的数据发生变化

31:50.740 --> 31:52.140
导致了A下边的时候

31:52.140 --> 31:54.240
所有东西都发生了变化

31:55.140 --> 31:55.940
都发生了变化

31:56.840 --> 31:57.240
对吧

31:57.740 --> 31:58.140
看到没

31:58.240 --> 31:59.040
这么没问题的

32:00.140 --> 32:01.640
我们就这样子来处理了

32:01.640 --> 32:03.740
就导致了这些地方的重新渲染了

32:04.440 --> 32:05.240
明白这个意思吗

32:06.140 --> 32:07.740
这是关于这一块

32:07.940 --> 32:08.540
这一块

32:08.640 --> 32:11.740
就是说我们如何来改变某一个区域的数据

32:11.740 --> 32:14.640
就是其实你只要把这个区域的数据一改

32:15.040 --> 32:16.240
就是状态一改

32:16.240 --> 32:19.140
那么这一块跟状态相关的所有数据

32:19.140 --> 32:19.940
也跟着改了

32:20.340 --> 32:21.440
因为状态的改变

32:21.440 --> 32:22.840
导致这个组件重新渲染

32:22.840 --> 32:24.240
而这个组件重新渲染

32:24.240 --> 32:26.540
导致它的直组件也跟着重新渲染

32:27.540 --> 32:29.240
不会有什么效率问题

32:29.740 --> 32:30.540
不会有什么效率

32:30.540 --> 32:31.840
你想这个道理呗

32:32.340 --> 32:34.340
你A组件重新数据变了

32:34.340 --> 32:36.340
那你说按你说这个B

32:36.640 --> 32:37.740
要不要重新宣传

32:37.940 --> 32:38.540
那不重新宣传

32:38.540 --> 32:39.940
它还是读到以前的指导

32:39.940 --> 32:41.240
肯定是不符合逻辑的

32:41.240 --> 32:41.640
对吧

32:41.840 --> 32:43.540
因为跟这个数据就不一致了

32:43.940 --> 32:45.940
所以说这里也肯定会导致重新宣传

32:46.340 --> 32:48.940
它是这样子是一层一层传官的

32:49.140 --> 32:51.940
通过这个例子也可以看出什么单向数据流

32:51.940 --> 32:52.440
对不对

32:52.640 --> 32:53.340
单向数据流

32:53.340 --> 32:55.740
数据从A开始起源在A

32:55.940 --> 32:57.140
传递给这个B

32:57.940 --> 32:59.640
然后B在传递给这个C

32:59.640 --> 33:00.240
看到没有

33:00.540 --> 33:03.040
B和C让它无权改变这个数据

33:03.040 --> 33:04.940
但是A可以改变这个数据

33:04.940 --> 33:06.640
因为这个数据是属于A的

33:07.140 --> 33:10.840
那么这个A的如果A还有一个副组件

33:11.640 --> 33:13.540
比方说A还有一个副组件

33:13.540 --> 33:14.940
那么这个A的副组件

33:14.940 --> 33:16.140
它能不能改变这个数据呢

33:16.140 --> 33:16.840
就不能了

33:17.440 --> 33:19.240
数据属于谁

33:19.540 --> 33:20.940
谁就有权力改变

33:20.940 --> 33:23.640
始终记住这个React的根本哲学

33:25.840 --> 33:28.640
ok 这是关于State里边的东西

33:29.240 --> 33:32.340
那么现在我们就学习了组件的状态

33:32.540 --> 33:35.140
于是组件里边是不是出现了两种数据了

33:35.840 --> 33:37.640
组件中的数据

33:37.840 --> 33:39.940
它不是来自于两个地方了对吧

33:40.040 --> 33:41.540
一个是什么 Probs

33:42.640 --> 33:44.540
probs 就是来自于属性

33:44.940 --> 33:47.240
就是别人传递过来的数据

33:48.040 --> 33:48.840
该数据

33:50.140 --> 33:51.740
是由

33:52.340 --> 33:53.040
由什么呢

33:53.040 --> 33:56.240
由那个组件的使用者

33:56.240 --> 33:57.740
就是谁在用这个组件

33:57.740 --> 33:59.740
用的人传递过来的数据

33:59.740 --> 34:03.240
是主要的使用者传递的数据

34:04.740 --> 34:05.340
数据

34:06.640 --> 34:09.340
所有权不属于什么

34:09.640 --> 34:11.840
不属于组件自身

34:12.740 --> 34:14.840
但是是不是来自于传递的

34:14.940 --> 34:17.940
它的所有权是不是来自一定来自于传递者的呢

34:18.540 --> 34:19.840
谁传递了这个数据

34:19.840 --> 34:21.240
它的数据属于谁呢

34:21.740 --> 34:23.340
也不一定比方说这里吧

34:24.440 --> 34:27.040
这个组件C的数据是谁传过来的

34:27.040 --> 34:28.540
是不是组件B的传过来的

34:29.140 --> 34:31.740
那人说这个数据是属于组件B的吗

34:31.740 --> 34:32.640
也不是

34:32.840 --> 34:34.440
这个数据它也没有这个权利

34:34.440 --> 34:35.940
它只是把别人传递过来的

34:35.940 --> 34:37.040
又传给你给你了

34:37.140 --> 34:38.640
又传递给你你了对吧

34:38.640 --> 34:39.740
又传递给C了

34:39.940 --> 34:41.940
所以说也不能说它属于它

34:42.440 --> 34:44.540
关键是谁的状态在哪

34:44.540 --> 34:45.240
就属于谁

34:45.540 --> 34:46.240
就属于谁

34:46.640 --> 34:48.640
那状态就是组件自身的东西了

34:49.340 --> 34:51.740
所有权不属于组件自身

34:51.740 --> 34:56.040
因此组件无法改变该数据

34:56.940 --> 34:58.440
绝对不能去改变

34:58.540 --> 34:59.840
第二个State

35:00.540 --> 35:02.240
对比一下对比一下这两个东西

35:02.840 --> 35:05.040
这些东西都是组件里面的数据

35:05.240 --> 35:11.140
该数据是由是由组件自身创建的

35:12.440 --> 35:16.440
所有权属于组件自身

35:16.840 --> 35:22.840
自身因此组件有权利改变该数据

35:23.940 --> 35:25.140
该数据

35:26.440 --> 35:27.840
再严格一点来说

35:28.140 --> 35:30.440
这个数据只有这个组件能改变

35:30.440 --> 35:32.240
其他任何东西都不能改变这个数据

35:32.340 --> 35:33.540
因为它是属于自己的

35:33.740 --> 35:34.640
数据属于谁

35:34.740 --> 35:35.640
谁就能改变

35:36.540 --> 35:37.540
讲得够清楚了吧

35:38.540 --> 35:41.940
咱们这就是组件状态这一块的概念

35:42.140 --> 35:43.940
那么现在组件里面的数据就完了

35:43.940 --> 35:44.440
就没了

35:44.840 --> 35:46.340
就这么两个地方来自于数据

35:46.540 --> 35:48.340
当然以后遇到一些黑科技

35:48.540 --> 35:49.940
还可能来自于一些别的地方

35:49.940 --> 35:51.740
比方说上下文啊之类的东西

35:52.340 --> 35:53.940
目前不在我们讨论发认为智烈

35:53.940 --> 35:55.240
因为那个东西用的太少了

35:55.440 --> 35:57.640
一般来说我们组件里面的数据就两个

35:57.640 --> 35:59.140
一个是属性一个是状态

35:59.640 --> 36:01.240
我不知道的东西你传给我

36:01.440 --> 36:03.940
我自己知道的东西我要自己维护的东西

36:03.940 --> 36:05.040
就是我自己的状态

36:05.740 --> 36:08.540
好吧这是关于属性的

36:08.840 --> 36:09.940
就是组件的状态

36:10.140 --> 36:12.140
那么咱们下节课还是按照惯例

36:12.140 --> 36:13.440
来做一个小的demo

36:13.540 --> 36:14.540
大家跟着练一下

