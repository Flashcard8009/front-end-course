WEBVTT

00:01.010 --> 00:05.770
好 这几个课开始呢 咱们之前讲过那个日子中年宴的吧

00:05.770 --> 00:08.410
那个东西很宴的 就是用来调试的 没啥好说的

00:08.410 --> 00:12.210
这几个课开始呢 才是重点 这一张的重点

00:12.210 --> 00:17.010
为什么要单独分一张解出来 就是因为要处理副作用

00:17.010 --> 00:20.410
你看一下 我们以前有机会处理副作用吗

00:20.410 --> 00:22.010
来吧 我们来看一下吧 一个型

00:22.010 --> 00:26.610
你在这里边处理副作用 他返回了是一个平面对象 对吧

00:26.810 --> 00:29.210
甚至呢 我们之前写过的大设员嘛

00:29.210 --> 00:32.410
Critis Stone里面还进行了 特别特别进行的判断

00:32.410 --> 00:35.210
判断啥 判断的这个X型是不是一个平面对象

00:35.210 --> 00:39.010
如果不是的话 他就爆错了 对吧 你在这里面有机会吗

00:39.010 --> 00:42.410
好像没有什么机会吧 你在这里面有啥机会呢

00:42.410 --> 00:44.410
搞不定嘛 对不对 对不对

00:44.410 --> 00:46.810
你说在这里写个异部 写个异部

00:46.810 --> 00:50.010
比方说我们在这里写个set time out

00:50.010 --> 00:52.910
一秒钟之后 去做一些事情

00:52.910 --> 00:55.410
那么就模仿阿迦克斯嘛 模拟阿迦克斯

00:55.410 --> 01:00.010
他先要经过一段时间是异部的 有意义吗

01:00.010 --> 01:03.710
没有意义 因为他这边这个Critis Stone里面

01:03.710 --> 01:08.910
你看他就是这个Dispatch的时候 你把X型给他

01:08.910 --> 01:12.010
你调用X型创建函数 那个函数马上就返回结果 对吧

01:12.010 --> 01:14.610
必须要马上返回结果 马上返回结果

01:14.610 --> 01:17.010
他马上就作为X型就传递给他了

01:17.010 --> 01:19.210
那管理返回的是什么 如果你返回的是个Promise

01:19.210 --> 01:21.810
他马上就爆错了 他必须是一个平面对象

01:21.810 --> 01:25.110
总之他必须是个平面对象 这件事情就不好办

01:25.110 --> 01:28.010
你怎么弄呢 没法搞定副作用

01:28.010 --> 01:32.310
然后我们又看Reducer Reducer里面有搞吗 有搞头吗

01:32.310 --> 01:35.310
没搞头啊 这个东西 当时我特别特别强调了

01:35.310 --> 01:39.310
Reducer必须是一个纯函数 副作用想都不要想

01:39.310 --> 01:42.710
必须是一个纯函数 他要保持这个函数的纯净

01:42.710 --> 01:44.610
编于测试和调试

01:44.610 --> 01:46.710
那你这哪去弄了这个东西啊

01:46.710 --> 01:50.510
你发现没法了 没法了 搞不定副作用了

01:50.510 --> 01:53.910
怎么办了 这个时候出来的一个中间键

01:53.910 --> 01:56.610
除了好多中间键来解决这个问题

01:56.610 --> 01:59.310
那么这些中间键各有各的解决办法

01:59.310 --> 02:03.510
我们分别来说一下吧 关于副作用处理

02:03.510 --> 02:12.740
这一做笔记 就是利用中间键进行副作用处理

02:12.740 --> 02:14.340
副作用处理

02:14.340 --> 02:18.040
我们这一章节会学习三个中间键来处理这个副作用

02:18.040 --> 02:22.040
其中第一个 因为我也不知道你们以后到了什么公司

02:22.040 --> 02:24.740
它会用到什么样的中间键 我也不太清楚

02:24.740 --> 02:29.940
所以说我们这三个都讲 第一个叫做Redux Sunk

02:29.940 --> 02:32.140
它可以处理副作用 我们一会就可以

02:32.140 --> 02:33.640
这一刻我们就学习到这个

02:33.640 --> 02:35.840
咱们一会就可以看到它怎么来处理副作用的

02:35.840 --> 02:38.640
另外一个是Redux Promise

02:38.640 --> 02:41.340
Promise这个东西我们也会讲

02:41.340 --> 02:44.140
然后是Redux Saga

02:44.140 --> 02:46.740
一共就这么三个来处理副作用的

02:46.740 --> 02:48.740
这三个我们都会详细的讲解

02:48.840 --> 02:52.340
并且我还会分析它的原码

02:52.340 --> 02:56.340
所以说慢慢来因此这个时间会花费的比较多一点

02:56.340 --> 02:58.140
我会用整个章节来讲

02:58.140 --> 03:01.340
当然有些同学可能

03:01.340 --> 03:05.040
我这样说吧 有些东西可能底子基础稍微差一点

03:05.040 --> 03:06.940
对这个原码也没有什么兴趣

03:06.940 --> 03:09.040
那么你可以直接略过原码

03:09.040 --> 03:11.040
可以直接略过原码来进行观看

03:11.040 --> 03:13.440
也没有啥问题 其实也没有啥问题的

03:13.440 --> 03:17.140
因为我这个课程不仅是要面向那个初学者

03:17.240 --> 03:20.240
还要面向一些自身的开发人员

03:20.240 --> 03:22.640
就是已经工作了一些时间的同学

03:22.640 --> 03:24.940
他可能会回过头来再提高一下

03:24.940 --> 03:28.440
所以说我会讲到原码层面会比较深一点

03:28.440 --> 03:30.040
但是如果说一开始初学者的话

03:30.040 --> 03:32.440
对原码这一块理解起来比较困难

03:32.440 --> 03:33.540
初学起来比较困难的话

03:33.540 --> 03:35.540
那你可以直接略过 也不会影响什么

03:35.540 --> 03:36.640
但是你知道怎么用

03:36.640 --> 03:38.040
当然理解原码更好

03:38.040 --> 03:41.240
你就能够非常非常深入地理解它的原理

03:41.240 --> 03:44.640
那么对它的掌控力肯定是不可同日而遇的

03:44.640 --> 03:46.640
好 这些可能咱们先来学习上课

03:46.640 --> 03:49.440
这三个东西里面最难的就是沙咖

03:49.440 --> 03:50.640
沙咖

03:50.640 --> 03:51.440
这东西是最难的

03:51.440 --> 03:53.740
而且它的功能是最强大的

03:53.740 --> 03:56.140
所以说我们后边着重的时间

03:56.140 --> 03:58.540
可能花费比较多的在沙咖上面

03:58.540 --> 04:00.540
咱们这里可能先来学习上课

04:00.540 --> 04:02.140
上课怎么来用呢

04:02.140 --> 04:04.440
当然你还是一样的

04:04.440 --> 04:05.040
还是一样的

04:05.040 --> 04:06.140
我们这里可以讲怎么用

04:06.140 --> 04:07.940
下面可以讲它的原码

04:07.940 --> 04:09.740
上课你这里查费

04:09.740 --> 04:11.840
上课 你看它怎么用的

04:11.840 --> 04:14.540
最简单

04:14.540 --> 04:15.540
怎么用的呢

04:15.540 --> 04:16.840
它告诉你

04:16.840 --> 04:19.240
你这个上课如果是用ES6导入的话

04:19.240 --> 04:20.840
你就安装一个Redux上课

04:20.840 --> 04:22.340
把它导入进来就完事了

04:22.340 --> 04:24.240
它就是一个什么呢

04:24.240 --> 04:27.640
就是这么一个中间键

04:27.640 --> 04:30.140
看一下它这个应用 在这

04:30.140 --> 04:31.140
你看

04:31.140 --> 04:31.940
就导入进来

04:31.940 --> 04:34.240
把Redux上课导入进来

04:34.240 --> 04:36.040
就是跟那个Nougat是不是一样的

04:36.040 --> 04:37.340
对不对 是不是一样的

04:37.340 --> 04:39.040
导入进来就完事了

04:39.040 --> 04:40.840
那么咱们先不说它怎么

04:40.840 --> 04:42.040
怎么具体怎么去使用吧

04:42.040 --> 04:44.440
先把安装好了再说

04:44.440 --> 04:47.940
1280Dsunk

04:47.940 --> 04:52.040
Redux上课

04:52.040 --> 04:54.240
让它安装

04:54.240 --> 04:56.040
安装好了这个上课之后

04:56.040 --> 04:57.640
我们就可以使用这个中间键了

04:57.640 --> 04:59.440
它就是一个中间键

04:59.440 --> 05:02.240
对吧 就是这么一个中间键

05:02.240 --> 05:05.640
那么现在我们到

05:05.640 --> 05:09.040
到哪了 在store里面

05:09.040 --> 05:09.740
在这里边

05:09.740 --> 05:12.240
然后我们在index里边

05:12.240 --> 05:13.340
导入这么一个

05:13.340 --> 05:14.540
之前不是导入Nougat吗

05:14.540 --> 05:15.040
对不对

05:15.040 --> 05:17.340
我们把运行车要start

05:21.340 --> 05:22.540
不是导入了一个什么

05:22.540 --> 05:23.940
导入了一个就是Nougat吗

05:23.940 --> 05:24.440
对不对

05:24.440 --> 05:24.840
OK

05:24.840 --> 05:28.240
我们现在再导入

05:28.240 --> 05:30.840
再导入这个sunk

05:30.840 --> 05:32.140
导入这个sunk

05:32.140 --> 05:33.540
from

05:33.540 --> 05:34.140
来到哪呢

05:34.140 --> 05:34.740
Redux上课

05:34.740 --> 05:35.940
它用法非常简单

05:35.940 --> 05:37.140
它的功能也很简单

05:37.140 --> 05:38.040
很简单

05:38.040 --> 05:39.340
那么导入个中间键

05:39.340 --> 05:39.740
对吧

05:39.740 --> 05:41.240
那么用中间键的时候

05:41.240 --> 05:42.540
我们是不是在这里

05:42.540 --> 05:43.940
注意我上节课说的

05:43.940 --> 05:44.940
nougat放在后边

05:44.940 --> 05:45.940
我一会就会说

05:45.940 --> 05:47.740
nougat为什么要放在后边了

05:47.740 --> 05:50.340
那么这个sunk放前边

05:50.340 --> 05:51.340
sunk一般

05:51.340 --> 05:54.140
它官方文档里边好像没有名书

05:54.140 --> 05:55.740
但是我们一般

05:55.740 --> 05:57.740
如果使用这个sunk中间键的话

05:57.740 --> 05:58.940
都会放到第一个

05:58.940 --> 05:59.740
把它放到第一个

05:59.740 --> 06:02.140
作为第一个中间键

06:02.140 --> 06:03.840
那么nougat作为最后一个

06:03.840 --> 06:04.640
就创建完了

06:04.640 --> 06:04.940
对吧

06:04.940 --> 06:06.440
应用了两个中间键

06:06.440 --> 06:07.640
应用了两个中间键

06:07.640 --> 06:09.740
下面这个门我先把它取消掉

06:09.840 --> 06:11.440
下面这两个先把取消掉

06:13.140 --> 06:14.140
这种先取消掉

06:15.040 --> 06:15.640
好了

06:15.640 --> 06:17.340
那么这里我们创建了一个仓库

06:17.340 --> 06:17.640
对不对

06:17.640 --> 06:18.440
创建了一个仓库

06:18.440 --> 06:22.140
甚至我们把这个仓库导出

06:22.140 --> 06:23.840
这也是我们常用的一种做法

06:23.840 --> 06:25.540
在这个in这个文件里边

06:25.540 --> 06:28.240
我们通常就是导出一个仓库就完事了

06:28.240 --> 06:29.740
导出这么一个仓库就完事了

06:29.740 --> 06:30.340
这个仓库里边

06:30.340 --> 06:32.540
应用中间键全在这个文件里边去写

06:32.540 --> 06:34.840
写完了过后导出这个仓库就完事了

06:34.840 --> 06:36.340
咱们一般形成这么一种格式

06:39.940 --> 06:41.040
写成这么一种格式

06:41.040 --> 06:41.740
应用中间键

06:41.740 --> 06:43.340
以第1个上课第2个楼格

06:43.340 --> 06:43.540
好

06:43.540 --> 06:44.440
用了这个上课之后

06:44.440 --> 06:45.940
我们怎么来处理副作用呢

06:45.940 --> 06:47.040
我举个例子

06:47.040 --> 06:48.540
我再给大家举个例子

06:48.540 --> 06:51.240
就是在他的副作用是放到X里边了

06:52.940 --> 06:54.340
他是放到这的

06:54.340 --> 06:55.640
放到X里边

06:55.640 --> 06:57.840
X我们之前说是一个

06:58.940 --> 06:59.940
平面对象

06:59.940 --> 07:00.640
对吧

07:00.640 --> 07:02.140
X他必须是一个平面对象

07:02.140 --> 07:03.740
就是一个Type值有个Payload的

07:03.740 --> 07:04.040
对不对

07:04.040 --> 07:05.640
Payload没有强制要求

07:05.640 --> 07:07.340
Type值是有强制要求的

07:07.340 --> 07:09.440
就是一个非常平面的对象

07:09.540 --> 07:10.540
一个普通的对象

07:10.540 --> 07:11.640
你看这些X型

07:11.640 --> 07:12.240
对吧

07:12.240 --> 07:14.940
都是普通普通的一个对象

07:14.940 --> 07:16.340
就这么个意思

07:16.340 --> 07:19.140
但是有了Sunk这个中间键之后

07:19.140 --> 07:21.940
它可以让你X型变成一个函数

07:23.040 --> 07:25.240
你的X型不是一个对象吗

07:25.240 --> 07:27.040
你看一下X型创建函数

07:27.040 --> 07:28.440
不是都得到的是一个对象吗

07:28.440 --> 07:29.240
对不对

07:29.240 --> 07:30.040
对象吗

07:30.040 --> 07:30.840
那么现在

07:30.840 --> 07:34.240
这个Sunk有这个中间键之后

07:34.240 --> 07:35.840
它可以让你变成函数

07:35.840 --> 07:38.340
因此你就有机会在这个函数里面

07:38.340 --> 07:39.740
进行副作用处理

07:39.740 --> 07:42.040
它是用这么一种逻辑来实现的

07:42.040 --> 07:43.140
用这么一种识路

07:43.140 --> 07:44.940
比方我们之前的添加一个用户

07:44.940 --> 07:45.340
对吧

07:45.340 --> 07:45.740
放到这了

07:45.740 --> 07:46.140
对吧

07:46.140 --> 07:46.740
给我一个用户

07:46.740 --> 07:47.740
就添加进去

07:47.740 --> 07:49.040
添加到数组里面去

07:49.040 --> 07:50.240
然后删除一个用户

07:50.240 --> 07:50.540
OK

07:50.540 --> 07:51.940
我在这里

07:51.940 --> 07:53.740
就是给我个ID

07:53.740 --> 07:54.940
我就删除一个用户

07:54.940 --> 07:58.440
然后修改一个用户

07:58.440 --> 07:59.340
给我个ID

07:59.340 --> 07:59.640
OK

07:59.640 --> 08:00.540
我修改一个用户

08:00.540 --> 08:00.740
对吧

08:00.740 --> 08:04.040
这是我们之前做的这么三个X型创建函数

08:04.040 --> 08:05.240
那么这个每一个创建函数

08:05.240 --> 08:05.840
你看返回的

08:05.840 --> 08:07.540
是不是都是一个平面对象

08:07.540 --> 08:08.240
对不对

08:08.240 --> 08:10.640
返回的都是一个平面对象

08:10.640 --> 08:12.240
那么现在有了桑可之后

08:12.240 --> 08:15.040
现在我们有额外的处理方式了

08:15.040 --> 08:16.840
额外的处理方式

08:16.840 --> 08:18.040
那么现在比方说

08:18.040 --> 08:20.240
我再写个X型创建函数

08:20.240 --> 08:21.640
这个X型创建函数

08:21.640 --> 08:24.040
它返回的就不是一个普通的平面

08:24.040 --> 08:24.640
对象了

08:24.640 --> 08:25.840
返回的是一个函数

08:25.840 --> 08:26.440
也行

08:26.440 --> 08:27.440
因为有桑可的存在

08:27.440 --> 08:28.840
它就允许

08:28.840 --> 08:30.140
比方说你看怎么写

08:30.140 --> 08:32.640
比方说我们这里

08:32.640 --> 08:35.340
这样吧

08:35.340 --> 08:35.840
这样

08:35.840 --> 08:37.440
我们这里再写一个普通的X型

08:37.440 --> 08:38.640
创建函数

08:38.640 --> 08:41.440
就是set users

08:41.440 --> 08:44.640
seter users

08:44.640 --> 08:49.440
叫做create set user users

08:49.440 --> 08:52.840
X型

08:52.840 --> 08:53.840
你给我什么

08:53.840 --> 08:54.940
users

08:54.940 --> 08:56.640
你给我users

08:56.640 --> 08:57.940
那么我返回给你

08:57.940 --> 08:59.640
返回给你一个平面对象

08:59.640 --> 09:01.240
Type的属性值

09:01.240 --> 09:02.240
我这里先写

09:02.240 --> 09:04.240
写了我再解释

09:04.240 --> 09:06.340
export constant

09:06.340 --> 09:06.840
Type的

09:06.940 --> 09:11.240
Type的内型是叫做set users

09:11.240 --> 09:11.840
simple

09:11.840 --> 09:12.640
什么意思呢

09:12.640 --> 09:13.940
就是你给我一个数组

09:13.940 --> 09:15.440
你这里不是在管理数组吗

09:15.440 --> 09:16.840
管理用户数组对吧

09:16.840 --> 09:17.840
那么你给我一个数组

09:17.840 --> 09:20.340
我把它设置到用户数组里面去

09:20.340 --> 09:22.240
我把它设置到用户数组里面去

09:22.240 --> 09:25.140
那么就是set users

09:25.140 --> 09:26.740
我们来产生这么一个X型

09:26.740 --> 09:29.840
它可以把用户设置到数组里面去

09:29.840 --> 09:30.540
内型呢

09:30.540 --> 09:34.840
内型就是set users

09:34.840 --> 09:35.640
那么panel的呢

09:35.640 --> 09:36.640
你是不是自然而然

09:36.640 --> 09:38.540
要给我一个用户的数组

09:38.540 --> 09:39.340
对吧

09:39.340 --> 09:41.640
这里是用户数组

09:41.640 --> 09:43.440
这是也是一个普通的X型

09:43.440 --> 09:45.540
我们先写到这一会变于测试

09:45.540 --> 09:47.640
那么这里我们就是得到一个用户

09:47.640 --> 09:48.540
用户数组

09:48.540 --> 09:50.240
那么来设置到这个

09:50.240 --> 09:53.140
来就是产生这么一个X型

09:53.140 --> 09:54.040
那么有了对应的

09:54.040 --> 09:55.340
X型是不是应该有对应的

09:55.340 --> 09:56.540
有丢失了对吧

09:56.540 --> 09:57.240
有丢失了

09:57.240 --> 09:58.640
我们之前写了这么一个

09:58.640 --> 10:00.040
是这个丢失了对吧

10:00.040 --> 10:00.740
写了这么一个丢失了

10:00.740 --> 10:02.040
之前我们自己写了这么一个

10:02.040 --> 10:03.140
初始化的用户

10:03.140 --> 10:04.540
实际上通常情况下

10:04.540 --> 10:05.840
初始化是一个空数组

10:05.840 --> 10:06.340
对吧

10:06.340 --> 10:08.140
初始化是这么一个空数组

10:08.140 --> 10:09.640
于是你这里如果说

10:09.640 --> 10:12.640
你给了我一个X型

10:12.640 --> 10:13.940
这些基础里的灰

10:13.940 --> 10:14.640
不了搞半天

10:14.640 --> 10:16.840
你现在的基础都搞不清楚

10:16.840 --> 10:17.440
那么如果说

10:17.440 --> 10:18.340
你给了我这么一个X型

10:18.340 --> 10:21.340
叫set users这个X型

10:21.340 --> 10:22.840
X型的内型是这个内型

10:22.840 --> 10:24.440
那么我干嘛呢

10:24.440 --> 10:26.840
是不是我要反复的是一个什么

10:26.840 --> 10:28.040
反复的是你

10:28.040 --> 10:29.840
这个X型里边的新数组

10:29.840 --> 10:32.240
就是配X型里边的新数组

10:33.040 --> 10:33.440
对吧

10:34.640 --> 10:36.640
配了直接反复就完事了

10:36.640 --> 10:38.240
为什么我们来带你一下

10:38.240 --> 10:39.040
你给就是说

10:39.040 --> 10:41.040
我这里有个X型创建函数

10:41.040 --> 10:42.740
那么你给我一个数组

10:42.740 --> 10:44.940
我就会给你一个X型

10:44.940 --> 10:46.640
他主要是为了得到这个X型

10:46.640 --> 10:48.140
X型的内型是这个内型

10:48.140 --> 10:48.840
然后呢

10:48.840 --> 10:49.640
这个payload的呢

10:49.640 --> 10:51.240
就是一个用户数组

10:51.240 --> 10:52.840
那么这个X型的到到时候出发

10:52.840 --> 10:53.840
分发这个X型的时候

10:53.840 --> 10:54.840
会分发给谁

10:54.840 --> 10:56.240
是分发给reducer

10:56.240 --> 10:56.540
对吧

10:56.540 --> 10:57.640
分发给reducer

10:57.640 --> 10:58.440
reducer里边

10:58.440 --> 10:59.140
如果判断

10:59.140 --> 11:00.640
如果说你的内型是这个内型

11:00.640 --> 11:01.240
ok

11:01.240 --> 11:04.540
那么我就用你给我的数组

11:04.540 --> 11:05.540
来作为状态

11:05.540 --> 11:06.640
反悔

11:06.640 --> 11:08.040
来作为状态反悔

11:08.040 --> 11:08.840
就这么个意思

11:08.840 --> 11:09.640
就这么个意思

11:11.040 --> 11:11.440
好了

11:11.440 --> 11:12.440
以后了这么一个东西过后

11:12.440 --> 11:13.640
我们先不管什么上课

11:13.640 --> 11:15.140
不上课

11:15.140 --> 11:15.540
上课了

11:15.540 --> 11:16.440
我们先不管他

11:16.440 --> 11:16.940
不管他

11:16.940 --> 11:17.540
哪怕没有上课

11:17.540 --> 11:18.440
我们现在也一样

11:18.440 --> 11:19.840
比方说现在没有上课

11:19.840 --> 11:20.240
没有上课

11:20.240 --> 11:20.840
我们来现在

11:20.840 --> 11:22.040
来测试一下

11:22.040 --> 11:23.240
来测试一下

11:23.240 --> 11:23.740
测试一下

11:23.740 --> 11:25.440
看一下能不能就是来得到

11:25.440 --> 11:27.640
就是那个

11:27.640 --> 11:29.140
来设置用户数组

11:29.140 --> 11:30.340
TESA点解释

11:30.440 --> 11:33.950
咱们来测试一下

11:33.950 --> 11:35.550
我们在这里

11:35.550 --> 11:37.350
写上这么一个代码

11:37.350 --> 11:39.050
首先导入

11:39.050 --> 11:40.550
store

11:40.550 --> 11:41.150
来自于哪呢

11:41.150 --> 11:43.150
来自于就是index

11:43.150 --> 11:44.150
导入一个store

11:44.150 --> 11:46.550
来测试一下

11:46.550 --> 11:47.850
为了方便测试的话

11:47.850 --> 11:50.150
我在整个项目的index的启动文件里边

11:50.150 --> 11:52.250
导入这个store.test

11:52.250 --> 11:52.950
导入个test

11:52.950 --> 11:54.550
来进行测试

11:54.550 --> 11:55.650
那么这个仓库里边

11:55.650 --> 11:56.750
我们去分发

11:56.750 --> 11:57.650
dispatch

11:57.650 --> 11:58.850
分发什么

11:58.850 --> 11:59.550
分发一个action

11:59.550 --> 12:00.050
这个action

12:00.050 --> 12:02.950
我们可以使用action创建还是拿到

12:02.950 --> 12:06.950
使用action创建还是拿到一个action

12:06.950 --> 12:07.950
action

12:07.950 --> 12:08.750
useraction

12:08.750 --> 12:10.650
user is action

12:10.650 --> 12:12.450
create

12:12.450 --> 12:14.150
create is set

12:14.150 --> 12:15.650
user is action

12:15.650 --> 12:17.550
那么我们这里调用这个函数

12:17.550 --> 12:19.150
调用这个函数来得到一个action

12:19.150 --> 12:21.350
我们再分开写吧

12:21.350 --> 12:25.550
就是user is action

12:25.550 --> 12:26.350
就是这里

12:26.350 --> 12:27.650
我们调用这个函数

12:27.650 --> 12:28.350
create is set

12:28.350 --> 12:29.550
user is action

12:29.550 --> 12:31.550
它需要传递一个用户的数组

12:31.550 --> 12:31.850
对吧

12:31.850 --> 12:33.150
那么我们传递一个用户数组

12:33.150 --> 12:34.150
随便传递一个

12:34.150 --> 12:35.550
我们为了测试的话

12:35.550 --> 12:37.150
给它一个

12:37.150 --> 12:38.850
导入一个uuid

12:38.850 --> 12:40.450
在这里测试

12:40.450 --> 12:41.250
uuid

12:41.250 --> 12:42.250
那么这里呢

12:42.250 --> 12:43.350
id为什么呢

12:43.350 --> 12:46.650
uuid

12:46.650 --> 12:48.150
这是一个用户数

12:48.150 --> 12:49.350
这是个数组

12:49.350 --> 12:51.050
数组里面每一个是个用户

12:51.050 --> 12:55.250
id uuid

12:55.250 --> 12:57.050
然后locking id

12:57.050 --> 12:58.650
登录账号等于比较说

12:59.650 --> 13:00.750
密码

13:00.750 --> 13:02.750
locking password

13:02.750 --> 13:04.250
密码123123

13:04.250 --> 13:04.850
比方说

13:04.850 --> 13:05.850
举个例子

13:05.850 --> 13:07.050
然后下面再来一个

13:07.050 --> 13:08.650
二的命二

13:08.650 --> 13:10.250
456456

13:10.250 --> 13:10.650
好

13:10.650 --> 13:11.650
于是我们写了

13:11.650 --> 13:13.250
冲建了这么一个action

13:13.250 --> 13:13.650
对吧

13:13.650 --> 13:15.050
使用action创建函数

13:15.050 --> 13:15.750
始终记住

13:15.750 --> 13:16.650
action创建函数

13:16.650 --> 13:18.550
它只是来得到一个action而已

13:18.550 --> 13:19.850
其他的没有什么特别的

13:19.850 --> 13:21.750
然后咱们把这个action放到这里

13:21.750 --> 13:23.650
触发一下这个action

13:23.650 --> 13:24.250
设置用户

13:24.250 --> 13:24.650
保存

13:24.650 --> 13:26.250
你看一下

13:26.250 --> 13:26.850
你看一下

13:26.850 --> 13:28.850
这里你右键检查

13:28.850 --> 13:29.850
右键检查

13:29.850 --> 13:31.050
你看是不是触发了一个action

13:31.050 --> 13:31.850
对不对

13:31.850 --> 13:32.850
日子里面记录了

13:32.850 --> 13:33.650
之前的状态

13:33.650 --> 13:35.250
你看U字是空速组

13:35.250 --> 13:36.350
然后之后的状态

13:36.350 --> 13:37.550
U字是不是有两个了

13:37.550 --> 13:38.150
对吧

13:38.150 --> 13:39.750
与丢失里面就把它

13:39.750 --> 13:41.150
把你拍到的传进去的数据

13:41.150 --> 13:43.150
直接作为状态返回了

13:43.150 --> 13:43.750
看到没

13:43.750 --> 13:44.850
这个东西很简单

13:44.850 --> 13:47.450
这东西你至少得理解

13:47.450 --> 13:49.050
但是现在没有副作用

13:49.050 --> 13:52.050
因为肯定是我们要得到用户的时候

13:52.050 --> 13:53.350
肯定不是用这种方式的

13:53.350 --> 13:54.250
肯定是用什么

13:54.250 --> 13:55.350
阿迦克10请求

13:55.350 --> 13:55.850
对吧

13:55.850 --> 13:57.250
来自于阿迦克斯请求

13:57.250 --> 13:58.850
去请求一个用户数据

13:58.850 --> 14:00.650
来拿到的用户

14:00.650 --> 14:01.550
那么如果说

14:01.550 --> 14:02.950
如果说我们没有什么

14:02.950 --> 14:04.250
上可的中间键的话

14:04.250 --> 14:05.450
我们怎么办

14:05.450 --> 14:06.150
绿大克斯里面

14:06.150 --> 14:07.050
他不能写副作用

14:07.050 --> 14:07.850
没有一个位置

14:07.850 --> 14:09.250
可以写副作用的东西

14:09.250 --> 14:10.250
那么我们怎么办

14:10.250 --> 14:11.150
我们只能在这里

14:11.150 --> 14:12.650
来进行阿迦克斯请求

14:12.650 --> 14:14.250
只能在这里去完成

14:14.250 --> 14:14.350
好

14:14.350 --> 14:15.050
那怎么做呢

14:15.050 --> 14:16.050
我们可以用这种方式

14:16.050 --> 14:17.050
比方说我们要进行一下

14:17.050 --> 14:18.550
阿迦克斯请求

14:18.550 --> 14:19.250
我们在这里写

14:19.250 --> 14:19.950
就在外面写

14:19.950 --> 14:21.650
跟绿大克斯无关

14:21.650 --> 14:22.350
我们在这里

14:22.350 --> 14:24.250
去写上这么一个就是

14:24.250 --> 14:25.450
导入我们之前写过那个

14:25.450 --> 14:26.450
services对吧

14:28.250 --> 14:32.050
from services student

14:32.050 --> 14:32.650
这里呢

14:32.650 --> 14:33.250
肯定有

14:33.250 --> 14:34.450
我记得有一个

14:34.450 --> 14:36.750
get all students

14:36.750 --> 14:37.850
有这么一个函数

14:37.850 --> 14:38.350
OK

14:38.350 --> 14:39.050
那么我们就可以

14:39.050 --> 14:40.050
调用这个函数

14:40.050 --> 14:41.250
get all students

14:41.250 --> 14:42.150
调用这么一个函数

14:42.150 --> 14:42.950
获取所有学生

14:42.950 --> 14:44.650
它是个异步的

14:44.650 --> 14:46.250
调用这个函数的时候

14:46.250 --> 14:47.650
我们再用z

14:47.650 --> 14:49.650
z

14:49.650 --> 14:51.650
然后得到了

14:51.650 --> 14:52.950
福奇返回结果

14:52.950 --> 14:53.650
福奇返回结果

14:53.650 --> 14:56.150
我们来打印一下

14:56.150 --> 14:59.750
打印一下福奇返回结果

14:59.750 --> 15:01.650
这个东西不要了

15:01.650 --> 15:03.050
这个东西不要了

15:03.050 --> 15:04.050
保存看一下

15:04.050 --> 15:05.550
打印福奇返回结果

15:05.550 --> 15:06.350
说谁拿到了

15:06.350 --> 15:06.650
对吧

15:06.650 --> 15:07.850
这就是个数组

15:07.850 --> 15:08.250
对不对

15:08.250 --> 15:09.850
这就是一个数组

15:09.850 --> 15:11.850
拿到所有的学生之后

15:11.850 --> 15:12.650
我们在这里

15:12.650 --> 15:14.650
通过create sets

15:14.650 --> 15:16.450
来创建一个型

15:16.450 --> 15:17.850
那么我们把福奇返回结果

15:17.850 --> 15:19.050
就是这个数组给它

15:19.050 --> 15:20.450
那么是不是得到一个一个型

15:20.450 --> 15:21.350
对不对

15:21.350 --> 15:22.250
得到一个一个型

15:22.250 --> 15:23.650
然后大家这里

15:23.650 --> 15:25.850
再去触发这个一个型

15:25.850 --> 15:27.450
是这个逻辑吧

15:27.450 --> 15:28.650
保存

15:28.650 --> 15:29.750
你看一下

15:29.750 --> 15:30.850
那么现在的

15:30.850 --> 15:32.250
设置完了学生就有89个了

15:32.250 --> 15:32.950
对吧

15:32.950 --> 15:34.450
那以前的副作用没办法

15:34.450 --> 15:35.650
你没有中间键的话

15:35.650 --> 15:36.850
你没有那个伤口中间键的话

15:36.850 --> 15:37.750
你只能这么处理

15:37.750 --> 15:38.650
你怎么办呢

15:38.650 --> 15:39.850
你又没法再认为

15:39.850 --> 15:41.350
大哥是你不要去写副作用

15:41.350 --> 15:42.850
你只能把副作用写到外边

15:42.850 --> 15:43.250
对吧

15:43.250 --> 15:43.950
写到外边

15:43.950 --> 15:44.950
那么这样一来的话

15:44.950 --> 15:46.050
确实有点麻烦

15:46.050 --> 15:48.250
因为很多地方有相同的副作用

15:48.250 --> 15:49.150
处理逻辑

15:49.150 --> 15:51.150
那么这样子

15:51.250 --> 15:53.650
既然大哥是吃一种数据留处理方案

15:53.650 --> 15:54.950
那么这个很多副作用的

15:54.950 --> 15:56.750
也是跟数据密切相关的

15:56.750 --> 15:57.650
然后这样子写了

15:57.650 --> 15:59.350
你会导致到导致后面的还是很

15:59.350 --> 16:00.850
有很多很多的麻烦

16:00.850 --> 16:01.950
很多很多的麻烦

16:02.750 --> 16:03.550
所以这种写法呢

16:03.550 --> 16:04.750
不是说不可以

16:04.750 --> 16:06.050
只是说比较麻烦一点

16:06.050 --> 16:06.550
另外呢

16:06.550 --> 16:09.350
我们这里再再再把这个场景丰富一下吧

16:09.350 --> 16:10.650
再个场景丰富一下

16:10.650 --> 16:11.750
因为他这个东西请求

16:11.750 --> 16:13.550
是不是需要一段过一段时间

16:13.550 --> 16:13.950
对吧

16:13.950 --> 16:14.550
需要一段时间

16:14.550 --> 16:15.950
比方说有三秒钟

16:15.950 --> 16:17.650
那这三秒钟三秒钟内

16:17.650 --> 16:19.350
界面上是不是应该有一个

16:19.350 --> 16:20.650
正在家载中的效果

16:20.650 --> 16:22.350
尽管我们现在不涉及界面

16:22.350 --> 16:22.750
对吧

16:22.750 --> 16:24.450
但是数据里边是不是应该记录

16:24.450 --> 16:26.250
我们现在正在获取数据

16:26.250 --> 16:26.550
对吧

16:26.550 --> 16:28.250
是不是应该做这么一个记录

16:28.250 --> 16:28.850
啊

16:28.850 --> 16:29.850
应该做这么一个记录

16:29.850 --> 16:31.150
正在获取数据

16:31.150 --> 16:31.650
对吧

16:31.650 --> 16:33.550
我们可能会这样子去理解啊

16:33.550 --> 16:34.550
就做这么一个记录

16:34.550 --> 16:37.050
来表示正在获取数据

16:37.050 --> 16:38.850
正在获取数据

16:38.850 --> 16:39.450
所以说呢

16:39.450 --> 16:40.750
我们现在呢

16:41.950 --> 16:42.550
现在呢

16:42.550 --> 16:44.450
我们还需要一个东西来表示

16:44.450 --> 16:45.850
当前数据的状态

16:45.850 --> 16:47.050
是不是已经获取到了

16:47.050 --> 16:48.250
还是说

16:48.250 --> 16:49.850
正在获取中啊

16:49.950 --> 16:50.950
那么我们可以在这里

16:50.950 --> 16:53.250
I個型里面再多加一个

16:53.250 --> 16:54.550
再多加一下I个型

16:54.550 --> 16:55.950
比方说我们这里来加一个

16:57.150 --> 16:57.950
加一个就是

16:59.950 --> 17:01.450
set loading

17:03.460 --> 17:06.360
表示是设置加载状态的

17:06.360 --> 17:07.260
I个型的一型

17:09.660 --> 17:12.860
这是设置加载状态

17:13.660 --> 17:14.360
设置加载状态

17:14.360 --> 17:15.560
那么同样的方式

17:15.560 --> 17:16.560
来导出一个

17:17.460 --> 17:19.260
create set loading I个型

17:21.260 --> 17:21.660
啊

17:25.260 --> 17:25.960
导出

17:27.160 --> 17:27.760
就是

17:30.460 --> 17:34.160
返回一个设置加载状态的

17:34.560 --> 17:35.060
I个型

17:35.760 --> 17:36.560
加载状态

17:36.560 --> 17:37.560
那么这里的type呢

17:37.560 --> 17:38.860
就是set什么

17:38.960 --> 17:39.560
loading

17:40.360 --> 17:40.760
好

17:40.760 --> 17:41.660
pulled是什么呢

17:41.660 --> 17:42.760
pulled就是一个布尔

17:43.260 --> 17:44.060
e is loading

17:44.060 --> 17:45.260
表示是否正在加载

17:45.260 --> 17:46.460
是否正在加载

17:46.460 --> 17:47.360
你给我一个值

17:47.360 --> 17:48.660
那么我就把它作为pulled的

17:48.660 --> 17:49.260
放进去

17:50.260 --> 17:54.060
这是表示是否正在加载

17:54.060 --> 17:54.560
注意啊

17:54.560 --> 17:55.260
一定要知道

17:55.260 --> 17:56.060
I个型创建还是说

17:56.060 --> 17:57.260
它只是给你返回一个I个型

17:57.260 --> 17:58.660
它不做任何数据处理

17:58.660 --> 18:00.960
然后我们在reducer里面去做数据处理

18:00.960 --> 18:02.060
reducer里面

18:02.060 --> 18:02.360
现在呢

18:02.360 --> 18:02.860
我们这里呢

18:02.860 --> 18:04.060
就不要不要用什么

18:04.060 --> 18:05.260
不要用这个玩意了

18:05.260 --> 18:06.460
不要用这个就是

18:06.460 --> 18:07.660
输阻了

18:07.660 --> 18:08.660
不要用输阻了

18:08.660 --> 18:09.560
而是用一个对象

18:11.060 --> 18:11.860
用个对象

18:11.860 --> 18:13.160
这个对象里面有两个属性

18:13.160 --> 18:13.960
一个是e is loading

18:13.960 --> 18:15.060
是否正在加载

18:15.060 --> 18:16.160
默认为forced

18:16.160 --> 18:17.560
默认为forced

18:17.860 --> 18:18.560
然后呢

18:18.560 --> 18:19.760
有这么一个属性

18:19.760 --> 18:22.360
叫做data

18:22.360 --> 18:24.060
data是一个数据

18:24.060 --> 18:26.360
那么这里存放的是学生数据

18:26.360 --> 18:27.460
就是应该是

18:27.460 --> 18:28.360
就是学生数据

18:28.360 --> 18:28.960
用户数据

18:28.960 --> 18:30.560
随便数据

18:30.560 --> 18:31.360
那么这个是

18:31.360 --> 18:33.760
是否正在加载

18:33.760 --> 18:34.760
那么这个也是数据

18:34.760 --> 18:35.260
对吧

18:35.260 --> 18:35.760
到时候呢

18:35.760 --> 18:37.060
我们跟界面联合起来

18:37.060 --> 18:37.660
那么界面上

18:37.660 --> 18:38.560
到底要不要显示

18:38.560 --> 18:40.160
那几个字正在加载中

18:40.160 --> 18:42.560
那么就全凭这个数据

18:42.560 --> 18:44.460
全部依托于这个数据

18:44.460 --> 18:44.660
对不对

18:44.660 --> 18:46.160
我们用数据记录一下

18:46.160 --> 18:48.260
用数据记录一下

18:48.260 --> 18:48.760
那么这里呢

18:48.760 --> 18:49.960
我们就写了这么两个数据

18:49.960 --> 18:50.860
对吧

18:50.860 --> 18:52.260
一个是e is loading

18:52.260 --> 18:53.160
一个data是

18:53.160 --> 18:53.960
那么这些数据

18:53.960 --> 18:56.260
到时候都会影响到界面

18:56.260 --> 18:57.660
因为界面上到底要不要显示

18:57.660 --> 18:58.060
那个东西

18:58.060 --> 19:00.060
你是不是得通过数据来判断

19:00.060 --> 19:01.360
你怎么知道它有没有加载的

19:01.360 --> 19:03.660
我们总的一个数据来记录

19:03.660 --> 19:04.260
我们这里呢

19:04.260 --> 19:06.560
因为当时它本身就是来处理数据的

19:06.560 --> 19:08.060
数据的放这

19:08.060 --> 19:09.060
那么如果说

19:09.060 --> 19:10.660
你给我传递的

19:10.660 --> 19:11.860
那我们一个按载

19:11.860 --> 19:13.660
稍微稍微改动一下

19:13.660 --> 19:14.860
如果说你添加一个用户

19:14.860 --> 19:16.160
是往这个数组里边添加

19:16.160 --> 19:16.460
对吧

19:16.460 --> 19:17.860
是往这个数组里边添加

19:17.860 --> 19:19.460
所以我返回的是什么了

19:19.460 --> 19:20.260
反回的是这样子

19:20.260 --> 19:21.460
这样子返回的

19:21.460 --> 19:23.360
我把原来的对象

19:23.360 --> 19:25.260
原来的状态展开

19:25.260 --> 19:26.860
原来的状态就是这种格式展开

19:26.860 --> 19:27.460
对吧

19:27.460 --> 19:29.360
然后重新更改它的什么属性

19:29.360 --> 19:30.860
更改data是属性

19:30.860 --> 19:33.260
data是属性的

19:33.260 --> 19:36.860
就是把原来的State里边的data是

19:36.860 --> 19:37.760
把它展开

19:37.760 --> 19:38.160
对吧

19:38.160 --> 19:39.160
把这个数据里边展开

19:39.160 --> 19:40.460
然后给它加影响

19:40.460 --> 19:41.260
对不对

19:41.260 --> 19:43.560
咱们这里稍微处理一下

19:43.560 --> 19:46.160
然后这里地内持有的三处用户也是一样

19:46.160 --> 19:47.460
三处用户也是一样

19:47.460 --> 19:51.060
我们这里首先把之前的状态拿过来

19:51.060 --> 19:54.460
然后data是得到一个新的数组

19:54.460 --> 19:56.760
新的数组来自于State点data是

19:56.760 --> 19:58.760
把之前的数组过滤一下

19:58.760 --> 20:00.660
到一个新的数组复制给它

20:00.660 --> 20:01.360
对吧

20:01.360 --> 20:04.160
然后修改用户

20:04.160 --> 20:06.460
我们也是用这种方式来做

20:06.460 --> 20:10.560
用这种方式

20:10.560 --> 20:13.060
然后这里使用

20:13.060 --> 20:15.160
把这句话写过来

20:15.160 --> 20:17.560
就是我们之前的处理是针对整个状态的

20:17.560 --> 20:20.360
那么现在只是针对状态里边的一个属性

20:20.360 --> 20:21.160
data是对吧

20:21.160 --> 20:22.660
稍微处理一下

20:22.660 --> 20:24.160
那么这里set users

20:24.160 --> 20:25.260
设置那个数组

20:25.260 --> 20:26.360
只是设置数组对吧

20:26.360 --> 20:29.160
所以说我们这里把原来的状态展开

20:29.160 --> 20:30.960
然后呢

20:30.960 --> 20:32.160
payload

20:32.160 --> 20:34.960
data是把它变成payload的

20:34.960 --> 20:36.260
把它变成payload的

20:36.260 --> 20:37.560
这是设置用户

20:37.560 --> 20:38.560
好那么最

20:38.560 --> 20:40.760
然后再加一个case

20:40.760 --> 20:41.960
users action

20:41.960 --> 20:44.460
如果说你的action类型是什么呢

20:44.560 --> 20:45.560
set loading

20:45.560 --> 20:47.960
设置什么加载状态

20:47.960 --> 20:50.060
那么我这个时候呢给力的是什么呢

20:50.060 --> 20:51.460
也是把set展开

20:51.460 --> 20:53.660
然后现在我们要重新设置什么

20:53.660 --> 20:54.960
哎我们要从

20:54.960 --> 20:56.460
哎为什么要写这个race啊

20:56.460 --> 20:57.360
我的天

20:57.360 --> 20:58.660
为什么要写race

20:58.660 --> 21:01.230
封个吧

21:01.230 --> 21:01.830
啊

21:03.630 --> 21:04.230
好

21:04.230 --> 21:04.730
那么现在呢

21:04.730 --> 21:07.230
我们要是不是要重新设置一直loading这个属性

21:07.230 --> 21:07.630
对吧

21:07.630 --> 21:08.430
设置这个属性

21:08.430 --> 21:09.330
设置这个属性为什么呢

21:09.330 --> 21:10.130
为payload的

21:10.130 --> 21:11.430
因为payload里面还就记录了

21:11.430 --> 21:13.230
你是否正在加载

21:13.230 --> 21:13.630
对吧

21:13.630 --> 21:14.430
好保存一下啊

21:14.430 --> 21:15.730
咱们看一下

21:15.930 --> 21:17.530
那么之前呢是不是仍然没有变化

21:17.530 --> 21:18.730
那么现在那个优热时呢

21:18.730 --> 21:19.930
他就变成个对象了啊

21:19.930 --> 21:20.930
一直loading为forrest

21:20.930 --> 21:22.630
data是一个空数组一开始

21:22.630 --> 21:23.930
然后呢设置了用户之后呢

21:23.930 --> 21:24.630
你看一下

21:24.630 --> 21:25.530
一直loading为forrest

21:25.530 --> 21:27.930
然后那个data是有89个数据

21:27.930 --> 21:28.930
对吧

21:28.930 --> 21:30.230
但是他现在多了一个属性了

21:30.230 --> 21:31.090
等多了一个一直

21:31.090 --> 21:31.730
一直loading的

21:31.730 --> 21:33.830
那么我们是不是可以触发相应的action

21:33.830 --> 21:34.430
来设置

21:34.430 --> 21:36.830
比方说我们在加载之前啊

21:36.830 --> 21:37.730
在获取学生之前

21:37.730 --> 21:39.330
因为获取学生需要一段时间嘛

21:39.330 --> 21:39.830
对不对

21:39.830 --> 21:40.930
需要一段时间

21:40.930 --> 21:42.530
获取学生之前呢

21:42.530 --> 21:44.630
我们先去触发一个action

21:44.830 --> 21:46.430
先去触发一个action

21:46.430 --> 21:50.130
就是create set loadenaction

21:50.130 --> 21:51.430
先去触发这么一个action

21:51.430 --> 21:51.730
好

21:51.730 --> 21:54.430
咱们呢用store.dispatch

21:54.430 --> 21:56.730
触发这个action

21:56.730 --> 21:58.830
比方说先把它设为去

21:58.830 --> 22:00.130
表示正在加载

22:00.130 --> 22:02.730
先把这个东西设为去

22:02.730 --> 22:04.230
正在加载

22:04.230 --> 22:05.330
正加载完了过后

22:05.330 --> 22:07.130
我们来设置用户的action

22:07.130 --> 22:08.330
设置用户的action

22:08.330 --> 22:10.930
就是来设置用户的数组

22:10.930 --> 22:11.130
好

22:11.130 --> 22:12.030
设置的数组过后呢

22:12.130 --> 22:15.330
我们再来触发这个action

22:15.330 --> 22:15.630
然后呢

22:15.630 --> 22:17.130
把加载状态设为force

22:19.730 --> 22:22.930
设置为没有正在加载

22:24.530 --> 22:25.530
理下这个逻辑

22:25.530 --> 22:26.730
理下这个逻辑

22:26.730 --> 22:27.530
首先说

22:27.530 --> 22:29.730
为什么需要這個isloading这个属性

22:29.730 --> 22:31.930
现在我们都还没有讲上课

22:31.930 --> 22:34.230
因为我想把它用到真实场景里边

22:34.230 --> 22:35.830
大家好理解一点

22:35.830 --> 22:37.030
那么这里呢

22:37.030 --> 22:38.530
isloading有这么一个属性

22:38.530 --> 22:40.430
它的属性作用就是记录

22:40.430 --> 22:42.030
当前是不是正在加载中

22:42.030 --> 22:44.630
正在加载中做这么一个记录

22:44.630 --> 22:46.530
因为这些东西都是数据

22:46.530 --> 22:47.730
你不要看什么界面上

22:47.730 --> 22:50.030
界面上可以用一个图片转圈圈来显示

22:50.030 --> 22:51.630
也可以用一行文字来显示

22:51.630 --> 22:53.130
可以用任何东西来显示

22:53.130 --> 22:53.930
界面怎么显示

22:53.930 --> 22:55.030
那是reaction的事情

22:55.030 --> 22:56.130
那是组件的事情

22:56.130 --> 22:57.330
跟我们目前没关

22:57.330 --> 22:57.630
但是呢

22:57.630 --> 22:59.130
我们数据得有

22:59.130 --> 23:00.330
你没有这个数据的话

23:00.330 --> 23:01.130
到时候见面

23:01.130 --> 23:02.430
那要不要显示正在加载了

23:02.430 --> 23:03.230
他也不知道

23:03.230 --> 23:04.830
他是要根据数据来的

23:04.830 --> 23:06.730
就是我们的前有数据

23:06.730 --> 23:08.130
那么有了这个数据过后

23:08.130 --> 23:09.730
我们就可以通过action

23:09.730 --> 23:11.930
但是数据的变化是通过action来触发的

23:11.930 --> 23:13.430
所以说我们需要相应的action

23:13.430 --> 23:14.830
来触发改变这个数据

23:14.830 --> 23:16.130
我们先分发一个action

23:16.130 --> 23:17.630
把它设为true

23:17.630 --> 23:18.930
然后再去得到

23:18.930 --> 23:20.330
去管理都经过的话的时间

23:20.330 --> 23:21.330
去得到这个东西

23:21.330 --> 23:22.330
得到这个东西过后

23:22.330 --> 23:23.930
我们再把东西放进去

23:23.930 --> 23:25.930
然后再把这个状态设为force

23:25.930 --> 23:26.930
那么现在这样一来

23:26.930 --> 23:28.330
我们获取学生你看一下

23:28.330 --> 23:29.730
是不是经过了三个action

23:29.730 --> 23:30.830
首先我们一开始

23:30.830 --> 23:34.230
你看UZ数据是空的

23:34.230 --> 23:35.530
isno定为force

23:35.530 --> 23:35.930
对吧

23:35.930 --> 23:37.130
看得非常非常清楚

23:37.130 --> 23:41.830
然后第二次是把这个楼顶设为true

23:41.830 --> 23:43.130
第二次

23:46.130 --> 23:48.330
第一次是把楼顶设为true

23:48.330 --> 23:50.430
楼顶设为true表示这么的夹展

23:50.430 --> 23:51.530
然后过了一会

23:51.530 --> 23:53.530
过了一会你看过了多少时间

23:53.530 --> 23:54.630
速度太快了

23:54.630 --> 23:55.830
那个速度太快了

23:55.830 --> 23:57.530
过了500毫秒左右

23:57.530 --> 23:58.430
500毫秒左右

23:58.430 --> 23:59.330
但是你可以看清楚

23:59.330 --> 24:00.930
这里肯定是经过了一段时间

24:00.930 --> 24:01.630
对吧

24:01.630 --> 24:03.630
我们这里

24:03.630 --> 24:04.330
这样子

24:04.330 --> 24:06.130
我们这里用个set timeout

24:06.130 --> 24:07.130
来模拟一下

24:07.130 --> 24:09.330
模拟一下3秒钟

24:09.330 --> 24:10.230
3秒钟过后

24:10.230 --> 24:12.330
我们再做这件事情

24:12.330 --> 24:13.930
老存

24:13.930 --> 24:15.530
首先把楼顶设为true

24:15.530 --> 24:17.030
3秒钟过后

24:17.030 --> 24:18.830
然后再去触发这个action

24:18.830 --> 24:20.230
对吧

24:20.230 --> 24:21.130
是这个意思吧

24:21.130 --> 24:23.130
然后把数组触发进去

24:23.130 --> 24:26.630
然后再把这个isno定设为force

24:26.630 --> 24:28.630
于是经过了这么三个action

24:28.630 --> 24:30.130
那么就说触发的数据

24:30.130 --> 24:33.430
导致的数据变化了三次

24:33.430 --> 24:33.930
好

24:34.030 --> 24:36.430
那么这是现在的写法

24:36.430 --> 24:37.130
没办法

24:37.130 --> 24:38.630
为什么没办法

24:38.630 --> 24:39.430
因为副作用

24:39.430 --> 24:42.130
他那个redax没有地方加进去

24:42.130 --> 24:43.530
所以说我们只能写到外面

24:43.530 --> 24:44.930
但是写到外面很麻烦

24:44.930 --> 24:47.930
我们希望了这个跟数据密切相关的东西

24:47.930 --> 24:50.830
也能够在redax里面就处理掉了

24:50.830 --> 24:51.830
反正跟数据相关的东西

24:51.830 --> 24:53.630
我们都可以在redax里面处理

24:53.630 --> 24:55.330
那么于是多了一些中间键

24:55.330 --> 24:57.430
其中我们这一课学习的就是

24:57.430 --> 25:00.030
sunk这个中间键

25:00.030 --> 25:01.330
就这个中间键

25:01.330 --> 25:03.430
那么这个中间键加进去

25:03.530 --> 25:05.130
加个中间键之后

25:05.130 --> 25:07.530
看一下怎么来用这个中间键

25:07.530 --> 25:08.230
这个中间键

25:08.230 --> 25:10.830
它允许里给的action

25:10.830 --> 25:12.830
不再是一个平面对象

25:12.830 --> 25:14.430
而是一个函数

25:14.430 --> 25:15.230
也说我们这里

25:15.230 --> 25:17.030
一看之前这个action创建函数

25:17.030 --> 25:18.430
它返回的都是一个平面对象

25:18.430 --> 25:18.830
对吧

25:18.830 --> 25:20.130
返回的都是一个action

25:20.130 --> 25:21.530
那么有了这个sunk之后

25:21.530 --> 25:24.030
它允许里

25:24.030 --> 25:24.930
返回一个什么呢

25:24.930 --> 25:26.830
返回一个函数

25:26.830 --> 25:30.030
返回这么一个函数

25:30.030 --> 25:31.130
那么比方说

25:31.130 --> 25:32.230
我们在这里

25:32.230 --> 25:35.230
就导出这么一个函数

25:35.230 --> 25:36.530
来作为action

25:36.530 --> 25:38.130
也不用函数创建函数了

25:38.130 --> 25:39.630
也不用什么函数创建函数了

25:39.630 --> 25:41.230
但也可以使用函数创建函数

25:41.230 --> 25:42.330
这个都无所谓的

25:42.330 --> 25:42.430
好

25:42.430 --> 25:43.530
咱们比方说

25:43.530 --> 25:48.030
我们写这么一个函数

25:48.030 --> 25:49.130
要取的名字叫做

25:52.130 --> 25:56.830
fetch users

25:56.830 --> 26:00.330
远程去拿用户数据

26:00.330 --> 26:02.430
这是一个有副作用的东西

26:02.430 --> 26:04.230
那么它返回啥呢

26:04.230 --> 26:05.930
我这些人函数模式嘛

26:05.930 --> 26:07.930
不然的话有些同学反应不过来

26:07.930 --> 26:09.430
函数模式

26:09.430 --> 26:13.230
就是fetch users

26:13.230 --> 26:14.030
它返回啥呢

26:14.030 --> 26:16.530
它本来说它是一个action创建函数

26:16.530 --> 26:16.930
对吧

26:16.930 --> 26:19.130
它返回的应该是一个平面对象

26:19.130 --> 26:20.830
本来应该返回的是一个action平面对象

26:20.830 --> 26:23.030
有type值还有什么

26:23.030 --> 26:24.630
有type值有payload的值

26:24.630 --> 26:25.630
对不对

26:25.630 --> 26:26.830
那么表示一个action

26:26.830 --> 26:28.430
但是由于我们使用了sunk

26:28.530 --> 26:32.530
它允许你返回一个具有副作用的函数

26:32.530 --> 26:36.430
由于sunk的存占

26:36.430 --> 26:44.330
允许x是一个带有副作用的函数

26:44.330 --> 26:45.830
于是我们这里可以返回什么

26:45.830 --> 26:47.530
可以返回一个函数

26:47.530 --> 26:50.030
我们可以返回一个函数

26:50.030 --> 26:52.630
这个函数还可以有副作用

26:52.630 --> 26:52.830
好

26:52.830 --> 26:54.930
这个函数里边我们就可以写上

26:54.930 --> 26:56.030
那些有副作用的代码

26:56.030 --> 26:56.730
就像这些代码

26:56.730 --> 26:59.630
我们就可以写过去

26:59.630 --> 26:59.930
好

26:59.930 --> 27:00.830
复制过来

27:00.830 --> 27:02.630
可以写过来

27:02.630 --> 27:04.730
就import在这

27:04.730 --> 27:05.930
import在这

27:05.930 --> 27:10.100
把刀上去

27:10.100 --> 27:11.600
这是副作用的函数

27:11.600 --> 27:11.900
对吧

27:11.900 --> 27:14.900
get all students

27:14.900 --> 27:15.200
好

27:15.200 --> 27:16.300
那么这里呢

27:16.300 --> 27:17.100
我们这里

27:17.100 --> 27:17.400
好

27:17.400 --> 27:18.200
那么首先呢

27:18.200 --> 27:20.400
你看这个副作用的函数里边要做很多事情

27:20.400 --> 27:23.400
我们首先要去触发状态变成什么

27:23.400 --> 27:24.400
做变状态变成

27:24.400 --> 27:25.700
就是家庭状态变成触

27:25.700 --> 27:26.400
对不对

27:26.400 --> 27:27.500
要去触发这个东西

27:27.500 --> 27:28.400
那怎么来触发呢

27:29.400 --> 27:31.100
那我现在怎么得到dispatch呢

27:31.100 --> 27:33.000
我这里没有Store

27:33.000 --> 27:34.100
那怎么得到dispatch呢

27:34.100 --> 27:35.200
是这样子

27:35.200 --> 27:36.700
到时候呢

27:36.700 --> 27:38.100
这个上可的中间键

27:38.100 --> 27:41.700
它会把dispatch作为参数给你传进来

27:41.700 --> 27:42.800
你就不究竟了吗

27:42.800 --> 27:43.600
对不对

27:43.600 --> 27:45.700
以后它会把参数给你传进来

27:45.700 --> 27:47.000
dispatch的参数

27:47.000 --> 27:49.200
所以说你这里就可以直接使用dispatch

27:49.200 --> 27:50.800
这个函数里边去处理副作用

27:50.800 --> 27:51.800
先把它设为q

27:51.800 --> 27:52.800
对吧

27:52.800 --> 27:53.900
这个不是副作用

27:53.900 --> 27:55.500
这只是触发一个x

27:55.500 --> 27:56.800
那么下面呢

27:56.900 --> 27:58.100
像这东西就是副作用了

27:58.100 --> 27:58.600
对不对

27:58.600 --> 27:59.100
副作用了

27:59.100 --> 28:00.900
那么这个函数既然是可以有副作用的

28:00.900 --> 28:03.600
那它甚至可以是异步的

28:03.600 --> 28:05.200
我们可以用这种协法

28:05.200 --> 28:07.700
用ES7的协法

28:07.700 --> 28:08.600
拿到

28:08.600 --> 28:10.000
从服务器拿到youtels

28:10.000 --> 28:10.600
而wait

28:10.600 --> 28:11.100
对吧

28:11.100 --> 28:11.800
而wait

28:11.800 --> 28:13.300
等待拿到youtels

28:13.300 --> 28:14.500
拿到之后呢

28:14.500 --> 28:17.800
我们这里

28:17.800 --> 28:19.100
拿到之后

28:19.100 --> 28:20.200
我们这里呢

28:20.200 --> 28:22.600
使用createYoutelAction

28:22.600 --> 28:25.600
都是自己的Action嘛

28:25.600 --> 28:27.200
把这个youtel放进去

28:27.200 --> 28:29.100
来得到一个x

28:29.100 --> 28:31.100
得到这么一个x

28:31.100 --> 28:33.800
然后呢去触发这个x

28:33.800 --> 28:34.900
dispatchx

28:34.900 --> 28:36.600
去触发它

28:36.600 --> 28:38.700
然后呢再去触发这个东西

28:38.700 --> 28:39.100
对吧

28:39.100 --> 28:40.800
我们就可以把它写到这

28:40.800 --> 28:42.100
写完了

28:42.100 --> 28:43.900
我们就写完了

28:43.900 --> 28:45.400
这就是一个有副作用的函数

28:45.400 --> 28:46.700
看到没

28:46.700 --> 28:50.300
这一步就在产生副作用的操作

28:50.300 --> 28:50.600
好

28:50.600 --> 28:51.300
于是

28:51.300 --> 28:52.700
以前是不能允许这样写的

28:52.700 --> 28:53.800
如果说没有伤口中间键

28:53.800 --> 28:55.300
是绝对不允许这样写的

28:55.300 --> 28:56.500
如果说没有伤口中间键

28:56.500 --> 28:57.100
你看一下

28:57.100 --> 28:57.800
没有伤口中间键

28:57.800 --> 28:59.300
会产生什么结果

28:59.300 --> 29:00.600
它告诉你什么

29:00.600 --> 29:01.200
告诉你

29:01.200 --> 29:01.600
哎

29:01.600 --> 29:04.810
它说什么

29:04.810 --> 29:05.110
哦

29:05.110 --> 29:07.310
这里

29:07.310 --> 29:08.310
youtelsx

29:08.310 --> 29:09.110
在这里

29:09.110 --> 29:11.910
这里还要返回上级目录

29:11.910 --> 29:12.710
还要返回啊

29:12.710 --> 29:17.710
好像

29:17.710 --> 29:19.810
student

29:19.810 --> 29:21.110
呃

29:21.110 --> 29:21.510
对的吧

29:21.510 --> 29:23.010
现在应该对的啊

29:26.010 --> 29:27.110
我们这里

29:27.110 --> 29:27.510
比方说

29:27.510 --> 29:28.710
现在呢

29:28.710 --> 29:30.610
现在呢

29:30.610 --> 29:31.810
如果说啊

29:31.810 --> 29:32.410
如果说

29:32.410 --> 29:33.410
我们在这里

29:33.410 --> 29:35.010
我们先不使用中间键吧

29:35.010 --> 29:38.240
先不使用中间键

29:38.240 --> 29:39.740
不使用中间键

29:39.740 --> 29:41.840
会有那个x型触发吗

29:41.840 --> 29:44.340
是不会有任何的x型触发啊

29:44.340 --> 29:46.240
不会有任何的x型触发

29:46.240 --> 29:46.640
为什么

29:46.640 --> 29:48.840
因为你这个x型返回的是一个

29:48.840 --> 29:49.840
是一个什么

29:49.840 --> 29:51.740
返回的是一个就是

29:51.740 --> 29:52.240
呃

29:52.240 --> 29:53.040
函数啊

29:53.040 --> 29:55.240
返回的是一个函数啊

29:55.240 --> 29:56.240
它返回的是

29:56.240 --> 29:56.440
哎

29:56.440 --> 29:58.040
跑了去了

29:58.040 --> 29:58.740
你这个

29:58.740 --> 29:59.740
你这个x型呢

29:59.740 --> 30:03.240
它返回的是一个函数啊

30:03.240 --> 30:04.040
呀

30:04.040 --> 30:04.940
我我运行

30:04.940 --> 30:06.240
现在运行的是test啊

30:06.240 --> 30:07.640
运行的是test

30:07.640 --> 30:08.140
呃

30:08.140 --> 30:09.340
我们

30:09.340 --> 30:11.740
test里边我们这样子换种写法

30:11.740 --> 30:11.840
好

30:11.840 --> 30:13.540
那么现在我们要触发那个x型

30:13.540 --> 30:14.840
我们就这样子触发

30:14.840 --> 30:17.040
Stone点dispatch啊

30:17.040 --> 30:18.440
Stone点dispatch

30:18.440 --> 30:19.140
触发一个x型

30:19.140 --> 30:20.140
触发哪个x型的

30:20.140 --> 30:22.040
触发这个

30:22.040 --> 30:23.440
我们现在在这里啊

30:23.440 --> 30:25.140
由于把他封到了x型里边了

30:25.140 --> 30:26.440
我们在这里触发什么

30:26.440 --> 30:27.540
触发那个

30:27.540 --> 30:28.240
fetch

30:28.240 --> 30:29.740
优热式对吧

30:29.740 --> 30:31.340
我们调用这个fetch优热式

30:31.340 --> 30:32.940
他返回一个x型啊

30:32.940 --> 30:34.040
返回一个x型

30:34.040 --> 30:35.540
那么来触发这个

30:35.540 --> 30:36.840
我们来触发这个

30:36.840 --> 30:37.840
你看现在能触发吗

30:37.840 --> 30:38.740
再再捋一下啊

30:38.740 --> 30:39.640
再捋一下

30:39.640 --> 30:40.240
我们这里呢

30:40.240 --> 30:41.840
本来是应该返回一个普通的

30:41.840 --> 30:43.240
x型平面对象的

30:43.240 --> 30:43.540
但是呢

30:43.540 --> 30:44.740
由于桑克的存在

30:44.740 --> 30:47.740
我们这里返回了一个有负重的函数

30:47.740 --> 30:48.440
啊

30:48.440 --> 30:49.240
然后呢

30:49.240 --> 30:51.040
我们到时候呢

30:51.040 --> 30:51.640
用法呢

30:51.640 --> 30:53.940
跟其他的x型创建函数的用法是一样的

30:53.940 --> 30:55.340
调用这个函数得到一个x型

30:55.340 --> 30:57.140
尽管的x型不是一个正常的x型

30:57.140 --> 30:57.940
得到的是一个

30:58.040 --> 30:58.840
有负重的函数

30:58.840 --> 31:01.240
但是由于桑克的存在是允许的

31:01.240 --> 31:02.440
那么这里第四part期

31:02.440 --> 31:04.440
那如果说没有桑克存在呢

31:04.440 --> 31:05.840
那我这里先把桑克注射掉

31:05.840 --> 31:06.740
没有桑克存在

31:06.740 --> 31:07.140
包存

31:09.140 --> 31:09.740
你看一下

31:09.740 --> 31:11.240
他是不是告诉你包错了

31:11.240 --> 31:11.540
对吧

31:11.540 --> 31:12.740
包错了

31:12.740 --> 31:13.440
啊

31:13.440 --> 31:14.240
他说

31:14.240 --> 31:14.840
x型呢

31:14.840 --> 31:17.140
must be a plan object

31:17.140 --> 31:18.840
他说x型必须是一个平面对象

31:18.840 --> 31:20.140
其实这是我们自己包的错误

31:20.140 --> 31:20.540
对吧

31:20.540 --> 31:21.240
自己写的代码

31:21.240 --> 31:22.040
因为我们自己

31:22.040 --> 31:23.140
我们现在用的是之前的

31:23.140 --> 31:23.940
我们自己写的代码

31:23.940 --> 31:25.440
那你看一下官方的他这里

31:25.440 --> 31:26.440
他也得包错啊

31:26.440 --> 31:27.040
他也得包错

31:27.040 --> 31:28.340
因为他也判断了对吧

31:28.340 --> 31:30.640
他说x型是must be a plan object

31:30.640 --> 31:31.340
对吧

31:31.340 --> 31:32.040
提示的语句呢

31:32.040 --> 31:33.940
好像好像呢

31:33.940 --> 31:35.040
就是啊

31:36.040 --> 31:37.140
好像有变化的

31:37.140 --> 31:37.940
但是呢

31:37.940 --> 31:38.840
意思是一样的啊

31:38.840 --> 31:39.940
意思是一样的

31:39.940 --> 31:40.940
他说告诉你呢

31:40.940 --> 31:42.940
应该你应该去使用什么

31:42.940 --> 31:43.840
嗯

31:43.840 --> 31:45.040
自定义的

31:45.640 --> 31:47.340
中间键啊

31:47.340 --> 31:48.340
来处理那些

31:48.340 --> 31:49.240
就是一步的

31:49.240 --> 31:50.840
一步的就是动作啊

31:50.840 --> 31:51.940
一步的x型

31:51.940 --> 31:52.340
那么这里呢

31:52.340 --> 31:53.340
桑克就是来处理

31:53.340 --> 31:54.440
这个问题的中间键

31:54.440 --> 31:55.240
他允许的

31:55.240 --> 31:56.740
反而会一个有副作用的

31:57.240 --> 31:58.640
函数来作为x型

31:59.040 --> 31:59.440
啊

31:59.440 --> 32:00.040
当然x型呢

32:00.040 --> 32:01.640
本来是应该是个平面对象的

32:01.640 --> 32:02.540
但是有上个存在

32:02.540 --> 32:03.240
它是允许的

32:03.240 --> 32:04.640
你看现在我把上可加上

32:05.340 --> 32:06.040
上可加上

32:06.540 --> 32:06.840
你看啊

32:06.840 --> 32:07.640
是不是正常了

32:07.640 --> 32:08.640
一切都正常了

32:08.640 --> 32:09.840
看没啊

32:09.840 --> 32:10.740
一切都正常了

32:11.540 --> 32:11.840
啊

32:11.840 --> 32:12.440
运行的什么

32:12.440 --> 32:13.140
set loading

32:13.140 --> 32:14.240
运行的set user 是

32:14.240 --> 32:15.240
运行的set loading

32:15.240 --> 32:15.640
对吧

32:15.640 --> 32:16.540
一切都正常了

32:16.940 --> 32:17.140
对吧

32:17.140 --> 32:18.340
这就是上可的作用

32:18.340 --> 32:19.540
上可就没了

32:19.540 --> 32:20.240
完了

32:20.240 --> 32:22.140
上可就是他允许的

32:22.140 --> 32:23.240
在x型

32:23.240 --> 32:24.540
x型这一块呢

32:24.640 --> 32:26.940
可以不是一个平面对象

32:27.140 --> 32:28.840
可以不是一个平面对象

32:28.840 --> 32:29.640
你的x型呢

32:29.640 --> 32:31.640
可以是一个函数

32:31.940 --> 32:32.440
啊

32:32.440 --> 32:34.540
你的x型可以是一个函数

32:35.140 --> 32:35.940
你看这个意思吧

32:36.240 --> 32:36.740
啊

32:36.840 --> 32:38.140
那么我们到时候用那个

32:38.140 --> 32:39.240
x型创建函数呢

32:39.240 --> 32:40.040
得到反回的

32:40.040 --> 32:41.740
就可以不用是一个平面对象

32:41.740 --> 32:42.940
而是一个函数

32:42.940 --> 32:43.940
这个函数呢

32:43.940 --> 32:44.840
它会运行

32:45.340 --> 32:45.540
啊

32:45.540 --> 32:46.240
它会运行

32:46.240 --> 32:47.540
所以我们这里记一笔啊

32:47.640 --> 32:48.740
在笔记里边记一笔

32:48.740 --> 32:49.640
上可这一块

32:51.040 --> 32:52.840
上可允许啊

32:52.840 --> 32:53.740
允许什么呢

32:53.740 --> 32:55.340
允许啊

32:55.340 --> 33:01.240
x型是一个带有副作用的函数

33:02.540 --> 33:03.140
啊

33:03.340 --> 33:03.940
当

33:04.840 --> 33:08.540
他当x型是一个函数时

33:09.540 --> 33:09.940
啊

33:10.940 --> 33:12.740
函数被分发时

33:12.740 --> 33:13.940
因为我们分发x型的时候

33:13.940 --> 33:15.540
是不是就是把x型传进去

33:15.540 --> 33:16.340
来进一分发

33:16.340 --> 33:16.840
对吧

33:16.940 --> 33:17.840
那么分发这个x型

33:17.840 --> 33:19.840
如果说它是一个函数的时候

33:20.140 --> 33:20.740
上可

33:21.340 --> 33:22.440
会啊

33:22.440 --> 33:24.440
阻止x型

33:24.640 --> 33:25.740
会阻止x型

33:26.340 --> 33:29.840
继续向后移交

33:30.040 --> 33:30.440
啊

33:30.440 --> 33:31.440
向后移交

33:32.040 --> 33:32.940
这什么意思呢

33:32.940 --> 33:33.940
你看这个图啊

33:34.140 --> 33:35.840
就是我们之前注册的中间键啊

33:35.840 --> 33:36.840
中间键比方说

33:37.940 --> 33:39.440
我们到时候注册完了

33:39.440 --> 33:40.740
中间键注册完了

33:40.840 --> 33:43.140
那么到时候去使用那个中间键的时候呢

33:43.240 --> 33:44.140
我们把这里

33:44.840 --> 33:45.240
复制

33:45.740 --> 33:46.340
这样子吧

33:46.940 --> 33:48.140
在这里复制一下啊

33:48.240 --> 33:48.740
放过来

33:50.340 --> 33:50.740
啊

33:51.740 --> 33:54.840
到时候我们去运行dispatch的时候啊

33:54.840 --> 33:56.740
到时候去运行dispatch的时候

33:58.040 --> 33:58.640
他是这样子

33:58.640 --> 33:59.840
我们之前分析过对吧

33:59.840 --> 34:00.940
他是怎么一个流产

34:00.940 --> 34:01.740
当我们调用

34:02.640 --> 34:04.040
仓库的dispatch的时候

34:04.140 --> 34:06.440
他是呢先交给第1个中间键啊

34:06.440 --> 34:07.540
交给第1个中间键

34:07.840 --> 34:09.340
就是我们的上可对不对啊

34:09.340 --> 34:09.940
上可

34:10.040 --> 34:11.240
那么当上可呢

34:11.240 --> 34:12.840
他本来应该是这样子啊

34:12.840 --> 34:14.440
我们之前讲过洋冲模型

34:14.440 --> 34:15.040
对不对

34:15.040 --> 34:16.140
洋冲模型

34:16.140 --> 34:17.140
就是说啊

34:17.140 --> 34:18.740
如果就是说那个

34:18.740 --> 34:20.640
他的第1个中间键处理处理了

34:20.640 --> 34:21.740
处理了一会之后呢

34:21.740 --> 34:24.340
他会交给下一个中间键来处理啊

34:24.340 --> 34:25.840
他是用这种模式来进行的

34:26.840 --> 34:27.740
但是呢上可呢

34:27.740 --> 34:30.040
他做做了一点特殊特殊处理

34:30.040 --> 34:33.440
就是说如果他发现你触发的x是一个函数

34:34.040 --> 34:36.040
那么如果他这里是上可

34:37.860 --> 34:40.360
他发现你的x是一个函数

34:40.360 --> 34:42.060
他就不会往后边移交了

34:42.060 --> 34:44.560
他根本就不会往后边移交了啊

34:44.560 --> 34:45.560
他会怎么来处理呢

34:45.560 --> 34:47.760
他会直接调用函数啊

34:50.760 --> 34:51.160
啊

34:51.560 --> 34:52.360
他会怎么做呢

34:52.360 --> 34:54.160
就是说如果啊

34:54.160 --> 34:57.160
如果x是一个函数

34:57.760 --> 35:02.660
则上可不会向后移交啊

35:02.660 --> 35:05.360
不会向后不会向后移交这个x

35:05.360 --> 35:07.360
不是我们之前写中间键的时候

35:07.360 --> 35:08.760
不是一个next这个参数吗

35:08.760 --> 35:09.660
回应一下啊

35:09.660 --> 35:11.160
咱们之前写的中间键的时候

35:11.160 --> 35:12.660
有这么一个next这个参数

35:12.660 --> 35:13.960
那么他到他呢

35:13.960 --> 35:14.760
他会把这个

35:15.760 --> 35:17.460
x的分发呢

35:17.460 --> 35:18.760
继续往后移交啊

35:18.760 --> 35:19.660
继续往后移交

35:19.660 --> 35:20.260
但是上可了

35:20.260 --> 35:21.760
他如果发现x是一个函数

35:21.760 --> 35:23.060
就不会往后移交

35:23.060 --> 35:27.360
那么会直接调用函数啊

35:27.360 --> 35:30.360
会直接调用函数

35:30.360 --> 35:32.160
这就是上可的作用啊

35:32.160 --> 35:33.560
如果他发现x是一个函数

35:33.560 --> 35:34.360
他就不会移交

35:34.360 --> 35:35.460
他就不会往后移交

35:35.460 --> 35:37.060
他就会直接调用函数

35:37.060 --> 35:38.760
那么就起了乖了

35:38.760 --> 35:39.460
你想啊

35:40.660 --> 35:41.660
我们这里呢

35:41.660 --> 35:42.460
赢这个手这里

35:42.460 --> 35:43.760
不是注冊两个中间吗

35:43.760 --> 35:45.460
那如果说他没往后移交

35:45.460 --> 35:46.760
日子怎么季度下来的呢

35:47.560 --> 35:48.660
日子怎么打印出来的呢

35:49.760 --> 35:50.560
他是这样子

35:51.760 --> 35:53.560
由于他调用的是啥

35:53.560 --> 35:54.660
调用的

35:54.660 --> 35:56.260
他只是调用x函函数

35:56.260 --> 35:57.560
就调用这个函数

35:57.560 --> 35:58.660
那如果说这个函数里边

35:58.660 --> 35:59.460
我啥都没写

36:00.560 --> 36:01.360
我啥都没写

36:01.360 --> 36:02.460
我就输出了一句话

36:03.060 --> 36:03.660
abc

36:04.360 --> 36:04.860
保存

36:05.960 --> 36:07.160
你看是不是只有abc

36:07.160 --> 36:08.960
日子日子有用吗

36:08.960 --> 36:10.360
那个日子中间键有用吗

36:10.360 --> 36:11.060
是没用

36:11.060 --> 36:12.460
日子中间键根本就没有调用

36:12.460 --> 36:13.560
为什么没有调用

36:13.560 --> 36:13.960
你看一下

36:13.960 --> 36:15.060
我这里不是第四part期

36:15.060 --> 36:16.460
触发了一个函数吗

36:16.460 --> 36:17.860
但是这个函数反回的结果

36:17.860 --> 36:18.860
是一个函数

36:18.860 --> 36:20.260
你看下这个费齐物热子

36:20.260 --> 36:21.660
他反回的是一个函数

36:21.660 --> 36:22.960
以为他是一个函数

36:22.960 --> 36:23.960
他叫交给谁

36:23.960 --> 36:25.960
是不是交给这个上可的中间键

36:25.960 --> 36:26.460
上可中间键

36:26.460 --> 36:28.160
他发现x是一个函数

36:28.160 --> 36:29.660
是不是就没有往后移交

36:29.660 --> 36:30.460
对吧

36:30.460 --> 36:31.360
没有往后移交

36:31.360 --> 36:31.760
你想啊

36:31.760 --> 36:32.760
他能不能往后移交

36:32.760 --> 36:34.160
不能往后移交啊

36:34.160 --> 36:34.960
你往后移交

36:34.960 --> 36:35.560
你看一下

36:35.560 --> 36:36.460
后边是啥

36:36.460 --> 36:37.260
后边是nogo

36:37.260 --> 36:37.860
对不对

36:37.860 --> 36:38.760
后边是nogo

36:38.760 --> 36:40.060
他如果说往后移交了

36:40.060 --> 36:41.160
nogo一下就蒙了

36:42.460 --> 36:44.060
你怎么给我一个函数的x

36:44.060 --> 36:45.760
x不能设一个函数啊

36:45.760 --> 36:47.960
这就是为什么nogo要往后边放

36:48.660 --> 36:49.760
因为前边的x

36:49.760 --> 36:51.360
可能是一些乱七八糟的东西

36:52.160 --> 36:54.260
nogo不能去记录一些乱七八糟的x

36:54.260 --> 36:54.960
比方说这里

36:54.960 --> 36:56.260
如果说把nogo放前面

36:56.260 --> 36:56.760
你看

36:57.560 --> 36:58.260
你看一下吧

36:58.260 --> 36:59.760
如果说把nogo放前面

37:00.460 --> 37:01.060
那么这样子

37:01.060 --> 37:02.460
他就会把函数交给nogo了

37:02.460 --> 37:04.160
把个x函数交给nogo了

37:04.160 --> 37:05.560
那你看nogo的x

37:06.160 --> 37:07.460
这个x是一个啥

37:07.460 --> 37:08.260
是一个函数

37:08.260 --> 37:08.960
蒙了

37:08.960 --> 37:09.960
这是啥呀这是

37:10.460 --> 37:11.360
虽然他打印出来了

37:11.360 --> 37:12.260
但是肯定不是

37:12.560 --> 37:13.560
把我们就看蒙了

37:13.560 --> 37:13.860
对吧

37:13.860 --> 37:14.660
就看蒙了

37:15.660 --> 37:16.360
他是这样子

37:17.060 --> 37:17.960
上可放前面

37:17.960 --> 37:18.760
nogo放后边

37:18.760 --> 37:19.460
你看一下

37:19.460 --> 37:21.060
上可如果看到x是一个函数

37:21.060 --> 37:22.060
他直接去调用

37:22.160 --> 37:23.660
如果x不是函数

37:23.660 --> 37:24.660
他再往后移交

37:24.860 --> 37:26.260
他是这么一个逻辑

37:26.760 --> 37:26.960
好

37:26.960 --> 37:28.460
那么再来理一下

37:28.460 --> 37:29.460
再来梳理一下

37:29.660 --> 37:30.660
那如果说这边

37:31.360 --> 37:32.660
这个x里边啥都没做

37:32.660 --> 37:33.860
就打印一个abc

37:34.060 --> 37:34.560
那你看

37:34.560 --> 37:35.860
运行的x是不是就完了

37:36.860 --> 37:37.560
是不是就完了

37:37.560 --> 37:38.460
那么这种情况下

37:38.460 --> 37:39.460
他还会往后移交吗

37:39.460 --> 37:40.160
是不是没有往后移交

37:40.160 --> 37:41.360
这个东西就没起作用

37:41.660 --> 37:42.860
运行的x就完了

37:43.360 --> 37:43.860
就完了

37:43.860 --> 37:44.860
因为他给他的事情函数

37:44.860 --> 37:45.860
被他截获了

37:46.160 --> 37:47.260
他没有往后移交

37:47.460 --> 37:49.260
所以说你就看不到这个nogo里边

37:49.260 --> 37:50.260
打印的出来的东西

37:51.360 --> 37:53.060
那如果说我们这里边

37:53.360 --> 37:54.360
写了这么一些东西

37:54.660 --> 37:56.660
那么我们在运行这个函数的时候

37:56.660 --> 37:58.660
是不是触发了又进行的分发

37:58.860 --> 37:59.260
对吧

37:59.660 --> 38:01.060
在运行这个x的时候

38:01.260 --> 38:02.660
在运行这个x的过程中

38:02.860 --> 38:03.960
然后进行了分发

38:04.160 --> 38:04.460
对吧

38:04.460 --> 38:05.260
进行了分发

38:05.260 --> 38:06.260
那么这个时候分发

38:06.260 --> 38:08.060
是不是又要重新运行这个流程

38:08.260 --> 38:09.460
每一次dispatch

38:09.460 --> 38:11.160
你看你这里每一次dispatch

38:11.160 --> 38:12.660
是不是又要得到一个x

38:12.660 --> 38:13.960
要重新运行这个流程

38:14.160 --> 38:15.460
好运行这个流程的话

38:15.460 --> 38:17.160
那后面的运行的时候

38:17.260 --> 38:18.560
他x就不是函数了

38:18.560 --> 38:19.060
对吧

38:19.360 --> 38:19.960
那你想啊

38:20.060 --> 38:21.560
这句话dispatch的时候

38:21.560 --> 38:22.760
这里返回的东西是啥

38:22.760 --> 38:23.560
是不是不是函数

38:23.560 --> 38:24.660
你看他返回的是啥吗

38:24.760 --> 38:25.560
他返回的是这个

38:26.260 --> 38:27.260
是不是不是函数

38:27.560 --> 38:27.860
对吧

38:27.860 --> 38:29.160
他反过来是一个平面对象

38:29.160 --> 38:29.660
ok

38:29.660 --> 38:31.560
那么这个时候再走一次这个流程

38:31.560 --> 38:32.660
诶平面对象

38:32.660 --> 38:33.060
ok

38:33.060 --> 38:33.760
那我不是函数

38:33.760 --> 38:34.560
我就不会运行

38:34.760 --> 38:36.460
那么我就把x往后移交

38:36.660 --> 38:38.060
是这么一个逻辑啊

38:38.160 --> 38:38.960
这么个逻辑

38:39.660 --> 38:40.360
能听懂吗

38:41.360 --> 38:42.360
那么这里的就是

38:42.360 --> 38:43.660
然后进行附中用操作

38:43.660 --> 38:44.760
然后又dispatch

38:44.960 --> 38:46.560
又得到一个x发过去

38:46.560 --> 38:47.960
那么这个又是一个平面对象

38:47.960 --> 38:48.660
那么后边呢

38:48.660 --> 38:49.460
他就不会再

38:49.660 --> 38:51.060
不会再当成函数来

38:51.260 --> 38:51.760
创建了

38:51.760 --> 38:53.360
但是如果说你后边还给他传了一个函数

38:53.360 --> 38:55.160
他又要把它当成函数来运行

38:55.560 --> 38:57.260
总之这个流程又重新走一遍

38:57.660 --> 38:59.260
总之这个sunk就很简单

38:59.360 --> 39:00.360
发现x是函数

39:00.360 --> 39:00.960
运行函数

39:01.060 --> 39:01.560
没了

39:01.560 --> 39:02.260
咋都不做了

39:02.660 --> 39:04.260
如果他不是函数往后边移交

39:04.260 --> 39:04.760
我不管

39:06.060 --> 39:07.760
sunk就在做这样的处理的

39:07.960 --> 39:08.760
这就是sunk

39:09.160 --> 39:10.460
他相当于是做了一个

39:10.460 --> 39:11.460
蓝结过滤

39:11.460 --> 39:13.460
如果你x是函数走一条通道

39:13.460 --> 39:14.260
往这边走

39:14.460 --> 39:16.360
如果你不是函数往后边移交

39:16.760 --> 39:17.060
啊

39:17.060 --> 39:18.060
这就是sunk的作用

39:18.360 --> 39:19.060
其他没了

39:19.260 --> 39:20.060
其他就没了

39:20.460 --> 39:20.960
并且呢

39:20.960 --> 39:22.260
sunk他调用函数的时候

39:22.260 --> 39:22.660
还会

39:22.660 --> 39:24.760
还会往函数里边传参数

39:26.660 --> 39:27.160
啊

39:27.260 --> 39:27.760
sunk

39:28.360 --> 39:29.060
会向

39:29.460 --> 39:30.860
函数中传递

39:31.860 --> 39:33.460
函数中传递

39:34.360 --> 39:35.460
两个参数

39:35.660 --> 39:36.460
哪两个呢

39:36.860 --> 39:37.260
啊

39:38.260 --> 39:39.160
三个参数啊

39:39.160 --> 39:40.060
我把它说完嘛

39:40.460 --> 39:41.260
三个参数

39:41.760 --> 39:42.360
哪三个呢

39:42.360 --> 39:43.760
第一个dispatch

39:44.260 --> 39:45.360
这个来自于哪呢

39:45.460 --> 39:48.260
来自于store.dispatch

39:48.760 --> 39:50.460
他传的是什么

39:50.760 --> 39:51.660
他是个中间键

39:51.660 --> 39:53.060
我们之前也写过中间键

39:53.360 --> 39:54.860
他传的还不是那个

39:54.860 --> 39:56.460
我们看一下之前中间键咋写的

39:56.560 --> 39:57.660
我们回忆一下啊

39:57.660 --> 39:58.560
之前的中间键

39:59.160 --> 39:59.860
madeware

39:59.960 --> 40:00.760
怎么写的呢

40:00.960 --> 40:02.060
是不是store

40:03.460 --> 40:04.860
然后呢什么next

40:04.860 --> 40:05.160
对吧

40:05.160 --> 40:06.160
这就是个dispatch

40:06.160 --> 40:06.560
对不对

40:06.660 --> 40:07.360
dispatch

40:07.460 --> 40:07.660
好

40:07.660 --> 40:08.360
那么然后呢

40:08.360 --> 40:08.860
是一个啥

40:09.360 --> 40:10.360
是一个就是

40:11.860 --> 40:12.260
这个啥

40:12.260 --> 40:12.760
exit

40:13.160 --> 40:13.560
对吧

40:14.260 --> 40:15.360
就这么写的中间键

40:15.460 --> 40:15.660
好

40:15.660 --> 40:16.960
那么他传的那个dispatch

40:16.960 --> 40:17.460
是什么呢

40:17.460 --> 40:18.060
不是这个

40:18.560 --> 40:19.160
因为这个呢

40:19.160 --> 40:20.060
我们之前说过啊

40:20.160 --> 40:20.960
这个东西dispatch

40:20.960 --> 40:23.160
他指的是下一个中间键的dispatch

40:23.760 --> 40:24.260
那个dispatch

40:24.260 --> 40:25.960
指的是下一个中间键的dispatch

40:26.260 --> 40:28.360
而不是store.dispatch

40:28.860 --> 40:30.160
所以说他给他传的要是什么

40:30.160 --> 40:31.460
传的要是store.dispatch

40:31.460 --> 40:33.260
让他重新走一遍整个流程

40:33.660 --> 40:35.360
让他重新走一遍整个流程

40:36.860 --> 40:39.060
就是最终的仓库里边的dispatch

40:39.760 --> 40:40.260
所以说呢

40:40.260 --> 40:42.060
这里传递的是store.dispatch

40:42.560 --> 40:42.760
好

40:42.760 --> 40:43.360
然后呢

40:43.460 --> 40:44.560
这个get state

40:45.560 --> 40:46.160
第二参数

40:46.160 --> 40:46.960
这是第二参数啊

40:46.960 --> 40:48.960
也就是说你在这个附中用函数里边

40:48.960 --> 40:50.660
你是可以得到状态的

40:50.960 --> 40:51.860
是来自于

40:53.060 --> 40:53.860
来自于什么呢

40:54.060 --> 40:55.760
store.get state

40:57.160 --> 40:58.360
第三个参数呢

40:58.760 --> 40:59.460
extra

41:00.660 --> 41:01.560
来自于

41:02.260 --> 41:04.060
用户设置的

41:04.560 --> 41:06.460
设置的额外参数

41:06.760 --> 41:07.360
你没有设置

41:07.360 --> 41:07.960
那就无所谓

41:07.960 --> 41:08.560
你设置的

41:08.560 --> 41:08.960
ok

41:08.960 --> 41:09.660
那么我就

41:10.260 --> 41:11.160
给你加上一个

41:11.360 --> 41:12.460
设置的额外参数

41:12.460 --> 41:12.960
你没有设置

41:12.960 --> 41:13.760
当然就无所谓

41:14.160 --> 41:14.960
就无所谓

41:15.160 --> 41:16.360
那么一般都用不到

41:16.360 --> 41:17.960
一般都用不到这个extra

41:17.960 --> 41:18.460
什么意思呢

41:18.460 --> 41:19.760
我们再写一下吧

41:19.860 --> 41:20.760
比方说在这里

41:20.960 --> 41:22.160
三个参数我们都写全啊

41:22.160 --> 41:22.960
dispatch

41:23.960 --> 41:24.760
get state

41:25.260 --> 41:25.760
然后呢

41:25.760 --> 41:26.860
extra都写全

41:27.160 --> 41:27.560
这里呢

41:27.560 --> 41:29.260
我们输出get state

41:30.660 --> 41:31.860
拿到当前的状态

41:32.560 --> 41:33.360
拿到当前的状态

41:33.360 --> 41:34.860
然后再输出extra

41:35.260 --> 41:35.960
好看一下吧

41:37.660 --> 41:38.560
那么get state

41:38.660 --> 41:39.960
看一下前面答应的

41:39.960 --> 41:40.760
是不是当前的状态

41:40.760 --> 41:41.160
对吧

41:41.660 --> 41:42.460
运行这个函数的时候

41:42.460 --> 41:43.260
当前的状态

41:44.260 --> 41:45.060
loading force

41:45.260 --> 41:46.260
数组为空数组

41:46.460 --> 41:46.860
然后呢

41:46.860 --> 41:47.560
undefend

41:47.760 --> 41:48.460
undefend

41:48.560 --> 41:49.460
那么这个东西呢

41:49.460 --> 41:51.060
是就是第三个参数

41:51.260 --> 41:52.660
第三个参数来自于哪呢

41:52.860 --> 41:53.460
品质用不到

41:53.460 --> 41:54.060
再说一次

41:54.060 --> 41:54.860
品质用不到

41:55.260 --> 41:55.960
来自于哪呢

41:55.960 --> 41:56.660
来自于这

41:58.260 --> 42:00.260
是你在应用这个中间键的时候

42:01.860 --> 42:03.160
应用这个中间键的时候

42:03.160 --> 42:04.660
那么你可以自行配置

42:04.860 --> 42:05.660
上课里边呢

42:05.660 --> 42:06.860
它有这么一个东西啊

42:07.460 --> 42:08.060
vis

42:08.860 --> 42:10.960
visextra argument

42:11.460 --> 42:12.660
你给它加一个就是

42:13.060 --> 42:14.160
任意的一个额外参数

42:14.160 --> 42:14.860
你这样子写

42:15.060 --> 42:15.560
放到这

42:15.760 --> 42:16.260
放到这

42:16.560 --> 42:19.160
把这个函数的反回结果当成当成一个中间键

42:19.160 --> 42:20.360
它里边提供了一个函数

42:20.360 --> 42:22.360
把这个函数的反回结果当成中间键

42:22.360 --> 42:23.660
里边可以注入一个参数

42:23.660 --> 42:25.260
比方说参数的值就是123

42:25.260 --> 42:26.060
所以随便加写吧

42:26.060 --> 42:27.060
你想写啥写啥

42:27.660 --> 42:28.160
保存

42:28.160 --> 42:28.860
那么这样子呢

42:28.860 --> 42:30.060
每一个副作用函数里边

42:30.060 --> 42:31.860
它都可以得到一个额外参数123

42:33.060 --> 42:33.760
就这么个一支

42:33.960 --> 42:34.660
用不到啊

42:34.660 --> 42:35.460
品质用不到

42:35.660 --> 42:36.460
品质用不到

42:37.660 --> 42:38.560
就这么个意思

42:38.860 --> 42:39.160
好了

42:39.160 --> 42:40.060
我们再来总结一下

42:40.060 --> 42:41.360
商可非常非常简单

42:41.460 --> 42:42.560
它的实现原理

42:42.560 --> 42:43.660
它的原理就是

42:44.060 --> 42:44.760
一个中间键

42:45.260 --> 42:47.160
这个中间键每一次在dispatch的时候

42:47.160 --> 42:48.560
那么它就作为第一个对吧

42:48.560 --> 42:50.160
它拿到了这个x

42:50.160 --> 42:52.160
它如果说发现x是一个函数

42:52.560 --> 42:53.560
就直接运行这个函数

42:53.560 --> 42:54.160
啥都没管

42:54.160 --> 42:55.660
往这个函数里边扔一些参数

42:55.960 --> 42:56.860
让它去使用

42:57.460 --> 42:58.160
啥都没管

42:58.460 --> 42:59.760
如果说它不是一个函数

42:59.760 --> 43:00.960
x是一个普通对象

43:00.960 --> 43:01.260
ok

43:01.260 --> 43:01.760
往后面

43:01.760 --> 43:02.660
往后面排

43:02.860 --> 43:04.260
只要是它是函数调用

43:04.260 --> 43:05.760
不是函数走另一条通道

43:05.760 --> 43:06.560
往后面扔

43:06.760 --> 43:07.560
然后面去调用

43:07.560 --> 43:08.360
我自己啥都不管

43:08.560 --> 43:09.360
这就是商可的作用

43:09.360 --> 43:09.960
其他没了

43:10.860 --> 43:11.460
那么这样子

43:11.460 --> 43:12.860
我们就有机会在x

43:13.460 --> 43:15.160
x就可以使用一个函数了

43:15.160 --> 43:15.560
对吧

43:15.560 --> 43:16.160
函数了

43:16.160 --> 43:16.960
那么这个函数里边

43:16.960 --> 43:18.460
我们可以拿到这些数据

43:18.460 --> 43:19.560
拿到这些dispatch

43:19.560 --> 43:20.260
get status

43:20.260 --> 43:21.760
耳外它是我们品识都用不到

43:21.760 --> 43:22.560
品识都用不到

43:22.960 --> 43:23.860
可以拿到这些东西

43:24.760 --> 43:25.260
就可以拿

43:25.460 --> 43:26.660
我们就可以拿到这些东西

43:26.860 --> 43:27.360
拿到这些东西

43:27.360 --> 43:28.360
然后我们i怎么处理

43:28.360 --> 43:28.960
就怎么处理

43:28.960 --> 43:30.060
去可以写附中用

43:30.360 --> 43:32.660
经过这么一个附中用过程中

43:32.660 --> 43:34.460
我们在获取学生的过程中

43:34.460 --> 43:35.660
获取用户的过程中

43:35.660 --> 43:37.060
我们可能会触发多个x

43:37.060 --> 43:37.860
多次触发

43:37.860 --> 43:38.260
对吧

43:38.260 --> 43:39.360
我们就可以在这里面去处理

43:39.360 --> 43:40.060
这个逻辑了

43:41.360 --> 43:42.060
原来的意思吧

43:42.460 --> 43:44.160
那么这里触发这些x的时候

43:44.160 --> 43:45.460
就会导致Reducer

43:45.560 --> 43:46.560
那么整个过程Reducer

43:46.560 --> 43:47.860
他知不知道有附作用

43:48.060 --> 43:49.060
Reducer是蒙的

43:49.160 --> 43:49.760
我不知道

43:49.760 --> 43:50.460
我他都不知道

43:50.460 --> 43:51.160
你给我一个用户

43:51.160 --> 43:51.760
我就添加

43:51.760 --> 43:52.560
你给我一个id

43:52.560 --> 43:53.160
我就删除

43:53.160 --> 43:55.060
你给我一个用户

43:55.060 --> 43:55.760
我就修改

43:55.760 --> 43:56.760
你给我一个就是

43:56.960 --> 43:57.260
数组

43:57.260 --> 43:58.560
我就把它设置到数组里边

43:58.660 --> 43:59.460
你给我一个

43:59.860 --> 44:00.760
true或者force

44:00.760 --> 44:02.060
我就设置到什么

44:02.060 --> 44:03.160
设置到ease loading里边

44:03.360 --> 44:04.960
我根本就不知道这些数据哪来的

44:04.960 --> 44:07.060
Reducer是永远是纯净的

44:07.160 --> 44:08.160
就是后边的附作用

44:08.160 --> 44:09.260
无论怎么玩

44:09.560 --> 44:10.560
他的Reducer

44:10.560 --> 44:11.660
他一定是纯净的

44:11.760 --> 44:13.160
非常非常纯粹的

44:13.760 --> 44:15.460
附作用是在x型这里产生的

44:15.460 --> 44:15.960
看没有

44:16.160 --> 44:17.660
我们至少我们桑可这个

44:18.260 --> 44:18.760
这个库

44:18.760 --> 44:20.660
他是在x型这里处理附作用的

44:20.760 --> 44:22.660
产生一个函数在处理附作用

44:22.760 --> 44:24.660
那么这个函数里边去触发各种x型

44:25.760 --> 44:26.460
不要的意思吧

44:27.560 --> 44:28.560
好好去理一下

44:28.560 --> 44:29.660
好好去理一下

44:29.660 --> 44:31.460
这是桑可这个中间键的作用

44:32.460 --> 44:32.760
好

44:32.760 --> 44:33.360
那么下节课

44:33.360 --> 44:33.960
咱们来讲

44:33.960 --> 44:36.360
桑可他的原代码实现

44:36.360 --> 44:37.360
非常非常简单

