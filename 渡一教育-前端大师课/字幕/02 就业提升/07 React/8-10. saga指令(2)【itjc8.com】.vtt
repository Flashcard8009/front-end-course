WEBVTT

00:01.010 --> 00:05.810
咱们这一课呢 接着讲 上节课接着讲 讲这个指令

00:05.810 --> 00:09.010
现在有多少几个指令呢 咱们这一课呢 讲这么四个指令

00:09.010 --> 00:12.410
Forg,cancel,cancel,riss

00:12.410 --> 00:15.610
这几个指令呢 相对于上节课来说的话

00:15.610 --> 00:20.410
它就用的比较少一点啊 但是有的时候呢 也会用到

00:20.410 --> 00:24.910
特别是这个Forg指令 这个Forg指令呢 在它内部实现里边

00:24.910 --> 00:30.310
到处会用 但是呢 我们平时呢 要说用的话 也可能会用到啊

00:30.810 --> 00:36.310
其实除了这四个指令之外呢 还有一些指令 还有一些指令呢

00:36.310 --> 00:39.810
我们就不讲了啊 因为它指令实在太多了啊

00:39.810 --> 00:42.810
而且每个指令呢 有很多很多的细节用法

00:42.810 --> 00:46.810
实在东西实在太多了 也没有必要去每一个讲

00:46.810 --> 00:50.610
因为像你们学到后期的话 特别是学到后边

00:50.610 --> 00:53.610
就又要学会自己去看那个API文档

00:53.610 --> 00:56.810
不是说我想偷懒啊 这个东西绝对不是这个样子

00:56.810 --> 00:59.810
因为我如果说我讲了 过后那个时长会

00:59.810 --> 01:03.310
一式会拿到 拿到非常非常长 没有这个必要

01:03.310 --> 01:08.310
第二个呢 你就算不讲 也可以通过API文档

01:08.310 --> 01:12.310
能够得到这样的信息 因为你们最终到了以后

01:12.310 --> 01:17.310
进入公司过后呢 肯定不会说永远都会依赖老师

01:17.310 --> 01:20.810
就老师呢 会告诉你怎么去 这条路该怎么去走

01:20.810 --> 01:24.310
给你指明一个方向 并且呢 把一些核心原理性的东西

01:24.310 --> 01:27.810
讲清楚 比如说什么圆骂分析啊 哪怕没有圆骂分析

01:27.810 --> 01:31.810
我也会给你讲到它的原理 对吧 老师他起这么一个作用

01:31.810 --> 01:34.810
像一些具体的API细致默契的东西呢

01:34.810 --> 01:37.810
如果说你在公司里面遇到了一些问题

01:37.810 --> 01:40.810
你可以去采约他的API文档 或者是呢 以后呢

01:40.810 --> 01:43.810
除了一些新技术 市面上没有教程那里怎么办呢

01:43.810 --> 01:46.810
那你还不是只能看API文档 所以说你在

01:46.810 --> 01:50.310
学前端的话东西非常非常多 每个东西呢

01:50.310 --> 01:53.810
也没有那么难 大家要学会啊 去看一下API文档

01:53.810 --> 01:57.310
以前呢 我在线下收获的时候 到了

01:57.310 --> 02:00.310
后期就讲到那个什么

02:00.310 --> 02:03.310
微信小程序啊那些东西的时候呢

02:03.310 --> 02:05.310
我基本上就是让同学们自己去看文档

02:05.310 --> 02:07.310
我告诉他们怎么去看文档

02:07.310 --> 02:10.310
这个能力是非常非常重要的

02:10.310 --> 02:13.310
因为你们早晚得拖的老师要去治学的

02:13.310 --> 02:16.310
所以说呢 大家后边如果说

02:16.310 --> 02:19.310
万一到了公司里面要用到一些

02:19.310 --> 02:22.310
奇奇怪怪的东西 那么你可以去采约他的API文档

02:22.310 --> 02:24.310
那么这个文档呢 我说一下啊

02:24.310 --> 02:27.310
这个文档呢 我以前看过 发现他里边翻译呢

02:27.310 --> 02:29.310
是有一些错误的 翻译是有一些

02:29.310 --> 02:31.310
有些地方是有些错误的 莫名其妙的

02:31.310 --> 02:34.310
前面的不用看了 前面的我都会给你讲

02:34.310 --> 02:37.310
啊 都会给你讲 主要是看后边这个API参考

02:37.310 --> 02:40.310
啊 主要是如果你要看一些就是

02:40.310 --> 02:43.310
没有讲到的那些API的话 可以看一下

02:43.310 --> 02:46.810
这个API参考 你看看 他里边非常非常多啊

02:46.810 --> 02:49.810
非常非常多啊 你可以自行去

02:49.810 --> 02:51.810
没事的时候可以去看一下啊 看两眼

02:51.810 --> 02:54.810
因为你知道原理过后呢 你去看这个API文档

02:54.810 --> 02:57.810
是非常非常轻松的啊 没有什么难度

02:57.810 --> 02:59.810
好 咱们呢 这些课来学习这么四个啊

02:59.810 --> 03:01.810
四个指令 首先是第1个

03:01.810 --> 03:04.810
FORC 这个指令呢 它是用于这个啊

03:04.810 --> 03:10.810
它是用于 啊 用于开启一个新的任务

03:10.810 --> 03:13.810
啊 它是用于开启一个新的任务

03:13.810 --> 03:17.810
呃 该任务 该任务

03:17.810 --> 03:20.810
不会主色 不会主色 这是FORC

03:20.810 --> 03:23.810
FORC呢 这里的每一个指令都是一个函数啊

03:23.810 --> 03:25.810
都是一个函数 那么FORC也是一样

03:25.810 --> 03:28.810
它也是一个函数 那么这个函数里面

03:28.810 --> 03:31.810
要传一个啥东西呢 它要传一个啥呢

03:31.810 --> 03:35.810
该函数需要传递一个

03:35.810 --> 03:38.810
啊 就是generator function

03:38.810 --> 03:40.810
叫做生成器函数

03:40.810 --> 03:45.140
它需要传递一个生成器函数

03:45.140 --> 03:48.140
于是呢 它就会开始去运行那个生成器函数

03:48.140 --> 03:50.140
去控制那个生成器函数运行

03:50.140 --> 03:52.140
但是呢 它不会主色

03:52.140 --> 03:55.140
注意 FORC 这个功能呢 它是不会主色的

03:55.140 --> 03:57.140
咱们举个例子啊 比方说

03:57.140 --> 03:59.140
我们之前不是写了一个什么 counter嘛

03:59.140 --> 04:02.140
对不对 咱们就在 counter 里面举这个例子

04:02.140 --> 04:05.140
之前呢 我们使用的是 TakeAvery

04:05.140 --> 04:06.140
对吧 TakeAvery

04:06.140 --> 04:08.140
那么这个东西是不是不会主色啊

04:08.140 --> 04:10.140
监听这个玩意儿 然后呢

04:10.140 --> 04:12.140
它不会主色 不会主色

04:12.140 --> 04:15.140
然后呢 当每一次发生这个监听的时候呢

04:15.140 --> 04:17.140
我们就去运行这个方法 对吧

04:17.140 --> 04:19.140
那么实际上 TakeAvery

04:19.140 --> 04:22.140
它相当于是我们下面的写法 大家注意看

04:22.140 --> 04:25.140
相当于是下面的写法

04:25.140 --> 04:27.140
我们先把这个删掉了

04:27.140 --> 04:30.140
我们先写一个一模一样的出来

04:30.140 --> 04:32.140
我们就写个 yield

04:32.140 --> 04:34.140
好 那么现在呢 我们导入一个 FORC

04:34.140 --> 04:38.970
FORC 相当于是什么呢

04:38.970 --> 04:41.970
相当于是分支 一个分叉

04:41.970 --> 04:44.970
就是我拷贝一个完全相同的那种功能出来

04:44.970 --> 04:46.970
然后呢 不影响原来的东西

04:46.970 --> 04:48.970
那么就是个 FORC

04:48.970 --> 04:50.970
FORC 就是我开启一个新任务

04:50.970 --> 04:52.970
但是不影响原来任务的运行

04:52.970 --> 04:54.970
后面接着运行就行了

04:54.970 --> 04:55.970
那么这里 FORC

04:55.970 --> 04:56.970
我们开启一个新的任务

04:56.970 --> 05:00.970
这个任务呢 后面我们就给它一个函数

05:00.970 --> 05:03.970
Increase 就给它这么一个函数

05:03.970 --> 05:05.970
这是一个生存器函数 对吧

05:05.970 --> 05:06.970
于是FORC里边

05:06.970 --> 05:07.970
它就是给了一个生存器函数

05:07.970 --> 05:08.970
没什么好说的

05:08.970 --> 05:11.970
就给这么一个生存器函数一完事了

05:11.970 --> 05:13.970
那么这个函数里边呢

05:13.970 --> 05:15.970
比方说我这个函数里边有主色

05:15.970 --> 05:16.970
比方说有主色

05:16.970 --> 05:20.970
咱们呢 比方说在这里边写了一个定内

05:20.970 --> 05:21.970
定内

05:21.970 --> 05:23.970
我这里写没写定内啊

05:23.970 --> 05:25.970
好像没有写

05:25.970 --> 05:28.860
定内

05:28.860 --> 05:31.860
比方说

05:31.860 --> 05:33.860
写了定内的

05:33.860 --> 05:36.860
定内呢 比方说我们这里写个10秒钟

05:36.860 --> 05:37.860
10秒钟

05:37.860 --> 05:40.860
然后呢 我们这里

05:40.860 --> 05:43.860
就是 FORC 任务完成

05:43.860 --> 05:45.860
就FORC 出来的任务

05:45.860 --> 05:47.860
分岔出来的任务完成了

05:47.860 --> 05:49.860
那么我们来看一下这个效果

05:49.860 --> 05:50.860
保存

05:50.860 --> 05:51.860
你看一下

05:51.860 --> 05:53.860
你看这句话是不是先输出了 对吧

05:53.860 --> 05:54.860
这句话是不是先输出了

05:54.860 --> 05:55.860
说明啥

05:55.860 --> 05:58.860
说明了这个 FORC 它并没有主色

05:58.860 --> 06:00.860
原来的任务

06:00.860 --> 06:02.860
并没有主色原来的任务

06:02.860 --> 06:04.860
这里还是一式运行 对吧

06:04.860 --> 06:05.860
并没有主色原来的任务

06:05.860 --> 06:08.860
那么相当于是新开的一个县城

06:08.860 --> 06:09.860
相当于你可以这样理解

06:09.860 --> 06:11.860
当然你可能不知道县城是啥意思

06:11.860 --> 06:12.860
那没关系

06:12.860 --> 06:14.860
相当于是又多了一个小人

06:14.860 --> 06:15.860
他去完成他的事情

06:15.860 --> 06:16.860
我不管

06:16.860 --> 06:17.860
我不管

06:17.860 --> 06:18.860
他自己去做就行了

06:18.860 --> 06:20.860
他不会主色这里的任务

06:20.860 --> 06:21.860
就是这个意思

06:21.860 --> 06:22.860
那么这里呢

06:22.860 --> 06:24.860
他就完成他自己的就行了

06:24.860 --> 06:25.860
那么你看

06:25.860 --> 06:26.860
10秒钟过后呢

06:26.860 --> 06:27.860
他输出了 FORC 任务完成

06:27.860 --> 06:28.860
就他去主色他自己的

06:28.860 --> 06:30.860
跟我没什么关系

06:30.860 --> 06:31.860
就是 FORC

06:31.860 --> 06:33.860
为什么说这个 FORC

06:33.860 --> 06:34.860
它很有用的

06:34.860 --> 06:36.860
不是说我们在平时开发中

06:36.860 --> 06:37.860
经常要用它

06:37.860 --> 06:38.860
我们平时倒是用的

06:38.860 --> 06:39.860
有的时候要用

06:39.860 --> 06:41.860
但是也不是太多

06:41.860 --> 06:43.860
可能用的比较多的是 TAKE AVERY

06:43.860 --> 06:45.860
只是这个 FORC 这个东西

06:45.860 --> 06:47.860
它在内部

06:47.860 --> 06:49.860
实现的时候经常会用到 FORC

06:49.860 --> 06:51.860
比方说 TAKE AVERY

06:51.860 --> 06:53.860
它不是要监听吗

06:53.860 --> 06:54.860
它为什么

06:54.860 --> 06:56.860
它不是要监听这个玩意吗

06:56.860 --> 06:59.860
它凭什么就是没有

06:59.860 --> 07:00.860
没有主

07:00.860 --> 07:02.860
就是没有主色

07:02.860 --> 07:04.860
没有主色它是怎么来做到监听的呢

07:04.860 --> 07:05.860
监听不是要主色吗

07:05.860 --> 07:06.860
TAKE不是要主色吗

07:06.860 --> 07:08.860
它就是通过 FORC 来完成的

07:08.860 --> 07:09.860
你可以这样认为

07:09.860 --> 07:10.860
它就是通过 FORC 来完成的

07:10.860 --> 07:12.860
它FORC 的一个东西

07:12.860 --> 07:13.860
一个东西

07:13.860 --> 07:15.860
然后在这里

07:15.860 --> 07:16.860
在这里比方说我们要监听

07:16.860 --> 07:17.860
监听啥呢

07:17.860 --> 07:18.860
监听这个 INCREASE

07:18.860 --> 07:19.860
我们就这样写

07:19.860 --> 07:21.860
WILE2

07:21.860 --> 07:22.860
WILE2

07:22.860 --> 07:23.860
Yield

07:23.860 --> 07:24.860
TAKE

07:24.860 --> 07:25.860
TAKE不是我们之前学过的

07:25.860 --> 07:26.860
对吧

07:26.860 --> 07:27.860
就是监听

07:27.860 --> 07:29.860
这个是要主色式监听

07:29.860 --> 07:30.860
监听什么呢

07:30.860 --> 07:31.860
监听 INCREASE

07:31.860 --> 07:32.860
AXY Type

07:32.860 --> 07:34.860
INCREASE

07:34.860 --> 07:35.860
监听这个

07:35.860 --> 07:36.860
拿到一个 AXY

07:36.860 --> 07:38.860
拿到一个 AXY

07:38.860 --> 07:39.860
对吧

07:39.860 --> 07:40.860
当我们监听到这个的时候

07:40.860 --> 07:41.860
它是不是要主色

07:41.860 --> 07:42.860
对吧

07:42.860 --> 07:43.860
运行到这儿

07:43.860 --> 07:44.860
它要停住

07:44.860 --> 07:45.860
等待 AXY 到来

07:45.860 --> 07:47.860
这应该是 ASYNC INCREASE

07:47.860 --> 07:49.860
等待这个 AXY 到来

07:49.860 --> 07:51.860
拿到这个 AXY 之后呢

07:51.860 --> 07:52.860
我们干嘛

07:52.860 --> 07:53.860
我们干嘛

07:53.860 --> 07:54.860
是不是拿到这个 AXY 过后

07:54.860 --> 07:56.860
我们要把这个 AXY

07:56.860 --> 07:57.860
我们要干嘛

07:57.860 --> 07:59.860
我们要创建一个 INCREASE

07:59.860 --> 08:00.860
这个 AXY

08:00.860 --> 08:01.860
然后把它铺直进去

08:01.860 --> 08:02.860
我们抵内嘛

08:02.860 --> 08:03.860
先抵内

08:03.860 --> 08:04.860
抵内

08:04.860 --> 08:05.860
比方说

08:05.860 --> 08:06.860
两秒钟

08:06.860 --> 08:07.860
两秒钟

08:08.860 --> 08:09.860
这里一有的

08:09.860 --> 08:11.860
然后我们 PUT

08:11.860 --> 08:12.860
INCREASE

08:12.860 --> 08:13.860
创建这么一个 AXY

08:13.860 --> 08:14.860
把它铺直进去

08:14.860 --> 08:15.860
然后干嘛

08:15.860 --> 08:16.860
再监听

08:16.860 --> 08:17.860
对吧

08:17.860 --> 08:18.860
再监听

08:18.860 --> 08:19.860
就这么个意思

08:19.860 --> 08:20.860
就这么个意思

08:21.860 --> 08:22.860
明白这个意思吗

08:22.860 --> 08:23.860
保存

08:23.860 --> 08:24.860
保存

08:24.860 --> 08:25.860
比方说我们现在呢

08:25.860 --> 08:26.860
看一下

08:26.860 --> 08:27.860
看一下

08:28.860 --> 08:29.860
ASYNC

08:32.860 --> 08:34.860
ASYNC INCREASE

08:35.860 --> 08:36.860
你看一下

08:36.860 --> 08:37.860
两秒钟之后

08:37.860 --> 08:38.860
触发这个

08:38.860 --> 08:39.860
触发这个

08:41.860 --> 08:43.860
两秒钟之后

08:44.860 --> 08:45.860
对了

08:45.860 --> 08:47.860
ASYNC INCREASE

08:48.860 --> 08:49.860
FORK

08:53.490 --> 08:54.490
这里两秒钟之后

08:54.490 --> 08:56.490
为什么没有触发呢

08:56.490 --> 08:57.490
我再刷新一下

08:57.490 --> 08:58.490
刷新一下

08:58.490 --> 08:59.490
再来

08:59.490 --> 09:00.490
INCREASE

09:00.490 --> 09:01.490
两秒钟之后

09:01.490 --> 09:05.250
它要触发一个 INCREASE

09:05.250 --> 09:07.250
它没有触发是吧

09:07.250 --> 09:08.250
它没有触发

09:08.250 --> 09:09.250
咱们这里输出一句话

09:09.250 --> 09:10.250
输出一句话

09:10.250 --> 09:12.250
关键是看它有没有监听到

09:12.250 --> 09:14.250
有没有监听到这一块

09:14.250 --> 09:16.250
这里我们输出一个

09:16.250 --> 09:17.250
随便输出一个

09:18.250 --> 09:19.250
试一下

09:19.250 --> 09:20.250
为什么没有监听到了

09:20.250 --> 09:22.250
这里说明监听到了

09:22.250 --> 09:24.250
这里说明监听到了

09:24.250 --> 09:25.250
然后地内

09:25.250 --> 09:26.250
2000

09:27.250 --> 09:28.250
2000

09:28.250 --> 09:31.250
然后我们PUT INCREASE

09:31.250 --> 09:32.250
没问题

09:33.250 --> 09:35.750
没问题

09:35.750 --> 09:36.750
PUT INCREASE

09:36.750 --> 09:38.750
那为什么日子里面没打印出来了

09:39.750 --> 09:40.750
我想想

09:41.750 --> 09:42.750
这一句话运行的

09:42.750 --> 09:44.750
那么我们放到下面了

09:44.750 --> 09:48.190
放到这个地内下面了

09:48.190 --> 09:50.190
感觉好像没有触发一样

09:50.190 --> 09:51.190
两秒钟之后

09:51.190 --> 09:52.190
触发了

09:53.190 --> 09:54.190
触发了

09:57.630 --> 09:58.630
想想

09:58.630 --> 09:59.630
是怎么回事

10:02.630 --> 10:03.630
像这种错误

10:03.630 --> 10:04.630
我也经常犯

10:04.630 --> 10:05.630
所以大家一定要注意

10:05.630 --> 10:07.630
指令前面一定要加EO

10:07.630 --> 10:08.630
一定要加EO

10:10.630 --> 10:11.630
再来

10:11.630 --> 10:12.630
两秒钟之后

10:12.630 --> 10:13.630
触发一个新

10:13.630 --> 10:14.630
增加了

10:14.630 --> 10:15.630
增加了

10:15.630 --> 10:18.630
这其实就是TAKER AVERY的实现

10:18.630 --> 10:19.630
TAKER AVERY的实现

10:19.630 --> 10:21.630
它没有组设原来的任务

10:21.630 --> 10:24.630
但是它内部新开了一个分支

10:24.630 --> 10:25.630
来去组设任务

10:25.630 --> 10:26.630
来去进行一个新的任务

10:26.630 --> 10:28.630
那么那个任务里边去组设

10:28.630 --> 10:30.630
跟外面的任务是没有什么关系的

10:31.630 --> 10:32.630
这是

10:32.630 --> 10:33.630
就是这种实现

10:33.630 --> 10:34.630
但是这样子实现的

10:34.630 --> 10:36.630
是不是

10:36.630 --> 10:38.630
是不是一定正确的

10:38.630 --> 10:40.630
来对比一下DECRASE

10:41.630 --> 10:42.630
DECRASE

10:42.630 --> 10:44.630
我们调用AsyncDECRASE

10:44.630 --> 10:45.630
看着

10:45.630 --> 10:46.630
我们这样子

10:46.630 --> 10:47.630
调用三次

10:48.630 --> 10:49.630
你看

10:50.630 --> 10:51.630
隔一段时间过

10:51.630 --> 10:52.630
它是不是应循了DECRASE

10:52.630 --> 10:53.630
触发DECRASE三次

10:54.630 --> 10:55.630
我们调用了三次

10:55.630 --> 10:57.630
触发三个AsyncDECRASE

10:57.630 --> 10:58.630
那么到时候

10:58.630 --> 10:59.630
它会三次

10:59.630 --> 11:00.630
时间到了

11:00.630 --> 11:01.630
每一次它会独立运行

11:01.630 --> 11:02.630
时间到了过

11:02.630 --> 11:03.630
它会触发三次DECRASE

11:03.630 --> 11:04.630
看到没

11:04.630 --> 11:06.630
触发三次DECRASE

11:06.630 --> 11:08.630
那么现在我们运行AsyncDECRASE

11:08.630 --> 11:10.630
看一下会不会这样子

11:10.630 --> 11:12.630
一次两次三次

11:13.630 --> 11:14.630
你会发现

11:14.630 --> 11:16.630
它只运行一次DECRASE

11:16.630 --> 11:17.630
为什么

11:17.630 --> 11:20.630
为什么会只运行一次DECRASE

11:20.630 --> 11:21.630
因为你想

11:21.630 --> 11:22.630
我们这里

11:22.630 --> 11:23.630
监听什么

11:23.630 --> 11:24.630
监听AsyncDECRASE

11:24.630 --> 11:25.630
对吧

11:25.630 --> 11:26.630
监听AsyncDECRASE

11:27.630 --> 11:28.630
那么第一次

11:28.630 --> 11:29.630
监听到了对吧

11:29.630 --> 11:30.630
监听到了

11:30.630 --> 11:31.630
监听到了过后

11:31.630 --> 11:32.630
它要延迟两秒钟等待

11:32.630 --> 11:33.630
监听

11:33.630 --> 11:34.630
因为这个taker

11:34.630 --> 11:35.630
监听是不是只监听一次

11:35.630 --> 11:36.630
对吧

11:36.630 --> 11:37.630
它只监听一次

11:37.630 --> 11:39.630
那么监听到了过后

11:39.630 --> 11:40.630
监听到了过后

11:40.630 --> 11:42.630
那么它就把之前的监听

11:42.630 --> 11:43.630
就删除掉了

11:43.630 --> 11:44.630
这是一个订阅发布模式

11:44.630 --> 11:46.630
我们之前也自己写过元代

11:46.630 --> 11:47.630
就说

11:47.630 --> 11:48.630
它先订阅一个

11:48.630 --> 11:50.630
我只要触发了这个X

11:50.630 --> 11:51.630
那么我就会运行

11:51.630 --> 11:52.630
继续运行

11:52.630 --> 11:53.630
那么

11:53.630 --> 11:54.630
继续运行的时候

11:54.630 --> 11:55.630
我先等待两秒

11:55.630 --> 11:56.630
那等待在过程中

11:56.630 --> 11:57.630
如果说我又去触发了

11:57.630 --> 11:58.630
你看我又去触发了

11:58.630 --> 12:00.630
AsyncDECRASE

12:00.630 --> 12:01.630
我又去触发这个

12:02.630 --> 12:04.630
又去触发这个的时候

12:04.630 --> 12:05.630
触发了两次

12:05.630 --> 12:06.630
那么这个时候还能不能监听到

12:06.630 --> 12:07.630
没有

12:07.630 --> 12:08.630
因为它没有在监听了

12:08.630 --> 12:09.630
明白这个意思吗

12:09.630 --> 12:10.630
它之前的监听已经结束了

12:10.630 --> 12:11.630
它不再监听了

12:11.630 --> 12:13.630
它只监听一次taker

12:13.630 --> 12:14.630
那么后边

12:14.630 --> 12:15.630
等待的过程中

12:15.630 --> 12:16.630
如果你再触发

12:16.630 --> 12:17.630
它没有监听到

12:17.630 --> 12:18.630
所以说它不会再运行了

12:18.630 --> 12:19.630
于是

12:19.630 --> 12:20.630
两秒钟之后

12:20.630 --> 12:21.630
它只会运行到这

12:21.630 --> 12:22.630
然后下一次循环

12:22.630 --> 12:23.630
再等两秒钟之后

12:23.630 --> 12:24.630
再回去监听

12:24.630 --> 12:25.630
对吧

12:25.630 --> 12:26.630
它是这么一种模式

12:26.630 --> 12:27.630
这么一种模式

12:27.630 --> 12:28.630
那如果我们要实现

12:28.630 --> 12:29.630
DECRASE的效果

12:29.630 --> 12:30.630
如果说不用takerEvery

12:30.630 --> 12:31.630
用fork

12:31.630 --> 12:32.630
来实现DECRASE效果

12:32.630 --> 12:33.630
能不能实现

12:34.630 --> 12:35.630
可以

12:35.630 --> 12:36.630
我们在这个地方

12:36.630 --> 12:38.630
再写一个fork

12:38.630 --> 12:40.630
再写一个fork

12:40.630 --> 12:41.630
因为fork

12:41.630 --> 12:42.630
它不会主色

12:42.630 --> 12:43.630
对不对

12:43.630 --> 12:44.630
它不会主色

12:44.630 --> 12:45.630
所以说你去运行你的

12:45.630 --> 12:47.630
我再开一个任务

12:47.630 --> 12:48.630
都可以写个匿名函数

12:48.630 --> 12:49.630
对吧

12:49.630 --> 12:50.630
可以写个匿名函数

12:50.630 --> 12:51.630
匿名函数

12:51.630 --> 12:52.630
只要你是生存器

12:52.630 --> 12:53.630
因为它这里边传

12:53.630 --> 12:54.630
传的不就是个生存器

12:54.630 --> 12:55.630
单独写个函数

12:55.630 --> 12:56.630
和在这里写个匿名函数

12:56.630 --> 12:57.630
有啥区别

12:57.630 --> 12:59.630
我们这里

12:59.630 --> 13:00.630
放这

13:01.630 --> 13:02.630
你看一下

13:02.630 --> 13:03.630
现在就不会出问题了

13:03.630 --> 13:04.630
先听完了过后

13:04.630 --> 13:05.630
马上fork一个新任务

13:05.630 --> 13:06.630
你去做

13:06.630 --> 13:07.630
我不管了

13:07.630 --> 13:08.630
你去做吧

13:08.630 --> 13:09.630
马上就下一次循环

13:09.630 --> 13:10.630
马上又监听了

13:10.630 --> 13:11.630
对吧

13:11.630 --> 13:12.630
马上又监听下一个

13:12.630 --> 13:13.630
对不对

13:13.630 --> 13:14.630
那么这一块

13:14.630 --> 13:15.630
就新开了一个任务出来

13:15.630 --> 13:16.630
我又fork了一个新任务

13:16.630 --> 13:17.630
fork相当于是一个分支

13:17.630 --> 13:18.630
我们可以这样理解

13:18.630 --> 13:21.630
我们的总体的任务线

13:21.630 --> 13:23.630
主任务线在这

13:23.630 --> 13:24.630
主任务线在这

13:26.630 --> 13:28.630
什么叫主色呢

13:28.630 --> 13:29.630
主色的是

13:29.630 --> 13:31.630
当前这条任务线

13:31.630 --> 13:32.630
比如说

13:32.630 --> 13:33.630
某一个东西卡在中间

13:33.630 --> 13:34.630
要等

13:34.630 --> 13:35.630
要等一段时间

13:35.630 --> 13:36.630
这叫主色

13:36.630 --> 13:37.630
这叫主色

13:39.630 --> 13:41.630
主色的是当前这条任务线

13:41.630 --> 13:42.630
那么停在这了

13:42.630 --> 13:43.630
不再运行了

13:43.630 --> 13:44.630
等一会实际成熟的时候

13:44.630 --> 13:45.630
我们再继续往后面运行

13:45.630 --> 13:46.630
这叫主色

13:47.630 --> 13:48.630
那么fork的作用是什么呢

13:48.630 --> 13:49.630
fork的作用就是

13:49.630 --> 13:51.630
新开了一个任务线

13:52.630 --> 13:54.630
新开了一个任务线

13:54.630 --> 13:56.630
就指的是这个意思

13:56.630 --> 13:58.630
它不会影响主任务的运行

13:58.630 --> 13:59.630
然后呢

13:59.630 --> 14:01.630
如果说你在新任务线上

14:01.630 --> 14:02.630
进行主色的话

14:02.630 --> 14:03.630
主色的是新任务线

14:04.630 --> 14:06.630
如果说你在新任务线上去主色

14:06.630 --> 14:07.630
主色的是新任务线

14:08.630 --> 14:09.630
比方说这里

14:09.630 --> 14:10.630
peck不是要主色吗

14:10.630 --> 14:11.630
主色的是谁

14:11.630 --> 14:12.630
主色的是这个新任务线

14:12.630 --> 14:14.630
等待x型到来

14:14.630 --> 14:15.630
对不对

14:15.630 --> 14:16.630
x型来了过后

14:16.630 --> 14:17.630
是不是解除主色了

14:17.630 --> 14:18.630
继续运行

14:18.630 --> 14:19.630
继续运行

14:19.630 --> 14:20.630
我们之前呢

14:20.630 --> 14:21.630
我们之前是这样的写的

14:21.630 --> 14:22.630
之前是这样的写的

14:22.630 --> 14:24.630
那么之前是把主色写到哪的

14:25.630 --> 14:26.630
这是监听主色吗

14:26.630 --> 14:27.630
比方说

14:27.630 --> 14:28.630
监听主色

14:28.630 --> 14:29.630
那么这里新

14:29.630 --> 14:30.630
刚才写的

14:30.630 --> 14:31.630
刚才的写法是

14:31.630 --> 14:32.630
在这里

14:32.630 --> 14:33.630
delay主色

14:33.630 --> 14:34.630
是写到这的

14:34.630 --> 14:36.630
由于监听主色已经完成了

14:36.630 --> 14:37.630
那么它是不是没有在监听了

14:37.630 --> 14:38.630
对吧

14:38.630 --> 14:39.630
那如果在delay的主色期间

14:39.630 --> 14:40.630
我们又去触发

14:40.630 --> 14:41.630
这个x型

14:41.630 --> 14:42.630
是不是监听不到了

14:42.630 --> 14:44.630
之前的监听已经结束了

14:44.630 --> 14:45.630
对不对

14:45.630 --> 14:46.630
监听已经结束了

14:46.630 --> 14:47.630
那么我们这里的做法

14:47.630 --> 14:48.630
把它写成下面那种做法

14:48.630 --> 14:49.630
是怎么回事呢

14:49.630 --> 14:51.630
就是我又在这个任务线上

14:51.630 --> 14:52.630
又开了一个任务

14:52.630 --> 14:57.100
又开了一个任务

14:57.100 --> 14:59.100
这个图没有画得很好

14:59.100 --> 15:00.100
应该是一个折线画过来

15:00.100 --> 15:01.100
这样最舒服的

15:01.100 --> 15:02.100
算了

15:02.100 --> 15:04.540
我画标准点

15:04.540 --> 15:05.540
真的是强迫症

15:05.540 --> 15:06.540
我也受不了

15:06.540 --> 15:12.960
这里要不要画标准点

15:12.960 --> 15:14.960
这里拿一条线下来

15:14.960 --> 15:25.410
这里一条线

15:25.410 --> 15:26.410
那么现在的我们

15:26.410 --> 15:28.410
现在的做法是这样子的

15:28.410 --> 15:29.410
监听主色在这里

15:29.410 --> 15:30.410
进行主色

15:30.410 --> 15:31.410
对吧

15:31.410 --> 15:32.410
在这里进行主色

15:32.410 --> 15:33.410
并且它是一个死循环

15:33.410 --> 15:34.410
它是一个死循环

15:34.410 --> 15:35.410
什么意思呢

15:35.410 --> 15:37.410
就是监听完了过后

15:37.410 --> 15:38.410
监听完了过后

15:38.410 --> 15:39.410
那么它又会主色监听

15:39.410 --> 15:40.410
对吧

15:41.410 --> 15:42.410
你看

15:42.410 --> 15:43.410
它在这里

15:43.410 --> 15:44.410
不断的去进行监听

15:44.410 --> 15:45.410
对不对

15:45.410 --> 15:46.410
不断的去进行监听

15:46.410 --> 15:48.410
我们可以再从这里开始

15:48.410 --> 15:53.510
就这样子

15:53.510 --> 15:55.510
它是不断的进行监听的

16:00.620 --> 16:01.620
就这样吧

16:01.620 --> 16:02.620
它不断的进行监听

16:02.620 --> 16:04.620
那么如果监听完了过后

16:04.620 --> 16:05.620
监听完了过后

16:05.620 --> 16:06.620
它又开了一个新任务

16:06.620 --> 16:08.620
又开了一个新任务

16:08.620 --> 16:09.620
所以这条线

16:09.620 --> 16:11.620
这条线去主色

16:11.620 --> 16:12.620
每一次监听结束过后

16:12.620 --> 16:14.620
这条又开一个新任务

16:15.620 --> 16:16.620
去主色

16:16.620 --> 16:17.620
地内

16:17.620 --> 16:18.620
地内

16:18.620 --> 16:19.620
两千

16:19.620 --> 16:20.620
去主色

16:20.620 --> 16:21.620
主色完了过后

16:22.620 --> 16:24.620
它现在形成这么一种现象了

16:24.620 --> 16:25.620
其实这才是

16:25.620 --> 16:27.620
take average的实现

16:27.620 --> 16:29.620
它会把我们给的函数

16:29.620 --> 16:30.620
放到这个位置

16:30.620 --> 16:31.620
放到这个位置

16:31.620 --> 16:33.620
因此你了解了这一点

16:33.620 --> 16:34.620
你是不是能够

16:34.620 --> 16:36.620
自己写一个take average出来

16:36.620 --> 16:37.620
对不对

16:37.620 --> 16:38.620
你自己都可以写一个出来

16:38.620 --> 16:40.620
就非常简单

16:40.620 --> 16:41.620
咱们接下来

16:41.620 --> 16:42.620
Essink Increase

16:42.620 --> 16:43.620
让我三次

16:43.620 --> 16:46.120
看一下吧

16:46.120 --> 16:48.120
那么等待了2万多之后

16:48.120 --> 16:50.120
是不是触发了3次increase

16:50.120 --> 16:51.120
对不对

16:51.120 --> 16:52.120
所以其实

16:52.120 --> 16:54.120
take average

16:54.120 --> 16:55.120
它就是这样子实现的

16:55.120 --> 16:57.120
就是用类似的这种方式实现的

16:57.120 --> 16:58.120
咱们到时候讲

16:58.120 --> 16:59.120
原码的分析的时候

16:59.120 --> 17:00.120
会告诉大家

17:00.120 --> 17:02.120
这么来去实现

17:02.120 --> 17:03.120
好 就是这个fork

17:03.120 --> 17:04.120
关于这个fork

17:04.120 --> 17:06.120
我们还有更多的东西要说

17:06.120 --> 17:07.120
因为这个fork

17:07.120 --> 17:09.120
由于它是一个

17:09.120 --> 17:12.120
由于它是一个

17:13.120 --> 17:14.120
非主色的

17:14.120 --> 17:16.120
那么在新的任务线里边

17:16.120 --> 17:17.120
它是会

17:17.120 --> 17:18.120
新的任务线里边

17:18.120 --> 17:19.120
是不是可以主色

17:19.120 --> 17:20.120
它不会主色当前任务线

17:20.120 --> 17:21.120
比方说fork

17:21.120 --> 17:22.120
从这个地位置

17:22.120 --> 17:23.120
开始一个fork

17:23.120 --> 17:24.120
fork就是一个分支

17:24.120 --> 17:25.120
一个分岔路口

17:25.120 --> 17:27.120
那么这里分支一个出来了

17:27.120 --> 17:28.120
从这个地方

17:28.120 --> 17:29.120
我们认为

17:29.120 --> 17:30.120
从这条任务线

17:30.120 --> 17:31.120
fork的一个新任务

17:31.120 --> 17:32.120
对吧

17:32.120 --> 17:33.120
新任务

17:33.120 --> 17:34.120
那么

17:34.120 --> 17:35.120
对于这条任务线而言

17:35.120 --> 17:37.120
那么它是可以随时取消

17:37.120 --> 17:38.120
这个任务的

17:38.120 --> 17:39.120
它是可以做到的

17:39.120 --> 17:41.120
可以随时取消这个任务

17:41.120 --> 17:43.120
你不要去再运行这个任务了

17:43.120 --> 17:45.120
就这么个意思

17:45.120 --> 17:46.120
好

17:46.120 --> 17:47.120
那么比方说

17:47.120 --> 17:50.120
我举个例子

17:50.120 --> 17:52.120
比方说

17:52.120 --> 17:54.120
我们在这里

17:54.120 --> 17:55.120
不是在这里的有

17:55.120 --> 17:56.120
每一次

17:56.120 --> 17:58.120
每一次监听到这个increase的时候

17:58.120 --> 18:00.120
我都要去开启一个新任务嘛

18:00.120 --> 18:01.120
对不对

18:01.120 --> 18:02.120
每一次

18:02.120 --> 18:03.120
每一次标了这里

18:03.120 --> 18:04.120
监听到了一个action

18:04.120 --> 18:06.120
那么我在这条任务线上

18:06.120 --> 18:07.120
去开启一个新的任务

18:07.120 --> 18:08.120
要等待两秒钟

18:08.120 --> 18:09.120
等待两秒钟之后

18:09.120 --> 18:11.120
我们再去做某一些事情

18:11.120 --> 18:12.120
对吧

18:12.120 --> 18:13.120
做某一些事情

18:13.120 --> 18:14.120
好

18:14.120 --> 18:15.120
那么比方说

18:15.120 --> 18:17.120
我们现在的

18:17.120 --> 18:19.120
要实现这么一个需求

18:19.120 --> 18:21.120
就是我每一次

18:21.120 --> 18:23.120
就是有点类似于韩束防斗

18:23.120 --> 18:25.120
我每一次运行

18:25.120 --> 18:27.120
就是监听到一个东西的时候

18:27.120 --> 18:29.120
如果说之前的任务

18:29.120 --> 18:30.120
没有完成

18:30.120 --> 18:33.120
我要把之前的任务取消掉

18:33.120 --> 18:35.120
你之前就不要做了

18:35.120 --> 18:38.120
我只以最后一次为准

18:39.120 --> 18:41.120
你懂我要做什么吗

18:41.120 --> 18:42.120
你懂我的意思吗

18:42.120 --> 18:45.120
就说我只以最后一次为准

18:45.120 --> 18:46.120
有些同学说

18:46.120 --> 18:47.120
那你不用focus了

18:47.120 --> 18:49.120
把这个写上来行不行

18:49.120 --> 18:51.120
它就不是以最后一次为准

18:51.120 --> 18:52.120
它是以第一次为准

18:52.120 --> 18:54.120
是这个意思吧

18:54.120 --> 18:55.120
因为后边的东西

18:55.120 --> 18:56.120
我就监听不到

18:56.120 --> 18:57.120
因为它等待两秒钟之后

18:57.120 --> 18:59.120
等待两秒钟的时候

18:59.120 --> 19:00.120
我不断去触发这个action

19:00.120 --> 19:01.120
它监听不到了

19:01.120 --> 19:04.120
我始终要以最后一次为准

19:04.120 --> 19:05.120
那怎么做呢

19:05.120 --> 19:07.120
比方说像刚才那种情况

19:07.120 --> 19:08.120
我这里触发了三次

19:08.120 --> 19:09.120
是不是就得到三次

19:09.120 --> 19:11.120
那我现在要做的事情就是

19:11.120 --> 19:13.120
那么我在两秒钟之内触发了第三次

19:13.120 --> 19:14.120
触发了三次

19:14.120 --> 19:16.120
那么前两次又被取消掉了

19:16.120 --> 19:17.120
就不要再等了

19:17.120 --> 19:18.120
就不用管了

19:18.120 --> 19:19.120
那么就取消掉

19:19.120 --> 19:21.120
那么这个东西怎么来完成的

19:21.120 --> 19:23.120
首先你要知道focus的东西

19:23.120 --> 19:25.120
它返回了一个对象

19:27.120 --> 19:31.120
focus返回了一个对象

19:31.120 --> 19:33.120
这个对象的类型

19:33.120 --> 19:35.120
类型为task

19:35.120 --> 19:36.120
一个任务对象

19:36.120 --> 19:38.120
这个task这是个构造函数

19:38.120 --> 19:40.120
只要我们自己不会用

19:40.120 --> 19:42.120
是那个

19:43.120 --> 19:45.120
那个撒杆内部的一个构造函数

19:45.120 --> 19:46.120
task

19:46.120 --> 19:49.120
返回了一个任务对象

19:49.120 --> 19:51.120
那么这个任务对象是可以被取消的

19:51.120 --> 19:53.120
它怎么被取消呢

19:53.120 --> 19:55.120
就通过cancel这个函数

19:55.120 --> 19:56.120
这个指令

19:56.120 --> 19:58.120
那么这个指令用来做什么呢

19:58.120 --> 20:03.120
用于取消一个或多个任务

20:03.120 --> 20:05.120
就是我们分岔的任务

20:05.120 --> 20:06.120
分岔的任务呢

20:06.120 --> 20:08.120
可以被主任务所取消

20:08.120 --> 20:10.120
比方说我们在这一块分岔的一个任务

20:10.120 --> 20:11.120
对吧

20:11.120 --> 20:13.120
因为才从这个分支上产生的任务

20:13.120 --> 20:16.120
那么可以被这个分支所取消

20:16.120 --> 20:18.120
那么咱们来看一下这个代码

20:18.120 --> 20:20.120
说可以预见到

20:20.120 --> 20:22.120
这个撒杆是非常非常强大的

20:22.120 --> 20:24.120
它还有一个任务管理系统

20:24.120 --> 20:26.120
那么这里呢

20:26.120 --> 20:27.120
我们focus了一个任务

20:27.120 --> 20:28.120
每一次监听了一过后

20:28.120 --> 20:30.120
我们就focus了一个任务

20:30.120 --> 20:31.120
focus任务的时候

20:31.120 --> 20:33.120
我要把之前的任务取消掉

20:33.120 --> 20:35.120
这样子的才能保证

20:35.120 --> 20:37.120
永远是运行的我这一次最新的任务

20:37.120 --> 20:39.120
之前的任务我就把它取消掉了

20:39.120 --> 20:40.120
当然你如果说

20:40.120 --> 20:42.120
如果说之前的任务已经完成了

20:42.120 --> 20:43.120
那就无所谓了

20:43.120 --> 20:44.120
如果说你还没有完成

20:44.120 --> 20:45.120
ok 你不要完成了

20:45.120 --> 20:46.120
我给你取消掉

20:46.120 --> 20:47.120
就这么个意思

20:47.120 --> 20:50.120
那么比方说我们这里呢

20:50.120 --> 20:53.120
写上这么一个函数

20:53.120 --> 20:55.120
写上这么一个变量

20:55.120 --> 20:57.120
let's task

20:57.120 --> 21:00.120
我们每一次在分支的时候

21:00.120 --> 21:02.120
分支一个任务的时候

21:02.120 --> 21:04.120
给它复职

21:04.120 --> 21:06.120
因为它会反回一个任务对象

21:06.120 --> 21:08.120
对吧 会反回一个任务对象

21:08.120 --> 21:12.120
然后我每一次监听到了请求过后

21:12.120 --> 21:15.120
在我监听到了请求

21:15.120 --> 21:16.120
监听

21:16.120 --> 21:17.120
不是请求

21:17.120 --> 21:18.120
老实说请求

21:18.120 --> 21:21.120
监听到了x

21:21.120 --> 21:30.120
并且在开启新任务之前

21:30.120 --> 21:31.120
监听到了x

21:31.120 --> 21:33.120
然后开启新任务之前

21:33.120 --> 21:35.120
我要把之前的任务取消掉

21:35.120 --> 21:38.120
取消之前的任务

21:38.120 --> 21:40.120
好 那么这里怎么写呢

21:40.120 --> 21:42.120
判断一下

21:42.120 --> 21:45.120
我们这里呢

21:45.120 --> 21:48.120
判断就是task有没有值

21:48.120 --> 21:50.120
主要是看它是不是第一次

21:50.120 --> 21:51.120
如果task有值的话

21:51.120 --> 21:54.120
表示之前有任务对吧

21:54.120 --> 21:56.120
之前有任务

21:56.120 --> 21:59.120
好 之前有任务的话

21:59.120 --> 22:00.120
我们就取消任务

22:00.120 --> 22:01.120
怎么取消

22:01.120 --> 22:03.120
使用指令cancel

22:03.120 --> 22:05.120
使用指令cancel

22:05.120 --> 22:09.120
好 我们用eo的cancel

22:09.120 --> 22:10.120
cancel

22:10.120 --> 22:12.120
把这个task传进去

22:12.120 --> 22:13.120
它可以传多个任务

22:13.120 --> 22:15.120
如果说你要取消多个任务的话

22:15.120 --> 22:17.120
你在这里t2 t3

22:17.120 --> 22:18.120
離世传进就行了

22:18.120 --> 22:21.120
如果你说你有多个任务对象的话

22:21.120 --> 22:22.120
那么行了

22:22.120 --> 22:23.120
我们这里输出一句

22:23.120 --> 22:24.120
输出一句

22:24.120 --> 22:28.120
之前的任务被取消掉了

22:28.120 --> 22:30.120
保存看一下吧

22:30.120 --> 22:36.140
我们这里还是运行多个

22:36.140 --> 22:38.140
那么你会发现最终只运行了一个

22:38.140 --> 22:39.140
对吧 只运行了一个

22:39.140 --> 22:41.140
因为每一次运行过后了

22:41.140 --> 22:42.140
之前的任务都被取消掉了

22:42.140 --> 22:43.140
之前的任务都被取消掉了

22:43.140 --> 22:45.140
那么它不会再运行了

22:45.140 --> 22:46.140
那么这个取消

22:46.140 --> 22:48.140
好像感觉很神奇的样子

22:48.140 --> 22:50.140
实际上取消的本质是什么呢

22:50.140 --> 22:52.140
你可以拆一下

22:52.140 --> 22:54.140
能不能想象得到

22:54.140 --> 22:57.640
取消它是怎么做的

22:57.640 --> 23:00.640
实际上

23:00.640 --> 23:04.640
取消的实现原理

23:04.640 --> 23:09.640
是利用generator的return

23:09.640 --> 23:10.640
对不对

23:10.640 --> 23:11.640
马上结束

23:11.640 --> 23:13.640
因为它之前不是在eo的那个位置

23:13.640 --> 23:14.640
在等着吗

23:14.640 --> 23:15.640
对不对

23:15.640 --> 23:16.640
之前有可能是任务在eo的那个位置

23:16.640 --> 23:18.640
等着等待下一次那个时候调用

23:18.640 --> 23:19.640
然后呢

23:19.640 --> 23:20.640
马上把取消掉

23:20.640 --> 23:21.640
就是取消就是

23:21.640 --> 23:22.640
把之前那个地方

23:22.640 --> 23:24.640
找到之前那个generator

23:24.640 --> 23:25.640
该调用return

23:25.640 --> 23:26.640
那么下一次再调用那个时候

23:26.640 --> 23:27.640
是不是不会往后面运行的

23:27.640 --> 23:28.640
就已经结束了

23:28.640 --> 23:29.640
对吧

23:29.640 --> 23:30.640
后面都不会再运行的

23:30.640 --> 23:31.640
对吧

23:31.640 --> 23:32.640
是这个意思

23:32.640 --> 23:33.640
它不是说

23:33.640 --> 23:35.640
你这个代码可能运行到一半

23:35.640 --> 23:37.640
比方说这里还有一些计算

23:37.640 --> 23:38.640
不是

23:39.640 --> 23:40.640
比方说这里还有一些计算

23:40.640 --> 23:41.640
还有一些输出

23:41.640 --> 23:44.640
不是说你代码运行到一半

23:44.640 --> 23:46.640
比方说运行到这个1加2

23:46.640 --> 23:47.640
1加22

23:47.640 --> 23:48.640
运行到这

23:48.640 --> 23:49.640
运行到这一下

23:49.640 --> 23:50.640
突然给你取消掉了

23:50.640 --> 23:51.640
不运行的

23:51.640 --> 23:52.640
不是这个意思

23:52.640 --> 23:53.640
它是在eo的位置

23:53.640 --> 23:54.640
比方说这个任务

23:54.640 --> 23:55.640
在eo的位置被阻塞了

23:55.640 --> 23:56.640
正在等待

23:56.640 --> 23:57.640
正在等待

23:58.640 --> 23:59.640
那么这个时候

23:59.640 --> 24:00.640
突然运行了一个cancel

24:00.640 --> 24:02.640
外面突然运行了个cancel

24:02.640 --> 24:04.640
那么它就会把这个generator找到

24:04.640 --> 24:07.640
就这个

24:07.640 --> 24:08.640
它的generator找到

24:08.640 --> 24:10.640
然后调用return

24:10.640 --> 24:11.640
把这个任务给你取消掉

24:11.640 --> 24:13.640
它是用这种模式来做的

24:14.640 --> 24:15.640
因为它这个函数

24:15.640 --> 24:16.640
会返回一个generator

24:16.640 --> 24:17.640
对吧

24:17.640 --> 24:18.640
它把这个generator找到

24:18.640 --> 24:20.640
然后给你调用return

24:20.640 --> 24:21.640
把这个任务给你取消掉

24:21.640 --> 24:23.640
那么哪怕你后来

24:23.640 --> 24:24.640
这个地内完成了

24:24.640 --> 24:25.640
再调用那个时候

24:25.640 --> 24:26.640
是不是已经没东西了

24:26.640 --> 24:27.640
对不对

24:27.640 --> 24:28.640
那个事情

24:28.640 --> 24:29.640
因为之前return了

24:29.640 --> 24:30.640
已经没东西了

24:30.640 --> 24:32.640
就这么个意思

24:32.640 --> 24:34.640
好就是关于取消任务

24:34.640 --> 24:36.640
关于取消任务

24:36.640 --> 24:37.640
因此我们这里

24:37.640 --> 24:39.640
要不然再来一个例子

24:39.640 --> 24:40.640
再来一个例子

24:40.640 --> 24:42.640
这个例子的话

24:42.640 --> 24:45.640
我们来实现这么一个效果吧

24:45.640 --> 24:47.640
比方说x里面

24:47.640 --> 24:48.640
counter里面

24:48.640 --> 24:50.640
我们再来一个x

24:50.640 --> 24:52.640
这个x

24:52.640 --> 24:54.640
叫做outto

24:54.640 --> 24:55.640
outtoincrease

24:56.640 --> 24:58.640
叫做outtoincrease

24:58.640 --> 24:59.640
自动增加

24:59.640 --> 25:00.640
自动增加

25:00.640 --> 25:02.640
这边我们写个symbol

25:02.640 --> 25:04.640
outtoincrease

25:04.640 --> 25:08.850
自动增加

25:08.850 --> 25:10.850
然后我们再来一个就是

25:12.850 --> 25:13.850
stop

25:13.850 --> 25:16.850
outtoincrease

25:16.850 --> 25:18.850
停止自动增加

25:20.850 --> 25:22.850
stop

25:22.850 --> 25:24.850
outtoincrease

25:24.850 --> 25:26.850
你会发现连这些逻辑上的事情

25:26.850 --> 25:27.850
本来说

25:27.850 --> 25:29.850
这些事情肯定要用setting

25:29.850 --> 25:30.850
towel那些东西来做

25:30.850 --> 25:31.850
停止计时器

25:31.850 --> 25:32.850
也计动计时器等等

25:32.850 --> 25:34.850
是要用那些东西来做

25:34.850 --> 25:35.850
你会发现

25:35.850 --> 25:36.850
这些东西其实跟界面

25:36.850 --> 25:37.850
没有什么关系

25:37.850 --> 25:39.850
你不应该放到react里面

25:39.850 --> 25:41.850
us只管界面

25:41.850 --> 25:42.850
这些东西saga

25:42.850 --> 25:43.850
还可以帮你处理

25:43.850 --> 25:45.850
帮你处理这些数据逻辑

25:45.850 --> 25:46.850
那么这里

25:46.850 --> 25:47.850
就停止

25:48.850 --> 25:49.850
自动增加

25:50.850 --> 25:51.850
你想一想

25:51.850 --> 25:52.850
没有saga你这个事情怎么做

25:52.850 --> 25:54.850
你会发现不是很好做

25:54.850 --> 25:55.850
不是很好做

25:55.850 --> 25:56.850
是融入不到react时器

25:56.850 --> 25:57.850
结构里面来

25:57.850 --> 25:58.850
但是有了saga过后

25:58.850 --> 25:59.850
在saga里面就可以处理了

25:59.850 --> 26:01.850
这里能不能返回

26:01.850 --> 26:03.850
导出一个函数

26:03.850 --> 26:05.850
导出一个action

26:05.850 --> 26:06.850
创建函数

26:06.850 --> 26:09.850
outtoincrease

26:09.850 --> 26:10.850
return

26:10.850 --> 26:11.850
tab

26:12.850 --> 26:13.850
当然每次这样写也挺烦的

26:13.850 --> 26:14.850
我们后面会讲一个酷

26:14.850 --> 26:16.850
它会给你

26:16.850 --> 26:17.850
更加方便的去写

26:17.850 --> 26:18.850
这个action和action

26:18.850 --> 26:19.850
创建函数

26:22.850 --> 26:23.850
因为我为什么一开始

26:23.850 --> 26:24.850
不讲这个酷

26:24.850 --> 26:25.850
是为了让大家

26:25.850 --> 26:26.850
先熟悉这种邪法

26:26.850 --> 26:27.850
先不要

26:27.850 --> 26:28.850
就像以前

26:28.850 --> 26:30.850
我们以后的公司里边

26:30.850 --> 26:31.850
还会真正的去操作

26:31.850 --> 26:32.850
原生的动物

26:32.850 --> 26:33.850
不太会了

26:33.850 --> 26:34.850
但是我们为什么要学习

26:34.850 --> 26:36.850
这个东西必须要先熟悉

26:37.850 --> 26:38.850
stop

26:38.850 --> 26:39.850
outtoincrease

26:39.850 --> 26:40.850
那么这里

26:40.850 --> 26:42.850
自动增加停止自动增加

26:42.850 --> 26:44.850
那么通过它来创建一个action

26:44.850 --> 26:45.850
然后到这边来

26:45.850 --> 26:46.850
看着

26:46.850 --> 26:47.850
我们现在把这个复制一下

26:47.850 --> 26:48.850
重新来一个

26:49.850 --> 26:50.850
increase

26:51.850 --> 26:52.850
increase的话

26:52.850 --> 26:53.850
还是用之前的吗

26:54.850 --> 26:55.850
还是用之前的

26:57.850 --> 26:58.850
increase

27:01.610 --> 27:02.610
increase

27:03.610 --> 27:04.610
那么用这个方式

27:05.610 --> 27:07.610
然后我们再

27:08.610 --> 27:09.610
把这个复制一下

27:11.610 --> 27:12.610
increase

27:14.610 --> 27:15.610
increase

27:15.610 --> 27:17.610
这里写上increase

27:22.430 --> 27:23.430
对了

27:24.430 --> 27:26.430
前面有重复了

27:28.870 --> 27:30.870
我们还原到最开始的场景

27:30.870 --> 27:31.870
还原到最开始的场景

27:31.870 --> 27:33.870
然后现在我们多监听一个action

27:34.870 --> 27:35.870
多监听一个action

27:35.870 --> 27:36.870
就前面两个不管

27:36.870 --> 27:37.870
跟我们没什么关系

27:37.870 --> 27:38.870
多监听一个

27:38.870 --> 27:40.870
或者是前两个不想去干扰我们了

27:40.870 --> 27:41.870
不想说他们干扰了

27:42.870 --> 27:43.870
再写一个

27:44.870 --> 27:45.870
这里要的一个什么呢

27:45.870 --> 27:46.870
我们要

27:46.870 --> 27:47.870
take every

27:47.870 --> 27:50.870
当我们得到一个action types

27:50.870 --> 27:52.870
为什么outtoincrease的时候

27:53.870 --> 27:55.870
我们去运行一个生成器

27:56.870 --> 27:57.870
一个生成器

27:57.870 --> 27:58.870
就叫做outtoincrease

28:00.870 --> 28:01.870
写过来

28:02.870 --> 28:03.870
我们去运行生成器

28:03.870 --> 28:05.870
我们先写一个最简单的

28:05.870 --> 28:06.870
生成器做什么呢

28:08.870 --> 28:09.870
一个使循环

28:10.870 --> 28:12.870
然后每隔一段时间

28:12.870 --> 28:13.870
定内

28:13.870 --> 28:15.870
每隔一段时间

28:15.870 --> 28:17.870
隔两秒钟

28:17.870 --> 28:18.870
每隔两秒钟

28:18.870 --> 28:19.870
然后干嘛呢

28:19.870 --> 28:21.870
去增加一个

28:21.870 --> 28:23.870
去触发一个action

28:23.870 --> 28:24.870
put increase

28:24.870 --> 28:26.870
去触发一个action

28:26.870 --> 28:27.870
这个decrease标了

28:28.870 --> 28:29.870
我们先写到这吧

28:29.870 --> 28:30.870
先写到这

28:30.870 --> 28:31.870
好 咱们来看一下

28:31.870 --> 28:33.870
目前这样子写

28:33.870 --> 28:35.870
会不会有什么样的问题

28:35.870 --> 28:36.870
我们现在呢

28:36.870 --> 28:37.870
正在监听

28:37.870 --> 28:38.870
这些不是async

28:38.870 --> 28:41.870
监听的是outtoincrease

28:42.870 --> 28:43.870
正在监听这个

28:44.870 --> 28:45.870
正在监听outtoincrease

28:45.870 --> 28:47.870
好 那么我们在tester里边

28:47.870 --> 28:48.870
给它加上

28:48.870 --> 28:49.870
还是按了惯例

28:49.870 --> 28:51.870
加上一个outtoincrease

28:51.870 --> 28:52.870
这里呢

28:52.870 --> 28:54.870
我们加上一个outtoincrease

28:54.870 --> 28:56.870
然后再顺便再加上一个

28:56.870 --> 28:57.870
一会肯定要停止嘛

28:57.870 --> 28:59.870
stop outtoincrease

28:59.870 --> 29:00.870
加上这两个

29:01.870 --> 29:02.870
window里边

29:02.870 --> 29:04.870
outtoincrease

29:04.870 --> 29:05.870
方式

29:06.870 --> 29:07.870
store

29:07.870 --> 29:08.870
dispatch

29:08.870 --> 29:09.870
触发一个action

29:09.870 --> 29:11.870
outtoincrease

29:11.870 --> 29:12.870
同样的

29:12.870 --> 29:13.870
window里边

29:13.870 --> 29:14.870
再加上一个stop

29:14.870 --> 29:16.870
outtoincrease

29:16.870 --> 29:17.870
方式

29:17.870 --> 29:18.870
store

29:18.870 --> 29:19.870
dispatch

29:20.870 --> 29:23.870
就是stop outtoincrease

29:24.870 --> 29:25.870
好 行了 保存

29:26.870 --> 29:27.870
看一下

29:27.870 --> 29:29.870
咱们呢 先在这里

29:29.870 --> 29:30.870
我们先触发

29:30.870 --> 29:34.870
就是outtoincrease

29:34.870 --> 29:35.870
运行

29:35.870 --> 29:36.870
你看一下

29:36.870 --> 29:37.870
每隔两秒钟

29:37.870 --> 29:38.870
是不是增加了一个数字

29:38.870 --> 29:39.870
你看

29:39.870 --> 29:40.870
每隔两秒钟

29:40.870 --> 29:41.870
增加一个

29:41.870 --> 29:42.870
就开始启动了

29:42.870 --> 29:43.870
对不对

29:43.870 --> 29:44.870
好 那么现在这一块

29:44.870 --> 29:45.870
有没有问题呢

29:45.870 --> 29:46.870
这样子做

29:46.870 --> 29:47.870
会不会有问题呢

29:47.870 --> 29:48.870
那么肯定是有问题的

29:48.870 --> 29:50.870
为什么会有问题呢

29:50.870 --> 29:52.870
如果说我们再来启动一个outtoincrease

29:52.870 --> 29:54.870
再来启动一个

29:54.870 --> 29:55.870
你看一下

29:55.870 --> 29:56.870
它就会越来越多了

29:56.870 --> 29:57.870
对吧 越来越多了

29:57.870 --> 29:58.870
因为之前的任务

29:58.870 --> 29:59.870
是不是没有停止

29:59.870 --> 30:00.870
对吧 之前的任务

30:00.870 --> 30:01.870
就一直在

30:01.870 --> 30:03.870
那你想想这个逻辑

30:03.870 --> 30:04.870
那么这里呢

30:04.870 --> 30:05.870
我们使用take average

30:05.870 --> 30:06.870
比方说

30:06.870 --> 30:07.870
咱们在这里

30:07.870 --> 30:08.870
为什么会出现这种情况

30:08.870 --> 30:11.870
这里给大家看一下这个意志

30:11.870 --> 30:13.870
我们在这里take average

30:13.870 --> 30:15.870
使用了一个take average

30:15.870 --> 30:17.870
那么它的作用就是

30:17.870 --> 30:19.870
每一次监听过后

30:19.870 --> 30:20.870
它会启动一个任务

30:20.870 --> 30:21.870
就是我们的生存器

30:21.870 --> 30:22.870
那么当我们第一次

30:22.870 --> 30:24.870
调用outtoincrease的时候

30:24.870 --> 30:26.870
启动了一个

30:26.870 --> 30:29.870
我们在这里使用了一个take average

30:29.870 --> 30:31.870
那么第一次outtoincrease

30:31.870 --> 30:33.870
outtoincrease的时候

30:33.870 --> 30:34.870
是不是启动一个任务

30:34.870 --> 30:35.870
它会进行一个使循环

30:35.870 --> 30:36.870
对吧

30:36.870 --> 30:37.870
它在这个调任务线上

30:37.870 --> 30:38.870
不断的去改变

30:38.870 --> 30:40.870
不断去增加数字

30:40.870 --> 30:41.870
那一会儿呢

30:41.870 --> 30:42.870
我们又调用了一次outtoincrease

30:42.870 --> 30:44.870
是不是又启动了一个任务线

30:44.870 --> 30:45.870
对不对

30:45.870 --> 30:47.870
所以又启动了一个任务线

30:47.870 --> 30:48.870
是这个意思吧

30:48.870 --> 30:50.870
它又跟我们启动了一个任务线

30:50.870 --> 30:52.870
因为我们第二次调用的时候

30:52.870 --> 30:54.870
又要调用outtoincrease

30:54.870 --> 30:55.870
那一组

30:55.870 --> 30:56.870
比如说

30:56.870 --> 30:57.870
那我们这样子行不行

30:57.870 --> 30:58.870
为了避免这种情况

30:58.870 --> 31:00.870
我把之前那个任务取消掉

31:00.870 --> 31:01.870
但是你在这里

31:01.870 --> 31:04.870
你是拿不到之前那个任务对象的

31:04.870 --> 31:05.870
你拿不到

31:05.870 --> 31:07.870
你在这个地方outtoincrease

31:07.870 --> 31:08.870
你要拿到之前

31:08.870 --> 31:09.870
那个任务的任务对象

31:09.870 --> 31:11.870
你拿不到的

31:11.870 --> 31:12.870
你拿不到的

31:12.870 --> 31:13.870
所以说你这一块

31:13.870 --> 31:14.870
你也没法

31:14.870 --> 31:15.870
也不好处理

31:15.870 --> 31:16.870
也不好处理

31:18.870 --> 31:19.870
那怎么办呢

31:19.870 --> 31:20.870
实际上

31:20.870 --> 31:21.870
实际上它是这样子

31:21.870 --> 31:22.870
其实我这个图呢

31:22.870 --> 31:25.870
都还没有画得那么的就是

31:25.870 --> 31:27.870
那么的就是完美

31:27.870 --> 31:28.870
它其实是这个样子的

31:28.870 --> 31:29.870
take every

31:29.870 --> 31:31.870
它会开启一个新任务

31:31.870 --> 31:32.870
take every

31:32.870 --> 31:34.870
会开启一个新任务

31:34.870 --> 31:36.870
这是take every的新任务

31:36.870 --> 31:38.870
这是take every的新任务

31:38.870 --> 31:39.870
然后每一次

31:39.870 --> 31:41.870
每一次那个x型到来的时候

31:41.870 --> 31:44.870
它会在这条任务线上

31:44.870 --> 31:45.870
这条任务线上

31:45.870 --> 31:46.870
给你开启一个新任务

31:46.870 --> 31:47.870
它是这么回事

31:47.870 --> 31:50.870
每一次这个take every

31:50.870 --> 31:51.870
到来的时候

31:51.870 --> 31:52.870
它会在这条任务线上

31:52.870 --> 31:54.870
给你开启一个新任务

31:54.870 --> 31:56.870
比较第一次调用outtoincrease

31:56.870 --> 31:57.870
outtoincrease

31:57.870 --> 31:58.870
对吧

31:58.870 --> 31:59.870
它是在这条线上

31:59.870 --> 32:00.870
给你开启一个新任务

32:00.870 --> 32:01.870
它是这么玩的

32:01.870 --> 32:02.870
对吧

32:02.870 --> 32:03.870
你可以拿到这个take every

32:03.870 --> 32:04.870
这个没问题

32:04.870 --> 32:07.870
你可以拿到这个take every的任务

32:07.870 --> 32:08.870
这个没问题

32:08.870 --> 32:09.870
这个任务在哪呢

32:09.870 --> 32:10.870
这个任务在这

32:10.870 --> 32:11.870
就在这个take every的时候

32:11.870 --> 32:12.870
它会给你返回一个任务

32:12.870 --> 32:13.870
不过这个任务

32:13.870 --> 32:14.870
我们拿这个任务

32:14.870 --> 32:16.870
目前对我们也没有什么用

32:16.870 --> 32:17.870
明白这个意思吗

32:17.870 --> 32:18.870
我们去拿这个任务

32:18.870 --> 32:19.870
这条任务线

32:19.870 --> 32:20.870
我们要取消这个任务吗

32:20.870 --> 32:21.870
也不是

32:21.870 --> 32:22.870
取消这个任务

32:22.870 --> 32:23.870
它就什么都不会监听的

32:23.870 --> 32:24.870
什么都不会监听的

32:24.870 --> 32:25.870
比方说

32:25.870 --> 32:26.870
那比方说吧

32:26.870 --> 32:27.870
我们就真的

32:27.870 --> 32:29.870
我们就真的去取消这个任务

32:29.870 --> 32:31.870
我们在这里定一个辨量

32:31.870 --> 32:32.870
task

32:32.870 --> 32:33.870
那比方说

32:33.870 --> 32:34.870
我们在这里去

32:34.870 --> 32:36.870
真的去取消这个任务

32:36.870 --> 32:38.870
就是

32:38.870 --> 32:39.870
我们使用cancel

32:39.870 --> 32:41.870
去取消这个任务

32:41.870 --> 32:43.870
我们要判断一下

32:43.870 --> 32:44.870
这个任务是不是存在

32:44.870 --> 32:45.870
如果是存在的话

32:45.870 --> 32:46.870
我们去取消这个任务

32:46.870 --> 32:48.870
如果说我们去取消这个任务的话

32:48.870 --> 32:49.870
问题很重了

32:49.870 --> 32:50.870
这里还要复制

32:50.870 --> 32:52.870
这个take every

32:52.870 --> 32:53.870
它会返回一个任务

32:53.870 --> 32:54.870
因为我们刚才说了

32:54.870 --> 32:55.870
这个take every

32:55.870 --> 32:57.870
它就是利用fork来实现的

32:57.870 --> 33:00.870
它返回的就是一个fork

33:00.870 --> 33:03.870
要不然我把take every

33:03.870 --> 33:06.870
这个原代码给大家写一下吧

33:06.870 --> 33:08.870
它写给大家写一下

33:08.870 --> 33:10.870
原代码也非常非常简单

33:10.870 --> 33:12.870
这个take every是怎么回事呢

33:12.870 --> 33:13.870
take every是这样子

33:13.870 --> 33:15.870
它是这么一个函数

33:15.870 --> 33:16.870
我们这里写一下吧

33:16.870 --> 33:17.870
我们不用它那个take every

33:17.870 --> 33:19.870
我们自己写一个take every

33:19.870 --> 33:21.870
就非常非常简单这个函数

33:21.870 --> 33:23.870
这个函数里边

33:23.870 --> 33:24.870
要接受两个参数嘛

33:24.870 --> 33:25.870
对吧

33:25.870 --> 33:26.870
一个是action type

33:26.870 --> 33:27.870
对吧

33:27.870 --> 33:28.870
action type

33:28.870 --> 33:29.870
action type

33:29.870 --> 33:31.870
一个是那个什么

33:31.870 --> 33:32.870
一个是saga

33:32.870 --> 33:33.870
对吧

33:33.870 --> 33:34.870
一个就是generator一个函数

33:34.870 --> 33:35.870
第一个参数就是一个函数

33:35.870 --> 33:36.870
对不对

33:36.870 --> 33:37.870
就是take every的写法

33:37.870 --> 33:39.870
它返回的是什么呢

33:39.870 --> 33:40.870
返回的就是一个fork

33:40.870 --> 33:42.870
它其实就是利用一个fork

33:42.870 --> 33:43.870
就是利用一个fork

33:43.870 --> 33:44.870
fork什么呢

33:44.870 --> 33:47.870
fork一个函数

33:47.870 --> 33:50.870
返回的就是fork

33:50.870 --> 33:52.870
fork返回的是啥

33:52.870 --> 33:54.870
fork返回的是啥

33:54.870 --> 33:57.870
返回的不就是最终的一个task对象吧

33:57.870 --> 33:59.870
最终会返回一个task对象

33:59.870 --> 34:00.870
对吧

34:00.870 --> 34:01.870
它这里返回的是fork

34:01.870 --> 34:02.870
于是你这里调用take every

34:02.870 --> 34:04.870
是不是就相当于是在这里写了一个fork

34:04.870 --> 34:05.870
对吧

34:05.870 --> 34:07.870
相当于是在这里写了一个fork

34:07.870 --> 34:08.870
那么这个fork里边

34:08.870 --> 34:09.870
我们之前说过

34:09.870 --> 34:11.870
这个fork里边怎么写的呢

34:11.870 --> 34:12.870
这个fork里边

34:12.870 --> 34:14.870
fork里边不是一个while true嘛

34:14.870 --> 34:15.870
对不对

34:15.870 --> 34:16.870
然后这里是什么take

34:16.870 --> 34:17.870
对吧

34:17.870 --> 34:18.870
take

34:18.870 --> 34:20.870
take是什么action type

34:20.870 --> 34:21.870
action type

34:21.870 --> 34:23.870
这里用 yield

34:23.870 --> 34:24.870
take action type

34:24.870 --> 34:25.870
那么这里呢

34:25.870 --> 34:26.870
会得到一个action

34:26.870 --> 34:28.870
会得到一个action对象

34:28.870 --> 34:29.870
然后呢

34:29.870 --> 34:30.870
我们之前是不是写过那个时代嘛

34:30.870 --> 34:32.870
然后在这里再fork一个

34:32.870 --> 34:34.870
再fork一个

34:35.870 --> 34:36.870
你看吧

34:36.870 --> 34:37.870
你看吧

34:37.870 --> 34:38.870
我们这个take every

34:38.870 --> 34:39.870
是不是在这里

34:39.870 --> 34:40.870
形成了一个新的任务线

34:40.870 --> 34:41.870
对吧

34:41.870 --> 34:43.870
形成了这么一个新的任务线

34:43.870 --> 34:45.870
是这个意思吧

34:45.870 --> 34:47.870
我们在这里take every

34:47.870 --> 34:48.870
在这里是不是形成一个新的任务线

34:48.870 --> 34:50.870
这个新的任务线是谁创建的

34:50.870 --> 34:51.870
是不是这个fork创建的

34:51.870 --> 34:52.870
对不对

34:52.870 --> 34:54.870
这个fork创建的一个新的任务

34:54.870 --> 34:55.870
它这里返回一个fork嘛

34:55.870 --> 34:56.870
这个fork在干嘛

34:56.870 --> 34:58.870
它在不断的监听

34:58.870 --> 34:59.870
你给定了一个action type

34:59.870 --> 35:01.870
不断的监听这个

35:01.870 --> 35:02.870
一旦监听拿到过后

35:02.870 --> 35:04.870
然后又去触发一个任务

35:04.870 --> 35:05.870
对吧

35:05.870 --> 35:06.870
然后监听到了

35:06.870 --> 35:07.870
监听到了什么

35:07.870 --> 35:08.870
out to increase

35:08.870 --> 35:10.870
于是又去开启一个新的任务

35:10.870 --> 35:11.870
又去开启一个新的任务

35:11.870 --> 35:13.870
就这么个意思

35:13.870 --> 35:15.870
又去开启一个新的任务

35:15.870 --> 35:16.870
在这个新的任务里边

35:16.870 --> 35:18.870
去调用你这个函数

35:18.870 --> 35:20.870
去调用你这个函数

35:20.870 --> 35:22.870
就这么个意思

35:22.870 --> 35:23.870
明白的意思吗

35:23.870 --> 35:24.870
去调用这个函数

35:24.870 --> 35:26.870
它会直接把这个函数传到这儿来

35:26.870 --> 35:27.870
你可以这样理解

35:27.870 --> 35:29.870
它会直接把你这个函数传到这儿来

35:29.870 --> 35:31.870
这就是你在新

35:31.870 --> 35:32.870
我们自己的函数

35:32.870 --> 35:33.870
是在这里边

35:33.870 --> 35:34.870
是在这个任务里边

35:34.870 --> 35:36.870
就是我们写的一个out to increase

35:36.870 --> 35:37.870
它是在这个

35:37.870 --> 35:38.870
它的分支任务里边

35:38.870 --> 35:39.870
它监听到了一个

35:39.870 --> 35:40.870
就开启一个新的任务

35:40.870 --> 35:42.870
监听到一个就开启一个新的任务

35:42.870 --> 35:44.870
就是take an average的写法

35:44.870 --> 35:45.870
对吧

35:45.870 --> 35:47.870
那么不管我们是不是

35:47.870 --> 35:48.870
我们自己写的

35:48.870 --> 35:49.870
其实都无所谓

35:49.870 --> 35:50.870
它自己就是这样子写的

35:50.870 --> 35:51.870
就是这样子写的

35:51.870 --> 35:52.870
以后我们

35:52.870 --> 35:53.870
演示完成过后

35:53.870 --> 35:54.870
我们就用自己的代码

35:54.870 --> 35:55.870
看一看吧

35:55.870 --> 35:57.870
也就是一样的

35:57.870 --> 35:58.870
然后我们这里

35:58.870 --> 36:00.870
还是用它的take an average

36:00.870 --> 36:01.870
它有些同学不相信

36:01.870 --> 36:02.870
说我自己在这里瞎写

36:02.870 --> 36:03.870
我这里就用它的

36:03.870 --> 36:04.870
就用它的

36:04.870 --> 36:06.870
那么现在我们你看一下

36:06.870 --> 36:07.870
如果说我们用这种方式取消

36:07.870 --> 36:08.870
这里要用eO的

36:08.870 --> 36:11.870
eO的来取消

36:11.870 --> 36:13.870
我们这里还是用这种判断

36:13.870 --> 36:14.870
它不允许的这样写

36:14.870 --> 36:19.870
task eO的cancel

36:19.870 --> 36:21.870
task把个任务取消

36:21.870 --> 36:23.870
我们这里为了测试方便

36:23.870 --> 36:26.870
我们在这里输出一句话

36:26.870 --> 36:28.870
监听到了

36:28.870 --> 36:29.870
监听到了

36:30.870 --> 36:31.870
那么接下来

36:31.870 --> 36:33.870
看大家有没有理解

36:33.870 --> 36:35.870
整个这个过程

36:35.870 --> 36:37.870
首先这句话

36:37.870 --> 36:38.870
会不会输出

36:38.870 --> 36:39.870
当我们触发一个

36:39.870 --> 36:41.870
out to increase的时候

36:41.870 --> 36:43.870
这句话会不会输出

36:43.870 --> 36:47.310
你看这张图

36:47.310 --> 36:48.310
take an average

36:48.310 --> 36:49.310
它会分拆一个任务

36:49.310 --> 36:50.310
就是fork一个任务

36:50.310 --> 36:51.310
出来

36:51.310 --> 36:52.310
在这个任务上去监听

36:52.310 --> 36:54.310
只要监听到一个

36:54.310 --> 36:56.310
它去运行out to increase

36:56.310 --> 36:58.310
那么我们在out to increase

36:58.310 --> 37:00.310
的时候取消的是谁

37:01.310 --> 37:02.310
取消的是谁

37:02.310 --> 37:03.310
是不是这个任务

37:03.310 --> 37:04.310
对吧

37:04.310 --> 37:05.310
取消的是这条任务线

37:05.310 --> 37:06.310
好

37:06.310 --> 37:07.310
咱们来看一下

37:09.310 --> 37:12.310
现在我们运行out to increase

37:12.310 --> 37:13.310
运行

37:13.310 --> 37:15.310
是不是这条任务线没问题

37:15.310 --> 37:16.310
为什么没问题

37:16.310 --> 37:17.310
你看着

37:17.310 --> 37:18.310
看这个图

37:18.310 --> 37:19.310
我再比方说

37:19.310 --> 37:21.310
第一次运行out to increase

37:21.310 --> 37:24.310
第一次运行out to increase的时候

37:24.310 --> 37:26.310
运行到它的时候

37:26.310 --> 37:29.310
我们把这条任务线取消掉了

37:30.310 --> 37:31.310
你看这去带

37:31.310 --> 37:33.310
在运行它的时候

37:33.310 --> 37:34.310
因为我们之前

37:34.310 --> 37:35.310
接受到的是什么

37:35.310 --> 37:37.310
take an average的任务线

37:37.310 --> 37:38.310
那么于是

37:38.310 --> 37:39.310
你看take an average

37:39.310 --> 37:41.310
是不是返回了这个监听的任务

37:41.310 --> 37:43.310
那么它会取消谁

37:43.310 --> 37:45.310
它会取消的是

37:45.310 --> 37:46.310
取消的是这条

37:46.310 --> 37:47.310
刚才的一条任务线

37:47.310 --> 37:48.310
就这条任务线

37:48.310 --> 37:49.310
对吧

37:49.310 --> 37:50.310
那么这条任务线

37:50.310 --> 37:51.310
是在做什么

37:51.310 --> 37:52.310
是在做监听的

37:52.310 --> 37:53.310
那么这条任务线取消了

37:53.310 --> 37:54.310
那么自己的任务线

37:54.310 --> 37:55.310
有没有取消

37:55.310 --> 37:56.310
并没有取消

37:56.310 --> 37:57.310
并没有取消

37:57.310 --> 37:58.310
不是说

37:59.310 --> 38:00.310
那么自己的任务线

38:00.310 --> 38:01.310
没有取消

38:01.310 --> 38:02.310
那么自己的任务线

38:02.310 --> 38:03.310
里面是不是接着运行

38:03.310 --> 38:04.310
对吧

38:04.310 --> 38:05.310
运行

38:05.310 --> 38:06.310
然后运行了

38:06.310 --> 38:07.310
说出了这句话

38:07.310 --> 38:08.310
那么任务是不是结束了

38:08.310 --> 38:09.310
任务结束了

38:09.310 --> 38:10.310
你不用你取消

38:10.310 --> 38:11.310
它自然都没了

38:11.310 --> 38:12.310
任务已经结束了

38:12.310 --> 38:13.310
运行完了

38:13.310 --> 38:14.310
对不对

38:14.310 --> 38:15.310
你又没有写死循环

38:15.310 --> 38:16.310
运行完了

38:16.310 --> 38:17.310
好

38:17.310 --> 38:18.310
那么这样子一来

38:18.310 --> 38:20.310
下一次你运行out to increase

38:20.310 --> 38:22.310
还会有监听吗

38:22.310 --> 38:24.310
是没有监听的

38:24.310 --> 38:25.310
你看一下

38:25.310 --> 38:26.310
监听到了out to increase

38:26.310 --> 38:27.310
是不是不存在

38:27.310 --> 38:28.310
这句话了

38:28.310 --> 38:30.310
是不再有监听了

38:30.310 --> 38:31.310
是这个意思吧

38:31.310 --> 38:32.310
因为你把监听的

38:32.310 --> 38:34.310
take average这条任务线

38:34.310 --> 38:36.310
给你它取消掉了

38:36.310 --> 38:38.310
这是我们想要的吗

38:38.310 --> 38:39.310
不是

38:39.310 --> 38:40.310
不然的话

38:40.310 --> 38:41.310
到时候比方说

38:41.310 --> 38:42.310
到时候会暂停

38:42.310 --> 38:43.310
会停止

38:43.310 --> 38:44.310
但是停止了过后

38:44.310 --> 38:45.310
我到时候可能以后

38:45.310 --> 38:46.310
还会再启动

38:46.310 --> 38:47.310
那我还能启动吗

38:47.310 --> 38:49.310
是不是启动不了了

38:49.310 --> 38:50.310
对吧

38:50.310 --> 38:51.310
是不是这个意思

38:51.310 --> 38:52.310
是启动不了了

38:52.310 --> 38:54.310
因此我们不能去取消

38:54.310 --> 38:55.310
这条任务线

38:55.310 --> 38:56.310
我们应该取消什么

38:56.310 --> 38:58.310
比方说我们监听到了一个过后

38:58.310 --> 39:00.310
我们是不是应该去取消

39:00.310 --> 39:02.310
比方说我们运行到第二次

39:02.310 --> 39:03.310
第二次的out to increase

39:03.310 --> 39:04.310
我们是不是要取消

39:04.310 --> 39:06.310
之前的那个任务线

39:06.310 --> 39:07.310
是这个意思吧

39:07.310 --> 39:08.310
我们是要取消

39:08.310 --> 39:10.310
之前的那个任务线

39:10.310 --> 39:12.310
而不是取消谁

39:12.310 --> 39:14.310
而不是取消那个

39:14.310 --> 39:17.310
take average的任务线

39:17.310 --> 39:19.310
所以这种心理不理解原理

39:19.310 --> 39:20.310
你都是蒙的

39:20.310 --> 39:21.310
你知道吗

39:21.310 --> 39:22.310
你都是蒙的

39:22.310 --> 39:23.310
所以你要取消的是

39:23.310 --> 39:25.310
之前的那个任务线

39:25.310 --> 39:27.310
但是之前的那个任务线

39:27.310 --> 39:29.310
你能得到吗

39:29.310 --> 39:31.310
你能得到之前的那个任务线

39:31.310 --> 39:32.310
我问你

39:32.310 --> 39:33.310
之前的那个任务线

39:33.310 --> 39:34.310
他有没有给你

39:34.310 --> 39:36.310
你看他通过这个fork来创建了

39:36.310 --> 39:38.310
fork你给他传了一个函数

39:38.310 --> 39:40.310
他创建了一个新的任务线

39:40.310 --> 39:41.310
之前的那个任务线

39:41.310 --> 39:43.310
是不是拿不到

39:43.310 --> 39:44.310
是不是拿不到

39:44.310 --> 39:46.310
是这个意思吧

39:46.310 --> 39:48.310
你拿不到之前的那个任务线

39:48.310 --> 39:50.310
问题是怎么办了

39:50.310 --> 39:51.310
这个时候

39:51.310 --> 39:52.310
怎么办了

39:52.310 --> 39:53.310
这个时候

39:53.310 --> 39:56.310
你就不能用他的take average了

39:56.310 --> 39:57.310
你就不能用了

39:57.310 --> 39:59.310
因为用这个take average的模式

39:59.310 --> 40:01.310
就已经造成了麻烦

40:01.310 --> 40:04.310
因为你拿不到之前的那个任务线了

40:04.310 --> 40:05.310
明白这个意思吗

40:05.310 --> 40:06.310
你拿不到了

40:06.310 --> 40:08.310
所以就会遇到一些麻烦

40:08.310 --> 40:09.310
当然你如果说

40:09.310 --> 40:11.310
强行用take average的也行

40:11.310 --> 40:12.310
得想一些办法

40:12.310 --> 40:13.310
得想一些办法

40:13.310 --> 40:14.310
只不过那样的代码

40:14.310 --> 40:16.310
写出来了更加复杂

40:16.310 --> 40:17.310
更加复杂

40:17.310 --> 40:19.310
我就不想去写那样的代码了

40:19.310 --> 40:21.310
不想去写了

40:21.310 --> 40:23.310
现在我们要做什么事情呢

40:23.310 --> 40:25.310
现在我们这样子来

40:25.310 --> 40:27.310
我们自己写folk

40:27.310 --> 40:29.310
自己写folk

40:29.310 --> 40:32.310
我们在这里写个folk

40:32.310 --> 40:33.310
运行什么呢

40:33.310 --> 40:35.310
out to increase

40:35.310 --> 40:37.310
还是运行这个

40:37.310 --> 40:38.310
自己写个folk

40:38.310 --> 40:39.310
那么现在呢

40:39.310 --> 40:41.310
我们就开了一个分支

40:41.310 --> 40:42.310
开了一个分支

40:42.310 --> 40:43.310
叫out to increase

40:43.310 --> 40:45.310
这么一个分支

40:45.310 --> 40:48.940
这个分支用来干嘛的

40:48.940 --> 40:50.940
它是用来监听的

40:50.940 --> 40:52.940
我们就不在意那什么

40:52.940 --> 40:54.940
我们就不再去写这个

40:54.940 --> 40:55.940
take average

40:55.940 --> 40:57.940
当然写take average也能办到

40:57.940 --> 40:59.940
只不过稍微有点麻烦

40:59.940 --> 41:01.940
那么这个图我都不好画了

41:01.940 --> 41:02.940
到时候

41:02.940 --> 41:03.940
我们这里

41:03.940 --> 41:05.940
总之理解原理过后

41:05.940 --> 41:06.940
你就能够想到很多办法

41:06.940 --> 41:08.940
这里肯定不是一种解决方案

41:08.940 --> 41:10.940
我们这里写上这个

41:10.940 --> 41:11.940
folk

41:11.940 --> 41:12.940
一个out to increase

41:12.940 --> 41:14.940
创造这么一个out to increase

41:14.940 --> 41:15.940
过后

41:15.940 --> 41:16.940
把这个声音先去掉

41:16.940 --> 41:17.940
在这里

41:17.940 --> 41:19.940
我们手动着去完成监听

41:19.940 --> 41:21.940
监听

41:21.940 --> 41:24.320
监听

41:24.320 --> 41:25.320
监听什么呢

41:25.320 --> 41:27.320
eod take

41:27.320 --> 41:29.320
监听一个action

41:29.320 --> 41:30.320
taps

41:30.320 --> 41:31.320
out to increase

41:31.320 --> 41:32.320
监听这个action

41:32.320 --> 41:34.320
我们在这里进行监听

41:34.320 --> 41:35.320
主色对不对

41:35.320 --> 41:36.320
主色监听

41:36.320 --> 41:38.320
我们在这里进行主色监听

41:38.320 --> 41:41.140
在这里

41:41.140 --> 41:43.140
进行主色监听

41:43.140 --> 41:45.710
监听我们的action

41:45.710 --> 41:46.710
监听谁

41:46.710 --> 41:47.710
就是监听这个

41:47.710 --> 41:49.710
一旦监听到了

41:49.710 --> 41:51.710
我干嘛呢

41:51.710 --> 41:53.710
我在这里

41:53.710 --> 41:55.710
手动的去启动一个新的任务线

41:55.710 --> 41:56.710
来负责

41:56.710 --> 41:57.710
来负责做什么

41:57.710 --> 41:59.710
来负责不断增加

41:59.710 --> 42:01.710
手动的去

42:01.710 --> 42:04.710
去产生一个新的任务线

42:04.710 --> 42:06.710
如果说一旦监听到了

42:06.710 --> 42:08.710
我们手动的去产生一个新的任务线

42:08.710 --> 42:09.710
来负责

42:09.710 --> 42:10.710
就是

42:10.710 --> 42:12.710
给它不断的加数字

42:12.710 --> 42:13.710
不断的加数字

42:13.710 --> 42:14.710
监听完成了

42:14.710 --> 42:15.710
但是

42:15.710 --> 42:17.710
因为我开的是新的任务线

42:17.710 --> 42:18.710
所以说他这里

42:18.710 --> 42:20.710
又会不断的去监听下一个

42:20.710 --> 42:22.710
又会不断的去监听下一个

42:22.710 --> 42:23.710
对吧

42:23.710 --> 42:24.710
监听到了过后

42:24.710 --> 42:25.710
我们干嘛

42:25.710 --> 42:26.710
我们是不是

42:26.710 --> 42:27.710
fork一个

42:27.710 --> 42:29.710
又来fork一个

42:29.710 --> 42:30.710
我们去手动去

42:30.710 --> 42:33.710
之前的模式是一样的

42:33.710 --> 42:35.710
新号

42:35.710 --> 42:37.710
开启一个新的任务线

42:37.710 --> 42:38.710
在这个任务线里面

42:38.710 --> 42:39.710
我们写上一个while2

42:39.710 --> 42:40.710
while2

42:40.710 --> 42:41.710
当然你也可以

42:41.710 --> 42:42.710
再写个函数也行

42:42.710 --> 42:44.710
在这个任务线里面

42:44.710 --> 42:45.710
我们负责

42:45.710 --> 42:46.710
要的

42:46.710 --> 42:48.710
delay

42:48.710 --> 42:49.710
delay

42:49.710 --> 42:50.710
两秒钟

42:50.710 --> 42:51.710
两秒钟之后

42:51.710 --> 42:53.710
put increase

42:53.710 --> 42:54.710
增加一个

42:54.710 --> 42:55.710
对吧

42:55.710 --> 42:56.710
这样子

42:56.710 --> 42:57.710
我们是不是完全

42:57.710 --> 42:58.710
跟take every

42:58.710 --> 42:59.710
一样的模式

42:59.710 --> 43:00.710
一样的模式

43:00.710 --> 43:01.710
但是

43:01.710 --> 43:02.710
由于我们是自己手写代

43:02.710 --> 43:04.710
我们自己可以完全控制

43:04.710 --> 43:05.710
你看一下

43:05.710 --> 43:07.710
out to increase

43:07.710 --> 43:09.710
两秒钟之后

43:12.710 --> 43:14.710
哪个地方没写对

43:14.710 --> 43:15.710
哪个地方

43:15.710 --> 43:19.470
这里又忘了写意义了

43:19.470 --> 43:20.470
out to increase

43:20.470 --> 43:21.470
看着

43:21.470 --> 43:22.470
两秒钟之后

43:22.470 --> 43:23.470
增加

43:23.470 --> 43:24.470
两秒钟增加一次

43:24.470 --> 43:25.470
两秒钟增加一次

43:25.470 --> 43:26.470
对吧

43:26.470 --> 43:27.470
增加一次

43:27.470 --> 43:28.470
那么现在为了

43:28.470 --> 43:30.470
避免反复的去增加

43:30.470 --> 43:31.470
因为为什么

43:31.470 --> 43:32.470
因为现在它仍然在坚定

43:32.470 --> 43:33.470
对吧

43:33.470 --> 43:34.470
一会又坚定到同样的

43:34.470 --> 43:35.470
一个形式

43:35.470 --> 43:36.470
又要启动一个任务线

43:36.470 --> 43:37.470
对吧

43:37.470 --> 43:38.470
又要启动一个任务线

43:38.470 --> 43:39.470
对不对

43:39.470 --> 43:40.470
那么为了

43:40.470 --> 43:41.470
避免重复的去

43:41.470 --> 43:43.470
重复的去做这件事情

43:43.470 --> 43:45.470
每一次启动这个任务线的时候

43:45.470 --> 43:46.470
之前的

43:46.470 --> 43:47.470
我要把之前的任务线

43:47.470 --> 43:48.470
取消掉

43:48.470 --> 43:49.470
我们刚才写过这样的代码

43:49.470 --> 43:50.470
对吧

43:50.470 --> 43:51.470
我们在这里

43:51.470 --> 43:52.470
订一个变量

43:52.470 --> 43:53.470
let's task

43:53.470 --> 43:54.470
订这么一个变量

43:54.470 --> 43:55.470
好

43:55.470 --> 43:56.470
那么我们这里

43:56.470 --> 43:57.470
给这个变量负责

43:57.470 --> 43:58.470
那这里判断一下

43:58.470 --> 43:59.470
如果说你之前

43:59.470 --> 44:00.470
还有任务的话

44:00.470 --> 44:01.470
那么我把之前的任务

44:01.470 --> 44:02.470
给你取消掉

44:02.470 --> 44:04.470
cancel task

44:04.470 --> 44:05.470
对吧

44:05.470 --> 44:06.470
取消掉之前的任务

44:06.470 --> 44:08.470
就这么简单

44:08.470 --> 44:09.470
就这么简单

44:09.470 --> 44:10.470
保存

44:10.470 --> 44:11.470
你看一下

44:11.470 --> 44:12.470
保存看一下

44:12.470 --> 44:14.470
那么现在呢

44:14.470 --> 44:15.470
你再看

44:15.470 --> 44:16.470
好

44:16.470 --> 44:17.470
那么现在呢

44:17.470 --> 44:18.470
我们看这里

44:18.470 --> 44:19.470
out to increase

44:19.470 --> 44:20.470
增加

44:20.470 --> 44:21.470
好

44:21.470 --> 44:22.470
那么

44:22.470 --> 44:23.470
再来

44:23.470 --> 44:25.470
我们再多掉几次

44:25.470 --> 44:26.470
多掉几次

44:26.470 --> 44:28.470
看一下速度有没有增快

44:28.470 --> 44:29.470
哦

44:29.470 --> 44:30.470
速度变快了

44:30.470 --> 44:31.470
速度变快了

44:31.470 --> 44:32.470
那之前的

44:32.470 --> 44:33.470
没有取消掉

44:33.470 --> 44:34.470
我看一下怎么回事

44:34.470 --> 44:36.470
它为什么会没有取消掉

44:36.470 --> 44:37.470
哦

44:37.470 --> 44:38.470
这里有光了写意

44:38.470 --> 44:39.470
我的天啊

44:39.470 --> 44:40.470
为什么这么容易错

44:40.470 --> 44:41.470
好

44:41.470 --> 44:42.470
这里

44:42.470 --> 44:43.470
out to increase

44:43.470 --> 44:44.470
多掉几次

44:44.470 --> 44:45.470
掉了很多次

44:45.470 --> 44:47.470
你看速度有没有变快

44:47.470 --> 44:48.470
是不是还是两秒一次

44:48.470 --> 44:49.470
对吧

44:49.470 --> 44:50.470
取消掉了

44:50.470 --> 44:51.470
对吧

44:51.470 --> 44:52.470
之前的取消掉了

44:52.470 --> 44:53.470
12到13

44:53.470 --> 44:54.470
13到14

44:54.470 --> 44:55.470
14到15

44:55.470 --> 44:56.470
对吧

44:56.470 --> 44:57.470
还是两秒钟的意思

44:57.470 --> 44:58.470
就这个意思

44:58.470 --> 44:59.470
比如说

44:59.470 --> 45:00.470
每一次我启动一个新的任务线的时候

45:00.470 --> 45:02.470
比方说我现在要启动一个新的任务线

45:02.470 --> 45:04.470
我先把之前的任务线

45:04.470 --> 45:05.470
取消掉

45:05.470 --> 45:06.470
保证这条任务线

45:06.470 --> 45:07.470
只有一个

45:07.470 --> 45:09.470
只有一个

45:09.470 --> 45:10.470
你看这意思吗

45:10.470 --> 45:11.470
这就是

45:11.470 --> 45:13.470
我们可以自己手写代

45:13.470 --> 45:15.470
利用 fork 来实现这个功能

45:15.470 --> 45:16.470
实际上呢

45:16.470 --> 45:17.470
这里呢

45:17.470 --> 45:18.470
还有这么一个

45:18.470 --> 45:19.470
就是例子

45:19.470 --> 45:21.470
就是海他给你提供了这么一个就是

45:21.470 --> 45:22.470
指令

45:22.470 --> 45:24.470
可以来帮助你完成这件事情

45:24.470 --> 45:25.470
这个指令呢

45:25.470 --> 45:26.470
叫做

45:30.470 --> 45:31.470
那么这个

45:31.470 --> 45:32.470
这个指令呢

45:32.470 --> 45:33.470
刚才之前是 take every

45:33.470 --> 45:34.470
对吧

45:34.470 --> 45:35.470
那么 take net is 成了

45:35.470 --> 45:36.470
它的功能

45:36.470 --> 45:39.470
和 take every

45:39.470 --> 45:40.470
一致

45:40.470 --> 45:41.470
只不过

45:41.470 --> 45:44.470
会自动取消掉

45:44.470 --> 45:47.470
之前开启的任务

45:47.470 --> 45:50.470
那么还会给你实现一样的功能

45:50.470 --> 45:51.470
那么每一次这里分岔

45:51.470 --> 45:52.470
一个新的任务的时候

45:52.470 --> 45:54.470
它会把之前的任务给你取消掉

45:54.470 --> 45:55.470
所以说这一块

45:55.470 --> 45:57.470
也可以不用你去手写代嘛

45:57.470 --> 45:59.470
也可以利用它的那个

45:59.470 --> 46:01.470
take every 来去手实现

46:01.470 --> 46:02.470
也就是说

46:02.470 --> 46:03.470
这里边呢

46:03.470 --> 46:04.470
我们还是直接写这个

46:04.470 --> 46:06.470
直接写这个

46:06.470 --> 46:07.470
然后呢

46:07.470 --> 46:08.470
我们这里呢

46:08.470 --> 46:10.470
就使用 take netis

46:10.470 --> 46:13.470
take netis

46:13.470 --> 46:15.470
也可以实现一样的功能

46:16.470 --> 46:17.470
保存

46:17.470 --> 46:18.470
你看一下吧

46:20.470 --> 46:21.470
我看一下

46:21.470 --> 46:22.470
哪里写错了

46:24.470 --> 46:25.470
没问题

46:25.470 --> 46:26.470
什么

46:26.470 --> 46:28.780
它说什么

46:28.780 --> 46:30.780
saga parameter

46:32.780 --> 46:34.780
我说我这个参数没给对

46:34.780 --> 46:36.780
action types

46:36.780 --> 46:38.780
out to increase

46:38.780 --> 46:39.780
然后呢

46:39.780 --> 46:41.780
这里写上那个就是

46:42.780 --> 46:44.780
out to increase

46:44.780 --> 46:45.780
实现一样的功能

46:45.780 --> 46:46.780
看着

46:46.780 --> 46:48.780
out to increase

46:48.780 --> 46:49.780
多掉一次

46:49.780 --> 46:50.780
多掉一次

46:50.780 --> 46:51.780
掉了很多次了

46:51.780 --> 46:52.780
对吧

46:52.780 --> 46:53.780
掉了很多次了

46:53.780 --> 46:54.780
你看一下

46:54.780 --> 46:55.780
是不是

46:55.780 --> 46:56.780
还是两万多一次

46:56.780 --> 46:57.780
它之前的任务

46:57.780 --> 46:58.780
是不是被取消掉了

46:58.780 --> 46:59.780
对吧

46:59.780 --> 47:01.780
这就是 take netis 的作用

47:01.780 --> 47:02.780
不讲那个 fork

47:02.780 --> 47:04.780
你是很难理解

47:04.780 --> 47:05.780
take netis 的东西

47:05.780 --> 47:07.780
是什么意思的

47:07.780 --> 47:09.780
之前为什么没讲

47:09.780 --> 47:11.780
那么它会实现一样的效果

47:11.780 --> 47:13.780
就是每一次分岔的时候

47:13.780 --> 47:15.780
你要去做这件事情的时候

47:15.780 --> 47:16.780
它之前的任务

47:16.780 --> 47:17.780
不管你完没完成

47:17.780 --> 47:18.780
反正我给你取消掉

47:18.780 --> 47:20.780
完成了也取消掉了

47:20.780 --> 47:21.780
没完成也取消掉了

47:21.780 --> 47:23.780
总之那个任务不再进行下去了

47:25.780 --> 47:26.780
那么接下来

47:26.780 --> 47:28.780
我们来说这个停止

47:28.780 --> 47:30.780
怎么去停止

47:31.780 --> 47:33.780
停止这一块

47:33.780 --> 47:35.780
它也有多种做法

47:35.780 --> 47:37.780
saga 是非常非常灵活的

47:37.780 --> 47:39.780
也就是你只要能够理解

47:39.780 --> 47:41.780
它这种执行原理的话

47:41.780 --> 47:42.780
你可以进行灵活处理

47:42.780 --> 47:43.780
所以这些可能可能

47:43.780 --> 47:44.780
稍微有点难度

47:44.780 --> 47:46.780
比上级可能学的那些基本指令

47:46.780 --> 47:47.780
有稍微有点难度

47:47.780 --> 47:48.780
虽然说我们平时开发的时候

47:48.780 --> 47:50.780
这些基本指令就

47:50.780 --> 47:52.780
99%的够用了

47:52.780 --> 47:53.780
不过有的时候

47:53.780 --> 47:55.780
我们来做一些特殊的案例的时候

47:55.780 --> 47:56.780
可能会用到一些

47:56.780 --> 47:58.780
特殊的这些指令

47:58.780 --> 48:00.780
那么你要做停止的话

48:00.780 --> 48:01.780
你看一下我这里可以

48:01.780 --> 48:02.780
好多种做法出来

48:02.780 --> 48:04.780
比方说我们这里

48:04.780 --> 48:05.780
首先我们可以

48:05.780 --> 48:06.780
利用take netis 对吧

48:06.780 --> 48:07.780
take netis

48:07.780 --> 48:10.780
让它自动取消之前的

48:10.780 --> 48:11.780
我们可以在这里

48:11.780 --> 48:13.780
定一个变量

48:13.780 --> 48:15.780
is stop

48:15.780 --> 48:17.780
是不是停止的

48:17.780 --> 48:19.780
比方说我们这里

48:19.780 --> 48:21.780
more than we force

48:21.780 --> 48:23.780
是否停止

48:23.780 --> 48:25.780
是否停止

48:25.780 --> 48:27.780
那么每一次out to increase的时候

48:27.780 --> 48:29.780
我们把is stop

48:29.780 --> 48:30.780
作为force

48:30.780 --> 48:32.780
就是说因为你运行的out to increase

48:32.780 --> 48:33.780
说明啥

48:33.780 --> 48:35.780
说明你是不是触发了out to increase

48:35.780 --> 48:36.780
你触发了它

48:36.780 --> 48:37.780
我肯定是不能停止

48:37.780 --> 48:39.780
把它作为force

48:39.780 --> 48:40.780
判断一下

48:40.780 --> 48:41.780
while的循环的时候

48:41.780 --> 48:42.780
我要push increase的时候

48:42.780 --> 48:43.780
判断一下

48:43.780 --> 48:46.780
如果说你已经停止了

48:46.780 --> 48:47.780
我这里break

48:47.780 --> 48:49.780
退出循环就结束了

48:49.780 --> 48:50.780
我这个任务不再进行下去了

48:50.780 --> 48:51.780
就结束了

48:51.780 --> 48:52.780
好

48:52.780 --> 48:54.780
那么现在我们再来写一个

48:54.780 --> 48:55.780
监听

48:55.780 --> 48:56.780
监听这个

48:56.780 --> 48:58.780
stop

48:58.780 --> 48:59.780
out to increase

48:59.780 --> 49:00.780
监听这个

49:00.780 --> 49:02.780
这个我写进来没有

49:02.780 --> 49:03.780
对 写进来

49:03.780 --> 49:04.780
然后这里我们去运行

49:04.780 --> 49:06.780
stop

49:06.780 --> 49:09.780
out to increase

49:09.780 --> 49:14.890
去运行这个函数

49:14.890 --> 49:15.890
停止

49:15.890 --> 49:16.890
怎么停止呢

49:16.890 --> 49:18.890
我们就把is stop

49:18.890 --> 49:19.890
设为啥

49:19.890 --> 49:20.890
设为q

49:20.890 --> 49:21.890
设为q

49:21.890 --> 49:22.890
是不是就完了

49:22.890 --> 49:23.890
对不对

49:23.890 --> 49:24.890
还要干嘛呢

49:24.890 --> 49:25.890
你告诉我还要干嘛呢

49:25.890 --> 49:26.890
就完了

49:26.890 --> 49:27.890
停止就很简单

49:27.890 --> 49:28.890
把这个变量

49:28.890 --> 49:30.890
我都不用那个

49:30.890 --> 49:31.890
不用那个生存器函数了

49:31.890 --> 49:33.890
让它直接运行就完事了

49:33.890 --> 49:34.890
运行一下这个函数就完事了

49:34.890 --> 49:35.890
都不用生存器函数了

49:35.890 --> 49:36.890
把is stop

49:36.890 --> 49:37.890
设为q就完事了

49:37.890 --> 49:38.890
因为设为q过后

49:38.890 --> 49:40.890
之前那个任务还在继续运行

49:40.890 --> 49:41.890
但是它一旦遇到了is stop

49:41.890 --> 49:42.890
因为它不但循环

49:42.890 --> 49:43.890
这个is stop

49:43.890 --> 49:44.890
设为出了过后

49:44.890 --> 49:45.890
它就会break

49:45.890 --> 49:46.890
对吧

49:46.890 --> 49:47.890
它就会停止

49:47.890 --> 49:48.890
保存我们来看一下吧

49:48.890 --> 49:49.890
然后我们这里

49:49.890 --> 49:50.890
out to

49:50.890 --> 49:51.890
有很多种做法

49:51.890 --> 49:52.890
有很多种做法

49:52.890 --> 49:53.890
那么这种

49:53.890 --> 49:55.890
它不是取消任务的这种模式

49:55.890 --> 49:57.890
它是用个变量来控制的

49:57.890 --> 49:58.890
out to increase

49:58.890 --> 49:59.890
你看

49:59.890 --> 50:01.890
不管给它写多少次out to increase

50:01.890 --> 50:02.890
不管给它写多少次

50:02.890 --> 50:04.890
它始终是2秒钟一次

50:04.890 --> 50:06.890
因为它会把之前的任务取消掉

50:06.890 --> 50:07.890
2秒钟一次

50:07.890 --> 50:08.890
对吧

50:08.890 --> 50:09.890
现在我们来停止

50:09.890 --> 50:10.890
stop

50:11.890 --> 50:12.890
out to increase

50:13.890 --> 50:14.890
好 停止

50:15.890 --> 50:17.890
停止过后是没了

50:17.890 --> 50:18.890
是没了

50:18.890 --> 50:19.890
为什么

50:19.890 --> 50:20.890
因为停止过后把设为q了过后

50:20.890 --> 50:22.890
之前那个任务虽然还在进行

50:22.890 --> 50:23.890
但是它判断到了is stop

50:23.890 --> 50:25.890
就之前那个任务并没有消失

50:25.890 --> 50:26.890
out to increase

50:26.890 --> 50:28.890
之前开启的任务并没有消失

50:28.890 --> 50:30.890
它还在使循环运行

50:30.890 --> 50:31.890
运行的时候

50:31.890 --> 50:32.890
它发现is stop了

50:32.890 --> 50:33.890
变量为出了

50:33.890 --> 50:34.890
然后它就停止循环了

50:34.890 --> 50:35.890
就这么简单

50:35.890 --> 50:36.890
对吧

50:36.890 --> 50:37.890
这是一种模式

50:37.890 --> 50:38.890
有很多种模式

50:38.890 --> 50:39.890
如果说我们这里

50:39.890 --> 50:41.890
再调用out to increase

50:42.890 --> 50:43.890
这么正常呢

50:43.890 --> 50:44.890
肯定还是正常的

50:44.890 --> 50:45.890
肯定是正常的

50:45.890 --> 50:46.890
没有任何问题

50:46.890 --> 50:47.890
为什么没有任何问题

50:47.890 --> 50:49.890
因为它相当于是又开了一个

50:49.890 --> 50:50.890
对吧

50:50.890 --> 50:51.890
又开了一个out to increase

50:51.890 --> 50:53.890
又开了一个任务分支

50:53.890 --> 50:54.890
又把之前的任务取消掉了

50:54.890 --> 50:55.890
又重新来了

50:55.890 --> 50:57.890
新的任务开启过后

50:57.890 --> 50:58.890
是不是又把is stop

50:58.890 --> 50:59.890
设为forced

50:59.890 --> 51:00.890
对吧

51:00.890 --> 51:01.890
又把is stop

51:01.890 --> 51:02.890
设为forced

51:02.890 --> 51:03.890
又可以继续运行了

51:03.890 --> 51:05.890
这里稍微有点绕

51:06.890 --> 51:08.890
就是有很多的模式

51:09.890 --> 51:10.890
都是第一种模式

51:10.890 --> 51:11.890
咱们把它复制一下

51:11.890 --> 51:12.890
还有第二种模式

51:12.890 --> 51:13.890
比方说第二种模式

51:13.890 --> 51:15.890
就是我们自己手写

51:15.890 --> 51:16.890
手写forced

51:16.890 --> 51:18.890
手写forced这种模式

51:18.890 --> 51:19.890
那么这里

51:19.890 --> 51:20.890
task

51:20.890 --> 51:21.890
我们就可以保存到

51:21.890 --> 51:22.890
权局变量里边

51:22.890 --> 51:24.890
保存到权局变量里边

51:25.890 --> 51:27.890
那么就是我们自己

51:27.890 --> 51:28.890
手写的模式

51:28.890 --> 51:29.890
就是out to increase

51:29.890 --> 51:30.890
这是out to increase

51:30.890 --> 51:32.890
然后主色监听

51:32.890 --> 51:33.890
对吧

51:33.890 --> 51:34.890
每一次开启新任务

51:34.890 --> 51:35.890
这样的

51:35.890 --> 51:36.890
我们把这个任务

51:36.890 --> 51:37.890
任务变量保存下来

51:37.890 --> 51:38.890
把这个任务变量

51:38.890 --> 51:39.890
表现下来

51:39.890 --> 51:40.890
这是表示我新开那个任务

51:40.890 --> 51:41.890
再进行使循环

51:41.890 --> 51:43.890
每一次监听到了新的

51:43.890 --> 51:44.890
out to increase

51:44.890 --> 51:45.890
都适合了

51:45.890 --> 51:46.890
我都把之前的任务取消掉

51:46.890 --> 51:47.890
又重来

51:47.890 --> 51:48.890
对不对

51:48.890 --> 51:49.890
那么到时候有什么停止呢

51:49.890 --> 51:50.890
停止是不是一样的道理

51:50.890 --> 51:51.890
就把之前的任务取消掉

51:51.890 --> 51:52.890
就完成了

51:52.890 --> 51:53.890
所以说我们这里要停止的话

51:53.890 --> 51:55.890
take every

51:55.890 --> 51:57.890
不要忘记写e

51:58.890 --> 51:59.890
take every

51:59.890 --> 52:00.890
就是action

52:00.890 --> 52:01.890
taps

52:01.890 --> 52:02.890
stop

52:02.890 --> 52:03.890
out to increase

52:03.890 --> 52:07.650
它有很多的模式

52:07.650 --> 52:08.650
方式

52:08.650 --> 52:10.650
非常非常灵活

52:10.650 --> 52:11.650
那么我干嘛

52:11.650 --> 52:12.650
我就一样的呗

52:12.650 --> 52:13.650
task

52:13.650 --> 52:15.650
甚至我会把这个地方

52:15.650 --> 52:16.650
封装成一个函数

52:16.650 --> 52:17.650
封装成一个函数吧

52:17.650 --> 52:18.650
封装成一个函数

52:18.650 --> 52:19.650
方式

52:19.650 --> 52:20.650
stop

52:20.650 --> 52:21.650
task

52:22.650 --> 52:23.650
封装成一个函数

52:23.650 --> 52:27.410
那么就这个代码

52:28.410 --> 52:29.410
封装成一个函数

52:29.410 --> 52:31.410
我们顺便说一下另外一个问题

52:31.410 --> 52:32.410
封装成一个函数

52:32.410 --> 52:33.410
这也是个生存器函数

52:33.410 --> 52:34.410
好

52:34.410 --> 52:35.410
那么现在呢

52:35.410 --> 52:36.410
这个生存器函数

52:36.410 --> 52:37.410
里边去执行

52:37.410 --> 52:38.410
还记得吗

52:38.410 --> 52:39.410
我们怎么来

52:39.410 --> 52:40.410
转到一个生存器函数

52:40.410 --> 52:41.410
里边去执行

52:41.410 --> 52:43.410
你千万不能这样子写

52:45.410 --> 52:46.410
task

52:46.410 --> 52:47.410
你千万不能这样子写

52:47.410 --> 52:48.410
这样子写是什么

52:48.410 --> 52:49.410
把e有得了一个什么

52:49.410 --> 52:50.410
就是把

52:50.410 --> 52:51.410
迪带了一个什么东西

52:51.410 --> 52:53.410
迪带了这个生存器对象过去了

52:53.410 --> 52:54.410
不能这样子写

52:54.410 --> 52:56.410
你是不是前面加个新号

52:56.410 --> 52:57.410
对不对

52:57.410 --> 52:58.410
表示进入这个函数

52:58.410 --> 52:59.410
里边去执行

52:59.410 --> 53:00.410
就这么个意思

53:00.410 --> 53:01.410
我们之前是不是说过了

53:01.410 --> 53:02.410
所以说

53:02.410 --> 53:03.410
你要学习Sagali

53:03.410 --> 53:04.410
条件必须要了解

53:04.410 --> 53:05.410
理解生存器

53:05.410 --> 53:06.410
好那么这里呢

53:06.410 --> 53:07.410
我们就写了这么一个

53:07.410 --> 53:08.410
生存器函数

53:08.410 --> 53:09.410
对吧

53:09.410 --> 53:10.410
那么封装了一下

53:10.410 --> 53:11.410
好那么这里呢

53:11.410 --> 53:12.410
stop out to increase

53:12.410 --> 53:13.410
干嘛

53:13.410 --> 53:14.410
e or 得

53:14.410 --> 53:15.410
stop task

53:15.410 --> 53:16.410
对吧

53:16.410 --> 53:18.410
把之前那个task移除掉就完事了

53:18.410 --> 53:19.410
对不对

53:19.410 --> 53:21.410
这也是一种做法

53:21.410 --> 53:22.410
做法有很多

53:22.410 --> 53:23.410
好你看一下

53:23.410 --> 53:24.410
我们现在呢

53:24.410 --> 53:26.410
out to increase

53:26.410 --> 53:27.410
增加

53:27.410 --> 53:28.410
数据不断的增加

53:28.410 --> 53:29.410
那增加吧

53:30.410 --> 53:31.410
而且呢

53:31.410 --> 53:33.410
不断的调用这个out to increase

53:33.410 --> 53:34.410
不断的调用他

53:34.410 --> 53:35.410
那么他都

53:35.410 --> 53:37.410
他都不会重复的启动

53:37.410 --> 53:39.410
因为他会把之前的任务取消掉

53:39.410 --> 53:40.410
那么如果说

53:40.410 --> 53:42.410
我们调用这个stop

53:42.410 --> 53:43.410
stop

53:43.410 --> 53:44.410
out to increase

53:44.410 --> 53:45.410
调用这个

53:45.410 --> 53:46.410
调用这个之后呢

53:46.410 --> 53:47.410
他会导致

53:47.410 --> 53:48.410
之前的任务被取消掉

53:48.410 --> 53:50.410
就这个任务会直接结束

53:50.410 --> 53:52.410
他就不是用变量的模式了

53:52.410 --> 53:53.410
今天还在进行

53:53.410 --> 53:54.410
对吧

53:54.410 --> 53:55.410
out to increase

53:55.410 --> 53:56.410
他今天还在进行

53:56.410 --> 53:57.410
但是呢

53:57.410 --> 53:58.410
这个任务结束了

53:58.410 --> 53:59.410
今天还在进行的好处在于

53:59.410 --> 54:01.410
重新调用这个out to increase

54:01.410 --> 54:03.410
他又会重新启动

54:03.410 --> 54:04.410
又会重新启动

54:04.410 --> 54:05.410
对吧

54:05.410 --> 54:07.410
这是这么模式

54:07.410 --> 54:08.410
这么模式

54:08.410 --> 54:09.410
还有一种模式

54:09.410 --> 54:10.410
我告诉大家

54:10.410 --> 54:11.410
还用模式

54:11.410 --> 54:13.410
非常非常灵活

54:13.410 --> 54:14.410
咱们呢

54:14.410 --> 54:15.410
我们再来看一个模式

54:15.410 --> 54:16.410
这个模式呢

54:16.410 --> 54:18.410
我们之前还没有结束过

54:18.410 --> 54:19.410
我们这里

54:19.410 --> 54:20.410
把这个关掉

54:20.410 --> 54:22.410
把这些乱七八糟的东西都去掉

54:22.410 --> 54:23.410
接下来我们再给大家看一个

54:23.410 --> 54:28.260
非常吸引的模式

54:29.260 --> 54:31.260
我们这里就纯熟写

54:31.260 --> 54:33.260
纯熟写

54:33.260 --> 54:35.260
看着啊

54:35.260 --> 54:36.260
我们这里呢

54:36.260 --> 54:37.260
我们这样子来操作

54:37.260 --> 54:38.260
好

54:38.260 --> 54:39.260
这里呢

54:39.260 --> 54:40.260
我们写上这么一个函数

54:40.260 --> 54:42.260
给大家取个名字

54:42.260 --> 54:46.260
叫做out to task

54:46.260 --> 54:48.260
写上这么一个生存器函数

54:48.260 --> 54:50.260
生存器函数

54:50.260 --> 54:51.260
写上这个

54:51.260 --> 54:53.260
那么 fork 这个函数

54:53.260 --> 54:55.260
直接 fork 这个函数

54:55.260 --> 54:57.260
看着啊

54:57.260 --> 54:58.260
这个模式呢

54:58.260 --> 54:59.260
大家也得学会

54:59.260 --> 55:00.260
因为这个是

55:00.260 --> 55:01.260
你要进入高阶的那种

55:01.260 --> 55:03.260
沙打的应用的时候呢

55:03.260 --> 55:05.260
必须学会的一种模式

55:05.260 --> 55:07.260
这叫做流程控制

55:09.260 --> 55:12.260
流程控制

55:12.260 --> 55:15.260
就是自动增加和停止的

55:15.260 --> 55:17.260
自动增加和停止的

55:17.260 --> 55:19.260
流程控制

55:19.260 --> 55:20.260
为什么叫流程控制呢

55:20.260 --> 55:22.260
你想想

55:22.260 --> 55:23.260
增加和停止

55:23.260 --> 55:24.260
是不是一定有个流程

55:24.260 --> 55:26.260
先增加

55:26.260 --> 55:28.260
再停止

55:28.260 --> 55:29.260
然后呢

55:29.260 --> 55:30.260
停止完了过后

55:30.260 --> 55:31.260
是不是再能自动增加

55:31.260 --> 55:32.260
对吧

55:32.260 --> 55:33.260
它一定是这样的流程

55:33.260 --> 55:34.260
一定是这样的流程

55:34.260 --> 55:36.260
一定是先增加再停止

55:36.260 --> 55:38.260
一定是

55:38.260 --> 55:39.260
一定是

55:39.260 --> 55:41.260
它流程一定是这样子的

55:41.260 --> 55:43.260
增加自动增加

55:43.260 --> 55:45.630
然后呢

55:45.630 --> 55:47.630
到下个流程就是停止

55:47.630 --> 55:48.630
对吧

55:48.630 --> 55:49.630
然后再到什么

55:49.630 --> 55:50.630
自动增加

55:50.630 --> 55:52.630
然后再到下个流程

55:52.630 --> 55:53.630
是不是停止

55:53.630 --> 55:54.630
它一定是这样子的流程

55:54.630 --> 55:55.630
因此呢

55:55.630 --> 55:56.630
你看着

55:56.630 --> 55:58.630
这里面有个非常非常巧妙的写法

55:58.630 --> 56:00.630
其实对我们

56:00.630 --> 56:01.630
熟悉了三个之后

56:01.630 --> 56:02.630
你会发现这种写法

56:02.630 --> 56:04.630
就是不说到处也有吧

56:04.630 --> 56:06.630
很多的公司里边

56:06.630 --> 56:08.630
开发的水平撑持不起

56:08.630 --> 56:09.630
可能写不出来这样的代吧

56:09.630 --> 56:10.630
但是呢

56:10.630 --> 56:11.630
如果说你要去写一些

56:11.630 --> 56:12.630
公共的一些模块的话

56:12.630 --> 56:14.630
你经常会用这样的写法

56:14.630 --> 56:15.630
然后到时候

56:15.630 --> 56:16.630
你要做登录助销

56:16.630 --> 56:18.630
先登录才能助销嘛

56:18.630 --> 56:19.630
助销过后才能重新登录嘛

56:19.630 --> 56:20.630
对吧

56:20.630 --> 56:22.630
也是类似有这样的流程

56:22.630 --> 56:23.630
好

56:23.630 --> 56:24.630
那么自动增加

56:24.630 --> 56:25.630
停止

56:25.630 --> 56:26.630
好你看着

56:26.630 --> 56:27.630
我们可以这样的写

56:27.630 --> 56:28.630
首先要的

56:28.630 --> 56:30.630
take

56:30.630 --> 56:31.630
监听

56:31.630 --> 56:32.630
只监听一次

56:32.630 --> 56:33.630
只监听一次

56:33.630 --> 56:34.630
监听什么呢

56:34.630 --> 56:36.630
监听action types

56:36.630 --> 56:37.630
什么

56:37.630 --> 56:38.630
out to increase

56:38.630 --> 56:39.630
只监听这个

56:39.630 --> 56:41.630
我都不监听停止

56:41.630 --> 56:42.630
你调用停止有用吗

56:42.630 --> 56:43.630
没用

56:43.630 --> 56:44.630
我都不监听你

56:44.630 --> 56:46.630
我只监听out to increase

56:46.630 --> 56:48.630
只监听这个

56:48.630 --> 56:50.630
只监听

56:50.630 --> 56:52.630
out to increase

56:52.630 --> 56:54.630
那么只有out to increase过后

56:54.630 --> 56:55.630
我们才会

56:55.630 --> 56:56.630
继续运行

56:56.630 --> 56:57.630
在这里主色了

56:57.630 --> 56:58.630
卡住了

56:58.630 --> 57:00.630
那么我们这里开了一个任务

57:00.630 --> 57:01.630
那么这个任务呢

57:01.630 --> 57:03.630
叫做out to task

57:03.630 --> 57:04.630
这个任务

57:04.630 --> 57:05.630
他监听谁

57:05.630 --> 57:07.630
是不是监听

57:07.630 --> 57:08.630
监听啥

57:08.630 --> 57:10.630
监听out to increase

57:10.630 --> 57:11.630
对吧

57:11.630 --> 57:12.630
监听这个

57:12.630 --> 57:13.630
对吧

57:13.630 --> 57:14.630
是监听这个

57:14.630 --> 57:15.630
好

57:15.630 --> 57:16.630
那么监听这个

57:16.630 --> 57:17.630
监听了过后

57:17.630 --> 57:18.630
他是在主色嘛

57:18.630 --> 57:19.630
只有这个

57:19.630 --> 57:21.630
action到哪的时候

57:21.630 --> 57:22.630
他就会去运行

57:22.630 --> 57:23.630
好

57:23.630 --> 57:24.630
继续运行的时候

57:24.630 --> 57:25.630
我们干嘛呢

57:25.630 --> 57:28.630
我们就开启一个新任务

57:28.630 --> 57:30.630
开启一个新任务

57:30.630 --> 57:31.630
方形

57:31.630 --> 57:36.670
开启一个新任务

57:36.670 --> 57:38.670
eO的

57:38.670 --> 57:40.670
得到一个task

57:40.670 --> 57:41.670
好

57:41.670 --> 57:42.670
开启这么一个新任务

57:42.670 --> 57:43.670
这个新任务做什么呢

57:43.670 --> 57:45.670
就是out to

57:45.670 --> 57:48.670
每隔2秒钟eO的定内

57:48.670 --> 57:50.670
每隔2秒钟

57:50.670 --> 57:51.670
然后干嘛

57:51.670 --> 57:55.670
每隔2秒钟是不是要运行一个

57:55.670 --> 57:57.670
定内还没有写

57:57.670 --> 57:58.670
定内

57:58.670 --> 58:00.670
每隔2秒钟

58:00.670 --> 58:01.670
然后运行一个put

58:01.670 --> 58:02.670
对吧

58:02.670 --> 58:03.670
触发一个action

58:03.670 --> 58:04.670
eO的

58:04.670 --> 58:05.670
put

58:05.670 --> 58:06.670
触发一个action

58:06.670 --> 58:07.670
increase

58:07.670 --> 58:08.670
对不对

58:08.670 --> 58:10.670
每隔2秒钟去触发一个action

58:10.670 --> 58:11.670
于是呢这里

58:11.670 --> 58:13.670
当我们监听到了过后

58:13.670 --> 58:15.670
监听到了这个out to increase的过后呢

58:15.670 --> 58:16.670
我们干嘛

58:16.670 --> 58:18.670
我们是不是触发一个新的任务

58:18.670 --> 58:20.670
触发一个新的任务

58:20.670 --> 58:24.560
就是对于Saga来说

58:24.560 --> 58:25.560
高级的用法

58:25.560 --> 58:27.560
就是你要理解这个fork

58:27.560 --> 58:28.560
理解fork过后

58:28.560 --> 58:30.560
你可以玩出各种各样的花样出来

58:30.560 --> 58:32.560
所以在这里就是

58:32.560 --> 58:34.560
不断的去增加对吧

58:34.560 --> 58:36.560
不断的去增加

58:36.560 --> 58:38.560
视循环

58:38.560 --> 58:39.560
视循环

58:39.560 --> 58:41.560
然后不断增加

58:41.560 --> 58:42.560
对不对

58:42.560 --> 58:43.560
增加

58:43.560 --> 58:45.560
那么这是监听什么

58:45.560 --> 58:46.560
这是监听啥

58:46.560 --> 58:49.560
监听这个就是out to increase

58:49.560 --> 58:50.560
对不对

58:50.560 --> 58:51.560
好那么

58:51.560 --> 58:53.560
监听了out to increase过后

58:53.560 --> 58:54.560
我开启了一个任务

58:54.560 --> 58:55.560
开启了一个任务之后

58:55.560 --> 58:57.560
后边我还监听这个out to increase吗

58:57.560 --> 58:59.560
不监听了

58:59.560 --> 59:01.560
我后边就不监听out to increase了

59:01.560 --> 59:03.560
我转而去监听谁

59:03.560 --> 59:05.560
我转而去监听停止

59:05.560 --> 59:06.560
看着

59:06.560 --> 59:09.560
这是一种非常非常巧妙的做法

59:09.560 --> 59:11.560
那么现在有监听谁

59:11.560 --> 59:14.560
监听stop out to increase

59:14.560 --> 59:15.560
我去监听这个

59:15.560 --> 59:17.560
所以说接下来我代码怎么写

59:17.560 --> 59:19.560
接下来我又要take

59:19.560 --> 59:21.560
exon types

59:21.560 --> 59:24.560
stop out to increase

59:24.560 --> 59:26.560
我去监听这个

59:26.560 --> 59:28.560
转而监听谁

59:28.560 --> 59:31.560
监听stop out to increase

59:31.560 --> 59:32.560
也就是说

59:32.560 --> 59:34.560
如果说你现在反复调用out to increase

59:34.560 --> 59:35.560
有用吗

59:35.560 --> 59:36.560
没用了

59:36.560 --> 59:37.560
没用了

59:37.560 --> 59:38.560
你看着

59:38.560 --> 59:39.560
我这里要out to increase

59:39.560 --> 59:41.560
反复了调用

59:41.560 --> 59:43.560
它会开启新任务吗

59:43.560 --> 59:44.560
不会了

59:44.560 --> 59:45.560
跟之前有没有影响

59:45.560 --> 59:47.560
跟之前一点影响都没有

59:47.560 --> 59:49.560
跟之前的一点影响都没有

59:49.560 --> 59:50.560
为什么

59:50.560 --> 59:51.560
因为这里的监听已经结束了

59:51.560 --> 59:53.560
它已经启动了一个新任务

59:53.560 --> 59:54.560
它不断的添加了

59:54.560 --> 59:56.560
我都不用去取消之前的任务

59:56.560 --> 59:57.560
都不用取消

59:57.560 --> 59:58.560
因为现在我在监听谁

59:58.560 --> 59:59.560
监听这个

59:59.560 --> 01:00:00.560
监听这个

01:00:00.560 --> 01:00:02.560
但是你给我的还是这个increase

01:00:02.560 --> 01:00:03.560
那我监听到吗

01:00:03.560 --> 01:00:04.560
监听不到了

01:00:04.560 --> 01:00:05.560
看到没

01:00:05.560 --> 01:00:06.560
我监听不到就完了

01:00:06.560 --> 01:00:08.560
所以说它还是之前的任务在运行

01:00:08.560 --> 01:00:10.560
也完全不会干扰之前的任务

01:00:10.560 --> 01:00:11.560
你不会取消掉

01:00:11.560 --> 01:00:12.560
看没

01:00:12.560 --> 01:00:13.560
它形成了这么一种模式

01:00:13.560 --> 01:00:15.560
现在只会监听这个

01:00:15.560 --> 01:00:16.560
那么监听这个过后

01:00:16.560 --> 01:00:17.560
好

01:00:17.560 --> 01:00:19.560
那么如果说一旦监听到了这个

01:00:19.560 --> 01:00:20.560
监听到了这个

01:00:20.560 --> 01:00:21.560
是不是我把这个任务

01:00:21.560 --> 01:00:22.560
取消

01:00:22.560 --> 01:00:23.560
对不对

01:00:23.560 --> 01:00:24.560
cancel

01:00:24.560 --> 01:00:25.560
我把之前那个task

01:00:25.560 --> 01:00:29.770
cancel取消

01:00:29.770 --> 01:00:30.770
task

01:00:30.770 --> 01:00:33.770
取消掉之前的task

01:00:33.770 --> 01:00:34.770
如果说我监听到了这个

01:00:34.770 --> 01:00:35.770
stop

01:00:35.770 --> 01:00:36.770
out to increase

01:00:36.770 --> 01:00:37.770
那我干吗

01:00:37.770 --> 01:00:38.770
我是不是取消

01:00:38.770 --> 01:00:43.230
我们再打个箭头

01:00:43.230 --> 01:00:44.230
打个箭头

01:00:44.230 --> 01:00:46.230
那么取消

01:00:46.230 --> 01:00:48.230
取消这个任务

01:00:48.230 --> 01:00:51.230
取消

01:00:51.230 --> 01:00:53.230
取消之前那个使循环

01:00:53.230 --> 01:00:54.230
取消过后

01:00:54.230 --> 01:00:55.230
是不是下一次使循环

01:00:55.230 --> 01:00:56.230
对吧

01:00:56.230 --> 01:00:57.230
我自己的任务

01:00:57.230 --> 01:00:58.230
这个取消过后

01:00:58.230 --> 01:00:59.230
下一次使循环

01:00:59.230 --> 01:01:00.230
是不是又到了

01:01:00.230 --> 01:01:01.230
又去转而去监听

01:01:01.230 --> 01:01:02.230
out to increase

01:01:02.230 --> 01:01:03.230
是不是这里就形成一个

01:01:03.230 --> 01:01:04.230
环状结构

01:01:04.230 --> 01:01:05.230
对吧

01:01:05.230 --> 01:01:07.860
这里就形成了这么一个

01:01:07.860 --> 01:01:08.860
环状结构了

01:01:08.860 --> 01:01:09.860
这里就形成了

01:01:09.860 --> 01:01:14.740
这么一种结构了

01:01:14.740 --> 01:01:15.740
我们这里

01:01:15.740 --> 01:01:16.740
放到这吧

01:01:16.740 --> 01:01:17.740
就形成了这么一种结构了

01:01:17.740 --> 01:01:18.740
看没

01:01:18.740 --> 01:01:19.740
组织监听过后

01:01:19.740 --> 01:01:20.740
我们取消

01:01:20.740 --> 01:01:21.740
要先取消

01:01:21.740 --> 01:01:25.740
要先取消

01:01:25.740 --> 01:01:27.740
我这个真的不好调

01:01:27.740 --> 01:01:28.740
PBT这个箭头

01:01:28.740 --> 01:01:29.740
真的很恶心

01:01:30.740 --> 01:01:32.740
那么监听取消过后

01:01:32.740 --> 01:01:33.740
我又回到监听

01:01:33.740 --> 01:01:34.740
out to increase

01:01:34.740 --> 01:01:35.740
又不再监听它了

01:01:35.740 --> 01:01:36.740
看到没

01:01:36.740 --> 01:01:37.740
又不再监听它了

01:01:37.740 --> 01:01:38.740
就形成了这么一种

01:01:38.740 --> 01:01:39.740
流程结构

01:01:39.740 --> 01:01:40.740
先监听它

01:01:40.740 --> 01:01:41.740
监听到了过后

01:01:41.740 --> 01:01:42.740
我增加一个任务

01:01:42.740 --> 01:01:43.740
去使循环

01:01:43.740 --> 01:01:44.740
你去做

01:01:44.740 --> 01:01:45.740
那么现在我先来监听这个

01:01:45.740 --> 01:01:46.740
现在监听它

01:01:46.740 --> 01:01:47.740
监听它

01:01:47.740 --> 01:01:48.740
监听到过后

01:01:48.740 --> 01:01:49.740
我把之前的任务

01:01:49.740 --> 01:01:50.740
取消掉

01:01:50.740 --> 01:01:51.740
我又重新去监听

01:01:51.740 --> 01:01:52.740
out to increase

01:01:52.740 --> 01:01:53.740
对吧

01:01:53.740 --> 01:01:54.740
以后在网站中

01:01:54.740 --> 01:01:55.740
系统开发中

01:01:55.740 --> 01:01:57.740
流程结构的这种数据

01:01:57.740 --> 01:01:58.740
那么我们都可以

01:01:58.740 --> 01:01:59.740
用这种方式来做

01:01:59.740 --> 01:02:00.740
什么登录

01:02:00.740 --> 01:02:01.740
登录完了过后再入销

01:02:01.740 --> 01:02:02.740
是不是都可以用

01:02:02.740 --> 01:02:03.740
这种方式来做

01:02:03.740 --> 01:02:04.740
我先监听登录

01:02:04.740 --> 01:02:05.740
登录完了过后

01:02:05.740 --> 01:02:06.740
我做一些处理

01:02:06.740 --> 01:02:07.740
设置了什么

01:02:07.740 --> 01:02:08.740
乱七八糟的数据

01:02:08.740 --> 01:02:09.740
那么现在我不监听登录了

01:02:09.740 --> 01:02:11.740
登录没意义了对我来说

01:02:11.740 --> 01:02:12.740
不用监听登录了

01:02:12.740 --> 01:02:13.740
我去监听啥

01:02:13.740 --> 01:02:14.740
监听助销

01:02:14.740 --> 01:02:15.740
等于助销的时候

01:02:15.740 --> 01:02:16.740
我再去做一些数据

01:02:16.740 --> 01:02:17.740
改动一下数据

01:02:17.740 --> 01:02:18.740
改完了过后

01:02:18.740 --> 01:02:19.740
我又重新监听登录

01:02:19.740 --> 01:02:20.740
你看看

01:02:20.740 --> 01:02:21.740
就变成了这么一种

01:02:22.740 --> 01:02:23.740
那么这里就是

01:02:23.740 --> 01:02:24.740
一样的逻辑

01:02:24.740 --> 01:02:25.740
你看一下

01:02:25.740 --> 01:02:26.740
现在我觉得

01:02:26.740 --> 01:02:27.740
目前这三种方案中

01:02:27.740 --> 01:02:29.740
我是最喜欢这种方案

01:02:29.740 --> 01:02:30.740
最喜欢这种方案

01:02:30.740 --> 01:02:31.740
因为这种方案

01:02:31.740 --> 01:02:33.740
流程结构无比的清晰

01:02:33.740 --> 01:02:35.740
而且不用去监听这样的

01:02:35.740 --> 01:02:36.740
监听大量

01:02:36.740 --> 01:02:38.740
全是在一个流程里面搞定

01:02:38.740 --> 01:02:39.740
因为他们两个

01:02:39.740 --> 01:02:40.740
本来就是有关联的

01:02:40.740 --> 01:02:41.740
启动过后停止

01:02:41.740 --> 01:02:42.740
停止过后再启动

01:02:42.740 --> 01:02:43.740
对吧

01:02:43.740 --> 01:02:44.740
然后现在我们看一下

01:02:44.740 --> 01:02:45.740
凸硬确实

01:02:45.740 --> 01:02:46.740
而它一个好处在有什么呢

01:02:46.740 --> 01:02:47.740
它不会说

01:02:47.740 --> 01:02:48.740
你不断的启动

01:02:48.740 --> 01:02:50.740
不断的去触发这个X

01:02:50.740 --> 01:02:51.740
取消之前的

01:02:51.740 --> 01:02:52.740
取消之前的时间还不好

01:02:52.740 --> 01:02:53.740
比方说之前

01:02:53.740 --> 01:02:54.740
本来要等两秒钟

01:02:54.740 --> 01:02:56.740
它刚好等到1.9秒了

01:02:56.740 --> 01:02:57.740
你突然把它取消掉了

01:02:57.740 --> 01:02:59.740
是不是又得重新等待两秒钟

01:02:59.740 --> 01:03:00.740
对吧

01:03:00.740 --> 01:03:01.740
那样子其实不好

01:03:01.740 --> 01:03:02.740
但是我们现在的任务模式

01:03:02.740 --> 01:03:06.740
它不会动员的任务

01:03:06.740 --> 01:03:07.740
所以这个任务

01:03:07.740 --> 01:03:08.740
按照它的时间

01:03:08.740 --> 01:03:09.740
挨在这家就行了

01:03:09.740 --> 01:03:10.740
跟我没关系

01:03:10.740 --> 01:03:11.740
你再

01:03:11.740 --> 01:03:12.740
就好像说

01:03:12.740 --> 01:03:13.740
给任务的感觉就好像说

01:03:13.740 --> 01:03:14.740
你不断的去触发这个

01:03:14.740 --> 01:03:15.740
凸硬确实的X

01:03:15.740 --> 01:03:17.740
好像没有什么效果一样

01:03:17.740 --> 01:03:19.740
为什么它不监听呢

01:03:19.740 --> 01:03:20.740
它不监听它了

01:03:20.740 --> 01:03:21.740
你看一下

01:03:21.740 --> 01:03:22.740
监听

01:03:22.740 --> 01:03:23.740
你看增加

01:03:23.740 --> 01:03:24.740
那我用这里反复

01:03:24.740 --> 01:03:25.740
反复你看

01:03:25.740 --> 01:03:26.740
它是不是还在增加

01:03:26.740 --> 01:03:27.740
对吧

01:03:27.740 --> 01:03:28.740
你看是不是还在增加

01:03:28.740 --> 01:03:29.740
它不像之前那样子

01:03:29.740 --> 01:03:30.740
我不断的去掉落它

01:03:30.740 --> 01:03:31.740
它会不断的取消

01:03:31.740 --> 01:03:32.740
重新监听

01:03:32.740 --> 01:03:33.740
那么它导致没有增加

01:03:33.740 --> 01:03:34.740
那我这里不断的运行

01:03:34.740 --> 01:03:35.740
它还是会增加

01:03:35.740 --> 01:03:36.740
该增加就增加

01:03:36.740 --> 01:03:37.740
因为它的任务

01:03:37.740 --> 01:03:38.740
没有受到影响

01:03:38.740 --> 01:03:39.740
OK 增加到18、19

01:03:39.740 --> 01:03:40.740
好

01:03:40.740 --> 01:03:41.740
那么现在我们掉了

01:03:41.740 --> 01:03:42.740
这个Stop

01:03:42.740 --> 01:03:43.740
Out to increase

01:03:43.740 --> 01:03:44.740
一定要用

01:03:44.740 --> 01:03:45.740
它就把这个任务取消掉了

01:03:45.740 --> 01:03:46.740
就不再增加了

01:03:46.740 --> 01:03:48.740
那么现在又转而去监听

01:03:49.740 --> 01:03:52.740
这种模式是注意舒服的模式

01:03:52.740 --> 01:03:54.740
说Saga它非常非常灵活

01:03:54.740 --> 01:03:55.740
你只要搞清楚了

01:03:55.740 --> 01:03:57.740
这种任务线

01:03:57.740 --> 01:03:59.740
它怎么来处处理分支的

01:03:59.740 --> 01:04:01.740
你只要搞清楚了这个

01:04:01.740 --> 01:04:03.740
那么你对它的任务调度

01:04:03.740 --> 01:04:05.740
控制的就是随心所欲了

01:04:05.740 --> 01:04:07.740
可以按照各种量的流程

01:04:07.740 --> 01:04:08.740
来控制这个任务

01:04:08.740 --> 01:04:10.740
我们这里就多举了一个例子

01:04:10.740 --> 01:04:13.740
关于Cancel

01:04:13.740 --> 01:04:14.740
以及Folk

01:04:14.740 --> 01:04:16.740
举了这么几个例子

01:04:16.740 --> 01:04:17.740
那么这个Cancel

01:04:17.740 --> 01:04:18.740
我再说一下

01:04:18.740 --> 01:04:20.740
可以传多个任务

01:04:20.740 --> 01:04:22.740
也可以不传递参数

01:04:22.740 --> 01:04:24.740
Cancel是可以不传递参数的

01:04:24.740 --> 01:04:27.740
Cancel可以不传递参数

01:04:27.740 --> 01:04:29.740
不传递参数

01:04:29.740 --> 01:04:31.740
如果不传递参数

01:04:31.740 --> 01:04:36.740
则取消自己的任务线

01:04:36.740 --> 01:04:39.740
就是当前任务线

01:04:39.740 --> 01:04:40.740
取消当前任务

01:04:40.740 --> 01:04:41.740
那么什么意思呢

01:04:41.740 --> 01:04:45.740
就是说在这个位置

01:04:45.740 --> 01:04:47.740
如果说

01:04:48.740 --> 01:04:51.740
Cancel没有传递参数

01:04:51.740 --> 01:04:54.740
那么他就会把这个任务线取消掉

01:04:54.740 --> 01:04:57.740
你Cancel在写到哪个任务线上的

01:04:57.740 --> 01:04:58.740
他就取消哪个任务线

01:04:58.740 --> 01:05:01.740
就这么个意思

01:05:01.740 --> 01:05:03.740
这个了解一下就行了

01:05:03.740 --> 01:05:05.740
下面这个Cancel

01:05:05.740 --> 01:05:07.740
Cancel的是一个判断

01:05:07.740 --> 01:05:09.740
他是用来判断当前

01:05:09.740 --> 01:05:11.740
他只判断当前任务线

01:05:11.740 --> 01:05:14.740
判断当前任务线

01:05:14.740 --> 01:05:17.740
是否被取消掉

01:05:17.740 --> 01:05:20.740
这个玩意我这里要说一下

01:05:20.740 --> 01:05:22.740
这个虽然有的时候还是有点用

01:05:22.740 --> 01:05:25.740
比方说这条任务线

01:05:25.740 --> 01:05:27.740
这条新开的任务线

01:05:27.740 --> 01:05:29.740
他有可能会被取消

01:05:29.740 --> 01:05:31.740
取消过后我们可能会做一些事情

01:05:31.740 --> 01:05:32.740
就对这个任务而言

01:05:32.740 --> 01:05:33.740
他自己被取消掉了

01:05:33.740 --> 01:05:34.740
他可能要

01:05:34.740 --> 01:05:36.740
他得知道我自己被取消掉了

01:05:36.740 --> 01:05:37.740
我要做一些事情

01:05:37.740 --> 01:05:38.740
那么比方说

01:05:38.740 --> 01:05:40.740
如果说我在这里写

01:05:40.740 --> 01:05:43.740
任务被取消了

01:05:43.740 --> 01:05:44.740
任务被取消了

01:05:44.740 --> 01:05:45.740
我能收到这个通知吗

01:05:45.740 --> 01:05:47.740
是不是肯定收不到

01:05:47.740 --> 01:05:48.740
取消任务

01:05:48.740 --> 01:05:49.740
他不是说结束循环

01:05:49.740 --> 01:05:50.740
就完了

01:05:50.740 --> 01:05:51.740
他整个函数都结束了

01:05:51.740 --> 01:05:53.740
整个函数都不在往后面运行了

01:05:53.740 --> 01:05:57.740
所以这个代码是执行不到的

01:05:57.740 --> 01:06:00.740
但是在函数里面有一个东西

01:06:00.740 --> 01:06:02.740
它是无论如何都会被执行到的

01:06:02.740 --> 01:06:04.740
就是finally

01:06:04.740 --> 01:06:06.740
finally这个代码块

01:06:06.740 --> 01:06:08.740
是无论如何都会被执行到的

01:06:08.740 --> 01:06:11.740
你们之前学的介石应该讲过

01:06:11.740 --> 01:06:14.740
finally是无论如何都会被执行到的

01:06:14.740 --> 01:06:15.740
那么在finally里面

01:06:15.740 --> 01:06:16.740
你就可以判断

01:06:16.740 --> 01:06:19.740
如果说我这个任务是被取消掉的

01:06:19.740 --> 01:06:21.740
因为这里肯定是被取消掉的

01:06:21.740 --> 01:06:22.740
因为我这里写的死循环

01:06:22.740 --> 01:06:24.740
那万一这里不是写的死循环了

01:06:24.740 --> 01:06:25.740
那中途被取消掉了

01:06:25.740 --> 01:06:26.740
那你也不知道

01:06:26.740 --> 01:06:27.740
它是不是被取消掉了

01:06:27.740 --> 01:06:28.740
进入finally

01:06:28.740 --> 01:06:29.740
因为它正常运行的话

01:06:29.740 --> 01:06:30.740
运行完这里的代码

01:06:30.740 --> 01:06:31.740
是不是也会进入finally执行

01:06:31.740 --> 01:06:32.740
对吧

01:06:32.740 --> 01:06:33.740
所以说我们这里

01:06:33.740 --> 01:06:36.740
可以写上一个cancel的

01:06:36.740 --> 01:06:37.740
我们可以通过这个函数

01:06:37.740 --> 01:06:39.740
所以加上e有的

01:06:39.740 --> 01:06:41.740
通过这个函数来判断

01:06:41.740 --> 01:06:43.740
我自己是不是被取消掉的

01:06:43.740 --> 01:06:44.740
是不是被取消掉了

01:06:44.740 --> 01:06:46.740
那么我们这里就输出

01:06:47.740 --> 01:06:50.740
自动增加任务

01:06:50.740 --> 01:06:52.740
被取消掉了

01:06:52.740 --> 01:06:54.740
我们可以通过这个东西来判断

01:06:54.740 --> 01:06:55.740
来做一些收尾的工作

01:06:55.740 --> 01:06:57.740
比方说我们取消掉过后

01:06:57.740 --> 01:06:58.740
可能还要做一些事情

01:06:58.740 --> 01:06:59.740
那么这里呢

01:06:59.740 --> 01:07:00.740
我们就可以进行处理的

01:07:00.740 --> 01:07:02.740
这么个意思

01:07:02.740 --> 01:07:05.740
比方说我们这里

01:07:05.740 --> 01:07:06.740
out to increase

01:07:06.740 --> 01:07:07.740
增加

01:07:08.740 --> 01:07:09.740
out to increase

01:07:09.740 --> 01:07:10.740
你看

01:07:10.740 --> 01:07:11.740
自动增加任务是不是被取消掉了

01:07:11.740 --> 01:07:12.740
因此呢

01:07:12.740 --> 01:07:13.740
它可以收到这个通知

01:07:13.740 --> 01:07:14.740
可以收到这个通知

01:07:14.740 --> 01:07:16.740
可以做一些收尾的工作

01:07:16.740 --> 01:07:17.740
好

01:07:17.740 --> 01:07:19.740
这是关于cancel的

01:07:19.740 --> 01:07:20.740
好

01:07:20.740 --> 01:07:21.740
下面这个

01:07:21.740 --> 01:07:23.740
race

01:07:23.740 --> 01:07:25.740
race表示进赛

01:07:25.740 --> 01:07:28.240
进赛

01:07:28.240 --> 01:07:30.240
它是会造成主色的

01:07:30.240 --> 01:07:32.240
它会造成主色

01:07:32.240 --> 01:07:34.240
进赛

01:07:34.240 --> 01:07:35.240
那么这个进赛

01:07:35.240 --> 01:07:36.240
什么意思呢

01:07:36.240 --> 01:07:37.240
就是说

01:07:37.240 --> 01:07:40.240
可以传递多个任务

01:07:40.240 --> 01:07:42.240
多个任务

01:07:42.240 --> 01:07:44.240
多个指令

01:07:44.240 --> 01:07:46.240
当一个

01:07:46.240 --> 01:07:49.240
当其中任何一个指令

01:07:49.240 --> 01:07:51.240
结束后

01:07:51.240 --> 01:07:53.240
会

01:07:53.240 --> 01:07:55.240
直接结束

01:07:55.240 --> 01:07:56.240
它不像or

01:07:56.240 --> 01:07:57.240
or是什么

01:07:57.240 --> 01:07:58.240
or是这个所有指令

01:07:58.240 --> 01:07:59.240
必须要全部结束过后

01:07:59.240 --> 01:08:01.240
才能结束对吧

01:08:01.240 --> 01:08:02.240
那么这个race呢

01:08:02.240 --> 01:08:03.240
跟那个promise

01:08:03.240 --> 01:08:04.240
race一样

01:08:04.240 --> 01:08:05.240
与

01:08:05.240 --> 01:08:06.240
promise

01:08:06.240 --> 01:08:08.240
race

01:08:08.240 --> 01:08:09.240
类似

01:08:09.240 --> 01:08:10.240
就是promise

01:08:10.240 --> 01:08:11.240
race

01:08:11.240 --> 01:08:12.240
是不是一个promise

01:08:12.240 --> 01:08:13.240
resolve之后

01:08:13.240 --> 01:08:14.240
就结束了对吧

01:08:14.240 --> 01:08:15.240
那么这里呢

01:08:15.240 --> 01:08:16.240
race也是一样的

01:08:16.240 --> 01:08:17.240
promise or

01:08:17.240 --> 01:08:18.240
是要所有的promise

01:08:18.240 --> 01:08:19.240
全部结束

01:08:19.240 --> 01:08:20.240
才能结束

01:08:20.240 --> 01:08:21.240
这个race就是这个意思

01:08:21.240 --> 01:08:22.240
好

01:08:22.240 --> 01:08:24.240
咱们还是来举个例子吧

01:08:24.240 --> 01:08:25.240
好

01:08:25.240 --> 01:08:26.240
我们呢

01:08:26.240 --> 01:08:27.240
这里呢

01:08:27.240 --> 01:08:28.240
我看一下

01:08:28.240 --> 01:08:29.240
这里又复制一个

01:08:29.240 --> 01:08:30.240
又复制一个

01:08:30.240 --> 01:08:32.240
我想一想

01:08:32.240 --> 01:08:34.240
想一想有什么例子呢

01:08:34.240 --> 01:08:35.240
先举个例子吧

01:08:35.240 --> 01:08:37.240
了解一下这个逻辑就行了

01:08:37.240 --> 01:08:38.240
这里呢

01:08:38.240 --> 01:08:40.240
我们还是复刻一个out to task

01:08:40.240 --> 01:08:42.240
还是复刻一个这个玩意

01:08:42.240 --> 01:08:43.240
好

01:08:43.240 --> 01:08:44.240
这里面呢

01:08:44.240 --> 01:08:45.240
我们去写这么一个玩意

01:08:45.240 --> 01:08:47.240
就随便写一个

01:08:47.240 --> 01:08:49.240
就是我们现在要用race

01:08:49.240 --> 01:08:52.240
race

01:08:52.240 --> 01:08:53.240
然后呢

01:08:53.240 --> 01:08:55.240
我们这里写上这么一个race

01:08:55.240 --> 01:08:57.240
race

01:08:57.240 --> 01:08:58.240
好

01:08:58.240 --> 01:08:59.240
race里边传的是啥呢

01:08:59.240 --> 01:09:00.240
传的是一个对象

01:09:00.240 --> 01:09:01.240
这个对象的属性名

01:09:01.240 --> 01:09:02.240
你自己规定

01:09:02.240 --> 01:09:04.240
自行规定这个属性名

01:09:04.240 --> 01:09:05.240
好

01:09:05.240 --> 01:09:06.240
这个属性名自行规定

01:09:06.240 --> 01:09:07.240
规定了过后呢

01:09:07.240 --> 01:09:08.240
每个属性对应什么呢

01:09:08.240 --> 01:09:10.240
对应一个指令

01:09:10.240 --> 01:09:11.240
每个属性呢

01:09:11.240 --> 01:09:12.240
对应一个指令

01:09:12.240 --> 01:09:13.240
好

01:09:13.240 --> 01:09:14.240
比方说我们这里呢

01:09:14.240 --> 01:09:15.240
当然前面要加eo

01:09:15.240 --> 01:09:17.240
这个毫无疑问

01:09:17.240 --> 01:09:18.240
每个属性呢

01:09:18.240 --> 01:09:19.240
对应一个指令

01:09:19.240 --> 01:09:21.240
比方说我们这里

01:09:21.240 --> 01:09:23.240
写上这么一个一步的函数

01:09:23.240 --> 01:09:26.240
sync

01:09:26.240 --> 01:09:28.240
sync

01:09:28.240 --> 01:09:30.240
sync

01:09:30.240 --> 01:09:32.240
task

01:09:32.240 --> 01:09:34.240
一个一步函数

01:09:34.240 --> 01:09:37.240
我们看一下这里用什么呢

01:09:37.240 --> 01:09:39.240
用什么一步函数呢

01:09:39.240 --> 01:09:41.240
用个啥一步函数呢

01:09:41.240 --> 01:09:46.240
我们用一个sync

01:09:46.240 --> 01:09:47.240
sync

01:09:47.240 --> 01:09:48.240
sync

01:09:48.240 --> 01:09:49.240
对吧

01:09:49.240 --> 01:09:50.240
我们用个sync

01:09:50.240 --> 01:09:51.240
sync

01:09:51.240 --> 01:09:52.240
就是一步的得到一个sync

01:09:52.240 --> 01:09:55.240
一步的得到一个sync

01:09:55.240 --> 01:09:56.240
那么得到什么sync呢

01:09:56.240 --> 01:09:57.240
我也说不准

01:09:57.240 --> 01:09:58.240
我也说不准

01:09:58.240 --> 01:09:59.240
为了更加方便来写

01:09:59.240 --> 01:10:00.240
这个东西呢

01:10:00.240 --> 01:10:01.240
我们这里呢

01:10:01.240 --> 01:10:03.240
还可以利用一个水积数嘛

01:10:03.240 --> 01:10:05.240
我们每隔一段时间过后

01:10:05.240 --> 01:10:06.240
隔一段时间过后

01:10:06.240 --> 01:10:07.240
来得到一个

01:10:07.240 --> 01:10:08.240
就是得到一个东西

01:10:08.240 --> 01:10:09.240
得到一个sync

01:10:09.240 --> 01:10:10.240
好

01:10:10.240 --> 01:10:11.240
tick

01:10:11.240 --> 01:10:12.240
得到一段时间

01:10:12.240 --> 01:10:13.240
或者是duration嘛

01:10:13.240 --> 01:10:15.240
得到一段时间

01:10:15.240 --> 01:10:17.240
我们来用个水积数来生成

01:10:17.240 --> 01:10:19.240
messfloor

01:10:19.240 --> 01:10:20.240
比方说

01:10:20.240 --> 01:10:21.240
三千

01:10:21.240 --> 01:10:23.240
一千到五千毫秒

01:10:23.240 --> 01:10:24.240
一千到五千毫秒

01:10:24.240 --> 01:10:26.240
那么就是mess.radon

01:10:26.240 --> 01:10:27.240
乘以四千

01:10:27.240 --> 01:10:28.240
对吧

01:10:28.240 --> 01:10:29.240
加上一千

01:10:29.240 --> 01:10:30.240
那么这样子

01:10:30.240 --> 01:10:31.240
就是一千到五千毫秒

01:10:31.240 --> 01:10:32.240
对吧

01:10:32.240 --> 01:10:33.240
这个代码

01:10:33.240 --> 01:10:34.240
打个注射

01:10:34.240 --> 01:10:36.240
生成一个

01:10:36.240 --> 01:10:40.240
一千到五千毫秒的

01:10:40.240 --> 01:10:42.240
水积时间

01:10:42.240 --> 01:10:43.240
水积时间

01:10:43.240 --> 01:10:44.240
好

01:10:44.240 --> 01:10:45.240
那么这里呢

01:10:45.240 --> 01:10:46.240
我们写一个set timeout

01:10:46.240 --> 01:10:48.240
然后我们返回一个new promise

01:10:48.240 --> 01:10:50.240
返回一个new promise

01:10:50.240 --> 01:10:52.240
result

01:10:52.240 --> 01:10:53.240
好

01:10:53.240 --> 01:10:55.240
返回这个东西

01:10:55.240 --> 01:10:56.240
然后呢

01:10:56.240 --> 01:10:57.240
我们这里呢

01:10:57.240 --> 01:10:58.240
set timeout

01:10:58.240 --> 01:10:59.240
set timeout

01:10:59.240 --> 01:11:01.240
生成一个水积时间嘛

01:11:02.240 --> 01:11:03.240
这里呢

01:11:03.240 --> 01:11:04.240
我们就用duration

01:11:04.240 --> 01:11:05.240
得到一个水积时间

01:11:05.240 --> 01:11:06.240
好

01:11:06.240 --> 01:11:07.240
这个水积时间到了过后呢

01:11:07.240 --> 01:11:08.240
我们返回一个

01:11:08.240 --> 01:11:09.240
得到一个x

01:11:09.240 --> 01:11:10.240
得到什么x呢

01:11:10.240 --> 01:11:11.240
我们也水积

01:11:11.240 --> 01:11:12.240
rather

01:11:12.240 --> 01:11:13.240
如果说大约零点五

01:11:13.240 --> 01:11:15.240
我们resolve一个x

01:11:15.240 --> 01:11:16.240
什么x呢

01:11:16.240 --> 01:11:17.240
这个x呢

01:11:17.240 --> 01:11:18.240
我们给它去

01:11:18.240 --> 01:11:19.240
就是increase

01:11:19.240 --> 01:11:20.240
increase

01:11:20.240 --> 01:11:21.240
好

01:11:21.240 --> 01:11:22.240
else呢

01:11:22.240 --> 01:11:23.240
我们就使用decrease

01:11:23.240 --> 01:11:24.240
就减少

01:11:25.240 --> 01:11:26.240
resolve

01:11:26.240 --> 01:11:27.240
decrease

01:11:28.240 --> 01:11:29.240
行了啊

01:11:29.240 --> 01:11:30.240
于是呢

01:11:30.240 --> 01:11:31.240
我们得到这么一个异步函数

01:11:31.240 --> 01:11:32.240
它返回的是一个promise

01:11:32.240 --> 01:11:33.240
那么现在

01:11:33.240 --> 01:11:34.240
我们要去调用这个异步函数

01:11:34.240 --> 01:11:35.240
对吧

01:11:35.240 --> 01:11:36.240
我们要用扩去调用这个异步函数

01:11:36.240 --> 01:11:37.240
好

01:11:37.240 --> 01:11:38.240
来吧

01:11:38.240 --> 01:11:39.240
我们去调用这个异步函数

01:11:39.240 --> 01:11:40.240
我们这个

01:11:40.240 --> 01:11:41.240
这个taps就不要了

01:11:41.240 --> 01:11:42.240
好

01:11:42.240 --> 01:11:43.240
我们去调用这个异步函数

01:11:43.240 --> 01:11:44.240
那么有

01:11:44.240 --> 01:11:45.240
有可能会出现这种情况

01:11:45.240 --> 01:11:46.240
我这里呢

01:11:46.240 --> 01:11:47.240
有多个

01:11:47.240 --> 01:11:48.240
就是要

01:11:48.240 --> 01:11:50.240
同时去调用几个异步函数

01:11:50.240 --> 01:11:51.240
那么

01:11:51.240 --> 01:11:52.240
只要有一个

01:11:52.240 --> 01:11:53.240
一个完成了

01:11:53.240 --> 01:11:55.240
那么我就整个就完成了

01:11:55.240 --> 01:11:56.240
就不像

01:11:56.240 --> 01:11:57.240
or必须要

01:11:57.240 --> 01:11:58.240
所有的全部完成

01:11:58.240 --> 01:11:59.240
我才能完成

01:11:59.240 --> 01:12:00.240
但是这里res

01:12:00.240 --> 01:12:01.240
只要有一个完成就行了

01:12:01.240 --> 01:12:02.240
好

01:12:02.240 --> 01:12:03.240
那么这里呢

01:12:03.240 --> 01:12:04.240
怎么来

01:12:04.240 --> 01:12:05.240
实现那个

01:12:05.240 --> 01:12:06.240
这个操作呢

01:12:06.240 --> 01:12:07.240
或者说我们在这里呢

01:12:07.240 --> 01:12:08.240
都不用这个

01:12:08.240 --> 01:12:09.240
什么监听呢

01:12:09.240 --> 01:12:10.240
我们直接

01:12:10.240 --> 01:12:11.240
我们直接把这个东西

01:12:11.240 --> 01:12:12.240
写过来也行

01:12:12.240 --> 01:12:15.000
写过来也行

01:12:15.000 --> 01:12:16.000
好

01:12:16.000 --> 01:12:17.000
那么这个res

01:12:17.000 --> 01:12:18.000
我们这里

01:12:18.000 --> 01:12:19.000
就是x1

01:12:19.000 --> 01:12:20.000
x1

01:12:20.000 --> 01:12:21.000
去用call

01:12:21.000 --> 01:12:22.000
调用那个

01:12:22.000 --> 01:12:24.000
调用这个函数

01:12:24.000 --> 01:12:25.000
syncx

01:12:25.000 --> 01:12:27.000
调用这个resinkx

01:12:27.000 --> 01:12:28.000
没有参数

01:12:28.000 --> 01:12:29.000
这是x1

01:12:29.000 --> 01:12:30.000
好

01:12:30.000 --> 01:12:31.000
x2

01:12:31.000 --> 01:12:32.000
x2

01:12:32.000 --> 01:12:33.000
我们也调用

01:12:33.000 --> 01:12:34.000
同一个函数

01:12:34.000 --> 01:12:36.000
也调用同一个函数

01:12:36.000 --> 01:12:37.000
好

01:12:37.000 --> 01:12:38.000
那么这两个函数

01:12:38.000 --> 01:12:39.000
是不是反回

01:12:39.000 --> 01:12:40.000
是不是完成的

01:12:40.000 --> 01:12:41.000
时间点都可能不一样

01:12:41.000 --> 01:12:42.000
因为他们随机的

01:12:42.000 --> 01:12:43.000
对不对

01:12:43.000 --> 01:12:44.000
他们随机的

01:12:44.000 --> 01:12:45.000
这个set timeout是随机的

01:12:45.000 --> 01:12:47.000
完成的时间点都不太一样

01:12:47.000 --> 01:12:48.000
那么但是呢

01:12:48.000 --> 01:12:49.000
只要有一个完成就行了

01:12:49.000 --> 01:12:50.000
好

01:12:50.000 --> 01:12:51.000
这里呢

01:12:51.000 --> 01:12:52.000
我们得到一个结果

01:12:52.000 --> 01:12:54.000
来输出一下这个结果

01:12:54.000 --> 01:12:56.000
输出一下这个结果

01:12:56.000 --> 01:12:57.000
保存

01:12:57.000 --> 01:12:58.000
好

01:12:58.000 --> 01:12:59.000
咱们来看一下

01:13:00.000 --> 01:13:01.000
等待

01:13:01.000 --> 01:13:02.000
是不是等待一个完成就行了

01:13:02.000 --> 01:13:03.000
对不对

01:13:03.000 --> 01:13:04.000
它只等了

01:13:04.000 --> 01:13:05.000
你看这个反回的结果

01:13:05.000 --> 01:13:07.000
是不是只有x1完成了

01:13:07.000 --> 01:13:08.000
对吧

01:13:08.000 --> 01:13:09.000
我们再刷新一次

01:13:09.000 --> 01:13:10.000
再刷新一次

01:13:10.000 --> 01:13:11.000
它只会反回完成的

01:13:11.000 --> 01:13:12.000
x1完成了

01:13:12.000 --> 01:13:13.000
再来

01:13:13.000 --> 01:13:14.000
刷新一次

01:13:14.000 --> 01:13:15.000
x2完成了

01:13:15.000 --> 01:13:16.000
x1没完成

01:13:16.000 --> 01:13:17.000
看到没

01:13:17.000 --> 01:13:19.000
它就用这种方式来处理的

01:13:19.000 --> 01:13:21.000
也就是我们这里可以记一笔

01:13:21.000 --> 01:13:22.000
所以你不去举例子的话

01:13:22.000 --> 01:13:24.000
你很难解释这个东西

01:13:25.000 --> 01:13:27.000
反回的结果

01:13:27.000 --> 01:13:31.000
是最先完成的指令结果

01:13:31.000 --> 01:13:32.000
这个指令结果就是

01:13:32.000 --> 01:13:34.000
那个指令应该反回什么样的结果

01:13:34.000 --> 01:13:35.000
就是什么样的结果

01:13:35.000 --> 01:13:36.000
比方说Promise

01:13:36.000 --> 01:13:37.000
它就反回一个Promise的结果

01:13:37.000 --> 01:13:38.000
反回的结果

01:13:38.000 --> 01:13:40.000
是最先完成的指令结果

01:13:40.000 --> 01:13:43.000
并且该函数

01:13:43.000 --> 01:13:45.000
会自动取消

01:13:45.000 --> 01:13:47.000
自动取消

01:13:47.000 --> 01:13:49.000
之前的

01:13:50.000 --> 01:13:52.000
就是其他的任务

01:13:53.000 --> 01:13:55.000
它会自动取消其他的任务

01:13:55.000 --> 01:13:57.000
你可以认为它这里开启了两个任务

01:13:57.000 --> 01:13:59.000
哪个任务先完成

01:13:59.000 --> 01:14:01.000
剩下的任务全部给你取消掉

01:14:01.000 --> 01:14:02.000
全部给你取消掉

01:14:02.000 --> 01:14:03.000
没了意思吗

01:14:03.000 --> 01:14:05.000
它会自动取消其他的任务

01:14:05.000 --> 01:14:07.000
这就是Race的竞赛

01:14:07.000 --> 01:14:09.000
看谁先跑得快

01:14:09.000 --> 01:14:10.000
谁先跑完

01:14:10.000 --> 01:14:12.000
我就得到谁

01:14:12.000 --> 01:14:13.000
得到对象

01:14:13.000 --> 01:14:15.000
只有完成的对象

01:14:15.000 --> 01:14:17.000
只有完成的对象

01:14:17.000 --> 01:14:18.000
结果

01:14:19.000 --> 01:14:21.000
再看一下

01:14:21.000 --> 01:14:23.000
只有x1完成了

01:14:23.000 --> 01:14:24.000
是这个意思吧

01:14:24.000 --> 01:14:25.000
比方说我们这里可以

01:14:25.000 --> 01:14:28.000
是不是可以触发x1对吧

01:14:28.000 --> 01:14:31.000
这是关于Race

01:14:31.000 --> 01:14:33.000
其实利用Race

01:14:33.000 --> 01:14:35.000
你会发现稍稍做又来了

01:14:35.000 --> 01:14:36.000
利用Race

01:14:36.000 --> 01:14:38.000
我们也可以实现之前的功能

01:14:38.000 --> 01:14:40.000
也可以实现的

01:14:40.000 --> 01:14:43.000
你看着利用Race就可以实现

01:14:43.000 --> 01:14:46.000
利用Race怎么来实现呢

01:14:46.000 --> 01:14:51.000
我们这里把这个玩意

01:14:51.000 --> 01:14:52.000
特别有意思

01:14:52.000 --> 01:14:55.000
只要你能够理解这个任务先

01:14:55.000 --> 01:14:57.000
那么就可以用各种各样的

01:14:57.000 --> 01:14:58.000
稍稍做都行

01:14:58.000 --> 01:15:00.000
因为Race它有个特点

01:15:00.000 --> 01:15:02.000
它只要有一个完成

01:15:02.000 --> 01:15:04.000
那么剩下的一个任务

01:15:04.000 --> 01:15:05.000
就一定会被取消

01:15:05.000 --> 01:15:07.000
剩下的任务就一定会被取消

01:15:07.000 --> 01:15:09.000
那么面对我们现在这样的场景

01:15:09.000 --> 01:15:11.000
面对我们这里的场景

01:15:11.000 --> 01:15:12.000
你看一下我们该可以怎么做呢

01:15:12.000 --> 01:15:14.000
我们可以这样写代吗

01:15:14.000 --> 01:15:15.000
先监听out to increase

01:15:15.000 --> 01:15:17.000
先监听这个

01:15:17.000 --> 01:15:20.000
然后这里面我们用一个Race

01:15:20.000 --> 01:15:22.000
来 进赛

01:15:22.000 --> 01:15:24.000
Race

01:15:24.000 --> 01:15:25.000
看着啊

01:15:25.000 --> 01:15:27.000
Race

01:15:27.000 --> 01:15:32.000
好 第一个是out to increase

01:15:32.000 --> 01:15:33.000
增加

01:15:33.000 --> 01:15:34.000
一个增加

01:15:34.000 --> 01:15:36.000
增加是不是我们调一个core

01:15:36.000 --> 01:15:37.000
调一个core

01:15:37.000 --> 01:15:38.000
core什么呢

01:15:38.000 --> 01:15:40.000
我们这里也写了core的

01:15:40.000 --> 01:15:43.000
core是不是要给它一个啥

01:15:43.000 --> 01:15:45.000
给它一个函数

01:15:45.000 --> 01:15:46.000
对不对

01:15:46.000 --> 01:15:47.000
给它一个函数

01:15:47.000 --> 01:15:49.000
它会去运行这个函数

01:15:49.000 --> 01:15:51.000
是这个意思吧

01:15:51.000 --> 01:15:52.000
它会去运行这个函数

01:15:52.000 --> 01:15:53.000
那么我们比方说

01:15:53.000 --> 01:15:55.000
给它一个生存器函数

01:15:55.000 --> 01:15:56.000
给它一个生存器函数

01:15:56.000 --> 01:15:58.000
然后把这个循环写进来

01:15:58.000 --> 01:16:00.000
使循环写进来

01:16:00.000 --> 01:16:01.000
来吧 你去运行吧

01:16:01.000 --> 01:16:02.000
那你想一想

01:16:02.000 --> 01:16:04.000
这个函数它不结束的话

01:16:04.000 --> 01:16:05.000
它能

01:16:05.000 --> 01:16:06.000
这个函数如果不结束

01:16:06.000 --> 01:16:07.000
是不是永远不会结束

01:16:07.000 --> 01:16:08.000
Race

01:16:08.000 --> 01:16:09.000
永远不会结束

01:16:09.000 --> 01:16:10.000
对不对

01:16:10.000 --> 01:16:11.000
永远不会结束

01:16:11.000 --> 01:16:12.000
它会不会进入下一次监听

01:16:12.000 --> 01:16:14.000
它不会进入下一次监听

01:16:14.000 --> 01:16:16.000
它不会进入下一次监听

01:16:16.000 --> 01:16:18.000
我们把这个去掉

01:16:18.000 --> 01:16:19.000
好 咱们来看一下吧

01:16:19.000 --> 01:16:20.000
看一下

01:16:20.000 --> 01:16:21.000
先看这个

01:16:21.000 --> 01:16:22.000
好 那么现在呢

01:16:22.000 --> 01:16:24.000
我们调 Out to increase

01:16:24.000 --> 01:16:25.000
你看 调一个

01:16:25.000 --> 01:16:27.000
那么由于Race存在

01:16:27.000 --> 01:16:28.000
由于

01:16:28.000 --> 01:16:29.000
为什么它现在可以自动运行

01:16:29.000 --> 01:16:30.000
因为它一调弄了core

01:16:30.000 --> 01:16:31.000
它这里调弄了core

01:16:31.000 --> 01:16:32.000
看到没

01:16:32.000 --> 01:16:33.000
调弄core

01:16:33.000 --> 01:16:34.000
它会运行这个函数

01:16:34.000 --> 01:16:35.000
而这个函数呢

01:16:35.000 --> 01:16:37.000
由于是个生存器函数

01:16:37.000 --> 01:16:39.000
你看它会不断的运行

01:16:39.000 --> 01:16:40.000
对吧 不断的运行

01:16:41.000 --> 01:16:43.000
然后我这里再调弄Out to increase

01:16:43.000 --> 01:16:44.000
它会不会增加呢

01:16:44.000 --> 01:16:45.000
增加它的速度呢

01:16:45.000 --> 01:16:47.000
不会

01:16:47.000 --> 01:16:48.000
这个进程不会受影响

01:16:48.000 --> 01:16:50.000
因为这个Race没有结束

01:16:50.000 --> 01:16:52.000
它现在不再监听这个玩意了

01:16:52.000 --> 01:16:54.000
它监听已经结束了

01:16:54.000 --> 01:16:55.000
它不会再监听这个玩意了

01:16:55.000 --> 01:16:57.000
所以说它现在还在这里运行

01:16:57.000 --> 01:16:58.000
它这个Race结束不了

01:16:58.000 --> 01:16:59.000
下一次循环都进不了

01:16:59.000 --> 01:17:00.000
对不对

01:17:00.000 --> 01:17:02.000
那么我们等到什么时候

01:17:02.000 --> 01:17:03.000
才能继续呢

01:17:03.000 --> 01:17:05.000
因为这个东西是永远不会结束的

01:17:05.000 --> 01:17:06.000
对吧

01:17:06.000 --> 01:17:07.000
我们等这个时候

01:17:07.000 --> 01:17:09.500
看着

01:17:09.500 --> 01:17:10.500
我们等这个时候

01:17:10.500 --> 01:17:11.500
等到什么

01:17:11.500 --> 01:17:12.500
等到那个

01:17:13.500 --> 01:17:14.500
调用什么呢

01:17:15.500 --> 01:17:17.500
我们这里调用

01:17:17.500 --> 01:17:19.500
调用那个cancel

01:17:19.500 --> 01:17:20.500
调用take

01:17:21.500 --> 01:17:23.500
又许监听另外一个

01:17:23.500 --> 01:17:25.500
我们这里不用cancel了

01:17:25.500 --> 01:17:26.500
不用cancel了

01:17:26.500 --> 01:17:28.500
因为它会自动取消

01:17:28.500 --> 01:17:29.500
又许监听这个

01:17:29.500 --> 01:17:34.160
如果你听懂了

01:17:34.160 --> 01:17:35.160
我相信你听到头皮发麻

01:17:35.160 --> 01:17:36.160
还有这种少操作

01:17:37.160 --> 01:17:38.160
你看Race

01:17:38.160 --> 01:17:40.160
两个竞赛一边竞争

01:17:40.160 --> 01:17:41.160
你吧

01:17:41.160 --> 01:17:42.160
你肯定永远不会结束

01:17:42.160 --> 01:17:44.160
那你跑的永远跑不到中电

01:17:44.160 --> 01:17:45.160
但是这个东西是不是

01:17:45.160 --> 01:17:46.160
可能会到中电

01:17:46.160 --> 01:17:48.160
一旦我再去触发一次

01:17:48.160 --> 01:17:49.160
stop auto increase

01:17:49.160 --> 01:17:50.160
是不是这个就完了

01:17:51.160 --> 01:17:52.160
这个指令是不是结束了

01:17:52.160 --> 01:17:53.160
对吧

01:17:53.160 --> 01:17:54.160
这个指令是不是结束了

01:17:54.160 --> 01:17:56.160
因为这个指令会组织

01:17:56.160 --> 01:17:57.160
它等到

01:17:57.160 --> 01:17:58.160
我到时候

01:17:58.160 --> 01:18:00.160
把去触发的这个

01:18:00.160 --> 01:18:02.160
stop auto increase过后

01:18:02.160 --> 01:18:03.160
是不是它就结束了

01:18:03.160 --> 01:18:04.160
它一结束

01:18:04.160 --> 01:18:05.160
是不是它赢了

01:18:05.160 --> 01:18:06.160
它会赢了

01:18:06.160 --> 01:18:07.160
它会自动的把

01:18:07.160 --> 01:18:08.160
其他的任务全部取消掉

01:18:08.160 --> 01:18:09.160
它会自动取消掉

01:18:10.160 --> 01:18:11.160
看一下吧

01:18:11.160 --> 01:18:12.160
auto increase

01:18:13.160 --> 01:18:14.160
那么现在还在竞赛

01:18:14.160 --> 01:18:15.160
对吧

01:18:15.160 --> 01:18:16.160
都在等

01:18:16.160 --> 01:18:17.160
它也在等

01:18:17.160 --> 01:18:18.160
它也在等

01:18:18.160 --> 01:18:19.160
它永远不会结束的

01:18:19.160 --> 01:18:20.160
它永远不会结束的

01:18:20.160 --> 01:18:21.160
那么下一次循环永远不会运行

01:18:22.160 --> 01:18:23.160
下一次循环永远不会运行

01:18:24.160 --> 01:18:25.160
然后这个时候

01:18:25.160 --> 01:18:27.160
突然我给它使用stop

01:18:28.160 --> 01:18:29.160
auto increase

01:18:29.160 --> 01:18:30.160
一停止

01:18:31.160 --> 01:18:32.160
一会发现真的停止了

01:18:32.160 --> 01:18:33.160
为什么停止的

01:18:33.160 --> 01:18:34.160
因为它结束了

01:18:35.160 --> 01:18:36.160
它结束了过后

01:18:36.160 --> 01:18:37.160
它就会自动把这个任务取消掉

01:18:38.160 --> 01:18:39.160
竞赛吗

01:18:39.160 --> 01:18:40.160
对不对

01:18:41.160 --> 01:18:43.160
然后这个整体就结束了

01:18:43.160 --> 01:18:44.160
整个整体结束过后

01:18:45.160 --> 01:18:46.160
整体结束过后

01:18:46.160 --> 01:18:47.160
是不是就进入下一次循环

01:18:48.160 --> 01:18:49.160
对吧

01:18:49.160 --> 01:18:50.160
那如果说你要在取消之后

01:18:50.160 --> 01:18:51.160
做什么事情

01:18:51.160 --> 01:18:52.160
你可以在下面做

01:18:52.160 --> 01:18:53.160
下面做

01:18:53.160 --> 01:18:54.160
下面就是一定是取消掉的结果

01:18:55.160 --> 01:18:56.160
你要这意思吗

01:18:57.160 --> 01:18:58.160
用race也可以

01:18:58.160 --> 01:18:59.160
所以说你会发现

01:18:59.160 --> 01:19:01.160
Saga的功能是非常非常强大的

01:19:01.160 --> 01:19:02.160
它不像上个

01:19:02.160 --> 01:19:03.160
不像promise

01:19:03.160 --> 01:19:05.160
它还在dax里面做文章

01:19:05.160 --> 01:19:07.160
Saga是完全给你开辟

01:19:07.160 --> 01:19:09.160
开辟的一个全新的大门

01:19:09.160 --> 01:19:11.160
你推开这个大门过后

01:19:11.160 --> 01:19:13.160
你会发现各种各样的少操作

01:19:13.160 --> 01:19:14.160
什么操作都可以来

01:19:15.160 --> 01:19:16.160
这是Saga

01:19:17.160 --> 01:19:19.160
它具有丰富的想象力

01:19:19.160 --> 01:19:20.160
和拓展空间

01:19:21.160 --> 01:19:23.160
当然你对于一个初学者而言

01:19:23.160 --> 01:19:25.160
我不是说要求大家

01:19:25.160 --> 01:19:26.160
一开始的对Saga

01:19:26.160 --> 01:19:28.160
就可以达到那么灵活的控制

01:19:28.160 --> 01:19:29.160
这是很难的

01:19:30.160 --> 01:19:32.160
但是你就像我们之前

01:19:32.160 --> 01:19:34.160
讲的这些基础指令

01:19:34.160 --> 01:19:36.160
你得会这些基础指令

01:19:36.160 --> 01:19:37.160
就包括这

01:19:37.160 --> 01:19:38.160
CPS都无所谓了

01:19:38.160 --> 01:19:39.160
CPS我们也很少用

01:19:39.160 --> 01:19:41.160
就这些指令得会

01:19:41.160 --> 01:19:43.160
但是你如果说你能够理解Folk的话

01:19:43.160 --> 01:19:44.160
当然最好

01:19:45.160 --> 01:19:46.160
最好是能够理解Folk

01:19:46.160 --> 01:19:47.160
因为Folk

01:19:47.160 --> 01:19:49.160
他能够干很多很多的事情

01:19:49.160 --> 01:19:51.160
就是说他能够开启一个新任务

01:19:51.160 --> 01:19:52.160
而且不会组设之前的任务

01:19:52.160 --> 01:19:54.160
就可以玩输很多的花样出来

01:19:54.160 --> 01:19:56.160
当然如果说你不用Folk

01:19:56.160 --> 01:19:57.160
你用之前的东西

01:19:57.160 --> 01:19:58.160
也完全没有什么问题

01:19:58.160 --> 01:19:59.160
做一些长过的操作

01:19:59.160 --> 01:20:00.160
完全没有问题了

01:20:01.160 --> 01:20:02.160
就不怕

01:20:02.160 --> 01:20:03.160
就不怕

01:20:03.160 --> 01:20:04.160
就我们学校里面学的那些东西

01:20:04.160 --> 01:20:05.160
一点问题都没有

01:20:05.160 --> 01:20:06.160
学校里面学的一项目

01:20:06.160 --> 01:20:07.160
练习

01:20:07.160 --> 01:20:08.160
一点问题都没有

01:20:08.160 --> 01:20:09.160
就用前面的操作就够了

01:20:09.160 --> 01:20:10.160
当然这里课的东西

01:20:10.160 --> 01:20:11.160
有点深

01:20:11.160 --> 01:20:12.160
你要能够听懂的话

01:20:12.160 --> 01:20:13.160
是最好的

01:20:14.160 --> 01:20:15.160
后边几节课

01:20:15.160 --> 01:20:17.160
我们就是讲Saga的代码分析了

01:20:17.160 --> 01:20:20.160
当然Saga的APN还是没有结束的

01:20:20.160 --> 01:20:21.160
Saga的APN就是

01:20:21.160 --> 01:20:22.160
还有更多的APN

01:20:22.160 --> 01:20:24.160
大家可以去参考中文文档

01:20:24.160 --> 01:20:25.160
因为有些APN

01:20:25.160 --> 01:20:26.160
确实太过于复杂了

01:20:26.160 --> 01:20:27.160
而且

01:20:27.160 --> 01:20:28.160
平时基本上不怎么用

01:20:28.160 --> 01:20:29.160
所以有兴趣的话

01:20:29.160 --> 01:20:31.160
去参考一下中文文档

01:20:31.160 --> 01:20:32.160
下一个开始

01:20:32.160 --> 01:20:34.160
我们来讲他的原码分析

01:20:34.160 --> 01:20:35.160
讲原码分析的时候

01:20:35.160 --> 01:20:36.160
我们下一个课再说

01:20:36.160 --> 01:20:37.160
好吧

01:20:37.160 --> 01:20:38.160
那是一些扩展课程

