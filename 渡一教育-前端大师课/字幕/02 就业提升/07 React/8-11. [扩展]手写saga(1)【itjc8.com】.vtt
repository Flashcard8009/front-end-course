WEBVTT

00:00.690 --> 00:04.290
最后开始我们来讲这个Saga的原码

00:04.290 --> 00:06.490
首先给大家打一个预防针

00:06.490 --> 00:10.390
这个Saga的原码这一部分难度是比较高的

00:10.390 --> 00:13.890
所以说为了大家的身体着想

00:13.890 --> 00:17.090
不会就是初学者了 今天就

00:17.090 --> 00:20.290
如果你特别特别有兴趣的话

00:20.290 --> 00:21.290
你可以看一看

00:21.290 --> 00:22.490
看一看你死过

00:22.490 --> 00:25.090
你如果感觉到自己受到任何的伤害

00:25.090 --> 00:27.790
你就退出来 以后再回过头来看都行

00:27.790 --> 00:30.790
以后工作了一两年了 再回过头来看都行

00:30.790 --> 00:33.790
这一部分的课程主要是准备给那些

00:33.790 --> 00:36.490
已经有了一部分工作经验的同学

00:36.490 --> 00:38.390
就说已经上班了

00:38.390 --> 00:41.790
也利用人爱个词的Saga做了一些事情

00:41.790 --> 00:44.790
再回过头来就给讲生路了解一下Saga

00:44.790 --> 00:47.390
那么再学一下原码

00:47.390 --> 00:50.190
Saga这部分的原码

00:50.190 --> 00:52.790
我当时去阅读原码的时候

00:52.790 --> 00:55.590
它是写的特别特别复杂的

00:55.590 --> 00:57.990
所以说我们这里在讲

00:57.990 --> 01:00.390
而且代码量很大

01:00.390 --> 01:01.390
代码量非常非常大

01:01.390 --> 01:03.390
它不像前面的那个什么桑克

01:03.390 --> 01:04.390
几句话就写完了

01:04.390 --> 01:06.190
Promise 几句话就写完了

01:06.190 --> 01:07.490
它代码量非常非常大

01:07.490 --> 01:10.290
而且细节非常非常多

01:10.290 --> 01:13.490
但是这样子就不利于我们讲解

01:13.490 --> 01:15.990
所以说我看完它的原码之后

01:15.990 --> 01:17.690
我综合了一下

01:17.690 --> 01:21.290
我会按照我的那种方式来书写

01:21.290 --> 01:23.790
就是说我不会完全的按照

01:23.790 --> 01:26.290
它原来的原代码的组织结构来写

01:26.290 --> 01:29.490
但是思路和原力是完全一样的

01:29.490 --> 01:30.490
完全一样的

01:30.490 --> 01:33.190
因为如果用它原来的那种格式来写的话

01:33.190 --> 01:35.390
大家不特别特别不好理解

01:35.390 --> 01:37.590
我都不知道怎么讲了

01:37.590 --> 01:38.490
还有个问题就是

01:38.490 --> 01:41.590
它这个Saga的原代码我看的时候

01:41.590 --> 01:44.190
它那个东西已经是打过一次包的了

01:44.190 --> 01:46.290
就是有些东西它已经合并了

01:46.290 --> 01:47.790
所以说我们在写的时候

01:47.790 --> 01:49.890
不会按照这种结构文件结构

01:49.890 --> 01:52.590
文件结构我可能会把它该分开的时候

01:53.590 --> 01:55.790
因为它已经打过一次包

01:55.790 --> 01:57.190
它已经合并过一次了

01:57.190 --> 01:58.790
它最原式的那种我拿不到

01:58.790 --> 01:59.390
没有

01:59.390 --> 02:01.790
它公开出来的就是开原的原代码部分

02:01.790 --> 02:04.590
它已经把很多东西都已经稍微合并了一下了

02:04.590 --> 02:07.590
但是根据我们分模块的原理

02:07.590 --> 02:09.790
我们还是要把这些功能的把它分开

02:09.790 --> 02:12.090
所以说在文件的组织结构上

02:12.090 --> 02:13.790
不会跟它的原代码一模一样

02:13.790 --> 02:17.390
另外在代码的书写过程中

02:17.390 --> 02:18.790
在代码的书写上

02:18.790 --> 02:21.390
也不会跟它的原代码一样

02:21.490 --> 02:22.590
只能保证说

02:22.590 --> 02:24.990
思路和原理是一样的

02:24.990 --> 02:25.690
就够了

02:26.590 --> 02:29.390
在书写的代码的代码结构上

02:29.390 --> 02:30.890
也不会跟原代码一模一样

02:30.890 --> 02:34.090
比方说有的时候它给你写了一个

02:34.090 --> 02:35.590
比方说用举个例子

02:35.590 --> 02:37.390
比方说给你写了个建筒函数

02:37.390 --> 02:38.990
但是我们这里用的是方式

02:38.990 --> 02:39.790
没有用建筒函数

02:39.790 --> 02:41.390
而且这些细致模型的东西

02:41.390 --> 02:42.590
再跟大家说清楚

02:42.590 --> 02:43.990
不会跟原代码一模一样

02:43.990 --> 02:45.190
因为原代码它考虑的

02:45.190 --> 02:47.090
太多太多的细节了

02:47.090 --> 02:49.190
那么这样子我真的是全部把它

02:49.190 --> 02:51.290
挨在来挨在来说完的话

02:51.390 --> 02:52.890
这个时间太恐怖了

02:52.890 --> 02:54.090
光是讲原代码

02:54.090 --> 02:55.290
要讲好久好久

02:55.290 --> 02:55.990
所以说

02:55.990 --> 02:58.790
因为我们学原代码的目的要明确

02:58.790 --> 02:59.790
目的不是说

02:59.790 --> 03:02.590
我们一个一个跟它做成一个一模一样的东西

03:02.590 --> 03:04.790
我们学它都是思路和原理

03:04.790 --> 03:05.790
它怎么处理

03:05.790 --> 03:07.290
怎么来解决这个问题的

03:07.290 --> 03:09.890
我只要能保证思路和原理一致就行了

03:09.890 --> 03:10.490
好吧

03:10.490 --> 03:12.090
这件先跟大家说清楚

03:12.990 --> 03:14.290
然后写这个杀杆的

03:14.290 --> 03:15.490
我们最弄的目的呢

03:15.490 --> 03:17.090
是要能够写出

03:17.090 --> 03:18.890
我们之前学杀杆

03:18.890 --> 03:19.890
用到了那些什么

03:20.890 --> 03:22.790
把那些功能全部实现

03:22.790 --> 03:24.490
这是咱们学习的目的

03:24.490 --> 03:25.690
代码量很多

03:25.690 --> 03:26.990
肯定一节课讲不完

03:26.990 --> 03:28.390
我们分析一节课来讲

03:28.390 --> 03:29.290
再说一次

03:29.290 --> 03:30.190
如果是初学者

03:30.190 --> 03:30.690
你又兴趣

03:30.690 --> 03:31.890
你看没问题

03:31.890 --> 03:33.490
但是如果你看了过程中

03:33.490 --> 03:35.490
你感觉自己受到了伤害

03:35.490 --> 03:36.890
那么我建议你的

03:36.890 --> 03:39.290
为了避免打击你的学习热情

03:39.290 --> 03:40.790
你可以稍微提一提

03:40.790 --> 03:42.990
这些本来就是高级的知识

03:42.990 --> 03:43.890
需要一点

03:45.890 --> 03:48.290
对代码的控制能力才行

03:48.790 --> 03:50.890
因为这一块杀杆的原代码

03:50.890 --> 03:53.890
其实涉及到很多的基础知识

03:54.690 --> 03:56.690
你像ES6的Promise

03:57.690 --> 04:00.490
你像那个Generator

04:01.990 --> 04:04.990
以及一些就是毁掉这些东西

04:04.990 --> 04:06.990
你把基础掌握得越牢固

04:06.990 --> 04:08.190
那么你取这一块

04:08.190 --> 04:10.390
你的压力的难度呢

04:10.390 --> 04:11.590
就稍微小一点了

04:12.090 --> 04:12.690
好吧

04:12.690 --> 04:13.290
OK啊

04:13.290 --> 04:14.290
说了这么多废话

04:14.290 --> 04:15.690
咱们就开始了

04:16.690 --> 04:17.290
好

04:17.290 --> 04:20.390
这里我们首先看到我们这里的准备的工程

04:20.390 --> 04:20.990
工程的话

04:20.990 --> 04:22.990
我把杀杆就保留了一个index

04:22.990 --> 04:23.890
啥这么写

04:23.890 --> 04:26.890
就保留了最纯粹的一个Generator函数

04:26.890 --> 04:28.190
啥这么写

04:28.190 --> 04:29.490
然后呢

04:29.490 --> 04:30.290
这里边呢

04:30.290 --> 04:31.090
index里边

04:31.090 --> 04:32.490
我们之前用到了一个杀杆

04:32.490 --> 04:32.790
对吧

04:32.790 --> 04:33.690
用了它一个函数叫

04:33.690 --> 04:34.990
createSugMeterware

04:34.990 --> 04:40.210
createSugMeterware

04:40.210 --> 04:43.010
然后它可以创建一个SugMeterium中间键

04:43.010 --> 04:44.510
然后SugMeterium中间里面

04:44.510 --> 04:45.710
还提供了一个ROUND

04:45.710 --> 04:47.110
还提供了一个ROUND函数

04:47.210 --> 04:49.210
来启动一个任务

04:49.210 --> 04:49.910
杀杆任务

04:49.910 --> 04:51.710
这里边要传一个Generator函数

04:51.710 --> 04:53.010
咱们来首先分析一下

04:53.910 --> 04:56.310
那么我们知道了这一点之后呢

04:57.010 --> 04:59.210
我们先来写出这么一个玩意儿

04:59.810 --> 05:01.110
创建中间键这个玩意儿

05:01.110 --> 05:02.310
我们之前是会写过

05:02.310 --> 05:03.510
这个玩意儿很好写

05:03.510 --> 05:04.710
就雕用一个函数

05:04.710 --> 05:06.710
其实这个函数里边还会传一些配置

05:06.710 --> 05:07.110
不过呢

05:07.110 --> 05:08.510
我们这些细致默写的地方

05:08.510 --> 05:09.710
我们就不care了

05:09.710 --> 05:11.110
我们就直接开始写

05:11.110 --> 05:12.410
写到最核心的东西

05:12.410 --> 05:13.410
核心原理

05:13.410 --> 05:14.310
我们学习原代吧

05:14.310 --> 05:16.710
最主要的目的是学它的思路

05:17.310 --> 05:19.110
而不是学习它真正的怎么去写的

05:19.110 --> 05:20.610
那个不重要

05:20.610 --> 05:21.510
没有意思吗

05:21.510 --> 05:25.710
咱们在这里新建个文件夹

05:25.710 --> 05:28.710
该取名为Redux

05:28.710 --> 05:29.310
杀杆

05:30.610 --> 05:32.010
我们自己来写

05:32.010 --> 05:32.310
好

05:32.310 --> 05:33.010
这个里边呢

05:33.010 --> 05:34.510
我们给它新建一个

05:34.510 --> 05:37.810
就是index.js

05:39.410 --> 05:42.010
这个index.js里边写啥呢

05:42.010 --> 05:43.510
是不是就写这个crease

05:44.510 --> 05:46.310
默认导出一个

05:46.310 --> 05:47.910
杀杆metaware

05:47.910 --> 05:49.110
好

05:49.110 --> 05:50.010
来吧

05:50.010 --> 05:51.010
咱们这里呢

05:51.010 --> 05:51.710
字直接

05:51.710 --> 05:52.710
export

05:52.710 --> 05:54.210
defort

05:54.210 --> 05:55.510
导出一个方形

05:55.510 --> 05:56.610
这个方形的名字呢

05:56.610 --> 05:57.310
这个名字呢

05:57.310 --> 05:58.110
其实得导出的时候

05:58.110 --> 05:59.910
默认导出的时候也可以不给名字

05:59.910 --> 06:01.110
这个不所谓

06:01.110 --> 06:03.510
这个打住是

06:03.510 --> 06:04.910
创建

06:04.910 --> 06:05.910
创建

06:05.910 --> 06:07.110
杀杆

06:07.110 --> 06:09.410
中间键的

06:09.410 --> 06:10.810
中间键的

06:10.810 --> 06:11.910
函数

06:11.910 --> 06:13.010
这个函数用干嘛的

06:13.010 --> 06:14.610
用来创建杀杆的中间键

06:16.210 --> 06:17.310
那么通过这个

06:17.310 --> 06:18.910
那么现在我们从这里导出

06:18.910 --> 06:20.410
就从我们自己的位置导入

06:20.410 --> 06:21.610
返回到

06:21.610 --> 06:24.610
返回到你目的

06:24.610 --> 06:25.810
返回到杀杆

06:25.810 --> 06:27.410
通过那个index.js导入这个

06:27.410 --> 06:28.010
那么这个呢

06:28.010 --> 06:29.710
run先暂时不到几写

06:29.710 --> 06:32.210
run先暂时不到几写

06:32.210 --> 06:32.310
好

06:32.310 --> 06:33.910
那么这个中间键咋写呢

06:33.910 --> 06:35.310
中间我们是不是很熟悉

06:35.310 --> 06:35.810
对吧

06:35.810 --> 06:36.910
返回的是一个啥

06:36.910 --> 06:37.310
对不对

06:37.310 --> 06:39.010
返回的是一个就是Stone

06:39.010 --> 06:39.610
然后呢

06:39.610 --> 06:40.410
next

06:40.410 --> 06:40.810
然后呢

06:40.810 --> 06:41.610
什么x

06:41.610 --> 06:42.410
对不对

06:42.510 --> 06:43.510
返回这么一个

06:44.610 --> 06:45.410
高线函数

06:46.110 --> 06:46.810
这是中间键

06:47.610 --> 06:48.010
当然呢

06:48.010 --> 06:49.210
我们这里呢

06:49.710 --> 06:51.810
就不大用箭头函数的模式来写了

06:51.810 --> 06:53.210
我们是用方式来返回

06:53.210 --> 06:53.810
所以也可以

06:53.810 --> 06:55.010
也一样的

06:55.010 --> 06:56.410
为什么用方式来返回呢

06:56.410 --> 06:57.310
跟我们以后

06:57.310 --> 06:57.810
一会呢

06:57.810 --> 06:59.210
写的东西有关系

06:59.210 --> 06:59.810
因为一会呢

06:59.810 --> 07:01.210
我会在这个函数

07:01.210 --> 07:03.210
和这个下面返回的函数之间

07:03.210 --> 07:04.310
要写些代码

07:04.310 --> 07:04.810
所以说呢

07:04.810 --> 07:05.210
我这里呢

07:05.210 --> 07:06.610
需要返回一个方形

07:06.610 --> 07:08.410
稍微好写一点这样子

07:08.410 --> 07:09.810
我们这里这样

07:09.810 --> 07:10.810
返回的是什么呢

07:10.810 --> 07:11.810
返回的是一个方形

07:12.810 --> 07:13.410
方形

07:13.410 --> 07:14.410
就是Saga

07:14.810 --> 07:15.810
Middleware

07:15.810 --> 07:17.010
因为它返回的就是一个Saga

07:17.010 --> 07:17.410
Middleware

07:17.410 --> 07:17.810
对吧

07:18.810 --> 07:19.810
Middleware

07:19.810 --> 07:20.210
好

07:20.210 --> 07:21.410
那么这里的传一个Stone

07:21.410 --> 07:22.010
对吧

07:22.010 --> 07:22.810
一个仓库

07:22.810 --> 07:23.110
然后呢

07:23.110 --> 07:24.310
这个玩意又返回啥

07:24.310 --> 07:25.610
是不是又返回一个方形

07:25.610 --> 07:26.810
这里没有一个next

07:26.810 --> 07:27.810
对吧

07:27.810 --> 07:28.210
这里呢

07:28.210 --> 07:28.910
又返回啥

07:28.910 --> 07:29.810
又返回一个方形

07:29.810 --> 07:31.010
这一个x

07:31.010 --> 07:31.910
对不对

07:31.910 --> 07:33.610
就把箭头函数这种格式呢

07:33.610 --> 07:34.810
写成这种格式

07:34.810 --> 07:35.410
没问题吧

07:35.410 --> 07:36.210
是不是一样的

07:36.210 --> 07:37.210
是一样的

07:37.210 --> 07:38.710
之所以要用这种解法

07:38.710 --> 07:39.810
是因为我一会呢

07:39.810 --> 07:41.610
会在这里加入一些代码

07:41.610 --> 07:43.010
会在这里加入一些代码

07:43.610 --> 07:44.810
好写好了

07:44.810 --> 07:46.610
那么接下来我们把这个中间键实现

07:46.610 --> 07:47.810
实现这个中间键

07:47.810 --> 07:48.810
其实实现这个中间键

07:48.810 --> 07:50.310
我们用一种最简单的方式

07:50.310 --> 07:51.210
就是个中间键

07:51.210 --> 07:52.510
什么作用都没有

07:52.510 --> 07:53.810
啥作用都没有

07:53.810 --> 07:54.910
它直接交用那个是

07:54.910 --> 07:56.010
我啥都不处理

07:56.010 --> 07:57.410
你给我一个X型过后呢

07:57.410 --> 07:59.610
我直接把这个X型交给下一个中间键

07:59.610 --> 08:00.610
我啥都没处理

08:01.810 --> 08:04.010
直接交给

08:05.210 --> 08:07.810
下一个中间键处理

08:08.210 --> 08:09.510
我自己啥都没处理

08:09.510 --> 08:10.610
都是最简单的一个中间键

08:10.610 --> 08:10.910
对吧

08:10.910 --> 08:12.710
我们先想想这么一种格式

08:12.710 --> 08:13.710
并且呢

08:13.710 --> 08:15.310
为了更加通用

08:15.310 --> 08:18.110
因为我不知道下一个中间键是啥

08:18.110 --> 08:19.510
因为这个那个时候是啥

08:19.510 --> 08:21.210
是不是下一个中间键的dispatch

08:21.210 --> 08:22.010
对吧

08:22.010 --> 08:23.510
下一个中间键的这个函数

08:23.510 --> 08:25.510
就下一个中间键的这个函数

08:25.510 --> 08:27.810
那么我不知道下一个中间键是啥

08:27.810 --> 08:30.210
我也不知道他有没有反回结果

08:30.210 --> 08:31.810
比方说我们之前学过sunk

08:31.810 --> 08:33.210
学过promise

08:33.210 --> 08:34.210
他的

08:34.210 --> 08:35.310
这个

08:35.310 --> 08:36.910
这个块的dispatch

08:36.910 --> 08:38.110
是不是有一个反回结果

08:38.110 --> 08:38.410
对吧

08:38.410 --> 08:39.510
他又有反回

08:39.510 --> 08:41.210
那么我也不知道他要反回什么

08:41.210 --> 08:42.110
那这样

08:42.110 --> 08:43.010
他反回什么

08:43.010 --> 08:44.010
我就反回什么

08:44.010 --> 08:45.510
我是不是可以写成这种格式

08:45.510 --> 08:46.810
对吧

08:46.810 --> 08:48.610
我把我去调用下一个中间键

08:48.610 --> 08:49.410
把Icon型传过去

08:49.410 --> 08:50.510
我自己啥都没处理

08:50.510 --> 08:51.210
他反回啥

08:51.210 --> 08:53.010
我就反回啥

08:53.010 --> 08:53.810
是吧

08:53.810 --> 08:54.410
那么这样子呢

08:54.410 --> 08:55.310
更加通用一点

08:55.310 --> 08:56.010
你不能吧

08:56.010 --> 08:56.410
不然的话

08:56.410 --> 08:57.910
你如果说你个三个中间键

08:57.910 --> 08:59.710
后面又加了一些什么sunk

08:59.710 --> 09:00.410
promise

09:00.410 --> 09:01.410
那不太会

09:01.410 --> 09:02.710
就例子嘛

09:02.710 --> 09:04.210
比方说加了一些别的中间键

09:04.210 --> 09:05.410
别的中间他又反回结果

09:05.410 --> 09:06.510
那么你这个

09:06.510 --> 09:08.110
你是不是把反回结果能丢了

09:08.110 --> 09:08.410
对吧

09:08.410 --> 09:10.410
你要把别人的反回结果跟着反回

09:10.410 --> 09:11.310
好

09:11.310 --> 09:12.510
这一块没什么问题吧

09:12.510 --> 09:12.710
好

09:12.710 --> 09:13.210
保持啊

09:13.210 --> 09:14.110
咱们来看一下

09:14.110 --> 09:16.210
那么现在的sunk中间键啥都没做

09:16.210 --> 09:16.910
我们先运行一下

09:16.910 --> 09:17.910
看能不能跑通

09:19.310 --> 09:19.410
啊

09:19.410 --> 09:20.910
这个肯定是没问题的啊

09:20.910 --> 09:22.710
现在没有任何的sunk功能

09:22.710 --> 09:23.410
只是呢

09:23.410 --> 09:25.510
我们把这个中间键呢

09:25.510 --> 09:26.210
交给下一个

09:26.210 --> 09:28.410
就简单的交给下一个就完事了

09:28.410 --> 09:29.210
然后运行起来

09:30.910 --> 09:36.560
稍等一下啊

09:36.560 --> 09:37.260
运行啊

09:38.460 --> 09:40.260
我们这里随便随便写一个嘛

09:40.260 --> 09:41.960
随便去触发一个Icon型

09:41.960 --> 09:43.560
之前不能写过一个increase

09:43.560 --> 09:44.060
对吧

09:44.060 --> 09:46.860
保存在Windows对象里面的increase

09:46.860 --> 09:47.960
触发一个啊

09:47.960 --> 09:48.960
你看说增加了

09:48.960 --> 09:49.260
对吧

09:49.260 --> 09:49.960
增加了啊

09:49.960 --> 09:50.660
触发来个性

09:50.660 --> 09:51.660
啥啥都没做

09:51.660 --> 09:54.060
他就纯粹往后面交就行了

09:54.060 --> 09:55.360
这是目前的中间键

09:55.360 --> 09:56.360
至少能够跑通了

09:58.460 --> 09:59.660
接下来的问题

09:59.660 --> 10:00.960
才是真正的开始啊

10:00.960 --> 10:02.560
才是真正问题的开始

10:02.560 --> 10:03.360
这里的Zoom

10:04.660 --> 10:06.960
这个中间键里边有一个

10:06.960 --> 10:07.460
署项

10:07.460 --> 10:09.460
又是一个方法叫做Zoom

10:09.460 --> 10:10.660
这个方法加给谁的呢

10:10.660 --> 10:11.660
是不是加给他的

10:11.760 --> 10:12.960
因为返回的是这个玩意

10:12.960 --> 10:13.360
对吧

10:13.360 --> 10:14.660
返回的是这么一个函数

10:14.660 --> 10:15.560
你在这个函数

10:15.560 --> 10:17.060
你看返回的是这个东西来接受

10:17.060 --> 10:18.860
然后这个函数里面有一个Zoom方法

10:18.860 --> 10:21.160
也就是说我们在这里是不是要给这个函数

10:21.160 --> 10:23.360
加上一个Zoom方法呀

10:23.360 --> 10:23.560
好了

10:23.560 --> 10:24.860
这这里怎么加呢

10:24.860 --> 10:26.760
这里就是就这样子写起非常简单啊

10:26.760 --> 10:27.460
made with

10:27.460 --> 10:28.260
你不是个函数吗

10:28.260 --> 10:28.460
对吧

10:28.460 --> 10:29.760
你返回就是这个玩意嘛

10:29.760 --> 10:31.860
所以说为什么我要在这里给他写个名字

10:31.860 --> 10:33.960
就是因为我要给他加东西

10:33.960 --> 10:35.460
是不是加上一个Zoom

10:35.460 --> 10:35.760
对吧

10:35.760 --> 10:36.960
加上个Zoom方法

10:36.960 --> 10:37.860
对不对

10:37.860 --> 10:38.360
就这样吧

10:38.360 --> 10:38.760
对不对

10:38.760 --> 10:40.160
给他复制一个函数嘛

10:40.160 --> 10:40.560
是吧

10:40.660 --> 10:41.760
是这个意思吧

10:41.760 --> 10:42.060
啊

10:42.060 --> 10:43.560
给他复制一个函数

10:43.560 --> 10:43.760
对吧

10:43.760 --> 10:44.560
就是这个意思

10:44.560 --> 10:44.760
好

10:44.760 --> 10:45.960
那么这里我要解释一下

10:45.960 --> 10:47.560
因为有些同学肯定有疑问

10:47.560 --> 10:47.860
哎

10:47.860 --> 10:48.760
为什么老师

10:48.760 --> 10:49.160
老师

10:49.160 --> 10:50.360
为什么你要加到这呢

10:50.360 --> 10:51.660
你为什么不写到这呢

10:51.660 --> 10:52.460
嗯

10:52.460 --> 10:53.560
你写到这不行吗

10:53.560 --> 10:53.760
啊

10:53.760 --> 10:55.160
或者说你写到这上面吗

10:55.160 --> 10:55.460
啊

10:55.460 --> 10:56.960
上面不行吗

10:56.960 --> 10:57.760
你写到这嘛

10:57.760 --> 10:58.460
对吧

10:58.460 --> 10:59.660
是不是也可以加啊

10:59.660 --> 11:00.460
三个made with

11:01.660 --> 11:01.960
嗯

11:01.960 --> 11:02.360
你看

11:04.660 --> 11:04.760
哦

11:04.760 --> 11:06.660
这个用的是函数表达式啊

11:06.660 --> 11:08.360
用函数表达式不行

11:08.360 --> 11:10.060
那比方说我们这里写个函数啊

11:10.060 --> 11:10.760
写这么一个函数

11:10.760 --> 11:12.460
最后呢把这个函数返回

11:12.460 --> 11:13.260
杀卡别逗人

11:13.260 --> 11:14.860
这样子写有些梦想呢

11:14.860 --> 11:17.660
这样写语法倒是没有啥问题啊

11:17.660 --> 11:18.460
只不过呢

11:18.460 --> 11:19.460
你想想这个道理

11:20.760 --> 11:21.960
这个wrong是不是

11:23.160 --> 11:24.060
我们的所有

11:24.060 --> 11:25.960
saga里面所有东西起作用

11:25.960 --> 11:27.260
是不是要用到这个wrong

11:27.260 --> 11:27.960
对吧

11:27.960 --> 11:29.360
saga里面东西起作用

11:29.360 --> 11:30.860
是因为这个wrong的存在

11:30.860 --> 11:32.360
如果说你把这个注释掉了

11:32.360 --> 11:33.260
那么这个saga的

11:33.260 --> 11:34.960
我们这个任务是不是启动不了了

11:34.960 --> 11:35.260
对吧

11:35.260 --> 11:36.560
启动不了saga任务了

11:37.360 --> 11:38.360
那既然说

11:38.360 --> 11:42.160
我们这里的启动任务是通过这个wrong完成的

11:42.160 --> 11:43.060
那么这个wrong

11:43.060 --> 11:44.460
他具体做什么事情呢

11:44.460 --> 11:46.160
他肯定是在启动任务

11:46.160 --> 11:47.560
然后呢在维护这个任务

11:47.560 --> 11:48.360
这个任务是啥

11:48.360 --> 11:49.960
就是我们的generator方形

11:49.960 --> 11:51.760
就是我们的生存器函数

11:51.760 --> 11:53.560
他在控制这个生存器函数

11:53.560 --> 11:53.960
然后呢

11:53.960 --> 11:55.160
忍不了让他进行下一步

11:55.160 --> 11:57.460
怎么让他进行下一步啊

11:57.460 --> 11:58.560
这一步得到啥东西

11:58.560 --> 11:59.360
又怎么来控制

11:59.360 --> 11:59.560
对吧

11:59.560 --> 12:01.160
他进行了很多控制

12:01.160 --> 12:02.460
那你回忆一下

12:02.460 --> 12:04.660
咱们saga在控制这些东西的时候

12:04.660 --> 12:06.760
有需不需要用到这个仓库

12:07.760 --> 12:08.360
需不需要

12:08.360 --> 12:09.860
也就是在这个函数里边

12:09.860 --> 12:11.160
需不需要用到这个玩意

12:12.260 --> 12:12.960
是不是需要

12:12.960 --> 12:14.760
因为这里边是不是有dispatch

12:14.760 --> 12:15.160
对吧

12:15.160 --> 12:15.760
我们一会儿

12:15.760 --> 12:16.960
不要到时候用push的时候

12:16.960 --> 12:18.560
push那个附中用函数的时候

12:18.560 --> 12:19.860
是不是要重新触发

12:19.860 --> 12:20.160
对吧

12:20.160 --> 12:21.760
重新那个分发x

12:21.760 --> 12:23.160
或者我们用那个snex

12:23.160 --> 12:24.760
那个附中用的时候呢

12:24.760 --> 12:26.960
那个就是fix的时候呢

12:26.960 --> 12:29.360
我们是不是得到仓库里边的数据

12:29.360 --> 12:29.760
对吧

12:29.760 --> 12:31.660
也就是这里边是要用到啊

12:31.660 --> 12:32.560
需要用到

12:33.760 --> 12:35.160
要用到什么

12:35.160 --> 12:37.560
仓库中的啥

12:37.560 --> 12:38.560
需要用到仓库的啥

12:38.560 --> 12:43.060
是不是就是那个dispatch和get state

12:43.060 --> 12:43.760
对吧

12:43.760 --> 12:44.660
他用到这个

12:44.660 --> 12:45.060
但是呢

12:45.060 --> 12:47.060
如果说你把这个函数写证

12:47.060 --> 12:48.260
你把这个函数写证

12:48.260 --> 12:49.860
你能在这里边

12:49.860 --> 12:51.260
能够得到这个store吗

12:51.260 --> 12:52.160
是不是得不到

12:52.160 --> 12:53.560
所以说这里不能写着啊

12:53.560 --> 12:55.460
不能写着啊

12:55.460 --> 12:56.060
应该写着

12:57.460 --> 12:57.560
好

12:57.560 --> 12:58.260
一同来说

12:58.260 --> 12:59.260
那不能写

12:59.260 --> 13:00.660
那不能写上边

13:00.660 --> 13:02.360
能不能写这儿呢

13:02.360 --> 13:03.560
能不能写这儿呢

13:03.560 --> 13:05.160
谁能不能写这儿啊

13:06.160 --> 13:07.460
写着不行

13:07.460 --> 13:09.160
因为这里的函数里边呢

13:09.160 --> 13:10.860
是每一次触发x

13:10.860 --> 13:12.160
就是这些基本功德掌握的

13:12.160 --> 13:13.560
非常老固才行啊

13:13.560 --> 13:14.960
是每一次触发x

13:14.960 --> 13:15.560
都会运行

13:15.560 --> 13:16.060
对吧

13:16.060 --> 13:17.160
但每一次触发x

13:17.160 --> 13:19.260
你该复制一个新的函数有啥意义呢

13:19.260 --> 13:20.360
这没有什么意义

13:20.360 --> 13:22.660
因为我们这个乱是不是在最开始就调用的

13:22.660 --> 13:22.860
对吧

13:22.860 --> 13:24.360
最开始就调用这个函数了

13:24.360 --> 13:25.560
后面就不再调用了

13:25.560 --> 13:26.760
后面就随便怎么触发x

13:26.760 --> 13:28.160
我都不会再调用这个函数了

13:28.160 --> 13:30.260
所以你这个函数该重新复制干嘛呢

13:30.260 --> 13:30.660
对吧

13:30.660 --> 13:31.560
他每触发一次x

13:31.560 --> 13:33.160
他都会在这里运行一次

13:33.160 --> 13:33.960
没有必要

13:34.760 --> 13:36.160
能不能写这儿呢

13:36.160 --> 13:36.760
这个地方

13:36.760 --> 13:39.660
如果你之前听了我之前的原代码分析过后呢

13:39.660 --> 13:40.160
你知道

13:40.160 --> 13:40.660
这个地方呢

13:40.660 --> 13:41.960
其实也只会运行一次

13:41.960 --> 13:42.460
对吧

13:42.460 --> 13:44.360
这个地方也只会运行一次

13:44.360 --> 13:45.160
一开始运行一次

13:45.160 --> 13:46.460
后面就不会再运行了

13:46.460 --> 13:49.160
那么这个能不能写到这个地方呢

13:49.160 --> 13:49.660
这个地方呢

13:49.660 --> 13:50.860
也没有什么意义

13:50.860 --> 13:52.160
因为我这里边呢

13:52.160 --> 13:54.560
根本就用不到这个next

13:54.560 --> 13:56.160
根本就用不到啊

13:56.160 --> 13:57.960
用不到把它交给下一个中间

13:57.960 --> 13:59.060
因为我们这个

13:59.060 --> 14:01.960
就是说我们这个中间键的本质就是

14:01.960 --> 14:03.960
saga中间键的本质啊

14:05.960 --> 14:09.660
saga中间键的本质

14:09.660 --> 14:10.360
是什么呢

14:10.360 --> 14:14.860
就是将当x型触发时

14:14.860 --> 14:16.760
x型触发时

14:16.760 --> 14:18.460
就是一个啊

14:18.460 --> 14:22.260
就是首先启动一个任务

14:22.260 --> 14:26.660
一个启动一个任务管理

14:26.660 --> 14:27.660
启动一个任务

14:29.060 --> 14:29.660
然后呢

14:29.660 --> 14:32.260
当x型触发时

14:32.260 --> 14:33.260
不能说本质吧

14:33.260 --> 14:33.760
原理嘛

14:33.760 --> 14:39.060
当x型触发时

14:39.060 --> 14:45.060
直接将将x型啊

14:45.060 --> 14:51.260
x型分发到下一个中间键

14:51.260 --> 14:52.460
什么都不做

14:52.460 --> 14:53.760
那么要做的是

14:53.760 --> 14:57.460
就是只有只是在任务里面进行处理

14:57.460 --> 14:58.060
也就是说

14:58.060 --> 14:59.660
当触发真正触发x型的时候

14:59.660 --> 15:00.760
我只要做的事情

15:00.760 --> 15:02.860
就是把这个x型交给下一个中间键

15:02.860 --> 15:03.960
啥都没做

15:03.960 --> 15:06.760
什么事情全是在任务里面处理

15:06.760 --> 15:09.060
任务里面进行管理

15:09.060 --> 15:09.560
好

15:09.560 --> 15:10.560
那么这一块呢

15:10.560 --> 15:11.760
所以要写到这没有意义

15:11.760 --> 15:13.060
因为我根本就不会交给

15:13.060 --> 15:14.860
我不再会交给下个中间键了

15:14.860 --> 15:16.260
交给中间键我已经交过去了

15:16.260 --> 15:16.660
对吧

15:16.660 --> 15:17.860
只要x型触发我就交过去了

15:17.860 --> 15:19.360
根本就不会用到这个next

15:19.360 --> 15:20.360
所以说我们这一块呢

15:20.360 --> 15:21.460
写到这

15:21.460 --> 15:23.460
我们尽量讲细致一点

15:23.460 --> 15:24.460
这些都是有原因的

15:24.460 --> 15:27.060
他为什么要写到这

15:27.060 --> 15:28.060
好那么这里边

15:28.060 --> 15:29.560
你可以想象一下

15:29.560 --> 15:33.260
这个代码的数量一定超级超级多

15:33.260 --> 15:33.860
所以说呢

15:33.860 --> 15:36.260
我们肯定是不会把这个代码写到这

15:36.260 --> 15:36.460
啊

15:36.460 --> 15:37.360
直接肯定肯定

15:37.360 --> 15:39.160
不会直接把代码写到这

15:39.160 --> 15:40.660
那么写到哪呢

15:40.660 --> 15:43.260
我们需要新建一个文件啊

15:43.260 --> 15:45.060
来帮助他在完成这件事

15:45.060 --> 15:45.860
好新建一个文件

15:45.860 --> 15:47.260
比方说我们该取个名字

15:47.260 --> 15:48.660
叫做Rom Saga

15:48.660 --> 15:50.960
这是咱们讲Saga

15:50.960 --> 15:53.360
那个就是原码的时候

15:53.360 --> 15:55.560
最核心的一个方法

15:55.660 --> 15:56.860
什么叫Rom Saga

15:56.860 --> 15:58.760
这个这个这个东西是什么用处

16:01.160 --> 16:01.960
原码分析

16:03.660 --> 16:05.360
第一个Rom Saga

16:07.160 --> 16:08.560
这个函数用于什么呢

16:08.560 --> 16:10.660
用于是一个函数

16:11.760 --> 16:14.060
用于启动一个任务

16:15.460 --> 16:18.560
Saga这里边全是用任务驱动的

16:18.560 --> 16:19.960
因为我们之前讲那个就是吗

16:19.960 --> 16:20.760
像我们Folker的时候

16:20.760 --> 16:22.260
就讲的看到很明确了

16:22.260 --> 16:23.260
对吧

16:23.260 --> 16:24.360
我们比方用于Folker

16:24.360 --> 16:25.960
是不是启动了一个新的任务

16:25.960 --> 16:26.960
然后呢

16:26.960 --> 16:28.560
我们用那个就是

16:28.560 --> 16:29.660
还有TakeAvery

16:29.660 --> 16:31.560
它其实内部也是给你启动了

16:31.560 --> 16:32.360
一个新的任务

16:32.360 --> 16:33.260
对吧

16:33.260 --> 16:33.460
好

16:33.460 --> 16:35.860
那么这个一个任务是怎么启动的

16:35.860 --> 16:38.660
就是调用Rom Saga这个函数启动的

16:39.560 --> 16:42.560
这个函数就是用来启动一个任务

16:42.560 --> 16:44.660
一个任务是啥啊

16:44.660 --> 16:51.160
一个任务的本质是一个Generator方形

16:51.160 --> 16:52.460
就是一个Generator函数

16:53.460 --> 16:56.060
那么Rom Saga在内部

16:57.060 --> 17:05.260
Rom Saga在内部得到该函数的Generator

17:05.260 --> 17:06.660
得到它的生存器

17:06.660 --> 17:07.260
然后呢

17:09.460 --> 17:17.960
并控制生存器的每一次叠弹

17:19.160 --> 17:19.660
对吧

17:19.660 --> 17:20.860
我们知道每一次

17:20.860 --> 17:21.960
用了副作用函数的时候

17:21.960 --> 17:23.060
每一次都要写一个eO的

17:23.060 --> 17:23.360
对吧

17:23.360 --> 17:25.260
那么这个eO的是不是会被生存器

17:25.260 --> 17:26.460
那些东西拿到

17:26.460 --> 17:27.660
eO的结果

17:27.660 --> 17:29.560
接待的结果会被生存器拿到

17:29.560 --> 17:31.560
那么在Rom Saga这个函数内部

17:31.560 --> 17:33.260
就要控制这个东西

17:33.260 --> 17:35.960
所以说我们回过头来再看一下这里

17:35.960 --> 17:36.360
这里呢

17:36.360 --> 17:37.360
我们写了一个Rom

17:37.360 --> 17:37.660
对吧

17:37.660 --> 17:39.560
是不是给它一个生存器函数

17:39.560 --> 17:39.860
对吧

17:39.860 --> 17:41.260
是不是给它一个生存器函数

17:41.260 --> 17:41.760
哎

17:41.760 --> 17:43.760
那么这个Rom其实调用的是啥

17:43.760 --> 17:45.860
调用的就是个Rom Saga函数

17:45.860 --> 17:47.960
就是我们写到这个文件里边的Rom Saga函数

17:47.960 --> 17:48.560
所以说这里呢

17:48.560 --> 17:49.760
我们说了半天

17:49.760 --> 17:50.560
说了半天

17:50.660 --> 17:51.960
无非就是要返回一个东西

17:51.960 --> 17:52.560
对不对

17:52.560 --> 17:54.560
无非这里我们就是要一个sport

17:55.860 --> 17:57.960
导出一个函数

17:57.960 --> 17:59.960
这个函数就是个Rom Saga函数

17:59.960 --> 18:00.160
好

18:00.160 --> 18:00.760
那么这里

18:00.760 --> 18:01.760
in这个是这里的

18:03.060 --> 18:05.060
我们需要in port

18:05.060 --> 18:08.560
然后导入什么Rom Saga这个函数

18:10.960 --> 18:12.760
把这个函数是不是复制过来

18:12.760 --> 18:13.860
对吧

18:13.860 --> 18:15.760
也就是说我们在这个函数里边

18:15.760 --> 18:16.960
这就是

18:16.960 --> 18:19.960
这个函数的重点就是启动一个

18:19.960 --> 18:20.960
任务

18:20.960 --> 18:22.160
启动一个任务

18:22.160 --> 18:24.360
就是开启一个新任务

18:24.360 --> 18:26.360
开启一个新任务

18:27.660 --> 18:28.560
明远这个意思吗

18:28.560 --> 18:29.960
开启这么一个新任务

18:29.960 --> 18:31.660
那么既然要开启一个新任务

18:31.660 --> 18:33.760
你是不是把你是不是得把那个

18:33.760 --> 18:35.160
那个generator函数给它

18:35.160 --> 18:35.860
对吧

18:35.860 --> 18:38.160
你是不是得把generator函数给它

18:38.160 --> 18:40.460
generator方形

18:40.460 --> 18:41.460
对吧

18:41.460 --> 18:42.960
你得把generator函数给它

18:42.960 --> 18:43.760
不然的话

18:43.760 --> 18:45.060
它到哪里去开启任务呢

18:45.060 --> 18:45.760
这个任务

18:45.760 --> 18:46.560
我们刚才说了

18:46.560 --> 18:47.760
这个任务是怎么开启的

18:47.760 --> 18:51.760
就是你给它一个生存器函数

18:51.760 --> 18:53.160
那么它会通过这个函数

18:53.160 --> 18:54.260
得到一个生存器

18:54.260 --> 18:56.060
并通过那个蛇那个蛇那个蛇

18:56.060 --> 18:57.760
控制生存器的每一次迭代

18:57.760 --> 18:57.960
对吧

18:57.960 --> 18:59.160
它就来做这个事情的

18:59.160 --> 19:00.360
就是这个一定要知道啊

19:00.360 --> 19:02.860
那个函数来做什么事情

19:02.860 --> 19:04.060
虽然我说我们现在还没写

19:04.060 --> 19:05.460
但是你要知道它做什么事情

19:05.460 --> 19:07.060
这一点非常关键

19:07.060 --> 19:07.560
那么这里呢

19:07.560 --> 19:09.660
我们打算做是generator方

19:09.660 --> 19:10.360
对吧

19:10.360 --> 19:14.060
这里是一个就是内形式

19:14.060 --> 19:16.260
一个方形

19:16.260 --> 19:17.660
就直接写吧

19:17.860 --> 19:19.360
generator funk

19:19.360 --> 19:22.360
那么这个这个参数的意义是

19:22.360 --> 19:24.960
一个生存器函数

19:24.960 --> 19:26.360
要给我一个生存器函数

19:26.360 --> 19:26.760
其实呢

19:26.760 --> 19:27.960
你给它普通函数行不行

19:27.960 --> 19:28.760
也行

19:28.760 --> 19:30.260
这个可以只是给普通函数

19:30.260 --> 19:31.760
没有什么意义啊

19:31.760 --> 19:32.760
实际上圆骂里边

19:32.760 --> 19:34.060
它进行了判断的

19:34.060 --> 19:35.360
如果它也是普通函数的话

19:35.360 --> 19:36.860
我就直接雕影师就完事了

19:36.860 --> 19:37.560
啥都别做

19:37.560 --> 19:39.060
雕影师就完事了

19:39.060 --> 19:39.460
不过呢

19:39.460 --> 19:41.660
大家我们在写圆骂的时候

19:41.660 --> 19:42.760
就不用去考虑这些了

19:42.760 --> 19:43.760
当然你要判断一下

19:43.760 --> 19:44.360
无所谓

19:44.360 --> 19:45.360
判断就判断没

19:45.360 --> 19:47.160
判断有什么难的呢

19:47.260 --> 19:49.060
没有任何难度

19:49.060 --> 19:49.260
好

19:49.260 --> 19:50.060
我们接下来再来分析

19:50.060 --> 19:51.360
我们先把结构写好

19:51.360 --> 19:52.860
不着急

19:52.860 --> 19:54.260
然后这个Rom Saga

19:54.260 --> 19:56.460
这个生存器函数里边

19:56.460 --> 19:59.160
它这个生存器函数里边

19:59.160 --> 20:00.660
要不要用到Stone

20:00.660 --> 20:01.860
要不要用到倉库

20:01.860 --> 20:03.660
比方Dispatch啊

20:03.660 --> 20:05.560
是那个车啊

20:05.560 --> 20:07.460
是不是有可能会用到

20:07.460 --> 20:09.060
对吧

20:09.060 --> 20:11.360
是不是有可能会用到啊

20:11.360 --> 20:13.560
在这里边是不是有可能会用到

20:13.560 --> 20:15.260
因为我要控制它每一个步骤

20:15.260 --> 20:16.860
比方说你雕了铺扯

20:16.860 --> 20:17.160
对吧

20:17.160 --> 20:18.360
你用了铺扯啊

20:18.360 --> 20:19.160
这个附中

20:19.160 --> 20:20.160
这个Effect

20:20.160 --> 20:21.960
那么我们是不是要派发一个Action

20:21.960 --> 20:22.460
对不对

20:22.460 --> 20:24.960
那么这里边就有可能

20:24.960 --> 20:28.160
要用到一个就是倉库啊

20:28.160 --> 20:28.760
因此呢

20:28.760 --> 20:29.960
我们这边

20:29.960 --> 20:33.160
是不是你是不是还要给我传一个东西过来

20:33.160 --> 20:33.660
啊

20:33.660 --> 20:34.860
还要传一个东西过来

20:34.860 --> 20:35.560
叫Stone

20:35.560 --> 20:35.860
对不对

20:35.860 --> 20:37.460
倉库里边包含了Dispatch

20:37.460 --> 20:38.860
里边包含了什么啊

20:38.860 --> 20:40.860
就是啊

20:40.860 --> 20:42.460
Action

20:42.460 --> 20:42.860
而且呢

20:42.860 --> 20:44.260
我们可以想象的到

20:44.260 --> 20:45.260
这里边可能

20:45.260 --> 20:46.060
可能以后呢

20:46.060 --> 20:48.260
还会有一些额外的东西要传过来

20:48.260 --> 20:49.260
除了倉库之外

20:49.260 --> 20:51.060
可能还有一些别的玩意

20:51.060 --> 20:52.460
那么这些玩意是不是通用的

20:52.460 --> 20:55.660
是在整个这个SACRE的处理过程中要通用

20:55.660 --> 20:56.060
所以说呢

20:56.060 --> 20:58.060
我们第一个位置的参数呢

20:58.060 --> 20:59.460
官方的元代嘛

20:59.460 --> 21:01.160
它是给了这么一个东西啊

21:01.160 --> 21:02.960
env

21:02.960 --> 21:04.060
这个env是什么意思呢

21:04.060 --> 21:06.860
表示的是环境数据

21:06.860 --> 21:11.040
全局环境的数据

21:11.040 --> 21:14.640
表示全局环境的数据

21:14.740 --> 21:16.540
就是有一些通用的数据

21:16.540 --> 21:17.740
我这一块方法要用

21:17.740 --> 21:18.840
另外一个方法要用

21:18.840 --> 21:22.140
在SACRE的执行期间都可以使用

21:22.140 --> 21:25.740
被SACRE执行期

21:25.740 --> 21:31.940
执行期共享的数据

21:31.940 --> 21:33.440
有哪些数据是被共享的

21:33.440 --> 21:35.240
比方说刚才我们说的Stone

21:35.240 --> 21:36.540
就可以放到这个环境

21:36.540 --> 21:37.840
环境边两里边

21:37.840 --> 21:39.540
就是个数据

21:39.540 --> 21:41.140
那么这个玩意就

21:41.140 --> 21:43.040
现在就奇怪了问题是

21:43.140 --> 21:45.240
我们之前调那个RUNSACRE的时候

21:45.240 --> 21:46.940
是不是只传了一个参数啊

21:46.940 --> 21:48.440
那你这里写了两个参数

21:48.440 --> 21:49.440
当时没有传两个参数

21:49.440 --> 21:51.240
也没有传什么环境数据啊

21:51.240 --> 21:52.540
那它是怎么做的呢

21:52.540 --> 21:53.140
看着啊

21:53.140 --> 21:54.940
它是用这种模式来做的

21:54.940 --> 21:56.840
你不是需要一个环境数据吗

21:56.840 --> 21:58.140
我肯定不会让拥护

21:58.140 --> 21:59.840
来给提供给你的环境数据

21:59.840 --> 22:01.340
因为我们要的环境数据

22:01.340 --> 22:01.840
是不是在这

22:01.840 --> 22:03.940
这里就可以拿到了

22:03.940 --> 22:04.340
我们在这里

22:04.340 --> 22:05.540
是不是可以拿到环境数据

22:05.540 --> 22:06.740
比方说可以拿到这个Stone嘛

22:06.740 --> 22:07.440
对不对

22:07.440 --> 22:09.440
我们这里比方写个辩量

22:09.440 --> 22:10.040
写个辩量

22:10.040 --> 22:11.440
env

22:11.440 --> 22:12.040
env是什么

22:12.040 --> 22:13.140
就加一个对象吧

22:13.140 --> 22:14.540
对象里面有一个属性叫Stone

22:15.740 --> 22:16.240
对吧

22:16.240 --> 22:17.740
给它一个属性叫Stone

22:17.740 --> 22:18.340
那么以后呢

22:18.340 --> 22:19.140
肯定还有一些东西

22:19.140 --> 22:20.040
我们要放进来

22:20.040 --> 22:21.940
还有一些东西也要放进来

22:21.940 --> 22:22.440
好

22:22.440 --> 22:23.840
那么这里的有一个环境

22:23.840 --> 22:25.240
环境就是一个辩量

22:25.240 --> 22:25.940
有四个对象

22:25.940 --> 22:27.840
对象里面有一个属性Stone

22:27.840 --> 22:28.540
当然官方里边

22:28.540 --> 22:30.940
它里边列举了好多好多东西

22:30.940 --> 22:32.940
因为它里边是有配置的

22:32.940 --> 22:35.640
还有很多配置的东西都在里边

22:35.640 --> 22:36.840
然后我们这里呢

22:36.840 --> 22:38.440
就可以把这个env

22:38.440 --> 22:39.440
怎么来操作呢

22:39.440 --> 22:40.840
我们用这种方式来操作

22:40.840 --> 22:41.840
用band

22:41.840 --> 22:44.910
好

22:44.910 --> 22:46.710
我们这里调用双saga

22:46.710 --> 22:48.910
使用双saga函数里边的一个band

22:48.910 --> 22:49.210
对吧

22:49.210 --> 22:49.910
还记得吗

22:49.910 --> 22:51.710
band的函数是不是会绑定this的

22:51.710 --> 22:52.410
this无所谓

22:52.410 --> 22:53.810
this给它一个NOW嘛

22:53.810 --> 22:56.210
然后band的函数是不是还可以绑定参数

22:56.210 --> 23:00.810
把第一个参数绑定到这个这个值

23:00.810 --> 23:01.810
那么后边调用

23:01.810 --> 23:03.810
那么这个东西会返回一个新的函数

23:03.810 --> 23:05.710
把这个新的函数复制给wrong

23:05.710 --> 23:08.410
那么后边我们再调用这个wrong的时候

23:08.410 --> 23:09.910
再调用这个wrong的时候

23:09.910 --> 23:12.310
是不是就可以

23:12.310 --> 23:13.610
我们调用这个wrong的时候

23:13.610 --> 23:15.310
是不是只需要传一个函数就行了

23:15.310 --> 23:17.710
因为第一个函数是不是已经绑定下来了

23:17.710 --> 23:19.710
这有点类似于科理化

23:19.710 --> 23:21.210
第一个函数已经绑定下来了

23:21.210 --> 23:23.510
我们只需要传剩余的函数就行了

23:23.510 --> 23:26.110
这就是为什么我这里只需要传一个

23:26.110 --> 23:28.210
对吧

23:28.210 --> 23:29.510
只需要传一个函数

23:29.510 --> 23:32.210
这样的意思吗

23:32.210 --> 23:32.710
好

23:32.710 --> 23:34.110
然后我们现在看一下

23:34.110 --> 23:36.510
看一下现在这个结构这么准确了

23:36.510 --> 23:40.010
我们看一下这个函数有没有运行

23:40.010 --> 23:44.010
一个新的任务启动了

23:44.010 --> 23:45.910
好保存

23:45.910 --> 23:47.710
再看看函数是不是运行了

23:47.710 --> 23:48.210
对吧

23:48.210 --> 23:51.950
咱们这个结构就写出来了

23:51.950 --> 23:52.650
好

23:52.650 --> 23:53.650
然后我们再来

23:53.650 --> 23:55.550
先不要说这个函数里面怎么去实现

23:55.550 --> 23:56.350
我们再来分析

23:56.350 --> 23:58.250
先把结构写好

23:58.250 --> 24:01.450
这个函数又不要返回值了

24:01.450 --> 24:02.750
这里我直接告诉大家

24:02.750 --> 24:03.650
大家肯定是想不到

24:03.650 --> 24:05.250
它有一个返回值

24:05.250 --> 24:09.050
这个返回值是一个task对象

24:09.050 --> 24:10.950
是一个task对象

24:10.950 --> 24:12.150
那么这个task对象

24:12.150 --> 24:13.750
官方有他官方的做法

24:13.750 --> 24:16.750
然后我们用我们自己简单的做法就行了

24:16.750 --> 24:18.250
用一个简单的做法就行了

24:18.250 --> 24:19.850
因为这个东西不重要

24:19.850 --> 24:21.250
重要的是我们直接它的原理

24:21.250 --> 24:23.150
就是task对象的结构是啥

24:23.150 --> 24:23.950
官方是这个结构

24:23.950 --> 24:25.650
那就说袁老师你想的是这种结构

24:25.650 --> 24:27.250
另外一种结构跟官方的不一样

24:27.250 --> 24:28.150
有啥区别呢

24:28.150 --> 24:30.650
我们只需要返回的是一个task对象就行了

24:30.650 --> 24:32.150
为什么要返回呢

24:32.150 --> 24:33.750
因为就是这个函数

24:33.750 --> 24:37.350
这个函数它启动的是一个任务

24:37.350 --> 24:39.150
那么我们返回这个任务对象

24:39.250 --> 24:41.350
是来帮助管理这个任务的

24:41.350 --> 24:43.850
这个对象的后边会有用

24:43.850 --> 24:45.550
暂时目前没有什么用

24:45.550 --> 24:47.450
那我们暂时就写个最简单的版本

24:47.450 --> 24:52.050
我们这里的新建一个task.js

24:52.050 --> 24:54.850
那你这里面我们就导出一个内

24:54.850 --> 24:56.450
task这个内

24:56.450 --> 24:58.850
这个内是空的啥都没有

24:58.850 --> 25:00.150
官方是不是这样写的

25:00.150 --> 25:01.650
不是这样写的

25:01.650 --> 25:02.150
不是这样写的

25:02.150 --> 25:03.750
但是不重要

25:03.750 --> 25:05.550
我们这里就可以用这种方式来写

25:05.550 --> 25:07.250
总之官方返回了一个task对象

25:07.250 --> 25:09.050
我们也返回了一个task对象

25:09.050 --> 25:09.950
总之task对象呢

25:09.950 --> 25:10.850
它用来做什么呢

25:10.850 --> 25:12.350
用来管理任务的

25:12.350 --> 25:13.950
我们现在对现在没什么用

25:13.950 --> 25:14.950
现在没有什么用

25:14.950 --> 25:17.550
所以说我们只是把这个结构给它写出来

25:17.550 --> 25:18.950
这个结构我们之后会用

25:18.950 --> 25:20.650
最终我们会返回一个啥呢

25:20.650 --> 25:24.350
会返回一个6一个task对象

25:24.350 --> 25:27.150
会返回一个task对象

25:28.850 --> 25:29.750
问题吧

25:29.750 --> 25:31.150
其实我们可以看一下

25:31.150 --> 25:33.250
看一下官方它的返回结构

25:33.250 --> 25:34.850
我们返回的就是一个空对象

25:34.850 --> 25:36.750
用构造函数产生的task

25:36.750 --> 25:37.850
我跟大家说一下

25:37.850 --> 25:38.850
有什么不一样的

25:38.850 --> 25:40.150
就这个地方不一样

25:40.150 --> 25:41.450
给它看一下吧

25:41.450 --> 25:41.950
wrong

25:41.950 --> 25:43.150
wrong是不是叫wrong saga

25:43.150 --> 25:43.750
对吧

25:43.750 --> 25:45.150
那么现在我们用的是官方的

25:45.150 --> 25:46.150
用的是官方的

25:46.150 --> 25:47.050
来看一下吧

25:47.050 --> 25:48.750
官方的task对象

25:48.750 --> 25:50.350
task

25:50.350 --> 25:51.450
输出一下task

25:51.450 --> 25:52.550
好 保存

25:52.550 --> 25:53.750
离开一下

25:53.750 --> 25:55.450
返回的就是一个task对象

25:55.450 --> 25:57.550
它用了一个特殊的属性

25:57.550 --> 25:58.750
叫做两个at

25:58.750 --> 26:00.950
Redug是Hungang saga task

26:00.950 --> 26:02.050
用这么一个特殊的属性

26:02.050 --> 26:02.950
把它设为true

26:02.950 --> 26:04.650
用这个东西来标识

26:04.650 --> 26:05.950
这是一个task对象

26:05.950 --> 26:07.950
然后它是一个plane object

26:07.950 --> 26:10.550
它用的是objects的原型

26:10.550 --> 26:11.550
我们用的是什么

26:11.550 --> 26:14.250
task自己写的构造函数的原型

26:14.250 --> 26:16.050
你看这个对象里面是不是有很多方法

26:16.050 --> 26:17.250
比方说这里取消任务

26:17.250 --> 26:18.050
对不对

26:18.050 --> 26:19.850
等等等等

26:19.850 --> 26:22.150
有很多方法

26:22.150 --> 26:23.150
没问题吧

26:23.150 --> 26:24.150
这就是一个task对象

26:24.150 --> 26:24.750
我们只不过

26:24.750 --> 26:27.850
我们根本没有用这种模式来做

26:27.850 --> 26:29.250
仅此而已

26:29.250 --> 26:31.450
并没有用这种模式来做

26:31.450 --> 26:33.150
我们这里就用一个构造函数来写

26:33.150 --> 26:35.520
就行了

26:35.520 --> 26:36.620
道理是一样的

26:36.620 --> 26:40.120
道理都是一样的

26:40.120 --> 26:42.020
这个对象我们目前没啥用

26:42.020 --> 26:44.020
后边有用

26:44.020 --> 26:44.620
行了

26:44.620 --> 26:46.020
咱们说了半天

26:46.020 --> 26:46.720
我们这里看一下

26:46.720 --> 26:49.420
我们自己写的task

26:49.420 --> 26:50.320
task

26:50.320 --> 26:51.520
包吹

26:51.520 --> 26:52.620
你看是不是task

26:52.620 --> 26:53.120
构造函数

26:53.120 --> 26:53.620
对不对

26:53.620 --> 26:57.020
有构造函数

26:57.020 --> 27:00.520
现在我们这里写好了这么一种结构

27:00.520 --> 27:03.120
这个结构基本的股价就写出来了

27:03.120 --> 27:04.720
那么写出来之后

27:04.720 --> 27:06.820
现在关键是在这一部分

27:06.820 --> 27:07.720
这一部分

27:07.720 --> 27:10.220
怎么去启动一个任务

27:10.220 --> 27:13.620
什么叫做启动一个任务

27:13.620 --> 27:16.520
这里我需要画张图给大家分析一下

27:16.520 --> 27:17.920
咱们切割到桌面

27:17.920 --> 27:19.020
建了一个ppt

27:19.020 --> 27:20.120
有点画张图

27:20.120 --> 27:24.020
其他原理是特别特别简单和纯粹的

27:24.020 --> 27:26.020
sug的原理特别特别好理解

27:26.020 --> 27:28.120
之前的75个也给大家说过了

27:28.120 --> 27:29.820
他就是启动一个任务

27:29.820 --> 27:31.620
然后这个任务来管理一个什么

27:31.620 --> 27:33.620
管理一个生存器

27:33.620 --> 27:34.920
再管理一个生存器

27:34.920 --> 27:36.420
让它不断的进行迭代

27:36.420 --> 27:37.120
对不对

27:37.120 --> 27:40.620
所以让sug的做的事情很简单

27:40.620 --> 27:45.420
sug就是管理一个生存器

27:45.420 --> 27:49.120
让其不断的迭代

27:49.120 --> 27:50.420
生存器不就用来迭代的吗

27:50.420 --> 27:51.820
不断的去调到它的next

27:51.820 --> 27:52.620
对不对

27:52.620 --> 27:54.220
就是他做的事情

27:54.220 --> 27:55.220
那么迭代的过程中

27:55.220 --> 27:56.520
是不是会遇到eO的

27:56.520 --> 27:57.720
每一次调到next

27:57.720 --> 27:59.620
是不是会遇到eO的那个位置

27:59.620 --> 28:01.420
eO的那个位置返回的结果

28:01.420 --> 28:04.220
那个表达是就是next得到了字

28:04.220 --> 28:05.420
对不对

28:05.420 --> 28:06.020
好

28:06.020 --> 28:07.620
那么每一次eO的的时候

28:07.620 --> 28:09.720
是不是会有这么affix

28:09.720 --> 28:10.120
对不对

28:10.120 --> 28:11.220
affix给它

28:11.220 --> 28:12.120
那么affix呢

28:12.120 --> 28:12.920
就有很多

28:12.920 --> 28:13.620
我们看一下吧

28:13.620 --> 28:15.420
affix

28:15.420 --> 28:16.920
我们一会儿会写affix

28:16.920 --> 28:18.020
现在得到几

28:18.020 --> 28:19.320
affix有很多

28:19.320 --> 28:20.820
比方说有什么

28:20.820 --> 28:21.720
puts呀

28:21.720 --> 28:22.820
snext呀

28:22.820 --> 28:24.820
or什么take呀

28:24.820 --> 28:27.220
take every呀

28:27.220 --> 28:28.220
every

28:28.220 --> 28:29.320
还有什么

28:29.320 --> 28:30.920
来去顺便总结一下

28:30.920 --> 28:31.520
还有什么

28:31.520 --> 28:33.220
还有那个fork

28:33.220 --> 28:33.920
对吧

28:33.920 --> 28:35.120
还有什么

28:35.120 --> 28:36.320
还有denay

28:36.320 --> 28:37.220
还有call

28:37.220 --> 28:38.220
什么apply

28:38.220 --> 28:38.920
对不对

28:38.920 --> 28:40.520
还有啥

28:40.520 --> 28:42.020
还有啥

28:42.020 --> 28:43.020
就是这么一些嘛

28:43.020 --> 28:43.820
比方说就这么一些

28:43.820 --> 28:45.320
我们后边写的时候再说

28:45.320 --> 28:47.320
那么这里的每一个affix呢

28:47.320 --> 28:48.620
它会产生一个什么

28:48.620 --> 28:51.420
在eO的affix的时候

28:51.420 --> 28:53.920
当我们进行eO的affix的时候

28:53.920 --> 28:55.020
那么这个affix呢

28:55.020 --> 28:56.020
会返回一个啥呢

28:56.020 --> 28:56.720
就调用这些方法

28:56.720 --> 28:58.320
这些全是都是函数

28:58.320 --> 28:59.220
调用这些函数

28:59.220 --> 29:00.620
它会得到一个结果

29:00.620 --> 29:01.620
得到什么结果呢

29:01.620 --> 29:03.620
得到一个就是叫做

29:03.620 --> 29:04.320
affect

29:04.320 --> 29:06.020
or不结果

29:06.020 --> 29:08.320
就是一个描述对象

29:08.320 --> 29:09.720
affect

29:09.720 --> 29:10.920
or不结果

29:10.920 --> 29:12.520
是一个描述对象

29:12.520 --> 29:13.320
它是个描述对象

29:13.320 --> 29:14.420
描述我要干嘛

29:14.420 --> 29:16.020
我想干嘛

29:16.020 --> 29:16.920
描述对象

29:16.920 --> 29:19.220
这有点类似于Retouch里面的一个

29:19.220 --> 29:20.220
就是action

29:20.220 --> 29:21.720
相当于是产生了一个action

29:21.720 --> 29:23.520
表示我要干嘛

29:23.520 --> 29:24.520
通过这个东西呢

29:24.520 --> 29:26.320
返回给是不是返回给那个

29:26.320 --> 29:28.820
就是生成器的next

29:28.820 --> 29:29.820
对吧

29:29.820 --> 29:30.620
我们把这个东西呢

29:30.620 --> 29:34.020
就给了生成器的next

29:34.020 --> 29:35.720
当生成器调用那个next的时候

29:35.720 --> 29:39.420
它得到就是这么一个结果

29:39.420 --> 29:44.360
反了

29:44.360 --> 29:45.660
当生成器调用next的时候

29:45.660 --> 29:47.360
它会得到这么一个描述对象

29:47.360 --> 29:48.160
然后它这边呢

29:48.160 --> 29:49.960
它就根据不同的描述对象

29:49.960 --> 29:51.760
去做不同的事情

29:51.760 --> 29:54.160
大概是这么一种原理

29:54.160 --> 29:54.560
所以说呢

29:54.560 --> 29:55.660
这个Ron Saga

29:55.660 --> 29:56.360
Ron Saga

29:56.360 --> 29:57.160
他做的事情

29:57.160 --> 29:58.560
其实特别特别简单

29:58.560 --> 29:59.860
就是管理一个生成器

29:59.860 --> 30:00.960
你生成器

30:00.960 --> 30:03.160
生成器函数已经告诉你的

30:03.160 --> 30:04.760
生成器函数已经告诉你的

30:04.760 --> 30:05.160
然后呢

30:05.160 --> 30:06.260
你要做的事情是

30:06.260 --> 30:07.960
去管理这个生成器函数

30:07.960 --> 30:08.960
然后得到一个生成器

30:08.960 --> 30:10.060
让它不断地迭代

30:10.060 --> 30:12.060
就是他做的事情

30:12.060 --> 30:14.560
那么其实我刚才还是把它写完善一点

30:14.560 --> 30:15.460
其实这个地方呢

30:15.460 --> 30:18.860
它有可能给你传的是一个普通函数

30:18.860 --> 30:21.660
这个地方它有可能会给你传一个普通函数

30:21.660 --> 30:22.260
那么传一个

30:22.260 --> 30:24.360
如果说给你传的是一个普通函数

30:24.360 --> 30:25.860
怎么办呢

30:25.860 --> 30:28.360
如果说给你传的是一个普通函数

30:28.360 --> 30:28.960
怎么办呢

30:29.960 --> 30:31.860
我们这里会用到一个第三方库

30:33.060 --> 30:35.460
会用的第三方库来判断

30:35.460 --> 30:36.960
它是不是一个生成器函数

30:36.960 --> 30:38.360
那个库也特别特别简单

30:38.360 --> 30:39.160
大家有兴趣的话

30:39.160 --> 30:40.660
可以去看一下一个库的

30:40.660 --> 30:41.860
就是说明

30:41.860 --> 30:44.660
npm上的说明特别特别简单

30:44.660 --> 30:45.860
几句话就写完了

30:45.860 --> 30:47.460
咱们安装一下这个库

30:47.460 --> 30:50.660
这个库叫做Ease Generator

30:50.660 --> 30:51.060
对吧

30:51.060 --> 30:52.860
是不是一个生成器

30:52.860 --> 30:54.760
他用来判断是不是一个生成器

30:54.760 --> 30:57.260
他还用到一个库叫做Ease Promise

30:57.360 --> 30:58.960
是不是一个Promise对象

30:58.960 --> 31:00.360
这个东西我们以前是不是用过的

31:00.360 --> 31:00.660
对吧

31:00.660 --> 31:01.560
这个库用过的

31:02.660 --> 31:03.560
添加一下这两个库

31:04.660 --> 31:05.860
这两个库也特别特别简单

31:05.860 --> 31:08.160
就是一个是用来判断是不是生成器

31:08.160 --> 31:09.760
以及是不是生成器函数

31:09.760 --> 31:10.860
另外一个是用来判断

31:10.860 --> 31:11.760
是不是Promise

31:11.760 --> 31:12.560
我们都会用到的

31:12.560 --> 31:13.660
这两个库

31:13.660 --> 31:14.360
我们先导入进来

31:16.460 --> 31:17.160
导入进来过后

31:17.160 --> 31:18.960
我们这里现在在这里写在

31:18.960 --> 31:24.360
ImportEase Generator

31:24.460 --> 31:28.660
Promise Generator

31:28.660 --> 31:30.760
从这个库里面拿到这个函数

31:30.760 --> 31:32.360
这个函数用来判断一个东西

31:32.360 --> 31:33.560
是不是Generator

31:33.560 --> 31:34.660
是不是Generator

31:35.760 --> 31:40.160
这里我们Clear

31:40.160 --> 31:43.970
一二Start

31:46.170 --> 31:46.970
特别特别简单

31:47.970 --> 31:49.170
怎么做呢

31:49.170 --> 31:50.270
这里不是一个函数吗

31:50.270 --> 31:50.770
OK

31:50.770 --> 31:51.970
我们调用这个函数

31:51.970 --> 31:54.370
这个函数还有一些额外的参数

31:54.370 --> 31:54.970
对了

31:55.070 --> 31:56.770
还可能可以匪匪里传

31:56.770 --> 31:58.370
它还有可能一些额外的参数

31:58.370 --> 31:59.370
就在这

31:59.370 --> 31:59.770
就在这

32:01.070 --> 32:03.670
就是我们在调用这个RoundSaga的时候

32:03.670 --> 32:05.070
你传了一个Saga进去

32:05.070 --> 32:06.870
因为我们这里的Saga是没有参数的

32:06.870 --> 32:07.370
看没

32:07.370 --> 32:08.270
这个Saga是没有参数的

32:08.270 --> 32:09.370
通常也没有什么参数

32:09.370 --> 32:11.370
跟Saga是没有什么参数的

32:11.370 --> 32:13.070
但是你可以传参数的

32:13.070 --> 32:14.870
也这边后边是可以传参数的

32:14.870 --> 32:15.870
一二三

32:15.870 --> 32:16.670
你可以传参数的

32:16.670 --> 32:17.770
我看一下吧

32:17.770 --> 32:18.270
看一下

32:19.470 --> 32:21.670
这边我们比方说这里

32:21.670 --> 32:22.570
传了一个一二三

32:22.670 --> 32:25.170
我们自己能用原始的RoundSaga

32:25.170 --> 32:26.270
然后我们在Saga里边

32:26.270 --> 32:27.870
看一下能不能得到这个参数

32:27.870 --> 32:31.770
A B C A B C

32:31.770 --> 32:32.770
保存

32:32.770 --> 32:33.270
你看一下

32:34.770 --> 32:35.270
右键

32:35.270 --> 32:35.770
检查

32:36.670 --> 32:37.570
控制台

32:37.570 --> 32:38.870
你看ABC是打印出来了

32:38.870 --> 32:39.670
一二三

32:39.670 --> 32:40.170
对不对

32:40.170 --> 32:41.970
也说这里是可以传参数的

32:41.970 --> 32:43.170
参数是可以传过去了

32:43.170 --> 32:45.970
那么这里我们就把参数放这吧

32:45.970 --> 32:47.170
参数放这

32:47.170 --> 32:48.470
这是函数的参数

32:48.470 --> 32:49.070
打个注射

32:50.070 --> 32:51.070
拍入

32:51.070 --> 32:56.450
ABC是额外的参数

32:56.450 --> 32:58.450
就是生成器

32:58.450 --> 32:59.450
生成器

33:00.450 --> 33:02.450
函数的参数

33:04.450 --> 33:05.450
把这个格式写出来过后

33:05.450 --> 33:07.450
那么现在我们只需要去调用这个函数

33:07.450 --> 33:08.450
就完事了

33:08.450 --> 33:09.450
调用这个函数

33:09.450 --> 33:10.450
把这个参数传进去

33:10.450 --> 33:11.450
是不是就完了

33:11.450 --> 33:12.450
对不对

33:12.450 --> 33:13.450
把参数传进去

33:13.450 --> 33:15.450
它是不是会返回一个结果

33:15.450 --> 33:15.950
对吧

33:15.950 --> 33:17.450
会返回一个结果

33:17.450 --> 33:18.450
Generator

33:18.450 --> 33:19.950
返回的是不是一个生成器

33:19.950 --> 33:21.950
但是你要考虑到一个问题

33:21.950 --> 33:22.950
就是说这个函数

33:22.950 --> 33:24.950
它可能是传的是一个普通函数

33:24.950 --> 33:25.950
它不是一个生成器函数

33:25.950 --> 33:27.950
可能传的是一个普通函数

33:27.950 --> 33:29.950
那么这里我们就需要判断一下

33:29.950 --> 33:30.950
它到底传的是什么

33:30.950 --> 33:31.950
如果说

33:31.950 --> 33:32.950
判断一下

33:32.950 --> 33:33.950
如果说

33:33.950 --> 33:36.950
意思Generator

33:36.950 --> 33:38.950
用这个函数来判断

33:38.950 --> 33:39.950
判断这个东西

33:39.950 --> 33:41.950
是不是一个生成器

33:41.950 --> 33:43.950
如果说Generator

33:43.950 --> 33:44.950
是一个生成器的话

33:44.950 --> 33:46.950
我怎么样怎么样怎么样

33:46.950 --> 33:47.950
Al

33:47.950 --> 33:48.950
如果它不是一个生成器的话

33:49.950 --> 33:51.950
我们就这里分成两个输出

33:51.950 --> 33:54.950
一个普通函数

33:54.950 --> 34:00.950
这个是一个生成器函数

34:03.950 --> 34:04.950
保存一下

34:04.950 --> 34:05.950
咱们看一下

34:05.950 --> 34:06.950
这是咱们的ROUND SAGA

34:06.950 --> 34:08.950
我们现在用回我们自己的

34:09.950 --> 34:11.950
那么目前我们得到的是

34:11.950 --> 34:12.950
一个生成器函数

34:12.950 --> 34:13.950
对吧

34:13.950 --> 34:14.950
为什么这个函数没运行

34:14.950 --> 34:15.950
这个函数里边不是显然

34:15.950 --> 34:16.950
要运行

34:16.950 --> 34:17.950
因为我们还没有

34:17.950 --> 34:18.950
调用next

34:18.950 --> 34:20.950
所以说这个函数自然不会运行

34:20.950 --> 34:21.950
生成器函数

34:21.950 --> 34:22.950
它不会运行函数的

34:22.950 --> 34:24.950
调用过后得到的是一个生成器

34:24.950 --> 34:25.950
那如果说我这里

34:25.950 --> 34:27.950
写的是一个普通函数

34:27.950 --> 34:28.950
写的是一个普通函数

34:28.950 --> 34:29.950
保存

34:29.950 --> 34:30.950
你看这个函数是不是瞬间运行的

34:30.950 --> 34:31.950
对吧

34:31.950 --> 34:33.950
它是一个普通函数

34:33.950 --> 34:34.950
咱们就可以使用这个库

34:34.950 --> 34:35.950
来帮助我们判断

34:35.950 --> 34:38.950
它是不是一个生成器

34:38.950 --> 34:39.950
如果说

34:39.950 --> 34:40.950
它是一个普通函数的话

34:40.950 --> 34:41.950
我们就什么都不做

34:41.950 --> 34:42.950
对吧

34:42.950 --> 34:43.950
做它干嘛

34:43.950 --> 34:45.950
普通函数就什么都不做

34:45.950 --> 34:46.950
我们先放着

34:46.950 --> 34:47.950
我们之后再说

34:47.950 --> 34:49.950
如果说它是一个生成器函数

34:49.950 --> 34:50.950
我们要干嘛呢

34:50.950 --> 34:52.950
是不是在这里

34:52.950 --> 34:53.950
要开始做一件事情

34:53.950 --> 34:54.950
就是

34:54.950 --> 34:57.950
不断调用next

34:57.950 --> 34:59.950
不断调用next

34:59.950 --> 35:01.950
然后呢

35:01.950 --> 35:03.950
不断调用next

35:03.950 --> 35:04.950
直到

35:04.950 --> 35:07.950
迭代结束

35:07.950 --> 35:08.950
直到迭代结束

35:08.950 --> 35:09.950
每调用一次

35:09.950 --> 35:10.950
因为今天有条

35:10.950 --> 35:11.950
每调用一次next

35:11.950 --> 35:12.950
是不是迭代一次

35:12.950 --> 35:13.950
每调用一次next

35:13.950 --> 35:14.950
就迭代一次

35:14.950 --> 35:15.950
实际上官方员

35:15.950 --> 35:16.950
罵里边

35:16.950 --> 35:18.950
这个地方用的名字叫做

35:18.950 --> 35:19.950
atorator

35:19.950 --> 35:20.950
其实也可以

35:20.950 --> 35:21.950
因为我们之前说过

35:21.950 --> 35:22.950
这个生成器

35:22.950 --> 35:23.950
它本来就符合

35:23.950 --> 35:24.950
迭代器规则

35:24.950 --> 35:25.950
所以说

35:25.950 --> 35:27.950
它本身也是一个迭代器

35:27.950 --> 35:28.950
不断调next

35:28.950 --> 35:29.950
直到迭代结束

35:29.950 --> 35:31.950
那么为了方便我们迭代

35:31.950 --> 35:33.950
我会在这个函数内部

35:33.950 --> 35:35.950
再写上这么一个东西

35:35.950 --> 35:36.950
会在这个函数内部

35:36.950 --> 35:37.950
写上这么一个东西

35:37.950 --> 35:39.950
叫做next

35:39.950 --> 35:41.950
写上这么一个函数

35:41.950 --> 35:42.950
next

35:42.950 --> 35:43.950
next什么意思

35:43.950 --> 35:44.950
就是表示的是下一个

35:44.950 --> 35:45.950
下一个

35:45.950 --> 35:46.950
OK

35:46.950 --> 35:47.950
我们往下走一个

35:47.950 --> 35:48.950
往下走一步

35:48.950 --> 35:49.950
往下走一步

35:49.950 --> 35:50.950
每次在eO的那里

35:50.950 --> 35:51.950
要是不是要停顿一下

35:51.950 --> 35:52.950
拿到结构过后

35:52.950 --> 35:53.950
我们继续往下走

35:53.950 --> 35:54.950
就写出这么一个函数

35:54.950 --> 35:55.950
这种写法

35:55.950 --> 35:56.950
我们之前是不是讲

35:56.950 --> 35:57.950
那个生成器的时候写过的

35:57.950 --> 35:58.950
所以这一块

35:58.950 --> 35:59.950
我们要干嘛

35:59.950 --> 36:00.950
是不是就直接调用这个next

36:00.950 --> 36:01.950
就完事了

36:01.950 --> 36:02.950
直接调用这个next就完事了

36:02.950 --> 36:04.950
明白的意思吧

36:04.950 --> 36:06.950
直接调用那个时候就完事了

36:06.950 --> 36:07.950
好

36:07.950 --> 36:08.950
那么这个next里边

36:08.950 --> 36:09.950
怎么写呢

36:09.950 --> 36:10.950
这个next

36:10.950 --> 36:11.950
怎么写呢

36:11.950 --> 36:12.950
这个next里边

36:12.950 --> 36:13.950
你肯定有一些参数

36:13.950 --> 36:14.950
要给它

36:14.950 --> 36:15.950
比方说nxt的时候

36:15.950 --> 36:16.950
是不是要有value

36:16.950 --> 36:17.950
对不对

36:17.950 --> 36:18.950
因为这个地方

36:18.950 --> 36:20.950
它里边内部有可能有多种情况

36:20.950 --> 36:21.950
有什么情况

36:21.950 --> 36:23.950
就情况1

36:23.950 --> 36:25.950
情况1就是

36:25.950 --> 36:26.950
调用

36:26.950 --> 36:29.950
attributor的next

36:29.950 --> 36:30.950
把这个value传进去

36:30.950 --> 36:31.950
对不对

36:31.950 --> 36:33.950
这是第1种情况

36:33.950 --> 36:34.950
第2种情况

36:34.950 --> 36:35.950
还有什么情况

36:35.950 --> 36:36.950
就没情况了

36:36.950 --> 36:37.950
第1种情况是

36:37.950 --> 36:38.950
调用attributor的

36:38.950 --> 36:39.950
因为还有几种方式

36:39.950 --> 36:41.950
shrow

36:41.950 --> 36:42.950
拨出异常

36:42.950 --> 36:43.950
对不对

36:43.950 --> 36:44.950
拨出异常

36:44.950 --> 36:45.950
第3种情况

36:45.950 --> 36:46.950
情况3

36:46.950 --> 36:48.950
是调用attributor的

36:48.950 --> 36:50.950
什么return

36:50.950 --> 36:51.950
结束

36:51.950 --> 36:52.950
结束任务

36:52.950 --> 36:53.950
结束

36:53.950 --> 36:54.950
对吧

36:54.950 --> 36:55.950
这里有3种情况

36:55.950 --> 36:56.950
都要进行处理

36:56.950 --> 36:57.950
那么怎么呢

36:57.950 --> 36:58.950
我这里怎么知道

36:58.950 --> 36:59.950
我要调用哪一个呢

36:59.950 --> 37:00.950
OK

37:00.950 --> 37:02.950
你给我传参数

37:02.950 --> 37:04.950
第1个value参数

37:04.950 --> 37:05.950
第2个value

37:05.950 --> 37:07.950
第3个就是is over

37:07.950 --> 37:08.950
打个注射

37:08.950 --> 37:10.950
这3个参数是什么用的

37:10.950 --> 37:12.950
value表示

37:12.950 --> 37:14.950
下正常

37:14.950 --> 37:16.950
调用

37:16.950 --> 37:18.950
attributor

37:18.950 --> 37:20.950
darned

37:20.950 --> 37:22.950
下传递的

37:22.950 --> 37:24.950
传递的值

37:24.950 --> 37:25.950
第2个能表示

37:25.950 --> 37:27.950
错误对象

37:27.950 --> 37:29.950
或者是错误消息

37:29.950 --> 37:31.950
这是error

37:31.950 --> 37:33.950
那么第3个就是is over

37:33.950 --> 37:35.950
is over表示一个布尔

37:35.950 --> 37:37.950
内容是布尔

37:37.950 --> 37:42.090
那么这个表示的是

37:42.090 --> 37:44.090
是否结束了

37:44.090 --> 37:45.090
是否结束

37:45.090 --> 37:46.090
是否马上终止

37:46.090 --> 37:48.090
终止这个任务

37:48.090 --> 37:50.090
也就是说我们到时候

37:50.090 --> 37:51.090
我这个函数里面

37:51.090 --> 37:52.090
我们就会做这样的判断

37:52.090 --> 37:53.090
如果说

37:53.090 --> 37:55.090
比方说你有错误

37:55.090 --> 37:56.090
你有错误干嘛呢

37:56.090 --> 37:58.090
我就调用的是

37:58.090 --> 38:00.090
srow error

38:00.090 --> 38:02.090
调用的是srow error

38:02.090 --> 38:04.090
抛出一个错误

38:06.090 --> 38:07.090
没问题吧

38:07.090 --> 38:08.090
我们就这样的调用

38:08.090 --> 38:09.090
抛出错误过后

38:09.090 --> 38:10.090
是不是会得到一个结果

38:10.090 --> 38:11.090
对不对

38:11.090 --> 38:12.090
会得到一个什么结果

38:12.090 --> 38:13.090
就是下一个

38:13.090 --> 38:15.090
就下一个的结果

38:15.090 --> 38:17.090
就迭代的结果

38:17.090 --> 38:18.090
迭代的结果

38:18.090 --> 38:20.090
我们这里面写上这么一个

38:20.090 --> 38:21.090
变量嘛

38:21.090 --> 38:23.090
result

38:23.090 --> 38:24.090
这是

38:24.090 --> 38:26.090
记录迭代的结果

38:26.090 --> 38:27.090
迭代的结果

38:27.090 --> 38:28.090
因为我们之前说过

38:28.090 --> 38:29.090
这个srow

38:29.090 --> 38:31.090
还跟那个是一样的

38:31.090 --> 38:32.090
没有什么区别

38:32.090 --> 38:34.090
它无非就是它拋出一个错误

38:34.090 --> 38:35.090
拋出一个错误

38:35.090 --> 38:36.090
有人说不是会停止运行吗

38:36.090 --> 38:37.090
那万一你不要用了

38:37.090 --> 38:38.090
揣开起来

38:38.090 --> 38:39.090
是不是补货的错误

38:39.090 --> 38:40.090
又接着运行了

38:40.090 --> 38:42.090
它总之会得到一个迭代结果

38:42.090 --> 38:43.090
如果爆错了

38:43.090 --> 38:44.090
里边没有用揣开起来

38:44.090 --> 38:46.090
那么直接在这里终止了

38:46.090 --> 38:47.090
所以这里面

38:47.090 --> 38:49.090
它仍然会得到一个迭代结果

38:49.090 --> 38:50.090
这个迭代结果也是一种格式

38:50.090 --> 38:51.090
就是什么

38:51.090 --> 38:52.090
格式就是

38:52.090 --> 38:54.090
y6是啥

38:55.090 --> 38:57.090
我们这里会换个名字吧

38:57.090 --> 38:58.090
那个是y6

38:59.090 --> 39:00.090
那么这个

39:00.090 --> 39:01.090
得到的迭代结果

39:03.090 --> 39:04.090
换一下

39:04.090 --> 39:05.090
这得到的迭代结果

39:05.090 --> 39:06.090
y6是啥

39:06.090 --> 39:07.090
然后当

39:07.090 --> 39:08.090
是啥

39:08.090 --> 39:09.090
对不对

39:09.090 --> 39:10.090
它就这么一种格式

39:10.090 --> 39:13.090
所以说你对生成器得非常熟悉才行

39:13.090 --> 39:15.090
然后如果有错误的话

39:15.090 --> 39:17.090
我们srow得到一个迭代结果

39:17.090 --> 39:18.090
好

39:18.090 --> 39:20.090
如果说lcf

39:20.090 --> 39:21.090
lcf

39:21.090 --> 39:23.090
那么如果说你这个

39:23.090 --> 39:25.090
is over 为出

39:25.090 --> 39:26.090
表示要结束了

39:26.090 --> 39:27.090
对吧

39:27.090 --> 39:28.090
表示要结束了

39:28.090 --> 39:29.090
那么我们这里

39:29.090 --> 39:30.090
就调用

39:32.090 --> 39:33.090
ator

39:33.090 --> 39:35.090
调用return

39:35.090 --> 39:36.090
结束

39:36.090 --> 39:37.090
结束整个

39:38.090 --> 39:39.090
迭代

39:41.090 --> 39:42.090
如果是lcf

39:42.090 --> 39:43.090
的话就正常情况了

39:43.090 --> 39:44.090
对吧

39:44.090 --> 39:45.090
正常情况我们就调用next

39:45.090 --> 39:47.090
得到迭代结果

39:48.090 --> 39:49.090
对吧

39:49.090 --> 39:50.090
把这个srowy6

39:50.090 --> 39:51.090
传进来

39:52.090 --> 39:53.090
对吧

39:53.090 --> 39:54.090
就这样子写

39:55.090 --> 39:56.090
总之呢

39:56.090 --> 39:57.090
我们无论是哪一种情况

39:57.090 --> 39:58.090
是不是都会得到一个迭代结果

39:58.090 --> 39:59.090
对吧

39:59.090 --> 40:00.090
这个next的函数

40:00.090 --> 40:01.090
是不是

40:01.090 --> 40:02.090
你传给他一参数

40:02.090 --> 40:03.090
他来根据不同的情况

40:03.090 --> 40:04.090
来去做不同的事情

40:04.090 --> 40:05.090
最终都会得到一个迭代结果

40:06.090 --> 40:07.090
这是next函数

40:07.090 --> 40:08.090
那么这里呢

40:08.090 --> 40:09.090
一开始调用的时候

40:10.090 --> 40:11.090
我是不是啥都可以不用传

40:11.090 --> 40:12.090
因为肯定没有错误吧

40:12.090 --> 40:13.090
对吧

40:13.090 --> 40:14.090
没有错误肯定不用传

40:14.090 --> 40:15.090
肯定没有结束嘛

40:15.090 --> 40:16.090
对不对

40:16.090 --> 40:17.090
那么这个is over 不用传

40:17.090 --> 40:18.090
然后呢

40:18.090 --> 40:19.090
next value

40:19.090 --> 40:20.090
传不传呢

40:20.090 --> 40:22.090
一开始的时候传的有啥意义呢

40:22.090 --> 40:23.090
最开始调用的时候

40:23.090 --> 40:24.090
next的时候

40:24.090 --> 40:25.090
是不是传的东西没意义

40:25.090 --> 40:26.090
如果说你对现在

40:26.090 --> 40:28.090
对这个迭代器的一块

40:28.090 --> 40:29.090
还感觉很模糊的话

40:29.090 --> 40:30.090
我建议你

40:30.090 --> 40:31.090
我都建议你

40:31.090 --> 40:33.090
可以回去重新再看一遍

40:33.090 --> 40:35.090
因为你要写3个元的嘛

40:35.090 --> 40:36.090
你必须要对迭代器

40:36.090 --> 40:37.090
非常非常熟悉

40:37.090 --> 40:38.090
好

40:38.090 --> 40:39.090
那么这里总之

40:39.090 --> 40:40.090
会得到一个迭代结果

40:40.090 --> 40:42.090
拿到这个迭代结果之后

40:42.090 --> 40:43.090
是不是我们可以分析出

40:43.090 --> 40:44.090
它的什么

40:44.090 --> 40:45.090
value和档

40:45.090 --> 40:46.090
对不对

40:46.090 --> 40:47.090
是不是可以分析出

40:47.090 --> 40:48.090
value和档

40:50.090 --> 40:51.090
分析出

40:52.090 --> 40:53.090
解构

40:53.090 --> 40:54.090
出

40:54.090 --> 40:55.090
value

40:55.090 --> 40:56.090
和

40:56.090 --> 40:57.090
档

40:57.090 --> 40:58.090
解构出这两个东西

40:58.090 --> 40:59.090
好

40:59.090 --> 41:00.090
解构出来过后呢

41:00.090 --> 41:02.090
我们这里有个判断

41:02.090 --> 41:03.090
始终记住

41:03.090 --> 41:04.090
咱们绕萨卡做什么事情

41:04.090 --> 41:06.090
就是管理一个迭代器

41:06.090 --> 41:07.090
不断的迭代

41:07.090 --> 41:08.090
你看一下我们在什么时候

41:08.090 --> 41:09.090
开始迭代

41:09.090 --> 41:10.090
先调到这个函数

41:10.090 --> 41:11.090
得到一个生存器

41:11.090 --> 41:12.090
迭代器

41:12.090 --> 41:13.090
那么就马上开始迭代了

41:13.090 --> 41:14.090
对吧

41:14.090 --> 41:15.090
就马上开始迭代了

41:15.090 --> 41:17.090
那么迭代的过程中

41:17.090 --> 41:18.090
它会进行不断的下一步

41:18.090 --> 41:19.090
不断的下一步

41:19.090 --> 41:20.090
每一次要进行

41:20.090 --> 41:21.090
下一步的时候

41:21.090 --> 41:22.090
就调到 next

41:22.090 --> 41:23.090
对吧

41:23.090 --> 41:24.090
来完成下一步

41:24.090 --> 41:25.090
好

41:25.090 --> 41:26.090
那么现在呢

41:26.090 --> 41:27.090
我们首先看一下

41:27.090 --> 41:28.090
还需不需要继续迭代

41:28.090 --> 41:29.090
好

41:29.090 --> 41:30.090
判断一下

41:30.090 --> 41:31.090
如果说

41:31.090 --> 41:33.090
它已经变成处了

41:33.090 --> 41:34.090
迭代结束了

41:34.090 --> 41:36.090
是不是迭代结束了

41:37.090 --> 41:38.090
迭代结束干嘛

41:38.090 --> 41:39.090
整个结束

41:39.090 --> 41:41.090
整个函数结束了

41:41.090 --> 41:43.090
整个函数结束了

41:43.090 --> 41:44.090
所以说呢

41:44.090 --> 41:45.090
我们

41:45.090 --> 41:47.090
如果说你写了一个迭代器

41:47.090 --> 41:48.090
如果你写了个迭代器

41:48.090 --> 41:49.090
比方在这里

41:49.090 --> 41:50.090
咱们呢

41:50.090 --> 41:52.090
传一个abc

41:52.090 --> 41:54.090
比方说这里就写了个迭代器

41:54.090 --> 41:55.090
写了个迭代器

41:55.090 --> 41:57.090
这个迭代器里边啥都没写

41:57.090 --> 41:58.090
没有写任何的eo的

41:58.090 --> 41:59.090
对吧

41:59.090 --> 42:00.090
一下就完成了

42:00.090 --> 42:01.090
好

42:01.090 --> 42:02.090
那么你看一下吧

42:02.090 --> 42:03.090
你看一下

42:03.090 --> 42:04.090
保存

42:04.090 --> 42:05.090
你看是不是还是输出了

42:05.090 --> 42:06.090
123SK完成

42:06.090 --> 42:07.090
对不对

42:07.090 --> 42:08.090
为什么

42:08.090 --> 42:10.090
因为它最开始得到迭代器过后

42:10.090 --> 42:12.090
马上还是进行迭代

42:12.090 --> 42:13.090
由于它里边没有eo的

42:13.090 --> 42:15.090
因此瞬间就结束了

42:15.090 --> 42:16.090
迭代器结束了

42:16.090 --> 42:18.090
比方我们在这里输出一下吧

42:18.090 --> 42:19.090
迭代结束

42:20.090 --> 42:21.090
保存

42:21.090 --> 42:22.090
你看

42:22.090 --> 42:23.090
是不是迭代结束了

42:23.090 --> 42:24.090
对吧

42:25.090 --> 42:26.090
所以说这样的迭代器

42:26.090 --> 42:27.090
跟普通函数

42:27.090 --> 42:28.090
没有任何区别

42:28.090 --> 42:29.090
所以说

42:29.090 --> 42:30.090
其实个生存性函数干嘛了

42:30.090 --> 42:32.090
它跟普通函数有啥区别呢

42:33.090 --> 42:34.090
然后呢

42:34.090 --> 42:35.090
现在

42:35.090 --> 42:37.090
这是当表示结束的情况

42:37.090 --> 42:39.090
接下来我们看没有结束的情况

42:40.090 --> 42:42.090
没有结束

42:43.090 --> 42:44.090
好

42:44.090 --> 42:46.090
没有结束的时候

42:46.090 --> 42:47.090
该干嘛了

42:47.090 --> 42:49.090
没有结束的时候

42:49.090 --> 42:50.090
没有结束的时候

42:50.090 --> 42:52.090
我们要把这个y6值分析出来了

42:52.090 --> 42:54.090
你看这个y6值是啥

42:54.090 --> 42:55.090
是不是就是eo的

42:55.090 --> 42:57.090
后表给我传递的东西

42:57.090 --> 42:59.090
那么我们之前学了很多的effects

42:59.090 --> 43:01.090
那么这些都是一些函数

43:01.090 --> 43:03.090
调用函数是不是会返回一个对象

43:03.090 --> 43:05.090
一个描述对象

43:05.090 --> 43:07.090
会返回这么一个描述对象

43:07.090 --> 43:08.090
那么这个描述对象呢

43:08.090 --> 43:09.090
会传递到

43:09.090 --> 43:11.090
那个是里面

43:11.090 --> 43:12.090
这个y6里面来

43:12.090 --> 43:13.090
会存在这儿来

43:13.090 --> 43:14.090
我们这边呢

43:14.090 --> 43:16.090
要根据这个y6值

43:16.090 --> 43:18.090
来去做不同的事情

43:18.090 --> 43:19.090
好

43:19.090 --> 43:20.090
这里边呢

43:20.090 --> 43:23.090
我们首先要分成两种情况

43:23.090 --> 43:24.090
哪两种情况呢

43:24.090 --> 43:25.090
一个

43:26.090 --> 43:28.090
一个是

43:28.090 --> 43:31.090
如果它是一个effects

43:31.090 --> 43:32.090
objects

43:32.090 --> 43:33.090
如果它是一个这个对象

43:33.090 --> 43:34.090
描述对象

43:34.090 --> 43:36.090
就是它是一个effects

43:36.090 --> 43:39.090
是一个effects

43:39.090 --> 43:41.090
我们怎么去处理

43:41.090 --> 43:42.090
好

43:42.090 --> 43:44.090
l11

43:44.090 --> 43:46.090
它如果它不是一个effects

43:46.090 --> 43:47.090
如果这里一个传递的是

43:47.090 --> 43:48.090
不是一个effects

43:48.090 --> 43:49.090
比方说

43:49.090 --> 43:50.090
什么情况不是一个effects呢

43:50.090 --> 43:51.090
比方说我们在这里

43:51.090 --> 43:53.090
写上一个eo的

43:53.090 --> 43:54.090
eo的put

43:54.090 --> 43:55.090
比方说我们随便写

43:55.090 --> 43:56.090
下写一个嘛

43:56.090 --> 43:57.090
下写一个

43:57.090 --> 43:58.090
或者是用那个delay嘛

43:58.090 --> 44:00.090
delay要简单一点

44:00.090 --> 44:01.090
1000

44:01.090 --> 44:02.090
比方说我们下写一个

44:02.090 --> 44:03.090
那么这个地方

44:03.090 --> 44:05.090
这个函数雕用返回的结果

44:05.090 --> 44:06.090
就是

44:06.090 --> 44:08.090
effects描述对象

44:08.090 --> 44:10.090
就是个effects描述对象

44:10.090 --> 44:11.090
好

44:11.090 --> 44:12.090
那么这个描述对象

44:12.090 --> 44:13.090
会交给谁呢

44:13.090 --> 44:14.090
是不是会交给它

44:14.090 --> 44:15.090
对不对

44:15.090 --> 44:16.090
会交给这个value

44:16.090 --> 44:17.090
对不对

44:17.090 --> 44:18.090
会交给这个value

44:18.090 --> 44:19.090
好

44:19.090 --> 44:20.090
那么如果说我这里

44:20.090 --> 44:21.090
给的是一个effects描述对象

44:21.090 --> 44:22.090
也就是说我这里

44:22.090 --> 44:23.090
给的是一个effects

44:23.090 --> 44:25.090
那么我们要做一个处理

44:25.090 --> 44:26.090
好

44:26.090 --> 44:27.090
如果说我们这里

44:27.090 --> 44:28.090
调整不是effects呢

44:28.090 --> 44:29.090
比方说我这里

44:29.090 --> 44:30.090
写个123

44:30.090 --> 44:31.090
能不能这样写

44:31.090 --> 44:32.090
愚法上肯定是支持的对吧

44:32.090 --> 44:33.090
愚法上肯定是支持的

44:33.090 --> 44:35.090
如果你不是一个effects呢

44:35.090 --> 44:36.090
我们又怎么处理

44:36.090 --> 44:37.090
又怎么处理

44:37.090 --> 44:38.090
那么这里

44:38.090 --> 44:39.090
else

44:39.090 --> 44:41.090
就是不是一个effects

44:41.090 --> 44:43.090
不是一个effects

44:43.090 --> 44:44.090
对吧

44:44.090 --> 44:46.090
我们这里输出一句话嘛

44:46.090 --> 44:48.400
输出一句话

44:48.400 --> 44:50.400
value

44:53.400 --> 44:55.400
不是一个effects

44:55.400 --> 44:57.400
我们先输出

44:57.400 --> 44:58.400
好

44:58.400 --> 44:59.400
那么这里

44:59.400 --> 45:00.400
我们首先遇到

45:00.400 --> 45:01.400
第一个问题

45:01.400 --> 45:03.400
就是如何来判断一个东西

45:03.400 --> 45:04.400
你这个value值

45:04.400 --> 45:05.400
是不是effects

45:05.400 --> 45:07.400
那么我们是不是要判断特点

45:07.400 --> 45:09.400
它一定有某一种特点

45:09.400 --> 45:11.400
effects一定有某一种特点

45:11.400 --> 45:12.400
什么特点呢

45:12.400 --> 45:13.400
我们来看一下

45:13.400 --> 45:14.400
我们看一下

45:14.400 --> 45:15.400
如果说我们在这里

45:15.400 --> 45:16.400
用那个sacca的元代吧

45:16.400 --> 45:18.400
我们就用sacca元嘛

45:18.400 --> 45:20.400
用它的元吧

45:20.400 --> 45:22.400
它里面不是有包含了

45:22.400 --> 45:23.400
effects嘛对吧

45:23.400 --> 45:24.400
比方说啊

45:24.400 --> 45:26.400
这里面我们导入

45:26.400 --> 45:27.400
from

45:27.400 --> 45:29.400
sacca

45:29.400 --> 45:31.400
with doggs

45:31.400 --> 45:32.400
sacca

45:32.400 --> 45:33.400
effects

45:33.400 --> 45:34.400
它里面不是有很多effects吗

45:34.400 --> 45:35.400
比方说有一个什么delay

45:35.400 --> 45:36.400
对吧

45:36.400 --> 45:37.400
或者用扣嘛

45:37.400 --> 45:38.400
扣

45:38.400 --> 45:39.400
这里呢

45:39.400 --> 45:40.400
我们用一个eo的

45:40.400 --> 45:42.400
我们直接不用eo的了

45:42.400 --> 45:43.400
直接调用那个扣

45:43.400 --> 45:44.400
直接调用

45:44.400 --> 45:45.400
看一下调用那个函数

45:45.400 --> 45:46.400
它反回了什么东西

45:46.400 --> 45:47.400
到底反回了什么东西

45:47.400 --> 45:48.400
这里面不传一个函数吗

45:48.400 --> 45:49.400
我们随便传个函数

45:49.400 --> 45:50.400
随便下传个函数

45:50.400 --> 45:51.400
这里

45:51.400 --> 45:52.400
c

45:52.400 --> 45:53.400
输出这个c

45:53.400 --> 45:55.400
看它得到的是什么东西

45:55.400 --> 45:57.400
保存

45:57.400 --> 45:59.400
你看一下得到是不是对象

45:59.400 --> 46:00.400
对吧

46:00.400 --> 46:01.400
是个对象

46:01.400 --> 46:02.400
那么这个对象

46:02.400 --> 46:03.400
我们怎么来判断

46:03.400 --> 46:04.400
它是一个effects呢

46:04.400 --> 46:05.400
怎么来判断呢

46:05.400 --> 46:06.400
你看这个对象

46:06.400 --> 46:07.400
就是一个普通的平面对象

46:07.400 --> 46:08.400
它的原性就是

46:08.400 --> 46:09.400
不解释了

46:09.400 --> 46:11.400
那么我们怎么来判断呢

46:11.400 --> 46:12.400
就判断这个

46:12.400 --> 46:13.400
特殊的这个属性

46:13.400 --> 46:14.400
with doggs

46:14.400 --> 46:15.400
sacca

46:15.400 --> 46:17.400
就判断这个玩意

46:17.400 --> 46:18.400
这个玩意

46:18.400 --> 46:19.400
就指示了

46:19.400 --> 46:21.400
它是一个effects

46:21.400 --> 46:22.400
所以说

46:22.400 --> 46:23.400
我们也可以利用它

46:23.400 --> 46:25.400
这种一种类似的方式

46:25.400 --> 46:26.400
来进行做

46:26.400 --> 46:27.400
来做

46:27.400 --> 46:28.400
我们可以在这里

46:28.400 --> 46:29.400
我们先把这个结构写好

46:29.400 --> 46:30.400
可以在这里

46:30.400 --> 46:31.400
这些可能我们就讲到

46:31.400 --> 46:33.400
如何来判定它是一个effects

46:33.400 --> 46:34.400
我们在这个with doggs

46:34.400 --> 46:36.400
sacca里边再写个文件

46:36.400 --> 46:37.400
这个文件专门来提供

46:37.400 --> 46:39.400
对effects的判断

46:39.400 --> 46:41.400
effects的创建

46:41.400 --> 46:43.400
来做一个支持

46:43.400 --> 46:44.400
effects

46:44.400 --> 46:45.400
比方说helper

46:45.400 --> 46:47.400
一个辅助函数

46:47.400 --> 46:48.400
这里面是一个辅助的模块

46:49.400 --> 46:50.400
这个模块

46:50.400 --> 46:51.400
该模块

46:51.400 --> 46:52.400
为

46:52.400 --> 46:53.400
创建

46:53.400 --> 46:55.400
effects

46:55.400 --> 46:56.400
和

46:56.400 --> 46:57.400
判断

46:57.400 --> 46:58.400
effects

46:58.400 --> 46:59.400
提供支持

46:59.400 --> 47:00.400
再说一次

47:00.400 --> 47:01.400
effects到底是什么东西

47:01.400 --> 47:03.400
effects是一个函数

47:03.400 --> 47:04.400
雕用这个函数

47:04.400 --> 47:05.400
它会得到这么一种

47:05.400 --> 47:06.400
结构的对象

47:06.400 --> 47:07.400
这个对象里面

47:07.400 --> 47:08.400
有个特殊的属性

47:08.400 --> 47:10.400
把它这为处就表示effects

47:10.400 --> 47:12.400
不要感觉好像很复杂的样子

47:12.400 --> 47:13.400
特别特别简单

47:13.400 --> 47:14.400
然后对象里边

47:14.400 --> 47:15.400
还有一个type

47:15.400 --> 47:16.400
type表示什么意思

47:16.400 --> 47:17.400
type表示你的事

47:17.400 --> 47:19.400
你调的是哪一个effects

47:19.400 --> 47:20.400
对吧

47:20.400 --> 47:21.400
你调的是哪一个effects

47:21.400 --> 47:22.400
调的是take every

47:22.400 --> 47:23.400
forcare

47:23.400 --> 47:24.400
还有调的是什么effects

47:25.400 --> 47:26.400
那么type

47:26.400 --> 47:27.400
type这个属性

47:27.400 --> 47:28.400
这个字母创

47:28.400 --> 47:29.400
表示的是

47:29.400 --> 47:30.400
调的是什么effects

47:30.400 --> 47:31.400
还有这个payload

47:31.400 --> 47:32.400
是不是附带的数据

47:32.400 --> 47:33.400
这个东西是不是特别像

47:33.400 --> 47:34.400
n型

47:34.400 --> 47:35.400
是不是特别特别像n型

47:35.400 --> 47:36.400
你可以认为

47:36.400 --> 47:37.400
这个sacra

47:37.400 --> 47:38.400
就是内部

47:38.400 --> 47:39.400
它做了一个小的

47:39.400 --> 47:40.400
迷离的瑞大克斯

47:40.400 --> 47:42.400
来类似于这种结构

47:42.400 --> 47:43.400
来进行处理

47:43.400 --> 47:44.400
但是它的代码

47:44.400 --> 47:45.400
量要比瑞大克斯

47:45.400 --> 47:46.400
要大得多

47:46.400 --> 47:47.400
但是它的思路

47:47.400 --> 47:49.400
是沿用了瑞大克斯的思路

47:49.400 --> 47:50.400
就是我调用这些函数

47:50.400 --> 47:52.400
我这些函数本身

47:52.400 --> 47:53.400
并不做任何处理

47:53.400 --> 47:55.400
它只是返回一个描述对象

47:55.400 --> 47:56.400
那么这个描述对象

47:56.400 --> 47:57.400
交给了RAM

47:57.400 --> 47:58.400
RAM仨卡档

47:58.400 --> 47:59.400
它俩进行处理

47:59.400 --> 48:00.400
是这么个意思

48:00.400 --> 48:01.400
那么这里

48:01.400 --> 48:02.400
我们再看一下

48:02.400 --> 48:03.400
看一下这边

48:03.400 --> 48:04.400
我们就按照这个来

48:04.400 --> 48:05.400
首先我们看一下

48:05.400 --> 48:06.400
有哪些type值

48:06.400 --> 48:07.400
type值

48:07.400 --> 48:08.400
比方说

48:08.400 --> 48:10.400
我们这里就随便写一个

48:10.400 --> 48:12.400
写出这么一种结构

48:12.400 --> 48:13.400
我们这里

48:13.400 --> 48:14.400
写这么一个

48:14.400 --> 48:15.400
导出这么一个长量

48:16.400 --> 48:17.400
const

48:17.400 --> 48:19.400
叫做affect

48:19.400 --> 48:20.400
types

48:20.400 --> 48:23.400
就是我们的affect里边有哪些内容

48:23.400 --> 48:25.400
affect

48:25.400 --> 48:26.400
内容

48:26.400 --> 48:28.400
可用内容

48:28.400 --> 48:30.400
可用内容有哪些

48:30.400 --> 48:31.400
有哪些

48:31.400 --> 48:33.400
我们这里就一次写上一些属性

48:33.400 --> 48:34.400
比方说有call

48:34.400 --> 48:35.400
对不对

48:35.400 --> 48:36.400
比方说

48:36.400 --> 48:38.400
有call

48:39.400 --> 48:40.400
对吧

48:40.400 --> 48:41.400
属性

48:41.400 --> 48:42.400
不然的话

48:42.400 --> 48:43.400
尽量避免印编

48:43.400 --> 48:44.400
我们在这里

48:44.400 --> 48:45.400
我们把一些可能的属性

48:45.400 --> 48:47.400
全部写出来

48:47.400 --> 48:48.400
然后这里就是

48:48.400 --> 48:49.400
还有什么

48:49.400 --> 48:51.400
还有tech

48:51.400 --> 48:52.400
对吧

48:52.400 --> 48:53.400
我们就写几个

48:53.400 --> 48:54.400
写几个

48:54.400 --> 48:55.400
我们后面还会扩充的

48:55.400 --> 48:57.400
还有什么 fork

48:57.400 --> 48:58.400
对不对

48:58.400 --> 48:59.400
fork

48:59.400 --> 49:00.400
还有什么

49:00.400 --> 49:03.400
还有tech

49:03.400 --> 49:05.400
还有什么

49:05.400 --> 49:06.400
还有all

49:06.400 --> 49:07.400
对不对

49:07.400 --> 49:09.400
我们先随便写几个

49:09.400 --> 49:11.400
随便写几个得了

49:11.400 --> 49:12.400
这就是

49:12.400 --> 49:14.400
用这个变量的记录

49:14.400 --> 49:16.400
所有可能出现的affect内容

49:16.400 --> 49:18.400
先写几个出来

49:18.400 --> 49:19.400
好

49:19.400 --> 49:20.400
写好之后

49:20.400 --> 49:21.400
我们再来看一下

49:21.400 --> 49:22.400
这个博客还要做一些事情

49:22.400 --> 49:23.400
还要来

49:23.400 --> 49:24.400
能够来帮助

49:24.400 --> 49:25.400
创建affect

49:25.400 --> 49:26.400
后边肯定要创建affect

49:26.400 --> 49:27.400
我们先暂时

49:27.400 --> 49:29.400
目前的好像没有什么用

49:29.400 --> 49:31.400
后边肯定有用

49:31.400 --> 49:33.400
来返回一个函数

49:33.400 --> 49:35.400
创建一个affect

49:35.400 --> 49:36.400
创建一个affect

49:36.400 --> 49:37.400
你给我传什么呢

49:37.400 --> 49:38.400
你看一下affect里边

49:38.400 --> 49:40.400
不就是有这么几个东西吗

49:40.400 --> 49:41.400
一个type

49:41.400 --> 49:43.400
一个payload

49:43.400 --> 49:44.400
这东西不用管

49:44.400 --> 49:45.400
跟我们没什么关系

49:45.400 --> 49:46.400
一个type

49:46.400 --> 49:47.400
一个payload

49:47.400 --> 49:49.400
你给我一个type

49:49.400 --> 49:51.400
一个payload

49:51.400 --> 49:53.400
你给我这两个东西

49:53.400 --> 49:55.400
那么我就来帮助你创建一个affect

49:55.400 --> 49:57.400
那么这个函数里边

49:57.400 --> 49:59.400
这个函数作用

49:59.400 --> 50:01.400
是用来创建affect

50:01.400 --> 50:03.400
那么这个type知道是什么

50:03.400 --> 50:06.400
有效的affect

50:06.400 --> 50:08.400
必须是有效的内容

50:08.400 --> 50:09.400
什么叫有效的内容

50:09.400 --> 50:10.400
就在这里面

50:10.400 --> 50:11.400
有效的内容

50:11.400 --> 50:12.400
你没有出现我要报错

50:12.400 --> 50:14.400
这里我们首先验证

50:14.400 --> 50:16.400
验证type值

50:16.400 --> 50:17.400
是不是正确的

50:17.400 --> 50:18.400
怎么验证呢

50:18.400 --> 50:19.400
非常简单

50:19.400 --> 50:20.400
我们把这个对象

50:20.400 --> 50:21.400
这个对象里面

50:21.400 --> 50:22.400
是不是保留了

50:22.400 --> 50:23.400
所有可能会出现的type值

50:23.400 --> 50:25.400
我们这里可以使用

50:25.400 --> 50:26.400
objects

50:26.400 --> 50:28.400
第二是Values

50:28.400 --> 50:29.400
取出这个对象

50:29.400 --> 50:31.400
里面所有的属性值

50:31.400 --> 50:33.400
是不是形成个数组

50:33.400 --> 50:34.400
取出对象里面

50:34.400 --> 50:35.400
所有的属性值

50:35.400 --> 50:36.400
形成个数组

50:36.400 --> 50:37.400
看一下这个数组里面

50:37.400 --> 50:39.400
是不是包含

50:39.400 --> 50:40.400
什么type值

50:40.400 --> 50:42.400
是不是包含type值

50:42.400 --> 50:43.400
如果说

50:43.400 --> 50:44.400
这个数组里面

50:44.400 --> 50:45.400
没有包含type值

50:45.400 --> 50:46.400
那么你危险了

50:46.400 --> 50:47.400
你给我一个

50:47.400 --> 50:49.400
什么乱七八糟的内形

50:49.400 --> 50:50.400
不能

50:50.400 --> 50:52.400
你不能是一个有效的affect

50:52.400 --> 50:55.910
跑出一个错误

50:55.910 --> 50:56.910
内形错误

50:56.910 --> 50:58.910
type error

50:58.910 --> 51:01.910
这是一个无效的

51:01.910 --> 51:05.910
这是一个无效的type值

51:05.910 --> 51:06.910
就写一个

51:06.910 --> 51:07.910
跑出个错误就完成了

51:07.910 --> 51:08.910
就验证type

51:08.910 --> 51:09.910
那么后面就是

51:09.910 --> 51:10.910
没有问题

51:10.910 --> 51:11.910
type没有问题的话

51:11.910 --> 51:12.910
很简单

51:12.910 --> 51:13.910
直接返回

51:13.910 --> 51:14.910
返回啥

51:14.910 --> 51:15.910
返回一个对象

51:15.910 --> 51:16.910
这个对象里边

51:16.910 --> 51:17.910
什么属性

51:17.910 --> 51:18.910
type的属性是咋

51:18.910 --> 51:19.910
type的属性

51:19.910 --> 51:20.910
是不是就是个type

51:20.910 --> 51:22.910
配楼的属性是咋

51:22.910 --> 51:23.910
配楼的属性

51:23.910 --> 51:25.910
是不是就是配楼的

51:25.910 --> 51:26.910
一次传给就行了

51:26.910 --> 51:28.910
我也不做任何事情

51:28.910 --> 51:29.910
无非让我在这里

51:29.910 --> 51:30.910
多加一个属性

51:30.910 --> 51:32.910
就是这个特殊的属性

51:32.910 --> 51:33.910
因为这个属性

51:33.910 --> 51:34.910
通过这个属性来判

51:34.910 --> 51:36.910
我可以用它来判断

51:36.910 --> 51:38.910
这个属性的名字

51:38.910 --> 51:39.910
叫这个

51:40.910 --> 51:42.910
可以用这个属性来判断

51:42.910 --> 51:44.910
你是不是一个affect

51:44.910 --> 51:45.910
把设为q

51:45.910 --> 51:46.910
就完成了

51:46.910 --> 51:47.910
特别特别简单

51:47.910 --> 51:49.910
就是创建一个affect的函数

51:49.910 --> 51:50.910
明白的意思吧

51:50.910 --> 51:51.910
当你理解了

51:51.910 --> 51:52.910
创建affect是怎么创建的

51:52.910 --> 51:53.910
就是创建一个对象

51:53.910 --> 51:54.910
啥都没做

51:54.910 --> 51:55.910
你别啥都没做

51:55.910 --> 51:56.910
管理是core

51:56.910 --> 51:57.910
还有type啥都没做

51:57.910 --> 51:59.910
它只是创建一个对象而已

51:59.910 --> 52:00.910
好那么这里

52:00.910 --> 52:01.910
我们就很好判断

52:01.910 --> 52:03.910
意思affect

52:03.910 --> 52:04.910
是不是一个affect了

52:04.910 --> 52:06.910
你给我一个对象

52:06.910 --> 52:07.910
我来判断这个对象

52:07.910 --> 52:08.910
是不是affect

52:08.910 --> 52:10.910
那怎么来判断的

52:10.910 --> 52:11.910
首先它必须是个对象

52:11.910 --> 52:15.910
如果说type obj

52:15.910 --> 52:17.910
不等于object

52:17.910 --> 52:18.910
它不是一个对象

52:18.910 --> 52:19.910
那对不起

52:19.910 --> 52:21.910
你肯定不是一个affect

52:21.910 --> 52:23.910
肯定不是一个affect

52:26.910 --> 52:27.910
对吧

52:27.910 --> 52:28.910
好

52:28.910 --> 52:29.910
如果说你是一个对象

52:29.910 --> 52:30.910
那么我们判断一下

52:30.910 --> 52:31.910
这个obj

52:31.910 --> 52:33.910
obj.

52:33.910 --> 52:34.910
什么属性

52:34.910 --> 52:35.910
是不是这个属性

52:35.910 --> 52:36.910
这个属性

52:36.910 --> 52:38.910
这个属性

52:38.910 --> 52:39.910
这个属性里面

52:39.910 --> 52:40.910
有非法的标识符

52:40.910 --> 52:41.910
所以说你得用

52:41.910 --> 52:43.910
锁印着这种方式来访问

52:43.910 --> 52:45.910
属性表达式来访问

52:45.910 --> 52:46.910
看一下这个属性

52:46.910 --> 52:47.910
是不是维修

52:47.910 --> 52:50.910
如果说它等于修的话

52:50.910 --> 52:52.910
那么它就表示

52:52.910 --> 52:53.910
也是一个

52:53.910 --> 52:55.910
它就是一个affect

52:55.910 --> 52:56.910
发回修

52:56.910 --> 52:57.910
否则的话

52:57.910 --> 52:58.910
它就不是affect

52:58.910 --> 52:59.910
对吧

52:59.910 --> 53:00.910
通这种方式来判定

53:00.910 --> 53:01.910
对吧

53:01.910 --> 53:02.910
当然

53:02.910 --> 53:04.910
你也可以再判断

53:04.910 --> 53:05.910
判断type payload的

53:05.910 --> 53:06.910
这些都是细致

53:06.910 --> 53:07.910
默诫的问题

53:07.910 --> 53:08.910
咱们就不用去care了

53:08.910 --> 53:09.910
这个东西

53:09.910 --> 53:10.910
判断一个对象

53:10.910 --> 53:11.910
是否是affect

53:11.910 --> 53:13.910
判断一个对象

53:13.910 --> 53:16.910
是否是affect

53:16.910 --> 53:17.910
我们知道affect

53:17.910 --> 53:18.910
如何来创建

53:18.910 --> 53:20.910
我们就知道如何来判断

53:20.910 --> 53:21.910
非常简单

53:21.910 --> 53:22.910
当然这里有重复代码

53:22.910 --> 53:23.910
对吧

53:23.910 --> 53:24.910
这两个地方重复了

53:24.910 --> 53:26.910
你可以专门在内部写个辩量

53:26.910 --> 53:27.910
写个辩量

53:27.910 --> 53:29.910
就是special

53:29.910 --> 53:30.910
affect

53:30.910 --> 53:32.910
name

53:32.910 --> 53:34.910
一个就特殊的affect

53:34.910 --> 53:35.910
对象

53:35.910 --> 53:37.910
它的特殊的属性名

53:37.910 --> 53:40.910
你可以写这么一个

53:40.910 --> 53:42.910
就是affect

53:42.910 --> 53:43.910
对象

53:43.910 --> 53:46.910
特殊的属性名

53:46.910 --> 53:47.910
就放到那个辩量里面

53:47.910 --> 53:48.910
那么这里呢

53:48.910 --> 53:50.910
我们就可以用这个辩量的值

53:50.910 --> 53:51.910
对吧

53:51.910 --> 53:52.910
用这个辩量的值

53:52.910 --> 53:53.910
这里也是

53:53.910 --> 53:55.910
用这个辩量的值就可以了

53:55.910 --> 53:56.910
对吧

53:56.910 --> 53:58.910
这些都没什么好说的

53:58.910 --> 53:59.910
好

53:59.910 --> 54:00.910
用到这个东西帮助之后

54:00.910 --> 54:01.910
我们在这边来

54:01.910 --> 54:02.910
是不是就可以判断

54:02.910 --> 54:03.910
是不是affect了

54:03.910 --> 54:04.910
好

54:04.910 --> 54:05.910
这里导入

54:05.910 --> 54:06.910
import

54:06.910 --> 54:07.910
导入什么

54:07.910 --> 54:09.910
ease effect

54:09.910 --> 54:11.910
from

54:11.910 --> 54:13.910
affect

54:13.910 --> 54:15.910
affect help

54:15.910 --> 54:17.910
把这个

54:17.910 --> 54:18.910
扣起来

54:18.910 --> 54:19.910
因为它没有没人导出

54:19.910 --> 54:21.910
它这里边有个ease effect

54:21.910 --> 54:22.910
好

54:22.910 --> 54:23.910
那么这里

54:23.910 --> 54:24.910
我们要如何来判断

54:24.910 --> 54:25.910
是不是一个affect

54:25.910 --> 54:26.910
那么这里

54:26.910 --> 54:27.910
是不是可以用ease effect

54:27.910 --> 54:28.910
对吧

54:28.910 --> 54:29.910
来判断

54:29.910 --> 54:30.910
判断什么

54:30.910 --> 54:31.910
这里呈现天啥

54:31.910 --> 54:32.910
这里天啥

54:32.910 --> 54:33.910
要判断啥

54:33.910 --> 54:34.910
判断这个value

54:34.910 --> 54:35.910
是不是affect

54:35.910 --> 54:36.910
对吧

54:36.910 --> 54:37.910
那么这里我们输出

54:37.910 --> 54:39.910
这个是一个

54:39.910 --> 54:40.910
affect

54:40.910 --> 54:41.910
是一个affect

54:41.910 --> 54:42.910
好

54:42.910 --> 54:43.910
那咱们来看一下吧

54:43.910 --> 54:44.910
我们这里

54:44.910 --> 54:45.910
由于我们现在

54:45.910 --> 54:46.910
自己还没有写affect

54:46.910 --> 54:47.910
那么我们affect

54:47.910 --> 54:48.910
就用它官方的

54:48.910 --> 54:50.910
就用它官方的affect

54:50.910 --> 54:51.910
于是

54:51.910 --> 54:52.910
我们这里启动的时候

54:52.910 --> 54:53.910
用我们自己的

54:53.910 --> 54:54.910
你看着

54:56.910 --> 54:57.910
好

54:57.910 --> 54:58.910
保存

54:58.910 --> 54:59.910
你看一下

54:59.910 --> 55:01.910
是不是一个affect

55:01.910 --> 55:02.910
这里

55:02.910 --> 55:03.910
我还没有用ease effect

55:03.910 --> 55:04.910
没有用ease effect

55:04.910 --> 55:07.730
好

55:07.730 --> 55:08.730
把这个去掉

55:08.730 --> 55:09.730
保存

55:09.730 --> 55:10.730
你看

55:10.730 --> 55:11.730
是不是得到一个affect

55:11.730 --> 55:12.730
因为ease effect

55:12.730 --> 55:14.730
后面它会是不是给它一个东西

55:14.730 --> 55:16.730
调那个函数得到一个东西

55:16.730 --> 55:17.730
调那个函数得到东西

55:17.730 --> 55:18.730
我们刚刚都看到了

55:18.730 --> 55:19.730
就是一个affect

55:19.730 --> 55:20.730
好

55:20.730 --> 55:21.730
如果说我这里ease effect

55:21.730 --> 55:22.730
一个ease effect

55:22.730 --> 55:23.730
你看一下

55:23.730 --> 55:24.730
ease effect

55:24.730 --> 55:25.730
它不是一个affect

55:25.730 --> 55:26.730
对吧

55:26.730 --> 55:27.730
那么在wrong saga

55:27.730 --> 55:28.730
可以拿到这个东西了

55:28.730 --> 55:29.730
这里边

55:29.730 --> 55:30.730
好

55:30.730 --> 55:31.730
那么具体

55:31.730 --> 55:32.730
试一个affect

55:32.730 --> 55:33.730
怎么处理

55:33.730 --> 55:35.730
我们下节课再说

55:35.730 --> 55:36.730
如果它试一个affect

55:36.730 --> 55:37.730
怎么来处理

55:37.730 --> 55:38.730
我们下节课再说

55:38.730 --> 55:39.730
我们先来看

55:39.730 --> 55:40.730
它不是一个affect

55:40.730 --> 55:41.730
affect的情况

55:41.730 --> 55:43.730
不是一个affect的话

55:43.730 --> 55:44.730
它又会经过凉

55:44.730 --> 55:46.730
它又会有凉重情况

55:46.730 --> 55:48.730
又会有凉重情况

55:48.730 --> 55:49.730
哪两种情况

55:49.730 --> 55:50.730
哪两种情况

55:50.730 --> 55:52.730
第一种情况

55:52.730 --> 55:54.730
情况一

55:54.730 --> 55:56.730
就是得到一个ease effect

55:56.730 --> 55:58.730
就是得到的

55:58.730 --> 56:00.730
就是value

56:00.730 --> 56:01.730
它不是一个affect

56:01.730 --> 56:04.730
但是它是一个promise

56:04.730 --> 56:05.730
我们之前说过

56:05.730 --> 56:07.730
如果说你在wrong saga里边

56:07.730 --> 56:09.730
你在ease的后面写个promise

56:09.730 --> 56:10.730
是不是要等待

56:10.730 --> 56:11.730
等待它完成

56:11.730 --> 56:12.730
完成过后才会继续运行

56:12.730 --> 56:13.730
对吧

56:13.730 --> 56:14.730
它是一个promise

56:14.730 --> 56:15.730
这种情况

56:15.730 --> 56:16.730
情况二

56:16.730 --> 56:17.730
就是其他

56:17.730 --> 56:18.730
对吧

56:18.730 --> 56:19.730
就其他

56:19.730 --> 56:20.730
好

56:20.730 --> 56:21.730
那么这里一个分为两种情况

56:21.730 --> 56:22.730
首先我判断

56:22.730 --> 56:23.730
它是不是一个promise

56:23.730 --> 56:24.730
因为promise我们要特殊处理

56:24.730 --> 56:25.730
只不过

56:25.730 --> 56:27.730
不是很建议大家

56:27.730 --> 56:28.730
不是很建议大家

56:28.730 --> 56:31.730
就是用在这个saga里边

56:31.730 --> 56:32.730
ease的后面

56:32.730 --> 56:33.730
直接写promise

56:33.730 --> 56:34.730
得到一个promise

56:34.730 --> 56:35.730
最好是用call

56:35.730 --> 56:36.730
因为我们刚才看到了

56:36.730 --> 56:38.730
promise反回来就是一个promise对象

56:38.730 --> 56:40.730
而call反回来是一个什么

56:40.730 --> 56:41.730
描述对象

56:41.730 --> 56:43.730
反回统一的一种对象格式

56:43.730 --> 56:45.730
便于我们后面做单元测试

56:45.730 --> 56:46.730
只不过

56:46.730 --> 56:47.730
但是它允许你这样做

56:47.730 --> 56:48.730
所以我们要判断

56:48.730 --> 56:50.730
value是不是一个promise

56:50.730 --> 56:52.730
这里ease的东西

56:52.730 --> 56:54.730
它有可能不是eaffect对象

56:54.730 --> 56:56.730
你不一定调整的是这些函数

56:56.730 --> 56:57.730
你可能调整的是一个apn

56:57.730 --> 56:59.730
反过来是一个promise

56:59.730 --> 57:01.730
那么也就还有其他情况

57:01.730 --> 57:03.730
就是说这里

57:03.730 --> 57:05.730
它还有可能是promise

57:05.730 --> 57:09.620
promise传递过去的

57:09.620 --> 57:11.620
它传递过去的可能是promise

57:11.620 --> 57:12.620
还有可能是其他

57:12.620 --> 57:13.620
其他我就啥都不管了

57:13.620 --> 57:18.510
我就啥都不管了

57:18.510 --> 57:19.510
传递是其他

57:19.510 --> 57:20.510
都有可能

57:20.510 --> 57:21.510
我们分开来搞定

57:21.510 --> 57:24.510
如果说你是一个promise

57:24.510 --> 57:26.510
import

57:26.510 --> 57:28.510
我们要判断它是不是你promise

57:28.510 --> 57:29.510
所以说需要一个函数

57:29.510 --> 57:30.510
我们之前安装一个库

57:30.510 --> 57:32.510
叫做ease promise

57:32.510 --> 57:33.510
这个库

57:33.510 --> 57:34.510
这个库就是来判断一个东西

57:34.510 --> 57:35.510
是不是promise

57:35.510 --> 57:37.510
来吧

57:37.510 --> 57:38.510
如果说

57:38.510 --> 57:39.510
或者在这里

57:39.510 --> 57:41.510
lcf

57:41.510 --> 57:44.510
这里ease promise

57:44.510 --> 57:46.510
这个value是一个promise

57:46.510 --> 57:52.290
lcf就是其他情况

57:52.290 --> 57:54.290
这里的情况

57:54.290 --> 57:55.290
ease

57:55.290 --> 57:58.290
这里是一个affect

57:59.290 --> 58:01.290
这里是情况2

58:01.290 --> 58:03.290
这里是情况3

58:03.290 --> 58:04.290
情况2

58:04.290 --> 58:05.290
如果它是一个promise

58:05.290 --> 58:06.290
怎么办呢

58:06.290 --> 58:07.290
这一简单

58:07.290 --> 58:08.290
也不是promise吗

58:08.290 --> 58:09.290
这个value是promise

58:09.290 --> 58:10.290
然后呢

58:10.290 --> 58:12.290
你总得完成吧

58:12.290 --> 58:13.290
你总得完成吧

58:13.290 --> 58:15.290
完成的时候

58:15.290 --> 58:17.290
我现在不给你做啥事情

58:17.290 --> 58:18.290
我等你

58:18.290 --> 58:19.290
我等你

58:19.290 --> 58:20.290
等你完成之后

58:20.290 --> 58:22.290
你不是得给我一个结果吗

58:22.290 --> 58:23.290
对不对

58:23.290 --> 58:25.290
得给我一个结果

58:25.290 --> 58:27.290
我把这个结果

58:27.290 --> 58:28.290
为参数

58:28.290 --> 58:30.290
再去调用下一个

58:30.290 --> 58:31.290
我等你

58:31.290 --> 58:32.290
我不着急

58:32.290 --> 58:33.290
比方说你这里

58:33.290 --> 58:34.290
我们这里

58:34.290 --> 58:35.290
到时候这样的写的

58:35.290 --> 58:38.290
这里是一个lease promise

58:38.290 --> 58:39.290
比方说

58:39.290 --> 58:40.290
这里是写的啥啥啥啥

58:40.290 --> 58:41.290
我等你

58:41.290 --> 58:42.290
我管理运行多久了

58:42.290 --> 58:43.290
你总得完成吧

58:43.290 --> 58:45.290
完成过后

58:45.290 --> 58:47.290
我再继续往后边运行

58:47.290 --> 58:48.290
我把你promise

58:48.290 --> 58:49.290
resolve的结果

58:49.290 --> 58:50.290
传给它

58:50.290 --> 58:51.290
然后继续往后边运行

58:51.290 --> 58:52.290
是不是要调用那个时候

58:52.290 --> 58:53.290
那个时候就是继续运行

58:53.290 --> 58:54.290
对吧

58:54.290 --> 58:55.290
你不调用那个时候

58:55.290 --> 58:56.290
它就不会继续运行

58:56.290 --> 58:57.290
你调用那个时候

58:57.290 --> 58:58.290
它就会继续运行

58:58.290 --> 58:59.290
明白的意思吗

58:59.290 --> 59:01.290
那么我等你完成之后

59:01.290 --> 59:03.290
我再去调用那个时候

59:03.290 --> 59:04.290
那个时候就是相当于

59:04.290 --> 59:05.290
地柜调用了

59:05.290 --> 59:06.290
地柜不要去想它的

59:06.290 --> 59:08.290
代码的运行方式

59:08.290 --> 59:09.290
要想运的

59:09.290 --> 59:11.290
你就想这个逻辑是不对的

59:11.290 --> 59:13.290
那个时候就是继续往后面运行

59:13.290 --> 59:14.290
它有三个属性

59:14.290 --> 59:15.290
一个是下个值

59:15.290 --> 59:16.290
一个是错误

59:16.290 --> 59:17.290
一个是一手

59:17.290 --> 59:18.290
那么它这里有没有错误呢

59:18.290 --> 59:19.290
肯定没有

59:19.290 --> 59:20.290
它完成了嘛

59:20.290 --> 59:22.290
所以说我只要把下一个值

59:22.290 --> 59:23.290
告诉它就行了

59:23.290 --> 59:24.290
值就是这个resolve的结果

59:24.290 --> 59:25.290
对吧

59:25.290 --> 59:26.290
就写完了

59:26.290 --> 59:27.290
就写完了

59:27.290 --> 59:29.290
那么开启呢

59:29.290 --> 59:30.290
开启是有错误

59:30.290 --> 59:31.290
对吧

59:31.290 --> 59:32.290
有错误

59:32.290 --> 59:33.290
如果说有错误的时候

59:33.290 --> 59:34.290
是不是我调用那个时候

59:34.290 --> 59:35.290
对吧

59:35.290 --> 59:37.290
调用那个时候

59:37.290 --> 59:38.290
那个时候里面

59:38.290 --> 59:40.290
value 已经没了

59:40.290 --> 59:43.290
错误我给你传一个 error 进来

59:43.290 --> 59:44.290
传一个 error 进来

59:44.290 --> 59:45.290
没有结束

59:45.290 --> 59:46.290
对吧

59:46.290 --> 59:47.290
这就是这些写法

59:47.290 --> 59:48.290
特别特别简单

59:48.290 --> 59:49.290
对吧

59:49.290 --> 59:50.290
完了 没了

59:50.290 --> 59:52.290
如果是个 promise 等它完成

59:52.290 --> 59:53.290
完成过后

59:53.290 --> 59:54.290
我再进行下一步

59:54.290 --> 59:55.290
完成我又不管了

59:55.290 --> 59:56.290
不管了

59:56.290 --> 59:57.290
你自己去做吧

59:57.290 --> 59:58.290
反正写了回调的

59:58.290 --> 59:59.290
这里是个回调函数

59:59.290 --> 01:00:00.290
到时候回调函数

01:00:00.290 --> 01:00:01.290
质量会运行

01:00:01.290 --> 01:00:03.290
好 如果说其他情况呢

01:00:03.290 --> 01:00:04.290
你既不是一个 promise

01:00:04.290 --> 01:00:05.290
又不是一个 effect

01:00:05.290 --> 01:00:06.290
那我干嘛呢

01:00:06.290 --> 01:00:08.290
我也不知道你给我写的是啥玩意

01:00:08.290 --> 01:00:09.290
那我就干嘛

01:00:09.290 --> 01:00:10.290
直接下一步

01:00:10.290 --> 01:00:11.290
直接下一步

01:00:11.290 --> 01:00:12.290
我就把这个

01:00:12.290 --> 01:00:14.290
这一步得到了 value 值

01:00:14.290 --> 01:00:15.290
直接登进去

01:00:15.290 --> 01:00:16.290
作为下一步

01:00:16.290 --> 01:00:19.290
直接进行下一步

01:00:20.290 --> 01:00:21.290
好 我就这里

01:00:21.290 --> 01:00:23.290
至少我们现在除了 effect 之外

01:00:23.290 --> 01:00:24.290
是不是写完了

01:00:24.290 --> 01:00:25.290
这一情况很好处理

01:00:25.290 --> 01:00:27.290
好 咱们来看一下吧

01:00:27.290 --> 01:00:28.290
我们这里呢

01:00:28.290 --> 01:00:29.290
比方说吧

01:00:29.290 --> 01:00:30.290
写了这么一个生存器

01:00:30.290 --> 01:00:32.290
我这里也先不用这个 effect

01:00:32.290 --> 01:00:33.290
我们现在都还没处理

01:00:33.290 --> 01:00:34.290
比方说

01:00:34.290 --> 01:00:37.290
这里写上这么一个就是函数

01:00:37.290 --> 01:00:40.290
就是 test 这么一个函数

01:00:40.290 --> 01:00:41.290
return

01:00:41.290 --> 01:00:43.290
new 一个 promise

01:00:43.290 --> 01:00:44.290
resolve

01:00:44.290 --> 01:00:45.290
reject

01:00:49.290 --> 01:00:53.630
好 这里等待3秒

01:00:53.630 --> 01:00:54.630
等待2秒钟吧

01:00:54.630 --> 01:00:55.630
写 time out

01:00:55.630 --> 01:00:56.630
等待2秒钟

01:00:56.630 --> 01:00:57.630
2秒钟之后呢

01:00:57.630 --> 01:00:59.630
我们resolve 一个值

01:00:59.630 --> 01:01:00.630
mess

01:01:00.630 --> 01:01:01.630
return

01:01:01.630 --> 01:01:02.630
resolve 一个值

01:01:02.630 --> 01:01:04.630
好 咱们来试用一下

01:01:04.630 --> 01:01:06.630
这里呢 eo 的 test

01:01:08.630 --> 01:01:12.320
三个开始

01:01:12.320 --> 01:01:13.320
这里 abc 放在这吧

01:01:13.320 --> 01:01:15.320
abc

01:01:15.320 --> 01:01:16.320
放在这

01:01:16.320 --> 01:01:17.320
三个开始

01:01:17.320 --> 01:01:18.320
好 开始过后呢

01:01:18.320 --> 01:01:20.320
我们这里 eo 的一个 test

01:01:20.320 --> 01:01:21.320
雕像 test

01:01:21.320 --> 01:01:22.320
它返回来是不是 a promise

01:01:22.320 --> 01:01:23.320
对吧

01:01:23.320 --> 01:01:24.320
返回来是 a promise

01:01:24.320 --> 01:01:25.320
这里面呢

01:01:25.320 --> 01:01:27.320
我们得到它的 result

01:01:27.320 --> 01:01:28.320
resolve 得到是什么

01:01:28.320 --> 01:01:30.320
得到是 resolve 的结构

01:01:30.320 --> 01:01:31.320
这里呢

01:01:31.320 --> 01:01:32.320
我们输出 result

01:01:32.320 --> 01:01:33.320
然后呢

01:01:33.320 --> 01:01:34.320
我们在这里呢

01:01:34.320 --> 01:01:35.320
后边再写

01:01:35.320 --> 01:01:37.320
再 eo 的一个其他玩意儿

01:01:37.320 --> 01:01:38.320
eo 的一个其他玩意儿

01:01:38.320 --> 01:01:39.320
比方说 123

01:01:39.320 --> 01:01:40.320
123

01:01:40.320 --> 01:01:42.320
const

01:01:42.320 --> 01:01:44.320
还是用 result

01:01:46.320 --> 01:01:47.320
resolve

01:01:47.320 --> 01:01:48.320
等于 123

01:01:48.320 --> 01:01:49.320
输出 result

01:01:49.320 --> 01:01:50.320
好 你看一下

01:01:50.320 --> 01:01:51.320
咱们写到这么一些情况

01:01:51.320 --> 01:01:53.320
保存我们这里呢

01:01:53.320 --> 01:01:54.320
index 里面

01:01:56.320 --> 01:01:57.320
index 里面

01:01:57.320 --> 01:01:58.320
我们使用的是自己的

01:01:58.320 --> 01:01:59.320
redacted saga

01:01:59.320 --> 01:02:01.320
好 看一下吧

01:02:01.320 --> 01:02:02.320
刷新

01:02:02.320 --> 01:02:03.320
三个开始什么

01:02:03.320 --> 01:02:04.320
等待两秒

01:02:04.320 --> 01:02:05.320
对吧 两秒

01:02:05.320 --> 01:02:06.320
然后运行这个

01:02:06.320 --> 01:02:07.320
运行这个

01:02:07.320 --> 01:02:08.320
对吧

01:02:08.320 --> 01:02:09.320
好 然后我们再测试一下

01:02:09.320 --> 01:02:10.320
redacted

01:02:10.320 --> 01:02:11.320
再测试一下 redacted

01:02:11.320 --> 01:02:12.320
好 这里面呢

01:02:12.320 --> 01:02:14.320
我们给它这么一个东西

01:02:14.320 --> 01:02:16.320
if mass write down

01:02:16.320 --> 01:02:18.320
write down

01:02:18.320 --> 01:02:19.320
大约了0.5

01:02:19.320 --> 01:02:20.320
那么就完成

01:02:20.320 --> 01:02:22.320
resolve 完成

01:02:23.320 --> 01:02:25.320
else

01:02:25.320 --> 01:02:27.320
就 reject

01:02:27.320 --> 01:02:29.320
失败

01:02:29.320 --> 01:02:30.320
redacted 失败

01:02:30.320 --> 01:02:31.320
好 保存

01:02:31.320 --> 01:02:32.320
你看一下

01:02:33.320 --> 01:02:34.320
两秒钟完成

01:02:34.320 --> 01:02:35.320
这是完成

01:02:35.320 --> 01:02:36.320
再来

01:02:37.320 --> 01:02:38.320
完成

01:02:38.320 --> 01:02:39.320
失败了

01:02:39.320 --> 01:02:40.320
来

01:02:40.320 --> 01:02:41.320
好 你看

01:02:41.320 --> 01:02:42.320
失败 是不是包了一个错

01:02:42.320 --> 01:02:43.320
对不对

01:02:43.320 --> 01:02:44.320
是不是在这里面

01:02:44.320 --> 01:02:45.320
包了一个错

01:02:45.320 --> 01:02:46.320
那么这里面

01:02:46.320 --> 01:02:47.320
哪个位置包错的

01:02:47.320 --> 01:02:48.320
是不是在这个位置包错的

01:02:48.320 --> 01:02:49.320
为什么会包错

01:02:49.320 --> 01:02:51.320
因为它在这边

01:02:51.320 --> 01:02:52.320
装Saga里边

01:02:52.320 --> 01:02:53.320
装Saga里边

01:02:53.320 --> 01:02:54.320
它掉到那个时候

01:02:54.320 --> 01:02:55.320
你看一下

01:02:55.320 --> 01:02:56.320
如果说有这个车了

01:02:56.320 --> 01:02:57.320
是不是就失败了

01:02:57.320 --> 01:02:58.320
失败了过后

01:02:58.320 --> 01:02:59.320
传了什么

01:02:59.320 --> 01:03:00.320
传了一个error

01:03:00.320 --> 01:03:02.320
把你与这个车里面的参数

01:03:02.320 --> 01:03:03.320
就在这

01:03:06.320 --> 01:03:07.320
在这 与这个车里面

01:03:07.320 --> 01:03:08.320
这个东西

01:03:08.320 --> 01:03:09.320
这个东西交给谁了

01:03:09.320 --> 01:03:10.320
是不是交给他了

01:03:10.320 --> 01:03:11.320
那么他是不是

01:03:11.320 --> 01:03:12.320
把他传到那个车

01:03:12.320 --> 01:03:13.320
这个参数里面去

01:03:13.320 --> 01:03:15.320
当再一次掉到那个车

01:03:15.320 --> 01:03:16.320
再一次掉到那个车的时候

01:03:16.320 --> 01:03:17.320
那么这一次

01:03:17.320 --> 01:03:18.320
他发现这个error有指

01:03:18.320 --> 01:03:19.320
是不是他掉了throw

01:03:19.320 --> 01:03:20.320
对吧

01:03:20.320 --> 01:03:21.320
throw

01:03:21.320 --> 01:03:22.320
他就这么来的

01:03:22.320 --> 01:03:24.320
所以说这里就包错了

01:03:24.320 --> 01:03:25.320
这里就包错了

01:03:26.320 --> 01:03:27.320
这里是不是包错了

01:03:27.320 --> 01:03:28.320
那么我们这里

01:03:28.320 --> 01:03:29.320
是不是可以进一步进行处理

01:03:29.320 --> 01:03:30.320
对吧

01:03:30.320 --> 01:03:31.320
比方说我们这里

01:03:31.320 --> 01:03:32.320
还可以用个trycache

01:03:32.320 --> 01:03:35.700
trycache

01:03:35.700 --> 01:03:38.400
cache

01:03:38.400 --> 01:03:39.400
cache

01:03:39.400 --> 01:03:40.400
来得到这个error

01:03:40.400 --> 01:03:41.400
因为我们之前讲过生存器

01:03:41.400 --> 01:03:42.400
生存器里边

01:03:42.400 --> 01:03:44.400
如果说这里拋了一个错误出来

01:03:44.400 --> 01:03:45.400
那么他会把这个错误的东西

01:03:45.400 --> 01:03:46.400
作为参数传过来

01:03:46.400 --> 01:03:47.400
你看

01:03:47.400 --> 01:03:48.400
错误的东西作为传数传过来

01:03:48.400 --> 01:03:49.400
那么他会

01:03:49.400 --> 01:03:50.400
在生存器内部

01:03:50.400 --> 01:03:51.400
他就会引发一个错误

01:03:51.400 --> 01:03:52.400
然后进入cache的执行

01:03:52.400 --> 01:03:53.400
那么这里能开启

01:03:53.400 --> 01:03:54.400
那么就输出error

01:03:54.400 --> 01:03:55.400
那就不爆错了

01:03:55.400 --> 01:03:56.400
对吧

01:03:56.400 --> 01:03:57.400
我们只是把个错误

01:03:57.400 --> 01:03:58.400
支付出来输出

01:03:58.400 --> 01:03:59.400
你看

01:03:59.400 --> 01:04:00.400
刚才是失败

01:04:00.400 --> 01:04:01.400
这件事完成

01:04:03.400 --> 01:04:04.400
等一下

01:04:04.400 --> 01:04:07.030
失败

01:04:07.030 --> 01:04:08.030
对吧

01:04:08.030 --> 01:04:09.030
失败

01:04:09.030 --> 01:04:10.030
甚至在失败的时候

01:04:10.030 --> 01:04:11.030
是不是你可以继续写

01:04:11.030 --> 01:04:12.030
对吧

01:04:12.030 --> 01:04:13.030
继续写eod

01:04:13.030 --> 01:04:14.030
eod

01:04:14.030 --> 01:04:15.030
456

01:04:15.030 --> 01:04:20.860
比方说

01:04:20.860 --> 01:04:21.860
保存看一下

01:04:21.860 --> 01:04:24.360
失败

01:04:24.360 --> 01:04:25.360
456

01:04:25.360 --> 01:04:26.360
对吧

01:04:26.360 --> 01:04:27.360
还可以继续写

01:04:27.360 --> 01:04:28.360
对不对

01:04:28.360 --> 01:04:29.360
因为他只要遇到了eod

01:04:29.360 --> 01:04:30.360
进行下一步

01:04:30.360 --> 01:04:31.360
直到什么

01:04:31.360 --> 01:04:32.360
直到迭代结束

01:04:32.360 --> 01:04:33.360
这个函数才会结束

01:04:33.360 --> 01:04:34.360
这个函数是一个不断

01:04:34.360 --> 01:04:35.360
帝规的过程

01:04:35.360 --> 01:04:36.360
是一个不断帝规的过程

01:04:36.360 --> 01:04:37.360
好

01:04:37.360 --> 01:04:38.360
那么现在呢

01:04:38.360 --> 01:04:39.360
我们搞定了

01:04:39.360 --> 01:04:40.360
情况2和情况3

01:04:40.360 --> 01:04:41.360
现在就剩下情况1了

01:04:41.360 --> 01:04:42.360
就是一个affect对象

01:04:42.360 --> 01:04:43.360
怎么去完成的

01:04:43.360 --> 01:04:44.360
好

01:04:44.360 --> 01:04:45.360
这个呢

01:04:45.360 --> 01:04:46.360
我们下一个再开始讲

01:04:46.360 --> 01:04:47.360
这一刻

01:04:47.360 --> 01:04:48.360
我们先把这个股价写出来

01:04:48.360 --> 01:04:49.360
好

01:04:49.360 --> 01:04:50.360
那么大家呢

01:04:50.360 --> 01:04:51.360
下来呢

01:04:51.360 --> 01:04:52.360
就是先

01:04:52.360 --> 01:04:53.360
先做这么一件事

01:04:53.360 --> 01:04:54.360
就是把这个代码结构

01:04:54.360 --> 01:04:55.360
写成我这种结构

01:04:55.360 --> 01:04:56.360
写成我这种结构

01:04:56.360 --> 01:04:57.360
之后呢

01:04:57.360 --> 01:04:58.360
再听下面的个程

01:04:58.360 --> 01:04:59.360
完了话的

01:04:59.360 --> 01:05:00.360
后边越听越云

01:05:00.360 --> 01:05:01.360
越听越云

01:05:01.360 --> 01:05:02.360
后边代码很多

01:05:02.360 --> 01:05:03.360
好

01:05:03.360 --> 01:05:04.360
先把写出来

01:05:04.360 --> 01:05:05.360
这种结构先写出来

