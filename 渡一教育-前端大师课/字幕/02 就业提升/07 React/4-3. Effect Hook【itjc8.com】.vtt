WEBVTT

00:01.070 --> 00:05.570
这节课呢 咱们呢讲一讲这个东西啊 又是一个hook

00:06.430 --> 00:14.950
之前呢 咱们讲过了这个state hook 对吧 那么这个玩意呢 是来解决什么呢 是在为了在函数组建中使用状态

00:16.150 --> 00:23.470
而我们现在这节课学习的这个effect啊 怎么读啊 怎么读啊 应该读effect 还是afflact

00:24.510 --> 00:25.710
不靠 这个网怎么呢

00:27.630 --> 00:31.300
什么情况 还都讨论不了

00:33.020 --> 00:40.340
等一下啊 我把这个这个玩意关掉啊 这个我看他怎么读的啊

00:41.860 --> 00:51.220
呃 effect effect 应该是这样读的啊 effect effect hook呢 这个东西呢 他在做什么用呢 他是用于处理啊

00:52.260 --> 00:56.740
用于在函数组建中处理副作用

00:57.780 --> 01:04.580
之前呢 咱们介绍过这个副作用啊 我们说如果说一个函数他没有副作用的话 那么他

01:04.580 --> 01:11.620
这个函数呢 叫做纯函数 对吧 是这样子 我们的函数组建本身呢 他是一个函数

01:12.180 --> 01:20.820
那么这个函数本身 他是不能带副作用的啊 这是right 他不说强制要求吧 他是推荐不要这样做啊 不要这样做 是不能自己

01:21.220 --> 01:24.980
不能不能带副作用 一个组建呢 就是一个非常非常纯粹的东西

01:25.780 --> 01:29.860
就根据你传的属性或者是自身的状态来进行某种变化

01:30.580 --> 01:39.940
呃 然后我们的副作用操作呢 比方说哪些是副作用操作啊 阿迦克斯请求对吧 或者是啊 即时器啊

01:40.580 --> 01:45.860
等等异步啊 异步的方式啊 或者是其他异步啊 异步操作

01:46.740 --> 01:48.740
或者是呢 什么呃 更改

01:49.460 --> 01:52.500
多么啊 真实多么对象啊 真实多么对象

01:53.220 --> 01:59.060
这些呢 都属于副作用的操作啊 以及呢 其他呃 会对

02:00.580 --> 02:03.140
外部产生啊

02:04.020 --> 02:09.940
影响的操作啊 比方说还有哪些呢 比方说呃 本地存储

02:11.380 --> 02:14.100
就nocal storage啊 这些呢 都属于副作用

02:14.820 --> 02:18.100
其实呢 rector 很早很早就反复强调了

02:18.500 --> 02:23.620
副作用的应该 如果如果以前啊 没有这个 hook 的和没有这个 hook 的时候呢

02:23.940 --> 02:28.580
我们当时使用的是内组件 对吧 内组件里边不是有很多的生命周期函数吗

02:29.220 --> 02:31.220
rex官方呢 反复的强调

02:31.780 --> 02:37.460
生命周期函数里边 哪些生命周期函数是能够使用副作用的 哪些是不能的

02:38.020 --> 02:42.420
尽管他反复的这样去强调 结果呢 开发者还是会犯错

02:43.220 --> 02:45.540
所以说呢 借这个 hook 的机会

02:46.100 --> 02:49.380
他就干脆直接给你出了一个 effect effect hook

02:50.020 --> 02:52.260
就专门来用于处理副作用的 hook

02:52.820 --> 02:55.940
那么通过这个名字你就看得到啊 你就能看到

02:56.340 --> 02:59.540
那么他就是专门来处理副作用的 所以说你就不要去乱用了啊

03:00.100 --> 03:03.940
没有什么副作用的操作 你就不要往这里面放了啊 他专门来处理其他副作用的

03:04.260 --> 03:10.820
好 咱们来看一下这个生命周期啊 我们以前在学习内的时候呢 我们讲过这么一些生命周期

03:11.780 --> 03:17.780
学习的内组件的时候 我们当时说了生命周期里边哪些地方可以处理副作用这个地方

03:18.500 --> 03:24.980
component did amount 当时我们还要做了一些练习 就包括什么获取学生数据 对吧 都是在这里面获取的

03:25.460 --> 03:27.300
还有什么地方呢 这个 did update

03:28.340 --> 03:35.380
就成为页面上真实动物啊 就是都是真实动物完成之后啊的操作 那么这些地方呢应该处理副作用

03:35.860 --> 03:41.460
啊 包括怎么 啊 组件销毁的可能要做一些日子记录啊等等等等啊 那么这些地方是有副作用

03:42.100 --> 03:46.420
但是由于我们之前内组件的生命周期比较复杂 他提供的函数比较多

03:46.980 --> 03:49.060
其他的函数都不能有副作用啊 都不能有

03:49.700 --> 03:56.100
由于我们之前呢 这些生命周期里边函数很多 而且呢 很多的开发者呢 不太注意这个细节

03:57.060 --> 03:59.780
把副作用到处乱用 导致了一些bug

04:00.420 --> 04:09.540
因为我们知道 这些方法呢 其实都有可能会被调用两遍的 因为涉及到服务端炫的啊 可能现在呢 你们还没有学习服务端炫的啊 没关系

04:09.780 --> 04:14.580
你只要知道 这些方法呢 都可能会被调用两次 所以说不应该有任何的副作用

04:15.700 --> 04:20.660
能够进行副作用的方法 只有这么三个啊 这三个方法是只能只会运行一次的

04:21.620 --> 04:25.940
那么就保证了啊 咱们的副作用呢 是正确的影响到了外部的数据

04:26.660 --> 04:33.540
那么 尽管rex官方反复的强调着一点 结果还是要犯错 所以说他后来更新了这个生命周期

04:34.100 --> 04:37.940
啊 但是更新了之后还是要犯错 现在的就出现了hook

04:38.660 --> 04:42.980
你用他就不会犯错了 为什么呢 因为他的名字就叫做effect

04:43.300 --> 04:49.540
你用他的时候 他就在提醒你 这里边是副作用的操作 那么其他地方的都不应该有副作用的操作

04:50.580 --> 04:55.780
好 那么这个东西怎么来玩呢 这个东西 他是这样子啊 他本质上的是一个函数啊

04:55.940 --> 05:01.700
他什么函数呢 他是函数就是use之前我们学的是use state 对吧 那么这个函数叫做use effect

05:02.340 --> 05:06.660
使用副作用啊 添加一个副作用的操作啊 该函数

05:08.020 --> 05:12.500
该函数接收一个函数作为参数

05:14.100 --> 05:17.540
那么这个函数呢 接收的函数

05:18.260 --> 05:23.380
接收的函数就是需要进行副作用

05:24.580 --> 05:29.620
操作的函数 比方说咱们Rx请求啊 等等等等啊 我们都可以在这个函数里面完成

05:30.180 --> 05:33.380
嗯 这里呢 我给大家举个例子吧 也是官方的一个例子

05:34.340 --> 05:36.500
嗯 比方说这里一个组件 函数组件

05:36.980 --> 05:38.980
这个函数组件里边呢 我们

05:39.620 --> 05:40.420
这样吧

05:41.620 --> 05:44.260
啊 写个按钮啊 这里有个数字

05:44.420 --> 05:47.860
啊 这里有个数字啊 这里有个数字 数字呢是

05:49.380 --> 05:50.260
我们用个

05:50.980 --> 05:52.580
十半元数嘛啊 十半元数

05:52.580 --> 05:56.900
有个数字 那么数字呢 它是自己改变的数字啊 自身改变的数字

05:56.900 --> 06:00.500
所以说呢 它是一个自身的状态啊 是一个自身的状态

06:00.500 --> 06:03.060
ok 那咱们呢 这里写一个啊 自身的状态

06:03.620 --> 06:04.260
use state

06:05.300 --> 06:06.180
啊 再导入进来啊

06:07.460 --> 06:08.500
use state

06:09.060 --> 06:11.780
啊 包括能use effect啊 一起把它导入进来

06:12.180 --> 06:16.500
好 这里面呢 我们使用添加一个状态啊 use state

06:18.100 --> 06:20.980
啊 数字n嘛啊 摸正值为0

06:21.940 --> 06:25.460
好 然后呢 这个里边呢 我们span里边 我们就显示n

06:26.500 --> 06:28.420
啊 点击按钮的时候呢 n加1

06:30.820 --> 06:33.620
好 我们来说明这个道理啊 好 这里呢 输出

06:34.980 --> 06:37.140
啊 不是输出啊 set n

06:37.780 --> 06:38.580
啊 n加1

06:39.860 --> 06:41.380
好 写完了啊 咱们来看一下

06:41.940 --> 06:42.420
保存

06:44.500 --> 06:45.380
没有文字啊

06:46.340 --> 06:47.220
加加 加

06:48.900 --> 06:50.740
就这么一个东西啊 写出来了

06:51.380 --> 06:53.700
那么这里面呢 我们有这么一个要求

06:54.500 --> 06:55.300
什么要求呢

06:56.020 --> 07:00.660
就是每 我们页面的标题啊 就这个页面啊 就这个玩意儿

07:00.660 --> 07:04.740
看我鼠标的啊 就鼠标这里的页面标题呢

07:04.740 --> 07:08.260
应该始终保证跟这个n的值是一致的

07:09.300 --> 07:11.940
好 咱们来做这么一件事 跟这个n的值一致

07:12.020 --> 07:15.460
也就是说每一次这个组件渲染完之后

07:16.500 --> 07:20.100
这里显示的是多少 那么这个页面的标题是多少

07:20.660 --> 07:23.620
我们说不要改变页面标题 对吧 是吧 改变

07:24.260 --> 07:27.300
好 那么改变页面标题呢 是不是应该在这里做

07:27.300 --> 07:31.060
document.title 对不对啊 页面标题是什么呢

07:31.060 --> 07:33.860
页面标题来自于 来自于就是

07:35.460 --> 07:39.060
技术器啊 后面冒号嘛 再写上一个值 n

07:40.260 --> 07:41.300
好 我们这样子来写

07:42.900 --> 07:48.100
你看一下 目前的显示技术器为0 对吧 加加加加

07:48.100 --> 07:51.860
你看这里 是不是技术器更增加了 对吧 技术器增加了

07:51.860 --> 07:53.060
我们就要实现这么一个效果

07:53.940 --> 07:57.060
那你说现在不就实现了吗 但是呢 你要知道

07:57.060 --> 07:59.140
这个玩意儿是一个副作用操作

07:59.700 --> 08:03.140
副作用操作不能应该直接出现在函数组件里边

08:03.140 --> 08:06.340
实际上副作用操作不应该出现在组件里边

08:06.980 --> 08:09.060
组件应该尽量的保持纯净

08:10.020 --> 08:13.940
那么这里怎么办呢 这个副作用操作应该尽量的把它放到

08:15.380 --> 08:17.220
专门的做副作用操作里边

08:17.940 --> 08:21.620
我们就是用这个函数来完成副作用 看一下怎么来做

08:23.540 --> 08:24.340
以下代码

08:28.180 --> 08:33.280
以下代码属于副作用

08:33.280 --> 08:36.800
因为它是直接操作浏览器啊 操作动物啊 操作外部的东西

08:36.800 --> 08:38.560
跟这个组件本身无关的东西

08:39.360 --> 08:41.120
那么这些代码属于副作用

08:41.120 --> 08:43.360
那么副作用代码的应该放到这里边

08:43.360 --> 08:44.160
看一下怎么来放

08:48.720 --> 08:50.160
那么这里边呢 它让里

08:50.160 --> 08:53.280
它这个函数没有返回值啊 这个函数是没有返回值的

08:53.280 --> 08:55.040
你只需要传参数去完成了

08:55.040 --> 08:58.240
好 参数传啥呢 它传的是一个函数

08:59.120 --> 09:00.640
传的是一个函数本身

09:00.640 --> 09:03.120
这个函数来处理来处理副作用

09:03.120 --> 09:04.720
比方说我们这里传一个建筒函数

09:05.440 --> 09:07.840
这个函数里边去处理副作用

09:08.640 --> 09:11.040
而不要直接在函数组件里边处理

09:11.040 --> 09:13.440
而是在专门在这里进行处理副作用

09:13.440 --> 09:15.440
副作用是什么呢 是不是这句话 对吧

09:16.480 --> 09:17.440
来 就完事了

09:18.240 --> 09:19.680
这就是处理副作用

09:19.680 --> 09:21.360
你看一下吧 就完了 就完了

09:22.160 --> 09:24.640
点击 你看一下 这里是不是更新了

09:24.640 --> 09:27.200
对吧 更新了 点击 看没有 更新了

09:29.220 --> 09:31.380
那么大家会发现呢 这个更新呢

09:31.380 --> 09:33.940
好像有点慢 对吧 有点稍微有点延迟

09:33.940 --> 09:36.820
点一下 仔细观察 有点延迟

09:37.780 --> 09:40.580
仔细观察 是不是有点延迟

09:40.580 --> 09:42.260
那是这是为什么呢

09:42.260 --> 09:44.820
它涉及到函数 它的运行时间

09:44.820 --> 09:46.740
就是你给它传了一个函数进去

09:46.740 --> 09:50.980
那么这个函数它是在什么时间去运行的

09:50.980 --> 09:52.500
这里说一下

09:54.500 --> 09:56.740
该函数什么时间运行

09:56.740 --> 09:58.900
运行的时间点

10:00.340 --> 10:04.020
是在 干脆把这些东西全部放到细节里边吧

10:07.890 --> 10:12.530
副作用函数的运行时间点

10:14.130 --> 10:23.330
时间点 是在页面完成真实的UI渲染之后

10:25.090 --> 10:27.330
什么就在真实的UI渲染之后呢

10:27.330 --> 10:30.290
指的是我们的页面上不是发生了变化吗

10:30.290 --> 10:32.690
好 变化之后 因为我们重新渲染

10:32.690 --> 10:34.290
对吧 重新渲染

10:34.290 --> 10:36.610
那么它会导致页面上发生变化

10:37.090 --> 10:39.010
页面发生变化之后

10:39.010 --> 10:42.290
就是整个浏览器显把这个结果

10:42.290 --> 10:45.890
新的结果渲染出来了之后

10:47.090 --> 10:48.610
才会去运行这个函数

10:49.410 --> 10:50.690
所以它的时间点呢

10:50.690 --> 10:51.890
它是比较靠后的

10:51.890 --> 10:53.970
并且它是异步的

10:53.970 --> 10:58.210
因此它的执行是异步的

10:59.410 --> 11:03.330
不会主色浏览器

11:05.330 --> 11:06.610
并且不会主色浏览器

11:07.730 --> 11:08.530
我再说一次

11:08.530 --> 11:10.210
它的运行时间点这个很重要

11:10.770 --> 11:12.130
就是说它的执行时间点

11:12.130 --> 11:12.930
那是在什么时候呢

11:13.730 --> 11:16.770
一定是在页面渲染完了之后

11:16.770 --> 11:19.090
就真实的看到效果了之后

11:19.090 --> 11:21.010
我们用户已经看到了效果了

11:21.010 --> 11:22.130
不要说加了过后

11:22.130 --> 11:23.330
它变成了12

11:23.330 --> 11:24.770
已经看到这个12了

11:24.770 --> 11:26.290
然后它才去执行这个函数

11:27.090 --> 11:27.730
不要这个意思吧

11:28.770 --> 11:30.290
好 那么这个地方呢

11:30.290 --> 11:31.810
无论是第一次渲染

11:31.810 --> 11:32.450
它会执行

11:32.450 --> 11:33.330
你看一下刷新

11:33.970 --> 11:35.250
第一次渲染是不是会执行

11:35.250 --> 11:35.890
对吧

11:35.970 --> 11:37.170
第一次渲染也是

11:37.170 --> 11:38.210
把这个组件呢

11:38.210 --> 11:39.090
渲染到了页面

11:39.090 --> 11:40.370
形成真实的动物元素

11:40.370 --> 11:41.090
并且呢

11:41.090 --> 11:43.090
我们用户能够看到结果了

11:43.650 --> 11:45.090
把结果都看到了

11:45.090 --> 11:45.890
那么这个时候呢

11:45.890 --> 11:47.010
才会运行这个函数

11:47.010 --> 11:48.770
那么后续的更新也是一样

11:48.770 --> 11:49.490
页面上呢

11:49.490 --> 11:51.010
已经渲染出了新的结果

11:51.650 --> 11:52.530
并且呢

11:52.530 --> 11:53.970
我们已经看到这个结果了

11:53.970 --> 11:54.930
那么这个时候呢

11:54.930 --> 11:56.530
才会去执行这个函数

11:56.530 --> 11:57.010
因此呢

11:57.010 --> 11:58.450
这个函数的执行啊

11:58.450 --> 11:59.250
它是异步的

12:00.210 --> 12:01.090
是异步执行的

12:01.650 --> 12:03.890
那么这里边可以做各种负重用的操作

12:04.530 --> 12:06.530
因为现在我们用户已经能看到东西了

12:06.530 --> 12:08.370
它不会影响用户看到的东西

12:08.370 --> 12:10.290
比方说一些非常复杂的计算

12:10.290 --> 12:11.250
要处理一些负重用

12:11.250 --> 12:12.610
非常非常复杂的计算

12:12.610 --> 12:13.570
那么这些计算呢

12:14.850 --> 12:15.650
这些计算呢

12:16.210 --> 12:19.170
如果说你每一次用户都还没有看到结果

12:19.170 --> 12:20.290
还没有看到这个页面

12:20.290 --> 12:21.410
渲染出来

12:21.410 --> 12:23.250
那么你就在做这种复杂的计算

12:23.250 --> 12:25.010
经过了很长长的时间

12:25.010 --> 12:27.570
那么你会感觉到这个流量器卡死了

12:28.450 --> 12:30.130
因为它没把结果渲染出来

12:30.130 --> 12:31.650
那么它这样子来操作的话

12:31.650 --> 12:33.330
无论你这个负重用的函数

12:33.410 --> 12:34.530
要处理多少东西

12:34.530 --> 12:35.010
无所谓

12:35.010 --> 12:35.570
随便的搞

12:36.450 --> 12:38.610
因为我已经用户已经看到界面了

12:38.610 --> 12:40.130
所以说不会影响用户的

12:40.130 --> 12:42.130
对这个界面的流量器的浏览

12:42.130 --> 12:43.730
它这个种非常非常细的细节

12:43.730 --> 12:44.850
它都给你考虑到的

12:45.650 --> 12:47.250
那么这种方式呢

12:47.250 --> 12:48.050
跟我们

12:49.250 --> 12:49.970
跟我们的那个

12:50.930 --> 12:52.370
生命周期里边

12:52.370 --> 12:53.970
不是地的mount也是这样子吗

12:53.970 --> 12:54.450
对吧

12:54.450 --> 12:56.850
虚拟洞挂得到页面成为真射洞

12:56.850 --> 12:59.650
以及地的update挂得到页面

12:59.650 --> 13:00.530
形成真射洞

13:00.530 --> 13:01.490
内饰

13:01.490 --> 13:03.090
跟着生命周期含述内饰

13:03.170 --> 13:04.210
相当于是

13:04.210 --> 13:05.650
它地的mount运行一次

13:05.650 --> 13:07.170
地的update也运行一次

13:07.170 --> 13:08.210
相当于是这样子

13:08.210 --> 13:09.730
相当于是你在内组界里边

13:09.730 --> 13:11.570
注册了这么两个生命周期含述

13:11.570 --> 13:13.010
这两个生命周期含述里边

13:13.010 --> 13:14.530
都做了这一件事

13:14.530 --> 13:16.370
都要做这一件事

13:16.370 --> 13:17.490
不要这一只吧

13:17.490 --> 13:17.970
但是呢

13:17.970 --> 13:19.250
它跟这两个含述呢

13:20.290 --> 13:21.250
又有所区别

13:22.130 --> 13:22.690
这里说一下

13:23.810 --> 13:25.970
与内组建中

13:27.810 --> 13:29.090
这两个含述的区别

13:30.850 --> 13:31.250
和

13:32.210 --> 13:35.490
地的update的区别

13:35.490 --> 13:36.610
区别在哪呢

13:36.610 --> 13:37.410
区别在于

13:38.210 --> 13:39.490
这两个含述呢

13:41.970 --> 13:43.250
这两个含述呢

13:43.250 --> 13:45.650
是更改了

13:46.690 --> 13:48.930
更改了真射洞

13:49.810 --> 13:51.010
它把真射洞更改了

13:51.010 --> 13:51.330
对吧

13:51.330 --> 13:53.330
真射洞已经完成更改了

13:53.330 --> 13:53.890
但是

13:54.610 --> 13:58.530
用户还没有看到UI更新

13:59.410 --> 14:00.050
就是说一下说

14:00.050 --> 14:01.330
它更改了真射洞

14:01.330 --> 14:03.410
你们也可以从真射动物元素里面

14:03.410 --> 14:05.570
拿到一些关键的信息

14:05.570 --> 14:07.330
但是用户还没有看到更新

14:07.330 --> 14:08.930
因为我们知道浏览器呢

14:08.930 --> 14:10.370
它要更新我们的页面

14:11.010 --> 14:12.530
它是要重新选了的

14:12.530 --> 14:14.130
它叫做重绘

14:14.130 --> 14:14.690
重绘呢

14:14.690 --> 14:16.130
它是每隔一段时间重绘一次

14:16.130 --> 14:17.490
每隔一段时间重绘一次

14:18.130 --> 14:18.690
那么

14:18.690 --> 14:20.530
就是我更新了动物元素

14:20.530 --> 14:21.010
但是呢

14:21.010 --> 14:23.490
还没有等到浏览器重绘页面

14:23.490 --> 14:25.330
那么它运行的这两个含述

14:25.330 --> 14:26.850
所以运行这两个含述的时候呢

14:26.850 --> 14:28.210
实际上用户呢

14:28.210 --> 14:29.170
还没有看到

14:29.890 --> 14:31.570
还没有看到页面完成更新

14:32.450 --> 14:32.930
但是呢

14:32.930 --> 14:34.850
这个use effect不一样

14:35.810 --> 14:37.170
中的副作用含述

14:38.850 --> 14:41.570
它是更改了真射洞

14:43.490 --> 14:47.570
并且用户已经看到了UI更新

14:48.210 --> 14:49.970
已经看到了这个UI更新

14:49.970 --> 14:51.170
那么这个时候呢

14:51.170 --> 14:54.050
它才会运行这个use effect中的副作用含述

14:55.170 --> 14:55.650
所以说呢

14:55.650 --> 14:57.330
这个use effect的副作用含述呢

14:57.330 --> 14:58.850
它是异步的

14:59.010 --> 14:59.730
它是异步的

15:00.850 --> 15:03.090
因为它等到UI更新之后

15:03.090 --> 15:05.250
就是重绘了之后才会运行

15:05.250 --> 15:06.370
而这两个含述呢

15:06.370 --> 15:07.010
是同步的

15:07.730 --> 15:08.530
是同步的

15:08.530 --> 15:09.810
改动了真射洞之后

15:09.810 --> 15:11.090
马上就会运行这两个含述

15:12.210 --> 15:12.690
这是呢

15:12.690 --> 15:13.810
regard之前

15:13.810 --> 15:15.890
它的那种细节没有考虑完善的地方

15:15.890 --> 15:16.450
那么现在呢

15:16.450 --> 15:17.810
在use effect

15:17.810 --> 15:20.290
就 effect 里面已经修复了

15:20.290 --> 15:21.090
而 effect 里面

15:21.090 --> 15:22.450
就是它肯定是

15:22.450 --> 15:23.010
用起来呢

15:23.010 --> 15:24.130
肯定要比这两个好一些

15:24.130 --> 15:26.610
它不会组色UI的界面

15:27.570 --> 15:28.210
明白的意思吧

15:28.210 --> 15:29.890
是它的运行时间点

15:29.890 --> 15:31.010
它一会儿还有很多细节

15:31.010 --> 15:31.730
咱们一个个说

15:33.090 --> 15:33.330
好

15:33.330 --> 15:34.050
当然呢

15:34.050 --> 15:34.610
一个

15:35.410 --> 15:36.130
组件里边

15:36.130 --> 15:38.290
是不是可以用多个副作用操作

15:38.290 --> 15:38.530
对吧

15:38.530 --> 15:39.570
你可能有的时候呢

15:39.570 --> 15:40.690
要改变dom

15:40.690 --> 15:41.330
有的时候呢

15:41.330 --> 15:42.850
要作为阿加斯请求对吧

15:44.530 --> 15:46.690
每个含述组件中

15:48.210 --> 15:48.930
组件中

15:49.730 --> 15:54.210
可以多次使用use effect

15:54.850 --> 15:56.290
可以多次使用这个

15:56.290 --> 15:57.010
但是呢

15:57.010 --> 15:58.290
这个潜力条件

15:58.290 --> 16:00.610
但不要

16:00.610 --> 16:01.490
不要什么呢

16:01.490 --> 16:08.610
不要放入判断或循环等含述体重

16:08.610 --> 16:10.610
那就是代码扩总

16:10.610 --> 16:12.370
包括我们后边讲的

16:12.370 --> 16:14.850
几乎是所有的 hook

16:14.850 --> 16:16.370
他们都有一个要求

16:16.370 --> 16:17.170
大家注意一下

16:17.170 --> 16:18.530
后边我就不追溯了

16:18.530 --> 16:21.410
都不要放到判断或循环等代码扩总

16:21.410 --> 16:21.810
为什么呢

16:21.810 --> 16:22.770
它也是一样

16:22.770 --> 16:23.890
它会建一个表格

16:23.890 --> 16:25.490
对为这个组件节点

16:25.490 --> 16:26.290
建一个表格

16:26.290 --> 16:27.010
这个表格里边

16:27.010 --> 16:27.570
我们记录了

16:27.570 --> 16:29.570
有哪些副作用要进行操作

16:29.570 --> 16:30.690
那么

16:30.690 --> 16:32.210
它每一次use effects的时候

16:32.210 --> 16:35.010
它就会更新那个对应下标的

16:35.010 --> 16:36.050
那个副作用操作

16:37.090 --> 16:37.810
就这么个意思

16:37.810 --> 16:38.370
所以说呢

16:38.370 --> 16:39.970
你尽量的不要使用

16:41.090 --> 16:42.370
不要使用那个

16:42.370 --> 16:43.810
就是放到判断呀

16:43.810 --> 16:44.370
循环里边

16:45.330 --> 16:45.410
好

16:45.410 --> 16:45.730
就这个

16:46.530 --> 16:47.170
比方说吧

16:47.170 --> 16:47.730
嗯

16:47.730 --> 16:49.010
我想还有什么例子

16:49.650 --> 16:50.770
还有什么例子呢

16:53.090 --> 16:54.050
这样子嘛

16:54.050 --> 16:54.530
这样子

16:55.810 --> 16:57.410
咱们这里的

16:57.410 --> 16:59.330
我关心说想不到有什么例子的

17:01.010 --> 17:01.490
目前啊

17:01.490 --> 17:03.890
因为目前我们现在还没有做更多的事情

17:05.010 --> 17:06.370
我们就再写一个嘛

17:06.370 --> 17:07.010
再写一个

17:07.490 --> 17:08.370
use effects

17:08.370 --> 17:09.170
它可以写多个

17:11.170 --> 17:12.770
这里面比方说一个副作用操作

17:13.650 --> 17:15.650
其他的副作用

17:17.010 --> 17:17.410
操作

17:18.370 --> 17:18.850
到时候呢

17:18.850 --> 17:21.090
它会按照你注册的顺序

17:21.090 --> 17:22.690
就是这个函数注册的顺序

17:22.690 --> 17:23.250
一次执行

17:23.970 --> 17:24.290
好

17:25.170 --> 17:26.050
你看一下

17:26.050 --> 17:27.090
第一次运行

17:28.530 --> 17:29.890
是改变

17:29.890 --> 17:33.010
页面标题的副作用操作

17:33.890 --> 17:34.130
好

17:34.130 --> 17:34.610
保存啊

17:35.090 --> 17:35.570
你看呀

17:35.570 --> 17:36.770
是这样的运行的

17:36.770 --> 17:38.130
那么每一次更新的过后

17:38.130 --> 17:39.170
是不是要重运行啊

17:39.170 --> 17:39.650
对吧

17:39.650 --> 17:41.810
只要你重新运行的这个app

17:41.810 --> 17:43.730
只要你重新宣展的这个组件

17:43.730 --> 17:45.570
那么它就会一定会重新运行

17:45.570 --> 17:46.770
这个副作用

17:46.770 --> 17:48.050
每次都会运行的

17:48.050 --> 17:48.850
每次都会运行的

17:50.050 --> 17:50.290
好

17:50.290 --> 17:51.170
这是关于这一点

17:52.130 --> 17:52.930
好

17:52.930 --> 17:54.450
接下来我们再来看一个例子

17:55.730 --> 17:57.330
这个例子是这样子

17:57.330 --> 17:58.690
可能呢

17:58.690 --> 18:00.690
稍微的又那么一丢丢复杂

18:00.690 --> 18:02.370
一点点复杂

18:02.370 --> 18:03.970
我想说明这个问题

18:03.970 --> 18:05.810
比方说呢

18:05.810 --> 18:06.290
这里呢

18:06.290 --> 18:07.490
我把这个删掉啊

18:09.090 --> 18:09.810
假设呢

18:09.810 --> 18:11.650
咱们有这么一个组件

18:11.650 --> 18:13.170
是一个函数组件

18:13.170 --> 18:15.410
给它取个名字叫做movable

18:15.410 --> 18:17.410
block

18:18.850 --> 18:20.930
一个可以移动的一个块

18:21.650 --> 18:21.890
啊

18:22.850 --> 18:23.250
一个

18:24.450 --> 18:26.690
一个可移动的块

18:28.130 --> 18:29.250
这么个东西

18:29.250 --> 18:29.970
有这么一个组件

18:30.690 --> 18:31.010
好

18:31.010 --> 18:32.050
那么这个块呢

18:32.050 --> 18:32.770
它是这样子

18:34.940 --> 18:35.260
嗯

18:36.220 --> 18:37.180
这个组件

18:37.820 --> 18:38.220
一开

18:38.220 --> 18:39.420
它返回的是一个什么呢

18:39.420 --> 18:41.020
返回的就是一个div

18:41.020 --> 18:41.660
为了避免

18:42.220 --> 18:43.740
难得去写这个样式表了啊

18:43.740 --> 18:45.180
咱们直接把样式写到这

18:45.740 --> 18:46.700
这个div呢

18:46.700 --> 18:47.580
它有个宽度

18:47.580 --> 18:48.860
比方说100个像素

18:48.860 --> 18:50.300
高度呢100个像素

18:51.180 --> 18:51.900
啊

18:51.900 --> 18:52.300
然后呢

18:52.300 --> 18:52.940
定位呢

18:52.940 --> 18:54.460
是用固定定位

18:54.460 --> 18:55.260
fixed

18:55.260 --> 18:56.380
啊固定定位

18:56.380 --> 18:56.700
然后呢

18:56.700 --> 18:57.980
一个背景颜色啊

18:57.980 --> 18:58.700
白光的

18:58.700 --> 18:59.900
比方说f10嘛

19:00.700 --> 19:00.780
啊

19:00.780 --> 19:01.660
有这么一个div

19:03.500 --> 19:03.740
好的

19:03.740 --> 19:05.260
你需要给我传一些属性进来

19:06.460 --> 19:06.940
比方说

19:06.940 --> 19:07.580
我们约定

19:09.100 --> 19:10.140
属性里边呢

19:10.140 --> 19:11.180
有这么一些属性

19:11.980 --> 19:12.860
比方说一个是

19:14.140 --> 19:14.540
left

19:15.340 --> 19:16.860
表示要移动到的

19:17.900 --> 19:19.660
要移动到的目标

19:20.220 --> 19:20.620
点

19:21.100 --> 19:21.900
横坐标

19:22.700 --> 19:23.100
然后呢

19:23.100 --> 19:24.700
还得指是top

19:25.500 --> 19:28.060
要移动到的目标点

19:29.900 --> 19:30.540
重坐标

19:32.380 --> 19:33.020
比方说

19:33.020 --> 19:35.740
有这么两个属性要传给我

19:36.460 --> 19:36.700
好

19:36.700 --> 19:37.420
传给我过后

19:37.420 --> 19:38.460
我要干嘛呢

19:39.980 --> 19:40.780
该啊

19:40.780 --> 19:41.500
该主见

19:42.620 --> 19:43.260
该主见

19:44.300 --> 19:45.660
始终啊

19:45.660 --> 19:47.900
每次渲染完成后

19:49.740 --> 19:51.100
每次渲染完成后

19:52.460 --> 19:53.740
始终从

19:54.700 --> 19:55.340
始终

19:56.940 --> 19:57.900
始终

19:57.900 --> 19:58.380
从

19:58.940 --> 20:00.220
零零

20:00.220 --> 20:00.700
坐标

20:02.300 --> 20:03.660
在一秒钟内

20:04.300 --> 20:05.420
在一秒钟

20:07.180 --> 20:07.500
内

20:08.380 --> 20:09.260
移动到

20:10.700 --> 20:12.220
目标点坐标

20:13.020 --> 20:14.460
始终要做这么一件事

20:14.460 --> 20:15.980
从零零坐标

20:15.980 --> 20:17.180
在一秒钟之内

20:17.180 --> 20:18.620
移动到目标点坐标

20:19.420 --> 20:20.620
那怎么来做呢

20:20.620 --> 20:21.420
我们在这里呢

20:21.420 --> 20:22.620
可以用这种方式

20:22.620 --> 20:23.660
你每一次渲染

20:23.660 --> 20:24.780
不是渲染一个div吗

20:24.780 --> 20:25.340
你看一下啊

20:25.340 --> 20:27.100
咱们比方说moveable

20:29.020 --> 20:29.740
moveable block

20:30.380 --> 20:31.100
有这么一个主见

20:31.100 --> 20:31.820
咱们看一下啊

20:31.820 --> 20:32.300
网页上

20:33.180 --> 20:34.060
不就是个块吗

20:34.060 --> 20:34.460
对吧

20:34.460 --> 20:35.100
就是这么一块

20:35.660 --> 20:35.820
好

20:35.820 --> 20:36.700
那么现在呢

20:36.700 --> 20:38.460
我每一次渲染完成过后

20:38.460 --> 20:39.660
是不是要移动了

20:39.660 --> 20:39.820
好

20:39.820 --> 20:41.500
这个移动的方式有很多啊

20:41.500 --> 20:42.220
那么比方说

20:42.220 --> 20:43.020
我们认为

20:43.020 --> 20:43.820
移动这一块呢

20:43.820 --> 20:45.020
我这里打算这样做

20:45.020 --> 20:46.540
直接操作动物元素

20:46.540 --> 20:47.260
来进行移动

20:47.820 --> 20:48.940
就不用搞一些

20:48.940 --> 20:50.060
花里葡萄的东西了

20:50.060 --> 20:51.820
咱们直接操作的动物元素

20:51.820 --> 20:53.020
来完成这个移动

20:53.820 --> 20:54.860
好了怎么来做呢

20:54.860 --> 20:56.220
那这个操作动物元素

20:56.220 --> 20:56.940
是不是副作用

20:57.580 --> 20:58.620
是不是副作用

20:58.620 --> 20:59.020
对不对

20:59.020 --> 20:59.980
副作用嘛

20:59.980 --> 21:01.340
所以说我们在里起到哪呢

21:01.900 --> 21:02.460
起到这

21:02.460 --> 21:04.060
use effect副作用

21:05.820 --> 21:06.620
然后我们在这里

21:07.660 --> 21:08.780
渲染完成之后

21:08.780 --> 21:09.340
因为我们知道

21:09.340 --> 21:10.940
这个函数什么时候运行

21:10.940 --> 21:13.180
是每一次渲染完成之后

21:13.740 --> 21:14.700
把这个东西都

21:14.700 --> 21:16.460
在页面上看到了之后

21:16.540 --> 21:17.420
用户已经看到了

21:17.420 --> 21:18.700
页面上的效果之后了

21:18.700 --> 21:20.540
那么它才会执行这个函数

21:20.540 --> 21:22.220
所以渲染完成后

21:22.220 --> 21:23.660
无论是首次渲染

21:23.660 --> 21:25.020
还是后边的更新渲染

21:25.020 --> 21:26.380
只要你渲染完成之后

21:26.380 --> 21:27.340
就会运行这个函数

21:28.140 --> 21:30.060
好那么渲染完成之后

21:30.860 --> 21:31.900
我们做啥呢

21:31.900 --> 21:33.500
是不是直接操作这个动物元素

21:33.500 --> 21:34.540
OK那么我是不是要

21:34.540 --> 21:35.500
获取这个动物元素

21:36.060 --> 21:36.540
我们这里呢

21:36.540 --> 21:38.540
可以使用以前咱们学过的知识

21:38.540 --> 21:39.020
Rave

21:39.820 --> 21:41.580
这里呢我们给它用一个

21:43.020 --> 21:44.700
就是Rave等于什么呢

21:46.780 --> 21:48.060
我们这里写到外面

21:48.060 --> 21:48.620
写到外面

21:50.060 --> 21:51.500
Rave等于React

21:51.500 --> 21:52.220
Create

21:52.940 --> 21:53.580
Ref

21:54.300 --> 21:55.500
这样创建一个Rave

21:56.220 --> 21:57.180
好那么这里呢

21:57.180 --> 21:58.380
我们把这个Rave放进去

21:58.380 --> 21:59.020
放进去

22:00.060 --> 22:00.540
没问题吧

22:01.180 --> 22:02.460
把这个变量放进去

22:02.460 --> 22:03.100
是个对象吗

22:03.100 --> 22:03.660
还记得吗

22:03.660 --> 22:04.700
是不是一个对象

22:04.700 --> 22:05.820
好那么它这里呢

22:05.820 --> 22:08.220
给它复作到的这个元素上面的时候呢

22:08.220 --> 22:09.180
它会给这个对象的

22:09.180 --> 22:10.540
Corrent属性复制

22:10.540 --> 22:11.900
那么我们这里拿到DIV

22:13.340 --> 22:14.700
拿到DIV怎么拿到

22:14.780 --> 22:16.540
是不是拿到这个Rave值

22:16.540 --> 22:16.940
对不对

22:18.540 --> 22:19.820
Rave点Corrent对吧

22:19.820 --> 22:20.540
是不是可以拿到

22:20.540 --> 22:21.260
输出看一下

22:21.660 --> 22:23.420
是不是可以拿到这个DIV保存

22:25.340 --> 22:27.100
你看这个DIV是不是拿到了

22:27.100 --> 22:27.420
对不对

22:28.300 --> 22:29.500
拿到这个DIV之后呢

22:29.500 --> 22:31.020
我们是不是可以控制移动了

22:31.020 --> 22:32.620
你要在一秒钟之内

22:33.180 --> 22:34.620
移动到目标点坐标

22:35.100 --> 22:35.820
怎么移动呢

22:36.460 --> 22:37.260
是不是我们要算

22:38.220 --> 22:39.420
我们移动的次数

22:39.420 --> 22:40.540
这个事情呢应该

22:41.100 --> 22:42.700
应该你们也很熟悉了

22:42.700 --> 22:43.740
我们用介绍来控制

22:44.780 --> 22:45.740
我们这里呢

22:45.740 --> 22:46.300
比方说

22:47.900 --> 22:48.540
定义一个

22:50.140 --> 22:53.260
定义一个Timer或者是用Net

22:53.260 --> 22:53.900
定义一个Timer

22:54.620 --> 22:55.580
这是G17ID

22:56.700 --> 22:57.900
G17ID

22:59.020 --> 23:01.180
好那么渲染完成之后

23:01.180 --> 23:02.940
我们要给这个Timer复制

23:02.940 --> 23:03.340
对不对

23:04.220 --> 23:05.180
给这个Timer复制

23:05.980 --> 23:07.580
是不是set interval对吧

23:08.540 --> 23:09.500
咱们在这里写

23:09.500 --> 23:10.060
set interval

23:10.060 --> 23:11.100
这都是全是复作用

23:11.100 --> 23:11.500
看呗

23:11.900 --> 23:12.860
是一步的操作

23:13.420 --> 23:13.980
那么这里呢

23:14.060 --> 23:15.820
在多长时间内完成移动了

23:17.180 --> 23:18.380
在一秒钟之内

23:18.380 --> 23:20.380
那么每一次每隔16毫秒

23:20.380 --> 23:20.940
比方说吧

23:22.140 --> 23:22.780
咱们呢

23:22.780 --> 23:24.860
每隔16毫秒移动一次

23:25.820 --> 23:26.380
移动一次

23:26.860 --> 23:27.980
或者说每隔20毫秒

23:28.380 --> 23:29.340
或者说每隔10毫秒

23:29.820 --> 23:31.020
10毫秒移动一次

23:31.020 --> 23:31.900
那么是不是移动

23:31.900 --> 23:33.180
移动要移动100次

23:33.180 --> 23:34.540
咱们尽量写简单一点

23:35.020 --> 23:36.380
移动是不是要移动100次

23:37.340 --> 23:38.060
没问题吧

23:38.060 --> 23:39.260
是不是移动要移动100次

23:40.060 --> 23:40.380
OK

23:40.380 --> 23:42.060
那这里呢咱们就移动100次呗

23:42.620 --> 23:43.580
就移动100次呗

23:44.060 --> 23:44.700
好那么来

23:45.500 --> 23:46.700
怎么来移动100次呢

23:47.580 --> 23:48.860
我们这里判断一下啊

23:48.860 --> 23:49.660
写一个变量

23:49.660 --> 23:51.500
来保存当前移动的次数

23:53.260 --> 23:54.140
curve times

23:54.940 --> 23:55.260
0

23:56.620 --> 23:58.780
当前移动的次数

23:59.900 --> 24:01.580
一共要移动100次

24:01.580 --> 24:03.740
每一次移动移动的距离是多少呢

24:03.740 --> 24:04.620
是不是可以算出来

24:05.180 --> 24:06.540
每一次移动的距离

24:06.540 --> 24:07.260
距离是多少

24:07.260 --> 24:07.900
是不是总

24:08.700 --> 24:11.100
从0到left距离

24:11.100 --> 24:12.780
从0到top的距离

24:12.780 --> 24:13.100
对吧

24:13.820 --> 24:14.140
是吧

24:14.700 --> 24:15.740
x上的距离

24:15.740 --> 24:16.300
等于啥呢

24:16.860 --> 24:18.300
left props

24:19.020 --> 24:21.100
left props

24:21.100 --> 24:21.980
left

24:21.980 --> 24:22.540
然后呢

24:22.540 --> 24:23.020
除亿

24:23.820 --> 24:24.700
除亿啥呢

24:24.700 --> 24:27.900
除亿一个次数100次

24:27.900 --> 24:31.420
就是每次移动的x方向

24:32.060 --> 24:33.020
横座标上

24:34.140 --> 24:35.660
每次移动的距离

24:36.540 --> 24:37.420
还有一个呢就是

24:37.980 --> 24:38.780
this y

24:39.340 --> 24:40.380
就是每一次

24:40.380 --> 24:42.380
因为我这里讲的就比较简洁了

24:42.460 --> 24:43.180
因为这一块呢

24:44.220 --> 24:46.620
都是很基础的一些逻辑知识

24:46.620 --> 24:47.740
都是众座标上

24:50.140 --> 24:51.820
每次移动的距离

24:52.700 --> 24:53.980
把距离算出来

24:53.980 --> 24:55.020
那么每一次移动

24:55.020 --> 24:55.900
我们干嘛呢

24:55.900 --> 24:57.260
是不是就设置这个div

24:58.220 --> 24:59.740
当前的left

24:59.740 --> 25:01.580
和当前的top值

25:01.580 --> 25:03.980
然后给它加上这么一段距离

25:03.980 --> 25:04.300
对吧

25:04.300 --> 25:04.700
就完了

25:05.500 --> 25:06.140
就完了

25:06.140 --> 25:06.700
就就完了

25:07.420 --> 25:08.060
或者说

25:08.940 --> 25:09.500
或者说

25:10.620 --> 25:11.740
你移动多少次

25:11.740 --> 25:12.540
移动了一次

25:12.620 --> 25:13.660
我们乘亿一个是

25:13.660 --> 25:15.100
是不是一次过后的距离

25:15.100 --> 25:16.140
增加了距离

25:16.140 --> 25:17.900
两次乘亿一个是

25:17.900 --> 25:19.260
是不是两次增加了距离

25:19.260 --> 25:20.860
那么我们这里来设置吧

25:21.980 --> 25:23.260
left值等于多少

25:23.260 --> 25:24.140
新的left值

25:25.100 --> 25:26.780
就这个div新的left值

25:26.780 --> 25:28.620
是不是等于移动的次数

25:29.740 --> 25:30.860
移动了多少次

25:30.860 --> 25:32.540
乘亿每次移动的距离

25:33.100 --> 25:33.420
对吧

25:34.060 --> 25:35.100
就新的left值

25:35.100 --> 25:36.940
那么新的top值呢等于

25:37.980 --> 25:39.100
当前移动的次数

25:39.660 --> 25:40.540
每次移动的

25:40.780 --> 25:42.860
就是次数乘亿什么第十 y

25:42.860 --> 25:43.260
对不对

25:43.260 --> 25:43.980
前面呢我们在

25:43.980 --> 25:44.860
coutimes加加

25:45.420 --> 25:45.740
对吧

25:45.740 --> 25:46.460
次数加亿

25:47.740 --> 25:48.700
移动次数

25:49.820 --> 25:50.220
加亿

25:50.780 --> 25:51.340
每一次呢

25:51.340 --> 25:52.220
就是移动次数

25:52.220 --> 25:53.420
乘亿每次移动的距离

25:53.420 --> 25:54.300
是不是总距离

25:54.300 --> 25:54.700
对吧

25:54.700 --> 25:55.180
总距离

25:55.180 --> 25:56.380
横桌标放的总距离

25:56.380 --> 25:57.340
众桌标放的总距离

25:57.340 --> 25:58.140
我们学习简单一点

25:59.180 --> 25:59.980
好那么这两个

25:59.980 --> 26:01.260
两个新的值算出来了

26:01.260 --> 26:02.540
我们直接给这个div

26:02.540 --> 26:02.940
style

26:04.220 --> 26:04.860
style

26:04.860 --> 26:05.900
点left

26:05.900 --> 26:07.020
等于new left

26:07.740 --> 26:08.540
拼接上

26:08.540 --> 26:09.260
px

26:09.260 --> 26:09.900
对吧

26:10.220 --> 26:11.340
divstyle

26:11.340 --> 26:12.220
直接操作多么远处

26:12.220 --> 26:13.340
这些都属于副作用

26:14.300 --> 26:15.260
top值

26:15.260 --> 26:15.820
拼接上

26:15.820 --> 26:16.220
px

26:17.820 --> 26:18.220
你看一下

26:18.220 --> 26:18.780
是不完了

26:18.780 --> 26:19.100
最后呢

26:19.100 --> 26:20.060
我们判断一下

26:20.060 --> 26:21.980
如果coutimes等于到100

26:21.980 --> 26:22.700
是不是100次

26:22.700 --> 26:23.260
到了100

26:23.260 --> 26:24.220
移动到100次

26:24.220 --> 26:24.940
100次过后呢

26:24.940 --> 26:25.660
是不是要停止

26:26.300 --> 26:26.620
对吧

26:26.620 --> 26:27.740
是不是要停止

26:27.740 --> 26:29.020
好怎么来停止

26:29.020 --> 26:29.740
是不是clear

26:30.940 --> 26:31.340
interval

26:31.980 --> 26:32.620
timer

26:32.620 --> 26:32.940
对吧

26:32.940 --> 26:33.500
把停止

26:34.620 --> 26:35.420
好保存

26:35.420 --> 26:36.060
咱们来看一下

26:38.480 --> 26:38.800
嗯

26:40.000 --> 26:40.640
为啥

26:40.640 --> 26:42.240
为啥没移动了

26:42.240 --> 26:42.640
等一下

26:42.640 --> 26:43.040
我看一下

26:43.680 --> 26:44.960
它为什么没有移动

26:45.680 --> 26:46.160
啊

26:48.160 --> 26:48.960
我们这里输出

26:48.960 --> 26:49.440
输出

26:51.620 --> 26:52.260
看一下输出

26:52.260 --> 26:52.980
有没有输出结果

26:55.300 --> 26:56.500
倒是输出了结果

26:56.500 --> 26:56.820
对吧

26:57.460 --> 26:59.220
倒是输出了结果

26:59.220 --> 26:59.780
我们在这里

26:59.780 --> 27:00.420
写到下面吧

27:04.930 --> 27:05.250
等一下

27:05.250 --> 27:06.770
这里应该输出100也才对啊

27:06.770 --> 27:08.210
因为只有到了100之后呢

27:08.210 --> 27:09.250
才会停止

27:09.250 --> 27:10.210
我看一下

27:10.210 --> 27:11.330
再刷新看一下

27:11.330 --> 27:11.810
怎么回事

27:13.330 --> 27:14.130
呃

27:14.130 --> 27:14.690
前边

27:15.490 --> 27:16.770
前边还有两次

27:16.770 --> 27:17.090
啊

27:17.090 --> 27:18.290
前边还有两次输出

27:18.930 --> 27:19.970
呃

27:19.970 --> 27:20.450
100

27:21.090 --> 27:21.730
清除

27:22.290 --> 27:23.250
清除计时器

27:25.250 --> 27:26.210
它没有移动

27:27.250 --> 27:27.650
我看一下

27:27.650 --> 27:28.610
到底是什么情况

27:28.610 --> 27:29.490
没有移动

27:29.490 --> 27:30.690
那么我们找找一找啊

27:30.690 --> 27:32.450
这个这个输出出来是多少

27:32.450 --> 27:33.010
new left

27:34.130 --> 27:34.930
啊new top

27:35.810 --> 27:36.930
看一下输出出来是多少

27:40.620 --> 27:41.500
NAN

27:41.500 --> 27:43.500
也就是这里输出出来是NAN

27:43.500 --> 27:44.940
那么我们再输出这个

27:45.020 --> 27:46.140
curtimes

27:46.140 --> 27:49.420
看一下输出出来是多少

27:49.420 --> 27:50.140
这个是出

27:50.140 --> 27:51.020
这个是正确的

27:51.020 --> 27:52.300
这个是正确的

27:52.300 --> 27:52.860
呃

27:52.860 --> 27:53.660
dx

27:53.660 --> 27:55.180
那么这个东西可能算出来是NAN

27:56.540 --> 27:56.860
哦

27:56.860 --> 27:57.500
这是NAN

27:57.500 --> 27:58.220
我明白了

27:58.220 --> 27:59.900
这里面我没给它传递属性对吧

27:59.900 --> 28:01.820
比方说给它传递移动到100

28:02.860 --> 28:04.300
top值100

28:04.300 --> 28:05.420
啊100x100

28:06.060 --> 28:07.260
移动到这个位置

28:07.260 --> 28:07.580
OK

28:07.580 --> 28:09.100
那么现在应该搞定了啊

28:09.100 --> 28:09.500
保存

28:11.500 --> 28:12.620
你看一下是不是移动了

28:12.620 --> 28:13.020
对吧

28:13.020 --> 28:15.740
它根据它的属性值来进行移动

28:15.740 --> 28:17.100
渲染完成过后了

28:17.100 --> 28:19.980
我们就按照属性值的要求来完成这个移动

28:20.700 --> 28:21.180
没问题吧

28:22.220 --> 28:23.180
好再看一下这个代码啊

28:23.180 --> 28:24.540
把这个代码先引理解清楚

28:25.420 --> 28:26.620
我们这些东西呢

28:26.620 --> 28:28.300
由于我们直接操作动物对象

28:29.260 --> 28:30.540
并且呢有计时器

28:30.540 --> 28:31.660
这些都属于副作用

28:32.540 --> 28:33.100
因此呢

28:33.100 --> 28:34.220
我们这移动的时候呢

28:35.260 --> 28:35.660
需要

28:35.660 --> 28:37.340
等它渲染完成过后

28:37.340 --> 28:38.700
我们来完成这个移动

28:39.980 --> 28:40.540
没问题吧

28:41.580 --> 28:41.820
好

28:41.820 --> 28:42.700
那么接下来了

28:42.700 --> 28:42.860
啊

28:42.860 --> 28:44.540
我这里直接把先把那个Left

28:44.700 --> 28:45.740
先给它默认识啊

28:45.740 --> 28:46.940
一开始写成零和零

28:46.940 --> 28:48.940
因为我们这个组件的要求是

28:48.940 --> 28:49.980
从零和零

28:49.980 --> 28:51.260
始终从零和零坐标

28:51.260 --> 28:53.100
在一秒钟之内引动到目标点的坐标

28:53.740 --> 28:53.980
好

28:53.980 --> 28:54.380
保存啊

28:55.180 --> 28:55.340
好

28:55.340 --> 28:56.140
你看一下

28:56.140 --> 28:56.540
对吧

28:56.540 --> 28:57.020
没问题吧

28:57.660 --> 28:57.820
好

28:57.820 --> 28:58.540
那么到时候呢

28:58.540 --> 28:59.980
我们这里改改数据啊

28:59.980 --> 29:01.100
比方说500x500

29:01.820 --> 29:02.140
保存

29:03.980 --> 29:04.220
啊

29:04.220 --> 29:05.180
是不是已经到这来了

29:05.180 --> 29:05.260
啊

29:05.260 --> 29:05.500
再来

29:06.060 --> 29:06.940
500x500

29:06.940 --> 29:07.900
是不是已经过来了

29:09.020 --> 29:09.340
好

29:09.340 --> 29:10.300
那么接下来呢

29:10.300 --> 29:11.420
咱们再完成这么一个东西

29:11.980 --> 29:13.180
在APP里边呢

29:13.180 --> 29:14.380
我们有这么一个东西

29:14.860 --> 29:16.380
有这么一个文本框

29:18.140 --> 29:19.180
这是X坐标

29:20.540 --> 29:21.420
给它写个Number吧

29:22.060 --> 29:22.380
Number

29:23.260 --> 29:23.900
这里呢

29:23.900 --> 29:25.020
还有一个Y坐标

29:27.840 --> 29:28.400
Y坐标

29:29.040 --> 29:29.520
Input

29:30.000 --> 29:30.320
Number

29:32.800 --> 29:33.840
这是X坐标

29:33.840 --> 29:34.800
这是Y坐标

29:35.920 --> 29:36.320
然后呢

29:36.320 --> 29:37.360
这里边有个状态

29:38.000 --> 29:38.800
UseState

29:39.520 --> 29:40.560
有个状态

29:40.560 --> 29:41.680
一个就是Point

29:42.160 --> 29:42.480
Point

29:43.360 --> 29:44.000
默认识呢

29:44.000 --> 29:44.960
是X为0

29:46.400 --> 29:47.120
Y值呢

29:47.120 --> 29:47.600
为0

29:48.640 --> 29:49.440
或者说

29:49.440 --> 29:49.760
对吧

29:49.760 --> 29:50.400
就这样吧

29:50.400 --> 29:50.800
就这样

29:50.800 --> 29:51.280
就这样

29:51.280 --> 29:51.440
好

29:51.440 --> 29:52.560
那么Left的值

29:52.560 --> 29:53.280
它一会呢

29:53.280 --> 29:55.120
要运行到哪呢

29:55.120 --> 29:57.040
要运行到这个X坐标

29:57.920 --> 29:59.280
要运行到这个X坐标

30:00.320 --> 30:00.720
没问题吧

30:01.280 --> 30:02.000
要运行到这

30:03.280 --> 30:03.680
好

30:05.600 --> 30:06.400
我想一想啊

30:06.880 --> 30:07.440
就这样吧

30:07.440 --> 30:08.160
就这样啊

30:08.160 --> 30:08.800
运行到这

30:10.720 --> 30:10.960
好

30:10.960 --> 30:11.520
那么这里呢

30:11.520 --> 30:12.480
应该写啥呢

30:12.480 --> 30:15.040
写上Point点X

30:16.000 --> 30:16.400
这里呢

30:16.400 --> 30:18.400
应该写上Point点Y

30:18.400 --> 30:19.760
当然你可以把它分开

30:19.760 --> 30:20.800
分开成两个状态

30:20.800 --> 30:21.200
也行

30:21.840 --> 30:22.080
好

30:22.080 --> 30:24.000
那么我们把它变成一个受控组件

30:24.000 --> 30:25.120
它的Y6值呢

30:25.120 --> 30:26.160
应该来自于什么呢

30:26.160 --> 30:27.680
来自于Point点X

30:28.560 --> 30:29.040
对吧

30:29.040 --> 30:29.280
好

30:29.280 --> 30:30.400
那么这里的Y6值呢

30:31.120 --> 30:34.000
应该来自于Point点Y

30:35.360 --> 30:35.680
好

30:35.680 --> 30:36.800
接下来Unchanged

30:38.480 --> 30:39.600
Unchanged

30:39.600 --> 30:40.880
当改变的时候

30:41.520 --> 30:42.640
改变的时候呢

30:42.640 --> 30:44.480
我们要重新设置X值

30:44.560 --> 30:45.520
然后SetPoint

30:47.120 --> 30:48.400
把之前的Point展开

30:49.040 --> 30:49.280
好

30:49.280 --> 30:49.680
然后呢

30:50.560 --> 30:52.080
它的X的值呢

30:52.080 --> 30:52.960
变成了什么呢

30:52.960 --> 30:55.440
变成了EarTarget点Value

30:56.080 --> 30:56.320
对吧

30:56.320 --> 30:57.680
这是新的X值

30:57.680 --> 30:58.480
咱们用Pose

30:59.520 --> 31:00.320
PoseInt

31:00.880 --> 31:01.760
把它变成整数

31:03.120 --> 31:03.360
好

31:03.360 --> 31:04.720
这是新的X值

31:04.720 --> 31:05.600
那么同样的道理

31:05.600 --> 31:06.880
我们是不是可以设置Y坐标

31:07.440 --> 31:07.680
对吧

31:07.680 --> 31:08.880
把它变成受控组件

31:09.440 --> 31:09.520
好

31:09.520 --> 31:10.240
那么这里呢

31:10.240 --> 31:10.560
Y

31:11.680 --> 31:11.920
好

31:11.920 --> 31:13.520
你看一下这个逻辑啊

31:13.520 --> 31:14.400
你看一下这个逻辑

31:14.880 --> 31:15.520
那么这样子呢

31:15.520 --> 31:17.600
我们改变了这两个闻闷框的值之后

31:18.400 --> 31:19.760
改变它的值之后

31:19.760 --> 31:20.800
是不是要重新移动

31:21.360 --> 31:21.840
对吧

31:21.840 --> 31:23.440
它要导致重新渲染嘛

31:23.440 --> 31:25.680
Unchanged的时候重新调用了SetPoint

31:25.680 --> 31:26.800
是不是要重新渲染

31:26.800 --> 31:27.680
重新渲染是不是

31:28.240 --> 31:29.200
它的属性变了

31:29.200 --> 31:30.880
属性变了是不是要重新运行这个

31:30.880 --> 31:32.080
重新渲染这个组件

31:32.080 --> 31:34.640
重新渲染这个组件是不是要重新从零

31:34.640 --> 31:36.080
零零坐标开始

31:36.080 --> 31:37.440
重新移动到新的位置

31:38.080 --> 31:38.560
没问题吧

31:39.280 --> 31:39.520
好

31:39.520 --> 31:40.320
保存看一下啊

31:42.160 --> 31:43.040
它把折住了

31:43.760 --> 31:44.480
它把折住了

31:46.400 --> 31:47.200
那这样吧

31:47.200 --> 31:47.600
这样吧

31:48.240 --> 31:49.280
我这个DIV啊

31:50.800 --> 31:51.360
写个style

31:52.160 --> 31:52.880
看不见了

31:52.880 --> 31:53.360
把它折住了

31:54.080 --> 31:55.520
或者说我们来这里写个style

31:58.080 --> 31:59.360
我就在这写吧

31:59.360 --> 31:59.920
就在这写

32:03.360 --> 32:03.760
style

32:05.360 --> 32:05.840
Pending

32:07.120 --> 32:07.440
Top

32:08.720 --> 32:09.120
200

32:10.480 --> 32:10.880
保存

32:11.680 --> 32:12.320
好看一下啊

32:12.320 --> 32:12.640
在这

32:13.120 --> 32:13.600
在那

32:14.640 --> 32:15.440
我们的这在这

32:15.440 --> 32:16.480
好比方说

32:16.480 --> 32:17.120
我们这里改

32:18.160 --> 32:19.280
改动成啥呢

32:19.280 --> 32:20.960
改动成100

32:23.180 --> 32:23.580
1000

32:24.780 --> 32:26.220
它为什么会变成这个样子

32:26.220 --> 32:27.020
看一下

32:27.020 --> 32:28.300
我还让它改动成50

32:29.340 --> 32:30.300
它为什么变成这个样子

32:30.300 --> 32:31.180
怎么到处来跑

32:31.180 --> 32:31.740
跑着闪

32:31.740 --> 32:32.780
怎么到处来闪

32:32.780 --> 32:33.180
闪动

32:34.700 --> 32:35.820
怎么回事呢

32:35.820 --> 32:37.420
它到底是怎么回事呢

32:37.420 --> 32:39.260
因为我们现在呢

32:39.260 --> 32:40.540
会导致一个结果

32:40.540 --> 32:42.620
就是会启动多个计时期

32:43.580 --> 32:44.380
你看一下

32:44.460 --> 32:46.220
每一次渲染完成之后

32:46.220 --> 32:47.660
是不是启动了很多个计时期了

32:48.620 --> 32:49.260
对吧

32:49.260 --> 32:50.700
是不是启动了很多的计时期

32:51.580 --> 32:52.060
没问题吧

32:52.620 --> 32:54.220
所以每一次渲染完成之后

32:54.220 --> 32:56.380
它都会启动很多的计时期

32:56.940 --> 32:58.140
那么也就是说

32:58.140 --> 33:00.140
每一次我要重新移动的时候呢

33:00.140 --> 33:01.580
我是不是要把计时器清空

33:02.380 --> 33:02.700
对不对

33:02.700 --> 33:04.300
是不是要在每一次移动之前

33:04.300 --> 33:05.660
要把计时器清空

33:05.660 --> 33:05.980
ok

33:05.980 --> 33:07.500
我们在这里写上一个interval

33:08.060 --> 33:08.540
time

33:09.580 --> 33:12.140
清空之前的计时期

33:13.420 --> 33:13.820
保存

33:14.380 --> 33:15.100
你看一下啊

33:15.100 --> 33:15.900
现在再看一下

33:15.900 --> 33:16.220
100

33:17.020 --> 33:17.340
100

33:18.060 --> 33:19.100
所以现在正确了

33:19.100 --> 33:19.740
对吧

33:19.740 --> 33:19.980
y

33:20.860 --> 33:21.180
100

33:21.980 --> 33:22.300
对吧

33:22.300 --> 33:22.940
我们这里一改

33:22.940 --> 33:23.900
是不是要重新移动

33:23.900 --> 33:24.220
对吧

33:24.220 --> 33:25.180
重新宣展这个组件

33:25.180 --> 33:26.380
这个组件始终保证

33:26.380 --> 33:27.500
在渲染之后

33:27.500 --> 33:28.700
是不是运行这个函数

33:28.700 --> 33:29.420
这个函数呢

33:29.420 --> 33:30.780
我们刚才没有少出了一件事

33:30.780 --> 33:32.620
就是清空之前的计时期

33:32.620 --> 33:33.660
那么之前的计时期

33:33.660 --> 33:34.620
如果没有清空的话

33:34.620 --> 33:36.620
是不是叠加了很多计时期进来了

33:36.620 --> 33:36.940
对吧

33:36.940 --> 33:38.380
每次都新创建个计时期

33:38.380 --> 33:39.420
那么之前的计时期

33:39.420 --> 33:40.780
仍然在保留

33:40.780 --> 33:41.500
所以说

33:41.500 --> 33:42.620
那么就导致了这个问题

33:43.340 --> 33:43.740
没问题吧

33:44.700 --> 33:45.580
能看懂吧

33:45.580 --> 33:47.660
好比方说这里要运动到1000

33:47.660 --> 33:48.220
你看一下

33:48.220 --> 33:49.100
是不是这样子

33:49.100 --> 33:50.380
这里运动到300

33:50.380 --> 33:51.260
你感一下

33:51.260 --> 33:53.100
就要变成这样子

33:53.100 --> 33:54.620
好比方说咱们有这么个例子

33:55.900 --> 33:58.620
但是现在真的是解决这个问题吗

33:58.620 --> 33:59.820
真的解决这个问题吗

33:59.820 --> 34:02.140
其实还有个很小的细节没有解决

34:02.940 --> 34:04.620
什么细节没有解决呢

34:04.620 --> 34:05.740
为了方便呢

34:05.740 --> 34:06.940
我们说明这个问题

34:07.740 --> 34:08.780
我们这里呢

34:08.780 --> 34:10.220
不是一秒钟

34:10.220 --> 34:11.180
不是一秒钟

34:11.740 --> 34:13.900
而是10秒钟之内移动

34:14.620 --> 34:16.620
在10秒钟之内完成移动

34:17.660 --> 34:17.900
好

34:17.900 --> 34:19.660
每10毫秒运行一次

34:19.660 --> 34:20.060
对吧

34:20.060 --> 34:21.500
那么我们这里稍微做改一下

34:21.500 --> 34:22.700
稍微改一下

34:22.700 --> 34:23.420
10秒钟

34:23.420 --> 34:24.620
因为边缘看得清楚嘛

34:25.100 --> 34:25.260
好

34:25.260 --> 34:27.340
那么现在每10毫秒运行一次

34:27.340 --> 34:28.860
是不是要运行1000次

34:28.860 --> 34:29.100
对吧

34:29.100 --> 34:30.620
我们这里处于1000

34:30.620 --> 34:32.060
那么这里先到1000

34:32.060 --> 34:33.580
10秒钟之内完成移动

34:33.580 --> 34:33.900
看一下

34:36.100 --> 34:36.420
100

34:37.300 --> 34:37.940
10秒钟之内

34:39.700 --> 34:40.340
你看一下

34:40.340 --> 34:41.860
10秒钟之内完成这个移动

34:42.500 --> 34:43.540
它现在就跑不见了

34:44.500 --> 34:44.820
好

34:44.820 --> 34:46.020
接下来我们来看一下

34:46.020 --> 34:47.380
它会有一个什么样的问题

34:48.180 --> 34:50.500
为了方便我们来查看这个问题呢

34:50.500 --> 34:51.700
我把这个Timer呢

34:51.700 --> 34:52.420
设置到哪呢

34:52.420 --> 34:53.620
设置到Window对象里面

34:55.140 --> 34:55.940
Window对象里面

34:56.900 --> 34:57.380
这样子呢

34:57.380 --> 34:59.620
我们边缘我们看得清楚

35:00.900 --> 35:02.340
Window点Timer

35:02.340 --> 35:03.700
清空之前的计时器

35:03.700 --> 35:06.340
然后再把这个计时器设为NOW

35:07.220 --> 35:08.180
清空之位设为NOW

35:08.180 --> 35:09.780
主要是为了方便我们查看

35:09.780 --> 35:10.740
查看那个变量的值

35:10.740 --> 35:12.020
到底是不是NOW

35:12.100 --> 35:14.260
那么这里的Window点Timer重新设置

35:15.220 --> 35:15.460
好

35:15.460 --> 35:16.500
会有什么样的问题

35:16.500 --> 35:16.820
看着

35:18.100 --> 35:19.860
如果说我这个App里面

35:19.860 --> 35:20.980
只这样子写的话

35:20.980 --> 35:22.340
倒不会有什么问题

35:22.340 --> 35:22.820
但是呢

35:22.820 --> 35:24.340
如果App里面后面加个NOW

35:24.980 --> 35:25.460
表示

35:28.480 --> 35:30.720
NOW表示显示隐藏

35:31.760 --> 35:32.560
显示隐藏

35:33.440 --> 35:34.160
那么这一部分

35:34.720 --> 35:35.920
我们放到一个P元数里面

35:36.800 --> 35:39.040
把这一部分放到P元数里面

35:39.040 --> 35:39.920
你说这个P元数呢

35:39.920 --> 35:41.760
它有可能显示有可能隐藏的

35:41.760 --> 35:42.400
对吧

35:42.480 --> 35:44.080
它是有可能显示有可能隐藏的

35:44.080 --> 35:45.280
这个玩意儿也在P元数

35:46.320 --> 35:47.280
这个用个DIV吧

35:49.040 --> 35:50.880
这个玩意儿也在这个DIV里面

35:53.200 --> 35:53.760
也在这里面

35:54.720 --> 35:54.960
好

35:54.960 --> 35:56.640
那么接下来我们来看一下

35:56.640 --> 35:57.680
这个DIV呢

35:57.680 --> 35:58.880
它有可能出现

35:58.880 --> 36:00.240
也有可能不出现

36:00.240 --> 36:01.600
所以说我们这里还需要一个状态

36:02.160 --> 36:03.200
叫做set state

36:05.200 --> 36:05.520
要不

36:06.400 --> 36:06.960
U state

36:08.560 --> 36:09.120
什么状态呢

36:09.120 --> 36:09.760
就是Visible

36:10.720 --> 36:12.480
适逢显示

36:12.480 --> 36:13.280
默认是True

36:14.000 --> 36:14.160
好

36:14.160 --> 36:14.880
我们这一部分呢

36:14.880 --> 36:15.280
这样子写

36:16.160 --> 36:17.440
这是一种常见写法

36:17.440 --> 36:19.280
Visible如果为True的话

36:19.280 --> 36:20.400
那么我们显示

36:20.960 --> 36:21.680
这么一个组件

36:22.720 --> 36:23.120
DIV

36:23.840 --> 36:25.040
就把这个放进来

36:25.040 --> 36:26.880
如果Visible为True就显示这个

36:26.880 --> 36:28.400
如果Visible为Force的话

36:28.400 --> 36:29.120
那么是不是

36:29.120 --> 36:29.920
它就不会运行了

36:30.320 --> 36:31.200
就不会运行后面了

36:31.680 --> 36:31.920
好

36:31.920 --> 36:32.720
那么这里呢

36:32.720 --> 36:34.080
我们就可以通过这种模式

36:34.080 --> 36:34.960
来显示这个

36:34.960 --> 36:36.320
只有Visible为True的时候

36:36.320 --> 36:37.280
才会显示这个东西

36:38.400 --> 36:38.960
好

36:39.120 --> 36:40.640
那么这个按钮点击过后

36:41.840 --> 36:42.400
onclick

36:43.200 --> 36:44.080
点击过后呢

36:44.080 --> 36:44.560
干嘛呢

36:45.280 --> 36:46.400
setVisible

36:46.400 --> 36:47.280
把它设置为

36:47.280 --> 36:48.400
跟之前相反的情况

36:49.680 --> 36:49.920
好

36:49.920 --> 36:50.720
咱们来看一下

36:50.720 --> 36:52.000
它又会有一个什么样的问

36:52.000 --> 36:52.320
哎

36:53.360 --> 36:54.480
Timer is not defined

36:56.720 --> 36:57.760
我看一下啊

36:57.760 --> 36:58.000
哦

36:58.000 --> 36:58.480
这里

36:58.480 --> 36:58.720
啊

36:58.720 --> 36:59.040
这里

37:00.400 --> 37:02.080
清除window.timer

37:02.080 --> 37:02.400
啊

37:02.400 --> 37:03.120
这里呢

37:03.120 --> 37:05.840
还要设置window.timer

37:05.840 --> 37:06.960
等于now

37:06.960 --> 37:08.720
当然也可以写个函数嘛

37:08.880 --> 37:10.480
比方说我们专门写个函数

37:11.520 --> 37:13.280
就是stop

37:13.280 --> 37:14.080
停止

37:14.080 --> 37:15.040
停止函数

37:15.040 --> 37:15.760
停止函数的话

37:15.760 --> 37:17.280
我们把这两句话扔进来

37:18.240 --> 37:19.360
当然一起到这也行

37:19.920 --> 37:20.480
扔进来

37:21.040 --> 37:21.600
那么这里呢

37:21.600 --> 37:22.080
就是stop

37:24.180 --> 37:24.340
好

37:24.340 --> 37:24.740
这里呢

37:24.740 --> 37:25.540
也是stop

37:27.650 --> 37:28.930
看一下会有什么样的问题啊

37:30.690 --> 37:31.010
好

37:31.010 --> 37:31.410
保存

37:31.410 --> 37:32.050
咱们来看一下

37:36.940 --> 37:37.100
好

37:37.100 --> 37:37.660
这里边呢

37:37.660 --> 37:39.740
我们让它在10秒钟之内呢

37:39.740 --> 37:40.780
移动到100

37:41.660 --> 37:42.460
乘以100

37:43.100 --> 37:43.420
好

37:44.380 --> 37:45.340
那么它移动的过程中

37:45.340 --> 37:46.620
我们突然点击到隐藏

37:47.180 --> 37:48.060
点击到隐藏过后

37:48.060 --> 37:49.980
我们来看一下window.timer

37:49.980 --> 37:50.780
在不在

37:50.780 --> 37:51.180
是不是在

37:52.780 --> 37:55.340
你这个组件都被销毁掉了

37:55.340 --> 37:56.700
这个组件都消失了

37:57.420 --> 37:59.340
这个window.timer还在

37:59.340 --> 38:00.300
为什么还在呢

38:01.180 --> 38:02.780
因为组件的消失

38:02.780 --> 38:04.380
它并不是重新渲染

38:04.380 --> 38:05.100
这个函数呢

38:05.100 --> 38:06.540
在组件消失过后

38:06.540 --> 38:07.580
是不会运行的

38:08.540 --> 38:09.100
啊

38:09.100 --> 38:10.140
我们之前没有说到

38:10.140 --> 38:10.540
但是呢

38:10.540 --> 38:12.460
我们之前提到这么个例子对吧

38:12.460 --> 38:12.860
它是

38:12.940 --> 38:14.140
它是在什么complete

38:14.140 --> 38:14.940
地的mount

38:14.940 --> 38:15.740
和complete

38:15.740 --> 38:17.740
component地的update的时候运行

38:18.700 --> 38:20.540
组件被消毁之后

38:20.540 --> 38:22.300
它是不会运行这个函数的

38:23.260 --> 38:23.900
因此呢

38:23.900 --> 38:24.700
这个函数呢

38:25.260 --> 38:26.140
在组件消毁过后

38:26.140 --> 38:27.340
它并不知道组件消毁了

38:27.340 --> 38:28.140
它还在计时

38:28.620 --> 38:29.260
还在

38:29.260 --> 38:30.300
计时还没有停止

38:30.300 --> 38:31.740
等到10秒钟之后

38:31.740 --> 38:32.700
它才会停止

38:32.700 --> 38:33.900
现在应该等到10秒钟了

38:33.900 --> 38:34.700
再看一下

38:34.700 --> 38:35.580
是不是闹了

38:35.580 --> 38:35.980
对吧

38:35.980 --> 38:38.220
它还会继续运行这个函数

38:39.020 --> 38:40.220
整个组件都消毁了

38:40.220 --> 38:41.340
那么这个是不合理

38:42.300 --> 38:42.940
是不是不合理

38:43.580 --> 38:43.740
好

38:43.740 --> 38:44.780
那应该怎么来做呢

38:45.580 --> 38:46.540
说了半天

38:46.540 --> 38:47.900
其实就像引出这么个点

38:49.020 --> 38:50.220
use effect

38:50.940 --> 38:52.140
终的副作用

38:53.900 --> 38:55.420
终的副作用函数

38:56.860 --> 38:57.500
就这个函数

38:58.620 --> 38:59.660
就这个函数

38:59.660 --> 39:00.940
这是它的副作用函数

39:00.940 --> 39:02.460
这里边要处理一些副作用操作

39:03.020 --> 39:04.300
那么这个函数呢

39:04.300 --> 39:06.540
是可以有返回值

39:07.180 --> 39:08.460
它是可以有返回值的

39:09.420 --> 39:10.380
返回值

39:11.340 --> 39:13.100
必须是一个函数

39:14.140 --> 39:15.500
返回值也得是一个函数

39:15.500 --> 39:16.940
也说这里要返回的话

39:16.940 --> 39:18.780
以返回的return的

39:18.780 --> 39:19.900
也得是一个函数

39:20.540 --> 39:21.580
返回的也得是个函数

39:22.300 --> 39:23.420
那么该函数呢

39:24.140 --> 39:24.940
该函数

39:25.660 --> 39:27.580
叫做清理函数

39:28.780 --> 39:30.940
就是专门做一些清理工作

39:30.940 --> 39:32.460
这个函数会在什么时候运行呢

39:33.100 --> 39:33.820
该函数

39:34.540 --> 39:35.660
运行时间点

39:36.860 --> 39:37.420
时间点

39:38.540 --> 39:40.140
在每次

39:41.100 --> 39:41.980
每次

39:44.220 --> 39:47.340
运行副作用函数之前

39:48.540 --> 39:50.140
就这个函数的运行时间点

39:50.140 --> 39:51.100
它是在运行

39:51.100 --> 39:52.460
这个副作用函数之前

39:54.540 --> 39:56.300
首次加载不会运行

39:57.020 --> 39:58.380
首次加载组建

39:58.940 --> 39:59.500
不会

39:59.500 --> 40:00.540
首次轩载组建

40:02.140 --> 40:02.860
不会运行

40:03.740 --> 40:05.660
只是后续的运行

40:05.660 --> 40:07.820
它会在每一次执行函数之前

40:08.300 --> 40:08.860
再说一次

40:09.500 --> 40:11.100
第一次运行这个组建的时候

40:11.100 --> 40:12.060
它会运行这个函数

40:12.060 --> 40:12.620
对吧

40:12.620 --> 40:13.900
它会运行这个函数

40:13.900 --> 40:15.740
但是它不会运行它返回的函数

40:16.540 --> 40:18.620
但是后边我们不断的去更新这个

40:18.620 --> 40:20.060
如果更新这个组建的话

40:20.060 --> 40:21.820
那么它更新这个组建的话

40:21.820 --> 40:23.660
那么它会先运行这个函数

40:24.620 --> 40:25.500
然后再运行

40:26.540 --> 40:27.500
这个副作用函数

40:29.100 --> 40:29.420
好

40:29.420 --> 40:30.700
比方说吧

40:30.700 --> 40:31.580
我们这里呢

40:32.460 --> 40:33.740
给它加上这么一个东西

40:37.010 --> 40:37.250
这里

40:38.050 --> 40:38.770
concel log

40:39.730 --> 40:41.170
副作用函数

40:42.050 --> 40:42.610
这里呢

40:42.610 --> 40:44.130
给它加上一个东西

40:44.130 --> 40:45.330
看一下它的运行时间

40:46.130 --> 40:47.890
这个是轻力函数

40:49.010 --> 40:50.850
就专门做一些轻力工作

40:50.850 --> 40:51.730
轻力函数

40:51.730 --> 40:54.930
把之前跟之前渲染相关的副作用给它轻力掉

40:55.490 --> 40:57.250
专门来用轻力函数

40:57.250 --> 41:00.050
然后这个函数本身我们使用

41:02.450 --> 41:02.930
渲染

41:03.730 --> 41:04.690
就是那个

41:05.410 --> 41:07.730
渲染组建

41:08.450 --> 41:08.610
好

41:08.610 --> 41:09.650
看一下它们的运行时间

41:10.530 --> 41:11.010
你看一下

41:11.490 --> 41:13.090
第一开始是不是第一次渲染的时候

41:13.090 --> 41:14.130
是不是渲染组建

41:14.130 --> 41:15.810
然后再运行副作用函数

41:15.810 --> 41:16.530
对吧

41:16.530 --> 41:17.170
没问题吧

41:17.170 --> 41:18.770
渲染组建运行副作用函数

41:19.810 --> 41:20.050
然后

41:21.090 --> 41:22.610
10秒钟都在倒零和零

41:22.610 --> 41:23.730
这个没什么好说的

41:23.730 --> 41:23.890
好

41:23.890 --> 41:24.930
那么现在呢

41:24.930 --> 41:26.050
比方说把它改成一版

41:26.850 --> 41:27.970
你看改变了多次了

41:27.970 --> 41:29.010
因为这里改变了多次

41:29.570 --> 41:31.410
那么一次是不是先渲染组建

41:31.410 --> 41:32.690
再运行轻力函数

41:32.690 --> 41:33.730
再运行副作用

41:33.730 --> 41:34.770
然后再渲染组建

41:34.770 --> 41:35.650
再运行轻力函数

41:35.650 --> 41:36.690
再运行副作用

41:36.690 --> 41:37.490
再渲染组建

41:37.490 --> 41:38.370
再运行轻力函数

41:38.370 --> 41:39.250
再运行副作用

41:39.330 --> 41:40.370
它是这么一个过程

41:40.370 --> 41:40.770
对吧

41:40.770 --> 41:42.130
这边也是一版

41:43.090 --> 41:46.210
你看渲染组建运行轻力函数运行副作用

41:46.210 --> 41:47.970
渲染组建轻力函数副作用

41:47.970 --> 41:48.370
看到没

41:49.410 --> 41:51.890
并且我们带隐藏之后

41:51.890 --> 41:52.450
还有一个点

41:55.760 --> 41:56.560
不是隐藏

41:56.560 --> 41:59.680
就是组建被销毁时

41:59.680 --> 42:01.600
如果对应到生命周期的话

42:01.600 --> 42:02.800
就这个生命周期

42:02.800 --> 42:04.560
will mount

42:05.360 --> 42:05.840
当然

42:06.720 --> 42:09.360
我们其实使用use effect的时候

42:09.440 --> 42:11.360
不要去太多考虑什么生命周期

42:11.360 --> 42:13.280
你只要知道它的运行时间点就行了

42:13.840 --> 42:14.720
对比生命周期

42:14.720 --> 42:17.040
只是帮助大家回忆一下以前的知识

42:17.040 --> 42:18.240
组建被销毁时

42:18.960 --> 42:19.840
一定会运行

42:21.440 --> 42:23.600
它就是这么一些特点

42:23.600 --> 42:24.480
它的运行时间点

42:25.040 --> 42:25.840
看一下

42:26.480 --> 42:27.920
那么现在的情况

42:28.960 --> 42:29.360
隐藏

42:29.920 --> 42:31.760
你看是不是只运行了轻力函数

42:31.760 --> 42:33.680
它有没有运行副作用函数

42:34.560 --> 42:36.080
有没有运行副作用函数

42:36.080 --> 42:36.720
是没有

42:36.720 --> 42:38.240
它只是运行副作用函数

42:38.240 --> 42:40.080
返回的轻力函数

42:40.080 --> 42:41.040
它会运行这个函数

42:41.920 --> 42:43.920
由于轻力函数有这么一个特点

42:44.480 --> 42:45.440
什么叫轻力

42:45.440 --> 42:46.720
就是之前渲染过了

42:46.720 --> 42:47.920
现在又要重新渲染

42:47.920 --> 42:48.720
我要轻力

42:48.720 --> 42:50.720
我要把之前一些副作用操作

42:50.720 --> 42:51.760
可能需要的

42:51.760 --> 42:53.760
要轻力的副作用操作给它轻力掉

42:54.480 --> 42:55.280
什么要轻力

42:55.280 --> 42:56.640
就是这个组建都不要了

42:56.640 --> 42:57.760
不要这个组建了

42:57.760 --> 42:59.440
那我肯定要做一些轻力操作

42:59.920 --> 43:01.040
这就是轻力函数

43:01.680 --> 43:02.880
那么这个轻力函数

43:02.880 --> 43:04.800
它专门用这么一种机制

43:04.800 --> 43:06.080
就非常非常方便了

43:06.080 --> 43:06.880
你看着

43:06.880 --> 43:08.080
我们这两句话不要了

43:09.200 --> 43:10.080
直接返回什么

43:10.080 --> 43:10.480
Stop

43:12.480 --> 43:13.280
直接使用

43:14.480 --> 43:16.880
Stop作为轻力函数

43:17.680 --> 43:19.200
那么这样子一来

43:19.200 --> 43:21.760
是不是只要这个组建重新渲染

43:21.760 --> 43:23.360
它都要把之前的机制一起停止

43:24.000 --> 43:25.280
重新渲染都要停止

43:25.280 --> 43:26.640
并且这个组建销毁过后

43:26.640 --> 43:27.760
是不是也要停止一起去

43:28.560 --> 43:28.880
对吧

43:29.520 --> 43:30.320
保存你看一下

43:32.240 --> 43:33.680
那么现在你看

43:33.680 --> 43:34.720
这里我们怎么写

43:34.720 --> 43:35.680
它都不会有问题

43:35.680 --> 43:36.240
对吧

43:36.240 --> 43:37.120
它不会有问题的

43:37.760 --> 43:39.520
并且我们把它隐藏掉

43:39.520 --> 43:40.160
销毁掉

43:40.160 --> 43:41.840
那么我们来看一下温豆点弹梦

43:42.560 --> 43:43.760
是不是已经清理掉了

43:43.760 --> 43:44.000
对吧

43:44.000 --> 43:46.320
跟这个组建相关的副作用都已经清理掉了

43:47.680 --> 43:49.520
所以说我们这里要讲的

43:49.520 --> 43:50.320
其实就是这个点

43:50.960 --> 43:51.920
这个轻力函数

43:52.880 --> 43:54.160
也就是说这个副作用函数

43:54.160 --> 43:55.680
它可以允许有返回值

43:55.680 --> 43:56.400
这个返回值

43:56.400 --> 43:58.400
你之前不是做了一些副作用操作吗

43:58.400 --> 43:59.520
如果你重新渲染过后

43:59.520 --> 44:01.360
是不是又要做新的副作用操作

44:01.360 --> 44:02.960
那么你之前的副作用

44:02.960 --> 44:04.160
可能有一些东西

44:04.160 --> 44:04.880
一丢的东西

44:04.880 --> 44:06.320
你可能需要清理一下

44:06.480 --> 44:07.920
那么它就提供了这么一种机制

44:07.920 --> 44:09.120
让你进行清理

44:09.120 --> 44:10.240
并且这个函数销

44:10.240 --> 44:11.520
这个组建销毁之后

44:11.520 --> 44:12.720
那肯定要进行清理

44:12.720 --> 44:14.000
那么它会运行这个函数

44:14.000 --> 44:14.720
来进行清理

44:15.520 --> 44:15.920
就这个点

44:16.720 --> 44:17.360
有新知识

44:20.060 --> 44:22.300
咱们再看下一个问题

44:23.660 --> 44:25.420
接下来我们把这个复制一下

44:25.420 --> 44:27.180
保存一下当之前的代码

44:28.700 --> 44:29.740
还是以这个例子

44:29.740 --> 44:31.100
还是以这个例子

44:31.100 --> 44:32.540
之前我们用的是受控组建

44:32.540 --> 44:33.020
对吧

44:33.020 --> 44:35.180
接下来我们不用受控组建了

44:35.180 --> 44:35.580
不用了

44:36.460 --> 44:37.340
这一块也不用了

44:38.060 --> 44:38.940
不用受控组建了

44:40.460 --> 44:42.220
不用受控组建之后

44:42.220 --> 44:44.220
我们在这里加上一个按钮

44:45.420 --> 44:45.980
一个按钮

44:47.100 --> 44:51.260
表示的是

44:53.100 --> 44:53.500
确定

44:53.900 --> 44:54.300
确定

44:54.940 --> 44:55.660
加这么个按钮

44:56.380 --> 44:57.900
就是说我这里写x

44:57.900 --> 44:58.220
y

44:58.220 --> 44:58.780
随便你写

44:59.340 --> 45:00.380
想咋写咋写

45:01.580 --> 45:03.020
这里因为它不是受控组建了

45:03.020 --> 45:03.420
对吧

45:03.420 --> 45:04.860
它改变这个两个稳定框

45:04.860 --> 45:06.780
它并不会改变它的状态值

45:06.860 --> 45:07.900
没有改变状态值

45:07.900 --> 45:09.100
是不是不会重新渲染

45:09.100 --> 45:09.820
不会重新渲染

45:09.820 --> 45:11.820
是不是这个组建也不会重新渲染

45:11.820 --> 45:12.300
对吧

45:12.300 --> 45:14.220
那么自然没有发生任何变化

45:15.020 --> 45:15.180
好

45:15.180 --> 45:16.700
那么点了确定过后

45:16.700 --> 45:17.900
再来改变状态值

45:18.860 --> 45:20.460
那么这是非受控组建

45:20.460 --> 45:21.340
非中国组建的话

45:21.340 --> 45:22.860
我们点确定的时候要干嘛呢

45:23.580 --> 45:25.820
确定的时候是不是要重新设置状态值

45:26.220 --> 45:26.540
对吧

45:28.540 --> 45:31.100
要重新去设置这个状态值

45:31.100 --> 45:31.820
点确定之后

45:32.700 --> 45:32.940
好

45:32.940 --> 45:34.140
怎么来设置这个状态值呢

45:34.140 --> 45:35.260
我们是不是要非受控组建

45:35.260 --> 45:36.140
是不是要用Rave

45:36.140 --> 45:36.620
对吧

45:36.700 --> 45:37.740
那有什么办法呢

45:37.740 --> 45:38.540
一告诉我有什么办法

45:39.340 --> 45:40.620
这是txtx

45:42.140 --> 45:42.860
Rave

45:42.860 --> 45:44.220
这是txty

45:44.220 --> 45:45.100
对不对

45:45.100 --> 45:46.060
是用Rave

45:46.060 --> 45:46.700
好那么这里呢

45:46.700 --> 45:48.220
我们自然而然要创建两个Rave

45:48.940 --> 45:50.220
一个是txtx

45:51.420 --> 45:52.140
好这里面呢

45:52.140 --> 45:53.820
我们使用react

45:53.820 --> 45:54.620
createRave

45:56.910 --> 45:57.470
好这里呢

45:58.030 --> 45:58.750
txty

45:59.390 --> 45:59.950
react

46:01.390 --> 46:02.430
createRave

46:03.630 --> 46:05.470
好把Rave拿到

46:05.470 --> 46:06.270
那么确定的时候

46:06.270 --> 46:07.070
我们干嘛呢

46:07.150 --> 46:08.670
我们重新去setpoint

46:09.630 --> 46:10.670
设置新的作标

46:11.150 --> 46:11.630
对吧

46:11.630 --> 46:12.750
设置这个新的作标

46:13.390 --> 46:14.510
新的作标等于什么呢

46:14.510 --> 46:15.630
x等于啥呢

46:15.630 --> 46:17.550
等于txtx

46:17.550 --> 46:18.510
current

46:18.510 --> 46:19.230
叫什么

46:19.230 --> 46:20.110
叫Values

46:20.910 --> 46:22.030
所以把这个文门创达到

46:22.030 --> 46:22.990
其他的Values

46:23.470 --> 46:24.430
PoseInt

46:26.750 --> 46:27.390
这是x

46:28.750 --> 46:29.950
y的话是不是一样的

46:31.310 --> 46:32.350
我们用这种方式

46:32.350 --> 46:33.710
你看一下会有什么样的问题

46:35.710 --> 46:36.670
currentValue

46:38.590 --> 46:39.790
为了说明问题呢

46:40.350 --> 46:41.310
我们在这里呢

46:41.310 --> 46:42.590
上面这个主键里边

46:42.590 --> 46:44.190
这个副作用操作这里

46:44.190 --> 46:45.790
上面打上一句话

46:45.790 --> 46:47.230
副作用操作

46:48.030 --> 46:48.750
这个stop

46:48.750 --> 46:50.190
就是清理操作

46:52.110 --> 46:52.590
算了

46:52.590 --> 46:53.310
先不写

46:53.310 --> 46:54.830
就看一下副作用操作

46:55.390 --> 46:55.870
保存

46:55.870 --> 46:56.350
你看一下

46:58.030 --> 46:59.630
一开始有个副作用操作对吧

46:59.630 --> 47:00.590
第一次手持家战

47:00.590 --> 47:01.150
没问题

47:01.150 --> 47:02.270
因为手持家的鬼子道理

47:02.270 --> 47:04.030
给他x和y是多少

47:04.030 --> 47:04.430
对吧

47:04.430 --> 47:05.630
手持家战的时候

47:05.630 --> 47:06.190
比方说

47:06.190 --> 47:07.950
你可能给他的x和y

47:08.030 --> 47:09.230
比方说是100×100

47:11.630 --> 47:12.190
保存

47:13.710 --> 47:14.590
比方说是这个字

47:14.590 --> 47:14.830
对吧

47:14.830 --> 47:15.790
他一开始就会移动

47:15.790 --> 47:16.670
这个没什么问题

47:17.710 --> 47:18.670
那么现在呢

47:18.670 --> 47:19.390
大家看一下

47:20.030 --> 47:20.830
如果我说

47:20.830 --> 47:21.470
我这里呢

47:22.270 --> 47:25.630
又把它写为100×100

47:25.630 --> 47:27.070
一开始不就是100×100吗

47:27.070 --> 47:28.350
不就是要移动这个位置吗

47:28.350 --> 47:28.990
对吧

47:28.990 --> 47:31.390
那么现在再写个100×100

47:31.390 --> 47:32.190
点确定

47:32.190 --> 47:33.550
它是不是要再重新移动一次

47:34.510 --> 47:35.630
是不是要重新移动一次

47:36.270 --> 47:36.510
对吧

47:37.070 --> 47:37.230
好

47:37.230 --> 47:38.110
我们又点确定

47:38.110 --> 47:39.470
是不是又要重新移动一次

47:39.470 --> 47:40.190
为什么呢

47:40.190 --> 47:41.710
因为点了确定过后

47:41.710 --> 47:42.910
它是不是要重新渲染

47:43.470 --> 47:44.670
这个组件是不是要重新渲染

47:45.310 --> 47:46.270
因为点了确定过后

47:46.270 --> 47:47.630
是不是要给他一个新的对象

47:47.630 --> 47:48.750
我们之前说过

47:48.750 --> 47:51.790
那个重在U字Stats里边

47:52.590 --> 47:53.710
那么他只要

47:53.710 --> 47:54.670
用这个函数的时候

47:54.670 --> 47:55.550
只要你给他的

47:56.190 --> 47:57.630
对象的地址不一样

47:57.630 --> 47:58.990
只要是OpG的意思

47:58.990 --> 48:00.510
他判定出来为几样

48:00.510 --> 48:01.630
那么他就要重新渲染

48:02.350 --> 48:03.950
除非给他的同一个对象

48:04.510 --> 48:05.310
否则的话

48:05.390 --> 48:06.830
那么他就一定会重新渲染

48:07.950 --> 48:09.790
那么怎么来解决这个问题呢

48:09.790 --> 48:11.710
比方说我这里重新渲染

48:11.710 --> 48:13.150
我就这个都无所谓

48:13.150 --> 48:14.430
比方说举个例子

48:14.750 --> 48:16.270
如果你不希望它重新渲染的话

48:16.270 --> 48:16.990
怎么办

48:16.990 --> 48:18.670
那你只能去改动这个对象了

48:18.670 --> 48:19.710
只能改动这个对象

48:20.190 --> 48:20.750
只能去改

48:20.750 --> 48:22.030
改动这个对象本身了

48:22.670 --> 48:23.470
改动这个对象的

48:23.470 --> 48:24.590
一个是改动这个对象的Y

48:24.590 --> 48:25.550
但是这是不合理的

48:25.950 --> 48:27.150
不要尽量不要去这样干

48:28.190 --> 48:29.790
那如果说我现在不是说

48:29.790 --> 48:31.070
重新渲染的问题

48:31.310 --> 48:33.630
我是说你可以重新渲染

48:34.350 --> 48:35.310
但是呢

48:36.030 --> 48:37.950
你不要再执行副作用操作了

48:39.230 --> 48:41.470
如果你跟上一次的只是一样的

48:41.950 --> 48:44.030
那你就不要去执行副作用操作了

48:44.430 --> 48:45.390
这个能不能办到呢

48:46.190 --> 48:47.150
这个是可以办到的

48:47.790 --> 48:48.350
怎么办呢

48:49.150 --> 48:50.350
主要是说一下这个问题

48:50.910 --> 48:52.110
虽然我讲的这些例子

48:52.110 --> 48:53.230
可能会有一点雕砖

48:53.630 --> 48:54.430
其实这些例子

48:54.430 --> 48:56.030
你看一下别的很多

48:56.030 --> 48:57.150
别的Rx教程

48:57.310 --> 48:58.350
他哪管这些

48:58.510 --> 49:00.190
他直接给你用官方的例子

49:00.190 --> 49:02.110
官方的例子其实已经更加雕砖

49:02.670 --> 49:03.470
所以说我这里呢

49:03.790 --> 49:04.910
都是想了很久

49:04.910 --> 49:06.190
想出来这么一个例子的

49:07.230 --> 49:07.870
理解一下

49:07.870 --> 49:08.990
理解完税

49:09.230 --> 49:12.030
因为也不可能去为了这个例子

49:12.030 --> 49:13.150
为了讲这个知识点

49:13.150 --> 49:14.590
去写很复杂的代码

49:14.750 --> 49:17.070
我们就把这个情况说清楚就行了

49:17.710 --> 49:20.430
就是U字Effects函数

49:21.550 --> 49:23.870
可以传递第二个参数

49:24.590 --> 49:26.350
刚才我们是不是传递了一个参数

49:26.590 --> 49:26.990
对吧

49:26.990 --> 49:27.870
这个U字Effects

49:27.870 --> 49:28.590
是不是一个参数

49:28.590 --> 49:29.790
一个函数嘛

49:30.350 --> 49:31.390
是不是一个参数

49:31.710 --> 49:32.190
对吧

49:32.750 --> 49:34.510
那么它是可以传递

49:34.910 --> 49:35.790
第二个参数的

49:36.190 --> 49:37.150
是可以传递的

49:37.870 --> 49:39.710
那么传递第二参数是怎么意思呢

49:40.670 --> 49:43.310
第二个参数是一个数组

49:45.070 --> 49:50.510
数组中记录该副作用的依赖相

49:50.830 --> 49:51.790
依赖数据

49:53.230 --> 49:55.950
只有依赖数据

49:56.190 --> 49:56.750
就当

49:57.230 --> 49:59.790
当组建重新渲染后

50:00.750 --> 50:02.670
渲染后

50:03.390 --> 50:05.310
只有依赖数据

50:06.510 --> 50:12.350
依赖数据与上一次不一样的时

50:12.590 --> 50:16.510
不一样时才会执行副作用

50:16.990 --> 50:18.270
有那个副作用呢

50:19.150 --> 50:20.750
它不是说一定会执行了

50:21.550 --> 50:23.870
之前的每次渲染过后一定是会执行

50:24.110 --> 50:24.750
但是呢

50:24.990 --> 50:27.470
你给它传进了依赖数据过后就不一样了

50:28.190 --> 50:32.910
只要有依赖数据与上一次不一样的时候才会执行副作用

50:33.630 --> 50:35.390
所以说传递的依赖数据过后呢

50:35.390 --> 50:36.190
它有这么一个特点

50:37.870 --> 50:38.350
所以

50:38.750 --> 50:41.630
当传递了依赖数据之后

50:43.070 --> 50:43.870
数据之后

50:45.230 --> 50:48.670
如果数据没有发生变化

50:50.030 --> 50:51.870
如果数据没有发生变化会怎么样呢

50:53.630 --> 50:55.150
副作用函数

50:55.550 --> 50:59.390
仅在第一次渲染后运行

50:59.870 --> 51:01.870
第一次之前没有对比嘛对吧

51:01.870 --> 51:02.910
依赖数据没有对比

51:02.910 --> 51:04.670
所以说第一次渲染过后一定运行

51:06.110 --> 51:06.670
然后呢

51:07.070 --> 51:08.110
轻力含述

51:08.110 --> 51:09.390
如果有轻力含述的话

51:09.790 --> 51:13.790
轻力含述仅在卸载组件后运行

51:17.500 --> 51:20.060
就相当于是如果依赖向一直没发生变化

51:20.380 --> 51:23.100
如果说如果说依赖向一直没发生变化

51:23.260 --> 51:26.540
那么就相当于是运行地的Mount

51:26.540 --> 51:27.660
运行WheelMount

51:28.220 --> 51:29.020
WheelAmount

51:29.420 --> 51:30.780
这里应该是WheelAmount

51:33.250 --> 51:34.050
没有这意思吧

51:35.810 --> 51:36.690
所以说呢

51:36.690 --> 51:39.410
轻力含述仅在卸载组件后运行

51:39.410 --> 51:42.050
副作用含述只在第一次渲染时运行

51:42.050 --> 51:44.770
当然前提条件是依赖数据没有发生变化

51:45.650 --> 51:46.770
好我们回到这

51:47.730 --> 51:49.970
那么我们来解决这个问题呢

51:49.970 --> 51:51.410
我们只需要传递第二个参数

51:52.210 --> 51:52.930
一个数组

51:52.930 --> 51:53.970
所以它一定是个数组

51:54.850 --> 51:56.210
数组里边写什么

51:56.210 --> 51:57.170
写依赖的数据

51:57.730 --> 51:59.090
比较多我们这里依赖啥

51:59.090 --> 52:01.010
是不是依赖这个属性里边两个值

52:01.010 --> 52:01.810
我要移动吗

52:01.810 --> 52:02.770
属性里边有两个值

52:02.770 --> 52:04.930
你看这里边是不是用到属性里边两个值

52:04.930 --> 52:05.490
对吧

52:05.490 --> 52:06.930
这是不是我们依赖的数据

52:06.930 --> 52:07.570
对不对

52:08.370 --> 52:08.770
好

52:08.770 --> 52:09.970
那么这里Left

52:09.970 --> 52:11.170
这是我们要依赖的值

52:11.170 --> 52:11.890
Probs

52:11.890 --> 52:12.370
Top

52:12.370 --> 52:13.250
我们要依赖的值

52:13.890 --> 52:15.810
这两个值只要没发生变化

52:15.810 --> 52:17.570
它是不会运行这个副作用操作的

52:18.050 --> 52:18.290
好

52:18.290 --> 52:18.930
保存看一下

52:20.290 --> 52:22.130
一开始是100×100对吧

52:22.130 --> 52:22.690
100

52:22.930 --> 52:24.050
我重新写个

52:24.050 --> 52:25.410
100×100

52:25.410 --> 52:26.690
你看一下我们点击

52:26.690 --> 52:28.210
有没有运行副作用操作

52:28.210 --> 52:28.610
点击

52:29.330 --> 52:30.290
有没有运行

52:30.290 --> 52:31.090
有没有运行

52:31.090 --> 52:32.290
是不是没有运行了

52:32.290 --> 52:32.930
对吧

52:32.930 --> 52:34.130
因为跟之前是一样的

52:34.130 --> 52:35.170
就有的时候

52:35.170 --> 52:37.010
它可能跟之前一样的情况下

52:37.010 --> 52:38.450
我不需要运行副作用

52:38.450 --> 52:39.010
那么ok

52:39.010 --> 52:39.970
你把依赖项写好

52:40.850 --> 52:41.650
如果说

52:42.770 --> 52:43.490
不管怎么样

52:43.490 --> 52:44.690
我都要运行副作用操作

52:44.690 --> 52:44.930
ok

52:44.930 --> 52:45.810
你不要写依赖项

52:46.530 --> 52:47.410
就完了

52:47.410 --> 52:48.530
就这么一个意思

52:48.530 --> 52:49.250
你看得懂吗

52:49.250 --> 52:50.050
比方说我们这里写

52:50.850 --> 52:51.490
300

52:51.570 --> 52:53.650
现在依赖项是不是发生变化了

52:53.650 --> 52:54.530
副作用操作

52:54.530 --> 52:55.250
没问题

52:56.370 --> 52:56.530
好

52:56.530 --> 52:58.530
那么这个时候我们再写回一版

52:58.530 --> 52:59.970
是不是依赖项发生变化了

52:59.970 --> 53:00.210
对吧

53:00.210 --> 53:01.090
没问题

53:01.090 --> 53:01.330
好

53:01.330 --> 53:03.090
这里写成200

53:03.090 --> 53:04.370
依赖项发生变化了

53:04.370 --> 53:05.090
没问题

53:05.090 --> 53:06.290
然后点不停的点确定

53:06.290 --> 53:07.490
是不是没用了

53:07.490 --> 53:07.970
对吧

53:07.970 --> 53:08.690
就没用了

53:09.730 --> 53:10.930
你听我这个意思

53:10.930 --> 53:12.290
这就是依赖项

53:12.290 --> 53:13.010
依赖数据

53:14.610 --> 53:16.290
我们有很多时候

53:16.290 --> 53:18.210
其实我们在副作用操作的时候

53:18.210 --> 53:19.730
绝大部分时候

53:19.810 --> 53:21.170
我们都需要依赖项

53:21.810 --> 53:23.570
那么这个依赖项怎么来定呢

53:24.610 --> 53:26.530
要定这个依赖项的话

53:26.530 --> 53:29.890
我们主要是看这个use effects函数

53:30.930 --> 53:31.810
看它里边

53:32.610 --> 53:34.530
真实的依赖哪些数据

53:34.530 --> 53:34.930
真实

53:34.930 --> 53:37.330
因为副作用肯定要依赖一些外部数据

53:37.330 --> 53:39.090
依赖哪些外部数据

53:39.090 --> 53:40.210
那么依赖的外部数据

53:40.210 --> 53:42.450
都可以把它当成我们的依赖项

53:42.450 --> 53:43.810
这里我们使用两个数字

53:43.810 --> 53:45.250
当然不仅仅是数字

53:45.250 --> 53:46.050
也可以是对象

53:46.050 --> 53:47.090
可以是任何东西

53:47.090 --> 53:47.970
那么它比较的时候

53:48.050 --> 53:49.810
它会用OpG的意思比较

53:49.810 --> 53:51.650
只要比较出来的数据里边

53:51.650 --> 53:54.370
有任何一项跟之前的不一样

53:54.370 --> 53:56.610
它都会进行这个副作用操作

53:57.410 --> 53:58.290
明白的意思吗

53:58.290 --> 53:59.570
所以说有了依赖项之后

54:00.450 --> 54:01.170
当然它第一次

54:01.170 --> 54:03.090
它一定是会运行副作用操作的

54:03.090 --> 54:03.490
第一次

54:03.490 --> 54:05.250
因为第一次它没有对比

54:05.250 --> 54:06.690
没有这个依赖项跟之前的对比

54:06.690 --> 54:08.370
所以说它一定会运行副作用操作

54:09.170 --> 54:10.130
那么后续呢

54:10.130 --> 54:11.730
不管是只要依赖项没变

54:11.730 --> 54:13.410
不管是清理函数也好

54:13.410 --> 54:14.930
还是副作用操作也好

54:14.930 --> 54:15.730
都不再运行

54:16.210 --> 54:16.930
都不再运行

54:17.650 --> 54:19.410
清理函数只有一种情况会运行

54:19.410 --> 54:20.850
就是依赖项发生变化

54:20.850 --> 54:21.410
或者说

54:22.610 --> 54:24.530
那个组件被卸载

54:24.530 --> 54:25.490
会运行

54:25.490 --> 54:26.530
其他的都不会运行

54:27.570 --> 54:28.130
原来的意思吗

54:30.050 --> 54:30.610
所以说呢

54:30.610 --> 54:32.290
我们可以利用这一点

54:32.290 --> 54:34.370
能来实现这么一个效果

54:34.370 --> 54:36.610
就是在我们以前的内组件里边

54:36.610 --> 54:38.530
不是有这么两个生命周期函数吗

54:38.530 --> 54:40.370
一个是component didn't mount

54:40.370 --> 54:42.450
一个是component will amount

54:42.450 --> 54:42.770
对吧

54:42.770 --> 54:44.530
销毁阶段和挂点阶段

54:44.610 --> 54:45.650
我们有的时候

54:45.650 --> 54:47.170
希望某一些函数

54:47.170 --> 54:49.250
再挂在阶段运行一次

54:49.250 --> 54:49.730
后边呢

54:49.730 --> 54:50.370
更新组件

54:50.370 --> 54:51.250
准备随便怎么更新

54:51.250 --> 54:52.210
都不运行

54:52.210 --> 54:52.690
然后呢

54:52.690 --> 54:54.370
销毁阶段运行一次

54:54.370 --> 54:55.810
那么中间呢

54:56.450 --> 54:57.170
都不运行

54:57.170 --> 54:58.050
那怎么办呢

54:58.050 --> 54:58.850
我们可以利用

54:58.850 --> 54:59.330
这样

54:59.330 --> 55:00.290
我们可以这样来写

55:02.690 --> 55:03.330
比方说吧

55:03.330 --> 55:04.530
我们把这些东西把它删掉啊

55:06.720 --> 55:08.080
比方说这里有个态色组件

55:09.600 --> 55:10.160
接下来呢

55:10.160 --> 55:11.040
我们在这里呢

55:11.040 --> 55:11.840
把这个东西

55:13.440 --> 55:13.920
这样子啊

55:16.270 --> 55:17.390
concentrate

55:17.390 --> 55:17.790
就是

55:20.190 --> 55:21.230
副作用函数

55:22.910 --> 55:24.430
仅挂在

55:25.230 --> 55:27.310
使运行一次

55:28.030 --> 55:28.270
好

55:28.270 --> 55:29.550
返回一个轻力函数

55:30.430 --> 55:31.470
返回一个轻力函数

55:32.430 --> 55:32.990
那么这个是

55:35.150 --> 55:37.150
轻力函数

55:37.950 --> 55:41.790
仅卸在时运行一次

55:43.550 --> 55:44.030
有的时候呢

55:44.030 --> 55:45.630
我们可能会需要这么一个操作啊

55:46.590 --> 55:47.230
这么就是

55:47.870 --> 55:48.910
就是一个组件啊

55:48.910 --> 55:49.550
test

55:49.550 --> 55:49.950
组件

55:51.310 --> 55:51.630
好

55:52.510 --> 55:52.990
接下来呢

55:52.990 --> 55:53.470
我们这个

55:54.430 --> 55:56.430
为了看到效果呢

55:56.430 --> 55:59.230
我们就强制让这个组件刷新嘛

55:59.870 --> 56:00.190
发生

56:01.710 --> 56:02.270
刷新

56:02.910 --> 56:03.790
刷新组件

56:04.830 --> 56:06.030
刷新组件

56:06.030 --> 56:06.270
好

56:06.270 --> 56:07.070
看一下怎么来刷新啊

56:07.070 --> 56:07.870
我们之前讲过

56:07.870 --> 56:09.070
一个强制刷新的方式

56:09.070 --> 56:10.190
尽管没什么用

56:10.190 --> 56:12.190
但是我们可以用来测试

56:12.270 --> 56:13.550
Ustate

56:14.750 --> 56:15.790
这个就是

56:15.790 --> 56:16.510
递个不要

56:16.510 --> 56:17.070
递个不要

56:18.110 --> 56:19.310
这里是一个空队箱

56:20.190 --> 56:21.230
这里用Force

56:22.750 --> 56:23.150
Update

56:24.750 --> 56:24.990
好

56:24.990 --> 56:26.830
点击这个按钮之后呢

56:26.830 --> 56:28.830
咱们强制刷新这个组件啊

56:29.710 --> 56:30.830
强制刷新这个组件

56:32.430 --> 56:33.070
Force

56:33.070 --> 56:33.790
Update

56:33.790 --> 56:34.910
这个空队箱

56:34.910 --> 56:36.750
然后这个组件里面一开始

56:36.750 --> 56:37.710
渲染组件

56:39.790 --> 56:40.030
好

56:40.030 --> 56:41.070
保存啊

56:41.070 --> 56:42.270
下边的App这里呢

56:42.990 --> 56:44.030
就写个Visible嘛

56:44.030 --> 56:45.310
写个Visible就行了

56:45.310 --> 56:46.190
其他的也不要了

56:46.830 --> 56:48.110
这个东西也不要了

56:48.110 --> 56:48.750
这个DIV

56:49.870 --> 56:50.270
这样子

56:50.270 --> 56:51.310
去掉

56:51.310 --> 56:52.350
如果显示的话

56:52.350 --> 56:53.870
我们就显示这个组件本身

56:54.750 --> 56:56.590
就是Test这个组件本身

56:57.710 --> 56:58.350
点击啊

56:58.350 --> 56:59.470
显示隐藏的时候呢

56:59.470 --> 57:00.590
给它改为不显示

57:01.310 --> 57:01.790
没问题吧

57:02.510 --> 57:03.950
咱们写成这么一个结构啊

57:03.950 --> 57:05.870
这个结构就变得很尖尖了

57:05.870 --> 57:06.270
就是说呢

57:06.270 --> 57:07.790
我这里的副作用操作呢

57:08.590 --> 57:09.710
只运行一次

57:09.790 --> 57:10.750
轻力的函数呢

57:10.750 --> 57:11.710
也只运行一次

57:12.830 --> 57:13.230
这里呢

57:13.230 --> 57:15.390
点击这个组件里面的按钮呢

57:15.390 --> 57:16.670
刷新整个组件

57:16.670 --> 57:17.550
那么刷新组件过后

57:17.550 --> 57:19.630
重新渲染是不是要运行这个副作用函数

57:19.630 --> 57:20.830
也会运行之前

57:20.830 --> 57:22.270
是不是要运行轻力函数

57:22.270 --> 57:22.590
对吧

57:23.550 --> 57:23.710
好

57:23.710 --> 57:24.110
没问题吧

57:25.070 --> 57:25.230
好

57:25.230 --> 57:26.110
接下来我们来看一下啊

57:27.310 --> 57:28.910
一开始第一次这个组件呢

57:28.910 --> 57:30.030
渲染了过后

57:30.030 --> 57:31.070
运行副作用函数

57:31.870 --> 57:33.150
渲染之后运行

57:33.150 --> 57:35.070
然后那么刷新组件里看一下

57:35.070 --> 57:36.190
是不是渲染组件之后呢

57:36.190 --> 57:37.630
先要运行轻力函数

57:37.630 --> 57:39.070
然后再运行副作用函数

57:39.070 --> 57:39.470
对吧

57:40.190 --> 57:40.990
这里出到这

57:40.990 --> 57:41.870
就顺便说一下

57:41.870 --> 57:43.390
如果说我把这句话写到下面了

57:44.910 --> 57:46.430
如果说我写到下面了

57:46.430 --> 57:47.070
谁先运行

57:47.710 --> 57:48.350
他先运行

57:48.350 --> 57:48.990
他先运行

57:49.870 --> 57:50.910
是不是还是他

57:50.910 --> 57:52.270
因为这个玩意是一亿步的啊

57:52.270 --> 57:53.230
搞清楚啊

57:53.230 --> 57:54.510
这个玩意是一亿步的

57:55.150 --> 57:56.510
他不是同步的

57:56.510 --> 57:58.030
他一定是在渲染完成之后

57:58.030 --> 58:00.110
整个这个函数执行完之后

58:00.110 --> 58:02.350
把这个真实的动物加到页面之后呢

58:02.350 --> 58:03.630
我们用户看到效果之后呢

58:03.630 --> 58:04.590
才会运行

58:04.590 --> 58:05.710
所以说一样的啊

58:05.710 --> 58:06.350
效果是一样的

58:06.350 --> 58:06.830
渲染组件

58:06.830 --> 58:07.470
你看呗

58:07.470 --> 58:08.190
刷新组件

58:08.190 --> 58:08.590
看呗

58:08.590 --> 58:09.070
是一样的

58:10.670 --> 58:10.910
好

58:10.910 --> 58:11.550
那么现在呢

58:12.110 --> 58:13.310
不满足要求对吧

58:13.310 --> 58:14.990
根本的要求不相符

58:14.990 --> 58:16.430
那么我们应该怎么办呢

58:16.430 --> 58:17.870
我们可以给他加一个依赖项

58:18.510 --> 58:21.900
一个空数组

58:21.900 --> 58:23.740
使用空数组

58:23.740 --> 58:24.940
作为依赖项

58:27.420 --> 58:28.140
依赖项

58:29.500 --> 58:31.500
则副作用函数

58:33.020 --> 58:35.900
仅在挂载的时候运行

58:35.900 --> 58:37.580
为什么你想象一个道理

58:37.580 --> 58:38.220
他第一次

58:38.220 --> 58:39.740
副作用函数第一次肯定要运行的

58:39.740 --> 58:40.380
他没有对比

58:40.380 --> 58:40.700
对吧

58:40.700 --> 58:41.420
没有对比

58:41.500 --> 58:43.020
所以说他必须要运行一次

58:43.020 --> 58:43.740
但是后边呢

58:43.740 --> 58:44.460
你会他会发现

58:44.460 --> 58:45.580
他不依赖任何东西

58:46.380 --> 58:48.140
不依赖任何东西的话

58:48.140 --> 58:49.340
那么后边呢

58:49.340 --> 58:50.620
他就认为啥都没变

58:50.620 --> 58:51.740
啥都没有变

58:51.740 --> 58:52.380
啥都没有变

58:52.380 --> 58:53.180
他就不会运行了

58:53.900 --> 58:55.740
他就不会运行这个副作用函数了

58:55.740 --> 58:56.540
就这么个意思

58:57.420 --> 58:59.340
应该就这么个意思啊

58:59.340 --> 59:01.100
那么同样的副作用函数他不运行

59:01.100 --> 59:03.180
那么清理函数也没有必要运行

59:03.180 --> 59:04.380
因为清理啥呢

59:05.100 --> 59:06.220
之前的副作用都没有运行

59:06.220 --> 59:07.020
你清理啥呢

59:07.020 --> 59:07.980
他又不会运行

59:07.980 --> 59:09.100
为什么要清理

59:09.100 --> 59:10.460
是因为之前的副作用

59:10.460 --> 59:12.380
可能带来了一些东西

59:12.380 --> 59:15.580
而下一次呢又要运行副作用函数

59:15.580 --> 59:16.700
这个时候呢才会清理

59:17.580 --> 59:19.180
但是我现在后边的副作用函数

59:19.180 --> 59:19.980
根本就不会运行

59:19.980 --> 59:21.180
他就不会清理

59:21.180 --> 59:21.820
就这么个意思

59:22.460 --> 59:23.340
但是清理函数呢

59:23.340 --> 59:24.540
会在卸载的时候运行

59:24.540 --> 59:25.740
这个是跑不了的

59:25.740 --> 59:26.860
因为组建都没了

59:26.860 --> 59:28.300
那么要清理掉一些副作用

59:28.300 --> 59:29.420
当然那潜力条件

59:29.420 --> 59:31.340
一定是有这么一些东西需要清理

59:32.060 --> 59:32.540
好好保存

59:32.540 --> 59:32.940
你看一下

59:33.740 --> 59:35.660
现在你看一看是运行的刷新组建

59:35.660 --> 59:37.500
你看他只有重新渲染

59:37.500 --> 59:39.340
但是呢没有运行副作用函数

59:39.340 --> 59:40.060
他没有依赖一下

59:40.620 --> 59:42.460
然后呢我们把组建卸载之后

59:42.460 --> 59:44.380
你看清理函数运行一次

59:45.180 --> 59:45.660
对吧

59:45.660 --> 59:46.620
就像那样有这么个东西

59:48.220 --> 59:48.380
好

59:48.380 --> 59:50.540
这是这么一个指示点

59:51.740 --> 59:51.980
好

59:51.980 --> 59:52.380
下一个

59:53.980 --> 59:55.180
下一个要特别注意了

59:55.980 --> 59:57.980
非常非常容易翻错的地方

59:59.740 --> 01:00:01.260
副作用函数

01:00:03.180 --> 01:00:03.500
中

01:00:06.060 --> 01:00:09.020
如果使用了函数

01:00:09.100 --> 01:00:11.260
上下文中的变量

01:00:14.450 --> 01:00:16.530
则由于

01:00:17.410 --> 01:00:18.770
必包的影响

01:00:21.200 --> 01:00:22.080
必包的影响

01:00:23.360 --> 01:00:26.400
会导致副作用函数中

01:00:27.840 --> 01:00:28.320
变量

01:00:29.600 --> 01:00:30.080
变量

01:00:30.720 --> 01:00:32.480
不会实时变化

01:00:33.360 --> 01:00:34.240
什么意思

01:00:35.760 --> 01:00:36.480
给大家解释一下

01:00:36.480 --> 01:00:37.200
这是什么意思

01:00:40.700 --> 01:00:40.940
好

01:00:40.940 --> 01:00:41.420
这里呢

01:00:41.980 --> 01:00:42.780
关闭到右侧

01:00:43.580 --> 01:00:44.380
好

01:00:44.380 --> 01:00:45.180
这里呢

01:00:45.180 --> 01:00:47.260
我们设置一个状态

01:00:48.780 --> 01:00:49.980
U state

01:00:50.780 --> 01:00:51.740
设置个状态

01:00:51.740 --> 01:00:52.380
N

01:00:52.380 --> 01:00:53.180
就N

01:00:53.180 --> 01:00:53.580
0

01:00:55.180 --> 01:00:55.740
这里面呢

01:00:55.740 --> 01:00:58.140
我们用一个H1显示这个状态

01:00:59.340 --> 01:01:00.540
H1显示个状态

01:01:01.500 --> 01:01:01.900
好

01:01:01.900 --> 01:01:02.780
显示一个N

01:01:03.820 --> 01:01:04.620
显示一个N

01:01:05.900 --> 01:01:06.060
好

01:01:06.060 --> 01:01:06.620
看着啊

01:01:07.660 --> 01:01:08.620
接下来呢

01:01:08.620 --> 01:01:10.220
我们下面呢有一个按钮

01:01:11.420 --> 01:01:12.140
这个按钮呢

01:01:12.140 --> 01:01:13.500
就是N加1

01:01:14.220 --> 01:01:15.500
很简单对吧

01:01:15.500 --> 01:01:16.140
unclick

01:01:17.100 --> 01:01:17.740
N加1

01:01:20.030 --> 01:01:20.270
好

01:01:20.270 --> 01:01:20.990
这里面呢

01:01:20.990 --> 01:01:22.430
我们输出啥呢

01:01:22.430 --> 01:01:24.590
输出这个N

01:01:24.590 --> 01:01:25.390
N

01:01:25.390 --> 01:01:27.070
不是输出N

01:01:27.070 --> 01:01:27.550
就是

01:01:30.110 --> 01:01:31.310
set N

01:01:31.310 --> 01:01:32.350
为N加1

01:01:33.230 --> 01:01:33.710
没问题吧

01:01:34.430 --> 01:01:35.710
这个很简单对不对

01:01:35.710 --> 01:01:36.990
这个没什么难的

01:01:36.990 --> 01:01:37.790
很简单

01:01:37.790 --> 01:01:38.110
对吧

01:01:38.910 --> 01:01:39.150
好

01:01:39.150 --> 01:01:39.550
接下来

01:01:39.550 --> 01:01:41.310
我们要玩一个非常有意思的事情

01:01:41.870 --> 01:01:43.870
我们给它添加一个副作用函数

01:01:46.400 --> 01:01:48.800
这个副作用函数要干嘛呢

01:01:48.800 --> 01:01:50.080
它里面有个set timeout

01:01:51.120 --> 01:01:52.320
3秒钟之后

01:01:53.680 --> 01:01:54.640
多一点嘛

01:01:54.640 --> 01:01:55.600
5秒钟之后

01:01:56.320 --> 01:01:56.800
输出

01:01:57.920 --> 01:01:58.880
输出这个N

01:02:01.490 --> 01:02:02.370
看着吧

01:02:02.370 --> 01:02:03.730
特别特别有意思

01:02:03.730 --> 01:02:04.930
特别有意思

01:02:04.930 --> 01:02:05.810
包存看一下

01:02:07.810 --> 01:02:08.690
5秒钟之后

01:02:08.690 --> 01:02:09.810
等5秒啊

01:02:09.810 --> 01:02:10.450
输出这个N

01:02:11.250 --> 01:02:11.730
是不是0

01:02:12.210 --> 01:02:12.450
对吧

01:02:12.450 --> 01:02:13.410
没问题吧

01:02:13.410 --> 01:02:13.890
N

01:02:14.610 --> 01:02:15.330
刷新一下

01:02:15.330 --> 01:02:15.970
我们点

01:02:15.970 --> 01:02:16.530
不停的加

01:02:17.250 --> 01:02:18.050
看5秒钟之后

01:02:18.050 --> 01:02:18.450
输出啥

01:02:20.530 --> 01:02:20.850
0

01:02:24.770 --> 01:02:25.250
啥意思

01:02:26.290 --> 01:02:26.770
啥意思

01:02:27.490 --> 01:02:28.850
咱们来理语一下

01:02:28.850 --> 01:02:29.810
理语一下

01:02:29.810 --> 01:02:30.770
先看一下

01:02:30.770 --> 01:02:32.290
一直如果你清楚了

01:02:32.290 --> 01:02:33.570
为什么它一开始会

01:02:33.570 --> 01:02:34.930
那么这里为什么会输出0

01:02:34.930 --> 01:02:35.570
你就知道了

01:02:35.570 --> 01:02:37.330
后面为什么会输出12356789

01:02:38.530 --> 01:02:38.930
好

01:02:38.930 --> 01:02:39.330
看一下吧

01:02:41.630 --> 01:02:42.910
一开始的时候

01:02:44.430 --> 01:02:45.310
渲染完成

01:02:46.750 --> 01:02:47.390
渲染完成

01:02:48.590 --> 01:02:49.310
渲染完成过后

01:02:49.310 --> 01:02:50.510
是不是要执行副作用函数

01:02:51.470 --> 01:02:51.870
对吧

01:02:52.430 --> 01:02:53.630
要执行副作用函数吧

01:02:54.430 --> 01:02:54.910
没问题吧

01:02:55.790 --> 01:02:56.030
好

01:02:56.030 --> 01:02:57.870
那么执行这个函数的时候

01:02:57.870 --> 01:02:58.750
这里是不是就必包

01:02:59.470 --> 01:02:59.790
对吧

01:02:59.790 --> 01:03:00.990
它用了外面的变量

01:03:00.990 --> 01:03:01.550
函数里边

01:03:02.190 --> 01:03:03.310
用了函数外部的变量

01:03:03.310 --> 01:03:04.430
是不是有必包

01:03:04.430 --> 01:03:06.030
那么我们根据我们以前

01:03:06.030 --> 01:03:08.910
介绍执行上下文的知识

01:03:08.910 --> 01:03:10.670
作用预练的知识

01:03:10.670 --> 01:03:12.590
那么这个N指向的是什么

01:03:12.590 --> 01:03:15.230
指向的是N指向

01:03:16.190 --> 01:03:20.590
当前函数调用时

01:03:20.590 --> 01:03:22.750
当前函数调用时

01:03:22.750 --> 01:03:24.430
怎么还说当前

01:03:24.430 --> 01:03:28.350
App函数调用时的N指

01:03:28.350 --> 01:03:28.990
N的指

01:03:30.510 --> 01:03:31.710
N对不对

01:03:31.710 --> 01:03:33.230
就这一次App调用的时候

01:03:33.230 --> 01:03:34.110
N的指是不是0

01:03:34.670 --> 01:03:35.310
是不是0

01:03:35.310 --> 01:03:36.510
于是N指向的是谁

01:03:36.510 --> 01:03:37.150
指向的是0

01:03:39.150 --> 01:03:39.950
然后呢

01:03:39.950 --> 01:03:40.510
它还

01:03:40.510 --> 01:03:42.110
它等待5秒之后才会输出

01:03:42.110 --> 01:03:42.430
对吧

01:03:42.430 --> 01:03:43.550
它输出的一定是0

01:03:44.190 --> 01:03:44.910
为什么呢

01:03:45.070 --> 01:03:47.230
哪怕你这5秒钟之内

01:03:47.230 --> 01:03:48.350
点了它10次

01:03:49.070 --> 01:03:49.790
点了它10次

01:03:49.790 --> 01:03:51.310
是不是就重新调用App

01:03:51.310 --> 01:03:52.830
是不是是新的函数调用

01:03:52.830 --> 01:03:54.350
不再是之前那个函数调用了

01:03:54.350 --> 01:03:55.230
对吧

01:03:55.230 --> 01:03:56.750
新的函数调用

01:03:56.750 --> 01:03:59.310
而新的函数调用的时候

01:03:59.310 --> 01:04:00.750
是不是新的上下文

01:04:00.750 --> 01:04:01.950
新的上下文里边N的指

01:04:01.950 --> 01:04:03.550
跟之前那个N有没有关系

01:04:04.110 --> 01:04:04.910
是不是没有关系

01:04:07.280 --> 01:04:07.920
画一圖

01:04:07.920 --> 01:04:08.560
不画一圖了

01:04:08.560 --> 01:04:08.880
要蒙

01:04:09.600 --> 01:04:10.000
要蒙

01:04:12.560 --> 01:04:12.960
看着吧

01:04:15.280 --> 01:04:17.120
这不是说Rx里边的东西

01:04:17.360 --> 01:04:19.520
这是Gs里边的东西

01:04:20.800 --> 01:04:21.120
好

01:04:21.120 --> 01:04:22.320
第一次函数调用

01:04:22.960 --> 01:04:24.400
第一次函数调用的时候手持夹展

01:04:24.400 --> 01:04:24.960
对吧

01:04:24.960 --> 01:04:26.720
App第一次

01:04:28.400 --> 01:04:30.240
一次调用

01:04:30.240 --> 01:04:31.600
它的N的指是多少

01:04:31.600 --> 01:04:32.000
是不是0

01:04:32.880 --> 01:04:33.360
没问题吧

01:04:34.160 --> 01:04:34.400
好

01:04:34.400 --> 01:04:35.200
N的指是0

01:04:35.200 --> 01:04:37.200
那么这个副作用函数里边的N

01:04:37.200 --> 01:04:38.000
是不是只像这个N

01:04:38.560 --> 01:04:39.040
对吧

01:04:39.040 --> 01:04:40.400
副作用里边函数的N

01:04:40.960 --> 01:04:42.000
这里有一个副作用函数

01:04:42.640 --> 01:04:43.440
副作用函数

01:04:44.800 --> 01:04:45.840
笔包嘛

01:04:45.840 --> 01:04:46.240
副作用

01:04:47.600 --> 01:04:48.400
函数

01:04:48.400 --> 01:04:50.480
那么这里的函数的里边用的N

01:04:50.480 --> 01:04:51.280
是不是只像这个N

01:04:52.240 --> 01:04:52.560
对吧

01:04:52.560 --> 01:04:53.680
只像这个上下文里边的N

01:04:54.240 --> 01:04:55.040
这是以前

01:04:55.440 --> 01:04:56.640
直行上下文的指示

01:04:57.120 --> 01:04:57.760
是不是只像这

01:04:58.960 --> 01:04:59.200
好

01:04:59.200 --> 01:05:00.960
那么现在第一次函数调用完了

01:05:00.960 --> 01:05:02.000
调完了这个N

01:05:02.000 --> 01:05:03.600
这个上下文的N是不是还存在

01:05:03.600 --> 01:05:03.840
对吧

01:05:03.840 --> 01:05:05.440
虽然它没有在直行站里边了

01:05:06.240 --> 01:05:08.000
虽然说它没有在直行站里边了

01:05:08.000 --> 01:05:09.120
但是这个N是不是存在

01:05:10.160 --> 01:05:10.480
好

01:05:10.480 --> 01:05:11.280
然后呢

01:05:11.280 --> 01:05:12.480
我们这里点击按钮

01:05:12.480 --> 01:05:13.520
5秒钟还没到

01:05:13.520 --> 01:05:14.560
点击按钮

01:05:14.560 --> 01:05:15.600
点击按钮过后呢

01:05:15.600 --> 01:05:16.880
是不是又新增一个

01:05:16.960 --> 01:05:18.080
就是N增加了

01:05:18.080 --> 01:05:19.440
增加了是不是要重新调用函数

01:05:20.000 --> 01:05:21.760
而重新调用函数的话

01:05:21.760 --> 01:05:23.440
是不是又有第二次调用了

01:05:23.440 --> 01:05:23.680
对吧

01:05:24.400 --> 01:05:25.920
有一个新的上下文产生了

01:05:25.920 --> 01:05:26.560
第二次调用

01:05:26.560 --> 01:05:27.360
N等于多少

01:05:27.360 --> 01:05:28.000
N等于1

01:05:28.800 --> 01:05:29.840
那么这个时候呢

01:05:29.840 --> 01:05:30.800
渲染完成之后

01:05:30.800 --> 01:05:32.160
是不是又产生了一个副作用函数

01:05:33.200 --> 01:05:34.480
那么这个副作用函数里边

01:05:34.480 --> 01:05:35.440
它是不是只像这个N

01:05:36.000 --> 01:05:36.240
好

01:05:36.240 --> 01:05:37.920
那么这一次渲染完了

01:05:37.920 --> 01:05:39.040
又加了一个副作用函数

01:05:40.560 --> 01:05:41.680
又加了一个副作用函数

01:05:42.960 --> 01:05:43.440
懂这个意思吧

01:05:43.440 --> 01:05:44.240
后面我不画了吧

01:05:44.800 --> 01:05:45.440
而只像这个N

01:05:46.400 --> 01:05:48.400
那么到时候五秒钟到达之后

01:05:48.400 --> 01:05:49.920
那么这个副作用函数运行

01:05:49.920 --> 01:05:51.200
输出N是不是输出了这个N

01:05:51.760 --> 01:05:52.720
还是之前的N

01:05:52.720 --> 01:05:54.880
因为B包它就这么一个特点

01:05:54.880 --> 01:05:56.560
这不是说什么Rex的特点

01:05:56.560 --> 01:05:56.960
这是

01:05:57.600 --> 01:05:58.640
执行上下文的特点

01:05:59.680 --> 01:06:01.040
那么这样子是不是输出了这个N

01:06:02.000 --> 01:06:02.960
所以说呢

01:06:02.960 --> 01:06:04.640
以前万不要认为

01:06:06.080 --> 01:06:08.800
副作用函数里边能够实时的获取

01:06:08.800 --> 01:06:10.080
最新的状态

01:06:10.080 --> 01:06:10.800
那不可能的

01:06:11.440 --> 01:06:12.080
这个副作用

01:06:12.080 --> 01:06:14.000
它也不符合逻辑对吧

01:06:14.000 --> 01:06:15.040
逻辑是什么

01:06:15.120 --> 01:06:16.480
我为什么要产生这个副作用

01:06:16.480 --> 01:06:18.560
是因为这一次渲染完成之后

01:06:18.560 --> 01:06:19.520
我要做的副作用

01:06:19.520 --> 01:06:22.240
那么我这里边得到的数据

01:06:22.240 --> 01:06:24.240
全是跟这一次相关的

01:06:24.240 --> 01:06:25.280
这是不是符合逻辑的

01:06:26.320 --> 01:06:27.200
是不是符合逻辑的

01:06:28.160 --> 01:06:30.640
我要处理的不是后边渲染的副作用

01:06:30.640 --> 01:06:33.120
我说要处理的是这一次的副作用

01:06:33.680 --> 01:06:34.880
这一次渲染的副作用

01:06:35.520 --> 01:06:37.200
所以说这是符合逻辑的

01:06:37.200 --> 01:06:38.400
是没有问题的

01:06:38.400 --> 01:06:39.280
没有问题的

01:06:39.280 --> 01:06:41.120
所以说就应该是这么一个现象

01:06:41.120 --> 01:06:42.000
它如果不是这个现象

01:06:42.000 --> 01:06:43.040
那才奇怪了

01:06:43.120 --> 01:06:45.120
那肯定是Rex又给你加了一些魔法

01:06:45.120 --> 01:06:46.880
Rex是最讨厌魔法的

01:06:46.880 --> 01:06:48.640
有魔法就意味着

01:06:49.120 --> 01:06:49.840
不好理解

01:06:50.400 --> 01:06:52.080
不好理解这一块的原理

01:06:52.080 --> 01:06:52.480
而且呢

01:06:52.480 --> 01:06:54.000
这是本来就是符合逻辑的

01:06:54.000 --> 01:06:55.280
因为我这一次渲染过后

01:06:55.280 --> 01:06:57.040
我要处理这一次渲染的副作用

01:06:57.040 --> 01:06:58.400
那么肯定得到的数据

01:06:58.400 --> 01:06:59.760
是跟这一次渲染相关的

01:07:01.520 --> 01:07:01.840
好

01:07:01.840 --> 01:07:02.800
这是这一点啊

01:07:02.800 --> 01:07:04.640
要特别特别注意

01:07:05.360 --> 01:07:06.080
不要乱来

01:07:07.120 --> 01:07:07.440
好

01:07:07.440 --> 01:07:08.880
既然说到这一点啊

01:07:08.880 --> 01:07:09.760
我刚才告诉大家

01:07:09.760 --> 01:07:12.000
大家可能有在某些开发的时候

01:07:12.000 --> 01:07:13.360
容易犯一些错误

01:07:13.360 --> 01:07:14.880
比方说什么错误呢

01:07:14.880 --> 01:07:16.320
我给大家看一个代码

01:07:16.320 --> 01:07:17.440
看一段代码

01:07:17.440 --> 01:07:18.560
这里呢

01:07:18.560 --> 01:07:20.720
比方说有个计时器组件

01:07:20.720 --> 01:07:22.240
10秒到计时

01:07:22.240 --> 01:07:24.240
10秒到计时

01:07:24.240 --> 01:07:24.560
好

01:07:24.560 --> 01:07:25.200
那么有些朋友呢

01:07:25.200 --> 01:07:26.560
可能会这样子写代码

01:07:26.560 --> 01:07:27.920
如果你要利用户口的话

01:07:27.920 --> 01:07:29.120
可能会这样子写代码

01:07:29.120 --> 01:07:31.360
那么我要在第一次渲染之后呢

01:07:31.360 --> 01:07:32.480
启动一个计时器

01:07:32.480 --> 01:07:32.880
于是呢

01:07:32.880 --> 01:07:33.760
他会这样子写

01:07:33.760 --> 01:07:35.280
写个依赖相啊

01:07:35.280 --> 01:07:36.560
为空数组

01:07:36.560 --> 01:07:38.000
依赖相为空数组

01:07:38.000 --> 01:07:38.480
然后呢

01:07:38.480 --> 01:07:39.680
在第一次渲染的时候呢

01:07:39.680 --> 01:07:41.040
启动一个计时器

01:07:41.200 --> 01:07:42.240
intel

01:07:42.240 --> 01:07:44.080
启动一个计时器

01:07:44.080 --> 01:07:45.920
这个计时器里边干嘛呢

01:07:45.920 --> 01:07:47.200
我就set n

01:07:47.200 --> 01:07:49.360
等于n-1

01:07:49.360 --> 01:07:50.800
因为他知道

01:07:50.800 --> 01:07:52.720
这个函数他一定是只运行一次

01:07:52.720 --> 01:07:53.040
对吧

01:07:53.040 --> 01:07:54.000
这个函数只运行一次

01:07:54.000 --> 01:07:55.440
因为加了空数组依赖相

01:07:55.440 --> 01:07:56.640
他只运行一次

01:07:56.640 --> 01:07:57.600
所以说他不用担心

01:07:57.600 --> 01:07:59.040
启动多个计时器的问题

01:07:59.040 --> 01:07:59.520
好

01:07:59.520 --> 01:08:00.720
那么这样子想是没问题的啊

01:08:00.720 --> 01:08:02.480
这种想法肯定是没问题的

01:08:02.480 --> 01:08:03.200
好

01:08:03.200 --> 01:08:04.400
那么这里写个time

01:08:04.400 --> 01:08:05.600
n-1对吧

01:08:05.600 --> 01:08:06.000
好

01:08:06.000 --> 01:08:06.320
然后呢

01:08:06.320 --> 01:08:07.120
他判断

01:08:07.120 --> 01:08:09.360
如果n的值等于0

01:08:09.360 --> 01:08:10.640
那么是不是计时器停止

01:08:10.720 --> 01:08:11.600
clear interval

01:08:11.600 --> 01:08:11.920
对吧

01:08:11.920 --> 01:08:12.800
计时器停止

01:08:13.920 --> 01:08:14.720
他为了避免

01:08:15.840 --> 01:08:17.200
这个组件被卸载之后呢

01:08:17.200 --> 01:08:17.920
计时器还在

01:08:17.920 --> 01:08:20.640
所以说他非常机智的

01:08:20.640 --> 01:08:22.080
返回一个清理函数

01:08:22.080 --> 01:08:22.400
然后呢

01:08:22.400 --> 01:08:23.600
把这个计时器清空

01:08:25.200 --> 01:08:26.640
这是函数卸载时运行

01:08:27.920 --> 01:08:29.920
函数卸载时运行

01:08:31.760 --> 01:08:32.240
这个呢

01:08:32.240 --> 01:08:32.640
是在

01:08:34.480 --> 01:08:34.800
这个呢

01:08:34.800 --> 01:08:35.360
是副动用

01:08:35.360 --> 01:08:36.960
就紧在第一次运行

01:08:36.960 --> 01:08:38.000
紧挂载时运行

01:08:39.440 --> 01:08:40.480
紧挂载时

01:08:40.800 --> 01:08:41.840
后运行

01:08:43.120 --> 01:08:43.920
看一下啊

01:08:43.920 --> 01:08:44.320
嗯

01:08:44.320 --> 01:08:46.000
为什么他是这样的一个特点呢

01:08:46.000 --> 01:08:47.120
是因为我传了个凶数组

01:08:47.840 --> 01:08:48.000
啊

01:08:48.000 --> 01:08:49.680
但是现在还可以报一个警告

01:08:49.680 --> 01:08:50.320
他想了半天

01:08:50.320 --> 01:08:51.040
可以可能不知道

01:08:51.040 --> 01:08:52.400
为什么要可以报这个警告了

01:08:52.400 --> 01:08:53.840
因为为什么有这个警告

01:08:53.840 --> 01:08:55.520
因为这个函数里边依赖了是吗

01:08:55.520 --> 01:08:56.080
依赖了n

01:08:56.560 --> 01:08:57.120
看没

01:08:57.120 --> 01:08:57.840
他依赖了n

01:08:58.560 --> 01:08:58.960
但是呢

01:08:58.960 --> 01:09:00.000
你这里有没有写n呢

01:09:00.800 --> 01:09:01.520
有没有写这个n

01:09:02.080 --> 01:09:03.040
是没有

01:09:03.040 --> 01:09:03.440
对吧

01:09:03.440 --> 01:09:04.640
但是他又不能写上

01:09:04.640 --> 01:09:05.360
写到n的过后

01:09:05.360 --> 01:09:07.040
他要启动多个计时器导致

01:09:07.040 --> 01:09:07.200
啊

01:09:07.200 --> 01:09:07.760
他就啊

01:09:07.760 --> 01:09:09.680
管他的警告就警告嘛

01:09:09.760 --> 01:09:10.720
他没有想象一下

01:09:11.440 --> 01:09:12.240
为什么这样子

01:09:12.720 --> 01:09:13.760
rex这么傻

01:09:13.760 --> 01:09:15.120
他没有考虑到这种情况

01:09:15.120 --> 01:09:16.000
rex他不傻的

01:09:16.480 --> 01:09:17.760
上面的代码写的有问题

01:09:18.880 --> 01:09:21.040
啊有些人说看没问题啊

01:09:21.040 --> 01:09:21.360
好

01:09:21.360 --> 01:09:22.080
仔细看一下哦

01:09:22.080 --> 01:09:22.960
原来这里有问题

01:09:22.960 --> 01:09:23.760
这个set n呢

01:09:23.760 --> 01:09:25.120
他可能是异步的对吧

01:09:25.840 --> 01:09:27.120
实际上这里不是异步的

01:09:27.120 --> 01:09:27.760
因为

01:09:27.760 --> 01:09:29.040
他不是动物事件

01:09:29.040 --> 01:09:30.320
动物事件里边是异步的

01:09:30.320 --> 01:09:30.960
那行吧

01:09:30.960 --> 01:09:32.720
那就假设他是异步的对吧

01:09:32.720 --> 01:09:33.440
那么他怕

01:09:33.440 --> 01:09:33.840
怕什么

01:09:33.840 --> 01:09:35.600
怕运行到这句话的时候呢

01:09:35.600 --> 01:09:36.800
n还没有更新

01:09:36.800 --> 01:09:37.120
对吧

01:09:37.120 --> 01:09:38.240
n还没有更新

01:09:38.240 --> 01:09:38.960
所以说呢

01:09:39.040 --> 01:09:40.400
他又做成什么事情了

01:09:40.400 --> 01:09:40.720
啊

01:09:42.240 --> 01:09:42.960
得到一个变

01:09:42.960 --> 01:09:44.800
用个变量啊得到一个6n

01:09:44.800 --> 01:09:45.920
6n等于什么呢

01:09:45.920 --> 01:09:47.040
等于n-1

01:09:47.760 --> 01:09:48.960
让他这里设置什么

01:09:48.960 --> 01:09:49.680
设置6n

01:09:50.560 --> 01:09:51.040
然后呢

01:09:51.040 --> 01:09:51.840
这里使用

01:09:52.560 --> 01:09:54.320
6n是不是等于0

01:09:55.200 --> 01:09:56.080
用这种方式来做

01:09:57.840 --> 01:09:58.720
真正的问题

01:09:58.720 --> 01:09:59.600
不在什么

01:09:59.600 --> 01:10:00.480
异步啊

01:10:00.480 --> 01:10:01.040
不在这

01:10:01.680 --> 01:10:02.560
当然他理解

01:10:02.560 --> 01:10:03.760
其实已经非常不错了啊

01:10:03.760 --> 01:10:05.040
理解如果能写成这样的代码

01:10:05.040 --> 01:10:06.640
他理解已经非常不错了

01:10:06.640 --> 01:10:07.120
但是呢

01:10:07.120 --> 01:10:07.680
你会发现

01:10:08.480 --> 01:10:09.840
根本就不是他想象的样子

01:10:10.320 --> 01:10:11.440
他到了9就不动了

01:10:14.030 --> 01:10:15.230
咱们好好看一下

01:10:15.230 --> 01:10:16.750
到了9为什么不动了呢

01:10:16.750 --> 01:10:18.350
我们把这个6n输出

01:10:18.350 --> 01:10:19.390
6n输出

01:10:19.390 --> 01:10:19.790
看一下

01:10:24.260 --> 01:10:24.820
哎

01:10:24.820 --> 01:10:25.140
哦

01:10:25.140 --> 01:10:26.020
set to interval

01:10:26.020 --> 01:10:27.380
set to interval没有写那个

01:10:27.380 --> 01:10:28.420
没有写时间限格啊

01:10:28.420 --> 01:10:28.900
一秒钟

01:10:29.780 --> 01:10:30.340
一秒钟

01:10:31.060 --> 01:10:31.620
看一下吧

01:10:31.620 --> 01:10:32.580
到9就不动了

01:10:32.580 --> 01:10:33.620
他不听到输出9

01:10:34.820 --> 01:10:35.540
什么意思呢

01:10:36.340 --> 01:10:37.700
就是因为他

01:10:37.700 --> 01:10:39.940
还在抱着跟之前的

01:10:39.940 --> 01:10:41.620
内组件的那种思维模式

01:10:42.580 --> 01:10:43.620
认为呢

01:10:43.620 --> 01:10:44.180
这个n呢

01:10:44.180 --> 01:10:45.620
始终是实时的

01:10:45.620 --> 01:10:46.980
它是不是实时的

01:10:46.980 --> 01:10:47.540
不是

01:10:48.180 --> 01:10:49.460
你这一次

01:10:49.460 --> 01:10:50.340
你再做的是

01:10:50.340 --> 01:10:52.340
这一次的副作用操作

01:10:53.060 --> 01:10:53.300
啊

01:10:53.300 --> 01:10:53.780
你做的是

01:10:53.780 --> 01:10:55.140
这一次的副作用操作

01:10:56.020 --> 01:10:57.220
那么你跟

01:10:57.220 --> 01:10:57.940
他不是说

01:10:57.940 --> 01:10:59.060
后边的副作用操作啊

01:10:59.060 --> 01:10:59.540
是你

01:10:59.540 --> 01:11:01.140
就是这一次渲染过后

01:11:01.140 --> 01:11:01.860
跟这一次

01:11:01.860 --> 01:11:03.780
渲染完成之后的副作用操作

01:11:03.780 --> 01:11:04.260
但是呢

01:11:04.260 --> 01:11:05.540
他老是去想着

01:11:05.540 --> 01:11:06.740
生命周期那一块

01:11:06.740 --> 01:11:07.780
实际上现在跟生命周期

01:11:07.780 --> 01:11:08.340
没有什么

01:11:08.340 --> 01:11:09.140
多少关系了

01:11:09.780 --> 01:11:10.820
就是解决副作用

01:11:10.900 --> 01:11:11.780
每次渲染完成过后

01:11:11.780 --> 01:11:13.060
有哪些额外的事情要做

01:11:14.100 --> 01:11:15.140
你不要去老想着

01:11:15.140 --> 01:11:15.700
想着生命周期

01:11:15.700 --> 01:11:16.180
我跟你讲

01:11:16.180 --> 01:11:16.740
生命周期呢

01:11:16.740 --> 01:11:17.860
主要是给你一个对照

01:11:17.860 --> 01:11:18.660
对到内组件

01:11:18.660 --> 01:11:19.940
那一块是怎么回事

01:11:20.580 --> 01:11:21.700
遍运你好理解

01:11:21.700 --> 01:11:23.140
实际上这个use而fig成了

01:11:23.540 --> 01:11:24.980
他跟生命周期没有什么关系

01:11:25.540 --> 01:11:26.660
他的意思就是说

01:11:26.660 --> 01:11:27.940
我渲染完成之后

01:11:27.940 --> 01:11:29.540
有什么事情应该做

01:11:31.300 --> 01:11:32.180
而不是说

01:11:32.180 --> 01:11:33.140
我这里渲染完

01:11:33.140 --> 01:11:34.100
第一次渲染完成

01:11:34.100 --> 01:11:35.060
每次渲染完成之后

01:11:36.260 --> 01:11:37.380
我都要去从

01:11:37.380 --> 01:11:38.260
设计时期

01:11:38.260 --> 01:11:39.860
不断地去设计n的值

01:11:40.020 --> 01:11:41.700
就当前这一次渲染的n的值

01:11:41.700 --> 01:11:42.660
不断去改变

01:11:43.220 --> 01:11:45.300
根据当前这一次渲染的n的值

01:11:45.860 --> 01:11:47.140
去得到新的值

01:11:47.140 --> 01:11:48.660
而不应该去做这样的事情

01:11:49.620 --> 01:11:50.740
所以说这里的正确代码

01:11:50.740 --> 01:11:52.020
应该是怎么写的

01:11:52.020 --> 01:11:52.820
这里是错误的

01:11:54.900 --> 01:11:57.140
以下是错误的做法

01:11:58.500 --> 01:12:00.180
正确的做法应该怎么做呢

01:12:00.180 --> 01:12:00.500
看着

01:12:01.380 --> 01:12:02.340
正确的做法应该这样写

01:12:04.340 --> 01:12:06.580
你这一次渲染完成之后

01:12:07.140 --> 01:12:07.860
set timeout

01:12:08.820 --> 01:12:11.540
我等一秒钟之后

01:12:11.540 --> 01:12:12.340
干嘛呢

01:12:12.340 --> 01:12:13.620
我这一次渲染完成之后

01:12:13.620 --> 01:12:15.220
我要把它的数字减1

01:12:16.740 --> 01:12:17.460
我要set

01:12:19.460 --> 01:12:21.860
把当前这一次渲染完成的n

01:12:21.860 --> 01:12:23.620
减1重新设置n

01:12:24.900 --> 01:12:26.340
这才是我要做的事情

01:12:26.340 --> 01:12:27.380
我不需要你清理

01:12:28.020 --> 01:12:29.060
不需要清理

01:12:29.060 --> 01:12:30.020
我的一代相是什么

01:12:30.020 --> 01:12:30.660
一代相就是n

01:12:31.780 --> 01:12:32.580
一代相就是n

01:12:33.300 --> 01:12:34.500
这才是正确的做法

01:12:35.460 --> 01:12:36.340
我这里呢

01:12:36.900 --> 01:12:38.340
下面是正确的做法

01:12:38.980 --> 01:12:40.980
就是我这一次渲染完成之后

01:12:40.980 --> 01:12:43.380
我要等一秒钟再重新渲染一次

01:12:43.380 --> 01:12:45.460
就是这一次渲染的n-1

01:12:45.460 --> 01:12:45.700
对吧

01:12:45.700 --> 01:12:47.300
这才是符合逻辑的

01:12:47.300 --> 01:12:47.940
大家注释嘛

01:12:50.020 --> 01:12:52.340
某一次渲染完成后

01:12:54.850 --> 01:12:56.690
需要改变

01:12:57.730 --> 01:12:59.330
需要根据当前

01:12:59.970 --> 01:13:01.250
就这一次什么要当前n

01:13:01.250 --> 01:13:02.530
就这一次渲染的n

01:13:03.170 --> 01:13:04.210
当前n的值

01:13:05.410 --> 01:13:07.650
重新一秒钟之后

01:13:08.930 --> 01:13:11.330
秒后重新渲染

01:13:12.050 --> 01:13:12.930
重新渲染

01:13:12.930 --> 01:13:14.050
那么下一次渲染过后

01:13:14.050 --> 01:13:15.010
是不是又要重新渲染

01:13:15.010 --> 01:13:15.410
对吧

01:13:15.410 --> 01:13:15.970
这样子呢

01:13:15.970 --> 01:13:16.850
来完成这样的效果

01:13:17.410 --> 01:13:18.610
当然有什么时候停止呢

01:13:19.170 --> 01:13:20.050
判断一下

01:13:20.050 --> 01:13:22.690
如果说n等于了

01:13:22.690 --> 01:13:23.810
这一次渲染过后

01:13:23.810 --> 01:13:24.850
n等于0了

01:13:24.850 --> 01:13:26.610
你还要重新去渲染吗

01:13:26.610 --> 01:13:27.410
就不要渲染了

01:13:28.450 --> 01:13:28.850
返回

01:13:29.730 --> 01:13:30.050
停止

01:13:30.450 --> 01:13:31.090
不要渲染了

01:13:32.050 --> 01:13:32.290
好

01:13:32.290 --> 01:13:33.010
保存你看一下

01:13:34.130 --> 01:13:35.810
198

01:13:35.810 --> 01:13:36.610
现在是没问题的

01:13:36.610 --> 01:13:36.850
对吧

01:13:38.290 --> 01:13:39.570
这倒计时期是不是没问题的

01:13:41.900 --> 01:13:42.380
看一下

01:13:44.380 --> 01:13:45.180
是没问题的

01:13:45.180 --> 01:13:45.660
对吧

01:13:45.660 --> 01:13:46.300
它就没问题的

01:13:46.940 --> 01:13:47.500
这里说一下

01:13:47.500 --> 01:13:49.180
这里是可以返回ND范的

01:13:49.180 --> 01:13:50.460
说本来说是可以

01:13:50.460 --> 01:13:51.260
要返回一个

01:13:51.260 --> 01:13:52.140
清理函数的

01:13:52.140 --> 01:13:53.260
但是它可以返回ND范

01:13:53.260 --> 01:13:54.300
它就不是一个函数

01:13:54.300 --> 01:13:55.180
它就不做任何事情

01:13:56.860 --> 01:13:57.260
好

01:13:57.260 --> 01:13:58.620
就这一块学习了之后

01:13:58.620 --> 01:14:00.460
大家要有这么一个理念

01:14:01.020 --> 01:14:02.700
就说这个use effect

01:14:02.700 --> 01:14:04.540
它就是做副作用操作

01:14:04.540 --> 01:14:05.580
就渲染之后

01:14:05.580 --> 01:14:08.220
它到底有哪些事情可能会做

01:14:08.380 --> 01:14:09.820
可能会去操作

01:14:09.820 --> 01:14:12.380
那么你使用这个use effect

01:14:12.380 --> 01:14:13.180
使用这个玩意

01:14:14.540 --> 01:14:15.100
明白的意思吧

01:14:15.820 --> 01:14:16.460
那包括什么

01:14:16.460 --> 01:14:17.340
阿加斯请求

01:14:17.340 --> 01:14:17.820
那些东西

01:14:17.820 --> 01:14:18.940
是不是都可以在这里面说

01:14:20.940 --> 01:14:23.420
这是关于这个use effect

01:14:23.420 --> 01:14:23.980
另外呢

01:14:23.980 --> 01:14:25.020
我最后再说一个点

01:14:25.020 --> 01:14:25.500
注意一下

01:14:25.500 --> 01:14:26.140
这个注意一下

01:14:27.180 --> 01:14:28.460
真的不是一般人的话

01:14:28.460 --> 01:14:30.060
根本不会这样去做的

01:14:31.020 --> 01:14:32.380
一般人根本不会去这样做

01:14:32.380 --> 01:14:32.860
这样去做

01:14:33.420 --> 01:14:34.060
我主要是

01:14:35.340 --> 01:14:36.140
讲给了一些

01:14:36.140 --> 01:14:38.300
就是思维特别特别惊奇的人

01:14:39.580 --> 01:14:40.460
思维

01:14:40.460 --> 01:14:41.740
你想得更远

01:14:41.740 --> 01:14:42.300
更细

01:14:42.300 --> 01:14:43.100
更乖的话

01:14:43.100 --> 01:14:44.300
当然你对你

01:14:44.300 --> 01:14:46.460
让你对技术的理解是有帮助的

01:14:47.020 --> 01:14:47.580
不过这点

01:14:47.580 --> 01:14:48.540
大家要注意一下

01:14:48.540 --> 01:14:49.340
就是什么呢

01:14:49.340 --> 01:14:51.340
就是说如果副作用函数

01:14:52.140 --> 01:14:53.180
副作用函数

01:14:54.300 --> 01:14:56.540
在每一次注册时

01:14:57.900 --> 01:15:01.980
会覆盖掉之前的副作用函数

01:15:03.020 --> 01:15:04.700
会覆盖掉之前的副作用函数

01:15:04.700 --> 01:15:05.260
就这个点

01:15:05.340 --> 01:15:07.020
平时我们根本就不会遇到这种情况

01:15:07.580 --> 01:15:07.980
就是说

01:15:08.860 --> 01:15:10.380
我们除非自己刻意

01:15:10.380 --> 01:15:10.860
否则的话

01:15:10.860 --> 01:15:11.820
不会遇到这种情况

01:15:13.020 --> 01:15:13.500
因此

01:15:15.020 --> 01:15:18.620
尽量保持副作用函数

01:15:20.460 --> 01:15:22.300
就是稳定

01:15:22.300 --> 01:15:24.300
就是你给他的副作用函数是稳定的

01:15:25.020 --> 01:15:26.380
就是什么意思呢

01:15:26.380 --> 01:15:26.940
举个例子

01:15:28.540 --> 01:15:28.940
否则

01:15:29.820 --> 01:15:30.220
否则

01:15:31.260 --> 01:15:32.140
控制起来

01:15:32.700 --> 01:15:34.140
会比较复杂

01:15:35.820 --> 01:15:36.140
好

01:15:36.140 --> 01:15:36.780
给大家说一下

01:15:36.780 --> 01:15:38.060
就是说什么情况了

01:15:40.420 --> 01:15:41.140
就这种情况

01:15:43.140 --> 01:15:44.260
我们这里这样吧

01:15:46.880 --> 01:15:47.280
这样子

01:15:48.000 --> 01:15:49.280
哪一个强制刷新

01:15:50.000 --> 01:15:50.400
force

01:15:51.680 --> 01:15:52.160
update

01:15:53.760 --> 01:15:54.240
update

01:15:54.800 --> 01:15:55.680
哪个强制刷新

01:15:56.960 --> 01:15:58.000
这里点击过后

01:15:58.000 --> 01:15:58.880
就是强制刷新

01:16:00.000 --> 01:16:00.720
是刷新

01:16:02.080 --> 01:16:03.520
强制刷新

01:16:03.520 --> 01:16:05.840
我们设置force

01:16:07.360 --> 01:16:07.920
update

01:16:10.290 --> 01:16:11.010
给大家新对象

01:16:11.730 --> 01:16:12.930
让他来强制刷新

01:16:14.770 --> 01:16:15.410
这里面

01:16:16.050 --> 01:16:17.890
我给大家写个副作用函数

01:16:20.000 --> 01:16:20.960
写个副作用函数

01:16:22.000 --> 01:16:23.360
这个副作用函数

01:16:23.360 --> 01:16:25.360
它不是像我们现在这样子写的

01:16:25.360 --> 01:16:27.280
它是给它一个传递的函数进来

01:16:27.280 --> 01:16:27.760
可不可以

01:16:27.760 --> 01:16:28.640
当然可以

01:16:28.640 --> 01:16:29.760
然后前面有两个函数

01:16:30.960 --> 01:16:31.840
一个函数是

01:16:34.480 --> 01:16:35.040
funk1

01:16:36.000 --> 01:16:37.360
一个副作用函数是funk1

01:16:38.080 --> 01:16:39.040
那么这个函数是这样子

01:16:41.300 --> 01:16:41.700
输出

01:16:42.500 --> 01:16:44.420
副作用函数1

01:16:45.380 --> 01:16:46.020
函数1

01:16:47.300 --> 01:16:47.860
或者叫做

01:16:49.060 --> 01:16:49.380
这样吧

01:16:49.380 --> 01:16:50.100
我们订个辩量

01:16:50.900 --> 01:16:51.460
订个辩量

01:16:52.260 --> 01:16:53.300
netn等于1

01:16:53.700 --> 01:16:54.660
letn等于1

01:16:55.460 --> 01:16:57.940
副作用函数1

01:16:58.900 --> 01:17:00.340
副作用函数1

01:17:01.620 --> 01:17:01.940
这里

01:17:02.900 --> 01:17:04.340
拼接一下n嘛

01:17:04.660 --> 01:17:05.380
拼接一下n

01:17:06.420 --> 01:17:06.980
没问题吧

01:17:07.620 --> 01:17:08.980
或者说不要整太复杂了

01:17:09.940 --> 01:17:11.220
表示n是极数

01:17:11.860 --> 01:17:12.500
n是极数

01:17:13.540 --> 01:17:15.940
funk1表示n是极数的时候执行

01:17:16.420 --> 01:17:17.140
副作用函数

01:17:17.940 --> 01:17:19.060
反回来是一个什么

01:17:19.060 --> 01:17:19.860
清理函数

01:17:20.740 --> 01:17:21.940
清理函数的话

01:17:21.940 --> 01:17:22.660
我们输出

01:17:23.940 --> 01:17:24.820
out

01:17:24.820 --> 01:17:26.020
这是清理函数

01:17:26.740 --> 01:17:29.220
也说n等于极数的时候

01:17:29.220 --> 01:17:31.060
我们使用这个函数作为副作用函数

01:17:31.700 --> 01:17:32.580
下面再写一个

01:17:34.580 --> 01:17:35.220
funk2

01:17:36.340 --> 01:17:36.980
1分

01:17:36.980 --> 01:17:38.900
就是它等于偶数的时候

01:17:38.900 --> 01:17:40.740
我们使用这个函数作为副作用函数

01:17:41.940 --> 01:17:42.500
好 接下来

01:17:42.980 --> 01:17:44.020
有意思的地方就来了

01:17:44.500 --> 01:17:46.020
这个use而fact

01:17:46.260 --> 01:17:46.820
这里面

01:17:46.820 --> 01:17:48.820
我们给它的函数是这样子写的

01:17:51.380 --> 01:17:52.420
每一次渲染的时候

01:17:52.420 --> 01:17:53.860
每一次渲染是n加加吗

01:17:53.860 --> 01:17:54.500
n加加

01:17:56.260 --> 01:17:57.060
在下面n加加

01:17:57.860 --> 01:17:58.900
在上面注册的时候

01:17:58.900 --> 01:17:59.620
我们这样子写

01:18:00.340 --> 01:18:01.780
n的值除1

01:18:01.780 --> 01:18:03.060
2是等于0

01:18:03.860 --> 01:18:04.660
如果等于0的话

01:18:04.660 --> 01:18:05.300
它是偶数

01:18:05.300 --> 01:18:06.580
我们给它传递funk2

01:18:07.380 --> 01:18:07.860
否则的话

01:18:07.860 --> 01:18:08.980
给它传递funk1

01:18:10.500 --> 01:18:10.900
你说

01:18:12.020 --> 01:18:15.140
这得多钻牛角尖

01:18:15.140 --> 01:18:16.420
才能去写出这样的代码

01:18:17.380 --> 01:18:18.740
你在函数里边判断不行了

01:18:18.740 --> 01:18:20.340
你不要用这种方式来写

01:18:21.220 --> 01:18:22.900
给它的函数是不是不稳定的

01:18:22.900 --> 01:18:23.140
现在

01:18:23.940 --> 01:18:25.860
给它的副作用函数不是不稳定的

01:18:26.500 --> 01:18:27.620
也有可能给它这个函数

01:18:27.620 --> 01:18:28.820
也可能给它这个函数

01:18:28.820 --> 01:18:30.340
那么会导致一个什么样的结果呢

01:18:31.940 --> 01:18:32.740
看着

01:18:32.740 --> 01:18:34.020
一开始的调整是什么

01:18:34.020 --> 01:18:35.620
order副作用函数

01:18:35.620 --> 01:18:36.420
为什么

01:18:36.420 --> 01:18:38.260
为什么调整是order副作用函数

01:18:38.260 --> 01:18:39.300
因为一开始的时候

01:18:39.300 --> 01:18:40.420
运行到这句代码的时候

01:18:40.420 --> 01:18:41.300
n值是多少

01:18:41.380 --> 01:18:42.500
n的值是不是1

01:18:42.500 --> 01:18:42.900
对吧

01:18:42.900 --> 01:18:44.180
最开始的时候是1

01:18:44.180 --> 01:18:44.900
那么1呢

01:18:45.460 --> 01:18:46.180
它是几数

01:18:46.180 --> 01:18:47.620
所以说它给它的是funk1

01:18:48.180 --> 01:18:49.540
给它的是这个函数

01:18:49.540 --> 01:18:50.580
拿到这个函数过后

01:18:50.580 --> 01:18:51.460
原来是会记录

01:18:52.420 --> 01:18:53.220
还会记录

01:18:53.220 --> 01:18:54.420
记录的是什么呢

01:18:54.420 --> 01:18:56.180
副作用函数

01:18:57.700 --> 01:18:58.340
是什么

01:18:58.340 --> 01:18:59.060
是funk1

01:19:00.420 --> 01:19:00.740
那么

01:19:01.460 --> 01:19:02.580
这是第一次调用对吧

01:19:03.540 --> 01:19:04.020
好

01:19:04.020 --> 01:19:05.220
那么现在呢

01:19:05.220 --> 01:19:06.660
开始渲染那个页面

01:19:06.660 --> 01:19:07.780
渲染了n加加

01:19:07.780 --> 01:19:08.340
n加加

01:19:08.340 --> 01:19:09.060
现在n变成了

01:19:09.780 --> 01:19:10.340
一开始呢

01:19:10.420 --> 01:19:11.540
n是等于1

01:19:11.540 --> 01:19:11.940
对吧

01:19:11.940 --> 01:19:12.900
n等于1的时候呢

01:19:12.900 --> 01:19:14.340
副作用函数是funk1

01:19:14.340 --> 01:19:14.740
对吧

01:19:14.740 --> 01:19:15.700
击数了一块

01:19:15.700 --> 01:19:16.340
这个没问题吧

01:19:16.820 --> 01:19:17.060
好

01:19:17.060 --> 01:19:18.420
那么它会记录下来

01:19:18.420 --> 01:19:18.900
然后呢

01:19:18.900 --> 01:19:19.540
等渲染

01:19:19.540 --> 01:19:20.180
渲染完成

01:19:20.180 --> 01:19:21.700
那么现在n变成2了

01:19:21.700 --> 01:19:22.660
然后渲染完成

01:19:22.660 --> 01:19:23.700
渲染完成之后

01:19:24.980 --> 01:19:25.700
是不是要

01:19:25.700 --> 01:19:26.980
调用这个副作用函数

01:19:27.940 --> 01:19:28.260
对吧

01:19:28.260 --> 01:19:29.540
要调用这个副作用函数

01:19:29.540 --> 01:19:30.020
于是呢

01:19:30.020 --> 01:19:31.060
它输出了啥

01:19:31.060 --> 01:19:32.740
输出了order副作用函数

01:19:33.540 --> 01:19:35.300
而调用完成之后

01:19:35.300 --> 01:19:36.020
调完成之后

01:19:36.020 --> 01:19:37.300
它是不是会运行一个这个

01:19:37.300 --> 01:19:37.940
得到一个结果

01:19:37.940 --> 01:19:38.660
好

01:19:38.660 --> 01:19:39.220
那么

01:19:39.220 --> 01:19:40.260
它调用完成之后呢

01:19:40.260 --> 01:19:41.620
它会得到一个轻力函数

01:19:43.060 --> 01:19:44.020
轻力函数

01:19:44.020 --> 01:19:44.580
什么

01:19:44.580 --> 01:19:46.740
就是funk1

01:19:46.740 --> 01:19:48.580
funk1的轻力

01:19:48.980 --> 01:19:49.780
轻力函数

01:19:50.740 --> 01:19:52.020
funk1反会的轻力函数

01:19:52.020 --> 01:19:52.820
它会得到这个

01:19:54.180 --> 01:19:54.500
好

01:19:54.500 --> 01:19:55.460
接下来它等待

01:19:55.460 --> 01:19:56.340
下一次渲染

01:19:56.980 --> 01:19:57.460
好

01:19:57.460 --> 01:19:58.260
比方说我们点了

01:19:58.260 --> 01:19:59.460
强制刷新过后

01:20:00.420 --> 01:20:01.700
它怎么会出现这种情况呢

01:20:01.700 --> 01:20:02.740
你看着啊

01:20:02.740 --> 01:20:04.340
强制刷新过后呢

01:20:04.340 --> 01:20:05.140
它现在干嘛

01:20:05.140 --> 01:20:06.740
是不是要重新运行这个函数

01:20:07.700 --> 01:20:09.540
重新运行这个函数

01:20:09.620 --> 01:20:11.220
那么是不是又运行到这句话

01:20:11.220 --> 01:20:14.100
这句话之前把n金加到一大变成变成二了

01:20:14.100 --> 01:20:14.500
好

01:20:14.500 --> 01:20:16.260
那么现在是不是给它的是funk2

01:20:16.260 --> 01:20:16.580
对吧

01:20:16.580 --> 01:20:17.620
副作用函数是funk2

01:20:18.820 --> 01:20:19.220
好

01:20:19.220 --> 01:20:19.940
然后呢

01:20:19.940 --> 01:20:22.180
又运行什么n加加对吧

01:20:22.180 --> 01:20:22.980
n又变成什么

01:20:22.980 --> 01:20:24.020
n变成3了

01:20:24.020 --> 01:20:25.060
然后开始渲染

01:20:25.060 --> 01:20:26.260
渲染完成之后

01:20:27.220 --> 01:20:28.100
然后开始运行

01:20:28.740 --> 01:20:30.420
之前得到了轻力函数

01:20:31.300 --> 01:20:33.460
那是不是运行的funk1的轻力函数之前的

01:20:34.740 --> 01:20:35.860
之前的funk1的轻力函数

01:20:35.860 --> 01:20:37.300
是不是order轻力函数

01:20:38.020 --> 01:20:38.260
好

01:20:38.260 --> 01:20:39.380
这样子运行过后

01:20:39.460 --> 01:20:40.340
再运行什么

01:20:40.340 --> 01:20:41.060
副作用函数

01:20:41.060 --> 01:20:41.860
funk2

01:20:41.860 --> 01:20:44.980
于是得到1分副作用函数

01:20:44.980 --> 01:20:45.140
好

01:20:45.140 --> 01:20:46.100
运行到之后呢

01:20:46.100 --> 01:20:47.780
下面又把这个轻力函数

01:20:47.780 --> 01:20:49.140
它反回一个结果嘛

01:20:49.140 --> 01:20:50.500
因此把它把轻力函数变成了

01:20:50.500 --> 01:20:51.540
funk2的轻力函数

01:20:53.140 --> 01:20:53.380
好

01:20:53.380 --> 01:20:54.260
那么再一下子

01:20:54.260 --> 01:20:55.380
下一次运行应该是什么

01:20:56.660 --> 01:20:57.540
运行是什么

01:20:57.540 --> 01:20:59.220
是不是先运行它的轻力函数

01:20:59.700 --> 01:21:00.100
对吧

01:21:01.540 --> 01:21:03.940
再运行funk1的轻力函数

01:21:03.940 --> 01:21:04.580
副作用函数

01:21:05.220 --> 01:21:05.700
总之呢

01:21:05.700 --> 01:21:06.980
它会比较怪异

01:21:06.980 --> 01:21:08.340
它按照这样的流程走的

01:21:09.060 --> 01:21:10.740
比较好预期它的结果

01:21:10.740 --> 01:21:12.180
当然你搞心中原力的话

01:21:12.180 --> 01:21:13.780
也容易分析出来

01:21:13.780 --> 01:21:15.060
只不过不要这样去写

01:21:15.060 --> 01:21:16.260
何必呢

01:21:16.260 --> 01:21:17.940
你是跟自己过不去了

01:21:17.940 --> 01:21:18.900
还是跟老师过不去了

01:21:18.900 --> 01:21:20.340
还是跟公司过不去了

01:21:20.340 --> 01:21:22.500
不要去这么去折磨自己

01:21:22.500 --> 01:21:23.220
不要这样做

01:21:23.220 --> 01:21:25.460
应该尽量的保持副作用函数稳定

01:21:25.460 --> 01:21:26.580
不要以后给它这个函数

01:21:26.580 --> 01:21:27.620
以后给它另一个函数

01:21:28.340 --> 01:21:28.660
好吧

01:21:29.460 --> 01:21:30.340
OK

01:21:30.340 --> 01:21:31.220
那么这一部分

01:21:31.220 --> 01:21:33.380
就是咱们的副作用这一块讲的东西

01:21:34.260 --> 01:21:34.900
没了

01:21:34.900 --> 01:21:35.140
没了

01:21:35.940 --> 01:21:39.140
下节课咱们还是做个练习吧

01:21:40.100 --> 01:21:41.300
做个练习

01:21:41.300 --> 01:21:43.140
就做一个学生列表

01:21:44.180 --> 01:21:45.860
分验显示学生的练习

01:21:45.860 --> 01:21:46.900
全部用函数组件

01:21:46.900 --> 01:21:48.100
因为现在我们用互可了

01:21:48.100 --> 01:21:49.540
全部用函数组件来做

01:21:49.540 --> 01:21:51.140
下节课咱们做练习

01:21:51.140 --> 01:21:52.340
下来把这个知识过一遍

01:21:52.340 --> 01:21:53.780
这里的知识点还是蛮多的

