WEBVTT

00:00.880 --> 00:03.880
好了啊 终于到迪瓦了

00:04.880 --> 00:06.880
哎呀 我真的冲到一口气了

00:06.880 --> 00:10.880
你说之前咱们学了多少东西了 特别特别多吧

00:10.880 --> 00:13.880
特别是约达克斯那一块 我们用了很多很多的时间

00:13.880 --> 00:16.880
而且那一块也比较绕 也比较复杂

00:16.880 --> 00:19.880
约达克斯那一块呢 我们花了很多的精力学习

00:19.880 --> 00:22.880
那么学校一大堆东西 用起来呢

00:22.880 --> 00:25.880
你能够理解它的好处 好处呢 我也反复强调了

00:25.880 --> 00:29.880
它为什么要去这样做 它也是 它有它的良苦用心

00:29.880 --> 00:33.880
但是呢 我们毕竟是要做开发 要去写带嘛

00:33.880 --> 00:37.880
写起来麻不麻烦啊 是不是 特别特别麻烦

00:37.880 --> 00:40.880
一会呢 要写个IgSync 又要写IgSync创建函数啊

00:40.880 --> 00:43.880
它的类型呢 我们还可能要单独做一个文件

00:43.880 --> 00:46.880
还有Reducer又是一块 还有昌贵又是一块

00:46.880 --> 00:50.880
又会有这个中间键 那个中间键 特别特别麻烦

00:50.880 --> 00:55.880
那么能不能有一个第三方库来帮我们去整合这些东西呢

00:56.880 --> 00:59.880
当然了 这个整合这件事啊

00:59.880 --> 01:03.880
我还是我以前说的 那么就看你去怎么去想

01:03.880 --> 01:06.880
因为Reducer它的那一套东西的话

01:06.880 --> 01:09.880
他们都比较遵循一个哲学思想

01:09.880 --> 01:11.880
就是说 我尽量的保守一点

01:11.880 --> 01:15.880
在没有形成 在这个行业没有形成最佳实践之前

01:15.880 --> 01:18.880
大家一个公司这样子用 一个公司那样子用

01:18.880 --> 01:22.880
为了更加的灵活 我尽量的 不要去做过多的干涉

01:22.880 --> 01:26.880
所以说Reducer它自身宣扬的 它不是一个框架

01:26.880 --> 01:28.880
框架是什么 框架它就有干涉

01:28.880 --> 01:30.880
它对你有强制性的约束和要求

01:30.880 --> 01:32.880
你必须要怎么去携带吧

01:32.880 --> 01:33.880
而不应该怎么去携带吧

01:33.880 --> 01:36.880
当然了 框架学习的简单啊 用起来比较简单

01:36.880 --> 01:39.880
就是因为它给你约定好了很多东西

01:39.880 --> 01:41.880
但是Reducer那一套东西呢

01:41.880 --> 01:43.880
它为了更加的灵活

01:43.880 --> 01:45.880
所以说它没有做过多的约定

01:45.880 --> 01:47.880
你可以这样子用 你可以那样子用

01:47.880 --> 01:49.880
所以说大家学Reducer就会感觉到

01:49.880 --> 01:53.880
它非常非常灵活 但是用起来就没有那么方便了

01:53.880 --> 01:55.880
那么现在呢 其实有一些公司呢

01:55.880 --> 02:00.880
就已经在思考我能不能把Reducer全家统来进行整合

02:00.880 --> 02:02.880
整合出一种方案出来

02:02.880 --> 02:04.880
大家都用这种方案来做

02:04.880 --> 02:06.880
当然这件事情是比较激进的

02:06.880 --> 02:09.880
也不太符合Reducer它的核心理念

02:09.880 --> 02:11.880
但是这件事情早晚得做

02:11.880 --> 02:14.880
因为一个行业早晚得形成一种最佳时间

02:14.880 --> 02:17.880
一定要形成一种框架早晚的事情

02:17.880 --> 02:20.880
有些公司呢 开始来尝试来去做这件事情

02:20.880 --> 02:23.880
其中一家公司呢 就是大名鼎鼎的阿里巴巴

02:23.880 --> 02:26.880
阿里巴巴呢 后来就出来了一种第三方库

02:26.880 --> 02:27.880
叫做Diva

02:27.880 --> 02:29.880
那么Diva呢 它就是一个框架

02:29.880 --> 02:31.880
它不仅仅是

02:31.880 --> 02:34.880
不仅仅是一个第三方库

02:34.880 --> 02:36.880
当然它本质上就是一个第三方库

02:36.880 --> 02:38.880
放到NPM上面的

02:40.880 --> 02:42.880
更是一个框架

02:42.880 --> 02:44.880
因为它只有强制约束力

02:44.880 --> 02:46.880
它约束力的代码应该怎么去写

02:46.880 --> 02:48.880
而不应该怎么去写

02:48.880 --> 02:50.880
它整合了

02:50.880 --> 02:52.880
它整合了

02:52.880 --> 02:54.880
应该说它主要整合了

02:54.880 --> 02:59.880
就是Reducer的相关内容

02:59.880 --> 03:00.880
相关内容

03:00.880 --> 03:02.880
让我们就是

03:02.880 --> 03:04.880
处理数据

03:04.880 --> 03:06.880
更加容易

03:06.880 --> 03:08.880
其实它不仅仅整合了Reducer

03:08.880 --> 03:09.880
还整合了 还没有

03:09.880 --> 03:12.880
就是Rotor一些东西都进行了一些整合

03:12.880 --> 03:15.880
那么它依赖了很多东西

03:15.880 --> 03:19.880
实际上Diva依赖了很多

03:19.880 --> 03:21.880
有哪些呢 比方说Reducer依赖

03:21.880 --> 03:23.880
Reducer Rotor

03:23.880 --> 03:25.880
Reducer Rotor

03:25.880 --> 03:27.880
我们学过了 它也依赖

03:27.880 --> 03:29.880
还依赖什么Reducer

03:29.880 --> 03:30.880
还依赖Reducer Saga

03:30.880 --> 03:34.880
它的数据处理方案就是对Saga的进一步封装

03:34.880 --> 03:35.880
Saga好不好用呢

03:35.880 --> 03:36.880
Saga我觉得挺好用的

03:36.880 --> 03:38.880
但是很多同学可能用起来比较

03:38.880 --> 03:39.880
比较恶心一点

03:39.880 --> 03:41.880
但是经过Diva封装了之后

03:41.880 --> 03:44.880
我们之后用起来就非常非常简单了

03:44.880 --> 03:46.880
说哪怕你前面学的刻刻办办的

03:46.880 --> 03:48.880
当然前面学好就是更好

03:48.880 --> 03:51.880
如果说前面学的有些地方感觉还是很模糊

03:51.880 --> 03:53.880
那么学到Diva之后一下就清晰了

03:53.880 --> 03:56.880
你至少用起来就非常非常舒服了

03:56.880 --> 03:58.880
它用到了Reducer Saga

03:58.880 --> 03:59.880
还用到了什么呢

03:59.880 --> 04:03.880
还用到了我们后来学的就是Reducer Rotor

04:03.880 --> 04:05.880
还用到了 还依赖了什么呢

04:05.880 --> 04:11.880
还依赖了我们刚刚学过的Connected Rotor

04:11.880 --> 04:13.880
它就依赖了这么一些酷 这些酷

04:13.880 --> 04:15.880
那么它把这些酷进行了整合

04:15.880 --> 04:17.880
使我们用这些酷的时候

04:17.880 --> 04:21.880
就不用去像他们原来的那种方式来应用了

04:21.880 --> 04:23.880
就特别特别麻烦

04:23.880 --> 04:25.880
因此它整合了过后提供了一种方案

04:25.880 --> 04:27.880
按照它那种方案来做的话

04:27.880 --> 04:29.880
就会变得非常非常简单

04:29.880 --> 04:31.880
我们以后就会看到了

04:31.880 --> 04:33.880
Diva它是阿里巴巴出品的一个第三方酷

04:33.880 --> 04:36.880
它就是宣扬的就是要做一个框架出来

04:36.880 --> 04:39.880
实际上Diva它当时的野心还很大

04:39.880 --> 04:42.880
后来它做了一个脚手架

04:42.880 --> 04:46.880
就是你都不用Create React App

04:46.880 --> 04:48.880
对吧 我最开始用了个脚手架

04:48.880 --> 04:49.880
搭建工程了

04:49.880 --> 04:52.880
你直接使用Diva那个脚手架来搭建工程

04:52.880 --> 04:54.880
但是后来那个脚手架被欺拥了

04:54.880 --> 04:56.880
因为他们做了一个更好的脚手架出来

04:56.880 --> 04:59.880
就是我们后边学习的5米解释

04:59.880 --> 05:01.880
现在很多公司已经开始用这个脚手架了

05:01.880 --> 05:03.880
特别特别好用

05:03.880 --> 05:07.880
所以说Diva它自身的脚手架已经不再使用了

05:07.880 --> 05:08.880
我们后边用脚手架的话

05:08.880 --> 05:10.880
都是用的是5米解释

05:10.880 --> 05:12.880
但是你要学习5米解释

05:12.880 --> 05:14.880
你就必须要先学习Diva

05:14.880 --> 05:17.880
因为5米解释它的脚手架里边搭建的东西

05:17.880 --> 05:19.880
它一个很重要的模块就是Diva

05:19.880 --> 05:21.880
你得把先把Diva学会

05:21.880 --> 05:24.880
Diva学会了过后你才能理解5米解释它是怎么回事

05:24.880 --> 05:28.880
我们后面会专门来开章节来学习5米解释

05:28.880 --> 05:31.880
Diva这个东西它本身非常非常简单

05:31.880 --> 05:32.880
也非常非常轻量

05:32.880 --> 05:35.880
最早的时候它单码一共就100多行

05:35.880 --> 05:37.880
当然现在肯定不止100多行

05:37.880 --> 05:39.880
现在应该有一两千行

05:39.880 --> 05:41.880
大概算了一下有一两千行

05:41.880 --> 05:43.880
现在的单码很多了

05:43.880 --> 05:45.880
但是最开始的单码很少很少

05:45.880 --> 05:47.880
它要解决的问题其实非常简单

05:47.880 --> 05:50.880
就是要解决瑞拉克斯的数据操作

05:50.880 --> 05:51.880
特别繁硕的问题

05:51.880 --> 05:54.880
包括我们的路由要往常库里边放

05:54.880 --> 05:55.880
对吧

05:55.880 --> 05:57.880
这些繁硕的工作

05:57.880 --> 06:00.880
Diva它都可以给你做一个一暂时的整合

06:00.880 --> 06:04.880
我们一会学到过后你就特别特别清楚了

06:04.880 --> 06:06.880
然后再多说一句

06:06.880 --> 06:08.880
它为什么叫Diva这个名字呢

06:08.880 --> 06:10.880
我们来看一下它的官方网站

06:10.880 --> 06:12.880
看一下它的官方网站

06:12.880 --> 06:14.880
这里有个指南

06:14.880 --> 06:16.880
这个指南里边他给你说的

06:16.880 --> 06:19.880
为什么秘密由来为什么叫Diva

06:19.880 --> 06:20.880
就跟大家想的一样

06:20.880 --> 06:23.880
就是来自于这个游戏守望先锋

06:23.880 --> 06:24.880
里边有一个Diva

06:24.880 --> 06:26.880
它为什么要用守望先锋的名字

06:26.880 --> 06:27.880
我也不知道

06:27.880 --> 06:28.880
你去问他们

06:28.880 --> 06:30.880
估计那个开发者

06:30.880 --> 06:32.880
开发这个框架的人

06:32.880 --> 06:34.880
可能是一个暴雪的游戏迷

06:35.880 --> 06:39.880
这个游戏现在好像也不太有人玩了

06:40.880 --> 06:43.880
然后这就是Diva名字由来

06:43.880 --> 06:45.880
稍微做了一下介绍

06:45.880 --> 06:48.880
那么接下来我们就开始来使用这个Diva

06:48.880 --> 06:51.880
我们这种工程我是直接从Master

06:51.880 --> 06:54.880
就是从主分支里面导出的

06:54.880 --> 06:56.880
主分支里面开的一个新分支

06:56.880 --> 06:59.880
因此我们这里边没有路由

06:59.880 --> 07:00.880
就非常纯净的一个状态

07:00.880 --> 07:01.880
没有Ridax

07:01.880 --> 07:02.880
没有路由

07:02.880 --> 07:03.880
啥都没有

07:03.880 --> 07:04.880
就按了一个Ridax

07:04.880 --> 07:05.880
其他啥都没有

07:05.880 --> 07:06.880
就特别特别纯净

07:06.880 --> 07:08.880
因这个这里边就现在什么

07:08.880 --> 07:09.880
渲染根主键

07:09.880 --> 07:11.880
然后根主键里边啥都没有

07:11.880 --> 07:13.880
就非常非常纯净的一个工程

07:13.880 --> 07:15.880
那么接下来我们直接安装Diva

07:15.880 --> 07:17.880
因为它是一个一战式解决方案

07:17.880 --> 07:19.880
所以说我们这里

07:19.880 --> 07:21.880
根本就不需要安装其他的第三方库

07:21.880 --> 07:23.880
我们直接安装Diva就行了

07:25.880 --> 07:26.880
直接安装这个玩意就行了

07:26.880 --> 07:27.880
其他都不用安装

07:27.880 --> 07:28.880
不用安装

07:29.880 --> 07:30.880
让它安装吧

07:31.880 --> 07:32.880
那么这个Diva安装过后

07:32.880 --> 07:34.880
我们就即可以使用什么

07:34.880 --> 07:35.880
Rotor

07:35.880 --> 07:36.880
那些乱七八糟的功能都可以使用了

07:36.880 --> 07:37.880
都可以使用了

07:37.880 --> 07:39.880
包括什么Ridax的功能全部可以使用了

07:39.880 --> 07:40.880
因为它都依赖

07:40.880 --> 07:41.880
依赖这些东西

07:41.880 --> 07:42.880
你安装Diva的时候

07:42.880 --> 07:45.880
实际上你就安装了所有东西了

07:45.880 --> 07:46.880
好了

07:46.880 --> 07:47.880
它怎么用呢

07:47.880 --> 07:48.880
它怎么用呢

07:48.880 --> 07:49.880
首先到英这个手里边来

07:49.880 --> 07:51.880
我们找到我们的入口文件

07:51.880 --> 07:53.880
不再是我们的根主键了

07:53.880 --> 07:54.880
找到入口文件

07:54.880 --> 07:57.880
这个入口文件里边

07:57.880 --> 07:58.880
我们来做文章

07:58.880 --> 07:59.880
在这里边写代码

07:59.880 --> 08:01.880
这里边怎么写代码呢

08:01.880 --> 08:04.880
首先你要导入这么一个东西

08:04.880 --> 08:05.880
我们以后会做笔记

08:05.880 --> 08:06.880
其他的API不多

08:06.880 --> 08:08.880
API只有那么一点点

08:08.880 --> 08:09.880
但是它的用法上

08:09.880 --> 08:12.880
跟我们之前的写法有比较大的区别

08:12.880 --> 08:14.880
所以说我这里说一下

08:14.880 --> 08:16.880
以后要记笔记说一下

08:16.880 --> 08:18.880
这里我们先把起动起来

08:18.880 --> 08:19.880
起动起来再说

08:19.880 --> 08:23.830
我们这里出个笔记

08:23.830 --> 08:25.830
首先就Diva的使用

08:27.830 --> 08:29.830
Diva的使用

08:30.830 --> 08:31.830
就第一个

08:32.830 --> 08:33.830
首先Diva这个库

08:33.830 --> 08:35.830
还有一个默认导出

08:35.830 --> 08:37.830
默认导出了什么东西呢

08:37.830 --> 08:39.830
它导出了一个函数

08:40.830 --> 08:42.830
通过该函数

08:42.830 --> 08:44.830
通过雕用该函数

08:44.830 --> 08:47.830
可以得到一个Diva

08:47.830 --> 08:49.830
应用程序对象

08:49.830 --> 08:51.830
我们后续的很多操作

08:51.830 --> 08:53.830
都要使用Diva的

08:53.830 --> 08:54.830
应用程序对象

08:54.830 --> 08:55.830
所以说这个程序对象

08:55.830 --> 08:56.830
你得拿到

08:56.830 --> 08:57.830
什么意思呢

08:57.830 --> 08:59.830
就是说它给导出了一个什么

08:59.830 --> 09:00.830
导出一个函数

09:00.830 --> 09:02.830
默认导出了一个函数

09:02.830 --> 09:03.830
你要干嘛呢

09:03.830 --> 09:05.830
你要去雕用这个函数

09:05.830 --> 09:06.830
它还是可以传议配置

09:06.830 --> 09:08.830
配置我们后边再说

09:08.830 --> 09:10.830
你可以去雕用这个函数

09:10.830 --> 09:11.830
然后呢

09:11.830 --> 09:13.830
它会返回一个什么呢

09:13.830 --> 09:15.830
返回一个应用程序对象

09:15.830 --> 09:17.830
就这句话的意思

09:17.830 --> 09:21.830
这是得到一个Diva对象

09:21.830 --> 09:23.830
我们把它叫做Diva对象

09:23.830 --> 09:25.830
其实就是个Diva应用程序对象

09:25.830 --> 09:27.830
拿到这个对象过干嘛呢

09:27.830 --> 09:28.830
通过这个对象

09:28.830 --> 09:29.830
可以做一些事情

09:29.830 --> 09:31.830
做什么事情呢

09:31.830 --> 09:32.830
我们这里呢

09:32.830 --> 09:33.830
可以通过这个对象

09:33.830 --> 09:35.830
对象里面它提供了一些方法

09:35.830 --> 09:36.830
我们这里说一下

09:36.830 --> 09:39.830
对象里面提供了哪些东西

09:39.830 --> 09:40.830
我们这里

09:40.830 --> 09:42.830
把统一叫做Diva对象

09:42.830 --> 09:45.830
Diva对象也叫做Diva应用程序对象

09:45.830 --> 09:48.830
Diva对象它提供了一个方法

09:48.830 --> 09:49.830
什么方法呢

09:49.830 --> 09:50.830
叫做rotor

09:50.830 --> 09:51.830
rotor什么意思

09:51.830 --> 09:52.830
不是路由吗

09:52.830 --> 09:53.830
对不对

09:53.830 --> 09:54.830
路由

09:54.830 --> 09:56.830
你再配置一下路由

09:56.830 --> 09:57.830
就这么个意思

09:57.830 --> 09:58.830
配置一下路由

09:58.830 --> 09:59.830
就这个方法

09:59.830 --> 10:00.830
这个方法呢

10:00.830 --> 10:01.830
其实你也可以把它理解成

10:01.830 --> 10:03.830
渲染一个根组件

10:03.830 --> 10:04.830
也可以这样去理解

10:04.830 --> 10:06.830
理解成为渲染一个根组件

10:06.830 --> 10:07.830
Diva对象

10:07.830 --> 10:08.830
但是我们一会再说

10:08.830 --> 10:09.830
它什么意思吗

10:09.830 --> 10:11.830
它为什么叫做路由

10:11.830 --> 10:13.830
因为我们先把它的程序运行起来再说

10:13.830 --> 10:14.830
这个东西呢

10:14.830 --> 10:17.830
指的是路由方法

10:17.830 --> 10:19.830
这是个路由方法

10:19.830 --> 10:20.830
传入的是什么呢

10:20.830 --> 10:23.830
传入一个函数

10:23.830 --> 10:27.830
该函数返回一个组件

10:27.830 --> 10:30.830
返回的是一个reactor元素

10:30.830 --> 10:32.830
或者说于reactor节点

10:32.830 --> 10:34.830
返回的是一个reactor节点

10:34.830 --> 10:37.830
那么将来

10:37.830 --> 10:39.830
将来

10:39.830 --> 10:43.830
应用程序启动后

10:43.830 --> 10:46.830
会自动渲染该节点

10:46.830 --> 10:47.830
所以说我们认为

10:47.830 --> 10:48.830
这个函数呢

10:48.830 --> 10:50.830
其实就是用来渲染根节点的

10:50.830 --> 10:51.830
对吧

10:51.830 --> 10:53.830
我们之前的根节点在哪

10:53.830 --> 10:54.830
是不是app

10:54.830 --> 10:55.830
对吧

10:55.830 --> 10:56.830
在app

10:57.830 --> 10:58.830
就使用这个Diva对象

10:58.830 --> 11:00.830
我们不再使用这种方式了

11:00.830 --> 11:01.830
不再使用这种方式了

11:01.830 --> 11:03.830
我们直接使用Diva对象

11:03.830 --> 11:04.830
使用它的什么方法

11:04.830 --> 11:05.830
Rotor

11:05.830 --> 11:08.830
这里边要传一个函数

11:08.830 --> 11:09.830
这个函数返回啥呢

11:09.830 --> 11:12.830
返回的就是一个reactor元素

11:12.830 --> 11:13.830
reactor元素

11:13.830 --> 11:14.830
是不是可以是个支付串

11:14.830 --> 11:15.830
可以是now

11:15.830 --> 11:16.830
可以是任何东西对吧

11:16.830 --> 11:18.830
那么这个元素是什么意思呢

11:18.830 --> 11:20.830
就是说我们当将来

11:20.830 --> 11:21.830
我们应用程序启动之后

11:21.830 --> 11:23.830
你要渲染什么组件

11:23.830 --> 11:24.830
你要渲染什么元素

11:24.830 --> 11:25.830
渲染什么东西

11:25.830 --> 11:27.830
你传递给它

11:27.830 --> 11:28.830
就这么个意思

11:28.830 --> 11:29.830
所以说这个函数返回的是什么呢

11:29.830 --> 11:31.830
比方说我们的根组件是app

11:31.830 --> 11:32.830
对吧

11:32.830 --> 11:33.830
OK

11:33.830 --> 11:34.830
我们就返回这个app

11:34.830 --> 11:35.830
就这么简单

11:35.830 --> 11:37.830
我们直接返回这个app

11:37.830 --> 11:38.830
明白的意思吧

11:40.830 --> 11:41.830
没问题吧

11:41.830 --> 11:42.830
返回这个app

11:42.830 --> 11:43.830
当然了

11:43.830 --> 11:44.830
这里由于是个函数

11:44.830 --> 11:45.830
我们是不是也可以认为

11:45.830 --> 11:46.830
它是一个函数组件

11:46.830 --> 11:47.830
对吧

11:47.830 --> 11:48.830
也可以认为它是个函数组件

11:48.830 --> 11:49.830
那这里

11:49.830 --> 11:50.830
app不就是个函数组件吗

11:50.830 --> 11:51.830
我们甚至呢

11:51.830 --> 11:53.830
可以直接把这个app传进来

11:53.830 --> 11:54.830
app不就是个函数

11:54.830 --> 11:55.830
对不对

11:55.830 --> 11:56.830
app是不是个函数

11:56.830 --> 11:58.830
是不是就是个函数

11:58.830 --> 11:59.830
没问题吧

11:59.830 --> 12:00.830
是不是可以直接传进来

12:00.830 --> 12:01.830
没问题吧

12:01.830 --> 12:02.830
也是一样的

12:02.830 --> 12:03.830
也是一样的

12:03.830 --> 12:04.830
那么调用这个函数

12:04.830 --> 12:06.830
是不是返回一个DIV

12:06.830 --> 12:07.830
对吧

12:07.830 --> 12:08.830
返回一个DIV

12:08.830 --> 12:09.830
没问题吧

12:09.830 --> 12:10.830
OK

12:10.830 --> 12:11.830
那么这种邪法

12:11.830 --> 12:12.830
这种邪法

12:12.830 --> 12:13.830
都差不多

12:13.830 --> 12:14.830
都类似

12:14.830 --> 12:15.830
好

12:15.830 --> 12:16.830
那么这是这个步骤

12:16.830 --> 12:17.830
这个步骤在做什么呢

12:17.830 --> 12:18.830
记住一下

12:18.830 --> 12:21.830
这个步骤是

12:21.830 --> 12:24.830
就是设置跟路由

12:24.830 --> 12:25.830
跟路由

12:25.830 --> 12:28.830
记起动后

12:28.830 --> 12:31.830
要运行的函数

12:31.830 --> 12:33.830
函数的返回结果

12:33.830 --> 12:35.830
会被渲染

12:35.830 --> 12:36.830
但是现在有没有渲染

12:36.830 --> 12:37.830
我们来看一下

12:37.830 --> 12:38.830
现在有没有渲染

12:38.830 --> 12:39.830
我们比较到这里写个

12:39.830 --> 12:40.830
跟组件

12:40.830 --> 12:43.270
我们现在根本

12:43.270 --> 12:45.270
根本就还没用到路由

12:45.270 --> 12:46.270
不着急

12:46.270 --> 12:47.270
保存

12:47.270 --> 12:48.270
我们来看一下有没有渲染

12:48.270 --> 12:49.270
有没有渲染

12:49.270 --> 12:50.270
是不是没有渲染

12:50.270 --> 12:52.270
没有进行任何渲染

12:52.270 --> 12:54.270
这里包了一个警告

12:54.270 --> 12:56.270
这个警告我们之后再说

12:56.270 --> 12:57.270
之后再说

12:57.270 --> 12:58.270
那么现在是不是

12:58.270 --> 12:59.270
没有任何渲染

12:59.270 --> 13:00.270
为什么没有渲染

13:00.270 --> 13:01.270
因为现在应用程序

13:01.270 --> 13:03.270
还没有启动

13:03.270 --> 13:04.270
我们之前是打启动的

13:04.270 --> 13:06.270
之前是不是react

13:06.270 --> 13:07.270
dom

13:07.270 --> 13:08.270
对不对

13:08.270 --> 13:09.270
Render

13:09.270 --> 13:10.270
对不对

13:10.270 --> 13:11.270
但是现在不用了

13:11.270 --> 13:12.270
现在用DIVA的方式来启动

13:12.270 --> 13:13.270
好

13:13.270 --> 13:14.270
怎么启动呢

13:14.270 --> 13:16.270
现在它又提供了一个方法

13:16.270 --> 13:19.270
3

13:19.270 --> 13:21.270
2

13:21.270 --> 13:23.270
DIVA对象里边又提供了一个方法

13:23.270 --> 13:25.270
叫做start

13:25.270 --> 13:27.270
这个方法做什么事情呢

13:27.270 --> 13:30.270
该方法用于启动

13:30.270 --> 13:32.270
DIVA应用程序

13:32.270 --> 13:35.270
你可以认为就是启动react程序

13:35.270 --> 13:38.270
可以认为启动的

13:38.270 --> 13:40.270
就是react程序

13:40.270 --> 13:42.270
就是我们的程序要启动起来

13:42.270 --> 13:44.270
我们要调整它的start才能启动

13:44.270 --> 13:47.270
那么这里调App.start

13:47.270 --> 13:49.270
那么这个start里边传什么呢

13:50.270 --> 13:52.270
一个就是选择器

13:52.270 --> 13:54.270
这个地方

13:54.270 --> 13:56.270
其实也很好理解

13:56.270 --> 13:58.270
该函数

13:58.270 --> 14:00.270
传入一个选择器

14:00.270 --> 14:02.270
用于选中

14:02.270 --> 14:04.270
页面中的

14:04.270 --> 14:06.270
页面中的

14:06.270 --> 14:08.270
某个dom元数

14:08.270 --> 14:10.270
react

14:10.270 --> 14:12.270
react

14:12.270 --> 14:15.270
会将内容

14:15.270 --> 14:18.270
渲染到该元数内部

14:18.270 --> 14:19.270
其实什么意思呢

14:19.270 --> 14:22.270
就是我们之前用的那个就是react

14:22.270 --> 14:26.270
react.derender

14:26.270 --> 14:28.270
这里边第一个是应用程序

14:28.270 --> 14:30.270
第一个是应用程序

14:30.270 --> 14:32.270
第二个是不是document

14:32.270 --> 14:33.270
get elements by ID

14:33.270 --> 14:35.270
什么root

14:35.270 --> 14:36.270
是不是这个玩意

14:36.270 --> 14:38.270
那么这里是一样的

14:38.270 --> 14:39.270
它就给你封装了一下

14:39.270 --> 14:41.270
你不再用这种方式来写了

14:41.270 --> 14:42.270
你直接start

14:42.270 --> 14:44.270
你把这个选择器传给它

14:44.270 --> 14:46.270
那么这里已经配置好了

14:46.270 --> 14:47.270
你先配置好了

14:47.270 --> 14:48.270
配置好了过后

14:48.270 --> 14:49.270
你把选择器传给它

14:49.270 --> 14:51.270
它就可以开始启动了

14:51.270 --> 14:52.270
其实可以想象

14:52.270 --> 14:53.270
它的内部是不可以

14:53.270 --> 14:54.270
雕容这种方法

14:54.270 --> 14:55.270
对吧

14:55.270 --> 14:56.270
它的内部给你雕容了

14:56.270 --> 14:57.270
这个东西

14:57.270 --> 14:58.270
所以说你不再雕容了

14:58.270 --> 15:00.270
那么这里传到是选择器

15:00.270 --> 15:01.270
注意是选择器

15:01.270 --> 15:02.270
不是id

15:02.270 --> 15:03.270
id的话就是这样的

15:03.270 --> 15:04.270
但是选择器的话

15:04.270 --> 15:05.270
就是css选择器

15:05.270 --> 15:06.270
它内部呢

15:06.270 --> 15:07.270
是用claris negative

15:07.270 --> 15:08.270
实现的

15:08.270 --> 15:10.270
所以说你这里要这样子写

15:10.270 --> 15:11.270
id為root

15:11.270 --> 15:12.270
好

15:12.270 --> 15:13.270
保存

15:13.270 --> 15:15.270
你看看是不是就出来了

15:15.270 --> 15:16.270
对吧

15:16.270 --> 15:18.270
这就是我们现在的写法

15:18.270 --> 15:19.270
看没

15:19.270 --> 15:20.270
出来了

15:20.270 --> 15:21.270
根主键

15:21.270 --> 15:22.270
出来了

15:22.270 --> 15:23.270
然后我们来看一下

15:23.270 --> 15:25.270
我们的react结构

15:25.270 --> 15:26.270
react结构

15:26.270 --> 15:27.270
它是多了一个根主键

15:27.270 --> 15:28.270
根主键是什么

15:28.270 --> 15:29.270
divar root

15:29.270 --> 15:31.270
它自己给你加了一个主键

15:31.270 --> 15:32.270
divar root

15:32.270 --> 15:34.270
然后给你加了一个上下文

15:34.270 --> 15:35.270
给你加一个上下文

15:35.270 --> 15:36.270
上下文里面一个stone

15:36.270 --> 15:37.270
一个stone就是

15:37.270 --> 15:38.270
跟那个

15:38.270 --> 15:40.270
Ridax倉库相关的

15:40.270 --> 15:41.270
我们后边再说了

15:41.270 --> 15:42.270
Ridax倉库

15:42.270 --> 15:44.270
我们先把它启动起来再说

15:44.270 --> 15:45.270
那我们刚才说了

15:45.270 --> 15:47.270
这个地方是不是也可以宣言这个

15:47.270 --> 15:48.270
是不是

15:48.270 --> 15:49.270
可以宣言这个

15:49.270 --> 15:50.270
一样的

15:50.270 --> 15:51.270
保存

15:51.270 --> 15:52.270
你看一下

15:52.270 --> 15:53.270
是一样的

15:53.270 --> 15:54.270
只不过这样子一来

15:54.270 --> 15:56.270
你就看不到那个app主键了

15:56.270 --> 15:57.270
你就看不到app主键了

15:57.270 --> 15:58.270
因为它到时候

15:58.270 --> 15:59.270
会把这个东西

15:59.270 --> 16:00.270
当成函数来调用

16:00.270 --> 16:01.270
它会调用这个函数

16:01.270 --> 16:03.270
把这个函数的反回结构

16:03.270 --> 16:04.270
宣言进去

16:04.270 --> 16:05.270
那么函数反回的是div

16:05.270 --> 16:06.270
这里就没有记录了

16:06.270 --> 16:08.270
没有记录

16:08.270 --> 16:09.270
这就是

16:09.270 --> 16:11.270
当然这个也不太影响

16:11.270 --> 16:12.270
也不太影响

16:12.270 --> 16:13.270
都无所谓

16:15.270 --> 16:16.270
这就是这一块

16:16.270 --> 16:17.270
这一块

16:18.270 --> 16:19.270
那么接下来

16:19.270 --> 16:20.270
那么重点开始

16:20.270 --> 16:21.270
重点来了

16:21.270 --> 16:23.270
我们首先来一部分说

16:23.270 --> 16:24.270
重点是

16:24.270 --> 16:27.270
它如何来控制倉库

16:27.270 --> 16:28.270
这跟我们之前

16:28.270 --> 16:29.270
直接用Ridax

16:29.270 --> 16:31.270
有很大的区别

16:31.270 --> 16:32.270
那么这里要说一个

16:32.270 --> 16:33.270
说一个方法

16:33.270 --> 16:34.270
就是diva对象的

16:34.270 --> 16:35.270
另外一个方法

16:35.270 --> 16:38.270
叫做model

16:38.270 --> 16:39.270
model

16:39.270 --> 16:41.270
就是该方法

16:41.270 --> 16:43.270
用于定义一个

16:43.270 --> 16:46.270
用于定义一个模型

16:46.270 --> 16:47.270
什么叫模型呢

16:47.270 --> 16:50.270
该模型可以控制

16:50.270 --> 16:54.270
Ridax倉库中的内容

16:54.270 --> 16:55.270
以及

16:58.270 --> 16:59.270
应该这样说吧

16:59.270 --> 17:00.270
大家就好理解了

17:00.270 --> 17:03.270
该模型可以理解为

17:04.270 --> 17:08.270
Ridax的x

17:08.270 --> 17:09.270
还有什么

17:09.270 --> 17:10.270
reducer

17:10.270 --> 17:11.270
还有什么

17:15.270 --> 17:16.270
Ridax Saga

17:16.270 --> 17:19.270
Saga的副作用

17:19.270 --> 17:22.270
副作用处理的整合

17:22.270 --> 17:24.270
它实际上这个模型

17:24.270 --> 17:26.270
这个模型你就可以把理解为

17:26.270 --> 17:28.270
就是把这些东西

17:28.270 --> 17:29.270
来整合

17:29.270 --> 17:31.270
整合成一个对象

17:31.270 --> 17:33.270
整合成

17:33.270 --> 17:36.270
整合成一个对象

17:36.270 --> 17:39.270
将该对象传入

17:40.270 --> 17:42.270
model方法即可

17:42.270 --> 17:44.270
我们主要是说这个

17:44.270 --> 17:45.270
model

17:45.270 --> 17:47.270
咱们来看一下

17:47.270 --> 17:49.270
这里diva创建好了之后

17:49.270 --> 17:50.270
我们在启动之前

17:50.270 --> 17:52.270
注意一定要在启动之前

17:52.270 --> 17:53.270
定义模型

17:53.270 --> 17:55.270
在启动之前

17:55.270 --> 17:57.270
启动之前

17:57.270 --> 17:59.270
定义模型

17:59.270 --> 18:00.270
在启动之前

18:00.270 --> 18:02.270
怎么来定义模型呢

18:02.270 --> 18:03.270
怎么来定义呢

18:03.270 --> 18:05.270
我们可以直接使用

18:05.270 --> 18:06.270
app里面的model

18:06.270 --> 18:07.270
这个方法

18:07.270 --> 18:08.270
来定义一个模型

18:08.270 --> 18:10.270
你不要传一个什么参数呢

18:10.270 --> 18:12.270
你不要传的参数就是模型对象

18:12.270 --> 18:13.270
模型对象

18:13.270 --> 18:14.270
好

18:14.270 --> 18:15.270
这个模型对象

18:15.270 --> 18:16.270
你可以直接写到这

18:16.270 --> 18:17.270
也可以呢

18:17.270 --> 18:19.270
单独来开一个文件夹来写

18:19.270 --> 18:20.270
比方说

18:20.270 --> 18:21.270
我们现在就新建个文件夹

18:21.270 --> 18:22.270
不再去建什么

18:22.270 --> 18:23.270
那个Ridax

18:23.270 --> 18:24.270
一个信仰Reduce

18:24.270 --> 18:25.270
不再去建这个东西了

18:25.270 --> 18:27.270
我们直接给它取名为models

18:27.270 --> 18:28.270
模型

18:28.270 --> 18:30.270
那么这个模型里边

18:30.270 --> 18:32.270
你可以写很多的文件

18:32.270 --> 18:33.270
它可以定义很多模型的

18:33.270 --> 18:34.270
不是一个

18:34.270 --> 18:35.270
比方两个 三个 四个 五个

18:35.270 --> 18:36.270
都可以

18:36.270 --> 18:38.270
比方说我们首先在这里

18:38.270 --> 18:39.270
定义一个模型

18:39.270 --> 18:40.270
我们这里

18:40.270 --> 18:42.270
比方说我们

18:42.270 --> 18:43.270
之前做过的

18:43.270 --> 18:44.270
对一个仓库

18:44.270 --> 18:46.270
对一个就是

18:46.270 --> 18:48.270
数字进行增加减少

18:48.270 --> 18:49.270
就这么一个模型

18:49.270 --> 18:50.270
比方说

18:50.270 --> 18:51.270
我们把它取名为counter

18:51.270 --> 18:52.270
调解释

18:53.270 --> 18:55.270
然后这里导出什么呢

18:55.270 --> 18:57.270
导出的是一个对象

18:57.270 --> 18:58.270
因为我们刚才说了

18:58.270 --> 18:59.270
模型就是一个对象

18:59.270 --> 19:00.270
好

19:00.270 --> 19:01.270
我们当然也可以

19:01.270 --> 19:02.270
直接把对象写到这

19:02.270 --> 19:03.270
也行

19:03.270 --> 19:04.270
都是一样的

19:05.270 --> 19:06.270
counter

19:06.270 --> 19:07.270
model

19:08.270 --> 19:09.270
from

19:10.270 --> 19:11.270
我再说一次

19:11.270 --> 19:12.270
模型是什么意思

19:12.270 --> 19:13.270
模型来处理什么事情

19:13.270 --> 19:15.270
处理的是绿达克斯

19:15.270 --> 19:16.270
仓库里边的东西

19:16.270 --> 19:18.270
跟什么组件没有什么关系

19:18.270 --> 19:19.270
跟组件没有任何关系

19:19.270 --> 19:21.270
处理的是仓库里边的东西

19:21.270 --> 19:22.270
好

19:22.270 --> 19:23.270
咱们看一下

19:23.270 --> 19:25.270
把这个模型导放进去

19:25.270 --> 19:26.270
那么现在仓库里边

19:26.270 --> 19:27.270
肯定会有变化

19:27.270 --> 19:28.270
当然现在

19:28.270 --> 19:29.270
还没有写完

19:29.270 --> 19:31.270
这个模型都还没有写完

19:31.270 --> 19:32.270
它告诉你

19:32.270 --> 19:33.270
这个模型里边

19:34.270 --> 19:36.270
你至少得写什么

19:36.270 --> 19:37.270
name space

19:37.270 --> 19:38.270
name space

19:38.270 --> 19:39.270
should be defined

19:39.270 --> 19:40.270
那么name space

19:40.270 --> 19:41.270
这个属性

19:41.270 --> 19:42.270
你必须要定义

19:42.270 --> 19:43.270
但是我们这个模型里边

19:43.270 --> 19:44.270
是个空对象

19:44.270 --> 19:45.270
咋都没定义

19:45.270 --> 19:46.270
那么它的模型里边

19:46.270 --> 19:47.270
可以写哪些东西

19:47.270 --> 19:48.270
我们来

19:48.270 --> 19:49.270
罗列一下

19:49.270 --> 19:51.270
模型中可以有哪些东西

19:52.270 --> 19:54.270
一个是name space

19:55.270 --> 19:56.270
name space

19:56.270 --> 19:57.270
我们一个先说完

19:57.270 --> 19:58.270
一个是呢

19:58.270 --> 20:00.270
就是reducers

20:00.270 --> 20:02.270
我看一下有没有s

20:03.270 --> 20:04.270
看API

20:04.270 --> 20:05.270
其实看它的API

20:05.270 --> 20:06.270
其实很少

20:06.270 --> 20:07.270
很少

20:07.270 --> 20:08.270
还有就是state

20:08.270 --> 20:09.270
对吧

20:09.270 --> 20:10.270
state

20:10.270 --> 20:11.270
我们一个个说

20:11.270 --> 20:12.270
一个个说

20:12.270 --> 20:13.270
然后reducers

20:13.270 --> 20:14.270
有s

20:15.270 --> 20:16.270
然后affect

20:17.270 --> 20:18.270
就这五个东西

20:18.270 --> 20:19.270
不可能有别的了

20:19.270 --> 20:20.270
这个模型里边

20:20.270 --> 20:21.270
就这五个属性

20:21.270 --> 20:23.270
有些属性是可以省略的

20:23.270 --> 20:24.270
scriptions

20:26.270 --> 20:27.270
有些属性可以省略

20:27.270 --> 20:28.270
有些属性不能省略

20:28.270 --> 20:29.270
不能省略

20:29.270 --> 20:30.270
这个属性是不能省略的

20:31.270 --> 20:33.270
我们来写一个name space

20:33.270 --> 20:34.270
这个name space

20:34.270 --> 20:35.270
是什么意思呢

20:35.270 --> 20:37.270
它表示的是命名空间

20:40.270 --> 20:42.270
实际上是什么意思

20:42.270 --> 20:44.270
实际上的意思就是

20:44.270 --> 20:47.270
该属性是一个制服串

20:47.270 --> 20:49.270
制服串的值

20:50.270 --> 20:56.270
会被作为仓库中的属性

20:56.270 --> 20:58.270
属性保存

20:58.270 --> 20:59.270
什么意思呢

20:59.270 --> 21:00.270
比方说你看着

21:00.270 --> 21:02.270
我们这个给它的name space

21:02.270 --> 21:04.270
就给它命名为 counter

21:04.270 --> 21:05.270
这样命名

21:05.270 --> 21:06.270
保存

21:06.270 --> 21:07.270
你看一下

21:13.270 --> 21:14.270
还要少写一个东西

21:14.270 --> 21:15.270
还得写个东西

21:15.270 --> 21:16.270
写完之后

21:16.270 --> 21:17.270
看得到

21:17.270 --> 21:18.270
还有这个属性也不能少

21:18.270 --> 21:19.270
state

21:19.270 --> 21:20.270
state表示

21:20.270 --> 21:21.270
仓库中

21:21.270 --> 21:23.270
仓库的默认值

21:24.270 --> 21:26.270
该模型的属性

21:27.270 --> 21:29.270
该模型的默认值

21:29.270 --> 21:31.270
默认状态

21:31.270 --> 21:32.270
这有点像什么呢

21:32.270 --> 21:34.270
有点像我们写reducer的时候

21:34.270 --> 21:36.270
给它的状态负责一个默认状态

21:36.270 --> 21:38.270
就是初始状态

21:38.270 --> 21:39.270
我们这里比方说

21:39.270 --> 21:41.270
给它状态给它负责为0

21:41.270 --> 21:42.270
给它负责为0

21:42.270 --> 21:43.270
保存

21:43.270 --> 21:44.270
再看一下

21:45.270 --> 21:46.270
好了

21:46.270 --> 21:47.270
这个说我们后面再说

21:47.270 --> 21:48.270
不着急

21:48.270 --> 21:49.270
我们现在来看一下

21:49.270 --> 21:51.780
我们的redux

21:52.780 --> 21:53.780
这个redux

21:53.780 --> 21:54.780
redux里面

21:54.780 --> 21:55.780
我们看一下state

21:56.780 --> 21:57.780
放大

21:58.780 --> 21:59.780
d8里面

21:59.780 --> 22:00.780
它已经把这个操作给你做了

22:00.780 --> 22:02.780
已经给你支持了这个插件了

22:02.780 --> 22:03.780
所以说你直接用就行

22:04.780 --> 22:05.780
这里

22:05.780 --> 22:06.780
这样子放大一点

22:07.780 --> 22:08.780
我们来看一下我们的状态

22:08.780 --> 22:09.780
状态里面

22:09.780 --> 22:10.780
其他都不用看

22:10.780 --> 22:11.780
其他都不用看

22:11.780 --> 22:12.780
我们先看这

22:12.780 --> 22:13.780
是不是多了一个counter

22:13.780 --> 22:14.780
等于0

22:14.780 --> 22:15.780
我们再说

22:15.780 --> 22:16.780
一个来说

22:16.780 --> 22:17.780
这个counter哪来的

22:18.780 --> 22:20.780
是不是这个文件名是counter

22:20.780 --> 22:21.780
不是

22:21.780 --> 22:23.780
是这个name space决定的

22:24.780 --> 22:26.780
当你把这个对象

22:26.780 --> 22:27.780
放到哪呢

22:27.780 --> 22:29.780
放到这个d8模型里面去

22:29.780 --> 22:31.780
来定一个模型的时候

22:31.780 --> 22:33.780
它就可以读到这个name space

22:33.780 --> 22:36.780
那么把这个name space的值

22:36.780 --> 22:38.780
作为它的属性名

22:38.780 --> 22:40.780
放到仓库里面

22:40.780 --> 22:41.780
就是这个意思

22:41.780 --> 22:43.780
比方说你这里写的是abc

22:43.780 --> 22:44.780
保存

22:44.780 --> 22:45.780
你看一下

22:45.780 --> 22:46.780
看一下这

22:47.780 --> 22:49.780
你看是不是abc

22:49.780 --> 22:52.780
给你的命名空间的名字是有关系的

22:52.780 --> 22:53.780
应该对是吧

22:53.780 --> 22:54.780
这就是命名空间

22:54.780 --> 22:55.780
好那么这个name

22:55.780 --> 22:56.780
state0

22:56.780 --> 22:57.780
它对应到哪呢

22:57.780 --> 22:59.780
是不是对应到这个数据

22:59.780 --> 23:00.780
对不对

23:00.780 --> 23:02.780
那么你定一个模型

23:02.780 --> 23:03.780
是不是就往仓库里面

23:03.780 --> 23:05.780
刮了一个数据上去

23:05.780 --> 23:06.780
如果你定两个模型

23:06.780 --> 23:07.780
那么比方说

23:07.780 --> 23:09.780
我们这里再定一个模型

23:09.780 --> 23:11.780
比方student

23:11.780 --> 23:12.780
student

23:12.780 --> 23:14.780
这里也导出一个模型

23:14.780 --> 23:15.780
你看现在写法

23:15.780 --> 23:16.780
是不是感觉很舒服了

23:16.780 --> 23:17.780
就感觉

23:17.780 --> 23:18.780
有点像啥

23:18.780 --> 23:19.780
是不是有点像vu

23:19.780 --> 23:21.780
所以有点像vux

23:21.780 --> 23:23.780
这里我们比方说

23:24.780 --> 23:26.780
这里name space

23:27.780 --> 23:29.780
name space

23:29.780 --> 23:31.780
这里student

23:31.780 --> 23:32.780
这里state

23:32.780 --> 23:33.780
它能摸到状态

23:33.780 --> 23:34.780
摸到状态

23:34.780 --> 23:35.780
有哪些呢

23:35.780 --> 23:36.780
比方说

23:36.780 --> 23:37.780
能摸到状态

23:37.780 --> 23:38.780
有哪些

23:40.780 --> 23:42.780
学生的数据

23:42.780 --> 23:44.780
data是个数组

23:44.780 --> 23:46.780
学生的总数

23:46.780 --> 23:48.780
偷偷

23:48.780 --> 23:50.780
比方说是0

23:50.780 --> 23:51.780
比方说吧

23:51.780 --> 23:52.780
这是默认的状态

23:52.780 --> 23:53.780
对吧

23:53.780 --> 23:54.780
咱们来看一下

23:55.780 --> 23:56.780
咱们来看一下

23:56.780 --> 23:58.780
然后我们这里

23:58.780 --> 24:00.780
找到这个app

24:01.780 --> 24:02.780
那个index

24:02.780 --> 24:04.780
我们再订一个模型

24:04.780 --> 24:06.780
是不是可以订多个模型

24:06.780 --> 24:08.780
这里导入student

24:08.780 --> 24:12.090
student model

24:12.090 --> 24:13.090
好我们这里

24:13.090 --> 24:15.090
再来订一个模型

24:15.090 --> 24:16.090
注意模型定义

24:16.090 --> 24:17.090
一定要在启动之前

24:17.090 --> 24:19.090
启动之后定义就没意义了

24:19.090 --> 24:21.090
好保存

24:21.090 --> 24:22.090
你看一下

24:22.090 --> 24:23.090
我们的模型

24:23.090 --> 24:24.090
这里面多了一个student

24:24.090 --> 24:25.090
它的默认状态

24:25.090 --> 24:26.090
一看是不是出来了

24:26.090 --> 24:28.090
那么我们现在要做一个

24:28.090 --> 24:29.090
要往仓库里面安个东西

24:29.090 --> 24:30.090
是不是不用写那么多了

24:30.090 --> 24:31.090
你看以前要写多少

24:31.090 --> 24:32.090
是不是要写action

24:32.090 --> 24:33.090
你再写吧

24:33.090 --> 24:34.090
action创建函数你再写吧

24:34.090 --> 24:35.090
你再写reducer吧

24:35.090 --> 24:36.090
对吧

24:36.090 --> 24:37.090
reducer过写完了过

24:37.090 --> 24:38.090
是不是得创建仓库

24:38.090 --> 24:40.090
是不是得安装各种中间

24:40.090 --> 24:41.090
是不是很麻烦

24:41.090 --> 24:42.090
那现在很简单了

24:42.090 --> 24:44.090
你就是写个模型就完事了

24:44.090 --> 24:46.090
就这么个意思

24:46.090 --> 24:47.090
我们重点做这个

24:47.090 --> 24:48.090
这个比较简单

24:48.090 --> 24:50.090
我先看它怎么去使用

24:50.090 --> 24:52.090
好里边还有哪些东西呢

24:52.090 --> 24:53.090
这个模型它不是

24:53.090 --> 24:55.090
这个数据我们在哪呢

24:55.090 --> 24:56.090
数据我们定义了

24:56.090 --> 24:58.090
这个数据我们已经定义了

24:58.090 --> 24:59.090
在哪呢

24:59.090 --> 25:00.090
在这个状态里面对吧

25:00.090 --> 25:02.090
那么这个数据是不是有可能会变化

25:02.090 --> 25:04.090
是不是有可能会变化

25:04.090 --> 25:05.090
那么变化的时候

25:05.090 --> 25:07.090
我们是不是跟按照大使的约定

25:07.090 --> 25:09.090
规定是不是要写reducer

25:09.090 --> 25:11.090
有reducer写哪呢

25:11.090 --> 25:12.090
是不是写reducer

25:12.090 --> 25:13.090
他就写这

25:13.090 --> 25:15.090
配置到这个属性里面

25:15.090 --> 25:18.090
该属性配置为一个对象

25:18.090 --> 25:22.090
对象中的每个方法

25:22.090 --> 25:26.090
每个方法就是一个reducer

25:26.090 --> 25:28.090
每个方法就是一个reducer

25:28.090 --> 25:29.090
好来吧

25:29.090 --> 25:30.090
看着啊

25:30.090 --> 25:33.090
咱们这里就写一个reducer

25:33.090 --> 25:36.090
reducer

25:36.090 --> 25:38.090
reducer

25:38.090 --> 25:42.090
reducer

25:42.090 --> 25:44.090
我都写匀了

25:44.090 --> 25:47.090
是这样写吧

25:47.090 --> 25:48.090
是这样子写的

25:48.090 --> 25:49.090
他配置为什么

25:49.090 --> 25:51.090
配置为一个函数

25:51.090 --> 25:53.090
配置为一个函数

25:53.090 --> 25:54.090
这个配置为一个对象

25:54.090 --> 25:56.090
这个对象里面有很多的方法

25:56.090 --> 25:58.090
比方说他里面有哪些方法

25:58.090 --> 26:00.090
比方说有增加

26:00.090 --> 26:02.090
增加就是increase

26:02.090 --> 26:04.090
有这个increase方法

26:04.090 --> 26:06.090
增加的方法

26:06.090 --> 26:07.090
有什么有减少

26:07.090 --> 26:09.090
这里面每一个方法

26:09.090 --> 26:10.090
就是一个reducer

26:10.090 --> 26:12.090
就是用来改变

26:12.090 --> 26:15.090
就是用来改变这个相应的数据的

26:15.090 --> 26:16.090
就这么个意思

26:16.090 --> 26:19.090
用来改变这个相应的数据

26:19.090 --> 26:22.090
好那么这些方法里边

26:22.090 --> 26:23.090
怎么写呢

26:23.090 --> 26:24.090
它是格式是什么呢

26:24.090 --> 26:27.090
跟reducer的格式是完全一样的

26:27.090 --> 26:29.090
跟reducer的格式是完全一样的

26:29.090 --> 26:30.090
stat

26:30.090 --> 26:33.090
x是完全一样的

26:33.090 --> 26:34.090
是不是就是一个reducer的格式

26:34.090 --> 26:35.090
然后反回什么呢

26:35.090 --> 26:37.090
反回一个新的状态

26:37.090 --> 26:38.090
对吧

26:38.090 --> 26:39.090
反回一个新的状态

26:39.090 --> 26:40.090
其实呢这里

26:40.090 --> 26:42.090
由于我这里不需要x

26:42.090 --> 26:43.090
对吧

26:43.090 --> 26:44.090
我们先写到这吧

26:44.090 --> 26:45.090
先写到这

26:45.090 --> 26:46.090
反回新的状态

26:46.090 --> 26:48.090
但是我们以前的reducer里面怎么写的

26:48.090 --> 26:50.090
是不是要switch

26:50.090 --> 26:51.090
x 点什么type

26:51.090 --> 26:52.090
对吧

26:52.090 --> 26:54.090
判断一下你的x 内形

26:54.090 --> 26:55.090
x 内形等于什么的时候

26:55.090 --> 26:56.090
我要增加

26:56.090 --> 26:58.090
现在不用了

26:58.090 --> 26:59.090
现在不用了

26:59.090 --> 27:00.090
为什么不用了呢

27:00.090 --> 27:03.090
因为它有这么一个规则

27:03.090 --> 27:05.090
第一把约定

27:05.090 --> 27:08.090
方法的名字

27:08.090 --> 27:13.090
就是匹配的x 内形

27:14.090 --> 27:16.090
你这里的方法写的是什么名字

27:16.090 --> 27:17.090
它就匹配什么x 内形

27:17.090 --> 27:18.090
因此呢

27:18.090 --> 27:20.090
如果说运行这个函数

27:20.090 --> 27:22.090
它一定是匹配了这个x 内形

27:22.090 --> 27:24.090
一定是匹配了这个x

27:24.090 --> 27:25.090
明白这个意思吗

27:25.090 --> 27:26.090
它一定是匹配了increase

27:26.090 --> 27:28.090
所以说你这里边不用判断了

27:28.090 --> 27:29.090
你不用判断了

27:29.090 --> 27:31.090
你直接写就行了

27:31.090 --> 27:32.090
反回什么呢

27:32.090 --> 27:34.090
反回的就是stat加一

27:34.090 --> 27:35.090
对吧

27:35.090 --> 27:36.090
就反回这个

27:36.090 --> 27:38.090
那么这个x 由于它没有负载

27:38.090 --> 27:39.090
没有payload

27:39.090 --> 27:41.090
所以说x 不需要了

27:41.090 --> 27:42.090
decrease呢

27:45.090 --> 27:47.090
decrease

27:47.090 --> 27:49.090
所以反回stat

27:49.090 --> 27:51.090
stat减1

27:51.090 --> 27:52.090
就这么简单

27:52.090 --> 27:53.090
一个加一个减1

27:53.090 --> 27:54.090
你看现在写法

27:54.090 --> 27:55.090
写出来一个结构

27:55.090 --> 27:57.090
是不是特别简单

27:57.090 --> 27:59.090
我们不用去switch判断了

27:59.090 --> 28:01.090
因为它只有满足这样的内形

28:01.090 --> 28:04.090
它才会匹配到这个reducer

28:04.090 --> 28:05.090
那么它的内部

28:05.090 --> 28:07.090
会对这些reducer进行合并

28:07.090 --> 28:08.090
会进行合并

28:08.090 --> 28:10.090
那么现在我们马上来用一下

28:10.090 --> 28:12.090
马上来用一下

28:12.090 --> 28:14.090
接下来我们在app里边

28:14.090 --> 28:16.090
这个组件里边

28:16.090 --> 28:18.090
给它做这么一个组件

28:18.090 --> 28:19.090
新建个文件

28:19.090 --> 28:21.090
conter.js

28:21.090 --> 28:23.090
做这么一个组件

28:23.090 --> 28:24.090
export

28:24.090 --> 28:27.090
先写这么一个组件

28:27.090 --> 28:29.090
rfc

28:29.090 --> 28:30.090
rfc

28:30.090 --> 28:32.090
这么一个conter组件

28:32.090 --> 28:35.090
conter组件里边有一个数字

28:35.090 --> 28:36.090
数字

28:36.090 --> 28:38.090
你要通过属性传给我

28:38.090 --> 28:41.090
你通过属性传给我

28:41.090 --> 28:43.090
传给我一个数字

28:43.090 --> 28:46.090
然后下面有两个按钮

28:46.090 --> 28:50.530
按钮1是减

28:50.530 --> 28:53.530
按钮2是加

28:53.530 --> 28:54.530
有两个按钮

28:54.530 --> 28:55.530
点击两个按钮干嘛呢

28:55.530 --> 28:56.530
要改变数字

28:56.530 --> 28:57.530
但是我也改变不了

28:57.530 --> 28:58.530
因为这个数字不是我的

28:58.530 --> 29:00.530
所以说我只能触发

29:00.530 --> 29:02.530
触发是函数

29:02.530 --> 29:03.530
unclick

29:03.530 --> 29:06.530
等于我自己的unincrease

29:06.530 --> 29:07.530
触发函数

29:07.530 --> 29:08.530
触发函数

29:08.530 --> 29:10.530
就是触发我这个组件的时间

29:10.530 --> 29:13.530
这里undecrease

29:13.530 --> 29:16.530
这里是加

29:16.530 --> 29:18.530
这里是减

29:18.530 --> 29:21.100
这里是加

29:21.100 --> 29:22.100
这里写过来

29:22.100 --> 29:23.100
点这个

29:23.100 --> 29:25.100
触发函数

29:25.100 --> 29:26.100
那么这里是不是有

29:26.100 --> 29:27.100
三个属性要传递

29:27.100 --> 29:28.100
那我们是不是要把

29:28.100 --> 29:29.100
仓库里边的东西

29:29.100 --> 29:30.100
看看连接

29:30.100 --> 29:31.100
对不对

29:31.100 --> 29:32.100
要连接

29:32.100 --> 29:33.100
连接我们现在没有按钮

29:33.100 --> 29:34.100
我觉得大概是

29:34.100 --> 29:35.100
没有按钮

29:35.100 --> 29:36.100
大概是怎么连接

29:36.100 --> 29:37.100
没关系

29:37.100 --> 29:38.100
Diva里边全部给你提供了

29:38.100 --> 29:39.100
from

29:39.100 --> 29:40.100
diva

29:40.100 --> 29:41.100
diva里边给你提供了

29:41.100 --> 29:42.100
一个什么

29:42.100 --> 29:43.100
connect

29:44.100 --> 29:45.100
对了

29:45.100 --> 29:48.660
是这个connect

29:48.660 --> 29:49.660
我看一下

29:49.660 --> 29:50.660
怎么感觉

29:50.660 --> 29:52.660
它应该有智能提示的

29:53.660 --> 29:54.660
它应该有智能提示的

29:54.660 --> 29:55.660
connect

29:55.660 --> 29:56.660
对有这个

29:56.660 --> 29:57.660
我说

29:57.660 --> 29:59.660
那么这个connect的用法

29:59.660 --> 30:00.660
跟那个reg

30:00.660 --> 30:01.660
大个是完全一样

30:01.660 --> 30:02.660
一点儿区别都没有

30:02.660 --> 30:03.660
完全一样

30:03.660 --> 30:04.660
你直接用就行了

30:04.660 --> 30:05.660
怎么用呢

30:05.660 --> 30:06.660
直接怎么用呢

30:06.660 --> 30:07.660
第一个传啥

30:07.660 --> 30:08.660
一个map state to props

30:08.660 --> 30:09.660
对吧

30:09.660 --> 30:11.660
一个map state to props

30:11.660 --> 30:12.660
这里一个函数

30:12.660 --> 30:14.660
map state to props

30:14.660 --> 30:15.660
这么一个函数

30:15.660 --> 30:16.660
它给你传一个什么进来

30:16.660 --> 30:18.660
给你传一个整个仓库

30:18.660 --> 30:19.660
整个仓库给你传进来

30:19.660 --> 30:21.660
然后你返回一个什么呢

30:21.660 --> 30:22.660
返回的就是

30:22.660 --> 30:23.660
它对应的数据属性

30:23.660 --> 30:24.660
你返回了

30:24.660 --> 30:25.660
它不是要一个number吗

30:25.660 --> 30:26.660
OK 我给你传一个number

30:26.660 --> 30:28.660
传这么一个number

30:28.660 --> 30:29.660
或者是我们把它写成

30:29.660 --> 30:31.660
一个箭头函数也行

30:31.660 --> 30:32.660
写成箭头函数也行

30:32.660 --> 30:33.660
当然都无所谓

30:33.660 --> 30:34.660
都无所谓

30:34.660 --> 30:39.380
箭头函数好看一点

30:39.380 --> 30:41.380
纯粹是好看一点

30:41.380 --> 30:45.940
这样子

30:48.940 --> 30:49.940
那么传一个state

30:49.940 --> 30:51.940
返回一个对象

30:51.940 --> 30:53.940
这个对象里面的就是属性

30:53.940 --> 30:54.940
number的有什么呢

30:54.940 --> 30:55.940
number为

30:55.940 --> 30:57.940
状态里面的什么

30:57.940 --> 30:59.940
看一下之前的状态里面

30:59.940 --> 31:01.940
什么counter对吧

31:01.940 --> 31:03.940
整个仓库里面的counter

31:03.940 --> 31:05.940
就是我们的命名空间

31:05.940 --> 31:06.940
空间counter

31:06.940 --> 31:07.940
对不对

31:07.940 --> 31:09.940
是不是这个东西就出来了

31:09.940 --> 31:11.940
咱们把这个东西传进去

31:11.940 --> 31:13.940
然后我们把这个counter

31:13.940 --> 31:15.940
包装的组件传进去

31:15.940 --> 31:17.940
最后导出export

31:17.940 --> 31:18.940
default

31:18.940 --> 31:20.940
你看是不是就写完了

31:20.940 --> 31:22.940
这个组件写完了

31:22.940 --> 31:24.940
咱们试用一下

31:24.940 --> 31:26.940
App里面我们这里跟组件

31:26.940 --> 31:29.940
下面我们导入我们自己的组件

31:29.940 --> 31:31.940
counter

31:31.940 --> 31:32.940
吊鞋杠

31:32.940 --> 31:33.940
counter

31:33.940 --> 31:35.940
跟组件导入

31:35.940 --> 31:38.940
counter

31:38.940 --> 31:40.940
counter

31:40.940 --> 31:41.940
保存

31:41.940 --> 31:42.940
你看一下

31:42.940 --> 31:43.940
是不是就出来了

31:43.940 --> 31:44.940
一开始显示零

31:44.940 --> 31:45.940
为什么显示零

31:45.940 --> 31:46.940
我又没敢写零

31:46.940 --> 31:47.940
是不是从来自于仓库的

31:47.940 --> 31:48.940
对不对

31:48.940 --> 31:49.940
那这里用法是不是一模一样

31:49.940 --> 31:50.940
因为这个东西

31:50.940 --> 31:51.940
是不是已经放了仓库的

31:51.940 --> 31:52.940
那么现在来看一下

31:52.940 --> 31:54.940
怎么来去触发

31:54.940 --> 31:55.940
怎么来去触发

31:55.940 --> 31:57.940
触发变化

31:57.940 --> 31:59.940
怎么来触发呢

31:59.940 --> 32:00.940
回到这来

32:00.940 --> 32:01.940
那么触发是不是

32:01.940 --> 32:02.940
你要写另外一个函数

32:02.940 --> 32:03.940
叫做

32:03.940 --> 32:04.940
map

32:04.940 --> 32:05.940
disparch

32:05.940 --> 32:06.940
to

32:06.940 --> 32:07.940
probs

32:07.940 --> 32:08.940
是不是写这么一个函数

32:08.940 --> 32:10.940
它传入一个disparch进来

32:10.940 --> 32:12.940
传入这么一个disparch进来

32:12.940 --> 32:13.940
你返回一个对象

32:13.940 --> 32:14.940
这个对象里边

32:14.940 --> 32:15.940
每一个是不是就是事件

32:15.940 --> 32:16.940
有哪些事件

32:16.940 --> 32:17.940
一个是unincrease

32:17.940 --> 32:18.940
对吧

32:18.940 --> 32:20.940
unincrease事件

32:20.940 --> 32:21.940
那么这个事件

32:21.940 --> 32:22.940
肯定是一个函数

32:22.940 --> 32:24.940
这么一个函数

32:24.940 --> 32:25.940
然后还有一个事件

32:25.940 --> 32:27.940
就是undecrease

32:27.940 --> 32:28.940
undecrease

32:28.940 --> 32:29.940
它也是一个事件

32:29.940 --> 32:30.940
那么这个事件里边

32:30.940 --> 32:31.940
怎么处理呢

32:31.940 --> 32:32.940
就是往这个组件里边

32:32.940 --> 32:34.940
传处理函数

32:34.940 --> 32:35.940
unincrease的时候

32:35.940 --> 32:37.940
是不是disparch一个action

32:37.940 --> 32:38.940
对吧

32:38.940 --> 32:39.940
是不是disparch一个action

32:39.940 --> 32:40.940
好

32:40.940 --> 32:41.940
那么这个action怎么写

32:41.940 --> 32:43.940
是不是要给它个内形

32:43.940 --> 32:44.940
对吧

32:44.940 --> 32:45.940
内形是啥

32:45.940 --> 32:46.940
想一想我们之前说的

32:46.940 --> 32:49.940
内形是啥

32:49.940 --> 32:50.940
内形是啥了

32:50.940 --> 32:51.940
是不是跟那个方法名

32:51.940 --> 32:52.940
是一样的

32:52.940 --> 32:53.940
对吧

32:53.940 --> 32:54.940
是不是跟方法名

32:54.940 --> 32:55.940
是一样的

32:55.940 --> 32:56.940
但是

32:56.940 --> 32:58.940
你得把命名空间架上

32:58.940 --> 32:59.940
好

32:59.940 --> 33:00.940
该怎么写的

33:00.940 --> 33:01.940
这里要这样子写

33:01.940 --> 33:02.940
counter

33:02.940 --> 33:03.940
斜杠

33:03.940 --> 33:05.940
increase

33:05.940 --> 33:06.940
就是触发

33:06.940 --> 33:10.940
这个模型里边的increase这个方法

33:10.940 --> 33:11.940
很明白吧

33:11.940 --> 33:12.940
这个

33:12.940 --> 33:15.940
触发这个模型里边的increase方法

33:15.940 --> 33:16.940
就触发这个方法

33:16.940 --> 33:17.940
就这么简单

33:17.940 --> 33:19.940
就是disparch

33:19.940 --> 33:20.940
那么这里

33:20.940 --> 33:23.940
触发这个模型里边的decrease方法

33:23.940 --> 33:24.940
看没

33:24.940 --> 33:25.940
就这么简单

33:25.940 --> 33:26.940
但是

33:26.940 --> 33:27.940
这就是

33:27.940 --> 33:28.940
我们要触发的一个形内形

33:28.940 --> 33:30.940
但是你得把命名空间加上

33:30.940 --> 33:31.940
它为什么要加命名空间

33:31.940 --> 33:34.940
它是为了防止命名冲突

33:34.940 --> 33:36.940
因为你在一个文件里边

33:36.940 --> 33:37.940
这个名字不可能有冲突的

33:37.940 --> 33:39.940
有冲突的马上爆错了

33:39.940 --> 33:40.940
但是在不同的模型里边

33:40.940 --> 33:41.940
名字是不是一样

33:41.940 --> 33:42.940
有可能一样

33:42.940 --> 33:44.940
那么如果说名字一样的话

33:44.940 --> 33:46.940
它就可能会导致

33:46.940 --> 33:47.940
那么一个x形会

33:47.940 --> 33:49.940
可能会被多个模型使用

33:49.940 --> 33:51.940
可能会被多个模型使用

33:51.940 --> 33:52.940
为了避免这一点

33:52.940 --> 33:53.940
你得把命名空间

33:53.940 --> 33:55.940
给大家加上

33:55.940 --> 33:56.940
就这么个意思

33:56.940 --> 33:57.940
好

33:57.940 --> 33:58.940
咱们把这个mapDisparch

33:58.940 --> 33:59.940
probs

33:59.940 --> 34:00.940
把它写上

34:00.940 --> 34:01.940
保存

34:01.940 --> 34:02.940
看一下吧

34:02.940 --> 34:03.940
这里点加

34:03.940 --> 34:04.940
你看是不是加了

34:04.940 --> 34:06.940
你看我们的触发的x形

34:06.940 --> 34:07.940
对吧

34:07.940 --> 34:08.940
是不是就触发这个x形

34:08.940 --> 34:09.940
counter increase

34:09.940 --> 34:10.940
对吧

34:10.940 --> 34:11.940
那么这个x形触发

34:11.940 --> 34:12.940
它会被谁接受到

34:12.940 --> 34:13.940
首先呢

34:13.940 --> 34:15.940
肯定跟这个模型没任何关系

34:15.940 --> 34:16.940
因为这个模型

34:16.940 --> 34:17.940
它一定接受到

34:17.940 --> 34:18.940
x形内形

34:18.940 --> 34:20.940
一定是students kettle的内形

34:20.940 --> 34:22.940
它一定不会接受counter kettle的内形

34:22.940 --> 34:23.940
那么只有这个模型

34:23.940 --> 34:24.940
才会接受到这个

34:24.940 --> 34:25.940
就是reducer

34:25.940 --> 34:26.940
那么这个reducer

34:26.940 --> 34:27.940
它就会交给相应的

34:27.940 --> 34:29.940
函数来进行处理

34:29.940 --> 34:30.940
对吧

34:30.940 --> 34:31.940
你就不用去

34:31.940 --> 34:32.940
不用去判断什么内形

34:32.940 --> 34:33.940
x形什么内形了

34:33.940 --> 34:34.940
没有这个必要了

34:34.940 --> 34:35.940
它会自动去交给

34:35.940 --> 34:36.940
相应的函数来处理

34:36.940 --> 34:37.940
那么现在写法

34:37.940 --> 34:38.940
是不是非常简单了

34:38.940 --> 34:40.940
对不对

34:40.940 --> 34:41.940
好再看一下

34:41.940 --> 34:42.940
那么我建议大家

34:42.940 --> 34:44.940
先暂时可以暂停视频

34:44.940 --> 34:46.940
先把这个东西先做出来

34:46.940 --> 34:47.940
做一次

34:47.940 --> 34:49.940
感受一下再说

34:49.940 --> 34:51.940
好我们再来演示一个

34:51.940 --> 34:53.940
带有负载的例子吧

34:53.940 --> 34:55.940
比方说我们这里

34:55.940 --> 34:56.940
再写一个

34:56.940 --> 34:58.940
再写一个就是reducer

34:58.940 --> 35:00.940
就是加

35:00.940 --> 35:02.940
加指定的数量

35:02.940 --> 35:04.940
加指定的数量

35:04.940 --> 35:05.940
add

35:05.940 --> 35:06.940
状态传进来

35:06.940 --> 35:07.940
注意啊

35:07.940 --> 35:08.940
这里写的就是reducer

35:08.940 --> 35:09.940
它会进行合并

35:09.940 --> 35:11.940
它会自动给你进行合并

35:11.940 --> 35:12.940
好那么这里是不是

35:12.940 --> 35:13.940
x形

35:13.940 --> 35:14.940
因为x形里面有负载

35:14.940 --> 35:15.940
我们可以把直接

35:15.940 --> 35:16.940
把负载解构出来

35:16.940 --> 35:17.940
pulled

35:17.940 --> 35:18.940
x形解构出来

35:18.940 --> 35:19.940
好那么这里

35:19.940 --> 35:20.940
要加多少个

35:20.940 --> 35:21.940
要加多少个数字呢

35:21.940 --> 35:22.940
就是set

35:22.940 --> 35:23.940
加上多少个数字呢

35:23.940 --> 35:24.940
加上那个负载

35:24.940 --> 35:26.940
你通过负载传进来

35:26.940 --> 35:27.940
好那么就完了

35:27.940 --> 35:29.940
你看是不是非常非常简单

35:29.940 --> 35:30.940
好了

35:30.940 --> 35:31.940
这边怎么写呢

35:31.940 --> 35:32.940
比方说

35:32.940 --> 35:33.940
我们这边

35:33.940 --> 35:35.940
再写这么一个文本框

35:35.940 --> 35:37.940
input

35:37.940 --> 35:38.940
文本框

35:38.940 --> 35:39.940
这边写个number

35:39.940 --> 35:40.940
number

35:40.940 --> 35:41.940
好

35:41.940 --> 35:42.940
给它一个ref

35:42.940 --> 35:43.940
给它一个ref

35:43.940 --> 35:44.940
好

35:44.940 --> 35:45.940
这里边

35:45.940 --> 35:47.940
我们直接使用reducer

35:47.940 --> 35:49.940
里面的hook

35:49.940 --> 35:50.940
useref

35:50.940 --> 35:52.940
useref

35:52.940 --> 35:53.940
直接用这个

35:53.940 --> 35:54.940
还记得吗

35:54.940 --> 35:55.940
还记得吗

35:55.940 --> 35:56.940
就是创建一个ref

35:56.940 --> 35:58.940
创建一个不可辨对象

35:58.940 --> 36:00.940
这个对象是保持唯一的

36:00.940 --> 36:01.940
无论有个函数运行多少次

36:01.940 --> 36:02.940
这个对象都是唯一的

36:02.940 --> 36:04.940
这个对象里面有个current属性

36:04.940 --> 36:06.940
createRef

36:06.940 --> 36:07.940
就完了

36:07.940 --> 36:09.940
这是input

36:10.940 --> 36:11.940
把这个ref传进来

36:11.940 --> 36:13.940
传进来

36:13.940 --> 36:14.940
好

36:14.940 --> 36:15.940
这里边有个按钮

36:17.940 --> 36:18.940
加上

36:18.940 --> 36:19.940
加上

36:19.940 --> 36:20.940
好

36:20.940 --> 36:22.940
那么这里onclick

36:23.940 --> 36:24.940
onclick

36:24.940 --> 36:25.940
等于什么呢

36:25.940 --> 36:26.940
等于一个函数

36:26.940 --> 36:27.940
等于一个函数

36:29.940 --> 36:30.940
好

36:30.940 --> 36:31.940
这个函数里边

36:31.940 --> 36:33.940
我们是不是要获取文本框的值

36:33.940 --> 36:34.940
对吧

36:34.940 --> 36:35.940
获取文本框的值

36:35.940 --> 36:36.940
来吧

36:36.940 --> 36:37.940
n

36:37.940 --> 36:38.940
postint

36:38.940 --> 36:39.940
postint

36:39.940 --> 36:40.940
这个文本框的值

36:40.940 --> 36:41.940
文本框在哪

36:41.940 --> 36:42.940
是不是input

36:42.940 --> 36:43.940
ref

36:43.940 --> 36:44.940
ref里边是不是个current属性

36:44.940 --> 36:45.940
就拿到文本框

36:45.940 --> 36:46.940
动不对象了

36:46.940 --> 36:47.940
拿到动不对象里边

36:47.940 --> 36:48.940
取它的value

36:48.940 --> 36:49.940
是不是可以取出

36:49.940 --> 36:50.940
文本框的值

36:50.940 --> 36:51.940
取出n

36:51.940 --> 36:52.940
取出n过后

36:52.940 --> 36:53.940
我们再来

36:53.940 --> 36:55.940
调用一个属性里边

36:55.940 --> 36:56.940
一个函数进来

36:56.940 --> 36:57.940
因为我做不了

36:57.940 --> 36:58.940
我是没法改变数据的

36:58.940 --> 37:00.940
我这是一个存展式的组建

37:00.940 --> 37:01.940
我不可能改变数据

37:01.940 --> 37:03.940
我只能去触发函数

37:03.940 --> 37:04.940
onadd

37:04.940 --> 37:05.940
然后呢

37:05.940 --> 37:07.940
给他传一个参数n进去

37:07.940 --> 37:08.940
你去做处理吧

37:08.940 --> 37:09.940
我不处理的

37:09.940 --> 37:10.940
我把数据传给你

37:10.940 --> 37:11.940
好

37:11.940 --> 37:12.940
那这边

37:12.940 --> 37:13.940
是不是要多传一个函数

37:13.940 --> 37:14.940
多传个什么

37:14.940 --> 37:15.940
onadd

37:15.940 --> 37:16.940
是不是要多传这么一个函数

37:16.940 --> 37:17.940
对吧

37:17.940 --> 37:18.940
我直接在这里这样子写吧

37:18.940 --> 37:22.380
直接在这里这样子写得了

37:22.380 --> 37:23.380
少写一点

37:23.380 --> 37:24.380
试一点

37:24.380 --> 37:25.380
方法

37:25.380 --> 37:26.380
无所谓

37:26.380 --> 37:27.380
onadd

37:27.380 --> 37:28.380
是不是要得到一个n

37:28.380 --> 37:29.380
对不对

37:29.380 --> 37:30.380
得到一个n

37:30.380 --> 37:31.380
那么这个n5是不是dispatch

37:31.380 --> 37:34.380
又来tap值等于什么

37:34.380 --> 37:35.380
conter

37:35.380 --> 37:36.380
鞋杠

37:36.380 --> 37:37.380
add

37:37.380 --> 37:40.380
触发conter里边的这个东西

37:40.380 --> 37:41.380
这个reducer

37:41.380 --> 37:42.380
然后呢

37:42.380 --> 37:43.380
给他一个什么

37:43.380 --> 37:44.380
给他一个payload

37:44.380 --> 37:45.380
payload是怎么了

37:45.380 --> 37:46.380
对了

37:46.380 --> 37:48.380
payload是怎么了

37:48.380 --> 37:49.380
payload就是n

37:49.380 --> 37:50.380
对吧

37:50.380 --> 37:51.380
保存

37:51.380 --> 37:52.380
你看一下

37:52.380 --> 37:53.380
那么这里呢

37:53.380 --> 37:54.380
这里加

37:54.380 --> 37:55.380
这里减

37:55.380 --> 37:57.380
然后再加上一个5

37:57.380 --> 37:58.380
变成3

37:58.380 --> 37:59.380
再加上一个5

37:59.380 --> 38:00.380
变成8

38:00.380 --> 38:01.380
对吧

38:01.380 --> 38:03.380
没问题吧

38:03.380 --> 38:05.380
这就是带有负载的情况

38:05.380 --> 38:07.380
是不是都特别简单

38:07.380 --> 38:08.380
好

38:08.380 --> 38:09.380
继续

38:09.380 --> 38:10.380
然后呢

38:10.380 --> 38:11.380
dva对象呢

38:11.380 --> 38:13.380
mod里边除了这三个之外呢

38:13.380 --> 38:14.380
还有

38:14.380 --> 38:15.380
affect

38:15.380 --> 38:16.380
affect

38:16.380 --> 38:17.380
好

38:17.380 --> 38:18.380
那么这个affect做什么事情呢

38:18.380 --> 38:19.380
这个affect

38:19.380 --> 38:21.380
他做的事情就是处理副作用

38:21.380 --> 38:23.380
他底层的原理

38:23.380 --> 38:24.380
是用dva

38:24.380 --> 38:25.380
是用那个sacca实现的

38:25.380 --> 38:27.380
处理副作用

38:27.380 --> 38:29.380
底层

38:29.380 --> 38:32.380
是使用reducer

38:32.380 --> 38:34.380
sacca实现的

38:34.380 --> 38:35.380
每个

38:35.380 --> 38:40.380
就是该属性配置为一个对象

38:40.380 --> 38:43.380
对象中的

38:43.380 --> 38:46.380
每个方法

38:46.380 --> 38:49.380
均处理一个副作用

38:49.380 --> 38:50.380
每个方法

38:50.380 --> 38:51.380
他就处理一个副作用

38:51.380 --> 38:52.380
那么

38:52.380 --> 38:54.380
这样的方法的名字

38:54.380 --> 38:57.380
就是匹配的x类型

38:57.380 --> 39:00.380
方法的名字就是匹配的x类型

39:00.380 --> 39:01.380
跟我们那个reducer

39:01.380 --> 39:02.380
是不是感觉差不多

39:02.380 --> 39:03.380
只不过reducer

39:03.380 --> 39:04.380
他干嘛呢

39:04.380 --> 39:06.380
reducer他处理的是

39:06.380 --> 39:07.380
无副作用的

39:07.380 --> 39:09.380
无副作用的状态变化

39:09.380 --> 39:11.380
他是处理的状态变化

39:11.380 --> 39:13.380
那么这个affect

39:13.380 --> 39:14.380
affect

39:14.380 --> 39:15.380
他不处理状态变化

39:15.380 --> 39:17.380
他不能改变状态

39:17.380 --> 39:19.380
他不能直接改变状态

39:19.380 --> 39:21.380
就跟我们之前学过的是一样的

39:21.380 --> 39:23.380
状态变化只能是reducer来处理

39:23.380 --> 39:24.380
那么

39:24.380 --> 39:25.380
副作用

39:25.380 --> 39:27.380
他只是来处理什么远程请求

39:27.380 --> 39:29.380
还有什么

39:29.380 --> 39:31.380
异布

39:31.380 --> 39:32.380
乱七八糟的

39:32.380 --> 39:34.380
什么存出了本地文件之类的

39:34.380 --> 39:35.380
alcool storage

39:35.380 --> 39:36.380
这些东西

39:36.380 --> 39:38.380
带有副作用的东西

39:38.380 --> 39:39.380
那么他来处理

39:39.380 --> 39:40.380
他并不改变状态

39:40.380 --> 39:41.380
如果说他要改变状态的话

39:41.380 --> 39:43.380
他必须要重新去出发

39:43.380 --> 39:44.380
一个型来改变状态

39:44.380 --> 39:45.380
跟我们之前写的

39:45.380 --> 39:46.380
是不是一样的

39:46.380 --> 39:47.380
对吧

39:47.380 --> 39:48.380
跟我们之前写的是一样的

39:48.380 --> 39:49.380
是一样的

39:49.380 --> 39:50.380
那么这个里边

39:50.380 --> 39:51.380
每一个属性

39:51.380 --> 39:52.380
它还是个对象

39:52.380 --> 39:54.380
每一个还是一个函数

39:54.380 --> 39:56.380
那么比方说

39:56.380 --> 39:58.380
我们这里写一个异补加载

39:58.380 --> 40:00.380
异补增加

40:00.380 --> 40:02.380
increase

40:02.380 --> 40:03.380
一个异补增加函数

40:03.380 --> 40:05.380
那么这个函数里边

40:05.380 --> 40:06.380
有什么参数呢

40:06.380 --> 40:09.380
关键是这个函数里边有什么参数呢

40:09.380 --> 40:12.380
第一个参数就是x

40:12.380 --> 40:14.380
这是第一个参数

40:14.380 --> 40:16.380
第二个参数是一个对象

40:16.380 --> 40:20.460
我们这里记一笔

40:20.460 --> 40:23.460
每个函数

40:23.460 --> 40:25.460
函数的参数1

40:25.460 --> 40:28.460
是action对象

40:28.460 --> 40:29.460
参数2呢

40:29.460 --> 40:32.460
函数的参数2是一个

40:32.460 --> 40:35.460
就是封装好的

40:35.460 --> 40:37.460
封装好的

40:37.460 --> 40:39.460
就是saga

40:39.460 --> 40:42.460
而facts对象

40:42.460 --> 40:43.460
也就是说

40:43.460 --> 40:44.460
我们第二个参数呢

40:44.460 --> 40:45.460
是一个对象

40:45.460 --> 40:47.460
我们把一个对象打印出来

40:47.460 --> 40:48.460
我们看一下

40:48.460 --> 40:49.460
打印出来看一下

40:49.460 --> 40:50.460
你马上就明白了

40:50.460 --> 40:51.460
好

40:51.460 --> 40:52.460
打印出来

40:52.460 --> 40:53.460
注意这个函数

40:53.460 --> 40:55.460
这个函数的名字是什么

40:55.460 --> 40:57.460
这个函数的名字

40:57.460 --> 40:59.460
就是匹配的action

40:59.460 --> 41:01.460
当我们匹配到这个action的时候

41:01.460 --> 41:03.460
它会运行这个函数

41:03.460 --> 41:04.460
那么这个呢

41:04.460 --> 41:05.460
它是在处理副作用的

41:05.460 --> 41:07.460
而且它底层使用的是saga

41:07.460 --> 41:09.460
那么saga在处理副作用的时候

41:09.460 --> 41:10.460
那么这个函数

41:10.460 --> 41:11.460
是不是一个生成器

41:11.460 --> 41:12.460
生成器函数

41:12.460 --> 41:14.460
因此这里的函数

41:14.460 --> 41:16.460
也得写成生成器函数

41:16.460 --> 41:17.460
没有意思吗

41:17.460 --> 41:19.460
因为它本身这个函数

41:19.460 --> 41:21.460
就是交给saga来运行的

41:21.460 --> 41:22.460
所以说你这个函数

41:22.460 --> 41:24.460
也得写成生成器函数

41:24.460 --> 41:25.460
现在我们虽然说

41:25.460 --> 41:26.460
用不到这个生成器

41:26.460 --> 41:27.460
没关系

41:27.460 --> 41:28.460
我们先写到这

41:28.460 --> 41:29.460
这里呢

41:29.460 --> 41:30.460
比方说我们在

41:30.460 --> 41:31.460
组件里面再加一个

41:31.460 --> 41:32.460
再加一个按钮

41:32.460 --> 41:34.460
这是异步键

41:34.460 --> 41:36.460
异步

41:36.460 --> 41:38.460
异步键

41:38.460 --> 41:40.460
异步键

41:40.460 --> 41:42.460
unclick

41:42.460 --> 41:44.460
等于什么呢

41:44.460 --> 41:45.460
probs

41:45.460 --> 41:47.460
async

41:47.460 --> 41:49.460
increase

41:49.460 --> 41:51.460
然后还有一个异步键

41:51.460 --> 41:54.830
decrease

41:54.830 --> 41:58.530
这里是异步键

41:58.530 --> 42:00.530
又多写了两个事件

42:00.530 --> 42:02.530
这里是不是要传递

42:02.530 --> 42:03.530
对不对

42:03.530 --> 42:05.530
来吧

42:05.530 --> 42:06.530
async

42:06.530 --> 42:08.530
increase

42:08.530 --> 42:09.530
异步键

42:09.530 --> 42:11.530
异步键做什么呢

42:11.530 --> 42:12.530
异步键做什么呢

42:12.530 --> 42:14.530
是不是用dispatch

42:14.530 --> 42:16.530
dispatch一个x

42:16.530 --> 42:18.530
让那个负重用函数来处理

42:18.530 --> 42:19.530
那么这个东西

42:19.530 --> 42:20.530
reducer是不是获取不到

42:20.530 --> 42:21.530
reducer里面

42:21.530 --> 42:22.530
有没有这个async increase

42:22.530 --> 42:23.530
没有

42:23.530 --> 42:24.530
它获取不到

42:24.530 --> 42:25.530
所以说

42:25.530 --> 42:26.530
让谁来处理

42:26.530 --> 42:27.530
让saga的负重用函数来处理

42:27.530 --> 42:28.530
好

42:28.530 --> 42:29.530
那么这里呢

42:29.530 --> 42:30.530
counter

42:30.530 --> 42:34.530
然后是un async increase

42:34.530 --> 42:36.530
un async increase

42:36.530 --> 42:37.530
payload的没有

42:37.530 --> 42:38.530
没有payload的

42:38.530 --> 42:39.530
这里

42:39.530 --> 42:40.530
再来一个

42:40.530 --> 42:42.530
un async decrease

42:42.530 --> 42:43.530
那么这里是

42:43.530 --> 42:44.530
触发这个

42:44.530 --> 42:45.530
好

42:45.530 --> 42:46.530
负重用处理是不是得

42:46.530 --> 42:47.530
也得有两个函数

42:47.530 --> 42:49.530
一个是async increase

42:49.530 --> 42:50.530
这里

42:50.530 --> 42:51.530
不是un

42:51.530 --> 42:52.530
没有un

42:52.530 --> 42:53.530
原那边没有

42:53.530 --> 42:54.530
好

42:54.530 --> 42:55.530
写好了

42:55.530 --> 42:56.530
那这边是不是得写两个

42:56.530 --> 42:58.530
一个是increase的负重用处理

42:58.530 --> 43:01.530
一个是decrease的负重用处理

43:01.530 --> 43:02.530
好

43:02.530 --> 43:03.530
看一下

43:03.530 --> 43:04.530
咱们来看一下

43:04.530 --> 43:05.530
保存

43:05.530 --> 43:07.530
那么它肯定是

43:07.530 --> 43:09.530
肯定是要交给那个函数运行

43:09.530 --> 43:10.530
点异步键

43:10.530 --> 43:11.530
来看一下

43:11.530 --> 43:12.530
说打印出来一个对象

43:12.530 --> 43:13.530
打印出来一个对象

43:13.530 --> 43:14.530
异步键

43:14.530 --> 43:15.530
那我们来看一下

43:15.530 --> 43:16.530
一回发生非常熟悉

43:16.530 --> 43:17.530
call

43:17.530 --> 43:19.530
apply

43:19.530 --> 43:20.530
oh

43:20.530 --> 43:21.530
CPS

43:21.530 --> 43:22.530
cancel

43:22.530 --> 43:23.530
fork

43:23.530 --> 43:24.530
是啥

43:24.530 --> 43:25.530
就是不是去saga里面的

43:25.530 --> 43:26.530
复作用

43:26.530 --> 43:27.530
affect里面的

43:27.530 --> 43:29.530
处理函数

43:29.530 --> 43:30.530
对不对

43:30.530 --> 43:31.530
所以affect里面的处理函数

43:31.530 --> 43:32.530
ok

43:32.530 --> 43:33.530
比方说我们这里

43:33.530 --> 43:34.530
到时候要用什么

43:34.530 --> 43:35.530
我们就取什么

43:35.530 --> 43:37.530
这里面得到了就是

43:37.530 --> 43:39.530
saga里面的affect

43:39.530 --> 43:40.530
哎

43:40.530 --> 43:41.530
有没有说

43:41.530 --> 43:42.530
那这里面没有状态

43:42.530 --> 43:43.530
为什么没给我传状态

43:43.530 --> 43:44.530
你回忆一下

43:44.530 --> 43:46.530
saga里面还有没有给传状态

43:46.530 --> 43:47.530
saga的那个地方

43:47.530 --> 43:49.530
还有没有给传状态

43:49.530 --> 43:50.530
你回忆一下

43:50.530 --> 43:51.530
是不是没有

43:51.530 --> 43:52.530
它这个东西就是交给saga处理

43:52.530 --> 43:54.530
而且我们都能想象得到

43:54.530 --> 43:56.530
它内部给你写了一个什么

43:56.530 --> 43:57.530
你可以想象

43:57.530 --> 43:58.530
它内部给你写了这么一个东西

43:58.530 --> 43:59.530
比方说

43:59.530 --> 44:00.530
tech

44:00.530 --> 44:01.530
tech

44:01.530 --> 44:02.530
every

44:02.530 --> 44:03.530
对吧

44:03.530 --> 44:04.530
每当接受到什么

44:04.530 --> 44:05.530
x的时候

44:05.530 --> 44:06.530
每当接受到

44:06.530 --> 44:07.530
cancel

44:07.530 --> 44:08.530
每当接受到 counter

44:08.530 --> 44:09.530
cancel

44:09.530 --> 44:10.530
x的时候

44:10.530 --> 44:11.530
交给谁

44:11.530 --> 44:12.530
哪个函数

44:12.530 --> 44:13.530
函数来处理

44:13.530 --> 44:14.530
对吧

44:14.530 --> 44:15.530
交给这个函数来处理

44:15.530 --> 44:16.530
你可以这样的想象

44:16.530 --> 44:17.530
它给你写了这么一个东西

44:17.530 --> 44:18.530
然后又给你写了一个

44:18.530 --> 44:19.530
counter

44:19.530 --> 44:20.530
cancel

44:20.530 --> 44:21.530
decrease

44:21.530 --> 44:22.530
然后交给这个

44:22.530 --> 44:23.530
cancel

44:23.530 --> 44:24.530
decrease

44:24.530 --> 44:25.530
函数来处理

44:25.530 --> 44:26.530
对吧

44:26.530 --> 44:27.530
你可以这样的去想象

44:27.530 --> 44:28.530
它给写这么一个东西

44:28.530 --> 44:29.530
所以说每一次出发了

44:29.530 --> 44:30.530
相应的x型过后

44:30.530 --> 44:31.530
它就会交给相应的函数

44:31.530 --> 44:32.530
来进行处理

44:32.530 --> 44:33.530
好

44:33.530 --> 44:34.530
那么比方说

44:34.530 --> 44:35.530
点increase的时候

44:35.530 --> 44:36.530
它接受到了

44:36.530 --> 44:37.530
它交给这个函数来处理

44:37.530 --> 44:38.530
那么这个函数怎么来处理

44:38.530 --> 44:39.530
就跟之前的saga写法

44:39.530 --> 44:40.530
完全一样

44:40.530 --> 44:41.530
它把x

44:42.530 --> 44:43.530
可能带了payload

44:43.530 --> 44:44.530
你可能会需要

44:44.530 --> 44:45.530
可能会需要

44:45.530 --> 44:47.530
所以它可以完整的传进来了

44:47.530 --> 44:48.530
好 传进来之后

44:48.530 --> 44:50.530
后边有这么一个

44:50.530 --> 44:52.530
就是obj

44:52.530 --> 44:53.530
那么这个地方

44:53.530 --> 44:55.530
就是得到了所有的saga的affect

44:55.530 --> 44:56.530
那么这里就可以解构

44:56.530 --> 44:57.530
比方说我们这里

44:57.530 --> 44:58.530
比方说我们要延迟

44:58.530 --> 45:00.530
延迟两秒钟

45:00.530 --> 45:01.530
我们这里是不是可以解构

45:01.530 --> 45:02.530
解构这个对象里边

45:02.530 --> 45:03.530
是不是有delay

45:03.530 --> 45:04.530
对吧

45:04.530 --> 45:05.530
我们这里先

45:05.530 --> 45:07.530
eald

45:07.530 --> 45:08.530
delay

45:08.530 --> 45:09.530
两秒钟

45:09.530 --> 45:10.530
两秒钟之后

45:10.530 --> 45:12.530
我们再去出发什么

45:12.530 --> 45:13.530
我们再去

45:13.530 --> 45:14.530
我们先不出发

45:14.530 --> 45:16.530
一步加

45:16.530 --> 45:18.530
输出一句话

45:18.530 --> 45:20.530
好 那么下边是不是一样的

45:20.530 --> 45:22.530
延迟两秒钟

45:22.530 --> 45:23.530
delay

45:23.530 --> 45:24.530
因为saga里边有的

45:24.530 --> 45:26.530
affect这里都可以使用

45:26.530 --> 45:28.530
那么这里是一步解

45:28.530 --> 45:33.100
好 看一下吧

45:33.100 --> 45:35.100
点击一步加

45:35.100 --> 45:37.100
没错了

45:37.100 --> 45:39.100
再点一步加

45:39.100 --> 45:41.100
出错了

45:41.100 --> 45:42.100
出错了

45:42.100 --> 45:43.100
我们看一下怎么回事

45:43.100 --> 45:44.100
点击一步加

45:44.100 --> 45:46.730
看它包包了什么错

45:51.730 --> 45:56.420
delay is not a function

45:56.420 --> 45:58.420
delay

45:58.420 --> 46:01.420
它这里边没传delay吗

46:01.420 --> 46:04.420
它这里边没有传delay吗

46:04.420 --> 46:05.420
我们看一下

46:05.420 --> 46:06.420
打印出来看一下

46:06.420 --> 46:07.420
我们看一下

46:07.420 --> 46:11.250
它有没有传delay

46:11.250 --> 46:16.200
delay

46:16.200 --> 46:17.200
它还真没有传delay

46:17.200 --> 46:19.200
还真没有传delay

46:19.200 --> 46:21.200
那么delay

46:21.200 --> 46:22.200
它封装了

46:22.200 --> 46:24.200
封装了saga里面的副作用处理

46:24.200 --> 46:26.200
没有delay

46:26.200 --> 46:27.200
因为它觉得delay

46:27.200 --> 46:29.200
它一般是用来做测试的

46:29.200 --> 46:31.200
OK 这个也简单

46:31.200 --> 46:33.200
我们自己写这么一个delay就完事了

46:33.200 --> 46:35.200
写这么一个delay就完事了

46:35.200 --> 46:36.200
来吧

46:36.200 --> 46:37.200
我写一个delay

46:37.200 --> 46:39.200
特别简单

46:39.200 --> 46:41.200
写这么一个函数

46:41.200 --> 46:42.200
delay

46:42.200 --> 46:44.200
传入delay

46:44.200 --> 46:46.200
传入一个就是

46:46.200 --> 46:47.200
多少毫秒

46:47.200 --> 46:48.200
多少毫秒

46:48.200 --> 46:49.200
等待多少毫秒

46:49.200 --> 46:51.200
然后返回这个什么呢

46:51.200 --> 46:53.200
返回的就是一个call

46:53.200 --> 46:55.200
对 我这里得不到这个call

46:55.200 --> 46:57.200
那么我们返回一个promise

46:57.200 --> 46:59.200
new promise

46:59.200 --> 47:02.200
resolve

47:02.200 --> 47:05.200
在这里边写timeout

47:05.200 --> 47:07.200
量多少

47:07.200 --> 47:09.200
你紫禁的时间过后

47:09.200 --> 47:11.200
我们resolve

47:11.200 --> 47:12.200
因为我们知道在saga里边

47:12.200 --> 47:13.200
你得到一个promise

47:13.200 --> 47:14.200
它会进行等待

47:14.200 --> 47:15.200
resolve就完事了

47:15.200 --> 47:17.200
咱们就直接使用

47:17.200 --> 47:18.200
我们自己写的delay

47:18.200 --> 47:19.200
那么这里呢

47:19.200 --> 47:22.200
我们就可以使用它的call

47:22.200 --> 47:24.200
调用函数

47:24.200 --> 47:26.200
一有的call

47:26.200 --> 47:28.200
我们的delay函数

47:28.200 --> 47:29.200
运行我们的delay函数

47:29.200 --> 47:30.200
传入一个参数

47:30.200 --> 47:32.200
怎么传出呢 两秒钟

47:32.200 --> 47:33.200
两秒钟

47:33.200 --> 47:34.200
我们这里输出

47:34.200 --> 47:36.200
一步加

47:36.200 --> 47:38.200
这里复制过来

47:38.200 --> 47:40.200
这里是一步减

47:40.200 --> 47:45.400
这里是call

47:45.400 --> 47:46.400
调用我们的方法

47:46.400 --> 47:47.400
对吧

47:47.400 --> 47:49.400
就是返回一个promise

47:49.400 --> 47:50.400
我们都知道

47:50.400 --> 47:51.400
它会等待

47:51.400 --> 47:52.400
保存

47:52.400 --> 47:54.400
咱们再看一下

47:54.400 --> 47:57.840
这里点一步加

47:57.840 --> 47:58.840
两秒钟之后

47:58.840 --> 47:59.840
是不是出现这个

47:59.840 --> 48:01.840
点一步减

48:01.840 --> 48:02.840
两秒钟之后

48:02.840 --> 48:03.840
是不是出现这个

48:03.840 --> 48:04.840
是不是就实现了

48:04.840 --> 48:05.840
好 那么现在

48:05.840 --> 48:06.840
如果说我们要

48:06.840 --> 48:08.840
要改变它的值怎么办

48:08.840 --> 48:09.840
就两秒钟之后

48:09.840 --> 48:10.840
要增加

48:10.840 --> 48:11.840
改变它的值怎么办

48:11.840 --> 48:12.840
是不是我们以前

48:12.840 --> 48:13.840
学saga的时候

48:13.840 --> 48:14.840
是不是要用put

48:14.840 --> 48:16.840
put重新去触发x型

48:16.840 --> 48:17.840
重新触发x型

48:17.840 --> 48:18.840
来呗

48:18.840 --> 48:20.840
put重新触发x型

48:20.840 --> 48:22.840
内行是什么内行

48:22.840 --> 48:23.840
内行是咋的内行

48:23.840 --> 48:24.840
counter

48:24.840 --> 48:25.840
鞋杠

48:25.840 --> 48:26.840
鞋杠什么

48:26.840 --> 48:27.840
increase

48:27.840 --> 48:28.840
对吧 是不是

48:28.840 --> 48:29.840
我们要触发这个

48:29.840 --> 48:30.840
触发这个reducer

48:30.840 --> 48:31.840
让这个reducer去执行

48:31.840 --> 48:32.840
对吧

48:32.840 --> 48:33.840
好 咱们来试一下

48:33.840 --> 48:35.840
看行不行

48:35.840 --> 48:38.840
点击一步加

48:38.840 --> 48:39.840
是不是增加了

48:39.840 --> 48:41.840
对吧 增加了

48:41.840 --> 48:42.840
你看一下

48:42.840 --> 48:44.840
它触发了x型

48:44.840 --> 48:45.840
触发了x型

48:45.840 --> 48:46.840
最终

48:46.840 --> 48:48.840
我们这里重新来

48:48.840 --> 48:50.840
然后点击一步加

48:50.840 --> 48:52.840
两秒钟之后

48:52.840 --> 48:53.840
你看一下

48:53.840 --> 48:54.840
它触发的

48:54.840 --> 48:56.840
我们最开始触发的是一步加

48:56.840 --> 48:58.840
是不是async increase

48:58.840 --> 48:59.840
对吧

48:59.840 --> 49:00.840
increase

49:00.840 --> 49:02.840
然后它最终又触发了increase

49:02.840 --> 49:03.840
那么这个玩意是咋

49:03.840 --> 49:04.840
这个玩意是咋

49:04.840 --> 49:05.840
我们先不管

49:05.840 --> 49:06.840
这个玩意是咋

49:06.840 --> 49:07.840
这个玩意是咋

49:07.840 --> 49:08.840
先不管

49:08.840 --> 49:09.840
那么这里最终

49:09.840 --> 49:10.840
是不是触发了increase

49:10.840 --> 49:11.840
那么它这里

49:11.840 --> 49:12.840
可以包了一个警告

49:12.840 --> 49:13.840
它说什么意思

49:13.840 --> 49:14.840
如果说你在内部

49:14.840 --> 49:15.840
使用

49:15.840 --> 49:17.840
你在这个模型内部

49:17.840 --> 49:18.840
就在这个模型里边

49:18.840 --> 49:20.840
在内部去使用这个

49:20.840 --> 49:23.840
触发去触发那个action的话

49:23.840 --> 49:25.840
你是不用去跟上这个前綴的

49:25.840 --> 49:27.840
你是不用跟上前綴的

49:27.840 --> 49:28.840
它就这么个意思

49:28.840 --> 49:30.840
它说就是 counter increase

49:30.840 --> 49:32.840
should not be prefixed

49:32.840 --> 49:34.840
with name space counter

49:34.840 --> 49:35.840
也就是说

49:35.840 --> 49:36.840
你本身就是 counter

49:36.840 --> 49:38.840
本身就是 counter

49:38.840 --> 49:39.840
本身就是个模型

49:39.840 --> 49:41.840
那么你在自己模型内部的话

49:41.840 --> 49:43.840
你是没有必要加上这个前綴的

49:43.840 --> 49:44.840
它就这么个意思

49:44.840 --> 49:46.840
所以在外面必须要加

49:46.840 --> 49:47.840
在外面必须要加

49:47.840 --> 49:48.840
在模型内部的话

49:48.840 --> 49:49.840
是不用加的

49:49.840 --> 49:51.840
你可以直接写这个increase

49:51.840 --> 49:53.840
咱们来看一下

49:53.840 --> 49:55.840
这里我们把这个清空

49:55.840 --> 49:56.840
清空了

49:56.840 --> 49:59.660
这里一部加

49:59.660 --> 50:00.660
是不是变成一大

50:00.660 --> 50:01.660
然后我们来看一下

50:01.660 --> 50:03.660
它的触发的action的时候

50:03.660 --> 50:04.660
是不是还是吧

50:04.660 --> 50:06.660
自动的把前维给你加上了

50:06.660 --> 50:07.660
在模型内部

50:07.660 --> 50:09.660
它会自动的把前维给你加上

50:09.660 --> 50:11.660
但是如果说

50:11.660 --> 50:14.660
你要触发别的reducer执行的话

50:14.660 --> 50:15.660
比方到这里

50:15.660 --> 50:17.660
我要去触发另外一个reducer执行

50:17.660 --> 50:18.660
就是触发一个action

50:18.660 --> 50:20.660
让别的模型里边reducer执行

50:20.660 --> 50:21.660
那就必须要加前维了

50:21.660 --> 50:22.660
比方说你要触发

50:22.660 --> 50:24.660
student里边的东西

50:24.660 --> 50:25.660
那是不是要加前维

50:25.660 --> 50:26.660
这就要加前维了

50:26.660 --> 50:27.660
就这么个意思

50:27.660 --> 50:29.660
如果说自己的不用加前维

50:29.660 --> 50:31.660
那么一会儿的一部减

50:31.660 --> 50:33.660
一部减的话就是

50:33.660 --> 50:35.660
decrease

50:35.660 --> 50:37.660
put

50:37.660 --> 50:39.660
之前的saga怎么用

50:39.660 --> 50:41.660
在这个函数里面就怎么用

50:41.660 --> 50:43.660
它会去匹配这个action

50:43.660 --> 50:45.660
会运行这个函数

50:45.660 --> 50:46.660
这里我们看一下

50:46.660 --> 50:48.660
一部减

50:48.660 --> 50:49.660
一部加

50:49.660 --> 50:51.660
我们是一秒钟

50:51.660 --> 50:52.660
一秒钟

50:52.660 --> 50:53.660
这样太长了

50:53.660 --> 50:54.660
保存

50:54.660 --> 50:55.660
重来

50:55.660 --> 50:56.660
一部加

50:56.660 --> 50:58.660
一部加

50:58.660 --> 50:59.660
一部减

50:59.660 --> 51:01.660
一部减

51:01.660 --> 51:02.660
开玩笑

51:02.660 --> 51:03.660
搞定了

51:03.660 --> 51:04.660
好 OK

51:04.660 --> 51:05.660
当然了

51:05.660 --> 51:06.660
这里边如果说

51:06.660 --> 51:07.660
你要获取仓库状态的话

51:07.660 --> 51:08.660
是不是用slag车

51:08.660 --> 51:09.660
对吧

51:09.660 --> 51:10.660
跟那个就是saga

51:10.660 --> 51:11.660
是完全一样的

51:11.660 --> 51:12.660
我就不再去数了

51:12.660 --> 51:13.660
总之这里边就写了

51:13.660 --> 51:15.660
是saga副作用

51:15.660 --> 51:16.660
这就是

51:16.660 --> 51:18.660
这个模型里边的

51:18.660 --> 51:20.660
这个affect

51:20.660 --> 51:21.660
接下来

51:21.660 --> 51:23.660
模型里边除了有affect之外

51:23.660 --> 51:25.660
还有什么subscription

51:25.660 --> 51:26.660
那么这个东西是做什么

51:26.660 --> 51:30.660
它是一个对象

51:30.660 --> 51:33.660
配置为一个对象

51:33.660 --> 51:35.660
该对象中

51:35.660 --> 51:39.660
可以写任意数量

51:40.660 --> 51:44.660
任意名称的数项

51:44.660 --> 51:47.660
每个数项

51:47.660 --> 51:50.660
每个数项是一个函数

51:50.660 --> 51:52.660
这些函数

51:52.660 --> 51:55.660
会在模型

51:55.660 --> 51:58.660
加入到仓库中

51:58.660 --> 52:01.660
后立即运行

52:01.660 --> 52:03.660
就是subscription

52:03.660 --> 52:04.660
什么意思呢

52:04.660 --> 52:06.660
就相当于是注册这么一个

52:06.660 --> 52:07.660
订阅者

52:07.660 --> 52:08.660
订阅这个模型

52:08.660 --> 52:09.660
那么这里边

52:09.660 --> 52:10.660
其实就是配置的一个对象

52:10.660 --> 52:11.660
它没有那么复杂

52:11.660 --> 52:12.660
特别简单

52:12.660 --> 52:14.660
这个东西有的时候还蛮有用的

52:14.660 --> 52:16.660
但是目前我们这些

52:16.660 --> 52:17.660
可能还设计不到它

52:17.660 --> 52:19.660
subscription

52:19.660 --> 52:21.660
这里边有很多函数

52:21.660 --> 52:23.660
比方说M1

52:23.660 --> 52:24.660
这是个函数

52:24.660 --> 52:26.660
我们这里M1

52:26.660 --> 52:28.660
execute

52:28.660 --> 52:29.660
执行了

52:29.660 --> 52:31.660
然后这是一个函数

52:31.660 --> 52:33.660
然后M2

52:33.660 --> 52:35.660
这是一个函数

52:35.660 --> 52:36.660
M2执行了

52:36.660 --> 52:37.660
就完了

52:37.660 --> 52:39.660
随便写属性

52:39.660 --> 52:40.660
那么这些属性

52:40.660 --> 52:41.660
它作为函数

52:41.660 --> 52:42.660
它都会被执行

52:42.660 --> 52:43.660
保存你看一下

52:43.660 --> 52:44.660
什么M1执行了

52:44.660 --> 52:45.660
M2也执行了

52:45.660 --> 52:47.660
那么之后执不执行了

52:47.660 --> 52:48.660
你看之后是不是不再执行了

52:48.660 --> 52:49.660
对吧

52:49.660 --> 52:51.660
之后这个函数也不再执行了

52:51.660 --> 52:52.660
它就最开始执行一次

52:52.660 --> 52:54.660
那么这就可以让你

52:54.660 --> 52:55.660
在最开始的时候

52:55.660 --> 52:56.660
做一些

52:56.660 --> 52:58.660
做一些操作

52:58.660 --> 52:59.660
那么到底要做

52:59.660 --> 53:01.660
到底能够做什么操作呢

53:01.660 --> 53:02.660
这里边

53:02.660 --> 53:03.660
这里边每一个函数

53:03.660 --> 53:05.660
它还会给你传参数

53:05.660 --> 53:06.660
我们这里呢

53:06.660 --> 53:07.660
给它写这么一个参数

53:07.660 --> 53:08.660
OB界

53:08.660 --> 53:09.660
它传的是个对象

53:09.660 --> 53:10.660
我们把这个对象打印出来

53:10.660 --> 53:12.660
给大家看一下

53:12.660 --> 53:13.660
保存

53:13.660 --> 53:14.660
你看对象里边

53:14.660 --> 53:15.660
就两个属性

53:15.660 --> 53:16.660
一个Dispatch

53:16.660 --> 53:17.660
什么东西

53:17.660 --> 53:18.660
是不是触发Action的

53:18.660 --> 53:20.660
一个是History

53:20.660 --> 53:21.660
对吧

53:21.660 --> 53:22.660
History

53:22.660 --> 53:23.660
那么就是我们的

53:23.660 --> 53:25.660
Rotor里边的History对象

53:25.660 --> 53:26.660
当然这个History

53:26.660 --> 53:28.660
我们目前还用不到

53:28.660 --> 53:29.660
目前还用不到

53:29.660 --> 53:30.660
因为我们这几颗

53:30.660 --> 53:31.660
不涉及到路由

53:31.660 --> 53:32.660
那么比方说

53:32.660 --> 53:33.660
我们这里能做啥呢

53:33.660 --> 53:35.660
我们就可以处理一些

53:35.660 --> 53:37.660
比方说一些订阅事件

53:37.660 --> 53:38.660
一些订阅事件

53:38.660 --> 53:39.660
比方说

53:39.660 --> 53:40.660
比方说我们这里

53:40.660 --> 53:43.660
给大家写上这么一个就是

53:43.660 --> 53:45.660
Resize

53:45.660 --> 53:48.660
Resize Increase

53:48.660 --> 53:49.660
写这么一个方法

53:49.660 --> 53:50.660
一个方法名字的

53:50.660 --> 53:51.660
我们自己读的懂就行了

53:51.660 --> 53:53.660
名字实际上是随便写的

53:53.660 --> 53:54.660
每一个方法

53:54.660 --> 53:55.660
我们就处理一方面的事情

53:55.660 --> 53:56.660
比方说

53:56.660 --> 53:57.660
这个方法干嘛呢

53:57.660 --> 53:58.660
这个方法就是

53:58.660 --> 54:00.660
订阅就是

54:00.660 --> 54:02.660
窗口尺寸变化

54:02.660 --> 54:04.660
订阅窗口的尺寸变化

54:04.660 --> 54:06.660
每次变化

54:06.660 --> 54:08.660
每次变化

54:08.660 --> 54:10.660
让数字加一

54:10.660 --> 54:12.660
数字增加

54:12.660 --> 54:13.660
你看看我们可以这样做

54:13.660 --> 54:15.660
就是在模型安装好了过后

54:15.660 --> 54:16.660
安装到低发过后

54:16.660 --> 54:18.660
我们马上去订阅一个

54:18.660 --> 54:19.660
这个东西

54:19.660 --> 54:20.660
就是它只会

54:20.660 --> 54:21.660
因为它只会运行一次

54:21.660 --> 54:22.660
所以说我们特别适合

54:22.660 --> 54:23.660
去订阅一些数

54:23.660 --> 54:25.660
订阅一些事件

54:25.660 --> 54:26.660
比方说我们这里呢

54:26.660 --> 54:28.660
这里我们

54:28.660 --> 54:29.660
把这里解构

54:29.660 --> 54:30.660
不是它里边有Dispatch吗

54:30.660 --> 54:31.660
对吧

54:31.660 --> 54:32.660
一会儿能让数字增加

54:32.660 --> 54:33.660
是不是要重新触发X

54:33.660 --> 54:34.660
对吧

54:34.660 --> 54:35.660
好我们这里就可以这样子去

54:35.660 --> 54:37.660
我们用Windows

54:37.660 --> 54:39.660
Unrecise

54:39.660 --> 54:41.660
订阅一个

54:41.660 --> 54:42.660
订阅一个就是

54:42.660 --> 54:44.660
窗口改变的时间

54:44.660 --> 54:45.660
然后每次窗口改变

54:45.660 --> 54:46.660
我们干嘛呢

54:46.660 --> 54:47.660
Dispatch

54:47.660 --> 54:48.660
触发一个X

54:48.660 --> 54:49.660
太不为什么呢

54:49.660 --> 54:52.660
太不为就为increase

54:52.660 --> 54:53.660
保存

54:53.660 --> 54:55.660
看一下吧

54:55.660 --> 54:56.660
我们这里改变

54:56.660 --> 54:57.660
这个窗口尺寸

54:57.660 --> 54:58.660
你看数字是不是增加

54:58.660 --> 54:59.660
对吧

54:59.660 --> 55:00.660
数字在增加

55:00.660 --> 55:01.660
你看这个意思吗

55:01.660 --> 55:03.660
因为它这个函数只运行一次

55:03.660 --> 55:04.660
它就不会导致重复的

55:04.660 --> 55:05.660
去注册这些时间

55:05.660 --> 55:07.660
所以说我们可以在最开始

55:07.660 --> 55:08.660
这个模型安装好过后

55:08.660 --> 55:10.660
跟这个模型可能会

55:10.660 --> 55:12.660
跟一些事件相关联

55:12.660 --> 55:13.660
那么我们跟

55:13.660 --> 55:14.660
事件相关联的时候

55:14.660 --> 55:15.660
我们就可以在这个函数里边

55:15.660 --> 55:16.660
进行处理

55:16.660 --> 55:18.660
它给你提供了一个Dispatch

55:18.660 --> 55:20.660
给你提供了一个History

55:20.660 --> 55:22.660
就这么个意思

55:22.660 --> 55:25.660
那么如果说我们看一下

55:25.660 --> 55:27.660
再来看一下

55:27.660 --> 55:28.660
台这个地方就是

55:28.660 --> 55:29.660
触发了内行的话

55:29.660 --> 55:31.660
如果说你改变了就是本模型

55:31.660 --> 55:32.660
你触发的就是

55:32.660 --> 55:34.660
当前模型里边的X型的话

55:34.660 --> 55:36.660
那么你可以不用加钱罪

55:36.660 --> 55:38.660
反正是在这个模型内部

55:38.660 --> 55:40.660
都可以不用加钱罪

55:40.660 --> 55:41.660
比方说我们还可以去注册

55:41.660 --> 55:42.660
另外一个事件员

55:42.660 --> 55:43.660
另外一个事员

55:43.660 --> 55:44.660
不过这个事员

55:44.660 --> 55:45.660
我们现在不好演示

55:45.660 --> 55:48.660
Resize Decrease

55:48.660 --> 55:49.660
好那么这里边

55:49.660 --> 55:50.660
我们

55:50.660 --> 55:52.660
解构出Dispatch

55:52.660 --> 55:53.660
解构出那个History

55:53.660 --> 55:55.660
因为我知道这个History对象

55:55.660 --> 55:56.660
它有一个特点

55:56.660 --> 55:57.660
有这么一个特点

55:57.660 --> 55:58.660
History对象

55:58.660 --> 56:00.660
其实也可以演示

56:00.660 --> 56:01.660
它里边不是一个Nation

56:01.660 --> 56:02.660
对吧

56:02.660 --> 56:03.660
我们之前学过的

56:03.660 --> 56:04.660
Rotor6里边说一个Nation

56:04.660 --> 56:05.660
对不对

56:05.660 --> 56:06.660
Nation

56:06.660 --> 56:08.660
那么这个Nation里边

56:08.660 --> 56:10.660
我们每一次发现

56:10.660 --> 56:12.660
路由变化了之后

56:12.660 --> 56:14.660
每一次路由发生变化之后

56:14.660 --> 56:15.660
我们干嘛呢

56:15.660 --> 56:17.660
又去Dispatch一个

56:17.660 --> 56:20.660
Type为Decrease

56:20.660 --> 56:21.660
对不对

56:21.660 --> 56:23.660
我们又去Dispatch这个

56:23.660 --> 56:24.660
我们就可以

56:24.660 --> 56:25.660
增加不同的时间订阅

56:25.660 --> 56:26.660
那么为什么

56:26.660 --> 56:27.660
还不给你写一个

56:27.660 --> 56:28.660
凡数就完事了

56:28.660 --> 56:29.660
为什么给你写个对象

56:29.660 --> 56:30.660
让你写多个函数呢

56:30.660 --> 56:31.660
就是因为你可以

56:31.660 --> 56:32.660
处理不同方面的事情

56:32.660 --> 56:34.660
便于代码分理分开

56:34.660 --> 56:35.660
甚至呢

56:35.660 --> 56:36.660
你可以把这个函数

56:36.660 --> 56:37.660
是不是寄到一个文件里边去

56:37.660 --> 56:38.660
对吧

56:38.660 --> 56:40.660
把整个这个订阅东西

56:40.660 --> 56:41.660
订阅东西

56:41.660 --> 56:42.660
是不是寄到一个文件里面去

56:42.660 --> 56:43.660
导出一个对象

56:43.660 --> 56:44.660
然后呢这里直接导入

56:44.660 --> 56:45.660
那个东西就可以分模块了

56:45.660 --> 56:46.660
它是属于

56:46.660 --> 56:48.660
就是其这么一个作用

56:48.660 --> 56:49.660
好保存

56:49.660 --> 56:50.660
你看一下

56:50.660 --> 56:51.660
那么现在窗口改变呢

56:51.660 --> 56:53.660
窗口改变

56:53.660 --> 56:54.660
你看是没问题

56:54.660 --> 56:55.660
然后呢

56:55.660 --> 56:56.660
我们现在

56:56.660 --> 56:58.660
由于它是默认是哈欣路由

56:58.660 --> 56:59.660
默认是哈欣路由

56:59.660 --> 57:00.660
没关系

57:00.660 --> 57:01.660
哈欣路由它不会导致刷新界面

57:01.660 --> 57:02.660
我们改变一下路由

57:02.660 --> 57:04.660
你看是不是减少了

57:04.660 --> 57:06.660
你看是不是减少了

57:06.660 --> 57:07.660
路由变化

57:07.660 --> 57:08.660
我们这里是不是可以监听到了

57:08.660 --> 57:09.660
对吧

57:09.660 --> 57:10.660
像这些事情呢

57:10.660 --> 57:11.660
我们就可以寄到订阅里边

57:11.660 --> 57:13.660
订阅这个配置呢

57:13.660 --> 57:14.660
就是做这件事情的

57:14.660 --> 57:15.660
好

57:15.660 --> 57:17.660
这就是saga里边

57:17.660 --> 57:19.660
注意重要的一个方法

57:19.660 --> 57:20.660
model这个方法

57:20.660 --> 57:21.660
如何去使用

57:21.660 --> 57:22.660
它是用来做什么

57:22.660 --> 57:23.660
它是用来

57:23.660 --> 57:24.660
定义一个模型的

57:24.660 --> 57:25.660
这个定义模型呢

57:25.660 --> 57:26.660
你必须要写掉

57:26.660 --> 57:27.660
启动之前

57:27.660 --> 57:29.660
每一个模型的就是一个对象

57:29.660 --> 57:31.660
每一个模型就是一个对象

57:31.660 --> 57:32.660
那么这个对象里边呢

57:32.660 --> 57:34.660
你可以写很多东西

57:34.660 --> 57:35.660
哪些东西呢

57:35.660 --> 57:36.660
命名空间

57:36.660 --> 57:37.660
这个是跑不了的

57:37.660 --> 57:38.660
默认状态跑不了

57:38.660 --> 57:39.660
然后呢reducer是

57:39.660 --> 57:40.660
改变模型的方法

57:40.660 --> 57:41.660
然后呢

57:41.660 --> 57:42.660
而fix处理副作用

57:42.660 --> 57:44.660
或者是订阅

57:44.660 --> 57:46.660
如果说你没有副作用的话

57:46.660 --> 57:47.660
这个可以不写

57:47.660 --> 57:48.660
如果说你没有改变的话

57:48.660 --> 57:49.660
reducer可以不写

57:49.660 --> 57:50.660
没有订阅的话

57:50.660 --> 57:51.660
这个可以不写

57:51.660 --> 57:52.660
一般情况下呢

57:52.660 --> 57:53.660
是这个东西

57:53.660 --> 57:54.660
都没有

57:54.660 --> 57:55.660
没有怎么去写

57:55.660 --> 57:56.660
除非你真的是

57:56.660 --> 57:57.660
要跟一些事件挂钩

57:57.660 --> 57:58.660
好

57:58.660 --> 57:59.660
最后呢

57:59.660 --> 58:00.660
我们来看一下

58:00.660 --> 58:02.660
dba和官方给你的图

58:02.660 --> 58:04.980
一张图

58:04.980 --> 58:05.980
我们看一下

58:05.980 --> 58:07.980
它的图在哪呢

58:07.980 --> 58:09.980
我看一下

58:09.980 --> 58:13.670
它的图在哪

58:13.670 --> 58:14.670
dba的概念

58:14.670 --> 58:15.670
就当图

58:15.670 --> 58:17.670
我给大家把这个当图

58:17.670 --> 58:18.670
复制过来

58:18.670 --> 58:19.670
复制过来

58:19.670 --> 58:20.670
放到我们的

58:20.670 --> 58:22.670
就是这里

58:22.670 --> 58:23.670
这个图

58:23.670 --> 58:24.670
不算道用

58:25.670 --> 58:27.670
读书用的是能算道用吗

58:27.670 --> 58:29.670
不能算道用

58:29.670 --> 58:31.670
而且这个图本来就是公开的

58:32.670 --> 58:33.670
给大家看一下

58:33.670 --> 58:34.670
这个图

58:34.670 --> 58:35.670
那么我们

58:35.670 --> 58:37.670
了解了这么多知识过后

58:37.670 --> 58:38.670
因为发现这个图

58:38.670 --> 58:39.670
就很容易看懂了

58:39.670 --> 58:40.670
看着

58:40.670 --> 58:42.670
当我们得到一个地址

58:42.670 --> 58:43.670
我们拿到一个地址过后

58:43.670 --> 58:44.670
是不是可以开始

58:44.670 --> 58:45.670
来渲染我们的组建

58:45.670 --> 58:46.670
对吧

58:46.670 --> 58:47.670
我们

58:47.670 --> 58:48.670
通过一个地址访问

58:48.670 --> 58:49.670
我们的页面过后

58:49.670 --> 58:50.670
就开始来渲染组建了

58:50.670 --> 58:52.670
这个组建跟组建的是一个router

58:52.670 --> 58:53.670
我们目前

58:53.670 --> 58:54.670
的这几个还没有设计

58:54.670 --> 58:55.670
还没有设计

58:55.670 --> 58:56.670
还没有设计我们的

58:56.670 --> 58:57.670
就是

58:57.670 --> 58:58.670
还没有设计到我们的路由

58:58.670 --> 58:59.670
总之

58:59.670 --> 59:00.670
路由下面不是有很多组建吗

59:00.670 --> 59:01.670
对吧

59:01.670 --> 59:02.670
就是browserrouter

59:02.670 --> 59:03.670
哈希router这些东西

59:03.670 --> 59:04.670
路由组建下面

59:04.670 --> 59:05.670
不是有很多的组建吗

59:05.670 --> 59:06.670
植柱建

59:06.670 --> 59:07.670
这就是根组建

59:07.670 --> 59:09.670
这个植柱建渲染出来

59:09.670 --> 59:10.670
然后这些植柱建

59:10.670 --> 59:11.670
是不是有可能

59:11.670 --> 59:13.670
他当他用户进行

59:13.670 --> 59:14.670
某项操作的时候

59:14.670 --> 59:15.670
是不是会触发一个

59:15.670 --> 59:16.670
x

59:16.670 --> 59:17.670
对吧

59:17.670 --> 59:18.670
是不是会触发x

59:18.670 --> 59:19.670
我们刚才在这

59:19.670 --> 59:20.670
我们刚才在这

59:20.670 --> 59:21.670
渲染的组建

59:21.670 --> 59:22.670
这个组建里面

59:22.670 --> 59:23.670
简直会触发x

59:23.670 --> 59:24.670
好

59:24.670 --> 59:25.670
那么触发x过后了

59:25.670 --> 59:26.670
你看

59:26.670 --> 59:27.670
x交给谁了

59:27.670 --> 59:28.670
是不是要交给两个东西

59:28.670 --> 59:29.670
一个是交给arphagus

59:29.670 --> 59:30.670
来处理

59:30.670 --> 59:31.670
一个是交给reducer

59:31.670 --> 59:32.670
来处理

59:32.670 --> 59:33.670
对吧

59:33.670 --> 59:34.670
这是我们模型里面配置的东西

59:34.670 --> 59:35.670
对吧

59:35.670 --> 59:36.670
模型里面是不是配置的东西

59:36.670 --> 59:37.670
reducer会处理

59:37.670 --> 59:38.670
arphagus也会处理

59:38.670 --> 59:40.670
当然他匹配道才会处理

59:40.670 --> 59:41.670
没匹配道就不会处理

59:41.670 --> 59:42.670
当然

59:42.670 --> 59:43.670
如果说你reducer的名字

59:43.670 --> 59:45.670
跟arphagus的名字是一样的

59:45.670 --> 59:47.670
那两个都会处理

59:47.670 --> 59:48.670
两个都会处理

59:48.670 --> 59:49.670
那谁先处理

59:49.670 --> 59:50.670
是不是reducer先处理

59:50.670 --> 59:51.670
reducer先处理

59:51.670 --> 59:52.670
然后再arphagus的处理

59:52.670 --> 59:53.670
跟那个saga的逻辑是一样的

59:53.670 --> 59:55.670
因为saga是先交给

59:55.670 --> 59:56.670
后续的reducer处理

59:56.670 --> 59:57.670
然后自己再处理

59:57.670 --> 59:58.670
对吧

59:58.670 --> 01:00:00.670
然后就这两个来处理

01:00:00.670 --> 01:00:03.670
reducer它会导致重新更改状态

01:00:03.670 --> 01:00:04.670
对吧

01:00:04.670 --> 01:00:05.670
只有reducer会导致重新更改状态

01:00:05.670 --> 01:00:06.670
状态一改

01:00:06.670 --> 01:00:07.670
那么就在Duckers里面

01:00:07.670 --> 01:00:08.670
倉库的数据改了

01:00:08.670 --> 01:00:09.670
那么是不是

01:00:09.670 --> 01:00:11.670
通过connegut

01:00:11.670 --> 01:00:12.670
把状态连接到

01:00:12.670 --> 01:00:14.670
相应的组建的时候

01:00:14.670 --> 01:00:15.670
那么这些组建也会得到

01:00:15.670 --> 01:00:16.670
相应的更改

01:00:16.670 --> 01:00:17.670
对吧

01:00:17.670 --> 01:00:18.670
就这么个意思

01:00:18.670 --> 01:00:19.670
好

01:00:19.670 --> 01:00:20.670
就是说

01:00:20.670 --> 01:00:22.670
如果说你匹配到老师arphagus的话

01:00:22.670 --> 01:00:23.670
arphagus他来处理副作用

01:00:23.670 --> 01:00:25.670
一般情况下

01:00:25.670 --> 01:00:26.670
副作用来做什么

01:00:26.670 --> 01:00:27.670
是不是来叫arcax请求

01:00:27.670 --> 01:00:28.670
那么arphagus呢

01:00:28.670 --> 01:00:31.670
是不是会跟服务器之间进行交互

01:00:31.670 --> 01:00:32.670
对吧

01:00:32.670 --> 01:00:33.670
跟服务器之间进行交互

01:00:33.670 --> 01:00:34.670
来做一些副作用

01:00:34.670 --> 01:00:35.670
arcax请求

01:00:35.670 --> 01:00:36.670
那么请求完了过后

01:00:36.670 --> 01:00:39.670
arphagus他又可能会导致

01:00:39.670 --> 01:00:40.670
arphagus里面又可能会触发

01:00:40.670 --> 01:00:42.670
他这个线就没画出来了

01:00:42.670 --> 01:00:43.670
你跟着我鼠标走

01:00:43.670 --> 01:00:45.670
那么arphagus是不是又会触发一个x

01:00:45.670 --> 01:00:46.670
对吧

01:00:46.670 --> 01:00:47.670
回到这

01:00:47.670 --> 01:00:48.670
arphagus又会触发一个x

01:00:48.670 --> 01:00:50.670
又会触发reducer

01:00:50.670 --> 01:00:51.670
导致状态变化

01:00:51.670 --> 01:00:52.670
就这么个流程

01:00:52.670 --> 01:00:54.670
还用了这个订阅的数据员

01:00:54.670 --> 01:00:55.670
如果说你有订阅的话

01:00:55.670 --> 01:00:56.670
那么在订阅里边

01:00:56.670 --> 01:00:58.670
是不是也有可能会触发x

01:00:58.670 --> 01:00:59.670
对吧

01:00:59.670 --> 01:01:01.670
在相应的时候也会触发x

01:01:01.670 --> 01:01:03.670
那么x又会交给arphagus和reducer

01:01:03.670 --> 01:01:04.670
对吧

01:01:04.670 --> 01:01:05.670
来进行处理

01:01:05.670 --> 01:01:07.670
就是这么一个逻辑

01:01:07.670 --> 01:01:08.670
好好看一下这张图

01:01:08.670 --> 01:01:09.670
你就基本上了解了

01:01:09.670 --> 01:01:11.670
这个saga的整个处理流程

01:01:11.670 --> 01:01:12.670
其实这个saga的处理流程

01:01:12.670 --> 01:01:14.670
跟那个redax有啥区别呢

01:01:14.670 --> 01:01:16.670
就是跟redax加saga

01:01:16.670 --> 01:01:17.670
没有多少区别

01:01:17.670 --> 01:01:18.670
没有多少区别

01:01:18.670 --> 01:01:20.670
这里可能我们重点就讲了model

01:01:20.670 --> 01:01:21.670
还没有设计路由

01:01:21.670 --> 01:01:23.670
路由也挺简单的

01:01:23.670 --> 01:01:24.670
下一集可能我们讲了

01:01:24.670 --> 01:01:25.670
讲路由

01:01:25.670 --> 01:01:28.670
以及相关的就是

01:01:28.670 --> 01:01:30.670
那个dba的配置

01:01:30.670 --> 01:01:31.670
因为我们配置还没有讲

01:01:31.670 --> 01:01:32.670
我们当时讲那个

01:01:32.670 --> 01:01:33.670
创建dba对象的时候

01:01:33.670 --> 01:01:34.670
这里有很多配置

01:01:34.670 --> 01:01:35.670
这里为什么报一个警告

01:01:35.670 --> 01:01:37.670
就是因为你没有配置

01:01:37.670 --> 01:01:39.670
没有配置

01:01:39.670 --> 01:01:40.670
你看这是什么

01:01:40.670 --> 01:01:41.670
那么这里呢

01:01:41.670 --> 01:01:42.670
它是可以写很多配置的

01:01:42.670 --> 01:01:44.670
我们下集会再想想

01:01:44.670 --> 01:01:45.670
再讲

