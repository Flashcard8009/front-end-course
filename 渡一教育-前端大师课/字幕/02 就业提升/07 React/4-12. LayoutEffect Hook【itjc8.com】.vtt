WEBVTT

00:00.500 --> 00:03.500
下一个 下一个 hook

00:03.820 --> 00:08.380
这个 hook 呢 叫做 layout effect hook

00:08.880 --> 00:11.260
要讲清楚这个 hook 的话

00:11.720 --> 00:14.980
就是说大家呢 得了解一个知识

00:14.980 --> 00:16.300
什么知识呢

00:16.540 --> 00:19.280
就是说这个我们平时呢

00:19.880 --> 00:22.320
在对真实的动物进行操作的时候啊

00:22.320 --> 00:24.980
比方说我们设置了一个dom.inner

00:24.980 --> 00:28.020
哎 天呐 给它设置为啥啊

00:28.740 --> 00:29.420
对吧

00:29.420 --> 00:32.180
或者说 设置了什么dom.style

00:32.180 --> 00:34.740
啊 等于啥啥

00:34.740 --> 00:36.100
对吧 我们以前呢

00:36.100 --> 00:39.220
学习原生介事的时候呢 讲过了个dom操作

00:39.220 --> 00:42.220
那么我们可能会改变页面的dom结构

00:42.220 --> 00:44.820
或者是dom的样式 或者是dom的内容

00:45.540 --> 00:47.700
那么改动这些的时候呢

00:47.700 --> 00:51.780
最终它会在页面上呈现出一个新的效果

00:51.780 --> 00:53.660
就之前的效果不见了

00:53.660 --> 00:55.140
出现了一个新的效果

00:55.140 --> 00:57.020
那么我们这里呢 你得知道

00:57.060 --> 00:59.300
它这个过程中发生了什么事

00:59.300 --> 01:02.060
你才能理解这个layout effect hook

01:02.060 --> 01:03.740
它到底是什么意思

01:03.740 --> 01:05.300
那它发生了什么事呢

01:05.300 --> 01:07.260
我给大家画一张图啊

01:07.260 --> 01:08.780
画一张图 大家就明白了

01:08.780 --> 01:11.020
我们这里随便找个pvt吧

01:11.020 --> 01:15.000
啊 画一张图 先建一个

01:16.360 --> 01:17.960
呃 就是这样子的

01:17.960 --> 01:20.280
就是说我们呢 在代码里边

01:20.280 --> 01:22.480
去对dom进行的改动 对吧

01:22.480 --> 01:25.400
对dom进行了改动

01:26.040 --> 01:27.720
那是不是立即导致呢

01:27.720 --> 01:29.240
立即的导致呢

01:29.240 --> 01:31.360
页面上出现了新的效果呢

01:31.360 --> 01:32.960
实际上是不是的

01:32.960 --> 01:34.680
怎么来验证这一点呢

01:34.680 --> 01:35.800
其实不好验证啊

01:35.800 --> 01:38.520
是真的真的不好验证

01:38.520 --> 01:41.720
呃 我给大家说一下这个道理吧

01:41.720 --> 01:42.880
让大家说一下这个道理

01:44.320 --> 01:45.560
看一下吧

01:45.560 --> 01:46.480
就比方说呢

01:46.480 --> 01:47.800
这里这个页面上呢

01:47.800 --> 01:49.480
我们直接操作真实动物啊

01:49.480 --> 01:50.960
页面上不是有div吗

01:50.960 --> 01:52.360
对不对 id为route

01:52.360 --> 01:54.600
好吧 那咱们来得到这个div

01:54.600 --> 01:58.240
document getsElement by idroute

01:58.240 --> 01:59.800
这个div 拿到

01:59.800 --> 02:00.680
拿到之后呢

02:00.680 --> 02:02.120
咱们这样子啊

02:02.120 --> 02:03.400
InnerAtmere

02:03.400 --> 02:04.880
给它设置一个abc

02:04.880 --> 02:06.120
随便写写啊

02:06.120 --> 02:09.680
然后再设置InnerAtmere啊

02:09.680 --> 02:12.520
给它复制为什么123

02:12.520 --> 02:13.600
然后再来啊

02:13.600 --> 02:16.920
再来 我们先暂时不着急运行啊

02:16.920 --> 02:20.000
div style color 等于红色

02:20.000 --> 02:20.760
那里告诉我

02:20.760 --> 02:22.160
这个页面上

02:22.160 --> 02:24.160
它会渲染几次呢

02:24.160 --> 02:26.800
就是这个新的效果会渲染几次呢

02:26.800 --> 02:29.880
是不是只会渲染一次

02:29.880 --> 02:30.120
对吧

02:30.120 --> 02:31.200
这个应该知道吧

02:31.200 --> 02:33.000
你不能说这个东西都不知道啊

02:33.000 --> 02:34.040
一定是讲过的

02:34.040 --> 02:36.000
它只会渲染一次

02:36.000 --> 02:38.720
它会等到一会一起来进行渲染

02:38.720 --> 02:40.960
它不会说先把它渲染成abc

02:40.960 --> 02:42.600
然后再把它渲染成123

02:42.600 --> 02:44.560
然后再把它的颜色收为红色

02:44.560 --> 02:46.640
它是一起渲染的啊

02:46.640 --> 02:47.320
我们回车你看

02:47.320 --> 02:48.000
瞬间就出来了

02:48.000 --> 02:48.640
对吧

02:48.640 --> 02:50.200
它是一起渲染的

02:50.200 --> 02:50.680
所以说呢

02:50.680 --> 02:51.840
它有个过程啊

02:51.840 --> 02:53.640
它什么样的过程是这样子

02:53.680 --> 02:56.480
你对多么元素的进行的改动

02:56.480 --> 02:57.760
改动完了过后

02:57.760 --> 03:01.400
它不是说立即导致渲染

03:01.400 --> 03:03.240
它不会立即导致渲染

03:03.240 --> 03:05.000
它会等什么呢

03:05.000 --> 03:08.600
等浏览器下一次啊

03:08.600 --> 03:11.400
浏览器下一次

03:11.400 --> 03:15.440
渲染时间点到达

03:15.440 --> 03:16.400
什么意思呢

03:16.400 --> 03:17.280
浏览器呢

03:17.280 --> 03:22.000
你可以认为它是一个一个一个照相机

03:22.040 --> 03:23.680
它不停的去拍照

03:23.680 --> 03:24.560
不停的拍照

03:24.560 --> 03:26.720
但是拍照的每一次拍照之间呢

03:26.720 --> 03:29.120
是有个时间间隔的

03:29.120 --> 03:30.320
它拍照的时候呢

03:30.320 --> 03:31.400
它在看对比

03:31.400 --> 03:32.840
对比之前的照片

03:32.840 --> 03:34.360
之前的页面的照片

03:34.360 --> 03:37.320
跟现在这个新的多么元素改动

03:37.320 --> 03:38.480
有没有差异

03:38.480 --> 03:39.840
之前的多么数

03:39.840 --> 03:41.320
和现在的多么数有没有差异

03:41.320 --> 03:42.600
如果有差异的话

03:42.600 --> 03:44.320
那么它会重新渲染

03:44.320 --> 03:45.800
按照新的多么数来渲染

03:45.800 --> 03:46.840
它是这样子的

03:46.840 --> 03:49.120
也就是说我们对多么进行的改动过后

03:49.120 --> 03:51.280
是不是要得等一段时间啊

03:51.320 --> 03:52.840
非常非常短这个时间

03:52.840 --> 03:54.560
可能一般来说

03:54.560 --> 03:56.080
这个东西不能是一个定

03:56.080 --> 03:57.840
不是一个定值啊

03:57.840 --> 03:59.800
这个时间间隔不是一个定值

03:59.800 --> 04:02.560
它根据计算机配置不一样

04:02.560 --> 04:04.920
根据浏览器也类型不一样

04:04.920 --> 04:05.600
版本不一样

04:05.600 --> 04:06.600
都可能有差异

04:06.600 --> 04:10.720
一般来说是16.666

04:10.720 --> 04:12.880
16.666毫秒

04:12.880 --> 04:13.880
经过这么一段时间

04:13.880 --> 04:15.560
然后重新渲染页面

04:15.560 --> 04:16.600
是这么个意思啊

04:16.600 --> 04:17.680
是这么个意思

04:17.680 --> 04:19.600
所以说呢

04:19.600 --> 04:21.240
我们对多么进行的一大堆改动

04:21.240 --> 04:22.520
甭管你改动了多少次

04:22.520 --> 04:23.760
这是同步代码

04:23.760 --> 04:24.240
对吧

04:24.240 --> 04:25.360
这一块是同步代码

04:26.720 --> 04:29.200
它是从上到下依次运行的

04:29.200 --> 04:30.960
那么改动完了过后

04:30.960 --> 04:32.520
要等一会

04:32.520 --> 04:33.760
等到那个浏览器

04:33.760 --> 04:36.200
下一次拍照的时候

04:36.200 --> 04:39.080
那么它才会执行这些改动

04:39.080 --> 04:41.040
下一次渲染时间点到达过后了

04:41.040 --> 04:44.880
那么对比

04:45.680 --> 04:52.760
对比差异进行渲染

04:52.760 --> 04:54.160
这个时候才进行渲染

04:54.160 --> 04:56.160
说这个地方是一步的

04:56.160 --> 04:57.920
它不是说我们改动过后了

04:57.920 --> 04:58.520
马上渲染

04:58.520 --> 04:59.560
它只要等一会

04:59.560 --> 05:02.040
等到一定时间点到了的时候

05:02.040 --> 05:03.160
然后对比差异

05:03.160 --> 05:04.760
然后进行渲染

05:04.760 --> 05:06.360
所以你要理解这个东西

05:06.360 --> 05:08.640
然后我们才最终看到效果

05:08.640 --> 05:09.080
对吧

05:09.080 --> 05:11.320
最终用户看到效果

05:11.320 --> 05:14.400
用户看到新的效果

05:14.440 --> 05:16.520
中间是一段过程的

05:16.520 --> 05:18.160
那么我们之前学习了

05:18.160 --> 05:20.320
那个什么use effect对吧

05:20.320 --> 05:22.040
这个use effect

05:22.040 --> 05:23.320
这个玩意

05:23.320 --> 05:24.560
它的时间点是什么了

05:24.560 --> 05:26.600
它这个副作用的触发时间点

05:26.600 --> 05:29.440
是渲染完成后

05:29.440 --> 05:32.320
就是浏览器渲染完成后

05:32.320 --> 05:34.560
用户看到效果之后

05:34.560 --> 05:36.280
用户看到效果

05:36.280 --> 05:40.840
就是新的渲染结果之后

05:40.840 --> 05:43.120
那么这个时候才会运行use effect

05:43.120 --> 05:44.600
也就是说use effect

05:44.600 --> 05:45.680
它时间点是在这儿

05:47.600 --> 05:49.320
use effect

05:49.320 --> 05:50.240
它的时间点是在这儿

05:55.560 --> 05:56.160
我们看一下

05:57.840 --> 05:58.680
它的时间点是在这儿

06:00.360 --> 06:01.760
这样子就是说

06:01.760 --> 06:03.920
之前的结果已经拿到了

06:03.920 --> 06:07.720
现在我们又要做一些各种操作

06:07.720 --> 06:10.640
那么我们就在运行use effect

06:10.640 --> 06:12.720
通常情况下我们都使用

06:12.800 --> 06:16.760
比方说还有什么component

06:16.760 --> 06:17.400
不对

06:17.400 --> 06:19.000
component的帮手还不对

06:19.000 --> 06:20.800
那么这是use effect

06:20.800 --> 06:23.000
那么中间这一部分时间

06:23.000 --> 06:24.040
中间这一部分时间

06:24.040 --> 06:24.600
我划过来

06:24.600 --> 06:25.360
不然划不下了

06:30.260 --> 06:32.260
中间这一部分

06:32.260 --> 06:33.140
现在目前是这样子

06:35.180 --> 06:42.980
点过来

06:42.980 --> 06:44.860
好 这样子

06:44.860 --> 06:47.660
use effect它是在这个时间点运行

06:47.660 --> 06:49.060
但是有的时候

06:49.060 --> 06:50.820
我们可能希望是这样子

06:51.060 --> 06:55.300
它之前react对动物元素进行的改动

06:55.300 --> 06:57.180
这个时候我们不能操作的

06:57.180 --> 06:59.700
react是自行改动真实的动物元素的

06:59.700 --> 07:01.300
但是有的时候我们想

07:01.300 --> 07:03.900
手动的去控制一些真实的动物元素

07:03.900 --> 07:05.860
当然这种情况很少

07:05.860 --> 07:07.300
尽量不要去这样做

07:07.300 --> 07:08.580
就是有些副作用操作

07:08.580 --> 07:10.260
我们要控制真实的动物元素

07:10.260 --> 07:11.900
尽量不要去这样操作

07:11.900 --> 07:14.380
但是说如果你需要这样的操作的话

07:14.380 --> 07:18.180
那么我们可能希望不要等到太晚

07:18.180 --> 07:20.220
不要等到用户看到新的效果之后

07:20.420 --> 07:21.620
我再去运行这个

07:21.620 --> 07:23.660
那这个时间点实在是太晚了

07:23.660 --> 07:24.340
太晚了

07:24.340 --> 07:25.740
因为用户已经看到界面了

07:25.740 --> 07:26.900
目以成周了

07:26.900 --> 07:28.900
然后这个时候你再去改动真实动物元素

07:28.900 --> 07:30.700
是不是用户去看到散了一下

07:30.700 --> 07:31.340
对吧

07:31.340 --> 07:32.100
用户看到散了一下

07:32.100 --> 07:34.020
但这个太快了

07:34.020 --> 07:35.980
你可能根本就感觉不到

07:35.980 --> 07:37.420
因为它速度太快了

07:37.420 --> 07:39.260
看一下吧

07:39.260 --> 07:41.580
看一下我看能不能感知得到

07:41.580 --> 07:43.460
反正有的时候我感知得到

07:43.460 --> 07:44.500
有的时候感知不到

07:44.500 --> 07:46.140
这个速度太快了

07:46.140 --> 07:47.780
比方说我们这里有一个

07:48.780 --> 07:50.300
H元素

07:50.300 --> 07:54.260
H元素里边

07:54.260 --> 07:57.380
我们这里写上一个n

07:57.380 --> 07:58.980
我们这里是用useState

07:58.980 --> 08:00.660
useState

08:00.660 --> 08:04.260
useState

08:04.260 --> 08:08.420
这里我们写上一个useState

08:08.420 --> 08:10.260
这里写个n

08:10.260 --> 08:11.540
从零开始了

08:11.540 --> 08:13.220
这里有一个n

08:13.220 --> 08:17.060
接下来我们下面写个按钮

08:17.340 --> 08:19.620
加

08:19.620 --> 08:23.550
onclick

08:23.550 --> 08:25.430
点击过后我们 set n

08:25.430 --> 08:25.990
n加1

08:25.990 --> 08:27.790
这个很简单的一个代码

08:27.790 --> 08:28.350
保存

08:28.350 --> 08:29.910
看一下

08:29.910 --> 08:31.430
那么这里

08:31.430 --> 08:31.790
加

08:31.790 --> 08:32.830
一看就加了

08:32.830 --> 08:33.390
对不对

08:33.390 --> 08:33.590
好

08:33.590 --> 08:36.790
接下来我们再写一个副作用函数

08:37.990 --> 08:41.390
useFact

08:41.390 --> 08:43.350
举个例子都是举例子

08:43.350 --> 08:44.430
useFact

08:44.430 --> 08:47.150
它这里边我们做什么事情呢

08:47.150 --> 08:48.870
我每次渲染完过后

08:48.870 --> 08:50.910
我得到这个真实动物元素

08:50.910 --> 08:58.710
然后又把它的文字又改成

08:58.710 --> 09:02.870
改成一个水积数

09:02.870 --> 09:05.590
假设我们看一下有没有一个散动的效果

09:05.590 --> 09:10.830
这里我们使用setn

09:10.830 --> 09:13.950
setn

09:13.950 --> 09:15.390
这样子

09:15.390 --> 09:17.030
我们就不能使用setn了

09:17.030 --> 09:18.990
因为这里边是

09:18.990 --> 09:20.310
我们要写副作用操作

09:20.310 --> 09:22.150
直接改变真实动物元素

09:22.150 --> 09:24.390
我们这里写个ref

09:24.390 --> 09:29.530
我们还要使用useRef

09:29.530 --> 09:31.010
这里

09:31.010 --> 09:33.330
heRef

09:33.330 --> 09:35.890
useRef

09:35.890 --> 09:37.890
好 这里放过来

09:37.890 --> 09:40.010
我们这里找到这个he元素

09:40.010 --> 09:41.410
操作一个真实动物元素

09:41.410 --> 09:43.810
给它设置inner text

09:43.810 --> 09:45.010
把它设置为mess

09:45.010 --> 09:46.010
叫right down

09:46.010 --> 09:48.010
设置个水积数

09:48.010 --> 09:49.690
我们保留两位小数

09:49.730 --> 09:50.610
保留两位小数

09:50.610 --> 09:51.850
to fix

09:51.850 --> 09:52.690
两位小数

09:52.690 --> 09:53.490
保存

09:53.490 --> 09:56.440
看一下

09:56.440 --> 09:57.240
是不是散了一下

09:57.240 --> 09:58.520
你看到没有

09:58.520 --> 10:02.560
我这里不知道我这个录屏的帧数够不够

10:02.560 --> 10:03.000
放心

10:03.000 --> 10:03.480
你看

10:03.480 --> 10:04.560
所以一开始看到您

10:04.560 --> 10:06.400
然后看到这个7.6

10:06.400 --> 10:09.600
也就是它等到用户的界面显示出来过后

10:09.600 --> 10:11.160
然后再重新改变

10:11.160 --> 10:13.200
太快了

10:13.200 --> 10:14.960
是不是看到散了一下

10:14.960 --> 10:17.120
我真的不知道你们能不能看到

10:17.120 --> 10:18.360
我这里是能看到的

10:18.360 --> 10:20.160
它确实散了一下

10:20.200 --> 10:23.320
因为它界面它被渲染了两次

10:23.320 --> 10:24.800
第一次渲染完成

10:24.800 --> 10:26.640
已经看到新的数字了

10:26.640 --> 10:27.400
比方说2

10:27.400 --> 10:28.320
已经看到了

10:28.320 --> 10:30.080
结果又运行UserFact

10:30.080 --> 10:31.080
又运行这个

10:31.080 --> 10:33.440
那么这个运行它又导致了

10:33.440 --> 10:35.520
导致了又把它设为了一个水积数

10:35.520 --> 10:35.880
对吧

10:35.880 --> 10:37.000
还导致了设为水积数

10:37.000 --> 10:38.960
所以说用户看到之前的数字

10:38.960 --> 10:39.800
还没看清楚

10:39.800 --> 10:41.120
马上又晃了一下

10:41.120 --> 10:42.600
又变成一个水积数了

10:42.600 --> 10:45.960
所以说这是有这么一个缺陷

10:45.960 --> 10:47.880
当然这个东西并不算是缺陷

10:47.880 --> 10:51.600
因为不要去老是去操作真设动

10:51.600 --> 10:52.880
不然你用rex干嘛

10:53.400 --> 10:55.360
你直接用原生的就行了

10:55.360 --> 10:57.000
给你做了这么好的一个库出来

10:57.000 --> 10:58.760
你结果你跑去用真设动

10:58.760 --> 11:00.840
其实我们平时不应该用真设动

11:00.840 --> 11:02.120
就说有的时候

11:02.120 --> 11:05.120
如果真正的要需要操作真设动的话

11:05.120 --> 11:07.840
那么用这个UserFact就不太合适了

11:07.840 --> 11:09.640
它会看到一个散出的效果

11:09.640 --> 11:10.880
当然如果你要做阿加克斯

11:10.880 --> 11:12.720
那些无所谓

11:12.720 --> 11:14.160
因为它不会组设

11:14.160 --> 11:15.400
这样做其实有好处的

11:15.400 --> 11:16.280
什么好处呢

11:16.360 --> 11:18.240
它不会导致浏览器卡住

11:18.240 --> 11:20.520
因为浏览器已经渲染出来了

11:20.520 --> 11:22.320
已经渲染出了结果

11:22.320 --> 11:24.080
所以说用户已经看到结果了

11:24.080 --> 11:24.800
那么你这个时候

11:24.800 --> 11:26.920
就待续进行一些副作用操作的话

11:26.920 --> 11:29.040
它不会导致液面卡住

11:29.040 --> 11:30.760
那么另外一个时间点就是在这

11:32.120 --> 11:32.680
就在这

11:34.440 --> 11:35.760
这个时间点了

11:35.760 --> 11:38.520
是不是在浏览器渲染之前

11:38.520 --> 11:39.120
对吧

11:39.120 --> 11:41.200
在浏览器渲染之前

11:41.200 --> 11:43.040
那么做一些事情都还没有

11:43.040 --> 11:43.960
就是之前做了改动

11:43.960 --> 11:45.560
但是还没有真实的渲染

11:45.560 --> 11:47.560
那么这个时候去做一些事情

11:47.560 --> 11:49.200
那么这个时候是哪些函数呢

11:49.200 --> 11:49.720
就是

11:49.720 --> 11:51.200
component

11:51.200 --> 11:52.640
did mount

11:52.640 --> 11:54.040
已经

11:54.040 --> 11:55.440
component

11:55.440 --> 11:56.360
did

11:56.360 --> 11:57.280
update

11:57.280 --> 11:58.640
就这个时候

11:58.640 --> 12:00.440
就这些时候触发的函数

12:01.320 --> 12:04.520
那么这两个都是内组件里面的生命周期方法

12:04.520 --> 12:05.880
那么现在呢

12:05.880 --> 12:08.360
现在就是有了这个东西

12:08.360 --> 12:08.560
叫

12:08.560 --> 12:10.320
layout effect

12:10.320 --> 12:11.840
那么就是use

12:11.840 --> 12:13.680
layout effect

12:13.720 --> 12:14.400
这个方法呢

12:14.400 --> 12:17.240
它有点对应内组件里面的这两个方法

12:17.240 --> 12:18.800
就是这顺便就说了

12:18.800 --> 12:19.680
这个use effect

12:19.680 --> 12:21.600
跟这两个的区别对吧

12:21.600 --> 12:22.120
好

12:22.120 --> 12:25.360
那么这个方法是浏览器

12:25.360 --> 12:28.400
就是完成了多么改动

12:29.400 --> 12:33.680
但还没有呈现给用户

12:33.680 --> 12:35.560
也就是浏览器还没有完成渲染

12:35.560 --> 12:36.720
就这个时间点

12:36.720 --> 12:37.520
那么这个时间点了

12:37.520 --> 12:39.520
跟那个就这两个是一样的

12:39.520 --> 12:42.000
就是use

12:42.000 --> 12:43.640
layout

12:43.960 --> 12:45.120
effect

12:45.120 --> 12:46.920
它的用法跟那个use effect

12:46.920 --> 12:47.800
完全一样

12:47.800 --> 12:48.840
一点区别都没有

12:48.840 --> 12:49.800
什么一耐相

12:49.800 --> 12:51.760
还说全部没有任何区别

12:51.760 --> 12:53.800
只是说它的时间点在这

12:53.800 --> 12:55.240
就这个区别

12:55.240 --> 12:57.000
所以说我们现在再看一下

12:57.000 --> 13:00.640
如果说我把这个东西改成了use

13:00.640 --> 13:02.040
就不用use effect了

13:02.040 --> 13:04.560
改成了use layout effect

13:04.560 --> 13:06.160
改成了这个

13:06.160 --> 13:06.720
你看一下

13:06.720 --> 13:09.180
保存

13:09.180 --> 13:10.300
是不是没有闪烁了

13:10.300 --> 13:11.300
对吧

13:11.300 --> 13:12.220
就非常流畅了

13:12.220 --> 13:13.020
没有闪烁了

13:13.060 --> 13:16.540
如果你说你要操作真实的动物的话

13:16.540 --> 13:19.140
那么如果你这个要操作真实动物的

13:19.140 --> 13:20.020
副作用的话

13:20.020 --> 13:21.340
那你最好用这个

13:21.340 --> 13:23.300
但是通常情况下我们不太会

13:23.300 --> 13:25.740
通常情况下不说一定的

13:25.740 --> 13:26.980
就讲这么一个道理

13:26.980 --> 13:28.740
其他也没啥了

13:28.740 --> 13:30.180
用法跟这个完全一样

13:30.180 --> 13:31.620
一点区别都没有

13:31.620 --> 13:33.740
只是时间点有区别

13:33.740 --> 13:37.260
但是我建议大家尽量使用这个

13:37.260 --> 13:39.220
这里还是说明一下

13:39.220 --> 13:42.460
尽量应该尽量

13:42.580 --> 13:45.420
使用use effect

13:46.220 --> 13:51.580
因为它不会导致渲染组设

13:51.580 --> 13:52.860
什么叫渲染组设呢

13:52.860 --> 13:53.540
就是说

13:53.540 --> 13:55.260
如果说你这边的代码

13:55.260 --> 13:55.820
比方说了

13:55.820 --> 13:58.740
做了很多很多各种复杂的动物操作

13:58.740 --> 14:00.140
做了各种复杂的动物操作

14:00.140 --> 14:02.700
那么你说夸张一点

14:02.700 --> 14:05.180
比方说你做了5秒钟的动物操作

14:06.100 --> 14:09.340
那么浏览器的渲染就会一直被延后

14:09.340 --> 14:10.180
一直被延后

14:10.180 --> 14:10.820
延后延后

14:10.820 --> 14:12.260
这时间点会被延后的

14:12.300 --> 14:15.020
它要等到你操作全部做完了之后

14:15.020 --> 14:17.620
然后浏览器在一起统一渲染

14:17.620 --> 14:20.180
那么这样子肯定会导致个浏览器

14:20.180 --> 14:22.820
就像连滚动条都滚动不动了

14:22.820 --> 14:24.380
导致个浏览器卡住

14:24.380 --> 14:26.260
给用户造成的体验不好

14:26.260 --> 14:27.940
而你使用如果使用use effect

14:27.940 --> 14:28.540
它就不会

14:28.540 --> 14:30.540
因为它之前已经渲染出来了

14:30.540 --> 14:31.860
你后面再做任何事情

14:31.860 --> 14:33.140
再复杂的事情

14:33.140 --> 14:34.980
再卡的事情

14:34.980 --> 14:36.380
它都不会导致

14:36.380 --> 14:37.740
那当前页面

14:37.740 --> 14:39.780
那导致你用户浏览不了

14:39.820 --> 14:42.620
所以说尽量的使用use effect

14:43.620 --> 14:47.620
如果出现了问题

14:47.620 --> 14:55.540
再考虑使用use layout effect hook

14:55.540 --> 14:56.980
就这么个意思

14:56.980 --> 14:59.140
把这个问题说清楚就行了

14:59.140 --> 15:01.900
其他的没啥了

15:01.900 --> 15:03.060
就没啥了

15:03.060 --> 15:06.260
这是关于这个东西

15:06.260 --> 15:07.700
也就是以前的l组件里面

15:07.700 --> 15:08.780
它是没有这个玩意的

15:08.820 --> 15:11.460
没有这个时间点的

15:11.460 --> 15:13.780
那么现在我们有了这个时间点

15:13.780 --> 15:15.580
其实对于效率来说的话

15:15.580 --> 15:16.220
就更好了

15:16.220 --> 15:19.580
因为它不会导致浏览器被卡住

15:19.580 --> 15:23.260
这是关于use layout effect

