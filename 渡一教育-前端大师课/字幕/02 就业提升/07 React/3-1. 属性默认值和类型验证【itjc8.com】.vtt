WEBVTT

00:00.620 --> 00:07.620
支持react基础部分 核心概念这一部分就已经学习完了

00:07.620 --> 00:12.620
接下来我们进入下一个章节就是react进阶部分

00:12.620 --> 00:18.620
进阶部分的知识有这么一个特点 它就说比较凌散

00:18.620 --> 00:20.620
它可能要动一下 细一下

00:20.620 --> 00:24.620
它不像我们在基础部分核心概念那一块东西

00:24.620 --> 00:28.620
它有一个连贯性 而且有一个学习的先后顺序

00:28.620 --> 00:32.620
但是进阶部分的知识它就稍微凌散一点

00:32.620 --> 00:38.620
这些知识有的稍微常用一点 有的没有那么常用

00:38.620 --> 00:41.620
但是它作为react里边支持的一部分

00:41.620 --> 00:44.620
咱们在进阶部分把它全部讲到

00:44.620 --> 00:47.620
这些知识可能没有什么连贯性

00:47.620 --> 00:51.620
大家看的时候也不一定

00:51.620 --> 00:54.620
但是我还是建议你按照顺序来看

00:54.620 --> 00:56.620
但是也可以不一定按照顺序来看

00:56.620 --> 01:01.620
这一部分知识有这么一个特点 没有严格连关系

01:01.620 --> 01:04.620
但是某一些部分还是有一些连关系的

01:04.620 --> 01:07.620
还是建议大家按照顺序来看

01:07.620 --> 01:12.620
这节课咱们来讲关于属性的一些进阶知识

01:12.620 --> 01:16.620
就是关于属性的默认值和内情检查

01:16.620 --> 01:20.620
咱们一个个说吧 先说属性的默认值

01:20.620 --> 01:24.620
属性的默认值实际上我完全没有必要

01:24.620 --> 01:27.620
去用一些什么新的语法

01:27.620 --> 01:30.620
完全就可以使用介石本身自带的功能

01:30.620 --> 01:32.620
来完成属性默认值

01:32.620 --> 01:34.620
咱们之前做一些练习的时候不做过吗

01:34.620 --> 01:36.620
做过这么一些练习

01:36.620 --> 01:37.620
如果你没有传辑的话

01:37.620 --> 01:39.620
我可以给你使用默认值

01:39.620 --> 01:41.620
我们可以用Objects而散

01:41.620 --> 01:43.620
就是来混合对象

01:43.620 --> 01:44.620
如果你传了过后

01:44.620 --> 01:47.620
我就把它混入到默认对象里边去

01:47.620 --> 01:49.620
实际上这里Rex给我们做了

01:49.620 --> 01:51.620
就本身就做了这么一个功能

01:51.620 --> 01:54.620
可以更加方便的让我们去使用属性默认值

01:54.620 --> 01:56.620
当然你完全也可以不使用它

01:56.620 --> 01:58.620
完全可以使用介石来做

01:58.620 --> 02:00.620
Rex是非常非常灵活的

02:00.620 --> 02:03.620
因为它本身介石它本身就很灵活

02:03.620 --> 02:06.620
所以我们这一块既然它提供了

02:06.620 --> 02:08.620
我们还是来认识一下属性默认值

02:08.620 --> 02:11.620
属性默认值如何来告诉Rex

02:11.620 --> 02:13.620
我有哪些属性还有默认值呢

02:13.620 --> 02:16.620
它是这样子是通过

02:16.620 --> 02:20.620
通过一个静态属性

02:20.620 --> 02:24.620
名字叫做DefaultProps

02:24.620 --> 02:27.620
看这个名字就非常容易理解

02:27.620 --> 02:30.620
Default表示默认的Props属性

02:30.620 --> 02:33.620
通过一个静态属性DefaultProps

02:33.620 --> 02:38.620
告知Rex属性默认值

02:38.620 --> 02:41.620
好,咱们来举个例子

02:41.620 --> 02:44.620
这里比方说我有这么两个组件

02:44.620 --> 02:46.620
一个寒宿组件,一个内组件

02:46.620 --> 02:48.620
Funk

02:48.620 --> 02:53.320
寒宿组件,Default

02:53.320 --> 02:56.320
这是个寒宿组件,RFC

02:56.320 --> 02:59.320
我怎么来,它有些属性

02:59.320 --> 03:02.320
我比方说,假设你属性里面

03:02.320 --> 03:05.320
要给我传三个传输

03:05.320 --> 03:08.320
就是三个属性值,一个是A,一个是B,一个是C

03:08.320 --> 03:10.320
那么你可以不传递

03:10.320 --> 03:12.320
不传递的话,我给你默认值

03:12.320 --> 03:14.320
我这里就显示

03:15.320 --> 03:17.320
A的值是Props.A

03:17.320 --> 03:20.320
B的值是Props.B

03:20.320 --> 03:22.320
没有什么实际意义

03:22.320 --> 03:25.320
属性默认值

03:25.320 --> 03:28.320
大家都知道什么意思

03:28.320 --> 03:30.320
知道什么意思就行了

03:30.320 --> 03:32.320
我们这一块的资讯将来在做一些练习的时候

03:32.320 --> 03:34.320
可以把它用上

03:34.320 --> 03:36.320
那么现在我们去使用这个组件

03:36.320 --> 03:39.320
在App里边去使用这个组件

03:39.320 --> 03:41.320
App里边,保住进来

03:41.320 --> 03:44.320
Import,Funk,Default

03:44.320 --> 03:47.320
Funk,Default

03:47.320 --> 03:49.320
这里倒入进来

03:49.320 --> 03:53.320
Funk,Default

03:53.320 --> 03:56.820
把运行器

03:56.820 --> 04:02.990
CD,React,Zenome

04:02.990 --> 04:04.990
启动起来

04:04.990 --> 04:07.990
这里面我们有没有传递的属性

04:07.990 --> 04:09.990
什么没传递啊

04:09.990 --> 04:10.990
这属性是哪传递的

04:10.990 --> 04:11.990
没有传递的属性

04:11.990 --> 04:14.990
那么没有传递的话,这个属性的值是多少

04:14.990 --> 04:15.990
应该是多少

04:15.990 --> 04:18.990
Undefine,这三个东西都是Undefine

04:18.990 --> 04:20.990
Undefine是不会显示到页面上的

04:20.990 --> 04:24.990
所以说现在在页面上只能看到ABC

04:24.990 --> 04:26.990
看不到它的值是什么

04:26.990 --> 04:29.990
那么我们有的时候想给它一个默认值

04:29.990 --> 04:31.990
以前我们可以直接在这里写

04:31.990 --> 04:32.990
写个默认值对象

04:32.990 --> 04:33.990
然后把它混合进去

04:33.990 --> 04:36.990
但是现在React里面给我们提供了这么一个功能

04:36.990 --> 04:38.990
就是说,如果

04:38.990 --> 04:41.990
你写了一个静态属性,什么叫静态属性

04:41.990 --> 04:43.990
这就是函数本身的属性

04:43.990 --> 04:44.990
对不对

04:44.990 --> 04:45.990
函数本身的属性

04:45.990 --> 04:47.990
函数它本身也是个对象

04:47.990 --> 04:50.990
那么函数本身的属性就是静态属性

04:50.990 --> 04:53.990
这是最基础,最基础的知识了

04:53.990 --> 04:56.990
咱们给它写上一个属性,叫Default Props

04:58.990 --> 04:59.990
这是默认属性

04:59.990 --> 05:01.990
属性肯定是个对象

05:01.990 --> 05:05.990
默认属性里面,我们给它写上A等于A

05:05.990 --> 05:07.990
B等于2,C等于3

05:07.990 --> 05:08.990
你看一下吧

05:08.990 --> 05:10.990
咱们这样子写的过后,保存

05:10.990 --> 05:12.990
这里看,是不是得到1,2,3了

05:12.990 --> 05:14.990
就这么简单

05:14.990 --> 05:17.990
那如果你3没有写了

05:17.990 --> 05:19.990
那么C是不是undefined

05:19.990 --> 05:21.990
它没有传递就是undefined

05:21.990 --> 05:25.990
它是不是跟我们之前自己写的那个混入

05:25.990 --> 05:26.990
是不是一样的

05:26.990 --> 05:29.990
这就是默认属性

05:29.990 --> 05:30.990
默认属性

05:31.990 --> 05:33.990
那么如果我传递了

05:33.990 --> 05:36.990
这东西不用再过多解释

05:36.990 --> 05:38.990
就大概说一下就行了

05:38.990 --> 05:40.990
比方说如果传递了

05:40.990 --> 05:41.990
传递了这个属性

05:41.990 --> 05:47.990
比方说传递了10,B等于20

05:47.990 --> 05:48.990
传递过后了

05:48.990 --> 05:49.990
看一下

05:49.990 --> 05:53.990
A和B就是死,C仍然保持默认止3

05:53.990 --> 05:54.990
对吧

05:54.990 --> 05:55.990
这个没什么问题

05:55.990 --> 05:57.990
那么这种情况下

05:57.990 --> 05:58.990
它会再怎么来处理呢

05:58.990 --> 06:01.990
它会在你使用这个主件的时候

06:01.990 --> 06:03.990
你不是传了一些属性过去吗

06:03.990 --> 06:05.990
传了属性过去过后了

06:05.990 --> 06:07.990
它马上就会进行混合

06:07.990 --> 06:09.990
跟这个默认属性进行混合

06:09.990 --> 06:10.990
混合过后呢

06:10.990 --> 06:11.990
我们在这里

06:11.990 --> 06:13.990
其实在这里边得到的东西

06:13.990 --> 06:15.990
在这里边得到的属性值

06:15.990 --> 06:17.990
它就是已经是混合之后的了

06:17.990 --> 06:19.990
就已经是混合之后的了

06:19.990 --> 06:21.990
它会先混合再传进去

06:21.990 --> 06:23.990
保存看一下吧

06:23.990 --> 06:24.990
检查

06:24.990 --> 06:26.990
这里你看

06:26.990 --> 06:27.990
你看

06:27.990 --> 06:29.990
是不是已经混合过后了

06:29.990 --> 06:31.990
当函数运行的时候

06:31.990 --> 06:32.990
它已经混合了

06:32.990 --> 06:36.990
这里是已经完成了混合

06:37.990 --> 06:39.990
这是这么一个函数组件

06:39.990 --> 06:41.990
它的属性默认止

06:41.990 --> 06:43.990
那么内组件是一样的道理

06:43.990 --> 06:44.990
对不对

06:44.990 --> 06:45.990
内组件是一样的道理

06:45.990 --> 06:47.990
咱们这里复制一下

06:47.990 --> 06:48.990
把它改为内组件

06:48.990 --> 06:50.990
class default

06:50.990 --> 06:52.990
内组件的默认止

06:52.990 --> 06:55.990
class default

06:55.990 --> 06:56.990
内组件

06:56.990 --> 06:57.990
我们稍微把

06:57.990 --> 06:58.990
改动一下

06:58.990 --> 06:59.990
这里就是class内了

06:59.990 --> 07:00.990
对吧

07:00.990 --> 07:01.990
然后这里

07:01.990 --> 07:03.990
要去继承

07:03.990 --> 07:05.990
继承extend

07:05.990 --> 07:07.990
component

07:07.990 --> 07:08.990
react

07:08.990 --> 07:09.990
component

07:09.990 --> 07:10.990
继承这个组件

07:10.990 --> 07:11.990
然后这里应该是

07:11.990 --> 07:12.990
放到render里面

07:12.990 --> 07:13.990
对吧

07:13.990 --> 07:14.990
放到render里面

07:14.990 --> 07:17.500
在render里面

07:17.500 --> 07:18.500
来返回这个东西

07:18.500 --> 07:20.500
那么这里要加上什么

07:20.500 --> 07:21.500
加上

07:21.500 --> 07:22.500
这里

07:22.500 --> 07:24.500
加上this props

07:24.500 --> 07:26.500
返回

07:26.500 --> 07:27.500
那么内组件里面

07:27.500 --> 07:28.500
因为内的本质是啥

07:28.500 --> 07:29.500
内的本质

07:29.500 --> 07:31.500
是不是还是一个函数

07:31.500 --> 07:32.500
对不对

07:32.500 --> 07:33.500
还是个函数

07:33.500 --> 07:34.500
是不是还是可以这样写

07:34.500 --> 07:35.500
它的默认止

07:35.500 --> 07:36.500
class default

07:36.500 --> 07:37.500
default props

07:37.500 --> 07:39.500
还是可以这样写

07:39.500 --> 07:40.500
那么在内组件里面

07:40.500 --> 07:41.500
是什么时候混合的呢

07:41.500 --> 07:43.500
它是在

07:43.500 --> 07:44.500
调用勾造函数

07:44.500 --> 07:45.500
也就是在负累里边

07:45.500 --> 07:46.500
负累的勾造函数里面

07:46.500 --> 07:47.500
就完成了

07:47.500 --> 07:48.500
混合了

07:48.500 --> 07:50.500
props

07:50.500 --> 07:51.500
看着

07:51.500 --> 07:52.500
super

07:52.500 --> 07:55.190
console

07:55.190 --> 07:56.190
在勾造函数里面

07:56.190 --> 07:57.190
就完成了

07:57.190 --> 07:58.190
混合了

07:58.190 --> 07:59.190
保存

07:59.190 --> 08:00.190
咱们叔叔看一下

08:00.190 --> 08:01.190
那这里

08:01.190 --> 08:02.190
我们去使用

08:02.190 --> 08:03.190
这个

08:03.190 --> 08:04.190
这个主持销

08:04.190 --> 08:06.190
这个主持销

08:06.190 --> 08:08.190
这边我们去使用

08:08.190 --> 08:09.190
import

08:09.190 --> 08:11.190
class default

08:11.190 --> 08:12.190
from

08:12.190 --> 08:16.720
class default

08:16.720 --> 08:17.720
就是你在使用

08:17.720 --> 08:18.720
这个主销的时候

08:18.720 --> 08:19.720
它就是已经是

08:19.720 --> 08:20.720
混合之后了

08:20.720 --> 08:21.720
那么你还记得

08:21.720 --> 08:22.720
我们讲生命周期那一块吗

08:22.720 --> 08:23.720
我们生命周期那一块

08:23.720 --> 08:25.720
有个初始化阶段

08:25.720 --> 08:26.720
初始化阶段干嘛的

08:26.720 --> 08:27.720
是不是

08:27.720 --> 08:29.720
初始化属性和状态

08:29.720 --> 08:30.720
那么初始化

08:30.720 --> 08:31.720
属性和状态的时候

08:31.720 --> 08:32.720
就已经包含了

08:32.720 --> 08:34.720
要混合

08:34.720 --> 08:35.720
那个

08:35.720 --> 08:36.720
默认属性

08:36.720 --> 08:37.720
要混合默认属性

08:38.720 --> 08:39.720
保存

08:39.720 --> 08:40.720
咱们看一下

08:41.720 --> 08:42.720
那里看得到结果

08:42.720 --> 08:43.720
是不是123

08:43.720 --> 08:44.720
对不对

08:44.720 --> 08:45.720
全是使用的默认值

08:45.720 --> 08:46.720
如果你给他

08:46.720 --> 08:47.720
a付了一个值

08:47.720 --> 08:48.720
比方说10

08:48.720 --> 08:49.720
保存

08:49.720 --> 08:50.720
那里看是不是10

08:50.720 --> 08:51.720
对不对

08:51.720 --> 08:52.720
这是这种

08:52.720 --> 08:53.720
这种写法

08:54.720 --> 08:55.720
内组键里面

08:55.720 --> 08:56.720
我们再多说几句

08:56.720 --> 08:58.720
因为在

08:58.720 --> 08:59.720
后来呢

08:59.720 --> 09:00.720
也是

09:00.720 --> 09:01.720
nxt里面

09:01.720 --> 09:02.720
里面呢

09:02.720 --> 09:03.720
它就加了一些标准

09:03.720 --> 09:04.720
就说

09:04.720 --> 09:05.720
现在写内组键里面

09:05.720 --> 09:06.720
如果你要写一些

09:06.720 --> 09:07.720
静态属性

09:07.720 --> 09:08.720
像这种静态属性的话

09:08.720 --> 09:09.720
你可以用这种方式

09:09.720 --> 09:10.720
下面这种方式

09:10.720 --> 09:11.720
当然也可以

09:12.720 --> 09:14.720
也可以使用这种方式

09:14.720 --> 09:15.720
加上Static

09:15.720 --> 09:16.720
这也是我在

09:16.720 --> 09:17.720
讲s6的时候

09:17.720 --> 09:19.720
你给大家介绍过

09:19.720 --> 09:22.720
Static Default Props

09:22.720 --> 09:23.720
直接写到这

09:23.720 --> 09:24.720
这样子

09:24.720 --> 09:26.720
看上去更加舒服一点

09:26.720 --> 09:27.720
这样子

09:27.720 --> 09:29.720
也可以写属性的默认值

09:30.720 --> 09:31.720
保存

09:31.720 --> 09:32.720
是完全一样的

09:32.720 --> 09:33.720
完全一样的

09:33.720 --> 09:34.720
你看一下

09:34.720 --> 09:35.720
你看

09:35.720 --> 09:36.720
里面是不是就已经

09:36.720 --> 09:38.720
就已经得到这些东西了

09:38.720 --> 09:39.720
对不对

09:39.720 --> 09:42.720
这就是内组键里面的默认值

09:43.720 --> 09:44.720
再重申一下

09:44.720 --> 09:45.720
就是说

09:45.720 --> 09:46.720
这个混合

09:46.720 --> 09:48.720
它是在什么时候完成的

09:48.720 --> 09:49.720
对于函数组件而言

09:49.720 --> 09:52.720
它在调用函数之前就完成了

09:52.720 --> 09:54.720
对于内组键而言

09:55.720 --> 09:56.720
其实也不能说

09:56.720 --> 09:57.720
在附内里面完成的

09:57.720 --> 09:58.720
也不能说

09:58.720 --> 09:59.720
它是在附内的

09:59.720 --> 10:00.720
构造函数里面完成混合的

10:00.720 --> 10:01.720
实际上不是

10:01.720 --> 10:02.720
实际上是要运行

10:02.720 --> 10:03.720
构造函数之前

10:03.720 --> 10:04.720
它就已经完成混合了

10:04.720 --> 10:06.720
它混合了之后给你传官了

10:06.720 --> 10:09.720
它是混合了之后给你传官了

10:09.720 --> 10:10.720
这才是

10:10.720 --> 10:12.720
正确的时间线

10:12.720 --> 10:13.720
正确的时间线

10:13.720 --> 10:14.720
你说这里呢

10:14.720 --> 10:15.720
我们去使用这个内组键

10:15.720 --> 10:17.720
它不是传了一些属性吗

10:17.720 --> 10:18.720
它这个时候

10:18.720 --> 10:19.720
就先把这些属性混合

10:19.720 --> 10:21.720
你不是有静态

10:21.720 --> 10:22.720
你这个class default

10:22.720 --> 10:23.720
它不是有静态属性

10:23.720 --> 10:25.720
default process吗

10:25.720 --> 10:26.720
那么它这个时候

10:26.720 --> 10:27.720
就把你这个东西

10:27.720 --> 10:28.720
组装成一个对象

10:28.720 --> 10:29.720
比方说这里有个B

10:29.720 --> 10:30.720
一个20

10:30.720 --> 10:31.720
那么就把这个东西

10:31.720 --> 10:33.720
先组装成一个对象

10:33.720 --> 10:36.720
A和S

10:37.720 --> 10:39.720
然后B20对吧

10:39.720 --> 10:41.720
然后先来进行混合

10:41.720 --> 10:42.720
先来进行混合

10:42.720 --> 10:43.720
跟什么混合呢

10:43.720 --> 10:45.720
跟这个class default的

10:45.720 --> 10:48.720
就是静态属性default process

10:48.720 --> 10:50.720
把这两个对象进行混合

10:50.720 --> 10:51.720
混合了过后

10:51.720 --> 10:53.720
再作为最终的属性传过去

10:53.720 --> 10:55.720
它是在最开始的时候去处理的

10:55.720 --> 10:57.720
这就是初始化结果要做的事

10:57.720 --> 10:59.720
只不过初始化完了过后

10:59.720 --> 11:00.720
它要运行什么

11:00.720 --> 11:02.720
它运行的是构造函数

11:02.720 --> 11:03.720
严格来说

11:03.720 --> 11:04.720
应该是这样的过程

11:04.720 --> 11:05.720
因为之前

11:05.720 --> 11:07.720
我们没有讲属性摸认值这一块

11:07.720 --> 11:08.720
所以说

11:08.720 --> 11:11.720
之前咱们直接可以认为

11:11.720 --> 11:12.720
初始化结果就是构造函数

11:12.720 --> 11:14.720
但是实际上是有点点差异的

11:14.720 --> 11:16.720
它在调整构造函数之前

11:16.720 --> 11:18.720
就已经完成了混合了

11:18.720 --> 11:19.720
比方说咱们把

11:19.720 --> 11:20.720
console.log

11:20.720 --> 11:21.720
放在这前边

11:21.720 --> 11:23.720
放在这前边来输出

11:23.720 --> 11:24.720
保存看一下吧

11:24.720 --> 11:25.720
刘维发现

11:25.720 --> 11:27.720
它输出的结果仍然是

11:27.720 --> 11:28.720
混合之后的结果

11:28.720 --> 11:30.720
所以它并不是腹内里边

11:30.720 --> 11:31.720
并不是腹内里边

11:31.720 --> 11:33.720
构造函数调用的

11:33.720 --> 11:35.720
这是这一块

11:35.720 --> 11:39.720
属性的摸认值

11:39.720 --> 11:41.720
下面这一块

11:41.720 --> 11:43.720
是内型检查

11:43.720 --> 11:44.720
它什么意思呢

11:44.720 --> 11:45.720
就是说

11:45.720 --> 11:47.720
有的时候

11:47.720 --> 11:48.720
我们为了写一个

11:48.720 --> 11:50.720
完美的组件出来

11:50.720 --> 11:51.720
什么叫完美的组件呢

11:51.720 --> 11:52.720
就是别人用的

11:52.720 --> 11:54.720
不但要很方便

11:54.720 --> 11:56.720
而且不容易出问题

11:56.720 --> 11:57.720
比方说

11:57.720 --> 11:58.720
我该传一个对象的地方

11:58.720 --> 11:59.720
你给我传一个数字

11:59.720 --> 12:00.720
该传一个数字的地方

12:00.720 --> 12:01.720
你给我传一个布尔

12:01.720 --> 12:02.720
该传个布尔的地方

12:02.720 --> 12:04.720
你给我传一个支付创

12:04.720 --> 12:05.720
像这种情况下

12:05.720 --> 12:07.720
我可能会导致这个组件

12:07.720 --> 12:09.720
没有办法正确工作

12:09.720 --> 12:11.720
其实我们之前写的组件

12:11.720 --> 12:13.720
就像这些乱七八糟的组件

12:13.720 --> 12:15.720
我们都是做了一个假设

12:15.720 --> 12:18.720
他给我正确的传递了一些东西

12:18.720 --> 12:20.720
假设他给我正确的传递的

12:20.720 --> 12:21.720
一些数据

12:21.720 --> 12:22.720
但是如果别人

12:22.720 --> 12:24.720
没有给你正确的传递

12:24.720 --> 12:26.720
是不是要出问题

12:26.720 --> 12:28.720
他肯定要出问题

12:28.720 --> 12:29.720
因此呢

12:29.720 --> 12:32.720
在Reactor里面给你加了这么一个类型检查

12:32.720 --> 12:33.720
就是说

12:33.720 --> 12:35.720
如果在写一个组件的时候

12:35.720 --> 12:37.720
我编写组件的时候

12:37.720 --> 12:38.720
我非常清楚

12:38.720 --> 12:40.720
我这个组件需要哪些属性

12:40.720 --> 12:41.720
哪些属性是必须要传递的

12:41.720 --> 12:43.720
哪些属性是可以不传递的

12:43.720 --> 12:45.720
哪些属性必须是自不创类型

12:45.720 --> 12:47.720
哪些属性必须是一个对象

12:47.720 --> 12:49.720
我是非常清楚的

12:49.720 --> 12:50.720
因此呢

12:50.720 --> 12:52.720
你在编写组件的时候

12:52.720 --> 12:54.720
你就把这些类型检查写好

12:54.720 --> 12:56.720
当我们使用组件的时候

12:56.720 --> 12:58.720
一旦他会自动进行检查

12:58.720 --> 13:00.720
你传的属性对不对

13:00.720 --> 13:03.720
如果你传递的属性不正确

13:03.720 --> 13:05.720
那么这个事情会导致问题

13:05.720 --> 13:07.720
这就是类型检查

13:07.720 --> 13:08.720
严格来说

13:08.720 --> 13:10.720
应该是属性的类型检查

13:10.720 --> 13:12.720
对属性进行类型检查

13:12.720 --> 13:14.720
那没有人要说对对

13:14.720 --> 13:15.720
对那个状态

13:15.720 --> 13:16.720
要不要进行类型检查呢

13:16.720 --> 13:18.720
你觉得有没有必要呢

13:18.720 --> 13:19.720
好好想一想

13:19.720 --> 13:21.720
对状态的话

13:21.720 --> 13:22.720
从哲学上来讲

13:22.720 --> 13:24.720
有没有必要呢

13:24.720 --> 13:26.720
没有必要

13:26.720 --> 13:28.720
为什么说对状态没有必要呢

13:28.720 --> 13:31.720
因为属性是别人给我的

13:31.720 --> 13:32.720
别人可能乱给

13:32.720 --> 13:34.720
而状态的是自己的

13:34.720 --> 13:36.720
你自己要整自己

13:36.720 --> 13:37.720
那谁拦得住了

13:37.720 --> 13:38.720
对吧

13:38.720 --> 13:39.720
拦不住的

13:39.720 --> 13:40.720
是这么个回意思

13:40.720 --> 13:43.720
所以只对属性进行类型检查

13:43.720 --> 13:44.720
就够了

13:44.720 --> 13:46.720
那么怎么来进行检查

13:46.720 --> 13:47.720
类型检查呢

13:47.720 --> 13:49.720
对属性进行类型检查

13:49.720 --> 13:51.720
要用到一个库

13:51.720 --> 13:53.720
这个库不是第三方的

13:53.720 --> 13:56.720
也是rex官方出品的一个库

13:56.720 --> 13:59.720
它以前是跟rex混在一起的

13:59.720 --> 14:01.720
后来把它分离出来了

14:01.720 --> 14:02.720
分离成了一个单独的一个库

14:02.720 --> 14:03.720
这个库也非常非常小

14:03.720 --> 14:07.720
它就是提供了一些非常非常简单的类型检查

14:07.720 --> 14:12.720
那么这个库的名字叫做prop types

14:12.720 --> 14:14.720
要使用第三方库

14:14.720 --> 14:16.720
不是叫第三方库

14:16.720 --> 14:18.720
要使用另外一个库

14:18.720 --> 14:22.720
使用浙库

14:23.720 --> 14:25.720
或者名字叫做prop types

14:25.720 --> 14:28.720
当你使用脚授架来搭建工程的时候

14:28.720 --> 14:30.720
那肯定就已经安装好了这个库了

14:30.720 --> 14:33.720
如果你直接在页面上引用介式的话

14:33.720 --> 14:36.720
那你还要去引用一下这个介式

14:36.720 --> 14:38.720
那么具体来说

14:38.720 --> 14:40.720
怎么来进行类型检查呢

14:40.720 --> 14:42.720
是这样子

14:42.720 --> 14:45.720
对组件使用静态属性

14:45.720 --> 14:47.720
所以又来了静态属性

14:47.720 --> 14:49.720
那么寒暑组件

14:49.720 --> 14:51.720
可不可以使用静态属性

14:51.720 --> 14:52.720
可不可以

14:52.720 --> 14:53.720
刚才不是做过吗

14:53.720 --> 14:55.720
是不是仍然可以

14:55.720 --> 14:57.720
仍然可以使用静态属性

14:57.720 --> 14:58.720
所以那组件的寒暑组件

14:58.720 --> 14:59.720
它都有属性

14:59.720 --> 15:01.720
都可以对属性进行类型检查

15:01.720 --> 15:02.720
它们都有静态属性

15:02.720 --> 15:03.720
所以都可以使用

15:03.720 --> 15:04.720
什么静态属性呢

15:04.720 --> 15:07.720
叫做prop types

15:07.720 --> 15:10.720
使用这个静态属性

15:10.720 --> 15:12.720
就是告知react

15:12.720 --> 15:15.720
如何检查属性

15:15.720 --> 15:17.720
它通过这种方式来告诉

15:17.720 --> 15:19.720
那么怎么的告诉呢

15:19.720 --> 15:20.720
一大堆例子

15:20.720 --> 15:21.720
不是例子

15:21.720 --> 15:22.720
就是大堆

15:22.720 --> 15:23.720
就是相当于是

15:23.720 --> 15:24.720
到时候你们忘了过后

15:24.720 --> 15:25.720
就去查越

15:25.720 --> 15:26.720
这个东西我也经常忘

15:26.720 --> 15:27.720
就是一些常用的

15:27.720 --> 15:28.720
我不会忘记

15:28.720 --> 15:29.720
但是一些不太常用的

15:29.720 --> 15:31.720
我可能会经常忘记

15:31.720 --> 15:32.720
没关系

15:32.720 --> 15:33.720
忘记了过后去查这个东西

15:33.720 --> 15:34.720
咱们学编程

15:34.720 --> 15:35.720
千万不要去背

15:35.720 --> 15:36.720
背没有什么意义

15:36.720 --> 15:38.720
把它理解清楚就行了

15:38.720 --> 15:39.720
这个属性的名字

15:39.720 --> 15:40.720
肯定要知道

15:40.720 --> 15:41.720
因为你经常用

15:41.720 --> 15:42.720
好

15:42.720 --> 15:44.720
然后我们现在来试一下

15:44.720 --> 15:47.720
这里我们再建一个文件

15:47.720 --> 15:48.720
这个地方

15:48.720 --> 15:49.720
重新复制一个了

15:49.720 --> 15:50.720
这里面

15:50.720 --> 15:51.720
把这些东西删掉了

15:54.720 --> 15:56.720
然后我们这里写个组件

15:56.720 --> 15:58.720
都是没有什么实际意义

15:58.720 --> 15:59.720
只是告诉大家

15:59.720 --> 16:00.720
因为这个地方很好理解

16:00.720 --> 16:02.720
我也不需要去举什么例子

16:02.720 --> 16:03.720
大家知道这个属性

16:03.720 --> 16:05.720
怎么去检查就完事了

16:05.720 --> 16:06.720
这里我们写这么一个组件

16:06.720 --> 16:07.720
叫做

16:09.720 --> 16:10.720
当然这个

16:10.720 --> 16:11.720
我就写个内组件

16:11.720 --> 16:12.720
我就写个内组件

16:12.720 --> 16:13.720
韩束组件我就不写了

16:13.720 --> 16:14.720
因为是一样的

16:14.720 --> 16:15.720
韩束组件里边

16:15.720 --> 16:16.720
是不是也是一样的解法

16:16.720 --> 16:17.720
你看韩束组件的

16:17.720 --> 16:18.720
静态属性

16:18.720 --> 16:19.720
是不是这样的写就完事了

16:19.720 --> 16:20.720
到时候是一样的解法

16:20.720 --> 16:22.720
没有直接写内组件了

16:22.720 --> 16:23.720
就是

16:24.720 --> 16:25.720
Validation

16:25.720 --> 16:26.720
Comp

16:26.720 --> 16:27.720
就是有一个

16:27.720 --> 16:29.720
内型检查的

16:30.720 --> 16:31.720
一个组件

16:31.720 --> 16:33.720
这是个内组件

16:35.720 --> 16:36.720
放过来

16:37.720 --> 16:38.720
关闭到右侧

16:38.720 --> 16:40.720
这里我们把它倒进来

16:41.720 --> 16:43.720
Validation

16:43.720 --> 16:45.720
Validation

16:45.720 --> 16:47.720
Validation

16:47.720 --> 16:48.720
Comp

16:50.720 --> 16:51.720
Validation

16:51.720 --> 16:52.720
Comp

16:52.720 --> 16:53.720
倒进来

16:53.720 --> 16:54.720
然后我们这边

16:54.720 --> 16:56.720
就直接使用这个组件的了

16:57.720 --> 16:58.720
Validation

16:58.720 --> 17:02.250
Comp

17:02.250 --> 17:03.250
好 接下来我们看一下

17:03.250 --> 17:04.250
这个组件里边

17:04.250 --> 17:06.250
怎么来进行内型检查

17:06.250 --> 17:08.250
好 比方说

17:08.250 --> 17:09.250
这个组件里面

17:09.250 --> 17:10.250
我们该写上一个静态属性

17:10.250 --> 17:11.250
Static

17:11.250 --> 17:12.250
Prob

17:12.250 --> 17:13.250
是吧

17:13.250 --> 17:14.250
Types

17:14.250 --> 17:16.250
Prob Types

17:16.250 --> 17:17.250
然后我们这里

17:17.250 --> 17:18.250
写上这个

17:18.250 --> 17:19.250
一个对象

17:19.250 --> 17:20.250
它是个对象

17:20.250 --> 17:21.250
就是说这里边

17:21.250 --> 17:22.250
它要对应到哪些属性

17:22.250 --> 17:23.250
有哪些属性

17:23.250 --> 17:24.250
要进行内型检查

17:24.250 --> 17:25.250
比方属性A

17:25.250 --> 17:26.250
要进行内型检查

17:26.250 --> 17:27.250
就这样子写

17:27.250 --> 17:28.250
好

17:28.250 --> 17:30.250
那么比方说有个属性A

17:30.250 --> 17:32.250
对属性A进行内型检查的时候

17:32.250 --> 17:34.250
要给它进行约束

17:34.250 --> 17:36.250
约束为什么样的内型

17:36.250 --> 17:38.250
那么怎么来写

17:38.250 --> 17:39.250
怎么来告诉他

17:39.250 --> 17:40.250
约定为什么样的内型

17:40.250 --> 17:41.250
这个时候

17:41.250 --> 17:42.250
我们要用到这个第三方库

17:42.250 --> 17:43.250
不要第三方库

17:43.250 --> 17:44.250
就说习惯了

17:44.250 --> 17:45.250
要用到这个库

17:45.250 --> 17:46.250
叫Prob Types

17:46.250 --> 17:47.250
好

17:47.250 --> 17:48.250
我们这里

17:48.250 --> 17:49.250
把它导入进来

17:49.250 --> 17:50.250
Import

17:50.250 --> 17:53.250
Prob Types

17:53.250 --> 17:56.250
Prob Types

17:56.250 --> 17:58.250
把这个库导入进来

17:58.250 --> 17:59.250
这个库里边

17:59.250 --> 18:00.250
它就提

18:00.250 --> 18:01.250
这是个对象

18:01.250 --> 18:02.250
它这个对象里边

18:02.250 --> 18:04.250
提供了很多很多的内型

18:04.250 --> 18:05.250
它给你做好的内型

18:05.250 --> 18:07.250
那么你直接使用就行了

18:07.250 --> 18:08.250
不能直接使用

18:08.250 --> 18:09.250
介石里边的内型

18:09.250 --> 18:10.250
全部不能这样子写

18:10.250 --> 18:12.250
全部不能这样子写

18:12.250 --> 18:14.250
你要用它里边的东西

18:14.250 --> 18:15.250
Prob Types

18:16.250 --> 18:18.250
Prob Types里边

18:18.250 --> 18:19.250
比方说

18:19.250 --> 18:20.250
它里边有一个

18:22.250 --> 18:23.250
比方说

18:23.250 --> 18:24.250
一个Number

18:24.250 --> 18:25.250
一个Number

18:25.250 --> 18:26.250
表示什么意思呢

18:26.250 --> 18:28.250
看着吧

18:28.250 --> 18:29.250
一个Number

18:29.250 --> 18:30.250
表示数字内型

18:30.250 --> 18:32.250
那么就告诉reactor

18:32.250 --> 18:33.250
这里A

18:33.250 --> 18:35.250
数相

18:35.250 --> 18:38.250
必须是一个数字内型

18:38.250 --> 18:39.250
必须是一个数字内型

18:39.250 --> 18:40.250
那么这个时候

18:40.250 --> 18:42.250
假设你传递的另外一个东西

18:42.250 --> 18:43.250
比方说传递的A

18:43.250 --> 18:45.250
给它传递的一个字符串1

18:45.250 --> 18:46.250
看行不行

18:46.250 --> 18:47.250
来看一下行不行

18:47.250 --> 18:48.250
保存

18:48.250 --> 18:49.250
运行

18:49.250 --> 18:50.250
你看一下

18:50.250 --> 18:51.250
这个时候介面上没有

18:51.250 --> 18:52.250
没有显

18:52.250 --> 18:54.250
当然我现在也没有在做任何显示

18:54.250 --> 18:55.250
那我先把显示出来

18:55.250 --> 18:56.250
显示出来

19:00.250 --> 19:01.250
保存

19:01.250 --> 19:02.250
那么可以看到

19:02.250 --> 19:03.250
介面上虽然显示了

19:03.250 --> 19:04.250
但是呢

19:04.250 --> 19:05.250
但是呢

19:05.250 --> 19:06.250
我这里的报了一个警告

19:06.250 --> 19:07.250
它说什么呢

19:10.250 --> 19:12.250
它说你给的就是

19:12.250 --> 19:13.250
它属性A

19:13.250 --> 19:16.250
是一个无销的内型字符串

19:16.250 --> 19:17.250
但是呢

19:17.250 --> 19:18.250
它expected

19:18.250 --> 19:21.250
它希望的是一个Number

19:21.250 --> 19:22.250
是不是报了错了

19:22.250 --> 19:24.250
它不会影响我们的代码执行

19:24.250 --> 19:25.250
它不会影响

19:25.250 --> 19:27.250
除非代码报错了

19:27.250 --> 19:28.250
它这个东西

19:28.250 --> 19:29.250
它的官方文档说的是

19:29.250 --> 19:31.250
它只是边易报错

19:31.250 --> 19:33.250
只是在开发阶段有用

19:33.250 --> 19:35.250
在开发阶段有用

19:35.250 --> 19:37.250
它不会影响我们的代码执行

19:37.250 --> 19:38.250
只不过呢

19:38.250 --> 19:39.250
它会给你报一个错误

19:39.250 --> 19:40.250
你在开发阶段

19:40.250 --> 19:42.250
肯定时时刻刻是把这个控制台打开的

19:42.250 --> 19:43.250
对吧

19:43.250 --> 19:44.250
有了错误你一定要解决

19:44.250 --> 19:45.250
将来呢

19:45.250 --> 19:47.250
我们把发布出去之后

19:47.250 --> 19:49.250
把这个东西发布出去之后

19:49.250 --> 19:50.250
这个错误就消失了

19:50.250 --> 19:52.250
它只是在我们的开发阶段有

19:52.250 --> 19:53.250
有了报错

19:53.250 --> 19:54.250
因为开发阶段

19:54.250 --> 19:55.250
我们给它传了一个错误的东西

19:55.250 --> 19:56.250
对吧

19:56.250 --> 19:57.250
它在这个时候报错

19:57.250 --> 19:58.250
以后发布出去

19:58.250 --> 19:59.250
在运行的时候

19:59.250 --> 20:01.250
就不会再报这个错误了

20:01.250 --> 20:03.250
这是官方文档里面说的

20:04.250 --> 20:06.250
那么能不能不传递呢

20:06.250 --> 20:08.250
能不能不传递呢

20:08.250 --> 20:09.250
可以不传递

20:09.250 --> 20:10.250
不传递是可以的

20:10.250 --> 20:11.250
但是呢你传递

20:11.250 --> 20:12.250
如果要传递的话

20:12.250 --> 20:14.250
就必须要传递一个正确的值

20:15.250 --> 20:16.250
是这么的意思

20:16.250 --> 20:17.250
好那么有些人要问的

20:17.250 --> 20:20.250
那如果我想约束他必须传递怎么办

20:22.250 --> 20:23.250
确实啊

20:23.250 --> 20:24.250
因为有些属性的

20:24.250 --> 20:25.250
他是必须要传递的

20:26.250 --> 20:29.250
如果你想约束他为必须要传递

20:29.250 --> 20:30.250
怎么办呢

20:30.250 --> 20:32.250
这里面每一个

20:34.250 --> 20:35.250
proper types里面

20:35.250 --> 20:36.250
每一个内形啊

20:36.250 --> 20:37.250
每一个内形

20:37.250 --> 20:39.250
它不是一个简单的东西

20:39.250 --> 20:40.250
它是一个对象

20:41.250 --> 20:42.250
把答应出来吧

20:42.250 --> 20:44.250
proper types

20:44.250 --> 20:45.250
第二什么lumber

20:45.250 --> 20:46.250
你看一下

20:47.250 --> 20:48.250
它是个什么东西

20:50.250 --> 20:51.250
它是个函数

20:51.250 --> 20:52.250
它是个函数

20:52.250 --> 20:53.250
它是个函数

20:53.250 --> 20:55.250
但函数也是对象对吧

20:55.250 --> 20:56.250
也是对象

20:56.250 --> 20:57.250
这个函数里边

20:57.250 --> 20:58.250
它有个东西啊

20:58.250 --> 20:59.250
我们用dir

20:59.250 --> 21:01.250
把函数答应出来

21:01.250 --> 21:02.250
这个函数里边有个东西

21:02.250 --> 21:04.250
叫做easy required

21:04.250 --> 21:05.250
有这么一个属性

21:06.250 --> 21:07.250
有这么一个属性

21:07.250 --> 21:08.250
其实这个属性呢

21:08.250 --> 21:09.250
也是一个函数

21:09.250 --> 21:10.250
也是一个函数

21:10.250 --> 21:12.250
那么你如果

21:13.250 --> 21:14.250
就说这个东西

21:14.250 --> 21:15.250
如果它是必填的

21:15.250 --> 21:17.250
你就后面就该加上一个属性

21:17.250 --> 21:18.250
easy required

21:19.250 --> 21:20.250
那么什么意思呢

21:20.250 --> 21:22.250
就是把这个函数负责给它

21:22.250 --> 21:23.250
那么它到时候

21:23.250 --> 21:24.250
它其实为什么是函数

21:24.250 --> 21:25.250
因为到时候

21:25.250 --> 21:27.250
它进行内形检查的时候

21:27.250 --> 21:29.250
它就会运行这个函数

21:29.250 --> 21:31.250
你给它加上这个东西

21:31.250 --> 21:32.250
就表示

21:32.250 --> 21:33.250
它这里边呢

21:33.250 --> 21:35.250
它既要是一个数字

21:35.250 --> 21:36.250
同时呢

21:36.250 --> 21:37.250
这个数字呢又是必填的

21:37.250 --> 21:38.250
你给它的

21:38.250 --> 21:39.250
数字是一个

21:39.250 --> 21:40.250
这个东西是一个函数

21:40.250 --> 21:41.250
这个东西也是一个函数

21:41.250 --> 21:42.250
那么

21:42.250 --> 21:44.250
到时候内形检查的时候呢

21:44.250 --> 21:45.250
它就会运行函数

21:45.250 --> 21:46.250
检查不通过

21:46.250 --> 21:47.250
它就会爆出

21:47.250 --> 21:49.250
其他的原理非常非常简单

21:49.250 --> 21:50.250
它就是给它一个函数

21:50.250 --> 21:51.250
然后呢

21:51.250 --> 21:53.250
通过这个函数来进行内形检查

21:54.250 --> 21:55.250
这个意思吧

21:55.250 --> 21:56.250
如果你直接给它的话

21:56.250 --> 21:57.250
它是进内形检查

21:57.250 --> 21:58.250
但是它不会检查

21:58.250 --> 21:59.250
为空的情况

21:59.250 --> 22:01.250
如果给它这个函数的话

22:01.250 --> 22:02.250
它不但要检查这个东西

22:02.250 --> 22:04.250
还要检查为空的情况

22:04.250 --> 22:06.250
其实你可以自己想一想

22:06.250 --> 22:08.250
我们到时候分析

22:08.250 --> 22:09.250
原码的时候呢

22:09.250 --> 22:10.250
其实说到这

22:10.250 --> 22:11.250
你应该知道它这个

22:11.250 --> 22:13.250
大概是怎么写的了

22:13.250 --> 22:14.250
就非常简单

22:14.250 --> 22:15.250
这里一点都不复杂

22:15.250 --> 22:16.250
你自己写的话

22:16.250 --> 22:18.250
完全可以写一套出来

22:18.250 --> 22:19.250
你看

22:19.250 --> 22:20.250
那么现在就告诉你

22:20.250 --> 22:21.250
这个属性呢

22:21.250 --> 22:22.250
是必填的

22:22.250 --> 22:24.250
是必填的

22:24.250 --> 22:26.250
这是

22:26.250 --> 22:27.250
这是

22:27.250 --> 22:28.250
非空检查

22:28.250 --> 22:29.250
非空检查

22:29.250 --> 22:30.250
所以说你这里必须要复实

22:30.250 --> 22:31.250
而且不但要复直

22:31.250 --> 22:33.250
还要复制一个正确的数字

22:33.250 --> 22:35.250
对吧

22:35.250 --> 22:37.250
这是关于数字内形

22:37.250 --> 22:38.250
那么还有什么

22:38.250 --> 22:39.250
布尔

22:39.250 --> 22:40.250
这个就没啥说的吧

22:40.250 --> 22:41.250
布尔我说一下吧

22:41.250 --> 22:42.250
布尔再说一下

22:42.250 --> 22:44.250
比方说还有一个属性

22:44.250 --> 22:45.250
下一个属性是必

22:47.250 --> 22:48.250
并且必填

22:48.250 --> 22:50.250
上面是并且必填

22:50.250 --> 22:52.250
这个属性是跑不掉的

22:52.250 --> 22:53.250
然后那个属性必

22:53.250 --> 22:54.250
这个属性必不用必填

22:54.250 --> 22:55.250
当然如果要必填的话

22:55.250 --> 22:56.250
是一样的

22:57.250 --> 22:58.250
布尔

22:58.250 --> 23:00.250
注意必须用这个东西来约束

23:00.250 --> 23:01.250
布尔

23:01.250 --> 23:03.250
它是一个必

23:03.250 --> 23:05.250
必须是一个布尔属性

23:06.250 --> 23:07.250
我说一下这个

23:07.250 --> 23:09.250
然后它也是

23:09.250 --> 23:11.250
要不要必填的

23:11.250 --> 23:12.250
也是必填吧

23:12.250 --> 23:14.250
is required

23:14.250 --> 23:18.840
也是必填

23:18.840 --> 23:19.840
比方说这个属性

23:20.840 --> 23:21.840
那现在我没有传递

23:21.840 --> 23:22.840
没有传递

23:22.840 --> 23:23.840
它肯定要保错

23:23.840 --> 23:24.840
保住警告

23:24.840 --> 23:26.840
那么现在我传递

23:26.840 --> 23:27.840
传递的时候怎么传递

23:27.840 --> 23:28.840
能不能这样传递

23:28.840 --> 23:29.840
能不能

23:29.840 --> 23:30.840
不能

23:30.840 --> 23:31.840
你这样子

23:31.840 --> 23:32.840
只有一种可能

23:32.840 --> 23:33.840
就是传递一个制服串

23:33.840 --> 23:34.840
你只传递了一个制服串

23:34.840 --> 23:36.840
其他不可能传递任何东西

23:36.840 --> 23:37.840
你看

23:37.840 --> 23:39.840
你说你这个希望的是一个

23:39.840 --> 23:40.840
布定对吧

23:40.840 --> 23:41.840
结果呢

23:41.840 --> 23:42.840
你给我的是一个啥

23:42.840 --> 23:43.840
给我的是一个stun

23:43.840 --> 23:44.840
所以说

23:44.840 --> 23:45.840
保错了

23:45.840 --> 23:46.840
保错了

23:46.840 --> 23:47.840
那么这里呢

23:47.840 --> 23:48.840
我们要怎么来传递呢

23:48.840 --> 23:49.840
要这样传递

23:52.840 --> 23:53.840
要这样子传递

23:53.840 --> 23:54.840
这样子没问题了

23:55.840 --> 23:56.840
你看没问题了

23:57.840 --> 23:58.840
好

23:58.840 --> 24:00.840
那这里还可以用传递方式

24:00.840 --> 24:01.840
这样子传递

24:01.840 --> 24:02.840
就啥都不写

24:02.840 --> 24:03.840
直接写个屁在这里

24:03.840 --> 24:04.840
可不可以呢

24:04.840 --> 24:05.840
可以

24:05.840 --> 24:06.840
这是我们之前说过的

24:06.840 --> 24:07.840
对吧

24:07.840 --> 24:08.840
说过的

24:08.840 --> 24:09.840
它是类似于ATM的语法

24:09.840 --> 24:10.840
就是你该写的这个属性

24:10.840 --> 24:11.840
它就认为你传的是去

24:11.840 --> 24:12.840
这种属性

24:12.840 --> 24:14.840
就认为是传的是去

24:14.840 --> 24:15.840
这样子写可以的

24:15.840 --> 24:17.840
那么不写是不行的

24:17.840 --> 24:18.840
你不能认为不写

24:18.840 --> 24:19.840
它就是force

24:19.840 --> 24:20.840
不是的

24:20.840 --> 24:21.840
不写是不行的

24:21.840 --> 24:22.840
不写是不行的

24:22.840 --> 24:23.840
但是一般来说

24:23.840 --> 24:25.840
对于那种布尔属性

24:25.840 --> 24:27.840
因为它的曲子很少

24:27.840 --> 24:28.840
只有两个

24:28.840 --> 24:29.840
通常情况下

24:29.840 --> 24:30.840
不是一定的

24:30.840 --> 24:31.840
通常情况下

24:31.840 --> 24:33.840
一般会给它一个默认值

24:33.840 --> 24:34.840
Static

24:34.840 --> 24:36.840
有default props

24:36.840 --> 24:38.840
会给这个一个默认值

24:38.840 --> 24:39.840
比较给它为force

24:39.840 --> 24:41.840
一开始就给它为force

24:41.840 --> 24:42.840
这样子一来

24:42.840 --> 24:43.840
你看一下

24:43.840 --> 24:45.840
哪怕它是必填的属性

24:45.840 --> 24:46.840
必填的属性

24:46.840 --> 24:47.840
那么现在

24:47.840 --> 24:48.840
我尽管没有传递这个属性

24:48.840 --> 24:50.840
由于它有默认值

24:50.840 --> 24:52.840
它也能保证这个属性

24:52.840 --> 24:53.840
是有值的

24:53.840 --> 24:54.840
所以说通过这一点

24:54.840 --> 24:56.840
你知道它的顺序是怎么了

24:56.840 --> 24:57.840
是不是先混合

24:57.840 --> 25:00.840
先混合属性

25:00.840 --> 25:02.840
混合过后再进行什么

25:02.840 --> 25:03.840
再验证

25:03.840 --> 25:07.840
再调用相应的

25:07.840 --> 25:09.840
函数进行验证

25:09.840 --> 25:11.840
交用什么函数

25:11.840 --> 25:12.840
这些东西都是函数

25:12.840 --> 25:13.840
都是函数

25:13.840 --> 25:14.840
咱们刚才看到了

25:14.840 --> 25:16.840
它交用这些函数进行验证

25:17.840 --> 25:19.840
然后再去初始化

25:19.840 --> 25:21.840
这个逐渐那些乱七八糟的事情

25:21.840 --> 25:22.840
这些事情做完了过

25:22.840 --> 25:24.840
再去做这些事情

25:24.840 --> 25:26.840
这是布尔属性

25:26.840 --> 25:29.840
看一下前面还有什么需要讲的

25:29.840 --> 25:31.840
函数内想就是你给我传的属性

25:31.840 --> 25:33.840
必须是函数

25:33.840 --> 25:35.840
什么时候我们会用到这个

25:35.840 --> 25:36.840
你觉得呢

25:36.840 --> 25:37.840
什么时候我们会用到

25:37.840 --> 25:38.840
就是你要传的

25:38.840 --> 25:40.840
你的属性必须是函数

25:40.840 --> 25:42.840
是不是事件啊

25:42.840 --> 25:43.840
对不对

25:43.840 --> 25:46.840
事件里面是不是要用到这个东西

25:46.840 --> 25:47.840
所以说我们这里可以

25:47.840 --> 25:48.840
比方说

25:48.840 --> 25:49.840
unclick

25:49.840 --> 25:51.840
unclick必须是个事件

25:51.840 --> 25:53.840
那么内想是什么

25:53.840 --> 25:54.840
内想就是propertypes

25:55.840 --> 25:57.840
funk

25:57.840 --> 25:59.840
那么你可以传可以不传

25:59.840 --> 26:00.840
像这个事件的话

26:00.840 --> 26:02.840
一般大家说都是可以传可以不传

26:02.840 --> 26:03.840
但如果你要求它必须传递的话

26:03.840 --> 26:05.840
是不是加上isrequired的完事了

26:06.840 --> 26:07.840
unclick

26:07.840 --> 26:10.840
必须是一个函数

26:10.840 --> 26:11.840
那么这样子一来呢

26:11.840 --> 26:13.840
你到时候你给我

26:13.840 --> 26:14.840
不传的东西是可以的

26:14.840 --> 26:15.840
不传是可以的

26:15.840 --> 26:16.840
到时候你给我一个

26:16.840 --> 26:17.840
乱七八糟的东西

26:17.840 --> 26:18.840
unclick给我一个制服串

26:18.840 --> 26:19.840
然后导致呢

26:19.840 --> 26:20.840
我那边出了问题

26:20.840 --> 26:22.840
那些实际传递的数据有问题

26:22.840 --> 26:23.840
对吧

26:23.840 --> 26:24.840
那这个时候呢

26:24.840 --> 26:26.840
就先给你提个警告再说

26:26.840 --> 26:27.840
让你

26:27.840 --> 26:28.840
这些错误呢

26:28.840 --> 26:30.840
主要不是用户发生的

26:30.840 --> 26:32.840
是开发者发生的错误

26:32.840 --> 26:34.840
我开发者写这个代码的时候

26:34.840 --> 26:35.840
再用一个组件

26:35.840 --> 26:37.840
结果呢我乱用这个组件

26:37.840 --> 26:39.840
导致这个组件出了问题

26:39.840 --> 26:40.840
所以说这个组件

26:40.840 --> 26:41.840
干脆一开始

26:41.840 --> 26:43.840
对这些属性进行检查

26:43.840 --> 26:45.840
一个通用的组件

26:45.840 --> 26:46.840
就是你以后呢

26:46.840 --> 26:47.840
你在公司里面

26:47.840 --> 26:48.840
如果你要去做一些

26:48.840 --> 26:49.840
通用的组件

26:49.840 --> 26:50.840
这些组件呢

26:50.840 --> 26:52.840
你的其他同事来使用

26:52.840 --> 26:54.840
其他同事呢都会用你的

26:54.840 --> 26:55.840
这个组件

26:55.840 --> 26:56.840
那么你就尽量的

26:56.840 --> 26:57.840
做完上一点

26:57.840 --> 26:58.840
你鬼知道他怎么会怎么去用

26:58.840 --> 26:59.840
他可能用这种方式

26:59.840 --> 27:00.840
给传这个东西

27:00.840 --> 27:01.840
可以给你传另外一个东西

27:01.840 --> 27:03.840
你不知道他怎么去用

27:03.840 --> 27:04.840
所以说呢

27:04.840 --> 27:05.840
你这里的最好是

27:05.840 --> 27:06.840
最好是

27:06.840 --> 27:07.840
把每一个属性的

27:07.840 --> 27:09.840
该检查的全报干检查

27:09.840 --> 27:10.840
好

27:10.840 --> 27:11.840
这是

27:11.840 --> 27:12.840
这个韩束属性

27:12.840 --> 27:14.840
通常用在事件里边啊

27:14.840 --> 27:15.840
什么的

27:15.840 --> 27:17.840
orbit 他就必须是个对象

27:17.840 --> 27:18.840
这个没什么好说的

27:18.840 --> 27:19.840
制服串就必须是个制服串

27:19.840 --> 27:20.840
symbol是我们之前

27:20.840 --> 27:21.840
es6讲的符号的一型

27:21.840 --> 27:22.840
对吧

27:22.840 --> 27:23.840
争碰有些形容在这里呢

27:23.840 --> 27:24.840
用了不多

27:24.840 --> 27:25.840
很少

27:25.840 --> 27:26.840
然后array呢

27:26.840 --> 27:27.840
他必须是输足

27:27.840 --> 27:28.840
这都没什么好说的啊

27:28.840 --> 27:29.840
那么nd

27:29.840 --> 27:30.840
就表示任意内容

27:30.840 --> 27:31.840
那就无所谓了

27:31.840 --> 27:32.840
那如果

27:32.840 --> 27:33.840
他是nd的话

27:33.840 --> 27:34.840
压根就可以不用写

27:34.840 --> 27:35.840
对吧

27:35.840 --> 27:36.840
压根就可以不用写在这

27:36.840 --> 27:37.840
就是有的时候

27:37.840 --> 27:38.840
为了公正

27:38.840 --> 27:39.840
这个nd内容有什么用的

27:39.840 --> 27:40.840
比方说

27:40.840 --> 27:42.840
有个属性c

27:42.840 --> 27:44.840
他本身没有什么用

27:44.840 --> 27:46.840
本身没有什么用

27:46.840 --> 27:47.840
就是说

27:47.840 --> 27:48.840
有个属性c

27:48.840 --> 27:49.840
给他写了nd

27:49.840 --> 27:51.840
你看啊

27:51.840 --> 27:53.840
怎么写这样子

27:53.840 --> 27:54.840
nd

27:54.840 --> 27:55.840
第一个用处呢

27:55.840 --> 27:56.840
是在这里

27:56.840 --> 27:57.840
是不是可以加上e-required

27:57.840 --> 27:59.840
尽管你的内容是nd

27:59.840 --> 28:01.840
任何内容都可以

28:01.840 --> 28:03.840
但是你是必填的

28:03.840 --> 28:04.840
是不是要这样写

28:04.840 --> 28:05.840
这是一个作用

28:05.840 --> 28:06.840
还有另外一个作用呢

28:06.840 --> 28:08.840
大家可能比较看重的是什么

28:08.840 --> 28:09.840
看重的就是

28:09.840 --> 28:10.840
我们在这里呢

28:10.840 --> 28:11.840
就可以把他的

28:11.840 --> 28:13.840
所有属性列出来

28:13.840 --> 28:14.840
到时候呢

28:14.840 --> 28:15.840
我查阅属性

28:15.840 --> 28:16.840
是不是非常非常方便

28:16.840 --> 28:17.840
比方说别人

28:17.840 --> 28:19.840
来查阅一下你这个组件

28:19.840 --> 28:20.840
你需要传递

28:20.840 --> 28:21.840
就是你有哪些属性

28:21.840 --> 28:22.840
我要传递

28:22.840 --> 28:23.840
那不是

28:23.840 --> 28:24.840
是不是其他地方代码

28:24.840 --> 28:25.840
一个不用看

28:25.840 --> 28:26.840
我只需要看这里就行了

28:26.840 --> 28:27.840
哪些是必填的

28:27.840 --> 28:28.840
是什么内容

28:28.840 --> 28:29.840
是不是看得一清二楚

28:29.840 --> 28:30.840
对吧

28:30.840 --> 28:31.840
你还可以把注射打好

28:31.840 --> 28:32.840
把注射打好

28:32.840 --> 28:34.840
你看得非常非常清楚

28:34.840 --> 28:35.840
那么c

28:35.840 --> 28:36.840
尽管那个属性是nd内容

28:36.840 --> 28:37.840
但是我把他写到这

28:37.840 --> 28:38.840
就表示呢

28:38.840 --> 28:39.840
我们这个组件里边

28:39.840 --> 28:40.840
可能要用到这个c

28:40.840 --> 28:41.840
这个内容

28:43.840 --> 28:44.840
重用e

28:44.840 --> 28:47.840
c是可以设置必填

28:47.840 --> 28:49.840
重用e是

28:51.840 --> 28:53.840
对列保持人期

28:55.840 --> 28:56.840
其实的意思呢

28:56.840 --> 28:57.840
是什么意思呢

28:57.840 --> 28:58.840
其实他的意思

28:58.840 --> 28:59.840
指的是

29:02.840 --> 29:03.840
其他的意思

29:03.840 --> 29:04.840
就是说

29:04.840 --> 29:05.840
我们可以把所有的属性

29:05.840 --> 29:06.840
放到这个对象里边

29:06.840 --> 29:07.840
对列保持人期

29:08.840 --> 29:10.840
所有属性

29:10.840 --> 29:11.840
都在

29:12.840 --> 29:13.840
该

29:13.840 --> 29:14.840
对

29:14.840 --> 29:15.840
对象中

29:22.840 --> 29:23.840
正型保持人期

29:25.840 --> 29:26.840
正型

29:26.840 --> 29:27.840
正期

29:27.840 --> 29:28.840
好

29:28.840 --> 29:29.840
这是这么一个特点

29:29.840 --> 29:30.840
这是ne

29:30.840 --> 29:31.840
那前面没什么好说的

29:31.840 --> 29:33.840
前面都是基本内容

29:33.840 --> 29:34.840
都是基本内容

29:34.840 --> 29:35.840
咱们来说一下

29:35.840 --> 29:36.840
后边的主要是

29:36.840 --> 29:37.840
后边的

29:37.840 --> 29:38.840
有些奇奇怪怪的东西

29:38.840 --> 29:39.840
来说一下

29:39.840 --> 29:40.840
这些东西

29:40.840 --> 29:41.840
可能在我们的开发中

29:41.840 --> 29:42.840
也

29:42.840 --> 29:43.840
可能会比较用

29:43.840 --> 29:44.840
可能会比较常见的用到

29:44.840 --> 29:45.840
因为有的时候

29:45.840 --> 29:46.840
我们可能会要

29:46.840 --> 29:47.840
进行更加精确的判断

29:47.840 --> 29:48.840
特别是什么呢

29:49.840 --> 29:50.840
特别是对一个对象而已

29:51.840 --> 29:52.840
对象的情况太多了

29:52.840 --> 29:53.840
对吧

29:53.840 --> 29:54.840
我怎么知道

29:54.840 --> 29:55.840
它是一个什么样的对象

29:55.840 --> 29:56.840
对吧

29:56.840 --> 29:57.840
特别是对这种情况

29:57.840 --> 29:58.840
那么我们可能要会

29:58.840 --> 30:00.840
进行一些更加精确的判断

30:00.840 --> 30:01.840
咱们来看一下这一部分

30:02.840 --> 30:03.840
咱们先看这个

30:03.840 --> 30:04.840
就是n

30:05.840 --> 30:06.840
这个约束了

30:06.840 --> 30:07.840
它是约束啥呢

30:07.840 --> 30:08.840
它是约束

30:08.840 --> 30:09.840
就是说那些

30:09.840 --> 30:11.840
任何可以被渲染的内容

30:11.840 --> 30:12.840
是什么呀

30:12.840 --> 30:13.840
制服圈啊

30:13.840 --> 30:14.840
是不可以渲染出来

30:14.840 --> 30:15.840
对吧

30:15.840 --> 30:16.840
可以渲染到页面上的内容

30:17.840 --> 30:18.840
还有什么呢

30:18.840 --> 30:19.840
还有什么

30:20.840 --> 30:22.840
数字对吧

30:23.840 --> 30:24.840
然后还有什么呢

30:24.840 --> 30:26.840
还有就是react元素

30:27.840 --> 30:28.840
也就是组件

30:28.840 --> 30:29.840
对不对

30:29.840 --> 30:30.840
什么DIV

30:30.840 --> 30:31.840
这都是组件

30:31.840 --> 30:32.840
对不对

30:32.840 --> 30:33.840
像这些东西

30:33.840 --> 30:34.840
这些东西

30:34.840 --> 30:35.840
那么就是

30:35.840 --> 30:37.840
可以使用这个类型约束

30:37.840 --> 30:38.840
load

30:39.840 --> 30:40.840
接下来咱们来看一下

30:40.840 --> 30:41.840
试一下

30:41.840 --> 30:42.840
这边呢

30:42.840 --> 30:43.840
我们

30:43.840 --> 30:44.840
加一个数学

30:44.840 --> 30:45.840
加一个数学

30:45.840 --> 30:46.840
d

30:46.840 --> 30:47.840
d

30:47.840 --> 30:48.840
它是一个load

30:49.840 --> 30:50.840
probs

30:50.840 --> 30:51.840
prob types

30:51.840 --> 30:52.840
load

30:52.840 --> 30:53.840
然后咱们把这个d

30:53.840 --> 30:54.840
显示到页面上

30:55.840 --> 30:56.840
this

30:56.840 --> 30:57.840
换个p元数

30:58.840 --> 30:59.840
this

30:59.840 --> 31:00.840
probs

31:01.840 --> 31:02.840
d2

31:02.840 --> 31:03.840
换个dmv

31:03.840 --> 31:04.840
换个dmv

31:05.840 --> 31:06.840
probs

31:06.840 --> 31:07.840
d

31:07.840 --> 31:08.840
放到这

31:09.840 --> 31:10.840
d呢

31:10.840 --> 31:11.840
还要求是一个load的

31:11.840 --> 31:12.840
那么咱们来看一下

31:12.840 --> 31:13.840
我们传递的时候

31:13.840 --> 31:14.840
d

31:15.840 --> 31:16.840
它可以传递个数

31:16.840 --> 31:18.840
能不能传递个字幕创呢

31:18.840 --> 31:19.840
我们看一下

31:19.840 --> 31:21.840
能不能传递个字幕创呢

31:21.840 --> 31:22.840
当然可以

31:22.840 --> 31:23.840
因为字幕创呢

31:23.840 --> 31:24.840
是可以显示到页面上的

31:24.840 --> 31:25.840
对吧

31:25.840 --> 31:26.840
是可以显示到页面上的

31:26.840 --> 31:27.840
可以渲染出来的

31:27.840 --> 31:28.840
然后呢

31:28.840 --> 31:29.840
就是说

31:29.840 --> 31:30.840
我加这个约束

31:30.840 --> 31:31.840
就表示我这一块东西

31:31.840 --> 31:32.840
是要用于渲染的

31:32.840 --> 31:33.840
是要用于渲染的

31:33.840 --> 31:35.840
那么这一块是没问题的

31:35.840 --> 31:37.840
那能不能写一个布尔呢

31:37.840 --> 31:38.840
可不可以呢

31:38.840 --> 31:39.840
看一下吧

31:40.840 --> 31:41.840
布尔是不是不行啊

31:41.840 --> 31:42.840
他说

31:44.840 --> 31:45.840
他必须要试一个

31:45.840 --> 31:47.840
就是可以渲染的节点

31:47.840 --> 31:49.840
一个可以渲染的节点

31:49.840 --> 31:50.840
布尔不行

31:50.840 --> 31:51.840
布尔不行

31:51.840 --> 31:53.840
那能不能试一个数字呢

31:53.840 --> 31:54.840
数字没问题

31:54.840 --> 31:55.840
数字没问题

31:55.840 --> 31:57.840
你看数字是可以的

31:57.840 --> 31:59.840
那能不能试一个load呢

31:59.840 --> 32:01.840
我们看一下吧

32:01.840 --> 32:02.840
load

32:02.840 --> 32:03.840
保存

32:03.840 --> 32:05.840
load没问题

32:05.840 --> 32:07.840
那这里我要好好说一下

32:07.840 --> 32:08.840
这个load

32:08.840 --> 32:10.840
还有什么undefined

32:10.840 --> 32:12.840
就这两个东西呢

32:12.840 --> 32:14.840
如果你传了这两个东西

32:14.840 --> 32:16.840
他会认为你是没有传递的

32:16.840 --> 32:18.840
他会认为你根本就没有传递

32:18.840 --> 32:20.840
他在进行检查的时候

32:20.840 --> 32:21.840
他在检查的时候

32:21.840 --> 32:23.840
他会认为根本就没有传递

32:23.840 --> 32:24.840
由于这里呢

32:24.840 --> 32:26.840
我们目前是没有设置

32:26.840 --> 32:27.840
非空验证的

32:27.840 --> 32:29.840
就是说没有设置他为避田

32:29.840 --> 32:30.840
因此呢

32:30.840 --> 32:31.840
他是

32:31.840 --> 32:32.840
没有保存

32:32.840 --> 32:33.840
没有保存

32:33.840 --> 32:34.840
是这么个意思

32:34.840 --> 32:35.840
这种load和undefined

32:35.840 --> 32:37.840
他是允许你用这种类型的

32:37.840 --> 32:38.840
不是这个意思

32:38.840 --> 32:39.840
这种类型你可以认为

32:39.840 --> 32:42.840
他只能允许支付算数字和rex元素

32:42.840 --> 32:44.840
所以说这一点呢

32:44.840 --> 32:45.840
你虽然传的load

32:45.840 --> 32:46.840
undefined没有抱错

32:46.840 --> 32:48.840
那是因为他没有非空验证

32:48.840 --> 32:49.840
如果你一旦

32:49.840 --> 32:51.840
把这个非空验证给他加上

32:51.840 --> 32:53.840
is required

32:53.840 --> 32:54.840
把这个非空验证加上

32:54.840 --> 32:55.840
你看一下

32:55.840 --> 32:56.840
是不是抱错了

32:56.840 --> 32:57.840
对吧

32:57.840 --> 32:58.840
他说他避田的

32:58.840 --> 33:01.840
但是你给我的是undefined

33:01.840 --> 33:02.840
然后这里呢

33:02.840 --> 33:03.840
一写的是load的话

33:03.840 --> 33:04.840
也是一样的问题

33:04.840 --> 33:06.840
也是一样的问题

33:06.840 --> 33:08.840
你给他指的是load

33:08.840 --> 33:10.840
但是我这里是避田的

33:10.840 --> 33:11.840
required

33:11.840 --> 33:12.840
指的是这么个意思

33:12.840 --> 33:14.840
并不是说load和undefined

33:14.840 --> 33:16.840
是可以允许在这个里边

33:16.840 --> 33:17.840
能够匹配这个类型的

33:17.840 --> 33:18.840
是不行的

33:18.840 --> 33:20.840
好吧

33:20.840 --> 33:21.840
然后还可以传什么呢

33:21.840 --> 33:24.840
还可以传一个rex元素

33:24.840 --> 33:25.840
看着

33:25.840 --> 33:28.840
这里面我们可以传一个rex元素

33:28.840 --> 33:30.840
这样子也没问题

33:30.840 --> 33:31.840
也没问题

33:31.840 --> 33:32.840
保存

33:32.840 --> 33:33.840
你看一下

33:33.840 --> 33:34.840
这样子也没问题

33:34.840 --> 33:37.840
总之你传了一个能够宣然的东西

33:37.840 --> 33:39.840
他就会通过验证

33:39.840 --> 33:40.840
你看一下

33:40.840 --> 33:43.840
传了个p元素进来看呗

33:43.840 --> 33:44.840
好

33:44.840 --> 33:45.840
这是这一块

33:45.840 --> 33:47.840
咱们还是在这里

33:47.840 --> 33:49.840
再打上个注释

33:49.840 --> 33:50.840
这说明了

33:50.840 --> 33:52.840
地避田

33:52.840 --> 33:55.840
而且必须是一个

33:55.840 --> 33:58.840
可以宣然的内容

33:58.840 --> 34:00.840
这个内容可以是制服串

34:00.840 --> 34:01.840
可以是数字

34:01.840 --> 34:02.840
也可以是什么呢

34:02.840 --> 34:06.840
也可以是一个rex元素

34:06.840 --> 34:07.840
好

34:07.840 --> 34:08.840
这是这一部分

34:08.840 --> 34:09.840
好

34:09.840 --> 34:10.840
下一个

34:10.840 --> 34:12.840
下一个是animate type

34:12.840 --> 34:14.840
我这里好像少写了一个

34:14.840 --> 34:16.840
这里少写了一个

34:16.840 --> 34:18.840
这里再加上

34:18.840 --> 34:22.840
加上animate

34:22.840 --> 34:23.840
这才是rex元素

34:23.840 --> 34:26.840
animate type是rex元素内容

34:26.840 --> 34:27.840
元素内容

34:27.840 --> 34:28.840
我们一个个说

34:28.840 --> 34:29.840
先说这个

34:29.840 --> 34:30.840
这个就是约束为

34:30.840 --> 34:32.840
它必须是一个rex元素了

34:32.840 --> 34:34.840
它必须是一个rex元素

34:34.840 --> 34:35.840
也就是说

34:35.840 --> 34:37.840
相当于是把上面这个东西

34:37.840 --> 34:38.840
再进一步

34:38.840 --> 34:39.840
更加精确的匹配

34:39.840 --> 34:41.840
更加精确的检查

34:41.840 --> 34:42.840
上一个是检查

34:42.840 --> 34:43.840
字不错

34:43.840 --> 34:44.840
数字

34:44.840 --> 34:45.840
那么还有一个包含rex元素

34:45.840 --> 34:46.840
那这一部分

34:46.840 --> 34:49.840
它只能写rex元素了

34:49.840 --> 34:50.840
只能写rex元素

34:50.840 --> 34:51.840
比方说

34:51.840 --> 34:52.840
咱们在这里

34:52.840 --> 34:53.840
再加一个属性

34:53.840 --> 34:55.840
加个属性e

34:55.840 --> 34:58.840
probs

34:58.840 --> 35:00.840
animate

35:00.840 --> 35:01.840
这个表示什么意思呢

35:01.840 --> 35:06.840
表示e必须是一个rex元素

35:06.840 --> 35:08.840
必须是一个rex元素

35:08.840 --> 35:09.840
咱们来看一下吧

35:09.840 --> 35:10.840
比方说

35:10.840 --> 35:12.840
这里咱们传递的时候

35:12.840 --> 35:13.840
再传两个属性

35:13.840 --> 35:15.840
OK

35:15.840 --> 35:17.840
再加个属性e

35:17.840 --> 35:19.840
e必须是一个rex元素

35:19.840 --> 35:21.840
你给它传一个字不错都不行

35:21.840 --> 35:22.840
包含

35:22.840 --> 35:24.840
你看一下

35:24.840 --> 35:25.840
就包错

35:25.840 --> 35:26.840
这个e不用去看界面

35:26.840 --> 35:28.840
咱们主要是关心它的类型检查

35:28.840 --> 35:30.840
你看是不是通不过检查

35:30.840 --> 35:31.840
对不对

35:31.840 --> 35:34.840
你必须要传一个rex元素

35:34.840 --> 35:36.840
也就是这里必须要用

35:36.840 --> 35:37.840
sx表达式

35:37.840 --> 35:39.840
或者是用rex

35:39.840 --> 35:43.840
crease element

35:43.840 --> 35:44.840
这样子可以

35:44.840 --> 35:45.840
总之就要传一个rex元素

35:45.840 --> 35:47.840
反正管理怎么弄

35:47.840 --> 35:48.840
OK

35:48.840 --> 35:49.840
那这里

35:49.840 --> 35:50.840
比方说

35:50.840 --> 35:51.840
给它写上一个

35:51.840 --> 35:54.840
he

35:54.840 --> 35:56.840
你看一下吧

35:56.840 --> 35:58.840
那么现在是不是没有包错了

35:58.840 --> 36:00.840
只不过页面上没办法用起来

36:00.840 --> 36:02.840
这样子

36:02.840 --> 36:03.840
我们有的时候

36:03.840 --> 36:04.840
就可以约束啥

36:04.840 --> 36:06.840
通过这个东西来约束啥

36:06.840 --> 36:08.840
来约束就是切封准属性

36:08.840 --> 36:10.840
比方说我们这里

36:10.840 --> 36:12.840
可以通过它来约束切封准

36:12.840 --> 36:14.840
切封准你光过传个字不错还不行

36:14.840 --> 36:16.840
你必须要传个元素进来

36:16.840 --> 36:18.840
有的时候我们可以这样约束

36:18.840 --> 36:19.840
或者说把切封准约束为什么

36:19.840 --> 36:21.840
约束络的也可以

36:21.840 --> 36:22.840
因为切封准

36:22.840 --> 36:23.840
它总归

36:24.840 --> 36:26.840
它也可以传个函数

36:26.840 --> 36:28.840
那就是一些奇奇怪怪的用法

36:28.840 --> 36:30.840
通常起光下的纸节点

36:30.840 --> 36:32.840
通常不是什么函数

36:32.840 --> 36:34.840
通常都是一些

36:35.840 --> 36:36.840
通常纸节点

36:36.840 --> 36:38.840
传过来的都是

36:38.840 --> 36:39.840
一个可以宣传的东西

36:39.840 --> 36:41.840
可以把它约束为node

36:41.840 --> 36:42.840
甚至我可以进一步

36:42.840 --> 36:43.840
把它约束为animate

36:43.840 --> 36:44.840
你必须是一个元素

36:44.840 --> 36:46.840
你够传字不错的不行

36:46.840 --> 36:47.840
对吧

36:47.840 --> 36:48.840
OK

36:48.840 --> 36:49.840
那么我们可以

36:49.840 --> 36:51.840
可以通过这种方式来进行约束

36:51.840 --> 36:52.840
就是animate

36:52.840 --> 36:53.840
你必须要传个元素

36:53.840 --> 36:54.840
非常好理解

36:54.840 --> 36:55.840
那么下一个

36:55.840 --> 36:57.840
下一个就点神奇了

36:57.840 --> 36:59.840
这个用的比较少

36:59.840 --> 37:00.840
用的比较少

37:00.840 --> 37:01.840
有的时候

37:01.840 --> 37:02.840
在一些特殊场景里面

37:02.840 --> 37:03.840
可能会用到

37:03.840 --> 37:05.840
就是在检查的时候

37:05.840 --> 37:07.840
要求他给我传一个啥呢

37:07.840 --> 37:09.840
他给我传一个元素内行进来

37:09.840 --> 37:11.840
你给我传一个元素内行

37:11.840 --> 37:12.840
animate type

37:12.840 --> 37:13.840
那么这个东西是啥呢

37:13.840 --> 37:17.150
咱们来看一下吧

37:17.150 --> 37:18.150
EF

37:19.150 --> 37:20.150
propt types

37:20.150 --> 37:22.150
第二animate type

37:22.150 --> 37:23.150
这个是F

37:23.150 --> 37:26.150
必须是一个元素内行

37:26.150 --> 37:29.150
或者叫做主建内行

37:29.150 --> 37:31.150
或者叫做主建内行

37:31.150 --> 37:32.150
什么意思呢

37:32.150 --> 37:33.150
那么这里呢

37:33.150 --> 37:34.150
我举个例子

37:35.150 --> 37:37.150
我们这里新建个文件

37:37.150 --> 37:39.150
新建个文件

37:39.150 --> 37:40.150
就比方说

37:40.150 --> 37:41.150
comp

37:41.150 --> 37:42.150
就这个文件

37:42.150 --> 37:43.150
一个主建

37:43.150 --> 37:44.150
啥用没有

37:44.150 --> 37:45.150
啥用没有

37:45.150 --> 37:46.150
FC

37:46.150 --> 37:48.150
这里就返回一个

37:48.150 --> 37:49.150
HEComp

37:49.150 --> 37:50.150
就这么一个主建

37:50.150 --> 37:51.150
啥用没有

37:51.150 --> 37:52.150
然后呢

37:52.150 --> 37:53.150
我们这里呢

37:53.150 --> 37:54.150
你看着啊

37:54.150 --> 37:56.150
我给这个F传词的时候

37:57.150 --> 37:59.150
给这个F传词的时候

37:59.150 --> 38:00.150
我们把导入进来啊

38:01.150 --> 38:02.150
comp

38:02.150 --> 38:03.150
from

38:03.150 --> 38:04.150
表写杠

38:04.150 --> 38:05.150
comp

38:06.150 --> 38:08.150
比方说我们之前的约束呢

38:08.150 --> 38:09.150
什么D啊

38:09.150 --> 38:10.150
什么E啊

38:10.150 --> 38:11.150
这些约束啊

38:11.150 --> 38:12.150
你看这个D和E的约束

38:12.150 --> 38:14.150
一个是可以渲染

38:14.150 --> 38:15.150
那么这个主建能不能渲染

38:15.150 --> 38:16.150
这个comp主建能不能渲染

38:16.150 --> 38:17.150
当然可以渲染

38:17.150 --> 38:18.150
对吧

38:18.150 --> 38:19.150
然后呢

38:19.150 --> 38:20.150
还有什么

38:20.150 --> 38:21.150
基本上它是个rex元素

38:21.150 --> 38:23.150
那么这个东西是不是个rex元素

38:23.150 --> 38:24.150
是可以的

38:24.150 --> 38:25.150
所以说在D里边呢

38:25.150 --> 38:27.150
我们可以给他一个什么呢

38:27.150 --> 38:28.150
给他一个comp

38:28.150 --> 38:29.150
可不可以

38:31.660 --> 38:32.660
给他这么一个东西

38:32.660 --> 38:33.660
可不可以

38:33.660 --> 38:34.660
当然可以

38:34.660 --> 38:36.660
在E里边说可以给他这个东西

38:36.660 --> 38:37.660
但是如果在F里面

38:37.660 --> 38:38.660
给他这个东西

38:38.660 --> 38:39.660
他要出问题了

38:39.660 --> 38:40.660
保存

38:40.660 --> 38:41.660
我们看一下吧

38:41.660 --> 38:42.660
其他的没有出问题

38:42.660 --> 38:44.660
就是这个F出了问题

38:44.660 --> 38:46.660
F出了什么问题呢

38:46.660 --> 38:47.660
F说

38:47.660 --> 38:49.660
你给我传的是一个啥玩意啊

38:49.660 --> 38:50.660
你给我传的

38:50.660 --> 38:51.660
是一个

38:51.660 --> 38:52.660
啊

38:52.660 --> 38:53.660
不解个词是个对象

38:53.660 --> 38:55.660
但是我需要的是啥呢

38:55.660 --> 38:58.660
需要的是一个元素内形

38:58.660 --> 39:01.660
什么叫做元素内形啊

39:01.660 --> 39:03.660
什么叫做元素内形

39:03.660 --> 39:05.660
好

39:05.660 --> 39:07.660
应该这里应该传的是什么了

39:07.660 --> 39:09.660
应该传的是这个

39:09.660 --> 39:10.660
这个构造函数本身

39:10.660 --> 39:11.660
或者说这个函数本身

39:11.660 --> 39:12.660
如果你是函数的话

39:12.660 --> 39:14.660
就是把函数本身传过去

39:14.660 --> 39:15.660
如果你是构造函数的话

39:15.660 --> 39:17.660
那么就把构造函数

39:17.660 --> 39:18.660
本身传过去

39:18.660 --> 39:19.660
他传的是这么个东西

39:19.660 --> 39:20.660
对吧

39:20.660 --> 39:22.660
他是把这个元素的构造函数传过去

39:22.660 --> 39:24.660
那么传过去过后呢

39:24.660 --> 39:25.660
这边如果要用

39:25.660 --> 39:26.660
这边如果要用的话

39:26.660 --> 39:28.660
那应该怎么用呢

39:28.660 --> 39:30.660
我这里写成大写的F

39:30.660 --> 39:32.660
大写的F

39:33.660 --> 39:36.660
这边应该怎么用呢

39:36.660 --> 39:37.660
这边的话

39:37.660 --> 39:38.660
他传的就不是主见了

39:38.660 --> 39:39.660
传的就不是主见了

39:39.660 --> 39:40.660
你千万不能这样子用啊

39:40.660 --> 39:42.660
千万不能这样子用啊

39:42.660 --> 39:44.660
你看一下

39:44.660 --> 39:46.660
这写错了

39:46.660 --> 39:47.660
this props

39:48.660 --> 39:49.660
千万不能这样子用

39:49.660 --> 39:50.660
你看一下

39:50.660 --> 39:51.660
如果这样子用的话

39:51.660 --> 39:52.660
你看他抱错

39:52.660 --> 39:53.660
他说你这个F啊

39:53.660 --> 39:55.660
它不是一个react元素

39:55.660 --> 39:56.660
它是什么

39:56.660 --> 39:57.660
它是构造函数

39:57.660 --> 39:59.660
你不能把一个函数传进来对吧

39:59.660 --> 40:00.660
它如果是内组件的话

40:00.660 --> 40:01.660
它就是构造函数

40:01.660 --> 40:02.660
如果是一个函数主见的话

40:02.660 --> 40:04.660
它就是个普通函数

40:04.660 --> 40:05.660
你是不是能不能

40:05.660 --> 40:07.660
不能把一个函数传过来啊

40:07.660 --> 40:08.660
对吧

40:08.660 --> 40:09.660
那我调用函数

40:09.660 --> 40:10.660
那调用函数

40:10.660 --> 40:11.660
不是我们常见的做法

40:11.660 --> 40:12.660
调用函数当然也可以

40:12.660 --> 40:13.660
只不过这里

40:13.660 --> 40:14.660
应该怎么来传定呢

40:14.660 --> 40:15.660
一看着

40:15.660 --> 40:16.660
这里应该是用这种方式

40:16.660 --> 40:18.660
它不是一个函数吗

40:18.660 --> 40:19.660
对不对

40:19.660 --> 40:20.660
它是不是主见

40:20.660 --> 40:21.660
这个东西

40:21.660 --> 40:22.660
这个F啊

40:22.660 --> 40:24.660
它是不是跟这个东西是一样的

40:24.660 --> 40:25.660
对吧

40:25.660 --> 40:26.660
它把这个东西传过来了

40:26.660 --> 40:27.660
这个F跟这个东西

40:27.660 --> 40:28.660
是不是一样的

40:28.660 --> 40:29.660
所以说呢

40:29.660 --> 40:30.660
我们这里呢

40:30.660 --> 40:31.660
可以这样子

40:31.660 --> 40:36.350
先把它保存到这个F里边

40:36.350 --> 40:37.350
好

40:37.350 --> 40:38.350
然后呢

40:38.350 --> 40:40.350
这边使用这种方式

40:40.350 --> 40:41.350
F

40:41.350 --> 40:42.350
这种方式来使用

40:42.350 --> 40:44.350
把当成一个主见来使用

40:44.350 --> 40:46.350
这个主见是通过属性传过来的

40:46.350 --> 40:47.350
看没有

40:47.350 --> 40:50.350
这样子的别人就可以传一个主见过来

40:50.350 --> 40:52.350
而不是主见构造好的元素

40:52.350 --> 40:53.350
是个主见本身

40:53.350 --> 40:54.350
主见的内型

40:54.350 --> 40:56.350
把这个主见内型传过来

40:56.350 --> 40:57.350
明白这个意思吗

40:57.350 --> 40:58.350
可以通过这种方式

40:58.350 --> 41:00.350
把一个主见内型传过来

41:00.350 --> 41:01.350
你看没有

41:01.350 --> 41:03.350
那么现在是不是也形成出来了

41:03.350 --> 41:04.350
好好理一下啊

41:04.350 --> 41:05.350
你这个东西呢

41:05.350 --> 41:06.350
你看看

41:06.350 --> 41:07.350
这个东西传过来的是一个

41:07.350 --> 41:08.350
主见内型

41:08.350 --> 41:09.350
是不是相当于就是它

41:09.350 --> 41:10.350
对不对

41:10.350 --> 41:11.350
就是它

41:11.350 --> 41:12.350
这个F就是它

41:12.350 --> 41:13.350
然后把它保存到一个变量F里边

41:13.350 --> 41:15.350
那么这里直接使用

41:15.350 --> 41:16.350
有些同学说

41:16.350 --> 41:18.350
为什么不能这样子用呢

41:19.350 --> 41:20.350
就是Z10.

41:21.350 --> 41:23.350
Probs.F

41:23.350 --> 41:24.350
能不能这样子用呢

41:24.350 --> 41:25.350
不行

41:25.350 --> 41:26.350
它与发不支持

41:26.350 --> 41:27.350
与发不支持

41:27.350 --> 41:28.350
所以说你等了

41:28.350 --> 41:29.350
先保存一下

41:29.350 --> 41:31.350
把它保存在变量里边

41:31.350 --> 41:33.350
然后直接在变量里边使用

41:33.350 --> 41:35.350
明白这个意思吧

41:35.350 --> 41:36.350
好

41:36.350 --> 41:37.350
这是这种传递

41:37.350 --> 41:39.350
那么是不是可以想象得到

41:39.350 --> 41:40.350
是不是又打开了一个

41:40.350 --> 41:41.350
新世界的大门了

41:41.350 --> 41:44.350
它可以把个主见内型传过来

41:44.350 --> 41:45.350
很好玩

41:45.350 --> 41:46.350
很好玩

41:46.350 --> 41:48.350
咱们后边再说吧

41:48.350 --> 41:50.350
我现在先把这个东西放着

41:50.350 --> 41:51.350
放着

41:51.350 --> 41:52.350
知道它可以传一个

41:52.350 --> 41:53.350
主见内型

41:53.350 --> 41:55.350
实际上属性啥都可以传递

41:55.350 --> 41:56.350
没有啥

41:56.350 --> 41:58.350
就是没有啥不可以传递的

41:58.350 --> 42:01.350
关键是看你拿到之后怎么去用

42:02.350 --> 42:03.350
下一个

42:03.350 --> 42:05.350
下一个是Instance of 构造函数

42:05.350 --> 42:07.350
构造函数的实力

42:08.350 --> 42:09.350
就是说

42:09.350 --> 42:10.350
这东西

42:10.350 --> 42:11.350
它会怎么来验证呢

42:11.350 --> 42:12.350
我就说一下

42:12.350 --> 42:13.350
它怎么来验证

42:13.350 --> 42:15.350
它是这样子

42:15.350 --> 42:17.350
它的验证方式呢

42:17.350 --> 42:18.350
是这样

42:18.350 --> 42:20.350
它的验证方式呢

42:20.350 --> 42:21.350
它到时候呢

42:21.350 --> 42:22.350
会把你传递的属性呢

42:22.350 --> 42:23.350
判断一下

42:23.350 --> 42:24.350
判断什么

42:24.350 --> 42:25.350
就是你传递的东西

42:25.350 --> 42:26.350
然后呢

42:26.350 --> 42:28.350
使用Instance of

42:28.350 --> 42:29.350
然后你

42:29.350 --> 42:30.350
然后看一下这个

42:30.350 --> 42:31.350
跟你传递的构造函数

42:31.350 --> 42:32.350
是不是一样的

42:32.350 --> 42:33.350
啊

42:33.350 --> 42:34.350
看一下这个判断

42:34.350 --> 42:35.350
能不能通过

42:35.350 --> 42:36.350
能通过的话

42:36.350 --> 42:37.350
验证成功

42:37.350 --> 42:38.350
没法通过的话

42:38.350 --> 42:39.350
就验证失败

42:39.350 --> 42:40.350
它会把你传递的属性值

42:40.350 --> 42:42.350
用这样的方式来进行判断

42:42.350 --> 42:43.350
简单

42:43.350 --> 42:44.350
所以它判断的是

42:44.350 --> 42:45.350
是不是某一个构造函数的实力

42:45.350 --> 42:46.350
当然这样子

42:46.350 --> 42:48.350
也可以判断继承

42:48.350 --> 42:49.350
我们通常用这种方式呢

42:49.350 --> 42:51.350
就是来约束他说什么

42:51.350 --> 42:52.350
就是说

42:52.350 --> 42:54.350
你要传给我某一个组件

42:54.350 --> 42:56.350
你必须要传给我某一个组件

42:56.350 --> 42:58.350
你还不能乱传其他组件

42:58.350 --> 42:59.350
你必须要给我传

42:59.350 --> 43:01.350
某一个组件的东西

43:01.350 --> 43:03.350
或者说某一类

43:03.350 --> 43:04.350
比方说

43:04.350 --> 43:05.350
咱们组件有继承关系

43:05.350 --> 43:07.350
虽然说我们在reaction里面

43:07.350 --> 43:08.350
不太会使用

43:08.350 --> 43:10.350
在组件之间的继承

43:10.350 --> 43:11.350
你看我们学了这么久

43:11.350 --> 43:12.350
有没有在组件里面

43:12.350 --> 43:14.350
这个组件继承另外一个组件

43:14.350 --> 43:15.350
并没有

43:15.350 --> 43:16.350
不太会使用这种情况

43:16.350 --> 43:18.350
那如果使用了

43:18.350 --> 43:19.350
如果使用了

43:19.350 --> 43:21.350
那么你可以这样子去进行约束

43:21.350 --> 43:22.350
但是更多的时候

43:22.350 --> 43:23.350
如果要用他的话

43:23.350 --> 43:25.350
约束的是以普通的对象

43:25.350 --> 43:26.350
约束的是普通对象

43:26.350 --> 43:28.350
这我就不带多举例的

43:28.350 --> 43:30.350
那就举个例吧

43:30.350 --> 43:32.350
举个例吧

43:32.350 --> 43:35.350
我这里举堂令了

43:35.350 --> 43:37.350
我们这里比方

43:37.350 --> 43:38.350
再导出一个内

43:38.350 --> 43:40.350
再导出一些内

43:41.350 --> 43:43.350
class A

43:43.350 --> 43:45.350
class A

43:45.350 --> 43:47.350
没啥东西

43:47.350 --> 43:49.350
class B

43:49.350 --> 43:52.350
一个是天子

43:52.350 --> 43:54.350
再导出两个内

43:54.350 --> 43:55.350
A和B没啥东西

43:55.350 --> 43:56.350
就没有东西

43:56.350 --> 43:58.350
然后我们这里就

43:58.350 --> 44:00.350
写这么一个

44:00.350 --> 44:01.350
fg

44:01.350 --> 44:02.350
写了一大堆

44:02.350 --> 44:03.350
这些都没有实际意义

44:03.350 --> 44:05.350
我们都是

44:05.350 --> 44:07.350
做一个概述

44:07.350 --> 44:08.350
就是说一下

44:08.350 --> 44:09.350
它这里边渔法是什么

44:09.350 --> 44:11.350
该怎么来用

44:11.350 --> 44:12.350
具体的例子

44:12.350 --> 44:13.350
我们后边遇到了再说

44:13.350 --> 44:14.350
直到我们知道

44:14.350 --> 44:16.350
有这么一些验证就行了

44:16.350 --> 44:17.350
比方说这里有两个内

44:17.350 --> 44:19.350
然后我们这里使用

44:19.350 --> 44:21.350
instance

44:21.350 --> 44:24.350
它必须是A的实力

44:24.350 --> 44:30.350
G必须是A的实力

44:30.350 --> 44:31.350
也就是

44:31.350 --> 44:32.350
G这个对象

44:32.350 --> 44:34.350
它的绵形链上

44:34.350 --> 44:37.350
它必须有A

44:37.350 --> 44:39.350
必须有A的就是圆形

44:39.350 --> 44:40.350
就这么个意思

44:40.350 --> 44:41.350
好那么这样子

44:41.350 --> 44:43.350
你一来还要传递的话

44:43.350 --> 44:44.350
当然我们也可以给

44:44.350 --> 44:45.350
还要约税什么

44:45.350 --> 44:47.350
easy required都可以

44:47.350 --> 44:49.350
如果还要传递的话

44:49.350 --> 44:50.350
比方说

44:50.350 --> 44:52.350
它这里要传递这个G的话

44:52.350 --> 44:54.350
那么我们这里看一下

44:54.350 --> 44:56.350
传递一个普通对象行不行

44:56.350 --> 44:57.350
传递一个普通对象

44:57.350 --> 44:59.350
你看一下一个空对象

44:59.350 --> 45:00.350
行不行

45:00.350 --> 45:02.350
它说你G是一个普通的

45:02.350 --> 45:03.350
objects

45:03.350 --> 45:05.350
它说内形是objects

45:05.350 --> 45:07.350
我希望的是内形是A

45:07.350 --> 45:08.350
是要继承A的

45:08.350 --> 45:09.350
所以说不行

45:09.350 --> 45:10.350
所以说这里

45:10.350 --> 45:11.350
我们要怎么来做呢

45:11.350 --> 45:13.350
要import

45:13.350 --> 45:15.350
把A和B都导入进来吧

45:17.350 --> 45:18.350
在这里导入

45:18.350 --> 45:21.980
A和B都导入进来

45:21.980 --> 45:22.980
然后这里

45:22.980 --> 45:23.980
我们可以用什么呢

45:23.980 --> 45:25.980
用6一个B对吧

45:25.980 --> 45:27.980
6一个B可不可以

45:27.980 --> 45:28.980
保存

45:28.980 --> 45:29.980
你看一下

45:29.980 --> 45:30.980
是不是可以

45:30.980 --> 45:31.980
就没有报处了吧

45:31.980 --> 45:32.980
它就报了个警告

45:32.980 --> 45:33.980
它说你A导入了

45:33.980 --> 45:34.980
又没有使用

45:34.980 --> 45:36.980
那创建个A的对象可不可以

45:37.980 --> 45:38.980
这些就没问题了

45:38.980 --> 45:39.980
看没有

45:39.980 --> 45:40.980
这些没问题

45:40.980 --> 45:41.980
是这么个意思

45:42.980 --> 45:43.980
这是这一块

45:43.980 --> 45:45.980
我还是分开导入

45:45.980 --> 45:46.980
导进来吧

45:46.980 --> 45:49.620
边域

45:51.620 --> 45:52.620
就这样吧

45:53.620 --> 45:54.620
B可以

45:54.620 --> 45:55.620
A也可以

45:55.620 --> 45:58.250
好

45:58.250 --> 45:59.250
这是这一部分

45:59.250 --> 46:00.250
下一个

46:02.250 --> 46:03.250
one note

46:04.250 --> 46:05.250
表示的是每一句

46:05.250 --> 46:07.250
每一句可能这个概念

46:07.250 --> 46:08.250
还有听说过

46:08.250 --> 46:09.250
我简单说一下

46:09.250 --> 46:11.250
它是面向对象语言里面的一种概念

46:11.250 --> 46:13.250
就是说从一组织里面

46:13.250 --> 46:15.250
取出其中一个

46:16.250 --> 46:17.250
这个字呢

46:17.250 --> 46:19.250
它必须在某一组织当中

46:19.250 --> 46:20.250
就是每一句

46:20.250 --> 46:21.250
one note 什么意思

46:21.250 --> 46:22.250
从个单词

46:22.250 --> 46:23.250
又可以看得非常非常清楚

46:23.250 --> 46:24.250
它应该

46:24.250 --> 46:25.250
这个属性

46:25.250 --> 46:26.250
应该是在

46:26.250 --> 46:28.250
应该是数组当中的一个

46:28.250 --> 46:29.250
数组当中的一个

46:29.250 --> 46:30.250
对吧

46:30.250 --> 46:31.250
这里里边要传一个数组

46:31.250 --> 46:33.250
它应该是属于数组当中的一个

46:33.250 --> 46:34.250
就这么简单

46:35.250 --> 46:36.250
非常好理解

46:36.250 --> 46:37.250
比方说

46:37.250 --> 46:38.250
一个6

46:39.250 --> 46:40.250
probs

46:40.250 --> 46:42.250
最常见的就是这个东西

46:42.250 --> 46:43.250
one note

46:46.390 --> 46:47.390
那么这里

46:47.390 --> 46:48.390
传一个数组进来

46:49.390 --> 46:50.390
数组里面比方说

46:50.390 --> 46:51.390
男

46:51.390 --> 46:52.390
和

46:52.390 --> 46:53.390
女

46:54.390 --> 46:55.390
只能是这两个

46:55.390 --> 46:56.390
只能是这两个

46:56.390 --> 46:57.390
中了一个

46:57.390 --> 46:58.390
你不能过于传别的

46:58.390 --> 46:59.390
那行吗

46:59.390 --> 47:01.390
我这里没有设置为必填

47:01.390 --> 47:02.390
所以说现在没爆错

47:02.390 --> 47:03.390
接下来

47:03.390 --> 47:04.390
我们如果设置必填的话

47:04.390 --> 47:05.390
就爆错了

47:05.390 --> 47:06.390
那么现在

47:06.390 --> 47:07.390
我们给它传这个属性

47:07.390 --> 47:08.390
这个是

47:08.390 --> 47:09.390
等于

47:09.390 --> 47:10.390
它要么传男

47:11.390 --> 47:12.390
没问题

47:12.390 --> 47:13.390
要么传女

47:15.390 --> 47:16.390
但是你给我传的其他东西

47:16.390 --> 47:17.390
就要爆错

47:17.390 --> 47:18.390
对吧

47:18.390 --> 47:19.390
这样是不是更加严格的约束

47:19.390 --> 47:20.390
对不对

47:21.390 --> 47:22.390
就这么简单

47:22.390 --> 47:23.390
没有这么复杂的

47:23.390 --> 47:24.390
都很简单

47:25.390 --> 47:26.390
然后下面这个

47:26.390 --> 47:27.390
下面这个

47:27.390 --> 47:28.390
areal

47:29.390 --> 47:32.390
必须是某一类型

47:32.390 --> 47:35.390
某一类型组成的数组

47:35.390 --> 47:36.390
就是说

47:37.390 --> 47:38.390
它这个东西

47:39.390 --> 47:40.390
这个数组

47:40.390 --> 47:42.390
你传的是什么

47:42.390 --> 47:43.390
传的必须是数组

47:44.390 --> 47:46.390
并且数组的每一项

47:46.390 --> 47:48.390
它要是这种类型

47:48.390 --> 47:50.390
它必须要是这种类型

47:50.390 --> 47:51.390
是这么个意思

47:52.390 --> 47:53.390
你传的数组

47:53.390 --> 47:54.390
每一项

47:54.390 --> 47:55.390
它就必须是这种类型

47:55.390 --> 47:57.390
那完比方说

47:57.390 --> 47:58.390
比方说

47:59.390 --> 48:00.390
这个打个数是

48:01.390 --> 48:07.390
必须是数组当中的一个

48:08.390 --> 48:09.390
下一个

48:09.390 --> 48:11.390
efgh

48:11.390 --> 48:12.390
这个数项

48:13.390 --> 48:14.390
propt types

48:15.390 --> 48:16.390
areal

48:17.390 --> 48:20.770
之前我们有这么一个约束

48:20.770 --> 48:21.770
就是areal

48:21.770 --> 48:22.770
areal它是一个数组

48:22.770 --> 48:23.770
只要你是数组就行

48:23.770 --> 48:24.770
管你是什么数组

48:25.770 --> 48:26.770
但是现在呢

48:26.770 --> 48:27.770
areal

48:27.770 --> 48:28.770
它必须是数组东

48:28.770 --> 48:29.770
某一

48:29.770 --> 48:31.770
它必须是某一类型组成的数组

48:31.770 --> 48:32.770
那什么意思呢

48:33.770 --> 48:34.770
比方说

48:34.770 --> 48:35.770
我这里呢

48:35.770 --> 48:36.770
给它写上这么一个东西

48:36.770 --> 48:37.770
写上一个

48:37.770 --> 48:40.770
propt types

48:40.770 --> 48:41.770
number

48:41.770 --> 48:42.770
什么意思

48:42.770 --> 48:43.770
它就表示的是

48:43.770 --> 48:45.770
这个数组必须是一个数字数组

48:46.770 --> 48:47.770
它可以这么精确

48:48.770 --> 48:49.770
保存

48:50.770 --> 48:51.770
咱们在这里看一下

48:51.770 --> 48:52.770
我们现在呢

48:52.770 --> 48:53.770
给它写上

48:53.770 --> 48:54.770
就是

48:55.770 --> 48:56.770
一个数组

48:56.770 --> 48:57.770
h

48:57.770 --> 48:58.770
给它传个数组

48:59.770 --> 49:00.770
如果这个数组里面

49:00.770 --> 49:01.770
是一个字母串

49:01.770 --> 49:02.770
你看一下

49:02.770 --> 49:03.770
保存

49:03.770 --> 49:04.770
保错

49:04.770 --> 49:07.770
它说你数组的第一项就不满足要求

49:07.770 --> 49:08.770
什么要求呢

49:08.770 --> 49:10.770
它必须是数字

49:10.770 --> 49:11.770
但是呢

49:11.770 --> 49:12.770
你是一个字母串

49:12.770 --> 49:13.770
就这么一个意思

49:13.770 --> 49:15.770
它会对数组每一项

49:15.770 --> 49:17.770
来进行验证

49:17.770 --> 49:18.770
挨摘的验证

49:18.770 --> 49:19.770
那这个数组没有传进来

49:19.770 --> 49:20.770
空数组呢

49:20.770 --> 49:21.770
那没问题

49:21.770 --> 49:22.770
那没问题

49:22.770 --> 49:23.770
这个没问题

49:23.770 --> 49:24.770
但是你有数据的话

49:24.770 --> 49:26.770
就必须要符合要求

49:26.770 --> 49:27.770
这个意思

49:28.770 --> 49:29.770
好

49:29.770 --> 49:30.770
这是关于这一块

49:30.770 --> 49:33.140
好

49:33.140 --> 49:34.140
然后呢

49:34.140 --> 49:35.140
这里

49:37.140 --> 49:38.140
对象呢

49:38.140 --> 49:39.140
它指的是

49:39.140 --> 49:40.140
这个对象

49:40.140 --> 49:42.140
是有某一类型

49:42.140 --> 49:44.140
某一类型的指数称

49:44.140 --> 49:46.140
这是什么意思呢

49:46.140 --> 49:47.140
好

49:47.140 --> 49:48.140
咱们来演示一下吧

49:48.140 --> 49:49.140
刚才是约束数组

49:49.140 --> 49:50.140
对啊

49:50.140 --> 49:51.140
那现在约束对象了

49:51.140 --> 49:52.140
好

49:52.140 --> 49:53.140
来吧

49:53.140 --> 49:54.140
对象

49:54.140 --> 49:56.140
e f g h i

49:56.140 --> 49:58.140
probe types

49:59.140 --> 50:01.140
objects

50:03.140 --> 50:05.140
那么这里边呢

50:05.140 --> 50:06.140
填啥呢

50:06.140 --> 50:07.140
比方说吧

50:07.140 --> 50:08.140
咱们这样子填

50:08.140 --> 50:10.140
probes types

50:10.140 --> 50:11.140
number

50:11.140 --> 50:12.140
什么意思呢

50:12.140 --> 50:14.140
它表示的是对象里边

50:14.140 --> 50:16.140
所有的属性值必须是数字

50:16.140 --> 50:19.140
所有的属性值必须是数字

50:19.140 --> 50:20.140
好

50:20.140 --> 50:21.140
那咱们看一下

50:21.140 --> 50:22.140
看一下

50:22.140 --> 50:23.140
这里边呢

50:23.140 --> 50:25.140
我们写上一个i

50:26.140 --> 50:27.140
然后呢

50:27.140 --> 50:28.140
我这里肯定要传对象

50:28.140 --> 50:29.140
你肯定不能传其他东西

50:29.140 --> 50:31.140
你全要传其他东西肯定要报错

50:33.140 --> 50:34.140
这里

50:34.140 --> 50:35.140
要传正确的

50:35.140 --> 50:36.140
二

50:36.140 --> 50:38.520
三

50:38.520 --> 50:39.520
这个i是不是报错了

50:39.520 --> 50:40.520
对吧

50:40.520 --> 50:41.520
报错了

50:41.520 --> 50:42.520
它必须要传对象

50:42.520 --> 50:43.520
这个毫无疑问

50:43.520 --> 50:44.520
好

50:44.520 --> 50:45.520
如果你传了个对象的话

50:45.520 --> 50:46.520
比方说一个属性a

50:46.520 --> 50:47.520
属性a

50:47.520 --> 50:48.520
它是个字无创

50:48.520 --> 50:49.520
报存

50:49.520 --> 50:50.520
报错了

50:50.520 --> 50:51.520
它说属性a

50:51.520 --> 50:52.520
它是个字无创

50:52.520 --> 50:53.520
但是呢

50:53.520 --> 50:54.520
我希望的是一个数字

50:54.520 --> 50:55.520
a呢

50:55.520 --> 50:56.520
是一个数字就没问题

50:57.520 --> 50:58.520
你看是不是没问题

50:58.520 --> 50:59.520
对吧

50:59.520 --> 51:00.520
刚才是验证数组

51:00.520 --> 51:02.520
那么现在是验证对象

51:02.520 --> 51:03.520
验证对象

51:03.520 --> 51:04.520
没问题吧

51:05.520 --> 51:06.520
但是呢

51:06.520 --> 51:07.520
这个东西啊

51:07.520 --> 51:08.520
好像是没什么用

51:08.520 --> 51:09.520
要数组呢

51:09.520 --> 51:10.520
倒是很有用

51:10.520 --> 51:11.520
对吧

51:11.520 --> 51:12.520
数组里面

51:12.520 --> 51:13.520
我们这样子约束

51:13.520 --> 51:14.520
挺有用的

51:14.520 --> 51:15.520
但是这个玩意

51:15.520 --> 51:16.520
就没有什么用

51:16.520 --> 51:17.520
没有什么意义的

51:17.520 --> 51:18.520
因为

51:18.520 --> 51:20.520
谁会去限制对象里面

51:20.520 --> 51:21.520
每个属性值

51:21.520 --> 51:22.520
是什么类型

51:22.520 --> 51:23.520
谁会去限制这个玩意呢

51:24.520 --> 51:25.520
通常情况下

51:25.520 --> 51:26.520
没有什么用

51:26.520 --> 51:27.520
我们在这里

51:27.520 --> 51:28.520
还是打算个注释

51:28.520 --> 51:30.520
就是属性

51:31.520 --> 51:32.520
必须

51:32.520 --> 51:35.520
就是数组的每一项

51:35.520 --> 51:37.520
必须满足

51:37.520 --> 51:39.520
满足类型要求

51:39.520 --> 51:40.520
这里呢

51:40.520 --> 51:41.520
就是

51:41.520 --> 51:43.520
每一个属性

51:43.520 --> 51:46.520
必须满足类型要求

51:48.520 --> 51:49.520
就这个

51:49.520 --> 51:50.520
通常情况下

51:50.520 --> 51:51.520
对象的约束

51:51.520 --> 51:52.520
我们通常

51:52.520 --> 51:54.520
使用的是另外一个东西

51:54.520 --> 51:55.520
另外一个

51:55.520 --> 51:56.520
非常非常常用的东西

51:56.520 --> 51:57.520
我们看笔

51:58.520 --> 52:00.520
我这里少写了一个

52:01.520 --> 52:02.520
这么重要的

52:02.520 --> 52:03.520
忘了写了

52:03.520 --> 52:04.520
再加上

52:04.520 --> 52:06.520
通常用的是这个玩意

52:06.520 --> 52:07.520
这个玩意

52:07.520 --> 52:09.520
这里传的是个对象

52:11.520 --> 52:12.520
这个什么意思呢

52:12.520 --> 52:13.520
它指的是

52:13.520 --> 52:14.520
对象

52:14.520 --> 52:16.520
传递的属性

52:16.520 --> 52:19.520
属性必须是对象

52:19.520 --> 52:21.520
并且满足

52:22.520 --> 52:24.520
指定的对象

52:25.520 --> 52:26.520
要求

52:27.520 --> 52:28.520
说起来挺抽象

52:28.520 --> 52:29.520
用起来这一简单

52:30.520 --> 52:31.520
看着

52:31.520 --> 52:32.520
咱们呢

52:32.520 --> 52:33.520
我们再写一个

52:33.520 --> 52:34.520
ABCDFG

52:34.520 --> 52:36.520
IGKG

52:36.520 --> 52:38.520
ProbTypes

52:38.520 --> 52:39.520
然后这里是

52:39.520 --> 52:40.520
Shape

52:40.520 --> 52:41.520
Shape

52:41.520 --> 52:42.520
Shape里面

52:42.520 --> 52:43.520
我们传的是什么呢

52:43.520 --> 52:45.520
传的是一个对象

52:45.520 --> 52:46.520
就是说

52:46.520 --> 52:47.520
你这个接

52:47.520 --> 52:48.520
它必须是一个对象

52:48.520 --> 52:49.520
这个对象

52:49.520 --> 52:51.520
它满足这个对象的格式

52:51.520 --> 52:52.520
这才是我们

52:52.520 --> 52:54.520
很多时候都要对对象的约束

52:54.520 --> 52:55.520
是想要的

52:55.520 --> 52:56.520
比方说

52:56.520 --> 52:57.520
对象里面有一个Name

52:57.520 --> 52:58.520
必须是一个什么呢

52:58.520 --> 52:59.520
字符串

52:59.520 --> 53:00.520
字符串怎么约束

53:00.520 --> 53:01.520
还是使用

53:01.520 --> 53:02.520
还是使用这个

53:02.520 --> 53:04.520
实讯来约束

53:04.520 --> 53:05.520
然后呢

53:05.520 --> 53:06.520
A级呢

53:06.520 --> 53:08.520
必须是一个ProbTypes

53:08.520 --> 53:09.520
然后呢

53:10.520 --> 53:11.520
Number

53:11.520 --> 53:12.520
当然

53:12.520 --> 53:13.520
也可以加上什么

53:13.520 --> 53:14.520
EazRequired对吧

53:14.520 --> 53:15.520
如果不加的话

53:15.520 --> 53:16.520
你可以不传递

53:16.520 --> 53:17.520
加了过后

53:17.520 --> 53:18.520
就必须要传递

53:18.520 --> 53:20.520
比方说Name必须要

53:20.520 --> 53:22.520
比方说Required

53:24.520 --> 53:25.520
大家注释

53:25.520 --> 53:28.520
这个B属相必须是

53:28.520 --> 53:30.520
必须满足

53:30.520 --> 53:32.520
该对象的要求

53:32.520 --> 53:33.520
就是至少

53:33.520 --> 53:35.520
你可以多属性没问题

53:35.520 --> 53:37.520
但是你至少得有些属性

53:37.520 --> 53:39.520
至少得有些属性

53:39.520 --> 53:40.520
然后这个呢

53:40.520 --> 53:45.520
Name必须是一个字符串

53:45.520 --> 53:46.520
然后呢

53:46.520 --> 53:47.520
B填

53:47.520 --> 53:50.090
这个呢

53:50.090 --> 53:51.090
A级呢

53:51.090 --> 53:53.090
A级是一个数字

53:53.090 --> 53:55.090
你看这样子是不是更加精确了

53:55.090 --> 53:57.090
对对象的要求更加精确了

53:57.090 --> 53:59.090
那么这里我们看一下

53:59.090 --> 54:00.090
这里使用的时候

54:00.090 --> 54:01.090
传一个借

54:01.090 --> 54:02.090
借传过去

54:02.090 --> 54:03.090
它是个对象

54:03.090 --> 54:04.090
这个对象里边呢

54:04.090 --> 54:05.090
比方说啊

54:05.090 --> 54:07.090
我们随便写个属性A等于3

54:07.090 --> 54:08.090
保存

54:08.090 --> 54:09.090
你看一下

54:09.090 --> 54:10.090
他说

54:10.090 --> 54:12.090
传A倒是没啥

54:12.090 --> 54:13.090
你传吧

54:13.090 --> 54:14.090
我也不管你多传属性

54:14.090 --> 54:16.090
我就看你传的属性里边

54:16.090 --> 54:18.090
有没有匹配到我们刚才的对象

54:18.090 --> 54:20.090
匹配到这个对象

54:20.090 --> 54:22.090
有没有匹配到这个对象

54:22.090 --> 54:23.090
你只传了一个A

54:23.090 --> 54:24.090
但是少传了一个什么

54:24.090 --> 54:25.090
少传了一个Name

54:25.090 --> 54:26.090
Name是必填的

54:26.090 --> 54:27.090
所以说

54:27.090 --> 54:28.090
它爆错了

54:28.090 --> 54:29.090
然后呢

54:29.090 --> 54:30.090
我们这里Name

54:30.090 --> 54:32.090
加上ABC

54:32.090 --> 54:33.090
保存

54:33.090 --> 54:34.090
你看没有爆错了

54:34.090 --> 54:36.090
你看是不是可以多传属性啊

54:36.090 --> 54:38.090
多传属性没问题的啊

54:38.090 --> 54:39.090
没问题的

54:39.090 --> 54:40.090
然后呢

54:40.090 --> 54:41.090
A级呢

54:41.090 --> 54:42.090
你要可以传递啊

54:42.090 --> 54:43.090
A级我们做了约束

54:43.090 --> 54:44.090
你可以传递

54:44.090 --> 54:45.090
但是你传递的时候

54:45.090 --> 54:47.090
一定要按照正确的内容来传递

54:47.090 --> 54:48.090
比方说这里

54:48.090 --> 54:49.090
这样传个数字

54:49.090 --> 54:50.090
没问题

54:50.090 --> 54:51.090
如果你传的

54:51.090 --> 54:52.090
是一个字不错的话

54:52.090 --> 54:53.090
保存

54:53.090 --> 54:54.090
你看是不是出了问题

54:54.090 --> 54:55.090
A级呢

54:55.090 --> 54:56.090
必须是一个数字

54:56.090 --> 54:58.090
看是不是对对象的约束

54:58.090 --> 54:59.090
非常非常精确了

54:59.090 --> 55:00.090
对不对

55:00.090 --> 55:02.090
我们还可以进一步约束啊

55:02.090 --> 55:03.090
这里这里

55:03.090 --> 55:04.090
我们可以文书很多花样出来

55:04.090 --> 55:05.090
比方说啊

55:05.090 --> 55:07.090
咱们还可以进一步约束

55:07.090 --> 55:08.090
比方说他还有一个

55:08.090 --> 55:09.090
Dis

55:09.090 --> 55:10.090
Dis

55:10.090 --> 55:11.090
Dis呢

55:11.090 --> 55:12.090
它又是一个对象

55:12.090 --> 55:13.090
又是一个对象

55:13.090 --> 55:14.090
这个对象里边

55:14.090 --> 55:15.090
还是要进行约束

55:15.090 --> 55:16.090
该怎么写呢

55:16.090 --> 55:18.090
你不能这样子写啊

55:18.090 --> 55:19.090
你不能这样子写的

55:19.090 --> 55:20.090
比方说啊

55:20.090 --> 55:21.090
你这样子写

55:21.090 --> 55:22.090
City

55:22.090 --> 55:23.090
City必须是一个字不错

55:23.090 --> 55:24.090
propertypes

55:24.090 --> 55:25.090
Stune

55:26.090 --> 55:27.090
Stune

55:27.090 --> 55:28.090
你不能这样子写

55:28.090 --> 55:29.090
你看一下这样子写

55:29.090 --> 55:30.090
这样子写的

55:30.090 --> 55:32.090
它说 checker is not a function

55:32.090 --> 55:34.090
因为它要检查这个属性

55:34.090 --> 55:36.090
这个属性你必须要给它一个函数

55:36.090 --> 55:37.090
你看我们这些东西都是函数

55:37.090 --> 55:38.090
对吧

55:38.090 --> 55:39.090
之前我们看到过

55:39.090 --> 55:40.090
这些东西都是函数

55:40.090 --> 55:41.090
你要给它一个函数

55:41.090 --> 55:43.090
但是你直接给它的一个对象

55:43.090 --> 55:44.090
这样子不行的

55:44.090 --> 55:45.090
你看对这个界

55:45.090 --> 55:46.090
这个属性的约束

55:46.090 --> 55:47.090
它也是个函数

55:47.090 --> 55:49.090
sharp返回的也是个函数

55:49.090 --> 55:50.090
它是个高间函数

55:50.090 --> 55:52.090
这个函数它本身返回的是一个函数

55:52.090 --> 55:54.090
所以说你这一块该怎么写呢

55:54.090 --> 55:56.090
继续使用这种方式

55:56.090 --> 55:58.090
propertypes shape

55:58.090 --> 56:00.090
继续使用这种方式

56:00.090 --> 56:01.090
来进行约束

56:01.090 --> 56:03.090
然后这里边

56:03.090 --> 56:04.090
你看

56:04.090 --> 56:05.090
它又是一个对象

56:05.090 --> 56:06.090
它又是个对象

56:06.090 --> 56:07.090
它里边有什么City

56:07.090 --> 56:09.090
propertypes

56:09.090 --> 56:10.090
propertypes

56:10.090 --> 56:11.090
是一个字不错

56:11.090 --> 56:12.090
propertypes

56:12.090 --> 56:14.090
Stune

56:14.090 --> 56:15.090
然后呢

56:15.090 --> 56:16.090
City

56:16.090 --> 56:18.090
propertypes

56:18.090 --> 56:20.090
Stune

56:20.090 --> 56:21.090
你看

56:21.090 --> 56:22.090
如果里面千套对象的话

56:22.090 --> 56:24.090
我们还可以进一步约束

56:24.090 --> 56:25.090
你看这个意思

56:25.090 --> 56:26.090
好

56:26.090 --> 56:27.090
咱们来看一下吧

56:27.090 --> 56:28.090
现在没有爆错

56:28.090 --> 56:29.090
因为你可以不传递

56:29.090 --> 56:30.090
不传递是没问题的

56:30.090 --> 56:32.090
不传递是没问题的

56:32.090 --> 56:34.090
如果你希望这个属性必须传递的话

56:34.090 --> 56:36.090
那你加上一个IsRequired

56:37.090 --> 56:39.090
你给整个加上Required

56:39.090 --> 56:41.090
如果你希望它里边的一个属性必须传递的话

56:41.090 --> 56:43.090
你给这里加上Required

56:43.090 --> 56:44.090
对吧

56:44.090 --> 56:45.090
这里非常非常灵活

56:45.090 --> 56:46.090
你可以自行处理

56:46.090 --> 56:47.090
那么现在呢

56:47.090 --> 56:49.090
比方说传递这个IsRequired

56:49.090 --> 56:50.090
你给它传一个字不错了

56:50.090 --> 56:51.090
行不行

56:51.090 --> 56:52.090
肯定不行

56:52.090 --> 56:53.090
它必须是一个对象

56:54.090 --> 56:55.090
我这边没保存

56:55.090 --> 56:56.090
保存一下

56:57.090 --> 56:58.090
没爆错

56:58.090 --> 56:59.090
我看一下

56:59.090 --> 57:00.090
这怎么回事

57:00.090 --> 57:01.090
IsRequired

57:01.090 --> 57:03.090
我这里写多了一个D

57:03.090 --> 57:04.090
多了一个D

57:04.090 --> 57:06.090
两边属性名字匹配不上

57:06.090 --> 57:07.090
你看

57:07.090 --> 57:08.090
对吧

57:09.090 --> 57:10.090
好爆错

57:10.090 --> 57:11.090
它必须是个对象

57:11.090 --> 57:12.090
对象里边

57:12.090 --> 57:14.090
它必须有两个属性

57:14.090 --> 57:15.090
但是不能少

57:15.090 --> 57:17.090
两个属性Prevents是这个

57:17.090 --> 57:18.090
Cities是这个

57:18.090 --> 57:19.090
我就不说了

57:20.090 --> 57:21.090
它必须是字不错

57:22.090 --> 57:25.090
我们可以达到更加精确的限制

57:25.090 --> 57:26.090
那么这样子一来的话

57:26.090 --> 57:27.090
像我们这一块

57:27.090 --> 57:28.090
像我们这一块

57:28.090 --> 57:30.090
之前的一些组件

57:30.090 --> 57:31.090
之前的一些组件里边

57:31.090 --> 57:32.090
不是有些属性

57:32.090 --> 57:34.090
你看一些属性乱七八糟的东西

57:34.090 --> 57:36.090
我们这样子是不是可以约束了

57:36.090 --> 57:37.090
对不对

57:37.090 --> 57:38.090
对象就已经约束了

57:39.090 --> 57:40.090
比方说这里的属性

57:40.090 --> 57:41.090
它是一个字不错

57:41.090 --> 57:42.090
它是个数组

57:42.090 --> 57:44.090
那么如何来对数组进行约束

57:44.090 --> 57:45.090
一看着

57:45.090 --> 57:47.090
我们再写一个数组

57:48.090 --> 57:50.090
fgk

57:50.090 --> 57:51.090
它必须是一个数组

57:51.090 --> 57:53.090
propertypes

57:53.090 --> 57:56.090
它必须是一个array

57:56.090 --> 57:58.090
它必须是一个数组

57:58.090 --> 57:59.090
这个数组的每一项

57:59.090 --> 58:00.090
是什么类型的

58:00.090 --> 58:01.090
你看每一项

58:01.090 --> 58:02.090
是不是可以用这个shape

58:02.090 --> 58:03.090
对吧

58:03.090 --> 58:04.090
你把它传一个shape进去

58:04.090 --> 58:05.090
对不对

58:05.090 --> 58:07.090
它每一项必须是这个东西

58:07.090 --> 58:09.090
它每一项必须是这个东西

58:09.090 --> 58:10.090
所以说这个东西

58:10.090 --> 58:12.090
里面是不是可以进一步约束了

58:12.090 --> 58:13.090
你是一个数组没问题

58:13.090 --> 58:15.090
但是里面一项必须是个对象

58:15.090 --> 58:17.090
这个对象里面必须要有names属性

58:17.090 --> 58:19.090
propertypes

58:20.090 --> 58:21.090
然后什么

58:24.090 --> 58:25.090
我记得那个

58:25.090 --> 58:28.090
插件可以一下子很轻松的打出来

58:28.090 --> 58:30.090
有年龄

58:30.090 --> 58:31.090
好像是怎么写的

58:31.090 --> 58:32.090
插件里面

58:33.090 --> 58:34.090
我下来再看一下

58:34.090 --> 58:36.090
我记得好像是可以一下子打出来

58:36.090 --> 58:37.090
第二是什么

58:37.090 --> 58:38.090
number

58:38.090 --> 58:39.090
必须要这两个属性

58:40.090 --> 58:42.090
都是一之一块的

58:43.090 --> 58:45.090
那这个整句话是什么意思呢

58:45.090 --> 58:47.090
整句话的意思就是

58:47.090 --> 58:49.090
你必须是得是一个数组

58:49.090 --> 58:51.090
而且数组的每一项得是一个对象

58:51.090 --> 58:53.090
这个对象里面还有要求

58:53.090 --> 58:54.090
有names属性

58:54.090 --> 58:55.090
a几属性

58:55.090 --> 58:56.090
而且必须是b田的

58:56.090 --> 58:57.090
好 这样子一来

58:57.090 --> 58:58.090
你看一下

58:58.090 --> 59:00.090
我们现在对这个k这个属性

59:00.090 --> 59:01.090
对这个k这个属性

59:01.090 --> 59:02.090
现在没爆错

59:02.090 --> 59:03.090
因为它可以不传

59:03.090 --> 59:04.090
对k这个属性本身是可以不传的

59:04.090 --> 59:06.090
如果你要传递的话

59:06.090 --> 59:07.090
那么就必须是一个数组

59:07.090 --> 59:09.090
数组里面的每一项就必须是个对象

59:09.090 --> 59:10.090
对象里面有什么

59:10.090 --> 59:11.090
有value值

59:11.090 --> 59:13.090
有names

59:13.090 --> 59:15.090
有a几

59:16.090 --> 59:18.090
你必须要这样传递

59:19.090 --> 59:20.090
你看这样的没问题

59:20.090 --> 59:21.090
那如果你这里传递错了

59:21.090 --> 59:23.090
不要传的一个支付错进来

59:23.090 --> 59:24.090
那就要出问题了

59:24.090 --> 59:25.090
后面

59:25.090 --> 59:26.090
就要出问题了

59:27.090 --> 59:28.090
就是

59:28.090 --> 59:29.090
这是这么一回事

59:31.090 --> 59:33.090
是不是非常凝阔这个玩意

59:33.090 --> 59:35.090
下面这个就不再说了

59:35.090 --> 59:37.090
下面这个rex

59:37.090 --> 59:40.090
它跟sharp是完全一样的

59:40.090 --> 59:42.090
是完全一样的用法

59:42.090 --> 59:43.090
用法完全一样

59:43.090 --> 59:44.090
只不过

59:44.090 --> 59:46.090
它跟sharp的区别在于什么呢

59:46.090 --> 59:48.090
一个rex它是精确匹配

59:48.090 --> 59:50.090
就是说你不能多属性

59:50.090 --> 59:52.090
你属性不能多

59:52.090 --> 59:54.090
你必须要完全精确匹配

59:54.090 --> 59:55.090
你比较传递的数据

59:55.090 --> 59:56.090
你不能多属性

59:57.090 --> 59:58.090
不要对是吧

59:58.090 --> 01:00:00.090
所以说这个rex

01:00:01.090 --> 01:00:03.090
不能有额外的属性

01:00:03.090 --> 01:00:04.090
sharp是可以有额外的属性的

01:00:04.090 --> 01:00:05.090
你可以多

01:00:05.090 --> 01:00:07.090
但是你

01:00:07.090 --> 01:00:08.090
只要有的属性

01:00:08.090 --> 01:00:09.090
是必须要满足要求的就行了

01:00:09.090 --> 01:00:10.090
但是一个rex

01:00:10.090 --> 01:00:11.090
你是不能多的

01:00:12.090 --> 01:00:14.090
这是这么一些东西

01:00:14.090 --> 01:00:15.090
最后一个

01:00:15.090 --> 01:00:17.090
最后一个就是自定义属性了

01:00:17.090 --> 01:00:18.090
自定义属性

01:00:18.090 --> 01:00:19.090
现在就是如果上面的东西

01:00:19.090 --> 01:00:21.090
都还不能满足你的要求

01:00:21.090 --> 01:00:23.090
都还无法满足

01:00:23.090 --> 01:00:25.090
还无法满足的话

01:00:25.090 --> 01:00:26.090
那么

01:00:28.090 --> 01:00:30.090
这里还有一个

01:00:30.090 --> 01:00:32.090
还有一个

01:00:32.090 --> 01:00:35.090
我这里还再说一个吧

01:00:35.090 --> 01:00:38.090
还有一个one of type

01:00:38.090 --> 01:00:39.090
还有一个

01:00:39.090 --> 01:00:43.360
我看一下我写的也没有

01:00:43.360 --> 01:00:45.360
应该是没问题的

01:00:46.360 --> 01:00:49.360
jklm

01:00:49.360 --> 01:00:51.360
probe types

01:00:51.360 --> 01:00:52.360
one of type

01:00:52.360 --> 01:00:53.360
对了

01:00:53.360 --> 01:00:54.360
还有一个

01:00:54.360 --> 01:00:55.360
就是说这里

01:00:57.360 --> 01:00:58.360
这边

01:00:58.360 --> 01:00:59.360
这里边传的是啥呢

01:00:59.360 --> 01:01:01.360
它就是说

01:01:01.360 --> 01:01:02.360
属性

01:01:02.360 --> 01:01:04.360
就是属性内型

01:01:04.360 --> 01:01:06.360
必须是

01:01:06.360 --> 01:01:08.360
数组中的

01:01:08.360 --> 01:01:09.360
其中一个

01:01:09.360 --> 01:01:10.360
属性内型必须是

01:01:10.360 --> 01:01:11.360
这些内型中的一个

01:01:11.360 --> 01:01:13.360
刚才的属性的值

01:01:13.360 --> 01:01:15.360
必须是这些东西的一个

01:01:15.360 --> 01:01:17.360
但是属性内型的必须是

01:01:17.360 --> 01:01:19.360
这些当中的一个

01:01:19.360 --> 01:01:20.360
也就是说这里

01:01:20.360 --> 01:01:21.360
我们可以这样传

01:01:21.360 --> 01:01:23.360
比方说你可以是一个

01:01:23.360 --> 01:01:24.360
probe types

01:01:24.360 --> 01:01:25.360
你可以是个资讯

01:01:25.360 --> 01:01:27.360
也可以是一个number

01:01:27.360 --> 01:01:28.360
也可以是个number

01:01:28.360 --> 01:01:30.360
这样子是可以的

01:01:30.360 --> 01:01:31.360
就是你这个属性的

01:01:31.360 --> 01:01:32.360
要么是支付串

01:01:32.360 --> 01:01:33.360
要么是number

01:01:33.360 --> 01:01:34.360
对吧

01:01:34.360 --> 01:01:35.360
我们可以把这些内型检查并列

01:01:35.360 --> 01:01:37.360
并列去其中一个

01:01:37.360 --> 01:01:38.360
这么个意思

01:01:38.360 --> 01:01:39.360
那咱们看一下

01:01:39.360 --> 01:01:40.360
m

01:01:40.360 --> 01:01:42.360
m可以传支付串

01:01:42.360 --> 01:01:43.360
保存

01:01:43.360 --> 01:01:44.360
你看没有爆错

01:01:44.360 --> 01:01:45.360
没问题

01:01:45.360 --> 01:01:47.360
然后可以传数字

01:01:47.360 --> 01:01:48.360
可以传数字

01:01:48.360 --> 01:01:49.360
保存

01:01:49.360 --> 01:01:50.360
你看没问题

01:01:50.360 --> 01:01:52.360
也可以传什么呢

01:01:52.360 --> 01:01:53.360
不是也可以传

01:01:53.360 --> 01:01:54.360
再传一个布尔了

01:01:54.360 --> 01:01:56.360
你看是不是爆错了

01:01:56.360 --> 01:01:57.360
对不对

01:01:57.360 --> 01:01:59.360
就这么个意思

01:01:59.360 --> 01:02:00.360
他可以两个中

01:02:00.360 --> 01:02:02.360
两个内型任何一个都可以

01:02:02.360 --> 01:02:03.360
好

01:02:03.360 --> 01:02:05.360
最后一个就是自定义属性检查了

01:02:05.360 --> 01:02:07.360
他说如果有错误的话

01:02:07.360 --> 01:02:08.360
那么返回错误对象就可以了

01:02:08.360 --> 01:02:09.360
如果没有错误的话

01:02:09.360 --> 01:02:11.360
啥都不用返回

01:02:11.360 --> 01:02:12.360
那么个自定义属性就是

01:02:12.360 --> 01:02:14.360
前面都还不满足你的要求

01:02:14.360 --> 01:02:15.360
都还不满足

01:02:15.360 --> 01:02:16.360
那么你可以自己写个

01:02:16.360 --> 01:02:18.360
函数来检查属性

01:02:18.360 --> 01:02:19.360
好比方说吧

01:02:19.360 --> 01:02:20.360
举个例子

01:02:21.360 --> 01:02:22.360
m

01:02:22.360 --> 01:02:24.360
哇好多了

01:02:24.360 --> 01:02:25.360
直接写个函数

01:02:25.360 --> 01:02:26.360
直接写函数

01:02:26.360 --> 01:02:28.360
这个函数有哪些参数呢

01:02:28.360 --> 01:02:29.360
我们看一下

01:02:29.360 --> 01:02:30.360
他有这么三个参数

01:02:30.360 --> 01:02:31.360
我们可以使用

01:02:31.360 --> 01:02:33.360
有这么三个参数

01:02:33.360 --> 01:02:34.360
第一个参数呢

01:02:34.360 --> 01:02:36.360
就是传过来的属性

01:02:36.360 --> 01:02:38.360
所有的属性他都给你

01:02:38.360 --> 01:02:40.360
把所有的属性全部给你

01:02:40.360 --> 01:02:41.360
答应一下吧

01:02:41.360 --> 01:02:42.360
probs

01:02:42.360 --> 01:02:44.360
prob net

01:02:44.360 --> 01:02:46.360
然后component net

01:02:46.360 --> 01:02:48.360
这些属性什么意思呢

01:02:48.360 --> 01:02:49.360
这个是所有的属性对象

01:02:49.360 --> 01:02:50.360
就是个属性对象

01:02:50.360 --> 01:02:51.360
就相当于是这个

01:02:51.360 --> 01:02:53.360
相当于是this props

01:02:53.360 --> 01:02:55.360
相当于是this props

01:02:55.360 --> 01:02:57.360
为什么这里不直接用this props

01:02:58.360 --> 01:02:59.360
静态的

01:02:59.360 --> 01:03:00.360
里面用不了

01:03:00.360 --> 01:03:01.360
用不了

01:03:01.360 --> 01:03:03.360
而且呢这里用this的话

01:03:03.360 --> 01:03:04.360
只想的是这个对象

01:03:04.360 --> 01:03:05.360
对吧只想到这个对象本身

01:03:05.360 --> 01:03:07.360
所以说不能用this

01:03:07.360 --> 01:03:08.360
这里呢我们

01:03:08.360 --> 01:03:10.360
这个是给你

01:03:10.360 --> 01:03:11.360
把所有的属性传给你

01:03:11.360 --> 01:03:13.360
然后呢这里是属性的名字

01:03:13.360 --> 01:03:15.360
就是当前验证那个属性的名字

01:03:15.360 --> 01:03:17.360
你不直接用NG完稍了吗

01:03:17.360 --> 01:03:18.360
但是不一定啊

01:03:18.360 --> 01:03:20.360
因为他有可能会重用的这个函数

01:03:20.360 --> 01:03:22.360
可能会用在多个属性里边

01:03:22.360 --> 01:03:24.360
所以说你他把属性名字传给你

01:03:24.360 --> 01:03:25.360
验证的是哪个属性

01:03:25.360 --> 01:03:27.360
验证的是哪一个

01:03:27.360 --> 01:03:29.360
验证的是哪一个就是

01:03:29.360 --> 01:03:30.360
组件的名称

01:03:30.360 --> 01:03:32.360
把这些都传给你

01:03:32.360 --> 01:03:34.360
我们打印出来看一下吧

01:03:34.360 --> 01:03:35.360
这里能比方说啊

01:03:35.360 --> 01:03:37.360
我给这个N传一个值

01:03:37.360 --> 01:03:38.360
传一个什么值呢

01:03:38.360 --> 01:03:39.360
传一个字不错吧

01:03:39.360 --> 01:03:41.360
N的值

01:03:42.360 --> 01:03:43.360
保存

01:03:43.360 --> 01:03:46.860
你看一下打印什么

01:03:46.860 --> 01:03:47.860
打印了第一个是吧

01:03:47.860 --> 01:03:49.860
是把所有的属性全部给你的

01:03:49.860 --> 01:03:50.860
你看

01:03:50.860 --> 01:03:51.860
所有的属性

01:03:51.860 --> 01:03:52.860
是不是全部给你的

01:03:52.860 --> 01:03:53.860
所有的属性值

01:03:53.860 --> 01:03:55.860
第二个呢我们属性的名字是N

01:03:55.860 --> 01:03:56.860
第三个呢

01:03:56.860 --> 01:03:58.860
我们的组件的名字是ValidationComp

01:03:58.860 --> 01:03:59.860
把这东西全部给你

01:03:59.860 --> 01:04:01.860
那么你自己去验证

01:04:01.860 --> 01:04:03.860
自己去验证

01:04:03.860 --> 01:04:04.860
那么比方说吧

01:04:04.860 --> 01:04:06.860
我们呢

01:04:06.860 --> 01:04:07.860
要验证这个N的值

01:04:07.860 --> 01:04:09.860
N必须是一个数字

01:04:09.860 --> 01:04:11.860
比方说举个例子啊

01:04:11.860 --> 01:04:13.860
必须是该属性

01:04:13.860 --> 01:04:16.860
该属性必须是一个数字

01:04:16.860 --> 01:04:18.860
必须是一个数字

01:04:18.860 --> 01:04:21.860
第一个必须必填

01:04:21.860 --> 01:04:23.860
该属性必须是一个数字

01:04:23.860 --> 01:04:25.860
并且

01:04:25.860 --> 01:04:27.860
取值范围

01:04:27.860 --> 01:04:29.860
范围是0到100

01:04:29.860 --> 01:04:31.860
那么这里我们写Score嘛

01:04:31.860 --> 01:04:33.860
Score分数这样子呢

01:04:33.860 --> 01:04:35.860
有点异议

01:04:36.860 --> 01:04:38.860
然后呢这里我们看

01:04:38.860 --> 01:04:40.860
首先验证必填

01:04:40.860 --> 01:04:41.860
看一下啊

01:04:41.860 --> 01:04:42.860
如果Props

01:04:42.860 --> 01:04:44.860
怎么来取这个属性值

01:04:44.860 --> 01:04:46.860
通过属性的名称

01:04:46.860 --> 01:04:47.860
是不是放进来

01:04:47.860 --> 01:04:48.860
对吧用表达设

01:04:48.860 --> 01:04:50.860
来从这个对象里面取出属性值

01:04:50.860 --> 01:04:52.860
对吧我们可以先把取出来吧

01:04:52.860 --> 01:04:54.860
先把取出来

01:04:54.860 --> 01:04:56.860
这是我们要验证的属性值

01:04:56.860 --> 01:04:58.860
然后呢必填

01:04:58.860 --> 01:05:00.860
那么我们看一下这个Var有没有值

01:05:00.860 --> 01:05:02.860
如果Var

01:05:02.860 --> 01:05:04.860
等于了什么Undefend

01:05:04.860 --> 01:05:06.860
或者说Var

01:05:06.860 --> 01:05:08.860
等于了什么NOW

01:05:08.860 --> 01:05:10.860
像这种两种情况是不是没有填写

01:05:10.860 --> 01:05:11.860
对吧没有填写

01:05:11.860 --> 01:05:13.860
你不能直接用Var来判断啊

01:05:13.860 --> 01:05:14.860
不能直接用Var来判断

01:05:14.860 --> 01:05:15.860
因为它有可能是数字

01:05:15.860 --> 01:05:16.860
数字是0的情况下

01:05:16.860 --> 01:05:18.860
也为Force

01:05:18.860 --> 01:05:19.860
这样的判断

01:05:19.860 --> 01:05:21.860
如果是这两种情况的话

01:05:21.860 --> 01:05:23.860
反而就没有通过

01:05:23.860 --> 01:05:25.860
新建的错误对象

01:05:25.860 --> 01:05:27.860
反而一个错误对象就行了

01:05:27.860 --> 01:05:29.860
它帮你进行拨出错误

01:05:29.860 --> 01:05:30.860
这个错误消息呢

01:05:30.860 --> 01:05:32.860
我们自己拼接一下嘛

01:05:32.860 --> 01:05:34.860
就是Invited

01:05:34.860 --> 01:05:37.860
无效的Prop

01:05:37.860 --> 01:05:39.860
什么属性呢

01:05:39.860 --> 01:05:40.860
哪个属性

01:05:40.860 --> 01:05:41.860
Proplay

01:05:41.860 --> 01:05:42.860
无效的属性

01:05:42.860 --> 01:05:43.860
In

01:05:43.860 --> 01:05:44.860
在哪个组件里面呢

01:05:44.860 --> 01:05:46.860
在Component层面

01:05:46.860 --> 01:05:47.860
在这个组件里面

01:05:47.860 --> 01:05:49.860
有个无效的属性

01:05:49.860 --> 01:05:50.860
然后呢

01:05:50.860 --> 01:05:52.860
我们这里再加上一句话嘛

01:05:52.860 --> 01:05:54.860
就是说

01:05:54.860 --> 01:05:55.860
这个Proplay

01:05:55.860 --> 01:05:56.860
这个属性

01:05:56.860 --> 01:05:57.860
Proplay

01:05:57.860 --> 01:05:58.860
意思

01:05:58.860 --> 01:06:02.300
required

01:06:02.300 --> 01:06:03.300
保存

01:06:03.300 --> 01:06:04.300
咱们

01:06:04.300 --> 01:06:05.300
如果不传递

01:06:05.300 --> 01:06:07.300
如果这一块不传递

01:06:07.300 --> 01:06:08.300
看一下

01:06:08.300 --> 01:06:09.300
你看一下

01:06:09.300 --> 01:06:10.300
是不是我们

01:06:10.300 --> 01:06:11.300
显示了我们自己的错误信息

01:06:11.300 --> 01:06:13.300
Score is required

01:06:14.300 --> 01:06:16.300
然后再来啊

01:06:16.300 --> 01:06:17.300
加上啊

01:06:17.300 --> 01:06:18.300
加上过后呢

01:06:18.300 --> 01:06:19.300
我们继续验证

01:06:19.300 --> 01:06:21.300
还必须是一个数字

01:06:21.300 --> 01:06:23.300
还必须是一个数字

01:06:23.300 --> 01:06:24.300
咱们呢

01:06:24.300 --> 01:06:25.300
又来看看

01:06:25.300 --> 01:06:26.300
Type 1

01:06:26.300 --> 01:06:29.300
是不是等于Number

01:06:29.300 --> 01:06:31.300
如果不等于Number的话

01:06:31.300 --> 01:06:32.300
那么它就不是数字

01:06:32.300 --> 01:06:33.300
对吧

01:06:33.300 --> 01:06:34.300
不是数字

01:06:34.300 --> 01:06:37.300
我们又返回一个错误

01:06:37.300 --> 01:06:38.300
然后呢

01:06:38.300 --> 01:06:42.300
is not a number

01:06:42.300 --> 01:06:44.300
它不是一个数字

01:06:44.300 --> 01:06:45.300
保存

01:06:45.300 --> 01:06:46.300
你看一下

01:06:46.300 --> 01:06:47.300
现在就报了这个错误了

01:06:47.300 --> 01:06:48.300
Score is not a number

01:06:48.300 --> 01:06:49.300
继续啊

01:06:49.300 --> 01:06:51.300
如果它是数字的话

01:06:51.300 --> 01:06:53.300
那么我们还判断取之范围

01:06:53.300 --> 01:06:54.300
如果 var 呢

01:06:54.300 --> 01:06:55.300
小于0

01:06:55.300 --> 01:06:57.300
或者说 var 呢

01:06:57.300 --> 01:06:58.300
大于100

01:06:58.300 --> 01:06:59.300
这个是不是也要报错

01:06:59.300 --> 01:07:00.300
对不对

01:07:00.300 --> 01:07:01.300
也要报错

01:07:01.300 --> 01:07:02.300
好

01:07:02.300 --> 01:07:03.300
好

01:07:03.300 --> 01:07:04.300
这里错误消息呢

01:07:04.300 --> 01:07:05.300
就是

01:07:05.300 --> 01:07:06.300
这个属性呢

01:07:06.300 --> 01:07:09.300
Must

01:07:09.300 --> 01:07:13.300
is between

01:07:13.300 --> 01:07:17.300
zero and 100

01:07:18.300 --> 01:07:19.300
好

01:07:19.300 --> 01:07:20.300
我们来看一下吧

01:07:20.300 --> 01:07:22.300
如果我给它传一个数字

01:07:22.300 --> 01:07:24.300
传的是33

01:07:24.300 --> 01:07:25.300
333

01:07:25.300 --> 01:07:26.300
你看是不是报错

01:07:26.300 --> 01:07:28.300
它必须是0到100

01:07:28.300 --> 01:07:31.300
如果给它传一个正确的

01:07:31.300 --> 01:07:32.300
你看是不是报错了

01:07:32.300 --> 01:07:33.300
对吧

01:07:33.300 --> 01:07:34.300
就可以通过我们自定义的属性

01:07:34.300 --> 01:07:37.320
来进行验证

01:07:37.320 --> 01:07:38.320
好

01:07:38.320 --> 01:07:39.320
写到这

01:07:39.320 --> 01:07:40.320
好了

01:07:40.320 --> 01:07:41.320
开始想了

01:07:41.320 --> 01:07:42.320
哇

01:07:42.320 --> 01:07:43.320
老师你这个东西

01:07:43.320 --> 01:07:44.320
没啥问题

01:07:44.320 --> 01:07:45.320
挺简单的

01:07:45.320 --> 01:07:46.320
这个玩意

01:07:46.320 --> 01:07:48.320
跟以前我们的表单验证是一样的

01:07:48.320 --> 01:07:50.320
跟表单验证一样吧

01:07:50.320 --> 01:07:52.320
这个是不是表单验证

01:07:52.320 --> 01:07:54.320
跟表单验证完全没关系

01:07:54.320 --> 01:07:56.320
这个东西验证的是啥

01:07:56.320 --> 01:07:59.320
是针对开发者在用这个组件的时候

01:07:59.320 --> 01:08:01.320
给我传了一些错误的东西进来

01:08:01.320 --> 01:08:03.320
导致到这个组件运行了

01:08:03.320 --> 01:08:06.320
可能会出现一些隐患

01:08:06.320 --> 01:08:08.320
为了让这个组件更加通用

01:08:08.320 --> 01:08:09.320
为了避免开发者出错

01:08:09.320 --> 01:08:11.320
所以说我们对开发者呢

01:08:11.320 --> 01:08:13.320
传的东西进行验证

01:08:13.320 --> 01:08:15.320
而表单验证的是对用户

01:08:15.320 --> 01:08:17.320
就是使用这个程序的人进行验证

01:08:17.320 --> 01:08:19.320
两码事

01:08:19.320 --> 01:08:22.320
这些东西都是针对开发者的验证

01:08:22.320 --> 01:08:24.320
那就没啥了

01:08:24.320 --> 01:08:25.320
另外我说一点

01:08:25.320 --> 01:08:26.320
就是说

01:08:26.320 --> 01:08:28.320
这个东西这些验证规则

01:08:28.320 --> 01:08:31.320
它为什么要把这个库分离出去

01:08:31.320 --> 01:08:33.320
因为这些验证规则它是可以通用的

01:08:33.320 --> 01:08:35.320
它不是说我只能把它写到

01:08:35.320 --> 01:08:37.320
把这一规则全部写到属性里边

01:08:37.320 --> 01:08:39.320
那如果有很多组件

01:08:39.320 --> 01:08:41.320
比方说我们之前可以看到

01:08:41.320 --> 01:08:43.320
我们之前做这个组件的时候

01:08:43.320 --> 01:08:45.320
你可以看到咱们这里

01:08:46.320 --> 01:08:48.320
很多组件都要传这个数据

01:08:48.320 --> 01:08:51.320
那么我们可以把验证规则抽象出来

01:08:51.320 --> 01:08:53.320
把验证规则抽象出来

01:08:53.320 --> 01:08:54.320
抽象出来过后

01:08:54.320 --> 01:08:56.320
每一个组件里边去使用

01:08:56.320 --> 01:08:58.320
不一定说把这些验证规则全部

01:08:58.320 --> 01:09:00.320
每个组件全部重新语写一遍

01:09:00.320 --> 01:09:01.320
只要发现有些重复的

01:09:01.320 --> 01:09:03.320
比方说性别这里

01:09:03.320 --> 01:09:05.320
性别这里的验证规则

01:09:05.320 --> 01:09:06.320
是不是可以把抽象出来

01:09:06.320 --> 01:09:07.320
抽象出来过后

01:09:07.320 --> 01:09:10.320
我们就可以形成一个公共的模块

01:09:10.320 --> 01:09:11.320
到时候我们要验证的时候

01:09:11.320 --> 01:09:13.320
直接从那个模块倒入进来就完事了

01:09:14.320 --> 01:09:17.320
这就是验证这一块的全部知识了

01:09:17.320 --> 01:09:18.320
东西有点多

01:09:18.320 --> 01:09:21.320
但是没有什么复杂的都很简单

01:09:21.320 --> 01:09:24.320
之前我在上课的时候

01:09:24.320 --> 01:09:25.320
遇到一个同学

01:09:25.320 --> 01:09:26.320
他非常非常厉害

01:09:26.320 --> 01:09:27.320
非常非常聪明

01:09:27.320 --> 01:09:29.320
他就来说这个问题

01:09:30.320 --> 01:09:32.320
咱们在制定验证里边

01:09:33.320 --> 01:09:34.320
因为我们之前说过

01:09:34.320 --> 01:09:36.320
像这些东西都是函数

01:09:36.320 --> 01:09:37.320
都是函数

01:09:38.320 --> 01:09:40.320
那么我们在制定验证里边

01:09:40.320 --> 01:09:42.320
可不可以就利用这些函数

01:09:42.320 --> 01:09:45.320
调用这些函数来帮我们进行验证的

01:09:46.320 --> 01:09:48.320
按道理来说是可以的

01:09:48.320 --> 01:09:50.320
就是说像这里比方说

01:09:50.320 --> 01:09:53.320
它必填又必须要是一个数字

01:09:53.320 --> 01:09:55.320
像这种规则是不是已经有了

01:09:55.320 --> 01:09:57.320
number is required

01:09:57.320 --> 01:09:58.320
它已经有了

01:09:58.320 --> 01:09:59.320
那么实际上这里

01:09:59.320 --> 01:10:01.320
我们可不可以这样子来做呢

01:10:01.320 --> 01:10:04.320
我们这里就调用这个函数

01:10:04.320 --> 01:10:05.320
因为它无非就是个函数

01:10:05.320 --> 01:10:07.320
它帮我们来进行验证

01:10:07.320 --> 01:10:08.320
就完事了

01:10:08.320 --> 01:10:10.320
所以我们这里能不能这样子

01:10:11.320 --> 01:10:12.320
调用函数

01:10:12.320 --> 01:10:13.320
proptaps

01:10:13.320 --> 01:10:16.320
然后number is required

01:10:17.320 --> 01:10:18.320
这里

01:10:18.320 --> 01:10:19.320
把这个东西传进去

01:10:19.320 --> 01:10:21.320
我们验证的属性传进去

01:10:21.320 --> 01:10:23.320
属性的名字传进去

01:10:23.320 --> 01:10:24.320
name

01:10:24.320 --> 01:10:25.320
还有什么component name

01:10:25.320 --> 01:10:27.320
把这些东西都传进去

01:10:27.320 --> 01:10:28.320
那么这样子呢

01:10:28.320 --> 01:10:30.320
让它返回一个

01:10:30.320 --> 01:10:31.320
跟我们一样的对吧

01:10:31.320 --> 01:10:32.320
要么返回错误

01:10:32.320 --> 01:10:33.320
要么返回 onDefend

01:10:33.320 --> 01:10:34.320
如果有错误的话

01:10:34.320 --> 01:10:36.320
我们直接把它的错误返回

01:10:36.320 --> 01:10:38.320
就利用它的这种方式

01:10:38.320 --> 01:10:39.320
它的这些东西来进行验证

01:10:39.320 --> 01:10:40.320
可不可以呢

01:10:41.320 --> 01:10:42.320
保证

01:10:43.320 --> 01:10:44.320
它不行

01:10:44.320 --> 01:10:45.320
它为什么不行呢

01:10:46.320 --> 01:10:47.320
这是rex里面

01:10:47.320 --> 01:10:49.320
它给你规定的

01:10:49.320 --> 01:10:50.320
它不让你去直接调用

01:10:50.320 --> 01:10:52.320
它说callingproptaps

01:10:52.320 --> 01:10:53.320
validators

01:10:53.320 --> 01:10:54.320
你直接调用

01:10:54.320 --> 01:10:55.320
什么

01:10:55.320 --> 01:10:57.320
这个对象里面的

01:10:57.320 --> 01:10:59.320
这些验证器直接调用

01:10:59.320 --> 01:11:00.320
is not supported

01:11:01.320 --> 01:11:02.320
它说

01:11:02.320 --> 01:11:04.320
在这个cool里面是不支持的

01:11:04.320 --> 01:11:06.320
是不支持你直接调用的

01:11:07.320 --> 01:11:08.320
然后它给你说

01:11:08.320 --> 01:11:09.320
换了一种说法

01:11:09.320 --> 01:11:11.320
就是说你让你去用这种方式

01:11:11.320 --> 01:11:12.320
来调用它们

01:11:12.320 --> 01:11:13.320
在这种方式呢

01:11:13.320 --> 01:11:14.320
我就不扯了

01:11:14.320 --> 01:11:16.320
这种方式触发验证

01:11:16.320 --> 01:11:18.320
这种方式肯定不是我们想要的

01:11:18.320 --> 01:11:19.320
你也做不到

01:11:19.320 --> 01:11:20.320
你也做不到

01:11:20.320 --> 01:11:21.320
这种方式呢

01:11:21.320 --> 01:11:22.320
我之前用了一下

01:11:22.320 --> 01:11:23.320
发现它也做不到

01:11:24.320 --> 01:11:25.320
它可以触发验证

01:11:25.320 --> 01:11:26.320
但是呢

01:11:26.320 --> 01:11:27.320
你不知道

01:11:28.320 --> 01:11:29.320
我就说一下这个方法

01:11:29.320 --> 01:11:30.320
画到嘴边了

01:11:30.320 --> 01:11:32.320
我给你解释清楚了

01:11:32.320 --> 01:11:34.320
你也不知道为什么

01:11:34.320 --> 01:11:35.320
它告诉你呢

01:11:35.320 --> 01:11:37.320
要用这种方式来触发

01:11:37.320 --> 01:11:38.320
就是用这个

01:11:38.320 --> 01:11:40.320
这个函数来触发验证

01:11:40.320 --> 01:11:42.320
它这个函数是在触发验证的

01:11:42.320 --> 01:11:43.320
它里面这些参数

01:11:43.320 --> 01:11:44.320
还要传什么呢

01:11:44.320 --> 01:11:45.320
第一个参数要传这个

01:11:45.320 --> 01:11:46.320
第一个参数

01:11:46.320 --> 01:11:48.320
它要传整个配置对象

01:11:48.320 --> 01:11:50.320
那能传吗

01:11:50.320 --> 01:11:51.320
不能传

01:11:51.320 --> 01:11:53.320
那不是帝规了吗

01:11:53.320 --> 01:11:54.320
整个配置对象传进来

01:11:54.320 --> 01:11:56.320
你这个东西是一个

01:11:56.320 --> 01:11:59.320
就是制定义的函数

01:11:59.320 --> 01:12:00.320
那么它到时候验证

01:12:00.320 --> 01:12:01.320
这个属性的时候

01:12:01.320 --> 01:12:02.320
它要运行这个函数

01:12:02.320 --> 01:12:03.320
运行这个函数的时候

01:12:03.320 --> 01:12:04.320
它又要触发这个

01:12:04.320 --> 01:12:06.320
它又要把重新把这个东西传进去

01:12:06.320 --> 01:12:08.320
那么我们有时候可以想到

01:12:08.320 --> 01:12:09.320
这里的第一个参数

01:12:09.320 --> 01:12:11.320
我们可以这样重新勾件一个配置

01:12:11.320 --> 01:12:13.320
重新勾件一个配置

01:12:13.320 --> 01:12:14.320
Score

01:12:14.320 --> 01:12:15.320
PropTabs

01:12:15.320 --> 01:12:17.320
就是这一块

01:12:17.320 --> 01:12:18.320
你听得懂就听不懂就算了

01:12:18.320 --> 01:12:19.320
反正我们会不用的

01:12:19.320 --> 01:12:21.320
然后这里是

01:12:21.320 --> 01:12:22.320
重新勾件一个规则

01:12:22.320 --> 01:12:24.320
单独勾件一个规则

01:12:24.320 --> 01:12:25.320
Score

01:12:25.320 --> 01:12:26.320
PropTabs就是Number

01:12:26.320 --> 01:12:28.320
IsRequired

01:12:28.320 --> 01:12:30.320
然后第二个参数传

01:12:30.320 --> 01:12:31.320
第二个参数传的是

01:12:31.320 --> 01:12:33.320
所有的属性值

01:12:33.320 --> 01:12:35.320
我们可以把所有的属性传进去

01:12:35.320 --> 01:12:36.320
所有的属性传进去

01:12:36.320 --> 01:12:38.320
就是我们来自于我们的参数

01:12:38.320 --> 01:12:40.320
所有的属性传进去

01:12:40.320 --> 01:12:42.320
然后第三个参数传

01:12:42.320 --> 01:12:44.320
三个传属你直接传个支付刷Prop

01:12:44.320 --> 01:12:45.320
这什么意思呢

01:12:45.320 --> 01:12:46.320
表示的是

01:12:46.320 --> 01:12:48.320
它这里说的是什么

01:12:48.320 --> 01:12:49.320
location

01:12:49.320 --> 01:12:50.320
location什么意思呢

01:12:50.320 --> 01:12:51.320
因为它这个库

01:12:51.320 --> 01:12:53.320
它不仅仅是可以验证属性

01:12:53.320 --> 01:12:55.320
将来我们学习了context

01:12:55.320 --> 01:12:57.320
还有什么child context

01:12:57.320 --> 01:12:59.320
就是学习了上下文之后

01:12:59.320 --> 01:13:01.320
它还可以验证上下文

01:13:01.320 --> 01:13:02.320
所以说这里呢

01:13:02.320 --> 01:13:03.320
告诉它验证的是啥

01:13:03.320 --> 01:13:04.320
验证的是属性

01:13:04.320 --> 01:13:05.320
好吧

01:13:05.320 --> 01:13:06.320
我们这里呢

01:13:06.320 --> 01:13:07.320
给它传递过去

01:13:07.320 --> 01:13:08.320
让它进行验证

01:13:08.320 --> 01:13:09.320
但实际上这个方法呢

01:13:09.320 --> 01:13:11.320
它返回的

01:13:11.320 --> 01:13:12.320
就是undefined

01:13:12.320 --> 01:13:14.320
它不会给你返回任何东西

01:13:14.320 --> 01:13:15.320
它如果验证出了问题

01:13:15.320 --> 01:13:17.320
它就直接给你报警告了

01:13:17.320 --> 01:13:18.320
它这里就直接给你报警告了

01:13:18.320 --> 01:13:19.320
保存看一下吧

01:13:19.320 --> 01:13:21.320
保存

01:13:21.320 --> 01:13:22.320
你看一下

01:13:22.320 --> 01:13:23.320
嗯嗯

01:13:23.320 --> 01:13:24.320
这个呢

01:13:24.320 --> 01:13:26.320
TabsDreamSupplied

01:13:26.320 --> 01:13:28.320
BaggedNumber

01:13:28.320 --> 01:13:30.320
它就说Score

01:13:30.320 --> 01:13:31.320
它出了问题

01:13:31.320 --> 01:13:32.320
Score出了问题

01:13:32.320 --> 01:13:33.320
我这里没有

01:13:33.320 --> 01:13:34.320
没有传那个组建

01:13:34.320 --> 01:13:36.320
我没有传组建名称

01:13:36.320 --> 01:13:38.320
还应该传一个组建名称后边

01:13:38.320 --> 01:13:40.320
component

01:13:40.320 --> 01:13:41.320
保存你看

01:13:41.320 --> 01:13:42.320
它验证出了问题

01:13:42.320 --> 01:13:43.320
看到没

01:13:43.320 --> 01:13:44.320
验证出了问题

01:13:44.320 --> 01:13:45.320
这是它给你触发的

01:13:45.320 --> 01:13:47.320
但是由于呢

01:13:47.320 --> 01:13:48.320
由于呢

01:13:48.320 --> 01:13:49.320
它这个东西

01:13:49.320 --> 01:13:51.320
它没有返回结果

01:13:51.320 --> 01:13:52.320
它没有返回结果

01:13:52.320 --> 01:13:53.320
我就不知道

01:13:53.320 --> 01:13:54.320
它发生了什么事

01:13:54.320 --> 01:13:55.320
我就不知道

01:13:55.320 --> 01:13:56.320
它发生了什么事

01:13:56.320 --> 01:13:57.320
所以说

01:13:57.320 --> 01:13:59.320
那如果你要配合

01:13:59.320 --> 01:14:01.320
配合自己的其他验证的话

01:14:01.320 --> 01:14:03.320
你看下面代码仍然会输出

01:14:03.320 --> 01:14:05.320
下面代码123

01:14:05.320 --> 01:14:06.320
你看一下

01:14:06.320 --> 01:14:08.320
你看123是不是仍然会输出

01:14:08.320 --> 01:14:09.320
它不会阻止代码运行

01:14:09.320 --> 01:14:11.320
这个东西也不是很好用

01:14:11.320 --> 01:14:12.320
也不是很好用

01:14:12.320 --> 01:14:14.320
是这么个意思

01:14:14.320 --> 01:14:16.320
它会直接给你输出

01:14:16.320 --> 01:14:17.320
它倒是报了

01:14:17.320 --> 01:14:18.320
报错都还好一点

01:14:18.320 --> 01:14:19.320
报错的话

01:14:19.320 --> 01:14:20.320
我们可以用Track-H

01:14:20.320 --> 01:14:21.320
对吧

01:14:21.320 --> 01:14:22.320
它连错误也不报

01:14:22.320 --> 01:14:23.320
所以说

01:14:23.320 --> 01:14:24.320
这个东西你没有办法知道

01:14:24.320 --> 01:14:26.320
它到底有没有

01:14:26.320 --> 01:14:28.320
就是错误消息发生

01:14:28.320 --> 01:14:30.320
这个也不是很好用

01:14:30.320 --> 01:14:32.320
所以说我们目前

01:14:32.320 --> 01:14:34.320
至少我这一块真的没有

01:14:34.320 --> 01:14:36.320
找到一个合适的解决办法

01:14:36.320 --> 01:14:37.320
那只能是一手东西

01:14:37.320 --> 01:14:39.320
其实也写不了多少代

01:14:39.320 --> 01:14:41.320
因为一般来说的话

01:14:41.320 --> 01:14:42.320
你要制定验证的话

01:14:42.320 --> 01:14:44.320
我们往往会把它抽象成一个函数

01:14:44.320 --> 01:14:45.320
把它单独提出去

01:14:45.320 --> 01:14:47.320
因为这些验证的往往是

01:14:47.320 --> 01:14:50.320
往往都会重复使用的

01:14:50.320 --> 01:14:51.320
OK

01:14:51.320 --> 01:14:52.320
这就是咱们

01:14:52.320 --> 01:14:54.320
时间有点长

01:14:54.320 --> 01:14:56.320
它其实内容并不复杂

01:14:56.320 --> 01:14:58.320
就是说东西还是有点多

01:14:58.320 --> 01:14:59.320
咱们下一课

01:14:59.320 --> 01:15:00.320
还是利用这一课的东西

01:15:00.320 --> 01:15:02.320
做一个练习吧

01:15:02.320 --> 01:15:03.320
好了

01:15:03.320 --> 01:15:04.320
这就是这一课

01:15:04.320 --> 01:15:05.320
验证这一会的知识

