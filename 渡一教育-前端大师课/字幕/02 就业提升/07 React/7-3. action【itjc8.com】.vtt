WEBVTT

00:00.690 --> 00:04.690
从这节课开始 咱们就一部分一部分来说

00:04.690 --> 00:07.290
这个Redar实际表 这三个东西

00:07.290 --> 00:09.690
分别写的时候 要注意一些什么

00:09.690 --> 00:12.690
首先我们这节课要说的是这个action

00:12.690 --> 00:15.690
action用来干嘛的 action就是用来描述

00:15.690 --> 00:19.690
我要做什么事情的 对吧 这是action的作用

00:19.690 --> 00:21.690
它用来描述我要做什么事情

00:21.690 --> 00:24.690
这个action我们这里做笔记

00:27.260 --> 00:32.260
这个 我们这里写一个action

00:32.260 --> 00:36.570
那么它这里边有哪些地方要注意的呢

00:36.570 --> 00:38.570
首先注意的第一点

00:38.570 --> 00:43.570
action是一个

00:43.570 --> 00:46.570
这东西怎么翻译呢 叫做plane object

00:49.570 --> 00:53.570
怎么翻译呢 叫做存对象

00:53.570 --> 00:57.570
或者应该叫做平面对象

00:57.570 --> 01:00.570
这个平面对象是什么东西呢

01:00.570 --> 01:03.570
你可以这样理解 就是

01:03.570 --> 01:06.570
平面对象就是它的原型

01:06.570 --> 01:09.570
它的就是这个proto

01:09.570 --> 01:13.570
这个影视原型 指向

01:13.570 --> 01:15.570
指向什么呢 object

01:15.570 --> 01:17.570
object

01:17.570 --> 01:20.570
第二proto type

01:20.570 --> 01:22.570
就这么一个平面对象

01:22.570 --> 01:24.570
你可以直接理解就是一个对象字面量

01:24.570 --> 01:26.570
创建的对象

01:26.570 --> 01:29.570
那么注意action必须是一个平面对象

01:29.570 --> 01:31.570
非常非常简单的对象

01:31.570 --> 01:34.570
它不能有一些乱七八糟的继承

01:34.570 --> 01:36.570
继承链 就是原型链

01:36.570 --> 01:40.570
比方说 咱们action这里

01:40.570 --> 01:42.570
这是个平面对象 对吧

01:42.570 --> 01:44.570
所以说一切运行起来很正常

01:44.570 --> 01:46.570
那么现在我们

01:46.570 --> 01:49.570
比方说现在我们这里

01:49.570 --> 01:51.570
给它写这么一个构造函数

01:51.570 --> 01:52.570
一个class 一个内

01:52.570 --> 01:54.570
action

01:54.570 --> 01:57.570
然后我们比方说一个constructor

01:57.570 --> 01:59.570
给我一个type值

01:59.570 --> 02:01.570
然后我们这里

02:01.570 --> 02:04.570
this.type 等于type

02:04.570 --> 02:06.570
比方说我们自己写一个内

02:06.570 --> 02:07.570
action这个内

02:07.570 --> 02:09.570
那么我们把这个action的

02:09.570 --> 02:12.570
如果说给它复制成为newaction

02:12.570 --> 02:14.570
然后内形是increase

02:14.570 --> 02:15.570
比方说这样子

02:15.570 --> 02:17.570
你看一下 行不行呢

02:17.570 --> 02:20.570
保存 我干嘛把个关掉了

02:21.570 --> 02:22.570
运行出来

02:22.570 --> 02:27.160
点击右键 检查

02:27.160 --> 02:29.160
你看一下 它告诉你什么

02:29.160 --> 02:32.160
action必须是一个plane object

02:32.160 --> 02:35.160
所以说你不能使用

02:35.160 --> 02:38.160
不能使用你自己的内来创建

02:38.160 --> 02:41.160
你必须要保证action的隐私原型

02:41.160 --> 02:44.160
要指向object的原型

02:46.160 --> 02:48.160
那么现在

02:49.160 --> 02:52.160
它这样做其实也是为了保持

02:53.160 --> 02:55.160
action的简洁

02:55.160 --> 02:58.160
因为action 它只是用来描述数据的

02:58.160 --> 03:00.160
描述就是

03:00.160 --> 03:02.160
它只是用来描述

03:02.160 --> 03:04.160
这个数据要怎么变化

03:04.160 --> 03:06.160
要干嘛 我要做什么样的操作

03:06.160 --> 03:08.160
对吧 你比方说像url 地址

03:08.160 --> 03:11.160
就是让以前的mvc 结构里边

03:11.160 --> 03:14.160
请求一个地址就表示到我要干嘛

03:14.160 --> 03:17.160
包括我们的请求方法都描述了我要干嘛

03:17.160 --> 03:19.160
它是一个非常非常简单的内形

03:19.160 --> 03:21.160
你不应该把它搞得那么复杂

03:21.160 --> 03:24.160
所以说它不允许你用这种方式来做

03:24.160 --> 03:27.160
它要爆错了 你只能是一个简单对象

03:27.160 --> 03:29.160
只能是这么一个简单对象

03:29.160 --> 03:31.160
tab increase

03:31.160 --> 03:33.160
这样子没问题了

03:33.160 --> 03:35.160
什么没问题的

03:35.160 --> 03:38.160
那么这是关于action的第一个要注意的地方

03:38.160 --> 03:40.160
它必须是一个平面对象

03:40.160 --> 03:43.160
接下来我们再来看

03:44.160 --> 03:46.160
然后这里

03:46.160 --> 03:48.160
action中的

03:48.160 --> 03:51.160
action中必须有

03:51.160 --> 03:53.160
type属性

03:53.160 --> 03:55.160
type属性

03:55.160 --> 03:56.160
那么比方说

03:56.160 --> 03:58.160
我们这里用的不是type

03:58.160 --> 04:00.160
而是type1 那比方说

04:00.160 --> 04:02.160
咱们这个action它是type1

04:02.160 --> 04:03.160
那么它告诉你 它给你爆了个错

04:03.160 --> 04:04.160
它说

04:04.160 --> 04:06.160
action它可能没有

04:06.160 --> 04:08.160
它有一个undefined type属性

04:08.160 --> 04:10.160
只是它是undefined

04:10.160 --> 04:12.160
它是不是你忘记了

04:12.160 --> 04:14.160
忘记了谁这个属性了

04:14.160 --> 04:17.160
所以action里边它必须要有type属性

04:17.160 --> 04:19.160
type属性干嘛的

04:19.160 --> 04:21.160
type属性

04:21.160 --> 04:23.160
type属性

04:23.160 --> 04:25.160
用于

04:25.160 --> 04:27.160
描述

04:27.160 --> 04:29.160
操作的内性

04:29.160 --> 04:31.160
你可以认为type属性

04:31.160 --> 04:33.160
就好像是

04:33.160 --> 04:35.160
请求地址 就好像是请求地址

04:35.160 --> 04:37.160
你不同的请求地址就描述了我要干嘛

04:37.160 --> 04:39.160
还包括请求方法

04:39.160 --> 04:41.160
是可以认为它是请求地址

04:41.160 --> 04:43.160
和请求方法的一个综合题

04:43.160 --> 04:45.160
因为我们请求方法和请求地址

04:45.160 --> 04:47.160
那么这个action

04:47.160 --> 04:49.160
它也是这个意思

04:49.160 --> 04:51.160
它有个type属性值

04:51.160 --> 04:53.160
它用于描述操作的内性

04:53.160 --> 04:55.160
但是它这个属性值

04:55.160 --> 04:57.160
它并没有说要求你必须是制服串

04:57.160 --> 04:59.160
它没有要求你制服串

04:59.160 --> 05:01.160
你可以是任何内性

05:01.160 --> 05:03.160
可以是任何内性

05:03.160 --> 05:05.160
比方说你这个玩意

05:05.160 --> 05:07.160
你这个玩意能不能是一个数字呢

05:07.160 --> 05:09.160
能不能是一个数字呢

05:09.160 --> 05:11.160
type内性

05:11.160 --> 05:13.160
可以是一个数字

05:13.160 --> 05:15.160
对吧

05:15.160 --> 05:17.160
如果你这里写的是数字的话

05:17.160 --> 05:19.160
这里判断的时候是要根据数字来判断

05:19.160 --> 05:21.160
对吧 根据数字来判断

05:21.160 --> 05:23.160
如果type等于1表示我要增加

05:23.160 --> 05:25.160
type等于0表示我要减少

05:25.160 --> 05:27.160
你可以自行这样子约定

05:27.160 --> 05:29.160
它没有要求你必须是制服串

05:29.160 --> 05:31.160
我这边再记一笔

05:31.160 --> 05:33.160
但是

05:33.160 --> 05:35.160
没有要求

05:35.160 --> 05:37.160
没有对type的内性

05:37.160 --> 05:39.160
做出要求

05:39.160 --> 05:41.160
这是关于type属性

05:41.160 --> 05:43.160
还有更多的点

05:43.160 --> 05:45.160
我们要说一下

05:45.160 --> 05:47.160
这会影响我们的开发方式

05:47.160 --> 05:49.160
在

05:49.160 --> 05:51.160
大形项目中

05:51.160 --> 05:53.160
由于

05:53.160 --> 05:55.160
操作内型

05:55.160 --> 05:57.160
非常多

05:57.160 --> 05:59.160
有多种方式来改变数据

05:59.160 --> 06:01.160
比如说添加一个学生

06:01.160 --> 06:03.160
添加一个电影

06:03.160 --> 06:05.160
修改一个电影

06:05.160 --> 06:07.160
查询一个电影

06:07.160 --> 06:09.160
各种各样的操作

06:09.160 --> 06:11.160
可能会非常多

06:11.160 --> 06:13.160
为了避免用边码

06:13.160 --> 06:15.160
为了避免用边码

06:15.160 --> 06:18.790
用边码

06:18.790 --> 06:20.790
大家有没有听说过什么叫用边码

06:20.790 --> 06:22.790
叫hardcode

06:22.790 --> 06:24.790
code是个动词

06:24.790 --> 06:26.790
code表示编码的意思

06:26.790 --> 06:28.790
编写代码的意思

06:28.790 --> 06:30.790
为了避免用边码

06:30.790 --> 06:32.790
会将

06:32.790 --> 06:34.790
action的内型

06:34.790 --> 06:36.790
存放到

06:36.790 --> 06:38.790
一些

06:38.790 --> 06:40.790
一个或一些

06:40.790 --> 06:42.790
单独的文件中

06:42.790 --> 06:44.790
它会这么来操作

06:44.790 --> 06:46.790
会将action的内型存放到一个单独的文件中

06:46.790 --> 06:48.790
什么意思呢

06:48.790 --> 06:50.790
比方说我们这里

06:50.790 --> 06:52.790
假设

06:52.790 --> 06:54.790
action是一个increase

06:54.790 --> 06:56.790
我们是个大型项目

06:56.790 --> 06:58.790
会经常来增加数字

06:58.790 --> 07:00.790
会经常增加或减少数字

07:00.790 --> 07:02.790
来控制共享代码

07:02.790 --> 07:04.790
现在我们在reducer里判断的时候

07:04.790 --> 07:06.790
是不是写死的单词

07:06.790 --> 07:08.790
你看这里是不是写死的

07:08.790 --> 07:10.790
将来有一天

07:10.790 --> 07:12.790
我要改变这个字

07:12.790 --> 07:14.790
是不是要导致很多问题了

07:14.790 --> 07:16.790
要到处去改

07:16.790 --> 07:18.790
很难以维护

07:18.790 --> 07:20.790
并且我们写的时候也经常写错

07:20.790 --> 07:22.790
毕竟有这么多字母

07:22.790 --> 07:24.790
你稍微写出了一个大小写

07:24.790 --> 07:26.790
比方说这里是区分大小写的

07:26.790 --> 07:28.790
因为你这里判断的时候

07:28.790 --> 07:30.790
是不是这样的判断的时候

07:30.790 --> 07:32.790
是区分大小写的

07:32.790 --> 07:34.790
那你稍微写出了一个单词

07:34.790 --> 07:36.790
是不是就会导致

07:36.790 --> 07:38.790
就出问题

07:38.790 --> 07:40.790
容易造成错误

07:40.790 --> 07:42.790
当然在一些小型中型项目里

07:42.790 --> 07:44.790
都无所谓

07:44.790 --> 07:46.790
因为我们的共享的数据本来就不多

07:46.790 --> 07:48.790
并且我们的类型

07:48.790 --> 07:50.790
也就那么一些并不多

07:50.790 --> 07:52.790
而且我们平时也写错了很少

07:52.790 --> 07:54.790
所以说我们没有必要去这样做

07:54.790 --> 07:56.790
但是如果在大型项目里边

07:56.790 --> 07:58.790
操作类型非常多

07:58.790 --> 08:00.790
为了避免硬编

08:00.790 --> 08:02.790
什么叫硬编

08:02.790 --> 08:04.790
不好更改

08:04.790 --> 08:06.790
不好更改,这不是硬编吗

08:06.790 --> 08:08.790
反而是看到某个地方有一个字面量的字母串

08:08.790 --> 08:10.790
某个地方有一个就是

08:10.790 --> 08:12.790
字面量的对象

08:12.790 --> 08:14.790
那些都是属于硬编

08:14.790 --> 08:16.790
那么

08:16.790 --> 08:18.790
为了避免这样的问题的话

08:18.790 --> 08:20.790
我们通常会在这里

08:20.790 --> 08:22.790
会在这里建一个文件夹

08:22.790 --> 08:24.790
X型

08:24.790 --> 08:26.790
这个文件夹里边

08:26.790 --> 08:28.790
我们新建个文件

08:28.790 --> 08:30.790
比方说该取个名字叫做X型

08:30.790 --> 08:32.790
X型Type

08:32.790 --> 08:34.790
或者是一个横杠X型Type

08:34.790 --> 08:36.790
都想看你的公司里边怎么去

08:36.790 --> 08:38.790
给文件命名

08:38.790 --> 08:40.790
那么写了这么一个文件

08:40.790 --> 08:42.790
这个文件里边干嘛的

08:42.790 --> 08:44.790
它就是导出各种各样的类型

08:44.790 --> 08:46.790
X型类型避免硬编

08:46.790 --> 08:48.790
比方说这里导出

08:48.790 --> 08:50.790
export导出

08:50.790 --> 08:52.790
一个X型类型叫做increase

08:52.790 --> 08:54.790
increase

08:54.790 --> 08:59.130
导出一个

08:59.130 --> 09:01.130
increase

09:01.130 --> 09:03.130
然后这里我们就写一个字不出来

09:03.130 --> 09:04.130
increase

09:04.130 --> 09:06.130
它表示的是X型的类型

09:06.130 --> 09:08.130
X型的类型它是一个increase

09:08.130 --> 09:09.130
它是增加

09:09.130 --> 09:11.130
然后我们再导出

09:11.130 --> 09:13.130
export

09:13.130 --> 09:15.130
Decrease

09:15.130 --> 09:17.130
这个非常很好理解

09:17.130 --> 09:18.130
Decrease

09:18.130 --> 09:20.130
那么这样子的是不是只写一次就行了

09:20.130 --> 09:22.130
在这个地方进行一次硬编

09:22.130 --> 09:23.130
那么之后我们就

09:23.130 --> 09:25.130
是不是全部使用这个

09:25.130 --> 09:26.130
因为是长量

09:26.130 --> 09:27.130
所以说我们手这么开头

09:27.130 --> 09:28.130
当然也可以

09:28.130 --> 09:29.130
长量有的时候

09:29.130 --> 09:30.130
看公司的个人

09:30.130 --> 09:32.130
看公司里面的命名要求

09:32.130 --> 09:34.130
也可以全部大写

09:34.130 --> 09:35.130
Decrease

09:35.130 --> 09:38.130
这也是一种长量的就是命名方式

09:38.130 --> 09:40.130
那么这样子

09:40.130 --> 09:41.130
我们就把这个硬编

09:41.130 --> 09:43.130
就写到单独的一个文件里边了

09:43.130 --> 09:44.130
那么到这边来

09:44.130 --> 09:46.130
我们要增加或减少的时候

09:46.130 --> 09:48.130
我们是不是可以导入

09:48.130 --> 09:50.130
我们把整体导入

09:50.130 --> 09:52.130
跟他决定另个比名

09:52.130 --> 09:53.130
X型

09:53.130 --> 09:54.130
Types

10:00.130 --> 10:01.130
X型

10:01.130 --> 10:03.130
Type

10:03.130 --> 10:04.130
那么这里面

10:04.130 --> 10:05.130
我们这里比较的时候

10:05.130 --> 10:06.130
是不是可以这样比较

10:06.130 --> 10:07.130
对吧

10:07.130 --> 10:08.130
Action

10:08.130 --> 10:09.130
Types

10:09.130 --> 10:10.130
Decrease

10:10.130 --> 10:11.130
对吧

10:11.130 --> 10:12.130
然后这里

10:13.130 --> 10:14.130
Action

10:14.130 --> 10:15.130
Types

10:15.130 --> 10:16.130
Decrease

10:16.130 --> 10:17.130
对吧

10:17.130 --> 10:18.130
Decrease

10:18.130 --> 10:19.130
好

10:19.130 --> 10:20.130
你是不是可以看一下

10:20.130 --> 10:21.130
是不是可以这样比较了

10:21.130 --> 10:22.130
然后这边

10:22.130 --> 10:23.130
Types

10:23.130 --> 10:24.130
是不是来自于

10:24.130 --> 10:25.130
Action

10:25.130 --> 10:26.130
Types

10:26.130 --> 10:27.130
Increase

10:27.130 --> 10:28.130
对吧

10:28.130 --> 10:29.130
那你看一下

10:29.130 --> 10:30.130
这个代码里面

10:30.130 --> 10:31.130
在这一段代码里面

10:31.130 --> 10:32.130
是不是没有硬编码了

10:32.130 --> 10:33.130
硬编码什么意思呢

10:33.130 --> 10:35.130
你只要看到两个字幕串

10:35.130 --> 10:36.130
一个就两个双引号

10:36.130 --> 10:37.130
或者两个单引号

10:37.130 --> 10:38.130
或者两个漂漂

10:38.130 --> 10:39.130
对吧

10:39.130 --> 10:40.130
模板字幕串

10:40.130 --> 10:41.130
你只要看到这种这种形式

10:41.130 --> 10:42.130
就是硬编码

10:42.130 --> 10:43.130
它不一定是字幕串

10:43.130 --> 10:45.130
就是有些东西一把写死了

10:45.130 --> 10:47.130
那么现在是不是没有写死

10:47.130 --> 10:48.130
对吧

10:48.130 --> 10:49.130
我们是来自于辩量的值

10:49.130 --> 10:50.130
你看一下

10:50.130 --> 10:51.130
对不对

10:51.130 --> 10:52.130
现在没有写死

10:52.130 --> 10:53.130
这样的好处在于

10:53.130 --> 10:54.130
我们将来

10:54.130 --> 10:56.130
第一是不容易出错

10:56.130 --> 10:57.130
在大型项目里边

10:57.130 --> 10:58.130
到时候除了一些错误

10:58.130 --> 10:59.130
不是很好调

10:59.130 --> 11:00.130
不容易出错

11:00.130 --> 11:01.130
因为我们用的是辩量

11:01.130 --> 11:02.130
你辩量名字写出来

11:02.130 --> 11:03.130
它肯定是

11:03.130 --> 11:05.130
都会直接提示你

11:07.130 --> 11:08.130
至少它运行出来

11:08.130 --> 11:09.130
会告诉你

11:09.130 --> 11:10.130
对不对

11:10.130 --> 11:11.130
它说告诉你

11:12.130 --> 11:13.130
这个东西不存在

11:13.130 --> 11:14.130
并没有导出

11:14.130 --> 11:16.130
这个导出里边

11:16.130 --> 11:17.130
它并没有这个东西

11:17.130 --> 11:18.130
并没有这个东西

11:18.130 --> 11:20.130
它会提示你

11:21.130 --> 11:22.130
这就是这种写法

11:22.130 --> 11:23.130
避免硬编码

11:23.130 --> 11:24.130
那么到时候

11:24.130 --> 11:25.130
比方说

11:25.130 --> 11:26.130
我们这里要改变

11:26.130 --> 11:27.130
Decrase面子

11:27.130 --> 11:28.130
变成这样子

11:28.130 --> 11:29.130
这里Decrase面子

11:29.130 --> 11:30.130
变成这样子

11:30.130 --> 11:31.130
那么你看一下

11:31.130 --> 11:32.130
不会有任何问题

11:32.130 --> 11:33.130
对吧

11:33.130 --> 11:34.130
我们只需要在这个文件里

11:34.130 --> 11:35.130
更加就行了

11:35.130 --> 11:36.130
那么这个东西

11:36.130 --> 11:38.130
我们把它叫做

11:38.130 --> 11:39.130
这个单读的文件

11:39.130 --> 11:41.130
叫做就是央板代码

11:41.130 --> 11:42.130
央板代码

11:45.130 --> 11:46.130
央板代码

11:46.130 --> 11:47.130
小的

11:47.130 --> 11:48.130
当然了这里边

11:48.130 --> 11:49.130
如果说以后

11:49.130 --> 11:50.130
你为了

11:50.130 --> 11:52.130
为了避免就是

11:52.130 --> 11:53.130
避免什么

11:53.130 --> 11:55.130
就是避免那个

11:55.130 --> 11:56.130
明智冲突

11:56.130 --> 11:58.130
你可能在大型项目里边

11:58.130 --> 11:59.130
制服刷写多了

11:59.130 --> 12:00.130
我们如果用制服刷的话

12:00.130 --> 12:01.130
制服刷写多了

12:01.130 --> 12:02.130
是不是会有明智冲突

12:02.130 --> 12:03.130
对吧

12:03.130 --> 12:04.130
你这里增加一个数字

12:04.130 --> 12:05.130
那比方说

12:05.130 --> 12:06.130
我们以后还有更多的X

12:06.130 --> 12:08.130
比方说增加一个电影的

12:08.130 --> 12:09.130
增加一个库存

12:09.130 --> 12:10.130
对吧

12:10.130 --> 12:11.130
比方说商城系统

12:11.130 --> 12:12.130
增加一个库存

12:12.130 --> 12:13.130
减少一个库存

12:13.130 --> 12:14.130
或者是

12:14.130 --> 12:16.130
增加一个就是

12:17.130 --> 12:18.130
增加一个就是

12:18.130 --> 12:19.130
电影的数量

12:19.130 --> 12:20.130
减少一个电影的数量

12:20.130 --> 12:21.130
对吧

12:21.130 --> 12:22.130
等等

12:22.130 --> 12:23.130
它可能有明智的

12:23.130 --> 12:24.130
有可能有冲突

12:24.130 --> 12:25.130
那是不是明智

12:25.130 --> 12:26.130
可能会有冲突

12:26.130 --> 12:27.130
那么为了避免这样子

12:27.130 --> 12:28.130
我们这里是不是

12:28.130 --> 12:29.130
还可以用symbol对吧

12:29.130 --> 12:30.130
因为我们知道这个action

12:30.130 --> 12:31.130
它可以这个type值

12:31.130 --> 12:33.130
它可以使任何类型

12:33.130 --> 12:34.130
可以使任何类型

12:34.130 --> 12:35.130
对不对

12:36.130 --> 12:37.130
我们这里

12:38.130 --> 12:40.130
可以使用symbol对不对

12:40.130 --> 12:41.130
symbol

12:42.130 --> 12:46.270
我为什么要用for呢

12:46.270 --> 12:47.270
symbol

12:47.270 --> 12:48.270
我们这里

12:48.270 --> 12:50.270
写上一个increase

12:51.270 --> 12:52.270
increase

12:53.270 --> 12:54.270
这里也是

12:54.270 --> 12:55.270
decrease

12:55.270 --> 12:56.270
decrease

12:57.270 --> 12:58.270
那么用了symbol过后

12:58.270 --> 12:59.270
你看还是没有变

12:59.270 --> 13:00.270
对吧

13:00.270 --> 13:01.270
为什么

13:01.270 --> 13:02.270
因为你这里是倒出了的

13:02.270 --> 13:03.270
所以说这边

13:03.270 --> 13:04.270
用的就是同一个变量

13:04.270 --> 13:05.270
对吧

13:05.270 --> 13:06.270
同一个变量的值

13:06.270 --> 13:07.270
我们可以用symbol类型

13:07.270 --> 13:08.270
包括我们后边

13:08.270 --> 13:09.270
如果说

13:09.270 --> 13:10.270
增加了不同的东西

13:10.270 --> 13:11.270
增加了不同

13:11.270 --> 13:12.270
比方说你这里

13:12.270 --> 13:13.270
变量明智

13:13.270 --> 13:14.270
不可能重复了

13:14.270 --> 13:15.270
那里后面不小心

13:15.270 --> 13:16.270
又写了一个increase

13:16.270 --> 13:17.270
但是它马上

13:17.270 --> 13:18.270
给你爆错了

13:18.270 --> 13:19.270
你马上知道

13:19.270 --> 13:20.270
你这里重明了

13:20.270 --> 13:21.270
但是这里是不是可以重明

13:21.270 --> 13:22.270
对吧

13:22.270 --> 13:23.270
因为我们之前

13:23.270 --> 13:24.270
那怕这里

13:24.270 --> 13:25.270
是不是说是一样的

13:25.270 --> 13:26.270
得到了也是不一样的东西

13:26.270 --> 13:27.270
对吧

13:27.270 --> 13:28.270
就可以避免这样的问题

13:28.270 --> 13:29.270
避免各种

13:29.270 --> 13:30.270
就是减少一些隐患

13:30.270 --> 13:31.270
可以这样说

13:32.270 --> 13:33.270
就是我们可以用一个

13:33.270 --> 13:34.270
样板代码

13:34.270 --> 13:35.270
来完成这样的

13:35.270 --> 13:38.270
就是来搞定这些问题

13:38.270 --> 13:39.270
只不过

13:39.270 --> 13:40.270
大家要注意

13:40.270 --> 13:41.270
样板代码

13:41.270 --> 13:42.270
不是说一定要写

13:42.270 --> 13:43.270
不要以后到公司说

13:43.270 --> 13:44.270
你看公司里边

13:44.270 --> 13:45.270
没有写

13:45.270 --> 13:46.270
没有写这个样板代码

13:46.270 --> 13:47.270
你说公司写的一个问题

13:47.270 --> 13:48.270
那不是这个意思

13:48.270 --> 13:49.270
它在大型项目里边

13:49.270 --> 13:50.270
才会用到这个东西

13:50.270 --> 13:52.270
平时在中小型项目里边

13:52.270 --> 13:53.270
会用这个东西

13:53.270 --> 13:54.270
也不是说一定

13:54.270 --> 13:55.270
看具体情况

13:55.270 --> 13:56.270
就是说

13:56.270 --> 13:57.270
如果你的操作内型

13:57.270 --> 13:58.270
非常多

13:58.270 --> 13:59.270
经常容易出窗的话

13:59.270 --> 14:01.270
那么建议就使用这个东西

14:01.270 --> 14:02.270
就是这个东西

14:02.270 --> 14:03.270
大家学习的肯定

14:03.270 --> 14:04.270
要麻烦一点

14:04.270 --> 14:05.270
稍微麻烦一点

14:05.270 --> 14:06.270
你要导入

14:06.270 --> 14:07.270
导入这个类型

14:07.270 --> 14:09.270
还要去干嘛呢

14:09.270 --> 14:11.270
还要去使用

14:11.270 --> 14:12.270
类型里边的

14:12.270 --> 14:13.270
相应的变量

14:13.270 --> 14:15.270
肯定要稍微麻烦一点

14:15.270 --> 14:17.270
但是对大型系统的话

14:17.270 --> 14:18.270
对大型系统的话

14:18.270 --> 14:19.270
是非常重要的

14:19.270 --> 14:21.270
因为它的操作内型很多

14:22.270 --> 14:23.270
这是关于这一点

14:24.270 --> 14:26.270
那么第四点就是

14:28.270 --> 14:30.270
为了方便

14:30.270 --> 14:31.270
就是

14:33.270 --> 14:34.270
方便传递X型

14:34.270 --> 14:37.270
通常会使用

14:37.270 --> 14:39.270
X型创建函数

14:40.270 --> 14:41.270
创建函数

14:41.270 --> 14:43.270
来创建X型

14:43.270 --> 14:45.270
就什么意思呢

14:45.270 --> 14:46.270
这一块是什么意思呢

14:46.270 --> 14:47.270
就是说

14:47.270 --> 14:48.270
我们以后比方说

14:48.270 --> 14:49.270
比方说

14:49.270 --> 14:50.270
我们以后要增加

14:50.270 --> 14:51.270
对吧

14:51.270 --> 14:53.270
要增加一个

14:53.270 --> 14:55.270
要增加一个数字

14:55.270 --> 14:56.270
要增加一个数字

14:56.270 --> 14:57.270
或者是减少一个数字

14:57.270 --> 14:58.270
是不是我们

14:58.270 --> 15:00.270
每次都在剧写这么一个X型

15:00.270 --> 15:01.270
写起来是不是很麻烦

15:01.270 --> 15:02.270
对吧

15:02.270 --> 15:03.270
写起来很麻烦

15:03.270 --> 15:05.270
这个东西倒不是

15:05.270 --> 15:07.270
容易出错的问题

15:07.270 --> 15:08.270
因为你加了一样

15:08.270 --> 15:09.270
满代码过后了

15:09.270 --> 15:10.270
这里不太容易出错

15:10.270 --> 15:11.270
就是很烦

15:12.270 --> 15:14.270
我干嘛要每次去

15:14.270 --> 15:16.270
新建一个对象呢

15:16.270 --> 15:18.270
我无非就是想增加

15:18.270 --> 15:20.270
你给我

15:20.270 --> 15:21.270
我要去做这么一种

15:21.270 --> 15:22.270
凡数的操作就挺麻烦的

15:22.270 --> 15:23.270
所以说

15:23.270 --> 15:25.270
我们通常会用一个函数

15:25.270 --> 15:28.270
来帮助我们来创建一个X型

15:28.270 --> 15:30.270
来帮助我们创建一个X型

15:30.270 --> 15:32.270
那么这个函数怎么写呢

15:32.270 --> 15:33.270
我们这个函数呢

15:33.270 --> 15:35.270
就叫做X型创建函数

15:35.270 --> 15:36.270
比方说

15:36.270 --> 15:37.270
我们在这个X型文件夹里面

15:37.270 --> 15:38.270
新建的文件

15:39.270 --> 15:40.270
举个例子

15:41.270 --> 15:42.270
就Number

15:44.270 --> 15:45.270
就是个数字

15:45.270 --> 15:46.270
数字X型

15:47.270 --> 15:48.270
叫JS

15:48.270 --> 15:49.270
Number X型

15:49.270 --> 15:50.270
叫JS

15:50.270 --> 15:51.270
那么这个JS文件里面

15:51.270 --> 15:52.270
我们就

15:52.270 --> 15:53.270
主要的目的

15:53.270 --> 15:55.270
就是得到X型对象

15:55.270 --> 15:57.270
方便它来得到X型对象

15:58.270 --> 15:59.270
那么比方说

15:59.270 --> 16:00.270
我们这里呢

16:01.270 --> 16:03.270
导出这么两个函数

16:04.270 --> 16:05.270
第一个函数是

16:05.270 --> 16:06.270
叫做Get

16:07.270 --> 16:08.270
Increase

16:08.270 --> 16:09.270
Increase

16:09.270 --> 16:10.270
X型

16:11.270 --> 16:13.270
得到一个增加的X型

16:14.270 --> 16:16.270
得到一个X型

16:18.270 --> 16:19.270
就是

16:19.270 --> 16:20.270
用于

16:21.270 --> 16:22.270
增加

16:22.270 --> 16:24.270
数字操作的

16:25.270 --> 16:26.270
X型

16:26.270 --> 16:27.270
也就是说

16:27.270 --> 16:28.270
我们

16:28.270 --> 16:29.270
雕用这个函数

16:29.270 --> 16:30.270
它就是做什么

16:30.270 --> 16:31.270
做一个很简单的事情

16:31.270 --> 16:33.270
就是帮我们把这个X型创建好

16:33.270 --> 16:34.270
返回

16:34.270 --> 16:35.270
因为这里很简单

16:35.270 --> 16:36.270
超级简单

16:36.270 --> 16:37.270
就是返回这么一个X型

16:37.270 --> 16:38.270
完了

16:38.270 --> 16:39.270
没了

16:39.270 --> 16:40.270
那么这里呢

16:40.270 --> 16:41.270
我们把这个X型Type

16:41.270 --> 16:42.270
放过来

16:44.270 --> 16:45.270
这里

16:45.270 --> 16:46.270
把这个去掉

16:47.270 --> 16:48.270
你看一下

16:48.270 --> 16:49.270
对吧

16:49.270 --> 16:50.270
就是这么一个函数

16:50.270 --> 16:51.270
然后我们再带导出

16:51.270 --> 16:52.270
方形

16:52.270 --> 16:53.270
Get

16:53.270 --> 16:54.270
Decrease

16:54.270 --> 16:55.270
Decrease

16:55.270 --> 16:56.270
X型

16:57.270 --> 16:58.270
那么这里返回

16:58.270 --> 16:59.270
Type之等于什么呢

16:59.270 --> 17:00.270
等于

17:00.270 --> 17:01.270
ActionTypes

17:01.270 --> 17:02.270
第二

17:02.270 --> 17:03.270
Decrease

17:03.270 --> 17:04.270
当然

17:04.270 --> 17:05.270
如果说你没有杨满代码

17:05.270 --> 17:06.270
没有这个文件的话

17:06.270 --> 17:07.270
那么你这里可以直接写识

17:08.270 --> 17:09.270
可以直接写识

17:10.270 --> 17:11.270
保存

17:11.270 --> 17:12.270
所以

17:12.270 --> 17:13.270
现在就可以通过函数

17:13.270 --> 17:14.270
来创建X型的

17:14.270 --> 17:15.270
对吧

17:15.270 --> 17:16.270
所以通过函数来创建X型

17:16.270 --> 17:17.270
那么这里

17:17.270 --> 17:18.270
我们之后

17:18.270 --> 17:19.270
要得到X型的

17:19.270 --> 17:20.270
就不用这种方式来得到

17:20.270 --> 17:21.270
就不用这种方式的

17:21.270 --> 17:22.270
用什么方式呢

17:22.270 --> 17:23.270
我们可以导入

17:24.270 --> 17:25.270
导入什么呢

17:25.270 --> 17:26.270
导入那个

17:27.270 --> 17:28.270
Number

17:28.270 --> 17:29.270
X型

17:29.270 --> 17:30.270
这里

17:30.270 --> 17:31.270
我们用个型号

17:31.270 --> 17:32.270
24

17:32.270 --> 17:33.270
Number

17:33.270 --> 17:34.270
X型

17:34.270 --> 17:35.270
From

17:36.270 --> 17:37.270
X型

17:37.270 --> 17:38.270
Number X型

17:38.270 --> 17:39.270
导入这个X型

17:39.270 --> 17:40.270
好

17:40.270 --> 17:41.270
那么这里

17:42.270 --> 17:44.270
你不是要分发X型吗

17:44.270 --> 17:45.270
那么这个X型哪来的

17:45.270 --> 17:47.270
我们通过一个函数来得到

17:47.270 --> 17:48.270
Get

17:48.270 --> 17:49.270
IncreaseX型

17:49.270 --> 17:51.270
我们就没有必要自己去手动写了

17:51.270 --> 17:53.270
那因为那边得到的是一个标准格式

17:53.270 --> 17:55.270
我们就没有必要去手动写了

17:55.270 --> 17:56.270
没有这个意思吗

17:57.270 --> 17:58.270
你看

17:58.270 --> 17:59.270
我们要得到增加的X型

17:59.270 --> 18:00.270
我们就通过这个函数

18:00.270 --> 18:02.270
这个函数的反回结果

18:03.270 --> 18:04.270
它的反回结果

18:04.270 --> 18:05.270
是不是就是一个X型

18:05.270 --> 18:06.270
对吧

18:06.270 --> 18:07.270
我们把它反回结果了

18:07.270 --> 18:08.270
作为X型分发出去

18:08.270 --> 18:09.270
是这么意思

18:09.270 --> 18:10.270
当然

18:10.270 --> 18:11.270
所以这个东西

18:11.270 --> 18:12.270
我觉得你应该学到这了

18:12.270 --> 18:13.270
你这个东西应该能看懂吧

18:13.270 --> 18:14.270
这个表达是

18:14.270 --> 18:15.270
你就相当于是这个

18:15.270 --> 18:16.270
先写这个

18:16.270 --> 18:18.270
然后得到这个X型

18:18.270 --> 18:19.270
再把X型放过来

18:19.270 --> 18:21.270
就是为了方便

18:21.270 --> 18:22.270
有时候说不方便

18:22.270 --> 18:23.270
不方便

18:23.270 --> 18:24.270
怎么这么麻烦呢

18:24.270 --> 18:26.270
那是因为我们目前的长期简单

18:26.270 --> 18:27.270
你自己手写X型

18:27.270 --> 18:28.270
也写不了多少代

18:29.270 --> 18:31.270
那长期的一旦稍微复杂一点的话

18:31.270 --> 18:33.270
那么我们就可以使用X型

18:33.270 --> 18:34.270
使用函数

18:34.270 --> 18:36.270
来得到一个标准的格式

18:36.270 --> 18:37.270
保存

18:37.270 --> 18:38.270
结果是完全一样的

18:38.270 --> 18:39.270
结果完全一样的

18:40.270 --> 18:41.270
一开始是10

18:41.270 --> 18:43.270
然后给它分发了一个

18:43.270 --> 18:44.270
增加的X型

18:44.270 --> 18:45.270
它就变成11了

18:46.270 --> 18:47.270
这个意思吧

18:47.270 --> 18:48.270
这东西叫做

18:48.270 --> 18:49.270
X型创建函数

18:49.270 --> 18:51.270
函是一个函数

18:51.270 --> 18:53.270
最终反回的是一个X型

18:53.270 --> 18:54.270
那么这个函数就是

18:54.270 --> 18:55.270
X型创建函数

18:55.270 --> 18:57.270
X型创建函数

18:58.270 --> 18:59.270
那么这是这一块

19:00.270 --> 19:01.270
那么关于这个

19:01.270 --> 19:02.270
X型创建函数

19:02.270 --> 19:03.270
我多说几句

19:03.270 --> 19:06.270
X型创建函数

19:06.270 --> 19:09.270
应为存函数

19:09.270 --> 19:11.270
存函数

19:11.270 --> 19:14.270
无副作用的存函数

19:14.270 --> 19:15.270
什么意思呢

19:15.270 --> 19:16.270
什么叫存函数

19:16.270 --> 19:17.270
就是存函数

19:17.270 --> 19:19.270
它只关心输入输出

19:19.270 --> 19:20.270
只关心输入输出

19:20.270 --> 19:21.270
你给我一个东西

19:21.270 --> 19:22.270
我反给你一个东西

19:22.270 --> 19:23.270
对吧

19:23.270 --> 19:25.270
存函数是最简单的函数

19:25.270 --> 19:26.270
也是最容易理解

19:26.270 --> 19:28.270
不容易出问题的函数

19:28.270 --> 19:29.270
因为X型

19:29.270 --> 19:30.270
它本身就是一个

19:30.270 --> 19:31.270
非常非常简单的一个对象

19:31.270 --> 19:32.270
你要得到X型

19:32.270 --> 19:33.270
逻辑上来说

19:33.270 --> 19:34.270
你要得到的是什么

19:34.270 --> 19:35.270
得到的是一个X型

19:35.270 --> 19:36.270
你为什么要给我

19:36.270 --> 19:38.270
搞一些其他的东西

19:38.270 --> 19:39.270
东西出来了

19:39.270 --> 19:40.270
你就是为了目的

19:40.270 --> 19:41.270
就是为了得到一个

19:41.270 --> 19:42.270
标准格式的X型

19:42.270 --> 19:43.270
就完事了

19:43.270 --> 19:44.270
所以说

19:44.270 --> 19:45.270
它这里要求

19:45.270 --> 19:47.270
X型是一个存函数

19:47.270 --> 19:48.270
X型必须是一个存函数

19:48.270 --> 19:49.270
当然这里面

19:49.270 --> 19:51.270
有可能会有一些特殊的情况

19:51.270 --> 19:52.270
特殊的情况

19:52.270 --> 19:53.270
我们后面再说

19:54.270 --> 19:56.270
那么存函数

19:57.270 --> 19:58.270
大家应该知道

19:58.270 --> 19:59.270
什么叫存函数

19:59.270 --> 20:00.270
无副作用的存函数

20:00.270 --> 20:01.270
我们这里说几句

20:01.270 --> 20:02.270
什么叫存函数

20:02.270 --> 20:03.270
就是说

20:03.270 --> 20:06.270
不能改动参数

20:06.270 --> 20:08.270
就是参数的指示不能改动的

20:08.270 --> 20:09.270
不要说这个函数

20:09.270 --> 20:10.270
现在目前是没有参数

20:10.270 --> 20:11.270
对吧

20:11.270 --> 20:12.270
那如果有参数的话

20:12.270 --> 20:13.270
参数的指示不能改动的

20:13.270 --> 20:15.270
不能以任何形式改动参数

20:15.270 --> 20:19.270
不能以任何形式改动参数

20:19.270 --> 20:21.270
不可以有异部

20:21.270 --> 20:22.270
这个函数里面

20:22.270 --> 20:23.270
不能有异部

20:23.270 --> 20:24.270
不能有异部的东西

20:24.270 --> 20:25.270
什么阿迦克斯琴球

20:25.270 --> 20:26.270
C 贪猫杂

20:26.270 --> 20:27.270
就别来了

20:27.270 --> 20:28.270
别来了

20:28.270 --> 20:29.270
在X型创建函数里面

20:29.270 --> 20:30.270
是不能写的

20:30.270 --> 20:31.270
不能有异部

20:32.270 --> 20:37.270
不可以对外部环境中的数据造成影响

20:37.270 --> 20:41.270
外部环境中的数据造成影响

20:41.270 --> 20:44.350
什么

20:44.350 --> 20:46.350
比如说你也要做一个本地存处

20:46.350 --> 20:47.350
往local storage里面夹一个

20:47.350 --> 20:49.350
往cookie里面写一些东西

20:49.350 --> 20:50.350
不要不能这样做

20:50.350 --> 20:51.350
包括什么外部的

20:51.350 --> 20:52.350
比方说外部的有些变量

20:52.350 --> 20:54.350
比方说这里外部给我写个变量

20:54.350 --> 20:56.350
你去改变这个变量的字

20:56.350 --> 20:57.350
这些都是副作用

20:57.350 --> 20:58.350
都是副作用

20:58.350 --> 21:00.350
什么叫存函数

21:00.350 --> 21:01.350
没有副作用是什么意思

21:01.350 --> 21:02.350
你把它这样理解

21:02.350 --> 21:04.350
就是一个输入输出

21:04.350 --> 21:05.350
你给我一个东西

21:05.350 --> 21:06.350
我就返回一个东西

21:06.350 --> 21:07.350
你给我的是

21:07.350 --> 21:09.350
我就一定返回你一个二

21:09.350 --> 21:10.350
比方说

21:10.350 --> 21:11.350
你给我的东西没变化

21:11.350 --> 21:13.350
那么返回的东西一定没变化

21:13.350 --> 21:14.350
一定是一样的

21:14.350 --> 21:16.350
你给我的东西变了

21:16.350 --> 21:17.350
我返回的东西

21:17.350 --> 21:19.350
就是你给我的东西是什么

21:19.350 --> 21:21.350
我返回的东西就是什么

21:21.350 --> 21:22.350
它是对应的

21:22.350 --> 21:23.350
对应的

21:23.350 --> 21:25.350
它就是一个简单的输入输出

21:25.350 --> 21:27.350
存函数是函数是编程里面的一种概念

21:27.350 --> 21:29.350
这样子的函数

21:29.350 --> 21:30.350
非常容易测试

21:30.350 --> 21:31.350
非常容易调试

21:31.350 --> 21:32.350
一旦出问题了

21:32.350 --> 21:33.350
你只比较说

21:33.350 --> 21:34.350
它得到的结果不同

21:34.350 --> 21:36.350
结果得到的结果不一样

21:36.350 --> 21:37.350
有问题

21:37.350 --> 21:38.350
那么你只需要观察这个函数

21:38.350 --> 21:40.350
本身是不是写的有问题

21:40.350 --> 21:41.350
另外再去观察这个函数

21:41.350 --> 21:43.350
给了参数是不是有问题

21:43.350 --> 21:45.350
你不用去管外部环境的东西

21:45.350 --> 21:46.350
因为它不会对外部环境

21:46.350 --> 21:47.350
产生任何影响

21:47.350 --> 21:48.350
我觉得吧

21:48.350 --> 21:50.350
这个东西以后发生起来

21:50.350 --> 21:53.350
会不会介绍在愚法层面上

21:53.350 --> 21:55.350
就给你检测这个函数

21:55.350 --> 21:56.350
是不是存函数

21:56.350 --> 21:57.350
有没有这种可能

21:57.350 --> 21:59.350
我觉得这个存函数

21:59.350 --> 22:01.350
在前多一领域里面

22:01.350 --> 22:03.350
用的还是蛮多的

22:03.350 --> 22:06.350
这是关于X型创建函数

22:10.350 --> 22:11.350
然后我们现在的创建函数

22:11.350 --> 22:12.350
是没有参数的

22:12.350 --> 22:13.350
是没有参数的

22:13.350 --> 22:16.350
要不然我们再写一个有参数的吧

22:16.350 --> 22:18.350
我们再写一个有参数的

22:18.350 --> 22:20.350
那比方说吧

22:21.350 --> 22:23.350
我们之前的状态

22:23.350 --> 22:24.350
Reducer里面

22:24.350 --> 22:26.350
不是有知情约定了

22:26.350 --> 22:28.350
约定了有两种

22:28.350 --> 22:29.350
操作类型

22:29.350 --> 22:30.350
一个是增加

22:30.350 --> 22:31.350
一个是减少

22:31.350 --> 22:32.350
那么比方说

22:32.350 --> 22:33.350
还有一种操作类型

22:33.350 --> 22:34.350
叫做set

22:34.350 --> 22:35.350
操作类型叫做set

22:35.350 --> 22:37.350
就是直接设差的一个值

22:37.350 --> 22:39.350
等于某一个值

22:39.350 --> 22:40.350
直接设置它的值

22:40.350 --> 22:41.350
等于某一个值

22:41.350 --> 22:42.350
比方说吧

22:42.350 --> 22:43.350
比方说

22:43.350 --> 22:44.350
那么我们这里

22:44.350 --> 22:46.350
我们可以在操作类型里面

22:46.350 --> 22:47.350
加一个类型

22:47.350 --> 22:49.350
叫做set

22:51.350 --> 22:52.350
那么这里

22:52.350 --> 22:54.350
我们写上这个就是

22:56.350 --> 22:57.350
symbol里面

22:58.350 --> 22:59.350
set

23:00.350 --> 23:01.350
多了一个操作类型了

23:01.350 --> 23:03.350
多了一个操作类型之后

23:03.350 --> 23:05.350
我们在Reducer里面

23:05.350 --> 23:06.350
来判断一下

23:06.350 --> 23:07.350
如果说

23:07.350 --> 23:09.350
Reducer里面判断

23:09.350 --> 23:10.350
它的类型

23:10.350 --> 23:11.350
如果说等于了

23:11.350 --> 23:13.350
等于了action types

23:13.350 --> 23:14.350
里面的set

23:15.350 --> 23:17.350
设置数据

23:17.350 --> 23:18.350
设置数据

23:18.350 --> 23:19.350
维某一个值

23:20.350 --> 23:21.350
那么我们这里

23:21.350 --> 23:23.350
直接返回什么了

23:23.350 --> 23:24.350
比方说吧

23:24.350 --> 23:25.350
我们举个例子

23:25.350 --> 23:26.350
举个例子

23:26.350 --> 23:27.350
可能是这个样子

23:27.350 --> 23:29.350
类型是set

23:29.350 --> 23:30.350
设置数据

23:30.350 --> 23:31.350
设置为多少呢

23:31.350 --> 23:32.350
你说要告诉他

23:32.350 --> 23:34.350
我们之前增加和减少

23:34.350 --> 23:36.350
都是增1加1和减1

23:36.350 --> 23:37.350
所以说你不用告诉他具体的数据

23:37.350 --> 23:38.350
那么你设置的时候

23:38.350 --> 23:39.350
说要告诉他

23:39.350 --> 23:40.350
要设置为几

23:40.350 --> 23:42.350
那么是不是要加一个附加数据

23:42.350 --> 23:43.350
附加数据

23:43.350 --> 23:44.350
通常我们是用payload的

23:44.350 --> 23:45.350
但是不是一定的

23:45.350 --> 23:46.350
他没有严格要求这一块

23:46.350 --> 23:48.350
这一块他没有严格

23:48.350 --> 23:49.350
规定

23:49.350 --> 23:50.350
但是我们通常情况下

23:50.350 --> 23:51.350
我们这里

23:52.350 --> 23:53.350
这里记笔

23:54.350 --> 23:55.350
就是

23:56.350 --> 23:57.350
通常

23:58.350 --> 24:01.350
使用payload的属性

24:01.350 --> 24:03.350
表示附加数据

24:05.350 --> 24:07.350
没有做强制要求

24:07.350 --> 24:09.350
没有强制要求

24:10.350 --> 24:11.350
没有强制要求

24:11.350 --> 24:12.350
只不过我们通常情况下

24:12.350 --> 24:14.350
用payload的这个数据

24:14.350 --> 24:15.350
来当作是附加数据

24:15.350 --> 24:16.350
那payload的

24:16.350 --> 24:17.350
我们到时候就会写这个

24:17.350 --> 24:19.350
比方说写一个3

24:19.350 --> 24:21.350
把这个数据变为3

24:21.350 --> 24:22.350
那么这个x就是这个样子

24:22.350 --> 24:23.350
我要设置数据

24:23.350 --> 24:25.350
把他的数据变为3

24:25.350 --> 24:26.350
那么这个reduce

24:26.350 --> 24:27.350
拿到这个x

24:27.350 --> 24:28.350
之后怎么操作呢

24:28.350 --> 24:30.350
我发现他的类型是设置数据

24:30.350 --> 24:31.350
我这里要反回什么

24:31.350 --> 24:32.350
来告诉我反回什么

24:33.350 --> 24:34.350
这种做法其实很简洁的

24:34.350 --> 24:35.350
只是有些同学呢

24:35.350 --> 24:36.350
不太适应而已

24:36.350 --> 24:37.350
所以说

24:37.350 --> 24:38.350
上去后我要要求你们

24:38.350 --> 24:40.350
一定要自己去写一下

24:40.350 --> 24:41.350
反回什么

24:41.350 --> 24:43.350
是反回x的payload

24:43.350 --> 24:44.350
对吧

24:45.350 --> 24:46.350
payload

24:46.350 --> 24:47.350
对不对

24:47.350 --> 24:48.350
反回这个东西

24:49.350 --> 24:50.350
payload表示的是

24:50.350 --> 24:52.350
附件附加的意思

24:52.350 --> 24:53.350
附赞

24:53.350 --> 24:54.350
好

24:54.350 --> 24:55.350
那么这里就是

24:55.350 --> 24:56.350
如果像多那种类型

24:56.350 --> 24:57.350
多了一种操作类型

24:57.350 --> 24:58.350
就是set

24:58.350 --> 25:00.350
那么反回的是一个payload的

25:00.350 --> 25:01.350
你要设置成什么

25:01.350 --> 25:02.350
你给我就行了

25:03.350 --> 25:04.350
好

25:04.350 --> 25:05.350
那么现在我们触发x

25:05.350 --> 25:06.350
的时候

25:06.350 --> 25:07.350
如果说我要得到这么一个x

25:07.350 --> 25:08.350
我是不是

25:08.350 --> 25:09.350
也可以去写一个x

25:09.350 --> 25:10.350
创建函数

25:10.350 --> 25:11.350
对吧

25:11.350 --> 25:12.350
我们又来写一个函数

25:12.350 --> 25:15.350
给他叫做getsetx

25:16.350 --> 25:17.350
写这么一个函数

25:17.350 --> 25:18.350
那么这个函数里边

25:18.350 --> 25:19.350
我们要反回啥

25:19.350 --> 25:20.350
所以反回

25:20.350 --> 25:21.350
刚才那个格式

25:21.350 --> 25:22.350
类型是什么

25:22.350 --> 25:23.350
actionTaps.set

25:23.350 --> 25:24.350
对吧

25:24.350 --> 25:25.350
这个类型

25:25.350 --> 25:26.350
好

25:26.350 --> 25:27.350
是不是现在一个payload了

25:27.350 --> 25:28.350
对吧

25:28.350 --> 25:29.350
payload

25:29.350 --> 25:30.350
一个附加数据

25:30.350 --> 25:31.350
那么附加数据是多少呢

25:31.350 --> 25:32.350
我要把数字

25:32.350 --> 25:33.350
数字改变为多少呢

25:33.350 --> 25:34.350
是不知道

25:34.350 --> 25:36.350
那不知道是不是要传参数

25:36.350 --> 25:37.350
对吧

25:37.350 --> 25:38.350
new number

25:38.350 --> 25:40.350
给我一个新的数字

25:40.350 --> 25:41.350
我把那个新的数字

25:41.350 --> 25:43.350
用一种标准的action格式

25:43.350 --> 25:44.350
反回

25:44.350 --> 25:45.350
那么这样子

25:45.350 --> 25:46.350
外面使用者

25:46.350 --> 25:47.350
他就不用关心

25:47.350 --> 25:48.350
这个标准的action格式

25:48.350 --> 25:49.350
这样子的

25:49.350 --> 25:50.350
不用关心这些东西了

25:50.350 --> 25:52.350
我们直接使用action创建函数

25:52.350 --> 25:53.350
就可以得到这么一个action

25:53.350 --> 25:54.350
对啊

25:54.350 --> 25:55.350
action创建函数

25:55.350 --> 25:56.350
是非常非常简单的

25:56.350 --> 25:57.350
非常非常简洁

25:57.350 --> 25:58.350
看到没

25:59.350 --> 26:00.350
好

26:00.350 --> 26:01.350
那么这里呢

26:01.350 --> 26:02.350
外面的使用者

26:02.350 --> 26:03.350
当然你不是说

26:03.350 --> 26:04.350
一定要用action创建函数

26:04.350 --> 26:05.350
你可以不用的

26:05.350 --> 26:06.350
现在多了一个函数了

26:06.350 --> 26:07.350
我们就可以使用

26:07.350 --> 26:09.350
getsetaction

26:09.350 --> 26:10.350
比较说

26:10.350 --> 26:11.350
我要把数字设为3

26:11.350 --> 26:13.350
那么传一个参数3进去

26:13.350 --> 26:14.350
他是不是给我

26:14.350 --> 26:16.350
反回了一个标准格式的action

26:16.350 --> 26:17.350
那么我这里

26:17.350 --> 26:18.350
12

26:18.350 --> 26:19.350
那么他就分发出去了

26:19.350 --> 26:20.350
然后最终

26:20.350 --> 26:21.350
让Reduce

26:21.350 --> 26:22.350
完成数据的变化

26:22.350 --> 26:23.350
保存

26:23.350 --> 26:24.350
看一下

26:25.350 --> 26:26.350
这10变成了3

26:26.350 --> 26:27.350
对吧

26:28.350 --> 26:29.350
这就是

26:29.350 --> 26:30.350
埃克形的

26:32.350 --> 26:33.350
埃克形的创建函数

26:34.350 --> 26:35.350
那写到这的话

26:35.350 --> 26:36.350
有些同学肯定想问

26:36.350 --> 26:37.350
你干嘛

26:37.350 --> 26:38.350
你在

26:38.350 --> 26:40.350
绕了这么一大一圈

26:40.350 --> 26:41.350
本来以前

26:41.350 --> 26:43.350
很开开心心的改数据的

26:43.350 --> 26:44.350
就一个数据

26:44.350 --> 26:45.350
不要说Number

26:45.350 --> 26:46.350
就一个对象点

26:46.350 --> 26:47.350
就完了

26:47.350 --> 26:48.350
你要干嘛

26:48.350 --> 26:49.350
怎么成这样子的

26:49.350 --> 26:51.350
人都快崩溃掉了

26:51.350 --> 26:52.350
原因是因为

26:52.350 --> 26:54.350
这个东西是来解决

26:54.350 --> 26:56.350
大中型项目的

26:56.350 --> 26:58.350
大中型项目里边

26:58.350 --> 26:59.350
大中型项目里边

26:59.350 --> 27:01.350
就是它的那个

27:01.350 --> 27:02.350
共享数据

27:02.350 --> 27:04.350
很多很复杂

27:04.350 --> 27:05.350
你如果不用这种方式

27:05.350 --> 27:06.350
就会出现我

27:06.350 --> 27:07.350
第一节课

27:07.350 --> 27:08.350
本张第一节课

27:08.350 --> 27:09.350
讲了各种各样的问题

27:09.350 --> 27:10.350
所以说

27:10.350 --> 27:12.350
你在简单的项目里面

27:12.350 --> 27:13.350
当然是看不出

27:13.350 --> 27:14.350
它的优势了

27:15.350 --> 27:16.350
你要把它放到大型项目里边做

27:16.350 --> 27:17.350
但是

27:17.350 --> 27:19.350
目前你又没有做大型项目

27:19.350 --> 27:20.350
问题就在这

27:20.350 --> 27:22.350
学习现在老火就在这

27:22.350 --> 27:24.350
那你只能

27:24.350 --> 27:25.350
放平心态

27:25.350 --> 27:26.350
接受它

27:26.350 --> 27:28.350
接受这种方式

27:28.350 --> 27:29.350
接受这种方式

27:29.350 --> 27:30.350
那你要去理解的话

27:30.350 --> 27:32.350
就再多看几遍我第一节课

27:32.350 --> 27:33.350
第一节课

27:33.350 --> 27:34.350
我花了一个多小时

27:34.350 --> 27:35.350
就讲这个东西

27:35.350 --> 27:36.350
希望你们能多多少少

27:36.350 --> 27:37.350
有点感觉

27:39.350 --> 27:41.350
好 那么现在

27:41.350 --> 27:42.350
就完成了一整套

27:42.350 --> 27:43.350
这么一种结构了

27:43.350 --> 27:44.350
对吧

27:44.350 --> 27:45.350
这是关于

27:45.350 --> 27:47.350
X型的创建函数

27:48.350 --> 27:49.350
对

27:49.350 --> 27:50.350
X型的创建函数

27:50.350 --> 27:52.350
我把英文给大家说一下

27:52.350 --> 27:53.350
X型的创建函数

27:53.350 --> 27:54.350
我们把它叫做

27:54.350 --> 27:55.350
X型

27:55.350 --> 27:56.350
creator

27:57.350 --> 27:59.350
就是在创建一个X型的函数

28:00.350 --> 28:01.350
X型的创建函数

28:01.350 --> 28:02.350
大家注意就是

28:02.350 --> 28:03.350
至少目前

28:03.350 --> 28:05.350
这个函数必须是一个存成函数

28:05.350 --> 28:06.350
五副作用的存成函数

28:06.350 --> 28:07.350
以后有特殊情况

28:07.350 --> 28:08.350
我们会再继续说

28:09.350 --> 28:10.350
好 下一个点

28:12.350 --> 28:13.350
为了方便

28:14.350 --> 28:16.350
为了方便就是触发X型

28:16.350 --> 28:17.350
就是分发X型

28:18.350 --> 28:19.350
分发X型

28:19.350 --> 28:20.350
也叫做触发X型

28:21.350 --> 28:22.350
触发一个动作

28:22.350 --> 28:23.350
X型就是动作

28:23.350 --> 28:24.350
触发

28:26.350 --> 28:27.350
X型

28:27.350 --> 28:28.350
触发X型怎么写的

28:28.350 --> 28:29.350
看一下这里

28:29.350 --> 28:30.350
是这样写的

28:30.350 --> 28:31.350
为了方便

28:31.350 --> 28:32.350
应该这样说

28:32.350 --> 28:33.350
为了方便利用

28:34.350 --> 28:35.350
X型

28:38.350 --> 28:39.350
创建函数

28:40.350 --> 28:41.350
来分发X型

28:42.350 --> 28:43.350
就是我们

28:43.350 --> 28:44.350
一看这里是不是利用

28:44.350 --> 28:45.350
X型创建函数

28:45.350 --> 28:46.350
来分发X型的

28:46.350 --> 28:47.350
对吧

28:47.350 --> 28:48.350
因为X型创建函数

28:48.350 --> 28:50.350
是一种Redux官方

28:50.350 --> 28:52.350
它就是建议的一种模式

28:52.350 --> 28:54.350
它不是必须要求你这样写

28:54.350 --> 28:56.350
它是它的一种建议模式

28:57.350 --> 28:58.350
那么如果为了方便来

28:58.350 --> 29:00.350
用X型来创建函数

29:00.350 --> 29:01.350
来分发X型的话

29:01.350 --> 29:02.350
那么

29:03.350 --> 29:04.350
Redux

29:05.350 --> 29:07.350
提供了一个函数

29:07.350 --> 29:08.350
叫做

29:09.350 --> 29:10.350
什么函数呢

29:10.350 --> 29:11.350
叫做Band

29:11.350 --> 29:12.350
X型

29:12.350 --> 29:13.350
Creator

29:15.350 --> 29:16.350
这么一个函数

29:17.350 --> 29:18.350
那么这个函数怎么用呢

29:18.350 --> 29:19.350
我们来看一下

29:21.350 --> 29:22.350
这里导入

29:22.350 --> 29:23.350
在上面导入

29:24.350 --> 29:25.350
Redux里面提供了一个函数

29:25.350 --> 29:26.350
叫做Creator

29:29.350 --> 29:30.350
叫做Band

29:30.350 --> 29:31.350
X型Creators

29:31.350 --> 29:32.350
这个函数

29:32.350 --> 29:33.350
我这里少写个S

29:34.350 --> 29:35.350
少写个S

29:35.350 --> 29:36.350
再复制一下吧

29:37.350 --> 29:38.350
它提供了这么一个函数

29:38.350 --> 29:39.350
这个函数怎么用呢

29:39.350 --> 29:40.350
你看着

29:40.350 --> 29:41.350
这个函数是这样子

29:41.350 --> 29:42.350
我们现在呢

29:42.350 --> 29:44.350
不是导入了很多的X型吧

29:44.350 --> 29:45.350
对吧

29:45.350 --> 29:46.350
X型创建函数

29:46.350 --> 29:47.350
对不对

29:47.350 --> 29:48.350
那么现在呢

29:48.350 --> 29:49.350
我们调用一下Band

29:49.350 --> 29:50.350
X型Creators

29:50.350 --> 29:51.350
把这个

29:52.350 --> 29:54.350
把这个就是

29:54.350 --> 29:55.350
Lumber

29:55.350 --> 29:56.350
X型是传进去

29:56.350 --> 29:57.350
把Lumber

29:57.350 --> 29:58.350
X型是传进去

29:58.350 --> 29:59.350
再传一个什么呢

29:59.350 --> 30:00.350
再传一个就是

30:01.350 --> 30:02.350
Dispatch

30:02.350 --> 30:03.350
我们放到这

30:04.350 --> 30:05.350
你们放到温度里边了

30:05.350 --> 30:06.350
把温度去了嘛

30:07.350 --> 30:13.310
去了

30:14.310 --> 30:15.310
这里边的第二个函数

30:15.310 --> 30:17.310
再传一个Dispatch

30:17.310 --> 30:18.310
Dispatch

30:18.310 --> 30:19.310
我们这里说一下

30:20.310 --> 30:21.310
这是用来干嘛的

30:21.310 --> 30:22.310
就是

30:22.310 --> 30:24.310
将Dispatch

30:26.310 --> 30:27.310
第一个参数

30:28.310 --> 30:29.310
第一个参数

30:29.310 --> 30:30.310
第一个参数

30:31.310 --> 30:32.310
是X型

30:34.310 --> 30:36.310
创建函数

30:37.310 --> 30:38.310
是X型

30:38.310 --> 30:39.310
创建函数

30:39.310 --> 30:41.310
合并的对象

30:41.310 --> 30:42.310
合并的对象

30:42.310 --> 30:43.310
就是通过这个

30:43.310 --> 30:44.310
你看看我们这里

30:44.310 --> 30:45.310
是不是导出了很多的

30:45.310 --> 30:46.310
X型创建函数

30:46.310 --> 30:48.310
那么可以把它合并成对象

30:48.310 --> 30:49.310
当然你这里也可以

30:49.310 --> 30:50.310
用这种方式来合并

30:50.310 --> 30:52.310
Dispatch

30:52.310 --> 30:53.310
导出一个对象

30:53.310 --> 30:54.310
这个对象里边

30:54.310 --> 30:55.310
有很多函数

30:55.310 --> 30:56.310
第一个函数是这个

30:56.310 --> 30:57.310
第一个函数是这个

30:57.310 --> 30:58.310
方可形

30:58.310 --> 30:59.310
或者是用这种协放

30:59.310 --> 31:00.310
都可以

31:01.310 --> 31:03.310
第二个函数是这个

31:03.310 --> 31:04.310
导出X型创建函数

31:04.310 --> 31:06.310
总之你把它合并成一个对象

31:06.310 --> 31:07.310
那么这里默认导出的话

31:07.310 --> 31:09.310
那边就是默认导入

31:09.310 --> 31:10.310
总之你把合并成对象

31:10.310 --> 31:11.310
就完事了

31:11.310 --> 31:12.310
那么这里就是

31:12.310 --> 31:13.310
已经把它

31:13.310 --> 31:14.310
用这种方式

31:14.310 --> 31:15.310
把它

31:15.310 --> 31:16.310
你可以把它理解为

31:16.310 --> 31:17.310
合并成对象了

31:17.310 --> 31:19.310
那么你把它合并成对象之后

31:19.310 --> 31:20.310
那么作为

31:20.310 --> 31:22.310
第一个函数传讯

31:22.310 --> 31:23.310
第二个参数

31:23.310 --> 31:24.310
第二个参数

31:24.310 --> 31:26.310
是Dispatch

31:26.310 --> 31:28.310
是仓库的Dispatch函数

31:28.310 --> 31:29.310
是

31:32.880 --> 31:35.880
仓库的Dispatch函数

31:36.880 --> 31:37.880
那么这样子一来

31:37.880 --> 31:40.880
它会得到一个新的对象

31:40.880 --> 31:41.880
得到一个新的对象

31:42.880 --> 31:45.880
新对象中的属性名

31:45.880 --> 31:47.880
与

31:47.880 --> 31:49.880
X型创建函数合并的对象

31:49.880 --> 31:51.880
与合并对象

31:51.880 --> 31:55.880
与第一个参数的属性名一致

31:56.880 --> 31:57.880
它是完全一致的

31:57.880 --> 31:58.880
与第一个参数的属性名

31:58.880 --> 31:59.880
是完全一致的

31:59.880 --> 32:00.880
那么比方说

32:00.880 --> 32:02.880
我们这里得到这么一个

32:02.880 --> 32:03.880
得到这么一个对象

32:03.880 --> 32:04.880
Bound

32:04.880 --> 32:05.880
X型

32:05.880 --> 32:06.880
好

32:06.880 --> 32:07.880
咱们看一下

32:07.880 --> 32:08.880
看一下

32:08.880 --> 32:09.880
下面几句太满了

32:09.880 --> 32:10.880
先注释掉

32:10.880 --> 32:15.880
输出一下Bound

32:15.880 --> 32:16.880
X型

32:16.880 --> 32:18.880
就是已经绑定完了的X型

32:18.880 --> 32:20.880
已经绑定完了的X型

32:20.880 --> 32:21.880
看一下是什么

32:21.880 --> 32:23.880
你看一下对象里边

32:23.880 --> 32:24.880
这个属性

32:24.880 --> 32:25.880
跟那个

32:25.880 --> 32:26.880
我们再把那个打印出来

32:26.880 --> 32:30.880
再把那个就是LumberX型

32:30.880 --> 32:31.880
打印出来

32:31.880 --> 32:32.880
看一下

32:34.880 --> 32:36.880
那么你看跟这个对象里边的

32:36.880 --> 32:37.880
属性是不是一样的

32:37.880 --> 32:38.880
对吧

32:38.880 --> 32:39.880
是不是一样的

32:39.880 --> 32:40.880
三个属性

32:40.880 --> 32:41.880
每个属性是韩数

32:41.880 --> 32:42.880
对吧

32:42.880 --> 32:43.880
通过模块

32:43.880 --> 32:44.880
导入的

32:44.880 --> 32:45.880
那么这里得到新的对象里边

32:45.880 --> 32:46.880
所以也有这三个属性

32:46.880 --> 32:47.880
对不对

32:47.880 --> 32:48.880
也有这三个属性

32:48.880 --> 32:49.880
那么这个三个属性

32:49.880 --> 32:50.880
看上去

32:50.880 --> 32:53.880
好像没差区别

32:54.880 --> 32:57.880
实际上这些韩数是不一样的

32:57.880 --> 32:58.880
怎么个不一样的法呢

32:58.880 --> 32:59.880
我们看着

32:59.880 --> 33:00.880
那么之后

33:00.880 --> 33:02.880
我们触发数据变化

33:02.880 --> 33:03.880
我们分发X型的时候

33:03.880 --> 33:06.880
就可以不用这种方式来分发了

33:06.880 --> 33:08.880
可以不用这种方式来分发了

33:08.880 --> 33:10.880
如果你把Dispatch传进去过后

33:10.880 --> 33:12.880
你只要调用这个韩数里边的对应方法

33:12.880 --> 33:14.880
它就会自动帮你分发X型

33:14.880 --> 33:15.880
帮你的X型是

33:15.880 --> 33:16.880
第二

33:16.880 --> 33:21.880
比方说GetIncreaseX型

33:21.880 --> 33:25.880
那么这句话就表示

33:25.880 --> 33:28.880
得到一个

33:28.880 --> 33:33.880
IncreaseX型

33:33.880 --> 33:35.880
并直接出

33:35.880 --> 33:36.880
直接分发

33:36.880 --> 33:38.880
它会自动帮你分发

33:38.880 --> 33:40.880
保存你看一下

33:40.880 --> 33:41.880
是不是十十一

33:41.880 --> 33:42.880
对吧

33:42.880 --> 33:44.880
我们并没有使用Store.Dispatch

33:44.880 --> 33:45.880
为什么它帮你做到这些

33:45.880 --> 33:46.880
那么这样子

33:46.880 --> 33:49.880
你使用起来是不是要简洁一些

33:49.880 --> 33:50.880
是不是要简洁一些

33:50.880 --> 33:51.880
丢起这么一个作用

33:51.880 --> 33:52.880
那么之前

33:52.880 --> 33:55.880
我们得用Store.Dispatch来进行分发

33:55.880 --> 33:56.880
那么现在呢

33:56.880 --> 33:57.880
由于你把Dispatch给它了

33:57.880 --> 33:58.880
那么你把X型的

33:58.880 --> 34:00.880
创建韩数里那些东西也给它了

34:00.880 --> 34:02.880
那么你可以直接调用这个玩意

34:02.880 --> 34:03.880
来完成分发

34:03.880 --> 34:04.880
应该的意思吧

34:04.880 --> 34:05.880
那么比方说

34:05.880 --> 34:06.880
我们再来一个

34:06.880 --> 34:07.880
再来一个

34:07.880 --> 34:08.880
Bound

34:08.880 --> 34:10.880
X型是Set

34:12.880 --> 34:15.700
好了

34:15.700 --> 34:18.700
GetSetX型

34:18.700 --> 34:19.700
那么这里要传一个参数

34:19.700 --> 34:20.700
传一个3

34:20.700 --> 34:21.700
比方说传一个3

34:21.700 --> 34:22.700
那么这里也是一样

34:22.700 --> 34:24.700
它得到这个X型之后

34:24.700 --> 34:26.700
会自动帮你分发

34:26.700 --> 34:27.700
它对这些韩数

34:27.700 --> 34:28.700
有所改动

34:28.700 --> 34:29.700
保存

34:29.700 --> 34:30.700
我们看一下

34:30.700 --> 34:31.700
这边的3

34:31.700 --> 34:32.700
这样子以后

34:32.700 --> 34:33.700
我们调用起来

34:33.700 --> 34:34.700
就更加简洁一点

34:34.700 --> 34:36.700
没有必要去使用Dispatch了

34:36.700 --> 34:37.700
就这么个意思

34:37.700 --> 34:38.700
其他都没啥了

34:38.700 --> 34:39.700
这就是

34:39.700 --> 34:41.700
X型绑定韩数

34:41.700 --> 34:43.700
X型绑定韩数

34:43.700 --> 34:44.700
该韩数

34:44.700 --> 34:45.700
该韩数

34:45.700 --> 34:48.700
用于将

34:48.700 --> 34:50.700
用于

34:50.700 --> 34:51.700
改动

34:51.700 --> 34:52.700
用于增强

34:52.700 --> 34:53.700
X型

34:53.700 --> 34:54.700
创建

34:54.700 --> 34:57.700
韩数的功能

34:57.700 --> 35:00.700
不使它

35:00.700 --> 35:01.700
使它

35:01.700 --> 35:03.700
不仅

35:03.700 --> 35:04.700
创建

35:04.700 --> 35:05.700
X型

35:05.700 --> 35:06.700
并且

35:06.700 --> 35:07.700
可以

35:07.700 --> 35:09.700
自动完成分发

35:09.700 --> 35:11.700
并且创建后

35:11.700 --> 35:14.700
会自动完成分发

35:14.700 --> 35:15.700
就起这么一个作用

35:15.700 --> 35:16.700
那么具体

35:16.700 --> 35:17.700
大家可以

35:17.700 --> 35:18.700
参与这个样的代码

35:18.700 --> 35:19.700
你明白了

35:19.700 --> 35:20.700
一看就明白了

35:20.700 --> 35:21.700
就是我们不再使用

35:21.700 --> 35:22.700
使用Dispatch了

35:22.700 --> 35:23.700
直接调用这个X型

35:23.700 --> 35:25.700
那么得到X型之后

35:25.700 --> 35:26.700
那么

35:26.700 --> 35:27.700
它就

35:27.700 --> 35:30.700
触发了这个X型

35:30.700 --> 35:31.700
当这个X型创建韩数

35:31.700 --> 35:32.700
它的命名

35:32.700 --> 35:33.700
不同的公司

35:33.700 --> 35:34.700
有不同的命名方式

35:34.700 --> 35:35.700
比如这里

35:35.700 --> 35:36.700
我使用的是Gate

35:36.700 --> 35:37.700
那也有可能

35:37.700 --> 35:38.700
今后你使用的是

35:38.700 --> 35:39.700
Creator

35:39.700 --> 35:40.700
Creator什么X型

35:40.700 --> 35:41.700
都有可能

35:41.700 --> 35:42.700
都有可能

35:42.700 --> 35:43.700
不同的公司

35:43.700 --> 35:44.700
你看一下

35:44.700 --> 35:45.700
具体的风格

35:45.700 --> 35:46.700
具体的风格

35:46.700 --> 35:47.700
Creator

35:47.700 --> 35:49.700
Gate都行

35:49.700 --> 35:50.700
都是关于

35:50.700 --> 35:51.700
X型

35:51.700 --> 35:52.700
X型这一块

35:52.700 --> 35:53.700
全部讲完了

35:53.700 --> 35:54.700
没了

35:54.700 --> 35:55.700
没有其他东西了

35:55.700 --> 35:56.700
X型是很简单的

35:56.700 --> 35:58.700
那么大家

35:58.700 --> 35:59.700
把这个过程

35:59.700 --> 36:00.700
梳理一下

36:00.700 --> 36:02.700
然后一定要自己去写一次

36:02.700 --> 36:03.700
因为当时这里

36:03.700 --> 36:04.700
别看着简单

36:04.700 --> 36:05.700
一定要自己去写一次

36:05.700 --> 36:06.700
这样子

36:06.700 --> 36:07.700
大家才有这个感觉

36:07.700 --> 36:08.700
那么后边讲起来

36:08.700 --> 36:09.700
讲Reduce的时候

36:09.700 --> 36:10.700
才不会自由

36:10.700 --> 36:11.700
不自由抹身

36:11.700 --> 36:12.700
因为Reduce那一块

36:12.700 --> 36:13.700
是有一点难度的

36:13.700 --> 36:14.700
是有点绕的

36:15.700 --> 36:16.700
这是关于这个X型这一块

36:16.700 --> 36:18.700
所有的知识就这么一些

