WEBVTT

00:00.560 --> 00:13.560
这一部分的知识 这一部分的知识 它可能会出现在各种面试体里面

00:13.560 --> 00:18.560
也可能会在你做rex开发的时候 遇到一些坑

00:18.560 --> 00:24.560
所以说我们单独拿一些课来讲一讲 这一块就是set data这一边的一些坑

00:24.560 --> 00:27.560
以及它遇到一些面试体的时候 你该怎么去处理

00:27.560 --> 00:31.560
这是怎么回事呢 我们来写个例子 写个例子你就明白了

00:31.560 --> 00:37.560
比方说我们这里来做一个组件 这个组件的名字 随便吧

00:37.560 --> 00:41.560
就compp吧 就随便写个组件

00:41.560 --> 00:45.560
一个内组件 因为它有状态嘛 对吧

00:45.560 --> 00:47.560
我们这里就可能是设计到状态的东西

00:47.560 --> 00:52.560
它有这么一个状态 叫做set state

00:53.560 --> 00:56.560
状态 我今天脑袋怎么回事呢

00:56.560 --> 00:59.560
我感觉这头发越来越大了

00:59.560 --> 01:06.560
状态里边有个数字n 是一个0

01:06.560 --> 01:10.560
然后这里边写了一个he元数

01:10.560 --> 01:15.560
he元数来显示这个n 显示个n 这个很简单 对吧

01:15.560 --> 01:17.560
然后下面有个n流

01:17.560 --> 01:22.560
当我们点击n流的时候 我要改变这个n的值

01:22.560 --> 01:24.560
咱们来看一下吧

01:24.560 --> 01:26.560
这个handle click

01:26.560 --> 01:30.940
我们写这么一个函数 来改变这个n的值

01:30.940 --> 01:33.940
所以这个n流的unclick时间

01:33.940 --> 01:37.940
给它复制为this handle click

01:37.940 --> 01:40.940
这个没问题吧 一个非常非常简单的组件

01:40.940 --> 01:44.940
然后点击之后 这个n流里边有个java

01:45.940 --> 01:48.940
点击这个n流干嘛呢 我就把这个n加1

01:48.940 --> 01:51.940
把这个n加1 咱们来啊

01:51.940 --> 01:55.940
这些kn我们写的东西 可能没有什么实际的意义

01:55.940 --> 01:58.940
但是以后我们写代码的时候

01:58.940 --> 02:01.940
如果不注意的话 可能会遇到一些kn

02:01.940 --> 02:04.940
把这个n重新复制 复制为啥呢

02:05.940 --> 02:10.940
n加1

02:10.940 --> 02:14.940
保存一下 这边我们把这个组件引用进来

02:14.940 --> 02:16.940
import

02:16.940 --> 02:20.940
组件的路径就是点鞋杠

02:20.940 --> 02:22.940
comp

02:22.940 --> 02:24.940
组件的名字就是comp

02:24.940 --> 02:26.940
这里能把这个组件引用进来

02:26.940 --> 02:30.310
鞋杠

02:33.710 --> 02:37.710
好 咱们呢 把它运行出来

02:37.710 --> 02:42.710
一二 因为我看一下目前的分支对不对

02:42.710 --> 02:44.710
分支对的 没问题

02:44.710 --> 02:46.710
把运行出来

02:46.710 --> 02:48.710
一二start

02:48.710 --> 02:50.710
start

02:50.710 --> 02:53.710
有的时候自打快的也挺烦的

02:53.710 --> 02:55.710
真的是一浪砸错

02:55.710 --> 02:58.710
好 运行出来

02:58.710 --> 03:00.710
换了其他的

03:00.710 --> 03:02.710
换了其他的

03:02.710 --> 03:04.710
好 看着

03:04.710 --> 03:07.710
目前也没有什么坑

03:07.710 --> 03:10.710
目前是看不出来有什么样的坑的

03:10.710 --> 03:12.710
这样子

03:12.710 --> 03:14.710
好 这里点击

03:14.710 --> 03:15.710
没有什么问题 对吧

03:15.710 --> 03:16.710
没有什么问题

03:16.710 --> 03:18.710
好 接下来坑在哪呢

03:18.710 --> 03:20.710
坑在这

03:20.710 --> 03:22.710
好 我们看一下吧

03:22.710 --> 03:25.710
我们改变了这个状态之后

03:25.710 --> 03:27.710
它肯定要导致重新渲染 对吧

03:27.710 --> 03:28.710
重新渲染

03:28.710 --> 03:32.710
我们在这里面去输出N的值

03:32.710 --> 03:34.710
start

03:34.710 --> 03:36.710
N的值 我们来看输出什么

03:36.710 --> 03:38.710
那么按照这样的以前的理论的话

03:38.710 --> 03:40.710
应该会输出什么呢

03:40.710 --> 03:42.710
第一次点击 它加了1了 对吧

03:42.710 --> 03:44.710
重新给它复制 加了1了

03:44.710 --> 03:46.710
这里是不是要输出1 对吧

03:46.710 --> 03:48.710
那咱们来看一下吧

03:48.710 --> 03:50.710
第一次点击 它应该输出1才对

03:50.710 --> 03:52.710
点击 结果它输出了0

03:52.710 --> 03:55.710
结果接面变成了1了

03:55.710 --> 03:57.710
然后再点击 应该输出2才对

03:57.710 --> 03:59.710
那么结果它变成了1

03:59.710 --> 04:01.710
见面变成了2了

04:01.710 --> 04:03.710
这怎么回事呢 咋回事了

04:03.710 --> 04:05.710
好 咱们再来看一下

04:05.710 --> 04:07.710
Render是不是重新渲染的函数

04:07.710 --> 04:10.710
我们这里呢 给它输出一个东西

04:10.710 --> 04:12.710
就是Render

04:12.710 --> 04:14.710
表示我们这里重新渲染了

04:14.710 --> 04:16.710
我们来看一下这两句代码

04:16.710 --> 04:18.710
谁在前 谁在后

04:18.710 --> 04:20.710
好 保存

04:20.710 --> 04:21.710
我们第一次点

04:21.710 --> 04:23.710
第一次一开始肯定要Render一次 对吧

04:23.710 --> 04:25.710
一开始肯定要渲染一次

04:25.710 --> 04:27.710
然后我们点击一下的时候

04:27.710 --> 04:29.710
它肯定要重新渲染

04:29.710 --> 04:31.710
但是我们这一句代码是写在

04:31.710 --> 04:33.710
改变了状态之后的

04:33.710 --> 04:34.710
改变了状态之后

04:34.710 --> 04:36.710
我们输出了这么一句话

04:36.710 --> 04:39.710
按理说 应该是这个东西输出在前

04:39.710 --> 04:41.710
Render输出在后

04:41.710 --> 04:43.710
但是我们看一下

04:43.710 --> 04:45.710
点击

04:45.710 --> 04:47.710
你看到 我们这个东西

04:47.710 --> 04:49.710
确实它输出在前

04:49.710 --> 04:52.710
Render确实输出在后

04:52.710 --> 04:55.710
但是为什么又会出现这种情况

04:55.710 --> 04:57.710
为什么会得到的是零呢

04:57.710 --> 05:00.710
这就很奇怪了

05:00.710 --> 05:02.710
这怎么回事呢

05:02.710 --> 05:04.710
实际上是这样子

05:04.710 --> 05:06.710
这里边有一个关键点在于什么

05:06.710 --> 05:08.710
在于这个Set

05:08.710 --> 05:11.710
SetState

05:11.710 --> 05:15.710
它对状态

05:15.710 --> 05:16.710
它是用来干嘛的

05:16.710 --> 05:18.710
它是用来改变状态的 对吧

05:18.710 --> 05:23.050
它对状态的改变

05:23.050 --> 05:26.050
可能是异步的

05:26.050 --> 05:27.050
可能是异步的

05:27.050 --> 05:29.050
我们要清楚的知道

05:29.050 --> 05:33.050
只有状态真实的发生了改变之后

05:33.050 --> 05:36.050
才会触发这个Render

05:36.050 --> 05:38.050
不是说你一调用这个SetState

05:38.050 --> 05:39.050
它就会触发Render

05:39.050 --> 05:41.050
当然它一定会触发

05:41.050 --> 05:42.050
将来它一定

05:42.050 --> 05:43.050
将来的某一个时间点

05:43.050 --> 05:44.050
它一定会触发

05:44.050 --> 05:46.050
但是它不一定是马上触发

05:46.050 --> 05:49.050
如果是马上触发的话

05:49.050 --> 05:51.050
如果是马上触发的话

05:51.050 --> 05:53.050
它还先输出Render

05:53.050 --> 05:54.050
先渲染

05:54.050 --> 05:56.050
如果说这个东西马上触发

05:56.050 --> 05:57.050
它是不是该先渲染

05:57.050 --> 05:58.050
再运行这句话

05:58.050 --> 05:59.050
对吧

05:59.050 --> 06:00.050
因为这个SetState

06:00.050 --> 06:01.050
相当于是在这里

06:01.050 --> 06:02.050
这个函数里边

06:02.050 --> 06:03.050
它调用了一次Render

06:03.050 --> 06:05.050
那么应该是先输出Render

06:05.050 --> 06:06.050
再输出这个东西

06:06.050 --> 06:07.050
那么结果呢

06:07.050 --> 06:09.050
我们是先输出了这个东西

06:09.050 --> 06:10.050
再输出了Render

06:10.050 --> 06:11.050
说明了啥呢

06:11.050 --> 06:13.050
说明了我们当我们运行

06:13.050 --> 06:15.050
第14行的时候

06:15.050 --> 06:17.050
这个时候还没有

06:17.050 --> 06:20.050
还没有重新渲染

06:20.050 --> 06:21.050
对吧

06:21.050 --> 06:22.050
还没有重新渲染

06:22.050 --> 06:23.050
说明了啥

06:23.050 --> 06:26.050
说明了这个SetState

06:26.050 --> 06:27.050
它对状态的改变

06:27.050 --> 06:28.050
可能是异步的

06:28.050 --> 06:30.050
只要状态一发生改变

06:30.050 --> 06:32.050
它一定会重新渲染

06:32.050 --> 06:34.050
一定马上会重新渲染

06:34.050 --> 06:36.050
但是现在还没有重新渲染

06:36.050 --> 06:37.050
说明啥

06:37.050 --> 06:44.360
说明目前状态仍然没有改变

06:44.360 --> 06:45.360
这就是为什么

06:45.360 --> 06:48.360
我这里得到了仍然是零的原因

06:48.360 --> 06:50.360
如果你看

06:50.360 --> 06:52.360
现在是零

06:52.360 --> 06:53.360
我们点了一下

06:53.360 --> 06:55.360
如果是不是异步的

06:55.360 --> 06:57.360
那么是不是马上改变状态

06:57.360 --> 06:58.360
按理说的话

06:58.360 --> 07:00.360
马上改变状态

07:00.360 --> 07:02.360
马上触发Render

07:02.360 --> 07:04.360
是不是应该先输出Render

07:04.360 --> 07:06.360
再输出这个东西

07:06.360 --> 07:07.360
马上改变状态

07:07.360 --> 07:08.360
这个函数里面

07:08.360 --> 07:09.360
它就会触发

07:09.360 --> 07:10.360
它就会运行Render

07:10.360 --> 07:11.360
你可以想象成为

07:11.360 --> 07:13.360
有这么一个SetState函数

07:13.360 --> 07:14.360
这个函数里面

07:14.360 --> 07:15.360
它做了一些事

07:15.360 --> 07:18.360
改变状态

07:18.360 --> 07:20.360
然后马上调用Render

07:20.360 --> 07:21.360
马上调用Render

07:21.360 --> 07:22.360
你可以这样的想

07:22.360 --> 07:23.360
那么是不是要

07:23.360 --> 07:24.360
应该先调用Render

07:24.360 --> 07:25.360
再输出这个东西

07:25.360 --> 07:27.360
但是实际上不是的

07:27.360 --> 07:29.360
它并没有马上改变状态

07:29.360 --> 07:30.360
而是说

07:30.360 --> 07:31.360
你看

07:31.360 --> 07:32.360
点了过后

07:32.360 --> 07:33.360
我们先输出了零

07:33.360 --> 07:34.360
也就是说

07:34.360 --> 07:35.360
先运行的是这句话

07:35.360 --> 07:38.360
然后才改变了状态

07:38.360 --> 07:39.360
然后改变状态之后

07:39.360 --> 07:40.360
才运行的Render

07:40.360 --> 07:41.360
所以我们这句话

07:41.360 --> 07:42.360
先输出这句话

07:42.360 --> 07:43.360
再输出

07:43.360 --> 07:45.360
明白这个意思吧

07:45.360 --> 07:46.360
所以说

07:46.360 --> 07:47.360
这里有这么一个坑

07:47.360 --> 07:48.360
大家要注意

07:48.360 --> 07:49.360
就是SetState

07:49.360 --> 07:50.360
它对状态的改变了

07:50.360 --> 07:53.360
可能是异步的

07:53.360 --> 07:54.360
那么之前

07:54.360 --> 07:55.360
我们用那个什么

07:55.360 --> 07:56.360
刀计时期

07:56.360 --> 07:57.360
为什么没有出问题呢

07:57.360 --> 07:58.360
就是我们用

07:58.360 --> 07:59.360
刀计时期

07:59.360 --> 08:00.360
这里不是说N-1吗

08:00.360 --> 08:01.360
对吧

08:01.360 --> 08:02.360
然后这里判断一下

08:02.360 --> 08:03.360
N那么那个时候

08:03.360 --> 08:04.360
为什么没出问题呢

08:04.360 --> 08:05.360
是因为

08:05.360 --> 08:06.360
这里说了两个字

08:06.360 --> 08:08.360
叫做可能是异步的

08:08.360 --> 08:09.360
它不一定是异步的

08:09.360 --> 08:10.360
有可能是同步的

08:10.360 --> 08:11.360
有可能是异步的

08:11.360 --> 08:13.360
说不好

08:13.360 --> 08:14.360
那么什么情况下

08:14.360 --> 08:15.360
是异步

08:15.360 --> 08:17.360
什么情况下是同步呢

08:17.360 --> 08:18.360
这个东西

08:18.360 --> 08:20.360
面试庭一般不会考

08:20.360 --> 08:21.360
一般不会考

08:21.360 --> 08:22.360
如果考的话

08:22.360 --> 08:24.360
就已经太偏太偏了

08:24.360 --> 08:25.360
不过我这里可以告诉大家

08:25.360 --> 08:27.360
什么情况下是异步的

08:27.360 --> 08:28.360
什么情况下是同步的

08:28.360 --> 08:29.360
以后咱们讲

08:29.360 --> 08:30.360
Ragged

08:30.360 --> 08:31.360
原码的时候

08:31.360 --> 08:32.360
你就知道了

08:32.360 --> 08:33.360
非常清楚了

08:33.360 --> 08:35.360
我这里先提一下吧

08:35.360 --> 08:36.360
就是如果

08:36.360 --> 08:40.360
改变状态的代码

08:40.360 --> 08:43.360
处于某个

08:43.360 --> 08:46.360
ATM元素的事件中

08:46.360 --> 08:51.360
则其是异步的

08:51.360 --> 08:55.360
否则是同步的

08:55.360 --> 08:56.360
那么我们回忆一下

08:56.360 --> 08:57.360
之前我们做了个

08:57.360 --> 09:00.360
倒计时期的时候

09:00.360 --> 09:01.360
那么那个时候

09:01.360 --> 09:02.360
我们是用什么

09:02.360 --> 09:03.360
set interval

09:03.360 --> 09:04.360
对吧

09:04.360 --> 09:05.360
set interval

09:05.360 --> 09:06.360
就是因为计时期

09:06.360 --> 09:07.360
那么那个是不是

09:07.360 --> 09:08.360
ATM的事件

09:08.360 --> 09:09.360
它不是ATM的事件

09:09.360 --> 09:10.360
对吧

09:10.360 --> 09:11.360
不是ATM元素的事件

09:11.360 --> 09:12.360
说它是同步的

09:12.360 --> 09:13.360
没有问题

09:13.360 --> 09:15.360
但是我们现在

09:15.360 --> 09:16.360
是不是ATM的事件

09:16.360 --> 09:17.360
对不对

09:17.360 --> 09:18.360
我们这个代码

09:18.360 --> 09:19.360
set state代码

09:19.360 --> 09:20.360
它是处于某一个

09:20.360 --> 09:22.360
ATM的事件当中

09:22.360 --> 09:25.360
所以说它是异步的

09:25.360 --> 09:27.360
它为什么要这样子处理呢

09:27.360 --> 09:29.360
它又很深层次的考虑

09:29.360 --> 09:31.360
我们一会就会讲到了

09:31.360 --> 09:33.360
总之它会是异步的

09:33.360 --> 09:34.360
那么平时

09:34.360 --> 09:36.360
我们做set state的时候

09:36.360 --> 09:38.360
它到底是同步还是异步呢

09:38.360 --> 09:39.360
我们需不需要

09:39.360 --> 09:40.360
自己脑袋里面去想

09:40.360 --> 09:41.360
它是不是

09:41.360 --> 09:43.360
蒙哥ATM的元素的事件了

09:43.360 --> 09:44.360
你不需要去想

09:44.360 --> 09:46.360
你做真词的开发的时候

09:46.360 --> 09:48.360
你始终把它当成异步的

09:48.360 --> 09:49.360
就不会有问题

09:49.360 --> 09:51.360
你始终把它当成异步

09:51.360 --> 09:53.360
就不会有任何问题了

09:53.360 --> 09:55.360
所以说我们为了避免

09:55.360 --> 09:56.360
后边学习写麻烦

09:56.360 --> 09:58.360
咱们后边写代码的时候

09:58.360 --> 10:00.360
就始终把这个set state

10:00.360 --> 10:01.360
当成异步的

10:01.360 --> 10:03.360
那就不会有任何问题了

10:03.360 --> 10:05.360
那么如果把它认为是异步的

10:05.360 --> 10:07.360
我们希望在改变状态之后

10:07.360 --> 10:09.360
要做一些事

10:09.360 --> 10:11.360
该怎么办呢

10:11.360 --> 10:12.360
我们这里复制一下

10:12.360 --> 10:14.360
copy一下

10:14.360 --> 10:16.360
那么如果我们改变状态之后

10:16.360 --> 10:17.360
可能要做一些事

10:17.360 --> 10:19.360
我们肯定不能这样子写了

10:19.360 --> 10:20.360
这样子写肯定要出问题

10:20.360 --> 10:21.360
对吧

10:21.360 --> 10:22.360
要出问题

10:22.360 --> 10:23.360
因为它可能是异步的

10:23.360 --> 10:24.360
运行到这的时候

10:24.360 --> 10:27.360
状态都还没有改变

10:27.360 --> 10:28.360
都还没有改变

10:28.360 --> 10:29.360
所以说我们没有办法

10:29.360 --> 10:31.360
得到新的set的值

10:31.360 --> 10:32.360
那该怎么办呢

10:32.360 --> 10:34.360
如果我们要在状态改变之后

10:34.360 --> 10:36.360
我们应该写第二个参数

10:36.360 --> 10:38.360
第二个参数是一个函数

10:38.360 --> 10:39.360
是一个函数

10:39.360 --> 10:41.360
这个函数里边

10:41.360 --> 10:42.360
我们可以获得

10:42.360 --> 10:44.360
这个是个回调函数

10:44.360 --> 10:46.360
这个回调函数是在什么

10:46.360 --> 10:49.360
状态完成改变之后

10:49.360 --> 10:51.360
触发

10:51.360 --> 10:53.360
我们使用回调函数的方式

10:53.360 --> 10:54.360
来得到新的状态

10:54.360 --> 10:55.360
那我们在这个函数里边

10:55.360 --> 10:57.360
输出什么

10:57.360 --> 10:58.360
输出这个

10:58.360 --> 11:00.360
zset.n

11:00.360 --> 11:01.360
你看就没有问题了

11:01.360 --> 11:02.360
好那么这个时候

11:02.360 --> 11:04.360
问大家一个问题

11:04.360 --> 11:05.360
先看结果

11:05.360 --> 11:07.360
先看结果

11:08.360 --> 11:09.360
我们现在点击

11:09.360 --> 11:10.360
你看

11:10.360 --> 11:11.360
是不是没问题了

11:11.360 --> 11:12.360
对吧没问题了

11:12.360 --> 11:13.360
刚才我想问什么问题呢

11:13.360 --> 11:14.360
就是Render在在前

11:14.360 --> 11:17.360
还是输出在后

11:17.360 --> 11:18.360
那应该是Render在前

11:18.360 --> 11:19.360
因为它是什么

11:19.360 --> 11:20.360
它是改变了状态

11:20.360 --> 11:21.360
改变了状态过后

11:21.360 --> 11:23.360
马上就会触发Render

11:23.360 --> 11:24.360
触发Render之后

11:24.360 --> 11:26.360
再运行这个回调函数

11:26.360 --> 11:28.360
那么该回调函数

11:28.360 --> 11:29.360
该回调

11:29.360 --> 11:33.360
运行在Render之后

11:33.360 --> 11:34.360
Render之后

11:34.360 --> 11:35.360
你看

11:35.360 --> 11:37.360
我们以后要得到新的状态

11:37.360 --> 11:40.360
我们应该在回调函数里边

11:40.360 --> 11:41.360
去完成

11:41.360 --> 11:42.360
去获取

11:42.360 --> 11:45.360
千万不要再用以前的那种方式了

11:45.360 --> 11:47.360
以后不管是同步还是异步

11:47.360 --> 11:48.360
免得出错

11:48.360 --> 11:49.360
为了避免出错

11:49.360 --> 11:51.360
如果你要获取新的状态

11:51.360 --> 11:53.360
都应该使用这种方式

11:53.360 --> 11:55.360
都应该使用这种方式

11:55.360 --> 11:56.360
在回调函数里边

11:56.360 --> 11:58.360
去获取新的状态

11:58.360 --> 11:59.360
你看

11:59.360 --> 12:00.360
是不是没问题了

12:00.360 --> 12:01.360
那么现在

12:01.360 --> 12:02.360
这里的数据

12:02.360 --> 12:04.360
就跟这里保持一致了

12:04.360 --> 12:05.360
好

12:05.360 --> 12:07.360
这是这一块

12:07.360 --> 12:08.360
好

12:08.360 --> 12:09.360
我们再继续来拓展

12:09.360 --> 12:10.360
好

12:10.360 --> 12:12.360
我们现在再复制一个

12:12.360 --> 12:13.360
现在再回调函数

12:13.360 --> 12:15.360
那如果

12:15.360 --> 12:17.360
如果说

12:17.360 --> 12:19.360
我们这里有可能

12:19.360 --> 12:22.360
会触发多个set state

12:22.360 --> 12:25.360
有可能会触发多个set state

12:25.360 --> 12:27.360
比方说

12:27.360 --> 12:30.360
我们能不能这样子写呢

12:30.360 --> 12:32.360
这样子写好像是看上去没问题

12:32.360 --> 12:33.360
对吧

12:33.360 --> 12:34.360
n

12:34.360 --> 12:35.360
然后加1

12:35.360 --> 12:36.360
你骂一开始是你骂

12:36.360 --> 12:37.360
你加1

12:37.360 --> 12:38.360
就是1把1复制给n

12:38.360 --> 12:40.360
然后再把1加1复制给n

12:40.360 --> 12:41.360
就是2

12:41.360 --> 12:43.360
然后再把2加1复制给n

12:43.360 --> 12:44.360
就是3

12:44.360 --> 12:45.360
对不对

12:45.360 --> 12:47.360
好像是没有什么问题

12:47.360 --> 12:49.360
好像是没有什么问题

12:49.360 --> 12:51.360
那么现在到底有没有问题呢

12:51.360 --> 12:53.360
到底有没有问题呢

12:53.360 --> 12:55.360
咱们来看一下结果

12:55.360 --> 12:56.360
好

12:56.360 --> 12:57.360
点击

12:57.360 --> 12:58.360
结果是1

12:58.360 --> 12:59.360
看到没

12:59.360 --> 13:00.360
结果它还是

13:00.360 --> 13:02.360
好像只运行了一次一样

13:02.360 --> 13:03.360
好像只运行了一次一样

13:03.360 --> 13:05.360
这是怎么回事呢

13:05.360 --> 13:07.360
好像这两句话忽略掉了

13:07.360 --> 13:08.360
是不是忽略掉了

13:08.360 --> 13:09.360
不是忽略掉了

13:09.360 --> 13:10.360
这是什么问题

13:10.360 --> 13:12.360
是不是就是刚才说的那个问题

13:12.360 --> 13:14.360
刚才说的是什么问题

13:14.360 --> 13:15.360
什么问题

13:15.360 --> 13:18.360
你这里在重新设置set

13:18.360 --> 13:19.360
但是呢

13:19.360 --> 13:21.360
我们是用同步的方式来得到这个n

13:21.360 --> 13:24.360
那么运行到这句话的时候

13:24.360 --> 13:26.360
是不是之前的状态还没有改变

13:26.360 --> 13:27.360
因为它是一步的嘛

13:27.360 --> 13:29.360
它的状态是不是还没有改变

13:29.360 --> 13:30.360
对吧

13:30.360 --> 13:31.360
还没有改变

13:31.360 --> 13:32.360
那么还没有改变

13:32.360 --> 13:34.360
是不是这里还是得到了是0

13:34.360 --> 13:35.360
我们之前说演示过

13:35.360 --> 13:36.360
对吧

13:36.360 --> 13:37.360
这里还是得到了是0

13:37.360 --> 13:39.360
相当于是你这里干嘛呢

13:39.360 --> 13:40.360
先把它设置为1

13:40.360 --> 13:42.360
然后再把它设置为1

13:42.360 --> 13:43.360
然后再把它设置为1

13:43.360 --> 13:45.360
相当于是做了这么一件事

13:45.360 --> 13:46.360
最终还是1

13:46.360 --> 13:48.360
那么第二次的时候呢

13:48.360 --> 13:49.360
你再点击

13:49.360 --> 13:51.360
相当于是把三个都设置为2

13:51.360 --> 13:52.360
因为这个n它是

13:52.360 --> 13:54.360
这个时候还没有被改变

13:54.360 --> 13:55.360
对吧

13:55.360 --> 13:56.360
还没有被改变

13:56.360 --> 13:58.360
那这个时候又怎么办呢

13:58.360 --> 14:01.360
那就说我这里写回调函数呗

14:01.360 --> 14:02.360
先把它设置为1

14:02.360 --> 14:04.360
然后再回调函数里边

14:04.360 --> 14:06.360
再把它设置为n加1

14:06.360 --> 14:07.360
然后再再回调函数里边

14:07.360 --> 14:09.360
把它设置为n加2

14:09.360 --> 14:10.360
这样子写可不可以

14:10.360 --> 14:11.360
可以

14:11.360 --> 14:12.360
我来写一遍

14:12.360 --> 14:13.360
我来写一遍

14:13.360 --> 14:14.360
Zestate

14:14.360 --> 14:15.360
又来

14:15.360 --> 14:18.360
又把这个n设置为Zestate

14:18.360 --> 14:21.360
点n加上1

14:21.360 --> 14:23.360
当然这个没有实际意义

14:23.360 --> 14:24.360
没有实际意义

14:24.360 --> 14:26.360
只不过我说明这个意思

14:26.360 --> 14:30.990
把这个意思说明一下

14:30.990 --> 14:32.990
我们这样子写可不可以

14:32.990 --> 14:33.990
当然这样子写就可以了

14:33.990 --> 14:35.990
那么这样子写噁不噁心

14:35.990 --> 14:37.990
你看一下噁不噁心

14:37.990 --> 14:38.990
超级噁心对不对

14:38.990 --> 14:39.990
你看一下吧

14:39.990 --> 14:41.990
现在是没问题了

14:41.990 --> 14:42.990
现在是没问题了

14:42.990 --> 14:43.990
但是呢

14:43.990 --> 14:45.990
很噁心这个代码

14:45.990 --> 14:46.990
很噁心这个代码

14:46.990 --> 14:49.990
那怎么样用一种优雅的方式来进行输写呢

14:49.990 --> 14:50.990
它实际上Zestate

14:50.990 --> 14:52.990
还给我们提供了一个东西

14:52.990 --> 14:53.990
就是你第一个参数

14:53.990 --> 14:55.990
你可以直接写个对象

14:55.990 --> 14:56.990
可以直接写个对象

14:56.990 --> 14:58.990
还可以写什么

14:58.990 --> 14:59.990
写成一个函数

14:59.990 --> 15:01.990
第一个参数

15:01.990 --> 15:04.990
这个函数有一个参数

15:04.990 --> 15:06.990
这个参数表示什么意思呢

15:06.990 --> 15:08.990
说一下这个函数

15:08.990 --> 15:12.990
这个函数它的参数Prieve

15:12.990 --> 15:15.990
表示当前的

15:15.990 --> 15:17.990
当前的状态

15:17.990 --> 15:20.990
它表示当前的状态

15:20.990 --> 15:23.990
然后呢

15:23.990 --> 15:27.990
这个该函数的返回结果

15:27.990 --> 15:29.990
返回结果

15:29.990 --> 15:33.990
返回结果会混合到

15:33.990 --> 15:35.990
或者说叫做覆盖

15:35.990 --> 15:38.990
会覆盖掉之前的状态

15:38.990 --> 15:39.990
对吧

15:39.990 --> 15:41.990
我们之前是直接传个对象嘛

15:41.990 --> 15:42.990
那么对象里边的东西

15:42.990 --> 15:44.990
是不是覆盖掉状态里边的东西

15:44.990 --> 15:46.990
那么现在你函数返回的结果

15:46.990 --> 15:47.990
它覆盖掉状态

15:47.990 --> 15:49.990
那这里是不是很简单

15:49.990 --> 15:50.990
Return什么呢

15:50.990 --> 15:52.990
Return

15:52.990 --> 15:53.990
等于什么呢

15:53.990 --> 15:55.990
等于当前的状态

15:55.990 --> 15:56.990
当前的状态

15:56.990 --> 15:58.990
不要用值钱

15:58.990 --> 15:59.990
用那个当前吧

15:59.990 --> 16:01.990
ker

16:01.990 --> 16:05.990
用当前的状态里边的n加1

16:05.990 --> 16:06.990
好

16:06.990 --> 16:08.990
然后呢还有个特点这个函数

16:08.990 --> 16:10.990
该函数呢

16:10.990 --> 16:12.990
也是

16:12.990 --> 16:14.990
就是

16:14.990 --> 16:16.990
是一步执行的

16:16.990 --> 16:17.990
也就是不是

16:17.990 --> 16:19.990
它不会马上执行这个函数

16:19.990 --> 16:21.990
什么时候执行呢

16:21.990 --> 16:23.990
就是

16:23.990 --> 16:25.990
我现在没法给你解释什么时候执行

16:25.990 --> 16:28.990
它会在一个适当的时机来执行这个函数

16:28.990 --> 16:30.990
会在一个适当的时机来执行这个函数

16:30.990 --> 16:32.990
它不会马上执行

16:32.990 --> 16:33.990
这个函数

16:33.990 --> 16:34.990
给的它一个函数的话

16:34.990 --> 16:36.990
它也是一个异步的函数

16:36.990 --> 16:37.990
它不会马上执行

16:37.990 --> 16:39.990
它等到一个适当的时候

16:39.990 --> 16:41.990
它才会执行这个函数

16:41.990 --> 16:42.990
我们再来看一下

16:42.990 --> 16:43.990
这样的一个写法

16:43.990 --> 16:45.990
会有一个什么样的结果

16:45.990 --> 16:46.990
看一下

16:46.990 --> 16:47.990
把下面两句话注释掉

16:47.990 --> 16:49.990
你看是一样的效果

16:49.990 --> 16:50.990
一样的效果

16:50.990 --> 16:51.990
然后点击

16:51.990 --> 16:52.990
点击

16:52.990 --> 16:53.990
你看看

16:53.990 --> 16:54.990
是不是一样的效果

16:54.990 --> 16:55.990
注意

16:55.990 --> 16:57.990
这个函数它也是异步执行的

16:57.990 --> 16:58.990
有时候也在这里

16:58.990 --> 16:59.990
输出一个

16:59.990 --> 17:01.990
Z state

17:01.990 --> 17:02.990
N

17:02.990 --> 17:03.990
看一下吧

17:03.990 --> 17:05.990
是一样的问题

17:05.990 --> 17:06.990
是一样的问题

17:06.990 --> 17:07.990
点击

17:07.990 --> 17:08.990
你看是不是还是0

17:08.990 --> 17:09.990
还是0

17:09.990 --> 17:10.990
点击还是1

17:10.990 --> 17:12.990
只不过把它输写成函数了

17:12.990 --> 17:14.990
输写成函数了

17:14.990 --> 17:16.990
这里还是可以写第二个函数

17:16.990 --> 17:17.990
回掉函数

17:17.990 --> 17:18.990
回掉函数里边输出

17:18.990 --> 17:19.990
N

17:19.990 --> 17:20.990
这个是没问题的

17:20.990 --> 17:21.990
看一下

17:21.990 --> 17:22.990
这个是没问题的

17:22.990 --> 17:24.990
跟之前是一样的

17:24.990 --> 17:27.990
既然一样有什么意义呢

17:27.990 --> 17:28.990
意义就在于

17:28.990 --> 17:31.990
这个函数里是可以信任的

17:31.990 --> 17:33.990
什么叫可以信任

17:33.990 --> 17:34.990
就是说

17:34.990 --> 17:36.990
如果你只改变一次状态

17:36.990 --> 17:38.990
你确实没有必要这样做

17:38.990 --> 17:39.990
确实没有必要这样做

17:39.990 --> 17:40.990
但是有的时候

17:40.990 --> 17:41.990
事件里边

17:41.990 --> 17:44.990
可能会涉及到多次状态改变

17:44.990 --> 17:46.990
那么涉及到多次状态改变的时候

17:46.990 --> 17:47.990
这个东西就有用了

17:47.990 --> 17:48.990
比方说

17:48.990 --> 17:50.990
我们第二次再改变状态

17:50.990 --> 17:54.300
我们也可以这样子写

17:54.300 --> 17:55.300
看着

17:55.300 --> 17:56.300
第二次改变状态

17:56.300 --> 17:58.300
我们可以这样子写

17:58.300 --> 17:59.300
当然

17:59.300 --> 18:00.300
我们这里还可以把它

18:00.300 --> 18:02.300
用函数

18:02.300 --> 18:05.300
可以把它减换一下

18:05.300 --> 18:08.300
这里先两个小颇号

18:08.300 --> 18:10.300
返回这个结果

18:10.300 --> 18:11.300
把它减换一下

18:11.300 --> 18:12.300
对不对

18:12.300 --> 18:14.300
这里也是

18:14.300 --> 18:15.300
把它加三次

18:15.300 --> 18:16.300
分别加三次

18:16.300 --> 18:17.300
你会说

18:17.300 --> 18:18.300
肯定没有意义

18:18.300 --> 18:19.300
所以

18:19.300 --> 18:20.300
你直接加三次完了

18:20.300 --> 18:22.300
举个例子

18:22.300 --> 18:23.300
不要叫头儿

18:23.300 --> 18:25.300
举个例子

18:25.300 --> 18:27.300
有可能我们会遇到多次

18:27.300 --> 18:28.300
多次改变状态

18:28.300 --> 18:29.300
那么这个时候

18:29.300 --> 18:32.300
这个参数是可以信任的

18:32.300 --> 18:33.300
它要等到什么呢

18:33.300 --> 18:35.300
等到前边的状态

18:35.300 --> 18:37.300
改变完了之后

18:37.300 --> 18:39.300
再会运行这个函数

18:39.300 --> 18:40.300
那么这个函数里边

18:40.300 --> 18:41.300
传入的这个参数

18:41.300 --> 18:43.300
就是之前那个状态

18:43.300 --> 18:45.300
之前的那个状态

18:45.300 --> 18:46.300
这个参数就是

18:46.300 --> 18:47.300
之前的那个状态

18:48.300 --> 18:49.300
实际上

18:49.300 --> 18:50.300
到时候我们分析圆骂的时候

18:50.300 --> 18:51.300
你会发现

18:51.300 --> 18:52.300
这三个函数

18:52.300 --> 18:54.300
它会把它形成一个对列

18:54.300 --> 18:56.300
它会把它形成一个对列

18:56.300 --> 18:57.300
那么第一个函数

18:57.300 --> 18:58.300
调用完了之后

18:58.300 --> 18:59.300
它会把这个新的状态

18:59.300 --> 19:01.300
作为参数传给它

19:01.300 --> 19:03.300
那么再调用这个函数

19:03.300 --> 19:04.300
然后这个函数

19:04.300 --> 19:05.300
调用完了之后

19:05.300 --> 19:06.300
再把新的状态传给它

19:06.300 --> 19:07.300
调用这个函数

19:07.300 --> 19:08.300
等到所有的函数

19:08.300 --> 19:09.300
调用完了之后

19:09.300 --> 19:11.300
再改变最终的状态

19:11.300 --> 19:13.300
它这么一种操作方式

19:13.300 --> 19:14.300
保存

19:14.300 --> 19:15.300
看一下吧

19:15.300 --> 19:16.300
好 那看

19:16.300 --> 19:17.300
现在是不是没问题了

19:17.300 --> 19:18.300
对吧

19:19.300 --> 19:20.300
我们以后

19:20.300 --> 19:22.300
所以大家注意

19:22.300 --> 19:23.300
将来

19:24.300 --> 19:26.300
就是如果遇到

19:26.300 --> 19:28.300
如果遇到

19:28.300 --> 19:30.300
某个事件

19:30.300 --> 19:32.300
某个事件中

19:32.300 --> 19:34.300
需要调用多次

19:36.300 --> 19:37.300
需要这样说

19:37.300 --> 19:39.300
需要同步调用多次

19:39.300 --> 19:40.300
为什么要加个同步两个字呢

19:40.300 --> 19:41.300
就是因为

19:41.300 --> 19:43.300
有可能这两个set state

19:43.300 --> 19:45.300
阿迦克斯请求完成之后调用

19:45.300 --> 19:46.300
那就无所谓了

19:46.300 --> 19:47.300
因为阿迦克斯请求

19:47.300 --> 19:48.300
肯定需要一段时间

19:48.300 --> 19:49.300
等这段时间完了

19:49.300 --> 19:50.300
早就重新渲染了

19:50.300 --> 19:51.300
对吧

19:51.300 --> 19:52.300
早就重新渲染了

19:52.300 --> 19:54.300
那么那个时候倒是无所谓的

19:54.300 --> 19:55.300
我就是这里说

19:55.300 --> 19:57.300
如果说同步的要调用多次

19:57.300 --> 19:59.300
那么这个时候要注意

19:59.300 --> 20:01.300
需要

20:01.300 --> 20:02.300
使用

20:02.300 --> 20:04.300
函数的方式

20:04.300 --> 20:06.300
得到

20:06.300 --> 20:08.300
最新状态

20:09.300 --> 20:11.300
如果你要根据最新状态

20:11.300 --> 20:13.300
来算出最终结果

20:13.300 --> 20:14.300
比方说你要根据最新

20:14.300 --> 20:16.300
之前的状态来算出一个结果

20:16.300 --> 20:18.300
那么你要用函数的方式

20:18.300 --> 20:20.300
当然如果你的状态

20:20.300 --> 20:22.300
得到的结果的状态

20:22.300 --> 20:24.300
你不需要用到之前的状态

20:24.300 --> 20:25.300
那就无所谓了

20:25.300 --> 20:26.300
如果你需要用到之前的状态

20:26.300 --> 20:28.300
那么你要用函数的方式

20:28.300 --> 20:30.300
你不能去信任

20:30.300 --> 20:31.300
代码运行到这个时候

20:31.300 --> 20:33.300
他的状态被改变了

20:33.300 --> 20:34.300
千万不要信任

20:34.300 --> 20:35.300
有可能他之前的状态

20:35.300 --> 20:36.300
还没有改变

20:36.300 --> 20:37.300
因为他是异步的

20:37.300 --> 20:38.300
原来这个意思吧

20:38.300 --> 20:40.300
所以说最安全的是啥

20:40.300 --> 20:41.300
最安全的就是说

20:41.300 --> 20:43.300
函是你要用到之前的状态

20:43.300 --> 20:45.300
进入函数

20:45.300 --> 20:46.300
所以说我们说

20:46.300 --> 20:48.300
这里说个最佳实践

20:48.300 --> 20:50.300
最佳实践

20:50.300 --> 20:51.300
实践

20:51.300 --> 20:52.300
什么叫最佳实践呢

20:52.300 --> 20:53.300
就是说我们最好

20:53.300 --> 20:54.300
开发的时候最好

20:54.300 --> 20:56.300
按照什么样的东西来编写

20:56.300 --> 20:58.300
就是说把所有的

20:59.300 --> 21:00.300
set state

21:00.300 --> 21:03.300
当做是异步的

21:03.300 --> 21:06.300
永远不要信任

21:06.300 --> 21:09.300
set state

21:10.300 --> 21:14.300
调用之后的状态

21:14.300 --> 21:15.300
那个时候状态

21:15.300 --> 21:16.300
可能还没有改变

21:16.300 --> 21:19.300
如果要使用

21:19.300 --> 21:22.300
改变之后的状态

21:22.300 --> 21:25.300
需要使用回调函数

21:25.300 --> 21:27.300
需要在回调函数里边

21:27.300 --> 21:29.300
就是set state

21:29.300 --> 21:31.300
set state的第二个参数

21:31.300 --> 21:33.300
的第二个参数

21:33.300 --> 21:35.300
在第二参数里边

21:35.300 --> 21:37.300
去使用最新的状态

21:37.300 --> 21:38.300
永远不要信任

21:38.300 --> 21:40.300
它调用之后的状态

21:40.300 --> 21:42.300
如果要用到

21:42.300 --> 21:45.300
如果新的状态

21:45.300 --> 21:49.300
要根据之前的状态

21:49.300 --> 21:51.300
进行运算

21:51.300 --> 21:53.300
比方说刚才那种情况

21:53.300 --> 21:55.300
新的状态

21:55.300 --> 21:56.300
它要根据之前的N

21:56.300 --> 21:57.300
进行运算

21:57.300 --> 21:58.300
如果是这种情况

21:58.300 --> 22:02.300
那么使用函数的方式

22:02.300 --> 22:04.300
方式改变

22:04.300 --> 22:05.300
改变状态

22:05.300 --> 22:06.300
那么就是

22:06.300 --> 22:08.300
set state的第一个参数

22:08.300 --> 22:10.300
把它做成一个函数

22:10.300 --> 22:11.300
这就是最大压时间

22:11.300 --> 22:13.300
以记住这四个点

22:13.300 --> 22:14.300
你开发的时候

22:14.300 --> 22:15.300
不会出问题的

22:15.300 --> 22:17.300
就不会出问题的

22:17.300 --> 22:18.300
这样子意思吧

22:18.300 --> 22:21.300
那么现在就没有出问题了

22:21.300 --> 22:22.300
好 接下来咱们

22:22.300 --> 22:24.300
再来看一个奇怪的现象

22:24.300 --> 22:25.300
这里我们改变了

22:25.300 --> 22:26.300
三次状态

22:26.300 --> 22:27.300
肯定有三次状态改变

22:27.300 --> 22:28.300
这个毫无疑问

22:28.300 --> 22:30.300
然后我们来看一下

22:30.300 --> 22:32.300
刷新

22:32.300 --> 22:33.300
点击

22:33.300 --> 22:35.300
它这个Render运行的几次

22:36.300 --> 22:37.300
是不是一次

22:37.300 --> 22:38.300
对吧

22:38.300 --> 22:40.300
它Render只运行了一次

22:40.300 --> 22:41.300
看没

22:41.300 --> 22:42.300
再来啊

22:42.300 --> 22:43.300
再点击

22:43.300 --> 22:44.300
本来是改变了三次状态的

22:44.300 --> 22:46.300
它只运行了一次

22:46.300 --> 22:48.300
为什么只运行一次呢

22:48.300 --> 22:49.300
不是说set state

22:49.300 --> 22:51.300
它会触发那个

22:51.300 --> 22:52.300
每次运行set state

22:52.300 --> 22:53.300
它都会触发渲染

22:53.300 --> 22:54.300
应该触发三次渲染

22:54.300 --> 22:56.300
它为什么只运行了一次呢

22:56.300 --> 22:57.300
这是Ragton

22:57.300 --> 22:59.300
做了一个优化

22:59.300 --> 23:00.300
它做了一个优化

23:00.300 --> 23:01.300
Ragton呢

23:01.300 --> 23:03.300
它是这样子

23:03.300 --> 23:04.300
Ragton

23:05.300 --> 23:08.300
会对一步的set state

23:08.300 --> 23:11.300
进行优化

23:11.300 --> 23:12.300
将

23:12.300 --> 23:14.300
它只对一步的set state

23:14.300 --> 23:15.300
进行优化

23:15.300 --> 23:16.300
如果set state是同步的

23:16.300 --> 23:17.300
它就不会进行优化了

23:17.300 --> 23:18.300
不会进行优化了

23:18.300 --> 23:20.300
每调用一次就运行Render

23:20.300 --> 23:22.300
它只会对一步的set state

23:22.300 --> 23:23.300
进行优化

23:23.300 --> 23:27.300
将多次set state

23:27.300 --> 23:28.300
进行合并

23:28.300 --> 23:29.300
进行合并

23:29.300 --> 23:30.300
它怎么来合并的

23:30.300 --> 23:31.300
其实就是一个喊数

23:31.300 --> 23:32.300
一个喊数调用

23:32.300 --> 23:33.300
只不过来调用

23:34.300 --> 23:36.300
就是除非把整个喊数调用完了

23:36.300 --> 23:37.300
否则的话

23:37.300 --> 23:40.300
它不会改变真正的状态

23:40.300 --> 23:41.300
我们那一里边的状态

23:41.300 --> 23:42.300
它不会改变的

23:42.300 --> 23:44.300
它只有把喊数调用完之后

23:44.300 --> 23:45.300
再一起来改变状态

23:45.300 --> 23:47.300
然后再触发Render

23:47.300 --> 23:49.300
它会把多次的set state

23:49.300 --> 23:50.300
进行合并

23:50.300 --> 23:51.300
实际上是怎么做的呢

23:51.300 --> 23:55.300
就是将多次状态

23:55.300 --> 23:57.300
改变

23:57.300 --> 23:59.300
完成后

23:59.300 --> 24:00.300
再

24:00.300 --> 24:03.300
统一对set state

24:03.300 --> 24:05.300
进行改变

24:05.300 --> 24:07.300
然后触发

24:07.300 --> 24:08.300
触发什么

24:08.300 --> 24:09.300
触发Render

24:09.300 --> 24:12.300
它是用这种方式来运作的

24:12.300 --> 24:13.300
不要说这里是调三次

24:13.300 --> 24:14.300
对吧

24:14.300 --> 24:15.300
第一次调用完了过后

24:15.300 --> 24:17.300
并没有真正改变这个状态

24:17.300 --> 24:19.300
而是等着

24:19.300 --> 24:21.300
因为这里有三个

24:21.300 --> 24:22.300
把下一次状态改了过后

24:22.300 --> 24:24.300
也没有真正触发

24:24.300 --> 24:27.300
没有真正把它覆盖掉

24:27.300 --> 24:28.300
也等着

24:28.300 --> 24:29.300
把它也运行完了过后

24:29.300 --> 24:31.300
发现后面没了

24:31.300 --> 24:32.300
后面没东西了

24:32.300 --> 24:33.300
那么这个时候

24:33.300 --> 24:34.300
再把这个状态改变

24:34.300 --> 24:35.300
然后再运行Render

24:35.300 --> 24:37.300
所以说我们只看到了一次

24:37.300 --> 24:39.300
只看到了一次Render调用

24:39.300 --> 24:40.300
你要这意思吧

24:40.300 --> 24:41.300
注意

24:41.300 --> 24:43.300
它只对一一步的进行这样的处理

24:43.300 --> 24:45.300
对同步的还没有这样的处理

24:45.300 --> 24:46.300
那比方说

24:46.300 --> 24:47.300
我们就写个同步

24:47.300 --> 24:48.300
写个同步

24:48.300 --> 24:50.300
constructor

24:50.300 --> 24:52.300
probs

24:52.300 --> 24:53.300
super

24:53.300 --> 24:54.300
probs

24:54.300 --> 24:57.300
然后这里set interval

24:58.300 --> 25:03.730
每个一秒钟

25:03.730 --> 25:05.730
每个一秒钟

25:05.730 --> 25:06.730
每个一秒钟干嘛呢

25:06.730 --> 25:08.730
我设置三次状态

25:08.730 --> 25:11.730
设置三次状态

25:11.730 --> 25:13.730
那么现在的状态

25:13.730 --> 25:14.730
我们就这样子设置

25:14.730 --> 25:15.730
你看同步里面

25:15.730 --> 25:16.730
就没有这些问题了

25:16.730 --> 25:17.730
直接来就行了

25:17.730 --> 25:18.730
你是可以信任的

25:18.730 --> 25:19.730
n对于什么

25:19.730 --> 25:20.730
z

25:20.730 --> 25:22.730
set n加1

25:22.730 --> 25:23.730
直接来就行了

25:23.730 --> 25:24.730
一次

25:24.730 --> 25:26.730
不能加分

25:26.730 --> 25:28.730
一次

25:28.730 --> 25:29.730
两次

25:29.730 --> 25:30.730
三次

25:30.730 --> 25:31.730
好看一下吧

25:32.730 --> 25:33.730
你看

25:33.730 --> 25:35.730
每次是不是运行了三次

25:35.730 --> 25:36.730
对吧

25:36.730 --> 25:37.730
再看一下

25:37.730 --> 25:39.730
每次是不是运行了三次

25:39.730 --> 25:40.730
对吧

25:40.730 --> 25:41.730
而且是有效的

25:41.730 --> 25:42.730
对吧

25:42.730 --> 25:44.730
它并不会出现刚才那个问题

25:44.730 --> 25:46.730
n还是之前的那个问题

25:46.730 --> 25:47.730
它不会出现

25:47.730 --> 25:48.730
因为这是同步的

25:48.730 --> 25:49.730
为什么是同步的

25:49.730 --> 25:50.730
我们刚才说了

25:50.730 --> 25:51.730
它不在

25:51.730 --> 25:53.730
atm元素的事件里边

25:53.730 --> 25:54.730
它就是同步的

25:54.730 --> 25:55.730
当然这个东西

25:55.730 --> 25:56.730
官网还没有给你解释

25:56.730 --> 25:57.730
完全没给你解释

25:57.730 --> 25:58.730
官网是没给你解释的

25:58.730 --> 25:59.730
它什么情况啊

25:59.730 --> 26:00.730
同步

26:00.730 --> 26:01.730
什么情况啊

26:01.730 --> 26:02.730
异步

26:02.730 --> 26:03.730
我们这个东西是要分析远

26:03.730 --> 26:04.730
骂你才知道

26:04.730 --> 26:05.730
它是怎么回事

26:05.730 --> 26:06.730
这一块呢

26:06.730 --> 26:08.730
大家了解一下就行了

26:08.730 --> 26:10.730
但是异步里边

26:10.730 --> 26:11.730
异步里边

26:11.730 --> 26:12.730
它是会进行合并的

26:12.730 --> 26:14.730
那么它为什么有这样的处理呢

26:14.730 --> 26:15.730
它是这样的考虑的

26:15.730 --> 26:16.730
它认为

26:16.730 --> 26:17.730
通常情况下

26:17.730 --> 26:19.730
我们的事件处理呢

26:19.730 --> 26:21.730
都是在什么时候处理事件

26:21.730 --> 26:23.730
都是追踪

26:23.730 --> 26:25.730
不管我们自己封装了多少层主见

26:25.730 --> 26:26.730
追踪的事件

26:26.730 --> 26:28.730
往往都是ATM元素的事件

26:28.730 --> 26:30.730
比如说鼠标移入啊

26:30.730 --> 26:31.730
用户说了什么操作啊

26:31.730 --> 26:32.730
对吧

26:32.730 --> 26:33.730
往往都是最终会对应到

26:33.730 --> 26:34.730
ATM元素的事件

26:34.730 --> 26:36.730
而在元素的事件里边呢

26:36.730 --> 26:38.730
可能会处理很多东西

26:38.730 --> 26:41.730
如果不加上这样的控制的话

26:41.730 --> 26:42.730
那么因为

26:42.730 --> 26:44.730
事件里面可能处理的事情很复杂

26:44.730 --> 26:46.730
一般事件里面可能有

26:46.730 --> 26:47.730
成百上千行代码

26:47.730 --> 26:48.730
可能需要处理

26:48.730 --> 26:49.730
那么这些代码呢

26:49.730 --> 26:51.730
你可能不会把它分得很善

26:51.730 --> 26:53.730
分得很善

26:53.730 --> 26:54.730
分得很散

26:55.730 --> 26:57.730
比方说

26:57.730 --> 26:59.730
比方说A这个主见里边

26:59.730 --> 27:01.730
有一个按钮

27:01.730 --> 27:03.730
这个按钮触发了一个点击事件

27:03.730 --> 27:05.730
然后这个主见A里边呢

27:05.730 --> 27:07.730
它可能要做实践事情

27:07.730 --> 27:08.730
当点击的时候

27:08.730 --> 27:09.730
可能要做实践事情

27:09.730 --> 27:12.730
这实践事情呢

27:12.730 --> 27:14.730
实践事

27:15.730 --> 27:16.730
这实践事情呢

27:16.730 --> 27:20.730
分散到不同的函数里边去完成的

27:20.730 --> 27:21.730
实践事情

27:21.730 --> 27:24.730
分散到10个函数里边去完成的

27:25.730 --> 27:26.730
这10个函数呢

27:26.730 --> 27:29.730
由于根据我们的设计的特点

27:29.730 --> 27:31.730
函数的编写的时候

27:31.730 --> 27:33.730
一般不会去考虑别的函数

27:33.730 --> 27:35.730
它是一个独立的东西

27:35.730 --> 27:36.730
所以这个10个函数里面呢

27:36.730 --> 27:39.730
每个函数都可能会改变一个状态

27:39.730 --> 27:40.730
都可能会改变一个状态

27:40.730 --> 27:42.730
如果不加限制的话

27:42.730 --> 27:44.730
那么这里会触发10次状态更新

27:44.730 --> 27:46.730
它就会重新渲染10次

27:46.730 --> 27:48.730
这个效率太低了

27:48.730 --> 27:49.730
它就会它会怎么做呢

27:49.730 --> 27:50.730
它反而它就会这样做

27:50.730 --> 27:51.730
为了优化效率

27:51.730 --> 27:52.730
它会把最终呢

27:52.730 --> 27:54.730
这10次渲染的合并到一起

27:54.730 --> 27:56.730
把它做成一个异步的

27:56.730 --> 27:58.730
你想必须要异步对吧

27:58.730 --> 27:59.730
如果它不异步的话

27:59.730 --> 28:00.730
它怎么来

28:00.730 --> 28:02.730
每次一调它就重新渲染了

28:02.730 --> 28:03.730
它就没法控制了

28:03.730 --> 28:04.730
它就必须要用异步

28:04.730 --> 28:06.730
它把它加到一个对列里边

28:06.730 --> 28:08.730
然后最终再从这个对列里边

28:08.730 --> 28:09.730
一个一个去运行

28:09.730 --> 28:10.730
运行完了之后

28:10.730 --> 28:12.730
再一起来更新状态

28:12.730 --> 28:13.730
它是用这种方式来处理的

28:13.730 --> 28:15.730
是为了提高效率

28:15.730 --> 28:16.730
他认为

28:16.730 --> 28:17.730
Rechs认为

28:17.730 --> 28:19.730
他就是在Ettman元素的世界里边

28:19.730 --> 28:21.730
我们往往会有一些复杂处理

28:21.730 --> 28:23.730
那么他同时又认为

28:23.730 --> 28:25.730
如果不在Ettman元素里边

28:25.730 --> 28:27.730
我们遇不到一些复杂处理

28:27.730 --> 28:29.730
比方说什么SettingTable

28:29.730 --> 28:30.730
这些东西

28:30.730 --> 28:31.730
往往会遇不到一些复杂处理

28:31.730 --> 28:32.730
所以说

28:32.730 --> 28:34.730
它不会去把它变成异步

28:34.730 --> 28:36.730
不会把它变成一个对列

28:36.730 --> 28:38.730
它就会让它变成同步执行

28:38.730 --> 28:39.730
它是这么考虑的

28:39.730 --> 28:42.730
我就把它的考虑这种思路告诉大家

28:42.730 --> 28:44.730
其实我们写代码的时候

28:44.730 --> 28:46.730
你只能把它当成异步就完事了

28:46.730 --> 28:48.730
就不会有任何问题了

28:48.730 --> 28:50.730
这是关于这一块

28:50.730 --> 28:51.730
另外再说一下

28:51.730 --> 28:53.730
再说一下这里

28:53.730 --> 28:55.730
那么它这里合并的执行了

28:55.730 --> 28:56.730
合并执行

28:56.730 --> 28:59.730
如果我们在第一次SettingStats里边

28:59.730 --> 29:01.730
写上一个函数

29:01.730 --> 29:02.730
写上一个回调函数

29:02.730 --> 29:05.730
就是它更新完了过后的回调函数

29:07.730 --> 29:08.730
回调

29:09.730 --> 29:11.730
就是Setting更新完成

29:11.730 --> 29:14.730
那么这个函数是在什么时候运行的呢

29:14.730 --> 29:15.730
它实际上

29:15.730 --> 29:16.730
不是说

29:16.730 --> 29:18.730
把这一次状态更新完了运行

29:18.730 --> 29:20.730
而是什么时候运行

29:20.730 --> 29:24.730
所有状态全部完成

29:24.730 --> 29:26.730
全部更新完成

29:26.730 --> 29:30.730
并且重新渲染后

29:30.730 --> 29:32.730
渲染后执行

29:32.730 --> 29:34.730
它是在这个时候执行的

29:34.730 --> 29:35.730
你看一下吧

29:35.730 --> 29:37.730
我们这里点击

29:37.730 --> 29:39.730
Setting更新完成

29:39.730 --> 29:42.730
先运行的是Render再运行的是这个东西

29:42.730 --> 29:43.730
再点击

29:43.730 --> 29:45.730
Render再运行的这个东西

29:45.730 --> 29:46.730
好

29:46.730 --> 29:47.730
比方说我们在这里

29:47.730 --> 29:48.730
再输出这个Stats的N

29:48.730 --> 29:49.730
你看一下

29:49.730 --> 29:50.730
你认为会输出多少

29:50.730 --> 29:51.730
会输出多少

29:51.730 --> 29:52.730
输出的是

29:52.730 --> 29:53.730
比方第一次

29:53.730 --> 29:54.730
输出的是1

29:54.730 --> 29:56.730
还是输出的是3

29:57.730 --> 29:58.730
你想呗

29:58.730 --> 29:59.730
肯定输出3

29:59.730 --> 30:00.730
对不对

30:00.730 --> 30:01.730
它输出的是3

30:01.730 --> 30:02.730
看没有

30:02.730 --> 30:04.730
它不是说这一次状态更新完了

30:04.730 --> 30:05.730
过后就运行

30:05.730 --> 30:06.730
而是整个状态

30:06.730 --> 30:08.730
全部更新完了过后再运行

30:08.730 --> 30:10.730
它这么个意思

30:11.730 --> 30:12.730
好了

30:12.730 --> 30:14.730
这就是关于SettingStats里边

30:14.730 --> 30:17.730
一些细节大家开发的时候要注意一下

30:17.730 --> 30:18.730
之前为什么没有讲了

30:18.730 --> 30:20.730
因为之前没有学过时间

30:20.730 --> 30:21.730
没有学过时间的话

30:21.730 --> 30:22.730
没法讲这个东西

30:22.730 --> 30:23.730
没法讲这个东西

30:23.730 --> 30:24.730
因为它设计到

30:24.730 --> 30:26.730
时间里边还是一步的

30:26.730 --> 30:28.730
之前那都是同步的运行的

30:28.730 --> 30:29.730
好吧

30:29.730 --> 30:30.730
这是关于这一块

