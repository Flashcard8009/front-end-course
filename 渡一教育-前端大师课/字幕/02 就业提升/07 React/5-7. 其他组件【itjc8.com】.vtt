WEBVTT

00:00.050 --> 00:06.050
这些可能咱们把rexrotor这一块的其他组件讲了

00:06.050 --> 00:10.050
rexrotor我们已经学过的东西有哪些呢

00:10.050 --> 00:12.050
与学习的组件啊

00:12.050 --> 00:15.050
首先说与学习有这个rotor对吧

00:15.050 --> 00:19.050
当然这个rotor它包含什么包含什么browser

00:19.050 --> 00:23.050
这我们最常见的browserrotor或者是hashrotor

00:23.050 --> 00:25.050
hashrotor这两种

00:25.050 --> 00:28.050
然后呢还学过什么rotor

00:28.050 --> 00:31.050
也是非常重要的组件它是用来匹配路径的

00:31.050 --> 00:34.050
然后不同的路径的渲染不同的组件

00:34.050 --> 00:37.050
然后呢还学习了什么呢还学习了这个switch

00:37.050 --> 00:42.050
相当于是个开关只要匹配到一个就不要再继续往下匹配了

00:42.050 --> 00:44.050
学这么三个组件

00:44.050 --> 00:47.050
然后呢还学习了一个高兼函数

00:47.050 --> 00:49.050
一个高兼函数

00:49.050 --> 00:54.050
什么就是wizrotor对吧就学一下这么一些东西

00:55.050 --> 00:57.050
除了这些组件之外呢

00:57.050 --> 00:59.050
包括这个高兼函数之外呢

00:59.050 --> 01:03.050
还有这么几个组件啊也是经常用到的

01:03.050 --> 01:06.050
但这几个组件呢用起来都非常非常简单啊

01:06.050 --> 01:09.050
所以说我就把它专门拿一些课来讲就完事了

01:09.050 --> 01:13.050
这三个组件呢分别是link

01:13.050 --> 01:15.050
navlink

01:15.050 --> 01:18.050
还有这个redirect

01:18.050 --> 01:20.050
分别是这么三个

01:21.050 --> 01:23.050
一个说首先是link这个组件

01:23.050 --> 01:26.050
其实呢它是用来解决什么问题呢

01:26.050 --> 01:31.050
它是用来生成一个不刷新页面完成跳转的A元素

01:31.050 --> 01:37.050
生成一个无刷新跳转的A元素

01:37.050 --> 01:40.050
实际上呢你要说没有这个组件我们自己能不能玩的

01:40.050 --> 01:42.050
自己都可以做出这个组件出来

01:42.050 --> 01:44.050
非常非常简单啊

01:44.050 --> 01:47.050
比方说吧咱们做这么一个组件啊

01:47.050 --> 01:49.050
很简单一个组件

01:49.050 --> 01:52.050
比方说我们这里呢

01:52.050 --> 01:54.050
还是简单写一个路由吗

01:54.050 --> 01:55.050
简单写个路由

01:55.050 --> 01:58.050
import from

01:58.050 --> 02:00.050
react rotor

02:00.050 --> 02:02.050
动

02:02.050 --> 02:05.050
导入browser rotor

02:05.050 --> 02:09.050
导入那个

02:09.050 --> 02:11.050
那个route

02:11.050 --> 02:13.050
导入

02:13.050 --> 02:15.050
行了嘛就这两个啊导入这两个

02:16.050 --> 02:19.050
app里边呢我们这里写上就这么几个组件

02:19.050 --> 02:21.050
配级A

02:21.050 --> 02:23.050
这是

02:23.050 --> 02:25.050
A1

02:25.050 --> 02:27.050
这是第一页

02:27.050 --> 02:30.050
方式配级B

02:30.050 --> 02:32.050
这是第二页

02:32.050 --> 02:34.050
一层HB

02:36.050 --> 02:39.050
然后呢写这么一个导航吧

02:39.050 --> 02:41.050
咱们写这么一个导航

02:41.050 --> 02:43.050
navbar

02:43.050 --> 02:45.050
这么一个导航

02:45.050 --> 02:47.050
这个导航呢它生成一个div

02:47.050 --> 02:49.050
生成这么一个div

02:49.050 --> 02:51.050
div里边呢有两个A元数

02:51.050 --> 02:53.050
有两个A元数

02:53.050 --> 02:55.050
那么点击A元数呢一个跳转到A

02:55.050 --> 02:57.050
一个跳转到B

02:57.050 --> 02:59.050
就这么简单

02:59.050 --> 03:01.050
那么这个导航里边呢

03:01.050 --> 03:03.050
我们这里写上两个A元数

03:03.050 --> 03:05.050
一个A元数跳转到A

03:05.050 --> 03:07.050
去A

03:07.050 --> 03:09.050
一个A元数呢跳转到B

03:09.050 --> 03:11.050
去B

03:11.050 --> 03:13.050
那么这个导航

03:13.050 --> 03:15.050
在这个组件里边呢

03:15.050 --> 03:17.050
我们就直接写上一个nav

03:17.050 --> 03:19.050
这里直接写上一个rotor

03:19.050 --> 03:21.050
这里直接写上一个rotor

03:21.050 --> 03:23.050
rotor

03:23.050 --> 03:25.050
rotor

03:25.050 --> 03:27.050
然后里边呢写上一个navbar

03:27.050 --> 03:29.050
然后里边呢写上一个navbar

03:29.050 --> 03:31.050
navbar

03:31.050 --> 03:33.050
然后下边呢写上一个

03:33.050 --> 03:35.050
route对吧

03:35.050 --> 03:37.050
皮配了我开始进行皮配了

03:37.050 --> 03:39.050
route

03:39.050 --> 03:41.050
pass

03:41.050 --> 03:43.050
如果是斜杠A的话

03:43.050 --> 03:45.050
我们使用component

03:45.050 --> 03:47.050
A这个组件

03:47.050 --> 03:49.050
配几A

03:49.050 --> 03:51.050
另外呢如果说

03:51.050 --> 03:53.050
是斜杠B的话

03:53.050 --> 03:55.050
我们使用B这个组件

03:55.050 --> 03:57.050
这个非常简单啊要么确展A

03:57.050 --> 03:59.050
要么确展B对吧

03:59.050 --> 04:01.050
当然我们这里也拿着去写精确匹配了

04:01.050 --> 04:03.050
就这么回事

04:03.050 --> 04:05.050
保存啊咱们看一下

04:05.050 --> 04:07.050
那么目前的两个A元数

04:07.050 --> 04:09.050
这个怎么分开呢

04:09.050 --> 04:11.050
这个写上

04:11.050 --> 04:13.050
一个

04:13.050 --> 04:15.050
style

04:15.050 --> 04:17.050
难得去写样式了

04:17.050 --> 04:19.050
margin left

04:19.050 --> 04:21.050
比方说20

04:21.050 --> 04:25.450
margin right

04:25.450 --> 04:27.450
保存

04:27.450 --> 04:29.450
那么点击去A也没问题

04:29.450 --> 04:31.450
但是你看到页面是刷新的

04:31.450 --> 04:33.450
你看页面注意看这

04:33.450 --> 04:35.450
看这

04:35.450 --> 04:37.450
是刷新的对吧

04:37.450 --> 04:39.450
我们很多时候是不希望他刷新的

04:39.450 --> 04:41.450
没必要

04:41.450 --> 04:43.450
因为我们可能只是改一个

04:43.450 --> 04:45.450
只是做页面的组件切换

04:45.450 --> 04:47.450
并不需要重新去刷新页面

04:47.450 --> 04:49.450
重新去加载JS

04:49.450 --> 04:51.450
重新去加载那些公用的图片

04:51.450 --> 04:53.450
并不需要

04:53.450 --> 04:55.450
所以说我们为什么要做单页应用程序呢

04:55.450 --> 04:57.450
为什么会流行呢

04:57.450 --> 04:59.450
就是因为单页应用程序呢

04:59.450 --> 05:01.450
他不刷新页面

05:01.450 --> 05:03.450
不刷新页面的话用户的就是体验比较好

05:03.450 --> 05:05.450
二呢是浏览的效率比较高

05:05.450 --> 05:07.450
因为你每次刷新页面的

05:07.450 --> 05:09.450
要重新去访问服务器

05:09.450 --> 05:11.450
那么我们这里的使用A元素

05:11.450 --> 05:13.450
肯定是避免不了要刷新页面的

05:13.450 --> 05:15.450
那怎么办呢

05:15.450 --> 05:17.450
我们能不能做一个A元素出来

05:17.450 --> 05:19.450
让他不要刷新页面的

05:19.450 --> 05:21.450
当然可以,比方说我们自己做一个

05:21.450 --> 05:23.450
都不用他的了,我们自己做一个

05:23.450 --> 05:25.450
新建个文件,link

05:25.450 --> 05:27.450
自己做一个解释

05:27.450 --> 05:29.450
导出一个寒树组件

05:29.450 --> 05:31.450
就是link

05:31.450 --> 05:33.450
你给我一些属性

05:33.450 --> 05:35.450
生成一个A元素

05:35.450 --> 05:37.450
A元素

05:37.450 --> 05:39.450
这个A元素里边的内容填啥呢

05:39.450 --> 05:41.450
那就是你

05:41.450 --> 05:43.450
使用probs

05:43.450 --> 05:45.450
这个A元素的超链接地址呢

05:45.450 --> 05:47.450
我们就

05:47.450 --> 05:49.450
给不给超链接地址呢

05:49.450 --> 05:51.450
我都难得给超链接地址

05:51.450 --> 05:53.450
我就写个javascript

05:53.450 --> 05:55.450
就这样子写,警告就警告嘛

05:55.450 --> 05:57.450
他告诉你这样子没必要,没有意义

05:57.450 --> 05:59.450
无所谓警告就警告嘛

05:59.450 --> 06:01.450
保存,那咱们使用这个link元素看一下

06:01.450 --> 06:03.450
这里呢,我们就不使用A元素了

06:03.450 --> 06:05.450
使用link元素

06:05.450 --> 06:07.450
import link from

06:07.450 --> 06:09.450
javascript link

06:09.450 --> 06:12.890
这个很好写

06:12.890 --> 06:14.890
link

06:14.890 --> 06:16.890
那么这里呢,這個

06:16.890 --> 06:18.890
這個属性就没意义了,对吧

06:18.890 --> 06:20.890
没意义了

06:20.890 --> 06:22.890
把这个属性去掉

06:22.890 --> 06:24.890
保存

06:24.890 --> 06:26.890
那么这些属性呢,我们可以一次给它放过来吧

06:26.890 --> 06:28.890
把其他的属性一次放过来

06:28.890 --> 06:30.890
就是把这个属性

06:30.890 --> 06:32.890
东西一次放过来嘛

06:32.890 --> 06:34.890
一次放过来

06:34.890 --> 06:36.890
好了,那咱们呢,就写到这了

06:36.890 --> 06:38.890
保存

06:38.890 --> 06:40.890
看一下啊,右键

06:40.890 --> 06:42.890
我们看一下我们这里的生存的元素

06:42.890 --> 06:44.890
A元素是不是

06:44.890 --> 06:46.890
它指性断介绍嘛

06:46.890 --> 06:48.890
尽管什么都没有执行

06:48.890 --> 06:50.890
点击过后,是不是不刷新一面了

06:50.890 --> 06:52.890
对吧,不刷新一面了

06:52.890 --> 06:54.890
大致的原理就是这样子

06:54.890 --> 06:56.890
那么,那如何来完成跳转呢

06:56.890 --> 06:58.890
我如何来完成跳转呢

06:58.890 --> 07:00.890
我希望你这个属性里面

07:00.890 --> 07:02.890
给我传一个属性,叫做2

07:02.890 --> 07:04.890
到哪儿去

07:04.890 --> 07:06.890
我要跳转到A

07:06.890 --> 07:08.890
真的,2,跳转到B

07:08.890 --> 07:10.890
比方说你传这么两个属性给我

07:10.890 --> 07:12.890
OK,那传了这两个属性给我之后呢

07:12.890 --> 07:14.890
我这里呢,给这个A元素呢

07:14.890 --> 07:16.890
注册点击事件

07:16.890 --> 07:18.890
onclick,点击事件

07:18.890 --> 07:20.890
当点击这个A元素的时候,干嘛呢

07:20.890 --> 07:22.890
我们

07:22.890 --> 07:24.890
是不是可以使用Props里面

07:25.890 --> 07:27.890
Push来进行跳转

07:27.890 --> 07:28.890
Push啥呢

07:28.890 --> 07:30.890
Push是不是Props里面的2

07:30.890 --> 07:31.890
对不对

07:31.890 --> 07:33.890
你给我传的2就是我跳转的地址

07:33.890 --> 07:35.890
我这样子跳转就完成了

07:35.890 --> 07:36.890
这个警告看起来真的烦

07:36.890 --> 07:38.890
我把它去掉,我把它去掉

07:38.890 --> 07:40.890
这个警告是这个

07:40.890 --> 07:42.890
就这个

07:42.890 --> 07:44.890
就这个玩意儿

07:44.890 --> 07:46.890
我们把它写个注册,警告去掉

07:46.890 --> 07:48.890
yes, need

07:48.890 --> 07:52.970
这样子

07:52.970 --> 07:54.970
发设为off

07:56.970 --> 07:58.970
没关掉吗,关不掉吗

07:58.970 --> 08:00.970
还是

08:00.970 --> 08:07.290
OK,那这个警告呢

08:07.290 --> 08:09.290
scripps url is

08:09.290 --> 08:11.290
form of evil

08:11.290 --> 08:13.290
no script url

08:13.290 --> 08:15.290
加上

08:15.290 --> 08:17.290
off

08:17.290 --> 08:19.290
OK,把它去掉

08:19.290 --> 08:21.290
把警告去掉

08:21.290 --> 08:23.290
然后呢,我们这里呢,就是直接使用History

08:23.290 --> 08:25.290
Push就完成了

08:25.290 --> 08:27.290
那么,但是呢,这个Props里面

08:27.290 --> 08:29.290
是不是没有History属性啊,我们之前讲过

08:29.290 --> 08:31.290
对吧,是不是没有

08:31.290 --> 08:33.290
没有怎么办

08:33.290 --> 08:35.290
没有怎么办

08:35.290 --> 08:37.290
是不是with rotor

08:37.290 --> 08:39.290
对不对,把它包装一下嘛

08:39.290 --> 08:41.290
它不就有一个高阶主键嘛

08:41.290 --> 08:43.290
with rotor嘛,对不对

08:43.290 --> 08:45.290
包装一下,反回

08:45.290 --> 08:47.290
把这个新的包装之后的主键反回不就有了嘛

08:47.290 --> 08:49.290
对不对,所以说我们这里导入一个

08:49.290 --> 08:51.290
import with rotor

08:51.290 --> 08:53.290
with rotor

08:53.290 --> 08:55.290
from rex rotor

08:55.290 --> 08:57.290
保存啊,看一下

08:57.290 --> 08:59.290
这里还有错误啊,在说什么

08:59.290 --> 09:01.290
rex does not recognize

09:01.290 --> 09:03.290
the static context problem

09:03.290 --> 09:05.290
on the dome

09:05.290 --> 09:07.290
elements

09:07.290 --> 09:09.290
哦,我明白了

09:09.290 --> 09:11.290
我明白了

09:11.290 --> 09:13.290
是我们这里的处理

09:13.290 --> 09:15.290
不妥啊,这里的处理不是很妥当

09:15.290 --> 09:17.290
因为我们这里的处理的时候呢

09:17.290 --> 09:19.290
我把所有的属性给它放到这个A元数上面

09:19.290 --> 09:21.290
但是,其中有些属性呢

09:21.290 --> 09:23.290
是不能放上去的

09:23.290 --> 09:25.290
它说到其中一个属性叫做Static Context

09:25.290 --> 09:27.290
这个属性是不能放上去的

09:27.290 --> 09:29.290
是不能放到Dome元数上面去的

09:29.290 --> 09:31.290
无所谓嘛

09:31.290 --> 09:33.290
我们现在只是做一个

09:33.290 --> 09:35.290
原理性的介绍

09:35.290 --> 09:37.290
所以说我们这里的也不过多说了

09:37.290 --> 09:39.290
我们不要这个属性吧

09:39.290 --> 09:41.290
不要这个属性就完事了

09:41.290 --> 09:43.290
然后呢,我们去A叶看一下

09:43.290 --> 09:45.290
去B叶,是不是不刷新的

09:45.290 --> 09:47.290
不刷新完成跳转的

09:47.290 --> 09:49.290
基本原理就是这样子

09:49.290 --> 09:51.290
它给你生成一个A元数

09:51.290 --> 09:53.290
这个A元数呢,它是会阻止默认行为的

09:53.290 --> 09:55.290
它没有默认,它没有跳转的功能

09:55.290 --> 09:57.290
它只是给它做出了一个点击事件

09:57.290 --> 09:59.290
当你点击的时候呢

09:59.290 --> 10:01.290
使用Push,把它加

10:01.290 --> 10:03.290
来进行跳转A面

10:03.290 --> 10:05.290
实际上它就可以做了这么一个东西

10:05.290 --> 10:07.290
我们这里讲的这个Link元数呢

10:07.290 --> 10:09.290
只是说不用我们自己写了

10:09.290 --> 10:11.290
它可以已经帮你写好了,直接用就行了

10:11.290 --> 10:13.290
那么具体怎么用呢

10:13.290 --> 10:15.290
看一下,这里具体怎么用

10:15.290 --> 10:17.290
那么这里呢,我们就不再使用我们自己写的Link了

10:17.290 --> 10:19.290
不再使用自己写的Link了

10:19.290 --> 10:21.290
而是使用它给你提供了这个Link

10:21.290 --> 10:23.290
是一样的

10:23.290 --> 10:25.290
用法是一样的

10:25.290 --> 10:27.290
保存力看一下

10:27.290 --> 10:29.290
啥都没改

10:29.290 --> 10:31.290
可以生成A元数

10:31.290 --> 10:33.290
这两个A元数呢

10:33.290 --> 10:35.290
虽然说它们有REF地址

10:35.290 --> 10:37.290
但是呢,它在点击事件里边

10:37.290 --> 10:39.290
已经阻止了默认行为了

10:39.290 --> 10:41.290
我们刚才应该这样子写,应该这样子写好一点

10:41.290 --> 10:43.290
就这里呢

10:43.290 --> 10:45.290
我仍然给你一个2

10:45.290 --> 10:47.290
仍然给你一个2

10:47.290 --> 10:49.290
但是点击事件里边

10:49.290 --> 10:51.290
我们用这个参数E

10:53.290 --> 10:55.290
prevent

10:55.290 --> 10:57.290
prevent default,阻止默认行为

10:57.290 --> 10:59.290
对吧,我们刚才可以

10:59.290 --> 11:01.290
应该可以这样子写

11:01.290 --> 11:03.290
保存,那我们再试一下

11:03.290 --> 11:07.300
刚才的写法

11:07.300 --> 11:09.300
你看一下,是一样的效果

11:09.300 --> 11:11.300
A,B,A,B

11:11.300 --> 11:13.300
这两个A元数,看上去是两个超链接

11:13.300 --> 11:15.300
但是呢,由于

11:15.300 --> 11:17.300
我们使用了就是

11:17.300 --> 11:19.300
阻止默认行为

11:19.300 --> 11:21.300
点击事件,阻止了默认行为

11:21.300 --> 11:23.300
因此呢

11:23.300 --> 11:25.300
因此呢,它不会真正的去发生

11:25.300 --> 11:27.300
跳转页面

11:27.300 --> 11:29.300
就这么回事,大概原理就是这样子

11:29.300 --> 11:31.300
这里呢,我们使用它的link

11:31.300 --> 11:33.300
用法是完全一样的,你看到

11:33.300 --> 11:35.300
用法是完全一样的

11:35.300 --> 11:37.300
就是设这个to

11:37.300 --> 11:39.300
那么其他的东西呢,可以直接给它复着在

11:39.300 --> 11:41.300
动物元素上面

11:41.300 --> 11:43.300
保存,你看一下

11:43.300 --> 11:45.300
它就无刷新跳转了

11:45.300 --> 11:47.300
就这么简单,没有什么特别复杂的

11:47.300 --> 11:49.300
这是关于这个link

11:49.300 --> 11:51.300
那么这个link的to这个属性

11:51.300 --> 11:53.300
我说一下,这个to这个属性

11:53.300 --> 11:55.300
to这个属性呢,它可以是一个制服串

11:55.300 --> 11:57.300
刚才我们使用的是制服串

11:57.300 --> 11:59.300
对吧,表示跳转的地址

11:59.300 --> 12:01.300
跳转的目标地址

12:01.300 --> 12:03.300
这个呢,也是我们常用的一种方式

12:03.300 --> 12:05.300
另外一种方式呢,要稍微繁确一点

12:05.300 --> 12:07.300
就是使用对象

12:07.300 --> 12:09.300
它可以是个对象,这个对象呢,有这么一些属性

12:09.300 --> 12:11.300
一个是passnet

12:11.300 --> 12:13.300
表示的是

12:13.300 --> 12:15.300
路径

12:15.300 --> 12:17.300
就是uil路径

12:17.300 --> 12:19.300
因为我们之前讲过,uil它有几个部分

12:19.300 --> 12:21.300
组成,对吧,一个是路径pass的一部分

12:21.300 --> 12:23.300
还有一个是什么search

12:23.300 --> 12:25.300
就表示search的一部分

12:25.300 --> 12:27.300
还有哈希

12:27.300 --> 12:29.300
还有什么stat

12:29.300 --> 12:31.300
这stat表示的是

12:31.300 --> 12:33.300
附加的状态信息

12:33.300 --> 12:35.300
我们之前讲的一个historyapi

12:35.300 --> 12:37.300
它里边是不是可以附加状态信息

12:37.300 --> 12:39.300
那么就相当于是这个东西

12:39.300 --> 12:41.300
跳过去那边可以通过history来拿到这个信息

12:41.300 --> 12:43.300
就这么个意思

12:43.300 --> 12:45.300
好,那么这是个to

12:45.300 --> 12:47.300
好,咱们来看一下吧

12:47.300 --> 12:49.300
不要跳到b

12:49.300 --> 12:51.300
我们可以用to,把它写成对象

12:51.300 --> 12:53.300
passnet

12:53.300 --> 12:55.300
使用什么呢,使用那个写杠币

12:55.300 --> 12:57.300
好,然后哈希

12:57.300 --> 12:59.300
加上一个嘛

12:59.300 --> 13:01.300
abc,随便乱讲

13:01.300 --> 13:03.300
search,加上一个,就是把它分成几段

13:03.300 --> 13:05.300
当然也可以把它写成一个字母数

13:05.300 --> 13:07.300
直接写成一个字母数也可以

13:07.300 --> 13:09.300
也等于1,b等于2

13:09.300 --> 13:11.300
随便写写吧,就完了

13:11.300 --> 13:13.300
看一下

13:13.300 --> 13:15.300
那么这是去a叶

13:15.300 --> 13:17.300
去b叶,跳到哪儿去了

13:17.300 --> 13:19.300
跳到哪儿去了,去a叶

13:19.300 --> 13:21.300
其他都没啥

13:21.300 --> 13:23.300
这是这个link

13:23.300 --> 13:25.300
link

13:25.300 --> 13:27.300
想象还有啥呢,这个玩意儿

13:27.300 --> 13:29.300
除了to属性之外,还有啥呢

13:29.300 --> 13:31.300
当它有这么一个属性

13:31.300 --> 13:33.300
叫做replace

13:33.300 --> 13:35.300
它是个布尔兹

13:35.300 --> 13:37.300
布尔兹表示

13:37.300 --> 13:39.300
是否

13:39.300 --> 13:41.300
是替换

13:41.300 --> 13:43.300
替换当前地址

13:43.300 --> 13:45.300
就是我们不是history

13:45.300 --> 13:47.300
APN里面,就是history里面

13:47.300 --> 13:49.300
不是有个poohy吗,还有一个replace

13:49.300 --> 13:51.300
那么到底是怎么来跳转

13:51.300 --> 13:53.300
它是用poohy来跳转

13:53.300 --> 13:55.300
还是用replace来跳转

13:55.300 --> 13:57.300
默认是poohy跳转

13:57.300 --> 13:59.300
默认是force

13:59.300 --> 14:01.300
默认是force

14:01.300 --> 14:03.300
那么也就是不写它的话

14:03.300 --> 14:05.300
它就是

14:05.300 --> 14:07.300
用poohy的方式来跳转

14:07.300 --> 14:09.300
这东西都没啥好说的

14:09.300 --> 14:11.300
你也看不到啥效果

14:11.300 --> 14:13.300
加上这个玩意儿就完事了

14:13.300 --> 14:15.300
加上过后来它就是用

14:15.300 --> 14:17.300
替换的方式来跳转

14:17.300 --> 14:19.300
就不是用poohy的

14:19.300 --> 14:21.300
就这个东西

14:21.300 --> 14:23.300
还有啥呢

14:23.300 --> 14:25.300
2replace

14:25.300 --> 14:27.300
还有那个

14:27.300 --> 14:29.300
inner rift

14:29.300 --> 14:31.300
这个就指的是

14:31.300 --> 14:33.300
可以复制为函数

14:33.300 --> 14:35.300
函数或者是

14:35.300 --> 14:37.300
Rift对象

14:37.300 --> 14:39.300
你懂什么意思对吧

14:39.300 --> 14:41.300
它可以用来做什么呢

14:41.300 --> 14:43.300
可以将

14:43.300 --> 14:45.300
内部的a元数的Rift

14:45.300 --> 14:47.300
复作在

14:47.300 --> 14:49.300
传递的

14:49.300 --> 14:51.300
对象

14:51.300 --> 14:53.300
或函数

14:53.300 --> 14:55.300
参数上

14:55.300 --> 14:57.300
就相当于是Rift

14:57.300 --> 14:59.300
你找到的不是这个组件本身

14:59.300 --> 15:01.300
找到的是它里边的a元数

15:01.300 --> 15:03.300
你使用这个

15:03.300 --> 15:05.300
就这么个意思

15:05.300 --> 15:07.300
你使用这个属性

15:07.300 --> 15:09.300
比方说吧

15:09.300 --> 15:11.300
使用一个

15:11.300 --> 15:13.300
inner rift

15:13.300 --> 15:15.300
看一下就行了

15:15.300 --> 15:17.300
这里它会给你一个参数

15:17.300 --> 15:19.300
参数其实是啥呢

15:19.300 --> 15:21.300
就是它里边的a元数

15:21.300 --> 15:23.300
输出一下

15:23.300 --> 15:25.300
你看一下

15:25.300 --> 15:27.300
就是里边的a元数

15:27.300 --> 15:29.300
输出就是里边的a元数

15:29.300 --> 15:31.300
没啥了

15:31.300 --> 15:33.300
这些东西都可以传

15:33.300 --> 15:35.300
函数对象

15:35.300 --> 15:37.300
需要的属性

15:37.300 --> 15:39.300
style,class name

15:39.300 --> 15:41.300
都可以传

15:41.300 --> 15:43.300
它会把它夹到a元数上面去

15:43.300 --> 15:45.300
就这个link

15:45.300 --> 15:47.300
这个组件

15:47.300 --> 15:49.300
非常简单的一个组件

15:49.300 --> 15:51.300
这个组件说完了

15:51.300 --> 15:53.300
过后我们再说下面这个组件

15:53.300 --> 15:55.300
下面这个组件

15:55.300 --> 15:57.300
可有可无

15:57.300 --> 15:59.300
其实连这个东西都可有可无

15:59.300 --> 16:01.300
我们就少写些代码

16:01.300 --> 16:03.300
别人一定做好了

16:03.300 --> 16:05.300
它不是很重要

16:05.300 --> 16:07.300
下面这个组件叫nevlink

16:07.300 --> 16:09.300
nevlink实际上是一种

16:09.300 --> 16:11.300
特殊的link

16:11.300 --> 16:13.300
上面那个组件有的东西它都有

16:13.300 --> 16:15.300
link

16:15.300 --> 16:17.300
组件

16:17.300 --> 16:19.300
具备的功能

16:19.300 --> 16:21.300
它都有

16:21.300 --> 16:23.300
比方说到这几个属性对吧

16:23.300 --> 16:25.300
它都有

16:25.300 --> 16:27.300
它具有一些额外的属性

16:27.300 --> 16:29.300
它具备的

16:29.300 --> 16:31.300
额外功能是

16:31.300 --> 16:33.300
是什么呢?就是根据

16:33.300 --> 16:35.300
当前

16:35.300 --> 16:37.300
地址

16:37.300 --> 16:38.300
和

16:38.300 --> 16:40.300
链接地址

16:40.300 --> 16:42.300
这是两个东西搞清楚

16:42.300 --> 16:43.300
这是两个东西

16:43.300 --> 16:45.300
什么叫当前地址

16:45.300 --> 16:47.300
你看这一部分

16:47.300 --> 16:49.300
叫当前地址

16:49.300 --> 16:51.300
什么叫做链接地址

16:51.300 --> 16:53.300
你看这个a元数这个鞋杠a

16:53.300 --> 16:55.300
叫做链接地址看到没

16:55.300 --> 16:57.300
这是当前地址

16:57.300 --> 16:59.300
浏览器的地址

16:59.300 --> 17:01.300
这是链接地址

17:01.300 --> 17:03.300
根据这两个

17:03.300 --> 17:05.300
来决定

17:05.300 --> 17:07.300
该元数

17:07.300 --> 17:09.300
该链接的

17:09.300 --> 17:11.300
样式它就多了这么一个功能

17:11.300 --> 17:13.300
就是有的时候呢比方说吧

17:13.300 --> 17:15.300
我们

17:15.300 --> 17:17.300
如果说现在就已经是必这个页面了

17:17.300 --> 17:19.300
对吧已经是必这个页面了

17:19.300 --> 17:21.300
那么比方说我要把它写成红色

17:21.300 --> 17:23.300
说明啥呢?说明这个超链接

17:23.300 --> 17:25.300
就已经是必这个页面了

17:25.300 --> 17:27.300
就这么个意思

17:27.300 --> 17:29.300
如果说现在是a这个页面了

17:29.300 --> 17:31.300
我们就要把它把这个东西

17:31.300 --> 17:33.300
显示成红色

17:33.300 --> 17:35.300
那么就是要根据什么

17:35.300 --> 17:37.300
根据浏览器地址

17:37.300 --> 17:39.300
和

17:39.300 --> 17:41.300
这个超链接的地址进行匹配

17:41.300 --> 17:43.300
如果匹配上了

17:43.300 --> 17:45.300
就会用一个

17:45.300 --> 17:47.300
不同的样式来显示

17:47.300 --> 17:49.300
这是这个navlink

17:49.300 --> 17:51.300
我们来用一下

17:51.300 --> 17:53.300
好复制一下

17:53.300 --> 17:55.300
这里呢我们就非常简单的

17:55.300 --> 17:57.300
把它这个navlink

17:57.300 --> 17:59.300
把它变成navlink就得了

17:59.300 --> 18:01.300
好

18:01.300 --> 18:02.300
这里呢变成navlink

18:02.300 --> 18:03.300
这里也是变成navlink

18:03.300 --> 18:05.300
其他都一样

18:05.300 --> 18:07.300
好保存

18:07.300 --> 18:09.300
你看一下会有什么样的区别

18:09.300 --> 18:12.620
好看着啊

18:12.620 --> 18:14.620
好那么这里呢你看目前显示的是

18:14.620 --> 18:16.620
a也对吧

18:16.620 --> 18:18.620
目前显示的是a也

18:18.620 --> 18:20.620
于是呢由于浏览器的地址

18:20.620 --> 18:22.620
a跟这个超链接的地址

18:22.620 --> 18:24.620
a是不是匹配的

18:24.620 --> 18:26.620
这两个路径是匹配的吧

18:26.620 --> 18:28.620
好那么既然是匹配的

18:28.620 --> 18:30.620
于是呢你会发现

18:30.620 --> 18:32.620
这个a这个

18:32.620 --> 18:34.620
第一个超链接呢

18:34.620 --> 18:36.620
它加了一个class active

18:36.620 --> 18:38.620
看到没

18:38.620 --> 18:40.620
你看之前那个a元素没有这样做吧

18:40.620 --> 18:42.620
现在就这样做了就多了这个区别

18:42.620 --> 18:44.620
其他都没啥

18:44.620 --> 18:46.620
然后前面是一个无障碍属性嘛

18:46.620 --> 18:48.620
这个东西没啥说的

18:49.620 --> 18:51.620
那么我们如果说我们这里有个

18:51.620 --> 18:53.620
那样式啊有个央视代码

18:53.620 --> 18:55.620
app.css

18:55.620 --> 18:57.620
我们在这里写上一个active

18:57.620 --> 18:59.620
啊

18:59.620 --> 19:00.620
color呢是为红色

19:00.620 --> 19:02.620
takes a declaration

19:02.620 --> 19:04.620
是为nav

19:04.620 --> 19:06.620
然后cursor呢是为

19:06.620 --> 19:07.620
out to

19:07.620 --> 19:09.620
好保存啊然后我们在这里边去

19:09.620 --> 19:11.620
导入这个央视代码

19:11.620 --> 19:13.620
import

19:13.620 --> 19:15.620
app.css

19:15.620 --> 19:16.620
保存

19:16.620 --> 19:18.620
好你看一下那现在是不是它

19:18.620 --> 19:20.620
它是一种啊有一个特别的样式

19:20.620 --> 19:22.620
那么去毕业

19:22.620 --> 19:24.620
然后这个b是不是有这种特别的样式

19:24.620 --> 19:26.620
对吧就这么个意思啊就是

19:26.620 --> 19:28.620
就是它的就是这个nav link

19:28.620 --> 19:30.620
和那个link的最大区别就在于这

19:30.620 --> 19:32.620
它央视是不一样的啊央视是不一样的

19:32.620 --> 19:34.620
好那么比方说啊我们这里

19:34.620 --> 19:36.620
如果说我这里没有写参数

19:36.620 --> 19:38.620
没有写参数行不行呢也能匹配

19:38.620 --> 19:40.620
也能匹配它的匹配方式呢

19:40.620 --> 19:42.620
跟那个roach的匹配方式是一样的

19:42.620 --> 19:44.620
啊我们之前写了个roach

19:44.620 --> 19:46.620
这个逐渐对吧跟它的匹配方式

19:46.620 --> 19:48.620
是一样的啊它是不管什么参数

19:48.620 --> 19:50.620
不参就是这个surge

19:50.620 --> 19:52.620
它是不管的啊不管的

19:52.620 --> 19:54.620
没有意思吧好只要匹配上了

19:54.620 --> 19:56.620
啊就拿这个地址

19:56.620 --> 19:58.620
拿这个这个

19:58.620 --> 20:00.620
和if地址呢跟这个

20:00.620 --> 20:02.620
当前那个路径来进行匹配

20:02.620 --> 20:04.620
就这么个意思

20:04.620 --> 20:06.620
好那么这个元素里边呢

20:06.620 --> 20:08.620
它其实还有多了一些属性啊多了一些属性

20:08.620 --> 20:10.620
比方说啊他有这么一个属性

20:10.620 --> 20:12.620
叫做

20:12.620 --> 20:14.620
active class

20:14.620 --> 20:16.620
active class

20:16.620 --> 20:18.620
应该叫这个属性名字啊咱们试一下啊

20:18.620 --> 20:20.620
比方说我们这里的

20:20.620 --> 20:22.620
内样式呢它不叫做active

20:22.620 --> 20:24.620
它叫做

20:24.620 --> 20:26.620
另一个名字啊叫做snegative

20:26.620 --> 20:28.620
叫做这个名字

20:28.620 --> 20:30.620
那这样子以来的话这个样式又应用不进去了

20:30.620 --> 20:32.620
对吧因为他用的样式呢是active

20:32.620 --> 20:34.620
我们希望把这个样式名字

20:34.620 --> 20:36.620
换一下可不可以换呢可以

20:36.620 --> 20:38.620
它这里边有个属性叫做

20:38.620 --> 20:40.620
active

20:40.620 --> 20:42.620
class name

20:42.620 --> 20:44.620
这个属性

20:44.620 --> 20:46.620
active class name

20:46.620 --> 20:48.620
就是匹配使

20:48.620 --> 20:50.620
使用的

20:50.620 --> 20:52.620
内名

20:52.620 --> 20:54.620
匹配使用的内名

20:54.620 --> 20:56.620
那么这个内名呢我们给它写上

20:56.620 --> 20:58.620
写成snegative

20:58.620 --> 21:00.620
那么这样子一旦匹配过后呢它就会使用这个内名了

21:00.620 --> 21:02.620
看一下

21:02.620 --> 21:04.620
保存

21:04.620 --> 21:06.620
你看是不是这样子啊对吧它变成了snegative了

21:06.620 --> 21:08.620
就这么简单

21:08.620 --> 21:10.620
啊你看对吧

21:10.620 --> 21:12.620
好然后还有什么属性呢

21:12.620 --> 21:14.620
还有这个属性

21:14.620 --> 21:16.620
来来来写吧

21:16.620 --> 21:18.620
active style

21:18.620 --> 21:20.620
这个属性呢它是什么样子呢

21:20.620 --> 21:22.620
说一下啊这个属性呢是

21:22.620 --> 21:24.620
匹配使

21:24.620 --> 21:26.620
匹配使使用的

21:26.620 --> 21:28.620
样式

21:28.620 --> 21:30.620
使用的内年样式

21:30.620 --> 21:32.620
就相当于是元素里面的这个style

21:32.620 --> 21:34.620
就相当于是元素里面的这个style

21:34.620 --> 21:36.620
如果匹配的时候呢它才生效

21:36.620 --> 21:38.620
比如说我们这里给它写上一个

21:38.620 --> 21:40.620
写上一个啥了

21:40.620 --> 21:42.620
背景颜色吗

21:42.620 --> 21:44.620
背景颜色为

21:44.620 --> 21:46.620
为啥了

21:46.620 --> 21:48.620
为ccc

21:48.620 --> 21:50.620
啊

21:50.620 --> 21:52.620
随便写上一个吧

21:52.620 --> 21:54.620
这里也写上一个一样的啊

21:54.620 --> 21:56.620
保存

21:56.620 --> 21:58.620
来看是不是多了一个style

21:58.620 --> 22:00.620
一看没style加了一个background

22:00.620 --> 22:02.620
就这么个意思啊

22:02.620 --> 22:04.620
这是关于这个

22:04.620 --> 22:06.620
然后另外呢

22:06.620 --> 22:08.620
它还有一个属性叫做

22:08.620 --> 22:10.620
嗯

22:10.620 --> 22:12.620
叫啥来着了

22:12.620 --> 22:14.620
叫做

22:14.620 --> 22:16.620
对exact

22:16.620 --> 22:18.620
是不跟那个rotr是一样的啊

22:18.620 --> 22:20.620
是否精确匹配

22:20.620 --> 22:22.620
什么意思呢

22:22.620 --> 22:24.620
就是说如果说呢我这里访问的地址

22:24.620 --> 22:26.620
是鞋杠A 鞋杠B 鞋杠C

22:26.620 --> 22:28.620
这样子访问它能不能匹配了

22:28.620 --> 22:30.620
默认情况下也是能匹配的

22:30.620 --> 22:32.620
也就是说默认情况下

22:32.620 --> 22:34.620
根本不是精确匹配

22:34.620 --> 22:36.620
那如果说我给它加上了一个

22:36.620 --> 22:38.620
exact

22:38.620 --> 22:40.620
再加上这个东西

22:40.620 --> 22:42.620
加上它之后呢我们再看一下

22:42.620 --> 22:44.620
是不是现在就没有这个样式了

22:44.620 --> 22:46.620
它匹配不上了啊

22:46.620 --> 22:48.620
就这么个意思啊跟那个rotr是一样的

22:48.620 --> 22:50.620
只是rotr匹配完了过后

22:50.620 --> 22:52.620
选了一个组件

22:52.620 --> 22:54.620
这个匹配完了过后加一个样式

22:54.620 --> 22:56.620
仅此而已啊对吧

22:56.620 --> 22:58.620
它还有什么呢还有那个

22:58.620 --> 23:00.620
深Ctv对吧

23:00.620 --> 23:02.620
Ctv对吧

23:02.620 --> 23:04.620
是否匹配时

23:04.620 --> 23:06.620
是否

23:06.620 --> 23:08.620
区分大小些

23:08.620 --> 23:10.620
大小些对吧这东西都有

23:10.620 --> 23:12.620
还有什么regs

23:12.620 --> 23:14.620
这个跟那个rotr是一样的

23:14.620 --> 23:16.620
Rotr里面我没有讲regs

23:16.620 --> 23:18.620
regs是

23:18.620 --> 23:20.620
是否精确匹配

23:20.620 --> 23:22.620
是否严格匹配

23:22.620 --> 23:24.620
最后一个

23:24.620 --> 23:26.620
鞋杠

23:26.620 --> 23:28.620
是不是严格匹配最后一个鞋杠

23:28.620 --> 23:30.620
就是这么个意思

23:30.620 --> 23:32.620
什么意思呢我给它说一下吧

23:32.620 --> 23:34.620
比方说吧我们这里说

23:34.620 --> 23:36.620
它是一个精确匹配

23:36.620 --> 23:38.620
它是一个精确匹配

23:38.620 --> 23:40.620
然后呢

23:40.620 --> 23:42.620
加上一个strict

23:42.620 --> 23:44.620
我们给它的路径是鞋杠A对吧

23:44.620 --> 23:46.620
给它的路径是鞋杠A

23:46.620 --> 23:48.620
保存

23:48.620 --> 23:50.620
如果说我们这样去访问鞋杠A

23:50.620 --> 23:52.620
它自然能匹配对吧

23:52.620 --> 23:54.620
那如果说我们访问鞋杠A 鞋杠呢

23:54.620 --> 23:56.620
它能不能匹配了它就不能匹配了

23:56.620 --> 23:58.620
它这个stricts呢

23:58.620 --> 24:00.620
保存

24:00.620 --> 24:02.620
你看到鞋杠A 鞋杠也是能匹配的

24:02.620 --> 24:04.620
懂这个意思吧

24:04.620 --> 24:06.620
stricts表示严格路径

24:06.620 --> 24:08.620
是不是严格匹配最后一个鞋杠

24:08.620 --> 24:10.620
指的是这么个意思

24:10.620 --> 24:12.620
当然这个roach里面也有

24:12.620 --> 24:14.620
只不过这个东西用的很少

24:14.620 --> 24:16.620
这是Levelink

24:16.620 --> 24:18.620
它主要是用来

24:18.620 --> 24:20.620
做那个匹配的时候

24:20.620 --> 24:22.620
有一个那样式的这么一个超链结

24:22.620 --> 24:24.620
其他都没啥

24:24.620 --> 24:26.620
好 下面这个组件

24:26.620 --> 24:28.620
readyregs

24:28.620 --> 24:30.620
它叫做重定向组件

24:30.620 --> 24:32.620
这个组件有什么用呢

24:32.620 --> 24:34.620
它是指的是

24:34.620 --> 24:36.620
当夹载到

24:36.620 --> 24:38.620
该组件时

24:38.620 --> 24:40.620
会自动

24:40.620 --> 24:42.620
挑转

24:42.620 --> 24:44.620
当然是无刷新的挑转

24:44.620 --> 24:46.620
挑转到另外一个地址

24:46.620 --> 24:48.620
这就是readyregs

24:48.620 --> 24:50.620
重定向

24:50.620 --> 24:52.620
从这个地址直接挑到另一个地址

24:52.620 --> 24:54.620
我给你演示一下这个组件

24:54.620 --> 24:56.620
这里面

24:56.620 --> 24:58.620
我们

24:58.620 --> 25:00.620
比方说吧

25:00.620 --> 25:02.620
就这么两个页面

25:02.620 --> 25:04.620
a和b

25:04.620 --> 25:06.620
就这么两个页面 没有别的页面

25:06.620 --> 25:08.620
只有这两个页面 a和b

25:08.620 --> 25:10.620
然后

25:10.620 --> 25:12.620
你访问其他页面的时候

25:12.620 --> 25:14.620
我全部要把它挑转到a

25:14.620 --> 25:16.620
你要这意思吧 我现在要做的事情就是

25:16.620 --> 25:18.620
如果说你要访问其他页面

25:18.620 --> 25:20.620
我全部给你挑转到a

25:20.620 --> 25:22.620
挑转到a这个页面

25:22.620 --> 25:24.620
那么这里怎么来做呢

25:24.620 --> 25:26.620
怎么来做呢

25:26.620 --> 25:28.620
看着我们可以用这种方式来处理

25:28.620 --> 25:30.620
这里加上一个switch

25:30.620 --> 25:32.620
switch

25:32.620 --> 25:34.620
然后这里把包起来

25:34.620 --> 25:36.620
switch

25:36.620 --> 25:38.620
switch

25:38.620 --> 25:40.620
把包起来

25:40.620 --> 25:42.620
这个放上面

25:42.620 --> 25:44.620
这个root

25:44.620 --> 25:46.620
放这里

25:46.620 --> 25:48.620
接下来

25:48.620 --> 25:50.620
ok 那就去渲染这个页面

25:50.620 --> 25:52.620
没问题

25:52.620 --> 25:54.620
如果说你匹配到b

25:54.620 --> 25:56.620
ok 你去渲染这个页面

25:56.620 --> 25:58.620
那如果说你前面两个都没有匹配到

25:58.620 --> 26:00.620
那对不起 我没有其他页面了

26:00.620 --> 26:02.620
我给你自动挑转到a

26:02.620 --> 26:04.620
那怎么来完成自动挑转呢

26:04.620 --> 26:06.620
怎么来完成自动挑转呢

26:06.620 --> 26:08.620
我们就可以使用 ready rate

26:08.620 --> 26:10.620
倒进来

26:10.620 --> 26:12.620
ready rate

26:12.620 --> 26:14.620
使用这个组件

26:14.620 --> 26:16.620
看这个组件怎么用

26:16.620 --> 26:18.620
ready rate 非常简单

26:18.620 --> 26:20.620
ready rate

26:20.620 --> 26:22.620
ready rate就是挑转的意思

26:22.620 --> 26:24.620
这个组件里边有个属性to

26:24.620 --> 26:26.620
to表示什么意思呢

26:26.620 --> 26:28.620
就指的是挑转的地址

26:28.620 --> 26:30.620
to

26:30.620 --> 26:32.620
表示

26:32.620 --> 26:34.620
挑转的地址

26:34.620 --> 26:36.620
它有两种写法

26:36.620 --> 26:38.620
一种是制服串

26:38.620 --> 26:40.620
一种是对象

26:40.620 --> 26:42.620
跟那个link的to是完全一样的

26:42.620 --> 26:44.620
没有什么区别

26:44.620 --> 26:46.620
保存 你看一下

26:46.620 --> 26:48.620
好 那么现在去a也去b也都没有问题

26:48.620 --> 26:50.620
对吧

26:50.620 --> 26:52.620
好 那么接下来我如果访问这个跟目录

26:52.620 --> 26:54.620
是不是没有这样的地址

26:54.620 --> 26:56.620
没有匹配到任何东西

26:56.620 --> 26:58.620
你看 是不是自动跑到a里面去了

26:58.620 --> 27:00.620
你看这个地址

27:00.620 --> 27:02.620
看没 是不是自动跑到a里面去了

27:02.620 --> 27:04.620
没问题吧

27:04.620 --> 27:06.620
它只能到a 看没

27:06.620 --> 27:08.620
因为我们只能匹配到a 匹配到b

27:08.620 --> 27:10.620
前面两个都没有匹配

27:10.620 --> 27:12.620
那么进入它匹配这个东西

27:12.620 --> 27:14.620
挑转到a了 就这么简单

27:14.620 --> 27:16.620
重新把地址挑转到a

27:16.620 --> 27:18.620
那么触发重新渲染

27:18.620 --> 27:20.620
重新渲染过后 地址挑转到a过后

27:20.620 --> 27:22.620
那你看 是不是渲染它了

27:22.620 --> 27:24.620
就这么简单

27:24.620 --> 27:26.620
然后我们比方说再加一个link

27:26.620 --> 27:28.620
再加一个link

27:28.620 --> 27:33.980
再加一个这个东西

27:33.980 --> 27:35.980
nevlink

27:35.980 --> 27:37.980
这里边我们写上

27:37.980 --> 27:41.540
其他页

27:41.540 --> 27:43.540
复制一下

27:43.540 --> 27:45.540
复制一下

27:45.540 --> 27:47.540
然后这里我们写上一个

27:47.540 --> 27:49.540
2

27:49.540 --> 27:51.540
比方说挑转到abc

27:51.540 --> 27:53.540
挑转到这个页面

27:53.540 --> 27:55.540
保存 你看一下

27:55.540 --> 27:57.540
当我们去

27:57.540 --> 27:59.540
marking lab

28:01.540 --> 28:03.540
当我们点击其他页的时候

28:03.540 --> 28:05.540
你看 有没有挑转

28:05.540 --> 28:07.540
能不能挑转 它是不是不能挑转

28:07.540 --> 28:09.540
对吧 不能挑转

28:09.540 --> 28:11.540
为什么不能挑转 是不是重新向了

28:11.540 --> 28:13.540
重新向到写到a了

28:13.540 --> 28:15.540
就这么简单

28:15.540 --> 28:17.540
没有什么特别的

28:17.540 --> 28:19.540
这是关于重新向

28:19.540 --> 28:21.540
这个主键里面

28:21.540 --> 28:23.540
其实还有一些其他属性

28:23.540 --> 28:25.540
只是我们平时用的可能不多

28:25.540 --> 28:27.540
一个呢 是那个

28:27.540 --> 28:29.540
好像这个属性名字

28:29.540 --> 28:31.540
因为用的不多 所以说老师一忘记

28:31.540 --> 28:33.540
好像也有 叫做replace

28:33.540 --> 28:35.540
不是

28:35.540 --> 28:37.540
叫做pooch

28:37.540 --> 28:39.540
对 pooch这个属性

28:39.540 --> 28:41.540
这个属性呢 指的是

28:41.540 --> 28:43.540
因为它默认情况下

28:43.540 --> 28:45.540
默认为

28:45.540 --> 28:47.540
默认为force

28:47.540 --> 28:49.540
表示

28:49.540 --> 28:51.540
挑转

28:51.540 --> 28:53.540
使用替换的方式

28:53.540 --> 28:55.540
不是pooch

28:55.540 --> 28:57.540
而replace的方式来挑转

28:57.540 --> 28:59.540
因为最终挑转 它都是使用history

28:59.540 --> 29:01.540
对吧 来进行挑转

29:01.540 --> 29:03.540
那么挑转的时候是使用替换的方式

29:03.540 --> 29:05.540
而不是pooch

29:05.540 --> 29:07.540
可以设置为处

29:07.540 --> 29:09.540
设置为处

29:09.540 --> 29:11.540
则使用

29:11.540 --> 29:13.540
pooch的方式

29:13.540 --> 29:15.540
挑转 这是这个属性没什么好说的

29:15.540 --> 29:17.540
然后还有这么一个属性

29:17.540 --> 29:19.540
叫做from

29:19.540 --> 29:21.540
指的是

29:21.540 --> 29:23.540
当匹配到

29:23.540 --> 29:25.540
匹配到

29:25.540 --> 29:27.540
from 地址

29:27.540 --> 29:29.540
地址规则是

29:29.540 --> 29:31.540
才进行挑转

29:33.540 --> 29:35.540
就说不是说一定挑转

29:35.540 --> 29:37.540
它是要有个条件

29:37.540 --> 29:39.540
你设置到这个属性 它是有条件的

29:39.540 --> 29:41.540
如果你匹配到这个地址规则的时候

29:41.540 --> 29:43.540
它才会进行挑转

29:43.540 --> 29:45.540
比方说 我们这里写上一个from

29:45.540 --> 29:47.540
from的话 比方说你要访问的

29:47.540 --> 29:49.540
路径是abc

29:49.540 --> 29:51.540
的时候 我才进行挑转

29:51.540 --> 29:53.540
保存看一下

29:53.540 --> 29:55.540
那么现在我们点其他页 其他页就是访问abc

29:55.540 --> 29:57.540
你看 是不是挑转到a了

29:57.540 --> 29:59.540
根本就看不见这个过程

29:59.540 --> 30:01.540
好 如果说我访问其他

30:01.540 --> 30:03.540
如果访问首页

30:03.540 --> 30:05.540
是不是没有挑转

30:05.540 --> 30:07.540
没有挑转到写上a

30:07.540 --> 30:09.540
它就是有条件的

30:09.540 --> 30:11.540
而且这里既然是规则

30:11.540 --> 30:13.540
规则的时候是不是可以写

30:13.540 --> 30:15.540
这些东西

30:15.540 --> 30:17.540
然后说后面可以加上id

30:17.540 --> 30:19.540
之类的东西

30:19.540 --> 30:21.540
是不是可以加

30:21.540 --> 30:23.540
保存看一下

30:23.540 --> 30:25.540
这里我们

30:25.540 --> 30:27.540
能匹配到abc

30:27.540 --> 30:29.540
后面只要你写任何东西

30:29.540 --> 30:31.540
它都会挑转到a

30:31.540 --> 30:33.540
看到没

30:33.540 --> 30:35.540
而且不仅如此

30:35.540 --> 30:37.540
你还能把它的匹配的结果

30:37.540 --> 30:39.540
放到2里边

30:39.540 --> 30:41.540
比方说匹配到这一块

30:41.540 --> 30:43.540
我要把这个匹配的结果放到这

30:43.540 --> 30:45.540
把匹配的结果放到这

30:45.540 --> 30:47.540
看一下

30:47.540 --> 30:49.540
那么如果我访问abc

30:49.540 --> 30:51.540
写纲这个地址的话

30:51.540 --> 30:53.540
你看 是不是挑转到这个地址

30:53.540 --> 30:55.540
看到没

30:55.540 --> 30:57.540
刚才我访问的是

30:57.540 --> 31:01.690
这个地址

31:01.690 --> 31:03.690
刚才我访问的这个地址abc

31:03.690 --> 31:05.690
它挑转到这个地址

31:05.690 --> 31:07.690
是不是把abc匹配的结果

31:07.690 --> 31:09.690
放到2里边去了

31:09.690 --> 31:11.690
它是把这个匹配的结果放到2里边去了

31:11.690 --> 31:13.690
注意名字要一样

31:13.690 --> 31:15.690
名字要一样才行

31:15.690 --> 31:17.690
关于fron2

31:17.690 --> 31:19.690
而且它这里边也可以设置一个z

31:19.690 --> 31:21.690
精确匹配

31:21.690 --> 31:23.690
是否严格匹配 是否大小写敏感

31:23.690 --> 31:25.690
因为你设置到fron属性的

31:25.690 --> 31:27.690
肯定要匹配 匹配的话

31:27.690 --> 31:29.690
就会设置到这些东西

31:29.690 --> 31:31.690
那么这个东西是一样的

31:31.690 --> 31:33.690
是否

31:33.690 --> 31:35.690
是否精确匹配fron

31:35.690 --> 31:37.690
fron匹配是

31:37.690 --> 31:39.690
是否匹配大小写

31:39.690 --> 31:41.690
fron是否严格匹配

31:41.690 --> 31:43.690
最后一个鞋杠

31:43.690 --> 31:45.690
就这么个意思

31:45.690 --> 31:47.690
这是radirect

31:47.690 --> 31:49.690
我们其实有的时候可以利用

31:49.690 --> 31:51.690
这个radirect来做一些事情

31:51.690 --> 31:53.690
我这里

31:53.690 --> 31:55.690
要不要在现在说呢

31:55.690 --> 31:57.690
现在说还是将来说呢

31:57.690 --> 31:59.690
算了吧 我后边再说吧

31:59.690 --> 32:01.690
reactrotor这里还有几节课

32:01.690 --> 32:03.690
当然还没有设计到圆码

32:03.690 --> 32:05.690
圆码的课程还比较多

32:05.690 --> 32:07.690
光是使用场景这一部分

32:07.690 --> 32:09.690
我们还设计到几节课

32:09.690 --> 32:11.690
这几节课都会教大家一些常用的

32:11.690 --> 32:13.690
利用reactrotor

32:13.690 --> 32:15.690
来解决一些常见的问题

32:15.690 --> 32:17.690
后面几节课再说吧

32:17.690 --> 32:19.690
所以说我这里只是把

32:19.690 --> 32:21.690
支持的告诉大家

32:21.690 --> 32:23.690
好 OK 这是我这节课

32:23.690 --> 32:25.690
要介绍的这么三个主见

32:25.690 --> 32:27.690
那么支持reactrotor这里

32:27.690 --> 32:29.690
基本上就学习完了

32:29.690 --> 32:31.690
就学习完了

32:31.690 --> 32:33.690
有人说感觉好少啊东西

32:33.690 --> 32:35.690
有些同学感觉少

32:35.690 --> 32:37.690
有些同学感觉多

32:37.690 --> 32:39.690
其实呢你们

32:39.690 --> 32:41.690
如果说感觉少的同学

32:41.690 --> 32:43.690
那里面的基础还不错

32:43.690 --> 32:45.690
因为你们觉得

32:45.690 --> 32:47.690
他只是给你提供了几个主见

32:47.690 --> 32:49.690
对吧 提供了几个主见

32:49.690 --> 32:51.690
然后在上下文字里面注入了一些信息

32:51.690 --> 32:53.690
就没了 这里感觉到少

32:53.690 --> 32:55.690
那么你对他的整体的把握是比较强的

32:55.690 --> 32:57.690
那么你感觉到多的同学呢

32:57.690 --> 32:59.690
你可能会感觉到他非常非常灵活

32:59.690 --> 33:01.690
因为你可以这样子用

33:01.690 --> 33:03.690
又可以另外一种用法

33:03.690 --> 33:05.690
是这样子的

33:05.690 --> 33:07.690
因为你们呢可能学习了

33:07.690 --> 33:09.690
维佑之后呢你会

33:09.690 --> 33:11.690
不自觉的将reactrotor

33:11.690 --> 33:13.690
跟维佑进行对比

33:13.690 --> 33:15.690
你会发现了

33:15.690 --> 33:17.690
维佑rotor和reactrotor

33:17.690 --> 33:19.690
它有很大很大的区别

33:19.690 --> 33:21.690
维佑rotor呢我给大家

33:21.690 --> 33:23.690
简单说一下吧简单说一下

33:23.690 --> 33:25.690
维佑rotor呢

33:25.690 --> 33:27.690
它最大的特点是

33:27.690 --> 33:29.690
它是一个静态的配置

33:29.690 --> 33:31.690
对吧

33:31.690 --> 33:33.690
当然你可以用一些手段

33:33.690 --> 33:35.690
把它做一些动态的东西出来

33:35.690 --> 33:37.690
但是呢通常情况下它是静态的

33:37.690 --> 33:39.690
它是一个配置文件

33:39.690 --> 33:41.690
我们通常是一些一个配置的ges对象

33:41.690 --> 33:43.690
对吧 它是一个配置

33:43.690 --> 33:45.690
以前呢

33:45.690 --> 33:47.690
在react

33:47.690 --> 33:49.690
rotor

33:49.690 --> 33:51.690
v4

33:51.690 --> 33:53.690
reactrotor

33:53.690 --> 33:55.690
它也是静态的配置

33:55.690 --> 33:57.690
但是后来呢

33:57.690 --> 33:59.690
它把它改了做了一些

33:59.690 --> 34:01.690
非常大的改动

34:01.690 --> 34:03.690
那么现在呢

34:03.690 --> 34:05.690
现在它是动态的

34:05.690 --> 34:07.690
动态组建

34:07.690 --> 34:09.690
动态的组建

34:09.690 --> 34:11.690
也就是说它现在是组建化的

34:11.690 --> 34:13.690
因此呢由于它是

34:13.690 --> 34:15.690
组建本身就非常非常靈活

34:15.690 --> 34:17.690
所以说呢

34:17.690 --> 34:19.690
它不需要像维佑rotor里面

34:19.690 --> 34:21.690
加什么路由

34:21.690 --> 34:23.690
路由

34:23.690 --> 34:25.690
守卫对吧 不需要加那些东西

34:25.690 --> 34:27.690
因为组建 组建是不是有生命周期

34:27.690 --> 34:29.690
你是不是可以

34:29.690 --> 34:31.690
用高业组建把它封装

34:31.690 --> 34:33.690
你是不是可以做嵌套

34:33.690 --> 34:35.690
是不是可以做组合

34:35.690 --> 34:37.690
各种各样的玩法都可以

34:37.690 --> 34:39.690
因此呢它提供了最大的靈活度给你

34:39.690 --> 34:41.690
它不需要给你做那些东西

34:41.690 --> 34:43.690
把它写实

34:43.690 --> 34:45.690
无论是react也好

34:45.690 --> 34:47.690
还是rotor也好

34:47.690 --> 34:49.690
它们做的事情真的不多

34:49.690 --> 34:51.690
它保持了最大的靈活度

34:51.690 --> 34:53.690
后面几节课呢我会给大家介绍一下

34:53.690 --> 34:55.690
如果说我们遇到一些常见的场景

34:55.690 --> 34:57.690
我们利用reactrotor

34:57.690 --> 34:59.690
该如何去应付这样的场景

34:59.690 --> 35:01.690
后面我们会说

35:01.690 --> 35:03.690
OK啊

35:03.690 --> 35:05.690
那么reactrotor它的核心周识就没了

35:05.690 --> 35:07.690
但是它其实还有一点点组建

35:07.690 --> 35:09.690
那些组建呢有些呢设计到

35:09.690 --> 35:11.690
移动端 有些呢设计到

35:11.690 --> 35:13.690
比方说memoryrotor

35:13.690 --> 35:15.690
有些设计到那个就是那个

35:15.690 --> 35:17.690
服务端渲染

35:17.690 --> 35:19.690
目前呢我们都还没有接触过那方面的知识

35:19.690 --> 35:21.690
所以说目前呢也没有必要去知道了

35:21.690 --> 35:23.690
它核心周间就讲完了

35:23.690 --> 35:25.690
那么下一个开始呢我们利用它

35:25.690 --> 35:27.690
来解决一些

35:27.690 --> 35:29.690
在真实的开发场景里边

35:29.690 --> 35:31.690
常常遇到的问题

35:31.690 --> 35:33.690
OK啊这也可以到这里了

