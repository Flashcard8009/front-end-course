WEBVTT

00:00.820 --> 00:04.820
好 这一块咱们来介绍两个工具

00:04.820 --> 00:10.120
这两个工具它都是为了在我们开发Racket的程序的时候

00:10.120 --> 00:14.420
提醒我们 帮电源我们分析我们的代码

00:14.420 --> 00:17.220
或者说分析我们的整个开发出来的程序

00:17.220 --> 00:18.920
它的效率上有没有问题啊

00:18.920 --> 00:20.820
它引起的代码有没有问题啊

00:20.820 --> 00:22.320
对吧 这些都是工具

00:22.320 --> 00:25.820
当然这个工具里面也可以包含ES Nint

00:25.820 --> 00:28.220
其实我们用那个脚手架的时候

00:28.220 --> 00:30.020
它就已经给你安装好了

00:30.020 --> 00:32.420
就是有的时候你写的一些没有意义的代码

00:32.420 --> 00:34.020
比方说你导入一个组件

00:34.020 --> 00:36.420
你导入了 谁写的

00:36.420 --> 00:38.020
你这里导入一个组件

00:38.020 --> 00:40.420
但是搞了半天你没有去使用这个组件

00:40.420 --> 00:42.220
它就认为这个代码是有问题的

00:42.220 --> 00:43.820
是不太合理的

00:43.820 --> 00:45.420
你看它这个就报了一个警告

00:45.420 --> 00:48.620
它说已经生命了App从未读去它的纸

00:48.620 --> 00:52.420
这是ES Nint它的功能 对吧

00:52.420 --> 00:53.820
这里除了这个ES Nint

00:53.820 --> 00:55.020
这个都没什么说的

00:55.020 --> 00:56.420
这个ES Nint我们之前要讲的

00:56.420 --> 00:58.620
Webpack的时候也讲过这个玩意

00:58.620 --> 00:59.920
这个东西没什么好说的

00:59.920 --> 01:01.120
我们主要说另外两个工具

01:01.120 --> 01:02.820
一个是严格模式

01:02.820 --> 01:04.920
一个是profiler

01:04.920 --> 01:06.120
那么这一颗讲完了之后

01:06.120 --> 01:12.920
咱们在Racket进阶部分就算结束了

01:12.920 --> 01:14.720
进阶部分其实多多少少

01:14.720 --> 01:16.620
还有那么一点点东西

01:16.620 --> 01:19.420
那一点点东西我觉得我思考了半天

01:19.420 --> 01:20.320
根本就没用

01:20.320 --> 01:21.120
根本就没啥用

01:21.120 --> 01:23.320
比方说什么克农的

01:23.320 --> 01:26.120
克农节点这些东西基本没啥用

01:26.120 --> 01:28.320
所以说那些东西就算了吧

01:29.320 --> 01:30.620
到看后边吧

01:30.620 --> 01:32.720
看后面如果我觉得有必要的话再给它加上

01:32.720 --> 01:34.920
因为我们讲Racket

01:34.920 --> 01:37.020
其实主要讲了它的一些核心原理

01:37.020 --> 01:38.520
我们平时要用到的东西

01:38.520 --> 01:42.320
要说把它里边的所有的API全部讲完的话

01:42.320 --> 01:43.120
那也不可能

01:43.120 --> 01:45.120
比方说你们之前学了一个Jquery

01:45.120 --> 01:47.120
也不太可能把它所有的API全部讲完

01:47.120 --> 01:48.920
这个是不太可能的

01:48.920 --> 01:50.520
其实API这个东西

01:50.520 --> 01:53.320
大家不要过于的神话它

01:53.320 --> 01:56.120
API这个东西我们也不要去使进用备

01:56.120 --> 01:57.920
所以我们遇到一些问题的时候

01:57.920 --> 01:58.920
需要查看的时候

01:58.920 --> 02:01.320
从官方闻到里边去找就完事了

02:01.320 --> 02:02.920
我编写单一码的话

02:02.920 --> 02:05.520
我从来不会太注重API

02:05.520 --> 02:06.820
有些重要的API

02:06.820 --> 02:08.920
涉及到它的原理部分的话

02:08.920 --> 02:10.620
我会特别重视

02:10.620 --> 02:11.620
但是有些API

02:11.620 --> 02:14.820
就是一些细致末节的一些功能性的东西

02:14.820 --> 02:17.020
咱们抓大胖小则了

02:17.020 --> 02:18.820
咱们这里就讲工具

02:18.820 --> 02:19.520
首先第一个

02:19.520 --> 02:20.420
严格模式

02:20.420 --> 02:21.520
这什么意思呢

02:21.520 --> 02:24.720
就是说它本质上是一个组件

02:24.720 --> 02:30.220
它叫做strict mode

02:30.220 --> 02:33.020
它本质是一个组件

02:33.020 --> 02:39.020
该组件不进行UI渲染

02:39.020 --> 02:40.620
这个组件它的UI部分

02:40.620 --> 02:42.620
它并不提供什么DIV

02:42.620 --> 02:44.720
并不提供一些真实的动物元素

02:44.720 --> 02:46.120
它并不提供这些东西

02:46.120 --> 02:47.920
那么它的作用就是

02:47.920 --> 02:50.120
它的作用是

02:50.120 --> 02:51.520
它这个不进行UI渲染

02:51.520 --> 02:53.720
其实我们之前还做过这么一个组件

02:53.720 --> 02:54.720
一个内置的组件

02:54.720 --> 02:56.420
它也不会进行UI渲染

02:56.420 --> 02:56.820
什么组件呢

02:56.820 --> 02:58.220
就是很早的时候

02:58.220 --> 02:59.720
咱们讲过这个fragment

02:59.720 --> 03:00.220
对吧

03:00.220 --> 03:02.720
reactor.fragment

03:02.720 --> 03:03.720
就这个组件

03:03.720 --> 03:04.820
它的减写

03:04.820 --> 03:06.820
这个可能没大家可能忘了是什么意思呢

03:06.820 --> 03:07.720
不管它的减写

03:07.720 --> 03:09.320
大家一定是见过的

03:09.320 --> 03:10.920
就这种写法

03:10.920 --> 03:11.620
就这种写法

03:11.620 --> 03:12.620
就它的减写

03:12.620 --> 03:15.420
这就是fragment

03:15.420 --> 03:17.920
我们这里打上来

03:17.920 --> 03:21.320
这个组件它也是不进行UI渲染

03:21.320 --> 03:22.420
同这个组件差不多

03:22.420 --> 03:23.420
那么strict mode

03:23.420 --> 03:25.720
它的组件也是这个

03:25.720 --> 03:30.520
叫做react.strict mode

03:30.520 --> 03:31.820
你看它手写

03:31.820 --> 03:32.720
手这么大写就知道

03:32.720 --> 03:33.720
它这个玩意不见了

03:33.720 --> 03:35.020
它一定是个组件

03:35.020 --> 03:36.720
至少是个勾到函数

03:36.720 --> 03:37.820
它的作用是什么呢

03:37.820 --> 03:42.420
它的作用是在渲染

03:42.420 --> 03:44.020
内部组件时

03:44.020 --> 03:45.620
它里边可以给它写组件

03:45.620 --> 03:48.320
在渲染内部组件时

03:48.420 --> 03:50.820
发现有问题

03:50.820 --> 03:55.920
或已经过时的

03:55.920 --> 03:56.720
应该这样说吧

03:56.720 --> 03:59.920
发现不合适的代码

03:59.920 --> 04:01.320
那么发现不合适的代码之后

04:01.320 --> 04:03.520
它会给你包出一些警告消息

04:03.520 --> 04:04.320
比方说哪些代码

04:04.320 --> 04:05.820
它认为是不合适的呢

04:05.820 --> 04:06.420
有这么一些

04:06.420 --> 04:07.720
下面我给大家列出来了

04:07.720 --> 04:08.720
一个是

04:08.720 --> 04:10.520
你用了一些不安全的生命周期

04:10.520 --> 04:12.220
什么叫不安全的生命周期

04:12.220 --> 04:13.920
就是什么vio

04:13.920 --> 04:15.420
就是我们旧版的生命周期里边

04:15.420 --> 04:17.420
有些生命周期现在被移除掉了

04:17.420 --> 04:19.520
但是你还能用

04:19.520 --> 04:21.220
那么你用这些生命周期的时候

04:21.220 --> 04:22.520
你会收到一些警告

04:22.520 --> 04:24.520
比方说component wheel mount

04:24.520 --> 04:26.020
这个生命周期你会收到警告

04:26.020 --> 04:26.720
还有这个玩意

04:26.720 --> 04:28.220
这个玩意我们当时还特别讲了这个东西

04:28.220 --> 04:28.620
对吧

04:28.620 --> 04:30.220
这个非常非常容易出问题

04:30.220 --> 04:31.820
那么这个生命周期函数

04:31.820 --> 04:34.320
不让你去使用

04:34.320 --> 04:35.220
包括什么呢

04:35.220 --> 04:37.620
包括这个vio update也被移除掉了

04:37.620 --> 04:39.420
所以说不会让你去使用

04:39.420 --> 04:41.420
那么当你去使用这些生命周期的时候

04:41.420 --> 04:43.320
它会给你包出一个警告

04:43.320 --> 04:43.620
好

04:43.620 --> 04:44.920
咱们来看一下吧

04:44.920 --> 04:45.920
就讲到这儿来了

04:45.920 --> 04:47.120
看一下吧

04:47.220 --> 04:50.120
比方说咱们这里写上这么一个组件

04:53.920 --> 04:54.720
comp

04:54.720 --> 04:56.320
就用这个app组件

04:56.320 --> 04:56.620
好吧

04:56.620 --> 04:57.720
就用这个app组件

04:57.720 --> 04:58.620
那么这个组件里边

04:58.620 --> 04:59.720
我们外面给它套一个

04:59.720 --> 05:00.520
套一个什么

05:00.520 --> 05:01.720
套一个react

05:01.720 --> 05:02.420
套一个这个东西

05:04.720 --> 05:06.520
就是把整个根组件都套进来

05:06.520 --> 05:08.420
那么它里边的所有组件

05:08.420 --> 05:09.620
它都会进行检查

05:09.620 --> 05:11.820
react strict mode

05:11.820 --> 05:12.520
该套一个这个东西

05:12.520 --> 05:13.420
完事了

05:13.420 --> 05:14.320
套一个app

05:14.320 --> 05:15.620
就完事了

05:15.720 --> 05:17.320
那么这里边我们比方说

05:17.320 --> 05:19.720
去使用了一些不合适的生命周期含书

05:21.520 --> 05:24.120
比方说咱们使用component wheel mount

05:25.720 --> 05:26.320
看一下

05:26.320 --> 05:27.120
这个生命周期含书

05:27.120 --> 05:28.620
这个生命周期含书在我们上

05:28.620 --> 05:31.420
上节课讲的一个宣展过程的时候都没有讲

05:31.420 --> 05:33.420
因为这个东西它早晚会消失的

05:33.420 --> 05:34.320
早晚就会消失了

05:35.120 --> 05:36.020
那么看一下吧

05:36.020 --> 05:37.720
看一下咱们运行书呢

05:37.720 --> 05:38.720
邮件点减一下

05:40.720 --> 05:42.520
你看它这里已经包的错误了

05:42.520 --> 05:44.020
它告诉你说什么

05:44.020 --> 05:44.820
它说

05:44.820 --> 05:48.420
你这个生命周期含书它不是一个安全的生命周期方法

05:48.420 --> 05:51.120
它在一个严格模式下面

05:51.120 --> 05:52.620
在一个严格的模式下面

05:52.620 --> 05:54.020
那么不应该出现这个方法

05:54.020 --> 05:55.020
它就会给你报个警告

05:55.020 --> 05:56.220
就这么个意思

05:56.220 --> 05:58.220
就这么个意思提醒你

05:58.220 --> 05:59.620
平时写代码的时候注意一下

05:59.620 --> 06:01.420
这东西尽量不要写

06:01.420 --> 06:02.020
另外一个呢

06:02.020 --> 06:04.720
这就是使用过时的支付串

06:04.720 --> 06:06.420
就是rave API的警告

06:06.420 --> 06:08.720
就是说如果我们之前讲过rave对吧

06:08.720 --> 06:09.220
rave呢

06:09.220 --> 06:11.620
我现在官方的都告诉你

06:11.620 --> 06:13.520
应该使用一个含书给它

06:13.520 --> 06:14.620
或者是给它一个什么

06:14.620 --> 06:17.120
通过crease rave创建了一个对象给它

06:17.120 --> 06:18.520
你不要去给它一个什么

06:18.520 --> 06:19.220
给一个支付串

06:19.220 --> 06:21.320
不要这种做法就不要来了

06:21.320 --> 06:22.720
它告诉你这种做法不要来了

06:22.720 --> 06:24.420
尽管了它现在还能用

06:24.420 --> 06:26.820
但是如果你在严格模式下面的时候

06:26.820 --> 06:29.020
你会看到它会给包了一个错误

06:29.020 --> 06:30.120
它告诉你

06:30.120 --> 06:33.120
它说你是这是一个支付串的引用

06:33.120 --> 06:35.720
这种的在严格模式下面

06:35.720 --> 06:36.920
已经不再推荐使用了

06:38.120 --> 06:41.120
好多支付串的引用容易导致bug

06:41.220 --> 06:42.320
而且呢

06:42.320 --> 06:42.820
这个什么

06:42.820 --> 06:43.820
avoid的什么意思

06:43.820 --> 06:46.460
avoid的

06:46.460 --> 06:47.960
而且我们之前还说过

06:47.960 --> 06:50.060
而且就是应该避免的

06:50.060 --> 06:51.060
应该避免

06:51.060 --> 06:52.760
容易导致bug

06:52.760 --> 06:53.360
这个什么意思

06:53.360 --> 06:54.060
复杂次

06:54.060 --> 06:54.660
source

06:56.760 --> 06:58.560
容易导致潜在的bug

06:58.560 --> 06:59.660
让你尽量避免

06:59.660 --> 07:04.060
因为你给它的是一个对象的话

07:04.060 --> 07:06.660
那么它可以通过对象的引用来发现

07:06.660 --> 07:07.360
这个对

07:07.360 --> 07:08.260
你给它的rave呢

07:08.260 --> 07:09.760
有没有变化

07:09.760 --> 07:10.560
有没有变化

07:10.560 --> 07:11.860
如果比方说你给它的一个含书

07:11.860 --> 07:13.760
每次给它的含书都是新鲜的含书

07:13.760 --> 07:15.560
那么每一次它都会运行这个含书

07:15.560 --> 07:15.860
对吧

07:15.860 --> 07:17.960
它可以通过对象的引用来发现这个rave

07:17.960 --> 07:18.960
有没有变化

07:18.960 --> 07:20.560
那么如果变化了的话

07:20.560 --> 07:21.660
那么它会运行含书

07:21.660 --> 07:23.460
或者说给它一个对象的话

07:23.460 --> 07:25.860
那么它就会在合适的生命周期里边

07:25.860 --> 07:28.860
去给它整个对象的current复植

07:28.860 --> 07:30.860
而不是说

07:30.860 --> 07:31.860
用这种方式

07:31.860 --> 07:33.260
用以前字不算的方式

07:33.260 --> 07:34.460
它直接把它复着在哪

07:34.460 --> 07:36.260
把它复着在raves下边了

07:36.260 --> 07:37.660
后边都不再运行了

07:37.660 --> 07:39.260
都不再重新给它复植了

07:39.260 --> 07:40.960
所以这种做法呢

07:41.060 --> 07:42.460
不太适合这个rages

07:42.460 --> 07:44.860
现在它认为的开发长期

07:44.860 --> 07:45.660
因此

07:45.660 --> 07:48.560
它让你不要去用这个事不错的rave

07:48.560 --> 07:49.960
这是第二点

07:49.960 --> 07:50.960
第三个点是

07:50.960 --> 07:52.860
当你去使用了一个飞机的方法

07:52.860 --> 07:54.160
这个方法呢

07:54.160 --> 07:55.160
我们没用过

07:55.160 --> 07:55.760
没有去

07:55.760 --> 07:57.560
我们在教程里边没有去用过

07:57.560 --> 07:59.560
这是很老很闹的方法了

07:59.560 --> 08:01.960
这个方法它现在已经完全没用了

08:01.960 --> 08:03.260
不要让你去用这个东西

08:03.260 --> 08:04.260
它这个东西是什么呢

08:04.260 --> 08:05.860
好找了好找以前的方法

08:05.860 --> 08:07.860
它是通过这个方法

08:07.860 --> 08:10.160
能够在动物树里边

08:10.160 --> 08:11.860
找到一个动物节点

08:11.860 --> 08:13.160
咱们上节课不是说了节点吗

08:13.160 --> 08:13.560
去吧

08:13.560 --> 08:15.560
还是区地动物树里边不是有节点吗

08:15.560 --> 08:17.760
然后去让你去找到一个动物节点

08:17.760 --> 08:20.060
那么如果你是找到了的

08:20.060 --> 08:21.660
找到的最终是一个动物节点的话

08:21.660 --> 08:23.060
那么它会给你一个

08:23.060 --> 08:25.060
原生的就真实的动物对象

08:25.060 --> 08:26.860
如果你找到的是一个

08:26.860 --> 08:28.560
内阻减节点的话

08:28.560 --> 08:30.460
那么它可会给你一个内阻减的对象

08:30.460 --> 08:31.360
就是什么回事

08:31.360 --> 08:32.260
它不让你去用这个了

08:32.260 --> 08:32.860
因为后来呢

08:32.860 --> 08:33.760
它出现了这个

08:33.760 --> 08:34.860
这个东西rave

08:34.860 --> 08:37.060
那么这个rave已经很好的解决这个问题了

08:37.060 --> 08:38.560
如果你要获去真实的动物对象

08:38.560 --> 08:39.660
那么应该用这种方式

08:39.660 --> 08:40.660
rave这种方式

08:40.660 --> 08:42.160
而不应该使用这种方式了

08:42.160 --> 08:43.560
就这个不说了

08:43.560 --> 08:45.960
另外是检测意外的副作用

08:45.960 --> 08:47.260
那么这里我解释一下

08:47.260 --> 08:49.860
什么叫做副作用

08:49.860 --> 08:52.760
副作用是什么意思呢

08:52.760 --> 08:54.860
我们就单独拿出来说一下

08:54.860 --> 08:56.760
因为后边我们还会

08:56.760 --> 08:58.360
还会说到这个副作用这个词

08:58.360 --> 09:00.360
所以说我们这几课单独把它说一下

09:00.360 --> 09:03.660
后边我们就不再过度地去解释它了

09:03.660 --> 09:04.860
什么叫副作用呢

09:04.860 --> 09:07.460
是指一个函数中

09:07.460 --> 09:15.660
一个函数中做了一些会影响

09:15.660 --> 09:22.700
会影响函数外部数据的事情

09:22.700 --> 09:26.100
会影响这个跟这个函数无关的事情

09:26.100 --> 09:27.200
那么跟外部数据的事情

09:27.200 --> 09:29.100
这些事情就叫做副作用

09:29.100 --> 09:30.200
那么具体的说的话

09:30.200 --> 09:32.000
像下面这些事情

09:32.000 --> 09:36.100
例如下面这些事情都属于副作用

09:36.300 --> 09:39.200
阿迦克斯请求这些是副作用

09:39.200 --> 09:40.000
那么还有什么呢

09:40.000 --> 09:41.500
还有就是那个异部

09:41.500 --> 09:43.300
当然异部它也包含阿迦克斯请求

09:43.300 --> 09:45.100
我们就统一说异部

09:45.100 --> 09:46.200
异部处理

09:46.200 --> 09:47.400
比如说set timeout

09:47.400 --> 09:49.700
set interval这些都是副作用

09:49.700 --> 09:50.800
因为这个函数运行完了过

09:50.800 --> 09:52.400
它还在影响外面的东西

09:52.400 --> 09:54.500
它还会持续产生影响

09:54.500 --> 09:56.700
比如说我设置了一个计时器

09:56.700 --> 09:57.500
set timeout

09:57.500 --> 09:59.400
哪怕你把它设置为0

09:59.400 --> 10:00.400
是异部代码对吧

10:00.400 --> 10:01.000
异部代码

10:01.000 --> 10:02.100
那么这个函数结束过后

10:02.100 --> 10:03.400
它才会运行

10:03.400 --> 10:04.800
那么这个函数结束过后

10:04.800 --> 10:06.900
它不是说这个函数结束就完了

10:06.900 --> 10:08.700
它还会持续影响

10:08.700 --> 10:10.100
这就是也副作用

10:10.100 --> 10:10.700
异部处理

10:10.700 --> 10:11.900
包括阿迦克斯请求

10:11.900 --> 10:13.600
这些也是副作用

10:13.600 --> 10:14.800
还包括什么

10:14.800 --> 10:17.900
改变参数

10:17.900 --> 10:21.600
改变参数值

10:21.600 --> 10:22.900
这些也是副作用

10:22.900 --> 10:24.700
你不要去改变参数值

10:24.700 --> 10:30.500
包括在react里边

10:30.500 --> 10:32.400
还包括set state

10:32.400 --> 10:33.800
这些也是副作用

10:33.800 --> 10:34.800
因为set state

10:34.800 --> 10:35.900
我们之前说过

10:35.900 --> 10:37.800
它有可能是异部的

10:37.800 --> 10:38.100
对吧

10:38.100 --> 10:38.900
它有可能是异部的

10:38.900 --> 10:41.900
所以说它也要算是副作用

10:41.900 --> 10:42.200
对吧

10:42.200 --> 10:43.100
像这些事情

10:43.100 --> 10:44.500
比方说第四个函

10:44.500 --> 10:45.200
还有什么

10:45.200 --> 10:50.700
还有就是本地存储

10:50.700 --> 10:52.200
就是nocal storage

10:52.200 --> 10:53.800
像这些就是会改变

10:53.800 --> 10:56.200
跟函数没有关系的东西

10:56.200 --> 10:59.200
那么会影响外部数据的事情

10:59.200 --> 11:01.300
都叫做副作用

11:01.300 --> 11:03.700
那么如果一个函数

11:03.700 --> 11:05.300
它具有副作用的话

11:05.300 --> 11:06.700
那么我们就认为这个函数

11:06.700 --> 11:09.100
叫做副作用函数

11:09.100 --> 11:10.400
有副作用的函数

11:10.400 --> 11:13.100
那么相反的

11:13.100 --> 11:20.000
如果一个函数没有副作用

11:20.000 --> 11:26.300
则可以认为该函数是一个存函数

11:26.300 --> 11:27.200
什么叫存函数呢

11:27.200 --> 11:28.500
就是你这个函数里边

11:28.500 --> 11:31.000
你没有改变外部的任何数据

11:31.100 --> 11:33.400
这里还有包括什么

11:33.400 --> 11:36.800
改变外部的函数

11:36.800 --> 11:37.700
外部的变量

11:37.700 --> 11:39.100
比方说你利用必包

11:39.100 --> 11:39.700
对吧

11:39.700 --> 11:42.300
你改变了函数的外部变量等等

11:42.300 --> 11:44.700
这些都算是副作用

11:44.700 --> 11:46.400
那么就意味着

11:46.400 --> 11:47.700
在rex里边

11:47.700 --> 11:49.600
它加了严格模式的话

11:49.600 --> 11:51.700
它会检查一些副作用

11:51.700 --> 11:53.400
因为rex它要求你

11:53.400 --> 11:55.600
它让你就是写出优质的代码的话

11:55.600 --> 11:56.500
它要求你

11:56.500 --> 12:00.100
你的副作用只能放在这么两个函数里边

12:00.100 --> 12:04.800
就是rex要求副作用代码

12:04.800 --> 12:09.700
仅出现在

12:09.700 --> 12:16.100
什么以下生命周期函数中

12:16.100 --> 12:18.100
比方说一个生命周期函数是怎么了

12:18.100 --> 12:20.300
第一个就是component

12:20.300 --> 12:22.000
component

12:22.000 --> 12:23.800
did mount

12:23.800 --> 12:26.200
就是组件已经挂载完成

12:26.200 --> 12:27.300
咱们张继可讲过

12:27.300 --> 12:27.500
对吧

12:27.500 --> 12:29.100
还非常详细的讲了

12:29.100 --> 12:30.100
组件已经挂载完成

12:30.100 --> 12:30.900
这个时候

12:30.900 --> 12:34.300
页面上的这些元素都可以使用了

12:34.300 --> 12:36.600
页面上的元素那些

12:36.600 --> 12:37.800
真实动物对象都有了

12:37.800 --> 12:39.400
那么你可以直接获取去使用

12:39.400 --> 12:40.500
那么比方说你要发生什么

12:40.500 --> 12:42.400
阿迦克斯请求

12:42.400 --> 12:43.600
也要写到这里边

12:43.600 --> 12:45.800
component did mount

12:45.800 --> 12:48.700
这个函数里边可以有副作用

12:48.700 --> 12:49.700
那么比方说

12:49.700 --> 12:50.400
那第二个函数

12:50.400 --> 12:54.700
比方说就是component did update

12:54.700 --> 12:56.200
就是已经完成更新了

12:56.200 --> 12:57.000
那么这个时候

12:57.000 --> 12:58.400
就已经全部做完了事情

12:58.500 --> 12:59.900
生命周期函数走了

12:59.900 --> 13:03.300
那么你这里可以去做一些操作

13:03.300 --> 13:04.300
有副作用的操作

13:04.300 --> 13:05.500
你可以在这里做

13:05.500 --> 13:06.300
比方说又发生了一些

13:06.300 --> 13:07.700
阿迦克斯请求等等

13:07.700 --> 13:09.600
都可以在这里去完成了

13:09.600 --> 13:13.500
那么第三个是component

13:13.500 --> 13:16.200
will amount

13:16.200 --> 13:18.500
即将被卸载

13:18.500 --> 13:20.000
即将被卸载

13:20.000 --> 13:22.400
这个函数里边也可以产生副作用

13:22.400 --> 13:24.300
因为一个函数

13:24.300 --> 13:26.500
一个组件它要被卸载的时候

13:26.500 --> 13:28.400
你可能要去嫉妒它的一些东西

13:28.400 --> 13:29.900
发生一些阿迦克斯请求

13:29.900 --> 13:32.200
或者往本地存储里边去嫉妒一些东西

13:32.200 --> 13:33.400
嫉妒一些信息等等

13:33.400 --> 13:36.200
那么这里边它是允许有副作用的

13:36.200 --> 13:37.200
不要这意思

13:37.200 --> 13:39.200
那么其他的生命周期函数里边

13:39.200 --> 13:41.100
都不允许有这些副作用

13:41.100 --> 13:42.600
都不允许

13:42.600 --> 13:45.300
比方说我们在app里边

13:45.300 --> 13:46.000
因为其他生命中

13:46.000 --> 13:47.300
周期函数之前也说过

13:47.300 --> 13:49.100
它会荣誉导致问题

13:49.100 --> 13:49.500
比方说

13:49.500 --> 13:50.400
构造函数里边

13:50.400 --> 13:51.600
组件的构造函数里边

13:51.600 --> 13:53.400
你去做了一些副作用

13:53.400 --> 13:55.800
那么它会创立这个函数之后

13:55.900 --> 13:58.100
突然这个函数可能它生命周期还没有走完

13:58.100 --> 14:00.400
然后又去异布了运行的你这些代码

14:00.400 --> 14:02.300
那么这样子可能会导致一些bug

14:02.300 --> 14:03.300
包括我们之前说的

14:03.300 --> 14:04.500
旧版生命周期里边

14:04.500 --> 14:05.300
像这个

14:05.300 --> 14:06.500
Voilmount里边

14:06.500 --> 14:07.100
你去

14:07.100 --> 14:08.600
它能不能允许你副作用

14:08.600 --> 14:09.200
可以允许

14:09.200 --> 14:10.600
但是如果在严格模式下面

14:10.600 --> 14:11.500
它要爆错了

14:11.500 --> 14:14.000
如果在这里边你去用了一些副作用的代码

14:14.000 --> 14:15.100
那么这个时候

14:15.100 --> 14:15.900
它会认为

14:15.900 --> 14:17.100
你可能

14:17.100 --> 14:18.400
这个副作用的代码

14:18.400 --> 14:20.100
因为这个Voilmount这个函数

14:20.100 --> 14:21.400
它可能会运行多次

14:21.400 --> 14:23.400
所以说它可能会导致你的副作用代码

14:23.400 --> 14:24.300
运行多次

14:24.300 --> 14:25.600
这些都是不合理的

14:25.600 --> 14:26.400
因此

14:26.400 --> 14:27.800
它认为你的副作用代码

14:27.800 --> 14:29.100
应该出现在这里

14:29.100 --> 14:31.700
这几个函数里边

14:31.700 --> 14:33.400
包括SetsDets函数里边

14:33.400 --> 14:34.800
也不能出现副作用

14:34.800 --> 14:37.200
SetsDets里边不是可以穿函数吗

14:37.200 --> 14:38.900
里边那个函数里边

14:38.900 --> 14:40.900
它也不能出现有副作用的

14:40.900 --> 14:41.900
那么咱们看一下吧

14:43.500 --> 14:44.400
我们这里

14:44.400 --> 14:45.900
比方说我们在

14:45.900 --> 14:49.100
在哪呢

14:49.100 --> 14:50.300
康斯装一套里边

14:50.300 --> 14:54.000
康斯装一套里边

14:55.000 --> 14:56.300
在这里边

14:56.300 --> 14:58.400
我们去写了一个有副作用的代码

14:58.400 --> 14:59.900
不应该把这些人给删掉

14:59.900 --> 15:03.110
删掉干嘛的

15:03.110 --> 15:05.210
康斯装一套里边

15:05.210 --> 15:06.510
Props

15:06.510 --> 15:07.310
在这里边

15:07.310 --> 15:08.210
Super

15:08.210 --> 15:09.310
Props

15:09.310 --> 15:10.810
如果去写了一个副作用的代码

15:10.810 --> 15:12.510
比方说SetTimeOut

15:12.510 --> 15:13.310
三秒钟之后

15:13.310 --> 15:15.110
去你执行某一个东西

15:15.110 --> 15:15.810
执行某个东西

15:15.810 --> 15:16.810
Hello

15:16.810 --> 15:17.510
咱们先好了

15:17.510 --> 15:18.210
看一下

15:18.210 --> 15:19.710
保存一下

15:19.710 --> 15:20.710
然后我们过来看一下

15:20.710 --> 15:23.210
一位发现

15:23.210 --> 15:23.910
对

15:23.910 --> 15:25.110
它是这样子

15:25.110 --> 15:27.010
在严格模式下面

15:27.010 --> 15:29.810
它是没有办法监测到副作用的代码

15:29.810 --> 15:31.810
就它这个代码是监控不到的

15:31.810 --> 15:32.810
为什么监控不到呢

15:32.810 --> 15:33.810
它是这样子

15:33.810 --> 15:35.010
因为你这里边写了代码

15:35.010 --> 15:36.510
它怎么知道你写了什么代码呢

15:36.510 --> 15:36.810
对不对

15:36.810 --> 15:38.010
它怎么知道你这里边

15:38.010 --> 15:39.710
函数里边写了什么代码呢

15:39.710 --> 15:41.710
或者说你这里去调用另外一个函数

15:41.710 --> 15:43.510
另外一个函数里边有副作用

15:43.510 --> 15:44.510
那么导致了这个函数

15:44.510 --> 15:45.610
它本身有副作用

15:45.610 --> 15:47.210
所以它监测不到这里边的代码

15:47.210 --> 15:48.910
它给你说了这么一件事

15:48.910 --> 15:50.810
它对于那些有副作用的函数

15:50.810 --> 15:53.510
它会故意给你调用两遍

15:53.510 --> 15:55.210
它会故意给你调用两遍

15:55.210 --> 15:56.310
就是这里

15:58.310 --> 15:59.810
在严格模式下

15:59.810 --> 16:01.810
严格模式下

16:01.810 --> 16:04.710
虽然不能

16:04.710 --> 16:09.410
不能监控到具体的副作用代

16:10.610 --> 16:12.410
它虽然不能具体的监控到

16:12.410 --> 16:16.310
但它会将

16:18.310 --> 16:23.210
不能具有副作用的函数调用两遍

16:23.710 --> 16:25.710
比方说像这个勾造函数

16:25.710 --> 16:27.710
勾造函数是不能有副作用的

16:27.710 --> 16:29.210
这些代码都不能有副作用

16:29.210 --> 16:31.510
那么它可以自动的给你调用两遍

16:31.510 --> 16:32.710
因为你没有副作用的话

16:32.710 --> 16:34.510
调用两遍是没有任何问题的

16:34.510 --> 16:35.510
你说这个函数的

16:35.510 --> 16:37.910
只有可能去做一些运算的事情

16:37.910 --> 16:40.110
那么它不会说

16:40.110 --> 16:42.710
这个函数它不会说

16:42.710 --> 16:44.110
会影响外部的数据

16:44.110 --> 16:45.710
所以调用几遍都无所谓

16:45.710 --> 16:47.210
你还是得到了一样的结果

16:47.210 --> 16:49.710
但是如果说你这个函数里边有副作用的话

16:49.710 --> 16:50.710
那么调用两遍过后

16:50.710 --> 16:52.010
你就会产生一些问题

16:52.010 --> 16:53.910
你会发现一些问题

16:53.910 --> 16:54.810
明白这个意思吗

16:54.810 --> 16:58.010
所以说它会将不能

16:58.010 --> 17:01.710
具有副作用的函数调用两遍

17:01.710 --> 17:04.410
以便发现问题

17:04.410 --> 17:06.210
以便我们开发者的发现问题

17:06.210 --> 17:09.210
那么注意这种情况

17:09.210 --> 17:12.810
仅在开发模式下有效

17:12.810 --> 17:14.210
当我们真正发布出去过后

17:14.210 --> 17:15.710
它不会调用两遍的

17:15.710 --> 17:16.910
就是在开发阶段的话

17:16.910 --> 17:19.310
它通过这种方式提示你

17:19.310 --> 17:21.310
你会发现有些问题

17:21.310 --> 17:23.610
你看这里是不是运行了两次Hello

17:23.610 --> 17:25.510
它构造函数运行的两遍

17:25.510 --> 17:28.110
它通过这种方式来提示你

17:28.110 --> 17:30.110
下面这个就是严根模式下面

17:30.110 --> 17:32.210
如果你使用了一些过时的API

17:32.210 --> 17:33.510
就是context API

17:33.510 --> 17:35.710
过时的那么它会导致问题

17:35.710 --> 17:36.670
比方我们之前说过

17:36.670 --> 17:39.110
context API是不是有这个玩意

17:39.110 --> 17:44.810
Static child context types

17:44.810 --> 17:45.910
是不是用了这个东西

17:45.910 --> 17:47.210
对不对

17:47.210 --> 17:49.010
这个玩意是不是过时的API

17:49.010 --> 17:50.610
是过时的API

17:50.610 --> 17:52.210
那么它会给你提示错误

17:52.210 --> 17:53.810
就这个

17:53.810 --> 17:55.310
它说是吗

17:55.310 --> 17:58.010
我当时还没有写这个

17:58.010 --> 18:00.810
比方说我们该写上

18:00.810 --> 18:02.110
写上这么一个还说

18:02.110 --> 18:05.110
Return就这个东西

18:05.110 --> 18:06.910
大家看一下吧

18:06.910 --> 18:07.910
它说

18:07.910 --> 18:09.910
不要跑到去了

18:09.910 --> 18:11.710
这个context API

18:11.710 --> 18:13.910
它说已经在严根模式下面

18:13.910 --> 18:15.110
被监控到了

18:15.110 --> 18:16.610
这个已经过时的API

18:16.610 --> 18:18.510
已经非法的API

18:18.510 --> 18:21.210
这个当时应该是非法的意思

18:21.210 --> 18:22.810
引力狗

18:24.810 --> 18:26.810
这是已经流的API

18:26.810 --> 18:28.510
就是已经过时的API

18:28.510 --> 18:30.610
这是之前的API遗留下来的

18:30.610 --> 18:32.910
它说这个API被监测到了

18:32.910 --> 18:34.410
所以说不应该去使用

18:34.410 --> 18:35.210
就完了

18:35.210 --> 18:36.110
我就说一下这个东西

18:36.110 --> 18:37.610
就是在严根模式下面

18:37.610 --> 18:40.010
它可能会给你进行一些监控

18:40.010 --> 18:43.210
监控防止里去写一些错误的代码

18:43.210 --> 18:44.010
不合适的代码

18:44.010 --> 18:45.110
至少说

18:45.110 --> 18:47.210
OK 这是严根模式

18:47.210 --> 18:48.310
好 下面这个

18:48.310 --> 18:50.710
下面这个工具

18:50.710 --> 18:53.210
就把这个复制一下

18:53.210 --> 18:54.410
下面这个工具

18:54.410 --> 18:55.610
我们说一下

18:55.610 --> 18:56.910
这个profiler

18:56.910 --> 18:58.410
它是一个分析器

18:58.410 --> 19:02.810
它是一个性能分析工具

19:02.810 --> 19:03.910
它是一个工具

19:03.910 --> 19:06.710
这个工具它不是在代码里边去使用

19:06.710 --> 19:08.710
而是在我们安装的一个

19:08.710 --> 19:10.610
流量器插件里边用的

19:10.610 --> 19:12.510
不是我们当时安装了这个东西吗

19:12.510 --> 19:13.310
就跑了去了

19:13.310 --> 19:14.310
这个玩意对吧

19:14.310 --> 19:17.410
rex developer tools

19:17.410 --> 19:18.310
安装了这个东西

19:18.310 --> 19:20.010
它是在这里边去使用的

19:20.010 --> 19:21.010
咱们找到这个

19:21.010 --> 19:22.610
这里边不是一个profiler吗

19:22.610 --> 19:24.410
就是一个性能分析工具

19:24.410 --> 19:25.610
它能关码

19:25.610 --> 19:28.410
它能够做出分析

19:28.410 --> 19:36.110
某一次或多次提交

19:36.110 --> 19:38.610
涉及到的组件

19:38.610 --> 19:39.610
就是某一次提交

19:39.610 --> 19:41.510
什么叫提交就是更新

19:41.510 --> 19:43.210
因为我们说提交更新

19:43.210 --> 19:44.110
我们更新的一些东西

19:44.110 --> 19:45.910
用户做了某些操作

19:46.010 --> 19:47.610
某一次多次提交

19:47.610 --> 19:52.210
涉及到了组件的渲染时间

19:52.210 --> 19:53.510
这个组件经过了多少时间

19:53.510 --> 19:55.210
把它渲染完成

19:55.210 --> 19:56.610
就分析这个东西

19:56.610 --> 19:58.210
那么我们可以找出那些

19:58.210 --> 19:59.510
耗时比较长的组件

19:59.510 --> 20:01.210
我们可以对它进行优化

20:01.210 --> 20:02.410
主要是起这么一个作用

20:02.410 --> 20:04.910
这里我给大家写个例子

20:04.910 --> 20:06.010
写个例子

20:06.010 --> 20:07.410
我们快速写一个

20:07.410 --> 20:08.810
就把这个删了

20:08.810 --> 20:10.010
rcc

20:11.210 --> 20:14.910
这里咱们写这么一个例子

20:16.610 --> 20:21.640
到之前的工具方

20:21.640 --> 20:23.340
就是services里面

20:23.340 --> 20:24.540
不是一个students

20:24.540 --> 20:26.640
RJX请求拿到所有的学生

20:26.640 --> 20:28.540
它不是里面提供了一个方法

20:28.540 --> 20:29.540
我们之前写过的

20:29.540 --> 20:30.740
get all students

20:30.740 --> 20:32.540
得到所有的学生

20:32.540 --> 20:35.540
然后我们在app里面写上这么一个状态

20:35.540 --> 20:36.340
state

20:36.340 --> 20:38.240
就是一个学生student

20:38.240 --> 20:39.940
一个学生的数数

20:39.940 --> 20:40.840
就完了

20:40.840 --> 20:43.040
然后再写这么一个函数

20:43.040 --> 20:47.040
就是load student

20:48.240 --> 20:49.240
写这么一个函数

20:49.240 --> 20:51.240
这个函数的作用就是来

20:51.240 --> 20:53.440
RJX用RJX的方式

20:53.440 --> 20:55.240
来获取所有学生

20:55.240 --> 20:57.240
咱们这里写上

20:57.240 --> 20:59.040
const students

20:59.040 --> 20:59.840
await

20:59.840 --> 21:01.240
get all students

21:01.240 --> 21:02.440
得到所有的学生

21:02.440 --> 21:03.440
然后拿到这个数组过后

21:03.440 --> 21:05.640
重新给这个状态复制

21:05.640 --> 21:08.040
st

21:08.040 --> 21:09.440
still nest

21:09.440 --> 21:10.640
重新给这个状态复制

21:10.640 --> 21:11.440
就完事了

21:11.440 --> 21:14.440
这就是一个写这么一个函数

21:14.440 --> 21:16.640
然后在Render的时候

21:16.640 --> 21:18.040
我们显示一个div

21:18.040 --> 21:20.640
这个div里面要显示

21:20.640 --> 21:22.240
当然前面要显示一个

21:22.240 --> 21:26.040
显示一个学生集合

21:26.040 --> 21:27.040
把显示到这

21:27.040 --> 21:28.940
以后我们写个组件让它显示

21:28.940 --> 21:30.540
然后下面提供两个按钮

21:30.540 --> 21:34.240
一个按钮是加载学生数据

21:34.240 --> 21:34.940
这个按钮

21:34.940 --> 21:36.240
当我们点击的时候

21:36.240 --> 21:37.740
我们就把它映射到那个函数

21:37.740 --> 21:38.740
this hand

21:38.740 --> 21:40.840
this load students

21:40.840 --> 21:43.040
把它映射到这个函数

21:43.040 --> 21:43.740
没问题吧

21:43.740 --> 21:44.540
好ok

21:44.540 --> 21:46.240
那么现在我们再写个按钮

21:46.240 --> 21:47.740
清空数据

21:47.740 --> 21:48.540
把数据清空

21:48.540 --> 21:49.740
那么这个按钮很简单

21:49.740 --> 21:52.040
就unclick

21:52.040 --> 21:54.240
然后写了这么一个东西

21:54.240 --> 21:56.440
this says that

21:56.440 --> 21:57.940
stil nest

21:57.940 --> 21:59.540
把设为空数就完事了

21:59.540 --> 22:00.340
一个是清空数据

22:00.340 --> 22:03.040
一个是加载学生数据

22:03.040 --> 22:05.240
然后我们在下边显示学生集合

22:05.240 --> 22:07.440
按钮写上边

22:07.440 --> 22:08.040
行了

22:08.040 --> 22:09.440
那么咱们写一个组件

22:09.440 --> 22:11.440
用来显示学生集合

22:11.440 --> 22:12.940
为了显示学生集合的话

22:12.940 --> 22:13.740
咱们需要一个组件

22:13.740 --> 22:15.640
就在显示单个学生

22:15.640 --> 22:17.140
student

22:17.140 --> 22:18.340
extend

22:18.340 --> 22:19.840
component

22:19.840 --> 22:20.940
render

22:20.940 --> 22:21.940
这个学生组件

22:21.940 --> 22:24.640
它是用来渲染单个学生的

22:24.640 --> 22:25.840
就是一个li

22:25.840 --> 22:26.840
就一个li

22:26.840 --> 22:29.240
这个li里面就显示学生的姓名

22:29.240 --> 22:30.140
就完事了

22:30.140 --> 22:31.140
就显示学生的姓名

22:31.140 --> 22:31.840
ok

22:31.840 --> 22:33.240
你就传个姓名过来就行了

22:33.240 --> 22:34.340
其他我也不要了

22:34.340 --> 22:34.840
也不要了

22:34.840 --> 22:36.740
就显示个学生姓名就完了

22:36.740 --> 22:37.240
行了

22:37.240 --> 22:39.040
就写出这么一个组件

22:39.040 --> 22:40.540
然后我们再写个组件

22:40.540 --> 22:41.740
student

22:41.740 --> 22:44.140
extend

22:44.140 --> 22:45.740
component

22:45.740 --> 22:46.640
那么这个组件

22:46.640 --> 22:49.140
它的作用是渲染

22:49.140 --> 22:52.540
渲染所有的学生数据

22:52.540 --> 22:54.540
那么还写个 render

22:54.540 --> 22:56.540
它要给它一个什么属性呢

22:56.540 --> 22:58.140
就是一个学生的数组

22:58.140 --> 23:00.040
你给我一个数组就行了

23:00.040 --> 23:00.540
ok

23:00.540 --> 23:01.840
那么我这里呢

23:01.840 --> 23:03.140
这样吧

23:03.140 --> 23:05.740
我这里就返回一个Ul

23:05.740 --> 23:06.740
返回Ul

23:06.840 --> 23:09.440
Ul里面得到很多个学生组件

23:09.440 --> 23:12.240
我们可以通过这个东西来得到

23:12.240 --> 23:13.940
stues

23:13.940 --> 23:15.440
通过this props

23:15.440 --> 23:16.940
你给我传一个学生

23:16.940 --> 23:19.240
学生集合进来

23:19.240 --> 23:22.240
比方说我们约定属性的名字是stuelist

23:22.240 --> 23:24.940
然后我把映射成为一个学生对象

23:24.940 --> 23:27.940
把映射成为一个学生对象

23:27.940 --> 23:29.940
然后我们这里呢

23:29.940 --> 23:31.440
先暂时不写keyz

23:31.440 --> 23:32.540
先暂时不写keyz

23:32.540 --> 23:34.040
你不是需要个name属性吗

23:34.040 --> 23:34.440
ok

23:34.440 --> 23:35.340
我给你

23:35.340 --> 23:36.240
从这个里面

23:36.240 --> 23:38.840
从一个学生对象里面拿去 name属性给你

23:38.840 --> 23:39.040
好

23:39.040 --> 23:39.340
这里呢

23:39.340 --> 23:41.540
我们把这个stues放进来

23:41.540 --> 23:41.940
行了

23:41.940 --> 23:43.240
我们就写出来这么一个组件

23:43.240 --> 23:43.540
ok

23:43.540 --> 23:44.340
我们在下边呢

23:44.340 --> 23:45.740
去用这个组件

23:45.740 --> 23:46.540
stuelist

23:46.540 --> 23:49.540
我把你需要的学生数据给你

23:49.540 --> 23:50.740
来自于我的状态

23:50.740 --> 23:52.540
stets still list

23:52.540 --> 23:54.840
stil list

23:54.840 --> 23:55.140
好

23:55.140 --> 23:55.640
行了

23:55.640 --> 23:57.140
咱们就这里就写好了

23:57.140 --> 23:58.340
一个非常非常简单的组件

23:58.340 --> 23:59.840
就一个套一个

23:59.840 --> 24:01.340
接下来我们来做一下分析

24:01.340 --> 24:02.240
做一下性能分析

24:04.240 --> 24:05.340
这里边呢

24:05.440 --> 24:06.640
我们先看一下效果吗

24:06.640 --> 24:07.640
点击加带

24:07.640 --> 24:08.240
这里报错

24:08.240 --> 24:09.040
没有写key

24:09.040 --> 24:10.040
没有写keyz

24:10.040 --> 24:10.240
ok

24:10.240 --> 24:12.440
我们把keyz加上

24:12.440 --> 24:13.640
keyz加上

24:13.640 --> 24:15.440
hid

24:15.440 --> 24:15.740
好

24:15.740 --> 24:18.040
保存

24:18.040 --> 24:18.240
好

24:18.240 --> 24:19.940
接下来我们来看一下加载水分数据

24:19.940 --> 24:21.140
你看是不是加载出来了

24:21.140 --> 24:22.640
清空数据加载数据

24:22.640 --> 24:24.340
清空数据加载数据

24:24.340 --> 24:24.540
好

24:24.540 --> 24:26.240
我们接下来再去做性能分析

24:26.240 --> 24:28.540
重新刷新一次

24:28.540 --> 24:30.340
再做这个性能分析

24:30.340 --> 24:31.540
现在我们点这

24:31.540 --> 24:32.540
进行录制

24:32.540 --> 24:33.940
什么叫录制呢

24:33.940 --> 24:35.140
那么我们点了过后

24:35.140 --> 24:37.740
它现在开始监控我们的数据变化

24:37.740 --> 24:39.940
那么我们每一次数据提交

24:39.940 --> 24:42.440
有哪些组件发生了更新

24:42.440 --> 24:43.540
它就会监控到

24:43.540 --> 24:45.140
比方说我们这里点一下这个

24:45.140 --> 24:46.440
它监控到了

24:46.440 --> 24:47.740
然后点一下这个监控到了

24:47.740 --> 24:48.640
两次了

24:48.640 --> 24:49.840
再点一下这个

24:49.840 --> 24:51.040
三次了

24:51.040 --> 24:52.540
再点一下这个

24:52.540 --> 24:53.140
四次了

24:53.140 --> 24:54.840
是不是提交了四次了

24:54.840 --> 24:56.440
发生了四次更新

24:56.440 --> 24:56.540
好

24:56.540 --> 24:57.740
我们这里停止

24:57.740 --> 24:58.540
你看一下这里

24:58.540 --> 25:00.040
是不是出现了四次更新

25:00.040 --> 25:01.040
总共有四次更新

25:01.040 --> 25:02.940
目前我们看到的是第一次更新

25:02.940 --> 25:03.440
第二次

25:03.440 --> 25:03.940
第三次

25:03.940 --> 25:05.040
第四次

25:05.140 --> 25:07.740
每一次我们每一次更新里边

25:07.740 --> 25:08.840
我们都可以看到

25:08.840 --> 25:09.340
看到什么了

25:09.340 --> 25:10.740
看到它每一个组件

25:10.740 --> 25:12.340
它经过了渲染时间

25:12.340 --> 25:13.440
你看这里

25:13.440 --> 25:14.940
第一次更新

25:14.940 --> 25:17.640
它这个黑色的就表示的是第一次更新

25:17.640 --> 25:19.040
那么这个绿色的就表示

25:19.040 --> 25:21.040
它的时间用的比较短

25:21.040 --> 25:21.740
用的比较短

25:21.740 --> 25:23.340
相对来说时间用的比较短

25:23.340 --> 25:25.540
黄色的用的时间比较多一点

25:25.540 --> 25:27.840
这个黑色表示我们当前查看了更新

25:27.840 --> 25:28.640
那么这一次更新

25:28.640 --> 25:29.840
它这里有个摘要

25:29.840 --> 25:31.240
一个就是提交摘要

25:31.240 --> 25:32.640
就是提交这一次更新

25:32.640 --> 25:33.940
它的摘要信息

25:33.940 --> 25:35.740
就是在什么时间点提交的

25:35.740 --> 25:36.940
是我们开始录制过后

25:36.940 --> 25:39.640
10秒钟过后提交的提交了更新

25:39.640 --> 25:43.940
那么整个渲染过程经过了8.6毫秒

25:43.940 --> 25:44.940
就这么个意思

25:44.940 --> 25:46.640
整个过程经过了8.6毫秒

25:46.640 --> 25:48.740
那么在这具体的信息那里看

25:48.740 --> 25:50.140
下面就有

25:50.140 --> 25:51.840
我们可以看到跟主键 app

25:51.840 --> 25:52.940
这是我们的跟主键

25:52.940 --> 25:54.340
跟主键发生了渲染

25:54.340 --> 25:55.540
重新渲染

25:55.540 --> 25:56.840
那如果跟主键没有渲染的话

25:56.840 --> 25:58.140
你会看到一个灰色的

25:58.140 --> 25:59.240
你会看到一个灰色的

25:59.240 --> 26:01.540
它就没有这个数字

26:01.540 --> 26:01.940
好

26:01.940 --> 26:03.740
那么这里边有两个数字

26:03.740 --> 26:04.940
这个数字是什么意思

26:04.940 --> 26:05.840
8.6毫秒

26:05.840 --> 26:06.440
这个很简单

26:06.440 --> 26:09.440
就是它的总共的渲染时间

26:09.440 --> 26:11.140
因为我们渲染的就是这个节点

26:11.140 --> 26:12.640
重新渲染的就是这个节点

26:12.640 --> 26:15.940
那么这个节点总共渲染了8.6毫秒

26:15.940 --> 26:18.240
那么我们可以看到右边的提交数据

26:18.240 --> 26:18.940
提交里面

26:18.940 --> 26:19.940
我们总共提交

26:19.940 --> 26:21.340
就整个全部渲染完

26:21.340 --> 26:23.040
是不是渲染了8.6毫秒

26:23.040 --> 26:24.640
这两个数据是一致的

26:24.640 --> 26:26.140
为什么是一致的

26:26.140 --> 26:27.540
你想的到的

26:27.540 --> 26:29.540
我更新的时候不去更新它吗

26:29.540 --> 26:30.340
更新了它

26:30.340 --> 26:31.040
那它渲染完了

26:31.040 --> 26:32.340
是不是整个就渲染完了

26:32.340 --> 26:32.740
对不对

26:32.740 --> 26:34.440
说它的数据跟它一致的

26:34.440 --> 26:36.340
就是说我花了

26:36.340 --> 26:38.240
整个花了8.6毫秒

26:38.240 --> 26:39.440
当然这8.6毫秒

26:39.440 --> 26:42.740
我自身渲染只用了0.4毫秒

26:42.740 --> 26:44.940
我自己没有渲染多少时间

26:44.940 --> 26:46.040
那么剩下的一些时间

26:46.040 --> 26:46.740
剩下的一些时间

26:46.740 --> 26:48.240
可能在用于一些循环

26:48.240 --> 26:49.440
做一些额外的操作

26:49.440 --> 26:51.240
还包括一些止节点的渲染

26:51.240 --> 26:53.040
你看它止节点渲染了什么

26:53.040 --> 26:55.440
渲染了7.8毫秒

26:55.440 --> 26:58.540
你看7.8加上它自己渲染的0.4

26:58.540 --> 26:59.740
是不是等于8.2

26:59.740 --> 27:01.140
8.2

27:01.240 --> 27:02.740
那么还有0.4毫秒

27:02.740 --> 27:04.140
是做一些额外的事情

27:04.140 --> 27:05.040
花费的时间

27:05.040 --> 27:06.140
总之呢

27:06.140 --> 27:07.740
整个渲染了花费了多少

27:07.740 --> 27:09.540
花分了8.6毫秒

27:09.540 --> 27:10.640
那么我们点击它过后

27:10.640 --> 27:12.440
还可以在右边看到

27:12.440 --> 27:14.240
它目前的状态数据

27:14.240 --> 27:15.540
它目前不是有个状态

27:15.540 --> 27:16.240
Still List吗

27:16.240 --> 27:17.340
它里面有个数组

27:17.340 --> 27:19.340
92个对象

27:19.340 --> 27:20.840
可以看到这些数据

27:20.840 --> 27:22.040
有问题吧

27:22.040 --> 27:24.440
它的属性是空的

27:24.440 --> 27:25.640
然后我们点这个

27:25.640 --> 27:26.240
你可以看到

27:26.240 --> 27:28.040
这个花费了7.8毫秒

27:28.040 --> 27:30.540
但它自己渲染了只花了1.7毫秒

27:30.540 --> 27:31.640
那么剩下的事情

27:31.640 --> 27:32.940
做了一些额外的事情

27:32.940 --> 27:34.040
那么通过这个长度

27:34.040 --> 27:35.240
也可以看出它们的比例

27:35.240 --> 27:36.140
看到没

27:36.140 --> 27:37.340
它花了8.6

27:37.340 --> 27:38.040
它充满的

27:38.040 --> 27:38.640
那么7.8

27:38.640 --> 27:40.340
大概到这

27:40.340 --> 27:41.140
那么点它的时候

27:41.140 --> 27:42.040
就因为它

27:42.040 --> 27:42.940
如果它是充满的

27:42.940 --> 27:44.740
那么下面的比例是多少

27:44.740 --> 27:45.840
那么它自己呢

27:45.840 --> 27:47.340
花费了1.7毫秒

27:47.340 --> 27:48.840
但是它整个渲染过程

27:48.840 --> 27:50.240
花费了7.8毫秒

27:50.240 --> 27:50.740
那么下面呢

27:50.740 --> 27:52.140
可以看到它的属性

27:52.140 --> 27:53.540
可以看到它的属性

27:53.540 --> 27:55.140
这些组件都发生了渲染

27:55.140 --> 27:55.940
那么它下面呢

27:55.940 --> 27:58.340
就看到每一个组件的渲染

27:58.340 --> 28:00.140
第一个Still List的组件的渲染

28:00.140 --> 28:00.840
已经呢

28:00.840 --> 28:02.240
第二个Still List的渲染

28:02.240 --> 28:04.640
你看

28:04.640 --> 28:05.940
对吧

28:05.940 --> 28:07.740
当然有些非常快

28:07.740 --> 28:09.040
几乎是没有花时间

28:09.040 --> 28:10.340
它都记录不到了

28:10.340 --> 28:10.940
记录不到了

28:10.940 --> 28:11.840
我们就不用说了

28:11.840 --> 28:13.140
因为它我们通过这个工具

28:13.140 --> 28:17.840
主要是分析出那些花费时间比较长的

28:17.840 --> 28:19.740
那么现在我们就分析出来了

28:19.740 --> 28:22.140
那么我们就可以利用这个看一下

28:22.140 --> 28:23.840
如果我不加T

28:23.840 --> 28:26.040
不加T会怎么样

28:26.040 --> 28:27.740
你看一下

28:27.740 --> 28:29.940
我们这里开始记录

28:29.940 --> 28:32.140
加载学生数据

28:32.140 --> 28:34.540
再轻空数据

28:34.540 --> 28:35.640
当然这个不加T的话

28:35.640 --> 28:36.840
目前也看不到什么

28:36.840 --> 28:39.640
看不到什么样的太大的变化

28:39.640 --> 28:41.440
也看不到太大的变化

28:41.440 --> 28:42.140
为什么呢

28:42.140 --> 28:43.440
因为不加T的话

28:43.440 --> 28:45.240
因为我们目前没有加数据

28:45.240 --> 28:46.040
对不对

28:46.040 --> 28:48.440
没往这个水深对象里面加数据

28:48.440 --> 28:49.640
那么我们加个按钮

28:49.640 --> 28:51.040
加一个按钮

28:51.040 --> 28:53.340
你可以看出来了

28:53.340 --> 28:55.240
加个按钮

28:55.240 --> 28:56.440
这样吧

28:56.440 --> 28:59.340
打乱顺序

28:59.340 --> 29:00.140
随机顺序

29:00.140 --> 29:02.640
把这个学生的数据的顺序打断

29:02.640 --> 29:04.440
这样做的目的是什么呢

29:04.440 --> 29:06.240
因为它如果没有Key值的话

29:06.240 --> 29:07.940
那么它就是按照位置来比较了

29:07.940 --> 29:08.340
对吧

29:08.340 --> 29:11.040
它不知道下一个动物数里边

29:11.040 --> 29:13.040
每一个堆印到之前的哪个位置

29:13.040 --> 29:15.140
它就要每一个从头开始比较了

29:15.140 --> 29:17.640
就是没有Key值的情况

29:17.640 --> 29:18.940
它就会导致很多动物元素

29:18.940 --> 29:20.440
要被重建

29:20.440 --> 29:22.140
比方说文笨节点

29:22.140 --> 29:23.540
它就会被重建

29:23.540 --> 29:27.140
这里我们set state

29:27.140 --> 29:28.540
这里重新给它复制

29:28.640 --> 29:31.540
然后来自于它之前的排序

29:31.540 --> 29:34.040
sort

29:34.040 --> 29:34.740
排序

29:34.740 --> 29:35.340
排序的

29:35.340 --> 29:37.240
随机顺序怎么写的

29:37.240 --> 29:38.540
这个没什么好说的

29:38.540 --> 29:40.240
mas redden

29:40.240 --> 29:41.540
减0.5

29:41.540 --> 29:43.840
这样子我们重新得到一个随机排序的数据

29:43.840 --> 29:45.040
重新给它复制

29:45.040 --> 29:46.940
然后让它重新渲染

29:46.940 --> 29:50.540
为了让我们更加明显的看到效果的话

29:50.540 --> 29:52.640
我们这里把Key值去掉

29:52.640 --> 29:55.040
每一个学生对象里边

29:55.040 --> 29:57.040
我多给它写一些东西

29:57.140 --> 29:57.940
我多给它

29:57.940 --> 29:59.440
尽量给它多写一些东西

29:59.440 --> 30:00.340
这样子

30:00.340 --> 30:01.740
因为如果你写少了的话

30:01.740 --> 30:03.840
它其实写少了的话

30:03.840 --> 30:04.840
你看不出来

30:04.840 --> 30:05.740
不再看得出来

30:05.740 --> 30:08.340
它的效率的变化

30:08.340 --> 30:09.340
比方说这里

30:09.340 --> 30:11.340
我们再给它写个Span元数

30:11.340 --> 30:12.740
Span元数里边是

30:12.740 --> 30:15.640
student props name

30:15.640 --> 30:17.240
然后再写个Span元数

30:17.240 --> 30:19.540
this is the props age

30:19.540 --> 30:20.840
年龄

30:20.840 --> 30:23.440
然后我们看一下学生还有哪些数据

30:23.440 --> 30:24.640
学生还有哪些数据

30:25.640 --> 30:26.940
看一下

30:26.940 --> 30:28.540
还有什么数据

30:28.540 --> 30:29.640
而dress

30:29.640 --> 30:30.640
这些东西全部写上

30:30.640 --> 30:35.320
而dress

30:35.320 --> 30:37.020
这是地址

30:37.020 --> 30:37.820
多写一点

30:37.820 --> 30:39.720
多写一点就看得出来差异了

30:39.720 --> 30:41.320
然后burst

30:41.320 --> 30:42.320
年龄有吗

30:42.320 --> 30:43.420
没有年龄

30:43.420 --> 30:44.120
没有年龄

30:44.120 --> 30:45.420
是个burst

30:45.420 --> 30:46.020
OK

30:46.020 --> 30:47.520
burst

30:47.520 --> 30:48.520
再来一个

30:48.520 --> 30:50.020
多来几个

30:50.020 --> 30:53.820
然后email

30:53.820 --> 30:55.820
然后再来

30:55.820 --> 30:59.150
fone

30:59.150 --> 30:59.950
多写几个

30:59.950 --> 31:01.050
再来一个

31:01.050 --> 31:04.850
再来一个6

31:04.850 --> 31:05.450
OK

31:05.450 --> 31:06.450
把这些数据全部写上

31:06.450 --> 31:08.150
单个决定有这么多数据

31:08.150 --> 31:09.050
那么这样子一来

31:09.050 --> 31:10.250
如果你打乱顺序过后

31:10.250 --> 31:11.150
没有气质的话

31:11.150 --> 31:12.850
那么它要从头开始构建

31:12.850 --> 31:14.150
那么这样子一来的话

31:14.150 --> 31:16.150
它要更新的动物元数

31:16.150 --> 31:17.650
就会有非常非常多

31:17.650 --> 31:18.450
当然这个里面

31:18.450 --> 31:20.450
因为我数据本来只有这么一点

31:20.450 --> 31:22.350
可能效果还没有那么明显

31:22.350 --> 31:23.650
我们可以看一下

31:23.650 --> 31:24.850
可以看一下

31:24.950 --> 31:26.550
现在我们没有keyz

31:26.550 --> 31:27.950
没有keyz

31:27.950 --> 31:28.150
好

31:28.150 --> 31:29.150
数据加载出来之后

31:29.150 --> 31:30.750
咱们来录制一下

31:30.750 --> 31:31.750
先让我们打乱顺序

31:31.750 --> 31:33.650
现在是没有keyz的情况

31:33.650 --> 31:34.950
没有keyz

31:34.950 --> 31:36.350
好

31:36.350 --> 31:37.450
点10是吗

31:37.450 --> 31:41.850
12345678910

31:41.850 --> 31:44.050
停止

31:44.050 --> 31:45.350
大家看一下

31:45.350 --> 31:46.550
这时间太多了

31:46.550 --> 31:47.850
主要是数据太少了

31:47.850 --> 31:48.950
我们的数据太少了

31:48.950 --> 31:49.850
这点数据

31:49.850 --> 31:51.250
像我们真实的

31:51.250 --> 31:52.450
因为里面拿出来

31:52.450 --> 31:53.550
根本不止这点数据

31:53.550 --> 31:55.550
而且我们的元素结构很简单

31:55.550 --> 31:56.850
所以说光从时间上

31:56.850 --> 31:58.050
你可能看不出来

31:58.050 --> 31:59.650
以后我们可能看不出来

31:59.650 --> 32:02.250
它的差异有多大

32:02.250 --> 32:03.550
因为没有keyz的话

32:03.550 --> 32:04.050
有的时候

32:04.050 --> 32:05.150
你数据量少的时候

32:05.150 --> 32:06.650
反而会提高效率

32:06.650 --> 32:07.750
不过那个提高效率

32:07.750 --> 32:08.550
可以忽略不具

32:08.550 --> 32:09.150
为什么

32:09.150 --> 32:11.250
因为它减少了key的

32:11.250 --> 32:13.550
去寻找相同key的过程

32:13.550 --> 32:14.050
对吧

32:14.050 --> 32:15.750
寻找那个相同keyz的过程

32:15.750 --> 32:17.050
它省略掉了

32:17.050 --> 32:18.350
因此某些时候

32:18.350 --> 32:19.150
数据量少的时候

32:19.150 --> 32:20.950
还会提高效率

32:20.950 --> 32:23.350
但是那点提高效率是微不足道的

32:23.750 --> 32:24.650
但是我们可以看到

32:24.650 --> 32:26.050
有一个现象就是

32:26.050 --> 32:28.050
你看这个元素渲染

32:28.050 --> 32:29.050
student list

32:29.050 --> 32:30.550
它这里在渲染的时候

32:30.550 --> 32:33.550
它的绝大部分时间花费到了哪去了

32:33.550 --> 32:35.950
花费到了渲染指援数上面去了

32:35.950 --> 32:36.750
对吧

32:36.750 --> 32:38.650
它绝大部分时间花费在

32:38.650 --> 32:40.050
渲染指援数上面去了

32:40.050 --> 32:41.750
你看指援数渲染这么多时间

32:41.750 --> 32:43.050
占用了这么多

32:43.050 --> 32:44.850
它整体时间只有这么多

32:44.850 --> 32:46.750
它只有0.7秒在渲染自己

32:46.750 --> 32:48.650
然后指援数在渲染这么多时间

32:48.650 --> 32:50.350
花费了这么多时间就渲染指援数

32:50.450 --> 32:50.850
为什么?

32:50.850 --> 32:54.350
因为很多指援数都需要重新渲染

32:54.350 --> 32:55.550
所以说你这一块

32:55.550 --> 32:57.150
你看到这么一个结果

32:57.150 --> 32:58.150
包括其他都是你看

32:58.150 --> 32:59.650
你看它比例是很高的

32:59.650 --> 33:01.150
它的指援数占用了

33:01.150 --> 33:03.450
花费的时间的比例是非常高的

33:03.450 --> 33:04.350
你看

33:04.350 --> 33:05.950
接下来我们把keyz加上

33:05.950 --> 33:08.550
keyz加上

33:08.550 --> 33:09.450
keyz加上的话

33:09.450 --> 33:11.050
我们加上id

33:11.050 --> 33:13.950
我们看一下加上keyz有什么样的特点

33:13.950 --> 33:15.650
加载全程数据

33:15.650 --> 33:16.850
接下来我们开始录制

33:16.850 --> 33:17.950
录制

33:17.950 --> 33:21.350
1 2 3 4 5 6 7 8 9 10

33:21.350 --> 33:23.550
还是点10是停止

33:23.550 --> 33:25.350
你会看到了时间上

33:25.350 --> 33:26.350
好像是差不多

33:26.350 --> 33:28.650
但是你会发现这个短了一点

33:28.650 --> 33:30.350
因为我们现在主要是太少了

33:30.350 --> 33:31.450
数据太少了

33:31.450 --> 33:33.650
看不到这种明显的差距

33:33.650 --> 33:35.350
那么这里是不是短了

33:35.350 --> 33:36.950
它的花费的时间

33:36.950 --> 33:37.850
绝大部分时间

33:37.850 --> 33:40.550
不在渲染指援数上面去了

33:40.550 --> 33:42.250
因为指援数需要重新渲染的

33:42.250 --> 33:44.450
其实很少

33:44.450 --> 33:46.250
它不需要花费那么多时间

33:46.250 --> 33:48.250
花费到渲染指援数上面去了

33:48.250 --> 33:50.350
因为指援数它只需要重新排序就行了

33:50.350 --> 33:52.350
把动物节点重新排序

33:52.350 --> 33:53.950
把真实动物节点重新排序

33:53.950 --> 33:54.950
它不需要

33:54.950 --> 33:57.550
然后重新构建动物节点了

33:57.550 --> 33:58.950
因为我们这里的动物节点

33:58.950 --> 34:00.150
因为现在看不出来差异

34:00.150 --> 34:02.550
是因为我们这里的动物节点结构很简单

34:02.550 --> 34:05.450
它里边没有出现那种复杂的结构

34:05.450 --> 34:07.550
另外是因为我们的数据量太少

34:07.550 --> 34:08.250
所以看不出来差异

34:08.250 --> 34:09.850
但是我们可以看到明显的

34:09.850 --> 34:12.650
这一块时间占比变少了

34:12.650 --> 34:13.950
所以说这个哎呀

34:13.950 --> 34:15.750
不太好演示

34:15.750 --> 34:17.450
我也不可能为了这个演示

34:17.450 --> 34:19.750
去在这里边写一个很复杂的动物结构

34:19.750 --> 34:20.850
那这样子吧

34:20.850 --> 34:23.050
咱们反正先把这个工具介绍到这

34:23.050 --> 34:26.450
以后咱们要做很多练习

34:26.450 --> 34:27.050
做一些练习

34:27.050 --> 34:28.450
做到遇到一些复杂结构的时候

34:28.450 --> 34:29.450
我们可以利用这个工具

34:29.450 --> 34:31.750
看一下加T和不加T

34:31.750 --> 34:33.850
它们的很显著的区别

34:33.850 --> 34:35.450
现在我们说是看不到

34:35.450 --> 34:37.250
因为数据量一是很少

34:37.250 --> 34:41.650
二是我们的结构不够复杂

34:41.650 --> 34:43.050
因为我们就算没有Key

34:43.050 --> 34:45.150
它也只是改变了文本节点

34:45.150 --> 34:46.650
它也只是改变了文本节点

34:46.650 --> 34:49.050
它没有更多的生存值的变化

34:49.050 --> 34:50.250
所以说我们可以看不到

34:50.250 --> 34:51.450
这种明显的效果

34:51.450 --> 34:52.350
但是如果以后

34:52.350 --> 34:53.850
我们改变了文本节点

34:53.850 --> 34:54.750
就是如果以后

34:54.750 --> 34:56.750
不仅仅是我改变文本节点

34:56.750 --> 34:58.650
我们可能要改动很多很多东西的时候

34:58.650 --> 35:00.850
就可以看到很明显的变化了

35:00.850 --> 35:02.350
所以我们先放着吧

35:02.350 --> 35:03.650
先放着

35:03.650 --> 35:05.050
然后我们在这里

35:05.050 --> 35:06.850
先这样子写一下看行不行

35:06.850 --> 35:09.350
如果这里我们这样子写一下

35:09.350 --> 35:11.550
就是ZS props

35:11.850 --> 35:15.450
这个什么6

35:15.450 --> 35:16.450
如果等于

35:16.450 --> 35:18.450
因为我们把所有的属性都传过来了

35:18.450 --> 35:20.850
这里我们把这个属

35:22.850 --> 35:24.650
这里只加了Name属性对吧

35:24.650 --> 35:26.550
我这里只加了Name属性

35:26.550 --> 35:28.450
还有其他属性都没有加过来

35:28.450 --> 35:30.150
怎么把所有的属性都给它

35:30.150 --> 35:32.250
我说怎么属性少的一些呢

35:32.250 --> 35:33.850
把状态里边的

35:33.850 --> 35:37.150
把业程里边的所有属性都给它

35:37.150 --> 35:38.150
就是个学生的最下里面

35:38.150 --> 35:39.050
所有属性都给它

35:39.050 --> 35:42.050
重新来一次 再试一下吧

35:42.050 --> 35:43.050
加载全程数据

35:43.050 --> 35:45.250
看能不能看出来一个效果

35:45.250 --> 35:46.750
现在数据多了一些了

35:46.750 --> 35:48.050
我们点击录制

35:48.050 --> 35:48.650
打六岁去

35:48.650 --> 35:49.450
1 2 3

35:49.450 --> 35:50.650
点三次

35:50.650 --> 35:51.250
行了

35:51.250 --> 35:52.050
看一下

35:52.050 --> 35:53.250
28毫秒

35:53.250 --> 35:54.850
然后赞比

35:54.850 --> 35:57.450
资源数的渲染占比这么多

35:57.450 --> 36:01.650
咱们看一下把T去掉

36:01.650 --> 36:03.650
去掉

36:03.650 --> 36:05.750
然后加载数据

36:05.750 --> 36:06.850
然后重新录制

36:06.850 --> 36:07.650
1 2

36:08.650 --> 36:09.450
点击

36:09.450 --> 36:12.250
1 2 3

36:12.250 --> 36:13.050
你看它

36:13.050 --> 36:14.650
现在我们至少能看它的占比

36:14.650 --> 36:15.650
是比较高的

36:15.650 --> 36:17.750
资源数的渲染占比是比较高的

36:17.750 --> 36:19.050
那为什么时间都差不多呢

36:19.050 --> 36:20.550
是因为以为了keyz过后

36:20.550 --> 36:23.750
它还要花费一些时间去寻找相同的keyz

36:23.750 --> 36:25.150
如果数据量很大

36:25.150 --> 36:27.250
如果原素结构足够复杂的话

36:27.250 --> 36:29.350
那么加keyz肯定是有优势的

36:29.350 --> 36:30.250
我们再来试一下

36:30.250 --> 36:31.450
因为数据量有点少

36:31.450 --> 36:33.050
我们的结构也很简单

36:33.050 --> 36:34.850
我们再来试一下这种情况

36:34.850 --> 36:36.150
如果试不出来的话就算了

36:36.150 --> 36:38.350
我们以后结构复杂了过后

36:38.350 --> 36:40.350
就可以看得见效果了

36:40.350 --> 36:41.050
在这个时候的项目中

36:41.050 --> 36:43.150
我们经常用这样的工具来分析

36:43.150 --> 36:43.750
没有keyz的话

36:43.750 --> 36:46.950
你会非常明显的看到这样的效果

36:46.950 --> 36:49.350
这个如果等于1的话

36:49.350 --> 36:50.750
如果等于1的话

36:50.750 --> 36:54.050
那么咱们给它宣展这个东西

36:54.050 --> 36:56.350
如果等于1

36:56.350 --> 37:04.400
那么这里边我们使用这个元素

37:04.400 --> 37:08.500
把这个Span元素改成i元素

37:08.500 --> 37:10.300
否则的话

37:10.400 --> 37:12.200
宣展这个

37:12.200 --> 37:15.200
你看我们故意的把元素结构给它更改

37:15.200 --> 37:17.700
更改它的元素结构

37:17.700 --> 37:22.000
这里要用这个

37:22.000 --> 37:24.100
看一下这个结构

37:24.100 --> 37:26.500
其实还是不够复杂这个结构

37:26.500 --> 37:28.700
实际上平时我们的一个列表里边

37:28.700 --> 37:30.400
像我们一些新闻列表的东西

37:30.400 --> 37:32.100
列表里面东西是非常非常多的

37:32.100 --> 37:33.500
一个列表里面东西非常非常多

37:33.500 --> 37:35.100
千套很深的层次

37:35.100 --> 37:36.400
如果你没有用keyz的话

37:36.400 --> 37:38.100
它要重新构建的话

37:38.100 --> 37:39.800
那肯定要花费更多的时间

37:39.800 --> 37:41.300
我们看一下吧

37:41.400 --> 37:42.900
我们现在是加key还是没加key

37:42.900 --> 37:44.100
加key的

37:44.100 --> 37:45.900
OK我们加载时间数据

37:45.900 --> 37:47.200
然后录制

37:47.200 --> 37:48.100
档论顺序

37:48.100 --> 37:50.300
1 2 3 4 5

37:50.300 --> 37:51.500
停止

37:51.500 --> 37:53.200
花费了39毫秒

37:53.200 --> 37:54.500
第一次花费了39毫秒

37:54.500 --> 37:56.700
然后是20多毫秒

37:56.700 --> 37:59.300
那么每一次它的这么一个占比

37:59.300 --> 38:03.700
接下来我们把keyz去掉

38:03.700 --> 38:06.600
再加点数据

38:06.600 --> 38:08.700
这里录制

38:08.700 --> 38:09.500
档论顺序

38:09.500 --> 38:11.100
1 2 3 4

38:11.100 --> 38:12.400
停止

38:12.500 --> 38:13.000
你看一下

38:13.000 --> 38:14.500
现在看着看着比较明

38:14.500 --> 38:15.500
稍微明显一点的

38:15.500 --> 38:16.000
对吧

38:16.000 --> 38:17.300
刚才是最多是30多毫秒

38:17.300 --> 38:18.600
现在变成40多毫秒了

38:18.600 --> 38:19.300
对不对

38:19.300 --> 38:20.900
现在比较明显一点

38:20.900 --> 38:22.900
而且你看它指援数占比

38:22.900 --> 38:23.900
是比较高的

38:23.900 --> 38:26.400
是非常非常高的

38:26.400 --> 38:27.700
如果它结构更加复杂的话

38:27.700 --> 38:28.700
进一步复杂的话

38:28.700 --> 38:31.500
它可能它的它的更明显

38:31.500 --> 38:32.700
它的效果更明显

38:32.700 --> 38:34.200
但是我这里不够复杂

38:34.200 --> 38:35.400
还不够复杂

38:35.400 --> 38:36.900
就说明这个道理就行了

38:36.900 --> 38:38.900
大家知道有这么个道理就行了

38:38.900 --> 38:42.200
这是关于这个火焰图

38:43.200 --> 38:45.200
录制的时候加载全程数据

38:45.200 --> 38:46.500
它的火焰图

38:46.500 --> 38:48.000
我们这里点三次加载

38:48.000 --> 38:48.900
你看一下

38:48.900 --> 38:50.000
这三次加载是不是都渲染了

38:50.000 --> 38:50.500
对吧

38:50.500 --> 38:51.400
都渲染了

38:51.400 --> 38:52.700
那么这三次加载完了过后

38:52.700 --> 38:55.300
实际上它里边的数据是没有什么变化的

38:55.300 --> 38:55.800
对不对

38:55.800 --> 38:56.400
它里边的数据

38:56.400 --> 38:58.000
基本上是没有什么变化的

38:58.000 --> 38:59.700
那么我们可以利用这一点的

38:59.700 --> 39:00.800
继续优化

39:00.800 --> 39:01.400
继续优化

39:01.400 --> 39:02.100
比方说这里的

39:02.100 --> 39:03.600
我发现它属性没变化的话

39:03.600 --> 39:04.900
我就不要重新更新了

39:04.900 --> 39:07.200
那么我们这里可以用 pure component

39:07.200 --> 39:08.200
这里复制一下

39:08.200 --> 39:10.300
复制一下

39:10.300 --> 39:13.400
我们可以用 pure component来优化一下

39:13.400 --> 39:14.100
保存

39:14.100 --> 39:15.800
咱们看一下吧

39:15.800 --> 39:18.300
好 这里呢

39:18.300 --> 39:20.700
好 咱们来录制

39:20.700 --> 39:23.600
加载一次 两次

39:23.600 --> 39:25.100
再加载再三次

39:25.100 --> 39:27.000
OK 停止

39:27.000 --> 39:28.700
我们从这个图里边可以看到

39:28.700 --> 39:29.700
这个火焰图里边

39:29.700 --> 39:30.400
你可以看到什么呢

39:30.400 --> 39:32.700
这里第一次加载了

39:32.700 --> 39:33.900
稍微时间要长一点

39:33.900 --> 39:34.500
对吧

39:34.500 --> 39:36.300
但是第二次加载

39:36.300 --> 39:38.700
你看下面的直主键是不是就没有加载了

39:38.700 --> 39:39.300
对吧

39:39.400 --> 39:40.300
你看这些灰色的

39:40.300 --> 39:40.500
对吧

39:40.500 --> 39:43.300
灰色的表示它根本就没有使用任何时间

39:43.300 --> 39:44.900
因为它没有重新渲染

39:44.900 --> 39:46.100
因为它发现了

39:46.100 --> 39:48.000
属性值跟之前是一样的

39:48.000 --> 39:49.600
不需要重新渲染了

39:49.600 --> 39:50.800
它没有花费时间

39:50.800 --> 39:52.700
然后前面你看这里

39:52.700 --> 39:53.900
它并没有花费时间

39:53.900 --> 39:55.100
对吧

39:55.100 --> 39:55.700
没问题吧

39:55.700 --> 39:56.500
那么我们下面

39:56.500 --> 39:59.100
它为什么还有一个就是长短不移的形状

39:59.100 --> 40:00.900
它是指的是上一次

40:00.900 --> 40:02.400
上一次花费的时间

40:02.400 --> 40:03.600
你看上一次是不是这样子

40:03.600 --> 40:04.400
对不对

40:04.400 --> 40:06.500
指的是上一次花费的时间

40:06.500 --> 40:09.200
但是这一次根本就没有花时间了

40:09.200 --> 40:11.800
这就是那么一个图表

40:11.800 --> 40:12.800
党政顺序你看一下

40:16.400 --> 40:17.200
现在不能党政顺序

40:17.200 --> 40:18.600
是因为这个sort

40:18.600 --> 40:19.200
这个函数

40:19.200 --> 40:20.500
这个函数有问题

40:20.500 --> 40:22.700
这个函数它返回了当前数组对象

40:22.700 --> 40:24.600
它把当前的数组顺序也改变了

40:24.600 --> 40:26.400
所以说我这里干脆这样子

40:26.400 --> 40:28.100
把当前的数组对象展开

40:28.100 --> 40:30.100
给它返回一个新的数组对象

40:30.100 --> 40:30.600
好吧

40:30.600 --> 40:31.400
这样子

40:31.400 --> 40:32.200
这样子不然的话

40:32.200 --> 40:34.500
党政顺序那一块一块一个bug

40:34.500 --> 40:35.300
点击

40:35.300 --> 40:36.100
党政顺序

40:36.100 --> 40:36.500
OK

40:36.500 --> 40:37.200
没问题

40:37.200 --> 40:38.200
咱们再看一下

40:39.200 --> 40:40.200
党政顺序

40:40.200 --> 40:41.200
党政顺序

40:41.200 --> 40:42.200
stop

40:42.200 --> 40:43.200
那么你看到

40:43.200 --> 40:45.200
只有第一次

40:45.200 --> 40:47.200
就是前面这几次都没有发生

40:47.200 --> 40:50.200
都没有看最多才用5.4毫秒

40:50.200 --> 40:51.200
都没有发生变化

40:51.200 --> 40:52.200
只是位置变了

40:52.200 --> 40:53.200
它里边的东西

40:53.200 --> 40:54.200
数据是没有发生变化的

40:54.200 --> 40:56.200
这里显示的是之前的

40:56.200 --> 40:57.200
加载需要的时间

40:57.200 --> 40:58.200
OK

40:58.200 --> 41:00.200
这是关于这一块

41:01.200 --> 41:02.200
那么这个图表

41:02.200 --> 41:04.200
除了火焰图之外

41:04.200 --> 41:05.200
还有这么一个图

41:05.200 --> 41:07.200
这个图叫做排序图

41:07.200 --> 41:09.200
就是这一次提交的时候

41:09.200 --> 41:10.200
某一次提交的时候

41:10.200 --> 41:12.200
有哪些组建发生了重新渲染

41:12.200 --> 41:13.200
他们渲染的各自渲染

41:13.200 --> 41:15.200
就是渲染自己需要的时间

41:15.200 --> 41:16.200
不是总时间

41:16.200 --> 41:18.200
渲染自己需要的

41:18.200 --> 41:19.200
用的时间是多少

41:19.200 --> 41:20.200
这是4.4毫秒

41:20.200 --> 41:22.200
这个是0.1毫秒

41:22.200 --> 41:23.200
你看

41:23.200 --> 41:24.200
App是0.1毫秒

41:24.200 --> 41:26.200
自身渲染0.1毫秒

41:26.200 --> 41:28.200
Students List渲染需要用了4.4毫秒

41:28.200 --> 41:29.200
对吧

41:29.200 --> 41:30.200
在这里是一个排序图

41:30.200 --> 41:32.200
就是每一次提交

41:32.200 --> 41:33.200
记住一下

41:34.200 --> 41:35.200
这是个排序图

41:35.200 --> 41:36.200
刚才是火焰图

41:36.200 --> 41:37.200
火焰图的话

41:37.200 --> 41:40.200
它是得到某一次提交

41:40.200 --> 41:42.200
每一个组建

41:42.200 --> 41:44.200
每一个组建

41:44.200 --> 41:47.200
总的渲染时间

41:47.200 --> 41:50.200
以及自身的渲染时间

41:50.200 --> 41:52.200
一个是总的

41:52.200 --> 41:53.200
包括它自己

41:53.200 --> 41:54.200
包括它直入件

41:54.200 --> 41:55.200
总的渲染时间

41:55.200 --> 41:56.200
以它自身

41:56.200 --> 41:57.200
光看看它自己

41:57.200 --> 41:59.200
它如何渲染需要多少时间

41:59.200 --> 42:00.200
这是火焰图

42:00.200 --> 42:01.200
还有一个是排序图

42:01.200 --> 42:02.200
得到的是

42:02.200 --> 42:05.200
得到某一次提交

42:05.200 --> 42:08.200
每个组建

42:08.200 --> 42:12.200
自身渲染时间的排序

42:12.200 --> 42:14.200
从高到低进行排序

42:14.200 --> 42:15.200
那么这里

42:15.200 --> 42:16.200
看了

42:16.200 --> 42:17.200
这是个排序图

42:17.200 --> 42:18.200
每一次提交

42:18.200 --> 42:19.200
每一次提交

42:19.200 --> 42:22.200
它的时间是不一样的

42:22.200 --> 42:23.200
那么还有一个图

42:23.200 --> 42:25.200
就是组建图叫做

42:25.200 --> 42:27.200
叫做组建图

42:27.200 --> 42:28.200
指的是

42:28.200 --> 42:30.200
某一个组建

42:30.200 --> 42:34.200
在多次提交中

42:34.200 --> 42:35.200
花费的

42:35.200 --> 42:37.200
自身渲染

42:37.200 --> 42:40.200
花费的时间

42:40.200 --> 42:41.200
看一下吧

42:41.200 --> 42:43.200
组建图

42:43.200 --> 42:45.200
我们到这

42:45.200 --> 42:46.200
随便找一个组建

42:46.200 --> 42:47.200
随便选一个组建

42:47.200 --> 42:48.200
比方到Student List

42:48.200 --> 42:49.200
这个组建

42:49.200 --> 42:50.200
我们想看一下

42:50.200 --> 42:51.200
它不是提交了三次吗

42:51.200 --> 42:52.200
想看一下

42:52.200 --> 42:53.200
它这个组建

42:53.200 --> 42:54.200
这三次提交

42:54.200 --> 42:55.200
每一次花了多少时间

42:55.200 --> 42:56.200
我们可以点这

42:56.200 --> 42:57.200
组建图

42:57.200 --> 42:58.200
点这

42:58.200 --> 42:59.200
你看

42:59.200 --> 43:00.200
第一次花了5.1毫秒

43:00.200 --> 43:01.200
第二次

43:01.200 --> 43:02.200
第二次提交

43:02.200 --> 43:03.200
第三次提交花了1.6毫秒

43:03.200 --> 43:04.200
你看

43:04.200 --> 43:06.200
你看这里

43:06.200 --> 43:07.200
这是第一次提交

43:07.200 --> 43:09.200
这是第二次提交

43:09.200 --> 43:10.200
这是第三次提交

43:10.200 --> 43:11.200
你要这意思吧

43:11.200 --> 43:12.200
这是组建图

43:12.200 --> 43:13.200
看某一个组建

43:13.200 --> 43:15.200
在多次提交中

43:15.200 --> 43:16.200
花费的时间

43:16.200 --> 43:18.200
这些都是性能分析工具

43:18.200 --> 43:19.200
实际上这个工具

43:19.200 --> 43:21.200
还有很多很多的东西

43:21.200 --> 43:22.200
包括

43:22.200 --> 43:23.200
它还可以结合代码

43:23.200 --> 43:25.200
大家可以看到这个东西

43:25.200 --> 43:26.200
还有这个图

43:26.200 --> 43:27.200
这个图我们现在看不到

43:27.200 --> 43:29.200
因为这个图叫做交互图

43:29.200 --> 43:30.200
它可以记录

43:30.200 --> 43:31.200
记录用户

43:31.200 --> 43:33.200
你是点了按钮发生了提交

43:33.200 --> 43:35.200
还是什么滚动滚动条发生了提交

43:35.200 --> 43:38.200
就是看的是跟用户之间的交互

43:38.200 --> 43:41.200
那么这些图都要结合代码来说

43:41.200 --> 43:43.200
这些东西我就不扯远了

43:43.200 --> 43:44.200
不扯远了

43:44.200 --> 43:45.200
要不然我

43:45.200 --> 43:47.200
以后有机会的话

43:47.200 --> 43:48.200
单独开个课吧

43:48.200 --> 43:49.200
单独开个课来说这个东西

43:49.200 --> 43:51.200
它还要结合代码

43:51.200 --> 43:53.200
我们仅仅学习它的简单用法就够了

43:53.200 --> 43:54.200
就够了

43:54.200 --> 43:56.200
就完全够用了

43:56.200 --> 43:57.200
好了

43:57.200 --> 43:59.200
这是关于性能分析工具

43:59.200 --> 44:00.200
其他的就没啥了

44:00.200 --> 44:01.200
没啥了

44:01.200 --> 44:02.200
这是一些工具

44:02.200 --> 44:03.200
了解就行了

44:04.200 --> 44:06.200
这是咱们rex进阶部分的知识

44:06.200 --> 44:07.200
就讲完了

44:07.200 --> 44:09.200
后边如果要需要补充的话

44:09.200 --> 44:11.200
我在单独去录制一些视频

44:11.200 --> 44:12.200
给它补充进去

44:12.200 --> 44:14.200
那么下面我们rex

44:14.200 --> 44:16.200
但是rex本身还没有结束

44:16.200 --> 44:17.200
还有这么一个东西

44:17.200 --> 44:19.200
还有rex hook

44:19.200 --> 44:22.200
咱们专门拿一个章节来讲解

44:23.200 --> 44:25.200
这是个新东西

44:25.200 --> 44:26.200
一个新东西

44:26.200 --> 44:27.200
那么

44:27.200 --> 44:30.200
后边它可能会越来越糊

44:30.200 --> 44:31.200
而且rex官方

44:31.200 --> 44:33.200
它越来越推荐使用这个东西了

44:33.200 --> 44:34.200
有了这个东西过后

44:34.200 --> 44:36.200
我们编写rex代码的话

44:36.200 --> 44:38.200
会发生不少的变化

44:38.200 --> 44:40.200
咱们后边专门拿一章

44:40.200 --> 44:41.200
来说rex hook

44:41.200 --> 44:43.200
那么rex的进阶部分到时结束了

