WEBVTT

00:00.110 --> 00:05.830
好 咱们就继续context 就是上下文

00:05.830 --> 00:14.140
上下文这个概念其实在很多的框架里边

00:14.140 --> 00:16.140
不仅仅是借是框架

00:16.140 --> 00:20.460
如果你以后有机会接触一些其他语言的框架的话

00:20.460 --> 00:22.460
也会经常看到这么一些东西

00:22.460 --> 00:24.460
只这个词叫做上下文

00:24.460 --> 00:27.420
在我们软件开发领域里边

00:27.420 --> 00:30.220
上下文是我们经常体系到的一个概念

00:30.220 --> 00:33.900
所以说我这里先把这个概念给大家讲清楚

00:33.900 --> 00:35.180
什么叫上下文呢

00:35.180 --> 00:39.380
上下文它的英文单词就是context

00:39.380 --> 00:47.340
它表示做某一些事情的环境

00:47.340 --> 00:49.340
比方说 我给大家举个例子

00:49.340 --> 00:50.940
这样说起来比较抽象

00:50.940 --> 00:52.260
给大家举个具体的例子

00:52.260 --> 00:55.020
比方说你在画画

00:55.020 --> 00:56.500
你要画一幅画

00:56.500 --> 00:59.700
这个画可能是比较的复杂

00:59.740 --> 01:03.860
可能你要经过一两个月才能把这幅画完成

01:03.860 --> 01:05.340
它很复杂

01:05.340 --> 01:07.420
然后它会分成几个阶段来做

01:07.420 --> 01:10.020
每个阶段它要做不同的事情

01:10.020 --> 01:14.060
但是你会发现不同的阶段里边

01:14.060 --> 01:17.660
可能他们要用到一些共同的东西

01:17.660 --> 01:25.780
比方说眼料 墨水 画笔这些东西

01:25.780 --> 01:27.500
它可能会用到一些东西

01:27.500 --> 01:30.140
那么这些东西就是一个环境

01:30.140 --> 01:32.260
它组成了我们画画的环境

01:32.260 --> 01:34.740
它给我们画画的每一个步骤

01:34.740 --> 01:35.940
提供支持

01:35.940 --> 01:37.820
这就是个上下文

01:37.820 --> 01:41.860
我们要做一个完整的系统的时候

01:41.860 --> 01:43.980
可能涉及到很多很多的功能

01:43.980 --> 01:45.580
那么涉及到每一个功能的时候

01:45.580 --> 01:47.220
它可能会有一个环境

01:47.220 --> 01:49.740
这个环境里边会提供一些数据

01:49.740 --> 01:52.300
那么我们可以在做这些功能的时候

01:52.300 --> 01:53.860
哪怕这些功能很复杂

01:53.860 --> 01:57.780
那么我们也可以从环境里边把这些数据拿到

01:57.780 --> 01:59.420
那如果再具体的说的话

01:59.420 --> 02:01.060
说到我们的Reactor里边

02:01.060 --> 02:02.260
那么它的上下文

02:02.260 --> 02:03.660
它起一个什么样的作用呢

02:03.660 --> 02:05.460
我给大家先解释清楚

02:05.460 --> 02:07.620
先把道理解释清楚

02:07.620 --> 02:08.220
不然的话

02:08.220 --> 02:09.140
你学到半天都不知道

02:09.140 --> 02:12.720
我这个东西有什么用

02:12.720 --> 02:14.480
比方说咱们的Reactor里边

02:14.480 --> 02:15.560
不是有很多组件吗

02:15.560 --> 02:16.320
对吧

02:16.320 --> 02:18.880
我们用框框表示组件吗

02:18.880 --> 02:20.360
这是个组件跟组件

02:20.360 --> 02:22.160
它形成了个组件数

02:22.160 --> 02:23.800
这里又有一些组件

02:23.800 --> 02:26.600
这是subload

02:26.600 --> 02:28.280
比方说这是直组件

02:28.280 --> 02:29.600
它的直组件

02:29.600 --> 02:31.280
1 2

02:31.280 --> 02:32.200
先两个吧

02:32.200 --> 02:33.600
先两个

02:33.600 --> 02:36.660
subload2

02:36.660 --> 02:38.780
这里放过来点

02:38.780 --> 02:41.020
然后这些组件它也有直组件

02:41.020 --> 02:43.420
它的组件层次可能很深

02:43.420 --> 02:46.620
我这里写的都不是比较浅的

02:46.620 --> 02:49.060
有可能它可能达到10多20层

02:49.060 --> 02:50.420
这是完全有可能的

02:50.420 --> 02:52.820
所以它组件层次可能比较深

02:52.820 --> 02:54.580
我们这里又有个组件

02:54.660 --> 02:56.020
切二的B

02:56.020 --> 02:57.940
这里是切二的C

02:57.940 --> 02:59.420
比方说

02:59.420 --> 03:01.140
我们用线把它连接起来

03:02.900 --> 03:06.680
连接一下

03:06.680 --> 03:08.720
这里连接过来

03:08.720 --> 03:10.520
这是一个组件

03:10.520 --> 03:12.320
它的直组件

03:12.320 --> 03:16.430
然后这里有一个直组件

03:16.430 --> 03:20.990
然后这里有一个直组件

03:20.990 --> 03:24.700
这里也有

03:24.700 --> 03:25.860
直组件

03:25.860 --> 03:27.100
这里也有

03:27.100 --> 03:29.540
总之它的千套层次会比较深

03:29.540 --> 03:30.820
所以我这里就不多画了

03:30.820 --> 03:32.420
就花这么几个就行了

03:32.420 --> 03:33.620
切二的1

03:33.620 --> 03:35.180
再来一个

03:35.180 --> 03:38.420
比方说我们可能会遇到这么一些场景

03:38.420 --> 03:41.860
我们的应用程序里面可能会有一些数据

03:41.860 --> 03:44.540
比方说这个数据它可能属于任何一个组件

03:44.540 --> 03:48.380
比方说我们的数据属于这个组件

03:48.380 --> 03:49.020
我们说

03:49.020 --> 03:51.660
当我们说数据属于某一个组件的时候

03:51.660 --> 03:52.860
指的是什么意思呢

03:52.860 --> 03:54.180
指的就是这个数据

03:54.180 --> 03:55.940
它就是个组件的状态

03:55.940 --> 03:56.820
State

03:56.820 --> 03:58.540
表示这个组件的状态

03:58.580 --> 04:00.220
因为这个数据是属于它的

04:00.220 --> 04:01.620
比方说有这么一个数据

04:01.620 --> 04:03.060
叫做挪顶油热

04:03.060 --> 04:04.940
当前登录的用户

04:04.940 --> 04:07.540
咱们给它这个颜色稍微设置一下

04:07.540 --> 04:08.740
设置一下这个颜色

04:08.740 --> 04:10.020
把这个颜色

04:10.020 --> 04:11.500
表示了这个数据

04:11.500 --> 04:14.820
它是属于这个图件的

04:14.820 --> 04:18.580
然后接下来我们会遇到一个现象就是

04:18.580 --> 04:19.940
它有可能

04:19.940 --> 04:21.500
下面这些直组件

04:21.500 --> 04:23.620
它也有可能会用到这些数据

04:23.620 --> 04:25.700
它也有可能会用这个数据

04:25.700 --> 04:26.900
那么这样子一来

04:26.900 --> 04:27.740
比方说

04:27.780 --> 04:28.620
咱们这个敲的

04:28.620 --> 04:29.780
E这个组件

04:29.780 --> 04:31.420
它就会用到这个数据

04:31.420 --> 04:32.540
挪顶油热

04:32.540 --> 04:33.940
咱们用换一个颜色

04:33.940 --> 04:34.860
换一个绿色

04:34.860 --> 04:36.780
表示它要用到这个数据

04:38.980 --> 04:40.020
换一个绿色

04:40.900 --> 04:41.900
加出一下

04:43.420 --> 04:44.620
它要用到这个数据

04:44.620 --> 04:45.820
那么比方说

04:46.460 --> 04:48.540
我们这里要用到这个数据

04:50.100 --> 04:52.300
那么这个数据是不是它的

04:52.980 --> 04:53.700
不是它的数据

04:53.700 --> 04:54.260
对吧

04:54.260 --> 04:55.820
所以说这个数据应该来自于哪

04:55.820 --> 04:56.940
我们说组件里边的数据

04:56.980 --> 04:58.660
它只能来自于两个地方

04:58.660 --> 04:59.620
哪两个地方

04:59.620 --> 05:01.260
一个是自己的状态

05:01.260 --> 05:01.980
自己的数据

05:01.980 --> 05:02.940
自己可以改变

05:02.940 --> 05:04.180
自己可以维护

05:04.180 --> 05:05.500
另一个数据来源于哪

05:05.500 --> 05:07.620
来源于属性

05:07.620 --> 05:09.380
那么这个数据它不是属于它的

05:09.380 --> 05:11.260
它肯定不能作为这个组件的状态

05:11.260 --> 05:14.180
那么它只能作为这个组件的属性

05:14.180 --> 05:15.620
那么这个属性怎么来传递的

05:15.620 --> 05:16.940
是不是它传递过来

05:16.940 --> 05:19.540
因为它在使用这个child1

05:19.540 --> 05:20.100
对吧

05:20.100 --> 05:22.580
所以说这个属性必须要通过它传过来

05:22.580 --> 05:24.220
但它的数据哪来了

05:24.220 --> 05:25.860
它又没有这个数据

05:25.900 --> 05:28.060
那么它也只能把这个数据

05:28.060 --> 05:30.140
作为属性通过它来传过来

05:31.420 --> 05:32.100
看着

05:32.100 --> 05:33.380
那么它就没办法了

05:33.380 --> 05:34.700
它就必须要有个属性

05:34.700 --> 05:35.700
裸紧优点

05:36.660 --> 05:38.300
我们用另外一个颜色

05:38.740 --> 05:42.460
用一个灰色

05:43.100 --> 05:44.860
那么这里是不是也得有个数据

05:44.860 --> 05:45.060
对吧

05:45.060 --> 05:46.500
它要一层一层传过去

05:46.500 --> 05:47.380
那么大家就形成

05:47.380 --> 05:49.140
大家看就形成了这么一个现象了

05:49.940 --> 05:51.220
数据本来在这

05:51.940 --> 05:54.980
然后它的后代元素

05:55.060 --> 05:56.460
它要用到这个数据

05:56.460 --> 05:57.700
它要用到这个数据

05:57.700 --> 05:59.540
所以说我们这里用个绿色的

05:59.540 --> 06:01.100
表示它要用到这个数据

06:01.100 --> 06:03.340
于是它只能通过属性传递

06:03.340 --> 06:04.900
所以说最后我们毕无得意

06:04.900 --> 06:07.220
最终会形成这么一种结构

06:07.220 --> 06:10.660
它把这个数据通过属性传给它

06:10.660 --> 06:13.100
然后它这个属性对它来说没有用

06:13.100 --> 06:13.820
它又不用

06:13.820 --> 06:14.940
不需要用到这个属性

06:14.940 --> 06:16.060
对它来说没有用

06:16.060 --> 06:17.380
但是它没办法

06:17.380 --> 06:18.020
为什么呢

06:18.020 --> 06:19.620
因为它要用到这个属性

06:19.620 --> 06:21.780
所以说它又把这个属性传给它

06:21.780 --> 06:23.740
但是实际上对它而言

06:23.780 --> 06:25.460
你给我这个属性我也没用

06:25.460 --> 06:27.460
我为什么要用这个属性

06:27.460 --> 06:29.460
是因为我的职员说要这个属性

06:29.460 --> 06:31.740
所以说它又传递给了它

06:31.740 --> 06:33.140
那么大家想象一下

06:33.140 --> 06:34.940
如果这个组建数的层次

06:34.940 --> 06:36.740
会非常非常深的话

06:36.740 --> 06:39.820
比方说10层20层

06:39.820 --> 06:42.740
可能只有最后一层要用到这个数据

06:42.740 --> 06:43.900
那么这样子以来

06:43.900 --> 06:47.380
这个属性的传递是不是会变得非常非常繁硕

06:47.380 --> 06:50.620
你看这些组建它根本就用不到这个数据

06:50.620 --> 06:52.220
用不到这个数据

06:52.340 --> 06:55.300
那么我这样子还是要写这个属性

06:55.300 --> 06:55.860
你为什么呢

06:55.860 --> 06:57.060
没办法

06:57.060 --> 06:58.500
因为直驻件需要

06:58.500 --> 07:00.300
但是直驻件说我也很无奈

07:00.300 --> 07:01.380
我也很绝望

07:01.380 --> 07:02.820
我本来不需要这个数据的

07:02.820 --> 07:04.060
但是我的直驻件需要

07:04.060 --> 07:06.220
所以说我也得把这个数据给我

07:06.220 --> 07:09.060
那么就形成了这么一种关系了

07:09.060 --> 07:11.220
这个数据传递会非常繁硕

07:11.220 --> 07:12.180
不仅如此

07:12.180 --> 07:14.860
将来我们改动了这个数据之后

07:14.860 --> 07:16.580
这个数据如果发生了改动

07:16.580 --> 07:18.380
那你是不是挨债都要改

07:18.380 --> 07:20.380
比方说以后还多了一些属性的传递

07:20.420 --> 07:22.020
那是不是挨债都要改

07:22.020 --> 07:22.820
对不对

07:22.820 --> 07:25.940
就会造成一些非常麻烦的问题

07:25.940 --> 07:28.700
那么这些问题该怎么来解决呢

07:28.700 --> 07:32.220
其实就使用上下文来解决

07:32.220 --> 07:33.420
怎么来送上下文解决呢

07:33.420 --> 07:35.780
我先跟大家说一下原理

07:35.780 --> 07:38.900
比方说首先这个数据

07:38.900 --> 07:40.740
它是属于组建App

07:40.740 --> 07:42.380
它属于这个组建的

07:42.380 --> 07:44.500
那么我当我写这个组建的时候

07:44.500 --> 07:46.980
我可能会预想到

07:46.980 --> 07:49.780
我这个组建里边的后代元素

07:49.820 --> 07:51.820
我也不知道哪个后代元素

07:51.820 --> 07:53.500
可能要用到这个数据

07:53.500 --> 07:55.740
但是我可以百分之百确定

07:55.740 --> 07:58.100
它肯定会用到这个数据的

07:58.100 --> 07:59.940
哪个组建用我现在还不清楚

07:59.940 --> 08:02.020
但是将来一定有一个后代元素

08:02.020 --> 08:03.020
后代组建

08:03.020 --> 08:04.380
它会用到这个数据

08:04.380 --> 08:05.820
如果是这种情况的话

08:05.820 --> 08:07.540
它就做这么一件事

08:07.540 --> 08:09.580
它创建一个上下文

08:09.580 --> 08:12.220
这个组建App

08:12.220 --> 08:14.340
创建这么一个上下文

08:14.340 --> 08:19.950
我这里换一个颜色

08:19.990 --> 08:22.310
这个浅皇上的背景

08:22.310 --> 08:24.990
就表示App创建的上下文

08:24.990 --> 08:27.910
App创建的上下文

08:27.910 --> 08:28.630
其实你不用

08:28.630 --> 08:29.350
我不用写文字

08:29.350 --> 08:30.590
你也看得很清楚了

08:30.590 --> 08:32.790
因为它把整个区域全部包起来了

08:32.790 --> 08:33.470
对吧

08:33.470 --> 08:36.030
所以说这个上下文的环境

08:36.030 --> 08:39.150
就是跟组建创建的

08:39.150 --> 08:40.590
那么它创建一个上下文

08:40.590 --> 08:42.030
它可以做这么一件事

08:42.030 --> 08:42.790
什么事呢

08:42.790 --> 08:45.230
它可以把我们的数据

08:45.230 --> 08:46.470
它可以把它的数据

08:46.470 --> 08:47.790
放到上下文里边

08:50.950 --> 08:53.030
它可以把我们的数据

08:53.030 --> 08:54.590
放到上下文里边

08:54.590 --> 08:55.630
上下文里边

08:55.630 --> 08:56.630
就跟罗杰尤尔这

08:56.630 --> 08:58.030
它放到这

08:59.030 --> 09:00.630
它把数据放到这

09:00.630 --> 09:02.190
那么这样子一来

09:02.190 --> 09:03.070
这个数据

09:03.070 --> 09:05.870
就会被所有的后代组建共享

09:05.870 --> 09:07.550
后代组建里边

09:07.550 --> 09:09.630
它不需要通过属性来获取

09:09.630 --> 09:10.670
属性不需要

09:10.670 --> 09:12.830
你要用到这个数据的时候

09:12.830 --> 09:13.590
你看这个组建

09:13.590 --> 09:14.790
它不是要用到这个数据吗

09:14.790 --> 09:16.630
直接从上下文里边去取

09:16.630 --> 09:17.950
上下文里边有这个数据

09:17.950 --> 09:18.790
直接拿过来

09:19.270 --> 09:20.510
就不再使用

09:20.510 --> 09:22.110
那么这个罗杰尤尔的就来自

09:22.110 --> 09:23.430
就不是来自于属性了

09:24.430 --> 09:26.070
来自于上下文

09:28.070 --> 09:30.390
从上下文里边直接把数据拿过来

09:30.390 --> 09:31.270
明白的意思吧

09:31.670 --> 09:33.670
就形成了这么一种结构了

09:33.670 --> 09:35.190
因此我们今天的课程

09:35.190 --> 09:36.950
就这些课学校之后

09:36.950 --> 09:38.510
大家可以发现一个现象

09:38.510 --> 09:39.910
就是我们的组建里边

09:39.910 --> 09:41.790
它的数据有三个来源

09:41.790 --> 09:43.070
一个是状态

09:43.070 --> 09:43.950
自己的数据

09:43.950 --> 09:45.110
这个没什么好说的

09:45.110 --> 09:46.950
一个是从其他地方来的话

09:46.950 --> 09:47.830
一个是属性

09:47.870 --> 09:48.790
一个是上下文

09:49.350 --> 09:50.230
属性和上下文

09:50.230 --> 09:52.030
都是来自于其他地方的数据

09:53.030 --> 09:54.430
也因为如此

09:54.430 --> 09:55.390
所以说官方

09:56.630 --> 09:58.750
让你在用上下文的时候

09:59.030 --> 10:00.750
尽量的小心

10:01.110 --> 10:02.230
尽量的谨慎

10:02.230 --> 10:03.710
谨慎使用上下文

10:03.710 --> 10:04.670
为什么呢

10:04.670 --> 10:07.310
就是因为本来这个组建

10:07.310 --> 10:08.950
它是很纯粹的

10:08.950 --> 10:10.750
就是说我需要的数据我没有

10:10.750 --> 10:12.110
那么你就通过属性给我

10:12.750 --> 10:13.990
本来是很纯粹的

10:13.990 --> 10:15.270
对于这个组建而言

10:15.270 --> 10:16.310
如果它只来自于

10:16.350 --> 10:18.270
它的数据除了状态之外

10:18.270 --> 10:19.510
就别人的给我的数据

10:19.510 --> 10:20.790
只来自于属性的话

10:21.790 --> 10:23.990
这个组建是非常纯粹的

10:24.310 --> 10:26.750
但是如果一旦它依赖了上下文

10:26.750 --> 10:28.470
它的数据有些来自于上下文

10:28.750 --> 10:30.230
那么就要求这个组建

10:30.230 --> 10:31.470
你在用这个组建的时候

10:31.470 --> 10:33.190
就必须要有一个上下文

10:34.030 --> 10:34.950
如果你的副组建

10:34.950 --> 10:36.190
比方他在用他的时候

10:36.190 --> 10:37.310
他就必须要想到

10:37.310 --> 10:39.110
我要在用他的时候

10:39.110 --> 10:40.470
我也得有个上下文

10:40.790 --> 10:43.270
如果我的副组建或者是我的主先元素

10:43.270 --> 10:44.390
他没有创建上下文

10:44.430 --> 10:45.910
那么我得自己创建一个

10:46.550 --> 10:49.150
那么他就有对使用组建而言的话

10:49.150 --> 10:50.990
那么相对来说的话

10:50.990 --> 10:52.270
就变得复杂了

10:52.270 --> 10:54.590
所以说这个世界上对于很多框架

10:54.590 --> 10:55.270
模式

10:55.270 --> 10:58.270
它没有一种完美的解决办法

10:59.470 --> 11:01.470
只能说有的时候只能说折衷

11:01.990 --> 11:05.030
咱们给你提供这么一种方式

11:05.030 --> 11:05.870
一用的时候

11:05.870 --> 11:07.670
你自己根据情况

11:07.670 --> 11:08.550
自己选择

11:08.550 --> 11:10.230
虽然说有了上下文之后

11:10.230 --> 11:12.470
我们不用去传递这些属性了

11:12.790 --> 11:13.430
属性

11:13.430 --> 11:15.070
就是这些里边的组建

11:15.110 --> 11:16.670
不管他欠套多么承证层次

11:16.670 --> 11:17.830
只要在上下文里边

11:17.830 --> 11:20.270
他就可以从上下文里边获取数据

11:20.670 --> 11:22.550
但是你只要使用了上下文

11:22.550 --> 11:25.670
就会导致组建依赖上下文

11:25.910 --> 11:27.150
那么这样子以来

11:27.630 --> 11:28.910
那么使用这个组

11:29.030 --> 11:29.990
导致这个组建

11:29.990 --> 11:32.150
它的附用性就会变低

11:32.150 --> 11:33.190
咱们把这个记一下

11:35.910 --> 11:40.310
当某个元素

11:40.470 --> 11:41.710
应该叫做某个组建

11:42.310 --> 11:44.750
创建了上下文后

11:46.070 --> 11:48.750
上下文终的数据

11:48.750 --> 11:49.710
上下文的主要目的

11:49.710 --> 11:50.990
就是为了保存数据的

11:51.510 --> 11:52.950
上下文终的数据

11:53.150 --> 11:56.550
会被所有后代组建

11:57.590 --> 11:59.550
后代组建共享

12:00.110 --> 12:01.070
这是第一个特点

12:02.270 --> 12:05.470
react终的上下文特点

12:06.070 --> 12:06.630
第一个

12:07.230 --> 12:09.070
当某一个组建创建了上下文之后

12:09.070 --> 12:10.470
现在我们还不知道怎么写代

12:10.990 --> 12:12.550
咱们先把这个理论搞清楚

12:12.790 --> 12:13.950
当它创建了上下文之后

12:14.190 --> 12:15.590
它的所有后代组建

12:15.590 --> 12:16.950
都会共享这个数据

12:18.790 --> 12:19.470
另外

12:19.990 --> 12:22.230
如果某个组建

12:23.830 --> 12:25.510
依赖了上下文

12:25.750 --> 12:27.470
本来一个组建它很纯粹的

12:27.470 --> 12:28.550
它只依赖属性

12:28.550 --> 12:29.390
你给我传什么

12:29.390 --> 12:30.310
我就怎么去显示

12:30.430 --> 12:31.750
本来非常纯粹的

12:32.270 --> 12:33.590
但是如果一个组建

12:33.590 --> 12:34.790
依赖了上下文的话

12:34.950 --> 12:38.430
会导致该组建不再纯粹

12:40.710 --> 12:41.550
不再纯粹

12:41.910 --> 12:42.910
就是它的什么叫纯粹

12:42.950 --> 12:44.270
就是说数据

12:44.270 --> 12:45.230
我们这里说的纯粹

12:45.230 --> 12:47.590
指的是数据紧来源于

12:48.190 --> 12:49.110
外部数据

12:50.030 --> 12:53.870
紧来源于属性

12:55.310 --> 12:55.950
紧来源于这个

12:55.950 --> 12:56.910
就是很纯粹的组建

12:57.430 --> 12:58.470
我们不依赖任何东西

12:58.470 --> 12:59.430
你直接用就行了

12:59.430 --> 13:00.790
给我传的属性就完事了

13:01.030 --> 13:02.270
但是一旦依赖到上下文的话

13:02.270 --> 13:03.830
这个组建就不再纯粹了

13:03.830 --> 13:04.710
就不再纯粹了

13:05.710 --> 13:07.950
这是上下文的这么一个特点

13:08.950 --> 13:10.470
随着大家用的时候

13:10.870 --> 13:13.630
不是说这些可以学习过后

13:14.510 --> 13:15.470
以后拿到任何数据

13:15.470 --> 13:16.790
你先往上下文里边扔

13:16.790 --> 13:17.350
不好

13:18.190 --> 13:19.110
谨慎使用

13:19.230 --> 13:19.990
谨慎使用

13:21.870 --> 13:22.790
我们后边会说

13:22.790 --> 13:23.910
在什么场景下边

13:24.310 --> 13:25.590
我们会用到这个上下文

13:25.750 --> 13:28.350
我们先对这个上下文有这么一个大致的了解

13:28.990 --> 13:29.990
了解了之后

13:30.350 --> 13:31.030
我们再来看

13:31.870 --> 13:32.670
两个问题

13:32.670 --> 13:33.670
一个问题是

13:33.670 --> 13:36.310
我如何在一个组建里边创建上下文

13:37.510 --> 13:37.950
等一下

13:38.870 --> 13:40.030
观察我说了这个场景

13:40.110 --> 13:41.510
还有其实还有一个场景

13:41.750 --> 13:42.430
还有一个场景

13:42.430 --> 13:42.950
就是说

13:42.950 --> 13:45.310
这个上下文不一定是App创建的

13:46.190 --> 13:47.510
它不一定是App创建的

13:47.870 --> 13:49.830
它可能是这个玩意儿创建的一个上下文

13:52.700 --> 13:54.340
它可能这个玩意儿创建的一个上下文

13:54.340 --> 13:55.500
它比方说它有个数据

13:55.780 --> 13:56.860
数据的名字叫data

13:57.500 --> 13:58.220
我就随便写一个

14:03.900 --> 14:05.060
它有个数据

14:05.220 --> 14:06.500
它创建的一个上下文

14:06.500 --> 14:07.860
那么它的双下文就变这

14:08.140 --> 14:10.100
它的范围就变小了

14:10.700 --> 14:11.900
这是它创建的上下文

14:12.180 --> 14:14.380
只有它的后代元素可以使用

14:14.740 --> 14:15.340
可以使用

14:15.420 --> 14:16.380
那么它也是一样

14:16.700 --> 14:18.340
把这个data放到上下文里边

14:19.340 --> 14:20.700
不是说只有根柱键

14:20.940 --> 14:22.580
只有根柱键才能创建上下文

14:22.580 --> 14:23.060
不是的

14:23.500 --> 14:24.580
它把这个数据放到哪里

14:24.580 --> 14:26.020
放到这里边

14:26.980 --> 14:29.620
放到subload创建的上下文里边

14:31.600 --> 14:32.360
subload

14:32.720 --> 14:35.000
1创建的上下文

14:35.920 --> 14:36.720
它把放到这里边

14:38.880 --> 14:40.520
它把这个data放到这里边

14:41.040 --> 14:41.760
当然是一样的

14:41.760 --> 14:42.360
是一样的

14:43.360 --> 14:46.800
其实我们以后接触到一些

14:46.800 --> 14:48.720
我们不是学rex全家统吗

14:48.960 --> 14:49.120
对吧

14:49.120 --> 14:50.280
后面还有一个rex

14:50.520 --> 14:51.960
还有什么rexrotor

14:52.160 --> 14:53.640
他们都用到了上下文

14:53.880 --> 14:55.720
所以上下文平时我们用的话

14:55.720 --> 14:58.400
一般是用于一些第三方组件

14:59.440 --> 15:00.320
一般情况下

15:00.520 --> 15:01.400
我这里就顺便说了

15:01.960 --> 15:02.720
情况下

15:03.400 --> 15:05.640
用于第三方组件

15:06.360 --> 15:08.400
就是以自己写的一些通用组件

15:09.080 --> 15:10.200
一些通用组件

15:11.200 --> 15:14.200
因为我们可能有很多的通用组件

15:14.200 --> 15:16.040
他们共同来完成一个功能

15:16.360 --> 15:18.120
他们之间是有一种结构的

15:18.400 --> 15:21.200
所以说我们可能会用上下文来组织

15:21.200 --> 15:22.520
他们这样子的方便

15:22.520 --> 15:24.240
他们之间发生数据关系

15:24.760 --> 15:26.160
数据之间可以相互沟通

15:26.600 --> 15:27.640
我们后边的下一节课

15:27.720 --> 15:29.320
我们这节课只讲知识

15:29.520 --> 15:31.880
只想如何去使用它

15:31.880 --> 15:33.920
它的语法是什么样子

15:34.160 --> 15:34.840
只讲这些

15:35.040 --> 15:36.520
下一节课咱们来做一个例子

15:36.520 --> 15:38.640
看一下上下文在我们的实际开发中

15:39.120 --> 15:40.720
会议者有什么样的用处

15:41.520 --> 15:44.480
我们这里先做这么一个大致的了解

15:45.080 --> 15:46.600
那么接下来我们来研究

15:46.600 --> 15:48.560
上下文来怎么来玩

15:50.320 --> 15:51.600
关键点在有两个

15:51.720 --> 15:54.080
一个就是上下文如何来创建

15:54.200 --> 15:54.960
就这个元素

15:55.120 --> 15:56.880
这个组件他不知道创建在上下文吗

15:57.200 --> 15:59.200
他怎么来创建一个上下文

15:59.440 --> 16:00.440
这是第一个问题

16:00.680 --> 16:01.400
第二个问题

16:01.600 --> 16:02.920
他创建好了上下文之后

16:03.040 --> 16:03.800
我这里要用

16:04.240 --> 16:04.720
要用

16:04.840 --> 16:06.720
怎么从上下文里面去拿数据

16:07.200 --> 16:08.760
这就是我们这就要研究的两个问题

16:08.960 --> 16:10.160
这两个问题研究清楚

16:10.280 --> 16:11.400
那么上下文的知识就没了

16:13.400 --> 16:16.760
上下文这一块我们来写出它的语法的话

16:17.200 --> 16:19.200
这里我们要分成两个部分来说

16:19.320 --> 16:21.760
因为上下文在16

16:22.000 --> 16:24.080
reacts16这个版本之前

16:24.240 --> 16:25.440
它是另外一种写法

16:26.400 --> 16:29.280
16版本之后又是另一种写法了

16:29.400 --> 16:30.080
又改了

16:30.680 --> 16:33.280
所以说我们这里要把两种写法都讲到

16:33.280 --> 16:34.960
因为保不起你到公司里面

16:35.240 --> 16:37.120
可能你就会遇到

16:37.320 --> 16:39.440
就是说公司里面可能是用的一些

16:39.440 --> 16:40.160
旧的API

16:40.160 --> 16:40.960
旧版本的API

16:40.960 --> 16:42.000
那么旧版本的API呢

16:42.000 --> 16:43.320
你要知道该怎么去写

16:43.520 --> 16:45.520
当然我们终点肯定是新的API

16:45.800 --> 16:47.160
上下文新的API该怎么去

16:47.160 --> 16:48.080
那是我们的终点

16:48.160 --> 16:50.120
但旧的API也要做了解

16:51.000 --> 16:54.560
所以我们这里先说旧的API

16:55.600 --> 16:56.560
旧的API

16:58.600 --> 17:00.960
当然说旧的API的时候还是一样的

17:01.240 --> 17:03.520
咱们还是要先说

17:03.600 --> 17:05.160
它如何来创建上下文

17:06.520 --> 17:07.400
一个上下文

17:07.560 --> 17:08.520
如何来创建

17:09.120 --> 17:11.000
旧的API里边是这样的

17:11.200 --> 17:12.600
是这样来创建上下文的

17:12.800 --> 17:14.680
就是说如果

17:15.960 --> 17:16.840
应该这样说

17:17.160 --> 17:23.640
只有那一组件才可以创建上下文

17:23.960 --> 17:25.320
其实这个东西

17:25.920 --> 17:26.880
它能不能把它做成

17:26.880 --> 17:28.280
还是组件来创建上下文的

17:28.280 --> 17:29.560
实际上它是可以做的

17:29.680 --> 17:31.400
它为什么没有这样去做呢

17:31.520 --> 17:33.280
是因为它认为

17:33.720 --> 17:35.760
那一组件里边才有状态

17:36.120 --> 17:37.400
那一组件才有状态

17:37.560 --> 17:39.320
函数组件它认为是没有状态的

17:39.520 --> 17:40.400
这是旧的API

17:40.400 --> 17:41.640
新的API又不太一样了

17:42.160 --> 17:44.280
旧的API里边它认为函数组件没有状态

17:44.360 --> 17:45.680
而我们上下文的数据

17:45.840 --> 17:47.240
一般来说它的数据

17:47.400 --> 17:49.720
它是来自于这个组件本身的状态的

17:49.800 --> 17:52.080
当然它的数据也可以来自于这个组件的属性

17:52.280 --> 17:53.480
也可以没问题

17:53.760 --> 17:56.720
但是一般来说它是来自于这个组件的状态的

17:56.720 --> 17:58.760
它多多少少会有这个组件的状态

17:58.880 --> 18:00.360
因此它把它放到了这个

18:01.520 --> 18:03.200
就是那一组件里边

18:03.320 --> 18:05.320
所以说只有那一组件才可以创造一场的

18:05.760 --> 18:07.240
那么这里怎么来创建了

18:07.400 --> 18:07.840
第一个

18:07.960 --> 18:08.920
然后做两件事

18:09.040 --> 18:09.760
第一件事

18:10.360 --> 18:12.000
就给那一组件

18:12.880 --> 18:13.640
书写

18:14.400 --> 18:15.680
静态属性

18:15.680 --> 18:16.800
一个静态属性

18:17.160 --> 18:18.080
这个静态属性

18:18.080 --> 18:18.840
就类似于什么

18:18.840 --> 18:19.520
defaults

18:19.520 --> 18:20.000
probs

18:20.000 --> 18:20.360
对吧

18:20.360 --> 18:21.280
这就是个静态属性

18:21.440 --> 18:21.840
对不对

18:22.000 --> 18:22.600
还有什么

18:22.920 --> 18:23.440
probs

18:23.440 --> 18:24.160
probs

18:24.600 --> 18:25.080
types

18:25.080 --> 18:25.320
对吧

18:25.320 --> 18:26.440
这些都是静态属性

18:26.960 --> 18:29.200
那么这里上下文这里也是一样

18:29.360 --> 18:30.280
它要为那一组件

18:30.280 --> 18:31.560
书写个静态属性

18:31.560 --> 18:36.560
叫做child context types

18:37.280 --> 18:37.720
什么意思

18:37.720 --> 18:38.760
child

18:39.040 --> 18:41.160
只context上下文

18:41.160 --> 18:42.240
taps内行

18:42.680 --> 18:44.040
就是我创建的

18:44.040 --> 18:45.400
我给我后代元素

18:45.400 --> 18:46.320
我给我的纸元素

18:46.320 --> 18:47.240
我后代元素

18:47.360 --> 18:48.880
创建了这个上下文

18:48.880 --> 18:51.200
上下文里边的数据内行

18:51.200 --> 18:51.800
是什么

18:52.800 --> 18:54.600
使用静属性

18:54.760 --> 18:59.760
对上下文中的数据内行进行约束

18:59.880 --> 19:01.520
这不是说可选的

19:01.560 --> 19:02.760
这是必须要做的

19:03.200 --> 19:05.360
你必须要写这么一个属性

19:05.520 --> 19:09.000
对上下文里边的数据内行进行约束

19:10.360 --> 19:10.640
好

19:10.640 --> 19:11.880
然后我们现在来写一个

19:14.160 --> 19:14.560
比方说

19:14.560 --> 19:15.480
有一些朋友可能注意到

19:15.480 --> 19:17.160
我把这里生命周期也放到这了

19:17.280 --> 19:18.000
这个PPT

19:18.000 --> 19:18.360
为什么

19:18.360 --> 19:19.360
因为我这些可能

19:19.520 --> 19:20.320
十字八九

19:20.680 --> 19:21.520
会用到这个生命

19:21.520 --> 19:23.280
会给大家看到这个生命周期

19:24.000 --> 19:25.840
我们这里写这么一个主线

19:27.640 --> 19:29.080
就写到这吧

19:29.240 --> 19:29.960
算了

19:29.960 --> 19:30.760
还是写到这吧

19:31.920 --> 19:33.600
old context

19:33.920 --> 19:34.600
叫js

19:35.000 --> 19:35.200
好

19:35.200 --> 19:36.640
这里来我们写个类组件

19:36.760 --> 19:38.760
这个主线的名字就叫做old context

19:39.720 --> 19:40.960
旧的上下文API

19:41.040 --> 19:41.960
那么比方说

19:41.960 --> 19:45.360
我这个组件里边要创建这么一个上下文

19:45.400 --> 19:47.040
那么我再图里面给大家画一下

19:47.320 --> 19:49.600
就说相当于是我这里有个组件

19:49.680 --> 19:51.360
它名字叫做old context

19:51.640 --> 19:53.880
这个组件里边要创建一个上下文

19:55.120 --> 19:56.440
old context

19:57.240 --> 19:58.160
它要创建个上下文

19:58.160 --> 19:59.000
怎么来创建的

19:59.040 --> 20:00.000
首先看这里

20:00.320 --> 20:01.240
怎么来创建呢

20:01.320 --> 20:02.920
我们首先要写个信态属性

20:03.200 --> 20:05.920
它的名字叫做child context

20:06.240 --> 20:07.680
为什么没有智能提示

20:07.960 --> 20:09.000
为什么没有智能提示

20:09.000 --> 20:11.160
是因为这个API已经过时了

20:11.160 --> 20:12.120
已经过时了

20:12.120 --> 20:14.160
不再推荐你使用了

20:15.360 --> 20:17.520
不过有些旧版本里边还可能会用

20:17.520 --> 20:18.880
所以说咱们还是要讲一讲

20:19.280 --> 20:19.480
好

20:19.480 --> 20:21.280
那么这里边就描述

20:21.280 --> 20:22.760
就跟你这个属性

20:22.960 --> 20:24.480
对一个类组件里边

20:24.640 --> 20:26.040
不是以前我们写过这个吗

20:26.200 --> 20:27.000
prob types

20:27.000 --> 20:27.560
对吧

20:28.200 --> 20:29.840
跟这种写法是一样的

20:30.080 --> 20:30.760
一样的

20:30.920 --> 20:32.480
只不过这里描述的是什么

20:32.480 --> 20:34.320
描述的是属性的类型

20:34.320 --> 20:35.880
就是你要使用我的这个组件

20:35.880 --> 20:37.000
你要给我哪些属性

20:37.000 --> 20:37.920
每个属性是哪些

20:37.920 --> 20:38.600
是什么类型

20:38.600 --> 20:39.920
哪些属性是必选的

20:40.240 --> 20:41.600
你要通过这个东西给我

20:41.920 --> 20:43.520
那么上下文里边

20:44.400 --> 20:45.960
上下文里边

20:45.960 --> 20:47.200
写法是一样的

20:47.200 --> 20:48.440
只不过它约述的数据

20:48.840 --> 20:50.400
是上下文里边的数据

20:51.160 --> 20:52.200
这个我们只做测试

20:52.200 --> 20:53.240
没有任何实际意义

20:53.240 --> 20:54.720
所以说我们这写两个属性

20:56.240 --> 20:57.160
什么类型

20:57.400 --> 20:59.000
是不是我们还是要用以前学过的

20:59.520 --> 21:00.600
prob types

21:01.000 --> 21:01.400
对吧

21:02.200 --> 21:03.800
所以说咱们这个知识

21:05.200 --> 21:07.000
也不是说完全没有关联

21:07.000 --> 21:07.920
进阶部份的知识

21:07.920 --> 21:08.960
也不是说完全没有关联

21:08.960 --> 21:10.160
多多少少还是有些关联

21:10.160 --> 21:11.440
你得先学习这个东西

21:12.120 --> 21:13.000
这里边我们

21:13.520 --> 21:13.840
第二

21:13.840 --> 21:14.280
什么

21:14.720 --> 21:15.880
number比方说

21:15.880 --> 21:16.520
number

21:17.240 --> 21:17.680
b

21:18.200 --> 21:19.080
prob types

21:20.680 --> 21:21.080
stune

21:21.080 --> 21:22.480
当然也可以稍微必选的

21:22.600 --> 21:23.200
required

21:24.880 --> 21:26.320
那么这里就约述了什么

21:26.320 --> 21:27.200
就约述了

21:28.840 --> 21:29.720
约述了

21:31.900 --> 21:33.460
上下文中

21:34.100 --> 21:35.700
数据的类型

21:35.860 --> 21:37.060
这是第一件事你要做

21:37.820 --> 21:39.580
光做这一件事还不够

21:39.980 --> 21:40.700
你还不够

21:40.700 --> 21:42.060
它还要要求你

21:42.060 --> 21:43.500
在这个l组件里边

21:43.700 --> 21:45.380
你还要写一个实力方法

21:46.540 --> 21:49.020
添加实力方法

21:49.620 --> 21:50.140
什么方法

21:50.340 --> 21:54.140
它方法名字叫做get child context

21:54.860 --> 21:55.500
这个方法

21:56.060 --> 21:57.220
该方法

21:58.140 --> 21:59.700
返回的对象

22:00.500 --> 22:01.140
计

22:02.100 --> 22:05.820
为上下文中的数据

22:06.900 --> 22:11.460
该数据必须满足类型约述

22:12.380 --> 22:13.140
什么意思

22:13.500 --> 22:14.980
就这句话已经很好理解了

22:15.780 --> 22:16.580
就是说我这里

22:16.980 --> 22:17.580
我这里

22:17.700 --> 22:18.700
除了写这个之外

22:18.700 --> 22:19.700
我还要写个方法

22:19.700 --> 22:23.220
这个方法的名字叫做get child context

22:23.740 --> 22:28.980
这是得到上下文中的数据

22:30.100 --> 22:31.780
这个方法要返回一个东西

22:31.780 --> 22:32.380
返回什么

22:32.380 --> 22:34.980
返回你这里约述的是啥

22:34.980 --> 22:35.740
返回的就是啥

22:35.740 --> 22:37.060
你这里约述的不是一个对象

22:37.060 --> 22:38.340
有两个a属性a和b

22:38.340 --> 22:38.940
对吧

22:38.940 --> 22:40.620
a还必须是一个数字

22:40.620 --> 22:43.660
b还必须是一个字符串

22:43.660 --> 22:44.260
看没

22:44.380 --> 22:45.060
对吧

22:45.980 --> 22:46.980
那么通过这样子

22:47.220 --> 22:48.540
我们就可以得到

22:48.540 --> 22:49.700
返回这个对象了

22:49.700 --> 22:52.220
它就是我们上下文里边的数据

22:53.220 --> 22:54.140
这个数据哪来的

22:54.140 --> 22:55.260
就是调用

22:55.260 --> 22:56.220
它会自动调用

22:56.220 --> 22:57.460
这个方法它会自动调用的

22:57.460 --> 22:58.420
你不用什么调用

22:58.860 --> 23:00.300
它会在合适的时间点

23:00.300 --> 23:01.580
自动调用这个方法

23:01.580 --> 23:03.900
然后来得到上下文里边的数据

23:03.900 --> 23:04.180
好

23:04.180 --> 23:05.900
咱们在这个方法里边输出一个东西

23:05.900 --> 23:06.660
输出

23:07.500 --> 23:10.420
获取上下文中的数据

23:10.900 --> 23:12.420
看一下这个方法有没有调用

23:12.700 --> 23:14.940
咱们在app里边把这个组件拿到

23:15.340 --> 23:20.660
import old context from old context

23:21.660 --> 23:22.740
把这个组件拿到

23:22.860 --> 23:24.020
这里我们把它渲染出来

23:26.540 --> 23:26.900
保存

23:27.300 --> 23:27.820
看一下

23:31.460 --> 23:32.380
打开扭量器

23:35.460 --> 23:36.580
看一下控制台

23:37.700 --> 23:39.540
你看控制台里边这个方法是不运行

23:39.700 --> 23:40.220
对吧

23:40.420 --> 23:41.940
这个方法它就运行了

23:41.940 --> 23:43.980
它会自动的去运行这个方法

23:43.980 --> 23:46.300
来得到上下文里边的数据

23:46.500 --> 23:46.900
当然了

23:46.900 --> 23:48.460
这个上下文的数据我们还没用

23:48.460 --> 23:49.340
用到还没有用

23:49.340 --> 23:50.060
但是没关系

23:50.060 --> 23:52.260
我们已经可以获取这个数据了

23:53.220 --> 23:55.820
这就是上下文里边的数据

23:55.820 --> 23:58.260
如何来创建

23:58.260 --> 23:59.860
如何来创建一个上下文的数

24:00.700 --> 24:02.020
如何来创建一个上下文

24:02.020 --> 24:03.820
以及这个上下文里边

24:03.820 --> 24:05.860
如何来得到上下文里边的数据

24:06.260 --> 24:07.380
再说一次

24:07.380 --> 24:09.020
一个静态属性

24:09.020 --> 24:10.460
约束上下文的内行

24:10.660 --> 24:12.180
另一个就是方法

24:12.180 --> 24:13.180
实力方法

24:13.180 --> 24:15.500
得到上下文里面对象里面

24:15.500 --> 24:16.580
内行满足约束

24:16.580 --> 24:18.340
比方说你这里内行不满足

24:18.340 --> 24:19.900
你这里是本来说是数字

24:19.900 --> 24:21.060
但是你这里写了字符算

24:21.060 --> 24:21.780
你看一下

24:21.980 --> 24:22.740
这不爆错了

24:22.740 --> 24:23.500
对吧

24:23.500 --> 24:25.860
他说希望是一个数字

24:25.860 --> 24:26.860
但是你给的是什么

24:26.860 --> 24:27.980
给的是一个字不错

24:28.460 --> 24:30.260
比方说这里B

24:31.820 --> 24:32.780
B我不填

24:32.780 --> 24:33.700
本来说是B填的

24:33.700 --> 24:34.100
对吧

24:34.100 --> 24:35.260
不填是不是又爆错了

24:35.260 --> 24:36.740
他说B is required

24:36.740 --> 24:37.940
他必须是

24:39.300 --> 24:40.020
是必须的

24:40.020 --> 24:41.540
但是你给的是undefend

24:42.900 --> 24:45.020
这就是这两个方法

24:46.260 --> 24:47.060
没问题了吧

24:47.700 --> 24:47.900
好

24:47.900 --> 24:48.820
那么接下来我们来看一下

24:48.820 --> 24:49.260
这个方法

24:49.260 --> 24:50.860
它在什么时候运行

24:51.140 --> 24:52.980
这个方法它是什么时候运行的

24:53.300 --> 24:55.460
它的方法的运行时间点是这样子的

24:57.140 --> 24:58.220
该方法

24:58.580 --> 24:59.460
汇赞

25:00.100 --> 25:00.900
汇赞

25:01.500 --> 25:04.300
每次渲染

25:04.300 --> 25:05.660
而Render之后

25:06.220 --> 25:09.620
会在每一次Render之后运行

25:10.460 --> 25:11.860
它会在这个时间点运行

25:11.860 --> 25:13.540
每一次Render之后运行

25:14.420 --> 25:15.380
如果是第一次的话

25:15.380 --> 25:17.420
它可以可能是在component

25:17.420 --> 25:18.420
deadupdate

25:18.780 --> 25:19.740
deadmount

25:19.780 --> 25:20.540
就是有渲染

25:21.540 --> 25:22.700
组件完成

25:23.180 --> 25:23.900
那个叫啥

25:23.900 --> 25:24.740
mount叫啥

25:24.740 --> 25:25.700
迁入之前

25:25.900 --> 25:27.060
组件完成迁入之前

25:27.060 --> 25:28.340
它会运行一次

25:28.340 --> 25:29.420
如果是后续的话

25:29.420 --> 25:30.900
它每一次属性变化

25:30.900 --> 25:31.740
状态变化

25:31.740 --> 25:32.580
它都会运行

25:32.580 --> 25:34.100
运行之后它为了保证

25:34.100 --> 25:35.220
它主要是为了保证

25:35.740 --> 25:37.340
保证这个就是

25:38.740 --> 25:40.380
它主要是为了保证

25:42.060 --> 25:44.420
上下文里面的数据能拿到最新的

25:44.780 --> 25:46.100
能拿到最新的数据

25:46.100 --> 25:47.140
它为了这个时候运行

25:47.820 --> 25:49.140
其实里面细节还很多

25:49.140 --> 25:50.020
但是更多的细节

25:50.300 --> 25:51.380
咱们点到技职就行了

25:51.380 --> 25:52.740
因为我们是旧的API

25:53.100 --> 25:54.300
后边你们代码基本上

25:54.300 --> 25:56.100
不会再用这种API来输写了

25:56.420 --> 25:57.820
除非你们以后到了非常

25:58.780 --> 25:59.420
公司里边

25:59.420 --> 26:00.500
一些老的项目里边

26:00.500 --> 26:01.780
可能还用这种方式来写

26:01.820 --> 26:03.260
不过他们都会慢慢改造了

26:03.300 --> 26:05.660
因为react官方的明确说明这个API

26:06.500 --> 26:08.460
它会后边的新版本里面

26:08.580 --> 26:09.980
它可能就会直接移除掉了

26:10.100 --> 26:11.100
目前还支持

26:11.140 --> 26:13.340
但是后边就可能会直接不支持了

26:13.740 --> 26:16.260
因此我们现在目前就是了解一下旧的API就行了

26:17.260 --> 26:20.340
这里我们拿到了

26:20.340 --> 26:21.700
调整函数拿到了上下文

26:21.700 --> 26:21.980
对吧

26:21.980 --> 26:23.500
得到了上下文数据

26:23.540 --> 26:24.580
那么现在的问题

26:24.580 --> 26:27.620
在于我们如何来使用

26:28.060 --> 26:29.380
使用这里边的数据

26:29.380 --> 26:30.500
我这里还包错

26:32.340 --> 26:34.300
这里变成123

26:35.740 --> 26:36.860
这里写上abc

26:38.980 --> 26:41.380
关键是我们如何来使用这个数据

26:41.860 --> 26:43.340
如何来使用数据

26:43.460 --> 26:44.420
我们来看笔

26:45.420 --> 26:54.740
使用上下文中的数据

26:56.060 --> 26:57.580
首先说

26:57.860 --> 26:59.860
如果是自身要使用的话

26:59.860 --> 27:00.860
就是在这个组件里边

27:00.860 --> 27:01.660
它充电了上下文

27:01.660 --> 27:02.260
对吧

27:02.380 --> 27:03.500
如果是在它里边

27:03.500 --> 27:05.820
你就要直接使用这个数据的话

27:05.820 --> 27:07.780
这不在我们的讨论范围之列

27:07.780 --> 27:08.300
为什么

27:09.300 --> 27:11.260
为什么不在我们讨论范围之列呢

27:11.460 --> 27:13.660
是因为你这里是不是可以直接调用这个函数

27:13.660 --> 27:14.220
对吧

27:14.260 --> 27:15.540
你这里直接调用完了

27:15.540 --> 27:17.740
就不就那么给你抢这个设

27:17.740 --> 27:18.180
对吧

27:18.220 --> 27:19.220
到上下文那边数据

27:19.220 --> 27:20.180
那是不是得到一个对象

27:20.180 --> 27:20.620
对不对

27:20.620 --> 27:21.780
对象的数据你随便用

27:22.780 --> 27:24.100
这个东西没有什么好说的

27:24.460 --> 27:25.940
你直接调用这个函数据完事了

27:25.940 --> 27:27.620
或者说你看这里边的数据

27:28.460 --> 27:29.700
我这里虽然没这样的写

27:29.700 --> 27:30.820
但是通常情况下

27:30.820 --> 27:32.140
这里边数据都是来自于

27:32.140 --> 27:34.420
当前这个组件的状态

27:34.420 --> 27:36.180
或者是当前这个组件的属性

27:36.180 --> 27:37.660
然后这里可能来自于

27:37.660 --> 27:39.660
Zs.stats.a

27:39.660 --> 27:42.180
这里来自于Zs.probs.b

27:42.180 --> 27:42.540
对吧

27:42.540 --> 27:43.820
可能来自于这些数据

27:43.820 --> 27:45.060
这个上下文那边数据

27:45.060 --> 27:46.420
可能来自于这里

27:46.420 --> 27:47.100
所以说这些本来

27:47.140 --> 27:49.380
就是我们自己本来就可以获取到的

27:49.380 --> 27:51.660
因此在自己组件里边

27:51.660 --> 27:53.700
获取上下文的数据是非常简单的

27:53.700 --> 27:55.300
这不在我们的讨论范围之内

27:55.300 --> 27:56.340
现在我们主要说的是

27:56.340 --> 27:57.660
在它的直组件

27:57.660 --> 27:59.260
或者说后代组件里边

27:59.260 --> 28:00.260
我们之前不说吗

28:00.260 --> 28:01.180
它有后代组件

28:01.180 --> 28:01.740
有直组件

28:01.740 --> 28:03.420
它们也可以随时获取

28:03.420 --> 28:04.540
这个上下文的东西

28:05.100 --> 28:05.340
好

28:05.340 --> 28:06.180
那么我们主要是看一下

28:06.180 --> 28:07.740
这个东西怎么来做

28:07.740 --> 28:09.180
比方说我们这里

28:09.900 --> 28:10.900
再写一个

28:10.900 --> 28:11.740
再写一个

28:12.740 --> 28:14.020
也不用一个sport

28:14.020 --> 28:14.820
就class

28:19.530 --> 28:20.490
class

28:21.890 --> 28:22.890
写个函数组件

28:22.890 --> 28:24.170
我们这里写个函数组件

28:24.170 --> 28:24.890
好吧

28:24.890 --> 28:27.730
函数组件就是childA

28:30.530 --> 28:31.530
这个函数组件

28:31.530 --> 28:33.290
这个函数组件其实也没啥东西

28:33.290 --> 28:34.330
目前也没啥东西

28:34.330 --> 28:35.370
就返回一个

28:35.370 --> 28:36.450
返回一个这么一个东西

28:36.450 --> 28:38.330
它又有一个直组件

28:38.330 --> 28:39.170
childB

28:42.470 --> 28:43.190
不是方形

28:43.190 --> 28:43.990
直组件

28:43.990 --> 28:45.670
内组件class

28:45.670 --> 28:46.390
childB

28:46.390 --> 28:47.430
咱们有两个组件

28:48.430 --> 28:50.270
childB

28:50.350 --> 28:51.270
extint

28:51.910 --> 28:52.870
react

28:52.870 --> 28:53.870
component

28:54.870 --> 28:55.870
render

28:56.670 --> 28:57.270
返回

28:57.270 --> 28:58.270
返回

28:59.070 --> 29:00.070
返回啥呢

29:00.070 --> 29:00.870
返回一个拼员数

29:01.470 --> 29:02.070
拼员数

29:02.070 --> 29:03.270
拼员数里边写上

29:03.870 --> 29:04.870
childB

29:05.870 --> 29:06.670
childB

29:07.670 --> 29:09.270
然后

29:09.270 --> 29:10.270
还有啥呢

29:10.870 --> 29:12.070
没有使用过对吧

29:12.070 --> 29:12.870
那么这里

29:12.870 --> 29:14.270
childA里边返回啥呢

29:14.270 --> 29:15.470
返回一个div

29:15.470 --> 29:16.270
一个div

29:16.270 --> 29:17.470
div里边写上

29:17.470 --> 29:18.670
he

29:18.670 --> 29:20.070
childA

29:21.070 --> 29:23.070
然后下边有个childB

29:23.070 --> 29:24.670
就形成了这么一种关系

29:24.670 --> 29:25.870
我给大家画一下图

29:25.870 --> 29:27.270
那么现在形成这么一种关系

29:27.270 --> 29:29.270
然后在这里边使用childA

29:30.270 --> 29:31.270
childA

29:32.270 --> 29:33.270
把这个去掉了

29:34.470 --> 29:35.470
看着

29:35.470 --> 29:36.270
childA

29:36.270 --> 29:37.070
childB

29:38.270 --> 29:40.070
我们在这里画个图

29:40.270 --> 29:42.070
把这些不相干的

29:42.070 --> 29:43.070
咱们的结构

29:43.070 --> 29:44.470
组件结构是这个样子的

29:44.470 --> 29:45.470
childA

29:45.470 --> 29:46.670
这里是childB

29:46.670 --> 29:47.870
childB

29:51.310 --> 29:52.910
是这么一种结构

29:53.310 --> 29:54.310
他创建的上下文

29:54.910 --> 29:56.110
我这里就不用写了吧

29:56.310 --> 29:57.110
不用写了吧

29:57.910 --> 29:58.910
你看这个背景

29:58.910 --> 29:59.710
看这个背景

29:59.710 --> 30:01.010
背景把整个这一块框住的

30:01.010 --> 30:02.110
那肯定是他创建的

30:02.710 --> 30:03.710
只有他创建的

30:03.710 --> 30:05.310
才是这样的一个背景

30:06.710 --> 30:07.710
我们把它写的简洁点

30:08.110 --> 30:09.110
画的简洁点

30:10.310 --> 30:11.110
我们上下文在这

30:11.110 --> 30:12.310
是他创建的上下文

30:12.910 --> 30:13.910
他创建的上下文

30:14.910 --> 30:16.110
那么现在呢

30:16.110 --> 30:17.710
我们比方说形成了这么一种结构了

30:17.710 --> 30:19.110
你看一下我们的代码

30:19.110 --> 30:19.710
你看

30:19.710 --> 30:21.310
O的context里边包含了什么

30:21.310 --> 30:22.310
childA

30:22.510 --> 30:23.510
childA

30:23.510 --> 30:25.310
childA里边包含了childB

30:25.310 --> 30:25.510
对吧

30:25.510 --> 30:26.310
childB

30:26.910 --> 30:28.910
现在我们要在childB里边

30:29.110 --> 30:30.910
获取上下文的数据

30:31.910 --> 30:33.510
这里要获取数据的话

30:33.510 --> 30:34.710
他有一个要求

30:35.110 --> 30:36.110
什么要求呢

30:37.110 --> 30:38.510
他的要求是

30:39.110 --> 30:43.110
如果要使用上下文中的数据

30:43.910 --> 30:44.710
组件

30:45.110 --> 30:47.310
不管你是什么函数组件也好

30:47.310 --> 30:49.110
还是说你是内组件也好

30:49.710 --> 30:51.910
组件必须有

30:52.310 --> 30:54.910
一个静态属性

30:54.910 --> 30:55.710
什么属性

30:55.710 --> 30:58.710
叫做context

30:59.110 --> 31:00.910
taps静态属性

31:01.710 --> 31:04.110
该属性描述了

31:04.910 --> 31:06.710
需要获取的

31:07.110 --> 31:10.510
上下文中的数据内容

31:11.710 --> 31:12.510
什么意思呢

31:12.910 --> 31:13.710
我举个例子

31:13.710 --> 31:14.510
举个例子

31:14.510 --> 31:15.110
看这里

31:15.710 --> 31:16.310
我们的数据

31:16.310 --> 31:17.510
上下文的数据是谁提供的

31:17.510 --> 31:18.110
他提供的

31:18.110 --> 31:18.510
对吧

31:18.910 --> 31:19.610
他提供的数据

31:19.610 --> 31:19.810
你看

31:19.810 --> 31:20.910
这是他提供的数据

31:21.010 --> 31:22.610
然后是他的数据内容

31:23.010 --> 31:23.910
现在呢

31:24.210 --> 31:26.210
我们比方说在trade B里边

31:26.210 --> 31:27.810
也要使用这个数据

31:28.110 --> 31:29.510
使用我们上下文那边数据

31:29.610 --> 31:32.510
那么你必须要使用一个静态属性

31:32.710 --> 31:33.310
叫什么呢

31:33.310 --> 31:35.110
叫做context

31:35.910 --> 31:36.610
taps

31:37.410 --> 31:39.310
使用这个静态属性

31:39.510 --> 31:41.310
那么我要声明在这里

31:43.010 --> 31:43.810
声明

31:45.210 --> 31:48.210
声明需要使用的

31:48.410 --> 31:49.610
上下文

31:49.810 --> 31:51.010
是要使用的

31:51.210 --> 31:52.410
使用哪些

31:53.010 --> 31:55.010
上下文中的数据

31:55.310 --> 31:56.410
你必须要在这里声明

31:57.510 --> 31:57.610
好

31:57.610 --> 31:58.610
那么这里怎么声明呢

31:58.610 --> 31:59.210
比方说

31:59.210 --> 32:01.810
我这里只需要使用上下文那边的数据

32:01.810 --> 32:02.210
a

32:02.810 --> 32:04.010
只需要使用这个a

32:04.810 --> 32:05.610
那么现在呢

32:05.610 --> 32:07.310
我们就给这个a做一个约束

32:07.310 --> 32:08.910
prob types number

32:09.110 --> 32:09.510
对吧

32:09.910 --> 32:10.510
a不是number吗

32:10.510 --> 32:11.410
我们上下文的数据

32:11.410 --> 32:12.110
a是不是number

32:12.110 --> 32:12.510
对不对

32:12.610 --> 32:12.710
好

32:12.710 --> 32:15.110
我们要声明一下

32:15.410 --> 32:15.910
一个东西说

32:15.910 --> 32:17.210
那没有意义啊

32:17.310 --> 32:19.010
你前面不是写上下文的内容吗

32:19.010 --> 32:20.610
干嘛我还要去写这个重复代吗

32:20.610 --> 32:21.710
写这个重复代

32:21.710 --> 32:23.010
react设计是不是有问题啊

32:23.010 --> 32:23.810
这个react

32:24.010 --> 32:24.610
不是的

32:24.810 --> 32:26.310
react它是这么思考的

32:26.610 --> 32:27.610
它认为呢

32:28.710 --> 32:30.310
上下文的这个东西呢

32:30.310 --> 32:33.410
它容易破坏这个纯粹的组件结构

32:33.410 --> 32:35.510
本来这个组件结构是非常非常纯粹的

32:36.410 --> 32:37.710
但是多了一个上下文过后呢

32:37.710 --> 32:40.010
还有它会破坏掉这个纯粹的结构

32:40.310 --> 32:43.010
如果你不在这里单独声明一下的话

32:43.210 --> 32:44.310
你这个组件

32:44.710 --> 32:46.710
就非常容易导致错误

32:47.010 --> 32:47.810
它认为你这个组件

32:47.810 --> 32:49.810
可能写着越写越混乱越写混乱

32:49.910 --> 32:51.110
你这个数据呢

32:51.410 --> 32:52.410
来自于上下文的数据

32:52.410 --> 32:54.710
跟我们来自于属性的数据

32:54.710 --> 32:55.910
可能混杂在一起

32:56.810 --> 32:58.010
就容易产生bug

32:58.210 --> 32:58.710
因此呢

32:58.710 --> 32:59.610
它建议你

32:59.910 --> 33:02.410
如果你有真正真的要依赖上下文的话

33:02.810 --> 33:03.710
你想清楚

33:03.910 --> 33:06.110
你自己去手动写这么一句话

33:06.410 --> 33:07.610
写这句话的时候

33:07.710 --> 33:09.010
实际上它在帮助你

33:09.310 --> 33:11.410
你清楚你清楚自己的思路

33:11.610 --> 33:12.410
你注意哦

33:12.410 --> 33:13.510
你在写这句话哦

33:13.610 --> 33:15.810
你这里的相当于是你要依赖上下文

33:15.810 --> 33:17.310
你里边的a了啊

33:17.910 --> 33:19.410
比方上下文里边有20个数据

33:19.410 --> 33:20.610
你是不是要全部一单了

33:20.710 --> 33:22.110
一单的越少越好

33:22.210 --> 33:23.510
咱们都听说过啊

33:23.510 --> 33:24.310
软件里边

33:24.510 --> 33:26.410
设计里边什么高内距

33:26.410 --> 33:27.710
低偶和对吧

33:28.210 --> 33:30.410
跟外部的关联越少越好

33:30.510 --> 33:31.410
上下文有20个数据

33:31.410 --> 33:32.410
你不是要全部用到哦

33:32.410 --> 33:33.510
你可能只用到这个a

33:33.510 --> 33:35.010
你自己单独去声明

33:35.310 --> 33:36.210
单独去声明

33:36.310 --> 33:37.610
你声明的过程

33:37.610 --> 33:38.710
其实在帮助你

33:38.710 --> 33:40.410
一是帮助你自己的心思路

33:40.510 --> 33:41.310
你这个组件

33:41.910 --> 33:43.210
需要用哪些上下文的数据

33:43.210 --> 33:44.310
是不是真的需要上下文

33:44.510 --> 33:46.410
你想清楚你去自己手写

33:46.910 --> 33:48.910
如果你手你都把它手写出来了

33:48.910 --> 33:51.110
说明你真的是需要这样的数据

33:52.310 --> 33:53.210
另一方面的

33:53.210 --> 33:55.010
也帮助组件的使用者

33:55.010 --> 33:55.710
越多代码

33:55.710 --> 33:57.110
组件的使用者一看这个组件

33:57.110 --> 33:59.610
哦原来你除了要属性之外

34:00.110 --> 34:01.310
还要要这个东西

34:01.510 --> 34:03.210
还要要这个上下文里边的东西

34:03.710 --> 34:04.410
应该这个意思吧

34:04.410 --> 34:06.310
所以说这个东西写起来是b

34:06.310 --> 34:07.910
是有非常非常有必要的

34:08.510 --> 34:09.910
好b需要写这么一句话啊

34:09.910 --> 34:11.710
比方说我们只需要a这个数据

34:12.610 --> 34:13.110
好

34:13.510 --> 34:15.810
用了这个前提条件之后

34:15.910 --> 34:17.710
接下来我们来获取数据

34:18.010 --> 34:20.410
很多地方都可以获取到上下文的数据

34:21.510 --> 34:22.210
可以在

34:23.010 --> 34:24.010
可以在什么

34:24.310 --> 34:25.310
组件的

34:25.810 --> 34:27.310
勾造函数中

34:28.710 --> 34:30.110
通过第二

34:31.310 --> 34:33.410
通过第二个参数

34:34.010 --> 34:35.910
获取上下文数据

34:36.610 --> 34:38.110
好保存看一下啊

34:38.210 --> 34:39.710
咱们呢给这个组件

34:39.710 --> 34:41.310
给这个内组件写个勾造函数

34:41.510 --> 34:42.310
都写过了对吧

34:42.310 --> 34:43.310
第一个参数probs

34:43.310 --> 34:44.410
现在我们多一个参数

34:45.010 --> 34:46.910
第二个参数就是我们上下文的数据了

34:48.310 --> 34:49.810
好我们这里写个修法

34:50.110 --> 34:50.710
probs

34:51.410 --> 34:52.910
好然后呢我们这里输出

34:53.310 --> 34:53.710
log

34:54.210 --> 34:54.910
context

34:57.270 --> 34:57.870
看一下啊

34:58.470 --> 34:59.170
好保存啊

34:59.170 --> 35:00.470
咱们到这边来看一下

35:00.970 --> 35:01.470
你看

35:01.970 --> 35:03.770
child b里边说得到这个数据了

35:03.770 --> 35:04.370
打印出来

35:04.370 --> 35:05.270
他只有一个数据

35:05.270 --> 35:05.870
就是a

35:05.970 --> 35:08.170
上下文的数据是不是a 123拿到了

35:08.270 --> 35:09.470
那b的数据跑哪去了

35:09.570 --> 35:11.070
他b的数据根本就不会给你

35:11.170 --> 35:12.470
房子里难用

35:13.470 --> 35:14.970
一代的越少越好

35:15.270 --> 35:16.070
不要一代那么多

35:16.070 --> 35:16.970
因为你这里声明了

35:16.970 --> 35:18.070
你只需要a就行了

35:19.370 --> 35:20.670
就是咱们其实这种方式

35:20.670 --> 35:21.770
大家也可以学会

35:21.870 --> 35:22.770
你们以后呢

35:23.070 --> 35:24.770
终究会成为一代大神的

35:24.770 --> 35:25.170
对吧

35:25.370 --> 35:27.170
不不不可能永远是初学者

35:27.370 --> 35:29.870
你们早晚会去自己写一些框架

35:30.170 --> 35:31.670
自己写一些底层的东西

35:31.970 --> 35:33.170
底层的模块的东西

35:33.270 --> 35:35.570
这是一种非常非常常用的一种方式

35:35.670 --> 35:37.370
我给你故意的制造麻烦

35:37.770 --> 35:38.170
就是

35:39.270 --> 35:39.970
通常情况下呢

35:39.970 --> 35:42.070
我们是让它是用的越简单越好

35:42.070 --> 35:43.270
但是有的时候

35:43.770 --> 35:45.470
为了让你谨慎使用

35:45.470 --> 35:47.870
我会故意故意的去给你找一些麻烦

35:47.970 --> 35:49.170
让你多写些代码

35:49.470 --> 35:50.870
如果你不怕这个麻烦的话

35:50.870 --> 35:53.370
说明你真的非常非常需要这个东西

35:53.370 --> 35:54.970
不是拍脑袋想出来了

35:55.170 --> 35:56.570
随便你想我就马上用了

35:57.070 --> 35:58.570
你给它使用的成本越高

35:58.570 --> 36:00.070
它用起来就会越谨慎

36:00.170 --> 36:01.070
那么这里就是

36:01.370 --> 36:02.870
它让你谨慎使用上下文

36:02.870 --> 36:05.270
这会导致主建的依赖关系变得复杂

36:05.370 --> 36:06.470
这个主建的通用性

36:06.570 --> 36:07.370
复用性

36:07.670 --> 36:08.570
会变得很差

36:09.870 --> 36:10.970
那么这里只能使用a

36:10.970 --> 36:12.370
那如果这个内形不一致呢

36:12.470 --> 36:13.870
比方说我这里写的是sjun

36:14.270 --> 36:14.670
sjun

36:14.970 --> 36:15.370
不一致

36:15.370 --> 36:15.970
你看一下

36:16.370 --> 36:16.770
他说什么

36:16.770 --> 36:17.670
是不是包错了

36:18.070 --> 36:19.170
他说你这个声明

36:19.170 --> 36:20.470
这个a里边的什么

36:21.970 --> 36:22.570
他说在

36:22.870 --> 36:23.770
b里边

36:24.170 --> 36:25.270
声明这个a

36:27.970 --> 36:29.970
你声明的是一个制服创类型

36:29.970 --> 36:30.370
对吧

36:30.370 --> 36:32.170
但是我从上下文里面得到了

36:32.170 --> 36:33.370
是一个数字内型

36:33.370 --> 36:33.970
是不是不一致的

36:33.970 --> 36:34.570
他会包错

36:35.070 --> 36:36.470
他要求你跟他声明的一致

36:36.570 --> 36:38.670
因此我们往往也会怎么样了

36:38.870 --> 36:40.170
往往也会这样子

36:40.370 --> 36:42.470
就是说我们会把这个地方

36:45.270 --> 36:46.670
把它单独提出来

36:46.770 --> 36:47.570
单独提出来

36:48.170 --> 36:48.670
比方说

36:50.070 --> 36:50.970
刚才这样子

36:50.970 --> 36:52.770
大家也可以自语器写

36:54.070 --> 36:54.570
taps

36:55.070 --> 36:55.970
把单独提出来

36:56.470 --> 36:57.170
那么这里呢

36:57.170 --> 36:58.770
我们就使用taps

37:01.070 --> 37:01.870
这里使用taps

37:02.670 --> 37:03.570
那么这边呢

37:03.870 --> 37:04.370
这边

37:04.970 --> 37:05.570
来自于哪呢

37:05.570 --> 37:07.470
a就来自于taps.a

37:07.470 --> 37:07.970
对吧

37:07.970 --> 37:08.770
taps.a

37:09.170 --> 37:10.470
我们就可以这样子来处理

37:11.070 --> 37:11.570
没问题吧

37:12.170 --> 37:13.570
这也是一种处理方式

37:13.870 --> 37:14.970
它也是一种处理方式

37:14.970 --> 37:16.170
如果需要全部数据的话

37:16.170 --> 37:17.570
那就是直接来自于taps

37:17.970 --> 37:18.370
对吧

37:18.870 --> 37:20.370
这里可以随意处理

37:20.470 --> 37:21.070
随意处理

37:21.070 --> 37:21.570
那么保存

37:21.570 --> 37:22.170
我们看一下

37:22.870 --> 37:24.470
那么现在是不是两个税都拿到了

37:24.570 --> 37:24.970
对不对

37:24.970 --> 37:25.570
a和b

37:25.570 --> 37:26.570
他们都拿到了

37:27.370 --> 37:28.470
这个东西没什么好说的了

37:28.770 --> 37:29.970
我把它放到变量里面

37:30.770 --> 37:31.270
然后

37:31.670 --> 37:33.170
这里内型约束都来自于变量

37:33.370 --> 37:34.570
那如果他们这些组件

37:34.570 --> 37:36.070
位于不同的文件的话

37:36.070 --> 37:37.870
那么我们可以把这个东西提去出来

37:37.870 --> 37:39.170
也形成一个文件

37:39.170 --> 37:39.970
形成个模块

37:40.170 --> 37:41.770
把这个东西导出

37:41.970 --> 37:44.070
那么其他要用到这个上下纹的地方

37:44.170 --> 37:45.470
可以把这个内型导入

37:45.870 --> 37:47.970
就可以达到复用的目的

37:49.570 --> 37:50.270
我们在这里呢

37:50.270 --> 37:51.170
可以得到上下纹

37:51.670 --> 37:52.370
这是一个

37:53.370 --> 37:54.370
但是那这里的上下纹

37:54.370 --> 37:55.170
由于构造函数

37:55.170 --> 37:56.470
它只会运行一次

37:56.970 --> 37:58.370
构造函数只会运行一次

37:58.370 --> 37:59.670
那后边上下纹的数据

37:59.670 --> 38:00.670
如果改变了

38:00.770 --> 38:01.370
如果改变了

38:01.370 --> 38:02.570
这个上下纹是不是得不到了

38:02.570 --> 38:03.670
就不是得不到了

38:03.770 --> 38:04.970
是不是它不会更新

38:04.970 --> 38:05.370
对不对

38:05.370 --> 38:06.170
它不会更新

38:06.170 --> 38:07.470
所以说更多的时候

38:08.270 --> 38:09.170
更多的时候

38:09.170 --> 38:10.970
我们会使用第二种方式

38:13.070 --> 38:14.470
在组件的

38:15.670 --> 38:16.470
context

38:16.470 --> 38:19.070
从组件的context中属性中得到

38:19.670 --> 38:21.270
从组件的context

38:21.470 --> 38:23.470
属性中获取

38:24.870 --> 38:26.070
这是我们常用的方式

38:26.070 --> 38:27.870
就是如果你用旧的API的话

38:28.070 --> 38:29.570
一般我们都会用这种方式

38:29.870 --> 38:31.070
由于它再来得到了

38:31.470 --> 38:33.470
拿到了是zees.context

38:33.770 --> 38:34.870
zees.context

38:35.070 --> 38:36.670
从当前属性里面拿到

38:37.070 --> 38:38.170
保存我们看一下

38:39.170 --> 38:40.670
它这里得到的是undefend

38:40.770 --> 38:42.070
为什么是undefend呢

38:42.170 --> 38:44.470
是因为它的负类的构造函数里边

38:44.470 --> 38:45.270
它有一个参数

38:45.670 --> 38:46.570
还有第二个参数

38:46.570 --> 38:47.970
就是如果你有上下纹的话

38:47.970 --> 38:49.970
你需要把上下纹那个参数也传进去

38:50.970 --> 38:51.470
将

38:53.070 --> 38:55.670
参数的上下纹

38:55.970 --> 38:58.870
交给负类处理

38:59.870 --> 39:00.870
它会进行处理

39:01.470 --> 39:02.870
然后我们这里就可以通过

39:02.870 --> 39:04.070
它其实处理得很简单

39:04.070 --> 39:05.370
还要把它保存到属性里边

39:05.470 --> 39:06.770
以后上下纹变化的时候

39:06.770 --> 39:08.370
它会重新更新这里的属性

39:08.670 --> 39:09.570
它会重新更新

39:10.170 --> 39:11.770
那么这里context得到了

39:11.770 --> 39:12.570
得到的是什么呢

39:12.970 --> 39:13.970
是不是ab

39:14.370 --> 39:15.570
这是我们常用的方式

39:16.370 --> 39:17.770
当然如果你不写这个构造函数

39:17.770 --> 39:18.770
它是不是自动运行的

39:18.770 --> 39:19.270
对不对

39:19.370 --> 39:20.770
它就自动运行修复了

39:21.470 --> 39:23.570
那么我们在render里面就可以直接写了

39:24.370 --> 39:25.470
来自于

39:27.470 --> 39:29.570
上下纹的数据

39:30.470 --> 39:31.470
一个是a

39:31.970 --> 39:32.970
a等于啥呢

39:33.270 --> 39:36.170
a就等于z是什么context

39:36.170 --> 39:36.970
a

39:37.470 --> 39:39.470
然后b等于啥呢

39:39.470 --> 39:41.470
z是context

39:41.470 --> 39:42.370
b

39:44.970 --> 39:46.370
保存看一下吧

39:46.970 --> 39:48.570
你看是不是把上下纹的数据拿到了

39:48.770 --> 39:49.170
对不对

39:49.970 --> 39:51.070
上下纹的数据拿到了

39:53.370 --> 39:54.870
然后我们再来看一下

39:55.470 --> 39:56.770
上下纹的数据

39:56.770 --> 39:59.070
如果在函数组件里面怎么拿到

39:59.670 --> 40:01.070
函数组件没有z

40:01.070 --> 40:02.270
它没有zcontext

40:03.070 --> 40:04.670
函数组件它没有z

40:04.670 --> 40:06.670
所以说我们直接通过第二个参数拿到

40:07.070 --> 40:08.370
在函数组件里边

40:09.670 --> 40:10.070
这里

40:12.360 --> 40:13.760
在函数组件中

40:14.560 --> 40:15.460
组件中

40:16.960 --> 40:19.160
通过第二个参数

40:19.560 --> 40:21.460
获取上下纹数据

40:21.960 --> 40:22.760
搞清楚

40:22.760 --> 40:25.060
创建上下纹的只能是内组件

40:25.060 --> 40:26.860
但是获取上下纹数据的

40:26.860 --> 40:29.060
可以是函数组件也可以是内组件

40:30.060 --> 40:30.660
那么这里呢

40:30.660 --> 40:32.160
我们就可以通过在这里

40:32.360 --> 40:33.160
几个H2

40:33.560 --> 40:39.760
H2A来自于context.a

40:39.960 --> 40:44.760
然后B来自于context.b

40:46.560 --> 40:47.160
保存

40:47.160 --> 40:47.760
保存

40:48.160 --> 40:49.460
那么我们看一下能不能拿到

40:49.960 --> 40:50.960
这里没有拿到

40:50.960 --> 40:52.160
没有拿到的原因是什么

40:52.160 --> 40:52.960
我们讲过的

40:54.560 --> 40:56.160
想想没拿到的原因是什么

40:56.560 --> 40:57.860
是不是有个前提条件

40:58.560 --> 41:01.160
B需要有个静态属性context types

41:01.560 --> 41:02.560
所以说你这里呢

41:02.760 --> 41:04.160
这个这个组件

41:04.160 --> 41:05.160
childA

41:05.560 --> 41:08.560
是不是也得有个静态属性context types

41:08.760 --> 41:09.760
你必须要声明

41:09.760 --> 41:11.560
我确实要用到上下纹的数据

41:11.560 --> 41:12.560
我不是开玩笑的

41:13.160 --> 41:14.560
我不是弄着玩的

41:14.560 --> 41:15.560
我知道这里的风险

41:15.760 --> 41:17.560
我已经都写了这么多代码了

41:17.560 --> 41:18.960
所以说我知道风险

41:18.960 --> 41:19.760
你放行给我吧

41:20.960 --> 41:21.360
保存

41:21.960 --> 41:22.360
你看一下

41:22.560 --> 41:23.960
那么现在是不是都可以拿到了

41:24.160 --> 41:24.560
对不对

41:25.960 --> 41:28.160
这是获取上下纹的里边数据

41:29.360 --> 41:30.560
那么接下来我们再来看

41:30.760 --> 41:32.560
上下纹里边的数据

41:33.560 --> 41:34.560
发生改变

41:34.760 --> 41:35.560
发生变化

41:37.760 --> 41:38.560
是这样子

41:39.760 --> 41:40.760
上下纹

41:41.560 --> 41:44.760
上下纹中的数据变化

41:45.560 --> 41:47.360
通常情况下都是这样子的

41:48.160 --> 41:51.360
上下纹中的数据

41:52.160 --> 41:53.760
不可以直接变化

41:53.760 --> 41:54.960
以前是可以的

41:55.160 --> 41:56.060
那么现在呢

41:56.060 --> 41:57.960
那都是很早很早以前的API了

41:57.960 --> 41:59.360
已经早就移出来了

42:00.960 --> 42:01.960
那么现在的变化

42:01.960 --> 42:03.960
数据的变化只有一种情况

42:03.960 --> 42:04.760
什么情况呢

42:05.160 --> 42:06.560
就是最终的一个 main原因

42:06.560 --> 42:07.960
都是状态发生变化

42:08.560 --> 42:09.560
不可以直接变化

42:09.760 --> 42:14.560
最终都是通过状态改变的

42:15.360 --> 42:16.760
都是通过状态发生变化

42:16.760 --> 42:18.360
从而发生变化的

42:18.360 --> 42:19.760
当然属性发生变化

42:19.760 --> 42:22.760
也会导致它从而发生变化

42:23.360 --> 42:24.360
那么比方说到这里

42:25.160 --> 42:26.560
这个child-tunnel里边

42:26.560 --> 42:28.360
它的数据是来自于状态的

42:29.360 --> 42:30.360
我这里写的状态

42:30.760 --> 42:31.760
来自于我这里的状态

42:31.760 --> 42:33.560
123B

42:34.760 --> 42:37.360
我们这里就直接把这个状态返回

42:37.360 --> 42:38.760
当然也可以分开写

42:38.760 --> 42:40.760
ZsStats里边有个A

42:41.760 --> 42:43.560
如果来自于属性的话也可以

42:43.560 --> 42:44.760
来自于属性也可以

42:45.360 --> 42:46.260
就属性发生变化了

42:46.260 --> 42:47.060
它也会跟着变

42:47.060 --> 42:48.360
因为我们之前说的这个函数

42:48.560 --> 42:50.560
只要属性或者是状态发生变化

42:50.560 --> 42:51.560
它都会重新调用

42:51.960 --> 42:52.760
所以说你不用担心

42:53.360 --> 42:53.960
那么这里

42:54.660 --> 42:55.860
那么就为了简单

42:55.860 --> 42:57.260
就直接返回ZsStats了

42:57.660 --> 42:58.360
直接返回这个了

42:59.160 --> 42:59.960
那么比方说

43:00.160 --> 43:01.360
我们这里Stats里边

43:01.360 --> 43:02.360
它有这么一些数据

43:02.360 --> 43:03.560
有这么一些数据

43:04.960 --> 43:06.560
那么或者我们分开写一下

43:06.960 --> 43:09.160
分开写一下ZsStatsB

43:10.560 --> 43:11.260
比方说

43:11.360 --> 43:12.560
咱们有这么一些数据

43:12.960 --> 43:14.960
那么我们这里提供一个按钮

43:14.960 --> 43:16.660
在副组件里面提供一个按钮

43:16.960 --> 43:17.460
button

43:18.260 --> 43:18.960
点击

43:19.260 --> 43:20.660
就是A加1

43:21.760 --> 43:22.560
A加1

43:23.360 --> 43:24.060
onclick

43:24.860 --> 43:25.560
为了简单的话

43:25.560 --> 43:26.660
我就直接在这里写了

43:27.160 --> 43:28.360
当我们点击的时候

43:28.360 --> 43:29.260
A加1

43:34.200 --> 43:36.200
那么怎么A加1

43:36.200 --> 43:37.600
是不是ZsStats

43:37.600 --> 43:38.200
对吧

43:38.200 --> 43:39.700
改变状态就可以了

43:40.100 --> 43:41.400
改变状态就可以了

43:41.600 --> 43:42.400
点A加1

43:42.800 --> 43:43.200
对吧

43:43.200 --> 43:44.200
改变状态就可以了

43:44.200 --> 43:45.900
因为每一次我改变状态

43:45.900 --> 43:47.600
是不是都要重新运行这个函数

43:47.600 --> 43:48.600
我们在这里输出

43:50.200 --> 43:52.200
获取新的上下文

43:53.400 --> 43:55.100
每一次改变状态

43:55.100 --> 43:56.600
它都会重新运行这个函数

43:56.600 --> 43:58.900
从而得到新的上下文对象

43:59.600 --> 44:01.500
那么新的上下文拿到了过后

44:01.500 --> 44:02.700
由于它触发了改变状态

44:02.700 --> 44:03.800
是不是要重新渲染

44:03.800 --> 44:04.300
对吧

44:04.300 --> 44:05.400
重新渲染的时候

44:05.400 --> 44:08.100
你看这些是不是来自于新的数据拿到了

44:08.100 --> 44:08.700
对不对

44:09.800 --> 44:10.900
渲染这些东西的时候

44:10.900 --> 44:11.700
渲染这个

44:11.700 --> 44:12.300
什么

44:12.300 --> 44:13.900
CHEL的B、CHEL的A的时候

44:13.900 --> 44:15.500
新的上下文的数据都有拿到了

44:15.500 --> 44:16.000
对吧

44:16.000 --> 44:17.300
因为我们使用ZsStats

44:17.300 --> 44:18.500
导致它重新渲染

44:18.500 --> 44:19.600
导春看一下

44:20.600 --> 44:21.900
下面一个按钮点击

44:21.900 --> 44:23.300
你看是不是两个都加了

44:23.300 --> 44:23.600
对吧

44:23.600 --> 44:25.100
你看函数是不是也运行了

44:25.100 --> 44:25.600
点击

44:25.600 --> 44:26.900
你看函数是不是运行了

44:28.100 --> 44:30.500
只要属性或者是状态发生变化

44:30.500 --> 44:32.300
那么它会重新运行这个函数

44:32.400 --> 44:34.200
那么会导致上下文发生变化

44:34.200 --> 44:35.700
上下文发生变化了

44:35.700 --> 44:36.800
由于它重新渲染了

44:36.800 --> 44:37.900
那么这些

44:37.900 --> 44:40.400
它又会来自于新的上下文的数据了

44:40.400 --> 44:41.200
是这么一回事

44:43.300 --> 44:44.600
好好看一下

44:44.600 --> 44:46.600
把旧版的API先搞清楚

44:46.600 --> 44:47.800
没问题吧

44:47.800 --> 44:48.800
那么这里还有一个问题

44:48.800 --> 44:49.600
就是说

44:49.600 --> 44:51.800
如果我希望

44:51.800 --> 44:53.600
在直主键里边

44:53.600 --> 44:55.400
也能改变上下文的数据

44:55.400 --> 44:56.800
那么又该怎么办

44:56.800 --> 44:58.600
比方这里有个按钮

44:58.700 --> 45:00.200
直主键的按钮

45:01.400 --> 45:02.700
a加1

45:02.700 --> 45:05.400
直主键也要能够改变上下文的数据

45:05.400 --> 45:07.500
因为上下文是共享的它的数据

45:07.500 --> 45:09.000
从刀理上来说的话

45:09.000 --> 45:11.700
直主键是有能力改变上下文的数据的

45:11.700 --> 45:12.800
那么这个时候怎么办

45:12.800 --> 45:13.300
onclick

45:14.500 --> 45:16.200
你可以利用这种做法

45:16.200 --> 45:16.700
这种做法

45:18.700 --> 45:20.900
这种做法的方式就是

45:20.900 --> 45:23.000
在上下文中

45:23.000 --> 45:26.700
文中加入一个函数

45:26.700 --> 45:27.600
处理函数

45:28.900 --> 45:31.300
可以用于更改

45:31.300 --> 45:32.900
用于后代主键

45:34.400 --> 45:35.900
更改上下

45:36.900 --> 45:38.200
上下文的数据

45:39.500 --> 45:40.500
就是说我们这里

45:40.500 --> 45:41.600
上下文本来是它创建的

45:41.600 --> 45:42.500
对吧

45:42.500 --> 45:44.000
数据本来是属于它的

45:44.000 --> 45:45.200
但是我在这里边

45:46.900 --> 45:48.100
但是我在这里边

45:48.100 --> 45:49.400
想改这个数据

45:49.400 --> 45:50.600
那怎么办呢

45:50.600 --> 45:51.600
在上下文里边

45:51.600 --> 45:53.300
你提供这么一个东西就行了

45:53.300 --> 45:54.300
在上下文里边

45:54.300 --> 45:55.200
比方说

45:55.200 --> 45:57.200
我们在上下文里面写一段话

45:57.200 --> 45:58.800
上下文里面不是一个数据A吗

45:58.800 --> 45:59.400
对吧

45:59.400 --> 46:00.600
是一个Lumber

46:00.600 --> 46:04.000
数据B也是一个字不错

46:04.000 --> 46:07.300
然后还有一个就是Change

46:07.300 --> 46:09.000
它是一个函数

46:09.000 --> 46:10.400
Change是一个函数

46:10.400 --> 46:12.800
我们只要在这里边去调用这个函数

46:12.800 --> 46:15.000
然后在函数里边去改变

46:15.000 --> 46:15.800
这个A和B

46:15.800 --> 46:17.200
是不是就完事了

46:17.200 --> 46:17.600
对不对

46:17.600 --> 46:18.800
没问题吧

46:18.800 --> 46:20.400
我们只要在这里去调用这个函数

46:20.400 --> 46:21.000
就行了

46:21.000 --> 46:24.200
所以说这里它并不会导致数据流动异常

46:24.200 --> 46:26.300
数据还是从上往下流动的

46:26.400 --> 46:28.200
这个数据还是来自于这个

46:28.200 --> 46:30.000
只不过这个Change的B里边

46:30.000 --> 46:31.600
可以调用副组件

46:31.600 --> 46:34.900
就是可以调用副组件里面的数据函数

46:34.900 --> 46:36.400
那么从而达到改变这个目的

46:36.400 --> 46:38.300
这跟属性是不是一样的

46:38.300 --> 46:39.400
咱们以前写属性的时候

46:39.400 --> 46:40.400
是不是这样的写过

46:40.400 --> 46:41.400
看着

46:41.400 --> 46:43.800
我们以前写属性的时候

46:43.800 --> 46:44.800
是不是这样的写过

46:44.800 --> 46:47.600
这里Rex,Propos,An

46:47.600 --> 46:48.400
什么什么什么

46:48.400 --> 46:49.100
然后去调用这个函数

46:49.100 --> 46:49.700
对吧

46:49.700 --> 46:50.700
是不是一样的

46:50.700 --> 46:51.400
那么现在这个东西

46:51.400 --> 46:53.300
是不是来自于上下文里边

46:53.300 --> 46:54.100
对不对

46:54.200 --> 46:57.000
上下文里边有个函数来进行改变数据

46:57.000 --> 46:58.600
是不是完全一样的

46:58.600 --> 47:00.400
它不是说数据流动发生变化

47:00.400 --> 47:02.300
不是说数据在从下面往上流了

47:02.300 --> 47:03.600
不可能的

47:03.600 --> 47:04.500
不可能的

47:04.500 --> 47:06.300
指的是

47:06.300 --> 47:08.300
数据还是从上面流下来的

47:08.300 --> 47:09.700
只不过它给了一个函数

47:09.700 --> 47:12.000
那么你下面的组件可以调用函数

47:12.000 --> 47:14.900
最终改变数据的还是这个函数来改变

47:14.900 --> 47:16.500
并不是只逐渐直接改变的

47:16.500 --> 47:17.900
是这个函数在改变

47:17.900 --> 47:19.900
跟那个事件是一样的

47:19.900 --> 47:22.100
只不过它现在在上下文里边而已

47:22.100 --> 47:24.100
那么现在上下文里边再加一个

47:24.100 --> 47:26.600
比方说

47:26.600 --> 47:28.900
欠级

47:28.900 --> 47:29.800
写这么一个函数

47:29.800 --> 47:32.700
你给我一个新的字

47:32.700 --> 47:34.200
6A

47:34.200 --> 47:35.400
欠级A吗

47:35.400 --> 47:36.600
欠级A

47:36.600 --> 47:37.600
你给我一个6A

47:37.600 --> 47:38.700
然后我这里干嘛呢

47:38.700 --> 47:40.800
this set state

47:40.800 --> 47:42.900
把这个a复制为6A

47:42.900 --> 47:44.100
复制为6A

47:44.100 --> 47:46.200
就完成了

47:46.200 --> 47:47.600
来看一下吧

47:47.600 --> 47:48.800
我这就写了一个函数

47:48.800 --> 47:49.900
你看改变数据

47:49.900 --> 47:52.300
是不是还是自己在改变

47:52.300 --> 47:53.400
这个组件在改变数据

47:53.400 --> 47:53.800
看到没有

47:53.800 --> 47:54.900
还是它在改变数据

47:54.900 --> 47:56.400
数据是属于它的

47:56.400 --> 47:59.300
那么其他只是调用函数而已

47:59.300 --> 48:00.300
那么这里面

48:00.300 --> 48:02.400
这边我们到这里来

48:02.400 --> 48:04.500
就是从contact的时候里面是不是拿到

48:04.500 --> 48:07.000
当然我taps里面再写

48:07.000 --> 48:09.300
这个taps里面再加一个

48:09.300 --> 48:10.300
加一个什么

48:10.300 --> 48:12.100
unchangedA

48:12.100 --> 48:14.600
是一个proptaps

48:14.600 --> 48:16.000
是一个函数

48:16.000 --> 48:17.300
必须要加约数

48:17.300 --> 48:19.000
必须要加约数

48:19.000 --> 48:20.700
然后我们来这边

48:20.700 --> 48:22.200
就可以使用函数

48:22.200 --> 48:24.000
unchangedA

48:24.000 --> 48:25.300
把新的值给它

48:25.300 --> 48:29.200
新的值我们可以给它一个

48:29.200 --> 48:32.400
叫做this context

48:32.400 --> 48:34.000
A加2

48:34.000 --> 48:36.800
它以前的值加2

48:36.800 --> 48:37.900
把新的值给它

48:37.900 --> 48:38.900
它以前的值加2

48:38.900 --> 48:41.300
把表拉式的结算的结果给它

48:41.300 --> 48:44.000
于是相当于是在运行函数

48:44.000 --> 48:46.800
这个函数它就把新的值重新复制给A了

48:46.900 --> 48:50.900
最终还是通过它来完成数据变化的

48:50.900 --> 48:53.200
植住键是不可能直接改变数据的

48:53.200 --> 48:55.100
保存看一下

48:55.100 --> 48:57.300
植住键的按钮点击

48:57.300 --> 48:58.600
哪里写错了

48:58.600 --> 49:01.500
setStateIsNotFunction

49:04.500 --> 49:07.100
哪里写错了

49:07.100 --> 49:09.600
context

49:09.600 --> 49:11.200
unchangedA

49:11.200 --> 49:12.100
这里的this

49:12.100 --> 49:13.300
这个this就有问题了

49:13.300 --> 49:15.700
要用这种方式来写

49:15.800 --> 49:16.600
然后箭头还说

49:16.600 --> 49:18.800
这样子race那才会指向当前对象

49:18.800 --> 49:21.200
不然的话race指向的是这个对象了

49:21.200 --> 49:22.300
那肯定不行

49:22.300 --> 49:22.800
保存

49:24.200 --> 49:24.700
植住键加2

49:24.700 --> 49:25.000
你看

49:27.000 --> 49:27.500
你看

49:27.500 --> 49:29.700
是不是现在达到了共享数据的目的了

49:29.700 --> 49:30.700
这个数据

49:30.700 --> 49:32.200
他们在上下文里边

49:32.200 --> 49:33.800
植住键可以轻松的获取

49:33.800 --> 49:35.000
不用属性传辑了

49:35.000 --> 49:36.800
其实要做的事情

49:36.800 --> 49:38.200
就改变了那么一点

49:38.200 --> 49:40.200
就什么属性

49:40.200 --> 49:41.400
来自于属性的数据

49:41.400 --> 49:43.200
现在变成来自于上下文了

49:43.200 --> 49:44.300
属性能不能传辑可以

49:44.300 --> 49:45.000
但是有些数据

49:45.000 --> 49:46.500
我们可以把它放到上下文里边

49:46.500 --> 49:49.000
这样子更加方便我们来共享数据

49:49.000 --> 49:50.300
仅此而已

49:50.300 --> 49:51.600
没有什么特别的

49:51.600 --> 49:53.700
敲的B本来需要一些数据

49:53.700 --> 49:55.800
那么本来是可以通过敲的A传过来的

49:55.800 --> 49:57.500
但是由于怕麻烦

49:57.500 --> 49:59.300
一层一层传递可能牵到很深

49:59.300 --> 50:01.000
所以我们放到上下文里边

50:01.000 --> 50:02.900
直接通过上下文里边去获取数据

50:04.300 --> 50:05.500
有问题吧

50:05.500 --> 50:07.500
这就是旧版的API里边

50:07.500 --> 50:09.100
如何来创建上下文

50:09.100 --> 50:11.400
以及如何在上下文里边获取数据

50:11.400 --> 50:12.700
好好看一下

50:12.700 --> 50:14.000
你可以暂停视频

50:14.000 --> 50:17.000
把旧版的API先看懂

50:17.000 --> 50:18.000
看懂之后

50:18.000 --> 50:20.500
我们再讲一讲新版的API

50:20.500 --> 50:21.700
新版的API是什么样子

