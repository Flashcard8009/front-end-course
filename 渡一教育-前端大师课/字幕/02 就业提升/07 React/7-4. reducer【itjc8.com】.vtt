WEBVTT

00:00.750 --> 00:04.350
上节课咱们学了那个Action对吧

00:04.350 --> 00:08.850
Action不管它有什么样的花样玩出什么样的花

00:08.850 --> 00:12.650
它最终它就是为了得到一个Action的对象

00:12.650 --> 00:14.950
就是一个普通的平面对象

00:14.950 --> 00:16.350
Plane Objects

00:16.350 --> 00:20.150
那么这节课才是非常非常核心的地方

00:20.150 --> 00:21.350
就是Reducer

00:21.350 --> 00:25.550
Reducer它真正改变数据的函数

00:25.550 --> 00:26.850
Reducer

00:27.250 --> 00:31.250
是用于改变数据的函数

00:32.650 --> 00:35.450
那么这个写Reducer的时候呢

00:35.450 --> 00:36.850
有哪些地方需要注意

00:36.850 --> 00:38.850
咱们来说一下

00:38.850 --> 00:41.250
之前咱们写过这么一个Reducer函数对吧

00:41.250 --> 00:42.450
它有两个函数

00:42.450 --> 00:44.450
这个东西是固定的有两个函数

00:44.450 --> 00:45.750
一个是状态

00:45.750 --> 00:46.950
就是之前的状态

00:46.950 --> 00:49.550
然后你要这一次要往下什么样的操作

00:49.550 --> 00:51.550
我给你返回一个新的状态

00:51.550 --> 00:54.450
就是之前的Reducer它的写法

00:54.450 --> 00:57.450
那么这里一个说平时有哪些地方要注意的

00:57.450 --> 01:00.250
第一个地方要注意的就是一个仓库

01:00.250 --> 01:02.050
一个数据仓库

01:02.050 --> 01:09.550
就是有且仅有一个Reducer

01:10.750 --> 01:15.750
并且通常情况下

01:15.750 --> 01:21.650
一个工程只有一个仓库

01:21.650 --> 01:24.350
通常不能不排除一些特殊情况

01:24.350 --> 01:26.150
你们以后在公司里面绝大部分情况下

01:26.150 --> 01:28.950
都是遇到的是一个工程只有一个仓库

01:28.950 --> 01:31.450
也就是这个这就在马上只运行一次

01:31.450 --> 01:32.650
那么换句话说

01:32.650 --> 01:34.050
由于一个工程里边

01:34.050 --> 01:35.650
比方说我们一个Reducer工程

01:35.650 --> 01:37.050
到时候要结合Reducer

01:37.050 --> 01:39.050
那么它只会创建一个仓库

01:39.050 --> 01:43.350
那么也就是说这个共享数据全部要保存在仓库里边

01:43.350 --> 01:45.750
而一个仓库只对应一个Reducer

01:45.750 --> 01:48.050
你看一下这里不能让你传输主

01:48.050 --> 01:49.350
它不能传输主的

01:49.350 --> 01:54.250
它只能传一个Reducer函数

01:54.250 --> 02:01.950
所以说你整个系统因此一个系统

02:01.950 --> 02:07.750
只有一个Reducer

02:07.750 --> 02:10.350
所以大家要知道这一点

02:10.350 --> 02:13.750
另外一点就是为了方便管理

02:13.750 --> 02:22.850
通常会将Reducer放到单独的文件中

02:23.850 --> 02:27.550
比方说我们Reducer里边可以再新建一个文件夹

02:27.550 --> 02:29.650
就是Reducer

02:29.650 --> 02:31.950
那么这里边我们来放Reducer代码

02:31.950 --> 02:33.350
比方说这个函数

02:33.350 --> 02:33.650
对吧

02:33.650 --> 02:35.250
我们之前写过Reducer函数

02:35.250 --> 02:36.650
那么我可以简介

02:36.650 --> 02:37.950
粘贴到这里

02:37.950 --> 02:39.150
因这个事的解释

02:39.150 --> 02:40.850
比方说粘贴到这

02:40.850 --> 02:43.650
那么这里该导入的导入进来

02:43.650 --> 02:45.150
这个action tabs

02:45.150 --> 02:46.050
OK

02:46.050 --> 02:49.410
导入进来

02:49.410 --> 02:51.210
看一下还有啥

02:51.210 --> 02:53.010
这个导出

02:54.010 --> 02:55.310
default

02:55.310 --> 02:56.410
把函数导出

02:56.410 --> 02:56.910
对吧

02:56.910 --> 02:58.910
我们通常会为了方便管理

02:58.910 --> 03:00.310
通常会把分开

03:00.310 --> 03:01.310
那么这里

03:01.310 --> 03:01.810
这样子进来

03:01.810 --> 03:03.910
我们这里只需要导入Reducer就行了

03:03.910 --> 03:04.810
from

03:04.810 --> 03:06.010
第二鞋杠Reducer

03:06.010 --> 03:07.210
因为它是因这个事文件

03:07.210 --> 03:08.710
所以我们直接导入Reducer

03:11.210 --> 03:11.510
好

03:11.510 --> 03:13.210
那么是不是写完了

03:13.210 --> 03:14.810
就写完了

03:14.810 --> 03:16.910
这是之前我们在测试的代码

03:16.910 --> 03:17.910
下面是测试的代码

03:17.910 --> 03:19.410
你说这个文件中

03:19.410 --> 03:21.610
我们只是创建一个仓库而已

03:21.610 --> 03:22.610
Reducer放哪呢

03:22.610 --> 03:24.410
放到一个另外一个单独的文件中

03:24.410 --> 03:27.010
刚才下面是做一些测试

03:27.010 --> 03:28.110
没问题吧

03:28.110 --> 03:31.210
这是我们这种一种常见的一种做法

03:31.210 --> 03:32.910
常见的一种做法

03:32.910 --> 03:34.610
然后接下来我们慢慢来说

03:34.610 --> 03:36.610
Reducer里边哪些地方是要注意

03:38.210 --> 03:39.210
首先

03:39.210 --> 03:39.810
第一个点

03:41.210 --> 03:44.310
就是Reducer什么时候被调用这个函数

03:44.310 --> 03:47.710
Reducer被调用的时机

03:47.710 --> 03:49.010
什么时候被调用了

03:49.010 --> 03:50.510
它是这样子

03:50.510 --> 03:52.310
第一种情况就是

03:52.410 --> 03:56.010
通过Store Disparch

03:56.010 --> 03:58.310
Disparch这个方法

03:58.310 --> 04:00.810
分发了一个X型的时候

04:00.810 --> 04:03.610
那么这个时候它会调用Reducer

04:03.610 --> 04:05.110
大家看一下

04:05.110 --> 04:05.810
就这里

04:05.810 --> 04:07.310
我们通过分发一个X型

04:07.310 --> 04:09.610
那么Store是不是会把X型和状态

04:09.610 --> 04:10.910
传到Reducer里面去

04:10.910 --> 04:11.310
之前

04:11.310 --> 04:13.110
当前的状态传到Reducer里面去

04:13.110 --> 04:14.710
那么Ducer它得到一个新的数据

04:14.710 --> 04:16.610
那么Store把它保存下来

04:16.610 --> 04:18.010
这是第一种情况

04:18.010 --> 04:20.110
会分发了一个X型

04:20.210 --> 04:23.310
此时会调用Reducer

04:23.310 --> 04:24.210
这个没什么好说的

04:24.210 --> 04:26.110
咱们之前都讲过了

04:26.110 --> 04:28.510
第二种情况

04:28.510 --> 04:29.910
第二种情况是什么呢

04:29.910 --> 04:33.810
当创建完

04:33.810 --> 04:37.510
当创建一个Store的时候

04:37.510 --> 04:43.110
会调用一次Reducer

04:43.110 --> 04:45.310
也就是我们刚刚创建一个仓库的时候

04:45.310 --> 04:46.910
它会调用一次Reducer

04:46.910 --> 04:47.910
就在这个时候

04:47.910 --> 04:48.410
什么时候呢

04:48.410 --> 04:49.910
我们看一下这里

04:49.910 --> 04:55.020
就是我们在这

04:55.020 --> 04:56.620
我们这里只改变一次就行了

04:56.620 --> 04:57.420
改变一次就行了

04:57.420 --> 04:59.020
不用写那么多

04:59.020 --> 05:00.520
这些因为我们商店会讲过了

05:00.520 --> 05:01.520
我就直接把删了

05:01.520 --> 05:02.620
下面这都是测试代码

05:02.620 --> 05:07.880
不要干扰我们

05:07.880 --> 05:11.380
这里我为了让你们看着更加清楚的话

05:11.380 --> 05:14.680
我这里这样子写

05:14.680 --> 05:15.880
number actions

05:15.880 --> 05:19.380
我们这里用这种写法

05:19.380 --> 05:21.380
不用棒着

05:21.380 --> 05:24.180
这里直接触发Store

05:24.180 --> 05:26.880
Dispatch

05:26.880 --> 05:28.480
触发触发什么呢

05:28.480 --> 05:30.880
触发那个一个Action

05:30.880 --> 05:33.180
number actions get

05:33.180 --> 05:35.380
increase action

05:35.380 --> 05:36.780
这下面测试代码

05:36.780 --> 05:38.280
上面是我们创建仓库

05:38.280 --> 05:39.780
其实在创建仓库

05:39.780 --> 05:42.480
在调用这个CreateStore的时候

05:42.480 --> 05:44.480
它一把Reducer传进去了

05:44.480 --> 05:45.380
这是个函数

05:45.380 --> 05:47.080
它会运行一次函数

05:47.080 --> 05:48.580
为什么要运行一次函数呢

05:48.580 --> 05:51.080
主要的目的是要做初始化

05:51.180 --> 05:53.280
我们怎么来验证这一点呢

05:53.280 --> 05:54.380
怎么来验证这一点呢

05:54.380 --> 05:55.780
我们来这样子

05:55.780 --> 05:58.080
我们在Reducer这个函数里面输出一句话

05:58.080 --> 05:59.780
因为只要调用这个函数它就会输

05:59.780 --> 06:01.580
它就会运行这句话

06:01.580 --> 06:04.180
Reducer运行了

06:04.180 --> 06:06.980
运行了我们把参数的值给它打印出来

06:06.980 --> 06:08.380
给它打印出来看一下

06:08.380 --> 06:09.580
保存

06:09.580 --> 06:10.880
你看一下

06:10.880 --> 06:12.280
是不是运行了两次

06:12.280 --> 06:12.580
对吧

06:12.580 --> 06:13.880
运行了两次

06:13.880 --> 06:16.980
这点第二次运行我们很好理解

06:16.980 --> 06:18.680
因为第二次运行是在什么时候呢

06:18.680 --> 06:20.780
是我们在Dispatch的时候

06:20.780 --> 06:22.780
我们传了一个X型进去

06:22.780 --> 06:28.180
Dispatch的时候它运行了一下这个东西

06:28.180 --> 06:31.580
运行的时候你看着

06:31.580 --> 06:32.380
第二次运行的时候

06:32.380 --> 06:33.980
你看是不是旧状态 死

06:33.980 --> 06:35.380
只看第二次

06:35.380 --> 06:37.880
然后X型是不是我们自己写的X型

06:37.880 --> 06:40.380
给它一个Symbol Increase

06:40.380 --> 06:42.380
这是第二次运行很好理解

06:42.380 --> 06:45.180
那么第一次运行是怎么回事呢

06:45.180 --> 06:46.380
第一次运行

06:46.380 --> 06:47.980
咱们再刷新一下

06:47.980 --> 06:49.680
第一次运行是怎么回事呢

06:49.680 --> 06:52.680
第一次运行是在创建

06:52.680 --> 06:54.980
创建那个就是

06:54.980 --> 06:57.580
仓库的时候在这个时候运行的Reducer

06:57.580 --> 06:59.880
那么它为什么要进行运行Reducer呢

06:59.880 --> 07:01.980
是为了进行初始化

07:01.980 --> 07:04.980
是为了进行初始化

07:04.980 --> 07:07.080
还会调用一次Reducer

07:07.080 --> 07:07.980
那么这一次调用过后

07:07.980 --> 07:09.280
以后就不会再调用了

07:09.280 --> 07:11.180
将这种代码还不会再调用了

07:11.180 --> 07:12.580
那么你看它传的是什么呢

07:12.580 --> 07:13.680
传的是10

07:13.680 --> 07:15.280
为什么传的是10

07:15.280 --> 07:18.180
因为在这

07:18.180 --> 07:19.480
因为你给它的一个默认值

07:19.480 --> 07:19.980
对吧

07:19.980 --> 07:21.980
给它的一个默认值是10

07:21.980 --> 07:23.680
与它传掉一个10

07:23.680 --> 07:24.980
那么第二个参数呢

07:24.980 --> 07:25.680
传的是什么呢

07:25.680 --> 07:26.880
传的是一个Action

07:26.880 --> 07:28.680
这个Action呢

07:28.680 --> 07:29.480
它的类型

07:29.480 --> 07:30.180
Type类型

07:30.180 --> 07:32.980
其实是一个非常非常特殊的值

07:32.980 --> 07:33.580
这个特殊的值

07:33.580 --> 07:34.980
我们都不用去管它

07:34.980 --> 07:35.980
这是什么样的特殊值

07:35.980 --> 07:36.980
都不用去管它

07:36.980 --> 07:38.680
不用去管它

07:38.680 --> 07:39.380
总之它

07:39.380 --> 07:40.480
这个Action是我们

07:40.480 --> 07:42.480
这个Type值是我们自己不太会写的

07:42.480 --> 07:43.680
还给你加了一个水积数

07:43.680 --> 07:44.380
对吧

07:44.380 --> 07:48.080
水积的字母和一些数字

07:48.080 --> 07:50.380
给你加了一些水积的东西在这里边

07:50.380 --> 07:51.680
前面那是两个Ata

07:51.680 --> 07:53.480
就是一个非常非常特殊的Action

07:53.480 --> 07:55.180
那么表示的意思就是什么呢

07:55.180 --> 07:56.880
我这一次运行你的Reduce

07:56.880 --> 07:58.380
是为了进行初始化

07:58.380 --> 07:59.280
为了进行初始化

07:59.280 --> 08:00.080
也就是Reduce

08:00.080 --> 08:00.980
你不要认为

08:00.980 --> 08:03.380
只是在Dispatch的时候运行

08:03.380 --> 08:04.980
它还有一个比较特殊的地方

08:04.980 --> 08:06.380
就是在创建仓库的时候

08:06.380 --> 08:08.380
它会运行一次

08:08.380 --> 08:10.380
那么这一次运行有什么意义呢

08:10.380 --> 08:11.380
在目前来说

08:11.380 --> 08:12.980
我们没有任何意义

08:12.980 --> 08:14.780
但是你可以这样

08:14.780 --> 08:15.980
我们不传递

08:15.980 --> 08:16.680
你看着

08:16.680 --> 08:18.080
不传递默认值的时候

08:18.080 --> 08:19.880
它就有意义了

08:19.880 --> 08:21.280
就是我们创建一个仓库的时候

08:21.280 --> 08:22.880
不传递默认值的时候

08:22.880 --> 08:23.680
你看一下

08:23.680 --> 08:25.480
那么默认值是不是undefend

08:25.480 --> 08:26.880
第一次运行是不是undefend

08:26.880 --> 08:27.680
对吧

08:27.680 --> 08:28.480
第一次运行

08:28.480 --> 08:30.280
它的传递的默认值就是undefend

08:30.280 --> 08:31.980
因为没有传递默认值

08:31.980 --> 08:32.680
对不对

08:32.680 --> 08:34.180
那么我们可以怎么来做呢

08:34.180 --> 08:35.580
我们可以利用这一点

08:35.580 --> 08:37.880
来初始化状态

08:37.880 --> 08:40.280
会调用一次Reduce

08:40.280 --> 08:42.080
可以利用这一点

08:42.080 --> 08:43.680
利用这一点

08:43.680 --> 08:46.080
来用Reduce

08:46.280 --> 08:49.480
用Reduce初始化状态

08:49.480 --> 08:50.880
来初始化状态

08:50.880 --> 08:52.680
那么具体怎么来初始化呢

08:52.680 --> 08:55.880
就是创建仓库时

08:55.880 --> 08:57.880
创建仓库时

08:57.880 --> 09:00.380
不传递任何状态

09:00.380 --> 09:01.180
创建仓库的时候

09:01.180 --> 09:04.780
不传递任何默认状态

09:04.780 --> 09:09.180
然后将Reduce的参数State

09:09.180 --> 09:13.080
设置一个默认值

09:13.080 --> 09:13.980
好看着

09:13.980 --> 09:15.180
咱们可以这样子做

09:15.180 --> 09:16.580
在创建仓库的时候

09:16.580 --> 09:18.280
在这里不设置它的默认值

09:18.280 --> 09:19.280
默认状态

09:19.280 --> 09:21.580
然后在这边给它这样子写

09:21.580 --> 09:22.880
给参数设一个默认值

09:22.880 --> 09:24.080
参数能不能设默认值

09:24.080 --> 09:24.980
是不是可以

09:24.980 --> 09:25.580
对吧

09:25.580 --> 09:26.780
好运行

09:26.780 --> 09:29.180
你看一下

09:29.180 --> 09:30.380
那么现在让我们得到这个

09:30.380 --> 09:31.480
得到这个参数State

09:31.480 --> 09:32.780
是不是默认值十的

09:32.780 --> 09:33.880
对不对

09:33.880 --> 09:35.380
为什么可以达到这样的效果

09:35.380 --> 09:38.380
咱们来梳理一下

09:38.380 --> 09:41.780
如果说你这里没传递的状态

09:41.780 --> 09:43.080
这里传递的状态

09:43.080 --> 09:45.480
那么它第一次调用这个Reduce的时候

09:45.480 --> 09:46.480
它是不是会把这个状态

09:46.480 --> 09:47.880
作为参数传过去

09:47.880 --> 09:48.080
对吧

09:48.080 --> 09:48.980
作为参数传过去

09:48.980 --> 09:50.280
那你的默认值还有用吗

09:50.280 --> 09:50.880
是没用了

09:50.880 --> 09:53.480
比方我们这里传递个20

09:53.480 --> 09:53.780
你看一下

09:53.780 --> 09:54.380
是不是20

09:54.380 --> 09:55.280
从20开头

09:55.280 --> 09:55.880
对吧

09:55.880 --> 09:56.480
为什么

09:56.480 --> 09:58.180
因为你这里传递的默认值

09:58.180 --> 09:58.880
它就会把

09:58.880 --> 10:00.880
它到时候会调用这个Reduce

10:00.880 --> 10:02.780
那么它会把你这个传递的默认值

10:02.780 --> 10:04.080
作为参数传递过来

10:04.080 --> 10:05.980
所以说它这里的默认值就失效了

10:05.980 --> 10:06.280
对吧

10:06.280 --> 10:07.480
就失效了

10:07.480 --> 10:10.380
那么如果说你没有传递默认值

10:10.380 --> 10:11.680
如果说你没有传递默认值

10:13.180 --> 10:13.580
对吧

10:13.580 --> 10:15.280
它第二个参数是不是Undefend

10:15.280 --> 10:16.880
那么第二个参数是Undefend的话

10:16.880 --> 10:18.380
它传了一个Undefend进来

10:18.380 --> 10:19.680
那么传Undefend的时候

10:19.680 --> 10:21.480
它是不是这个参数要使用默认值

10:21.480 --> 10:22.080
10

10:22.080 --> 10:22.980
对不对

10:22.980 --> 10:23.980
传了Undefend过来

10:23.980 --> 10:26.480
它就使用了默认值10

10:26.480 --> 10:26.680
好

10:26.680 --> 10:27.280
那么埃克星

10:27.280 --> 10:29.080
它是一个非常非常特殊的埃克星

10:29.080 --> 10:30.880
因此这个判断进不去

10:30.880 --> 10:32.080
这个判断进不去

10:32.080 --> 10:33.080
这个判断也进不去

10:33.080 --> 10:35.080
它是不是远方不动的返回了

10:35.080 --> 10:35.680
对不对

10:35.680 --> 10:35.880
好

10:35.880 --> 10:37.080
咱们再来梳理一下

10:37.080 --> 10:38.380
慢一点

10:38.380 --> 10:41.180
一开始是Store在这里边

10:41.180 --> 10:42.780
在这呢

10:42.880 --> 10:47.380
它的默认值是Undefend的

10:47.380 --> 10:48.880
它的默认值是Undefend的

10:48.880 --> 10:49.880
它的数据

10:49.880 --> 10:50.180
好

10:50.180 --> 10:51.780
然后它传了一个什么过去

10:51.780 --> 10:53.180
是不是传了一个Undefend的过去

10:53.180 --> 10:53.780
对吧

10:53.780 --> 10:56.180
传了一个Undefend的过去

10:56.180 --> 10:57.180
它第一次调用

10:57.180 --> 10:58.180
第一次调用

10:58.180 --> 10:59.780
那么旧状态是不是Undefend

10:59.780 --> 11:00.280
对吧

11:00.280 --> 11:01.380
Undefend

11:01.380 --> 11:02.280
对不对

11:02.280 --> 11:04.680
它旧状态就是Undefend的

11:04.680 --> 11:04.880
好

11:04.880 --> 11:07.080
那么埃克星是一个特殊的Type

11:07.080 --> 11:08.480
特殊的Type值

11:08.480 --> 11:14.600
埃克星是一个特殊的Type值

11:14.700 --> 11:17.400
特殊Type

11:17.400 --> 11:19.200
这是第一次调用

11:19.200 --> 11:21.000
它传了一个特殊的Type值进去

11:21.000 --> 11:22.200
那么到了Reducer里边

11:22.200 --> 11:22.900
你看一下

11:22.900 --> 11:25.000
由于它的参数是Undefend的

11:25.000 --> 11:27.000
那么它是不是使用了默认值

11:27.000 --> 11:28.200
使用了默认值

11:28.200 --> 11:29.800
那么使用了默认值

11:29.800 --> 11:31.000
那个参数是不是变成10

11:31.000 --> 11:31.500
对不对

11:31.500 --> 11:32.200
变成10

11:32.200 --> 11:32.400
好

11:32.400 --> 11:33.600
那么运行这个Reducer

11:33.600 --> 11:34.300
你看一下

11:34.300 --> 11:36.000
由于它的Type值比较特殊

11:36.000 --> 11:37.200
所以这些都匹配不上

11:37.200 --> 11:37.700
对吧

11:37.700 --> 11:39.900
不是我们自己决定的Type

11:39.900 --> 11:41.400
它不是一个有效的Type

11:41.400 --> 11:42.200
不是一个有效的Type

11:42.200 --> 11:44.700
是不是直接把这个远方不动的返回

11:44.700 --> 11:45.800
那么以为它有默认值

11:45.800 --> 11:47.200
是不是返回了一个默认值

11:47.200 --> 11:47.700
对吧

11:47.700 --> 11:49.800
第一次调用是不是返回了一个默认值

11:49.800 --> 11:50.700
没问题吧

11:50.700 --> 11:52.400
返回了一个默认值

11:52.400 --> 11:53.700
那么是不是返回的是什么

11:53.700 --> 11:54.900
返回的是10

11:54.900 --> 11:55.900
那么返回的默认值

11:55.900 --> 11:57.500
是不是被仓库保留下来了

11:57.500 --> 11:58.400
对不对

11:58.400 --> 11:59.500
是不是被仓库保留下来了

11:59.500 --> 12:00.500
那么保留的是什么

12:00.500 --> 12:01.500
就是10

12:01.500 --> 12:01.800
对吧

12:01.800 --> 12:03.000
就这么个意思

12:03.000 --> 12:03.500
有啥

12:03.500 --> 12:03.800
有啥

12:03.800 --> 12:04.400
很特别的

12:04.400 --> 12:05.600
就这么个意思

12:05.600 --> 12:06.600
那么这个仓库里面

12:06.600 --> 12:09.000
第一次创建好仓库之后

12:09.000 --> 12:10.800
是不是得到一个默认值10

12:10.800 --> 12:12.100
我们就可以利用这一点

12:12.200 --> 12:13.800
写法就非常简单

12:13.800 --> 12:14.800
就是你创建仓库的时候

12:14.800 --> 12:15.900
不要写默认值

12:15.900 --> 12:17.800
然后在Reducer里面给它写成默认值

12:17.800 --> 12:18.500
就完事了

12:18.500 --> 12:19.600
就这么简单

12:19.600 --> 12:20.500
写法非常简单

12:20.500 --> 12:23.500
它原理就是这样的原理

12:23.500 --> 12:25.000
那么我们可以利用这一点

12:25.000 --> 12:26.700
给它写上一个默认值

12:26.700 --> 12:28.500
这是Reducer被调了十几

12:28.500 --> 12:31.300
已经可以利用了地方

12:31.300 --> 12:33.200
那么这样子其实更好一点

12:33.200 --> 12:34.300
Reducer这里的

12:34.300 --> 12:36.200
在Reducer它不是在处理数据的吗

12:36.200 --> 12:36.500
ok

12:36.500 --> 12:37.500
它既然在处理数据

12:37.500 --> 12:39.100
那么它肯定非常清楚

12:39.100 --> 12:41.300
它的数据的结构是什么

12:41.400 --> 12:42.800
那么这里我们在这里完成

12:42.800 --> 12:44.400
对数据结构的初始化

12:44.400 --> 12:47.000
而不在Stone里面进行初始化

12:47.000 --> 12:49.400
这是关于这一点

12:49.400 --> 12:49.600
好

12:49.600 --> 12:50.800
下面这个点

12:50.800 --> 12:53.900
下面是Reducer内部的写法

12:53.900 --> 13:00.800
Reducer内部通常使用Switch

13:00.800 --> 13:05.100
来判断Type值

13:05.100 --> 13:06.800
这也是种数写习惯而已

13:06.800 --> 13:07.400
也就是说

13:07.400 --> 13:09.300
不是说一定是必须要用Switch

13:09.300 --> 13:11.200
没有这样的规定

13:11.200 --> 13:14.900
只是说我们习惯上会写上一个Switch

13:14.900 --> 13:17.100
也就是说这里我们通常会怎么写

13:17.100 --> 13:20.300
一看它代码肯定要简洁一些Switch

13:20.300 --> 13:21.900
Action.Type

13:21.900 --> 13:22.500
对吧

13:22.500 --> 13:25.100
我们看一下Action.Type有哪些地方不一样

13:25.100 --> 13:26.500
哪些地方不一样

13:26.500 --> 13:29.300
不同的地方我们做不同的处理

13:29.300 --> 13:31.100
那么这里的Case比方说

13:31.100 --> 13:33.400
它的Type值是Action.Types

13:33.400 --> 13:36.100
叫什么Increase

13:36.100 --> 13:36.900
然后这个值

13:36.900 --> 13:39.100
这个值我们就返回State加1

13:39.100 --> 13:39.800
对不对

13:39.900 --> 13:40.800
返回State加1

13:43.500 --> 13:46.100
然后这个报警告是因为没有写Default

13:46.100 --> 13:46.800
没有写Default

13:46.800 --> 13:48.500
它一个代码风格检查

13:48.500 --> 13:49.600
Default的话就是

13:49.600 --> 13:50.400
Default是什么意思

13:50.400 --> 13:51.500
就表示了说

13:51.500 --> 13:53.400
我们这里的Type都匹配不上

13:53.400 --> 13:54.500
都匹配不上返回什么

13:54.500 --> 13:55.900
就远风不动的返回State

13:55.900 --> 13:56.400
对吧

13:56.400 --> 13:58.400
远风不动的返回就完事了

13:58.400 --> 13:59.500
那么这里

13:59.500 --> 14:02.200
我们一次来写CaseAction.Types

14:02.200 --> 14:02.900
叫什么

14:02.900 --> 14:09.100
Decrease

14:09.200 --> 14:12.500
那么就返回State减1

14:12.500 --> 14:13.100
对吧

14:13.100 --> 14:15.400
然后Action.Types

14:16.900 --> 14:21.600
Action.Types是set

14:22.900 --> 14:26.400
就返回Action.Payload

14:26.900 --> 14:27.200
对吧

14:27.200 --> 14:28.400
这是我们之前写的代码

14:28.400 --> 14:28.600
OK

14:28.600 --> 14:30.600
我们最终能用这种代码写

14:30.600 --> 14:31.200
两个对比一下

14:31.200 --> 14:33.000
你看上面是不是要简洁很多

14:33.000 --> 14:33.800
对不对

14:33.800 --> 14:35.400
这是通常的一种写法

14:35.400 --> 14:36.600
review手里边的一种写法

14:36.600 --> 14:38.200
我们通常会用Swee起来写

14:38.200 --> 14:39.500
第4车就是匹配不上

14:39.500 --> 14:41.000
所有的类型都匹配不上的时候

14:41.000 --> 14:42.500
那么就远风不动的

14:42.500 --> 14:44.100
返回它的状态就完事了

14:45.100 --> 14:46.000
这是关于这一点

14:46.000 --> 14:47.000
这一点也很简单

14:47.900 --> 14:51.100
下面这个点是非常非常重要的一点

14:53.000 --> 14:54.000
大家注意

14:54.000 --> 14:55.500
下面这个点说的就是

14:55.500 --> 14:58.500
Reducer必须是一个

14:58.500 --> 15:02.400
没有副作用的存函数

15:03.900 --> 15:04.700
又来了对吧

15:04.700 --> 15:07.400
我们之前看到Action的创建函数

15:07.500 --> 15:09.900
他也要求是一个没有副作用的存函数

15:09.900 --> 15:10.800
那么Reducer这里

15:10.800 --> 15:13.500
也要求是一个没有副作用的存函数

15:13.500 --> 15:17.000
实际上Reducer大概是有没有强制要求这一点的

15:17.000 --> 15:19.200
因为大概是实际上没有强制要求的

15:20.600 --> 15:22.400
你不有点负一阵副作用的

15:22.400 --> 15:23.200
他也不会怪你

15:23.200 --> 15:24.900
他也会正常运行

15:24.900 --> 15:26.000
只不过很多公司

15:26.000 --> 15:27.000
不用说很多公司

15:27.000 --> 15:28.300
百分之百所有公司

15:28.300 --> 15:29.000
他都要求你

15:29.000 --> 15:31.200
必须是一个没有副作用的存函数

15:31.200 --> 15:32.400
为什么要这样

15:32.400 --> 15:33.400
这样子不一定

15:34.400 --> 15:35.800
是因为Reducer

15:35.800 --> 15:37.200
他在处理数据状态

15:38.400 --> 15:40.200
那么如果说你在这里

15:40.200 --> 15:41.400
属于的改动参数

15:42.300 --> 15:43.400
比方说我们这里

15:43.400 --> 15:44.400
比方说这里是个对象

15:44.400 --> 15:45.200
是个对象

15:45.800 --> 15:47.600
那么如果是对象里面

15:47.600 --> 15:50.400
属于改动这个状态里面的属性值

15:50.900 --> 15:55.400
那么就会导致之前的状态里边有些东西

15:55.400 --> 15:58.200
而之前的状态跟现在的状态是一个对象

15:58.700 --> 16:00.100
是不是有可能导致这样的问题

16:00.100 --> 16:00.800
对不对

16:01.100 --> 16:03.600
他有可能会导致之前的状态

16:03.600 --> 16:05.600
跟现在的状态是同一个对象

16:06.200 --> 16:07.200
那么这样子

16:07.200 --> 16:09.100
他主要会导致两个问题

16:09.100 --> 16:10.600
第一个不好调试

16:11.400 --> 16:13.500
这个东西我们后边学到一些

16:15.500 --> 16:16.200
一些中间见过后

16:16.200 --> 16:18.000
我们再具体的说不好调试

16:18.000 --> 16:18.800
因为调试的时候

16:18.800 --> 16:19.700
两个是同一个对象

16:19.700 --> 16:21.200
你看展开看来是同一个东西

16:22.400 --> 16:24.300
你又不知道之间发生了哪些变化了

16:24.300 --> 16:25.500
你不知道之前的状态是啥

16:25.500 --> 16:26.100
现在状态是啥

16:26.100 --> 16:27.600
因为他们是同一个对象

16:27.600 --> 16:28.300
你对象改了过

16:28.300 --> 16:29.800
之前的对象也跟着改了

16:29.800 --> 16:31.700
你就不知道之前的对象是啥了

16:31.700 --> 16:33.000
第一个不好调试

16:33.000 --> 16:36.900
第二个是不容易导致不容易还原数据

16:36.900 --> 16:38.300
比方说你比方说

16:38.300 --> 16:39.600
我就举个例子

16:39.600 --> 16:42.600
比方说这个状态里边是一个是一个对象

16:42.600 --> 16:45.800
有一个比方说一个NAM属性

16:45.800 --> 16:47.100
有一个年龄

16:47.100 --> 16:47.800
对吧

16:47.800 --> 16:49.000
那么你在reducer里边

16:49.000 --> 16:50.600
比方说做了这么一件事

16:50.600 --> 16:51.400
State

16:51.400 --> 16:53.200
点A级把它复制为30

16:53.200 --> 16:54.800
你这样你复制

16:54.800 --> 16:56.200
那么这样子你复制

16:56.200 --> 16:58.800
到时候以后可能会有一个需求

16:58.800 --> 17:00.800
就是还原到之前的状态

17:00.800 --> 17:02.600
你能知道之前的状态是啥吗

17:02.600 --> 17:05.200
就不拿不到拿不到之前的状态

17:05.200 --> 17:06.100
对不对

17:06.100 --> 17:07.200
因为你对象改了

17:07.200 --> 17:09.900
你又不知道之前是从什么改成什么的

17:09.900 --> 17:10.400
对吧

17:10.400 --> 17:13.400
你拿不到之前的状态就很难很麻烦

17:13.400 --> 17:15.400
但是如果说你保持新的对象的话

17:15.400 --> 17:16.300
就很简单

17:16.300 --> 17:17.900
之前的对象保持不动

17:17.900 --> 17:21.300
然后得到一个新的对象A级变成30

17:21.300 --> 17:21.800
那么这样子

17:21.800 --> 17:24.100
之前的对象是不是我们可以通过某种方设

17:24.100 --> 17:25.100
把它保存到一个地方

17:25.100 --> 17:25.600
对不对

17:25.600 --> 17:28.300
那么到时候就很容易还原了

17:28.300 --> 17:30.200
是这么个意思

17:30.200 --> 17:32.700
如果它这里的主要目的是这么几个目的

17:32.700 --> 17:40.500
第一个存函数有利于测试和调试

17:40.500 --> 17:43.600
可能你们现在还没有学过测试

17:43.600 --> 17:44.800
因为我们这门课

17:44.800 --> 17:46.400
所以说这门课一般是不设计测试

17:46.400 --> 17:48.400
你们后面专门有门课来设计测试

17:48.400 --> 17:51.000
你会发现存函数是非常容易测试的

17:51.000 --> 17:51.800
你给它一个值

17:51.800 --> 17:52.700
它就反悔一个值

17:52.700 --> 17:53.200
对吧

17:53.200 --> 17:54.600
这样子是很容易调试的

17:54.600 --> 17:56.400
它没有其他任何的副作用

17:56.400 --> 17:58.400
也就是说你只要给它的东西不变

17:58.400 --> 18:01.200
它反悔的东西就一定是不会变化的

18:01.200 --> 18:03.900
那么很容易就是重现这个场景

18:03.900 --> 18:05.700
存函数有利于测试和调试

18:05.700 --> 18:06.900
调试的时候也是一样

18:06.900 --> 18:08.400
我们有的时候要做一些记录

18:08.400 --> 18:09.400
它之前的状态是什么

18:09.400 --> 18:11.200
怎么变到现在的状态的

18:11.200 --> 18:12.200
那如果是同一个对象的话

18:12.200 --> 18:13.900
你会发现两个对象是一样的

18:13.900 --> 18:15.200
现在状态跟之前的状态是一样的

18:15.200 --> 18:16.000
因为同一个对象

18:17.600 --> 18:25.700
第二点是有利于还原数据

18:25.900 --> 18:27.100
我们之前拿到一个数据

18:27.100 --> 18:28.300
刚才那个场景

18:28.300 --> 18:30.500
如果说你直接改变它的属性值的话

18:30.500 --> 18:34.300
那么会导致你要还原到之前的数据的话

18:34.300 --> 18:35.900
你找不到之前的数据是啥了

18:35.900 --> 18:36.700
对吧

18:36.700 --> 18:38.100
所以我们要产生一个新的对象

18:39.700 --> 18:49.800
第三个是有利于将来和react结合时的优化

18:49.800 --> 18:53.600
那么到时候我们会学习如何与react结合

18:53.600 --> 18:54.300
那么结合的时候

18:54.300 --> 18:55.600
我们会具体来说

18:55.600 --> 18:57.000
它会做它做的哪些优化

18:57.000 --> 18:57.500
为什么

18:57.500 --> 18:58.700
那么到时候就非常清楚了

18:58.700 --> 19:00.900
你为什么也需要一个就是存函数

19:02.200 --> 19:04.100
这就是关于它为什么需要个存函数

19:05.400 --> 19:06.900
那么这里记一下

19:06.900 --> 19:10.700
为什么需要存函数

19:14.800 --> 19:15.800
那么再来说

19:15.800 --> 19:17.400
它具体有哪些要求了

19:17.400 --> 19:18.000
具体要求

19:18.000 --> 19:19.600
那就是存函数的要求了

19:19.600 --> 19:20.800
存函数有哪些要求

19:20.800 --> 19:22.200
是不是不能改变参数

19:22.200 --> 19:22.900
对吧

19:22.900 --> 19:25.200
不能改变参数

19:26.800 --> 19:27.700
不能改变参数

19:27.700 --> 19:29.800
包括就是你可以参数重新复职

19:29.800 --> 19:30.600
不行

19:30.600 --> 19:33.300
你可以参数那个某一个属性重新复职

19:33.300 --> 19:34.900
也不行

19:34.900 --> 19:36.100
不能改变参数

19:36.100 --> 19:39.400
也就是说你那么由于它不能改变参数

19:39.400 --> 19:40.500
你这个参数是状态

19:40.500 --> 19:41.200
对吧

19:41.200 --> 19:42.500
是不是状态

19:42.500 --> 19:44.400
那你看一下这个代码行不行

19:44.400 --> 19:45.100
这种代码

19:46.700 --> 19:48.700
比方说这里家家

19:48.700 --> 19:51.700
然后把这个redu state返回行不行

19:51.700 --> 19:53.000
这样代码不行

19:53.000 --> 19:54.600
因为这样子是改变参数了

19:54.600 --> 19:55.500
对不对

19:55.500 --> 19:57.400
改变参数了

19:57.400 --> 19:58.100
所以说呢

19:58.100 --> 19:59.100
比方说它是个对象

19:59.100 --> 20:01.100
比方说它是个对象

20:01.100 --> 20:02.100
我就随便瞎写个

20:03.700 --> 20:04.900
那么你能不能这样做

20:04.900 --> 20:07.000
State改变参数的属性能不能

20:07.000 --> 20:08.300
比如说没改变参数

20:08.300 --> 20:09.600
我这里没有给参数重新复职

20:09.600 --> 20:11.300
我只是给属性重新复职

20:11.300 --> 20:12.300
也不行

20:12.300 --> 20:14.500
这个参数不能有任何变化

20:14.500 --> 20:15.800
参数不能有任何变化

20:15.800 --> 20:17.900
你把这个号路给直接断了

20:17.900 --> 20:19.100
你不能改变参数

20:19.100 --> 20:21.000
不能改变参数

20:21.100 --> 20:22.300
那么比方比方说

20:22.300 --> 20:23.500
我要把A级变成3

20:23.500 --> 20:24.700
我应该怎么写

20:24.700 --> 20:25.700
是不是应该这样子写

20:25.700 --> 20:27.300
返回返回

20:27.300 --> 20:28.600
返回啥

20:28.600 --> 20:29.600
我可以这样子写

20:29.600 --> 20:31.200
是不是要对象合并

20:31.200 --> 20:32.600
之前的拿到

20:32.600 --> 20:32.900
对吧

20:32.900 --> 20:34.200
之前的展开

20:34.200 --> 20:35.800
然后把A级变成3

20:35.800 --> 20:36.700
你得这样子写

20:36.700 --> 20:38.200
用展开运算幅

20:38.200 --> 20:39.200
对不对

20:40.700 --> 20:41.800
那么或者说A级

20:41.800 --> 20:42.600
A级加1

20:42.600 --> 20:43.300
A级加1的话

20:43.300 --> 20:45.400
我们是不是可以用这种方式

20:45.400 --> 20:47.600
State的A级

20:47.600 --> 20:48.300
加上1

20:48.300 --> 20:48.700
对不对

20:48.700 --> 20:49.800
重新复职

20:49.800 --> 20:51.500
给这个A级重新复职

20:51.500 --> 20:52.900
你得用这种形式来做

20:52.900 --> 20:55.000
或者说你写成一个什么

20:55.000 --> 20:57.000
Objects Design

20:57.000 --> 20:59.700
就是Objects

20:59.700 --> 21:00.600
而散

21:00.600 --> 21:01.200
而散

21:01.200 --> 21:02.300
来混合对象

21:02.300 --> 21:03.000
但是混合对象

21:03.000 --> 21:03.300
注意哦

21:03.300 --> 21:05.800
第一个参数是不能写State的

21:05.800 --> 21:06.400
因为你写的

21:06.400 --> 21:07.800
第一个参数写State的话

21:07.800 --> 21:09.800
它仍然会把第二后边的数据

21:09.800 --> 21:11.900
覆盖掉第一个对象里面的东西

21:11.900 --> 21:13.300
你不能导致第一个对象改动

21:13.300 --> 21:14.400
是不能做任何改动的

21:14.400 --> 21:15.100
所以第一个参数

21:15.100 --> 21:16.800
你再写一个空对象

21:16.800 --> 21:17.900
新建一个对象

21:17.900 --> 21:19.700
然后把State混合进来

21:19.700 --> 21:22.500
把这个A级混合进来

21:22.500 --> 21:23.300
不要这个意思吧

21:23.300 --> 21:25.000
你在这样子写

21:25.000 --> 21:26.000
总之呢

21:26.000 --> 21:27.500
把这条路给断了

21:27.500 --> 21:29.300
就是不要想去改动这个

21:29.300 --> 21:31.000
那你只能返回一个新的东西

21:31.000 --> 21:33.700
返回一个全新的东西

21:33.700 --> 21:35.400
把这条路给断掉

21:35.400 --> 21:36.800
所以不能改变参数

21:36.800 --> 21:44.600
因此若要让状态变化

21:44.600 --> 21:47.600
必须得到一个新的状态

21:47.600 --> 21:48.200
跑不了的

21:48.200 --> 21:49.300
没得跑

21:49.300 --> 21:50.300
你只能这样做

21:50.300 --> 21:52.400
你没有别的办法

21:52.400 --> 21:54.000
所以说这条一定要记住

21:54.000 --> 21:56.000
千万不要在Reducer里边

21:56.000 --> 22:00.200
去写上有附中的代码

22:00.200 --> 22:01.000
就是改变参数

22:01.000 --> 22:02.600
就是附作用

22:02.600 --> 22:04.700
那么第二个肯定是不能有异步

22:04.700 --> 22:05.600
不能有异步

22:05.600 --> 22:07.000
异步代码想都不要想

22:07.000 --> 22:07.900
什么阿加克斯

22:07.900 --> 22:10.200
set timeouts这些不要想了

22:10.200 --> 22:12.400
Promise这里面根本就没有

22:12.400 --> 22:14.700
不能有异步

22:14.700 --> 22:18.900
然后不能对外部环境造成影响

22:19.100 --> 22:21.300
比方说什么local storage

22:21.300 --> 22:23.100
cookie这些外部环境的东西

22:23.100 --> 22:24.700
不能造成任何影响

22:24.700 --> 22:26.700
总之Reducer就有一个非常简单的东西

22:26.700 --> 22:29.700
就是你现在眼睛就看着这个set

22:29.700 --> 22:30.700
看着这个x

22:30.700 --> 22:32.300
其他啥都不要管

22:32.300 --> 22:33.700
你给我一个x

22:33.700 --> 22:36.300
那么这个样子其实思维是非常纯粹的

22:36.300 --> 22:38.100
因为一个纯韩数

22:38.100 --> 22:39.500
就是一个单项数据留

22:39.500 --> 22:39.900
你给我一个东西

22:39.900 --> 22:40.500
我给你一个东西

22:40.500 --> 22:40.900
给我一个东西

22:40.900 --> 22:41.700
我给你一个东西

22:41.700 --> 22:42.300
对吧

22:42.300 --> 22:43.300
那么这样子的

22:43.300 --> 22:45.300
就是非常纯粹的一个韩数

22:45.300 --> 22:46.300
也是这样的

22:46.300 --> 22:48.300
就是非常纯粹的纯粹的一个韩数

22:48.300 --> 22:50.300
也是非常容易理解的

22:50.300 --> 22:51.300
你要做什么

22:51.300 --> 22:52.700
我之前的状态给你

22:52.700 --> 22:54.500
根据你要做的事情

22:54.500 --> 22:54.900
ok

22:54.900 --> 22:57.300
我得到了一个新的状态

22:57.300 --> 22:59.300
所以他做的事情很简单

22:59.300 --> 23:00.300
这就是Reducer

23:00.300 --> 23:00.800
这个特点

23:00.800 --> 23:02.100
这个特点一定要记住

23:02.100 --> 23:03.300
千万千万要记住

23:03.300 --> 23:06.300
他是不能有任何副中用的纯韩数

23:07.500 --> 23:07.700
好

23:07.700 --> 23:10.100
这是这一点

23:10.100 --> 23:10.300
好

23:10.300 --> 23:11.500
最后一点

23:11.500 --> 23:13.300
就是本来稍微麻烦一点

23:13.300 --> 23:15.300
前面其实都没有什么

23:15.300 --> 23:17.300
太多要注意的

23:17.300 --> 23:19.300
就是注意他是纯韩数有些吗

23:19.300 --> 23:22.300
最后一点是比较麻烦的

23:22.300 --> 23:26.300
由于在大中型项目中

23:29.300 --> 23:32.300
就是操作比较复杂

23:32.300 --> 23:36.300
数据结构也比较复杂

23:36.300 --> 23:42.300
因此需要对Reducer进行细分

23:42.300 --> 23:44.300
进行细分

23:44.300 --> 23:45.300
什么意思呢

23:45.300 --> 23:47.300
就是我们现在的状态

23:47.300 --> 23:50.300
只是一个数字而已

23:50.300 --> 23:53.300
我们的状态它只是一个数字而已

23:53.300 --> 23:55.300
非常简单的一个数字

23:55.300 --> 23:56.300
那么这个状态

23:56.300 --> 23:57.300
但是实际开发中

23:57.300 --> 23:59.300
我们肯定不只是一个数字

23:59.300 --> 24:01.300
我们整个常库里边的状态

24:01.300 --> 24:03.300
要存放所有的共享数据

24:03.300 --> 24:05.300
比方说

24:05.300 --> 24:06.300
比如

24:06.300 --> 24:08.300
我举个例子

24:08.300 --> 24:10.300
比如的话我们这里

24:10.300 --> 24:11.300
我这要写个完整的例子出来

24:11.300 --> 24:13.300
比方说我们这里的状态

24:13.300 --> 24:15.300
一共享状态里边有哪些呢

24:15.300 --> 24:19.300
有当前登录的

24:19.300 --> 24:23.300
就是用户

24:23.300 --> 24:25.300
当前登录的用户

24:25.300 --> 24:27.300
这是一个状态对不对

24:27.300 --> 24:28.300
还有什么状态呢

24:28.300 --> 24:31.300
就是所有的用户

24:31.300 --> 24:32.300
这也是一个共享

24:32.300 --> 24:33.300
比方说这是个共享状态

24:33.300 --> 24:34.300
比方说还有什么

24:34.300 --> 24:36.300
所有的城市

24:36.300 --> 24:38.300
所有的城市

24:38.300 --> 24:40.300
城市数据

24:40.300 --> 24:41.300
省份

24:41.300 --> 24:43.300
城市

24:43.300 --> 24:45.300
居住街道这些数据

24:45.300 --> 24:46.300
也是共享的数据

24:46.300 --> 24:48.300
比方说

24:48.300 --> 24:49.300
还有什么呢

24:49.300 --> 24:51.300
电影数据

24:51.300 --> 24:54.300
还有什么新闻数据

24:54.300 --> 24:55.300
新闻数据

24:55.300 --> 24:58.300
这些都是共享的数据

24:58.300 --> 24:59.300
那么这些数据里边

24:59.300 --> 25:00.300
是不是还有很多很多东西

25:00.300 --> 25:01.300
比方说所有的用户

25:01.300 --> 25:02.300
可能是一个数据

25:02.300 --> 25:03.300
那它里边是不是

25:03.300 --> 25:04.300
还有很多很多东西

25:04.300 --> 25:06.300
对不对

25:06.300 --> 25:08.300
那么这些状态

25:08.300 --> 25:09.300
这些共享的状态

25:09.300 --> 25:10.300
比方说

25:10.300 --> 25:11.300
还有很多细致墨界的东西

25:11.300 --> 25:12.300
比方说

25:12.300 --> 25:14.300
用户是否关闭过新闻

25:14.300 --> 25:17.300
用户是否点击过

25:17.300 --> 25:20.300
不再显示广告

25:20.300 --> 25:21.300
比方说广告

25:21.300 --> 25:22.300
一个广告飘出来

25:22.300 --> 25:23.300
用户点的不再显示

25:23.300 --> 25:24.300
那么以后

25:24.300 --> 25:25.300
这个网页瀏覽过程中

25:25.300 --> 25:26.300
都不再显示了

25:26.300 --> 25:27.300
那么这个数据

25:27.300 --> 25:28.300
是不是也要记录下来

25:28.300 --> 25:29.300
对吧

25:29.300 --> 25:30.300
就是用户跟UI的一些相关操作

25:30.300 --> 25:31.300
共享操作

25:31.300 --> 25:32.300
可能也要记录下来

25:32.300 --> 25:33.300
对吧

25:33.300 --> 25:35.300
这些数据太多太多了

25:35.300 --> 25:36.300
都不用大动心项目了

25:36.300 --> 25:37.300
就是一个

25:37.300 --> 25:38.300
稍微商点规模的项目

25:38.300 --> 25:39.300
它数据

25:39.300 --> 25:41.300
共享数据可能就会非常非常多

25:41.300 --> 25:42.300
那么这么多数据

25:42.300 --> 25:43.300
你想一想

25:43.300 --> 25:44.300
它对你的操作

25:44.300 --> 25:45.300
是不是一定很多

25:45.300 --> 25:46.300
哪里要用这样子

25:46.300 --> 25:47.300
Switch来判断的话

25:47.300 --> 25:49.300
哪里要写多长啊

25:49.300 --> 25:50.300
写几千行

25:50.300 --> 25:52.300
可能要写几千行的Switch带

25:52.300 --> 25:53.300
每个Switch里边

25:53.300 --> 25:54.300
那管理的数据

25:54.300 --> 25:55.300
也不一样

25:55.300 --> 25:56.300
那这个东西

25:56.300 --> 25:58.300
函数是不是太恐怖了

25:58.300 --> 25:59.300
是不是太恐怖了

25:59.300 --> 26:01.300
那么这样子的话

26:01.300 --> 26:03.300
不利于我们

26:03.300 --> 26:04.300
就是在工程里面操作

26:04.300 --> 26:05.300
不利于我们维护

26:05.300 --> 26:07.300
也不利于我们编写带

26:07.300 --> 26:09.300
那么这样子一来

26:09.300 --> 26:10.300
我们可能会希望

26:10.300 --> 26:12.300
把这个Reducer进行细分

26:12.300 --> 26:13.300
细分

26:13.300 --> 26:14.300
就是说

26:14.300 --> 26:15.300
当时他为什么给你搞出一个

26:15.300 --> 26:16.300
Reducer这个模块出来

26:16.300 --> 26:17.300
以前Flux没有的

26:17.300 --> 26:19.300
他就是为了细分这些东西

26:19.300 --> 26:21.300
为了细分这些东西

26:21.300 --> 26:22.300
但是你要知道

26:22.300 --> 26:24.300
最终

26:24.300 --> 26:26.300
尤且仅有一个Reducer

26:26.300 --> 26:28.300
最终细分分化过去

26:28.300 --> 26:29.300
过后你再把合并

26:29.300 --> 26:31.300
合并成一个Reducer

26:31.300 --> 26:33.300
合并成一个Reducer

26:33.300 --> 26:35.300
那么怎么来细分呢

26:35.300 --> 26:36.300
我们可以这样子来做

26:36.300 --> 26:38.300
就是

26:38.300 --> 26:39.300
每一个Reducer

26:39.300 --> 26:40.300
就是我们细分出去的

26:40.300 --> 26:41.300
每一个Reducer

26:41.300 --> 26:42.300
当然肯定要合并

26:42.300 --> 26:44.300
到时候再说怎么去合并

26:44.300 --> 26:45.300
每一个Reducer

26:45.300 --> 26:47.300
他只关心那一块数据就行了

26:47.300 --> 26:49.300
比较当前登录的用户

26:49.300 --> 26:50.300
我们只维护

26:50.300 --> 26:51.300
当前登录的用户

26:51.300 --> 26:52.300
这一块数据

26:52.300 --> 26:53.300
我们来看一下怎么来写

26:53.300 --> 26:54.300
看着

26:54.300 --> 26:55.300
Reducer里面

26:55.300 --> 26:57.300
我们新建一个Reducer

26:57.300 --> 26:59.300
表示

26:59.300 --> 27:01.300
logging

27:01.300 --> 27:03.300
或者是我们在新建个文件夹

27:03.300 --> 27:05.300
就是subreducers

27:05.300 --> 27:07.300
的Reducers都可以

27:07.300 --> 27:09.300
这些管理方式

27:09.300 --> 27:11.300
就可以自行去做了

27:11.300 --> 27:13.300
比方说我们这里新建一个文件

27:13.300 --> 27:15.300
表示

27:15.300 --> 27:17.300
logging

27:17.300 --> 27:19.300
当前登录的用户

27:19.300 --> 27:20.300
这个Reducer

27:20.300 --> 27:21.300
那么它既然是一个Reducer

27:21.300 --> 27:22.300
还是一样的

27:22.300 --> 27:24.300
现在我们先把它分化出去

27:24.300 --> 27:25.300
最终再把合并

27:25.300 --> 27:26.300
你先不别管怎么合并

27:26.300 --> 27:27.300
先看怎么分化

27:27.300 --> 27:28.300
分化的话就是

27:28.300 --> 27:29.300
一个数据

27:29.300 --> 27:30.300
它对应一个Reducer

27:30.300 --> 27:31.300
就是一些

27:31.300 --> 27:32.300
细微的数据

27:32.300 --> 27:33.300
再去对应Reducer

27:33.300 --> 27:34.300
export

27:34.300 --> 27:35.300
default

27:35.300 --> 27:36.300
方形

27:36.300 --> 27:37.300
logging user

27:39.300 --> 27:40.300
或者导出一个匿名

27:40.300 --> 27:41.300
也行

27:41.300 --> 27:42.300
那么这就是个Reducer

27:42.300 --> 27:44.300
你给我一个状态

27:44.300 --> 27:45.300
给我一个action

27:45.300 --> 27:47.300
但是我这里只会分析

27:47.300 --> 27:49.300
只会得到当前登录的用户

27:49.300 --> 27:51.300
只会得到这个

27:51.300 --> 27:53.300
我们只管理这一块数据

27:53.300 --> 27:54.300
其他数据我管都不管

27:54.300 --> 27:56.300
我只管理这一块数据

27:56.300 --> 27:58.300
那么当前登录的用户

27:58.300 --> 28:00.300
我们可以给它一个默认值

28:00.300 --> 28:01.300
给它一个默认值

28:01.300 --> 28:02.300
默认值为now

28:02.300 --> 28:04.300
表示当前没有登录用户

28:04.300 --> 28:05.300
没有登录用户

28:05.300 --> 28:07.300
那么X形有哪些

28:07.300 --> 28:08.300
有哪些X形

28:08.300 --> 28:09.300
那么咱们

28:09.300 --> 28:10.300
我们写上一个对应的X形

28:10.300 --> 28:12.300
那么X形这里也一样

28:12.300 --> 28:13.300
是不是也可以分化

28:13.300 --> 28:14.300
对不对

28:14.300 --> 28:16.300
X形这里是不是也可以分化

28:16.300 --> 28:18.300
那么这里我们新建一个文件

28:18.300 --> 28:19.300
叫做

28:19.300 --> 28:21.300
logging user

28:21.300 --> 28:22.300
X形

28:22.300 --> 28:23.300
logging user

28:23.300 --> 28:24.300
X形

28:24.300 --> 28:26.300
那么这里点一个介式

28:29.300 --> 28:31.300
那么这个X形里面

28:31.300 --> 28:33.300
我们既可以得到一些

28:33.300 --> 28:34.300
创建X形的函

28:34.300 --> 28:35.300
就是X形创建函数

28:35.300 --> 28:36.300
也可以得到一些

28:36.300 --> 28:37.300
X形的类型

28:37.300 --> 28:39.300
X形的类型也可以得到

28:39.300 --> 28:40.300
我们这里就直接写

28:40.300 --> 28:41.300
把它写到

28:41.300 --> 28:42.300
把它合并到一起写

28:42.300 --> 28:44.300
我们之前是把分成两个文件写的

28:44.300 --> 28:45.300
一个是X形的类型

28:45.300 --> 28:46.300
一个是X形的创建函数

28:46.300 --> 28:47.300
对不对

28:47.300 --> 28:48.300
那么现在呢

28:48.300 --> 28:50.300
我们可以把它合并成一个来说写

28:50.300 --> 28:51.300
当然也可以分开

28:51.300 --> 28:52.300
无所谓

28:52.300 --> 28:53.300
那么分开的话

28:53.300 --> 28:54.300
就建一个文件

28:54.300 --> 28:55.300
logging user

28:55.300 --> 28:56.300
这里边是X形type

28:56.300 --> 28:57.300
一个是

28:57.300 --> 28:59.300
一个是X形的

28:59.300 --> 29:00.300
创建函数

29:00.300 --> 29:01.300
分开

29:01.300 --> 29:02.300
也可以合并

29:02.300 --> 29:03.300
我们这里就合并

29:03.300 --> 29:04.300
因为它本身就并不多

29:04.300 --> 29:05.300
它只是一个模块

29:05.300 --> 29:06.300
就是把Reducer

29:06.300 --> 29:07.300
分开模块之后

29:07.300 --> 29:09.300
我们只关心这一块数据

29:09.300 --> 29:10.300
那么这个X形里面

29:10.300 --> 29:11.300
我们可以导出

29:11.300 --> 29:12.300
export

29:13.300 --> 29:14.300
什么X形呢

29:14.300 --> 29:15.300
就是

29:15.300 --> 29:16.300
logging

29:18.300 --> 29:19.300
什么X形就是

29:19.300 --> 29:20.300
set

29:20.300 --> 29:21.300
logging user

29:21.300 --> 29:23.300
这么一个X形

29:23.300 --> 29:25.300
set一个logging user

29:28.300 --> 29:29.300
set

29:29.300 --> 29:30.300
logging

29:30.300 --> 29:31.300
user

29:31.300 --> 29:32.300
type

29:35.300 --> 29:36.300
我们可以用字幕创

29:36.300 --> 29:37.300
也可以用symbol

29:37.300 --> 29:38.300
用symbol

29:38.300 --> 29:39.300
symbol稳当一点

29:39.300 --> 29:40.300
那么这里

29:40.300 --> 29:41.300
我们是

29:41.300 --> 29:42.300
只要取个名字

29:42.300 --> 29:43.300
叫set

29:43.300 --> 29:44.300
logging

29:44.300 --> 29:45.300
logging

29:45.300 --> 29:46.300
user

29:47.300 --> 29:48.300
好了

29:48.300 --> 29:49.300
就set

29:49.300 --> 29:50.300
logging user type

29:50.300 --> 29:51.300
表示

29:51.300 --> 29:52.300
这个X形的type

29:52.300 --> 29:53.300
就是这个type

29:53.300 --> 29:54.300
对吧

29:54.300 --> 29:55.300
那么这里

29:55.300 --> 29:56.300
只有一个X形

29:56.300 --> 29:57.300
举个例子

29:57.300 --> 29:58.300
比方说只有一个X形

29:58.300 --> 29:59.300
创建函数

29:59.300 --> 30:00.300
比方说我们这里可以

30:00.300 --> 30:01.300
之前用的get

30:01.300 --> 30:02.300
现在也可以用create

30:02.300 --> 30:03.300
都行

30:03.300 --> 30:04.300
看公司的具体约定

30:04.300 --> 30:05.300
create

30:05.300 --> 30:06.300
set

30:06.300 --> 30:07.300
logging

30:07.300 --> 30:08.300
user

30:08.300 --> 30:09.300
x

30:09.300 --> 30:12.680
名字稍微长一点

30:12.680 --> 30:13.680
这是个函数

30:13.680 --> 30:14.680
这个X形的创建函数

30:14.680 --> 30:15.680
它主要的目的是

30:15.680 --> 30:19.180
来创建一个X形

30:19.180 --> 30:20.180
它主要的目的是

30:20.180 --> 30:21.180
来创建一个X形

30:21.180 --> 30:22.180
导出一个X形创建函数

30:22.180 --> 30:23.180
它用来做什么

30:23.180 --> 30:25.180
它用来创建一个

30:25.180 --> 30:27.180
设置登录用户的X形

30:27.180 --> 30:28.180
那么设置登录用户

30:28.180 --> 30:29.180
你看一下

30:29.180 --> 30:30.180
返回的type

30:30.180 --> 30:31.180
type是什么

30:31.180 --> 30:32.180
set

30:32.180 --> 30:33.180
logging

30:33.180 --> 30:34.180
user

30:34.180 --> 30:35.180
这个type

30:35.180 --> 30:36.180
然后

30:36.180 --> 30:37.180
它的payload

30:37.180 --> 30:38.180
它要不要payload

30:39.180 --> 30:40.180
是不是要payload

30:40.180 --> 30:41.180
就是你要设置

30:41.180 --> 30:43.180
当前登录的用户的X形

30:43.180 --> 30:44.180
那是不是要payload

30:44.180 --> 30:46.180
就是一些附加信息

30:46.180 --> 30:47.180
那用户是啥

30:47.180 --> 30:48.180
你是不是要告诉我

30:48.180 --> 30:49.180
对不对

30:49.180 --> 30:50.180
用户是啥

30:50.180 --> 30:51.180
你是不是要告诉我

30:51.180 --> 30:52.180
那么这里

30:52.180 --> 30:53.180
user

30:53.180 --> 30:54.180
要告诉一个user

30:54.180 --> 30:55.180
这个user表示什么意思

30:55.180 --> 30:58.180
表示的是当前登录的用户

30:58.180 --> 30:59.180
有的人说

30:59.180 --> 31:00.180
为什么不传一个账号密码

31:00.180 --> 31:01.180
让那边去登录

31:01.180 --> 31:03.180
这个reducer里面能去登录吗

31:03.180 --> 31:04.180
账号密码是不是

31:04.180 --> 31:05.180
阿迪克斯请求

31:05.180 --> 31:06.180
那是不是副作用

31:06.180 --> 31:07.180
这里面能写吗

31:07.180 --> 31:08.180
是不是不能写

31:08.180 --> 31:09.180
想到不要去想

31:09.180 --> 31:10.180
阿迪克斯请求

31:10.180 --> 31:11.180
想到别想了

31:11.180 --> 31:12.180
你只能通过

31:12.180 --> 31:13.180
阿迪克斯得到了之后

31:13.180 --> 31:14.180
请求得到之后

31:14.180 --> 31:15.180
把用户放到这儿

31:15.180 --> 31:16.180
那么给你设置

31:16.180 --> 31:17.180
只能这样子

31:17.180 --> 31:18.180
那么这个就是

31:18.180 --> 31:23.180
设置登录用户的X形

31:23.180 --> 31:24.180
设置登录用户的X形

31:24.180 --> 31:25.180
那payload是什么

31:25.180 --> 31:26.180
就是user

31:26.180 --> 31:27.180
对吧

31:27.180 --> 31:28.180
告诉我

31:28.180 --> 31:29.180
那么我来帮你设置

31:29.180 --> 31:31.180
这个登录用户

31:31.180 --> 31:33.180
我得到一个X形

31:33.180 --> 31:34.180
标准格式X形

31:34.180 --> 31:35.180
好

31:35.180 --> 31:36.180
那么到这边来

31:36.180 --> 31:37.180
你看一下

31:37.180 --> 31:38.180
两个是对应的

31:38.180 --> 31:39.180
看到没

31:39.180 --> 31:40.180
这个X形

31:40.180 --> 31:41.180
它对应到这里的reducer

31:41.180 --> 31:42.180
看到没

31:42.180 --> 31:43.180
那么这个reducer里面

31:43.180 --> 31:44.180
是不是要导入

31:44.180 --> 31:45.180
对吧

31:45.180 --> 31:47.180
导入

31:47.180 --> 31:48.180
from

31:48.180 --> 31:49.180
来自于哪

31:49.180 --> 31:50.180
来自于

31:50.180 --> 31:52.180
返回上级目录

31:52.180 --> 31:53.180
X形里面

31:53.180 --> 31:54.180
locking userX形

31:54.180 --> 31:55.180
导入什么

31:55.180 --> 31:56.180
X形Type

31:56.180 --> 31:57.180
就是set

31:57.180 --> 31:58.180
locking userType

31:58.180 --> 31:59.180
对吧

31:59.180 --> 32:00.180
我们只需要这个

32:00.180 --> 32:01.180
switch

32:01.180 --> 32:03.180
默认是没有用户登录的

32:03.180 --> 32:04.180
那么switch

32:04.180 --> 32:06.180
如果说你的X形Type值

32:06.180 --> 32:07.180
我们来判断一下

32:07.180 --> 32:08.180
test

32:08.180 --> 32:09.180
如果说

32:09.180 --> 32:10.180
它等于什么

32:10.180 --> 32:11.180
set

32:11.180 --> 32:13.180
locking userType

32:13.180 --> 32:15.180
等于这个值

32:15.180 --> 32:16.180
我要返回

32:16.180 --> 32:17.180
返回

32:17.180 --> 32:18.180
我等一下

32:18.180 --> 32:19.180
那么这里

32:19.180 --> 32:20.180
default先写上

32:20.180 --> 32:25.560
返回set

32:25.560 --> 32:26.560
我记得

32:26.560 --> 32:27.560
这个插件

32:27.560 --> 32:28.560
好像可以快速写的

32:28.560 --> 32:29.560
我看一下

32:29.560 --> 32:30.560
这个插件

32:30.560 --> 32:31.560
我记得是有

32:31.560 --> 32:32.560
有这个功能的

32:32.560 --> 32:33.560
redux

32:34.560 --> 32:35.560
看一下

32:35.560 --> 32:36.560
看一下

32:36.560 --> 32:37.560
不着急

32:37.560 --> 32:38.560
看一下

32:40.560 --> 32:41.560
redux

32:41.560 --> 32:47.220
我看一下redux在哪

32:47.220 --> 32:48.220
我下转

32:51.240 --> 32:57.170
这个redux在哪

32:58.170 --> 32:59.170
redux

32:59.170 --> 33:00.170
redux

33:00.170 --> 33:01.170
redux

33:06.240 --> 33:09.240
Rx

33:09.240 --> 33:10.240
Rx

33:10.240 --> 33:11.240
Rx

33:11.240 --> 33:12.240
Rx

33:12.240 --> 33:13.240
Rx

33:13.240 --> 33:14.240
Rx

33:14.240 --> 33:15.240
看一下

33:16.240 --> 33:17.240
Rx

33:17.240 --> 33:18.240
Rx

33:20.240 --> 33:22.240
这样子也可以

33:22.240 --> 33:23.240
这样子

33:23.240 --> 33:25.240
得到一个X形的创建函数了

33:25.240 --> 33:26.240
它是用箭头函数

33:26.240 --> 33:28.240
给得到导出

33:28.240 --> 33:29.240
函数名字

33:29.240 --> 33:31.240
然后给你传一个参数

33:31.240 --> 33:32.240
有参数的话就传

33:32.240 --> 33:33.240
那么得到一个X形的

33:33.240 --> 33:34.240
创建函数

33:35.240 --> 33:36.240
好

33:36.240 --> 33:37.240
再看

33:40.240 --> 33:41.240
它又给你去掉了

33:44.570 --> 33:45.570
好 这里

33:46.570 --> 33:47.570
Rx

33:47.570 --> 33:48.570
Rx

33:48.570 --> 33:49.570
redux

33:49.570 --> 33:50.570
redux

33:50.570 --> 33:51.570
redux

33:51.570 --> 33:52.570
那我们试一下吧

33:54.570 --> 33:55.570
这里

33:55.570 --> 33:56.570
这是I型的创建函数

33:56.570 --> 33:57.570
已经写过了

33:57.570 --> 33:58.570
那么这里

33:58.570 --> 33:59.570
Rx

33:59.570 --> 34:00.570
redux

34:01.570 --> 34:03.570
可以

34:03.570 --> 34:04.570
没问题

34:04.570 --> 34:06.570
那么它现在就是给你写成这么一种格式了

34:06.570 --> 34:07.570
那现在我们就

34:07.570 --> 34:08.570
舒服多了

34:09.570 --> 34:10.570
Rx

34:10.570 --> 34:11.570
redux

34:11.570 --> 34:12.570
舒服多了

34:12.570 --> 34:13.570
这样子

34:13.570 --> 34:14.570
已经给你写好了

34:14.570 --> 34:15.570
这是解构了

34:15.570 --> 34:16.570
你看一下吧

34:16.570 --> 34:17.570
导出一个

34:17.570 --> 34:18.570
就是

34:18.570 --> 34:19.570
直接写的一个建函函数

34:19.570 --> 34:20.570
对吧

34:20.570 --> 34:21.570
那么这里是默认值

34:21.570 --> 34:22.570
它把默认值放到这儿

34:22.570 --> 34:23.570
默认值

34:23.570 --> 34:24.570
我们这里可以写上

34:24.570 --> 34:25.570
NOW

34:25.570 --> 34:26.570
NOW是默认值

34:26.570 --> 34:27.570
然后

34:27.570 --> 34:28.570
它这里

34:28.570 --> 34:29.570
第二次来说给你解构出来了

34:29.570 --> 34:30.570
对吧

34:30.570 --> 34:31.570
解构出来就两个

34:31.570 --> 34:32.570
一个是Type

34:32.570 --> 34:33.570
一个是Payload

34:33.570 --> 34:34.570
给你解构出来了

34:34.570 --> 34:35.570
那么我们这里

34:35.570 --> 34:36.570
判断一下Type值

34:36.570 --> 34:37.570
如果Type值等于这个的话

34:37.570 --> 34:38.570
如果等于这个的话

34:38.570 --> 34:39.570
你看一下

34:39.570 --> 34:40.570
那么怎么做呢

34:40.570 --> 34:41.570
这个写法是这样的

34:41.570 --> 34:42.570
那肯定不是这样子写的

34:42.570 --> 34:43.570
那么

34:43.570 --> 34:44.570
是不是直接返回Payload的

34:44.570 --> 34:45.570
因为Payload的里边

34:45.570 --> 34:47.570
是不是就记录了

34:47.570 --> 34:48.570
记录了啥呢

34:48.570 --> 34:49.570
就记录了

34:49.570 --> 34:50.570
这个

34:51.570 --> 34:53.570
我要设置的用户

34:53.570 --> 34:54.570
对不对

34:54.570 --> 34:55.570
你不是要设置用户吗

34:55.570 --> 34:56.570
那Payload的里边就记录了

34:56.570 --> 34:57.570
你要设置的用户

34:57.570 --> 34:58.570
好

34:58.570 --> 35:00.570
那么这个redux是不是写出来了

35:00.570 --> 35:01.570
那你看一下

35:01.570 --> 35:02.570
当前登录用户这一块

35:02.570 --> 35:03.570
是不是有一个redux

35:03.570 --> 35:05.570
它对应了一个redux

35:05.570 --> 35:06.570
叫做

35:06.570 --> 35:08.570
对应一个redux

35:08.570 --> 35:09.570
对吧

35:09.570 --> 35:10.570
一个redux

35:10.570 --> 35:11.570
好

35:11.570 --> 35:12.570
那么比方说

35:12.570 --> 35:13.570
还有一个所有的用户

35:13.570 --> 35:14.570
那下面我们不管了

35:14.570 --> 35:15.570
我写不了那么多

35:15.570 --> 35:16.570
好

35:16.570 --> 35:17.570
那么还有一个所有的用户

35:17.570 --> 35:18.570
我们也可以给它写一个redux

35:18.570 --> 35:20.570
就是可以把它分开写

35:20.570 --> 35:21.570
所有的用户

35:21.570 --> 35:23.570
我们把它叫做users

35:23.570 --> 35:25.570
users.js

35:25.570 --> 35:27.570
users.js

35:27.570 --> 35:28.570
或者是这些东西

35:28.570 --> 35:30.570
我们都不应该守这么大写

35:30.570 --> 35:31.570
守这么小写

35:31.570 --> 35:32.570
为什么呢

35:32.570 --> 35:34.570
因为它不是构造函数

35:34.570 --> 35:35.570
users

35:35.570 --> 35:36.570
好

35:36.570 --> 35:37.570
nogginus

35:37.570 --> 35:38.570
us

35:38.570 --> 35:39.570
好

35:39.570 --> 35:41.570
users里边我们也要写一下

35:41.570 --> 35:43.570
首先是x

35:43.570 --> 35:47.720
x

35:47.720 --> 35:49.720
这里要不然也改成

35:49.720 --> 35:50.720
也改成小写

35:50.720 --> 35:52.720
改成小写好一点

35:52.720 --> 35:53.720
改成小写好一点

35:53.720 --> 35:56.720
这里改成小写

35:56.720 --> 35:58.720
那么现在我们再来一个

35:58.720 --> 35:59.720
一个x创建函数

35:59.720 --> 36:00.720
以及x的类型

36:00.720 --> 36:01.720
我们都写过来

36:01.720 --> 36:02.720
都写过来

36:02.720 --> 36:03.720
当然也可以把它分开

36:03.720 --> 36:04.720
这些东西都可以分开的

36:04.720 --> 36:06.720
把类型和类型东西都分开

36:06.720 --> 36:07.720
也可以的

36:07.720 --> 36:09.720
那么这里我们该取个名字

36:09.720 --> 36:12.720
users.js

36:12.720 --> 36:15.720
users.js

36:15.720 --> 36:16.720
那么这里我们

36:16.720 --> 36:17.720
还是先写上类型

36:17.720 --> 36:19.720
有哪些操作类型

36:19.720 --> 36:20.720
我们自己随便写几个吧

36:20.720 --> 36:21.720
写几个

36:21.720 --> 36:22.720
export

36:22.720 --> 36:24.720
const

36:24.720 --> 36:26.720
比方说

36:26.720 --> 36:27.720
添加一个用户

36:27.720 --> 36:28.720
add

36:28.720 --> 36:29.720
users

36:29.720 --> 36:30.720
添加一个用户

36:30.720 --> 36:32.720
那么这个用symbol

36:32.720 --> 36:34.720
add

36:34.720 --> 36:35.720
users

36:35.720 --> 36:37.720
写上一个类型

36:37.720 --> 36:38.720
然后呢

36:38.720 --> 36:39.720
删除一个用户

36:39.720 --> 36:41.720
我们都写一下吧

36:41.720 --> 36:43.720
把这些信息都写一下

36:43.720 --> 36:45.720
就是update user

36:45.720 --> 36:46.720
update

36:46.720 --> 36:47.720
就是delete user

36:47.720 --> 36:49.720
删除一个用户

36:49.720 --> 36:50.720
然后的话

36:50.720 --> 36:51.720
然后export

36:51.720 --> 36:53.720
const

36:53.720 --> 36:56.720
再给一个

36:56.720 --> 36:57.720
再给一个啥呢

36:57.720 --> 36:58.720
再给一个就是

36:58.720 --> 36:59.720
添加用户

36:59.720 --> 37:00.720
删除用户

37:00.720 --> 37:02.720
再来一个update

37:02.720 --> 37:05.720
update user

37:05.720 --> 37:06.720
修改用户

37:07.720 --> 37:08.720
symbol

37:08.720 --> 37:10.720
update user

37:11.720 --> 37:12.720
好 行了

37:12.720 --> 37:13.720
行了

37:13.720 --> 37:14.720
那咱们写的这么三个x

37:14.720 --> 37:16.720
那么具体的写x创建函数

37:16.720 --> 37:17.720
大家可以体会一下

37:17.720 --> 37:19.720
整个reducer是怎么写出来的

37:19.720 --> 37:20.720
创建函数

37:20.720 --> 37:21.720
第一个呢

37:21.720 --> 37:22.720
我们写上一个就是什么

37:22.720 --> 37:23.720
re

37:23.720 --> 37:24.720
rxx

37:24.720 --> 37:26.720
这是个x创建函数

37:26.720 --> 37:27.720
第一个创建函数的名字呢

37:27.720 --> 37:29.720
叫做

37:29.720 --> 37:30.720
叫做什么呢

37:30.720 --> 37:31.720
叫做那个就是

37:31.720 --> 37:33.720
add user

37:33.720 --> 37:35.720
add user

37:35.720 --> 37:37.720
那么这个payload呢

37:37.720 --> 37:38.720
type的

37:38.720 --> 37:39.720
type的姿势

37:39.720 --> 37:40.720
不是

37:40.720 --> 37:41.720
就是

37:42.720 --> 37:44.720
add user

37:44.720 --> 37:45.720
叫做

37:45.720 --> 37:47.720
这样子写

37:47.720 --> 37:49.720
createadd user

37:49.720 --> 37:51.720
x

37:51.720 --> 37:52.720
那么

37:52.720 --> 37:54.720
内容是add user

37:54.720 --> 37:55.720
这毫无疑问

37:55.720 --> 37:56.720
关于这

37:56.720 --> 37:58.720
那么创天下一个用户

37:58.720 --> 37:59.720
你说要给我一个用户

37:59.720 --> 38:00.720
对吧

38:00.720 --> 38:01.720
你说要给我一个用户对象

38:01.720 --> 38:02.720
对不对

38:02.720 --> 38:03.720
那么payload呢

38:03.720 --> 38:04.720
它是乃至于用户对象

38:04.720 --> 38:05.720
要给我一个用户对象

38:05.720 --> 38:06.720
我才能添加

38:06.720 --> 38:07.720
对不对

38:07.720 --> 38:08.720
那么产生一个性就是这样的

38:08.720 --> 38:09.720
一个性

38:09.720 --> 38:10.720
操作内形

38:10.720 --> 38:11.720
那么给了一附加的数据

38:11.720 --> 38:12.720
就是一个用户对象

38:12.720 --> 38:13.720
给力就行了

38:14.720 --> 38:15.720
好

38:15.720 --> 38:16.720
那么这是关于这一块

38:16.720 --> 38:17.720
好 接下来

38:17.720 --> 38:18.720
再来

38:18.720 --> 38:19.720
添加用户搞定了

38:19.720 --> 38:20.720
那么删除用户呢

38:20.720 --> 38:22.720
注意我们现在写啥

38:22.720 --> 38:23.720
写的是一个

38:23.720 --> 38:24.720
add创建函数

38:24.720 --> 38:25.720
那么删除用户

38:25.720 --> 38:26.720
是不是直接要给我

38:26.720 --> 38:27.720
一个id就行了

38:27.720 --> 38:28.720
对不对

38:28.720 --> 38:30.720
那么我们按照id来删除

38:30.720 --> 38:32.720
这里是dn

38:33.720 --> 38:34.720
u

38:34.720 --> 38:36.720
这是删除一个x

38:36.720 --> 38:38.720
删除一个就是用户的x

38:38.720 --> 38:39.720
好

38:39.720 --> 38:40.720
然后是修改用户

38:40.720 --> 38:42.720
update

38:42.720 --> 38:43.720
修改用户

38:43.720 --> 38:44.720
修改用户的话

38:44.720 --> 38:45.720
你是不是要告诉我

38:45.720 --> 38:46.720
修改的用户id

38:46.720 --> 38:48.720
还有是不是新的用户数据

38:48.720 --> 38:49.720
对吧

38:49.720 --> 38:50.720
新的用户数据

38:50.720 --> 38:51.720
你有u的data

38:51.720 --> 38:52.720
对吧

38:52.720 --> 38:53.720
新的用户数据

38:53.720 --> 38:54.720
但是你也可以把它合并

38:54.720 --> 38:55.720
成一个用户对象

38:55.720 --> 38:56.720
对不对

38:56.720 --> 38:57.720
一个用户对象

38:57.720 --> 38:58.720
也可以

39:02.720 --> 39:03.720
一个是id

39:03.720 --> 39:04.720
就修改了用户id

39:04.720 --> 39:06.720
这个是新的用户数据

39:06.720 --> 39:07.720
它就进行修改

39:07.720 --> 39:08.720
那么我们payload

39:08.720 --> 39:09.720
但是只能传一个payload

39:09.720 --> 39:10.720
对吧

39:10.720 --> 39:11.720
那么payload的传啥呢

39:11.720 --> 39:12.720
我们就可以这样子

39:12.720 --> 39:14.720
把新的用户数据展开

39:14.720 --> 39:15.720
你不是个对象吗

39:15.720 --> 39:16.720
对吧

39:16.720 --> 39:18.720
当然你这里可以判断一下

39:18.720 --> 39:19.720
他有没有值

39:19.720 --> 39:21.720
把新的用户数据展开

39:21.720 --> 39:22.720
展开过后

39:22.720 --> 39:23.720
然后再把id放进去

39:23.720 --> 39:24.720
对吧

39:24.720 --> 39:25.720
再把id放进去

39:25.720 --> 39:26.720
对不对

39:26.720 --> 39:27.720
就这样子写呗

39:27.720 --> 39:28.720
payload

39:28.720 --> 39:29.720
那么这样子

39:29.720 --> 39:30.720
它既包含了新的用户数据

39:30.720 --> 39:31.720
又包含这个id

39:31.720 --> 39:32.720
对吧

39:32.720 --> 39:33.720
我们把它一起

39:33.720 --> 39:34.720
放到payload里面

39:34.720 --> 39:35.720
对吧

39:35.720 --> 39:36.720
我们就把x型写完了

39:36.720 --> 39:37.720
好好看一下

39:37.720 --> 39:38.720
现在不要去管合并

39:38.720 --> 39:39.720
虽然说我们说

39:39.720 --> 39:42.720
只能有一个reducer

39:42.720 --> 39:43.720
但是现在不要去管合并

39:43.720 --> 39:44.720
你看一下

39:44.720 --> 39:45.720
当前登录的用户

39:45.720 --> 39:46.720
是不是对一个reducer还说

39:46.720 --> 39:47.720
所有的用户

39:47.720 --> 39:48.720
是不是对一个reducer还说

39:48.720 --> 39:49.720
对吧

39:49.720 --> 39:50.720
我们现在先不要去管合并

39:50.720 --> 39:51.720
我们先把这个x型

39:51.720 --> 39:52.720
第二个x型

39:52.720 --> 39:53.720
就第二个就是

39:53.720 --> 39:54.720
操作的x型写好

39:54.720 --> 39:56.720
那么到reducer这边来

39:56.720 --> 39:58.720
我们是不是在优热室里边

39:58.720 --> 39:59.720
就可以用了

39:59.720 --> 40:00.720
对不对

40:00.720 --> 40:02.720
导致我们需要的东西

40:02.720 --> 40:03.720
from

40:04.720 --> 40:05.720
我们获得在这里

40:05.720 --> 40:06.720
用一个什么呢

40:06.720 --> 40:07.720
用一个信号吧

40:07.720 --> 40:08.720
而是

40:09.720 --> 40:11.720
usersx

40:11.720 --> 40:12.720
from

40:13.720 --> 40:14.720
x

40:14.720 --> 40:15.720
usersx

40:15.720 --> 40:16.720
那么现在

40:16.720 --> 40:17.720
我们写上一个reducer

40:18.720 --> 40:19.720
reducer

40:20.720 --> 40:21.720
初始数据是什么呢

40:21.720 --> 40:22.720
那么用户

40:22.720 --> 40:23.720
它是一个数组

40:23.720 --> 40:24.720
对不对

40:24.720 --> 40:25.720
用户它是一个数组

40:25.720 --> 40:26.720
那么初始数据

40:26.720 --> 40:28.720
自然而然是一个数组

40:28.720 --> 40:29.720
这是它初始数据

40:29.720 --> 40:30.720
那么这里的

40:30.720 --> 40:31.720
副字为初始数据

40:31.720 --> 40:32.720
对吧

40:32.720 --> 40:34.720
那么typepano的人过来

40:34.720 --> 40:35.720
来吧

40:35.720 --> 40:36.720
一个个判断

40:36.720 --> 40:37.720
首先是type值

40:37.720 --> 40:38.720
如果说它等于

40:38.720 --> 40:39.720
因为在这里边

40:39.720 --> 40:40.720
就那么几个操作类型

40:40.720 --> 40:41.720
来看一下吧

40:41.720 --> 40:42.720
添加用户

40:42.720 --> 40:44.720
如果你是添加一个用户的话

40:44.720 --> 40:45.720
那或者说

40:45.720 --> 40:46.720
我们这里初始

40:46.720 --> 40:47.720
初始化几个用户

40:47.720 --> 40:48.720
初始化几个用户

40:49.720 --> 40:50.720
用户的id

40:50.720 --> 40:51.720
我们可以利用那个

40:51.720 --> 40:52.720
我们之前学过的一个cool

40:52.720 --> 40:53.720
叫做uid

40:54.720 --> 40:55.720
uid

40:55.720 --> 40:56.720
from

40:56.720 --> 40:57.720
uid

40:58.720 --> 41:00.720
安装这个cool的吧

41:00.720 --> 41:02.720
我记得我安装了这个cool的

41:02.720 --> 41:03.720
我看一下

41:03.720 --> 41:05.720
我这个拍个几年节省里边

41:05.720 --> 41:07.720
有没有安装这个uid的cool

41:07.720 --> 41:09.720
那我之前没从master里面

41:09.720 --> 41:10.720
打过出来

41:10.720 --> 41:11.720
安装一下吧

41:11.720 --> 41:12.720
安装一下

41:12.720 --> 41:15.990
停止

41:17.990 --> 41:19.990
要add uuid

41:19.990 --> 41:20.990
安装一下

41:20.990 --> 41:21.990
这个可以方便

41:21.990 --> 41:22.990
可以非常方便的

41:22.990 --> 41:23.990
生成一个唯一的id

41:23.990 --> 41:25.990
关上让它安装就行了

41:25.990 --> 41:26.990
好

41:26.990 --> 41:27.990
然后这里边

41:27.990 --> 41:28.990
我们写上一个初始状态

41:28.990 --> 41:29.990
uid

41:30.990 --> 41:31.990
然后呢

41:31.990 --> 41:32.990
姓名

41:32.990 --> 41:34.990
就是用户1

41:35.990 --> 41:37.990
然后的话

41:37.990 --> 41:38.990
比方说年龄

41:39.990 --> 41:40.990
随便吧

41:40.990 --> 41:41.990
就随便写几个

41:41.990 --> 41:42.990
随便写几个

41:48.900 --> 41:49.900
这是一个用户了

41:49.900 --> 41:50.900
对吧

41:50.900 --> 41:51.900
再来一个

41:52.900 --> 41:53.900
uid用户2

41:54.900 --> 41:58.980
这里是用户2

41:58.980 --> 41:59.980
用户2

41:59.980 --> 42:00.980
年龄12

42:00.980 --> 42:04.440
行了

42:05.440 --> 42:06.440
这怎么了

42:07.440 --> 42:08.440
他又告诉我不能

42:08.440 --> 42:09.440
重新打开

42:09.440 --> 42:12.010
OK

42:13.010 --> 42:14.010
好

42:14.010 --> 42:15.010
那么这里呢

42:15.010 --> 42:16.010
初始状态就有两个用户

42:16.010 --> 42:17.010
就两个用户

42:17.010 --> 42:18.010
就个例子

42:18.010 --> 42:19.010
然后如果说

42:19.010 --> 42:20.010
你要做添加用户的话

42:20.010 --> 42:21.010
那么

42:21.010 --> 42:23.010
到时候你是不是要得到

42:23.010 --> 42:24.010
要给我一个新的用户进来

42:24.010 --> 42:25.010
那我怎么办

42:25.010 --> 42:26.010
怎么办

42:27.010 --> 42:28.010
怎么办

42:28.010 --> 42:29.010
是不是

42:29.010 --> 42:30.010
你不能去改动

42:30.010 --> 42:32.010
你千万不能去这样子写

42:32.010 --> 42:33.010
你看着

42:33.010 --> 42:35.010
你能不能把status

42:35.010 --> 42:36.010
铺写

42:36.010 --> 42:37.010
铺写什么payload

42:37.010 --> 42:38.010
你把新用户添加进去

42:38.010 --> 42:39.010
能不能这样子

42:39.010 --> 42:40.010
这样子就改动了

42:40.010 --> 42:41.010
原用的东西了

42:41.010 --> 42:42.010
千万不能这样子做

42:42.010 --> 42:44.010
原用的状态是不能发生改变的

42:45.010 --> 42:47.010
你应该返回一个新宿主

42:47.010 --> 42:49.010
把原宿主展开呗

42:49.010 --> 42:51.010
然后再加一项payload

42:51.010 --> 42:53.010
这种写法一定要回

42:53.010 --> 42:54.010
一定要回

42:54.010 --> 42:55.010
千万不能对他做任何改动

42:55.010 --> 42:57.010
一定要产生一个新的东西

42:57.010 --> 42:58.010
或者说用什么呢

42:58.010 --> 42:59.010
或者说用status

42:59.010 --> 43:00.010
concast

43:00.010 --> 43:01.010
对吧

43:01.010 --> 43:02.010
连接

43:02.010 --> 43:03.010
连接

43:03.010 --> 43:04.010
连接payload

43:04.010 --> 43:05.010
对吧

43:05.010 --> 43:06.010
这样子也行

43:06.010 --> 43:07.010
因为它

43:07.010 --> 43:08.010
这个concast寒书

43:08.010 --> 43:10.010
它不会改变原用的宿主

43:10.010 --> 43:11.010
都行

43:11.010 --> 43:12.010
总之

43:12.010 --> 43:13.010
你不能改动原用的东西

43:13.010 --> 43:15.010
你只能返回新的东西

43:15.010 --> 43:16.010
payload

43:16.010 --> 43:18.010
那么这是添加用户

43:18.010 --> 43:19.010
来吧

43:19.010 --> 43:20.010
然后还有什么

43:20.010 --> 43:21.010
还有什么

43:21.010 --> 43:23.010
删除用户

43:23.010 --> 43:24.010
dnx有这

43:24.010 --> 43:26.010
删除用户

43:27.010 --> 43:29.010
删除用户的话

43:30.010 --> 43:31.010
那么删除用户的话

43:31.010 --> 43:33.010
你是不是要给我一个用户

43:33.010 --> 43:34.010
给的是啥

43:34.010 --> 43:35.010
是不是给的用户id

43:35.010 --> 43:36.010
对不对

43:36.010 --> 43:37.010
这是咱们约定好的

43:37.010 --> 43:38.010
删除

43:38.010 --> 43:40.010
创建一个删除用户的x

43:40.010 --> 43:41.010
是不是要给一个id

43:41.010 --> 43:42.010
对不对

43:42.010 --> 43:43.010
那么到时候

43:43.010 --> 43:44.010
你会给我一个

43:44.010 --> 43:46.010
在payload里边给我一个id

43:46.010 --> 43:47.010
那么这个id

43:47.010 --> 43:48.010
我们是不是用id去删

43:48.010 --> 43:49.010
那怎么删呢

43:50.010 --> 43:52.010
你不要给我来这个东西

43:52.010 --> 43:53.010
你不要给我什么得到下标

43:53.010 --> 43:54.010
来这个东西

43:54.010 --> 43:55.010
别来了

43:55.010 --> 43:56.010
不要来这个玩意了

43:56.010 --> 43:57.010
因为这个东西

43:57.010 --> 43:58.010
会改变原宿主

43:58.010 --> 43:59.010
一定不能改变原宿主

43:59.010 --> 44:00.010
那么怎么来删呢

44:00.010 --> 44:02.010
你看着这样子写

44:02.010 --> 44:03.010
field

44:04.010 --> 44:07.010
id不等于

44:07.010 --> 44:09.010
x的payload

44:09.010 --> 44:11.010
就是不等于payload的

44:11.010 --> 44:12.010
对吧

44:12.010 --> 44:13.010
你这样的写

44:13.010 --> 44:14.010
能理解吗

44:14.010 --> 44:16.010
就是从这个宿主里面去筛选

44:16.010 --> 44:17.010
筛选什么

44:17.010 --> 44:18.010
你不是要筛一个id吗

44:18.010 --> 44:19.010
你把id传给我

44:19.010 --> 44:20.010
传给我过后

44:20.010 --> 44:21.010
就再通过这个东西传给我了

44:21.010 --> 44:22.010
对吧

44:22.010 --> 44:24.010
那么传给我这个id过后

44:24.010 --> 44:25.010
我来去找到

44:25.010 --> 44:27.010
id不等于这个id

44:27.010 --> 44:28.010
得到一个新宿主

44:28.010 --> 44:29.010
把新宿主换回

44:29.010 --> 44:31.010
那么就相当于就删掉了

44:31.010 --> 44:32.010
比方说

44:32.010 --> 44:34.010
以前的宿主里面

44:34.010 --> 44:35.010
比方说id

44:35.010 --> 44:36.010
我只记住id

44:36.010 --> 44:38.010
有1 2 3 4 5

44:38.010 --> 44:39.010
这样的一些数据

44:39.010 --> 44:41.010
那么你给了我一个id等于3

44:41.010 --> 44:42.010
那么我得到数据

44:42.010 --> 44:44.010
是不是1 2 4 5

44:44.010 --> 44:45.010
对不对

44:45.010 --> 44:46.010
得到的数据是不是这个

44:46.010 --> 44:47.010
对吧

44:47.010 --> 44:48.010
那么我们是不是

44:48.010 --> 44:49.010
删选的时候

44:49.010 --> 44:50.010
id不等于这个了

44:50.010 --> 44:51.010
是不是拿出来

44:51.010 --> 44:52.010
这是删除用户

44:52.010 --> 44:53.010
这样子写

44:53.010 --> 44:54.010
然后User Action

44:54.010 --> 44:56.010
如果是updates user

44:56.010 --> 44:58.010
修改用户了

44:58.010 --> 45:00.010
对吧

45:00.010 --> 45:02.010
修改用户怎么写

45:02.010 --> 45:04.010
修改用户

45:04.010 --> 45:06.010
这个大家要想一想

45:06.010 --> 45:08.010
想想修改用户咋写

45:08.010 --> 45:09.010
修改用户的话

45:09.010 --> 45:11.010
你可以用这样的方式来操作

45:11.010 --> 45:13.010
你看一下它的原理是什么

45:13.010 --> 45:14.010
就咱们宿主里面

45:14.010 --> 45:16.010
它是有一个一个的用户对象

45:16.010 --> 45:17.010
对不对

45:17.010 --> 45:19.010
有一个一个的用户对象

45:19.010 --> 45:21.010
那么每个用户对象里面有一个id

45:21.010 --> 45:22.010
那么你现在修改用户

45:22.010 --> 45:24.010
是不是要比方说

45:24.010 --> 45:25.010
我们给的

45:25.010 --> 45:27.010
给的一个新的用户对象

45:27.010 --> 45:29.010
id等于3

45:29.010 --> 45:30.010
其他属性

45:30.010 --> 45:31.010
对吧

45:31.010 --> 45:32.010
我们是不是要用通过这个id

45:32.010 --> 45:34.010
去匹配到一个用户对吧

45:34.010 --> 45:35.010
比方匹配到它

45:35.010 --> 45:38.010
那么是不是把它替换成一个新的对象

45:38.010 --> 45:39.010
对不对

45:39.010 --> 45:40.010
你不能去改动这个对象

45:40.010 --> 45:41.010
千万不能做任何改动

45:41.010 --> 45:43.010
不能对原有数据做任何改动

45:43.010 --> 45:45.010
一定要去给得到一个新的对象

45:45.010 --> 45:46.010
其实我给大家介绍一下

45:46.010 --> 45:48.010
虽然说我们这门客不涉及

45:48.010 --> 45:50.010
叫做Inmartable

45:50.010 --> 45:52.010
第二介事

45:52.010 --> 45:53.010
这是一个介事

45:53.010 --> 45:54.010
第三方介事库

45:54.010 --> 45:56.010
它专门就用来处理这样的问题

45:56.010 --> 45:58.010
对象一旦创建就不能改变了

45:58.010 --> 46:00.010
一改变它要包错

46:00.010 --> 46:02.010
为了防止你犯错

46:02.010 --> 46:03.010
这个介事

46:03.010 --> 46:05.010
它就是可以得到那些

46:05.010 --> 46:06.010
不能改变的对象

46:06.010 --> 46:07.010
你要对对象做任何更改

46:07.010 --> 46:09.010
你可以用这个库里面的方法

46:09.010 --> 46:10.010
它可以帮你更改对象

46:10.010 --> 46:12.010
它永远都是产生新的东西来替换

46:12.010 --> 46:13.010
好

46:13.010 --> 46:14.010
那么现在我们这里

46:14.010 --> 46:15.010
其实怎么处理呢

46:15.010 --> 46:16.010
也很简单

46:16.010 --> 46:17.010
怎么处理呢

46:17.010 --> 46:19.010
我们可以使用Map

46:21.010 --> 46:22.010
Map

46:22.010 --> 46:25.220
Map里面

46:25.220 --> 46:26.220
我们可以这样来写吧

46:26.220 --> 46:27.220
这样来写

46:27.220 --> 46:29.220
如果说你这个对象

46:29.220 --> 46:30.220
一个全部拿出来

46:30.220 --> 46:32.220
数组里面全部拿出来来映射

46:32.220 --> 46:33.220
如果说你这个对象

46:33.220 --> 46:35.220
ID等于了

46:35.220 --> 46:36.220
什么呢

46:36.220 --> 46:37.220
Payload对吧

46:37.220 --> 46:39.220
是不是我们要改Payload.id

46:39.220 --> 46:41.220
因为这里Payload是一个对象

46:41.220 --> 46:42.220
看一下

46:42.220 --> 46:43.220
我们创建一个用户的

46:43.220 --> 46:45.220
就是更新用户的

46:45.220 --> 46:46.220
一个型的时候

46:46.220 --> 46:48.220
那么这个返回的是一个对象

46:48.220 --> 46:49.220
Payload是一个对象

46:49.220 --> 46:50.220
它里面带了一个ID

46:50.220 --> 46:52.220
这个ID就是你要改变的

46:52.220 --> 46:54.220
就是你要改变的用户

46:54.220 --> 46:56.220
就是对应的ID

46:56.220 --> 46:58.220
那么如果说ID等于ID

46:58.220 --> 47:00.220
这个对象要被替换

47:00.220 --> 47:01.220
怎么替换呢

47:01.220 --> 47:02.220
替换成啥呢

47:02.220 --> 47:06.220
是不是替换成Payload

47:06.220 --> 47:07.220
对不对

47:07.220 --> 47:08.220
替换成Payload的

47:08.220 --> 47:10.220
Payload整个对象替换过去

47:10.220 --> 47:11.220
对吧

47:13.220 --> 47:16.220
如果不是呢

47:16.220 --> 47:18.220
如果不是呢

47:18.220 --> 47:19.220
那你是不是要把

47:19.220 --> 47:21.220
原的对象返回

47:21.220 --> 47:22.220
对不对

47:22.220 --> 47:23.220
就这样子写就完了

47:23.220 --> 47:24.220
你看一下吧

47:24.220 --> 47:25.220
如果两个ID一样

47:25.220 --> 47:27.220
那么这个我们是不是要替换

47:27.220 --> 47:28.220
替换成什么

47:28.220 --> 47:29.220
替换成Payload的

47:29.220 --> 47:30.220
替换成这个新的对象

47:30.220 --> 47:31.220
新的用户对象

47:31.220 --> 47:32.220
否则的话

47:32.220 --> 47:33.220
我们就替换原的

47:33.220 --> 47:35.220
就是直接用原的对象

47:35.220 --> 47:36.220
对吧

47:36.220 --> 47:37.220
总之你不能对原的对象

47:37.220 --> 47:38.220
都做改动

47:38.220 --> 47:39.220
就完了

47:39.220 --> 47:40.220
你不能做改动

47:40.220 --> 47:42.220
就用硬设来搞定

47:42.220 --> 47:43.220
硬设来搞定修改

47:43.220 --> 47:44.220
对吧

47:44.220 --> 47:45.220
那么现在呢

47:45.220 --> 47:47.220
这个

47:47.220 --> 47:48.220
Reduce是不搞定的

47:48.220 --> 47:49.220
所有用户的Reduce

47:49.220 --> 47:50.220
是不搞定的

47:50.220 --> 47:51.220
对不对

47:51.220 --> 47:53.220
当然我们这里讲的呢

47:53.220 --> 47:54.220
不是说怎么去合并

47:54.220 --> 47:55.220
我们还没有讲合并

47:55.220 --> 47:57.220
我们只是通过这个例子

47:57.220 --> 47:58.220
顺便就说一下

47:58.220 --> 47:59.220
遇到这些常见的场景

47:59.220 --> 48:00.220
该怎么去处理

48:00.220 --> 48:01.220
一定得会写

48:01.220 --> 48:02.220
三处该怎么写

48:02.220 --> 48:04.220
修改该怎么写

48:04.220 --> 48:05.220
那比方说

48:05.220 --> 48:06.220
那比方说

48:06.220 --> 48:07.220
这个东西可以

48:07.220 --> 48:08.220
就是可以灵活运用的

48:08.220 --> 48:09.220
比方说

48:09.220 --> 48:10.220
我们到时候

48:10.220 --> 48:11.220
这个留有Zeta

48:11.220 --> 48:12.220
它可能会要求你

48:12.220 --> 48:13.220
它可能会要求说

48:13.220 --> 48:15.220
我到时候可能只改变新名

48:15.220 --> 48:16.220
不一定改变年龄

48:16.220 --> 48:17.220
我只传了个新名进来

48:17.220 --> 48:18.220
比方这个Payload

48:18.220 --> 48:19.220
到时候是这样子写的

48:19.220 --> 48:20.220
这个Payload

48:20.220 --> 48:21.220
可能是这样子

48:21.220 --> 48:24.920
ID等于3

48:24.920 --> 48:26.920
Name等于ABC

48:26.920 --> 48:27.920
比方说

48:27.920 --> 48:28.920
它可能是这样子

48:28.920 --> 48:29.920
它没有连零

48:29.920 --> 48:30.920
那你这样子

48:30.920 --> 48:31.920
是不是把连零数据丢失了

48:31.920 --> 48:32.920
但是你又不希望丢失

48:32.920 --> 48:33.920
就是我不改变年龄

48:33.920 --> 48:34.920
我只改变新名

48:34.920 --> 48:35.920
那怎么办呢

48:35.920 --> 48:36.920
那这个位置

48:36.920 --> 48:37.920
是不是又可以进行

48:37.920 --> 48:39.920
混合对象混合

48:39.920 --> 48:40.920
对象混合的方式

48:40.920 --> 48:41.920
大家一定要会

48:41.920 --> 48:42.920
一定要会

48:42.920 --> 48:43.920
就是先把它之前展开

48:43.920 --> 48:45.920
然后再把Payload展开

48:45.920 --> 48:46.920
对不对

48:46.920 --> 48:48.920
通过这样的方式来进行混合

48:48.920 --> 48:49.920
把之前的对象的

48:49.920 --> 48:50.920
所有属性展开

48:50.920 --> 48:51.920
然后再把Payload展开

48:51.920 --> 48:53.920
把Payload的东西混合进去

48:53.920 --> 48:54.920
对吧

48:54.920 --> 48:55.920
一定的会写

48:55.920 --> 48:56.920
就是各种场景的

48:56.920 --> 48:58.920
你得知道该怎么去处理

48:58.920 --> 48:59.920
终止一句话

48:59.920 --> 49:01.920
你不能改变原来的对象

49:01.920 --> 49:02.920
你自己以后想办法

49:02.920 --> 49:03.920
想办法就是

49:03.920 --> 49:04.920
不改变

49:04.920 --> 49:06.920
原来对象的基础上

49:06.920 --> 49:07.920
得到一个新的数据

49:07.920 --> 49:08.920
你看这里返回

49:08.920 --> 49:09.920
是有一个新的数据

49:09.920 --> 49:11.920
然后数据的某一项

49:11.920 --> 49:13.920
是不是得到的是一个新的对象

49:13.920 --> 49:14.920
对吧

49:14.920 --> 49:16.920
总之不能改变原来的东西

49:16.920 --> 49:17.920
OK就写好了

49:17.920 --> 49:18.920
那么现在呢

49:18.920 --> 49:19.920
我们就形成了两个reducer

49:19.920 --> 49:20.920
再看一下

49:20.920 --> 49:22.920
如果说你把它分开看的话

49:22.920 --> 49:23.920
User.js

49:23.920 --> 49:25.920
它里面导出一个reducer

49:25.920 --> 49:26.920
Nokin.js

49:26.920 --> 49:28.920
Nokin.js导出一个reducer

49:28.920 --> 49:29.920
对吧

49:29.920 --> 49:30.920
但是你分开看的话

49:30.920 --> 49:31.920
你是很好理解的

49:31.920 --> 49:32.920
User.js就是个reducer

49:32.920 --> 49:33.920
然后呢

49:33.920 --> 49:34.920
它对你的Action在这边

49:34.920 --> 49:35.920
对吧

49:35.920 --> 49:36.920
然后呢

49:36.920 --> 49:37.920
Nokin.js有个reducer

49:37.920 --> 49:38.920
它对你的Action在这边

49:38.920 --> 49:39.920
对吧

49:39.920 --> 49:40.920
在这边

49:40.920 --> 49:41.920
但是

49:42.920 --> 49:43.920
因为DUX

49:43.920 --> 49:44.920
它可不管那么多

49:44.920 --> 49:46.920
它管你这些了

49:46.920 --> 49:47.920
我们刚才之前怎么说的

49:47.920 --> 49:48.920
因为DUX

49:48.920 --> 49:49.920
它只有一个reducer

49:49.920 --> 49:50.920
非常简单

49:50.920 --> 49:51.920
尤其是只有一个reducer

49:51.920 --> 49:52.920
因此呢

49:52.920 --> 49:55.920
你是不是得合并一下呀

49:55.920 --> 49:57.920
你再写这么一个reducer出来

49:57.920 --> 49:58.920
啊

49:58.920 --> 50:00.920
你再写这么一个reducer出来

50:00.920 --> 50:01.920
啊

50:01.920 --> 50:03.920
把这两个reducer合并一下

50:03.920 --> 50:04.920
啊

50:04.920 --> 50:05.920
合并一下

50:05.920 --> 50:06.920
形成一个reducer

50:06.920 --> 50:07.920
那么Reducer里边

50:07.920 --> 50:08.920
它只能用

50:08.920 --> 50:09.920
Reducer里边

50:09.920 --> 50:10.920
它只能用这个reducer

50:10.920 --> 50:11.920
因为倒是只能用一个

50:11.920 --> 50:12.920
因此呢

50:12.920 --> 50:13.920
在index.js里边

50:13.920 --> 50:14.920
我们在这里

50:14.920 --> 50:15.920
就可以进行合并

50:15.920 --> 50:17.920
你看一下我们怎么合并

50:17.920 --> 50:18.920
Import

50:18.920 --> 50:19.920
导入什么呢

50:19.920 --> 50:20.920
导入那个

50:20.920 --> 50:22.920
locking user

50:22.920 --> 50:23.920
from

50:23.920 --> 50:24.920
点儿鞋杠

50:24.920 --> 50:28.230
嗯

50:28.230 --> 50:30.230
locking user

50:30.230 --> 50:31.230
Import

50:31.230 --> 50:32.230
啊

50:32.230 --> 50:33.230
这样子嘛

50:33.230 --> 50:34.230
减一些啊

50:34.230 --> 50:35.230
这个是

50:35.230 --> 50:37.230
点儿鞋杠

50:37.230 --> 50:39.230
User

50:39.230 --> 50:40.230
User

50:40.230 --> 50:42.230
导入这两个reducer

50:42.230 --> 50:43.230
对吧

50:43.230 --> 50:44.230
把它进行合并

50:44.230 --> 50:45.230
那么这里块

50:45.230 --> 50:46.230
我们导出一个

50:46.230 --> 50:47.230
合并之后的函数

50:47.230 --> 50:49.230
合并之后的函数

50:49.230 --> 50:50.230
我们这里

50:50.230 --> 50:52.230
这个是reducer

50:52.230 --> 50:53.230
初始值是什么呢

50:53.230 --> 50:55.230
由于我们这里有两个reducer

50:55.230 --> 50:56.230
他们要管理各自的数据

50:56.230 --> 50:57.230
对吧

50:57.230 --> 50:58.230
这有两个reducer

50:58.230 --> 50:59.230
要管理各自的数据

50:59.230 --> 51:00.230
那么初始值的话

51:00.230 --> 51:02.230
我们是不是要形成一个对象

51:02.230 --> 51:04.230
一个对象对应一块数据

51:04.230 --> 51:05.230
一个对象对应一块数据

51:05.230 --> 51:06.230
对吧

51:06.230 --> 51:07.230
因为这里有两个reducer

51:07.230 --> 51:08.230
他们各自管理各自的数据

51:08.230 --> 51:09.230
这里

51:09.230 --> 51:11.230
这里的reducer管理的是一个对象

51:11.230 --> 51:12.230
这里的reducer

51:12.230 --> 51:13.230
管理的是一个数组

51:13.230 --> 51:14.230
对不对

51:14.230 --> 51:15.230
那我们这里呢

51:15.230 --> 51:16.230
是不是要写个初始值

51:16.230 --> 51:17.230
是不是有两个

51:17.230 --> 51:19.230
是不是得有两个啊

51:19.230 --> 51:20.230
对不对

51:20.230 --> 51:21.230
哪两个初始值

51:21.230 --> 51:22.230
初始值是不是两个属性

51:22.230 --> 51:24.230
一个是当前登录的用户

51:24.230 --> 51:25.230
罗景优热

51:25.230 --> 51:27.230
当前登录的用户

51:27.230 --> 51:28.230
默认之为闹嘛

51:28.230 --> 51:29.230
默认之为闹

51:29.230 --> 51:30.230
啥都没有

51:30.230 --> 51:31.230
然后呢

51:31.230 --> 51:33.230
所有的用户

51:33.230 --> 51:34.230
优热

51:34.230 --> 51:35.230
对不对

51:35.230 --> 51:36.230
也没有

51:36.230 --> 51:38.230
我哪能给他默认值的

51:38.230 --> 51:39.230
哪能给他默认值的

51:39.230 --> 51:40.230
全部都没有

51:40.230 --> 51:41.230
没有默认值

51:41.230 --> 51:42.230
这是一条State

51:42.230 --> 51:43.230
对吧

51:43.230 --> 51:44.230
好

51:44.230 --> 51:45.230
总之我们形成这么一个对象

51:45.230 --> 51:46.230
形成这么一个对象

51:46.230 --> 51:48.230
它里面有两个数据

51:49.230 --> 51:50.230
好

51:50.230 --> 51:51.230
那么这里导出来就是一个

51:51.230 --> 51:52.230
导出来的是啥呢

51:52.230 --> 51:53.230
这里就是x

51:53.230 --> 51:55.230
我们这里换两x

51:55.230 --> 51:57.230
导出来的就是一个

51:57.230 --> 51:58.230
统一的Reducer

51:58.230 --> 51:59.230
也就是仓库里面

51:59.230 --> 52:00.230
要用那个Reducer

52:00.230 --> 52:02.230
仓库一旦Dispatch

52:02.230 --> 52:03.230
一旦触发一个x

52:03.230 --> 52:04.230
它就会运行

52:04.230 --> 52:07.230
运行的是这个Reducer函数

52:07.230 --> 52:08.230
那么这个Reducer函数

52:08.230 --> 52:09.230
怎么处理呢

52:09.230 --> 52:11.230
你看我们这样子处理

52:12.230 --> 52:13.230
NewState

52:13.230 --> 52:14.230
一个新的状态

52:14.230 --> 52:15.230
因为我们最终

52:15.230 --> 52:16.230
会返回新的状态

52:16.230 --> 52:17.230
我给他一个空对象

52:17.230 --> 52:18.230
我给他一个空对象

52:20.230 --> 52:21.230
由于每一次运行Reducer

52:21.230 --> 52:23.230
是不是得到一个新的对象

52:23.230 --> 52:24.230
对吧

52:24.230 --> 52:25.230
是不是得到一个新的对象

52:25.230 --> 52:26.230
因此它根源

52:26.230 --> 52:27.230
它不会影响原来的对象

52:27.230 --> 52:29.230
它就得到的是新的对象

52:29.230 --> 52:30.230
NewState

52:30.230 --> 52:32.230
最后返回新的对象

52:32.230 --> 52:33.230
那么新的对象里面

52:33.230 --> 52:34.230
也不是有很多数据吗

52:34.230 --> 52:36.230
这些数据不是我管理的

52:36.230 --> 52:37.230
是别人管理的

52:37.230 --> 52:38.230
行

52:38.230 --> 52:39.230
行

52:39.230 --> 52:40.230
那我这样吧

52:40.230 --> 52:41.230
NewState里面

52:41.230 --> 52:42.230
怎么Lock in user

52:42.230 --> 52:43.230
Lock in user

52:43.230 --> 52:45.230
或者说我们这样子写

52:45.230 --> 52:46.230
NewState

52:47.230 --> 52:49.540
Lock in user

52:49.540 --> 52:50.540
Lock in user

52:50.540 --> 52:51.540
等于什么呢

52:51.540 --> 52:54.540
我觉得这不用这个初始词了

52:54.540 --> 52:55.540
初始都没必要用了

52:55.540 --> 52:56.540
因为反正每次我得到的是

52:56.540 --> 52:57.540
一个新的对象

52:57.540 --> 52:58.540
对吧

52:58.540 --> 52:59.540
每次都得到的是一个新的对象

53:00.540 --> 53:01.540
Lock in user

53:01.540 --> 53:02.540
等于什么呢

53:02.540 --> 53:03.540
来自于

53:04.540 --> 53:05.540
Lock in

53:05.540 --> 53:06.540
调用Lock in

53:06.540 --> 53:07.540
Lock in user

53:07.540 --> 53:08.540
这个函数

53:08.540 --> 53:09.540
调用Lock in user

53:09.540 --> 53:10.540
这个函数

53:10.540 --> 53:11.540
调用这个函数

53:11.540 --> 53:12.540
把State传进去

53:12.540 --> 53:13.540
把X型传进去

53:13.540 --> 53:15.540
把State里面哪个传进去

53:15.540 --> 53:16.540
把State里面

53:16.540 --> 53:17.540
Lock in user

53:17.540 --> 53:18.540
传进去

53:19.540 --> 53:20.540
然后呢

53:21.540 --> 53:22.540
User

53:23.540 --> 53:24.540
调用User这个函数

53:24.540 --> 53:25.540
把State

53:26.540 --> 53:27.540
User传进去

53:27.540 --> 53:28.540
把X型

53:30.540 --> 53:31.540
看不懂这是什么意思

53:31.540 --> 53:32.540
就这一块比较糟

53:32.540 --> 53:33.540
就这一块比较糟

53:34.540 --> 53:35.540
看着

53:35.540 --> 53:36.540
这里管理的是什么

53:36.540 --> 53:37.540
是不是管理到一个对象

53:37.540 --> 53:38.540
对吧

53:38.540 --> 53:39.540
这里管理的是一个数组

53:39.540 --> 53:40.540
他们各自管理

53:40.540 --> 53:41.540
各自的互不干擾

53:41.540 --> 53:43.540
然后我们现在要写一个

53:43.540 --> 53:44.540
统一的reducer

53:44.540 --> 53:45.540
把它合并起来

53:45.540 --> 53:47.540
那么合并是不是有两块数据

53:47.540 --> 53:48.540
对吧

53:48.540 --> 53:49.540
是不是有两块数据

53:49.540 --> 53:50.540
对不对

53:50.540 --> 53:51.540
一个是当前的Lock用户

53:51.540 --> 53:52.540
一个是所有用户

53:52.540 --> 53:53.540
他们是各自的reducer在管理

53:53.540 --> 53:54.540
对不对

53:54.540 --> 53:56.540
我这里只是把它合并一下

53:56.540 --> 53:57.540
那么这里的数据

53:57.540 --> 53:58.540
这个reducer

53:58.540 --> 53:59.540
那么统一的reducer

53:59.540 --> 54:00.540
管理的数据

54:00.540 --> 54:02.540
它管理的是一个整体的数据

54:02.540 --> 54:03.540
对吧

54:03.540 --> 54:04.540
管理的是一个整体的数据

54:04.540 --> 54:05.540
那么整体的数据的话

54:05.540 --> 54:07.540
我们可以用一个对象来表示

54:08.540 --> 54:09.540
这就是为什么我这里

54:09.540 --> 54:10.540
要写对象

54:10.540 --> 54:11.540
它管理的整体数据

54:11.540 --> 54:12.540
是一个对象

54:12.540 --> 54:13.540
这个对象里面

54:13.540 --> 54:14.540
我们规定

54:14.540 --> 54:15.540
有两个属性

54:15.540 --> 54:16.540
一个属性叫做Lock用户

54:16.540 --> 54:18.540
但那个属性名字的随便规定

54:18.540 --> 54:19.540
你想的那规定

54:19.540 --> 54:20.540
你抓规定

54:20.540 --> 54:21.540
它有两个属性

54:21.540 --> 54:22.540
一个属性是Lock用户

54:22.540 --> 54:24.540
一个属性是reducer

54:24.540 --> 54:25.540
这两个属性

54:25.540 --> 54:27.540
分别交给这两个reducer来管理

54:28.540 --> 54:31.540
凡是要触发数据变化的话

54:31.540 --> 54:33.540
也要触发数据变化

54:33.540 --> 54:35.540
那么我自己控制不了

54:35.540 --> 54:36.540
这个数据怎么变

54:36.540 --> 54:37.540
我怎么办呢

54:37.540 --> 54:38.540
我调用

54:38.540 --> 54:40.540
你看我怎么写的

54:40.540 --> 54:42.540
调用这个Lock用户

54:42.540 --> 54:43.540
调用这个reducer

54:43.540 --> 54:44.540
它不是可以管理数据吗

54:44.540 --> 54:45.540
它管理的是这一块数据

54:45.540 --> 54:46.540
对吧

54:46.540 --> 54:48.540
那么我调用这个Lock用户

54:48.540 --> 54:50.540
我把我状态里边

54:50.540 --> 54:51.540
你看整个是不是状态

54:51.540 --> 54:52.540
对吧

54:52.540 --> 54:53.540
这是我管理的状态

54:53.540 --> 54:55.540
那么我把我当前状态里边的Lock用户

54:55.540 --> 54:56.540
由着传给你

54:56.540 --> 54:57.540
我只把Lock用户

54:57.540 --> 54:59.540
因为它管理的只有这一块

54:59.540 --> 55:00.540
对不对

55:00.540 --> 55:01.540
我不能把整个状态传给你

55:01.540 --> 55:02.540
这里为什么要写这个

55:02.540 --> 55:04.540
因为我不能把整个状态传给你

55:04.540 --> 55:05.540
为什么不能传给你呢

55:05.540 --> 55:06.540
因为我整个状态

55:06.540 --> 55:07.540
是这样的一种结构

55:08.540 --> 55:09.540
因为整个状态

55:09.540 --> 55:10.540
它是有多个数据的

55:10.540 --> 55:11.540
后面可能还有电影

55:11.540 --> 55:12.540
新闻这些东西

55:12.540 --> 55:13.540
还有多个数据

55:13.540 --> 55:15.540
我不能把整个状态传给你

55:15.540 --> 55:16.540
你管理的时候

55:16.540 --> 55:17.540
你不需要知道整个状态

55:17.540 --> 55:18.540
对吧

55:18.540 --> 55:20.540
你只需要知道

55:21.540 --> 55:23.540
只需要知道你那一部分的数据

55:23.540 --> 55:24.540
所以说我给你传的的是哪呢

55:24.540 --> 55:25.540
传的的是这个

55:27.540 --> 55:28.540
我给你传的的是这个

55:28.540 --> 55:30.540
State点Lock用户

55:30.540 --> 55:31.540
我给你传的的是这个玩意

55:31.540 --> 55:32.540
对不对

55:32.540 --> 55:33.540
好

55:33.540 --> 55:34.540
那么这里再把x

55:34.540 --> 55:35.540
有操作的x

55:35.540 --> 55:36.540
我要传给你

55:36.540 --> 55:37.540
对不对

55:37.540 --> 55:38.540
你看一下这个x

55:38.540 --> 55:39.540
你能不能操作

55:39.540 --> 55:40.540
如果说你

55:40.540 --> 55:41.540
有些人可能担心

55:41.540 --> 55:42.540
这个x

55:42.540 --> 55:43.540
如果说我是添加一个用户

55:43.540 --> 55:44.540
不是登录用户

55:44.540 --> 55:45.540
怎么办

55:45.540 --> 55:46.540
那没关系

55:46.540 --> 55:47.540
你这个x对他来说就是无效的

55:47.540 --> 55:48.540
无效的会怎么样

55:48.540 --> 55:49.540
会直接给你返回一个

55:49.540 --> 55:50.540
只就行了

55:50.540 --> 55:51.540
对吧

55:51.540 --> 55:52.540
远方不动的给你返回

55:52.540 --> 55:53.540
对不对

55:53.540 --> 55:54.540
你这个东西就是无效的

55:54.540 --> 55:56.540
对他来说就是无效的

55:56.540 --> 55:57.540
对不对

55:57.540 --> 55:59.540
那么U字也是一样的

55:59.540 --> 56:00.540
这一块数据

56:00.540 --> 56:01.540
我管理不了

56:01.540 --> 56:02.540
我只是来做一个合并

56:02.540 --> 56:03.540
我管理不了

56:03.540 --> 56:04.540
我交给你来管理

56:04.540 --> 56:05.540
你这个Reduce来管理

56:05.540 --> 56:06.540
看没

56:06.540 --> 56:08.540
交给你这个Reduce来管理

56:08.540 --> 56:10.540
我把我整个状态里面的U字

56:10.540 --> 56:11.540
传递给你

56:11.540 --> 56:14.540
OK你去管理这个东西

56:14.540 --> 56:16.540
有些人担心这个东西没有直

56:16.540 --> 56:17.540
这个U字没有直

56:17.540 --> 56:18.540
没有传递过去会不会导致问题

56:18.540 --> 56:19.540
不会

56:19.540 --> 56:21.540
因为这边有默认值

56:21.540 --> 56:23.540
如果你没有值的话

56:23.540 --> 56:24.540
给力的就是默认值

56:24.540 --> 56:27.880
这里

56:27.880 --> 56:28.880
你看一下

56:28.880 --> 56:29.880
是不是有默认值

56:29.880 --> 56:30.880
对吧

56:30.880 --> 56:31.880
这边有默认值

56:31.880 --> 56:32.880
怎么样

56:32.880 --> 56:34.880
如果说你这里传递的Undefend

56:34.880 --> 56:36.880
如果说你传递的Undefend

56:36.880 --> 56:37.880
那么

56:37.880 --> 56:38.880
到时候呢

56:38.880 --> 56:39.880
给力的就是默认值

56:39.880 --> 56:40.880
那么这里的State程度

56:40.880 --> 56:41.880
我可以给他个默认值

56:41.880 --> 56:42.880
给他个空对象

56:42.880 --> 56:43.880
空对象

56:43.880 --> 56:44.880
不然的话一开始

56:44.880 --> 56:45.880
最开始创建仓库的时候

56:45.880 --> 56:46.880
这个东西是Undefend的

56:46.880 --> 56:47.880
那这里是不是要爆错

56:47.880 --> 56:48.880
对吧

56:48.880 --> 56:49.880
这个东西是Undefend的

56:49.880 --> 56:50.880
那这里也要爆错

56:50.880 --> 56:51.880
得不到Undefend里面的东西

56:51.880 --> 56:52.880
那么他默认值是一个空对象

56:52.880 --> 56:53.880
啥都没有

56:53.880 --> 56:55.880
第一次出实化的时候呢

56:55.880 --> 56:57.880
我就调用这些来进行出实化

56:57.880 --> 56:58.880
对吧

56:58.880 --> 56:59.880
总之你给我什么X

56:59.880 --> 57:00.880
我就传递给这些东西来

57:00.880 --> 57:01.880
让他们去处理

57:01.880 --> 57:02.880
得到他们对应的数据

57:02.880 --> 57:03.880
放到这里边

57:04.880 --> 57:05.880
没问题吧

57:05.880 --> 57:07.880
好保存看一下

57:08.880 --> 57:09.880
看一下

57:10.880 --> 57:11.880
Colors Resolve

57:13.880 --> 57:14.880
哪里出了问题

57:16.880 --> 57:17.880
那再看一下

57:18.880 --> 57:19.880
再检查看一下

57:20.880 --> 57:28.730
他说Colors Resolve

57:28.730 --> 57:30.730
它是不能找到模块

57:30.730 --> 57:31.730
Number

57:31.730 --> 57:32.730
Action这个模块找不到

57:32.730 --> 57:33.730
在哪个地方

57:33.730 --> 57:34.730
在Redux

57:35.730 --> 57:36.730
Redux里边

57:37.730 --> 57:40.430
Redux里边

57:41.430 --> 57:42.430
这个地方没找到

57:42.430 --> 57:43.430
这个地方我已经删掉了

57:43.430 --> 57:44.430
对吧

57:44.430 --> 57:45.430
已经删掉了

57:45.430 --> 57:46.430
好没关系

57:47.430 --> 57:48.430
那么这里呢

57:48.430 --> 57:50.430
我们来看一下

57:50.430 --> 57:51.430
再看一下

57:51.430 --> 57:53.430
一开始的窗户状态是啥

57:54.430 --> 57:55.430
你看一下

57:55.430 --> 57:56.430
一开始窗户状态

57:56.430 --> 57:57.430
是不是Lockin U熱为NOW

57:57.430 --> 57:58.430
对不对

57:58.430 --> 57:59.430
整个窗户的状态

57:59.430 --> 58:00.430
里面包含了一个U热室

58:00.430 --> 58:01.430
对吧怎么来的

58:01.430 --> 58:02.430
因为你创建窗户的时候

58:02.430 --> 58:04.430
是不是运行的一次

58:04.430 --> 58:05.430
运行的一次这个

58:05.430 --> 58:06.430
看一下

58:06.430 --> 58:07.430
是不是运行的一次这个Redux

58:07.430 --> 58:08.430
不在这

58:09.430 --> 58:11.430
一开始创建窗户的时候

58:11.430 --> 58:13.430
是不是运行的一次这个Redux

58:13.430 --> 58:14.430
对吧

58:14.430 --> 58:15.430
就是个统一的Redux

58:15.430 --> 58:16.430
合并之后的Redux

58:17.430 --> 58:18.430
State X

58:18.430 --> 58:19.430
对吧

58:19.430 --> 58:20.430
你看一下

58:20.430 --> 58:21.430
打印出来

58:21.430 --> 58:22.430
State是不是一个空对象

58:22.430 --> 58:23.430
对吧

58:23.430 --> 58:24.430
一个空的对象

58:24.430 --> 58:25.430
然后X

58:25.430 --> 58:26.430
是不是一个初识化的X

58:26.430 --> 58:27.430
对吧

58:27.430 --> 58:28.430
它传的这个东西

58:28.430 --> 58:29.430
传的这个东西进来

58:29.430 --> 58:30.430
然后我们得到一个新的状态

58:30.430 --> 58:31.430
这个新的状态的话

58:31.430 --> 58:33.430
那么它哪一支有哪呢

58:33.430 --> 58:35.430
把Lockin U熱

58:35.430 --> 58:36.430
Lockin U熱是不是undefined

58:36.430 --> 58:37.430
对不对

58:37.430 --> 58:38.430
对不对

58:38.430 --> 58:39.430
是不是undefined

58:39.430 --> 58:40.430
你看吧

58:40.430 --> 58:41.430
这个对象里面是空的

58:41.430 --> 58:42.430
一开始

58:42.430 --> 58:44.430
X 远风不动的传给你

58:44.430 --> 58:45.430
X 远风不动的传给你

58:45.430 --> 58:46.430
那么这个X

58:46.430 --> 58:47.430
对于它来说是无效的

58:47.430 --> 58:48.430
那么就到了这个方法

58:48.430 --> 58:49.430
对吧

58:49.430 --> 58:50.430
雕用这个方法

58:50.430 --> 58:51.430
雕用这个方法

58:51.430 --> 58:52.430
它由于这个undefined

58:52.430 --> 58:53.430
它是不是使用它的默认值

58:53.430 --> 58:54.430
对不对

58:54.430 --> 58:55.430
返回一个

58:55.430 --> 58:56.430
于是

58:56.430 --> 58:57.430
由于它的Type值是无效的

58:57.430 --> 58:59.430
那么它返回了这个默认值

58:59.430 --> 59:00.430
于是

59:00.430 --> 59:01.430
这个东西就有默认值了

59:01.430 --> 59:02.430
有者是

59:02.430 --> 59:03.430
你看一下

59:03.430 --> 59:04.430
是不是也有默认值了

59:04.430 --> 59:05.430
同样的道理

59:05.430 --> 59:06.430
于是

59:06.430 --> 59:07.430
最开始是这个样子

59:07.430 --> 59:08.430
对吧

59:08.430 --> 59:09.430
最开始是这个样子

59:09.430 --> 59:10.430
那么现在

59:10.430 --> 59:11.430
长库的状态

59:11.430 --> 59:12.430
变成这个样子了

59:12.430 --> 59:13.430
比方说

59:13.430 --> 59:14.430
现在我们添加一个用户

59:14.430 --> 59:15.430
添加一个用户

59:17.430 --> 59:18.430
到这个index

59:19.430 --> 59:20.430
添加一个用户

59:20.430 --> 59:21.430
那么现在一开始

59:21.430 --> 59:22.430
用户有两个

59:22.430 --> 59:23.430
对不对

59:23.430 --> 59:24.430
有两个

59:24.430 --> 59:25.430
添加一个用户

59:26.430 --> 59:27.430
比方说

59:27.430 --> 59:28.430
我们这里

59:28.430 --> 59:29.430
Store

59:29.430 --> 59:30.430
Dispatch

59:30.430 --> 59:31.430
添加一个用户

59:31.430 --> 59:32.430
那么我们这里需要一个

59:32.430 --> 59:33.430
创建用户的

59:33.430 --> 59:34.430
创建添加用户的X

59:35.430 --> 59:36.430
From

59:36.430 --> 59:37.430
X

59:37.430 --> 59:39.430
就是

59:39.430 --> 59:40.430
UserX

59:40.430 --> 59:41.430
我们要

59:41.430 --> 59:42.430
添加一个用户

59:42.430 --> 59:43.430
AdD

59:43.430 --> 59:44.430
CreaseAdDUserX

59:44.430 --> 59:45.430
这里

59:45.430 --> 59:46.430
Crease

59:46.430 --> 59:47.430
AdDUserX

59:47.430 --> 59:48.430
那么这里

59:48.430 --> 59:49.430
要传一个用户对象

59:49.430 --> 59:50.430
进去

59:50.430 --> 59:51.430
传一个用户对象

59:51.430 --> 59:52.430
ind的话

59:52.430 --> 59:55.190
我们就用UuID

59:55.190 --> 59:56.190
UuID

59:56.190 --> 59:57.190
UuID

59:58.190 --> 59:59.190
ind的话

59:59.190 --> 01:00:00.190
UuID

01:00:00.190 --> 01:00:01.190
然后name

01:00:01.190 --> 01:00:02.190
ABC

01:00:03.190 --> 01:00:04.190
然后

01:00:04.190 --> 01:00:05.190
Aging

01:00:06.190 --> 01:00:07.190
然后我们再输出

01:00:07.190 --> 01:00:08.190
这个

01:00:08.190 --> 01:00:09.190
状态

01:00:09.190 --> 01:00:10.190
看一下

01:00:11.190 --> 01:00:12.190
保存

01:00:12.190 --> 01:00:13.190
你看一下

01:00:13.190 --> 01:00:14.190
之前的状态是不是

01:00:14.190 --> 01:00:15.190
两个数据

01:00:15.190 --> 01:00:16.190
之后的状态

01:00:16.190 --> 01:00:17.190
是不是三个数据了

01:00:17.190 --> 01:00:18.190
怎么回事

01:00:18.190 --> 01:00:19.190
因为我们之后

01:00:19.190 --> 01:00:20.190
是不是

01:00:20.190 --> 01:00:21.190
传了一个X

01:00:21.190 --> 01:00:22.190
对不对

01:00:22.190 --> 01:00:23.190
传了个X

01:00:23.190 --> 01:00:24.190
进去

01:00:24.190 --> 01:00:25.190
那么传了个X

01:00:25.190 --> 01:00:26.190
进去过后

01:00:26.190 --> 01:00:27.190
我们是不是在这里

01:00:27.190 --> 01:00:28.190
在这里

01:00:28.190 --> 01:00:29.190
可以得到这个X

01:00:29.190 --> 01:00:30.190
那么这里怎么操作的

01:00:30.190 --> 01:00:31.190
它又创建一个新的对象

01:00:31.190 --> 01:00:32.190
你看

01:00:32.190 --> 01:00:33.190
Reducer

01:00:33.190 --> 01:00:34.190
就是这样子

01:00:34.190 --> 01:00:35.190
每次都得到一个新的东西

01:00:35.190 --> 01:00:36.190
创建一个新的对象

01:00:36.190 --> 01:00:37.190
LoginUser

01:00:37.190 --> 01:00:38.190
是不是又来重新调用一下

01:00:38.190 --> 01:00:39.190
LoginUser

01:00:39.190 --> 01:00:40.190
没有什么关系

01:00:40.190 --> 01:00:41.190
它跟LoginUser

01:00:41.190 --> 01:00:42.190
没有什么关系

01:00:42.190 --> 01:00:43.190
所以LoginUser

01:00:43.190 --> 01:00:44.190
它没有变化

01:00:44.190 --> 01:00:45.190
还是NOW

01:00:45.190 --> 01:00:46.190
因为LoginUser

01:00:46.190 --> 01:00:47.190
对应不上

01:00:47.190 --> 01:00:48.190
LoginUser

01:00:48.190 --> 01:00:49.190
它对应不上

01:00:49.190 --> 01:00:50.190
看到没

01:00:50.190 --> 01:00:51.190
因为它只关心

01:00:51.190 --> 01:00:52.190
这个X

01:00:52.190 --> 01:00:53.190
那么

01:00:53.190 --> 01:00:54.190
我们现在给它传的

01:00:54.190 --> 01:00:55.190
LoginUser

01:00:55.190 --> 01:00:56.190
它对应不上

01:00:56.190 --> 01:00:57.190
对应不上的话

01:00:57.190 --> 01:00:58.190
那么LoginUser

01:00:58.190 --> 01:00:59.190
是不是没变化

01:00:59.190 --> 01:01:00.190
你看看

01:01:00.190 --> 01:01:01.190
LoginUser

01:01:01.190 --> 01:01:02.190
它对应不上

01:01:02.190 --> 01:01:03.190
返回的

01:01:03.190 --> 01:01:04.190
是不是原来的状态

01:01:04.190 --> 01:01:05.190
它没有发出变化

01:01:05.190 --> 01:01:06.190
那么User

01:01:06.190 --> 01:01:07.190
使这个函数里边

01:01:07.190 --> 01:01:08.190
是不是

01:01:08.190 --> 01:01:09.190
加到这个数组里边了

01:01:09.190 --> 01:01:10.190
返回

01:01:10.190 --> 01:01:11.190
我们把之前的数组给它

01:01:11.190 --> 01:01:12.190
对吧

01:01:12.190 --> 01:01:13.190
之前的数组

01:01:13.190 --> 01:01:14.190
你看之前的数组

01:01:14.190 --> 01:01:15.190
StateUser

01:01:15.190 --> 01:01:16.190
给它

01:01:16.190 --> 01:01:17.190
然后它给你返回

01:01:17.190 --> 01:01:18.190
一个新的数组

01:01:18.190 --> 01:01:20.190
是不是重新得到

01:01:20.190 --> 01:01:21.190
对不对

01:01:21.190 --> 01:01:22.190
就使用这个模式

01:01:22.190 --> 01:01:23.190
合并很简单

01:01:23.190 --> 01:01:24.190
对吧

01:01:24.190 --> 01:01:25.190
合并非常简单

01:01:25.190 --> 01:01:26.190
那么对于Stone

01:01:26.190 --> 01:01:27.190
而言

01:01:27.190 --> 01:01:28.190
对于这个仓库而言

01:01:28.190 --> 01:01:30.190
它知不知道是合并的Reducer

01:01:30.190 --> 01:01:31.190
它不知道

01:01:31.190 --> 01:01:32.190
它只知道

01:01:32.190 --> 01:01:33.190
你给了我一个函数

01:01:33.190 --> 01:01:34.190
我把它当成Reducer

01:01:34.190 --> 01:01:35.190
我在合适的时间点

01:01:35.190 --> 01:01:36.190
去调用它就完事了

01:01:36.190 --> 01:01:37.190
我压根就不知道

01:01:37.190 --> 01:01:38.190
你是怎么来的

01:01:38.190 --> 01:01:39.190
你看我们是合并的来的

01:01:39.190 --> 01:01:40.190
对吧

01:01:40.190 --> 01:01:41.190
但是对于仓库而言

01:01:41.190 --> 01:01:42.190
它根本就不知道

01:01:42.190 --> 01:01:43.190
它只知道

01:01:43.190 --> 01:01:45.190
我只要一个Reducer就行了

01:01:45.190 --> 01:01:46.190
你给我一个Reducer

01:01:46.190 --> 01:01:47.190
OK

01:01:47.190 --> 01:01:48.190
那我就可以了

01:01:48.190 --> 01:01:49.190
对吧

01:01:49.190 --> 01:01:50.190
所以说

01:01:50.190 --> 01:01:51.190
对于

01:01:51.190 --> 01:01:53.190
对于那个就是

01:01:53.190 --> 01:01:54.190
仓库

01:01:54.190 --> 01:01:55.190
而言

01:01:55.190 --> 01:01:56.190
那么它只需要

01:01:56.190 --> 01:01:57.190
一个

01:01:57.190 --> 01:01:59.190
只需要一个Reducer就行了

01:01:59.190 --> 01:02:01.190
它不管那个Reducer哪来的

01:02:01.190 --> 01:02:02.190
怎么合并

01:02:02.190 --> 01:02:03.190
你自己去合并

01:02:03.190 --> 01:02:05.190
其实这一块

01:02:06.190 --> 01:02:09.010
Reducer

01:02:09.010 --> 01:02:11.010
提供了一个

01:02:11.010 --> 01:02:12.010
方法

01:02:13.010 --> 01:02:15.010
可以帮助我们

01:02:15.010 --> 01:02:16.010
帮助我们

01:02:16.010 --> 01:02:17.010
更加

01:02:17.010 --> 01:02:18.010
减

01:02:18.010 --> 01:02:20.010
更加方便的

01:02:20.010 --> 01:02:21.010
合并

01:02:21.010 --> 01:02:22.010
与丢失

01:02:23.010 --> 01:02:24.010
什么方法呢

01:02:24.010 --> 01:02:25.010
这个方法的名字叫做

01:02:25.010 --> 01:02:26.010
我们在这里写吧

01:02:26.010 --> 01:02:29.710
这个方法的名字呢

01:02:29.710 --> 01:02:30.710
叫做

01:02:30.710 --> 01:02:34.850
打入进来

01:02:34.850 --> 01:02:35.850
from

01:02:35.850 --> 01:02:39.850
Reducer

01:02:40.850 --> 01:02:42.850
这个方法名字叫做

01:02:42.850 --> 01:02:43.850
combine

01:02:43.850 --> 01:02:44.850
combine就是合并

01:02:44.850 --> 01:02:45.850
Reducers

01:02:45.850 --> 01:02:46.850
就是这个方法

01:02:46.850 --> 01:02:47.850
这个函数

01:02:47.850 --> 01:02:48.850
好

01:02:48.850 --> 01:02:49.850
这个函数有什么用呢

01:02:49.850 --> 01:02:50.850
我们直接导出

01:02:50.850 --> 01:02:51.850
这个函数的返回结果

01:02:51.850 --> 01:02:52.850
combine

01:02:52.850 --> 01:02:53.850
Reducers

01:02:53.850 --> 01:02:55.850
它里面写的是一个对象

01:02:55.850 --> 01:02:57.850
这个对象里面写上什么

01:02:57.850 --> 01:02:58.850
写上Reducer

01:02:58.850 --> 01:02:59.850
完了

01:02:59.850 --> 01:03:00.850
没了

01:03:00.850 --> 01:03:01.850
Reducers

01:03:01.850 --> 01:03:02.850
没了

01:03:02.850 --> 01:03:04.850
效果一模一样

01:03:04.850 --> 01:03:05.850
保存

01:03:05.850 --> 01:03:06.850
你看看

01:03:06.850 --> 01:03:08.850
效果是不是一模一样的

01:03:08.850 --> 01:03:09.850
这个代码

01:03:09.850 --> 01:03:10.850
就相当于是

01:03:10.850 --> 01:03:12.850
上面的这个代码

01:03:12.850 --> 01:03:15.850
就相当于是个代码

01:03:15.850 --> 01:03:17.850
你仔细对到一下就明白了

01:03:17.850 --> 01:03:19.850
这里写的是Reducer

01:03:19.850 --> 01:03:20.850
那么

01:03:20.850 --> 01:03:21.850
它的属性名字

01:03:21.850 --> 01:03:23.850
跟Reducer的名字是一样的

01:03:23.850 --> 01:03:24.850
属性的名字

01:03:24.850 --> 01:03:26.850
跟Reducer的名字是一样的

01:03:26.850 --> 01:03:27.850
那如果

01:03:27.850 --> 01:03:28.850
希望属性的名字

01:03:28.850 --> 01:03:29.850
跟Reducer的名字不一样的

01:03:29.850 --> 01:03:31.850
我们这里copy一个

01:03:31.850 --> 01:03:32.850
如果说

01:03:32.850 --> 01:03:33.850
你希望Reducer的名字

01:03:33.850 --> 01:03:34.850
跟属性的名字不一样的

01:03:34.850 --> 01:03:35.850
比方说

01:03:35.850 --> 01:03:36.850
这里locking user

01:03:36.850 --> 01:03:37.850
还有一个多个东西

01:03:37.850 --> 01:03:40.850
这里一个user是Reducer

01:03:40.850 --> 01:03:41.850
那么这样子

01:03:41.850 --> 01:03:43.850
那你如果你把Reducer放过来

01:03:43.850 --> 01:03:45.850
放过来

01:03:45.850 --> 01:03:46.850
那这里是不是

01:03:46.850 --> 01:03:48.850
属性名字变成这个样子的

01:03:48.850 --> 01:03:50.850
它跟Reducer的名字是一样的

01:03:50.850 --> 01:03:51.850
最终的效果

01:03:51.850 --> 01:03:52.850
跟这个效果是一样的

01:03:52.850 --> 01:03:53.850
完全对应的

01:03:53.850 --> 01:03:54.850
完全对应的

01:03:54.850 --> 01:03:56.850
对比就明白了

01:03:56.850 --> 01:03:57.850
那么这里变化的话

01:03:57.850 --> 01:03:59.850
那如果说在这里

01:03:59.850 --> 01:04:01.850
在前面这一块

01:04:01.850 --> 01:04:03.850
我们自己手写的话

01:04:03.850 --> 01:04:04.850
是不是在这样子写

01:04:04.850 --> 01:04:06.850
是不是在这样子写

01:04:07.850 --> 01:04:08.850
这样子手写

01:04:08.850 --> 01:04:10.850
我们就可以把属性名字给它改一下

01:04:10.850 --> 01:04:12.850
那么下面这种方式怎么改

01:04:12.850 --> 01:04:13.850
下面这种方式是这样子

01:04:13.850 --> 01:04:15.850
你自己手写属性名

01:04:15.850 --> 01:04:16.850
因为它这里

01:04:16.850 --> 01:04:18.850
变量的名字就是属性名的名字

01:04:18.850 --> 01:04:19.850
那么你这里

01:04:19.850 --> 01:04:20.850
你手写个属性名碑

01:04:20.850 --> 01:04:21.850
对不对

01:04:21.850 --> 01:04:22.850
这是我们之前

01:04:22.850 --> 01:04:23.850
你们大家都学过的

01:04:23.850 --> 01:04:24.850
你给的是个对象

01:04:24.850 --> 01:04:25.850
对象的属性名字

01:04:25.850 --> 01:04:26.850
如果你用刚才那种写法的话

01:04:26.850 --> 01:04:28.850
它就给你变量的名字是一样的

01:04:28.850 --> 01:04:29.850
如果你这样写的话

01:04:29.850 --> 01:04:30.850
那么属性名字

01:04:30.850 --> 01:04:31.850
你可以分开出写

01:04:31.850 --> 01:04:32.850
对不对

01:04:32.850 --> 01:04:33.850
你可以自行约定

01:04:33.850 --> 01:04:34.850
你看一下

01:04:34.850 --> 01:04:35.850
没问题吧

01:04:35.850 --> 01:04:37.850
你只要给它对应的Reducer

01:04:37.850 --> 01:04:38.850
就是这个数据

01:04:38.850 --> 01:04:39.850
让这个Reducer来管理

01:04:39.850 --> 01:04:40.850
这个数据

01:04:40.850 --> 01:04:41.850
让这个Reducer来管理

01:04:41.850 --> 01:04:42.850
对吧

01:04:42.850 --> 01:04:43.850
那么形成了一个

01:04:43.850 --> 01:04:44.850
整个完整的对象

01:04:44.850 --> 01:04:46.850
那么又

01:04:46.850 --> 01:04:47.850
那么

01:04:47.850 --> 01:04:48.850
这个通过这个函数

01:04:48.850 --> 01:04:49.850
它就得到了一个就是

01:04:49.850 --> 01:04:51.850
唯一的一个Reducer

01:04:51.850 --> 01:04:52.850
那么现在问大家一个问题

01:04:52.850 --> 01:04:54.850
这个函数它返回的内情是啥

01:04:54.850 --> 01:04:55.850
康败Reducer

01:04:55.850 --> 01:04:57.850
这个函数它返回的是啥

01:04:58.850 --> 01:05:00.850
返回的是不是对象

01:05:00.850 --> 01:05:01.850
是对象吗

01:05:01.850 --> 01:05:04.850
那你看这里返回的是啥吗

01:05:04.850 --> 01:05:06.850
这次返回是不是个函数

01:05:06.850 --> 01:05:07.850
所以说这个函数

01:05:07.850 --> 01:05:08.850
它返回的是一个函数

01:05:08.850 --> 01:05:10.850
返回的是一个函数

01:05:10.850 --> 01:05:11.850
为什么是个函数

01:05:11.850 --> 01:05:12.850
它返回Reducer

01:05:12.850 --> 01:05:13.850
Reducer是个函数

01:05:13.850 --> 01:05:15.850
所以说你只能返回一个函数

01:05:15.850 --> 01:05:16.850
那么这个康败Reducer

01:05:16.850 --> 01:05:17.850
有什么作用

01:05:17.850 --> 01:05:21.480
我们把记录一下

01:05:21.480 --> 01:05:23.480
康败Reducer的作用就是

01:05:23.480 --> 01:05:25.480
合并Reducer

01:05:25.480 --> 01:05:29.480
得到一个新的Reducer

01:05:29.480 --> 01:05:31.480
用新的Reducer

01:05:31.480 --> 01:05:33.480
就这么个意思

01:05:34.480 --> 01:05:38.480
该新的Reducer

01:05:38.480 --> 01:05:41.480
管理一个对象

01:05:42.480 --> 01:05:44.480
该对象中的

01:05:44.480 --> 01:05:46.480
每一个属性

01:05:46.480 --> 01:05:50.480
交给对应的Reducer管理

01:05:50.480 --> 01:05:52.480
它就这么个作用

01:05:52.480 --> 01:05:53.480
看一下吧

01:05:53.480 --> 01:05:55.480
这个东西只能好好去理解一下

01:05:55.480 --> 01:05:56.480
好好去琢磨一下

01:05:56.480 --> 01:05:57.480
一定要对照这个东西来看

01:05:57.480 --> 01:05:58.480
你不对照这个东西来看

01:05:58.480 --> 01:05:59.480
很难明白

01:05:59.480 --> 01:06:00.480
你首先把这个东西

01:06:00.480 --> 01:06:01.480
要理解清楚

01:06:01.480 --> 01:06:02.480
就自己手写的要理解清楚

01:06:02.480 --> 01:06:03.480
这个理解清楚过后

01:06:03.480 --> 01:06:04.480
再来理解这个

01:06:04.480 --> 01:06:05.480
要对比起来看

01:06:05.480 --> 01:06:06.480
就好理解了

01:06:06.480 --> 01:06:08.480
首先你要理解这个东西

01:06:08.480 --> 01:06:10.480
这个东西你就把它当成

01:06:10.480 --> 01:06:11.480
你自己熟悉的

01:06:11.480 --> 01:06:13.480
就这样的想

01:06:13.480 --> 01:06:15.480
你自己熟悉了一个Reducer

01:06:15.480 --> 01:06:16.480
熟悉了一个Reducer

01:06:16.480 --> 01:06:17.480
唯一的Reducer

01:06:17.480 --> 01:06:18.480
但是它里边要出的东西太多了

01:06:18.480 --> 01:06:19.480
我想把它分开

01:06:19.480 --> 01:06:21.480
于是我自己封装了一些函数

01:06:21.480 --> 01:06:22.480
一些普通函数

01:06:22.480 --> 01:06:24.480
这东西就是个普通函数而已

01:06:24.480 --> 01:06:26.480
你就封装了一些普通函数

01:06:26.480 --> 01:06:28.480
对于不同的数据

01:06:28.480 --> 01:06:29.480
去调用这些普通的函数

01:06:29.480 --> 01:06:31.480
来得到新的数据

01:06:31.480 --> 01:06:33.480
那就这样去理解

01:06:33.480 --> 01:06:34.480
对吧

01:06:34.480 --> 01:06:36.480
我就把它封装了一下

01:06:36.480 --> 01:06:38.480
这就是关于Reducer的合并

01:06:38.480 --> 01:06:39.480
那么这样子一来的话

01:06:39.480 --> 01:06:40.480
这个Reducer是不是形成

01:06:40.480 --> 01:06:42.480
一种塑形结构

01:06:42.480 --> 01:06:47.180
Reducer它又形成了一种塑形结构

01:06:47.180 --> 01:06:48.180
你看一下

01:06:48.180 --> 01:06:50.180
这个Reducer它形成了一种塑形结构

01:06:50.180 --> 01:06:53.180
这里是一个根Reducer

01:06:53.180 --> 01:06:55.180
最终只有一个Reducer

01:06:55.180 --> 01:06:57.180
然后它里边又可能管理了

01:06:57.180 --> 01:06:58.180
多个Reducer

01:06:58.180 --> 01:06:59.180
它的书

01:06:59.180 --> 01:07:01.180
这个Reducer里边管理的数据

01:07:01.180 --> 01:07:02.180
它自己不管理

01:07:02.180 --> 01:07:04.180
它交给它里边的Reducer来管理

01:07:04.180 --> 01:07:05.180
那么你看一下

01:07:05.180 --> 01:07:08.180
形成了这个塑形结构

01:07:08.180 --> 01:07:09.180
是不是也是个单项数据

01:07:09.180 --> 01:07:10.180
它的数据交给它

01:07:10.180 --> 01:07:11.180
它的数据交给它

01:07:11.180 --> 01:07:12.180
对吧

01:07:12.180 --> 01:07:13.180
那它们去管理

01:07:13.180 --> 01:07:14.180
那有可能它里边的数据

01:07:14.180 --> 01:07:15.180
它又不管理了

01:07:15.180 --> 01:07:17.180
它又去交给其他地方管理

01:07:17.180 --> 01:07:20.180
都有可能

01:07:20.180 --> 01:07:23.180
它可能会形成这么一种塑形结构

01:07:23.180 --> 01:07:26.940
明白这个意思吧

01:07:26.940 --> 01:07:27.940
那么这样子

01:07:27.940 --> 01:07:29.940
管理就更加精细了

01:07:29.940 --> 01:07:30.940
就更加精细了

01:07:30.940 --> 01:07:32.940
就没有那么麻烦了

01:07:32.940 --> 01:07:34.940
我们一个Reducer管理所有数据

01:07:34.940 --> 01:07:35.940
它太麻烦了

01:07:35.940 --> 01:07:36.940
我们就可以更加精细的

01:07:36.940 --> 01:07:37.940
来管理这个数据

01:07:37.940 --> 01:07:38.940
看到没有

01:07:38.940 --> 01:07:39.940
它形成了这么一种结构

01:07:39.940 --> 01:07:40.940
这就是Reducer

01:07:40.940 --> 01:07:41.940
它为什么要提出

01:07:41.940 --> 01:07:42.940
Reducer这个概念

01:07:42.940 --> 01:07:43.940
它的原因

01:07:43.940 --> 01:07:44.940
那么这样子

01:07:44.940 --> 01:07:45.940
更加方便于我们管理数据

01:07:45.940 --> 01:07:47.940
形成这么一种数据结构

01:07:47.940 --> 01:07:48.940
它的数据交给它

01:07:48.940 --> 01:07:49.940
那么它有些数据处理不了

01:07:49.940 --> 01:07:50.940
又交给它们

01:07:50.940 --> 01:07:51.940
对不对

01:07:51.940 --> 01:07:52.940
可以用手续代码

01:07:52.940 --> 01:07:54.940
也可以用康败

01:07:54.940 --> 01:07:55.940
康败那个Reducer

01:07:55.940 --> 01:07:56.940
来进行管理

01:07:56.940 --> 01:07:58.940
都可以

01:07:58.940 --> 01:08:00.940
只要你记住

01:08:00.940 --> 01:08:01.940
所以说

01:08:01.940 --> 01:08:02.940
有些东西你理解的

01:08:02.940 --> 01:08:03.940
原理是很重要的

01:08:03.940 --> 01:08:04.940
你理解了它的原理过

01:08:04.940 --> 01:08:05.940
和理解觉得

01:08:05.940 --> 01:08:06.940
它没有什么特别的

01:08:06.940 --> 01:08:08.940
我们完全可以手续代码

01:08:08.940 --> 01:08:09.940
就是有的时候

01:08:09.940 --> 01:08:11.940
我们可能不需要

01:08:11.940 --> 01:08:12.940
用这个东西

01:08:12.940 --> 01:08:14.940
我们可能在某个时候

01:08:14.940 --> 01:08:15.940
某些数据

01:08:15.940 --> 01:08:16.940
需要交给这些管理

01:08:16.940 --> 01:08:17.940
那么我们就可以

01:08:17.940 --> 01:08:18.940
直接写就完成了

01:08:19.940 --> 01:08:21.940
就可以手续代码来完成

01:08:22.940 --> 01:08:23.940
你看这意思吗

01:08:23.940 --> 01:08:24.940
OK

01:08:24.940 --> 01:08:25.940
那咱们

01:08:25.940 --> 01:08:26.940
就没了

01:08:26.940 --> 01:08:27.940
就没了

01:08:27.940 --> 01:08:28.940
这就是

01:08:28.940 --> 01:08:29.940
这节课我们要讲的内容

01:08:29.940 --> 01:08:30.940
与丢事

01:08:30.940 --> 01:08:31.940
始终记住

01:08:31.940 --> 01:08:32.940
Reducer是一个存在函数

01:08:32.940 --> 01:08:33.940
没有副作用

01:08:33.940 --> 01:08:34.940
第二个

01:08:34.940 --> 01:08:35.940
Reducer只能有一个

01:08:35.940 --> 01:08:36.940
但是我没有需要

01:08:36.940 --> 01:08:37.940
精细的管理

01:08:37.940 --> 01:08:38.940
各种复杂的数据

01:08:38.940 --> 01:08:40.940
和复杂的多种的action

01:08:40.940 --> 01:08:41.940
我们可能会把

01:08:41.940 --> 01:08:42.940
划分

01:08:42.940 --> 01:08:43.940
分开

01:08:43.940 --> 01:08:44.940
分开过后

01:08:44.940 --> 01:08:45.940
我们用一个函数

01:08:45.940 --> 01:08:46.940
把它合并起来

01:08:46.940 --> 01:08:47.940
这个函数

01:08:47.940 --> 01:08:48.940
我们可以自己

01:08:48.940 --> 01:08:49.940
手续代码来创建

01:08:49.940 --> 01:08:50.940
也可以利用

01:08:50.940 --> 01:08:51.940
CombineReducer来创建

01:08:52.940 --> 01:08:53.940
总之

01:08:53.940 --> 01:08:54.940
最终是要

01:08:54.940 --> 01:08:55.940
给它这么的东西

01:08:55.940 --> 01:08:56.940
对于仓库而言

01:08:56.940 --> 01:08:57.940
它是根本就不知道

01:08:57.940 --> 01:08:58.940
Reducer哪来的

01:08:58.940 --> 01:08:59.940
它只知道

01:08:59.940 --> 01:09:00.940
我一个函数

01:09:00.940 --> 01:09:01.940
我就把它当成Reducer

01:09:01.940 --> 01:09:02.940
初识化的时候

01:09:02.940 --> 01:09:03.940
我给你一个东西

01:09:03.940 --> 01:09:04.940
你调容一次

01:09:04.940 --> 01:09:05.940
然后

01:09:05.940 --> 01:09:06.940
后续的时候

01:09:06.940 --> 01:09:07.940
只要dispatch

01:09:07.940 --> 01:09:08.940
只要分发了action

01:09:08.940 --> 01:09:09.940
我又去改变

01:09:09.940 --> 01:09:10.940
我又去调容你的函数

01:09:10.940 --> 01:09:11.940
去改变

01:09:12.940 --> 01:09:13.940
好好去理清楚

01:09:13.940 --> 01:09:14.940
这些东西一定要

01:09:14.940 --> 01:09:15.940
仔细体会

01:09:15.940 --> 01:09:16.940
一定要仔细体会

01:09:16.940 --> 01:09:18.940
Reducer是

01:09:18.940 --> 01:09:19.940
Reducer里面

01:09:19.940 --> 01:09:20.940
非常核心的东西

01:09:20.940 --> 01:09:21.940
也是我们代码

01:09:21.940 --> 01:09:22.940
主要集中的地方

01:09:22.940 --> 01:09:23.940
所以一定要去体会

01:09:23.940 --> 01:09:24.940
不但要体会

01:09:24.940 --> 01:09:25.940
这个工程结构

01:09:25.940 --> 01:09:26.940
还要去体会

01:09:26.940 --> 01:09:27.940
这个

01:09:27.940 --> 01:09:28.940
细分的Reducer

01:09:28.940 --> 01:09:29.940
该怎么去输解

01:09:29.940 --> 01:09:30.940
怎么去合并

01:09:30.940 --> 01:09:31.940
它的原理是什么

01:09:31.940 --> 01:09:32.940
它整个过程是什么

01:09:32.940 --> 01:09:33.940
好好去体会

01:09:33.940 --> 01:09:34.940
多花点时间

01:09:34.940 --> 01:09:35.940
多去测试

01:09:35.940 --> 01:09:36.940
因为这一块

01:09:36.940 --> 01:09:37.940
我平时

01:09:37.940 --> 01:09:38.940
线下想的时候

01:09:38.940 --> 01:09:39.940
遇到很多同学

01:09:39.940 --> 01:09:40.940
都有很多疑问

01:09:40.940 --> 01:09:41.940
但是那些

01:09:41.940 --> 01:09:42.940
就是视频里面

01:09:42.940 --> 01:09:43.940
我就很愁畅

01:09:43.940 --> 01:09:44.940
因为我不知道

01:09:44.940 --> 01:09:45.940
你到底卡在哪

01:09:45.940 --> 01:09:46.940
你的想法到底卡在哪

01:09:46.940 --> 01:09:47.940
所以多去自己输理

01:09:47.940 --> 01:09:48.940
就是有些同学

01:09:48.940 --> 01:09:50.940
他自己知道很模糊

01:09:50.940 --> 01:09:51.940
但他不知道

01:09:51.940 --> 01:09:52.940
自己模糊在哪个点

01:09:52.940 --> 01:09:53.940
就很多同学

01:09:53.940 --> 01:09:54.940
都有那种感觉

01:09:54.940 --> 01:09:55.940
那怎么办

01:09:55.940 --> 01:09:56.940
首先自己

01:09:56.940 --> 01:09:57.940
把它手写一遍

01:09:57.940 --> 01:09:59.940
然后再去想

01:09:59.940 --> 01:10:00.940
它到底是怎么回事

01:10:00.940 --> 01:10:01.940
如果说

01:10:01.940 --> 01:10:02.940
你有了一些想法

01:10:02.940 --> 01:10:03.940
有了一些猜想

01:10:03.940 --> 01:10:04.940
然后再去写代码验证

01:10:04.940 --> 01:10:05.940
不断的猜想

01:10:05.940 --> 01:10:06.940
不断的验证

01:10:06.940 --> 01:10:07.940
就是学技术的一种

01:10:07.940 --> 01:10:09.940
非常好的一种方式

01:10:09.940 --> 01:10:10.940
慢慢

01:10:10.940 --> 01:10:11.940
你通过自己的猜想

01:10:11.940 --> 01:10:12.940
自己去验证

01:10:12.940 --> 01:10:14.940
那么最终得到了结论

01:10:14.940 --> 01:10:16.940
你印象会非常深刻

01:10:16.940 --> 01:10:17.940
然后你可以

01:10:17.940 --> 01:10:18.940
如果还是觉得

01:10:18.940 --> 01:10:19.940
验证完了过后

01:10:19.940 --> 01:10:20.940
担心自己

01:10:20.940 --> 01:10:21.940
可能

01:10:21.940 --> 01:10:22.940
理解是不是有问题

01:10:22.940 --> 01:10:23.940
那么你可以再看一下

01:10:23.940 --> 01:10:25.940
我这个地方的解释

01:10:25.940 --> 01:10:26.940
你再看一下

01:10:26.940 --> 01:10:27.940
就后来明白了

01:10:27.940 --> 01:10:29.940
如果你之前没有做

01:10:29.940 --> 01:10:30.940
任何的思考的光来听

01:10:30.940 --> 01:10:31.940
那肯定是有点牢火

01:10:31.940 --> 01:10:33.940
这是非常非常正常的

01:10:33.940 --> 01:10:34.940
好吧

01:10:34.940 --> 01:10:35.940
下来一定要去做一次

01:10:35.940 --> 01:10:36.940
这是关于绿丢伤

