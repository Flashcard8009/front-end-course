WEBVTT

00:00.430 --> 00:08.910
还是来做一个小练习 这个练习 呢 效果就这样子 啊 就这样子 就是一个可以自动移动的小球

00:09.630 --> 00:14.350
啊 这个小球的跑了 碰到边缘的时候呢 就会反弹啊 就这么一个小球

00:15.310 --> 00:21.550
我们这里呢 以前其实我们做过这样的一个练习啊 在学习非常非常早的时候学习那个

00:22.270 --> 00:30.510
既也是基础的时候 一个公开课啊 我就在公开课里边呢 我就做过这么一个练习 那么现在呢 我们在react里边也把做一次

00:30.830 --> 00:35.390
现在我们呢 使用组件的那种思维啊来做一下这个练习

00:35.950 --> 00:40.750
因此呢 我们这里呢 会考虑把这个小球呢 当成一个组件

00:41.310 --> 00:45.310
ok啊 咱们写这么一个文件牙component

00:46.030 --> 00:50.830
component 这里边加一个文件啊 就是布

00:51.790 --> 00:55.790
所以手这么大写啊 不小球把它做成一个组件

00:56.590 --> 01:08.670
啊 然后呢 这个小球呢 它要能够自我移动 那既然要能够自我移动的话 那肯定有自己的状态对吧 比方说目前的坐标啊 目前的速度等等等等啊

01:09.390 --> 01:17.310
啊 所以说他又肯定是有自己的状态 那么因此呢 我们这里呢 会把它写成一个内组件 因为只有内组件的

01:17.710 --> 01:19.710
才有状态 所以说rcc

01:21.310 --> 01:26.510
写成一个内组件啊 这个内组件里边呢 我们首先思考一下啊

01:27.630 --> 01:30.860
constructor 思考一下

01:32.060 --> 01:36.620
它有什么样的状态啊 有什么样的状态

01:37.500 --> 01:43.500
就是我们这里肯定要给状态呢 进行初始化啊 有什么样的状态呢 它在这里边

01:45.100 --> 01:49.900
啊 他肯定有一个 他有一个位置对吧 他肯定有这么一个位置

01:50.460 --> 01:55.100
所以说呢 这里呢 位置呢 我们就使用什么lapt和top

01:56.220 --> 01:59.980
跟我们css里边的位置呢 保持一致啊 left

02:01.340 --> 02:03.260
是什么 然后呢 top

02:05.020 --> 02:11.020
好 那么这两个东西到底是啥呢 有人说啊 那这里呢 就给他写个零呗 随便是啥 其实也无所谓

02:12.060 --> 02:16.540
实际上呢 我们尽量的啊 在做组件的时候呢 尽量的考虑多一点

02:17.020 --> 02:23.340
尽量的希望组件能够通用 就是不管在什么场景里边呢 他都能够就是

02:24.060 --> 02:31.020
通用的 因为我们这个写这个组件呢 他的主要目的是什么呢 主要目的是为了就是制作一个

02:32.060 --> 02:36.300
一个能够自动移动的小球

02:37.500 --> 02:42.380
他的主要目的是一个能自动移动的小球 那么这个小球的初始位置

02:42.780 --> 02:48.300
实际上呢 对于这个组件而言 我是不知道的 我并不知道这个小球的初始位置

02:48.700 --> 02:54.380
那怎么办呢 那我可以希望啊 你能不能在属性里边给我传过来

02:54.700 --> 02:57.020
把这个小球的初始位置给我传过来

02:57.580 --> 03:01.900
所以说这个属性里边呢 他有一些初始位置啊 我希望你给我传过来

03:02.700 --> 03:06.060
好 那么我这样子写吧啊 这样子写 就说probs

03:06.780 --> 03:10.860
probs 第二 什么lapt 你给我传一个初始位置

03:11.420 --> 03:15.660
那如果你没有传递啊 如果你没有传递呢 我就使用0

03:16.220 --> 03:17.180
这个写法能看懂吗

03:18.700 --> 03:25.980
啊 我本来是我希望能够得到这个字 但是如果你没有传递 没有传递的话 那我就使用0

03:27.020 --> 03:32.380
好 他不止也是啊 你给我传过来 如果你没有传递的话 我就使用0

03:33.500 --> 03:35.580
啊 这是坐标啊 坐标

03:36.460 --> 03:37.500
就是横坐标

03:38.860 --> 03:42.940
当然这个是小球左上角的横坐标啊 这是重坐标

03:45.020 --> 03:53.500
这是小球的当前位置啊 这是小球的当前位置 当前位置呢 一开始在进行初始化的时候呢 来自于属性的值

03:53.740 --> 03:55.340
当然如果属性没有传递 那就失礼

03:56.300 --> 03:58.780
好 除了初始位置之外呢

03:59.260 --> 04:02.540
这个小球呢 还有一个什么 还有什么样的特点呢

04:03.340 --> 04:11.340
这个小球除了初始位置之外 它还应该有一个就是说速度 对吧 横向上的速度

04:11.900 --> 04:18.780
向右的话 我们就认为是一个正值 向左的话 就认为是一个负值

04:19.660 --> 04:27.020
同样的 还有一个向 还有一个中向的速度 就是向下的话 认为是正值 向上的话 认为是负值

04:27.500 --> 04:30.060
好 你还要给我一个速度啊 速度

04:31.020 --> 04:37.580
好 这个速度呢 肯定也要通过什么propercy来告诉我 那我们的速度它有没有可能会变化呢

04:38.540 --> 04:45.580
在我们目前这个需求里边 速度是不会变化的 因此呢 速度呢 我就不会把它写到状态里边了

04:46.060 --> 04:50.060
啊 因为这个速度它不会变化 它也不需要自我去维护这个状态

04:50.540 --> 04:55.340
所以说呢 这个速度呢 我就认为在属性里边 你要给我传过来

04:55.740 --> 04:56.860
你要给我传过来

04:57.740 --> 05:02.940
好吧 所以说速度呢 我就不写到状态里边了 状态里边就写一个横重坐标

05:03.500 --> 05:12.380
好 这里呢 打个注释啊 属性中需要传递什么 需要传递什么 一个就是横重

05:14.770 --> 05:20.850
横重坐标上的速度 需要分别传递

05:21.810 --> 05:27.250
横重坐标上的速度 这个速度呢 我们可以啊 就约定好嘛 这些组件跟那个

05:27.810 --> 05:33.570
使用组件的人呢 之间肯定要有一个约定啊 约定好这个速度的意思呢 就是每秒

05:35.330 --> 05:35.890
每秒

05:37.410 --> 05:42.130
移动的像素值 每秒钟移动多少个像素

05:43.650 --> 05:50.450
好 那么假设啊 假设了就已经传过来了啊 传过来了分别保存到哪呢 分别保存到属性propercy

05:51.170 --> 05:52.050
x speed

05:53.410 --> 05:58.210
一个是呢propercy y speed 分别保存到这

05:59.890 --> 06:07.250
好 行了啊 那咱们这些东西呢 都做了约定了 那将来呢 我们要用这个主线的时候 怎么用呢 我们就可以这样子使用

06:07.970 --> 06:15.090
在这边啊 我们把导进来测试一下啊 我们这里呢使用啊 导进来啊 这个波

06:15.810 --> 06:19.890
波 导进来 然后在这边 这样子使用

06:20.770 --> 06:26.690
波 他不是需要一个速度吗 对不对 好 x speed

06:27.650 --> 06:35.170
speed 所以小同步命迷法啊 横座标的速度呢 他是向右的啊 向右的比方说是一个

06:36.290 --> 06:37.810
每秒钟移动

06:38.850 --> 06:42.050
100个像素 好 然后y speed

06:43.010 --> 06:44.610
每秒钟移动

06:45.970 --> 06:53.570
200个像素啊 举个例子啊 举个例子 然后呢 坐标 uh left 坐标呢 为100

06:54.530 --> 07:03.570
啊 然后top值呢 也为100啊 这些东西我都可以传的过去啊 接下来呢 我们一边写呢 一边测试一下啊

07:03.650 --> 07:04.050
12

07:05.170 --> 07:09.250
start 要进入这个目录啊 cd react

07:11.170 --> 07:20.830
12 start 看一下啊 把运行出来 我们这样子呢 就是使用这个组件的方式就是这样子使用的

07:21.630 --> 07:26.350
好 接下来呢 我就完全交给这个组件自己去完成了 剩下的事情自己去完成

07:26.990 --> 07:30.430
那么这个组件呢 首先我们看一下这个render

07:31.070 --> 07:35.710
宣然的时候 他是怎么宣然的 我们的数据是什么呢 数据

07:36.350 --> 07:41.870
坐标的数据是不是来自于这儿啊 我们就根据状态里边的坐标来进行宣然对吧

07:42.510 --> 07:46.190
我们render这个这个方法 他要做的事情其实很简单

07:46.910 --> 07:50.670
他不不做是任何去改变什么数据的事 这些事情他不做

07:51.150 --> 07:55.950
他就做什么事呢 就做一个就说 我现在有一个数据这个数据呢 有的来自于

07:56.590 --> 08:04.670
属性有的呢 来自于状态 那么我们根据属性里边的数据 根据状态里边的数据把它宣然出来就完成了

08:05.470 --> 08:10.830
所以说这个render呢 还本身呢 就很简单啊 根据这个这些东西呢 把它宣然出来

08:11.310 --> 08:18.030
好 这里有个div 好 我们给这个div呢 写一些样式嘛啊 咱们去建一个新建一个文件啊 不叫css

08:18.270 --> 08:25.150
当然你把它做成那一年样式写进去研修啊 建个css啊 给他一个那样式啊 不

08:26.910 --> 08:29.470
什么样式呢 就是一个宽高嘛 一个宽高

08:30.270 --> 08:35.630
小球嘛 给他固定的宽高啊 100个像素 高度的100个像素 然后呢

08:37.710 --> 08:41.310
就是border writers啊 border writers

08:42.510 --> 08:51.950
50%背景颜色呢 背景颜色是不是也可以传过来 对不对 哎 背景颜色 我刚才来传递算了啊 传递一个背景颜色

08:52.910 --> 08:58.590
好 这里呢 还有一个就是背景颜色啊 还有一个就是背景颜色 背景颜色呢 你需要给我传递一个

08:58.910 --> 09:07.070
好 所以说这里还要说一个啊 就是需要啊 需要传递背景颜色啊 背景颜色

09:09.150 --> 09:17.790
背景颜色啊 如果没有传递啊 如果没有传递 则使用

09:18.510 --> 09:20.510
呃 红色嘛啊 就使用红色

09:21.630 --> 09:26.190
啊 那么比方说我这里传一个背景颜色过来啊 就是bg啊 bg传过来

09:26.910 --> 09:35.150
啊 bg的话 我们就是传一个制服串嘛啊 传制服串的话直接写双引号就行了啊 因为这种普通的制服串属性的话 你直接写个双引号就可以了

09:35.790 --> 09:39.230
啊 这里呢 我们传一个什么颜色呢 比方说

09:40.750 --> 09:42.830
呃 亮蓝色吧啊 亮蓝色

09:43.550 --> 09:51.630
不要写情号了啊 保存啊 那这边呢 我们根据这些情况啊 首先有个内样式 一个框膏 一个一个就是

09:52.350 --> 09:58.350
边框颜色啊 有个边框颜色啊 不就是圆角边框 好 我们这里呢 把这个css导入进来

09:59.070 --> 10:00.270
import啊

10:01.470 --> 10:01.870
这里

10:03.070 --> 10:07.790
bore.css 把css导入进来 然后这里边呢 class name

10:08.510 --> 10:10.990
写上我们的css啊 就是bore

10:11.950 --> 10:15.230
然后呢 他自己有个样式啊 自己有一个样式就是style

10:16.190 --> 10:23.710
style 是不是个对象 对吧 是一个对象 好 有哪些属性要设置呢 当然他这里边还有一个什么 还有一个就是pracing

10:24.350 --> 10:31.630
pracing啊 我们可以用fixed 因为是整个屏幕滚 整个屏幕的弹动嘛 对吧 我们可以用fixed

10:32.510 --> 10:40.590
啊 对这个pracing啊 定位 然后这边就只需要写什么呢 写left值对吧 他们left值为多少呢 是不是来自于

10:40.990 --> 10:44.430
this.stat.left 凭借上什么ps

10:45.070 --> 10:46.190
啊 这是left值

10:47.150 --> 10:50.750
啊 我看一下那个 我先写吧 写了过后我再看一下 他们

10:51.310 --> 10:55.790
我还我还真没有试过啊 他可不可以部加这个ps

10:57.950 --> 10:58.430
看一下啊

10:59.230 --> 11:02.110
然后背景颜色 背景颜色 background

11:03.230 --> 11:09.710
背景颜色的话 来自于属性啊 你要知道一个数据从哪来的 这里为什么来自于状态 因为这个

11:10.430 --> 11:15.710
坐标他会变化啊 状态的坐标是会变化的 所以说我们要根据状态的坐标来设置他的

11:16.270 --> 11:21.950
横重坐标 总之Render他就根据数据来设置这里的界面啊 这就是rex要做的事

11:22.350 --> 11:25.230
根据数据来设置界面该怎么显示

11:25.790 --> 11:30.830
好 这里呢 背景颜色呢 我们就来自于属性 属性不是一个背景颜色吗 对不对

11:31.390 --> 11:35.630
属性的背景颜色啊 是来自于bg啊 bg

11:35.950 --> 11:40.110
他当他有可能没有船 如果你没有船地的话 那我就使用什么

11:40.590 --> 11:44.670
如果你没有船地这个东西 那我就使用这个f40吗 一个红色

11:45.790 --> 11:51.310
好 保存啊 怎么来看一下啊 哎 他说跑错了啊 他说什么

11:51.870 --> 11:57.630
啊 这个波 哦 波的css 哦 这里应用 这里大写的啊

11:58.430 --> 11:58.750
保存

12:00.430 --> 12:02.670
啊 他还抱错了 哎 对了啊 出来了

12:03.790 --> 12:10.030
啊 那是不是出来了 对吧 那就没问题了 那我试一下啊 试一下这这里能不能不写这个ps

12:10.670 --> 12:12.030
能不能不写 保存

12:12.590 --> 12:19.070
哎 可以不写啊 那我就不写了 好 那么这样子一来呢 这个组件呢 他就是根据那个

12:20.030 --> 12:24.430
根据我们的数据来显示出来了 咱们再来多测试一下啊

12:24.830 --> 12:29.470
那比方说咱们这里呢 没有写这个背景颜色啊 没有给他背景颜色这个负责

12:29.950 --> 12:32.030
你看他就是红色 看没有 就是红色

12:32.750 --> 12:35.470
啊 就这样子啊 没问题吧

12:36.590 --> 12:44.190
哎 好 这样子写了之后呢 不要说啊 不设置laptop纸 它不是有是不是有个默认值啊 对吧 默认了初始位置

12:44.350 --> 12:45.150
那就是0

12:45.790 --> 12:47.310
啊 好 这都没问题

12:48.270 --> 12:54.270
好 那么接下来呢 要做的事情 那这里render是不是写好了 就已经写完了啊 人的就已经写完了

12:54.910 --> 12:57.790
我们接下来要做的事情是啥呢 无非就是

12:59.230 --> 13:05.230
啊 不断的去改变状态里边的laptop和top纸

13:06.270 --> 13:07.310
就是改变这两个东西

13:08.110 --> 13:14.190
于是呢 我们要不断的改变 是不是要设置一个什么set interval 对不对啊 要设置这么一个东西

13:15.150 --> 13:23.950
在这里设置 好 每个那就短时间短一点嘛 这个时间越短呢 它就是越平滑 比方说16毫秒

13:25.390 --> 13:29.230
每个16毫秒要改变啊 改变

13:29.870 --> 13:31.790
怎么改变呢 是根据速度

13:32.830 --> 13:35.950
改变laptop和top纸

13:37.470 --> 13:41.150
好 我们一个一个来说 首先是要改变laptop

13:41.710 --> 13:44.990
要改变laptop 怎么来变呢

13:46.110 --> 13:48.110
新的laptop 该怎么来算呢

13:48.910 --> 13:53.070
我们是不是要根据速度来 对不对 要根据这个速度来啊

13:53.630 --> 13:57.710
好 我们知道这个速度呢 是指的是每秒钟

13:58.270 --> 14:02.030
它移动的像素值 每秒钟移动多少个像素

14:02.990 --> 14:05.950
那么现在呢 我们是每隔了16毫秒

14:06.590 --> 14:10.270
每隔16毫秒要移动多少了 刚才我这里用个变量的了

14:10.430 --> 14:16.270
如果不用变量的话 这里呢 啊 容易把它写死啊 所以说用个变量啊 就Dial Ration

14:17.710 --> 14:22.750
Dial Ration 16啊 间隔的好秒数

14:23.710 --> 14:28.580
啊 我们这里把它放到这儿 我怎么又用这个

14:30.100 --> 14:36.820
把它放到这儿啊 那么每隔16毫秒 它移动多少距离呢 是不是可以可以非常轻松的算出来

14:37.300 --> 14:37.700
对不对

14:38.660 --> 14:42.660
没问题吧 我们可以非常轻松的算出来 我们知道速度

14:43.380 --> 14:47.460
然后呢 知道间隔时间 我们可以非常轻松的算出来

14:47.780 --> 14:51.140
它注意一种移动的距离啊 最终移动的距离

14:51.860 --> 14:55.700
好 那么x的距离是多少呢 x this

14:58.420 --> 15:01.620
x this x 走移动的距离是多少了 是不是

15:02.820 --> 15:05.380
来自于this props x speed

15:06.100 --> 15:10.340
啊 x 的速度 速度乘以什么 乘以时间

15:11.380 --> 15:13.540
啊 乘以时间 时间是什么Dial Ration

15:14.180 --> 15:17.540
好 注意啊 你要处于1000 因为这个单位呢 这个

15:18.100 --> 15:23.780
速度的单位呢 是每秒钟移动的距离 这是好秒对吧 所以说呢 你再把它转换成秒

15:24.260 --> 15:30.900
啊 你再处于1000 这就是x方向上 这一段时间内 这一小段时间内 它移动的距离

15:31.860 --> 15:33.780
好 我们把它写上啊 这是这个字

15:34.500 --> 15:37.860
好 另外呢 y 的移动距离是不是也可以算出来

15:38.500 --> 15:41.140
this props x speed

15:42.260 --> 15:44.740
乘以Dial Ration 处于1000

15:45.140 --> 15:48.260
好 其实这个东西两个东西是有没有必要每次都算一遍

15:48.660 --> 15:52.580
你看这个东西有没有变化 是不会变的 属性里边东西是不会变的对吧

15:53.060 --> 15:55.780
我们认为是不会变的 那么这个Dial Ration呢

15:56.260 --> 16:00.020
它是不是也不会变化 所以说这两个东西是不是一开始就可以算出来了

16:00.340 --> 16:03.620
对不对 一开始可以把它算出来啊 就是

16:04.340 --> 16:10.420
间隔时间内在x方向移动的距离 间隔时间内在y方向上移动的距离

16:10.500 --> 16:14.180
所以可以把它算出来 好 算出来过后呢 在这里就是

16:15.220 --> 16:18.580
新的Left值等于什么呢 这个变量啊

16:20.740 --> 16:23.860
New left 等于啥呢 等于

16:24.420 --> 16:27.860
原来的State

16:28.180 --> 16:30.500
Dial Left 加上

16:31.860 --> 16:37.380
x 走 移动的距离 对吧 这个距离有可能是正数 有可能是复数 说不好

16:37.860 --> 16:38.500
啊 说不好

16:39.300 --> 16:41.620
啊 不行 不行 好像每次都还在算一遍

16:41.780 --> 16:46.740
这个地方每次都还在算一遍 因为它到了边缘 它会弹回来 它的速度会变化

16:47.620 --> 16:49.220
它的速度有可能会变化

16:49.700 --> 16:53.620
所以说这里 这里我之前没考虑到啊 我之前没有考虑到

16:54.020 --> 16:59.380
这个速度啊 它也得放到状态里边 因为速度会变化 我们之前认为速度它不会变的

16:59.540 --> 17:01.940
但实际上那个速度会变的 你看到了边缘过后

17:02.420 --> 17:06.660
它的某一个方向上的速度是相反的 对吧 它的速度是会变化的

17:07.060 --> 17:10.980
啊 这些东西我一开始没有考虑 考虑得很周全啊 写成绪就是这样子

17:11.460 --> 17:14.500
先为自己开拓一波嘛 行不行 写成绪就是这样子啊

17:14.900 --> 17:18.740
那确实是这样子啊 一开始可能考虑不了不到所有的情况

17:19.140 --> 17:23.060
啊 那这里刚才呢 我认为这个速度不会变化 实际上那个速度呢是会变化的

17:23.140 --> 17:27.460
它需要自我维护的 因此这个速度呢 需要放到状态里边

17:28.180 --> 17:32.820
啊 它一开始的速度呢 是初速度 那么传 通过属性传进来

17:33.140 --> 17:36.660
那么这里呢 我们还需要 还是要把这个速度啊 放到这个状态里边

17:37.220 --> 17:37.620
speed

17:38.820 --> 17:41.940
来自于啊 这里应该是 z 点 props

17:44.660 --> 17:48.340
啊 当然这里写 props 也行 因为这里是参数嘛 对吧 可以直接使用参数

17:49.060 --> 17:56.660
props 点 x speed y speed props y speed

17:57.380 --> 18:01.060
好 我们这里呢 还是要在这里进行计算啊 这里是来自于状态的

18:01.780 --> 18:02.740
来自于状态的

18:03.940 --> 18:09.620
好了 我们根据 哎 这是 y 我们根据速度这里算出来的位移

18:10.020 --> 18:13.620
那么我们就再根据位移来算出新的作标

18:13.860 --> 18:18.340
为什么我再说一次啊 为什么要写到这里边 因为速度它可能会变化

18:18.580 --> 18:21.700
如果你写到外边的话 构造函数只会只会运行一次

18:22.100 --> 18:24.020
那么这个速度呢 它就永远不变了啊

18:24.660 --> 18:26.500
那怕这个速度变化了 它也感知不到

18:27.060 --> 18:28.020
所以说我们要写到这

18:28.500 --> 18:33.140
好 这是新的 left 值 然后呢 再来一个新的 top 值

18:33.300 --> 18:35.140
是不是 z step 点 top

18:36.340 --> 18:38.500
加上什么 加上 y 的 this

18:39.140 --> 18:42.980
啊 我们先把算好 算好过后呢 再重新覆盖

18:43.220 --> 18:45.860
啊 我们先算好 算好过后再重新覆盖

18:46.820 --> 18:51.460
好 那么这样子加了过后 有没有可能超过边界呢

18:52.020 --> 18:52.660
有没有可能

18:54.100 --> 18:57.540
当然有可能啊 比方说 left 值 我们一个个看啊

18:58.180 --> 19:02.020
横坐标 横坐标这样子一相加 因为它有可能是附属

19:02.580 --> 19:06.900
它是像左的速度嘛 对吧 那么这样子的速度有可能是附属

19:06.900 --> 19:09.220
附属的呈出来过后呢 这个就是附属

19:09.380 --> 19:11.620
不断的去加一个附属 是不是 left 值

19:11.940 --> 19:15.060
一旦呢 就越来越小 越来越小啊 新的 left 值就越来越小

19:15.700 --> 19:18.980
好 所以说 有可能呢 出现这么一种情况

19:19.300 --> 19:22.500
new left 呢 它小于了零 有没有可能

19:23.060 --> 19:25.860
有可能 如果出现这种情况怎么办

19:27.540 --> 19:32.660
new left 是不是要等于零 它不能跑到边界外面去吧 最后要等于零

19:33.620 --> 19:35.060
然后干嘛呢 反向

19:36.020 --> 19:41.060
横向上反向 怎么反向呢 是不是要重新设置 set state

19:42.180 --> 19:44.340
重新设置什么 x speed

19:45.140 --> 19:51.220
重新设置 x 走方向上的速度 为什么呢 为之前 x 方向上的速度

19:51.860 --> 19:57.700
是不是取反啊 把取为附属啊 不是附属啊 把取一个反

19:57.700 --> 20:00.980
它之前是附属现在变成正数了 之前是正数现在变成附属了

20:01.540 --> 20:05.220
总之呢 在 x 走方向上取反 没问题吧 这个没问题吧

20:05.860 --> 20:10.820
啊 如果碰到了边缘啊 碰到了边缘 是不是要反向对不对

20:11.460 --> 20:14.980
横坐横坐标反向

20:16.740 --> 20:18.580
好 再来啊 lcf

20:19.540 --> 20:24.740
横坐标还有一种情况会超出边界 就是跑到屏幕 就是右边的屏幕外面去了

20:25.300 --> 20:26.900
就是跑出这个四口的

20:27.620 --> 20:32.260
外面去了 好 那么这个种情况是什么情况了 是新的横坐标

20:32.980 --> 20:34.980
大雨大雨到啥

20:35.620 --> 20:40.260
大雨那就是啊或者说大雨小雨等于吗 那这大大雨等于

20:40.980 --> 20:44.260
大雨等于了啥呢 大雨等于了就是

20:46.900 --> 20:50.420
就是整个四口 document document element

20:51.540 --> 20:52.500
client width

20:53.460 --> 21:01.860
整个四口的宽度减去它自身的宽度 自身的宽度是多少 我们这里定时的对吧 定时的宽度是一百

21:02.100 --> 21:04.020
好 自身的宽度是一百 比方说吧

21:04.900 --> 21:07.700
好 减去一百 为什么要减宽度 你看一下吧

21:08.260 --> 21:10.260
这个小球 我们看一下

21:10.900 --> 21:12.340
等到一个合适的时期 我截个图

21:17.070 --> 21:17.790
重新刷新一下啊

21:18.750 --> 21:20.990
大家看啊 就到这边啊 到这个边缘

21:22.030 --> 21:23.390
到四口的这个边缘

21:24.750 --> 21:26.270
稍等一下啊 我们截个图

21:29.600 --> 21:30.160
好 到这

21:31.600 --> 21:38.800
那么这个这个地方它的横坐标是不是整个屏幕的宽度减去它自身的宽度对吧

21:39.200 --> 21:42.160
它自身的宽度啊 它的横坐标在这啊 在这

21:43.120 --> 21:47.840
这一条边是横坐标 所以说呢 我们这里呢 需要啊 需要就是

21:49.120 --> 21:53.680
用减一百来进行判断 如果大约到这个纸呢 就把它复制为这个纸

21:53.680 --> 21:57.280
因为它不能超出这个边界嘛 对不对啊 复制为这个纸

21:57.840 --> 22:00.800
然后呢 是不是又要反向 对不对 还是得反向

22:01.440 --> 22:06.240
啊 横坐标反向 那么横坐标是不是搞定了 对不对 横坐标搞定了

22:07.360 --> 22:09.360
好 然后呢 再搞定重坐标

22:10.320 --> 22:10.800
if

22:11.680 --> 22:13.920
我们把它稍微复制一下吧 稍微复制一下

22:14.400 --> 22:17.920
重坐标呢 是一样的道理啊 这里是new top new top

22:18.480 --> 22:22.400
如果小于你 是不是把它等于一年 然后呢 wide speed

22:23.120 --> 22:26.400
wide的速度 是不是要反向 对吧 要反向

22:27.760 --> 22:33.890
speed 这是重坐标反向 这里也是重坐标反向

22:34.930 --> 22:36.770
好 然后呢 这里呢 如果

22:37.490 --> 22:41.650
新的top值搭于等于了它的四口高度

22:43.570 --> 22:44.370
四口高度

22:45.090 --> 22:49.410
减去100 那怎么样呢 就把它设置为四口高度减100

22:49.410 --> 22:51.490
这是它最大的top值了 不能比这个大了

22:53.570 --> 22:57.010
好 然后呢 重新设置状态 那么同样的啊 也是

22:57.810 --> 22:58.530
wide反向

22:59.810 --> 23:03.650
好 那么这样子呢 我们就搞定了反向的情况 到边界的情况

23:04.050 --> 23:09.010
那么其他情况呢 都是正常的情况 速度不需要反向啊 速度不需要改变

23:09.010 --> 23:14.290
所以说其他的情况呢 我们都统一设置啊 统一设置 就是 this state

23:14.290 --> 23:15.170
set state

23:16.290 --> 23:20.610
重新设置状态 状态里边 是不是要改变横重的落标 对吧

23:20.610 --> 23:24.290
横坐标等于啥呢 等于新的new the left

23:24.290 --> 23:27.890
横坐标 然后重坐标等于啥呢 new the top

23:29.170 --> 23:30.050
新的重坐标

23:30.770 --> 23:34.690
好 就完了 你看一下 我们这里就启动了这个计时器

23:34.690 --> 23:39.730
根据我们指定的速度啊 来算出位移 根据位移 算出新的坐标

23:39.730 --> 23:43.170
然后判断一下边界的情况 然后最后呢 把坐标覆盖进去

23:43.890 --> 23:45.010
保存 看一下吧

23:46.690 --> 23:47.170
好 你看

23:48.290 --> 23:52.370
是不是根据我们的速度啊 根据我们设置的速度 这不就按照我们的

23:52.370 --> 23:54.530
设置的速度来进行运动了 看到没

23:55.490 --> 23:59.010
哎 这样子就出来了 这么一个效果

24:00.770 --> 24:05.970
好 所以这一刻呢 这个练习呢 主要是练习一下我们的状态啊 对状态的控制

24:05.970 --> 24:11.090
那比方说啊 我们这里呢 你看啊 这里呢 可以进行各种各样的调整

24:11.090 --> 24:14.370
比方 x 为300 y 为400 保存

24:15.650 --> 24:19.330
啊 你看 速度变快了 对吧 速度变快了

24:20.290 --> 24:26.290
啊 ok 那我们现在有了有了这个组件之后呢 后续的操作呢就可以非常非常丰富了

24:26.290 --> 24:29.490
比方说我们可以再写一个组件 叫做 ball list

24:30.370 --> 24:39.570
啊 ball list 你知道我要干嘛了对吧 我可以设置多个啊 多个就是小球啊 可以设置多个小球

24:40.130 --> 24:43.890
好 比方说我们这里还是设置一个rcc

24:44.450 --> 24:48.850
啊 这个地方呢 为什么要我要把它使用成一个内组件呢

24:48.930 --> 24:55.330
是因为我觉得啊 这里边肯定要维护一个啥 维护一个小球的数组啊 小球的组件数组

24:55.490 --> 24:59.410
我们肯定要维护这么一个东西 所以说呢 我们这里呢

24:59.970 --> 25:05.650
把它设置为这么一个就是啊 这么一个内组件 内组件里面才有自己的状态对吧

25:05.650 --> 25:09.330
它自我维护小球的数组啊 这个东西是

25:10.370 --> 25:13.970
自动啊 每隔一段时间

25:14.690 --> 25:21.330
自动产生一个小球啊 各种各种数据

25:22.210 --> 25:24.290
随机啊 各种数据全部随机

25:25.570 --> 25:32.610
好 然后呢 我们这里这帮这么来玩啊 真的玩就用做法很多啊 做法很多啊 这里呢constructor

25:36.670 --> 25:38.270
probs

25:38.510 --> 25:40.110
super

25:40.110 --> 25:41.870
probs

25:42.030 --> 25:46.910
好 这里呢 这是stats 初始化一个状态 这个状态里边呢 就一个东西

25:47.630 --> 25:53.230
就是小球的信息啊 小球的信息 就是4

25:55.470 --> 25:59.630
in 4 嗯 这里边存放啥呢 in force

26:00.350 --> 26:02.350
这里边存放啥呢 这里面是一个数组

26:02.750 --> 26:10.190
它存放的是每一个小球的一些属性的对象啊 每个小球比方说啊 第一个小球的属性对象

26:10.510 --> 26:18.910
它的left值是多少啊 top值是多少啊 然后呢 什么颜色 bg 是什么什么对吧

26:19.230 --> 26:21.870
然后呢 还有什么还有什么还有什么

26:22.750 --> 26:28.350
还有那个x speed啊 x speed啊 是多少 所以把这些信息全部存放到这个数组里面

26:28.670 --> 26:30.430
当然那个数组里面甚至可以直接

26:31.230 --> 26:37.470
直接存放什么 直接存放不啊 是不是可以直接存放不对不对啊 可以直接存放

26:38.430 --> 26:42.830
啊 把这 这里把导入进来啊 import

26:43.550 --> 26:51.550
不 from 第二写上不啊 可以直接存放这个东西 也行啊 也行 看你自己啊 看你自己啊 比方说吧

26:52.190 --> 26:55.470
呃 我们这里呢 就是把它存放信息嘛 一个对象信息

26:55.870 --> 26:59.950
好 比方说每个一秒钟啊 每个一秒钟set interval

27:00.510 --> 27:06.430
每个一秒钟来产生一个小球啊 所有东西全部水积啊 各种东西全部水积

27:06.910 --> 27:12.750
好 我们这里呢 呃 因为要设立到水积数 所以说 我们这里呢 可以专门来写一个js啊

27:12.830 --> 27:14.830
这个js呢 把它取名为ut

27:15.550 --> 27:21.630
ut 叫js 这个js里边专门来提供一些函数 来够能够帮助

27:21.710 --> 27:25.630
辅助了我们的功能 我们这里导出一个函数啊 方形

27:26.510 --> 27:28.910
get write 得到一个水积数

27:29.630 --> 27:34.510
给我一个最小值 给我一个最大值 这个东西应该用过很多很多遍了啊 我就不再说了

27:34.830 --> 27:36.830
mass flow

27:37.470 --> 27:43.150
然后呢 mass 点write 成义什么呢 成义 max 解密

27:43.870 --> 27:49.710
解密啊 当然如果你要能够 如果你要能够取到最大值的话得加一过后解密

27:50.270 --> 27:51.790
好 然后呢 呃

27:52.510 --> 27:54.510
加上啊 加上密

27:55.630 --> 27:56.270
啊 这样子

27:57.150 --> 27:59.870
没问题吧啊 这里产生一个水积数啊

28:00.270 --> 28:03.630
好 我们这里呢 就是把这个导入进来啊 import

28:04.830 --> 28:05.630
ut

28:06.270 --> 28:07.070
ut

28:08.110 --> 28:10.590
这样导入啊 get write

28:14.160 --> 28:14.960
from

28:16.160 --> 28:20.400
上一个上已经目录的ut 把导入进来 这个get write 等函数

28:20.800 --> 28:26.240
好 然后每隔一秒钟呢 我们来产生一个对象啊 产生一个对象 info

28:27.120 --> 28:32.480
这个对象里边呢 首先 left 值啊 横坐标随机的啊 横坐标随机的

28:32.960 --> 28:37.600
啊 这个随机的横坐标呢 它的取值范围是多少呢 它的取值范围是这样子

28:38.240 --> 28:45.360
嗯 我们这里呢 get write 等 最小值呢 肯定是零 最大值呢 是整个四口的宽度

28:45.760 --> 28:49.040
减去小球的宽度一百 对吧 document

28:49.520 --> 28:55.280
啊 就是啊 document element client with 减去一百

28:56.160 --> 29:00.560
好 这是横坐标的啊 随机范围 top 值呢 复制一下啊

29:01.520 --> 29:08.560
top 值呢 也是零 然后是client height 高度减去一百

29:09.360 --> 29:14.560
好 继续来啊 然后呢 速度x speed 那我们这里自行规定一下啊

29:15.600 --> 29:20.320
速度呢 是零到啊 不能零 零就不动了 对吧 零就不动了

29:20.720 --> 29:29.200
比方说速度是50到多少呢 50到500啊 50到500之间你取一个x的速度 y 的 y 的速度

29:29.840 --> 29:34.800
是b的啊 get write 50到500啊

29:35.440 --> 29:43.280
这是产生一个随机的速度 然后背景颜色啊 bg 随机啊 背景颜色也随机 get write 这样子

29:43.360 --> 29:49.520
背景颜色呢 是一个字母串啊 随机 随机的话就 rgb 啊 rgb 然后呢 这里

29:50.400 --> 29:56.080
第一个值 第二个值 第三个值 第一个值能来自于随机的get write 等

29:56.560 --> 30:02.080
0到255啊 0到255

30:03.840 --> 30:07.200
好 这一部分随机啊 这一部分随机啊

30:08.000 --> 30:13.120
行了 背景也随机了啊 背景也随机了啊 这就是一个随机的信息啊 一个信息

30:13.680 --> 30:17.040
好 我们把这个对象呢 加到哪去呢 就加到这个数组里边去

30:18.000 --> 30:19.120
加到数组里边去

30:20.160 --> 30:28.480
this state set state 注意啊 改变状态只能用这个属性啊 只能用这个方法来改变状态

30:29.760 --> 30:33.600
设置重新设置状态 它的什么 bore info

30:34.880 --> 30:40.720
重新给它复制 重新给它复制 就是往那个数组里边加一下 你千万不能这样写啊

30:41.280 --> 30:46.800
千万千万不能这样子写 这样子写是不是改变了原用的状态了 对吧

30:47.120 --> 30:54.240
不能直接改变原用状态啊 千万不能直接改变原用状态 应该是重新给它这个数组复制 那怎么来复制呢

30:54.960 --> 30:57.040
怎么来复制 我们可以用这种方式

30:57.920 --> 31:06.240
不是我们学过那个就是展开运算符吗 把这个数组里边把原来的数组里边这个 bore info 展开

31:06.720 --> 31:13.680
原来的数据展开 然后再来加一项数据什么 info 对吧 给它加一项数据 这样子来重新设置状态

31:14.640 --> 31:20.400
没问题吧 这样子就每隔一段时间给它加了一个就是数组 加了一个对象进去

31:21.280 --> 31:27.120
好 在显示的时候怎么显示呢 显示的时候呢 我们就根据这个数组

31:28.240 --> 31:30.080
拿到这个数组什么 bore info

31:31.040 --> 31:37.680
把它映射成为什么 映射成为一个一个的 就是每数组里面每一个对象是不是映射成一个 bore 的

31:38.160 --> 31:41.760
就是小球的组件 对吧 把它映射成一个组件

31:42.240 --> 31:46.880
好 item 映射成一个组件 什么组件呢 就是 bore

31:49.680 --> 31:56.000
不把映射成一个组件 这个组件里边的属性呢 是不是把这个展开 对吧 把这个

31:57.040 --> 32:03.520
item 展开 我们之前是不是学过的 把这个对象里边的所有属性展开 放作为它的属性放到这个这里边

32:04.000 --> 32:08.560
好 于是呢 这句话运行完了之后 是不是得到了得到了一个啥 是不是得到了一个就是

32:09.520 --> 32:18.000
就是那个小球的数组 对不对 小球的数组 那么接下来呢 我们要做的事情就是 不需要这个dib啊 不需要这个dib

32:18.960 --> 32:25.120
我们要做的事情就是 把这个小球的数组放进来 但是不要忘记的 还有keyz 对不对 还有keyz

32:26.000 --> 32:29.520
keyz的话 我们就用i嘛 就是i 就是它的下标

32:30.080 --> 32:33.520
好 这里呢 keyz 就用它的下标

32:34.960 --> 32:37.680
好了 就写好了 看呗 好好看一下啊

32:38.960 --> 32:42.880
应该没问题吧 你们学到现在呢 这样的逻辑应该是具备的啊

32:43.680 --> 32:50.320
好 这样子设置好了过后了 我们在index里边呢 就不是不是去导入这个了啊 bore list 导入这个东西

32:51.600 --> 32:54.480
我们这里呢 只需要去宣传这个玩意 这个玩意就行了

32:56.770 --> 32:58.370
好 bore list

32:59.810 --> 33:06.420
next 好 只需要宣传它就行了 保存你看一下 好你看一下

33:07.540 --> 33:11.540
啊 是不是有各种各样的小球 对吧 颜色随机啊 然后呢

33:12.020 --> 33:15.940
它的就是速度啊 位置啊 这些都随机 然后它自己在里面移动

33:16.260 --> 33:19.700
当然我这里没有去做什么小球 预小球碰撞啊 就没有去做了

33:20.820 --> 33:26.260
没问题吧 当然我们这里可以控制一下啊 不然越来越多 越来越多 这个就越来越卡

33:26.420 --> 33:31.540
我们可以控制一下 如果这个数组里比较长度达到某一个值 就不要再动了啊 就不要再动了

33:31.700 --> 33:33.700
比方说 我们这里呢 设置一个啊

33:34.660 --> 33:36.660
设置一个 timeer

33:38.020 --> 33:43.060
timeer 对吧 好 然后呢 判断一下啊 如果res state 的 bore

33:43.620 --> 33:46.660
inforce 的 lance 如果等于呢

33:48.820 --> 33:54.980
30个 30个也太多了 10个小球嘛 10个小球过后呢 我们就clear interval timeer

33:55.940 --> 33:57.300
把这个g17清空

33:58.660 --> 33:59.700
保存好

34:01.140 --> 34:04.260
啊 看一下一个3个 4个 5个

34:05.220 --> 34:07.060
6个啊

34:07.700 --> 34:12.900
然后7个 我就数清楚了啊 总之呢 他就不再产生了啊 可没 他就不再产生了

34:14.180 --> 34:22.580
好 这就是用组建化的方式来开发这么一个效果 注意呢 现在我们这两个组建 他都有各自有各自的状态 因为他需要自我维护

34:23.300 --> 34:31.540
好吧 下来当下来的 大家把它练习一下啊 练习一下这么一个例子来体会一下这个状态 怎么去自我控制

34:32.660 --> 34:34.260
好 这是这么一个小的

