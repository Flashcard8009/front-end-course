WEBVTT

00:00.500 --> 00:04.500
这也看了 怎么来讲Redux的最后一个功能

00:04.500 --> 00:07.500
你看Redux里面 它没有给我们提供多少东西

00:07.500 --> 00:13.500
就是一个创建仓库 组合Reduser 绑定Action

00:13.500 --> 00:16.500
就提供这么一些函数

00:16.500 --> 00:22.500
然后它还给我们提供了最后一个功能 就是中间键的功能

00:22.500 --> 00:25.500
那么中间键到底是什么玩意呢 它的单词叫做Medware

00:25.500 --> 00:29.500
这个单词你们以后在旋漏的解释的时候还会遇到

00:29.500 --> 00:34.500
不过肯定跟Redux多多少次有一些差异

00:34.500 --> 00:40.500
但是它的概念了差不多 中间键什么意思呢

00:40.500 --> 00:44.500
中间键你可以理解为 类似于插件

00:44.500 --> 00:53.500
然后可以再不影响原本功能的基础上

00:53.500 --> 00:58.500
就是它不会影响原本的功能 并且不改动

00:58.500 --> 01:03.500
不改动原本代码 不影响原本功能

01:03.500 --> 01:15.500
不改动原本代码的基础上对其功能进行增强

01:15.500 --> 01:17.500
你可以这样去理解

01:17.500 --> 01:21.500
就比方说像我们Redux里面

01:21.500 --> 01:23.500
我们之前也写过很多的代码

01:24.500 --> 01:26.500
特别是CreatorStone里面的代码

01:26.500 --> 01:29.500
就创建一个仓库 这些代码我们都写好了

01:29.500 --> 01:33.500
那么我们如何再不改动代码基础上

01:33.500 --> 01:36.500
来增强它的一些功能

01:36.500 --> 01:38.500
这就是中间键要考虑的事情

01:38.500 --> 01:41.500
包括你们以后学习的Rodges

01:41.500 --> 01:43.500
一些服务器专的框架

01:43.500 --> 01:46.500
Express、KoA这些东西

01:46.500 --> 01:47.500
他们也有自己的中间键

01:47.500 --> 01:50.500
不过他们的概念多多少次也是有些区别的

01:50.500 --> 01:54.500
咱们先按照这种模式来想

01:54.500 --> 01:57.500
认识大概这么一个概念

01:57.500 --> 02:00.500
它是在增强Rodges的功能的

02:00.500 --> 02:04.500
由于它不会影响原本的代码

02:04.500 --> 02:06.500
也不会影响原本的功能

02:06.500 --> 02:08.500
所以说中间键你可以认为

02:08.500 --> 02:11.500
跟Rodges本身其他的功能是独立开的

02:11.500 --> 02:13.500
既然它独立开的话

02:13.500 --> 02:16.500
它就容易形成第三方库

02:16.500 --> 02:18.500
Rodges的原本缺失一些功能

02:18.500 --> 02:20.500
或者它没有处理一些事情

02:20.500 --> 02:22.500
或者说有一些特殊的场景下面

02:22.500 --> 02:24.500
我们要额外做一些事情

02:24.500 --> 02:26.500
那么我们就可以利用中间键

02:26.500 --> 02:28.500
像一个插件一样去增强它的功能

02:28.500 --> 02:30.500
是这么个意思

02:30.500 --> 02:32.500
因此中间键它有很多的第三方库

02:32.500 --> 02:34.500
像我们下一个章节

02:34.500 --> 02:36.500
会专门拿一个章节来说

02:36.500 --> 02:38.500
我们常用的一些

02:38.500 --> 02:39.500
大概是中间键

02:39.500 --> 02:41.500
所以中间键的内容是非常非常多的

02:41.500 --> 02:44.500
因为它实际上是一个功能扩展点

02:44.500 --> 02:45.500
我们通过这个点

02:45.500 --> 02:47.500
就可以扩展各种各样的功能

02:47.500 --> 02:49.500
是这么个意思

02:49.500 --> 02:51.500
然后中间键这一块

02:51.500 --> 02:55.500
它是Rodges里面最难的部分

02:55.500 --> 02:57.500
最不好理解的部分

02:57.500 --> 02:59.500
你要说我们直接使用

02:59.500 --> 03:02.500
第三方给你写好的中间键的话

03:02.500 --> 03:04.500
难度到没有那么高

03:04.500 --> 03:06.500
你就使用别人写好的

03:06.500 --> 03:08.500
你怎么去使用就完事了

03:08.500 --> 03:10.500
但是这一个章节

03:10.500 --> 03:12.500
这一个章节我们不会设计到

03:12.500 --> 03:13.500
任何的第三方库

03:13.500 --> 03:15.500
像别人写好的中间键我们不会用

03:15.500 --> 03:17.500
我们都会自己写中间键

03:17.500 --> 03:18.500
为什么呢

03:18.500 --> 03:19.500
因为这个章节我们讲的是

03:19.500 --> 03:20.500
最核心的功能

03:20.500 --> 03:22.500
它本身自带的功能

03:22.500 --> 03:23.500
中间键它本来就是

03:23.500 --> 03:25.500
给你带好的功能

03:25.500 --> 03:29.500
你可以利用它来做一些功能扩展

03:29.500 --> 03:31.500
所以说我们这一个章节

03:31.500 --> 03:32.500
要学习自己如何来

03:32.500 --> 03:34.500
去书写一个中间键

03:34.500 --> 03:36.500
这个中间键这一块

03:36.500 --> 03:37.500
在目前这个章节里边

03:37.500 --> 03:39.500
我们打算分为两节客

03:39.500 --> 03:41.500
第一节客就是我们这节客

03:41.500 --> 03:43.500
讲如何自己去写一个中间键

03:43.500 --> 03:45.500
来扩展他的功能

03:45.500 --> 03:48.500
下一节客呢是一个扩展课程

03:48.500 --> 03:49.500
下一节客呢我们来讲

03:49.500 --> 03:51.500
绿大克斯里边

03:51.500 --> 03:53.500
怎么来

03:53.500 --> 03:55.500
就是怎么来

03:55.500 --> 03:57.500
就是把我们写的中间键

03:57.500 --> 03:58.500
融入到绿大克斯里边

03:58.500 --> 04:00.500
就是绿大克斯原码部分了

04:00.500 --> 04:01.500
所以说我们这里

04:01.500 --> 04:03.500
会分成两节客来讲

04:03.500 --> 04:04.500
但是呢这两节客

04:04.500 --> 04:05.500
我先跟大家打个预防针

04:05.500 --> 04:07.500
会特别特别难

04:07.500 --> 04:09.500
它既难又绕

04:09.500 --> 04:11.500
而且又不好理解

04:11.500 --> 04:13.500
但是呢大家心里面

04:13.500 --> 04:14.500
不要有压力

04:14.500 --> 04:16.500
就算这两节客

04:16.500 --> 04:18.500
你啥都没学懂

04:18.500 --> 04:20.500
你到了下一个章节

04:20.500 --> 04:21.500
下一个章节

04:21.500 --> 04:22.500
我们是讲第三方

04:22.500 --> 04:23.500
已经写好的中间键

04:23.500 --> 04:24.500
那么我们怎么去使用

04:24.500 --> 04:25.500
到下一个章节

04:25.500 --> 04:26.500
你知道怎么去用

04:26.500 --> 04:28.500
这些第三方的中间键就行了

04:28.500 --> 04:30.500
因为在公司里边

04:30.500 --> 04:32.500
如果说你要自己写中间键

04:32.500 --> 04:34.500
这种场景的比较少

04:34.500 --> 04:35.500
比较少

04:35.500 --> 04:36.500
因为特别是对于

04:36.500 --> 04:38.500
刚刚毕业的同学的话

04:38.500 --> 04:39.500
这些中间键的场景

04:39.500 --> 04:40.500
几乎是没有

04:40.500 --> 04:41.500
所以说呢大家

04:41.500 --> 04:42.500
不用太过于担心

04:42.500 --> 04:43.500
但是呢这两节客

04:43.500 --> 04:44.500
你要说他重要吗

04:44.500 --> 04:45.500
他也重要

04:45.500 --> 04:46.500
因为你学的这两节客

04:46.500 --> 04:47.500
你会对中间键

04:47.500 --> 04:49.500
产生非常非常清晰的认识

04:49.500 --> 04:50.500
但是呢

04:50.500 --> 04:52.500
你不是那么容易听的懂

04:52.500 --> 04:54.500
但是你给大家打个预防针

04:54.500 --> 04:55.500
有时候可能

04:55.500 --> 04:56.500
上完这两节客

04:56.500 --> 04:57.500
一下子就蒙了

04:57.500 --> 04:58.500
完全蒙全了

04:58.500 --> 04:59.500
没关系

04:59.500 --> 05:00.500
如果说你实在老虎

05:00.500 --> 05:02.500
那么你可以从下个章节

05:02.500 --> 05:03.500
直接看

05:03.500 --> 05:04.500
比人的写好的中间键

05:04.500 --> 05:05.500
怎么去使用就完事了

05:05.500 --> 05:07.500
好吧

05:07.500 --> 05:08.500
这是我们这一章节

05:08.500 --> 05:10.500
我们讲中间键这一块

05:10.500 --> 05:11.500
我首先在课前

05:11.500 --> 05:12.500
要说的那一种

05:12.500 --> 05:14.500
咱们这个章节只学新两节客

05:14.500 --> 05:16.500
一个是自己怎么写中间键

05:16.500 --> 05:17.500
第二个呢

05:17.500 --> 05:18.500
Ridax原码部分

05:18.500 --> 05:19.500
他怎么去把中间键

05:19.500 --> 05:20.500
应用进去

05:20.500 --> 05:22.500
OK

05:22.500 --> 05:23.500
首先呢

05:23.500 --> 05:24.500
这个中间键在Ridax里边

05:24.500 --> 05:26.500
我们再详细说一下

05:26.500 --> 05:28.500
它的主要作用是增强功能

05:28.500 --> 05:29.500
对吧

05:29.500 --> 05:30.500
那么增强什么功能了

05:30.500 --> 05:32.500
在Ridax中

05:32.500 --> 05:33.500
Ridax中

05:33.500 --> 05:35.500
中间键

05:35.500 --> 05:38.500
主要用于增强

05:38.500 --> 05:40.500
增强

05:40.500 --> 05:42.500
Dispatch功能

05:42.500 --> 05:44.500
增强Dispatch函数

05:44.500 --> 05:45.500
因为我们知道

05:45.500 --> 05:46.500
仓库里边

05:46.500 --> 05:48.500
不是有一个Dispatch函数吗

05:48.500 --> 05:49.500
你看看

05:49.500 --> 05:51.500
我们之前创建的仓库

05:51.500 --> 05:52.500
仓库里边

05:52.500 --> 05:53.500
是不是有一个Dispatch函数

05:53.500 --> 05:54.500
对吧

05:54.500 --> 05:55.500
这个Dispatch函数

05:55.500 --> 05:56.500
我们之前做的很简单

05:56.500 --> 05:58.500
非常非常简单

05:58.500 --> 05:59.500
非常简单

05:59.500 --> 06:00.500
这个函数里边

06:00.500 --> 06:02.500
我们做了什么事情

06:02.500 --> 06:03.500
我就是

06:03.500 --> 06:04.500
验证了一下

06:04.500 --> 06:05.500
然后把它交给Ridax

06:05.500 --> 06:06.500
对吧

06:06.500 --> 06:07.500
之前我们有画过图

06:07.500 --> 06:09.500
画过这个图

06:09.500 --> 06:11.500
Dispatch的作用就是什么

06:11.500 --> 06:12.500
就是把ActionState

06:12.500 --> 06:13.500
交给Ridax

06:13.500 --> 06:14.500
得到新数据

06:14.500 --> 06:16.500
它们要做任何其他事情

06:16.500 --> 06:18.500
来把新数据保存起来

06:18.500 --> 06:20.500
它们要做任何其他事情

06:20.500 --> 06:21.500
因此

06:21.500 --> 06:22.500
这个Dispatch

06:22.500 --> 06:23.500
如果说你还要做

06:23.500 --> 06:24.500
一些额外的事情的话

06:24.500 --> 06:25.500
你不是很方便做

06:25.500 --> 06:26.500
你没有了

06:26.500 --> 06:27.500
不是很方便做

06:27.500 --> 06:29.500
那么如果说

06:29.500 --> 06:30.500
我们要增强Dispatch

06:30.500 --> 06:31.500
怎么来做呢

06:31.500 --> 06:33.500
就要使用中间键

06:33.500 --> 06:35.500
就要使用中间键了

06:35.500 --> 06:37.500
好 那么具体怎么来

06:37.500 --> 06:39.500
具体的原理是什么呢

06:39.500 --> 06:41.500
因为我们这里毕竟是

06:41.500 --> 06:43.500
不涉及第三方库

06:43.500 --> 06:44.500
所以说

06:44.500 --> 06:45.500
我们要自己写中间键

06:45.500 --> 06:47.500
你得知道它的原理

06:47.500 --> 06:49.500
原理是什么呢

06:49.500 --> 06:51.500
原理是

06:51.500 --> 06:53.500
更改Dispatch函数

06:55.500 --> 06:57.500
实现中间键

06:57.500 --> 06:59.500
实现Ridax

06:59.500 --> 07:02.500
中间键的原理

07:02.500 --> 07:04.500
的基本原理

07:04.500 --> 07:05.500
是

07:05.500 --> 07:07.500
更改

07:07.500 --> 07:11.500
仓库中的Dispatch函数

07:11.500 --> 07:12.500
Dispatch函数

07:12.500 --> 07:14.500
然后我这里给大家写一个吧

07:14.500 --> 07:15.500
写一个如何来

07:15.500 --> 07:16.500
更改Dispatch函数

07:16.500 --> 07:17.500
举个例子

07:17.500 --> 07:18.500
比方说

07:18.500 --> 07:19.500
我们这里

07:19.500 --> 07:21.500
有这么一个仓库

07:21.500 --> 07:22.500
那之前

07:22.500 --> 07:23.500
我们不是加了接近期吗

07:23.500 --> 07:24.500
对不对

07:24.500 --> 07:26.500
每次数据改变

07:26.500 --> 07:28.500
每一次数据改变

07:28.500 --> 07:29.500
我都会呢

07:29.500 --> 07:31.500
接近期都会收到这个通知

07:31.500 --> 07:32.500
咱们来看一下吧

07:32.500 --> 07:34.500
这是咱们之前加的接近期

07:36.500 --> 07:37.500
接下来

07:37.500 --> 07:38.500
Cd

07:42.500 --> 07:43.500
让它运营起来

07:43.500 --> 07:44.500
你看一下

07:44.500 --> 07:45.500
创建了一个仓库

07:45.500 --> 07:46.500
对吧

07:46.500 --> 07:47.500
仓库里面说

07:47.500 --> 07:48.500
带了一个Dispatch

07:48.500 --> 07:49.500
对不对

07:49.500 --> 07:50.500
带了一个Dispatch

07:50.500 --> 07:51.500
然后呢

07:51.500 --> 07:52.500
然后呢

07:52.500 --> 07:53.500
我们这里绑定了一个IgC

07:53.500 --> 07:55.500
当然不绑定也无所谓

07:55.500 --> 07:57.500
绑定了方便的改变数据

07:58.500 --> 07:59.500
然后呢

07:59.500 --> 08:00.500
我们这里加个接近期

08:00.500 --> 08:01.500
然后呢

08:01.500 --> 08:02.500
这里我们改变了两次数据

08:02.500 --> 08:03.500
我们来看一下

08:03.500 --> 08:04.500
接近期呢

08:04.500 --> 08:05.500
它会运行两次

08:05.500 --> 08:06.500
它都会得到运行

08:06.500 --> 08:07.500
对吧

08:07.500 --> 08:08.500
那么在接近期里面

08:08.500 --> 08:09.500
我们得到了就是

08:09.500 --> 08:11.500
每一次改变之后

08:11.500 --> 08:12.500
新的数据

08:12.500 --> 08:13.500
新的数据

08:13.500 --> 08:14.500
那如果说

08:14.500 --> 08:16.500
现在我们有这么一个要求

08:16.500 --> 08:17.500
注意听啊

08:17.500 --> 08:18.500
这里一定要注意听

08:18.500 --> 08:19.500
稍微补胜

08:19.500 --> 08:20.500
稍微走神

08:20.500 --> 08:22.500
也不知道我来说什么了

08:22.500 --> 08:23.500
我们现在

08:23.500 --> 08:25.500
假设接近期有这么一个要求

08:25.500 --> 08:26.500
就是我要得到啥呢

08:26.500 --> 08:27.500
我要得到

08:27.500 --> 08:29.500
这里要输出之前的数据

08:30.500 --> 08:32.500
输出之前的状态

08:33.500 --> 08:34.500
然后呢

08:34.500 --> 08:35.500
输出

08:36.500 --> 08:38.500
新的状态

08:38.500 --> 08:40.500
不但要输出之前的状态

08:40.500 --> 08:42.500
还要输出新的状态

08:42.500 --> 08:43.500
还要输出什么呢

08:43.500 --> 08:44.500
还要输出

08:44.500 --> 08:45.500
就是

08:45.500 --> 08:47.500
触发的IgC

08:48.500 --> 08:49.500
就是在我要接近期里面

08:49.500 --> 08:50.500
我要输出之前的状态

08:50.500 --> 08:51.500
要输出新的状态

08:51.500 --> 08:52.500
之前是啥

08:52.500 --> 08:53.500
新的状态是啥

08:53.500 --> 08:54.500
触发了什么IgC

08:54.500 --> 08:55.500
导致的状态变化

08:55.500 --> 08:56.500
我们要做这样的技术

08:57.500 --> 08:59.500
你看监禁器能办到吗

08:59.500 --> 09:00.500
能办到吗

09:00.500 --> 09:01.500
你想一想

09:01.500 --> 09:03.500
你之前写过有当时的原码

09:03.500 --> 09:04.500
它能办到吗

09:04.500 --> 09:06.500
它办不到

09:06.500 --> 09:07.500
办不到

09:07.500 --> 09:08.500
为什么呢

09:08.500 --> 09:09.500
你看有当时的原码

09:09.500 --> 09:10.500
它监禁器是什么时候运行的

09:10.500 --> 09:11.500
是不是在dispatch的时候

09:11.500 --> 09:12.500
一个循环运行的

09:12.500 --> 09:14.500
没有给它传递任何参数

09:14.500 --> 09:16.500
那么这个时候运行

09:16.500 --> 09:17.500
监禁器的时候

09:17.500 --> 09:19.500
是不是数据已经发生变化了

09:19.500 --> 09:21.500
你要再得到之前的数据

09:21.500 --> 09:22.500
可能吗

09:22.500 --> 09:23.500
是不是不可能

09:23.500 --> 09:24.500
对吧

09:24.500 --> 09:26.500
你上面的验证你都不看

09:26.500 --> 09:27.500
验证都不看

09:27.500 --> 09:28.500
你看是不是已经触发了数据变化了

09:28.500 --> 09:30.500
得到新的数据了

09:30.500 --> 09:32.500
那么你这个时候

09:32.500 --> 09:36.500
再去拿之前的数据

09:36.500 --> 09:37.500
你发现拿不到

09:37.500 --> 09:39.500
根本就拿不到

09:39.500 --> 09:40.500
那怎么办

09:40.500 --> 09:43.500
监禁器不行了

09:43.500 --> 09:44.500
监禁器的作用

09:44.500 --> 09:47.500
其实仅仅是为了让你在

09:47.500 --> 09:48.500
数据变化的时候

09:48.500 --> 09:50.500
收到一个通知

09:50.500 --> 09:51.500
但是收到通知过后

09:51.500 --> 09:52.500
如果说

09:52.500 --> 09:53.500
你还要去得到之前的数据

09:53.500 --> 09:55.500
得到埃克兴是啥

09:55.500 --> 09:57.500
你拿不到

09:57.500 --> 09:59.500
那怎么办呢

09:59.500 --> 10:00.500
怎么办呢

10:00.500 --> 10:01.500
你看着

10:01.500 --> 10:02.500
我现在可以使用

10:02.500 --> 10:06.500
一种别的方式

10:06.500 --> 10:08.500
我什么地方可以

10:08.500 --> 10:09.500
非常轻松的拿到

10:09.500 --> 10:11.500
之前的数据和埃克兴呢

10:11.500 --> 10:12.500
就是第十八期

10:12.500 --> 10:13.500
因为你分发一个

10:13.500 --> 10:14.500
分发一个埃克兴的时候

10:14.500 --> 10:15.500
是不是埃克兴就

10:15.500 --> 10:16.500
为参数传进来了

10:16.500 --> 10:17.500
对吧

10:17.500 --> 10:18.500
而就是个第十八期的寒数

10:18.500 --> 10:21.500
那么这个寒数里面

10:21.500 --> 10:22.500
是不是可以非常轻松拿到

10:22.500 --> 10:23.500
之前的数据

10:23.500 --> 10:25.500
已经拿到什么埃克兴对吧

10:25.500 --> 10:26.500
那如果说

10:26.500 --> 10:27.500
我们在第十八期里面

10:27.500 --> 10:28.500
就是在Crazy Stone

10:28.500 --> 10:29.500
我们之前写过的一个代码

10:29.500 --> 10:30.500
所以说

10:30.500 --> 10:31.500
为什么我要先讲代码

10:31.500 --> 10:32.500
先讲原码

10:32.500 --> 10:33.500
我在讲那个MadeWare

10:33.500 --> 10:34.500
就是这样的好分析

10:34.500 --> 10:35.500
如果说

10:35.500 --> 10:36.500
我们在第十八期里面

10:36.500 --> 10:38.500
我们如果要把这个

10:38.500 --> 10:39.500
就是日治功能

10:39.500 --> 10:40.500
加到第十八期里面

10:40.500 --> 10:41.500
是不是就很简单

10:41.500 --> 10:42.500
对吧

10:42.500 --> 10:43.500
到这里边就很简单

10:43.500 --> 10:44.500
我要拿到

10:44.500 --> 10:45.500
之前的状态

10:45.500 --> 10:46.500
来吧你看着

10:48.500 --> 10:49.500
这里

10:49.500 --> 10:51.500
之前的数据

10:51.500 --> 10:53.500
或者就数据

10:54.500 --> 10:55.500
就数据

10:55.500 --> 10:56.500
然后拼接一下

10:56.500 --> 10:57.500
拼接一下

10:57.500 --> 10:59.500
就数据就是什么

10:59.500 --> 11:00.500
current

11:00.500 --> 11:01.500
current state

11:01.500 --> 11:02.500
就就数据

11:02.500 --> 11:03.500
当然也可以叫

11:03.500 --> 11:04.500
get state

11:04.500 --> 11:05.500
一样的

11:05.500 --> 11:06.500
是同一个东西

11:06.500 --> 11:07.500
是同一个东西

11:07.500 --> 11:08.500
就是就数据

11:08.500 --> 11:09.500
好

11:09.500 --> 11:10.500
那么

11:10.500 --> 11:11.500
然后我们触发的

11:11.500 --> 11:12.500
埃克兴

11:12.500 --> 11:13.500
是不是可以说说

11:13.500 --> 11:14.500
埃克兴

11:14.500 --> 11:16.500
再打个帽号

11:16.500 --> 11:17.500
埃克兴是

11:17.500 --> 11:18.500
是不是

11:18.500 --> 11:19.500
就是这里埃克兴

11:19.500 --> 11:20.500
对不对

11:20.500 --> 11:21.500
这里

11:21.500 --> 11:22.500
尽量不要拼接

11:22.500 --> 11:23.500
不要拼接

11:24.500 --> 11:25.500
因为拼接的话

11:25.500 --> 11:26.500
不是用对象的格式展示的

11:26.500 --> 11:27.500
current

11:27.500 --> 11:28.500
就get state

11:28.500 --> 11:29.500
吧

11:29.500 --> 11:30.500
用这个

11:30.500 --> 11:31.500
拿到当前的数据

11:31.500 --> 11:32.500
埃克兴呢

11:32.500 --> 11:33.500
我们这里

11:33.500 --> 11:34.500
来这里

11:34.500 --> 11:35.500
拿到这个参数埃克兴

11:35.500 --> 11:36.500
是吧

11:36.500 --> 11:37.500
全可以拿到对吧

11:37.500 --> 11:38.500
然后我们得到

11:38.500 --> 11:39.500
行者数据过后

11:39.500 --> 11:40.500
调到reducer过后

11:40.500 --> 11:41.500
我们是不是又可以输出

11:41.500 --> 11:42.500
新数据

11:43.500 --> 11:44.500
新数据

11:44.500 --> 11:45.500
把帽号去掉吧

11:47.500 --> 11:48.500
好

11:48.500 --> 11:49.500
新数据

11:49.500 --> 11:50.500
也是get state

11:50.500 --> 11:51.500
因为你调到reducer之后

11:51.500 --> 11:52.500
是拿到新数据了

11:52.500 --> 11:53.500
对不对

11:53.500 --> 11:54.500
这是新数据

11:55.500 --> 11:56.500
保存

11:56.500 --> 11:57.500
咱们来看一下

11:57.500 --> 11:58.500
你看

11:58.500 --> 12:00.500
每一次数据发生变化

12:00.500 --> 12:01.500
它都会有

12:01.500 --> 12:02.500
这样的触发

12:02.500 --> 12:03.500
看到没

12:03.500 --> 12:04.500
都会有这样的触发

12:04.500 --> 12:05.500
就数据

12:05.500 --> 12:06.500
怎么样怎么样

12:06.500 --> 12:07.500
是undefend

12:07.500 --> 12:08.500
就数据是undefend

12:08.500 --> 12:09.500
然后呢

12:09.500 --> 12:10.500
埃克兴呢

12:10.500 --> 12:11.500
给他传了一个

12:11.500 --> 12:12.500
就是这个东西

12:12.500 --> 12:13.500
对吧

12:13.500 --> 12:14.500
然后新的数据呢

12:14.500 --> 12:15.500
得到的结果是这个

12:15.500 --> 12:16.500
然后呢

12:16.500 --> 12:17.500
又触发了一次添加码

12:17.500 --> 12:18.500
就数据是这个

12:18.500 --> 12:19.500
然后呢

12:19.500 --> 12:20.500
埃克兴呢

12:20.500 --> 12:21.500
是这个

12:21.500 --> 12:22.500
添加个用户

12:22.500 --> 12:23.500
那么得到新数据

12:23.500 --> 12:24.500
新数据是这个

12:24.500 --> 12:25.500
看到没

12:25.500 --> 12:26.500
那么就数据

12:26.500 --> 12:27.500
就数据是这个

12:27.500 --> 12:28.500
看到没

12:28.500 --> 12:29.500
然后呢

12:29.500 --> 12:30.500
埃克兴呢

12:30.500 --> 12:31.500
是地内市有的

12:31.500 --> 12:32.500
得到新数据

12:32.500 --> 12:33.500
对吧

12:33.500 --> 12:34.500
哎

12:34.500 --> 12:35.500
是不是

12:35.500 --> 12:36.500
那么我们

12:36.500 --> 12:37.500
为了隔开的话

12:37.500 --> 12:38.500
我们还可以任意处理

12:38.500 --> 12:39.500
对吧

12:39.500 --> 12:40.500
换一个行

12:40.500 --> 12:41.500
换一个行

12:41.500 --> 12:42.500
哎

12:42.500 --> 12:43.500
不能换行吗

12:43.500 --> 12:44.500
这样子

12:44.500 --> 12:45.500
换一个行

12:45.500 --> 12:46.500
你看

12:46.500 --> 12:47.500
每一次数据发生变化

12:47.500 --> 12:48.500
是不是可以变异我们分析

12:48.500 --> 12:49.500
对吧

12:49.500 --> 12:50.500
哎

12:50.500 --> 12:51.500
但是我们现在

12:51.500 --> 12:52.500
正常写法好不好呢

12:52.500 --> 12:53.500
肯定不好

12:53.500 --> 12:54.500
为什么不好呢

12:54.500 --> 12:55.500
因为我把写死的

12:55.500 --> 12:56.500
写到第十八期里边了

12:56.500 --> 12:57.500
那如果有天不要呢

12:57.500 --> 12:58.500
哦

12:58.500 --> 12:59.500
打个电话

12:59.500 --> 13:00.500
到处一大个子

13:00.500 --> 13:01.500
不安方

13:01.500 --> 13:02.500
哎 麻烦你

13:02.500 --> 13:03.500
把那个

13:03.500 --> 13:04.500
把那个代码

13:04.500 --> 13:05.500
原代码删一下

13:05.500 --> 13:06.500
删一下

13:06.500 --> 13:07.500
我这里用一下

13:07.500 --> 13:08.500
那天下的电话

13:08.500 --> 13:09.500
要被打爆

13:09.500 --> 13:10.500
对吧

13:10.500 --> 13:11.500
你要

13:11.500 --> 13:12.500
你要要这个数据

13:12.500 --> 13:13.500
我要

13:13.500 --> 13:14.500
我要

13:14.500 --> 13:15.500
你可能还要

13:15.500 --> 13:16.500
做别的功能

13:16.500 --> 13:17.500
这样子写肯定不好

13:17.500 --> 13:18.500
你看没

13:18.500 --> 13:19.500
肯定不好

13:19.500 --> 13:20.500
那怎么办

13:20.500 --> 13:21.500
那你告诉我怎么办

13:21.500 --> 13:22.500
这个有啥办法

13:22.500 --> 13:23.500
你告诉我

13:23.500 --> 13:24.500
这是第十八期的

13:24.500 --> 13:25.500
它不能写这些代码

13:25.500 --> 13:26.500
这些代码

13:26.500 --> 13:27.500
它又要融入进来

13:27.500 --> 13:29.500
它又要融入进来

13:29.500 --> 13:30.500
那怎么办

13:30.500 --> 13:31.500
那你告诉我

13:31.500 --> 13:32.500
看着

13:32.500 --> 13:34.500
我们可以用这种方式来做

13:34.500 --> 13:35.500
你第十八期

13:35.500 --> 13:37.500
它是一个最原始的功能

13:37.500 --> 13:38.500
对吧

13:38.500 --> 13:39.500
把这个action分发给什么

13:39.500 --> 13:40.500
reducer

13:40.500 --> 13:41.500
然后来触发监进去

13:41.500 --> 13:42.500
它是一个最原始的功能

13:42.500 --> 13:43.500
那如果说

13:43.500 --> 13:45.500
我要增强一些功能的话

13:45.500 --> 13:47.500
我们用这种模式来做

13:47.500 --> 13:50.130
我们可以

13:50.130 --> 13:51.130
创建了stone之后

13:51.130 --> 13:53.130
创建了stone之后

13:53.130 --> 13:54.130
然后

13:54.130 --> 13:55.130
你不是有一个

13:55.130 --> 13:56.130
dispatch函数吗

13:56.130 --> 13:57.130
对吧

13:57.130 --> 13:58.130
我给你改了

13:58.130 --> 13:59.130
我把你这个dispatch函数

13:59.130 --> 14:01.130
给你改了

14:01.130 --> 14:02.130
改成啥呢

14:02.130 --> 14:03.130
我就可以在这里面

14:03.130 --> 14:04.130
随便写代码

14:04.130 --> 14:05.130
对吧

14:05.130 --> 14:06.130
这个可不可以

14:06.130 --> 14:07.130
也介绍可不可以这样做

14:07.130 --> 14:08.130
当然可以这样做

14:08.130 --> 14:09.130
为什么不可以呢

14:09.130 --> 14:10.130
我可以更改你的dispatch代码

14:10.130 --> 14:11.130
好

14:11.130 --> 14:12.130
那么dispatch代码

14:12.130 --> 14:13.130
但是我又不想改完

14:13.130 --> 14:14.130
你的原用的功能

14:14.130 --> 14:15.130
是不是要保留

14:15.130 --> 14:16.130
对吧

14:16.130 --> 14:17.130
原用的功能我们在保留

14:17.130 --> 14:18.130
我们不能全部改完

14:18.130 --> 14:19.130
所以我可以先

14:19.130 --> 14:21.130
把你原用的dispatch

14:21.130 --> 14:23.130
保存起来

14:23.130 --> 14:26.130
stone叫dispatch

14:26.130 --> 14:27.130
或者叫做

14:27.130 --> 14:29.130
olddispatch

14:29.130 --> 14:31.130
把你原用的dispatch

14:31.130 --> 14:32.130
保留起来

14:32.130 --> 14:33.130
保留

14:33.130 --> 14:35.130
原本的dispatch功能

14:35.130 --> 14:37.130
dispatch函数

14:37.130 --> 14:38.130
保留起来

14:38.130 --> 14:40.130
然后重新给你dispatch复制

14:40.130 --> 14:41.130
复制为一个新函数

14:41.130 --> 14:42.130
那么这个新的函数

14:42.130 --> 14:43.130
你看

14:43.130 --> 14:45.130
我们现在是不是可以写了

14:45.130 --> 14:47.130
就是

14:47.130 --> 14:48.130
旧数据

14:48.130 --> 14:49.130
旧数据

14:49.130 --> 14:50.130
然后来自于哪

14:50.130 --> 14:51.130
什么来自于

14:51.130 --> 14:53.130
stone.getState

14:53.130 --> 14:54.130
对吧

14:54.130 --> 14:56.130
旧数据

14:56.130 --> 14:58.130
然后新数据

14:58.130 --> 15:00.130
新数据

15:02.130 --> 15:03.130
没有

15:03.130 --> 15:04.130
一个型

15:04.130 --> 15:05.130
一个型的话

15:05.130 --> 15:06.130
来自于这个参数

15:06.130 --> 15:07.130
一个型

15:07.130 --> 15:08.130
然后

15:08.130 --> 15:09.130
你看我是不是把旧数据拿到了

15:09.130 --> 15:11.130
旧数据拿到了过后

15:11.130 --> 15:12.130
拿到了过后

15:12.130 --> 15:13.130
现在

15:13.130 --> 15:14.130
我们是不是

15:14.130 --> 15:15.130
调用olddispatch

15:15.130 --> 15:17.130
因为它里边的怎么触发

15:17.130 --> 15:18.130
一个型

15:18.130 --> 15:20.130
把一个型分发给reducer

15:20.130 --> 15:21.130
这些功能是它里面带的

15:21.130 --> 15:22.130
对吧

15:22.130 --> 15:23.130
但是这些功能还是得要

15:23.130 --> 15:24.130
还是得要

15:24.130 --> 15:26.130
那么我在这里面去调用这个

15:26.130 --> 15:27.130
把这个一个型传

15:27.130 --> 15:29.130
把这个一个型传给你

15:29.130 --> 15:31.130
一个型传给你

15:31.130 --> 15:33.130
那么你就去触发你原用的dispatch

15:33.130 --> 15:34.130
触发原来的这个

15:34.130 --> 15:35.130
对吧

15:35.130 --> 15:36.130
运行这个代码

15:36.130 --> 15:37.130
好你完了之后

15:37.130 --> 15:38.130
完了之后

15:38.130 --> 15:41.130
我们再运行新数据

15:41.130 --> 15:42.130
新数据

15:42.130 --> 15:43.130
stoke

15:43.130 --> 15:44.130
第二

15:46.130 --> 15:47.130
get state

15:47.130 --> 15:48.130
新数据

15:48.130 --> 15:50.130
最后我们换个好吗

15:51.130 --> 15:52.130
行了

15:52.130 --> 15:53.130
那么这样子一来

15:53.130 --> 15:55.130
我们来再保存看一下

15:56.130 --> 15:57.130
是不是OK了

15:57.130 --> 15:58.130
对不对

15:58.130 --> 15:59.130
是不是OK了

15:59.130 --> 16:01.130
那么当然第一次

16:01.130 --> 16:02.130
第一次肯定调用不了

16:02.130 --> 16:03.130
因为第一次是

16:03.130 --> 16:04.130
quizstone

16:04.130 --> 16:05.130
quizstone里边它自带了一个dispatch

16:05.130 --> 16:07.130
自带了一个dispatch

16:08.130 --> 16:10.130
那么那个dispatch我监控不到

16:10.130 --> 16:11.130
监控不到

16:11.130 --> 16:12.130
那么我是那个dispatch

16:12.130 --> 16:14.130
就是一开始quizstone的时候

16:14.130 --> 16:16.130
自己不是默认了dispatch的一个吗

16:16.130 --> 16:17.130
对不对

16:17.130 --> 16:18.130
这个东西监控不到

16:18.130 --> 16:20.130
这个东西就监控不到

16:20.130 --> 16:21.130
这个东西监控没无所谓

16:21.130 --> 16:22.130
那是初始化的东西

16:22.130 --> 16:23.130
我们也不care

16:23.130 --> 16:24.130
我们只care

16:24.130 --> 16:25.130
我们自己改变了数据

16:25.130 --> 16:26.130
对吧

16:26.130 --> 16:27.130
因为这个触发的时候

16:27.130 --> 16:29.130
我们dispatch还没有重新

16:29.130 --> 16:32.130
还没有重新那个就是更新

16:32.130 --> 16:34.130
你看看没问题吧

16:34.130 --> 16:35.130
是没问题

16:35.130 --> 16:36.130
那么现在呢

16:36.130 --> 16:37.130
就实现了这么一个功能了

16:37.130 --> 16:38.130
那么这样子的好处在于

16:38.130 --> 16:40.130
我有没有改这个东西

16:40.130 --> 16:41.130
有没有改这个代码

16:41.130 --> 16:42.130
没有

16:42.130 --> 16:44.130
而是我增加了一块代码

16:44.130 --> 16:46.130
那么这一块就类似于

16:46.130 --> 16:47.130
中间建的功能

16:47.130 --> 16:48.130
中间建的实现原理

16:48.130 --> 16:50.130
它就是这样子

16:50.130 --> 16:52.130
给你改动这个dispatch属性

16:52.130 --> 16:54.130
那么你要做什么事情

16:54.130 --> 16:55.130
你在外面去做

16:55.130 --> 16:57.130
这就是中间建的核心

16:57.130 --> 16:58.130
实现原理

16:58.130 --> 17:01.130
这是更改

17:01.130 --> 17:03.130
stone中的dispatch

17:03.130 --> 17:04.130
当然有些人说

17:04.130 --> 17:06.130
那这里我能不能补掉这个

17:06.130 --> 17:07.130
补掉这个

17:07.130 --> 17:08.130
补掉这个的话

17:08.130 --> 17:09.130
那么它就根本就补

17:09.130 --> 17:10.130
那么有没有触发

17:10.130 --> 17:11.130
有没有触发这个

17:11.130 --> 17:13.130
因为dispatch触发

17:13.130 --> 17:15.130
有触发

17:15.130 --> 17:16.130
但是数据变没变

17:16.130 --> 17:17.130
没变

17:17.130 --> 17:18.130
你看看没变

17:18.130 --> 17:19.130
因为你没有真

17:19.130 --> 17:20.130
你没有真正的去把

17:20.130 --> 17:22.130
这个dispatch交给reducer

17:22.130 --> 17:23.130
对吧

17:23.130 --> 17:24.130
所以它没变

17:24.130 --> 17:25.130
没变

17:25.130 --> 17:26.130
当然你能不能补用它了

17:26.130 --> 17:27.130
当然也可以补用它

17:27.130 --> 17:28.130
大家看你的

17:28.130 --> 17:29.130
自己的情况了

17:29.130 --> 17:31.130
你爱加什么样的功能

17:31.130 --> 17:32.130
就加什么样的功能

17:32.130 --> 17:34.130
你只要一调用它就OK

17:34.130 --> 17:36.130
好这一块听懂了吗

17:36.130 --> 17:38.130
你现在把这一块听懂

17:38.130 --> 17:40.130
这是中间的核心实现原理

17:40.130 --> 17:42.130
它改了这个dispatch数据

17:42.130 --> 17:44.130
改了这个玩意

17:44.130 --> 17:47.130
而实际上中间键

17:47.130 --> 17:48.130
它不只一个

17:48.130 --> 17:50.130
它可能有很多

17:50.130 --> 17:51.130
可能有很多

17:51.130 --> 17:53.130
那么它就会形成一种

17:53.130 --> 17:54.130
链式调用

17:54.130 --> 17:56.130
就是你也要改dispatch

17:56.130 --> 17:58.130
我也要改dispatch

17:58.130 --> 18:00.130
那到底听谁的呢

18:00.130 --> 18:01.130
到底听谁的呢

18:01.130 --> 18:02.130
不要在这个中间键

18:02.130 --> 18:04.130
把dispatch改成这个样子

18:04.130 --> 18:05.130
另外一个中间键

18:05.130 --> 18:06.130
又把dispatch改成

18:06.130 --> 18:07.130
另外一个样子

18:07.130 --> 18:08.130
到底听谁的呢

18:08.130 --> 18:09.130
问题是

18:09.130 --> 18:10.130
听谁的呢

18:10.130 --> 18:11.130
比方说吧

18:11.130 --> 18:13.130
这是中间键

18:13.130 --> 18:16.130
这是中间键1

18:16.130 --> 18:20.760
中间键1

18:20.760 --> 18:22.760
比方说有一个例子

18:22.760 --> 18:24.760
那么如果说有一天

18:24.760 --> 18:25.760
我又来一个中间键

18:25.760 --> 18:26.760
它也做了类似的事情

18:26.760 --> 18:28.760
当然中间键不是这样的写的

18:28.760 --> 18:30.760
我们现在只是举个例子

18:30.760 --> 18:32.760
它也做了类似的事情

18:32.760 --> 18:34.760
那么它又把那个dispatch

18:34.760 --> 18:35.760
函数改了

18:35.760 --> 18:36.760
它又改了dispatch函数

18:36.760 --> 18:37.760
那中间键2

18:37.760 --> 18:39.760
那中间键1是不是被覆盖掉了

18:39.760 --> 18:40.760
对吧

18:40.760 --> 18:42.760
中间键1是不是被覆盖掉了

18:42.760 --> 18:43.760
对不对

18:43.760 --> 18:44.760
所以说呢

18:44.760 --> 18:45.760
当如果出现

18:45.760 --> 18:47.760
多个中间键的时候呢

18:47.760 --> 18:48.760
我们应该怎么做呢

18:48.760 --> 18:51.760
我们应该还是要保留这个步骤

18:51.760 --> 18:53.760
还是要保留这个步骤

18:53.760 --> 18:55.760
对不对

18:55.760 --> 18:57.760
还是要保留这个步骤

18:57.760 --> 18:58.760
就是把它的dispatch

18:58.760 --> 18:59.760
保留起来

18:59.760 --> 19:00.760
保留起来

19:00.760 --> 19:02.760
然后重新给dispatch复制

19:02.760 --> 19:03.760
那么这样子呢

19:03.760 --> 19:04.760
比方说遇到

19:04.760 --> 19:06.760
第二个中间键的时候

19:06.760 --> 19:07.760
它保留到dispatch

19:07.760 --> 19:08.760
是不是之前改动过的dispatch

19:08.760 --> 19:09.760
对吧

19:09.760 --> 19:10.760
之前已经改动过了

19:10.760 --> 19:11.760
那么现在保留到

19:11.760 --> 19:12.760
之前的dispatch

19:12.760 --> 19:13.760
那么是不是把之前的东西

19:13.760 --> 19:15.760
就应用进去了

19:15.760 --> 19:16.760
对吧

19:16.760 --> 19:18.760
是不是就应用进去了

19:18.760 --> 19:19.760
没问题吧

19:19.760 --> 19:20.760
是不是就应用进去了

19:20.760 --> 19:21.760
然后呢

19:21.760 --> 19:23.760
然后我再重新给dispatch复制

19:23.760 --> 19:24.760
那么现在这个

19:24.760 --> 19:25.760
偶尔的dispatch

19:25.760 --> 19:26.760
是不是只想到

19:26.760 --> 19:27.760
之前这一次复制的dispatch

19:27.760 --> 19:28.760
不再是最原始的了

19:28.760 --> 19:29.760
看到没

19:29.760 --> 19:31.760
能理解这个意思吗

19:31.760 --> 19:33.760
能不能理解这个意思

19:33.760 --> 19:34.760
好

19:34.760 --> 19:35.760
还是画个图吗

19:35.760 --> 19:36.760
画个图

19:39.760 --> 19:41.760
这是始统最原始的dispatch

19:45.840 --> 19:48.840
原始的dispatch

19:48.840 --> 19:50.840
原始的dispatch

19:53.840 --> 19:54.840
然后呢

19:54.840 --> 19:56.840
我们这个dispatch

19:56.840 --> 19:58.840
就中间键1

19:58.840 --> 19:59.840
中间键1的话

19:59.840 --> 20:01.840
是不是改动了dispatch

20:01.840 --> 20:03.840
它把原始的dispatch

20:03.840 --> 20:04.840
包装了一下

20:04.840 --> 20:05.840
对吧

20:05.840 --> 20:06.840
它把原始的dispatch

20:06.840 --> 20:07.840
包装了一下

20:07.840 --> 20:09.840
就形成这么一种结构

20:11.840 --> 20:13.840
放到底参

20:13.840 --> 20:14.840
形状的话

20:14.840 --> 20:15.840
用这个颜色吧

20:15.840 --> 20:16.840
好

20:16.840 --> 20:18.840
这是中间键1

20:20.840 --> 20:23.840
中间键1

20:23.840 --> 20:27.840
中间键1的dispatch

20:27.840 --> 20:28.840
对吧

20:28.840 --> 20:29.840
那么

20:29.840 --> 20:31.840
它把原始的dispatch

20:31.840 --> 20:32.840
包了一层

20:32.840 --> 20:33.840
你看

20:33.840 --> 20:34.840
它外面

20:34.840 --> 20:35.840
给你包了一层

20:35.840 --> 20:37.840
里面还用到了原始的dispatch

20:37.840 --> 20:38.840
对吧

20:38.840 --> 20:39.840
然后呢

20:39.840 --> 20:41.840
中间键2

20:41.840 --> 20:43.840
它又在中间键1前面

20:43.840 --> 20:45.840
给你包了一层

20:45.840 --> 20:47.840
其实这就是中间键的模型

20:47.840 --> 20:49.840
我们一把它叫做洋葱模型

20:49.840 --> 20:52.840
就像洋葱一层一层的

20:54.840 --> 20:56.840
中间键2的dispatch

20:56.840 --> 20:58.840
它就形成这么一种结构了

20:58.840 --> 20:59.840
你看懂吗

20:59.840 --> 21:00.840
中间键2

21:00.840 --> 21:02.840
包装了中间键1的dispatch

21:02.840 --> 21:03.840
然后呢

21:03.840 --> 21:04.840
最里面

21:04.840 --> 21:06.840
最里层就是原始的dispatch

21:06.840 --> 21:07.840
你这样子你看

21:07.840 --> 21:08.840
每一个中间键

21:08.840 --> 21:10.840
是不是把它的功能

21:10.840 --> 21:11.840
就一步一步增强

21:11.840 --> 21:13.840
而且相互不受影响

21:13.840 --> 21:14.840
中间键2

21:14.840 --> 21:16.840
它会影响到中间键1的dispatch吗

21:16.840 --> 21:17.840
不会

21:17.840 --> 21:18.840
因为中间键1封装好了

21:18.840 --> 21:19.840
中间键2

21:19.840 --> 21:21.840
如果说中间键2不去调用这个

21:21.840 --> 21:22.840
如果说中间键2里面

21:22.840 --> 21:23.840
不去调用这个O的dispatch

21:23.840 --> 21:24.840
那么它就不会动

21:24.840 --> 21:25.840
就不会变化

21:25.840 --> 21:26.840
那么就

21:26.840 --> 21:27.840
不是变化

21:27.840 --> 21:30.840
就不会运行中间键1的dispatch

21:30.840 --> 21:31.840
如果说中间2里面

21:31.840 --> 21:33.840
它去调用了这个O的dispatch

21:33.840 --> 21:34.840
它在合适的时间点

21:34.840 --> 21:35.840
去调用它

21:35.840 --> 21:36.840
那么中间键2

21:36.840 --> 21:38.840
它就包装了中间键1的dispatch

21:38.840 --> 21:39.840
就形成了这么一种结构

21:39.840 --> 21:40.840
那么还可以写中间键3

21:40.840 --> 21:41.840
中间键4

21:41.840 --> 21:42.840
中间键5

21:42.840 --> 21:43.840
这不是可以一层一层写过去

21:43.840 --> 21:44.840
对不对

21:44.840 --> 21:46.840
每一个中间键

21:46.840 --> 21:47.840
增强一次功能

21:47.840 --> 21:49.840
每一个中间键增强一次功能

21:49.840 --> 21:50.840
那么就形成了一种

21:50.840 --> 21:51.840
固定的结构

21:51.840 --> 21:52.840
每一个中间

21:52.840 --> 21:54.840
搞定一下自己的事情

21:54.840 --> 21:56.840
每个中间键搞定自己的事情

21:56.840 --> 21:57.840
对吧

21:57.840 --> 21:59.840
就形成了这么一种结构了

21:59.840 --> 22:00.840
看到没

22:00.840 --> 22:01.840
好

22:01.840 --> 22:03.840
这就是中间键这一块

22:03.840 --> 22:05.840
中间键这一块

22:05.840 --> 22:06.840
好

22:06.840 --> 22:07.840
那么直到了中间键的

22:07.840 --> 22:09.840
核心原理之后

22:09.840 --> 22:10.840
我们之后自己写中间键

22:10.840 --> 22:12.840
是不是就用这种写法了

22:12.840 --> 22:14.840
这种写法太楼了

22:14.840 --> 22:15.840
太楼了

22:15.840 --> 22:17.840
而且不是那么

22:17.840 --> 22:18.840
写起来

22:18.840 --> 22:20.840
没有一种固定标准的格式

22:20.840 --> 22:21.840
所以说

22:21.840 --> 22:22.840
它不是用的这种写法

22:22.840 --> 22:23.840
但是原理

22:23.840 --> 22:24.840
基本上是这样的原理

22:24.840 --> 22:26.840
大家用的是什么写法

22:26.840 --> 22:27.840
中间键这一块

22:27.840 --> 22:28.840
是这样子

22:29.840 --> 22:31.840
开始到了地方来了

22:31.840 --> 22:35.150
瑞达格斯中间键

22:35.150 --> 22:36.150
书写

22:36.150 --> 22:39.150
就是如何来书写一个中间键

22:39.150 --> 22:41.150
那么第1个

22:41.150 --> 22:43.150
就是一个中间键

22:43.150 --> 22:46.150
中间键本身是一个函数

22:46.150 --> 22:49.150
中间键本身是一个函数

22:49.150 --> 22:51.150
该函数接收一个

22:51.150 --> 22:54.150
Stone 函数

22:54.150 --> 22:56.150
表示

22:56.150 --> 22:58.150
创建的仓库

22:58.150 --> 23:01.150
表示创建的仓库

23:01.150 --> 23:02.150
那么这里

23:02.150 --> 23:03.150
我们来看一下

23:03.150 --> 23:04.150
我们这里

23:04.150 --> 23:05.150
应那个时候复制一下

23:05.150 --> 23:06.150
我们看一下具体的中间键

23:06.150 --> 23:07.150
比方说我们要实现同样的功能

23:07.150 --> 23:08.150
具体的中间键

23:08.150 --> 23:09.150
该怎么来写

23:09.150 --> 23:11.150
就不是用这种写法了

23:11.150 --> 23:12.150
肯定不是用这种写法了

23:12.150 --> 23:14.150
我们就要写到这上面

23:14.150 --> 23:15.150
它是一个函数

23:15.150 --> 23:16.150
比方说

23:16.150 --> 23:18.150
我们的Made of Weir

23:18.150 --> 23:19.150
不要取个名字

23:19.150 --> 23:20.150
叫中间键1

23:20.150 --> 23:23.150
或者叫做Logue

23:23.150 --> 23:24.150
Logue

23:24.150 --> 23:27.150
Made of Weir

23:28.150 --> 23:32.300
这是一个中间键

23:32.300 --> 23:35.300
一个中间键函数

23:35.300 --> 23:37.300
它本身是一个函数

23:37.300 --> 23:38.300
它有这么一个函数

23:38.300 --> 23:40.300
叫Stone

23:40.300 --> 23:42.300
有这么一个函数

23:42.300 --> 23:44.300
那么这个

23:44.300 --> 23:46.300
函数表示什么意思呢

23:46.300 --> 23:47.300
表示

23:47.300 --> 23:48.300
创建的仓库

23:48.300 --> 23:49.300
创建的仓库

23:49.300 --> 23:50.300
就是仓库对象

23:50.300 --> 23:51.300
但是它不是一个

23:51.300 --> 23:52.300
完整的仓库对象

23:52.300 --> 23:54.300
它里面只包含两个属性

23:54.300 --> 23:56.300
表示创建的仓库

23:56.300 --> 23:57.300
该仓库

23:57.300 --> 24:00.300
并非一个完整的

24:00.300 --> 24:01.300
仓库对象

24:01.300 --> 24:02.300
因为我们知道

24:02.300 --> 24:03.300
完整的仓库对象里面

24:03.300 --> 24:04.300
它包含很多东西

24:04.300 --> 24:05.300
对吧

24:05.300 --> 24:06.300
我们之前写过的

24:06.300 --> 24:07.300
一个完整的仓库对象里面

24:07.300 --> 24:08.300
它是不是包含很多东西

24:08.300 --> 24:10.300
Dispatch, GetState, Subscribe

24:10.300 --> 24:11.300
对吧

24:11.300 --> 24:12.300
它包含了海报

24:12.300 --> 24:13.300
我这里还没有写其他的

24:13.300 --> 24:14.300
对不对

24:14.300 --> 24:15.300
它包含了很多东西

24:15.300 --> 24:16.300
那么但是这个

24:16.300 --> 24:17.300
我们这里的

24:17.300 --> 24:18.300
Stone这个参数

24:18.300 --> 24:19.300
它表示的是个仓库对象

24:19.300 --> 24:20.300
它这不是一个

24:20.300 --> 24:21.300
完整的仓库对象

24:21.300 --> 24:22.300
它里面包含什么呢

24:22.300 --> 24:23.300
锦包含

24:23.300 --> 24:25.300
锦包含两个属性

24:25.300 --> 24:27.300
GetState

24:27.300 --> 24:29.300
拿到仓库当前的状态

24:29.300 --> 24:30.300
还有什么呢

24:30.300 --> 24:32.300
还有Dispatch

24:32.300 --> 24:33.300
Dispatch分发

24:33.300 --> 24:34.300
分发函数

24:34.300 --> 24:35.300
它只有这两个东西

24:35.300 --> 24:36.300
只用这两个东西

24:36.300 --> 24:37.300
供你使用

24:37.300 --> 24:38.300
你不能在这里面

24:38.300 --> 24:39.300
注册什么监听器

24:39.300 --> 24:40.300
没有这个东西

24:40.300 --> 24:41.300
没有这个意思

24:41.300 --> 24:42.300
中间键里面

24:42.300 --> 24:43.300
它的参数

24:43.300 --> 24:44.300
Stone

24:44.300 --> 24:45.300
它只包含这两个东西

24:45.300 --> 24:47.300
那么既然是个函数

24:47.300 --> 24:48.300
它是在什么时候

24:48.300 --> 24:50.300
运行的这个函数

24:50.300 --> 24:51.300
这个函数是在

24:51.300 --> 24:52.300
什么时候运行的

24:52.300 --> 24:54.300
它的运行时间

24:54.300 --> 24:57.300
该函数运行的时间

24:57.300 --> 24:59.300
是在仓库

24:59.300 --> 25:02.300
就是仓库

25:02.300 --> 25:03.300
叫什么

25:03.300 --> 25:08.300
仓库创建之后运行

25:08.300 --> 25:10.300
是在仓库创建之后运行

25:10.300 --> 25:11.300
那你看一下

25:11.300 --> 25:12.300
我们之前写的这个中间键

25:12.300 --> 25:13.300
就是我们这种写法

25:13.300 --> 25:14.300
是不是在创建仓库之后

25:14.300 --> 25:15.300
就可以改动

25:15.300 --> 25:16.300
它的Dispatch函数了

25:16.300 --> 25:17.300
对吧

25:17.300 --> 25:18.300
那么这里最终是要

25:18.300 --> 25:19.300
改动Dispatch

25:19.300 --> 25:20.300
只是我们现在

25:20.300 --> 25:21.300
还没写来嘛

25:21.300 --> 25:22.300
不着急

25:22.300 --> 25:23.300
那么我们这里

25:23.300 --> 25:24.300
创建这个函数

25:24.300 --> 25:25.300
它传那个仓库队来进来

25:25.300 --> 25:26.300
那肯定是要

25:26.300 --> 25:27.300
仓库创建完了之后

25:27.300 --> 25:28.300
才能运行这个函数

25:28.300 --> 25:29.300
对不对

25:29.300 --> 25:30.300
所以说

25:30.300 --> 25:31.300
它那个函数运行的时间点

25:31.300 --> 25:32.300
就是刚刚好

25:32.300 --> 25:33.300
创建仓库之后

25:33.300 --> 25:34.300
我要运行这个函数

25:34.300 --> 25:36.300
就这么个意思

25:36.300 --> 25:37.300
那么既然创建了

25:37.300 --> 25:38.300
仓库之后

25:38.300 --> 25:39.300
我要运行这个函数

25:39.300 --> 25:41.300
你是不是得高速仓库

25:41.300 --> 25:42.300
你是不是得注意

25:42.300 --> 25:43.300
一定要认能听

25:43.300 --> 25:44.300
这点招得很

25:44.300 --> 25:45.300
你既然要

25:45.300 --> 25:47.300
创建完仓库之后

25:47.300 --> 25:48.300
运行这个函数

25:48.300 --> 25:49.300
那你是不是得

25:49.300 --> 25:50.300
创建仓库的时候

25:50.300 --> 25:51.300
得高速这个仓库

25:51.300 --> 25:53.300
得高速这个仓库

25:53.300 --> 25:54.300
它里边

25:54.300 --> 25:56.300
有哪些中间建

25:56.300 --> 25:57.300
对吧

25:57.300 --> 25:58.300
有哪些中间建

25:58.300 --> 25:59.300
函数对不对

25:59.300 --> 26:00.300
是不是得高速仓库

26:00.300 --> 26:01.300
让它去运行

26:01.300 --> 26:02.300
是这个逻辑吧

26:02.300 --> 26:03.300
不然的话

26:03.300 --> 26:04.300
这个创建仓库之后

26:04.300 --> 26:05.300
它怎么来知道

26:05.300 --> 26:06.300
有哪些函数要运行呢

26:06.300 --> 26:07.300
有哪些中间建

26:07.300 --> 26:08.300
函数要运行的

26:08.300 --> 26:09.300
它不知道

26:09.300 --> 26:10.300
所以说你必须要

26:10.300 --> 26:11.300
高速这个仓库

26:11.300 --> 26:12.300
有哪些中间建

26:12.300 --> 26:13.300
函数要运行

26:13.300 --> 26:14.300
那怎么来

26:14.300 --> 26:15.300
高速这个仓库

26:15.300 --> 26:16.300
有哪些中间建

26:16.300 --> 26:18.300
函数要运行呢

26:18.300 --> 26:19.300
好

26:19.300 --> 26:20.300
这里呢

26:20.300 --> 26:22.300
我们要用原生的Redux

26:22.300 --> 26:23.300
我们这里

26:23.300 --> 26:25.300
Chris Stone里边

26:25.300 --> 26:26.300
需要提供第二个参数

26:26.300 --> 26:27.300
第二个参数

26:27.300 --> 26:28.300
我们之前说过是

26:28.300 --> 26:29.300
第二个参数

26:29.300 --> 26:30.300
是一个默认值

26:30.300 --> 26:31.300
对吧

26:31.300 --> 26:32.300
状态默认值

26:32.300 --> 26:33.300
但是呢

26:33.300 --> 26:34.300
如果说你第二个参数

26:34.300 --> 26:35.300
给的是一个函数的话

26:35.300 --> 26:36.300
那么还不是表示的

26:36.300 --> 26:37.300
默认值的

26:37.300 --> 26:38.300
它表示的运行中间建

26:38.300 --> 26:39.300
什么函数呢

26:39.300 --> 26:40.300
这个函数的名字叫做

26:40.300 --> 26:41.300
Apply

26:41.300 --> 26:42.300
Medware

26:42.300 --> 26:43.300
Apply

26:43.300 --> 26:44.300
Medware

26:44.300 --> 26:45.300
那么这里

26:45.300 --> 26:46.300
我们再记一遍

26:47.300 --> 26:49.300
由于

26:49.300 --> 26:51.300
创建仓库

26:51.300 --> 26:52.300
后

26:52.300 --> 26:54.300
需要自动运行

26:54.300 --> 26:56.300
就是

26:56.300 --> 26:59.300
设置的中间建函数

26:59.300 --> 27:01.300
因此

27:01.300 --> 27:02.300
需要在

27:02.300 --> 27:03.300
创建仓库时

27:03.300 --> 27:05.300
创建仓库时

27:06.300 --> 27:08.300
高速仓库

27:09.300 --> 27:11.300
有哪些中间建

27:11.300 --> 27:13.300
有哪些中间建

27:14.300 --> 27:16.300
那么怎么来高速呢

27:16.300 --> 27:19.300
需要使用Apply

27:19.300 --> 27:21.300
Apply什么意思

27:21.300 --> 27:22.300
应用的意思

27:22.300 --> 27:23.300
Medware

27:24.300 --> 27:26.300
应用中间建函数

27:27.300 --> 27:29.300
使用用这个函数

27:29.300 --> 27:31.300
需要调用这个函数

27:31.300 --> 27:34.670
需要调用这个函数

27:35.670 --> 27:36.670
将

27:36.670 --> 27:37.670
函数的

27:37.670 --> 27:39.670
返回结果

27:39.670 --> 27:40.670
作为

27:40.670 --> 27:41.670
作为什么

27:42.670 --> 27:43.670
Crazy

27:43.670 --> 27:44.670
Stone

27:44.670 --> 27:45.670
第二

27:45.670 --> 27:46.670
或

27:46.670 --> 27:47.670
第三个

27:47.670 --> 27:48.670
蚕数

27:48.670 --> 27:49.670
什么意思呢

27:49.670 --> 27:50.670
就是说在这里

27:50.670 --> 27:51.670
我们要应用中间建

27:51.670 --> 27:52.670
我们怎么写的

27:52.670 --> 27:53.670
就是利用Apply

27:53.670 --> 27:54.670
Medware

27:54.670 --> 27:56.670
把我们的中间建传过去

27:56.670 --> 27:57.670
Locker

27:57.670 --> 27:58.670
Medware

27:58.670 --> 28:00.670
用来做日子基督的中间建

28:00.670 --> 28:02.670
把我们的中间建传过去

28:02.670 --> 28:03.670
就这样

28:03.670 --> 28:04.670
就这样写

28:04.670 --> 28:05.670
为什么说

28:05.670 --> 28:06.670
这是第二个蚕数对吧

28:06.670 --> 28:07.670
为什么说可以作为第三个蚕数呢

28:07.670 --> 28:08.670
就是说

28:08.670 --> 28:09.670
如果说

28:09.670 --> 28:10.670
你的状态

28:10.670 --> 28:13.670
比方说你的状态有默认值

28:13.670 --> 28:14.670
如果说你的状态有默认值

28:14.670 --> 28:16.670
比方说这里有默认值

28:16.670 --> 28:17.670
好那么

28:17.670 --> 28:18.670
这就是第三个蚕数对吧

28:18.670 --> 28:19.670
它会自动分辨

28:19.670 --> 28:20.670
分辨哪个是默认值

28:20.670 --> 28:21.670
哪个是

28:21.670 --> 28:22.670
你的中间建

28:22.670 --> 28:24.670
总之它能够分辨出来

28:24.670 --> 28:26.670
我们下节课讲远码

28:26.670 --> 28:27.670
好那这样子

28:27.670 --> 28:28.670
就把中间建一用进去了

28:28.670 --> 28:29.670
那如果说

28:29.670 --> 28:30.670
多个中间建

28:30.670 --> 28:31.670
比方说我们这里Locker

28:31.670 --> 28:32.670
Locker1

28:32.670 --> 28:33.670
这是一个中间建

28:33.670 --> 28:34.670
中间建就是一个蚕数

28:34.670 --> 28:36.670
然后我们在这里写个

28:36.670 --> 28:37.670
Locker2

28:37.670 --> 28:38.670
Stone

28:39.670 --> 28:41.670
那么这里分别输出

28:41.670 --> 28:44.670
分别输出Locker1

28:44.670 --> 28:48.670
这里分别输出Locker2

28:48.670 --> 28:50.670
好于是在这里

28:50.670 --> 28:54.670
我们可以这样子写Locker2

28:54.670 --> 28:55.670
这是个生于蚕数的写法对吧

28:55.670 --> 28:56.670
可以把多个蚕数

28:56.670 --> 28:57.670
直接写到这

28:57.670 --> 28:59.670
那么要用多少个中间建

28:59.670 --> 29:01.670
那么直接去运用就完成了

29:01.670 --> 29:02.670
好保存

29:02.670 --> 29:03.670
咱们来看一下

29:03.670 --> 29:04.670
你看注册中间建

29:04.670 --> 29:05.670
是不Locker1

29:05.670 --> 29:06.670
Locker2

29:06.670 --> 29:07.670
现在抱错

29:07.670 --> 29:08.670
因为这个蚕数里面

29:08.670 --> 29:09.670
还不满足要求

29:09.670 --> 29:10.670
但是没关系

29:10.670 --> 29:11.670
我们是不是可以看到

29:11.670 --> 29:12.670
这个蚕数已经运行了

29:12.670 --> 29:13.670
对吧

29:13.670 --> 29:14.670
什么时候运行

29:14.670 --> 29:16.670
创建仓库之后就会运行

29:16.670 --> 29:19.670
创建仓库之后就会运行

29:19.670 --> 29:20.670
好

29:20.670 --> 29:21.670
那么这里呢

29:21.670 --> 29:22.670
我们是不是可以再输出

29:22.670 --> 29:23.670
这个Stone对象

29:23.670 --> 29:24.670
对吧

29:24.670 --> 29:25.670
我们再可以再输出

29:25.670 --> 29:26.670
这个Stone对象

29:26.670 --> 29:27.670
好

29:27.670 --> 29:28.670
你看一下

29:28.670 --> 29:29.670
这个Stone对象

29:29.670 --> 29:30.670
是不是可以输出

29:30.670 --> 29:31.670
对吧

29:31.670 --> 29:32.670
我们只可以拿到GetState

29:32.670 --> 29:33.670
和GetState

29:33.670 --> 29:34.670
只能拿到这两个

29:34.670 --> 29:35.670
这个Stone里面

29:35.670 --> 29:36.670
当然我们平时也不太

29:37.670 --> 29:38.670
当然也可能

29:38.670 --> 29:39.670
我们拿状态

29:39.670 --> 29:40.670
拿状态数据

29:40.670 --> 29:42.670
主要是拿状态数据

29:42.670 --> 29:43.670
好

29:43.670 --> 29:44.670
这个函数就会运行

29:44.670 --> 29:45.670
但是现在肯定抱错

29:45.670 --> 29:46.670
因为这个函数

29:46.670 --> 29:47.670
不满足要求

29:47.670 --> 29:48.670
好

29:48.670 --> 29:49.670
这个函数

29:49.670 --> 29:50.670
中间建

29:50.670 --> 29:51.670
我们刚才分析的

29:51.670 --> 29:52.670
它是要改动Dispatch

29:52.670 --> 29:53.670
对吧

29:53.670 --> 29:54.670
于是

29:54.670 --> 29:55.670
它这个函数

29:55.670 --> 29:56.670
它是有要求的

29:56.670 --> 29:58.670
中间建函数

29:58.670 --> 30:01.670
必须返回一个

30:01.670 --> 30:02.670
什么呢

30:02.670 --> 30:03.670
一个Dispatch

30:03.670 --> 30:05.670
创建函数

30:05.670 --> 30:06.670
什么叫做Dispatch

30:06.670 --> 30:07.670
创建函数

30:07.670 --> 30:08.670
就是

30:08.670 --> 30:09.670
你要返

30:09.670 --> 30:10.670
你最目的是

30:10.670 --> 30:11.670
要返回一个Dispatch函数

30:11.670 --> 30:12.670
但是呢

30:12.670 --> 30:13.670
这个Dispatch函数

30:13.670 --> 30:14.670
需要

30:14.670 --> 30:16.670
需要通过其他的Dispatch来

30:16.670 --> 30:18.670
需要通过其他的Dispatch来

30:18.670 --> 30:19.670
因此呢

30:19.670 --> 30:20.670
也就是说

30:20.670 --> 30:21.670
我们要返回一个Dispatch

30:21.670 --> 30:22.670
创建函数

30:22.670 --> 30:23.670
这个函数用来

30:23.670 --> 30:24.670
创建Dispatch的

30:24.670 --> 30:25.670
我们于是呢

30:25.670 --> 30:27.670
这里具体来说

30:27.670 --> 30:29.670
要返回的函数

30:29.670 --> 30:31.670
返回的函数

30:31.670 --> 30:32.670
需要

30:32.670 --> 30:33.670
有一个

30:33.670 --> 30:34.670
参数

30:34.670 --> 30:36.670
Dispatch

30:36.670 --> 30:39.670
参数Dispatch

30:39.670 --> 30:41.670
然后呢

30:41.670 --> 30:42.670
这个函数的返回之后

30:42.670 --> 30:43.670
我们再说吧

30:43.670 --> 30:44.670
就这里特别特别

30:44.670 --> 30:45.670
特别特别早

30:45.670 --> 30:46.670
我们这里算了

30:46.670 --> 30:47.670
不说这个

30:47.670 --> 30:48.670
我们直接来

30:48.670 --> 30:49.670
也就是说

30:49.670 --> 30:50.670
这里呢

30:50.670 --> 30:51.670
我们要返回啥呢

30:51.670 --> 30:52.670
它得返回一个函数

30:52.670 --> 30:53.670
这个函数

30:53.670 --> 30:54.670
用于做什么呢

30:54.670 --> 30:57.670
用来创建Dispatch函数

30:57.670 --> 30:58.670
我们这里

30:58.670 --> 30:59.670
要返回一个函数

30:59.670 --> 31:00.670
这个函数

31:01.670 --> 31:02.670
用来

31:02.670 --> 31:03.670
这里就绕在这

31:03.670 --> 31:04.670
绕就绕在这

31:04.670 --> 31:05.670
要来返

31:05.670 --> 31:06.670
这个函数返回干嘛的

31:06.670 --> 31:08.670
这个函数用来返回

31:08.670 --> 31:10.670
一个Dispatch函数

31:11.670 --> 31:12.670
但是这里我是写的名字

31:12.670 --> 31:13.670
当然你可以不写名字

31:13.670 --> 31:14.670
反正你没函数嘛

31:14.670 --> 31:15.670
也就是说

31:15.670 --> 31:16.670
这个函数

31:16.670 --> 31:18.670
就是最终要应用的Dispatch

31:18.670 --> 31:19.670
下面的

31:19.670 --> 31:21.670
下面返回的函数

31:21.670 --> 31:22.670
是

31:22.670 --> 31:23.670
最终要

31:23.670 --> 31:25.670
应用的Dispatch

31:25.670 --> 31:26.670
那么这个中

31:26.670 --> 31:27.670
这个

31:27.670 --> 31:28.670
到时候呢

31:28.670 --> 31:29.670
Apply Middleware

31:29.670 --> 31:30.670
它就会帮你搞定

31:30.670 --> 31:32.670
它会把你这里返回的函数

31:32.670 --> 31:33.670
替换掉

31:33.670 --> 31:35.670
Stone里边的Dispatch

31:35.670 --> 31:37.670
它会做替换

31:37.670 --> 31:39.670
最终会做替换

31:39.670 --> 31:40.670
也就是说这里返回的

31:40.670 --> 31:42.670
就是Dispatch函数

31:42.670 --> 31:43.670
这个函数

31:43.670 --> 31:44.670
这个函数

31:44.670 --> 31:45.670
这个函数是不是很简单

31:45.670 --> 31:46.670
这个函数

31:46.670 --> 31:47.670
如果你不看外称的话

31:47.670 --> 31:48.670
那么这个函数

31:48.670 --> 31:49.670
是一个Dispatch函数

31:49.670 --> 31:51.670
那它有没有函数

31:51.670 --> 31:52.670
Dispatch函数有没有函数

31:52.670 --> 31:53.670
是不是就是X

31:53.670 --> 31:54.670
对不对

31:54.670 --> 31:55.670
你给我传一个X

31:55.670 --> 31:56.670
进来

31:56.670 --> 31:57.670
我要干嘛干嘛干嘛

31:57.670 --> 31:58.670
对不对

31:58.670 --> 31:59.670
因为这个函数

31:59.670 --> 32:01.670
就是我们之前写的这一部分

32:01.670 --> 32:03.670
就是这一部分

32:03.670 --> 32:05.670
要更改的Dispatch

32:05.670 --> 32:06.670
就是这一部分

32:06.670 --> 32:07.670
那么我们甚至可以

32:07.670 --> 32:08.670
就直接在这儿

32:08.670 --> 32:10.670
把人拿过来

32:10.670 --> 32:11.670
对吧

32:11.670 --> 32:12.670
直接拿过来

32:12.670 --> 32:13.670
对不对

32:13.670 --> 32:14.670
好

32:14.670 --> 32:15.670
然后这里

32:15.670 --> 32:16.670
我们

32:16.670 --> 32:18.670
这边下面也是一样的

32:18.670 --> 32:19.670
中间1

32:19.670 --> 32:20.670
中间2

32:20.670 --> 32:21.670
中间2

32:21.670 --> 32:22.670
是吧

32:22.670 --> 32:23.670
可以拿过来

32:23.670 --> 32:24.670
那么拿过来之后

32:24.670 --> 32:25.670
就是我们代码

32:25.670 --> 32:26.670
就在这里边写

32:26.670 --> 32:27.670
这就是我们

32:27.670 --> 32:28.670
Dispatch函数

32:28.670 --> 32:29.670
那么我们之前

32:29.670 --> 32:30.670
分析的过程

32:30.670 --> 32:31.670
我们知道

32:31.670 --> 32:32.670
这个新的Dispatch函数

32:32.670 --> 32:33.670
是不是要应用

32:33.670 --> 32:34.670
老的Dispatch

32:34.670 --> 32:35.670
对吧

32:35.670 --> 32:36.670
是不是要应用

32:36.670 --> 32:37.670
老的Dispatch

32:37.670 --> 32:38.670
对不对

32:38.670 --> 32:39.670
那么这个

32:39.670 --> 32:40.670
老的Dispatch

32:40.670 --> 32:41.670
在哪里用呢

32:41.670 --> 32:42.670
有些同学说

32:42.670 --> 32:43.670
在这个Stone.Dispatch

32:43.670 --> 32:44.670
里面用

32:44.670 --> 32:45.670
在这里面

32:45.670 --> 32:46.670
Stone里面

32:46.670 --> 32:47.670
不是有Dispatch吗

32:47.670 --> 32:48.670
但是呢

32:48.670 --> 32:49.670
你要考虑

32:49.670 --> 32:50.670
多个人的情况

32:50.670 --> 32:51.670
这个Stone.Dispatch

32:51.670 --> 32:52.670
它是这样子

32:52.670 --> 32:53.670
它穿两个仓库

32:53.670 --> 32:55.670
这个仓库里面

32:55.670 --> 32:56.670
它是这样子

32:56.670 --> 32:57.670
在操作的

32:57.670 --> 33:01.140
看着啊

33:03.140 --> 33:05.140
这里是Stone

33:05.140 --> 33:06.140
它本身有一个Dispatch

33:06.140 --> 33:08.140
本身有一个Dispatch函数

33:08.140 --> 33:09.140
是吧

33:09.140 --> 33:10.140
本身有一个

33:11.140 --> 33:12.140
然后呢

33:12.140 --> 33:13.140
现在呢

33:13.140 --> 33:14.140
我们这里不是返回了

33:14.140 --> 33:15.140
一个新的函数吗

33:15.140 --> 33:16.140
到时候中间键

33:16.140 --> 33:17.140
它会把这个新的函数

33:17.140 --> 33:18.140
替换掉Dispatch

33:18.140 --> 33:20.140
但是它不是立即替换的

33:20.140 --> 33:21.140
因为它可能

33:21.140 --> 33:22.140
有多个中间

33:22.140 --> 33:24.140
它有多个中间键

33:24.140 --> 33:25.140
所以说呢

33:25.140 --> 33:26.140
它不是立即替换的

33:26.140 --> 33:27.140
它会怎么做呢

33:27.140 --> 33:28.140
它会这样做

33:28.140 --> 33:30.140
它会建立一个Dispatch变量

33:31.140 --> 33:32.140
它会创建

33:32.140 --> 33:35.140
它会得到一个Dispatch变量

33:39.410 --> 33:40.410
它是这样子

33:40.410 --> 33:41.410
我给大家看一下吧

33:42.410 --> 33:44.410
这是中间键

33:44.410 --> 33:46.410
这是中间键1

33:46.410 --> 33:47.410
中间键1

33:47.410 --> 33:49.410
至少你们目前应该知道

33:49.410 --> 33:50.410
中间键的作用是什么

33:50.410 --> 33:52.410
就是得到一个Dispatch函数

33:52.410 --> 33:53.410
对吧

33:53.410 --> 33:54.410
中间键本质

33:54.410 --> 33:55.410
就是得到一个Dispatch函数

33:55.410 --> 33:56.410
你看

33:56.410 --> 33:57.410
这里不是一个Dispatch函数吗

33:57.410 --> 33:58.410
外面为什么要套一层

33:58.410 --> 33:59.410
我们马上就知道了

34:00.410 --> 34:02.410
得到一个Dispatch函数

34:02.410 --> 34:03.410
那么这个中间键

34:03.410 --> 34:05.410
这是中间键1

34:05.410 --> 34:06.410
还有中间键2

34:06.410 --> 34:07.410
还有中间键2

34:08.410 --> 34:09.410
我们的注册顺序是

34:09.410 --> 34:10.410
先注册到中间键1

34:10.410 --> 34:11.410
2

34:11.410 --> 34:12.410
然后再注册到中间键1

34:12.410 --> 34:13.410
现在注册到1

34:13.410 --> 34:14.410
再注册到2

34:14.410 --> 34:16.410
然后还会做这么一件事情

34:16.410 --> 34:17.410
拿比方说吧

34:17.410 --> 34:18.410
还有中间键3

34:18.410 --> 34:20.410
起了很多个中间键

34:20.410 --> 34:21.410
每个中间键

34:21.410 --> 34:22.410
就是这么一个

34:22.410 --> 34:23.410
整个函数就中间键

34:24.410 --> 34:25.410
它返回一个Dispatch

34:25.410 --> 34:26.410
创建函数

34:26.410 --> 34:27.410
最终它会返回一个Dispatch函数

34:28.410 --> 34:29.410
那么它会怎么做呢

34:29.410 --> 34:30.410
你看着

34:30.410 --> 34:31.410
它会这样做

34:32.410 --> 34:33.410
这个方法

34:33.410 --> 34:34.410
就是Apply

34:35.410 --> 34:37.410
它会做这么一个处理

34:37.410 --> 34:38.410
看着

34:38.410 --> 34:39.410
一定要注意听

34:39.410 --> 34:41.410
它把这个仓库里面的

34:41.410 --> 34:42.410
原始的Dispatch

34:42.410 --> 34:43.410
给你传进来

34:45.410 --> 34:47.410
给你传到中间键1

34:47.410 --> 34:49.410
传进来

34:49.410 --> 34:50.410
传进来过后

34:50.410 --> 34:51.410
你是不是会得到

34:51.410 --> 34:52.410
一个新的Dispatch

34:52.410 --> 34:53.410
但是它不会立即

34:53.410 --> 34:54.410
把新的Dispatch

34:54.410 --> 34:55.410
给这里复制

34:55.410 --> 34:56.410
它不会

34:56.410 --> 34:57.410
它会得到一个

34:57.410 --> 34:58.410
你可以认为

34:58.410 --> 34:59.410
是个名识的辩量

35:01.410 --> 35:03.410
得到一个新的Dispatch

35:08.870 --> 35:11.760
这样

35:12.760 --> 35:13.760
得到一个新的Dispatch

35:14.760 --> 35:16.760
然后再把新的Dispatch

35:16.760 --> 35:18.760
又传给中间键2

35:18.760 --> 35:20.760
又传给中间键2

35:20.760 --> 35:21.760
那么中间键2

35:21.760 --> 35:22.760
是不是又得到一个

35:22.760 --> 35:23.760
新的Dispatch

35:23.760 --> 35:24.760
对吧

35:24.760 --> 35:26.760
又把中间键2的Dispatch

35:26.760 --> 35:28.760
又传给中间键1

35:28.760 --> 35:29.760
中间键1

35:30.760 --> 35:31.760
你看它是不是

35:31.760 --> 35:32.760
导则传递的

35:33.760 --> 35:34.760
对吧

35:34.760 --> 35:35.760
对吧

35:35.760 --> 35:36.760
它是导则传递的

35:36.760 --> 35:37.760
刚才声音

35:37.760 --> 35:39.760
好像有很大的回音

35:39.760 --> 35:40.760
对吧

35:40.760 --> 35:41.760
我那个麦没有去

35:41.760 --> 35:42.760
把关掉

35:42.760 --> 35:43.760
没有把

35:44.760 --> 35:45.760
音效没有关掉

35:45.760 --> 35:46.760
调一下

35:47.760 --> 35:48.760
这里

35:48.760 --> 35:49.760
它是导则传递的

35:49.760 --> 35:50.760
至于它

35:50.760 --> 35:51.760
为什么要导则传递

35:51.760 --> 35:52.760
我们一会就知道了

35:52.760 --> 35:53.760
它是导则传递的

35:53.760 --> 35:54.760
它先

35:54.760 --> 35:55.760
就是你给它传递的顺序

35:55.760 --> 35:56.760
是123

35:56.760 --> 35:57.760
这样传递的

35:57.760 --> 35:58.760
比方说我们这里

35:58.760 --> 35:59.760
传递的是

35:59.760 --> 36:00.760
log1

36:00.760 --> 36:01.760
log2

36:01.760 --> 36:02.760
对吧

36:02.760 --> 36:03.760
当然我们这里

36:03.760 --> 36:04.760
没有寫log3

36:04.760 --> 36:05.760
假设有个log3

36:06.760 --> 36:07.760
但是它调的顺序是

36:07.760 --> 36:09.760
先调用中间键3

36:10.760 --> 36:12.760
先调用这个函数

36:12.760 --> 36:13.760
先调用这个函数

36:14.760 --> 36:15.760
调用这个函数

36:15.760 --> 36:16.760
然后

36:16.760 --> 36:19.760
把原式的Dispatch传过去

36:20.760 --> 36:22.760
把原式的Dispatch传过去

36:22.760 --> 36:23.760
那么也就是说

36:23.760 --> 36:24.760
这个函数里边

36:24.760 --> 36:25.760
它有个参数叫Dispatch

36:26.760 --> 36:27.760
原式的Dispatch传过去

36:28.760 --> 36:29.760
把这个函数

36:29.760 --> 36:31.760
这个函数返回的Dispatch

36:31.760 --> 36:32.760
你看一下这个函数

36:32.760 --> 36:33.760
它是不是返回一个Dispatch

36:33.760 --> 36:35.760
返回的是一个Dispatch

36:35.760 --> 36:37.760
那么就把这个返回的Dispatch

36:40.760 --> 36:41.760
那么

36:41.760 --> 36:42.760
传递给中间

36:42.760 --> 36:43.760
前面那个中间键

36:43.760 --> 36:44.760
前面那个中间键是啥

36:44.760 --> 36:45.760
就这个

36:45.760 --> 36:46.760
前面那个中间键

36:46.760 --> 36:47.760
就这个

36:47.760 --> 36:48.760
你说这个地方

36:48.760 --> 36:49.760
它得到的Dispatch

36:49.760 --> 36:50.760
是前面那个中间键

36:50.760 --> 36:51.760
就之后那个中间键

36:51.760 --> 36:52.760
传递过来的Dispatch

36:53.760 --> 36:55.760
所以说你这里

36:55.760 --> 36:57.760
你如果说在中间键里边

36:57.760 --> 36:58.760
用什么

36:58.760 --> 36:59.760
用那个store的Dispatch的话

36:59.760 --> 37:00.760
用的是原式的

37:00.760 --> 37:02.760
用的是最原式的Dispatch

37:02.760 --> 37:03.760
而不是上一个中间键

37:03.760 --> 37:04.760
传过来的

37:04.760 --> 37:05.760
如果还有下一个

37:05.760 --> 37:06.760
还有之前的中间键的话

37:06.760 --> 37:07.760
又把这个Dispatch

37:07.760 --> 37:08.760
又传过去

37:08.760 --> 37:09.760
看了没

37:09.760 --> 37:10.760
是这么个意思

37:10.760 --> 37:11.760
是这么个意思

37:11.760 --> 37:12.760
那么这个中间键

37:12.760 --> 37:13.760
是不是也会得到一个Dispatch

37:13.760 --> 37:14.760
对吧

37:14.760 --> 37:15.760
那么这个中间键

37:15.760 --> 37:16.760
已经是

37:16.760 --> 37:17.760
第一个中间键了

37:17.760 --> 37:18.760
因此它最后

37:18.760 --> 37:19.760
会把这个中间键

37:19.760 --> 37:20.760
Dispatch的最终

37:20.760 --> 37:22.760
复制给这个Stone的Dispatch

37:22.760 --> 37:23.760
最终会复制过去

37:23.760 --> 37:24.760
它是这么一个过程

37:24.760 --> 37:26.760
它是最后完成复制

37:26.760 --> 37:28.760
等你把所有的中间键

37:28.760 --> 37:29.760
的Dispatch

37:29.760 --> 37:30.760
全部拿到过后

37:30.760 --> 37:32.760
拿到第一个中间键的Dispatch

37:32.760 --> 37:33.760
OK

37:33.760 --> 37:34.760
我再把第一个Dispatch

37:34.760 --> 37:35.760
这样的复制过去

37:35.760 --> 37:36.760
复制过去

37:36.760 --> 37:38.760
一样的意思吗

37:38.760 --> 37:39.760
你看

37:39.760 --> 37:40.760
仔细看一下这个过程

37:40.760 --> 37:41.760
它先把原式的Dispatch

37:41.760 --> 37:42.760
传给最后一个中间键

37:42.760 --> 37:43.760
然后把最后一个中间键

37:43.760 --> 37:44.760
执行了Dispatch

37:44.760 --> 37:45.760
传给之前的中间键

37:45.760 --> 37:46.760
又打到一个Dispatch

37:46.760 --> 37:47.760
那么这样子

37:47.760 --> 37:48.760
是不是一层一层

37:48.760 --> 37:49.760
就传递过去了

37:49.760 --> 37:50.760
对吧

37:50.760 --> 37:51.760
所以说

37:51.760 --> 37:52.760
为什么我刚才说

37:52.760 --> 37:53.760
在这里边

37:53.760 --> 37:54.760
去拿这个Stone的Dispatch

37:54.760 --> 37:55.760
不太正确

37:55.760 --> 37:56.760
因为你这里

37:56.760 --> 37:57.760
比方说

37:57.760 --> 37:58.760
因为你不知道这个中间键

37:58.760 --> 37:59.760
它是第几个

37:59.760 --> 38:00.760
你不知道它是第几个

38:00.760 --> 38:01.760
它写的这个Mogo

38:01.760 --> 38:02.760
就是第1个

38:02.760 --> 38:03.760
你不知道它是第几个

38:03.760 --> 38:05.760
比方说它是这个中间键

38:05.760 --> 38:06.760
那么这个时候

38:06.760 --> 38:07.760
你要拿的Dispatch

38:07.760 --> 38:09.760
你不能影响之前的

38:09.760 --> 38:10.760
跟中间键的功能

38:10.760 --> 38:11.760
你不能影响

38:11.760 --> 38:12.760
之后的中间键的功能

38:12.760 --> 38:13.760
所以说你要去拿

38:13.760 --> 38:14.760
之后的中间键

38:14.760 --> 38:15.760
给你传过来的Dispatch

38:15.760 --> 38:16.760
你不能去拿原式的Dispatch

38:16.760 --> 38:17.760
当然

38:17.760 --> 38:18.760
也要看情况

38:18.760 --> 38:19.760
它既然把原式的Dispatch

38:19.760 --> 38:20.760
提供给你的

38:20.760 --> 38:21.760
通过Stone

38:21.760 --> 38:22.760
提供给你的

38:22.760 --> 38:23.760
那肯定有它的作用

38:23.760 --> 38:24.760
比方说有的时候

38:24.760 --> 38:25.760
有些中间键

38:25.760 --> 38:26.760
它比较霸道

38:26.760 --> 38:27.760
比方这个中间键很霸道

38:27.760 --> 38:28.760
我不管

38:28.760 --> 38:29.760
我啥都不管

38:29.760 --> 38:30.760
不管我不听

38:30.760 --> 38:32.760
我就要用原式的Dispatch

38:32.760 --> 38:33.760
我要忽略掉

38:33.760 --> 38:34.760
之前中间键的功能

38:34.760 --> 38:35.760
就之后的中间键的功能

38:35.760 --> 38:36.760
我要忽略掉

38:36.760 --> 38:38.760
我不能用之后的中间键的功能

38:38.760 --> 38:39.760
哪怕你写的再多功能

38:39.760 --> 38:40.760
我都不管

38:40.760 --> 38:42.760
我就要用我自己的功能

38:42.760 --> 38:43.760
我就要用原式的Dispatch

38:43.760 --> 38:44.760
OK

38:44.760 --> 38:45.760
那你去拿Stone的Dispatch

38:45.760 --> 38:46.760
是不一样的

38:46.760 --> 38:48.760
通过这个参数

38:48.760 --> 38:49.760
去拿到这个Dispatch

38:49.760 --> 38:51.760
和从Stone里边的Dispatch

38:51.760 --> 38:52.760
它的概念是不一样的

38:52.760 --> 38:53.760
你在中间键里边

38:53.760 --> 38:54.760
通过Stone的Dispatch

38:54.760 --> 38:55.760
去拿的话

38:55.760 --> 38:56.760
拿到的是最原式的

38:56.760 --> 38:58.760
长谱里边的自带的Dispatch

38:58.760 --> 38:59.760
那么如果你

38:59.760 --> 39:00.760
通过这个参数

39:00.760 --> 39:01.760
去拿到Dispatch

39:01.760 --> 39:02.760
指的是上一个

39:02.760 --> 39:03.760
就是之后的中间键

39:03.760 --> 39:05.760
传过来的Dispatch

39:05.760 --> 39:06.760
通过这个筒

39:06.760 --> 39:07.760
我们也可以看到

39:07.760 --> 39:09.760
对于一个中间键而言

39:11.760 --> 39:13.760
那么它这个Dispatch

39:13.760 --> 39:15.760
这个参数这个Dispatch

39:15.760 --> 39:16.760
是不是它的下一个

39:16.760 --> 39:17.760
中间键传过来的Dispatch

39:18.760 --> 39:19.760
对于启动了一个

39:19.760 --> 39:20.760
中间键而言

39:20.760 --> 39:21.760
不要对它而言

39:21.760 --> 39:22.760
它这个Dispatch

39:22.760 --> 39:24.760
它参数的Dispatch

39:24.760 --> 39:25.760
是不是下一个中间键

39:25.760 --> 39:26.760
传过来的Dispatch

39:27.760 --> 39:28.760
对吧

39:28.760 --> 39:29.760
所以说有的时候

39:29.760 --> 39:30.760
这个参数也叫做Next

39:31.760 --> 39:32.760
下一个中间键

39:32.760 --> 39:33.760
传过来的Dispatch

39:33.760 --> 39:34.760
也叫做Next

39:34.760 --> 39:35.760
这是一种习惯上的

39:35.760 --> 39:36.760
写法而已

39:36.760 --> 39:37.760
只不过呢

39:38.760 --> 39:39.760
只不过呢

39:39.760 --> 39:40.760
就是我们这里

39:40.760 --> 39:41.760
告诉大家

39:41.760 --> 39:42.760
这里就是Dispatch

39:42.760 --> 39:43.760
就是Dispatch的函数

39:43.760 --> 39:44.760
只不过呢

39:44.760 --> 39:45.760
我们平时写法上的

39:45.760 --> 39:46.760
习惯上把它写为Next

39:46.760 --> 39:48.760
就是下一个中间键的Dispatch

39:49.760 --> 39:50.760
理解这个意思吗

39:51.760 --> 39:52.760
这样子的

39:52.760 --> 39:53.760
形成这么一种结构之后

39:53.760 --> 39:54.760
有什么好处呢

39:54.760 --> 39:56.760
就在于每一个中间键

39:56.760 --> 39:57.760
我是不是不用管

39:57.760 --> 39:58.760
我是第几个注册的

39:58.760 --> 39:59.760
对吧

39:59.760 --> 40:00.760
注册中间键就是这样的

40:00.760 --> 40:01.760
注册中间键

40:01.760 --> 40:02.760
我不用管我的注册顺序

40:02.760 --> 40:03.760
我是第几个

40:03.760 --> 40:05.760
我总归可以拿到

40:05.760 --> 40:06.760
下一个Dispatch

40:06.760 --> 40:07.760
下一个Dispatch

40:07.760 --> 40:09.760
我总归是可以拿到的

40:09.760 --> 40:10.760
可以拿到的

40:10.760 --> 40:12.760
那么就形成了这么一种结构

40:12.760 --> 40:15.760
到时候你要分发数据

40:15.760 --> 40:16.760
分发的是啥

40:16.760 --> 40:17.760
分发的是不是

40:17.760 --> 40:18.760
第一个中间键的Dispatch

40:18.760 --> 40:19.760
对吧

40:19.760 --> 40:20.760
因为它最终是

40:20.760 --> 40:22.760
给到这个仓库的Dispatch

40:22.760 --> 40:23.760
好

40:23.760 --> 40:24.760
那么到时候我们要

40:24.760 --> 40:25.760
触发分发数据

40:25.760 --> 40:27.760
是不是一定是拿到

40:27.760 --> 40:28.760
第一个的Dispatch

40:28.760 --> 40:29.760
那么第一个Dispatch

40:29.760 --> 40:30.760
它调用的过程中

40:30.760 --> 40:31.760
就拿到这个函数

40:31.760 --> 40:32.760
调用这个函数

40:32.760 --> 40:33.760
调用的过程中

40:33.760 --> 40:34.760
是不是又翻过来了

40:34.760 --> 40:35.760
调用的过程中

40:35.760 --> 40:36.760
是不是顺序调用

40:36.760 --> 40:37.760
先调用它

40:37.760 --> 40:38.760
调用它的过程中

40:38.760 --> 40:39.760
它可能会用到

40:39.760 --> 40:40.760
之前之后的Dispatch

40:40.760 --> 40:41.760
对吧

40:41.760 --> 40:42.760
调用它自己

40:42.760 --> 40:43.760
运行这个

40:43.760 --> 40:45.760
然后再运行之后的Dispatch

40:45.760 --> 40:46.760
然后再运行这个

40:46.760 --> 40:47.760
是这个意思吗

40:47.760 --> 40:48.760
对吧

40:48.760 --> 40:49.760
没问题吧

40:49.760 --> 40:50.760
那么我们可以把这个

40:50.760 --> 40:51.760
放过来吗

40:51.760 --> 40:52.760
放过来

40:52.760 --> 40:53.760
放过来

40:54.760 --> 40:55.760
这样子

40:55.760 --> 40:56.760
把第一个中间键运行完了

40:56.760 --> 40:57.760
拿到它第二个Dispatch

40:57.760 --> 40:58.760
当然这个

40:58.760 --> 40:59.760
这个调用

40:59.760 --> 41:00.760
怎么去调用Dispatch

41:00.760 --> 41:01.760
Nex在哪里调用

41:01.760 --> 41:02.760
随便你

41:02.760 --> 41:03.760
总之你要运行

41:03.760 --> 41:05.760
如果说你要运行之后的Dispatch

41:05.760 --> 41:06.760
你就去调用

41:06.760 --> 41:07.760
如果说你不运行之后的Dispatch

41:07.760 --> 41:08.760
你就不要去调用

41:08.760 --> 41:09.760
对吧

41:09.760 --> 41:10.760
根据你自己的情况

41:10.760 --> 41:11.760
根据你自己的情况

41:11.760 --> 41:12.760
自行决定

41:12.760 --> 41:13.760
自行决定

41:13.760 --> 41:15.760
它就形成了这么一种结构

41:15.760 --> 41:16.760
所以说我这里为什么Nex

41:16.760 --> 41:17.760
它为什么之前要反过来

41:17.760 --> 41:18.760
就是因为调用的时候

41:18.760 --> 41:19.760
是顺序调用的

41:19.760 --> 41:20.760
一不反过来的话

41:20.760 --> 41:22.760
调用的顺序就是导致调用的

41:22.760 --> 41:23.760
它保证

41:23.760 --> 41:24.760
它为了保证

41:24.760 --> 41:26.760
调用的顺序是顺着调用的

41:26.760 --> 41:27.760
那么

41:27.760 --> 41:28.760
它要把它反过来

41:28.760 --> 41:29.760
当然

41:29.760 --> 41:30.760
要不要调用

41:30.760 --> 41:31.760
怎么去调用

41:31.760 --> 41:32.760
什么时候去调用

41:32.760 --> 41:34.760
完全取决于你这个中间键里边

41:34.760 --> 41:36.760
Nex代码的位置

41:36.760 --> 41:37.760
要不要写Nex代码

41:37.760 --> 41:39.760
要不要去调用下一个中间键

41:39.760 --> 41:40.760
那么就形成这么一个模型了

41:40.760 --> 41:41.760
对吧

41:41.760 --> 41:42.760
就好比说

41:42.760 --> 41:43.760
咱们就是

41:43.760 --> 41:45.760
有很多人排成一排

41:45.760 --> 41:46.760
做一件事

41:46.760 --> 41:47.760
这些人都是中间键

41:47.760 --> 41:48.760
这些人做了一些事

41:48.760 --> 41:49.760
做了一半

41:49.760 --> 41:50.760
或者是做完了

41:50.760 --> 41:51.760
然后把它交给下一个人

41:51.760 --> 41:52.760
下个人做完了

41:52.760 --> 41:53.760
又交给下一个人

41:53.760 --> 41:54.760
对吧

41:54.760 --> 41:56.760
每一个人去处理自己的事情就行了

41:56.760 --> 41:57.760
那么每个中间键

41:57.760 --> 41:58.760
它就是相互隔离的

41:58.760 --> 41:59.760
相互隔离的

41:59.760 --> 42:01.760
就形成了这么一种结构

42:01.760 --> 42:02.760
这就是中间键的结构

42:02.760 --> 42:03.760
其实像这种结构

42:03.760 --> 42:04.760
我们以后

42:04.760 --> 42:05.760
你们以后在

42:05.760 --> 42:06.760
就是

42:06.760 --> 42:08.760
悬逗的阶势的时候

42:08.760 --> 42:09.760
里面也会遇到一些中间键

42:09.760 --> 42:10.760
那么他们

42:10.760 --> 42:12.760
也是类似的处理方式

42:13.760 --> 42:14.760
好

42:14.760 --> 42:15.760
那么就形成一种中间

42:15.760 --> 42:16.760
在中间的一个环节

42:16.760 --> 42:17.760
不断的传递的过程

42:17.760 --> 42:18.760
好

42:18.760 --> 42:19.760
于是那我们运行出来看一下

42:19.760 --> 42:21.760
是不是运行的顺序是

42:21.760 --> 42:22.760
我下面没有改

42:22.760 --> 42:24.760
下面改成中间键2

42:25.760 --> 42:26.760
那么运行的顺序

42:26.760 --> 42:27.760
你看是不是中间键1

42:27.760 --> 42:28.760
中间键2

42:28.760 --> 42:29.760
中间键1

42:29.760 --> 42:30.760
中间键2

42:30.760 --> 42:32.760
每一次Dispatch的时候

42:32.760 --> 42:33.760
它就会运行这个

42:33.760 --> 42:34.760
对不对

42:34.760 --> 42:35.760
这个东西就是最终

42:35.760 --> 42:37.760
你调用Dispatch的时候

42:37.760 --> 42:38.760
要运行的函数

42:38.760 --> 42:39.760
你可以这样理解

42:39.760 --> 42:40.760
这个函数就是你最终

42:40.760 --> 42:42.760
要调用Dispatch的时候

42:42.760 --> 42:43.760
要运行的东西

42:43.760 --> 42:44.760
它会一个一个一次运行

42:44.760 --> 42:45.760
先运行它

42:45.760 --> 42:47.760
然后运行它过后

42:47.760 --> 42:48.760
只要看到这个代码

42:48.760 --> 42:49.760
它就会把它交给

42:49.760 --> 42:51.760
下一个中间键去运行

42:51.760 --> 42:52.760
下个中间键运行完了过

42:52.760 --> 42:53.760
它又会运行Dex

42:53.760 --> 42:55.760
又会交给下一个中间键

42:55.760 --> 42:56.760
又会交给下一个中间键

42:56.760 --> 42:58.760
就是这么个意思

43:00.760 --> 43:01.760
没问题吧

43:01.760 --> 43:02.760
最终一直调用

43:02.760 --> 43:03.760
一直调用

43:03.760 --> 43:05.760
调用到原始的Dispatch为止

43:05.760 --> 43:06.760
对吧

43:06.760 --> 43:08.760
这就是中间键的

43:08.760 --> 43:10.760
就是它的写法

43:10.760 --> 43:11.760
它的写法就是这个样子

43:11.760 --> 43:12.760
这样子

43:12.760 --> 43:13.760
我们就可以做日子记录了

43:13.760 --> 43:14.760
对吧

43:14.760 --> 43:16.760
这就是中间键

43:16.760 --> 43:18.760
它的这种书写方式

43:18.760 --> 43:19.760
那么基于这种书写方式

43:19.760 --> 43:21.760
这样子写肯定是比较麻烦的

43:21.760 --> 43:22.760
但是这种写法

43:22.760 --> 43:23.760
你一定要理解

43:23.760 --> 43:24.760
一定要理解这种写法

43:24.760 --> 43:25.760
它这个函数

43:25.760 --> 43:26.760
为什么要套这么多层

43:26.760 --> 43:27.760
为什么要套这么多层

43:27.760 --> 43:28.760
我再重复一次

43:28.760 --> 43:29.760
第一层函数

43:29.760 --> 43:30.760
它是来得到仓库的

43:30.760 --> 43:31.760
因为仓库只有一个

43:31.760 --> 43:32.760
对不对

43:32.760 --> 43:33.760
只有一个仓库

43:33.760 --> 43:34.760
它不会有太多的仓库

43:34.760 --> 43:35.760
只有这么一个仓库

43:35.760 --> 43:36.760
它要得到这个仓库

43:36.760 --> 43:37.760
仓库里面就提供了

43:37.760 --> 43:38.760
什么状态数据

43:38.760 --> 43:39.760
还要得到这个仓库

43:39.760 --> 43:40.760
提供了就是

43:40.760 --> 43:42.760
哦 这里不行不行不行

43:42.760 --> 43:43.760
新数据

43:43.760 --> 43:44.760
新数据的话

43:44.760 --> 43:46.760
还必须要写到那个写字后

43:47.760 --> 43:48.760
新数据要写到那个写字后

43:48.760 --> 43:49.760
因为你只有调用了

43:49.760 --> 43:50.760
后边的中间键

43:50.760 --> 43:52.760
你只有调用了后边的中间键

43:52.760 --> 43:54.760
你才知道新的数据是什么

43:54.760 --> 43:56.760
因为追踪原式的地质派系

43:56.760 --> 43:58.760
它才会把数据给更改

43:58.760 --> 44:00.760
所以说你得先调用后边的中间键

44:02.760 --> 44:03.760
看来

44:03.760 --> 44:04.760
这就是新数据

44:04.760 --> 44:05.760
新数据

44:05.760 --> 44:06.760
新数据

44:06.760 --> 44:07.760
先调用后边的中间键

44:08.760 --> 44:09.760
好 看来

44:09.760 --> 44:11.760
就行了这么种结构了

44:12.760 --> 44:13.760
中间键1

44:13.760 --> 44:15.760
中间键1运行就数据

44:15.760 --> 44:16.760
运行了这两句话

44:16.760 --> 44:17.760
运行了这两句话

44:17.760 --> 44:18.760
然后运行了一个型

44:18.760 --> 44:19.760
对不对

44:19.760 --> 44:20.760
运行的一个型是啥

44:20.760 --> 44:22.760
然后呢

44:22.760 --> 44:23.760
由于调用了那个式

44:23.760 --> 44:24.760
是不是运行中间键2

44:24.760 --> 44:25.760
对吧

44:25.760 --> 44:26.760
运行中间键2

44:26.760 --> 44:27.760
运行了这一坨

44:27.760 --> 44:28.760
你看没有

44:28.760 --> 44:30.760
中间键2运行了这一坨

44:30.760 --> 44:31.760
然后呢

44:31.760 --> 44:34.760
中间键2里面运行了原式的地质派系

44:34.760 --> 44:35.760
原式的地质派系

44:35.760 --> 44:37.760
然后就是数据发生变化了

44:37.760 --> 44:39.760
然后再运行中间键2的

44:39.760 --> 44:40.760
这个代码

44:40.760 --> 44:42.760
这个地方是运行中间键2的新数据

44:42.760 --> 44:43.760
对不对

44:43.760 --> 44:44.760
然后换行

44:44.760 --> 44:45.760
换行之后呢

44:45.760 --> 44:47.760
又回到第1个中间键

44:47.760 --> 44:48.760
它这个地方运行完了

44:48.760 --> 44:50.760
因为运行第1个中间键的新数据

44:50.760 --> 44:52.760
就形成这种洋冲模型

44:52.760 --> 44:53.760
以后呢

44:53.760 --> 44:54.760
你们学行路的JS里面

44:54.760 --> 44:55.760
Express

44:55.760 --> 44:56.760
它也会说到这个洋冲模型

44:56.760 --> 44:57.760
就是什么了

44:57.760 --> 44:58.760
洋冲模型是这个样子

44:59.760 --> 45:00.760
我在百度里面

45:00.760 --> 45:01.760
给大家收一下吧

45:01.760 --> 45:02.760
我之前就来的话了

45:02.760 --> 45:03.760
洋冲模型

45:03.760 --> 45:05.760
洋冲模型

45:09.760 --> 45:10.760
你看一下就这个

45:12.760 --> 45:14.760
就是你这里每一个圈就是个中间键

45:14.760 --> 45:15.760
每个圈就是个中间键

45:15.760 --> 45:17.760
这个画的还不是很好

45:17.760 --> 45:19.760
我给大家看一下图片里面

45:19.760 --> 45:20.760
洋冲模型

45:27.650 --> 45:28.650
我们来看一下吧

45:28.650 --> 45:30.650
就在这里

45:30.650 --> 45:33.650
这个图片怎么那么不相干呢

45:34.650 --> 45:35.650
洋冲模型

45:35.650 --> 45:37.650
哎呀还真

45:37.650 --> 45:39.650
不是很好收到

45:40.650 --> 45:41.650
你可以想象成

45:41.650 --> 45:43.650
它是一个一个的同心圆

45:43.650 --> 45:44.650
这样子吧

45:44.650 --> 45:45.650
你可以想象成

45:45.650 --> 45:47.650
它是一个一个的同心圆

45:48.650 --> 45:49.650
形状天冲

45:49.650 --> 45:50.650
无天冲

45:50.650 --> 45:54.820
轮廓

45:54.820 --> 45:56.820
这是

45:56.820 --> 46:03.140
一个一个的同心圆

46:03.140 --> 46:04.140
稍等一下

46:09.140 --> 46:10.140
我们画3个

46:11.140 --> 46:12.140
当我们掉

46:12.140 --> 46:13.140
每一个圆圈

46:13.140 --> 46:14.140
它就是一个Dispatch

46:14.140 --> 46:16.140
一个Dispatch套一个

46:16.140 --> 46:17.140
就第一个中间键的Dispatch

46:17.140 --> 46:18.140
它套了第二个

46:18.140 --> 46:19.140
然后

46:19.140 --> 46:20.140
第二个套了第三个

46:20.140 --> 46:21.140
对吧

46:21.140 --> 46:22.140
就像我们这种情况下

46:22.140 --> 46:24.140
log1它套了第二个

46:24.140 --> 46:26.140
log2它套了第三个

46:26.140 --> 46:28.140
第三个就是圆式的了

46:28.140 --> 46:29.140
它运行的时候

46:29.140 --> 46:30.140
是调用log1

46:30.140 --> 46:33.140
比方说我们这里画一个图

46:33.140 --> 46:35.140
log1它是这样调用的

46:36.140 --> 46:37.140
它是这样调用的

46:38.140 --> 46:39.140
你看呀

46:39.140 --> 46:40.140
调用log1的时候

46:40.140 --> 46:41.140
是不是先运行

46:41.140 --> 46:42.140
log1的代码

46:42.140 --> 46:43.140
对不对

46:43.140 --> 46:44.140
log1的代码

46:44.140 --> 46:45.140
log1的代码是不是运行了这三句话

46:45.140 --> 46:47.140
然后log1是不是调用了下一个

46:47.140 --> 46:48.140
对不对

46:48.140 --> 46:49.140
下一个

46:49.140 --> 46:50.140
于是它又进入下一个去运行了

46:50.140 --> 46:52.140
它又进入下一个去运行了

46:52.140 --> 46:54.140
下一个又在调用

46:54.140 --> 46:56.140
又在运行了这三句话

46:56.140 --> 46:57.140
还又在调用下一个

46:57.140 --> 46:58.140
下一个是不是

46:58.140 --> 47:00.140
就是它圆式的Dispatch了

47:00.140 --> 47:01.140
圆式的Dispatch运行了

47:01.140 --> 47:02.140
好

47:02.140 --> 47:03.140
圆式的Dispatch运行完了之后

47:03.140 --> 47:04.140
是不是又回到第二个

47:04.140 --> 47:05.140
对吧

47:05.140 --> 47:06.140
又回到这里

47:06.140 --> 47:07.140
又运行这里

47:07.140 --> 47:08.140
对吧

47:08.140 --> 47:09.140
好 这里运行完了过去

47:09.140 --> 47:10.140
是不是又回到第一个

47:10.140 --> 47:11.140
又把剩下的事情运行完

47:11.140 --> 47:14.140
这就是形成这么一种扬出模型

47:14.140 --> 47:17.140
那么你可以把这个Nex放到任何为之去调用

47:17.140 --> 47:19.140
总之就是调用下一个

47:19.140 --> 47:20.140
把下个中间键运行完

47:20.140 --> 47:22.140
运行完了过后再运行这个

47:22.140 --> 47:24.140
这就是中间键的这么一种模型

47:24.140 --> 47:27.140
以后大家学些no的解释还会遇到

47:27.140 --> 47:29.140
好 那么现在我们再说一下这个函数

47:29.140 --> 47:30.140
这个函数现在这种写法

47:30.140 --> 47:32.140
你首先要理解这个函数这种写法

47:32.140 --> 47:33.140
理解了之后

47:33.140 --> 47:36.140
那么你知道中间键怎么去写了过后

47:36.140 --> 47:39.140
那么这个中间键可以有更加简洁的写法

47:39.140 --> 47:40.140
当然只是

47:40.140 --> 47:43.140
语法上写得更加舒服一点

47:43.140 --> 47:45.140
这张字写得太难看了

47:45.140 --> 47:47.140
所以说我们可以用这种方式来写

47:47.140 --> 47:48.140
用箭头函数

47:48.140 --> 47:50.140
但是你前提条件再先理解这个

47:50.140 --> 47:52.140
不然你根本就理解不了一个箭头函数

47:52.140 --> 47:53.140
LOG1

47:53.140 --> 47:54.140
我怎么写呢

47:54.140 --> 47:55.140
你看着我这样子写

47:55.140 --> 47:56.140
STONE

47:56.140 --> 47:57.140
当然这里也可以解构

47:57.140 --> 47:58.140
GateState

47:58.140 --> 48:00.140
要用到哪些什么Dispatch

48:00.140 --> 48:02.140
要用到哪些可以进行解构

48:02.140 --> 48:03.140
当然我懒得去解构了

48:03.140 --> 48:05.140
就是STONE

48:05.140 --> 48:06.140
那么这个STONE是个函数

48:06.140 --> 48:07.140
它反回什么

48:07.140 --> 48:09.140
反回一个函数

48:09.140 --> 48:11.140
反回一个函数

48:11.140 --> 48:12.140
函数是什么

48:12.140 --> 48:13.140
函数是

48:13.140 --> 48:15.140
有个参数Negas

48:15.140 --> 48:16.140
Negas

48:16.140 --> 48:18.140
这个Negas是不是又要反回一个函数

48:18.140 --> 48:19.140
又要反回一个函数

48:19.140 --> 48:20.140
这个函数是x

48:20.140 --> 48:21.140
有参数x

48:21.140 --> 48:24.140
有参数x

48:24.140 --> 48:25.140
对吧

48:25.140 --> 48:26.140
它就形成这么一种结构

48:26.140 --> 48:27.140
最终呢

48:27.140 --> 48:28.140
x里面

48:28.140 --> 48:29.140
x里面

48:29.140 --> 48:30.140
是这么一坨

48:30.140 --> 48:34.660
x里面是这么一坨

48:37.660 --> 48:38.660
实际上

48:38.660 --> 48:40.660
我们可以把扩好去掉

48:40.660 --> 48:41.660
扩好去掉

48:41.660 --> 48:42.660
它是能够理解的

48:42.660 --> 48:43.660
是能够理解的

48:43.660 --> 48:45.660
可以去掉扩好就行了

48:45.660 --> 48:46.660
你看

48:46.660 --> 48:48.660
就形成了这么一种结构

48:48.660 --> 48:50.660
它反回这么一个函数

48:50.660 --> 48:52.660
参数为Negas的函数

48:52.660 --> 48:53.660
那么这个Negas

48:53.660 --> 48:54.660
这个函数

48:54.660 --> 48:55.660
它又反回这个函数

48:55.660 --> 48:57.660
就是一个Dispatch函数

48:57.660 --> 48:59.660
最重要覆盖的Dispatch函数

48:59.660 --> 49:00.660
Negas1

49:00.660 --> 49:01.660
是不是这样的简介多了

49:01.660 --> 49:03.660
然后Negas2

49:03.660 --> 49:05.660
也是这种结构

49:05.660 --> 49:07.660
也是这种结构

49:08.660 --> 49:10.660
那么下面我就注射掉了

49:18.350 --> 49:19.350
你看一下

49:19.350 --> 49:20.350
是不是完全一样的

49:20.350 --> 49:21.350
对吧

49:21.350 --> 49:22.350
完全一样的

49:22.350 --> 49:23.350
这就是

49:23.350 --> 49:24.350
这个中间键

49:24.350 --> 49:25.350
你至少再知道

49:25.350 --> 49:27.350
中间键怎么去书写

49:27.350 --> 49:28.350
至少得知道这一点

49:28.350 --> 49:29.350
你至少得监国

49:29.350 --> 49:30.350
至少得监国

49:30.350 --> 49:31.350
本块你会不会

49:31.350 --> 49:32.350
至少得监国

49:32.350 --> 49:33.350
监国这个中间键

49:33.350 --> 49:35.350
怎么去写

49:35.350 --> 49:36.350
这是中间键

49:36.350 --> 49:38.350
如何来书写一个中间键

49:39.350 --> 49:40.350
书写中间键完了过后

49:40.350 --> 49:41.350
我们再来看

49:41.350 --> 49:43.350
如何来应用一个中间键

49:43.350 --> 49:44.350
应用中间键

49:44.350 --> 49:45.350
我们之前写到这

49:47.350 --> 49:50.350
这是第一种应用方式

49:50.350 --> 49:52.350
这是第一种应用方式

49:52.350 --> 49:54.350
第二种应用方式

49:54.350 --> 49:56.350
第二种应用方式

49:56.350 --> 49:57.350
我们看一下

49:57.350 --> 50:00.350
应用中间键

50:00.350 --> 50:02.350
方式1

50:02.350 --> 50:03.350
那么这里

50:03.350 --> 50:05.350
方式2

50:05.350 --> 50:06.350
有两种方式

50:06.350 --> 50:07.350
第二种

50:07.350 --> 50:08.350
我不用什么

50:10.350 --> 50:11.350
来创建中间键的

50:11.350 --> 50:12.350
我们使用

50:13.350 --> 50:15.350
用这种方式来创建中间键

50:15.350 --> 50:16.350
就是来创建仓库

50:16.350 --> 50:17.350
不用这种方式

50:17.350 --> 50:18.350
来创建仓库了

50:18.350 --> 50:19.350
这个函数

50:19.350 --> 50:20.350
它怎么来创建仓库

50:20.350 --> 50:21.350
它这样子

50:21.350 --> 50:24.350
首先你把中间键传进去

50:24.350 --> 50:25.350
我没有两个中间键

50:25.350 --> 50:26.350
传进去

50:26.350 --> 50:27.350
那么这个玩意

50:27.350 --> 50:29.350
它会返回一个函数

50:29.350 --> 50:30.350
这个函数

50:30.350 --> 50:31.350
是用来帮助你

50:31.350 --> 50:32.350
创建仓库的

50:33.350 --> 50:34.350
首先这个函数

50:34.350 --> 50:36.350
它是来固定

50:36.350 --> 50:37.350
大家来记录

50:37.350 --> 50:39.350
你有哪些中间键

50:39.350 --> 50:41.350
我们这里寄个笔记

50:42.350 --> 50:43.350
Apply

50:45.350 --> 50:47.350
Apply middleware

50:47.350 --> 50:49.350
Apply middleware

50:49.350 --> 50:50.350
函数

50:50.350 --> 50:52.350
用于记录

50:54.350 --> 50:57.350
有哪些中间键

50:57.350 --> 50:58.350
它是用来记录

50:58.350 --> 50:59.350
有哪些中间键

50:59.350 --> 51:02.350
它会返回一个

51:02.350 --> 51:04.350
仓库创建

51:07.350 --> 51:13.860
它会返回一个函数

51:13.860 --> 51:14.860
它会返回一个函数

51:14.860 --> 51:15.860
这个函数

51:15.860 --> 51:16.860
我真的不知道

51:16.860 --> 51:17.860
该怎么去教它

51:17.860 --> 51:18.860
那么现在我们说

51:18.860 --> 51:19.860
它这个函数

51:21.860 --> 51:22.860
首先Apply

51:22.860 --> 51:23.860
它本身是个函数

51:23.860 --> 51:24.860
它记录了有哪些中间键

51:24.860 --> 51:25.860
它没有做任何事情

51:25.860 --> 51:26.860
这个函数

51:26.860 --> 51:28.860
那么它会返回一个函数

51:28.860 --> 51:29.860
这个函数用来干嘛

51:30.860 --> 51:31.860
该函数

51:31.860 --> 51:32.860
它返回那个函数

51:32.860 --> 51:33.860
用于

51:33.860 --> 51:34.860
我在这里

51:34.860 --> 51:36.860
打了一个就是Type键

51:36.860 --> 51:37.860
就是一个说劲

51:37.860 --> 51:38.860
就表示这个描述的是

51:38.860 --> 51:39.860
这个返回的函数

51:40.860 --> 51:43.860
该函数用于记录

51:43.860 --> 51:44.860
有哪些

51:46.860 --> 51:50.860
创建仓库的方法

51:50.860 --> 51:51.860
就是我们创建仓库

51:51.860 --> 51:52.860
不是用这个创建的吗

51:52.860 --> 51:53.860
Crisis Stone对吧

51:53.860 --> 51:54.860
那么

51:54.860 --> 51:55.860
但是它由于

51:55.860 --> 51:57.860
Apply middleware这个函数

51:57.860 --> 51:58.860
它是不管心理

51:58.860 --> 51:59.860
是怎么创建仓库的

51:59.860 --> 52:01.860
它跟创建仓库的东西

52:01.860 --> 52:02.860
是独立的

52:02.860 --> 52:03.860
所以说

52:03.860 --> 52:05.860
它不能去依赖这个Crisis Stone

52:05.860 --> 52:07.860
因此它到底要怎么来创建仓库

52:07.860 --> 52:08.860
你告诉它

52:08.860 --> 52:09.860
通过你来告诉它

52:09.860 --> 52:10.860
怎么来创建仓库

52:10.860 --> 52:11.860
因此这个玩意

52:11.860 --> 52:12.860
它返回的是一个函数

52:12.860 --> 52:14.860
这个函数就有一个参数

52:14.860 --> 52:15.860
你告诉它

52:15.860 --> 52:17.860
创建仓库怎么去创建

52:17.860 --> 52:18.860
那么怎么告诉它

52:18.860 --> 52:19.860
我们调问这个函数

52:19.860 --> 52:20.860
调问这个函数

52:20.860 --> 52:21.860
这样子看

52:21.860 --> 52:22.860
这是一个

52:22.860 --> 52:23.860
这个东西

52:23.860 --> 52:24.860
整个这个一块

52:24.860 --> 52:25.860
调问之后

52:25.860 --> 52:27.860
它得到的是一个新的函数

52:27.860 --> 52:28.860
这个新的函数

52:28.860 --> 52:29.860
它需要你告诉它

52:29.860 --> 52:30.860
怎么来创建仓库

52:30.860 --> 52:31.860
我们怎么传

52:31.860 --> 52:33.860
就把Crisis Stone传进去

52:33.860 --> 52:34.860
告诉它

52:34.860 --> 52:36.860
通过这种方式来创建仓库

52:36.860 --> 52:38.860
来创建仓库

52:38.860 --> 52:39.860
于是

52:39.860 --> 52:40.860
它会返回

52:40.860 --> 52:41.860
又会返回

52:41.860 --> 52:42.860
又会返回一个函数

52:45.860 --> 52:46.860
创造方法

52:46.860 --> 52:47.860
U

52:47.860 --> 52:48.860
然后

52:48.860 --> 52:49.860
U

52:49.860 --> 52:50.860
返回一个函数

52:50.860 --> 52:52.860
它是一层一层来过来的

52:52.860 --> 52:53.860
就第一个函数

52:53.860 --> 52:54.860
它用来记录的有哪些中间键

52:54.860 --> 52:56.860
它把中间键记录下来

52:56.860 --> 52:57.860
然后它又给你返回一个函数

52:57.860 --> 52:58.860
这个函数

52:58.860 --> 52:59.860
它不知道怎么来创建仓库

52:59.860 --> 53:01.860
它其实可以帮助你

53:01.860 --> 53:02.860
创建仓库的

53:02.860 --> 53:03.860
它不知道怎么来创建仓库

53:03.860 --> 53:05.860
于是你要把它给它一个函数

53:05.860 --> 53:06.860
让它知道怎么来创建仓库

53:06.860 --> 53:08.860
然后它又给你返回一个函数

53:08.860 --> 53:09.860
为什么还要给你返回一个函数呢

53:09.860 --> 53:10.860
因为它不知道

53:10.860 --> 53:11.860
创建仓库的时候

53:11.860 --> 53:14.860
需要哪些参数

53:14.860 --> 53:17.860
那么你是不是要给它个函数

53:17.860 --> 53:18.860
把创建仓库的参数告诉它

53:18.860 --> 53:20.860
比方第三个参数

53:20.860 --> 53:22.860
第三个函数就是Reducer

53:22.860 --> 53:23.860
Reducer

53:23.860 --> 53:25.860
就是你要把Reducer告诉它

53:25.860 --> 53:27.860
还有什么默认值

53:27.860 --> 53:28.860
一有的话就告诉它

53:28.860 --> 53:29.860
没有的话就算了

53:29.860 --> 53:31.860
那么通过这种方式

53:31.860 --> 53:33.860
也能创建一个仓库

53:33.860 --> 53:36.860
只不过这种方式很难理解

53:36.860 --> 53:37.860
很不好理解

53:37.860 --> 53:39.860
你们以后建的比较少一点

53:39.860 --> 53:40.860
但是你要知道

53:40.860 --> 53:43.860
通过这种方式是可以创建仓库的

53:43.860 --> 53:45.860
是可以创建仓库的

53:45.860 --> 53:47.860
实际上你用第一种方式

53:47.860 --> 53:48.860
创建仓库

53:48.860 --> 53:50.860
最终它是调整的这个方法

53:50.860 --> 53:51.860
来创建仓库的

53:51.860 --> 53:52.860
当你使用中间键的时候

53:52.860 --> 53:53.860
它是调整的这个方法

53:53.860 --> 53:55.860
来创建仓库的

53:55.860 --> 53:56.860
但是你这个东西

53:56.860 --> 53:57.860
你可以不懂

53:57.860 --> 53:58.860
方式二种这东西

53:58.860 --> 53:59.860
你可以不懂

53:59.860 --> 54:00.860
没关系

54:00.860 --> 54:01.860
但是如果说你要

54:01.860 --> 54:02.860
像天下节课的扩展课程

54:02.860 --> 54:03.860
你要知道

54:03.860 --> 54:04.860
ApplyMadeWire这个函数怎么写的

54:04.860 --> 54:06.860
那就必须要懂

54:06.860 --> 54:08.860
它这里返回了两层函数

54:08.860 --> 54:10.860
它本身是个函数

54:10.860 --> 54:11.860
然后它调整它过来

54:11.860 --> 54:13.860
它返回了一个函数

54:13.860 --> 54:15.860
它本身是用来记录中间键的

54:15.860 --> 54:16.860
然后返回了这个函数

54:16.860 --> 54:17.860
它是用来记录

54:17.860 --> 54:19.860
创建仓库方法的

54:19.860 --> 54:20.860
再返回那个函数

54:20.860 --> 54:22.860
它才是真正用来创建仓库的

54:22.860 --> 54:25.860
它是这样的一种模式来做的

54:25.860 --> 54:26.860
抽湿薄解

54:26.860 --> 54:29.860
一层一层过来的

54:29.860 --> 54:31.860
它为什么要把它分成这么多函数

54:31.860 --> 54:32.860
你想啊

54:32.860 --> 54:33.860
你第一层函数

54:33.860 --> 54:34.860
它是不是不知道

54:34.860 --> 54:36.860
它要写几个中间键

54:36.860 --> 54:38.860
它并不知道要写几个中间键

54:38.860 --> 54:39.860
那如果全部写到这儿

54:39.860 --> 54:40.860
比方说你把这个东西

54:40.860 --> 54:41.860
全部写到这儿

54:41.860 --> 54:42.860
你看

54:42.860 --> 54:43.860
克里斯洞是函数

54:43.860 --> 54:44.860
对不对

54:44.860 --> 54:46.860
这个尾流射是函数

54:46.860 --> 54:47.860
它鬼知道

54:47.860 --> 54:48.860
尾流射哪个是中间键

54:48.860 --> 54:49.860
它认为这四个都是中间键

54:49.860 --> 54:50.860
对吧

54:50.860 --> 54:51.860
你怕不知道

54:51.860 --> 54:52.860
所以它要需要第一层函数

54:52.860 --> 54:54.860
来固定

54:54.860 --> 54:55.860
我有哪些中间键

54:55.860 --> 54:57.860
然后第二层函数

54:57.860 --> 54:58.860
它来固定

54:58.860 --> 54:59.860
我得知道

54:59.860 --> 55:00.860
有哪些

55:00.860 --> 55:02.860
就是我创建的仓库的方法是什么

55:02.860 --> 55:04.860
创建的仓库的方法是什么

55:04.860 --> 55:06.860
这是第二个函数

55:06.860 --> 55:07.860
那么第三个函数

55:07.860 --> 55:08.860
我得知道

55:08.860 --> 55:09.860
就是创建的仓库的时候

55:09.860 --> 55:10.860
不是要传函数吗

55:10.860 --> 55:11.860
那么创建的仓库的时候

55:11.860 --> 55:12.860
具体的函数是什么

55:12.860 --> 55:14.860
于是给你套了三层

55:14.860 --> 55:15.860
这也是函数

55:15.860 --> 55:16.860
这变成了一种

55:16.860 --> 55:18.860
非常非常常见的做法

55:18.860 --> 55:19.860
就是不断的去返回函数

55:19.860 --> 55:21.860
就是高间函数的做法

55:21.860 --> 55:22.860
其实像

55:22.860 --> 55:23.860
什么可理化

55:23.860 --> 55:25.860
也有感觉有点像

55:25.860 --> 55:26.860
对吧

55:26.860 --> 55:27.860
固定一些参数

55:27.860 --> 55:28.860
再固定一些参数

55:28.860 --> 55:29.860
再固定一些参数

55:29.860 --> 55:30.860
每次参数的函数

55:30.860 --> 55:32.860
含义是不太一样的

55:32.860 --> 55:33.860
这是

55:33.860 --> 55:34.860
应用中间键的两种

55:34.860 --> 55:35.860
这种方式

55:35.860 --> 55:36.860
应用中间键

55:36.860 --> 55:37.860
我们这几课

55:37.860 --> 55:38.860
不做强制要求

55:38.860 --> 55:40.860
只需要你会一种就行了

55:40.860 --> 55:41.860
方式一和方式二

55:41.860 --> 55:42.860
你只需要会一种

55:42.860 --> 55:43.860
我推荐大家会方式一

55:43.860 --> 55:45.860
因为方式一用的是最多的

55:45.860 --> 55:47.860
但是你自己写中键键

55:47.860 --> 55:48.860
你一定得会写

55:48.860 --> 55:49.860
你至少

55:49.860 --> 55:51.860
哪怕不知道这个什么意思

55:51.860 --> 55:53.860
至少得写出这样的格式的代

55:53.860 --> 55:55.860
这就是中间键代

55:55.860 --> 55:56.860
你得知道

55:56.860 --> 55:57.860
那个时候是什么意思

55:57.860 --> 55:59.860
就是之前的Dispatch

55:59.860 --> 56:01.860
下一个Dispatch函数

56:01.860 --> 56:02.860
它形成一个链条

56:02.860 --> 56:04.860
下一个Dispatch函数

56:04.860 --> 56:05.860
这个Stone里边的Dispatch

56:05.860 --> 56:06.860
跟它有什么区别

56:06.860 --> 56:07.860
比方说面试的时候问你

56:07.860 --> 56:08.860
Stone的Dispatch

56:08.860 --> 56:09.860
和那个时候有什么区别

56:09.860 --> 56:10.860
你看

56:10.860 --> 56:11.860
你心里面有张图

56:11.860 --> 56:12.860
你就知道了

56:12.860 --> 56:13.860
Stone的Dispatch

56:13.860 --> 56:15.860
在中间键里边使用的时候

56:15.860 --> 56:17.860
它永远用的是什么

56:17.860 --> 56:18.860
一致

56:18.860 --> 56:19.860
肯定用的是

56:19.860 --> 56:20.860
Stone原本的Dispatch

56:20.860 --> 56:22.860
就是最原始的Dispatch

56:22.860 --> 56:23.860
而你用的是

56:23.860 --> 56:24.860
那个时候的Dispatch

56:24.860 --> 56:25.860
指的是

56:25.860 --> 56:27.860
它下一个中间键的Dispatch

56:27.860 --> 56:29.860
明白这个意思吧

56:33.490 --> 56:34.490
它还不是

56:34.490 --> 56:36.490
说的有点问题

56:38.490 --> 56:40.490
你在这个时候用的

56:40.490 --> 56:42.490
如果用的是Stone的Dispatch

56:42.490 --> 56:44.490
用的始终是最终的Dispatch

56:44.490 --> 56:45.490
因为最终

56:45.490 --> 56:46.490
它会把Dispatch

56:46.490 --> 56:47.490
替换掉Stone里边

56:47.490 --> 56:48.490
当你去运行

56:48.490 --> 56:49.490
某个中间键的Dispatch的时候

56:49.490 --> 56:50.490
它里边

56:50.490 --> 56:51.490
如果你去

56:51.490 --> 56:52.490
再去使用Stone的Dispatch

56:52.490 --> 56:54.490
它用的是最终的Dispatch

56:54.490 --> 56:55.490
而不是下一个

56:55.490 --> 56:56.490
而不是下一个

56:56.490 --> 56:57.490
不是最原始的

56:57.490 --> 56:58.490
一开始是最原始的

56:58.490 --> 56:59.490
但是后边会替换掉

56:59.490 --> 57:01.490
后边最终会完成替换

57:01.490 --> 57:02.490
一替换掉之后

57:02.490 --> 57:03.490
你在以后

57:03.490 --> 57:04.490
因为替换掉之后

57:04.490 --> 57:05.490
才会去分发

57:05.490 --> 57:06.490
状态

57:06.490 --> 57:07.490
对吧

57:07.490 --> 57:08.490
分发X型

57:08.490 --> 57:09.490
因为分发X型的是在后边的

57:09.490 --> 57:10.490
分发X型是在后边

57:10.490 --> 57:11.490
分发X型的时候

57:11.490 --> 57:13.490
它已经完成替换了

57:13.490 --> 57:14.490
那么到时候

57:14.490 --> 57:15.490
你在中间键里边

57:15.490 --> 57:17.490
如果去使用Stone的Dispatch

57:17.490 --> 57:18.490
它使用的

57:18.490 --> 57:19.490
使用的是最终的

57:19.490 --> 57:20.490
中间键E里边

57:20.490 --> 57:22.490
去使用Stone的Dispatch

57:22.490 --> 57:24.490
那是不是又

57:24.490 --> 57:25.490
因为这里

57:25.490 --> 57:26.490
Stone的Dispatch

57:26.490 --> 57:27.490
也需要无线地规

57:27.490 --> 57:28.490
因为中间键E的Dispatch

57:28.490 --> 57:29.490
也就是Stone的Dispatch

57:29.490 --> 57:30.490
对吧

57:30.490 --> 57:31.490
那你

57:31.490 --> 57:32.490
中间键E里边

57:32.490 --> 57:33.490
去调用Stone的Dispatch

57:33.490 --> 57:34.490
是不是要无线地规

57:34.490 --> 57:35.490
看一下吧

57:35.490 --> 57:36.490
如果在中间键E里边

57:36.490 --> 57:38.490
去调用Stone的Dispatch

57:38.490 --> 57:41.490
它又会出现无线地规

57:41.490 --> 57:42.490
看一下

57:42.490 --> 57:43.490
你看

57:43.490 --> 57:44.490
说无线循环

57:44.490 --> 57:45.490
对吧

57:45.490 --> 57:46.490
无线循环

57:46.490 --> 57:48.490
你看不停的都要输出

57:49.490 --> 57:50.490
卡死了

57:51.490 --> 57:52.490
所以说

57:52.490 --> 57:53.490
要慎用

57:54.490 --> 57:56.490
你得知道自己在干嘛

57:56.490 --> 57:58.490
刚才我解释一个问题

57:58.490 --> 57:59.490
你得知道自己在干嘛

57:59.490 --> 58:00.490
因为它最终

58:00.490 --> 58:01.490
已经完成覆盖了

58:01.490 --> 58:02.490
你在中间键E里边

58:02.490 --> 58:03.490
调用Dispatch

58:03.490 --> 58:04.490
就是调用它

58:04.490 --> 58:05.490
如果说你在中间键E

58:05.490 --> 58:06.490
去调用这个Dispatch的话

58:06.490 --> 58:07.490
那么就是

58:07.490 --> 58:08.490
调用了什么呢

58:08.490 --> 58:09.490
调用的是

58:09.490 --> 58:10.490
因为已经完成覆盖了

58:10.490 --> 58:11.490
对不对

58:11.490 --> 58:12.490
完成覆盖了

58:12.490 --> 58:13.490
最终

58:13.490 --> 58:14.490
完成

58:14.490 --> 58:15.490
就是这样子

58:15.490 --> 58:16.490
链条形成之后

58:16.490 --> 58:17.490
最终的Dispatch

58:17.490 --> 58:18.490
这个Dispatch

58:19.490 --> 58:20.490
这个Dispatch就是这个

58:21.490 --> 58:22.490
这个Dispatch

58:22.490 --> 58:24.490
就是这个

58:29.210 --> 58:30.210
最终就是这个

58:30.210 --> 58:31.210
对吧

58:32.210 --> 58:33.210
Store里边的Dispatch就是这个

58:33.210 --> 58:34.210
所以说你在中间键2里边

58:34.210 --> 58:35.210
去调用

58:35.210 --> 58:36.210
调用了那个时辰

58:36.210 --> 58:37.210
调用了不是它

58:37.210 --> 58:38.210
调用了是它

58:39.210 --> 58:40.210
最终的Dispatch

58:40.210 --> 58:41.210
所以大家慎用

58:41.210 --> 58:42.210
就尽量

58:42.210 --> 58:43.210
通常以后

58:43.210 --> 58:44.210
我们都是使用下一个

58:45.210 --> 58:46.210
好了 没了

58:46.210 --> 58:47.210
没了

58:47.210 --> 58:48.210
这就是中间键的写法

58:48.210 --> 58:49.210
大家输了一下吧

58:49.210 --> 58:50.210
这一块确实确实

58:50.210 --> 58:51.210
非常非常有难度

58:51.210 --> 58:52.210
特别特别绕

58:52.210 --> 58:53.210
你说代码有多少

58:53.210 --> 58:54.210
代码没多少

58:54.210 --> 58:55.210
就特别特别绕

58:55.210 --> 58:56.210
不太容易理解

58:56.210 --> 58:57.210
因此下期课

58:57.210 --> 58:58.210
我们是个扩展课程

58:58.210 --> 58:59.210
下期课呢

58:59.210 --> 59:00.210
我们讲的中间键

59:00.210 --> 59:01.210
Apply Middleware

59:01.210 --> 59:02.210
实现代码

59:02.210 --> 59:03.210
那个东西更糟

59:03.210 --> 59:04.210
虽然代码没有机航

59:04.210 --> 59:05.210
东西糟得不得了

59:06.210 --> 59:07.210
大家理解一下吧

59:07.210 --> 59:09.210
如果说实在理解不了的话

59:09.210 --> 59:10.210
也没关系

59:10.210 --> 59:11.210
我们下一张

59:11.210 --> 59:12.210
会专门来讲中间键

59:12.210 --> 59:13.210
就是各种

59:13.210 --> 59:14.210
第三方的中间键

59:14.210 --> 59:15.210
怎么去使用

59:15.210 --> 59:16.210
那么

59:16.210 --> 59:17.210
下一张的时候

59:17.210 --> 59:18.210
你只需要知道

59:18.210 --> 59:19.210
它怎么去使用就行了

59:19.210 --> 59:21.210
当你能够理解这一节课

59:21.210 --> 59:22.210
讲了中间键的

59:22.210 --> 59:23.210
它的就是原理

59:23.210 --> 59:24.210
以及它的实现

59:24.210 --> 59:26.210
自己书写的方式最好

59:26.210 --> 59:27.210
这是关于中间键的一块

