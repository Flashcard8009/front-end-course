WEBVTT

00:00.430 --> 00:06.430
这节课的内容实际上多多少少有一些操纲

00:06.430 --> 00:10.430
因此我把它作为一个扩展课程

00:10.430 --> 00:17.430
实际上这一块内容在我们学习玩了整个Rex全家统之后

00:17.430 --> 00:22.430
它就不算操纲了 它是一个非常正常的一块内容

00:22.430 --> 00:26.430
所以说这一块内容我想来想去我怎么弄都不太合适

00:26.430 --> 00:32.430
因为你要理解这一块内容的话 你得理解这个东西

00:32.430 --> 00:36.430
Redux 但是Redux我们现在还没有学

00:36.430 --> 00:42.430
如果说按照学习顺序的话 我们应该在Redux讲完了之后

00:42.430 --> 00:51.430
再来讲Reducer Hook 但是这样子就相当于把Hook的章节强行的拆分开了

00:51.430 --> 00:52.430
你懂我意思吗

00:52.430 --> 00:55.430
所以说想来想去我这样子吧

00:55.430 --> 00:58.430
我把这一节课作为一个扩展课程

00:58.430 --> 01:04.430
但是建议你如果你学习完了Redux之后

01:04.430 --> 01:07.430
再回过头来把Redux看一下

01:07.430 --> 01:11.430
所以说安排是真的不好安排

01:11.430 --> 01:13.430
所以说我就这么着吧

01:13.430 --> 01:16.430
那么这一块为什么说它有点操纲呢

01:16.430 --> 01:20.430
实际上这一块本身它的代码并不复杂

01:20.430 --> 01:25.430
只是说这一块有一些概念你得需要理解

01:25.430 --> 01:28.430
不过你如果学习过了Viu的话

01:28.430 --> 01:31.430
这一块概念也不是那么的不好理解

01:31.430 --> 01:36.430
这一块要涉及到一些概念 就是关于Redux里面的一些概念

01:36.430 --> 01:38.430
虽然我们后边学到Redux的时候

01:38.430 --> 01:44.430
它的很多概念是来自于这个框架 Flux

01:45.430 --> 01:54.430
这是Facebook出品的一个数据流框架

01:54.430 --> 01:57.430
这个框架很早很早就出现了

01:57.430 --> 01:59.430
甚至比React还要早

01:59.430 --> 02:02.430
甚至更加不用说什么Redux的

02:02.430 --> 02:04.430
在很早很早就出来了

02:04.430 --> 02:08.430
那么这个框架里面它有这么一些核心点

02:08.430 --> 02:10.430
我大概说一下吧

02:10.430 --> 02:17.430
就是它里面规定了数据是单向流动的

02:17.430 --> 02:19.430
它规定的数据是单向流动的

02:19.430 --> 02:21.430
那么它也出现了什么组件的一些概念

02:21.430 --> 02:24.430
不过后边出现了React之后

02:24.430 --> 02:28.430
React就替代了组件那一块的东西

02:28.430 --> 02:31.430
它主要是规定的数据是单向流动的

02:31.430 --> 02:33.430
字顶而下的流动

02:33.430 --> 02:36.430
然后其他的它是这样的规定的

02:36.430 --> 02:43.430
数据存储在数据仓库中

02:43.430 --> 02:45.430
数据存储在数据仓库中

02:45.430 --> 02:48.430
那么现在我们数据是存在哪的

02:48.430 --> 02:51.430
目前在React里面是存在State里面

02:51.430 --> 02:52.430
存在状态里面的吧

02:52.430 --> 02:56.430
那么你可以认为状态就是一个数据仓库

02:56.430 --> 03:05.430
就是目前你可以认为State就是一个存储数据的仓库

03:05.430 --> 03:07.430
可以这样去想象

03:07.430 --> 03:11.430
然后状态它是不是会发生改变

03:11.430 --> 03:14.430
状态是会发生改变的

03:14.430 --> 03:17.430
那么如果状态改变的话

03:17.430 --> 03:19.430
有的时候我们为了做一些日子记录

03:19.430 --> 03:23.430
或者是有的时候我们可能会倒回到之前的状态

03:23.430 --> 03:25.430
所以说我们需要知道

03:25.430 --> 03:28.430
之前的状态是怎么改变的

03:28.430 --> 03:30.430
状态发生改变可以没问题

03:30.430 --> 03:32.430
但是这个框架认为

03:32.430 --> 03:35.430
我得知道这个状态为什么会发生改变

03:35.430 --> 03:37.430
于是它规定了

03:37.430 --> 03:39.430
这个框架里面它规定了这么一个东西

03:39.430 --> 03:43.430
它说X型有一个东西叫做X型

03:43.430 --> 03:44.430
X型动作对吧

03:44.430 --> 03:46.430
产生一个东西动作

03:46.430 --> 03:53.430
X型是改变数据的唯一原因

03:53.430 --> 03:56.430
就是说如果说我的状态发生变化了

03:56.430 --> 03:59.430
那一定是有一个X型触发了

03:59.430 --> 04:01.430
比方说用户做了某个操作

04:01.430 --> 04:02.430
时间到了某个点

04:02.430 --> 04:03.430
对吧

04:03.430 --> 04:05.430
它一定是触发了某个东西

04:05.430 --> 04:09.430
X型它是改变数据的唯一原因

04:09.430 --> 04:12.430
那么在这个框架里边

04:12.430 --> 04:13.430
不说以后

04:13.430 --> 04:14.430
在这个框架里边

04:14.430 --> 04:17.430
它认为数据要发生变动

04:17.430 --> 04:19.430
它必须要有一个X型

04:19.430 --> 04:22.430
那么这个X型到底是什么东西

04:22.430 --> 04:28.430
本质上就是一个对象

04:28.430 --> 04:30.430
该框架它规定了

04:30.430 --> 04:33.430
X型它有两个属性

04:33.430 --> 04:35.430
有两个属性

04:35.430 --> 04:37.430
哪两个属性呢

04:37.430 --> 04:38.430
第一个就是Type属性

04:38.430 --> 04:40.430
是一个制幅串

04:40.430 --> 04:44.430
它表示的是动作的类型

04:44.430 --> 04:46.430
你不是要发生把数据改变吗

04:46.430 --> 04:48.430
那么一个动作到底是什么动作

04:48.430 --> 04:50.430
比方说你增加一个学生

04:50.430 --> 04:52.430
或者是删除一个学生

04:52.430 --> 04:54.430
或者是读取一个学生

04:54.430 --> 04:56.430
你总归有一个动作

04:56.430 --> 04:57.430
那么这个动作

04:57.430 --> 04:59.430
它是什么类型的动作

04:59.430 --> 05:02.430
我们用一个制幅串来表示

05:02.430 --> 05:05.430
另外一个就是Payload

05:05.430 --> 05:07.430
Payload是一个对象

05:07.430 --> 05:08.430
不一定是对象

05:08.430 --> 05:11.430
它可以是任意类型

05:11.430 --> 05:16.430
就是动作发生后的附加信息

05:16.430 --> 05:18.430
比方说你要添加一个学生

05:18.430 --> 05:20.430
比方说比如

05:20.430 --> 05:22.430
例如

05:22.430 --> 05:24.430
添加一个

05:24.430 --> 05:25.430
这样子吧

05:25.430 --> 05:26.430
我写到这

05:26.430 --> 05:28.430
例如

05:28.430 --> 05:29.430
如果你要添加一个学生的话

05:29.430 --> 05:31.430
这个X型大概

05:31.430 --> 05:33.430
是这样的描述的

05:33.430 --> 05:36.430
如果是添加一个学生

05:36.430 --> 05:39.430
那么这个X型大概描述

05:39.430 --> 05:42.430
X型可以描述

05:42.430 --> 05:44.430
描述为

05:44.430 --> 05:45.430
什么东西呢

05:45.430 --> 05:47.430
就是一个解释对象

05:47.430 --> 05:48.430
这个对象

05:48.430 --> 05:50.430
因为X型本质就是一个对象

05:50.430 --> 05:52.430
Type你可以规定一个制幅串

05:52.430 --> 05:53.430
什么制幅串呢

05:53.430 --> 05:56.430
就是ADD student

05:57.430 --> 05:58.430
你可以这样的规定

05:58.430 --> 06:00.430
全是自行规定的

06:00.430 --> 06:01.430
全是自行规定的

06:01.430 --> 06:03.430
ADD student

06:03.430 --> 06:05.430
然后后面加一个Payload

06:05.430 --> 06:06.430
表示附和

06:06.430 --> 06:07.430
附载

06:07.430 --> 06:09.430
当然它不是说强性规定

06:09.430 --> 06:11.430
不是说你必须要这样子写

06:11.430 --> 06:12.430
只是它的规范里边

06:12.430 --> 06:14.430
它建议你这样子写

06:14.430 --> 06:15.430
Payload就表示

06:15.430 --> 06:16.430
它的附加信息

06:16.430 --> 06:18.430
是不是一个学生对象本身

06:18.430 --> 06:19.430
对吧

06:19.430 --> 06:23.430
都是学生对象的

06:23.430 --> 06:24.430
各种信息

06:24.430 --> 06:25.430
比如说学生姓名

06:25.430 --> 06:26.430
Name

06:26.430 --> 06:27.430
学生的弟子

06:27.430 --> 06:28.430
而最是

06:28.430 --> 06:29.430
学生的年龄

06:29.430 --> 06:30.430
A級

06:30.430 --> 06:31.430
学生的性别6

06:31.430 --> 06:32.430
对吧

06:32.430 --> 06:33.430
都放到这个微象里边

06:33.430 --> 06:35.430
我们就可以用一个对象来描述

06:35.430 --> 06:37.430
我们到底要干吗

06:37.430 --> 06:39.430
这个X型它是描述

06:39.430 --> 06:40.430
到底你要干吗

06:40.430 --> 06:42.430
你不是想改变数据吗

06:42.430 --> 06:44.430
你描述一下你到底要干吗

06:44.430 --> 06:45.430
把我的附加信息

06:45.430 --> 06:47.430
和我要到底要干吗

06:47.430 --> 06:48.430
传给你

06:48.430 --> 06:50.430
到时候你再发生变化

06:50.430 --> 06:51.430
这是X型

06:51.430 --> 06:53.430
我们一块块认识

06:53.430 --> 06:55.430
然后

06:55.430 --> 06:57.430
不要再举个例子吧

06:57.430 --> 07:01.430
如果要删除一个学生

07:01.430 --> 07:03.430
X型可以描述

07:03.430 --> 07:04.430
也不是一定的

07:04.430 --> 07:06.430
它只是建议你这样描述

07:06.430 --> 07:08.430
用这种格式来进行描述

07:08.430 --> 07:10.430
那么X型可以描述为

07:10.430 --> 07:11.430
Type

07:11.430 --> 07:12.430
V

07:12.430 --> 07:13.430
Denate

07:13.430 --> 07:15.430
Student

07:15.430 --> 07:17.430
然后Payload

07:17.430 --> 07:18.430
是什么呢

07:18.430 --> 07:21.430
是

07:21.430 --> 07:22.430
学生的ID

07:22.430 --> 07:23.430
就是学生的ID

07:23.430 --> 07:24.430
学生

07:24.430 --> 07:25.430
直接一个数字

07:25.430 --> 07:27.430
学生ID

07:27.430 --> 07:29.430
学生ID

07:29.430 --> 07:30.430
明白这个意思吧

07:30.430 --> 07:32.430
尽管你目前对X型还比较模

07:32.430 --> 07:34.430
对整个结构还比较模糊

07:34.430 --> 07:36.430
但是你至少得把X型认识清楚

07:36.430 --> 07:37.430
它就是一个对象

07:37.430 --> 07:39.430
这个对象描述了你要干吗

07:39.430 --> 07:41.430
因为Type是描述你要干吗

07:41.430 --> 07:42.430
用Payload的描述

07:42.430 --> 07:43.430
你要干这件事情

07:43.430 --> 07:45.430
有一些额外的信息我要给你

07:45.430 --> 07:46.430
所以说

07:46.430 --> 07:48.430
它就描述你要干吗的

07:48.430 --> 07:49.430
以及它的附加信息

07:49.430 --> 07:51.430
这就是X型

07:51.430 --> 07:53.430
任何数据的变化

07:53.430 --> 07:55.430
Flux认为任何数据的变化

07:55.430 --> 07:57.430
都必须要有X型来触发

07:57.430 --> 07:59.430
没有X型数据是不变的

07:59.430 --> 08:01.430
比如用户做了一个操作

08:01.430 --> 08:02.430
添加一个学生

08:02.430 --> 08:03.430
添加了一些数据

08:03.430 --> 08:05.430
点击添加添加一个学生

08:05.430 --> 08:06.430
那你干吗呢

08:06.430 --> 08:09.430
你该用代码来产生一个X型对象

08:09.430 --> 08:11.430
Type就为IDD Student

08:11.430 --> 08:13.430
然后Payload就把这些信息

08:13.430 --> 08:15.430
放进来

08:15.430 --> 08:16.430
你首先得有X型

08:16.430 --> 08:18.430
你才能变化数据

08:18.430 --> 08:20.430
这个空间是这样子认为的

08:20.430 --> 08:22.430
但是X型本身

08:22.430 --> 08:24.430
它只是描述了

08:24.430 --> 08:25.430
我要干吗呢

08:25.430 --> 08:26.430
我要干

08:26.430 --> 08:28.430
怎么样去改变数据

08:28.430 --> 08:30.430
它只是做描述

08:30.430 --> 08:31.430
具体的

08:31.430 --> 08:33.430
是不是要有个东西去改变数据

08:33.430 --> 08:36.430
具体改变数据的

08:36.430 --> 08:39.430
具体改变数据的

08:39.430 --> 08:41.430
是一个函数

08:41.430 --> 08:42.430
这个函数

08:42.430 --> 08:44.430
才来真正改变这个数据

08:44.430 --> 08:49.430
该函数叫做Reducer

08:49.430 --> 08:51.430
至于它为什么叫做Reducer

08:51.430 --> 08:53.430
咱们以后再讲Redux的时候

08:53.430 --> 08:57.430
因为Redux是跟Flex一脉相承的

08:57.430 --> 08:58.430
所以说我们之后

08:58.430 --> 08:59.430
再讲Redux的时候

08:59.430 --> 09:01.430
再详细的去聊这些事吧

09:01.430 --> 09:03.430
现在我们不测缘了

09:03.430 --> 09:05.430
总之这个函数就叫Reducer怎么样

09:05.430 --> 09:06.430
你把它宰了

09:06.430 --> 09:07.430
它就叫这个名字

09:07.430 --> 09:09.430
它叫做Reducer

09:09.430 --> 09:10.430
好

09:10.430 --> 09:11.430
那么这个函数

09:11.430 --> 09:13.430
它就有这么一个特点

09:13.430 --> 09:17.430
该函数接收两个参数

09:17.430 --> 09:19.430
第一个参数呢

09:19.430 --> 09:22.430
第一个参数是Action

09:22.430 --> 09:25.430
第一个参数是State

09:25.430 --> 09:26.430
状态

09:26.430 --> 09:30.430
表示当前数据仓库中

09:30.430 --> 09:32.430
仓库中的数据

09:32.430 --> 09:33.430
我把当前的数据仓库

09:33.430 --> 09:35.430
给的数据给你

09:35.430 --> 09:37.430
然后第二个是什么呢

09:37.430 --> 09:40.430
第二个是Action

09:40.430 --> 09:42.430
我把现在的数据给你

09:42.430 --> 09:44.430
我把我要做的动作给你

09:44.430 --> 09:47.430
就是表示

09:47.430 --> 09:49.430
Action就是描述了

09:49.430 --> 09:52.430
如何去改变数据

09:52.430 --> 09:56.430
以及改变数据的一些附加信息

09:56.430 --> 09:58.430
比方说我要删除一个学生

09:58.430 --> 09:59.430
那我就这里就描述了

09:59.430 --> 10:00.430
你要干嘛

10:00.430 --> 10:01.430
你要删除学生

10:01.430 --> 10:03.430
然后我需要一些附加信息

10:03.430 --> 10:04.430
那么我会给你

10:04.430 --> 10:06.430
到时候我把学生IT给你

10:06.430 --> 10:07.430
你要这意思吧

10:07.430 --> 10:11.430
我们把当前的数据仓库的数据给你

10:11.430 --> 10:13.430
然后又给你Action

10:13.430 --> 10:16.430
那么你来真实的完成数据变化

10:16.430 --> 10:18.430
怎么来完成数据变化呢

10:18.430 --> 10:22.430
该函数必须有一个返回结果

10:22.430 --> 10:33.430
用于表示数据仓库变化之后的数据

10:33.430 --> 10:36.430
就是你我才真正的完成数据的变化

10:36.430 --> 10:37.430
那么我变化之后

10:37.430 --> 10:39.430
会给你一个新的数据

10:40.430 --> 10:42.430
Flex要求

10:44.430 --> 10:46.430
对象是不可变的

10:48.430 --> 10:49.430
不可变的

10:49.430 --> 10:50.430
就是每一次才能对象

10:50.430 --> 10:52.430
你不能去直接改变他的数据值

10:52.430 --> 10:53.430
是不可变的

10:53.430 --> 10:55.430
如果返回对象

10:55.430 --> 10:58.430
必须创建新的对象

10:59.430 --> 11:00.430
来返回

11:00.430 --> 11:02.430
这就是Flex的要求

11:02.430 --> 11:04.430
我们先把这些概念认识一下

11:05.430 --> 11:08.430
如果说我要画一个图的话

11:09.430 --> 11:11.430
他应该是这么一个样子

11:11.430 --> 11:12.430
再画个图

11:13.430 --> 11:14.430
他应该是这么一个样子

11:15.430 --> 11:18.430
就是说我们这里有一个数据仓库

11:18.430 --> 11:19.430
这个数据仓库

11:19.430 --> 11:21.430
你可以就认为是一个状态

11:21.430 --> 11:22.430
一个State

11:22.430 --> 11:23.430
一个组件里面的状态

11:24.430 --> 11:25.430
这是数据仓库

11:25.430 --> 11:27.430
你可以就这么认为

11:27.430 --> 11:29.430
它就是一个组件里面的状态

11:29.430 --> 11:33.000
数据仓库

11:33.000 --> 11:37.000
然后我们这里有一个Reducer

11:37.000 --> 11:38.000
是一个函数

11:39.000 --> 11:41.000
改变数据的函数

11:42.000 --> 11:43.000
有这么一个函数

11:45.000 --> 11:47.000
它的名字叫做Reducer

11:49.000 --> 11:51.000
这个函数它需要两个参数

11:51.000 --> 11:53.000
到时候调整的时候需要两个参数

11:53.000 --> 11:54.000
它是这样子

11:54.000 --> 11:56.000
数据仓库一开始没有发生

11:56.000 --> 11:57.000
就是有些数据

11:57.000 --> 11:59.000
初始化了一些数据

11:59.000 --> 12:01.000
然后到时候我要改变

12:01.000 --> 12:03.000
改变这个数据的话

12:03.000 --> 12:05.000
会调用Reducer

12:05.000 --> 12:07.000
会调用Reducer

12:08.000 --> 12:10.000
那么调用的时候怎么来调用呢

12:10.000 --> 12:11.000
下面还有一个规则

12:11.000 --> 12:12.000
还有一个对

12:12.000 --> 12:14.000
这里稍微要绕一点

12:14.000 --> 12:16.000
就是这个数据流

12:16.000 --> 12:17.000
Flex数据流

12:17.000 --> 12:19.000
它是这样子来规范的

12:19.000 --> 12:21.000
它就是触发

12:21.000 --> 12:24.000
如果要触发Reducer

12:26.000 --> 12:28.000
不可以直接调用

12:28.000 --> 12:30.000
也不能直接调用Reducer函数

12:30.000 --> 12:32.000
而是应该

12:33.000 --> 12:36.000
调用一个辅助函数

12:36.000 --> 12:38.000
叫做Dispatch

12:38.000 --> 12:39.000
分发

12:39.000 --> 12:41.000
调用这个函数

12:41.000 --> 12:43.000
然后该函数又来了

12:43.000 --> 12:44.000
这个函数的规范

12:44.000 --> 12:49.000
该函数仅接收一个参数

12:49.000 --> 12:50.000
一个参数

12:50.000 --> 12:51.000
什么参数呢

12:51.000 --> 12:52.000
这个参数什么东西呢

12:52.000 --> 12:54.000
这个参数就是x

12:54.000 --> 12:56.000
只接收一个x

12:57.000 --> 12:59.000
然后该函数

12:59.000 --> 13:05.000
会间接去调用

13:06.000 --> 13:09.000
Reducer

13:09.000 --> 13:15.000
以达到改变数据的目的

13:15.000 --> 13:16.000
好

13:16.000 --> 13:17.000
接下来我们来看一下

13:17.000 --> 13:18.000
什么意思

13:18.000 --> 13:20.000
我们来看一个图

13:20.000 --> 13:22.000
我们现在有数据了

13:22.000 --> 13:24.000
比方说这个数据里边

13:24.000 --> 13:26.000
就存放了一个学生的数据

13:26.000 --> 13:28.000
比方说存放了一个学生的数据

13:28.000 --> 13:29.000
好

13:29.000 --> 13:30.000
尤其是我们写了这么一个函数

13:30.000 --> 13:31.000
这个函数

13:31.000 --> 13:33.000
它可以支持天家学生

13:33.000 --> 13:35.000
也可以支持

13:35.000 --> 13:37.000
也可以支持就是三出学生

13:37.000 --> 13:39.000
总之它这个函数里边

13:39.000 --> 13:41.000
可以改变这个常库里边的数据

13:42.000 --> 13:43.000
好

13:43.000 --> 13:44.000
接下来我们要

13:44.000 --> 13:46.000
比方说我们突然一个用户

13:46.000 --> 13:48.000
填写了一些信息

13:48.000 --> 13:49.000
点击了天家按钮

13:49.000 --> 13:50.000
要天家一个学生怎么办

13:50.000 --> 13:51.000
这个用户

13:51.000 --> 13:53.000
它需要去调用另外一个函数

13:53.000 --> 13:55.000
这个函数叫做Dispatch

13:55.000 --> 13:57.000
分发

13:57.000 --> 13:59.000
Dispatch函数

13:59.000 --> 14:00.000
好

14:00.000 --> 14:01.000
Dispatch的函数里边

14:01.000 --> 14:02.000
它是不是要传一个

14:02.000 --> 14:03.000
比方说三出一个学生

14:03.000 --> 14:04.000
它是不是要传一个x型进来

14:04.000 --> 14:05.000
对吧

14:05.000 --> 14:06.000
传一个x型进来

14:06.000 --> 14:07.000
这个x型

14:09.000 --> 14:11.000
可以这样子写吧

14:13.000 --> 14:14.000
它传一个x型

14:14.000 --> 14:15.000
它的type值

14:15.000 --> 14:17.000
type值等于什么

14:17.000 --> 14:18.000
Dnet

14:18.000 --> 14:19.000
student

14:19.000 --> 14:20.000
好

14:20.000 --> 14:22.000
然后它的payload

14:22.000 --> 14:24.000
payload等于

14:24.000 --> 14:25.000
比方说id为1

14:25.000 --> 14:27.000
它调用这个函数

14:27.000 --> 14:29.000
而这个函数做什么呢

14:29.000 --> 14:30.000
这个函数

14:30.000 --> 14:32.000
它就是会拿到当前的数据

14:32.000 --> 14:33.000
仓库State

14:33.000 --> 14:34.000
对吧

14:34.000 --> 14:35.000
它拿到当前的数据仓库State

14:35.000 --> 14:36.000
然后

14:36.000 --> 14:38.000
它把这个数据仓库

14:38.000 --> 14:39.000
传给这个Reducer

14:39.000 --> 14:42.000
Reducer里边不是要得到当前的数据吗

14:42.000 --> 14:44.000
它把数据仓库的值传给这个Reducer

14:44.000 --> 14:45.000
然后再把这个x型

14:45.000 --> 14:47.000
也传给这个Reducer

14:49.000 --> 14:50.000
再把这个x型

14:50.000 --> 14:51.000
也传给这个Reducer

14:51.000 --> 14:52.000
于是

14:52.000 --> 14:53.000
这个Reducer

14:53.000 --> 14:54.000
不是需要两个参数吗

14:54.000 --> 14:55.000
一个是当前数据仓库的值

14:55.000 --> 14:58.000
一个是x型的值

14:58.000 --> 15:00.000
一个是x型的值

15:00.000 --> 15:01.000
于是这样子一来

15:01.000 --> 15:03.000
它又把数据仓库的数据给了它了

15:03.000 --> 15:04.000
又把这个x型

15:04.000 --> 15:05.000
就是用户传过来的

15:05.000 --> 15:06.000
对吧

15:06.000 --> 15:07.000
也给了它了

15:07.000 --> 15:09.000
那么它来完成数据的变化

15:10.000 --> 15:12.000
大概是这么一个流程

15:13.000 --> 15:14.000
当然我现在也不可能

15:14.000 --> 15:16.000
把它讲得特别特别细

15:16.000 --> 15:18.000
因为这是Reducer方面的知识

15:18.000 --> 15:19.000
不过呢

15:19.000 --> 15:20.000
你学过Wilx

15:20.000 --> 15:22.000
Wil的数据流处理方式

15:22.000 --> 15:23.000
大同小异

15:23.000 --> 15:25.000
Wil的数据流处理方式

15:25.000 --> 15:27.000
也是类似的方式来处理

15:27.000 --> 15:28.000
对吧

15:28.000 --> 15:29.000
也是类似的方式来处理

15:29.000 --> 15:30.000
好

15:30.000 --> 15:31.000
这里呢

15:31.000 --> 15:32.000
是不是

15:32.000 --> 15:33.000
就这么一个方案了

15:34.000 --> 15:35.000
因此呢

15:35.000 --> 15:36.000
我们如果说

15:36.000 --> 15:39.000
要来实现这么一个效果的话

15:39.000 --> 15:41.000
我们现在不去考虑

15:41.000 --> 15:42.000
什么出去大个事

15:42.000 --> 15:43.000
在Wilx

15:43.000 --> 15:45.000
现在有了Reducer Hook之后

15:45.000 --> 15:48.000
我们也可以实现类似的效果

15:48.000 --> 15:49.000
好

15:49.000 --> 15:50.000
比方说

15:50.000 --> 15:51.000
我们先不考虑Reducer Hook

15:51.000 --> 15:52.000
不考虑这个东西

15:52.000 --> 15:54.000
我们自己手动来实现

15:54.000 --> 15:55.000
怎么来实现

15:55.000 --> 15:56.000
看着

15:57.000 --> 15:59.000
比方说吧

16:00.000 --> 16:01.000
咱们呢

16:01.000 --> 16:03.000
这个组建里边

16:03.000 --> 16:05.000
有一个数字

16:06.000 --> 16:08.000
这个数字是这样子

16:08.000 --> 16:10.000
做一个非常非常简单的例子

16:10.000 --> 16:12.000
非常非常简单的例子

16:12.000 --> 16:13.000
就是说

16:13.000 --> 16:15.000
这个有一个数字

16:15.000 --> 16:17.000
那比方说就是状态

16:17.000 --> 16:18.000
状态

16:18.000 --> 16:19.000
我们这里

16:19.000 --> 16:21.000
还是用Ustate

16:23.000 --> 16:24.000
Ustate

16:25.000 --> 16:26.000
这里呢

16:26.000 --> 16:27.000
我们Ustate

16:27.000 --> 16:29.000
Ustate

16:29.000 --> 16:31.000
数字n嘛

16:31.000 --> 16:33.000
more than 只能为你用

16:33.000 --> 16:35.000
more than 只为你用

16:35.000 --> 16:36.000
好 接下来

16:36.000 --> 16:38.000
我们这里有一个span元数

16:38.000 --> 16:40.000
它用来显示这个数字

16:40.000 --> 16:42.000
然后上面有个按钮

16:42.000 --> 16:44.000
这是减少

16:44.000 --> 16:45.000
减少

16:45.000 --> 16:47.440
unclick

16:47.440 --> 16:49.440
unclick

16:49.440 --> 16:50.440
好 这里呢

16:50.440 --> 16:51.440
button

16:51.440 --> 16:53.440
这是增加

16:53.440 --> 16:55.440
增加

16:55.440 --> 16:57.440
unclick

16:58.440 --> 16:59.440
减少干嘛呢

16:59.440 --> 17:01.440
是不是set n

17:01.440 --> 17:02.440
n-1

17:02.440 --> 17:03.440
对吧

17:03.440 --> 17:04.440
增加干嘛呢

17:04.440 --> 17:06.440
set n

17:06.440 --> 17:07.440
n加1

17:07.440 --> 17:09.940
对吧

17:09.940 --> 17:10.940
运行出来

17:10.940 --> 17:12.940
这个很简单一个例子

17:12.940 --> 17:16.450
看一下

17:16.450 --> 17:17.450
那么现在呢比方说

17:17.450 --> 17:19.450
这个地址没什么好说的

17:19.450 --> 17:21.450
它肯定能实现这个功能

17:21.450 --> 17:22.450
那比方说呢

17:22.450 --> 17:24.450
现在呢

17:24.450 --> 17:26.450
我们要把这一部分

17:26.450 --> 17:28.450
数据处理的逻辑呢

17:28.450 --> 17:29.450
要把它分离出去

17:29.450 --> 17:31.450
要分离这个数据处理逻辑

17:31.450 --> 17:34.450
因为有可能会出现这么一种情况

17:34.450 --> 17:35.450
就多个组件呢

17:35.450 --> 17:37.450
会用到同一种数据处理逻辑

17:37.450 --> 17:38.450
对吧

17:38.450 --> 17:39.450
这个逻辑是一样的

17:39.450 --> 17:41.450
会用到同一种数据处理逻辑

17:41.450 --> 17:43.450
另外呢

17:43.450 --> 17:46.450
可能那个数据处理逻辑

17:46.450 --> 17:47.450
以后要发生维护

17:47.450 --> 17:48.450
要发生变动

17:48.450 --> 17:49.450
比方说减少的时候

17:49.450 --> 17:50.450
你不能要保证它

17:50.450 --> 17:51.450
它的指小

17:51.450 --> 17:52.450
不能小于0

17:52.450 --> 17:53.450
对吧

17:53.450 --> 17:54.450
稍微增加一判断

17:54.450 --> 17:55.450
我们希望呢

17:55.450 --> 17:56.450
一个组件呢

17:56.450 --> 17:58.450
尽量的保持干净

17:58.450 --> 17:59.450
就它只处理界面

17:59.450 --> 18:00.450
因为我们说过reaction

18:00.450 --> 18:02.450
它只处理界面的

18:02.450 --> 18:03.450
整个数据处理呢

18:03.450 --> 18:05.450
你能不能把它分离出去

18:05.450 --> 18:06.450
专门来写一个模块

18:06.450 --> 18:07.450
来进行数据处理

18:07.450 --> 18:09.450
可不可以这样做呢

18:09.450 --> 18:10.450
当然可以

18:10.450 --> 18:11.450
这就是这个flux方案

18:11.450 --> 18:12.450
flux呢

18:12.450 --> 18:14.450
其实就是一个数据流的处理方案

18:14.450 --> 18:15.450
它来控制

18:15.450 --> 18:16.450
这个数据

18:16.450 --> 18:18.450
它到底是怎么流动的

18:18.450 --> 18:19.450
那么现在呢

18:19.450 --> 18:21.450
我给大家写一下

18:21.450 --> 18:22.450
写一下

18:22.450 --> 18:24.450
如果说我用这个flux方案的话

18:24.450 --> 18:25.450
如果你前面没听懂

18:25.450 --> 18:26.450
你看着我的代码

18:26.450 --> 18:28.450
来感受一下

18:28.450 --> 18:30.450
如果说我

18:30.450 --> 18:32.450
现在呢写上这么一个

18:32.450 --> 18:34.450
函数

18:34.450 --> 18:37.450
叫做reducer

18:37.450 --> 18:39.450
写上这么一个函数

18:39.450 --> 18:40.450
好

18:40.450 --> 18:41.450
这个函数呢

18:41.450 --> 18:42.450
我们刚才说过

18:42.450 --> 18:44.450
这个函数来干嘛呢

18:44.450 --> 18:45.450
如果刚才没听懂的话

18:45.450 --> 18:46.450
来看一下这个代码

18:46.450 --> 18:47.450
慢慢来理解

18:47.450 --> 18:49.450
那么如果写个函数

18:49.450 --> 18:50.450
这个函数是不是有两个参数

18:50.450 --> 18:53.450
一个是之前的状态

18:53.450 --> 18:54.450
一个是呢

18:54.450 --> 18:55.450
你要干嘛

18:55.450 --> 18:56.450
你要干嘛

18:56.450 --> 19:00.460
要传一个x

19:00.460 --> 19:01.460
该函数

19:01.460 --> 19:05.460
根据当前的数据

19:05.460 --> 19:08.460
以及x

19:08.460 --> 19:11.460
生成一个新的数据

19:11.460 --> 19:12.460
好了

19:12.460 --> 19:13.460
那么这个函数干嘛呢

19:13.460 --> 19:14.460
你看着

19:14.460 --> 19:15.460
你现在不要想太多

19:15.460 --> 19:16.460
不要想以后

19:16.460 --> 19:17.460
这个函数怎么用

19:17.460 --> 19:18.460
它又怎么跟数据结合

19:18.460 --> 19:19.460
又怎么来调用

19:19.460 --> 19:20.460
先不要想这些

19:20.460 --> 19:22.460
你就老老实实把这个函数写好

19:22.460 --> 19:23.460
你这个函数

19:23.460 --> 19:25.460
只考虑数据是怎么变的

19:25.460 --> 19:26.460
x已经给力了

19:26.460 --> 19:27.460
你甭管它是哪来的

19:27.460 --> 19:28.460
它已经给力了

19:28.460 --> 19:30.460
你只需要改动这个数据成了

19:30.460 --> 19:31.460
好

19:31.460 --> 19:32.460
怎么来做呢

19:32.460 --> 19:33.460
这个函数其实跟reactor

19:33.460 --> 19:34.460
都没有任何关系

19:34.460 --> 19:36.460
它只是用来处理数据的

19:36.460 --> 19:37.460
这是一个非常非常

19:37.460 --> 19:39.460
纯净的一个介石函数

19:39.460 --> 19:40.460
而且呢

19:40.460 --> 19:42.460
flux还要求

19:42.460 --> 19:43.460
要求这个reducer

19:43.460 --> 19:45.460
必须是纯函数

19:45.460 --> 19:47.460
说一下

19:47.460 --> 19:51.460
reducer必须是纯函数

19:51.460 --> 19:52.460
必须是纯函数

19:52.460 --> 19:56.460
不能有任何副作用

19:57.460 --> 19:59.460
你就是用来计算的

19:59.460 --> 20:00.460
好

20:00.460 --> 20:01.460
怎么来算呢

20:01.460 --> 20:02.460
那么我是不是要知道

20:02.460 --> 20:03.460
用户到底要

20:03.460 --> 20:04.460
我要改变数据

20:04.460 --> 20:05.460
改变这个数据

20:05.460 --> 20:06.460
不要说n嘛

20:06.460 --> 20:07.460
我这个reducer

20:07.460 --> 20:08.460
是专门为它写的

20:08.460 --> 20:10.460
就是专门处理这个数据的

20:10.460 --> 20:11.460
那么这个数据变化

20:11.460 --> 20:12.460
是不是只有两种情况

20:12.460 --> 20:13.460
一个是增加

20:13.460 --> 20:14.460
一个是减少

20:14.460 --> 20:15.460
对吧

20:15.460 --> 20:16.460
增加1

20:16.460 --> 20:17.460
减少1

20:17.460 --> 20:18.460
对吧

20:18.460 --> 20:19.460
只有这两种情况

20:19.460 --> 20:20.460
那我怎么来知道

20:20.460 --> 20:22.460
是增加还是减少呢

20:22.460 --> 20:23.460
怎么来知道

20:23.460 --> 20:24.460
增加还是减少

20:24.460 --> 20:25.460
是不是通过action

20:25.460 --> 20:26.460
里面就记录了

20:26.460 --> 20:28.460
你到底要干嘛

20:28.460 --> 20:29.460
对不对

20:29.460 --> 20:31.460
你到底要干嘛呀

20:31.460 --> 20:32.460
我把这个东西

20:32.460 --> 20:33.460
也要给我

20:33.460 --> 20:35.460
ok 那我这里呢

20:35.460 --> 20:37.460
这里呢我干嘛呢

20:37.460 --> 20:38.460
我这里呢就是

20:38.460 --> 20:40.460
写上这么一个判断

20:40.460 --> 20:42.460
或者是用switch嘛

20:42.460 --> 20:44.460
switch

20:44.460 --> 20:45.460
switch上呢

20:45.460 --> 20:48.460
就是action的配

20:48.460 --> 20:50.460
这个type

20:50.460 --> 20:51.460
action的type

20:51.460 --> 20:53.460
就到底是什么类型的

20:54.460 --> 20:55.460
好 一个来

20:55.460 --> 20:56.460
task

20:56.460 --> 20:57.460
如果说你的值呢

20:57.460 --> 20:59.460
比方说是increase

20:59.460 --> 21:00.460
increase

21:00.460 --> 21:02.460
增加

21:02.460 --> 21:03.460
如果你的类型

21:03.460 --> 21:05.460
我们全是约定好

21:05.460 --> 21:06.460
全是约定好

21:06.460 --> 21:08.460
你这个类型是增加的话

21:08.460 --> 21:10.460
我干嘛呢

21:10.460 --> 21:11.460
你现在的状态

21:11.460 --> 21:12.460
我是不是要加1

21:12.460 --> 21:13.460
这个状态就是数据

21:13.460 --> 21:15.460
就相当于是这个数据

21:15.460 --> 21:16.460
你的状态是不是要加1

21:16.460 --> 21:17.460
对吧

21:17.460 --> 21:19.460
反回state加1

21:19.460 --> 21:21.460
就这么个意思

21:22.460 --> 21:23.460
然后cance

21:23.460 --> 21:25.460
如果说你是减少

21:25.460 --> 21:27.460
decrease

21:27.460 --> 21:29.460
好 那么我反回啥呢

21:29.460 --> 21:31.460
反回你的状态

21:31.460 --> 21:32.460
减1

21:32.460 --> 21:34.460
对吧

21:34.460 --> 21:35.460
然后其他

21:35.460 --> 21:36.460
现在爆出了

21:36.460 --> 21:37.460
因为还有其他情况

21:37.460 --> 21:38.460
那如果你给我

21:38.460 --> 21:39.460
暖传一个状态怎么办呢

21:39.460 --> 21:41.460
你给我暖传了一个状态

21:41.460 --> 21:43.460
我用default

21:43.460 --> 21:45.460
你给我暖传了一个类型

21:45.460 --> 21:46.460
那我既不是增加

21:46.460 --> 21:47.460
也不是减少

21:47.460 --> 21:48.460
那我这里的处理逻辑上

21:48.460 --> 21:49.460
只有这两种情况

21:49.460 --> 21:50.460
没有别的情况了

21:50.460 --> 21:51.460
那我就数据不变呗

21:51.460 --> 21:53.460
数据反回给你

21:53.460 --> 21:55.460
这就是reducer的写法

21:55.460 --> 21:57.460
因为看一下我们这里

21:57.460 --> 21:58.460
reducer接受两个参数

21:58.460 --> 21:59.460
对吧

21:59.460 --> 22:00.460
一个state action

22:00.460 --> 22:01.460
它必须要一个反回结果

22:01.460 --> 22:02.460
这个反回结果就是

22:02.460 --> 22:03.460
变化之后的数据

22:03.460 --> 22:06.460
那你把之前的数据给我

22:06.460 --> 22:08.460
你把你要干麻给我

22:08.460 --> 22:10.460
然后我根据你要干麻

22:10.460 --> 22:11.460
和当前的数据

22:11.460 --> 22:12.460
来得到一个新的数据

22:12.460 --> 22:13.460
这就是reducer要干的事情

22:13.460 --> 22:14.460
你看这个代码

22:14.460 --> 22:16.460
根据react有啥关系

22:16.460 --> 22:17.460
是不是一定要关系的没有

22:17.460 --> 22:19.460
它是做存数据处理的

22:19.460 --> 22:20.460
对吧

22:20.460 --> 22:22.460
做存数据处理的

22:22.460 --> 22:25.460
那么到时候我要去

22:25.460 --> 22:28.460
我要去处理这个

22:28.460 --> 22:30.460
就是我要去

22:30.460 --> 22:31.460
调用这个reducer

22:31.460 --> 22:34.460
但是reducer就是flex

22:34.460 --> 22:36.460
它不要你直接去调用

22:36.460 --> 22:37.460
不可以直接去调用

22:37.460 --> 22:41.460
应该使用一个辅助函数dispatch

22:41.460 --> 22:43.460
使用这个辅助函数

22:43.460 --> 22:45.460
来进行调用

22:45.460 --> 22:46.460
好

22:46.460 --> 22:48.460
这个辅助函数咋写呢

22:48.460 --> 22:49.460
看着

22:49.460 --> 22:50.460
辅助函数呢

22:50.460 --> 22:52.460
我们可以用这种方式来写

22:52.460 --> 22:54.460
比方说我们在这里写个辅助函数

22:54.460 --> 22:56.460
dispatch

22:56.460 --> 22:57.460
dispatch里面

22:57.460 --> 22:58.460
我们刚才说了

22:58.460 --> 23:00.460
这个辅助函数呢

23:00.460 --> 23:02.460
要接受一个函数就是x

23:02.460 --> 23:04.460
x

23:04.460 --> 23:05.460
我们最后把整体写完

23:05.460 --> 23:07.460
整体写完就明白什么意思了

23:07.460 --> 23:09.460
它这里的确实有点绕

23:09.460 --> 23:10.460
这个数据处理方案

23:10.460 --> 23:11.460
确实有点绕

23:11.460 --> 23:12.460
它肯定有它的好处

23:12.460 --> 23:13.460
我们之后讲入

23:13.460 --> 23:14.460
大个社会详细说

23:14.460 --> 23:17.460
现在我们先接受

23:17.460 --> 23:18.460
有些东西呢

23:18.460 --> 23:20.460
你不是那么容易理解

23:20.460 --> 23:21.460
那你先接受它

23:21.460 --> 23:22.460
接受它呢

23:22.460 --> 23:24.460
就是知道它这个世界上存在这么个东西

23:24.460 --> 23:26.460
而且大家都在用

23:26.460 --> 23:27.460
你先接受它

23:27.460 --> 23:28.460
慢慢慢慢去体会这个东西

23:28.460 --> 23:29.460
比方说

23:29.460 --> 23:30.460
很多同学学面向对象的时候

23:30.460 --> 23:32.460
觉得面向对象学习很困难

23:32.460 --> 23:33.460
很难理解

23:33.460 --> 23:35.460
为什么要这样的写

23:35.460 --> 23:36.460
你只能先接受

23:36.460 --> 23:37.460
那是没办法

23:37.460 --> 23:38.460
学习面向对象也好

23:38.460 --> 23:40.460
学习函数字编程也好

23:40.460 --> 23:42.460
都是一个非常漫长的一个过程

23:42.460 --> 23:45.460
不要想一口吃成一个胖子

23:45.460 --> 23:46.460
我这里说一点题外话吧

23:46.460 --> 23:47.460
就是很多同学

23:47.460 --> 23:49.460
我在上课的过程中

23:49.460 --> 23:52.460
很多同学都是在问到这么一个问题

23:52.460 --> 23:54.460
就是说咱们学技术

23:54.460 --> 23:56.460
到底要学几年

23:56.460 --> 23:59.460
可以把前端的技术算算是精通

23:59.460 --> 24:01.460
我经常听到这样的一个问题

24:01.460 --> 24:03.460
实际上是这样子的

24:03.460 --> 24:05.460
你学技术是学不完了

24:05.460 --> 24:07.460
你越学得多

24:07.460 --> 24:08.460
越自觉着自己

24:08.460 --> 24:09.460
越傻逼

24:09.460 --> 24:10.460
就是自己不懂的东西

24:10.460 --> 24:11.460
越多

24:11.460 --> 24:13.460
有一段时间我给大家举个例子

24:13.460 --> 24:15.460
那个时候的工作

24:15.460 --> 24:16.460
有三年了

24:16.460 --> 24:17.460
三年来的工作

24:17.460 --> 24:19.460
突然有一天我不敢写辩量了

24:19.460 --> 24:20.460
为什么

24:20.460 --> 24:21.460
我突然觉得辩量

24:21.460 --> 24:23.460
像我完全理解不了辩量是怎么回事

24:23.460 --> 24:25.460
我辩量都不敢写了

24:25.460 --> 24:26.460
因为那个时候

24:26.460 --> 24:29.460
当我们去研究到一些底层原理的时候

24:29.460 --> 24:30.460
你没研究透的时候

24:30.460 --> 24:32.460
你真的是觉得啥都不懂了

24:32.460 --> 24:33.460
后来我搞清楚了

24:33.460 --> 24:34.460
我才敢写辩量

24:34.460 --> 24:36.460
那段时间我真的不敢写大码了

24:36.460 --> 24:37.460
你辩量都不敢写

24:37.460 --> 24:39.460
你刚我说我能干吗

24:39.460 --> 24:41.460
那就是你越研究得多的话

24:41.460 --> 24:43.460
你会发现

24:43.460 --> 24:44.460
你不懂得越多

24:44.460 --> 24:46.460
所以说这个技术是学不完的

24:46.460 --> 24:48.460
绝对不可能出现说有一个大神出来

24:48.460 --> 24:50.460
这个世界上计划机构技术

24:50.460 --> 24:51.460
全部搞清楚了

24:51.460 --> 24:53.460
我告诉你绝对不可能

24:53.460 --> 24:54.460
你就从现在开始

24:54.460 --> 24:55.460
你不迟不和不睡觉

24:55.460 --> 24:56.460
也不上班

24:56.460 --> 24:57.460
天天就学

24:57.460 --> 24:58.460
学到你隔壁的一天

24:58.460 --> 24:59.460
你都学不完

24:59.460 --> 25:01.460
你都学不完

25:01.460 --> 25:03.460
不要包着什么这种心态

25:03.460 --> 25:04.460
就是说

25:04.460 --> 25:06.460
我能够学个一年

25:06.460 --> 25:07.460
学个两年

25:07.460 --> 25:08.460
我教练

25:08.460 --> 25:09.460
教练费用

25:09.460 --> 25:10.460
在学校里面

25:10.460 --> 25:11.460
认真学习一下

25:11.460 --> 25:13.460
我就把所有东西全部搞定了

25:13.460 --> 25:15.460
而且天下无敌了

25:15.460 --> 25:17.460
我出去以后就再也不用学习了

25:17.460 --> 25:18.460
我就靠那一点知识

25:18.460 --> 25:20.460
能够称霸天下了

25:20.460 --> 25:21.460
不可能的

25:21.460 --> 25:22.460
绝对不可能

25:22.460 --> 25:23.460
你不要说你们了

25:23.460 --> 25:24.460
老是不可能

25:24.460 --> 25:26.460
所以说不要去包有这样的幻想

25:26.460 --> 25:29.460
这个学习是一个不断持续的过程

25:29.460 --> 25:31.460
所以说市场上竞争的

25:31.460 --> 25:33.460
不管有多么激烈

25:33.460 --> 25:35.460
也绝不会有人说

25:35.460 --> 25:37.460
它是天下无敌的

25:37.460 --> 25:39.460
总有人会超过它

25:39.460 --> 25:41.460
因为它不可能学完

25:41.460 --> 25:42.460
因此后来

25:42.460 --> 25:45.460
你再如果你要走技术这条路的话

25:45.460 --> 25:46.460
那么你的技术发展

25:46.460 --> 25:49.460
你的薪资待遇等等等等

25:49.460 --> 25:51.460
你只能通过不断的学习才能获得

25:51.460 --> 25:52.460
如果你懒得的话

25:52.460 --> 25:54.460
那可能就停滞不前了

25:54.460 --> 25:56.460
如果你长时间几年时间

25:56.460 --> 25:58.460
你都没有去更新自己的知识的话

25:58.460 --> 26:00.460
慢慢就会被市场淘汰

26:00.460 --> 26:03.460
除非你在有些官僚气氛

26:03.460 --> 26:04.460
比较重的公司

26:04.460 --> 26:05.460
比方说

26:05.460 --> 26:07.460
那个MS

26:07.460 --> 26:09.460
有些官僚气氛比较重的公司

26:09.460 --> 26:11.460
比方说那个

26:11.460 --> 26:13.460
再比方说那个就是

26:13.460 --> 26:15.460
BD

26:15.460 --> 26:18.460
那么在这些公司里边

26:18.460 --> 26:20.460
你可能

26:20.460 --> 26:23.460
你跟那个领导关系混俗了

26:23.460 --> 26:25.460
跟同事关系混俗了

26:25.460 --> 26:26.460
哪怕你天天屁事不干

26:26.460 --> 26:28.460
你可能在里面混日子

26:28.460 --> 26:30.460
但是那是一种非常危险的状态

26:30.460 --> 26:32.460
一旦市场有变化

26:32.460 --> 26:33.460
你不能说任何世界上

26:33.460 --> 26:36.460
任何一家公司都是永远稳定的

26:36.460 --> 26:38.460
因为那是私人企业

26:38.460 --> 26:40.460
而且是参与市场竞争的

26:40.460 --> 26:42.460
现在不就退出了

26:42.460 --> 26:43.460
基本上

26:43.460 --> 26:44.460
基本上被那个什么

26:44.460 --> 26:45.460
以前都说BAT对吧

26:45.460 --> 26:47.460
那么现在只有AT了

26:47.460 --> 26:48.460
没有那个B了

26:48.460 --> 26:51.460
现在今日头条的市值都被白度高了

26:51.460 --> 26:52.460
市场竞争

26:52.460 --> 26:53.460
你不可能说

26:53.460 --> 26:55.460
一个公司

26:55.460 --> 26:58.460
这样子永远是行业老大

26:58.460 --> 26:59.460
很难的

26:59.460 --> 27:00.460
真的很难的

27:00.460 --> 27:01.460
你看美国很多公司

27:01.460 --> 27:04.460
都是经过了一百多年

27:04.460 --> 27:06.460
或者是甚至200年

27:06.460 --> 27:08.460
以上的城店

27:08.460 --> 27:10.460
才有今天的规模

27:10.460 --> 27:11.460
这种行业老大的规模

27:11.460 --> 27:12.460
他们都不敢大意

27:12.460 --> 27:15.460
比方说以前的那个

27:15.460 --> 27:17.460
那个什么

27:17.460 --> 27:19.460
这个相机叫啥呢

27:19.460 --> 27:21.460
以前的相机

27:21.460 --> 27:22.460
叫啥相机呢

27:22.460 --> 27:23.460
我忘了

27:23.460 --> 27:25.460
它是胶减相机

27:25.460 --> 27:27.460
叫啥相机呢

27:27.460 --> 27:29.460
离康还是什么玩意

27:29.460 --> 27:30.460
我突然忘了

27:30.460 --> 27:31.460
很大一个牌子

27:31.460 --> 27:32.460
现在哪了

27:32.460 --> 27:33.460
人都不见了

27:33.460 --> 27:34.460
以前逻辑

27:34.460 --> 27:35.460
多强大

27:35.460 --> 27:36.460
人呢 现在

27:36.460 --> 27:39.460
像这些老牌企业

27:39.460 --> 27:40.460
都容易出现这样的问题

27:40.460 --> 27:43.460
还不说中国这么多新兴企业

27:43.460 --> 27:44.460
阿里才过了多少年

27:44.460 --> 27:45.460
有20年没有

27:45.460 --> 27:46.460
差不多

27:46.460 --> 27:47.460
20年才时间

27:47.460 --> 27:49.460
20多年的时间

27:49.460 --> 27:50.460
这才多多少年

27:50.460 --> 27:51.460
不要保持什么

27:51.460 --> 27:53.460
吃黄粮吃一辈子的幻想

27:53.460 --> 27:55.460
除非你已经国企

27:55.460 --> 27:57.460
国企的话

27:57.460 --> 27:59.460
也说不准

27:59.460 --> 28:01.460
鬼知道以后会发生什么

28:01.460 --> 28:02.460
对吧

28:02.460 --> 28:03.460
这些话呢

28:03.460 --> 28:04.460
我就不多说了

28:04.460 --> 28:05.460
大家心里面

28:05.460 --> 28:06.460
有这么一个感知

28:06.460 --> 28:08.460
感知就行了

28:08.460 --> 28:09.460
所以说回来

28:09.460 --> 28:10.460
说回到这里

28:10.460 --> 28:11.460
说到这么远了

28:11.460 --> 28:13.460
就是先认识一下

28:13.460 --> 28:15.460
认识它就是这么一种结构

28:15.460 --> 28:17.460
那么现在有一个函数dispatch

28:17.460 --> 28:18.460
这是个辅助函数

28:18.460 --> 28:20.460
这个函数要干嘛呢

28:20.460 --> 28:21.460
这个函数要干嘛呢

28:21.460 --> 28:23.460
这个函数就是

28:23.460 --> 28:26.460
帮助理去调用这个reducer

28:26.460 --> 28:27.460
那这个函数

28:27.460 --> 28:29.460
是不是要得到当前的数据

28:29.460 --> 28:32.460
它就是要帮你来调用reducer的

28:32.460 --> 28:35.460
它把当前的数据n传进去

28:35.460 --> 28:37.460
然后你不是给它一个x吗

28:37.460 --> 28:38.460
对不对

28:38.460 --> 28:40.460
再把x也传进去

28:40.460 --> 28:41.460
那么这个reducer

28:41.460 --> 28:43.460
是不是会返回一个东西

28:43.460 --> 28:45.460
它会返回一个新的数据

28:45.460 --> 28:47.460
咱们来获取6n

28:47.460 --> 28:48.460
所以拿到一个新的数据

28:48.460 --> 28:49.460
这个reducer

28:49.460 --> 28:51.460
是不是拿到新的数据

28:51.460 --> 28:52.460
拿到新的数据过后

28:52.460 --> 28:53.460
它要干嘛呢

28:53.460 --> 28:56.460
它是不是调用setn

28:56.460 --> 28:58.460
把这个新的数据6n传进去

28:58.460 --> 29:00.460
就这么简单

29:00.460 --> 29:01.460
就这么简单

29:01.460 --> 29:02.460
这是发起

29:02.460 --> 29:03.460
还有多复杂呢

29:03.460 --> 29:04.460
我觉得这个代码应该不复杂吧

29:04.460 --> 29:06.460
非常简单吧

29:06.460 --> 29:08.460
这就是dispatch的函数

29:08.460 --> 29:09.460
对吧

29:09.460 --> 29:10.460
没啥东西的

29:10.460 --> 29:12.460
然后有了这个函数之后

29:12.460 --> 29:14.460
你看我们现在数据仓库在哪

29:14.460 --> 29:16.460
数据仓库就是这个

29:16.460 --> 29:17.460
就是我们的状态

29:17.460 --> 29:18.460
状态就是数据仓库

29:18.460 --> 29:20.460
这是我们存数据的地方

29:20.460 --> 29:22.460
然后这是我们通过这个

29:22.460 --> 29:24.460
这个辅助函数来改变数据

29:24.460 --> 29:25.460
它怎么来改变呢

29:25.460 --> 29:26.460
你要告诉它

29:26.460 --> 29:27.460
你要干嘛

29:27.460 --> 29:28.460
你要干嘛告诉它

29:28.460 --> 29:30.460
那么它就会把数据

29:30.460 --> 29:32.460
当前的数据传给reducer

29:32.460 --> 29:34.460
传给这个状态

29:34.460 --> 29:36.460
然后你要干嘛传给它

29:36.460 --> 29:38.460
于是它会是不是返回一个新的数据

29:38.460 --> 29:39.460
好 返回新的数据

29:39.460 --> 29:40.460
我们接受一下

29:40.460 --> 29:42.460
然后重新设置新的数据

29:42.460 --> 29:43.460
把这个数据仓库里面

29:43.460 --> 29:44.460
只重新设置新的数据

29:44.460 --> 29:45.460
对吧

29:45.460 --> 29:46.460
就完了

29:46.460 --> 29:48.460
就完了

29:48.460 --> 29:49.460
好 接下来呢

29:49.460 --> 29:50.460
我们在按钮里面

29:50.460 --> 29:51.460
你先别管它

29:51.460 --> 29:52.460
为什么要这样做

29:52.460 --> 29:53.460
我们以后Redux

29:53.460 --> 29:54.460
再详细说

29:54.460 --> 29:56.460
它就是这样的模式

29:56.460 --> 29:58.460
用户调用dispatch

29:58.460 --> 29:59.460
dispatch把数据仓库的

29:59.460 --> 30:00.460
reducer

30:00.460 --> 30:01.460
再把这个action

30:01.460 --> 30:02.460
也给reducer

30:02.460 --> 30:04.460
然后让它得到新的数据

30:04.460 --> 30:06.460
来更新数据仓库

30:06.460 --> 30:07.460
好 那么现在

30:07.460 --> 30:08.460
当我们点击按钮的时候

30:08.460 --> 30:09.460
要干嘛呢

30:09.460 --> 30:10.460
我们是不是就可以简单的

30:10.460 --> 30:12.460
使用dispatch搞定了

30:12.460 --> 30:14.460
调用这个辅助函数

30:14.460 --> 30:15.460
这个辅助函数里面

30:15.460 --> 30:16.460
我们就有了一种

30:16.460 --> 30:17.460
统一的改变数据方式

30:17.460 --> 30:19.460
以后任何的需要改变数据方式

30:19.460 --> 30:20.460
都使用dispatch

30:20.460 --> 30:22.460
而不再使用什么

30:22.460 --> 30:23.460
在这里用什么set这样

30:23.460 --> 30:24.460
set那样

30:24.460 --> 30:25.460
不用这样做了

30:25.460 --> 30:26.460
全部使用dispatch

30:26.460 --> 30:27.460
就是flux

30:27.460 --> 30:28.460
它的理想状态下

30:28.460 --> 30:30.460
是有这么一种方案

30:30.460 --> 30:31.460
dispatch的时候

30:31.460 --> 30:32.460
是不是传一个action

30:32.460 --> 30:33.460
action传递啥

30:33.460 --> 30:34.460
是不是传个type就行了

30:34.460 --> 30:36.460
这里没有什么payload

30:36.460 --> 30:37.460
这里没有什么payload

30:37.460 --> 30:38.460
没有附加数据

30:38.460 --> 30:40.460
我就传个type就行了

30:40.460 --> 30:41.460
type为什么呢

30:41.460 --> 30:43.460
type为就是

30:43.460 --> 30:45.460
increase

30:45.460 --> 30:46.460
increase增加

30:46.460 --> 30:48.460
我这里要做增加

30:48.460 --> 30:50.460
好 那么这里的点击的时候

30:50.460 --> 30:51.460
我这里要干嘛呢

30:51.460 --> 30:54.460
我这里要减少

30:54.460 --> 30:56.460
不能这样子写

30:56.460 --> 30:58.460
你得传一个函数进去

30:58.460 --> 30:59.460
你怎么能这样子写

30:59.460 --> 31:00.460
在这里写

31:00.460 --> 31:01.460
dispatch增加

31:01.460 --> 31:02.460
这里呢

31:02.460 --> 31:04.460
dispatch Decrease

31:04.460 --> 31:06.460
减少

31:06.460 --> 31:07.460
对吧

31:07.460 --> 31:10.460
就是形成这么一种方案

31:10.460 --> 31:11.460
那么这样子的

31:11.460 --> 31:12.460
简单的说一下

31:12.460 --> 31:13.460
它的好处吧

31:13.460 --> 31:14.460
就这样子的

31:14.460 --> 31:17.460
你在渲染这一块东西的时候

31:17.460 --> 31:19.460
那么在这个函数里边

31:19.460 --> 31:20.460
你看一下

31:20.460 --> 31:22.460
它是跟什么无关了

31:22.460 --> 31:24.460
跟你怎么去改变

31:24.460 --> 31:25.460
数据是不是无关了

31:25.460 --> 31:28.460
我只是声明我要干嘛

31:28.460 --> 31:29.460
我要做什么

31:29.460 --> 31:30.460
我要增加

31:30.460 --> 31:31.460
这写反了

31:31.460 --> 31:32.460
我要减少

31:32.460 --> 31:33.460
我这里干嘛

31:33.460 --> 31:34.460
我要增加

31:34.460 --> 31:36.460
就是我在宣扰那个页面的时候

31:36.460 --> 31:37.460
要注册事件

31:37.460 --> 31:38.460
事件里面

31:38.460 --> 31:39.460
它就不再去涉及到

31:39.460 --> 31:41.460
我怎么去减少

31:41.460 --> 31:42.460
怎么去增加

31:42.460 --> 31:43.460
它就不涉及了

31:43.460 --> 31:44.460
我只是告诉你

31:44.460 --> 31:45.460
我要干嘛

31:45.460 --> 31:47.460
这样子是不是更加符合逻辑

31:47.460 --> 31:48.460
对吧

31:48.460 --> 31:49.460
我做了一个某个操作

31:49.460 --> 31:50.460
我就要干嘛

31:50.460 --> 31:51.460
那具体怎么去干

31:51.460 --> 31:52.460
谁的事情

31:52.460 --> 31:53.460
是不是他的事情

31:53.460 --> 31:54.460
对吧

31:54.460 --> 31:56.460
他来负责怎么去干

31:56.460 --> 31:58.460
而这个东西是跟reaction无关的

31:58.460 --> 31:59.460
你看这个函数

31:59.460 --> 32:02.460
拿一句话跟reaction有任何关系

32:02.460 --> 32:04.460
它只是处理数据的逻辑变化

32:04.460 --> 32:05.460
那么这样子

32:05.460 --> 32:07.460
就把这两者是不是分离了

32:07.460 --> 32:09.460
那假设我们就这里很简单嘛

32:09.460 --> 32:11.460
那假设这里有一千行代码

32:11.460 --> 32:13.460
这里有一万行代码

32:13.460 --> 32:15.460
那么这样的代码

32:15.460 --> 32:16.460
是不是可以达到复用的目的

32:16.460 --> 32:18.460
以后你就告诉我你要干嘛

32:18.460 --> 32:19.460
你别逼逼

32:19.460 --> 32:20.460
你告诉我你要干嘛

32:20.460 --> 32:21.460
那我剩下的事情

32:21.460 --> 32:22.460
我帮你去做

32:22.460 --> 32:23.460
于是呢

32:23.460 --> 32:25.460
我们在组建里面就非常纯净了

32:25.460 --> 32:27.460
我只是描述见面

32:27.460 --> 32:29.460
当我们做一些动作的时候

32:29.460 --> 32:30.460
或者时间到了

32:30.460 --> 32:33.460
或者说我要去点了某个东西

32:33.460 --> 32:35.460
或者是出发了某个事件

32:35.460 --> 32:37.460
我只是声明我要干嘛就行了

32:37.460 --> 32:38.460
剩下的事情我不管

32:38.460 --> 32:39.460
于是呢

32:39.460 --> 32:40.460
他把这个action传给了dispatch

32:40.460 --> 32:42.460
dispatch叫做分发器

32:42.460 --> 32:44.460
他把数据拿到

32:44.460 --> 32:45.460
把数据拿到

32:45.460 --> 32:47.460
然后把用户传给了action拿到

32:47.460 --> 32:48.460
然后拿去得到新的数据

32:48.460 --> 32:49.460
然后再把数据

32:49.460 --> 32:51.460
又重新改变数据仓库

32:51.460 --> 32:52.460
就这么个意思

32:52.460 --> 32:53.460
对吧

32:53.460 --> 32:54.460
你看一下

32:54.460 --> 32:56.460
这个一改变新的数据过后了

32:56.460 --> 32:57.460
是要重新运行

32:57.460 --> 32:58.460
重新宣传主�

32:58.460 --> 32:59.460
一重新宣传的话

32:59.460 --> 33:01.460
那么是不是

33:01.460 --> 33:03.460
是不是这个

33:03.460 --> 33:04.460
就得到新的数据了

33:04.460 --> 33:05.460
对不对

33:05.460 --> 33:06.460
就这么个意思

33:06.460 --> 33:08.460
就这么个意思

33:08.460 --> 33:10.460
保存咱们看一下

33:10.460 --> 33:12.460
那么现在是不是仍然可以实现

33:12.460 --> 33:13.460
增加减少

33:13.460 --> 33:14.460
对吧

33:14.460 --> 33:15.460
增加减少

33:15.460 --> 33:16.460
仍然可以实现

33:16.460 --> 33:18.460
就这么个意思

33:18.460 --> 33:19.460
那么这种方式

33:19.460 --> 33:21.460
大概说一下有什么好处

33:21.460 --> 33:22.460
那比方说以后

33:22.460 --> 33:24.460
我要修改

33:24.460 --> 33:25.460
修改啥呢

33:25.460 --> 33:26.460
修改就是减少了

33:26.460 --> 33:27.460
所以不能减少为0

33:27.460 --> 33:29.460
那你想一想这个逻辑

33:29.460 --> 33:30.460
我的数据减少

33:30.460 --> 33:31.460
它不能减少到

33:31.460 --> 33:32.460
不能减少到复数

33:32.460 --> 33:33.460
不能减少到复数

33:33.460 --> 33:35.460
那么这是数据的逻辑

33:35.460 --> 33:37.460
还是组建的逻辑

33:37.460 --> 33:39.460
是不是数据的逻辑

33:39.460 --> 33:41.460
跟组建没有任何关系

33:41.460 --> 33:42.460
跟显示的界面没有任何关系

33:42.460 --> 33:44.460
所以我们不动这个

33:44.460 --> 33:46.460
这个函数动都不用动

33:46.460 --> 33:47.460
我们干吗

33:47.460 --> 33:48.460
是不是我们在这里

33:48.460 --> 33:49.460
判断一下就完了

33:49.460 --> 33:50.460
对不对

33:50.460 --> 33:51.460
我们判断一下

33:51.460 --> 33:54.460
如果说Stats已经等于0了

33:54.460 --> 33:56.460
已经等于0了

33:56.460 --> 33:58.460
或者说它已经

33:58.460 --> 33:59.460
对吧

33:59.460 --> 34:00.460
就已经等于0了

34:00.460 --> 34:02.460
那么我就返回什么

34:02.460 --> 34:03.460
就返回0

34:03.460 --> 34:05.460
就返回0就完事了

34:05.460 --> 34:06.460
好你看一下

34:06.460 --> 34:07.460
现在这是数据的逻辑

34:07.460 --> 34:09.460
我们只改变数据

34:09.460 --> 34:10.460
看一下

34:10.460 --> 34:11.460
是不是减少不了了

34:11.460 --> 34:12.460
对吧

34:12.460 --> 34:14.460
减少到0就不行了

34:14.460 --> 34:15.460
对不对

34:15.460 --> 34:16.460
就这么个意思

34:16.460 --> 34:18.460
于是它更加纯净了

34:18.460 --> 34:19.460
而且另外

34:19.460 --> 34:21.460
我们以后每一次改变数据

34:21.460 --> 34:23.460
我要做一些记录

34:23.460 --> 34:25.460
比方说做一些日子记录

34:25.460 --> 34:27.460
是不是可以在dispatch里边写

34:27.460 --> 34:28.460
dispatch呢

34:28.460 --> 34:29.460
负责就是分发

34:29.460 --> 34:32.460
分发它是完成具体的数据变化

34:32.460 --> 34:34.460
那么还要去调用这个reducer

34:34.460 --> 34:35.460
好那么这里呢

34:35.460 --> 34:36.460
我们就可以怎么写了

34:36.460 --> 34:38.460
就可以日子

34:38.460 --> 34:39.460
日子

34:39.460 --> 34:40.460
n的值从

34:40.460 --> 34:41.460
我们这样吧

34:41.460 --> 34:43.460
写个模板支付串

34:43.460 --> 34:44.460
举个例子就行了

34:44.460 --> 34:45.460
日子

34:45.460 --> 34:46.460
n的值

34:46.460 --> 34:48.460
从多少变到多少

34:50.460 --> 34:52.460
n的值

34:52.460 --> 34:53.460
从多少呢

34:53.460 --> 34:55.460
从之前的n的值

34:55.460 --> 34:56.460
变到什么呢

34:56.460 --> 34:57.460
变到6n

34:58.460 --> 34:59.460
保存

34:59.460 --> 35:00.460
你看一下

35:00.460 --> 35:02.460
我们要做一些日子记录

35:03.460 --> 35:04.460
好

35:04.460 --> 35:05.460
点1加

35:05.460 --> 35:06.460
你看是不是从0变到1

35:06.460 --> 35:07.460
1变到2

35:07.460 --> 35:08.460
对吧

35:08.460 --> 35:09.460
就非常方便我们调试

35:09.460 --> 35:10.460
它到底是怎么回事

35:10.460 --> 35:12.460
数据是怎么来变化的

35:12.460 --> 35:13.460
对吧

35:13.460 --> 35:14.460
ok

35:14.460 --> 35:16.460
发了数据流的处理方案

35:16.460 --> 35:17.460
就这么一些

35:17.460 --> 35:18.460
接下来呢

35:18.460 --> 35:19.460
我们这里觉得

35:19.460 --> 35:20.460
哎

35:20.460 --> 35:22.460
还是不够简化呀

35:22.460 --> 35:24.460
这东西还是不够简化

35:24.460 --> 35:25.460
因为我们在这里边

35:25.460 --> 35:27.460
还要写什么dispatch

35:27.460 --> 35:28.460
还要写这个玩意

35:28.460 --> 35:31.460
那能不能把这个东西抽象出去呢

35:31.460 --> 35:33.460
能不能把这个东西抽象出去呢

35:33.460 --> 35:35.460
形成一个自定义的后可呢

35:36.460 --> 35:37.460
可以

35:37.460 --> 35:39.460
这就是我们这里要讲的

35:39.460 --> 35:40.460
我们这里要讲的就是

35:40.460 --> 35:42.460
把这个东西抽象出去

35:42.460 --> 35:43.460
好

35:43.460 --> 35:45.460
这个东西怎么来抽象呢

35:45.460 --> 35:46.460
你看着

35:46.460 --> 35:47.460
我可以用这种方式

35:47.460 --> 35:48.460
我把这一部分代码呢

35:48.460 --> 35:50.460
写成一个函数

35:50.460 --> 35:51.460
方个是

35:51.460 --> 35:52.460
给它取个名字叫做

35:52.460 --> 35:54.460
use

35:54.460 --> 35:56.460
与丢失

35:56.460 --> 35:58.460
与丢失这个函数

35:58.460 --> 36:00.460
我们自己写个函数

36:00.460 --> 36:01.460
这个函数呢

36:01.460 --> 36:03.460
接收一个

36:03.460 --> 36:04.460
接收一个啥呢

36:04.460 --> 36:06.460
接收一个

36:06.460 --> 36:08.460
嗯

36:08.460 --> 36:09.460
我们想一想啊

36:09.460 --> 36:10.460
这个函数干嘛

36:10.460 --> 36:11.460
我们这个世界函数

36:11.460 --> 36:12.460
世界啥都不写吗

36:12.460 --> 36:14.460
就这样子

36:14.460 --> 36:16.460
我们这个函数里边

36:16.460 --> 36:17.460
干嘛呢

36:17.460 --> 36:19.460
就把这两句话写进来

36:19.460 --> 36:20.460
对吧

36:20.460 --> 36:21.460
就这两句话写进来

36:21.460 --> 36:22.460
然后呢

36:22.460 --> 36:24.460
返回一个啥呢

36:24.460 --> 36:26.460
返回这个dispatch

36:26.460 --> 36:28.460
把这个dispatch函数返回

36:28.460 --> 36:29.460
可不可以

36:29.460 --> 36:30.460
是不是可以

36:30.460 --> 36:32.460
我们自己写了一个

36:32.460 --> 36:35.840
自己的自定义 hook

36:35.840 --> 36:37.840
自定义 hook

36:37.840 --> 36:39.840
用于

36:39.840 --> 36:41.840
抽离

36:41.840 --> 36:43.840
抽离数据处理

36:43.840 --> 36:45.840
数据处理

36:45.840 --> 36:46.840
对吧

36:46.840 --> 36:47.840
用于抽离数据处理

36:47.840 --> 36:48.840
OK

36:48.840 --> 36:49.840
我们把这个东西拿到了

36:49.840 --> 36:50.840
拿到了

36:50.840 --> 36:51.840
好

36:51.840 --> 36:52.840
我们这里就这样去干嘛

36:52.840 --> 36:54.840
就把这个返回就完了

36:54.840 --> 36:55.840
好

36:55.840 --> 36:56.840
于是呢在这边

36:56.840 --> 36:58.840
到了这边

36:58.840 --> 37:00.840
这边的话

37:00.840 --> 37:02.840
我们这里呢

37:02.840 --> 37:03.840
看着

37:03.840 --> 37:05.840
可以这样子来写

37:05.840 --> 37:06.840
我们这里是不是可以

37:06.840 --> 37:08.840
用这个use reducer

37:08.840 --> 37:09.840
对吧

37:09.840 --> 37:10.840
use reducer

37:10.840 --> 37:11.840
然后呢

37:11.840 --> 37:12.840
这个use reducer也没有什么参数

37:12.840 --> 37:13.840
它直接返回一个

37:13.840 --> 37:14.840
返回一个什么

37:14.840 --> 37:16.840
返回dispatch

37:16.840 --> 37:20.280
dispatch

37:20.280 --> 37:21.280
parch

37:21.280 --> 37:23.280
把这个函数给我返回了

37:23.280 --> 37:24.280
那数据完了

37:24.280 --> 37:26.280
这个组件是不是变得非常简单了

37:26.280 --> 37:27.280
但是你会发现

37:27.280 --> 37:28.280
现在还有一个问题就是

37:28.280 --> 37:29.280
我要得到这个数据得不到了

37:29.280 --> 37:30.280
因为这个数据呢

37:30.280 --> 37:31.280
在里边

37:31.280 --> 37:32.280
在这个函数里边

37:32.280 --> 37:33.280
它没有暴露出去

37:33.280 --> 37:34.280
外边呢

37:34.280 --> 37:35.280
它只能去

37:35.280 --> 37:37.280
通过它来改变数据

37:37.280 --> 37:38.280
通过这个分发器来改变数据

37:38.280 --> 37:40.280
但它得不到这个数据本身了

37:40.280 --> 37:41.280
所以这样子呢

37:41.280 --> 37:42.280
也不是很好

37:42.280 --> 37:43.280
因此呢

37:43.280 --> 37:44.280
我这里呢

37:44.280 --> 37:45.280
最好返回一个对象

37:45.280 --> 37:46.280
这个对象里边包含两个

37:46.280 --> 37:47.280
或者是返回说

37:47.280 --> 37:48.280
返回数组

37:48.280 --> 37:50.280
这个数组里面包含两个东西

37:50.280 --> 37:52.280
一个东西呢

37:52.280 --> 37:53.280
就是那个

37:53.280 --> 37:55.280
状态本身

37:55.280 --> 37:56.280
状态本身

37:56.280 --> 37:57.280
就是这个n

37:57.280 --> 37:58.280
状态本身

37:58.280 --> 38:00.280
另外一个东西呢

38:00.280 --> 38:02.280
就是dispatch

38:02.280 --> 38:03.280
这个c乘n

38:03.280 --> 38:04.280
我就不暴露出去了

38:04.280 --> 38:05.280
我给你这个状态

38:05.280 --> 38:06.280
我给你这个数据

38:06.280 --> 38:07.280
打用打用

38:07.280 --> 38:08.280
如果你要改变数据的话

38:08.280 --> 38:09.280
通过这个数

38:09.280 --> 38:10.280
反复来改变数据

38:10.280 --> 38:11.280
而不再直接通过

38:11.280 --> 38:13.280
这次n来改变数据了

38:13.280 --> 38:14.280
我这样子也返回

38:14.280 --> 38:15.280
返回这么一个数据

38:15.280 --> 38:16.280
好 那么你到时候

38:16.280 --> 38:17.280
接受的时候怎么接受

38:17.280 --> 38:18.280
是不是可以解构

38:18.280 --> 38:19.280
对吧

38:19.280 --> 38:21.280
我可以得到这个n

38:21.280 --> 38:22.280
又可以得到这个什么

38:22.280 --> 38:23.280
dispatch函数

38:23.280 --> 38:24.280
对吧

38:24.280 --> 38:25.280
是不是可以解构

38:25.280 --> 38:27.280
这样子你解构出来

38:27.280 --> 38:29.280
是不是这里又没问题了

38:29.280 --> 38:31.280
这个组件就变得更加简洁了

38:31.280 --> 38:32.280
用了这个函数之后

38:32.280 --> 38:33.280
变得更加简洁了

38:33.280 --> 38:35.280
保存 你看一下

38:35.280 --> 38:36.280
是一样的

38:36.280 --> 38:37.280
对吧

38:37.280 --> 38:39.280
变得更加简洁了

38:39.280 --> 38:40.280
这个组件

38:40.280 --> 38:42.280
就像把这一部分抽离出去

38:42.280 --> 38:43.280
没有什么特别的

38:43.280 --> 38:45.280
就是把刚才两句单码抽离出去

38:45.280 --> 38:47.280
然后他需要用到的东西

38:47.280 --> 38:48.280
返回

38:48.280 --> 38:49.280
当然这个返回的方式

38:49.280 --> 38:50.280
可以是一个数据

38:50.280 --> 38:51.280
也可以是个对象随便你

38:51.280 --> 38:52.280
随便你

38:52.280 --> 38:53.280
要这意思吧

38:55.280 --> 38:57.280
但是这样子一写的话

38:57.280 --> 38:58.280
我们再继续分析

38:58.280 --> 38:59.280
但是这样子一写的话

38:59.280 --> 39:01.280
那么以后是不是每一个组件

39:01.280 --> 39:03.280
凡是要用到数据处理的地方

39:03.280 --> 39:04.280
凡是我们要使用

39:04.280 --> 39:06.280
flex这个数据处理方案的话

39:07.280 --> 39:08.280
当然前提条件

39:08.280 --> 39:09.280
你是要用这个方案

39:09.280 --> 39:11.280
那么你是不是都得写一遍

39:11.280 --> 39:13.280
这个redius写我还可以理解

39:13.280 --> 39:14.280
因为redius写每一种数据

39:14.280 --> 39:17.280
他的改变方式是有区别的

39:17.280 --> 39:19.280
不要说你要添加三图学生

39:19.280 --> 39:20.280
跟你加数字肯定不一样

39:20.280 --> 39:21.280
对吧

39:21.280 --> 39:22.280
你肯定要重新写一遍

39:22.280 --> 39:23.280
这个毫无疑问

39:23.280 --> 39:24.280
但是这个东西有必要这样子

39:24.280 --> 39:26.280
每次反复写一个

39:26.280 --> 39:27.280
你看这个东西

39:27.280 --> 39:29.280
是不是每次逻辑是一样的

39:29.280 --> 39:30.280
对不对

39:30.280 --> 39:32.280
我有一个状态

39:32.280 --> 39:33.280
然后呢

39:33.280 --> 39:35.280
我要通过dspark去改变

39:35.280 --> 39:36.280
这个状态

39:36.280 --> 39:37.280
是不是都一样的

39:37.280 --> 39:39.280
这个us reducer

39:39.280 --> 39:40.280
对吧

39:40.280 --> 39:41.280
这块是不是都一样的

39:41.280 --> 39:42.280
好

39:42.280 --> 39:43.280
那么这样子一来呢

39:43.280 --> 39:45.280
我们是不是可以写一个

39:45.280 --> 39:47.280
通用的us reducer

39:47.280 --> 39:48.280
是不是可以写个通用的

39:48.280 --> 39:49.280
怎么写个通用的

39:49.280 --> 39:51.280
你告诉我这么一些东西

39:51.280 --> 39:52.280
你告诉我

39:52.280 --> 39:54.280
我要调用的

39:54.280 --> 39:56.280
比方说我们写到外面

39:56.280 --> 39:57.280
就写到这个

39:59.280 --> 40:01.280
接着我们先讲吧

40:01.280 --> 40:03.280
就在这里写个

40:03.280 --> 40:05.280
us reducer

40:05.280 --> 40:09.190
这件事

40:09.190 --> 40:10.190
那比方说

40:10.190 --> 40:11.190
我们这里又写个函数

40:11.190 --> 40:12.190
导出default

40:12.190 --> 40:15.190
写个通用的us reducer函数

40:15.190 --> 40:16.190
对吧

40:20.270 --> 40:21.270
方可信

40:22.270 --> 40:23.270
写个通用的

40:25.270 --> 40:28.270
通用的us reducer函数

40:30.270 --> 40:31.270
可以

40:31.270 --> 40:33.270
整个功能就是这样子

40:33.270 --> 40:34.270
整个功能就是

40:34.270 --> 40:35.270
我要有个状态

40:35.270 --> 40:36.270
然后呢

40:36.270 --> 40:37.270
我要有个dspark函数

40:37.270 --> 40:39.270
然后我最后会返回这个玩意

40:40.270 --> 40:41.270
然后我会返回这个玩意

40:41.270 --> 40:42.270
就这么个意思

40:42.270 --> 40:43.270
就这么个意思

40:44.270 --> 40:45.270
没了意思吧

40:46.270 --> 40:47.270
好

40:47.270 --> 40:48.270
那么现在呢

40:48.270 --> 40:50.270
我们把个代码扔过来

40:50.270 --> 40:51.270
你看哪些地方

40:51.270 --> 40:52.270
首先肯定 use

40:52.270 --> 40:54.270
这个东西要拿到

40:54.270 --> 40:55.270
import

40:55.270 --> 40:56.270
import

40:56.270 --> 40:58.270
my use state

40:59.270 --> 41:00.270
from

41:00.270 --> 41:01.270
这个东西要拿到

41:01.270 --> 41:02.270
这个好不疑问

41:02.270 --> 41:03.270
那么现在我们看一下

41:03.270 --> 41:04.270
哪些地方要变

41:04.270 --> 41:06.270
这个初始指数是不知道

41:07.270 --> 41:08.270
对吧

41:08.270 --> 41:09.270
这个reducer

41:09.270 --> 41:10.270
我要调用哪个reducer

41:10.270 --> 41:11.270
是不是不知道

41:11.270 --> 41:12.270
好

41:12.270 --> 41:14.270
你是不是得传一个reducer进来

41:15.270 --> 41:16.270
这个没问题吧

41:16.270 --> 41:18.270
你得给我这个玩意吧

41:18.270 --> 41:19.270
你再把reducer给我吧

41:19.270 --> 41:20.270
不然我咋知道

41:20.270 --> 41:21.270
你要调用哪个函数

41:21.270 --> 41:22.270
那么这个reducer

41:22.270 --> 41:23.270
是不是这个函数

41:24.270 --> 41:25.270
这个参数

41:25.270 --> 41:26.270
这个reducer

41:26.270 --> 41:27.270
是不是这个函数

41:27.270 --> 41:28.270
方形

41:34.440 --> 41:35.440
这个reducer

41:35.440 --> 41:36.440
是不是得是个函数吧

41:37.440 --> 41:38.440
对不对

41:38.440 --> 41:39.440
要告诉我

41:39.440 --> 41:40.440
函数格式是固定的

41:40.440 --> 41:42.440
我之前说过reducer是一个统一的格式

41:42.440 --> 41:44.440
它第一个是当前状态

41:44.440 --> 41:45.440
第二个是action

41:45.440 --> 41:46.440
对吧

41:46.440 --> 41:47.440
这东西你得告诉我

41:47.440 --> 41:48.440
还要告诉我啥呢

41:48.440 --> 41:50.440
是不是还要告诉我初始指

41:50.440 --> 41:51.440
initial

41:51.440 --> 41:52.440
data

41:52.440 --> 41:53.440
initial state

41:53.440 --> 41:54.440
对吧

41:54.440 --> 41:56.440
这个都要告诉我啥

41:56.440 --> 41:57.440
你要告诉我

41:57.440 --> 41:59.440
这个reducer是

41:59.440 --> 42:01.440
reducer函数

42:02.440 --> 42:03.440
标准格式

42:03.440 --> 42:04.440
就是你有两个参数

42:04.440 --> 42:05.440
第一个参数是当前状态

42:05.440 --> 42:07.440
第二个参数是action

42:07.440 --> 42:08.440
你还要告诉我啥

42:08.440 --> 42:10.440
还要告诉我

42:12.440 --> 42:13.440
任何类型

42:13.440 --> 42:14.440
initial state

42:14.440 --> 42:15.440
要告诉我这个

42:15.440 --> 42:17.440
就是初始状态

42:17.440 --> 42:19.440
你得把初始状态告诉我

42:19.440 --> 42:20.440
那么这样子

42:20.440 --> 42:21.440
我是把初始状态放在这儿

42:21.440 --> 42:22.440
对吧

42:22.440 --> 42:23.440
好

42:23.440 --> 42:24.440
那么这里我就换个名字

42:24.440 --> 42:25.440
就不能用n了

42:25.440 --> 42:26.440
当然用n也无所谓

42:26.440 --> 42:27.440
变相名字

42:27.440 --> 42:28.440
换一个名字

42:28.440 --> 42:30.440
比方说就是state

42:30.440 --> 42:31.440
set state

42:31.440 --> 42:33.440
换一个名字

42:33.440 --> 42:34.440
好

42:34.440 --> 42:35.440
然后呢

42:35.440 --> 42:36.440
这里呢

42:36.440 --> 42:37.440
这里reducer里边

42:37.440 --> 42:38.440
你给我

42:38.440 --> 42:39.440
我得到这么一个函数

42:39.440 --> 42:40.440
叫dispatch

42:40.440 --> 42:41.440
你给我一个action

42:41.440 --> 42:42.440
到时候呢

42:42.440 --> 42:43.440
我会得到什么

42:43.440 --> 42:45.440
我把当前状态给力

42:45.440 --> 42:46.440
然后把action给力

42:46.440 --> 42:47.440
是不是得到一个新的状态

42:47.440 --> 42:49.440
new state

42:49.440 --> 42:50.440
然后呢

42:50.440 --> 42:51.440
我们这里也输出一个日字

42:51.440 --> 42:52.440
比方说统一

42:52.440 --> 42:53.440
我得到输出日字

42:53.440 --> 42:54.440
ok

42:54.440 --> 42:55.440
那么我的状态是

42:55.440 --> 42:56.440
从旧状态

42:56.440 --> 42:57.440
变到啥

42:57.440 --> 42:58.440
变到这个新状态

42:58.440 --> 42:59.440
对不对

42:59.440 --> 43:01.440
然后set state

43:01.440 --> 43:03.440
设置新状态为

43:03.440 --> 43:05.440
new state

43:06.440 --> 43:08.440
然后返回了数组里边

43:08.440 --> 43:09.440
第一个是状态

43:09.440 --> 43:11.440
第二个是dispatch

43:11.440 --> 43:13.440
这样子是不是写出一个通用的

43:13.440 --> 43:14.440
reducer

43:14.440 --> 43:16.440
是写出一个通用的reducer

43:16.440 --> 43:17.440
于是呢

43:17.440 --> 43:18.440
到这边来

43:18.440 --> 43:19.440
好好看一下

43:19.440 --> 43:20.440
到这边来

43:20.440 --> 43:21.440
我这一部分是不用写的

43:21.440 --> 43:22.440
因为已经写了一个

43:22.440 --> 43:23.440
通用的reducer出来了

43:23.440 --> 43:25.440
所以说我们这里只需要导入

43:25.440 --> 43:27.440
这个地方也不要了

43:28.440 --> 43:30.440
直接导入 import

43:31.440 --> 43:33.440
那个是use reducer

43:34.440 --> 43:36.440
reducer

43:36.440 --> 43:37.440
from

43:37.440 --> 43:38.440
什么呢

43:40.440 --> 43:41.440
第二鞋杠

43:41.440 --> 43:42.440
use reducer

43:43.440 --> 43:44.440
好

43:44.440 --> 43:45.440
那么这里怎么用呢

43:45.440 --> 43:46.440
你看着

43:46.440 --> 43:48.440
我们就使用use reducer

43:48.440 --> 43:49.440
里边呢

43:49.440 --> 43:50.440
我们给力啥

43:50.440 --> 43:52.440
是不是要给力一个reducer函数

43:52.440 --> 43:54.440
你这一次

43:54.440 --> 43:56.440
怎么来处理数据

43:56.440 --> 43:57.440
怎么来处理数据变化

43:57.440 --> 43:58.440
是这个有reducer函数

43:58.440 --> 43:59.440
当这个函数的名字

43:59.440 --> 44:00.440
你可以随便取一个

44:00.440 --> 44:02.440
你只要以后追reducer结尾

44:02.440 --> 44:03.440
比方说n reducer

44:03.440 --> 44:05.440
比方说n reducer

44:05.440 --> 44:07.440
专门来处理数字n的

44:07.440 --> 44:08.440
随便取一个名字都行

44:09.440 --> 44:10.440
我们用这个reducer函数

44:10.440 --> 44:11.440
然后初始值呢

44:11.440 --> 44:14.440
初始值比方说是0

44:14.440 --> 44:15.440
初始值是0

44:15.440 --> 44:16.440
那么现在的结果是一样的

44:16.440 --> 44:18.440
现在代表不用动

44:18.440 --> 44:19.440
不用动

44:19.440 --> 44:20.440
我们这里解构

44:20.440 --> 44:22.440
得到它状态和dispatch

44:22.440 --> 44:23.440
保存

44:23.440 --> 44:24.440
你看一下

44:25.440 --> 44:26.440
完全一样的效果

44:26.440 --> 44:27.440
对吧

44:27.440 --> 44:28.440
但是现在呢

44:28.440 --> 44:30.440
这个玩意儿就是通用的了

44:30.440 --> 44:32.440
是完全通用的了

44:32.440 --> 44:34.440
明白这个意思吗

44:34.440 --> 44:36.440
这就是咱们的

44:36.440 --> 44:37.440
这个

44:37.440 --> 44:39.440
用flux数据流

44:39.440 --> 44:41.440
它的怎么来处理这个问题

44:41.440 --> 44:42.440
在react里面

44:42.440 --> 44:44.440
现在有了以前的react里面

44:44.440 --> 44:45.440
它是不管这个问题的

44:45.440 --> 44:47.440
不管什么数据流处理方案

44:47.440 --> 44:48.440
不管呢

44:48.440 --> 44:49.440
那么它现在呢

44:49.440 --> 44:50.440
有了后可之后

44:50.440 --> 44:52.440
我们可以使用这样的方式

44:52.440 --> 44:54.440
来完成类似于flux

44:54.440 --> 44:55.440
以及类似于我们

44:55.440 --> 44:57.440
后面dux的这种功能

44:57.440 --> 44:58.440
但它现在说

44:58.440 --> 45:00.440
要说现在它能取代react

45:00.440 --> 45:02.440
还不至于

45:02.440 --> 45:03.440
还不至于

45:03.440 --> 45:04.440
将来说不准

45:04.440 --> 45:06.440
我可以说将来说不准

45:06.440 --> 45:08.440
很多时候看以后吧

45:08.440 --> 45:09.440
看以后的发展

45:09.440 --> 45:10.440
那么现在呢

45:10.440 --> 45:11.440
它就变成这种方案了

45:11.440 --> 45:12.440
对吧

45:12.440 --> 45:15.440
现在只要一个通用的use reducer

45:15.440 --> 45:16.440
实际上这个

45:16.440 --> 45:17.440
通用的use reducer

45:17.440 --> 45:18.440
别人已经已经写好了

45:18.440 --> 45:20.440
你自己都不用写

45:20.440 --> 45:21.440
自己都不用写

45:21.440 --> 45:22.440
它可以放到哪儿的呢

45:22.440 --> 45:24.440
它可以放到这儿的

45:24.440 --> 45:26.440
还有一个官方的use reducer

45:27.440 --> 45:28.440
已经有了

45:28.440 --> 45:30.440
你看直接用它就行了

45:30.440 --> 45:31.440
我一行代码不用改

45:31.440 --> 45:32.440
保存

45:33.440 --> 45:34.440
你看呀

45:34.440 --> 45:35.440
是不是已经完成了

45:35.440 --> 45:36.440
对吧

45:36.440 --> 45:38.440
我们刚才只不过自己写了一遍

45:38.440 --> 45:39.440
只不过它已经给你写好了

45:39.440 --> 45:40.440
直接用就行了

45:40.440 --> 45:43.440
一模一样的功能

45:43.440 --> 45:44.440
一模一样的功能

45:44.440 --> 45:45.440
那如果你第二个参数

45:45.440 --> 45:46.440
不写的话

45:46.440 --> 45:47.440
就是没有默认字

45:47.440 --> 45:48.440
对不对

45:48.440 --> 45:49.440
undefined

45:49.440 --> 45:50.440
没有默认字

45:50.440 --> 45:51.440
当然默认字

45:51.440 --> 45:53.440
你可以写任何东西

45:53.440 --> 45:54.440
对吧

45:54.440 --> 45:55.440
这就是

45:55.440 --> 45:56.440
没啥说的吧

45:56.440 --> 45:58.440
官方已经给你写好了

45:58.440 --> 45:59.440
你还管那么多干嘛

45:59.440 --> 46:01.440
他已经写好了

46:01.440 --> 46:02.440
那么以后呢

46:02.440 --> 46:03.440
以后呢

46:03.440 --> 46:04.440
比方说我们假设

46:04.440 --> 46:05.440
我们整个系统里边

46:05.440 --> 46:06.440
绝大部分数据

46:06.440 --> 46:08.440
都用这种方案的话

46:08.440 --> 46:09.440
那你看一下

46:09.440 --> 46:10.440
以后我们自己是不是

46:10.440 --> 46:11.440
不会用什么use reducer

46:11.440 --> 46:12.440
对吧

46:12.440 --> 46:14.440
不会再用use reducer了

46:14.440 --> 46:15.440
而转而是什么呢

46:15.440 --> 46:17.440
转我们只需要先写出

46:17.440 --> 46:18.440
我们这一块的

46:18.440 --> 46:20.440
这个组件相关数据

46:20.440 --> 46:21.440
它有哪些变化

46:21.440 --> 46:22.440
怎么变化

46:22.440 --> 46:24.440
我们先把这个逻辑抽离出来

46:24.440 --> 46:25.440
让整个组件的结构

46:25.440 --> 46:28.440
变得非常非常清晰

46:28.440 --> 46:29.440
我都不用写组件的界面

46:29.440 --> 46:30.440
界面都没有

46:30.440 --> 46:31.440
我只是想象一下

46:31.440 --> 46:32.440
我这个组件

46:32.440 --> 46:33.440
它的依赖的数据

46:33.440 --> 46:34.440
它会发生哪些变化

46:34.440 --> 46:37.440
我们先把这个变化写出来

46:37.440 --> 46:39.440
然后我们要做的事情就是

46:39.440 --> 46:40.440
使用use reducer

46:40.440 --> 46:41.440
把这个传统进行

46:41.440 --> 46:42.440
初始者

46:42.440 --> 46:44.440
初始状态的团进去

46:44.440 --> 46:45.440
然后得到一个结果

46:45.440 --> 46:46.440
那么到时候

46:46.440 --> 46:47.440
要变化状态的时候

46:47.440 --> 46:48.440
我们只需要

46:48.440 --> 46:49.440
dispatch这个函数

46:49.440 --> 46:51.440
我要干嘛告诉你

46:51.440 --> 46:52.440
你去做

46:52.440 --> 46:53.440
如果合适的话

46:53.440 --> 46:55.440
我还会给你一个payload的

46:55.440 --> 46:56.440
还会给你一个payload的

46:56.440 --> 46:57.440
就这么个意思

46:57.440 --> 47:01.440
这就是reaction里边

47:01.440 --> 47:03.440
use reducer这个 hook

47:03.440 --> 47:04.440
所以说这句话

47:04.440 --> 47:05.440
几句话就讲完了

47:05.440 --> 47:06.440
因为我们自己已经写了一遍

47:06.440 --> 47:08.440
只不过这个use reducer

47:08.440 --> 47:09.440
这个函数

47:09.440 --> 47:11.440
它可以传第3个传统

47:11.440 --> 47:13.440
这三个传统基本上

47:13.440 --> 47:15.440
没多少意义

47:15.440 --> 47:18.440
这三个传统它是这样子

47:18.440 --> 47:20.440
它是一个函数

47:20.440 --> 47:22.440
它是一个函数

47:22.440 --> 47:25.440
这个函数它的返回结果

47:25.440 --> 47:28.440
会作为初始值

47:28.440 --> 47:29.440
保存你看一下

47:29.440 --> 47:30.440
现在是100

47:30.440 --> 47:31.440
初始值是100

47:31.440 --> 47:32.440
是不是10

47:32.440 --> 47:33.440
对吧

47:33.440 --> 47:34.440
不是10

47:34.440 --> 47:35.440
那么当你传了

47:35.440 --> 47:37.440
第三个传统函数过后

47:37.440 --> 47:38.440
它会用第三个传统

47:38.440 --> 47:41.440
函数来代表它的初始值

47:41.440 --> 47:42.440
不要这意思吧

47:42.440 --> 47:43.440
就是说

47:43.440 --> 47:46.440
它以这个函数的返回结果

47:46.440 --> 47:47.440
它调用这个函数

47:47.440 --> 47:49.440
以这个函数的返回结果

47:49.440 --> 47:50.440
来作为初始值

47:50.440 --> 47:51.440
就这么个意思

47:51.440 --> 47:52.440
那第二个值还有什么用呢

47:52.440 --> 47:53.440
它第二个值会

47:53.440 --> 47:54.440
把它作为

47:54.440 --> 47:58.440
参数传到第三个函数里边去

47:58.440 --> 47:59.440
它会把它作为

47:59.440 --> 48:00.440
参数传过去

48:00.440 --> 48:01.440
你看一下

48:01.440 --> 48:02.440
对吧

48:02.440 --> 48:04.440
这倒是第二个值是

48:04.440 --> 48:05.440
这种场景

48:05.440 --> 48:06.440
我们就简单说一下就行了

48:06.440 --> 48:07.440
这个场景用的很少

48:07.440 --> 48:08.440
这个场景是一般

48:08.440 --> 48:10.440
初始值还要经过一些

48:10.440 --> 48:11.440
复杂的计算

48:11.440 --> 48:13.440
它要通过这个值

48:13.440 --> 48:15.440
来算出最终的初始值

48:15.440 --> 48:16.440
会经过一个复杂的计算

48:16.440 --> 48:17.440
那么比方说

48:17.440 --> 48:19.440
这个值它可能来自于属性

48:19.440 --> 48:20.440
可能来自于属性

48:20.440 --> 48:22.440
比方说属性里边有个N

48:22.440 --> 48:23.440
就例子

48:23.440 --> 48:24.440
属性里边有个N

48:24.440 --> 48:27.440
那么它根据属性来得到

48:27.440 --> 48:29.440
来通过函数来

48:29.440 --> 48:31.440
算出它的另外一个初始值

48:31.440 --> 48:33.440
来算出它的状态的初始值

48:33.440 --> 48:35.440
就这么个意思

48:35.440 --> 48:37.440
经过一些复杂的计算

48:37.440 --> 48:38.440
来进行

48:38.440 --> 48:39.440
来进行那个

48:39.440 --> 48:40.440
创建初始值

48:40.440 --> 48:41.440
其实这一点

48:41.440 --> 48:42.440
我们也可以在

48:42.440 --> 48:43.440
我们自己写的这个

48:43.440 --> 48:44.440
U字Reducer里边

48:44.440 --> 48:45.440
给它加上

48:45.440 --> 48:46.440
比方说第三个函数

48:46.440 --> 48:48.440
放函数

48:48.440 --> 48:50.820
排绕

48:50.820 --> 48:53.820
然后这里Funk

48:53.820 --> 48:54.820
换个名字

48:54.820 --> 48:56.820
叫做InnitFunk

48:56.820 --> 48:58.820
初始的一个函数

48:58.820 --> 49:00.820
计算初始值的函数

49:00.820 --> 49:05.410
它类型是方形

49:05.410 --> 49:10.410
它是用于计算初始值的函数

49:10.410 --> 49:11.410
好

49:11.410 --> 49:12.410
那么这里

49:12.410 --> 49:13.410
我们在U字State里边

49:13.410 --> 49:14.410
在这里的时候

49:14.410 --> 49:16.410
我们就判断一下

49:16.410 --> 49:18.410
看一下这个InnitFunk

49:18.410 --> 49:19.410
是不是存在呢

49:19.410 --> 49:21.410
如果存在的话

49:22.410 --> 49:24.410
我们就调用InnitFunk

49:24.410 --> 49:26.410
InitialState

49:26.410 --> 49:28.410
把我们第二个函数的

49:28.410 --> 49:29.410
指传进去

49:29.410 --> 49:30.410
然后把它的反应

49:30.410 --> 49:32.410
回结果作为初始值

49:32.410 --> 49:33.410
否则的话

49:33.410 --> 49:34.410
我们用什么

49:34.410 --> 49:35.410
我们就用

49:36.410 --> 49:38.410
InitialState

49:38.410 --> 49:40.410
判断一下就完了

49:40.410 --> 49:42.410
这个函数很好写的

49:42.410 --> 49:43.410
只不过这个函数

49:43.410 --> 49:44.410
Reducer已经给你写好了

49:44.410 --> 49:45.410
React

49:45.410 --> 49:46.410
已经给你写好了

49:46.410 --> 49:48.410
你自己也不用再写了

49:48.410 --> 49:49.410
当然我们这里

49:50.410 --> 49:52.410
如果说我们这里使用

49:52.410 --> 49:53.410
我们自己写的函数

49:53.410 --> 49:54.410
也是一样的效果

49:54.410 --> 49:56.410
完全一样的效果

49:56.410 --> 49:58.410
这里我们导入

49:58.410 --> 50:00.410
UseReducer

50:03.410 --> 50:04.410
这里是个代码块

50:04.410 --> 50:05.410
这个代码块

50:05.410 --> 50:07.410
它会给你生成这么一个结构

50:07.410 --> 50:08.410
你看 是不是一样的

50:08.410 --> 50:09.410
一样的

50:10.410 --> 50:12.410
UseReducer

50:14.410 --> 50:15.410
Funk

50:15.410 --> 50:16.410
UseReducer

50:16.410 --> 50:17.410
对吧 看一下

50:17.410 --> 50:18.410
结果是完全一样的

50:18.410 --> 50:20.410
我们要这里输出

50:20.410 --> 50:21.410
输出

50:22.410 --> 50:23.410
Argus

50:23.410 --> 50:25.410
保存 你看一下

50:25.410 --> 50:27.410
你看 初始值就是10

50:27.410 --> 50:29.410
初始值最终结果是100

50:29.410 --> 50:31.410
它可以应付一些

50:31.410 --> 50:32.410
复杂计算的场景

50:33.410 --> 50:34.410
其他都没啥了

50:34.410 --> 50:36.410
没啥 真没啥了

50:36.410 --> 50:37.410
真没啥了

50:37.410 --> 50:39.410
这就是UseReducer

50:39.410 --> 50:40.410
现阶段我们可能用不到

50:40.410 --> 50:42.410
以后可能在将来

50:42.410 --> 50:43.410
未来

50:43.410 --> 50:45.410
它可能会结合Reducer

50:45.410 --> 50:46.410
不说替代

50:46.410 --> 50:48.410
可能会结合Reducer来使用

50:48.410 --> 50:49.410
未来

50:49.410 --> 50:51.410
了解一下这一块的知识就行了

50:51.410 --> 50:52.410
你就注意丢事

