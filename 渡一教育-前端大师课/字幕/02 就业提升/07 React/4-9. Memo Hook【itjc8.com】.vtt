WEBVTT

00:01.460 --> 00:05.060
MEMO HOOK

00:05.060 --> 00:08.260
它很简单 几分钟就讲完了

00:08.260 --> 00:10.260
它是用来做什么呢

00:10.260 --> 00:23.860
用于保持那些需要经过复杂的计算

00:23.860 --> 00:27.260
或者说需要经过高开销

00:27.260 --> 00:29.460
就是要计算一个值出来

00:29.460 --> 00:31.420
需要经过很长一段时间

00:32.420 --> 00:36.420
计算会占用计算用的内存和CPU

00:36.420 --> 00:38.420
但是这样的计算出来的结果

00:38.420 --> 00:40.420
又不怎么会变化

00:40.420 --> 00:44.420
就要保持那些需要经过高开销的计算

00:44.420 --> 00:48.420
才能得到的值

00:48.420 --> 00:51.420
好 举个例子吧 什么意思啊

00:52.420 --> 00:55.420
比方说吧

00:55.420 --> 00:57.420
应该这样说

00:58.420 --> 01:05.420
用于保持一些比较稳定的数据

01:05.420 --> 01:08.420
用于保持一些比较稳定的数据

01:08.420 --> 01:10.420
好 举个例子嘛

01:11.420 --> 01:14.420
通常用于性能优化

01:15.420 --> 01:18.420
上节课咱们写这个APP 对吧

01:18.420 --> 01:19.420
还记得吗

01:19.420 --> 01:20.420
咱们写这个APP的时候

01:20.420 --> 01:21.420
我们用了什么

01:21.420 --> 01:22.420
Use callback 对吧

01:22.420 --> 01:23.420
你给它一个函数

01:23.420 --> 01:26.420
它会把这个函数的引用地址保留下来

01:26.420 --> 01:29.420
那么我们现在在这几课接着这个来做

01:29.420 --> 01:31.420
来实现同样一个功能

01:31.420 --> 01:34.420
不过这一次我没有使用Use callback

01:34.420 --> 01:35.420
使用另外一个

01:35.420 --> 01:37.420
也可以达到完全一样的功能

01:37.420 --> 01:39.420
那这两个区别一下就看明白了

01:39.420 --> 01:40.420
就是两个东西

01:40.420 --> 01:42.420
你可以任意选择一个

01:42.420 --> 01:43.420
不过这个Use callback

01:43.420 --> 01:45.420
它只是固定函数

01:45.420 --> 01:46.420
Use memo

01:46.420 --> 01:48.420
它可以固定的场景很多

01:48.420 --> 01:49.420
它可以不仅固定函数

01:49.420 --> 01:51.420
固定任何值都可以

01:51.420 --> 01:53.420
那么这里我们要换一种写法

01:53.420 --> 01:55.420
叫做Use memo

01:56.420 --> 01:58.420
好 看着这个东西怎么来用

01:58.420 --> 02:00.420
这个东西用法跟Use callback一样

02:00.420 --> 02:03.420
只不过Use memo里边

02:03.420 --> 02:06.420
你会需要返回一个值

02:06.420 --> 02:07.420
返回啥呢

02:07.420 --> 02:09.420
一个啥都可以

02:09.420 --> 02:11.420
啥都可以返回

02:11.420 --> 02:13.420
比方说我们这里

02:13.420 --> 02:15.420
return 返回个啥

02:15.420 --> 02:16.420
返回这个东西

02:16.420 --> 02:17.420
所以返回了一个函数

02:17.420 --> 02:18.420
对吧 返回一个函数

02:18.420 --> 02:21.420
那么这样子它会做什么事情呢

02:21.420 --> 02:23.420
它会检查依赖项

02:23.420 --> 02:26.420
第一次使用这个函数的时候

02:26.420 --> 02:28.420
它会立即执行这个函数

02:28.420 --> 02:31.420
把这个函数的返回结果拿到

02:31.420 --> 02:33.420
拿到这个函数的返回结果

02:33.420 --> 02:35.420
那么这个函数的返回结果

02:35.420 --> 02:37.420
是不是这个

02:37.420 --> 02:39.420
把这个结果

02:39.420 --> 02:41.420
直接作为这个函数本身返回

02:41.420 --> 02:43.420
复制给这个辩量

02:43.420 --> 02:44.420
就是第一次运行的时候

02:44.420 --> 02:46.420
它就会运行这个函数

02:46.420 --> 02:49.420
把这个函数的返回结果

02:49.420 --> 02:51.420
作为自己的返回结果

02:51.420 --> 02:53.420
那么这个第一次

02:53.420 --> 02:54.420
调用这个parent的时候

02:54.420 --> 02:55.420
是不是它

02:55.420 --> 02:56.420
就指向了它

02:56.420 --> 02:57.420
对吧

02:57.420 --> 02:59.420
就指向了它

02:59.420 --> 03:00.420
然后后边调用的

03:00.420 --> 03:01.420
它会检查依赖项

03:01.420 --> 03:02.420
有没有发生变化

03:02.420 --> 03:04.420
如果说依赖项

03:04.420 --> 03:05.420
没有发生变化

03:05.420 --> 03:07.420
那么它就不会再调用

03:07.420 --> 03:08.420
你给它传递的函数了

03:08.420 --> 03:09.420
根本就不会调用了

03:09.420 --> 03:11.420
直接使用之前的结果

03:11.420 --> 03:14.420
它跟use callback的区别在哪

03:14.420 --> 03:16.420
就仅仅在于use callback

03:16.420 --> 03:18.420
它传递的就是函数本身

03:18.420 --> 03:20.420
而这个use memo

03:20.420 --> 03:23.420
它不是说我们用那个

03:23.420 --> 03:25.420
不是这个东西

03:25.420 --> 03:26.420
跟这个东西没什么关系

03:26.420 --> 03:27.420
跟这个东西没什么关系

03:27.420 --> 03:30.420
虽然名字好像差不多

03:30.420 --> 03:32.420
那么第二就是

03:32.420 --> 03:34.420
跟那个use callback有什么区别呢

03:34.420 --> 03:36.420
callback它是直接给的函数

03:36.420 --> 03:37.420
那么如果依赖项没有发生变化

03:37.420 --> 03:38.420
它就会直接

03:38.420 --> 03:40.420
把这个函数地址给你返回

03:40.420 --> 03:42.420
而这里它返回的

03:42.420 --> 03:44.420
不是这个函数地址

03:44.420 --> 03:45.420
返回的是什么

03:45.420 --> 03:47.420
返回的是调用这个函数

03:47.420 --> 03:49.420
这个函数的返回结果

03:49.420 --> 03:50.420
它给你固定下来

03:50.420 --> 03:51.420
就这个区别

03:51.420 --> 03:52.420
其他没区别了

03:52.420 --> 03:53.420
那么现在是不是

03:53.420 --> 03:54.420
实现一样的效果了

03:54.420 --> 03:55.420
对吧

03:55.420 --> 03:56.420
你看一下改变文本

03:56.420 --> 03:57.420
没问题

03:57.420 --> 03:58.420
没问题

03:58.420 --> 03:59.420
然后改变这里

03:59.420 --> 04:00.420
是不是只运行了parent

04:00.420 --> 04:01.420
对吧

04:01.420 --> 04:02.420
一样的效果

04:02.420 --> 04:03.420
因为它固定下来了

04:03.420 --> 04:04.420
它一带相没发生变化

04:04.420 --> 04:07.420
就使用之前的得到的结果

04:07.420 --> 04:08.420
那么这个use memo

04:08.420 --> 04:10.420
它的应用场景

04:10.420 --> 04:11.420
比这个use callback

04:11.420 --> 04:12.420
还更多

04:12.420 --> 04:13.420
因为它更加通用

04:13.420 --> 04:14.420
use callback

04:14.420 --> 04:15.420
它只能固定函数

04:15.420 --> 04:16.420
对吧

04:16.420 --> 04:17.420
那这个东西

04:17.420 --> 04:18.420
可以固定任何东西

04:18.420 --> 04:19.420
返回任何东西都可以

04:19.420 --> 04:21.420
它都可以给你固定下来

04:21.420 --> 04:22.420
比方说举个例子

04:23.420 --> 04:25.420
举个什么例子呢

04:26.420 --> 04:27.420
比方说吧

04:28.420 --> 04:29.420
把这个缺掉

04:30.420 --> 04:32.420
我们这个组件里边

04:32.420 --> 04:35.420
有一个特别特别复杂的操作

04:36.420 --> 04:38.420
我们这里使用一个use state

04:38.420 --> 04:39.420
不是复杂吧

04:39.420 --> 04:41.420
可能耗时比较长

04:42.420 --> 04:44.420
这里的对象

04:44.420 --> 04:46.420
我们使用那个

04:47.420 --> 04:49.420
使用一个min

04:49.420 --> 04:51.420
使用一个min

04:54.420 --> 04:55.420
怎么写的

04:55.420 --> 04:56.420
range

04:56.420 --> 04:57.420
一个范围

04:59.420 --> 05:00.420
它是个对象

05:00.420 --> 05:01.420
min的值为1

05:01.420 --> 05:03.420
max的值为10万

05:04.420 --> 05:05.420
10万

05:06.420 --> 05:07.420
写这么一个对象

05:08.420 --> 05:10.420
然后这里边

05:10.420 --> 05:11.420
我们

05:12.420 --> 05:13.420
渲染什么呢

05:13.420 --> 05:17.300
渲染这么一个东西

05:17.300 --> 05:19.300
渲染这个li

05:20.300 --> 05:21.300
我们渲染一个组件

05:21.300 --> 05:22.300
我们这里写个组件

05:22.300 --> 05:23.300
还是写个组件

05:23.300 --> 05:25.300
这个组件叫做

05:26.300 --> 05:27.300
item

05:27.300 --> 05:28.300
item这个组件

05:28.300 --> 05:30.300
这个组件需要一个

05:30.300 --> 05:31.300
数据

05:31.300 --> 05:32.300
需要个属性

05:32.300 --> 05:33.300
返回什么呢

05:33.300 --> 05:35.300
返回这个返回一个li

05:35.300 --> 05:36.300
li里边

05:36.300 --> 05:37.300
probs

05:38.300 --> 05:39.300
probs 点什么

05:39.300 --> 05:40.300
点name

05:42.300 --> 05:44.300
或者说value

05:44.300 --> 05:45.300
把value只告诉我

05:45.300 --> 05:46.300
把value只告诉我

05:46.300 --> 05:47.300
我给你宣传出一个li

05:47.300 --> 05:48.300
好

05:48.300 --> 05:49.300
那么这里我得到什么呢

05:49.300 --> 05:51.300
我得到这么一个东西

05:52.300 --> 05:54.300
得到的是一个

05:56.300 --> 05:57.300
nest

05:57.300 --> 05:59.300
这个 nest 成了来自于哪呢

05:59.300 --> 06:01.300
来自于一个循环

06:01.300 --> 06:03.300
来自于一个循环

06:04.300 --> 06:06.300
我们这里把它做成一个数据

06:06.300 --> 06:07.300
然后进行循环

06:07.300 --> 06:09.300
循环的变量 i

06:09.300 --> 06:11.300
从range.name

06:11.300 --> 06:12.300
开始

06:13.300 --> 06:15.300
然后

06:15.300 --> 06:17.300
i小于

06:17.300 --> 06:20.300
等于range.max

06:20.300 --> 06:22.300
i加加

06:22.300 --> 06:23.300
你知道我要干嘛了对吧

06:23.300 --> 06:25.300
然后每一次循环

06:25.300 --> 06:27.300
往这个链子里面铺系一下

06:27.300 --> 06:28.300
铺系什么呢

06:28.300 --> 06:29.300
铺系一个item

06:30.300 --> 06:32.300
铺系一个item

06:32.300 --> 06:34.300
这个item肯定要给keyz

06:34.300 --> 06:36.300
keyz的话就用i嘛

06:37.300 --> 06:38.300
它的值呢

06:38.300 --> 06:40.300
它的就是

06:40.300 --> 06:43.300
白六值呢就是i

06:43.300 --> 06:44.300
都是i

06:44.300 --> 06:45.300
就得到一个

06:45.300 --> 06:47.300
得到一个组件数组

06:47.300 --> 06:49.300
我们把这个组件数组是不是扔这

06:49.300 --> 06:50.300
对吧 就扔这

06:51.300 --> 06:52.300
没问题吧

06:52.300 --> 06:54.300
但是我们现在不需要一个set range

06:54.300 --> 06:56.300
set range 不需要

06:56.300 --> 06:58.300
保存 你看一下

06:59.300 --> 07:01.300
非常卡

07:01.300 --> 07:03.300
然后等待好久才能渲染出来

07:03.300 --> 07:05.300
不能写10万 这10万太卡了

07:05.300 --> 07:06.300
10万嘛

07:06.300 --> 07:07.300
保存

07:08.300 --> 07:11.300
要渲染好久好久

07:11.300 --> 07:13.300
吃不吃 哎呦

07:13.300 --> 07:15.300
我之前是10万的

07:15.300 --> 07:17.300
现在1万 刷新一下

07:17.300 --> 07:18.300
等一下

07:19.300 --> 07:20.300
稍等一下

07:21.300 --> 07:22.300
range.max1万了

07:22.300 --> 07:24.300
把它变成1万了

07:25.300 --> 07:27.300
你看啊 等好久好久好久

07:29.300 --> 07:31.300
卡封了

07:31.300 --> 07:33.300
这样子 关了

07:33.300 --> 07:34.300
受不了了

07:35.300 --> 07:37.300
关了 去试吧你

07:39.300 --> 07:40.300
卡死了啊

07:40.300 --> 07:42.300
现在它一直在运行

07:43.300 --> 07:44.300
渲染 渲染

07:45.300 --> 07:46.300
1万

07:46.300 --> 07:48.300
1万还稍微好一点

07:48.300 --> 07:50.300
等了半天 终于把这个数据渲染出来了

07:50.300 --> 07:51.300
好 接下来呢

07:51.300 --> 07:53.300
我们做了个简单的操作

07:53.300 --> 07:54.300
比方说

07:54.300 --> 07:57.300
我们下面有一个跟它没什么关系的东西

07:58.300 --> 07:59.300
比方说跟它一个

07:59.300 --> 08:01.300
一个跟它没什么关系的东西

08:01.300 --> 08:02.300
没什么关系的东西呢

08:02.300 --> 08:03.300
就是说

08:03.300 --> 08:04.300
有一个闻闷框吧

08:04.300 --> 08:05.300
咱们又来一个闻闷框

08:05.300 --> 08:06.300
type number

08:07.300 --> 08:08.300
这里呢

08:08.300 --> 08:10.300
我们写上一个

08:10.300 --> 08:11.300
use state

08:12.300 --> 08:13.300
n

08:13.300 --> 08:14.300
0开始

08:15.300 --> 08:16.300
number

08:16.300 --> 08:17.300
我们这里value就为n

08:19.300 --> 08:20.300
然后unchanged

08:20.300 --> 08:21.300
你知道我要干嘛了对吧

08:21.300 --> 08:23.300
因为这个东西一变化

08:23.300 --> 08:24.300
是不是导致它重新渲染

08:24.300 --> 08:26.300
它重新渲染是不是又再重新来一变

08:26.300 --> 08:27.300
要封掉了这个东西

08:28.300 --> 08:30.300
然后我们这里

08:31.300 --> 08:33.300
setn

08:33.300 --> 08:34.300
这里呢

08:34.300 --> 08:35.300
e.

08:35.300 --> 08:37.300
post int

08:37.300 --> 08:38.300
e.

08:38.300 --> 08:39.300
target.value

08:40.300 --> 08:41.300
保存

08:41.300 --> 08:42.300
你看一下

08:43.300 --> 08:44.300
好不容易渲染出来了对吧

08:44.300 --> 08:45.300
好不容易渲染出来了

08:45.300 --> 08:47.300
已经千辛万苦

08:47.300 --> 08:48.300
那么现在闻闷框一变

08:50.300 --> 08:51.300
它又得重新渲染一次

08:51.300 --> 08:52.300
又得重新渲染一次

08:52.300 --> 08:53.300
闻框一变

08:53.300 --> 08:54.300
又得重新渲染一次

08:54.300 --> 08:56.300
当然我们现在看不到这个过程了

08:56.300 --> 08:57.300
看不到这个过程

08:57.300 --> 08:59.300
但是它一定是重新渲染这一变

09:00.300 --> 09:02.300
所以这个效率是非常低的

09:02.300 --> 09:03.300
你说我们闻闷框变化

09:03.300 --> 09:04.300
跟它有啥关系呢

09:04.300 --> 09:06.300
你干嘛去循环这么多次呢

09:06.300 --> 09:07.300
是不是还是循环了这么多次

09:07.300 --> 09:08.300
咱们来输出一下吧

09:09.300 --> 09:10.300
输出i嘛

09:10.300 --> 09:11.300
你看一下吧

09:12.300 --> 09:13.300
它肯定是循环了这么多次啊

09:13.300 --> 09:15.300
那跑不掉啊

09:15.300 --> 09:16.300
循环这么

09:18.300 --> 09:20.300
空彩已经卡死了

09:20.300 --> 09:22.810
空彩啊

09:22.810 --> 09:23.810
出来吧

09:23.810 --> 09:25.810
是不是输出了这么多次

09:25.810 --> 09:26.810
我们把空彩清空

09:26.810 --> 09:27.810
好不容易渲染出来了

09:27.810 --> 09:28.810
我们点击1

09:28.810 --> 09:29.810
你看是不是又来了

09:29.810 --> 09:30.810
又来一次

09:31.810 --> 09:33.810
又是不是把它逼疯

09:33.810 --> 09:34.810
有这个必要吗

09:34.810 --> 09:35.810
是没这个必要

09:35.810 --> 09:38.810
就是有一些非常非常耗时的操作

09:38.810 --> 09:40.810
没有必要反复去做

09:40.810 --> 09:42.810
跟我们这个操作

09:42.810 --> 09:44.810
跟这个耗时的操作有什么关系呢

09:44.810 --> 09:46.810
有了以前在那一组期间里面

09:46.810 --> 09:47.810
都办不到这一点

09:47.810 --> 09:49.810
要办到这一点其实挺麻烦的

09:49.810 --> 09:50.810
那么现在呢

09:50.810 --> 09:52.810
在有了后可之后呢

09:52.810 --> 09:54.810
可以轻松地搞定这一点

09:54.810 --> 09:55.810
是不是可以Use Memo

09:55.810 --> 09:57.810
Use Memo可以固定一下

09:57.810 --> 09:58.810
之前的值

09:58.810 --> 10:00.810
我们使用Use Memo

10:00.810 --> 10:02.810
Use Memo干嘛呢

10:02.810 --> 10:04.810
你传一个函数进去

10:04.810 --> 10:06.810
传一个函数进去

10:06.810 --> 10:07.810
传这个函数进去的

10:07.810 --> 10:09.810
这个函数的返回结果

10:09.810 --> 10:10.810
它会给你固定下来

10:10.810 --> 10:12.810
比方我们就这里

10:12.810 --> 10:14.810
就这个玩意

10:14.810 --> 10:15.810
对吧

10:15.810 --> 10:17.810
我们这是不是做一个很复杂的计算吗

10:17.810 --> 10:19.810
我把这个返回结果

10:19.810 --> 10:20.810
把这个东西返回

10:20.810 --> 10:21.810
列设返回

10:21.810 --> 10:23.810
这里接受一下

10:23.810 --> 10:26.810
现在大家已经有了

10:26.810 --> 10:27.810
应该知道

10:27.810 --> 10:29.810
这个变量跟这个变量是不一样的

10:29.810 --> 10:31.810
这个变量是这个函数里面的局部变量

10:31.810 --> 10:33.810
返回的结果保存在外面的变量里面

10:33.810 --> 10:34.810
虽然和名字一样

10:34.810 --> 10:36.810
但名字不一样也可以

10:36.810 --> 10:37.810
于是呢

10:37.810 --> 10:38.810
这样子呢

10:38.810 --> 10:39.810
来大家来看一下

10:39.810 --> 10:40.810
那么它有没有依赖相呢

10:40.810 --> 10:41.810
它有依赖相

10:41.810 --> 10:42.810
什么依赖相

10:42.810 --> 10:43.810
什么依赖相

10:43.810 --> 10:44.810
它依赖啥

10:44.810 --> 10:46.810
是不是依赖这个Range.me

10:46.810 --> 10:47.810
对吧

10:47.810 --> 10:48.810
依赖这个Range.max

10:48.810 --> 10:49.810
也就是说

10:49.810 --> 10:50.810
这个Range只要没变

10:50.810 --> 10:52.810
是不是我就不需要重新计算

10:52.810 --> 10:53.810
对吧

10:53.810 --> 10:54.810
只要Range没变

10:54.810 --> 10:56.810
我就不需要重新计算

10:56.810 --> 10:57.810
比方说

10:57.810 --> 10:59.810
Range.me

10:59.810 --> 11:01.810
Range.max

11:01.810 --> 11:03.810
这样子写也可以

11:03.810 --> 11:04.810
只要这两个东西没变

11:04.810 --> 11:06.810
那么我就不需要重新计算

11:06.810 --> 11:07.810
对吧

11:08.810 --> 11:09.810
好

11:09.810 --> 11:10.810
接下来我们再来看一下

11:11.810 --> 11:12.810
保存

11:13.810 --> 11:14.810
说说吧

11:14.810 --> 11:15.810
你辛苦一次

11:15.810 --> 11:16.810
确实应该辛苦

11:16.810 --> 11:17.810
没办法

11:17.810 --> 11:18.810
有这么多东西要宣人

11:18.810 --> 11:19.810
终于出来了

11:19.810 --> 11:20.810
好

11:20.810 --> 11:21.810
现在我们改变

11:21.810 --> 11:22.810
轻空

11:22.810 --> 11:23.810
改变这个值

11:23.810 --> 11:24.810
有没有重新计算

11:24.810 --> 11:25.810
有没有重新计算

11:25.810 --> 11:26.810
有没有重新计算

11:26.810 --> 11:27.810
是没有重新计算了

11:27.810 --> 11:28.810
对吧

11:28.810 --> 11:29.810
跟它就没有什么关系了

11:29.810 --> 11:30.810
看到没

11:30.810 --> 11:31.810
明白的意思吧

11:31.810 --> 11:32.810
所以说

11:32.810 --> 11:33.810
这样子有些高开销的计算

11:33.810 --> 11:35.810
我们可以把它放到Use Memo里边

11:35.810 --> 11:37.810
来达到效率优化的目的

11:37.810 --> 11:39.810
它会把它的返回结果记录下来

11:39.810 --> 11:41.810
只要它一代向没发生变化

11:41.810 --> 11:42.810
那么这个返回结果

11:42.810 --> 11:44.810
就不会重新计算

11:44.810 --> 11:45.810
就不会重新计算

11:45.810 --> 11:46.810
这有点像什么

11:46.810 --> 11:47.810
有点像Wheel里边的

11:47.810 --> 11:49.810
那个什么Computed

11:49.810 --> 11:50.810
对吧

11:50.810 --> 11:51.810
Computed也是这样子

11:51.810 --> 11:52.810
只要它的一代向

11:52.810 --> 11:53.810
没有发生变化

11:53.810 --> 11:55.810
那么我就不需要重新计算了

11:55.810 --> 11:56.810
是这么个意思

11:56.810 --> 11:57.810
而且呢

11:57.810 --> 11:58.810
不仅如此

11:58.810 --> 11:59.810
不仅如此

11:59.810 --> 12:00.810
由于呢

12:00.810 --> 12:02.810
我们这个例子

12:02.810 --> 12:03.810
这个集合

12:03.810 --> 12:05.810
就这个玩意集合

12:05.810 --> 12:06.810
由于呢

12:06.810 --> 12:09.810
它跟上次是一样的

12:09.810 --> 12:11.810
因为它有这么一个特点

12:11.810 --> 12:13.810
就是说我们的React元素

12:13.810 --> 12:15.810
它不是通过这个东西创建的吗

12:15.810 --> 12:16.810
对吧

12:16.810 --> 12:19.810
通过React.createElement创建的

12:19.810 --> 12:20.810
React元素

12:20.810 --> 12:22.810
它通过这个创建的

12:22.810 --> 12:23.810
比如说这里有个数组

12:23.810 --> 12:24.810
那数组不是

12:24.810 --> 12:26.810
不也是通过这种方式来创建的吗

12:26.810 --> 12:27.810
对不对

12:27.810 --> 12:28.810
这里是不是一个数组节点

12:28.810 --> 12:29.810
对不对

12:29.810 --> 12:30.810
那如果说

12:30.810 --> 12:32.810
你这个React元素

12:32.810 --> 12:34.810
本身没有发生变化

12:34.810 --> 12:35.810
因为我们每一次

12:35.810 --> 12:37.810
比如说我们把元素写到这儿

12:37.810 --> 12:38.810
写到这个Item写到这儿

12:38.810 --> 12:39.810
那每一次这个组建

12:39.810 --> 12:40.810
这个组建圈展的时候

12:40.810 --> 12:42.810
是不是要得到一个新的元素

12:42.810 --> 12:43.810
它看到这个表达

12:43.810 --> 12:46.810
它就会创建一个新的Element元素

12:46.810 --> 12:48.810
那如果说这个元素

12:48.810 --> 12:50.810
它没有新创建

12:50.810 --> 12:51.810
比方说我们现在创建元素

12:51.810 --> 12:52.810
在哪里创建的

12:52.810 --> 12:53.810
是不是在这里循环里面

12:53.810 --> 12:54.810
创建的元素

12:54.810 --> 12:55.810
对吧

12:55.810 --> 12:56.810
是在这里创建的元素

12:56.810 --> 12:58.810
而由于UseMemo的存在

12:58.810 --> 12:59.810
那么导致了

12:59.810 --> 13:00.810
后续现在只要这个

13:00.810 --> 13:01.810
没有发生变化

13:01.810 --> 13:03.810
它是不是不会重新运行循环

13:03.810 --> 13:04.810
那么这个数组里面

13:04.810 --> 13:06.810
东西是不是之前的东西

13:06.810 --> 13:07.810
也就是说

13:07.810 --> 13:10.810
这个元素本身都没有发生变化

13:10.810 --> 13:12.810
那么这里有一个很重要的点

13:12.810 --> 13:13.810
之前好像没讲到

13:13.810 --> 13:17.810
就是如果元素React

13:17.810 --> 13:20.810
元素本身的引用

13:20.810 --> 13:23.810
没有发生变化

13:23.810 --> 13:28.810
一定不会重新渲染

13:28.810 --> 13:29.810
如果说引用发生了变化

13:29.810 --> 13:32.810
它才会重新去创建节点

13:32.810 --> 13:33.810
由于这个引用本身

13:33.810 --> 13:34.810
都没有发生变化

13:34.810 --> 13:35.810
它就不会重新渲染

13:35.810 --> 13:36.810
这个元素本身

13:36.810 --> 13:37.810
一定不会重新渲染

13:37.810 --> 13:38.810
那比方说我们在这里

13:38.810 --> 13:40.810
输出一个

13:40.810 --> 13:45.810
ItemRender

13:45.810 --> 13:46.810
后边写上一个I

13:46.810 --> 13:48.810
评计一下PropsValue

13:48.810 --> 13:49.810
评计一下这个

13:49.810 --> 13:51.810
我们打印出来看一下

13:51.810 --> 13:53.810
把这个就去掉了

13:53.810 --> 13:54.810
这个去掉了

13:54.810 --> 13:56.810
就说我们现在这样子写

13:56.810 --> 13:57.810
这样子写

13:57.810 --> 13:58.810
我们可以观测到

13:58.810 --> 14:00.810
这个组件渲染得多好吃

14:00.810 --> 14:01.810
我们这里一开始

14:01.810 --> 14:02.810
不是运行那个循环吗

14:02.810 --> 14:03.810
运行了一万次循环

14:03.810 --> 14:04.810
那么每一次循环

14:04.810 --> 14:05.810
是不是创建了一个组件

14:05.810 --> 14:06.810
创建了一个组件

14:06.810 --> 14:07.810
后边渲染的时候

14:07.810 --> 14:08.810
是不是要运行这个组件

14:08.810 --> 14:10.810
对吧 运行这个函数

14:10.810 --> 14:11.810
由于后边

14:11.810 --> 14:12.810
这个组件

14:12.810 --> 14:14.810
它保持的是同一个数组

14:14.810 --> 14:15.810
引用没发生变化

14:15.810 --> 14:16.810
并且数组里面

14:16.810 --> 14:17.810
每一项

14:17.810 --> 14:19.810
它的对象也没有发生任何变化

14:19.810 --> 14:21.810
不像以前总是得到一个新数组

14:21.810 --> 14:22.810
对吧 用Map得到一个新数组

14:22.810 --> 14:24.810
那么这里不是

14:24.810 --> 14:25.810
还是用的是之前的东西

14:25.810 --> 14:26.810
数组是用的是之前的

14:26.810 --> 14:27.810
而且数组里面

14:27.810 --> 14:30.810
每一项用的还是之前的

14:30.810 --> 14:32.810
引用没有发生变化

14:32.810 --> 14:34.810
那么就不会导致它的组件

14:34.810 --> 14:35.810
连组件都不会重新券的

14:35.810 --> 14:36.810
看一下吧

14:36.810 --> 14:38.810
一开始得到一万了

14:38.810 --> 14:40.810
对吧 接下来我们改变这个

14:40.810 --> 14:42.810
是不是组件也没有重新券

14:42.810 --> 14:43.810
为什么

14:43.810 --> 14:45.810
因为我们这个是一个数组

14:45.810 --> 14:47.810
它没有本身没发生变化

14:47.810 --> 14:49.810
数组里面每一项也没有发生变化

14:49.810 --> 14:50.810
对吧

14:50.810 --> 14:52.810
如果说你把这东西写到这儿来了

14:52.810 --> 14:54.810
那是不是要出问题

14:54.810 --> 14:55.810
那这个地方

14:55.810 --> 14:56.810
它肯定会丢一个

14:56.810 --> 14:57.810
肯定会用React

14:57.810 --> 14:59.810
叫CreateElement来创建一个

14:59.810 --> 15:01.810
但是我们之前是把它放到变量里面了

15:01.810 --> 15:02.810
变量里面

15:02.810 --> 15:04.810
它的引用是没有发生变化的

15:04.810 --> 15:06.810
所以说它不会重新宣传

15:06.810 --> 15:08.810
这是UseMemo的好处

15:08.810 --> 15:09.810
那里面

15:09.810 --> 15:11.810
如果你没有用UseMemo

15:11.810 --> 15:12.810
它一定会导致重新宣传

15:12.810 --> 15:14.810
因为你想

15:14.810 --> 15:16.810
如果你没有用UseMemo的话

15:16.810 --> 15:17.810
比方说

15:17.810 --> 15:18.810
你没有用UseMemo

15:18.810 --> 15:19.810
那么每一次运行这个函数

15:19.810 --> 15:21.810
是不是创建一个新的数组

15:21.810 --> 15:22.810
而新的数组里面

15:22.810 --> 15:23.810
是不是又要重新去循环

15:23.810 --> 15:25.810
每次循环是不是要创建一个新的元素

15:25.810 --> 15:26.810
加进去

15:26.810 --> 15:27.810
关键在于这个

15:27.810 --> 15:29.810
创建了一个新的元素

15:29.810 --> 15:30.810
加进去

15:30.810 --> 15:31.810
那么它就认为

15:31.810 --> 15:32.810
这个地方有可能会变

15:32.810 --> 15:33.810
它就会去做对比

15:33.810 --> 15:34.810
对吧

15:34.810 --> 15:35.810
进入生命周期这个流程

15:35.810 --> 15:37.810
我们之前讲了一个渲染流程

15:37.810 --> 15:39.810
会去跟之前的节点做对比

15:39.810 --> 15:40.810
对比过来不一样

15:40.810 --> 15:41.810
又怎么办

15:41.810 --> 15:42.810
但是如果利用的是

15:42.810 --> 15:44.810
同一个react元素

15:44.810 --> 15:45.810
它连对比都不会做

15:45.810 --> 15:46.810
直接放弃掉

15:46.810 --> 15:47.810
不是放弃掉

15:47.810 --> 15:48.810
直接不看后面的

15:48.810 --> 15:50.810
它认为这个一定没变化

15:50.810 --> 15:52.810
什么都不做

15:52.810 --> 15:53.810
所以说这样子

15:53.810 --> 15:55.810
效率会高很多很多

15:55.810 --> 15:57.810
大家注意一下

15:57.810 --> 15:58.810
就是说对一些复杂的操作

15:58.810 --> 16:00.810
或者说根据一些复杂的操作来生成

16:00.810 --> 16:01.810
生成那个

16:01.810 --> 16:03.810
就是特别是生成元素

16:03.810 --> 16:04.810
特别是元素数组的时候

16:04.810 --> 16:05.810
我们用UseMemo

16:05.810 --> 16:08.810
可以极大地提高效率

16:08.810 --> 16:12.570
这是关于这一点

16:13.570 --> 16:14.570
其实它就

16:15.570 --> 16:16.570
我们来看一下

16:16.570 --> 16:17.570
我们来看一下

16:17.570 --> 16:18.570
我们之前不是讲过一个分析工具吗

16:18.570 --> 16:19.570
对不对

16:19.570 --> 16:21.570
我们把这个注射点

16:22.570 --> 16:23.570
保存

16:25.570 --> 16:26.570
之前不是讲过react里面

16:26.570 --> 16:27.570
不是一个分析工具吗

16:27.570 --> 16:28.570
来吧

16:28.570 --> 16:29.570
用一下吧

16:29.570 --> 16:30.570
profiler

16:30.570 --> 16:32.570
点击路子

16:32.570 --> 16:34.570
现在我们点击点击点击点击点击

16:34.570 --> 16:36.570
点击点击点击点击点击

16:38.570 --> 16:39.570
stop

16:42.390 --> 16:43.390
出来了

16:46.390 --> 16:48.830
东西呢

16:48.830 --> 16:49.830
重新来重新来

16:49.830 --> 16:50.830
重新来重新来

16:53.830 --> 16:54.830
重新来

16:54.830 --> 16:55.830
放小一点

16:56.830 --> 16:58.830
profiler 路子

16:59.830 --> 17:02.830
点击点击点击点击

17:03.830 --> 17:04.830
行了

17:04.830 --> 17:05.830
stop

17:06.830 --> 17:07.830
4次

17:07.830 --> 17:08.830
每次渲染

17:09.830 --> 17:10.830
26

17:10.830 --> 17:11.830
8

17:11.830 --> 17:12.830
43

17:12.830 --> 17:14.830
后边只有10.6毫秒

17:14.830 --> 17:15.830
这个的时间

17:15.830 --> 17:17.830
使用了use memo的时候

17:17.830 --> 17:19.830
它的渲染效率

17:19.830 --> 17:20.830
现在

17:20.830 --> 17:21.830
因为它讲到一些调试代码

17:21.830 --> 17:22.830
所以稍微慢一点

17:22.830 --> 17:24.830
而且整个

17:24.830 --> 17:26.830
整个元素非常非常多

17:26.830 --> 17:27.830
有40多毫秒已经不错了

17:27.830 --> 17:28.830
现在

17:28.830 --> 17:29.830
我们

17:29.830 --> 17:30.830
把use memo去掉

17:30.830 --> 17:31.830
你看一下

17:31.830 --> 17:32.830
有多恐怖

17:32.830 --> 17:36.590
把use memo去掉

17:36.590 --> 17:37.590
来吧

17:38.590 --> 17:39.590
还是我们点4次

17:41.590 --> 17:42.590
第一次渲染出来了

17:43.590 --> 17:44.590
profiler

17:44.590 --> 17:45.590
点击字

17:46.590 --> 17:47.590
来

17:47.590 --> 17:48.590
1

17:48.590 --> 17:49.590
2

17:49.590 --> 17:50.590
3

17:51.590 --> 17:52.590
4

17:52.590 --> 17:53.590
停止

17:56.220 --> 17:57.220
停止

17:59.220 --> 18:01.220
它只得到一次结果

18:01.220 --> 18:02.220
我们都按得太快了

18:03.220 --> 18:04.220
第一次渲染还没有结束

18:04.220 --> 18:06.220
它说我又点了第二次了

18:06.220 --> 18:07.220
按得太快了

18:07.220 --> 18:08.220
稍微慢一点

18:08.220 --> 18:09.220
我们再慢一点

18:10.220 --> 18:11.220
点击字

18:12.220 --> 18:13.220
第一次

18:13.220 --> 18:14.220
等一下

18:14.220 --> 18:15.220
稍微等一下

18:16.220 --> 18:17.220
第二次

18:17.220 --> 18:18.220
点两次

18:19.220 --> 18:20.220
第三次

18:20.220 --> 18:22.540
第四次

18:24.980 --> 18:25.980
好 行了

18:25.980 --> 18:26.980
点击停止

18:26.980 --> 18:27.980
你看一下

18:27.980 --> 18:28.980
100多毫秒了

18:28.980 --> 18:29.980
对吧

18:29.980 --> 18:30.980
100多毫秒了

18:30.980 --> 18:31.980
所以说这个效率上

18:31.980 --> 18:33.980
差别还是蛮大的

18:33.980 --> 18:34.980
蛮大的

18:34.980 --> 18:35.980
如果说这里边渲染的内容

18:35.980 --> 18:36.980
还很多

18:36.980 --> 18:37.980
我们现在渲染的很简单

18:37.980 --> 18:38.980
对吧

18:38.980 --> 18:39.980
只有一个文本

18:39.980 --> 18:40.980
那如果里边还有DIV

18:40.980 --> 18:41.980
DIV还套了

18:41.980 --> 18:42.980
实际要是成结构

18:42.980 --> 18:43.980
不要一个新闻列表

18:43.980 --> 18:44.980
那是不是太恐怖了

18:44.980 --> 18:45.980
这个东西

18:45.980 --> 18:46.980
就超级恐怖了

18:46.980 --> 18:48.980
所以说我们一定要用Use Memo来

18:48.980 --> 18:49.980
进行优化一下

18:50.980 --> 18:51.980
其他就没啥了

18:51.980 --> 18:53.980
就这么简单

18:53.980 --> 18:55.980
这是关于Use Memo

18:55.980 --> 18:56.980
Memo Hook

