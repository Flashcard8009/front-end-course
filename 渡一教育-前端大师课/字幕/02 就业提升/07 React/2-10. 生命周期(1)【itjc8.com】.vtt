WEBVTT

00:00.620 --> 00:05.520
咱们来讲一个非常重要的内容

00:05.520 --> 00:08.620
就是 组建的生命周期

00:08.620 --> 00:11.220
你们学习无忧的时候

00:11.220 --> 00:14.620
也肯定学习过无忧组建的生命周期

00:14.620 --> 00:16.420
它什么意思呢

00:16.420 --> 00:18.020
它就说一个组建

00:18.020 --> 00:21.420
它从单生到销毁

00:21.420 --> 00:23.020
会经过一系列的过程

00:23.020 --> 00:24.020
就跟人一样

00:24.020 --> 00:27.820
人一出生到人死亡

00:28.020 --> 00:30.820
整个这几十年上百年的时间

00:30.820 --> 00:34.020
它会经历一系列的事情

00:34.020 --> 00:36.420
那么整个过程就叫做生命周期

00:36.420 --> 00:38.820
从单生到销毁

00:38.820 --> 00:40.820
在这些生命周期里边

00:40.820 --> 00:41.820
在这些过程里边

00:41.820 --> 00:45.020
会不断的去触发一些事情

00:45.020 --> 00:46.420
会发生一些事情

00:46.420 --> 00:49.420
于是Reagt在这个过程中

00:49.420 --> 00:51.620
提供了一系列的勾指函数

00:51.620 --> 00:53.020
什么叫勾指函数呢

00:53.020 --> 00:54.820
这个很丰烧的名字对吧

00:54.820 --> 00:57.720
它就可以把它想象成一个类似于事件

00:57.720 --> 00:59.020
就是一个函数

00:59.020 --> 01:01.020
你只要写了这个函数

01:01.020 --> 01:03.320
那么它会在适当的时候

01:03.320 --> 01:05.020
去调用这个函数

01:05.020 --> 01:07.420
所以说开发者可以在这些函数里边

01:07.420 --> 01:09.120
写入各种各样的代码

01:09.120 --> 01:11.820
这一代码会在适当的时候运行

01:11.820 --> 01:14.220
咱们这节课实际上在研究啥呢

01:14.220 --> 01:16.020
就是在研究这些函数

01:16.020 --> 01:17.820
什么时候我该使用这个函数

01:17.820 --> 01:19.320
什么时候该使用另一个函数

01:19.320 --> 01:21.020
你要非常清楚的知道

01:21.020 --> 01:25.020
这些函数是在什么时候运行的

01:25.020 --> 01:26.820
另外一点大家要知道

01:26.920 --> 01:28.620
就是说生命周期

01:28.620 --> 01:31.520
它仅仅存在于内组件中

01:31.520 --> 01:33.120
咱们的函数组件

01:33.120 --> 01:34.720
它是没有生命周期的

01:34.720 --> 01:36.620
因为函数组件它非常简单

01:36.620 --> 01:38.020
它就是一个函数

01:38.020 --> 01:40.720
每一次运行它调用于是函数就完事了

01:40.720 --> 01:43.220
我们比方说说说个例子

01:43.220 --> 01:44.420
就是一个intX介绍

01:44.420 --> 01:46.220
就随便写一个

01:46.220 --> 01:47.320
随便写一个函数

01:47.320 --> 01:49.320
比方说A这个函数

01:49.320 --> 01:52.720
这些可能可能没有多少实际的例子

01:52.720 --> 01:54.220
可能没有多少实际的例子

01:54.220 --> 01:55.820
但是这些课非常非常的重要

01:55.820 --> 01:59.320
它对你理解整个组件的过程

01:59.320 --> 02:00.520
是至关重要的

02:00.520 --> 02:01.720
学习到这一课之后

02:01.720 --> 02:04.720
咱们对组件的认识就更加深入了

02:04.720 --> 02:07.120
就不是停留在表面了

02:07.120 --> 02:09.220
比方说我们返回一个A起源书

02:09.220 --> 02:11.120
随便写一个

02:11.120 --> 02:13.120
这里我们使用的是函数组件

02:13.120 --> 02:13.820
对吧

02:13.820 --> 02:14.920
函数组件

02:14.920 --> 02:19.120
函数组件是没有生命周期的

02:19.120 --> 02:21.620
我们可以用这种方式来

02:21.620 --> 02:23.720
但是这个东西没法看

02:23.820 --> 02:26.320
我只能给你这么一说

02:26.320 --> 02:27.620
只能给你这么一说

02:27.620 --> 02:28.320
完了

02:28.320 --> 02:28.920
玩毒子了

02:28.920 --> 02:31.720
他又给我爆错了

02:31.720 --> 02:32.720
又给我爆错了

02:32.720 --> 02:33.720
我也不知道这个错误

02:33.720 --> 02:34.520
他怎么来的

02:34.520 --> 02:36.920
把关了重新打开一次

02:36.920 --> 02:38.020
关了重新打开一次

02:38.020 --> 02:39.920
就行了

02:39.920 --> 02:40.220
行了

02:40.220 --> 02:42.120
他又不爆错了

02:42.120 --> 02:43.620
就挺神奇的

02:43.620 --> 02:44.720
行了

02:44.720 --> 02:46.820
咱们这里看每隔一秒钟

02:46.820 --> 02:48.220
是不是重新渲染

02:48.220 --> 02:48.820
对吧

02:48.820 --> 02:50.420
重新渲染它会怎么回事呢

02:50.420 --> 02:52.120
它是一个函数

02:52.120 --> 02:54.520
那么每一次重新渲染的时候

02:54.520 --> 02:56.220
它就会做这么一件事

02:56.220 --> 02:59.020
之前函数组件就直接扔掉了

02:59.020 --> 03:00.120
就直接不要了

03:00.120 --> 03:03.720
重新调用函数来得到新的东西

03:03.720 --> 03:05.720
函数组件就这么简单

03:05.720 --> 03:07.720
它重新调用函数得到新的东西

03:07.720 --> 03:09.120
所以说函数组件

03:09.120 --> 03:10.720
它的生命周期

03:10.720 --> 03:11.520
它有没有生命周期

03:11.520 --> 03:12.720
实际上它也有

03:12.720 --> 03:15.220
只不过它非常短

03:15.220 --> 03:16.720
不在我们的考虑范围之列

03:16.720 --> 03:17.720
它只有两个阶段

03:17.720 --> 03:18.520
一个是出生

03:18.520 --> 03:19.820
一个是消亡

03:19.820 --> 03:20.720
什么时候出生

03:20.720 --> 03:21.620
就是你在渲染的时候

03:21.620 --> 03:22.920
用了函数组件

03:22.920 --> 03:24.920
那么它就掉用了一次函数

03:24.920 --> 03:26.320
它就出生了

03:26.320 --> 03:27.620
把它刮载到了

03:27.620 --> 03:30.620
刮载到了就是整个虚拟动物树里边

03:30.620 --> 03:32.520
咱们后边的后期会学习

03:32.520 --> 03:35.320
就是虚拟动物树

03:35.320 --> 03:36.920
然后下一次再调用函数

03:36.920 --> 03:38.020
它就把之前那个东西

03:38.020 --> 03:39.120
就直接扔掉了

03:39.120 --> 03:42.020
又重新调用一次新的函数

03:42.020 --> 03:42.820
就这么回事

03:42.820 --> 03:44.620
所以说它只有两个阶段

03:44.620 --> 03:46.220
就是出生和失望

03:46.220 --> 03:47.920
它中间没有任何过程了

03:47.920 --> 03:50.220
所以我们这里研究的生命周期

03:50.320 --> 03:52.520
都是指的是内组件

03:52.520 --> 03:54.020
实际上函数这一块

03:54.020 --> 03:55.620
它也有生命周期

03:55.620 --> 03:56.920
说实话也有

03:56.920 --> 03:59.020
因为就是我们之前提到过的

03:59.020 --> 04:02.420
就是后边我们会学习一个hooks

04:02.420 --> 04:03.420
有了这个东西过后

04:03.420 --> 04:05.420
我们就可以在函数里边

04:05.420 --> 04:07.320
去应用一些生命周期了

04:07.320 --> 04:08.620
但是目前的

04:08.620 --> 04:09.220
不行

04:09.220 --> 04:10.020
目前函数

04:10.020 --> 04:10.920
我们就可以认为它

04:10.920 --> 04:12.920
没有任何生命周期

04:12.920 --> 04:14.520
所以说我们这里函数组件

04:14.520 --> 04:19.120
不在我们的讨论范围之列

04:19.120 --> 04:22.320
我们主要说的是内组件

04:22.320 --> 04:23.420
然后这边

04:23.420 --> 04:25.620
我们先把这个东西认识清楚

04:25.620 --> 04:28.220
然后再认识清楚一个东西

04:28.220 --> 04:32.020
就是说我们生命周期研究的是谁

04:32.020 --> 04:33.020
研究的是谁呢

04:33.020 --> 04:35.520
比方说咱们这里写个内组件

04:35.520 --> 04:38.920
class 写这么一个内组件

04:38.920 --> 04:41.720
咱们的生命周期研究的是啥呢

04:41.720 --> 04:44.520
研究的是这个内组件

04:44.520 --> 04:45.820
就这个东西

04:45.820 --> 04:48.220
我们这样子

04:49.220 --> 04:56.100
比方说这里有三个内组件

04:58.100 --> 05:00.100
这是一个

05:00.100 --> 05:01.100
两个

05:01.100 --> 05:02.100
三个

05:02.100 --> 05:03.100
我们研究的是啥呢

05:03.100 --> 05:05.100
是每一个组件

05:05.100 --> 05:06.100
它的生命周期

05:06.100 --> 05:07.600
它会经过哪些过程

05:07.600 --> 05:09.600
它从诞生到销毁

05:09.600 --> 05:10.600
从出生到死亡

05:10.600 --> 05:12.100
会经过哪些阶段

05:12.100 --> 05:14.100
我们研究的是这么个东西

05:14.100 --> 05:16.100
而不是说内本身

05:16.100 --> 05:17.100
我们是说内的对象

05:17.100 --> 05:18.100
你可以认为

05:18.100 --> 05:20.100
这里使用的内组件

05:20.100 --> 05:22.100
那么就相当于是溜了一个

05:22.100 --> 05:24.100
你可以认为这里

05:24.100 --> 05:26.100
就相当于是溜了一个

05:26.100 --> 05:28.100
溜了一个爱的对象

05:28.100 --> 05:30.100
我们研究的是这个对象的生命周期

05:30.100 --> 05:32.100
我们研究的是这个玩意

05:32.100 --> 05:34.100
而不是这个内本身

05:34.100 --> 05:35.100
明白的意思吧

05:35.100 --> 05:37.100
我们研究的是这个内的对象

05:37.100 --> 05:38.100
一个对象

05:38.100 --> 05:40.100
它就有一个独立的生命周期

05:40.100 --> 05:42.100
每一个就是这些不同的组件

05:42.100 --> 05:44.100
他们的生命周期

05:44.100 --> 05:46.100
互不干擾

05:46.100 --> 05:48.100
虽然说他们是同一个组件

05:48.100 --> 05:50.100
但是由于他们是不同的

05:50.100 --> 05:52.100
组件实力

05:52.100 --> 05:54.100
这是一个组件实力

05:54.100 --> 05:56.100
组件实力

05:56.100 --> 05:58.100
就相当于是内的对象

05:58.100 --> 06:00.100
这也是个组件实力

06:00.100 --> 06:02.100
所以说他们之间的生命周期

06:02.100 --> 06:03.100
互不干擾

06:03.100 --> 06:05.100
他们各自有各自的生命周期

06:05.100 --> 06:06.100
我们研究的是单个

06:06.100 --> 06:08.100
组件对象的生命周期

06:08.100 --> 06:09.100
是这么回事

06:09.100 --> 06:11.100
咱们想要把我们研究的对象

06:11.100 --> 06:12.100
搞清楚

06:12.100 --> 06:14.100
这个东西都是模糊的

06:14.100 --> 06:15.100
那还需要什么生命周期呢

06:15.100 --> 06:17.100
我们先把这个东西认识清楚

06:17.100 --> 06:19.100
当然我们以后讲解的时候

06:19.100 --> 06:20.100
可能不会写这么多

06:20.100 --> 06:21.100
只会写一个

06:21.100 --> 06:22.100
你把一个认识清楚了

06:22.100 --> 06:24.100
其他是一样的

06:24.100 --> 06:25.100
他们生命周期是相互独立的

06:25.100 --> 06:27.100
互不干擾

06:27.100 --> 06:29.100
明白这个意思吧

06:29.100 --> 06:31.100
接下来我们再来看

06:31.100 --> 06:33.100
具体的生命周期

06:33.100 --> 06:35.100
第一个是纠板的生命周期

06:35.100 --> 06:36.100
什么呢

06:36.100 --> 06:38.100
就是rex的目前的版本

06:38.100 --> 06:40.100
就是我目前的课程里面的版本

06:40.100 --> 06:43.100
它是16.8.6

06:43.100 --> 06:44.100
我看一下吧

06:44.100 --> 06:46.100
拍给点节省

06:46.100 --> 06:47.100
16.8.6

06:47.100 --> 06:49.100
它是这么一个版本

06:49.100 --> 06:51.100
我们研究的纠板生命周期是什么呢

06:51.100 --> 06:56.100
是16.0.0之前的生命周期

06:56.100 --> 06:58.100
它的版本是小于这个时候

06:58.100 --> 06:59.100
它的生命周期

06:59.100 --> 07:00.100
我们研究的是这个

07:00.100 --> 07:02.100
新版的生命周期

07:02.100 --> 07:04.100
就是rex大于等于

07:04.100 --> 07:07.100
大于等于16.0.0

07:07.100 --> 07:10.100
我们这是新版的生命周期

07:10.100 --> 07:13.100
纠板的生命周期到目前还能用

07:13.100 --> 07:15.100
尽管rex官方

07:15.100 --> 07:17.100
它已经不再提倡你使用了

07:17.100 --> 07:18.100
因为它里面会

07:18.100 --> 07:19.100
它遇到了一些坑

07:19.100 --> 07:21.100
不是很好解决

07:21.100 --> 07:23.100
以前遗留的一些bug

07:23.100 --> 07:24.100
不是很好解决

07:24.100 --> 07:25.100
也不算bug吧

07:25.100 --> 07:26.100
它实在是不好处理

07:26.100 --> 07:28.100
所以说它提出了新版的生命周期

07:28.100 --> 07:30.100
两个生命周期我们都得学习

07:30.100 --> 07:31.100
因为保不齐

07:31.100 --> 07:32.100
你以后到公司里面

07:32.100 --> 07:34.100
可能用的是以前

07:34.100 --> 07:36.100
用rex开发的程序

07:36.100 --> 07:38.100
所以说你纠板生命周期也得了解

07:38.100 --> 07:39.100
新版的生命周期更不要说了

07:39.100 --> 07:41.100
肯定要了解

07:41.100 --> 07:42.100
而且这两个生命周期

07:42.100 --> 07:45.100
它们的差异性并没有太大

07:45.100 --> 07:47.100
有一些差异性并没有太大

07:47.100 --> 07:49.100
所以了解是旧版生命周期

07:49.100 --> 07:50.100
也不是说学了旧版过后

07:50.100 --> 07:52.100
新版的就完全两码事了

07:52.100 --> 07:53.100
也不是这样子

07:53.100 --> 07:55.100
差异也不会很大

07:55.100 --> 07:57.100
好 咱们现在说旧版

07:57.100 --> 07:59.100
旧版里边我们写了一个ppt

07:59.100 --> 08:00.100
我这里写一个ppt

08:00.100 --> 08:02.100
我们用ppt来讲

08:08.370 --> 08:12.370
我这里直接把这个运行出来吧

08:12.370 --> 08:13.370
这个地方

08:13.370 --> 08:15.370
这个文字里面看不见了

08:15.370 --> 08:17.370
看不见了

08:17.370 --> 08:19.370
我写到这吧

08:19.370 --> 08:20.370
这样子

08:20.370 --> 08:22.370
现在应该能看完了

08:23.370 --> 08:24.370
好多

08:24.370 --> 08:25.370
好多东西

08:25.370 --> 08:26.370
没关系

08:26.370 --> 08:28.370
咱们一部分一部分看

08:28.370 --> 08:30.370
首先是初始化阶段

08:30.370 --> 08:31.370
一个组建的

08:31.370 --> 08:33.370
它首先要出生

08:33.370 --> 08:34.370
一个内组建的

08:34.370 --> 08:35.370
它出生是干嘛呢

08:35.370 --> 08:37.370
是不是雕用构造寒朔

08:37.370 --> 08:38.370
所以说初始化阶段

08:38.370 --> 08:40.370
它就是初始化属性

08:40.370 --> 08:41.370
初始化状态

08:41.370 --> 08:42.370
做这些事情的

08:42.370 --> 08:43.370
那么这个时候

08:43.370 --> 08:46.370
它有一个相应的寒朔就是constructor

08:46.370 --> 08:48.370
就是内的构造寒朔

08:48.370 --> 08:49.370
所以说最先运行的

08:49.370 --> 08:50.370
就是内的构造寒朔

08:50.370 --> 08:51.370
注意

08:51.370 --> 08:53.370
一个组建的初始化阶段

08:53.370 --> 08:55.370
它只会运行一次

08:55.370 --> 08:57.370
就是构造寒朔只会运行一次

08:57.370 --> 08:58.370
那举个例子吧

08:58.370 --> 08:59.370
我们这里

08:59.370 --> 09:01.370
新建个文件

09:01.370 --> 09:03.370
就是旧版生命周期

09:03.370 --> 09:08.370
old life cycle

09:08.370 --> 09:09.370
cicle

09:09.370 --> 09:10.370
j

09:10.370 --> 09:11.370
这里我们写个内组建

09:11.370 --> 09:13.370
反正全是研究的内组建

09:13.370 --> 09:15.370
寒朔组建不在我们考虑范围之列

09:15.370 --> 09:20.370
这里我们写上一个constructor

09:20.370 --> 09:22.370
probs

09:22.370 --> 09:24.370
super

09:24.370 --> 09:25.370
probs

09:25.370 --> 09:27.370
然后我们这里就输出

09:27.370 --> 09:28.370
this state

09:28.370 --> 09:30.370
给它初始化一个东西吧

09:30.370 --> 09:31.370
随便

09:31.370 --> 09:32.370
n等于0

09:32.370 --> 09:33.370
就随便

09:33.370 --> 09:35.370
然后我们这里输出一个

09:35.370 --> 09:37.370
一个新的组建

09:37.370 --> 09:40.370
诞生了

09:41.370 --> 09:43.370
我们看一下这个构造寒朔

09:43.370 --> 09:44.370
它会运行多少次

09:44.370 --> 09:46.370
这里我们再建一个文件

09:46.370 --> 09:50.370
叫做app.js

09:50.370 --> 09:52.370
这个组建的作用就是

09:52.370 --> 09:54.370
应用old life cycle

09:54.370 --> 09:55.370
应用这个组建

09:55.370 --> 09:57.370
我们还是写个内组建

09:58.370 --> 09:59.370
然后这个组建里面

09:59.370 --> 10:01.370
我们去用一下

10:01.370 --> 10:07.370
old life cycle

10:07.370 --> 10:09.370
probs

10:10.370 --> 10:12.370
用一下这个组建

10:12.370 --> 10:16.700
这里的old life cycle

10:16.700 --> 10:18.700
DIV里面还是写的东西吧

10:18.700 --> 10:20.700
不然咱都看不见

10:20.700 --> 10:24.700
这是旧版生命周期组建

10:24.700 --> 10:25.700
新版里面

10:25.700 --> 10:26.700
目前我是新版

10:26.700 --> 10:28.700
但是还是可以用

10:28.700 --> 10:30.700
还有啥呢

10:30.700 --> 10:31.700
这样吧

10:31.700 --> 10:32.700
这样

10:32.700 --> 10:33.700
我们在这里

10:33.700 --> 10:34.700
constructor里面

10:34.700 --> 10:36.700
设置一个计时器

10:36.700 --> 10:38.700
或者说我们这里设置个按钮

10:43.700 --> 10:44.700
这是啥按钮了

10:44.700 --> 10:45.700
就会把生命周期组建

10:45.700 --> 10:46.700
我们这样吧

10:46.700 --> 10:48.700
这里要显示一些属性

10:48.700 --> 10:49.700
显示些属性

10:49.700 --> 10:52.700
属性n

10:52.700 --> 10:54.700
比方说属性n

10:54.700 --> 10:55.700
来自于哪呢

10:55.700 --> 10:57.700
来自于js props.n

10:57.700 --> 10:59.700
然后状态

10:59.700 --> 11:01.700
状态n

11:01.700 --> 11:03.700
来自于哪呢

11:03.700 --> 11:06.700
来自于js state.n

11:06.700 --> 11:08.700
不要说属性里面

11:08.700 --> 11:09.700
它也会传一个n过来

11:09.700 --> 11:11.700
状态里面它本身也有一个n

11:11.700 --> 11:13.700
我们都把它打印出来

11:13.700 --> 11:15.700
这里面我们就写一个状态

11:15.700 --> 11:17.700
状态

11:17.700 --> 11:19.700
lumber

11:19.700 --> 11:21.700
从1开始

11:23.700 --> 11:27.700
然后我们这里把lumber传过去

11:27.700 --> 11:29.700
会不会写得太复杂了

11:29.700 --> 11:30.700
应该不会吧

11:30.700 --> 11:31.700
这个应该很简单吧

11:31.700 --> 11:33.700
n传过去

11:33.700 --> 11:35.700
把js state里面lumber传过去

11:35.700 --> 11:36.700
这个很简单吧

11:36.700 --> 11:37.700
把我们的状态里面传过去

11:37.700 --> 11:39.700
作为属性传过去

11:39.700 --> 11:41.700
下面有个按钮

11:41.700 --> 11:43.700
n加1

11:43.700 --> 11:45.700
这是这个app主件的

11:45.700 --> 11:47.700
这不是我们研究的对象

11:47.700 --> 11:49.700
我们研究的对象是这个

11:51.700 --> 11:52.700
然后n加1

11:52.700 --> 11:57.020
咱们给它做这个事件

11:57.020 --> 11:59.020
主要观察啥呢

11:59.020 --> 12:00.020
主要观察一下

12:00.020 --> 12:01.020
构造函数

12:01.020 --> 12:03.020
它会不会反复运行

12:03.020 --> 12:04.020
主要是观察这个

12:04.020 --> 12:05.020
js state

12:05.020 --> 12:06.020
我这里为了简单

12:06.020 --> 12:08.020
就直接这样写了

12:08.020 --> 12:09.020
lumber

12:09.020 --> 12:10.020
为什么呢

12:10.020 --> 12:12.020
js state

12:12.020 --> 12:13.020
lumber加1

12:13.020 --> 12:14.020
别人可能说

12:14.020 --> 12:15.020
上节课不是说了吗

12:15.020 --> 12:16.020
你要用之前的状态的字

12:16.020 --> 12:18.020
你应该写成函数

12:18.020 --> 12:19.020
那行吧

12:19.020 --> 12:20.020
那我就写成函数吧

12:20.020 --> 12:21.020
因为这里我觉得没

12:21.020 --> 12:22.020
无所谓

12:22.020 --> 12:23.020
因为我只调用了一次

12:23.020 --> 12:24.020
sets state

12:24.020 --> 12:25.020
它不会导致问题

12:25.020 --> 12:26.020
那行吧

12:26.020 --> 12:28.020
写成函数

12:28.020 --> 12:29.020
写成函数

12:29.020 --> 12:32.460
反回一个新的对象

12:32.460 --> 12:33.460
那这里使用

12:33.460 --> 12:34.460
state

12:34.460 --> 12:36.460
lumber加1

12:36.460 --> 12:37.460
行了

12:37.460 --> 12:38.460
我们这里

12:38.460 --> 12:39.460
这个设里面就用

12:39.460 --> 12:44.300
就使用这个app

12:44.300 --> 12:45.300
使用这个什么

12:53.300 --> 12:54.300
OK

12:54.300 --> 12:56.300
我们这里就直接使用app

12:56.300 --> 12:57.300
行了

12:57.300 --> 12:58.300
我们来看一下

12:59.300 --> 13:00.300
cd

13:00.300 --> 13:01.300
react

13:01.300 --> 13:02.300
nur

13:02.300 --> 13:03.300
dea

13:03.300 --> 13:04.300
star

13:04.300 --> 13:05.300
好

13:05.300 --> 13:06.300
让它运行吧

13:06.300 --> 13:07.300
我喝口水

13:07.300 --> 13:09.300
再看一下这个app

13:09.300 --> 13:12.060
再看一下这个

13:12.060 --> 13:13.060
看一下我们一个状态

13:13.060 --> 13:15.060
来把这个状态作为属性传过去

13:15.060 --> 13:17.060
然后每次点击了更新状态

13:17.060 --> 13:18.060
我们主要是看一下

13:18.060 --> 13:19.060
因为我们这里的

13:19.060 --> 13:20.060
dea用了set state

13:20.060 --> 13:21.060
对吧

13:21.060 --> 13:22.060
dea用了这个

13:22.060 --> 13:23.060
是不是会导致重新刷新

13:23.060 --> 13:24.060
对吧

13:24.060 --> 13:25.060
重新渲染

13:25.060 --> 13:26.060
而重新渲染的时候

13:26.060 --> 13:28.060
关键点看一下

13:28.060 --> 13:30.060
它会不会重新创建一个

13:30.060 --> 13:32.060
这个组建

13:32.060 --> 13:33.060
这个组建对象

13:33.060 --> 13:34.060
会不会重新创建

13:35.060 --> 13:36.060
我们之前说

13:36.060 --> 13:37.060
每一次运行都是重新创建

13:37.060 --> 13:38.060
对吧

13:38.060 --> 13:39.060
重新来

13:39.060 --> 13:40.060
但是对于那一组建而言

13:40.060 --> 13:41.060
它的组建对象

13:41.060 --> 13:42.060
我们看一下

13:42.060 --> 13:43.060
它到底会不会重新创建

13:43.060 --> 13:44.060
右键检查

13:44.060 --> 13:45.060
看一下

13:45.060 --> 13:46.060
抗射

13:46.060 --> 13:47.060
我们看

13:47.060 --> 13:48.060
一开始肯定是

13:48.060 --> 13:49.060
创建了一个新的组建

13:49.060 --> 13:50.060
对吧

13:50.060 --> 13:51.060
然后我们N加1

13:52.060 --> 13:53.060
你看一下

13:53.060 --> 13:55.060
右边有没有运行

13:55.060 --> 13:56.060
有没有运行够多寒朔

13:56.060 --> 13:57.060
有没有

13:57.060 --> 13:58.060
是没有运行

13:58.060 --> 13:59.060
对吧

13:59.060 --> 14:00.060
说明啥

14:00.060 --> 14:01.060
说明这个组建

14:01.060 --> 14:02.060
仍然使用的是

14:02.060 --> 14:03.060
同一个对象

14:03.060 --> 14:04.060
它是为了效率

14:04.060 --> 14:05.060
它不像寒朔一样

14:05.060 --> 14:06.060
寒朔的时候

14:06.060 --> 14:07.060
重新调整一次

14:07.060 --> 14:08.060
不完了

14:08.060 --> 14:09.060
对吧

14:09.060 --> 14:10.060
但是内对象的话

14:10.060 --> 14:12.060
你每次去创建一个新的对象的话

14:12.060 --> 14:13.060
确实有点浪费内存空间

14:13.060 --> 14:14.060
所以说

14:14.060 --> 14:16.060
它就没有去重新创建对象了

14:16.060 --> 14:17.060
而是用什么呢

14:17.060 --> 14:18.060
而是

14:18.060 --> 14:20.060
就用原来的对象

14:20.060 --> 14:22.060
只是改变了它的属性而已

14:22.060 --> 14:23.060
所以说

14:23.060 --> 14:24.060
我们这一块看到的

14:24.060 --> 14:25.060
就版生命周期里边

14:25.060 --> 14:26.060
当然新版也是一样

14:26.060 --> 14:27.060
这一块是一样的

14:27.060 --> 14:29.060
就是构造寒朔

14:30.060 --> 14:32.060
构造寒朔这一块

14:32.060 --> 14:33.060
它只会运行一次

14:33.060 --> 14:35.060
咱们挨着来嫉妒

14:36.060 --> 14:37.060
构造寒朔里面

14:37.060 --> 14:38.060
只会运行一次

14:41.060 --> 14:42.060
记在这

14:42.060 --> 14:43.060
一个个来

14:43.060 --> 14:44.060
第一个就是

14:44.060 --> 14:45.060
Constructor

14:46.060 --> 14:49.060
构造寒朔除非

14:49.060 --> 14:50.060
组建

14:51.060 --> 14:52.060
被销毁

14:52.060 --> 14:53.060
除非组建被销毁

14:53.060 --> 14:54.060
被销毁过后

14:54.060 --> 14:56.060
下一次肯定是重新创建了

14:56.060 --> 14:58.060
肯定是重新创建组建了

14:58.060 --> 15:00.060
那就是另一个组建的生命周期了

15:00.060 --> 15:01.060
跟这个组建就没关系了

15:02.060 --> 15:03.060
可以这样说吧

15:03.060 --> 15:05.060
同一个组建

15:05.060 --> 15:07.060
同一个组建对象

15:07.060 --> 15:09.060
只会

15:09.060 --> 15:10.060
创建一次

15:10.060 --> 15:11.060
只会创建一次

15:11.060 --> 15:13.060
它不会反复创建

15:13.060 --> 15:14.060
所以说Constructor

15:14.060 --> 15:15.060
对于一个生命周期而言

15:15.060 --> 15:17.060
它只会运行一次

15:18.060 --> 15:19.060
这是第一个

15:19.060 --> 15:20.060
Constructor

15:20.060 --> 15:21.060
要注意的

15:21.060 --> 15:22.060
第一个点

15:24.060 --> 15:25.060
然后Constructor

15:25.060 --> 15:26.060
里面还要注意一些点

15:26.060 --> 15:27.060
什么呢

15:27.060 --> 15:28.060
就是说

15:28.060 --> 15:30.060
如果你在Constructor里面

15:30.060 --> 15:31.060
去使用了什么

15:33.060 --> 15:34.060
去使用了这个东西

15:34.060 --> 15:35.060
看一下会

15:35.060 --> 15:36.060
产生什么样的问题

15:37.060 --> 15:38.060
比方说把它设置为3

15:39.060 --> 15:40.060
假设

15:41.060 --> 15:42.060
我们来看一下吧

15:42.060 --> 15:43.060
它是爆错了

15:44.060 --> 15:45.060
你看状态有没有改变

15:45.060 --> 15:46.060
是不是没有改变

15:46.060 --> 15:47.060
它说什么

15:47.060 --> 15:48.060
它说不能

15:48.060 --> 15:49.060
调用

15:54.060 --> 15:55.060
它说不能在一个

15:56.060 --> 15:57.060
不能在

15:58.060 --> 15:59.060
组建

15:59.060 --> 16:00.060
挂载之前

16:00.060 --> 16:02.060
我们现在还没有想挂载

16:02.060 --> 16:03.060
什么叫挂载

16:03.060 --> 16:04.060
挂载的意思就是

16:04.060 --> 16:05.060
把这个组建

16:05.060 --> 16:06.060
组建不是个对象吗

16:06.060 --> 16:07.060
对吧

16:07.060 --> 16:08.060
把这个对象

16:08.060 --> 16:10.060
变成一个真实的动物元素

16:10.060 --> 16:11.060
挂载到页面上

16:11.060 --> 16:12.060
它是这么个意思

16:13.060 --> 16:14.060
在组建

16:14.060 --> 16:16.060
真实的挂载到页面上

16:16.060 --> 16:17.060
之前

16:17.060 --> 16:19.060
你是不能使用setState

16:20.060 --> 16:21.060
你是不能使用setState的

16:21.060 --> 16:22.060
所以说

16:22.060 --> 16:24.060
你在勾造函数里边

16:24.060 --> 16:25.060
是不可能

16:26.060 --> 16:27.060
调用setState的

16:28.060 --> 16:29.060
有同学就开始问了

16:30.060 --> 16:31.060
为什么

16:31.060 --> 16:32.060
以前我不是写的

16:32.060 --> 16:33.060
这么个玩意

16:34.060 --> 16:36.060
这个玩意不就是调用setState吗

16:38.060 --> 16:39.060
一秒钟过后

16:39.060 --> 16:40.060
每一秒钟是不是我们以前

16:40.060 --> 16:41.060
这样子写的

16:41.060 --> 16:43.060
setState 调用的

16:43.060 --> 16:45.060
那是因为我们这里是一步的

16:45.060 --> 16:47.060
是一秒钟之后再去调用的

16:47.060 --> 16:48.060
而一秒钟之后

16:48.060 --> 16:50.060
是不是组建已经挂载了

16:50.060 --> 16:51.060
已经显示到页面上了

16:51.060 --> 16:52.060
对吧

16:52.060 --> 16:53.060
可能

16:53.060 --> 16:54.060
不到一一秒钟

16:54.060 --> 16:56.060
可能就是实际豪妙

16:56.060 --> 16:57.060
实弹豪妙

16:57.060 --> 16:59.060
那么这个组建就已经挂载到页面上了

16:59.060 --> 17:01.060
就变成真实的动物元素了

17:01.060 --> 17:02.060
所以说这个时候

17:02.060 --> 17:04.060
再去调用setState是可以的

17:04.060 --> 17:06.060
它主要是为了要求你就是什么

17:06.060 --> 17:08.060
这个组建都还没有挂载到页面上

17:08.060 --> 17:11.060
你就不要不能去调用setState

17:11.060 --> 17:13.060
不能去调用这个玩意

17:14.060 --> 17:15.060
为什么呢

17:15.060 --> 17:17.060
它为什么有这样的要求呢

17:17.060 --> 17:18.060
是因为我们之前说过

17:18.060 --> 17:20.060
这个setState这个函数

17:20.060 --> 17:23.060
它是会导致重新渲染的

17:23.060 --> 17:24.060
但是现在组建

17:24.060 --> 17:26.060
第一次都还没有渲染完成

17:26.060 --> 17:28.060
第一次还要做很多很多的事情

17:28.060 --> 17:30.060
都还没有做完

17:30.060 --> 17:33.060
你这个时候重新渲染是渲染不成功的

17:33.060 --> 17:35.060
它是跟它的内部实现原理有关系

17:35.060 --> 17:36.060
总之呢

17:36.060 --> 17:38.060
你说你记住一句话

17:39.060 --> 17:41.060
不能

17:41.060 --> 17:42.060
不能什么

17:42.060 --> 17:43.060
在

17:43.060 --> 17:46.060
不能再渲染

17:46.060 --> 17:48.060
就是

17:48.060 --> 17:53.060
第一次挂载到页面之前

17:53.060 --> 17:54.060
挂载到页面之前

17:54.060 --> 17:57.060
调用setState

17:57.060 --> 17:58.060
所以说呢

17:58.060 --> 17:59.060
构造函数

17:59.060 --> 18:00.060
由于是太早了

18:00.060 --> 18:02.060
这个生命周期太早了

18:02.060 --> 18:04.060
在初始化的第一个阶段

18:04.060 --> 18:05.060
最开始的时候

18:05.060 --> 18:06.060
初始化只有一个阶段

18:06.060 --> 18:08.060
就在初始化阶段调用的

18:08.060 --> 18:09.060
所以说呢

18:09.060 --> 18:11.060
它是不能调用setState的

18:11.060 --> 18:12.060
这就是为什么

18:12.060 --> 18:13.060
我们之前做了个练习

18:13.060 --> 18:15.060
就是做了个分业那个地方

18:15.060 --> 18:16.060
第一次

18:16.060 --> 18:17.060
咱们看不见那个夹载中

18:17.060 --> 18:18.060
对吧

18:18.060 --> 18:19.060
那就是因为

18:19.060 --> 18:20.060
我们当时呢

18:20.060 --> 18:21.060
当时在构造函数里边

18:21.060 --> 18:22.060
调用了一个函数

18:22.060 --> 18:24.060
那个函数一开始就调用了setState

18:24.060 --> 18:25.060
所以说它爆错了

18:25.060 --> 18:27.060
它不允许你这样做

18:27.060 --> 18:28.060
明白的意思吧

18:28.060 --> 18:30.060
所以说构造函数里边

18:30.060 --> 18:32.060
为了避免出问题

18:32.060 --> 18:34.060
为了避免出问题

18:34.060 --> 18:37.060
为了避免问题

18:37.060 --> 18:39.060
构造函数中

18:39.060 --> 18:44.060
严禁使用setState

18:44.060 --> 18:46.060
你可以初始化状态

18:46.060 --> 18:47.060
那么没问题

18:47.060 --> 18:48.060
这个没问题

18:48.060 --> 18:49.060
初始化状态没问题

18:49.060 --> 18:51.060
它本来就是在构造函数里边

18:51.060 --> 18:52.060
初始化的对吧

18:52.060 --> 18:53.060
这状态本来就在这里

18:53.060 --> 18:54.060
初始化的

18:54.060 --> 18:55.060
初始化状态没问题

18:55.060 --> 18:56.060
你要么就直接初始化3

18:56.060 --> 19:00.060
千万不能再直接使用setState

19:00.060 --> 19:02.060
不能使用这个东西

19:02.060 --> 19:03.060
这是关于

19:03.060 --> 19:04.060
第一个点

19:04.060 --> 19:05.060
构造函数这一块

19:05.060 --> 19:07.060
我要讲的东西

19:07.060 --> 19:08.060
以后就不要这样

19:08.060 --> 19:09.060
这样做了

19:09.060 --> 19:10.060
包括什么setinterfer

19:10.060 --> 19:11.060
都尽量不要这样做

19:11.060 --> 19:13.060
这不是一个很好的编程习惯

19:13.060 --> 19:14.060
并且呢

19:14.060 --> 19:15.060
我们以后呢

19:15.060 --> 19:16.060
还会学习什么

19:16.060 --> 19:18.060
SSR就是服务端渲染

19:18.060 --> 19:19.060
那么服务端渲染

19:19.060 --> 19:20.060
也会用到构造函数

19:20.060 --> 19:21.060
那么到时候

19:21.060 --> 19:23.060
在服务端运行这个东西的时候

19:23.060 --> 19:24.060
给我买一些乱七八糟的东西

19:24.060 --> 19:25.060
那肯定不行了

19:25.060 --> 19:29.060
所以构造函数里面就严禁使用这个东西

19:29.060 --> 19:30.060
好

19:30.060 --> 19:31.060
咱们来看下一个

19:31.060 --> 19:33.060
下一个生命周期

19:33.060 --> 19:34.060
好

19:34.060 --> 19:35.060
下一个

19:35.060 --> 19:37.060
下一个呢就是这个

19:37.060 --> 19:38.060
初始化完了过后

19:38.060 --> 19:39.060
就相当于是一个婴儿出生了

19:39.060 --> 19:40.060
对吧

19:40.060 --> 19:42.060
婴儿出生了过后呢

19:42.060 --> 19:43.060
这个婴儿很忙

19:43.060 --> 19:45.060
刚一出生就干活了

19:45.060 --> 19:47.060
他现在要马不停提的

19:47.060 --> 19:48.060
要做一件事

19:48.060 --> 19:49.060
就是要把这个

19:49.060 --> 19:52.060
组件的挂载到页面上

19:52.060 --> 19:53.060
他首先呢

19:53.060 --> 19:54.060
他会触发这么一个事件

19:54.060 --> 19:55.060
也就是勾字函数

19:55.060 --> 19:57.060
也就是当组件呢

19:57.060 --> 19:58.060
即将被挂载到页面上

19:58.060 --> 19:59.060
还没有挂载

19:59.060 --> 20:01.060
即将被挂载的时候呢

20:01.060 --> 20:03.060
他会运行这个函数

20:03.060 --> 20:05.060
component wheel mount

20:05.060 --> 20:08.060
比如说生命周期第二个

20:08.060 --> 20:09.060
他会运行这个函数

20:09.060 --> 20:10.060
好

20:10.060 --> 20:11.060
咱们来看一下吧

20:11.060 --> 20:12.060
这个函数

20:12.060 --> 20:13.060
我们在这里边呢

20:13.060 --> 20:14.060
写上

20:14.060 --> 20:15.060
我们安装那个插件

20:15.060 --> 20:16.060
插件里边

20:16.060 --> 20:18.060
他有提供了这么一个简写

20:18.060 --> 20:21.060
component wheel mount

20:21.060 --> 20:22.060
就这么一个函数

20:22.060 --> 20:23.060
好

20:23.060 --> 20:24.060
这函数呢

20:24.060 --> 20:25.060
我们输出一个

20:25.060 --> 20:27.060
咱们把这个函数的名字也写进去吧

20:27.060 --> 20:29.060
函数的名字也写进去

20:29.060 --> 20:30.060
这里呢

20:30.060 --> 20:31.060
写上这个

20:31.060 --> 20:33.060
component wheel mount

20:33.060 --> 20:34.060
这里呢

20:34.060 --> 20:35.060
写上这个

20:35.060 --> 20:36.060
这个是

20:36.060 --> 20:40.060
组件即将被挂载

20:40.060 --> 20:43.210
挂载

20:43.210 --> 20:44.210
好

20:44.210 --> 20:45.210
那么这个组件即将被挂载

20:45.210 --> 20:47.210
是在什么时候运行呢

20:47.210 --> 20:49.210
是在这个构造函数完了之后

20:49.210 --> 20:50.210
马上就运行

20:50.210 --> 20:51.210
并且这个函数呢

20:51.210 --> 20:53.210
他也只会运行一次

20:53.210 --> 20:54.210
也只会运行一次

20:54.210 --> 20:56.210
保存咱们看一下吧

20:56.210 --> 20:57.210
你看

20:57.210 --> 20:58.210
它是不是运行的

20:58.210 --> 20:59.210
构造函数运行的一次

20:59.210 --> 21:00.210
它运行的一次

21:00.210 --> 21:01.210
然后我们点击

21:01.210 --> 21:02.210
改变它的属性

21:02.210 --> 21:03.210
有没有重新运行

21:03.210 --> 21:04.210
并没有

21:04.210 --> 21:05.210
这个函数呢

21:05.210 --> 21:06.210
它只会运行一次

21:06.210 --> 21:07.210
好

21:07.210 --> 21:08.210
那么这里记一下

21:08.210 --> 21:09.210
第一个就是

21:09.210 --> 21:11.210
和构造函数一样

21:11.210 --> 21:13.210
构造函数一样

21:13.210 --> 21:17.210
它只会运行一次

21:17.210 --> 21:18.210
挂载了

21:18.210 --> 21:19.210
即将挂载

21:19.210 --> 21:21.210
它只会运行一次

21:21.210 --> 21:22.210
好

21:22.210 --> 21:23.210
第二个呢

21:23.210 --> 21:25.210
它能不能使用了

21:25.210 --> 21:27.210
它可以使用

21:27.210 --> 21:28.210
set

21:28.210 --> 21:29.210
set

21:29.210 --> 21:31.210
但是

21:31.210 --> 21:33.210
为了避免

21:33.210 --> 21:34.210
bug

21:34.210 --> 21:36.210
不允许使用

21:36.210 --> 21:38.210
不允许你在这里面使用set state

21:38.210 --> 21:39.210
好

21:39.210 --> 21:40.210
咱们来看一下吧

21:40.210 --> 21:41.210
它是可以使用set

21:41.210 --> 21:42.210
s

21:42.210 --> 21:44.210
set state

21:44.210 --> 21:46.210
n

21:46.210 --> 21:47.210
保存

21:47.210 --> 21:50.210
因为它已经到了挂载阶段了

21:50.210 --> 21:51.210
在挂载阶段

21:51.210 --> 21:52.210
是可以使用set state的

21:52.210 --> 21:53.210
你看

21:53.210 --> 21:55.210
状态改变了

21:55.210 --> 21:56.210
但是呢

21:56.210 --> 21:58.210
不准利使用

21:58.210 --> 21:59.210
为什么不准利使用呢

21:59.210 --> 22:01.210
它是因为这个原因

22:01.210 --> 22:02.210
是这个原因

22:02.210 --> 22:05.780
就是说

22:05.780 --> 22:07.780
因为在

22:07.780 --> 22:09.780
因为

22:09.780 --> 22:12.780
在某些特殊情况下

22:12.780 --> 22:14.780
该函数

22:14.780 --> 22:16.780
可能被调用多次

22:16.780 --> 22:18.780
刚刚不是才说

22:18.780 --> 22:20.780
它只会调用一次吗

22:20.780 --> 22:21.780
只会运行一次吗

22:21.780 --> 22:23.780
就是正常情况下

22:23.780 --> 22:25.780
正常情况下

22:25.780 --> 22:28.780
它是会只会被调用一次的

22:28.780 --> 22:29.780
那么

22:29.780 --> 22:31.780
为什么可能会被调用多次呢

22:31.780 --> 22:33.780
是有一些特殊原因

22:33.780 --> 22:35.780
现在我没法给你解释

22:35.780 --> 22:36.780
它涉及到

22:36.780 --> 22:37.780
简单说一下吧

22:37.780 --> 22:38.780
听听就行了

22:38.780 --> 22:39.780
听听就行了

22:39.780 --> 22:40.780
不要往心里面去

22:40.780 --> 22:42.780
就是说

22:42.780 --> 22:45.780
将来我们可能会遇到一种情况

22:45.780 --> 22:46.780
就是在生命周期初时的

22:46.780 --> 22:48.780
就是在一开始的阶段

22:48.780 --> 22:50.780
还没有挂载完成的阶段的时候呢

22:50.780 --> 22:52.780
它可能会打断

22:52.780 --> 22:53.780
把生命周期打断

22:53.780 --> 22:54.780
然后重新来一遍

22:54.780 --> 22:55.780
把整个过程

22:55.780 --> 22:57.780
一开始的过程重新走一遍

22:57.780 --> 22:59.780
那么就会导致了某些出现的

22:59.780 --> 23:00.780
component will mount

23:00.780 --> 23:01.780
它会运行多次

23:01.780 --> 23:03.780
还有种情况是服务端渲染

23:03.780 --> 23:04.780
SSR

23:04.780 --> 23:05.780
那么这个东西

23:05.780 --> 23:06.780
服务端会运行一次

23:06.780 --> 23:07.780
它也

23:07.780 --> 23:08.780
课不端也会运行一次

23:08.780 --> 23:10.780
所以说尽量在这里面

23:10.780 --> 23:12.780
不要去使用SSDat

23:12.780 --> 23:13.780
好吧

23:13.780 --> 23:14.780
我解释清楚了没有

23:14.780 --> 23:15.780
肯定没有

23:15.780 --> 23:18.780
因为我们以后再好好解释

23:18.780 --> 23:19.780
所以说

23:19.780 --> 23:21.780
这里你只需要心里面知道

23:21.780 --> 23:23.780
不能去用就完事了

23:23.780 --> 23:25.780
所以说component will mount

23:25.780 --> 23:27.780
由于它可能在特殊情况下

23:27.780 --> 23:29.780
可能会被调用多次

23:29.780 --> 23:31.780
由于它是个特点

23:31.780 --> 23:32.780
所以说这个函数

23:32.780 --> 23:35.780
也让react官方挺头痛的

23:35.780 --> 23:37.780
这个东西非常容易导致bug

23:37.780 --> 23:38.780
平时我们开发中

23:38.780 --> 23:39.780
也其实尽量的去避免了

23:39.780 --> 23:40.780
使用这个勾折函数

23:40.780 --> 23:42.780
尽量避免去使用它

23:42.780 --> 23:44.780
因为它非常容易导致bug

23:44.780 --> 23:45.780
所以呢

23:45.780 --> 23:47.780
后来在新版的生命周期里面

23:47.780 --> 23:48.780
它就移除了

23:48.780 --> 23:49.780
直接把它砍掉了

23:49.780 --> 23:51.780
就不要它了

23:51.780 --> 23:54.780
这是这么一个生命周期函数

23:54.780 --> 23:55.780
好

23:55.780 --> 23:56.780
接下来咱们再看

23:56.780 --> 23:57.780
下面就是Render

23:57.780 --> 23:59.780
这个Render函数就非常熟悉了

23:59.780 --> 24:01.780
Render函数干嘛呢

24:01.780 --> 24:03.780
它就是来渲染一个虚拟动

24:03.780 --> 24:05.780
什么叫虚拟动

24:05.780 --> 24:07.780
这个玩意儿就是个虚拟动

24:07.780 --> 24:09.780
它不是真实的动物对象

24:09.780 --> 24:10.780
它就是一个

24:10.780 --> 24:11.780
我们之前说过

24:11.780 --> 24:12.780
GSX表达式

24:12.780 --> 24:13.780
它其实就是一个对象

24:13.780 --> 24:14.780
它就是

24:14.780 --> 24:15.780
反回的是什么呢

24:15.780 --> 24:17.780
反回的就是一个

24:17.780 --> 24:19.780
react create element

24:19.780 --> 24:21.780
反回的相当于是这么一个东西

24:21.780 --> 24:23.780
反回的是个GS对象

24:23.780 --> 24:25.780
那么它会把这个反回的GS对象

24:25.780 --> 24:26.780
挂载到什么

24:26.780 --> 24:28.780
挂载到一个虚拟动物数里面

24:28.780 --> 24:30.780
你看一下我们的react这个结构

24:30.780 --> 24:31.780
你看这是

24:31.780 --> 24:33.780
这是一个对象

24:33.780 --> 24:34.780
react元素

24:34.780 --> 24:35.780
react元素里面

24:35.780 --> 24:37.780
有一些指元素都是对象

24:37.780 --> 24:38.780
全都是对象

24:38.780 --> 24:39.780
它不是真实动物元素

24:39.780 --> 24:41.780
有一个组件DIV

24:41.780 --> 24:42.780
DIV组件里面

24:42.780 --> 24:43.780
有这个组件

24:43.780 --> 24:44.780
有这个组件

24:44.780 --> 24:45.780
有这个组件

24:45.780 --> 24:46.780
这个组件

24:46.780 --> 24:47.780
你看看

24:47.780 --> 24:49.780
这些都是组件

24:49.780 --> 24:50.780
所以说

24:50.780 --> 24:52.780
这就是一个虚拟动物数

24:52.780 --> 24:53.780
虚拟的动物数

24:53.780 --> 24:54.780
并不是真实的

24:54.780 --> 24:56.780
并不是真实的

24:56.780 --> 24:57.780
所以说它这里反回的结构

24:57.780 --> 24:58.780
它会把它挂载到

24:58.780 --> 24:59.780
虚拟动物数里面

24:59.780 --> 25:00.780
那么这个时候

25:00.780 --> 25:01.780
它开始运行

25:01.780 --> 25:03.780
这个 render 函数

25:03.780 --> 25:05.780
我们把它叫做渲染函数

25:05.780 --> 25:07.780
渲染

25:07.780 --> 25:11.780
然后反回的react元素

25:11.780 --> 25:13.780
会被挂载到

25:13.780 --> 25:16.780
虚拟动物数种

25:16.780 --> 25:18.780
虚拟动物数种

25:18.780 --> 25:20.780
咱们这里说的挂载

25:20.780 --> 25:22.780
其实有两层含义

25:22.780 --> 25:23.780
一层含义

25:23.780 --> 25:25.780
把它挂到虚拟动物数里面

25:25.780 --> 25:26.780
另外一层含义

25:26.780 --> 25:28.780
是把虚拟动物数

25:28.780 --> 25:29.780
显示到页面上

25:29.780 --> 25:30.780
其实你虚拟动物数

25:30.780 --> 25:31.780
构建完成过后

25:31.780 --> 25:34.780
这个东西就开始发挥作用了

25:34.780 --> 25:36.780
这个东西开始发挥作用

25:36.780 --> 25:37.780
它就会把它挂载到

25:37.780 --> 25:39.780
真实的动物元素里面

25:39.780 --> 25:41.780
只要你把虚拟动物数

25:41.780 --> 25:42.780
构建好过后

25:42.780 --> 25:43.780
它就会开始工作了

25:43.780 --> 25:45.780
所以说我们甚至可以认为

25:45.780 --> 25:46.780
你的虚拟动物数

25:46.780 --> 25:47.780
构建好了过后

25:47.780 --> 25:49.780
就页面就已经能够显示了

25:49.780 --> 25:51.780
是这么个意思

25:51.780 --> 25:52.780
这是Render

25:52.780 --> 25:53.780
咱们大家看一下

25:53.780 --> 25:55.780
Render是不是调用了

25:55.780 --> 25:58.780
Render肯定不只运行一次

25:58.780 --> 26:00.780
那么很多时候

26:00.780 --> 26:02.780
只要需要重新训练

26:02.780 --> 26:03.780
都会运行

26:03.780 --> 26:05.780
Render

26:05.780 --> 26:09.780
创建

26:09.780 --> 26:13.780
就是返回一个虚拟动物

26:13.780 --> 26:19.780
会被挂载到虚拟动物数中

26:19.780 --> 26:21.780
挂载到这个数里面

26:21.780 --> 26:27.780
最终渲染到页面的真实动物中

26:27.780 --> 26:29.780
最终会渲染到这

26:29.780 --> 26:30.780
这是Render

26:30.780 --> 26:32.780
Render肯定不会只运行一次

26:32.780 --> 26:38.280
Render

26:38.280 --> 26:42.280
可能不只运行一次

26:42.280 --> 26:47.280
只要需要重新渲染

26:47.280 --> 26:49.280
就会被运行

26:49.280 --> 26:50.280
我们之前还说过的吧

26:50.280 --> 26:51.280
什么

26:51.280 --> 26:53.280
副主建的Render调用了

26:53.280 --> 26:54.280
它会是不是导致

26:54.280 --> 26:56.280
指数件的Render也会跟着调用

26:56.280 --> 26:57.280
它只要重新渲染

26:57.280 --> 26:58.280
它都会运行

26:58.280 --> 27:00.280
就会重新运行

27:00.280 --> 27:01.280
这是

27:01.280 --> 27:02.280
只不过我们现在讲的

27:02.280 --> 27:04.280
是一开始就会运行Render

27:04.280 --> 27:05.280
它有渲染

27:05.280 --> 27:07.280
它把显示出来

27:07.280 --> 27:08.280
它会运行Render

27:08.280 --> 27:09.280
Render之后

27:09.280 --> 27:12.280
把它挂载到虚拟动物数之后

27:12.280 --> 27:14.280
就马上开始运行这个函数了

27:14.280 --> 27:16.280
这是个勾字函数

27:16.280 --> 27:18.280
虚拟动物已经挂得到页面

27:18.280 --> 27:19.280
成为真实动物

27:19.280 --> 27:20.280
也可以认为

27:20.280 --> 27:22.280
它把它勾件到虚拟动物数里面

27:22.280 --> 27:24.280
之后就会运行这个函数

27:24.280 --> 27:26.280
因为我们可以认为

27:26.280 --> 27:28.280
只要虚拟动物数勾件完成之后

27:28.280 --> 27:30.280
它就可以进行渲染了

27:30.280 --> 27:31.280
可以进行页面渲染了

27:31.280 --> 27:32.280
所以说我们这两个

27:32.280 --> 27:34.280
不用去分得那么的清楚

27:34.280 --> 27:35.280
我们后边讲

27:35.280 --> 27:36.280
原理部分的

27:36.280 --> 27:37.280
会把它分得很清楚

27:37.280 --> 27:39.280
目前不用分得那么清楚

27:39.280 --> 27:40.280
我们现在只需要知道

27:40.280 --> 27:41.280
虚拟动物勾件完了过后

27:41.280 --> 27:43.280
你就可以渲染了

27:43.280 --> 27:45.280
它会运行这个函数

27:45.280 --> 27:48.280
这个函数它也是只会运行一次

27:48.280 --> 27:49.280
这个函数是真真切切地

27:49.280 --> 27:51.280
只会运行一次了

27:51.280 --> 27:52.280
地德曼子

27:52.280 --> 27:54.280
Hansel Nog

27:54.280 --> 27:57.280
这个玩意

27:57.280 --> 28:00.280
就是挂载完成

28:00.280 --> 28:02.280
这个函数还是真正的

28:02.280 --> 28:04.280
只会运行一次

28:05.280 --> 28:06.280
刚才还忘了说了

28:06.280 --> 28:07.280
在Render里面

28:07.280 --> 28:08.280
能不能调用SetState

28:08.280 --> 28:10.280
最好不要

28:10.280 --> 28:11.280
最好不要

28:11.280 --> 28:12.280
我们来看一下

28:12.280 --> 28:14.280
Render里面我们去调用一下

28:14.280 --> 28:15.280
Yes SetState

28:15.280 --> 28:18.980
看一下会发生什么事情

28:18.980 --> 28:19.980
保存

28:19.980 --> 28:20.980
你看一下

28:20.980 --> 28:22.980
会发生什么事情

28:22.980 --> 28:24.980
它这个错误是什么

28:24.980 --> 28:27.980
它说更新的深度

28:27.980 --> 28:28.980
一出

28:28.980 --> 28:29.980
什么意思

28:29.980 --> 28:30.980
你想一下

28:30.980 --> 28:32.980
在Render里面去调用SetState

28:32.980 --> 28:33.980
运行这个东西

28:33.980 --> 28:34.980
是不是又要重新调用Render

28:34.980 --> 28:35.980
又要重新调用Render

28:35.980 --> 28:36.980
是不是又要调用SetState

28:36.980 --> 28:37.980
对吧

28:37.980 --> 28:38.980
它就反复渲染

28:38.980 --> 28:39.980
反复渲染

28:39.980 --> 28:41.980
所以Render里面

28:41.980 --> 28:42.980
不要说尽量了

28:42.980 --> 28:44.980
就直接延近

28:44.980 --> 28:45.980
Render里面

28:45.980 --> 28:47.980
延近使用

28:47.980 --> 28:50.980
延近使用SetState

28:50.980 --> 28:52.980
延近使用这个东西

28:52.980 --> 28:53.980
为什么

28:53.980 --> 28:57.980
因为可能会导致

28:57.980 --> 29:00.980
就是无限地规渲染

29:00.980 --> 29:01.980
因为每次调用它

29:01.980 --> 29:02.980
会渲染一次

29:02.980 --> 29:03.980
每次调用会渲染一次

29:03.980 --> 29:04.980
它渲染的是又重新调用

29:04.980 --> 29:05.980
那又会渲染

29:05.980 --> 29:06.980
所以Render里面是

29:06.980 --> 29:08.980
延近使用这种东西的

29:08.980 --> 29:10.980
接下来我们看这个

29:10.980 --> 29:11.980
ComponentDid

29:11.980 --> 29:13.980
Did是过去完成时的

29:13.980 --> 29:16.980
Did已经完成了挂斩

29:16.980 --> 29:17.980
我们看这个

29:17.980 --> 29:22.860
这个东西它肯定是执行一次

29:22.860 --> 29:24.860
只会执行一次

29:24.860 --> 29:25.860
它没有什么情况了

29:25.860 --> 29:27.860
只会执行一次

29:27.860 --> 29:30.860
所以这个函数蛮有用的

29:30.860 --> 29:32.860
那么这里面肯定是可以

29:32.860 --> 29:33.860
已经渲染完成了

29:33.860 --> 29:34.860
渲染完成了

29:34.860 --> 29:35.860
就是已经挂斩完成了

29:35.860 --> 29:37.860
那么这个时候你可以改变

29:37.860 --> 29:39.860
通过SetState改变

29:39.860 --> 29:43.860
可以使用SetState

29:43.860 --> 29:45.860
可以使用这个

29:45.860 --> 29:47.860
通常情况下

29:47.860 --> 29:49.860
这个还是蛮有用的

29:49.860 --> 29:50.860
非常非常有用

29:50.860 --> 29:51.860
通常情况下

29:51.860 --> 29:53.860
汇疆

29:53.860 --> 29:55.860
阿加克斯请求

29:55.860 --> 29:57.860
就是远程请求

29:57.860 --> 29:59.860
网络请求

29:59.860 --> 30:00.860
还有什么呢

30:00.860 --> 30:04.860
启动计时器等一开始

30:04.860 --> 30:06.860
需要的操作

30:06.860 --> 30:09.860
书写到该函数中

30:09.860 --> 30:11.860
就是我们之前的

30:11.860 --> 30:12.860
启动了个倒计时期

30:12.860 --> 30:13.860
对吧

30:13.860 --> 30:14.860
我们把它写到哪里

30:14.860 --> 30:15.860
把它写到构造函数里面

30:15.860 --> 30:16.860
实际上是不好的

30:16.860 --> 30:18.860
这种写法习惯上是不好的

30:18.860 --> 30:19.860
尽管我们是异部

30:19.860 --> 30:21.860
它不会输出什么问题

30:21.860 --> 30:22.860
但是实际上是不好的

30:22.860 --> 30:23.860
我们应该写到哪

30:23.860 --> 30:25.860
应该写到ComponentDidMount里面

30:25.860 --> 30:26.860
写到这

30:26.860 --> 30:28.860
等它挂斩完成了之后

30:28.860 --> 30:29.860
因为它先看到东西过后

30:29.860 --> 30:30.860
然后咱们再来

30:30.860 --> 30:31.860
做一些其他的事情

30:31.860 --> 30:32.860
可能其他的事情

30:32.860 --> 30:33.860
会改变状态

30:33.860 --> 30:34.860
明白的意思吧

30:34.860 --> 30:37.860
所以说我们写的React程序

30:37.860 --> 30:38.860
往往是这样子

30:38.860 --> 30:40.860
比方说一个远程请求

30:40.860 --> 30:42.860
咱们要显示一个学生列表

30:42.860 --> 30:44.860
它是要远程去获取学生

30:44.860 --> 30:46.860
那么我们就把远程请求的代码

30:46.860 --> 30:47.860
写到这

30:47.860 --> 30:49.860
就让它废弃

30:49.860 --> 30:51.860
去写一个UIL地址

30:51.860 --> 30:52.860
然后拿到学生数据

30:52.860 --> 30:54.860
Rain怎么样

30:54.860 --> 30:57.860
然后拿到学生数据过后

30:57.860 --> 30:58.860
然后再干嘛呢

30:58.860 --> 31:00.860
再把这个学生数据

31:00.860 --> 31:02.860
再把这个学生数据

31:02.860 --> 31:04.860
再把这个学生数据

31:04.860 --> 31:07.860
挂载到ResponseData

31:07.860 --> 31:08.860
就是拿出来

31:08.860 --> 31:09.860
然后呢

31:09.860 --> 31:11.860
是不是重新set

31:11.860 --> 31:12.860
对吧

31:12.860 --> 31:13.860
在这里

31:13.860 --> 31:14.860
在这里去处理这些问题

31:14.860 --> 31:16.860
我们往往是把它写到这的

31:16.860 --> 31:18.860
也就是给用户

31:18.860 --> 31:20.860
给什么样的效果呢

31:20.860 --> 31:21.860
一个种感觉

31:21.860 --> 31:22.860
我们的页面

31:22.860 --> 31:23.860
一开始有一个东西

31:23.860 --> 31:24.860
一个modern的东西

31:24.860 --> 31:26.860
表示说正在夹载中

31:26.860 --> 31:28.860
或者是一个圈圈的一转

31:28.860 --> 31:30.860
然后等它夹载完成过后呢

31:30.860 --> 31:32.860
在这里面重新设置set state

31:32.860 --> 31:34.860
设置完了过后呢

31:34.860 --> 31:35.860
它界面又重新改变了

31:35.860 --> 31:37.860
我们往往在这里进行处理

31:37.860 --> 31:39.860
所以这个函数非常非常有用

31:39.860 --> 31:40.860
好了

31:40.860 --> 31:41.860
那至此呢

31:41.860 --> 31:42.860
挂载阶段就完成了

31:42.860 --> 31:45.860
挂载阶段完成之后

31:45.860 --> 31:47.860
那么这个组建的他进入

31:47.860 --> 31:49.860
进入了一个活跃状态

31:51.860 --> 31:53.860
组建进入活跃状态

31:54.860 --> 31:56.860
什么叫活跃状态呢

31:56.860 --> 31:57.860
它就相当于是

31:57.860 --> 31:58.860
人一出生

31:58.860 --> 31:59.860
这个婴儿一出生

31:59.860 --> 32:01.860
马不停地去干了这些事情

32:01.860 --> 32:02.860
干了这些事情过来

32:02.860 --> 32:03.860
现在没事可干了

32:03.860 --> 32:04.860
那等这边

32:04.860 --> 32:05.860
玩呗对吧

32:05.860 --> 32:07.860
你干干嘛干嘛去玩就行了

32:07.860 --> 32:09.860
那么这个时候他等什么呢

32:09.860 --> 32:13.860
等需要重新渲染的时候

32:13.860 --> 32:16.860
什么情况下需要重新渲染呢

32:16.860 --> 32:20.860
一个是属性发生变化

32:21.860 --> 32:24.860
一个是状态发生变化

32:24.860 --> 32:26.860
一个是属性发生变化

32:26.860 --> 32:28.860
一个是状态发生变化

32:28.860 --> 32:30.860
好我们一个个来

32:30.860 --> 32:33.860
首先说属性发生变化

32:33.860 --> 32:34.860
那么这个部分

32:34.860 --> 32:36.860
我们把统称为更新阶段

32:36.860 --> 32:37.860
更新阶段

32:37.860 --> 32:39.860
就现在这个组建呢

32:39.860 --> 32:40.860
等着没事干了

32:40.860 --> 32:42.860
但是通常突然出现一件事

32:42.860 --> 32:44.860
导致了他属性发生变化了

32:44.860 --> 32:45.860
于是呢

32:45.860 --> 32:47.860
他要进入下个生命周期了

32:47.860 --> 32:49.860
当属性发生变化的时候

32:49.860 --> 32:51.860
他会运行这个函数

32:51.860 --> 32:52.860
这个函数

32:52.860 --> 32:55.860
叫做component will

32:55.860 --> 32:59.860
即将接收到属性值

32:59.860 --> 33:02.860
我们来看一下这个

33:02.860 --> 33:03.860
这个函数

33:03.860 --> 33:07.860
component will receive props

33:07.860 --> 33:11.860
即将接收新的属性值

33:11.860 --> 33:14.860
就属性发生的变化

33:14.860 --> 33:15.860
好然后呢

33:15.860 --> 33:16.860
我们这里看一下

33:16.860 --> 33:18.860
再写个函数

33:18.860 --> 33:19.860
叫做

33:19.860 --> 33:24.860
component will receive

33:24.860 --> 33:25.860
在这

33:27.860 --> 33:29.860
这个块钱是

33:29.860 --> 33:33.860
component will receive

33:33.860 --> 33:34.860
是这个吗

33:34.860 --> 33:36.860
对就是这个

33:36.860 --> 33:37.860
他有这么一个函数

33:37.860 --> 33:38.860
有这个函数

33:38.860 --> 33:40.860
就是新的属性值

33:40.860 --> 33:44.860
参数为新的属性

33:44.860 --> 33:45.860
属性对象

33:45.860 --> 33:47.860
他是为新的属性对象

33:47.860 --> 33:49.860
好咱们呢这里打印一下

33:49.860 --> 33:51.860
console log

33:51.860 --> 33:52.860
好这里呢

33:52.860 --> 33:54.860
在这里

33:54.860 --> 33:57.860
运行是在这里输出一下

33:57.860 --> 33:59.860
这个就是

33:59.860 --> 34:03.860
接收到新的属性值

34:03.860 --> 34:05.860
好我们把新的属性值打印出来

34:05.860 --> 34:07.860
那个是 props

34:07.860 --> 34:09.860
好看一下

34:09.860 --> 34:10.860
他会怎么运行

34:10.860 --> 34:11.860
好这里呢

34:11.860 --> 34:12.860
我们不是改变他的属性吗

34:12.860 --> 34:13.860
对吧改变他的属性

34:13.860 --> 34:14.860
一开始没问题吧

34:14.860 --> 34:16.860
一开始这样的运行顺序没问题吧

34:16.860 --> 34:18.860
好点击n加1

34:18.860 --> 34:20.860
好你看是不是

34:20.860 --> 34:22.860
他这样子这里就得到了

34:22.860 --> 34:24.860
得到了新的属性值了

34:24.860 --> 34:25.860
n等于2了

34:25.860 --> 34:26.860
你看属性对象里面

34:26.860 --> 34:27.860
n等于2了

34:27.860 --> 34:28.860
他会运行这个东西

34:28.860 --> 34:29.860
会运行这个对象

34:29.860 --> 34:31.860
会运行这个函数

34:31.860 --> 34:32.860
好那么这个函数里边

34:32.860 --> 34:33.860
如果你要获取

34:33.860 --> 34:34.860
当前的属性值呢

34:34.860 --> 34:35.860
this props

34:35.860 --> 34:36.860
你看一下

34:36.860 --> 34:37.860
获取当前属性值

34:37.860 --> 34:38.860
看一下属性值

34:38.860 --> 34:40.860
有没有变化

34:40.860 --> 34:41.860
好点击

34:41.860 --> 34:42.860
你会发现

34:42.860 --> 34:43.860
当前的属性值

34:43.860 --> 34:45.860
还没有被改变

34:45.860 --> 34:46.860
看到没

34:46.860 --> 34:47.860
当前的属性值

34:47.860 --> 34:49.860
还没有被改变

34:49.860 --> 34:51.860
这是我们传入的新的属性值

34:51.860 --> 34:53.860
这是我们当前的属性值

34:53.860 --> 34:54.860
你看还没有被改变

34:54.860 --> 34:55.860
那么你有可能

34:55.860 --> 34:56.860
会在这里边做一些事情

34:56.860 --> 34:57.860
实际上

34:57.860 --> 34:59.860
这里面我们也没有什么事情可以做

34:59.860 --> 35:00.860
通常情况下

35:00.860 --> 35:01.860
也没有什么事情可以做

35:01.860 --> 35:03.860
这个函数呢也挺积累的

35:03.860 --> 35:04.860
并且这个函数呢

35:04.860 --> 35:06.860
在某些特殊情况下

35:06.860 --> 35:08.860
可能会导致一些bug

35:08.860 --> 35:09.860
导致一些问题

35:09.860 --> 35:10.860
因此在新版里边

35:10.860 --> 35:12.860
又把这个函数给我移除掉了

35:12.860 --> 35:13.860
基本上移除掉了

35:13.860 --> 35:14.860
所以说这个函数呢

35:15.860 --> 35:17.860
因为我现在只能这样子

35:17.860 --> 35:18.860
该反反而谈

35:18.860 --> 35:19.860
因为现在的

35:19.860 --> 35:20.860
涉及到更深的原理

35:20.860 --> 35:21.860
我们现在还没讲

35:21.860 --> 35:22.860
该函数呢

35:22.860 --> 35:25.860
可能会导致一些bug

35:25.860 --> 35:27.860
所以

35:27.860 --> 35:29.860
不推荐使用

35:29.860 --> 35:30.860
不推荐使用

35:30.860 --> 35:32.860
大家了解一下这个函数就行了

35:32.860 --> 35:33.860
知道有这么个东西就行了

35:33.860 --> 35:35.860
不推荐使用就完事了

35:35.860 --> 35:37.860
这是这么一个函数

35:37.860 --> 35:39.860
接受到新的属性值

35:39.860 --> 35:40.860
好那么接下来呢

35:40.860 --> 35:42.860
就进入了

35:42.860 --> 35:43.860
状态改变

35:43.860 --> 35:44.860
属性改变

35:44.860 --> 35:45.860
共同的生命周期了

35:45.860 --> 35:46.860
有下面这一部分

35:46.860 --> 35:47.860
无论是状态改变

35:47.860 --> 35:49.860
还是状态改变是什么

35:49.860 --> 35:51.860
就是set state

35:51.860 --> 35:53.860
状态变化

35:53.860 --> 35:56.860
这里就是set state

35:56.860 --> 36:00.430
当我们调用这个东西的时候

36:00.430 --> 36:02.430
那么这个组件呢

36:02.430 --> 36:04.430
它会进入下面这个过程

36:04.430 --> 36:05.430
那么属性变化完了过后呢

36:05.430 --> 36:07.430
它如果发生了这件事情过后

36:07.430 --> 36:09.430
然后它也会进入这个流程

36:09.430 --> 36:10.430
所以说剩下的流程是一样的了

36:10.430 --> 36:11.430
我们就统一讲

36:11.430 --> 36:14.430
下边这个函数是非常非常关键的

36:14.430 --> 36:16.430
这是一个性能优化点

36:16.430 --> 36:17.430
它叫做什么呢

36:17.430 --> 36:21.430
它叫做shoot component update

36:21.430 --> 36:23.430
看一下这个函数

36:25.430 --> 36:26.430
下个函数

36:26.430 --> 36:28.740
就这里面虽然很多

36:28.740 --> 36:30.740
但是平时我们用到了其实不多

36:30.740 --> 36:33.740
那么这个用到了我们打个重点嘛

36:33.740 --> 36:34.740
把家出一下

36:34.740 --> 36:35.740
这个东西是重点

36:35.740 --> 36:38.740
这个东西当然毫不以为是重点

36:38.740 --> 36:40.740
你要知道它什么时候执行

36:40.740 --> 36:41.740
那么下面这个

36:41.740 --> 36:43.740
这个是重点

36:43.740 --> 36:44.740
这是个性能优化点

36:44.740 --> 36:47.740
它是指示

36:47.740 --> 36:49.740
指示react

36:49.740 --> 36:52.740
是否要更新

36:52.740 --> 36:58.740
要重新渲染该组件

36:58.740 --> 37:02.740
是不是要重新渲染该组件

37:02.740 --> 37:03.740
那么这个函数呢

37:03.740 --> 37:04.740
它有个返回值

37:04.740 --> 37:08.740
通过返回去和force来指定

37:08.740 --> 37:10.740
如果你返回了去的话

37:10.740 --> 37:13.740
那么表示重新渲染这个组件

37:13.740 --> 37:14.740
返回了force的话

37:14.740 --> 37:16.740
它就不会重新渲染

37:16.740 --> 37:18.740
明白这个意思吧

37:18.740 --> 37:21.740
那么默认情况下

37:21.740 --> 37:25.740
会直接返回去

37:25.740 --> 37:27.740
就是你如果不写这个函数的话

37:27.740 --> 37:28.740
它直接返回出

37:28.740 --> 37:29.740
所以说我们可以看到

37:29.740 --> 37:31.740
当它属性变化

37:31.740 --> 37:33.740
当它的状态变化

37:33.740 --> 37:34.740
它都会重新渲染

37:34.740 --> 37:35.740
我这里再说一下

37:35.740 --> 37:37.740
这个属性变化呢

37:37.740 --> 37:39.740
指的是你重新给它复制的属性

37:39.740 --> 37:41.740
它不一定是属性的值发生变化

37:41.740 --> 37:42.740
那比方说吧

37:42.740 --> 37:43.740
那这里set state

37:43.740 --> 37:45.740
我始终把这个number设置为1

37:45.740 --> 37:46.740
始终设置为1

37:46.740 --> 37:48.740
看一下吧

37:48.740 --> 37:49.740
点击

37:49.740 --> 37:50.740
你看一下

37:50.740 --> 37:52.740
是不是还是运行了这个函数

37:52.740 --> 37:55.740
它指的是属性重新备复制的

37:55.740 --> 37:57.740
指的是属性重新备复制的

37:57.740 --> 37:58.740
它并不是说

37:58.740 --> 38:00.740
这个属性值一定要变化

38:00.740 --> 38:02.740
指的是属性只要重新备复制

38:02.740 --> 38:03.740
OK

38:03.740 --> 38:04.740
它就会

38:04.740 --> 38:06.740
它就会就是运行这个函数

38:06.740 --> 38:08.740
是这么个意思

38:08.740 --> 38:10.740
我直接顺便说一下

38:10.740 --> 38:11.740
好 那么现在回到这

38:11.740 --> 38:13.740
should component

38:13.740 --> 38:14.740
should 是不是

38:14.740 --> 38:15.740
应该什么

38:15.740 --> 38:16.740
应该主键

38:16.740 --> 38:18.740
适合主键应该更新

38:18.740 --> 38:19.740
这么个意思

38:19.740 --> 38:21.740
好 咱们来看一下这个函数

38:21.740 --> 38:26.740
should component update

38:26.740 --> 38:29.740
你看一下这个函数

38:29.740 --> 38:30.740
这个函数里边

38:30.740 --> 38:32.740
它给我们提供了两个参数

38:32.740 --> 38:37.760
我们这里先把这个打印出来

38:37.760 --> 38:38.760
函数里面

38:38.760 --> 38:39.760
根本提供了两个参数

38:39.760 --> 38:42.760
是否应该重新

38:42.760 --> 38:43.760
现在

38:43.760 --> 38:45.760
因为无论是属性变化

38:45.760 --> 38:46.760
还是状态变化

38:46.760 --> 38:48.760
它都会运行这个函数

38:48.760 --> 38:49.760
那么在这个函数里边

38:49.760 --> 38:51.760
我们可以获取

38:51.760 --> 38:55.760
当前的属性和当前的状态

38:55.760 --> 38:58.760
this props

38:58.760 --> 39:01.760
然后 next props

39:01.760 --> 39:02.760
这是我们当前的属性

39:02.760 --> 39:04.760
这是我们新的属性

39:04.760 --> 39:06.760
然后 this state

39:06.760 --> 39:08.760
这是我们当前的状态

39:09.760 --> 39:10.760
next state

39:10.760 --> 39:11.760
这是我们新的状态

39:11.760 --> 39:13.760
那么你通过这些信息

39:13.760 --> 39:14.760
来进行对比

39:14.760 --> 39:15.760
看一下你这个主键

39:15.760 --> 39:17.760
是不是真的应该更新

39:17.760 --> 39:19.760
是不是真的应该重新选了

39:19.760 --> 39:21.760
这就是这么个意思

39:21.760 --> 39:23.760
我们把这些东西都打印出来

39:23.760 --> 39:24.760
都打印出来

39:24.760 --> 39:26.760
好 咱们来看一下吧

39:27.760 --> 39:29.760
点击N加1

39:29.760 --> 39:32.760
我这里没有返回

39:32.760 --> 39:34.760
我们先返回一个处

39:34.760 --> 39:36.760
表示要重新选了

39:36.760 --> 39:37.760
返回一个处

39:38.760 --> 39:39.760
好 点击N加1

39:39.760 --> 39:40.760
你看一下

39:40.760 --> 39:42.760
是否应该重新选了

39:42.760 --> 39:43.760
这里你看得到旧的属性

39:43.760 --> 39:45.760
这是新的属性

39:45.760 --> 39:46.760
旧的状态

39:46.760 --> 39:47.760
新的状态

39:47.760 --> 39:48.760
状态都是一样的

39:48.760 --> 39:49.760
状态都是一样的

39:49.760 --> 39:51.760
那么这里我们比方说

39:51.760 --> 39:52.760
再加一个按钮

39:52.760 --> 39:53.760
再加一个按钮

39:53.760 --> 39:58.760
这是状态N加1

39:58.760 --> 40:00.760
比方说这里写一个

40:00.760 --> 40:01.760
unclick

40:01.760 --> 40:07.570
this set state

40:07.570 --> 40:09.570
N等于

40:09.570 --> 40:11.570
this set

40:11.570 --> 40:13.570
N加1

40:13.570 --> 40:15.570
好 看一下

40:15.570 --> 40:16.570
把状态加1

40:16.570 --> 40:17.570
你看

40:17.570 --> 40:18.570
点击状态加1

40:18.570 --> 40:19.570
你看

40:19.570 --> 40:21.570
这里是不是也要重新选了

40:21.570 --> 40:22.570
重新调用这个函数

40:22.570 --> 40:24.570
should component update

40:24.570 --> 40:25.570
然后呢

40:25.570 --> 40:26.570
返回了去

40:26.570 --> 40:27.570
所以它重新选了

40:27.570 --> 40:29.570
那么这里可以获取旧的状态

40:29.570 --> 40:30.570
可以获取新的状态

40:30.570 --> 40:31.570
看没有

40:31.570 --> 40:32.570
N等于1

40:32.570 --> 40:33.570
看没

40:34.570 --> 40:35.570
好 那么这里边

40:35.570 --> 40:37.570
我们就可以做一些性能优化

40:37.570 --> 40:38.570
比方说

40:38.570 --> 40:39.570
目前情况下

40:39.570 --> 40:40.570
它始终要重新选了

40:40.570 --> 40:41.570
那么我们这里可以判断一下

40:41.570 --> 40:42.570
判断一下

40:42.570 --> 40:43.570
怎么来判断呢

40:43.570 --> 40:44.570
因为我们属性里边

40:44.570 --> 40:45.570
只有个N

40:45.570 --> 40:46.570
状态里边也只有个N

40:46.570 --> 40:47.570
那要不要重新选了呢

40:47.570 --> 40:48.570
判断呗

40:48.570 --> 40:51.570
如果this props.N

40:51.570 --> 40:53.570
等于了

40:53.570 --> 40:57.570
next props.N

40:57.570 --> 40:58.570
两个相等

40:58.570 --> 40:59.570
并且

40:59.570 --> 41:01.570
this set.N

41:01.570 --> 41:02.570
也等于了

41:02.570 --> 41:04.570
next set.N

41:04.570 --> 41:05.570
你看

41:05.570 --> 41:06.570
这四个东西全部相等

41:06.570 --> 41:07.570
对吧

41:07.570 --> 41:08.570
两个属性一样

41:08.570 --> 41:10.570
然后两个状态也一样

41:10.570 --> 41:12.570
全都一样我还选了

41:12.570 --> 41:13.570
啥呢

41:13.570 --> 41:14.570
我就return force

41:14.570 --> 41:16.570
否则的话就return true

41:16.570 --> 41:17.570
是不是可以做性能优化

41:17.570 --> 41:18.570
对吧

41:18.570 --> 41:19.570
那么这样子一来

41:19.570 --> 41:20.570
比方说

41:20.570 --> 41:21.570
我们这里

41:21.570 --> 41:25.570
就把它复制为1

41:25.570 --> 41:26.570
把它复制为1

41:26.570 --> 41:27.570
看一下吧

41:27.570 --> 41:28.570
状态一开始是0

41:28.570 --> 41:29.570
点击状态

41:29.570 --> 41:30.570
重新选了

41:30.570 --> 41:31.570
你看没有

41:31.570 --> 41:32.570
重新选了

41:32.570 --> 41:33.570
然后再点击

41:33.570 --> 41:34.570
它已经是1

41:34.570 --> 41:35.570
你看没有

41:35.570 --> 41:36.570
它就没有重新选了

41:36.570 --> 41:37.570
云的就没有运行了

41:37.570 --> 41:38.570
就没有重新渲染

41:38.570 --> 41:39.570
这样子的

41:39.570 --> 41:40.570
可以节约一些效率

41:40.570 --> 41:42.570
就可以节约效率

41:42.570 --> 41:44.570
看没有

41:44.570 --> 41:46.570
这就是这个函数

41:46.570 --> 41:47.570
那如果这个函数

41:47.570 --> 41:49.570
你不管3721

41:49.570 --> 41:51.570
我就简单粗暴一点

41:51.570 --> 41:52.570
那你直接反回一个force

41:52.570 --> 41:54.570
会怎么样了

41:54.570 --> 41:55.570
你会发现

41:55.570 --> 41:56.570
这个组件

41:56.570 --> 41:58.570
永远就都不要想重新渲染

41:58.570 --> 41:59.570
你看一下

41:59.570 --> 42:01.570
点击过后

42:01.570 --> 42:03.570
你看这里的

42:03.570 --> 42:04.570
这些东西

42:04.570 --> 42:05.570
数据是不是变化了

42:05.570 --> 42:07.570
数据倒是变得飞起

42:07.570 --> 42:09.570
但是有没有重新渲染

42:09.570 --> 42:10.570
没有

42:10.570 --> 42:11.570
它没有重新构建

42:11.570 --> 42:12.570
虚拟洞

42:12.570 --> 42:14.570
虚拟洞没有重新构建

42:14.570 --> 42:15.570
所以说

42:15.570 --> 42:17.570
它导致了状态不一致

42:17.570 --> 42:19.570
导致了状态不一致

42:19.570 --> 42:21.570
但是我们是可以这样子玩的

42:21.570 --> 42:25.140
这是个性能优化点

42:25.140 --> 42:28.140
这是关于shootComponentUpdate

42:28.140 --> 42:30.140
我这里把它改回去

42:30.140 --> 42:32.140
State.n

42:32.140 --> 42:35.140
加1

42:35.140 --> 42:38.140
这是这么一个生命周期

42:38.140 --> 42:39.140
好

42:39.140 --> 42:40.140
下一个

42:40.140 --> 42:41.140
如果是force一看

42:41.140 --> 42:43.140
它就直接结束了

42:43.140 --> 42:45.140
如果它反回的是q的话

42:45.140 --> 42:46.140
那么这个时候

42:46.140 --> 42:48.140
它又会运行这么一些东西

42:48.140 --> 42:51.140
一个是ComponentWealUpdate

42:51.140 --> 42:53.140
即将重新渲染

42:53.140 --> 42:54.140
说实话

42:54.140 --> 42:55.140
这个函数没啥用

42:55.140 --> 42:56.140
没有啥用

42:56.140 --> 42:58.140
所以说这个东西了解一下就行了

42:58.140 --> 42:59.140
了解一下就行了

42:59.140 --> 43:00.140
没啥用的

43:00.140 --> 43:02.140
这里面很多生命周期函数

43:02.140 --> 43:04.140
不是我们重点

43:05.140 --> 43:06.140
面试题也不会考

43:06.140 --> 43:07.140
放心吧

43:07.140 --> 43:08.140
真的放心

43:08.140 --> 43:09.140
我说放心就放心

43:09.140 --> 43:10.140
这东西就是

43:10.140 --> 43:12.140
即将主见

43:12.140 --> 43:15.140
即将被重新渲染

43:15.140 --> 43:16.140
即将被重新渲染

43:16.140 --> 43:18.140
是运行这个函数

43:18.140 --> 43:21.830
咱们来看一下吧

43:21.830 --> 43:24.830
ComponentWealUpdate

43:29.830 --> 43:30.830
就这个

43:30.830 --> 43:32.830
它里边也可以得到

43:32.830 --> 43:33.830
下一个状态

43:33.830 --> 43:34.830
下一个属性

43:34.830 --> 43:37.830
这里我们就打印就行了

43:37.830 --> 43:42.740
这里我们写上

43:42.740 --> 43:44.740
主见

43:44.740 --> 43:47.740
即将被重新渲染

43:47.740 --> 43:49.740
即将被重新渲染

43:49.740 --> 43:51.740
保存

43:51.740 --> 43:52.740
好

43:52.740 --> 43:53.740
这里我们点击

43:53.740 --> 43:54.740
点击

43:54.740 --> 43:55.740
你看

43:55.740 --> 43:56.740
主见即将被重新渲染

43:56.740 --> 43:57.740
是不是运行的

43:57.740 --> 43:59.740
它在Render之前运行

44:01.740 --> 44:02.740
下边

44:02.740 --> 44:03.740
这个就很

44:03.740 --> 44:05.740
就是我们之前反复强调过的

44:05.740 --> 44:07.740
最终它会运行Render

44:07.740 --> 44:08.740
重新渲染

44:08.740 --> 44:09.740
这个没什么好说的

44:09.740 --> 44:10.740
只要它渲染了

44:10.740 --> 44:12.740
你看它就会运行Render

44:12.740 --> 44:14.740
反而是我们页面的

44:14.740 --> 44:16.740
看到的东西发生了变化

44:16.740 --> 44:18.740
它一定是运行Render

44:18.740 --> 44:20.740
重新构建了虚拟动物数

44:22.740 --> 44:23.740
最后一个函数

44:23.740 --> 44:25.740
更新阶段的最后一个函数

44:25.740 --> 44:27.740
叫做ComponentWealUpdate

44:27.740 --> 44:29.740
这个东西还蛮有用的

44:29.740 --> 44:31.740
不过目前

44:31.740 --> 44:32.740
目前我们倒是用不上

44:32.740 --> 44:34.740
以后我们会用上

44:34.740 --> 44:39.740
ComponentWealUpdate

44:45.740 --> 44:47.740
咱们打印一下

44:47.740 --> 44:49.740
它提供了两个属性

44:49.740 --> 44:51.740
我们看一下这两个属性是什么

44:51.740 --> 44:53.740
已经完成重新渲染

44:53.740 --> 44:56.740
已完成重新渲染

44:56.740 --> 44:57.740
这两个属性我们看一下

44:57.740 --> 45:01.740
PriorPropsPriorState

45:01.740 --> 45:03.740
就是重新渲染完成之后

45:03.740 --> 45:05.740
它的属性有已经改变了

45:05.740 --> 45:07.740
我们来看一下

45:07.740 --> 45:09.740
点击状态

45:09.740 --> 45:11.740
我们可以看到

45:11.740 --> 45:13.740
重新刷新是

45:13.740 --> 45:14.740
点击状态

45:14.740 --> 45:17.740
我们看到状态改变了

45:17.740 --> 45:19.740
状态变成1了

45:19.740 --> 45:21.740
它现在得到状态是0

45:21.740 --> 45:22.740
为什么是0呢

45:22.740 --> 45:25.740
因为它可以得到之前的状态

45:25.740 --> 45:27.740
可以得到之前的状态

45:27.740 --> 45:29.740
包括属性也是一样

45:29.740 --> 45:30.740
我们点击N加1

45:30.740 --> 45:32.740
这是改变属性

45:32.740 --> 45:33.740
N加1过后你看这里

45:33.740 --> 45:36.740
得到之前的N等于1

45:36.740 --> 45:38.740
N等于1

45:38.740 --> 45:41.740
点击得到之前的属性1

45:41.740 --> 45:43.740
现在属性1变成2了

45:43.740 --> 45:44.740
因为在这个时候

45:44.740 --> 45:46.740
你再去获取Zis.Props

45:46.740 --> 45:47.740
它已经变化了

45:47.740 --> 45:48.740
它在Render过后

45:48.740 --> 45:50.740
它就已经变化了

45:50.740 --> 45:52.740
所以我们可以在这个函数里边

45:52.740 --> 45:53.740
得到之前的属性

45:53.740 --> 45:54.740
之前的状态

45:54.740 --> 45:55.740
这个函数

45:55.740 --> 45:57.740
我们现在

45:57.740 --> 46:00.740
确实我不好解释有什么意义

46:00.740 --> 46:02.740
它往往会做一些什么事呢

46:02.740 --> 46:03.740
这个函数

46:03.740 --> 46:04.740
我这里说一下吧

46:04.740 --> 46:06.740
它往往会做一些什么事

46:06.740 --> 46:08.740
它名字叫做

46:08.740 --> 46:12.060
ComponentDidUpdate

46:12.060 --> 46:16.560
往往

46:16.560 --> 46:20.560
往往

46:20.560 --> 46:26.190
在该函数中

46:26.190 --> 46:28.190
使用动物

46:28.190 --> 46:30.190
使用动物操作

46:30.190 --> 46:32.190
改变

46:32.190 --> 46:34.190
改变一些元素

46:34.190 --> 46:35.190
就是我们在这里

46:35.190 --> 46:36.190
可以使用一些

46:36.190 --> 46:37.190
添加一些动物操作

46:37.190 --> 46:38.190
来改变一些元素

46:38.190 --> 46:39.190
就你旋转完成过后

46:39.190 --> 46:40.190
有些元素

46:40.190 --> 46:41.190
会跟着发生变化

46:41.190 --> 46:42.190
我们可能在这里面

46:42.190 --> 46:44.190
可能要去完成一下

46:44.190 --> 46:46.190
所以说我们这里个函数

46:46.190 --> 46:48.190
有的时候还是有点用的

46:48.190 --> 46:50.190
但是我们没有把它当成重点

46:50.190 --> 46:51.190
没有把它当成重点

46:51.190 --> 46:52.190
它的重要程度

46:52.190 --> 46:53.190
肯定没有我前面说的

46:53.190 --> 46:55.190
这几个函数高

46:55.190 --> 46:57.190
这是这么一个函数

46:57.190 --> 46:59.190
这是更新阶段

46:59.190 --> 47:01.190
更新阶段完成过后

47:01.190 --> 47:02.190
最后

47:02.190 --> 47:03.190
就是每一次发生变化

47:03.190 --> 47:04.190
它都要全部流程

47:04.190 --> 47:06.190
就要全部走一遍

47:06.190 --> 47:08.190
然后最后就是销毁阶段

47:08.190 --> 47:10.190
什么时候主键会销毁了

47:10.190 --> 47:11.190
就是这个主键

47:11.190 --> 47:13.190
从虚拟动物数里边

47:13.190 --> 47:14.190
移除的时候

47:14.190 --> 47:15.190
它就会销毁

47:15.190 --> 47:16.190
它不是看不见

47:16.190 --> 47:17.190
千万不要认为是看不见

47:17.190 --> 47:18.190
比较说你把设为

47:18.190 --> 47:19.190
Display Lang

47:19.190 --> 47:20.190
它不会销毁的

47:20.190 --> 47:21.190
主键还在

47:21.190 --> 47:22.190
我说的是

47:22.190 --> 47:23.190
这个主键

47:23.190 --> 47:25.190
从动物数里边移除掉

47:25.190 --> 47:26.190
你看这个

47:26.190 --> 47:27.190
不是个动物数吗

47:27.190 --> 47:28.190
数型结构

47:28.190 --> 47:29.190
从动物数型结构里边

47:29.190 --> 47:30.190
把移除掉的时候

47:30.190 --> 47:32.190
这个主键就被销毁了

47:32.190 --> 47:33.190
那么咱们来举个例子

47:33.190 --> 47:35.190
这个主键什么时候被销毁了

47:35.190 --> 47:36.190
我们看一下

47:36.190 --> 47:38.190
在这边

47:39.190 --> 47:40.190
这里的状态

47:40.190 --> 47:43.190
我们再给它写个

47:43.190 --> 47:44.190
写个状态

47:47.190 --> 47:49.190
然后我们这里判断一下

47:49.190 --> 47:52.190
这里写个辨量

47:52.190 --> 47:54.190
写个Comp

47:54.190 --> 47:55.190
就是说

47:55.190 --> 47:57.190
如果ZsStats

47:57.190 --> 47:59.190
的Show为True的话

47:59.190 --> 48:00.190
为True的话

48:00.190 --> 48:01.190
我就给它复制为这个

48:01.190 --> 48:03.190
我给它复制为这个

48:03.190 --> 48:04.190
否则的话

48:04.190 --> 48:06.190
给它复制为Null

48:06.190 --> 48:08.190
写这么一个东西

48:08.190 --> 48:09.190
它有可能是Null

48:09.190 --> 48:10.190
有可能是这个东西

48:10.190 --> 48:12.190
OK 我把这个东西显示到这

48:14.190 --> 48:17.630
然后再加一个按钮

48:17.630 --> 48:20.630
显示隐藏

48:20.630 --> 48:22.630
显示隐藏按钮

48:22.630 --> 48:23.630
然后点击这个按钮

48:23.630 --> 48:24.630
给它做这个事件

48:24.630 --> 48:28.330
这个事件里面很简单

48:28.330 --> 48:30.330
就是ZsStats

48:30.330 --> 48:31.330
设置什么呢

48:31.330 --> 48:32.330
Show

48:32.330 --> 48:33.330
为什么

48:33.330 --> 48:34.330
相反取反

48:34.330 --> 48:36.330
取反

48:36.330 --> 48:37.330
取反就完事了

48:37.330 --> 48:38.330
它之前是True

48:38.330 --> 48:40.330
把它变成Force

48:40.330 --> 48:41.330
之前是Force

48:41.330 --> 48:42.330
把它变成True

48:42.330 --> 48:44.330
这是这么一个东西

48:44.330 --> 48:45.330
我们这里写着

48:45.330 --> 48:47.330
然后把生命周期函数给它加上

48:47.330 --> 48:49.330
叫做Component

48:51.330 --> 48:53.330
Wheel Amount

48:55.330 --> 48:57.330
逐渐被销毁

48:57.330 --> 49:00.330
逐渐被销毁

49:00.330 --> 49:06.260
保存

49:07.260 --> 49:08.260
那么这里

49:12.020 --> 49:13.020
隐藏

49:13.020 --> 49:15.020
你看是不是这个组件被销毁了

49:15.020 --> 49:17.020
那么下一次在显示的时候

49:17.020 --> 49:18.020
就是这个人

49:18.020 --> 49:20.020
这个组件已经被他杀死了

49:20.020 --> 49:21.020
他已经没了

49:21.020 --> 49:23.020
已经把它从这个世界上干掉了

49:23.020 --> 49:25.020
那么下一次在显示的时候

49:25.020 --> 49:26.020
你看

49:26.020 --> 49:28.020
一个新的组件单身了

49:29.020 --> 49:31.020
因为之前的虚计动物数

49:31.020 --> 49:32.020
里边没有这个组件了

49:32.020 --> 49:33.020
那现在又加上了

49:33.020 --> 49:34.020
是不是一个新的组件单身了

49:34.020 --> 49:36.020
然后再点击又把它杀死

49:36.020 --> 49:38.020
这个新单身的婴儿又把它杀死

49:38.020 --> 49:39.020
你看

49:39.020 --> 49:40.020
现在这个虚计动物数里边

49:40.020 --> 49:41.020
你看一下有没有这个组件

49:41.020 --> 49:42.020
没有

49:42.020 --> 49:43.020
没有 只有这种情况下

49:43.020 --> 49:44.020
它才会销毁

49:44.020 --> 49:45.020
才会销毁

49:45.020 --> 49:46.020
你看这个意思吧

49:46.020 --> 49:48.020
它不是说我们看不见就会销毁

49:48.020 --> 49:49.020
而是

49:50.020 --> 49:52.020
它在虚计动物数里边不存在了

49:52.020 --> 49:53.020
它才会销毁

49:53.020 --> 49:54.020
是这么个意思

49:55.020 --> 49:56.020
这就是销毁组件

49:57.020 --> 49:58.020
这个函数蛮用用的

49:59.020 --> 50:00.020
所以说要加出

50:02.020 --> 50:05.100
这个函数蛮用用的

50:05.100 --> 50:06.100
它来做什么了

50:09.100 --> 50:10.100
通常

50:11.100 --> 50:13.100
通常在该函数中

50:14.100 --> 50:15.100
该函数中

50:16.100 --> 50:19.100
销毁一些组件

50:20.100 --> 50:21.100
依赖的资源

50:22.100 --> 50:23.100
比如

50:23.100 --> 50:24.100
计时器

50:25.100 --> 50:26.100
比如计时器

50:26.100 --> 50:27.100
比方说我们写个计时器

50:27.100 --> 50:29.100
或者是一个倒计时期

50:29.100 --> 50:30.100
反正我们使用了一些

50:30.100 --> 50:31.100
什么set timeout

50:31.100 --> 50:32.100
set interval

50:32.100 --> 50:33.100
这些计时器

50:33.100 --> 50:35.100
你把组件已经不存在了

50:35.100 --> 50:36.100
但是计时器在不在

50:36.100 --> 50:37.100
计时器在不在

50:37.100 --> 50:38.100
它还在

50:38.100 --> 50:39.100
它怎么可能自动停止

50:39.100 --> 50:40.100
它还在

50:40.100 --> 50:42.100
所以说你应该在这里

50:42.100 --> 50:43.100
在组件销毁的时候

50:43.100 --> 50:44.100
这个组件都不兼

50:44.100 --> 50:45.100
哪里还能有这个计时器

50:45.100 --> 50:46.100
不能有了

50:47.100 --> 50:48.100
它是依赖这个组件的

50:48.100 --> 50:49.100
所以说

50:49.100 --> 50:50.100
这个时候

50:50.100 --> 50:51.100
你要把计时器干清除掉

50:52.100 --> 50:53.100
因此我们会在这里

50:53.100 --> 50:54.100
进行处理

50:55.100 --> 50:56.100
通常我们就在这里

50:56.100 --> 50:57.100
进行处理

50:57.100 --> 50:58.100
销毁计时器这些东西

50:59.100 --> 51:01.100
这就是一个旧版的生命周期

51:01.100 --> 51:03.100
整个组件的过程就是这样子

51:03.100 --> 51:04.100
注意关键点

51:04.100 --> 51:05.100
关键点

51:05.100 --> 51:07.100
就是只有这么几个

51:07.100 --> 51:08.100
Render 渲染函数

51:08.100 --> 51:09.100
这个要知道

51:09.100 --> 51:10.100
这个我们反复提起的

51:10.100 --> 51:11.100
也没什么好说的

51:11.100 --> 51:13.100
第二个就是Component Deed Mount

51:13.100 --> 51:15.100
这里面我们通常会

51:15.100 --> 51:16.100
开启一些网络请求

51:16.100 --> 51:17.100
启动计时器

51:17.100 --> 51:18.100
这些操作

51:18.100 --> 51:19.100
往往会启到这里面

51:19.100 --> 51:20.100
然后这个东西

51:20.100 --> 51:21.100
是个性能优化点

51:21.100 --> 51:22.100
我们以后

51:22.100 --> 51:23.100
讲到一些东西的时候

51:23.100 --> 51:25.100
还会反复提起

51:25.100 --> 51:27.100
我们现在可能用的比较少一点

51:27.100 --> 51:28.100
然后这个东西

51:28.100 --> 51:29.100
就是销毁的组件的时候

51:29.100 --> 51:30.100
你要注意

51:30.100 --> 51:33.100
可能可以在这里面

51:33.100 --> 51:34.100
去清除一些资源

51:35.100 --> 51:36.100
相应的资源

51:37.100 --> 51:39.100
这就是一个旧版的生命周期

51:40.100 --> 51:41.100
我看时间也差不多了

51:41.100 --> 51:43.100
讲了快将近一个小时了

51:43.100 --> 51:45.100
那咱们要不然就休息会吧

51:45.100 --> 51:46.100
因为生命周期

51:46.100 --> 51:47.100
这里面的支持很多

51:47.100 --> 51:48.100
咱们休息会吧

51:48.100 --> 51:51.100
我把这些课分成两部分

51:51.100 --> 51:52.100
那么以后

51:52.100 --> 51:53.100
下节课我们来讲

51:53.100 --> 51:54.100
新版的生命周期

51:54.100 --> 51:55.100
好吧

51:55.100 --> 51:56.100
休息会

