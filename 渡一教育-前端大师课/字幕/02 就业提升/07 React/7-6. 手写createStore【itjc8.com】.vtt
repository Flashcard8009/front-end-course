WEBVTT

00:01.010 --> 00:04.110
这一刻咱们来学习Redux的圆码

00:04.730 --> 00:07.430
为什么这么早就开始讲圆码呢

00:07.430 --> 00:10.390
Redux里边其实还有一些东西还没有讲

00:11.170 --> 00:14.130
这么早讲圆码呢 主要因为这个Redux

00:14.130 --> 00:17.270
它首先圆码是很简单的 并不复杂

00:17.270 --> 00:20.430
另一个地方是因为我们早一点讲圆码

00:20.430 --> 00:24.130
因为它不复杂 所以很快就讲完了

00:24.130 --> 00:28.830
还有一个原因就是如果说我后边再讲圆码的话

00:28.990 --> 00:34.090
在讲到中间键的一块 很多同学对那一块理解的就很模糊

00:34.090 --> 00:36.270
会非常非常模糊 不太透彻

00:36.270 --> 00:38.090
所以说我们早一点讲圆码

00:38.090 --> 00:40.590
方便后面讲中间键的时候

00:40.590 --> 00:43.270
我们又直接把个中间键的圆码也跟着讲了

00:43.630 --> 00:45.810
因为它本身就比较简单

00:45.810 --> 00:48.270
相对于ReduxRotor来说的话

00:48.270 --> 00:52.270
它的圆码 代码量要少很多 非常非常多

00:53.470 --> 00:55.750
行 那咱们就开始吧

00:55.750 --> 00:58.590
这里我把目录结构做了一点改动

00:58.630 --> 01:01.430
就是我们之前这个目录是Redux这个目录

01:01.430 --> 01:04.750
我这里把它变成了一个Store 表示我们的数据仓库

01:04.750 --> 01:09.430
这里面有什么Ightion Reducer 还有就是创建Redux的仓库这些东西

01:09.430 --> 01:12.150
对不对 我们把目录结构做了一点改动

01:12.150 --> 01:13.230
为什么做一点改动呢

01:13.230 --> 01:17.350
因为我一会要写圆码 圆码的一个目录名字叫做Redux

01:17.350 --> 01:21.030
所以说之前Redux的目录名字把我的目录名字给我占用了

01:21.030 --> 01:25.550
所以说改动一下 圆码这一些课咱们就来实现

01:25.550 --> 01:28.270
因为Redux里面还就是给你提供了一些函数

01:28.310 --> 01:32.030
对吧 我们这里用了最多的就是CreateStore这个函数

01:32.030 --> 01:35.550
那么这几课咱们就来实现CreateStore这个函数

01:37.870 --> 01:41.590
实现CreateStore函数

01:41.590 --> 01:44.470
那么这个函数里面 它会返回一个对象 对吧

01:44.470 --> 01:46.870
我们之前也看到过 它返回什么对象呢

01:46.870 --> 01:50.390
它返回了一个对象里面 它返回了有这么一些东西 对不对

01:50.390 --> 01:51.550
咱们再来看一下吧

01:51.550 --> 01:55.510
这个CreateStoreStore这个函数 它返回一个对象

01:56.510 --> 01:58.350
返回一个对象

01:58.350 --> 01:59.950
这个对象里面有这么一些东西

01:59.950 --> 02:03.190
Dispatch, GetState, ReplaceReducer, Subscribe

02:03.190 --> 02:03.870
还有一个什么呢

02:03.870 --> 02:05.830
还有一个就是 我们上去看了一下

02:05.830 --> 02:08.430
就看了一下 是一个Simple

02:08.430 --> 02:09.750
Simple

02:09.750 --> 02:11.510
这个Simple里面是一个Observer

02:14.990 --> 02:16.470
这个咋写呢

02:16.470 --> 02:18.150
我看一下吧

02:18.150 --> 02:19.590
看一下

02:19.910 --> 02:23.550
YoursStart

02:23.550 --> 02:25.710
这个单词咋写的呢

02:25.710 --> 02:27.550
叫做观察者

02:27.550 --> 02:28.950
我看一下吧

02:28.950 --> 02:30.630
看一下再说吧

02:30.630 --> 02:32.230
看一下那个Observer

02:32.230 --> 02:36.070
Observer就是我们这里不会返回的对象呢

02:36.070 --> 02:37.790
尽量的跟它差不多

02:37.790 --> 02:39.110
跟那个原码差不多

02:39.110 --> 02:41.430
反过来

02:41.430 --> 02:43.350
但是有些地方我们就不去实现了

02:43.350 --> 02:45.710
比方说这个东西 其实实现也很简单

02:45.710 --> 02:46.590
只不过呢

02:46.590 --> 02:48.190
实现没有什么意义

02:48.190 --> 02:50.750
因为我们平时也用不到

02:50.750 --> 02:51.550
你看一下吧

02:51.550 --> 02:52.910
这个里面不就是这些东西吗

02:52.910 --> 02:53.350
还有啥呢

02:53.350 --> 02:53.830
没了

02:53.830 --> 02:55.030
就这么几个函数

02:55.030 --> 02:56.750
对 全是函数

02:56.750 --> 02:58.870
这个Reducer

02:58.870 --> 03:00.510
这个东西我们平时用不到

03:00.510 --> 03:02.270
可以这个东西不用去我们管了

03:02.270 --> 03:03.310
不用我们管了

03:03.310 --> 03:04.270
这个Simple呢

03:04.270 --> 03:06.390
它这个是Observer

03:06.390 --> 03:07.550
Observer

03:07.550 --> 03:08.510
这个玩意是啥呢

03:08.510 --> 03:11.390
这个玩意其实它是跟那个

03:11.390 --> 03:12.790
多说两句吧

03:12.790 --> 03:14.470
它现在的ES

03:14.470 --> 03:15.510
就是EchemaScript

03:15.510 --> 03:16.750
它有个提案

03:16.790 --> 03:18.190
就是Observer

03:18.190 --> 03:21.190
这种提案是一个新的一个构造函数

03:21.190 --> 03:22.470
叫做Observer

03:22.470 --> 03:25.550
能够实现观察者模式

03:25.550 --> 03:27.110
那么什么叫观察者模式呢

03:27.110 --> 03:29.350
我们一会讲的过程中

03:29.350 --> 03:31.390
就比较讲监听器的时候

03:31.390 --> 03:33.310
就会用到这个观察者模式

03:33.310 --> 03:35.190
以后能讲的时候再具体的说

03:35.190 --> 03:36.470
这个Observer

03:36.470 --> 03:38.350
就是它提供这么一个就是

03:38.350 --> 03:39.990
提供这么一个函数

03:39.990 --> 03:42.030
用一个Simple来表示

03:42.030 --> 03:44.630
为什么还要用Simple来表示呢

03:44.630 --> 03:45.630
意思就是说

03:45.670 --> 03:46.790
现在呢

03:46.790 --> 03:48.990
一时半会还用不上这个玩意

03:48.990 --> 03:50.030
将来呢

03:50.030 --> 03:51.030
可能用得上

03:51.030 --> 03:52.590
他先把它写出来了

03:52.590 --> 03:54.190
因为ES里边一个提案

03:54.190 --> 03:55.750
就是Observer提案

03:55.750 --> 03:58.510
那个提案目前还是草案阶段

03:58.510 --> 04:00.230
还没有成为正式的标准

04:00.230 --> 04:01.230
所以说这一块

04:01.230 --> 04:03.150
我们目前也可以不用管

04:03.150 --> 04:04.990
等它以后成为正式标准的时候

04:04.990 --> 04:06.230
我在这个课程里边

04:06.230 --> 04:07.470
给大家更新一下

04:07.470 --> 04:08.990
给大家做个补充

04:08.990 --> 04:10.350
实际上目前还有个库

04:10.350 --> 04:11.710
叫做RXJS

04:11.710 --> 04:12.830
不知道大家听说过没有

04:13.830 --> 04:16.430
这个库东西还蛮多的

04:16.430 --> 04:17.710
东西非常非常多

04:17.710 --> 04:21.710
这个你可以把它理解成为一个JS的增强库

04:21.710 --> 04:23.590
它增强了很多的JS功能

04:23.590 --> 04:24.870
这个库呢

04:24.870 --> 04:26.990
我们看今后有没有机会吧

04:26.990 --> 04:27.670
我给大家讲

04:27.670 --> 04:28.430
可以给大家讲

04:28.430 --> 04:29.550
RXJS

04:29.550 --> 04:31.910
学习曲线还是蛮抖翘的这个玩意

04:31.910 --> 04:32.830
这个里边呢

04:32.830 --> 04:35.070
它已经实现了观察的模式了

04:35.070 --> 04:36.950
如果说你用这个库的话

04:36.950 --> 04:38.670
你可能会用到这个东西

04:38.670 --> 04:39.830
可能会用到这个东西

04:39.830 --> 04:40.630
但是目前呢

04:40.630 --> 04:42.910
我们没有学习一个库之前

04:42.910 --> 04:44.430
已经学习ES

04:44.430 --> 04:46.550
ES的OBREVERB

04:46.550 --> 04:47.590
还没有成为标准之前

04:47.590 --> 04:48.590
这东西暂时用不到

04:48.590 --> 04:49.230
所以这个话呢

04:49.230 --> 04:50.550
我们也把它去掉

04:50.550 --> 04:51.630
也就是我们现在呢

04:51.630 --> 04:53.190
就是这个CREATE STONE里边的

04:53.190 --> 04:54.270
它就返回一个对象

04:54.270 --> 04:56.030
这个对象里边有三个函数

04:56.030 --> 04:57.950
我们把这三个函数实现就完成了

04:57.950 --> 04:59.230
其实就这么简单

04:59.230 --> 05:00.310
没啥了

05:00.310 --> 05:01.310
那么在RXJS里边

05:01.310 --> 05:04.110
我们来新建一个新建个文件

05:04.110 --> 05:06.630
给它取名为CREATE STONE

05:06.630 --> 05:08.710
点儿介绍

05:08.910 --> 05:10.910
这个文件里面我们返回一个啥呢

05:10.910 --> 05:13.470
返回一个就是方形

05:13.470 --> 05:14.430
返回一个函数

05:14.430 --> 05:15.030
这个函数呢

05:15.030 --> 05:17.750
就是实现CREATE STONE的功能

05:17.750 --> 05:21.830
实现CREATE STONE的功能

05:21.830 --> 05:22.870
看一下怎么实现

05:22.870 --> 05:23.670
其实非常简单

05:23.670 --> 05:25.070
你会发现RXJS

05:25.070 --> 05:27.790
其实这个库本身就非常非常简单

05:27.790 --> 05:29.310
实现这个功能就行了

05:29.310 --> 05:30.590
然后的话

05:30.590 --> 05:32.350
我在这里再加个index

05:32.350 --> 05:34.230
加个index叫JS

05:34.230 --> 05:35.670
那么加上这个JS过后

05:35.750 --> 05:38.790
我们在这里导出一下

05:38.790 --> 05:39.830
export

05:43.510 --> 05:45.950
把这个CREATE STONE导入

05:45.950 --> 05:49.190
这种做法其实在我们之前学的那个

05:49.190 --> 05:51.190
学那个就是Rect

05:51.190 --> 05:53.230
Rect Rotor的手术也做过类似的做法

05:53.230 --> 05:53.710
对吧

05:53.710 --> 05:57.430
把它的默认导出

05:57.430 --> 05:58.870
重新导出一下

05:58.870 --> 06:00.310
再换取个名字

06:00.310 --> 06:01.270
叫CREATE STONE

06:02.270 --> 06:02.750
好了

06:02.750 --> 06:04.510
咱们这里就写了这么一个index

06:04.510 --> 06:05.510
入口文件

06:05.670 --> 06:08.350
然后我们在我们之前写的代码里面

06:08.350 --> 06:09.350
在之前写的代码里面

06:09.350 --> 06:10.710
我们就不再使用这种方式

06:10.710 --> 06:12.590
再导入我们的CREATE STONE了

06:12.590 --> 06:14.390
我们导入我们自己的CREATE STONE

06:14.390 --> 06:15.510
导入自己的

06:15.510 --> 06:16.190
就行了

06:16.190 --> 06:18.190
当然现在看不出来任何效果

06:18.190 --> 06:19.230
而且这里的

06:19.230 --> 06:20.070
看一下

06:20.070 --> 06:21.630
Major Not Found

06:21.630 --> 06:24.310
我们的模块是没有找到的

06:24.310 --> 06:25.590
没有找到这个模块

06:25.590 --> 06:26.910
他说啥呢

06:26.910 --> 06:27.990
他说

06:27.990 --> 06:30.190
Kana Resolve

06:30.190 --> 06:31.430
这里的我们的

06:31.430 --> 06:32.510
返回上级目录

06:32.510 --> 06:33.870
返回上级目录

06:33.950 --> 06:35.030
找到Retounce

06:36.190 --> 06:37.470
那么现在肯定要抱错

06:37.470 --> 06:39.310
因为这些函数都不存在

06:39.310 --> 06:40.270
对吧

06:40.270 --> 06:41.550
对函数都不存在

06:42.550 --> 06:42.790
好

06:42.790 --> 06:44.550
那么现在我们就开始来写这个东西

06:44.550 --> 06:45.950
开始来写这个东西

06:46.950 --> 06:48.070
首先这个CREATE STONE

06:48.070 --> 06:49.790
我们经过之前的使用

06:49.790 --> 06:51.110
我们知道这个函数本身

06:51.110 --> 06:52.790
它要提供两个参数

06:52.790 --> 06:53.950
第一个参数是啥呢

06:53.950 --> 06:55.350
第一个参数是不是Reducer

06:55.350 --> 06:55.830
对吧

06:55.830 --> 06:57.190
就是个Reducer

06:57.190 --> 06:58.270
第二参数是什么呢

06:58.270 --> 07:01.190
第二参数就是默认值

07:01.190 --> 07:02.550
默认的状态值

07:02.630 --> 07:04.990
我们可以用个DefaultState

07:05.990 --> 07:07.110
打上注释

07:07.110 --> 07:08.390
第一个参数

07:08.390 --> 07:10.670
第一个参数就是一个内详式一个方形

07:12.310 --> 07:12.670
方形

07:14.230 --> 07:16.510
就是Reducer这个参数

07:16.510 --> 07:17.630
那么它是一个就是

07:17.630 --> 07:18.310
指的是什么意思

07:18.310 --> 07:19.590
就是Reducer

07:19.590 --> 07:21.070
就是Reducer的意思

07:21.070 --> 07:21.270
好

07:21.270 --> 07:22.750
第二个参数呢

07:22.750 --> 07:24.510
大家注释

07:24.510 --> 07:26.830
内询是一个

07:26.830 --> 07:28.630
任意内询

07:28.630 --> 07:29.310
任意内询

07:29.310 --> 07:30.990
我们这里的参数

07:30.990 --> 07:34.670
它的意思是默认的状态值

07:34.670 --> 07:36.430
默认的状态值

07:36.430 --> 07:37.670
你要给我这么两个参数

07:37.670 --> 07:38.310
对吧

07:38.310 --> 07:39.390
第一个参数是必须的

07:39.390 --> 07:40.030
第二个参数呢

07:40.030 --> 07:40.910
倒无所谓

07:40.910 --> 07:41.790
这个参数倒无所谓

07:41.790 --> 07:42.510
你不传递

07:42.510 --> 07:43.150
你不传递的话

07:43.150 --> 07:44.590
也无所谓

07:44.590 --> 07:45.910
这是这一块

07:45.910 --> 07:46.830
最后会返回

07:46.830 --> 07:48.270
是不是会返回个对象

07:48.270 --> 07:48.790
对吧

07:48.790 --> 07:49.830
对对象里面拥有啥

07:49.830 --> 07:51.350
拥有什么Dispatch

07:51.350 --> 07:51.710
对吧

07:51.710 --> 07:53.070
拥有什么getState

07:53.070 --> 07:53.670
对不对

07:53.670 --> 07:54.390
还有什么呢

07:54.390 --> 07:56.790
subscribe

07:56.790 --> 07:57.950
对吧

07:57.950 --> 07:59.990
一共就提供这么三个函数

07:59.990 --> 08:00.750
那么这三个函数

08:00.790 --> 08:02.390
我们挨着再把它写出来就完了

08:02.390 --> 08:03.870
Dispatch

08:03.870 --> 08:05.390
Dispatch这个函数

08:05.390 --> 08:06.270
然后呢

08:06.270 --> 08:07.510
getState这个函数

08:07.510 --> 08:09.630
咱们在这里把写出来

08:09.630 --> 08:10.550
然后呢

08:10.550 --> 08:11.070
放个情

08:11.070 --> 08:14.350
subscribe

08:16.230 --> 08:17.790
我们以后一会慢慢来实现

08:17.790 --> 08:18.870
不着急

08:22.230 --> 08:23.190
那么这里又爆错了

08:23.190 --> 08:24.910
但是你看到打印这个stone

08:24.910 --> 08:26.590
是不是已经有这三个函数了

08:26.590 --> 08:27.350
对吧

08:27.350 --> 08:28.510
最常用的这三个函数

08:28.590 --> 08:29.950
我们平时要用到的这三个函数

08:29.950 --> 08:30.710
都在这了

08:30.710 --> 08:31.910
咱们一个个来实现

08:32.790 --> 08:32.990
好

08:32.990 --> 08:34.030
首先呢

08:34.030 --> 08:34.750
我们这里

08:34.750 --> 08:36.590
它不是给了一个reducer吗

08:36.590 --> 08:38.790
不是给了你一个default state吗

08:38.790 --> 08:39.270
对吧

08:39.270 --> 08:40.430
给了你一个reducer

08:40.430 --> 08:41.470
一个default state

08:41.470 --> 08:42.670
我们来回忆一下

08:42.670 --> 08:43.870
咱们stone要干嘛

08:43.870 --> 08:45.510
是不是到时候分发action的时候

08:45.510 --> 08:48.310
要把action和状态要传给这个

08:48.310 --> 08:48.990
对吧

08:48.990 --> 08:49.710
然后呢

08:49.710 --> 08:51.270
这个reducer得到数据过后

08:51.270 --> 08:53.030
是不是要把状态重新保存

08:53.030 --> 08:54.190
因此的这个stone

08:54.190 --> 08:55.230
这个对象里面呢

08:55.230 --> 08:56.310
是不是要保存什么

08:56.310 --> 08:57.950
保存当前的状态

08:57.990 --> 08:59.310
以及当前的reducer

08:59.310 --> 08:59.750
对不对

08:59.750 --> 09:01.030
要保存这个东西

09:01.030 --> 09:01.870
这个很简单

09:01.870 --> 09:03.790
咱们这里写上这么两个变量

09:03.790 --> 09:06.030
一个是current reducer

09:07.030 --> 09:08.110
current reducer

09:08.110 --> 09:09.550
表示当前的reducer

09:09.550 --> 09:10.430
来自于这

09:11.190 --> 09:14.070
一个是current state

09:14.070 --> 09:15.190
当前的状态

09:15.190 --> 09:16.750
来自于什么默认状态

09:16.750 --> 09:17.070
对吧

09:17.070 --> 09:18.630
我们先把这两个变量写出来

09:18.630 --> 09:19.430
这个是什么意思

09:19.430 --> 09:21.070
打上个注释

09:21.070 --> 09:22.270
这个表示的是

09:22.270 --> 09:23.550
当前的

09:23.550 --> 09:25.870
当前使用的reducer

09:25.870 --> 09:27.670
就咱们仓库使用的reducer

09:27.750 --> 09:29.190
因为当时我要去调用reducer

09:29.190 --> 09:29.990
我得把我升起来

09:29.990 --> 09:30.950
不然我得什么调用了

09:30.950 --> 09:31.310
对吧

09:31.310 --> 09:32.950
保存这个reducer

09:32.950 --> 09:34.110
其实你可以想象一下

09:34.110 --> 09:36.150
如果说要替换reducer的话

09:36.150 --> 09:37.830
你把这个变量直接换就完事了

09:37.830 --> 09:38.590
就这么简单

09:38.590 --> 09:39.270
就这么简单

09:39.270 --> 09:40.590
非常简单

09:40.590 --> 09:41.830
那么这个东西是

09:41.830 --> 09:43.270
当前

09:43.270 --> 09:46.590
当前仓库中的状态

09:46.590 --> 09:46.990
对吧

09:46.990 --> 09:48.790
当前仓库中的状态

09:48.790 --> 09:49.310
没有

09:49.310 --> 09:50.750
没有

09:50.750 --> 09:53.070
写这么两个变量

09:53.070 --> 09:55.790
然后一个个来说

09:55.870 --> 09:58.270
首先是dispatch

09:58.270 --> 10:00.470
dispatch这个函数要干嘛呢

10:00.470 --> 10:02.470
是不是要传一个x型进来

10:02.470 --> 10:04.790
dispatch这个函数是不是要传一个x型

10:04.790 --> 10:05.190
对吧

10:05.190 --> 10:05.830
你还能干嘛

10:05.830 --> 10:08.430
你不得给我传一个x型

10:08.430 --> 10:09.310
对不对

10:09.310 --> 10:10.990
你给我传一个x型

10:10.990 --> 10:12.270
那么这里首先

10:12.270 --> 10:13.470
他要做这么一件事

10:13.470 --> 10:15.110
对这个x型进行验证

10:15.110 --> 10:16.150
因为我们之前说过

10:16.150 --> 10:18.230
x型必须是一个

10:18.230 --> 10:18.950
品面对象

10:18.950 --> 10:20.550
叫plane object

10:20.550 --> 10:21.390
另外一个

10:21.390 --> 10:21.910
我们要说

10:21.910 --> 10:22.830
就是这个x型

10:22.830 --> 10:24.950
就是他还必须要有个type值

10:24.990 --> 10:25.350
对不对

10:25.350 --> 10:26.910
必须要有个type值

10:26.910 --> 10:29.150
所以说我们这里一块

10:29.150 --> 10:29.950
咱们这里一块

10:29.950 --> 10:31.830
我们需要给他

10:31.830 --> 10:33.710
进行一下验证

10:33.710 --> 10:35.790
验证x

10:35.790 --> 10:36.510
怎么验证呢

10:36.510 --> 10:39.110
首先看他是不是一个品面对象

10:39.110 --> 10:39.910
那么怎么来判断

10:39.910 --> 10:41.190
他是不是一个品面对象呢

10:41.190 --> 10:42.750
咱们这里可以写个函数

10:42.750 --> 10:44.150
可以写个函数

10:44.150 --> 10:44.950
给他取个名字叫做

10:44.950 --> 10:47.950
ease plane object

10:47.950 --> 10:49.070
给我一个对象

10:49.070 --> 10:49.910
我来判断这个对象

10:49.910 --> 10:52.830
是不是一个品面对象

10:52.830 --> 10:55.750
判断某个对象

10:55.750 --> 10:59.990
是否是一个plane object

10:59.990 --> 11:02.430
是不是一个plane object

11:02.430 --> 11:04.070
那么这里我们首先判断

11:04.070 --> 11:05.630
这个object

11:05.630 --> 11:06.990
他如果不是一个对象

11:06.990 --> 11:08.070
他肯定不是一个品面对象

11:08.070 --> 11:08.790
对不对

11:08.790 --> 11:11.070
如果说type OBj

11:11.070 --> 11:12.990
不等于什么object

11:12.990 --> 11:14.190
他连对象都不是

11:14.190 --> 11:15.990
他更加谈不上是一个plane object

11:15.990 --> 11:17.590
所谓反辉force

11:17.590 --> 11:18.670
他必须得是一个对象

11:18.670 --> 11:19.710
对不对

11:19.710 --> 11:20.910
那么下面如果说

11:20.910 --> 11:22.270
他是一个对象

11:22.310 --> 11:23.270
试一个对象的话

11:23.270 --> 11:23.990
我们来看一下

11:23.990 --> 11:24.830
什么东西来判断

11:24.830 --> 11:26.830
他是不是品面对象

11:26.830 --> 11:27.870
判断什么东西

11:27.870 --> 11:28.990
其实也很简单

11:28.990 --> 11:30.030
就判断一下

11:30.030 --> 11:30.510
因为我们说过

11:30.510 --> 11:31.150
一个品面对象

11:31.150 --> 11:31.790
有一个特点

11:31.790 --> 11:35.350
就是proto这个属像

11:35.350 --> 11:36.830
应该等于什么

11:36.830 --> 11:39.550
等于object prototype

11:39.550 --> 11:40.110
对吧

11:40.110 --> 11:41.590
就判断这个东西

11:41.590 --> 11:43.310
判断一下他的影视圆形

11:43.310 --> 11:44.950
是不是等于object圆形

11:44.950 --> 11:45.910
就说他这个对象

11:45.910 --> 11:47.270
是不是就是一个object的对象

11:47.270 --> 11:49.310
他不是来自于其他内创建的

11:49.310 --> 11:49.910
不是数组

11:49.910 --> 11:50.830
不是其他玩意

11:50.830 --> 11:53.390
他必须是一个普通的object的对象

11:53.390 --> 11:54.350
当然这种协访

11:54.350 --> 11:56.310
不是一种很好的协访

11:56.310 --> 11:57.190
建议你怎么选择

11:57.190 --> 12:00.350
建议你用object的getproto typo

12:02.350 --> 12:03.470
然后给一个对象

12:03.470 --> 12:04.470
你看一下这个对象

12:04.470 --> 12:05.590
它的圆形

12:05.590 --> 12:09.110
圆形是不是一个object prototype

12:09.110 --> 12:09.630
对吧

12:09.630 --> 12:10.310
就这么简单

12:10.310 --> 12:10.790
没了

12:10.790 --> 12:11.790
没了

12:11.790 --> 12:12.590
比方说现在

12:12.590 --> 12:13.630
咱们来判断一下吧

12:13.630 --> 12:14.910
isplay

12:16.510 --> 12:18.230
直接输出

12:18.230 --> 12:19.830
isplay

12:19.830 --> 12:20.790
object

12:21.310 --> 12:23.190
那么这里比方说给他一个空对象

12:23.190 --> 12:24.750
你看一下是不是一个平面对象

12:24.750 --> 12:25.310
是不是true

12:25.310 --> 12:25.670
对吧

12:25.670 --> 12:26.790
就是一个平面对象

12:26.790 --> 12:27.790
true

12:27.790 --> 12:29.230
然后这里面比方说

12:29.230 --> 12:30.390
咱们给他一个123

12:30.390 --> 12:31.070
一个数字

12:31.070 --> 12:31.990
是不是个平面对象

12:31.990 --> 12:32.830
force

12:32.830 --> 12:34.150
看没

12:34.150 --> 12:37.510
然后这里比方说给他一个数组

12:37.510 --> 12:38.510
他是不是个平面对象

12:38.510 --> 12:39.230
force

12:39.230 --> 12:39.710
对吧

12:39.710 --> 12:40.630
就很简单

12:40.630 --> 12:42.910
这个玩意儿就很简单

12:42.910 --> 12:45.790
就是提供这么一个方法

12:45.790 --> 12:46.790
但这个方法没有导出

12:46.790 --> 12:49.510
这个方法就是内部实现用的

12:49.510 --> 12:50.270
验证x型的

12:50.310 --> 12:52.270
首先判断一下他是不是平面对象

12:52.270 --> 12:53.270
如果说这个action

12:53.270 --> 12:54.790
他不是平面对象

12:54.790 --> 12:55.190
意思

12:55.190 --> 12:56.470
play object

12:56.470 --> 12:58.190
如果说他不是一个平面对象

12:58.190 --> 12:59.670
加上感叹号

12:59.670 --> 13:00.830
那么是不是要报错

13:00.830 --> 13:02.750
按照之前的他的那种行为

13:02.750 --> 13:03.630
是不是要报错

13:03.630 --> 13:05.870
so new type error

13:05.870 --> 13:07.590
我们可以报一个错误

13:07.590 --> 13:08.270
什么错误

13:08.270 --> 13:13.030
就是action must be

13:13.030 --> 13:14.630
and

13:14.630 --> 13:19.030
play object

13:19.030 --> 13:20.110
对吧

13:20.150 --> 13:21.910
所以报这么一个错误就完事了

13:21.910 --> 13:23.310
这是验证一下action

13:23.310 --> 13:24.030
那么验证完了

13:24.030 --> 13:25.030
action本身之后

13:25.030 --> 13:25.950
还要去验证一下

13:25.950 --> 13:26.470
怎么了

13:26.470 --> 13:28.510
验证一下action的type

13:28.510 --> 13:30.030
的type属性

13:30.030 --> 13:31.110
是否存在

13:31.110 --> 13:33.110
是否存在type属性

13:33.110 --> 13:35.590
那么怎么验证type属性是不是存在呢

13:35.590 --> 13:37.270
你可以判断一下

13:37.270 --> 13:39.470
那么这个type

13:39.470 --> 13:41.110
或者这样判断

13:41.110 --> 13:43.390
action.tap

13:43.390 --> 13:44.510
是不是等于什么

13:44.510 --> 13:45.070
indefend

13:46.830 --> 13:47.630
那么等于的话

13:47.630 --> 13:48.910
那么是不是没有type属性

13:48.910 --> 13:49.190
对吧

13:49.270 --> 13:50.190
没有type属性的

13:50.190 --> 13:51.630
我们也该报一个错误

13:51.630 --> 13:54.990
x must

13:54.990 --> 13:59.070
has a property

13:59.070 --> 14:00.430
of type

14:00.430 --> 14:02.630
对吧

14:02.630 --> 14:04.150
必须要有个type属性

14:04.150 --> 14:05.070
就是总之呢

14:05.070 --> 14:06.710
对action做一个验证

14:06.710 --> 14:08.470
那么type属性验证通过了

14:08.470 --> 14:10.350
然后它又是个平面对象

14:10.350 --> 14:11.270
那么接下来怎么办

14:11.270 --> 14:12.790
dispatch要干嘛

14:12.790 --> 14:13.710
你告诉我

14:13.710 --> 14:15.430
分发一个action到stone里面

14:15.430 --> 14:17.270
stone它分发一个action它要干嘛

14:17.270 --> 14:18.510
是不是最终就是调用什么

14:18.510 --> 14:19.950
调用reducer对吧

14:19.950 --> 14:21.310
就是调用reducer

14:21.310 --> 14:22.030
就这么简单

14:22.030 --> 14:24.470
一点技术含量都没有

14:24.470 --> 14:25.950
就是去调用这个reducer

14:25.950 --> 14:26.950
调用哪个reducer

14:26.950 --> 14:28.390
是不是调用这个current reducer

14:28.390 --> 14:28.830
对吧

14:28.830 --> 14:30.110
调用这个

14:30.110 --> 14:30.990
current reducer

14:30.990 --> 14:31.910
调用它就完事了

14:31.910 --> 14:32.910
就这么简单

14:32.910 --> 14:34.030
就这么简单

14:34.030 --> 14:35.390
调用它的时候

14:35.390 --> 14:36.870
给它传什么呢

14:36.870 --> 14:38.030
reducer里面要传什么

14:38.030 --> 14:39.710
是不是传当前的状态

14:39.710 --> 14:40.230
对吧

14:40.230 --> 14:41.470
current state

14:41.470 --> 14:42.710
当前的状态

14:42.710 --> 14:44.070
还要传什么

14:44.070 --> 14:45.310
还要传啥

14:45.310 --> 14:47.150
除了传当前的状态之外

14:47.230 --> 14:48.670
是不是还要传一个

14:48.670 --> 14:50.510
还要传一个action

14:50.510 --> 14:51.310
对不对

14:51.310 --> 14:52.430
你给我一个action

14:52.430 --> 14:53.350
你看一下这个图

14:53.350 --> 14:54.110
看一下这个图

14:54.110 --> 14:54.870
是动干嘛

14:54.870 --> 14:55.630
传递action

14:55.630 --> 14:56.750
传递state对吧

14:56.750 --> 14:58.110
把当前的状态给它

14:58.110 --> 14:59.070
给它一个action

14:59.070 --> 15:00.470
那么是不是得到一个新的状态

15:00.470 --> 15:02.270
reducer会返回一个新的状态

15:02.270 --> 15:02.870
对不对

15:02.870 --> 15:04.470
你不要想这里边有什么异步

15:04.470 --> 15:05.830
你什么异步没有异步

15:05.830 --> 15:07.270
这里边全是存寒数

15:07.270 --> 15:07.910
你给它一个东西

15:07.910 --> 15:08.950
它就返回一个东西

15:08.950 --> 15:10.150
好返回一个新状态

15:10.150 --> 15:11.350
那么咱们这里呢

15:11.350 --> 15:13.710
使用current state接受一下就完了

15:13.710 --> 15:15.030
就没了

15:15.030 --> 15:15.950
就没了

15:15.950 --> 15:17.030
就这么简单

15:17.990 --> 15:20.830
这里是constance

15:20.830 --> 15:23.830
在这里边我们通过

15:23.830 --> 15:24.870
你得到一个新的状态

15:24.870 --> 15:25.190
ok

15:25.190 --> 15:26.590
那么我们这里接受一下

15:26.590 --> 15:27.110
就没了

15:28.630 --> 15:29.950
这就是dispatch

15:29.950 --> 15:31.430
dispatch

15:31.430 --> 15:32.310
就没了

15:32.310 --> 15:33.870
就没了

15:33.870 --> 15:35.190
那么其实你仔细看一下

15:35.190 --> 15:37.110
现在我们把这个nation去掉

15:37.110 --> 15:38.630
dispatch就已经可以工作了

15:38.630 --> 15:39.590
你发现

15:40.750 --> 15:44.570
我们把这个nation去掉

15:45.850 --> 15:46.410
dispatch

15:46.410 --> 15:47.530
那么现在就已经可以工作了

15:47.570 --> 15:49.570
只是我们现在看不到效果关键是

15:49.570 --> 15:51.250
国家是看不到效果

15:51.250 --> 15:53.130
dispatch就已经可以工作了

15:53.130 --> 15:54.290
那么为了看到效果的话

15:54.290 --> 15:56.050
我们还要去实现一下这个函数

15:56.050 --> 15:57.010
get state

15:57.010 --> 15:58.770
得到当前的状态

15:58.770 --> 16:00.050
这个函数极其简单

16:00.050 --> 16:01.170
你告诉我怎么写这个函数

16:02.330 --> 16:03.010
怎么写

16:03.010 --> 16:05.250
是不是就是返回什么current state

16:05.250 --> 16:06.330
就没了

16:06.330 --> 16:08.250
get state就是返回当前的状态

16:08.250 --> 16:10.010
就没了

16:10.010 --> 16:11.010
保存你看一下吧

16:11.010 --> 16:12.570
那么咱们这里呢

16:12.570 --> 16:15.530
dispatch前面先写上一个输出

16:15.570 --> 16:17.690
store get state

16:18.530 --> 16:18.770
好

16:18.770 --> 16:21.370
下面每一次分发

16:21.370 --> 16:22.290
一开始输出一次

16:22.290 --> 16:24.330
分发之后再输出一次

16:24.330 --> 16:25.890
再输出一次

16:25.890 --> 16:26.450
保存

16:29.250 --> 16:29.890
你看没

16:30.730 --> 16:34.130
那么这一次得到的结果是

16:34.130 --> 16:36.130
第一次分发是不是加了一条数据

16:36.130 --> 16:38.010
第二次分发是不是少了一条数据

16:38.010 --> 16:38.650
对吧

16:38.650 --> 16:39.890
少了一条数据

16:39.890 --> 16:41.330
那第一次分发

16:41.330 --> 16:43.010
第一次为什么是undefined的呢

16:43.010 --> 16:44.690
就是在第一次分发之前

16:44.730 --> 16:46.290
它不是一个初始化过程吗

16:46.290 --> 16:47.770
你看我们qt store

16:47.770 --> 16:50.330
创建这个仓库之后

16:50.330 --> 16:52.970
你看这里输出的是undefined的

16:52.970 --> 16:53.890
那为什么呢

16:53.890 --> 16:55.930
是因为我们之前说过

16:55.930 --> 16:57.770
如果说你这里写的默认值

16:57.770 --> 16:59.530
那你看默认值是不是附进来了

16:59.530 --> 17:00.770
附到这个变量里边来了

17:00.770 --> 17:02.970
那么get state当然可以得到

17:02.970 --> 17:05.690
但是那你可以是不填默认值的

17:05.690 --> 17:06.810
不填默认值

17:06.810 --> 17:08.090
那么这个是不是undefined的

17:08.090 --> 17:08.330
对吧

17:08.330 --> 17:09.730
第二参数是undefined的

17:10.970 --> 17:12.170
所以说它就得不到结果

17:12.170 --> 17:13.050
那自然得不到结果

17:13.050 --> 17:14.130
你直接调用get state

17:14.210 --> 17:16.050
自然得到的是undefined

17:16.050 --> 17:17.570
但是我们一开始

17:17.570 --> 17:18.690
是不是我们之前说过

17:18.690 --> 17:20.250
要调用一次

17:20.250 --> 17:20.970
调用一次啥

17:20.970 --> 17:23.170
是不是要调用一次reducer

17:23.170 --> 17:23.770
对不对

17:23.770 --> 17:25.930
也就是一开始的时候

17:25.930 --> 17:27.850
创建仓库时

17:27.850 --> 17:29.650
创建仓库时

17:29.650 --> 17:32.610
需要调用一次

17:32.610 --> 17:34.530
需要dispatch一次

17:34.530 --> 17:39.530
需要分发一次初始的x

17:39.530 --> 17:39.770
对吧

17:39.770 --> 17:40.610
我们之前说过对吧

17:40.610 --> 17:41.530
那个x的type值

17:41.530 --> 17:43.730
还是一个非常特殊的type

17:43.810 --> 17:45.810
因此我们这里就可以直接调用

17:45.810 --> 17:46.730
就完成了dispatch

17:46.730 --> 17:47.810
调用一下

17:47.810 --> 17:49.450
那么把x应该传进去

17:49.450 --> 17:50.810
什么x呢

17:50.810 --> 17:52.450
这个x是怎么x的

17:52.450 --> 17:54.210
那么x里边一个type值

17:54.210 --> 17:54.930
一个type值

17:54.930 --> 17:57.050
这个type值是不是一个非常特殊的type值

17:57.050 --> 17:57.810
对吧

17:57.810 --> 17:58.890
非常特殊的type值

17:58.890 --> 18:01.130
那type值大概格式是这样子

18:01.130 --> 18:02.610
两个atarex

18:02.610 --> 18:04.690
然后一个邪杠enate

18:04.690 --> 18:07.410
后边是一些随机的字母和数字

18:07.410 --> 18:08.810
随机的字母和数字

18:08.810 --> 18:10.090
那么这东西是怎么做出来的呢

18:10.090 --> 18:11.850
我们可以写个工具函数

18:11.850 --> 18:13.290
来产生这么一个东西

18:13.330 --> 18:14.730
来产生这么一个东西

18:14.730 --> 18:16.330
那么比方说我们这里呢

18:16.330 --> 18:19.090
写上这么一个函数

18:19.090 --> 18:20.530
get ridem

18:20.530 --> 18:23.450
get ridem stream

18:23.450 --> 18:24.850
得到一个随机字母创

18:24.850 --> 18:27.170
这里是字母创的长度

18:27.170 --> 18:28.290
其实这种写法呢

18:28.290 --> 18:29.770
我们之前讲的Rey

18:29.770 --> 18:31.250
在讲的扩展课程

18:31.250 --> 18:32.410
就是readRotor的时候

18:32.410 --> 18:33.930
我们也写过对吧

18:33.930 --> 18:36.530
得到一个指定

18:36.530 --> 18:39.690
指定长度的随机字母创

18:39.690 --> 18:41.530
那么随机字母创怎么写呢

18:41.530 --> 18:43.250
我们可以之前写过了

18:43.370 --> 18:45.690
怎么写就是你用max.readem

18:46.690 --> 18:47.970
是不是得到一个随机数

18:47.970 --> 18:48.370
对吧

18:48.370 --> 18:49.730
我们来在这里写一下

18:52.010 --> 18:54.930
所以max.readem可以得到一个随机数

18:54.930 --> 18:55.730
对不对

18:55.730 --> 18:57.330
这个n就是个随机数

18:57.330 --> 19:00.250
那么把这个随机数转换成图示讯

19:00.250 --> 19:02.290
这个数字转换成一个字母创

19:02.290 --> 19:03.410
这里边写上36

19:03.410 --> 19:04.650
是不是36进字

19:04.650 --> 19:06.530
为什么36进字呢

19:06.530 --> 19:07.090
你想啊

19:07.090 --> 19:07.930
数字有几个

19:07.930 --> 19:09.010
10个吗

19:09.010 --> 19:09.770
字母有几个

19:09.770 --> 19:10.530
26个吗

19:10.530 --> 19:12.330
加起来是不是一共有36个

19:12.450 --> 19:14.210
数字加字母一共有36个

19:14.210 --> 19:15.530
ok 36进字

19:15.530 --> 19:16.490
那每一个位置

19:16.490 --> 19:18.330
是不是可以表示10个数字

19:18.330 --> 19:20.290
或者是26个字母当中的一个

19:20.290 --> 19:20.810
对吧

19:20.810 --> 19:23.890
把它转换成36进字的格式的一个字母创

19:23.890 --> 19:24.490
转换出来过后

19:24.490 --> 19:25.930
你看是不是这个样子

19:25.930 --> 19:26.810
对不对

19:26.810 --> 19:27.730
然后再用用什么

19:27.730 --> 19:28.890
再用字母创解去

19:28.890 --> 19:29.290
对吧

19:29.290 --> 19:30.530
再用字母创解去

19:30.530 --> 19:31.410
subsgene

19:33.930 --> 19:34.610
subsgene

19:35.850 --> 19:37.090
从哪个位置开始解去呢

19:37.090 --> 19:39.330
是不是从下标为二那个位置

19:39.330 --> 19:41.090
底后边你看一下

19:41.090 --> 19:42.130
都是下标为0

19:42.130 --> 19:42.930
下标为1

19:42.930 --> 19:43.690
下标为2

19:43.690 --> 19:44.250
对不对

19:44.250 --> 19:45.490
下标为2这个位置

19:45.490 --> 19:46.290
开始解去

19:46.290 --> 19:47.290
解去多少个呢

19:47.290 --> 19:48.530
比方说解去7个

19:49.330 --> 19:50.290
是不是这样子

19:50.290 --> 19:51.090
对不对

19:51.090 --> 19:52.050
就这么简单

19:52.050 --> 19:53.130
就这么简单

19:53.130 --> 19:54.130
所以说这里呢

19:55.530 --> 19:56.010
你看呀

19:56.010 --> 19:56.570
这就是一个

19:56.570 --> 19:58.370
产生一个水积字母创的方式

19:58.370 --> 19:59.490
非常简单

19:59.490 --> 20:00.890
只不过把这里7变成啥

20:00.890 --> 20:01.850
变成lens

20:02.570 --> 20:03.890
变成指定长度

20:03.890 --> 20:05.570
得到这么一个函数

20:05.570 --> 20:06.050
好

20:06.050 --> 20:07.610
有了这么一个函数辅助之后

20:07.610 --> 20:08.490
我们这里呢

20:08.490 --> 20:09.210
音列扯这里

20:09.210 --> 20:10.170
是不是可以写了

20:10.210 --> 20:11.970
后边在拼接上一个水积字母创

20:11.970 --> 20:12.370
对吧

20:12.370 --> 20:13.450
拼上一个水积字母创

20:16.450 --> 20:16.690
好

20:16.690 --> 20:17.250
这里呢

20:18.010 --> 20:18.810
get a write down

20:19.570 --> 20:20.610
get a write down stream

20:21.170 --> 20:21.290
好

20:21.290 --> 20:22.330
那么这里写个7

20:22.330 --> 20:24.090
他写的是7个

20:24.090 --> 20:25.210
他用使用的是7个

20:25.690 --> 20:25.850
好

20:25.850 --> 20:26.610
那么这样子一来呢

20:26.610 --> 20:28.250
我们再这个就是

20:30.450 --> 20:30.930
你看一下

20:30.930 --> 20:31.730
第四是不有了

20:31.730 --> 20:32.650
因为分发了一次

20:32.650 --> 20:34.130
分发了一个特殊的一个型

20:34.130 --> 20:34.410
好

20:34.410 --> 20:34.890
那么这里呢

20:34.890 --> 20:36.090
我们可以去

20:37.450 --> 20:39.050
在Reduce里面打印一下吧

20:39.290 --> 20:40.650
打印一下Reduce里面的东西

20:42.850 --> 20:43.770
我们在哪呢

20:44.410 --> 20:45.210
在那个

20:46.210 --> 20:47.130
locking user

20:47.130 --> 20:48.490
locking user

20:48.490 --> 20:49.210
在这里边

20:49.210 --> 20:50.570
不要在这里边吧

20:50.570 --> 20:51.850
咱们打印一下

20:51.850 --> 20:53.850
打印一下这个type值

20:53.850 --> 20:54.250
保存

20:55.490 --> 20:55.970
你看一下

20:58.810 --> 20:59.970
他为什么多了几个

20:59.970 --> 21:00.490
多了几个

21:00.490 --> 21:01.490
我们现在不用管

21:01.490 --> 21:02.170
不用管

21:02.170 --> 21:04.330
那么我们来看一下音列扯

21:04.330 --> 21:05.810
我们自己的音列扯

21:05.810 --> 21:06.730
你看一下是不是这个

21:06.730 --> 21:07.090
对吧

21:07.090 --> 21:08.130
这是我们自己的音列扯

21:08.130 --> 21:08.730
看到没

21:08.770 --> 21:09.610
是不是这一碗

21:10.130 --> 21:10.850
没问题吧

21:10.850 --> 21:12.650
这是我们自己写的音列扯

21:12.650 --> 21:13.650
前面两个不用管

21:13.650 --> 21:14.850
前面两个是combine

21:14.850 --> 21:16.050
combine reducer

21:16.050 --> 21:17.810
有丢失的是那个东西给你调用的

21:17.810 --> 21:18.570
你不用管他

21:18.570 --> 21:19.250
不用管他

21:19.250 --> 21:20.290
那么这一块

21:20.290 --> 21:21.770
这一块是不是我们自己的

21:21.770 --> 21:22.330
对不对

21:22.330 --> 21:23.290
我们自己的吧

21:24.130 --> 21:25.410
那如果算了算了

21:25.410 --> 21:25.970
我们先

21:25.970 --> 21:28.090
先不要让大家看到一些位置的东西

21:28.450 --> 21:29.090
我们在这里

21:29.090 --> 21:30.450
我们使用自己的combine

21:31.210 --> 21:32.690
使用自己的就是自己的

21:32.690 --> 21:34.170
代码组装的一个东西

21:35.250 --> 21:36.650
这里得到Action的type

21:36.650 --> 21:38.210
那这里可以看到很清楚了

21:38.610 --> 21:39.170
你看一下

21:39.170 --> 21:40.330
这是不是我们自己的type

21:40.330 --> 21:40.850
对吧

21:40.850 --> 21:41.410
type

21:41.410 --> 21:43.050
刚才我们看到了音列扯

21:43.050 --> 21:43.690
它是大写的

21:43.690 --> 21:44.930
咱们稍微改东西一下

21:45.650 --> 21:46.250
这个音列扯

21:46.250 --> 21:47.650
这个字母它是大写的

21:47.650 --> 21:48.410
音列扯

21:48.770 --> 21:49.690
然后后面这个

21:49.690 --> 21:51.530
它中间是用底耳来分割的

21:51.530 --> 21:52.850
它是用底耳来分割的

21:52.850 --> 21:54.050
这个东西简单

21:54.050 --> 21:55.810
我们不是得到一个字母串吗

21:55.810 --> 21:56.450
对吧

21:56.450 --> 21:57.170
得个字母串

21:57.170 --> 21:58.450
然后send split

21:59.290 --> 22:00.490
用一个空字母串分割

22:00.490 --> 22:02.650
是不是把每个字符就分割开了

22:02.650 --> 22:03.050
对不对

22:03.050 --> 22:04.610
把每个字符就分割开了

22:04.610 --> 22:05.650
然后join

22:05.650 --> 22:07.490
再用一个底耳来的延接

22:07.570 --> 22:09.410
再用一个底耳来的延接就完事了

22:09.410 --> 22:10.650
廉接是一个字母串

22:11.090 --> 22:12.490
那你看一下是不是变成这样子了

22:13.650 --> 22:14.450
就很简单

22:14.450 --> 22:15.210
很简单

22:15.850 --> 22:16.370
没了

22:16.370 --> 22:16.930
没了

22:17.530 --> 22:18.410
这就是

22:18.850 --> 22:20.610
一开始我们去触发一个

22:20.610 --> 22:23.490
触发一个这么一个Action

22:24.090 --> 22:25.330
一开始默认触发一个Action

22:25.330 --> 22:26.690
给它一个特殊的type字

22:27.290 --> 22:29.970
这样的作用目的是

22:29.970 --> 22:31.970
让它去完成状态的初始化

22:34.180 --> 22:34.420
好

22:34.420 --> 22:36.020
那么dspd是不是写完了

22:36.020 --> 22:37.620
getState是不是写完了

22:37.980 --> 22:38.820
就写完了

22:39.340 --> 22:40.420
就插最后一个了

22:40.420 --> 22:41.580
什么subscribe

22:42.180 --> 22:43.180
这是一个什么

22:44.980 --> 22:46.380
添加一个

22:47.060 --> 22:47.820
监听器

22:47.820 --> 22:49.020
也可以叫订阅器

22:49.380 --> 22:50.100
订阅器

22:51.580 --> 22:54.020
这个东西需要用到一个设计模式

22:54.020 --> 22:56.380
就是发布订阅模式

22:56.380 --> 22:58.300
其实这个模式也没有什么特殊的

22:58.300 --> 23:00.420
以前在像什么csharp语言

23:00.420 --> 23:02.020
加把语言里面实现起来

23:02.020 --> 23:02.900
那肯定有点绕

23:02.900 --> 23:05.660
但是在介石语言里面特别简单

23:05.660 --> 23:06.660
因此我们之前在讲的

23:06.700 --> 23:07.500
RetroRotor的时候

23:07.500 --> 23:08.740
我都没有去专门说

23:08.740 --> 23:10.580
它是一种什么什么样的设计模式

23:10.940 --> 23:12.060
非常简单

23:12.380 --> 23:14.060
这个函数是不是要接受一个参数

23:14.060 --> 23:14.340
对吧

23:14.340 --> 23:14.980
Lessoner

23:15.300 --> 23:15.940
对不对

23:16.580 --> 23:17.740
是不是要接受一个参数

23:17.740 --> 23:20.100
这个参数是不是用来监听的

23:20.100 --> 23:20.620
对吧

23:20.660 --> 23:21.660
用来监听的

23:22.180 --> 23:23.140
那么什么意思呢

23:23.140 --> 23:24.980
这个发布订阅模式

23:24.980 --> 23:25.740
什么意思呢

23:25.740 --> 23:27.260
就是说我呢

23:27.260 --> 23:28.620
用一个数组呢

23:28.620 --> 23:30.460
来保存我的监听器

23:32.140 --> 23:34.060
就是订阅或者叫订阅器

23:34.740 --> 23:35.980
也叫或者叫订阅者

23:36.020 --> 23:36.500
无所谓吧

23:36.500 --> 23:37.220
叫什么名字

23:37.220 --> 23:38.020
无所谓

23:38.020 --> 23:38.980
监听器

23:39.220 --> 23:41.100
我用一个数组来表示

23:41.100 --> 23:42.660
来保存这些监听器

23:42.660 --> 23:43.900
你只要调用这个方法

23:43.900 --> 23:45.660
我就往数组里面加一个监听器

23:45.980 --> 23:47.020
加这么一个监听器

23:47.020 --> 23:48.020
就这么简单

23:49.020 --> 23:50.260
加这么一个监听器

23:50.380 --> 23:51.460
然后呢

23:51.460 --> 23:54.620
只要你发生某一件事的时候

23:54.620 --> 23:56.180
我去循环这个数组

23:56.180 --> 23:57.220
因为监听器

23:57.500 --> 23:59.780
监听器是不是就是函数

23:59.980 --> 24:00.540
对吧

24:00.540 --> 24:01.580
是不是就是函数

24:02.620 --> 24:03.820
只要你呢

24:03.980 --> 24:07.420
只要你在某个时候发生的时候

24:07.420 --> 24:08.820
比方说我们分发了一个x

24:08.820 --> 24:09.580
我们说过

24:09.580 --> 24:11.140
这个监听器什么时候运行

24:11.140 --> 24:12.780
是分发x 之后运行

24:12.780 --> 24:14.220
分发完了x 之后

24:14.220 --> 24:15.860
我们去一次从这个数组里面

24:15.860 --> 24:17.500
去运行这个监听器就完成了

24:17.500 --> 24:19.140
其实它特别特别简单

24:19.140 --> 24:20.900
在介石里面特别特别简单

24:20.900 --> 24:22.660
这些后装语言

24:22.660 --> 24:24.020
墙内型语言里面

24:24.020 --> 24:25.820
可能它写起来稍微麻烦一点

24:25.820 --> 24:27.700
但是在介石里面特别特别简单

24:27.900 --> 24:29.820
你说自己只需要个数组就完了

24:29.820 --> 24:30.340
没了

24:30.340 --> 24:31.180
真的是没了

24:32.180 --> 24:33.260
const

24:33.260 --> 24:34.420
表示什么呢

24:34.420 --> 24:35.420
表示Nationals

24:39.800 --> 24:41.360
其实我们这里说的订阅模式

24:41.360 --> 24:42.440
这些就是订阅者

24:42.440 --> 24:43.520
订阅者

24:43.520 --> 24:44.640
什么叫发布者呢

24:44.640 --> 24:46.480
就是当发生一件事的时候

24:46.480 --> 24:49.080
我们去调用这些订阅者的函数

24:49.080 --> 24:50.520
就是它就叫做发布者

24:50.520 --> 24:52.000
我们可以认为它dispatch

24:52.000 --> 24:53.320
分发就是发布者

24:53.320 --> 24:53.840
对吧

24:54.280 --> 24:54.560
好

24:54.560 --> 24:55.080
那么这里呢

24:55.080 --> 24:55.960
Nationals

24:55.960 --> 24:57.560
那么这里就是记录

24:58.080 --> 25:00.840
记录所有的监听器

25:01.040 --> 25:02.080
也就是订阅者

25:02.840 --> 25:03.560
订阅者

25:04.360 --> 25:04.560
好

25:04.560 --> 25:05.600
那么这里要干嘛呢

25:05.600 --> 25:07.560
这里其实要做的事情最简单

25:08.360 --> 25:09.760
怎么做什么

25:09.760 --> 25:11.160
就是Nationals

25:12.440 --> 25:13.560
我这里写错了吗

25:14.440 --> 25:15.240
应该这样子写

25:15.240 --> 25:16.240
单子写错了

25:16.560 --> 25:17.400
Nationals

25:19.000 --> 25:19.960
Nationals

25:19.960 --> 25:20.680
那么这里呢

25:20.680 --> 25:22.080
往这个数组里面扑洗一个

25:22.080 --> 25:23.360
加一个监听器

25:24.280 --> 25:27.080
将监听器加入到数组中

25:27.080 --> 25:29.040
因为现在还不会运行这个函数

25:29.040 --> 25:30.000
是将来运行

25:30.000 --> 25:30.960
我把它放到数组里面

25:30.960 --> 25:31.640
将来运行的时候

25:31.680 --> 25:33.120
我就知道要怎么运行的

25:33.360 --> 25:33.720
对吧

25:33.720 --> 25:34.560
就这么简单

25:35.080 --> 25:35.960
所以说这一块呢

25:35.960 --> 25:37.000
dispatch过后

25:37.520 --> 25:39.520
当我们分发了状态之后

25:39.520 --> 25:39.840
对吧

25:39.840 --> 25:41.280
分发了这个x型之后

25:41.280 --> 25:42.320
这不得到新的状态

25:42.320 --> 25:44.120
得到新的状态之后干嘛

25:44.720 --> 25:45.400
是不是

25:45.400 --> 25:48.920
运就是运行所有的订阅者

25:48.920 --> 25:49.240
对吧

25:49.240 --> 25:50.360
也就是监听器

25:51.960 --> 25:53.000
就这么简单

25:53.000 --> 25:53.960
循环呗

25:54.200 --> 25:55.760
还能还要干嘛呢

25:55.760 --> 25:56.920
所以循环就完成了

25:56.920 --> 25:58.440
循环所有的什么

26:00.200 --> 26:01.000
监听器

26:01.120 --> 26:01.920
niss and nurse

26:01.920 --> 26:03.120
我这样的写你们

26:03.120 --> 26:04.080
是不是看的不太清楚

26:04.080 --> 26:04.920
但是没办法

26:04.920 --> 26:07.440
这个写出来就是这么一种命名

26:07.920 --> 26:08.600
它是复苏

26:08.600 --> 26:09.360
它是单苏

26:09.360 --> 26:09.960
对吧

26:09.960 --> 26:11.720
它把当成函数去雕人就完成了

26:11.720 --> 26:12.640
就这么简单

26:12.640 --> 26:13.440
没了

26:13.440 --> 26:15.280
运行所有的订阅者

26:15.280 --> 26:17.120
这个数组里面游戏一下就运行几个

26:17.120 --> 26:17.560
对吧

26:17.560 --> 26:18.160
就没了

26:19.000 --> 26:19.800
还有啥呢

26:19.800 --> 26:20.080
好

26:20.080 --> 26:21.840
咱们回到这个index里面看一下

26:21.840 --> 26:22.160
好

26:22.160 --> 26:23.200
比方说咱们去

26:25.320 --> 26:27.000
加入这个监听器

26:28.000 --> 26:30.000
取消监听器

26:30.000 --> 26:31.040
我们一会再说

26:31.040 --> 26:32.200
加入这个监听器

26:32.200 --> 26:32.480
好

26:32.480 --> 26:32.920
来看一下

26:32.920 --> 26:33.520
保存

26:35.520 --> 26:37.560
把个type之去掉

26:37.560 --> 26:39.200
打印那个type

26:39.200 --> 26:42.640
这type之打印的去掉

26:43.200 --> 26:43.480
好

26:43.480 --> 26:44.080
你看一下

26:44.080 --> 26:45.120
所以每一次

26:45.120 --> 26:46.720
分发的状态之后

26:46.720 --> 26:47.040
对吧

26:47.040 --> 26:48.520
每一次分发的状态之后

26:48.520 --> 26:49.920
是不是都会运行这个监听器

26:49.920 --> 26:50.560
对吧

26:50.560 --> 26:51.440
就这么简单

26:51.440 --> 26:52.360
就这么简单

26:52.360 --> 26:53.640
那如果说你这里掉

26:53.640 --> 26:55.640
你这里运行的多个监听器呢

26:55.640 --> 26:56.480
那比方说

26:56.480 --> 26:58.000
这里掉了一个监听器

26:58.120 --> 26:59.280
两个监听器

26:59.280 --> 27:00.480
那么这里是

27:01.080 --> 27:01.800
比方说

27:05.040 --> 27:07.560
这是监听器1

27:08.360 --> 27:09.840
或者叫订阅者1

27:09.840 --> 27:11.280
都是一个意思

27:11.280 --> 27:12.560
好

27:12.560 --> 27:13.920
这是监听器2

27:14.560 --> 27:15.520
保存

27:15.520 --> 27:16.640
你看每一次运行

27:16.640 --> 27:18.000
是不是运行了两个监听器

27:18.760 --> 27:20.080
有多复杂了

27:20.080 --> 27:21.280
就是一个输出来保存

27:21.280 --> 27:22.240
就完成了

27:22.240 --> 27:23.400
你添加监听器的

27:23.400 --> 27:24.080
你这里

27:24.080 --> 27:24.680
这个玩意儿

27:26.880 --> 27:27.680
你这个玩意儿

27:27.720 --> 27:28.560
不是在添加监听器

27:28.560 --> 27:30.080
我给你夹一下输出里面

27:30.080 --> 27:31.720
到时候分发状态之后

27:31.720 --> 27:32.560
我们把运行

27:32.560 --> 27:33.520
每一个监听器

27:33.520 --> 27:35.160
把运行出来就完成了

27:35.160 --> 27:36.160
就这么简单

27:36.160 --> 27:36.320
好

27:36.320 --> 27:37.600
但是现在我们这个函数

27:37.600 --> 27:39.200
它还要返回一个东西

27:39.200 --> 27:39.680
返回什么

27:39.680 --> 27:41.160
是不是返回一个取消啊

27:41.160 --> 27:42.320
取消监听的函数

27:42.320 --> 27:43.080
对吧

27:43.080 --> 27:44.720
什么叫取消监听

27:44.720 --> 27:45.840
不就是把这个玩意儿

27:45.840 --> 27:47.160
从输出里面移除吗

27:47.160 --> 27:48.320
不就取消监听吗

27:48.320 --> 27:49.520
对不对

27:49.520 --> 27:51.120
将什么

27:51.120 --> 27:52.600
之前添加的Lessener

27:52.600 --> 27:53.360
这里有个B包

27:53.360 --> 27:54.200
对吧

27:54.200 --> 27:55.200
Lessener

27:55.200 --> 27:57.040
从输出中

27:57.080 --> 27:58.240
从输出中移除

27:58.240 --> 27:59.840
不就玩那么对不对

27:59.840 --> 28:00.960
怎么移除

28:00.960 --> 28:04.040
首先得到它的下标

28:04.040 --> 28:04.440
对不对

28:04.440 --> 28:06.120
const index

28:06.120 --> 28:07.360
等于什么

28:07.360 --> 28:10.560
输出是Lessener index

28:11.760 --> 28:13.240
得到这个Lessener的下标

28:13.240 --> 28:13.880
对不对

28:13.880 --> 28:15.560
从在输出里面的位置

28:15.560 --> 28:17.040
然后干嘛

28:17.040 --> 28:18.880
然后是不是Lessener

28:20.160 --> 28:21.800
Lessener's splice

28:21.800 --> 28:22.320
对不对

28:22.320 --> 28:23.280
splice

28:25.000 --> 28:26.760
就是移除掉一个

28:26.760 --> 28:28.480
移除掉一个监听器

28:28.480 --> 28:30.760
移除掉一个监听器

28:30.760 --> 28:31.480
移除要哪一个

28:31.480 --> 28:33.560
就是index

28:33.560 --> 28:34.440
移除要这个位置

28:34.440 --> 28:34.680
对吧

28:34.680 --> 28:35.280
移除一个

28:35.280 --> 28:36.960
从这个输出里面移除一个

28:36.960 --> 28:37.560
对不对

28:37.560 --> 28:38.520
就没了

28:38.520 --> 28:40.560
就没了

28:40.560 --> 28:42.440
当然你为了防止

28:42.440 --> 28:44.640
防止重复去从输出里面移除

28:44.640 --> 28:47.240
你也可以写个变量在这

28:47.240 --> 28:48.400
写个变量在这

28:48.400 --> 28:49.160
比方说

28:49.160 --> 28:52.800
isRemoveForce

28:52.800 --> 28:53.800
写个变量在这

28:53.800 --> 28:54.000
好

28:54.000 --> 28:54.840
我们移除掉过后

28:54.880 --> 28:55.840
把这个isRemove

28:55.840 --> 28:56.960
设为True

28:56.960 --> 28:57.360
移除掉

28:57.360 --> 28:58.400
成功移除掉了

28:58.400 --> 28:59.480
那如果说这个函数

28:59.480 --> 29:00.560
一开始判断一下

29:00.560 --> 29:01.800
如果说已经移除掉了

29:01.800 --> 29:03.240
我们直接return

29:03.240 --> 29:04.120
什么都不做

29:04.120 --> 29:05.520
如果说已经移除掉了

29:05.520 --> 29:06.200
我就什么都不做

29:06.200 --> 29:06.360
对吧

29:06.360 --> 29:08.520
因为变量来记录一下

29:08.520 --> 29:11.680
是否已经移除掉了

29:11.680 --> 29:12.520
为了避免

29:12.520 --> 29:14.360
为了稍微提高那么一点点效率

29:14.360 --> 29:14.920
对吧

29:14.920 --> 29:16.600
少去从输出里面移除

29:16.600 --> 29:17.640
那么你可以这样做

29:17.640 --> 29:19.040
可以这样做

29:19.040 --> 29:20.000
当然也可以判断一下

29:20.000 --> 29:21.320
这个index是不是等于附一

29:21.320 --> 29:22.520
无所谓

29:22.520 --> 29:23.440
总之你移除一次

29:23.440 --> 29:25.320
就不用再移除了

29:25.320 --> 29:26.360
就写完了

29:26.360 --> 29:27.440
真的就写完了

29:27.440 --> 29:27.720
好

29:27.720 --> 29:29.160
咱们在这边来看一下吧

29:29.160 --> 29:30.440
那么现在我们取消监听

29:30.440 --> 29:31.760
你会发现第二次

29:31.760 --> 29:32.640
分发这个x

29:32.640 --> 29:36.670
你就得不到了

29:36.670 --> 29:37.590
Unlesson

29:39.270 --> 29:40.990
第二次的分发

29:40.990 --> 29:41.950
你就无法监听到了

29:41.950 --> 29:43.150
因为他取消了监听

29:43.150 --> 29:44.030
保存

29:44.030 --> 29:44.430
你看

29:44.430 --> 29:45.430
是不是只运行了监听器

29:45.430 --> 29:47.270
一运行了一次

29:47.270 --> 29:49.350
第二次就没运行了

29:49.350 --> 29:49.870
没了

29:49.870 --> 29:51.390
这就是credestore

29:51.390 --> 29:52.150
就这么简单

29:52.150 --> 29:53.110
你看有多少人还带吗

29:53.110 --> 29:54.150
还不到100

29:54.190 --> 29:55.870
还没有公开直播课

29:55.870 --> 29:57.550
写的带码多

29:57.550 --> 30:00.550
其实他带码是非常非常简单和纯粹的

30:00.550 --> 30:02.190
就是提供那么几个东西

30:02.190 --> 30:02.870
没啥了

30:02.870 --> 30:04.150
真的没啥了

30:04.150 --> 30:04.270
好

30:04.270 --> 30:05.510
大家把它写一下

30:05.510 --> 30:07.550
去写一下这里的带码

30:09.190 --> 30:10.910
这是关于credestore

30:10.910 --> 30:11.750
这么一个函数

30:11.750 --> 30:12.550
他如何去实现

