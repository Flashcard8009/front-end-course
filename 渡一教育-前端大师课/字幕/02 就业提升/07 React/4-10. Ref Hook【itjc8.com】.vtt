WEBVTT

00:00.430 --> 00:03.430
咱们又要看这个玩意儿

00:03.430 --> 00:07.430
其实大伙儿应该能感觉到了

00:07.430 --> 00:09.430
这个hook呀

00:09.430 --> 00:14.430
除了state hook和effect hook

00:14.430 --> 00:17.430
后边我们学的这几个hook

00:17.430 --> 00:20.430
什么callback hook

00:20.430 --> 00:22.430
以及memo hook

00:22.430 --> 00:24.430
他们用来干什么事情

00:24.430 --> 00:26.430
都是用来固定一些值的

00:26.430 --> 00:28.430
保持一些值的引用

00:28.430 --> 00:30.430
为什么他要去做这么些事情呢

00:30.430 --> 00:32.430
根本的原因在于

00:32.430 --> 00:35.430
函数组件跟内组件有很大的区别

00:35.430 --> 00:37.430
内组件它是有个构造函数

00:37.430 --> 00:39.430
构造函数只运行一次

00:39.430 --> 00:40.430
它一个生命周期

00:40.430 --> 00:42.430
每一次它都运行这个构造

00:42.430 --> 00:44.430
对象里面的render方法

00:44.430 --> 00:46.430
它是运行对象里面的render方法

00:46.430 --> 00:48.430
而不再去运行构造函数了

00:48.430 --> 00:50.430
而函数组件不一样

00:50.430 --> 00:52.430
函数组件它只有一个函数

00:52.430 --> 00:54.430
它只能反复地去运行这个函数

00:54.430 --> 00:55.430
那么有些东西呢

00:55.430 --> 00:57.430
它需要再多次运行这个函数值

00:57.430 --> 00:59.430
之间要保持统一

00:59.430 --> 01:01.430
为了效率啊

01:01.430 --> 01:03.430
什么一些函数啊

01:03.430 --> 01:05.430
甭管的调用多少次这个函数

01:05.430 --> 01:06.430
那么有些函数呢

01:06.430 --> 01:08.430
它保持要地址要一样

01:08.430 --> 01:10.430
甭管你要调用多少次这个函数

01:10.430 --> 01:12.430
它反回来有一些只要一样

01:12.430 --> 01:14.430
那么就是youse memo对吧

01:14.430 --> 01:16.430
如果要保持函数地址一样

01:16.430 --> 01:17.430
那么可以使用youse callback

01:17.430 --> 01:19.430
其实都可以使用youse memo

01:19.430 --> 01:21.430
youse memo的通用性比较高

01:21.430 --> 01:22.430
只不过呢youse callback呢

01:22.430 --> 01:24.430
它呢更加简洁一点

01:24.430 --> 01:25.430
如果你说

01:25.430 --> 01:27.430
你要保持这个函数组件里边的

01:27.430 --> 01:29.430
某一个函数它地址为一

01:29.430 --> 01:31.430
地址是一样的

01:31.430 --> 01:33.430
那么使用youse callback

01:33.430 --> 01:35.430
你要保证其他东西一样的话

01:35.430 --> 01:37.430
那么就使用youse memo

01:37.430 --> 01:39.430
就这么个意思啊

01:39.430 --> 01:41.430
它都有这么一样一些处理

01:41.430 --> 01:43.430
因为它函数组件本身的特点就决定了

01:43.430 --> 01:44.430
由于函数组件

01:44.430 --> 01:45.430
它是一个普通函数

01:45.430 --> 01:47.430
它要调用很多次这个函数

01:47.430 --> 01:48.430
有些东西呢

01:48.430 --> 01:50.430
我们多次调用只需要保持一个就够了

01:50.430 --> 01:51.430
所以说呢

01:51.430 --> 01:53.430
它就出来这么些东西

01:53.430 --> 01:54.430
然后咱们学习的ref

01:54.430 --> 01:56.430
还是要解决这个问题

01:56.430 --> 01:57.430
ref这个互可呢

01:57.430 --> 01:59.430
它当然就是使用youse ref

01:59.430 --> 02:00.430
这个函数

02:00.430 --> 02:01.430
这个函数在做什么事情呢

02:01.430 --> 02:03.430
非常非常简单

02:03.430 --> 02:04.430
它函数一个

02:04.430 --> 02:06.430
就只有一个函数

02:06.430 --> 02:08.430
这个函数呢就是什么

02:08.430 --> 02:10.430
就是默认值

02:10.430 --> 02:11.430
默认

02:11.430 --> 02:12.430
当然你可以不传

02:12.430 --> 02:13.430
不传的话undefined嘛

02:13.430 --> 02:14.430
一个默认值

02:14.430 --> 02:15.430
好

02:15.430 --> 02:16.430
返回的是什么呢

02:16.430 --> 02:19.430
返回一个固定的对象

02:19.430 --> 02:22.430
这个对象的地址是永远固定的

02:22.430 --> 02:25.430
比如说以后呢你甭管调用多少次这个youse ref

02:25.430 --> 02:28.430
就同一个组建里边

02:28.430 --> 02:30.430
你甭管调用多少次这个youse ref

02:30.430 --> 02:32.430
返回的都是同一个对象

02:32.430 --> 02:33.430
它对象不会变化

02:33.430 --> 02:34.430
地址不会变化

02:34.430 --> 02:37.430
该对象的格式是这样子

02:37.430 --> 02:43.220
一看你们就知道非常熟悉了

02:43.220 --> 02:44.220
它的格式是这样子

02:44.220 --> 02:46.220
是不是就是我们以前的ref这种格式

02:46.220 --> 02:47.220
对吧

02:47.220 --> 02:49.220
它为什么要做出这么一个函数呢

02:49.220 --> 02:50.220
大家看一下

02:50.220 --> 02:51.220
我刚才讲一讲

02:51.220 --> 02:53.220
它为什么要做出这么一个函数

02:53.220 --> 02:55.220
就还是用app为例

02:55.220 --> 02:56.220
比方说吧

02:56.220 --> 02:58.220
我们这里呢就一个input

02:58.220 --> 03:00.220
然后点击按钮过后呢

03:00.220 --> 03:01.220
我们要干嘛呢

03:01.220 --> 03:04.220
得到input的值

03:04.220 --> 03:06.220
我们不希望它是一个受控主线

03:06.220 --> 03:07.220
所以说呢

03:07.220 --> 03:08.220
我们这里呢

03:08.220 --> 03:10.220
用一个非受控主线来得到

03:10.220 --> 03:11.220
那么是不是要加ref

03:11.220 --> 03:12.220
对吧

03:12.220 --> 03:13.220
是不是要加ref

03:13.220 --> 03:14.220
不然怎么得到了

03:14.220 --> 03:15.220
它是一个非控制控主线

03:15.220 --> 03:16.220
好

03:16.220 --> 03:17.220
那么这里呢

03:17.220 --> 03:18.220
我们以前咋写

03:18.220 --> 03:19.220
是不是在这里建一个变量

03:19.220 --> 03:20.220
对吧

03:20.220 --> 03:21.220
一个变量

03:21.220 --> 03:23.220
或者就是inputref

03:23.220 --> 03:25.220
是不是要用react

03:25.220 --> 03:27.220
createref

03:27.220 --> 03:28.220
对不对

03:28.220 --> 03:29.220
是吧

03:29.220 --> 03:30.220
建一个变量

03:30.220 --> 03:31.220
好

03:31.220 --> 03:32.220
OK

03:32.220 --> 03:33.220
我们把这个变量给它

03:33.220 --> 03:34.220
给它

03:34.220 --> 03:35.220
然后呢

03:35.220 --> 03:36.220
我们unclick

03:36.220 --> 03:38.220
点击的时候干嘛呢

03:39.220 --> 03:42.220
我们通过这个inputref

03:42.220 --> 03:43.220
the current

03:43.220 --> 03:44.220
对吧

03:44.220 --> 03:46.720
来得到它的白六字

03:46.720 --> 03:47.720
对不对

03:47.720 --> 03:48.720
把这个白六字输出

03:48.720 --> 03:49.720
保存看一下

03:49.720 --> 03:50.720
就这么简单了

03:50.720 --> 03:51.720
看一下

03:52.720 --> 03:53.720
控制台

03:54.720 --> 03:55.720
这里我们输出一个

03:55.720 --> 03:56.720
写一个点击

03:56.720 --> 03:57.720
是不是得到了

03:57.720 --> 03:58.720
随便输出一个

03:58.720 --> 03:59.720
得不得到了

03:59.720 --> 04:00.720
对吧

04:00.720 --> 04:01.720
非常简单

04:01.720 --> 04:02.720
那这个代码有什么问题呢

04:02.720 --> 04:03.720
实际上它没有多大的问题

04:03.720 --> 04:04.720
没有多大的问题

04:04.720 --> 04:07.720
只是说它这个代码有点不好

04:07.720 --> 04:08.720
因为你每

04:08.720 --> 04:09.720
这是一个函数组件

04:09.720 --> 04:11.720
你每一次运行这个函数组件

04:11.720 --> 04:12.720
是不是得到的ref都不一样

04:12.720 --> 04:14.720
得到对象都不一样

04:14.720 --> 04:15.720
对吧

04:15.720 --> 04:16.720
为了验证这一点

04:16.720 --> 04:17.720
我们这里呢

04:17.720 --> 04:18.720
用这种方式来验证

04:18.720 --> 04:19.720
写一个window里面

04:19.720 --> 04:20.720
写个ar

04:20.720 --> 04:22.720
然后我们每一次

04:22.720 --> 04:23.720
创建一个ref之后

04:23.720 --> 04:25.720
把它往这个window.ar里面

04:25.720 --> 04:26.720
铺起一个

04:26.720 --> 04:27.720
铺起一个inputref

04:27.720 --> 04:28.720
看一下吧

04:28.720 --> 04:29.720
保存

04:30.720 --> 04:31.720
看一下

04:33.720 --> 04:34.720
不过那倒是

04:34.720 --> 04:35.720
现在这个组件

04:35.720 --> 04:36.720
没有重新渲染

04:36.720 --> 04:37.720
对吧

04:37.720 --> 04:39.720
它倒是没有重新渲染

04:41.720 --> 04:42.720
那这样吧

04:42.720 --> 04:43.720
我就强行让它重新渲染

04:43.720 --> 04:44.720
行不行

04:44.720 --> 04:46.720
我让它强行让它重新渲染

04:46.720 --> 04:47.720
好

04:47.720 --> 04:48.720
来吧

04:48.720 --> 04:49.720
随便写一个

04:49.720 --> 04:50.720
useState

04:50.720 --> 04:52.720
强行让它重新渲染

04:52.720 --> 04:54.720
当然我们就模拟这个场景嘛

04:55.720 --> 04:56.720
useState

04:57.720 --> 04:58.720
n还是n

04:58.720 --> 04:59.720
0

04:59.720 --> 05:00.720
下面写

05:00.720 --> 05:01.720
一种的

05:01.720 --> 05:02.720
写个什么

05:02.720 --> 05:03.720
number

05:03.720 --> 05:05.720
value等于n

05:06.720 --> 05:07.720
然后呢

05:07.720 --> 05:08.720
unchange

05:09.720 --> 05:12.350
e

05:12.350 --> 05:13.350
然后呢

05:13.350 --> 05:14.350
这里

05:14.350 --> 05:15.350
setn

05:15.350 --> 05:17.350
就直接点e点target

05:17.350 --> 05:18.350
点value

05:18.350 --> 05:19.350
我这样做的目的主要是

05:19.350 --> 05:20.350
为了让这个组件重新渲染

05:20.350 --> 05:21.350
其他没有什么目的

05:23.350 --> 05:24.350
什么意思

05:26.350 --> 05:27.350
少许个括号

05:28.350 --> 05:29.350
保存

05:29.350 --> 05:30.350
看一下

05:31.350 --> 05:32.350
那么现在呢

05:32.350 --> 05:33.350
我们这里

05:33.350 --> 05:34.350
看一下这个

05:34.350 --> 05:35.350
AR

05:35.350 --> 05:36.350
是不是有一个

05:36.350 --> 05:37.350
有两个了

05:37.350 --> 05:38.350
运行

05:38.350 --> 05:39.350
AR

05:40.350 --> 05:41.350
有两个

05:41.350 --> 05:42.350
有两个原因呢

05:42.350 --> 05:43.350
还是这里

05:43.350 --> 05:44.350
还是这个调试工具

05:44.350 --> 05:45.350
它运行了这个

05:45.350 --> 05:46.350
运行这个函数两次

05:46.350 --> 05:48.350
它对根结点的运行的两次

05:48.350 --> 05:49.350
是因为一个调试工具的原因

05:49.350 --> 05:51.350
不是说它一定会运行

05:51.350 --> 05:53.350
这里一定会运行两次

05:53.350 --> 05:54.350
那么现在呢

05:54.350 --> 05:55.350
我们主要是看一下这里

05:55.350 --> 05:56.350
改变

05:56.350 --> 05:57.350
改变

05:57.350 --> 05:58.350
加了几个

05:58.350 --> 05:59.350
你看一下

05:59.350 --> 06:00.350
AR里面

06:00.350 --> 06:01.350
好

06:01.350 --> 06:02.350
咱们来测试一下

06:02.350 --> 06:03.350
AR的0

06:03.350 --> 06:04.350
是不是等于AR的表示

06:04.350 --> 06:05.350
随便写个吗

06:05.350 --> 06:06.350
force

06:06.350 --> 06:07.350
对吧

06:07.350 --> 06:08.350
是force

06:08.350 --> 06:09.350
它每个对象不一样

06:09.350 --> 06:11.350
那你觉得有这个必要吗

06:11.350 --> 06:12.350
我这个对象有必要

06:12.350 --> 06:14.350
每一次去新创建一个吗

06:14.350 --> 06:15.350
是不是没有必要啊

06:15.350 --> 06:16.350
有这个必要吗

06:16.350 --> 06:18.350
没有必要去新创建一个

06:18.350 --> 06:19.350
所以说呢

06:19.350 --> 06:20.350
为了

06:20.350 --> 06:22.350
为了解决这个问题啊

06:22.350 --> 06:23.350
我们是不是可以

06:23.350 --> 06:25.350
应该使用一个固定的对象

06:25.350 --> 06:26.350
那有些同学说

06:26.350 --> 06:27.350
那很简单啊

06:27.350 --> 06:28.350
这个代码写上面

06:28.350 --> 06:29.350
来不就完了吗

06:29.350 --> 06:31.350
写上面是不是固定一个对象

06:31.350 --> 06:32.350
但是你这样子

06:32.350 --> 06:33.350
又会出问题

06:33.350 --> 06:34.350
因为它有可能会

06:34.350 --> 06:35.350
到时候用这个组件的时候

06:35.350 --> 06:38.350
可能会用两次

06:38.350 --> 06:39.350
它可能会用两次

06:39.350 --> 06:40.350
这个组件

06:40.350 --> 06:41.350
它生成两个节点

06:41.350 --> 06:42.350
那么是不是

06:42.350 --> 06:43.350
这两个节点

06:43.350 --> 06:44.350
共享一个ref了

06:44.350 --> 06:45.350
那是不是肯定有问题

06:45.350 --> 06:46.350
大了这个问题

06:46.350 --> 06:47.350
对吧

06:47.350 --> 06:48.350
共享一个ref对象了

06:48.350 --> 06:49.350
那么两个组件之间

06:49.350 --> 06:51.350
是不是会产生干扰

06:51.350 --> 06:52.350
对不对

06:52.350 --> 06:53.350
这样子也不行

06:53.350 --> 06:54.350
也不能写到外面

06:54.350 --> 06:55.350
写到外面的话

06:55.350 --> 06:56.350
就是全局通用了

06:56.350 --> 06:57.350
那就是说

06:57.350 --> 06:58.350
多个组件

06:58.350 --> 06:59.350
它也可以共享一个ref了

06:59.350 --> 07:00.350
那肯定不行

07:00.350 --> 07:01.350
好

07:01.350 --> 07:02.350
所以说呢

07:02.350 --> 07:03.350
我们希望的是

07:03.350 --> 07:04.350
一个节点

07:04.350 --> 07:05.350
有一个ref

07:05.350 --> 07:06.350
那怎么办呢

07:06.350 --> 07:07.350
就使用这个

07:07.350 --> 07:10.350
叫做useref

07:10.350 --> 07:11.350
它专门干这个事了

07:11.350 --> 07:12.350
所以说

07:12.350 --> 07:13.350
在寒石组件里面

07:13.350 --> 07:15.350
尽量不要使用这个ref

07:15.350 --> 07:16.350
尽量不要使用这个玩意

07:17.350 --> 07:18.350
应该使用什么

07:18.350 --> 07:19.350
使用这个useref

07:19.350 --> 07:20.350
完了

07:20.350 --> 07:21.350
没了

07:21.350 --> 07:22.350
没了

07:22.350 --> 07:23.350
你看一下吧

07:23.350 --> 07:24.350
保存

07:25.350 --> 07:26.350
你看一下吧

07:26.350 --> 07:27.350
随便你怎么玩

07:27.350 --> 07:28.350
随便怎么玩

07:28.350 --> 07:29.350
点点点

07:29.350 --> 07:30.350
随便怎么玩

07:30.350 --> 07:31.350
看一下

07:35.500 --> 07:36.500
24个

07:36.500 --> 07:37.500
24个

07:37.500 --> 07:38.500
好

07:38.500 --> 07:39.500
现在呢

07:39.500 --> 07:40.500
因为它调试工具存在

07:40.500 --> 07:42.500
它运行的多次

07:42.500 --> 07:43.500
运行的多次

07:43.500 --> 07:44.500
不过这个没关系

07:46.500 --> 07:47.500
看着

07:47.500 --> 07:48.500
那么现在呢

07:48.500 --> 07:50.500
我们找到这个AR0

07:50.500 --> 07:51.500
然后呢

07:51.500 --> 07:53.500
是不是等于AR10

07:54.500 --> 07:56.500
看是不是全部一样的

07:56.500 --> 07:57.500
这些ref的

07:57.500 --> 07:58.500
实际上是同一个对象

07:58.500 --> 07:59.500
全部一样的

07:59.500 --> 08:01.500
每个对象是一样的

08:01.500 --> 08:03.500
每个对象是一样的

08:03.500 --> 08:04.500
明白我的意思吗

08:04.500 --> 08:05.500
所以说呢

08:05.500 --> 08:06.500
我们这里呢

08:06.500 --> 08:07.500
就肯定用这个useref

08:07.500 --> 08:09.500
来产生一个唯一地址

08:09.500 --> 08:10.500
就是一个组件

08:10.500 --> 08:11.500
有一个唯一地址

08:11.500 --> 08:13.500
每一个组件都有自己的唯一地址

08:13.500 --> 08:15.500
这么一个ref对象

08:15.500 --> 08:16.500
明白我的意思吗

08:17.500 --> 08:18.500
其实不仅如此

08:18.500 --> 08:19.500
好像看上去呢

08:19.500 --> 08:21.500
这个函数只用来产生一个ref

08:21.500 --> 08:22.500
其实不是的

08:22.500 --> 08:24.500
由于它能够产生一个

08:24.500 --> 08:26.500
具有唯一地址的对象

08:26.500 --> 08:27.500
所以说呢

08:27.500 --> 08:29.500
我们可以利用它做很多的事情

08:29.500 --> 08:30.500
比方说啊

08:30.500 --> 08:32.500
就是一个组件

08:32.500 --> 08:33.500
就是一个节点

08:33.500 --> 08:34.500
它对你一个唯一的对象

08:34.500 --> 08:35.500
一个节点

08:35.500 --> 08:36.500
对你一个唯一的对象

08:36.500 --> 08:37.500
我们就可以利用它

08:37.500 --> 08:38.500
做很多的事情

08:38.500 --> 08:39.500
就例子

08:39.500 --> 08:41.500
比方说这个App呢

08:41.500 --> 08:43.500
它是这样子

08:43.500 --> 08:45.500
它有这么一个计时器

08:46.500 --> 08:47.500
这个计时器里边

08:47.500 --> 08:49.500
要显示一个number

08:49.500 --> 08:51.500
显示一个

08:51.500 --> 08:52.500
显示个啥呢

08:52.500 --> 08:55.500
显示一个数字n

08:55.500 --> 08:57.500
显示个数字n

08:57.500 --> 08:58.500
那如果我们按照

08:58.500 --> 08:59.500
以前的做法呢

08:59.500 --> 09:01.500
应该就是一个倒计时嘛

09:01.500 --> 09:02.500
倒计时时秒

09:02.500 --> 09:03.500
倒零的时候停止

09:03.500 --> 09:04.500
倒零的时候停止

09:04.500 --> 09:05.500
然后函数

09:05.500 --> 09:06.500
这个组件被卸下的时候

09:06.500 --> 09:08.500
也把计时器给清空

09:08.500 --> 09:11.500
比方说做这么一个例子

09:11.500 --> 09:12.500
做这么一个例子

09:12.500 --> 09:13.500
那么接下来呢

09:13.500 --> 09:14.500
我们看一下

09:14.500 --> 09:17.500
我们怎么来去处理这个问题

09:17.500 --> 09:18.500
我们这里呢

09:18.500 --> 09:19.500
可以这样子写

09:19.500 --> 09:21.500
useState

09:21.500 --> 09:22.500
有个n

09:22.500 --> 09:23.500
数字n

09:23.500 --> 09:25.500
它是从10开始

09:25.500 --> 09:26.500
这里显示啥

09:26.500 --> 09:27.500
显示数字n

09:27.500 --> 09:28.500
接下来

09:28.500 --> 09:29.500
这个组件一开始

09:29.500 --> 09:31.500
就进行倒计时

09:31.500 --> 09:32.500
一开始就进行倒计时

09:32.500 --> 09:33.500
怎么倒计时呢

09:33.500 --> 09:35.500
是不是用一个副作用

09:35.500 --> 09:37.500
useEffect

09:37.500 --> 09:38.500
好副作用

09:38.500 --> 09:40.500
好副作用里边

09:40.500 --> 09:41.500
看着

09:41.500 --> 09:42.500
我们按照这些

09:42.500 --> 09:43.500
给它个空数组

09:43.500 --> 09:44.500
表示呢

09:44.500 --> 09:46.500
它不依赖任何东西

09:46.500 --> 09:47.500
它只是说

09:47.500 --> 09:48.500
干嘛呢

09:48.500 --> 09:50.500
只是每一次

09:50.500 --> 09:52.500
每一次

09:52.500 --> 09:53.500
减少1

09:53.500 --> 09:54.500
每一次减少1

09:54.500 --> 09:55.500
它不是

09:55.500 --> 09:57.500
n开始不是10吗

09:57.500 --> 09:58.500
每过一秒钟

09:58.500 --> 10:01.500
我们这里set interval

10:01.500 --> 10:03.500
每过一秒钟

10:03.500 --> 10:04.500
干嘛呢

10:04.500 --> 10:06.500
我是不是重新设止n

10:06.500 --> 10:07.500
对不对

10:07.500 --> 10:08.500
重新设止n

10:08.500 --> 10:10.500
这个n的值等于啥呢

10:10.500 --> 10:12.500
这个n的值

10:12.500 --> 10:13.500
等于啥呢

10:13.500 --> 10:14.500
有一种人说

10:14.500 --> 10:16.500
能不能写n-1

10:16.500 --> 10:18.500
能不能写n-1呢

10:18.500 --> 10:20.500
那如果你写n-1的话

10:20.500 --> 10:21.500
首先这里要报警告

10:21.500 --> 10:23.500
它要依赖这个数据n

10:23.500 --> 10:24.500
好你这样一写的话

10:24.500 --> 10:25.500
你是不是改变了n

10:25.500 --> 10:26.500
改变了n过后

10:26.500 --> 10:27.500
下一次渲染过后

10:27.500 --> 10:28.500
是不是要重新运行这个函数

10:28.500 --> 10:30.500
是不是又开了一个计时写

10:30.500 --> 10:31.500
是不是开了多个计时写

10:31.500 --> 10:32.500
对吧

10:32.500 --> 10:33.500
当时我们怎么说的

10:33.500 --> 10:34.500
这个问题怎么说的

10:34.500 --> 10:35.500
是不是这里写什么

10:35.500 --> 10:36.500
set timeout对吧

10:36.500 --> 10:38.500
写这个函数是最好的

10:38.500 --> 10:40.500
是能解决这个问题的

10:40.500 --> 10:41.500
useEffect

10:41.500 --> 10:43.500
所以说你之前

10:43.500 --> 10:44.500
我们之前

10:44.500 --> 10:46.500
讲的每一个练习

10:46.500 --> 10:47.500
你一定要去自己做一遍

10:47.500 --> 10:48.500
不然的话

10:48.500 --> 10:49.500
一点印象都没有

10:49.500 --> 10:50.500
你当时听懂了

10:50.500 --> 10:51.500
很快就忘了

10:51.500 --> 10:52.500
当时我们说

10:52.500 --> 10:53.500
要写成这个

10:53.500 --> 10:54.500
这样子保证了

10:54.500 --> 10:55.500
每一次渲染的时候

10:55.500 --> 10:57.500
把之前的那个n

10:57.500 --> 10:59.500
就是把当时渲染那一次的n

10:59.500 --> 11:00.500
拿出来

11:00.500 --> 11:01.500
简移重新设置

11:01.500 --> 11:03.500
这里要一秒钟之过后

11:03.500 --> 11:04.500
重新设置

11:04.500 --> 11:06.500
设置个n

11:06.500 --> 11:07.500
对吧

11:07.500 --> 11:08.500
是不是这样子

11:08.500 --> 11:10.500
没问题吧

11:11.500 --> 11:12.500
然后当时

11:12.500 --> 11:14.500
我们是写了一个timeout

11:14.500 --> 11:15.500
对不对

11:15.500 --> 11:16.500
写了一个timeout变亮

11:16.500 --> 11:17.500
写了一个timeout变亮

11:17.500 --> 11:19.500
那个timeout变亮

11:19.500 --> 11:20.500
我们写到哪儿的

11:20.500 --> 11:22.500
我们当时写到这儿的

11:22.500 --> 11:23.500
不知道大家还记不记得

11:23.500 --> 11:24.500
当时写到这儿的

11:24.500 --> 11:25.500
对吧

11:25.500 --> 11:26.500
我们把timeout

11:26.500 --> 11:27.500
给它复制为什么

11:27.500 --> 11:28.500
set timeout对吧

11:28.500 --> 11:30.500
然后我们这里return

11:30.500 --> 11:31.500
一个函数

11:31.500 --> 11:32.500
清理函数

11:32.500 --> 11:33.500
清理函数怎么写的

11:33.500 --> 11:36.500
clear timeout timeout

11:36.500 --> 11:39.500
然后如果说n等于了0

11:40.500 --> 11:43.500
如果说n-1等于了0

11:43.500 --> 11:44.500
是不是减到0了

11:44.500 --> 11:45.500
减到0过后

11:45.500 --> 11:47.500
我们用什么clear timeout

11:47.500 --> 11:48.500
timeout对吧

11:51.500 --> 11:52.500
let

11:53.500 --> 11:54.500
是不是这样子

11:54.500 --> 11:55.500
我们当时是不是这样子写的

11:55.500 --> 11:56.500
保存看一下

11:57.500 --> 11:58.500
你看一下

11:58.500 --> 11:59.500
所以每一次渲染完

11:59.500 --> 12:00.500
完了过后

12:00.500 --> 12:01.500
又启动一个计时器

12:01.500 --> 12:02.500
每一次渲染完了过后

12:02.500 --> 12:03.500
都启动一个计时器

12:03.500 --> 12:04.500
一秒钟过后了

12:04.500 --> 12:05.500
是不是又减1

12:05.500 --> 12:06.500
减1过后又渲染

12:06.500 --> 12:07.500
渲染完了过后

12:07.500 --> 12:08.500
又启动一个计时器

12:08.500 --> 12:10.500
怎么变成负疑了

12:10.500 --> 12:11.500
只要养了半天

12:11.500 --> 12:12.500
结果变成负疑了

12:12.500 --> 12:14.500
不尴尬这个事情

12:15.500 --> 12:16.500
n的值

12:16.500 --> 12:17.500
现在

12:18.500 --> 12:19.500
看一下

12:19.500 --> 12:20.500
它怎么

12:22.500 --> 12:23.500
看一下

12:23.500 --> 12:25.500
如果n的值为1的值

12:26.500 --> 12:27.500
1的时候

12:27.500 --> 12:29.500
我们这里输出一下n吧

12:29.500 --> 12:30.500
这里输出一下n

12:30.500 --> 12:31.500
看一下怎么回事

12:35.500 --> 12:37.500
由于这里是同步渲染的

12:37.500 --> 12:38.500
它不是异步的

12:38.500 --> 12:39.500
同步渲染的

12:40.500 --> 12:41.500
就是说有的时候

12:41.500 --> 12:42.500
你分不清楚

12:42.500 --> 12:43.500
它是同步

12:44.500 --> 12:45.500
你分不清楚

12:45.500 --> 12:46.500
它是同步

12:46.500 --> 12:47.500
还是异步的话

12:51.130 --> 12:52.130
想一想

12:52.130 --> 12:55.820
当时我是不是这样子写的

12:55.820 --> 12:56.820
当时我不是这样子写的

12:56.820 --> 12:58.820
我是在这里判断的

12:58.820 --> 12:59.820
判断

12:59.820 --> 13:00.820
如果n的值

13:00.820 --> 13:02.820
已经是0了

13:02.820 --> 13:03.820
那我就不要做

13:03.820 --> 13:04.820
任何副作用操作了

13:04.820 --> 13:05.820
我们是在这里写的

13:05.820 --> 13:06.820
因为你不能在这里写

13:06.820 --> 13:07.820
为什么呢

13:07.820 --> 13:08.820
因为

13:08.820 --> 13:09.820
它每次

13:09.820 --> 13:10.820
每一次只要一渲染

13:10.820 --> 13:11.820
只要一重新渲染

13:11.820 --> 13:13.820
它一定会启动一个计时器

13:13.820 --> 13:14.820
这是跑不了的

13:14.820 --> 13:15.820
一定会启动一个计时器

13:15.820 --> 13:17.820
就在这里边判断没用

13:17.820 --> 13:18.820
它只要一

13:18.820 --> 13:19.820
因为这里边会导致重新渲染

13:19.820 --> 13:20.820
一重新渲染

13:20.820 --> 13:21.820
它又会启动一个计时器

13:21.820 --> 13:22.820
所以说计时器

13:22.820 --> 13:23.820
它是一定启动的

13:23.820 --> 13:24.820
我们要判断的是什么

13:24.820 --> 13:26.820
不知道让它启动计时器

13:26.820 --> 13:27.820
就当某一个情况下

13:27.820 --> 13:28.820
它是不能启动计时器的

13:28.820 --> 13:30.820
应该在这里边判断

13:30.820 --> 13:31.820
再来

13:31.820 --> 13:32.820
这才是符合逻辑的

13:32.820 --> 13:33.820
看一下

13:33.820 --> 13:34.820
9

13:34.820 --> 13:35.820
8

13:35.820 --> 13:36.820
7

13:36.820 --> 13:37.820
没有必要写了

13:38.820 --> 13:39.820
10

13:39.820 --> 13:40.820
2

13:40.820 --> 13:41.820
1

13:41.820 --> 13:42.820
0

13:42.820 --> 13:43.820
好

13:43.820 --> 13:44.820
正确了

13:45.820 --> 13:48.820
现在的问题是什么呢

13:48.820 --> 13:50.820
现在的问题

13:50.820 --> 13:53.820
就是说如果它在倒计时期间

13:53.820 --> 13:55.820
如果说它在倒计

13:56.820 --> 13:58.820
我们输出个N

13:58.820 --> 14:00.820
如果说它在倒计时期间

14:00.820 --> 14:01.820
发生了一件事

14:01.820 --> 14:03.820
导致了这个东西清楚

14:03.820 --> 14:05.820
导致了这个东西

14:06.820 --> 14:08.820
被卸载

14:09.820 --> 14:12.820
那么我们需要清除这个计时器

14:12.820 --> 14:14.820
但是大家考虑过这么一个问题没有

14:14.820 --> 14:17.820
如果说这个组件用了多次

14:17.820 --> 14:19.820
如果说这个组件

14:19.820 --> 14:22.820
它用了多次这个组件

14:22.820 --> 14:24.820
那么其中一个组件被卸载的时候

14:24.820 --> 14:26.820
是不是导致了

14:26.820 --> 14:28.820
有可能会导致

14:28.820 --> 14:31.820
其他组件的timer被卸载

14:31.820 --> 14:32.820
因为这个timer变量

14:32.820 --> 14:33.820
是不是统一的

14:33.820 --> 14:36.820
就是是用了共用了一个变量对吧

14:36.820 --> 14:38.820
这个多个这个组件共用了一个变量

14:38.820 --> 14:40.820
一个这个timer变量

14:40.820 --> 14:41.820
那么其中一个组件卸载的时候

14:41.820 --> 14:42.820
是不是导致了

14:42.820 --> 14:45.820
其他组件的timer可能也不能用了

14:45.820 --> 14:47.820
明白这个意思吗

14:47.820 --> 14:48.820
所以说这样做呢

14:48.820 --> 14:49.820
其实是不好的

14:49.820 --> 14:51.820
我们希望的是每一个节点

14:51.820 --> 14:53.820
用一个timer

14:53.820 --> 14:54.820
每一个节点用一个timer

14:54.820 --> 14:56.820
而不是每一个这个函数

14:56.820 --> 14:57.820
比较这个函数

14:57.820 --> 14:59.820
这个函数可以生成10个组件

14:59.820 --> 15:01.820
10个节点

15:01.820 --> 15:03.820
共用一个timer那肯定不合理

15:03.820 --> 15:05.820
每一个节点用一个timer

15:05.820 --> 15:06.820
那怎么做呢

15:06.820 --> 15:08.820
我们需要把这个timer

15:08.820 --> 15:10.820
用一个固定的对象

15:10.820 --> 15:11.820
就是一个节点

15:11.820 --> 15:12.820
它都用一个固定的对象

15:12.820 --> 15:13.820
把它放进去

15:13.820 --> 15:14.820
因此我们这里可以使用到

15:14.820 --> 15:15.820
NewRef

15:15.820 --> 15:16.820
NewRef

15:16.820 --> 15:17.820
默认值啥呢

15:17.820 --> 15:18.820
默认值啥都没有

15:18.820 --> 15:19.820
啥都没有

15:19.820 --> 15:20.820
那么这里呢

15:20.820 --> 15:22.820
就是得到一个值

15:22.820 --> 15:25.820
就是timerRef

15:25.820 --> 15:27.820
那么这个东西跟元素无关了

15:27.820 --> 15:28.820
跟那些元

15:28.820 --> 15:31.820
就不是用来获得元素的数据了

15:31.820 --> 15:32.820
而是就是来保存

15:32.820 --> 15:34.820
用一个统一的变量来保存数据

15:34.820 --> 15:35.820
好那么这里呢

15:35.820 --> 15:37.820
我们就可以用

15:37.820 --> 15:38.820
timerRef

15:38.820 --> 15:39.820
Horrent

15:39.820 --> 15:40.820
在这里边

15:40.820 --> 15:42.820
来给它复制

15:42.820 --> 15:43.820
你看一下

15:43.820 --> 15:44.820
这样子呢

15:44.820 --> 15:45.820
是不是每一个组件

15:45.820 --> 15:46.820
都有一个固定的东西了

15:46.820 --> 15:47.820
有一个固定的timer了

15:47.820 --> 15:48.820
对不对

15:48.820 --> 15:49.820
有一个固定的数据

15:49.820 --> 15:50.820
每一个节点

15:50.820 --> 15:51.820
对应一个固定的对象

15:51.820 --> 15:52.820
对象里面

15:52.820 --> 15:53.820
你想放啥放啥

15:53.820 --> 15:55.820
I放啥放啥

15:55.820 --> 15:56.820
你还甚至还可以多次

15:56.820 --> 15:57.820
调用这个useRef

15:57.820 --> 15:58.820
来得到多个数据

15:58.820 --> 15:59.820
对吧

15:59.820 --> 16:00.820
都可以

16:00.820 --> 16:01.820
都可以

16:01.820 --> 16:02.820
其实效果是一样的

16:02.820 --> 16:03.820
效果是一样的

16:03.820 --> 16:07.330
没问题吧

16:07.330 --> 16:09.330
所以效果也是一样的

16:09.330 --> 16:10.330
这就是

16:10.330 --> 16:12.330
就说明这个做法

16:12.330 --> 16:13.330
如果说这个做法

16:13.330 --> 16:14.330
你看着

16:14.330 --> 16:16.330
还不是很清楚的话

16:16.330 --> 16:17.330
我们再写一个

16:17.330 --> 16:18.330
再写一个

16:18.330 --> 16:20.330
就看得更加清楚了

16:20.330 --> 16:21.330
那么现在呢

16:21.330 --> 16:22.330
我们这样子写

16:22.330 --> 16:24.330
看着

16:24.330 --> 16:26.330
我们这样子写

16:26.330 --> 16:28.330
我这里呢

16:28.330 --> 16:30.330
写这样子写

16:30.330 --> 16:31.330
这样子写

16:31.330 --> 16:32.330
useRef

16:32.330 --> 16:33.330
我们这里呢

16:33.330 --> 16:35.330
nRef

16:35.330 --> 16:36.330
这里

16:36.330 --> 16:38.330
默认值为n

16:38.330 --> 16:39.330
我要干嘛

16:39.330 --> 16:41.330
我把它放到n里边

16:41.330 --> 16:43.330
我要用n的值

16:43.330 --> 16:44.330
来初识化这个Ref

16:44.330 --> 16:45.330
这是一个对象

16:45.330 --> 16:46.330
对吧

16:46.330 --> 16:47.330
那么它得到一个对象

16:47.330 --> 16:48.330
是不是这样的对象

16:48.330 --> 16:49.330
corrent等于10

16:49.330 --> 16:50.330
对不对

16:50.330 --> 16:51.330
n的值是10

16:51.330 --> 16:52.330
给它一个默认值

16:52.330 --> 16:54.330
corrent等于10

16:54.330 --> 16:55.330
好 接下来呢

16:55.330 --> 16:56.330
we use effect

16:56.330 --> 16:58.330
好 这里怎么玩呢

16:58.330 --> 16:59.330
我们这样子玩

16:59.330 --> 17:02.960
setInterval

17:02.960 --> 17:04.960
setInterval

17:04.960 --> 17:06.960
那么这个Interval里边干嘛呢

17:06.960 --> 17:08.960
每隔1秒钟

17:08.960 --> 17:10.960
每隔1秒钟

17:10.960 --> 17:11.960
然后呢

17:11.960 --> 17:12.960
我们减1

17:12.960 --> 17:13.960
对吧

17:13.960 --> 17:15.960
setn

17:15.960 --> 17:16.960
减1

17:16.960 --> 17:17.960
怎么来减1呢

17:17.960 --> 17:19.960
我这里不能直接使用n

17:19.960 --> 17:20.960
我这里这样子

17:20.960 --> 17:21.960
去掉

17:21.960 --> 17:22.960
因为我之前解释过

17:22.960 --> 17:24.960
为什么不能直接使用n

17:24.960 --> 17:25.960
因为如果你说

17:25.960 --> 17:27.960
你直接使用n的话

17:27.960 --> 17:29.960
那么这个n的值是不是

17:29.960 --> 17:31.960
是在运行负重用函数的时候

17:31.960 --> 17:32.960
就运行这句话的时候

17:32.960 --> 17:33.960
当时的n的值

17:33.960 --> 17:34.960
永远都是当时的n的值

17:34.960 --> 17:36.960
n的值是永远不会改变的

17:36.960 --> 17:37.960
所以你不能使用n

17:37.960 --> 17:40.960
但是我可以使用这个

17:40.960 --> 17:41.960
这是个对象

17:41.960 --> 17:42.960
对吧

17:42.960 --> 17:43.960
我们从这个对象里面

17:43.960 --> 17:44.960
取属性可以吧

17:44.960 --> 17:46.960
这个属性变化我能接受到吧

17:46.960 --> 17:47.960
因为我们用的是

17:47.960 --> 17:48.960
同一个对象

17:48.960 --> 17:49.960
对吧

17:49.960 --> 17:50.960
对象里面属性变化

17:50.960 --> 17:51.960
我能接受到吧

17:51.960 --> 17:54.960
我们把这个属性减1

17:54.960 --> 17:55.960
对吧

17:55.960 --> 17:56.960
这是n

17:56.960 --> 17:57.960
属性减1

17:57.960 --> 18:00.960
然后再把它自己的属性减减

18:00.960 --> 18:01.960
对不对

18:01.960 --> 18:03.960
这个随便改变无所谓

18:03.960 --> 18:04.960
这个随便改变

18:04.960 --> 18:05.960
因为它不是状态

18:05.960 --> 18:06.960
所以说这个随便改变

18:06.960 --> 18:07.960
改变它的属性

18:07.960 --> 18:08.960
它的属性减减

18:08.960 --> 18:10.960
先把它减1的值

18:10.960 --> 18:12.960
或者说先减减

18:12.960 --> 18:13.960
先属性

18:13.960 --> 18:15.960
它这个属性减减减

18:15.960 --> 18:17.960
然后再重新设置这个值

18:17.960 --> 18:18.960
对吧

18:18.960 --> 18:20.960
共有的对象

18:20.960 --> 18:21.960
然后判断一下

18:21.960 --> 18:24.960
如果说你这个减了过后

18:24.960 --> 18:26.960
current等于0

18:26.960 --> 18:27.960
如果等于0的话

18:27.960 --> 18:30.960
我清除你这个计时器

18:30.960 --> 18:31.960
const

18:31.960 --> 18:32.960
timeout

18:32.960 --> 18:33.960
我清除你这个计时器

18:33.960 --> 18:35.960
就是clear interval

18:35.960 --> 18:36.960
timeout

18:36.960 --> 18:37.960
以后我清除

18:37.960 --> 18:39.960
就是clear timeout

18:39.960 --> 18:40.960
clear interval的时候

18:40.960 --> 18:41.960
也是一样

18:41.960 --> 18:44.960
我清除你这个

18:44.960 --> 18:46.960
清除这个timeout

18:46.960 --> 18:47.960
对吧

18:47.960 --> 18:48.960
现在我现在

18:48.960 --> 18:49.960
现在timeout就可以放进来了

18:49.960 --> 18:51.960
因为这个函数它只运行一次

18:51.960 --> 18:52.960
你看这个函数

18:52.960 --> 18:53.960
它没有任何依赖相

18:53.960 --> 18:54.960
是不是它只运行一次

18:54.960 --> 18:55.960
到时候卸载这个

18:55.960 --> 18:56.960
主件的时候

18:56.960 --> 18:58.960
它再运行一次清理函数

18:58.960 --> 18:59.960
对吧

18:59.960 --> 19:00.960
所以说我没有必要写到外面去了

19:00.960 --> 19:02.960
当然这个写到外面

19:02.960 --> 19:04.960
写成个timeout rave也可以

19:04.960 --> 19:06.960
现在为什么我们可以使用

19:06.960 --> 19:07.960
interval了

19:07.960 --> 19:08.960
看一下

19:08.960 --> 19:10.960
为什么现在我们可以大能使用了

19:10.960 --> 19:13.960
是因为我们是通过 rave 来得到数据的

19:13.960 --> 19:15.960
这个 rave 是不是多次交用这个函数

19:15.960 --> 19:16.960
它共用一个对象

19:16.960 --> 19:17.960
对吧

19:17.960 --> 19:18.960
共用一个对象引用

19:18.960 --> 19:19.960
我就可以是实时的

19:19.960 --> 19:20.960
从这个对象里面

19:20.960 --> 19:22.960
这个数据里面去取东西

19:22.960 --> 19:23.960
对吧

19:23.960 --> 19:25.960
它是跨越多次交用这个函数的

19:25.960 --> 19:26.960
无论你交用十是一百是

19:26.960 --> 19:28.960
我们用的都是同一个对象

19:28.960 --> 19:30.960
我们可以改变这个对象里面的属性

19:30.960 --> 19:32.960
那么就是跨越多次交用

19:32.960 --> 19:33.960
我可以得到一些共享的数据

19:33.960 --> 19:34.960
对吧

19:34.960 --> 19:35.960
我把这个属性的值

19:35.960 --> 19:36.960
减1

19:36.960 --> 19:37.960
对吧

19:37.960 --> 19:38.960
减1

19:38.960 --> 19:40.960
然后我再去设置 current

19:40.960 --> 19:41.960
设置 n

19:41.960 --> 19:43.960
设置 n 的过程是不是重新渲染

19:43.960 --> 19:44.960
重新渲染

19:44.960 --> 19:45.960
重新渲染过后

19:45.960 --> 19:46.960
那是不是得到 n 的值

19:46.960 --> 19:47.960
到 n 的值

19:47.960 --> 19:48.960
然后呢

19:48.960 --> 19:49.960
我这里呢

19:49.960 --> 19:50.960
判断

19:50.960 --> 19:51.960
如果它等于0

19:51.960 --> 19:52.960
减到0

19:52.960 --> 19:53.960
然后把清空

19:53.960 --> 19:54.960
对吧

19:54.960 --> 19:55.960
那么就可以写出这么一种结构了

19:55.960 --> 19:56.960
总之

19:56.960 --> 19:57.960
这个UseRef

19:57.960 --> 19:59.960
它能够得到一个

19:59.960 --> 20:00.960
同一个节点

20:00.960 --> 20:01.960
共用

20:01.960 --> 20:03.960
共享一个对象

20:03.960 --> 20:05.960
这么一种格式

20:05.960 --> 20:07.960
比方说我们画个图

20:08.960 --> 20:09.960
就是说呢

20:09.960 --> 20:10.960
如果说我又有一个节点

20:10.960 --> 20:11.960
对吧

20:11.960 --> 20:12.960
我们之前说过

20:12.960 --> 20:13.960
虚的节点数

20:13.960 --> 20:16.960
这是一个函数组建节点

20:17.960 --> 20:18.960
组建节点

20:18.960 --> 20:19.960
那么同一个函数

20:19.960 --> 20:21.960
比方说这个函数是

20:21.960 --> 20:22.960
App

20:22.960 --> 20:23.960
这个函数

20:23.960 --> 20:24.960
那么它有可能有多个

20:24.960 --> 20:25.960
对吧

20:25.960 --> 20:26.960
有可能有多个这个节点

20:26.960 --> 20:28.960
有可能有很多个这个节点

20:28.960 --> 20:29.960
它有很多个

20:29.960 --> 20:32.960
那么我们现在希望呢

20:32.960 --> 20:35.960
节点之间那肯定是不能相互影响的

20:35.960 --> 20:36.960
节点之间

20:36.960 --> 20:38.960
我这个节点跟你是有什么关系的

20:38.960 --> 20:39.960
不能相互影响

20:39.960 --> 20:41.960
那么我们希望呢

20:41.960 --> 20:42.960
是同一个节点里边呢

20:42.960 --> 20:44.960
挂载一些数据

20:44.960 --> 20:46.960
那你多少次去调用这个函数

20:46.960 --> 20:47.960
使用的都是同一个数据

20:47.960 --> 20:48.960
那么这个时候呢

20:48.960 --> 20:50.960
我们就可以使用

20:50.960 --> 20:52.960
UseRef

20:52.960 --> 20:54.960
返回对象

20:54.960 --> 20:56.960
在函数里边使用UseRef

20:56.960 --> 20:57.960
返回对象的时候呢

20:57.960 --> 20:58.960
每一个节点的

20:58.960 --> 21:02.960
它不管调用多少次的函数

21:02.960 --> 21:03.960
它都会使用同一个

21:03.960 --> 21:04.960
返回对象

21:04.960 --> 21:06.960
当然你可以多次使用UseRef

21:06.960 --> 21:07.960
多次使用的话

21:07.960 --> 21:08.960
这是一次使用

21:08.960 --> 21:09.960
在第二次使用

21:09.960 --> 21:11.960
多次使用是不是得到不同的对象

21:11.960 --> 21:12.960
对吧

21:12.960 --> 21:13.960
你自己分开去处理

21:13.960 --> 21:14.960
用不同的变量名来接收

21:14.960 --> 21:16.960
分开处理

21:16.960 --> 21:18.960
它是形成这么一种结构

21:18.960 --> 21:19.960
有的时候呢

21:19.960 --> 21:20.960
我们需要在

21:20.960 --> 21:21.960
共享一些数据的时候

21:21.960 --> 21:22.960
就可以用这种方式

21:22.960 --> 21:26.420
好 OK

21:26.420 --> 21:29.420
这是关于这个Ref Hook

