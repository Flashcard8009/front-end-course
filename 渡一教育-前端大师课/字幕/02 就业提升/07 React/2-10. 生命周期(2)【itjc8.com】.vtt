WEBVTT

00:00.560 --> 00:03.560
这一课咱们来继续生命周期

00:03.560 --> 00:06.560
这一课我们说一下新版的生命周期

00:06.560 --> 00:11.560
主要是跟原版的生命周期来做一下对比

00:11.560 --> 00:15.560
大家现在看到的东西就是新版的生命周期

00:15.560 --> 00:17.560
你会发现新版的生命周期里边

00:17.560 --> 00:21.560
它初始化阶段和小鬼阶段是没有什么变化的

00:21.560 --> 00:22.560
都是一样的

00:22.560 --> 00:27.560
它主要的变化在挂载阶段和更新阶段

00:27.560 --> 00:29.560
它主要变化在这两个阶段

00:29.560 --> 00:32.560
一个是更新阶段 一个是挂载阶段

00:32.560 --> 00:33.560
那么对比一下

00:33.560 --> 00:35.560
我们先说挂载阶段吧

00:35.560 --> 00:36.560
挂载阶段的话

00:36.560 --> 00:39.560
我们对比一下9版的生命周期

00:39.560 --> 00:41.560
9版的生命周期有这么一个事件

00:41.560 --> 00:43.560
叫做Component Wheel Mount

00:43.560 --> 00:44.560
有这么一个事件

00:44.560 --> 00:47.560
然后再运行Render

00:47.560 --> 00:50.560
然后再运行ComponentDidMount

00:50.560 --> 00:52.560
运行这么三个东西

00:52.560 --> 00:54.560
然后在新版的生命周期里边

00:54.560 --> 00:57.560
你会发现它少了一个东西

00:57.560 --> 00:58.560
Render也会运行

00:58.560 --> 00:59.560
Render会运行

00:59.560 --> 01:01.560
然后ComponentDidMount

01:01.560 --> 01:02.560
我们之前说过

01:02.560 --> 01:07.560
ComponentDidMount这个勾字函数

01:07.560 --> 01:08.560
是非常非常常用的

01:08.560 --> 01:10.560
所以说它这个东西是保留的

01:10.560 --> 01:12.560
它不可能去删这个东西

01:12.560 --> 01:13.560
然后Render肯定不能删

01:13.560 --> 01:14.560
对不对

01:14.560 --> 01:15.560
那么它删了什么呢

01:15.560 --> 01:17.560
它删除了这个东西

01:17.560 --> 01:20.560
它删除了Component Wheel Mount

01:20.560 --> 01:22.560
删除了这么一个玩意

01:22.560 --> 01:25.560
这个玩意它删了之后

01:25.560 --> 01:27.560
为什么要有删

01:27.560 --> 01:29.560
因为它觉得这个函数

01:29.560 --> 01:30.560
它容易产生bug

01:30.560 --> 01:31.560
因为这个函数

01:31.560 --> 01:32.560
我们之前说过

01:32.560 --> 01:34.560
它有可能在某些特殊的情况下

01:34.560 --> 01:36.560
会被调用多次

01:36.560 --> 01:37.560
从而导致bug

01:37.560 --> 01:38.560
所以说到后来

01:38.560 --> 01:40.560
官方都不推荐

01:40.560 --> 01:43.560
不推荐去使用生命周期勾字函数了

01:43.560 --> 01:45.560
所以说它后来干脆把它移除掉

01:45.560 --> 01:46.560
说按了

01:46.560 --> 01:47.560
直接把它标去为过期的

01:47.560 --> 01:48.560
可能在江南的版本里面

01:48.560 --> 01:50.560
就直接把它给干掉了

01:50.560 --> 01:52.560
所以说它把生命周期函数给你去掉了

01:52.560 --> 01:53.560
不要让你用

01:53.560 --> 01:54.560
免得倒车出了问题

01:54.560 --> 01:55.560
你还要怪它

01:55.560 --> 01:57.560
所以说它就把它去掉了

01:57.560 --> 01:59.560
因此它现在加了这么一个东西

01:59.560 --> 02:01.560
加了这么一个生命周期函数

02:01.560 --> 02:03.560
这个叫做get

02:03.560 --> 02:05.560
divide

02:05.560 --> 02:06.560
这个这么多

02:06.560 --> 02:09.560
derived state from props

02:09.560 --> 02:10.560
这个derived的什么意思呢

02:10.560 --> 02:12.560
表示派生

02:12.560 --> 02:14.560
就得到获取

02:14.560 --> 02:15.560
什么意思呢

02:15.560 --> 02:16.560
就是获取一个状态

02:16.560 --> 02:17.560
从什么地方获取呢

02:17.560 --> 02:19.560
从一个属性里面获取状态

02:19.560 --> 02:21.560
我们一会再说一下

02:21.560 --> 02:23.560
生命周期勾字函数

02:23.560 --> 02:25.560
现在它是一个静态函数

02:25.560 --> 02:27.560
它是一个静态函数

02:27.560 --> 02:28.560
这是

02:28.560 --> 02:30.560
于是它现在生命周期勾字函数里面

02:30.560 --> 02:31.560
它多了这么一个东西

02:31.560 --> 02:32.560
而T换掉了什么

02:32.560 --> 02:35.560
T换掉了以前的component

02:35.560 --> 02:36.560
T换掉了这个东西

02:36.560 --> 02:37.560
这是第1个

02:37.560 --> 02:38.560
挂载阶段

02:38.560 --> 02:40.560
你会看到的变化

02:40.560 --> 02:42.560
然后我们再看更新阶段

02:42.560 --> 02:43.560
更新阶段

02:43.560 --> 02:44.560
更新阶段里面

02:44.560 --> 02:45.560
我们看到之前的

02:45.560 --> 02:48.560
当属性发生变化的时候

02:48.560 --> 02:50.560
它会先运行一个这个东西

02:50.560 --> 02:52.560
只是属性发生变化

02:52.560 --> 02:53.560
属性发生变化的时候

02:53.560 --> 02:54.560
它会运行这个玩意

02:54.560 --> 02:57.560
就是component will receive props

02:57.560 --> 02:59.560
它会运行这个东西

02:59.560 --> 03:00.560
然后现在没了

03:00.560 --> 03:01.560
你看没有

03:01.560 --> 03:02.560
属性变化过后

03:02.560 --> 03:03.560
它没有生命周期函数了

03:03.560 --> 03:05.560
它仍然是运行这个玩意

03:05.560 --> 03:07.560
仍然是运行这个玩意

03:07.560 --> 03:10.560
它把这个东西T换掉了

03:10.560 --> 03:12.560
然后以前状态变化过后

03:12.560 --> 03:13.560
它直接运行的是

03:13.560 --> 03:15.560
should component update

03:15.560 --> 03:17.560
它直接运行的是这个玩意

03:17.560 --> 03:18.560
那么现在的状态变化

03:18.560 --> 03:20.560
它也会运行这个东西

03:20.560 --> 03:22.560
它相当于是一个

03:22.560 --> 03:24.560
给你进行那个拦截

03:24.560 --> 03:26.560
在渲染之前有这么一个函数

03:26.560 --> 03:27.560
给你进行的拦截

03:27.560 --> 03:29.560
就是说你在渲染之前

03:29.560 --> 03:32.560
你始终会经过这么一个函数

03:32.560 --> 03:33.560
始终会经过这么一个函数

03:33.560 --> 03:35.560
我们一会再说这个函数

03:35.560 --> 03:37.560
然后后面都是一样的

03:37.560 --> 03:40.560
should component update render

03:40.560 --> 03:42.560
然后下边又出现了差异了

03:42.560 --> 03:43.560
下边出现什么差异呢

03:43.560 --> 03:46.560
就是在以前的生命周期函数里面

03:46.560 --> 03:48.560
出现了一个component will update

03:48.560 --> 03:50.560
后来官方觉得这个东西没啥用

03:50.560 --> 03:51.560
没啥意义

03:51.560 --> 03:53.560
在render之前出现的

03:53.560 --> 03:55.560
那么现在在render之前

03:55.560 --> 03:57.560
不是已经有了这么一个东西了吗

03:57.560 --> 03:58.560
在render之前

03:58.560 --> 03:59.560
已经有了这么一个东西了

03:59.560 --> 04:01.560
所以说它把这个东西也干掉了

04:01.560 --> 04:02.560
也干掉了

04:02.560 --> 04:04.560
然后给你加了一个

04:04.560 --> 04:05.560
加了一个什么呢

04:05.560 --> 04:07.560
加了一个component update

04:07.560 --> 04:08.560
前面加了一个这个

04:08.560 --> 04:10.560
获取更新前的快照

04:10.560 --> 04:12.560
get snapshot

04:12.560 --> 04:13.560
表示快照的意思

04:13.560 --> 04:15.560
在更新之前的快照

04:15.560 --> 04:16.560
加了这么一个生命周期函数

04:16.560 --> 04:18.560
所以说变化的关键点在什么呢

04:18.560 --> 04:20.560
加了一个这个东西

04:20.560 --> 04:21.560
在render之后

04:21.560 --> 04:24.560
然后在update之前

04:24.560 --> 04:25.560
运行的

04:25.560 --> 04:26.560
加了这么一个东西

04:26.560 --> 04:28.560
这个东西在什么时候运行

04:28.560 --> 04:30.560
是在render之前运行

04:30.560 --> 04:31.560
同时如果是更新阶段的话

04:31.560 --> 04:34.560
也会在should component update之前

04:34.560 --> 04:36.560
它会加了这么两个

04:36.560 --> 04:37.560
就加这么两个

04:37.560 --> 04:38.560
干掉了谁呢

04:38.560 --> 04:40.560
干掉了这几个will

04:40.560 --> 04:42.560
这几个will都干掉了

04:42.560 --> 04:43.560
就这个东西干掉了

04:43.560 --> 04:45.560
这个东西干掉了

04:45.560 --> 04:47.560
我们这里说一下

04:47.560 --> 04:48.560
为什么要干掉

04:48.560 --> 04:49.560
因为他有bug

04:49.560 --> 04:50.560
他可能会多次运行

04:50.560 --> 04:52.560
然后这个东西为什么要干掉

04:52.560 --> 04:53.560
他主要是没什么用了

04:53.560 --> 04:54.560
没什么用了

04:54.560 --> 04:55.560
在render之前

04:55.560 --> 04:56.560
他现在已经有了这么一个东西了

04:56.560 --> 04:57.560
已经有了这么一个东西了

04:57.560 --> 04:58.560
他觉得没啥用了

04:58.560 --> 05:00.560
所以把这个东西给你干掉了

05:00.560 --> 05:02.560
现在关键点在这

05:02.560 --> 05:05.560
他为什么要干掉这个东西

05:05.560 --> 05:06.560
为什么呢

05:06.560 --> 05:08.560
他真的是受不了了

05:08.560 --> 05:09.560
真的是受不了了

05:09.560 --> 05:11.560
除了问题全怪他

05:11.560 --> 05:13.560
所以他其实不是他的问题

05:13.560 --> 05:16.560
我们开发者使用的方式不正确

05:16.560 --> 05:18.560
使用的知识不正确

05:18.560 --> 05:20.560
所以说他后来干就直接干掉

05:20.560 --> 05:21.560
得了

05:21.560 --> 05:23.560
这个地方太容易出问题了

05:23.560 --> 05:24.560
为什么容易出问题呢

05:24.560 --> 05:26.560
第一个是他的效率问题

05:26.560 --> 05:28.560
在这里边可能有些开发者

05:28.560 --> 05:30.560
在这里边去使用set state

05:30.560 --> 05:32.560
保证了一些效率问题

05:32.560 --> 05:33.560
我们以后再看

05:33.560 --> 05:34.560
另外一个问题

05:34.560 --> 05:36.560
主要的问题他还不是效率

05:36.560 --> 05:37.560
主要的问题是

05:37.560 --> 05:40.560
这里边非常非常容易造成混乱

05:40.560 --> 05:42.560
为什么会容易造成混乱

05:42.560 --> 05:45.560
因为开发者他发现了这么一个现象

05:45.560 --> 05:46.560
这个生命周期函数

05:46.560 --> 05:48.560
它是在什么时候运行了

05:48.560 --> 05:50.560
它是在属性发生变化之后

05:50.560 --> 05:52.560
它会运行这种生命周期函数

05:52.560 --> 05:54.560
于是一些开发者

05:54.560 --> 05:56.560
就异想天开

05:56.560 --> 05:58.560
然后干出了这么一件事

05:58.560 --> 06:02.560
这件事后来被官方叫做反模式

06:04.560 --> 06:05.560
反模式

06:05.560 --> 06:06.560
什么叫反模式

06:06.560 --> 06:08.560
你可以把它理解为反面教材

06:08.560 --> 06:09.560
我们说我们的设计模式

06:09.560 --> 06:11.560
是一个正常的模式

06:11.560 --> 06:13.560
来解决一些常见问题的

06:13.560 --> 06:14.560
什么叫反模式

06:14.560 --> 06:17.560
就是看上去像是一个设计模式

06:17.560 --> 06:20.560
但是实际上它是违背了一些原则

06:20.560 --> 06:22.560
导致了更多的问题

06:22.560 --> 06:24.560
这就是反模式

06:24.560 --> 06:27.560
后来官方把它列成反面教材之一

06:27.560 --> 06:29.560
我们来看一下

06:29.560 --> 06:30.560
就这个生命周期函数

06:30.560 --> 06:32.560
会被怎样的滥用

06:32.560 --> 06:35.560
咱们来写这么一个例子

06:35.560 --> 06:37.560
这个例子里边

06:37.560 --> 06:40.560
我们就写一个test

06:41.560 --> 06:45.560
这个test里边我们有这么一个状态

06:45.560 --> 06:47.560
这个状态

06:47.560 --> 06:50.560
这个状态里边有一个数字n

06:50.560 --> 06:51.560
这个数字n

06:51.560 --> 06:53.560
这个数字n来自于哪呢

06:53.560 --> 06:56.560
来自于属性里边的n

06:56.560 --> 06:58.560
那一车代码我们是不是以前写过

06:58.560 --> 07:00.560
但是以前我们这样子写的

07:00.560 --> 07:02.560
还不算是很大的问题

07:02.560 --> 07:03.560
因为我们以前写个倒计时期

07:03.560 --> 07:05.560
你给我一个初始字

07:05.560 --> 07:07.560
我们只是把它当成初始字来使用

07:07.560 --> 07:09.560
它的属性我们用一次就算了

07:09.560 --> 07:11.560
后面我们就不会用到它的属性了

07:11.560 --> 07:12.560
都用的是状态

07:12.560 --> 07:14.560
但是你看着

07:14.560 --> 07:16.560
接下来的事情就变得有意思了

07:16.560 --> 07:18.560
接下来我们把它

07:18.560 --> 07:21.560
这个属性里边的n放过来

07:21.560 --> 07:22.560
放过来过后

07:22.560 --> 07:24.560
我们在div里边干了一件事

07:24.560 --> 07:27.560
就是我这里显示出

07:27.560 --> 07:30.560
我显示出这个n的数字

07:30.560 --> 07:32.560
来自于这个状态里边的n

07:32.560 --> 07:33.560
我希望干嘛呢

07:33.560 --> 07:36.560
就是有些开发者他开始想这么一件事

07:36.560 --> 07:37.560
我希望做这么一件事

07:37.560 --> 07:39.560
就是说我这里显示个数字n

07:39.560 --> 07:42.560
然后我这个组件里边有一个按钮

07:42.560 --> 07:43.560
有一个按钮

07:43.560 --> 07:46.560
这个按钮就是n加1

07:46.560 --> 07:48.560
就点一下n就加1

07:48.560 --> 07:49.560
就这么一个意思

07:49.560 --> 07:51.560
好来吧

07:51.560 --> 07:53.560
onclick

07:53.560 --> 07:54.560
这个很简单

07:54.560 --> 07:57.560
我为了解方便就直接在这里写了

07:57.560 --> 07:59.560
setState

07:59.560 --> 08:01.560
设字n等于什么值

08:01.560 --> 08:04.560
thisState.n

08:04.560 --> 08:05.560
加1

08:05.560 --> 08:08.560
把设字n跟它只加1

08:08.560 --> 08:09.560
加了1之后

08:09.560 --> 08:11.560
我来看一下目前的效果

08:11.560 --> 08:13.560
这个app以前的代码呢

08:13.560 --> 08:14.560
我就复制一下

08:14.560 --> 08:15.560
放过来

08:15.560 --> 08:16.560
那么重新来一个

08:16.560 --> 08:17.560
重新来一个

08:17.560 --> 08:19.560
这里是test

08:19.560 --> 08:22.560
主要是给大家说明一下这个问题

08:22.560 --> 08:25.560
这边我们就

08:25.560 --> 08:27.560
还是保留一个State

08:27.560 --> 08:29.560
number

08:29.560 --> 08:31.560
保留一个State number

08:31.560 --> 08:34.560
然后这边我们就div里边

08:34.560 --> 08:36.560
就达到一个组件

08:36.560 --> 08:38.560
给这个组件传入一个属性

08:38.560 --> 08:39.560
它不是需要个属性吗

08:39.560 --> 08:41.560
需要个属性n

08:41.560 --> 08:43.560
我把属性传给你

08:43.560 --> 08:44.560
传给谁呢

08:44.560 --> 08:45.560
就是thisState number

08:45.560 --> 08:47.560
把属性传给你

08:47.560 --> 08:48.560
好了

08:48.560 --> 08:51.560
这里我们运行出来看一下

08:51.560 --> 08:52.560
已经运行了

08:52.560 --> 08:53.560
保存

08:53.560 --> 08:55.560
流量器都关了

08:55.560 --> 08:57.560
重新来一次

08:57.560 --> 09:00.560
ear start

09:00.560 --> 09:04.190
就什么意思呢

09:04.190 --> 09:07.190
就是说我这个组件里面的n

09:07.190 --> 09:09.190
是通过这个属性传进去了

09:09.190 --> 09:11.190
通过这个属性传进去了

09:11.190 --> 09:12.190
然后这一方面

09:12.190 --> 09:13.190
把这个属性的n

09:13.190 --> 09:14.190
作为它的状态

09:14.190 --> 09:15.190
因为为什么要作为状态

09:15.190 --> 09:17.190
因为它自己要改变

09:17.190 --> 09:18.190
它自己要改变这个值

09:18.190 --> 09:19.190
目前来看的话

09:19.190 --> 09:20.190
没有什么问题

09:20.190 --> 09:22.190
目前为什么没有什么问题呢

09:22.190 --> 09:24.190
因为我

09:24.190 --> 09:27.760
为什么还是显示的

09:29.760 --> 09:31.760
我怎么感动到这了

09:31.760 --> 09:33.760
我怎么感动到这了

09:34.760 --> 09:35.760
放回去

09:35.760 --> 09:36.760
然后这边

09:36.760 --> 09:37.760
感动过来

09:42.760 --> 09:43.760
本来是没有什么问题的

09:43.760 --> 09:44.760
n加1

09:44.760 --> 09:45.760
你看它改变的是

09:45.760 --> 09:47.760
这个组件内部的状态

09:47.760 --> 09:48.760
而这个组件里边

09:48.760 --> 09:49.760
这个数据的来源

09:49.760 --> 09:51.760
它也是来自于状态的

09:51.760 --> 09:53.760
目前看是没有什么问题的

09:53.760 --> 09:54.760
这个属性的n

09:54.760 --> 09:55.760
表示什么意思

09:55.760 --> 09:58.760
表示的是这个状态的初始值

09:58.760 --> 10:00.760
目前是没有什么问题的

10:00.760 --> 10:01.760
但是

10:01.760 --> 10:03.760
有些开发者开始来想

10:03.760 --> 10:04.760
另外一个问题了

10:04.760 --> 10:05.760
就是说

10:05.760 --> 10:06.760
它就是说

10:06.760 --> 10:08.760
这个属性有可能会变化

10:08.760 --> 10:10.760
这个属性的值

10:10.760 --> 10:11.760
它有可能会变化

10:11.760 --> 10:12.760
它希望

10:12.760 --> 10:13.760
如果变化了之后

10:13.760 --> 10:15.760
要保持同步

10:15.760 --> 10:17.760
啥意思呢

10:17.760 --> 10:19.760
你看着

10:19.760 --> 10:20.760
在副组件里边

10:20.760 --> 10:22.760
我们还有一个按钮

10:22.760 --> 10:24.760
这是副组件

10:24.760 --> 10:25.760
按钮

10:25.760 --> 10:27.760
它也是起到一个加1的作用

10:27.760 --> 10:29.760
好 看着

10:29.760 --> 10:33.760
onclick

10:33.760 --> 10:34.760
onclick

10:34.760 --> 10:35.760
然后点击之后

10:35.760 --> 10:38.760
我们把副组件的状态发生变化

10:38.760 --> 10:39.760
就是把这个number

10:39.760 --> 10:40.760
设置为什么

10:40.760 --> 10:42.760
this

10:42.760 --> 10:43.760
this

10:43.760 --> 10:44.760
number

10:44.760 --> 10:45.760
加1

10:45.760 --> 10:47.760
this is state

10:47.760 --> 10:48.760
state.number

10:48.760 --> 10:50.760
加1

10:50.760 --> 10:51.760
好

10:51.760 --> 10:52.760
这是副组件里边的number

10:52.760 --> 10:53.760
副组件里边的number

10:53.760 --> 10:55.760
你看一下目前的情况

10:55.760 --> 10:57.760
我们点这个值的时候

10:57.760 --> 10:59.760
有没有改变副组件的number

10:59.760 --> 11:00.760
没有 对吧

11:00.760 --> 11:02.760
改变的是值组件里边的n

11:02.760 --> 11:04.760
我们把这个打开

11:04.760 --> 11:06.760
把这个打开看得很清楚

11:06.760 --> 11:07.760
这个结构

11:07.760 --> 11:08.760
看一下

11:08.760 --> 11:09.760
这个test里边

11:09.760 --> 11:10.760
你看

11:10.760 --> 11:12.760
它的属性是不是还是1

11:12.760 --> 11:13.760
属性还是1

11:13.760 --> 11:14.760
但状态发生变化了

11:14.760 --> 11:15.760
这个没有问题

11:15.760 --> 11:16.760
目前是没有问题的

11:16.760 --> 11:17.760
这个属性表示什么意思呢

11:17.760 --> 11:18.760
表示的是

11:18.760 --> 11:19.760
它当前的

11:19.760 --> 11:21.760
就是它的初始值

11:21.760 --> 11:22.760
但是有些开发者

11:22.760 --> 11:25.760
他没有把它当成一个初始值

11:25.760 --> 11:26.760
他认为

11:26.760 --> 11:29.760
如果副组件变化了过后

11:29.760 --> 11:30.760
你看副组件变化

11:30.760 --> 11:32.760
是不是导致值组件的属性发生变化

11:32.760 --> 11:34.760
如果副组件变化过后

11:34.760 --> 11:35.760
它这里的值

11:35.760 --> 11:37.760
又要变成副组件的

11:37.760 --> 11:39.760
因为副组件里边的状态

11:39.760 --> 11:41.760
你看副组件的状态

11:41.760 --> 11:43.760
是不是通过属性传过去了

11:43.760 --> 11:45.760
那么副组件发生变化的时候

11:45.760 --> 11:47.760
它值组件也要跟着变

11:47.760 --> 11:50.760
这就产生问题了

11:50.760 --> 11:53.760
以前的开发者他觉得没问题

11:53.760 --> 11:54.760
挺好的

11:54.760 --> 11:55.760
他会怎么写呢

11:55.760 --> 11:56.760
他会这样子写

11:56.760 --> 11:58.760
因为他发现有这么一个生命周期勾指函数

11:58.760 --> 12:00.760
他发现有这么一个函数

12:00.760 --> 12:02.760
这个函数里边

12:02.760 --> 12:04.760
它就会这样子来处理

12:04.760 --> 12:05.760
看着

12:05.760 --> 12:07.760
它在生命周期函数里边

12:07.760 --> 12:09.760
因为这个生命周期函数

12:09.760 --> 12:12.760
Component Will

12:12.760 --> 12:15.760
Receive

12:15.760 --> 12:18.760
这个生命周期函数

12:18.760 --> 12:20.760
它是在什么时候运行

12:20.760 --> 12:23.760
它是在属性发生变化的时候运行

12:23.760 --> 12:25.760
属性是别人传给我的

12:25.760 --> 12:27.760
也就是别人发生变化了

12:27.760 --> 12:29.760
属性发生变化的时候

12:29.760 --> 12:31.760
它做了这么一件事

12:31.760 --> 12:33.760
它做了什么事呢

12:33.760 --> 12:35.760
重新去设置

12:35.760 --> 12:38.760
重新去设置的状态

12:38.760 --> 12:41.760
它要保证属性的状态是一致的

12:41.760 --> 12:44.760
重新去设置的状态

12:44.760 --> 12:47.760
把它设置为next props.n

12:47.760 --> 12:49.760
它做了这么一件事

12:49.760 --> 12:52.760
你看一下这件事做了之后

12:52.760 --> 12:55.760
看上去了没有啥问题了

12:55.760 --> 12:57.760
看上去好像一切都正常了

12:57.760 --> 12:58.760
你看属性

12:58.760 --> 13:00.760
一开始初始只是一码

13:00.760 --> 13:02.760
然后自己的状态发生变化

13:02.760 --> 13:04.760
你看这里状态发生变化属性没变

13:04.760 --> 13:06.760
然后副主见的属性发生变化过后

13:06.760 --> 13:08.760
你看它变成二了

13:08.760 --> 13:11.760
比方说咱们就是这样的需求

13:11.760 --> 13:13.760
我们的需求就是这样子

13:13.760 --> 13:14.760
看上去没啥问题了

13:14.760 --> 13:16.760
你看副主见可以控制它

13:16.760 --> 13:18.760
直助键也可以控制它

13:18.760 --> 13:19.760
没啥问题了对吧

13:19.760 --> 13:21.760
好 那我们来说一下它的问题在哪

13:21.760 --> 13:23.760
它的问题在哪呢

13:23.760 --> 13:25.760
效率问题我们都不说了

13:25.760 --> 13:27.760
效率问题我们以后分析它的原理的时候

13:27.760 --> 13:29.760
分析Rx原理的时候我们再说

13:29.760 --> 13:31.760
效率问题反正它肯定是有

13:31.760 --> 13:34.760
在某些情况下是有效率问题的

13:34.760 --> 13:35.760
那个不是关键

13:35.760 --> 13:37.760
关键点在于什么呢

13:37.760 --> 13:39.760
关键点在于

13:39.760 --> 13:41.760
如果你这样去思考问题的话

13:41.760 --> 13:45.760
这个数据的来源它不再单一了

13:45.760 --> 13:47.760
你看这个数字的来源

13:47.760 --> 13:50.760
它是不是有可能来自于属性

13:50.760 --> 13:53.760
你看 你看

13:53.760 --> 13:55.760
它的数据来源本来有的时候

13:55.760 --> 13:57.760
你看它来自于状态的对吧

13:57.760 --> 13:58.760
它是来自于状态的

13:58.760 --> 13:59.760
状态可以控制它

13:59.760 --> 14:02.760
然后一块属性也可以控制它

14:02.760 --> 14:05.760
看没 属性的变化也可以控制它

14:05.760 --> 14:08.760
好像说这个东西保持了一致

14:08.760 --> 14:09.760
挺好的

14:09.760 --> 14:11.760
实际上这里非常容易造成bug

14:11.760 --> 14:13.760
非常非常容易造成bug

14:13.760 --> 14:16.760
那具体为什么会容易造成bug呢

14:16.760 --> 14:18.760
它需要一个复杂的系统里面

14:18.760 --> 14:19.760
我们才好演示

14:19.760 --> 14:22.760
那现在我找不到这样的复杂系统

14:22.760 --> 14:24.760
不能说我为了解释这个问题

14:24.760 --> 14:26.760
我给你写个复杂系统出来吧

14:26.760 --> 14:27.760
也不现实

14:27.760 --> 14:29.760
但是大家可以看到一个明显的现象

14:29.760 --> 14:31.760
就是说它的目的是为了保持

14:31.760 --> 14:32.760
这两个值得统一

14:32.760 --> 14:33.760
但是统一的吗

14:33.760 --> 14:36.760
兄弟 你看统一的吗

14:36.760 --> 14:37.760
是不是还是没有统一

14:37.760 --> 14:39.760
这两个值得它

14:39.760 --> 14:41.760
它总有可能会保持不一致的情况

14:41.760 --> 14:43.760
那么它只要有不一致的情况

14:43.760 --> 14:45.760
它就会容易造成问题

14:45.760 --> 14:47.760
就容易造成问题

14:47.760 --> 14:49.760
你想一下那个逻辑

14:49.760 --> 14:50.760
这个数字的逻辑

14:50.760 --> 14:52.760
它一方面的逻辑是

14:52.760 --> 14:54.760
它来自于状态

14:54.760 --> 14:56.760
它跟状态保持一致

14:56.760 --> 14:57.760
你看这个写在代码

14:57.760 --> 14:59.760
写代码是不是来自于状态的

14:59.760 --> 15:00.760
对吧

15:00.760 --> 15:02.760
跟状态要保持一致

15:02.760 --> 15:04.760
然后另外一方面

15:04.760 --> 15:06.760
它的属性

15:06.760 --> 15:08.760
它又要跟属性要保持一致

15:08.760 --> 15:11.760
你看这两个事情是不是矛盾的

15:11.760 --> 15:12.760
对吧

15:12.760 --> 15:14.760
它想把它数据变成统一

15:14.760 --> 15:16.760
反而容易造成数据不同意

15:16.760 --> 15:18.760
这就是一种反模式

15:18.760 --> 15:20.760
这非常非常容易产生问题

15:20.760 --> 15:22.760
而以前不少的开发者

15:22.760 --> 15:24.760
他都习惯于这样子写

15:24.760 --> 15:25.760
他觉得挺好的

15:25.760 --> 15:27.760
我们充分利用了生命周期

15:27.760 --> 15:29.760
勾字函数

15:29.760 --> 15:30.760
后来React

15:30.760 --> 15:32.760
官方他发现了这个问题

15:32.760 --> 15:33.760
他怎么有这么多人

15:33.760 --> 15:35.760
他愿意去这样子写代吗

15:35.760 --> 15:36.760
他认为什么呢

15:36.760 --> 15:38.760
官方认为是这么回事

15:40.760 --> 15:42.760
React

15:42.760 --> 15:44.760
就是官方

15:44.760 --> 15:46.760
认为

15:46.760 --> 15:48.760
某个数据

15:48.760 --> 15:50.760
来的来源

15:50.760 --> 15:52.760
必须是单一的

15:52.760 --> 15:54.760
他要么来自于属性

15:54.760 --> 15:55.760
只受属性影响

15:55.760 --> 15:57.760
要么来自于狀态

15:57.760 --> 15:58.760
只受狀态影响

15:58.760 --> 16:00.760
他不能继受属性影响

16:00.760 --> 16:01.760
又受狀态影响

16:01.760 --> 16:03.760
这样子非常容易导致问题

16:03.760 --> 16:05.760
而以前的存在这么一个生命周期

16:05.760 --> 16:06.760
勾字函数

16:06.760 --> 16:08.760
就给了开发者可称之机

16:08.760 --> 16:09.760
他就利用了

16:09.760 --> 16:10.760
他觉得自己还

16:10.760 --> 16:12.760
挺厉害的

16:12.760 --> 16:13.760
这世界充分的利用了

16:13.760 --> 16:14.760
生命周期勾字函数

16:14.760 --> 16:15.760
来实现了这么一个

16:15.760 --> 16:17.760
特殊的效果

16:17.760 --> 16:19.760
但是这样子的设计

16:19.760 --> 16:21.760
其实是一种反摩式

16:21.760 --> 16:22.760
不好的

16:22.760 --> 16:23.760
所以说他后边

16:23.760 --> 16:25.760
直接给你干掉了

16:25.760 --> 16:26.760
直接给你干掉了

16:26.760 --> 16:27.760
而且以前的

16:27.760 --> 16:28.760
还有很多开发者在这里面

16:28.760 --> 16:30.760
写了很多很多的黑科技

16:30.760 --> 16:31.760
在这里面

16:31.760 --> 16:32.760
在这里面还写了

16:32.760 --> 16:33.760
判断Z史

16:33.760 --> 16:34.760
当前的属性

16:34.760 --> 16:35.760
跟下一个属性

16:35.760 --> 16:36.760
是不是一样

16:36.760 --> 16:37.760
还有当前的状态

16:37.760 --> 16:38.760
怎么样怎么样

16:38.760 --> 16:40.760
做了很多这样的类似的事情

16:40.760 --> 16:41.760
越做越乱

16:41.760 --> 16:42.760
越来越

16:42.760 --> 16:44.760
勇于产生Bug

16:44.760 --> 16:45.760
所以说他后边

16:45.760 --> 16:46.760
直接把他干掉了

16:46.760 --> 16:47.760
而替换成了一个

16:47.760 --> 16:49.760
新版的生命周期函数

16:49.760 --> 16:50.760
这个生命周期函数

16:50.760 --> 16:52.760
并且给你强行

16:52.760 --> 16:54.760
设置为了Static

16:54.760 --> 16:56.760
静态的

16:56.760 --> 16:59.760
然后他犹豫他是静态的

16:59.760 --> 17:01.760
你能不能使用Z史

17:01.760 --> 17:02.760
能不能获取当前对象

17:02.760 --> 17:03.760
我们之前学过了

17:03.760 --> 17:04.760
静态方法里面

17:04.760 --> 17:06.760
是不能获取当前对象的

17:06.760 --> 17:07.760
所以说你想都不要想

17:07.760 --> 17:08.760
在这个勾字函数里面

17:08.760 --> 17:09.760
去获取什么

17:09.760 --> 17:10.760
当前的属性

17:10.760 --> 17:12.760
当前的状态

17:12.760 --> 17:13.760
还有ZState

17:13.760 --> 17:14.760
想都不要想

17:14.760 --> 17:16.760
根本不允许你这样做

17:16.760 --> 17:19.760
因此他给你出了这么一个东西

17:19.760 --> 17:21.760
那清出来的东西有什么用呢

17:21.760 --> 17:22.760
说实话

17:22.760 --> 17:25.760
很多时候用处都不大

17:25.760 --> 17:26.760
都没有什么用处

17:26.760 --> 17:28.760
他的主要目的呢

17:28.760 --> 17:30.760
是给了你一个替换的东西

17:30.760 --> 17:31.760
并且给你干掉了

17:31.760 --> 17:32.760
就着生命周期函数

17:32.760 --> 17:33.760
这是他的主要目的

17:33.760 --> 17:36.760
这个新的生命周期函数

17:36.760 --> 17:37.760
意义不大

17:37.760 --> 17:38.760
意义不大

17:38.760 --> 17:39.760
很多时候呢

17:39.760 --> 17:40.760
我们用他呢

17:40.760 --> 17:42.760
如果你用他的话

17:42.760 --> 17:45.760
很多时候都有替代的方案

17:45.760 --> 17:46.760
那有些人说

17:46.760 --> 17:48.760
那我们如果为了实现这样的效果

17:48.760 --> 17:49.760
该怎么来做呢

17:49.760 --> 17:50.760
该怎么来做

17:50.760 --> 17:51.760
如果你要比方说

17:51.760 --> 17:52.760
他的数据

17:52.760 --> 17:53.760
他要么来自于状态

17:53.760 --> 17:55.760
要么来自于属性

17:55.760 --> 17:56.760
那如果你觉得

17:56.760 --> 17:57.760
他要来自于属性

17:57.760 --> 17:59.760
OK干掉状态

17:59.760 --> 18:01.760
直接来自于属性

18:02.760 --> 18:03.760
直接来自于属性

18:03.760 --> 18:04.760
Probs

18:04.760 --> 18:06.760
然后点击的时候

18:06.760 --> 18:07.760
抛出事件

18:07.760 --> 18:08.760
ZS

18:08.760 --> 18:09.760
Probs

18:09.760 --> 18:10.760
Unclick

18:10.760 --> 18:11.760
这样子来做

18:11.760 --> 18:14.760
让数据的拥有者来改变数据

18:14.760 --> 18:15.760
这样子的组件

18:15.760 --> 18:17.760
是最不容易出问题的

18:17.760 --> 18:19.760
千万千万不要这样做

18:22.760 --> 18:24.760
千万不要这样做

18:24.760 --> 18:25.760
千万不要这样做

18:25.760 --> 18:27.760
好咱们来看一下

18:27.760 --> 18:29.760
这个新的生命周期函数

18:29.760 --> 18:31.760
他给你提供了什么东西

18:31.760 --> 18:33.760
New Life

18:33.760 --> 18:35.760
其实他本身没有什么用

18:35.760 --> 18:38.760
他的目的是干掉以前的函数

18:38.760 --> 18:39.760
然后给你为科堂

18:39.760 --> 18:41.760
说咱们有一个替代的方案

18:41.760 --> 18:42.760
但是你一用发现

18:42.760 --> 18:44.760
之前的事情完全干不了了

18:44.760 --> 18:46.760
因为以前我们用这个函数的

18:46.760 --> 18:47.760
主要目的就是这样的目的

18:47.760 --> 18:49.760
他的数据有可能被属性控制

18:49.760 --> 18:51.760
有可能被状态控制

18:51.760 --> 18:52.760
主要的目的就是这个

18:52.760 --> 18:54.760
现在来吧

18:54.760 --> 18:55.760
我给你干掉了

18:55.760 --> 18:56.760
但是没关系

18:56.760 --> 18:57.760
我给你提供了一个新的

18:57.760 --> 18:58.760
但是你一用发现

18:58.760 --> 19:00.760
麻烦的新的完全没法用

19:00.760 --> 19:01.760
因为它是个静态的

19:01.760 --> 19:03.760
你根本获取不到ZS

19:03.760 --> 19:04.760
根本没法set state

19:05.760 --> 19:07.760
而且新的函数

19:07.760 --> 19:09.760
还不仅仅是属性变化贵触发

19:09.760 --> 19:11.760
状态变化也会触发

19:11.760 --> 19:12.760
你根本就不知道是属性变化了

19:12.760 --> 19:13.760
还是状态变化了

19:13.760 --> 19:14.760
根本就不知道

19:14.760 --> 19:15.760
什么意思

19:15.760 --> 19:16.760
它是什么含义

19:16.760 --> 19:18.760
官方的态度再明显不过了

19:18.760 --> 19:21.760
我现在就明确告诉你

19:21.760 --> 19:22.760
官方的意思

19:22.760 --> 19:25.760
就说我现在就明确告诉你

19:25.760 --> 19:27.760
放弃掉以前的所有幻想

19:27.760 --> 19:28.760
不要再这样用了

19:28.760 --> 19:30.760
主见根本不是你这样玩的

19:30.760 --> 19:32.760
你要么就是一个

19:32.760 --> 19:34.760
获取从属性里面来的数据

19:34.760 --> 19:36.760
要么就是从状态里面来的数据

19:36.760 --> 19:38.760
千万不要混杂着来

19:38.760 --> 19:41.760
所以这个函数本身是没有什么用的

19:41.760 --> 19:42.760
包括官方文档里面

19:42.760 --> 19:44.760
也说了就是很多时候

19:44.760 --> 19:46.760
这个派生状态没有什么意义

19:46.760 --> 19:49.760
它的主要目的就是干掉这个东西

19:49.760 --> 19:50.760
咱们还是看一下吧

19:50.760 --> 19:51.760
既然它有了

19:51.760 --> 19:53.760
我们来看一下

19:53.760 --> 19:55.760
我们这里RCC

19:55.760 --> 19:58.760
然后这里边

19:58.760 --> 19:59.760
随便来一个吧

19:59.760 --> 20:00.760
我们就随便来一个吧

20:00.760 --> 20:02.760
看一下吧

20:02.760 --> 20:04.760
这里State有个状态

20:04.760 --> 20:06.760
状态N42

20:06.760 --> 20:08.760
随便来一个吧

20:08.760 --> 20:10.760
随便来一个

20:10.760 --> 20:12.760
N40

20:12.760 --> 20:15.760
然后这里边

20:15.760 --> 20:17.760
有一个HE

20:17.760 --> 20:18.760
它里边

20:18.760 --> 20:23.760
显示一个ZestState.n

20:23.760 --> 20:26.760
然后里边有一个按钮

20:26.760 --> 20:27.760
有个按钮

20:27.760 --> 20:30.760
这个按钮里面就是一个

20:30.760 --> 20:33.760
onclick

20:33.760 --> 20:35.760
然后这里边

20:35.760 --> 20:38.760
ZestState

20:38.760 --> 20:40.760
Zest

20:40.760 --> 20:42.760
N等于ZestState

20:42.760 --> 20:44.760
N加1

20:44.760 --> 20:45.760
N加1对吧

20:45.760 --> 20:48.760
然后这里面我们写

20:48.760 --> 20:50.760
加1

20:50.760 --> 20:52.760
然后这里面我们写一个

20:52.760 --> 20:54.760
静态的生命周期

20:54.760 --> 20:55.760
勾字函数

20:55.760 --> 20:56.760
叫什么名字呢

20:56.760 --> 20:58.760
叫做

20:58.760 --> 21:03.760
get

21:03.760 --> 21:05.760
derived

21:05.760 --> 21:07.760
State from props

21:07.760 --> 21:09.760
因为我很少用这个玩意

21:09.760 --> 21:10.760
很少用这个玩意

21:10.760 --> 21:11.760
好

21:11.760 --> 21:13.760
这里边我们输出一下

21:13.760 --> 21:17.760
输出就是

21:17.760 --> 21:18.760
这个函数

21:18.760 --> 21:19.760
看一下这个函数

21:19.760 --> 21:20.760
什么是运行

21:20.760 --> 21:21.760
然后返回一个now

21:21.760 --> 21:23.760
我们以后再说返回字

21:23.760 --> 21:24.760
以后再说返回字

21:24.760 --> 21:26.760
以后再说参数和返回字

21:26.760 --> 21:27.760
好

21:27.760 --> 21:28.760
看一下吧

21:28.760 --> 21:30.760
这里我们再复制一个

21:30.760 --> 21:32.760
这里我们使用新的生命周期

21:32.760 --> 21:34.760
勾字函数

21:34.760 --> 21:35.760
写钢

21:35.760 --> 21:40.330
new life circle

21:40.330 --> 21:43.330
然后这边我们使用

21:43.330 --> 21:45.330
new life circle

21:45.330 --> 21:49.330
然后N还是要传进去吧

21:49.330 --> 21:51.330
N还是要传进去

21:51.330 --> 21:53.330
N还是要传进去

21:53.330 --> 21:56.330
然后这边就是

21:56.330 --> 21:57.330
还是这样子

21:57.330 --> 21:58.330
这里还是不变

21:58.330 --> 21:59.330
这里还是不变

21:59.330 --> 22:00.330
保存一下

22:00.330 --> 22:02.330
咱们看一下

22:02.330 --> 22:03.330
好

22:03.330 --> 22:05.330
这里我们来看一下

22:05.330 --> 22:06.330
一开始是不是运行的

22:06.330 --> 22:07.330
为什么一开始运行

22:07.330 --> 22:09.330
因为在新版的生命周期里边

22:09.330 --> 22:11.330
反而是在Render之前

22:11.330 --> 22:13.330
它一定会运行是这个

22:13.330 --> 22:14.330
一定会运行是这个

22:14.330 --> 22:15.330
所以说一开始

22:15.330 --> 22:16.330
我们可以看到

22:16.330 --> 22:17.330
一开始能调用这个函数

22:17.330 --> 22:18.330
然后我们这里

22:18.330 --> 22:19.330
状态发生改变

22:19.330 --> 22:21.330
你看是不是又调用这个函数

22:21.330 --> 22:22.330
状态改变

22:22.330 --> 22:23.330
它也要调用这个函数

22:23.330 --> 22:25.330
然后这里

22:25.330 --> 22:26.330
副主建加1

22:26.330 --> 22:27.330
副主建加1过后

22:27.330 --> 22:29.330
属性改变

22:29.330 --> 22:31.330
属性改变你看是不是也调用了

22:31.330 --> 22:33.330
属性改变所以也调用了

22:33.330 --> 22:34.330
尽管这个属性我用都没用

22:34.330 --> 22:36.330
但是还是会调用

22:36.330 --> 22:38.330
总之在Render之前

22:38.330 --> 22:39.330
重新选展之前

22:39.330 --> 22:41.330
它都会调用这个函数

22:41.330 --> 22:42.330
然后这个函数里边

22:42.330 --> 22:43.330
你看一下

22:43.330 --> 22:45.330
你还能不能像以前那么干

22:45.330 --> 22:46.330
还能不能像以前那么干

22:46.330 --> 22:47.330
以前怎么干的

22:47.330 --> 22:48.330
是不是N来自于

22:48.330 --> 22:49.330
它的初始值

22:49.330 --> 22:51.330
Prob's点N

22:51.330 --> 22:53.330
来自于它的初始值

22:53.330 --> 22:54.330
后来现在

22:54.330 --> 22:55.330
由于给你去掉了

22:55.330 --> 22:57.330
这个will receive的

22:57.330 --> 22:58.330
Prob's

22:58.330 --> 22:59.330
由于给你去掉了

22:59.330 --> 23:01.330
这个函数

23:01.330 --> 23:02.330
之前指错了

23:02.330 --> 23:03.330
这个函数

23:03.330 --> 23:05.330
由于给你去掉了这个函数

23:05.330 --> 23:06.330
那么现在

23:06.330 --> 23:07.330
你还能这样子玩吗

23:07.330 --> 23:08.330
你看一下怎么来玩

23:08.330 --> 23:09.330
怎么来玩这个事情

23:09.330 --> 23:10.330
这里边

23:10.330 --> 23:11.330
它倒是给你提供了

23:11.330 --> 23:12.330
两个参数

23:12.330 --> 23:14.330
一个参数的是next

23:15.330 --> 23:16.330
next

23:16.330 --> 23:17.330
Prob's

23:17.330 --> 23:19.330
一个参数的是next

23:19.330 --> 23:20.330
是之前的状态

23:20.330 --> 23:21.330
一个是

23:21.330 --> 23:22.330
下一个属性

23:22.330 --> 23:23.330
就是新的属性

23:23.330 --> 23:24.330
这是新的属性

23:24.330 --> 23:25.330
这是之前的状态

23:25.330 --> 23:26.330
我们把它打印出来

23:26.330 --> 23:28.330
你看一下

23:28.330 --> 23:30.330
那么现在属性的是

23:30.330 --> 23:32.330
属性的是N

23:32.330 --> 23:33.330
等于1

23:33.330 --> 23:34.330
状态的也是N等于1

23:34.330 --> 23:35.330
对吧

23:35.330 --> 23:36.330
这个没问题

23:36.330 --> 23:37.330
它是初始值

23:37.330 --> 23:38.330
它是允许的付出值的

23:38.330 --> 23:39.330
根据属性来付出值

23:39.330 --> 23:40.330
这个是没问题的

23:40.330 --> 23:41.330
好

23:41.330 --> 23:42.330
然后我们现在改变状态

23:42.330 --> 23:43.330
你看一下

23:43.330 --> 23:44.330
改变状态过后了

23:44.330 --> 23:46.330
这个状态是不是变了

23:46.330 --> 23:47.330
变了

23:47.330 --> 23:48.330
变成了2了

23:48.330 --> 23:49.330
你看改变状态过后

23:49.330 --> 23:50.330
变状态变成2了

23:50.330 --> 23:51.330
变成3

23:51.330 --> 23:52.330
变成4

23:52.330 --> 23:53.330
对吧

23:53.330 --> 23:54.330
状态跟着改变

23:54.330 --> 23:55.330
然后呢

23:55.330 --> 23:56.330
我们再点

23:56.330 --> 23:57.330
再点这个

23:57.330 --> 23:59.330
属性是不是也跟着变了

23:59.330 --> 24:00.330
对吧

24:00.330 --> 24:01.330
属性也跟着变了

24:01.330 --> 24:02.330
你看

24:02.330 --> 24:04.330
新的属性值

24:04.330 --> 24:05.330
新的属性值

24:05.330 --> 24:06.330
好

24:06.330 --> 24:07.330
那么我们可以获得新的属性

24:07.330 --> 24:09.330
也可以获得新的状态

24:09.330 --> 24:10.330
我们通常的这里

24:10.330 --> 24:12.330
也不用什么next了

24:12.330 --> 24:13.330
就用probs

24:13.330 --> 24:14.330
State

24:14.330 --> 24:15.330
State

24:15.330 --> 24:16.330
就用这两个

24:16.330 --> 24:17.330
这样子不用

24:17.330 --> 24:19.330
不容易造成混淆

24:19.330 --> 24:20.330
好

24:20.330 --> 24:21.330
改变了

24:21.330 --> 24:22.330
改变了

24:22.330 --> 24:23.330
好

24:23.330 --> 24:24.330
那么接下来了

24:24.330 --> 24:25.330
很多东西开始玩了

24:25.330 --> 24:27.330
那我又像以前那样做

24:27.330 --> 24:29.330
属性改变的时候

24:29.330 --> 24:30.330
我把状态的

24:30.330 --> 24:31.330
跟属性值设为一样的

24:31.330 --> 24:32.330
它开始来了

24:32.330 --> 24:33.330
咦

24:33.330 --> 24:34.330
然后一发现

24:34.330 --> 24:35.330
这个Z使用不了了

24:35.330 --> 24:37.330
这个Z使里边啥东西

24:37.330 --> 24:38.330
啥东西

24:38.330 --> 24:40.330
这个Z使指向谁

24:40.330 --> 24:42.330
指向这个构造函数了

24:42.330 --> 24:43.330
它是精彩的

24:43.330 --> 24:45.330
你还能使用set state吗

24:45.330 --> 24:46.330
不能用了

24:46.330 --> 24:47.330
用都不能用了

24:47.330 --> 24:49.330
压根就不能用set state

24:49.330 --> 24:50.330
n等于啥

24:50.330 --> 24:52.330
等于probs里面的n

24:52.330 --> 24:53.330
看一下能不能用

24:53.330 --> 24:55.330
点击

24:55.330 --> 24:56.330
你看一下

24:56.330 --> 24:58.330
根本就读不出来了

24:58.330 --> 25:00.330
set state根本就读不出来

25:00.330 --> 25:01.330
因为这个东西

25:01.330 --> 25:03.330
它指向的是个函数本身

25:03.330 --> 25:04.330
而不是对相了

25:04.330 --> 25:05.330
所以Z根本用不了了

25:05.330 --> 25:06.330
好

25:06.330 --> 25:07.330
开始在扣脑袋了

25:07.330 --> 25:08.330
怎么办呢

25:08.330 --> 25:09.330
我一定要让别人

25:09.330 --> 25:10.330
像以前那么用

25:10.330 --> 25:11.330
那怎么办呢

25:11.330 --> 25:12.330
好

25:12.330 --> 25:13.330
接下来了

25:13.330 --> 25:14.330
他再想办法了

25:14.330 --> 25:15.330
他发现了

25:15.330 --> 25:16.330
他阅读官方文档

25:16.330 --> 25:17.330
发现了这个函数

25:17.330 --> 25:18.330
他有个反回指

25:18.330 --> 25:20.330
如果反回 now 的话

25:20.330 --> 25:21.330
表示什么意思

25:21.330 --> 25:24.330
就是不改变

25:24.330 --> 25:26.330
当前状态

25:26.330 --> 25:28.330
不改变当前状态

25:28.330 --> 25:30.330
状态不会发生任何变化

25:30.330 --> 25:31.330
你之前变成什么就是什么

25:31.330 --> 25:33.330
反回 now 是这个

25:33.330 --> 25:35.330
那如果你反回一个对象的

25:35.330 --> 25:36.330
反回了对象的话

25:36.330 --> 25:37.330
它会用新的对象

25:37.330 --> 25:39.330
来替换掉之前的状态

25:39.330 --> 25:40.330
反回对象的话

25:40.330 --> 25:42.330
用新的对象

25:42.330 --> 25:44.330
就跟那个 set state 差不多

25:44.330 --> 25:47.330
新的对象替换掉

25:47.330 --> 25:50.330
替换掉之前的状态

25:50.330 --> 25:51.330
替换掉之前的状态

25:51.330 --> 25:53.330
那不是还是可以玩吗

25:53.330 --> 25:54.330
来吧

25:54.330 --> 25:55.330
反回个 n 为啥

25:55.330 --> 25:56.330
probs.n

25:56.330 --> 25:57.330
对吧

25:57.330 --> 25:58.330
这样不就完了吗

25:58.330 --> 25:59.330
我们继续玩

25:59.330 --> 26:00.330
继续玩

26:00.330 --> 26:01.330
你不要我这样玩

26:01.330 --> 26:02.330
偏要这样玩

26:02.330 --> 26:05.330
咱们的保存看一下吧

26:05.330 --> 26:06.330
一开始看

26:06.330 --> 26:07.330
一没问题吧

26:07.330 --> 26:09.330
我们把这个打开

26:09.330 --> 26:10.330
这个打开

26:10.330 --> 26:11.330
看着

26:12.330 --> 26:14.330
probs 状态是一

26:14.330 --> 26:16.330
现在我们改变状态

26:16.330 --> 26:18.330
没用了居然

26:18.330 --> 26:20.330
改变状态都没用了

26:20.330 --> 26:21.330
为什么没用了

26:21.330 --> 26:23.330
因为改变状态的时候

26:23.330 --> 26:24.330
是不是也会运行这个

26:24.330 --> 26:25.330
对吧

26:25.330 --> 26:26.330
改变状态的时候

26:26.330 --> 26:27.330
它也会运行这个

26:27.330 --> 26:29.330
改变状态的时候

26:29.330 --> 26:31.330
你状态的本来是解

26:31.330 --> 26:33.330
状态的本来是

26:33.330 --> 26:34.330
变成二的

26:34.330 --> 26:35.330
对吧

26:35.330 --> 26:36.330
变成二的

26:36.330 --> 26:37.330
但是你又把它

26:37.330 --> 26:38.330
状态给我覆盖掉了

26:38.330 --> 26:40.330
又把它变成了什么

26:40.330 --> 26:41.330
又把它变成了

26:41.330 --> 26:42.330
1 对不对

26:42.330 --> 26:43.330
属性里面不是1吗

26:43.330 --> 26:44.330
你看

26:44.330 --> 26:45.330
本来状态是不是

26:45.330 --> 26:46.330
应该是二的

26:46.330 --> 26:47.330
点了过后

26:47.330 --> 26:48.330
但是属性是一

26:48.330 --> 26:51.330
始终把属性的值改成状态了

26:51.330 --> 26:52.330
你返回的是属性的值

26:52.330 --> 26:53.330
你看

26:53.330 --> 26:54.330
你有把属性的值

26:54.330 --> 26:55.330
变成状态的值

26:55.330 --> 26:56.330
n 又返回回去了

26:56.330 --> 26:57.330
所以这样子

26:57.330 --> 26:59.330
改变状态改变不了了

26:59.330 --> 27:00.330
而改变属性的

27:00.330 --> 27:02.330
改变属性倒是可以改变

27:02.330 --> 27:04.330
改变属性倒是可以改变

27:04.330 --> 27:05.330
这说明了咋

27:05.330 --> 27:07.330
它强制要求里数据统一

27:07.330 --> 27:09.330
既然你的东西

27:09.330 --> 27:11.330
它收空于属性

27:11.330 --> 27:12.330
那么它就一直要

27:12.330 --> 27:13.330
收空于属性

27:13.330 --> 27:15.330
它就不能是技术收空于狀态

27:15.330 --> 27:16.330
又收空于属性

27:16.330 --> 27:17.330
它不准你这样干

27:17.330 --> 27:18.330
那你这样子

27:18.330 --> 27:19.330
你能玩吗

27:19.330 --> 27:20.330
我玩不了了

27:20.330 --> 27:21.330
我说我玩不了了

27:21.330 --> 27:23.330
当然有些很聪明的人

27:23.330 --> 27:26.330
他脚劲脑子又发明了一些东西

27:26.330 --> 27:27.330
我就不说了

27:27.330 --> 27:29.330
我不把这些错误的势力告诉大家了

27:29.330 --> 27:31.330
有些就是

27:31.330 --> 27:32.330
网上有些帖子还说

27:32.330 --> 27:34.330
你干嘛整出这么一个东西

27:34.330 --> 27:36.330
这东西好难好难用

27:36.330 --> 27:37.330
它就让你用了

27:37.330 --> 27:39.330
根本就没有让你用

27:39.330 --> 27:40.330
说的是什么

27:40.330 --> 27:42.330
说的是以前的错误的用法太多了

27:42.330 --> 27:44.330
不要再用以前错误的方式了

27:44.330 --> 27:46.330
它给你搞出来这么一个玩意

27:46.330 --> 27:47.330
根本就是很明确了

27:47.330 --> 27:48.330
不让你用

27:48.330 --> 27:50.330
不要用

27:50.330 --> 27:52.330
什么情况下会用到这个

27:52.330 --> 27:53.330
很少很少

27:53.330 --> 27:54.330
将来咱们讲了

27:54.330 --> 27:56.330
收空主见之后

27:56.330 --> 27:57.330
可能

27:57.330 --> 27:59.330
那么有一点点地方

27:59.330 --> 28:00.330
可能会用到这个东西

28:00.330 --> 28:02.330
平时根本就见不到这个东西

28:02.330 --> 28:03.330
意思是什么

28:03.330 --> 28:04.330
就是不让你用

28:04.330 --> 28:05.330
就是不让你用

28:05.330 --> 28:06.330
不给你吹油

28:06.330 --> 28:07.330
是官方说的

28:07.330 --> 28:08.330
官方说的

28:08.330 --> 28:10.330
说不给你吹油

28:11.330 --> 28:12.330
大家以后

28:12.330 --> 28:14.330
这个神明周期函数肯定不能再用了

28:14.330 --> 28:16.330
然后这种函数

28:16.330 --> 28:17.330
也没什么用处

28:17.330 --> 28:18.330
也没什么用处了

28:18.330 --> 28:19.330
所以说

28:19.330 --> 28:21.330
以后大家写主见的时候

28:21.330 --> 28:22.330
注意一下

28:22.330 --> 28:24.330
如果你发现一个主见

28:24.330 --> 28:25.330
它既要来自于属性

28:25.330 --> 28:26.330
又来了来自于状态

28:26.330 --> 28:28.330
它肯定是以设计的一个问题

28:28.330 --> 28:30.330
肯定不应该这样子设计

28:30.330 --> 28:31.330
这样子设计的

28:31.330 --> 28:33.330
非常容易导致八个

28:33.330 --> 28:35.330
难以调试的八个

28:35.330 --> 28:36.330
这是第一个

28:36.330 --> 28:37.330
这个神明周期函数

28:37.330 --> 28:38.330
给大家说清楚

28:39.330 --> 28:40.330
下一个

28:41.330 --> 28:42.330
实际上你看很多教程

28:42.330 --> 28:43.330
谁给你讲那么细呢

28:43.330 --> 28:44.330
还省得那么大的胆子

28:44.330 --> 28:45.330
给你讲这个东西呢

28:45.330 --> 28:47.330
为什么有那么大的胆子

28:47.330 --> 28:48.330
讲出这句话

28:48.330 --> 28:49.330
因为官方说的

28:49.330 --> 28:51.330
官方里边给你

28:51.330 --> 28:53.330
转载了一个一篇博客

28:53.330 --> 28:55.330
那篇博客就说得很清楚

28:55.330 --> 28:57.330
在绝大部分情况下

28:57.330 --> 28:58.330
我们都用不到他

28:58.330 --> 28:59.330
都用不了他

28:59.330 --> 29:00.330
他没有什么用

29:00.330 --> 29:01.330
可能少量的情况下

29:01.330 --> 29:02.330
能用到他

29:02.330 --> 29:03.330
但是能用到他的场景下面

29:03.330 --> 29:04.330
我们总会有替代方案

29:04.330 --> 29:06.330
那搞出这个玩意

29:06.330 --> 29:08.330
目的就是不要你用这个

29:08.330 --> 29:10.330
但是你直接把它去掉了

29:10.330 --> 29:12.330
有些人反弹很大

29:12.330 --> 29:13.330
反弹很大

29:13.330 --> 29:14.330
受不了

29:14.330 --> 29:15.330
那还给你加一个

29:15.330 --> 29:16.330
给你加一个

29:16.330 --> 29:17.330
你加一个过后

29:17.330 --> 29:18.330
你用着就会发现了

29:18.330 --> 29:20.330
rex的态度很明确

29:20.330 --> 29:22.330
不让你去干这样的事情

29:22.330 --> 29:24.330
为什么把它搞成静态的

29:24.330 --> 29:25.330
为什么

29:25.330 --> 29:26.330
他能不能不搞成静态的

29:26.330 --> 29:27.330
可以

29:27.330 --> 29:29.330
他就是不让你去搞这些操作

29:29.330 --> 29:32.330
这样子会非常容易造成混乱

29:33.330 --> 29:34.330
下一个

29:34.330 --> 29:35.330
下一个就是这个函数

29:35.330 --> 29:36.330
这个函数

29:36.330 --> 29:38.330
其实我们也没这么用

29:38.330 --> 29:39.330
也没这么用

29:39.330 --> 29:40.330
这个函数是什么意思呢

29:40.330 --> 29:43.330
它的运行时间点

29:43.330 --> 29:45.330
主要说一下这个函数

29:45.330 --> 29:46.330
第一个函数

29:46.330 --> 29:49.330
我们刚才还是说一下

29:49.330 --> 29:50.330
这个函数说一下

29:50.330 --> 29:52.330
第一个还有两个参数

29:52.330 --> 29:53.330
参数

29:53.330 --> 29:55.330
通过参数

29:55.330 --> 29:57.330
可以获取

29:57.330 --> 30:00.330
获取就是新的属性

30:00.330 --> 30:03.330
新的属性和状态

30:03.330 --> 30:04.330
新的属性和状态

30:05.330 --> 30:06.330
为什么之前呢

30:06.330 --> 30:07.330
他给你打的

30:07.330 --> 30:09.330
辩量的名称叫做

30:09.330 --> 30:10.330
next props

30:10.330 --> 30:11.330
和prev status

30:11.330 --> 30:13.330
为什么一个这样打名称的

30:13.330 --> 30:14.330
说实话

30:14.330 --> 30:15.330
这是以前

30:15.330 --> 30:17.330
这是以前

30:17.330 --> 30:19.330
好像在16.4的版本里边

30:19.330 --> 30:22.330
他那个生命中心是这样子的

30:22.330 --> 30:23.330
当时是这样子的

30:23.330 --> 30:25.330
他仍然是在属性变化和运行

30:25.330 --> 30:27.330
很多人说

30:27.330 --> 30:29.330
你不是就是搞了一个

30:29.330 --> 30:31.330
换了个名字而已吗

30:31.330 --> 30:32.330
我之前该玩的还是玩

30:32.330 --> 30:34.330
后来官方突然出来说

30:34.330 --> 30:36.330
这是我以前写错了

30:36.330 --> 30:37.330
他是以前写错了

30:37.330 --> 30:38.330
一开始设计的时候

30:38.330 --> 30:39.330
根本就不是这样子设计的

30:39.330 --> 30:41.330
只是他写的时候

30:41.330 --> 30:42.330
不小心写错了

30:42.330 --> 30:44.330
然后把他变成了这个样子

30:44.330 --> 30:46.330
把他变成了这个样子

30:46.330 --> 30:48.330
所以说在之前的版本里面

30:48.330 --> 30:49.330
这样子写的

30:49.330 --> 30:50.330
他把这个参数的名字

30:50.330 --> 30:52.330
叫做props和stat

30:52.330 --> 30:54.330
实际上现在根本就不是这个意思了

30:54.330 --> 30:55.330
根本就不是这个意思了

30:55.330 --> 30:57.330
就是新的属性和状态

30:59.330 --> 31:00.330
这里就是

31:00.330 --> 31:02.330
后期新的属性和状态

31:02.330 --> 31:04.330
另外一个就是该函数

31:04.330 --> 31:06.330
是静态的

31:06.330 --> 31:08.330
另外该函数的反回值

31:08.330 --> 31:10.330
反回值

31:10.330 --> 31:12.330
会覆盖掉

31:12.330 --> 31:14.330
组建状态

31:14.330 --> 31:16.330
会覆盖掉组建状态

31:16.330 --> 31:18.330
就这个函数

31:18.330 --> 31:20.330
该函数

31:20.330 --> 31:23.900
几乎是没有什么用

31:23.900 --> 31:24.900
下个函数

31:24.900 --> 31:26.900
下个函数是这个函数

31:26.900 --> 31:27.900
这个函数其实也没啥用

31:27.900 --> 31:29.900
至少目前我们没啥用

31:29.900 --> 31:31.900
后边还是有一点点用的

31:31.900 --> 31:32.900
还是有一些用的

31:32.900 --> 31:34.900
这个函数它的运行时间点

31:34.900 --> 31:35.900
所以它的运行时间点

31:35.900 --> 31:37.900
运行时间点是在什么呢

31:37.900 --> 31:39.900
就是真实的动物

31:39.900 --> 31:41.900
虚拟

31:41.900 --> 31:43.900
动物数

31:43.900 --> 31:45.900
构建完成

31:45.900 --> 31:46.900
构建完成

31:46.900 --> 31:47.900
真实

31:47.900 --> 31:48.900
但

31:48.900 --> 31:50.900
还未

31:50.900 --> 31:52.900
还未加入到

31:52.900 --> 31:55.900
真实的动物中

31:55.900 --> 31:57.900
还没有加入到真实的动物中

31:57.900 --> 31:58.900
应该这样说吧

31:58.900 --> 31:59.900
应该这样说

31:59.900 --> 32:01.900
真实的动物

32:01.900 --> 32:02.900
真实的动物

32:02.900 --> 32:03.900
构建完成

32:03.900 --> 32:05.900
但是还没有加入到

32:05.900 --> 32:07.900
还没有加入到夜面中

32:07.900 --> 32:09.900
夜面中

32:09.900 --> 32:11.900
还没有实际渲染到夜面中

32:11.900 --> 32:13.900
但还未

32:13.900 --> 32:15.900
实际

32:15.900 --> 32:17.900
实际渲染到夜面中

32:17.900 --> 32:19.900
就是真实的动物已经完了

32:19.900 --> 32:21.900
已经构建完了

32:21.900 --> 32:23.900
但是还没有渲染到夜面上面

32:23.900 --> 32:25.900
就是夜面上面还没有发生改变

32:25.900 --> 32:27.900
就差那么一点点了

32:27.900 --> 32:28.900
马上要发生改变了

32:28.900 --> 32:29.900
那么这个时候

32:29.900 --> 32:31.900
它给你提供了这么一个函数

32:31.900 --> 32:32.900
函数

32:32.900 --> 32:33.900
就是一个快兆

32:33.900 --> 32:34.900
就是马上我现在

32:34.900 --> 32:35.900
再加入

32:35.900 --> 32:36.900
就是在上台之前

32:36.900 --> 32:37.900
我们先照照相

32:37.900 --> 32:39.900
照照相就是快兆的意思

32:39.900 --> 32:40.900
那么这个函数里面

32:40.900 --> 32:41.900
通常用于做什么呢

32:41.900 --> 32:43.900
为什么现在做不了呢

32:43.900 --> 32:44.900
因为现在我们还

32:44.900 --> 32:45.900
没有学习

32:45.900 --> 32:47.900
如何在rex里面

32:47.900 --> 32:49.900
进行一些动物的操作

32:49.900 --> 32:50.900
这个要用到一个

32:50.900 --> 32:51.900
知识叫做ref

32:51.900 --> 32:53.900
其实你vue里面

32:53.900 --> 32:56.900
rex里面也有

32:57.900 --> 32:58.900
这个东西

32:58.900 --> 32:59.900
我们说的目前掩饰不了

32:59.900 --> 33:02.900
在函数中

33:02.900 --> 33:04.900
通常用于

33:04.900 --> 33:07.900
实现一些

33:07.900 --> 33:09.900
附加的动物操作

33:09.900 --> 33:11.900
就是我要直接操作动物

33:11.900 --> 33:13.900
绕过rex

33:13.900 --> 33:15.900
直接操作的一些动物元素

33:15.900 --> 33:17.900
通常用于实现一些

33:17.900 --> 33:18.900
附加的动物操作

33:18.900 --> 33:20.900
比如说什么设置滚动条位置

33:20.900 --> 33:22.900
添加一些动化效果之类的东西

33:23.900 --> 33:24.900
当然

33:24.900 --> 33:25.900
官方建议你

33:25.900 --> 33:27.900
就尽量的

33:27.900 --> 33:28.900
所有的元素

33:28.900 --> 33:30.900
都尽量让rex来控制

33:30.900 --> 33:32.900
如果你实在是

33:32.900 --> 33:34.900
手动的去控制一些动物

33:34.900 --> 33:36.900
那么你可以使用这个函数

33:36.900 --> 33:38.900
在这个函数里面进行书写

33:40.900 --> 33:41.900
这么个意思

33:41.900 --> 33:42.900
然后这个函数

33:42.900 --> 33:43.900
还有一个作用就是

33:43.900 --> 33:46.900
该函数的反回指

33:46.900 --> 33:48.900
会作为

33:48.900 --> 33:50.900
会作为这个函数

33:50.900 --> 33:53.900
这个生命周期函数的

33:53.900 --> 33:55.900
第三个函数

33:55.900 --> 33:57.900
之前咱们说过的这个函数

33:57.900 --> 33:58.900
那么

33:58.900 --> 34:00.900
如果这个函数有反回指的话

34:00.900 --> 34:01.900
它的反回指会作为

34:01.900 --> 34:03.900
这个函数的第三个函数

34:03.900 --> 34:04.900
目前看似

34:04.900 --> 34:05.900
这个东西好像没什么意义

34:05.900 --> 34:06.900
以后我们学了

34:06.900 --> 34:09.900
如何在rex里面去操作动物之后

34:09.900 --> 34:11.900
我们可以在这个函数里面

34:11.900 --> 34:12.900
去举个例子

34:12.900 --> 34:15.900
这两个都不是很常见

34:15.900 --> 34:16.900
所以说

34:16.900 --> 34:17.900
在新版的生命周期里面

34:17.900 --> 34:19.900
基本上是给你简化掉了

34:19.900 --> 34:20.900
我们之前说

34:20.900 --> 34:22.900
那个component d的update

34:22.900 --> 34:23.900
这个函数

34:23.900 --> 34:24.900
它其实就是

34:24.900 --> 34:25.900
这个函数运行的时候

34:25.900 --> 34:27.900
页面上已经展现出来了

34:27.900 --> 34:28.900
就已经展现出来了

34:28.900 --> 34:29.900
都已经形成真实的动物了

34:29.900 --> 34:30.900
已经渲染到页面上了

34:30.900 --> 34:31.900
所以说

34:31.900 --> 34:33.900
如果你期望在渲染之前

34:33.900 --> 34:34.900
等一下别渲染

34:34.900 --> 34:35.900
我这里还有一些事情

34:35.900 --> 34:36.900
我给你加上去

34:36.900 --> 34:37.900
那你加吧

34:37.900 --> 34:38.900
加上去

34:38.900 --> 34:39.900
因为我们知道渲染页面

34:39.900 --> 34:41.900
比方说我们之前操作动物的时候

34:41.900 --> 34:42.900
渲染页面

34:42.900 --> 34:44.900
动物元素比方说同一个属性

34:44.900 --> 34:45.900
动物元素的同一个属性

34:45.900 --> 34:47.900
比方说style color

34:47.900 --> 34:48.900
一开始把它设为red

34:48.900 --> 34:49.900
然后

34:49.900 --> 34:51.900
动物的style color

34:51.900 --> 34:52.900
再把它设为green

34:52.900 --> 34:54.900
最终肯定是绿色

34:54.900 --> 34:55.900
它会渲染几次

34:55.900 --> 34:56.900
渲染一次

34:56.900 --> 34:57.900
它会合并

34:57.900 --> 34:58.900
它会合并

34:58.900 --> 34:59.900
合并之后

34:59.900 --> 35:00.900
最后渲染的时候

35:00.900 --> 35:01.900
把它变成绿色

35:01.900 --> 35:02.900
所以说

35:02.900 --> 35:03.900
它为了提高效率

35:03.900 --> 35:04.900
它出来这么一个函数

35:04.900 --> 35:05.900
就说

35:05.900 --> 35:06.900
可能之前渲染的时候

35:06.900 --> 35:07.900
做了一些动物操作了

35:07.900 --> 35:08.900
那么可能

35:08.900 --> 35:10.900
你在真实的渲染之前

35:10.900 --> 35:12.900
可能还需要做一些事情

35:12.900 --> 35:13.900
要改一些值

35:13.900 --> 35:14.900
那么你去改

35:14.900 --> 35:15.900
我在这里

35:15.900 --> 35:16.900
在这里进行处理

35:16.900 --> 35:18.900
这样子就不会导致

35:18.900 --> 35:19.900
以前没办法

35:19.900 --> 35:20.900
以前只能在这里处理

35:20.900 --> 35:21.900
这里处理的话

35:21.900 --> 35:22.900
会遇到一个问题

35:22.900 --> 35:23.900
就是说

35:23.900 --> 35:25.900
已经渲染完了过后

35:25.900 --> 35:26.900
你又去改

35:26.900 --> 35:27.900
改了过又要渲染

35:27.900 --> 35:28.900
那么又会导致渲染两次

35:28.900 --> 35:30.900
就可能会导致一些页面散数

35:30.900 --> 35:31.900
那么在这里

35:31.900 --> 35:32.900
那就不会导致这个问题

35:32.900 --> 35:34.900
说是其中一个重要

35:34.900 --> 35:36.900
咱们来看一下吧

35:36.900 --> 35:37.900
现在我们只能去看一下

35:37.900 --> 35:40.900
看一下这个函数的运行时间

35:40.900 --> 35:41.900
它不是一个静态的

35:41.900 --> 35:42.900
叫做

35:42.900 --> 35:43.900
还是用简写吧

35:43.900 --> 35:44.900
get

35:45.900 --> 35:46.900
就这个东西

35:49.900 --> 35:50.900
这个函数

35:50.900 --> 35:52.900
它能得到之前的属性

35:52.900 --> 35:53.900
之前的状态

35:53.900 --> 35:54.900
对吧

35:54.900 --> 35:55.900
因为马上要渲染了

35:55.900 --> 35:56.900
马上要渲染了

35:56.900 --> 35:57.900
这个时候

35:57.900 --> 35:58.900
因为Render已经运行结束了

35:58.900 --> 35:59.900
我们之前说过

35:59.900 --> 36:01.900
Render运行结束过后了

36:01.900 --> 36:02.900
那么它的就是新的属性

36:02.900 --> 36:04.900
新的状态就已经生效了

36:04.900 --> 36:05.900
那么如果你要获取

36:05.900 --> 36:06.900
之前的属性

36:06.900 --> 36:07.900
之前的状态

36:07.900 --> 36:08.900
你可以通过这两个参数来获取

36:08.900 --> 36:09.900
你要干什么事情

36:09.900 --> 36:10.900
你自己去干

36:10.900 --> 36:11.900
我不管你

36:11.900 --> 36:12.900
自己去干

36:12.900 --> 36:13.900
那我主要说一下

36:13.900 --> 36:15.900
这个函数的输出

36:15.900 --> 36:16.900
输出这个东西

36:16.900 --> 36:17.900
你会发现

36:17.900 --> 36:20.900
只要在更新阶段

36:20.900 --> 36:22.900
它主要发生在更新阶段

36:22.900 --> 36:23.900
也就是它这个

36:23.900 --> 36:25.900
什么瓜仔阶段是不会运行的

36:25.900 --> 36:27.900
瓜仔阶段它不会运行这个东西的

36:27.900 --> 36:28.900
它发生在更新阶段

36:28.900 --> 36:29.900
你看一下

36:38.400 --> 36:40.400
should be used with

36:40.400 --> 36:41.400
它说这个函数

36:41.400 --> 36:43.400
通常要跟那个联合使用

36:43.400 --> 36:44.400
要跟这个联合使用

36:44.400 --> 36:46.400
我们后面会举例子

36:46.400 --> 36:48.400
就是那个

36:48.400 --> 36:51.400
component deed update

36:51.400 --> 36:53.400
通常跟它来联合使用

36:53.400 --> 36:55.400
它有第三个材料

36:55.400 --> 36:56.400
snap

36:58.400 --> 36:59.400
这里输出一下

36:59.400 --> 37:01.400
刚才有一个警告

37:01.400 --> 37:04.400
通常会跟它来进行联合使用

37:04.400 --> 37:06.400
保存

37:06.400 --> 37:07.400
我们后面在讲这个东西

37:07.400 --> 37:09.400
我们现在只是看它的运行时间

37:09.400 --> 37:10.400
一开始有没有运行

37:10.400 --> 37:11.400
没有运行

37:11.400 --> 37:13.400
因为它瓜仔阶段是不会运行的

37:13.400 --> 37:14.400
它什么时候运行的

37:14.400 --> 37:17.400
它是要在更新阶段才会运行

37:17.400 --> 37:18.400
看一下吧

37:18.400 --> 37:19.400
我们点击加一

37:19.400 --> 37:20.400
你看

37:20.400 --> 37:21.400
它是不是运行的

37:21.400 --> 37:23.400
这里又报警告

37:25.400 --> 37:26.400
它这里说又是个警告

37:26.400 --> 37:27.400
它说什么呢

37:27.400 --> 37:29.400
它说你这个函数

37:29.400 --> 37:30.400
你这个函数

37:30.400 --> 37:32.400
应该返回一个值

37:32.400 --> 37:33.400
应该返回一个值

37:33.400 --> 37:34.400
但是你现在返回的是Nd犯

37:34.400 --> 37:35.400
那行吧

37:35.400 --> 37:36.400
我返回一个值吧

37:36.400 --> 37:37.400
return随便返回一个值

37:37.400 --> 37:38.400
123

37:38.400 --> 37:39.400
132

37:39.400 --> 37:40.400
这个返回的值

37:40.400 --> 37:42.400
会在这里能够获取

37:42.400 --> 37:45.840
在这里能够获取

37:45.840 --> 37:46.840
保存

37:46.840 --> 37:47.840
看一下吧

37:47.840 --> 37:48.840
点击

37:48.840 --> 37:49.840
你看

37:49.840 --> 37:50.840
这里运行的函数

37:50.840 --> 37:51.840
那么这个地方

37:51.840 --> 37:52.840
能够获取它返回的值

37:52.840 --> 37:53.840
对吧

37:53.840 --> 37:54.840
能够获取它返回的值

37:54.840 --> 37:55.840
那么这个返回的值

37:55.840 --> 37:56.840
在地的update的时候

37:56.840 --> 37:58.840
它可能会用到

37:58.840 --> 37:59.840
我们后面讲这个场景

37:59.840 --> 38:00.840
现在不管

38:00.840 --> 38:01.840
你看

38:01.840 --> 38:03.840
只是在更新阶段

38:03.840 --> 38:05.840
更新阶段会使用这个函数

38:05.840 --> 38:07.840
其他阶段不会有

38:07.840 --> 38:08.840
就这么一个函数

38:08.840 --> 38:09.840
了解一下就行了

38:09.840 --> 38:10.840
目前了解一下就行了

38:10.840 --> 38:12.840
了解它的运行时间点就行了

38:12.840 --> 38:14.840
所以说新的生命周期里边

38:14.840 --> 38:15.840
其实

38:15.840 --> 38:16.840
加东西的吗

38:16.840 --> 38:18.840
好像说加了这两个东西

38:18.840 --> 38:19.840
实际上对我们目前

38:19.840 --> 38:20.840
就没什么用

38:20.840 --> 38:22.840
就加个就没什么用

38:22.840 --> 38:23.840
那相当于是什么呢

38:23.840 --> 38:25.840
相当于是我们减轻的负担

38:25.840 --> 38:26.840
对吧

38:26.840 --> 38:27.840
这个东西干掉了

38:27.840 --> 38:28.840
没用了

38:28.840 --> 38:29.840
这个东西有bug没用了

38:29.840 --> 38:30.840
这个东西容易出问题

38:30.840 --> 38:31.840
没用了

38:31.840 --> 38:32.840
这个东西没有意义

38:32.840 --> 38:33.840
没用了

38:33.840 --> 38:34.840
所以说这东西

38:34.840 --> 38:35.840
我们就把去掉了

38:35.840 --> 38:36.840
新的生命周期

38:36.840 --> 38:37.840
更加减化了

38:37.840 --> 38:40.840
这是关于生命周期这一块

38:40.840 --> 38:41.840
新的周期这一块

38:41.840 --> 38:42.840
再说一次

38:42.840 --> 38:44.840
生命周期对于我们而言

38:44.840 --> 38:46.840
最重要的是这些

38:46.840 --> 38:47.840
Render

38:47.840 --> 38:48.840
这个东西没变化

38:48.840 --> 38:50.840
ComponentDitAmount没变化

38:50.840 --> 38:53.840
ShouldComponentUpdate没变化

38:53.840 --> 38:54.840
ComponentWealAmount

38:54.840 --> 38:55.840
这几个东西都没有变化

38:55.840 --> 38:57.840
最重要的是这么几个

38:57.840 --> 38:58.840
这几个东西

38:58.840 --> 38:59.840
你一定要知道

38:59.840 --> 39:00.840
它什么时候运行

39:00.840 --> 39:01.840
什么时候运行

39:01.840 --> 39:03.840
它用来干什么事情的

39:03.840 --> 39:04.840
我这里都打出事的

39:04.840 --> 39:05.840
Render就是渲染

39:05.840 --> 39:06.840
这个没什么好说的

39:06.840 --> 39:08.840
然后这个是

39:08.840 --> 39:10.840
我们往往要启动一个

39:10.840 --> 39:11.840
远程琴球

39:11.840 --> 39:12.840
启动计时器

39:12.840 --> 39:13.840
往往在这里面写

39:13.840 --> 39:16.840
然后这里面主要是做性能优化的

39:16.840 --> 39:17.840
做性能优化的

39:17.840 --> 39:18.840
我们后边还会遇到这个东西

39:18.840 --> 39:20.840
目前还用的不是很多

39:20.840 --> 39:21.840
但是后边

39:21.840 --> 39:22.840
我们做一些性能优化的时候

39:22.840 --> 39:23.840
会用到

39:23.840 --> 39:24.840
然后这个东西

39:24.840 --> 39:25.840
是在销毁的时候

39:25.840 --> 39:26.840
比方说我们要清除一些计时器

39:26.840 --> 39:28.840
我们就可以在这里面写

39:28.840 --> 39:30.840
这是关于这么几个生命周期函数

39:30.840 --> 39:32.840
老老记住这么几个

39:32.840 --> 39:33.840
其他的都无所谓

39:33.840 --> 39:34.840
了解就行了

39:34.840 --> 39:36.840
这是关于生命周期这一块

