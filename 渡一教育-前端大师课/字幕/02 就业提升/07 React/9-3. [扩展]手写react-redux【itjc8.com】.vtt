WEBVTT

00:00.620 --> 00:04.620
这节课咱们来熟写一个React Redux

00:04.620 --> 00:07.620
虽然说是凡是熟写的地方

00:07.620 --> 00:10.620
我们大部分都是作为扩展课程的

00:10.620 --> 00:13.620
但是这节课实际上初学者也可以听一听

00:13.620 --> 00:16.620
因为特别简单

00:16.620 --> 00:19.620
我们之前学过的React Redux里面

00:19.620 --> 00:21.620
不就是有两个东西吗

00:21.620 --> 00:22.620
一个是Provider

00:22.620 --> 00:24.620
它提供一个上下文

00:24.620 --> 00:27.620
一个是Connect

00:27.620 --> 00:29.620
无非就是这么两个东西

00:29.620 --> 00:30.620
咱们来写呗

00:30.620 --> 00:33.620
我们这里新建有这么一个文件

00:33.620 --> 00:36.620
叫做React Redux

00:36.620 --> 00:39.620
然后我们首先在这里面写上一个文件

00:39.620 --> 00:41.620
index 就是默认导出文件

00:41.620 --> 00:44.620
这种模式大家应该非常熟悉了吧

00:44.620 --> 00:45.620
对不对

00:45.620 --> 00:47.620
然后我们这里新建一个文件

00:47.620 --> 00:50.620
就是Provider提供这么一个组件

00:50.620 --> 00:51.620
提供这个组件

00:51.620 --> 00:55.620
然后这个index里面怎么导出

00:55.620 --> 00:58.620
把这个Provider里面的默认值

00:58.620 --> 01:01.620
Provider导出

01:01.620 --> 01:03.620
Provider

01:03.620 --> 01:05.620
把这个导出就完事了

01:05.620 --> 01:06.620
这个Provider干嘛呢

01:06.620 --> 01:07.620
它就是个组件

01:07.620 --> 01:10.620
这个组件用来提供这么一个上下文

01:10.620 --> 01:12.620
我们就把它写成一个

01:12.620 --> 01:14.620
韩式主件得了

01:14.620 --> 01:16.620
直接把它写成一个韩式主件得了

01:16.620 --> 01:17.620
Provider

01:17.620 --> 01:18.620
然后这里面提供一个啥

01:18.620 --> 01:19.620
它没有什么元素

01:19.620 --> 01:21.620
元素这些东西全部没有

01:21.620 --> 01:24.620
它纯粹是用来提供一个上下文

01:24.620 --> 01:25.620
那么上下文的话

01:25.620 --> 01:26.620
我们这里可以新建个文件

01:26.620 --> 01:30.620
叫做ctx.js

01:30.620 --> 01:31.620
这里一个文件里面

01:31.620 --> 01:33.620
创建一个上下文就完事了

01:33.620 --> 01:37.620
react from right

01:37.620 --> 01:39.620
这里我们使用react里面的一个韩数

01:39.620 --> 01:41.620
叫create context

01:41.620 --> 01:43.620
创建这么一个上下文

01:43.620 --> 01:45.620
这里我们得到这个上下文

01:45.620 --> 01:48.060
ctx

01:48.060 --> 01:50.060
这个把返回就完事了

01:50.060 --> 01:51.060
实际上我们直接可以

01:51.060 --> 01:54.060
一个sport default

01:54.060 --> 01:55.060
直接返回就完事了

01:55.060 --> 01:56.060
这个很简单

01:56.060 --> 01:58.060
就创建一个上下文

01:58.060 --> 02:00.060
Provider里面无非就是

02:00.060 --> 02:02.060
使用这个上下文

02:02.060 --> 02:03.060
import

02:03.060 --> 02:06.060
搞进来fromctx

02:06.060 --> 02:07.060
然后这里面返回啥呢

02:07.060 --> 02:10.060
返回就是一个ctx

02:10.060 --> 02:12.060
provider

02:12.060 --> 02:14.060
返回的无非就是这个东西

02:14.060 --> 02:17.700
返回的就是这个东西

02:17.700 --> 02:19.700
就这么个上下文

02:19.700 --> 02:21.700
上下文里面不是要给它写上一个

02:21.700 --> 02:23.700
写上一个Value

02:23.700 --> 02:25.700
要给它一个Value属性值

02:25.700 --> 02:27.700
Value它是什么呢

02:27.700 --> 02:28.700
它有什么呢

02:28.700 --> 02:29.700
我们这里面就直接

02:29.700 --> 02:30.700
放个仓库就完事了

02:30.700 --> 02:31.700
你不是要给我

02:31.700 --> 02:33.700
传一个仓库

02:33.700 --> 02:34.700
就是它的属性

02:34.700 --> 02:35.700
我们来回顾一下

02:35.700 --> 02:37.700
咱们在App里面

02:37.700 --> 02:38.700
Provider里面

02:38.700 --> 02:39.700
是要给一个属性Store

02:39.700 --> 02:40.700
还要给个what

02:40.700 --> 02:42.700
给个choging对不对

02:42.700 --> 02:44.700
那么在这里当很简单

02:44.700 --> 02:46.700
我们就直接写

02:46.700 --> 02:48.700
把choging写到这就完事了

02:48.700 --> 02:50.700
然后仓库写到哪呢

02:50.700 --> 02:52.700
它不是有个属性吗

02:52.700 --> 02:53.700
属性就是仓库

02:53.700 --> 02:54.700
Store

02:54.700 --> 02:55.700
那么这个仓库

02:55.700 --> 02:57.700
我们就直接写到这

02:57.700 --> 02:58.700
ProvsterStore

02:58.700 --> 02:59.700
对不对

02:59.700 --> 03:00.700
直接写到这

03:00.700 --> 03:01.700
就完事了

03:03.700 --> 03:04.700
我们这里用

03:04.700 --> 03:07.700
GSX的导入react

03:07.700 --> 03:10.330
就完了

03:10.330 --> 03:12.330
Provider就写完了

03:12.330 --> 03:14.330
那咱们在这个Provider里面

03:14.330 --> 03:15.330
我们就

03:15.330 --> 03:17.330
一会我们肯定就直接使用

03:17.330 --> 03:19.330
我们自己的Provider

03:19.330 --> 03:20.330
直接使用我们自己的Provider

03:20.330 --> 03:21.330
我们这里先

03:21.330 --> 03:22.330
啥都不写

03:22.330 --> 03:24.330
比方说我们这里使用自己的Provider

03:24.330 --> 03:25.330
Provider来自于哪呢

03:25.330 --> 03:27.330
来自于点儿鞋杠

03:27.330 --> 03:28.330
reacts

03:28.330 --> 03:29.330
reacts是我们自己写的

03:29.330 --> 03:30.330
保存

03:30.330 --> 03:31.330
咱们看一下

03:35.330 --> 03:36.330
看一下吧

03:36.330 --> 03:39.830
它就会提供这么一个上下文

03:39.830 --> 03:40.830
等它运行出来

03:40.830 --> 03:42.830
Provider就写好了

03:42.830 --> 03:44.830
那除了Provider之外

03:44.830 --> 03:46.830
还有一个就是Connect

03:46.830 --> 03:51.230
我们先看一下这个Provider

03:52.230 --> 03:53.230
等一下

03:53.230 --> 03:57.910
等它运行出来

03:57.910 --> 03:59.910
运行出来了

03:59.910 --> 04:00.910
我们这里

04:00.910 --> 04:01.910
这些应该是升级的

04:01.910 --> 04:02.910
我这里升级了

04:02.910 --> 04:03.910
它变成这种模式了

04:03.910 --> 04:04.910
Component

04:04.910 --> 04:06.910
然后让我们看一下

04:06.910 --> 04:07.910
你看

04:07.910 --> 04:08.910
是不是就提供了一个上下文

04:08.910 --> 04:09.910
对不对

04:09.910 --> 04:10.910
Value就是什么

04:10.910 --> 04:11.910
就是一个仓库

04:11.910 --> 04:12.910
Stone

04:12.910 --> 04:14.910
实际上在它的原码里边

04:14.910 --> 04:15.910
这里边还提供了一些别的东西

04:15.910 --> 04:17.910
不过我们这里根本就用不到

04:17.910 --> 04:19.910
就提供这个Stone就行了

04:19.910 --> 04:20.910
因为它还要考虑一些

04:20.910 --> 04:22.910
什么服务端渲染的东西

04:22.910 --> 04:24.910
跟我们目前也没有什么关系

04:24.910 --> 04:25.910
好 接下来

04:25.910 --> 04:27.910
我们这里提供了上下文之后

04:27.910 --> 04:29.910
我们在这里再加一个Connect

04:29.910 --> 04:31.910
就是写这么一个函数

04:31.910 --> 04:32.910
来进行连接

04:32.910 --> 04:34.910
无非就是实现这两个东西

04:34.910 --> 04:35.910
对不对

04:35.910 --> 04:36.910
然后我们在这里

04:36.910 --> 04:38.910
In这个设里边导出

04:39.910 --> 04:43.670
导出Connect

04:43.670 --> 04:44.670
导出这个玩意

04:45.670 --> 04:46.670
然后我们这里

04:46.670 --> 04:48.670
Connect这里边怎么写呢

04:48.670 --> 04:49.670
我们来看一下

04:49.670 --> 04:50.670
之前

04:50.670 --> 04:52.670
我们这个Connect是怎么用的

04:52.670 --> 04:53.670
我们上一课

04:53.670 --> 04:54.670
讲了这个

04:55.670 --> 04:56.670
连接这一块

04:56.670 --> 04:57.670
Connect是

04:57.670 --> 04:58.670
它无非就是两个参数

04:58.670 --> 04:59.670
对不对

04:59.670 --> 05:00.670
两个参数

05:00.670 --> 05:02.670
一个是MapStateToProps

05:02.670 --> 05:04.670
IsMapDispatchToProps

05:04.670 --> 05:05.670
于是我们这里

05:05.670 --> 05:06.670
就照着这个写

05:06.670 --> 05:07.670
照着这种格式写

05:08.670 --> 05:10.670
我们这里写这么一个函数

05:10.670 --> 05:12.670
导出这么一个函数

05:12.670 --> 05:13.670
翻个写

05:14.670 --> 05:16.670
这个函数它有两个参数

05:16.670 --> 05:19.670
一个是MapStateToProps

05:19.670 --> 05:22.670
一个是MapDispatchToProps

05:22.670 --> 05:24.670
一共就这么两个参数

05:25.670 --> 05:27.670
那么有了这两个参数过后

05:27.670 --> 05:28.670
你看一下

05:28.670 --> 05:30.670
整个Connect反回的是啥

05:30.670 --> 05:32.670
反回的是一个Hoc

05:32.670 --> 05:33.670
一个高接组件

05:33.670 --> 05:35.670
这个高接组件是不是一个函数

05:35.670 --> 05:36.670
就整个框住这一坨

05:36.670 --> 05:38.670
它得到的结果

05:38.670 --> 05:39.670
是不是一个函数

05:39.670 --> 05:40.670
这个函数传入一个组件

05:40.670 --> 05:42.670
返回了一个新的组件

05:42.670 --> 05:43.670
所以说

05:43.670 --> 05:44.670
这个东西反回的是什么

05:44.670 --> 05:46.670
反回的是一个高接函数

05:46.670 --> 05:47.670
Return

05:47.670 --> 05:49.670
反回的是一个高接函数

05:49.670 --> 05:50.670
Hoc

05:50.670 --> 05:51.670
当然高接函数的话

05:51.670 --> 05:52.670
你可以不给名字

05:54.670 --> 05:55.670
我们这里打个数是

05:55.670 --> 06:00.670
反回一个高接函数

06:00.670 --> 06:01.670
反回一个高接函数

06:01.670 --> 06:02.670
那么既然是高接函数

06:02.670 --> 06:04.670
是不是要传入一个组件

06:04.670 --> 06:06.670
然后你得返回一个新的组件

06:06.670 --> 06:07.670
对不对

06:07.670 --> 06:08.670
返回了新的组件

06:08.670 --> 06:09.670
比方说我们这里有两种写法

06:09.670 --> 06:11.670
一种是使用内组件

06:11.670 --> 06:12.670
一种是使用函数组件

06:12.670 --> 06:13.670
那么比方说

06:13.670 --> 06:14.670
我们这里先使用内组件

06:14.670 --> 06:15.670
内组件是比较简单的

06:15.670 --> 06:16.670
这里写下来

06:16.670 --> 06:17.670
这里

06:18.670 --> 06:19.670
Import

06:20.670 --> 06:21.670
倒入

06:26.670 --> 06:27.670
反回的是什么呢

06:27.670 --> 06:28.670
反回的是一个内组件

06:28.670 --> 06:29.670
class

06:29.670 --> 06:30.670
给这个组件取个名字吗

06:30.670 --> 06:31.670
取个名字

06:32.670 --> 06:35.670
这个组件的名字的话

06:35.670 --> 06:36.670
它的原码里边

06:36.670 --> 06:37.670
这个组件的名字

06:37.670 --> 06:38.670
跟那个你这个组件的名字

06:38.670 --> 06:39.670
保持一致的

06:39.670 --> 06:41.670
它是保持一样的

06:41.670 --> 06:42.670
所以说

06:42.670 --> 06:43.670
这个组件的名字

06:43.670 --> 06:44.670
我们这样吧

06:44.670 --> 06:45.670
我们这样

06:45.670 --> 06:47.670
我把这个class

06:47.670 --> 06:48.670
小字

06:48.670 --> 06:49.670
temp

06:49.670 --> 06:50.670
就是

06:51.670 --> 06:52.670
temp

06:52.670 --> 06:54.670
extend

06:54.670 --> 06:56.670
然后react

06:56.670 --> 06:57.670
component

06:57.670 --> 06:59.670
这是个内组件

06:59.670 --> 07:00.670
然后给这个内组件

07:00.670 --> 07:01.670
设置一个display

07:01.670 --> 07:02.670
lay

07:02.670 --> 07:04.670
设置一个显示的名字

07:04.670 --> 07:05.670
显示的名字

07:05.670 --> 07:09.180
跟你这个组件的名字一样

07:09.180 --> 07:10.180
跟你这个组件的名字一样

07:10.180 --> 07:11.180
就是

07:12.180 --> 07:14.180
内组件的名称

07:14.180 --> 07:15.180
在调

07:15.180 --> 07:17.180
调是工具里边的名称

07:17.180 --> 07:18.180
和

07:18.180 --> 07:20.180
传入的组件一致

07:20.180 --> 07:22.180
传入的组件一致

07:22.180 --> 07:23.180
对吧

07:23.180 --> 07:24.180
那如果说传入的组件

07:24.180 --> 07:25.180
没有display name

07:25.180 --> 07:26.180
没有display name

07:26.180 --> 07:27.180
那么我们就使用

07:27.180 --> 07:28.180
传入的组件的

07:28.180 --> 07:29.180
函数名字

07:29.180 --> 07:30.180
函数名字

07:30.180 --> 07:32.180
这个代码都很简单

07:32.180 --> 07:33.180
display name

07:33.180 --> 07:34.180
我们之前也讲过

07:34.180 --> 07:35.180
是指的是那个组件的

07:35.180 --> 07:36.180
在

07:36.180 --> 07:37.180
在调示工具里边

07:37.180 --> 07:38.180
显示的名字

07:38.180 --> 07:39.180
就在这个位置

07:39.180 --> 07:40.180
就在这个位置

07:40.180 --> 07:42.180
在这个位置显示的名字

07:42.180 --> 07:44.180
但是也没有什么区别

07:44.180 --> 07:45.180
没多少影响

07:45.180 --> 07:46.180
如果说它没有这个display name

07:46.180 --> 07:47.180
那么我们就显示

07:47.180 --> 07:49.180
这个组件的函数名

07:49.180 --> 07:50.180
因为默认情况下

07:50.180 --> 07:51.180
就是函数名

07:51.180 --> 07:52.180
作为它的display

07:52.180 --> 07:53.180
就是显示的名字

07:53.180 --> 07:54.180
好 最后我们把这个

07:54.180 --> 07:55.180
内组件返回

07:55.180 --> 07:56.180
对吧

07:56.180 --> 07:57.180
所以我们这里

07:57.180 --> 07:58.180
要做的事情就是

07:58.180 --> 07:59.180
只是去实现

07:59.180 --> 08:00.180
这个内组件而已

08:01.180 --> 08:02.180
好 你看着

08:02.180 --> 08:03.180
看那个是这个函数

08:03.180 --> 08:05.180
你传入两个东西

08:05.180 --> 08:06.180
传入这两个东西

08:06.180 --> 08:07.180
然后过后

08:07.180 --> 08:08.180
我们在这一块

08:08.180 --> 08:09.180
就可以

08:09.180 --> 08:11.180
就是给它一个

08:11.180 --> 08:12.180
传入两个东西过后

08:12.180 --> 08:13.180
我们在这里

08:13.180 --> 08:15.180
给它的就是那个

08:16.180 --> 08:18.180
一个高阶

08:19.180 --> 08:20.180
高阶组件

08:20.180 --> 08:21.180
其实就是一个函数

08:21.180 --> 08:22.180
传入一个组件

08:22.180 --> 08:23.180
给你返回一个新的组件

08:23.180 --> 08:24.180
对吧

08:24.180 --> 08:25.180
那么就形成了这么一种结构了

08:25.180 --> 08:26.180
第二个

08:26.180 --> 08:27.180
这个卡拉伊格斯得到了什么

08:27.180 --> 08:28.180
高阶组件

08:28.180 --> 08:29.180
传入一个组件

08:29.180 --> 08:30.180
给你一个新的组件

08:31.180 --> 08:33.180
好 那么这个新的组件里边怎么写

08:33.180 --> 08:34.180
这个组件里边怎么写呢

08:34.180 --> 08:36.180
这个组件你要做啥

08:36.180 --> 08:38.180
是不是要利用上下文

08:38.180 --> 08:39.180
对不对

08:39.180 --> 08:41.180
我们要从上下文里边去得到

08:41.180 --> 08:42.180
得到我们的仓库

08:42.180 --> 08:43.180
因为仓库里边

08:43.180 --> 08:44.180
有一些数据

08:44.180 --> 08:45.180
加信息之类的东西

08:45.180 --> 08:46.180
对不对

08:46.180 --> 08:48.180
好 那么这个内组件里边

08:48.180 --> 08:50.180
我们现在要干嘛呢

08:50.180 --> 08:51.180
要干嘛呢

08:51.180 --> 08:53.180
我们是不是要去得到

08:53.180 --> 08:54.180
那个就是

08:56.180 --> 08:58.180
那个上下文里边的东西

08:58.180 --> 08:59.180
对吧

08:59.180 --> 09:00.180
要去得到上下文里边的东西

09:00.180 --> 09:01.180
那么这里呢

09:01.180 --> 09:02.180
我们就很简单

09:02.180 --> 09:03.180
我们这里写上

09:03.180 --> 09:04.180
上下文怎么写

09:04.180 --> 09:05.180
Static对吧

09:05.180 --> 09:06.180
我们可以通过Static

09:06.180 --> 09:07.180
来得到

09:07.180 --> 09:08.180
就是context

09:08.180 --> 09:09.180
Type

09:09.180 --> 09:10.180
把上下文呢

09:10.180 --> 09:12.180
去对应到这个上下文

09:12.180 --> 09:13.180
CTX from

09:14.180 --> 09:15.180
CTX

09:15.180 --> 09:16.180
对吧

09:16.180 --> 09:17.180
我们把上下文的对应到哪

09:17.180 --> 09:18.180
对应到这个CTX

09:18.180 --> 09:19.180
那么这样子一来了

09:19.180 --> 09:21.180
这个内组件里边自然而然

09:21.180 --> 09:23.180
它就有了这么一个数相

09:23.180 --> 09:25.180
就是context这个数相

09:25.180 --> 09:26.180
不知道它还记不记得

09:26.180 --> 09:27.180
这东西不要丢啊

09:27.180 --> 09:29.180
学了过就不要丢

09:29.180 --> 09:30.180
我们这里输出

09:30.180 --> 09:31.180
输出这个

09:31.180 --> 09:33.180
这个就是啥

09:33.180 --> 09:36.180
输出这个就是context

09:36.180 --> 09:38.180
输出这个context

09:38.180 --> 09:39.180
this.context

09:39.180 --> 09:41.180
this.context

09:41.180 --> 09:43.180
看一下上下文那边东西吧

09:43.180 --> 09:44.180
我们看一下能不能得到

09:44.180 --> 09:45.180
能不能得到

09:45.180 --> 09:46.180
好

09:46.180 --> 09:47.180
这个能不能保存一下啊

09:47.180 --> 09:49.180
我们到这个

09:49.180 --> 09:51.180
student設计里边去

09:51.180 --> 09:52.180
然后呢

09:52.180 --> 09:53.180
我们把这个

09:53.180 --> 09:54.180
reactory大格式

09:54.180 --> 09:55.180
用我们自己的

09:55.180 --> 09:57.180
用我们自己的reactory大格式

09:57.180 --> 09:58.180
里面导出

09:58.180 --> 09:59.180
context

09:59.180 --> 10:00.180
看一下啊

10:00.180 --> 10:01.180
虽然说现在

10:01.180 --> 10:02.180
肯定是啥都显示不了

10:02.180 --> 10:03.180
咱们来看一下

10:03.180 --> 10:04.180
打印的结果

10:04.180 --> 10:05.180
打印的结果

10:05.180 --> 10:06.180
这样子一连接

10:06.180 --> 10:07.180
打印的结果是啥

10:07.180 --> 10:09.180
看一下吧

10:09.180 --> 10:11.180
我们到那个

10:11.180 --> 10:12.180
app里面来

10:12.180 --> 10:14.180
我们还是把这个东西加进去

10:14.180 --> 10:19.060
好保存啊看一下

10:19.060 --> 10:20.060
这里报错了

10:20.060 --> 10:21.060
报了很多错误

10:21.060 --> 10:23.060
他说他没有写render

10:23.060 --> 10:24.060
对了我这里没有写render

10:24.060 --> 10:25.060
行吧

10:25.060 --> 10:27.060
那咱们把这个render写上

10:27.060 --> 10:28.060
render写上

10:28.060 --> 10:30.060
返回的就是一个那

10:30.060 --> 10:31.060
啥都没返回

10:31.060 --> 10:32.060
保存

10:32.060 --> 10:34.060
这个地方的context

10:34.060 --> 10:35.060
是undefend的

10:35.060 --> 10:36.060
我想一下啊

10:36.060 --> 10:38.060
哦是这样子

10:38.060 --> 10:40.060
我们之前讲那个

10:40.060 --> 10:41.060
上下文的时候说过啊

10:41.060 --> 10:42.060
就是说这个上下文呢

10:42.060 --> 10:43.060
如果说一个组件

10:43.060 --> 10:45.060
他要使用上下文

10:45.060 --> 10:46.060
不管是你是韩式组件也好

10:46.060 --> 10:48.060
还是内组件也好

10:48.060 --> 10:49.060
那么他会把

10:49.060 --> 10:50.060
这个上下文呢

10:50.060 --> 10:51.060
作为第二个参数

10:51.060 --> 10:53.060
传到构造韩数里面去

10:53.060 --> 10:54.060
啊

10:54.060 --> 10:55.060
他会把这个上下文

10:55.060 --> 10:56.060
作为第二个参数

10:56.060 --> 10:58.060
传到构造韩数里面去

10:58.060 --> 10:59.060
然后呢

10:59.060 --> 11:00.060
这个构造

11:00.060 --> 11:01.060
我们可以通过

11:01.060 --> 11:02.060
第二个参数来获取

11:02.060 --> 11:03.060
这个上下文

11:03.060 --> 11:04.060
那么这个属性里面的

11:04.060 --> 11:05.060
上下文的就是

11:05.060 --> 11:06.060
他怎么来形成自己的属性呢

11:06.060 --> 11:08.060
你需要把这个上下文的

11:08.060 --> 11:09.060
作为第二个参数

11:09.060 --> 11:10.060
传给副类的构造韩数

11:10.060 --> 11:11.060
啊

11:11.060 --> 11:12.060
你需要把这个上下文

11:12.060 --> 11:13.060
作为副类

11:13.060 --> 11:15.060
作为第二个参数

11:15.060 --> 11:17.060
传给副类的构造韩数

11:17.060 --> 11:18.060
因为副类的构造韩数里面

11:18.060 --> 11:19.060
他会把这个上下文呢

11:19.060 --> 11:20.060
保存到那

11:20.060 --> 11:21.060
保存到属性里面

11:21.060 --> 11:22.060
那么这样子呢

11:22.060 --> 11:23.060
你就可以从属性里面获取了

11:23.060 --> 11:25.060
好保存看一下

11:25.060 --> 11:26.060
好看一下

11:26.060 --> 11:27.060
你看上下文是不是获取了

11:27.060 --> 11:28.060
上下文里面是不是

11:28.060 --> 11:29.060
这个数据就是

11:29.060 --> 11:30.060
一个仓库

11:30.060 --> 11:31.060
对吧

11:31.060 --> 11:32.060
你看这个spark

11:32.060 --> 11:33.060
getStats

11:33.060 --> 11:34.060
对不对

11:34.060 --> 11:35.060
全有吗

11:35.060 --> 11:36.060
好那你搞定了

11:36.060 --> 11:37.060
对吧就搞定了

11:37.060 --> 11:38.060
没问题吧

11:39.060 --> 11:40.060
这一块没问题吧

11:40.060 --> 11:41.060
就我们这个组件

11:41.060 --> 11:42.060
他使用了上下文

11:42.060 --> 11:43.060
因此呢

11:43.060 --> 11:45.060
他在使用这个组件的时候呢

11:45.060 --> 11:46.060
他会把这个上下文对象

11:46.060 --> 11:47.060
上下文里面的数据

11:47.060 --> 11:49.060
传到第二个参数里面去

11:49.060 --> 11:51.060
那么传到第二个参数里面去呢

11:51.060 --> 11:52.060
你要手动的把它传到

11:52.060 --> 11:53.060
副类的构造韩数

11:53.060 --> 11:54.060
因为副类的构造韩数里面

11:54.060 --> 11:55.060
他会把这上下文

11:55.060 --> 11:56.060
保存到属性

11:56.060 --> 11:57.060
你之后呢

11:57.060 --> 11:58.060
才能在属性里面

11:58.060 --> 11:59.060
获取这个上下文

11:59.060 --> 12:00.060
好

12:00.060 --> 12:01.060
拿到这个上下文之后呢

12:01.060 --> 12:02.060
就是其实就是一个仓库

12:02.060 --> 12:03.060
对吧

12:03.060 --> 12:04.060
就是一个Stone

12:04.060 --> 12:05.060
这个上下文

12:05.060 --> 12:06.060
我们会用个变量

12:08.060 --> 12:09.060
就是个Stone

12:09.060 --> 12:11.060
就是

12:11.060 --> 12:13.060
this.context

12:13.060 --> 12:15.060
stone

12:15.060 --> 12:16.060
就是一个仓库

12:16.060 --> 12:17.060
对吧

12:17.060 --> 12:18.060
甚至呢

12:18.060 --> 12:19.060
你可以把这个仓库保存到

12:19.060 --> 12:21.060
保存到对象的属性里面

12:21.060 --> 12:22.060
都可以

12:22.060 --> 12:23.060
换个名字

12:23.060 --> 12:24.060
其实也不用换

12:24.060 --> 12:25.060
主要是我这样子写的

12:25.060 --> 12:26.060
看得懂一点

12:26.060 --> 12:27.060
看得懂一点

12:27.060 --> 12:28.060
Stone 仓库

12:28.060 --> 12:29.060
对吧

12:29.060 --> 12:30.060
仓库

12:30.060 --> 12:31.060
好了

12:31.060 --> 12:32.060
接下来呢

12:32.060 --> 12:33.060
我们要做什么

12:33.060 --> 12:34.060
我们之前好像是做过的

12:34.060 --> 12:35.060
我们这个组件里面呢

12:35.060 --> 12:36.060
要维护一个状态

12:36.060 --> 12:37.060
对吧

12:37.060 --> 12:38.060
维护一个状态

12:38.060 --> 12:39.060
这个状态是啥呢

12:39.060 --> 12:41.060
就是通过这个函数

12:41.060 --> 12:43.060
来得到的状态

12:43.060 --> 12:44.060
就是通过这个函数

12:44.060 --> 12:45.060
来得到的状态

12:45.060 --> 12:47.060
我们这里要维护一个状态

12:47.060 --> 12:48.060
这个状态来自于哪

12:48.060 --> 12:50.060
来自于这个函数

12:50.060 --> 12:51.060
这个函数是什么

12:51.060 --> 12:54.060
给它一个整个仓库的数据

12:54.060 --> 12:56.060
它返回给你一个对象

12:56.060 --> 12:57.060
对吧

12:57.060 --> 12:58.060
返回一个对象

12:58.060 --> 12:59.060
你看一下吧

12:59.060 --> 13:01.060
给它一个整个仓库的数据

13:01.060 --> 13:02.060
然后呢

13:02.060 --> 13:03.060
它返回一个对象

13:03.060 --> 13:04.060
那个对象的每一个属性

13:04.060 --> 13:06.060
就是我们到时候要传递给

13:06.060 --> 13:07.060
这个组件的属性

13:07.060 --> 13:08.060
对吧

13:08.060 --> 13:09.060
是这样吧

13:09.060 --> 13:11.060
好 那么咱们这里呢

13:11.060 --> 13:14.060
我就调用这个函数

13:14.060 --> 13:16.060
调用这个函数

13:16.060 --> 13:18.060
把什么给它

13:18.060 --> 13:19.060
把什么给它

13:19.060 --> 13:21.060
把我们整个仓库的数据给它

13:21.060 --> 13:22.060
好 整个仓库的数据

13:22.060 --> 13:23.060
来自于ZestorStone

13:23.060 --> 13:25.060
调getState

13:25.060 --> 13:26.060
对吧

13:26.060 --> 13:28.060
我们把整个仓库的数据给力

13:28.060 --> 13:31.060
你是不是会返回给我一个结果

13:31.060 --> 13:32.060
给我一个什么结果呢

13:32.060 --> 13:33.060
你会给我一个就是

13:33.060 --> 13:35.060
最终映射出来的结果

13:35.060 --> 13:36.060
映射出来的数据

13:36.060 --> 13:38.060
就是我需要哪部分数据

13:38.060 --> 13:39.060
那么这里呢

13:39.060 --> 13:40.060
我们

13:40.060 --> 13:42.060
它会得到一个结果

13:42.060 --> 13:43.060
那么我们把这个结果

13:43.060 --> 13:44.060
是不是保存到状态里面

13:44.060 --> 13:45.060
对吧

13:47.060 --> 13:49.060
状态中的数据

13:49.060 --> 13:51.060
状态中的数据

13:51.060 --> 13:53.060
来自于

13:53.060 --> 13:54.060
来自于哪呢

13:54.060 --> 13:57.060
来自于就是仓库

13:57.060 --> 14:00.060
仓库中映射的结果

14:00.060 --> 14:01.060
这个函数

14:01.060 --> 14:03.060
会把仓库里面的状态

14:03.060 --> 14:05.060
映射成一个局部的数据

14:05.060 --> 14:06.060
一个局部的

14:06.060 --> 14:07.060
我们需要的数据

14:07.060 --> 14:08.060
那么我们把这个数据

14:08.060 --> 14:09.060
保存到状态里面

14:09.060 --> 14:11.060
对吧

14:11.060 --> 14:12.060
当时你这里要注意

14:12.060 --> 14:14.060
这个属性是不是可以不传的

14:14.060 --> 14:15.060
是不是可以不传

14:15.060 --> 14:16.060
那么不传的话

14:16.060 --> 14:17.060
你是不是可以

14:17.060 --> 14:18.060
要写个判断

14:18.060 --> 14:19.060
判断啥

14:19.060 --> 14:21.060
判断就是

14:21.060 --> 14:23.060
mapState to props

14:23.060 --> 14:24.060
是不是存在的

14:24.060 --> 14:25.060
如果说它存在的话

14:25.060 --> 14:26.060
我们才做这件事情

14:26.060 --> 14:27.060
对吧

14:27.060 --> 14:29.060
存在的时候才做这件事情

14:29.060 --> 14:31.060
不存在我就不做了

14:31.060 --> 14:32.060
明白这个意思吗

14:32.060 --> 14:34.060
没问题吧

14:34.060 --> 14:35.060
好

14:35.060 --> 14:36.060
那么如果它存在的话

14:36.060 --> 14:37.060
我们这里

14:37.060 --> 14:39.060
把这个数据拿到

14:39.060 --> 14:41.060
拿到

14:41.060 --> 14:42.060
好

14:42.060 --> 14:43.060
那么接下来

14:43.060 --> 14:44.060
接下来

14:44.060 --> 14:46.060
我们要做的事情是

14:46.060 --> 14:47.060
监听

14:47.060 --> 14:49.060
监听它数据的变化

14:49.060 --> 14:51.060
监听它数据的变化

14:51.060 --> 14:52.060
那如果说你

14:52.060 --> 14:54.060
不监听数据的变化的话

14:54.060 --> 14:56.060
那我这里

14:56.060 --> 14:57.060
我到时候

14:57.060 --> 14:58.060
仓库里面数据改变过后

14:58.060 --> 14:59.060
这个组建

14:59.060 --> 15:00.060
它不会重新旋转

15:00.060 --> 15:01.060
对不对

15:01.060 --> 15:02.060
所以说我们这里

15:02.060 --> 15:04.060
要监听仓库里面的数据变化

15:04.060 --> 15:05.060
好

15:05.060 --> 15:06.060
这里

15:06.060 --> 15:07.060
监听

15:07.060 --> 15:08.060
仓库

15:08.060 --> 15:11.060
中的数据变化

15:11.060 --> 15:13.060
它要监听仓库里面的数据变化

15:13.060 --> 15:14.060
但是前提条件

15:14.060 --> 15:15.060
你必须要映射

15:15.060 --> 15:16.060
映射的数据过后

15:16.060 --> 15:17.060
我才要监听

15:17.060 --> 15:18.060
你数据都没有给我

15:18.060 --> 15:19.060
我监听啥数据变化呢

15:19.060 --> 15:20.060
我就不需要你的数据

15:20.060 --> 15:21.060
对吧

15:21.060 --> 15:22.060
根本就不需要

15:22.060 --> 15:23.060
仓库里面的数据

15:23.060 --> 15:24.060
我根本就不监听了

15:24.060 --> 15:25.060
所以说你只有给了的我数据

15:25.060 --> 15:26.060
我才需要去监听

15:26.060 --> 15:28.060
仓库里面的数据变化

15:28.060 --> 15:29.060
好那么这个监听

15:31.060 --> 15:33.060
就是利用这个Store

15:33.060 --> 15:34.060
Store

15:34.060 --> 15:36.060
它不是一个subscript吗

15:36.060 --> 15:38.060
subscript

15:38.060 --> 15:39.060
quib

15:39.060 --> 15:40.060
对吧

15:40.060 --> 15:42.060
subscript

15:42.060 --> 15:44.060
那么这里是不是写个函数

15:44.060 --> 15:45.060
对不对

15:45.060 --> 15:46.060
写个函数

15:46.060 --> 15:47.060
当仓库里面的数据

15:47.060 --> 15:49.060
发生变化的时候

15:49.060 --> 15:50.060
我们要干嘛

15:50.060 --> 15:52.060
是不是要重新设置状态

15:52.060 --> 15:53.060
对吧

15:53.060 --> 15:54.060
因为你一旦掉落

15:54.060 --> 15:55.060
sets data

15:55.060 --> 15:56.060
是不是就改变了状态了

15:56.060 --> 15:57.060
对吧

15:57.060 --> 15:58.060
状态就改变了

15:58.060 --> 15:59.060
那么这个组件

15:59.060 --> 16:00.060
是不是重新刷新了

16:00.060 --> 16:01.060
复制过来

16:01.060 --> 16:02.060
复制过来

16:02.060 --> 16:03.060
不就完了吗

16:03.060 --> 16:04.060
还要干嘛呢

16:04.060 --> 16:05.060
你告诉我还要干嘛

16:05.060 --> 16:06.060
不就完了吗

16:06.060 --> 16:07.060
对不对

16:07.060 --> 16:08.060
好那么这里

16:08.060 --> 16:09.060
我们还要做一个细节

16:09.060 --> 16:11.060
就是数据发生变化之后

16:11.060 --> 16:13.060
数据发生变化之后

16:13.060 --> 16:15.060
那么我们这里获得了监听

16:15.060 --> 16:16.060
那当有一天

16:16.060 --> 16:17.060
这个组件不再使用了

16:17.060 --> 16:18.060
那么这个监听

16:18.060 --> 16:19.060
是不是得取消

16:19.060 --> 16:20.060
你得取消监听

16:20.060 --> 16:21.060
因为我们之前以前知道

16:21.060 --> 16:22.060
这个函数

16:22.060 --> 16:23.060
它会返回一个结果

16:23.060 --> 16:26.060
就是取消监听的函数

16:26.060 --> 16:27.060
就得到

16:28.060 --> 16:31.060
一个取消监听的函数

16:31.060 --> 16:32.060
那么这个函数

16:32.060 --> 16:34.060
我们可以用一个属性来接收

16:34.060 --> 16:36.060
z点 on listen

16:36.060 --> 16:37.060
on listen

16:37.060 --> 16:38.060
来接收

16:38.060 --> 16:40.060
那么这个属性接收过后

16:40.060 --> 16:41.060
等到什么时候

16:41.060 --> 16:43.060
我就不再监听了

16:43.060 --> 16:45.060
等到这个组件卸载的时候

16:45.060 --> 16:46.060
component

16:46.060 --> 16:47.060
vio

16:47.060 --> 16:48.060
component

16:48.060 --> 16:50.060
vio

16:50.060 --> 16:52.060
on mount

16:52.060 --> 16:53.060
当我们组件卸载的时候

16:53.060 --> 16:56.380
判断一下

16:56.380 --> 16:57.380
z on listen

16:57.380 --> 16:58.380
如果存在

16:58.380 --> 17:00.380
说明是之前传的这个东西

17:00.380 --> 17:03.380
那么我们这里就取消监听

17:03.380 --> 17:05.380
取消监听

17:05.380 --> 17:06.380
on listen

17:06.380 --> 17:09.380
取消监听就完事了

17:09.380 --> 17:10.380
当组件

17:10.380 --> 17:11.380
大家说是

17:11.380 --> 17:15.380
当组件卸载时

17:15.380 --> 17:17.380
取消监听

17:17.380 --> 17:18.380
对吧

17:18.380 --> 17:19.380
那么这样子

17:19.380 --> 17:20.380
maps that to props

17:20.380 --> 17:21.380
是不是搞定了

17:21.380 --> 17:22.380
对吧

17:22.380 --> 17:23.380
这一块就搞定了

17:23.380 --> 17:24.380
把它放到状态里边

17:24.380 --> 17:25.380
只要

17:25.380 --> 17:27.380
只要仓库里边的东西一遍

17:27.380 --> 17:29.380
那么我这里就重新映射状态

17:29.380 --> 17:31.380
重新映射状态

17:31.380 --> 17:32.380
好

17:32.380 --> 17:34.380
那么接下来我们来再看另外一个

17:34.380 --> 17:36.380
map dispatch to props

17:36.380 --> 17:38.380
再看这个东西

17:38.380 --> 17:39.380
那么这个东西呢

17:39.380 --> 17:41.380
是不是得到一个处理函数

17:41.380 --> 17:42.380
对不对

17:42.380 --> 17:43.380
是不是得到一个处理函数

17:43.380 --> 17:44.380
那么我们

17:44.380 --> 17:45.380
我们刚才先把这个状态

17:45.380 --> 17:46.380
放到这个组件里边

17:46.380 --> 17:47.380
在渲染的时候

17:47.380 --> 17:48.380
先把这个状态

17:48.380 --> 17:49.380
我们映射出来的状态

17:49.380 --> 17:50.380
放到组件里边

17:50.380 --> 17:51.380
我们这里渲染的时候

17:51.380 --> 17:52.380
渲染啥呢

17:52.380 --> 17:53.380
渲染啥呢

17:53.380 --> 17:54.380
是不是渲染这个组件

17:54.380 --> 17:55.380
对吧

17:55.380 --> 17:56.380
最终我们渲染的是这个组件

17:56.380 --> 17:57.380
OK 那么我们这里呢

17:57.380 --> 17:59.380
返回的就是这个组件

17:59.380 --> 18:00.380
那么给它的属性是什么呢

18:00.380 --> 18:02.380
给它的属性是啥

18:02.380 --> 18:04.380
给它的属性是啥

18:04.380 --> 18:07.380
给它的属性是不是来自于

18:07.380 --> 18:10.380
给它的属性来自于我们的状态

18:10.380 --> 18:11.380
对吧

18:11.380 --> 18:13.380
我们把我们的状态展开

18:13.380 --> 18:14.380
get state

18:14.380 --> 18:15.380
状态展开

18:15.380 --> 18:17.380
是不是把我们状态里边的数据

18:17.380 --> 18:18.380
就作为属性传过去了

18:18.380 --> 18:19.380
对吧

18:19.380 --> 18:20.380
你看

18:20.380 --> 18:21.380
我们的状态的数据哪来的

18:21.380 --> 18:23.380
通过这个map to props

18:23.380 --> 18:24.380
哪来的 哪来的这个数据

18:24.380 --> 18:25.380
对吧 哪来的这个数据

18:25.380 --> 18:26.380
然后呢

18:26.380 --> 18:27.380
我们把通过

18:27.380 --> 18:28.380
达到这个数据

18:28.380 --> 18:29.380
把它保存到状态里边过后呢

18:29.380 --> 18:31.380
我们就把这个数据展开

18:31.380 --> 18:32.380
把它的每一个属性

18:32.380 --> 18:34.380
就传递给这个组件

18:34.380 --> 18:36.380
所以说我们当时写这个

18:36.380 --> 18:37.380
写这个地方的时候

18:37.380 --> 18:38.380
那么这里呢

18:38.380 --> 18:39.380
是不是要对应这个

18:39.380 --> 18:40.380
我们要

18:40.380 --> 18:41.380
我们这里组件的数据名

18:41.380 --> 18:42.380
对吧

18:42.380 --> 18:43.380
组件的属性名

18:43.380 --> 18:44.380
要对应上

18:44.380 --> 18:46.380
就这么个意思

18:46.380 --> 18:48.380
好 那么这里呢

18:48.380 --> 18:49.380
这个地方就是不是写完了

18:49.380 --> 18:50.380
对吧

18:50.380 --> 18:51.380
写完了

18:51.380 --> 18:52.380
那还有事件呢

18:52.380 --> 18:54.380
事件是不是也得传过去啊

18:54.380 --> 18:56.380
事件是不是也得传过去

18:56.380 --> 18:57.380
好 事件的话

18:57.380 --> 18:58.380
我们可以在Render里边

18:58.380 --> 18:59.380
就直接写

18:59.380 --> 19:00.380
直接写

19:00.380 --> 19:01.380
好 怎么写呢

19:01.380 --> 19:03.380
在Render里边

19:03.380 --> 19:05.380
怎么写呢

19:05.380 --> 19:06.380
我们可以

19:06.380 --> 19:08.380
其实也可以在这里

19:08.380 --> 19:10.380
直接写也行

19:10.380 --> 19:11.380
在这里直接写了也行

19:11.380 --> 19:12.380
我们在构造函数里边

19:12.380 --> 19:13.380
直接写了也行

19:13.380 --> 19:15.380
好 if 判断一下

19:15.380 --> 19:18.380
map to props

19:18.380 --> 19:19.380
是否存在

19:19.380 --> 19:21.380
是否存在

19:21.380 --> 19:22.380
我这里就不去判断

19:22.380 --> 19:23.380
它的两种情况了

19:23.380 --> 19:24.380
因为我们之前讲过

19:24.380 --> 19:25.380
这里有两种情况

19:25.380 --> 19:28.380
一种就是你给我的是一个函数

19:28.380 --> 19:29.380
另一种是

19:29.380 --> 19:31.380
给我的是一个对象

19:31.380 --> 19:34.380
给我的是一个对象

19:34.380 --> 19:35.380
算了 我全部重新写吧

19:35.380 --> 19:36.380
我重新写吧

19:36.380 --> 19:37.380
这个也没啥

19:37.380 --> 19:38.380
没啥 重新写就得了

19:38.380 --> 19:39.380
重新写就得了

19:39.380 --> 19:41.380
好 那么这里边呢

19:41.380 --> 19:42.380
来写一下

19:42.380 --> 19:43.380
如果说你给了我

19:43.380 --> 19:44.380
给了我这个东西

19:44.380 --> 19:46.380
如果说你给了我这个东西

19:46.380 --> 19:48.380
那么我要传递给你啥呢

19:48.380 --> 19:50.380
我

19:50.380 --> 19:51.380
我这样吧

19:51.380 --> 19:52.380
我专门来写个函数

19:52.380 --> 19:53.380
来处理这个事情

19:53.380 --> 19:54.380
写个函数

19:54.380 --> 19:55.380
这个函数的名字

19:55.380 --> 19:56.380
能给他取的名字叫做

19:56.380 --> 20:00.380
就是get

20:00.380 --> 20:04.380
get event handler

20:04.380 --> 20:05.380
get event handler

20:05.380 --> 20:09.690
得到事件处理函数

20:09.690 --> 20:14.690
得到需要传递的事件

20:14.690 --> 20:16.690
事件属性

20:16.690 --> 20:19.690
事件处理属性

20:19.690 --> 20:24.690
那么我们把代码写到这里边

20:24.690 --> 20:25.690
然后我们这里

20:25.690 --> 20:27.690
如果说你传递了这个字

20:27.690 --> 20:28.690
传递了这个字

20:28.690 --> 20:29.690
那么我们这里呢

20:29.690 --> 20:31.690
handlers

20:31.690 --> 20:32.690
我得到一个handlers

20:32.690 --> 20:34.690
保存到属性里边

20:34.690 --> 20:35.690
然后调用函数

20:35.690 --> 20:38.690
get event handler

20:38.690 --> 20:39.690
那么我们这里呢

20:39.690 --> 20:40.690
就可以得到这个东西

20:40.690 --> 20:41.690
最终我们

20:41.690 --> 20:42.690
这个得到的是一个对象

20:42.690 --> 20:43.690
得到的是一个对象

20:43.690 --> 20:45.690
最终我们把handlers

20:45.690 --> 20:46.690
可以传进去

20:47.690 --> 20:49.690
handlers给你传进去

20:49.690 --> 20:50.690
对吧

20:50.690 --> 20:51.690
把我的状态数据给你传进去

20:51.690 --> 20:53.690
把我的事件处理函数给你传进去

20:53.690 --> 20:55.690
你不就是要这些东西吗

20:55.690 --> 20:56.690
我一次传递给你就行了

20:56.690 --> 20:57.690
那么我们这里呢

20:57.690 --> 20:58.690
就把写完吧

20:58.690 --> 21:00.690
在这个函数里边

21:00.690 --> 21:01.690
是不是有几种情况

21:01.690 --> 21:02.690
这个map

21:02.690 --> 21:04.690
这个map is dispatch to props

21:04.690 --> 21:05.690
是不是有几种情况

21:05.690 --> 21:06.690
我们一个个来

21:06.690 --> 21:08.690
如果说你的map

21:08.690 --> 21:10.690
dispatch to props

21:10.690 --> 21:11.690
是一个函数

21:11.690 --> 21:15.510
如果你给我的是一个函数

21:15.510 --> 21:17.510
这是我们最常见的一种情况

21:18.510 --> 21:19.510
就是说你这里呢

21:19.510 --> 21:20.510
你给我的是什么

21:20.510 --> 21:21.510
给我的是一个函数

21:21.510 --> 21:22.510
不是

21:22.510 --> 21:23.510
给我的是一个对

21:23.510 --> 21:24.510
就是一个函数

21:24.510 --> 21:25.510
你看看

21:25.510 --> 21:26.510
整个是一个函数

21:26.510 --> 21:27.510
它需要一个dispatch传进去

21:27.510 --> 21:28.510
然后呢

21:28.510 --> 21:30.510
返回到是一个对象

21:30.510 --> 21:31.510
返回的是一个对象

21:31.510 --> 21:33.510
如果说是这种情况的话

21:33.510 --> 21:34.510
那么我怎么办

21:34.510 --> 21:35.510
我是不是雕用这个函数

21:35.510 --> 21:36.510
是不是得到对象了

21:36.510 --> 21:37.510
雕用你这个函数

21:37.510 --> 21:38.510
给你传一个什么

21:38.510 --> 21:40.510
传一个dispatch

21:40.510 --> 21:41.510
this叫stone

21:41.510 --> 21:42.510
dispatch

21:43.510 --> 21:45.510
把dispatch传进去

21:45.510 --> 21:46.510
如果你是一个函数的话

21:46.510 --> 21:48.510
我就把dispatch传给你

21:48.510 --> 21:49.510
传给你

21:49.510 --> 21:51.510
你看这个stone哪来的

21:51.510 --> 21:53.510
是之前保持到属性里面的

21:53.510 --> 21:55.510
那么dispatch传给你

21:55.510 --> 21:56.510
传给你过后呢

21:56.510 --> 21:57.510
我是不是得到一个

21:57.510 --> 21:58.510
就得到一个对象了

21:58.510 --> 21:59.510
是不是这个对象

21:59.510 --> 22:00.510
对不对

22:00.510 --> 22:01.510
这个对象

22:01.510 --> 22:02.510
OK我就把这个对象返回

22:02.510 --> 22:03.510
就完了

22:03.510 --> 22:04.510
这个很简单

22:04.510 --> 22:05.510
你看一下

22:05.510 --> 22:06.510
我们之前全自用

22:06.510 --> 22:07.510
这种方式来做的

22:07.510 --> 22:08.510
那么现在就随时已经写完了

22:08.510 --> 22:09.510
告诉大家

22:09.510 --> 22:10.510
已经写完了

22:10.510 --> 22:11.510
你看着吧

22:12.510 --> 22:13.510
你看是不是已经出来了

22:13.510 --> 22:14.510
点击2

22:14.510 --> 22:15.510
你看

22:15.510 --> 22:16.510
这就已经写完了

22:16.510 --> 22:17.510
就这么简单

22:17.510 --> 22:18.510
你越多复杂

22:18.510 --> 22:19.510
就这么简单

22:20.510 --> 22:21.510
只不过呢

22:21.510 --> 22:22.510
我们这里只考虑到函数的情况

22:22.510 --> 22:23.510
那么如果说

22:23.510 --> 22:24.510
它是一个对象的话

22:24.510 --> 22:25.510
l

22:25.510 --> 22:26.510
我们之前还说过

22:27.510 --> 22:31.210
如果说它是一个对象的话

22:32.210 --> 22:33.210
map

22:33.210 --> 22:34.210
dispatch

22:35.210 --> 22:36.210
to props

22:36.210 --> 22:38.210
如果是一个object

22:38.210 --> 22:39.210
它是一个对象

22:39.210 --> 22:41.210
那么这个对象里边

22:41.210 --> 22:42.210
这个对象里边有

22:42.210 --> 22:44.210
就是如果你直接给它写个对象

22:44.210 --> 22:45.210
那么对象里边

22:45.210 --> 22:46.210
我们之前说过

22:46.210 --> 22:47.210
写的是什么

22:47.210 --> 22:48.210
x形创建函数

22:48.210 --> 22:49.210
对吧

22:49.210 --> 22:50.210
x形创建函数

22:50.210 --> 22:51.210
对象里边的每一个属性

22:51.210 --> 22:53.210
就是一个x形创建函数

22:54.210 --> 22:56.210
那我们要做的事情就是

22:56.210 --> 22:57.210
到时候

22:57.210 --> 22:59.210
它调用一个创建函数的时候

22:59.210 --> 23:01.210
我要把dispatch的x形

23:01.210 --> 23:02.210
实际上这里在做什么

23:02.210 --> 23:03.210
实际上这里的做法

23:03.210 --> 23:04.210
就是

23:05.210 --> 23:06.210
就是用band

23:06.210 --> 23:07.210
x形

23:07.210 --> 23:10.710
实际上就是用了这个

23:10.710 --> 23:12.710
from

23:12.710 --> 23:14.710
用到的就是band

23:14.710 --> 23:15.710
x形creators

23:15.710 --> 23:17.710
就是说如果你直接把

23:17.710 --> 23:18.710
x形创建函数传给它

23:18.710 --> 23:19.710
就是这个东西

23:19.710 --> 23:20.710
直接是一个

23:20.710 --> 23:21.710
x形创建函数

23:21.710 --> 23:22.710
组成了对象

23:22.710 --> 23:23.710
那我这里就直接用band

23:23.710 --> 23:24.710
x形creators

23:24.710 --> 23:26.710
把这个给传进去

23:26.710 --> 23:28.710
那么反而把dispatch

23:28.710 --> 23:29.710
要传进去

23:30.710 --> 23:31.710
dispatch

23:31.710 --> 23:32.710
传进去

23:32.710 --> 23:33.710
好

23:33.710 --> 23:34.710
然后这里反回

23:34.710 --> 23:35.710
直接把这个反回

23:35.710 --> 23:36.710
就完手了

23:36.710 --> 23:37.710
就这么简单

23:37.710 --> 23:38.710
我们之前举过例子

23:38.710 --> 23:39.710
我不再举例子了

23:39.710 --> 23:41.710
就说你给我的是一个啥

23:41.710 --> 23:42.710
给我的是一个

23:42.710 --> 23:43.710
x形创建函数

23:43.710 --> 23:44.710
就是这里

23:44.710 --> 23:47.660
你给我的是一个对象

23:47.660 --> 23:49.660
对象里面充满了这种increase

23:50.660 --> 23:51.660
我们看一下之前

23:51.660 --> 23:53.660
好像有个地方好像写了 counter

23:57.660 --> 23:58.660
对

23:58.660 --> 23:59.660
你看这里是不是写的

23:59.660 --> 24:00.660
就这种写法

24:00.660 --> 24:01.660
你给我的是一个

24:01.660 --> 24:02.660
x形创建函数组成的对象

24:02.660 --> 24:03.660
看没

24:03.660 --> 24:04.660
那我直接把这个对象

24:04.660 --> 24:05.660
使用什么

24:05.660 --> 24:06.660
使用band

24:06.660 --> 24:07.660
x形

24:07.660 --> 24:08.660
band

24:08.660 --> 24:09.660
x形creators

24:09.660 --> 24:10.660
得到一个新的对象

24:10.660 --> 24:11.660
一个新的对象里面

24:11.660 --> 24:13.660
每一个都是同名函数

24:13.660 --> 24:14.660
那么调整函数的时候

24:14.660 --> 24:16.660
它会自动的去dispatch

24:17.660 --> 24:18.660
就完了

24:18.660 --> 24:19.660
对不对

24:19.660 --> 24:20.660
就完了

24:20.660 --> 24:21.660
其实也很简单

24:21.660 --> 24:22.660
也很简单

24:22.660 --> 24:24.660
就没啥了

24:24.660 --> 24:25.660
好

24:25.660 --> 24:26.660
那么剩下的事情

24:26.660 --> 24:27.660
就是一些细节

24:27.660 --> 24:28.660
就是一些细节

24:28.660 --> 24:29.660
比方说这个组建

24:29.660 --> 24:31.660
它还有自己的其他属性

24:31.660 --> 24:32.660
对吧

24:32.660 --> 24:33.660
你得把其他属性

24:33.660 --> 24:34.660
给它传过去

24:34.660 --> 24:35.660
对不对

24:35.660 --> 24:36.660
在render的时候

24:36.660 --> 24:38.660
你得把我自己的属性里面

24:38.660 --> 24:40.660
传到其他属性给它传过去

24:40.660 --> 24:42.660
那么这里也很简单

24:42.660 --> 24:43.660
就是说我们从属性里面

24:43.660 --> 24:45.660
属性里面就多了一个什么

24:45.660 --> 24:47.660
属性里面也没多啥

24:47.660 --> 24:49.660
就直接给传过去就完了

24:49.660 --> 24:50.660
直接给传过去就完了

24:50.660 --> 24:51.660
好

24:51.660 --> 24:52.660
咱们来写一下

24:52.660 --> 24:56.170
这里我们用

24:57.170 --> 24:58.170
直接把属性里面

24:58.170 --> 24:59.170
其他额外的属性

24:59.170 --> 25:01.170
额外的属性传给你

25:01.170 --> 25:03.610
直接展开

25:03.610 --> 25:04.610
this props

25:04.610 --> 25:05.610
对吧

25:05.610 --> 25:06.610
直接把额外的属性传给你

25:06.610 --> 25:07.610
就完事了

25:07.610 --> 25:09.610
这个东西都没啥

25:10.610 --> 25:11.610
好

25:11.610 --> 25:12.610
那么之前我们还说

25:12.610 --> 25:13.610
这个什么

25:13.610 --> 25:15.610
map dispatch to props

25:15.610 --> 25:16.610
这个函数里面

25:16.610 --> 25:17.610
还有什么呢

25:17.610 --> 25:18.610
还有第二个函数对吧

25:18.610 --> 25:19.610
第二个函数是属性

25:19.610 --> 25:20.610
那就是this props

25:20.610 --> 25:21.610
我们之前讲过对吧

25:21.610 --> 25:23.610
它可以接受第二个函数

25:23.610 --> 25:24.610
还有这个

25:24.610 --> 25:25.610
map status to props

25:25.610 --> 25:26.610
里面

25:26.610 --> 25:27.610
它也是有第二个函数

25:27.610 --> 25:28.610
this props

25:28.610 --> 25:29.610
对不对

25:29.610 --> 25:30.610
这些都很简单

25:30.610 --> 25:34.300
就完事了

25:35.300 --> 25:36.300
实际上这里

25:36.300 --> 25:38.300
还有一些小的细节

25:38.300 --> 25:39.300
比方说我们这里

25:39.300 --> 25:40.300
就是效率问题

25:40.300 --> 25:41.300
这样子

25:41.300 --> 25:42.300
我们这里

25:42.300 --> 25:43.300
每一次

25:44.300 --> 25:45.300
嗯

25:47.300 --> 25:49.300
每一次重新渲染的时候

25:50.300 --> 25:51.300
重新渲染的时候

25:51.300 --> 25:53.300
我们这里输出这么一句话

25:53.300 --> 25:54.300
就是

25:59.810 --> 26:01.810
感觉空气污染又严重了

26:01.810 --> 26:04.570
好

26:04.570 --> 26:05.570
这里每一次重新渲染的时候

26:05.570 --> 26:06.570
我们输出一句话

26:06.570 --> 26:07.570
就是把那个

26:07.570 --> 26:08.570
temp这个组件

26:08.570 --> 26:10.570
它的display name

26:10.570 --> 26:11.570
重新输出一下

26:11.570 --> 26:12.570
就是我表示了

26:12.570 --> 26:13.570
我重新渲染了

26:13.570 --> 26:14.570
看着

26:14.570 --> 26:16.570
我们这样子写

26:19.460 --> 26:20.460
temp.display name

26:21.460 --> 26:23.460
重新渲染了

26:24.460 --> 26:25.460
写着

26:26.460 --> 26:27.460
重新渲染了

26:27.460 --> 26:28.460
咱们来看一下

26:28.460 --> 26:29.460
看一下

26:29.460 --> 26:30.460
这个效率问题是怎么回事

26:31.460 --> 26:32.460
这里呢

26:32.460 --> 26:33.460
我们在console里面

26:35.460 --> 26:36.460
这个logo主键

26:36.460 --> 26:37.460
我把它去掉了

26:37.460 --> 26:39.460
把logo主键去掉

26:39.460 --> 26:41.460
打印太多也挺烦的

26:41.460 --> 26:43.460
把logo中间键

26:43.460 --> 26:44.460
先暂时的去掉

26:48.300 --> 26:49.300
因为我们之后

26:49.300 --> 26:50.300
会安装一个

26:50.300 --> 26:52.300
安装一个浏览器插件

26:52.300 --> 26:53.300
来搞定

26:53.300 --> 26:54.300
看它的状态变化

26:54.300 --> 26:55.300
那么这里

26:55.300 --> 26:56.300
你看一下一开始

26:58.300 --> 27:00.300
为什么渲染了这么多次

27:00.300 --> 27:01.300
首先看主键结构

27:01.300 --> 27:02.300
这个主键结构

27:02.300 --> 27:03.300
没有什么问题

27:03.300 --> 27:04.300
student search

27:04.300 --> 27:05.300
里面

27:05.300 --> 27:06.300
这是我们的主键

27:06.300 --> 27:07.300
提供数据的主键

27:07.300 --> 27:08.300
然后这个主键里面

27:08.300 --> 27:09.300
连接了很多

27:09.300 --> 27:11.300
每个主键都进行了连接

27:11.300 --> 27:12.300
你看它外面

27:12.300 --> 27:13.300
是不是掏了一个student search bar

27:13.300 --> 27:14.300
对吧

27:14.300 --> 27:15.300
就是我们掏的这个东西

27:15.300 --> 27:17.300
掏的就是我们这个东西

27:17.300 --> 27:18.300
就这个主键

27:18.300 --> 27:19.300
对吧

27:19.300 --> 27:20.300
就这个主键

27:20.300 --> 27:21.300
掏的这个

27:21.300 --> 27:23.300
那么它里面

27:23.300 --> 27:24.300
它里面

27:24.300 --> 27:25.300
是不是掏了一个最终的主键

27:25.300 --> 27:27.300
我们把名字设成一样的

27:27.300 --> 27:28.300
它的官方员

27:28.300 --> 27:29.300
就是这样子设置的

27:29.300 --> 27:30.300
我们也这样设置

27:30.300 --> 27:31.300
student table

27:31.300 --> 27:32.300
你看一下

27:32.300 --> 27:33.300
下面是不是掏了一个student table

27:33.300 --> 27:34.300
对吧

27:34.300 --> 27:36.300
pager 下面掏了一个pager

27:36.300 --> 27:37.300
好

27:37.300 --> 27:38.300
那么这里

27:38.300 --> 27:39.300
我们主要是看一下

27:39.300 --> 27:41.300
它为什么渲染了这么多次

27:42.300 --> 27:43.300
那你想

27:44.300 --> 27:45.300
我们这里的

27:45.300 --> 27:46.300
就是一开始运行的时候

27:46.300 --> 27:48.300
是不是状态导致了多次变化

27:49.300 --> 27:51.300
是不是状态变化了多次

27:52.300 --> 27:53.300
为什么说

27:53.300 --> 27:55.300
状态变化了多次呢

27:55.300 --> 27:56.300
因为

27:56.300 --> 27:58.300
我们最开始的时候

27:58.300 --> 27:59.300
是不是触发了一个什么

27:59.300 --> 28:00.300
fetch student

28:00.300 --> 28:01.300
对吧

28:01.300 --> 28:03.300
触发了这么一个fetch student

28:03.300 --> 28:04.300
你看

28:04.300 --> 28:05.300
是不是触发了这个东西

28:05.300 --> 28:06.300
fetch student

28:06.300 --> 28:07.300
触发了这个过后

28:07.300 --> 28:08.300
它是不是要设置什么

28:08.300 --> 28:09.300
iss loading对吧

28:09.300 --> 28:10.300
设置iss loading的时候

28:10.300 --> 28:11.300
是不是改变了仓库

28:11.300 --> 28:13.300
也改变了仓库呢

28:13.300 --> 28:14.300
那么这些东西

28:14.300 --> 28:15.300
这些主键

28:15.300 --> 28:16.300
全部接受到通知了

28:16.300 --> 28:17.300
就是这些主键

28:17.300 --> 28:19.300
因为他们都订阅了仓库

28:19.300 --> 28:20.300
对吧

28:20.300 --> 28:21.300
对仓库进行了订阅

28:21.300 --> 28:23.300
订阅了仓库的数据变化

28:23.300 --> 28:24.300
那么仓库的数据

28:24.300 --> 28:25.300
哪怕一钉第二变化

28:25.300 --> 28:28.300
那么它也会导致它重新set state

28:28.300 --> 28:30.300
导致它重新渲染

28:30.300 --> 28:32.300
那么这样子效率是不是会出问题

28:32.300 --> 28:34.300
因为你看一下这些东西

28:34.300 --> 28:35.300
我们设置iss loading

28:35.300 --> 28:36.300
跟它有啥关系呢

28:36.300 --> 28:38.300
跟这个表格有啥关系呢

28:38.300 --> 28:39.300
跟这里有啥关系呢

28:39.300 --> 28:41.300
是不是没啥关系

28:41.300 --> 28:43.300
我们希望的这些主键

28:43.300 --> 28:46.300
只有他们需要的数据发生变化

28:46.300 --> 28:48.300
那么他们才重新渲染

28:48.300 --> 28:49.300
不是说仓库里边

28:49.300 --> 28:50.300
仓库里边这么多数据

28:50.300 --> 28:52.300
哪怕你改了一个钉点的数据

28:52.300 --> 28:54.300
它都会导致所有的主键

28:54.300 --> 28:55.300
所有依赖仓库的主键

28:55.300 --> 28:56.300
全部重新渲染

28:56.300 --> 28:57.300
是不是

28:57.300 --> 28:58.300
这个太夸张了

28:58.300 --> 28:59.300
对吧

28:59.300 --> 29:00.300
我们只需要他们呢

29:00.300 --> 29:02.300
这些对于这个主键而言

29:02.300 --> 29:04.300
只有仓库

29:04.300 --> 29:06.300
对

29:06.300 --> 29:11.300
对于temp主键

29:12.300 --> 29:14.300
只有仓库

29:14.300 --> 29:19.300
只有他需要的数据发生

29:19.300 --> 29:21.300
变化时

29:21.300 --> 29:23.300
才会重新渲染

29:23.300 --> 29:25.300
才会重新渲染

29:25.300 --> 29:26.300
其他的情况

29:26.300 --> 29:27.300
我不会重新渲染

29:27.300 --> 29:28.300
那怎么办呢

29:28.300 --> 29:29.300
这一简单

29:29.300 --> 29:33.190
使用pure component

29:33.190 --> 29:34.190
pure component

29:34.190 --> 29:35.190
是不是就是

29:35.190 --> 29:36.190
做这件事情的存主键

29:36.190 --> 29:37.190
对不对

29:37.190 --> 29:38.190
好

29:38.190 --> 29:39.190
那么这里的状态呢

29:39.190 --> 29:40.190
你虽然说我这里

29:40.190 --> 29:41.190
设置的状态

29:41.190 --> 29:43.190
虽然说我这里

29:43.190 --> 29:44.190
在这

29:44.190 --> 29:45.190
虽然说我们这里

29:45.190 --> 29:47.190
重新设置的状态

29:47.190 --> 29:49.190
跑了出来

29:49.190 --> 29:50.190
map to students

29:50.190 --> 29:52.190
在这

29:52.190 --> 29:53.190
set status

29:53.190 --> 29:54.190
虽然说我重新设置的状态

29:54.190 --> 29:55.190
我们又调用这个函数

29:55.190 --> 29:56.190
去映射这个状态

29:56.190 --> 29:57.190
对吧

29:57.190 --> 29:58.190
但是映射的结果

29:58.190 --> 29:59.190
它进行前比较

29:59.190 --> 30:00.190
那你之前比方这个主键

30:00.190 --> 30:02.190
你之前给它的不就是个key

30:02.190 --> 30:03.190
和什么sets

30:03.190 --> 30:04.190
对吧

30:04.190 --> 30:05.190
只要你这个key和sets

30:05.190 --> 30:06.190
没有发生变化

30:06.190 --> 30:07.190
OK

30:07.190 --> 30:08.190
那我这个主键

30:08.190 --> 30:09.190
我就不刷新

30:09.190 --> 30:10.190
不刷新

30:10.190 --> 30:11.190
就这么个意思

30:11.190 --> 30:12.190
就重新设置状态过后

30:12.190 --> 30:13.190
新的状态

30:13.190 --> 30:14.190
新的状态跟之前的状态

30:14.190 --> 30:15.190
还是一样的

30:15.190 --> 30:16.190
我就

30:16.190 --> 30:17.190
我就不会重新选了

30:17.190 --> 30:19.190
我就不会重新运行

30:19.190 --> 30:20.190
这样子起来过后

30:20.190 --> 30:21.190
我们再来看

30:21.190 --> 30:22.190
再来看控制台

30:22.190 --> 30:23.190
你看

30:23.190 --> 30:24.190
现在是不是

30:24.190 --> 30:26.190
情爽多了

30:26.190 --> 30:27.190
对吧

30:27.190 --> 30:28.190
情爽多了

30:28.190 --> 30:29.190
这里呢

30:29.190 --> 30:31.190
肯定是比之前要少很多了

30:31.190 --> 30:32.190
不过你看一下

30:32.190 --> 30:33.190
其实

30:33.190 --> 30:35.190
为什么都还是有重新选了

30:35.190 --> 30:37.190
比方这个students search bar

30:37.190 --> 30:38.190
它的关键值和性别

30:38.190 --> 30:39.190
不是没变化吗

30:39.190 --> 30:41.190
为什么它也重新选了多次呢

30:41.190 --> 30:43.190
这是个主键的问题

30:43.190 --> 30:45.190
这是个主键的问题

30:45.190 --> 30:46.190
为什么呢

30:46.190 --> 30:47.190
它是这样子

30:47.190 --> 30:48.190
我们把这个状态打印出来就知道了

30:48.190 --> 30:49.190
这些sets

30:49.190 --> 30:50.190
这个状态打印出来

30:50.190 --> 30:51.190
保存

30:51.190 --> 30:52.190
你看一下吧

30:52.190 --> 30:53.190
状态打印出来就知道了

30:53.190 --> 30:54.190
我们来关注一下

30:54.190 --> 30:55.190
它为什么会重新选了多次

30:55.190 --> 30:56.190
你看d forks value

30:56.190 --> 30:57.190
它里面key

30:57.190 --> 30:58.190
控制不出来

30:58.190 --> 30:59.190
sets是-1

30:59.190 --> 31:00.190
对吧

31:00.190 --> 31:01.190
没问题

31:01.190 --> 31:02.190
那下一个students search bar

31:02.190 --> 31:03.190
它又重新选了

31:03.190 --> 31:04.190
我们看一下d forks value

31:04.190 --> 31:05.190
没变化呀

31:05.190 --> 31:06.190
为什么重新选了

31:06.190 --> 31:07.190
你要注意

31:07.190 --> 31:08.190
你要注意

31:09.190 --> 31:12.190
我们这个pure component

31:12.190 --> 31:13.190
是不是前比较

31:13.190 --> 31:14.190
对吧

31:14.190 --> 31:15.190
它比较的是

31:15.190 --> 31:17.190
它不会进行深度比较

31:17.190 --> 31:19.190
它进行的是前比较

31:19.190 --> 31:20.190
进行的是前比较

31:20.190 --> 31:22.190
因为你每一次给它的d forks value

31:22.190 --> 31:24.190
所以要说这个对象里边

31:24.190 --> 31:25.190
没问题

31:25.190 --> 31:26.190
但是呢

31:26.190 --> 31:28.190
这个对象是不是发生变化了

31:28.190 --> 31:29.190
对吧

31:29.190 --> 31:30.190
这个对象发生了变化

31:30.190 --> 31:31.190
你看这

31:31.190 --> 31:33.190
跑了去了

31:33.190 --> 31:34.190
跑了去了

31:34.190 --> 31:36.190
这个对象它发生了变化

31:36.190 --> 31:38.190
你看每一次sets data的时候

31:38.190 --> 31:40.190
是不是要重新获得一个新的对象

31:40.190 --> 31:41.190
对吧

31:41.190 --> 31:42.190
这个对象里边

31:42.190 --> 31:43.190
这个属性

31:43.190 --> 31:45.190
maps data to props里边

31:45.190 --> 31:47.190
这个地方

31:47.190 --> 31:49.190
跑了去了

31:49.190 --> 31:50.190
maps data

31:50.190 --> 31:51.190
这里

31:51.190 --> 31:52.190
这里

31:52.190 --> 31:54.190
我们每次给它的是一个新的对象

31:54.190 --> 31:55.190
是这个意思吧

31:55.190 --> 31:56.190
对吧

31:56.190 --> 31:58.190
我们每次给它的是一个新的对象

31:58.190 --> 31:59.190
所以说它这里变化了

31:59.190 --> 32:00.190
这里变化了

32:00.190 --> 32:01.190
导致了这个问题

32:01.190 --> 32:02.190
那么如果说

32:02.190 --> 32:04.190
你要优化这一块的东西的话

32:04.190 --> 32:05.190
那怎么办呢

32:05.190 --> 32:07.190
我们不是我这个connect的问题

32:07.190 --> 32:09.190
我这个connect就是一个pure component

32:09.190 --> 32:10.190
一个存住键

32:10.190 --> 32:11.190
它进行浅度比较

32:11.190 --> 32:13.190
那里边还有一个对象

32:13.190 --> 32:14.190
对象里边东西变了

32:14.190 --> 32:15.190
那我肯定

32:15.190 --> 32:17.190
那我肯定不比较了

32:17.190 --> 32:18.190
我只比较对象的引用

32:18.190 --> 32:19.190
因为它比较的是什么

32:19.190 --> 32:21.190
比较的是这个default value

32:21.190 --> 32:23.190
它的引用地址有没有发生变化

32:23.190 --> 32:25.190
那么它每一次得到的是一个新的对象

32:25.190 --> 32:26.190
它自然发生变化了

32:26.190 --> 32:28.190
所以说这里你要优化的话

32:28.190 --> 32:30.190
你可以在student search bar里边

32:30.190 --> 32:32.190
你可以这个default value

32:32.190 --> 32:34.190
这个default value呢

32:34.190 --> 32:35.190
这样子

32:35.190 --> 32:37.190
你让它这个属性里边

32:37.190 --> 32:39.190
传一个key和传一个sex

32:39.190 --> 32:40.190
就是分开传进来

32:40.190 --> 32:41.190
分开传进来

32:41.190 --> 32:43.190
这里能分开传进来的话

32:43.190 --> 32:47.190
我们就把这个东西来进行覆盖

32:47.190 --> 32:48.190
来进行覆盖

32:48.190 --> 32:50.190
比方说我们这里就可以用这种方式

32:52.190 --> 32:53.190
给它一个新的对象

32:53.190 --> 32:54.190
就是this

32:54.190 --> 32:55.190
就是probs

32:55.190 --> 32:56.190
就this,probs

32:58.190 --> 33:00.190
就是key

33:00.190 --> 33:02.190
等于probs 叫key

33:03.190 --> 33:05.190
然后就是sex

33:06.190 --> 33:08.190
就是我让你的属性

33:08.190 --> 33:10.190
你不要传一个整个对象过来

33:10.190 --> 33:11.190
你分开给我传过来

33:11.190 --> 33:12.190
分开给我传过来

33:12.190 --> 33:14.190
好,那么这边

33:14.190 --> 33:15.190
在这边

33:15.190 --> 33:16.190
那么我们这里

33:16.190 --> 33:18.190
就这样子传

33:18.190 --> 33:19.190
就这样子传

33:19.190 --> 33:21.190
就不要default value那个属性了

33:21.190 --> 33:22.190
这样子传的

33:22.190 --> 33:23.190
保存

33:23.190 --> 33:24.190
你看一下

33:24.190 --> 33:27.190
那现在这个student search bar

33:27.190 --> 33:28.190
是不是只渲染一次的

33:28.190 --> 33:30.190
因为它这里属性是这样子写的

33:30.190 --> 33:31.190
属性是这样子写的

33:31.190 --> 33:33.190
那么这样子属性只要没变

33:33.190 --> 33:34.190
它就不会重新宣传

33:35.190 --> 33:36.190
然后我们再看一下别的

33:36.190 --> 33:38.190
然后这个student table

33:38.190 --> 33:39.190
它重新宣传了两次

33:39.190 --> 33:40.190
这么准确了

33:40.190 --> 33:41.190
这个肯定是正确的

33:41.190 --> 33:43.190
因为一开始它得到的数组是0

33:43.190 --> 33:45.190
是个空数组

33:45.190 --> 33:47.190
然后后面的一个数组长度为10

33:47.190 --> 33:49.190
数组的引用地址发生了变化

33:49.190 --> 33:50.190
那么这里肯定要重新宣传

33:50.190 --> 33:51.190
这个没问题

33:51.190 --> 33:52.190
然后pager

33:52.190 --> 33:53.190
为什么重新宣传了两次呢

33:53.190 --> 33:54.190
你看pager

33:54.190 --> 33:55.190
一开始偷偷为0

33:55.190 --> 33:56.190
后来偷偷为88

33:56.190 --> 33:57.190
找到数据了

33:57.190 --> 33:58.190
对不对

33:58.190 --> 33:59.190
这里宣传了两次

33:59.190 --> 34:00.190
也就这样子

34:00.190 --> 34:01.190
它只要

34:01.190 --> 34:03.190
只有属性发生变化的时候

34:03.190 --> 34:04.190
才会重新宣传

34:04.190 --> 34:05.190
否则的话

34:05.190 --> 34:06.190
它不会重新宣传

34:06.190 --> 34:07.190
对吧

34:07.190 --> 34:08.190
那么楼梯宣传了三次

34:08.190 --> 34:09.190
对吧

34:09.190 --> 34:10.190
没问题吧

34:10.190 --> 34:12.190
然后我们再点击下一页

34:12.190 --> 34:13.190
你看一下

34:13.190 --> 34:14.190
这个sarchy bar

34:14.190 --> 34:16.190
是不是没有重新宣传

34:16.190 --> 34:17.190
对吧

34:17.190 --> 34:18.190
总之呢

34:18.190 --> 34:19.190
我们用pure component

34:19.190 --> 34:21.190
就可以解决这样的一个效率问题

34:24.190 --> 34:26.190
用pure component

34:26.190 --> 34:27.190
就可以解决效率问题

34:27.190 --> 34:28.190
就完了

34:28.190 --> 34:29.190
就写完了

34:29.190 --> 34:30.190
那么这是一种内一样

34:30.190 --> 34:32.190
就是内组件的写法

34:32.190 --> 34:33.190
反而回到是一个内组件

34:33.190 --> 34:35.190
通过内组件来控制的

34:36.190 --> 34:37.190
好

34:37.190 --> 34:38.190
那么这里呢

34:38.190 --> 34:39.190
既然我们之前看到

34:39.190 --> 34:41.190
官方现在的reaction redux

34:41.190 --> 34:42.190
它升级了

34:42.190 --> 34:43.190
升级过后

34:43.190 --> 34:44.190
它现在使用的是

34:44.190 --> 34:46.190
函数组件的那种模式

34:46.190 --> 34:47.190
函数组件的那种模式

34:47.190 --> 34:48.190
来搞定这件事情的

34:48.190 --> 34:50.190
那么我们也可以用函数组件

34:50.190 --> 34:51.190
利用hook

34:51.190 --> 34:52.190
来搞定这件事

34:52.190 --> 34:53.190
好

34:53.190 --> 34:54.190
这里我们复制一下吧

34:54.190 --> 34:55.190
既然有了

34:55.190 --> 34:56.190
我们就写一下吧

34:56.190 --> 34:57.190
其实也不难

34:57.190 --> 34:58.190
因为我们之前的

34:58.190 --> 34:59.190
反回来是一个内组件

34:59.190 --> 35:00.190
对吧

35:00.190 --> 35:01.190
那么现在呢

35:01.190 --> 35:02.190
我们该反回一个函数组件

35:02.190 --> 35:03.190
那么对不对

35:03.190 --> 35:04.190
也就是说我们这里

35:04.190 --> 35:05.190
就把这一块改了

35:05.190 --> 35:07.190
这里之前写的是个内组件

35:07.190 --> 35:08.190
对吧

35:08.190 --> 35:09.190
我们这里呢

35:09.190 --> 35:10.190
现在写个函数组件

35:10.190 --> 35:12.190
写个函数组件

35:12.190 --> 35:14.190
函数组件

35:14.190 --> 35:16.190
那么函数组件呢

35:16.190 --> 35:17.190
用函数组件来搞定这件事

35:17.190 --> 35:19.190
实际上是一样的

35:19.190 --> 35:20.190
来

35:20.190 --> 35:21.190
咱们来看一下

35:21.190 --> 35:22.190
怎么来做

35:22.190 --> 35:24.190
首先这一块的原理

35:24.190 --> 35:25.190
肯定是一样的

35:25.190 --> 35:26.190
我们首先要拿上下文

35:26.190 --> 35:27.190
这个毫无疑问

35:27.190 --> 35:28.190
对不对

35:28.190 --> 35:29.190
肯定要拿到一个上下文

35:29.190 --> 35:30.190
那么这里呢

35:30.190 --> 35:31.190
我们可以利用

35:31.190 --> 35:32.190
把这个取掉了

35:32.190 --> 35:34.190
我们可以利用这个

35:34.190 --> 35:35.190
就是 hook 里面的

35:35.190 --> 35:37.190
就是 use context

35:37.190 --> 35:38.190
对吧

35:38.190 --> 35:40.190
会拿到这个上下文

35:40.190 --> 35:41.190
我们把它保存那个变量

35:41.190 --> 35:42.190
store 里面

35:42.190 --> 35:44.190
就是这里

35:44.190 --> 35:46.190
使用 use context

35:46.190 --> 35:47.190
把 context 传进去

35:47.190 --> 35:49.190
直接拿上下文里面的数据

35:49.190 --> 35:50.190
上下文里面的数据

35:50.190 --> 35:51.190
不就是一个仓库吗

35:51.190 --> 35:52.190
把仓库拿到

35:52.190 --> 35:54.190
从上下文中

35:54.190 --> 35:56.190
拿到仓库

35:56.190 --> 35:57.190
那么最终

35:57.190 --> 35:58.190
然后呢

35:58.190 --> 35:59.190
我们是不是要拿到状态

35:59.190 --> 36:00.190
对吧

36:00.190 --> 36:01.190
要初始化一个状态

36:01.190 --> 36:02.190
我们这里呢

36:02.190 --> 36:03.190
写上这么一个

36:03.190 --> 36:06.190
就是 use effect

36:06.190 --> 36:08.190
use state

36:08.190 --> 36:09.190
好

36:09.190 --> 36:10.190
我们这里呢

36:10.190 --> 36:11.190
要去拿状态

36:11.190 --> 36:12.190
好

36:12.190 --> 36:14.890
这里呢

36:14.890 --> 36:16.890
我们用 use state

36:16.890 --> 36:17.890
好

36:17.890 --> 36:18.890
那么这个状态呢

36:18.890 --> 36:19.890
就是这里呢

36:19.890 --> 36:20.890
初始状态是啥呢

36:20.890 --> 36:21.890
初始状态是啥

36:21.890 --> 36:22.890
初始状态是不是

36:22.890 --> 36:23.890
调用这个函数

36:23.890 --> 36:24.890
拿到了初始状态

36:24.890 --> 36:25.890
对不对

36:25.890 --> 36:26.890
调用这个函数

36:26.890 --> 36:27.890
看一下

36:27.890 --> 36:31.890
map state to props

36:31.890 --> 36:32.890
然后呢

36:32.890 --> 36:33.890
如果说他有值

36:33.890 --> 36:35.890
我们就去调用这个函数

36:35.890 --> 36:37.890
map state to props

36:37.890 --> 36:38.890
把什么传进去

36:38.890 --> 36:40.890
把stone叫get state传进去

36:40.890 --> 36:42.890
对吧

36:42.890 --> 36:44.890
我们把这个仓库里边的

36:44.890 --> 36:45.890
get state传进去

36:45.890 --> 36:46.890
然后呢

36:46.890 --> 36:47.890
拿到这个状态

36:47.890 --> 36:48.890
对不对

36:48.890 --> 36:49.890
把这个状态

36:49.890 --> 36:50.890
就是作为初始值

36:50.890 --> 36:51.890
作为初始值

36:51.890 --> 36:52.890
复制进去

36:52.890 --> 36:53.890
这个状态是不是搞定了

36:53.890 --> 36:54.890
对吧

36:54.890 --> 36:55.890
跟那边是不是一样的

36:55.890 --> 36:56.890
是

36:56.890 --> 36:57.890
如果说他有值

36:57.890 --> 36:58.890
我们就去调用他

36:58.890 --> 36:59.890
拿到状态

36:59.890 --> 37:00.890
对不对

37:00.890 --> 37:01.890
拿到这个状态

37:01.890 --> 37:02.890
就没了

37:02.890 --> 37:03.890
就没了

37:03.890 --> 37:04.890
好

37:04.890 --> 37:05.890
那么接下来

37:05.890 --> 37:06.890
就是状态的变化

37:06.890 --> 37:07.890
状态发生变化

37:07.890 --> 37:08.890
状态发生变化的时候呢

37:08.890 --> 37:10.890
我们只关心这一部分

37:10.890 --> 37:12.890
就它映射出来的状态

37:12.890 --> 37:13.890
发生变化的时候

37:13.890 --> 37:15.890
只关心这一部分

37:15.890 --> 37:16.890
它映射出来的状态

37:16.890 --> 37:17.890
发生变化的时候呢

37:17.890 --> 37:19.890
我们应该怎么做

37:19.890 --> 37:20.890
只关心这一部分

37:20.890 --> 37:22.890
因此呢

37:22.890 --> 37:23.890
因此呢

37:23.890 --> 37:24.890
我们这里

37:24.890 --> 37:25.890
我们可以使用

37:25.890 --> 37:26.890
这么一种模式

37:26.890 --> 37:27.890
就是

37:27.890 --> 37:28.890
跟之前一样

37:28.890 --> 37:30.890
窗户里边变化了

37:30.890 --> 37:31.890
我要说到通知

37:31.890 --> 37:32.890
对吧

37:32.890 --> 37:33.890
我是不是在监听

37:33.890 --> 37:34.890
对不对

37:34.890 --> 37:35.890
去监听窗户变化

37:35.890 --> 37:36.890
不然的话

37:36.890 --> 37:37.890
窗户变化的话

37:37.890 --> 37:38.890
有些同学说

37:38.890 --> 37:40.890
我要不能去用什么User Effect

37:40.890 --> 37:42.890
当然肯定要用这个东西

37:42.890 --> 37:43.890
后面不是写个依赖箱

37:43.890 --> 37:44.890
对不对

37:44.890 --> 37:45.890
依赖箱

37:45.890 --> 37:46.890
哪些数据变了

37:46.890 --> 37:47.890
我就跟着变

37:47.890 --> 37:48.890
但是你要

37:48.890 --> 37:49.890
首先得潜力条件

37:49.890 --> 37:50.890
你在运行这个函数才行

37:50.890 --> 37:51.890
你这个函数都没有运行

37:51.890 --> 37:52.890
那怎么变了

37:52.890 --> 37:53.890
所以说

37:53.890 --> 37:55.890
从去注册去监听一下

37:55.890 --> 37:56.890
去监听一下

37:56.890 --> 37:58.890
监听窗户里边的数据变化

37:58.890 --> 37:59.890
窗户变化的过程

37:59.890 --> 38:00.890
我调整一下

38:00.890 --> 38:01.890
然后导致个函数

38:01.890 --> 38:02.890
重新运行

38:02.890 --> 38:03.890
这才行

38:03.890 --> 38:04.890
这才行

38:04.890 --> 38:05.890
所以说呢

38:05.890 --> 38:06.890
我们这里

38:06.890 --> 38:08.890
要用User Effect

38:08.890 --> 38:10.890
就是一开始去监听

38:10.890 --> 38:11.890
然后这个组件销毁的时候

38:11.890 --> 38:13.890
再把它取消监听

38:13.890 --> 38:14.890
对吧

38:14.890 --> 38:16.890
我们使用User Effect

38:16.890 --> 38:17.890
那么这里

38:17.890 --> 38:18.890
写上这么一个函数

38:18.890 --> 38:20.890
这么一个函数

38:20.890 --> 38:21.890
依赖箱是什么呢

38:21.890 --> 38:22.890
依赖箱

38:22.890 --> 38:24.890
因为只有最开始

38:24.890 --> 38:25.890
才会运行一次

38:25.890 --> 38:27.890
然后最后组件销毁的时候

38:27.890 --> 38:29.890
然后再重新

38:32.890 --> 38:33.890
再把它取消监听

38:33.890 --> 38:34.890
对吧

38:34.890 --> 38:35.890
所以说依赖箱

38:35.890 --> 38:36.890
也可以写个函数数

38:36.890 --> 38:38.890
咱们这里呢

38:38.890 --> 38:39.890
这里怎么办

38:39.890 --> 38:40.890
是不是

38:40.890 --> 38:44.890
当我们去注册一个监听程序

38:44.890 --> 38:46.890
得到一个取消监听函数

38:46.890 --> 38:48.890
然后我们这里写上监听

38:48.890 --> 38:49.890
监听什么

38:49.890 --> 38:50.890
就是Store

38:50.890 --> 38:51.890
第二是什么

38:51.890 --> 38:54.890
sub-script

38:54.890 --> 38:56.890
寄上这么一个监听程序

38:56.890 --> 38:59.890
当仓库的数据发生变化的时候

38:59.890 --> 39:01.890
是不是我们要重新调用一次set state

39:01.890 --> 39:02.890
对吧

39:02.890 --> 39:03.890
set state

39:03.890 --> 39:04.890
那么新的状态是啥呢

39:04.890 --> 39:06.890
新的状态是不是这个玩意儿

39:06.890 --> 39:07.890
对不对

39:07.890 --> 39:08.890
是不是这个玩意儿

39:08.890 --> 39:09.890
这就是新的状态

39:09.890 --> 39:10.890
对吧

39:10.890 --> 39:11.890
这就是新的状态

39:11.890 --> 39:12.890
没问题吧

39:12.890 --> 39:14.890
我们这里可以先得到

39:14.890 --> 39:16.890
得到new state

39:16.890 --> 39:17.890
新的状态

39:17.890 --> 39:18.890
就这个

39:18.890 --> 39:19.890
新的状态就这个

39:19.890 --> 39:20.890
没问题吧

39:20.890 --> 39:21.890
然后把新的状态

39:21.890 --> 39:22.890
设置到状态里边去

39:22.890 --> 39:23.890
就完了

39:23.890 --> 39:24.890
好

39:24.890 --> 39:25.890
这里的报道有警告

39:25.890 --> 39:26.890
他说你这里不要使用

39:26.890 --> 39:27.890
应该依赖Store

39:27.890 --> 39:28.890
使用了Store

39:28.890 --> 39:29.890
无所谓吧

39:29.890 --> 39:30.890
Store反正也是不可辨的

39:30.890 --> 39:31.890
就放这吧

39:31.890 --> 39:32.890
好

39:32.890 --> 39:33.890
那么这里返回啥呢

39:33.890 --> 39:34.890
返回的就是取消监听

39:34.890 --> 39:35.890
就是销毁函数

39:35.890 --> 39:36.890
销毁函数

39:36.890 --> 39:38.890
甚至你可以直接把这个函数的

39:38.890 --> 39:39.890
函数的返回结果返回

39:39.890 --> 39:40.890
是一样的

39:40.890 --> 39:41.890
是一样的

39:41.890 --> 39:43.890
就是逐渐销毁过后的取消监听

39:43.890 --> 39:45.890
因为这个函数返回的就是一个

39:45.890 --> 39:46.890
取消监听的函数

39:46.890 --> 39:47.890
好

39:47.890 --> 39:48.890
那么这样子呢

39:48.890 --> 39:49.890
实现了就是

39:49.890 --> 39:50.890
在一开始的时候

39:50.890 --> 39:51.890
我给他注册一个监听程序

39:51.890 --> 39:52.890
然后呢

39:52.890 --> 39:54.890
反正这个仓库是永远不会变化的

39:54.890 --> 39:55.890
然后呢

39:55.890 --> 39:56.890
我们这里

39:56.890 --> 39:57.890
逐渐注销的时候

39:57.890 --> 39:58.890
逐渐销毁的时候

39:58.890 --> 39:59.890
把这个取消掉

39:59.890 --> 40:00.890
对不对

40:00.890 --> 40:01.890
就实现了监听

40:01.890 --> 40:02.890
效果是不是一样的

40:02.890 --> 40:03.890
好

40:03.890 --> 40:04.890
然后呢

40:04.890 --> 40:05.890
dispatch

40:05.890 --> 40:06.890
dispatch这里呢

40:06.890 --> 40:07.890
我们可以把这个函数复制过来

40:07.890 --> 40:08.890
这个函数复制过来

40:09.890 --> 40:10.890
dispatch的话

40:10.890 --> 40:11.890
把这个函数复制过来

40:11.890 --> 40:12.890
好

40:12.890 --> 40:13.890
那么dispatch的话

40:13.890 --> 40:14.890
我们无非就是得到一个handlers

40:14.890 --> 40:15.890
对吧

40:15.890 --> 40:16.890
好

40:16.890 --> 40:17.890
dispatch这一块

40:17.890 --> 40:19.890
我们这里得到一个handlers

40:20.890 --> 40:21.890
是不是调用这个函数

40:21.890 --> 40:22.890
得到一个对象

40:22.890 --> 40:23.890
对吧

40:23.890 --> 40:24.890
调用这个函数得到一个对象

40:24.890 --> 40:25.890
没问题吧

40:25.890 --> 40:26.890
就调用这个函数

40:26.890 --> 40:27.890
得到一个对象就完事了

40:27.890 --> 40:29.890
得到一个对象就完事了

40:29.890 --> 40:30.890
然后呢

40:30.890 --> 40:31.890
我们这里调用这个函数吧

40:31.890 --> 40:33.890
get event handlers

40:33.890 --> 40:34.890
调用这个函数

40:35.890 --> 40:36.890
得到这么一个对象

40:36.890 --> 40:37.890
好

40:37.890 --> 40:39.890
那么我们把这个对象放到哪呢

40:39.890 --> 40:40.890
当然要前提条件

40:40.890 --> 40:41.890
也可以判断一下

40:41.890 --> 40:44.890
判断那个就是

40:44.890 --> 40:47.890
map dispatch to props

40:47.890 --> 40:48.890
有没有值

40:48.890 --> 40:50.890
如果说有值的话

40:50.890 --> 40:51.890
我们去调用这个

40:52.890 --> 40:53.890
把放在这个变量里面

40:54.890 --> 40:55.890
那么默认情况下

40:55.890 --> 40:56.890
这个变量呢

40:56.890 --> 40:57.890
我们可以复个默认值

40:57.890 --> 40:58.890
handlers

41:00.890 --> 41:01.890
默认情况下

41:01.890 --> 41:02.890
这个变量里面啥都没有

41:03.890 --> 41:04.890
啥都没有

41:04.890 --> 41:05.890
一个空对象

41:05.890 --> 41:06.890
然后呢

41:06.890 --> 41:07.890
如果说这个东西有值的话

41:07.890 --> 41:08.890
那么调用这个函数

41:08.890 --> 41:09.890
我们把这个z一起去掉

41:10.890 --> 41:13.460
调用这个函数

41:13.460 --> 41:14.460
来得到一个

41:14.460 --> 41:15.460
就是处理程序

41:15.460 --> 41:16.460
处理程序的对象

41:16.460 --> 41:17.460
最终呢

41:17.460 --> 41:18.460
我们返回的是一个

41:18.460 --> 41:19.460
comp

41:19.460 --> 41:20.460
一个组件

41:20.460 --> 41:21.460
这个组件呢

41:21.460 --> 41:22.460
要展开什么

41:22.460 --> 41:24.460
展开我的所谓的状态

41:24.460 --> 41:26.460
要展开所谓的handlers

41:26.460 --> 41:27.460
对吧

41:27.460 --> 41:28.460
还要展开

41:28.460 --> 41:29.460
还要展开什么

41:29.460 --> 41:31.460
还要展开那个就是

41:34.460 --> 41:35.460
props

41:35.460 --> 41:36.460
把这些东西全部拿到

41:36.460 --> 41:37.460
全部拿到

41:37.460 --> 41:38.460
这样子

41:38.460 --> 41:39.460
那就写完了

41:39.460 --> 41:40.460
你看一下吧

41:40.460 --> 41:41.460
就已经写完了

41:41.460 --> 41:42.460
已经写完了

41:42.460 --> 41:43.460
保存看一下吧

41:44.460 --> 41:45.460
诶

41:45.460 --> 41:46.460
出问题了

41:46.460 --> 41:47.460
出问题了

41:47.460 --> 41:48.460
我看一下

41:48.460 --> 41:49.460
怎么回事

41:49.460 --> 41:50.460
我这里监听了

41:50.460 --> 41:51.460
监听了

41:51.460 --> 41:52.460
我这里输出一下

41:52.460 --> 41:56.460
仓库数据变化了

41:56.460 --> 41:57.460
输出一下

41:58.460 --> 41:59.460
对了

41:59.460 --> 42:00.460
没问题

42:00.460 --> 42:01.460
保存

42:02.460 --> 42:03.460
诶

42:03.460 --> 42:04.460
我不输出

42:04.460 --> 42:07.470
它就不行

42:07.470 --> 42:08.470
再刷新一下

42:09.470 --> 42:10.470
仓库数据变化了

42:10.470 --> 42:11.470
下一页

42:12.470 --> 42:13.470
下一页

42:13.470 --> 42:14.470
没问题

42:14.470 --> 42:15.470
没问题

42:15.470 --> 42:16.470
诶

42:16.470 --> 42:18.470
为什么我把这个去掉就不行了

42:18.470 --> 42:19.470
是往

42:19.470 --> 42:21.470
这个是请求的导致的吗

42:22.470 --> 42:23.470
然后点击

42:23.470 --> 42:24.470
没问题

42:24.470 --> 42:25.470
没问题

42:25.470 --> 42:26.470
对吧

42:26.470 --> 42:27.470
没问题

42:27.470 --> 42:28.470
好

42:28.470 --> 42:29.470
现在就是效率优化

42:29.470 --> 42:30.470
效率优化

42:30.470 --> 42:31.470
因为我们这里是函数组件

42:31.470 --> 42:32.470
它没有pure component

42:32.470 --> 42:34.470
没有存住件的模式

42:34.470 --> 42:35.470
所以说

42:35.470 --> 42:36.470
效率优化怎么办

42:36.470 --> 42:37.470
效率优化的话

42:37.470 --> 42:39.470
我们需要在这里进行比较

42:39.470 --> 42:41.470
你可以自己手写代码来进行比较

42:41.470 --> 42:42.470
把之前的状态

42:42.470 --> 42:43.470
和新的状态

42:43.470 --> 42:44.470
比较两个是否

42:44.470 --> 42:45.470
是否是一样的

42:45.470 --> 42:46.470
如果说

42:46.470 --> 42:48.470
他们两个是一样的的话

42:48.470 --> 42:49.470
ok

42:49.470 --> 42:50.470
那么我们就不用更新

42:50.470 --> 42:51.470
就不用更新

42:51.470 --> 42:52.470
我们这里写个函数

42:52.470 --> 42:54.470
写个辅助函数来进行比较

42:55.470 --> 42:56.470
compare

42:56.470 --> 42:57.470
compare

42:57.470 --> 42:58.470
你给我一个对象

42:58.470 --> 42:59.470
ob借1

42:59.470 --> 43:00.470
ob借2

43:00.470 --> 43:02.470
我把这两个对象拿来进行前比较

43:02.470 --> 43:03.470
看他们是不是一样的

43:03.470 --> 43:04.470
是不是一样的

43:04.470 --> 43:06.470
怎么来进行前比较了

43:06.470 --> 43:07.470
就非常简单

43:07.470 --> 43:08.470
咱们这里就循环

43:08.470 --> 43:10.470
v1循环

43:10.470 --> 43:11.470
循环什么

43:11.470 --> 43:12.470
ob借1

43:12.470 --> 43:14.470
循环ob借1

43:15.470 --> 43:17.470
循环这个对象的属性

43:19.470 --> 43:21.470
如果说这个对象的属性拿出来

43:21.470 --> 43:23.470
跟对象2的属性进行比较

43:26.470 --> 43:27.470
判断一下

43:27.470 --> 43:28.470
ob借1的t

43:28.470 --> 43:29.470
这个属性

43:29.470 --> 43:32.470
跟ob借2的属性进行比较

43:32.470 --> 43:33.470
如果说两个

43:33.470 --> 43:34.470
两个不相等

43:34.470 --> 43:36.470
只要有一个不相等

43:36.470 --> 43:37.470
说明说比较的结果

43:37.470 --> 43:38.470
就为force

43:38.470 --> 43:40.470
我们就这里写个非常简单的版本

43:41.470 --> 43:42.470
如果全部都相等

43:42.470 --> 43:43.470
返回处

43:43.470 --> 43:44.470
返回处

43:44.470 --> 43:45.470
我们就写上这么一个函数

43:45.470 --> 43:48.470
有了这么一个函数辅助之后

43:48.470 --> 43:49.470
我们在这里就可以调用了

43:49.470 --> 43:51.470
我们再拿到新的状态

43:51.470 --> 43:52.470
然后我们这里

43:52.470 --> 43:54.470
compare之前的状态

43:54.470 --> 43:56.470
和新状态进行比较

43:56.470 --> 43:57.470
进行比较

43:57.470 --> 44:00.470
如果说两个状态都

44:00.470 --> 44:02.470
不相等的情况下

44:02.470 --> 44:03.470
两个状态不相等的情况下

44:03.470 --> 44:04.470
我们再去调用这个

44:04.470 --> 44:05.470
set state

44:05.470 --> 44:06.470
那就完了

44:06.470 --> 44:07.470
这里有什么

44:10.470 --> 44:13.470
他说又缺造了一个enlight state

44:13.470 --> 44:14.470
缺造一个enlight state

44:14.470 --> 44:16.470
我们这里不enlight state

44:16.470 --> 44:18.470
我们这里不能enlight state

44:18.470 --> 44:20.470
这个state是不能enlight的

44:20.470 --> 44:24.470
我们这里干脆给他取消这个警告

44:24.470 --> 44:26.470
我们这里是不能enlight state的

44:26.470 --> 44:27.470
只能enlight这个store

44:27.470 --> 44:29.470
或者说我们什么都不enlight都行

44:29.470 --> 44:32.470
取消这个就是警告

44:32.470 --> 44:35.470
这里我们写上这一句话

44:35.470 --> 44:39.470
就是esnint disabled

44:39.470 --> 44:42.470
直接禁用esnint的检查

44:42.470 --> 44:43.470
就完了

44:43.470 --> 44:45.470
就不会有这个警告了

44:45.470 --> 44:46.470
来测试一下

44:46.470 --> 44:47.470
我们这里输出

44:47.470 --> 44:50.470
输出还是像之前那样子输出

44:50.470 --> 44:52.470
这个主键display name

44:52.470 --> 44:55.470
从渲染了

44:55.470 --> 44:56.470
看一下

44:56.470 --> 44:59.360
保存

44:59.360 --> 45:01.360
出了点问题

45:01.360 --> 45:03.360
其他出现都没什么问题

45:03.360 --> 45:06.360
就这个主键出了点问题

45:06.360 --> 45:08.360
大家明白了

45:08.360 --> 45:10.360
有一个很小很小的细节

45:10.360 --> 45:11.360
大家

45:11.360 --> 45:13.360
我之前也在讲hook的时候

45:13.360 --> 45:14.360
强调过这个细节

45:14.360 --> 45:16.360
就在hook的时候

45:16.360 --> 45:19.360
你尽量使用这个函数里边有的东西

45:19.360 --> 45:21.360
这个函数外边的东西

45:21.360 --> 45:22.360
它会造成一个问题

45:22.360 --> 45:24.360
就是说你不要浪费set state的时候

45:24.360 --> 45:27.360
你不能直接去使用这个state变量

45:27.360 --> 45:28.360
为什么呢

45:28.360 --> 45:30.360
因为你这样子做的话

45:30.360 --> 45:31.360
会造成一个问题

45:31.360 --> 45:33.360
这也是刚才在警告里我都没有注意

45:33.360 --> 45:35.360
刚才在警告的时候都没注意

45:35.360 --> 45:37.360
你不能去直接使用外面这个变量

45:37.360 --> 45:39.360
因为你这里有个必包的现象

45:39.360 --> 45:41.360
我们当时还是特别强调过的

45:41.360 --> 45:42.360
在这个effect里边

45:42.360 --> 45:44.360
你如果去直接使用这个state的话

45:44.360 --> 45:46.360
会导致你这个使用的state

45:46.360 --> 45:47.360
它永远是使用的是

45:47.360 --> 45:51.360
第一次最开始那个state

45:51.360 --> 45:52.360
那么我们来分析一下

45:52.360 --> 45:54.360
最开始的是

45:54.360 --> 45:56.360
isLoading主键

45:56.360 --> 45:57.360
它的秀这个属性

45:57.360 --> 45:58.360
是不是等于force

45:58.360 --> 46:00.360
一开始的等于force

46:00.360 --> 46:01.360
那么现在呢

46:01.360 --> 46:03.360
新的变化成什么了

46:03.360 --> 46:04.360
变化成初了

46:04.360 --> 46:05.360
对吧

46:05.360 --> 46:06.360
所以说它能够显示出来

46:06.360 --> 46:07.360
你看没有

46:07.360 --> 46:09.360
等一下

46:09.360 --> 46:11.360
再保存

46:11.360 --> 46:13.360
刷新

46:13.360 --> 46:14.360
你看

46:14.360 --> 46:15.360
把它变成初了

46:15.360 --> 46:16.360
所以说它能够显示出来

46:16.360 --> 46:18.360
那么下一次再变成force的时候

46:18.360 --> 46:19.360
注意

46:19.360 --> 46:21.360
它跟的是最开始那一次比较

46:21.360 --> 46:23.360
而不是上一次比较

46:23.360 --> 46:24.360
因为这个现象

46:24.360 --> 46:25.360
当时我们强调过这个现象

46:25.360 --> 46:26.360
所以说你这里

46:26.360 --> 46:27.360
set state的时候

46:27.360 --> 46:28.360
如果说你要用到

46:28.360 --> 46:29.360
之前的状态的话

46:29.360 --> 46:31.360
你应该这样子写

46:31.360 --> 46:32.360
应该这样子写再买

46:32.360 --> 46:33.360
set state

46:33.360 --> 46:34.360
这里边要写个函数

46:34.360 --> 46:36.360
这是之前的状态

46:36.360 --> 46:37.360
然后呢

46:37.360 --> 46:38.360
返回的是一个新状态

46:38.360 --> 46:39.360
返回一个新状态

46:39.360 --> 46:41.360
那么返回的新状态的时候

46:41.360 --> 46:42.360
你判断一下

46:42.360 --> 46:43.360
如果说你

46:43.360 --> 46:45.360
如果说compare

46:45.360 --> 46:47.360
如果说之前的状态

46:47.360 --> 46:49.360
和那个新状态

46:49.360 --> 46:50.360
两个是一样的

46:50.360 --> 46:51.360
进行前比较

46:51.360 --> 46:52.360
是一样的

46:52.360 --> 46:53.360
那么我们直接返回

46:53.360 --> 46:54.360
之前的状态

46:54.360 --> 46:56.360
就不用去返回新对象了

46:56.360 --> 46:57.360
那么这样子

46:57.360 --> 46:58.360
由于返回的对象

46:58.360 --> 46:59.360
引用地址一样

46:59.360 --> 47:01.360
它不会重新宣的

47:01.360 --> 47:02.360
l是

47:02.360 --> 47:03.360
不一样的话

47:03.360 --> 47:04.360
我们才返回新状态

47:04.360 --> 47:05.360
new state

47:05.360 --> 47:07.360
我们这样子写

47:07.360 --> 47:09.360
去掉

47:09.360 --> 47:10.360
去掉

47:10.360 --> 47:11.360
这里还是

47:11.360 --> 47:12.360
还有警告

47:12.360 --> 47:13.360
还有警告

47:13.360 --> 47:14.360
他说什么

47:14.360 --> 47:15.360
miss store

47:15.360 --> 47:17.360
加上就行了

47:17.360 --> 47:18.360
刚才也有警告

47:18.360 --> 47:19.360
我都没注意

47:19.360 --> 47:20.360
所以大家还是不要

47:20.360 --> 47:21.360
不要像我刚才那样子的

47:21.360 --> 47:23.360
这种错误的方式

47:23.360 --> 47:24.360
直接忽略警告

47:24.360 --> 47:25.360
好了

47:25.360 --> 47:26.360
就写好了

47:26.360 --> 47:27.360
保存你看一下

47:28.360 --> 47:29.360
这里

47:29.360 --> 47:30.360
存刷新

47:30.360 --> 47:31.360
你看

47:31.360 --> 47:32.360
loading

47:32.360 --> 47:34.360
因为它这个渲染得很快

47:34.360 --> 47:36.360
先从force变成处

47:36.360 --> 47:37.360
然后再从

47:37.360 --> 47:38.360
对

47:38.360 --> 47:40.360
先从force变成处

47:40.360 --> 47:42.360
然后再从处变成force

47:42.360 --> 47:44.360
它为什么又渲染了两次

47:44.360 --> 47:45.360
我们看一下其他的正确了

47:45.360 --> 47:46.360
这个是正确的

47:46.360 --> 47:48.360
table渲染两次正确的

47:48.360 --> 47:49.360
培设了偷偷变化了

47:49.360 --> 47:50.360
渲染两次正确的

47:50.360 --> 47:52.360
那么这个

47:52.360 --> 47:54.360
loading它渲染了三次

47:54.360 --> 47:55.360
就不太正确了

47:55.360 --> 47:57.360
它应该渲染两次才对

47:57.360 --> 47:59.360
loading它应该渲染两次才对

47:59.360 --> 48:01.360
咱们这里把这个set打印出来

48:01.360 --> 48:03.360
打印出来看一下吧

48:03.360 --> 48:05.360
loading

48:05.360 --> 48:08.360
loading先从

48:08.360 --> 48:09.360
loading

48:09.360 --> 48:10.360
loading一开始

48:10.360 --> 48:11.360
第一次渲染的时候是force

48:11.360 --> 48:12.360
对

48:12.360 --> 48:13.360
没问题

48:13.360 --> 48:14.360
然后从force变成处

48:14.360 --> 48:15.360
然后再从处变成force

48:15.360 --> 48:16.360
对

48:16.360 --> 48:17.360
没问题

48:17.360 --> 48:19.360
然后第二页

48:19.360 --> 48:20.360
第三页

48:20.360 --> 48:22.360
是没问题的

48:22.360 --> 48:23.360
就完事了

48:23.360 --> 48:24.360
这是用函数

48:24.360 --> 48:26.360
用互可的方式来做的

48:26.360 --> 48:27.360
其实原理差不多

48:27.360 --> 48:28.360
只不过

48:28.360 --> 48:30.360
不熟悉这个互可这种

48:30.360 --> 48:31.360
API的话

48:31.360 --> 48:32.360
你肯定这理解起来

48:32.360 --> 48:33.360
会有一点困难

48:33.360 --> 48:34.360
没关系

48:34.360 --> 48:36.360
但是你只要能够大概理解

48:36.360 --> 48:38.360
不管你用内组件来做

48:38.360 --> 48:39.360
还是用那个函数组件

48:39.360 --> 48:40.360
用互可来做

48:40.360 --> 48:41.360
只要你理解

48:41.360 --> 48:42.360
它的大部分原理就行了

48:42.360 --> 48:43.360
原理就是

48:43.360 --> 48:44.360
我把这个函数

48:44.360 --> 48:46.360
调整的结果放到我的状态里边

48:46.360 --> 48:48.360
给我的状态挂勾

48:48.360 --> 48:49.360
如果说里变了

48:49.360 --> 48:51.360
那么我重新设置状态

48:51.360 --> 48:52.360
怎么来做呢

48:52.360 --> 48:54.360
具体的做法就是监听

48:54.360 --> 48:55.360
你看在这里

48:55.360 --> 48:56.360
使用监听

48:56.360 --> 48:57.360
监听那个

48:57.360 --> 48:59.360
监听这个仓库里边数据变化

48:59.360 --> 49:00.360
仓库数据变化

49:00.360 --> 49:01.360
我就重新设置状态

49:01.360 --> 49:02.360
那么状态一变

49:02.360 --> 49:03.360
是不是整个数据重新设置了

49:03.360 --> 49:04.360
为了提高效率的话

49:04.360 --> 49:05.360
内组件可以使用

49:05.360 --> 49:06.360
Pure Component

49:06.360 --> 49:08.360
那么这边它就在手动写

49:08.360 --> 49:09.360
手动写前避交

49:09.360 --> 49:10.360
总之呢

49:10.360 --> 49:11.360
就可以完成这些事情

49:13.360 --> 49:14.360
就没了

49:14.360 --> 49:15.360
当然我这里还没有去

49:15.360 --> 49:16.360
做什么REF转发

49:16.360 --> 49:17.360
当然做的话

49:17.360 --> 49:18.360
大家也可以用之前

49:18.360 --> 49:19.360
我们讲REF转发的

49:19.360 --> 49:20.360
只是转发下就完小了

49:20.360 --> 49:21.360
这都是简单

49:21.360 --> 49:22.360
就没啥了

49:22.360 --> 49:23.360
就没啥了

49:23.360 --> 49:24.360
这就是我们

49:24.360 --> 49:26.360
这是对REF当时

49:26.360 --> 49:28.360
库它的原码的分析

49:28.360 --> 49:30.360
基本的原理就是这样子

49:30.360 --> 49:32.360
这是关于这一节和的东西

