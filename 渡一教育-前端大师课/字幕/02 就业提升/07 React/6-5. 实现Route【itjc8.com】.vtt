WEBVTT

00:00.820 --> 00:04.260
咱们继续 现在我们实现了Rotor

00:04.260 --> 00:06.560
那么这一刻咱们来实现Rot

00:06.560 --> 00:08.560
就加上了R去掉

00:08.560 --> 00:10.160
就是来匹配度游的

00:10.160 --> 00:12.720
来匹配度游的 实现了个Rotor组件

00:12.720 --> 00:14.960
我们来首先看一下它是怎么做的

00:14.960 --> 00:16.960
看一下它那个Rotor组件是怎么做的

00:16.960 --> 00:18.460
咱们把这个组织掉

00:18.460 --> 00:20.560
这个复制一个嘛 干脆

00:20.560 --> 00:21.960
复制一个

00:21.960 --> 00:26.960
然后我们这里的导入RxRotor

00:27.400 --> 00:28.800
那么这里呢

00:30.800 --> 00:31.860
也不用管了啊

00:31.860 --> 00:33.360
Rotor这个组件

00:33.360 --> 00:35.000
倒是个Rotor的组件

00:35.000 --> 00:36.600
Rotor的组件呢

00:36.600 --> 00:38.600
我们这里比方说 写两个页面嘛

00:38.600 --> 00:40.100
写两个页面 方可行

00:40.100 --> 00:43.600
配 配级1

00:43.600 --> 00:47.400
Return 配级1

00:47.400 --> 00:51.100
然后呢 方可行 配级2

00:51.100 --> 00:55.100
Return 配级1 配级2

00:55.140 --> 00:56.340
ok 那这里边呢

00:56.340 --> 01:00.840
我们写两个Rotor 写两个Rotor组件

01:00.840 --> 01:03.000
Rotor组件不是有一个属性的pass对吧

01:03.000 --> 01:03.940
pass

01:03.940 --> 01:07.040
然后pass呢 就路径是配级1

01:07.040 --> 01:08.940
然后对应的component呢

01:08.940 --> 01:14.940
component是配级1

01:14.940 --> 01:17.940
这里是配级2

01:17.940 --> 01:19.940
那么下面呢 我为了方便嘛

01:19.940 --> 01:21.940
我给它两个按钮

01:21.940 --> 01:26.680
一个按钮是去配级1

01:26.680 --> 01:32.180
一个按钮是去配级2

01:32.180 --> 01:35.180
去配级2

01:35.180 --> 01:37.680
那问题是我这里怎么去得到history的问题是

01:37.680 --> 01:39.480
这里我拿不到history啊

01:39.480 --> 01:41.680
啊 怎么办了

01:41.680 --> 01:42.580
怎么办了

01:42.580 --> 01:44.080
好 那么我们再写个组件吧

01:44.080 --> 01:45.280
再写个组件

01:45.280 --> 01:47.680
Change

01:47.680 --> 01:48.940
Props

01:48.940 --> 01:49.880
嗯

01:49.880 --> 01:51.880
这里边呢 我们把两个按钮放过来

01:51.880 --> 01:52.880
放过来

01:52.880 --> 01:53.880
把这个DIV放过来

01:55.880 --> 01:56.880
没错

01:56.880 --> 01:59.640
我看一下啊

01:59.640 --> 02:01.640
对 没问题啊 没问题

02:01.640 --> 02:03.640
好 去配级1

02:03.640 --> 02:05.640
配级1的话点击onclick

02:05.640 --> 02:06.640
啊

02:06.640 --> 02:08.640
就是Props

02:08.640 --> 02:09.640
history

02:09.640 --> 02:11.640
我们这里直接解构嘛

02:11.640 --> 02:13.640
解构出history

02:13.640 --> 02:15.640
history

02:15.640 --> 02:17.640
然后呢 点push

02:17.640 --> 02:19.640
push写杠 配级1

02:20.640 --> 02:22.640
然后这个复制一下啊

02:22.640 --> 02:23.640
onclick

02:23.640 --> 02:24.640
去配级2

02:24.640 --> 02:25.640
配级2

02:25.640 --> 02:27.640
好了 我们这里一个迁迹组件

02:27.640 --> 02:29.640
咱们把迁迹组件也写到这

02:29.640 --> 02:30.640
也是放到路由里边

02:30.640 --> 02:32.640
不然的话 它哪来的啊

02:32.640 --> 02:34.640
就是那个商项文的history数据呢

02:34.640 --> 02:35.640
对不对

02:35.640 --> 02:36.640
把它放到路由里边啊

02:36.640 --> 02:37.640
Props呢

02:37.640 --> 02:38.640
只要是写杠

02:38.640 --> 02:39.640
因为我不精确匹配

02:39.640 --> 02:40.640
不精确匹配的话

02:40.640 --> 02:41.640
它任何地址都可以匹配到这个东西

02:41.640 --> 02:42.640
对吧

02:42.640 --> 02:44.640
那么匹配什么Change

02:44.640 --> 02:45.640
Change

02:45.640 --> 02:47.640
好了啊 就完了

02:47.640 --> 02:48.640
就完了

02:48.640 --> 02:49.640
运行出来看一下

02:49.640 --> 02:53.780
运行出来看一下啊

02:53.780 --> 02:55.780
我们主要是看一下那个肉车组件

02:55.780 --> 02:56.780
他做了啥事

02:56.780 --> 02:57.780
去配级1 配级2

02:57.780 --> 02:58.780
你看看

02:58.780 --> 03:00.780
主要是看一下那个肉车组件

03:00.780 --> 03:02.780
他做了啥事

03:02.780 --> 03:05.780
在那个regs里边

03:05.780 --> 03:06.780
我们来看一下吧

03:06.780 --> 03:08.780
这个组件里边呢

03:08.780 --> 03:09.780
你看这是肉车组件

03:09.780 --> 03:10.780
我们之前写的对吧

03:10.780 --> 03:11.780
Rose provider

03:11.780 --> 03:13.780
好 咱们来看肉车组件

03:13.780 --> 03:14.780
肉车组件里边呢

03:14.780 --> 03:15.780
你会发现

03:15.780 --> 03:17.780
它又给你提供了一个玩意

03:17.780 --> 03:18.780
这么一个玩意

03:18.780 --> 03:19.780
看呗

03:19.780 --> 03:20.780
肉车组件

03:20.780 --> 03:21.780
配级1里边

03:21.780 --> 03:22.780
看是不是又提供了一个

03:22.780 --> 03:23.780
它有一个就是

03:23.780 --> 03:24.780
上下文的消费者

03:24.780 --> 03:25.780
抗休门

03:25.780 --> 03:26.780
有一个上下文的

03:26.780 --> 03:27.780
又有一个提供者

03:27.780 --> 03:28.780
它又给你提供了一个

03:28.780 --> 03:30.780
它又给你提供了一个上下文

03:30.780 --> 03:32.780
你看看这个配级2

03:32.780 --> 03:34.780
所以又给你提供了一个上下文

03:34.780 --> 03:35.780
对吧

03:35.780 --> 03:36.780
没问题吧

03:36.780 --> 03:37.780
看呗

03:37.780 --> 03:38.780
它又给你提供了一个上下文

03:38.780 --> 03:39.780
它为什么还要给你提供了一个上下文呢

03:39.780 --> 03:40.780
这个Rote组件

03:40.780 --> 03:41.780
不是已经提供了一个上下文吗

03:41.780 --> 03:42.780
它为什么它里边

03:42.780 --> 03:43.780
肉车组件里边

03:43.780 --> 03:45.780
它又要给你提供一个上下文呢

03:45.780 --> 03:47.780
咱们先把这个问题搞清楚

03:47.780 --> 03:49.780
因为Rote组件里面的上下文

03:49.780 --> 03:50.780
你看看它的march

03:50.780 --> 03:52.780
是不是我们随意写的

03:52.780 --> 03:53.780
对吧

03:53.780 --> 03:54.780
那么Rote组件

03:54.780 --> 03:55.780
它要匹配一个东西

03:55.780 --> 03:56.780
匹配网站过程

03:56.780 --> 03:58.780
是不是得到一个新的匹配对象

03:58.780 --> 03:59.780
对不对

03:59.780 --> 04:00.780
你看这个

04:00.780 --> 04:01.780
它的路径规则是鞋杠配级1

04:01.780 --> 04:02.780
那么它匹配出来

04:02.780 --> 04:03.780
它的匹配对象

04:03.780 --> 04:04.780
是不是跟那个

04:04.780 --> 04:06.780
鞋杠配级2是不是不一样的

04:06.780 --> 04:08.780
那么它为了让后续的就是

04:08.780 --> 04:09.780
它里边的东西

04:09.780 --> 04:10.780
能够获取到

04:10.780 --> 04:11.780
就是

04:11.780 --> 04:13.780
这个新匹配的结果

04:13.780 --> 04:15.780
所以它也必须要提供一个上下文

04:15.780 --> 04:16.780
这个上下文里边

04:16.780 --> 04:18.780
提供这一次匹配的对象

04:18.780 --> 04:19.780
其实呢

04:19.780 --> 04:20.780
History是一样的

04:20.780 --> 04:21.780
location一样的

04:21.780 --> 04:23.780
区别就在于这个march对象

04:23.780 --> 04:24.780
就是march对象不一样

04:24.780 --> 04:25.780
就这个不一样

04:25.780 --> 04:26.780
其他全是一

04:26.780 --> 04:27.780
History一样的

04:27.780 --> 04:28.780
location也是一样的

04:28.780 --> 04:29.780
完全一样的

04:29.780 --> 04:30.780
就是个march不一样

04:30.780 --> 04:32.780
因为Rote组件是用来匹配的

04:32.780 --> 04:33.780
每一个Rote组件

04:33.780 --> 04:35.780
它匹配的结果是不一样的

04:35.780 --> 04:36.780
是不一样的

04:36.780 --> 04:37.780
所以说

04:37.780 --> 04:38.780
为了让后续的组件

04:38.780 --> 04:40.780
就是Rote后边的组件

04:40.780 --> 04:41.780
就是Rote它对应到一个组件

04:41.780 --> 04:43.780
为了让那个组件里边

04:43.780 --> 04:44.780
能够获取到

04:44.780 --> 04:46.780
这个march结果

04:46.780 --> 04:47.780
匹配的结果

04:47.780 --> 04:48.780
所以说它必须要重新

04:48.780 --> 04:49.780
去得到一个march

04:49.780 --> 04:51.780
再重新通过一个上下文

04:51.780 --> 04:52.780
提供给你

04:52.780 --> 04:53.780
所以说是这个意思

04:53.780 --> 04:54.780
因此呢

04:54.780 --> 04:55.780
我们分析得出

04:55.780 --> 04:57.780
这个Rote组件干嘛用的呢

04:57.780 --> 04:58.780
我们在这里写个

04:58.780 --> 04:59.780
Rote组件应该是属于

04:59.780 --> 05:00.780
Ragged Rotor

05:00.780 --> 05:01.780
它是核心功的

05:01.780 --> 05:02.780
Rote组件

05:02.780 --> 05:03.780
这个Rote组件

05:03.780 --> 05:04.780
干嘛用的呢

05:04.780 --> 05:05.780
我们打个注释

05:05.780 --> 05:06.780
它是用于

05:06.780 --> 05:08.780
匹配路由

05:08.780 --> 05:09.780
匹配路由

05:09.780 --> 05:13.780
并将匹配的结果

05:13.780 --> 05:15.780
放入到上下文中

05:15.780 --> 05:17.780
放入到上下文中

05:17.780 --> 05:18.780
它就是做这么一件事

05:18.780 --> 05:20.780
它是用来匹配路由

05:20.780 --> 05:21.780
把路由的匹配结果

05:21.780 --> 05:23.780
放到上下文里边

05:23.780 --> 05:25.780
就做这么一件事

05:25.780 --> 05:26.780
明白的意思吧

05:28.780 --> 05:29.780
好

05:29.780 --> 05:30.780
然后呢

05:30.780 --> 05:31.780
既然我们知道了这一点

05:31.780 --> 05:32.780
那么Rote组件是不是可以写了

05:32.780 --> 05:33.780
看着

05:33.780 --> 05:35.780
RTCRote组件

05:35.780 --> 05:36.780
这个组件呢

05:36.780 --> 05:37.780
我们这里

05:37.780 --> 05:38.780
反复导出

05:38.780 --> 05:39.780
我们在这里

05:39.780 --> 05:40.780
index里面

05:40.780 --> 05:41.780
把这个Rote组件导出

05:43.780 --> 05:45.780
Default

05:45.780 --> 05:46.780
乃至于Rote组件

05:46.780 --> 05:47.780
把这个组件导出

05:47.780 --> 05:48.780
然后呢

05:48.780 --> 05:49.780
为了让外面使用的

05:49.780 --> 05:50.780
使用的起来方便

05:50.780 --> 05:51.780
因为外面

05:51.780 --> 05:52.780
让外面的使用者

05:52.780 --> 05:54.780
不要一会儿从这个裤里面导

05:54.780 --> 05:55.780
一会儿从这个裤里面导

05:55.780 --> 05:56.780
麻烦的

05:56.780 --> 05:57.780
所以在这个裤里面

05:57.780 --> 05:58.780
我们再一次

05:58.780 --> 06:00.780
重新把这个Rote组件导出

06:01.780 --> 06:02.780
这个玩意

06:02.780 --> 06:03.780
就是为了外面用的方便

06:03.780 --> 06:04.780
其他没啥

06:05.780 --> 06:06.780
Ragged Rotor

06:06.780 --> 06:08.780
你把这个什么

06:09.780 --> 06:11.780
导出那个Rote组件

06:12.780 --> 06:14.780
把个Rote组件重新导出

06:14.780 --> 06:15.780
重新导出

06:15.780 --> 06:16.780
对吧

06:16.780 --> 06:17.780
我们就做这么一个处理就行了

06:17.780 --> 06:18.780
那么外面

06:18.780 --> 06:20.780
直接可以在Ragged Rotor洞里面

06:20.780 --> 06:22.780
来去导出这个Rote

06:22.780 --> 06:23.780
导入这个Rote

06:23.780 --> 06:25.780
我先把个结构写好

06:25.780 --> 06:27.780
然后回到Rote这里来

06:27.780 --> 06:28.780
这个Rote

06:28.780 --> 06:29.780
它自身不渲染什么DFV

06:29.780 --> 06:30.780
这些东西

06:30.780 --> 06:31.780
一个不渲染

06:31.780 --> 06:32.780
它主要的目的呢

06:32.780 --> 06:33.780
是做匹配

06:33.780 --> 06:34.780
首先那么来分析一下

06:34.780 --> 06:35.780
Rote组件

06:35.780 --> 06:37.780
是不是里面有很多属性

06:37.780 --> 06:39.780
我们之前学习Rotor的时候

06:39.780 --> 06:41.780
Rote组件里面属性特别特别多

06:41.780 --> 06:42.780
有哪些属性

06:42.780 --> 06:43.780
我们来罗列一下

06:43.780 --> 06:44.780
有哪些属性

06:44.780 --> 06:46.780
有什么Pass属性

06:46.780 --> 06:48.780
有什么Children

06:48.780 --> 06:49.780
有什么

06:49.780 --> 06:50.780
有Render

06:50.780 --> 06:51.780
对不对

06:51.780 --> 06:52.780
有Render属性

06:52.780 --> 06:53.780
还有什么呢

06:53.780 --> 06:54.780
还有什么呢

06:54.780 --> 06:56.780
还有一个Ragged

06:56.780 --> 06:57.780
对不对

06:57.780 --> 06:58.780
还有一个Ragged属性

06:58.780 --> 06:59.780
还有什么呢

06:59.780 --> 07:00.780
还有那个就是

07:00.780 --> 07:02.780
还有Component

07:02.780 --> 07:04.780
Component

07:04.780 --> 07:05.780
还有这个属性

07:05.780 --> 07:06.780
一个Ragged

07:06.780 --> 07:07.780
还有什么Strigged

07:07.780 --> 07:08.780
对吧

07:08.780 --> 07:09.780
是不是严格的

07:09.780 --> 07:10.780
还有Sensitive

07:10.780 --> 07:11.780
是不是大小型敏感的

07:11.780 --> 07:12.780
Sensitive

07:12.780 --> 07:13.780
对不对

07:13.780 --> 07:14.780
是有很多很多的属性

07:14.780 --> 07:15.780
那么这些属性

07:15.780 --> 07:17.780
咱们把它分成两组

07:17.780 --> 07:18.780
第一组呢

07:18.780 --> 07:20.780
是这一部分

07:20.780 --> 07:22.780
这一部分是跟匹配相关的

07:22.780 --> 07:23.780
就是什么

07:23.780 --> 07:25.780
我们的路径规则

07:25.780 --> 07:26.780
我们的

07:26.780 --> 07:27.780
如果匹配成功了

07:27.780 --> 07:29.780
比方说我们要Render渲染函数

07:29.780 --> 07:30.780
比方说

07:30.780 --> 07:32.780
无论有没有匹配

07:32.780 --> 07:33.780
我们都是要Children

07:33.780 --> 07:34.780
还有什么呢

07:34.780 --> 07:35.780
我们对应的Component

07:35.780 --> 07:36.780
对吧

07:36.780 --> 07:37.780
都是匹配成功之后

07:37.780 --> 07:38.780
我们要干嘛

07:38.780 --> 07:39.780
以及匹配规则

07:39.780 --> 07:41.780
另外一部分呢

07:41.780 --> 07:43.780
是不是匹配对象的配置

07:43.780 --> 07:45.780
我们回顾一下

07:45.780 --> 07:46.780
另外一部分

07:46.780 --> 07:47.780
一个Ragged

07:47.780 --> 07:48.780
Strigged

07:48.780 --> 07:49.780
Sensitive

07:49.780 --> 07:50.780
就是如何去匹配

07:50.780 --> 07:51.780
如何去匹配

07:51.780 --> 07:52.780
是不是匹配

07:52.780 --> 07:53.780
到时候我们

07:53.780 --> 07:54.780
调用March Pass的时候

07:54.780 --> 07:55.780
它不是有配置吗

07:55.780 --> 07:56.780
这个配置里面

07:56.780 --> 07:57.780
我们看一下

07:57.780 --> 07:58.780
之前是咋写的

07:58.780 --> 07:59.780
配置里面

07:59.780 --> 08:00.780
不就是三个属性吗

08:00.780 --> 08:01.780
一个Ragged

08:01.780 --> 08:02.780
Sensitive

08:02.780 --> 08:03.780
这个配置对象

08:03.780 --> 08:05.780
那么剩下的部分

08:05.780 --> 08:06.780
关于配置的

08:06.780 --> 08:08.780
就是我们匹配的时候

08:08.780 --> 08:10.780
如何用合众方式去匹配

08:10.780 --> 08:11.780
它的一些配置

08:11.780 --> 08:12.780
没问题吧

08:12.780 --> 08:13.780
好

08:13.780 --> 08:14.780
咱们这个Rotor里面

08:14.780 --> 08:15.780
它有这么多属性

08:15.780 --> 08:16.780
对吧

08:16.780 --> 08:17.780
OK

08:17.780 --> 08:18.780
我们现在来一个一个规定一下

08:18.780 --> 08:20.780
规定一下这些属性

08:20.780 --> 08:21.780
好

08:21.780 --> 08:22.780
这里我们

08:22.780 --> 08:26.780
导入PropTaps

08:26.780 --> 08:29.780
PropRagged

08:30.780 --> 08:32.780
PropPaps

08:32.780 --> 08:33.780
导入进来

08:33.780 --> 08:34.780
那么约束一下

08:34.780 --> 08:35.780
约束一下

08:35.780 --> 08:36.780
Static

08:36.780 --> 08:37.780
约束一下这个什么呢

08:37.780 --> 08:40.780
这个就是PropTaps

08:40.780 --> 08:41.780
小写的

08:41.780 --> 08:45.780
PropTaps

08:45.780 --> 08:46.780
有哪些属性呢

08:46.780 --> 08:47.780
在哪里

08:47.780 --> 08:48.780
有Pass

08:48.780 --> 08:50.780
Pass这个属性

08:50.780 --> 08:51.780
Pass这个属性

08:51.780 --> 08:52.780
它必须是一个什么类型呢

08:52.780 --> 08:54.780
Pass个属性

08:54.780 --> 08:56.780
它可以是一个

08:56.780 --> 08:57.780
数组

08:57.780 --> 08:58.780
因为匹配规则里面

08:58.780 --> 08:59.780
是可以是数组的

08:59.780 --> 09:00.780
这个是可以是数组的

09:00.780 --> 09:01.780
也可以

09:01.780 --> 09:02.780
当然是个字符则的数组

09:02.780 --> 09:03.780
也可以是一个字符则

09:03.780 --> 09:05.780
所以它的类型PropTaps

09:05.780 --> 09:06.780
是一个字符则

09:06.780 --> 09:08.780
或者是

09:08.780 --> 09:09.780
不能用这种方式

09:09.780 --> 09:11.780
应该是用OneOf

09:11.780 --> 09:12.780
OneOf

09:12.780 --> 09:14.780
就是其中一个

09:14.780 --> 09:15.780
其中一个

09:17.780 --> 09:18.780
其中一个

09:18.780 --> 09:20.780
要么是字符则

09:20.780 --> 09:22.780
要么是字符则

09:22.780 --> 09:24.780
要么是什么呢

09:24.780 --> 09:26.780
是PropTaps

09:26.780 --> 09:28.780
要么是字符则数组

09:28.780 --> 09:30.780
就是ArrayEr

09:30.780 --> 09:31.780
ArrayEr

09:31.780 --> 09:33.780
PropTaps

09:33.780 --> 09:34.780
总之呢

09:34.780 --> 09:35.780
是一个数组

09:35.780 --> 09:36.780
算了我感觉有点难得写

09:36.780 --> 09:37.780
难得写

09:37.780 --> 09:38.780
算了我不想写这个

09:38.780 --> 09:39.780
你们要写自己写吧

09:39.780 --> 09:40.780
我不想写

09:40.780 --> 09:41.780
好麻烦啊

09:41.780 --> 09:42.780
感觉

09:42.780 --> 09:43.780
好麻烦

09:43.780 --> 09:44.780
咱们打注尸嘛

09:44.780 --> 09:45.780
打注尸得了

09:45.780 --> 09:47.780
一共有这么一些属性

09:47.780 --> 09:48.780
这么一些属性

09:48.780 --> 09:50.780
打个注尸在这里

09:50.780 --> 09:55.160
这些属性

09:55.160 --> 09:56.160
感觉好麻烦

09:57.160 --> 09:59.160
这些体内活里面自己搞定啊

09:59.160 --> 10:00.160
这是

10:00.160 --> 10:01.160
就是规则

10:01.160 --> 10:02.160
路径规则

10:02.160 --> 10:04.160
可以是字符则

10:04.160 --> 10:06.160
可以是字符则数组

10:06.160 --> 10:07.160
无所谓

10:07.160 --> 10:08.160
反正那你给我规则就行了

10:08.160 --> 10:09.160
反正

10:09.160 --> 10:10.160
怎么去匹配

10:10.160 --> 10:12.160
我们是调用这个

10:12.160 --> 10:13.160
使用的是第三方库

10:13.160 --> 10:14.160
他去帮我们搞定的

10:14.160 --> 10:15.160
我也不管

10:15.160 --> 10:17.160
好企务准的就是

10:17.160 --> 10:19.160
渲染的就是

10:19.160 --> 10:21.160
企务准的就是

10:21.160 --> 10:23.160
无论

10:23.160 --> 10:25.160
是否匹配

10:25.160 --> 10:28.160
都应该渲染的

10:28.160 --> 10:30.160
支援数

10:30.160 --> 10:31.160
好

10:31.160 --> 10:33.160
轮到了就是匹配成功后

10:33.160 --> 10:35.160
匹配成功后

10:35.160 --> 10:38.160
渲染的支援数

10:38.160 --> 10:40.160
渲染的函数

10:40.160 --> 10:42.160
渲染函数

10:42.160 --> 10:45.160
他们好认识的就是匹配成功后

10:45.160 --> 10:47.160
匹配成功后

10:47.160 --> 10:49.160
然后呢

10:49.160 --> 10:51.160
渲染的组件

10:51.160 --> 10:53.160
这三个弹数都是用来渲染的

10:53.160 --> 10:54.160
都是用来渲染的

10:54.160 --> 10:56.160
他们的优先级是这样子

10:56.160 --> 10:57.160
如果你配置到企务准过后

10:57.160 --> 10:58.160
这两个都无效了

10:58.160 --> 10:59.160
这两个就无效了

10:59.160 --> 11:01.160
如果你没有配置企务准

11:01.160 --> 11:02.160
但是配置到Render过后

11:02.160 --> 11:03.160
Render的优先级次值

11:03.160 --> 11:04.160
它会调用Render

11:04.160 --> 11:06.160
忽略掉component

11:06.160 --> 11:08.160
如果说前两个都没有配置的话

11:08.160 --> 11:09.160
component很生销

11:09.160 --> 11:10.160
那么后边几个呢

11:10.160 --> 11:12.160
后边几个就是以下

11:12.160 --> 11:13.160
是

11:13.160 --> 11:16.160
调用那个march

11:16.160 --> 11:17.160
march

11:17.160 --> 11:18.160
pass

11:18.160 --> 11:19.160
方法

11:19.160 --> 11:20.160
使

11:20.160 --> 11:21.160
的配置

11:21.160 --> 11:23.160
是调用那个march

11:23.160 --> 11:25.160
pass这个方法的使得配置

11:25.160 --> 11:27.160
调用这个使得配置

11:27.160 --> 11:28.160
没了

11:28.160 --> 11:29.160
没了

11:29.160 --> 11:30.160
就这么一些属性

11:30.160 --> 11:31.160
就这么一些属性

11:31.160 --> 11:32.160
好

11:32.160 --> 11:33.160
那么接下来

11:33.160 --> 11:34.160
就还是渲染

11:34.160 --> 11:35.160
我们来想渲染

11:35.160 --> 11:37.160
渲染是干嘛

11:37.160 --> 11:38.160
要干嘛

11:38.160 --> 11:40.160
渲染的时候干嘛

11:40.160 --> 11:42.160
渲染的时候是不是要决定

11:42.160 --> 11:44.160
你到底有没有匹配成功

11:44.160 --> 11:45.160
对不对

11:45.160 --> 11:46.160
是不是要决定这个东西

11:46.160 --> 11:47.160
你到底有没有

11:47.160 --> 11:48.160
因为匹配成功

11:48.160 --> 11:50.160
因为我们这里要提供一个上下文

11:50.160 --> 11:52.160
它一定要会提供一个上下文的

11:52.160 --> 11:53.160
对吧

11:53.160 --> 11:54.160
它会提供一个上下文

11:54.160 --> 11:55.160
那么这个上下文是不是

11:55.160 --> 11:56.160
提供了上下文过后

11:56.160 --> 11:58.160
前两个属性都没变化

11:58.160 --> 11:59.160
什么history

11:59.160 --> 12:01.160
location是不是都没变化

12:01.160 --> 12:02.160
只有这个march对象变化了

12:02.160 --> 12:04.160
那么我们是不是要得到

12:04.160 --> 12:06.160
它的march

12:06.160 --> 12:08.160
它到底有没有匹配成功

12:08.160 --> 12:10.160
是这个意思吧

12:10.160 --> 12:11.160
没问题吧

12:11.160 --> 12:12.160
那这个上下文里面的march

12:12.160 --> 12:13.160
是不是要得到

12:13.160 --> 12:14.160
它到底有没有匹配成功

12:14.160 --> 12:15.160
所以说呢

12:15.160 --> 12:16.160
这个render里面

12:16.160 --> 12:17.160
我们干嘛呢

12:17.160 --> 12:18.160
我们

12:18.160 --> 12:20.160
就是一个

12:20.160 --> 12:21.160
得到了就是那个

12:21.160 --> 12:22.160
上下文

12:22.160 --> 12:24.160
我们用concumer嘛

12:24.160 --> 12:26.160
把上下文导入进来

12:26.160 --> 12:28.160
就是导入那个

12:28.160 --> 12:30.160
rotor context

12:30.160 --> 12:32.160
from

12:32.160 --> 12:33.160
rotor context

12:33.160 --> 12:35.160
导入这个上下文

12:35.160 --> 12:36.160
那么这里呢

12:36.160 --> 12:37.160
我们使用

12:37.160 --> 12:39.160
这里CTX嘛

12:39.160 --> 12:40.160
简单一点

12:40.160 --> 12:41.160
这里呢

12:41.160 --> 12:43.160
就是一个ctx

12:43.160 --> 12:46.160
ctx concumer

12:46.160 --> 12:47.160
对吧

12:47.160 --> 12:49.160
上下文的消费者

12:49.160 --> 12:52.110
就是一个

12:52.110 --> 12:54.110
上下文的消费者

12:54.110 --> 12:55.110
那么这里边

12:55.110 --> 12:56.110
我们还记得嘛

12:56.110 --> 12:57.110
上下文的

12:57.110 --> 12:58.110
写的那个concumer过后

12:58.110 --> 12:59.110
里边要写啥

12:59.110 --> 13:00.110
是不是要写个函数

13:00.110 --> 13:01.110
它会把上下文的值

13:01.110 --> 13:02.110
告诉你

13:02.110 --> 13:03.110
对不对

13:03.110 --> 13:04.110
那么你IU先确认

13:04.110 --> 13:05.110
它就确认啥

13:05.110 --> 13:06.110
比方说我们这里

13:06.110 --> 13:07.110
输出一个value

13:07.110 --> 13:08.110
你看一下吧

13:08.110 --> 13:09.110
保存

13:09.110 --> 13:10.110
这里面

13:10.110 --> 13:11.110
app里边

13:11.110 --> 13:12.110
我们把这个复制一下

13:12.110 --> 13:14.110
这个地方复制过来

13:16.110 --> 13:17.110
我这样吧

13:17.110 --> 13:18.110
我这样

13:19.110 --> 13:20.110
我把这个代码

13:20.110 --> 13:22.110
直接把这个地方改成

13:22.110 --> 13:24.110
第二鞋杠

13:24.110 --> 13:25.110
其他都不可以变

13:25.110 --> 13:26.110
保存

13:26.110 --> 13:27.110
现在看不到任何效果

13:27.110 --> 13:29.110
因为我们现在功能还没有实现

13:29.110 --> 13:30.110
但是我们看一个组件结构

13:30.110 --> 13:31.110
保存Rotor里面

13:31.110 --> 13:32.110
Rotor里面

13:32.110 --> 13:33.110
是不是加了一些Rotor组件了

13:33.110 --> 13:34.110
每个Rotor组件

13:34.110 --> 13:35.110
是不是一个concumer

13:35.110 --> 13:36.110
对吧

13:36.110 --> 13:37.110
里边是不是写了个函数

13:37.110 --> 13:38.110
每个Rotor组件

13:38.110 --> 13:39.110
是不是写了一个函数

13:39.110 --> 13:40.110
对吧

13:40.110 --> 13:42.110
concumer里面一个函数

13:42.110 --> 13:43.110
那你看

13:43.110 --> 13:44.110
是不是拿到了

13:44.110 --> 13:45.110
每个Rotor组件

13:45.110 --> 13:47.110
都是拿到上下文里边的数据了

13:47.110 --> 13:48.110
是吧

13:48.110 --> 13:49.110
他拿到了上下文里边的数据

13:49.110 --> 13:50.110
看到没

13:51.110 --> 13:52.110
那么上下文里的数据

13:52.110 --> 13:53.110
大部分没有什么变化

13:53.110 --> 13:55.110
就有一个地方有变化

13:55.110 --> 13:56.110
因为我们这里最终

13:56.110 --> 13:57.110
要渲染的是啥呢

13:57.110 --> 13:58.110
要返回的

13:59.110 --> 14:00.110
这个地方要返回的是啥

14:00.110 --> 14:01.110
返回的

14:01.110 --> 14:02.110
是不是又要返回一个

14:02.110 --> 14:03.110
provider

14:03.110 --> 14:04.110
对不对

14:04.110 --> 14:05.110
又要提供一个上下文

14:05.110 --> 14:06.110
那么这个上下文里边

14:06.110 --> 14:07.110
这个value

14:09.110 --> 14:10.110
上下文里边

14:10.110 --> 14:11.110
它的数据

14:11.110 --> 14:13.110
其他的都没有变化

14:13.110 --> 14:14.110
其他的都没变化

14:14.110 --> 14:15.110
比方说我们这里

14:15.110 --> 14:16.110
也用一个对象

14:16.110 --> 14:17.110
也用一个对象

14:17.110 --> 14:18.110
叫ctxvalue

14:19.110 --> 14:20.110
也用一个对象

14:20.110 --> 14:22.110
保持对象的引用地址唯一

14:22.110 --> 14:24.110
这也是叫ctx

14:25.110 --> 14:26.110
这里吧

14:26.110 --> 14:27.110
我们来这里

14:28.110 --> 14:29.110
这个函数里边写

14:29.110 --> 14:30.110
ctxvalue

14:31.110 --> 14:32.110
第二

14:32.110 --> 14:34.110
它的就是history

14:34.110 --> 14:35.110
history

14:35.110 --> 14:36.110
等于什么

14:36.110 --> 14:40.110
等于value.history

14:40.110 --> 14:42.110
history不变

14:42.110 --> 14:45.110
然后ctx location

14:45.110 --> 14:47.110
value.location

14:47.110 --> 14:49.110
这个location也不会发生变化

14:49.110 --> 14:51.110
就一个东西变了

14:51.110 --> 14:52.110
就一个东西变了

14:52.110 --> 14:54.110
这里肯定就是写的是

14:54.110 --> 14:56.110
this.ctxvalue

14:56.110 --> 14:57.110
对吧

14:57.110 --> 14:58.110
什么东西变了

14:58.110 --> 15:00.110
就是一个march变了

15:00.110 --> 15:02.110
除了其他都没变

15:02.110 --> 15:03.110
都没有变

15:03.110 --> 15:04.110
就一个march变了

15:04.110 --> 15:06.110
ctxvalue

15:06.110 --> 15:08.110
叫什么march

15:08.110 --> 15:09.110
就这个对象变了

15:09.110 --> 15:10.110
这个对象

15:10.110 --> 15:11.110
怎么来

15:11.110 --> 15:12.110
是不是要重新获取

15:12.110 --> 15:13.110
对吧

15:13.110 --> 15:14.110
是不是要重新获取这个对象

15:14.110 --> 15:15.110
没问题吧

15:15.110 --> 15:16.110
好

15:16.110 --> 15:18.110
那么重新获取这个对象

15:18.110 --> 15:19.110
那么我们是不是又要用这个函数

15:19.110 --> 15:20.110
import

15:20.110 --> 15:21.110
哪个函数

15:22.110 --> 15:24.110
march

15:24.110 --> 15:25.110
pass

15:25.110 --> 15:26.110
from

15:26.110 --> 15:27.110
写上

15:27.110 --> 15:28.110
marchpass

15:28.110 --> 15:30.110
所以要用这个函数

15:30.110 --> 15:31.110
对不对

15:31.110 --> 15:32.110
那么这里呢

15:32.110 --> 15:33.110
就是来匹配

15:33.110 --> 15:34.110
来进行匹配

15:34.110 --> 15:35.110
那么看一下能不能匹配

15:35.110 --> 15:36.110
能匹配的话

15:36.110 --> 15:37.110
我就把

15:37.110 --> 15:38.110
渲染出来

15:39.110 --> 15:41.110
那么得到这个march对象

15:41.110 --> 15:42.110
我们也可以在这里

15:42.110 --> 15:43.110
专门来写一个函数

15:43.110 --> 15:45.110
在这里来专门来写一个函数

15:45.110 --> 15:47.110
就是写这么一个函数

15:47.110 --> 15:49.110
来得到一个march对象

15:49.110 --> 15:50.110
得到march对象

15:50.110 --> 15:51.110
就是给它取个名字

15:51.110 --> 15:53.110
就是march

15:53.110 --> 15:55.110
road

15:55.110 --> 15:57.110
march road

15:57.110 --> 15:59.110
来得到这个march对象

15:59.110 --> 16:00.110
你给我一个啥呢

16:00.110 --> 16:03.110
给我一个就是location

16:03.110 --> 16:05.110
给我一个location对象

16:05.110 --> 16:08.110
然后我给你返回一个march对象

16:10.110 --> 16:12.110
根据指定的location对象

16:14.110 --> 16:15.110
对象

16:15.110 --> 16:16.110
返回

16:16.110 --> 16:17.110
march对象

16:17.110 --> 16:18.110
当然

16:18.110 --> 16:19.110
如果没有匹配成功

16:19.110 --> 16:20.110
返回就是now

16:20.110 --> 16:21.110
对吧

16:21.110 --> 16:22.110
返回就是now

16:22.110 --> 16:23.110
好 那么就完了

16:23.110 --> 16:24.110
那么这里边

16:24.110 --> 16:25.110
我们这里就可以调用什么

16:25.110 --> 16:27.110
thismarchroad

16:27.110 --> 16:28.110
调用这个方法

16:28.110 --> 16:29.110
是不是得到march对象

16:29.110 --> 16:30.110
来放进来

16:30.110 --> 16:31.110
好 那么现在我们实现

16:31.110 --> 16:32.110
这个方法就行了

16:32.110 --> 16:33.110
那么这个方法怎么实现呢

16:33.110 --> 16:34.110
我们最终是要调用它

16:34.110 --> 16:35.110
marchpass

16:35.110 --> 16:37.110
直接要调用它

16:37.110 --> 16:38.110
好

16:38.110 --> 16:39.110
marchpass里边

16:39.110 --> 16:41.110
它有很多参数要选择

16:41.110 --> 16:42.110
一个来吧

16:42.110 --> 16:43.110
marchpass路径

16:43.110 --> 16:45.110
路径规则是不是来自于属性

16:45.110 --> 16:46.110
对不对

16:46.110 --> 16:48.110
来自于属性的路径规则pass

16:48.110 --> 16:49.110
对吧

16:49.110 --> 16:50.110
没问题吧

16:50.110 --> 16:53.110
来自于属性的路径规则pass

16:53.110 --> 16:54.110
好

16:54.110 --> 16:55.110
然后呢是passname

16:55.110 --> 16:56.110
就是真实的地址

16:56.110 --> 16:58.110
真实的地址是不是来自于location

16:58.110 --> 17:00.110
location里边的什么

17:00.110 --> 17:02.110
passname

17:02.110 --> 17:04.110
好 后面是options

17:04.110 --> 17:06.110
options的话

17:06.110 --> 17:07.110
那么是不是来自于

17:07.110 --> 17:09.110
那个就是

17:09.110 --> 17:11.110
来自于属性里边的东西

17:11.110 --> 17:13.110
来自于属性里边的这三个属性值

17:13.110 --> 17:14.110
对不对

17:14.110 --> 17:15.110
来自于这三个属性值

17:15.110 --> 17:16.110
咱们从属性里边

17:16.110 --> 17:18.110
把这三个属性值解构出来

17:18.110 --> 17:19.110
解构出来

17:19.110 --> 17:21.110
从属性里边解构出来

17:21.110 --> 17:23.110
and this probes

17:23.110 --> 17:25.110
从属性里边把它解构出来

17:25.110 --> 17:27.110
一个是exact

17:27.110 --> 17:28.110
给它个model值嘛

17:28.110 --> 17:29.110
model值为force

17:29.110 --> 17:30.110
strict

17:30.110 --> 17:32.110
model值为force

17:32.110 --> 17:33.110
sensitive

17:33.110 --> 17:35.110
model值为force

17:35.110 --> 17:36.110
把它解构出来

17:36.110 --> 17:37.110
好 那么这里

17:37.110 --> 17:38.110
后面的参数配置

17:38.110 --> 17:39.110
配置的话

17:39.110 --> 17:40.110
这三个传过去就完了

17:40.110 --> 17:41.110
一个是exact

17:41.110 --> 17:42.110
这个是strict

17:42.110 --> 17:43.110
还有什么

17:43.110 --> 17:45.110
还有sensitive

17:45.110 --> 17:47.110
对不对

17:47.110 --> 17:49.110
最终的目标是要得到pass

17:49.110 --> 17:50.110
跟march对象

17:50.110 --> 17:52.110
因为我要把march对象放到哪儿了

17:52.110 --> 17:54.110
我要把march对象放到哪儿

17:54.110 --> 17:55.110
放到上下文里边

17:55.110 --> 17:56.110
对吧

17:56.110 --> 17:57.110
我要让后边的指节点

17:57.110 --> 17:59.110
知道我跟上下文里边

17:59.110 --> 18:01.110
它之前的匹配结果是怎么样的

18:01.110 --> 18:02.110
不管我怎么渲染吧

18:02.110 --> 18:03.110
我要让你知道

18:03.110 --> 18:04.110
我之前是怎么匹配的

18:04.110 --> 18:06.110
匹配结果是怎么样的

18:06.110 --> 18:07.110
我要让你知道

18:07.110 --> 18:09.110
那么我们通过这个函数

18:09.110 --> 18:12.110
就可以得到这么一个march对象

18:12.110 --> 18:13.110
可以得到这么一个march对象

18:13.110 --> 18:14.110
就完了

18:14.110 --> 18:15.110
保存你看一下

18:15.110 --> 18:17.110
现在别的

18:17.110 --> 18:21.110
I cannot rate the property pass name of undefend

18:21.110 --> 18:24.110
我这里没有传递那个location

18:24.110 --> 18:28.110
就是value.location

18:28.110 --> 18:30.110
传进去

18:30.110 --> 18:32.110
现在我别的不说

18:32.110 --> 18:33.110
至少我上下文的数据

18:33.110 --> 18:34.110
我给你提供了

18:34.110 --> 18:35.110
我先不说什么渲染

18:35.110 --> 18:36.110
渲染的问题

18:36.110 --> 18:37.110
我们之后再说慢慢来

18:37.110 --> 18:38.110
但是我发现我一个

18:38.110 --> 18:39.110
上下文里边的东西

18:39.110 --> 18:40.110
我给你提供了

18:40.110 --> 18:41.110
至少这个没问题了

18:41.110 --> 18:42.110
我给你提供了一个

18:42.110 --> 18:43.110
上下文的东西了

18:43.110 --> 18:44.110
看没

18:44.110 --> 18:45.110
march

18:45.110 --> 18:46.110
第一个是不是

18:46.110 --> 18:47.110
现在配G2

18:47.110 --> 18:48.110
第一个没有匹配到

18:48.110 --> 18:49.110
march没有匹配到

18:49.110 --> 18:50.110
那么第二个

18:50.110 --> 18:51.110
所以匹配到了

18:51.110 --> 18:52.110
march

18:52.110 --> 18:53.110
你看一下march是为匹配到了

18:53.110 --> 18:54.110
对吧

18:54.110 --> 18:55.110
一个zx2

18:55.110 --> 18:56.110
是为匹配到了

18:56.110 --> 18:57.110
那么斜杠有没有匹配到了

18:57.110 --> 18:58.110
斜杠

18:58.110 --> 18:59.110
是不是有匹配到了

18:59.110 --> 19:00.110
对吧

19:00.110 --> 19:01.110
有匹配到了

19:01.110 --> 19:02.110
一个zx是with force

19:02.110 --> 19:03.110
对不对

19:03.110 --> 19:04.110
但是没有精确匹配

19:04.110 --> 19:05.110
但是匹配到了

19:05.110 --> 19:06.110
没问题吧

19:06.110 --> 19:07.110
那我们现在

19:07.110 --> 19:08.110
也能实现了什么了

19:08.110 --> 19:09.110
也能实现了

19:09.110 --> 19:10.110
能精确匹配

19:10.110 --> 19:11.110
比方说这个地方

19:11.110 --> 19:12.110
我要给他加一个zx

19:12.110 --> 19:13.110
一个zx

19:13.110 --> 19:15.110
至少上下文的数据没问题了

19:15.110 --> 19:17.110
看一下吧

19:17.110 --> 19:18.110
现在我们看一下

19:18.110 --> 19:19.110
这里的就是第三个弱者

19:19.110 --> 19:20.110
一个zx为q

19:20.110 --> 19:21.110
那么咱们来看一下

19:21.110 --> 19:23.110
他在提供的上下文

19:23.110 --> 19:25.110
march是不是匹配不到了

19:25.110 --> 19:26.110
对吧

19:26.110 --> 19:27.110
这些都是我们以前

19:27.110 --> 19:28.110
实现好的功能

19:28.110 --> 19:29.110
就是给他传配置

19:29.110 --> 19:31.110
这个配置就直接传到哪去了

19:31.110 --> 19:32.110
就传到这来

19:32.110 --> 19:33.110
传到这来

19:33.110 --> 19:34.110
对吧

19:34.110 --> 19:35.110
我们来匹配

19:35.110 --> 19:37.110
得到一个匹配结果

19:37.110 --> 19:39.110
就完了

19:39.110 --> 19:41.110
咱们这里就是

19:41.110 --> 19:42.110
让他去完成这个匹配

19:42.110 --> 19:44.110
然后把匹配的结果

19:44.110 --> 19:45.110
放到上下文里边

19:45.110 --> 19:46.110
至少这件事我们做了

19:46.110 --> 19:48.110
我们已经做了

19:48.110 --> 19:50.110
没问题吧

19:50.110 --> 19:52.110
这件事我们已经做了

19:52.110 --> 19:53.110
那么接下来

19:53.110 --> 19:55.110
还有一件事

19:55.110 --> 19:56.110
还有一件事

19:56.110 --> 19:58.110
或者说我们在这里

19:58.110 --> 19:59.110
把这个东西写成一个函数

19:59.110 --> 20:01.110
来单独来处理也行

20:01.110 --> 20:02.110
写成一个函数

20:02.110 --> 20:03.110
来单独处理

20:03.110 --> 20:05.110
Render children

20:05.110 --> 20:07.110
写成这么一个函数

20:07.110 --> 20:09.110
来单独处理

20:09.110 --> 20:11.110
单独处理这个问题

20:11.110 --> 20:13.110
给我一个就是

20:13.110 --> 20:15.110
我想想

20:15.110 --> 20:17.110
给我一个y6字

20:17.110 --> 20:20.800
给我一个y6字

20:20.800 --> 20:24.240
我看一下

20:24.240 --> 20:26.240
写这么一个函数

20:26.240 --> 20:28.240
Render children

20:28.240 --> 20:30.240
给我一个y6字

20:30.240 --> 20:32.240
那么我们把这个函数写到这

20:32.240 --> 20:34.240
写到这

20:35.240 --> 20:37.880
没问题吧

20:37.880 --> 20:38.880
应该是可以的

20:38.880 --> 20:40.880
我这里直接把函数放过来

20:40.880 --> 20:42.880
这也是Render children

20:42.880 --> 20:43.880
这个函数

20:43.880 --> 20:44.880
你去调用这个函数

20:44.880 --> 20:45.880
这个函数来帮你搞定

20:45.880 --> 20:46.880
直接调整圈子

20:46.880 --> 20:47.880
保存

20:47.880 --> 20:48.880
是一样的

20:48.880 --> 20:49.880
我就是把抽离一下

20:49.880 --> 20:51.880
把这个过程抽离一下

20:51.880 --> 20:52.880
看一下

20:52.880 --> 20:53.880
是一样的

20:54.880 --> 20:55.880
Provide

20:55.880 --> 20:56.880
你看一下

20:56.880 --> 20:57.880
第一个没有匹配到

20:57.880 --> 20:59.880
第二个匹配到了

20:59.880 --> 21:00.880
看一下

21:00.880 --> 21:01.880
Machi匹配到了

21:01.880 --> 21:03.880
第三个

21:05.880 --> 21:06.880
Machi

21:06.880 --> 21:07.880
没有匹配到了

21:07.880 --> 21:08.880
匹配到了

21:08.880 --> 21:09.880
Machi不为空

21:09.880 --> 21:10.880
它就匹配到了

21:10.880 --> 21:12.880
只不过没有精确匹配而已

21:12.880 --> 21:13.880
好了

21:13.880 --> 21:16.880
那么现在就是这里边的东西了

21:16.880 --> 21:18.880
就是上下文里边的东西

21:18.880 --> 21:19.880
它提供了上下文

21:19.880 --> 21:20.880
上下文已经搞定了

21:20.880 --> 21:22.880
那么里边东西渲染啥呢

21:22.880 --> 21:24.880
到底渲染啥呢

21:24.880 --> 21:26.880
渲染啥是不是取决于

21:26.880 --> 21:29.880
它有没有匹配

21:29.880 --> 21:30.880
对吧

21:30.880 --> 21:32.880
是这个意思吧

21:32.880 --> 21:33.880
渲染啥是不是取决于

21:33.880 --> 21:35.880
有没有匹配

21:35.880 --> 21:37.880
而且取决于这些属性的值

21:37.880 --> 21:38.880
对不对

21:38.880 --> 21:40.880
是不是取决于这些属性的值

21:40.880 --> 21:42.880
这里肯定有很多情况

21:42.880 --> 21:44.880
这里肯定是有很多情况跑不了的

21:44.880 --> 21:46.880
跑不了的

21:46.880 --> 21:47.880
好

21:47.880 --> 21:49.880
那么这里我们又可以写个函数

21:49.880 --> 21:51.880
来专门来做直接点的渲染

21:51.880 --> 21:53.880
专门来做直接点的算渲染

21:53.880 --> 21:54.880
好

21:54.880 --> 21:56.880
比方说我们这里写这么一个函数

21:56.880 --> 21:58.880
写这么一个函数

21:59.880 --> 22:00.880
这里就写了

22:00.880 --> 22:02.880
已经写了就是

22:02.880 --> 22:04.880
这里有个换个名字

22:04.880 --> 22:06.880
换个名字

22:07.880 --> 22:08.880
concumer

22:08.880 --> 22:10.880
就是上下文不是个消费者吗

22:10.880 --> 22:11.880
它不是要传个函数吗

22:11.880 --> 22:13.880
concumer funk

22:13.880 --> 22:15.880
就是上下文消费者函数

22:15.880 --> 22:18.880
上下文中

22:18.880 --> 22:20.880
消费者函数

22:20.880 --> 22:22.880
就是在concumer里边不是要写个函数

22:22.880 --> 22:23.880
对不对

22:23.880 --> 22:25.880
拿到当前这个上下文的东西

22:25.880 --> 22:27.880
然后你要做什么事情你自己去做

22:27.880 --> 22:28.880
但是这个消费者函数

22:28.880 --> 22:29.880
里边要返回一个provider

22:29.880 --> 22:31.880
provider里边又要得到一些东西

22:31.880 --> 22:33.880
又要得到一些东西

22:33.880 --> 22:34.880
那么这里呢

22:34.880 --> 22:35.880
我们使用另外一个函数

22:35.880 --> 22:37.880
给它取个名字叫做

22:37.880 --> 22:38.880
叫做

22:38.880 --> 22:41.880
这个叫做render children

22:41.880 --> 22:42.880
就确认直接点

22:42.880 --> 22:44.880
确认provider里边的直接点

22:44.880 --> 22:46.880
我们写这么一个函数

22:46.880 --> 22:47.880
你把传个什么东西过来了

22:47.880 --> 22:48.880
传一个上下文的

22:48.880 --> 22:50.880
当前上下文的数据

22:50.880 --> 22:51.880
就是这个

22:51.880 --> 22:53.880
就是这个数据给我传过来

22:53.880 --> 22:54.880
然后我给你返回东西

22:54.880 --> 22:55.880
你去选了

22:55.880 --> 22:56.880
那么这里呢

22:56.880 --> 22:57.880
我们就调用

22:57.880 --> 22:59.880
resrender children

22:59.880 --> 23:01.880
把这个上下文的东西给你

23:01.880 --> 23:02.880
因为这里有很多情况

23:02.880 --> 23:03.880
这里有很多情况

23:03.880 --> 23:05.880
你自己去搞定

23:05.880 --> 23:06.880
到底要选择啥

23:06.880 --> 23:07.880
你自己去搞定

23:07.880 --> 23:08.880
我们把题上面

23:08.880 --> 23:10.880
对照这个属性写

23:10.880 --> 23:11.880
对照这个属性写

23:11.880 --> 23:13.880
所以CTA是什么意思

23:13.880 --> 23:15.880
就是

23:15.880 --> 23:18.880
在上下文提供着

23:18.880 --> 23:20.880
中

23:20.880 --> 23:23.880
内部渲染的内容

23:23.880 --> 23:24.880
到底要渲染什么东西

23:24.880 --> 23:25.880
是不是要取决于

23:25.880 --> 23:27.880
你到底有没有匹配

23:27.880 --> 23:28.880
匹配过后

23:28.880 --> 23:29.880
到底要渲染什么东西

23:29.880 --> 23:30.880
对吧

23:30.880 --> 23:31.880
是不是取决于这些东西

23:31.880 --> 23:32.880
对吧

23:32.880 --> 23:33.880
我们这里到底要渲染啥

23:33.880 --> 23:34.880
就有很多情况

23:34.880 --> 23:35.880
好

23:35.880 --> 23:36.880
首先这种情况

23:36.880 --> 23:37.880
就是你写的

23:37.880 --> 23:38.880
切尤准属性

23:38.880 --> 23:40.880
你写的切尤准属性

23:40.880 --> 23:41.880
那么这种情况下

23:41.880 --> 23:42.880
无论你有没有匹配

23:42.880 --> 23:43.880
我都要渲染

23:43.880 --> 23:44.880
判断一下

23:44.880 --> 23:45.880
如果说你写的

23:45.880 --> 23:46.880
这个切尤准属性

23:46.880 --> 23:48.880
你给我传递的切尤准

23:48.880 --> 23:51.880
你给我传递的切尤准

23:51.880 --> 23:53.880
那么无论如何

23:53.880 --> 23:55.880
无论是否匹配

23:55.880 --> 23:57.880
都要渲染

23:57.880 --> 23:58.880
那怎么渲染呢

23:58.880 --> 23:59.880
来写吧

23:59.880 --> 24:00.880
怎么渲染

24:00.880 --> 24:01.880
渲染的方式

24:01.880 --> 24:03.880
就是首先看一下

24:03.880 --> 24:04.880
因为这个切尤准属性

24:04.880 --> 24:05.880
我们知道

24:05.880 --> 24:06.880
它有两种情况

24:06.880 --> 24:08.880
首先这个

24:08.880 --> 24:09.880
不是contact切尤准

24:09.880 --> 24:11.880
是this props切尤准

24:12.880 --> 24:15.880
如果说你这个切尤准属性

24:15.880 --> 24:17.880
你给我传的是一个

24:18.880 --> 24:19.880
节点

24:19.880 --> 24:21.880
传的是一个节点

24:21.880 --> 24:23.880
传的是什么呢

24:23.880 --> 24:25.880
传的是一个react元素

24:25.880 --> 24:26.880
传的是一个react元素

24:27.880 --> 24:28.880
那么比方说

24:28.880 --> 24:30.880
传的是一个object

24:30.880 --> 24:35.020
是一个react元素

24:35.020 --> 24:36.020
或者说呢

24:36.020 --> 24:38.020
也有可能是知误创

24:38.020 --> 24:39.020
总之呢

24:39.020 --> 24:41.020
只要你不是函数就行

24:41.020 --> 24:42.020
只要你不是函数

24:42.020 --> 24:44.020
你这个切尤准有值

24:44.020 --> 24:45.020
一个切尤准有值

24:45.020 --> 24:48.520
并且你不是函数

24:49.520 --> 24:50.520
这样说吧

24:50.520 --> 24:51.520
你这个切尤准不等于

24:51.520 --> 24:53.520
undefend

24:53.520 --> 24:54.520
不等于undefend

24:54.520 --> 24:56.520
并且你又不是函数

24:56.520 --> 24:57.520
如果你不

24:57.520 --> 24:58.520
不等于undefend

24:58.520 --> 24:59.520
是不是传了切尤准

24:59.520 --> 25:00.520
对吧

25:00.520 --> 25:01.520
传了切尤准

25:01.520 --> 25:02.520
那么传了切尤准

25:02.520 --> 25:04.520
无论如何都要渲染切尤准

25:04.520 --> 25:05.520
其他的就忽略掉了

25:05.520 --> 25:07.520
那么如果你不是一个函数的话

25:07.520 --> 25:09.520
那么我直接给你返回

25:09.520 --> 25:10.520
切尤准

25:10.520 --> 25:11.520
你直接渲染就完事了

25:11.520 --> 25:12.520
你去渲染吧

25:12.520 --> 25:13.520
我不管了

25:13.520 --> 25:14.520
我不管了你去渲染吧

25:14.520 --> 25:15.520
好

25:15.520 --> 25:16.520
这种情况

25:16.520 --> 25:18.520
else

25:18.520 --> 25:19.520
如果说你没有传

25:19.520 --> 25:22.520
就是如果你切尤准是一个函数

25:22.520 --> 25:23.520
这是不是函数

25:23.520 --> 25:25.520
或者说我们把这样子写吧

25:25.520 --> 25:26.520
这样子写一下

25:27.520 --> 25:28.520
你不是函数

25:28.520 --> 25:30.520
我就直接把切尤准返回就完事了

25:30.520 --> 25:31.520
这是什么情况

25:31.520 --> 25:32.520
这是这种情况

25:34.520 --> 25:36.520
就是说你在这里写到切尤准

25:36.520 --> 25:37.520
你写到切尤准

25:37.520 --> 25:39.520
在这里边写了一些东西

25:39.520 --> 25:40.520
那我直接劝了就完事了

25:40.520 --> 25:42.520
我就不管你有没有

25:42.520 --> 25:43.520
我就不管你有没有就是匹配

25:43.520 --> 25:45.520
反正我就劝了

25:45.520 --> 25:46.520
我就劝了

25:46.520 --> 25:47.520
对吧

25:47.520 --> 25:48.520
我就返回probs切尤准

25:48.520 --> 25:49.520
如果说你是一个函数

25:49.520 --> 25:51.520
我是不是要调用函数

25:51.520 --> 25:52.520
我是不是要调用函数

25:52.520 --> 25:55.520
把函数的返回结果来进行劝了

25:55.520 --> 25:57.520
那么我们要调用函数

25:57.520 --> 25:59.520
因为我们知道切尤准是可以试函数的

25:59.520 --> 26:00.520
它跟那个render是一样的

26:00.520 --> 26:02.520
它这个切尤准可以试一个函数

26:03.520 --> 26:05.520
那么函数里边的数据是什么

26:05.520 --> 26:07.520
数据是不是就把它这个东西传过去

26:07.520 --> 26:08.520
还记得吗

26:08.520 --> 26:10.520
当时我们这个函数里边

26:10.520 --> 26:12.520
是不是可以用到的三个函数

26:12.520 --> 26:14.520
这个函数里面如果可以写函数的话

26:14.520 --> 26:15.520
是不是可以用到这个

26:15.520 --> 26:16.520
上下往里面的value

26:16.520 --> 26:18.520
value里面是不是可以提供什么

26:18.520 --> 26:19.520
History

26:19.520 --> 26:21.520
还有什么Location

26:21.520 --> 26:23.520
还有什么March

26:23.520 --> 26:24.520
都可以使用

26:24.520 --> 26:25.520
对吧

26:25.520 --> 26:26.520
挨咋用咋用

26:26.520 --> 26:28.520
总之里面函数要给我一个结果

26:28.520 --> 26:30.520
就是这么一个逻辑

26:30.520 --> 26:32.520
那么我就调用函数

26:32.520 --> 26:34.520
把函数的返回结果返回

26:34.520 --> 26:36.520
好,那咱们来看一下切尤准的情况吧

26:36.520 --> 26:37.520
我们这里随便写一个

26:37.520 --> 26:39.520
你看是不是显示了

26:39.520 --> 26:40.520
为啥显示呢

26:40.520 --> 26:42.520
因为它是切尤准

26:42.520 --> 26:44.520
它是切尤准

26:45.520 --> 26:46.520
Provider里边是不是显示了

26:46.520 --> 26:47.520
哪怕你没有匹配

26:47.520 --> 26:48.520
匹配到了吗

26:48.520 --> 26:49.520
是不是没匹配

26:49.520 --> 26:50.520
对吧

26:50.520 --> 26:51.520
但是我还是给你显示了

26:51.520 --> 26:52.520
还是给你显示了

26:52.520 --> 26:53.520
因为你是切尤准

26:53.520 --> 26:55.520
那么切尤准的也可以写函数

26:55.520 --> 26:56.520
比方说Value

26:56.520 --> 26:57.520
可以写函数

26:57.520 --> 26:59.520
咱们输出一个Value

26:59.520 --> 27:00.520
比方说输出一个Value

27:00.520 --> 27:01.520
Return

27:01.520 --> 27:02.520
一个

27:02.520 --> 27:04.520
这是切尤准

27:04.520 --> 27:07.520
函数返回的结果

27:07.520 --> 27:08.520
好,保存

27:08.520 --> 27:09.520
你看

27:09.520 --> 27:10.520
是不是得到这个东西了

27:10.520 --> 27:11.520
于是它就调用了啥

27:11.520 --> 27:12.520
调用了函数

27:12.520 --> 27:13.520
而且空置才能看到

27:13.520 --> 27:14.520
这个函数里边

27:14.520 --> 27:15.520
说可以拿到这些东西

27:15.520 --> 27:16.520
对吧

27:16.520 --> 27:17.520
可以拿到这些东西

27:17.520 --> 27:18.520
你看这些东西

27:18.520 --> 27:19.520
就是这样子写出来的

27:19.520 --> 27:21.520
好,这是切尤准

27:22.520 --> 27:23.520
切尤准搞定了

27:23.520 --> 27:25.520
那么现在我们看另外一个

27:25.520 --> 27:27.520
当然下面就是

27:27.520 --> 27:29.520
我们这里就结束

27:29.520 --> 27:31.520
切尤准只要你有值

27:31.520 --> 27:32.520
那么这样子

27:32.520 --> 27:33.520
两个一定是返回结果了

27:33.520 --> 27:34.520
对吧

27:34.520 --> 27:36.520
这是切尤准有值的情况

27:36.520 --> 27:38.520
切尤准有值

27:38.520 --> 27:39.520
好了吗

27:39.520 --> 27:41.520
如果说切尤准没有值

27:41.520 --> 27:43.520
切尤准

27:43.520 --> 27:45.520
没有值

27:45.520 --> 27:47.520
但是Render有值

27:47.520 --> 27:50.520
Render有值

27:51.520 --> 27:53.520
那这种情况下

27:53.520 --> 27:54.520
Render有值

27:54.520 --> 27:55.520
切尤准没有值

27:55.520 --> 27:56.520
那是不是要运行Render

27:56.520 --> 27:58.520
我管不管什么

27:58.520 --> 27:59.520
运行Render

27:59.520 --> 28:00.520
Render运行的话

28:00.520 --> 28:01.520
是不是要看有没有匹配

28:01.520 --> 28:02.520
我就看一下

28:02.520 --> 28:03.520
ctx是march

28:03.520 --> 28:04.520
有没有值

28:06.520 --> 28:07.520
march

28:07.520 --> 28:09.520
就是Render有值

28:11.520 --> 28:13.520
无论是Render有值

28:13.520 --> 28:16.520
后面的情况就是

28:16.520 --> 28:17.520
切尤准它没有值

28:17.520 --> 28:18.520
切尤准没有值的话

28:18.520 --> 28:19.520
就是要么就渲染它

28:19.520 --> 28:20.520
要么就渲染它

28:20.520 --> 28:21.520
对不对

28:21.520 --> 28:22.520
那么两种情况

28:22.520 --> 28:23.520
是不是都要匹配

28:23.520 --> 28:25.520
都要匹配过后才能渲染

28:25.520 --> 28:27.520
如果说你没有匹配

28:27.520 --> 28:28.520
你没有值

28:28.520 --> 28:29.520
ctx是march

28:29.520 --> 28:31.520
没有值

28:33.520 --> 28:34.520
如果说没有值

28:34.520 --> 28:35.520
没有匹配

28:35.520 --> 28:37.520
是不会进行任何渲染的

28:37.520 --> 28:39.520
不会进行任何渲染

28:39.520 --> 28:40.520
所以我们这里直接返回

28:40.520 --> 28:41.520
什么

28:41.520 --> 28:42.520
可以返回Low

28:42.520 --> 28:44.520
直接可以返回Low

28:44.520 --> 28:46.520
没有匹配就不要进行任何渲染

28:46.520 --> 28:47.520
保存

28:48.520 --> 28:50.520
现在把8个切尤准去掉

28:50.520 --> 28:52.520
切尤准去掉

28:52.520 --> 28:56.600
那么现在我们看一下

29:03.600 --> 29:05.600
这个切尤准它给的是Low

29:05.600 --> 29:07.600
Low它也会被选择

29:07.600 --> 29:09.600
那我们这里还要判断一个Low的情况

29:09.600 --> 29:10.600
我们这里只判断了一个onD犯的

29:10.600 --> 29:11.600
onD犯的

29:11.600 --> 29:12.600
并且

29:12.600 --> 29:15.600
this props.churchin

29:15.600 --> 29:16.600
不等于Low

29:16.600 --> 29:18.600
就是你给到我值就行了

29:18.600 --> 29:20.600
只要能够给我值就行

29:20.600 --> 29:22.600
都把Low的情况要考虑在内

29:22.600 --> 29:24.600
要考虑在内

29:24.600 --> 29:25.600
看一下吧

29:29.600 --> 29:30.600
那么现在呢

29:30.600 --> 29:32.600
它没有渲染效准对吧

29:32.600 --> 29:33.600
那么现在呢

29:33.600 --> 29:34.600
它也没有渲染任何东西

29:34.600 --> 29:36.600
没有渲染任何东西

29:38.600 --> 29:39.600
为什么没有渲染任何东西呢

29:39.600 --> 29:41.600
因为它没有匹配

29:41.600 --> 29:43.600
反之如果它匹配了

29:43.600 --> 29:44.600
匹配了

29:44.600 --> 29:46.600
匹配到是不是要看Render

29:47.600 --> 29:48.600
Component哪个有值

29:48.600 --> 29:49.600
对吧

29:49.600 --> 29:50.600
如果说Render有值

29:50.600 --> 29:52.600
如果CTX Render

29:52.600 --> 29:54.600
this props

29:55.600 --> 29:57.600
Render是有值的

29:57.600 --> 29:59.600
不等于onD犯

29:59.600 --> 30:00.600
你给我传了值

30:00.600 --> 30:02.600
你给我传了值进来

30:02.600 --> 30:03.600
或者是这样判断

30:03.600 --> 30:05.600
Render type of this props Render

30:05.600 --> 30:06.600
等于什么呢

30:06.600 --> 30:07.600
等于方形

30:07.600 --> 30:08.600
你给我传了个函数进来

30:08.600 --> 30:10.600
因为Render它一定是函数

30:10.600 --> 30:12.600
那我是不是要调用Render函数

30:12.600 --> 30:14.600
那调用的方式是不是一样的

30:14.600 --> 30:16.600
跟之前调用的气候准数一样的

30:16.600 --> 30:18.600
把CTX传给你

30:18.600 --> 30:20.600
匹配了

30:20.600 --> 30:22.600
我调用Render

30:22.600 --> 30:24.600
把Render的结果返回

30:24.600 --> 30:26.600
这是Render的情况

30:26.600 --> 30:28.600
那么后边就是

30:28.600 --> 30:30.600
匹配了

30:30.600 --> 30:32.600
Render有值

30:32.600 --> 30:34.600
那么现在就是Render没有值

30:34.600 --> 30:36.600
只有Component有值

30:36.600 --> 30:38.600
只有Component有值

30:38.600 --> 30:40.600
那怎么办

30:40.600 --> 30:42.600
是不是返回啥

30:42.600 --> 30:44.600
返回Component是属性值

30:44.600 --> 30:46.600
对吧

30:46.600 --> 30:48.600
咱们把Component拿到

30:48.600 --> 30:50.600
Component拿到

30:50.600 --> 30:51.600
这里呢

30:51.600 --> 30:53.600
当然Component还是要判断一下

30:53.600 --> 30:55.600
万一Component也没有值

30:55.600 --> 30:57.600
然后鬼出了准

30:57.600 --> 31:00.600
就是thisPropsComponent

31:00.600 --> 31:02.600
如果你Component有值的话

31:02.600 --> 31:05.600
如果说Component也有值的话

31:05.600 --> 31:08.600
那么我们就要把Component拿到

31:08.600 --> 31:10.600
Component

31:10.600 --> 31:11.600
拿到

31:11.600 --> 31:13.600
等于thisProps

31:13.600 --> 31:14.600
Component

31:14.600 --> 31:16.600
拿到这个Component

31:16.600 --> 31:17.600
然后返回啥

31:17.600 --> 31:19.600
Component这个组件

31:19.600 --> 31:21.600
我返回你这个Component的组件

31:21.600 --> 31:22.600
对吧

31:22.600 --> 31:23.600
就完了

31:23.600 --> 31:25.600
然后组件里面是不是要注入一些信息

31:25.600 --> 31:27.600
对吧 我们的弱者组件不是要玩个

31:27.600 --> 31:28.600
匹配的组件里面注入信息吗

31:28.600 --> 31:29.600
注入啥

31:29.600 --> 31:30.600
是不是注入一个

31:30.600 --> 31:32.600
那三个属性

31:32.600 --> 31:34.600
对吧 直接把CTX展开就完了

31:34.600 --> 31:35.600
CTX

31:35.600 --> 31:37.600
上下吻里面的属性展开

31:37.600 --> 31:39.600
给他作为属性传过去就完事了

31:39.600 --> 31:40.600
对吧 非常非常简单

31:40.600 --> 31:41.600
就返回组件

31:41.600 --> 31:43.600
好 如果说你组件也没有值

31:43.600 --> 31:44.600
那我只能给你返回NOW了

31:44.600 --> 31:45.600
那我还能干嘛呢

31:45.600 --> 31:47.600
就给你返回NOW就完事了

31:47.600 --> 31:48.600
保存你看一下

31:53.620 --> 31:54.620
好

31:54.620 --> 31:55.620
然后我们看一下

31:55.620 --> 31:57.620
这里出了点小问题

31:57.620 --> 31:58.620
出了点小问题

31:58.620 --> 32:00.620
到了配级1过后

32:00.620 --> 32:02.620
到了配级1过后

32:04.620 --> 32:06.620
它这个地方没有变化

32:06.620 --> 32:07.620
没有变化

32:07.620 --> 32:08.620
我们去配级2

32:08.620 --> 32:10.620
再回到

32:10.620 --> 32:12.620
配级1

32:12.620 --> 32:14.620
配级1里面没变化

32:14.620 --> 32:16.620
我看一下是怎么回事

32:16.620 --> 32:17.620
是怎么回事

32:17.620 --> 32:19.620
为什么没有发生变化

32:19.620 --> 32:21.620
应该说至少现在渲染没问题了

32:21.620 --> 32:22.620
就是如果说匹配到了

32:22.620 --> 32:24.620
比方说我这里直接回车

32:24.620 --> 32:25.620
渲染配级1

32:25.620 --> 32:26.620
匹配到了过后就进行渲染

32:26.620 --> 32:28.620
已经没问题了

32:28.620 --> 32:29.620
已经没有任何问题了

32:29.620 --> 32:30.620
就是匹配到了过后

32:30.620 --> 32:31.620
我发现

32:31.620 --> 32:32.620
给了component

32:32.620 --> 32:34.620
那么就运行了这个这个地方

32:34.620 --> 32:35.620
对吧

32:35.620 --> 32:36.620
我直接设置个component

32:36.620 --> 32:39.620
然后把这些上下吻的数据全部给力

32:39.620 --> 32:40.620
至少这些没问题了

32:40.620 --> 32:42.620
然后这些

32:42.620 --> 32:43.620
组件里面的属性也传过去了

32:43.620 --> 32:45.620
这就是为什么我点了这个圈级

32:45.620 --> 32:47.620
这里边可以使用到history

32:47.620 --> 32:48.620
对吧

32:48.620 --> 32:50.620
那么现在关键的问题是那个

32:51.620 --> 32:52.620
点击页面过后

32:52.620 --> 32:53.620
它没有发生变化

32:53.620 --> 32:54.620
我们来看一下

32:54.620 --> 32:55.620
这是怎么回事

32:55.620 --> 32:56.620
点击区

32:56.620 --> 32:57.620
从现在是配级1

32:57.620 --> 32:58.620
点击区配级2

32:58.620 --> 32:59.620
它这里没变化

32:59.620 --> 33:00.620
那么我们来看一下吧

33:00.620 --> 33:01.620
那么看一下

33:01.620 --> 33:02.620
首先看一下这个上下吻

33:02.620 --> 33:03.620
有没有发生变化

33:06.620 --> 33:08.620
这个变化了

33:08.620 --> 33:09.620
那么这个导致

33:09.620 --> 33:11.620
这个就是上下吻刷新了

33:11.620 --> 33:12.620
这个上下吻肯定是刷新了

33:12.620 --> 33:13.620
这个没问题

33:14.620 --> 33:16.620
这个上下吻刷新了

33:16.620 --> 33:18.620
然后在肉彻1里边

33:18.620 --> 33:20.620
它的consumer里边

33:20.620 --> 33:22.620
provider

33:23.620 --> 33:25.620
它这里面有没有刷新的

33:25.620 --> 33:27.620
它这里面还是配级1

33:27.620 --> 33:29.620
这个地方有点奇怪

33:29.620 --> 33:31.620
它这里面还是配级1

33:31.620 --> 33:33.620
它没有刷新

33:33.620 --> 33:34.620
咱们来看一下吧

33:34.620 --> 33:36.620
它为什么会没有刷新

33:38.620 --> 33:40.620
我们来看一下这里

33:40.620 --> 33:42.620
这是一个consumer

33:42.620 --> 33:43.620
这是个函数

33:43.620 --> 33:44.620
我这个函数这里打印一下

33:44.620 --> 33:46.620
打印一下Value.hiss

33:46.620 --> 33:48.620
location.passname

33:48.620 --> 33:51.760
打印一下

33:51.760 --> 33:53.760
这个函数运行了多少次

33:54.760 --> 33:55.760
运行了三次

33:55.760 --> 33:56.760
有三个组件

33:56.760 --> 33:57.760
对不对

33:57.760 --> 33:58.760
区配级1

33:58.760 --> 34:00.760
它就没运行了

34:00.760 --> 34:04.720
这个挺牛逼的

34:04.720 --> 34:05.720
它没运行了

34:05.720 --> 34:07.720
这个挺牛逼的

34:07.720 --> 34:09.720
它连这个函数都没有运行了

34:10.720 --> 34:12.720
我想一想

34:14.720 --> 34:16.720
我的天啊

34:16.720 --> 34:19.720
我发了一个很低级的错误

34:20.720 --> 34:22.720
我干嘛要去画舍天主

34:22.720 --> 34:24.720
我发现我这两天经常去画舍天主

34:24.720 --> 34:26.720
这个地方不能这样子写

34:26.720 --> 34:28.720
之前写个rotor的时候

34:28.720 --> 34:29.720
不能这样子写

34:29.720 --> 34:30.720
为了解约效率

34:30.720 --> 34:32.720
不能这样子写

34:32.720 --> 34:34.720
要在这里重新建对象

34:34.720 --> 34:35.720
为什么

34:35.720 --> 34:37.720
如果说你这里变化了过后

34:37.720 --> 34:38.720
如果说你这里

34:38.720 --> 34:40.720
上下文里边的对象引用没有变化

34:40.720 --> 34:42.720
它认为上下文是没变的

34:42.720 --> 34:44.720
它认为上下文是没变的

34:44.720 --> 34:45.720
它不会导致刷新

34:45.720 --> 34:47.720
依赖上下文的组件

34:47.720 --> 34:49.720
必须要让上下文的

34:49.720 --> 34:51.720
Value值发生变化

34:51.720 --> 34:53.720
让上下文的Value值发生变化

34:53.720 --> 34:55.720
它才知道上下文变化了

34:55.720 --> 34:56.720
所以说我们这里

34:56.720 --> 34:59.720
得至于去建立一个变量

34:59.720 --> 35:00.720
Value

35:00.720 --> 35:02.720
CXValue

35:03.720 --> 35:05.720
等于一个空对象

35:05.720 --> 35:06.720
对象里边的history

35:06.720 --> 35:07.720
这样子写

35:07.720 --> 35:08.720
换一下写法

35:12.030 --> 35:14.030
然后location

35:18.030 --> 35:20.030
然后是march

35:20.030 --> 35:22.600
march

35:22.600 --> 35:23.600
let's do it

35:26.290 --> 35:27.290
得这样子写

35:27.290 --> 35:29.670
得这样子写

35:29.670 --> 35:30.670
让它每一次渲染的时候

35:30.670 --> 35:32.670
得到一个新的对象

35:32.670 --> 35:33.670
不然的话

35:33.670 --> 35:34.670
它就

35:34.670 --> 35:35.670
后续的对象

35:35.670 --> 35:36.670
它就不知道发生变化了

35:36.670 --> 35:37.670
不知道那个provider

35:37.670 --> 35:39.670
上下文发生变化了

35:39.670 --> 35:41.670
这里是这种情况

35:41.670 --> 35:42.670
这边也是一样

35:42.670 --> 35:43.670
这边也是一样

35:45.670 --> 35:46.670
这边

35:47.670 --> 35:48.670
我看一下

35:49.670 --> 35:50.670
这里不要用

35:50.670 --> 35:51.670
CXValue了

35:51.670 --> 35:52.670
这里也是一样

35:55.560 --> 35:56.560
定个变量

35:56.560 --> 35:57.560
CXValue

35:59.560 --> 36:00.560
来自于这些字

36:00.560 --> 36:01.560
history

36:01.560 --> 36:02.560
Value 第二

36:02.560 --> 36:03.560
history

36:04.560 --> 36:05.560
location

36:06.560 --> 36:07.560
Value 第二

36:07.560 --> 36:08.560
location

36:08.560 --> 36:09.560
然后呢

36:09.560 --> 36:10.560
march

36:11.560 --> 36:13.560
这个是来自于这

36:13.560 --> 36:16.700
得这么写

36:16.700 --> 36:17.700
得这么写

36:20.460 --> 36:21.460
得这么写

36:21.460 --> 36:22.460
好 保存

36:22.460 --> 36:23.460
保存

36:23.460 --> 36:24.460
现在再看一下

36:25.460 --> 36:26.460
page2

36:26.460 --> 36:27.460
是不是跟着刷新了

36:27.460 --> 36:28.460
这样才会刷新

36:28.460 --> 36:29.460
不然的话

36:29.460 --> 36:30.460
同一个对象引用

36:30.460 --> 36:31.460
它不会刷新的

36:31.460 --> 36:32.460
不会刷新的

36:32.460 --> 36:33.460
看一下是不是变了

36:33.460 --> 36:34.460
对吧

36:34.460 --> 36:35.460
上下文刷新了

36:35.460 --> 36:36.460
看这个过程

36:36.460 --> 36:38.460
我们这里的browser

36:38.460 --> 36:39.460
它提供的上下文

36:39.460 --> 36:40.460
当改变地址的时候

36:40.460 --> 36:41.460
因为它有监听器

36:41.460 --> 36:43.460
它监听到地址发生变化

36:43.460 --> 36:45.460
是不是上下文的数据要更新

36:45.460 --> 36:46.460
上下文的数据更新

36:46.460 --> 36:48.460
那么这些组件是依赖上下文的

36:48.460 --> 36:49.460
它是上下文的消费者

36:49.460 --> 36:50.460
是不是他们也会更新

36:50.460 --> 36:51.460
重新渲染

36:51.460 --> 36:52.460
他们一重新渲染

36:52.460 --> 36:53.460
是不是要重新去匹配

36:53.460 --> 36:54.460
重新匹配

36:54.460 --> 36:55.460
那么有些没匹配到的

36:55.460 --> 36:56.460
它就啥都没有渲染

36:56.460 --> 36:57.460
对吧

36:57.460 --> 36:58.460
它只提供了一个上下文

36:58.460 --> 36:59.460
但是啥都没渲染

36:59.460 --> 37:00.460
没匹配到

37:00.460 --> 37:01.460
然后那比方说

37:01.460 --> 37:02.460
我们现在到了page1

37:02.460 --> 37:03.460
那它是不是匹配到了

37:03.460 --> 37:04.460
它重新渲染就匹配到了

37:04.460 --> 37:05.460
有它渲染的支柱件

37:05.460 --> 37:06.460
对吧

37:06.460 --> 37:07.460
那么它

37:07.460 --> 37:08.460
它又没匹配到了

37:08.460 --> 37:09.460
它也不渲染了

37:09.460 --> 37:10.460
对不对

37:10.460 --> 37:11.460
是不是有些消费者这么一个效果

37:11.460 --> 37:12.460
对吧

37:12.460 --> 37:13.460
同时也实现了什么

37:13.460 --> 37:14.460
一个ZX

37:14.460 --> 37:15.460
最个ZX

37:15.460 --> 37:16.460
生存体物都实现了

37:16.460 --> 37:17.460
比方说

37:17.460 --> 37:19.460
我们这里要加上一个ZX

37:19.460 --> 37:20.460
加上一个ZX

37:20.460 --> 37:21.460
那么你会发现

37:21.460 --> 37:22.460
它没有渲染出来了

37:22.460 --> 37:23.460
两个按钮没有渲染出来了

37:23.460 --> 37:24.460
那么这里的

37:24.460 --> 37:25.460
只有访问这个地址的时候

37:25.460 --> 37:26.460
才会渲染两个按钮

37:26.460 --> 37:28.460
访问配级1

37:29.460 --> 37:30.460
访问配级1的时候

37:30.460 --> 37:31.460
就渲染不了

37:31.460 --> 37:32.460
对吧

37:32.460 --> 37:34.840
渲染不了

37:34.840 --> 37:35.840
其实这里还有一种情况

37:35.840 --> 37:37.840
就是你不写PASS

37:37.840 --> 37:38.840
你不写PASS

37:38.840 --> 37:40.840
是不是无论如何都要渲染

37:40.840 --> 37:41.840
对吧

37:41.840 --> 37:42.840
如果你不写PASS的话

37:42.840 --> 37:43.840
无论如何都要渲染

37:43.840 --> 37:44.840
好

37:44.840 --> 37:45.840
咱们来试一下

37:45.840 --> 37:46.840
咱们在下面

37:46.840 --> 37:48.840
再写一个配

37:48.840 --> 37:50.840
再写一个component

37:50.840 --> 37:52.840
就用配级2

37:52.840 --> 37:55.840
或者就用这个

37:55.840 --> 37:57.840
无论如何都要渲染

37:57.840 --> 37:58.840
不写PASS

37:58.840 --> 37:59.840
那么我们看一下

37:59.840 --> 38:01.840
目前能不能达到要求

38:01.840 --> 38:02.840
目前

38:02.840 --> 38:03.840
它说不行

38:03.840 --> 38:04.840
为什么不能达到要求呢

38:04.840 --> 38:05.840
因为我们这里

38:05.840 --> 38:06.840
在这个函数里边

38:06.840 --> 38:08.840
是始终当PASS有值的

38:08.840 --> 38:10.840
始终认为PASS是有值的

38:10.840 --> 38:12.840
那如果说你现在

38:12.840 --> 38:14.840
PASS没有值的话

38:14.840 --> 38:16.840
没有值的话怎么去匹配呢

38:16.840 --> 38:17.840
好 那我们看一下

38:17.840 --> 38:18.840
它是怎么做的

38:18.840 --> 38:19.840
对这一点

38:19.840 --> 38:20.840
它是怎么做的

38:20.840 --> 38:21.840
我们把这个代码

38:22.840 --> 38:23.840
扣皮到这

38:24.840 --> 38:26.840
把之前的代码扣皮过来

38:27.840 --> 38:28.840
就是看那个

38:28.840 --> 38:29.840
它那个组件里边

38:29.840 --> 38:31.840
如果说我这里不写PASS

38:31.840 --> 38:32.840
它是怎么来匹配的

38:32.840 --> 38:33.840
保存

38:34.840 --> 38:35.840
它是无论如何都

38:35.840 --> 38:36.840
为宣展 这点毫无疑问

38:36.840 --> 38:37.840
这是它的功能

38:37.840 --> 38:38.840
我们主要看它上下文里边

38:38.840 --> 38:39.840
是怎么匹配的

38:39.840 --> 38:40.840
好 落车这里

38:40.840 --> 38:42.840
没有给它写PASS 对吧

38:42.840 --> 38:43.840
没有给它写PASS

38:43.840 --> 38:44.840
好 咱们来看一下

38:44.840 --> 38:45.840
Provider里边

38:45.840 --> 38:46.840
它的上下文March

38:47.840 --> 38:48.840
看没

38:48.840 --> 38:51.840
如果说你没有写PASS的话

38:51.840 --> 38:52.840
我就认为你匹配的

38:52.840 --> 38:53.840
你的路径规则

38:53.840 --> 38:54.840
就是一个斜槓

38:54.840 --> 38:55.840
我认为你的路径规则

38:55.840 --> 38:56.840
就是一个斜槓

38:56.840 --> 38:57.840
你要这个意思吧

38:58.840 --> 39:00.840
也就是说我可以怎么样呢

39:00.840 --> 39:01.840
我是不是可以给一个PASS

39:01.840 --> 39:02.840
一个默认值

39:02.840 --> 39:03.840
对吧

39:03.840 --> 39:04.840
是不是可以给PASS

39:05.840 --> 39:06.840
看吧

39:06.840 --> 39:08.840
我们这里在路车里边

39:08.840 --> 39:10.840
就很简单这个做法

39:10.840 --> 39:12.840
就是Default

39:12.840 --> 39:14.840
default props

39:14.840 --> 39:15.840
等于什么呢

39:15.840 --> 39:17.840
PASS有个默认值写钢

39:17.840 --> 39:19.840
有个默认值写钢

39:19.840 --> 39:20.840
对吧

39:20.840 --> 39:21.840
就完了

39:22.840 --> 39:23.840
好

39:23.840 --> 39:24.840
来吧

39:24.840 --> 39:26.840
来 试一下

39:26.840 --> 39:29.840
我们还是把之前的Copy过来

39:30.840 --> 39:32.840
这是它的

39:32.840 --> 39:33.840
这是我们自己的

39:34.840 --> 39:35.840
Copy过来

39:35.840 --> 39:38.920
那么现在我们再看一下

39:38.920 --> 39:39.920
还有问题

39:39.920 --> 39:40.920
我看一下

39:40.920 --> 39:41.920
哪里还有问题

39:45.060 --> 39:47.060
这个PASS是一个斜槓了

39:47.060 --> 39:49.060
PASS路径规则已经有值的

39:49.060 --> 39:50.060
已经有值的

39:50.060 --> 39:51.060
它不可能没有值的

39:51.060 --> 39:52.060
因为Default

39:52.060 --> 39:53.060
这里没加那个

39:53.060 --> 39:54.060
没加Static

39:55.060 --> 39:56.060
没办默认值

39:56.060 --> 39:57.060
你看 是不是搞定了

39:57.060 --> 39:58.060
那么我们现在再看一下

39:58.060 --> 39:59.060
我们里边的

40:00.060 --> 40:02.060
就是第三个

40:03.060 --> 40:04.060
对吧

40:04.060 --> 40:05.060
第三个没有写PASS

40:05.060 --> 40:06.060
那么就相当于是加了个默认值

40:06.060 --> 40:07.060
对吧

40:07.060 --> 40:08.060
相当于是加了个默认值

40:08.060 --> 40:09.060
实际上它是怎么写的呢

40:09.060 --> 40:10.060
它还不是给

40:10.060 --> 40:11.060
它给的不是默认值

40:11.060 --> 40:12.060
它是在这里判断的

40:12.060 --> 40:14.060
它是在这里判断的

40:14.060 --> 40:15.060
比方说在这

40:15.060 --> 40:16.060
嗯 这哪呢

40:17.060 --> 40:18.060
在这

40:20.060 --> 40:21.060
MARCH

40:21.060 --> 40:22.060
MARCH这里

40:22.060 --> 40:24.060
在MARCH这里已经判断的

40:24.060 --> 40:25.060
MARCH这里已经判断的

40:25.060 --> 40:28.060
那么这里就是PASS有没有值

40:28.060 --> 40:30.060
如果说PASS没有值

40:31.060 --> 40:33.060
如果说PASS有值

40:33.060 --> 40:35.060
那么就取取这个

40:36.060 --> 40:38.060
如果它没有值

40:38.060 --> 40:39.060
没有值的话就取一个鞋杠

40:39.060 --> 40:41.060
它是在这里控制的

40:41.060 --> 40:42.060
它是在这里控制的

40:42.060 --> 40:43.060
当然这里控制也行

40:43.060 --> 40:44.060
也行

40:44.060 --> 40:46.060
它就没有去给属性默认值

40:46.060 --> 40:47.060
在这里控制也行

40:47.060 --> 40:48.060
总之它会控制的

40:48.060 --> 40:49.060
来看一下

40:49.060 --> 40:50.060
结果是不是还是出来了

40:50.060 --> 40:51.060
对吧

40:51.060 --> 40:52.060
那么这里呢

40:52.060 --> 40:53.060
就没有属性了

40:53.060 --> 40:54.060
但是仍然匹配上了

40:54.060 --> 40:55.060
无论如何都会匹配

40:55.060 --> 40:56.060
因为它只是一个鞋杠

40:56.060 --> 40:57.060
它肯定会匹配的

40:58.060 --> 40:59.060
这就是弱务扯的做法

40:59.060 --> 41:00.060
你会发现

41:00.060 --> 41:01.060
也没有什么复杂的

41:02.060 --> 41:03.060
因为我们有了

41:03.060 --> 41:04.060
之前那些东西支持

41:04.060 --> 41:05.060
这些东西就不复杂了

41:05.060 --> 41:06.060
弱扯里边

41:06.060 --> 41:07.060
它的主要作用

41:07.060 --> 41:09.060
它提供一个上下文

41:09.060 --> 41:10.060
再看一下

41:10.060 --> 41:12.060
弱扯它本身提供一个上下文

41:12.060 --> 41:13.060
因为弱扯后边的主件

41:13.060 --> 41:14.060
它可能要用到上下文的东西

41:14.060 --> 41:16.060
它要知道匹配的结果

41:16.060 --> 41:17.060
有什么不一样

41:17.060 --> 41:19.060
因为弱扯这个主件里

41:19.060 --> 41:20.060
为什么要提供上下文

41:20.060 --> 41:21.060
它的History是一样的

41:21.060 --> 41:22.060
location是一样的

41:22.060 --> 41:24.060
只是匹配不一样

41:24.060 --> 41:25.060
所以说它要用一个新的上下文

41:25.060 --> 41:27.060
来进入一个匹配结果

41:27.060 --> 41:28.060
让后续的主件知道

41:28.060 --> 41:30.060
它到底是匹配的是什么情况

41:31.060 --> 41:32.060
它会有什么给上下文

41:33.060 --> 41:34.060
于是弱扯的主件

41:34.060 --> 41:35.060
做了一半天

41:35.060 --> 41:36.060
对弱强扯到的事情

41:36.060 --> 41:37.060
无非就是给它提供这么一个上下文

41:37.060 --> 41:38.060
这是它第一件事

41:38.060 --> 41:39.060
第二件事

41:39.060 --> 41:40.060
它做了一个什么事

41:40.060 --> 41:41.060
它做了一个就是

41:41.060 --> 41:42.060
根据你匹配的结果

41:42.060 --> 41:45.060
来决定我如何去渲染什么东西

41:45.060 --> 41:46.060
根据哪几个字

41:46.060 --> 41:47.060
根据旗有准

41:47.060 --> 41:48.060
Render Component的三个字

41:48.060 --> 41:50.060
来决定我到底去渲染什么东西

41:51.060 --> 41:52.060
如果有旗有准

41:52.060 --> 41:54.060
无论如何都会渲染旗有准

41:54.060 --> 41:56.060
如果说没有旗有准

41:56.060 --> 41:57.060
OK

41:57.060 --> 42:00.060
我就看一下有没有匹配

42:00.060 --> 42:01.060
没有匹配我就什么都不渲染

42:01.060 --> 42:02.060
如果匹配了过后了

42:02.060 --> 42:03.060
我就渲染

42:03.060 --> 42:04.060
如果有Render函数

42:04.060 --> 42:05.060
就调入Render函数

42:05.060 --> 42:06.060
如果没有Render函数

42:06.060 --> 42:07.060
那我就渲染Component

42:07.060 --> 42:09.060
并且把上下文的数据

42:09.060 --> 42:11.060
给它作为属性放进去

42:11.060 --> 42:12.060
对吧

42:12.060 --> 42:13.060
OK

42:13.060 --> 42:14.060
这就是Router这个主件

42:15.060 --> 42:17.060
这个主件就在Reaction Router里边

42:17.060 --> 42:18.060
Reaction Router DOM里边

42:18.060 --> 42:20.060
也没有对它进行啥操作

42:20.060 --> 42:21.060
没有就对它进行啥操作

42:21.060 --> 42:22.060
你就不用管它

42:23.060 --> 42:25.060
直接把Reaction Router DOM里边

42:25.060 --> 42:27.060
你直接把它导出就完事了

42:28.060 --> 42:29.060
好 下来

42:29.060 --> 42:31.060
又有事情可以做了

42:31.060 --> 42:32.060
把这东西写好

42:32.060 --> 42:34.060
把Router这个主件给它写出来

42:35.060 --> 42:37.060
这是关于Router这个主件

