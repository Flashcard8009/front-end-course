WEBVTT

00:01.460 --> 00:03.460
hello 大家好

00:03.460 --> 00:07.460
这一集我们来说一个新的一个算法的一个问题

00:07.460 --> 00:10.460
就是数的深度优先搜索

00:10.460 --> 00:12.460
我们说之前不是说过吗

00:12.460 --> 00:14.460
我们之前说的就叫二差数

00:14.460 --> 00:17.460
二差数和数实际上是不太一样的 是吧

00:17.460 --> 00:19.460
二差数只有两个差

00:19.460 --> 00:21.460
看起来比较简单

00:21.460 --> 00:23.460
数差比较多

00:23.460 --> 00:25.460
所以看起来比较复杂

00:25.460 --> 00:26.460
实际上也没多复杂 是吧

00:26.460 --> 00:28.460
我们今天就来简单的来写一下

00:28.460 --> 00:30.460
数的深度优先搜索

00:30.460 --> 00:32.460
48

00:32.460 --> 00:37.460
数的深度优先搜索

00:37.460 --> 00:42.340
我来建一个文件

00:42.340 --> 00:46.720
我们先随便的建一个数的节点

00:46.720 --> 00:47.720
算你建一个数的节点

00:47.720 --> 00:48.720
no的

00:48.720 --> 00:50.720
value

00:50.720 --> 00:52.720
然后this

00:52.720 --> 00:54.720
the value

00:54.720 --> 00:55.720
等于value

00:55.720 --> 00:57.720
this 的value等于value

00:57.720 --> 00:59.720
然后对于一个数而言

00:59.720 --> 01:01.720
不是二差数了

01:01.720 --> 01:05.720
数是不是可以有很多的chill

01:05.720 --> 01:06.720
是吧

01:06.720 --> 01:08.720
一个数是可以有很多的仔细点

01:08.720 --> 01:10.720
所以我的仔细点

01:10.720 --> 01:12.720
就不是lab的right了

01:12.720 --> 01:14.720
而是一个数组

01:14.720 --> 01:15.720
这样的话

01:15.720 --> 01:17.720
我们来讲是个做一棵数

01:17.720 --> 01:18.720
做一棵数

01:18.720 --> 01:20.720
找一棵多差的数

01:20.720 --> 01:22.720
看看前面有没有多差的数

01:24.720 --> 01:26.720
ok吧

01:26.720 --> 01:37.020
这样一棵二差数

01:37.020 --> 01:40.020
数的深度优先搜索

01:40.020 --> 01:49.680
数的深度优先搜索

01:49.680 --> 01:52.680
数的深度优先搜索

01:52.680 --> 01:54.680
1234566个节点是吧

01:54.680 --> 01:55.680
我们来创建一下

01:55.680 --> 01:58.680
创建一下6个节点

01:58.680 --> 02:01.680
were 一个

02:01.680 --> 02:04.680
A,B,C,D,E,F 是吧

02:04.680 --> 02:05.680
A

02:05.680 --> 02:07.680
等于no的

02:07.680 --> 02:09.680
A

02:09.680 --> 02:12.680
A,B,C,D,E,F

02:12.680 --> 02:19.680
A,B,C,D,E,F

02:19.680 --> 02:24.680
A,B,C,D,E,F

02:24.680 --> 02:28.680
然后A的孩子有C,B,F

02:28.680 --> 02:30.680
A的chill的

02:30.680 --> 02:32.680
chill的push

02:32.680 --> 02:40.780
C,B,F

02:40.780 --> 02:41.780
是吧

02:41.780 --> 02:42.780
A

02:42.780 --> 02:45.780
然后B的chill的是D和E

02:45.780 --> 02:48.780
B的chill的push

02:48.780 --> 02:56.850
D和E

02:56.850 --> 02:58.850
这样的话我们就过建出了一棵数

02:58.850 --> 02:59.850
是吧

02:59.850 --> 03:00.850
这棵数不是二三数

03:00.850 --> 03:02.850
然后我们来说

03:02.850 --> 03:05.860
dps

03:05.860 --> 03:11.940
如何来进行深度优先搜索

03:11.940 --> 03:12.940
dps

03:12.940 --> 03:14.940
我们要传入一个A是吧

03:14.940 --> 03:17.940
还是严谨性判断

03:17.940 --> 03:21.940
如果route等于空

03:21.940 --> 03:22.940
我们就return

03:22.940 --> 03:23.940
你说啥也别干

03:23.940 --> 03:24.940
就得了

03:24.940 --> 03:26.940
如果route不等于空

03:26.940 --> 03:33.940
肯定是先打印route的y6

03:33.940 --> 03:34.940
打印完当前的值

03:34.940 --> 03:36.940
深度优先搜索

03:36.940 --> 03:37.940
是吧

03:37.940 --> 03:38.940
我有几个孩子

03:38.940 --> 03:42.940
我就要对几个孩子进行给力

03:42.940 --> 03:43.940
were 一个

03:43.940 --> 03:45.940
I等于0

03:45.940 --> 03:51.940
I小于route的chill的lens

03:51.940 --> 03:53.940
I加加

03:53.940 --> 04:02.940
然后dpsroute的chill的df

04:02.940 --> 04:03.940
这样的方式去深搜

04:03.940 --> 04:05.940
我们来看一下

04:05.940 --> 04:09.940
看打印的是A,C,B,D,E,F

04:09.940 --> 04:13.940
A,C,B,D,E,F

04:13.940 --> 04:14.940
没有什么毛病

04:14.940 --> 04:17.940
从深度上去走

04:17.940 --> 04:24.940
因为我写的是B在F的前面

04:24.940 --> 04:26.940
但是实际上应该这样

04:26.940 --> 04:31.380
F再写

04:31.380 --> 04:34.380
这回就变成A,C,F,B,D,E了

04:34.380 --> 04:37.380
A,C,F,B,D,E

04:37.380 --> 04:38.380
先搜

04:38.380 --> 04:41.380
我都是先去一个分支里找

04:41.380 --> 04:43.380
这个分支往下走不了了

04:43.380 --> 04:46.380
我才会去换到另外一个分支

04:46.380 --> 04:48.380
我先可一个分支找

04:48.380 --> 04:49.380
这个分支找不了了

04:49.380 --> 04:51.380
我才会换到另外一个分支

04:51.380 --> 04:53.380
这就是深度优先搜索

04:53.380 --> 04:56.380
数的深搜

04:56.380 --> 04:58.380
那数的广搜

04:58.380 --> 05:00.380
什么样的

05:00.380 --> 05:01.380
想一下

05:01.380 --> 05:03.380
数的广搜会是什么样的

05:03.380 --> 05:04.380
我们下一集来说

05:04.380 --> 05:06.380
数的广度优先搜索

