WEBVTT

00:00.370 --> 00:06.370
哈喽 大家好 这一集我们来说线性数据结构的地规便利

00:06.370 --> 00:09.370
上一节课咱们简单的说了一个便利是吧

00:09.370 --> 00:12.370
我们再来写一个JS文件

00:12.370 --> 00:18.370
地规算法是大家所有人学算法的第一道卡

00:18.370 --> 00:22.370
因为很多人搞不清楚地规的逻辑

00:22.370 --> 00:26.370
但是这个东西没有办法 只能慢慢的去理解

00:26.370 --> 00:29.370
只能实际的去理解 多看几遍

00:30.370 --> 00:33.370
就像我当年学地规 那真的是

00:33.370 --> 00:37.370
可能看了几十遍 上百遍才能真正的理解得了地规

00:37.370 --> 00:40.370
这是一个AR 我们都知道便利一个数组

00:40.370 --> 00:43.370
便利一个数组的话 我们非常轻松

00:43.370 --> 00:46.370
便利AR 传的一个AR 我们就可以便利了 是吧

00:46.370 --> 00:50.370
判断一个 判空 AR不等于空

00:50.370 --> 00:54.370
如果AR等于空的话 就return 是吧

00:55.370 --> 00:59.370
然后if否则的话 我们就写个复讼环境性便利

00:59.370 --> 01:01.370
where you i等于0

01:01.370 --> 01:05.370
i小于AR的籃子

01:05.370 --> 01:08.370
然后console了点log AR

01:12.660 --> 01:14.660
我们用这样的方式

01:14.660 --> 01:17.660
就可以打印出来数组里的每一个元素了

01:17.660 --> 01:20.660
对吧 用这样的方式可以打印出来数组的每个元素

01:20.660 --> 01:24.660
但是我们说地规

01:24.660 --> 01:26.660
我们再来写一个地规

01:26.660 --> 01:30.660
快写了 这个大家一定要多练的

01:30.660 --> 01:36.660
你会发现很多的同学都没有我在上课的时候练的次数多

01:36.660 --> 01:45.280
this value等于y6 this nice等于空

01:45.280 --> 01:47.280
这是node 是吧

01:47.280 --> 01:49.280
where一个node 1

01:49.280 --> 01:51.280
等于new一个node

01:51.280 --> 01:55.780
1 2 3 4 5

01:55.780 --> 02:00.990
2 3 4 5

02:01.990 --> 02:05.990
这是5个节点

02:05.990 --> 02:09.990
node1的next等于node2

02:09.990 --> 02:12.990
node2的next等于node3

02:12.990 --> 02:16.990
node3的next等于node4

02:16.990 --> 02:21.990
node4的next等于node5

02:21.990 --> 02:25.990
这样的5个节点

02:25.990 --> 02:27.990
这是一个练秒 是吧

02:27.990 --> 02:30.990
我们上一节课的时候说

02:30.990 --> 02:36.900
变例练表怎么变例来着

02:36.900 --> 02:38.900
传入一个root 是吧

02:38.900 --> 02:44.600
然后呢 value2

02:44.600 --> 02:48.600
where一个time等于root

02:48.600 --> 02:50.600
然后怎么办

02:50.600 --> 02:56.700
如果time不等于空

02:56.700 --> 03:00.700
我们就打印time

03:00.700 --> 03:02.700
否则

03:02.700 --> 03:04.700
我们就break 是吧

03:04.700 --> 03:05.700
退出这个循环

03:05.700 --> 03:11.700
然后time不等于time不等next

03:11.700 --> 03:13.700
这个是循环的方式 是吧

03:13.700 --> 03:16.700
循环变例这个练表的方式

03:16.700 --> 03:20.700
但是我们希望大家在初学的时候不要用这种方式

03:20.700 --> 03:21.700
这种方式好不好

03:21.700 --> 03:23.700
这种方式其实是最好的

03:23.700 --> 03:28.700
但是它极其不利于你学习后面的很多的算法

03:28.700 --> 03:29.700
所以我们今天来说一个

03:29.700 --> 03:32.700
地规的变例的方式

03:32.700 --> 03:34.700
地规的变例的方式怎么变例呢

03:34.700 --> 03:35.700
看好了

03:35.700 --> 03:37.700
传进来一个root 是吧

03:37.700 --> 03:41.700
还是碰空 root

03:41.700 --> 03:45.700
如果等于空

03:45.700 --> 03:47.700
我直接就return

03:47.700 --> 03:48.700
没啥问题 是吧

03:48.700 --> 03:49.700
你给我传进来一个空

03:49.700 --> 03:50.700
我就什么都不打了 是吧

03:50.700 --> 03:52.700
否则的话

03:52.700 --> 03:58.590
cancel了点node root的value

03:58.590 --> 04:00.590
如果不维空

04:00.590 --> 04:01.590
我就打印它的值

04:01.590 --> 04:03.590
如果不维空

04:03.590 --> 04:05.590
我就打印它的值

04:05.590 --> 04:06.590
对吧

04:06.590 --> 04:08.590
如果维空的话

04:08.590 --> 04:09.590
我就直接return

04:09.590 --> 04:10.590
如果不维空的话

04:10.590 --> 04:11.590
就直接打印它的值

04:11.590 --> 04:12.590
但是你会发现

04:12.590 --> 04:14.590
我现在只能打印一个阶段的值

04:14.590 --> 04:15.590
对吧

04:15.590 --> 04:16.590
下一个阶段的值

04:16.590 --> 04:17.590
我怎么打印的

04:17.590 --> 04:19.590
我没有办法打印下一个阶段

04:19.590 --> 04:20.590
对吧

04:20.590 --> 04:21.590
怎么办的

04:21.590 --> 04:22.590
再调一下自己

04:22.590 --> 04:24.590
这个函数是干嘛的

04:24.590 --> 04:25.590
函数不就是

04:25.590 --> 04:26.590
如果有当前的值

04:26.590 --> 04:27.590
我就打印了

04:27.590 --> 04:28.590
是吧

04:28.590 --> 04:29.590
然后打印完了之后

04:29.590 --> 04:30.590
去调下一个

04:30.590 --> 04:31.590
如果维空的话就退出

04:31.590 --> 04:33.590
所以我就调下一个

04:33.590 --> 04:35.590
root的node

04:35.590 --> 04:36.590
把我的下一个节点

04:36.590 --> 04:37.590
作为根节点

04:37.590 --> 04:40.590
再传到这个方法里

04:40.590 --> 04:41.590
自己调自己

04:41.590 --> 04:42.590
我们一直说自己调自己

04:42.590 --> 04:43.590
就是地规

04:43.590 --> 04:44.590
其实这就是一个

04:44.590 --> 04:48.590
非常典型的例子

04:48.590 --> 04:49.590
把我的下一个

04:49.590 --> 04:50.590
把root的node的

04:50.590 --> 04:53.590
再传建便利另一个的方法里

04:53.590 --> 04:54.590
是吧

04:54.590 --> 04:55.590
它每一次

04:55.590 --> 04:56.590
虽然只打印一个节点

04:56.590 --> 04:57.590
但是它还会

04:57.590 --> 04:58.590
继续线下传递

04:58.590 --> 04:59.590
是吧

04:59.590 --> 05:00.590
传递到什么时候为止

05:00.590 --> 05:01.590
传递到维空的为止

05:01.590 --> 05:02.590
比如说5

05:02.590 --> 05:04.590
5的Nex的就维空了

05:04.590 --> 05:05.590
是吧

05:05.590 --> 05:06.590
因为默认Nex的维空

05:06.590 --> 05:07.590
对吧

05:07.590 --> 05:09.590
5的Nex的维空

05:09.590 --> 05:10.590
我们把空传进了

05:10.590 --> 05:11.590
便利的这个另一个里面

05:11.590 --> 05:12.590
就是Return的

05:12.590 --> 05:13.590
就不会再线下传了

05:13.590 --> 05:14.590
记住

05:14.590 --> 05:15.590
便利

05:15.590 --> 05:19.220
便利

05:19.220 --> 05:21.220
这个地规便利

05:21.220 --> 05:24.220
必须有出口

05:24.220 --> 05:28.920
有出口

05:28.920 --> 05:29.920
啥叫出口

05:29.920 --> 05:30.920
就是Return的地方

05:30.920 --> 05:31.920
你想想

05:31.920 --> 05:33.920
如果你每一个都打印

05:33.920 --> 05:34.920
并且掉下来的话

05:34.920 --> 05:36.920
是不是就无限的循环下去了

05:36.920 --> 05:37.920
对吧

05:37.920 --> 05:38.920
你就无限的循环下去了

05:38.920 --> 05:39.920
它一直会掉

05:39.920 --> 05:40.920
一直会掉

05:40.920 --> 05:42.920
可能掉到抱错

05:42.920 --> 05:43.920
就不掉了

05:43.920 --> 05:44.920
是吧

05:44.920 --> 05:45.920
但是我们说了

05:45.920 --> 05:47.920
算法题是不允许抱错的

05:47.920 --> 05:48.920
然后

05:48.920 --> 05:49.920
所以我们就必须得

05:49.920 --> 05:51.920
找一个时候让它停止

05:51.920 --> 05:53.920
这个停止的点

05:53.920 --> 05:54.920
就是出口

05:54.920 --> 05:56.920
所以地规便利必须有出口

05:56.920 --> 05:57.920
这句话

05:57.920 --> 05:58.920
慢慢理解

05:58.920 --> 05:59.920
以后我们会遇到

05:59.920 --> 06:00.920
非常多的

06:00.920 --> 06:01.920
找出口的线下

06:01.920 --> 06:02.920
所以说

06:02.920 --> 06:03.920
很多的时候

06:03.920 --> 06:04.920
地规便利

06:04.920 --> 06:05.920
甚至都是先找出口

06:05.920 --> 06:06.920
后写地规

06:06.920 --> 06:07.920
既然我这行就是

06:07.920 --> 06:08.920
先写一个Return

06:08.920 --> 06:10.920
然后再慢慢的写地规

06:10.920 --> 06:11.920
这就是

06:12.920 --> 06:14.920
链表的地规便利

06:14.920 --> 06:16.920
然后咱们再说点个外的

06:16.920 --> 06:17.920
有的时候

06:17.920 --> 06:18.920
同学说

06:18.920 --> 06:19.920
链表能地规便利

06:19.920 --> 06:20.920
那数组

06:20.920 --> 06:21.920
能不能地规便利

06:21.920 --> 06:22.920
但其实数组

06:22.920 --> 06:23.920
肯定是可以的

06:23.920 --> 06:24.920
对吧

06:24.920 --> 06:26.920
这点也可以地规便利

06:26.920 --> 06:27.920
咱们再掩饰

06:27.920 --> 06:28.920
数组地规便利之前

06:28.920 --> 06:29.920
我们先来

06:29.920 --> 06:30.920
验证一下

06:30.920 --> 06:31.920
链表的地规便利

06:32.920 --> 06:33.920
传说一个诺德译

06:33.920 --> 06:34.920
我打印一下试试

06:36.920 --> 06:37.920
12345

06:37.920 --> 06:38.920
没有问题是吧

06:38.920 --> 06:39.920
然后我们来说

06:39.920 --> 06:40.920
数组的地规便利

06:40.920 --> 06:42.920
数组的最好的便利方式

06:42.920 --> 06:43.920
就是循环

06:43.920 --> 06:44.920
是吧

06:44.920 --> 06:45.920
因为数组是直到长度的

06:45.920 --> 06:47.920
数组是直到长度的

06:47.920 --> 06:48.920
所以我们

06:48.920 --> 06:49.920
要是如果把它改成

06:49.920 --> 06:51.920
地规便利的话

06:51.920 --> 06:52.920
怎么变

06:53.920 --> 06:54.920
就是说你现在给我

06:54.920 --> 06:55.920
传进了一个AR

06:56.920 --> 06:57.920
然后

06:57.920 --> 06:59.920
我还需要知道的是

06:59.920 --> 07:00.920
我现在当前需要

07:00.920 --> 07:01.920
打印的试几

07:01.920 --> 07:02.920
打一个i

07:04.920 --> 07:05.920
那我怎么办

07:06.920 --> 07:07.920
衣服

07:08.920 --> 07:09.920
AR

07:09.920 --> 07:10.920
等于空

07:11.920 --> 07:12.920
我得return是吧

07:12.920 --> 07:13.920
AR不能为空

07:13.920 --> 07:14.920
对吧

07:14.920 --> 07:15.920
然后或者

07:16.920 --> 07:17.920
AR的籃子

07:19.920 --> 07:20.920
小鱼

07:21.920 --> 07:22.920
等于

07:24.920 --> 07:25.920
对吧

07:25.920 --> 07:26.920
你这个数组

07:26.920 --> 07:27.920
长度为10

07:27.920 --> 07:29.920
你最多i能取到几的

07:29.920 --> 07:30.920
数组长度为10

07:30.920 --> 07:31.920
i能取到几的

07:31.920 --> 07:32.920
i是不是能取到9

07:32.920 --> 07:33.920
因为0到9

07:33.920 --> 07:34.920
就是10个数

07:34.920 --> 07:35.920
是吧

07:35.920 --> 07:37.920
所以说籃子必须得小鱼等于

07:39.920 --> 07:40.920
这个是这一点

07:40.920 --> 07:41.920
衣服

07:41.920 --> 07:42.920
AR等于空

07:42.920 --> 07:43.920
或者是AR的籃子

07:43.920 --> 07:44.920
小鱼等于i

07:44.920 --> 07:45.920
这种情况

07:45.920 --> 07:47.920
然后我给它return掉

07:47.920 --> 07:48.920
否则

07:48.920 --> 07:49.920
我觉得打印的是吧

07:49.920 --> 07:50.920
坑瘦了

07:51.920 --> 07:52.920
点log

07:53.920 --> 07:54.920
AR

07:57.920 --> 07:58.920
坑瘦了点log

07:58.920 --> 07:59.920
AR

07:59.920 --> 08:00.920
打印完了当前

08:00.920 --> 08:01.920
这个还不行

08:01.920 --> 08:02.920
是吧

08:02.920 --> 08:03.920
还得再掉利

08:03.920 --> 08:04.920
用一下便利AR

08:04.920 --> 08:05.920
把AR传进去

08:05.920 --> 08:07.920
把i加1传进去

08:08.920 --> 08:09.920
才能完事

08:09.920 --> 08:10.920
我把下面这个

08:10.920 --> 08:11.920
诸调

08:11.920 --> 08:12.920
我打印一下这个

08:13.920 --> 08:14.920
便利

08:16.920 --> 08:17.920
便利

08:17.920 --> 08:18.920
AR

08:18.920 --> 08:19.920
传AR

08:19.920 --> 08:20.920
喝啥

08:21.920 --> 08:22.920
喝i是吧

08:22.920 --> 08:23.920
i是几

08:23.920 --> 08:24.920
我们传一个0是吧

08:24.920 --> 08:25.920
便利

08:25.920 --> 08:26.920
你想从第几位开始便利

08:26.920 --> 08:27.920
你就传第几位

08:28.920 --> 08:32.260
对吧

08:32.260 --> 08:33.260
12345678

08:34.260 --> 08:35.260
用这样的方式

08:35.260 --> 08:36.260
我们就可以用

08:36.260 --> 08:37.260
地规

08:37.260 --> 08:38.260
来便利一个数组

08:38.260 --> 08:39.260
但是这种方式

08:39.260 --> 08:40.260
地规便利数组

08:40.260 --> 08:41.260
是既不推荐

08:41.260 --> 08:42.260
也不常用

08:43.260 --> 08:44.260
但是

08:44.260 --> 08:45.260
地规便利链表

08:45.260 --> 08:46.260
是非常常见的

08:46.260 --> 08:47.260
虽然我们说

08:47.260 --> 08:49.260
用循环便利链表的性能

08:49.260 --> 08:50.260
更好

08:50.260 --> 08:52.260
但是有很多的场景下

08:52.260 --> 08:53.260
我们是需要用

08:53.260 --> 08:55.260
地规去便利链表的

08:56.260 --> 08:57.260
因为在后面

08:57.260 --> 08:58.260
我们就可以看到

08:58.260 --> 08:59.260
在后面又

09:00.260 --> 09:01.260
有一些算法的时候

09:01.260 --> 09:02.260
我们就可以看的

09:02.260 --> 09:04.260
用地规去便利链表的话

09:04.260 --> 09:07.260
能够节省大量的开发时间

09:07.260 --> 09:08.260
和开发效率

09:10.260 --> 09:11.260
这就是我们的

09:11.260 --> 09:12.260
所说的

09:12.260 --> 09:13.260
地规便利

09:13.260 --> 09:14.260
大家回去多练一下

09:14.260 --> 09:15.260
把这个链表的

09:15.260 --> 09:16.260
地规的便利的方式

09:16.260 --> 09:18.260
我们给它练熟

09:18.260 --> 09:19.260
后面

09:19.260 --> 09:20.260
我们有很多的地方

09:20.260 --> 09:21.260
会用到地规

09:22.260 --> 09:23.260
这就是我们这一节的内容

