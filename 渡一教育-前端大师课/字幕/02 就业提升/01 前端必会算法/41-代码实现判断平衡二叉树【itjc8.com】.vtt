WEBVTT

00:01.140 --> 00:03.140
Hello 大家好啊

00:03.140 --> 00:09.140
这一集我们用代码来做一个方式来写一个功能

00:09.140 --> 00:12.140
来判断一棵树是否平行二三树

00:12.140 --> 00:15.140
首先我们先随机的来构建一棵树

00:15.140 --> 00:17.140
来写一个节点的定义

00:17.140 --> 00:19.140
this is the value等于value

00:19.140 --> 00:21.140
我已经写过很多遍了

00:21.140 --> 00:22.140
this is the left等于空

00:22.140 --> 00:24.140
this is the right等于空

00:26.140 --> 00:28.140
这是一个最基本的一个节点

00:28.140 --> 00:34.140
然后弯一个a等于nu一个node

00:34.140 --> 00:36.140
比如说我来实现一棵奶咖树

00:36.140 --> 00:41.140
实现一下这棵树

00:41.140 --> 00:43.140
实现一下这棵树

00:45.140 --> 00:46.140
节点好多呀

00:46.140 --> 00:49.140
一二三四五六七八九

00:49.140 --> 00:51.140
居然一共有九个节点

00:51.140 --> 00:53.140
等于nu一个node

00:54.140 --> 00:55.140
a

00:56.140 --> 00:59.140
二三四五六七八九

00:59.140 --> 01:01.140
好吧 九个就九个吧

01:01.140 --> 01:03.140
都有什么来着

01:04.140 --> 01:06.140
a 我的天

01:06.140 --> 01:07.140
我给你们统一一下

01:07.140 --> 01:17.510
b c d e f g h g

01:17.510 --> 01:20.510
我们跳过i跟e太像了

01:23.780 --> 01:31.780
a b c d e f g h g

01:31.780 --> 01:41.150
然后我们把后面来给看

01:41.150 --> 01:47.150
a b c d e f g h g

01:47.150 --> 01:50.150
然后a的left等于b

01:50.150 --> 01:52.150
a的left等于b

01:54.150 --> 01:57.150
a的right等于c

01:58.150 --> 02:01.150
b的left等于d

02:02.150 --> 02:05.150
b的right等于e

02:06.150 --> 02:10.150
c的left等于f

02:11.150 --> 02:14.150
c的right等于g

02:15.150 --> 02:20.150
然后d的right等于h

02:21.150 --> 02:23.150
e的right等于j

02:26.620 --> 02:28.620
这样的话我们就构建出来了

02:28.620 --> 02:29.620
一颗二三数

02:29.620 --> 02:31.620
构建出来这样的一颗二三数

02:31.620 --> 02:33.620
然后我们希望写一个方法

02:37.620 --> 02:39.620
传入一个route来判断

02:39.620 --> 02:41.620
以route为根结点的这颗二三数

02:41.620 --> 02:43.620
是否为平衡二三数

02:43.620 --> 02:47.950
这个怎么玩

02:47.950 --> 02:48.950
这个怎么玩

02:48.950 --> 02:51.950
首先我们必须得写出一个功能来干嘛

02:51.950 --> 02:54.950
就是获取最深的一个层数

02:56.950 --> 02:57.950
给我传入一颗二三数

02:57.950 --> 02:59.950
这颗二三数我得返回给他

02:59.950 --> 03:01.950
这颗二三数有多深

03:01.950 --> 03:03.950
先写一个getdip

03:03.950 --> 03:05.950
getdip怎么写

03:05.950 --> 03:07.950
getdip

03:07.950 --> 03:09.950
e

03:09.950 --> 03:11.950
route等于空

03:11.950 --> 03:13.950
route是什么呀

03:13.950 --> 03:15.950
一层都没有是吧

03:15.950 --> 03:17.950
route是0

03:17.950 --> 03:18.950
else

03:18.950 --> 03:22.900
else是什么

03:22.900 --> 03:24.900
return

03:24.900 --> 03:25.900
怎么样

03:25.900 --> 03:27.900
else呢

03:27.900 --> 03:29.900
route不为空

03:29.900 --> 03:30.900
是吧

03:30.900 --> 03:32.900
它不为空的情况下

03:32.900 --> 03:34.900
我们要判断什么

03:34.900 --> 03:36.900
route不为空的情况下

03:36.900 --> 03:38.900
我们要干什么

03:38.900 --> 03:40.900
我们要看左边的神

03:40.900 --> 03:42.900
还是右边的神

03:42.900 --> 03:43.900
是吧

03:43.900 --> 03:45.900
route一个left的dip

03:45.900 --> 03:47.900
等于什么

03:47.900 --> 03:49.900
getdip

03:49.900 --> 03:51.900
route的left

03:51.900 --> 03:54.900
route一个right的dip

03:54.900 --> 03:57.900
等于getdip

03:57.900 --> 04:00.900
route的right

04:00.900 --> 04:01.900
是吧

04:01.900 --> 04:02.900
然后我要看左边的神

04:02.900 --> 04:03.900
还是右边的神

04:03.900 --> 04:05.900
return

04:05.900 --> 04:08.900
mastermax

04:08.900 --> 04:10.900
left的dip

04:10.900 --> 04:11.900
right的dip

04:11.900 --> 04:12.900
不管哪边的神

04:12.900 --> 04:14.900
我反正取的是比较深的那一边

04:14.900 --> 04:16.900
还得加上我当前的这一层

04:16.900 --> 04:17.900
是吧

04:17.900 --> 04:18.900
左门是三层

04:18.900 --> 04:19.900
右门是两层

04:19.900 --> 04:20.900
我得用左门的是吧

04:20.900 --> 04:22.900
还得加上我当前还有一层

04:22.900 --> 04:23.900
还得我当前还有一层

04:23.900 --> 04:24.900
所以得加一

04:24.900 --> 04:26.900
这就是一个getdip的一个算

04:26.900 --> 04:28.900
就像我现在这个数

04:28.900 --> 04:30.900
分搜了

04:30.900 --> 04:34.900
点loggetdip

04:34.900 --> 04:36.900
A

04:36.900 --> 04:39.900
看看我能得到数字级

04:39.900 --> 04:43.660
4

04:43.660 --> 04:44.660
1

04:44.660 --> 04:45.660
2

04:45.660 --> 04:46.660
3

04:46.660 --> 04:47.660
4

04:47.660 --> 04:48.660
对吧

04:48.660 --> 04:49.660
我如果传进去的B

04:49.660 --> 04:50.660
B这个指数有几层

04:50.660 --> 04:51.660
三层是吧

04:51.660 --> 04:53.660
我们看能不能得到的是3

04:54.660 --> 04:55.660
是不是3

04:55.660 --> 04:56.660
没有问题

04:56.660 --> 04:57.660
对吧

04:57.660 --> 04:58.660
所以说getdip

04:58.660 --> 05:00.660
获取刚才说的深度

05:00.660 --> 05:02.660
是这个功能的一个

05:02.660 --> 05:04.660
基本的一个功能

05:04.660 --> 05:05.660
一个最基本的功能

05:05.660 --> 05:07.660
如何判断一个数字

05:07.660 --> 05:09.660
是否为balance

05:09.660 --> 05:11.660
如果

05:11.660 --> 05:13.660
route等于空

05:13.660 --> 05:14.660
如果route等于空

05:14.660 --> 05:16.660
那它是平衡的吗

05:16.660 --> 05:17.660
我们假设是平衡的

05:17.660 --> 05:18.660
是吧

05:18.660 --> 05:19.660
因为空的话

05:19.660 --> 05:20.660
它也没有左门

05:20.660 --> 05:21.660
也没有右门是吧

05:21.660 --> 05:22.660
它也不可能超过2

05:22.660 --> 05:27.740
所以它就估计算它是平衡的

05:27.740 --> 05:28.740
如果不为空

05:28.740 --> 05:29.740
怎么办

05:29.740 --> 05:30.740
不为空

05:30.740 --> 05:32.740
我就得看它的左字数

05:32.740 --> 05:33.740
和右字数的深度

05:33.740 --> 05:34.740
是吧

05:34.740 --> 05:37.740
where一个life的dip

05:37.740 --> 05:39.740
等于什么

05:39.740 --> 05:41.740
等于getdip

05:41.740 --> 05:43.740
route的life

05:43.740 --> 05:46.740
where一个right的dip

05:46.740 --> 05:50.310
等于getdip

05:50.310 --> 05:52.310
route的right

05:52.310 --> 05:54.310
获取一下左边的深度

05:54.310 --> 05:56.310
获取右边的深度

05:56.310 --> 05:57.310
然后

05:57.310 --> 05:59.310
我让

05:59.310 --> 06:00.310
它俩相见

06:00.310 --> 06:01.310
看它差

06:01.310 --> 06:03.310
是否超过1

06:03.310 --> 06:04.310
如何看差

06:04.310 --> 06:06.310
是我超过1

06:06.310 --> 06:07.310
是不是

06:07.310 --> 06:08.310
反正就是life的

06:08.310 --> 06:09.310
getroute就行了

06:09.310 --> 06:10.310
是吧

06:10.310 --> 06:11.310
然后看它的绝对值

06:11.310 --> 06:12.310
是否大于1

06:12.310 --> 06:13.310
对吧

06:13.310 --> 06:16.310
max.abf

06:16.310 --> 06:18.310
等于life的dip

06:18.310 --> 06:21.310
剪缺route的dip

06:21.310 --> 06:23.310
看它的绝对值

06:23.310 --> 06:24.310
是否大于1

06:24.310 --> 06:26.310
如果它的绝对值大于1了

06:26.310 --> 06:27.310
说明什么

06:27.310 --> 06:28.310
说明

06:28.310 --> 06:29.310
不平衡

06:29.310 --> 06:31.310
直接return

06:31.310 --> 06:33.310
first就可以了

06:33.310 --> 06:34.310
否则的话

06:34.310 --> 06:36.310
代表当前的这个结点

06:36.310 --> 06:37.310
是平衡的

06:37.310 --> 06:38.310
我还得看

06:38.310 --> 06:39.310
下面这两个结点

06:39.310 --> 06:40.310
是不是平衡的

06:40.310 --> 06:42.310
那就return什么呢

06:42.310 --> 06:44.310
exbalance

06:44.310 --> 06:46.310
route的life

06:46.310 --> 06:48.310
还有exbalance

06:48.310 --> 06:50.310
route的right

06:50.310 --> 06:51.310
你说这个是雨的关系

06:51.310 --> 06:53.310
还是起货的关系

06:53.310 --> 06:54.310
得左边平衡

06:54.310 --> 06:55.310
右边也平衡

06:55.310 --> 06:57.310
它才能算是平衡

06:57.310 --> 06:58.310
是吧

06:58.310 --> 07:00.310
所以说它是一个起的关系

07:00.310 --> 07:01.310
用这种方式

07:01.310 --> 07:03.310
我们可以判断sbalace

07:03.310 --> 07:04.310
我们可以试一下

07:04.310 --> 07:07.310
可搜索点logsbalace

07:07.310 --> 07:08.310
看一下a这块差数

07:08.310 --> 07:10.310
是否是平衡的

07:10.310 --> 07:11.310
触

07:11.310 --> 07:12.310
是吧

07:12.310 --> 07:13.310
我们看一下b这块差数

07:13.310 --> 07:14.310
是否也平衡的

07:14.310 --> 07:15.310
是不是也是触

07:15.310 --> 07:16.310
对于b来说也是平衡的

07:16.310 --> 07:17.310
对吧

07:17.310 --> 07:18.310
我们删除一个

07:18.310 --> 07:20.310
我们删除一个

07:20.310 --> 07:21.310
j

07:21.310 --> 07:22.310
删除一个j

07:22.310 --> 07:24.310
e的right

07:24.310 --> 07:25.310
e的right

07:25.310 --> 07:27.310
我让它去掉一个j

07:27.310 --> 07:28.310
看现在去掉这的话

07:28.310 --> 07:30.310
是不是平衡的

07:30.310 --> 07:31.310
假设说去掉了j

07:31.310 --> 07:32.310
这个数是平衡的

07:32.310 --> 07:33.310
是平衡的

07:33.310 --> 07:34.310
是吧

07:34.310 --> 07:35.310
a左边3层

07:35.310 --> 07:36.310
右边2层

07:36.310 --> 07:37.310
b左边2层

07:37.310 --> 07:38.310
右边1层

07:38.310 --> 07:39.310
c左边1层

07:39.310 --> 07:40.310
右边1层

07:40.310 --> 07:41.310
还应该是平衡的

07:41.310 --> 07:42.310
我们来看一下

07:42.310 --> 07:43.310
依然是处

07:43.310 --> 07:44.310
对吧

07:44.310 --> 07:45.310
我们再去掉个e

07:45.310 --> 07:46.310
去掉了一个e

07:46.310 --> 07:48.310
把b的右边也给去掉

07:51.310 --> 07:52.310
这回应该是不平衡的吧

07:52.310 --> 07:54.310
我们希望得到的是一个force

07:54.310 --> 07:55.310
是吧

07:55.310 --> 07:56.310
force

07:56.310 --> 07:57.310
是吧

07:57.310 --> 07:59.310
我们可以用asbalance

07:59.310 --> 08:01.310
方法来判断一颗二叉数

08:01.310 --> 08:03.310
是否为平衡的

08:03.310 --> 08:06.310
用asbalance的方法

08:06.310 --> 08:07.310
来判断一颗二叉数

08:07.310 --> 08:08.310
是否为平衡的

08:08.310 --> 08:10.310
这种方式就能够检验

08:10.310 --> 08:12.310
我们随机产生一万个数

08:12.310 --> 08:13.310
生成二叉数

08:13.310 --> 08:14.310
是否为平衡的

08:14.310 --> 08:16.310
答案几乎是肯定的

08:16.310 --> 08:17.310
因为你压根也没有

08:17.310 --> 08:19.310
故意让它平衡

08:19.310 --> 08:21.310
它一定是不平衡的

08:21.310 --> 08:23.310
我们如何让一颗

08:23.310 --> 08:25.310
不平衡的二叉数

08:25.310 --> 08:27.310
逐渐的变得平衡呢

08:27.310 --> 08:30.310
我们下一集就开始

08:30.310 --> 08:33.310
我们将不平衡二叉数

08:33.310 --> 08:34.310
转换于平衡二叉数的

08:34.310 --> 08:35.310
一个转换之路

08:35.310 --> 08:37.310
下一集我们讲

08:37.310 --> 08:39.310
二叉数的单选

08:39.310 --> 08:40.310
左单选和右单选

08:40.310 --> 08:41.310
我们下集见

