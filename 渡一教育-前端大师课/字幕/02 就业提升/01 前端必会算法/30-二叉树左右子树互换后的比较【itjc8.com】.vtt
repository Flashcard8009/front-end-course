WEBVTT

00:01.140 --> 00:03.140
哈喽 大家好吧

00:03.140 --> 00:06.140
上一集我们说了两棵杀树的比较

00:06.140 --> 00:08.140
但是我们抛出了一个问题

00:08.140 --> 00:10.140
左右子树互换了之后

00:10.140 --> 00:12.140
还是不是同一棵杀树

00:12.140 --> 00:15.140
上一集我们说的这种是左右子树互换了之后

00:15.140 --> 00:17.140
不是同一棵杀树 是吧

00:17.140 --> 00:19.140
因为我的左子树就和左子树比

00:19.140 --> 00:20.140
两个左子树不一样

00:20.140 --> 00:21.140
我就认为你不是同一棵杀树

00:21.140 --> 00:22.140
不相等

00:22.140 --> 00:24.140
两棵杀树就不相等 是吧

00:24.140 --> 00:26.140
右子树也只和右子树相比

00:26.140 --> 00:27.140
如果两个右子树不相等的话

00:27.140 --> 00:29.140
我们也认为不是同一棵杀树

00:29.140 --> 00:31.140
那我们这一集

00:32.140 --> 00:34.140
来写一个算法来判断

00:34.140 --> 00:37.140
左右子树如果互换了

00:37.140 --> 00:39.140
左右子树如果互换了

00:39.140 --> 00:42.140
还要判断是否相等

00:42.140 --> 00:43.140
怎么来做

00:44.140 --> 00:46.140
左右子树是允许互换的

00:46.140 --> 00:47.140
我们还要判断

00:47.140 --> 00:50.140
刚才之前那种是左子树和左子树判断

00:50.140 --> 00:51.140
是吧

00:51.140 --> 00:53.140
这个时候我们还需要再来算一种

00:53.140 --> 00:55.140
右子树和右子树判断

00:56.140 --> 00:58.140
是吧 左子树和右子树

00:58.140 --> 01:00.140
是吧 只有这么情况 是吧

01:00.140 --> 01:03.140
A的左子树要么对着你们的B的左子树

01:03.140 --> 01:05.140
要么B对着B的右子树

01:05.140 --> 01:07.140
是吧 这就要互换 是吧

01:07.140 --> 01:09.140
你不能出来一个中间的子树

01:09.140 --> 01:11.140
没有 是吧 只有这两种情况

01:11.140 --> 01:13.140
如果左子树对左子树了

01:13.140 --> 01:15.140
那么右子树就只能对右子树 是吧

01:15.140 --> 01:17.140
如果左子树对右子树了

01:17.140 --> 01:19.140
那么右子树就得对左子树

01:20.140 --> 01:22.140
所以我们这块要改一下

01:24.140 --> 01:26.140
compire tree

01:27.140 --> 01:29.140
root1的life

01:30.140 --> 01:32.140
root2的life

01:33.140 --> 01:35.140
且

01:35.140 --> 01:37.140
compire tree

01:37.140 --> 01:40.140
root1的right

01:41.140 --> 01:43.140
root2的right

01:43.140 --> 01:47.140
这是我们之前那种写法的减写 是吧

01:47.140 --> 01:49.140
这是第一种情况

01:50.140 --> 01:52.140
对吧 左边左边B

01:52.140 --> 01:53.140
右边右边B

01:53.140 --> 01:55.140
但是我们现在要加一点

01:55.140 --> 01:59.150
货

01:59.150 --> 02:00.150
左边

02:00.150 --> 02:02.150
1的左边和2的

02:02.150 --> 02:04.150
右边B

02:04.150 --> 02:09.450
且

02:09.450 --> 02:11.450
1的右边

02:11.450 --> 02:13.450
和2的

02:13.450 --> 02:17.270
左边B

02:19.270 --> 02:21.270
左边和右边B

02:21.270 --> 02:23.270
右边和左边B

02:23.270 --> 02:25.270
它俩是货的关系

02:25.270 --> 02:27.270
有一边的比较相当的

02:27.270 --> 02:28.270
它就相当的

02:28.270 --> 02:30.270
对吧 你既然左左右不能相当

02:30.270 --> 02:32.270
我看你左右右左能不能相当

02:32.270 --> 02:33.270
如果这样能相当的话

02:33.270 --> 02:35.270
我认为你是拧过来了之后

02:35.270 --> 02:36.270
相当

02:36.270 --> 02:37.270
我也认为是相当

02:39.270 --> 02:40.270
OK吧

02:40.270 --> 02:41.270
我们来试一下

02:41.270 --> 02:42.270
来构建一下

02:42.270 --> 02:43.270
我们先看看

02:43.270 --> 02:45.270
上面这个树不变

02:45.270 --> 02:46.270
然后我们来构建一下

02:52.270 --> 02:53.270
怎么给我来的安地饭呢

03:00.940 --> 03:01.940
树 是吧

03:01.940 --> 03:02.940
不变的话还是树

03:02.940 --> 03:04.940
靠了 我给左右互换是吧

03:04.940 --> 03:06.940
之前A的左边是C

03:06.940 --> 03:08.940
A的右边是B 是吧

03:08.940 --> 03:10.940
我现在让

03:10.940 --> 03:11.940
A2的

03:11.940 --> 03:13.940
右边是C2

03:14.940 --> 03:16.940
左边是B2

03:16.940 --> 03:21.150
是吧 给它拧过来一下

03:21.150 --> 03:23.150
左右给它互换一下位置

03:23.150 --> 03:24.150
相当于什么呢

03:24.150 --> 03:27.660
相当于我现在让它

03:27.660 --> 03:29.660
这是一个新的二大树

03:29.660 --> 03:31.660
C在右边

03:32.660 --> 03:43.650
B在左边

03:43.650 --> 03:45.650
OK

03:55.210 --> 04:08.860
移到最后面

04:08.860 --> 04:10.860
相当于这种情况

04:10.860 --> 04:11.860
跟它对称的是吧

04:11.860 --> 04:12.860
它的B在右边

04:12.860 --> 04:13.860
我们的B在左边

04:13.860 --> 04:14.860
它的C在左边

04:14.860 --> 04:15.860
我的C在右边

04:15.860 --> 04:16.860
其他它都一样

04:16.860 --> 04:17.860
左右互换

04:17.860 --> 04:18.860
我们有的时候

04:18.860 --> 04:19.860
认为这是一种镜像是吧

04:19.860 --> 04:20.860
我们认为

04:20.860 --> 04:22.860
有的时候是相当的

04:23.860 --> 04:24.860
所以我们看看

04:25.860 --> 04:26.860
A2的Ride是C2

04:26.860 --> 04:28.860
A2的Ride是C2

04:28.860 --> 04:30.860
A2的Live是B2

04:30.860 --> 04:32.860
看看这种情况

04:32.860 --> 04:33.860
能不能相当

04:34.860 --> 04:37.170
是不是也是处了

04:37.170 --> 04:38.170
它是走了

04:38.170 --> 04:40.170
这一条情况了是吧

04:40.170 --> 04:42.170
E的Live和R的RideB

04:43.170 --> 04:45.170
E的Ride和R的Live

04:46.170 --> 04:47.170
这样的情况下

04:47.170 --> 04:50.170
能判断在左右互换

04:50.170 --> 04:51.170
情况下

04:51.170 --> 04:53.170
左右指数

04:53.170 --> 04:54.170
旋转

04:54.170 --> 04:55.170
翻转的情况下

04:56.170 --> 04:57.170
两旁是R树

04:57.170 --> 04:58.170
是否相当

04:58.170 --> 04:59.170
两旁是R树

04:59.170 --> 05:00.170
是否相当

05:00.170 --> 05:02.170
这是一种特殊的一种情况

05:02.170 --> 05:03.170
如果要去彼时

05:03.170 --> 05:04.170
或者面试的时候

05:04.170 --> 05:05.170
一定要注意这种情况

05:05.170 --> 05:06.170
如果遇到了R树

05:06.170 --> 05:07.170
比较的体

05:07.170 --> 05:08.170
一定要注意

05:08.170 --> 05:09.170
这就是两个R树

05:11.170 --> 05:13.170
但是我们现在光能比较相同

05:13.170 --> 05:14.170
不相同

05:14.170 --> 05:17.170
不是我们的最终需求

05:17.170 --> 05:18.170
不是我们最终需求

05:18.170 --> 05:20.170
就像没有一种你说的

05:20.170 --> 05:21.170
Def算法也好

05:21.170 --> 05:23.170
我需要的判断是一不一样的

05:23.170 --> 05:24.170
我不是需要

05:24.170 --> 05:26.170
我改了就不一样

05:26.170 --> 05:28.170
我需要判断是哪不一样

05:28.170 --> 05:29.170
对吧

05:29.170 --> 05:30.170
我说了

05:30.170 --> 05:32.170
哪个新增了

05:32.170 --> 05:33.170
哪个删除了

05:33.170 --> 05:34.170
是吧

05:34.170 --> 05:37.170
我们要判断的是哪个新增了

05:37.170 --> 05:38.170
哪个删除了

05:38.170 --> 05:39.170
这样的结果

05:39.170 --> 05:41.170
对我们才有意义

05:41.170 --> 05:42.170
是吧

05:42.170 --> 05:45.170
所以我们要做一个Def算法

05:45.170 --> 05:46.170
Def算法

05:46.170 --> 05:48.170
对两个R树进行Def

05:48.170 --> 05:50.170
将新增的提出来

05:50.170 --> 05:53.170
将这个删除的提出来

05:53.170 --> 05:55.170
标记出来

05:55.170 --> 05:57.170
这个是我们下集的内容

05:57.170 --> 05:59.170
下集来做R树的Def算法

