WEBVTT

00:00.940 --> 00:02.940
Hello 大家好

00:02.940 --> 00:05.940
这一集我们来说一个冒泡排序

00:05.940 --> 00:07.940
我们来说冒泡排序

00:08.940 --> 00:13.940
排序是对我们通常都是指对数组进行排序

00:13.940 --> 00:16.940
咱们通常拿到了一个数组了之后

00:16.940 --> 00:22.770
它可能不是按照顺序排列

00:22.770 --> 00:24.770
比如说这样的一个数组

00:24.770 --> 00:26.770
我随便写几个数了

00:26.770 --> 00:27.770
比如说

00:27.770 --> 00:36.770
4 1 6 9 3 2 8 7

00:36.770 --> 00:38.770
随便写的

00:38.770 --> 00:40.770
乱糟糟的

00:40.770 --> 00:41.770
它是没有序列的

00:41.770 --> 00:44.770
我们希望把它从小到大进行排列

00:44.770 --> 00:48.770
我们希望把它从小到大进行排列

00:50.770 --> 00:54.770
看一看我们有什么一个排序的方式

00:54.770 --> 00:56.770
很多同学最先想到的

00:56.770 --> 01:03.770
就是我们所谓的传统的一个非常古老的一种排序

01:03.770 --> 01:10.660
我们再声明出来一个数组

01:10.660 --> 01:13.660
然后在这里面找到最小的1放在这

01:13.660 --> 01:15.660
然后把1删掉

01:15.660 --> 01:16.660
然后找到第二小的2

01:16.660 --> 01:17.660
把2放在这

01:17.660 --> 01:19.660
然后把2删掉

01:19.660 --> 01:21.660
然后再找出最小的

01:21.660 --> 01:22.660
找出3

01:22.660 --> 01:23.660
然后3写在这

01:23.660 --> 01:24.660
把3删掉

01:24.660 --> 01:27.660
然后再找出来最小的是4

01:27.660 --> 01:29.660
然后4写在这把4删掉

01:29.660 --> 01:31.660
然后再找出来最小的是6

01:31.660 --> 01:34.660
然后把6写在这把它删掉

01:34.660 --> 01:36.660
然后找出最小的7

01:36.660 --> 01:38.660
7写在这把7删掉

01:38.660 --> 01:40.660
再找出最小的8

01:40.660 --> 01:41.660
8写在这把它删掉

01:41.660 --> 01:43.660
然后再找出最小的9

01:43.660 --> 01:44.660
9写在这把它删掉

01:44.660 --> 01:46.660
上面的都删完了

01:46.660 --> 01:47.660
下面的都填完了

01:47.660 --> 01:48.660
完成一个新的数组

01:48.660 --> 01:50.660
这个数组是有趣的

01:50.660 --> 01:51.660
这种方法行不行

01:51.660 --> 01:53.660
这种方法其实是一个最简单的方法

01:53.660 --> 01:55.660
对吧

01:55.660 --> 01:56.660
一个最简单的方法了

01:57.660 --> 01:58.660
我们来写一下

01:58.660 --> 01:59.660
这种方法

01:59.660 --> 02:00.660
其实是能实现的

02:00.660 --> 02:02.660
但是性能是极差的

02:02.660 --> 02:04.660
写一个太刺的点

02:04.660 --> 02:05.660
JS

02:05.660 --> 02:10.220
我问一个数组

02:10.220 --> 02:13.220
剩下的41693287

02:13.220 --> 02:14.220
是吧

02:14.220 --> 02:19.820
4169

02:19.820 --> 02:20.820
3

02:20.820 --> 02:21.820
2

02:21.820 --> 02:22.820
8

02:22.820 --> 02:23.820
7

02:23.820 --> 02:24.820
41693287

02:24.820 --> 02:25.820
真是8个数

02:25.820 --> 02:28.820
然后我要声明一个新的数组

02:28.820 --> 02:29.820
是吧

02:29.820 --> 02:30.820
方式

02:30.820 --> 02:31.820
然后我要sort

02:31.820 --> 02:32.820
进行排序

02:32.820 --> 02:33.820
给我传进了AR

02:33.820 --> 02:34.820
我要干嘛

02:34.820 --> 02:35.820
我声明一个新的数

02:35.820 --> 02:37.820
我居然还得声明一个新的数组

02:37.820 --> 02:39.820
声明一个9AR

02:39.820 --> 02:40.820
是吧

02:40.820 --> 02:42.820
然后9AR有多长呢

02:42.820 --> 02:43.820
9AR

02:43.820 --> 02:48.020
你有多长呢

02:48.020 --> 02:50.020
和AR一样长

02:50.020 --> 02:52.020
居然还得供AR一样长

02:52.020 --> 02:53.020
是吧

02:53.020 --> 02:55.020
我让我的存储空间

02:55.020 --> 02:56.020
得翻一倍是吧

02:56.020 --> 02:57.020
存储空间翻了一倍

02:57.020 --> 02:58.020
然后我干嘛

02:58.020 --> 03:00.020
每次找到最小的

03:00.020 --> 03:01.020
复苏循环

03:01.020 --> 03:04.020
我们要往这里面进行tn是吧

03:04.020 --> 03:05.020
i等于0

03:05.020 --> 03:08.020
i小于9AR的lans

03:08.020 --> 03:10.020
i加加

03:10.020 --> 03:13.020
然后我每次给9ARi位置

03:13.020 --> 03:15.020
给它复一个值

03:15.020 --> 03:16.020
这个值

03:16.020 --> 03:18.020
我得复成谁

03:18.020 --> 03:20.020
复成AR里面

03:20.020 --> 03:23.020
当先最小的这个值是吧

03:23.020 --> 03:24.020
方个谁

03:24.020 --> 03:25.020
怎么样

03:25.020 --> 03:28.020
我还得get me

03:28.020 --> 03:30.780
对吧

03:30.780 --> 03:32.780
我得找到最小的

03:32.780 --> 03:35.780
找到最小的在第几位上

03:35.780 --> 03:38.780
找到最小的在第几位上

03:38.780 --> 03:40.780
word一个index

03:40.780 --> 03:42.780
等于f1

03:42.780 --> 03:43.780
然后呢

03:43.780 --> 03:46.780
先等于0吧

03:46.780 --> 03:49.780
复苏循环

03:49.780 --> 03:51.780
word一个i等于0

03:51.780 --> 03:53.780
i小于AR的lans

03:53.780 --> 03:55.780
i加加

03:55.780 --> 03:58.780
找到最小的数在第几个位置上

03:59.780 --> 04:01.780
AR2i

04:01.780 --> 04:03.780
小于

04:03.780 --> 04:05.780
AR

04:05.780 --> 04:08.780
index

04:08.780 --> 04:12.780
我们就让index等于i

04:12.780 --> 04:14.780
最后我们

04:14.780 --> 04:16.780
return

04:16.780 --> 04:18.780
index

04:18.780 --> 04:19.780
就完事

04:19.780 --> 04:20.780
是吧

04:20.780 --> 04:22.780
前提是这个AR必须得有数

04:22.780 --> 04:23.780
是吧

04:23.780 --> 04:24.780
必须得有数

04:24.780 --> 04:26.780
AR

04:26.780 --> 04:27.780
等于空

04:27.780 --> 04:30.780
或者是AR的lans

04:30.780 --> 04:31.780
等于理儿

04:31.780 --> 04:34.780
我都直接return

04:34.780 --> 04:35.780
是吧

04:35.780 --> 04:36.780
我就都给他直接return

04:36.780 --> 04:37.780
这里面必须得有值

04:37.780 --> 04:38.780
没有值不行

04:38.780 --> 04:39.780
对吧

04:39.780 --> 04:40.780
这里面必须得有值

04:40.780 --> 04:42.780
没有值不行

04:42.780 --> 04:43.780
这是这一块是吧

04:43.780 --> 04:45.780
我们能找到一个最小的

04:45.780 --> 04:48.780
然后复给他

04:48.780 --> 04:50.780
把AR传进去

04:50.780 --> 04:54.540
你说这样行吗

04:54.540 --> 04:55.540
return

04:55.540 --> 04:56.540
你有没有

04:56.540 --> 04:57.540
这样行吗

04:57.540 --> 04:59.540
起码我现在这样是不行

04:59.540 --> 05:01.540
为啥

05:01.540 --> 05:04.880
soul

05:04.880 --> 05:05.880
我把AR传进去了之后

05:05.880 --> 05:06.880
你看我返回的

05:06.880 --> 05:07.880
应该是

05:07.880 --> 05:09.880
会给我返回的是啥

05:09.880 --> 05:11.880
都是1是吧

05:11.880 --> 05:14.880
因为这个数组里面最小的是1是吧

05:14.880 --> 05:16.880
他每一次都会把1给我找出来

05:16.880 --> 05:17.880
对吧

05:17.880 --> 05:18.880
我们需要

05:18.880 --> 05:20.880
当我找出来这一项的时候

05:20.880 --> 05:22.880
我给他删掉

05:22.880 --> 05:23.880
对吧

05:23.880 --> 05:24.880
我得给他删掉

05:24.880 --> 05:26.880
给他删掉的一个最好的方式

05:26.880 --> 05:29.880
其实也不一定是splays这些

05:29.880 --> 05:30.880
什么replays

05:30.880 --> 05:31.880
splays这些

05:31.880 --> 05:32.880
不用这些

05:32.880 --> 05:33.880
用这些的话

05:33.880 --> 05:34.880
性能就更差了

05:34.880 --> 05:35.880
都没眼看了

05:35.880 --> 05:37.880
怎么办

05:37.880 --> 05:45.880
让AR index等于空

05:45.880 --> 05:48.880
然后我们现在前提是必须得AR

05:48.880 --> 05:50.880
i得有数

05:50.880 --> 05:52.880
然后并且

05:52.880 --> 05:54.880
AR得写全了吧

05:54.880 --> 05:55.880
就不等于空

05:55.880 --> 05:57.880
并且小于他才行

05:57.880 --> 05:58.880
这样玩

05:58.880 --> 05:59.880
这样玩

05:59.880 --> 06:10.790
看看哪写错了

06:10.790 --> 06:12.790
我每次只会挑出一个index

06:12.790 --> 06:14.790
我看一下

06:14.790 --> 06:22.000
怎么写成这么乱的

06:22.000 --> 06:23.000
get me

06:23.000 --> 06:25.000
我把AR2传进去

06:25.000 --> 06:29.870
get me

06:29.870 --> 06:32.870
我把AR2传进去

06:32.870 --> 06:35.870
然后

06:35.870 --> 06:37.870
当找到一个最小的

06:37.870 --> 06:40.870
那时候我把他变为空

06:40.870 --> 06:42.870
我把他变为空

06:42.870 --> 06:47.500
如果什么样的情况下参与比较

06:47.500 --> 06:49.500
如果他不等于空的时候

06:49.500 --> 06:51.500
才会参与比较

06:51.500 --> 06:55.940
这个没有什么问题

06:55.940 --> 07:07.940
我每次都打印一下AR2

07:07.940 --> 07:08.940
4

07:08.940 --> 07:09.940
空

07:09.940 --> 07:10.940
对吧

07:10.940 --> 07:11.940
第一次把1变为空

07:11.940 --> 07:14.940
然后第二次把2变为空

07:14.940 --> 07:17.940
然后第三次把3变为空

07:17.940 --> 07:29.480
第四次把4变为空

07:29.480 --> 07:32.480
4变为空了之后

07:32.480 --> 07:34.480
每一次

07:34.480 --> 07:37.480
他就找不到最小的

07:37.480 --> 07:44.890
把4变为空了之后

07:44.890 --> 07:46.890
他就找不到最小的

07:46.890 --> 07:47.890
我换一下

07:47.890 --> 07:52.840
我们把浪变的-1

07:52.840 --> 07:54.840
给他一个没有用的值也行

07:54.840 --> 07:56.840
给他一个没有用的值也行

07:56.840 --> 08:03.520
我们让AR2得大于-1

08:03.520 --> 08:07.150
再来试一下

08:07.150 --> 08:10.150
第四次了之后

08:10.150 --> 08:14.320
看吧

08:14.320 --> 08:16.320
第四次了之后

08:18.320 --> 08:22.320
我们要让index最开始等于0了是吧

08:22.320 --> 08:26.320
我们最开始index等于0了是吧

08:26.320 --> 08:28.320
是这块的问题

08:28.320 --> 08:30.320
我来改一下

08:30.320 --> 08:32.320
因为AR4

08:32.320 --> 08:35.320
4这个位置变成空了之后

08:35.320 --> 08:36.320
index等于空了

08:36.320 --> 08:38.320
index就等于空了

08:38.320 --> 08:40.320
所以说他确实是

08:40.320 --> 08:42.320
不等于空的时候才能复制给i

08:42.320 --> 08:44.320
但是还有一个情况下得复制给

08:44.320 --> 08:47.320
货上

08:47.320 --> 08:50.320
我们让index等于-1

08:50.320 --> 08:52.320
货上

08:52.320 --> 08:58.740
index等于-1

08:58.740 --> 09:01.740
货还是起来的

09:01.740 --> 09:05.740
货他不等于空

09:05.740 --> 09:08.740
起

09:08.740 --> 09:12.180
index等于-1

09:12.180 --> 09:15.180
你首先这个值不能为空是吧

09:15.180 --> 09:18.180
然后如果index为-1的话

09:18.180 --> 09:21.180
不管他大小全都给他弄上去

09:21.180 --> 09:23.180
因为他是序号

09:23.180 --> 09:25.180
这个不可能捐负1是吧

09:25.180 --> 09:27.180
数组从0号为开始

09:27.180 --> 09:30.180
负1的代表是还没有给他复制

09:30.180 --> 09:39.000
还没有给他复制

09:39.000 --> 09:40.000
然后我们这样的话

09:40.000 --> 09:42.000
我们每次能拿出来一个最小的

09:42.000 --> 09:45.000
我先来打印一下

09:45.000 --> 09:53.450
这是15402763是吧

09:53.450 --> 09:55.450
有朋友说你这个为什么不是按的

09:55.450 --> 09:56.450
从小到大

09:56.450 --> 09:58.450
因为我拿出来的是序号

09:58.450 --> 10:00.450
我拿出来的是序号

10:00.450 --> 10:03.450
我得给他AR

10:03.450 --> 10:05.450
这个东西才行

10:05.450 --> 10:08.450
我拿出来的是序号

10:08.450 --> 10:12.340
等一下我看一下

10:12.340 --> 10:15.340
因为我现在拿出来的这个index

10:15.340 --> 10:16.340
是序号

10:16.340 --> 10:18.340
但是我在这会给他置为空了

10:18.340 --> 10:20.340
这块现在是这块有问题

10:20.340 --> 10:21.340
我给他置为空了

10:21.340 --> 10:22.340
我再给他去拿的话

10:22.340 --> 10:24.340
他就全都变为空了

10:24.340 --> 10:27.340
所以这会的前号顺序是有问题的

10:27.340 --> 10:29.340
我现在getme

10:29.340 --> 10:30.340
getme的话

10:30.340 --> 10:34.340
我就给他拿上这个

10:34.340 --> 10:36.340
wear一个result

10:36.340 --> 10:39.340
等于AR index

10:39.340 --> 10:41.340
这回我这个result是一个值了

10:41.340 --> 10:42.340
对吧

10:42.340 --> 10:46.480
然后我把index置为空了之后

10:46.480 --> 10:50.480
我再把这个节目给他返回回去

10:50.480 --> 10:52.480
然后就1234678

10:52.480 --> 10:54.480
你会发现了

10:54.480 --> 10:58.480
我们看似想思考起来最简单的方式

10:58.480 --> 11:01.480
实际上代码是最复杂的

11:01.480 --> 11:04.480
我们思考起来最简单的方式

11:04.480 --> 11:05.480
代码是最复杂的

11:05.480 --> 11:07.480
而且循环特别多

11:07.480 --> 11:09.480
双重循环的前套

11:09.480 --> 11:11.480
然后还有那么多层的

11:11.480 --> 11:13.480
一些东西乱七八糟

11:13.480 --> 11:14.480
我说哪双重循环

11:14.480 --> 11:15.480
这不是一层循环

11:15.480 --> 11:16.480
这不是一层循环吗

11:16.480 --> 11:17.480
看好了

11:17.480 --> 11:18.480
我这一层循环里面

11:18.480 --> 11:19.480
如果套个函数

11:19.480 --> 11:21.480
函数里面还有一层循环的话

11:21.480 --> 11:22.480
这就是两层循环

11:22.480 --> 11:23.480
对吧

11:23.480 --> 11:25.480
你只不给他提出去而已

11:25.480 --> 11:26.480
对吧

11:26.480 --> 11:27.480
他还是循环套循环

11:27.480 --> 11:29.480
所以说这个的

11:29.480 --> 11:32.480
无论是时间上还是空间上

11:32.480 --> 11:33.480
空间上

11:33.480 --> 11:35.480
新生明了一个数组

11:35.480 --> 11:36.480
对吧

11:36.480 --> 11:38.480
时间上又循环套循环的

11:38.480 --> 11:40.480
这种方式是非常不好的

11:40.480 --> 11:42.480
这种方式非常不好的

11:42.480 --> 11:44.480
我们今天来说一个排序

11:44.480 --> 11:46.480
就冒泡排序

11:46.480 --> 11:48.480
冒泡排序

11:48.480 --> 11:50.480
冒泡排序是怎么玩的

11:50.480 --> 11:56.180
看

11:56.180 --> 11:58.180
这个4和1

11:58.180 --> 12:01.180
假如说我要从小到大排序

12:01.180 --> 12:02.180
那4和1显比

12:02.180 --> 12:04.180
先拿出来前两个比

12:04.180 --> 12:06.180
你会发现4比1大是吧

12:06.180 --> 12:07.180
从小到大排序

12:07.180 --> 12:08.180
起码左边这样小

12:08.180 --> 12:09.180
右边的大是吧

12:09.180 --> 12:11.180
第一步

12:11.180 --> 12:13.180
先把4和1进行交换

12:13.180 --> 12:20.440
把4和1交换位置

12:20.440 --> 12:22.440
它是1

12:22.440 --> 12:24.440
它是4

12:24.440 --> 12:26.440
然后第二步是看

12:26.440 --> 12:28.440
4和6比

12:28.440 --> 12:30.440
将4和6进行比

12:30.440 --> 12:31.440
4比6小

12:31.440 --> 12:33.440
不动是吧

12:33.440 --> 12:35.440
这是第二步

12:35.440 --> 12:37.440
第三步是6和9比

12:37.440 --> 12:38.440
6比9小

12:38.440 --> 12:40.440
不用动对吧

12:40.440 --> 12:46.250
又没有把每个都写上

12:48.250 --> 12:52.250
4和1比

12:52.250 --> 12:54.250
需要交换

12:54.250 --> 12:55.250
对吧

12:55.250 --> 12:56.250
因为左小又大

12:56.250 --> 12:58.250
我们需要的是左小又大的形式

12:58.250 --> 13:03.610
然后

13:03.610 --> 13:05.610
这个是4和6比

13:05.610 --> 13:06.610
是吧

13:06.610 --> 13:10.920
因为每一次都是往后推一回

13:10.920 --> 13:12.920
都是两个两个相比

13:12.920 --> 13:14.920
先是第0和第1个比

13:14.920 --> 13:15.920
然后是第1个和第2个比

13:15.920 --> 13:16.920
然后是第2个和第3个比

13:16.920 --> 13:18.920
然后第3和第4个比

13:18.920 --> 13:19.920
是吧

13:19.920 --> 13:20.920
这是4和6比

13:20.920 --> 13:22.920
然后它是不需要交换的

13:22.920 --> 13:23.920
对吧

13:23.920 --> 13:25.920
左小又大

13:25.920 --> 13:31.580
然后是6和9比

13:31.580 --> 13:36.210
这也是不需要交换的对吧

13:36.210 --> 13:39.210
然后是9和3比

13:39.210 --> 13:42.290
9和3比

13:42.290 --> 13:44.290
是不是需要交换了

13:44.290 --> 13:45.290
需要交换了

13:45.290 --> 13:47.290
交换之后变成什么样

13:47.290 --> 13:53.420
把3写在这

13:53.420 --> 13:55.420
把9写在这

13:55.420 --> 13:57.420
这是交换之后

13:57.420 --> 14:00.420
然后又变成9和2比

14:00.420 --> 14:02.420
刚才刚比完9是吧

14:02.420 --> 14:03.420
对呀

14:03.420 --> 14:04.420
但是他现在交换

14:04.420 --> 14:06.420
9往后边移了一位

14:06.420 --> 14:08.420
所以现在变成9和2比

14:08.420 --> 14:12.420
9和2比也需要交换对吧

14:12.420 --> 14:18.880
然后这块变成9

14:18.880 --> 14:21.880
然后是9和8比

14:21.880 --> 14:25.510
9和8比

14:25.510 --> 14:33.370
是不是也是需要交换的

14:33.370 --> 14:34.370
9

14:34.370 --> 14:36.370
然后是9和7比

14:36.370 --> 14:44.810
是不是也是需要交换的

14:44.810 --> 14:48.570
然后就不用比了

14:48.570 --> 14:49.570
是吧

14:49.570 --> 14:50.570
比到头了

14:50.570 --> 14:52.570
我们会发现

14:52.570 --> 14:55.570
整个冒泡排序做完了

14:55.570 --> 14:57.570
从头到尾比完了一圈

14:57.570 --> 14:59.570
完成了一个什么事

14:59.570 --> 15:07.160
是不是把最大的数推到了最后边

15:07.160 --> 15:08.160
对吧

15:08.160 --> 15:10.160
整个冒泡排序做完了

15:10.160 --> 15:15.160
我们其实就是把最大的数推到了最后边

15:15.160 --> 15:17.160
这就是冒泡排序的作用

15:17.160 --> 15:20.160
这就是一变循环

15:20.160 --> 15:21.160
也就是说

15:21.160 --> 15:22.160
每一次循环

15:22.160 --> 15:24.160
把一个最大的数推到最后面

15:24.160 --> 15:27.160
下次循环把大的数推到到这边

15:27.160 --> 15:28.160
再下一次循环

15:28.160 --> 15:30.160
把大的数推到到这边

15:30.160 --> 15:32.160
一次推

15:32.160 --> 15:33.160
一个一点点推

15:33.160 --> 15:34.160
越推越快

15:34.160 --> 15:35.160
越推越快

15:35.160 --> 15:36.160
就结束了

15:36.160 --> 15:38.160
这是冒泡排序

15:38.160 --> 15:41.160
那么我们来写个冒泡排序的一个例子

15:41.160 --> 15:44.300
好吧

15:44.300 --> 15:45.300
GS

15:45.300 --> 15:55.790
我把这个数组展过来

15:55.790 --> 15:57.790
我把这个数组展过来

15:57.790 --> 15:59.790
这是一个AR是吧

15:59.790 --> 16:01.790
我要对这个数组先排序

16:01.790 --> 16:02.790
然后问大家一个问题

16:02.790 --> 16:05.790
排序的本质是什么

16:05.790 --> 16:09.790
排序的本质是什么

16:09.790 --> 16:11.790
排序的本质是什么

16:11.790 --> 16:14.790
排序不是比较大小

16:14.790 --> 16:15.790
记住

16:15.790 --> 16:17.790
如果说

16:17.790 --> 16:19.790
排序

16:19.790 --> 16:22.790
不是比较大小

16:22.790 --> 16:23.790
对吧

16:23.790 --> 16:26.790
排序跟大小没有关系

16:26.790 --> 16:29.790
我们生活中有很多的排序

16:29.790 --> 16:30.790
女是有闲

16:30.790 --> 16:32.790
老人有闲

16:32.790 --> 16:33.790
小孩有闲

16:33.790 --> 16:34.790
先到先得

16:34.790 --> 16:35.790
对吧

16:35.790 --> 16:36.790
你说先到先得

16:36.790 --> 16:38.790
是根据时间的顺序进行排序

16:38.790 --> 16:39.790
那老人有闲

16:39.790 --> 16:40.790
女是有闲的

16:40.790 --> 16:41.790
是吧

16:41.790 --> 16:42.790
这些综合在一起

16:42.790 --> 16:43.790
是吧

16:43.790 --> 16:45.790
所以排序不是比较大小

16:45.790 --> 16:47.790
排序的本质

16:47.790 --> 16:55.360
排序的本质是比较和交换

16:55.360 --> 16:56.360
看好了

16:56.360 --> 16:57.360
我说的是比较

16:57.360 --> 16:59.360
没说比较大小

17:00.360 --> 17:02.360
如果说比较大小的话

17:02.360 --> 17:04.360
这种说法是不正确的

17:04.360 --> 17:06.360
这种说法就太局限了

17:06.360 --> 17:08.360
排序的本质是比较和交换

17:08.360 --> 17:10.360
也就是说我最后

17:10.360 --> 17:12.360
我需要写两个算法

17:12.360 --> 17:13.360
写两个方法

17:13.360 --> 17:15.360
一个是compire

17:15.360 --> 17:16.360
比较一下

17:16.360 --> 17:17.360
比较一下

17:17.360 --> 17:19.360
最后得出的结果是什么

17:19.360 --> 17:21.360
比较之后

17:21.360 --> 17:23.360
需要得出

17:23.360 --> 17:25.360
是否

17:25.360 --> 17:27.360
需要交换

17:30.360 --> 17:32.360
方式

17:32.360 --> 17:34.360
趁止

17:34.360 --> 17:37.360
交换

17:37.360 --> 17:38.360
传令AR

17:38.360 --> 17:39.360
一个A位置

17:39.360 --> 17:41.360
一个B位置

17:41.360 --> 17:42.360
将

17:42.360 --> 17:44.360
数组中

17:44.360 --> 17:45.360
A

17:45.360 --> 17:46.360
B

17:46.360 --> 17:49.800
位置

17:49.800 --> 17:51.800
理的值

17:51.800 --> 17:56.840
进行交换

17:56.840 --> 17:57.840
所以说

17:57.840 --> 17:59.840
几乎每一种排序

17:59.840 --> 18:01.840
都会有这两种方式

18:01.840 --> 18:03.840
比较和交换

18:03.840 --> 18:04.840
然后

18:04.840 --> 18:05.840
才是

18:05.840 --> 18:07.840
我们所谓的排序算法

18:07.840 --> 18:09.840
这个salt

18:11.840 --> 18:12.840
这个salt

18:12.840 --> 18:18.710
可以是冒泡

18:19.710 --> 18:21.710
也可以是

18:21.710 --> 18:23.710
选择

18:24.710 --> 18:26.710
可以是冒泡排序

18:28.710 --> 18:30.710
也可以是

18:30.710 --> 18:32.710
其他排序

18:33.710 --> 18:35.710
我们所谓的排序算法

18:35.710 --> 18:37.710
指的是这一块不同

18:37.710 --> 18:39.710
这一块和这一块

18:39.710 --> 18:40.710
都是一样的

18:40.710 --> 18:41.710
交换

18:41.710 --> 18:43.710
你说还能有多少种交换方式

18:43.710 --> 18:44.710
交换能有什么交换方式

18:44.710 --> 18:45.710
我说一个

18:45.710 --> 18:47.710
临时变量

18:48.710 --> 18:50.710
等于ARRA

18:50.710 --> 18:54.150
然后能让

18:54.150 --> 18:55.150
ARRA

18:55.150 --> 18:57.150
等于ARB

18:57.150 --> 19:02.550
然后让ARB

19:02.550 --> 19:06.380
等于临时变量

19:07.380 --> 19:09.380
这就是交换

19:09.380 --> 19:10.380
交换

19:10.380 --> 19:11.380
什么地方都一样

19:11.380 --> 19:12.380
交换在哪都一样

19:12.380 --> 19:14.380
交换就是这么交换

19:14.380 --> 19:15.380
也就是说

19:15.380 --> 19:16.380
排序

19:16.380 --> 19:17.380
我们当传说salt的时候

19:17.380 --> 19:19.380
给我传一个AR

19:19.380 --> 19:21.380
我如何对这个东西进行排序

19:21.380 --> 19:22.380
我们所谓的

19:22.380 --> 19:24.380
每一轮

19:24.380 --> 19:25.380
进行

19:25.380 --> 19:26.380
两个两个进行比较

19:26.380 --> 19:27.380
找到什么

19:27.380 --> 19:28.380
找到最小的

19:28.380 --> 19:29.380
是吧

19:29.380 --> 19:30.380
说循环

19:31.380 --> 19:35.380
问一个I

19:35.380 --> 19:36.380
等于0

19:36.380 --> 19:38.380
我先问一个接等于0

19:38.380 --> 19:40.380
接等于0

19:40.380 --> 19:41.380
然后

19:41.380 --> 19:43.380
接小鱼

19:43.380 --> 19:44.380
谁

19:44.380 --> 19:45.380
假设说

19:45.380 --> 19:46.380
先小鱼ARRA的烂子

19:46.380 --> 19:47.380
这肯定是不对的

19:47.380 --> 19:48.380
咱们待会再改

19:48.380 --> 19:49.380
再加

19:51.380 --> 19:52.380
我们要说

19:52.380 --> 19:53.380
两个两个进行比较是吧

19:53.380 --> 19:55.380
谁和比谁比较

19:55.380 --> 19:56.380
接

19:56.380 --> 19:57.380
第接位

19:57.380 --> 19:58.380
和接加1位进行比较是吧

19:58.380 --> 19:59.380
Compire

20:00.380 --> 20:01.380
Compire也得比较

20:01.380 --> 20:02.380
也是吧

20:03.380 --> 20:04.380
A和B

20:04.380 --> 20:05.380
给我传进来两个指

20:05.380 --> 20:06.380
Compire谁

20:06.380 --> 20:07.380
AR

20:07.380 --> 20:08.380
接

20:08.380 --> 20:09.380
和谁

20:09.380 --> 20:10.380
AR

20:10.380 --> 20:11.380
接

20:11.380 --> 20:12.380
加1

20:13.380 --> 20:15.380
这么两个位置进行比较

20:15.380 --> 20:17.380
看的需不需要交换

20:17.380 --> 20:19.380
如果他给我返回处了

20:19.380 --> 20:20.380
那我就进行交换是吧

20:20.380 --> 20:21.380
进行交换什么

20:21.380 --> 20:22.380
Exchange

20:22.380 --> 20:23.380
AR

20:23.380 --> 20:24.380
接

20:24.380 --> 20:25.380
接加1

20:26.380 --> 20:27.380
否则的话

20:27.380 --> 20:28.380
就进行下一次

20:29.380 --> 20:30.380
是吧

20:31.380 --> 20:32.380
然后你看我这里面

20:32.380 --> 20:33.380
要对接和进行

20:33.380 --> 20:34.380
接加1进行操作

20:34.380 --> 20:36.380
我接能取到最后一个吗

20:36.380 --> 20:37.380
我接要是取到最后一个

20:37.380 --> 20:38.380
和接加1不就冒出了吗

20:38.380 --> 20:39.380
是吧

20:39.380 --> 20:41.380
所以接不是小鱼ARRA的烂子

20:41.380 --> 20:43.380
是小鱼ARRA的烂子建议

20:45.380 --> 20:47.380
小鱼ARRA的烂子建议

20:47.380 --> 20:49.380
然后Compire

20:49.380 --> 20:50.380
什么样的情况

20:50.380 --> 20:51.380
就要交换

20:51.380 --> 20:52.380
左小右大需要交换吗

20:52.380 --> 20:54.380
不需要是吧

20:54.380 --> 20:55.380
当右大左小的时候

20:55.380 --> 20:56.380
才需要交换是吧

20:56.380 --> 20:57.380
是吧

20:57.380 --> 20:58.380
义父B大于A的时候

20:58.380 --> 20:59.380
才需要return

21:00.380 --> 21:01.380
处

21:01.380 --> 21:02.380
否则

21:04.380 --> 21:05.380
return

21:05.380 --> 21:06.380
否则

21:07.380 --> 21:08.380
对吧

21:08.380 --> 21:09.380
当右大左小的时候

21:09.380 --> 21:10.380
才需要交换

21:10.380 --> 21:11.380
左小右大不需要交换

21:13.380 --> 21:14.380
这就是一个salt

21:14.380 --> 21:15.380
对吧

21:15.380 --> 21:16.380
那我们来看一下

21:16.380 --> 21:20.330
当排完序

21:20.330 --> 21:21.330
以下的之后

21:21.330 --> 21:23.330
看salt有点log

21:23.330 --> 21:24.330
salt

21:24.330 --> 21:25.330
AR

21:25.330 --> 21:27.330
会变成什么样

21:32.780 --> 21:33.780
不是这样的

21:33.780 --> 21:34.780
salt

21:34.780 --> 21:36.780
然后我最后打AR

21:36.780 --> 21:50.160
是吧

21:50.160 --> 21:52.160
我们把

21:53.160 --> 21:55.160
我们把最小的

21:55.160 --> 21:57.160
放到最后面

21:57.160 --> 22:02.480
我们看

22:02.480 --> 22:04.480
46932871

22:04.480 --> 22:05.480
是吧

22:05.480 --> 22:06.480
我们把1

22:06.480 --> 22:07.480
放到最后面

22:07.480 --> 22:08.480
是吧

22:08.480 --> 22:09.480
我们看一下

22:10.480 --> 22:11.480
B

22:11.480 --> 22:12.480
大于A

22:12.480 --> 22:13.480
需要交换

22:14.480 --> 22:16.480
如果把这变成B小

22:21.990 --> 22:23.990
这样的话9就变到最后面去了

22:23.990 --> 22:24.990
是吧

22:24.990 --> 22:26.990
我们总之是通过交换了之后

22:26.990 --> 22:28.990
我们要么把最大的放到后面

22:28.990 --> 22:29.990
要么把最小的放到后面

22:29.990 --> 22:30.990
对吧

22:30.990 --> 22:31.990
所以说我们需要

22:31.990 --> 22:33.990
正序还是道序

22:33.990 --> 22:35.990
我们其实改变的是谁

22:35.990 --> 22:37.990
我们就改变一个compire

22:37.990 --> 22:38.990
这个

22:38.990 --> 22:41.990
排序算法是不需要变的

22:41.990 --> 22:43.990
排序算法是不需要变的

22:43.990 --> 22:46.990
你正序和道序都是写compire

22:46.990 --> 22:47.990
你知道为什么

22:47.990 --> 22:49.990
AR它本身不是有salt

22:50.990 --> 22:52.990
salt里面不让你传个方式

22:52.990 --> 22:53.990
你知道这个方式是谁吗

22:53.990 --> 22:55.990
这个方式就是compire

22:56.990 --> 22:58.990
你传的这个方式

22:58.990 --> 22:59.990
就是compire

23:01.990 --> 23:03.990
你传的这个方式就是compire

23:03.990 --> 23:05.990
如果方式传

23:05.990 --> 23:07.990
返回正一了

23:07.990 --> 23:08.990
我们说返回正数了

23:08.990 --> 23:09.990
就相当于初

23:09.990 --> 23:10.990
返回复数了就相当于first

23:10.990 --> 23:11.990
就是这么一个概念

23:11.990 --> 23:13.990
所以AR的salt

23:13.990 --> 23:14.990
这个方式

23:14.990 --> 23:16.990
其实就是compire

23:16.990 --> 23:17.990
其实就是compire

23:17.990 --> 23:19.990
我们无论如何是

23:19.990 --> 23:20.990
怎么样是进行了一圈是吧

23:20.990 --> 23:22.990
一圈只能找出来一个是吧

23:22.990 --> 23:23.990
那我们一共有多少个数

23:23.990 --> 23:24.990
我们有很多个数是吧

23:24.990 --> 23:26.990
有AR的籃子这么一个数

23:26.990 --> 23:28.990
每一圈找一个

23:28.990 --> 23:30.990
那我就多给他循环几圈就得了

23:30.990 --> 23:31.990
是吧

23:31.990 --> 23:32.990
把这个循环

23:32.990 --> 23:33.990
把这个方循环放在里面去

23:33.990 --> 23:34.990
看好了

23:34.990 --> 23:35.990
放进去之后不动

23:35.990 --> 23:38.990
在外面问一个i等于0

23:38.990 --> 23:41.990
i小于AR点籃子

23:41.990 --> 23:43.990
i加加

23:43.990 --> 23:45.990
这是将里面的循环执行了

23:45.990 --> 23:46.990
i变是吧

23:46.990 --> 23:48.990
执行了AR点籃子变

23:48.990 --> 23:49.990
是吧

23:49.990 --> 23:51.990
是不是就12345

23:51.990 --> 23:55.970
对吧

23:55.970 --> 24:01.900
说人家没有什么毛病

24:01.900 --> 24:03.900
这就进行排序

24:03.900 --> 24:05.900
当然这种方式

24:05.900 --> 24:07.900
实际上是不太好的

24:07.900 --> 24:09.900
这种方式实际上

24:09.900 --> 24:10.900
稍微有点问题

24:10.900 --> 24:11.900
哪有问题

24:11.900 --> 24:12.900
你看

24:12.900 --> 24:14.900
第一圈找到了之后

24:14.900 --> 24:15.900
9已经是最大的了

24:15.900 --> 24:17.900
第二圈再从头比到尾

24:17.900 --> 24:19.900
8还用和9比

24:19.900 --> 24:20.900
不用是吧

24:20.900 --> 24:21.900
之前都比过了

24:21.900 --> 24:22.900
对吧

24:22.900 --> 24:24.900
之前都已经比过了

24:24.900 --> 24:26.900
它不需要再比了

24:26.900 --> 24:27.900
也就是说

24:27.900 --> 24:28.900
第一圈执行了之后

24:28.900 --> 24:30.900
下一第二圈的时候

24:30.900 --> 24:31.900
就会少比一个

24:31.900 --> 24:32.900
第三圈的时候就少比两个

24:32.900 --> 24:34.900
第四圈的时候就少比三个

24:34.900 --> 24:35.900
对吧

24:35.900 --> 24:36.900
后面你不用再比了

24:36.900 --> 24:38.900
之前几圈都比过了

24:38.900 --> 24:39.900
它之所以能在最后面

24:39.900 --> 24:40.900
是因为之前就已经

24:40.900 --> 24:41.900
战胜过所有人

24:41.900 --> 24:42.900
对吧

24:42.900 --> 24:43.900
所以说

24:43.900 --> 24:45.900
gAR不用一直小于AR点籃子

24:45.900 --> 24:47.900
再减去一个i

24:47.900 --> 24:50.900
第几圈就少几

24:50.900 --> 24:53.900
最后的结果是12

24:53.900 --> 24:56.900
12346789

24:57.900 --> 24:59.900
这个就是排序

24:59.900 --> 25:01.900
这就是排序

25:03.900 --> 25:04.900
如果你要是改变一下

25:04.900 --> 25:05.900
从小到大

25:05.900 --> 25:06.900
或者从大到小

25:06.900 --> 25:07.900
就把它变成

25:07.900 --> 25:09.900
给它改一下

25:09.900 --> 25:12.900
大于号还是小于号

25:12.900 --> 25:14.900
这样就到去了

25:14.900 --> 25:15.900
再改变一下大于号

25:15.900 --> 25:16.900
小于号

25:16.900 --> 25:18.900
这就正序了

25:18.900 --> 25:19.900
其实排序

25:19.900 --> 25:20.900
就是这么简单

25:20.900 --> 25:21.900
这是冒泡排序

25:21.900 --> 25:22.900
这是冒泡排序

25:22.900 --> 25:24.900
还有一种排序

25:24.900 --> 25:27.900
和冒泡排序都一样出名

25:27.900 --> 25:28.900
这是哪种排序

25:28.900 --> 25:30.900
就是选择排序

25:30.900 --> 25:31.900
下一集

25:31.900 --> 25:32.900
我们来说

25:32.900 --> 25:34.900
选择排序是怎么回事

