WEBVTT

00:00.500 --> 00:02.500
Hello 大家好

00:02.500 --> 00:05.500
这一集我们来说限性书与结构的便利

00:05.500 --> 00:10.500
对于很多同学来说便利这个词比较陌生

00:10.500 --> 00:23.460
我来写一下文本限性数据结构的便利

00:23.460 --> 00:25.460
限性书与结构的便利

00:25.460 --> 00:27.460
其实这个算法非常简单

00:27.460 --> 00:30.460
这是最最基础的一个算法

00:30.460 --> 00:32.460
但是对于很多同学来说

00:32.460 --> 00:36.460
是对便利这个词理解的不够明确

00:36.460 --> 00:40.460
因为很多的行业点或者是很多的专业里面

00:40.460 --> 00:42.460
可能没有便利这个词

00:42.460 --> 00:44.460
便利是什么意思呢

00:44.460 --> 00:58.460
就是将一个集合中的每一个元素进行获取并查看

00:58.460 --> 01:01.460
将集合里面的每一个元素

01:01.460 --> 01:03.460
什么是集合 这是一个数学的概念

01:03.460 --> 01:05.460
一堆元素放在一起

01:05.460 --> 01:07.460
装在了一个容器里面就叫做集合

01:07.460 --> 01:09.460
比如说数组

01:09.460 --> 01:11.460
一个数组里面有很多个元素

01:11.460 --> 01:12.460
比如说链表

01:12.460 --> 01:15.460
一个链表里面有很多个元素

01:15.460 --> 01:20.460
然后我们将集合中的每一个元素都取出来进行查看

01:20.460 --> 01:23.460
数组来说我们可能比较好理解

01:23.460 --> 01:25.460
取第一个 第二个 第三个 第四个 第五个

01:25.460 --> 01:30.460
链表其实也是取第一个 第二个 第三个 第四个 第五个

01:30.460 --> 01:34.460
但是链表不能用下脚标的方式来进行获取

01:34.460 --> 01:36.460
它有它的获取的方式

01:36.460 --> 01:39.460
我们今天这一节课就来简单的来说一下

01:39.460 --> 01:44.460
现行数据结构 数组和链表如何进行编达

01:44.460 --> 01:50.670
我来先建一个GS文件

02:01.060 --> 02:04.060
然后我来创建一个数组

02:04.060 --> 02:12.060
味一个AR等于12345678

02:12.060 --> 02:14.060
数组的变力怎么变力

02:14.060 --> 02:15.060
是不是非常简单

02:15.060 --> 02:16.060
我写一个方式

02:16.060 --> 02:18.060
比如说我叫变力 是吧

02:18.060 --> 02:21.060
给我传入一个AR

02:21.060 --> 02:23.060
然后我怎么样

02:23.060 --> 02:25.060
就变力了 是吧

02:25.060 --> 02:28.060
味一个I等于0

02:28.060 --> 02:33.430
I小于AR的LANCE

02:34.430 --> 02:37.430
然后一次打印一下 是吧

02:37.430 --> 02:40.430
cancel了点LOG AR

02:40.430 --> 02:43.430
这就变力了 对吧

02:43.430 --> 02:44.430
但是记住

02:44.430 --> 02:45.430
我们平时写单码的时候

02:45.430 --> 02:46.430
你可能经常会这么写

02:46.430 --> 02:50.430
但是如果在考算法题的时候这么写

02:50.430 --> 02:52.430
一分没有

02:52.430 --> 02:54.430
考算法的时候如果这么写

02:54.430 --> 02:56.430
一分没有 为什么

02:56.430 --> 03:00.430
算法严谨性要求必须有严谨性判断

03:01.430 --> 03:03.430
AR等于空

03:07.430 --> 03:09.430
如果AR为空的话

03:09.430 --> 03:10.430
你这一点AR点LANCE

03:10.430 --> 03:12.430
是不是就抱错了

03:12.430 --> 03:13.430
对吧 是不是就抱错了

03:13.430 --> 03:15.430
记住 算法题里面

03:15.430 --> 03:18.430
任何一个地方出现了抱错行为

03:18.430 --> 03:19.430
没有份

03:19.430 --> 03:21.430
算法做对了

03:21.430 --> 03:22.430
虽然是可以的

03:22.430 --> 03:24.430
不管什么性能好性能差的

03:24.430 --> 03:25.430
都算做对了

03:25.430 --> 03:27.430
但是算法的题

03:27.430 --> 03:29.430
不允许出现任何抱错

03:29.430 --> 03:31.430
有任何一个地方抱错的

03:31.430 --> 03:33.430
都是没有份的

03:33.430 --> 03:36.430
所以说这个严谨性判断必须得写

03:36.430 --> 03:38.430
而且必须得重视

03:38.430 --> 03:41.430
否则写的再多跟没写一样

03:41.430 --> 03:43.430
因为这是算法的要素

03:43.430 --> 03:45.430
严谨性判断

03:45.430 --> 03:47.430
这是辨定一个数组

03:47.430 --> 03:48.430
我们可以看到

03:48.430 --> 03:50.430
可以用一种循环的方式来辨定

03:50.430 --> 03:51.430
对吧

03:51.430 --> 03:53.430
咱们再写一个

03:54.430 --> 03:56.430
咱们上节课不是说了

03:56.430 --> 03:58.430
节点吗

03:58.430 --> 03:59.430
我创建一个node

03:59.430 --> 04:03.320
this value 等于 value

04:04.320 --> 04:05.320
然后

04:06.320 --> 04:08.320
this left

04:09.320 --> 04:10.320
等于空

04:10.320 --> 04:12.320
this the next 等于空

04:12.320 --> 04:14.320
这样的一个node节点

04:14.320 --> 04:15.320
对吧

04:15.320 --> 04:20.490
然后我们来创建几个node

04:20.490 --> 04:22.490
所以就创建五个node吧

04:23.490 --> 04:25.490
where一个

04:25.490 --> 04:28.490
node1 等于你有一个node

04:28.490 --> 04:31.490
node1 等于你有一个node

04:31.490 --> 04:36.700
1 2 3 4 5 是吧

04:36.700 --> 04:39.700
2 3 4 5

04:39.700 --> 04:43.700
1 2 3 4 5

04:43.700 --> 04:45.700
有这样的五个节点

04:45.700 --> 04:49.700
然后node1 the next 等于node2

04:50.700 --> 04:54.700
然后node2 the next 等于node3

04:55.700 --> 04:59.700
然后node3 the next 等于node4

05:00.700 --> 05:05.700
然后node4 the next 等于node5

05:06.700 --> 05:08.700
是吧 这样的话我们就形成了一个链表是吧

05:08.700 --> 05:10.700
1的下一个是2 2的下一个是3

05:10.700 --> 05:12.700
3的下一个是4 4的下一个是5

05:12.700 --> 05:16.700
那问这样的东西我们该如何便利

05:17.700 --> 05:19.700
这样的便利怎么便利

05:19.700 --> 05:21.700
它叫便利ar

05:21.700 --> 05:23.700
我们再写一个

05:23.700 --> 05:25.700
写一个方式

05:25.700 --> 05:27.700
便利link

05:30.010 --> 05:32.010
然后传入一个node

05:33.010 --> 05:35.010
root吧

05:35.010 --> 05:38.010
root在这个算法里面属于跟接点的意思

05:38.010 --> 05:40.010
跟接点

05:40.010 --> 05:42.010
还记着吗 我们上段课说过

05:42.010 --> 05:45.010
如果我想传递一个链表我要传的是什么

05:45.010 --> 05:48.010
我们只能传跟接点 是吧

05:48.010 --> 05:50.010
比如说我调用

05:51.010 --> 05:54.010
便link 我要传的人

05:54.010 --> 05:56.010
我要传的是node1 是吧

05:56.010 --> 05:58.010
因为通过1可以通过node1

05:58.010 --> 06:00.010
node4找到2 2的node4找到3 是吧

06:00.010 --> 06:02.010
如果你传个2进去

06:02.010 --> 06:04.010
它没有办法找到1

06:04.010 --> 06:06.010
2的node4是3 3的node4是4

06:06.010 --> 06:08.010
4的node4是5 5的node4是空 是吧

06:08.010 --> 06:10.010
他们再也找不到1了

06:10.010 --> 06:12.010
所以说这块可以验证出来两个特性

06:12.010 --> 06:15.010
一个是我们如果想传递

06:15.010 --> 06:17.010
数组 后面想传递链表

06:17.010 --> 06:19.010
我们必须得传递跟接点

06:19.010 --> 06:20.010
再有一个就是

06:20.010 --> 06:22.010
每一个

06:22.010 --> 06:24.010
每一个

06:24.010 --> 06:26.010
节点都会认为是自己是跟接点

06:26.010 --> 06:28.010
就像你这块如果传递一个node2

06:28.010 --> 06:30.010
那就是node2 打印的是node2

06:30.010 --> 06:32.010
node2的node3

06:32.010 --> 06:34.010
node3的node4

06:34.010 --> 06:36.010
node4的node5

06:36.010 --> 06:38.010
就这样的一个过程

06:38.010 --> 06:40.010
然后我们看看我们有个root 是吧

06:40.010 --> 06:42.010
然后我们不论怎样

06:42.010 --> 06:44.010
我们期望的都是来打印这个root 是吧

06:44.010 --> 06:46.010
看好了

06:46.010 --> 06:48.010
were一个temp等于root

06:48.010 --> 06:50.010
我们用temp来进行一个技存

06:50.010 --> 06:52.010
temp来进行技存

06:52.010 --> 06:54.010
然后链表有多长

06:54.010 --> 06:56.010
我们知道吗

06:56.010 --> 06:57.010
链表有多长

06:57.010 --> 06:58.010
我们是不知道的

06:58.010 --> 06:59.010
它不像数组

06:59.010 --> 07:00.010
数组直接点达这个长度

07:00.010 --> 07:01.010
所以

07:01.010 --> 07:03.010
不知道多长的时候

07:03.010 --> 07:04.010
我们尽量用were处

07:04.010 --> 07:06.010
were循环

07:06.010 --> 07:08.010
复数循环是知道循环次数的

07:08.010 --> 07:10.010
不知道循环次数的呢

07:10.010 --> 07:12.010
我们就用were处

07:12.010 --> 07:13.010
然后呢

07:13.010 --> 07:14.010
if

07:14.010 --> 07:15.010
temp

07:15.010 --> 07:17.010
不等于kong

07:17.010 --> 07:20.010
那我们就打印

07:20.010 --> 07:22.010
temp的y6

07:23.010 --> 07:27.010
否则的话就不打印

07:27.010 --> 07:28.010
else

07:28.010 --> 07:30.010
temp都微kong了

07:30.010 --> 07:32.010
这个链表就结束了

07:32.010 --> 07:33.010
对吧

07:33.010 --> 07:34.010
temp如果微kong了

07:34.010 --> 07:35.010
就代表这个链表结束了

07:35.010 --> 07:36.010
或者就没有这个链表

07:36.010 --> 07:38.010
那就break

07:39.010 --> 07:40.010
然后呢

07:40.010 --> 07:41.010
我们让temp

07:41.010 --> 07:44.010
看好了等于temp的next

07:44.010 --> 07:45.010
看好了

07:45.010 --> 07:47.010
如果root现在是node1

07:47.010 --> 07:48.010
那现在

07:48.010 --> 07:50.010
temp就指向的是node1 是吧

07:50.010 --> 07:51.010
然后呢

07:51.010 --> 07:53.010
temp等于temp的next

07:53.010 --> 07:55.010
temp就变成node2了

07:55.010 --> 07:56.010
是吧

07:56.010 --> 07:57.010
然后如果不等于kong

07:57.010 --> 07:58.010
就打印值

07:58.010 --> 07:59.010
然后呢

07:59.010 --> 08:00.010
temp

08:00.010 --> 08:01.010
node2又等于node3 是吧

08:01.010 --> 08:03.010
temp又等于node3了

08:03.010 --> 08:04.010
然后再打印

08:04.010 --> 08:05.010
然后又temp等于node4了

08:05.010 --> 08:06.010
再打印

08:06.010 --> 08:07.010
temp等于node5了

08:07.010 --> 08:08.010
再打印

08:08.010 --> 08:09.010
temp等于kong了

08:09.010 --> 08:10.010
发现不走这个了

08:10.010 --> 08:11.010
走到这个了

08:11.010 --> 08:12.010
break

08:12.010 --> 08:13.010
这就打印完了

08:13.010 --> 08:14.010
这是一个这样的过程

08:14.010 --> 08:16.010
这是循环便利

08:17.010 --> 08:19.010
看看

08:22.920 --> 08:24.920
我们传递的一个node1

08:24.920 --> 08:25.920
传递一个node1

08:27.920 --> 08:28.920
是吧

08:28.920 --> 08:29.920
打印的是12345

08:29.920 --> 08:30.920
打印的是12345

08:31.920 --> 08:32.920
这样的话呢

08:32.920 --> 08:33.920
我们就能用便利的方式

08:33.920 --> 08:34.920
来便利数组和列表

08:34.920 --> 08:35.920
数组

08:35.920 --> 08:36.920
我们还没

08:36.920 --> 08:37.920
演示呢 是吧

08:37.920 --> 08:38.920
变

08:44.920 --> 08:45.920
对吧

08:45.920 --> 08:46.920
12345678

08:46.920 --> 08:47.920
然后12345

08:47.920 --> 08:48.920
因为数组

08:48.920 --> 08:49.920
这里面要卸了8位

08:49.920 --> 08:50.920
这个呢

08:50.920 --> 08:52.920
就是循环便利

08:52.920 --> 08:54.920
除了循环便利之外

08:54.920 --> 08:55.920
我们

08:55.920 --> 08:56.920
很多的同学

08:56.920 --> 08:57.920
学过一点算法的人

08:57.920 --> 08:58.920
都知道

08:58.920 --> 08:59.920
对于

08:59.920 --> 09:00.920
链表来说

09:00.920 --> 09:01.920
我们最常用的是

09:01.920 --> 09:02.920
地规便利

09:02.920 --> 09:03.920
那我们下一节

09:03.920 --> 09:04.920
来说

09:04.920 --> 09:05.920
链表的

09:05.920 --> 09:06.920
地规便利

