WEBVTT

00:01.520 --> 00:03.520
哈喽 大家好啊

00:03.520 --> 00:06.520
上一集我们说了什么是数据结构啊

00:06.520 --> 00:07.520
说了什么是算法

00:07.520 --> 00:10.520
今天我们就来说第一个内容啊

00:10.520 --> 00:11.520
也就是第一个数据结构

00:11.520 --> 00:14.520
也就是线性数据结构

00:14.520 --> 00:17.520
我先来看一下PPT

00:17.520 --> 00:20.520
线性数据结构呢也被称为一围数据结构

00:20.520 --> 00:22.520
这个一围 二围 三围 四围

00:22.520 --> 00:25.520
和我们世界里面认为的一围 二围 三围 四围

00:25.520 --> 00:27.520
基本上是一二的 是吧

00:27.520 --> 00:29.520
一围是条线

00:29.520 --> 00:31.520
二围是个面

00:31.520 --> 00:32.520
三围是个立方体

00:32.520 --> 00:34.520
四围带空间

00:34.520 --> 00:36.520
四围带世界 是吧

00:36.520 --> 00:38.520
所以说我们说的一围的数据结构

00:38.520 --> 00:41.520
也被称为线性数据结构

00:41.520 --> 00:43.520
换句话说干嘛呢

00:43.520 --> 00:44.520
线性数据结构啊

00:44.520 --> 00:46.520
其实就是把一堆数给存起来

00:46.520 --> 00:48.520
没有什么可说的

00:48.520 --> 00:50.520
就是一个类似于什么呢

00:50.520 --> 00:52.520
一个饼干盒

00:52.520 --> 00:55.520
它就把所有的饼干都放到盒子里

00:55.520 --> 00:59.900
线性的数据结构

00:59.900 --> 01:01.900
数据结构

01:01.900 --> 01:03.900
强调

01:03.900 --> 01:05.900
强调什么呢

01:05.900 --> 01:07.900
强调的是存储

01:07.900 --> 01:09.900
与

01:09.900 --> 01:11.900
与

01:11.900 --> 01:13.900
顺序

01:13.900 --> 01:15.900
线性的数据结构

01:15.900 --> 01:18.900
强调的是存储与顺序

01:18.900 --> 01:20.900
它是一个最基本的数据结构

01:20.900 --> 01:22.900
这种数据结构

01:22.900 --> 01:24.900
几乎没有什么任何的特性

01:24.900 --> 01:26.900
几乎没有什么任何特殊的东西

01:26.900 --> 01:28.900
都是一些最基本的东西

01:29.900 --> 01:32.900
它所以最广泛的用来就是存储

01:32.900 --> 01:33.900
我有一些数

01:33.900 --> 01:35.900
我想把它从A的地方给它拌动B的地方

01:35.900 --> 01:36.900
怎么办呢

01:36.900 --> 01:37.900
给它存起来吧

01:37.900 --> 01:38.900
拿什么存呢

01:38.900 --> 01:40.900
最简单的东西就是数组和链表

01:40.900 --> 01:42.900
先给它存起来

01:42.900 --> 01:45.900
很多的同学不太了解

01:45.900 --> 01:46.900
什么是数组

01:46.900 --> 01:47.900
什么是链表

01:47.900 --> 01:49.900
我们今天就先来讲

01:49.900 --> 01:50.900
第一个

01:50.900 --> 01:54.900
我们比较好理解的数据结构数组

01:54.900 --> 01:56.900
在大家在学习GS的过程中

01:56.900 --> 01:57.900
是不是也都学了

01:57.900 --> 01:58.900
什么是数组

01:58.900 --> 01:59.900
是吧

01:59.900 --> 02:01.900
都知道你有一个额锐

02:01.900 --> 02:03.900
或者是直接用数组

02:03.900 --> 02:05.900
放入号就能给弄出来一个数组

02:05.900 --> 02:06.900
是吧

02:06.900 --> 02:08.900
今天的我们来说的

02:08.900 --> 02:10.900
不是GS里面的数组

02:10.900 --> 02:11.900
到底怎么写

02:11.900 --> 02:13.900
我们要说的是数组的特性

02:13.900 --> 02:15.900
我们要说的是数组的特性

02:15.900 --> 02:16.900
看好了

02:16.900 --> 02:19.900
数组有一个非常大的一个特性

02:19.900 --> 02:21.900
叫做数组定长

02:27.380 --> 02:28.380
有的同学说

02:28.380 --> 02:31.380
我们前端里面数组好像不定长

02:31.380 --> 02:33.380
我设就是一个数组

02:33.380 --> 02:34.380
我也没给它长度

02:34.380 --> 02:36.380
然后我就可以不停的往里面塞东西

02:36.380 --> 02:37.380
是吧

02:37.380 --> 02:40.380
你感觉你用的数组是不定长的

02:40.380 --> 02:42.380
它的底层是定长的

02:42.380 --> 02:44.380
只不过它的长度

02:44.380 --> 02:45.380
达到了一定的数值的时候

02:45.380 --> 02:47.380
它自动的扩容了

02:47.380 --> 02:50.380
这是GS的引擎帮你实现的

02:50.380 --> 02:51.380
那有的同学说

02:51.380 --> 02:52.380
GS引擎就是帮我实现了

02:52.380 --> 02:53.380
我不管了不就等了

02:53.380 --> 02:54.380
不行

02:54.380 --> 02:57.380
扩容的过程是消耗性能的

02:57.380 --> 03:00.380
扩容的过程是消耗性能的

03:00.380 --> 03:01.380
好的程序源

03:01.380 --> 03:04.380
它在程序在运行的过程中

03:04.380 --> 03:07.380
它能够预先的设定好

03:07.380 --> 03:09.380
我大概数组需要多长

03:09.380 --> 03:10.380
我打好提前量

03:10.380 --> 03:11.380
我在声明的时候

03:11.380 --> 03:13.380
就给它声明出来

03:13.380 --> 03:16.380
在我使用数组的整个过程中

03:16.380 --> 03:19.380
它不会出现任何扩容的时候

03:19.380 --> 03:20.380
但是一个普通的程序源

03:20.380 --> 03:21.380
它就是

03:21.380 --> 03:22.380
既然它能自己扩容

03:22.380 --> 03:24.380
我就声明一个

03:24.380 --> 03:25.380
随便声明一个

03:25.380 --> 03:26.380
然后它就往里面放

03:26.380 --> 03:28.380
然后就会不停的扩容

03:28.380 --> 03:31.380
这种扩容的过程是消耗CPL的

03:31.380 --> 03:33.380
会影响我们的性能

03:33.380 --> 03:35.380
所以说数组在底层上

03:35.380 --> 03:37.380
叫做数组定长

03:37.380 --> 03:40.380
数组在初始化的时候

03:40.380 --> 03:41.380
多长

03:41.380 --> 03:42.380
它就是多长

03:42.380 --> 03:44.380
我们扩容是怎么实现的

03:44.380 --> 03:46.380
比如说我这个数组长度为8

03:46.380 --> 03:48.380
我往里面放的第九个值怎么办

03:48.380 --> 03:50.380
它会先创建出了一个

03:50.380 --> 03:52.380
长度可能为16的

03:52.380 --> 03:54.380
因为它操作系统

03:54.380 --> 03:55.380
不能像烂程圈那么傻

03:55.380 --> 03:57.380
操作系统

03:57.380 --> 03:59.380
引擎会打点提前量

03:59.380 --> 04:00.380
是吧

04:00.380 --> 04:02.380
8个既然存不下了

04:02.380 --> 04:04.380
你证明你这个人质账

04:04.380 --> 04:05.380
我这就多给你讲

04:05.380 --> 04:06.380
看看你能不能存得下

04:06.380 --> 04:08.380
所以它可能自动会给你

04:08.380 --> 04:10.380
划一个16的长度

04:10.380 --> 04:12.380
所以这种情况下

04:12.380 --> 04:14.380
你就可以放了第九了

04:14.380 --> 04:16.380
划了一个新的16个长度的

04:16.380 --> 04:18.380
之后怎么办

04:18.380 --> 04:20.380
得把刚才的那8个给它复制过来

04:20.380 --> 04:21.380
是吧

04:21.380 --> 04:23.380
因为数组定长

04:23.380 --> 04:25.380
数组定长是什么意思

04:26.380 --> 04:29.380
数组的长度是不可变的

04:29.380 --> 04:31.380
刚才我的数组长度为8

04:31.380 --> 04:35.140
刚才我的数组长度为8

04:35.140 --> 04:37.140
这里面存了几个数

04:37.140 --> 04:43.140
比如说12345678

04:43.140 --> 04:46.140
我现在忽然要来了一个数字9

04:46.140 --> 04:49.140
我这8个肯定是存不下了

04:49.140 --> 04:50.140
绝对不是说

04:50.140 --> 04:52.140
扩容绝对不是这样的

04:52.140 --> 04:53.140
往后这样扩容

04:53.140 --> 04:54.140
可不是这样的

04:54.140 --> 04:58.140
而是在一个新的空间

04:58.140 --> 05:00.140
划分出来

05:00.140 --> 05:04.030
16块内容

05:04.030 --> 05:07.860
连续的

05:07.860 --> 05:09.860
我这个都划不下了

05:10.860 --> 05:12.860
在一个新的空间划分出来

05:12.860 --> 05:13.860
16块内容

05:13.860 --> 05:15.860
把这些数字给删掉

05:15.860 --> 05:17.860
前8个数是复制过来的

05:17.860 --> 05:20.860
然后有的同学就会说

05:20.860 --> 05:22.860
老师那为什么不直接往后扩容

05:22.860 --> 05:24.860
直接往后扩容多方便

05:24.860 --> 05:25.860
是吧

05:25.860 --> 05:28.860
如果你在面试的时候千万别这么说话

05:28.860 --> 05:29.860
面试的时候

05:29.860 --> 05:31.860
你就认为它是这样扩容就行了

05:31.860 --> 05:33.860
面试的时候千万不要这么问

05:33.860 --> 05:34.860
这么问的话

05:34.860 --> 05:36.860
会让人发现

05:36.860 --> 05:37.860
你不但不懂酸话

05:37.860 --> 05:39.860
居然还不懂操作系统

05:41.860 --> 05:42.860
内存的分配

05:42.860 --> 05:44.860
都是操作系统给分配的

05:44.860 --> 05:45.860
所以说

05:45.860 --> 05:47.860
你说我想要

05:47.860 --> 05:49.860
把这些数字

05:49.860 --> 05:51.860
把这些数字

05:51.860 --> 05:52.860
操作系统给分配的

05:52.860 --> 05:53.860
所以说

05:53.860 --> 05:55.860
你说我想要

05:55.860 --> 05:56.860
一块新的空间

05:56.860 --> 05:58.860
操作系统不一定给你分配在哪

05:59.860 --> 06:01.860
你只能跟操作系统说啥

06:01.860 --> 06:03.860
我想要一块连续的

06:03.860 --> 06:04.860
多大的空间

06:04.860 --> 06:07.860
我想要一块连续的多大的空间

06:07.860 --> 06:09.860
你说我想要一块空间

06:09.860 --> 06:10.860
操作系统给你放在这

06:12.860 --> 06:13.860
是吧

06:13.860 --> 06:14.860
你这个数就存不进去了

06:14.860 --> 06:16.860
它不是在后面接着的

06:16.860 --> 06:17.860
所以说

06:17.860 --> 06:18.860
生命

06:18.860 --> 06:20.860
申请存储空间

06:20.860 --> 06:22.860
是操作系统做的

06:22.860 --> 06:23.860
所以说

06:23.860 --> 06:25.860
当你这个数存不下的时候

06:25.860 --> 06:27.860
GS引擎只能向操作系统

06:27.860 --> 06:29.860
去申请一个什么

06:29.860 --> 06:30.860
我想要一块连续的

06:30.860 --> 06:32.860
长度为16的

06:32.860 --> 06:33.860
操作系统

06:33.860 --> 06:34.860
夸给它分配一个

06:34.860 --> 06:35.860
长度为16的

06:35.860 --> 06:36.860
连续的

06:36.860 --> 06:37.860
然后

06:37.860 --> 06:38.860
它要先苦哈哈的

06:38.860 --> 06:39.860
先把之前的

06:39.860 --> 06:41.860
八个数给它复制过来

06:41.860 --> 06:42.860
你说这个过程

06:42.860 --> 06:43.860
又分配内存

06:43.860 --> 06:44.860
又复制数据

06:44.860 --> 06:45.860
小不小要行的

06:45.860 --> 06:46.860
行好是吧

06:46.860 --> 06:47.860
然后

06:47.860 --> 06:48.860
再把第九个数

06:48.860 --> 06:49.860
放进去

06:50.860 --> 06:51.860
这个是在

06:51.860 --> 06:53.860
扩容的过程中干的事

06:54.860 --> 06:55.860
所以说

06:55.860 --> 06:57.860
我们在使用数组的时候

06:57.860 --> 06:58.860
最好怎么样

06:58.860 --> 06:59.860
最好

06:59.860 --> 07:01.860
先大概的预估出来

07:01.860 --> 07:03.860
我这个数组大概有多长

07:03.860 --> 07:04.860
是吧

07:04.860 --> 07:05.860
自己的业务自己知道

07:05.860 --> 07:06.860
比如说你要做

07:06.860 --> 07:07.860
翻页的算法

07:07.860 --> 07:09.860
我一页就是十条数据

07:09.860 --> 07:10.860
那我设置数组就

07:10.860 --> 07:11.860
长度为十

07:11.860 --> 07:12.860
是吧

07:12.860 --> 07:13.860
要么它默认的数组

07:13.860 --> 07:14.860
长度如果为八

07:14.860 --> 07:15.860
那我这个上来可能

07:15.860 --> 07:16.860
存及九个还得扩容

07:16.860 --> 07:17.860
何必呢

07:17.860 --> 07:18.860
就多那两

07:18.860 --> 07:20.860
直接就生命出来多好

07:20.860 --> 07:21.860
是吧

07:21.860 --> 07:23.860
如果你要做的东西

07:23.860 --> 07:25.860
比如说是一个碳知识的

07:25.860 --> 07:26.860
我就上来先

07:26.860 --> 07:27.860
我先统计一下

07:27.860 --> 07:29.860
大概一个人大概能活多久

07:29.860 --> 07:30.860
能玩碳知识

07:30.860 --> 07:31.860
能玩多久

07:31.860 --> 07:33.860
大概有100来节的时候

07:33.860 --> 07:34.860
就挂了是吧

07:34.860 --> 07:35.860
我就先声明出来一个

07:35.860 --> 07:36.860
长度为120

07:36.860 --> 07:38.860
我让绝大多数人

07:38.860 --> 07:40.860
都在没用完我的数组的时候

07:40.860 --> 07:41.860
挂掉

07:41.860 --> 07:42.860
游戏结束

07:42.860 --> 07:43.860
这样的话

07:43.860 --> 07:45.860
就能保证我的程序的完美运行

07:45.860 --> 07:46.860
在整个运行的过程中

07:46.860 --> 07:48.860
不发生数组困难的情况

07:48.860 --> 07:49.860
也就不会消耗

07:49.860 --> 07:52.860
有额外的这种性能消耗

07:52.860 --> 07:54.860
这是数组的特性

07:54.860 --> 07:56.860
我们来看一个

07:57.860 --> 07:59.860
来做一个小小的总结

08:00.860 --> 08:02.860
数组的特性1

08:02.860 --> 08:06.170
数组的特性

08:06.170 --> 08:09.170
数组的特性就是存储1

08:09.170 --> 08:13.170
存储在物理空间上

08:14.170 --> 08:16.170
是连续的

08:17.170 --> 08:19.170
它的存储在物理空间上

08:19.170 --> 08:20.170
是连续的

08:20.170 --> 08:21.170
然后

08:21.170 --> 08:22.170
第二个特性

08:24.170 --> 08:28.170
长度是不可辨的

08:28.170 --> 08:30.170
底层的数组

08:32.170 --> 08:34.170
长度是不可辨的

08:34.170 --> 08:35.170
我们之所以

08:35.170 --> 08:36.170
我们所见到的数组

08:36.170 --> 08:38.170
长度是可辨的

08:38.170 --> 08:39.170
是什么

08:40.170 --> 08:41.170
是因为GSC引擎

08:41.170 --> 08:43.170
给我们做了优化

08:43.170 --> 08:44.170
如果你学的

08:44.170 --> 08:45.170
不是GSC语言

08:45.170 --> 08:46.170
是其他的语言的话

08:46.170 --> 08:47.170
人家都会告诉你

08:47.170 --> 08:48.170
数组的长度

08:48.170 --> 08:49.170
就是固定的

08:49.170 --> 08:50.170
没有可辨的

08:52.170 --> 08:53.170
这是数组的特性

08:55.170 --> 08:57.170
由于数组的特性

08:57.170 --> 08:58.170
就会衍生出来

08:58.170 --> 08:59.170
数组的优点

08:59.170 --> 09:01.170
以及数组的缺点

09:03.170 --> 09:04.170
我们现在说优点

09:06.170 --> 09:07.170
因为它空间是连续的

09:07.170 --> 09:08.170
你们知道我们比如说

09:08.170 --> 09:10.170
数组我们写一个这样

09:10.170 --> 09:14.060
写一个数组A

09:15.060 --> 09:16.060
然后等于

09:16.060 --> 09:18.060
怎么给我变成大写了

09:20.060 --> 09:23.060
数组A

09:23.060 --> 09:24.060
小小了吧

09:24.060 --> 09:26.060
数组A等于

09:26.060 --> 09:28.060
这么多东西

09:28.060 --> 09:30.060
1 2 3 4 5 6 7 8

09:33.690 --> 09:38.340
A是这么快的东西

09:38.340 --> 09:40.340
典型A是数组

09:40.340 --> 09:41.340
问

09:41.340 --> 09:43.340
A指向了哪

09:43.340 --> 09:45.340
说A指向数组

09:45.340 --> 09:46.340
我告诉大家

09:46.340 --> 09:49.340
A指向的是数组的起点

09:49.340 --> 09:52.340
数组第1个元素的位置

09:57.130 --> 09:59.130
数组的变量

10:01.130 --> 10:02.130
指向了

10:03.130 --> 10:08.130
数组第1个元素的位置

10:09.130 --> 10:10.130
数组的变量

10:10.130 --> 10:12.130
指向了数组第1个元素的位置

10:12.130 --> 10:14.130
比如说A等于1 2 3 4 5 6 7 8

10:14.130 --> 10:15.130
这个数组

10:15.130 --> 10:17.130
在物理上的空间存储是这样的

10:17.130 --> 10:18.130
A指向了谁呢

10:18.130 --> 10:19.130
A就指向了

10:19.130 --> 10:20.130
E的这个起点

10:20.130 --> 10:22.130
A指向了E的这个起点

10:22.130 --> 10:23.130
然后我们说

10:23.130 --> 10:24.130
在使用数组的时候

10:24.130 --> 10:26.130
比如说我要使用数组的第2个

10:26.130 --> 10:28.130
第2个元素是什么

10:28.130 --> 10:30.130
A-1是吧

10:30.130 --> 10:33.130
第3个元素就是A-2是吧

10:33.130 --> 10:36.130
第4个元素就是A-3是吧

10:36.130 --> 10:38.130
方库号是什么

10:38.130 --> 10:40.130
方库号是什么

10:40.130 --> 10:43.130
方库号表示的是偏移

10:43.130 --> 10:46.130
方库号表示的是偏移

10:48.130 --> 10:53.130
方库号表示存储

10:53.130 --> 10:57.130
地址的偏移

10:57.130 --> 11:01.140
在这个之前

11:01.140 --> 11:04.140
有个操作系统上的一个小知识

11:04.140 --> 11:07.140
就是通过偏移去寻找一个数

11:07.140 --> 11:08.140
性能比较好

11:08.140 --> 11:11.140
这是一个操作系统层面的小知识

11:11.140 --> 11:24.240
通过偏移查询数据

11:24.240 --> 11:26.240
性能最好

11:27.240 --> 11:30.240
通过偏移查询数据性能最好

11:30.240 --> 11:31.240
不得已了

11:31.240 --> 11:34.240
我得给它拿下一点

11:34.240 --> 11:43.300
通过偏移查询数据性能最好

11:43.300 --> 11:46.300
所以说数组的一个优点

11:46.300 --> 11:50.300
就是查询性能好

11:50.300 --> 11:53.300
优点

11:53.300 --> 11:58.300
查询性能好

11:59.300 --> 12:01.300
在查询的过程中

12:01.300 --> 12:02.300
我想要第几个

12:02.300 --> 12:04.300
我就能直接找到第几个

12:04.300 --> 12:05.300
我想要第六个

12:05.300 --> 12:06.300
我能直接找到第六个

12:06.300 --> 12:08.300
我想要第七个

12:08.300 --> 12:10.300
我就能直接拿到第七个

12:10.300 --> 12:12.300
所以说它的查询性能好

12:12.300 --> 12:14.300
我们再来看数组有什么缺点

12:14.300 --> 12:16.300
说数组没有别的优点

12:16.300 --> 12:18.300
还真没了

12:18.300 --> 12:20.300
数组的优点

12:20.300 --> 12:21.300
唯一的优点

12:21.300 --> 12:23.300
就是查询的时候性能好

12:23.300 --> 12:24.300
数组

12:24.300 --> 12:26.300
我们来看看数组的缺点

12:26.300 --> 12:28.300
数组的第一个缺点

12:28.300 --> 12:34.300
因为空间必须得是连续的

12:34.300 --> 12:39.300
所以如果数组比较大

12:39.300 --> 12:42.300
容易存不下

12:42.300 --> 12:47.130
你说我家有个大衣柜

12:47.130 --> 12:48.130
特别的大

12:48.130 --> 12:49.130
还不能拆

12:49.130 --> 12:51.130
它进门都费劲

12:51.130 --> 12:53.130
如果这个东西能拆

12:53.130 --> 12:54.130
它多大都行

12:54.130 --> 12:56.130
我给它拆碎了

12:56.130 --> 12:58.130
然后找个墙脚给它堆砌

12:58.130 --> 12:59.130
是吧

12:59.130 --> 13:00.130
所以这是它的缺点

13:00.130 --> 13:04.130
所以说为什么会容易存不下呢

13:04.130 --> 13:06.130
有个前提

13:06.130 --> 13:14.130
当系统的空间碎片较多的时候

13:14.130 --> 13:17.130
当系统的空间碎片较多的时候

13:17.130 --> 13:20.130
容易存不下

13:20.130 --> 13:23.130
当系统的空间碎片较多的时候

13:23.130 --> 13:27.460
容易存不下

13:27.460 --> 13:30.460
把它们变成两行

13:30.460 --> 13:31.460
缺点1

13:31.460 --> 13:35.460
因为它在空间必须得是连续的

13:35.460 --> 13:38.460
所以

13:38.460 --> 13:40.460
因为它这个空间必须得是连续的

13:40.460 --> 13:43.460
所以当系统数组比较大

13:43.460 --> 13:45.460
然后空间碎片比较多的时候

13:45.460 --> 13:46.460
容易存不下

13:46.460 --> 13:48.460
空间碎片有很多朋友

13:48.460 --> 13:50.460
不知道什么意思

13:50.460 --> 13:52.460
简单说一下

13:52.460 --> 13:55.460
我们用的每一个程序

13:55.460 --> 13:58.460
它都是一个程序

13:58.460 --> 13:59.460
既然是程序

13:59.460 --> 14:00.460
它得生命变量

14:00.460 --> 14:02.460
生命变量的变量

14:02.460 --> 14:05.460
就得占用系统的存储空间

14:05.460 --> 14:08.460
这个变量在销毁的时候

14:08.460 --> 14:10.460
这块空间也被置空了

14:10.460 --> 14:11.460
在生命的时候

14:11.460 --> 14:13.460
那系统肯定是iPad给的分配

14:13.460 --> 14:14.460
第一个位置

14:14.460 --> 14:15.460
第二个位置

14:15.460 --> 14:16.460
第三个位置

14:16.460 --> 14:17.460
第四个位置

14:17.460 --> 14:18.460
但是用着用着

14:18.460 --> 14:19.460
可能第二个位置不用了

14:19.460 --> 14:20.460
清空了

14:20.460 --> 14:21.460
第二个位置就空出来

14:21.460 --> 14:22.460
然后就是断开

14:22.460 --> 14:25.460
一三四五六七八九

14:25.460 --> 14:27.460
待会六七可能不用了

14:27.460 --> 14:31.460
那就是一三四五八九

14:31.460 --> 14:34.460
中间就会有这种小小的空档

14:34.460 --> 14:35.460
你说它简直说

14:35.460 --> 14:36.460
刚才十个位置

14:36.460 --> 14:37.460
我空了三个

14:37.460 --> 14:38.460
按理来说

14:38.460 --> 14:40.460
我长度为三的数组能放得下

14:40.460 --> 14:42.460
但是因为数组必须得是连续的

14:42.460 --> 14:44.460
但是它这三个的空间的位置

14:44.460 --> 14:45.460
不是连续的

14:45.460 --> 14:49.460
这种小的空间的空间

14:49.460 --> 14:51.460
我们就称之为空间碎片

14:51.460 --> 14:54.460
所以说数组在遇到空间碎片的时候

14:54.460 --> 14:55.460
就很难干

14:55.460 --> 14:56.460
明明空间感觉够用

14:56.460 --> 14:58.460
但是我却放不下一个数组

14:58.460 --> 15:00.460
所以说这是数组的第一个缺点

15:00.460 --> 15:02.460
其实也是大数组的缺点

15:02.460 --> 15:04.460
所以说我们在编程的过程中

15:04.460 --> 15:06.460
要避免数组过大

15:06.460 --> 15:08.460
不要让那数组太长

15:08.460 --> 15:09.460
数组有的同学生命的数字

15:09.460 --> 15:10.460
长得为1万

15:10.460 --> 15:11.460
长得为2万

15:11.460 --> 15:12.460
这样的话

15:12.460 --> 15:14.460
对于我们的空间的性能

15:14.460 --> 15:16.460
要求是很高的

15:16.460 --> 15:18.460
系统为了能存下

15:19.460 --> 15:22.460
解释我的系统空间有一个G

15:22.460 --> 15:24.460
我就往里面存一个

15:24.460 --> 15:28.460
我往里面存一个200兆的数组

15:28.460 --> 15:29.460
是不是应该能存下

15:29.460 --> 15:31.460
我系统空间有一个G

15:31.460 --> 15:32.460
我存200兆的数组

15:32.460 --> 15:34.460
为什么存不下呢

15:34.460 --> 15:36.460
但是因为有太多的是空间碎片

15:36.460 --> 15:39.460
没有连续的200兆的空间

15:39.460 --> 15:40.460
所以它存不下

15:40.460 --> 15:42.460
系统为了能够让你存下

15:42.460 --> 15:43.460
因为你看着能存下

15:43.460 --> 15:44.460
我就得让你能存下

15:44.460 --> 15:47.460
然后它就会整理空间

15:47.460 --> 15:49.460
你说这系统一整理空间

15:49.460 --> 15:50.460
它能不耗费C平吗

15:50.460 --> 15:52.460
它能不耗费磁盘的独显

15:52.460 --> 15:53.460
性能能好

15:53.460 --> 15:54.460
那肯定不好

15:54.460 --> 15:55.460
对吧

15:55.460 --> 15:56.460
所以说

15:56.460 --> 15:59.460
纪念我们要避免数组过大

15:59.460 --> 16:01.460
这样的话

16:01.460 --> 16:03.460
我们要保证每个数组

16:03.460 --> 16:04.460
给操作系统的时候

16:04.460 --> 16:05.460
它直接能存下

16:05.460 --> 16:06.460
这样的话

16:06.460 --> 16:07.460
能不避免

16:07.460 --> 16:08.460
因为空间碎片

16:08.460 --> 16:09.460
较多

16:09.460 --> 16:11.460
而产生的一些性能问题

16:11.460 --> 16:13.460
而且有很多很多很多的性能问题

16:13.460 --> 16:15.460
说都说不完

16:15.460 --> 16:16.460
这样的问题

16:16.460 --> 16:19.460
具体会产生有哪些情况

16:19.460 --> 16:21.460
具体有哪些原因

16:21.460 --> 16:23.460
想见操作系统课

16:23.460 --> 16:24.460
当然了

16:24.460 --> 16:25.460
我现在还没有入操作系统课

16:25.460 --> 16:27.460
想见学校里的操作系统课

16:27.460 --> 16:29.460
这是操作系统原理

16:29.460 --> 16:31.460
不是我们讲的Linux

16:31.460 --> 16:32.460
是操作系统原理

16:34.460 --> 16:36.460
如果你学校里没有操作系统课

16:36.460 --> 16:37.460
你就先

16:37.460 --> 16:38.460
就当我说的是对的

16:38.460 --> 16:39.460
就OK的

16:39.460 --> 16:41.460
你不用那么深究操作系统

16:41.460 --> 16:43.460
然后再怎么对它进行操作

16:43.460 --> 16:44.460
总之

16:44.460 --> 16:45.460
空间碎片较多的时候

16:45.460 --> 16:48.460
操作系统会进行整理空间碎片

16:48.460 --> 16:50.460
非常的缓慢

16:50.460 --> 16:52.460
非常的学好性能

16:52.460 --> 16:53.460
好了

16:53.460 --> 16:54.460
这是第一个

16:54.460 --> 16:55.460
第二个

16:55.460 --> 16:58.460
你说我这个长度为8

16:58.460 --> 17:00.460
数组长度为8

17:00.460 --> 17:02.460
你说我一直就这样保持不动

17:02.460 --> 17:03.460
还好

17:03.460 --> 17:04.460
那我明天

17:04.460 --> 17:05.460
或者我说

17:05.460 --> 17:06.460
我不想要

17:06.460 --> 17:08.460
我让给它删了

17:08.460 --> 17:11.460
然后或者明天我想加个9

17:11.460 --> 17:14.460
它都会改变数组长度

17:15.460 --> 17:17.460
因为

17:17.460 --> 17:21.460
数组的长度是固定的

17:21.460 --> 17:23.460
所以

17:23.460 --> 17:27.460
数组的内容

17:27.460 --> 17:32.460
难以被添加和删除

17:35.100 --> 17:37.100
你说数组添加我能理解是吧

17:37.100 --> 17:39.100
数组长度为8

17:39.100 --> 17:41.100
然后我请添加一个9

17:41.100 --> 17:42.100
我放不下

17:42.100 --> 17:43.100
我得扩容是吧

17:43.100 --> 17:45.100
所以说添加一个内容

17:45.100 --> 17:46.100
我能理解是吧

17:46.100 --> 17:48.100
它得逍遥性能

17:48.100 --> 17:49.100
那有时候删除就删除

17:49.100 --> 17:51.100
我删除就不要它了

17:51.100 --> 17:52.100
我又能存在下

17:52.100 --> 17:53.100
为什么也不行

17:53.100 --> 17:54.100
你看

17:54.100 --> 17:55.100
你删除了是吧

17:55.100 --> 17:57.100
假如你不要5了

17:57.100 --> 17:59.100
你说A4这个位置在哪

17:59.100 --> 18:00.100
A0

18:00.100 --> 18:01.100
A1

18:01.100 --> 18:02.100
A2

18:02.100 --> 18:03.100
A4是吧

18:03.100 --> 18:05.100
A4这个位置是啥

18:05.100 --> 18:06.100
不能没有

18:06.100 --> 18:07.100
是吧

18:07.100 --> 18:08.100
你这个后面

18:08.100 --> 18:09.100
你有7个数

18:09.100 --> 18:10.100
你凭什么没有A4

18:10.100 --> 18:12.100
你一旦要把这个数删了

18:12.100 --> 18:13.100
你得把6往前移

18:13.100 --> 18:14.100
把7往前移

18:14.100 --> 18:15.100
把8往前移

18:15.100 --> 18:17.100
把8给删了

18:17.100 --> 18:20.100
8这个值给删了

18:20.100 --> 18:24.100
虽然它不用扩容数组了

18:24.100 --> 18:26.100
也不用缩容数组

18:26.100 --> 18:27.100
但是

18:27.100 --> 18:30.100
它得把后面数往前移

18:30.100 --> 18:31.100
对吧

18:31.100 --> 18:33.100
如果不把后面数往前移

18:33.100 --> 18:36.100
这个数组是不是就又出问题了

18:36.100 --> 18:38.100
所以说

18:38.100 --> 18:40.100
你要对数组操作的时候

18:40.100 --> 18:42.100
不论是添加一个数

18:42.100 --> 18:43.100
还是删除一个数

18:43.100 --> 18:46.100
代价都是非常大的

18:46.100 --> 18:48.100
没有我们看上去添加一个下

18:48.100 --> 18:50.100
和删除一下那么简单

18:50.100 --> 18:52.100
这就是数组的特性

18:52.100 --> 18:53.100
数组只有一个优点

18:53.100 --> 18:55.100
查询性能好

18:55.100 --> 18:57.100
查询性能好

18:57.100 --> 18:59.100
查询性能它有个限定

18:59.100 --> 19:04.100
就是指定查询某个位置

19:04.100 --> 19:06.100
比如说我查第三个

19:06.100 --> 19:07.100
我查第四个

19:07.100 --> 19:09.100
这种时候数组的性能是最好的

19:09.100 --> 19:10.100
没有任何数据结构

19:10.100 --> 19:11.100
可以和数组相比

19:11.100 --> 19:13.100
它可以直接定位到这个位置

19:13.100 --> 19:14.100
根据

19:14.100 --> 19:16.100
手地值加上偏移

19:16.100 --> 19:17.100
就能直接定位

19:17.100 --> 19:19.100
我们刚才说的操作系统小知识

19:19.100 --> 19:21.100
通过偏移查询性能最好

19:21.100 --> 19:23.100
这是数组的一个优点

19:23.100 --> 19:25.100
数组的缺点你看好了

19:25.100 --> 19:28.100
都是根据数组的特性而决定的

19:28.100 --> 19:30.100
数组的空间是连续的

19:30.100 --> 19:32.100
是数组的第一特性

19:32.100 --> 19:33.100
因为空间是连续的

19:33.100 --> 19:35.100
所以容易在空间随便

19:35.100 --> 19:37.100
多的时候存不下

19:37.100 --> 19:40.100
因为长度是固定的

19:40.100 --> 19:42.100
这个是数组的第二特性

19:42.100 --> 19:46.100
所以数组难以被添加和删除

19:46.100 --> 19:48.100
所以说优点也好

19:48.100 --> 19:51.100
缺点也好都取决于数组的特性

19:51.100 --> 19:52.100
发现了吗

19:52.100 --> 19:54.100
优点是取决于第三特性

19:54.100 --> 19:57.100
第三特性和第一特性

19:57.100 --> 20:00.100
手地值 引用指向手地值

20:00.100 --> 20:02.100
空间是连续的

20:02.100 --> 20:03.100
所以我根据手地值

20:03.100 --> 20:05.100
加上我要的第几块

20:05.100 --> 20:06.100
我就能瞬间的找到这个数

20:06.100 --> 20:08.100
这是它的优点

20:08.100 --> 20:10.100
缺点也是根据特性产生

20:10.100 --> 20:13.100
这是数组的优点和缺点

20:13.100 --> 20:14.100
好同学说

20:14.100 --> 20:16.100
缺点既然也很明显

20:16.100 --> 20:18.100
有的时候我想要避免

20:18.100 --> 20:20.100
这些缺点怎么办呢

20:20.100 --> 20:22.100
所以说我们回过头来说

20:22.100 --> 20:24.100
一位的数据也够

20:24.100 --> 20:26.100
我们常见的有两种

20:26.100 --> 20:28.100
一个是数组

20:28.100 --> 20:29.100
一个是练表

20:29.100 --> 20:31.100
练表的同学们之前没有学过

20:31.100 --> 20:33.100
我们下几课来说练表

20:33.100 --> 20:34.100
到了时候你会发现

20:34.100 --> 20:36.100
数组和练表的优缺点

20:36.100 --> 20:38.100
是完全互补的

20:38.100 --> 20:40.100
数组和练表的优缺点

20:40.100 --> 20:42.100
是完全互补的

20:42.100 --> 20:44.100
我们在数组的最后一堂课

20:44.100 --> 20:45.100
最后一点时间

20:45.100 --> 20:47.100
我们来简单的说一下

20:47.100 --> 20:50.100
在GS里面重建数组

20:50.100 --> 20:52.100
这个其实不用我怎么说了

20:52.100 --> 20:54.100
是吧

20:54.100 --> 20:56.100
无论一个a等于这个

20:56.100 --> 20:58.100
12345

21:00.100 --> 21:02.100
无论一个a等于一个数组

21:02.100 --> 21:04.100
数组可以怎么写

21:06.410 --> 21:08.410
12345

21:08.410 --> 21:10.410
怎么被杀了呢

21:10.410 --> 21:12.410
这样可以直接得到一个数组

21:12.410 --> 21:13.410
是吧

21:13.410 --> 21:15.410
或者怎么样

21:15.410 --> 21:18.410
你有一个array是吧

21:18.410 --> 21:19.410
我们推荐

21:19.410 --> 21:21.410
是不是用这种方法

21:21.410 --> 21:23.410
给它一个数10

21:23.410 --> 21:25.410
给它一个数10

21:27.410 --> 21:28.410
这种点进去

21:28.410 --> 21:30.410
我们传入的这个10

21:30.410 --> 21:33.410
其实就是它的初始化的长度

21:33.410 --> 21:35.410
就是我们建议它初始化的长度

21:35.410 --> 21:36.410
所以说

21:36.410 --> 21:39.410
我们尽量在使用的时候

21:39.410 --> 21:41.410
给它一个初始化的长度

21:41.410 --> 21:43.410
用这样的方式

21:43.410 --> 21:45.410
是性能最好的

21:45.410 --> 21:47.410
当然如果内容是固定的

21:47.410 --> 21:48.410
用这种方式

21:48.410 --> 21:49.410
一般都是为啥呢

21:49.410 --> 21:50.410
就是内容是固定的

21:50.410 --> 21:52.410
就这么几个值

21:52.410 --> 21:53.410
这种是OK的

21:53.410 --> 21:55.410
如果内容不是固定的

21:55.410 --> 21:57.410
比如说我的翻页

21:57.410 --> 22:00.410
第一页和第二页内容肯定不一样

22:00.410 --> 22:02.410
但是第一页和第二页的挑数

22:02.410 --> 22:03.410
最多是10条

22:03.410 --> 22:04.410
是吧

22:04.410 --> 22:06.410
我们利用一个array是

22:06.410 --> 22:08.410
让它的长度最高为10

22:08.410 --> 22:09.410
这样的话

22:09.410 --> 22:11.410
我们的性能能够达到最高

22:11.410 --> 22:13.410
这就是我们这一集的内容

22:13.410 --> 22:14.410
下一集

22:14.410 --> 22:15.410
我们就来说一个

22:15.410 --> 22:18.410
优缺点和数组都互补的

22:18.410 --> 22:19.410
另一种

22:19.410 --> 22:20.410
意味的数据结构

22:20.410 --> 22:21.410
练饼

22:21.410 --> 22:23.410
我们下单可见

