WEBVTT

00:00.430 --> 00:03.430
Hello 大家好

00:03.430 --> 00:05.430
上一集

00:05.430 --> 00:09.430
咱们说了 根据前续和中续 还原一颗二刹树

00:09.430 --> 00:12.430
这一集我们来说 根据中续和后续来还原二刹树

00:12.430 --> 00:14.430
根据中续和后续来还原二刹树

00:14.430 --> 00:17.430
忘题 叫代码 还是简单

00:17.430 --> 00:19.430
我把代码提上去

00:29.880 --> 00:32.880
前续和中续 不知道大家回去练练

00:32.880 --> 00:35.880
但是后续和中续 几乎跟前续和中续的顺序是一样的

00:35.880 --> 00:37.880
只不过逻辑不同

00:37.880 --> 00:39.880
只有逻辑不同

00:39.880 --> 00:41.880
代码实现

00:41.880 --> 00:47.820
二十五颗

00:47.820 --> 00:49.820
代码实现

00:49.820 --> 00:51.820
中续

00:51.820 --> 00:52.820
后续

00:52.820 --> 00:53.820
还原

00:53.820 --> 00:57.540
二刹树

00:57.540 --> 00:59.540
然后我先创建一个GS

00:59.540 --> 01:08.740
创建一个GS

01:08.740 --> 01:11.740
然后我们把中续后续给它写过来

01:11.740 --> 01:13.740
FG 有点多

01:13.740 --> 01:14.740
中

01:14.740 --> 01:17.820
什么

01:17.820 --> 01:20.820
FCGADBE

01:20.820 --> 01:24.820
FCCG

01:24.820 --> 01:29.820
AD family

01:29.820 --> 01:31.820
BE

01:31.820 --> 01:32.820
是吧

01:32.820 --> 01:34.820
math 一个后

01:34.820 --> 01:35.820
后续等于什么

01:35.820 --> 01:37.820
FGCD

01:37.820 --> 01:39.820
EBA

01:39.820 --> 01:50.820
F,G,C,D,E,B,A

01:51.820 --> 01:53.820
这是终续和后续

01:55.820 --> 01:57.820
我们还是来写一个方法

01:57.820 --> 01:59.820
然后根据一个终续

01:59.820 --> 02:01.820
再给我传出一个后续

02:01.820 --> 02:04.820
然后我就能还原的了一咖啥数

02:05.820 --> 02:06.820
还是先做一个判断是吧

02:06.820 --> 02:07.820
严谨性判断

02:07.820 --> 02:10.820
中等于空

02:10.820 --> 02:13.820
或者是后等于空

02:13.820 --> 02:18.820
或者是中的lans等于零

02:18.820 --> 02:22.820
或者是后的lans等于零

02:22.820 --> 02:26.820
或者是中的lans

02:26.820 --> 02:33.540
不等于后的lans

02:33.540 --> 02:36.540
我们就return

02:37.540 --> 02:40.540
否则的话,我们就开始搞事情了

02:40.540 --> 02:42.540
先弄一个根几点

02:42.540 --> 02:45.540
然后我写一个note

02:45.540 --> 02:47.540
传出一个value

02:47.540 --> 02:50.540
this value等于

02:50.540 --> 02:54.540
然后this life等于空

02:54.540 --> 02:57.540
然后this right等于空

03:00.540 --> 03:01.540
大概是这样

03:01.540 --> 03:03.540
然后我们来看一下

03:03.540 --> 03:05.540
如何来把这个东西给它搞出来

03:05.540 --> 03:07.540
首先我们先找个根几点

03:07.540 --> 03:09.540
对于后续变例来说谁是根几点

03:09.540 --> 03:11.540
对于后续变例来说谁是根几点

03:11.540 --> 03:13.540
我们让一个入企

03:13.540 --> 03:15.540
用一个note

03:15.540 --> 03:17.540
传谁呢

03:17.540 --> 03:19.540
是不是后续变例的最后一个

03:19.540 --> 03:24.780
这个或是根几点

03:24.780 --> 03:26.780
后续变例的最后一个点是根几点

03:26.780 --> 03:32.780
有了后续变例的根几点了之后我想怎么办

03:32.780 --> 03:35.780
我从终续变例里面

03:35.780 --> 03:37.780
找到一个根几点在哪

03:37.780 --> 03:39.780
是吧

03:39.780 --> 03:43.780
中的index of root的位

03:43.780 --> 03:45.780
找到一个位置是吧

03:45.780 --> 03:47.780
然后我怎么办

03:47.780 --> 03:49.780
找出

03:49.780 --> 03:51.780
左子数的终续和左子数的后续

03:51.780 --> 03:53.780
以及右子数的终续

03:53.780 --> 03:55.780
以及右子数的后续是吧

03:55.780 --> 04:00.780
问一个life的终

04:02.780 --> 04:03.780
等于什么

04:03.780 --> 04:05.780
左子数的终续

04:05.780 --> 04:07.780
从零到哪

04:07.780 --> 04:09.780
是不是

04:09.780 --> 04:11.780
中的slice

04:11.780 --> 04:15.780
零到index

04:15.780 --> 04:16.780
对吧

04:16.780 --> 04:18.780
问一个right

04:18.780 --> 04:20.780
等于哪

04:20.780 --> 04:22.780
中的slice

04:22.780 --> 04:26.470
index

04:26.470 --> 04:27.470
加1

04:27.470 --> 04:28.470
到哪

04:28.470 --> 04:30.470
到中的最后是吧

04:30.470 --> 04:32.470
中的lence

04:32.470 --> 04:35.470
然后能找到左子数的后续

04:36.470 --> 04:39.470
等于厚的slice

04:39.470 --> 04:41.470
后续

04:41.470 --> 04:43.470
也是从零到index

04:43.470 --> 04:47.470
从零到index

04:47.470 --> 04:51.470
问一个right的后续

04:51.470 --> 04:53.470
右子数的后续

04:53.470 --> 04:55.470
是从index加1到哪

04:55.470 --> 04:57.470
没有最后一个

04:57.470 --> 04:58.470
是吧

04:58.470 --> 05:00.470
是从index不加1了

05:00.470 --> 05:01.470
index是吧

05:01.470 --> 05:04.470
后续的slice

05:04.470 --> 05:05.470
从哪呢

05:05.470 --> 05:07.470
从dindex

05:07.470 --> 05:10.470
到后续的lence

05:10.470 --> 05:12.470
因为最后一个是跟进点

05:12.470 --> 05:13.470
最后一个不算

05:13.470 --> 05:14.470
所以他得加1

05:14.470 --> 05:18.910
这个在旅下逻辑是吧

05:18.910 --> 05:20.910
左子数的后续

05:20.910 --> 05:21.910
这么长是吧

05:21.910 --> 05:22.910
index在哪

05:22.910 --> 05:24.910
它就有多长是吧

05:24.910 --> 05:26.910
然后

05:26.910 --> 05:28.910
因为他们的这个

05:28.910 --> 05:30.910
后续和中续的左子数的

05:30.910 --> 05:32.910
顺序是一样的

05:32.910 --> 05:34.910
左子数的位置是一样的

05:34.910 --> 05:36.910
就是这些

05:36.910 --> 05:37.910
然后呢

05:37.910 --> 05:39.910
中续的右边是右子数

05:39.910 --> 05:40.910
然后呢

05:40.910 --> 05:41.910
除去左子数这些

05:41.910 --> 05:43.910
到处第二个是右子数

05:43.910 --> 05:46.220
然后呢

05:46.220 --> 05:47.220
我们可以让

05:47.220 --> 05:50.220
root的left

05:50.220 --> 05:51.220
等于谁呢

05:51.220 --> 05:53.220
等于ve

05:53.220 --> 05:57.220
left的中

05:57.220 --> 06:00.220
然后left的后

06:00.220 --> 06:02.220
root的right

06:02.220 --> 06:04.220
等于ve

06:04.220 --> 06:07.220
right的中

06:07.220 --> 06:10.220
和right的后

06:10.220 --> 06:12.220
这就搞定了

06:12.220 --> 06:13.220
对吧

06:13.220 --> 06:15.220
这就搞定了

06:15.220 --> 06:18.220
那我们来试一下

06:18.220 --> 06:20.220
ve

06:20.220 --> 06:22.220
中

06:22.220 --> 06:23.220
后

06:23.220 --> 06:24.220
我们要

06:24.220 --> 06:25.220
最后的return right

06:25.220 --> 06:26.220
root是吧

06:26.220 --> 06:28.220
return这个root

06:28.220 --> 06:30.220
然后问一个root等于

06:30.220 --> 06:33.220
打印一下root

06:33.220 --> 06:35.220
left

06:35.220 --> 06:37.220
以及root

06:37.220 --> 06:39.220
right

06:39.220 --> 06:42.600
走

06:42.600 --> 06:44.600
root的left是C

06:44.600 --> 06:46.600
对吧

06:46.600 --> 06:48.600
C的left是

06:48.600 --> 06:49.600
F

06:49.600 --> 06:50.600
对吧

06:50.600 --> 06:52.600
C的right是G

06:52.600 --> 06:53.600
对吧

06:53.600 --> 06:55.600
root的right是B

06:55.600 --> 06:56.600
对吧

06:56.600 --> 06:58.600
B的left是D

06:58.600 --> 07:00.600
B的right是E

07:00.600 --> 07:01.600
是吧

07:01.600 --> 07:02.600
B的right是E

07:02.600 --> 07:03.600
是吧

07:03.600 --> 07:06.600
这就是根据中序和后序

07:06.600 --> 07:08.600
还原一颗二叉树是吧

07:08.600 --> 07:10.600
看似比较复杂

07:10.600 --> 07:11.600
但是实际上

07:11.600 --> 07:12.600
我们用上地规的时候

07:12.600 --> 07:14.600
实际上很简单

07:14.600 --> 07:15.600
难在地规

07:15.600 --> 07:16.600
所以说

07:16.600 --> 07:17.600
地规的思维

07:17.600 --> 07:18.600
大家必须要提早养成

07:18.600 --> 07:20.600
后面还有很多的地方

07:20.600 --> 07:22.600
都会用到地规

07:22.600 --> 07:25.600
这是一个前序中序

07:25.600 --> 07:26.600
和后序中序

07:26.600 --> 07:28.600
还原二叉树的问题

07:28.600 --> 07:30.600
OK了吧

07:30.600 --> 07:31.600
那后面的课程

07:31.600 --> 07:32.600
我们会继续往下讲

07:32.600 --> 07:34.600
比如说还有一些搜索

07:34.600 --> 07:36.600
还有一些杀出的比较

07:36.600 --> 07:37.600
这些问题

07:37.600 --> 07:38.600
我们之后来讲

