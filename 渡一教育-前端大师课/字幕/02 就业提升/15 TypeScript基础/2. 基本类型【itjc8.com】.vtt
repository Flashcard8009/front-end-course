WEBVTT

00:00.690 --> 00:06.830
ok 接下来呢 我们就来看一下啊 在我们之前做内形冤属的时候

00:07.350 --> 00:08.370
这个位置

00:08.890 --> 00:10.410
可以写哪些内形

00:10.930 --> 00:14.770
当然这里的东西呢 可以写很丰富啊 写的东西可以很多

00:15.030 --> 00:20.910
我们呢 先来学习一些基本的内形书写方式 先来学习基本内形

00:21.930 --> 00:23.210
基本内形呢 就是说

00:23.470 --> 00:29.110
在GS代码中支持的内形 就是我们以前写的GS 里边它支持哪些内形呢

00:30.070 --> 00:37.310
N 数字注意 N 小写 千万不要写成大写了啊 先大写变成另外一个意思的 我们后边

00:37.570 --> 00:42.930
讲了内之后呢 再详细讲大写表示什么意思 这里要用小写啊 表示它的内形名字

00:43.190 --> 00:47.030
N 表示约束为一个数字 这没什么好说的 数字

00:47.790 --> 00:53.430
然后呢 实际注意S小写啊 第一个S小写 约束为一个字母串 很简单

00:53.890 --> 00:59.010
还有什么呢 布尔布丽 表示约束为一个布尔子

00:59.770 --> 01:06.690
布尔子真或者是假 布尔子还没练过 对吧 我们来看一下吧 看一下 比方说我们来写这么一个函数

01:07.970 --> 01:08.490
Is odd

01:09.510 --> 01:16.930
是不是一个基数啊 这个函数 这个某一个数字是不是一个基数啊 我们写这个N 判断N是不是

01:16.930 --> 01:23.090
基数 你看 写出来了过后 三个点出现了 对吧 三个点出现了 他不知道这个N是什么内形

01:23.530 --> 01:30.450
约束一下 我们内形呢 囊本啊 判断一下N是不是基数 那判断的结果是不是一定是布尔

01:30.850 --> 01:35.250
对不对 真或者是假 是或者是不是 ok 我们把约束一下啊 不立

01:36.090 --> 01:39.610
返回的结果一定是布尔 你看马上爆错了 他为什么会爆错

01:41.010 --> 01:44.450
你想一想 像这些问题啊 我们平时也单码的时候都没有特别留意的

01:45.010 --> 01:48.810
你说好了 这个函数要返回一个布尔 结果你返回了吗

01:49.390 --> 01:53.870
你返回了吗 你没有返回任何东西 那凭什么他不爆错了 所以他一定会爆错

01:54.430 --> 01:57.750
你这里说好了 返回布尔 那一定要返回一个布尔 这就是

01:58.750 --> 02:02.270
在约束下面 我们代码就一定不容易乱 很难

02:03.230 --> 02:06.790
输写一些混乱的代码 就减上了我们输写代码的隐患

02:07.470 --> 02:11.710
好 我们这里判断一下 如果N除以二的余数等于年

02:12.470 --> 02:16.310
就表示是基数 是偶数 对吧 是偶数 返回啥

02:17.290 --> 02:19.530
返回force 返回force

02:20.130 --> 02:24.730
然后ok 那么其他情况 返回处 你看现在不会爆错了 就不会爆错了

02:25.530 --> 02:27.690
ok 那么我们还可以用这种方式来返回

02:28.290 --> 02:32.050
return n除以二的余数是不是等于年 还可以用这种方式

02:33.210 --> 02:40.370
这就是布尔的用处 有些时候是需要参数啊 或者是变量啊 要把他约束的布尔就可以用这种方式

02:41.050 --> 02:44.250
当然你这里可不可以不约束 可不可以不约束 想一想

02:45.230 --> 02:50.190
可不可以不约束 可以啊 你不约束的话 你指着他看一下 返回点

02:50.830 --> 02:55.750
推倒出来还是个布尔 为什么他能推倒出来 因为他知道这个N是一个数字

02:56.310 --> 03:01.590
数字跟数字相处 跟另外一个数字不是相处 求余 跟另外一个数字进行比较

03:02.190 --> 03:05.710
比较的结果一定是个布尔 所以他能推倒出来 这里返回的是布尔

03:06.990 --> 03:10.150
这是布尔 还有什么类型呢 还有

03:11.130 --> 03:13.650
数组 数组

03:15.490 --> 03:22.490
数组 数组类型该怎么来约束呢 在ts里边约束数组类型 这里我要特别说一下

03:23.330 --> 03:25.130
比方说我这里有一个数组

03:26.010 --> 03:31.010
就是Numbers嘛 这里面有很多数字 你看他现在三个点 表示没有对他进行类型约束

03:31.890 --> 03:38.210
好 我现在约束一下 约束他为一个数字的数组 看一下该怎么写

03:38.950 --> 03:45.270
你不能去用这种写法 这种写法不爆错 我们之后会讲这种写法表示什么意思 这种写法不行的啊

03:46.230 --> 03:48.550
这种写法不会爆错 我们后边会讲他什么意思

03:50.230 --> 03:56.470
你要约束他为一个数组的时候 必须要指定数组的每一项是怎么类型

03:56.990 --> 04:04.230
他就西化到这种程度 你是一个数组 那么你定义了一个数字的数组 你肯定知道他的每一项是一个数字

04:04.650 --> 04:07.170
于是呢 在两个中框号前边写上一个Number

04:08.090 --> 04:12.530
明白这个意思吗 表示这是一个Number类型的数组 一个数字类型的数组

04:12.930 --> 04:19.370
数组的每一项要装数字 我们再接下来再看一下 当我给他复制的时候 给他复制的时候

04:19.970 --> 04:22.410
复制为这种值行不行 不想

04:23.410 --> 04:28.850
数字不想必须是一个数组 并且数组里面是制服串行不行 不行

04:29.590 --> 04:37.790
他告诉你 制服串无法把制服串分配给Number类型 因为他知道每一项是一个数字 每一项是数字那就没问题了

04:38.630 --> 04:42.950
当然你可以在这里完成复制 也可以写到哪了 也可以写到这啊

04:43.590 --> 04:46.950
去到这一样的 没什么区别 先约束 约束再复制

04:47.910 --> 04:53.390
当然了 你也可以利用类型推到 你把这个三了 他能不能推到出来 我们看一下啊

04:54.270 --> 04:56.990
指着他推到出来了 这个Number数组

04:57.690 --> 04:58.370
因此其实

04:59.450 --> 05:05.690
我们学到TS 很多时候写单码都感觉不到它的存在 但是莫名其妙 我们单码的质量就变得很高了

05:06.450 --> 05:09.250
不容易出错了 因为很多时候他可以进行类型推导的

05:10.370 --> 05:13.450
好 这是数组的这种约束方式 还有一种约束方式

05:14.890 --> 05:22.810
数组 达到同样的效果 我们是用这种写法而畏啊 使用数组的构造函数而畏 加个间扩号

05:23.230 --> 05:26.190
间扩号里边写上数组每一项的类型

05:27.070 --> 05:29.950
是一模一样的效果啊 一模一样的效果

05:30.870 --> 05:34.550
都可以表示 这是一个Number的型号数组 没有任何问题的

05:35.270 --> 05:40.470
ok 你看 其实这个东西实际上是啥 这个东西实际上是一个愚法堂 是一个愚法堂

05:41.030 --> 05:46.030
实际上呢 他真实的完整写法应该是这样子 刚才这个是个愚法堂而已

05:46.850 --> 05:50.690
呃 这就是对数组的约束啊 扬种写法都可以 看你自己喜欢哪一种

05:51.570 --> 05:58.810
我个人的话 比较的推荐使用这一种 为什么呢 因为下面这种写法呢

05:59.330 --> 06:05.690
在react里边 你看这个间扩号 是不是代表的一个元素啊 不是元素 应该是一个组件 对吧

06:05.970 --> 06:09.530
代表的是一个组件 所以说可能会跟那个代码的愚法造成冲突

06:10.050 --> 06:15.490
因此呢 我建议呢 使用这种方式 把这种方式 啊 总之数组有两种约束方式

06:16.450 --> 06:19.890
这是关于数组 关于数组 还有呢

06:20.890 --> 06:25.850
什么呢 关于object 啊 表示约束为一个对象

06:27.170 --> 06:34.570
约束为一个对象 嗯 这种约束呢 不是很常见啊 不是很常见 但是有的时候呢 会用到

06:35.250 --> 06:39.090
不举个例子吧 比方说这里呢 有一个用户对象啊 呦

06:39.890 --> 06:43.890
他是一个用户对象 用户对象的时候呢 我把约束一下约束的object

06:44.870 --> 06:51.710
呃 后边我给他复制的时候呢 复制为一个制服创意行不行 不行 复制为一个数字 不行 出合force

06:52.190 --> 06:57.590
不想必须是一个对象 哎 这个可以了 只要你是对象就行啊 只要你是对象就行

06:57.990 --> 07:04.110
这个对象里面有哪些属性的 随便你啊 随便你 有name属性 有埃及属性 随便你啊 只要你是一个对象就行

07:05.030 --> 07:07.750
因此呢 这个约束实际上他不够精准

07:08.350 --> 07:12.030
他不能约束到这个对象里面有哪些东西 他不能做这些约束

07:12.530 --> 07:18.930
呃 所以说他用的呢 是确实不太多啊 但是他有没有约束力呢 肯定有约束力 像刚才制服创 数字

07:19.330 --> 07:24.930
布尔就不行了 对吧 他是有约束力的 但是呢 他约束力没有那么强 因此呢

07:25.530 --> 07:32.130
用的不是很多 但有的时候会用的 比方说我举个例子啊 我写这么一个函数 这个函数呢

07:33.170 --> 07:36.450
我这写这么行吧 print values

07:37.430 --> 07:46.550
啊 传入一个对象进来 我要打印这个对象里边所有的属性值啊 我要打印这个对象里边所有的属性值

07:47.190 --> 07:49.350
啊 我知道对象里面有属性名吗 属性值

07:50.070 --> 07:55.190
好 那么这个时候呢 我你不能够传一个布尔进来 对不对 你不能够传个制服创而进来 我怎么弄呢

07:55.710 --> 08:01.550
所以说这里呢 我也不知道你要给我传什么对象 所以说这里可以简单的约束一下 你只要是个对象就行了

08:02.010 --> 08:07.250
只要是个对象就行了 ok 那么我们就可以使用 object 啊 object 第二

08:08.010 --> 08:10.250
Values 你看在TS里边

08:11.250 --> 08:16.210
绝大部分时候啊 99%的时候都有完善的智能提示

08:16.690 --> 08:20.130
我们没写个东西的时候 他里面有哪些东西都能完整的提示出来

08:20.570 --> 08:26.490
他怎么能够提示出来的 就是因为他有类型系统啊 他知道每一个东西是什么类型

08:26.770 --> 08:30.610
知道这个东西是个知不错 知道另外一个东西是个数字 那么他就能推到出来

08:31.070 --> 08:35.510
知不错有哪些属性 有哪些函数 数字有哪些属性 哪些函数 他就能推到出来

08:36.230 --> 08:41.310
以前在接试里面有智能提示吗 很少很少吧 而且有的话你都不敢相信他对吧

08:42.110 --> 08:45.870
ok 我们得到这个对象的所有的属性值 你看一下

08:46.670 --> 08:52.190
这个函数返回的是啥 返回的是一个数组啊 是个N类型的数组

08:52.510 --> 08:58.870
N类型我们之前说过 对吧 是一个任何类型 他又不清楚这个每个属性只是什么类型 他不清楚了

08:59.330 --> 09:03.690
他这个地方没法推到出来 太难问他了 因为他是在运行过程中才能确定的

09:04.530 --> 09:06.850
好 这里呢 我们得到得到个结果吧

09:08.570 --> 09:13.770
vowels 你看我们写了多少类型系统呢 没有 就这个地方约束了一下

09:14.530 --> 09:16.890
好 我们就知道了 这个东西至少他是一个数组

09:17.770 --> 09:20.170
N类型的数组 数组的每一项 随便啊

09:20.850 --> 09:24.170
ok 我们看一下这个数组里面 你看 数组的所有函数都出现了

09:24.970 --> 09:28.210
所有的函数都出现了 为什么他知道 因为他知道这是个数组

09:28.830 --> 09:33.150
在GS里面 他是很难推到出来的 但TS里面 他有完整的类型系统

09:33.790 --> 09:35.870
他可以推到出来 我们可以使用for一起

09:36.670 --> 09:41.910
而且你这个地方还不能乱写啊 比方说写成这样for一起 他马上就爆错了 他告诉你没有这个函数

09:42.390 --> 09:47.510
他不知道有这个函数 但他知道数组里边呢 有for一起这个函数 他知道的

09:48.230 --> 09:51.190
好 for一起这个函数里边呢 有回调 你看回调里边

09:52.230 --> 09:57.030
回调 这是个回调函数 回调里边有几个函数呢 他告诉你可以写三个函数

09:57.410 --> 10:01.250
第一个函数是数组每一项的值vennination

10:02.010 --> 10:08.610
这个函数呢 是数组的索引啊 就是每一项 当前的一项的索引是一个number类型 他每一项都能推到出来

10:09.330 --> 10:13.050
而这里呢 而瑞就是整个这个数组是n立的数组

10:13.970 --> 10:18.330
好 我们来看一下啊 这里我们把这个属性值输出就行了啊

10:19.050 --> 10:20.130
console log

10:21.410 --> 10:23.170
就完事了啊 就写了这么一个函数

10:23.670 --> 10:27.270
print values 我们随便给一个对象吧 随便给个对象

10:28.950 --> 10:29.910
Age 随便给

10:30.870 --> 10:34.310
好 我们来看一下啊 运行运不运行的物数为了其实

10:35.590 --> 10:36.470
npm 以往

10:39.190 --> 10:40.390
啊 等他运行出来啊

10:41.270 --> 10:47.750
啊 运行出来了啊 就把两个属性值运行出来了 像这种情况呢 就是说你写一个函数的时候啊

10:48.110 --> 10:52.550
写个函数的时候 有的时候函数这个对象 你也不知道他是什么对象 那么你可以使用

10:53.190 --> 10:56.150
来约束啊 这个约束呢 比较的少见

10:57.790 --> 10:58.430
好 下一个

10:59.710 --> 11:00.550
下一个是low

11:01.590 --> 11:02.990
和undefend

11:03.910 --> 11:07.150
undefend 这两个类型 我要好好说一下 关于这两个类型

11:07.750 --> 11:08.630
low undefend

11:09.630 --> 11:14.550
这两个类型呢 世界是里面的类型啊 都表示空啊 都表示空

11:15.550 --> 11:19.590
他们呢 这两个类型的特点就是low和undefend

11:20.410 --> 11:24.370
是所有其他类型的纸类型

11:24.930 --> 11:26.450
啊 换句话说什么意思呢

11:27.050 --> 11:31.210
他们可以复制给其他类型的

11:32.210 --> 11:35.730
可以复制给其他类型 比方变量 比方说吧

11:36.290 --> 11:36.890
这里

11:38.250 --> 11:39.250
比方说这里

11:39.690 --> 11:40.570
有一个变量

11:41.810 --> 11:43.970
就n嘛 我们随便写一个

11:44.770 --> 11:45.890
他是一个制服串

11:46.330 --> 11:47.970
但是呢 我给他复制为low行不行

11:47.990 --> 11:49.070
给他复制为low行不行

11:49.430 --> 11:50.590
你看 没有问题的

11:50.990 --> 11:51.750
是没有问题的

11:52.030 --> 11:53.390
给他复制为undefend行不行

11:54.110 --> 11:55.430
undefend 没有问题

11:56.030 --> 11:57.630
他是一个number 一个数字

11:57.990 --> 12:00.150
可以给他复制为undefend 也没有任何问题

12:00.990 --> 12:03.990
所以说这两个类型呢 他比较特殊 他可以复制给其他类型

12:04.590 --> 12:05.590
但是你想一想

12:05.910 --> 12:07.750
这样 如果允许这样复制的话

12:08.110 --> 12:09.430
隐患是不是又发生了

12:09.990 --> 12:10.950
又产生隐患了

12:11.310 --> 12:12.350
又发生隐患了

12:12.670 --> 12:14.790
因为后边我在使用这个n的时候呢

12:15.110 --> 12:17.310
我要调了他的制服串的函数 比方说to

12:18.290 --> 12:19.330
你觉得要不要报处

12:20.090 --> 12:21.170
那肯定报处了嘛

12:21.410 --> 12:22.370
他的只是undefend

12:22.890 --> 12:25.450
你跟他说是制服串类型 结果他的只是undefend

12:25.970 --> 12:28.410
所以说这种情况呢 我们通常

12:28.690 --> 12:29.810
是不希望发生的

12:30.570 --> 12:31.850
不希望发生这种情况

12:32.370 --> 12:35.170
我们就是需要用ts来避免这些问题

12:35.450 --> 12:38.010
你说他制服串 他一定100%一定是制服串

12:38.250 --> 12:39.530
就不能是其他类型

12:40.050 --> 12:41.010
那怎么办呢

12:41.250 --> 12:43.130
我们可以在配置文件里边

12:43.370 --> 12:45.170
就是边意配置的时候

12:45.410 --> 12:47.210
给他配置的更加严格一点

12:47.770 --> 12:48.850
加上这么一个配置

12:49.570 --> 12:50.650
叫做strict

12:51.250 --> 12:53.330
表示也更加严格的

12:53.650 --> 12:55.050
now checks

12:55.610 --> 12:58.010
更加严格的空内型检查

12:58.690 --> 13:00.170
这样子加上之后

13:00.410 --> 13:02.370
你的now和undefend

13:02.610 --> 13:04.330
就不能复制给其他类型了

13:05.370 --> 13:06.970
所以说我们加上这个

13:09.290 --> 13:11.450
通过添加

13:12.010 --> 13:12.690
这个玩意儿

13:13.130 --> 13:14.650
把它设为去

13:14.930 --> 13:15.930
通过添加这个东西

13:16.130 --> 13:16.930
把它设为去

13:18.290 --> 13:21.730
可以获得更严格的

13:22.370 --> 13:23.650
空内型检查

13:25.530 --> 13:26.490
从此以后

13:26.730 --> 13:29.130
now和undefend

13:29.890 --> 13:33.050
只能复制给自身

13:33.090 --> 13:34.410
不能复制给其他类型了

13:34.690 --> 13:35.970
这才是我们需要的

13:36.370 --> 13:37.570
这才是我们需要的

13:38.250 --> 13:41.010
OK 这是关于now和undefend

13:41.570 --> 13:42.290
这两个类型

13:43.130 --> 13:44.010
那就差不多了

13:44.210 --> 13:44.850
基本的

13:44.950 --> 13:46.070
GS里面的基本类型

13:46.070 --> 13:47.230
有就这么一些了

13:48.430 --> 13:50.590
那么这些基本类型在TS里面

13:50.590 --> 13:51.350
都可以成为

13:51.870 --> 13:53.830
作为类型来进行约束

13:54.870 --> 13:56.910
好 这是关于它的基本类型

