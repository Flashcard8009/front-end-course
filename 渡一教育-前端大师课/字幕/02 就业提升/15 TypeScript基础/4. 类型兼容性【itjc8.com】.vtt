WEBVTT

00:00.880 --> 00:05.340
OK 这一部分就很重要了

00:05.340 --> 00:08.880
我们这一部分讲的是内形兼容性

00:08.880 --> 00:11.180
这一部分我们讲什么呢

00:11.180 --> 00:17.180
讲的是TS如何来判定两个内形是不是兼容

00:17.180 --> 00:20.880
怎么要兼容 只有两个内形兼容过后了

00:20.880 --> 00:24.380
这两个内形才能完成互相的复制

00:24.380 --> 00:28.880
比方说我们要把B复制给A

00:28.880 --> 00:31.880
在TS中它要对它进行内形检查

00:31.880 --> 00:35.880
如果能完成复制 如果能完成复制

00:35.880 --> 00:41.880
那么则认为B和A内形兼容

00:41.880 --> 00:42.880
就这么个意思

00:42.880 --> 00:47.880
它是如何来判断到底他们两个内形是不是兼容的

00:47.880 --> 00:49.880
可能有些同学就在想

00:49.880 --> 00:52.880
两个内形兼容不很好说吗

00:52.880 --> 00:54.880
两个内形必须完全一样不就兼容了吗

00:54.880 --> 00:56.880
其实不是的 不是这样子

00:56.880 --> 00:57.880
没有那么简单

00:57.880 --> 01:00.880
因为TS考虑的问题很多

01:00.880 --> 01:01.880
它考虑的很深

01:01.880 --> 01:04.880
它要根据我们平时开发GS的习惯

01:04.880 --> 01:07.880
按照我们开发GS的习惯来进行判定

01:07.880 --> 01:09.880
因此我们通过这一个小节的学习

01:09.880 --> 01:10.880
你可以体会到

01:10.880 --> 01:15.880
真的TS这个语言设计的真的是用心良苦

01:15.880 --> 01:16.880
它真的想了很多很多

01:16.880 --> 01:18.880
它不能给我们平时开发

01:18.880 --> 01:19.880
代码的造成差异很大

01:19.880 --> 01:21.880
有的时候在GS里面

01:21.880 --> 01:23.880
可以有很多很方便的写法

01:23.880 --> 01:25.880
它要把这些东西保留下来

01:25.880 --> 01:26.880
所以说

01:26.880 --> 01:28.880
它在判断内形兼容性的时候

01:28.880 --> 01:30.880
做了很多很多的考虑

01:30.880 --> 01:31.880
我们这一块

01:32.880 --> 01:34.880
带着一种欣赏的态度

01:34.880 --> 01:37.880
来看待一下TS是怎么去考虑这些问题的

01:39.880 --> 01:41.880
它如何来判断内形兼容性的

01:41.880 --> 01:42.880
它有一个总的原则

01:42.880 --> 01:45.880
叫做压制变形法

01:46.880 --> 01:48.880
变是分变的变

01:51.880 --> 01:53.880
变形是内形的形

01:54.880 --> 01:55.880
压制变形法

01:55.880 --> 01:56.880
也叫做

01:56.880 --> 01:58.880
指结构

01:59.880 --> 02:00.880
变形法

02:01.880 --> 02:03.880
什么意思我解释一下

02:03.880 --> 02:04.880
这个压制变形法

02:04.880 --> 02:06.880
和指结构变形法是一个意思

02:06.880 --> 02:07.880
什么意思呢

02:07.880 --> 02:09.880
就是说有的时候

02:09.880 --> 02:12.880
我要关心你到底是不是一只压制呢

02:12.880 --> 02:14.880
其实我关心的并不是

02:14.880 --> 02:17.880
你到底是一个什么东西

02:17.880 --> 02:19.880
我关心的你是不是压制

02:19.880 --> 02:20.880
只需要关心

02:20.880 --> 02:22.880
你是不是具有压制的特征

02:23.880 --> 02:25.880
比如说我们这个程序中

02:25.880 --> 02:26.880
我们认为什么东西是压制

02:26.880 --> 02:28.880
你只要会嘎嘎叫

02:28.880 --> 02:29.880
然后你会游泳

02:29.880 --> 02:31.880
你只要具有这两个特征

02:31.880 --> 02:33.880
我就认为你是一只压制

02:33.880 --> 02:34.880
比如说我

02:35.880 --> 02:37.880
我会嘎嘎叫嘎嘎

02:37.880 --> 02:39.880
然后我也会游泳

02:39.880 --> 02:40.880
其实我也不会游泳

02:40.880 --> 02:42.880
那就假设我会游泳

02:42.880 --> 02:44.880
在这种情况下

02:44.880 --> 02:46.880
就可以把我看成一只压制

02:46.880 --> 02:48.880
什么叫指结构变形法

02:48.880 --> 02:49.880
那你想一想

02:49.880 --> 02:50.880
我作为一个人

02:50.880 --> 02:51.880
我又没有其他属性

02:51.880 --> 02:52.880
有没有其他成员

02:52.880 --> 02:53.880
我有年龄

02:53.880 --> 02:54.880
有性别

02:54.880 --> 02:55.880
有身高

02:55.880 --> 02:56.880
有体重

02:56.880 --> 02:57.880
我有一些其他的成员

02:57.880 --> 02:58.880
我还有一些其他的

02:58.880 --> 02:59.880
函数方法

02:59.880 --> 03:01.880
比方说我可以上课

03:01.880 --> 03:02.880
等等等等

03:02.880 --> 03:03.880
因此我作为一个人

03:03.880 --> 03:05.880
有很多很多的成员

03:05.880 --> 03:08.880
但是我其中有两个成员

03:08.880 --> 03:10.880
一个是我会嘎嘎叫

03:10.880 --> 03:11.880
一个是我会游泳

03:11.880 --> 03:12.880
那就够了

03:12.880 --> 03:13.880
我其他成员不看了

03:13.880 --> 03:14.880
这两个成员

03:14.880 --> 03:16.880
是我的指结构

03:16.880 --> 03:17.880
对不对

03:17.880 --> 03:18.880
是我的指结构

03:18.880 --> 03:21.880
它只要从我们的整个结构中

03:21.880 --> 03:23.880
找到这两个特征就够了

03:23.880 --> 03:25.880
这就是指结构变形法

03:25.880 --> 03:27.880
是一样的意思

03:27.880 --> 03:29.880
说到鸭子

03:29.880 --> 03:32.880
我旁边有一只鸭子

03:32.880 --> 03:33.880
大家看不见

03:33.880 --> 03:36.880
给大家听一下它的声音

03:36.880 --> 03:37.880
这是鸭子

03:37.880 --> 03:38.880
为什么有这只鸭子

03:38.880 --> 03:40.880
因为我路播课的时候

03:40.880 --> 03:42.880
整个房间里面就有一个活人

03:42.880 --> 03:44.880
我实在找不到对谁说话了

03:44.880 --> 03:45.880
我就摆一只鸭子

03:45.880 --> 03:47.880
我对它讲客

03:47.880 --> 03:48.880
鸭子变形法

03:48.880 --> 03:50.880
指结构变形法就是这么一个意思

03:50.880 --> 03:51.880
就是这么个意思

03:51.880 --> 03:54.880
就是说我只要满足某些特征就行了

03:54.880 --> 03:57.880
我们把它解释一下

03:57.880 --> 03:59.880
目标类型

03:59.880 --> 04:00.880
什么叫目标类型

04:00.880 --> 04:01.880
就是我要负责的目标

04:01.880 --> 04:02.880
把B负责给A

04:02.880 --> 04:05.880
A就是目标类型

04:05.880 --> 04:08.880
需要某一些特征

04:08.880 --> 04:09.880
比方说一个用户

04:09.880 --> 04:11.880
它需要有新名新别年龄

04:11.880 --> 04:13.880
这些一些特征

04:13.880 --> 04:15.880
而负责的类型

04:15.880 --> 04:18.880
只要能满足

04:18.880 --> 04:21.880
该特征

04:21.880 --> 04:23.880
该特征即可

04:23.880 --> 04:25.880
只要你满足个特征即可

04:25.880 --> 04:27.880
而不需要考虑你有其他东西

04:27.880 --> 04:29.880
有没有其他东西

04:29.880 --> 04:31.880
这就是鸭子变形法

04:31.880 --> 04:33.880
那么具体来说

04:33.880 --> 04:34.880
到了代码里边

04:34.880 --> 04:36.880
具体的不同的场景下面

04:36.880 --> 04:37.880
是怎么样的呢

04:37.880 --> 04:39.880
它其实多少少

04:39.880 --> 04:41.880
还有一些细节需要去讨论

04:41.880 --> 04:43.880
其实TS

04:43.880 --> 04:45.880
它希望的是

04:45.880 --> 04:48.880
让开发者完全感觉不到

04:48.880 --> 04:50.880
感觉不到它的类型

04:50.880 --> 04:52.880
那么复杂的类型兼容性判定

04:52.880 --> 04:54.880
需要希望让你感觉不到

04:54.880 --> 04:55.880
因为一切代码

04:55.880 --> 04:57.880
都是自然而然写出来的

04:57.880 --> 04:59.880
你觉得这个代码是正确的

04:59.880 --> 05:00.880
它就真的是正确的

05:00.880 --> 05:01.880
如果一个代码有问题

05:01.880 --> 05:03.880
它就真的是有问题

05:03.880 --> 05:05.880
它不会来困扰你

05:05.880 --> 05:07.880
所以说在TS里边

05:07.880 --> 05:09.880
类型兼容性的判定

05:09.880 --> 05:11.880
它是非常非常自然的

05:11.880 --> 05:13.880
我觉得我看到这一块的时候

05:13.880 --> 05:15.880
当时我觉得它真的是生死属于

05:15.880 --> 05:16.880
我们来看一下

05:16.880 --> 05:18.880
一个是基本类型

05:18.880 --> 05:19.880
基本类型

05:19.880 --> 05:21.880
对基本类型的判定

05:21.880 --> 05:22.880
这一块呢

05:22.880 --> 05:24.880
它用的是这种方式

05:24.880 --> 05:25.880
就是完全匹配

05:25.880 --> 05:27.880
它是这样的考虑的

05:27.880 --> 05:29.880
基本类型是啥

05:29.880 --> 05:31.880
基本类型差异是非常非常大的

05:31.880 --> 05:33.880
一向是制服串

05:33.880 --> 05:34.880
还有数字

05:34.880 --> 05:36.880
还有布尔

05:36.880 --> 05:37.880
还有数组

05:37.880 --> 05:39.880
这个类型之间差异有多大

05:39.880 --> 05:40.880
而且非常非常大

05:40.880 --> 05:42.880
那你必须要完全匹配

05:42.880 --> 05:43.880
你不能搞搞出一个

05:43.880 --> 05:45.880
既是制服出来又是数字的玩意儿

05:45.880 --> 05:46.880
不能搞出这么玩意儿

05:46.880 --> 05:47.880
所以对基本类型而言

05:47.880 --> 05:49.880
它要求你完全匹配

05:49.880 --> 05:50.880
完全匹配

05:50.880 --> 05:52.880
这个没什么好说的

05:52.880 --> 05:54.880
第二个是对象

05:54.880 --> 05:55.880
它对象里面

05:55.880 --> 05:57.880
做了很多很多的考虑

05:57.880 --> 05:58.880
大家看一下

05:58.880 --> 05:59.880
对象

05:59.880 --> 06:00.880
那么这一块呢

06:00.880 --> 06:02.880
使用的就是压子变形法

06:02.880 --> 06:04.880
压子

06:04.880 --> 06:06.880
分辨

06:06.880 --> 06:08.880
变形法

06:08.880 --> 06:10.880
我们压子变形法

06:10.880 --> 06:12.880
主要是用在对象里面

06:12.880 --> 06:14.880
在对象里面

06:14.880 --> 06:15.880
它是怎么来考虑的呢

06:15.880 --> 06:16.880
它是用这种方式

06:16.880 --> 06:18.880
就是用压子变形法

06:18.880 --> 06:20.880
你只要满足特征就行

06:20.880 --> 06:22.880
你负责的东西只要满足特征就行

06:22.880 --> 06:23.880
来举个例子

06:23.880 --> 06:24.880
就比方说

06:24.880 --> 06:26.880
比方说我们有这么一个接口

06:26.880 --> 06:28.880
当然写那个

06:28.880 --> 06:30.880
内容别名也可以

06:30.880 --> 06:31.880
压子

06:31.880 --> 06:33.880
我们这个系统里面

06:33.880 --> 06:35.880
只要关心你是不是压子

06:35.880 --> 06:37.880
你只要有这两个特征

06:37.880 --> 06:39.880
sound

06:39.880 --> 06:41.880
你的声音

06:41.880 --> 06:43.880
声音必须是一个字面量

06:43.880 --> 06:44.880
嘎嘎嘎

06:44.880 --> 06:45.880
必须是这个东西

06:45.880 --> 06:46.880
声音

06:46.880 --> 06:47.880
然后呢

06:47.880 --> 06:48.880
你的

06:48.880 --> 06:50.880
有一个函数

06:50.880 --> 06:51.880
swing

06:51.880 --> 06:52.880
你必须要会游泳

06:52.880 --> 06:54.880
必须要是会游泳

06:55.880 --> 06:57.880
反过来就会游泳的

06:57.880 --> 06:59.880
这里不能用斗号

06:59.880 --> 07:00.880
好

07:00.880 --> 07:02.880
这就是

07:02.880 --> 07:03.880
一只压子

07:03.880 --> 07:04.880
它的接口

07:04.880 --> 07:05.880
好

07:05.880 --> 07:06.880
然后呢

07:06.880 --> 07:08.880
我们建立一个对象

07:08.880 --> 07:09.880
percent

07:09.880 --> 07:10.880
一个人

07:10.880 --> 07:12.880
这个人其实你还可以建个人的接口

07:12.880 --> 07:13.880
对吧

07:13.880 --> 07:14.880
为他约束一下

07:14.880 --> 07:15.880
这难得建立了

07:15.880 --> 07:16.880
人有啥

07:16.880 --> 07:17.880
人有姓名

07:17.880 --> 07:18.880
姓名叫做

07:18.880 --> 07:20.880
伪装成

07:20.880 --> 07:22.880
压子的人

07:22.880 --> 07:24.880
伪装成压子的人

07:24.880 --> 07:25.880
然后呢

07:25.880 --> 07:26.880
它有一个年龄

07:26.880 --> 07:27.880
还有姓别那些

07:27.880 --> 07:28.880
我就不难得写了

07:28.880 --> 07:29.880
年龄

07:29.880 --> 07:31.880
这个小孩

07:31.880 --> 07:33.880
sound

07:33.880 --> 07:34.880
好

07:34.880 --> 07:36.880
既然我要伪装成压子

07:36.880 --> 07:38.880
我就给他一个声音

07:38.880 --> 07:40.880
但是大家注意一下

07:40.880 --> 07:41.880
你这样写他代码的话

07:41.880 --> 07:42.880
一会儿是会出问题的

07:42.880 --> 07:44.880
因为他这样推断出来

07:44.880 --> 07:45.880
你看

07:45.880 --> 07:46.880
稍的

07:46.880 --> 07:47.880
这个推断出来

07:47.880 --> 07:49.880
这个我们使用的是内形推断

07:49.880 --> 07:51.880
内形推断

07:51.880 --> 07:52.880
它推断出来的话

07:52.880 --> 07:53.880
是一个制服串

07:53.880 --> 07:54.880
但是压子呢

07:54.880 --> 07:56.880
他要求是一个字面量

07:56.880 --> 07:57.880
是一个字面量

07:57.880 --> 07:58.880
而不是一个普通的制服串

07:58.880 --> 08:00.880
因为制服串的曲子很多

08:00.880 --> 08:02.880
他这里必须要求一个字面量

08:02.880 --> 08:03.880
那么怎么办呢

08:03.880 --> 08:04.880
我们希望在这里

08:04.880 --> 08:06.880
对他进行约束一下

08:06.880 --> 08:07.880
但是很遗憾

08:07.880 --> 08:08.880
遗憾的是

08:08.880 --> 08:10.880
这里我们已经在负责对象了

08:10.880 --> 08:12.880
已经在负责为一个对象了

08:12.880 --> 08:13.880
要约束

08:13.880 --> 08:15.880
应该在这个辩量位置进行约束

08:15.880 --> 08:17.880
应该在辩量位置进行约束

08:17.880 --> 08:19.880
而不应该在对象的书写里边

08:19.880 --> 08:20.880
在进行约束

08:20.880 --> 08:21.880
那这里怎么办呢

08:21.880 --> 08:23.880
这里我希望他能够判断出来

08:23.880 --> 08:25.880
他是一个字面量类型嘎嘎

08:25.880 --> 08:26.880
好

08:26.880 --> 08:27.880
这里教大家一种方式

08:27.880 --> 08:28.880
这种方式呢

08:28.880 --> 08:31.880
叫做内形断言

08:31.880 --> 08:32.880
内形断言

08:32.880 --> 08:33.880
就是有的时候呢

08:33.880 --> 08:35.880
他的内形推导也好

08:35.880 --> 08:36.880
还是怎么回事也好

08:36.880 --> 08:38.880
内形判断也好

08:38.880 --> 08:39.880
有的时候呢

08:39.880 --> 08:41.880
跟我们的想法有些差异

08:41.880 --> 08:42.880
有些差异

08:42.880 --> 08:44.880
而我们清楚的知道

08:44.880 --> 08:45.880
我们到底要干什么

08:45.880 --> 08:46.880
我们仔细思考

08:46.880 --> 08:48.880
觉得我们这样干是正确的

08:48.880 --> 08:49.880
那么这个时候呢

08:49.880 --> 08:50.880
可以使用内形断言

08:50.880 --> 08:51.880
比方说这里

08:51.880 --> 08:53.880
我真的是想让这个少的

08:53.880 --> 08:55.880
不要是一个制服串

08:55.880 --> 08:56.880
不要是一个制服串

08:56.880 --> 08:58.880
而他是一个字面量类型嘎嘎嘎

08:58.880 --> 08:59.880
你不要这样给我推断

08:59.880 --> 09:00.880
那么怎么办呢

09:00.880 --> 09:02.880
我就强行把这个东西

09:02.880 --> 09:03.880
把这个东西内形

09:03.880 --> 09:04.880
他推断出来

09:04.880 --> 09:06.880
这个东西的内形是一个字不串

09:06.880 --> 09:07.880
而不是字面量

09:07.880 --> 09:09.880
因为这里不是在进行内形约束

09:09.880 --> 09:11.880
这里是在复制

09:11.880 --> 09:12.880
不是在进行内形约束

09:12.880 --> 09:13.880
所以他推断出来

09:13.880 --> 09:15.880
是一个字不串

09:15.880 --> 09:16.880
而不是字面量

09:16.880 --> 09:18.880
那么但是我们心里面

09:18.880 --> 09:19.880
非常非常清楚

09:19.880 --> 09:20.880
我们真的希望

09:20.880 --> 09:22.880
把它当成一个字面量类型

09:22.880 --> 09:23.880
当成另外一个类型

09:23.880 --> 09:24.880
那么这个时候怎么办

09:24.880 --> 09:26.880
可以使用内形断言

09:26.880 --> 09:27.880
内形断言非常简单

09:27.880 --> 09:29.880
我只需要把

09:30.880 --> 09:32.880
我要断言的东西

09:32.880 --> 09:33.880
我要对它进行断言

09:33.880 --> 09:34.880
就断定

09:34.880 --> 09:35.880
断定它是什么东西

09:35.880 --> 09:36.880
我要对它进行断言

09:36.880 --> 09:38.880
只需要它后边写上一个关键字

09:38.880 --> 09:39.880
二次

09:39.880 --> 09:40.880
写上这么一个关键字

09:40.880 --> 09:42.880
后边写上内形就行了

09:42.880 --> 09:43.880
内形是啥

09:43.880 --> 09:44.880
内形就是字面量内形

09:44.880 --> 09:45.880
嘎嘎嘎

09:46.880 --> 09:47.880
这样你推断出来

09:47.880 --> 09:48.880
你看一下

09:48.880 --> 09:49.880
少的

09:49.880 --> 09:50.880
嘎嘎嘎

09:50.880 --> 09:51.880
推断出来这个内形

09:52.880 --> 09:53.880
当然不是推断出来的

09:53.880 --> 09:54.880
是我们断言出来的

09:54.880 --> 09:56.880
强行把这个内形改成嘎嘎嘎

09:56.880 --> 09:58.880
前面是我们

09:58.880 --> 09:59.880
这个写法感觉有点怪

09:59.880 --> 10:01.880
前边的是数据

10:01.880 --> 10:03.880
字文给它复制的数据

10:03.880 --> 10:04.880
这个数据

10:04.880 --> 10:05.880
它会被它推断出来

10:05.880 --> 10:06.880
是一个制服串

10:06.880 --> 10:07.880
所以说我们使用二次

10:07.880 --> 10:08.880
进行内形断言

10:09.880 --> 10:10.880
断言出来

10:10.880 --> 10:11.880
这后面写的是啥

10:11.880 --> 10:12.880
后面写的是内形

10:13.880 --> 10:14.880
后面写的是内形

10:14.880 --> 10:15.880
再给大家看一下

10:15.880 --> 10:16.880
看一下编译结果

10:19.880 --> 10:20.880
没得搞云了

10:22.880 --> 10:23.880
编译结果

10:23.880 --> 10:24.880
看一下编译结果里边

10:25.880 --> 10:26.880
它只有一个数据了

10:26.880 --> 10:27.880
这些东西都会消失的

10:27.880 --> 10:29.880
内形断言它也会消失的

10:29.880 --> 10:30.880
只是在编开发阶段

10:30.880 --> 10:32.880
让它把内形

10:32.880 --> 10:34.880
按照我们想要的内形

10:34.880 --> 10:35.880
来进行判定

10:36.880 --> 10:37.880
所以前面是数据

10:37.880 --> 10:38.880
后边是内形

10:41.880 --> 10:42.880
这是Sound

10:42.880 --> 10:44.880
然后再给它复制一个

10:44.880 --> 10:45.880
函数

10:47.880 --> 10:48.880
就输出

10:49.880 --> 10:50.880
正在游泳

10:56.450 --> 10:57.450
并发出了

10:58.450 --> 10:59.450
并发出了

11:10.780 --> 11:12.780
我随便写一点

11:12.780 --> 11:14.780
总之你实现一个方法就行了

11:15.780 --> 11:16.780
注意

11:16.780 --> 11:17.780
这是一个人

11:17.780 --> 11:18.780
他有牙齿的特征

11:18.780 --> 11:20.780
那么接下来我们来看一下

11:20.780 --> 11:21.780
下面有个辩量

11:22.780 --> 11:23.780
打开看一下

11:24.780 --> 11:25.780
下面有个辩量

11:25.780 --> 11:29.090
它的内形跟它约束一下

11:29.090 --> 11:30.090
约束出来

11:31.090 --> 11:32.090
那么表示

11:32.090 --> 11:33.090
这个辩量是一只牙齿

11:33.090 --> 11:34.090
我们看一下

11:34.090 --> 11:36.090
能不能给它复制一个人

11:37.090 --> 11:38.090
你看

11:38.090 --> 11:39.090
没问题的

11:39.090 --> 11:40.090
可以完成复制的

11:41.090 --> 11:42.090
也就是说

11:42.090 --> 11:43.090
这就是我们说的

11:43.090 --> 11:44.090
牙齿变形法

11:44.090 --> 11:46.090
也叫子结构变形法

11:46.090 --> 11:48.090
咱们人里面有很多属性

11:48.090 --> 11:49.090
但是它有个子结构

11:49.090 --> 11:50.090
这个子结构就是

11:50.090 --> 11:51.090
Sound和Swim

11:51.090 --> 11:52.090
就这个结构

11:53.090 --> 11:55.090
这个结构是满足牙齿的特征的

11:55.090 --> 11:56.090
那么OK

11:56.090 --> 11:57.090
我可以让你复制

11:57.090 --> 11:58.090
它是这样子考虑的

11:58.090 --> 11:59.090
它是这样子考虑的

11:59.090 --> 12:01.090
它为什么要这样子考虑问题

12:01.090 --> 12:02.090
为什么要这样子考虑问题

12:02.090 --> 12:03.090
因为

12:03.090 --> 12:05.090
我们在介石中

12:05.090 --> 12:07.090
经常使用这种质面量对象

12:07.090 --> 12:08.090
经常使用

12:08.090 --> 12:10.090
创建这么一个质面量对象

12:10.090 --> 12:11.090
这个对象里边

12:11.090 --> 12:12.090
可能为了

12:12.090 --> 12:14.090
这个对象可能还要用到其他地方

12:14.090 --> 12:15.090
其他地方

12:15.090 --> 12:16.090
不要说外面还有一些配置

12:16.090 --> 12:17.090
还有一些其他属性

12:17.090 --> 12:18.090
这个对象

12:18.090 --> 12:19.090
有的时候

12:19.090 --> 12:21.090
我要把它当成一个东西来处理

12:21.090 --> 12:22.090
有的时候

12:22.090 --> 12:23.090
我要把它当成一个用户

12:23.090 --> 12:24.090
一个人来进行处理

12:24.090 --> 12:26.090
就是它用的用法很多

12:26.090 --> 12:27.090
用的场景有很多

12:27.090 --> 12:28.090
咱们在介石里面

12:28.090 --> 12:29.090
经常发生这样的事

12:29.090 --> 12:30.090
所以说

12:30.090 --> 12:31.090
他认为

12:31.090 --> 12:32.090
你这个对象

12:32.090 --> 12:33.090
你这个对象

12:33.090 --> 12:34.090
我只需要判断

12:34.090 --> 12:35.090
它的结构是不是满足

12:35.090 --> 12:36.090
要求就行了

12:36.090 --> 12:38.090
不需要去

12:38.090 --> 12:40.090
那么严格的去执行判定

12:40.090 --> 12:41.090
不然的话会导致

12:41.090 --> 12:42.090
你这个对象

12:42.090 --> 12:43.090
可能要写成两个

12:43.090 --> 12:44.090
比方说我要

12:44.090 --> 12:45.090
既要把它当成用户

12:45.090 --> 12:47.090
要把它当成一只牙齿

12:47.090 --> 12:48.090
要把它当成牙齿

12:48.090 --> 12:49.090
在介石里面

12:49.090 --> 12:50.090
其实这种场景的蛮多的

12:50.090 --> 12:52.090
那么他就必须要把对象

12:52.090 --> 12:53.090
拆成两个

12:53.090 --> 12:54.090
如果用严格的内心检查的话

12:54.090 --> 12:55.090
因此

12:55.090 --> 12:56.090
他在这里的

12:56.090 --> 12:57.090
比较寬鬆

12:57.090 --> 12:58.090
还有一个原因

12:58.090 --> 12:59.090
他会认为你这个对象

12:59.090 --> 13:01.090
有可能来自于一个寒树

13:01.090 --> 13:02.090
就是来自于别的

13:02.090 --> 13:03.090
第三方模块得到了对象

13:03.090 --> 13:04.090
这个对象

13:04.090 --> 13:05.090
有一些属性

13:05.090 --> 13:06.090
有一些属性

13:06.090 --> 13:08.090
有一些属性是我们需要的

13:08.090 --> 13:09.090
而另一些属性

13:09.090 --> 13:10.090
我们不care

13:10.090 --> 13:11.090
不care的一些属性

13:13.090 --> 13:14.090
举个例子

13:14.090 --> 13:15.090
举个例子

13:15.090 --> 13:17.090
比方说

13:19.090 --> 13:20.090
假设

13:21.090 --> 13:22.090
假设有个寒树

13:22.090 --> 13:24.090
假设有个寒树

13:25.090 --> 13:28.090
用于得到服务器的

13:28.090 --> 13:30.090
某个接口

13:31.090 --> 13:33.090
某个接口的返回结果

13:33.090 --> 13:35.090
服务器的响应结果

13:35.090 --> 13:38.090
响应结果是一个拥护的宿主

13:38.090 --> 13:40.090
一个拥护对象

13:40.090 --> 13:41.090
一个拥护对象

13:41.090 --> 13:43.090
假设这个拥护对象里面

13:43.090 --> 13:44.090
得到了结果

13:44.090 --> 13:45.090
有一百个属性

13:45.090 --> 13:47.090
假设我们说花招一点

13:47.090 --> 13:48.090
有一百个属性

13:48.090 --> 13:50.090
但是我们拥的时候

13:50.090 --> 13:52.090
实际上我们只会用到

13:52.090 --> 13:53.090
一点点属性

13:53.090 --> 13:54.090
只会用到一点点属性

13:54.090 --> 13:56.090
比方说它的拥护名

13:56.090 --> 13:58.090
它的礼称

13:58.090 --> 13:59.090
或者它的性别

13:59.090 --> 14:00.090
可能只会用到一点点

14:00.090 --> 14:01.090
这种情况是不是经常有

14:01.090 --> 14:02.090
对不对

14:02.090 --> 14:03.090
经常有

14:03.090 --> 14:05.090
我们要判断这个拥护

14:05.090 --> 14:07.090
给它显示一些基本信息的时候

14:07.090 --> 14:09.090
我们只需要用到这么一点点信息就行了

14:09.090 --> 14:11.090
那么我们定接口的时候

14:11.090 --> 14:12.090
我们就没有必要

14:12.090 --> 14:13.090
把整个服务器的返回结果

14:13.090 --> 14:15.090
全部给它约束起来

14:15.090 --> 14:16.090
定下来

14:16.090 --> 14:17.090
比方说

14:17.090 --> 14:18.090
我们服务器的返回结果

14:18.090 --> 14:19.090
比方说

14:20.090 --> 14:23.090
服务器的返回的这个用户

14:23.090 --> 14:25.090
比方说我们这里

14:25.090 --> 14:26.090
只定一个账号

14:26.090 --> 14:28.090
我们只需要它的账号

14:28.090 --> 14:31.090
以及它的礼称

14:31.090 --> 14:35.090
以及它的

14:35.090 --> 14:38.090
性别

14:38.090 --> 14:40.090
当然这里要有美剧

14:40.090 --> 14:41.090
或者是女

14:41.090 --> 14:43.090
我们只需要知道

14:43.090 --> 14:45.090
这边一些减断的信息就行了

14:45.090 --> 14:46.090
其他的东西我不想要

14:46.090 --> 14:47.090
其他的东西

14:47.090 --> 14:48.090
要的话

14:48.090 --> 14:49.090
其他地方要用

14:49.090 --> 14:50.090
其他地方可能要用

14:50.090 --> 14:51.090
但是我这个地方

14:51.090 --> 14:52.090
只需要知道这三个东西就行了

14:52.090 --> 14:54.090
我没有必要把它全部写完

14:54.090 --> 14:56.090
那么用户的真实对象里边

14:56.090 --> 14:58.090
是不是有很多属先

14:58.090 --> 14:59.090
本管

14:59.090 --> 15:00.090
我把这个用户对象

15:00.090 --> 15:01.090
可以直接付这个

15:01.090 --> 15:02.090
这个接口约束的变量

15:02.090 --> 15:04.090
比方说有个变量

15:04.090 --> 15:06.090
User

15:06.090 --> 15:07.090
它是ResponseUser

15:07.090 --> 15:09.090
那么这个用户里边

15:09.090 --> 15:10.090
这个用户里边

15:10.090 --> 15:11.090
可能有很多

15:11.090 --> 15:12.090
这个用户比方说

15:12.090 --> 15:14.090
来自于一个函数的调用

15:14.090 --> 15:15.090
这个U

15:15.090 --> 15:17.090
来自于一个函数的调用

15:17.090 --> 15:18.090
来这个函数的调用

15:18.090 --> 15:19.090
我不写了

15:19.090 --> 15:20.090
我把这个U

15:20.090 --> 15:22.090
复制给这个用户的时候

15:22.090 --> 15:24.090
那么如果用跟严格的类型检查

15:24.090 --> 15:25.090
是不是慌不慌

15:25.090 --> 15:26.090
很慌对吧

15:26.090 --> 15:28.090
你这里面要写多好东西

15:28.090 --> 15:29.090
我需要那么多吗

15:29.090 --> 15:30.090
不需要那么多

15:30.090 --> 15:31.090
我只需要知道这个东西就行了

15:31.090 --> 15:32.090
实际上是这种场景

15:32.090 --> 15:34.090
在接试里面是非常非常常见的

15:34.090 --> 15:36.090
它基于这样的考虑

15:36.090 --> 15:37.090
它考虑了很多

15:37.090 --> 15:38.090
它为什么要这样做

15:38.090 --> 15:40.090
是经过深思熟虑的

15:40.090 --> 15:41.090
它之所以这样子来做的话

15:41.090 --> 15:43.090
它就是为了方便我们

15:43.090 --> 15:45.090
按照我们接试的习惯

15:46.090 --> 15:48.090
因此它允许这样子复制

15:48.090 --> 15:51.090
这是关于对象内形

15:51.090 --> 15:52.090
对象内形这一块

15:52.090 --> 15:54.090
这里顺便讲那个新的知识

15:54.090 --> 15:55.090
叫做内形断言

15:55.090 --> 15:56.090
有的时候我们知道

15:56.090 --> 15:58.090
它是某一个缺陷内形

15:58.090 --> 16:00.090
我们就可以大胆的断定

16:00.090 --> 16:01.090
它是某一个内形

16:01.090 --> 16:02.090
这样子TS

16:02.090 --> 16:05.090
它更加明确我们的意图了

16:05.090 --> 16:07.090
但是这里有个特殊情况

16:07.090 --> 16:09.090
什么特殊情况呢

16:09.090 --> 16:12.460
我们把这个东西

16:12.460 --> 16:14.460
直接写过来

16:14.460 --> 16:15.460
看一下

16:15.460 --> 16:17.460
直接写过来

16:17.460 --> 16:19.460
它确谈就爆错了

16:19.460 --> 16:20.460
这是我非常非常

16:20.460 --> 16:22.460
佩服TS的地方

16:22.460 --> 16:25.460
真的是想得真的细

16:25.460 --> 16:27.460
直接写过来它就爆错了

16:27.460 --> 16:28.460
为什么呢

16:28.460 --> 16:31.460
因为它有这么一个规则

16:31.460 --> 16:32.460
它什么规则

16:32.460 --> 16:36.460
就是当直接使用

16:36.460 --> 16:41.460
对象字面量复制的时候

16:41.460 --> 16:45.460
会进行更加严格的判断

16:45.460 --> 16:47.460
我真的是佩服

16:47.460 --> 16:52.860
当使用对象字面量复制的时候

16:52.860 --> 16:53.860
它规则又变了

16:53.860 --> 16:56.860
它会进行更加严格的判断

16:56.860 --> 16:58.860
压制里面没有那么熟悉

16:58.860 --> 16:59.860
你干嘛写了

16:59.860 --> 17:01.860
没有A级熟悉你干嘛写了

17:01.860 --> 17:03.860
这两个够了

17:03.860 --> 17:04.860
为什么

17:04.860 --> 17:06.860
它为什么要这样做

17:06.860 --> 17:08.860
不是说好的压制面移法吗

17:08.860 --> 17:10.860
压制好好的怎么又不行了

17:10.860 --> 17:12.860
因为你使用的是

17:12.860 --> 17:14.860
一向字面量复制

17:14.860 --> 17:15.860
你想一想

17:15.860 --> 17:16.860
你想一想那个代码

17:16.860 --> 17:18.860
你这样写的逻辑在哪

17:18.860 --> 17:20.860
你想想那个逻辑在哪

17:20.860 --> 17:22.860
你直接使用的对象字面量

17:22.860 --> 17:24.860
你想想那个道理

17:24.860 --> 17:25.860
我定义了个变量

17:25.860 --> 17:27.860
它是一只牙齿

17:27.860 --> 17:28.860
但是呢

17:28.860 --> 17:29.860
我要把它当成一个牙齿对吧

17:29.860 --> 17:30.860
其他东西我不关心的

17:30.860 --> 17:32.860
你看我们后面使用的时候

17:32.860 --> 17:33.860
使用了个大颗的时候

17:33.860 --> 17:35.860
我只能得到少的和使用

17:35.860 --> 17:36.860
因为它是一只牙齿

17:36.860 --> 17:37.860
你跟它复制这些属于

17:37.860 --> 17:38.860
它一不用的

17:38.860 --> 17:39.860
它用都不会用

17:39.860 --> 17:40.860
它只能允许你用这两个

17:40.860 --> 17:42.860
因为你是把它当成牙齿来看待

17:42.860 --> 17:43.860
甭管你写了多少

17:43.860 --> 17:44.860
包括前边

17:44.860 --> 17:46.860
包括前边我们使用那个

17:46.860 --> 17:48.860
Person的时候也是一样

17:48.860 --> 17:50.860
比方说这里写成Person

17:50.860 --> 17:52.860
Person也是一样的

17:52.860 --> 17:54.860
我们后面使用这个大颗的时候

17:54.860 --> 17:55.860
你也只能使用这两个

17:55.860 --> 17:56.860
你使用Name

17:56.860 --> 17:57.860
不行

17:57.860 --> 17:58.860
它是牙齿

17:58.860 --> 17:59.860
哪有这个属性

17:59.860 --> 18:00.860
我只把它当成牙齿来用

18:00.860 --> 18:02.860
甭管你真实的东西是啥

18:02.860 --> 18:03.860
你是一只牙齿

18:03.860 --> 18:04.860
你只能用这两个

18:04.860 --> 18:05.860
你还有意思吧

18:05.860 --> 18:06.860
这是个符合逻辑的

18:06.860 --> 18:08.860
那么它为什么要要求你

18:08.860 --> 18:09.860
字面量

18:09.860 --> 18:11.860
其实有一同样已经感受到了

18:11.860 --> 18:12.860
音乐感受到了

18:12.860 --> 18:14.860
它的用心良苦

18:14.860 --> 18:16.860
它为什么不能让你这样子写

18:16.860 --> 18:17.860
你想啊

18:17.860 --> 18:18.860
你想啊

18:18.860 --> 18:20.860
你这个写了一个牙齿

18:20.860 --> 18:22.860
它说好了是一只牙齿

18:22.860 --> 18:23.860
我后面用的话也只能用它

18:23.860 --> 18:25.860
如果你这个对象是从

18:25.860 --> 18:26.860
其他地方得到的

18:26.860 --> 18:28.860
那么我可以原谅

18:28.860 --> 18:29.860
我可以宽松一点

18:29.860 --> 18:30.860
因为其他地方不知道

18:30.860 --> 18:31.860
我要把它当成牙齿

18:31.860 --> 18:32.860
对吧

18:32.860 --> 18:34.860
而你在这里写这个代码的时候

18:34.860 --> 18:35.860
你已经非常清楚

18:35.860 --> 18:36.860
它是一只牙齿

18:36.860 --> 18:37.860
你这不够倒弯吗

18:37.860 --> 18:38.860
你还给我写这个东西干吗

18:38.860 --> 18:40.860
这东西没有任何意义

18:40.860 --> 18:41.860
我后面用也不能用

18:41.860 --> 18:42.860
用都不能用这些东西

18:42.860 --> 18:43.860
你干吗去写呢

18:43.860 --> 18:45.860
这东西是没有意义的

18:45.860 --> 18:47.860
因为你是直接复制的

18:47.860 --> 18:48.860
你这个对象不是来自于

18:48.860 --> 18:49.860
其他地方

18:49.860 --> 18:50.860
就好比说

18:50.860 --> 18:51.860
我们刚才说的

18:51.860 --> 18:52.860
从服务器返回的结果

18:52.860 --> 18:53.860
我能控制吗

18:53.860 --> 18:54.860
我也控制不了啊

18:54.860 --> 18:55.860
它给我返回多少

18:55.860 --> 18:56.860
我就返回多少

18:56.860 --> 18:57.860
我不能给它

18:57.860 --> 18:58.860
给后装开发者说

18:58.860 --> 18:59.860
我要把它当成牙齿

18:59.860 --> 19:01.860
你能不能少返回一点

19:01.860 --> 19:04.860
少想一点数据

19:04.860 --> 19:05.860
不会的

19:05.860 --> 19:06.860
它给我返回的东西

19:06.860 --> 19:07.860
我怎么能控制呢

19:07.860 --> 19:08.860
不能控制

19:08.860 --> 19:09.860
所以从那个时候

19:09.860 --> 19:10.860
它会宽松

19:10.860 --> 19:11.860
但是你这样直接复制

19:11.860 --> 19:12.860
你明明知道

19:12.860 --> 19:13.860
它是一只牙齿

19:13.860 --> 19:14.860
你还用去直接复制

19:14.860 --> 19:16.860
让你纯粹地倒弯

19:16.860 --> 19:17.860
纯粹去写一些

19:17.860 --> 19:18.860
带有隐患的代码

19:18.860 --> 19:20.860
另外这个意思吧

19:20.860 --> 19:21.860
而且它这样做

19:21.860 --> 19:23.860
还能防止啥呢

19:23.860 --> 19:25.860
还能防止有些情况下

19:25.860 --> 19:27.860
你代码写错

19:27.860 --> 19:29.860
你直接书写的时候写错

19:29.860 --> 19:30.860
比方说

19:30.860 --> 19:32.860
我们这里有一个interface

19:32.860 --> 19:33.860
用户吗

19:33.860 --> 19:34.860
用户

19:34.860 --> 19:36.860
我们认为用户的姓名

19:36.860 --> 19:37.860
是可选的

19:37.860 --> 19:39.860
这里用户的姓名是可选的

19:39.860 --> 19:40.860
怎么来做可选呢

19:40.860 --> 19:41.860
之前我们讲

19:41.860 --> 19:42.860
函数的时候

19:42.860 --> 19:44.860
讲过一个东西叫可选参数

19:44.860 --> 19:45.860
可选参数

19:45.860 --> 19:47.860
其实这些属性也是一样

19:47.860 --> 19:48.860
属性也可以填

19:48.860 --> 19:49.860
可以不填

19:49.860 --> 19:50.860
那么加上个问号就完成了

19:50.860 --> 19:52.860
表示这个属性可以有

19:52.860 --> 19:53.860
可以没有

19:53.860 --> 19:54.860
可以有

19:54.860 --> 19:55.860
可以没有

19:55.860 --> 19:57.860
这里年龄

19:57.860 --> 19:59.860
比方年龄必须要有

19:59.860 --> 20:02.860
比方说吧有这么一个用户

20:02.860 --> 20:03.860
OK

20:03.860 --> 20:05.860
那么我在复制的时候

20:05.860 --> 20:07.860
复制的时候

20:07.860 --> 20:08.860
那个是U

20:08.860 --> 20:11.860
如果我直接使用字面量复制

20:11.860 --> 20:13.860
它会进行更加严格的检查

20:13.860 --> 20:14.860
它防止什么呢

20:14.860 --> 20:18.750
防止你这里打错了

20:18.750 --> 20:20.750
这是我经常看到的错误

20:20.750 --> 20:21.750
给它复制姓名

20:21.750 --> 20:23.750
给它复制年龄

20:23.750 --> 20:25.750
它防止打错了

20:25.750 --> 20:26.750
防止你打错了

20:26.750 --> 20:27.750
你看这里

20:27.750 --> 20:28.750
它说

20:28.750 --> 20:30.750
那么属性是可以

20:30.750 --> 20:31.750
可以为undefine

20:31.750 --> 20:32.750
因为可以不复制

20:32.750 --> 20:33.750
可以不复制

20:33.750 --> 20:35.750
但是你不能够多一个属性

20:35.750 --> 20:37.750
多这个属性是N1MA

20:37.750 --> 20:39.750
很多时候我们可能写错了

20:39.750 --> 20:40.750
这个属性名字

20:40.750 --> 20:42.750
它为了防止这种情况

20:42.750 --> 20:44.750
那如果这个对象是从

20:44.750 --> 20:46.750
其他地方来的呢

20:46.750 --> 20:48.750
OBG

20:48.750 --> 20:50.750
是从其他地方来的呢

20:50.750 --> 20:52.750
咱们来看一下

20:52.750 --> 20:53.750
它就不爆错了

20:53.750 --> 20:55.750
你说那你可能会觉得

20:55.750 --> 20:56.750
它不神经病吗

20:56.750 --> 20:57.750
最少意义的

20:57.750 --> 20:59.750
那我只需要把铁层变量就行了

20:59.750 --> 21:00.750
那你为什么要

21:00.750 --> 21:01.750
那我想

21:01.750 --> 21:02.750
你为什么要去把它弄错呢

21:02.750 --> 21:03.750
你想一想

21:04.750 --> 21:06.750
我们平时书写的习惯

21:06.750 --> 21:08.750
我们不太会去写这样的代码吧

21:08.750 --> 21:10.750
这样代码我们不太会写

21:10.750 --> 21:11.750
不太会写对不对

21:11.750 --> 21:12.750
我们来理一下这个思路

21:12.750 --> 21:13.750
你看一下

21:13.750 --> 21:15.750
铁层是怎么在想这个问题的

21:15.750 --> 21:17.750
这个代码它认为是不太会写的

21:17.750 --> 21:19.750
我们会写怎么样的代码呢

21:19.750 --> 21:21.750
如果我直接给它复制的话

21:21.750 --> 21:23.750
我一般会写这样的代码

21:23.750 --> 21:25.750
这是我们经常写的对不对

21:25.750 --> 21:26.750
好那么

21:26.750 --> 21:27.750
上面这种情况

21:27.750 --> 21:28.750
一般是什么情况呢

21:28.750 --> 21:31.750
一般是这里有个函数调用

21:31.750 --> 21:34.750
调用一个函数得到一个对象

21:34.750 --> 21:36.750
调用一个函数得到一个对象

21:36.750 --> 21:38.750
那么自然而然

21:38.750 --> 21:40.750
在这个函数里边

21:40.750 --> 21:41.750
因为贴是吗

21:41.750 --> 21:43.750
函数里边也会完成类型检查

21:43.750 --> 21:45.750
每一个环境都有类型检查

21:45.750 --> 21:47.750
因为你的类型检查之前就已经发生了

21:47.750 --> 21:49.750
在函数里边就发生了类型检查

21:49.750 --> 21:50.750
所以说

21:50.750 --> 21:52.750
他认为你这样的没事

21:52.750 --> 21:53.750
而且你可以多一些属性

21:53.750 --> 21:55.750
因为这个函数本身

21:55.750 --> 21:57.750
他不知道你要把它当成一个用户来使用

21:57.750 --> 21:58.750
他并不知道的

21:58.750 --> 21:59.750
你可以多一些

21:59.750 --> 22:00.750
是没有问题的

22:01.750 --> 22:03.750
这就是在这个场景下面

22:03.750 --> 22:06.750
给对象直接复制一个字面量的时候

22:06.750 --> 22:07.750
他认为你都知道了

22:07.750 --> 22:08.750
他是一个用户了

22:08.750 --> 22:10.750
你干嘛不按照要求来写

22:10.750 --> 22:12.750
多写的一些属性没有任何意义

22:12.750 --> 22:14.750
因为如果你调用函数的话

22:14.750 --> 22:15.750
那些函数

22:15.750 --> 22:17.750
开发者他不知道之后

22:17.750 --> 22:18.750
要怎么去用他

22:18.750 --> 22:19.750
因此他会返回

22:19.750 --> 22:21.750
可能会返回多一些的数据

22:21.750 --> 22:22.750
但是你这里明明就知道

22:22.750 --> 22:23.750
他要使用用户

22:23.750 --> 22:24.750
直接给他复制的

22:24.750 --> 22:27.750
你就应该准确的去完成

22:27.750 --> 22:28.750
复制

22:28.750 --> 22:30.750
匹配每一个属性

22:30.750 --> 22:31.750
OK

22:31.750 --> 22:35.750
这是关于在对象这一块

22:35.750 --> 22:36.750
有这么一个规则

22:36.750 --> 22:39.750
直接使用对象字面量复制的时候

22:39.750 --> 22:42.750
会进行更加严格的判断

22:43.750 --> 22:46.750
前面讲的是对象内象

22:46.750 --> 22:48.750
使用的是压制编想法

22:49.750 --> 22:50.750
好

22:50.750 --> 22:54.750
下边讲的是函数内象

22:54.750 --> 22:57.750
函数内象

22:57.750 --> 22:59.750
函数内象这一块

22:59.750 --> 23:00.750
就是有两个函数

23:00.750 --> 23:02.750
你要把这个函数复制给另一个函数

23:02.750 --> 23:05.750
这通常出现在回调这里

23:05.750 --> 23:07.750
通常出现在回调这里

23:07.750 --> 23:09.750
比方说

23:09.750 --> 23:10.750
比方说

23:10.750 --> 23:13.750
就咱们之前写不是写过一个函数吗

23:13.750 --> 23:15.750
咱们写过这么一个函数

23:15.750 --> 23:17.750
比较看一下

23:17.750 --> 23:18.750
这函数在哪

23:18.750 --> 23:20.750
在这

23:20.750 --> 23:22.750
写过这么一个函数

23:23.750 --> 23:24.750
拿下来

23:25.750 --> 23:26.750
这是咱们之前写的函数

23:26.750 --> 23:27.750
你看一下

23:27.750 --> 23:28.750
扛地形

23:28.750 --> 23:30.750
扛地形在上面

23:30.750 --> 23:31.750
拿一下

23:31.750 --> 23:33.750
扛地形在这

23:33.750 --> 23:35.750
用interface

23:36.750 --> 23:37.750
咱们今天学了interface

23:37.750 --> 23:39.750
我们就拿来用吧

23:40.750 --> 23:41.750
在这

23:41.750 --> 23:42.750
看一下这个函数

23:42.750 --> 23:44.750
之前咱们写的

23:44.750 --> 23:46.750
这个函数是一个回调函数

23:46.750 --> 23:47.750
你看

23:47.750 --> 23:48.750
这个函数是不是个函数

23:48.750 --> 23:49.750
对不对

23:49.750 --> 23:50.750
函数是一个函数

23:50.750 --> 23:52.750
那这个东西是不是函数

23:52.750 --> 23:53.750
对不对

23:53.750 --> 23:54.750
是个函数

23:54.750 --> 23:55.750
那我现在在做什么

23:55.750 --> 23:57.750
是把这个函数

23:57.750 --> 23:58.750
复制给谁

23:58.750 --> 24:00.750
复制给这个函数对不对

24:00.750 --> 24:02.750
把这个函数

24:02.750 --> 24:04.750
复制给这个函数

24:04.750 --> 24:05.750
函数之间也可以

24:05.750 --> 24:07.750
要进行内形判定的

24:07.750 --> 24:08.750
他们之间内形是怎么判定的

24:08.750 --> 24:09.750
函数有参数

24:09.750 --> 24:11.750
函数有返回值

24:11.750 --> 24:12.750
函数有返回值

24:12.750 --> 24:13.750
那么

24:13.750 --> 24:15.750
他是怎么来判定这个问题的

24:15.750 --> 24:17.750
对于函数内形

24:17.750 --> 24:19.750
这里其实

24:19.750 --> 24:20.750
他来讲的东西有点细

24:20.750 --> 24:21.750
可能

24:21.750 --> 24:22.750
听上去有点绕

24:22.750 --> 24:24.750
但是我先给大家打个招呼

24:24.750 --> 24:26.750
先说明一下

24:26.750 --> 24:28.750
函数内形这一块

24:28.750 --> 24:30.750
我又忍不住把它记下来了

24:30.750 --> 24:31.750
一切

24:31.750 --> 24:33.750
无比的自然

24:33.750 --> 24:35.750
就是你甚至都感觉不到

24:35.750 --> 24:37.750
它这样子就完成了

24:37.750 --> 24:39.750
无比的自然

24:39.750 --> 24:40.750
就是你不知道这一规则

24:40.750 --> 24:42.750
不知道函数怎么来

24:42.750 --> 24:44.750
进行内形判断的

24:44.750 --> 24:45.750
不是那断言

24:45.750 --> 24:47.750
内形兼容性判定的

24:47.750 --> 24:48.750
没问题

24:48.750 --> 24:50.750
你会发现一切的邪法

24:50.750 --> 24:52.750
跟我们以前的接视邪法

24:52.750 --> 24:53.750
无缝迁击

24:53.750 --> 24:56.750
没有任何的就是觉得奇怪的地方

24:56.750 --> 24:58.750
它无比的自然

24:58.750 --> 24:59.750
那么是怎么回事呢

24:59.750 --> 25:00.750
我们要具体的说

25:00.750 --> 25:01.750
所以说

25:01.750 --> 25:02.750
如果你要更加细的话

25:02.750 --> 25:03.750
就听一下后面的

25:03.750 --> 25:04.750
其实你多听一点

25:04.750 --> 25:05.750
多听一点

25:05.750 --> 25:06.750
多听一点

25:06.750 --> 25:07.750
对这个TS

25:07.750 --> 25:08.750
就会了解得更加深入

25:08.750 --> 25:10.750
它是怎么去思考问题的

25:10.750 --> 25:12.750
真的厉害

25:12.750 --> 25:13.750
好

25:13.750 --> 25:14.750
这个函数它是怎么判断的

25:14.750 --> 25:16.750
函数它有参数

25:16.750 --> 25:17.750
有返回值

25:17.750 --> 25:18.750
OK

25:18.750 --> 25:19.750
咱们来看一下

25:19.750 --> 25:21.750
首先看一下关于参数

25:21.750 --> 25:23.750
首先看一下关于参数

25:24.750 --> 25:27.750
关于函数参数

25:27.750 --> 25:29.750
第一个问题

25:29.750 --> 25:30.750
参数

25:30.750 --> 25:32.750
参数它是怎么处理的

25:32.750 --> 25:33.750
好

25:33.750 --> 25:34.750
我举个例子

25:34.750 --> 25:35.750
比方说这里

25:35.750 --> 25:36.750
刚才写的这么一个函数

25:36.750 --> 25:38.750
这个函数是个回调函数

25:38.750 --> 25:39.750
我给你一个数字

25:39.750 --> 25:41.750
你返回一个适逢满足要求

25:41.750 --> 25:42.750
适逢满足要求

25:42.750 --> 25:45.750
那么在这个函数里边

25:45.750 --> 25:46.750
有的时候

25:46.750 --> 25:48.750
我们可能会遇到这样的一个场景

25:48.750 --> 25:49.750
我要把

25:49.750 --> 25:50.750
不是把

25:50.750 --> 25:53.750
我要判断它是不是满足要求

25:53.750 --> 25:55.750
可能还需要一些额外的信息

25:55.750 --> 25:57.750
我现在是怎么告诉他的

25:57.750 --> 25:59.750
我把数组的每一项拿出来

25:59.750 --> 26:01.750
传到这个函数里边去

26:01.750 --> 26:02.750
你看看

26:02.750 --> 26:04.750
做一个参数传过去

26:04.750 --> 26:05.750
传到这个函数里边去

26:05.750 --> 26:07.750
我把每一项拿出来给他

26:07.750 --> 26:08.750
但是有的时候

26:08.750 --> 26:09.750
比方说

26:09.750 --> 26:10.750
我现在要

26:10.750 --> 26:11.750
我要求合的

26:11.750 --> 26:12.750
不是求击数

26:12.750 --> 26:14.750
也不是求偶数

26:14.750 --> 26:15.750
只是要把

26:15.750 --> 26:16.750
第一位

26:16.750 --> 26:17.750
第三位

26:17.750 --> 26:20.750
和第五位的数字相加

26:20.750 --> 26:22.750
那么我要判断它的下标

26:22.750 --> 26:23.750
我要判断满不满足

26:23.750 --> 26:25.750
要求你要给我一个下标才行

26:25.750 --> 26:26.750
光给我这个数组

26:26.750 --> 26:27.750
每一项有什么用的

26:27.750 --> 26:29.750
我要判断的是下标

26:29.750 --> 26:30.750
于是我觉得

26:30.750 --> 26:32.750
为了适应各种各样的情况

26:32.750 --> 26:33.750
我这个函数

26:33.750 --> 26:35.750
可能还需要一个参数

26:35.750 --> 26:37.750
还需要一个参数

26:37.750 --> 26:39.750
叫做

26:39.750 --> 26:40.750
下标

26:40.750 --> 26:41.750
它也是个数字

26:41.750 --> 26:43.750
下标也是数字

26:43.750 --> 26:45.750
这个回调函数需要两个参数

26:45.750 --> 26:46.750
需要两个参数

26:46.750 --> 26:48.750
我会告诉你每一项的值

26:48.750 --> 26:50.750
我也会告诉你

26:50.750 --> 26:51.750
这个i

26:51.750 --> 26:52.750
这个回调函数

26:52.750 --> 26:54.750
那么传递的时候

26:54.750 --> 26:55.750
大家看

26:55.750 --> 26:57.750
我要传两个东西

26:57.750 --> 26:59.750
这里应该是

26:59.750 --> 27:00.750
拨一起里面

27:00.750 --> 27:01.750
不是有个i吗

27:01.750 --> 27:02.750
对吧

27:02.750 --> 27:05.510
拨拿出来

27:05.510 --> 27:06.510
拨一起里面有个i

27:06.510 --> 27:07.510
你看

27:07.510 --> 27:08.510
如果你拨一起

27:08.510 --> 27:10.510
看到有点牢火

27:10.510 --> 27:11.510
因为咱们这个课

27:11.510 --> 27:13.510
面向的同学

27:13.510 --> 27:14.510
称之不起

27:14.510 --> 27:15.510
所以说

27:15.510 --> 27:16.510
有同学呢

27:16.510 --> 27:17.510
可能觉得这个拨一起

27:17.510 --> 27:18.510
看着有点牢火

27:18.510 --> 27:20.510
我还是把它写成拨群环吧

27:20.510 --> 27:22.510
群环这个数组

27:22.510 --> 27:24.510
n

27:24.510 --> 27:26.510
数组的每一项

27:26.510 --> 27:27.510
n

27:27.510 --> 27:30.510
n

27:30.510 --> 27:31.510
好

27:31.510 --> 27:32.510
判断一下

27:32.510 --> 27:34.890
这里是一样的

27:34.890 --> 27:35.890
判断一下

27:35.890 --> 27:36.890
把n传进去

27:36.890 --> 27:37.890
每一项传进去

27:37.890 --> 27:38.890
把下标传进去

27:38.890 --> 27:39.890
你要判断一下

27:39.890 --> 27:40.890
我给力的数字

27:40.890 --> 27:41.890
我给力的下标

27:41.890 --> 27:42.890
你再帮我判断一下

27:42.890 --> 27:43.890
是不是满足要求

27:43.890 --> 27:44.890
满足要求

27:45.890 --> 27:46.890
大家看一个

27:46.890 --> 27:47.890
神奇的事情发生了

27:47.890 --> 27:49.890
它不爆错

27:49.890 --> 27:51.890
它不爆错

27:51.890 --> 27:52.890
我这个函数

27:52.890 --> 27:54.890
只有一个参数

27:54.890 --> 27:56.890
只有一个参数

27:56.890 --> 27:58.890
我的条件是

27:58.890 --> 27:59.890
我把每一项的值纳到

27:59.890 --> 28:00.890
看一下这个值

28:00.890 --> 28:01.890
除以0

28:01.890 --> 28:02.890
是不是不等于0

28:02.890 --> 28:03.890
就是我要把基础向向加

28:03.890 --> 28:04.890
那你想一想

28:04.890 --> 28:05.890
这个逻辑道理

28:05.890 --> 28:07.890
讲道理吗

28:07.890 --> 28:08.890
我这里要判断

28:08.890 --> 28:09.890
它是不是基础

28:09.890 --> 28:10.890
我需不需要下标

28:10.890 --> 28:12.890
需不需要下标

28:12.890 --> 28:13.890
所以完全不需要

28:13.890 --> 28:14.890
它的第二个参数

28:14.890 --> 28:15.890
我只要

28:15.890 --> 28:16.890
一个参数就行了

28:16.890 --> 28:18.890
如果TS进行

28:18.890 --> 28:20.890
严格的内容检查

28:20.890 --> 28:21.890
那么就要求你

28:21.890 --> 28:22.890
你这里说好了

28:22.890 --> 28:23.890
这个函数有两个参数

28:23.890 --> 28:24.890
那你必须要

28:24.890 --> 28:25.890
判断两个参数

28:25.890 --> 28:26.890
那天的凡事

28:26.890 --> 28:27.890
真的得凡事

28:27.890 --> 28:28.890
我每名不需要

28:28.890 --> 28:29.890
第二个参数

28:29.890 --> 28:30.890
我一个参数就够了

28:30.890 --> 28:31.890
你给我一个参数

28:31.890 --> 28:32.890
我就完全够了

28:32.890 --> 28:33.890
那么我就可以完成

28:33.890 --> 28:34.890
负责了

28:34.890 --> 28:35.890
就可以完成判断了

28:35.890 --> 28:36.890
干嘛

28:36.890 --> 28:37.890
一定要让我

28:37.890 --> 28:38.890
传递第二个参数呢

28:38.890 --> 28:39.890
那如果我需要

28:39.890 --> 28:40.890
第二个参数怎么办

28:40.890 --> 28:42.890
需要第二个参数

28:42.890 --> 28:43.890
比如说

28:43.890 --> 28:47.780
随便写

28:47.780 --> 28:48.780
然后呢

28:48.780 --> 28:49.780
我需要这个参数

28:49.780 --> 28:50.780
OK

28:50.780 --> 28:51.780
我要的时候

28:51.780 --> 28:52.780
我就会用

28:52.780 --> 28:53.780
比如说我要求

28:53.780 --> 28:55.780
下标为基数的

28:55.780 --> 28:57.780
下标为基数的项

28:57.780 --> 28:59.780
下标为基数的项

28:59.780 --> 29:00.780
那么我需要用到

29:00.780 --> 29:01.780
第二个参数

29:01.780 --> 29:02.780
那我自然回去用

29:02.780 --> 29:03.780
当我不需要用的时候

29:03.780 --> 29:05.780
当我不需要用的时候

29:05.780 --> 29:07.780
我就可以不用写

29:07.780 --> 29:08.780
这种场景

29:08.780 --> 29:09.780
不要太多

29:09.780 --> 29:10.780
真的不要太多

29:10.780 --> 29:11.780
大家看一下这里

29:11.780 --> 29:12.780
随便写个

29:12.780 --> 29:13.780
这个数组

29:13.780 --> 29:14.780
对吧

29:14.780 --> 29:15.780
数组里面不是有

29:15.780 --> 29:16.780
拨一起吗

29:16.780 --> 29:17.780
拨一起的看一下

29:17.780 --> 29:19.780
他要求你传的什么

29:19.780 --> 29:20.780
传的这个回调函数

29:20.780 --> 29:21.780
对不对

29:21.780 --> 29:22.780
传的这个回调函数

29:22.780 --> 29:23.780
这个回调函数

29:23.780 --> 29:24.780
它的格式是什么

29:24.780 --> 29:25.780
我们把它复制出来

29:25.780 --> 29:30.820
看一下这个回调函数的格式

29:30.820 --> 29:31.820
看一下这个回调函数的格式

29:31.820 --> 29:32.820
它有三个参数

29:32.820 --> 29:33.820
对不对

29:33.820 --> 29:34.820
值

29:34.820 --> 29:35.820
数字

29:35.820 --> 29:37.820
数字数组

29:37.820 --> 29:38.820
它每一个只是数字

29:38.820 --> 29:39.820
下标数字

29:39.820 --> 29:40.820
整个函数

29:40.820 --> 29:41.820
整个数组

29:41.820 --> 29:42.820
是一个数组

29:42.820 --> 29:43.820
它有三个参数

29:43.820 --> 29:45.820
反回类型

29:45.820 --> 29:48.820
它有三个参数的情况下

29:48.820 --> 29:49.820
是不是你每次要用的时候

29:49.820 --> 29:51.820
必须要写三个参数在这

29:51.820 --> 29:52.820
不是吧

29:52.820 --> 29:53.820
我们平时用的是

29:53.820 --> 29:54.820
一个参数可以用

29:54.820 --> 29:55.820
对不对

29:55.820 --> 29:56.820
两个参数

29:56.820 --> 29:57.820
也可以用

29:57.820 --> 29:58.820
也可以用

29:58.820 --> 29:59.820
也可以用

29:59.820 --> 30:00.820
没问题

30:00.820 --> 30:01.820
三个参数

30:01.820 --> 30:02.820
也可以用

30:02.820 --> 30:03.820
但是四个参数就不行了

30:03.820 --> 30:04.820
多了参数

30:04.820 --> 30:06.820
还不可能传给你任何东西

30:06.820 --> 30:07.820
四个参数不行

30:07.820 --> 30:08.820
参数不能多

30:08.820 --> 30:10.820
但可以少

30:10.820 --> 30:11.820
但可以少

30:11.820 --> 30:12.820
所以我们记住一个关键点

30:13.820 --> 30:14.820
其实不用记

30:14.820 --> 30:15.820
一切都无比的自然

30:15.820 --> 30:17.820
因为我们平时都是这样解答的

30:17.820 --> 30:19.820
它是深思熟练的

30:19.820 --> 30:20.820
对着一块

30:20.820 --> 30:22.820
参数这一块怎么处理的

30:22.820 --> 30:24.820
参数

30:24.820 --> 30:26.820
就是

30:26.820 --> 30:28.820
传递给

30:28.820 --> 30:29.820
目标

30:29.820 --> 30:31.820
函数的参数

30:31.820 --> 30:32.820
我们要把

30:32.820 --> 30:34.820
B这个函数复制给A

30:34.820 --> 30:35.820
A要求有多好的参数

30:35.820 --> 30:36.820
对吧

30:36.820 --> 30:37.820
传递给目标函数

30:37.820 --> 30:39.820
就是A那个参数

30:39.820 --> 30:41.820
可以少

30:41.820 --> 30:43.820
但不可以多

30:43.820 --> 30:44.820
就这么简单

30:44.820 --> 30:46.820
当然类型要匹配

30:46.820 --> 30:47.820
类型要匹配

30:47.820 --> 30:48.820
就参数就是这样要求

30:48.820 --> 30:50.820
你如果去背这个东西的话

30:50.820 --> 30:51.820
你背了就觉得莫名其妙的

30:51.820 --> 30:53.820
但是你在这个场景下面一看

30:53.820 --> 30:54.820
一下就明白了

30:54.820 --> 30:55.820
平时都是这样处理的

30:55.820 --> 30:56.820
对不对

30:56.820 --> 30:57.820
都是这样处理的

30:57.820 --> 31:00.820
这是关于参数这一块

31:00.820 --> 31:02.820
关于参数这一块

31:02.820 --> 31:04.820
那么返回值呢

31:04.820 --> 31:06.820
返回值又是咋处理的呢

31:06.820 --> 31:08.820
大家看一下

31:08.820 --> 31:10.820
它真的是想了很多

31:10.820 --> 31:12.820
我们把这个去掉

31:12.820 --> 31:14.820
这个函数要求返回一个布尔

31:14.820 --> 31:16.820
要求返回一个布尔

31:16.820 --> 31:18.820
那么我在用这个函数的时候

31:18.820 --> 31:19.820
你哪里在用

31:19.820 --> 31:20.820
在这里求合的时候

31:20.820 --> 31:21.820
所以要用这个函数

31:21.820 --> 31:22.820
雕用这个函数

31:22.820 --> 31:23.820
在这里雕用的

31:23.820 --> 31:25.820
我把东西传给你

31:25.820 --> 31:26.820
你说好了返回一个布尔

31:26.820 --> 31:28.820
说好了返回一个布尔

31:28.820 --> 31:29.820
那么一定要给我个布尔

31:29.820 --> 31:30.820
千万不要给我个制服串

31:30.820 --> 31:32.820
给我一个乱七八糟的东西

31:32.820 --> 31:33.820
一定要给我一个布尔

31:33.820 --> 31:34.820
因为我要判断

31:34.820 --> 31:36.820
我要用你的返回值

31:36.820 --> 31:37.820
所以说返回值

31:37.820 --> 31:38.820
它的要求很严格

31:38.820 --> 31:39.820
你必须要类型匹配

31:39.820 --> 31:41.820
返回值必须要要求类型匹配

31:41.820 --> 31:43.820
如果这里我啥都不返回

31:43.820 --> 31:44.820
不要返回一个1

31:44.820 --> 31:45.820
说好了

31:45.820 --> 31:46.820
我要判断的

31:46.820 --> 31:47.820
要给我条件

31:47.820 --> 31:49.820
你不能给我其他乱七八糟的东西

31:49.820 --> 31:50.820
对不对

31:50.820 --> 31:52.820
所以说你这里

31:52.820 --> 31:54.820
要返回一个布尔

31:54.820 --> 31:55.820
这个是没问题的

31:55.820 --> 31:57.820
所以说当返回值

32:01.450 --> 32:03.450
返回值

32:03.450 --> 32:07.530
要求返回

32:07.530 --> 32:09.530
它要求你返回一个东西

32:09.530 --> 32:11.530
就必须返回

32:11.530 --> 32:12.530
必须返回

32:12.530 --> 32:13.530
而且类型匹配

32:13.530 --> 32:15.530
而且类型匹配

32:15.530 --> 32:16.530
要求你返回

32:16.530 --> 32:17.530
因为它要用了

32:17.530 --> 32:19.530
它这个函数里面要用这个东西

32:19.530 --> 32:21.530
所以说你必须要返回

32:21.530 --> 32:23.530
要求你返回必须要返回

32:23.530 --> 32:26.530
如果它不要求你返回呢

32:26.530 --> 32:30.480
咱们看一下

32:30.480 --> 32:32.480
如果它不要求你返回

32:32.480 --> 32:34.480
大家看一下这个

32:34.480 --> 32:35.480
一个数组里面

32:35.480 --> 32:36.480
它不是一个函数吗

32:36.480 --> 32:37.480
叫for一起

32:37.480 --> 32:38.480
对吧

32:38.480 --> 32:39.480
又把这个东西拿出来

32:39.480 --> 32:41.480
这个函数的要求是啥呢

32:41.480 --> 32:42.480
要求是这个

32:42.480 --> 32:43.480
来看一下

32:43.480 --> 32:45.480
它的要求

32:45.480 --> 32:47.480
是要有这么一个格式

32:47.480 --> 32:48.480
它的函数

32:48.480 --> 32:49.480
函数你随便

32:49.480 --> 32:50.480
函数你随意

32:50.480 --> 32:51.480
你可以

32:51.480 --> 32:52.480
想用几个用几个

32:52.480 --> 32:53.480
返回呢

32:53.480 --> 32:55.480
是for你的

32:55.480 --> 32:56.480
它是没有返回的

32:56.480 --> 32:57.480
不要求你返回

32:57.480 --> 32:58.480
不要求你返回

32:58.480 --> 33:00.480
就意味着啥

33:00.480 --> 33:01.480
就意味着

33:01.480 --> 33:02.480
它在书写

33:02.480 --> 33:03.480
比方说它写了这么个函数

33:03.480 --> 33:04.480
for一起

33:04.480 --> 33:08.480
它在书写你这个函数的时候

33:08.480 --> 33:11.480
在书写这个函数的时候

33:11.480 --> 33:13.480
它直接就调用了它

33:13.480 --> 33:14.480
直接就调用了这个函数

33:14.480 --> 33:15.480
把东西传进去

33:15.480 --> 33:17.480
把东西传进去

33:17.480 --> 33:18.480
想想东西传进去

33:18.480 --> 33:19.480
还有三个函数

33:19.480 --> 33:20.480
它直接调用这个函数

33:20.480 --> 33:22.480
因为它返回的是for你的

33:22.480 --> 33:23.480
返回的是for你的

33:23.480 --> 33:24.480
它要求的

33:24.480 --> 33:25.480
返回的是for你的

33:25.480 --> 33:27.480
它不会用它的返回结果

33:27.480 --> 33:29.480
不会用它的返回结果

33:29.480 --> 33:30.480
所以说

33:30.480 --> 33:32.480
如果你在这里

33:32.480 --> 33:34.480
如果你在这里

33:34.480 --> 33:36.480
你进行了返回

33:36.480 --> 33:38.480
报不报错呢

33:38.480 --> 33:39.480
它不报错

33:39.480 --> 33:40.480
因为无所谓

33:40.480 --> 33:41.480
你又不影响

33:41.480 --> 33:43.480
喜欢返回就返回

33:43.480 --> 33:44.480
喜欢返回就返回

33:44.480 --> 33:45.480
不影响

33:45.480 --> 33:46.480
因为无所谓的

33:46.480 --> 33:47.480
我是无所谓的

33:47.480 --> 33:48.480
反正又不用你的东西

33:48.480 --> 33:50.480
因为你这里声明的是voy的

33:50.480 --> 33:52.480
我知道你没有返回结果

33:52.480 --> 33:53.480
你一定要返回

33:53.480 --> 33:54.480
随便你

33:54.480 --> 33:55.480
我又不用

33:55.480 --> 33:57.480
那么你这个返回是没有任何意义的

33:57.480 --> 33:58.480
当然

33:58.480 --> 33:59.480
没有意义不代表

33:59.480 --> 34:00.480
我不会写这样的代码

34:00.480 --> 34:01.480
我有可能会写出这样的代码

34:01.480 --> 34:02.480
但是这个代码

34:02.480 --> 34:03.480
不会影响到任何东西

34:03.480 --> 34:04.480
不会造成程序

34:04.480 --> 34:06.480
有任何的隐患

34:06.480 --> 34:08.480
因为我又不会用你这个返回结果

34:08.480 --> 34:09.480
所以说

34:10.480 --> 34:11.480
那么再给大家看一个例子

34:11.480 --> 34:12.480
我们平时

34:12.480 --> 34:13.480
要输出一个数组里面

34:13.480 --> 34:15.480
每一项我们会怎么做

34:16.480 --> 34:17.480
我们会怎么做

34:17.480 --> 34:18.480
for一起循环

34:25.480 --> 34:26.480
对不对

34:26.480 --> 34:27.480
我们会这样子写

34:27.480 --> 34:28.480
对不对

34:28.480 --> 34:29.480
会这样子写吧

34:29.480 --> 34:32.480
那么使用尖头函数的时候

34:32.480 --> 34:34.480
后边跟着是不是返回结果

34:34.480 --> 34:35.480
尖头函数

34:35.480 --> 34:37.480
后边跟着是不是就返回结果

34:37.480 --> 34:38.480
对呀你返回来

34:38.480 --> 34:39.480
你返回来的东西

34:39.480 --> 34:40.480
你返回来的结果

34:40.480 --> 34:42.480
虽然LOG是OND犯

34:42.480 --> 34:43.480
返回的是

34:43.480 --> 34:45.480
这个都让LOG的返回的也是卧位的

34:45.480 --> 34:47.480
返回的也是卧位的

34:47.480 --> 34:49.480
有可能

34:50.480 --> 34:51.480
这个场景我实在去不到了

34:51.480 --> 34:53.480
总之就是刚才我们说的

34:53.480 --> 34:54.480
刚才我们说的

34:54.480 --> 34:56.480
就是你返不返回去

34:56.480 --> 34:57.480
对他没有什么影响的

34:57.480 --> 34:58.480
没有什么影响的

34:58.480 --> 35:00.480
因为他又不会用你的返回结果

35:00.480 --> 35:01.480
所以说

35:01.480 --> 35:02.480
他这个点

35:02.480 --> 35:04.480
他是这样子处理的

35:04.480 --> 35:07.480
不要求返回的时候

35:07.480 --> 35:08.480
你随意

35:08.480 --> 35:09.480
随便

35:09.480 --> 35:10.480
要返回就返回

35:10.480 --> 35:11.480
返回不用

35:11.480 --> 35:14.480
你不会对程序造成任何的影响

35:15.480 --> 35:16.480
OK

35:16.480 --> 35:18.480
这就是函数这一块

35:18.480 --> 35:20.480
他是怎么来限定内容的

35:20.480 --> 35:22.480
整个这一块东西我讲了这么多

35:22.480 --> 35:25.480
不需要大家去使心隐悲

35:25.480 --> 35:26.480
千万不要悲

35:26.480 --> 35:27.480
我反正悲不住

35:27.480 --> 35:30.480
那么你们怎么要去理解这一块

35:30.480 --> 35:31.480
理解他的合理性

35:31.480 --> 35:33.480
他是怎么去看待这个问题的

35:33.480 --> 35:35.480
你理解了过后

35:35.480 --> 35:37.480
你就会对这个TS

35:37.480 --> 35:39.480
有更深入的感受了

35:39.480 --> 35:41.480
你只知道他这个类型系统

35:41.480 --> 35:43.480
到底做了哪些事情

35:43.480 --> 35:45.480
怎么来去推倒的

35:45.480 --> 35:47.480
也对你们今后去开发

35:47.480 --> 35:48.480
一些公共模块

35:48.480 --> 35:49.480
会去写一些

35:49.480 --> 35:51.480
底层的一些东西的时候

35:51.480 --> 35:53.480
提供了一种考虑问题的思路

35:53.480 --> 35:56.480
他其实很多问题的出发点

35:56.480 --> 35:58.480
他出发点都是

35:58.480 --> 36:00.480
尽量保留我们以前的

36:00.480 --> 36:02.480
良好的开发习惯

36:02.480 --> 36:05.480
舍弃掉不好的一些开发习惯

36:06.480 --> 36:08.480
或者是保留那些

36:08.480 --> 36:10.480
没有什么影响的开发习惯

36:10.480 --> 36:11.480
这里就没有什么影响

36:11.480 --> 36:12.480
没有什么影响的开发习惯

36:12.480 --> 36:13.480
也保留下来

36:14.480 --> 36:15.480
这一课咯

36:15.480 --> 36:16.480
咱们就讲完了

36:16.480 --> 36:18.480
咱们讲了两个东西

36:18.480 --> 36:19.480
一个是接口

36:19.480 --> 36:20.480
非常常用的

36:20.480 --> 36:22.480
目前的接口跟内心别名

36:22.480 --> 36:23.480
区别不是很大

36:23.480 --> 36:25.480
但是我个人建议

36:25.480 --> 36:26.480
大家使用接口吧

36:26.480 --> 36:27.480
我看你自己习惯吧

36:27.480 --> 36:29.480
算了我也不会强制要求你们

36:29.480 --> 36:31.480
后边学的

36:31.480 --> 36:32.480
进阶部分的时候

36:32.480 --> 36:34.480
我会详细的讲接口和内的

36:34.480 --> 36:35.480
之间的联用

36:35.480 --> 36:37.480
它可以约束内

36:37.480 --> 36:39.480
基础部分我们先不管

36:39.480 --> 36:40.480
然后讲内形兼容性

36:40.480 --> 36:43.480
就是TS里边如何来判定内形的

36:43.480 --> 36:44.480
那么有了这两块知识过后

36:44.480 --> 36:46.480
我们接下来还是老规矩

36:46.480 --> 36:49.480
对咱们的小练习

36:49.480 --> 36:50.480
铺客牌的小练习

36:50.480 --> 36:51.480
做一下改造

