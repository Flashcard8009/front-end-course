WEBVTT

00:00.000 --> 00:08.000
好 开发完了这么一个小的骑士 这么一个组件之外 之后呢 咱们来开发这个组件

00:08.600 --> 00:14.000
就是这个骑盘的组件 好 其实骑士这个骑盘的组件就是一个一个的

00:15.280 --> 00:19.280
小的骑士组成的 对吧 就是这么一个一个的小的骑士组成的

00:19.880 --> 00:22.920
因此呢 我们这里建立这么一个文件

00:23.720 --> 00:27.000
该取名为board 骑盘这么一个组件

00:28.000 --> 00:35.600
好 同样的道理啊 我还是给他返回一个函数组件吧 返回这么一个函数组件

00:36.400 --> 00:37.200
好 方形

00:38.800 --> 00:40.120
这里写上board

00:41.120 --> 00:41.400
comp

00:42.320 --> 00:46.280
然后有个属性 这个属性肯定要进行约束 我们等一下来进行约束

00:47.200 --> 00:48.520
好 来约束一下这个属性

00:49.520 --> 00:54.200
你要我要显示一个骑盘 你得告诉我啥呢 先写个interface

00:54.760 --> 00:55.400
i props

00:56.400 --> 01:01.400
有这么一个骑盘 你得告诉我个啥呢 告诉我一个数组

01:02.200 --> 01:03.200
为什么要告诉一个数组

01:04.000 --> 01:11.000
这个骑盘上有9个格子 对吧 每一个格子显示的是什么骑子

01:12.000 --> 01:17.600
这个格子每个格子上有没有骑子 或者说这个格子上显示的是什么骑子 你得告诉我

01:18.000 --> 01:21.000
这样子呢 我才能帮你去展示这个骑盘

01:21.800 --> 01:26.200
因此呢 你得告诉我一个数组 比方说这个数组的名字 我给他取名为css

01:27.000 --> 01:35.200
表示一个数组 一个骑盘 一个骑子的数组 每一个骑子呢 还有状态 要么没有 要么是红色 要么是

01:35.800 --> 01:36.200
黑色

01:37.000 --> 01:43.000
所以说这个骑子它是一个数组 它是一个什么类型的数组呢 大家想一想 好想想这块

01:44.200 --> 01:50.000
骑子有一个数组 它是什么类型的数组 它的每一项应该是什么类型

01:51.800 --> 01:56.800
你想啊 每一项我要需要知道什么信息 每一项我要需要知道的信息是

01:57.400 --> 02:03.200
这个数组 比方肯定是有九项 对吧 有九项 我们到时候传的话会传一个长度为九的数组过来

02:04.000 --> 02:10.000
传过来的时候 数组的每一项它要么是黑色的 要么是红色的 要么是没有 对不对

02:10.400 --> 02:16.000
但是这应该是个什么数组 是不是应该是个每一句的数组啊 就是个css type的数组

02:16.500 --> 02:21.800
每一项它只是三个状态中的一个 需要给我们传一个这样的一个数组过来

02:23.100 --> 02:29.400
好 给我们传过来的时候呢 我们在这里就可以给它进行约束了啊 约束一下这个iprops

02:30.400 --> 02:36.600
把这个属性约束为这个 那么我们就可以使用这个属性了 这它是一个数组吧 我们可以循环它

02:37.200 --> 02:38.200
每一次循环

02:39.200 --> 02:47.000
得到一个什么样的 得到一个什么样的东西 这个数组里面每一项是一个状态 我们需要通过这个状态来生成一个组件

02:47.600 --> 02:53.400
你想啊 你给我传一个长度为九的数组 我要生成一个九个格子 每个格子是不是个组件 对不对

02:54.000 --> 02:59.200
所以说按照我们以前的知识 我们在这里呢 可以使用这个属性里面的css

03:00.200 --> 03:01.800
使用这个东西 然后呢

03:03.200 --> 03:07.000
进行map 来进行映射 来进行映射 这是个数组吗

03:07.800 --> 03:10.600
每数组的每一项什么的一项 数组的每一项

03:11.900 --> 03:16.400
type 是一个type的一项 每一项是个type 你看就是个chess type

03:17.100 --> 03:21.400
好 每一项我要给他一个返回一个什么样的结果了 我要返回一个

03:23.200 --> 03:29.200
返回个啥 返回一个组件 这个数组里面有一项 我就要返回一个组件 这个组件是啥 这个组件就是

03:29.700 --> 03:36.900
chess comp 就这个组件 好这个组件有个属性 这个属性什么属性 如果你忘了这个属性的名字

03:37.200 --> 03:46.800
你指着他看一下 属性就是type 对不对 就是你要告诉他 你不是要使用一个棋子组件吗 你告诉他这个棋子是什么类型 什么类型的棋子

03:47.000 --> 03:48.800
好 棋子就是把这个传过去

03:50.500 --> 03:52.100
type 再传过去

03:53.100 --> 03:58.000
好了 通过这种方式呢 我们就得到了啊 当然这里可以把它写成一句话啊 也可以

03:58.400 --> 04:05.700
减写一下 写成一句话 这样子也可以 通过这个map函数来映射出一个什么呢 一个集合啊 一个集合

04:06.300 --> 04:12.100
我们指着他看一下这个集合 这个集合是什么类型 是一个js x element的类型

04:12.600 --> 04:23.000
就表示一个一个元素的数组 这个集合里面存放了一个一个的元素 当然呢 按照我们以前的方式啊 这里面是不是应该还要写个key子 对不对

04:23.200 --> 04:32.100
还写个key 还写个key子 不然他要报警告的 这个key子写啥呢 其实这里有没有id写啥呢 我就可以写这个数组的下标啊

04:32.700 --> 04:35.700
写下这个数组的下标 把这个下标给他

04:36.500 --> 04:38.300
ok 把这个key子给他

04:39.700 --> 04:44.500
好了 有了这么个数组过后 接下来我们来返回一个东西 啊return

04:45.500 --> 04:50.100
返回个啥 返回个div 这个div给他跟那样是吧 表示bode 这是我们的棋盘

04:50.700 --> 04:56.300
棋盘里边有很多的棋子 棋子在哪 就在这个历史里面啊 就在这个历史里面

04:57.200 --> 05:01.800
好 保存一下啊 我们在app这里面去使用一下 测试一下

05:03.000 --> 05:10.600
把这个取消掉 把这个地方删除掉 这里面我们要给他一个组件叫bode count这个组件

05:11.100 --> 05:18.300
好 这个组件呢 需要你给他一个属性 如果你忘了那个属性的名字 你指着他马上就可以看到他需要这么一个属性啊切碎是

05:18.900 --> 05:24.300
好 切碎是个属性的 你如果你忘了那一行的话 其实你指着他他会提示你 这是个咱们那一行呢

05:24.700 --> 05:29.100
看这里是一个每一句的数组啊 一个每一句的数组 然后咱们来

05:30.100 --> 05:34.300
试着做一下吧 反正是测试嘛 对不对 这里面我们写这么一个每句的数组啊

05:35.700 --> 05:36.100
taps

05:38.100 --> 05:39.300
这里面呢 我使用

05:40.200 --> 05:48.900
cheese type 他是个cheese type的数组 ok 那么数组复指的时候每一项的指指一个复指啊 第一个第一个棋子是

05:50.100 --> 05:56.100
黑紫 一项一项复指一二三四五六七八九

05:57.100 --> 05:58.100
红色

06:04.050 --> 06:14.050
随便写吧 这个地方啊 随便写一些好 我就把这个切碎啊 这个这个纸呢 给他复指过去

06:15.050 --> 06:19.050
好 给他复指过去 好 咱们来看一下啊 看一下我们的一面

06:21.050 --> 06:26.050
哎 又遇到同样的问题了 对吧 老是忘记 这里应该找入react

06:29.050 --> 06:31.050
好 咱们再看一下啊

06:33.050 --> 06:34.050
关掉

06:35.050 --> 06:41.050
好 你看一下 是不是有九个棋子的一二三四五六七八九啊 一共有九个棋子

06:42.050 --> 06:48.050
那么现在就在接下来就是显示的问题 显示的时候呢 我不能用这种方式来显示

06:49.050 --> 06:54.050
现在为什么这种方式显示是因为每个棋子呢 是一个diva 他是个快合 所以说他独占一行

06:55.050 --> 07:01.050
那现在要显示的话 我应该使用把它三个三个并排显示 其实这里呢 可以设置一下宽膏

07:02.050 --> 07:09.050
就是设置一下这个盒子的宽膏 设置一下这个盒子宽膏 或者是不设置高度都行啊 你的宽度你要设置一下

07:10.050 --> 07:14.050
设置一下宽度了 然后把它变成弹性盒 那它可以自动换好

07:15.050 --> 07:19.360
这里我们设置一下这个board

07:20.360 --> 07:24.360
comp.css 啊 写个css文件 然后这边去把导入进来

07:25.360 --> 07:30.360
in port 导入一下这个chess comp

07:31.360 --> 07:35.360
应该是board.comp.css 导入进来

07:36.360 --> 07:40.360
然后css里边呢 就可以加上这个内样式了 这个内样式叫做board

07:41.360 --> 07:45.360
好 这个内样式里边其实就是把它变成一个弹性盒 Flux 弹性盒

07:46.360 --> 07:53.360
然后呢 允许换行 Flux Web Web 允许换行宽度设置多少呢

07:53.360 --> 08:00.360
宽度的话 这里每一行有三个格子 我看一下之前每个格子设置的是

08:01.360 --> 08:07.360
50个像素 50个像素 这里面呢 我就给它50乘以3对吧 50乘以3

08:08.360 --> 08:12.360
150个像素 好 保存一下 咱们来看一下啊

08:13.360 --> 08:18.360
好 现在一个问题就是美行它只显示了两个 为什么呢 咱们来审核一下元素啊

08:18.360 --> 08:24.960
这里要分析一下 为什么美行只显示了两个元素 其实你看一下外面那个盒子 它的宽度是正常的

08:25.560 --> 08:32.360
宽度是150 那应该按你说的话里面可以装三个 但是为什么只装了两个就装不下来了

08:32.860 --> 08:39.960
我们看一下这里 为什么只装了两个 当我们指着这个盒子的时候呢 你看一下啊 看一下这个位置

08:40.960 --> 08:45.960
它生成的尺寸是多少 能不能看见啊 是54乘以54

08:46.560 --> 08:52.960
为什么我说的宽高是50乘50 它结果显示得到得到的最终结果呢 何止它占据了54个像素呢

08:53.560 --> 09:00.160
是因为它包含边框啊 是因为这个原因 说这个地方呢CSS大家要注意一下啊 边框是会占据空间的

09:00.760 --> 09:06.560
因此呢 在这个位置啊 在这个位置 我们这里有两种做法

09:07.160 --> 09:09.960
一种做法呢 是直接把这个玩意呢 设置成outnet

09:11.360 --> 09:16.160
设置成outnet outnet 我们知道是不占据空间的啊 他不占据空间 这是这种做法

09:16.760 --> 09:21.960
另外一种做法呢 是设置box sizing border box

09:23.460 --> 09:28.660
就是我们盒子的尺寸呢 是按照边框盒啊 是从边框范围内来进行计算的

09:29.160 --> 09:34.360
我们这里的宽高呢 设置是带边框的宽高啊 所以边框宽高了 它也包含在内的

09:34.960 --> 09:38.960
我们可以通过这种方式来进行处理 都行啊 看你自己使用哪一种

09:39.760 --> 09:47.760
啊 那么现在就显示了三层三的格子了 好 最后呢 我们把这个盒子居中啊 Margin

09:50.160 --> 09:54.160
上下设置为一个EM左右的话为out to

09:55.460 --> 09:58.760
把这个盒子居中啊 差不多了啊 就显示出来了

09:59.560 --> 10:06.360
好 那么之后呢 这个盒子这个棋盘上要显示什么样的棋子 是需要通过这个属性来进行传递的

10:06.760 --> 10:11.360
传递过去 当然呢 这里面还有很 其实你要把它做系 把做

10:12.160 --> 10:18.160
好的话 其实还有很多东西需要考虑 比方说你这里其实有一些偶和对吧 比方说这里

10:18.760 --> 10:24.160
凭什么宽度是150呢 是因为我认为每个小的棋子啊 每个小的棋子

10:24.560 --> 10:29.560
是50个相处 为什么我这里知道是50个相处呢 是因为我看到这个CSS

10:29.960 --> 10:36.760
因此呢 你看这个CSS跟这个CSS 他们之间是有偶和的 什么叫偶和 偶和就是联系的意思

10:39.560 --> 10:39.960
偶和

10:41.860 --> 10:49.660
偶和 偶和就是联系的意思啊 他们之间无形中产生的关联 那如果有一天你要把这个央视调整一下 你想一想

10:50.660 --> 10:59.860
你很有可能就忘了 这边要需要调整 因此这里是有一些缺陷的啊 只不过这些缺陷我们目前呢 也不去花过多的时间去解决 该怎么解决呢

11:00.360 --> 11:01.760
真确的做法是应该把这个

11:02.660 --> 11:07.960
每个盒子的宽高呢 也应该作为属性啊 也应该作为属性 比方说这个小棋子

11:08.460 --> 11:16.160
小棋子的宽高为50 凭什么是50呢 你应该传递给他 作为属性来传递给他 传递给他之后呢 这边啊 这边

11:16.960 --> 11:21.660
就需要啊 使用这个属性来这里动态的设置他的宽高 通过style

11:22.160 --> 11:28.660
来设置他的宽高 这是这种做法 那么这边也是同样的啊 每个小格子有多少宽高呢 你需要告诉他

11:29.260 --> 11:34.360
这样子呢 更加好一点 只不过我们现在不用去做那么麻烦了 我关注这个功能就行了

11:34.860 --> 11:41.160
还有一个缺 还有一个点呢 其实就是如果以后你要做更多的格子 比方说不一定是三成一三

11:41.660 --> 11:45.860
不一定是三成一三 或者是八成一八十成一十 那么你可能要考虑更多的东西

11:46.360 --> 11:51.160
只不过我们这个练习里边呢 尽量 尽量简单一点吧 因为我们主要是练习ts

11:52.860 --> 11:56.160
好 有了这么一个棋盘之后 我们还要考虑些东西 就是事件

11:57.160 --> 12:00.660
我们知道刚之前呢 我们做这个做这个玩意的时候

12:01.760 --> 12:05.060
我当时负责 这里负责两个属性 这里面是有事件的

12:05.460 --> 12:10.660
这个事件呢 他可能我们需要去对他进行处理一下 这个事件的名字叫做on 把on打出来

12:11.160 --> 12:18.160
你会发现了他有一个事件名叫做click 你看 现在我们不用去背他的一个事件名了 他会这种提示我们

12:19.060 --> 12:23.360
好 有这么一个事件 我们需要对这个事件来进行下处理 处理一下这个事件

12:24.660 --> 12:30.860
好 这个事件怎么处理呢 当我们发生这个事件的时候 就是当用户点了谁 点了一个

12:32.060 --> 12:35.060
空位置 一个空位置上的

12:35.760 --> 12:36.160
这个

12:37.960 --> 12:44.560
棋子的时候 就是这个地方没有棋子 点击的时候呢 他会触发这个事件 他会触发这个事件 我来

12:45.360 --> 12:47.760
康兽乐鬼一下吧 我乐鬼啥呢 就乐鬼就哎

12:48.560 --> 12:52.760
就数组的下标 把数组下标打出来啊 保存一下啊 跟他看一下

12:54.260 --> 12:59.760
当我点第一个的时候 你看是没有触发这个事件的 对吧 当我点第三个的时候 你看下标二打出来了

13:00.460 --> 13:04.960
当我点第四个的时候 下标为三打出来了 啊 这些东西都不能触发时间

13:05.360 --> 13:12.260
看到没 就这个事件触发的 他有个前提条件 就是肯定是点的是个空格子 这是我们之前那个组建做好的

13:12.960 --> 13:15.960
好 如果你点了一个空格子 这里要做啥

13:16.960 --> 13:20.960
这里要做啥呢 所以也不知道要做啥 这个地方我也不知道要做啥

13:21.660 --> 13:27.160
因此呢 我也要把这个事件扔出去啊 我也不知道要做啥 因此我要把个事件扔出去

13:27.560 --> 13:30.860
因此呢 你需要给我传递一个回调 这个回调是可选的

13:32.360 --> 13:34.760
啊 还是onclick 还是onclick

13:35.560 --> 13:37.160
传递一个回调 这个回调是可选的

13:38.060 --> 13:42.660
当我们点击的时候要做什么事情 做什么事情呢 就要给我一个函数

13:43.160 --> 13:45.160
这个函数里边呢 我会给你一个参数

13:46.160 --> 13:51.560
为什么我要给你一个参数 因为我要让你知道是哪个旗子 就是哪个格子被点击了

13:52.060 --> 13:56.060
不然的话你怎么知道点了哪个格子呢 所以说我会给你一个下标

13:57.960 --> 14:04.360
他是个数字 我会把我点击那个格子的下标给你 那么到时候你需要怎么去处理呢 你自己去处理

14:04.660 --> 14:08.660
我不管 好 这个函数呢 返回为void 不需要返回

14:10.060 --> 14:15.860
好 这里面我就可以怎么样 就可以判断一下 判断一下 onclick

14:17.060 --> 14:18.060
probs

14:18.860 --> 14:20.660
probs onclick

14:21.860 --> 14:25.060
有值吗 如果你有值的话 我就调用这个函数

14:25.860 --> 14:28.360
如果你给了我这个回调函数 我就调用这个回调函数

14:28.660 --> 14:31.460
然后把这个index传给你 就是i

14:32.460 --> 14:36.060
下标不就是个i吗 对不对 我把这个下标传给你

14:37.260 --> 14:42.860
好 接下来我们再看一下啊 再看一下 这边我们来注册一个事件 注册一个事件

14:46.660 --> 14:52.560
onclick 注册一个事件 这个事件里边呢 它会传一个下标进来

14:53.260 --> 15:00.060
i 会传一个下标过来 我们把这个i输出看一下啊 把这个i输出 保存一下

15:01.060 --> 15:09.060
这边过来 点这个地方 二没问题 三没问题 点这些没有反应 点这些没有反应

15:10.660 --> 15:15.260
好 这是关于这一块啊 我需要传递这么一个东西过来

15:16.260 --> 15:23.260
好 接下来其实还有一个问题 还有一个问题 其实还有一种情况 我也不需要出发事件

15:23.860 --> 15:28.460
什么情况呢 还有一种情况是我也不需要出发事件的 什么情况

15:28.660 --> 15:33.060
就是游戏已经结束了 对吧 游戏结束了过后

15:33.860 --> 15:37.260
我也不需要出发这个事件 这个事件只有在什么时候出发

15:38.060 --> 15:43.460
游戏没有结束的时候 并且你点了空白的位置才会出发这个事件

15:43.860 --> 15:49.260
如果游戏已经结束了 我也不需要出发这个事件 因此呢 我可以把这个逻辑呢写到这

15:50.060 --> 15:52.060
也可以怎么样 也可以

15:53.060 --> 16:00.260
把这个逻辑呢放到外边来处理 我总之给你出发事件 游戏有没有结束 你根据游戏有没有结束来自行自行进行判断

16:00.660 --> 16:08.860
看你自己了 看你自己把这个逻辑写到哪 如果你要写到这个旗盘里边的话 你还需要个属性 就是游戏

16:09.660 --> 16:15.660
是否结束 游戏是否结束 那么这里比方说有这么一个属性 游戏是否结束

16:16.660 --> 16:23.260
游戏是不是结束了 它的类型是什么 布尔

16:25.260 --> 16:33.060
或者说 is game over 游戏是否结束 当然它默认了 可以给它个默认值 可以给它个默认值 默认值我们以后再说吧

16:33.260 --> 16:37.460
我们以后再说默认值的问题 假设有这么一个属性 游戏是否结束

16:37.860 --> 16:41.660
ok 那我什么时候出发这个事件呢 只有当什么

16:42.660 --> 16:45.260
当游戏没有结束的时候

16:47.660 --> 16:54.660
is game over 游戏没有结束 并且你又传递了这么一个毁掉函数

16:54.660 --> 16:56.660
ok 那我给你出发这个事件

16:57.660 --> 17:02.660
好 那我们这边传递的时候还要传递一个数据 就是游戏是否结束

17:02.660 --> 17:04.660
游戏是否结束

17:07.660 --> 17:09.660
比方说给它传递为处

17:10.660 --> 17:13.660
现在我们给它设置为游戏已经结束了 我们看一下这里

17:13.660 --> 17:18.660
点击一下 你看 是不是没有事件发生了 没有任何事情发生 因为游戏已经结束了

17:18.660 --> 17:23.660
我现在把游戏设为 force 游戏是否结束设为 force 要是游戏没有结束

17:23.660 --> 17:27.660
没有结束 那么点击过后了 它就有相应的事件发生了

17:27.660 --> 17:31.660
于是这个事件我们就可以认为 什么时候会出发这个事件

17:31.660 --> 17:36.660
只有游戏没有结束 并且我点了一个空白位置的时候 才会出发这个事件

17:37.660 --> 17:43.660
好 这是关于这一块 关于这一块 那么这里我说一个小的问题

17:43.660 --> 17:46.660
其实不算问题了 在咱们这个项目里面不算什么问题

17:46.660 --> 17:53.660
但既然讲到这儿了 我顺便说一下 就是这个属性的默认值的问题

17:53.660 --> 17:59.660
如果我这里有一个需求 我需要给这个属性一个默认值

17:59.660 --> 18:02.660
它默认为 force 默认为游戏没有结束

18:02.660 --> 18:07.660
也就是说外面可以不用传递 不用传递 那么它默认就为 force

18:07.660 --> 18:11.660
该怎么来做 该怎么来实现这个默认值

18:11.660 --> 18:18.660
这里其实有很多的办法 但是目前还没有一个特别特别完美的一种方案

18:18.660 --> 18:23.660
这里的很多办法还需要用到境界部分的知识

18:23.660 --> 18:28.660
因此如果你在基础部分 要使用属性默认值的话

18:28.660 --> 18:33.660
我比较推荐用这种做法 第一步 你的内情约束里面

18:33.660 --> 18:37.660
你不能在这里写默认值 这里是不能写的 这里为它不能写

18:37.660 --> 18:41.660
因为这是接口 接口是不会参与到编译结果里面的

18:41.660 --> 18:44.660
编译结果里面这个就消失了 那它只能杂志到默认值是啥的

18:44.660 --> 18:47.660
所以这个代码会消失的 所以不能在这里写

18:47.660 --> 18:51.660
它也不允许你在这里写 那么你首先第一步呢

18:51.660 --> 18:55.660
你要把这个东西变成问号 为什么

18:55.660 --> 18:58.660
因为你是默认值 你既然有默认值的话

18:58.660 --> 19:01.660
是不是意味着可以不用传递 对不对 可以不用传递

19:01.660 --> 19:04.660
因为它是 这就意味着它是可选的

19:04.660 --> 19:09.660
所以说第一步 你要把这个东西设置成可选的属性

19:09.660 --> 19:14.660
第二步 就跟以前的JS一样 跟以前的JS一样

19:14.660 --> 19:21.660
这个是函数组件 给这个组件加一个属性叫DefaultProbs

19:21.660 --> 19:24.660
给它属性复制默认值

19:24.660 --> 19:28.660
但是这里你写的时候 它没有智能提示

19:28.660 --> 19:32.660
它完全没有智能提示 为什么它没有智能提示呢

19:32.660 --> 19:38.660
因为它不知道 你这个东西就是一个函数组件

19:38.660 --> 19:41.660
它不知道这个玩意是个函数组件 为什么它不知道

19:41.660 --> 19:46.660
你看一下这个函数的写法 跟一个普通的函数有啥区别

19:46.660 --> 19:50.660
所以没有区别 它怎么知道这个函数里边有这么一个属性

19:50.660 --> 19:54.660
它其实并不知道 因此你在写这个函数的时候

19:54.660 --> 19:58.660
写这个组件的时候 就不太建议你用这种方式写了

19:58.660 --> 20:02.660
你要用什么方式写呢 你要用这种方式

20:02.660 --> 20:07.660
用这种方式 就是我们当时讲

20:07.660 --> 20:12.660
就是本节课的第二个小节的时候 讲TS如何跟RECT来联用的时候

20:12.660 --> 20:17.660
当时讲了这么一个方式 在这里进行约束 约束为RECT

20:17.660 --> 20:22.660
FC 函数式组件 或者叫做无状态组件

20:22.660 --> 20:26.660
通过这个翻型 给它约束属性

20:26.660 --> 20:30.660
这样子以约束过后 咱们来看一下

20:30.660 --> 20:33.660
其实我们可以看一下FC里面到底有什么东西

20:33.660 --> 20:36.660
这个FC 我们按F12转到定义

20:36.660 --> 20:40.660
这样子以约束过后 你会发现 它其实是个什么内形别名

20:40.660 --> 20:44.660
这个内形别名有个翻型 这个翻型默认只是空对象

20:44.660 --> 20:48.660
其实我们现在已经给它传了一个范围了 传了这么个内形了

20:48.660 --> 20:52.660
那么接下来 它这个内形别名用的是啥呢

20:52.660 --> 20:55.660
其实内形别名用的就是方形component

20:55.660 --> 20:58.660
因此这里其实是可以直接使用这个东西

20:58.660 --> 21:02.660
方形component 把它导入间就完事了

21:02.660 --> 21:06.660
是完全一样的 因为刚才那个东西FC

21:06.660 --> 21:09.660
其实就是一个别名而已 就是个别名

21:09.660 --> 21:13.660
它本质上就是个接口 那么这个接口里面有什么东西呢

21:13.660 --> 21:16.660
首先它说是一个函数 看了没 它说是一个函数

21:16.660 --> 21:20.660
你第一个参数 必须要有一个参数 这个参数是函数的属性

21:20.660 --> 21:23.660
是一个属性 其次呢 你要

21:23.660 --> 21:27.660
第二个参数是可选的Countex 就是Ragson里面的姿势

21:27.660 --> 21:30.660
叫做上下文 对吧 平时我们不怎么会用的

21:30.660 --> 21:33.660
然后下边的这个函数呢 还会带来一些可选的属性

21:33.660 --> 21:36.660
你看这可选的属性 属属些 对吧

21:36.660 --> 21:40.660
这个是属性的内形约束 我们以前的做法

21:40.660 --> 21:44.660
还有这个DefaultProps 这是函数的一个属性

21:44.660 --> 21:47.660
因此呢 你要做智能提示的话

21:47.660 --> 21:51.660
你需要给这个函数呢 用这种方式来进行约束

21:51.660 --> 21:55.660
约束之后 这里我们再打一下

21:55.660 --> 22:00.660
BoardComp.DefaultProps

22:00.660 --> 22:02.660
你看 可以打出来了 它就有提示了

22:02.660 --> 22:06.660
并且这边的东西 跟这边是对应的 是对应的

22:06.660 --> 22:10.660
好 我们再写一下 然后你刚写个A 这样的复制行吗

22:10.660 --> 22:13.660
不行 因为它没有这些属性 没有A这个属性

22:13.660 --> 22:16.660
你给它复制默认字干嘛呢 它没有这个属性

22:16.660 --> 22:18.660
它有什么属性呢 有一个GameOver这个属性

22:18.660 --> 22:22.660
你可以给它复制为默认字Force

22:22.660 --> 22:26.660
可以通过这种方式来完成默认字的复制

22:26.660 --> 22:30.660
再说一次啊 第一步你把这个约束这里

22:30.660 --> 22:33.660
属性设为可选 为什么可以可选

22:33.660 --> 22:35.660
它有默认字吗 你可以不传递

22:35.660 --> 22:37.660
否则的话 还会要求你必须要传递

22:37.660 --> 22:42.660
第二个呢 你在下面用以前的做法给它设置默认字

22:42.660 --> 22:45.660
目前它其实有很多种方式的 这是其中一种方式

22:45.660 --> 22:50.660
这种方式呢 总之不论你用哪种方式 你都得写这么一个代嘛

22:50.660 --> 22:53.660
用以前的老的方式给它写上默认字

22:53.660 --> 22:55.660
因为接口里面是不能写默认字的

22:55.660 --> 23:00.660
好 然后呢 其实这里其实也就没啥了

23:00.660 --> 23:02.660
就是有的同学呢 可能觉得

23:02.660 --> 23:06.660
我想把这个默认字复制完成之后再导出行不行

23:06.660 --> 23:09.660
我不知道一开始有导出 可以 没问题

23:09.660 --> 23:12.660
那么你可以到时候在这里 这个位置 下面这个位置呢

23:12.660 --> 23:14.660
进行导出board camp

23:14.660 --> 23:16.660
但是你这样导出的时候注意一下

23:16.660 --> 23:19.660
因为export ES6的标准里边

23:19.660 --> 23:22.660
它是要导出啥 导出一个声明的 对吧

23:22.660 --> 23:25.660
导出一个变量声明 或者是导出一个函数声明

23:25.660 --> 23:27.660
而你这里根本就不是一个声明 是一个变量

23:27.660 --> 23:29.660
如果你要导出一个变量的话

23:29.660 --> 23:32.660
那么你需要把这个变量和8个号扩起来

23:32.660 --> 23:36.660
这是其实是ES6的姿势 跟TS没有什么关系

23:36.660 --> 23:39.660
好 那么现在呢 我就设置了默认字了

23:39.660 --> 23:44.660
那这边 你看 我不该进行传递的話

23:44.660 --> 23:50.660
那么刷新一下 它默认表示游戏没有结束

23:50.660 --> 23:53.660
你看 它会出发事件的 它就使用的是默认字

23:53.660 --> 23:55.660
好 其实这里还有一个小细节

23:55.660 --> 23:58.660
我都讲到这来了 我肯定要把它讲完

23:58.660 --> 24:02.660
还有一个小细节 就是大家再看一下这个属性里边

24:02.660 --> 24:05.660
这个 is game over 它现在是啥类型

24:05.660 --> 24:10.660
它变成了不而 或者是 undefined

24:10.660 --> 24:14.660
但是实际情况了 想想实际情况

24:14.660 --> 24:19.660
实际情况上下这个属性 有没有可能是 undefined

24:19.660 --> 24:22.660
有没有可能是 undefined

24:22.660 --> 24:24.660
所以不太可能 对不对

24:24.660 --> 24:26.660
这个属性是可选的

24:26.660 --> 24:28.660
不传递的时候呢 使用的是啥

24:28.660 --> 24:31.660
不传递的时候使用的是默认字

24:31.660 --> 24:33.660
使用的是默认字 force

24:33.660 --> 24:37.660
那你传递到过后呢 使用的就是你传递的指处和 force

24:37.660 --> 24:40.660
因此呢 真实的情况下

24:40.660 --> 24:44.660
这个玩意实际上是不可能是 undefined

24:44.660 --> 24:45.660
不可能是 undefined

24:45.660 --> 24:49.660
但是它这里会提示你 它这个有可能是不而和 undefined

24:49.660 --> 24:51.660
如果涉及到一些运算的话

24:51.660 --> 24:53.660
就有可能会出问题

24:53.660 --> 24:55.660
当然这里不涉及到什么运算

24:55.660 --> 24:56.660
所以这里呢 无所谓

24:56.660 --> 24:58.660
但是如果你涉及到运算的话

24:58.660 --> 25:01.660
就有可能会出一些问题

25:01.660 --> 25:05.660
那如果我现在要手动的告诉他

25:05.660 --> 25:07.660
要告诉他 这个地方不可能是 undefined

25:07.660 --> 25:09.660
你放心吧 他永远不可能是 undefined

25:09.660 --> 25:11.660
因为我们是有不过认知的

25:11.660 --> 25:12.660
那怎么告诉他呢

25:12.660 --> 25:15.660
怎么把那个 undefined给我去掉呢

25:15.660 --> 25:16.660
去掉的方式呢

25:16.660 --> 25:20.660
可以用这种方式 用内情断言的方式

25:20.660 --> 25:22.660
然后上面我再订一个变量

25:22.660 --> 25:24.660
is game over

25:24.660 --> 25:27.660
这个变量呢 直接给他复制为

25:27.660 --> 25:30.660
复制为啥 props is game over

25:30.660 --> 25:33.660
然后对他进行内情断言不定

25:33.660 --> 25:35.660
在这里对他进行内情断言

25:35.660 --> 25:37.660
好 这里一看

25:37.660 --> 25:39.660
复制完了过后 他就是不定了

25:39.660 --> 25:41.660
那么后边我们就可以使用这个

25:41.660 --> 25:45.660
不可能带有 undefined的东西来进行判定

25:45.660 --> 25:48.660
然后这里复制一下

25:48.660 --> 25:51.660
我这个位置就可以使用他来进行内情判定了

25:51.660 --> 25:53.660
好 这是一种方式

25:53.660 --> 25:55.660
还有一种方式大家注意听

25:55.660 --> 25:56.660
还一种方式听好

25:56.660 --> 25:58.660
可以使用 这里是个新知识

25:58.660 --> 26:00.660
可以使用这种方式

26:00.660 --> 26:02.660
在后面加上一个感叹号

26:02.660 --> 26:04.660
也可以

26:04.660 --> 26:07.660
这种做法以后在具体的项目开发中还蛮常见的

26:07.660 --> 26:09.660
这个感叹号是啥意思呢

26:09.660 --> 26:11.660
你看 结果还是个不

26:11.660 --> 26:14.660
感叹号啥意思 我再记一下

26:14.660 --> 26:18.940
叫做非空断言

26:18.940 --> 26:19.940
他其实也是个断言

26:19.940 --> 26:21.940
只是一种简写 非空断言

26:21.940 --> 26:23.940
就是

26:23.940 --> 26:29.940
在数据之后加上一个感叹号

26:29.940 --> 26:31.940
英文的感叹号

26:31.940 --> 26:34.940
可以去掉

26:34.940 --> 26:37.940
它是高速ts

26:37.940 --> 26:39.940
去掉

26:39.940 --> 26:43.940
就是不用考虑该数据

26:43.940 --> 26:45.940
为空的情况

26:45.940 --> 26:47.940
就是这个数据里边

26:47.940 --> 26:48.940
它如果有一些内想

26:48.940 --> 26:50.940
这些内想里面包含了空的内想

26:50.940 --> 26:51.940
比方说now

26:51.940 --> 26:53.940
比方说undefend

26:53.940 --> 26:55.940
那么让ts把这种情况给我过滤掉

26:55.940 --> 26:57.940
不要去考虑这种情况

26:57.940 --> 26:59.940
就相当于是刚才第一种写法

26:59.940 --> 27:00.940
写了个us

27:00.940 --> 27:03.940
它里面是number和undefend

27:03.940 --> 27:05.940
写了个usnumber

27:05.940 --> 27:07.940
这种写法就跟这里是一样的

27:07.940 --> 27:09.940
加上个感叹号

27:09.940 --> 27:11.940
感叹号是一样的

27:11.940 --> 27:12.940
而不是number

27:12.940 --> 27:13.940
but

27:13.940 --> 27:14.940
那么就把它内想里面

27:14.940 --> 27:16.940
undefend给我去掉

27:16.940 --> 27:17.940
这样的复制完了过后

27:17.940 --> 27:18.940
你想这边

27:18.940 --> 27:20.940
它就只有一个布尔了

27:20.940 --> 27:21.940
它就没有undefend

27:21.940 --> 27:23.940
这是非空断言

27:23.940 --> 27:24.940
其实像这个东西

27:24.940 --> 27:25.940
在编译结果里边也没有

27:25.940 --> 27:28.940
它只是在ts内想检查的时候起作用

27:28.940 --> 27:29.940
就是有的时候

27:29.940 --> 27:30.940
面对一些特殊的情况

27:30.940 --> 27:32.940
我们非常清楚

27:32.940 --> 27:33.940
它不可能为空

27:33.940 --> 27:35.940
但是由于一些

27:35.940 --> 27:37.940
乱七八糟的原因

27:37.940 --> 27:38.940
它可能带了一个undefend

27:38.940 --> 27:39.940
比方说这里

27:39.940 --> 27:40.940
这种情况带了一个undefend

27:40.940 --> 27:41.940
那么我们可以通过

27:41.940 --> 27:43.940
这种方式把它去掉

27:43.940 --> 27:44.940
好

27:44.940 --> 27:45.940
这里就顺便加一个知识

27:45.940 --> 27:46.940
尽管我们这里

27:46.940 --> 27:49.940
可以不怕设置为默认值

27:49.940 --> 27:50.940
然后它必须传提

27:50.940 --> 27:52.940
但是我们把这个知识

27:52.940 --> 27:53.940
也讲给大家

27:54.940 --> 27:55.940
OK

27:55.940 --> 27:56.940
现在我们就做出了

27:56.940 --> 27:58.940
这么一个棋盘的

27:58.940 --> 27:59.940
这么一个组件

27:59.940 --> 28:01.940
有了这个棋盘组件之后

28:03.940 --> 28:04.940
等一下

28:04.940 --> 28:05.940
保存一下

28:06.940 --> 28:08.940
它为什么没有打印呢

28:09.940 --> 28:10.940
抓紧

28:11.940 --> 28:12.940
这里有问题

28:12.940 --> 28:13.940
它为什么没有打印

28:13.940 --> 28:14.940
这里没有加个感叹号

28:14.940 --> 28:15.940
对吧

28:16.940 --> 28:17.940
没有结束的时候

28:17.940 --> 28:19.940
游戏没有结束的时候

28:19.940 --> 28:20.940
要出发时间

28:20.940 --> 28:21.940
它默认是没有结束的

28:22.940 --> 28:23.940
OK

28:23.940 --> 28:25.940
做出了这么一个棋盘对象

28:25.940 --> 28:26.940
那么接下来

28:26.940 --> 28:28.940
就剩最后一个东西了

28:28.940 --> 28:29.940
也是

28:29.940 --> 28:31.940
这个项目里边最复杂的一块

28:31.940 --> 28:32.940
就是整个游戏

28:32.940 --> 28:33.940
整个游戏

28:33.940 --> 28:34.940
OK

28:34.940 --> 28:36.940
我们先把棋盘对象做好

