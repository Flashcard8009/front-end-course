WEBVTT

00:00.880 --> 00:06.320
好 那么接下来呢 我们还是继续来使用啊 练习这个撲克牌

00:07.040 --> 00:12.000
加入这么个功能啊 就用内改造什么去

00:12.960 --> 00:22.160
嗯 这一次呢 我们的内容比较多 我们会给他增加一些功能 比方说洗牌比方说发牌啊 像这些功能呢 我们会给他增加进去

00:23.320 --> 00:28.400
好 这里呢 我要把什么东西变成内呢 我们看一下这里他的内行里边

00:28.880 --> 00:38.080
内行里边呢 我们之前啊 之前这里呢 使用的是deck一个内行别名来表示一副撲克牌啊 一叠牌

00:39.040 --> 00:41.520
那么我现在呢 我打算把这个deck

00:42.160 --> 00:44.560
做成一个内啊 把它做成一个内

00:45.280 --> 00:50.240
我干脆新建一个文件吧 新建一个文件 这里呢 我们建一个文件deck

00:51.760 --> 00:56.880
ts 啊 建这么一个文件 然后呢 这里就把删掉了啊 这里我就把删掉了

00:58.560 --> 01:04.560
这里 不要了 我们在这个文件里边来书写一个内啊 导出一个内

01:05.680 --> 01:06.080
class

01:06.640 --> 01:06.880
deck

01:07.760 --> 01:15.280
啊 这么一个内 我想把这一副撲克牌呢 里面保存了一个卡牌的数组 对吧 一副牌他有很多卡牌嘛

01:15.600 --> 01:24.240
而且呢 这个内里边呢 还提供了一些函数 比方说打印一副撲克牌 比方说洗牌 比方说发牌 我们都把它写到这个内里边

01:24.720 --> 01:26.160
在这个内里边来进行操作

01:26.880 --> 01:32.560
好 这个内里边呢 首先一个属性 把属性列表写出来 有什么属性呢 就是一个cart

01:33.280 --> 01:36.400
一副撲克牌 那么这个是一个数组 什么数组

01:36.960 --> 01:37.280
cut

01:37.920 --> 01:38.240
cut

01:38.720 --> 01:39.360
这么一个数组

01:40.160 --> 01:40.880
它是一个数组

01:41.760 --> 01:44.800
好 这个数组什么时候完成初始化呢

01:45.440 --> 01:52.640
我们可以把它写到构造函数里边 不需要你传过来啊 不需要你传给我 我直接把它完成初始化 因为一副撲克牌

01:52.800 --> 01:59.200
它的初始化工作是一样的啊 是一样的 就是52张牌 加上两个大小王 对不对

01:59.600 --> 02:07.840
那一副撲克牌一定是这样的格式 所以说不需要你给我传参数了啊 不需要你传参数 我直接让在这里完成对这个卡牌的初始化

02:08.320 --> 02:10.960
干脆我这里写个函数吧 写个函数

02:12.480 --> 02:12.960
init

02:13.600 --> 02:14.640
init这个函数

02:15.840 --> 02:22.240
这个函数呢 我就把之前这里的函数 函数 我把它复制过来

02:23.200 --> 02:26.000
然后稍微改一下代码 把它复制过来

02:26.640 --> 02:34.720
创建副撲克牌 把代码扔过来啊 扔过来 扔过来过后我们稍微改一下啊 首先数组的话 数组的话就在这

02:35.120 --> 02:38.800
cards有有这个数组了 所以说第一行不要了 第一行不要了

02:40.480 --> 02:44.400
然后这里 这里有内行把导入进来

02:45.360 --> 02:50.320
导入所谓的缺失的内行 得到每一句 得到每一句的自断值

02:50.880 --> 02:52.880
然后循环 循环的时候呢

02:53.520 --> 02:58.880
让this cards啊 this cards 当我们这个撲克牌啊 让我们这个撲克牌往里面

03:00.160 --> 03:05.200
添加一个一张一张的牌啊 像这个牌主力边添加一张一张的牌

03:05.600 --> 03:07.920
把普通牌添加进去 这是我们之前的代码

03:08.400 --> 03:11.920
然后再加两个大小王 这里把改成this cards

03:13.360 --> 03:16.400
这里也是啊 把它改成this cards

03:17.520 --> 03:22.960
最后不用返回了啊 不用返回了 因为现在呢 它已经是我们的属性了 已经放到属性里边了

03:23.120 --> 03:26.400
所以说你不用返回 你其实改变的就是这个属性 对吧

03:27.040 --> 03:29.840
这里一个小问题啊 大家注意一下 小细节 就是

03:30.800 --> 03:36.800
这个cards啊 它是个数组 这个数组现在是undefine啊 现在是undefine 没有对它进行初始化 对吧

03:37.120 --> 03:41.920
没有对它进行初始化的时候 它现在没有爆错 没有爆错是因为我还没有加这个配置

03:42.400 --> 03:44.400
好 其实这里还有很多配置是确实的 对吧

03:45.040 --> 03:48.960
strict property initialization

03:49.280 --> 03:53.360
把这为数 就是属性必须要初始化啊 那么现在它就爆错了

03:53.680 --> 03:57.600
爆错的话 我给它复制为一个默认值吧 给它复制为一个默认值

03:58.160 --> 04:02.160
ok ok 就完成了啊 那么现在呢 我给它调用一下这个函数

04:02.640 --> 04:10.080
引力值 初始化整幅卡牌 完成初始化 其实初始化这个工作需不需要让外面知道呢

04:10.640 --> 04:13.120
需不需要让外面知道 外面来调用初始化

04:13.840 --> 04:20.400
不不需要啊 不需要 初始化呢 我创建一副牌就已经初始化完成了啊 我只会调用一次

04:20.880 --> 04:27.440
创建一副牌的时候啊 就已经初始化完成了啊 你们买了一副喝牌 你看买的是一张完整的牌 对吧

04:27.600 --> 04:31.280
你不需要再返场重新初始化一次吧 重新硬刷一次吧 不需要吧

04:31.680 --> 04:36.320
所以说初始化这个工作呢 我不需要让外面知道 因此呢 我把它设为private

04:36.880 --> 04:42.160
外面不要理虚调用这个函数 我自己就把它完成了 你创建一副卡牌就已经完成了初始化了

04:42.960 --> 04:48.160
好 然后是打印 打印print 打印当前这一副撲克牌

04:48.800 --> 04:50.640
好 我们这里呢把之前的代码

04:51.600 --> 04:52.240
负责了

04:53.760 --> 04:54.320
好 打印

04:55.280 --> 04:58.560
其实就是把这里稍微改一下啊 改成cards 就完事了

04:59.360 --> 05:05.680
好 现在我们写好这么一个内 那以前这个funk这个文件就可以不要了啊 把删掉不要了

05:06.160 --> 05:12.720
好 index 里边呢 其实我现在要做啥呢 就是创建一副撲克牌 对不对

05:13.360 --> 05:14.720
const deck

05:16.560 --> 05:17.520
new deck

05:18.480 --> 05:26.800
创建一副撲克牌 然后把这副牌print 打印出来 打印出来就完事了 好 咱们来看一下啊

05:28.000 --> 05:30.400
np mnp m

05:33.520 --> 05:34.000
看一下

05:35.520 --> 05:39.280
打印出来了 当然它包含了大小网 包含了大小网

05:40.160 --> 05:43.840
好 打印出来了 过后呢 现在我们要给它添加一些功能

05:44.560 --> 05:52.400
在这副撲克牌里边 它除了有打印啊 除了有出使化之外呢 它还提供了一些使用的方法 比方说洗牌啊 洗牌

05:54.080 --> 06:01.200
好 ok 我们这里其实我觉得吧 这个东西都可以把它室友化啊 这个东西也不需要外面去调用啊

06:01.520 --> 06:06.560
如果他去外面调用的话 他也可能把这个重新复制啊 重新复制 所以说

06:07.120 --> 06:12.640
把它也室友化吧 我们也不需要用啊 不需要给外面用 到时候需要外面用的时候 我们再来考虑吧

06:13.600 --> 06:21.840
好 下面呢 我写这么一个函数叫swaffle swaffle 表示洗牌啊 这个函数的意思是洗牌

06:23.040 --> 06:29.600
什么洗牌呢 就是把这个数组啊 打乱这个数组的顺序啊 打乱这个数组的顺序

06:30.160 --> 06:37.760
那么怎么来完成洗牌呢 怎么来完成洗牌呢 这洗牌呢 有很多种算法啊 有很多种方式

06:38.160 --> 06:41.840
这里呢 我使用这么一种最简单的方式 假设有一个数组

06:42.800 --> 06:51.280
啊 我们一个数组 甭管这个数组连有什么 其实无所谓 只要我一个数组就行啊 这个数组呢 比方说是这么一个数组啊

06:52.400 --> 07:02.000
我们用这种来区分一下吧 3 4 5 6 7啊 有这么一些这个有各种不同数据的数组

07:02.720 --> 07:07.600
我怎么做呢 我数组一项一项拿出来 先把第一项拿出来

07:08.640 --> 07:17.600
然后随机生成一个数字 这个随机数的取之范围是0到这个数组的长度减1啊 是0到这个数组的长度减1

07:18.000 --> 07:24.400
随机生成一个下标 然后这个地方的纸跟随机生成的下标进行交换

07:25.440 --> 07:32.320
然后再循环到下一个下一个纸也是一样 从这个位置在在这个位置再重新生成一个下标 随机生成

07:33.520 --> 07:37.600
然后呢 把这个位置的纸呢 跟随机生成的下标进行交换

07:38.480 --> 07:45.920
所以说这里呢 我们需要用到一个随机数 在某一个范围之内来产生一个随机数 我们这里写这么一个辅助函数啊

07:46.400 --> 07:52.880
由于它是一个辅助函数 所以说我不太希望外边的人来调用 它只是为了实现洗牌过程

07:53.920 --> 07:57.280
创建了这么一个辅助的函数 好 把它设为private

07:58.160 --> 08:00.800
好 刚函数起个名字要是get

08:01.760 --> 08:02.080
red

08:09.070 --> 08:10.030
right 等

08:10.990 --> 08:12.270
right 等 是这样写吧

08:13.070 --> 08:13.550
right 等

08:15.070 --> 08:22.110
然后给他一个最小值number 最大值number 注意 这里我把它注明一下取不到最大值

08:24.030 --> 08:24.990
无法取到

08:26.190 --> 08:26.750
最大值

08:27.710 --> 08:34.910
好 有这么一个函数啊 在这个范围之内生成一个随机数 那么怎么生成的随机数 我生成的算法大家都知道啊

08:35.310 --> 08:41.630
先求一个差值最大值减去最小值 安全的减就行了 以后咱们写这些函数啊 不用去考虑

08:41.950 --> 08:49.630
哎 到底要不要传一个数字过来 有可能你传的是undefine 有可能你传的是nau 有可能你传的是一些制服创 要不要去判断一下

08:50.110 --> 08:53.390
不用了 不用了 现在有内形检查了 你不需要考虑这些问题了

08:54.030 --> 08:56.590
好 这里直接返回master floor

08:58.110 --> 09:03.550
然后 然后这里面是master written

09:04.190 --> 09:06.670
成义差值加上最小数

09:07.470 --> 09:12.190
ok 写这么一个随机帮助的函数啊 帮助我们来完成洗盘

09:12.750 --> 09:22.750
有了这个函数过后 我们现在来做什么 就是循环这个数组 对吧 循环他一项一项拿出来 每一循环一项生成一个随机数交换

09:23.550 --> 09:24.750
因此 这里写个副循环

09:25.870 --> 09:31.070
循环啥 循环 this cards 啊 循环 this cards 每一循环一项呢

09:32.030 --> 09:34.350
每一循环想做什么 生成一个随机数

09:36.590 --> 09:43.310
target index 就是我们要交换的目标 它的锁印 锁印在哪呢 雕用这个函数

09:44.190 --> 09:50.190
零 零到多少 零到这个数组的长度啊 因为他取不到最大值嘛 所以说到这个数组的长度

09:50.670 --> 09:51.230
Darnace

09:51.870 --> 09:54.750
啊 如果他能够取到最大值的话 那么就是长度减1

09:55.310 --> 09:58.670
总之在这个范围之内 生成一个随机数 这就是目标的锁印

09:58.990 --> 10:02.110
这是我们当前的锁印 这是目标的锁印 那么两个

10:02.670 --> 10:07.710
地方的值要进行交换 不是锁印交换 是值交换啊 交换它的值

10:08.270 --> 10:12.110
那么怎么交换呢 就是交换的方式大家都知道 对吧

10:13.390 --> 10:14.910
const temp

10:15.630 --> 10:16.110
啊 先

10:16.510 --> 10:21.310
第一个变量啊 这个变量呢 先保存一下this cards 的这个i

10:22.030 --> 10:29.310
然后呢 再把this cards 这个i 给它复制为this cards的 target index

10:30.110 --> 10:30.990
然后呢 再把

10:33.470 --> 10:37.950
this cards target index 给它复制为

10:39.790 --> 10:40.670
给它复制为temp

10:41.550 --> 10:49.230
通过这种方式来完成洗牌 完成洗牌 好 咱们来看一下啊 有了这个洗牌函数过后 咱们在这里测试一下

10:50.190 --> 10:55.870
创建一副牌 然后先洗牌 先洗牌 洗完牌过后呢 再打印

10:56.750 --> 10:57.550
保存看一下

10:59.150 --> 11:04.430
啊 洗完牌过后就打印了啊 那么现在这个牌的顺序呢 就乱了啊 就乱了 咱们再保存一次啊

11:04.990 --> 11:07.710
看一下重新洗牌过后 每次的都不一样

11:08.350 --> 11:14.670
嗯 这里为什么没对齐啊 其实我研究了半天 他这里为什么没对齐 其实这个问题是个小问题啊 大家不用去纠结啊

11:14.990 --> 11:21.070
是因为这里的制服的问题啊 制服的问题 制服在控制台上的站位导致的影响到了这个

11:22.350 --> 11:29.150
导致的最终导致的这个问题 如果都是用这个制服的话 它站位是对齐的 但是如果你使用了这个制服过后

11:29.390 --> 11:34.830
又加了一些普通的这个制服 它会导致问题啊 具体的原因呢 也不知道为什么

11:35.470 --> 11:43.230
肯定是这个制服的问题 这个制服的有力扩的码的问题啊 这个不用去纠结 不用去纠结 总之他有点不对齐 没关系啊

11:44.830 --> 11:51.630
好 这里洗牌过后 把打印打印出来 好 洗牌函数就完成了 那么现在咱们再来做一个函数

11:53.390 --> 11:58.510
再来做一个函数 叫发牌 发牌 发牌的话

12:00.590 --> 12:04.590
发牌跟怎么说 发牌 嗯 怎么说

12:06.190 --> 12:12.030
我也想不出来怎么当次了 发牌 发牌呢 比方说咱们是一个斗地主啊 一个斗地主

12:12.590 --> 12:19.710
斗地主发牌的话 想一想这个发发完牌 返回的结果应该是什么 这个函数肯定要有返回结果的

12:20.430 --> 12:25.870
把咱们这副牌啊 把咱们 这是我们的牌 这是我们一叠牌 还有54张

12:26.590 --> 12:34.190
然后发完牌过后 这里面是不是还剩三张 对不对 这里面还剩三张啊 或者说我们直接这里面就啥都不剩的 我们直接把它放到

12:34.910 --> 12:39.070
四个 四个数组里边去啊 四个数组里边去

12:39.630 --> 12:44.190
因此我们发完牌过后呢 我们可以这样子来分析一下 发完牌后

12:45.390 --> 12:46.350
发完牌后

12:47.150 --> 12:51.870
得到的结果 得到的结果是啥呢 得到的结果有

12:54.290 --> 12:58.370
四个数组啊 什么数组 有四个card的数组

12:59.170 --> 13:00.610
啊 有四个card的数组

13:01.410 --> 13:04.530
发完牌过后得到了结果有四个card的数组

13:05.090 --> 13:09.650
那么哪四个呢 你看斗地主说三家 三家每家17张

13:10.210 --> 13:15.570
然后呢 最后是不是还有三张啊 每家17张是每个17张是一个数组吗

13:16.130 --> 13:19.490
然后最后呢 还有三张又是一个数组 所以说结果呢

13:19.970 --> 13:23.490
有四个card的数组啊 有四个card的数组

13:24.050 --> 13:28.930
因此呢 这个发完牌之后啊 发完牌之后这个应该返回什么类型呢

13:29.250 --> 13:33.650
返回的是四 返回的是一个四个card的数组

13:34.290 --> 13:38.050
四个啥啥啥 多读几遍

13:38.530 --> 13:41.970
那么它是个什么类型 它也是一个数组

13:42.770 --> 13:46.370
这个数组有几项 有几项呢 是不是有四项

13:46.850 --> 13:50.210
对不对 有四项啊 数组有四项

13:51.170 --> 13:56.210
那么其实呢 数组的每一项是个啥呢 每一项是个card的数组

13:56.930 --> 13:59.410
每一项是个card的数组 我们可以这样子写

14:00.050 --> 14:02.130
给大家理一下啊 理一下这个思维

14:03.090 --> 14:04.930
card card

14:06.210 --> 14:11.170
啊 理一下这个思维啊 我们这里使用的是什么 使用的其实是圆组

14:11.330 --> 14:14.850
对不对 使用的是圆组 圆组就可以限定

14:15.410 --> 14:19.650
数组有几项 数组有四项啊 比方说先写简单的吧

14:20.610 --> 14:23.010
这样子你看不懂的话 先写简单的 这不算

14:23.970 --> 14:25.730
这不算啊 这个能看懂吗

14:26.370 --> 14:31.330
这是什么 这是我们以前讲的圆组啊 以前讲的圆组

14:31.730 --> 14:35.810
圆组呢 就是这样子写的 数组里面有四项 每项是个字不算

14:36.050 --> 14:39.650
那么现在是数组里面有四项 每项是一个card的数组

14:40.130 --> 14:41.810
每项是一个card的数组

14:42.450 --> 14:45.170
那么就通过这种方式啊 这是我们的返回的结果

14:45.570 --> 14:47.650
返回的结果 也就是分牌的结果

14:48.050 --> 14:51.330
当然呢 你可不可以把这个东西也做成一个类呢

14:51.650 --> 14:53.330
当然可以啊 当然可以

14:53.650 --> 14:56.450
其实按你说的话 这个东西也可以把它做成一个类

14:56.690 --> 14:59.010
这个类里面有四个属性 分别表示

14:59.650 --> 15:02.530
第一个玩家的牌 第二个玩家的牌 第三个玩家的牌 以及

15:02.930 --> 15:04.930
生语的牌 有这么四个属性

15:05.490 --> 15:09.010
这里呢 我要简单啊 就用这种方式 返回的是这种圆组

15:09.730 --> 15:13.170
使用了ts过后呢 这种类型要能看得懂啊 要能看得懂

15:14.130 --> 15:18.290
好 首先呢 为了得到这个结果啊 我首先创建这么一个

15:18.850 --> 15:20.690
数组 创建这么一个数组

15:21.250 --> 15:21.810
result

15:23.170 --> 15:25.010
啊 这个数组里边呢

15:26.290 --> 15:27.570
这个result就是这个类型

15:28.370 --> 15:30.450
这个result就把它限制为这个类型

15:31.730 --> 15:33.970
好 给它复制 我们换一行给它复制

15:34.690 --> 15:35.650
复制的时候呢

15:36.210 --> 15:41.730
数组有四项啊 这四项第一项是个空数组 第二项是个空数组 能理解吗

15:42.450 --> 15:43.010
能理解吗

15:43.970 --> 15:48.530
整个是一个数组 数组里面每一项是一叠牌

15:49.090 --> 15:50.370
每一项是一叠牌

15:50.930 --> 15:52.130
每一项是一叠牌

15:52.370 --> 15:53.250
每一项是一叠牌

15:53.730 --> 15:56.930
好 那么这个数组里面就有四项 每一项是一个数组

15:57.730 --> 15:59.410
好 写到这呢 有些同学可能觉得

16:00.050 --> 16:02.130
哎呀 怎么这么复杂呀 怎么这么绕啊

16:02.930 --> 16:03.970
其实咱们代码

16:04.370 --> 16:07.970
如果你写到这种格式的话 你写出来这种格式的话

16:08.450 --> 16:10.610
如果你还能理解的话 你已经非常不错了

16:11.010 --> 16:13.970
但是如果你不理解是非常非常正常的

16:14.210 --> 16:15.810
说实话 这个代码我看着老火

16:16.370 --> 16:17.250
我看着也老火

16:18.210 --> 16:22.770
因此呢 这里呢 你得好好想一想 有没有什么更优雅的写法呢

16:23.570 --> 16:25.650
有没有什么更优雅的写法呢

16:25.890 --> 16:26.770
想一想这个道理

16:27.570 --> 16:28.290
大家看一下

16:29.170 --> 16:32.050
一副牌卡的的数组啊

16:32.930 --> 16:34.850
卡的的数组本质上是什么

16:35.810 --> 16:37.330
本质上是不是就是一叠牌

16:38.130 --> 16:39.570
而一叠牌是什么

16:40.690 --> 16:44.290
一叠牌是不是deck 是不是这个玩意啊

16:44.930 --> 16:46.210
一叠牌嘛 就是deck呀

16:46.450 --> 16:47.730
deck就是一叠牌的意思啊

16:48.770 --> 16:52.210
所以说 我们这里每一项应该是一个啥呢

16:52.770 --> 16:55.010
什么最好了 应该是一个deck

16:56.370 --> 16:57.170
这是最好的

16:58.290 --> 16:59.410
每一项是一个deck

17:00.210 --> 17:01.250
每一项是一个deck

17:03.170 --> 17:05.650
这样子能不能符合 我是不是符合逻辑的

17:05.650 --> 17:06.210
大家想一想

17:06.530 --> 17:07.250
这符合逻辑的

17:07.890 --> 17:09.250
卡的的数组就是一叠牌

17:09.410 --> 17:11.010
而deck呢就表示的是一叠牌

17:11.010 --> 17:12.450
它里面还提供了一些洗牌

17:12.450 --> 17:14.690
比方说我拿到牌过后 我把自己的牌洗一洗

17:14.690 --> 17:16.130
可不可以 可以 没问题

17:16.450 --> 17:17.650
我可以把自己的牌

17:18.050 --> 17:19.410
把这个17张牌输出

17:19.410 --> 17:20.690
可不可以 没问题

17:21.090 --> 17:22.850
所以说它本质上就是一叠牌

17:22.850 --> 17:24.530
因此呢 这里我们可以使用deck

17:25.250 --> 17:27.650
但是使用deck的时候呢 出了一个问题

17:28.050 --> 17:30.450
就是deck它的构造函数呢 没有参数

17:31.010 --> 17:31.970
它没有参数的

17:32.370 --> 17:33.730
创建的时候

17:34.290 --> 17:36.130
创建这个构造函数的时候

17:36.130 --> 17:38.290
它直接初始化为54张牌了

17:38.690 --> 17:39.650
直接这样子处理了

17:40.370 --> 17:41.970
因此呢 它的构造函数呢

17:41.970 --> 17:43.650
我们这里可以改造一下

17:44.050 --> 17:44.850
改造一下

17:45.410 --> 17:47.730
你给我传一个card的数组进来

17:48.290 --> 17:49.250
给我传一个进来

17:50.610 --> 17:52.690
如果这个是可选的参数

17:54.290 --> 17:55.330
这个是card的数组

17:56.370 --> 17:58.530
如果你没有传递这个参数

17:59.570 --> 18:01.410
如果你传递了这个参数 我怎么办

18:01.730 --> 18:03.650
就是说明这个牌是你创建的

18:03.650 --> 18:05.330
是你给我的一些一些牌

18:05.330 --> 18:07.250
OK 那么我完成复制就完成了

18:07.730 --> 18:09.570
如果你给了我这个参数 我完成复制

18:10.610 --> 18:12.690
如果你没有给我这个参数

18:12.690 --> 18:14.130
我在进行初始化

18:14.370 --> 18:15.730
我们把它写成这种格式

18:17.010 --> 18:18.130
把它写成这种格式

18:18.770 --> 18:20.850
好吗 好了 那么这个这副牌呢

18:20.850 --> 18:22.130
就更加灵活了

18:22.130 --> 18:24.130
它可以不是自己初始化的

18:24.530 --> 18:25.970
可以是别人完成创建的

18:26.530 --> 18:27.410
两者都可以

18:27.410 --> 18:30.050
你传参数就表示我来创建了

18:30.050 --> 18:31.170
给你一副牌

18:31.170 --> 18:33.490
如果你不传参数 我就是自己初始化了

18:34.210 --> 18:35.410
好 我们再回到这里

18:36.370 --> 18:37.890
这里我要返回的是什么呢

18:37.890 --> 18:39.570
我要返回的是视碟牌

18:40.130 --> 18:41.970
视碟牌 这样看上去就舒服多了

18:42.610 --> 18:43.570
都抵辱吗

18:43.570 --> 18:45.970
一共肯定要分出来视碟牌嘛 对不对

18:45.970 --> 18:47.810
每一碟牌是什么东西呢

18:47.810 --> 18:51.890
就是每一碟牌我们先这样子

18:53.250 --> 18:55.570
先不着急复制 这一块也不要

18:56.290 --> 18:59.650
我们最终是要创建那么四个对象

18:59.650 --> 19:01.650
对不对 创建那么四个对象

19:01.650 --> 19:03.570
然后把这个四个对象扔到数组里面

19:03.570 --> 19:04.370
返回就完事了

19:05.090 --> 19:06.690
那么哪四个对象 我们先写出来

19:07.330 --> 19:09.410
第一个对象 Player 1

19:10.290 --> 19:13.010
Player 1 第一个玩家的是不是一副牌

19:13.010 --> 19:14.290
对不对 一副牌嘛

19:15.170 --> 19:17.490
然后一次来写 我们就直接这样子写

19:18.050 --> 19:24.290
Player 2 Deck 一副牌 Player 3 Deck 一副牌

19:24.290 --> 19:28.930
然后呢 剩下的 Left 剩下的桌子上的牌

19:28.930 --> 19:31.090
一副牌 一共就这么四个

19:31.090 --> 19:33.570
最后呢 我把这四个东西扔进去

19:33.650 --> 19:37.810
Player 1 Player 2 Player 3

19:39.570 --> 19:40.930
然后 Left 桌上的牌

19:41.650 --> 19:43.730
返回这个圆柱 返回这个圆柱就完事了

19:44.530 --> 19:45.810
现在呢 它爆错了

19:45.810 --> 19:47.490
因为这些东西都还没有复制

19:47.490 --> 19:48.450
都还没有复制

19:48.450 --> 19:49.490
所以它爆错了 没关系

19:50.050 --> 19:51.330
我们现在一次给它们复制

19:51.970 --> 19:52.770
怎么复制呢

19:53.810 --> 19:54.450
怎么复制

19:55.330 --> 19:56.370
这里还不简单嘛

19:57.650 --> 20:00.450
第一个玩家先摸17张嘛

20:00.450 --> 20:01.170
对不对

20:01.170 --> 20:02.370
先摸个17张

20:03.090 --> 20:05.730
把前面17张的牌给第一个玩家

20:05.730 --> 20:06.690
然后再有

20:06.690 --> 20:08.290
第二个玩家再摸17张

20:08.290 --> 20:10.130
第三个玩家再摸17张

20:10.130 --> 20:12.690
剩下的牌是不是就是桌上的牌了

20:13.250 --> 20:15.890
因此呢 这里我可以写一个辅助的函数

20:16.930 --> 20:18.370
你只该取个名字叫 Take

20:19.090 --> 20:19.730
Take Card

20:20.210 --> 20:22.050
从这一落牌里边

20:22.050 --> 20:23.890
从当前这一落牌里边

20:25.090 --> 20:27.810
然后来进行摸

20:27.810 --> 20:29.010
从上面进行摸

20:29.010 --> 20:30.690
摸多好张 给我一个参数

20:31.410 --> 20:31.810
Number

20:33.330 --> 20:33.970
或者是N

20:36.450 --> 20:38.850
好 这是我要取的张数

20:38.850 --> 20:40.210
返回的是什么呢

20:40.210 --> 20:41.810
返回的是一副牌

20:42.850 --> 20:43.490
一副牌

20:44.050 --> 20:45.570
大家可能这里不要晕

20:45.570 --> 20:48.130
不要认为这个内里面怎么还能使用这个内

20:48.130 --> 20:49.570
不要去想这些问题

20:49.570 --> 20:50.450
不要想这个问题

20:50.450 --> 20:52.690
你就想这个符不符合逻辑就行了

20:52.690 --> 20:53.730
是不是符合逻辑的

20:54.370 --> 20:55.410
我这是一副牌

20:55.970 --> 20:57.250
我摸了17张

20:57.250 --> 20:58.610
是不是得到另一副牌了

20:58.610 --> 20:59.010
对不对

20:59.010 --> 21:00.530
它是符合逻辑的就行了

21:01.170 --> 21:02.530
好 这里有个数字

21:02.530 --> 21:03.730
表示我要摸多少张

21:04.290 --> 21:05.010
怎么摸呢

21:05.810 --> 21:06.370
怎么摸

21:06.930 --> 21:09.650
数组里边不是有一个什么函数

21:10.770 --> 21:13.170
叫做Unshift

21:13.170 --> 21:13.890
对吧

21:13.890 --> 21:14.290
不是

21:14.930 --> 21:16.610
应该是shift

21:18.450 --> 21:21.330
移除掉数组的第一项

21:22.050 --> 21:24.210
从一个数组中移除掉第一项

21:24.210 --> 21:25.810
然后返回这个第一项

21:26.370 --> 21:27.810
返回这个第一项

21:27.810 --> 21:28.690
明白这个意思吗

21:29.250 --> 21:31.250
移除掉数组的第一项

21:31.250 --> 21:32.850
然后返回这个第一项

21:33.330 --> 21:34.690
就是shift这个函数

21:35.250 --> 21:36.370
所以说这里怎么弄

21:37.330 --> 21:37.970
把它删掉

21:38.610 --> 21:40.130
我先建一个数组

21:40.690 --> 21:41.250
Cards

21:42.610 --> 21:43.970
它是一个Card的数组

21:45.970 --> 21:47.170
默认是一个空数组

21:47.890 --> 21:50.370
然后我循环循环多少次

21:50.850 --> 21:52.770
这个N是多少我就循环多少次

21:52.770 --> 21:54.050
你要摸几张吗

21:54.050 --> 21:55.650
你要摸几张我就循环多少次

21:56.850 --> 22:00.290
每一次循环往这个数组里面加一项

22:00.690 --> 22:01.410
加什么呢

22:02.290 --> 22:06.130
把当前我的牌里边东西拿出来shift

22:07.890 --> 22:09.410
这里它为什么要爆错呢

22:09.970 --> 22:11.410
大家只能给函数看一下

22:11.410 --> 22:12.290
它为什么爆错

22:12.770 --> 22:15.410
因为它返回的结果有可能是一个Card

22:15.730 --> 22:17.010
有可能是Nd犯

22:17.010 --> 22:17.730
大家想一想

22:18.130 --> 22:19.490
它为什么有可能是Nd犯

22:20.370 --> 22:21.810
它为什么有可能是Nd犯

22:22.770 --> 22:24.850
我从那个数组里面移除第一项

22:24.850 --> 22:25.730
第一项的结果

22:25.730 --> 22:26.850
它有怎么可能是Nd犯

22:26.850 --> 22:27.970
这是一个Card的数组

22:29.170 --> 22:30.690
什么情况它是Nd犯呢

22:32.130 --> 22:35.090
当这个数组里边已经没有任何内容的时候

22:35.090 --> 22:36.290
它是不是有可能是Nd犯

22:36.610 --> 22:37.010
对不对

22:37.490 --> 22:39.090
这个数组长度有0的时候

22:39.090 --> 22:40.130
你还能移除第一项吗

22:40.130 --> 22:40.850
它就是Nd犯

22:41.330 --> 22:42.690
但是我们清楚

22:42.690 --> 22:43.970
我们自己很清楚

22:43.970 --> 22:45.490
这里是我们内部的函数

22:45.490 --> 22:46.770
我不会去乱调用的

22:47.090 --> 22:48.130
因此这里怎么办

22:48.130 --> 22:49.570
使用内形断言

22:49.570 --> 22:50.290
告诉它

22:50.530 --> 22:52.050
你别怕不要担心

22:52.050 --> 22:53.730
我这里我知道在干什么

22:53.730 --> 22:55.650
你不用那么的严格

22:55.650 --> 22:57.170
我可以明确的告诉你

22:57.170 --> 22:58.130
这里一定是个Card

22:58.770 --> 22:59.410
一定是个Card

22:59.890 --> 23:01.250
因此进行内形断言

23:01.570 --> 23:02.290
内形断言

23:02.290 --> 23:03.330
解决这里的问题

23:03.810 --> 23:06.050
我从这里取出N章牌

23:06.050 --> 23:07.570
每一次循环

23:07.570 --> 23:08.690
我取出一章牌

23:08.690 --> 23:10.530
然后把这章牌加到这个数组里边

23:10.530 --> 23:11.890
返回的是什么呢

23:11.890 --> 23:13.890
返回新建一个Dec对象

23:13.890 --> 23:15.970
新建一副牌的对象

23:15.970 --> 23:17.410
把我们的Cards

23:17.410 --> 23:19.010
刚才的数组传进去

23:19.010 --> 23:20.690
新建一个对象

23:20.690 --> 23:22.530
把我们这个数组传进去

23:22.530 --> 23:24.290
而我们看这个勾到函数

23:24.290 --> 23:25.650
这勾到函数里边

23:25.650 --> 23:28.450
我只可以给它传一个数组进去

23:28.450 --> 23:30.210
可以给它传一个数组进去

23:30.370 --> 23:31.490
传的数组过后

23:31.490 --> 23:34.210
它就按照我们的数组来出示化一副牌

23:34.210 --> 23:36.050
而不是自己的出示化

23:36.050 --> 23:37.250
另外这意思

23:37.250 --> 23:38.050
好这里呢

23:38.050 --> 23:40.050
我们通过写了这么一个函数

23:40.050 --> 23:41.090
写了这么一个函数

23:41.090 --> 23:43.650
然后创建了一副牌

23:44.610 --> 23:46.210
这里就简单了

23:46.770 --> 23:47.730
Player1

23:48.370 --> 23:49.410
怎么办

23:49.410 --> 23:50.370
Z

23:50.370 --> 23:51.810
Tag

23:51.810 --> 23:53.250
TagCards

23:53.250 --> 23:54.450
TagCards

23:54.450 --> 23:56.050
然后17章

23:57.650 --> 23:59.650
玩家1拿17章

23:59.730 --> 24:02.130
玩家2拿17章

24:02.130 --> 24:04.530
玩家3再拿17章

24:04.530 --> 24:08.210
然后最后剩下三章

24:08.210 --> 24:09.810
剩下三章就是Left

24:09.810 --> 24:11.090
Left

24:11.090 --> 24:11.730
其实Left呢

24:11.730 --> 24:13.090
都可以不用调用这个函数了

24:13.090 --> 24:14.450
直接把剩下的牌

24:14.450 --> 24:16.850
直接把当前卡牌里面

24:16.850 --> 24:18.610
剩下的牌复制过去就行了

24:18.610 --> 24:19.490
ThisCards

24:19.490 --> 24:20.850
ThisCards复制过去

24:20.850 --> 24:22.610
当然要创建一个对象

24:22.610 --> 24:23.490
NewDec

24:23.490 --> 24:24.610
但也可以调用这个函数

24:24.610 --> 24:25.010
也无所谓

24:25.010 --> 24:25.810
把它取光嘛

24:25.810 --> 24:26.850
把它取完也行

24:28.450 --> 24:29.090
好

24:29.170 --> 24:31.650
就写了这么三

24:31.650 --> 24:32.770
四副牌

24:32.770 --> 24:33.810
创建了四副牌

24:33.810 --> 24:34.930
根据当前这一副牌

24:34.930 --> 24:36.130
把它分成了四副牌

24:36.130 --> 24:37.570
然后把这个数组返回

24:37.570 --> 24:39.090
返回就完成了

24:39.090 --> 24:39.490
当然了

24:39.490 --> 24:40.850
也可以用这种方式

24:40.850 --> 24:41.730
返回一个对象

24:41.730 --> 24:43.490
对象Player1是一副牌

24:43.490 --> 24:44.530
Player2是一副牌

24:44.530 --> 24:45.970
Player3也是一副牌

24:45.970 --> 24:47.010
Left是一副牌

24:47.010 --> 24:47.730
无所谓

24:47.730 --> 24:48.610
都行

24:48.610 --> 24:49.890
看你怎么去用

24:49.890 --> 24:50.210
都行

24:51.410 --> 24:52.530
那我们看一下对象吧

24:52.530 --> 24:53.650
我们多看一点吧

24:53.650 --> 24:55.010
对象有怎么写

24:55.010 --> 24:57.010
这里我可以订一个Interface

24:57.010 --> 24:58.290
可以订一个Interface

24:58.370 --> 24:59.090
表示呢

24:59.090 --> 25:00.850
我们分牌的结果

25:00.850 --> 25:01.650
publish

25:02.850 --> 25:04.210
publish result

25:04.210 --> 25:05.730
分牌的结果

25:05.730 --> 25:06.450
Player1

25:07.330 --> 25:07.970
Player1

25:09.650 --> 25:10.450
Player1

25:11.650 --> 25:13.010
Player1

25:13.010 --> 25:13.970
它是什么

25:13.970 --> 25:14.610
一副牌

25:15.650 --> 25:16.290
Player2

25:17.250 --> 25:17.570
二

25:18.130 --> 25:19.330
一副牌

25:19.330 --> 25:20.450
严格来说的话

25:20.450 --> 25:20.930
玩家

25:20.930 --> 25:21.970
它不应该是一副牌

25:21.970 --> 25:23.570
玩家怎么能是一副牌呢

25:23.570 --> 25:24.290
但是现在呢

25:24.290 --> 25:25.570
由于我们系统里边

25:25.570 --> 25:26.770
并不关心

25:26.850 --> 25:28.770
它的玩家姓名

25:28.770 --> 25:30.290
玩家目前的积分

25:30.290 --> 25:31.250
赢了多少钱

25:31.250 --> 25:32.290
不关心这些事情

25:32.290 --> 25:34.290
所以说就把它一副牌呗

25:34.290 --> 25:36.050
写这么一个接口

25:36.050 --> 25:37.170
然后这里呢

25:37.170 --> 25:37.970
返回的是咋呢

25:37.970 --> 25:39.890
我们可以用一个更加简积的表达方式

25:39.890 --> 25:40.530
返回一个接口

25:41.410 --> 25:43.330
publish result

25:43.330 --> 25:44.210
那么这里

25:44.210 --> 25:45.730
返回的就是一个对象

25:45.730 --> 25:46.690
返回一个对象

25:46.690 --> 25:47.330
对对象里面

25:47.330 --> 25:47.890
Player1

25:48.770 --> 25:49.330
Player2

25:50.930 --> 25:52.050
Player3

25:52.050 --> 25:53.090
然后还有Left

25:54.050 --> 25:54.530
晚上

25:54.530 --> 25:55.250
也一样的

25:55.250 --> 25:55.730
也一样的

25:55.810 --> 25:56.930
看你自己喜欢哪种鞋法

25:56.930 --> 25:58.130
刚才用的是圆组

25:58.130 --> 25:59.090
这里使用对象

25:59.090 --> 25:59.570
也秀

25:59.570 --> 26:00.130
也秀

26:01.810 --> 26:02.050
好

26:02.050 --> 26:03.730
然后到了银这个手里边

26:03.730 --> 26:04.450
现在呢

26:04.450 --> 26:05.730
先洗牌

26:05.730 --> 26:07.490
洗完牌过后了

26:07.490 --> 26:10.050
我们再打印一下牌吧

26:10.050 --> 26:10.770
打印一下牌

26:11.890 --> 26:12.930
这样子我们输出一下

26:17.660 --> 26:19.340
洗牌之后

26:20.700 --> 26:21.420
洗牌之后

26:22.540 --> 26:24.140
然后下面再输出

26:24.620 --> 26:25.420
下面是

26:26.700 --> 26:27.980
发牌之后

26:27.980 --> 26:29.260
发牌之前

26:29.260 --> 26:30.540
发牌之前呢

26:30.540 --> 26:31.820
我们通过

26:31.820 --> 26:33.100
deck

26:33.100 --> 26:34.380
publish

26:34.380 --> 26:35.660
来完成发牌

26:35.660 --> 26:36.940
都利如嘛

26:36.940 --> 26:38.220
完成发牌

26:38.220 --> 26:39.500
它返回一个什么呢

26:39.500 --> 26:40.780
返回一个result

26:40.780 --> 26:42.060
result

26:42.060 --> 26:43.340
返回一个这个东西

26:43.340 --> 26:44.380
好

26:44.380 --> 26:45.900
完成发牌之后

26:45.900 --> 26:47.180
咱们来看一下

26:47.180 --> 26:48.460
每个玩家

26:48.460 --> 26:49.740
以及桌面上

26:49.740 --> 26:51.020
有哪些东西

26:51.020 --> 26:52.300
发牌之后

26:52.300 --> 26:53.580
我们先输出

26:53.580 --> 26:54.860
先输出

26:54.860 --> 26:56.140
先输出

26:56.140 --> 26:58.700
玩家1

26:58.700 --> 26:59.980
玩家1

26:59.980 --> 27:01.020
玩家1

27:01.020 --> 27:02.540
玩家1的卡牌

27:02.540 --> 27:03.820
有哪些呢

27:03.820 --> 27:05.100
result

27:05.100 --> 27:06.380
player1

27:06.380 --> 27:07.660
就是玩家1

27:07.660 --> 27:08.940
print

27:08.940 --> 27:09.980
直接打印

27:09.980 --> 27:11.500
你看我们现在在重用

27:11.500 --> 27:12.540
deck

27:12.540 --> 27:13.820
它是一副牌

27:13.820 --> 27:15.100
这是一副牌

27:15.100 --> 27:16.620
那么牌里边一定有print

27:16.620 --> 27:17.900
打印出来

27:17.900 --> 27:19.180
同样道理

27:19.180 --> 27:20.460
玩家2

27:20.460 --> 27:21.740
玩家3

27:21.900 --> 27:22.860
玩家2

27:22.860 --> 27:23.660
玩家3

27:23.660 --> 27:24.860
player2

27:24.860 --> 27:27.100
player3

27:27.100 --> 27:27.580
好

27:27.580 --> 27:28.940
把三个玩家的牌打印出来

27:28.940 --> 27:30.540
最后打印桌面

27:30.540 --> 27:32.300
桌面

27:32.300 --> 27:33.260
桌面上

27:33.260 --> 27:35.100
就是nab

27:35.100 --> 27:37.020
或者desk也行

27:37.020 --> 27:40.220
好咱们来看一下最多的结果

27:40.220 --> 27:42.780
咱赢出来了看到没

27:42.780 --> 27:46.530
我们再保存一下重新来

27:46.530 --> 27:49.090
大家看一下

27:49.090 --> 27:50.290
洗牌之后

27:50.290 --> 27:51.810
它是乱的顺序对吧

27:51.810 --> 27:52.850
然后开始发牌

27:53.010 --> 27:55.410
你看这个顺序

27:55.410 --> 27:57.010
是不是第一个玩家拿了17张牌

27:57.010 --> 27:57.970
对不对

27:57.970 --> 27:59.250
没有作弊吧

27:59.250 --> 28:00.530
没有作弊

28:00.530 --> 28:01.810
第一个玩家拿了17张牌

28:01.810 --> 28:03.090
第一个玩家拿了17张牌

28:03.090 --> 28:04.130
第三个玩家也是一样

28:04.130 --> 28:06.930
桌面上还剩个682

28:06.930 --> 28:08.210
就完成了发牌

28:08.210 --> 28:09.970
整个程序呢

28:09.970 --> 28:10.770
其实

28:10.770 --> 28:13.090
不用内可不可以写

28:13.090 --> 28:13.730
当然可以

28:13.730 --> 28:14.850
没有任何问题

28:14.850 --> 28:16.130
我再次强调

28:16.130 --> 28:17.170
ts

28:17.170 --> 28:19.970
它并不是要来改变我们的开发方式

28:19.970 --> 28:21.010
开发方式不变

28:21.090 --> 28:24.450
你完全可以使用以前介绍的写法

28:24.450 --> 28:26.050
不是喜欢写函数吗

28:26.050 --> 28:27.410
那么你可以把这些东西

28:27.410 --> 28:28.450
全部写成函数

28:28.450 --> 28:30.290
你可以自己去试一下

28:30.290 --> 28:32.210
用存函数来写

28:32.210 --> 28:34.610
和用这种类的方式来写

28:34.610 --> 28:36.210
你的代码它有哪些区别

28:36.210 --> 28:37.810
你可以自己去试一下

28:37.810 --> 28:39.810
我用类的方式来书写的话

28:39.810 --> 28:41.090
你会发现

28:41.090 --> 28:43.010
很多代码是可以重用的

28:43.010 --> 28:44.690
而且有更加严格的显示

28:44.690 --> 28:45.650
你看这些函数

28:45.650 --> 28:47.410
外面是刁弄不到的

28:47.410 --> 28:48.210
我们把

28:48.290 --> 28:50.370
整个关于发牌

28:50.370 --> 28:51.250
洗牌

28:51.250 --> 28:52.610
分牌的功能

28:52.610 --> 28:54.690
全部包含在这个类里面

28:54.690 --> 28:56.770
它高度聚合了

28:56.770 --> 28:59.490
一个一副牌的所有功能

28:59.490 --> 29:01.170
我们可以通过这个对象

29:01.170 --> 29:03.170
来得到它的结果

29:03.170 --> 29:04.210
不仅如此

29:04.210 --> 29:05.810
我们还可以创建多副牌

29:05.810 --> 29:06.770
现在我们创建一副牌

29:06.770 --> 29:07.170
对吧

29:07.170 --> 29:08.130
咱们有五张桌子

29:08.130 --> 29:09.330
每张桌子都在我牌

29:09.330 --> 29:11.570
那么我创建这个五个对象就完事了

29:11.570 --> 29:12.450
创建五个对象

29:12.450 --> 29:15.170
做相同的操作就完事了

29:15.170 --> 29:16.690
它可以复制它的功能

29:16.770 --> 29:19.090
每个对象就具有它完整的功能

29:19.090 --> 29:21.090
你可以自己去体会一下

29:21.090 --> 29:24.210
我不想在这里说太多关于面向对象的东西

29:24.210 --> 29:27.170
这个程序有一点点复杂度了

29:27.170 --> 29:28.770
有那么一点点复杂度了

29:28.770 --> 29:33.170
大家下去可以多去看一下这一块代码

29:33.170 --> 29:34.690
多研究一下这块代码

29:34.690 --> 29:36.290
如果放在里来写的话

29:36.290 --> 29:38.210
你会怎么去书写这一块代码

29:38.210 --> 29:41.010
当然这里代码绝对不只一种书写方式

29:41.010 --> 29:41.970
我这里

29:41.970 --> 29:44.290
上课的时候只是给大家提供了

29:44.450 --> 29:47.570
我自己脑袋里面第一想法

29:47.570 --> 29:49.330
想到的是什么样的书写方式

29:49.330 --> 29:51.090
大家可以自行去尝试一下

29:51.090 --> 29:53.250
你会用什么样的方式来书写

29:53.250 --> 29:54.290
我再次重申

29:54.290 --> 29:55.490
TS

29:55.490 --> 29:58.130
它不是说一定要改变我们的开发方式

29:58.130 --> 30:00.690
你完全可以用之前的方式来开发

30:00.690 --> 30:03.570
并且它的类型系统也是可选的

30:03.570 --> 30:04.850
不是说你一定要用

30:04.850 --> 30:07.170
只不过我们在讲这个TS的时候了

30:07.170 --> 30:08.930
肯定要把这些类型系统用上去

30:10.370 --> 30:12.770
OK 其实咱们卡牌这个练习了

30:12.770 --> 30:13.970
就已经做了差不多了

30:14.130 --> 30:15.810
我们不会再往生了做了

30:15.810 --> 30:17.410
做到这就其实已经差不多了

30:17.410 --> 30:20.370
我们学习的TS技术部分

30:20.370 --> 30:22.130
也接近尾声了

30:22.130 --> 30:23.250
基本上接近尾声了

30:23.250 --> 30:25.570
还有那么一个小知识就是犯罪

30:25.570 --> 30:27.570
其实它也不算小知识的

30:27.570 --> 30:28.690
还是有点糟的

30:28.690 --> 30:30.130
这一块学习完了之后

30:30.130 --> 30:33.650
咱们就可以使用React来完成一个小练习了

30:33.650 --> 30:36.050
OK 这一块就到这里了

30:36.050 --> 30:37.010
拜拜

