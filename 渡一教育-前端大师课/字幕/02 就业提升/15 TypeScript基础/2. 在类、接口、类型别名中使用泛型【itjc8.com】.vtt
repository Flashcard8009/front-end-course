WEBVTT

00:00.750 --> 00:04.950
了解了范雄在函数里边如何去使用

00:04.950 --> 00:10.750
那么在接口和内雄别名以及内里边

00:10.750 --> 00:14.750
那么他们又是怎么去跟范雄进行配合的使用的呢

00:14.750 --> 00:18.550
那么这里来举个例子 首先看如何

00:18.550 --> 00:27.150
就是如何在内雄别名接口和内中使用范雄

00:28.150 --> 00:32.350
就也很简单的 直接在名称之后

00:32.350 --> 00:35.950
什么名称 内名称 接口名称

00:35.950 --> 00:40.150
或者是内雄别名的名称后边

00:40.150 --> 00:46.550
后写上 写上啥 写上这个东西

00:46.550 --> 00:49.550
一样的 没有什么本质的区别

00:49.550 --> 00:51.750
举个例子吧 比方说

00:51.750 --> 00:56.350
咱们之前写过这么一个东西

00:56.350 --> 01:01.550
大家还记得吗 type callback 回调函数

01:01.550 --> 01:05.550
来判断某个东西是否满足条件

01:05.550 --> 01:06.950
对吧 当时我们怎么写的

01:06.950 --> 01:10.150
当时我们是这样写的 传一个n进来

01:10.150 --> 01:12.750
number 输出里面某一个东西

01:12.750 --> 01:15.950
index i number

01:15.950 --> 01:19.150
然后返回的是啥呢 返回的是一个布尔

01:19.150 --> 01:21.550
对吧 当时我们写过这么一个东西

01:21.550 --> 01:23.150
还记得吗 总之

01:23.150 --> 01:24.550
但是如果不记得的话没关系

01:24.550 --> 01:29.950
总之我有这么一个内雄别名 callback

01:29.950 --> 01:32.550
这个内雄别名他要求是一个函数

01:32.550 --> 01:34.950
这个函数返回的是一个布尔

01:34.950 --> 01:36.150
他判断的是啥呢

01:36.150 --> 01:40.150
这是个回调函数

01:40.150 --> 01:47.150
他判断数组中的某一项是否满足条件

01:47.150 --> 01:48.550
这是他判断的东西

01:48.550 --> 01:51.550
数组里面某一项是否满足条件

01:51.550 --> 01:54.150
那么看一下你之前的这种写法

01:54.150 --> 01:56.950
是否具有通用性

01:56.950 --> 01:58.450
你会发现不太通用

01:58.450 --> 01:59.550
为啥呢

01:59.550 --> 02:01.750
因为你这个回调函数

02:01.750 --> 02:02.850
你这个玩意儿

02:02.850 --> 02:06.050
你只能适用于number 内型的输出

02:06.050 --> 02:07.150
对不对

02:07.150 --> 02:07.750
你看吗

02:07.750 --> 02:09.250
输出的每一项拿出来

02:09.250 --> 02:10.950
传给这个n n是number

02:10.950 --> 02:12.650
你凭什么知道他是number呢

02:12.650 --> 02:14.150
凭什么知道这个输出

02:14.150 --> 02:16.050
一定是number 内型的输出

02:16.050 --> 02:17.150
所以说你不一定知道的

02:17.150 --> 02:17.650
对吧

02:17.650 --> 02:18.950
你不一定知道的

02:18.950 --> 02:19.650
怎么办

02:19.650 --> 02:21.550
犯小犯小

02:21.550 --> 02:23.650
我们可以给这个type

02:23.650 --> 02:24.750
就是内型别名

02:24.750 --> 02:25.650
写个犯小t

02:26.950 --> 02:27.950
然后在这里呢

02:27.950 --> 02:29.750
给他加上t这个先子

02:29.750 --> 02:31.050
我管你是什么数组

02:31.050 --> 02:32.550
什么是内型的数组

02:32.550 --> 02:34.050
你只要把内型扔给我

02:34.050 --> 02:37.350
你每一项就是一个内型t

02:37.350 --> 02:39.050
你在使用内型的时候

02:39.050 --> 02:40.850
你自然会告诉我

02:40.850 --> 02:44.650
他相关的内型到底是什么

02:44.650 --> 02:44.950
OK

02:44.950 --> 02:47.550
那么现在我们就依托于这个

02:47.550 --> 02:49.050
来写这么一个函数

02:49.050 --> 02:49.950
比方说这个函数呢

02:49.950 --> 02:51.950
我们仿造filter

02:51.950 --> 02:53.950
仿造filter来写个函数

02:53.950 --> 02:55.550
你给我一个数组

02:55.550 --> 02:56.650
一个数组

02:56.650 --> 02:58.850
好这个数组什么内型

02:58.850 --> 02:59.550
写不出来

02:59.550 --> 03:00.250
这些写不出来

03:00.250 --> 03:01.350
不知道是什么内型的数组

03:01.350 --> 03:02.050
怎么办

03:02.050 --> 03:02.750
犯小

03:02.750 --> 03:05.350
像这种场景其实非常非常多

03:05.350 --> 03:06.550
非常非常多

03:06.550 --> 03:07.650
filter不知道什么内型

03:07.650 --> 03:08.650
于是写犯小

03:08.650 --> 03:09.750
于是写犯小

03:09.750 --> 03:09.950
好

03:09.950 --> 03:12.750
那么这里是一个这个内型的数组

03:12.750 --> 03:13.950
这个内型的数组

03:13.950 --> 03:14.250
好

03:14.250 --> 03:15.250
数组后边呢

03:15.250 --> 03:16.950
我们要传一个callback

03:16.950 --> 03:17.850
callback

03:17.850 --> 03:18.750
什么内型

03:18.750 --> 03:22.250
就是callback这个内型

03:22.250 --> 03:23.050
翻型加上

03:23.050 --> 03:24.150
翻型也是t

03:24.150 --> 03:24.750
你看

03:24.750 --> 03:26.550
这样子通过一步一步传递过来

03:26.550 --> 03:28.550
我们可以清楚的知道

03:28.550 --> 03:30.150
你这里过滤的时候

03:30.150 --> 03:31.650
过滤的是这个内型的数组

03:31.650 --> 03:33.050
于是你传的时候

03:33.050 --> 03:35.150
你就必须要传一个这个内型的数组

03:35.150 --> 03:37.050
并且你的回掉函数里面

03:37.050 --> 03:38.850
每一箱的内型的也是t

03:38.850 --> 03:41.950
你看就把这个信息传递出去了

03:41.950 --> 03:43.950
一层一层传递出去了

03:43.950 --> 03:45.850
这三个内型是一致的

03:45.850 --> 03:46.450
好

03:46.450 --> 03:47.750
反而或者是什么东西呢

03:47.850 --> 03:52.050
返回的是一个过滤之后的新数组

03:52.050 --> 03:53.250
我们来写一下啊

03:53.250 --> 03:54.250
写一下这个filter

03:54.250 --> 03:55.350
怎么写啊

03:55.350 --> 03:56.450
怎么写

03:56.450 --> 03:58.750
建立一个新数组呗

03:58.750 --> 03:59.650
建立一个新数组

03:59.650 --> 04:00.750
六二位

04:00.750 --> 04:02.050
什么内箱

04:02.050 --> 04:03.250
t的数组

04:03.250 --> 04:05.250
你看这信息就传递出去了

04:05.250 --> 04:05.450
好

04:05.450 --> 04:05.850
最后呢

04:05.850 --> 04:07.850
我们把这个六二位返回

04:07.850 --> 04:08.750
中间怎么弄的

04:08.750 --> 04:09.650
中间

04:09.650 --> 04:11.150
先循环这个数组

04:11.150 --> 04:12.250
拂一起

04:12.250 --> 04:13.850
循环

04:13.850 --> 04:15.450
每一箱拿出来

04:15.450 --> 04:16.250
n

04:16.250 --> 04:17.650
i

04:17.650 --> 04:18.650
拿出来

04:18.650 --> 04:20.150
拿出来之后呢

04:20.150 --> 04:22.750
我判断一下这个n是否满足条件

04:22.750 --> 04:25.050
如果callback

04:25.050 --> 04:25.950
啊

04:25.950 --> 04:26.550
callback

04:26.550 --> 04:27.550
把n传进去

04:27.550 --> 04:28.450
i传进去

04:28.450 --> 04:29.850
看一下是否满足条件

04:29.850 --> 04:31.450
如果满足条件的话

04:31.450 --> 04:33.050
往新数组里边

04:33.050 --> 04:34.650
push加一箱

04:34.650 --> 04:36.850
加一箱这个n

04:36.850 --> 04:38.550
最后把个新数组返回

04:38.550 --> 04:39.850
其实这就是

04:39.850 --> 04:41.350
s里边的一个filter

04:41.350 --> 04:42.150
他的写法

04:42.150 --> 04:43.850
无非就是这种写法

04:43.850 --> 04:44.050
好

04:44.050 --> 04:45.150
你看这个内形信息

04:45.150 --> 04:46.650
就一步一步传递出去了

04:46.650 --> 04:49.250
那么这个函数就可以适用于任何的

04:49.250 --> 04:49.950
数组

04:49.950 --> 04:50.850
比方说

04:50.850 --> 04:51.650
咱们有个数组

04:54.650 --> 04:55.350
二

04:55.350 --> 04:56.250
一个数组

04:56.250 --> 04:57.450
一个制服算数组吧

04:58.550 --> 05:00.250
或者是数字数组吧

05:00.250 --> 05:00.850
数字数组

05:02.950 --> 05:03.550
好

05:03.550 --> 05:04.950
然后我要得到这个数组

05:04.950 --> 05:06.150
所有的基数

05:07.350 --> 05:08.350
我们输出

05:08.350 --> 05:09.450
这个数组

05:09.450 --> 05:10.550
中所有的基数

05:10.550 --> 05:11.550
怎么来输出

05:11.550 --> 05:13.750
调用filter这个函数

05:13.750 --> 05:15.450
然后把数组传进去

05:15.450 --> 05:16.350
由于我传了

05:16.350 --> 05:17.750
一个number内形的数组

05:17.750 --> 05:18.550
于是他知道

05:18.550 --> 05:20.250
原来你这个地方是number

05:20.250 --> 05:21.450
你这个地方是number了

05:21.450 --> 05:22.850
那么callback也是number

05:22.850 --> 05:23.450
你看到没

05:23.450 --> 05:24.750
返回的结果也是number

05:24.750 --> 05:26.550
这个信息就一致了

05:26.550 --> 05:27.550
好

05:27.550 --> 05:28.750
第二个参数callback

05:28.750 --> 05:30.050
那么一定是一个函数

05:30.050 --> 05:30.350
对吧

05:30.350 --> 05:31.450
一定是一个函数

05:31.450 --> 05:33.550
我们判断一下 n

05:33.550 --> 05:35.950
n除以2的余数

05:35.950 --> 05:36.550
不等于0

05:36.550 --> 05:37.350
这就是基数吗

05:37.350 --> 05:37.950
对不对

05:37.950 --> 05:38.450
基数

05:38.450 --> 05:39.150
你看一下这个n

05:39.150 --> 05:40.150
他推断出来

05:40.150 --> 05:40.950
是number

05:40.950 --> 05:42.550
因为你这里的内形确定了

05:42.550 --> 05:44.250
就确定了这个函数的犯行

05:44.250 --> 05:45.450
这个函数的犯行确定了

05:45.450 --> 05:49.150
就确定了这个毁掉函数的犯行

05:49.150 --> 05:50.250
这个毁掉函数的犯行

05:50.250 --> 05:52.350
确定了就确定了这个函数的犯行

05:52.350 --> 05:54.150
你看一层一层就传递过去了

05:54.150 --> 05:56.050
这些所谓的信息就完整了

05:56.050 --> 05:56.250
好

05:56.250 --> 05:57.350
咱们保存一下

05:57.350 --> 05:58.450
看一下结果

05:58.450 --> 06:00.350
就得到了一个数字

06:00.350 --> 06:01.750
基数3

06:01.750 --> 06:01.950
好

06:01.950 --> 06:05.550
这是关于内形别名的犯行

06:05.550 --> 06:06.850
其实接口是一样的

06:06.850 --> 06:07.850
接口是一样的

06:07.850 --> 06:08.850
把它换成接口

06:08.850 --> 06:10.250
其他当然不动

06:10.250 --> 06:13.250
interface callback

06:13.250 --> 06:14.050
把它换成接口

06:15.050 --> 06:17.650
无非就是稍微改一下

06:17.650 --> 06:18.450
稍微改一下

06:20.450 --> 06:21.850
这里把它变成帽号

06:23.050 --> 06:24.250
做完事一样的

06:24.250 --> 06:24.750
一样的

06:24.750 --> 06:25.850
没有什么区别

06:25.850 --> 06:27.450
接口也可以使用方向

06:28.450 --> 06:28.750
好

06:28.750 --> 06:29.850
我们再看一个例子

06:29.850 --> 06:30.650
就是内

06:30.650 --> 06:31.450
就是内

06:32.450 --> 06:33.450
也是一样的

06:33.450 --> 06:35.850
其实没有什么独大的区别

06:35.850 --> 06:36.850
内这一块

06:36.850 --> 06:37.650
我们多讲一点

06:37.650 --> 06:39.850
因为大家平时开发的时候

06:39.850 --> 06:42.550
可能用内的场景比较少

06:42.650 --> 06:43.950
之前学GS的时候

06:43.950 --> 06:46.550
估计就在react里边使用了一些内

06:46.550 --> 06:48.350
平时自己开发代码的时候

06:48.350 --> 06:49.750
使用内的场景

06:49.750 --> 06:50.850
我估摸着

06:50.850 --> 06:51.550
我只能猜

06:51.550 --> 06:53.350
估摸了大家可能用的比较少

06:53.350 --> 06:55.050
平时用的都是函数

06:55.050 --> 06:55.950
或者是一个对象

06:55.950 --> 06:56.850
直接一个对象

06:56.850 --> 06:58.750
很少去自己去写一个内

06:58.750 --> 07:00.550
那么这里我们来练习一下内吧

07:01.750 --> 07:03.050
这里我们新建一个文件

07:03.050 --> 07:04.350
比方说

07:04.350 --> 07:05.050
举个例子

07:05.050 --> 07:09.050
就是array helper ts

07:09.050 --> 07:11.150
还是就这样写

07:11.150 --> 07:12.150
array helper

07:13.050 --> 07:14.150
写这么一个文件

07:14.150 --> 07:14.950
这个文件里面

07:14.950 --> 07:16.450
我们导出一个内

07:16.450 --> 07:18.950
class array helper

07:18.950 --> 07:20.950
是一个数组的帮助内

07:20.950 --> 07:22.950
是一个数组的帮助内

07:22.950 --> 07:25.350
这个帮助内里面要做什么事情呢

07:25.350 --> 07:27.550
可以提他提供了一些

07:27.550 --> 07:30.550
常见的对数组操作的函数

07:32.550 --> 07:34.050
比方说什么函数呢

07:34.050 --> 07:36.150
比方说我们之前写的take

07:36.150 --> 07:36.750
对吧

07:36.750 --> 07:37.950
take这个函数

07:37.950 --> 07:39.050
从这个数组

07:39.050 --> 07:40.350
当前的数组里面

07:40.350 --> 07:41.650
取出多少张

07:41.650 --> 07:42.650
取出多少

07:42.650 --> 07:46.050
取出多少项

07:46.050 --> 07:47.650
取出前面的多少项

07:47.650 --> 07:49.050
然后呢

07:49.050 --> 07:51.050
得到一个新的数组take

07:51.050 --> 07:52.150
take这个函数

07:52.150 --> 07:53.450
我们来看一下

07:53.450 --> 07:54.550
是不是要一个番形

07:54.550 --> 07:55.050
对不对

07:55.050 --> 07:56.550
我们之前写过的

07:56.550 --> 07:57.650
这里一个数组

07:57.650 --> 07:59.250
扔进来t

07:59.250 --> 08:00.050
扔进来

08:00.050 --> 08:01.250
然后取多少项

08:01.250 --> 08:02.250
取多少项

08:02.250 --> 08:03.850
取n项吧

08:03.850 --> 08:05.850
n number

08:05.850 --> 08:06.650
返回的是什么

08:06.650 --> 08:07.650
返回的是一个数组

08:07.650 --> 08:09.050
我直接把这个函数扔过来

08:10.050 --> 08:11.250
直接把这个函数扔过来

08:11.650 --> 08:13.050
之前咱们这样写的

08:14.250 --> 08:15.050
保存一下

08:15.050 --> 08:16.850
这个粘贴过来

08:16.850 --> 08:17.650
确实是一样的

08:17.650 --> 08:18.650
是一样的

08:18.650 --> 08:19.250
take

08:19.250 --> 08:20.250
再比方说

08:20.250 --> 08:21.250
这个数组里面

08:21.250 --> 08:22.050
还可以做什么呢

08:22.050 --> 08:23.450
还可以洗牌

08:24.250 --> 08:25.650
把这个数组的顺序

08:25.650 --> 08:26.850
随机排列

08:26.850 --> 08:27.650
随机排列

08:27.650 --> 08:29.250
当前数组的顺序

08:29.250 --> 08:30.450
其实这里的数组

08:30.450 --> 08:31.450
这个ar数组

08:31.450 --> 08:32.850
可以把它作为属性

08:32.850 --> 08:33.250
对吧

08:33.250 --> 08:34.150
以后再说吧

08:34.150 --> 08:35.650
可以把它作为属性

08:35.650 --> 08:35.950
好

08:35.950 --> 08:36.650
咱们来

08:37.650 --> 08:38.650
take

08:38.650 --> 08:39.050
好的

08:39.050 --> 08:39.650
刷否

08:40.650 --> 08:41.650
刷否

08:41.650 --> 08:42.650
是这样子

08:42.650 --> 08:43.250
这样子

08:43.250 --> 08:43.850
刷否

08:44.250 --> 08:45.050
洗牌

08:45.050 --> 08:46.250
洗牌的话

08:46.250 --> 08:48.150
你甭管是什么样的数组

08:48.150 --> 08:50.450
它的洗牌的方式都是一样的

08:50.450 --> 08:51.450
什么制服刷的数组

08:51.450 --> 08:52.250
可不可以洗牌

08:52.250 --> 08:53.450
可不可以打乱顺序

08:53.450 --> 08:54.350
可以

08:54.350 --> 08:55.250
数字数组

08:55.250 --> 08:56.450
可不可以打乱顺序

08:56.450 --> 08:57.250
可以

08:57.250 --> 08:59.650
还有对象的数组

08:59.650 --> 09:00.850
能不能打乱顺序

09:00.850 --> 09:03.450
就跟我们之前的谱歌牌

09:03.450 --> 09:05.050
那个练习是一样的

09:05.050 --> 09:05.450
对吧

09:05.450 --> 09:06.450
都可以打乱顺序

09:06.450 --> 09:07.050
因此

09:07.050 --> 09:08.850
数组每一项的类型

09:08.850 --> 09:09.650
传过来

09:09.650 --> 09:10.850
通过范形传过来

09:10.850 --> 09:12.050
甭管你是什么数组

09:12.050 --> 09:13.250
我都可以完成洗牌

09:13.250 --> 09:14.650
把数组给我吧

09:14.650 --> 09:15.350
给我

09:15.350 --> 09:17.050
我来帮你完成洗牌

09:17.050 --> 09:17.250
好

09:17.250 --> 09:18.150
洗牌怎么用

09:18.150 --> 09:18.850
怎么做的

09:18.850 --> 09:19.850
快速的再做一次

09:19.850 --> 09:21.250
快速的做一次

09:21.250 --> 09:22.450
当这里面

09:22.450 --> 09:24.650
我提供一个私有的方法

09:24.650 --> 09:25.250
私有的方法

09:25.250 --> 09:26.450
get riddle

09:26.450 --> 09:27.450
得到一个随机数

09:27.450 --> 09:28.950
马上快速的做一次

09:28.950 --> 09:31.450
number max number

09:31.450 --> 09:32.250
我这里就不讲了

09:32.250 --> 09:33.450
这个函数

09:33.450 --> 09:35.850
得到它们相简的结果

09:35.950 --> 09:37.150
相简的结果

09:37.150 --> 09:38.550
然后呢

09:38.550 --> 09:39.290
返回

09:39.290 --> 09:41.850
max their floor

09:41.850 --> 09:43.550
max their riddle

09:43.550 --> 09:46.450
乘以deck加上max

09:46.450 --> 09:47.050
好

09:47.050 --> 09:48.550
怎么洗牌呢

09:48.550 --> 09:50.050
就是我们之前做的

09:50.050 --> 09:51.350
之前做的方式

09:51.350 --> 09:53.150
循环

09:53.150 --> 09:54.150
循环

09:54.150 --> 09:54.850
循环啥

09:54.850 --> 09:56.150
循环这个数组

09:56.150 --> 09:57.350
循环这个数组

09:57.350 --> 09:58.250
每一次循环

09:58.250 --> 10:00.650
产生一个随机数

10:00.650 --> 10:02.950
target indexed

10:02.950 --> 10:04.350
通过this gets riddle

10:04.350 --> 10:05.450
得到一个随机数

10:05.450 --> 10:06.450
最小之为0

10:06.450 --> 10:07.650
最大值呢

10:07.650 --> 10:10.650
最大值就是个数组的长度

10:10.650 --> 10:12.450
ar-distance

10:12.450 --> 10:14.050
数的长度

10:14.050 --> 10:14.650
好

10:14.650 --> 10:16.850
然后得到这个目标的锁印过后

10:16.850 --> 10:18.150
两个地方交换

10:18.150 --> 10:19.250
交换

10:19.250 --> 10:22.450
temp

10:22.450 --> 10:24.250
ar-i

10:24.250 --> 10:26.250
然后ar-i

10:26.250 --> 10:28.350
复制为

10:28.350 --> 10:29.850
ar-r

10:29.850 --> 10:32.050
target indexed

10:32.050 --> 10:33.650
然后ar-r

10:33.650 --> 10:35.350
target indexed

10:35.550 --> 10:36.750
复制为

10:36.750 --> 10:37.750
复制为啥呢

10:37.750 --> 10:39.650
复制为temp

10:39.650 --> 10:40.550
好完成交换

10:40.550 --> 10:41.950
这样子完成洗牌了

10:41.950 --> 10:42.350
好

10:42.350 --> 10:42.950
洗牌过后呢

10:42.950 --> 10:44.750
这个数组的顺序打乱了

10:44.750 --> 10:44.950
好

10:44.950 --> 10:46.050
提供了这么两个函数

10:46.050 --> 10:46.950
大家看

10:46.950 --> 10:49.750
我这个写下来

10:49.750 --> 10:51.550
提供了这么两个函数

10:51.550 --> 10:52.350
一个是take

10:52.350 --> 10:53.250
一个是刷否

10:53.250 --> 10:55.450
他们各自有各自的方形

10:55.450 --> 10:58.450
那么现在的信息是什么呢

10:58.450 --> 10:59.850
现在的信息是

10:59.850 --> 11:01.750
这个函数有自己的方形

11:01.750 --> 11:03.050
它里边有些操作

11:03.050 --> 11:04.150
那么这些方形呢

11:04.250 --> 11:05.350
保持这些联系

11:05.350 --> 11:06.550
联系他们一致

11:06.550 --> 11:07.450
这个刷否呢

11:07.450 --> 11:08.550
洗牌这个动作呢

11:08.550 --> 11:10.050
他也有一个方形

11:10.050 --> 11:10.950
但是这个方形

11:10.950 --> 11:12.850
跟这个方形是不是没有关联的

11:12.850 --> 11:14.250
比方他们明智一样

11:14.250 --> 11:15.150
明智一样不

11:15.150 --> 11:16.350
不代表他们有关联

11:16.350 --> 11:17.650
他们没有什么关联的

11:17.650 --> 11:18.750
为什么没有关联的

11:18.750 --> 11:20.450
因为每一次调用函数

11:20.450 --> 11:22.450
我都要传递这个一个方形过去

11:22.450 --> 11:23.450
调用这个函数的时候

11:23.450 --> 11:24.650
可以传递一个方形

11:24.650 --> 11:25.650
调用这个函数的时候

11:25.650 --> 11:27.550
也可以传递另外一个方形

11:27.550 --> 11:28.550
所以说

11:28.550 --> 11:29.550
他们的

11:29.550 --> 11:30.850
他们的就是

11:30.850 --> 11:31.750
这两个地方

11:31.750 --> 11:32.650
函数之间

11:32.650 --> 11:34.450
他们是没有任何关联的

11:34.450 --> 11:35.650
你不要说两个名字一样

11:35.650 --> 11:36.050
有关联

11:36.050 --> 11:37.450
那这个两个名字一样

11:37.450 --> 11:38.450
你觉得他们有关联吗

11:38.450 --> 11:40.250
这个AR和这个AR

11:40.250 --> 11:41.050
他们有关联吗

11:41.050 --> 11:41.850
没有什么关联

11:41.850 --> 11:43.050
对吧

11:43.050 --> 11:44.150
但是呢

11:44.150 --> 11:46.750
我既然把它写成了一个内

11:46.750 --> 11:50.050
我希望你创建好这个内的时候

11:50.050 --> 11:52.350
你创这是个数组帮助内

11:52.350 --> 11:54.850
你创建这个数组帮助内的时候

11:54.850 --> 11:57.150
你就直接把数组告诉我得了

11:57.150 --> 11:59.050
你就直接把数组告诉我得了

11:59.050 --> 12:01.650
我后边进行了所有操作

12:01.650 --> 12:04.150
都是跟这个数组相关的操作

12:04.150 --> 12:05.750
后边进行的一切操作

12:05.750 --> 12:07.850
都是跟这个数组相关的操作

12:07.850 --> 12:09.050
因此

12:09.050 --> 12:10.150
因此

12:10.150 --> 12:11.050
我这里呢

12:11.050 --> 12:13.950
我想把这个玩意儿写成啥呢

12:13.950 --> 12:16.250
写成属性

12:16.250 --> 12:17.250
这个AR2

12:17.250 --> 12:19.450
我想把它写成属性

12:19.450 --> 12:20.950
写成属性的时候

12:20.950 --> 12:22.050
这就麻烦来了

12:22.050 --> 12:24.050
这里能不能使用T呢

12:24.050 --> 12:25.450
这里能不能使用T

12:25.450 --> 12:26.650
说不行

12:26.650 --> 12:27.850
这里哪来的T呢

12:27.850 --> 12:28.450
没有

12:28.450 --> 12:29.850
使用不了这个T

12:29.850 --> 12:31.150
那么怎么办呢

12:31.150 --> 12:33.150
我们现在做的事情很简单

12:33.150 --> 12:34.250
我把这个T

12:34.250 --> 12:36.350
这个范熊提升一下

12:36.350 --> 12:38.950
提升到整个内上面

12:38.950 --> 12:40.550
提升到这

12:40.550 --> 12:42.550
提升到整个内上面

12:42.550 --> 12:43.350
提升到这了

12:43.350 --> 12:44.550
过后呢

12:44.550 --> 12:45.350
这里没有出实话

12:45.350 --> 12:46.450
没有出实话的话

12:46.450 --> 12:48.150
我们在那个构造函数里面

12:48.150 --> 12:49.850
我们出实话吧

12:49.850 --> 12:52.350
康实状态

12:52.350 --> 12:53.150
我们这样子写吧

12:53.150 --> 12:56.150
Private AR2T

12:56.150 --> 13:00.080
把这样子写

13:00.080 --> 13:02.780
我们提升为整个内里边

13:02.780 --> 13:05.980
就表示我创建它对象的时候

13:05.980 --> 13:06.680
我们是说

13:06.680 --> 13:09.680
翻译型它是在使用的时候

13:09.680 --> 13:10.880
雕用的时候

13:10.880 --> 13:12.080
给它指定内形

13:12.080 --> 13:14.080
那么创建内的对象的时候

13:14.080 --> 13:15.580
是不是要调用构造函数

13:15.580 --> 13:16.380
对不对

13:16.380 --> 13:18.080
调用构造函数的时候

13:18.080 --> 13:19.080
你告诉我

13:19.080 --> 13:21.180
你要操作的是什么内形的输出

13:21.180 --> 13:22.480
那么我后续的操作

13:22.480 --> 13:24.780
全都是跟这个输出相关的

13:24.780 --> 13:25.680
懂的意思吗

13:25.680 --> 13:27.580
我把内形提到这了

13:27.580 --> 13:29.080
提到这了之后呢

13:29.180 --> 13:30.380
那么我这个属性

13:30.380 --> 13:32.480
你看这个属性使用的是内形

13:32.480 --> 13:33.380
没问题

13:33.380 --> 13:35.680
然后我里面的所有的函数

13:35.680 --> 13:37.280
使用的都是这个内形

13:37.280 --> 13:39.180
函数我就不加翻译了

13:39.180 --> 13:40.480
这样子一来

13:40.480 --> 13:42.380
你这个T就通用了

13:42.380 --> 13:44.480
这个T跟这个T是一样的

13:44.480 --> 13:45.780
跟这个T是一样的

13:45.780 --> 13:46.880
跟这个T是一样的

13:46.880 --> 13:48.280
跟像你这个T是一样的

13:48.280 --> 13:51.380
因为这个T来自于不来自于函数了

13:51.380 --> 13:53.180
而来自于整个内

13:53.180 --> 13:54.780
来自于整个内

13:54.780 --> 13:55.980
当然我这里

13:55.980 --> 13:57.880
AR就不再作为参数了

13:57.880 --> 13:59.980
就这里就是Z点AR

14:01.480 --> 14:02.680
Z点AR

14:02.680 --> 14:03.680
Z点AR

14:03.680 --> 14:04.480
下面改一下

14:05.580 --> 14:06.680
这里没有参数了

14:08.580 --> 14:10.380
这里Z

14:11.180 --> 14:14.680
Z加上Z加上Z加上Z加上Z加上

14:15.680 --> 14:18.880
好我们就写出了这么一个数组的帮助类

14:18.880 --> 14:19.880
咱们来用一下

14:19.880 --> 14:21.780
看一下他们神奇的效果

14:22.580 --> 14:24.080
好有了这个内之后呢

14:24.080 --> 14:25.980
我们在创建这个内的对象的时候

14:25.980 --> 14:27.480
就要指定这个内的犯行

14:28.180 --> 14:28.980
我们来试一下

14:30.480 --> 14:31.480
创建一个

14:32.080 --> 14:32.780
help

14:32.780 --> 14:33.680
help

14:33.680 --> 14:35.480
new一个array

14:35.480 --> 14:36.080
help

14:36.880 --> 14:38.980
好创建的时候给他指定一个数组

14:38.980 --> 14:40.080
指定一个数组

14:42.180 --> 14:44.480
这样修复导入

14:45.280 --> 14:47.080
创建的时候给他指定一个数组

14:47.080 --> 14:47.980
什么内容的数组呢

14:47.980 --> 14:49.580
他现在不知道是什么内容的数组

14:49.580 --> 14:51.180
那我给他随便指定一个吧

14:51.180 --> 14:53.380
比方说我有一个数字内容的数组

14:53.380 --> 14:55.080
你看他马上就推断出来了

14:55.080 --> 14:57.680
哦你这里给了一个数字内容的数组

14:57.680 --> 14:59.780
也就是说这个t是什么呢

14:59.780 --> 15:00.680
t是number

15:00.680 --> 15:01.880
他就推断出来了

15:01.880 --> 15:03.880
t是number的话这里的t也是number

15:03.880 --> 15:05.580
那么后面的全是number了

15:05.580 --> 15:06.980
全都是number了

15:06.980 --> 15:08.080
另外这个意思

15:08.080 --> 15:10.980
当然你也可以手动的去输写这个犯行

15:10.980 --> 15:12.280
创建这个对象的时候

15:12.280 --> 15:13.680
手动的去输写这里

15:13.680 --> 15:15.080
把它输写为number

15:15.080 --> 15:17.280
也可以用他的内容推导

15:17.280 --> 15:18.880
然后推导出来是number

15:18.880 --> 15:19.780
然后接下来我们看一下

15:19.780 --> 15:21.580
这个help里面的东西

15:21.580 --> 15:22.580
刷否你看一下

15:23.780 --> 15:25.080
对刷否

15:25.080 --> 15:26.280
洗牌

15:26.480 --> 15:27.280
洗牌

15:27.280 --> 15:29.880
这个地方他没有显示出来

15:29.880 --> 15:30.880
没有显示出来

15:30.880 --> 15:31.880
然后看take

15:31.880 --> 15:32.880
看take

15:33.480 --> 15:35.680
你看到他返回的是什么

15:35.680 --> 15:37.180
返回的是一个number数组

15:37.180 --> 15:39.280
返回的是个number数组

15:39.280 --> 15:40.880
那么如果我这里

15:40.880 --> 15:43.280
如果我这里是一个字不串的数组

15:46.080 --> 15:47.880
我数量不太好用

15:47.880 --> 15:49.480
是一个字不串的数组

15:49.480 --> 15:51.080
你看一下take

15:51.080 --> 15:53.280
返回的就是一个字不串的数组

15:53.280 --> 15:55.280
那么我们通过内德犯行

15:55.280 --> 15:56.880
就可以约束这个内里面

15:56.880 --> 15:59.380
所有跟这个犯行相关的函数

15:59.380 --> 16:01.780
他们都可以使用同一种犯行

16:01.780 --> 16:03.480
使用的是同一种犯行

16:04.880 --> 16:06.380
这是关于内德犯行

16:06.380 --> 16:07.880
实际上是一样的道理

16:07.880 --> 16:08.780
完全一样的道理

16:10.180 --> 16:12.280
这里给大家看几个函数

16:12.280 --> 16:13.280
给大家看一下

16:13.280 --> 16:14.480
随便写一些函数

16:14.480 --> 16:15.780
给大家看一下

16:15.780 --> 16:18.380
你会发现犯行在咱们ts里面

16:18.380 --> 16:19.280
到处在使用

16:20.280 --> 16:21.080
随便写个函数

16:23.980 --> 16:24.980
一个数数

16:25.080 --> 16:25.980
for each

16:27.080 --> 16:27.880
for each

16:28.880 --> 16:30.780
我们按f12

16:30.980 --> 16:32.180
按一下f12

16:32.180 --> 16:34.080
转到for each的定义

16:34.580 --> 16:35.280
转过去

16:36.180 --> 16:36.980
你会发现

16:36.980 --> 16:39.780
for each的函数里面使用了一个什么东西

16:40.280 --> 16:41.480
使用了一个t

16:41.480 --> 16:42.080
看到没

16:42.380 --> 16:43.280
使用了一个t

16:43.380 --> 16:44.380
这个t哪来的

16:44.380 --> 16:44.880
你看

16:45.680 --> 16:47.580
for each表示循环数组

16:47.580 --> 16:48.580
循环数组的时候

16:48.580 --> 16:49.580
每一项要做什么

16:49.580 --> 16:51.080
它是个回调函数

16:51.280 --> 16:52.580
一个回调函数

16:52.580 --> 16:53.880
它有哪些参数呢

16:53.880 --> 16:55.080
第一个参数就是v6

16:55.280 --> 16:56.480
v6表示什么呢

16:56.480 --> 16:58.780
表示的是数组里面某一项

16:59.280 --> 17:01.580
数组里面表示数组里面某一项

17:01.780 --> 17:02.580
某一项的类型

17:02.580 --> 17:04.680
它写这个函数的时候知不知道

17:04.780 --> 17:05.880
它肯定不知道

17:05.980 --> 17:07.180
根本就不知道这个数组

17:07.180 --> 17:08.280
每一项是什么类型

17:08.480 --> 17:09.880
因此它使用了犯行

17:10.080 --> 17:11.680
那么这个犯行定在哪的呢

17:11.680 --> 17:12.580
我们往上找

17:12.980 --> 17:13.580
往上找

17:15.380 --> 17:16.380
二位看到没有

17:16.380 --> 17:16.880
t

17:17.280 --> 17:19.580
我们之前还记得吗

17:19.880 --> 17:22.480
咱们之前在约束数组的时候

17:23.180 --> 17:24.980
在约束一个数组的时候

17:25.080 --> 17:26.180
它是一个数组

17:26.180 --> 17:28.780
我们可以使用这种方式来约束对吧

17:29.280 --> 17:29.980
这是啥

17:29.980 --> 17:31.080
这就是一个犯行

17:31.280 --> 17:32.480
在告诉他

17:32.480 --> 17:33.780
通过这个地方告诉他

17:33.780 --> 17:34.880
这个数组是一个

17:34.880 --> 17:35.980
你看它是个接口

17:36.780 --> 17:39.480
这个数组它每一项的类型是number

17:39.480 --> 17:41.480
当然这里可以写成任何其他东西

17:41.680 --> 17:42.880
如果没有犯行

17:42.880 --> 17:43.480
你想一想

17:43.480 --> 17:45.880
它这个耳瑞这个接口该怎么写

17:45.880 --> 17:47.180
怎么写都不对

17:47.480 --> 17:48.680
随便你怎么写都不对

17:48.780 --> 17:49.980
因为它少了一个信息

17:49.980 --> 17:51.480
少了一个相关的信息

17:51.680 --> 17:52.680
它缺失了

17:52.780 --> 17:53.780
那么有了犯行过后

17:53.880 --> 17:56.280
就可以把缺失的信息给它加上了

17:56.680 --> 17:57.280
好吧

17:57.380 --> 17:58.680
这就是这一块

17:59.080 --> 18:01.680
我们可以犯行可以在内接口

18:01.880 --> 18:03.580
内层面面中都可以使用

18:03.680 --> 18:04.780
后面咱们学习

18:04.780 --> 18:06.580
做那个项目的时候

18:06.580 --> 18:08.180
做react这个项目的时候

18:08.280 --> 18:10.080
要大量使用到犯行

18:10.180 --> 18:14.080
很多时候可能不太需要你自己去定一个犯行

18:14.280 --> 18:16.580
但是我们要用到

18:16.580 --> 18:18.580
至少你要知道那个地方是犯行

18:18.580 --> 18:19.780
我们该怎么去使用

18:20.480 --> 18:22.580
好都是关于犯行这一块的

18:22.580 --> 18:25.080
就是这一块在写代码的时候

18:25.080 --> 18:26.080
该如何来书写

