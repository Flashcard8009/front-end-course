WEBVTT

00:00.940 --> 00:05.140
这节课呢 咱们学习了基本内容约束

00:05.140 --> 00:09.340
那么接下来呢 我就用这节课咱们学过的知识啊

00:09.340 --> 00:13.340
来做这么一个小练习啊 比方说我们现在做一个练习

00:13.340 --> 00:16.140
就是练习 创建一副撲克牌

00:16.140 --> 00:19.140
然后呢 再把它打印出来啊 做这么一个小练习

00:19.140 --> 00:23.940
来体会一下ts给我们的开发呢 带来哪些便利

00:23.940 --> 00:28.940
ok 我这里呢建立一个建立一个分支 check out

00:29.940 --> 00:32.940
建立一个practice

00:32.940 --> 00:38.940
poker 撲克牌的一个小练习 创建这么一个分支

00:38.940 --> 00:41.940
好 现在呢 我们切换到这个分支

00:41.940 --> 00:45.940
然后呢 我就把这个这里面的东西全部删了啊 全部删了

00:45.940 --> 00:48.940
啊 这个笔记啊 扔着吧 扔着

00:48.940 --> 00:51.940
好 这个撲克牌的小练习呢 我们现在要做这么一件事情

00:51.940 --> 00:58.450
我在笔记面积 撲克牌小练习

00:58.450 --> 01:00.450
我们首先做这么一件事

01:00.450 --> 01:07.210
呃 就是我们要完成目标啊 完成目标

01:07.210 --> 01:11.210
目标是什么呢 是创建要能够有个函数

01:11.210 --> 01:15.210
创建一副撲克牌啊 撲克牌

01:15.210 --> 01:19.210
这里呢 我要简单一点啊 就不包括大小王了啊

01:19.210 --> 01:23.210
不包括大小王 大小王不要了

01:23.210 --> 01:28.210
然后呢 还要能够打印该撲克牌

01:28.210 --> 01:32.210
打印这一副撲克牌 这是我们今天这个练习的目标

01:32.210 --> 01:35.210
那么这里呢 我们设计到两个函数

01:35.210 --> 01:39.210
一个是创建撲克牌的函数 一个是打印撲克牌的函数

01:39.210 --> 01:43.210
好 我们先写这么一个函数啊 写这么一个函数

01:43.210 --> 01:47.210
这里 创建一副撲克牌

01:47.210 --> 01:51.210
CREATE DECK 表示创建一副牌

01:51.210 --> 01:55.210
好 这个函数返回的是什么类型呢

01:55.210 --> 01:58.210
我们如果不写类型行不行啊 当然可以

01:58.210 --> 02:02.210
我们知道TS是一个可选的类型系统

02:02.210 --> 02:06.210
你完全可以不写它 不用它 其实就已经可以带来很多的便利了

02:06.210 --> 02:09.210
当然你可以去使用 我们既然在学习它

02:09.210 --> 02:13.210
那么我肯定要来这里去使用这个 使用这个类型约束

02:13.210 --> 02:18.210
好 这里返回什么呢 我们假设 假设有这么一个类型

02:18.210 --> 02:22.210
叫DECK 表示一副牌 一副牌的类型

02:22.210 --> 02:25.210
或者把D大写吧 DECK 表示一副牌的类型

02:25.210 --> 02:29.210
那么现在没有这个类型 因此我们可以用什么

02:29.210 --> 02:33.210
用这种方式来定义一个类型 叫类型别名

02:33.210 --> 02:35.210
来定义这么一个类型

02:35.210 --> 02:39.210
一副牌它到底是什么呢 它肯定是很多很多牌的一个数组

02:39.210 --> 02:43.210
对不对 一定是很多牌的一个数组

02:43.210 --> 02:46.210
我们一副撲克牌有54张 去了拉小王

02:46.210 --> 02:50.210
有多少张 有52张 一定是有一些牌的数组

02:50.210 --> 02:53.210
那么这个地方是什么呢 这个地方呢

02:53.210 --> 02:56.210
我们也可以用一个类型来进行定义

02:56.210 --> 03:00.210
比如说我们再定一个类型 这个类型表示Normal Card

03:00.210 --> 03:04.210
一个普通的撲克牌 就是一张牌

03:04.210 --> 03:08.210
一张牌我们认为它是一个对象 一张牌是一个对象

03:08.210 --> 03:13.210
然后一张牌里面有哪些呢 有花色 对吧 卡纳 有花色

03:13.210 --> 03:16.210
花色是啥 是一个字母创吗 先用个字母创来说

03:16.210 --> 03:20.210
然后呢 有什么呢 有数字 数字

03:20.210 --> 03:26.210
我们用单词Mark 表示它标记的数字 这是一个Number

03:26.210 --> 03:30.210
好 一张撲克牌 用这样的一个类型来表示

03:30.210 --> 03:34.210
这是个字面两样的类型 给它取个名字 叫Normal Card

03:34.210 --> 03:38.210
好 一副撲克牌 是不是它的数组 对不对

03:38.210 --> 03:42.210
有些是它的数组 OK 我们就定义了这么两个类型

03:43.210 --> 03:46.210
当然这两个类型定义好了过后 我们再多想一点

03:46.210 --> 03:49.210
尽量让后边拥起来方便一点

03:49.210 --> 03:52.210
就是撲克牌的花色是一个字母创

03:52.210 --> 03:55.210
那么它的取值范围是不是太广了

03:55.210 --> 03:58.210
一个字母创可以取很多很多的值

03:58.210 --> 04:01.210
因此它的取值范围过于宽广

04:01.210 --> 04:04.210
我们需要希望的对它进行一下限制

04:04.210 --> 04:07.210
怎么限制呢 就是用这种方式

04:07.210 --> 04:10.210
可以用字面量的方式来进行限制

04:10.210 --> 04:13.210
这边就是四种花色 哪四种呢

04:13.210 --> 04:16.210
红桃 用这个吧

04:16.210 --> 04:19.210
黑桃 用这个

04:19.210 --> 04:25.210
然后方块 然后是还啥

04:25.210 --> 04:28.210
梅花 梅花 OK

04:28.210 --> 04:31.210
我们用这个四个字不错的字面量

04:31.210 --> 04:34.210
对这个属性进行约束

04:34.210 --> 04:37.210
那么这个属性只能取之为这个东西了

04:37.210 --> 04:39.210
而下面这个排面呢 就是123456

04:39.210 --> 04:42.210
一直到13 对吧 一到13

04:42.210 --> 04:45.210
这个排面呢 我就不约束了吧

04:45.210 --> 04:47.210
要约束也可以 用数字的字面量

04:47.210 --> 04:50.210
对它进行约束 难得写了 不约束了

04:50.210 --> 04:52.210
好 我们写到这的时候

04:52.210 --> 04:55.210
其实也可以再多想一想

04:55.210 --> 04:57.210
将来呢 这个地方呢

04:57.210 --> 04:59.210
我们可能有这么一个函数

04:59.210 --> 05:01.210
将来可能会有这么一个函数

05:01.210 --> 05:05.210
比方说查询 比方说fan的

05:06.210 --> 05:10.210
查询一些铺客牌

05:10.210 --> 05:13.210
比方说按照某一种花色来查询

05:13.210 --> 05:15.210
传一个变量卡到进来

05:15.210 --> 05:18.210
按照某一种花色来查询铺客牌

05:18.210 --> 05:20.210
那么这个时候呢

05:20.210 --> 05:22.210
是不是又要进行约束

05:22.210 --> 05:24.210
我得写重复代码进行约束

05:24.210 --> 05:25.210
就很麻烦

05:25.210 --> 05:27.210
所以说写到这的时候呢

05:27.210 --> 05:28.210
应该有种感觉

05:28.210 --> 05:30.210
怎么办呢 我们可以把这个玩意儿

05:30.210 --> 05:33.210
又提出来 提出来

05:33.210 --> 05:35.210
这个书写顺序无所谓的

05:35.210 --> 05:37.210
提出来形成一个color

05:37.210 --> 05:39.210
这么一个别名

05:39.210 --> 05:41.210
要取个别名 color

05:41.210 --> 05:43.210
ok 那么这里

05:43.210 --> 05:45.210
我们就可以使用这个东西来约束

05:45.210 --> 05:47.210
这个地方也可以使用这个东西来约束

05:47.210 --> 05:49.210
好 其实我们做的事情

05:49.210 --> 05:50.210
也不多

05:50.210 --> 05:51.210
就做了这么一件事

05:51.210 --> 05:53.210
给他订了一些别名

05:53.210 --> 05:55.210
给这些内心订了别名

05:55.210 --> 05:57.210
防止我们后面去写一些重复的代码

05:57.210 --> 05:59.210
有了别名过后

05:59.210 --> 06:00.210
这个表示花色

06:00.210 --> 06:01.210
这个表示一张铺客牌

06:01.210 --> 06:03.210
这个表示一副牌

06:03.210 --> 06:05.210
这个逻辑关系就清楚了

06:05.210 --> 06:07.210
那么这里我要创建一副副客牌

06:07.210 --> 06:09.210
返回的是啥 返回的就是

06:09.210 --> 06:11.210
deck 返回的就是这个东西

06:11.210 --> 06:12.210
一副副客牌

06:12.210 --> 06:14.210
也就是是一个竖竹

06:14.210 --> 06:15.210
好 怎么来创建呢

06:15.210 --> 06:17.210
我们这里可以用这种方式

06:17.210 --> 06:20.210
先写一个竖竹

06:20.210 --> 06:22.210
deck

06:22.210 --> 06:23.210
内形

06:23.210 --> 06:25.210
先给它复制为一个空竖竹

06:25.210 --> 06:26.210
给它约束一下

06:26.210 --> 06:28.210
它的内形是竖竹

06:28.210 --> 06:30.210
这里为什么不能推倒呢

06:30.210 --> 06:32.210
为什么不能推倒

06:32.210 --> 06:34.210
因为如果你不写这个约束的话

06:34.210 --> 06:36.210
它怎么知道是什么竖竹呢

06:36.210 --> 06:38.210
它不知道是一个什么样的竖竹

06:38.210 --> 06:40.210
所以说你这里也需要推倒

06:40.210 --> 06:42.210
你需要给它写一个deck

06:42.210 --> 06:43.210
推倒一下

06:43.210 --> 06:45.210
就是告诉它

06:45.210 --> 06:47.210
这里deck 两个东话

06:47.210 --> 06:48.210
表示

06:48.210 --> 06:49.210
不是东话

06:49.210 --> 06:51.210
表示这是一副牌

06:51.210 --> 06:53.210
表示这是一副牌

06:53.210 --> 06:55.210
不然的话由于这个竖竹里边没东西

06:55.210 --> 06:58.210
它不知道这个竖竹每一项是什么内形

06:58.210 --> 06:59.210
OK

06:59.210 --> 07:01.210
好 现在呢

07:01.210 --> 07:03.210
我们定义了这么一副牌

07:03.210 --> 07:05.210
接下来我就要往这个竖竹里边加东西了

07:05.210 --> 07:06.210
怎么加

07:06.210 --> 07:07.210
副柯牌

07:07.210 --> 07:09.210
每个花色四张

07:09.210 --> 07:11.210
每个花色四张

07:11.210 --> 07:12.210
然后呢

07:12.210 --> 07:14.210
一共有

07:14.210 --> 07:17.210
每个竖竹一共有13个

07:17.210 --> 07:19.210
所以说我这里可以这样子写

07:19.210 --> 07:21.210
循环

07:21.210 --> 07:23.210
起个副循环

07:23.210 --> 07:25.210
循环I从一开始

07:25.210 --> 07:28.210
小于等于13

07:28.210 --> 07:30.210
每次I加加

07:30.210 --> 07:32.210
每一次循环呢

07:32.210 --> 07:35.210
往这个竖竹里边加一个对象

07:35.210 --> 07:37.210
加一个对象

07:37.210 --> 07:39.210
添加一个副柯牌

07:39.210 --> 07:40.210
你看

07:40.210 --> 07:42.210
它知道这是一个竖竹

07:42.210 --> 07:43.210
看到没

07:43.210 --> 07:45.210
它知道这是个normal card的竖竹

07:45.210 --> 07:46.210
于是呢

07:46.210 --> 07:47.210
既然是竖竹

07:47.210 --> 07:48.210
它就会有

07:48.210 --> 07:49.210
poohy这个函数

07:49.210 --> 07:51.210
它会自动提示的

07:51.210 --> 07:52.210
点poohy

07:52.210 --> 07:53.210
好

07:53.210 --> 07:54.210
poohy里边

07:54.210 --> 07:55.210
每一项是什么呢

07:55.210 --> 07:56.210
它会提示的

07:56.210 --> 07:58.210
每一项是一个normal card

07:58.210 --> 08:00.210
每一项是个normal card

08:00.210 --> 08:02.210
这里要添加四个poohy

08:02.210 --> 08:03.210
四项

08:03.210 --> 08:05.210
我就一次写呗

08:05.210 --> 08:06.210
好

08:06.210 --> 08:07.210
mark

08:07.210 --> 08:08.210
为什么

08:08.210 --> 08:09.210
数字为i

08:09.210 --> 08:10.210
数字为i

08:10.210 --> 08:11.210
然后

08:11.210 --> 08:12.210
颜色呢

08:12.210 --> 08:13.210
花色呢

08:13.210 --> 08:14.210
花色这里写啥呢

08:14.210 --> 08:15.210
你看

08:15.210 --> 08:16.210
打出双一号

08:16.210 --> 08:17.210
它马上就提示你的

08:17.210 --> 08:18.210
因为它知道

08:18.210 --> 08:20.210
这里的卡的内形是一个

08:20.210 --> 08:22.210
字面量内形

08:22.210 --> 08:24.210
只能取得四个当中的一个

08:24.210 --> 08:25.210
因此呢

08:25.210 --> 08:26.210
这里它会提示你

08:26.210 --> 08:28.210
你只能取得四个当中的一个

08:28.210 --> 08:29.210
你不可能出错的

08:29.210 --> 08:32.210
有的时候打这种特殊符号

08:32.210 --> 08:34.210
可能老是打不出来

08:34.210 --> 08:35.210
或者是打出来了

08:35.210 --> 08:37.210
又不是跟之前的一样的

08:37.210 --> 08:39.210
在ts里面不可能

08:39.210 --> 08:40.210
你使用了字面量的约束

08:40.210 --> 08:42.210
它一定能打出来

08:42.210 --> 08:43.210
而且呢

08:43.210 --> 08:44.210
是一模一样的

08:44.210 --> 08:45.210
好

08:45.210 --> 08:46.210
添加一个poohy

08:46.210 --> 08:47.210
添加四个吧

08:47.210 --> 08:48.210
三

08:48.210 --> 08:49.210
四

08:49.210 --> 08:50.210
这个地方

08:50.210 --> 08:52.210
我们换一下花色

08:52.210 --> 08:53.210
这个

08:54.210 --> 08:55.210
这个地方

08:55.210 --> 08:56.210
红桃

08:57.210 --> 08:59.210
最后一个梅花

08:59.210 --> 09:00.210
梅花有了

09:00.210 --> 09:01.210
防困

09:01.210 --> 09:02.210
好

09:02.210 --> 09:03.210
循环13次

09:03.210 --> 09:04.210
每次往里面加

09:04.210 --> 09:05.210
四个当铺盒牌

09:05.210 --> 09:06.210
最后呢

09:06.210 --> 09:07.210
循环结束过后

09:07.210 --> 09:08.210
自然而然

09:08.210 --> 09:09.210
这就是一层副铺盒牌了

09:09.210 --> 09:11.210
最后我们把这个带盒返回

09:12.210 --> 09:13.210
其实

09:13.210 --> 09:14.210
ts在这里面

09:14.210 --> 09:15.210
用到多少呢

09:15.210 --> 09:16.210
其实也没多少

09:16.210 --> 09:17.210
就定义了一下内形

09:17.210 --> 09:18.210
防之后面出错

09:18.210 --> 09:20.210
该写带怎么去写带吗

09:20.210 --> 09:21.210
还是跟之前一样

09:21.210 --> 09:23.210
跟之前建设是一样的

09:23.210 --> 09:24.210
好

09:24.210 --> 09:25.210
这是关于

09:25.210 --> 09:27.210
铺盒牌的创建

09:27.210 --> 09:28.210
有这么一个函数

09:28.210 --> 09:29.210
创建一副铺盒牌

09:29.210 --> 09:31.210
接下来我们再写个函数

09:32.210 --> 09:34.210
PrinceDec

09:34.210 --> 09:36.210
打印一副铺盒牌

09:36.210 --> 09:37.210
那么打印的时候

09:37.210 --> 09:39.210
是不是要传个参数进来

09:39.210 --> 09:40.210
对不对

09:40.210 --> 09:42.210
也要传一副铺盒牌进来

09:42.210 --> 09:43.210
传个参数

09:43.210 --> 09:44.210
以前在建设里面

09:44.210 --> 09:46.210
没有任何约束

09:46.210 --> 09:47.210
那么就神奇了

09:47.210 --> 09:48.210
它可能会传入

09:48.210 --> 09:50.210
各种各样乱七八糟的对象

09:51.210 --> 09:53.210
各种各样的乱七八糟的东西

09:53.210 --> 09:54.210
都可能传进来

09:54.210 --> 09:56.210
但是现在有了TS过后

09:56.210 --> 09:57.210
我们只要轻轻的

09:57.210 --> 09:59.210
给它加上一个约束

09:59.210 --> 10:00.210
Dec

10:00.210 --> 10:01.210
你还能乱传吗

10:01.210 --> 10:03.210
绝对不可能乱传

10:03.210 --> 10:05.210
你传的只能是一副铺盒牌

10:05.210 --> 10:07.210
并且是一个NormalCard的数组

10:07.210 --> 10:08.210
每一项

10:08.210 --> 10:09.210
数组的每一项

10:09.210 --> 10:10.210
一定是这个对象

10:10.210 --> 10:12.210
现在就不可能出现问题了

10:12.210 --> 10:13.210
OK

10:13.210 --> 10:14.210
咱们再来看

10:14.210 --> 10:16.210
既然它适应副�铺盒牌

10:16.210 --> 10:17.210
那么这里

10:17.210 --> 10:19.210
它是一个数组

10:19.210 --> 10:20.210
是不是可以循环

10:20.210 --> 10:22.210
你想想以前在GS里面

10:22.210 --> 10:23.210
以前在GS里面

10:23.210 --> 10:25.210
有没有可能有这种智能提示

10:25.210 --> 10:26.210
是不可能的

10:26.210 --> 10:28.210
它怎么知道这是个数组呢

10:28.210 --> 10:29.210
它无法知道这是个数组

10:29.210 --> 10:31.210
但是现在有内情约束过后

10:31.210 --> 10:32.210
它就知道了

10:32.210 --> 10:33.210
这是个数组

10:33.210 --> 10:34.210
于是它就包含了

10:34.210 --> 10:35.210
数组的所有函数

10:35.210 --> 10:37.210
可以智能提示

10:37.210 --> 10:38.210
而且这个循环的时候

10:38.210 --> 10:39.210
数组的每一项

10:39.210 --> 10:41.210
我们来看一下

10:41.210 --> 10:43.210
数组的每一项Card

10:44.210 --> 10:46.210
我们指着Card看一下

10:46.210 --> 10:48.210
它能够清楚的知道

10:48.210 --> 10:49.210
你在循环数组

10:49.210 --> 10:51.210
数组的每一项

10:51.210 --> 10:53.210
是一张牌

10:53.210 --> 10:55.210
于是你下面

10:55.210 --> 10:57.210
仍然可以获得智能提示

10:57.210 --> 10:58.210
你看

10:58.210 --> 10:59.210
每张牌的颜色

10:59.210 --> 11:00.210
每张牌的数字

11:00.210 --> 11:02.210
可以清楚的获得这个智能提示

11:02.210 --> 11:04.210
那我要怎么输出呢

11:04.210 --> 11:05.210
我要怎么输出

11:05.210 --> 11:07.210
我就这样子吧

11:07.210 --> 11:09.210
我写这么一个支付串

11:09.210 --> 11:10.210
写这么一个支付串

11:10.210 --> 11:11.210
STR

11:11.210 --> 11:14.210
首先取出这个牌的花色

11:14.210 --> 11:16.210
把花色取出来

11:16.210 --> 11:17.210
然后数字呢

11:17.210 --> 11:19.210
有这么一种几种情况

11:19.210 --> 11:21.210
如果这个牌的数字

11:21.210 --> 11:23.210
你看不可能出错的

11:23.210 --> 11:25.210
出错的话

11:25.210 --> 11:26.210
它就会爆错的

11:26.210 --> 11:28.210
如果你不要一写错了

11:28.210 --> 11:29.210
写成Mark了

11:29.210 --> 11:31.210
所以马上就爆错了

11:31.210 --> 11:33.210
它就会提示你没有这个属性

11:33.210 --> 11:34.210
而且有智能提示

11:34.210 --> 11:36.210
也是不太可能写错的

11:36.210 --> 11:37.210
Mark

11:37.210 --> 11:39.210
如果小于等于10

11:39.210 --> 11:42.210
那么直接拼接这个支付串就是

11:42.210 --> 11:45.210
拼接上Card的Mark

11:45.210 --> 11:47.210
把个数字拼接上就行了

11:47.210 --> 11:49.210
LCF

11:49.210 --> 11:53.210
如果CardMark

11:53.210 --> 11:55.210
等于11

11:55.210 --> 11:56.210
那么11是啥

11:56.210 --> 11:58.210
11就是勾对吧

11:58.210 --> 12:01.210
界拼接界

12:01.210 --> 12:04.210
LCFCardMark

12:04.210 --> 12:06.210
等于12

12:06.210 --> 12:07.210
我就拼接

12:07.210 --> 12:11.210
拼接界Q

12:12.210 --> 12:14.210
LC就是13

12:14.210 --> 12:16.210
拼接

12:16.210 --> 12:17.210
OK

12:17.210 --> 12:19.210
我就把这个支付串拼接好

12:19.210 --> 12:20.210
拼接好了过后呢

12:20.210 --> 12:22.210
我就把输出就完事了

12:22.210 --> 12:23.210
Console

12:23.210 --> 12:24.210
Log

12:24.210 --> 12:25.210
STL

12:25.210 --> 12:26.210
就完事了

12:26.210 --> 12:29.210
这就是我这里打印一幅破壳牌的

12:29.210 --> 12:31.210
打印方式

12:31.210 --> 12:34.210
当然你可以把它做得更加晚上一点

12:34.210 --> 12:36.210
这里我们就写好了这两个函数

12:36.210 --> 12:39.210
其实用到了多少TS的东西呢

12:39.210 --> 12:40.210
没有用多少

12:40.210 --> 12:41.210
咱们TS里面

12:41.210 --> 12:44.210
它本不是为了给我们制造麻烦的

12:44.210 --> 12:46.210
它是为了减轻我们的负担的

12:46.210 --> 12:47.210
那么写的时候

12:47.210 --> 12:49.210
虽然我们好像多写了这么一些代码

12:49.210 --> 12:51.210
但是实际上我们每一个位置

12:51.210 --> 12:53.210
都获得了完整的类型检查

12:53.210 --> 12:55.210
依兰不太容易出错

12:55.210 --> 12:56.210
第二种呢

12:56.210 --> 12:59.210
第二来我们可以获得完整的智能提示

12:59.210 --> 13:00.210
OK

13:00.210 --> 13:01.210
好

13:01.210 --> 13:03.210
现在我们调用一下这个函数

13:03.210 --> 13:04.210
首先我们得到一幅破壳牌

13:04.210 --> 13:05.210
Deck

13:05.210 --> 13:06.210
Crease

13:06.210 --> 13:08.210
Deck

13:08.210 --> 13:09.210
得到一幅破壳牌

13:09.210 --> 13:10.210
那么现在这个变量

13:10.210 --> 13:11.210
你看推断出来

13:11.210 --> 13:13.210
就是一幅破壳牌了

13:13.210 --> 13:16.210
然后使用PrintDeck

13:16.210 --> 13:18.210
把这个破壳牌传进去

13:18.210 --> 13:19.210
调容它

13:19.210 --> 13:20.210
好

13:20.210 --> 13:22.210
我们来看一下结果

13:22.210 --> 13:27.930
这个用NPM

13:27.930 --> 13:28.930
看一下结果

13:28.930 --> 13:30.930
你看破壳牌就打印出来了

13:30.930 --> 13:31.930
打印出来了

13:31.930 --> 13:32.930
当然我们可以把它

13:32.930 --> 13:33.930
这个打印呢

13:33.930 --> 13:34.930
再优化一下吧

13:34.930 --> 13:35.930
再优化一下

13:35.930 --> 13:37.930
这种打印方式看的不太清楚

13:37.930 --> 13:38.930
把优化一下

13:38.930 --> 13:40.930
这里打印的时候

13:40.930 --> 13:42.930
我们可以这样子写

13:42.930 --> 13:43.930
我们可以写

13:43.930 --> 13:44.930
这么一个

13:44.930 --> 13:45.930
外面写一个

13:45.930 --> 13:46.930
外面写个支付串

13:46.930 --> 13:47.930
Result

13:47.930 --> 13:48.930
支付串

13:48.930 --> 13:49.930
先写钢N

13:49.930 --> 13:50.930
换个行

13:50.930 --> 13:52.930
然后每一次循环

13:52.930 --> 13:53.930
一张破壳牌的时候

13:53.930 --> 13:55.930
把破壳牌得到了结果

13:55.930 --> 13:57.930
破壳牌得到了结果

13:57.930 --> 13:58.930
然后呢

13:58.930 --> 14:00.930
Result拼借一下

14:00.930 --> 14:01.930
拼借一下

14:01.930 --> 14:03.930
拼借一下这个

14:03.930 --> 14:05.930
STR

14:05.930 --> 14:07.930
然后再拼借一个写钢T

14:07.930 --> 14:08.930
就是字表幅

14:08.930 --> 14:10.930
就是你自己去排一下吧

14:10.930 --> 14:11.930
自己去排一下吧

14:11.930 --> 14:13.930
我们这里再这样子吧

14:13.930 --> 14:15.930
再这样子

14:15.930 --> 14:16.930
可以获得

14:16.930 --> 14:17.930
我们在循环的时候

14:17.930 --> 14:18.930
还可以获得

14:18.930 --> 14:19.930
数组里边

14:19.930 --> 14:20.930
每一项的下标

14:20.930 --> 14:21.930
你看

14:21.930 --> 14:22.930
它可以判断出来

14:22.930 --> 14:24.930
它是一个Number

14:24.930 --> 14:25.930
就这么致的

14:25.930 --> 14:26.930
它可以知道

14:26.930 --> 14:27.930
这个地方是一个Number

14:27.930 --> 14:28.930
因为它这个

14:28.930 --> 14:30.930
每一个地方都有内情约束的

14:30.930 --> 14:31.930
好

14:31.930 --> 14:32.930
那么这个I表示下标

14:32.930 --> 14:33.930
每一张牌

14:33.930 --> 14:34.930
在牌里面的下标

14:34.930 --> 14:35.930
我打算

14:35.930 --> 14:37.930
一行显示6张

14:37.930 --> 14:39.930
一行显示6张

14:39.930 --> 14:41.930
所以说我这里判断一下

14:41.930 --> 14:43.930
如果这个I

14:44.930 --> 14:45.930
这个I

14:45.930 --> 14:46.930
它是从零开始的嘛

14:46.930 --> 14:48.930
大家自己去活一下

14:48.930 --> 14:49.930
这个东西不重要了

14:49.930 --> 14:50.930
这东西不重要

14:50.930 --> 14:51.930
I加1

14:51.930 --> 14:54.930
除以6的余数等于零

14:54.930 --> 14:55.930
除以6的余数等于零

14:55.930 --> 14:56.930
那么就是每6张

14:56.930 --> 14:57.930
我换一次行

14:57.930 --> 14:58.930
换一个行

14:58.930 --> 15:00.930
Result拼借一个写钢N

15:00.930 --> 15:02.930
换一个行就完事了

15:02.930 --> 15:03.930
每6张换一个行

15:03.930 --> 15:05.930
这个东西不是很重要

15:05.930 --> 15:06.930
主要是你体验一下

15:06.930 --> 15:07.930
体验一下

15:07.930 --> 15:08.930
体验一下这个

15:08.930 --> 15:09.930
它的智能提示

15:09.930 --> 15:12.930
以及它的内行检查

15:12.930 --> 15:13.930
好

15:13.930 --> 15:14.930
评价完成之后

15:14.930 --> 15:15.930
我们最后循环结束过后

15:15.930 --> 15:16.930
再输出

15:16.930 --> 15:17.930
Result

15:17.930 --> 15:19.930
把评价成一个制服串

15:19.930 --> 15:20.930
来输出

15:20.930 --> 15:21.930
保存一下

15:21.930 --> 15:22.930
咱们再看

15:23.930 --> 15:25.930
打印出来就这样的结果了

15:25.930 --> 15:26.930
这样的结果

15:26.930 --> 15:27.930
OK

15:27.930 --> 15:29.930
你们可以自己去试一下

15:29.930 --> 15:30.930
主要是体验

15:30.930 --> 15:31.930
TS

15:31.930 --> 15:32.930
它的内行检查

15:32.930 --> 15:34.930
给我们代码开发带来的方便

15:34.930 --> 15:36.930
你看我们整个开发过程

15:36.930 --> 15:37.930
没有出现任何的错误

15:37.930 --> 15:38.930
是因为

15:38.930 --> 15:39.930
它一步一步

15:39.930 --> 15:40.930
给我们进行了内行检查

15:40.930 --> 15:42.930
而且我们开发过程是很轻松的

15:42.930 --> 15:43.930
为什么很轻松

15:43.930 --> 15:44.930
因为

15:44.930 --> 15:45.930
每个备地方

15:45.930 --> 15:47.930
它都有完整的智能提示

15:47.930 --> 15:49.930
它怎么来的智能提示

15:49.930 --> 15:51.930
就是基于内行检查

15:51.930 --> 15:52.930
才有智能提示

15:52.930 --> 15:53.930
它检查到

15:53.930 --> 15:54.930
这是一个数组

15:54.930 --> 15:55.930
所以说

15:55.930 --> 15:56.930
它知道数组里面有蝴蚁

15:56.930 --> 15:57.930
它检查到

15:57.930 --> 15:58.930
数组的蝴蚁

15:58.930 --> 15:59.930
回掉函数里边

15:59.930 --> 16:00.930
第一个是数组的某一项

16:00.930 --> 16:02.930
而某一项

16:02.930 --> 16:03.930
就是数组

16:03.930 --> 16:06.930
数组是NormalCard的数组

16:06.930 --> 16:07.930
因此数组的每一项

16:07.930 --> 16:08.930
这Card的辨量

16:08.930 --> 16:10.930
这Card的辨量

16:10.930 --> 16:11.930
就是一个NormalCard

16:11.930 --> 16:12.930
因此它知道

16:12.930 --> 16:14.930
这Card里面有Card属性

16:14.930 --> 16:16.930
有Mark属性

16:16.930 --> 16:17.930
在GS里面

16:17.930 --> 16:20.930
这些场景都是不可能完成的

16:20.930 --> 16:21.930
不是说功能不可完成

16:21.930 --> 16:22.930
这种智能提示

16:22.930 --> 16:24.930
是不可能出现的

16:24.930 --> 16:25.930
OK

16:25.930 --> 16:27.930
好 这是关于这个联系

16:27.930 --> 16:28.930
这个联系

16:28.930 --> 16:29.930
我们后边讲了

16:29.930 --> 16:30.930
更多的知识过后

16:30.930 --> 16:32.930
还会继续来改造

16:32.930 --> 16:34.930
复刻牌的这么一个小联系

16:34.930 --> 16:35.930
还会继续改造

16:35.930 --> 16:36.930
OK 大家下去

16:36.930 --> 16:37.930
把这个地方完成

16:37.930 --> 16:38.930
OK

16:38.930 --> 16:40.930
那么咱们本节奏到这里了

16:40.930 --> 16:41.930
拜拜

