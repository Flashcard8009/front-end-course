WEBVTT

00:00.370 --> 00:04.370
好 接下来咱们再来看 接口代码

00:04.370 --> 00:06.370
具体该如何输解

00:06.370 --> 00:09.370
在TS里面我们如何来去输解接口代码呢

00:09.370 --> 00:11.370
我们分为几个部分来讲啊

00:11.370 --> 00:16.370
因为接口它是约束内 约束对象 约束函数的契约

00:16.370 --> 00:21.370
因此呢 我们这里分开分别来说一下

00:21.370 --> 00:25.370
内这个东西呢 由于现在呢 我还没有讲到

00:25.370 --> 00:27.370
在TS里面我们还没有讲到内

00:27.370 --> 00:30.370
在TS里面已经有内了 对吧 已经有内这个概念了

00:30.370 --> 00:34.370
但是呢 我们后边会讲 专门来讲TS的内

00:34.370 --> 00:38.370
转TS的内的时候呢 我们再去说这个接口

00:38.370 --> 00:41.370
再去说这个接口 跟内怎么去联用

00:41.370 --> 00:44.370
好 我们先说对象 内这一块呢 我们先跳过

00:44.370 --> 00:46.370
讲内的时候再说 先说对象

00:46.370 --> 00:53.370
第一个问题 如何接口约束对象

00:53.370 --> 00:56.370
那么怎么来约束呢 首先我们要定义一个接口

00:56.370 --> 00:58.370
就跟没据一样 跟内形别密一样

00:58.370 --> 01:02.370
我们先定义一个内形 接口提起是什么

01:02.370 --> 01:05.370
就是一个内形 对吧 好 我们来定义一个内形

01:05.370 --> 01:09.370
怎么定义呢 定义接口的话是用interface

01:09.370 --> 01:13.370
定义没据是用in的 定义接口是用interface

01:13.370 --> 01:16.370
后边跟上一个接口的名字 接口的名字

01:16.370 --> 01:19.370
跟那个没据是一样的 跟上一个没据的名字

01:19.370 --> 01:22.370
这里跟上一个接口的名字 比方说U字

01:22.370 --> 01:25.370
有一个用户对象 用户对象

01:25.370 --> 01:29.370
我就定了一个接口 表示来约束用户对象的

01:29.370 --> 01:32.370
一个用户对象里边 应该有哪些东西呢

01:32.370 --> 01:36.370
我们就在这里一次来书写 比方说用户的姓名

01:36.370 --> 01:40.370
必须是一个支付串 用户的年龄 必须是个number

01:40.370 --> 01:43.370
这个代码我们就写了好多好多次了

01:43.370 --> 01:46.370
就约束完了 比方说约束完了

01:46.370 --> 01:49.370
有了这样的一个接口之后 后边比方说

01:49.370 --> 01:52.370
我要定义一个用户 U

01:52.370 --> 01:55.370
我要对它进行约束一下 你必须是一个用户

01:55.370 --> 01:58.370
你必须是一个用户 对它进行类型的约束

01:58.370 --> 02:02.370
约束之后 后边你书写代码的时候

02:02.370 --> 02:04.370
你是不是就必须要给一个内容属性 对吧

02:04.370 --> 02:06.370
而且还必须是一个支付串

02:06.370 --> 02:09.370
然后要给一个A级属性 必须要是一个数字

02:09.370 --> 02:11.370
就完事了 就这么简单

02:11.370 --> 02:13.370
接口 你看约束对象 就这样子的约束

02:13.370 --> 02:16.370
明白了吧 这就是接口约束对象

02:16.370 --> 02:20.370
那么看到这里呢 有些同学肯定想问了

02:20.370 --> 02:24.370
这个玩意儿 跟我们之前学的内雄别名

02:24.370 --> 02:27.370
有啥区别呢 好像没啥区别啊

02:27.370 --> 02:31.370
好 我给大家写一下 内雄别名 Type

02:31.370 --> 02:34.370
U字 以前我们是这样子写的

02:34.370 --> 02:39.370
Name String Age Number

02:39.370 --> 02:41.370
我们以前是这样写的 对吧

02:41.370 --> 02:44.370
是不是没有区别 只是写法变了一下

02:44.370 --> 02:46.370
确实 确实

02:46.370 --> 02:49.370
接口了 跟内雄别名

02:49.370 --> 02:53.370
在目前阶段 在现阶段区别不大

02:53.370 --> 02:56.370
区别不大 那么他们有没有区别呢

02:56.370 --> 02:59.370
他们是有区别的 他们最大的区别在哪

02:59.370 --> 03:03.370
他们最大的区别在这 约束内这一块

03:03.370 --> 03:06.370
主要是在这 但是由于目前

03:06.370 --> 03:08.370
我们还没有讲到类

03:08.370 --> 03:11.370
因此你这节课看上去了

03:11.370 --> 03:14.370
他们两个好像没啥区别

03:14.370 --> 03:17.370
所以说有的时候 我发现有的教程里边

03:17.370 --> 03:20.370
讲TS的时候 讲 TypeScript的时候

03:20.370 --> 03:23.370
他就说 接口了 内雄别名 你任选一个

03:23.370 --> 03:25.370
你喜欢用哪个 用哪个

03:25.370 --> 03:27.370
其实他们是有个很重要的区别的

03:27.370 --> 03:30.370
就在约束内这一块 但是我们还没有讲到类

03:30.370 --> 03:32.370
因此这节课 你可以认为

03:32.370 --> 03:34.370
他们没有多少的区别

03:34.370 --> 03:36.370
其实他们后面还是有一点点小区别的

03:36.370 --> 03:38.370
就算把这个跑开

03:38.370 --> 03:40.370
把这个东西跑开 他们还是有一点小区别

03:40.370 --> 03:42.370
我们以后再说

03:42.370 --> 03:45.370
但是我个人建议

03:45.370 --> 03:48.370
在绝大部分场景下边

03:48.370 --> 03:50.370
像这种约束对象的时候

03:50.370 --> 03:52.370
建议大家使用这种方式

03:52.370 --> 03:55.370
使用接口的方式 为什么呢

03:55.370 --> 03:58.370
习惯 个人习惯

03:58.370 --> 04:01.370
以这是练习一下这个接口的使用

04:01.370 --> 04:04.370
二者是为以后

04:04.370 --> 04:07.370
书写约束内的代码做准备

04:07.370 --> 04:08.370
因为我们后边

04:08.370 --> 04:11.370
你会看到很多的第三方的一些程序

04:11.370 --> 04:12.370
第三方很酷

04:12.370 --> 04:14.370
他们里边用的TS代码

04:14.370 --> 04:16.370
很多地方都是使用接口

04:16.370 --> 04:20.370
没有使用内容别名

04:20.370 --> 04:22.370
我个人建议

04:22.370 --> 04:25.370
其实这节课无所谓的 两个都可以用

04:25.370 --> 04:27.370
这里大家说一下

04:27.370 --> 04:28.370
在约束对象的情况下

04:28.370 --> 04:31.370
这两个其实没有多少的区别

04:31.370 --> 04:35.370
这是接口来约束一个对象

04:35.370 --> 04:36.370
我们来看一下

04:36.370 --> 04:39.370
除了约束对象之外

04:39.370 --> 04:42.370
它还可以约束函数

04:42.370 --> 04:44.370
约束函数

04:44.370 --> 04:46.370
接口

04:46.370 --> 04:49.370
约束函数

04:49.370 --> 04:51.370
这个约束函数

04:51.370 --> 04:53.370
其实有两种情况

04:53.370 --> 04:55.370
一种是在对象里边有个函数

04:55.370 --> 04:56.370
这叫方法 对吧

04:56.370 --> 04:57.370
对象里面的函数

04:57.370 --> 04:59.370
我们通常把它称之为方法

04:59.370 --> 05:01.370
比方说这个用户对象里边

05:01.370 --> 05:02.370
有一个方法

05:02.370 --> 05:03.370
有一个方法

05:03.370 --> 05:04.370
叫打招呼吧

05:04.370 --> 05:08.370
say hello

05:08.370 --> 05:10.370
那么它是一个方法

05:10.370 --> 05:11.370
我们给它约束一下

05:11.370 --> 05:13.370
这个东西是一个方法

05:13.370 --> 05:14.370
那么它没有参数

05:14.370 --> 05:16.370
返回内形为void

05:16.370 --> 05:18.370
我们就简单约束一下

05:18.370 --> 05:19.370
那怎么写呢

05:19.370 --> 05:20.370
约束一个方法

05:20.370 --> 05:22.370
两个括号表示方法的参数

05:22.370 --> 05:24.370
参数里边啥都没有

05:24.370 --> 05:25.370
没有任何东西

05:25.370 --> 05:27.370
返回内形

05:27.370 --> 05:28.370
一个箭头对吧

05:28.370 --> 05:31.370
返回内形一个箭头void

05:31.370 --> 05:32.370
那么表示

05:32.370 --> 05:33.370
它是一个函数

05:33.370 --> 05:35.370
这个函数没有参数

05:35.370 --> 05:36.370
这个函数

05:36.370 --> 05:38.370
返回内形是void

05:38.370 --> 05:41.370
注意你这里不能去写函数实现

05:41.370 --> 05:43.370
千万不要去写函数实现

05:43.370 --> 05:46.370
因为它没有实现的

05:46.370 --> 05:50.370
因为这个接口跟我们的内形别名一样

05:50.370 --> 05:53.370
它不会出现在编译结果里边

05:53.370 --> 05:55.370
编译结果里边是不会有这个东西的

05:55.370 --> 05:56.370
这个东西会消失的

05:56.370 --> 05:57.370
是没有这个东西的

05:57.370 --> 05:59.370
不用咱们看一下了

05:59.370 --> 06:01.370
这里就马上了

06:01.370 --> 06:03.370
我们这里编译一下

06:03.370 --> 06:04.370
tsc

06:04.370 --> 06:05.370
对不对

06:05.370 --> 06:06.370
应该使用什么

06:06.370 --> 06:07.370
我们上一课学的

06:07.370 --> 06:11.370
上一课做的npm run build

06:11.370 --> 06:14.810
没有是吧

06:14.810 --> 06:16.810
上一课这边

06:16.810 --> 06:18.810
这边我们带了个卡牌

06:18.810 --> 06:19.810
卡牌程序里面配置的

06:19.810 --> 06:20.810
这边还没有配置

06:20.810 --> 06:21.810
我们配置一下

06:21.810 --> 06:23.810
build

06:23.810 --> 06:24.810
这里

06:24.810 --> 06:25.810
rd

06:25.810 --> 06:26.810
删除目录

06:26.810 --> 06:28.810
然后写钢s

06:28.810 --> 06:29.810
写钢q

06:29.810 --> 06:30.810
删除dist

06:30.810 --> 06:32.810
然后再运行tsc

06:32.810 --> 06:36.120
把这个写一下

06:37.120 --> 06:40.120
npm run build

06:40.120 --> 06:42.120
先删除这个文件夹

06:42.120 --> 06:44.120
然后再重新编译

06:44.120 --> 06:46.120
编译完成

06:46.120 --> 06:47.120
编译完成

06:47.120 --> 06:48.120
大家看一下

06:48.120 --> 06:49.120
结果里边

06:49.120 --> 06:51.120
结果不见了

06:51.120 --> 06:52.120
消失了

06:52.120 --> 06:54.120
所以跟内形别名一样

06:54.120 --> 06:55.120
跟内形别名一样

06:55.120 --> 06:57.120
这里我们记一笔

06:57.120 --> 07:01.120
接口和内形别名一样

07:01.120 --> 07:04.120
接口不出现在

07:04.120 --> 07:06.120
编译结果中

07:06.120 --> 07:08.120
在编译结果中

07:08.120 --> 07:10.120
它只是在你写代码的阶段

07:10.120 --> 07:12.120
对你的代码进行约束的

07:12.120 --> 07:13.120
因此

07:13.120 --> 07:15.120
这里你肯定不能写实现

07:15.120 --> 07:16.120
你实现怎么运行的

07:16.120 --> 07:18.120
它又不在编译结果里面

07:18.120 --> 07:19.120
因此你不能写实现的

07:19.120 --> 07:20.120
say hello

07:20.120 --> 07:21.120
你可以这样子书写

07:21.120 --> 07:23.120
这是地种书写方式

07:23.120 --> 07:25.120
表示这个东西是一个成员

07:25.120 --> 07:27.120
这个成员是一个寒树

07:27.120 --> 07:28.120
寒树没有参数

07:28.120 --> 07:29.120
反回内形为臥意的

07:29.120 --> 07:30.120
这是地种书写方式

07:31.120 --> 07:32.120
第二种书写方式

07:32.120 --> 07:34.120
你可以这样子写

07:34.120 --> 07:36.120
用ES6那种方法的书写方式

07:36.120 --> 07:38.120
表示这是一个寒树

07:38.120 --> 07:39.120
它没有参数

07:39.120 --> 07:41.120
帽号反回内形为臥意的

07:41.120 --> 07:43.120
都行

07:43.120 --> 07:44.120
两种写法都行

07:44.120 --> 07:46.120
效果是完全一样的

07:46.120 --> 07:47.120
好

07:47.120 --> 07:48.120
我们写了这个约束过后

07:48.120 --> 07:49.120
那么一个用户里边

07:49.120 --> 07:51.120
你就不能不

07:51.120 --> 07:52.120
没有这个寒树了

07:52.120 --> 07:53.120
必须要有这个寒树

07:53.120 --> 07:54.120
say hello

07:54.120 --> 07:55.120
因此现在它爆错了

07:55.120 --> 07:56.120
它告诉你

07:56.120 --> 07:57.120
提示得很明确了

07:57.120 --> 07:58.120
对吧 指着它

07:58.120 --> 07:59.120
它告诉你 say hello

07:59.120 --> 08:00.120
它说已经

08:00.120 --> 08:01.120
它声明了

08:01.120 --> 08:02.120
已经声明过了

08:02.120 --> 08:03.120
这个接口里面

08:03.120 --> 08:04.120
必须要有这个东西

08:04.120 --> 08:05.120
但是里面有

08:05.120 --> 08:06.120
我们写上这么一个 say hello

08:06.120 --> 08:08.120
写上这么一个寒树

08:08.120 --> 08:09.120
让我说

08:09.120 --> 08:10.120
随便写吧

08:10.120 --> 08:11.120
这个无所谓

08:12.120 --> 08:13.120
保存一下

08:13.120 --> 08:14.120
没问题了

08:14.120 --> 08:15.120
这是把寒树

08:15.120 --> 08:17.120
作为一个方法

08:17.120 --> 08:18.120
作为一个对象的成员

08:18.120 --> 08:19.120
来进行约束

08:19.120 --> 08:20.120
其实跟之前是一样的

08:20.120 --> 08:21.120
没有什么区别

08:21.120 --> 08:22.120
当然了

08:22.120 --> 08:24.120
也可以使用内形别名

08:24.120 --> 08:26.120
效果是完全一样的

08:26.120 --> 08:27.120
一点区别都没有

08:27.120 --> 08:28.120
效果完全一样

08:28.120 --> 08:31.120
这里内形别名 say hello

08:32.120 --> 08:35.120
或者是 say hello

08:35.120 --> 08:36.120
这样子写

08:36.120 --> 08:37.120
也可以

08:37.120 --> 08:38.120
两种写法都可以

08:38.120 --> 08:39.120
没有任何区别

08:39.120 --> 08:41.120
在这个场景下边

08:41.120 --> 08:42.120
是没有任何区别的

08:42.120 --> 08:43.120
内形别名

08:43.120 --> 08:45.120
和接口的两种书写方式

08:45.120 --> 08:48.120
这是关于寒树的约束

08:49.120 --> 08:50.120
那么有的时候

08:50.120 --> 08:52.120
我们约束的寒树

08:52.120 --> 08:53.120
可能不是一个

08:53.120 --> 08:54.120
对象里边的成员

08:54.120 --> 08:55.120
我们可能会

08:55.120 --> 08:57.120
直接约束寒树

08:57.120 --> 08:59.120
这种情况发生在什么时候呢

08:59.120 --> 09:01.120
比方说通常会发生在这

09:01.120 --> 09:02.120
这种情况

09:03.120 --> 09:04.120
给大家看一下

09:04.120 --> 09:05.120
我上面注释掉了

09:05.120 --> 09:07.120
给大家看一下下面的单

09:07.120 --> 09:08.120
比方说

09:08.120 --> 09:10.120
我有这么一个寒树

09:10.120 --> 09:11.120
这么一个寒树

09:11.120 --> 09:12.120
这个寒树呢

09:12.120 --> 09:13.120
名字叫做

09:13.120 --> 09:15.120
come back

09:16.120 --> 09:17.120
或者叫求和吧

09:17.120 --> 09:18.120
求和

09:19.120 --> 09:20.120
求和

09:20.120 --> 09:21.120
这个求和呢

09:21.120 --> 09:23.120
你要给我传一个

09:23.120 --> 09:25.120
数字的数字

09:25.120 --> 09:26.120
numbers

09:26.120 --> 09:28.120
它是一个数字的数组

09:28.120 --> 09:29.120
给大家约束一下

09:30.120 --> 09:31.120
另外呢

09:31.120 --> 09:32.120
我不是对这个数组里面

09:32.120 --> 09:34.120
每一项求和

09:34.120 --> 09:35.120
我可能

09:35.120 --> 09:36.120
有的时候呢

09:36.120 --> 09:38.120
我要求它里面的

09:38.120 --> 09:39.120
积数之和

09:39.120 --> 09:40.120
那些积数

09:40.120 --> 09:41.120
把它加起来

09:41.120 --> 09:43.120
或者是有的时候呢

09:43.120 --> 09:45.120
我要求一个偶数之和

09:46.120 --> 09:47.120
有的时候呢

09:47.120 --> 09:48.120
我要求一个

09:48.120 --> 09:49.120
数数之和

09:49.120 --> 09:50.120
就是

09:50.120 --> 09:51.120
字数只能被一

09:51.120 --> 09:53.120
和字身整出的数字

09:53.120 --> 09:54.120
有的时候呢

09:54.120 --> 09:55.120
我要

09:55.120 --> 09:56.120
把这个数组

09:56.120 --> 09:58.120
第1357这样的

09:58.120 --> 10:00.120
积数位相加

10:00.120 --> 10:01.120
有的时候呢

10:01.120 --> 10:02.120
把它偶数为相加

10:02.120 --> 10:03.120
就是情况有很多

10:03.120 --> 10:04.120
我也不知道

10:04.120 --> 10:05.120
要对哪些东西求和

10:05.120 --> 10:06.120
有的时候呢

10:06.120 --> 10:07.120
我要对各位

10:07.120 --> 10:08.120
就是各位数求和

10:08.120 --> 10:09.120
有的时候呢

10:09.120 --> 10:10.120
我要对

10:11.120 --> 10:12.120
三位数求和

10:13.120 --> 10:14.120
就是很多情况

10:14.120 --> 10:15.120
你并不知道

10:15.120 --> 10:17.120
它要对什么东西求和

10:17.120 --> 10:18.120
那么这个寒树

10:18.120 --> 10:19.120
问大家这个问题

10:19.120 --> 10:21.120
该怎么来设计

10:21.120 --> 10:22.120
该怎么来设计

10:22.120 --> 10:23.120
如果你只写一个寒树

10:23.120 --> 10:24.120
我这个寒树

10:24.120 --> 10:25.120
怎么知道

10:25.120 --> 10:26.120
要对哪些东西求和

10:26.120 --> 10:28.120
哪些东西是不求和的

10:29.120 --> 10:30.120
应该怎么来设计这个寒树呢

10:32.120 --> 10:33.120
好

10:33.120 --> 10:34.120
带大家回忆一下

10:34.120 --> 10:36.120
数组里边的一些知识

10:37.120 --> 10:38.120
数组里边

10:38.120 --> 10:39.120
我们学过了

10:39.120 --> 10:40.120
很多很多的寒树了

10:40.120 --> 10:41.120
对吧

10:41.120 --> 10:42.120
有哪些寒树呢

10:42.120 --> 10:43.120
我们先说看

10:43.120 --> 10:44.120
第1个

10:44.120 --> 10:45.120
for一起

10:45.120 --> 10:46.120
这个寒树

10:46.120 --> 10:48.120
这个寒树在做什么

10:49.120 --> 10:50.120
在寻环

10:50.120 --> 10:51.120
便利这个数组

10:51.120 --> 10:52.120
对不对

10:52.120 --> 10:53.120
在便利数组

10:53.120 --> 10:54.120
那么

10:54.120 --> 10:55.120
如果你想一想

10:55.120 --> 10:57.120
你射身处立的想一想

10:57.120 --> 10:59.120
你在写这个寒树的时候

10:59.120 --> 11:00.120
你在便利数组

11:00.120 --> 11:01.120
便利数组很好说

11:01.120 --> 11:03.120
一共for寻环就可以便利

11:03.120 --> 11:04.120
便利数组的时候

11:04.120 --> 11:06.120
有一个问题就是

11:06.120 --> 11:08.120
我把数组的每一项拿到了

11:08.120 --> 11:09.120
比方说

11:09.120 --> 11:10.120
你自己在写这个寒树

11:10.120 --> 11:11.120
for一起

11:11.120 --> 11:12.120
这个寒树是你自己写的

11:12.120 --> 11:13.120
for一起

11:13.120 --> 11:15.120
我把数组的每一项

11:15.120 --> 11:16.120
写出来

11:16.120 --> 11:17.120
for一起

11:17.120 --> 11:19.120
我把数组的每一项拿到了

11:19.120 --> 11:20.120
我要做什么事呢

11:20.120 --> 11:21.120
问题是

11:21.120 --> 11:22.120
我把每一项拿出来干嘛呢

11:22.120 --> 11:24.120
我要输出吗

11:24.120 --> 11:25.120
我把每一项拿到了过后

11:25.120 --> 11:27.120
我要进行某个运算吗

11:27.120 --> 11:28.120
我并不知道啊

11:28.120 --> 11:30.120
我不知道他要做什么

11:30.120 --> 11:31.120
因此应该写什么

11:31.120 --> 11:32.120
这个寒树里面

11:32.120 --> 11:33.120
参数应该写什么

11:33.120 --> 11:35.120
写一个毁掉

11:35.120 --> 11:36.120
写一个毁掉寒树

11:36.120 --> 11:38.120
我把数组的每一项拿到过后

11:38.120 --> 11:39.120
我给你这个寒树

11:39.120 --> 11:40.120
把这个东西给你

11:40.120 --> 11:41.120
你去处理

11:41.120 --> 11:42.120
这就是毁掉

11:42.120 --> 11:43.120
再比方说

11:43.120 --> 11:45.120
数组里面不是一个寒树

11:45.120 --> 11:47.120
叫做filter嘛对吧

11:47.120 --> 11:48.120
过滤的对吧

11:48.120 --> 11:51.120
假设你自己来写这个寒树的时候

11:51.120 --> 11:52.120
你会怎么写呢

11:52.120 --> 11:55.120
你会把满足条件的保留

11:55.120 --> 11:57.120
不满足条件的扔掉

11:57.120 --> 11:59.120
只保留那些满足条件的

11:59.120 --> 12:02.120
但是问题是条件失啥呢

12:02.120 --> 12:03.120
条件失啥呢

12:03.120 --> 12:05.120
问题是你怎么知道条件失啥

12:05.120 --> 12:07.120
这个条件是可能很多遍的

12:07.120 --> 12:08.120
因此呢

12:08.120 --> 12:10.120
你会使用一个毁掉寒树

12:10.120 --> 12:11.120
让他来告诉你

12:11.120 --> 12:13.120
我把每一项数字给你

12:13.120 --> 12:14.120
你告诉我这个数字

12:14.120 --> 12:16.120
或者是把数字的每一项

12:16.120 --> 12:17.120
不一定是数字

12:17.120 --> 12:18.120
把数字的每一项告诉你

12:18.120 --> 12:20.120
你告诉我这一项

12:20.120 --> 12:21.120
是不是满足条件

12:21.120 --> 12:23.120
返回个true 或者是force

12:23.120 --> 12:24.120
明白吧

12:24.120 --> 12:26.120
我们可以通过毁掉寒树来

12:26.120 --> 12:27.120
解决这个问题

12:27.120 --> 12:28.120
那么这里也是一样

12:28.120 --> 12:30.120
我在求核

12:30.120 --> 12:31.120
求核呢

12:31.120 --> 12:33.120
我会把每一项拿出来看一下

12:33.120 --> 12:34.120
看一下这一项

12:34.120 --> 12:36.120
是不是满足求核的条件

12:36.120 --> 12:38.120
能不能把它来进行求核

12:38.120 --> 12:39.120
如果可以的话

12:39.120 --> 12:40.120
我就进行求核

12:40.120 --> 12:41.120
如果不行的话

12:41.120 --> 12:42.120
我就不求核

12:42.120 --> 12:43.120
明白这个意思吗

12:43.120 --> 12:44.120
所以说

12:44.120 --> 12:45.120
第二个参数呢

12:45.120 --> 12:47.120
我们会传一个毁掉寒树进来

12:47.120 --> 12:49.120
我会把数组的每一项给力

12:49.120 --> 12:50.120
然后你告诉我

12:50.120 --> 12:52.120
是否满足条件

12:52.120 --> 12:54.120
是否满足条件

12:54.120 --> 12:55.120
我们写个毁掉寒树

12:55.120 --> 12:56.120
比方说就写

12:56.120 --> 12:57.120
要取个名字吧

12:57.120 --> 12:58.120
就callback

12:58.120 --> 13:00.120
以前呢

13:00.120 --> 13:01.120
在GS里面

13:01.120 --> 13:02.120
我们这样写就完事了

13:02.120 --> 13:04.120
还没有这个类型约束

13:04.120 --> 13:05.120
这是个数组

13:05.120 --> 13:07.120
我们只能在脑袋里面去记忆

13:07.120 --> 13:08.120
所以说

13:08.120 --> 13:09.120
我说

13:09.120 --> 13:10.120
前端开发者

13:10.120 --> 13:12.120
真的是记忆力完全的

13:12.120 --> 13:14.120
还要记好多好多的东西

13:14.120 --> 13:15.120
如果你记不住的话

13:15.120 --> 13:17.120
你只能去查文档

13:17.120 --> 13:18.120
只能去查文档

13:18.120 --> 13:20.120
百度或者是他的官方文档

13:20.120 --> 13:23.120
因此要全靠全视频记忆力

13:23.120 --> 13:24.120
但是自从有了TS过后

13:24.120 --> 13:26.120
我们不需要靠记忆力了

13:26.120 --> 13:28.120
他会随时随地的提示我

13:28.120 --> 13:29.120
无论是智能提示

13:29.120 --> 13:30.120
还是及时的爆出

13:30.120 --> 13:31.120
都在提示我们

13:31.120 --> 13:32.120
应该怎么去输携带吗

13:32.120 --> 13:34.120
我们有了类型约束了

13:34.120 --> 13:35.120
好

13:35.120 --> 13:36.120
那么现在呢

13:36.120 --> 13:38.120
我们要对他来进行约束

13:38.120 --> 13:39.120
他是个寒树

13:39.120 --> 13:41.120
我怎么来对他进行约束呢

13:42.120 --> 13:43.120
同样的道理

13:43.120 --> 13:45.120
寒树也是可以约束的

13:45.120 --> 13:46.120
我们怎么约束

13:46.120 --> 13:48.120
我们来约束一下这个寒树

13:48.120 --> 13:50.120
这个寒树有几个参数呢

13:50.120 --> 13:52.120
你觉得他有几个参数

13:53.120 --> 13:55.120
我要把树主的每一项拿出来

13:55.120 --> 13:57.120
给这个寒树

13:57.120 --> 13:59.120
给这个寒树

13:59.120 --> 14:00.120
是不是

14:00.120 --> 14:01.120
是不是

14:01.120 --> 14:02.120
这个寒树有一个参数

14:02.120 --> 14:03.120
这个参数就是给的

14:03.120 --> 14:04.120
给的什么

14:04.120 --> 14:05.120
给的数字

14:05.120 --> 14:07.120
把树主的每一项拿出来给他

14:07.120 --> 14:09.120
因此他参数是一个数字

14:10.120 --> 14:11.120
寒树是一个数字

14:11.120 --> 14:12.120
有一个参数

14:12.120 --> 14:14.120
有没有反悔值呢

14:14.120 --> 14:15.120
有 肯定有反悔值

14:15.120 --> 14:17.120
我调用你这个寒树之后

14:17.120 --> 14:18.120
你要告诉我

14:18.120 --> 14:20.120
它是不是满足条件

14:20.120 --> 14:21.120
是和不是

14:21.120 --> 14:22.120
就是反悔值

14:22.120 --> 14:23.120
我把数字给你

14:23.120 --> 14:24.120
你要告诉我

14:24.120 --> 14:25.120
它是不是满足条件

14:25.120 --> 14:26.120
反悔值是啥

14:26.120 --> 14:27.120
反悔类型

14:27.120 --> 14:28.120
就是不

14:28.120 --> 14:29.120
不利

14:29.120 --> 14:31.120
这就是寒树的格式

14:32.120 --> 14:33.120
那么

14:33.120 --> 14:35.120
如果我们的以后的代码中

14:35.120 --> 14:37.120
经常出现这样的寒树格式

14:37.120 --> 14:40.120
经常出现这样的寒树格式

14:40.120 --> 14:41.120
我们就可以

14:41.120 --> 14:44.120
把这个约束单独提出来

14:44.120 --> 14:47.120
形成一个内雄别名

14:47.120 --> 14:48.120
或者是接口

14:48.120 --> 14:50.120
我们先用内雄别名写一下

14:50.120 --> 14:51.120
内雄别名很好写

14:51.120 --> 14:52.120
tab

14:52.120 --> 14:53.120
怎么写呢

14:53.120 --> 14:55.120
就是条件

14:55.120 --> 14:56.120
对吧 条件

14:56.120 --> 14:58.120
OK 就是condition

14:58.120 --> 14:59.120
比方说

14:59.120 --> 15:00.120
我们给他取这么个名字

15:00.120 --> 15:01.120
condition

15:01.120 --> 15:02.120
条件

15:02.120 --> 15:03.120
条件是啥呢

15:03.120 --> 15:04.120
它是一个寒树

15:04.120 --> 15:05.120
一个回调寒树

15:05.120 --> 15:07.120
我要给你

15:07.120 --> 15:08.120
一个数字

15:08.120 --> 15:10.120
你给我告诉我结果

15:10.120 --> 15:11.120
不利

15:11.120 --> 15:12.120
告诉我一个结果

15:12.120 --> 15:13.120
是不是满足条件

15:13.120 --> 15:15.120
就这么一个寒树

15:15.120 --> 15:16.120
我给他取了个内雄别名

15:16.120 --> 15:17.120
那么这里

15:17.120 --> 15:19.120
我们就可以使用内雄别名了

15:20.120 --> 15:21.120
OK 我们先把他写完

15:21.120 --> 15:22.120
写完再说

15:22.120 --> 15:23.120
那么

15:23.120 --> 15:24.120
求和

15:24.120 --> 15:25.120
求和怎么弄呢

15:25.120 --> 15:26.120
就先定一个辨量

15:26.120 --> 15:27.120
s等于0

15:27.120 --> 15:29.120
存放最弄的结果

15:29.120 --> 15:31.120
然后循环这个数组

15:31.120 --> 15:34.120
佛一起循环这个数组

15:34.120 --> 15:36.120
把数组每一项拿出来

15:36.120 --> 15:37.120
每一项拿出来

15:37.120 --> 15:39.120
拿出来之后呢

15:39.120 --> 15:40.120
怎么办

15:40.120 --> 15:41.120
判断一下

15:41.120 --> 15:42.120
判断一下

15:42.120 --> 15:43.120
callback

15:43.120 --> 15:44.120
这是个寒树

15:44.120 --> 15:46.120
它一定是一个寒树

15:46.120 --> 15:48.120
因为我们这里已经约束了

15:48.120 --> 15:49.120
之前写结实的时候

15:49.120 --> 15:50.120
你还不确定

15:50.120 --> 15:51.120
对吧

15:51.120 --> 15:52.120
你写到这的时候

15:52.120 --> 15:53.120
像我这种

15:53.120 --> 15:55.120
强迫症患者

15:55.120 --> 15:56.120
每次写结实的时候

15:56.120 --> 15:57.120
写到这种代码

15:57.120 --> 15:58.120
没有内情约束的时候

15:58.120 --> 15:59.120
写到这种代码

15:59.120 --> 16:00.120
我心里面都是悬的

16:00.120 --> 16:01.120
万一他不给我

16:01.120 --> 16:02.120
传寒树咋办呢

16:02.120 --> 16:03.120
他给我传个字

16:03.120 --> 16:04.120
传个数字咋办呢

16:04.120 --> 16:05.120
我心里面都是悬的

16:05.120 --> 16:06.120
因此我要在前面

16:06.120 --> 16:07.120
为了安全

16:07.120 --> 16:09.120
我要在前面写一大堆判断

16:09.120 --> 16:12.120
判断你这个callback

16:12.120 --> 16:13.120
callback

16:13.120 --> 16:14.120
是不是寒树

16:14.120 --> 16:15.120
我会这样写

16:15.120 --> 16:18.120
taple callback

16:18.120 --> 16:20.120
是不是一个方形

16:20.120 --> 16:21.120
是不是一个寒树

16:21.120 --> 16:22.120
我们都会这样写

16:22.120 --> 16:23.120
没有办法

16:23.120 --> 16:24.120
没有办法

16:24.120 --> 16:25.120
而且我就算判断出来

16:25.120 --> 16:26.120
它是寒树

16:26.120 --> 16:27.120
我也不知道

16:27.120 --> 16:28.120
它的参数

16:28.120 --> 16:30.120
是不是一个数字

16:30.120 --> 16:31.120
我也不知道

16:31.120 --> 16:32.120
它是返回了内情

16:32.120 --> 16:33.120
是不是一个布尔

16:33.120 --> 16:34.120
我也不知道的

16:34.120 --> 16:35.120
所以说以前写

16:35.120 --> 16:36.120
接也审谈

16:36.120 --> 16:37.120
我心里面总是悬的

16:37.120 --> 16:38.120
没有安全感

16:38.120 --> 16:39.120
你知道吗

16:39.120 --> 16:41.120
那么现在我就有安全感

16:41.120 --> 16:43.120
安全感暴捧

16:43.120 --> 16:44.120
为什么

16:44.120 --> 16:45.120
因为我这里约束了

16:45.120 --> 16:46.120
它一定是一个寒树

16:46.120 --> 16:47.120
你看智能提示

16:47.120 --> 16:48.120
我在雕容它的时候

16:48.120 --> 16:49.120
告诉我

16:49.120 --> 16:50.120
这个一定是一个寒树

16:50.120 --> 16:51.120
你不用想了

16:51.120 --> 16:52.120
它里面是一个数字

16:52.120 --> 16:54.120
你把数字给它就行了

16:54.120 --> 16:55.120
把这个n

16:55.120 --> 16:56.120
数字的每一项给它

16:56.120 --> 16:58.120
它返回的一定是一个布尔

16:58.120 --> 17:01.120
一定是一个true和force

17:01.120 --> 17:02.120
条件为真

17:02.120 --> 17:03.120
条件为真怎么办

17:03.120 --> 17:04.120
把它加起来

17:04.120 --> 17:05.120
对不对

17:05.120 --> 17:06.120
把它加起来

17:06.120 --> 17:07.120
加起来最后

17:07.120 --> 17:09.120
把这个s返回

17:09.120 --> 17:10.120
好

17:10.120 --> 17:11.120
这个寒树就写完了

17:11.120 --> 17:13.120
写完了之后

17:13.120 --> 17:14.120
我们就来用一下

17:14.120 --> 17:15.120
试一下

17:15.120 --> 17:16.120
既然都写了

17:16.120 --> 17:18.120
其实也没啥好试的

17:18.120 --> 17:20.120
既然都写了

17:20.120 --> 17:22.120
我们比方说

17:22.120 --> 17:25.120
把所有的基数加起来

17:25.120 --> 17:27.120
把所有的基数加起来

17:27.120 --> 17:28.120
那么这里

17:28.120 --> 17:29.120
第二个参数

17:29.120 --> 17:30.120
你看必须要给我

17:30.120 --> 17:31.120
这个参数就不能不传

17:31.120 --> 17:32.120
因为约束了的

17:32.120 --> 17:33.120
好

17:33.120 --> 17:34.120
第二参数是个回调寒树

17:34.120 --> 17:35.120
回调寒树

17:35.120 --> 17:37.120
我们就给它这样子写

17:37.120 --> 17:38.120
几个箭头寒树

17:39.120 --> 17:40.120
结果

17:40.120 --> 17:41.120
把每一项的数字给我

17:41.120 --> 17:42.120
我来判断这个数字

17:42.120 --> 17:44.120
是不是能够满足条件

17:44.120 --> 17:46.120
条件就是n处一二的

17:46.120 --> 17:47.120
余数不得于你

17:47.120 --> 17:48.120
就是基数

17:48.120 --> 17:49.120
对不对

17:49.120 --> 17:50.120
这是条件

17:50.120 --> 17:51.120
你看返回的结果

17:51.120 --> 17:52.120
这是寒树的返回值

17:52.120 --> 17:53.120
返回的结果

17:53.120 --> 17:54.120
你看是个表达式

17:54.120 --> 17:56.120
这个表达式一定是个布尔

17:56.120 --> 17:57.120
OK

17:57.120 --> 17:58.120
最后得到结果

17:58.120 --> 17:59.120
得到结果

18:00.120 --> 18:01.120
我们输出

18:01.120 --> 18:02.120
console

18:02.120 --> 18:03.120
log

18:03.120 --> 18:04.120
输出

18:05.120 --> 18:06.120
运行一下

18:06.120 --> 18:08.120
npm装

18:08.120 --> 18:11.710
看一下

18:11.710 --> 18:12.710
26

18:12.710 --> 18:13.710
26应该正确了

18:13.710 --> 18:14.710
应该正确的

18:14.710 --> 18:15.710
只需加吧

18:15.710 --> 18:16.710
应该正确的

18:16.710 --> 18:17.710
3加5

18:17.710 --> 18:18.710
26

18:18.710 --> 18:19.710
好

18:19.710 --> 18:20.710
这是

18:20.710 --> 18:21.710
我们这种写法

18:21.710 --> 18:22.710
是用内雄别名

18:22.710 --> 18:23.710
来进行约束的

18:23.710 --> 18:24.710
那么接下来

18:24.710 --> 18:25.710
我们再来看一下

18:25.710 --> 18:27.710
接口是如何来约束的

18:27.710 --> 18:28.710
我们今天

18:28.710 --> 18:29.710
这解构

18:29.710 --> 18:30.710
虽然学的接口

18:30.710 --> 18:32.710
你会感觉他跟内雄别名

18:32.710 --> 18:33.710
差不多

18:33.710 --> 18:34.710
但是你必须要学习接口

18:34.710 --> 18:35.710
因为这是一个

18:35.710 --> 18:37.710
非常非常重要的概念

18:37.710 --> 18:38.710
他的最大区别

18:38.710 --> 18:39.710
再重申一次

18:39.710 --> 18:40.710
他的最大区别

18:40.710 --> 18:42.710
在约束内这一块

18:42.710 --> 18:44.710
但是现在我们还没有讲到内

18:44.710 --> 18:45.710
还没有讲到内

18:45.710 --> 18:47.710
而且在基础部分

18:47.710 --> 18:49.710
咱们学习TS基础部分

18:49.710 --> 18:51.710
我也不会去

18:51.710 --> 18:53.710
不会去说内

18:53.710 --> 18:55.710
跟接口如何来联用

18:55.710 --> 18:56.710
还不会说

18:56.710 --> 18:57.710
因为那一块是比较

18:57.710 --> 18:58.710
有点复杂的

18:58.710 --> 18:59.710
其实代码不复杂

18:59.710 --> 19:00.710
有点着玩

19:00.710 --> 19:02.710
因此我基础部分

19:02.710 --> 19:04.710
不打算讲这一块的知识

19:04.710 --> 19:05.710
要到进阶部分

19:05.710 --> 19:07.710
我们才能真正的明白

19:07.710 --> 19:09.710
接口和内

19:09.710 --> 19:12.710
就是接口和内雄别名

19:12.710 --> 19:14.710
他们的真正的区别

19:14.710 --> 19:16.710
以及接口如何来跟内

19:16.710 --> 19:17.710
进行联动

19:17.710 --> 19:19.710
不好意思

19:19.710 --> 19:23.710
把这段剪了

19:23.710 --> 19:26.710
这里要重说一下

19:26.710 --> 19:29.150
也就是说

19:29.150 --> 19:31.150
要到进阶部分

19:31.150 --> 19:32.150
TS进阶部分

19:32.150 --> 19:34.150
我们才能真正的知道

19:34.150 --> 19:37.150
如何将接口和内

19:37.150 --> 19:38.150
进行联动

19:38.150 --> 19:40.150
并且我们才能知道

19:40.150 --> 19:42.150
接口和内雄别名

19:42.150 --> 19:43.150
真正的区别

19:43.150 --> 19:44.150
在现阶段

19:44.150 --> 19:45.150
我们可以认为

19:45.150 --> 19:46.150
两者差不多

19:46.150 --> 19:47.150
没问题的

19:47.150 --> 19:48.150
但是大家心里面

19:48.150 --> 19:49.150
要有个底

19:49.150 --> 19:50.150
好 下边

19:50.150 --> 19:53.150
我们来写个接口

19:53.150 --> 19:54.150
看一下这个接口

19:54.150 --> 19:56.150
如何来约束一个函数

19:56.150 --> 19:57.150
之前的接口

19:57.150 --> 19:58.150
都是约束对象

19:58.150 --> 19:59.150
两个大括号

19:59.150 --> 20:00.150
表示对象里面的

20:00.150 --> 20:01.150
各种各样的成员

20:01.150 --> 20:03.150
那么怎么来约束函数呢

20:03.150 --> 20:05.150
这样的约束

20:05.150 --> 20:07.150
直接在这个大括号里面

20:07.150 --> 20:09.150
直接在这个大括号里面

20:09.150 --> 20:11.150
书写函数的签名

20:11.150 --> 20:13.150
就不要写函数名字了

20:13.150 --> 20:14.150
不要写函数名字了

20:14.150 --> 20:15.150
直接写签名

20:15.150 --> 20:16.150
因为这个东西

20:16.150 --> 20:17.150
就是函数的名字

20:17.150 --> 20:18.150
怎么写呢

20:18.150 --> 20:19.150
一样的

20:19.150 --> 20:21.150
N number

20:21.150 --> 20:23.150
不理

20:23.150 --> 20:24.150
这个接口

20:24.150 --> 20:25.150
不是

20:25.150 --> 20:27.150
这里是冒号

20:27.150 --> 20:30.150
这里要写冒号

20:30.150 --> 20:31.150
表示的是

20:31.150 --> 20:32.150
这个接口

20:32.150 --> 20:33.150
就是一个

20:33.150 --> 20:35.150
约束的是一个函数

20:35.150 --> 20:37.150
约束的是一个普通函数

20:37.150 --> 20:38.150
这个函数有一个函数N

20:38.150 --> 20:41.150
反回内形为不理

20:41.150 --> 20:42.150
效果是完全一样的

20:42.150 --> 20:44.150
效果完全一样的

20:44.150 --> 20:45.150
其实像这种写法

20:45.150 --> 20:46.150
这种写法

20:46.150 --> 20:47.150
有的时候

20:47.150 --> 20:48.150
我们可以看到

20:48.150 --> 20:49.150
第三方库里面

20:49.150 --> 20:50.150
如果使用TS代码的话

20:50.150 --> 20:52.150
也会看到这种写法

20:52.150 --> 20:54.150
其实这种写法

20:54.150 --> 20:55.150
可以直接写到

20:55.150 --> 20:56.150
内形别名的里面来

20:56.150 --> 20:58.150
也是完全一样的

20:58.150 --> 20:59.150
这里

20:59.150 --> 21:00.150
写过来

21:00.150 --> 21:02.150
你看是完全一样的

21:02.150 --> 21:03.150
是完全一样的

21:03.150 --> 21:04.150
它下面

21:04.150 --> 21:05.150
它也是在约束函数

21:05.150 --> 21:06.150
就这种写法

21:06.150 --> 21:08.150
就是你两个大括号里边

21:08.150 --> 21:11.150
没有任何的成员名称

21:11.150 --> 21:12.150
没有任何的成员

21:12.150 --> 21:14.150
你看我们之前大括号里边

21:14.150 --> 21:15.150
写的成员名称了

21:15.150 --> 21:17.150
N、A、G、C、H、L

21:17.150 --> 21:18.150
都是成员的名称

21:18.150 --> 21:19.150
你的大括号里边

21:19.150 --> 21:21.150
没有任何的成员名称

21:21.150 --> 21:22.150
那么就表示

21:22.150 --> 21:23.150
这个大括号

21:23.150 --> 21:25.150
只是一个定界符而已

21:25.150 --> 21:29.660
只是一个定界符

21:29.660 --> 21:32.660
定界符

21:32.660 --> 21:35.660
表示这里面是具体的约束内容

21:35.660 --> 21:37.660
表示具体的约束内容

21:37.660 --> 21:38.660
而不表示一个对象了

21:38.660 --> 21:40.660
不表示一个对象了

21:40.660 --> 21:41.660
所以说这种写法

21:41.660 --> 21:43.660
在内形别名里面

21:43.660 --> 21:44.660
也可以使用

21:44.660 --> 21:45.660
也可以使用

21:45.660 --> 21:46.660
明白这个意思吗

21:46.660 --> 21:49.660
内形别名以及

21:49.660 --> 21:51.660
接口如何来去约束

21:51.660 --> 21:53.660
一个单个函数

21:53.660 --> 21:54.660
就这样一些

21:55.660 --> 21:57.660
这是这一部分

21:57.660 --> 22:00.660
接口约束函数

22:00.660 --> 22:02.660
好 接下来

22:02.660 --> 22:03.660
咱们再来看

22:03.660 --> 22:04.660
一些新的玩意

22:04.660 --> 22:08.480
接口除了约束对象

22:08.480 --> 22:09.480
约束函数之外

22:09.480 --> 22:10.480
它还可以约束内

22:10.480 --> 22:11.480
对吧

22:11.480 --> 22:12.480
我们以后再说

22:12.480 --> 22:15.480
那么接口还有一个特点

22:15.480 --> 22:18.480
用这个新的一个表达方式

22:18.480 --> 22:22.480
接口可以继承

22:22.480 --> 22:23.480
这个继承这个概念

22:23.480 --> 22:25.480
其实大家接触过

22:25.480 --> 22:27.480
什么时候接触过

22:27.480 --> 22:29.480
在react的时候

22:29.480 --> 22:31.480
你会使用写一个内

22:31.480 --> 22:32.480
对吧

22:32.480 --> 22:33.480
写一个内

22:33.480 --> 22:35.480
这个内去继承

22:35.480 --> 22:37.480
react component

22:37.480 --> 22:38.480
对不对

22:38.480 --> 22:41.480
我们以前写过这么一个代码

22:41.480 --> 22:45.480
就是class my component

22:45.480 --> 22:47.480
然后去extend

22:47.480 --> 22:49.480
react component

22:49.480 --> 22:50.480
对吧

22:50.480 --> 22:51.480
以前我们是这样写的

22:51.480 --> 22:52.480
react是这样写的

22:52.480 --> 22:53.480
对吧

22:53.480 --> 22:55.480
内之间的继承

22:55.480 --> 22:56.480
继承有什么作用呢

22:56.480 --> 22:58.480
当一个纸内

22:58.480 --> 23:00.480
继承了附内之后

23:00.480 --> 23:03.480
当一个内继承了另一个内之后

23:03.480 --> 23:04.480
这个就是纸内

23:04.480 --> 23:05.480
这个就是附内

23:05.480 --> 23:07.480
纸内里边会拥有

23:07.480 --> 23:09.480
附内的所有支援

23:09.480 --> 23:10.480
所有成员

23:10.480 --> 23:11.480
附内里面有哪些属性

23:11.480 --> 23:12.480
附内里面有哪些方法

23:12.480 --> 23:15.480
纸内里面都会拥有

23:15.480 --> 23:16.480
这样子就减少了

23:16.480 --> 23:17.480
很多很多的重复代

23:17.480 --> 23:19.480
这就是继承

23:19.480 --> 23:20.480
好 继承它也表示

23:20.480 --> 23:21.480
一些逻辑性的概念

23:21.480 --> 23:23.480
也表示一些逻辑性的概念

23:23.480 --> 23:24.480
比方说

23:24.480 --> 23:25.480
比方说

23:25.480 --> 23:27.480
这里是主键

23:27.480 --> 23:28.480
我的主键

23:28.480 --> 23:29.480
对吧

23:29.480 --> 23:30.480
你这个我的主键

23:30.480 --> 23:31.480
或者叫band

23:31.480 --> 23:32.480
换灯片主键

23:32.480 --> 23:33.480
换灯片主键

23:33.480 --> 23:34.480
那么这个东西

23:34.480 --> 23:35.480
就是主键

23:35.480 --> 23:36.480
react的主键

23:36.480 --> 23:40.480
换灯片是一个react的主键

23:40.480 --> 23:41.480
你想一想

23:41.480 --> 23:43.480
这个描述能不能描述通

23:43.480 --> 23:44.480
是不是逻辑正确了

23:44.480 --> 23:47.480
换灯片是一个react的主键

23:47.480 --> 23:49.480
只要这个描述能够描述通

23:49.480 --> 23:51.480
他们之间就是继承关系

23:51.480 --> 23:52.480
就是继承关系

23:52.480 --> 23:54.480
这就是继承逻辑上的含义

23:54.480 --> 23:55.480
语意上的含义

23:55.480 --> 23:58.480
接口其实也可以继承

23:58.480 --> 24:00.480
虽然接口它不参与运行

24:00.480 --> 24:02.480
但是也可以通过继承

24:02.480 --> 24:05.480
让一个接口拥有另一个接口的

24:05.480 --> 24:07.480
所有成员

24:07.480 --> 24:08.480
来看一下

24:08.480 --> 24:10.480
接口的继承

24:10.480 --> 24:12.480
这里主事一样

24:15.480 --> 24:16.480
比方说

24:16.480 --> 24:18.480
我这里就随便举个例子吧

24:18.480 --> 24:19.480
随便举个例子

24:19.480 --> 24:21.480
interface只讲语法

24:21.480 --> 24:24.480
比方说有个接口a

24:24.480 --> 24:25.480
有一个接口a

24:25.480 --> 24:27.480
这里面有个成员

24:27.480 --> 24:29.480
有一个成员

24:29.480 --> 24:31.480
比方说t1吧

24:31.480 --> 24:32.480
t1

24:32.480 --> 24:36.480
t1 这不错

24:36.480 --> 24:40.480
然后有一个接口b

24:40.480 --> 24:45.480
它去继承了接口a

24:45.480 --> 24:47.480
它里面有个成员t2

24:47.480 --> 24:49.480
t2是一个Number

24:49.480 --> 24:50.480
随便写的

24:50.480 --> 24:52.480
没有什么实际的含义

24:52.480 --> 24:53.480
好 那么我们看一下

24:53.480 --> 24:54.480
这个接口b

24:54.480 --> 24:57.480
用这个东西来进行约束的时候

24:57.480 --> 24:59.480
我们看一下对对象

24:59.480 --> 25:01.480
会有什么样的约束力

25:01.480 --> 25:03.480
我们约束

25:03.480 --> 25:04.480
u这个变量

25:04.480 --> 25:06.480
为内雄b

25:06.480 --> 25:07.480
那么我们看一下

25:07.480 --> 25:08.480
我要写一个属性t2

25:08.480 --> 25:09.480
必须要写

25:09.480 --> 25:10.480
其实它已经提示力了

25:10.480 --> 25:12.480
已经在提示力了

25:12.480 --> 25:13.480
有两个成员必须要写

25:13.480 --> 25:15.480
一个是t1和t2

25:15.480 --> 25:16.480
两个成员都必须要写

25:16.480 --> 25:18.480
t2必须是一个数字

25:18.480 --> 25:19.480
还不行

25:19.480 --> 25:20.480
还有t1

25:20.480 --> 25:25.480
因为相当于是进行的组合

25:25.480 --> 25:28.480
就是接口b里面

25:28.480 --> 25:32.480
要有接口a里面的所有成员

25:32.480 --> 25:33.480
明白这个意思吗

25:33.480 --> 25:35.480
这是关于接口的继承

25:35.480 --> 25:36.480
是一样的含义

25:36.480 --> 25:38.480
表示的有的时候

25:38.480 --> 25:39.480
我可以通过这种继承

25:39.480 --> 25:42.480
来组合一些接口

25:42.480 --> 25:43.480
接口里面

25:43.480 --> 25:45.480
除了用这种方式来继承之外

25:45.480 --> 25:47.480
除了用这种方式继承之外

25:47.480 --> 25:48.480
还有一种方式

25:48.480 --> 25:51.480
这里我们先写个b

25:51.480 --> 25:52.480
先写个b

25:52.480 --> 25:53.480
不继承了

25:53.480 --> 25:54.480
现在不继承了

25:54.480 --> 25:55.480
那么t1就不能写了

25:55.480 --> 25:56.480
对不对

25:56.480 --> 25:57.480
t1就不能写了

25:57.480 --> 25:58.480
好

25:58.480 --> 26:00.480
然后现在我们再写个接口c

26:00.480 --> 26:02.480
interface c

26:02.480 --> 26:04.480
这里我去继承啥呢

26:04.480 --> 26:05.480
t1

26:05.480 --> 26:07.480
我去继承a

26:07.480 --> 26:08.480
dou

26:08.480 --> 26:10.480
再继承b

26:10.480 --> 26:11.480
可不可以

26:11.480 --> 26:12.480
可以的

26:12.480 --> 26:13.480
没问题

26:13.480 --> 26:14.480
我们写个t3

26:15.480 --> 26:16.480
b

26:17.480 --> 26:18.480
在接口里面

26:18.480 --> 26:20.480
你是可以有多继承的

26:20.480 --> 26:22.480
就是一个接口

26:22.480 --> 26:24.480
可以继承多个

26:24.480 --> 26:26.480
可以继承多个

26:26.480 --> 26:27.480
好

26:27.480 --> 26:28.480
写好这个继承过后

26:28.480 --> 26:30.480
我们再来看

26:30.480 --> 26:32.480
c

26:32.480 --> 26:33.480
约束一下

26:33.480 --> 26:34.480
你看看这里

26:34.480 --> 26:35.480
它要有t2

26:35.480 --> 26:36.480
还不行

26:36.480 --> 26:37.480
还不够

26:37.480 --> 26:39.480
还要有t1

26:39.480 --> 26:40.480
还不够

26:40.480 --> 26:41.480
还要有t3

26:41.480 --> 26:42.480
b

26:42.480 --> 26:43.480
这样才行

26:43.480 --> 26:45.480
接口可以通过继承

26:45.480 --> 26:48.480
来实现多种契约的组合

26:49.480 --> 26:54.110
可以通过接口间

26:55.110 --> 26:58.110
接口之间的继承

26:58.110 --> 27:02.110
实现多种接口的组合

27:02.110 --> 27:04.110
来组合多种接口

27:04.110 --> 27:06.110
那么其实在这个点上

27:06.110 --> 27:08.110
跟我们的类型别名

27:08.110 --> 27:10.110
就已经开始有区别了

27:10.110 --> 27:11.110
已经开始有区别了

27:11.110 --> 27:13.110
类型别名

27:13.110 --> 27:15.110
能不能做到类似的事情

27:15.110 --> 27:17.110
能不能来组合

27:17.110 --> 27:20.110
类型别名其实也可以

27:20.110 --> 27:21.110
但是他们之间

27:21.110 --> 27:22.110
是有一点区别的

27:22.110 --> 27:24.110
如果你要做组合的话

27:24.110 --> 27:26.110
我更加建议使用

27:26.110 --> 27:27.110
更加建议使用接口

27:27.110 --> 27:29.110
我不太建议使用类型别名

27:29.110 --> 27:31.110
我等一下讲讲原因

27:31.110 --> 27:33.110
比方说

27:33.110 --> 27:36.110
这里我们要实现同样的一个效果

27:36.110 --> 27:37.110
用类型别名

27:37.110 --> 27:38.110
来实现同样一个效果

27:38.110 --> 27:40.110
你看我会怎么写

27:40.110 --> 27:42.110
首先是a里面有个t1

27:43.110 --> 27:44.110
type

27:44.110 --> 27:46.110
a里面有个啥

27:46.110 --> 27:48.110
有个t1

27:49.110 --> 27:51.110
这个t1是一个字不错

27:51.110 --> 27:52.110
一样的吧

27:52.110 --> 27:53.110
这个是一样的

27:53.110 --> 27:55.110
好b里面有个t2

27:56.110 --> 27:57.110
type

27:57.110 --> 27:58.110
b

27:58.110 --> 28:00.110
b里面有个t2

28:00.110 --> 28:02.110
是一个number

28:02.110 --> 28:04.110
b里面有个t2是个number

28:04.110 --> 28:05.110
好c他要继承

28:05.110 --> 28:06.110
但是类型别名

28:06.110 --> 28:08.110
是不能继承的

28:08.110 --> 28:09.110
那怎么写呢

28:09.110 --> 28:11.110
我们可以这样子写

28:11.110 --> 28:13.110
c他有啥呢

28:13.110 --> 28:14.110
c他有啥

28:14.110 --> 28:16.110
有t3对吧

28:16.110 --> 28:17.110
t3是一个布尔

28:17.110 --> 28:18.110
一个布尔

28:19.110 --> 28:20.110
这是c的类型

28:20.110 --> 28:21.110
类型约束

28:21.110 --> 28:22.110
一个对象

28:22.110 --> 28:24.110
对象里面必须有t3

28:24.110 --> 28:25.110
一个布尔

28:25.110 --> 28:27.110
然后它同时还得有a

28:27.110 --> 28:28.110
同时还得有b

28:28.110 --> 28:30.110
可以这样子写

28:30.110 --> 28:31.110
and符号

28:31.110 --> 28:32.110
a

28:32.110 --> 28:33.110
and符号

28:33.110 --> 28:34.110
b

28:35.110 --> 28:36.110
你看

28:36.110 --> 28:37.110
不爆错了

28:37.110 --> 28:39.110
那么这个and符号表示什么意思呢

28:39.110 --> 28:41.110
这里咱们记一笔

28:43.110 --> 28:46.110
使用类型别名

28:46.110 --> 28:49.110
可以实现类似的

28:49.110 --> 28:51.110
类似的组合效果

28:53.110 --> 28:55.110
需要通过

28:55.110 --> 28:58.490
这个符号

28:58.490 --> 29:00.490
这个符号

29:00.490 --> 29:01.490
他叫做啥呢

29:01.490 --> 29:03.490
他叫做交叉类型

29:03.490 --> 29:05.490
交叉类型

29:05.490 --> 29:06.490
什么叫做交叉类型

29:06.490 --> 29:07.490
就是把

29:07.490 --> 29:08.490
这是一个类型

29:08.490 --> 29:09.490
你看看

29:09.490 --> 29:10.490
这是类型

29:10.490 --> 29:11.490
它不是对象

29:11.490 --> 29:12.490
这是类型

29:12.490 --> 29:13.490
它在约束一个对象

29:13.490 --> 29:14.490
一向搞清楚

29:14.490 --> 29:15.490
这些东西都是

29:15.490 --> 29:16.490
不参与

29:16.490 --> 29:17.490
不到编译结果里面的

29:17.490 --> 29:18.490
它不是对象

29:18.490 --> 29:19.490
它是类型

29:19.490 --> 29:20.490
它是个对象类型

29:20.490 --> 29:21.490
里面一个属性提算

29:21.490 --> 29:23.490
把三个类型

29:23.490 --> 29:24.490
使用交叉类型

29:24.490 --> 29:26.490
对他们之间使用交叉类型

29:26.490 --> 29:28.490
交叉类型什么意思呢

29:28.490 --> 29:30.490
就是交叉的结果

29:30.490 --> 29:32.490
比方他跟a来交叉

29:32.490 --> 29:33.490
交叉的结果

29:33.490 --> 29:34.490
它要保证

29:34.490 --> 29:36.490
这个结果的类型里面

29:36.490 --> 29:37.490
一定要包含

29:37.490 --> 29:39.490
两者的所有成员

29:39.490 --> 29:40.490
一定要包含

29:40.490 --> 29:41.490
两者的所有成员

29:41.490 --> 29:42.490
那么这就是

29:42.490 --> 29:43.490
这就是交叉类型

29:43.490 --> 29:44.490
交叉类型

29:44.490 --> 29:45.490
那么再去交叉b

29:45.490 --> 29:46.490
大家保证

29:46.490 --> 29:47.490
也就是说

29:47.490 --> 29:48.490
我们最终的结果是

29:48.490 --> 29:49.490
它里面的所有成员

29:49.490 --> 29:50.490
我要有

29:50.490 --> 29:51.490
a里面的成员

29:51.490 --> 29:52.490
我要有

29:52.490 --> 29:53.490
b里面的成员

29:53.490 --> 29:54.490
我也要有

29:54.490 --> 29:55.490
这是交叉类型

29:55.490 --> 29:56.490
所以说

29:56.490 --> 29:57.490
这个类型别名

29:57.490 --> 29:58.490
也可以实现类似的效果

29:58.490 --> 29:59.490
但他们之间

29:59.490 --> 30:00.490
有一些

30:00.490 --> 30:02.490
细微的差异

30:02.490 --> 30:03.490
差异在哪呢

30:03.490 --> 30:05.490
咱们来看一下

30:05.490 --> 30:07.490
首先看接口

30:08.490 --> 30:09.490
首先看接口

30:13.380 --> 30:14.380
接口这里

30:14.380 --> 30:16.380
咱们这样子来

30:16.380 --> 30:17.380
这样子来

30:17.380 --> 30:18.380
接口这里

30:18.380 --> 30:20.380
我在c里边

30:20.380 --> 30:23.380
我写了一个同名的t1

30:23.380 --> 30:25.380
a里面是不是有t1

30:25.380 --> 30:26.380
对吧

30:26.380 --> 30:27.380
支付创

30:27.380 --> 30:28.380
a里面有t1

30:28.380 --> 30:30.380
我把t1改成number

30:30.380 --> 30:31.380
改成number

30:31.380 --> 30:33.380
它这里爆错了

30:34.380 --> 30:35.380
它说

30:35.380 --> 30:36.380
接口c

30:36.380 --> 30:39.380
它错误的扩展了接口a

30:39.380 --> 30:41.380
因为t的类型不兼容

30:41.380 --> 30:43.380
它说不能把number

30:43.380 --> 30:45.380
分配给类型是均

30:45.380 --> 30:46.380
也就是说

30:46.380 --> 30:48.380
在接口里边

30:48.380 --> 30:49.380
你接口里边

30:49.380 --> 30:52.380
你不能去重新覆盖

30:52.380 --> 30:53.380
这东西相当于覆类

30:53.380 --> 30:55.380
叫做覆接口吧

30:55.380 --> 30:57.380
你不能去重新覆盖

30:57.380 --> 31:00.380
覆接口里面的成员

31:00.380 --> 31:01.380
你不能重新覆盖

31:01.380 --> 31:02.380
覆接口的成员

31:02.380 --> 31:03.380
特别是

31:03.380 --> 31:04.380
它类型不兼容的情况下

31:04.380 --> 31:06.380
你不能去重新覆盖

31:06.380 --> 31:08.380
这是接口里面的情况

31:08.380 --> 31:10.380
来记忆

31:10.380 --> 31:12.380
它们的区别是

31:12.380 --> 31:16.710
它们的区别

31:16.710 --> 31:18.710
只接口

31:18.710 --> 31:20.710
不能覆盖

31:20.710 --> 31:22.710
覆接口

31:24.710 --> 31:26.710
覆接口的成员

31:26.710 --> 31:27.710
它不能去覆盖

31:27.710 --> 31:28.710
覆接口的成员

31:28.710 --> 31:31.710
那么再看一下类型别名

31:31.710 --> 31:33.710
其实我们这里不叫

31:33.710 --> 31:34.710
讲的其实也不是类型别名

31:34.710 --> 31:37.710
讲的是交叉类型

31:37.710 --> 31:38.710
接口主持人

31:38.710 --> 31:43.660
现在我们在类型里边

31:43.660 --> 31:45.660
写上T1

31:45.660 --> 31:47.660
A里面是不是有T1

31:47.660 --> 31:49.660
我在这里面写上一个T1

31:49.660 --> 31:50.660
T1这里

31:50.660 --> 31:52.660
A里面是T144

31:52.660 --> 31:53.660
这不算

31:53.660 --> 31:55.660
我来这里的T写上一个Number

31:55.660 --> 31:57.660
不爆错

31:57.660 --> 31:58.660
它这里不爆错的

31:58.660 --> 32:00.660
结果是啥呢

32:00.660 --> 32:02.660
这个T1

32:02.660 --> 32:04.660
它变成了一个啥类型的T1

32:05.660 --> 32:07.660
你看啊变成了个啥类型

32:07.660 --> 32:09.660
它在进行交叉合并的时候

32:09.660 --> 32:12.660
它发现有两个相同的成员

32:12.660 --> 32:13.660
那么它就把两个

32:13.660 --> 32:15.660
这两个成员的类型进行合并的

32:15.660 --> 32:17.660
你看T1

32:17.660 --> 32:18.660
T1是个成员

32:18.660 --> 32:19.660
这个地方的成员

32:19.660 --> 32:21.660
这个类型约束的成员

32:21.660 --> 32:23.660
也是A里面的这个成员

32:23.660 --> 32:24.660
那么这个成员里面是Number

32:24.660 --> 32:26.660
那么A里面的成员是制服串

32:26.660 --> 32:28.660
它把两个类型进行合并

32:28.660 --> 32:29.660
你看这就它们区别

32:29.660 --> 32:30.660
一件细微区别

32:30.660 --> 32:33.660
Number和制服串进行合并

32:33.660 --> 32:34.660
就是交叉

32:34.660 --> 32:36.660
那么数字和制服串交叉

32:36.660 --> 32:37.660
得到一个什么玩意呢

32:37.660 --> 32:38.660
得到一个什么玩意

32:38.660 --> 32:39.660
得到一个很奇怪的玩意

32:39.660 --> 32:40.660
我这里没法复制

32:40.660 --> 32:41.660
我这里确实没法复制

32:41.660 --> 32:42.660
复制啥都不对

32:42.660 --> 32:43.660
复制制服串也不对

32:43.660 --> 32:44.660
复制数字也不对

32:44.660 --> 32:46.660
我给大家看一下吧

32:46.660 --> 32:48.660
这个T1里面很神奇

32:48.660 --> 32:49.660
它是一个制服串

32:49.660 --> 32:51.660
同时又是一个数字

32:51.660 --> 32:54.660
那么它里面就具备了一个啥呢

32:54.660 --> 32:55.660
ToFixed

32:55.660 --> 32:56.660
你看一下

32:56.660 --> 32:57.660
这个函数是哪里面的

32:57.660 --> 32:59.660
是数字里面才有的函数

32:59.660 --> 33:01.660
这个ToFixed

33:01.660 --> 33:04.660
是数字里面才有的函数

33:04.660 --> 33:05.660
然后呢

33:05.660 --> 33:07.660
它又具有了什么

33:07.660 --> 33:09.660
制服串的Chart

33:09.660 --> 33:11.660
你看这个函数

33:11.660 --> 33:13.660
这个函数是制服串里面的函数

33:13.660 --> 33:14.660
也就是说交叉类型

33:14.660 --> 33:15.660
实际上是啥意思

33:15.660 --> 33:18.660
交叉类型就是把两个东西

33:18.660 --> 33:19.660
合并过后

33:19.660 --> 33:21.660
两个的成员都有了

33:21.660 --> 33:23.660
两个的成员都有了

33:23.660 --> 33:24.660
如果你有相同的函数

33:24.660 --> 33:26.660
就变成了不同的函数存在

33:26.660 --> 33:29.660
如果你是不同的内形的话

33:29.660 --> 33:31.660
就把这两个类型再进行合并

33:31.660 --> 33:32.660
那么这里怎么复制

33:32.660 --> 33:33.660
我没法复制

33:33.660 --> 33:34.660
复制啥都不对

33:34.660 --> 33:36.660
所以说不要把制服串跟这种数字

33:36.660 --> 33:37.660
这种基本的类型进行交叉

33:37.660 --> 33:39.660
不要去做这种交叉

33:39.660 --> 33:41.660
这就是他们的区别

33:41.660 --> 33:42.660
我这里能不能复制

33:42.660 --> 33:43.660
其实也可以

33:43.660 --> 33:45.660
我自己写一个类型

33:45.660 --> 33:46.660
自己写一个类型

33:46.660 --> 33:47.660
这个类型

33:47.660 --> 33:48.660
它有制服串的所有成员

33:48.660 --> 33:50.660
也有数字的所有成员

33:50.660 --> 33:52.660
那我就可以复制了

33:52.660 --> 33:54.660
所以说他们的区别

33:54.660 --> 33:56.660
这里一个西围区别就是

33:56.660 --> 33:58.660
使用交叉类型

33:59.660 --> 34:01.660
它不是覆盖

34:01.660 --> 34:06.660
会把相同成员的类型

34:06.660 --> 34:09.660
进行交叉

34:10.660 --> 34:11.660
你把两个类型

34:11.660 --> 34:13.660
两个对象

34:13.660 --> 34:16.660
两个约束对象的类型

34:16.660 --> 34:17.660
进行交叉

34:17.660 --> 34:18.660
你看

34:18.660 --> 34:20.660
可以认为这个A是一个对象

34:20.660 --> 34:21.660
这个地方是一个对象

34:21.660 --> 34:23.660
把两个约束对象的

34:23.660 --> 34:24.660
这两个类型

34:24.660 --> 34:26.660
A和这个类型进行交叉

34:26.660 --> 34:27.660
如果它里面有相同的成员

34:27.660 --> 34:29.660
那么把这个成员继续交叉

34:29.660 --> 34:30.660
就这么一个意思

34:30.660 --> 34:32.660
这是他们的一个西围区别

34:32.660 --> 34:34.660
不用去计

34:34.660 --> 34:36.660
交叉类型其实我们

34:36.660 --> 34:38.660
平时用的不是很多

34:38.660 --> 34:39.660
不算很多

34:39.660 --> 34:40.660
有的时候会用的

34:40.660 --> 34:41.660
会用的

34:41.660 --> 34:42.660
我们更多的时候

34:42.660 --> 34:44.660
使用的是这种接口

34:44.660 --> 34:45.660
接口的技能方式

34:45.660 --> 34:46.660
它更加合理一点

34:46.660 --> 34:48.660
更加合理一点

34:48.660 --> 34:49.660
因为交叉类型的时候

34:49.660 --> 34:50.660
有的时候

34:50.660 --> 34:51.660
你必须要处理一下

34:51.660 --> 34:52.660
这种情况

34:52.660 --> 34:53.660
比方说

34:53.660 --> 34:54.660
如果有相同的成员

34:54.660 --> 34:55.660
这样一搞的话

34:55.660 --> 34:56.660
就会出一些问题

34:57.660 --> 35:00.660
这是关于接口

35:00.660 --> 35:02.660
和类型别名

35:02.660 --> 35:04.660
他们的具体常性的使用

35:04.660 --> 35:07.660
以及区别

35:07.660 --> 35:10.660
最后我这里想到一个

35:10.660 --> 35:12.660
小的知识点

35:12.660 --> 35:13.660
这个知识点

35:13.660 --> 35:14.660
给大家说一下

35:14.660 --> 35:15.660
既然都讲到接口

35:15.660 --> 35:16.660
这里来了

35:16.660 --> 35:17.660
其实它跟接口

35:17.660 --> 35:18.660
并没有一个

35:18.660 --> 35:20.660
本质上的一个关联

35:20.660 --> 35:22.660
跟我下个小节再讲吧

35:22.660 --> 35:23.660
把它单独提出来

35:23.660 --> 35:24.660
再讲一下

35:24.660 --> 35:25.660
再补充一下

35:25.660 --> 35:27.660
这个是接口这一部分的知识

