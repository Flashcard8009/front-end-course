WEBVTT

00:00.000 --> 00:08.460
好 咱们再来看一下在TS里边 除了之前讲的GS的基本内容之外 都支持

00:08.960 --> 00:15.880
除了这些东西之外呢 他还有一些其他的常用内容 他自己搞出来的一些其他的常用内容

00:16.380 --> 00:23.300
这些内容的每个也非常非常简单 我们先看第一个 联合内容 咱们看一下这里

00:24.260 --> 00:29.860
刚才呢 我们写了一个 比方说啊 比方说一个内容吧 他是个制服串

00:30.580 --> 00:39.860
但是呢 我给他复制为了unty fan 啊 复制为了unty fan 那肯定要抱错对吧 为什么 因为他说你这个内容是制服串内容 你怎么能复制他呢

00:40.180 --> 00:46.180
啊 我们由于我们已经加了更加严格的空类型检查 所以不能这样做了 这样做往往会出问题的

00:47.060 --> 00:51.460
那有的时候 我确实是这样子的 就是一个

00:52.420 --> 00:58.340
姓名 他可能用户可以不填写 争职姓名可以不填写 他可以是一个制服串

00:58.780 --> 01:05.340
确实又可以是unty fan的 或者说可以是一个制服串又可以维空 那么这个时候怎么办啊

01:06.060 --> 01:13.780
我们可以认为 这个变量啊 他可能会出现两种情况 制服串或者是unty fan

01:14.420 --> 01:16.420
那么这个时候就可以使用联合内容了

01:16.900 --> 01:21.060
非常非常简单 你在约束的时候 这样约束 他是一个制服串

01:22.020 --> 01:26.180
或者 注意一个数线啊 或者是一个unty fan

01:27.140 --> 01:36.500
那么就ok了 这个name呢 他可以是制服串可以是unty fan 这就是联合内容 通过一个数线来进行连接 当然呢 我这里写空格也可以不写空格

01:36.900 --> 01:41.700
啊 这个我所谓的 我格式化一下 还有空格又加上了 好 这就是联合内容

01:42.340 --> 01:46.500
当这个name这个变量变成了联合内形过后 你看现在可以负责为unty fan

01:46.980 --> 01:52.900
因为他可以取这个字 接下来我们再看一下啊 当我们去使用这个name的时候

01:53.540 --> 02:02.100
你看他有没有提示 智能提示消失了 对不对 智能提示消失了 为什么会消失呢 你想想这个逻辑

02:03.060 --> 02:08.900
这个name属性他可能是制服串又可能是unty fan的 是不是

02:09.460 --> 02:16.660
他就有两种情况啊 那你怎么能保证他一定是制服串呢 unty fan的东西里面是没有任何东西可以写的

02:17.060 --> 02:22.660
而制服串里面呢倒是有一些含书 但是他现在无法确定他是制服串还是unty fan

02:23.540 --> 02:26.980
那这个时候怎么办呢 你可以判断一下 他就让你进行判断

02:27.700 --> 02:30.580
判断什么type of name

02:31.860 --> 02:35.860
是不是等于 等于啥呢 你看下面有提示啊 等于制服串

02:36.740 --> 02:44.180
如果他等于制服串过后name 这里我是直接负责为unty fan的啊 直接负责为unty fan的 我不敢负责吧

02:44.660 --> 02:49.700
我不敢负责 因为他能够推荡出来 这里一定为unty fan 所以说他不甩力了啊 不甩力了

02:50.100 --> 02:53.380
ok 我们现在点 你看是不是制服串的含书就出来了

02:53.860 --> 02:58.500
所有的含书就出来了 他就智能到这种程度 当你他发现这里有判断的时候

02:58.900 --> 03:04.420
当他发现这里有判断的时候 到了衣服判断里边 他就一定能确定 到了代码到了这里边

03:04.900 --> 03:09.300
这个name 你指着他看一下 很恐怖啊 智能到这种程度

03:10.580 --> 03:14.980
他发现这个东西一定是制服串了 代码到了26行一定是制服串

03:15.700 --> 03:22.180
而在外边的时候呢 在外边的时候一点 点了出来吧 没有任何智能提示 因为在这个位置

03:23.300 --> 03:25.780
他认为他可能是制服串又可能是unty fan

03:26.500 --> 03:31.860
但是到了判断里边 他就能够指到他是制服串了啊 这个东西叫做内形保护

03:32.660 --> 03:38.500
叫内形保护 叫内形保护 怎么叫内形保护 我这里就是面积一笔啊

03:41.940 --> 03:46.580
怎么叫联合内形 我先记下联合内形就是将多种内形

03:48.340 --> 03:50.180
多种内形认选其

03:51.780 --> 03:52.580
就是联合内形

03:53.460 --> 03:56.180
然后呢 可以配合内形保护

03:57.540 --> 04:00.900
配合内形保护进行判断

04:01.860 --> 04:03.860
那么内形保护是怎么触发的呢

04:04.180 --> 04:07.700
就是说 当我们判断的时候 判断他的内形的时候

04:07.860 --> 04:11.460
那么进了这个判断过后 他就能够知道他的确切内形了

04:11.780 --> 04:13.060
那么这就是内形保护

04:13.620 --> 04:14.580
怎么叫内形保护

04:16.580 --> 04:20.420
当对某个变量

04:20.980 --> 04:25.140
对某个变量进行内形判断之后

04:25.620 --> 04:27.140
对他进行内形判断之后

04:27.780 --> 04:30.100
在判断的

04:31.140 --> 04:32.900
判断的语句框中

04:33.540 --> 04:34.980
就是衣服判断的语句框中

04:35.860 --> 04:36.900
便可以确定

04:37.540 --> 04:38.420
可以确定

04:39.780 --> 04:41.620
他的确切内形

04:41.620 --> 04:44.800
这就是内形保护

04:44.800 --> 04:48.000
当我们在这里完成了对内的内形判断

04:48.000 --> 04:50.000
判断完成过后 到了这个语句框里面

04:50.000 --> 04:51.760
他就能确定他一定是支付创

04:51.760 --> 04:53.360
你不是支付创你进不来

04:53.360 --> 04:54.400
这就是内形保护

04:54.400 --> 04:55.840
内形保护如何触发呢

04:56.240 --> 04:57.840
他有很多种触发方式

04:57.920 --> 05:00.080
我们后面还会专门来讲内形保护

05:00.080 --> 05:01.520
那么这里大家先了解一下

05:01.520 --> 05:05.520
通常情况下可以使用Typef来进行触发

05:07.840 --> 05:12.720
Typef可以触发内形保护

05:12.720 --> 05:14.320
但是这里我说说一点

05:14.320 --> 05:17.120
Typef只能触发简单内形

05:17.120 --> 05:18.720
就基本内形的内形保护

05:18.720 --> 05:20.080
什么制服创

05:20.080 --> 05:20.880
什么数字

05:21.680 --> 05:22.400
什么布尔

05:22.400 --> 05:24.320
像这些内形才能触发

05:24.320 --> 05:25.360
如果是一个复杂内形

05:25.360 --> 05:27.360
比方说一个内的对象

05:27.440 --> 05:28.320
它是无法触发的

05:28.960 --> 05:29.680
这里我说一下

05:30.960 --> 05:33.120
这是关于联合内想

05:33.120 --> 05:35.920
有的时候他可能就会去多个内形中取一个

05:37.120 --> 05:38.160
下一个

05:38.160 --> 05:38.960
Void内想

05:39.760 --> 05:41.040
这个Void的关键字

05:41.040 --> 05:42.320
其实在GS里面也有

05:42.320 --> 05:42.960
对吧

05:42.960 --> 05:45.280
GS里面使用Void的关键字

05:45.280 --> 05:46.400
表示啥意思

05:46.400 --> 05:48.720
表示运算一个表达式之后

05:48.720 --> 05:49.760
返回一个undefined

05:50.400 --> 05:51.520
这个东西不用去管了

05:51.520 --> 05:52.640
在TS里面

05:52.640 --> 05:54.000
它是完全不一样的意思

05:54.480 --> 05:56.640
在TS里面Void表示什么呢

05:56.720 --> 05:57.520
通常用约

05:59.680 --> 06:01.040
通常用约

06:02.560 --> 06:03.120
约束

06:03.840 --> 06:05.680
函数的返回值

06:06.960 --> 06:10.640
表示该函数没有任何返回

06:11.440 --> 06:13.600
表示这个函数不返回任何东西

06:14.240 --> 06:15.440
比方说我这里写个函数

06:18.360 --> 06:20.120
这个函数我们就要取个名字

06:20.120 --> 06:21.400
叫做Print

06:21.400 --> 06:22.360
Menu

06:22.360 --> 06:23.800
打印一个菜单

06:23.800 --> 06:25.160
打印一个菜单

06:25.720 --> 06:27.080
那既然是打印菜单

06:27.080 --> 06:28.200
它还要返回啥东西呢

06:28.280 --> 06:29.080
啥都不返回

06:29.080 --> 06:30.440
打印就完事了呗

06:30.440 --> 06:31.400
打印

06:31.400 --> 06:32.440
打印菜单

06:32.440 --> 06:34.040
比方说一登录

06:35.720 --> 06:37.240
cancel log2

06:37.880 --> 06:38.680
注册

06:38.680 --> 06:40.280
它不返回任何东西

06:40.280 --> 06:41.480
那么像这种函数

06:41.480 --> 06:42.840
你就可以对它进行约束

06:42.840 --> 06:43.720
约束为啥呢

06:43.720 --> 06:44.760
Void

06:44.760 --> 06:45.720
表示这个函数

06:45.720 --> 06:47.080
它不返回任何东西

06:47.080 --> 06:48.200
给它进行约束就完事了

06:48.200 --> 06:48.840
就这么简单

06:49.720 --> 06:50.440
当然

06:50.440 --> 06:51.480
你不约束行不行

06:52.200 --> 06:52.840
不约束

06:52.840 --> 06:53.800
你看它推断出来

06:54.760 --> 06:55.560
推到出来

06:55.560 --> 06:57.480
返回的类型就是Void

06:57.560 --> 06:59.800
表示它没有任何返回值

06:59.800 --> 07:01.000
当然这个类型

07:01.000 --> 07:02.440
它一般补去约束变量

07:03.400 --> 07:04.520
一般补约束变量

07:04.520 --> 07:05.080
约束参数

07:05.080 --> 07:06.280
这些都不会的

07:06.280 --> 07:07.880
一般就是约束返回值

07:07.880 --> 07:08.840
表示无返回

07:09.560 --> 07:09.880
OK

07:09.880 --> 07:10.760
这是Void的类型

07:11.880 --> 07:12.200
好

07:12.200 --> 07:13.160
下面这个

07:13.160 --> 07:14.040
这个其他的类型

07:14.040 --> 07:14.760
叫做never

07:15.320 --> 07:16.120
never

07:16.120 --> 07:16.920
这是它类型的

07:17.560 --> 07:18.440
通常

07:18.440 --> 07:22.920
通常用于约束函数的返回值

07:22.920 --> 07:24.440
它也是约束函数的返回值

07:25.400 --> 07:26.520
表示

07:26.520 --> 07:27.720
该函数

07:27.720 --> 07:30.120
永远不可能结束

07:31.080 --> 07:33.320
表示这个函数是永远不可能结束的

07:33.320 --> 07:34.760
这就是never的类型

07:34.760 --> 07:35.960
never就是永远不会

07:36.520 --> 07:37.640
就是这个意思

07:37.640 --> 07:39.320
它能不能约束变量呢

07:39.320 --> 07:40.680
可以约束变量

07:40.680 --> 07:41.720
只不过呢

07:41.720 --> 07:42.840
不太这样去做

07:42.840 --> 07:44.280
不太这样去做

07:44.280 --> 07:44.440
好

07:44.440 --> 07:45.160
我们来看一下

07:46.360 --> 07:46.680
这里

07:48.280 --> 07:49.640
我写这么一个函数

07:49.640 --> 07:50.760
比方这个函数

07:50.760 --> 07:51.560
该取个名字叫

07:51.880 --> 07:54.760
throw error

07:54.760 --> 07:55.880
抛出一个错误

07:56.600 --> 07:57.720
给我一个错误消息

07:58.680 --> 08:00.040
这个错误消息是一个制服串

08:00.920 --> 08:02.200
你给我一个错误消息

08:02.200 --> 08:03.320
我在这里面干嘛呢

08:03.880 --> 08:07.080
我throw new error

08:07.080 --> 08:08.200
抛一个错误出来

08:08.920 --> 08:10.120
抛一个错误出来

08:10.120 --> 08:11.720
就帮你来抛一个错误

08:11.720 --> 08:13.080
其实这个函数也不说没用

08:13.640 --> 08:15.000
它还是有点用的

08:15.000 --> 08:16.280
有的时候抛一个错误

08:16.280 --> 08:17.320
我想简单一点

08:17.320 --> 08:18.280
我就可以

08:18.280 --> 08:19.240
少写两个单词

08:19.240 --> 08:20.520
我就可以使用这个函数

08:21.800 --> 08:22.120
好

08:22.120 --> 08:24.440
这个函数表示抛出一个错误

08:24.440 --> 08:26.440
那么这个函数的返回值是啥呢

08:27.080 --> 08:28.680
我们这里需要你约束一下

08:28.680 --> 08:29.480
现在它推断出来

08:29.480 --> 08:31.000
已经推断的有问题了

08:31.000 --> 08:31.800
它推断这个函数

08:31.800 --> 08:32.760
已经推断的有问题了

08:32.760 --> 08:33.240
你看

08:33.240 --> 08:35.080
它推断出来是 void

08:35.080 --> 08:36.600
但是呢实际上不是的

08:36.600 --> 08:39.320
这个函数应该是 never

08:39.960 --> 08:40.360
never

08:40.920 --> 08:41.880
表示的是

08:41.880 --> 08:44.120
这个函数永远不会结束

08:44.120 --> 08:44.680
你想一想

08:45.400 --> 08:46.360
掉用这个函数

08:46.360 --> 08:47.960
这个函数能结束的了啊

08:47.960 --> 08:49.160
肯定结束不了

08:49.160 --> 08:50.520
它要抛出错误的

08:50.600 --> 08:51.960
比方说下面有一条语句

08:51.960 --> 08:52.920
cancel log

08:52.920 --> 08:53.720
随便写吧

08:54.440 --> 08:55.720
那里觉得这个log的语句

08:56.440 --> 08:57.160
会运行吗

08:57.800 --> 08:58.920
是不是一定不会运行

08:58.920 --> 08:59.880
它都告诉你了

08:59.880 --> 09:01.800
这个代码是永远无法访问到的

09:01.800 --> 09:03.240
检测到无法访问的代码

09:04.120 --> 09:05.160
因此呢

09:05.160 --> 09:05.960
所以说这个函数

09:05.960 --> 09:07.320
它是永远不会结束的

09:07.320 --> 09:09.160
那么你把它约束成为never

09:09.160 --> 09:10.120
永远不会返回

09:11.160 --> 09:11.400
好

09:11.400 --> 09:12.040
再比方说

09:13.000 --> 09:13.880
写这么一个函数

09:14.520 --> 09:15.240
这么一个函数

09:16.200 --> 09:16.920
就随便写吧

09:16.920 --> 09:17.720
写个 always

09:18.680 --> 09:20.440
always

09:20.440 --> 09:21.480
我咋写的

09:21.480 --> 09:22.040
always

09:23.880 --> 09:25.720
always do something

09:25.720 --> 09:27.480
一直在去做一些事情

09:29.000 --> 09:29.240
好

09:29.240 --> 09:30.040
这个函数里边呢

09:30.040 --> 09:31.160
我就做了这么一件事

09:31.160 --> 09:31.880
写个死循环

09:33.800 --> 09:35.400
这个死循环是不是永远不会结束

09:35.400 --> 09:36.920
我甭管在里面写啥吧

09:36.920 --> 09:37.880
这个无所谓

09:37.880 --> 09:39.720
这个循环永远不会结束

09:39.720 --> 09:42.200
那么这个函数也会永远不会结束

09:42.200 --> 09:43.800
那么这里推到出来有问题

09:43.800 --> 09:44.520
它反过来

09:44.520 --> 09:45.720
它说这个函数是过于的

09:45.720 --> 09:46.840
实际上不是了

09:46.920 --> 09:48.920
这个函数是never

09:48.920 --> 09:49.880
是never

09:49.880 --> 09:50.760
永远不会结束

09:50.760 --> 09:52.440
你这里手动去著名一下

09:53.480 --> 09:54.360
像这两种情况

09:54.360 --> 09:55.320
我们都可以去著名

09:55.960 --> 09:57.160
标注一下这个函数

09:58.040 --> 09:59.640
它永远不会结束

10:00.440 --> 10:02.040
通过never来标注

10:02.040 --> 10:03.080
这是never来行

10:03.080 --> 10:05.240
通常用于约束函数的反挥值

10:07.080 --> 10:08.120
我们给大家看一下吧

10:08.120 --> 10:09.000
看一下一种情况

10:09.000 --> 10:11.880
就是有一种情况也会出现never

10:12.520 --> 10:13.240
有一种情况

10:13.960 --> 10:16.840
后面其实还有一些其他情况

10:16.840 --> 10:18.200
会看到一些变量里面

10:18.200 --> 10:19.240
也会有never约束

10:19.880 --> 10:21.880
比方说我们这里写一个变量

10:22.760 --> 10:23.240
ar

10:23.800 --> 10:24.920
我约束的时候

10:25.480 --> 10:26.280
我可能写错了

10:26.280 --> 10:27.080
可能手抖了

10:27.080 --> 10:28.200
我写成这个样子

10:28.200 --> 10:29.720
我们之前说过不要写成这个样子

10:29.720 --> 10:30.280
对吧

10:30.280 --> 10:31.560
不要写成这个样子

10:31.560 --> 10:32.280
这个样子呢

10:32.280 --> 10:33.640
应该在前面加一个

10:33.640 --> 10:35.720
每一个数组的每一项是什么类型

10:35.720 --> 10:36.840
应该这样子写

10:36.840 --> 10:37.240
但是呢

10:37.240 --> 10:38.840
你可能写成这个样子

10:38.840 --> 10:39.560
咱们来看一下

10:40.120 --> 10:40.680
这个数组

10:41.640 --> 10:42.680
帽好

10:44.280 --> 10:45.240
等一下啊

10:45.240 --> 10:46.040
等一下

10:47.000 --> 10:47.960
这个数组

10:48.600 --> 10:49.400
我们这里

10:49.960 --> 10:51.400
复制一个数组

10:52.360 --> 10:55.800
这里应该是有这个新版本更新过后有变化

10:55.800 --> 10:57.880
应该是新版本更新有变化

10:57.880 --> 10:59.480
以前在这里呢

10:59.480 --> 11:00.840
我记得很有印象

11:00.840 --> 11:01.640
这里的地方呢

11:01.640 --> 11:04.040
它是把它约束成为了一个never数组

11:04.040 --> 11:06.200
它是把它约束成为了一个never数组

11:06.200 --> 11:07.000
我们试一下

11:07.000 --> 11:07.560
这边

11:08.360 --> 11:09.560
它现在变化了

11:10.280 --> 11:11.400
现在变化了

11:11.400 --> 11:13.560
现在这个不再是never数组了

11:13.560 --> 11:14.440
那我们就不管了

11:14.440 --> 11:15.400
不管它了

11:15.400 --> 11:16.760
之前它确实是never数组

11:16.760 --> 11:18.600
现在版本新版本里面可能有变化

11:20.120 --> 11:21.000
这是never

11:21.000 --> 11:24.280
我们通常用于约束它的约束函数的返回值

11:25.400 --> 11:27.080
下一个字面量类型

11:29.090 --> 11:29.970
这个是什么意思呢

11:30.530 --> 11:31.810
只能看高清它的意思

11:33.010 --> 11:35.010
表示使用一个值

11:36.130 --> 11:39.410
使用一个值进行约束

11:39.410 --> 11:40.610
而不是使用一个类型

11:40.930 --> 11:42.610
使用的是一个值进行约束

11:43.250 --> 11:44.450
而是字面量类型

11:44.930 --> 11:46.290
那么咱们来看一下

11:46.290 --> 11:46.930
这种情况

11:48.530 --> 11:49.170
就例子吧

11:50.930 --> 11:51.410
注释掉了

11:53.570 --> 11:54.610
比方说

11:54.610 --> 11:57.330
我们写这么一个变量

11:58.850 --> 12:00.930
比方说咱们随便写吧

12:00.930 --> 12:01.730
写个A变量

12:02.290 --> 12:04.210
然后我约束它的类型的时候呢

12:04.210 --> 12:05.250
我不是使用实均

12:06.050 --> 12:07.330
而是使用的是啥呢

12:07.330 --> 12:09.490
我使用一个制服串来进行约束

12:10.450 --> 12:11.810
表示A

12:12.690 --> 12:13.650
那么什么意思呢

12:14.210 --> 12:15.970
表示的是这个变量

12:16.530 --> 12:17.410
从此以后

12:17.410 --> 12:19.090
你只能有一种曲子

12:19.090 --> 12:20.130
就是这个制服串A

12:20.690 --> 12:21.490
就表示这个意思

12:21.970 --> 12:23.410
好 我给这个A复制的时候

12:23.410 --> 12:24.210
你看一下

12:24.210 --> 12:25.250
复制的时候

12:25.250 --> 12:26.530
它就都在提示你了

12:27.250 --> 12:28.050
别乱来

12:28.050 --> 12:29.490
你只能复制为这个字

12:29.490 --> 12:31.010
别都直接别想了

12:31.010 --> 12:32.130
你只能复制为这个字

12:33.090 --> 12:35.410
这就是字面量约束

12:36.690 --> 12:38.370
那你跟复制为其他值行不行

12:38.370 --> 12:38.930
复制为B

12:40.450 --> 12:41.410
你看它的类型

12:42.370 --> 12:44.050
它的类型只能是A

12:44.850 --> 12:45.330
看到没

12:45.330 --> 12:46.290
只能是A

12:46.290 --> 12:47.490
这就是字面量约束

12:47.890 --> 12:48.290
当然呢

12:48.290 --> 12:50.690
也可以使用数字也是一样的

12:51.250 --> 12:51.970
那么复制的时候

12:51.970 --> 12:53.090
你只能复制为2

12:53.090 --> 12:53.970
复制为1

12:53.970 --> 12:54.370
不行

12:55.570 --> 12:57.010
这就是字面量约束

12:57.010 --> 12:59.250
它也是一种非常非常强力的约束

13:00.290 --> 13:01.170
字面量约束呢

13:01.170 --> 13:02.370
通常可以做这种事情

13:03.010 --> 13:04.290
比方说性别

13:05.170 --> 13:05.570
尖段

13:06.290 --> 13:07.970
我可以这样子约束

13:08.050 --> 13:09.570
你只能取之为蓝

13:10.690 --> 13:11.810
或者是

13:12.130 --> 13:12.850
联合类型

13:13.490 --> 13:14.290
取之为女

13:14.930 --> 13:17.490
我使用两个字面量的联合类型

13:17.490 --> 13:19.330
对这个性别进行约束

13:19.330 --> 13:21.010
从此以后的这个性别

13:21.010 --> 13:22.610
你还能够去其他值吗

13:23.330 --> 13:24.050
肯定不行

13:24.050 --> 13:24.930
要么只能取蓝

13:24.930 --> 13:26.050
要么只能取女

13:26.050 --> 13:26.770
看呗

13:26.770 --> 13:27.890
是不是很舒服这样子

13:27.890 --> 13:30.050
以后是根本就无法出错了

13:30.050 --> 13:31.330
是很难出错的

13:31.330 --> 13:32.290
这就是字面量类型

13:33.650 --> 13:34.850
当然字面量的类型呢

13:34.850 --> 13:35.330
除了

13:36.370 --> 13:37.890
使用这种制服错了之外

13:37.970 --> 13:39.250
除了使用数字之外

13:39.250 --> 13:40.690
当然还可以使用其他的了

13:41.410 --> 13:43.570
比方说像咱们刚才看到的

13:44.290 --> 13:45.010
一个数组

13:45.650 --> 13:46.450
这样子约束

13:47.010 --> 13:48.690
其实这就是一个字面量约束

13:49.330 --> 13:50.690
这就是一个字面量约束

13:51.170 --> 13:51.890
约束为啥

13:51.890 --> 13:52.690
一个数组

13:52.690 --> 13:53.730
这就是个数组对吧

13:54.450 --> 13:55.730
高速ts

13:56.130 --> 13:57.090
该数组呢

13:58.050 --> 13:59.090
表示ar

13:59.730 --> 14:01.250
永远只能

14:02.530 --> 14:03.490
取之为

14:04.770 --> 14:06.370
一个空数组

14:07.330 --> 14:08.610
这就是个字面量约束

14:09.890 --> 14:10.530
之前的

14:10.530 --> 14:12.530
他说要把它变成label类型的数组了

14:12.530 --> 14:14.370
现在终于把它弄成正常了

14:14.370 --> 14:15.250
我之前就觉得

14:15.250 --> 14:16.930
这个地方应该是用一个字面量约束

14:16.930 --> 14:17.570
给你好一点

14:18.850 --> 14:19.250
好

14:20.050 --> 14:20.610
下面

14:20.610 --> 14:21.650
还有一种情况

14:21.650 --> 14:23.730
就是对相进行字面量约束

14:24.850 --> 14:25.490
一个用户

14:26.530 --> 14:27.090
一个用户

14:27.650 --> 14:29.330
我对他进行约束的时候

14:29.330 --> 14:31.570
我可以写一个对相的字面量

14:32.130 --> 14:33.890
我甚至可以写一个对相的字面量

14:34.450 --> 14:35.330
这个对相的字面量

14:35.330 --> 14:35.890
我这样子写

14:36.850 --> 14:37.490
lamb

14:37.490 --> 14:38.050
实均

14:39.890 --> 14:40.690
aj

14:40.690 --> 14:41.570
aj

14:41.570 --> 14:42.530
这里不打都好

14:42.530 --> 14:43.490
这里不打都好

14:45.170 --> 14:45.570
number

14:46.770 --> 14:48.610
我可以这样子在进行约束

14:48.610 --> 14:49.890
表示什么意思呢

14:49.890 --> 14:51.090
表示你这个对象

14:51.090 --> 14:52.290
你不是一个普通对象

14:52.290 --> 14:55.490
你这对象里面必须要有一个制服串的属性lamb

14:55.490 --> 14:57.330
必须要有一个数字的属性

14:57.330 --> 14:57.650
aj

14:58.370 --> 14:59.890
注意这不是复职

14:59.890 --> 15:01.170
这不是给有点复职

15:01.170 --> 15:03.330
都是对他进行类型的约束

15:04.370 --> 15:04.770
OK

15:04.850 --> 15:05.970
后边复职的时候

15:05.970 --> 15:06.530
你看一下

15:07.570 --> 15:13.090
不做任何事情是不是爆错了

15:13.090 --> 15:13.730
他说什么

15:14.290 --> 15:17.410
他说你这个给他复制为一个空对象不行

15:18.050 --> 15:20.050
他里面缺少了一些属性

15:20.050 --> 15:20.770
什么属性呢

15:20.770 --> 15:22.210
缺少了name制服串

15:22.210 --> 15:23.570
缺少了aj number

15:24.130 --> 15:25.490
你看后面给你列出来了

15:25.490 --> 15:26.530
缺少这两个属性

15:26.530 --> 15:27.410
行那写呗

15:28.050 --> 15:29.170
lamb给他复职

15:29.170 --> 15:30.850
复制为一个数字行不行

15:30.850 --> 15:31.650
爆错

15:31.650 --> 15:32.610
他说lamb

15:32.610 --> 15:33.650
必须是一个制服串

15:33.650 --> 15:34.130
你看

15:34.290 --> 15:35.650
更加强烈的约束了

15:36.450 --> 15:37.730
aj数字

15:38.530 --> 15:40.210
这就是字面量约束

15:40.210 --> 15:41.250
通过对象的方式

15:41.250 --> 15:42.530
进行字面量约束

15:42.530 --> 15:43.810
但这种方式有点麻烦

15:43.810 --> 15:44.850
有点繁琐

15:44.850 --> 15:46.610
我们后边会讲到接口

15:46.610 --> 15:47.250
会讲到

15:48.690 --> 15:49.490
其他的东西

15:49.490 --> 15:51.170
来对他这一块进行约束

15:51.170 --> 15:52.210
比方说类

15:52.210 --> 15:53.970
也可以对他这一块进行约束

15:53.970 --> 15:55.810
一般不太会使用这种方式

15:58.800 --> 16:00.160
还有类型别名也可以

16:00.880 --> 16:02.160
这是我给大家看一下

16:02.160 --> 16:03.040
这个字面量

16:03.040 --> 16:04.320
是可以这样子约束的

16:05.280 --> 16:07.360
这是字面量类型的约束

16:08.480 --> 16:09.840
接下来看两个

16:09.840 --> 16:10.480
最后两个

16:10.960 --> 16:12.480
一个是圆组类型

16:12.960 --> 16:14.560
其实这些东西都很简单了

16:14.560 --> 16:15.840
就东西有点多

16:15.840 --> 16:16.560
很简单

16:16.560 --> 16:17.840
我先把基本操作学会

16:18.800 --> 16:19.840
圆组类型

16:19.840 --> 16:20.960
什么叫圆组类型了

16:20.960 --> 16:21.680
这个用的

16:22.720 --> 16:23.280
不多

16:23.280 --> 16:23.920
比较少

16:24.480 --> 16:27.040
表示的是一个固定长度的数组

16:27.920 --> 16:29.360
固定长度的数组

16:30.320 --> 16:30.880
并且

16:31.840 --> 16:34.320
数组中每一项的

16:34.960 --> 16:37.440
每一项的类型确定

16:37.440 --> 16:38.240
这就是个圆组

16:39.440 --> 16:40.400
有一个数组

16:40.400 --> 16:41.840
它的数组的长度确定

16:41.840 --> 16:42.320
并且呢

16:42.320 --> 16:44.080
数组的每一项的类型

16:44.080 --> 16:45.040
也确定

16:45.040 --> 16:45.920
这就是一个圆组

16:46.880 --> 16:47.120
好

16:47.120 --> 16:47.840
咱们来看一下

16:49.840 --> 16:51.040
比方说我这里

16:52.160 --> 16:52.800
有一个变量

16:55.920 --> 16:57.040
不管它啥变量吧

16:57.040 --> 16:57.600
这个不重要

16:58.720 --> 16:59.120
接下来

16:59.120 --> 17:00.400
我对它进行类型结束

17:00.480 --> 17:01.440
我这样子约束

17:02.160 --> 17:03.200
好像是个数组对吧

17:03.920 --> 17:04.400
然后呢

17:04.400 --> 17:06.400
接下来我在这里面写个字符串

17:06.400 --> 17:07.040
写个Lumber

17:08.000 --> 17:08.880
这就是一个圆组

17:09.600 --> 17:11.200
它约束了这个变量

17:12.160 --> 17:13.280
告诉它

17:13.280 --> 17:14.800
你只能有两项

17:14.800 --> 17:16.160
数组必须有两项

17:16.720 --> 17:17.280
并且呢

17:17.280 --> 17:19.280
第一项必须是一个字符串

17:19.280 --> 17:20.960
第二项必须是一个Lumber

17:21.760 --> 17:23.440
之后再给这个数组复指的时候

17:23.440 --> 17:24.080
咱们看一下

17:24.880 --> 17:26.560
给它复指为一个空数组行不行

17:27.280 --> 17:28.080
不行

17:28.080 --> 17:29.600
必须有两项

17:29.680 --> 17:30.880
好这两项呢

17:30.880 --> 17:32.080
我给它复指三项行不行

17:32.560 --> 17:33.040
不行

17:33.920 --> 17:34.400
第一个

17:34.400 --> 17:35.520
第一项还必须是字符串

17:35.920 --> 17:36.720
还必须是字符串

17:37.360 --> 17:38.320
三项不行

17:38.320 --> 17:39.280
它只能有两项

17:39.680 --> 17:40.000
OK

17:40.800 --> 17:41.600
两项可以

17:41.600 --> 17:43.120
但是第一项必须是字符串

17:43.120 --> 17:44.640
第二项必须是数字

17:45.120 --> 17:45.920
这就是圆组

17:47.120 --> 17:48.160
好这是关于这个圆组

17:48.160 --> 17:49.360
这个圆组用的少一点

17:49.360 --> 17:50.080
了解一下就行了

17:51.280 --> 17:53.040
最后一个就是我们之前说过

17:53.040 --> 17:54.160
说的ND类型

17:56.160 --> 17:58.720
ND类型可以绕过

17:59.680 --> 18:00.560
类型检查

18:01.040 --> 18:02.320
它可以绕过类型检查

18:02.800 --> 18:03.760
就是类型检查

18:03.760 --> 18:05.360
发现有ND类型的地方了

18:05.360 --> 18:06.880
不对它进行任何类型检查

18:08.240 --> 18:10.960
因此ND类型的数据

18:12.240 --> 18:14.640
可以复指给任意类型

18:16.400 --> 18:17.920
是可以复指给任意类型的

18:18.800 --> 18:19.280
比方说

18:20.480 --> 18:20.880
这里

18:23.490 --> 18:24.130
有一个变量

18:24.610 --> 18:26.290
我手动的对它进行

18:27.490 --> 18:28.050
约束

18:28.050 --> 18:28.850
约束为ND

18:29.490 --> 18:30.850
手动的进行约束

18:30.930 --> 18:32.690
当你手动的进行约束过后了

18:32.690 --> 18:34.130
这三个点就不会爆出来了

18:34.530 --> 18:36.050
那个警告就不会有了

18:36.050 --> 18:37.570
因为你都手动约束了

18:37.570 --> 18:39.650
那肯定你心里面肯定清楚

18:39.650 --> 18:40.770
你自己要干嘛

18:40.770 --> 18:42.370
所以它不会对你进行警告了

18:43.010 --> 18:43.650
好

18:43.650 --> 18:44.450
随便干复指吧

18:44.450 --> 18:44.850
无所谓

18:44.850 --> 18:45.410
随便复指

18:46.050 --> 18:47.410
然后有另外一个变量

18:48.050 --> 18:49.010
比方说Number

18:49.570 --> 18:50.210
是一个数字

18:50.690 --> 18:51.410
咱们看一下

18:51.410 --> 18:52.530
Data能不能复制过去

18:53.410 --> 18:54.210
能不能复制过去

18:54.690 --> 18:55.490
可以复制过去

18:55.890 --> 18:58.450
ND类型可以复指给任意类型

18:59.090 --> 19:00.210
那么你看一下这个代码

19:00.290 --> 19:01.010
是不是有隐患

19:01.570 --> 19:02.610
肯定有隐患

19:02.610 --> 19:04.450
在运行过程中肯定有隐患

19:04.850 --> 19:06.050
所以说不建议大家

19:06.610 --> 19:08.210
随意的去使用ND类型

19:09.010 --> 19:10.610
随意的去使用ND类型不太好

19:11.890 --> 19:13.170
有些特殊的情况下

19:13.170 --> 19:14.050
可能会用到它

19:14.050 --> 19:15.490
咱们之后遇到了再说

19:16.690 --> 19:17.010
OK

19:17.650 --> 19:19.250
这就是TS

19:19.810 --> 19:21.890
在GS基本类型基础上

19:21.890 --> 19:23.250
给我们扩展了一些

19:23.250 --> 19:24.770
常见的一些其他类型

19:25.650 --> 19:26.370
这些类型呢

19:26.850 --> 19:28.610
我们和GS的基本类型

19:28.690 --> 19:31.330
我们把它统称为TS的基本类型

19:32.050 --> 19:33.570
除了这些类型约束之外

19:33.570 --> 19:35.570
咱们后边的课程中

19:35.570 --> 19:37.810
还会学习很多其他的

19:38.290 --> 19:39.250
自定义的类型

19:39.250 --> 19:40.450
可以扩展的类型

19:40.930 --> 19:42.050
但是基本类型

19:42.050 --> 19:43.010
我们先把它学会

19:44.130 --> 19:45.570
OK 这几个我先讲了

19:45.570 --> 19:47.090
讲了这么一些基本类型之后

19:47.650 --> 19:48.690
还有一些知识

19:48.690 --> 19:50.450
还有一些常见的一些

19:50.450 --> 19:51.650
非常实用的操作

19:52.050 --> 19:53.410
我们后边一个个一个补充

19:54.050 --> 19:54.610
基本类型

19:54.610 --> 19:55.330
我们先到这一块

