WEBVTT

00:00.690 --> 00:07.410
好 接下来 我们来讲一个知识点 叫做 犯刑约束

00:07.410 --> 00:10.610
这啥意思呢 其实很简单啊

00:10.610 --> 00:13.890
就是我们之前不编写犯刑吗 对吧

00:13.890 --> 00:16.330
这个地方可以传递任何类型

00:16.330 --> 00:19.610
然后这里我们在类上面使用了犯刑

00:19.610 --> 00:22.570
那么我们创建这个类的对象的时候啊

00:22.570 --> 00:25.250
在使用这个类的时候就可以给它规定

00:25.250 --> 00:30.050
这是一个什么样的制服创 这是一个什么样的宿主

00:30.130 --> 00:33.850
什么样的宿主帮助类就可以给它进行规定

00:33.850 --> 00:36.050
然后说我们之前对调用的时候啊

00:36.050 --> 00:37.370
我们来打一个吧

00:37.370 --> 00:41.770
help new array helper

00:41.770 --> 00:44.690
在使用这个创 再创建这个类的时候呢

00:44.690 --> 00:46.250
我们就可以给它规定

00:46.250 --> 00:49.130
这个宿主的每一项是一个什么样的类型

00:49.130 --> 00:50.850
然后把这个宿主给它 对吧

00:50.850 --> 00:52.410
我们之前是这样做的

00:52.410 --> 00:55.610
之前呢 在这个位置 就在这个位置

00:55.610 --> 00:57.370
可以传递任何类型

00:57.410 --> 01:00.090
制服创可以 数字可以 一个对象可以

01:00.090 --> 01:02.650
什么都可以 可以传递任何类型

01:02.650 --> 01:06.010
在咱们之前的例子里面呢 是没有什么问题的

01:06.010 --> 01:08.050
但是在某些情况下

01:08.050 --> 01:10.770
可能呢 这里传递的类型呢

01:10.770 --> 01:13.330
它有所要求不能随便传啊

01:13.330 --> 01:16.810
必须要满足某种条件的类型 才行

01:16.810 --> 01:19.890
那么什么情况下会遇到这种现象呢

01:19.890 --> 01:22.850
实话实说 在基础阶段呢

01:22.850 --> 01:26.090
我想这个例子真的是非禁的老子

01:26.090 --> 01:28.410
真的是不好想这个例子

01:28.410 --> 01:30.970
那么我这里给它看一个例子啊

01:30.970 --> 01:32.410
看一个例子

01:32.410 --> 01:34.250
这个例子呢 可能看上去有点怪

01:34.250 --> 01:36.050
但是我真的是想不出来了

01:36.050 --> 01:38.730
因为这个其实 这种场景啊

01:38.730 --> 01:41.890
在境界部分 会出现很多

01:41.890 --> 01:44.010
但是在基础阶段呢

01:44.010 --> 01:46.250
我要想一个合适的例子是真的不好想

01:46.250 --> 01:47.850
大家理解一下

01:47.850 --> 01:49.890
这里有个函数

01:49.890 --> 01:52.610
这个函数呢 我要做这么一件事

01:52.610 --> 01:54.010
这个函数很奇怪

01:54.010 --> 01:55.290
我该取个名字

01:55.290 --> 01:57.290
叫做

01:57.290 --> 02:01.450
name to upper case

02:01.450 --> 02:03.490
我要有这么一个函数

02:03.490 --> 02:05.850
这个函数做什么呢 我该打成一个出示

02:05.850 --> 02:07.930
这个函数要做这么一件事

02:07.930 --> 02:14.290
将某个对象的name属性

02:14.290 --> 02:16.650
将某个对象的name属性

02:16.650 --> 02:21.330
的每个单词的手字母大写

02:21.330 --> 02:23.530
每个单词的手字母大写

02:23.530 --> 02:28.770
然后将该对象返回

02:28.770 --> 02:29.770
就是说什么意思

02:29.770 --> 02:33.050
这个函数有一个参数

02:33.050 --> 02:34.970
这个参数是一个对象

02:34.970 --> 02:37.250
将来我们会调用这个函数

02:37.250 --> 02:39.290
这个函数会起这么一个作用

02:39.290 --> 02:39.850
什么意思

02:39.850 --> 02:43.050
就是说我这里比方说有一个对象

02:43.050 --> 02:44.250
有一个对象O

02:44.250 --> 02:46.130
这个对象里边有一个name属性

02:46.130 --> 02:49.730
我们随便写

02:49.850 --> 02:52.290
kevin

02:52.290 --> 02:55.530
然后这里随便写下其他属性

02:55.530 --> 02:57.170
随便写下其他属性

02:57.170 --> 02:59.290
jander

02:59.290 --> 03:01.010
有这么一个对象

03:01.010 --> 03:03.570
我之后我可以做这么一件事

03:03.570 --> 03:05.890
name to upper case

03:05.890 --> 03:08.010
把这个对象O传进去

03:08.010 --> 03:10.610
它就会把这个对象的name属性

03:10.610 --> 03:13.650
每一个单词的手字母大写

03:13.650 --> 03:17.730
然后返回一个新的对象

03:17.730 --> 03:18.730
返回一个新的对象

03:18.730 --> 03:20.930
其实也不叫新的对象

03:20.930 --> 03:23.130
就是原来的对象直接返回

03:23.130 --> 03:26.330
然后最后我们输出这个

03:26.330 --> 03:29.730
newO.name的时候

03:29.730 --> 03:33.970
输出的结果它就应该是这样的结果

03:33.970 --> 03:35.010
懂我这个意思吗

03:35.010 --> 03:37.050
我们要完成这么一个操作

03:37.050 --> 03:38.570
就是这个函数

03:38.570 --> 03:41.970
它能够把某一个对象的name属性

03:41.970 --> 03:44.130
每一个单词的手字母大写

03:44.130 --> 03:46.090
然后返回对象

03:46.090 --> 03:47.970
我们需要接收

03:47.970 --> 03:49.170
等到这个对象之后

03:49.170 --> 03:50.530
再去读它的name属性

03:50.530 --> 03:51.970
它的手字母就大写了

03:51.970 --> 03:53.170
我们要完成这么一件事

03:53.170 --> 03:55.010
是真的不好想这个例子

03:55.010 --> 03:57.330
基础阶段这种情况遇到的很少

03:57.330 --> 03:58.810
但是既然讲到犯行这一块

03:58.810 --> 04:02.170
我们需要把这一块的知识全部讲完

04:02.170 --> 04:07.530
好 这里我们首先对函数进行约束

04:07.530 --> 04:09.930
首先我们会看到这么一个现象

04:09.930 --> 04:13.810
这个函数传入的对象的内向

04:13.810 --> 04:17.330
跟它返回的对象内向是不是一致的

04:17.370 --> 04:18.490
是不是一致的

04:18.490 --> 04:19.970
是完全一致的

04:19.970 --> 04:21.330
就这里是什么内向

04:21.330 --> 04:23.250
返回的就是什么内向

04:23.250 --> 04:26.770
那么这个函数又是跟某一个内向相关的

04:26.770 --> 04:30.770
我们这里可以使用犯行

04:30.770 --> 04:32.530
也就是说你告诉我

04:32.530 --> 04:35.050
你传了对象是一个什么样的内向

04:35.050 --> 04:36.170
你把它告诉我

04:36.170 --> 04:40.090
那么这个对象就是这个内向

04:40.090 --> 04:42.970
返回的结果也是这个内向

04:42.970 --> 04:46.410
把这三个点联系在一起

04:46.450 --> 04:49.210
你给我传这么一个对象

04:49.210 --> 04:50.690
比方说传这个O

04:50.690 --> 04:51.970
传这个O

04:51.970 --> 04:55.330
再看一下

04:55.330 --> 04:56.850
你看现在不爆错了

04:56.850 --> 04:58.250
这个函数还没写完

04:58.250 --> 04:59.650
传了一个O进来

04:59.650 --> 05:00.570
我们指着这个函数

05:00.570 --> 05:03.610
你看我传了这个对象进来

05:03.610 --> 05:05.730
于是这个犯行就变成了这个对象

05:05.730 --> 05:06.410
看没

05:06.410 --> 05:08.130
这个犯行就变成这个样子

05:08.130 --> 05:10.810
那么返回的内向也是一致的

05:10.810 --> 05:11.890
我们通过犯行

05:11.890 --> 05:13.850
把这个三个信息联系起来

05:13.850 --> 05:14.970
你给我传一个对象

05:14.970 --> 05:16.530
那么我传的是什么内向

05:16.530 --> 05:18.610
返回的就是这么内向

05:18.610 --> 05:18.850
好

05:18.850 --> 05:20.930
接下来我来实现这个函数

05:20.930 --> 05:23.650
将这个对象的内属性

05:23.650 --> 05:25.970
手字母大写

05:25.970 --> 05:28.370
这个时候写的就会出问题了

05:28.370 --> 05:29.650
OB借点

05:29.650 --> 05:31.530
你会发现点不出来

05:31.530 --> 05:32.330
为什么出不来呢

05:32.330 --> 05:32.970
他怎么

05:32.970 --> 05:34.690
这里为什么没有内面这个属性呢

05:34.690 --> 05:35.570
你只要直接写内面

05:35.570 --> 05:36.930
他要爆错

05:36.930 --> 05:39.770
因为你在这个函数的编写过程中

05:39.770 --> 05:43.130
他并不知道你这个T将来是什么内向

05:43.130 --> 05:44.890
这个T有没有可能是支付串

05:44.890 --> 05:45.810
有没有可能

05:45.850 --> 05:47.690
比方这里传个支付串行不行

05:47.690 --> 05:48.290
他是可以的

05:48.290 --> 05:50.050
因为犯行的话

05:50.050 --> 05:51.370
我们之前学着犯行

05:51.370 --> 05:54.010
他并不要求你这里到具体是什么内向

05:54.010 --> 05:55.970
随便什么内向都可以

05:55.970 --> 05:58.970
所以说如果他将来传了一个支付串

05:58.970 --> 06:01.730
传了一个Number 咋办呢

06:01.730 --> 06:03.290
他没有内属性

06:03.290 --> 06:05.130
所以说他这里考虑到了这一点

06:05.130 --> 06:07.330
因此他不知道

06:07.330 --> 06:08.490
在编写函数的时候

06:08.490 --> 06:11.570
他不知道OB借里边有内属性

06:11.570 --> 06:13.410
他并不知道

06:13.450 --> 06:16.650
因此他不允许你随意去使用这个Name属性

06:16.650 --> 06:17.850
因为如果你用了Name

06:17.850 --> 06:19.810
那么他将来传的不是内向

06:19.810 --> 06:20.890
不是这样传递的

06:20.890 --> 06:22.330
他传的一个支付串

06:22.330 --> 06:24.330
他这样传递

06:24.330 --> 06:25.850
Name to Arpcase

06:25.850 --> 06:26.850
传了个支付串行来

06:26.850 --> 06:28.170
那咋办了

06:28.170 --> 06:29.210
这个事情不好办了

06:29.210 --> 06:30.770
比方传了个数字

06:30.770 --> 06:31.810
怎么办了

06:31.810 --> 06:33.570
这个事情麻烦了

06:33.570 --> 06:35.650
所以说这里应该怎么做呢

06:35.650 --> 06:38.250
我们应该对这个T做一个限定

06:38.250 --> 06:40.250
你不能是所谓的内行

06:40.250 --> 06:41.970
你至少这个内行里边

06:42.010 --> 06:43.690
你至少得是一个对象

06:43.690 --> 06:47.370
并且对象里边得有一个属性

06:47.370 --> 06:48.250
是Name

06:48.250 --> 06:49.610
而且是个支付串

06:49.610 --> 06:50.130
对不对

06:50.130 --> 06:53.490
我们需要对这个T来进行一下约束

06:53.490 --> 06:56.770
那比方说我们这里有这么一个内行

06:56.770 --> 06:58.010
写个Interface

06:58.010 --> 07:00.690
或者是写内行点名都可以

07:00.690 --> 07:01.690
该取个名字吧

07:01.690 --> 07:07.290
比方说HighsNameProperty

07:07.290 --> 07:09.250
有Name属性的对象

07:09.250 --> 07:10.890
给他做个约束

07:11.010 --> 07:12.330
有一个Name属性

07:12.330 --> 07:13.770
它是一个支付串

07:13.770 --> 07:15.210
假设有这么一个内行

07:15.210 --> 07:16.770
这个内行表示是一个对象

07:16.770 --> 07:17.850
这个对象里边

07:17.850 --> 07:19.450
你得有一个Name属性

07:19.450 --> 07:20.810
是一个支付串

07:20.810 --> 07:21.090
好

07:21.090 --> 07:23.090
这里我就用这个内行

07:23.090 --> 07:25.010
对这个T进行限制

07:25.010 --> 07:27.050
你这个T是啥都可以

07:27.050 --> 07:30.850
但是你至少得是这么一种接口

07:30.850 --> 07:32.570
至少得是这么一种接口

07:32.570 --> 07:34.730
里边得有一个Name属性

07:34.730 --> 07:36.730
我怎么来进行限定呢

07:36.730 --> 07:37.570
在T后边

07:37.570 --> 07:39.490
我们给他加上一个关键字

07:39.690 --> 07:40.810
是Tens

07:40.810 --> 07:42.130
表示什么

07:42.130 --> 07:43.490
继承的意思对吧

07:43.490 --> 07:45.330
对番形的限定这里

07:45.330 --> 07:46.770
我们通常都会使用

07:46.770 --> 07:48.650
一个Tens

07:48.650 --> 07:50.810
来限定内行

07:50.810 --> 07:54.490
它应该继承于某个东西

07:54.490 --> 07:54.810
好

07:54.810 --> 07:56.090
继承于某个东西过后

07:56.090 --> 07:57.890
你想想这个继承的关系

07:57.890 --> 07:58.890
某一个内行

07:58.890 --> 07:59.930
继承了另一个内行

07:59.930 --> 08:01.210
那它里面是不是有了

08:01.210 --> 08:02.330
它里边是不是

08:02.330 --> 08:04.410
应该至少具有这个里面的东西

08:04.410 --> 08:05.290
对不对

08:05.290 --> 08:07.010
那么这样才是继承

08:07.010 --> 08:07.850
继承过后

08:07.970 --> 08:11.770
它拥有相当于是负累的一些成员

08:11.770 --> 08:12.930
那么表示

08:12.930 --> 08:13.970
这里的表示

08:13.970 --> 08:15.410
表示的是T

08:15.410 --> 08:16.530
这个内行

08:16.530 --> 08:20.650
你至少得拥有这个接口

08:20.650 --> 08:21.090
它不一定

08:21.090 --> 08:22.890
这里其实不一定是接口

08:22.890 --> 08:24.410
像什么内行别名

08:24.410 --> 08:26.810
像内都可以

08:26.810 --> 08:29.570
必须有这个内行里边的成员

08:29.570 --> 08:30.050
好

08:30.050 --> 08:31.490
这样子一约束过后

08:31.490 --> 08:34.570
你看这里不爆出了

08:34.650 --> 08:35.770
因为它知道

08:35.770 --> 08:38.050
这个OB界是T这个内行

08:38.050 --> 08:39.250
而T这个内行

08:39.250 --> 08:41.170
它是这个接口

08:41.170 --> 08:42.810
它约束为这个接口

08:42.810 --> 08:44.010
那么也就是说

08:44.010 --> 08:45.930
你到时候传过来的东西

08:45.930 --> 08:47.410
不能随意的传递

08:47.410 --> 08:49.050
你只能传递啥

08:49.050 --> 08:52.650
只能传递满足这个接口的内行

08:52.650 --> 08:53.810
满足这个接口

08:53.810 --> 08:55.570
一直我们知道压子变雄法

08:55.570 --> 08:56.090
对吧

08:56.090 --> 08:58.330
你只要包含这个属性就行

08:58.330 --> 08:58.610
好

08:58.610 --> 09:01.730
于是这里面就可以使用内属性了

09:01.730 --> 09:03.770
接下来我们来做手之母大学

09:04.570 --> 09:06.290
其实做手之母大学不是重点的

09:06.290 --> 09:08.930
重点是我们这里也要理解

09:08.930 --> 09:10.930
这里为什么要进行限定

09:10.930 --> 09:13.010
在某些情况下归于到这种场景

09:13.010 --> 09:13.250
好

09:13.250 --> 09:14.050
它是一个制服串

09:14.050 --> 09:15.290
制服串来呗

09:15.290 --> 09:16.890
首先按照split

09:16.890 --> 09:18.410
按照空格来分割

09:18.410 --> 09:18.810
对吧

09:18.810 --> 09:21.370
分割分割完了之后是啥

09:21.370 --> 09:23.090
制服串分割完了之后

09:23.090 --> 09:24.570
是不是一个数组

09:24.570 --> 09:26.330
数组的每一项是个制服串

09:26.330 --> 09:26.770
对不对

09:26.770 --> 09:28.970
形成了一个制服串的数组

09:28.970 --> 09:31.770
那么把这个数组通过map

09:31.890 --> 09:33.490
来进行硬设

09:33.490 --> 09:34.330
硬设

09:34.330 --> 09:35.610
把数组的每一项

09:35.610 --> 09:36.850
每一项是个制服串

09:36.850 --> 09:37.890
每一项是个单词

09:37.890 --> 09:38.690
对不对

09:38.690 --> 09:41.330
每一项的值拿出来

09:41.330 --> 09:43.250
每一项的值s

09:43.250 --> 09:44.730
每个制服串拿出来

09:44.730 --> 09:47.210
然后将他的手之母大学

09:47.210 --> 09:49.250
将这个制服串的第一项

09:49.250 --> 09:50.050
就是严格来说

09:50.050 --> 09:51.450
这里应该进行判断

09:51.450 --> 09:52.570
看这个制服串的长度

09:52.570 --> 09:53.610
是不是得于0

09:53.610 --> 09:54.770
我难得判断了

09:54.770 --> 09:56.570
to uppercase

09:56.570 --> 09:58.370
把手之母转换成大学

09:58.370 --> 09:59.130
然后呢

09:59.130 --> 10:00.570
在拼接上这个制服串

10:00.570 --> 10:01.770
声誉的部分

10:01.770 --> 10:02.770
sabra

10:02.770 --> 10:03.450
sabra stream

10:03.450 --> 10:04.970
e

10:04.970 --> 10:05.770
于是呢

10:05.770 --> 10:08.450
这个单码就形成了一个新的数组

10:08.450 --> 10:08.810
麻烦了

10:08.810 --> 10:08.890
好

10:08.890 --> 10:11.250
我们把这个不是重点了

10:11.250 --> 10:13.130
你们可以自行去实现

10:13.130 --> 10:15.090
然后形成了一个新的制服串数组

10:15.090 --> 10:16.010
制服串数组里边

10:16.010 --> 10:18.450
每一个制服串手之母是大学的

10:18.450 --> 10:18.970
最后呢

10:18.970 --> 10:20.250
使用交易

10:20.250 --> 10:20.970
把这个制服串

10:20.970 --> 10:22.970
再用空格连接起来

10:22.970 --> 10:23.410
连接起来

10:23.410 --> 10:25.050
就完事了

10:25.050 --> 10:25.610
好

10:25.610 --> 10:27.010
最后呢

10:27.010 --> 10:28.010
我们返回

10:28.010 --> 10:29.050
返回啥

10:29.050 --> 10:31.290
返回这个obg

10:31.290 --> 10:33.250
当然我这里要重新给他复制

10:33.250 --> 10:37.050
obg的连重新复制

10:37.050 --> 10:38.570
把这个连属性重新复制

10:38.570 --> 10:42.530
复制为把每个单词手之母转换成大学的

10:42.530 --> 10:44.090
只复制完了过后

10:44.090 --> 10:46.050
把这个对象返回

10:46.050 --> 10:46.250
好

10:46.250 --> 10:48.250
这个函数写完了之后呢

10:48.250 --> 10:50.250
咱们再来看怎么去使用

10:50.250 --> 10:52.050
你看这样子使用

10:52.050 --> 10:53.330
这样子使用

10:53.330 --> 10:54.490
没有任何问题

10:54.490 --> 10:55.610
为什么没问题

10:55.610 --> 10:57.090
因为你这个对象

10:57.090 --> 10:58.370
O

10:58.370 --> 10:59.970
里面有一个连属性

10:59.970 --> 11:01.570
所以说你这样子实现

11:01.570 --> 11:03.370
这样子使用没有任何问题

11:03.370 --> 11:04.090
而且呢

11:04.090 --> 11:05.210
他返回的类型呢

11:05.210 --> 11:06.690
跟这个O的类型是一样的

11:06.690 --> 11:07.770
因为使用了范形

11:07.770 --> 11:09.050
你看是一致的

11:09.050 --> 11:10.290
你这个O是这个类型

11:10.290 --> 11:11.090
看一下

11:11.090 --> 11:12.570
这个O是这个类型

11:12.570 --> 11:14.210
那么这里的6O呢

11:14.210 --> 11:15.410
也是一样的类型

11:15.410 --> 11:16.090
返回来类型

11:16.090 --> 11:18.090
跟这里的类型一致

11:18.090 --> 11:20.810
那如果我把这个O的这个连属性去掉

11:20.810 --> 11:21.970
大家看一下

11:21.970 --> 11:22.930
马上就爆错了

11:22.930 --> 11:23.810
爆错了

11:23.810 --> 11:24.650
他告诉你

11:24.650 --> 11:25.890
不满足约束

11:25.930 --> 11:27.370
这里不满足约束

11:27.370 --> 11:29.290
他说你这个类型

11:29.290 --> 11:31.890
不能复制给他要求的范形型

11:31.890 --> 11:33.970
HasNameProperty

11:33.970 --> 11:34.890
他推断出来

11:34.890 --> 11:35.330
不行

11:35.330 --> 11:35.970
你不行

11:35.970 --> 11:37.170
这样子复制是不行的

11:37.170 --> 11:38.450
因为你少了一个连属性

11:38.450 --> 11:39.330
当然你这里

11:39.330 --> 11:40.730
你给他一个字无创

11:40.730 --> 11:41.250
也不行

11:41.250 --> 11:43.330
因为字无创里面没有连属性

11:43.330 --> 11:45.090
只要你这个对象有连属性

11:45.090 --> 11:45.850
那我就认

11:45.850 --> 11:46.610
没有连属性

11:46.610 --> 11:47.610
我就不认

11:47.610 --> 11:48.090
你看看

11:48.090 --> 11:51.410
就是通过范形型的约束来实现的

11:51.410 --> 11:52.450
那如果

11:52.450 --> 11:54.250
这个函数没有这个约束的话

11:54.250 --> 11:55.090
那你想一想

11:55.130 --> 11:56.090
是不是要出问题

11:56.090 --> 11:57.810
他有可能将来掉落的时候

11:57.810 --> 11:59.690
给你传了一些乱七八糟的东西

11:59.690 --> 12:01.570
而这些乱七八糟的东西里面

12:01.570 --> 12:03.890
可能他就没有连属性

12:05.410 --> 12:06.850
真的是讲究竟老字

12:06.850 --> 12:09.010
真的是侥幸老字想出这么一个例子

12:09.010 --> 12:09.930
在基础阶段

12:09.930 --> 12:11.970
这种场景并不多

12:11.970 --> 12:14.610
但是在进阶的部分

12:14.610 --> 12:16.450
这个场景是非常多的

12:16.450 --> 12:16.970
OK

12:16.970 --> 12:17.930
这里

12:17.930 --> 12:20.610
讲一下内范形的约束

12:20.610 --> 12:21.570
范形的约束

12:21.570 --> 12:22.610
我把它记一下

12:23.530 --> 12:24.850
范形约束

12:24.850 --> 12:30.210
用于先至范形的曲直

12:30.210 --> 12:31.210
曲直

12:31.210 --> 12:32.770
就是你这个范形T

12:32.770 --> 12:33.890
你这个范形T

12:33.890 --> 12:36.730
它应该取一个什么样的内形

12:36.730 --> 12:38.730
它是有一些条件的

12:38.730 --> 12:39.610
有一些先至的

12:39.610 --> 12:40.290
不像之前

12:40.290 --> 12:41.810
随便什么都可以

12:41.810 --> 12:42.250
OK

12:42.250 --> 12:43.730
把这里先讲一下

12:43.730 --> 12:44.730
这是范形的约束

