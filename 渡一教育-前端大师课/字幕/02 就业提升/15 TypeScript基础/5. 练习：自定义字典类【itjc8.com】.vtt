WEBVTT

00:00.620 --> 00:04.060
接下来我们来做一个翻型的练习

00:04.060 --> 00:08.100
这个练习相对于之前的铺客牌这种练习

00:08.100 --> 00:12.620
可能对比起来难度差不多

00:12.620 --> 00:17.220
通过这个练习咱们可以对于翻型这一块的知识进行下铺固

00:17.220 --> 00:20.420
如果你能够到时候我做完之后

00:20.420 --> 00:22.300
你能够自己把它写一遍

00:22.300 --> 00:23.500
把代码写出来的话

00:23.500 --> 00:25.620
翻型这一块你已经没有什么问题了

00:25.620 --> 00:27.700
好 这个练习我们要做什么呢

00:27.700 --> 00:29.620
首先我们这里开一个分支吧

00:31.060 --> 00:32.060
开一个分支

00:32.060 --> 00:36.540
get check out 新建一个分支

00:36.540 --> 00:39.020
给它取一个名字叫做 dig scenery

00:39.020 --> 00:41.700
我们要来做一个内开发一个内

00:41.700 --> 00:43.140
所以我本节课呢

00:43.140 --> 00:46.660
我们不仅仅是能够练习到翻型

00:46.660 --> 00:48.980
还能练习到练习到内的知识

00:48.980 --> 00:52.180
为我们之后进节部分做一些准备

00:52.180 --> 00:54.180
src下面的这些文件呢

00:54.180 --> 00:55.140
我先把这个删了

00:55.140 --> 00:56.900
这个没什么用了 删掉

00:56.900 --> 00:59.620
因这个手这里去掉

01:00.340 --> 01:02.260
我要这里新建一个文件

01:02.260 --> 01:03.540
其实我要做一个内出来

01:04.660 --> 01:06.180
给它取名为 dig scenery

01:06.180 --> 01:07.500
就小写吧

01:07.500 --> 01:10.460
dig scenery.ts

01:10.460 --> 01:12.180
取这么一个文件名

01:12.180 --> 01:14.220
然后这里我要导出一个内

01:14.220 --> 01:14.860
导出一个内

01:14.860 --> 01:16.660
给它取个名字叫 dig scenery

01:18.380 --> 01:19.860
写这么一个内

01:19.860 --> 01:21.620
首先我说一下我到底要做什么

01:22.740 --> 01:25.180
我这里要开发一个

01:25.180 --> 01:29.020
开发一个内

01:29.060 --> 01:31.580
名字叫做 dig scenery

01:31.580 --> 01:32.340
什么意思

01:32.340 --> 01:35.380
就是字点 开发一个字点内

01:36.860 --> 01:38.900
字点里面保存的是什么呢

01:38.900 --> 01:41.700
保存的是兼职队的数据

01:41.700 --> 01:47.260
字点中会保存兼职队的数据

01:49.340 --> 01:51.740
其实咱们怎么兼职队的数据

01:51.740 --> 01:55.380
在特别是前端开发里边会经常看到

01:55.380 --> 01:55.900
对吧

01:55.900 --> 01:57.500
我们的接剩格式的数据

01:57.540 --> 01:58.420
是不是兼职队

01:58.420 --> 01:59.340
一个属性名

01:59.340 --> 02:00.700
一个属性值

02:00.700 --> 02:03.620
咱们的ATTP请求

02:03.620 --> 02:07.860
或者是响应请求头和响应头里边

02:07.860 --> 02:09.860
也是一个一个的兼职队

02:09.860 --> 02:11.780
像兼职队的数据

02:11.780 --> 02:14.940
是咱们在前端开发中会经常看到的

02:14.940 --> 02:16.820
而且兼职队的数据

02:16.820 --> 02:18.340
它有这么一个特点

02:18.340 --> 02:20.020
兼职队的数据

02:20.020 --> 02:21.500
兼职队数据的特点

02:22.780 --> 02:24.300
它有什么样的特点呢

02:24.300 --> 02:25.300
兼

02:27.100 --> 02:28.100
兼

02:29.380 --> 02:30.500
打不出来

02:30.500 --> 02:33.660
兼可以是任何类型

02:33.660 --> 02:35.140
我们把它用单词来表述

02:38.940 --> 02:40.100
就是我们的key字

02:40.100 --> 02:41.740
它可以是任何类型

02:41.740 --> 02:44.140
但不允许重复

02:44.140 --> 02:45.500
对不对

02:45.500 --> 02:47.980
咱们的接生配置文件里边

02:47.980 --> 02:49.740
你能配置一个重复的签名吗

02:49.740 --> 02:51.020
肯定是不行

02:51.020 --> 02:53.620
咱们在请求头和响应头里边

02:53.620 --> 02:54.700
你能配置重复吗

02:54.700 --> 02:55.540
也不行

02:55.580 --> 02:57.300
说见了他可以是任何类型

02:57.300 --> 02:59.460
我们平时见到最多的一个见

02:59.460 --> 03:01.540
他都是使用的是字不创

03:01.540 --> 03:02.820
因为个字不创作为属性名

03:02.820 --> 03:04.060
或者是作为见名

03:04.060 --> 03:05.180
但是其实呢

03:05.180 --> 03:06.180
他可以是数字

03:06.180 --> 03:07.060
可以是布尔

03:07.060 --> 03:07.940
可以是一个对象

03:07.940 --> 03:09.260
可以是任何类型

03:09.260 --> 03:10.780
但是不管你是咋类型

03:10.780 --> 03:12.260
不允许重复

03:12.260 --> 03:13.580
不允许重复

03:13.580 --> 03:15.260
这是见的特点

03:15.260 --> 03:16.900
值呢

03:16.900 --> 03:17.940
值呢

03:17.940 --> 03:19.100
value

03:19.100 --> 03:21.740
也可以是任何类型

03:21.740 --> 03:23.060
也可以是任何类型

03:23.100 --> 03:24.540
那么坚合值

03:24.540 --> 03:25.940
他们是成对出现的

03:25.940 --> 03:27.780
一个见对一个值

03:27.780 --> 03:28.740
因此呢

03:28.740 --> 03:30.340
我们还有这个特点

03:30.340 --> 03:31.780
每个见

03:31.780 --> 03:35.580
每个见对应一个值

03:35.580 --> 03:37.500
值也可以是任何类型

03:37.500 --> 03:38.820
怎么值这个类型呢

03:38.820 --> 03:40.180
他比方说他可以是字不创

03:40.180 --> 03:41.260
也可以是数字

03:41.260 --> 03:42.820
也可以是一个对象

03:42.820 --> 03:43.340
甚至呢

03:43.340 --> 03:46.020
可以是个数组都想都想

03:46.020 --> 03:47.180
而我们这里呢

03:47.180 --> 03:48.620
开发的这个字点类啊

03:48.620 --> 03:49.380
他保存的

03:49.380 --> 03:52.100
里边保存的就是一个一个的见值对

03:52.140 --> 03:54.260
一个一个的见值对

03:54.260 --> 03:55.980
我们在平时的开发中呢

03:55.980 --> 03:57.900
特别是在GS里边

03:57.900 --> 03:58.980
见的值呢

03:58.980 --> 03:59.660
见呢

03:59.660 --> 04:00.620
它是不允许重复的

04:00.620 --> 04:02.100
比方说我们的map对吧

04:02.100 --> 04:03.460
map里边

04:03.460 --> 04:05.780
我们之前学过GS里面的数据类型

04:05.780 --> 04:06.340
一个map

04:06.340 --> 04:08.020
它是ES6里面出现的

04:08.020 --> 04:09.540
如果你没有学过呢

04:09.540 --> 04:10.500
其实也没关系

04:10.500 --> 04:11.060
也没关系

04:11.060 --> 04:13.100
我们这一课自己开发

04:13.100 --> 04:13.660
以前呢

04:13.660 --> 04:16.340
其他GS里面也有类式见值对的类型

04:16.340 --> 04:16.700
但是呢

04:16.700 --> 04:17.980
他们有一个特点就是

04:17.980 --> 04:20.500
见可以是任何类型没问题

04:20.500 --> 04:21.700
也不允许重复

04:21.700 --> 04:22.540
但是呢

04:22.540 --> 04:25.100
见的类型可以不同意

04:25.100 --> 04:26.420
在一个见值对里边

04:26.420 --> 04:27.700
它有的时候是一个字符串啊

04:27.700 --> 04:28.780
有的时候是一个数字

04:28.780 --> 04:29.380
有的时候呢

04:29.380 --> 04:31.060
是一个对象都可以

04:31.060 --> 04:33.380
但是实际我们在开发中

04:33.380 --> 04:34.260
很多时候

04:34.260 --> 04:36.300
应该说绝大部分时候

04:36.300 --> 04:37.380
他们的类型呢

04:37.380 --> 04:38.460
都是同一的

04:38.460 --> 04:40.420
见如果你规定它是一个字符串

04:40.420 --> 04:41.580
那么它永远是字符串

04:41.580 --> 04:43.220
所有的见都是字符串

04:43.220 --> 04:43.900
而值呢

04:43.900 --> 04:44.940
你规定它是一个对象

04:44.940 --> 04:47.020
那么所有的值都是一个对象啊

04:47.020 --> 04:48.700
我们更多的时候呢

04:48.700 --> 04:50.780
需要把它的类型来进行统一

04:50.820 --> 04:51.740
而TS呢

04:51.740 --> 04:53.660
就给我们了这样的机会啊

04:53.660 --> 04:53.780
好

04:53.780 --> 04:56.660
所以说我们这里开发的这个字点类啊

04:56.660 --> 04:59.020
它里面保存的是一个一个的见值对

04:59.020 --> 05:02.500
那么我们会给它一个额外的要求啊

05:02.500 --> 05:03.900
就是所有的见

05:05.820 --> 05:08.300
见类型相同

05:08.300 --> 05:09.060
并且呢

05:09.060 --> 05:12.460
所有的值类型相同

05:12.460 --> 05:14.140
它有这么一个特点

05:14.140 --> 05:14.780
好

05:14.780 --> 05:15.580
了解呢

05:15.580 --> 05:17.500
我们这个字点类

05:17.500 --> 05:20.420
它里面存放了这些见值位的特点之后呢

05:20.460 --> 05:22.620
我们再来想想下一个目标

05:22.620 --> 05:23.500
就是这个字点呢

05:23.500 --> 05:26.900
它应该给我们提供一些什么样的操作啊

05:27.740 --> 05:28.900
字点类中

05:30.180 --> 05:31.780
对见值对数据

05:31.780 --> 05:34.900
见值对数据的操作

05:34.900 --> 05:36.300
应该可以有哪些操作呢

05:36.300 --> 05:37.220
我们想一想呢

05:37.220 --> 05:39.180
至少得有这么一些操作

05:39.180 --> 05:40.340
第一个操作呢

05:40.340 --> 05:43.900
就是添加一个见值对

05:43.900 --> 05:45.580
添加一个见值对

05:45.580 --> 05:46.300
第二个操作呢

05:46.300 --> 05:52.940
是按照按照件按照件

05:54.940 --> 05:56.220
你给它一个见

05:56.220 --> 05:57.540
然后呢

05:57.540 --> 06:00.860
删除对应的见值对

06:03.100 --> 06:03.820
然后当然呢

06:03.820 --> 06:04.740
还会有一些

06:04.740 --> 06:06.540
比如说循环啊

06:06.540 --> 06:08.900
循环一个循环操作

06:08.900 --> 06:11.700
循环每一个见值对

06:11.700 --> 06:12.500
所以说这几刻呢

06:12.500 --> 06:13.980
时间会比较长一点啊

06:13.980 --> 06:16.180
我们把这个东西开发好一点

06:16.220 --> 06:17.620
循环每一个见值对

06:17.620 --> 06:18.860
有这么一个操作

06:18.860 --> 06:19.460
然后呢

06:19.460 --> 06:24.540
得到当前见值对的数量啊

06:24.540 --> 06:25.540
还有这么个操作

06:25.540 --> 06:26.220
还有呢

06:26.220 --> 06:27.460
可以判断啊

06:27.460 --> 06:28.140
判断

06:30.140 --> 06:32.580
怎么判断某个见

06:33.980 --> 06:35.780
是否存在啊

06:35.780 --> 06:36.900
还有这样的操作

06:36.900 --> 06:37.500
再比方说

06:37.500 --> 06:38.700
还有一个操作啊

06:38.700 --> 06:40.980
就是重新啊

06:40.980 --> 06:44.020
重新设置某个见

06:45.020 --> 06:47.620
对应的值啊

06:47.620 --> 06:49.220
如果不存在啊

06:49.220 --> 06:50.220
如果不存在

06:50.220 --> 06:51.780
这添加啊

06:51.780 --> 06:52.340
如果不存在

06:52.340 --> 06:53.620
就添加啊

06:53.620 --> 06:55.420
或者是我们就不要这个添加了吧

06:55.420 --> 06:55.940
对吧

06:55.940 --> 06:56.260
添加

06:56.260 --> 06:57.820
我们用下面这个就可以了

06:57.820 --> 06:59.140
设置某一个见对的值

06:59.140 --> 07:00.060
如果不存在就添加

07:00.060 --> 07:02.100
那么下面这个可以做添加了

07:02.100 --> 07:04.260
这是咱们要在这个内里面

07:04.260 --> 07:05.540
提供了一些函数

07:05.540 --> 07:06.780
就是操作就是函数嘛

07:06.780 --> 07:07.220
对吧

07:07.220 --> 07:08.340
提供了一些方法

07:08.340 --> 07:10.100
我们可以通过这些方法了

07:10.100 --> 07:12.380
来操作这个字点

07:12.380 --> 07:13.500
也就是见值对

07:13.540 --> 07:15.500
其实字点就是个点心的见值对

07:15.500 --> 07:15.940
对吧

07:15.940 --> 07:17.540
我们为什么把它叫做字点

07:17.540 --> 07:20.540
你看我们字点里边就我们中文字点吧

07:20.540 --> 07:23.220
我们要查找一个字的目录里边

07:23.220 --> 07:23.780
你看一下

07:23.780 --> 07:25.380
想回想一下

07:25.380 --> 07:26.420
偏旁

07:26.420 --> 07:27.060
偏旁

07:27.060 --> 07:28.900
按照偏旁部是来查造的话

07:28.900 --> 07:30.860
偏旁就是见对不对

07:30.860 --> 07:32.420
对应的夜码

07:32.420 --> 07:33.620
所以就是值

07:33.620 --> 07:36.180
偏旁见对应的夜码就是值

07:36.180 --> 07:37.740
这就其实就是一个见值对

07:38.820 --> 07:39.860
好

07:39.860 --> 07:41.180
我们分析出来了

07:41.180 --> 07:43.020
我们要做的事情之后啊

07:43.100 --> 07:45.380
我们接下来就开始写这个类了

07:45.380 --> 07:47.180
写这个类的时候呢

07:47.180 --> 07:49.620
首先我们就应该想到这么一个问题

07:49.620 --> 07:53.460
这里面要保存一个见值对的数据

07:53.460 --> 07:56.340
那么见它是一组值对不对

07:56.340 --> 07:56.980
值呢

07:56.980 --> 07:58.460
它也是一组值

07:58.460 --> 07:59.660
我们在这里面呢

07:59.660 --> 08:03.420
可以使用两个私有的数组

08:03.420 --> 08:04.740
两个私有的数组

08:04.740 --> 08:05.620
一个数组呢

08:05.620 --> 08:07.300
来保存我们的见

08:07.300 --> 08:09.700
把我们的所有的见来保存下来

08:09.700 --> 08:10.620
另一个数组呢

08:10.620 --> 08:12.660
来保存所有的值

08:12.700 --> 08:13.740
好我们首先呢

08:13.740 --> 08:15.100
写这么一个数组啊

08:15.100 --> 08:17.580
kiss来保存所有的见

08:18.820 --> 08:19.540
然后呢

08:19.540 --> 08:20.820
再写一个数组

08:20.820 --> 08:24.220
vals来保存所有的值

08:24.220 --> 08:26.260
就比方说我有这么一个见值对

08:26.260 --> 08:26.740
假设

08:27.900 --> 08:28.780
我到时候呢

08:28.780 --> 08:31.100
有这么一个见值对给他

08:31.100 --> 08:33.020
比方说随便写吧

08:33.020 --> 08:35.500
a是一是一

08:35.500 --> 08:38.820
b呢是二十二

08:38.820 --> 08:39.660
假设

08:39.660 --> 08:42.220
c呢是三十三

08:42.220 --> 08:44.020
比方说有这么一个见值对

08:44.020 --> 08:44.620
到时候呢

08:44.620 --> 08:46.780
我通过这个字点来保存的时候呢

08:46.780 --> 08:47.780
他怎么保存

08:47.780 --> 08:49.580
就把这个abc啊

08:49.580 --> 08:53.420
把这个abc保存到这个数组里边

08:53.420 --> 08:54.140
然后呢

08:54.140 --> 08:58.420
把这个十一二十二三十三保存到这个数组里边

08:58.420 --> 08:59.580
保存到这个数组里边

08:59.580 --> 09:01.540
我们通过这两个数组呢

09:01.540 --> 09:05.540
分别来对见和所有的值来进行保存

09:05.540 --> 09:06.260
这两个数组呢

09:06.260 --> 09:08.180
我们要严格按照顺序啊

09:08.180 --> 09:09.100
保持一致

09:09.100 --> 09:11.300
要严格按照顺序来保持一致

09:11.300 --> 09:11.900
这样子呢

09:11.900 --> 09:13.060
我们到时候取的时候呢

09:13.060 --> 09:15.820
就用对应的所引去取就行了

09:15.820 --> 09:16.060
好

09:16.060 --> 09:17.540
这是我们分析出来的结果

09:17.540 --> 09:18.620
我们用这种方式来做

09:18.620 --> 09:20.140
当然这里的做法有很多啊

09:20.140 --> 09:20.740
大家可以下来

09:20.740 --> 09:22.540
可以想象还有没有其他方式

09:22.540 --> 09:23.140
我这里呢

09:23.140 --> 09:25.660
就使用这种方式来做

09:25.660 --> 09:25.820
好

09:25.820 --> 09:27.540
这里就出现一个问题

09:27.540 --> 09:30.540
当我给这个属性来进行约束的时候

09:30.540 --> 09:31.700
约束他的内行的时候

09:31.700 --> 09:33.980
当然可不可以不约束

09:33.980 --> 09:34.980
当然可以不约束

09:34.980 --> 09:36.500
我就不做任何约束

09:36.500 --> 09:38.300
也可以把这个内杆写出来

09:38.300 --> 09:40.100
那就使用以前介石的写法

09:40.100 --> 09:40.620
对吧

09:40.660 --> 09:42.300
不做任何的内行约束

09:42.300 --> 09:45.100
那如果我不做任何的内行约束的话

09:45.100 --> 09:47.060
那我讲这些课干嘛呢

09:47.060 --> 09:48.780
那讲这一课没有这么

09:48.780 --> 09:49.620
没有任何的意义

09:49.620 --> 09:50.460
对吧

09:50.460 --> 09:52.380
所以说我们既然在学TS

09:52.380 --> 09:54.020
我们还是对每一个地方呢

09:54.020 --> 09:55.540
对他进行严格的约束

09:55.540 --> 09:56.780
其实也可以防止咱们

09:56.780 --> 09:59.420
后续写单码的过程中出现一些

09:59.420 --> 10:02.700
避免避免后续单码中的出现一些低级的错误

10:03.740 --> 10:03.940
好

10:03.940 --> 10:04.340
这里呢

10:04.340 --> 10:06.620
我们首先对这个键进行约束

10:06.620 --> 10:07.860
首先他肯定是一个数组

10:07.860 --> 10:09.380
这个毫无疑问

10:09.420 --> 10:12.500
那么问题是他是一个什么内形的数组呢

10:12.500 --> 10:13.940
这里说不知道啊

10:13.940 --> 10:16.780
我并不知道这每一个键是什么内形

10:16.780 --> 10:18.620
但我能够清楚的知道

10:18.620 --> 10:20.580
他的内形是统一的

10:20.580 --> 10:21.740
那怎么办呢

10:21.740 --> 10:22.660
怎么办

10:22.660 --> 10:25.740
所以使用本节课学习的翻型的知识

10:25.740 --> 10:27.260
我给这个内呢

10:27.260 --> 10:28.380
加上一个翻型

10:28.380 --> 10:29.940
现在我不用T的啊

10:29.940 --> 10:31.620
我用K表示T

10:31.620 --> 10:32.740
是T

10:32.740 --> 10:34.180
T的内形

10:34.180 --> 10:36.940
那么每一表示我们的键的内形是什么

10:36.940 --> 10:38.580
比如说这里

10:38.580 --> 10:40.340
如果我们一个键是一个字幕券的话

10:40.340 --> 10:41.780
那么到时候用这个内的时候呢

10:41.780 --> 10:42.980
这里就传一个什么

10:42.980 --> 10:44.300
传一个字幕券进来

10:44.300 --> 10:45.460
就这么简单

10:45.460 --> 10:46.540
所以说这里呢

10:46.540 --> 10:48.780
我用K这个字母来表示

10:48.780 --> 10:50.700
键的就是键这个数组

10:50.700 --> 10:52.020
每一项的内形

10:52.020 --> 10:53.060
键是什么内形

10:53.060 --> 10:53.580
那这里呢

10:53.580 --> 10:54.180
解啥

10:54.180 --> 10:55.260
就写K

10:55.260 --> 10:56.380
对不对

10:56.380 --> 10:56.580
好

10:56.580 --> 10:57.220
这里爆出了

10:57.220 --> 10:57.940
爆出的原因呢

10:57.940 --> 10:59.220
是没有进行初始化

10:59.220 --> 11:01.260
给他进行一下初始化的

11:01.260 --> 11:01.460
好

11:01.460 --> 11:02.380
下面这个

11:02.380 --> 11:03.420
直

11:03.420 --> 11:05.620
直的内形是不是跟键的内形一样的

11:06.620 --> 11:07.820
想一想

11:07.820 --> 11:09.620
键直对

11:09.620 --> 11:10.420
键直对

11:10.420 --> 11:11.100
键直对

11:11.100 --> 11:13.260
直的内形是不是必须要跟键一样

11:13.260 --> 11:14.980
是不是不是啊

11:14.980 --> 11:15.780
直的内形呢

11:15.780 --> 11:16.980
是可以不一样的

11:16.980 --> 11:17.860
可以一样

11:17.860 --> 11:18.660
也可以不一样

11:18.660 --> 11:19.020
因此呢

11:19.020 --> 11:20.220
他们两者之间呢

11:20.220 --> 11:21.460
没有必然的联系

11:21.460 --> 11:24.060
因此我这里还需要写一个方向

11:24.060 --> 11:25.260
比方说V

11:25.260 --> 11:26.540
表示Value

11:26.540 --> 11:27.700
表示直

11:27.700 --> 11:28.500
好了吗

11:28.500 --> 11:29.380
直这个数组呢

11:29.380 --> 11:31.580
每一项就是个V

11:31.580 --> 11:33.620
同样的给他复个出字

11:33.620 --> 11:35.100
OK

11:35.140 --> 11:35.420
好了

11:35.420 --> 11:38.020
现在我们的有了这么两个数组之后

11:38.020 --> 11:39.340
有了这么两个数组之后

11:39.340 --> 11:39.900
一个数组呢

11:39.900 --> 11:40.980
保存谁的键

11:40.980 --> 11:42.100
每一项是k

11:42.100 --> 11:42.780
一个数组呢

11:42.780 --> 11:43.700
保存谁的直

11:43.700 --> 11:45.580
每一个像每一项是v

11:45.580 --> 11:46.540
接下来我们来看一下

11:46.540 --> 11:47.780
这里面有哪些操作

11:49.100 --> 11:49.900
首先呢

11:49.900 --> 11:52.020
我们来做这个操作吧

11:52.020 --> 11:52.780
这里

11:52.780 --> 11:54.980
设置某一个键

11:54.980 --> 11:56.140
对应的直

11:56.140 --> 11:57.460
如果不存在的话

11:57.460 --> 11:59.260
这添加这个直

11:59.260 --> 12:00.220
设置某个键

12:00.220 --> 12:01.140
对应的直

12:01.140 --> 12:01.300
好

12:01.300 --> 12:04.460
我们首先来写下这个函这个方法

12:04.500 --> 12:05.340
比方这个方法呢

12:05.340 --> 12:07.540
就该取名为set

12:07.540 --> 12:10.140
设置某一个东西

12:10.140 --> 12:11.580
这个方法呢

12:11.580 --> 12:13.060
需要两个参数

12:13.060 --> 12:14.100
一个参数呢

12:14.100 --> 12:16.140
你要把键告诉

12:16.140 --> 12:17.580
你要设置一个直吗

12:17.580 --> 12:19.020
哪个键对应哪个直

12:19.020 --> 12:20.940
比方说我们这里要添加

12:20.940 --> 12:22.380
或者是设置

12:22.380 --> 12:24.420
地的直为44

12:24.420 --> 12:25.420
那么要传什么

12:25.420 --> 12:27.300
把地这个字不算传进去

12:27.300 --> 12:28.860
还把他的直要传进去

12:28.860 --> 12:29.500
就这个意思

12:30.860 --> 12:32.460
那么这里set的时候呢

12:32.460 --> 12:33.620
你要传一个键

12:33.660 --> 12:35.940
也要传一个直

12:35.940 --> 12:37.500
那大家想一想啊

12:37.500 --> 12:38.780
大家想一想

12:38.780 --> 12:39.820
这里呢

12:39.820 --> 12:42.140
每一个参数是啥内容呢

12:42.140 --> 12:43.820
这个key是啥内容

12:43.820 --> 12:45.820
key建的直是什么内容

12:45.820 --> 12:46.900
当然就是key对吧

12:46.900 --> 12:48.140
我们之前也说

12:48.140 --> 12:49.300
就通过这个方形呢

12:49.300 --> 12:50.420
我们在每一个地方呢

12:50.420 --> 12:51.500
就可以保持一致了

12:51.500 --> 12:51.940
而且呢

12:51.940 --> 12:54.060
这些内容是可以变化的

12:54.060 --> 12:54.260
好

12:54.260 --> 12:55.420
挖的直呢

12:55.420 --> 12:56.420
就是v

12:56.420 --> 12:57.940
就是v

12:57.940 --> 12:58.220
好

12:58.220 --> 13:00.260
接下来我要做啥呢

13:00.260 --> 13:02.220
我要首先看一下

13:02.220 --> 13:04.980
建这个数组里边有没有这个直

13:04.980 --> 13:05.460
对吧

13:05.460 --> 13:07.660
我首先从这个数组里边去找这个东西

13:07.660 --> 13:08.700
看能不能找到啊

13:08.700 --> 13:10.140
有没有这个直

13:10.140 --> 13:11.460
怎么找呢

13:11.460 --> 13:12.780
可以通过这种方式啊

13:12.780 --> 13:13.780
key是你看

13:13.780 --> 13:16.460
s叫key是他不是个数组吗

13:16.460 --> 13:17.820
数组里面有个函数

13:17.820 --> 13:19.100
index

13:19.100 --> 13:20.420
你看全是有智能提示的

13:20.420 --> 13:22.340
因为他知道key是什么内容

13:22.340 --> 13:23.660
如果你不用ts的话

13:23.660 --> 13:24.540
根本就不知道

13:24.540 --> 13:26.220
这个key是他到底是啥内容

13:26.220 --> 13:28.660
他就没有办法给你进行智能提示

13:29.900 --> 13:30.500
好

13:30.540 --> 13:32.460
判断一下index

13:32.460 --> 13:34.340
那么把什么东西传进去

13:34.340 --> 13:35.740
把key传进去

13:35.740 --> 13:37.460
看一下这个玩意

13:37.460 --> 13:41.060
在这个数组中出现的锁印是多少

13:41.060 --> 13:41.300
ok

13:41.300 --> 13:42.620
我们来得到他的锁印

13:42.620 --> 13:44.900
反过来结果index

13:44.900 --> 13:47.460
就是个锁印或者使用i

13:47.460 --> 13:48.780
当然根据他的推断

13:48.780 --> 13:49.820
这个i什么类型

13:49.820 --> 13:50.500
i是个number

13:50.500 --> 13:52.100
你看每一个地方都有推断的

13:53.900 --> 13:54.980
拿到这个i过后

13:54.980 --> 13:56.500
就拿到他的锁印了

13:56.500 --> 13:58.060
我们来判断一下

13:58.060 --> 14:00.140
如果i小于0

14:00.140 --> 14:01.700
就等于-1

14:01.700 --> 14:02.940
-1啥意思

14:02.940 --> 14:03.900
这个应该很熟悉

14:03.900 --> 14:04.820
对吧

14:04.820 --> 14:05.460
-1啥意思

14:05.460 --> 14:08.020
表示这个数组里边不存在

14:08.020 --> 14:09.380
没有这个键

14:09.380 --> 14:11.540
那没有这个键还不好说吗

14:11.540 --> 14:12.980
没有这个键怎么办

14:12.980 --> 14:15.620
刚才我们写的

14:15.620 --> 14:18.380
如果设置某个键的值

14:18.380 --> 14:19.300
如果不存在的话

14:19.300 --> 14:20.140
就添加

14:20.140 --> 14:21.100
那就添加

14:21.820 --> 14:22.620
添加

14:22.620 --> 14:22.860
好

14:22.860 --> 14:24.660
首先在这个数组里边

14:24.660 --> 14:26.340
push

14:26.340 --> 14:27.620
添加以下

14:27.620 --> 14:29.100
添加以下啥

14:29.100 --> 14:29.820
key

14:29.860 --> 14:30.900
多了一个键的

14:30.900 --> 14:31.500
然后呢

14:31.500 --> 14:33.060
值也多了一个了

14:33.060 --> 14:33.820
vows

14:33.820 --> 14:34.620
push

14:34.620 --> 14:35.740
多了一个值了

14:37.100 --> 14:38.380
把这两个添加进去

14:39.060 --> 14:39.900
l

14:39.900 --> 14:41.620
如果存在的话

14:41.860 --> 14:43.020
存在的话怎么办

14:43.020 --> 14:44.300
就是这个键找到了

14:44.300 --> 14:45.580
比方说这个键找到了

14:45.580 --> 14:47.900
在这个数组里边的第三项

14:48.460 --> 14:49.580
比方说找到了

14:49.580 --> 14:50.500
那么找到过后

14:50.500 --> 14:51.260
你要干嘛呢

14:51.260 --> 14:51.900
你想一想

14:51.900 --> 14:53.220
比方说找到的这个键

14:54.540 --> 14:56.140
找到个键在第三项

14:56.140 --> 14:57.740
也就是虾表尾2

14:58.140 --> 14:59.780
那么你要做的事情就是

14:59.980 --> 15:01.260
找到对应的值

15:01.260 --> 15:02.540
虾表尾2的值

15:02.540 --> 15:04.780
把这个值设置为啥

15:04.780 --> 15:06.140
设置为这个值

15:06.140 --> 15:07.420
就是更改它的值

15:07.420 --> 15:08.060
对不对

15:08.060 --> 15:09.820
所以说这里我要做的就是

15:09.820 --> 15:11.100
找到这个V

15:11.100 --> 15:12.060
把这个i

15:12.060 --> 15:13.260
虾表传进去

15:13.260 --> 15:14.460
找到对应这个值

15:14.460 --> 15:16.540
把它更改为它们的V

15:16.540 --> 15:18.300
就完事了

15:19.500 --> 15:21.260
咱们来试一下吧

15:21.260 --> 15:22.780
我们写个函数就试一下

15:22.780 --> 15:23.900
这个函数最后呢

15:23.900 --> 15:25.180
我来测试一下

15:25.180 --> 15:26.380
打印出键

15:26.380 --> 15:27.820
打印出键

15:27.820 --> 15:29.660
然后再打印出值

15:30.140 --> 15:30.940
值

15:30.940 --> 15:31.740
vars

15:31.740 --> 15:32.780
把两个打印出来

15:32.780 --> 15:34.380
我们换行打印吧

15:35.660 --> 15:36.540
console

15:36.540 --> 15:37.660
devlog

15:37.660 --> 15:38.140
值

15:38.140 --> 15:39.260
vars

15:39.260 --> 15:39.740
好

15:39.740 --> 15:40.780
每一家一次呢

15:40.780 --> 15:42.780
我们都在换行打印一次

15:42.780 --> 15:42.940
好

15:42.940 --> 15:44.300
我们来测试一下

15:44.300 --> 15:44.540
好

15:44.540 --> 15:47.260
这里导入这个

15:47.260 --> 15:48.060
创举一个对象

15:48.060 --> 15:49.180
创举一个对象

15:49.180 --> 15:50.700
dick

15:50.700 --> 15:51.260
new

15:51.260 --> 15:52.460
一个dictionary

15:53.340 --> 15:53.580
好

15:53.580 --> 15:54.860
给它传两个犯行

15:55.420 --> 15:56.380
传两个犯行

15:56.380 --> 15:57.420
这个时候它没法推倒

15:57.420 --> 15:58.540
如果你直接这样子写的话

15:58.540 --> 15:59.500
它推倒不出来

15:59.580 --> 16:01.100
它不知道这两个类型是啥

16:01.100 --> 16:01.500
因此呢

16:01.500 --> 16:02.780
我这里手动传一下吧

16:02.780 --> 16:04.940
然后第一个件的类型是支付串

16:04.940 --> 16:05.980
值的类型呢

16:05.980 --> 16:07.260
是number

16:07.260 --> 16:07.980
假设

16:08.940 --> 16:09.980
来看一下

16:09.980 --> 16:11.580
创建这么一个字点

16:11.580 --> 16:12.060
然后呢

16:12.060 --> 16:13.820
它里面有函数set

16:13.820 --> 16:15.020
往字件里面添加数据

16:15.020 --> 16:17.420
你看现在通过翻译型就推断出来了

16:17.420 --> 16:19.820
你件的类型必须是一个支付串

16:19.820 --> 16:21.260
你就不能试其他的了

16:21.260 --> 16:23.020
这就满足我们的这里的要求

16:23.020 --> 16:24.780
所有的件的类型相同

16:24.780 --> 16:25.660
所有的值呢

16:25.660 --> 16:26.700
类型也相同

16:26.700 --> 16:28.220
你看这里就该约束好了

16:28.220 --> 16:29.180
这个字件里边

16:29.260 --> 16:31.340
你所有的件都必须是支付串

16:31.340 --> 16:32.060
所有的值呢

16:32.060 --> 16:33.100
都必须是number

16:33.100 --> 16:34.220
以前的接式里面

16:34.220 --> 16:36.860
你是没有办法进行这样的约束的

16:36.860 --> 16:37.340
好

16:37.340 --> 16:38.220
添加

16:38.220 --> 16:40.060
第一个件比方叫M

16:40.060 --> 16:41.100
A

16:41.100 --> 16:41.980
E

16:41.980 --> 16:43.020
保存一下

16:43.020 --> 16:43.900
咱们来看一下

16:46.300 --> 16:47.580
np1

16:47.580 --> 16:48.060
对

16:50.780 --> 16:51.500
咱们看一下

16:51.500 --> 16:51.940
你看

16:51.940 --> 16:52.700
件里面

16:52.700 --> 16:54.300
这个数组里面多了一个A

16:54.300 --> 16:54.700
值呢

16:54.700 --> 16:55.500
就多了一个E

16:55.500 --> 16:56.060
对吧

16:56.060 --> 16:56.860
咱们又来

16:57.580 --> 16:58.140
又加一个

16:59.660 --> 17:00.300
加一个B

17:01.020 --> 17:01.420
2

17:03.420 --> 17:03.980
看一下

17:05.580 --> 17:06.860
第一次添加过后呢

17:06.860 --> 17:08.140
是这个样子

17:08.140 --> 17:09.500
第二次添加过后呢

17:09.500 --> 17:09.820
你看

17:09.820 --> 17:10.940
件里面就是A和B了

17:10.940 --> 17:12.460
纸里面就是一和二了

17:12.460 --> 17:12.620
好

17:12.620 --> 17:13.100
那么接下来

17:13.100 --> 17:14.380
我们再来测试一下

17:14.380 --> 17:15.500
我把这个A纸呢

17:15.500 --> 17:16.540
重新修改一下

17:16.540 --> 17:17.660
sets

17:17.660 --> 17:19.180
A等于11

17:19.980 --> 17:20.460
随便写

17:21.820 --> 17:21.980
好

17:21.980 --> 17:22.700
你看

17:22.700 --> 17:24.220
第一次完成过后是这个样子

17:25.020 --> 17:26.540
第二次完成过后是这个样子

17:26.540 --> 17:27.660
加了一个B

17:27.660 --> 17:28.780
第三次完成过后呢

17:28.780 --> 17:29.580
A的纸呢

17:29.580 --> 17:30.220
对你的纸呢

17:30.300 --> 17:31.180
变成了11

17:31.180 --> 17:32.380
我们把它的

17:33.100 --> 17:33.820
执行过程呢

17:33.820 --> 17:34.860
把它打印出来看了

17:34.860 --> 17:35.580
没问题

17:35.580 --> 17:36.460
没问题

17:36.460 --> 17:36.780
好

17:36.780 --> 17:38.540
那么这个函数就写好了

17:38.540 --> 17:39.580
这个函数就写好了

17:40.380 --> 17:40.460
好

17:40.460 --> 17:42.140
这是这个函数

17:42.140 --> 17:42.860
咱们来看一下

17:42.860 --> 17:43.820
还有哪些函数要写

17:44.940 --> 17:45.980
这个函数写好了

17:45.980 --> 17:47.020
我们打个ok

17:48.860 --> 17:49.180
好

17:49.180 --> 17:50.300
下面我们写个循环吧

17:50.860 --> 17:52.620
循环每一个键子队

17:53.180 --> 17:54.620
循环每一个键子队

17:54.620 --> 17:55.580
我们写这么一个函数

17:56.140 --> 17:56.860
这个函数呢

17:56.860 --> 17:57.820
就该取个名字

17:57.820 --> 17:59.180
用我们熟悉的名字

17:59.180 --> 18:00.060
for each

18:01.020 --> 18:02.060
我这里呢

18:02.060 --> 18:03.100
进行循环

18:03.100 --> 18:04.540
循环每一个键子队

18:04.540 --> 18:07.100
每次我循环到一个键子队的时候呢

18:07.100 --> 18:08.620
我就会交给你

18:08.620 --> 18:10.860
你给我传一个回调函数进来

18:11.420 --> 18:11.980
我会把

18:12.700 --> 18:14.860
我拿到的每一个键子队

18:14.860 --> 18:16.380
交给你这个回调函数

18:16.380 --> 18:17.740
然后你剩下的事情呢

18:17.740 --> 18:18.540
你去处理

18:18.540 --> 18:20.060
你去处理这个剩下的事情

18:20.940 --> 18:21.740
因此呢

18:21.740 --> 18:24.540
我需要你这里传递一个回调函数

18:24.540 --> 18:26.860
那么传递什么格式的回调函数呢

18:27.500 --> 18:30.540
我这里先对这个回调函数进行一下约束

18:30.540 --> 18:32.060
其实我可以把导出去

18:32.060 --> 18:32.460
type

18:34.380 --> 18:35.580
callback

18:35.580 --> 18:36.220
callback

18:36.220 --> 18:37.180
这个回调函数

18:37.980 --> 18:40.620
我会把一个兼职队来传给你

18:40.620 --> 18:42.300
会把一个兼职队来传给你

18:42.300 --> 18:42.940
大家看一下

18:43.820 --> 18:46.460
那么你这个函数是不是得有两个参数

18:46.460 --> 18:47.340
对不对

18:47.340 --> 18:48.460
得有两个参数嘛

18:48.460 --> 18:50.060
一个是key我会传给你

18:50.060 --> 18:51.580
一个是var我会传给你

18:52.140 --> 18:53.500
那么你需不需要返回呢

18:54.300 --> 18:55.660
你I返回不返回

18:55.660 --> 18:57.260
我反正不用你的返回结果

18:57.260 --> 18:57.660
因此呢

18:57.660 --> 18:58.700
我写var的

18:58.700 --> 19:00.220
那么根据我们之前所学

19:00.860 --> 19:02.700
什么内形的兼容性的一块

19:03.260 --> 19:04.220
那么函数这里呢

19:04.220 --> 19:05.100
我返回var的

19:05.100 --> 19:05.820
那么到时候

19:05.820 --> 19:07.500
你要给我传函数的时候呢

19:08.060 --> 19:08.940
你可以返回

19:08.940 --> 19:09.580
我无所谓

19:09.580 --> 19:10.460
反正我也不用

19:10.460 --> 19:12.060
你返回的话也不影响

19:12.060 --> 19:13.180
所以说我这里写var的

19:13.180 --> 19:15.820
就跟那个我们写的之前用那个for一起是一样的

19:15.820 --> 19:16.300
对吧

19:16.300 --> 19:17.340
for一起的回调函数

19:17.340 --> 19:18.300
它不需要我们返回

19:19.180 --> 19:19.420
好

19:19.420 --> 19:20.700
现在我们的callback函数

19:20.700 --> 19:21.740
你需要给我两个东西

19:21.740 --> 19:22.300
一个是键

19:22.860 --> 19:23.420
一个是纸

19:23.980 --> 19:24.460
需要给我

19:25.340 --> 19:26.140
那么这里呢

19:26.140 --> 19:26.780
就出现一个

19:27.420 --> 19:27.820
以后

19:28.380 --> 19:29.740
这里是any内形

19:29.740 --> 19:30.140
看到没

19:30.700 --> 19:31.900
是any内形

19:31.900 --> 19:32.780
对不对

19:32.780 --> 19:33.900
any内形

19:33.900 --> 19:34.700
那么

19:34.700 --> 19:35.420
实际上呢

19:35.420 --> 19:36.780
键和纸的内形呢

19:36.780 --> 19:37.580
是有可以

19:37.580 --> 19:39.740
它是之前是约定好的

19:39.740 --> 19:41.180
约定好的内形

19:41.180 --> 19:43.340
那么到底这里该写啥内形呢

19:43.340 --> 19:43.900
可以

19:43.900 --> 19:44.940
用什么样的内形呢

19:44.940 --> 19:45.820
对它约束呢

19:46.380 --> 19:47.340
当然你可以想到

19:47.340 --> 19:48.300
这里应该写啥

19:48.300 --> 19:49.100
写k

19:49.100 --> 19:49.500
对吧

19:50.060 --> 19:50.940
写v

19:50.940 --> 19:51.260
但是

19:51.980 --> 19:53.500
但是问题来了

19:53.580 --> 19:55.100
我这里k从哪来

19:55.100 --> 19:56.620
是来自于这个内的

19:56.620 --> 19:57.740
只有在内里边

19:57.740 --> 19:59.580
我们才能使用这个k和v

19:59.580 --> 20:01.100
除了这个内能不能使用

20:01.100 --> 20:01.980
就不能使用了

20:03.180 --> 20:03.820
那咋办了

20:04.620 --> 20:05.100
那咋办

20:05.820 --> 20:07.100
不要死闹惊啊

20:07.100 --> 20:08.220
不要死闹惊

20:08.220 --> 20:09.740
你这里缺少这两个内形

20:09.740 --> 20:11.500
你把这个东西做成发行不完的嘛

20:12.060 --> 20:13.900
你把这个东西做成发行不完的嘛

20:13.900 --> 20:14.220
对吧

20:14.220 --> 20:15.740
这里的k和v跟这里的k和v

20:15.740 --> 20:16.700
没有任何关系

20:16.700 --> 20:17.580
没有任何关系

20:17.580 --> 20:18.380
就是名字

20:18.380 --> 20:20.060
恰巧相同而已

20:20.060 --> 20:20.780
当然我可以写成

20:20.780 --> 20:21.660
任何其他内形

20:22.620 --> 20:23.820
任何其他内形都可以

20:23.820 --> 20:24.380
t u

20:25.340 --> 20:26.060
t u

20:26.060 --> 20:27.020
都无所谓

20:27.020 --> 20:27.660
都无所谓

20:28.860 --> 20:30.620
表示我这个回调函数呢

20:30.620 --> 20:31.340
我也不知道

20:31.340 --> 20:32.300
它第一个参数啥内相

20:32.300 --> 20:33.180
第二个参数啥内相

20:33.180 --> 20:34.140
总之你给我呗

20:34.140 --> 20:35.340
到时候用这个内形的时候

20:35.340 --> 20:36.460
到时候你告诉我

20:36.460 --> 20:37.580
第一个参数啥内相

20:37.580 --> 20:38.540
第二个参数啥内相

20:38.540 --> 20:39.180
就完事了

20:40.300 --> 20:40.540
好

20:40.540 --> 20:41.660
for一起的时候呢

20:41.660 --> 20:43.020
你就需要给我传一个

20:43.020 --> 20:44.380
回调函数进来

20:44.380 --> 20:44.940
callback

20:45.980 --> 20:47.340
传一个回调函数

20:47.340 --> 20:48.700
这个回调函数啥内形呢

20:49.580 --> 20:50.700
是不是要用这个内形啊

20:50.700 --> 20:51.100
对不对

20:51.180 --> 20:51.980
要用这个内形

20:53.660 --> 20:55.340
要用这个callback这个内形

20:55.340 --> 20:56.780
名字一样不要搞困了

20:56.780 --> 20:57.660
这是参数

20:57.660 --> 20:59.020
这是内形先词

20:59.020 --> 21:01.020
当然你可以最好把它写成不一样吧

21:01.020 --> 21:02.620
我去把它写成不一样吧

21:02.620 --> 21:04.060
F2重新命名一下

21:04.060 --> 21:04.780
callback

21:04.780 --> 21:05.340
打写呗

21:07.020 --> 21:07.340
好

21:07.900 --> 21:08.780
那么它这个内形

21:08.780 --> 21:09.500
它现在爆错

21:09.500 --> 21:10.460
是因为它有翻译形

21:10.460 --> 21:12.140
但是你没有告诉它是什么翻译形

21:12.140 --> 21:13.500
那我现在告诉它呗

21:13.500 --> 21:15.180
那你看现在在内里边了

21:15.180 --> 21:16.700
它第一个这个回调函数的

21:16.700 --> 21:18.300
第一个参数应该是什么内形

21:18.300 --> 21:19.420
应该是k

21:19.420 --> 21:20.380
第一个参数什么内形

21:20.460 --> 21:22.780
v你看这个内形时间是可以传递的

21:22.780 --> 21:25.180
我把这个k这个内形的传递给这个t

21:25.180 --> 21:26.780
那么这个t传递给这个参数

21:26.780 --> 21:27.180
于是呢

21:27.180 --> 21:29.100
它第一个参数就是k这个内形了

21:29.100 --> 21:29.980
同样道理

21:29.980 --> 21:30.940
把v传过去

21:30.940 --> 21:32.860
它第二个参数就是v这个内形了

21:33.420 --> 21:33.740
ok

21:33.740 --> 21:34.780
我们再指这个callback

21:34.780 --> 21:35.740
你看一下啊

21:35.740 --> 21:37.100
这个callback它就知道了啊

21:37.100 --> 21:38.300
原是这个kv

21:39.420 --> 21:39.660
好

21:39.660 --> 21:42.060
你给我传这么一个回调函数新的

21:42.060 --> 21:43.260
那么接下来呢

21:43.260 --> 21:44.700
我就来帮你进行循环

21:44.700 --> 21:45.660
怎么循环呢

21:45.660 --> 21:46.380
我就这样子呗

21:47.420 --> 21:48.140
循环key吧

21:48.140 --> 21:50.140
循环key是或者是循环那个

21:50.140 --> 21:51.580
vows都一样

21:51.580 --> 21:52.140
key是

21:53.020 --> 21:53.660
for一起

21:53.660 --> 21:55.180
它是个普通数组对吧

21:55.180 --> 21:57.260
普通数组里面肯定有for一起的这个

21:58.460 --> 21:59.020
这个东西

22:00.380 --> 22:00.940
这个函数

22:01.660 --> 22:01.900
好

22:01.900 --> 22:05.260
for一起里面有每个数组的每一项

22:05.260 --> 22:08.060
每一项n或者是k嘛

22:08.060 --> 22:09.740
然后数组的下标

22:09.740 --> 22:09.980
哎

22:09.980 --> 22:11.420
为什么要得到下标呢

22:11.420 --> 22:13.020
因为我需要用这个下标

22:13.020 --> 22:15.020
从vows里面去取相应的数据

22:15.660 --> 22:15.900
好

22:15.900 --> 22:17.260
我们现在的key值是啥

22:17.260 --> 22:17.980
每次循环

22:17.980 --> 22:19.740
key值就是这个k对吧

22:19.820 --> 22:20.940
那么vows是啥呢

22:21.740 --> 22:23.020
vows我们把取出来

22:23.020 --> 22:24.300
vows是啥呢

22:24.300 --> 22:25.900
resvows

22:26.780 --> 22:27.340
哎

22:27.340 --> 22:30.460
通过下标把这个对应的值取出来

22:30.460 --> 22:31.580
那么键出来了

22:31.580 --> 22:32.860
key值出来了

22:32.860 --> 22:34.220
值也出来了

22:34.220 --> 22:35.260
你看这个值

22:35.260 --> 22:36.140
值的它知道

22:36.140 --> 22:37.580
它的类型呢是v

22:38.380 --> 22:39.820
现在还不知道v是什么类型

22:39.820 --> 22:42.220
但是你使用这个类的时候

22:42.220 --> 22:43.820
使用这个类的时候呢

22:43.820 --> 22:45.020
它就一定清楚了

22:45.020 --> 22:45.820
v是什么类型

22:45.820 --> 22:46.940
现在还不知道

22:46.940 --> 22:47.740
好

22:47.740 --> 22:48.380
没关系啊

22:48.460 --> 22:49.340
不管是啥类型

22:49.340 --> 22:51.100
现在我知道了k知道了v

22:51.100 --> 22:53.740
那么我就去调用你这个callback

22:54.460 --> 22:55.580
调用你这个callback

22:55.580 --> 22:56.540
这个回调函数

22:56.540 --> 22:58.380
你看这个回调函数是不是要两个参数

22:59.180 --> 23:00.380
这里是约定的

23:00.380 --> 23:01.980
这个回调函数有两个参数

23:01.980 --> 23:02.300
好

23:02.300 --> 23:04.860
第一个参数要传一个k这个类型

23:04.860 --> 23:05.580
那么k

23:05.580 --> 23:07.420
这个东西刚好是这个类型

23:07.420 --> 23:09.260
v刚好是这个类型

23:09.260 --> 23:09.420
好

23:09.420 --> 23:10.700
你去处理呗

23:10.700 --> 23:11.260
我不管了

23:12.060 --> 23:12.300
OK

23:12.300 --> 23:13.100
我就这样子呢

23:13.100 --> 23:14.220
我就写了一个for一起

23:14.220 --> 23:14.700
看呗

23:14.700 --> 23:15.900
我就写了一个for一起

23:16.860 --> 23:17.100
好

23:17.100 --> 23:17.820
这里呢

23:17.900 --> 23:19.580
我们就可以使用for一起

23:19.580 --> 23:22.220
我把上面那个打印删了

23:22.220 --> 23:23.100
这个打印就不要了

23:24.620 --> 23:25.340
好

23:25.340 --> 23:26.940
这里cs完了之后呢

23:26.940 --> 23:29.100
我们使用它里面提供的for一起这个函数

23:29.100 --> 23:29.500
你看

23:29.500 --> 23:30.380
现在告诉我

23:30.380 --> 23:32.220
我要传一个回调函数进去

23:33.100 --> 23:34.860
这个回调函数需要两个参数

23:34.860 --> 23:36.860
如果你只需要k值的话

23:36.860 --> 23:38.700
那么你只需要填一个参数就行了

23:38.700 --> 23:39.900
因为我们之前说过

23:39.900 --> 23:41.260
函数之间的传定了

23:41.260 --> 23:42.540
你参数数量

23:42.540 --> 23:45.020
少于等于要求的数量

23:45.020 --> 23:45.660
都是可以的

23:45.660 --> 23:46.620
好

23:46.700 --> 23:47.020
这里呢

23:47.020 --> 23:48.460
我需要两个都需要

23:48.460 --> 23:50.060
k和v都需要

23:50.060 --> 23:51.180
你告诉我呗

23:51.180 --> 23:52.140
告诉我k和v

23:52.140 --> 23:52.780
让我这里呢

23:52.780 --> 23:54.220
把间打印出来

23:54.220 --> 23:55.420
你看到到这里

23:55.420 --> 23:56.620
具体使用的时候

23:56.620 --> 23:58.460
它就非常清楚k是什么类型

23:58.460 --> 23:59.420
v是什么类型的

23:59.420 --> 24:01.020
你看k是一个字不串

24:01.020 --> 24:02.460
为什么是个字不串

24:02.460 --> 24:04.060
这个字点就是一个字不串

24:04.060 --> 24:05.500
k值就是个字不串

24:05.500 --> 24:06.380
为什么类型啊

24:06.380 --> 24:06.860
number

24:06.860 --> 24:08.780
因为这个字点的值就是number

24:08.780 --> 24:09.020
好

24:09.020 --> 24:09.660
这里

24:09.660 --> 24:10.540
我们就可以打印出

24:11.420 --> 24:13.260
k这样打印吧

24:13.260 --> 24:13.740
这样打印

24:14.540 --> 24:15.340
k的值

24:15.420 --> 24:18.220
帽号v的值

24:18.220 --> 24:18.780
v的值

24:19.660 --> 24:20.300
保存

24:20.300 --> 24:21.260
咱们看一下啊

24:21.260 --> 24:21.580
你看

24:22.700 --> 24:23.500
就打印出来了

24:23.500 --> 24:24.140
打印出来了

24:25.500 --> 24:26.380
好了

24:26.380 --> 24:28.300
这是关于这个函数

24:28.300 --> 24:29.100
关于这个函数

24:29.980 --> 24:30.860
下面我们继续写

24:32.300 --> 24:33.500
set for一起都有了

24:33.500 --> 24:33.980
对吧

24:33.980 --> 24:34.940
那么这个也好了

24:37.420 --> 24:38.060
上面这个

24:39.340 --> 24:40.140
还写哪一个呢

24:41.020 --> 24:41.820
写这个吧

24:41.820 --> 24:44.060
判断某个建设讽存在

24:44.140 --> 24:45.580
判断某个建设讽存在

24:45.580 --> 24:47.100
这个就很简单了对吧

24:47.100 --> 24:47.900
非常简单

24:47.900 --> 24:48.700
我们这里写一个

24:50.300 --> 24:50.780
heist

24:52.140 --> 24:53.420
要传一个东西进来

24:53.420 --> 24:54.460
传什么东西进来

24:54.460 --> 24:55.180
k值

24:55.180 --> 24:56.140
你告诉我一个建

24:56.780 --> 24:58.140
那么我们现在印写的很熟了

24:58.140 --> 24:59.500
知道它是k这个类型

25:00.620 --> 25:01.740
你传一个建进来

25:02.220 --> 25:03.260
传一个建进来

25:03.260 --> 25:04.620
然后判断一下这个建

25:04.620 --> 25:06.140
在这个数组里面设讽存在

25:06.140 --> 25:07.900
就是我们这里保存的建设队里面

25:07.900 --> 25:09.100
有没有这个建

25:09.100 --> 25:10.220
这个就很简单了

25:11.180 --> 25:12.140
怎么判定呢

25:12.140 --> 25:12.780
怎么判定呢

25:12.780 --> 25:13.900
我们直接返回了对吧

25:14.300 --> 25:16.780
zst是这个include

25:17.420 --> 25:19.820
这个数组中是否包含某一个字

25:20.700 --> 25:21.660
如果包含的话

25:22.380 --> 25:23.980
这个函数返回的本身就是个布尔

25:23.980 --> 25:24.700
看到没

25:24.700 --> 25:26.220
这个函数返回的本身就是个布尔

25:26.220 --> 25:27.260
所以说这个函数呢

25:27.260 --> 25:29.100
返回的也是布尔

25:29.100 --> 25:29.740
也是布尔

25:31.580 --> 25:32.700
是否包含某个东西

25:32.700 --> 25:34.540
那么如果包含的话返回处

25:34.540 --> 25:37.100
如果没有包含的话返回force就完事了

25:37.820 --> 25:38.460
几个还是

25:39.180 --> 25:40.140
我们判断一下吧

25:40.860 --> 25:41.340
等一下

25:41.980 --> 25:43.820
这里console log

25:43.820 --> 25:44.620
dick

25:44.620 --> 25:45.500
hice

25:45.500 --> 25:46.300
传一个建进去

25:46.300 --> 25:47.180
你看到了这里

25:47.180 --> 25:48.060
它就是个支付圈了

25:48.060 --> 25:49.580
因为我们具体使用的时候

25:49.580 --> 25:52.300
建它约定为一个支付圈

25:52.300 --> 25:53.260
比方说判断一下

25:53.980 --> 25:55.500
c这个建是否存在呢

25:55.500 --> 25:56.460
我们看一下结果

25:56.460 --> 25:57.580
当然是不存在的

25:57.580 --> 25:58.300
你看force

25:59.580 --> 26:00.060
好

26:00.060 --> 26:02.460
这是关于判断一个建是否存在

26:03.100 --> 26:03.740
这个OK了

26:05.580 --> 26:05.820
好

26:05.820 --> 26:06.220
接下来

26:07.180 --> 26:10.940
按照建三除对应的建置队

26:10.940 --> 26:12.140
我们要进行三除了

26:12.140 --> 26:13.020
有的时候

26:13.020 --> 26:14.220
某些东西不要了

26:14.220 --> 26:15.180
某个建置队不要了

26:15.180 --> 26:17.020
我们要把它进行三除

26:17.580 --> 26:19.820
三除对应的建置队

26:20.460 --> 26:21.100
这里呢

26:21.100 --> 26:21.900
我们写一个函数

26:23.100 --> 26:23.580
对了

26:24.300 --> 26:25.260
就那一尺这个函数

26:25.660 --> 26:27.500
这个函数你要传什么进来呢

26:27.500 --> 26:29.340
你只需要传一个建进来就行了

26:29.900 --> 26:31.500
传一个建进来就行了

26:31.500 --> 26:33.420
那么传这个建进来之后呢

26:33.420 --> 26:35.660
我把这个建它对应的东西

26:35.820 --> 26:36.620
给你删掉

26:36.620 --> 26:37.420
给你删掉

26:38.540 --> 26:38.860
好

26:38.860 --> 26:39.980
怎么删呢

26:39.980 --> 26:40.860
怎么删出数组

26:41.500 --> 26:43.340
首先我看一下啊

26:43.340 --> 26:45.100
还是跟之前一样的

26:45.100 --> 26:46.860
我看一下这个下标

26:46.860 --> 26:49.180
index或者叫i嘛

26:49.180 --> 26:52.140
从这个建的数组里边去找到

26:52.140 --> 26:52.860
index

26:53.740 --> 26:54.620
key这个字啊

26:55.340 --> 26:56.540
你要按照这个建来删

26:56.540 --> 26:58.540
那么我去看一下这个建在数组里边

26:58.540 --> 26:59.900
它的下标是什么

26:59.900 --> 27:01.100
当然这个下标是负一

27:01.100 --> 27:02.780
有可能是负一对不对

27:02.780 --> 27:04.300
有可能是负一

27:04.380 --> 27:05.820
如果是负一的话

27:05.820 --> 27:06.860
那怎么办

27:06.860 --> 27:07.980
或者是小余宁

27:07.980 --> 27:09.020
小余宁的时候

27:09.020 --> 27:10.540
或者是负一的时候怎么办

27:10.540 --> 27:12.620
表示这个建它根本就不存在

27:12.620 --> 27:13.820
那海山是什么山呢

27:13.820 --> 27:14.620
直接返回

27:14.620 --> 27:15.260
这个数

27:15.260 --> 27:16.700
不需要做任何事情

27:17.500 --> 27:19.100
那么如果啊

27:19.100 --> 27:19.660
如果

27:20.540 --> 27:22.860
它这个下标是存在的

27:22.860 --> 27:24.300
存在了怎么删呢

27:24.300 --> 27:27.180
那么把建这个数组里边相同位置

27:28.140 --> 27:28.940
给它删掉

27:28.940 --> 27:31.340
再把直这个数组里边

27:31.340 --> 27:32.540
相同的下标位置

27:32.540 --> 27:33.340
哎给它删掉

27:33.340 --> 27:34.620
就完事了啊

27:34.620 --> 27:35.500
首先呢

27:35.500 --> 27:37.740
我们使用把建这个数组里边

27:37.740 --> 27:38.380
splice

27:39.340 --> 27:40.460
下标传进去

27:40.460 --> 27:41.980
删几个就删一个

27:41.980 --> 27:42.940
建议不会重复

27:42.940 --> 27:43.260
对不对

27:43.260 --> 27:44.540
就删一个就完事了

27:44.540 --> 27:45.500
然后同样的

27:45.500 --> 27:47.180
把直这一块splice

27:48.140 --> 27:49.260
也删进去啊

27:49.260 --> 27:50.380
删一个就完事了

27:50.380 --> 27:50.780
对不对

27:50.780 --> 27:51.660
这两个数数

27:51.660 --> 27:51.900
好

27:51.900 --> 27:52.540
这就完成了

27:52.540 --> 27:53.900
建的删除

27:53.900 --> 27:54.780
咱们来试一下吧

27:55.900 --> 27:56.540
这里

27:56.540 --> 27:58.380
我们写的啊

27:58.380 --> 27:58.860
写的

27:59.820 --> 28:01.020
再写一个建

28:01.020 --> 28:01.180
C

28:01.180 --> 28:03.100
C

28:03.100 --> 28:04.860
随便写吧

28:04.860 --> 28:05.660
二十二

28:05.660 --> 28:06.540
三十三

28:06.540 --> 28:06.940
随便写

28:07.900 --> 28:08.700
好

28:08.700 --> 28:09.340
然后呢

28:09.340 --> 28:11.260
我们写前加了三个建

28:11.260 --> 28:12.380
然后先打一

28:12.380 --> 28:13.340
先打一

28:13.340 --> 28:14.060
看一下啊

28:14.060 --> 28:15.260
就这样的直

28:15.260 --> 28:16.380
然后现在进行删除

28:18.540 --> 28:19.020
好这里

28:19.020 --> 28:19.660
我们先输出

28:21.260 --> 28:22.460
删除建

28:22.460 --> 28:24.380
比方说删除建什么呢

28:24.380 --> 28:25.020
建B

28:26.380 --> 28:27.340
这个B这个建

28:27.340 --> 28:28.460
把删除掉

28:28.460 --> 28:29.740
好删除的时候怎么删除呢

28:29.740 --> 28:30.540
调用这个函数

28:32.140 --> 28:33.020
把这个B

28:33.020 --> 28:35.260
按照这个建名来进行删除

28:35.260 --> 28:35.980
删完了之后

28:35.980 --> 28:37.260
咱们再来输出一下

28:37.260 --> 28:37.740
看一下

28:40.780 --> 28:41.500
保存一下

28:42.700 --> 28:43.740
删除了建B过后了

28:43.740 --> 28:45.740
你看只有A和C了

28:46.700 --> 28:46.860
好

28:46.860 --> 28:48.060
这次关于删除

28:49.260 --> 28:50.540
那么最后啊

28:50.540 --> 28:50.940
最后

28:51.580 --> 28:54.300
我要得到目前的建值队里面

28:54.300 --> 28:55.420
有多少个建

28:55.420 --> 28:56.140
这个搞定了

28:57.020 --> 28:59.260
得到当前建值的数量啊

28:59.260 --> 29:01.740
得到当前建值队的数量

29:01.740 --> 29:03.100
那么这个东西怎么来得

29:03.820 --> 29:04.700
怎么来得到呢

29:04.700 --> 29:06.060
我们可以写一个属性

29:06.780 --> 29:07.500
来看啊

29:07.500 --> 29:08.620
咱们可以写个属性

29:10.540 --> 29:11.020
Science

29:11.580 --> 29:12.780
它是一个什么属性呢

29:12.780 --> 29:13.420
Number

29:13.420 --> 29:14.780
这个Number属性

29:14.780 --> 29:15.980
默认的值是多少呢

29:15.980 --> 29:16.860
默认的值是0

29:17.900 --> 29:20.540
我每一次只要有新的建

29:21.340 --> 29:22.460
建值队产生

29:22.460 --> 29:23.340
我就给它加1

29:23.980 --> 29:26.060
每一次只要我删除了一个建值队

29:26.060 --> 29:27.260
我就给它减1

29:27.260 --> 29:29.820
我们通过来维护这么一个属性

29:29.820 --> 29:30.620
来搞定

29:30.620 --> 29:32.460
它里边有多少个建值队

29:33.180 --> 29:34.300
比方说set的时候

29:34.300 --> 29:36.540
它有可能会导致新增一个建值队

29:36.540 --> 29:37.260
比方说这儿

29:37.260 --> 29:38.700
你看是不是在新增一个建值队

29:39.260 --> 29:39.980
简单

29:39.980 --> 29:41.180
res size加加

29:42.060 --> 29:42.860
数量加1

29:43.900 --> 29:44.620
然后呢

29:45.420 --> 29:46.380
delete的时候

29:47.980 --> 29:49.020
删除的时候

29:49.020 --> 29:50.300
删除的时候

29:50.300 --> 29:51.820
每删除一个建值队

29:52.540 --> 29:54.460
res size减减

29:54.860 --> 29:55.820
res size减减

29:56.540 --> 29:56.940
OK

29:56.940 --> 29:58.140
我们来看一下啊

29:58.140 --> 29:59.660
有了这个size过后呢

29:59.660 --> 30:00.780
咱们来输出

30:01.500 --> 30:02.220
嗯

30:02.220 --> 30:03.100
这里

30:03.100 --> 30:03.820
删除之前

30:03.820 --> 30:05.020
我们先输出

30:05.020 --> 30:07.340
当前建值队数量

30:07.340 --> 30:09.180
啊数量是多少呢

30:09.180 --> 30:10.140
dick size

30:10.940 --> 30:11.340
得到

30:12.380 --> 30:12.700
好

30:13.580 --> 30:13.900
下边

30:14.620 --> 30:15.660
删除完了过后

30:15.660 --> 30:17.260
当前建队的数量是多少

30:17.260 --> 30:18.460
再来看一下啊

30:18.460 --> 30:19.260
你看

30:19.260 --> 30:20.140
删除之前

30:20.140 --> 30:21.580
当前建队的数量3

30:21.580 --> 30:22.300
删除了之后

30:22.300 --> 30:23.820
当前建队的数量12

30:25.260 --> 30:25.500
好

30:25.500 --> 30:26.300
这样子写呢

30:26.300 --> 30:27.340
倒是没有什么问题

30:27.340 --> 30:27.820
只不过呢

30:27.820 --> 30:28.940
它有一点隐患

30:28.940 --> 30:30.140
什么隐患呢

30:30.220 --> 30:31.740
我这里可以随意复职的

30:31.740 --> 30:32.620
兄弟

30:32.620 --> 30:33.980
我这里是不是可以随意复职

30:34.700 --> 30:35.660
那么这样子的话

30:35.660 --> 30:37.980
外面如果一旦操作不慎

30:37.980 --> 30:40.140
那么一个监制队的整个数据结构

30:40.140 --> 30:41.100
就会找到破坏

30:41.740 --> 30:44.460
那怎么样让外面不能重新复职呢

30:44.460 --> 30:45.820
这里有很多办法啊

30:46.620 --> 30:48.460
你可能会想到了啊

30:48.460 --> 30:50.540
把这个地方设成red only

30:50.540 --> 30:51.900
啊把设成red only

30:51.900 --> 30:53.180
这样子行不行呢

30:53.180 --> 30:54.220
你看下面

30:54.220 --> 30:55.180
你倒是

30:55.180 --> 30:56.940
当时外面倒是不能复职了

30:56.940 --> 30:58.300
那里边也不能复职啊

30:58.380 --> 30:59.340
你看这个那里边

30:59.340 --> 31:00.300
他也不能复职

31:00.300 --> 31:00.940
对不对

31:00.940 --> 31:01.900
他也不能复职

31:02.460 --> 31:04.060
所以说这里怎么做呢

31:04.060 --> 31:05.740
这里还有极动办法啊

31:05.740 --> 31:06.620
给他讲一讲吧

31:06.620 --> 31:08.700
顺便复识一下之前的知识

31:08.700 --> 31:09.660
我可以这样子做

31:10.620 --> 31:12.700
我设置一个私有的

31:12.700 --> 31:13.260
私有的

31:14.220 --> 31:14.780
Size

31:14.780 --> 31:16.380
下滑线Size

31:16.380 --> 31:17.980
私有的下滑线Size

31:17.980 --> 31:19.020
它是一个Number

31:19.020 --> 31:19.980
得它复职为利益

31:21.420 --> 31:22.140
然后呢

31:23.020 --> 31:23.900
我们可以这样做

31:24.860 --> 31:25.980
我们后边

31:26.060 --> 31:29.820
在增加这个Size的时候

31:29.820 --> 31:31.820
或者在减少这个Size的时候

31:31.820 --> 31:32.780
在这里

31:32.780 --> 31:33.900
刚才是减少对吧

31:34.860 --> 31:35.420
添加

31:36.140 --> 31:38.140
要增加一个数量

31:38.140 --> 31:39.820
和减少一个数量的时候

31:39.820 --> 31:41.180
控制这个私有的属性

31:41.180 --> 31:41.900
外面访问不到

31:42.540 --> 31:43.980
那外面能访问到啥呢

31:44.540 --> 31:45.580
能访问的

31:45.580 --> 31:47.260
我给他写一个访问器

31:50.460 --> 31:51.420
这个访问器

31:51.420 --> 31:53.660
这个访问器直接把这个私有制断返回

31:54.300 --> 31:55.740
直接把这个私有制断返回

31:56.060 --> 31:57.180
那么你想一想

31:57.180 --> 32:00.060
现在外面只能够得到这个属性

32:00.060 --> 32:01.260
你看这个是个属性的对吧

32:01.260 --> 32:02.300
我们之前讲过的

32:02.860 --> 32:04.620
只能够取这个属性的值

32:04.620 --> 32:06.060
但是不能设置它的值

32:06.060 --> 32:06.540
为什么

32:06.540 --> 32:08.860
因为我没有去设置Size

32:09.580 --> 32:10.620
没有去设置Size

32:10.620 --> 32:11.820
这里的做法很多

32:11.820 --> 32:12.300
很多

32:13.020 --> 32:13.260
好

32:13.260 --> 32:13.900
然后这里

32:13.900 --> 32:14.620
我们看一下这里

32:15.580 --> 32:15.900
这里

32:16.540 --> 32:19.180
我们当我们去给它复职的时候

32:20.460 --> 32:21.100
它告诉你

32:21.100 --> 32:21.420
不行

32:21.980 --> 32:23.260
因为你这个是止读的

32:23.260 --> 32:24.620
在它看来它就是止读的

32:24.620 --> 32:25.580
因为它只有一个Gate

32:26.300 --> 32:27.100
只有一个Gate

32:27.100 --> 32:27.660
它止读的

32:27.660 --> 32:28.540
你不能复职

32:28.540 --> 32:29.660
这样就避免这个问题了

32:30.380 --> 32:31.340
这是这个点

32:31.340 --> 32:31.820
当然了

32:31.820 --> 32:33.820
你既然都写出来这么一个东西了

32:35.260 --> 32:37.100
你都写出来这个玩意了

32:37.100 --> 32:38.140
你好好想一想

32:38.700 --> 32:39.740
还需要它吗

32:40.460 --> 32:41.340
还需要它吗

32:41.340 --> 32:42.380
其实不需要了

32:43.340 --> 32:44.460
不需要了

32:44.460 --> 32:45.100
那你想一想

32:45.100 --> 32:46.220
不需要的话怎么写

32:46.220 --> 32:47.180
下面一个代码都不写了

32:48.540 --> 32:49.900
下面一个代码也不写了

32:51.260 --> 32:51.740
你想一想

32:51.740 --> 32:52.860
老我这里应该写啥了

32:53.420 --> 32:53.820
写啥

32:54.300 --> 32:55.180
那你想这个道理

32:56.060 --> 32:57.980
这个间对的数量

32:59.180 --> 33:01.260
跟这个数组的数量是不是一致的

33:01.980 --> 33:02.460
或者说

33:03.180 --> 33:05.100
跟这个数组的数量是不是一致的

33:05.660 --> 33:06.060
对不对

33:06.620 --> 33:09.100
这个数组的长度是不是就是它的size

33:09.820 --> 33:11.340
所以说这里返回啥呢

33:11.340 --> 33:12.300
我直接返回

33:12.300 --> 33:14.540
Tis的Lens就完事了

33:15.100 --> 33:15.740
就完事了

33:15.740 --> 33:17.340
我都还不用去自己去控制

33:17.340 --> 33:18.620
因为它们两者是一致的

33:19.180 --> 33:20.140
非常类似于啥

33:20.140 --> 33:21.100
非常类似于

33:21.900 --> 33:23.340
View的计算属性

33:23.340 --> 33:23.740
对不对

33:24.780 --> 33:25.580
保存一下

33:25.660 --> 33:26.540
那么外边

33:26.540 --> 33:28.220
仍然是可以得到它的数量

33:28.220 --> 33:29.100
是一样的

33:29.100 --> 33:32.220
同时也可以防止它去对它进行修改

33:33.500 --> 33:35.340
这是关于这个字点的

33:35.340 --> 33:37.100
做了这么一个字点内出来

33:37.100 --> 33:38.700
有了这个字点内过后

33:38.700 --> 33:42.060
咱们之后去装一些间织对的数据的时候

33:42.060 --> 33:44.300
就可以使用我们这个地方写的内

33:45.180 --> 33:46.060
好做了这么多

33:46.060 --> 33:47.900
其实我告诉大家

33:48.460 --> 33:51.900
实际上在Tis里边是有相应的东西的

33:51.900 --> 33:54.140
有这么一个字点的这么一种结构

33:54.140 --> 33:55.180
什么结构呢

33:55.260 --> 33:58.220
就是咱们js里面学习的map

33:58.780 --> 33:59.900
就是这个玩意儿

33:59.900 --> 34:01.100
js学习的map

34:01.100 --> 34:03.340
这个map就是我们这里的字点

34:03.340 --> 34:04.620
只不过在Tis里边

34:04.620 --> 34:06.060
它对它进行的约束

34:06.060 --> 34:07.340
对它进行的约束

34:07.340 --> 34:08.940
咱们按F12

34:08.940 --> 34:11.980
按键盘上的F12转到定义

34:11.980 --> 34:13.660
或者是点这里右键

34:14.300 --> 34:15.340
这里转到定义

34:15.340 --> 34:17.580
F12或者是右键这里都可以

34:17.580 --> 34:19.340
我们按F12转到定义

34:19.340 --> 34:20.300
你看一下这里

34:20.940 --> 34:22.780
我这里点一下这个interface

34:22.780 --> 34:24.700
它用接口来进行约束的

34:25.660 --> 34:27.020
不用它不是一个内

34:27.020 --> 34:28.940
别管我们看它对内型的约束

34:28.940 --> 34:30.220
你看是不是个范形

34:30.860 --> 34:32.380
KV对不对

34:32.380 --> 34:33.340
一个范形

34:33.340 --> 34:35.580
三出的时候你看T的字是不是个K

34:35.580 --> 34:36.300
对不对

34:36.300 --> 34:37.740
返回一个布尔是否三出成功

34:38.380 --> 34:39.580
好for一起的时候

34:39.580 --> 34:41.180
你看这个回掉函数里边

34:41.740 --> 34:43.580
第一个是指

34:43.580 --> 34:44.380
第二个是键对吧

34:44.380 --> 34:45.500
我们是相反的

34:45.500 --> 34:46.780
Values是V

34:46.780 --> 34:48.060
T的是K

34:48.060 --> 34:48.460
看到没

34:49.660 --> 34:51.420
get得到某一个键的字

34:51.420 --> 34:53.740
我好像还没有写这个函数对吧

34:53.740 --> 34:54.780
有没有这个函数

34:55.580 --> 34:56.220
好像没有

34:56.220 --> 34:58.700
get根据一个件得到一个指

34:58.700 --> 34:59.820
返回的指是V

34:59.820 --> 35:00.780
如果这个件不存在

35:00.780 --> 35:01.900
返回的就是on define

35:01.900 --> 35:02.540
你看没有

35:02.540 --> 35:04.060
它已经给你约束好了

35:04.060 --> 35:06.940
所以说你可以像之前那样子

35:06.940 --> 35:08.940
使用new一个map

35:08.940 --> 35:10.780
像js那样子来进行

35:11.340 --> 35:12.300
建筑队的控制

35:12.940 --> 35:14.460
但是在ts里边

35:14.460 --> 35:16.140
它是有更加严格的要求

35:16.140 --> 35:18.620
它要求每一个键的类型必须相同

35:18.620 --> 35:20.300
每个值的类型也必须相同

35:21.500 --> 35:22.940
我们也不是说

35:22.940 --> 35:24.540
我们写这个东西完全没用

35:24.620 --> 35:25.740
通过写这个东西

35:25.740 --> 35:27.980
我们就可以一次熟悉

35:27.980 --> 35:30.220
我们这里的就是建筑队

35:30.220 --> 35:32.940
不是熟悉这里的范形的使用

35:32.940 --> 35:33.740
第二呢

35:33.740 --> 35:36.300
是能够熟悉map

35:36.300 --> 35:39.180
那个功能它怎么做出来了

35:39.180 --> 35:40.380
但是这里的做法有很多

35:40.380 --> 35:42.540
我选择的是这种做法

35:43.500 --> 35:43.820
好

35:43.820 --> 35:46.540
这是关于范形这一块的知识

35:47.100 --> 35:48.540
那么这一块的知识讲完后了

35:48.540 --> 35:51.020
咱们基础部分就到此结束了

35:51.740 --> 35:53.180
从下节课开始

35:53.420 --> 35:57.100
咱们来开始做一个基础部分的一个项目实战

35:57.100 --> 36:01.980
用react做一个紧制器的小游戏

36:01.980 --> 36:02.860
通过这个游戏

36:02.860 --> 36:03.900
我们可以理解

36:03.900 --> 36:06.380
要依则是理解咱们TypeScript

36:06.380 --> 36:08.300
在具体的项目中如何去使用

36:08.300 --> 36:10.300
另外一个是咱们熟悉一下

36:10.300 --> 36:11.980
在react里边

36:11.980 --> 36:14.140
怎么去结合咱们的ts

36:14.140 --> 36:15.900
结合之后又有什么样的好处

36:16.700 --> 36:18.300
这是下节课的预告

36:18.300 --> 36:18.620
OK

36:18.620 --> 36:21.180
那么咱们范形这一块的知识

36:21.180 --> 36:22.140
就到这里了

36:22.140 --> 36:23.260
拜拜

