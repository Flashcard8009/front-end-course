WEBVTT

00:00.620 --> 00:02.920
好 接下来 下面这个例子

00:03.180 --> 00:07.020
我们讲这么一个东西 叫做多范形

00:07.280 --> 00:10.600
多范形 其实这个不是一个什么新的知识点

00:10.860 --> 00:12.660
就是自然而然发生的事

00:12.920 --> 00:15.720
咱们来看一个例子 还是用一个例子来说明

00:15.980 --> 00:17.260
这里把它注释掉

00:18.540 --> 00:21.100
下边呢 我们写这么一个函数

00:21.860 --> 00:24.940
这个函数呢 实现一个非常特殊的功能

00:25.460 --> 00:28.780
我们把它叫做mixie array

00:29.780 --> 00:33.400
它的作用是将两个数组

00:34.160 --> 00:36.200
将两个数组

00:36.720 --> 00:38.000
进行混合

00:38.520 --> 00:40.040
什么意思呢 就比方说

00:40.300 --> 00:41.320
有第一个数组

00:42.600 --> 00:43.640
这是第一个数组

00:44.400 --> 00:45.420
然后呢

00:46.180 --> 00:46.960
又来一个数组

00:47.220 --> 00:47.980
比方说

00:48.240 --> 00:48.740
a

00:49.520 --> 00:50.020
b

00:50.800 --> 00:51.300
c

00:52.080 --> 00:53.360
比方说又来一个数组

00:53.860 --> 00:57.200
然后组合出来 混合出来的结果呢 是这个样子

00:57.660 --> 00:58.180
1

00:58.940 --> 00:59.460
a

01:00.220 --> 01:01.760
然后是3

01:02.020 --> 01:02.520
3

01:02.780 --> 01:03.300
b

01:03.820 --> 01:04.320
4

01:04.580 --> 01:05.860
然后是c

01:06.380 --> 01:07.380
这是混合出来的结果

01:07.660 --> 01:08.680
那么这个意思吧

01:08.940 --> 01:09.940
这是

01:10.220 --> 01:12.760
将两个数组进行混合

01:13.020 --> 01:16.600
这里呢 为了简单一点 要求两个数组的长度是一致的

01:16.860 --> 01:17.620
必须要一致

01:17.880 --> 01:20.180
这里呢 我到时候可以在函数里面进行判断

01:20.440 --> 01:21.480
进行判断就完事了

01:22.240 --> 01:23.780
好 我们要做这么一个练习

01:24.540 --> 01:26.340
将两个数组进行混合

01:26.560 --> 01:27.840
产生一个新的数数

01:28.600 --> 01:32.180
首先呢 我们来先不说这个函数怎么实现 这还不是重点

01:32.440 --> 01:34.220
重点是我们要想一想这个函数

01:34.480 --> 01:35.760
怎么来写他的签名

01:36.020 --> 01:37.040
什么叫函数签名

01:37.300 --> 01:38.840
就是有函数名我们知道了啊

01:39.080 --> 01:39.480
mixing

01:39.720 --> 01:40.120
re

01:40.880 --> 01:42.160
他的函数参数有几个

01:42.680 --> 01:44.720
然后函数的反挥值是什么类型

01:44.980 --> 01:47.280
参数又是什么类型 我们把这个东西想好

01:47.800 --> 01:49.840
好 这里有两个参数 我们首先可以确定

01:50.100 --> 01:50.620
一个是

01:50.880 --> 01:51.900
数组1

01:52.160 --> 01:52.920
一个是呢

01:53.180 --> 01:53.940
数组2

01:54.700 --> 01:56.240
好 做出了还有一个返回

01:56.540 --> 01:58.460
那么我们先把这个东西搞定

01:58.980 --> 02:00.380
首先这里是个数组 对吧

02:00.640 --> 02:01.540
第一个是个数组

02:01.800 --> 02:02.800
什么类型的数组

02:03.120 --> 02:03.820
是不是不知道

02:04.180 --> 02:04.580
对不对

02:04.820 --> 02:06.540
它可以是任何类型的数组

02:06.800 --> 02:08.060
不一定是什么东西的数组

02:08.460 --> 02:10.380
因此呢 我就写这么一个范形

02:10.880 --> 02:12.180
比方说数组t

02:12.420 --> 02:12.920
t

02:13.700 --> 02:15.860
第一个数组每一项的类型是一个t

02:16.620 --> 02:18.560
第一个数组每一项的类型是一个t

02:18.940 --> 02:20.100
好 第二个数组呢

02:20.620 --> 02:21.620
每一项是什么类型呢

02:22.420 --> 02:24.860
那么第二个数组在这种场景下面

02:25.180 --> 02:28.620
有没有要求第二个数组必须跟第一个数组的类型一致

02:29.900 --> 02:32.500
第二个数组是不是必须要跟第一个数组的类型一致

02:33.020 --> 02:34.020
是不是的对吧

02:34.300 --> 02:35.820
不是的 你看这个例子里边

02:36.060 --> 02:38.380
第一个是数字数组 第二个是一个字不算数组

02:38.620 --> 02:42.220
它并不要求这两个数组每一项的类型是一致的

02:42.740 --> 02:45.820
因此呢 第二个数组它是一个什么类型的数组呢

02:45.820 --> 02:47.300
是不是又缺少一个类型

02:47.580 --> 02:48.740
又少了一个类型

02:49.140 --> 02:53.100
于是呢 范形里边实际上是可以写多个范形的

02:53.180 --> 02:55.340
我们就讲这个点 要说的就是这个东西

02:55.780 --> 02:59.900
可以写两个可以是三个可以是四个可以是一百个都可以

03:00.300 --> 03:03.340
其实不是什么形式 都是自然而然发生的事情

03:03.340 --> 03:05.060
别忘了这里 有两个数组

03:05.380 --> 03:07.540
两个数组每一项的类型可能会不一样

03:07.700 --> 03:09.340
它可不可以一样 可以一样

03:09.580 --> 03:12.540
但是呢 逻辑上是可以 要把它分开的

03:12.860 --> 03:13.980
你不能把它写成一致

03:14.260 --> 03:15.580
因此呢 我再加一个范形

03:15.940 --> 03:17.500
我们之前说过 这个范形的名字

03:17.740 --> 03:19.460
也是可以随便取的 随便取的

03:20.020 --> 03:21.980
好 这就是两个范形了 用都有好分隔

03:22.700 --> 03:24.700
我们看第二个数组呢 我们就用k来表示

03:24.700 --> 03:26.100
每一项的类型就是k

03:27.020 --> 03:29.700
好 那么大家开动老金 想一想

03:29.700 --> 03:31.660
先不用去管这个函数怎么实现

03:31.660 --> 03:32.660
那个不是重点

03:33.740 --> 03:35.780
想一想它的反回类型是什么

03:36.420 --> 03:38.980
首先反回类型应该是一个新的数组 对吧

03:38.980 --> 03:41.620
这个毫无疑问 应该是一个新的数组

03:42.060 --> 03:44.140
那么这个数组的每一项是什么类型的

03:44.660 --> 03:45.300
你想一想

03:46.300 --> 03:47.420
开动老金想一想

03:48.340 --> 03:50.620
这个数组返回的这个结果

03:50.820 --> 03:52.140
它每一项是什么类型的

03:52.140 --> 03:53.260
大家看上面这个例子

03:55.220 --> 03:57.060
第一个数组每一项是number

03:58.060 --> 04:00.020
第二个数组每一项是支付串

04:00.900 --> 04:02.140
这是我们返回的结果

04:03.100 --> 04:03.740
返回的结果

04:03.740 --> 04:05.940
我们把这两个数组进行混合

04:06.460 --> 04:09.540
混合出来最后的结果就是这个东西

04:09.940 --> 04:12.020
那么这个返回结果每一项是什么类型

04:12.660 --> 04:14.100
它可以是number

04:14.420 --> 04:15.940
可以是支付串 对不对

04:16.300 --> 04:17.620
那么返回的结果咱怎么写

04:17.820 --> 04:19.420
怎么写

04:20.420 --> 04:23.340
数组的每一项是t或者是k

04:24.100 --> 04:24.740
或者是k

04:24.740 --> 04:26.100
这不就是返回结果的类型吗

04:26.860 --> 04:27.780
这个是返回结果

04:28.660 --> 04:31.140
先把这个类型签名给它写出来

04:31.660 --> 04:32.940
把这个类型给它写出来

04:32.940 --> 04:34.820
写出来过后我们再说怎么实现

04:34.820 --> 04:36.340
怎么实现其实不是重点的

04:36.660 --> 04:39.820
那个都会按照以前的GS写法

04:39.820 --> 04:40.860
该怎么写就怎么写

04:40.860 --> 04:42.700
我们学习TS主要是说

04:42.700 --> 04:44.740
怎么去约束它这种情况的类型

04:45.220 --> 04:47.100
这种情况下类型该怎么去做

04:47.100 --> 04:48.180
该怎么去约束

04:48.540 --> 04:50.140
我们把这个东西写好TS

04:50.140 --> 04:51.340
就是我们学习的TS

04:51.340 --> 04:52.340
就学习这一块

04:52.740 --> 04:52.980
好

04:52.980 --> 04:54.260
那么现在既然写到这儿

04:54.260 --> 04:54.980
我们把实现

04:55.780 --> 04:56.580
做简单一点

04:56.740 --> 04:57.740
不要这么复杂

04:58.300 --> 05:00.220
首先第一个数组的长度

05:00.220 --> 05:02.300
如果不等于

05:02.540 --> 05:05.300
不等于第二个数组的长度

05:05.620 --> 05:07.460
如果不等于第二个数组的长度

05:07.460 --> 05:08.420
那咋办了

05:08.540 --> 05:09.580
我就抛出一个错误

05:09.980 --> 05:12.580
throw new error

05:13.420 --> 05:16.420
两个数组长度不等

05:17.100 --> 05:17.980
长度不等

05:18.020 --> 05:18.660
一个错误

05:18.660 --> 05:19.740
它必须要长度相等

05:19.740 --> 05:20.740
当然长度不等

05:20.740 --> 05:21.380
能不能做

05:21.380 --> 05:22.340
肯定是可以做的

05:22.340 --> 05:23.460
逻辑上肯定可以做的

05:23.460 --> 05:24.540
我这难得写了

05:24.580 --> 05:25.980
这不是我们学习的重点

05:26.500 --> 05:26.780
好

05:26.780 --> 05:28.140
两个数组长度一样的话

05:28.140 --> 05:29.380
那怎么来做呢

05:29.420 --> 05:30.420
怎么来做呢

05:30.420 --> 05:31.940
我们就这样的写呗

05:31.940 --> 05:33.500
来创建这么一个数组

05:33.780 --> 05:35.100
先创建一个数组

05:35.340 --> 05:35.940
net

05:38.340 --> 05:39.260
最后的结果

05:39.460 --> 05:42.100
就是最后最终要返回的结果

05:42.260 --> 05:43.500
这个数组什么类型

05:43.700 --> 05:45.060
每一项可以是个t

05:45.060 --> 05:46.180
可以是个k

05:46.460 --> 05:47.500
是这么一个数组

05:48.180 --> 05:49.220
先给它复一个出子

05:49.940 --> 05:50.900
有这么一个数组

05:51.260 --> 05:51.500
好

05:51.500 --> 05:52.140
来呗

05:52.340 --> 05:52.820
来呗

05:52.820 --> 05:54.260
我们循环第一个数组

05:54.780 --> 05:57.180
循环而为1.n

05:57.180 --> 05:58.380
循环出来

05:58.380 --> 06:00.100
把数组的这一项拿到

06:00.260 --> 06:01.540
把数组的这一项拿到

06:01.540 --> 06:02.580
其实我要做什么

06:02.740 --> 06:03.860
每循环第一个数组

06:03.860 --> 06:04.780
循环一次

06:04.780 --> 06:07.260
我就往这个result里边铺起一个

06:07.380 --> 06:08.260
加住一个

06:08.420 --> 06:09.380
加一个什么子

06:09.380 --> 06:10.140
可以是t

06:10.140 --> 06:10.980
可以是k

06:11.180 --> 06:13.260
从第一个数组里边取出i

06:13.260 --> 06:14.460
那是不是就是t

06:14.460 --> 06:15.220
t这个类型

06:15.220 --> 06:15.620
对吧

06:15.620 --> 06:17.420
甭管第一个数组是它内

06:17.620 --> 06:18.340
是它内详

06:18.340 --> 06:19.140
具体是它内详

06:19.140 --> 06:19.620
无所谓

06:19.620 --> 06:20.780
我们用t来表示

06:20.780 --> 06:22.740
表示数组里边每一项是个t

06:22.740 --> 06:23.540
那么

06:23.700 --> 06:25.860
把每一项的内误就是个t

06:25.860 --> 06:27.540
把这个数组的当前这一项

06:27.700 --> 06:29.300
就是这个t的内误的数据

06:29.740 --> 06:31.900
加到结果里边

06:32.340 --> 06:34.260
然后再加一个result

06:34.260 --> 06:35.420
p

06:35.500 --> 06:36.940
AR2

06:36.940 --> 06:37.740
对不对

06:37.740 --> 06:38.700
就是k的内误

06:38.700 --> 06:39.740
你看一下

06:39.940 --> 06:40.980
这是t的数组

06:40.980 --> 06:41.860
这是k的数组

06:41.860 --> 06:43.140
为什么都能加进去

06:43.140 --> 06:44.780
因为最后的结果这个数组

06:44.900 --> 06:46.820
它每一项可以是个t

06:46.820 --> 06:48.060
也可以是个k

06:48.060 --> 06:49.180
所以说没问题

06:49.900 --> 06:53.020
能不能把这个意思要能理解

06:53.140 --> 06:53.900
把理清楚

06:54.060 --> 06:54.900
把理清楚

06:54.900 --> 06:55.300
好

06:55.300 --> 06:57.020
最后result

06:57.140 --> 06:57.860
返回

06:59.980 --> 07:00.900
有些同学

07:00.900 --> 07:02.380
总之学到翻译型这一块

07:02.540 --> 07:03.740
脸上的笑容

07:03.980 --> 07:05.260
逐渐的凝固

07:05.500 --> 07:07.140
脸上的笑容逐渐消失了

07:07.700 --> 07:09.900
就是你不用有那么大的压力

07:09.900 --> 07:11.780
因为我之前反复的强调过

07:12.500 --> 07:15.060
ts是一个可选的类型系统

07:15.060 --> 07:16.940
你不用翻译能不能做

07:17.460 --> 07:18.500
直接使用n

07:19.500 --> 07:20.460
完全不去限制

07:20.460 --> 07:22.340
全部把默认为n能不能写

07:22.340 --> 07:24.740
能写就是以前的介石代码

07:24.740 --> 07:25.780
没有什么区别

07:25.780 --> 07:27.660
如果你觉得实在是很恼火

07:27.660 --> 07:28.580
非常非常恼火

07:28.580 --> 07:31.660
你之前的这些基本类型使用

07:31.660 --> 07:32.820
以及接合的使用

07:32.820 --> 07:34.540
都还没有完全搞清楚

07:34.660 --> 07:36.460
那觉得翻译这里确实很恼火

07:36.460 --> 07:37.460
那你不用呗

07:37.460 --> 07:38.540
你不用就行了

07:38.540 --> 07:40.460
不用的话你就按照介石来写

07:40.700 --> 07:41.420
写着写着

07:41.420 --> 07:43.740
慢慢理解到之前的内询约束过后

07:43.980 --> 07:46.460
再去探讨更加高级的用法

07:46.700 --> 07:47.820
因为你不写

07:47.820 --> 07:49.260
像这里不写翻译的话

07:49.260 --> 07:50.380
你得不到内询约束

07:50.380 --> 07:52.140
那跟以前的介石代码是一样的

07:52.260 --> 07:53.100
是一样的

07:53.220 --> 07:55.180
并不比以前的介石代码差

07:55.180 --> 07:56.340
我们之前反复强调过

07:56.500 --> 07:58.300
这里是可选的一个内询系统

07:58.300 --> 07:59.460
就算你不用

07:59.900 --> 08:01.340
那么你写出来的代码了

08:01.340 --> 08:03.580
也比之前的介石要好得多

08:03.620 --> 08:04.620
因为它有内询约

08:04.620 --> 08:08.300
它还是有很多地方会进行内询推断和检查

08:08.780 --> 08:10.180
那如果你写了这个东西

08:10.180 --> 08:11.540
是锦上添花

08:11.740 --> 08:12.740
那明白这个意思吧

08:13.180 --> 08:14.140
当然我们在讲

08:14.140 --> 08:15.060
既然在讲贴时

08:15.060 --> 08:16.740
我肯定会按照这种写发来写

08:17.740 --> 08:18.180
OK

08:18.180 --> 08:19.780
那么现在我们写了这个函束过后

08:19.780 --> 08:20.740
大家看一下

08:20.740 --> 08:21.660
我来用一下

08:22.660 --> 08:24.820
有两个数组给他传进去

08:24.980 --> 08:26.260
Mixing Array

08:26.260 --> 08:27.060
第一个数组

08:27.420 --> 08:28.140
就来这个

08:28.820 --> 08:29.380
就来这个

08:31.100 --> 08:31.900
第二个数组

08:32.900 --> 08:33.620
就来这个

08:34.780 --> 08:35.180
这个

08:35.900 --> 08:36.500
看一下

08:38.180 --> 08:39.460
这样的环境去过后

08:39.460 --> 08:40.300
它的推到出来

08:40.300 --> 08:41.900
一看下推到出来是什么东西

08:42.540 --> 08:43.620
它第一个内询

08:43.620 --> 08:44.620
你看我们传的数组

08:44.620 --> 08:45.500
每一项是Number

08:45.500 --> 08:46.820
还推到出来是Number

08:46.820 --> 08:47.540
第二个数组

08:47.540 --> 08:48.500
每一项是个字符串

08:48.500 --> 08:49.700
还推到出来是字符串

08:49.940 --> 08:50.500
第一个数组

08:50.500 --> 08:51.340
Number数组

08:51.340 --> 08:51.980
第二个数组

08:51.980 --> 08:52.460
字符串

08:52.460 --> 08:52.980
数组

08:52.980 --> 08:54.620
反而会的结果就是一个Stream

08:54.620 --> 08:56.180
或者是Number的数组

08:56.500 --> 08:57.660
每一项可能是个字符串

08:57.660 --> 08:59.100
可能是一个数字

08:59.580 --> 09:00.700
我们最后结束

09:00.900 --> 09:01.980
就是它的结果

09:02.500 --> 09:04.780
最后把这个结果循环打印出来

09:05.780 --> 09:06.420
for each

09:07.820 --> 09:08.820
把每一项拿到

09:09.100 --> 09:09.980
每一项拿到

09:09.980 --> 09:10.980
然后进行打印

09:11.340 --> 09:12.220
这个R

09:12.380 --> 09:13.660
这个R什么内型

09:14.420 --> 09:16.180
这个R你能知道什么内型吗

09:16.620 --> 09:17.820
应该是一个字符串

09:17.820 --> 09:18.980
或者是一个Number

09:18.980 --> 09:19.220
对吧

09:19.220 --> 09:20.180
它可以推到出来

09:20.500 --> 09:21.300
让我来试一下

09:21.980 --> 09:23.580
其实这个也没什么好事的

09:24.660 --> 09:25.220
运行

09:27.420 --> 09:29.020
一看看到这个数组

09:29.020 --> 09:30.060
就进行了混合

09:31.020 --> 09:32.140
这是这么一个例子

09:33.540 --> 09:33.980
好了

09:33.980 --> 09:35.740
那么咱们翻译这一块

09:36.140 --> 09:36.900
就讲到这了

09:36.900 --> 09:37.820
就讲到这了

09:38.180 --> 09:39.580
多翻译什么时候使用了

09:39.580 --> 09:41.020
就是写一些函数

09:41.020 --> 09:42.380
或者是写一些内的时候

09:42.460 --> 09:44.060
它可能依赖多种内详

09:44.180 --> 09:45.980
我们之前的演示的时候

09:46.020 --> 09:47.300
都是依赖一种内详

09:47.380 --> 09:48.980
它有可能会依赖多个内详

09:48.980 --> 09:50.580
那么我就可以使用多翻译

09:50.820 --> 09:52.460
这个不是什么特别的知识

09:52.540 --> 09:54.380
这是自然而然发生的事情

09:55.460 --> 09:56.820
我们这一块血腥了

09:56.820 --> 09:57.460
翻译

09:57.580 --> 09:59.700
翻译在我们后续的开发中

09:59.740 --> 10:01.300
特别是在进节部分

10:01.300 --> 10:03.420
我们会经常使用到

10:03.900 --> 10:04.300
因此

10:04.700 --> 10:06.180
如果你翻译成这一块

10:06.180 --> 10:07.100
如果你没有

10:07.740 --> 10:08.540
这几颗的内容

10:08.540 --> 10:09.460
你觉得有点晕

10:09.580 --> 10:11.380
我建议大家多看几遍

10:11.740 --> 10:14.340
特别是咱们后边要做

10:14.540 --> 10:16.020
这个react的项目的时候

10:16.380 --> 10:18.260
我们下节课就开始做这个练习

10:18.500 --> 10:19.620
项目的这个练习

10:19.940 --> 10:20.980
做这个项目的时候

10:21.020 --> 10:22.940
就会大量的使用到翻译

10:23.060 --> 10:24.740
如果你这一块还不太理解的话

10:24.740 --> 10:25.300
多看几遍

10:25.540 --> 10:26.180
多看几遍

10:26.260 --> 10:28.300
包括我们进阶也会经常使用到翻译

10:28.940 --> 10:29.340
ok

10:29.340 --> 10:30.340
那么接下来

10:30.340 --> 10:32.260
我们还是来对翻译成这一块

10:32.380 --> 10:33.260
来做个练习

