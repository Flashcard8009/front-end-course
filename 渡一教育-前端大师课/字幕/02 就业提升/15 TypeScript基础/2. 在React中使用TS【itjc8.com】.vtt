WEBVTT

00:00.690 --> 00:06.190
好 在咱们开始去具体的开发这个项目之前呢

00:06.190 --> 00:12.190
我们先要讲一讲啊 这个rex和ts如何来进行结合

00:12.190 --> 00:14.190
当然呢 还是我反复强调的

00:14.190 --> 00:16.190
它是个可选的内容系统

00:16.190 --> 00:18.190
因此呢 你不结合也没有任何问题

00:18.190 --> 00:20.190
你就用以前的开发方式没有任何问题

00:20.190 --> 00:24.190
而要去讲它如何去跟ts结合的话

00:24.190 --> 00:26.190
我们首先要认识到

00:26.190 --> 00:30.190
以前咱们用GS来写rex的代码的时候

00:30.190 --> 00:32.190
会遇到哪些问题

00:32.190 --> 00:34.190
这里呢 我们把它做个笔记

00:37.190 --> 00:39.190
就说我们首先讲这么一个点

00:39.190 --> 00:43.690
以前的rex和ts来结合来书写代码的话

00:43.690 --> 00:45.190
会遇到哪些问题

00:45.190 --> 00:47.190
其实大家都写过rex的代码

00:47.190 --> 00:50.190
因此呢 应该是深有体会

00:50.190 --> 00:52.190
比方说第一个问题

00:52.190 --> 00:58.190
某个组建有哪些属性需要传递

00:58.190 --> 01:00.190
你是不是这个时候是懵的

01:00.190 --> 01:02.190
哪怕你是自己写的组建

01:02.190 --> 01:03.190
好不容易把它开发完了

01:03.190 --> 01:05.190
将来去用这个组建的时候

01:05.190 --> 01:07.190
你可能很快就会忘记

01:07.190 --> 01:09.190
有哪些属性要传递呢

01:09.190 --> 01:11.190
对吧 这是第一个问题

01:11.190 --> 01:13.190
通常情况下

01:13.190 --> 01:16.190
就是如果我们去使用别人的组建的话

01:16.190 --> 01:18.190
一般会去查一些官方稳当

01:18.190 --> 01:20.190
比方说我们使用And

01:20.190 --> 01:22.190
比方说使用这个And

01:22.190 --> 01:24.190
使用这个UI库的时候

01:24.190 --> 01:26.190
我们会怎么来操作

01:26.190 --> 01:29.190
是查看官方稳当 对吧

01:29.190 --> 01:30.190
那么官方稳当里面

01:30.190 --> 01:31.190
就会给你描述

01:31.190 --> 01:34.190
用各种样的势力来给你描述

01:34.190 --> 01:36.190
你需要传递哪些属性

01:36.190 --> 01:39.190
但是呢 即便是

01:39.190 --> 01:41.190
即便是你有了官方稳当

01:41.190 --> 01:42.190
你是不是还是用英写错

01:42.190 --> 01:44.190
比方说最常见的错误

01:44.190 --> 01:45.190
我不是说了很多遍了吗

01:45.190 --> 01:46.190
最常见的错误

01:46.190 --> 01:48.190
什么name属性呢

01:48.190 --> 01:50.190
给它写成了这个东西

01:50.190 --> 01:51.190
给它写成这个东西

01:51.190 --> 01:53.190
我也不知道是怎么出错的

01:53.190 --> 01:55.190
还有什么URI

01:55.190 --> 01:57.190
写成了UI

01:57.190 --> 01:59.190
像这些常见的错误

01:59.190 --> 02:01.190
经常会发生

02:01.190 --> 02:03.190
就是它没有一个严格的检查

02:03.190 --> 02:04.190
就算你出错了

02:04.190 --> 02:06.190
你也不知道自己写错了

02:06.190 --> 02:07.190
这是第一个问题

02:07.190 --> 02:09.190
第二个问题呢

02:09.190 --> 02:12.190
是每个属性

02:12.190 --> 02:14.190
每个属性

02:14.190 --> 02:17.190
应该传递什么类型

02:17.190 --> 02:19.190
这个也是经常出错的

02:19.190 --> 02:21.190
错误的点经常在于

02:21.190 --> 02:23.190
本来是要你传一个数字

02:23.190 --> 02:25.190
结果你传了一个制服串过去

02:25.190 --> 02:27.190
比方说某个组件

02:27.190 --> 02:29.190
某个组件

02:29.190 --> 02:31.190
有一个属性

02:31.190 --> 02:33.190
是一个数字

02:33.190 --> 02:35.190
有一个NUM的属性

02:35.190 --> 02:37.190
是一个数字

02:37.190 --> 02:39.190
结果你使用那个组件的时候

02:39.190 --> 02:40.190
你怎么传的呢

02:40.190 --> 02:41.190
你可能是这样传的

02:41.190 --> 02:43.190
不要说买component

02:43.190 --> 02:45.190
传递NUM的时候

02:45.190 --> 02:47.190
你可能要传这个东西

02:47.190 --> 02:48.190
你传了一个制服串进去了

02:48.190 --> 02:49.190
但是你当时

02:49.190 --> 02:50.190
这个没问题

02:50.190 --> 02:51.190
334个数字

02:51.190 --> 02:52.190
这样子

02:52.190 --> 02:53.190
没有任何的错误提示

02:53.190 --> 02:55.190
因为因此你觉得这个是正确的

02:55.190 --> 02:57.190
很多错误可能要在运行过后

02:57.190 --> 03:00.190
你才知道它到底是出了什么问题

03:00.190 --> 03:01.190
你要到处去查

03:01.190 --> 03:02.190
到处去调试

03:02.190 --> 03:05.190
结果发现原来是这个地方出了问题

03:05.190 --> 03:08.190
这个问题也是经常常见的

03:08.190 --> 03:10.190
比方说有个组件里边

03:10.190 --> 03:12.190
通过属性传递的时候

03:12.190 --> 03:14.190
还要传递一些

03:14.190 --> 03:16.190
毁掉函数对吧

03:17.190 --> 03:20.190
传递事件的时候

03:20.190 --> 03:24.190
传递事件时就是毁掉函数

03:24.190 --> 03:26.190
有哪些参数

03:26.190 --> 03:28.190
这个世界有哪些参数

03:28.190 --> 03:30.190
每个参数又是一个什么样的内心

03:30.190 --> 03:32.190
像这些问题就是咱们在以前

03:32.190 --> 03:35.190
开发react的时候是经常发生的

03:35.190 --> 03:37.190
比方那个毁掉函数

03:37.190 --> 03:38.190
要不要返回

03:38.190 --> 03:39.190
应该有什么样的返回内心

03:39.190 --> 03:40.190
也是经常发生的事

03:40.190 --> 03:42.190
我们搞不清楚了

03:42.190 --> 03:44.190
有的时候要去看一下官方文的

03:44.190 --> 03:46.190
这里是你公司内部

03:46.190 --> 03:48.190
跟其他的开发人员进行交互的时候

03:48.190 --> 03:50.190
可能连官方文档都没有

03:50.190 --> 03:51.190
连文档都没有

03:51.190 --> 03:52.190
只是凭口头

03:52.190 --> 03:54.190
交流主要是靠喊

03:54.190 --> 03:55.190
所以到时候就会遇到

03:55.190 --> 03:57.190
很多很多这样的类似的问题

03:57.190 --> 03:58.190
哪怕你是自己写的逐渐

03:58.190 --> 04:00.190
你也会经常忘记

04:00.190 --> 04:02.190
这是前面三个点

04:02.190 --> 04:04.190
那么其实还有一些

04:04.190 --> 04:05.190
比方说

04:05.190 --> 04:07.190
还有一个问题就是

04:07.190 --> 04:10.190
错误发生在运行时

04:10.190 --> 04:12.190
就是什么意思呢

04:12.190 --> 04:13.190
就是说

04:13.190 --> 04:15.190
我们可以通过

04:15.190 --> 04:18.190
react里面不是有这个东西吗

04:18.190 --> 04:20.190
叫做probs

04:20.190 --> 04:22.190
probtabs

04:22.190 --> 04:24.190
好像是这样写的

04:24.190 --> 04:25.190
应该是这样写的

04:25.190 --> 04:26.190
我来试一下

04:26.190 --> 04:28.190
我有点忘记了

04:28.190 --> 04:29.190
这个巨像名字

04:29.190 --> 04:30.190
咱们试一下

04:30.190 --> 04:31.190
app

04:31.190 --> 04:32.190
prob

04:32.190 --> 04:33.190
对就这个写的

04:33.190 --> 04:34.190
这样写的

04:34.190 --> 04:35.190
probtabs

04:35.190 --> 04:38.190
可以通过它来约束属性的内行

04:38.190 --> 04:41.190
虽然可以通过它约束

04:42.190 --> 04:43.190
属性的内行

04:43.190 --> 04:44.190
每一个属性是什么内行

04:44.190 --> 04:46.190
可以具体的进行约束

04:46.190 --> 04:48.190
也就是说react很早

04:48.190 --> 04:50.190
它就已经想到这个点了

04:50.190 --> 04:51.190
你这个属性

04:51.190 --> 04:52.190
我不知道要传什么

04:52.190 --> 04:54.190
那么可以通过它来约束

04:54.190 --> 04:55.190
但是

04:55.190 --> 04:57.190
经过这样的约束

04:57.190 --> 05:00.190
就算你发生了错误

05:00.190 --> 05:01.190
你约束了它

05:01.190 --> 05:02.190
但是你给它传了另外一个东西

05:02.190 --> 05:04.190
本来约束为制服串

05:04.190 --> 05:05.190
也给它传了个数字

05:05.190 --> 05:06.190
或者说约束为个布尔

05:06.190 --> 05:08.190
你给它传了个制服串

05:08.190 --> 05:10.190
但是你发生错误后

05:10.190 --> 05:12.190
但是发生错误后

05:12.190 --> 05:14.190
错误的时间点

05:14.190 --> 05:16.190
是在运行时

05:16.190 --> 05:20.190
它发生错误时间太靠后了

05:20.190 --> 05:22.190
就是我们写代码的时候

05:22.190 --> 05:23.190
它不会立即提示我们

05:23.190 --> 05:24.190
这个地方有问题

05:24.190 --> 05:26.190
它要等到运行的时候

05:26.190 --> 05:27.190
才会提示有问题

05:27.190 --> 05:29.190
为什么以前做不到

05:29.190 --> 05:30.190
写代码的时候又提示了

05:30.190 --> 05:32.190
因为以前使用的是GS代码

05:32.190 --> 05:35.190
GS代码是解释性语言

05:35.190 --> 05:36.190
它需要等到运

05:36.190 --> 05:37.190
它直接可以运行

05:37.190 --> 05:38.190
不管你写了什么代码

05:38.190 --> 05:39.190
它都可以运行

05:39.190 --> 05:41.190
你只有等到运行的时候

05:41.190 --> 05:42.190
才能知道是什么样的错误

05:42.190 --> 05:45.190
它是在运行的时候检查错误的

05:45.190 --> 05:47.190
所以说就会遇到这么一些

05:47.190 --> 05:48.190
乱七八糟的问题

05:48.190 --> 05:49.190
这些问题

05:49.190 --> 05:51.190
也要说多严重

05:51.190 --> 05:54.190
看上去好像不是很严重

05:54.190 --> 05:56.190
但是为了去解决这些问题

05:56.190 --> 05:58.190
会花费很多很多的时间

05:58.190 --> 05:59.190
你去看吧

05:59.190 --> 06:00.190
你看官方文档

06:00.190 --> 06:01.190
是不是要花费时间

06:01.190 --> 06:02.190
你写错了过后

06:02.190 --> 06:03.190
要去调试

06:03.190 --> 06:04.190
要花费很多时间

06:04.190 --> 06:06.190
因此我们就特别需要

06:06.190 --> 06:07.190
有一个内询系统

06:07.190 --> 06:10.190
来进行静态的内询检查

06:10.190 --> 06:12.190
这就是我们TS要解决的问题

06:12.190 --> 06:15.190
TS要解决的其实就是这些问题

06:15.190 --> 06:18.190
这些问题其实可大可小

06:18.190 --> 06:20.190
如果是一个小项目的话

06:20.190 --> 06:21.190
功能很简单

06:21.190 --> 06:23.190
比方说像我们这个小项目

06:23.190 --> 06:24.190
功能很简单

06:24.190 --> 06:25.190
要说遇到这些问题

06:25.190 --> 06:26.190
有很严重吧

06:26.190 --> 06:27.190
也不至于

06:27.190 --> 06:28.190
但是我在这里

06:28.190 --> 06:30.190
也不可能给大家做一个

06:30.190 --> 06:32.190
比方说做一个完整的大型项目

06:32.190 --> 06:34.190
或者是中型项目

06:34.190 --> 06:35.190
那样子的话

06:35.190 --> 06:36.190
可以看这个视频

06:36.190 --> 06:37.190
要看几个月

06:37.190 --> 06:38.190
那何必呢

06:38.190 --> 06:39.190
所以我们通过以小伯大

06:39.190 --> 06:40.190
通过这个小项目

06:40.190 --> 06:42.190
来给大家理解

06:42.190 --> 06:45.190
它会发生这样的各种各样的问题

06:45.190 --> 06:47.190
因此为了解决这样的问题

06:47.190 --> 06:49.190
就是rex和TS

06:49.190 --> 06:51.190
就结合在一起了

06:51.190 --> 06:52.190
跟TS结合

06:52.190 --> 06:53.190
就可以解决这样的问题

06:53.190 --> 06:54.190
为什么呢

06:54.190 --> 06:56.190
因为TS

06:56.190 --> 06:59.190
TS是一套内询系统

06:59.190 --> 07:00.190
它可以检查

07:00.190 --> 07:01.190
各种内询是不是正确

07:01.190 --> 07:04.190
并且是静态的

07:04.190 --> 07:05.190
检查的

07:05.190 --> 07:07.190
就是不用等你运行出来

07:07.190 --> 07:08.190
你在写代码的时候

07:08.190 --> 07:09.190
就可以给你提示

07:09.190 --> 07:10.190
你这个属性有没有传队

07:10.190 --> 07:12.190
就可以提示了

07:12.190 --> 07:13.190
好了

07:13.190 --> 07:15.190
这里我们来直接用代码来

07:15.190 --> 07:16.190
给大家演示一下

07:16.190 --> 07:17.190
看一下怎么来使用

07:17.190 --> 07:18.190
其实用起来非常简单

07:18.190 --> 07:21.190
也不会打扰你太多的开发思路

07:21.190 --> 07:22.190
以前怎么写

07:22.190 --> 07:23.190
现在怎么写

07:23.190 --> 07:25.190
就是加上一些内询约束就行了

07:25.190 --> 07:27.190
这里我们首先建一个文件

07:27.190 --> 07:29.190
讲component

07:29.190 --> 07:31.190
这里面存放一些组件

07:31.190 --> 07:33.190
比方说我们这里写个组件

07:33.190 --> 07:35.190
这个组件就是技术器

07:35.190 --> 07:37.190
技术器

07:37.190 --> 07:39.190
comp

07:39.190 --> 07:41.190
我写组件的话喜欢加一个后维

07:41.190 --> 07:43.190
就是component的前面几个字母

07:43.190 --> 07:44.190
comp

07:44.190 --> 07:45.190
表示这是一个组件

07:45.190 --> 07:46.190
看到大家习惯了

07:46.190 --> 07:48.190
就是有些人写组件的话

07:48.190 --> 07:49.190
会在前面加一个C

07:49.190 --> 07:51.190
或者是前面加一个comp

07:51.190 --> 07:52.190
表示这是个组件

07:52.190 --> 07:53.190
就看个人习惯

07:53.190 --> 07:54.190
我喜欢加在后面

07:54.190 --> 07:55.190
hello

07:55.190 --> 07:57.190
或者叫做这个技术器

07:57.190 --> 08:00.190
comp.tsx

08:00.190 --> 08:02.190
使用这样的后维名来表示

08:02.190 --> 08:03.190
一个使用ts代码

08:03.190 --> 08:05.190
书写的组件

08:05.190 --> 08:07.190
这里我会演示两种情况

08:07.190 --> 08:09.190
一种是内组件

08:09.190 --> 08:11.190
一种是函数式组件

08:11.190 --> 08:12.190
我们通常知道

08:12.190 --> 08:13.190
我们知道这么一个点

08:13.190 --> 08:15.190
这是以前rex的姿势

08:15.190 --> 08:17.190
记住一下

08:17.190 --> 08:19.190
就是咱们在rex里面写组件

08:19.190 --> 08:20.190
通常会这样

08:20.190 --> 08:22.190
会分成两种组件

08:22.190 --> 08:23.190
一种是展式组件

08:23.190 --> 08:25.190
它只做存数据展式的

08:25.190 --> 08:27.190
只跟界面有关系

08:27.190 --> 08:30.190
一种是容器组件

08:30.190 --> 08:32.190
容器组件跟样式没有任何关系

08:32.190 --> 08:34.190
它只是做数据处理的

08:34.190 --> 08:37.190
通常会分为这么两种组件

08:37.190 --> 08:40.190
一般来说展式组件

08:40.190 --> 08:42.190
它用不到什么生命周期函数

08:42.190 --> 08:43.190
也都用不到

08:43.190 --> 08:46.190
因此展式组件通常是

08:46.190 --> 08:49.190
一个通常是函数式组件

08:49.190 --> 08:50.190
就是一个普通函数

08:50.190 --> 08:52.190
而容器组件

08:52.190 --> 08:54.190
可能会用到一些生命周期函数

08:54.190 --> 08:57.190
所以它通常是内组件

08:57.190 --> 08:59.190
比方说咱们这里是一个展式组件

08:59.190 --> 09:01.190
按照以前的代码怎么写的

09:01.190 --> 09:03.190
以前的代码就直接导出了

09:03.190 --> 09:05.190
写个函数完事了

09:05.190 --> 09:07.190
写个函数方式

09:07.190 --> 09:09.190
函数比方说

09:11.190 --> 09:13.190
它要传一个属性进来

09:13.190 --> 09:15.190
传一个属性进来

09:15.190 --> 09:16.190
我们这里

09:16.190 --> 09:17.190
这个属性没有用到

09:17.190 --> 09:19.190
所以说它没有去读习它的字

09:19.190 --> 09:21.190
它隐释

09:21.190 --> 09:23.190
由于它现在有严格的内容检查

09:23.190 --> 09:25.190
因此它不太允许你

09:25.190 --> 09:27.190
出现N里内容

09:27.190 --> 09:28.190
就是你

09:28.190 --> 09:30.190
如果你不跟它进行内容约束的话

09:30.190 --> 09:32.190
因为我们现在写的是TS代码

09:32.190 --> 09:34.190
你没有跟它进行约束

09:34.190 --> 09:36.190
它默认带有N里内容

09:36.190 --> 09:38.190
因此它这里报道的错

09:38.190 --> 09:40.190
因为现在我们的检查是比较严格的

09:40.190 --> 09:41.190
你看

09:41.190 --> 09:43.190
把这个严格检查开起来了

09:43.190 --> 09:46.190
这里我们其实可以对它进行约束

09:46.190 --> 09:48.190
就约束为N里

09:48.190 --> 09:50.190
告诉它我们这里就是N里内容

09:50.190 --> 09:52.190
这样它不会报错了

09:52.190 --> 09:54.190
它不是说不可以约束为N里

09:54.190 --> 09:55.190
只是说

09:55.190 --> 09:58.190
它怕你忘了写内容检查

09:58.190 --> 09:59.190
内容约束

09:59.190 --> 10:01.190
所以说它如果没有约束的话

10:01.190 --> 10:02.190
默认是N里内容

10:02.190 --> 10:03.190
它觉得这是有危险的

10:03.190 --> 10:04.190
因此它会提示你

10:04.190 --> 10:06.190
如果你手中给它进行约束的话

10:06.190 --> 10:08.190
就没有问题了

10:08.190 --> 10:09.190
就稍微约束一下吧

10:09.190 --> 10:12.190
那么这个其实就是以前的一个介石逐渐

10:12.190 --> 10:14.190
那么这里怎么写呢

10:14.190 --> 10:15.190
我们按照以前的写法

10:15.190 --> 10:17.190
会这样子写

10:17.190 --> 10:19.190
这里显示

10:19.190 --> 10:22.190
直接显示一个DIV

10:22.190 --> 10:24.190
DIV

10:25.190 --> 10:27.190
这个DIV呢有一个

10:27.190 --> 10:29.190
比方说有一个失败元素

10:29.190 --> 10:30.190
一个失败元素

10:30.190 --> 10:32.190
这里面显示数字

10:32.190 --> 10:33.190
数字哪来呢

10:33.190 --> 10:35.190
来自于这个属性的ProbsNUM

10:35.190 --> 10:37.190
我们希望它是一个数字

10:37.190 --> 10:39.190
你看写的完全没有安全感

10:39.190 --> 10:41.190
我怎么凭什么知道这里面有NUM这个属性呢

10:41.190 --> 10:42.190
它万一不传怎么办呢

10:42.190 --> 10:44.190
完全没有任何的安全感

10:44.190 --> 10:46.190
后边加上两个

10:46.190 --> 10:47.190
左边加上一个按钮吧

10:47.190 --> 10:48.190
数字减少

10:48.190 --> 10:50.190
button一个减号

10:50.190 --> 10:51.190
表示数字减少

10:51.190 --> 10:53.190
后边这个按钮加上一个

10:53.190 --> 10:55.190
一个加号

10:55.190 --> 10:56.190
数字增加

10:56.190 --> 10:58.190
然后这两个按钮里边呢

10:58.190 --> 10:59.190
这两个按钮里边呢

10:59.190 --> 11:01.190
我们给它写上一个unclick

11:01.190 --> 11:03.190
unclick

11:03.190 --> 11:04.190
写上unclick过后呢

11:04.190 --> 11:05.190
其实你会发现

11:05.190 --> 11:07.190
现在已经有智能提示了你发现没

11:07.190 --> 11:09.190
unclick

11:11.190 --> 11:13.190
你看已经有智能提示了

11:13.190 --> 11:14.190
这种智能提示是谁带给你的

11:14.190 --> 11:16.190
就是TS带给你的

11:16.190 --> 11:17.190
如果你这里写错了

11:17.190 --> 11:18.190
比方说你这里

11:18.190 --> 11:19.190
把sys写成了小写的sys

11:19.190 --> 11:21.190
你看马上就爆错

11:21.190 --> 11:22.190
它告诉你

11:23.190 --> 11:24.190
对

11:25.190 --> 11:27.190
它说不存在这个属性

11:27.190 --> 11:28.190
unclick

11:28.190 --> 11:29.190
你看马上就知道了

11:29.190 --> 11:30.190
这里写错了

11:30.190 --> 11:31.190
写成一个小写的sys了

11:31.190 --> 11:32.190
其实这些类型系统

11:32.190 --> 11:34.190
类型的检查它已经在做了

11:34.190 --> 11:36.190
就算写出一些存的

11:36.190 --> 11:38.190
以前的GS带

11:38.190 --> 11:40.190
你都会获得很大的优势

11:40.190 --> 11:42.190
因为已经有了类型检查

11:42.190 --> 11:43.190
只不过你自己的

11:43.190 --> 11:45.190
自己的组建没有类型检查而已

11:45.190 --> 11:46.190
好

11:46.190 --> 11:47.190
这个写个unclick

11:47.190 --> 11:49.190
当我们点击的时候

11:49.190 --> 11:50.190
我们怎么样呢

11:50.190 --> 11:52.190
我们去

11:52.190 --> 11:53.190
调用一下

11:53.190 --> 11:54.190
调用一下一个回调

11:54.190 --> 11:56.190
希望它给我传一个回调进来

11:56.190 --> 11:57.190
回调进来

11:57.190 --> 11:59.190
比方说回调的名字

11:59.190 --> 12:03.190
就叫做undecrease

12:03.190 --> 12:06.190
当要减少1的时候

12:06.190 --> 12:07.190
要减少1的时候

12:07.190 --> 12:09.190
把这个回调传给它

12:09.190 --> 12:11.190
写的时候没有任何的安全感

12:11.190 --> 12:12.190
它要不要传递

12:12.190 --> 12:13.190
它传递到过后

12:13.190 --> 12:15.190
这个函数又是什么东西

12:15.190 --> 12:16.190
不知道了

12:16.190 --> 12:17.190
好

12:17.190 --> 12:18.190
我们这里

12:18.190 --> 12:20.190
把这个复制一下

12:20.190 --> 12:21.190
这里

12:21.190 --> 12:24.190
unincrease

12:24.190 --> 12:25.190
好

12:25.190 --> 12:26.190
有这么两个回调

12:26.190 --> 12:27.190
有这么两个回调

12:27.190 --> 12:29.190
它至少得传一个那么进来

12:29.190 --> 12:31.190
而且必须要是数字

12:31.190 --> 12:33.190
当我们点击这个按钮的时候

12:33.190 --> 12:34.190
调用这个回调

12:34.190 --> 12:35.190
当我们点击这个按钮的时候

12:35.190 --> 12:36.190
调用这个回调

12:36.190 --> 12:37.190
好

12:37.190 --> 12:38.190
写好之后

12:38.190 --> 12:40.190
咱们在这个app.tsx里面

12:40.190 --> 12:41.190
去用一下这个组建

12:41.190 --> 12:42.190
去用一下

12:42.190 --> 12:43.190
试一下

12:43.190 --> 12:45.190
这里我就直接写上这个组建名

12:46.190 --> 12:47.190
只能提示呢

12:48.190 --> 12:49.190
等一下

12:49.190 --> 12:51.190
我在这里先把只能提示弄出来

12:53.190 --> 12:54.190
好吧

12:54.190 --> 12:55.190
加进去

12:55.190 --> 12:56.190
加进去过后

12:56.190 --> 12:57.190
我们这里就可以使用这个组建了

12:59.190 --> 13:00.190
使用这个组建

13:01.190 --> 13:02.190
好

13:02.190 --> 13:03.190
使用这个组建过后

13:03.190 --> 13:05.190
这里其实也是一个函数式组建

13:05.190 --> 13:06.190
对不对

13:06.190 --> 13:07.190
这个app

13:07.190 --> 13:08.190
它是一个函数

13:08.190 --> 13:10.190
这个函数就是一个组建

13:10.190 --> 13:11.190
好

13:11.190 --> 13:12.190
那么这里我使用这个组建

13:12.190 --> 13:14.190
这个组建是不是必须要传一个属性

13:14.190 --> 13:15.190
对不对

13:15.190 --> 13:16.190
必须要传一个属性

13:16.190 --> 13:17.190
但是我这里

13:17.190 --> 13:18.190
可能就忘记了

13:18.190 --> 13:19.190
它要传什么属性

13:19.190 --> 13:20.190
它的类型是什么

13:20.190 --> 13:21.190
有没有回调函数

13:21.190 --> 13:22.190
回调函数的名称有什么

13:22.190 --> 13:24.190
可能这些东西都容易忘记

13:24.190 --> 13:25.190
都容易忘记

13:25.190 --> 13:26.190
因为它这里

13:26.190 --> 13:27.190
没有任何的智能提示

13:27.190 --> 13:28.190
你看

13:28.190 --> 13:29.190
我要传nam

13:29.190 --> 13:30.190
但是没有任何智能提示

13:30.190 --> 13:31.190
我就有非常有可能写错

13:31.190 --> 13:33.190
我也不知道这个nam

13:33.190 --> 13:34.190
应该是什么类型

13:34.190 --> 13:36.190
那么我如何来解决这个问题呢

13:36.190 --> 13:37.190
在ts中

13:37.190 --> 13:39.190
它可以使用类型约束

13:39.190 --> 13:40.190
来解决这个问题

13:40.190 --> 13:42.190
就是你在写一个函数式组建的时候

13:42.190 --> 13:43.190
你这里不是一个

13:44.190 --> 13:46.190
不是一个就是什么

13:46.190 --> 13:47.190
这个属性吗

13:47.190 --> 13:48.190
对吧

13:48.190 --> 13:50.190
这个属性那里是可以对它进行约束的

13:50.190 --> 13:52.190
跟我们以前写的函数是一样的

13:52.190 --> 13:54.190
它这个属性是可以进行约束的

13:54.190 --> 13:56.190
怎么约束呢

13:56.190 --> 13:57.190
怎么约束呢

13:57.190 --> 13:59.190
这里有两种做法

13:59.190 --> 14:00.190
第一种做法

14:00.190 --> 14:02.190
我们先写一个interface

14:02.190 --> 14:03.190
先写一个interface

14:03.190 --> 14:04.190
我们这个属性里边

14:04.190 --> 14:06.190
就该命名为ipross

14:06.190 --> 14:08.190
表示这里有一个属性

14:08.190 --> 14:10.190
这个组建有个属性

14:10.190 --> 14:11.190
这个属性里边

14:11.190 --> 14:14.190
它必须要传递num

14:14.190 --> 14:15.190
对不对

14:15.190 --> 14:16.190
我们可以对它进行约束

14:16.190 --> 14:18.190
这个属性里边必须要有这么一个属性num

14:18.190 --> 14:20.190
并且它的指示

14:20.190 --> 14:22.190
它的指示内层是一个number

14:22.190 --> 14:24.190
内层是一个number

14:24.190 --> 14:26.190
你看说把约束起来了

14:26.190 --> 14:27.190
好

14:27.190 --> 14:28.190
还有两个属性

14:28.190 --> 14:29.190
两个回调

14:29.190 --> 14:32.190
undecrease

14:32.190 --> 14:33.190
一个回调函数

14:33.190 --> 14:34.190
这里呢

14:34.190 --> 14:35.190
你还可以给它加上一个问号

14:35.190 --> 14:36.190
表示它是可选的

14:36.190 --> 14:38.190
你可以传递这个回调

14:38.190 --> 14:39.190
你可以不传递

14:39.190 --> 14:40.190
不传递就是undecrase

14:40.190 --> 14:41.190
对

14:41.190 --> 14:42.190
它是什么内层呢

14:42.190 --> 14:44.190
它内层是一个函数

14:44.190 --> 14:45.190
函数也就是说

14:45.190 --> 14:46.190
它有哪些函数

14:46.190 --> 14:47.190
有什么反回内层

14:47.190 --> 14:48.190
函数有什么呢

14:48.190 --> 14:50.190
不需要理由参数

14:50.190 --> 14:51.190
不需要理由参数

14:51.190 --> 14:52.190
因此空的

14:52.190 --> 14:53.190
不需要理由参数

14:53.190 --> 14:54.190
反回内层是什么呢

14:54.190 --> 14:56.190
反回内层为void

14:56.190 --> 14:58.190
反回内层为void

14:58.190 --> 14:59.190
当然其实这里

14:59.190 --> 15:00.190
有些人已经想到了

15:00.190 --> 15:01.190
其实这两个回调

15:01.190 --> 15:02.190
可以把它做成一个回调

15:02.190 --> 15:03.190
对吧

15:03.190 --> 15:05.190
可以把它做成一个回调函数

15:05.190 --> 15:06.190
没问题吧

15:06.190 --> 15:08.190
我们把它做成一个回调函数

15:08.190 --> 15:10.190
我们可以使用这种方式

15:11.190 --> 15:13.190
unchain

15:13.190 --> 15:14.190
两个都用一个回调函数

15:14.190 --> 15:16.190
然后给这个回调函数

15:16.190 --> 15:18.190
给这个回调函数

15:18.190 --> 15:19.190
绑定一个

15:19.190 --> 15:21.190
就这样子

15:21.190 --> 15:23.190
来这样子写

15:23.190 --> 15:25.190
判断一下

15:25.190 --> 15:27.190
prose unchain

15:27.190 --> 15:29.190
你有没有传递这个回调函数

15:29.190 --> 15:30.190
如果你有传递

15:30.190 --> 15:31.190
这个回调函数的话

15:31.190 --> 15:32.190
我这里调用一下

15:32.190 --> 15:33.190
回调函数

15:33.190 --> 15:34.190
我这里手动处理一下

15:34.190 --> 15:36.190
调用一下这个回调函数

15:36.190 --> 15:38.190
回调函数

15:38.190 --> 15:40.190
这里我给它传递一个参数

15:40.190 --> 15:42.190
参数就是

15:42.190 --> 15:44.190
这里是简法

15:44.190 --> 15:46.190
简法就是prose non-1

15:46.190 --> 15:48.190
我把简箱简的结果传给你

15:48.190 --> 15:50.190
稍微写一下

15:50.190 --> 15:52.190
那么这下面也是一样的

15:52.190 --> 15:54.190
这下面也是一样的

15:54.190 --> 15:56.190
这里就是加以

15:56.190 --> 15:57.190
加以

15:57.190 --> 15:58.190
能看懂吧

15:58.190 --> 15:59.190
应该没什么问题吧

15:59.190 --> 16:01.190
rex是最基本的知识

16:01.190 --> 16:02.190
好

16:02.190 --> 16:04.190
那么这里我就给它配置一个

16:04.190 --> 16:05.190
就是你的属性里边

16:05.190 --> 16:06.190
有可能

16:06.190 --> 16:08.190
要传一个回调函数进来

16:08.190 --> 16:10.190
这回调函数有一个参数

16:10.190 --> 16:12.190
这个参数的类型

16:12.190 --> 16:14.190
就是要改变成结果

16:14.190 --> 16:15.190
要改变成什么值

16:15.190 --> 16:16.190
它也是一个number

16:16.190 --> 16:17.190
也是一个number

16:17.190 --> 16:18.190
你去处理吧

16:18.190 --> 16:20.190
交给你去处理

16:20.190 --> 16:21.190
好

16:21.190 --> 16:22.190
有了这个东西过后

16:22.190 --> 16:24.190
有了这个东西过后

16:24.190 --> 16:25.190
你看

16:25.190 --> 16:26.190
我们现在有了这个接口过后

16:26.190 --> 16:28.190
就可以对属性里边

16:28.190 --> 16:30.190
每一部分进行严格的约束

16:30.190 --> 16:32.190
然后我们现在把这个接口

16:32.190 --> 16:34.190
用这个接口来约束这个参数

16:34.190 --> 16:36.190
约束这个参数

16:36.190 --> 16:38.190
大家现在再看一下

16:38.190 --> 16:40.190
当我们使用这个参数的时候

16:40.190 --> 16:43.190
你看是不是已经有智能提示了

16:43.190 --> 16:45.190
你可以使用这两个属性

16:45.190 --> 16:47.190
并且如果你在属性的过程中

16:47.190 --> 16:48.190
写错了

16:48.190 --> 16:49.190
写成了大写的n

16:49.190 --> 16:50.190
马上就爆错了

16:50.190 --> 16:51.190
它告诉你

16:51.190 --> 16:53.190
你这属性里面没有这个东西

16:53.190 --> 16:54.190
属性里面没有传这个东西

16:54.190 --> 16:55.190
你不能使用的

16:55.190 --> 16:56.190
所以你看

16:56.190 --> 16:58.190
每一部都有严格的类型检查

16:58.190 --> 16:59.190
类型检查就出来了

16:59.190 --> 17:00.190
好

17:00.190 --> 17:01.190
这里它爆错了

17:01.190 --> 17:02.190
看一下为什么爆错

17:02.190 --> 17:03.190
它告诉你

17:03.190 --> 17:04.190
有可能呢

17:04.190 --> 17:06.190
这里可能是NOW

17:06.190 --> 17:07.190
就可能是undefend

17:07.190 --> 17:08.190
它没有传的

17:08.190 --> 17:10.190
你看这些问题它提示得很细的

17:10.190 --> 17:11.190
它能知道

17:11.190 --> 17:13.190
这里可能代码可能会有隐患

17:13.190 --> 17:15.190
而且这种提示是在运行之前

17:15.190 --> 17:16.190
还没有运行出来

17:16.190 --> 17:18.190
我们就知道代码有哪里出了问题

17:18.190 --> 17:19.190
你这个地方

17:19.190 --> 17:21.190
它告诉你unchanged

17:21.190 --> 17:23.190
有可能是undefend

17:23.190 --> 17:24.190
有可能是undefend

17:24.190 --> 17:26.190
那里这里去调用的话

17:26.190 --> 17:28.190
会导致它出问题

17:28.190 --> 17:29.190
于是你就马上改

17:29.190 --> 17:30.190
你看一下代码

17:30.190 --> 17:31.190
原来是这个地方

17:31.190 --> 17:32.190
要判断一下

17:32.190 --> 17:34.190
当你进行的判断过后

17:34.190 --> 17:35.190
它马上就知道了

17:35.190 --> 17:37.190
原来你这里已经经过判断了

17:37.190 --> 17:38.190
到了11行的时候

17:38.190 --> 17:39.190
它一定不为NOW

17:39.190 --> 17:41.190
它一定你看NOW就没了

17:41.190 --> 17:42.190
它是一个普通的函数

17:42.190 --> 17:44.190
并且函数有一个参数

17:44.190 --> 17:46.190
那你要传一个参数进去

17:46.190 --> 17:47.190
传一个参数进去

17:47.190 --> 17:48.190
通过这么模式

17:48.190 --> 17:51.190
我们就可以获得严格的类型检查

17:51.190 --> 17:52.190
好了

17:52.190 --> 17:53.190
这个组件写好了之后

17:53.190 --> 17:55.190
你看这边去使用这个组件的时候

17:55.190 --> 17:56.190
再看

17:56.190 --> 17:57.190
现在马上就爆错了

17:57.190 --> 17:58.190
为什么爆错

17:58.190 --> 18:00.190
它就会提示你

18:00.190 --> 18:02.190
这个组件里面有一个属性是NOW

18:02.190 --> 18:04.190
NOW这个属性是不能为空的

18:04.190 --> 18:06.190
是必须要传递的

18:06.190 --> 18:09.190
因为这边这个属性不是可选

18:09.190 --> 18:10.190
不是可选的

18:10.190 --> 18:11.190
是必须要传递的

18:11.190 --> 18:13.190
因此它这里就爆错了

18:13.190 --> 18:14.190
爆错的时候

18:14.190 --> 18:15.190
你怎么来处理呢

18:15.190 --> 18:16.190
你直接把属性夹上来

18:16.190 --> 18:18.190
你看它有智能体式的

18:18.190 --> 18:19.190
NOW

18:19.190 --> 18:20.190
一个班手

18:20.190 --> 18:22.190
表示这是一个普通属性

18:22.190 --> 18:23.190
传递的时候

18:23.190 --> 18:24.190
你看传递的时候

18:24.190 --> 18:25.190
如果该传一个制服串

18:25.190 --> 18:26.190
不行

18:26.190 --> 18:27.190
它不能是一个制服串

18:27.190 --> 18:29.190
它告诉你不能把制服串

18:29.190 --> 18:30.190
一个数字

18:30.190 --> 18:31.190
你马上就明白了

18:31.190 --> 18:33.190
这里写错了

18:33.190 --> 18:34.190
把它改一下

18:34.190 --> 18:35.190
改成一个数字

18:35.190 --> 18:36.190
明白这个意思吗

18:36.190 --> 18:38.190
是不是这样子做了过后

18:38.190 --> 18:39.190
这样子做了过后

18:39.190 --> 18:42.190
整个程序就非常难以出错了

18:42.190 --> 18:43.190
就很难以出错了

18:43.190 --> 18:45.190
而且这种检查是在

18:45.190 --> 18:47.190
编译的时候完成的

18:47.190 --> 18:48.190
是在写代码的过程中完成的

18:48.190 --> 18:50.190
而不是在运行的时候

18:50.190 --> 18:51.190
运行的时候

18:51.190 --> 18:53.190
时间点太靠后了

18:53.190 --> 18:54.190
好

18:54.190 --> 18:55.190
韩苏组建

18:55.190 --> 18:57.190
这是一种书写方式

18:57.190 --> 18:59.190
还有一种书写方式

18:59.190 --> 19:01.190
使用这种书写方式

19:01.190 --> 19:03.190
看一下

19:03.190 --> 19:05.190
我这里稍微改一下

19:05.190 --> 19:06.190
我这里呢

19:06.190 --> 19:07.190
返回的是

19:07.190 --> 19:08.190
导出的是一个变量

19:08.190 --> 19:10.190
比方变量

19:10.190 --> 19:11.190
变量的名字叫做

19:11.190 --> 19:12.190
Count

19:12.190 --> 19:14.190
就是使用韩苏表达式

19:14.190 --> 19:16.190
来给它复制

19:16.190 --> 19:18.190
使用这种韩苏表达式来复制

19:18.190 --> 19:20.190
那么在这个复制的时候

19:20.190 --> 19:21.190
这里有个变量

19:21.190 --> 19:22.190
它是一个韩苏

19:22.190 --> 19:23.190
是一样的

19:23.190 --> 19:24.190
这种情况是一样的

19:24.190 --> 19:25.190
这个变量

19:25.190 --> 19:26.190
它是一个韩苏组建

19:26.190 --> 19:28.190
那么在这个变量的位置

19:28.190 --> 19:29.190
我们其实就可以

19:29.190 --> 19:30.190
对它进行约束

19:30.190 --> 19:32.190
可以对它进行约束

19:32.190 --> 19:33.190
怎么约束呢

19:33.190 --> 19:34.190
约束的这个

19:34.190 --> 19:35.190
这个字

19:35.190 --> 19:36.190
react

19:36.190 --> 19:37.190
把导入进来

19:37.190 --> 19:38.190
react

19:38.190 --> 19:39.190
第二

19:39.190 --> 19:40.190
什么

19:42.190 --> 19:44.190
fc

19:44.190 --> 19:45.190
fc

19:45.190 --> 19:46.190
表示

19:46.190 --> 19:47.190
f表示

19:47.190 --> 19:48.190
function

19:48.190 --> 19:49.190
c表示

19:49.190 --> 19:50.190
component

19:50.190 --> 19:52.190
这是一个内行

19:52.190 --> 19:53.190
这个内行

19:53.190 --> 19:54.190
我们看一下吧

19:54.190 --> 19:55.190
if12

19:55.190 --> 19:56.190
你看

19:56.190 --> 19:57.190
这是一个内行别名

19:57.190 --> 19:58.190
内行别名

19:58.190 --> 20:00.190
并且是带翻型的内行别名

20:00.190 --> 20:01.190
它这个翻型

20:01.190 --> 20:02.190
默认只是一个空对象

20:02.190 --> 20:04.190
这个翻型是啥意思呢

20:04.190 --> 20:05.190
其实这个翻型的意思

20:05.190 --> 20:07.190
就是属性的内行

20:07.190 --> 20:08.190
你是一个韩苏组建

20:08.190 --> 20:10.190
韩苏组建没有状态

20:10.190 --> 20:11.190
没有状态

20:11.190 --> 20:12.190
你只能通过属性

20:12.190 --> 20:13.190
只有属性

20:13.190 --> 20:14.190
那么属性是什么内行呢

20:14.190 --> 20:16.190
可以通过翻型来告诉它

20:16.190 --> 20:17.190
什么内行

20:17.190 --> 20:19.190
就是ipros

20:19.190 --> 20:21.190
就这个内行

20:21.190 --> 20:22.190
通过这种方式

20:22.190 --> 20:23.190
来告诉它

20:23.190 --> 20:24.190
我这个属性的内想

20:24.190 --> 20:25.190
就是ipros

20:25.190 --> 20:26.190
那么现在呢

20:26.190 --> 20:27.190
后边写的这个韩苏

20:27.190 --> 20:29.190
我就可以不要这个东西了

20:29.190 --> 20:30.190
可以不要了

20:30.190 --> 20:31.190
那么我们现在只这个propos

20:31.190 --> 20:32.190
你看一下

20:32.190 --> 20:33.190
它推断出来

20:33.190 --> 20:35.190
推断出来就是个ipros

20:35.190 --> 20:36.190
ipros

20:36.190 --> 20:38.190
并且它给你进行的封装

20:38.190 --> 20:40.190
这种写法跟之前的

20:40.190 --> 20:41.190
在这里进行约束

20:41.190 --> 20:42.190
有什么不一样呢

20:42.190 --> 20:43.190
我们再看一下

20:43.190 --> 20:45.190
这种写法写出来的代码呢

20:45.190 --> 20:46.190
以这个propos里面

20:46.190 --> 20:47.190
会多一个东西

20:47.190 --> 20:48.190
叫做切组

20:48.190 --> 20:49.190
这个知道吧

20:49.190 --> 20:51.190
切组啥意思

20:51.190 --> 20:53.190
有点类似于无忧的插槽

20:53.190 --> 20:54.190
对不对

20:54.190 --> 20:55.190
它可以表示

20:55.190 --> 20:58.190
可以往这个组件的内容里面

20:58.190 --> 20:59.190
去放一些东西

20:59.190 --> 21:01.190
在这个组件内容里面

21:01.190 --> 21:02.190
就像这样子

21:02.190 --> 21:04.190
像这样子

21:06.190 --> 21:07.190
这个组件内容里面

21:07.190 --> 21:08.190
可以去放一些东西

21:08.190 --> 21:09.190
这些东西呢

21:09.190 --> 21:10.190
会传递给

21:10.190 --> 21:11.190
作为切组

21:11.190 --> 21:12.190
传递给

21:12.190 --> 21:14.190
这个属性的切组里面

21:14.190 --> 21:15.190
因此呢

21:15.190 --> 21:16.190
你用这种写法

21:16.190 --> 21:17.190
它会多一个属性切组

21:17.190 --> 21:19.190
这两种写法都可以

21:19.190 --> 21:20.190
当然呢

21:20.190 --> 21:21.190
这边

21:21.190 --> 21:23.190
你还可以把它写成一个箭头寒书

21:23.190 --> 21:24.190
都没有任何问题

21:24.190 --> 21:25.190
总之呢

21:25.190 --> 21:26.190
你得想办法

21:26.190 --> 21:27.190
把它的属性约束一下

21:27.190 --> 21:30.190
寒书组件有两种约束方式

21:30.190 --> 21:31.190
这是一种约束方式

21:31.190 --> 21:32.190
还有最开始

21:32.190 --> 21:33.190
我们直接在属性这里

21:33.190 --> 21:35.190
也可以进行约束

21:35.190 --> 21:36.190
两种方式都可以

21:36.190 --> 21:37.190
只不过区别在于

21:37.190 --> 21:38.190
用这种方式呢

21:38.190 --> 21:39.190
它会多一个属性

21:39.190 --> 21:40.190
就是切组

21:40.190 --> 21:41.190
好

21:41.190 --> 21:42.190
这里呢

21:42.190 --> 21:43.190
我要说明一下

21:43.190 --> 21:44.190
说明一下

21:44.190 --> 21:45.190
但你可能会看到

21:45.190 --> 21:46.190
网上有些

21:46.190 --> 21:49.190
TS和read教程里边呢

21:49.190 --> 21:50.190
说到了

21:50.190 --> 21:52.190
约束一个寒书式

21:52.190 --> 21:53.190
寒书式组件的话

21:53.190 --> 21:55.190
如果你要约束一个寒书式

21:55.190 --> 21:56.190
组件的话

21:56.190 --> 21:58.190
你要使用fsc

21:58.190 --> 21:59.190
你可能看到一些教程里面

21:59.190 --> 22:01.190
是这样的写的

22:01.190 --> 22:02.190
是这样的写的

22:02.190 --> 22:03.190
I promise

22:05.190 --> 22:06.190
它要求你这样的写

22:06.190 --> 22:07.190
其实呢

22:07.190 --> 22:08.190
现在呢

22:08.190 --> 22:09.190
大家使用fc就行了

22:09.190 --> 22:11.190
不要使用sfc了

22:11.190 --> 22:12.190
它这里其实已经有提示

22:12.190 --> 22:13.190
它说了

22:13.190 --> 22:14.190
这个已经过期了

22:14.190 --> 22:15.190
已经过期了

22:15.190 --> 22:16.190
不要不建议你再使用了

22:16.190 --> 22:17.190
它说

22:17.190 --> 22:19.190
根据最近的rex这个版本啊

22:19.190 --> 22:21.190
寒书组件已经不再是

22:21.190 --> 22:23.190
无状态的了

22:23.190 --> 22:24.190
它说

22:24.190 --> 22:25.190
function components

22:25.190 --> 22:26.190
还是组件

22:26.190 --> 22:28.190
can no longer be considered

22:28.190 --> 22:29.190
stateless

22:29.190 --> 22:30.190
已经不再被认为是

22:30.190 --> 22:31.190
无状态的了

22:31.190 --> 22:33.190
因为寒书组件里边呢

22:33.190 --> 22:34.190
它多了

22:34.190 --> 22:35.190
可以用这个东西

22:35.190 --> 22:36.190
rex最新版本里面

22:36.190 --> 22:37.190
有个提案

22:37.190 --> 22:38.190
就是hooks

22:38.190 --> 22:39.190
rex勾字

22:39.190 --> 22:40.190
那么这个东西

22:40.190 --> 22:41.190
如果你不了解的话

22:41.190 --> 22:42.190
但是我这个课程

22:42.190 --> 22:43.190
肯定不展开了

22:43.190 --> 22:44.190
肯定不展开了

22:44.190 --> 22:46.190
我们后边的相关课程

22:46.190 --> 22:47.190
可能会讲到这个东西

22:47.190 --> 22:48.190
大家可以

22:48.190 --> 22:49.190
密切关注一下

22:49.190 --> 22:50.190
独一学院的

22:50.190 --> 22:51.190
后边的相关课程

22:51.190 --> 22:53.190
那么你建议你现在使用

22:53.190 --> 22:55.190
寒书组件约束的话

22:55.190 --> 22:57.190
应该使用function components

22:57.190 --> 22:58.190
来代替

22:58.190 --> 22:59.190
就是fc

22:59.190 --> 23:01.190
使用fc来代替

23:01.190 --> 23:03.190
这个大家了解一下就行了

23:04.190 --> 23:05.190
好

23:05.190 --> 23:06.190
那么现在我们做了

23:06.190 --> 23:07.190
这个寒书组件过后了

23:07.190 --> 23:08.190
这边

23:08.190 --> 23:09.190
那么就可以得到

23:09.190 --> 23:11.190
严格的内容检查了

23:11.190 --> 23:13.190
可以得到严格的内容检查

23:13.190 --> 23:14.190
包括

23:14.190 --> 23:15.190
写回掉寒书

23:15.190 --> 23:16.190
你看一下

23:16.190 --> 23:17.190
不可能写错的

23:17.190 --> 23:18.190
它会智能提示你

23:18.190 --> 23:20.190
如果你这里写错了

23:20.190 --> 23:21.190
如果你这里写错了

23:21.190 --> 23:22.190
马上就提示你

23:22.190 --> 23:23.190
这个什么

23:23.190 --> 23:24.190
这个属性不存在

23:24.190 --> 23:25.190
unchanged

23:25.190 --> 23:26.190
不存在这个属性

23:27.190 --> 23:28.190
我们写成正确的

23:28.190 --> 23:29.190
unchanged

23:29.190 --> 23:31.190
并且你复辞的时候

23:31.190 --> 23:32.190
你能弯复辞吗

23:32.190 --> 23:33.190
肯定不行

23:33.190 --> 23:34.190
你刚复辞一个

23:34.190 --> 23:35.190
你刚复辞一个

23:35.190 --> 23:36.190
制服出来的事实

23:36.190 --> 23:37.190
你行吗

23:37.190 --> 23:38.190
你刚复辞一个数字

23:38.190 --> 23:39.190
你试试

23:39.190 --> 23:40.190
可以吗

23:40.190 --> 23:41.190
绝对不可以

23:41.190 --> 23:42.190
它必须是一个寒书

23:42.190 --> 23:43.190
它是有约束的

23:43.190 --> 23:44.190
你看

23:44.190 --> 23:45.190
它告诉你这个寒书

23:46.190 --> 23:48.190
它告诉你这个寒书有一个

23:48.190 --> 23:50.190
它告诉你这个寒书有一个

23:50.190 --> 23:51.190
参数n

23:51.190 --> 23:52.190
返回类型为void

23:52.190 --> 23:54.190
你可以不写这个属性

23:54.190 --> 23:55.190
但是你要写的话

23:55.190 --> 23:57.190
你只能复辞为这个寒书

23:57.190 --> 23:59.190
ok 那么你这里复辞的时候

23:59.190 --> 24:00.190
有个n

24:00.190 --> 24:01.190
参数有个n

24:01.190 --> 24:02.190
对吧

24:02.190 --> 24:03.190
然后这个寒书的T

24:03.190 --> 24:04.190
逼成一个n它的推断出来

24:04.190 --> 24:05.190
是一个number的一形

24:05.190 --> 24:06.190
你看每一步

24:06.190 --> 24:08.190
它都有严格的内形推荡

24:08.190 --> 24:10.190
我们就不用靠脑袋去记忆

24:10.190 --> 24:11.190
有哪些属性了

24:11.190 --> 24:12.190
它已经跟你说得很明白了

24:13.190 --> 24:14.190
并且我们以后

24:14.190 --> 24:15.190
就算要看

24:15.190 --> 24:16.190
忘了哪些属性

24:16.190 --> 24:17.190
就算要看的话

24:17.190 --> 24:18.190
你看一下这个接口

24:18.190 --> 24:19.190
所以啥都明白了

24:19.190 --> 24:20.190
哪些属性是可选的

24:20.190 --> 24:21.190
每个属性是什么内形

24:21.190 --> 24:23.190
我们也不需要使用以前的

24:24.190 --> 24:25.190
这种方式

24:25.190 --> 24:27.190
也不需要使用以前的这种方式

24:27.190 --> 24:29.190
来对它进行内形检查了

24:29.190 --> 24:30.190
所以方便很多了

24:32.190 --> 24:34.190
这是寒书式的组件

24:34.190 --> 24:36.190
这是寒书式的组件

24:36.190 --> 24:38.190
那么内组件该怎么写呢

24:38.190 --> 24:39.190
内组件该怎么写呢

24:39.190 --> 24:41.190
我们来写一下内组件

24:43.190 --> 24:44.190
内组件

24:44.190 --> 24:46.190
内组件自然而然是一个class

24:46.190 --> 24:48.190
export导出

24:48.190 --> 24:50.190
class

24:50.190 --> 24:52.190
内名就跟取名还是一样的

24:54.190 --> 24:55.190
这里顺便说一下

24:55.190 --> 24:57.190
其实这个接口你也可以导出

24:57.190 --> 24:58.190
可导出可不导出

24:58.190 --> 24:59.190
无所谓的

24:59.190 --> 25:00.190
因为接口

25:00.190 --> 25:01.190
它不会出在那边

25:01.190 --> 25:02.190
你也过里边

25:02.190 --> 25:03.190
无所谓的

25:03.190 --> 25:04.190
如果外面

25:04.190 --> 25:05.190
可能会用到这个接口的话

25:05.190 --> 25:06.190
你把导出吧

25:06.190 --> 25:07.190
如果不需要用到这个接口的话

25:07.190 --> 25:08.190
你不导出也行

25:08.190 --> 25:09.190
无所谓

25:10.190 --> 25:11.190
这里写一个内组件

25:11.190 --> 25:13.190
内组件它当然要去继承

25:13.190 --> 25:14.190
继承哪了

25:14.190 --> 25:15.190
react

25:15.190 --> 25:16.190
component

25:16.190 --> 25:17.190
继承这个地方

25:17.190 --> 25:19.190
继承这个内组件

25:19.190 --> 25:20.190
这里

25:21.190 --> 25:22.190
把导入一下

25:24.190 --> 25:25.190
快速修复

25:25.190 --> 25:27.190
导入一下react

25:28.190 --> 25:29.190
导入过后

25:29.190 --> 25:30.190
这是个内组件

25:30.190 --> 25:31.190
内组件里面

25:31.190 --> 25:32.190
我们如何来约束

25:32.190 --> 25:34.190
内组件里面的属性

25:34.190 --> 25:36.190
如何来约束它的属性

25:36.190 --> 25:37.190
你看内组件里面

25:37.190 --> 25:39.190
它的翻习会多一些

25:39.190 --> 25:40.190
它的翻习会多一些

25:41.190 --> 25:43.190
我们可以写两个翻习

25:43.190 --> 25:44.190
第三个不用管

25:44.190 --> 25:45.190
第三个不用管

25:45.190 --> 25:47.190
第一个翻习就是属性的内相

25:47.190 --> 25:48.190
iProbs

25:51.190 --> 25:52.190
就是属性的内相

25:52.190 --> 25:54.190
它可以约束有一个内相

25:54.190 --> 25:55.190
那么现在呢

25:55.190 --> 25:57.190
这个内组件里面的属性

25:57.190 --> 25:59.190
我为什么把刚才全部删完了

25:59.190 --> 26:00.190
等一下

26:00.190 --> 26:02.190
我代码要复制一下

26:04.190 --> 26:05.190
代码我需要用的

26:06.190 --> 26:07.190
像这样子吧

26:07.190 --> 26:08.190
复制一下

26:08.190 --> 26:09.190
复制一下

26:09.190 --> 26:10.190
复制一下这个代码

26:10.190 --> 26:11.190
然后把它注释掉

26:12.190 --> 26:13.190
我写内组件

26:13.190 --> 26:14.190
export

26:14.190 --> 26:15.190
class

26:16.190 --> 26:17.190
count

26:17.190 --> 26:18.190
comp

26:19.190 --> 26:20.190
继承

26:20.190 --> 26:21.190
extend

26:21.190 --> 26:22.190
react

26:22.190 --> 26:23.190
component

26:24.190 --> 26:25.190
ok

26:25.190 --> 26:26.190
这里

26:26.190 --> 26:27.190
把导入进来

26:28.190 --> 26:29.190
好 这里

26:29.190 --> 26:31.190
我们写翻译的时候

26:31.190 --> 26:33.190
我们写这个翻译的时候

26:33.190 --> 26:34.190
第一个翻译

26:34.190 --> 26:36.190
指的是属性的内相

26:36.190 --> 26:38.190
那就是iProbs

26:38.190 --> 26:40.190
内组件可以通过这种方式来书写

26:40.190 --> 26:41.190
好 后边我们

26:41.190 --> 26:43.190
Render这个函数里面

26:43.190 --> 26:45.190
Render函数里面

26:45.190 --> 26:47.190
就把这个翻回

26:47.190 --> 26:48.190
那么当然这里

26:48.190 --> 26:49.190
应该使用ZS

26:49.190 --> 26:51.190
你看以前是没有这个提示的

26:51.190 --> 26:52.190
如果你以前

26:52.190 --> 26:54.190
像这个地方也是经常出现的错误

26:54.190 --> 26:55.190
在内组件里面

26:55.190 --> 26:56.190
我们使用

26:56.190 --> 26:57.190
没有去加账这个类似

26:57.190 --> 26:59.190
是不是也是经常出现的问题

26:59.190 --> 27:00.190
对不对

27:01.190 --> 27:03.190
这里把这个ZS加上

27:03.190 --> 27:04.190
ZS加上

27:04.190 --> 27:05.190
你看

27:05.190 --> 27:06.190
同样可以获得

27:06.190 --> 27:07.190
所有的智能提示

27:07.190 --> 27:08.190
对

27:08.190 --> 27:09.190
你看

27:09.190 --> 27:10.190
当然是一样的

27:10.190 --> 27:11.190
内组件里面

27:11.190 --> 27:13.190
除了使用这个

27:13.190 --> 27:16.190
内相来约束属性之外

27:16.190 --> 27:18.190
还可以约束状态

27:18.190 --> 27:20.190
还可以约束状态

27:20.190 --> 27:21.190
比方说目前的状态

27:21.190 --> 27:22.190
它默认情况下是啥呢

27:22.190 --> 27:23.190
我们来看一下

27:23.190 --> 27:24.190
ZS

27:24.190 --> 27:25.190
你看都有智能提示的

27:25.190 --> 27:27.190
因为它知道这是个组件

27:27.190 --> 27:28.190
这是个组件

27:28.190 --> 27:29.190
它有这个State属性

27:29.190 --> 27:30.190
那么这里面有啥东西

27:30.190 --> 27:32.190
让我指着它看一下

27:32.190 --> 27:33.190
指着它看一下

27:33.190 --> 27:34.190
它默认的话

27:34.190 --> 27:35.190
是一个空的对象

27:35.190 --> 27:37.190
它的内相是一个空的对象

27:37.190 --> 27:39.190
因此你这里得不到任何东西

27:39.190 --> 27:42.190
当然我们可以去约束一下

27:42.190 --> 27:44.190
约束一下它的

27:44.190 --> 27:45.190
iState

27:45.190 --> 27:46.190
约束它的状态

27:46.190 --> 27:47.190
比方说状态

27:47.190 --> 27:48.190
我这里也没有什么状态

27:48.190 --> 27:49.190
可以写

27:49.190 --> 27:50.190
我就随便写一个

27:50.190 --> 27:51.190
随便写一个

27:51.190 --> 27:52.190
比方message

27:52.190 --> 27:53.190
是一个支付串

27:53.190 --> 27:54.190
一个状态

27:54.190 --> 27:56.190
就随便写吧

27:56.190 --> 27:59.190
然后description

27:59.190 --> 28:00.190
也是一个支付串

28:00.190 --> 28:01.190
我们就随便写一个

28:01.190 --> 28:03.190
来测试一下

28:03.190 --> 28:05.190
写了这个约束过后

28:05.190 --> 28:07.190
它的状态State里面

28:07.190 --> 28:08.190
有哪些东西

28:08.190 --> 28:09.190
每个东西有什么类型

28:09.190 --> 28:11.190
我就可以通过这里

28:11.190 --> 28:12.190
写第二个状态

28:12.190 --> 28:13.190
iState

28:13.190 --> 28:14.190
来进行约束

28:14.190 --> 28:16.190
约束过后咱们来看一下

28:16.190 --> 28:17.190
给你们看一下

28:17.190 --> 28:18.190
这个State里面

28:18.190 --> 28:19.190
是不是有东西了

28:19.190 --> 28:20.190
description

28:20.190 --> 28:21.190
message

28:21.190 --> 28:22.190
都有智能提示的

28:22.190 --> 28:23.190
你还不能写错

28:23.190 --> 28:24.190
你写错了

28:24.190 --> 28:25.190
抱错了

28:25.190 --> 28:26.190
因为它进行了约束

28:26.190 --> 28:27.190
明白这个意思了吗

28:27.190 --> 28:29.190
这是关于这一块

28:29.190 --> 28:31.190
那么这个如果有状态的话

28:31.190 --> 28:33.190
如何来对状态进行初始化

28:33.190 --> 28:35.190
对状态进行初始化

28:35.190 --> 28:36.190
我们在这里写

28:36.190 --> 28:37.190
状态的初始化

28:37.190 --> 28:39.190
比方说State

28:39.190 --> 28:41.190
State

28:41.190 --> 28:43.190
对状态进行初始化

28:43.190 --> 28:45.190
我们可以直接

28:45.190 --> 28:47.190
复制message

28:47.190 --> 28:49.190
控制5串

28:49.190 --> 28:51.190
然后description

28:51.190 --> 28:53.190
控制5串

28:53.190 --> 28:54.190
好

28:54.190 --> 28:55.190
这样子写了过后

28:55.190 --> 28:57.190
大家看一下

28:57.190 --> 28:59.190
会有一个问题

29:00.190 --> 29:01.190
当我们指着State的时候

29:01.190 --> 29:02.190
你看

29:02.190 --> 29:04.190
它判断的类型是啥

29:04.190 --> 29:06.190
它判断出来的类型

29:06.190 --> 29:07.190
是这里的类型

29:07.190 --> 29:08.190
看到没

29:08.190 --> 29:09.190
是这里的类型

29:09.190 --> 29:11.190
而不是这里的类型

29:11.190 --> 29:12.190
你看一下

29:12.190 --> 29:13.190
写了过后

29:13.190 --> 29:14.190
它判断出来的类型是这

29:14.190 --> 29:15.190
一说我们这里

29:15.190 --> 29:17.190
可以多写一些属性

29:17.190 --> 29:20.560
可以多写一些属性

29:20.560 --> 29:21.560
没有任何问题的

29:21.560 --> 29:23.560
但它判断出来的类型

29:23.560 --> 29:24.560
是这个

29:24.560 --> 29:26.560
因此这里有个问题

29:26.560 --> 29:27.560
这个问题

29:27.560 --> 29:29.560
不知道以后的版本能不能解决

29:29.560 --> 29:31.560
就目前的react的版本

29:31.560 --> 29:32.560
和ts结合的时候

29:32.560 --> 29:33.560
有这么一个问题

29:33.560 --> 29:34.560
就是说

29:34.560 --> 29:35.560
如果你写了

29:35.560 --> 29:36.560
状态的初始化的话

29:36.560 --> 29:38.560
状态肯定要初始化的

29:38.560 --> 29:40.560
你写了状态的初始化的话

29:40.560 --> 29:41.560
它会把这个地方给你覆盖掉

29:41.560 --> 29:43.560
会把这个地方覆盖掉

29:43.560 --> 29:44.560
那么这个时候怎么办呢

29:44.560 --> 29:46.560
其实要做的事情非常简单

29:46.560 --> 29:47.560
很好处理

29:47.560 --> 29:48.560
你在这里

29:48.560 --> 29:49.560
再给它加个约束

29:49.560 --> 29:50.560
State

29:50.560 --> 29:51.560
这里再加一次

29:51.560 --> 29:53.560
加一次约束过后

29:53.560 --> 29:54.560
就没问题了

29:54.560 --> 29:56.560
那么这里的类型

29:56.560 --> 29:57.560
跟这里的

29:57.560 --> 29:58.560
就完全保持一致了

29:58.560 --> 29:59.560
当然

29:59.560 --> 30:00.560
你可以

30:00.560 --> 30:01.560
这里

30:01.560 --> 30:02.560
也可以不写

30:02.560 --> 30:03.560
不写的话

30:03.560 --> 30:04.560
你看State约束出来

30:04.560 --> 30:06.560
还是State

30:06.560 --> 30:07.560
就是说

30:07.560 --> 30:08.560
状态这一块

30:08.560 --> 30:09.560
你是可以不写到这的

30:09.560 --> 30:10.560
你直接

30:10.560 --> 30:11.560
在初始化的时候

30:11.560 --> 30:12.560
给它进行状态约束

30:12.560 --> 30:14.560
也是没问题的

30:14.560 --> 30:16.560
这是关于

30:16.560 --> 30:17.560
类组件

30:17.560 --> 30:18.560
类组件

30:18.560 --> 30:19.560
如何来约束

30:20.560 --> 30:21.560
它的类型

30:21.560 --> 30:22.560
那么现在我们知道了

30:22.560 --> 30:23.560
如何来

30:23.560 --> 30:24.560
去用react来

30:24.560 --> 30:25.560
书写一个函数式组件

30:25.560 --> 30:27.560
如何来书写个类组件

30:27.560 --> 30:28.560
我都清楚了

30:28.560 --> 30:29.560
其实非常简单

30:29.560 --> 30:31.560
也没有改变太多的东西

30:31.560 --> 30:33.560
我们把类组件先删了

30:33.560 --> 30:34.560
先删了

30:34.560 --> 30:36.560
我们把功能做完

30:36.560 --> 30:37.560
讲到这

30:37.560 --> 30:38.560
把功能做完

30:38.560 --> 30:40.560
这边我导出了一个函数组件

30:40.560 --> 30:42.560
用之前的方式导出一个函数组件

30:42.560 --> 30:44.560
它需要一个属性

30:44.560 --> 30:45.560
它有约束的属性的类型

30:45.560 --> 30:46.560
为iProps

30:47.560 --> 30:48.560
那么这边使用的时候

30:48.560 --> 30:50.560
因为这边需要设立到状态

30:50.560 --> 30:51.560
所以说

30:51.560 --> 30:53.560
我把这边做成一个类组件

30:54.560 --> 30:55.560
这样子

30:55.560 --> 30:56.560
把它做成一个类组件

30:58.560 --> 30:59.560
我怎么感觉

30:59.560 --> 31:01.560
我现在的鼠标不是那么好用

31:01.560 --> 31:03.560
这边是卡的原因

31:03.560 --> 31:04.560
有可能

31:04.560 --> 31:05.560
用tens

31:05.560 --> 31:06.560
react

31:06.560 --> 31:07.560
component

31:08.560 --> 31:09.560
component

31:10.560 --> 31:12.560
把它做成一个类组件

31:12.560 --> 31:14.560
这个类组件里面有个状态

31:14.560 --> 31:15.560
这个状态

31:15.560 --> 31:17.560
状态我这里可以写一个

31:17.560 --> 31:19.560
我就直接复制字面量

31:19.560 --> 31:21.560
因为它会进行类型的推导

31:21.560 --> 31:24.560
它会把字面量推导为状态的类型

31:24.560 --> 31:25.560
它会进行类型推导的

31:25.560 --> 31:26.560
没问题

31:26.560 --> 31:28.560
这样直接复制为了字面量

31:28.560 --> 31:30.560
我就不在这里用翻询写了

31:31.560 --> 31:32.560
给它设置一个num

31:32.560 --> 31:33.560
默认为你

31:33.560 --> 31:34.560
默认为你

31:34.560 --> 31:35.560
都是它的状态

31:35.560 --> 31:37.560
然后它一个render

31:37.560 --> 31:38.560
render函数

31:38.560 --> 31:39.560
render方法

31:39.560 --> 31:41.560
这个render方法必须要有返回

31:41.560 --> 31:42.560
必须要有返回

31:42.560 --> 31:44.560
它说你不能把void分配给

31:44.560 --> 31:46.560
它的返回类型要求是

31:46.560 --> 31:47.560
react

31:47.560 --> 31:48.560
no的

31:48.560 --> 31:49.560
它必须要要求返回这个类型

31:49.560 --> 31:51.560
这个类型是可以维空的

31:51.560 --> 31:52.560
是可以维空的

31:52.560 --> 31:54.560
你返回一个num

31:54.560 --> 31:55.560
没问题的

31:55.560 --> 31:56.560
不显示

31:56.560 --> 31:57.560
不显示任何东西

31:57.560 --> 31:59.560
当然你不能返回一个字不错

31:59.560 --> 32:00.560
字不错是可以的

32:00.560 --> 32:01.560
可以的

32:01.560 --> 32:02.560
因为我们知道字不错

32:02.560 --> 32:04.560
也是可以把它显示到页面上的

32:04.560 --> 32:05.560
那你返回一个对相

32:05.560 --> 32:06.560
我试一下

32:06.560 --> 32:07.560
对相也是可以的

32:07.560 --> 32:08.560
其实我们可以看一下

32:08.560 --> 32:09.560
看一下这个render函数

32:09.560 --> 32:12.560
它的这个约束

32:12.560 --> 32:13.560
我们转到这个component

32:13.560 --> 32:15.560
转到它的定义

32:15.560 --> 32:18.560
不看一下吗

32:18.560 --> 32:20.560
component的定义

32:20.560 --> 32:21.560
它里面的render

32:21.560 --> 32:22.560
找一找

32:22.560 --> 32:23.560
render

32:23.560 --> 32:24.560
它返回的要求里

32:24.560 --> 32:25.560
返回一个react

32:25.560 --> 32:26.560
no的

32:26.560 --> 32:27.560
那么这个react

32:27.560 --> 32:28.560
no的是什么东西呢

32:28.560 --> 32:29.560
我们转到定义看一下

32:29.560 --> 32:30.560
它里面有这么多

32:30.560 --> 32:32.560
用了联合类型对吧

32:32.560 --> 32:33.560
用了联合类型

32:33.560 --> 32:34.560
可以为undefine

32:34.560 --> 32:35.560
可以返回undefine

32:35.560 --> 32:36.560
可以返回low

32:36.560 --> 32:37.560
可以返回一个布

32:37.560 --> 32:38.560
这些都可以返回

32:38.560 --> 32:39.560
都可以返回

32:39.560 --> 32:40.560
可以返回

32:40.560 --> 32:41.560
这些又是一些

32:41.560 --> 32:42.560
其他的类型了

32:42.560 --> 32:43.560
又是使用了类型别密

32:43.560 --> 32:45.560
大家可以咨询去看一下

32:46.560 --> 32:47.560
好 这里呢

32:47.560 --> 32:48.560
我们这里

32:48.560 --> 32:49.560
总之里要返回

32:49.560 --> 32:51.560
直接返回一个

32:51.560 --> 32:52.560
这个组件吧

32:52.560 --> 32:53.560
直接返回这个组件

32:53.560 --> 32:57.560
这个组件是

32:57.560 --> 32:58.560
返回这个组件

32:58.560 --> 32:59.560
这个组件里边呢

32:59.560 --> 33:01.560
有个属性num

33:01.560 --> 33:02.560
必须要复制

33:02.560 --> 33:03.560
复制的话

33:03.560 --> 33:06.560
就给它来一个num

33:06.560 --> 33:07.560
复制过来

33:07.560 --> 33:08.560
好 它这里报错了

33:08.560 --> 33:09.560
这里我写错了

33:09.560 --> 33:11.560
应该是res state

33:11.560 --> 33:12.560
你看 错误的提示

33:12.560 --> 33:14.560
是非常及时的

33:14.560 --> 33:16.560
好 这里面有

33:16.560 --> 33:17.560
有相应的函数

33:17.560 --> 33:18.560
相应的回到函数

33:18.560 --> 33:19.560
unchanged

33:19.560 --> 33:22.560
当发生改变的时候

33:22.560 --> 33:24.560
我们这里的参数n

33:24.560 --> 33:27.560
就是它会把新的数字传给你

33:27.560 --> 33:28.560
好 我这里做什么呢

33:28.560 --> 33:30.560
res state state

33:30.560 --> 33:31.560
你看 每一步都有智能提示

33:31.560 --> 33:33.560
因为它知道现在是一个组件

33:33.560 --> 33:34.560
它继承过来的

33:34.560 --> 33:36.560
然后复制为啥呢

33:36.560 --> 33:38.560
就是把num复制为啥

33:38.560 --> 33:40.560
复制为n

33:40.560 --> 33:41.560
就写完了

33:41.560 --> 33:43.560
好 这个地方做完了之后

33:43.560 --> 33:45.560
我们到这个index里边去

33:45.560 --> 33:46.560
这个地方

33:46.560 --> 33:48.560
就使用这种方式导入

33:48.560 --> 33:49.560
使用这种方式导入

33:49.560 --> 33:50.560
我来看一下

33:50.560 --> 33:52.560
整个的效果如何

33:52.560 --> 33:54.560
整个的效果会如何

33:54.560 --> 33:56.560
咱们来看一下

33:56.560 --> 33:57.560
加一加

33:57.560 --> 33:58.560
都没有任何问题

33:58.560 --> 33:59.560
对吧

33:59.560 --> 34:00.560
都没有任何问题

34:00.560 --> 34:02.560
这个就把开放完成了

34:02.560 --> 34:03.560
通过这么一个小例子

34:03.560 --> 34:04.560
告诉大家

34:04.560 --> 34:05.560
在react里面

34:05.560 --> 34:08.560
如何来使用这个组件

34:08.560 --> 34:09.560
就是加一些

34:09.560 --> 34:12.560
合适的位置去加一些内容的约束

34:12.560 --> 34:14.560
但是注意

34:14.560 --> 34:15.560
注意

34:15.560 --> 34:17.560
这个地方会有一个小问题

34:17.560 --> 34:19.560
什么小约束

34:19.560 --> 34:21.560
什么小问题呢

34:21.560 --> 34:22.560
在这

34:22.560 --> 34:25.560
sets data里面

34:25.560 --> 34:27.560
这里会有个什么问题呢

34:27.560 --> 34:29.560
就是说

34:29.560 --> 34:31.560
你在这边去设置的时候

34:31.560 --> 34:33.560
没有经过内容检查

34:33.560 --> 34:35.560
这里它得不到内容检查

34:35.560 --> 34:36.560
什么内容检查呢

34:36.560 --> 34:38.560
比方说我这里设置数字的时候

34:38.560 --> 34:40.560
我设置成了一个n

34:40.560 --> 34:41.560
比方说

34:41.560 --> 34:43.560
或者是成这个东西

34:43.560 --> 34:45.560
我忘了我的

34:45.560 --> 34:46.560
那个属性名字叫num

34:46.560 --> 34:48.560
我把它设置成number

34:48.560 --> 34:50.560
把它设置成n

34:50.560 --> 34:51.560
它没有属性

34:51.560 --> 34:53.560
它没有内容检查

34:53.560 --> 34:55.560
为什么这里没有内容检查呢

34:55.560 --> 34:56.560
这个问题

34:56.560 --> 34:58.560
不知道未来版本里面能不能解决

34:58.560 --> 35:00.560
现在好像

35:00.560 --> 35:02.560
react里面有点困难解决这个问题

35:02.560 --> 35:04.560
因为你这里的

35:04.560 --> 35:07.560
它能推到出你这个状态的内容

35:07.560 --> 35:09.560
但是它现在推到不出来

35:09.560 --> 35:10.560
这个sets data

35:10.560 --> 35:12.560
这个参数是什么内容

35:12.560 --> 35:13.560
而这两个内容

35:13.560 --> 35:15.560
它很难把它挂钩

35:15.560 --> 35:16.560
就是这里的sets内容

35:16.560 --> 35:18.560
和这里的参数内容很难挂钩

35:18.560 --> 35:20.560
因为

35:20.560 --> 35:22.560
这个原因的话

35:22.560 --> 35:23.560
要讲一下就复杂了

35:23.560 --> 35:25.560
其实跟我们设置的方形有关

35:25.560 --> 35:27.560
你这个函数是在哪个内里面的函数呢

35:27.560 --> 35:29.560
是在这个内里面的函数

35:29.560 --> 35:31.560
而这个内容是一个翻型内

35:31.560 --> 35:32.560
它是需要翻型的

35:32.560 --> 35:34.560
但是你没有给它翻型

35:34.560 --> 35:36.560
没有给它翻型的话

35:36.560 --> 35:38.560
那么它的默认翻型就是一个空对象

35:38.560 --> 35:40.560
因此它这个sets data

35:40.560 --> 35:42.560
它认为它这里认为是个空对象

35:42.560 --> 35:43.560
认为是个空对象

35:43.560 --> 35:45.560
所以说你什么东西都可以复制

35:45.560 --> 35:47.560
因此你要解决这个问题呢

35:47.560 --> 35:50.560
你就就得在这里

35:50.560 --> 35:51.560
你在这里

35:51.560 --> 35:53.560
要把这个sets的内形给它写上

35:53.560 --> 35:55.560
就必须要在这里写上翻型

35:55.560 --> 35:56.560
我们之前说

35:56.560 --> 35:58.560
这里可以不写sets的翻型

35:58.560 --> 36:00.560
是因为我们如果只需要用到

36:00.560 --> 36:02.560
这个sets的内形推到的话

36:02.560 --> 36:03.560
那么就没问题

36:03.560 --> 36:05.560
如果你要在sets stets里面

36:05.560 --> 36:07.560
获得完整的内形检查的话

36:07.560 --> 36:09.560
你这里的翻型是必须要写上的

36:09.560 --> 36:10.560
必须要写上

36:10.560 --> 36:12.560
所以说这里哪里还没办法

36:12.560 --> 36:13.560
第一个是属性

36:13.560 --> 36:14.560
属性的话就是空对象

36:14.560 --> 36:16.560
没有不需要属性

36:16.560 --> 36:19.560
第二个就是翻型

36:19.560 --> 36:21.560
就是这个sets的内形

36:21.560 --> 36:24.560
那么我们还是得建一个interface

36:24.560 --> 36:26.560
iState

36:26.560 --> 36:28.560
那是一个number

36:28.560 --> 36:33.560
这里把这个加到这个位置

36:33.560 --> 36:35.560
这个地方也约束一下

36:35.560 --> 36:37.560
好那么现在你看

36:37.560 --> 36:40.560
它就会获得内形检查了

36:40.560 --> 36:43.560
这个number都属性

36:43.560 --> 36:44.560
不在这个内形里面

36:44.560 --> 36:46.560
那么它现在就会给你包捉

36:46.560 --> 36:48.560
现在指的这个setsState

36:48.560 --> 36:49.560
它现在知道了

36:49.560 --> 36:52.560
我们的状态是一个iState

36:52.560 --> 36:55.560
所以说我们setsState这个函数

36:55.560 --> 36:57.560
sets 这里显示不下

36:57.560 --> 36:58.560
setsState这个函数

36:58.560 --> 37:00.560
那么你现在要設置的是number

37:00.560 --> 37:03.560
然后这里

37:03.560 --> 37:06.390
然后这里

37:06.390 --> 37:07.390
你看

37:07.390 --> 37:11.390
设置函数参数必须是一个iState的内形

37:11.390 --> 37:13.390
必须是一个这么一个内形

37:13.390 --> 37:15.390
好我们把它修改正确

37:15.390 --> 37:18.390
把修改成为number

37:18.390 --> 37:19.390
把修改正确

37:19.390 --> 37:21.390
好那么现在就做出来了

37:21.390 --> 37:22.390
整个效果

37:22.390 --> 37:23.390
再试一下

37:23.390 --> 37:25.390
其实是一样的

37:25.390 --> 37:29.390
好这就是ts和sets

37:29.390 --> 37:31.390
该如何来结合使用

37:31.390 --> 37:33.390
大家无论是开发内组件

37:33.390 --> 37:35.390
还是开发一个函数组件

37:35.390 --> 37:36.390
我们现在都学会了

37:36.390 --> 37:37.390
其他的地方

37:37.390 --> 37:38.390
大部分给我们以前的介石

37:38.390 --> 37:39.390
没有什么差别了

37:39.390 --> 37:41.390
就是多了一个内形检查

37:41.390 --> 37:42.390
好了有了这些知识过后

37:42.390 --> 37:44.390
接下来我们就来一步一步

37:44.390 --> 37:46.390
去完成整个项目了

