WEBVTT

00:00.750 --> 00:03.750
大家好 我是杜亦教育微博前装奖师袁晋

00:03.750 --> 00:08.750
OK 咱们这节课就终于到了基础部分的项目实战了

00:08.750 --> 00:12.750
我们做这个项目是做一个仅自取的这么一个小游戏

00:12.750 --> 00:15.750
就是先把一个三层一三的格子

00:15.750 --> 00:19.750
然后格子里面可以放各种旗子

00:19.750 --> 00:21.750
先放一个黑子 然后再放一个红子

00:21.750 --> 00:24.750
那么模拟了对战的两方

00:24.750 --> 00:26.750
当然这是个单机应用程序

00:26.750 --> 00:30.750
就是说是在同一台计算机上两个人在玩

00:30.750 --> 00:33.750
而不是分开到两台计算机

00:33.750 --> 00:35.750
两台计算机的话会用到web socket

00:35.750 --> 00:39.750
那么我们这门客讲的不是web socket

00:39.750 --> 00:42.750
讲的是ts ts配合react来使用

00:42.750 --> 00:46.750
所以说这里我们就在同一台计算机上来进行演示就行了

00:46.750 --> 00:48.750
然后分别来过纸

00:48.750 --> 00:50.750
什么情况下算赢呢

00:50.750 --> 00:52.750
就是说某一个纸

00:52.750 --> 00:54.750
某一个纸它是横向的中向的

00:54.750 --> 00:57.750
或者是斜线上连成了一片

00:57.750 --> 00:59.750
连成了三个纸

00:59.750 --> 01:00.750
那么就算胜利

01:00.750 --> 01:02.750
那么胜利之后就不能再点击了

01:02.750 --> 01:04.750
你看看没不能再点击了

01:04.750 --> 01:06.750
可以点击这里头重新开始这个按钮

01:06.750 --> 01:08.750
重新开始个游戏

01:08.750 --> 01:11.750
比方说再来一个中向的

01:11.750 --> 01:13.750
OK 胜利

01:13.750 --> 01:14.750
黑方胜利

01:14.750 --> 01:15.750
不能再点击了

01:15.750 --> 01:18.750
有可能这里面还会出现评举

01:18.750 --> 01:20.750
就这种情况

01:20.750 --> 01:22.750
这里点一个

01:22.750 --> 01:24.750
然后这里点一个

01:24.750 --> 01:26.750
这里点一个

01:26.750 --> 01:28.750
这种情况就是评举

01:28.750 --> 01:30.750
评举的话也是不能再击击游戏了

01:30.750 --> 01:34.750
OK 这就是我们整个游戏的一个效果

01:34.750 --> 01:36.750
我们做这个效果出来的话

01:36.750 --> 01:40.750
使用的技术是使用的是react

01:40.750 --> 01:43.750
加上type script

01:43.750 --> 01:45.750
我们之前学习过react

01:45.750 --> 01:48.750
当时是用原生的介石代码来写的

01:48.750 --> 01:50.750
用介石语法来写的

01:50.750 --> 01:52.750
那么我们既然学习了type script

01:52.750 --> 01:54.750
学习了TS个语言

01:54.750 --> 01:58.750
我们看一下TS个语言怎么去跟react来进行结合

01:58.750 --> 02:01.750
其实在做这个结合的过程中

02:01.750 --> 02:03.750
我们有两种做法

02:03.750 --> 02:05.750
就是工程的搭建

02:05.750 --> 02:07.750
工程如何搭建

02:07.750 --> 02:09.750
这个问题我们其实有两种做法

02:09.750 --> 02:11.750
第一种做法是使用webpack

02:11.750 --> 02:13.750
我们自己手动来进行搭建

02:13.750 --> 02:15.750
当然这种搭建方式要复杂一些

02:15.750 --> 02:18.750
因为webpack有非常深入的了解

02:18.750 --> 02:21.750
我们后边也会有相关的webpack的课程

02:21.750 --> 02:23.750
大家可以立即的保持关注

02:23.750 --> 02:25.750
但是我们在基础部分

02:25.750 --> 02:29.750
这一块我们不会过多的把精力分成到这里

02:29.750 --> 02:30.750
这一部分

02:30.750 --> 02:32.750
因此我们这种做法

02:32.750 --> 02:35.750
这种做法我们在这节课里面不涉及到

02:35.750 --> 02:37.750
在进节部分的时候我会讲一讲

02:37.750 --> 02:39.750
如果你使用webpack手动去

02:39.750 --> 02:42.750
搭建一个构建工程的话

02:42.750 --> 02:44.750
我们是如何去把TypeScript手动入进来

02:44.750 --> 02:46.750
我们之前在贴使搭建贴使的环境

02:46.750 --> 02:48.750
都是在load的环境里面

02:48.750 --> 02:49.750
在浏览器环境里面

02:49.750 --> 02:52.750
你需要去配合webpack来进行搭建工程

02:52.750 --> 02:54.750
那么这一部分我们先不涉及

02:54.750 --> 02:56.750
因为这个过程有点繁琐

02:56.750 --> 02:57.750
东西有点多

02:57.750 --> 02:59.750
还涉及到很多的webpack的知识

02:59.750 --> 03:00.750
我们现在注意力

03:00.750 --> 03:02.750
我们这里头主要是学习的是

03:02.750 --> 03:03.750
语言本身

03:03.750 --> 03:05.750
如何跟reacts这个语言

03:05.750 --> 03:07.750
跟reacts这个框架

03:07.750 --> 03:08.750
如何来进行结合

03:08.750 --> 03:11.750
所以说我们不用把注意力分散太多

03:11.750 --> 03:13.750
我们使用第二种打点方式

03:13.750 --> 03:15.750
就是使用搅手架

03:15.750 --> 03:17.750
搅手架的话reacts里面

03:17.750 --> 03:19.750
其实也有非常非常多了

03:19.750 --> 03:21.750
什么diva

03:21.750 --> 03:23.750
这些第三方的搅手架

03:23.750 --> 03:25.750
什么5米解释

03:25.750 --> 03:26.750
这些都是搅手架

03:26.750 --> 03:29.750
包括浮端圈的next解释

03:29.750 --> 03:31.750
它也是一个reacts的搅手架

03:31.750 --> 03:34.750
只不过这些搅手架都不是官方的

03:34.750 --> 03:36.750
他们能不能支持ts呢

03:36.750 --> 03:39.750
有些能有些需要你自己手动构建一下

03:39.750 --> 03:41.750
所以说我们这里直接使用

03:41.750 --> 03:43.750
而官方的搅手架

03:43.750 --> 03:47.750
跟官方的搅手架是createreacts

03:47.750 --> 03:48.750
是这个搅手架

03:48.750 --> 03:52.750
而这个搅手架是天生就支持ts的

03:52.750 --> 03:53.750
稍微做一下

03:53.750 --> 03:54.750
用这个命令的时候

03:54.750 --> 03:55.750
稍微做一下配置

03:55.750 --> 03:57.750
就可以支持ts

03:57.750 --> 03:58.750
因此我们这一刻

03:58.750 --> 04:01.750
使用官方的搅手架来搭建工程

04:01.750 --> 04:02.750
怎么搭建呢

04:02.750 --> 04:05.750
我们可以去访问一下它的网站

04:05.750 --> 04:07.750
网站叫github上面

04:07.750 --> 04:09.750
进入github的官网

04:09.750 --> 04:12.750
你可以到github上面去搜索一下

04:12.750 --> 04:14.750
createreactsapp

04:14.750 --> 04:16.750
去搜索一下就行了

04:16.750 --> 04:18.750
搜索一下出来过后

04:18.750 --> 04:21.750
就这个facebook开发的这个搅手架reacts

04:21.750 --> 04:23.750
createreactsapp

04:23.750 --> 04:24.750
进去

04:24.750 --> 04:26.750
这里面有很多的说明

04:26.750 --> 04:27.750
在这里

04:27.750 --> 04:28.750
这里有一些文档

04:28.750 --> 04:29.750
我们点进去

04:29.750 --> 04:30.750
文档说明

04:30.750 --> 04:32.750
这里有一个docs文档

04:32.750 --> 04:34.750
它里面说到了很多地方

04:34.750 --> 04:37.750
说如何去跟CSS module来配合使用

04:37.750 --> 04:40.750
如何去跟rotor来配合使用

04:40.750 --> 04:43.750
这个搅手架怎么去搭建一个初始的环境

04:43.750 --> 04:47.750
包括如何加上CSS reset

04:47.750 --> 04:49.750
就是重置代码等等

04:49.750 --> 04:50.750
里面有很多

04:50.750 --> 04:52.750
这个搅手架的功能非常丰富

04:52.750 --> 04:54.750
我们在这里面去搜索一下

04:54.750 --> 04:56.750
type script

04:56.750 --> 04:57.750
说的

04:57.750 --> 04:59.750
那么就可以看到这里有个文档

04:59.750 --> 05:00.750
它说了

05:00.750 --> 05:03.750
这个搅手架如何添加对ts的支持

05:03.750 --> 05:04.750
去看一下

05:04.750 --> 05:05.750
非常简单

05:05.750 --> 05:07.750
它这里说到了

05:07.750 --> 05:08.750
全英文无所谓

05:08.750 --> 05:10.750
就看一下它的命令就行了

05:10.750 --> 05:12.750
这里说到这么个命令

05:12.750 --> 05:13.750
我们搭建搅手架的时候

05:13.750 --> 05:15.750
使用createreactsapp

05:15.750 --> 05:18.750
然后写上我们的工程的名称

05:18.750 --> 05:19.750
加上一个参数

05:19.750 --> 05:20.750
两个横杠

05:20.750 --> 05:22.750
写上type script就行了

05:22.750 --> 05:25.750
这里的方式是使用的是npx

05:25.750 --> 05:27.750
如果你安装了压的话

05:27.750 --> 05:29.750
你可以使用压都可以

05:29.750 --> 05:30.750
为什么要使用这两个呢

05:30.750 --> 05:32.750
如果你不是选举安装

05:32.750 --> 05:33.750
这个createreactsapp

05:33.750 --> 05:35.750
你不是全举安装的话

05:35.750 --> 05:37.750
可以使用这个命令npx

05:37.750 --> 05:38.750
如果你是全举安装

05:38.750 --> 05:40.750
比方说我这里就是全举安装的

05:40.750 --> 05:41.750
这个搅手架

05:41.750 --> 05:43.750
因此我可以直接使用这个命令

05:43.750 --> 05:44.750
也是可以的

05:44.750 --> 05:45.750
没有任何问题

05:45.750 --> 05:46.750
咱们使用吧

05:46.750 --> 05:48.750
使用这个方式来搭建

05:48.750 --> 05:54.750
我这里使用createreactsapp

05:54.750 --> 05:56.750
当然你要找好一个目录

05:56.750 --> 05:57.750
找好前面的一个目录

05:57.750 --> 05:58.750
空格

05:58.750 --> 05:59.750
后面先来工程名称

05:59.750 --> 06:00.750
工程名称的话

06:00.750 --> 06:01.750
我就使用这个名称

06:01.750 --> 06:04.750
tsreact

06:04.750 --> 06:05.750
空格

06:05.750 --> 06:06.750
game

06:06.750 --> 06:07.750
好

06:07.750 --> 06:08.750
后面要加上两个参数

06:08.750 --> 06:10.750
type script

06:10.750 --> 06:11.750
回车

06:11.750 --> 06:12.750
OK

06:12.750 --> 06:13.750
就让它懂得让它搭建吧

06:13.750 --> 06:14.750
让它搭建

06:14.750 --> 06:15.750
好

06:15.750 --> 06:16.750
这里呢

06:16.750 --> 06:17.750
它搭建的过程中

06:17.750 --> 06:18.750
我们来说明一下

06:18.750 --> 06:20.750
就说我们

06:20.750 --> 06:22.750
我们使用的这个

06:22.750 --> 06:24.750
搅手架搭建的工程

06:24.750 --> 06:25.750
createreactsapp

06:25.750 --> 06:26.750
搭建的工程

06:26.750 --> 06:29.750
我们在开发的过程中

06:29.750 --> 06:31.750
一定要使用tsreact

06:31.750 --> 06:32.750
是不是一定要使用

06:32.750 --> 06:33.750
type script

06:33.750 --> 06:34.750
不一定的

06:34.750 --> 06:35.750
不一定的

06:35.750 --> 06:37.750
这是咱们之前反复强调过的

06:37.750 --> 06:40.750
type script是一个始终技术

06:40.750 --> 06:42.750
它是一个可选的

06:42.750 --> 06:45.750
精态的类型系统

06:45.750 --> 06:46.750
因此

06:46.750 --> 06:47.750
它既然是可选的

06:47.750 --> 06:49.750
我们完全可以

06:49.750 --> 06:51.750
不使用它里面的任何功能

06:51.750 --> 06:52.750
就以前杂写

06:52.750 --> 06:53.750
现在杂写

06:53.750 --> 06:54.750
你说这个游戏

06:54.750 --> 06:55.750
能不能用解释做出来

06:55.750 --> 06:56.750
能不能用解释做出来

06:56.750 --> 06:58.750
肯定是没有任何问题的

06:58.750 --> 06:59.750
用解释就可以开发

06:59.750 --> 07:01.750
但是加上tsreact

07:01.750 --> 07:03.750
这个类型检查系统过后

07:03.750 --> 07:05.750
我们可以得到更多的类型检查

07:05.750 --> 07:07.750
更加不容易出错

07:07.750 --> 07:09.750
可以大量的减少我们

07:09.750 --> 07:11.750
出错的几率

07:11.750 --> 07:13.750
而降低我们开发的成本

07:13.750 --> 07:15.750
调色时间降低了

07:15.750 --> 07:16.750
所以开发成本降低了

07:16.750 --> 07:17.750
因此

07:17.750 --> 07:19.750
可以结合tsreact

07:19.750 --> 07:20.750
但不是说

07:20.750 --> 07:21.750
一定必须要使用tsreact

07:21.750 --> 07:23.750
我把这个地方反复强调一下

07:23.750 --> 07:24.750
它是个可选的

07:24.750 --> 07:25.750
因此

07:25.750 --> 07:27.750
咱们在学习tsreact的时候

07:27.750 --> 07:28.750
反复的说

07:28.750 --> 07:30.750
大家不要有什么心理压力

07:30.750 --> 07:31.750
你写代码的时候

07:31.750 --> 07:32.750
以前杂写

07:32.750 --> 07:33.750
现在就杂写

07:33.750 --> 07:34.750
没有任何问题

07:34.750 --> 07:36.750
那么你写的时候

07:36.750 --> 07:37.750
你可以给它加上

07:37.750 --> 07:39.750
你觉得合适的位置

07:39.750 --> 07:41.750
给它加上一些类型检查

07:41.750 --> 07:42.750
你会发现

07:42.750 --> 07:43.750
代码就输写起来

07:43.750 --> 07:44.750
输过很多

07:44.750 --> 07:45.750
就是有些同学学习tsreact

07:45.750 --> 07:47.750
就是星期非常非常沉重

07:47.750 --> 07:48.750
他老是想

07:48.750 --> 07:49.750
把每一个位置

07:49.750 --> 07:50.750
全部加上类型检查

07:50.750 --> 07:52.750
而他的能力又打不到

07:52.750 --> 07:54.750
因此发挥了很多的时间

07:54.750 --> 07:56.750
再去类型检查上面

07:56.750 --> 07:57.750
然后得不尝试

07:57.750 --> 07:58.750
咱们学习tsreact

07:58.750 --> 07:59.750
是在帮助我们解决问题的

07:59.750 --> 08:01.750
而不是在给我们制造麻烦的

08:01.750 --> 08:02.750
我建议

08:02.750 --> 08:05.750
我个人建议大家的学习方法是

08:05.750 --> 08:07.750
就是你理解的地方

08:07.750 --> 08:09.750
你能够理解的地方

08:09.750 --> 08:10.750
或者是你觉得

08:10.750 --> 08:11.750
这一块我加上类型检查

08:11.750 --> 08:12.750
我自己能加

08:12.750 --> 08:14.750
我这一块已经很熟悉了

08:14.750 --> 08:15.750
我给它加上类型检查

08:15.750 --> 08:17.750
那么可以防止我们

08:17.750 --> 08:19.750
后边一些地方的出问题

08:19.750 --> 08:20.750
出错

08:20.750 --> 08:21.750
如果后边

08:21.750 --> 08:22.750
我这种方式做的

08:22.750 --> 08:23.750
用了很熟了

08:23.750 --> 08:24.750
过后

08:24.750 --> 08:26.750
有一些类型检查

08:26.750 --> 08:27.750
有一些比较特殊的地方

08:27.750 --> 08:28.750
加上类型检查

08:28.750 --> 08:30.750
我可以学习一下

08:30.750 --> 08:31.750
学习一下

08:31.750 --> 08:32.750
某些特殊的地方

08:32.750 --> 08:33.750
怎么去加类型检查

08:33.750 --> 08:34.750
学习了之后

08:34.750 --> 08:35.750
我又尝试在这些地方

08:35.750 --> 08:36.750
去加上类型检查

08:36.750 --> 08:38.750
这是一种渐进式的方案

08:38.750 --> 08:39.750
而不是说

08:39.750 --> 08:41.750
写一个工程的时候

08:41.750 --> 08:43.750
我自己都没有把ts搞清楚

08:43.750 --> 08:45.750
需要在他每一个地方

08:45.750 --> 08:46.750
所谓的细致末节

08:46.750 --> 08:47.750
计较高拉

08:47.750 --> 08:48.750
全部要加上类型检查

08:48.750 --> 08:49.750
耗费大量的时间

08:49.750 --> 08:50.750
其实没有必要的

08:50.750 --> 08:53.750
ts设计的初衷是为了解决

08:53.750 --> 08:55.750
是为了降低我们的麻烦的

08:55.750 --> 08:56.750
减少我们的麻烦

08:56.750 --> 08:57.750
而不是给我们制造麻烦的

08:57.750 --> 08:58.750
所以大家学习这一块

08:58.750 --> 09:01.750
学习ts真的不要有任何的心理压力

09:01.750 --> 09:03.750
当然我们讲课的时候

09:03.750 --> 09:05.750
肯定是面对各种情况

09:05.750 --> 09:07.750
要把各种类型检查加上

09:07.750 --> 09:09.750
我们看一下大家好了没有

09:09.750 --> 09:11.750
OK 大家好了

09:11.750 --> 09:12.750
大家好了之后

09:12.750 --> 09:14.750
咱们到文件夹里边去

09:14.750 --> 09:15.750
就在这里输入命令

09:15.750 --> 09:17.750
我们清楚一下

09:17.750 --> 09:18.750
输入命令

09:18.750 --> 09:19.750
输入code

09:19.750 --> 09:20.750
我们用vscode

09:20.750 --> 09:22.750
把文件夹打开

09:22.750 --> 09:27.750
打开的目录是tsrex

09:27.750 --> 09:29.750
就是这个目录

09:29.750 --> 09:30.750
OK

09:30.750 --> 09:32.750
用vscode打开

09:32.750 --> 09:33.750
打开过后

09:33.750 --> 09:35.750
咱们先把它运行出来吧

09:35.750 --> 09:38.750
运行出来

09:38.750 --> 09:41.750
这里我们用npm start

09:41.750 --> 09:43.750
把这个工程启动

09:43.750 --> 09:44.750
跟以前是一样的

09:44.750 --> 09:45.750
一样的

09:45.750 --> 09:46.750
没有多少的差异

09:46.750 --> 09:49.750
把它启动起来

09:49.750 --> 09:51.750
看一下这个工程

09:51.750 --> 09:52.750
稍微等待一下

09:52.750 --> 09:53.750
它第一次夹展

09:53.750 --> 09:54.750
需要有点慢

09:54.750 --> 09:57.750
因为它有一个编印的过程

09:57.750 --> 09:59.750
我们其实看这个工程结构

09:59.750 --> 10:00.750
其实跟我们以前是差不多的

10:00.750 --> 10:01.750
对不对

10:01.750 --> 10:02.750
都多了一个配置文件

10:02.750 --> 10:06.190
tsconfig

10:06.190 --> 10:07.190
OK

10:07.190 --> 10:09.190
这个界面是不是很熟悉

10:09.190 --> 10:11.190
你们以前学习react的时候

10:11.190 --> 10:12.190
使用这个角色下

10:12.190 --> 10:14.190
搭建的工程就是这个界面

10:14.190 --> 10:15.190
这个界面你们提到了

10:15.190 --> 10:16.190
有一个地方有点改变

10:16.190 --> 10:18.190
提到了这里

10:18.190 --> 10:20.190
就是他说让你去编辑

10:20.190 --> 10:22.190
src目录下面的app

10:22.190 --> 10:24.190
app.tsx

10:24.190 --> 10:25.190
这个文件

10:25.190 --> 10:26.190
以前是啥文件

10:26.190 --> 10:28.190
以前是js这个文件

10:28.190 --> 10:30.190
现在变成了tsx

10:30.190 --> 10:32.190
让你去编辑这个文件

10:32.190 --> 10:33.190
也就是说

10:33.190 --> 10:34.190
我们看一下

10:34.190 --> 10:35.190
src目录下边的

10:35.190 --> 10:36.190
你看

10:36.190 --> 10:37.190
这些js文件

10:37.190 --> 10:38.190
全部变成了啥呢

10:38.190 --> 10:40.190
变成了tsx

10:40.190 --> 10:42.190
tsx

10:42.190 --> 10:44.190
变成了这种文件

10:44.190 --> 10:45.190
但是里面写的代码

10:45.190 --> 10:46.190
你会发现

10:46.190 --> 10:47.190
绝大部分代码

10:47.190 --> 10:48.190
都是我们熟悉的js代码

10:48.190 --> 10:49.190
再一次说明了

10:49.190 --> 10:51.190
ts是js的超级

10:51.190 --> 10:54.190
它里面完全支持js代码

10:54.190 --> 10:55.190
现在文件后续明编了

10:55.190 --> 10:56.190
说明这些文件里面

10:56.190 --> 10:58.190
是可以加上类型检查的

10:58.190 --> 11:01.190
是可以去书写ts代码的

11:01.190 --> 11:02.190
好

11:02.190 --> 11:03.190
我们首先来对这个工程

11:03.190 --> 11:04.190
做一个描述

11:04.190 --> 11:05.190
在工程里面

11:05.190 --> 11:07.190
其实没有多少型东西

11:07.190 --> 11:08.190
首先看这个文件

11:08.190 --> 11:09.190
tsconfig

11:09.190 --> 11:11.190
这是ts的

11:11.190 --> 11:13.190
编译配置文件

11:13.190 --> 11:14.190
是ts的配置文件

11:14.190 --> 11:15.190
我先来解释一下

11:15.190 --> 11:17.190
这个文件里面写了哪些东西

11:17.190 --> 11:19.190
首先这里面写了两个配置

11:19.190 --> 11:21.190
一个是编译选项

11:21.190 --> 11:23.190
一个是咱们包含的目录

11:23.190 --> 11:24.190
好,我们看先看这个吧

11:24.190 --> 11:25.190
include

11:25.190 --> 11:27.190
表示我们包含了目录

11:27.190 --> 11:28.190
这个大家都知道

11:28.190 --> 11:30.190
我们之前在配置ts的

11:30.190 --> 11:31.190
load开发环境的时候

11:31.190 --> 11:32.190
也说过

11:32.190 --> 11:33.190
这个表示的是什么意思呢

11:33.190 --> 11:34.190
表示的是

11:34.190 --> 11:35.190
我们代码

11:35.190 --> 11:37.190
是放到哪个目录下面的

11:37.190 --> 11:38.190
哪个目录呢

11:38.190 --> 11:39.190
放到src目录下面的

11:39.190 --> 11:41.190
就是外边的其他的文件

11:41.190 --> 11:42.190
其他的目录

11:42.190 --> 11:43.190
我们不用看了

11:43.190 --> 11:45.190
让ts只去处理

11:45.190 --> 11:47.190
src这个目录下面的

11:47.190 --> 11:48.190
ts代码

11:48.190 --> 11:49.190
要进行编译

11:49.190 --> 11:51.190
好,这是这个配置的意思

11:51.190 --> 11:53.190
ok,那这里面的编译选项呢

11:53.190 --> 11:55.190
就在编译过程中

11:55.190 --> 11:56.190
有一些配置呢

11:56.190 --> 11:57.190
这里面配置就很多了

11:57.190 --> 11:58.190
我们挨着来解释

11:58.190 --> 11:59.190
就是很多配置呢

11:59.190 --> 12:01.190
我们以前也学习过

12:01.190 --> 12:03.190
首先是这个

12:03.190 --> 12:04.190
talkit

12:04.190 --> 12:05.190
这个配置

12:05.190 --> 12:06.190
这个配置呢

12:06.190 --> 12:07.190
我们都知道

12:07.190 --> 12:08.190
它配置的是什么呢

12:08.190 --> 12:09.190
配置的是

12:09.190 --> 12:11.190
你ts要进行编译

12:11.190 --> 12:13.190
编译成最终的gs代码

12:13.190 --> 12:15.190
这个gs代码使用的是哪一套

12:15.190 --> 12:16.190
标准

12:16.190 --> 12:17.190
它这里使用的是s5

12:17.190 --> 12:19.190
s5的话基本上

12:19.190 --> 12:21.190
99.9%

12:21.190 --> 12:22.190
浏览器

12:22.190 --> 12:23.190
目前市面上的浏览器

12:23.190 --> 12:24.190
都是能支持的

12:24.190 --> 12:27.190
就让它变成s5这个代码

12:27.190 --> 12:29.190
下边是一个酷环境

12:29.190 --> 12:31.190
酷环境叫NAP

12:31.190 --> 12:32.190
酷环境呢

12:32.190 --> 12:33.190
我们以前也解释过

12:33.190 --> 12:34.190
因为ts呢

12:34.190 --> 12:35.190
它不知道

12:35.190 --> 12:36.190
我们这些ts代码

12:36.190 --> 12:38.190
它运行在哪个环境里边

12:38.190 --> 12:39.190
它是不知道的

12:39.190 --> 12:40.190
它默认环境呢

12:40.190 --> 12:41.190
是一个动物环境

12:41.190 --> 12:43.190
那么这个地方是可以配置的

12:43.190 --> 12:45.190
就是咱们以前呢

12:45.190 --> 12:47.190
一起漏的环境搭建的时候

12:47.190 --> 12:48.190
对不对

12:48.190 --> 12:50.190
我们这个地方只配置了一个啥

12:50.190 --> 12:52.190
当时我们是只配置了一个

12:52.190 --> 12:55.190
ES2016

12:55.190 --> 12:56.190
对不对

12:56.190 --> 12:57.190
配置了这么一个环境

12:57.190 --> 12:58.190
那就把那个动物环境

12:58.190 --> 12:59.190
给它取消掉了

12:59.190 --> 13:01.190
取消掉动物环境过后

13:01.190 --> 13:02.190
如果你取消掉动物环境过后

13:02.190 --> 13:03.190
你会发现

13:03.190 --> 13:04.190
这一代码里边

13:04.190 --> 13:05.190
像这个document

13:05.190 --> 13:06.190
不能用了

13:06.190 --> 13:07.190
因为它现在不是

13:07.190 --> 13:08.190
浏览器环境的

13:08.190 --> 13:09.190
就不能使用这个document

13:09.190 --> 13:10.190
上什么window

13:10.190 --> 13:11.190
也不能用了

13:11.190 --> 13:12.190
也不能用了

13:12.190 --> 13:14.190
但是由于我们目前

13:14.190 --> 13:16.190
这是处于浏览器环境的

13:16.190 --> 13:18.190
需要在浏览器环境里边

13:18.190 --> 13:20.190
去应用这些代码

13:20.190 --> 13:21.190
因此现在

13:21.190 --> 13:23.190
它把document这个环境给加上了

13:23.190 --> 13:25.190
document这个环境加上了

13:25.190 --> 13:26.190
好 下一个

13:26.190 --> 13:28.190
下一个环境是document

13:28.190 --> 13:30.190
atorable

13:30.190 --> 13:31.190
这个是什么意思呢

13:31.190 --> 13:33.190
我这里要解释一下

13:33.190 --> 13:35.190
这里涉及到一个知识点

13:35.190 --> 13:36.190
什么知识点呢

13:36.190 --> 13:38.190
大家知不知道这个东西

13:38.190 --> 13:39.190
你知不知道

13:39.190 --> 13:41.190
我也听不到你说话

13:41.190 --> 13:42.190
symbol

13:42.190 --> 13:43.190
知不知道这个东西

13:43.190 --> 13:45.190
好像在讲那个内德时候

13:45.190 --> 13:47.190
讲它的私有成员的时候

13:47.190 --> 13:48.190
说到过这个东西

13:48.190 --> 13:50.190
这个东西在ES6里边出现的

13:50.190 --> 13:52.190
它是ES6里面的东西

13:54.190 --> 13:55.190
ES6

13:55.190 --> 13:57.190
它是ES6里面的

13:57.190 --> 13:59.190
一个出现的一个新的概念

13:59.190 --> 14:01.190
symbol 叫做符号

14:01.190 --> 14:03.190
它用来做什么呢

14:03.190 --> 14:05.190
它用来做一个

14:05.190 --> 14:06.190
可以做私有

14:06.190 --> 14:08.190
可以做一些内德私有成员

14:08.190 --> 14:09.190
它可以做这么一件事

14:09.190 --> 14:10.190
如果你对这个东西

14:10.190 --> 14:11.190
不太熟悉的话

14:11.190 --> 14:12.190
不太熟悉的话

14:12.190 --> 14:13.190
可以去网上

14:13.190 --> 14:15.190
找一下相关的文章

14:15.190 --> 14:16.190
它也不难

14:17.190 --> 14:19.190
那么这个symbol的符号

14:19.190 --> 14:20.190
它有很多的用处

14:20.190 --> 14:22.190
它可以做私有成员

14:22.190 --> 14:24.190
还可以实现一些

14:24.190 --> 14:25.190
特别的效果

14:25.190 --> 14:26.190
在ES6里面

14:26.190 --> 14:28.190
它提出了这么一个概念

14:28.190 --> 14:29.190
叫做迭代器

14:30.190 --> 14:31.190
迭代器

14:31.190 --> 14:32.190
如果你对迭代器

14:32.190 --> 14:33.190
也不了解的话

14:33.190 --> 14:34.190
可以去网上

14:34.190 --> 14:35.190
看一下相关的文章

14:35.190 --> 14:36.190
但是你不知道

14:36.190 --> 14:37.190
这些信息

14:37.190 --> 14:38.190
也没事

14:39.190 --> 14:40.190
我们这里把它

14:40.190 --> 14:41.190
大开的解释一下

14:41.190 --> 14:43.190
这个配置到底在干嘛

14:43.190 --> 14:44.190
我先说一下

14:44.190 --> 14:45.190
ES6里面

14:45.190 --> 14:46.190
它出现了两个东西

14:46.190 --> 14:47.190
一个是symbol符号

14:47.190 --> 14:49.190
一个是迭代器

14:49.190 --> 14:50.190
而迭代器

14:50.190 --> 14:51.190
表示什么意思呢

14:51.190 --> 14:52.190
表示

14:53.190 --> 14:54.190
该数据

14:54.190 --> 14:57.190
是可以循环的

14:57.190 --> 14:59.190
是可以被循环的

14:59.190 --> 15:01.190
以前什么东西

15:01.190 --> 15:02.190
可以被循环呢

15:02.190 --> 15:03.190
可以

15:03.190 --> 15:04.190
就是比方说

15:04.190 --> 15:05.190
素主可以循环

15:05.190 --> 15:06.190
对吧

15:06.190 --> 15:07.190
字无创

15:07.190 --> 15:08.190
也可以被循环

15:08.190 --> 15:09.190
那么其他东西

15:09.190 --> 15:10.190
能不能循环呢

15:10.190 --> 15:12.190
这里说的循环

15:12.190 --> 15:14.190
指的是for25循环

15:14.190 --> 15:16.190
指的是for25循环

15:16.190 --> 15:18.190
不是指的是for循环

15:18.190 --> 15:19.190
for循环的话

15:19.190 --> 15:20.190
你不需要素主

15:20.190 --> 15:21.190
就一个变量

15:21.190 --> 15:23.190
i从0开始到10

15:23.190 --> 15:24.190
也可以循环

15:24.190 --> 15:25.190
对不对

15:25.190 --> 15:26.190
我们这里说的是for25循环

15:26.190 --> 15:27.190
就是说

15:27.190 --> 15:28.190
把素主里面

15:28.190 --> 15:29.190
每一项单独拿出来

15:29.190 --> 15:30.190
一个个看

15:30.190 --> 15:31.190
像这种循环

15:32.190 --> 15:33.190
for25

15:33.190 --> 15:34.190
这种循环

15:34.190 --> 15:35.190
我们这里说的循环

15:35.190 --> 15:36.190
是for25循环

15:36.190 --> 15:38.190
迭代器的意思表示

15:38.190 --> 15:39.190
如果一个东西

15:39.190 --> 15:41.190
比方说一个东西

15:41.190 --> 15:43.190
它有具备迭代器的功能

15:43.190 --> 15:44.190
那么这个东西

15:44.190 --> 15:46.190
是可以被for25循环的

15:46.190 --> 15:48.190
只要这个东西具有迭代器

15:48.190 --> 15:49.190
那么它就可以

15:49.190 --> 15:50.190
被for25循环

15:50.190 --> 15:51.190
是这么一个意思

15:51.190 --> 15:52.190
这么一个意思

15:52.190 --> 15:53.190
那么怎么来

15:53.190 --> 15:55.190
实现一个迭代器呢

15:55.190 --> 15:57.190
实现迭代器的方式

15:57.190 --> 15:58.190
也就是说

15:58.190 --> 15:59.190
现在迭代器这个东西

15:59.190 --> 16:00.190
它不一定是素主

16:00.190 --> 16:01.190
它不一定是素主

16:01.190 --> 16:02.190
任何东西

16:02.190 --> 16:03.190
只要它

16:03.190 --> 16:04.190
是一个

16:04.190 --> 16:05.190
它里面有迭代器

16:05.190 --> 16:07.190
它就可以使用for25循环

16:07.190 --> 16:08.190
来循环它

16:08.190 --> 16:09.190
大概了解一下就行了

16:09.190 --> 16:11.190
关于什么是迭代器

16:11.190 --> 16:12.190
关于什么是符号

16:12.190 --> 16:13.190
你们可以去

16:13.190 --> 16:15.190
采约一下相关的文章

16:15.190 --> 16:17.190
我这里大概了解一下就行了

16:17.190 --> 16:18.190
一个东西

16:18.190 --> 16:19.190
不一定是素主

16:19.190 --> 16:21.190
它只要具有迭代器

16:21.190 --> 16:23.190
就可以使用for25循环

16:24.190 --> 16:25.190
那么迭代器

16:25.190 --> 16:27.190
是怎么做出来的呢

16:27.190 --> 16:29.190
你要制作一个迭代器的话

16:29.190 --> 16:31.190
制作迭代器

16:31.190 --> 16:34.190
迭代器必须使用

16:35.190 --> 16:36.190
simple

16:36.190 --> 16:40.190
必须使用simple.atorator

16:40.190 --> 16:42.190
你甭问这个东西是啥吗

16:42.190 --> 16:44.190
总之要用到符号的东西

16:44.190 --> 16:46.190
总之要用到它

16:46.190 --> 16:47.190
而且这个符号里面

16:47.190 --> 16:49.190
有个特殊的符号叫atorator

16:49.190 --> 16:51.190
表示的是一个迭代器符号

16:51.190 --> 16:52.190
你甭问它是啥

16:52.190 --> 16:54.190
只要一个东西里边

16:54.190 --> 16:57.190
它包含了simple.atorator

16:57.190 --> 16:58.190
就表示的是

16:58.190 --> 17:00.190
这个东西是一个迭代器

17:00.190 --> 17:03.190
这个东西可以使用for25循环

17:03.190 --> 17:06.190
那么这里的配置是什么意思呢

17:06.190 --> 17:08.190
我这里要说明一下

17:08.190 --> 17:10.190
迭代器这个概念

17:10.190 --> 17:12.190
是es6里面出来的概念

17:12.190 --> 17:14.190
而一些老的浏览器里边

17:14.190 --> 17:16.190
比较旧版本的浏览器里边

17:16.190 --> 17:19.190
在es62015年之前的一些浏览器

17:19.190 --> 17:21.190
它们是没有这个东西的

17:21.190 --> 17:23.190
没有这个概念的

17:23.190 --> 17:25.190
因此就导致了一个问题

17:25.190 --> 17:27.190
在es6里边

17:27.190 --> 17:29.190
我们通过这么一个东西

17:29.190 --> 17:32.190
document query selector

17:33.190 --> 17:34.190
得到一个

17:34.190 --> 17:36.190
或者是通过这个

17:36.190 --> 17:40.190
通过get element by tag name

17:40.190 --> 17:42.190
比方说

17:42.190 --> 17:44.190
我们得到一些动物元素

17:44.190 --> 17:46.190
这是个动物元素的集合

17:46.190 --> 17:47.190
对不对

17:47.190 --> 17:48.190
动物元素的集合

17:48.190 --> 17:50.190
把它保存一下

17:50.190 --> 17:51.190
doms

17:51.190 --> 17:52.190
比方说

17:52.190 --> 17:54.190
我们以前可能会得到

17:54.190 --> 17:56.190
一个动物元素的集合

17:56.190 --> 17:57.190
包括使用什么

17:57.190 --> 17:58.190
一个动物元素的求准属性

17:58.190 --> 18:00.190
也会得到一个集合

18:00.190 --> 18:01.190
那么这个集合

18:01.190 --> 18:04.190
它能不能使用for25循环呢

18:04.190 --> 18:06.190
能不能使用for25循环

18:06.190 --> 18:07.190
去循环它呢

18:07.190 --> 18:08.190
你会发现

18:08.190 --> 18:10.190
你会发现这样的循环

18:10.190 --> 18:11.190
是不行的

18:11.190 --> 18:12.190
是不行的

18:12.190 --> 18:14.190
为什么不行呢

18:14.190 --> 18:15.190
是因为以前

18:15.190 --> 18:17.190
在旧版本的浏览器里边

18:17.190 --> 18:19.190
旧版本的浏览器环境里边

18:19.190 --> 18:22.190
这个东西它不是数组

18:22.190 --> 18:24.190
它并不是一个数组

18:24.190 --> 18:26.190
所以说它这里提示了

18:26.190 --> 18:27.190
你又不是一个数组

18:27.190 --> 18:29.190
以前循环只能循环啥

18:29.190 --> 18:30.190
for25循环只能循环数组

18:30.190 --> 18:31.190
和字符串

18:31.190 --> 18:32.190
对不对

18:32.190 --> 18:33.190
你又不是一个数组

18:33.190 --> 18:35.190
又不是一个字符串

18:35.190 --> 18:37.190
那么我怎么去循环它呢

18:37.190 --> 18:39.190
你就必须要是迭代器

18:39.190 --> 18:41.190
这里再给你提示

18:41.190 --> 18:42.190
它说

18:42.190 --> 18:43.190
我也不知道它到底

18:43.190 --> 18:44.190
是不是一个迭代器

18:44.190 --> 18:46.190
你需要开启这个东西

18:46.190 --> 18:48.190
需要开启这个编译选项

18:48.190 --> 18:49.190
如果你不开启

18:49.190 --> 18:50.190
这个编译选项的话

18:50.190 --> 18:53.190
for25循环只能循环数组

18:53.190 --> 18:54.190
或者是字符串

18:54.190 --> 18:56.190
其他的都不能循环

18:56.190 --> 18:57.190
你现在

18:57.190 --> 18:58.190
这东西是伪数组

18:58.190 --> 18:59.190
它不是一个数组

18:59.190 --> 19:01.190
所以说for25循环

19:01.190 --> 19:02.190
它不会循环它

19:02.190 --> 19:04.190
它认为这个循环是不合理的

19:04.190 --> 19:06.190
因此它让你去开启这个选项

19:06.190 --> 19:08.190
把这个选项开起来

19:08.190 --> 19:10.190
这个选项要是做什么呢

19:10.190 --> 19:12.190
这个选项是说

19:12.190 --> 19:15.190
如果你开启了这个选项过后

19:15.190 --> 19:17.190
它在for25循环的时候

19:17.190 --> 19:19.190
你在进行for25循环的时候

19:19.190 --> 19:21.190
如果你不是一个数组

19:21.190 --> 19:23.190
如果你不是一个字符串

19:23.190 --> 19:25.190
但是你可能是一个迭代器

19:25.190 --> 19:27.190
就是你这个东西里边

19:27.190 --> 19:29.190
实现了一个迭代器

19:29.190 --> 19:31.190
如果你实现了迭代器的话

19:31.190 --> 19:33.190
我也允许你使用for25循环

19:33.190 --> 19:35.190
明白这个意思吗

19:35.190 --> 19:36.190
把这个选项开起

19:36.190 --> 19:38.190
那么for25循环

19:38.190 --> 19:40.190
它也可以循环迭代器了

19:40.190 --> 19:42.190
也可以循环迭代器了

19:42.190 --> 19:44.190
好 现在它之所以能够循环

19:44.190 --> 19:46.190
它说明它是一个迭代器

19:46.190 --> 19:47.190
它不是数组吗

19:47.190 --> 19:48.190
它不是字符串

19:48.190 --> 19:49.190
说明它是个迭代器

19:49.190 --> 19:51.190
那么它为什么是个迭代器呢

19:51.190 --> 19:53.190
是因为我们开启了这个选项

19:53.190 --> 19:55.190
能够绕清楚

19:55.190 --> 19:57.190
能够绕清楚这个概念

19:57.190 --> 19:59.190
因为我们开启了这个选项

19:59.190 --> 20:01.190
再开启到这个选项过后

20:01.190 --> 20:04.190
因为到了2015年之后

20:04.190 --> 20:07.190
很多流量器都已经把这个违数组

20:07.190 --> 20:09.190
加上迭代器的功能了

20:09.190 --> 20:10.190
所以说现在可以循环

20:10.190 --> 20:12.190
如果你把这个选项去掉

20:12.190 --> 20:13.190
你看一下

20:13.190 --> 20:15.190
就是一些老版本的流量器里边

20:15.190 --> 20:16.190
它这里就爆缩了

20:16.190 --> 20:18.190
因为老版本的流量器里边

20:18.190 --> 20:19.190
是没有这个东西的

20:19.190 --> 20:21.190
它这个就是一个违数组

20:21.190 --> 20:22.190
它里面有纳使

20:22.190 --> 20:23.190
有长度

20:23.190 --> 20:24.190
可以进行锁印

20:24.190 --> 20:26.190
可以用锁印来取它

20:26.190 --> 20:27.190
每一项的值

20:27.190 --> 20:28.190
但是它不是一个迭代器

20:28.190 --> 20:30.190
因此你不能使用富二五循环

20:31.190 --> 20:32.190
所以说

20:32.190 --> 20:33.190
为什么要开启这个

20:33.190 --> 20:34.190
是为了

20:34.190 --> 20:36.190
我们写代码更加的方便

20:36.190 --> 20:37.190
因为有的时候

20:37.190 --> 20:38.190
我们得到一些动物对象

20:38.190 --> 20:40.190
可能需要对它进行富二五循环

20:40.190 --> 20:41.190
那么就必须要

20:41.190 --> 20:43.190
把动物对象的迭代器环境

20:43.190 --> 20:44.190
跟它开启

20:44.190 --> 20:46.190
有些同学可能想问

20:46.190 --> 20:48.190
就是说你这里写成这个样子

20:48.190 --> 20:50.190
会不会有流量器兼容性问题

20:50.190 --> 20:52.190
那如果我要运行在2015年

20:52.190 --> 20:54.190
之前的流量器里边

20:54.190 --> 20:55.190
这么运行的

20:56.190 --> 20:57.190
不要蒙了

20:57.190 --> 20:58.190
不要蒙圈了

20:58.190 --> 21:01.190
这个地方开启的只是酷环境

21:01.190 --> 21:03.190
开启的只是酷环境

21:03.190 --> 21:04.190
是为了

21:04.190 --> 21:05.190
就是说

21:05.190 --> 21:07.190
在我们的写代码这个环境里边

21:07.190 --> 21:09.190
它是默认是什么环境

21:09.190 --> 21:10.190
我们当然希望这个环境

21:10.190 --> 21:11.190
越新越好

21:11.190 --> 21:13.190
可以使用一些新的迷法

21:13.190 --> 21:15.190
新的一些功能

21:15.190 --> 21:17.190
我们当然希望越新越好

21:17.190 --> 21:18.190
但是最终

21:18.190 --> 21:20.190
它会被编一层ES5

21:20.190 --> 21:21.190
所以说你不用担心

21:21.190 --> 21:24.190
它只会影响我们写代码的时候的写法

21:24.190 --> 21:25.190
它不会影响它编印结果

21:25.190 --> 21:27.190
编印结果还是ES5

21:27.190 --> 21:28.190
明白这个意思吗

21:28.190 --> 21:30.190
好 这是关于这两个酷环境

21:30.190 --> 21:31.190
我们是动物的环境

21:31.190 --> 21:32.190
并且呢

21:32.190 --> 21:34.190
我们得到一些动物的伪术组过后

21:34.190 --> 21:36.190
它里边已经自带迭代器功能了

21:36.190 --> 21:38.190
我们可以使用FOR不循环

21:38.190 --> 21:39.190
好 下面这个呢

21:39.190 --> 21:40.190
是ES6

21:40.190 --> 21:41.190
表示ES版本

21:41.190 --> 21:43.190
就是我们酷环境的版本

21:43.190 --> 21:45.190
就是我们写代码的时候

21:45.190 --> 21:46.190
写这个代码的时候

21:46.190 --> 21:48.190
使用的是哪一个标准

21:48.190 --> 21:50.190
使用的是哪一套ES的标准

21:50.190 --> 21:51.190
当然我们是用

21:51.190 --> 21:52.190
希望越新越好

21:52.190 --> 21:54.190
我们之前这里写的是啥呢

21:54.190 --> 21:57.190
之前这里写的是ES6

21:57.190 --> 21:58.190
ES2016对不对

21:58.190 --> 21:59.190
并且呢

21:59.190 --> 22:01.190
我们当时还把这两个东西删掉了

22:01.190 --> 22:02.190
没有这两个东西

22:02.190 --> 22:03.190
只有一个ES2016

22:03.190 --> 22:05.190
那么现在它使用的更加新的版本

22:05.190 --> 22:06.190
就是ES Next

22:06.190 --> 22:07.190
那么这里面呢

22:07.190 --> 22:08.190
我们可以使用更加

22:08.190 --> 22:10.190
一些最前面的语法

22:10.190 --> 22:12.190
它默认的配置

22:12.190 --> 22:13.190
当然你可以把这里改一下

22:13.190 --> 22:14.190
无所谓的

22:14.190 --> 22:16.190
OK 这是关于Neb的配置

22:16.190 --> 22:18.190
好 下面这个刚才讲过了

22:18.190 --> 22:20.190
是为了支持迭代器的

22:20.190 --> 22:21.190
把稍微去

22:21.190 --> 22:23.190
好 下面这个配置

22:23.190 --> 22:24.190
而到介石

22:24.190 --> 22:25.190
这个啥意思呢

22:25.190 --> 22:27.190
这个表示的是

22:27.190 --> 22:29.190
我是否允许

22:29.190 --> 22:31.190
我在TS代码里边

22:31.190 --> 22:33.190
跟介石代码进行交互

22:33.190 --> 22:34.190
就是说

22:34.190 --> 22:35.190
我们这个SRC目录下边

22:35.190 --> 22:37.190
可能写了一个介石代码

22:37.190 --> 22:39.190
比方说随便写一个吧

22:39.190 --> 22:41.190
Test.介石

22:41.190 --> 22:43.190
比方写了这么一个代码

22:43.190 --> 22:44.190
这个代码呢

22:44.190 --> 22:46.190
导出了

22:47.190 --> 22:49.190
导出一些乱七八糟的玩意

22:49.190 --> 22:50.190
导出一些东西

22:50.190 --> 22:52.190
我们是否允许

22:52.190 --> 22:54.190
在TS代码里边

22:55.190 --> 22:57.190
去导入介石

22:57.190 --> 22:59.190
是否允许这个点

23:04.190 --> 23:05.190
是否允许

23:05.190 --> 23:07.190
默认情况下

23:07.190 --> 23:09.190
是不允许的

23:09.190 --> 23:11.190
比方说你这里

23:11.190 --> 23:13.190
把它设置为Force

23:13.190 --> 23:14.190
看一下

23:15.190 --> 23:19.340
把它设置为Force

23:19.340 --> 23:21.340
你看这就爆错了

23:21.340 --> 23:23.340
刚才有点反应不过来

23:23.340 --> 23:24.340
稍微等一下

23:24.340 --> 23:25.340
它就爆错了

23:25.340 --> 23:27.340
因为它不是一个TS代码

23:27.340 --> 23:28.340
默认情况下

23:28.340 --> 23:29.340
TS只能跟TS进行交互

23:29.340 --> 23:31.340
所以说它这里爆错了

23:31.340 --> 23:33.340
因此你把这个选项开启

23:33.340 --> 23:35.340
它允许你跟介石代码进行交互

23:35.340 --> 23:37.340
但是我个人觉得

23:37.340 --> 23:39.340
你在开发TS工程的时候

23:39.340 --> 23:41.340
最好是全部都是使用TS

23:41.340 --> 23:43.340
不要去使用GS

23:43.340 --> 23:44.340
因此这个选项

23:44.340 --> 23:45.340
看你自己

23:45.340 --> 23:47.340
不要去写一些介石文件

23:47.340 --> 23:48.340
在这里面

23:48.340 --> 23:49.340
你把它开启

23:49.340 --> 23:51.340
如果你觉得你的工程

23:51.340 --> 23:52.340
全部要使用TS的话

23:52.340 --> 23:53.340
你就把这个选项去掉

23:53.340 --> 23:54.340
都无所谓

23:54.340 --> 23:56.340
OK 这是关于这个份

23:56.340 --> 23:58.340
这个配置

23:58.340 --> 24:00.340
好 下面这个配置

24:00.340 --> 24:02.340
它叫做Step Lab Check

24:02.340 --> 24:03.340
它指的是什么意思呢

24:03.340 --> 24:04.340
这个配置呢

24:04.340 --> 24:05.340
我只能先提一下

24:05.340 --> 24:06.340
没法解释现在

24:06.340 --> 24:07.340
它是说

24:07.340 --> 24:08.340
是否挑过

24:08.340 --> 24:11.340
对声明文件的类型检查

24:11.340 --> 24:12.340
是否挑过

24:12.340 --> 24:14.340
对声明文件的类型检查

24:14.340 --> 24:15.340
声明文件目前呢

24:15.340 --> 24:16.340
还没有学习

24:16.340 --> 24:17.340
我们是在境界部分

24:17.340 --> 24:18.340
学习声明文件

24:18.340 --> 24:20.340
因此这个选项了解一下

24:20.340 --> 24:21.340
怎么回事就行了

24:21.340 --> 24:23.340
是跟声明文件相关的

24:23.340 --> 24:24.340
直接略过

24:24.340 --> 24:25.340
这个配置不看

24:25.340 --> 24:26.340
这里为什么报错

24:26.340 --> 24:28.340
这个三点

24:28.340 --> 24:37.860
好 下一个

24:37.860 --> 24:39.860
这个配置是不是见过呢

24:39.860 --> 24:40.860
我们以前见模块画的时候

24:40.860 --> 24:42.860
就见过这个配置

24:42.860 --> 24:43.860
这个配置什么意思呢

24:43.860 --> 24:44.860
就是有些模块

24:44.860 --> 24:46.860
特别是第三方模块

24:46.860 --> 24:47.860
它可能使用的是

24:47.860 --> 24:48.860
这种方式导出的

24:48.860 --> 24:50.860
module.export

24:50.860 --> 24:52.860
这种方式在导出的

24:52.860 --> 24:53.860
或者说

24:53.860 --> 24:55.860
它使用的是TS代码

24:55.860 --> 24:56.860
它用这种方式导出的

24:56.860 --> 24:57.860
当然翻译过来了

24:57.860 --> 24:58.860
把它编译过来了

24:58.860 --> 25:00.860
也是module.export

25:00.860 --> 25:02.860
它可能使用这种方式导出的

25:02.860 --> 25:04.860
那么这种方式导出的代码呢

25:04.860 --> 25:06.860
你是没有办法进行默认导入的

25:06.860 --> 25:07.860
我们之前也解释过

25:07.860 --> 25:09.860
它没法进行默认导入

25:09.860 --> 25:10.860
因此呢

25:10.860 --> 25:12.860
你把这个选项开启过后

25:12.860 --> 25:14.860
它就可以进行默认导入了

25:14.860 --> 25:16.860
因为它会生成两个辅助函

25:16.860 --> 25:17.860
说一个是 import star

25:17.860 --> 25:19.860
一个是 import default

25:19.860 --> 25:20.860
我们当时

25:20.860 --> 25:21.860
如果这一块忘了的话

25:21.860 --> 25:23.860
可以就回过头去看一下那一块

25:23.860 --> 25:24.860
模块化的章节

25:24.860 --> 25:26.860
我们当时特别讲了这个配置

25:26.860 --> 25:27.860
那么就可以使

25:27.860 --> 25:28.860
如果

25:28.860 --> 25:29.860
一些第三方的裤

25:29.860 --> 25:30.860
它使用这种方式导出

25:30.860 --> 25:31.860
我们也可以使用

25:31.860 --> 25:32.860
es6的方式

25:32.860 --> 25:34.860
来进行默认导入的

25:34.860 --> 25:36.860
就这么一块配置

25:36.860 --> 25:37.860
它表示的是

25:37.860 --> 25:38.860
适合允许es

25:38.860 --> 25:39.860
我们使用

25:39.860 --> 25:42.860
我们使用es6的

25:42.860 --> 25:43.860
模块化标准

25:43.860 --> 25:45.860
来跟

25:45.860 --> 25:46.860
common.js

25:46.860 --> 25:47.860
这些模块化标准

25:47.860 --> 25:49.860
也就是es6的模块化标准

25:49.860 --> 25:50.860
来进行交互

25:50.860 --> 25:51.860
它适合允许把它开启

25:51.860 --> 25:52.860
开启过后

25:52.860 --> 25:53.860
它会生成一些

25:53.860 --> 25:54.860
辅助的函数

25:54.860 --> 25:56.860
来帮助你完成

25:56.860 --> 25:58.860
好 下边这个配置

25:58.860 --> 25:59.860
没见过对吧

25:59.860 --> 26:01.860
当我们讲模块化的时候

26:01.860 --> 26:02.860
是没有讲这个配置的

26:02.860 --> 26:04.860
因为没有必要

26:04.860 --> 26:06.860
当你把这个配置开启的时候

26:06.860 --> 26:07.860
它自动的

26:07.860 --> 26:08.860
就会把这个配置开启

26:08.860 --> 26:09.860
所以说

26:09.860 --> 26:10.860
这个配置

26:10.860 --> 26:11.860
实际上是可以不用配置的

26:11.860 --> 26:12.860
这个配置是什么意思呢

26:12.860 --> 26:14.860
就是说当你

26:14.860 --> 26:15.860
还是一样的意思

26:15.860 --> 26:16.860
就是说有一些模块

26:16.860 --> 26:17.860
它使用的是

26:17.860 --> 26:19.860
这种方式导出的

26:19.860 --> 26:22.860
那么我默认导入的时候

26:22.860 --> 26:23.860
我使用默认导入的时候

26:23.860 --> 26:25.860
它会爆错

26:25.860 --> 26:27.860
你把这个配置开启过后

26:27.860 --> 26:28.860
它就不会爆错了

26:28.860 --> 26:29.860
这个配置

26:29.860 --> 26:31.860
它跟编译没有任何关系

26:31.860 --> 26:33.860
它不会生成任何的编译结果

26:33.860 --> 26:34.860
这里也说到了

26:34.860 --> 26:36.860
然后这个配置

26:36.860 --> 26:38.860
不会影响到编译结果

26:38.860 --> 26:39.860
影响到编译结果

26:39.860 --> 26:41.860
只有是这个配置来完成的

26:41.860 --> 26:43.860
这个配置会在编译结果里边

26:43.860 --> 26:44.860
生成一些辅助函数

26:44.860 --> 26:45.860
来帮助你

26:45.860 --> 26:47.860
帮助你

26:47.860 --> 26:49.860
把编译的结果里边

26:49.860 --> 26:51.860
跟这种方式导出的东西

26:51.860 --> 26:53.860
进行交互

26:53.860 --> 26:54.860
所以说真正会影响

26:54.860 --> 26:55.860
编译结果的是这个配置

26:55.860 --> 26:56.860
而这个配置

26:56.860 --> 26:58.860
只是会影响什么呢

26:58.860 --> 27:00.860
会影响在TS代码中的内形检查

27:00.860 --> 27:01.860
就是说

27:01.860 --> 27:02.860
有些第三方模块

27:02.860 --> 27:04.860
利用这种方式导出了

27:04.860 --> 27:06.860
适逢允许你在TS代码里边

27:06.860 --> 27:07.860
使用默认导入

27:07.860 --> 27:08.860
使用默认导入

27:08.860 --> 27:09.860
它的余法检查

27:09.860 --> 27:11.860
它只会影响这一块

27:11.860 --> 27:12.860
因此这两个东西

27:12.860 --> 27:13.860
往往是连着用的

27:13.860 --> 27:15.860
你把它开启过后

27:15.860 --> 27:16.860
它默认就会开启

27:16.860 --> 27:17.860
所以说

27:17.860 --> 27:19.860
这个配置可以写可以不写

27:19.860 --> 27:21.860
这是关于下面这个配置

27:21.860 --> 27:23.860
而这个配置

27:23.860 --> 27:24.860
表示

27:24.860 --> 27:26.860
是否经过严格的检查

27:26.860 --> 27:27.860
之前

27:27.860 --> 27:28.860
其实咱们

27:28.860 --> 27:29.860
写配置的时候

27:29.860 --> 27:30.860
写过这么一些配置

27:30.860 --> 27:31.860
还记得吗

27:31.860 --> 27:32.860
script

27:32.860 --> 27:33.860
now

27:33.860 --> 27:35.860
是不是要检查

27:35.860 --> 27:36.860
空的内形

27:36.860 --> 27:38.860
我们如果不加这个配置的话

27:38.860 --> 27:40.860
它的now内形

27:40.860 --> 27:41.860
undefine内形

27:41.860 --> 27:42.860
是可以复制给任何内形的

27:42.860 --> 27:43.860
对吧

27:43.860 --> 27:45.860
还有这么一个配置

27:45.860 --> 27:46.860
script

27:46.860 --> 27:48.860
property

27:48.860 --> 27:49.860
initialization

27:49.860 --> 27:51.860
是否检查属性的初始化

27:51.860 --> 27:52.860
对不对

27:52.860 --> 27:53.860
其实除了这两个之外

27:53.860 --> 27:55.860
还有很多的严格检查

27:55.860 --> 27:57.860
可以对某一些方面

27:57.860 --> 27:59.860
进行更加严格的检查

27:59.860 --> 28:01.860
那么如果你需要

28:01.860 --> 28:02.860
对所有的方面

28:02.860 --> 28:03.860
都进行严格的检查的话

28:03.860 --> 28:05.860
你就把这个配置开启

28:05.860 --> 28:07.860
这是一个统一的配置

28:07.860 --> 28:08.860
把这个配置开启过后

28:08.860 --> 28:09.860
我们刚才提到了

28:09.860 --> 28:10.860
所有的地方

28:10.860 --> 28:11.860
它都会经过严格的检查

28:11.860 --> 28:14.860
就加上这个script

28:14.860 --> 28:15.860
好

28:15.860 --> 28:16.860
下边

28:16.860 --> 28:17.860
它是啥意思呢

28:17.860 --> 28:18.860
它表示的是

28:18.860 --> 28:21.860
是否不允许

28:21.860 --> 28:24.860
不一致的大小写引用

28:24.860 --> 28:25.860
啥意思

28:25.860 --> 28:26.860
就是有的时候

28:26.860 --> 28:28.860
我们写了一个文件

28:28.860 --> 28:30.860
比方说写了这么一个文件

28:30.860 --> 28:32.860
test.ts

28:32.860 --> 28:33.860
写了这么一个文件

28:33.860 --> 28:34.860
这个文件

28:34.860 --> 28:36.860
我们要导入的时候

28:36.860 --> 28:43.180
导入这个文件的时候

28:43.180 --> 28:44.180
随便写

28:44.180 --> 28:46.180
比方说

28:46.180 --> 28:48.180
test.ts

28:48.180 --> 28:49.180
fram

28:49.180 --> 28:51.180
导入这个文件的时候

28:51.180 --> 28:53.180
它是否要区分这个文件的大小写

28:53.180 --> 28:55.180
是否要区分这个文件的大小写

28:55.180 --> 28:56.180
就是说

28:56.180 --> 28:58.180
加上t

28:58.180 --> 28:59.180
那么

28:59.180 --> 29:00.180
就是大写

29:00.180 --> 29:01.180
大小写有问题

29:01.180 --> 29:03.180
那么它是否要区分这个大小写

29:03.180 --> 29:04.180
就这么一个意思

29:04.180 --> 29:05.180
一把配置为q

29:05.180 --> 29:06.180
就表示

29:06.180 --> 29:08.180
要区分大小写

29:08.180 --> 29:10.180
就是这么一个意思

29:10.180 --> 29:11.180
那边

29:16.180 --> 29:17.180
这啥意思呢

29:17.180 --> 29:19.180
马旧这个配置我们之前见过

29:19.180 --> 29:21.180
再讲模块画的那一块

29:21.180 --> 29:22.180
我们要见过的

29:22.180 --> 29:23.180
对吧

29:23.180 --> 29:24.180
模块画的时候

29:24.180 --> 29:25.180
它模块画的结果

29:25.180 --> 29:27.180
使用的是哪一套模块画的标准

29:27.180 --> 29:29.180
它真的是这么一个意思

29:29.180 --> 29:30.180
当时我们配置的

29:30.180 --> 29:32.180
尝试了两个选项

29:32.180 --> 29:33.180
一个是es6

29:33.180 --> 29:35.180
es6是一个模块画标准

29:35.180 --> 29:37.180
还有一种选项是common.js

29:37.180 --> 29:39.180
common.js

29:39.180 --> 29:40.180
使用了这两套标准

29:40.180 --> 29:43.180
这里它把它配置成为了esNext

29:43.180 --> 29:46.180
就是使用了最新版本的模块画标准

29:46.180 --> 29:48.180
其实我这里顺便说一下

29:48.180 --> 29:50.180
这是esNext里面的知识

29:50.180 --> 29:52.180
在这个模块画标准里边

29:52.180 --> 29:54.180
就是最新的模块画标准里边

29:54.180 --> 29:56.180
它其实跟之前的es6

29:56.180 --> 29:58.180
没有太大的变化

29:58.180 --> 30:00.180
只不过在这个模块画标准里边

30:00.180 --> 30:02.180
它允许你动态导入

30:02.180 --> 30:03.180
这啥意思呢

30:03.180 --> 30:04.180
就是说

30:04.180 --> 30:06.180
有可能你这个代码里边

30:06.180 --> 30:07.180
可能写了这么一个代码

30:07.180 --> 30:08.180
if2

30:08.180 --> 30:10.180
比如说我就是随便写一个

30:12.180 --> 30:13.180
没关系

30:13.180 --> 30:14.180
它现在包含我一会再说

30:14.180 --> 30:15.180
我赶紧写到这边

30:15.180 --> 30:16.180
写到这边

30:17.180 --> 30:18.180
写到这

30:19.180 --> 30:22.180
比如说我要在一个判断里边

30:22.180 --> 30:24.180
去动态的导入一些东西

30:24.180 --> 30:26.180
如果你满足某个条件

30:26.180 --> 30:29.180
然后我对一些东西进行导入

30:30.180 --> 30:31.180
这里是用input

30:31.180 --> 30:34.180
是用这种语法来进行导入

30:34.180 --> 30:37.180
就随便导入一个

30:37.180 --> 30:39.180
它是允许你这样使用的

30:39.180 --> 30:41.180
在es6的模块画标准里面

30:41.180 --> 30:43.180
是允许你这样子使用的

30:43.180 --> 30:46.180
因此它这里使用了最新的模块画标准

30:46.180 --> 30:48.180
使用了最新的模块画标准

30:48.180 --> 30:49.180
那么这里

30:49.180 --> 30:50.180
有一个朋友讲问了

30:50.180 --> 30:52.180
那你如果编印的结果

30:52.180 --> 30:55.180
使用这种最新的模块画标准

30:55.180 --> 30:56.180
一个动态导入

30:56.180 --> 30:58.180
以前不能用这种方式导入

30:58.180 --> 31:00.180
es6的模块画标准的话

31:00.180 --> 31:02.180
还要求你导入的所有东西

31:02.180 --> 31:03.180
必须在最顶端

31:03.180 --> 31:04.180
对不对

31:04.180 --> 31:07.180
那你如果使用了这种最新的模块画标准

31:07.180 --> 31:09.180
那会不会有兼容性问题呢

31:09.180 --> 31:11.180
这个问题问得挺好的

31:12.180 --> 31:15.180
所以说这里它是这样子来处理的

31:15.180 --> 31:16.180
怎么处理的呢

31:16.180 --> 31:18.180
在这个教授家里边

31:18.180 --> 31:25.180
它是ts和bible和webpack来进行联用的

31:25.180 --> 31:27.180
是进行联用的

31:27.180 --> 31:30.180
首先webpack把这些ts文件夹展出来

31:30.180 --> 31:32.180
夹展出来过后

31:32.180 --> 31:34.180
交给ts

31:34.180 --> 31:36.180
它这么一个过程

31:36.180 --> 31:38.180
webpack把文件夹展出来

31:38.180 --> 31:39.180
交给谁

31:39.180 --> 31:40.180
交给ts

31:40.180 --> 31:44.180
ts再把它翻译成为编印成为ges代码

31:44.180 --> 31:46.180
ges代码里面是不是有些新的东西

31:46.180 --> 31:49.180
你看模块画标准使用的是最新的模块画标准

31:49.180 --> 31:51.180
它会影响到这一步

31:51.180 --> 31:53.180
ts编印成ges过后

31:53.180 --> 31:54.180
它会影响到这

31:54.180 --> 31:58.180
ges代码里面使用的是最新的模块画标准

31:58.180 --> 32:00.180
当然会有兼容性问题对不对

32:00.180 --> 32:02.180
但是ges它会继续交给谁

32:02.180 --> 32:04.180
交给bible来处理

32:04.180 --> 32:07.180
那么bible就会把它进一步的编译

32:07.180 --> 32:10.180
因为bible就是把新版本的ges代码

32:10.180 --> 32:13.180
编译成为旧版本的ges代码

32:13.180 --> 32:14.180
所以会交给bible

32:14.180 --> 32:18.180
那么这里就会产生最终的结果

32:18.180 --> 32:21.180
当然最后还会经过webpack的打包

32:21.180 --> 32:22.180
把它进行合并

32:22.180 --> 32:26.180
合并成一个两个少量的ges文件

32:26.180 --> 32:28.180
原来都有意思吗

32:28.180 --> 32:29.180
所以说

32:29.180 --> 32:30.180
整个工程里面

32:30.180 --> 32:33.180
它不是说光有一个ts再发挥作用

32:33.180 --> 32:35.180
它其实还会加入了

32:35.180 --> 32:36.180
webpack里面

32:36.180 --> 32:38.180
角色家里面一些其他的东西

32:38.180 --> 32:39.180
比方说bible

32:39.180 --> 32:40.180
所以说

32:40.180 --> 32:44.180
这里ts编印的结果还会经过一次bible的编印

32:44.180 --> 32:45.180
因此你这里不用担心

32:45.180 --> 32:47.180
不用担心接种性问题

32:47.180 --> 32:50.180
虽然ts把编印的结果使用的是

32:50.180 --> 32:51.180
最新的模块画标准

32:51.180 --> 32:53.180
但是还会经过bible

32:53.180 --> 32:55.180
不用担心的

32:55.180 --> 32:58.180
好 这是关于这一块

32:58.180 --> 32:59.180
下一个配置

32:59.180 --> 33:02.180
marge resolution

33:02.180 --> 33:03.180
这个是讲过的

33:03.180 --> 33:05.180
表示模块解析的方式

33:05.180 --> 33:07.180
用什么方式解析

33:07.180 --> 33:08.180
这里不用管

33:08.180 --> 33:09.180
你直接把它配置成漏的

33:09.180 --> 33:11.180
现在都是使用漏的方式来解析模块

33:11.180 --> 33:13.180
先查到当前目录

33:13.180 --> 33:16.180
就是在使用非相对路径的时候

33:16.180 --> 33:18.180
先查到当前目录有没有

33:18.180 --> 33:19.180
如果没有的话

33:19.180 --> 33:21.180
那么看一下当前目录里面

33:21.180 --> 33:23.180
有没有这个

33:23.180 --> 33:25.180
这里没有配置

33:25.180 --> 33:26.180
有没有这个配置

33:26.180 --> 33:27.180
这个pac系列接生里面

33:27.180 --> 33:29.180
有没有这个配置

33:29.180 --> 33:30.180
如果有的话

33:30.180 --> 33:31.180
那么去找一下

33:31.180 --> 33:33.180
这个配置对应的文件

33:33.180 --> 33:35.180
如果这个配置也没有的话

33:35.180 --> 33:36.180
去找in这个时候文件

33:36.180 --> 33:37.180
就通过这么一些规则

33:37.180 --> 33:38.180
来去找模块

33:38.180 --> 33:39.180
来去解析模块

33:39.180 --> 33:41.180
把设文漏掉就完成了

33:41.180 --> 33:43.180
好 下一个配置

33:43.180 --> 33:44.180
下一个配置指的是

33:44.180 --> 33:47.180
是否能够允许解析接生模块

33:47.180 --> 33:48.180
就是说有的时候

33:48.180 --> 33:50.180
我们写了一个接生的配置

33:50.180 --> 33:51.180
一个配置文件

33:51.180 --> 33:52.180
是否这个配置文件

33:52.180 --> 33:53.180
这种配置文件

33:53.180 --> 33:55.180
能够在ts里面把它导入进来

33:55.180 --> 33:57.180
把它当成一个对象来使用

33:57.180 --> 33:58.180
指的是这么一个仪式

33:58.180 --> 34:00.180
这里它把默认开启的

34:00.180 --> 34:01.180
但是我们这个工程里边

34:01.180 --> 34:04.180
也不会使用到这种情况

34:04.180 --> 34:06.180
好 下一个

34:06.180 --> 34:08.180
下一个挺有意思的

34:08.180 --> 34:09.180
下一个是什么意思呢

34:09.180 --> 34:10.180
它表示的是

34:10.180 --> 34:13.180
是不是把每一个文件

34:13.180 --> 34:14.180
当成一个模块

34:14.180 --> 34:15.180
是不是把每一个文件

34:15.180 --> 34:17.180
就当成一个模块

34:17.180 --> 34:18.180
它把它开启了

34:18.180 --> 34:19.180
开启了之后你会发现

34:19.180 --> 34:20.180
你这个文件啥都不写

34:20.180 --> 34:21.180
它要爆错

34:21.180 --> 34:22.180
啥都不写

34:22.180 --> 34:23.180
它要爆错

34:23.180 --> 34:24.180
因为你这个

34:24.180 --> 34:25.180
这个模块

34:25.180 --> 34:26.180
这是个模块

34:26.180 --> 34:28.180
你没有出现 import 关键词

34:28.180 --> 34:30.180
也没有出现 export

34:30.180 --> 34:31.180
所以说它认为

34:31.180 --> 34:32.180
你这个地方有问题

34:32.180 --> 34:34.180
你应该把它当成一个模块

34:34.180 --> 34:36.180
不能直接是一个空的文件

34:36.180 --> 34:37.180
因此你这个文件里面

34:37.180 --> 34:38.180
至少得写个什么

34:38.180 --> 34:41.870
至少得写一个 export

34:41.870 --> 34:42.870
它这么一个仪式

34:42.870 --> 34:44.870
现在也不爆错了

34:44.870 --> 34:46.870
当然你写一个 export 的时候

34:46.870 --> 34:47.870
你不能用这种写法

34:47.870 --> 34:49.870
你不能用这种写法

34:49.870 --> 34:50.870
你不能用这种写法

34:50.870 --> 34:51.870
为什么呢

34:51.870 --> 34:53.870
因为现在的模块化标准

34:53.870 --> 34:54.870
你看一下

34:54.870 --> 34:56.870
现在的模块化标准

34:56.870 --> 34:57.870
使用的是 es next

34:57.870 --> 34:59.870
那你这个东西

34:59.870 --> 35:00.870
这个玩意

35:00.870 --> 35:01.870
我们之前说过

35:01.870 --> 35:03.870
这个玩意会被编译成啥

35:03.870 --> 35:04.870
编译成这种东西

35:04.870 --> 35:05.870
对不对

35:05.870 --> 35:07.870
在 es 6 里面标准里面

35:07.870 --> 35:10.870
它是不能允许利用这种写法的

35:10.870 --> 35:12.870
而我们现在模块化的标准

35:12.870 --> 35:13.870
就是编译的结果里面

35:13.870 --> 35:15.870
模块化的标准是使用 es next

35:15.870 --> 35:18.870
就是最新的模块化标准

35:18.870 --> 35:19.870
官方的模块化标准

35:19.870 --> 35:21.870
那么你不能使用这种方式来倒出

35:21.870 --> 35:22.870
因为这种方式

35:22.870 --> 35:23.870
会被编译成这种结果

35:23.870 --> 35:25.870
而这是 common 介石的规范

35:25.870 --> 35:27.870
我们以前反复强调过

35:27.870 --> 35:28.870
反正总之呢

35:28.870 --> 35:30.870
你在写 ts 的时候

35:30.870 --> 35:32.870
你在写 ts 的时候

35:32.870 --> 35:33.870
直接使用 es

35:33.870 --> 35:36.870
es6 的模块化标准就完事了

35:36.870 --> 35:37.870
好

35:37.870 --> 35:38.870
这是关于这个配置

35:38.870 --> 35:41.870
下面这个 low emit

35:41.870 --> 35:42.870
这个配置表示什么意思呢

35:42.870 --> 35:46.870
表示不生成介石文件

35:46.870 --> 35:48.870
我们之前搭建的环境里边

35:48.870 --> 35:50.870
我们写的 ts 代码

35:50.870 --> 35:51.870
最终编译的结果

35:51.870 --> 35:52.870
是一个介石文件

35:52.870 --> 35:53.870
对不对

35:53.870 --> 35:55.870
它这个 low emit 表示的是

35:55.870 --> 35:57.870
我不要去生成文件了

35:57.870 --> 35:59.870
就在内存里面完成编译就完事了

35:59.870 --> 36:03.870
low emit 不生成介石文件

36:03.870 --> 36:05.870
为什么不要生成介石文件呢

36:05.870 --> 36:06.870
因为还有后续的处理啊

36:06.870 --> 36:07.870
你看

36:07.870 --> 36:08.870
为 pack 会交给 ts

36:08.870 --> 36:10.870
ts 把它编成介石代码

36:10.870 --> 36:11.870
你不需要给我生成文件

36:11.870 --> 36:13.870
因为这个代码还会经过处理

36:13.870 --> 36:15.870
还会经过 bible 来处理

36:15.870 --> 36:16.870
产生最终的结果

36:16.870 --> 36:17.870
所以说这里呢

36:17.870 --> 36:19.870
你不需要生成文件了

36:19.870 --> 36:20.870
你直接编译

36:20.870 --> 36:21.870
然后后续还要处理

36:21.870 --> 36:22.870
好

36:22.870 --> 36:24.870
所以说把这个配置开启

36:24.870 --> 36:25.870
最后一个配置

36:25.870 --> 36:29.870
最后配置是指的是解析

36:29.870 --> 36:31.870
介石 x 的方式

36:31.870 --> 36:33.870
因为我们写的是 rex 的代码

36:33.870 --> 36:34.870
而 rex 的代码里边呢

36:34.870 --> 36:35.870
肯定会涉及到

36:35.870 --> 36:38.870
肯定会涉及到介石 x 的代码

36:38.870 --> 36:39.870
就是这种代码

36:39.870 --> 36:41.870
那么这种代码呢

36:41.870 --> 36:43.870
ts 原生的 ts

36:43.870 --> 36:44.870
最早的时候

36:44.870 --> 36:45.870
ts 是不支持的

36:45.870 --> 36:47.870
因为他不认识这个东西是啥

36:47.870 --> 36:49.870
这个东西又不是介石的标准

36:49.870 --> 36:50.870
对不对

36:50.870 --> 36:51.870
他又不是介石的标准

36:51.870 --> 36:52.870
他不认识这个东西是啥

36:52.870 --> 36:53.870
但是后来呢

36:53.870 --> 36:54.870
我之前也说过

36:54.870 --> 36:56.870
本节课一开始的时候说过

36:56.870 --> 36:57.870
后来呢

36:57.870 --> 36:59.870
微软跟 rex

36:59.870 --> 37:01.870
就是 facebook 两个公司呢

37:01.870 --> 37:03.870
有进行了合作

37:03.870 --> 37:04.870
微软的 ts 里边呢

37:04.870 --> 37:07.870
开始去支持介石 x 的代码了

37:07.870 --> 37:09.870
他并他能够识别这样的代码

37:09.870 --> 37:10.870
他不会抱错

37:10.870 --> 37:11.870
并且呢

37:11.870 --> 37:12.870
他还能够支持

37:12.870 --> 37:13.870
在这个代码里边

37:13.870 --> 37:15.870
进行严格的内情检查

37:15.870 --> 37:17.870
那么这里的配置呢

37:17.870 --> 37:18.870
就指的是

37:18.870 --> 37:20.870
我如何来解析

37:20.870 --> 37:21.870
介石 x 代码

37:21.870 --> 37:23.870
如何来进行解析

37:23.870 --> 37:25.870
这里有三个配置值

37:25.870 --> 37:26.870
preserve 的意思呢

37:26.870 --> 37:27.870
就表示不变

37:27.870 --> 37:28.870
不变 跟以前一样

37:28.870 --> 37:30.870
我们来看一下这三个值吧

37:30.870 --> 37:32.870
就是他官方文档里边有说了

37:32.870 --> 37:35.870
进入他的官方文档 TypeScript

37:35.870 --> 37:37.870
这里面我们进入他的文档看一下

37:37.870 --> 37:39.870
这一个手冊

37:39.870 --> 37:40.870
手冊下面有

37:40.870 --> 37:41.870
你看这里

37:41.870 --> 37:43.870
对介石 x 的支持

37:43.870 --> 37:44.870
我来看一下这个

37:44.870 --> 37:45.870
这里面说的

37:45.870 --> 37:46.870
他所说的

37:46.870 --> 37:47.870
他就说了这么一个点

37:47.870 --> 37:49.870
就是说你可以在配置文件里面

37:49.870 --> 37:50.870
加上这么一个配置

37:50.870 --> 37:52.870
就是介石 x 的配置

37:52.870 --> 37:53.870
他有三种曲子

37:53.870 --> 37:55.870
地种曲子呢就是不变的preserve

37:55.870 --> 37:57.870
以前怎么写

37:57.870 --> 37:58.870
现在怎么写

37:58.870 --> 37:59.870
以前啥样

37:59.870 --> 38:00.870
编印的结果就是啥样

38:00.870 --> 38:01.870
如果你写了

38:01.870 --> 38:02.870
比方说他告诉你的

38:02.870 --> 38:03.870
觉得例子

38:03.870 --> 38:05.870
如果你在ts 里边写了这个代码

38:05.870 --> 38:06.870
他编印的结果

38:06.870 --> 38:07.870
缘分不动

38:07.870 --> 38:08.870
还是这个代码

38:08.870 --> 38:10.870
当然这个代码会交给谁

38:10.870 --> 38:11.870
会交给bibe 对吧

38:11.870 --> 38:13.870
让他进一步进行处理

38:13.870 --> 38:15.870
会编印成这个代码

38:15.870 --> 38:17.870
并且的编印的后维

38:17.870 --> 38:20.870
编印的文件后维是gesx

38:20.870 --> 38:22.870
如果你要产生文件的话

38:22.870 --> 38:23.870
如果你要产生一个

38:23.870 --> 38:24.870
编印结果文件的话

38:24.870 --> 38:26.870
它是gesx

38:26.870 --> 38:29.870
好 这是这种方式

38:29.870 --> 38:30.870
好 下面这个方式

38:30.870 --> 38:32.870
是把它配置为react

38:32.870 --> 38:34.870
如果使用这种配置的话

38:34.870 --> 38:35.870
你写的这个代码

38:35.870 --> 38:37.870
会被bene 成为这个代码

38:37.870 --> 38:38.870
这个代码

38:38.870 --> 38:41.870
其实我们以前学习react的时候

38:41.870 --> 38:42.870
应该讲过的吧

38:42.870 --> 38:44.870
gesx

38:44.870 --> 38:46.870
它本质上就是一个对象

38:46.870 --> 38:48.870
这个对象是怎么产生的

38:48.870 --> 38:50.870
就是通过这个函数产生的

38:50.870 --> 38:51.870
react 第二

38:51.870 --> 38:52.870
create element

38:52.870 --> 38:54.870
通过这个函数调用

38:54.870 --> 38:55.870
来产生的一个对象

38:55.870 --> 38:58.870
因此在ts 里面

38:58.870 --> 39:00.870
如果你进行了这样的配置

39:00.870 --> 39:01.870
那么它会把自动的

39:01.870 --> 39:02.870
把这个东西

39:02.870 --> 39:04.870
直接给你编印成这个东西

39:04.870 --> 39:05.870
直接变成这个东西

39:05.870 --> 39:06.870
那直接变成这个东西

39:06.870 --> 39:07.870
过后甚至

39:07.870 --> 39:09.870
甚至你可以不使用bibe了

39:09.870 --> 39:12.870
你可以不进行进一步的编印了

39:12.870 --> 39:13.870
如果你要产生文件的话

39:13.870 --> 39:15.870
我们这里是不产生文件的

39:15.870 --> 39:17.870
刚才说过是没有产生文件的

39:17.870 --> 39:18.870
如果你要产生文件的话

39:18.870 --> 39:20.870
文件的后维是ges

39:20.870 --> 39:22.870
下面这个react native

39:22.870 --> 39:24.870
就是开发手机端

39:24.870 --> 39:25.870
移动端应用的

39:25.870 --> 39:27.870
这个框架

39:27.870 --> 39:30.870
如果你把它配置为这个东西的话

39:30.870 --> 39:32.870
跟preserve 是一样的

39:32.870 --> 39:33.870
跟它是一样的

39:33.870 --> 39:34.870
只不过它产生的文件

39:34.870 --> 39:36.870
后续名是ges

39:36.870 --> 39:38.870
这就是三个配置的差别

39:38.870 --> 39:41.870
ok 这就是关于

39:41.870 --> 39:44.870
这就是关于这里

39:44.870 --> 39:45.870
所有的配置

39:45.870 --> 39:48.870
把配置这一块讲完了

39:48.870 --> 39:50.870
好 了解的配置过后

39:50.870 --> 39:52.870
咱们把这个工程里边的东西

39:52.870 --> 39:53.870
稍微清理一下

39:53.870 --> 39:55.870
因为我们要开发

39:55.870 --> 39:56.870
一个全新的应用

39:56.870 --> 39:58.870
它里边有一些势力代码

39:58.870 --> 40:00.870
我们不太需要

40:00.870 --> 40:02.870
首先我们从这个地方来说

40:02.870 --> 40:04.870
这个是app.css

40:04.870 --> 40:06.870
这个css我们可以不要

40:06.870 --> 40:08.870
我们以后需要的时候再洗

40:08.870 --> 40:09.870
把它删除掉

40:09.870 --> 40:11.870
删除掉这是个测试文件

40:11.870 --> 40:12.870
这是个测试文件

40:12.870 --> 40:14.870
它使用的是ges来进行测试

40:14.870 --> 40:16.870
这里我们也不需要测试

40:16.870 --> 40:18.870
删掉

40:18.870 --> 40:21.870
好 这个app.tsx里边

40:21.870 --> 40:22.870
我们这里

40:22.870 --> 40:23.870
这个东西是啥

40:23.870 --> 40:24.870
不用管 现在不用管

40:24.870 --> 40:26.870
我们以后再也继续

40:26.870 --> 40:27.870
我们以后会详细来讲

40:27.870 --> 40:29.870
我们这里

40:29.870 --> 40:31.870
把这些东西全部去掉

40:31.870 --> 40:33.870
把这些样式也全部去掉

40:33.870 --> 40:34.870
什么nogo 全部去掉

40:34.870 --> 40:35.870
就给它写一个

40:35.870 --> 40:37.870
H1元素

40:37.870 --> 40:40.870
app.tsx

40:40.870 --> 40:42.870
OK 起到这

40:42.870 --> 40:44.870
然后这个index.css

40:44.870 --> 40:46.870
这是一个全局的样式

40:46.870 --> 40:47.870
全局的样式里边

40:47.870 --> 40:49.870
我们保留一点东西吧

40:49.870 --> 40:50.870
把这个删了

40:50.870 --> 40:52.870
没什么用 这个把删了

40:52.870 --> 40:53.870
就保留这么一个东西

40:53.870 --> 40:54.870
body 下面

40:54.870 --> 40:56.870
要设置 margin,pending

40:56.870 --> 40:58.870
稍微的做一下

40:58.870 --> 41:00.870
样式的重置就行了

41:00.870 --> 41:02.870
好 下面这个是启动文件

41:02.870 --> 41:04.870
index.tsx

41:04.870 --> 41:05.870
是一个启动文件

41:05.870 --> 41:07.870
这个启动文件里边

41:07.870 --> 41:09.870
我们把有些不必要的东西删掉

41:09.870 --> 41:11.870
这个service worker不要了

41:11.870 --> 41:13.870
这是pwa的东西 不要了

41:13.870 --> 41:15.870
然后这个地方不要了

41:15.870 --> 41:18.870
保留干干净净的一个代码就行了

41:18.870 --> 41:19.870
保存一下

41:19.870 --> 41:22.870
下面是一个nogo

41:22.870 --> 41:25.870
nogo有SVG写的

41:25.870 --> 41:28.870
我们把它删掉

41:28.870 --> 41:30.870
下面这个文件

41:30.870 --> 41:32.870
是一个生命文件

41:32.870 --> 41:34.870
生命文件我们现在还没有讲

41:34.870 --> 41:35.870
生命文件

41:35.870 --> 41:36.870
因此 扔这儿吧

41:36.870 --> 41:37.870
因为这个文件你删也删不掉

41:37.870 --> 41:38.870
它会给你

41:38.870 --> 41:39.870
下一次启动的时候

41:39.870 --> 41:40.870
它又会给你生存

41:40.870 --> 41:42.870
这里面还使用了删写线指令

41:42.870 --> 41:43.870
不用管 不用管

41:43.870 --> 41:44.870
我们扔这儿就行了

41:44.870 --> 41:46.870
好 下面这个service worker

41:46.870 --> 41:47.870
也不需要了

41:47.870 --> 41:48.870
我们把它删除掉

41:48.870 --> 41:50.870
保留这么一个干干净净的工程

41:50.870 --> 41:51.870
OK

41:51.870 --> 41:54.870
咱们把这个工程重新启动一遍

41:54.870 --> 41:56.870
npm start

41:56.870 --> 42:03.870
启动一下

42:03.870 --> 42:04.870
其实这里

42:04.870 --> 42:05.870
刚才不启动的时候

42:05.870 --> 42:07.870
已经显示出来了 对吧

42:07.870 --> 42:09.870
稍微等一下

42:09.870 --> 42:10.870
你可以看到

42:10.870 --> 42:12.870
现在咱们的工程里面就很简单了

42:12.870 --> 42:14.870
就显示了这么一个结果

42:14.870 --> 42:16.870
好 在开发这个应用程序的时候

42:16.870 --> 42:18.870
我建议大家还是去安装

42:18.870 --> 42:20.870
一个谷歌浏览器的插件

42:20.870 --> 42:21.870
这个插件的名字就是这个

42:21.870 --> 42:22.870
rex的调试插件

42:22.870 --> 42:24.870
你们之前学rex的话

42:24.870 --> 42:25.870
应该是有安装这个插件的

42:25.870 --> 42:27.870
rex developer tools

42:27.870 --> 42:28.870
就可以

42:28.870 --> 42:29.870
通过这个插件

42:29.870 --> 42:30.870
就可以去调试这个rex里面

42:30.870 --> 42:32.870
每一个组件的结构

42:32.870 --> 42:34.870
可以去调试它

42:34.870 --> 42:35.870
好 那么现在

42:35.870 --> 42:38.870
我们整个工程环境就准备好了

42:38.870 --> 42:39.870
我们也解释了

42:39.870 --> 42:40.870
被配置文件里面

42:40.870 --> 42:41.870
每一块配置

42:41.870 --> 42:43.870
是一个什么样的含义

42:43.870 --> 42:45.870
以及把工程稍微做了一下清理

42:45.870 --> 42:46.870
OK 那么接下来

42:46.870 --> 42:47.870
我们就开始具体的

42:47.870 --> 42:49.870
来分析整个程序

42:49.870 --> 42:51.870
并且先去了解一下

42:51.870 --> 42:53.870
rex里面如何来去结合

42:53.870 --> 42:55.870
ts来书写代码

