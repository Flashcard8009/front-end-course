WEBVTT

00:00.560 --> 00:04.560
前面的课程我们讲了内装时期

00:04.560 --> 00:08.060
内装时期这东西我知道里面的疑问

00:08.060 --> 00:09.560
你不知道这个东西有什么用

00:09.560 --> 00:13.060
了解语法就行了 目前了解语法就行了

00:13.060 --> 00:14.560
我们先把语法讲完

00:14.560 --> 00:16.560
对语法有这么个印象

00:16.560 --> 00:21.060
我们后边再去说怎么去做一个完整的效果出来

00:21.060 --> 00:24.060
然后我们这些课讲成员装时期

00:24.060 --> 00:27.560
什么叫成员 成员指的是内成员 对吧

00:27.560 --> 00:28.560
内的成员

00:29.560 --> 00:32.560
成员装时期里边我们有这么一些成员

00:32.560 --> 00:35.560
随便成员列出来 有属性

00:35.560 --> 00:38.560
还有什么有方法 对吧

00:38.560 --> 00:40.560
这些都是成员

00:40.560 --> 00:43.060
好 当然属性的还有静态属性

00:43.060 --> 00:46.060
还有实力属性都不一样的

00:46.060 --> 00:48.060
我们先说属性吧

00:48.060 --> 00:51.560
属性的装时期 装时期

00:51.560 --> 00:56.560
装时期也是一个内 跟内一样

00:56.560 --> 00:59.560
装时期本质上也是一个函数

00:59.560 --> 01:01.560
本质上都是函数

01:01.560 --> 01:06.560
但是属性的装时期它函数的格式有所不同

01:06.560 --> 01:11.560
该函数需要两个参数

01:11.560 --> 01:13.560
之前内的话只需要一个参数就完事了

01:13.560 --> 01:17.560
你把构造 把整个内传给我就完事了

01:17.560 --> 01:20.560
但是属性装时期它需要两个参数

01:20.560 --> 01:24.560
哪两个参数呢 参数1

01:24.560 --> 01:29.560
1是 第一个参数有两种情况

01:29.560 --> 01:34.560
第一个参数 如果是静态属性

01:34.560 --> 01:39.560
则为什么呢 为内本身

01:39.560 --> 01:41.560
如果你是静态属性的话

01:41.560 --> 01:44.560
那么它第一个参数传进来的是内本身

01:44.560 --> 01:46.560
就跟内装时期是一样的

01:46.560 --> 01:49.560
如果是实力属性

01:49.560 --> 01:51.560
什么叫实力属性

01:51.560 --> 01:53.560
就是这个属性是通过对相来雕用的

01:53.560 --> 01:56.560
你溜了内的对相 然后去雕用属性

01:56.560 --> 01:59.560
就大部分时候我们都是实力属性

01:59.560 --> 02:05.560
如果是实力属性的话 则为内的圆形

02:05.560 --> 02:10.560
方法圆形 了解一下就是Prototype

02:10.560 --> 02:15.560
实力里面的一个对相里面的一些东西

02:15.560 --> 02:18.560
可能放在圆形里面了 它就是内的圆形

02:18.560 --> 02:21.560
这是第一个参数 第二个参数是固定的

02:21.560 --> 02:27.560
固定为一个支付串 表示属性名

02:27.560 --> 02:29.560
表示的是属性名

02:29.560 --> 02:32.560
好 我们既然知道它的就是这个本质

02:32.560 --> 02:35.560
我们就来书写一下吧 来书写一下

02:38.560 --> 02:42.560
这里我们写这么一个函数

02:42.560 --> 02:44.560
函数 或者就是D吧

02:44.560 --> 02:47.560
这个函数我们给它两个参数

02:47.560 --> 02:51.560
第一个参数 它有可能是一个静态属性

02:51.560 --> 02:54.560
有可能修饰的是一个实力属性

02:54.560 --> 02:57.560
那我这里干脆给ND吧 给ND无所谓的

02:57.560 --> 03:03.560
然后第二个参数 我们支付串 就是属性的名字

03:03.560 --> 03:06.560
用T来表示 是一个支付串

03:06.560 --> 03:12.560
这个装饰器里面 我直接输出Target和T

03:12.560 --> 03:14.560
把这两个输出就玩笑了

03:14.560 --> 03:16.560
好 咱来试着用一下这个装饰器

03:16.560 --> 03:20.560
比方说这里有这么一个内 有这么一个内

03:20.560 --> 03:22.560
地方不要了

03:22.560 --> 03:24.560
这个内里面有一些属性

03:24.560 --> 03:28.560
PIP1是一个支付串 随便写吧

03:28.560 --> 03:30.560
给它一个装饰器D

03:30.560 --> 03:34.560
然后再一个属性PIP2一个支付串

03:34.560 --> 03:36.560
给它的装饰器D

03:36.560 --> 03:38.560
那么问大家一个问题

03:38.560 --> 03:41.560
你觉得这个装饰器会运行几次呢

03:41.560 --> 03:43.560
会运行几次

03:43.560 --> 03:46.560
就运行两次 它装饰了两个东西吧

03:46.560 --> 03:49.560
之前装饰内的时候 装饰一个内运行一次

03:49.560 --> 03:51.560
装饰另一个内运行一次

03:51.560 --> 03:55.560
装饰属性也是一样的 装饰一个属性就运行一次

03:55.560 --> 03:57.560
保存一下 咱们来看一下

04:03.700 --> 04:05.700
你看 它运行了两次

04:05.700 --> 04:09.700
第一次运行的 把属性名PIP1传进去了

04:09.700 --> 04:11.700
然后还传了个什么东西呢

04:11.700 --> 04:14.700
还传了一个不是A的对象

04:14.700 --> 04:17.700
不是A的对象 是A的Prototype

04:17.700 --> 04:19.700
是A的Prototype

04:19.700 --> 04:22.700
不信我了 我们这里判断一下吧

04:22.700 --> 04:25.700
A.Prototype 看一下这个是不是一样的

04:25.700 --> 04:28.700
看一下Target跟Prototype是一致的

04:28.700 --> 04:34.700
保存 你看 它传入的是A的原型

04:34.700 --> 04:38.700
那比方说我们就可以这样做

04:38.700 --> 04:40.700
比方说 举个例子吧

04:40.700 --> 04:42.700
就随便举个例子

04:42.700 --> 04:45.700
我们做一些事吧

04:45.700 --> 04:47.700
因为这里面做的事情实在是太多了

04:47.700 --> 04:49.700
我们可以这样做

04:49.700 --> 04:52.700
在Target里边 我们给它加一个属性

04:52.700 --> 04:54.700
加一个 两个下滑线

04:54.700 --> 04:57.700
Probs 它是一个数组

04:57.700 --> 05:00.700
这个数组里边 我们判断一下吧

05:00.700 --> 05:02.700
判断一下这个数组

05:02.700 --> 05:03.700
这个东西是否存在

05:03.700 --> 05:06.700
因为它是A内行 可以绕过内行检查

05:06.700 --> 05:10.700
如果这个数组不存在的话

05:10.700 --> 05:12.700
我就给它创建这么一个数组

05:12.700 --> 05:14.700
PROP

05:14.700 --> 05:17.700
然后给它复制为一个数组

05:17.700 --> 05:20.700
好 数组复制完了过后

05:20.700 --> 05:23.700
我这里找到这个属性

05:23.700 --> 05:26.700
往这个数组里面加一下

05:26.700 --> 05:30.700
加一下什么 加一下这个key

05:30.700 --> 05:32.700
好 那么这个代码运行完了过后

05:32.700 --> 05:35.700
你觉得会有一个什么样的现象

05:35.700 --> 05:37.700
我们这里下边输出

05:37.700 --> 05:39.700
输出啥呢

05:39.700 --> 05:41.700
A.prototype

05:41.700 --> 05:43.700
然后

05:43.700 --> 05:45.700
什么呢

05:45.700 --> 05:47.700
Probs

05:47.700 --> 05:49.700
好 这里要报错 报出的原因

05:49.700 --> 05:51.700
它推断出来

05:51.700 --> 05:53.700
它的圆形里边是没有这个东西的

05:53.700 --> 05:55.700
但是实际上我们现在肯定它有

05:55.700 --> 05:56.700
肯定它有

05:56.700 --> 05:58.700
因为我们在装饰器里面给它加了

05:58.700 --> 06:00.700
它这里使用了装饰器

06:00.700 --> 06:02.700
装饰器里面给它加了这个东西

06:02.700 --> 06:04.700
我们就可以怎么做了

06:05.700 --> 06:07.700
把这个prototype转换成N力

06:09.700 --> 06:11.700
把它不要报错

06:11.700 --> 06:13.700
让它输出看一下

06:13.700 --> 06:15.700
你看 输出了一个数组

06:15.700 --> 06:17.700
你看在装饰器里面可以做

06:17.700 --> 06:19.700
很多很多特别的事情

06:19.700 --> 06:21.700
它既然拿到了圆形对象

06:21.700 --> 06:23.700
我就可以往圆形对象里面

06:23.700 --> 06:25.700
就做很多事情

06:25.700 --> 06:27.700
OK 这是关于这一点

06:27.700 --> 06:29.700
当然也可以怎么样呢

06:29.700 --> 06:31.700
也可以创建一个A的对象

06:31.700 --> 06:33.700
创建一个A的对象

06:33.700 --> 06:35.700
这个属性是在圆形里面

06:35.700 --> 06:37.700
我要看一下A里面有哪些属性

06:37.700 --> 06:40.700
我直接通过A

06:40.700 --> 06:42.700
两个下滑线probs

06:42.700 --> 06:44.700
当然要先转换一下

06:44.700 --> 06:46.700
不然它识别不出来

06:46.700 --> 06:48.700
识别不出来的

06:48.700 --> 06:50.700
转换一下

06:50.700 --> 06:51.700
保存

06:51.700 --> 06:53.700
输出了 给我们看一下

06:53.700 --> 06:56.700
所以也输出了这个东西

06:56.700 --> 06:58.700
装饰器里面可以做很多事情

06:58.700 --> 07:00.700
我这里只是引出这么一个例子

07:01.700 --> 07:03.700
这里面可以做很多很多的想要的事情

07:03.700 --> 07:05.700
总之你拿到了圆形对象

07:05.700 --> 07:06.700
拿到了属性的名字

07:06.700 --> 07:08.700
你想做什么就做什么

07:08.700 --> 07:10.700
好 这是关于

07:10.700 --> 07:13.700
这个属性装饰器

07:13.700 --> 07:16.700
好 我们就接着看

07:16.700 --> 07:19.700
刚才我们做了这个实力属性

07:19.700 --> 07:21.700
我们再看一下静态属性

07:21.700 --> 07:23.700
看一下静态属性

07:23.700 --> 07:24.700
比方说这个

07:24.700 --> 07:26.700
第二个属性是静态的

07:26.700 --> 07:28.700
Static

07:28.700 --> 07:29.700
是静态的

07:29.700 --> 07:32.700
好 这里面我仍然输出Target

07:32.700 --> 07:34.700
看一下它们的区别

07:34.700 --> 07:36.700
保存

07:36.700 --> 07:37.700
看一下它们的区别

07:37.700 --> 07:39.700
你看

07:39.700 --> 07:41.700
稍微缝小一点

07:41.700 --> 07:42.700
下边

07:42.700 --> 07:43.700
你看这个

07:43.700 --> 07:45.700
这是它的运行结果

07:45.700 --> 07:47.700
再对照一下这个装饰器

07:47.700 --> 07:48.700
装饰器的代码

07:48.700 --> 07:49.700
你看一下

07:49.700 --> 07:52.700
就是实力属性的时候

07:52.700 --> 07:54.700
它的

07:54.700 --> 07:56.700
第一个参数是Target

07:56.700 --> 07:59.700
因此得到一个远雄对象

07:59.700 --> 08:01.700
远雄是个对象

08:01.700 --> 08:03.700
第二个是一个静态属性

08:03.700 --> 08:05.700
静态的成员

08:05.700 --> 08:07.700
因此得到了结果

08:07.700 --> 08:08.700
第一个参数得到了结果

08:08.700 --> 08:09.700
是一个方式

08:09.700 --> 08:10.700
也就是Adder

08:10.700 --> 08:12.700
构造函数

08:12.700 --> 08:13.700
明白这个意思吗

08:13.700 --> 08:14.700
所以说

08:14.700 --> 08:15.700
这是两者的差别

08:15.700 --> 08:17.700
两者的差别大家注意一下

08:17.700 --> 08:18.700
好了

08:18.700 --> 08:21.700
那么这是关于属性装饰器

08:21.700 --> 08:23.700
当然跟之前一样

08:23.700 --> 08:25.700
属性装饰器

08:25.700 --> 08:27.700
也可以使用这种方式

08:27.700 --> 08:28.700
是一样的

08:28.700 --> 08:29.700
没有什么区别

08:29.700 --> 08:33.700
我这里的Return方式

08:33.700 --> 08:37.850
我写成这种格式

08:37.850 --> 08:38.850
那么这个装饰器

08:38.850 --> 08:39.850
要怎么使用呢

08:39.850 --> 08:40.850
要这样子使用对吧

08:40.850 --> 08:41.850
调用这个函数

08:41.850 --> 08:43.850
来得到这个装饰器

08:43.850 --> 08:44.850
调用函数得到装饰器

08:44.850 --> 08:45.850
是一样的

08:45.850 --> 08:46.850
跟之前

08:46.850 --> 08:47.850
总之你给它满足格式的函数

08:47.850 --> 08:48.850
就行了

08:48.850 --> 08:49.850
它甭管你这个函数

08:49.850 --> 08:50.850
拿来的

08:50.850 --> 08:51.850
其实这个地方

08:51.850 --> 08:52.850
有一种教法

08:52.850 --> 08:55.850
叫做装饰器工厂

08:55.850 --> 08:56.850
啥意思

08:56.850 --> 08:57.850
就表示这个函数

08:57.850 --> 08:59.850
是来产生装饰器的

08:59.850 --> 09:00.850
它本身不是装饰器

09:00.850 --> 09:01.850
它调用它

09:01.850 --> 09:03.850
可以得到一个装饰器

09:03.850 --> 09:05.850
把它叫做装饰器工厂

09:05.850 --> 09:06.850
好

09:06.850 --> 09:09.850
这是属性的装饰器

09:09.850 --> 09:11.850
另外一个就是方法

09:11.850 --> 09:14.850
方法是一样的

09:14.850 --> 09:16.850
这本质上都是函数

09:16.850 --> 09:18.850
方法装饰器

09:18.850 --> 09:20.850
也是一个函数

09:20.850 --> 09:21.850
干函数

09:21.850 --> 09:23.850
它需要三个函数

09:23.850 --> 09:24.850
哪三个函数呢

09:24.850 --> 09:28.420
第一个参数

09:28.420 --> 09:30.420
我们先把语法认识清楚

09:30.420 --> 09:31.420
认识清楚语法过后

09:31.420 --> 09:32.420
我们再说

09:32.420 --> 09:33.420
它能做出什么样的效果

09:33.420 --> 09:36.420
它做出的效果很丰富

09:36.420 --> 09:38.420
第一个参数

09:38.420 --> 09:39.420
它一样的

09:39.420 --> 09:41.420
如果是净太属性

09:41.420 --> 09:42.420
则为内本身

09:42.420 --> 09:43.420
如果是实力属性

09:43.420 --> 09:44.420
则为内的原型

09:44.420 --> 09:45.420
这个不变

09:45.420 --> 09:46.420
当然不是属性的

09:46.420 --> 09:47.420
是方法

09:47.420 --> 09:48.420
因为方法的属性

09:48.420 --> 09:49.420
本质上都是一样的

09:49.420 --> 09:50.420
都是内的成员

09:50.420 --> 09:51.420
对吧

09:51.420 --> 09:52.420
本质上是一样的

09:52.420 --> 09:53.420
第二个参数

09:53.420 --> 09:55.420
固定为一个制服串

09:55.420 --> 09:58.420
表示方法名

09:58.420 --> 10:00.420
它还有第三个参数

10:00.420 --> 10:02.420
第三个参数表示

10:02.420 --> 10:05.420
描述服对象

10:05.420 --> 10:07.420
什么叫描述服对象

10:07.420 --> 10:10.420
大家以前

10:10.420 --> 10:12.420
应该做过这么一个东西

10:12.420 --> 10:14.420
至少你兼过这么一个东西

10:14.420 --> 10:15.420
这是介石

10:15.420 --> 10:17.420
介石原本身的东西

10:17.420 --> 10:19.420
就是我们

10:19.420 --> 10:21.420
这里

10:21.420 --> 10:23.420
比方说有个内

10:24.420 --> 10:25.420
这装饰器认辙吧

10:25.420 --> 10:26.420
认辙

10:26.420 --> 10:27.420
比方说我们创建一下

10:27.420 --> 10:29.420
这个内的对象

10:29.420 --> 10:31.420
创建一下内的对象

10:31.420 --> 10:32.420
我们之前

10:32.420 --> 10:33.420
Object里面不是有一个

10:33.420 --> 10:34.420
这个东西吗

10:34.420 --> 10:36.420
叫define property

10:36.420 --> 10:37.420
见过没

10:37.420 --> 10:38.420
这个函数

10:38.420 --> 10:40.420
可能有些人也忘了

10:40.420 --> 10:42.420
第一个参数传啥呢

10:42.420 --> 10:46.420
第一个参数传的是对象

10:46.420 --> 10:47.420
第二参数传啥呢

10:47.420 --> 10:48.420
往这个对象里边

10:48.420 --> 10:50.420
定义哪个属性

10:50.420 --> 10:51.420
就定义成员

10:51.420 --> 10:52.420
因为在介石里面

10:52.420 --> 10:53.420
方法它也叫做属性

10:53.420 --> 10:54.420
都是一样

10:54.420 --> 10:56.420
都等质上都是一样的

10:56.420 --> 10:57.420
就是成员

10:57.420 --> 10:58.420
内的成员

10:58.420 --> 10:59.420
成员名称

10:59.420 --> 11:01.420
比方说abc

11:01.420 --> 11:03.420
我来提醒这么一个成员

11:03.420 --> 11:04.420
然后第三个参数

11:04.420 --> 11:07.420
需要传一个配置

11:07.420 --> 11:08.420
对吧配置

11:08.420 --> 11:09.420
还记得吗

11:09.420 --> 11:10.420
那个配置里边

11:10.420 --> 11:12.420
什么writeable

11:12.420 --> 11:13.420
这个成员

11:13.420 --> 11:14.420
是不是可以重新复制

11:14.420 --> 11:16.420
默认为true

11:16.420 --> 11:18.420
那么你这里可以把设为force

11:18.420 --> 11:19.420
把设为force

11:19.420 --> 11:20.420
不能重新复制

11:20.420 --> 11:22.420
然后什么Value

11:22.420 --> 11:24.420
这个成员的值是多少

11:24.420 --> 11:26.420
这个值可以是一个方形

11:26.420 --> 11:28.420
也可以是一个

11:28.420 --> 11:29.420
支不出啊

11:29.420 --> 11:31.420
随便随便

11:31.420 --> 11:34.420
然后还有什么innumerable

11:34.420 --> 11:35.420
表示这个成员

11:35.420 --> 11:37.420
是不是可以便利的

11:37.420 --> 11:39.420
在for硬循环里边

11:39.420 --> 11:41.420
是不是可以把这个成员便利出来

11:41.420 --> 11:42.420
默认为true

11:42.420 --> 11:44.420
那么这里可以把写成force等等

11:44.420 --> 11:46.420
这里这个配置对象

11:46.420 --> 11:48.420
就是属性描述幅

11:48.420 --> 11:51.420
就表示的是描述幅对象

11:51.420 --> 11:54.420
描述对象或者叫描述对象

11:54.420 --> 11:56.420
属性描述对象

11:56.420 --> 11:57.420
明明是这里是方法

11:57.420 --> 11:58.420
为什么写成属性

11:58.420 --> 11:59.420
因为在GSE里面

11:59.420 --> 12:02.420
属性和方法本质上是一样的

12:02.420 --> 12:04.420
方法的特点只不过

12:04.420 --> 12:05.420
它是一个函数而已

12:05.420 --> 12:08.420
函数在GSE里边是一等公里

12:08.420 --> 12:10.420
可以当作其他任何类型

12:10.420 --> 12:12.420
统一代对待

12:12.420 --> 12:14.420
所以说它也可以把它叫属性

12:14.420 --> 12:17.420
因此呢方法这么一个修饰幅的话

12:17.420 --> 12:19.420
第三个函数就是这么一个东西

12:19.420 --> 12:21.420
它会把这个东西传进来

12:21.420 --> 12:23.420
好,我们来看一下吧

12:23.420 --> 12:25.420
好,看一下

12:25.420 --> 12:26.420
比方说

12:26.420 --> 12:28.420
这里有两个属性

12:28.420 --> 12:29.420
属性描述幅了

12:29.420 --> 12:30.420
我写个方法

12:30.420 --> 12:33.420
方法Message1

12:33.420 --> 12:35.420
好,这个方法呢

12:35.420 --> 12:37.420
我把

12:37.420 --> 12:39.420
我写这么一个装饰器

12:39.420 --> 12:41.420
就用装饰器工厂吧

12:41.420 --> 12:42.420
就用装饰器工厂

12:42.420 --> 12:43.420
无所谓的

12:43.420 --> 12:45.420
你可以使用装饰器本

12:45.420 --> 12:47.420
这个函数是个装饰器没问题

12:47.420 --> 12:49.420
装饰器工厂也没有任何问题

12:49.420 --> 12:50.420
都是一样的

12:50.420 --> 12:52.420
装饰器工厂应该怎么调用呢

12:52.420 --> 12:53.420
应该这样调用,对吧

12:53.420 --> 12:55.420
应该这样调用

12:55.420 --> 12:57.420
好,现在它仍然是满足要求的

12:57.420 --> 12:59.420
也就是说再一次说明了一个问题

12:59.420 --> 13:02.420
方法也可以当成属性来对待

13:02.420 --> 13:04.420
也可以当成属性来对待

13:04.420 --> 13:07.420
但是呢,它现在可以允许你写

13:07.420 --> 13:09.420
第三个函数

13:09.420 --> 13:11.420
descript

13:11.420 --> 13:13.420
就是这个描述对象

13:13.420 --> 13:15.420
第三个函数的类型是什么呢

13:15.420 --> 13:17.420
在TS里边描述对象的类型叫做

13:17.420 --> 13:19.420
property

13:21.420 --> 13:23.420
descript

13:23.420 --> 13:24.420
property

13:24.420 --> 13:25.420
descript

13:25.420 --> 13:27.420
是它的描述对象的类型

13:27.420 --> 13:29.420
好,我们把这三个东西

13:29.420 --> 13:31.420
输出来看一下

13:31.420 --> 13:33.420
descript

13:33.420 --> 13:34.420
输出来看一下

13:34.420 --> 13:36.420
好,保存

13:36.420 --> 13:38.420
我这里不用去建立对象

13:38.420 --> 13:39.420
不用去建立对象

13:39.420 --> 13:40.420
我们来看一下

13:40.420 --> 13:42.420
因为装饰器的函数

13:42.420 --> 13:44.420
这个函数

13:44.420 --> 13:45.420
它什么时候运行

13:45.420 --> 13:47.420
定义完了之后就会运行

13:47.420 --> 13:49.420
好,咱们来看一下

13:49.420 --> 13:51.420
它输出的结果,你看

13:51.420 --> 13:53.420
第一个参数圆形,对吧

13:53.420 --> 13:54.420
跟属性是一样的

13:54.420 --> 13:56.420
第二参数方法名称

13:56.420 --> 13:58.420
message1,你看,跟属性是一样的

13:58.420 --> 14:00.420
好,多了第三个参数

14:00.420 --> 14:01.420
第三个参数呢

14:01.420 --> 14:03.420
就是这个方法的什么

14:03.420 --> 14:05.420
方法的

14:05.420 --> 14:07.420
描述对象

14:08.420 --> 14:10.420
好,比方说这个描述对象里面

14:10.420 --> 14:12.420
可以做一些稀奇古外的事

14:12.420 --> 14:13.420
比方说

14:13.420 --> 14:15.420
这个innumerable

14:15.420 --> 14:17.420
你看,它为force对吧

14:17.420 --> 14:18.420
也就是这个方法

14:18.420 --> 14:19.420
我们在循环

14:19.420 --> 14:20.420
这个内的时候

14:20.420 --> 14:22.420
它的方法是不会被憋你的

14:22.420 --> 14:23.420
比方说

14:23.420 --> 14:24.420
我们来循环这个

14:24.420 --> 14:26.420
有一个a

14:26.420 --> 14:27.420
有一个a

14:27.420 --> 14:29.420
好,我们再用 forin循环

14:29.420 --> 14:32.420
forin循环,循环这个a对象

14:32.420 --> 14:33.420
循环的时候

14:33.420 --> 14:35.420
我们把这个a打印出来

14:35.420 --> 14:37.420
把这个t打印出来

14:37.420 --> 14:38.420
好,咱们来看一下

14:38.420 --> 14:40.420
循环的时候把这个t打印出来

14:40.420 --> 14:41.420
保存

14:41.420 --> 14:44.420
就是循环对象a里面的所有成员

14:44.420 --> 14:46.420
因为发现

14:46.420 --> 14:47.420
除了之前那个输出

14:47.420 --> 14:49.420
装饰器里面的输出之外

14:49.420 --> 14:51.420
它没有任何东西

14:51.420 --> 14:53.420
它没有任何东西输出

14:53.420 --> 14:54.420
因为它没有属性

14:54.420 --> 14:55.420
它只有一个方法

14:55.420 --> 14:57.420
而这个方法是不参与循环的

14:57.420 --> 14:58.420
为什么呢

14:58.420 --> 15:00.420
因为这个方法的描述幅里边

15:00.420 --> 15:02.420
它把这个东西设为force

15:02.420 --> 15:04.420
默认情况下

15:04.420 --> 15:06.420
方法的innumerable

15:06.420 --> 15:07.420
把设为force

15:07.420 --> 15:10.420
表示方法是不参与便利的

15:10.420 --> 15:12.420
如果你希望这个方法参与便利

15:12.420 --> 15:14.420
很简单,你在装饰器里边

15:14.420 --> 15:16.420
给它加上

15:16.420 --> 15:17.420
crepter

15:17.420 --> 15:18.420
你就不用在外面去写了

15:18.420 --> 15:20.420
就在装饰器,给它写这么一个

15:20.420 --> 15:22.420
你这个方法要参与便利

15:22.420 --> 15:24.420
我就把这个装饰器给加上

15:24.420 --> 15:26.420
自然就参与便利了

15:26.420 --> 15:28.420
我不需要在后面去自己在手东西

15:28.420 --> 15:31.420
装饰器就变成了一个通用的东西了

15:31.420 --> 15:32.420
好,这里

15:32.420 --> 15:33.420
innumerable

15:33.420 --> 15:35.420
把设为true

15:35.420 --> 15:37.420
保存,我们再看一下

15:37.420 --> 15:39.420
你看message1是变利出来了

15:39.420 --> 15:41.420
变利的时候,message1就出来了

15:41.420 --> 15:43.420
好,这样写的好处在什么地方呢

15:43.420 --> 15:45.420
好处在于

15:45.420 --> 15:47.420
这是通用的装饰器写好了之后

15:47.420 --> 15:49.420
比方说我将来还有一些方法

15:49.420 --> 15:51.420
message2

15:51.420 --> 15:53.420
我也希望message2这个方法

15:53.420 --> 15:54.420
也能参与便利

15:54.420 --> 15:55.420
我只需要大家加上的装饰器

15:55.420 --> 15:56.420
完成了

15:56.420 --> 15:57.420
结束

15:57.420 --> 15:58.420
写完了

15:58.420 --> 16:00.420
或者是我把这个装饰器的名称

16:00.420 --> 16:01.420
名名好一点

16:01.420 --> 16:03.420
这样的名名

16:03.420 --> 16:04.420
innum

16:04.420 --> 16:09.420
innumerable

16:09.420 --> 16:10.420
这样命名

16:10.420 --> 16:12.420
或者是把这个装饰器

16:12.420 --> 16:14.420
直接做成这种格式

16:14.420 --> 16:15.420
也行

16:15.420 --> 16:17.420
直接做成这种格式

16:17.420 --> 16:23.670
就不返回寒疏了

16:23.670 --> 16:25.670
那么这里不返回寒疏了

16:25.670 --> 16:28.670
你看这样的写法是不是很舒服

16:28.670 --> 16:30.670
这个方法它本来是不参与便利的

16:30.670 --> 16:31.670
加上一个装饰器

16:31.670 --> 16:33.670
以后它就会参与便利的

16:33.670 --> 16:35.670
包括了其他内里边也是一样

16:35.670 --> 16:37.670
不是说只能在这个内里面使用

16:37.670 --> 16:38.670
其他内里面

16:38.670 --> 16:40.670
反而是我以后遇到了一个方法

16:40.670 --> 16:42.670
还希望它参与便利

16:42.670 --> 16:43.670
我就要加上这个装饰器

16:43.670 --> 16:44.670
完成了

16:44.670 --> 16:46.670
这样代码的是写得非常非常舒服的

16:46.670 --> 16:48.670
因为我写这个方法的时候

16:48.670 --> 16:50.670
我是非常清楚这个方法的各种情况的

16:50.670 --> 16:51.670
我就可以把它加

16:51.670 --> 16:54.670
把相应的装饰器加上就行了

16:54.670 --> 16:55.670
OK

16:55.670 --> 16:58.670
这是关于方法的装饰器

16:58.670 --> 17:00.670
当然这里面还可以做很多很多的事

17:00.670 --> 17:03.670
比方说

17:03.670 --> 17:04.670
怎么样呢

17:04.670 --> 17:06.670
比方说这里

17:07.670 --> 17:09.670
我们可以这样做

17:09.670 --> 17:11.670
Illumerable

17:11.670 --> 17:12.670
不是

17:12.670 --> 17:14.670
Dignite

17:14.670 --> 17:16.670
或者是

17:16.670 --> 17:17.670
这样子

17:17.670 --> 17:19.670
过期

17:19.670 --> 17:20.670
过期

17:20.670 --> 17:24.430
usiness

17:24.430 --> 17:26.430
比方说这个方法已经没用了

17:26.430 --> 17:27.430
不要去调用了

17:27.430 --> 17:28.430
我希望调用这个方法

17:28.430 --> 17:30.430
就会得到一个

17:30.430 --> 17:32.430
得到一个就是警告

17:32.430 --> 17:34.430
得到一个警告

17:34.430 --> 17:36.430
比方说

17:36.430 --> 17:37.430
你给我一个方法

17:37.430 --> 17:38.430
如果装饰为

17:38.430 --> 17:40.430
usiness的方法了

17:40.430 --> 17:42.430
我们就给它重新复职

17:42.430 --> 17:44.430
重新复职

17:46.430 --> 17:47.430
重新复职

17:47.430 --> 17:48.430
它的value值

17:48.430 --> 17:49.430
它本来是一个函数的

17:49.430 --> 17:50.430
对吧

17:50.430 --> 17:51.430
方法本来就是一个函数

17:51.430 --> 17:52.430
我给它重新复一个值

17:52.430 --> 17:54.430
重新复一个函数

17:54.430 --> 17:55.430
这个函数里边

17:55.430 --> 17:56.430
我给它写上

17:56.430 --> 17:58.430
我

17:58.430 --> 17:59.430
该方法

17:59.430 --> 18:01.430
已过期

18:01.430 --> 18:02.430
或者是

18:02.430 --> 18:03.430
把方法名页加上

18:04.430 --> 18:07.510
已过期

18:09.510 --> 18:10.510
比方说

18:10.510 --> 18:11.510
我有这么一个装饰器

18:11.510 --> 18:13.510
有的这么一个装饰器过后

18:13.510 --> 18:14.510
比方说

18:14.510 --> 18:15.510
我这个measure的e

18:15.510 --> 18:17.510
measure的e里边

18:17.510 --> 18:19.510
当然它可以便利

18:19.510 --> 18:20.510
measure的e里面

18:20.510 --> 18:23.510
我本来输出的是measure的e

18:23.510 --> 18:24.510
本来输出的是它

18:24.510 --> 18:26.510
然后我后来有一天发现

18:26.510 --> 18:27.510
这个方法

18:27.510 --> 18:29.510
可能过期了

18:29.510 --> 18:30.510
过时了

18:30.510 --> 18:32.510
但是我现在不敢删

18:32.510 --> 18:33.510
因为我一删的话

18:33.510 --> 18:34.510
很多地方都要报错

18:34.510 --> 18:35.510
很多地方都要报错

18:35.510 --> 18:37.510
但是我希望提示他们

18:37.510 --> 18:38.510
因为他们那边

18:38.510 --> 18:39.510
团队协作

18:39.510 --> 18:41.510
我写这个方法过后

18:41.510 --> 18:42.510
他们那边可能会用

18:42.510 --> 18:43.510
用的时候

18:43.510 --> 18:45.510
他们已经依赖这个方法了

18:45.510 --> 18:47.510
我希望他们尽量的

18:47.510 --> 18:49.510
快一点把这个方法拋弃掉

18:49.510 --> 18:51.510
所以说我这里

18:51.510 --> 18:53.510
可以加上一个usiness

18:53.510 --> 18:55.510
表示个方法不再用了

18:55.510 --> 18:56.510
不再用了

18:56.510 --> 18:58.510
那么我们接下来再看一下

18:58.510 --> 18:59.510
当我们是用对象

18:59.510 --> 19:00.510
去调用这个方法的时候

19:00.510 --> 19:01.510
measure的e的时候

19:02.510 --> 19:04.510
它输出的是

19:04.510 --> 19:06.510
这个方法一过期

19:06.510 --> 19:07.510
为什么呢

19:07.510 --> 19:08.510
因为在装饰器里面

19:08.510 --> 19:10.510
我们已经把这个方法的值

19:10.510 --> 19:12.510
通过属性描述服的value

19:12.510 --> 19:14.510
value就是这个属性的值

19:14.510 --> 19:15.510
它本来是原本

19:15.510 --> 19:16.510
原本是这么一个函数的

19:16.510 --> 19:18.510
我把它替换掉了

19:18.510 --> 19:19.510
替换成了这个

19:19.510 --> 19:21.510
measure的e方法一过期

19:21.510 --> 19:22.510
有一天我发现

19:22.510 --> 19:24.510
这个方法还是挺好的

19:24.510 --> 19:25.510
可以用

19:25.510 --> 19:27.510
我要做的是只有一件事

19:27.510 --> 19:29.510
把这个装饰器去掉

19:30.510 --> 19:31.510
还正常的

19:31.510 --> 19:32.510
看呗

19:32.510 --> 19:33.510
这装饰器的好处

19:33.510 --> 19:34.510
它可以

19:34.510 --> 19:36.510
通过一句简单的语句

19:36.510 --> 19:37.510
来进行描述

19:37.510 --> 19:38.510
描述一个成员

19:38.510 --> 19:39.510
描述一个方法

19:39.510 --> 19:40.510
描述一个属性

19:40.510 --> 19:42.510
来达到你想要的目的

19:42.510 --> 19:43.510
而装饰器里面

19:43.510 --> 19:44.510
要做的事情

19:44.510 --> 19:46.510
可以做的非常非常丰富

19:46.510 --> 19:47.510
因为你拿到了原型

19:47.510 --> 19:48.510
如果是静态

19:48.510 --> 19:49.510
静态的方法的话

19:49.510 --> 19:51.510
拿到的是内

19:51.510 --> 19:52.510
拿到了原型

19:52.510 --> 19:53.510
拿到了内

19:53.510 --> 19:55.510
又拿到了名字

19:55.510 --> 19:56.510
又拿到了描述服

19:56.510 --> 19:58.510
那就可以做各种各样

19:58.510 --> 20:00.510
丰富的事情

20:00.510 --> 20:03.510
当然无论是方法

20:03.510 --> 20:05.510
无论是方法还是属性

20:05.510 --> 20:06.510
它们呢

20:06.510 --> 20:09.510
也可以有多个装饰器修饰

20:09.510 --> 20:11.510
可以有

20:11.510 --> 20:14.510
多个装饰器修饰

20:14.510 --> 20:16.510
那么就像刚才的样子

20:16.510 --> 20:18.510
刚才的样子

20:18.510 --> 20:19.510
你看这里是不

20:19.510 --> 20:20.510
两个装饰器修饰

20:20.510 --> 20:21.510
一样的

20:21.510 --> 20:22.510
都是一样的

20:22.510 --> 20:24.510
那么运行的顺序是啥

20:24.510 --> 20:25.510
运行它

20:25.510 --> 20:27.510
在运行它

20:27.510 --> 20:29.510
按照这样的顺序运行

20:29.510 --> 20:31.510
那如果是装饰器工厂的话

20:31.510 --> 20:32.510
也是一样的

20:32.510 --> 20:33.510
只要你保证

20:33.510 --> 20:35.510
无论你是通过工厂

20:35.510 --> 20:36.510
来得到的函数

20:36.510 --> 20:38.510
还是通过直接

20:38.510 --> 20:39.510
把函数放在这

20:39.510 --> 20:40.510
只要能保证

20:40.510 --> 20:42.510
函数的参数

20:42.510 --> 20:43.510
是匹配的

20:43.510 --> 20:44.510
就完事了

20:44.510 --> 20:45.510
只要能保证

20:45.510 --> 20:46.510
函数的参数匹配

20:46.510 --> 20:47.510
就可以了

20:47.510 --> 20:48.510
就OK了

20:48.510 --> 20:50.510
就没有什么问题了

20:50.510 --> 20:53.510
这是关于

20:53.510 --> 20:54.510
这么两个装饰器

20:54.510 --> 20:56.510
属性和方法

20:56.510 --> 20:57.510
这两个装饰器

20:57.510 --> 20:59.510
那么了解了

20:59.510 --> 21:00.510
这两个装饰器过后

21:00.510 --> 21:02.510
了解了内装饰器

21:02.510 --> 21:04.510
了解了成员装饰器

21:04.510 --> 21:05.510
那么我们

21:05.510 --> 21:07.510
就可以做一些效果了

21:07.510 --> 21:08.510
还有个参数装饰器

21:08.510 --> 21:09.510
我们后面再说吧

21:09.510 --> 21:10.510
我们先把

21:10.510 --> 21:11.510
了解这两个装饰器

21:11.510 --> 21:12.510
把它的

21:12.510 --> 21:14.510
与法规则搞清楚

21:14.510 --> 21:15.510
本质上就是个函数

21:15.510 --> 21:16.510
没什么特别的

21:16.510 --> 21:17.510
只不过

21:17.510 --> 21:18.510
修饰内的时候

21:18.510 --> 21:19.510
修饰属性

21:19.510 --> 21:20.510
修饰方法的时候

21:20.510 --> 21:22.510
它要求有不同的参数

21:22.510 --> 21:23.510
仅此而已

21:23.510 --> 21:25.510
我们把这个规则搞清楚

21:25.510 --> 21:26.510
过后了

21:26.510 --> 21:27.510
我们下节课

21:27.510 --> 21:28.510
来做一个练习

21:28.510 --> 21:29.510
但是前提条件

21:29.510 --> 21:30.510
先搞清楚

21:30.510 --> 21:31.510
它的与法规则

21:31.510 --> 21:32.510
好吧

21:32.510 --> 21:33.510
OK那么这里

21:33.510 --> 21:34.510
可能就到这了

21:34.510 --> 21:35.510
拜拜

