WEBVTT

00:01.140 --> 00:04.140
大家好 我是杜亦教育 微博 简单 讲师 元静

00:05.140 --> 00:08.140
终于咱们到了TS的进阶部分了

00:08.140 --> 00:12.140
技术部分学习完了之后呢 如果你学习TS

00:12.140 --> 00:17.140
只是至于之类或者说只是凭着兴趣来学习的话

00:17.140 --> 00:20.140
技术部分的东西呢其实已经够用了

00:20.140 --> 00:25.140
在很多情况下呢 使用TS的一些基本的类型约束

00:25.140 --> 00:27.140
我们还可以做一些接口啊

00:27.140 --> 00:30.140
类型别名啊 对它进行一下约束

00:30.140 --> 00:33.140
在很多场景里边都已经够用了

00:33.140 --> 00:39.140
如果你学习TS 不会改 不用改变以前的开发方式的话

00:39.140 --> 00:42.140
就是以前怎么写带嘛 那么现在怎么写

00:42.140 --> 00:44.140
如果这个开发方式不改变的话

00:44.140 --> 00:48.140
那么学习TS其实没有多少东西 没有多少东西

00:48.140 --> 00:50.140
因为TS是接使的超级嘛

00:50.140 --> 00:53.140
接使以前写带嘛我们已经非常熟悉了

00:53.140 --> 00:56.140
你只需要跟它加上一些在合适的位置

00:56.140 --> 00:58.140
加上一些类型检查就行了

00:58.140 --> 01:02.140
况且不说 这种类型检查还是可选的

01:02.140 --> 01:05.140
你可以加 可以不加 你心情好就加

01:05.140 --> 01:09.140
如果你觉得加到很烦 那你就不加呗 对不对

01:09.140 --> 01:13.140
所以说咱们学习TS 学习成本是蛮低的了

01:13.140 --> 01:16.140
因为它里面其实如果紧急于

01:16.140 --> 01:18.140
以前的那种开发方式的话

01:18.140 --> 01:22.140
没有产生太大的改变 只是加了一些类型检查

01:22.140 --> 01:26.140
但是如果你想深入的去了解TS

01:26.140 --> 01:31.140
或者说你的公司里面你是开发一个大型项目

01:31.140 --> 01:34.140
非常复杂的项目 决定上这个TS

01:34.140 --> 01:39.140
再或者说你以后想进入一些大型的企业

01:39.140 --> 01:41.140
去做前端开发

01:41.140 --> 01:45.140
那么你学习TS的话就不能浮于表面了

01:45.140 --> 01:50.140
那你就会要了解TS里面一些比较深的东西

01:50.140 --> 01:52.140
就是境界部分要讲的

01:52.140 --> 01:56.140
境界部分讲这个东西的时候 我在规划的时候

01:56.140 --> 01:59.140
我在第一节课规划了一个对大家来说

01:59.140 --> 02:02.140
可能比较难的一个知识

02:02.140 --> 02:06.140
就是深入去理解内和接口

02:06.140 --> 02:10.140
在技术部分的时候我们讲到内 讲到接口

02:10.140 --> 02:13.140
我当时都是玩了很多坑 对吧

02:13.140 --> 02:17.140
我说有些东西我们要在境界部分慢慢来聊

02:17.140 --> 02:22.140
那现在我得把这些坑给它一个一个的填上

02:22.140 --> 02:25.140
因为讲内和接口的时候

02:25.140 --> 02:27.140
在技术部分我为什么不去想起讲

02:27.140 --> 02:31.140
因为内和接口里边它涉及到一个东西就是面向对象

02:31.140 --> 02:33.140
涉及到面向对象的概念

02:33.140 --> 02:37.140
可能有些同学应该很多同学都听说过这个东西

02:37.140 --> 02:41.140
不过有些同学对他可能有一些误解

02:41.140 --> 02:45.140
认为我们以前写的代码已经学习过面向对象了

02:45.140 --> 02:48.140
学接识的时候是不是已经学习过了

02:48.140 --> 02:51.140
我们学习过内也学习过对象

02:51.140 --> 02:54.140
两个大括号吧 建一个对象

02:54.140 --> 02:56.140
好像是已经学习过了面向对象开发

02:56.140 --> 02:58.140
实际上不是的

02:58.140 --> 03:01.140
不是说你写了内你写了对象

03:01.140 --> 03:03.140
就是在使用面向对象开发了

03:03.140 --> 03:07.140
哪怕加法 加法语言是一个面向对象的语言

03:07.140 --> 03:09.140
加法里面也可以写内 对吧

03:09.140 --> 03:13.140
当然你写了内那你一定可以创建对象 对不对

03:13.140 --> 03:17.140
但是你有了内有了对象 不一定你的开发

03:17.140 --> 03:19.140
就是面向对象开发

03:19.140 --> 03:22.140
实际上不一定的 这两个东西不能化等号了

03:22.140 --> 03:24.140
比方说咱们学习react

03:24.140 --> 03:28.140
react里面你写内没有 你肯定写了内

03:28.140 --> 03:32.140
因为他要求你写内主见 对不对

03:32.140 --> 03:35.140
因此你要写主见的话 你得必须要写内

03:35.140 --> 03:38.140
实际上你在开发的过程中 你当你回忆一下吧

03:38.140 --> 03:42.140
你除了react强制要求你写一个内主见的话

03:42.140 --> 03:46.140
除了这种情况之外 你还在其他地方写过什么内没有呢

03:46.140 --> 03:49.140
有些人说可能写过 有些人说没有写过

03:49.140 --> 03:53.140
但是不管你写没有写过 你的开发思维

03:53.140 --> 03:56.140
不一定是使用面向对象的开发思维

03:56.140 --> 04:00.140
今天我们首先我要说明的是

04:00.140 --> 04:03.140
这节课的时间可能会比较长

04:03.140 --> 04:07.140
这节课我们讲的是深入理解内核接口

04:07.140 --> 04:10.140
里面会涉及到面向对象的一些东西

04:10.140 --> 04:12.140
时间可能比较长

04:12.140 --> 04:15.140
所以大家可能不要想着一口气

04:15.140 --> 04:20.140
一天两天就把整个章节就看完

04:20.140 --> 04:24.140
要花多一点时间 特别是我讲了一些概念

04:24.140 --> 04:28.140
讲了一些东西的时候 大家需要去把它练习一下 巩固一下

04:28.140 --> 04:30.140
而且在看的过程中要许多思考

04:30.140 --> 04:35.140
而且这个章节后面还有一个跟这个章节相关的

04:35.140 --> 04:37.140
跟面向对象相关的一个练习

04:37.140 --> 04:39.140
这个练习也会做比较长的时间

04:39.140 --> 04:42.140
所以咱们这个课其实干货是蛮多的

04:42.140 --> 04:44.140
时长也是足够的

04:44.140 --> 04:47.140
我们会尽量的把我制造的东西

04:47.140 --> 04:49.140
以及需要大家了解的东西

04:49.140 --> 04:51.140
我会给大家讲清楚

04:51.140 --> 04:53.140
但是在讲这个面向对象的时候

04:53.140 --> 04:57.140
我不会过于的复杂

04:57.140 --> 05:00.140
因为面向对象的这个概念我之前也说过

05:00.140 --> 05:02.140
它不是说一朝一夕大家能够

05:02.140 --> 05:05.140
就彻底的理解了 彻底的顿误了

05:05.140 --> 05:07.140
那是不可能的

05:07.140 --> 05:11.140
所以说这一块东西我会有适当的保留

05:11.140 --> 05:14.140
就是我觉得大家目前现阶段

05:14.140 --> 05:17.140
还没有必要去接触太正的东西的时候呢

05:17.140 --> 05:18.140
我就不讲了

05:18.140 --> 05:20.140
我会讲到是可而止

05:20.140 --> 05:23.140
因为现在前端的大环境了

05:23.140 --> 05:25.140
面向对象这个概念

05:25.140 --> 05:27.140
在前端整个大环境里边

05:27.140 --> 05:29.140
还不是特别的重视

05:29.140 --> 05:31.140
还不是特别的重视

05:31.140 --> 05:34.140
因为毕竟现在的现状是很多的开发者

05:34.140 --> 05:36.140
特别是前端开发者

05:36.140 --> 05:39.140
并没有这个面向对象开发的这个概念

05:39.140 --> 05:41.140
并没有这个概念

05:41.140 --> 05:42.140
包括我之前上课的时候

05:42.140 --> 05:44.140
有的时候我做一些练习的时候

05:44.140 --> 05:46.140
哪怕一些很小很小的练习

05:46.140 --> 05:49.140
我说那我使用面向对象的方式

05:49.140 --> 05:50.140
给大家写一下

05:50.140 --> 05:52.140
看大家能不能接受

05:52.140 --> 05:53.140
发现完全接受不了

05:53.140 --> 05:56.140
哪怕很多学的好的同学就完全接受不了

05:56.140 --> 05:59.140
所以说现在前端的这个环境呢

05:59.140 --> 06:03.140
先实是很多开发者是不具有面向对象视为的

06:03.140 --> 06:05.140
但是未来会怎么样呢

06:05.140 --> 06:07.140
目前未来会怎么样呢

06:07.140 --> 06:09.140
就是说以后啊

06:09.140 --> 06:12.140
有可能这个东西会被提上日程

06:12.140 --> 06:14.140
在前端开发里边

06:14.140 --> 06:16.140
因此呢我们作为一个前端开发者

06:16.140 --> 06:18.140
越早的去接触这个概念的

06:18.140 --> 06:21.140
对我们以后的发展是越有好处的

06:21.140 --> 06:22.140
OK

06:22.140 --> 06:25.140
那么我们讲深入理解内核接口

06:25.140 --> 06:27.140
肯定要设立到面向对象

06:27.140 --> 06:29.140
咱们的第一节课

06:29.140 --> 06:31.140
就来讲面向对象概述

06:32.140 --> 06:34.140
讲它里边的一些概念

06:34.140 --> 06:36.140
讲它到底是什么东西

06:36.140 --> 06:38.140
它能解决什么样的问题

06:38.140 --> 06:39.140
为什么要去使用它

06:39.140 --> 06:41.140
把这些问题解释清楚

06:41.140 --> 06:43.140
也是清楚过后呢

06:43.140 --> 06:45.140
后边大家学习的心里面有个数

06:45.140 --> 06:48.140
对它有一个大体的概念

06:48.140 --> 06:50.140
好,首先我说第一个

06:51.140 --> 06:52.140
第一个

06:52.140 --> 06:54.140
就是估计什么

06:54.140 --> 06:56.140
现在我们学习的是前端

06:57.140 --> 07:00.140
为什么要讲面向对象

07:01.140 --> 07:03.140
咱们学习的是前端

07:03.140 --> 07:05.140
学习的是TS开发

07:05.140 --> 07:07.140
对吧,这本课学生是TS开发

07:07.140 --> 07:09.140
为什么我讲到TS的时候

07:09.140 --> 07:11.140
要去把这个面向对象

07:11.140 --> 07:13.140
拿进来讲

07:13.140 --> 07:15.140
主要是基于两点原因

07:15.140 --> 07:17.140
第一点原因呢

07:17.140 --> 07:20.140
是TS为前端

07:20.140 --> 07:23.140
面向对象开发

07:23.140 --> 07:26.140
带来了契机

07:26.140 --> 07:28.140
就说以前GS

07:28.140 --> 07:30.140
能不能做面向对象开发呢

07:30.140 --> 07:32.140
实际上是可以做的

07:32.140 --> 07:34.140
只不过做起来

07:34.140 --> 07:36.140
不是那么的舒服

07:36.140 --> 07:38.140
给大家看一下吧

07:38.140 --> 07:40.140
以前我用一个后台语言

07:40.140 --> 07:42.140
写过这么一个小的游戏

07:42.140 --> 07:44.140
当然这个游戏呢

07:44.140 --> 07:46.140
也不是一个完整的游戏了

07:46.140 --> 07:48.140
就是一个小的坦克大弹

07:48.140 --> 07:50.140
就这么一个游戏

07:50.140 --> 07:52.140
当时我是用后端语言写下不写的

07:52.140 --> 07:54.140
写了之后呢

07:54.140 --> 07:56.140
后来我讲前端的时候

07:56.140 --> 07:58.140
用前端做一做这个游戏

07:58.140 --> 08:00.140
后来我先自己去做

08:00.140 --> 08:02.140
自己去做的时候呢

08:02.140 --> 08:04.140
我也使用面向对象的方式

08:04.140 --> 08:06.140
来进行开发

08:06.140 --> 08:08.140
但是做着做着就会发现

08:08.140 --> 08:10.140
会很复杂做起来

08:10.140 --> 08:12.140
我把它做出来了

08:12.140 --> 08:14.140
但我觉得代码呢

08:14.140 --> 08:16.140
如果给学生去解释的话

08:16.140 --> 08:18.140
太过于复杂了

08:18.140 --> 08:20.140
学生不太理解

08:20.140 --> 08:22.140
但是以前我讲

08:22.140 --> 08:24.140
加法讲c下巴的时候呢

08:24.140 --> 08:26.140
讲的话绝对就很容易理解

08:26.140 --> 08:28.140
可能

08:28.140 --> 08:30.140
究习原因分析了一下原因

08:30.140 --> 08:32.140
JS之所以不太

08:32.140 --> 08:34.140
适用于面向对象来去开发

08:34.140 --> 08:36.140
像这种应用

08:36.140 --> 08:38.140
这也不算很复杂

08:38.140 --> 08:40.140
不算很复杂的应用

08:40.140 --> 08:42.140
之所以不太

08:42.140 --> 08:44.140
不太合适

08:44.140 --> 08:46.140
用JS去开发这个东西

08:46.140 --> 08:48.140
之所以不太合适

08:48.140 --> 08:50.140
究习主要的原因呢

08:50.140 --> 08:52.140
可能是因为

08:52.140 --> 08:54.140
JS里面它缺少了一个内容系统

08:54.140 --> 08:56.140
因为做面向对象开发的话

08:56.140 --> 08:58.140
这些东西会被分得很细

08:58.140 --> 09:00.140
你看这些

09:00.140 --> 09:02.140
你看这些看到的每一个东西

09:02.140 --> 09:04.140
它都是对象

09:04.140 --> 09:06.140
这个槽

09:06.140 --> 09:08.140
这个砖

09:08.140 --> 09:10.140
这些地方坦克

09:10.140 --> 09:12.140
这些发出的子弹全是对象

09:12.140 --> 09:14.140
那么像它会把它分得很细

09:14.140 --> 09:16.140
分得非常非常细

09:16.140 --> 09:18.140
而JS里面一旦把这些

09:18.140 --> 09:20.140
接口啊把这些东西分得很细

09:20.140 --> 09:22.140
很细过后呢

09:22.140 --> 09:24.140
就会产生一个问题

09:24.140 --> 09:26.140
它的函数非常多

09:26.140 --> 09:28.140
它要调用的接口非常多

09:28.140 --> 09:30.140
要使用的参数非常多

09:30.140 --> 09:32.140
而你开发的东西

09:32.140 --> 09:34.140
这些东西越多

09:34.140 --> 09:36.140
你就越容易发生错误

09:36.140 --> 09:38.140
就非常容易发生错误

09:38.140 --> 09:40.140
大家看这么一个游戏

09:40.140 --> 09:42.140
也是以前我用那个

09:42.140 --> 09:44.140
谁瞎不写的

09:44.140 --> 09:46.140
像这些东西

09:46.140 --> 09:48.140
能不能用JS开发我也尝试过

09:48.140 --> 09:50.140
开发能开发不舒服

09:50.140 --> 09:52.140
不能开发

09:52.140 --> 09:54.140
但是开发起来了总觉得很不舒服

09:54.140 --> 09:56.140
除非利用其他的开发方式

09:58.140 --> 10:00.140
除非利用其他的开发方式

10:00.140 --> 10:02.140
否则的话利用面向对象开发方式的话

10:02.140 --> 10:04.140
会导致很多的问题

10:04.140 --> 10:06.140
这些问题呢就是我说的

10:08.140 --> 10:10.140
JS语言

10:10.140 --> 10:12.140
没有内情检查

10:12.140 --> 10:14.140
如果使用面向对象开发

10:14.140 --> 10:16.140
如果使用

10:16.140 --> 10:18.140
面向对象的

10:18.140 --> 10:20.140
方式开发

10:20.140 --> 10:22.140
不是说不行

10:22.140 --> 10:24.140
它也能继承嘛对吧

10:24.140 --> 10:26.140
也可以写内

10:26.140 --> 10:28.140
会产生大量的

10:28.140 --> 10:30.140
接口

10:30.140 --> 10:32.140
因为面向对象里边

10:32.140 --> 10:34.140
它会把东西分得很细很细

10:34.140 --> 10:36.140
哪怕一个子弹

10:36.140 --> 10:38.140
我都可能把它做成一个内

10:38.140 --> 10:40.140
它会产生大量的接口

10:40.140 --> 10:42.140
就是接口我们要掉

10:42.140 --> 10:44.140
接口是什么

10:44.140 --> 10:46.140
就是我要访问的东西

10:46.140 --> 10:48.140
我要调用的函数

10:48.140 --> 10:50.140
我要创建的内

10:50.140 --> 10:52.140
内里面构造函数有哪些参数

10:52.140 --> 10:54.140
指的是这些东西

10:54.140 --> 10:56.140
而大量的接口

10:56.140 --> 10:58.140
而大量的接口

10:58.140 --> 11:00.140
会导致

11:00.140 --> 11:02.140
调用

11:02.140 --> 11:04.140
调用复杂度

11:04.140 --> 11:08.540
去整

11:08.540 --> 11:10.540
就是有接口我们需要去调用它

11:10.540 --> 11:12.540
那么调用的时候呢

11:12.540 --> 11:14.540
这个时候调用什么接口

11:14.540 --> 11:16.540
复杂度又去整了

11:16.540 --> 11:18.540
这种复杂度

11:18.540 --> 11:20.540
必须通过

11:20.540 --> 11:22.540
严格的

11:22.540 --> 11:24.540
内形

11:24.540 --> 11:28.100
检查

11:28.100 --> 11:30.100
来避免

11:30.100 --> 11:32.100
错误

11:32.100 --> 11:34.100
如果没有严格的内形检查的话

11:34.100 --> 11:36.100
我们全评的是什么呢

11:36.100 --> 11:38.100
全评的是记忆力

11:38.100 --> 11:40.100
或者是说

11:40.100 --> 11:42.100
官方稳当

11:42.100 --> 11:44.100
或者说详细的稳当

11:44.100 --> 11:46.100
这种记忆力

11:46.100 --> 11:48.100
和注释

11:48.100 --> 11:50.100
或者是稳当

11:50.100 --> 11:52.100
它是没有强约数力的

11:52.100 --> 11:54.100
就是尽管

11:54.100 --> 11:56.100
可以使用注释

11:56.100 --> 11:58.100
或稳当

11:58.100 --> 12:00.100
或记忆力

12:00.100 --> 12:02.100
我们接使

12:02.100 --> 12:04.100
我说前段开发真的是不容易

12:04.100 --> 12:06.100
好多东西要全评记

12:06.100 --> 12:08.100
尽管可以通过这些

12:08.100 --> 12:10.100
这些方式

12:10.100 --> 12:12.100
可以使用这些方式

12:12.100 --> 12:14.100
他们是没有强约数力的

12:14.100 --> 12:16.100
他们没有强约数力

12:18.100 --> 12:20.100
强约数力

12:20.100 --> 12:22.100
就是你写错了

12:22.100 --> 12:24.100
他也不会告诉你这个地方写错了

12:24.100 --> 12:26.100
他认为有可能是正确的

12:26.100 --> 12:28.100
真是因为如此

12:28.100 --> 12:30.100
接使不太适合

12:30.100 --> 12:32.100
特别特别复杂的程序

12:32.100 --> 12:34.100
因此接使

12:34.100 --> 12:36.100
经常看到一些

12:36.100 --> 12:38.100
技术大神的演讲中也说到这个问题

12:38.100 --> 12:40.100
接使天生

12:40.100 --> 12:42.100
这个语言本身就不是用来购建

12:42.100 --> 12:44.100
大雄应用的

12:44.100 --> 12:46.100
因为他天生做这个语言的时候

12:46.100 --> 12:48.100
开发这个语言的时候

12:48.100 --> 12:50.100
他想的就是怎么去在网页上

12:50.100 --> 12:52.100
做一些小的效果

12:52.100 --> 12:54.100
这个语言越简单越好

12:54.100 --> 12:56.100
入门越简单越好

12:56.100 --> 12:58.100
越容易上手越好

12:58.100 --> 13:00.100
所以说接使

13:00.100 --> 13:02.100
尽管现在有那么多的框架

13:02.100 --> 13:04.100
来解决很多的问题

13:04.100 --> 13:06.100
但是这个语言天生的一些缺陷

13:06.100 --> 13:08.100
并没有得到解决

13:08.100 --> 13:10.100
只是那个东西

13:10.100 --> 13:12.100
根源 弱内型 解释型

13:12.100 --> 13:14.100
这种两种

13:14.100 --> 13:16.100
它没有发生改变

13:16.100 --> 13:18.100
那么这两种没发生改变的话

13:18.100 --> 13:20.100
这种大型应用用

13:20.100 --> 13:22.100
都是不太合适的

13:22.100 --> 13:24.100
所以说接使他会有这个问题

13:24.100 --> 13:26.100
那么TS出来过后

13:26.100 --> 13:28.100
他带来了内询系统

13:28.100 --> 13:30.100
TS带来了

13:30.100 --> 13:32.100
完整的内询系统

13:32.100 --> 13:34.100
因此

13:34.100 --> 13:36.100
开发

13:36.100 --> 13:38.100
复杂程序时

13:38.100 --> 13:40.100
无论你接口有多少

13:40.100 --> 13:42.100
无论你接口有多少

13:42.100 --> 13:44.100
我都可以进行完整的

13:44.100 --> 13:46.100
内询检查

13:46.100 --> 13:48.100
开发复杂程序时

13:48.100 --> 13:50.100
无论

13:50.100 --> 13:52.100
接口

13:52.100 --> 13:54.100
数量有多少

13:54.100 --> 13:56.100
都可以

13:56.100 --> 13:58.100
获得完整的

13:58.100 --> 14:00.100
内询检查

14:00.100 --> 14:02.100
并且

14:02.100 --> 14:04.100
这种检查

14:04.100 --> 14:06.100
是具有强约速力的

14:06.100 --> 14:08.100
是具有强

14:08.100 --> 14:10.100
约速力的

14:10.100 --> 14:12.100
就是说

14:12.100 --> 14:14.100
不是说我写错了就错了

14:14.100 --> 14:16.100
那不行 你必须要写正确

14:16.100 --> 14:18.100
他会给你包错的

14:18.100 --> 14:20.100
真是因为有了强约速力

14:20.100 --> 14:22.100
我们就有机会去写一些复杂的程序

14:22.100 --> 14:24.100
我们就有机会把一些

14:24.100 --> 14:26.100
东西尽量的抽象化

14:26.100 --> 14:28.100
尽量的给它分得很细

14:28.100 --> 14:30.100
那产生大量的接口其实无所谓的

14:30.100 --> 14:32.100
因为我们有强约速力的

14:32.100 --> 14:34.100
内询检查

14:34.100 --> 14:36.100
我们写错了 它会往上提示我

14:36.100 --> 14:38.100
不要小看这个东西

14:38.100 --> 14:40.100
当我们的系统

14:40.100 --> 14:42.100
越来越复杂 接口越来越多的时候

14:42.100 --> 14:44.100
我这样给你说吧

14:44.100 --> 14:46.100
比方说咱们一个小的应用里边

14:46.100 --> 14:48.100
就这个

14:48.100 --> 14:50.100
就这个坦克大战

14:50.100 --> 14:52.100
就这个坦克大战里边

14:52.100 --> 14:54.100
这个东西

14:54.100 --> 14:56.100
我现在告诉里边

14:56.100 --> 14:58.100
这里面有十五个内

14:58.100 --> 15:00.100
有十五个内

15:00.100 --> 15:02.100
一共加起来

15:02.100 --> 15:04.100
提供了可能

15:04.100 --> 15:06.100
将近一百个函数

15:06.100 --> 15:08.100
一百个方法

15:08.100 --> 15:10.100
那么这个时候告诉你没有文档

15:10.100 --> 15:12.100
可能只有简单的几行注释

15:12.100 --> 15:14.100
你能用吗

15:14.100 --> 15:16.100
你敢去调用吗 这里面的东西

15:16.100 --> 15:18.100
而且这些参数传递极具复杂

15:18.100 --> 15:20.100
极其复杂

15:20.100 --> 15:22.100
那么这个时候你用起来就很牢火

15:22.100 --> 15:24.100
就非常非常牢火

15:24.100 --> 15:26.100
你会发现写的代码

15:26.100 --> 15:28.100
每一步 每一句代码

15:28.100 --> 15:30.100
每一句代码埋着全是隐患

15:30.100 --> 15:32.100
因为你不知道该怎么去调用

15:32.100 --> 15:34.100
不知道要传哪些东西

15:34.100 --> 15:36.100
传的到底是不是正确的

15:36.100 --> 15:38.100
这个里是数字还是字母圈

15:38.100 --> 15:40.100
这里是一个对象

15:40.100 --> 15:42.100
对象里面有哪些属性地

15:42.100 --> 15:44.100
完全不知道的

15:44.100 --> 15:46.100
就会产生这样的问题

15:46.100 --> 15:48.100
但是TS

15:48.100 --> 15:50.100
它带来的类型系统

15:50.100 --> 15:52.100
因此我们可以

15:52.100 --> 15:54.100
尝试着用它来进行面向对象开发

15:54.100 --> 15:56.100
这是TS

15:56.100 --> 15:58.100
这个点为什么我要讲面向对象

15:58.100 --> 16:00.100
因为TS它带来的这个器机

16:00.100 --> 16:02.100
我们就有机会在前端使用

16:02.100 --> 16:04.100
面向对象去开发一些

16:04.100 --> 16:06.100
复杂的应用了

16:06.100 --> 16:08.100
这是关于这个点

16:08.100 --> 16:10.100
第二个原因是

16:10.100 --> 16:12.100
面向对象中

16:12.100 --> 16:14.100
就是咱们为什么要学习

16:14.100 --> 16:16.100
这个面向对象

16:16.100 --> 16:18.100
面向对象中有许多

16:18.100 --> 16:22.100
非常成熟的模式

16:22.100 --> 16:24.100
能处理

16:24.100 --> 16:27.800
复杂问题

16:27.800 --> 16:29.800
其实为什么

16:29.800 --> 16:31.800
面向对象它能处理复杂问题呢

16:31.800 --> 16:33.800
是不是说

16:33.800 --> 16:35.800
只有面向对象这种方式

16:35.800 --> 16:37.800
才能处理复杂问题呢

16:37.800 --> 16:39.800
实际上不是的

16:39.800 --> 16:41.800
咱们最近几年不是新起一个

16:41.800 --> 16:43.800
函数式编程嘛

16:43.800 --> 16:45.800
函数式编程它也能处理复杂问题

16:45.800 --> 16:47.800
包括

16:47.800 --> 16:49.800
面向过程编程

16:49.800 --> 16:51.800
就大家现在用的方式

16:51.800 --> 16:53.800
能不能处理复杂问题呢

16:53.800 --> 16:55.800
也能处理复杂问题

16:55.800 --> 16:57.800
只不过呢我们之所以

16:57.800 --> 16:59.800
要处理复杂问题的时候

16:59.800 --> 17:01.800
目前啊首选的方案

17:01.800 --> 17:03.800
是面向对象这种方案

17:03.800 --> 17:05.800
为什么呢是因为面向对象

17:05.800 --> 17:07.800
已经有很多很多年的

17:07.800 --> 17:09.800
它在大型应用领域

17:09.800 --> 17:11.800
特别是复杂的应用

17:11.800 --> 17:13.800
这个场景下边

17:13.800 --> 17:15.800
它已经工作的非常非常好了

17:15.800 --> 17:17.800
我们有很多的经验

17:17.800 --> 17:19.800
就先前呢用加把开发

17:19.800 --> 17:21.800
用c sharp开发这些

17:21.800 --> 17:23.800
然后呢已经总结出来了

17:23.800 --> 17:25.800
非常非常多的处理这种

17:25.800 --> 17:27.800
复杂问题的经验

17:27.800 --> 17:29.800
那么这种经验是非常非常宝贵的

17:29.800 --> 17:31.800
如果我现在

17:31.800 --> 17:33.800
使用函数式编程

17:33.800 --> 17:35.800
这种方式

17:35.800 --> 17:37.800
我们又重新去构建一套

17:37.800 --> 17:39.800
这样的经验的话

17:39.800 --> 17:41.800
这个时间是会比较漫长的

17:41.800 --> 17:43.800
因此呢像函数式编程

17:43.800 --> 17:45.800
这种方式啊还需要

17:45.800 --> 17:47.800
大量很长的时间的一种

17:47.800 --> 17:49.800
积累

17:49.800 --> 17:51.800
非常非常成熟了

17:51.800 --> 17:53.800
就是在过去

17:53.800 --> 17:55.800
在过去的很多年中

17:57.800 --> 17:59.800
已经

17:59.800 --> 18:01.800
在复杂

18:01.800 --> 18:03.800
大型应用

18:03.800 --> 18:05.800
或复杂领域

18:05.800 --> 18:07.800
面向对象

18:09.800 --> 18:11.800
已经积累了

18:11.800 --> 18:13.800
非常多的

18:13.800 --> 18:15.800
经验

18:15.800 --> 18:17.800
这些经验呢都已经成为模式了

18:17.800 --> 18:19.800
就是一种

18:19.800 --> 18:21.800
固定的方式来处理某一些问题

18:21.800 --> 18:23.800
比如说全线管理啊

18:23.800 --> 18:25.800
比方说

18:25.800 --> 18:27.800
工作流啊之类的

18:27.800 --> 18:29.800
一些

18:29.800 --> 18:31.800
复杂的领域呢就已经

18:31.800 --> 18:33.800
形成了一种固定的模式了

18:33.800 --> 18:35.800
那么这种模式呢

18:35.800 --> 18:37.800
这种经验是非常宝贵的

18:37.800 --> 18:39.800
而现在前端呢

18:39.800 --> 18:41.800
特别缺乏这个东西

18:41.800 --> 18:43.800
前端一旦遇到一些

18:43.800 --> 18:45.800
类似的复杂应用场景

18:45.800 --> 18:47.800
导致了很麻烦

18:47.800 --> 18:49.800
而现在呢我们

18:49.800 --> 18:51.800
TES给我们面向对象开发带来了

18:51.800 --> 18:53.800
契机

18:53.800 --> 18:55.800
我们在前端呢就有能力

18:55.800 --> 18:57.800
或者说有机会来出用

18:57.800 --> 18:59.800
面向对象来处理这些复杂问题了

18:59.800 --> 19:01.800
基于上面两点原因啊

19:01.800 --> 19:03.800
我先解释一下

19:03.800 --> 19:05.800
为什么我要去讲这个面向对象

19:05.800 --> 19:07.800
而且呢为难了

19:07.800 --> 19:09.800
其实现在呢已经发现啊

19:09.800 --> 19:11.800
有一些框架

19:11.800 --> 19:13.800
在开始往这个方面着手了

19:13.800 --> 19:15.800
就说大家有没有听说过这个

19:15.800 --> 19:20.010
nest要解释

19:20.010 --> 19:22.010
这个东西是啥呢

19:22.010 --> 19:24.010
它相当于

19:24.010 --> 19:25.010
相

19:25.010 --> 19:28.010
相当于是前端的

19:28.010 --> 19:30.010
java sprain

19:30.010 --> 19:32.010
这很恐怖了啊

19:32.010 --> 19:34.010
java sprain有些同学听说过

19:34.010 --> 19:36.010
有些同学没有听说过

19:36.010 --> 19:38.010
它是java语言的

19:38.010 --> 19:40.010
后端的一种解决方案

19:40.010 --> 19:42.010
一套完整的解决方案

19:42.010 --> 19:44.010
它里面有很多很多东西

19:44.010 --> 19:46.010
对象来变现出来的

19:46.010 --> 19:48.010
而nest的解释

19:48.010 --> 19:50.010
它就已经相当于是java sprain了

19:50.010 --> 19:52.010
我当时看了一下

19:52.010 --> 19:54.010
看了一下它的官方文章

19:54.010 --> 19:56.010
非常恐怖

19:56.010 --> 19:58.010
基本上是把java sprain那一套东西

19:58.010 --> 20:00.010
全部搬过来的

20:00.010 --> 20:02.010
而它是基于什么

20:02.010 --> 20:04.010
它基于的是ts

20:04.010 --> 20:06.010
它为什么基于ts不能直接用ts呢

20:06.010 --> 20:08.010
因为用ts的话

20:08.010 --> 20:10.010
里面有那么多的接口

20:10.010 --> 20:12.010
肯定是非常非常容易出问题的

20:12.010 --> 20:14.010
所以说有了ts过后

20:14.010 --> 20:16.010
才为这个东西的出现

20:16.010 --> 20:18.010
带来了奇迹

20:18.010 --> 20:20.010
比方说这里面

20:20.010 --> 20:22.010
我们今后还可能会

20:22.010 --> 20:24.010
接触到一些库

20:24.010 --> 20:26.010
比如说type orm

20:26.010 --> 20:28.010
这是个orm框架

20:28.010 --> 20:30.010
当然大家可能不太清楚

20:30.010 --> 20:32.010
什么叫orm框架

20:32.010 --> 20:34.010
就是把数据库

20:34.010 --> 20:36.010
数据库里面存出的数据

20:36.010 --> 20:38.010
它的结构映射到对象里面

20:38.010 --> 20:40.010
咱们之前学mongo DB的时候

20:40.010 --> 20:42.010
mongo DB里面不是一个库吗

20:42.010 --> 20:44.010
叫mongo s

20:44.010 --> 20:46.010
mongo s这个库

20:46.010 --> 20:48.010
其实也可以把它看做

20:48.010 --> 20:51.510
看做是一个orm框架

20:51.510 --> 20:53.510
它其实也可以

20:53.510 --> 20:55.510
看做是一个orm框架

20:55.510 --> 20:57.510
但是这个框架呢

20:57.510 --> 20:59.510
它里面提供的功能比较简单

20:59.510 --> 21:01.510
比较简单

21:01.510 --> 21:03.510
但是type orm

21:03.510 --> 21:05.510
它已经非常类似于

21:05.510 --> 21:07.510
csharp里面的

21:07.510 --> 21:09.510
非常类似于csharp

21:09.510 --> 21:11.510
EF

21:11.510 --> 21:13.510
大家可能没有接触过

21:13.510 --> 21:15.510
总之我讲这些例子

21:15.510 --> 21:17.510
讲这些

21:17.510 --> 21:19.510
这些案例的原因呢

21:19.510 --> 21:21.510
是要告诉大家

21:21.510 --> 21:23.510
现在后端的

21:23.510 --> 21:25.510
某些框架

21:25.510 --> 21:27.510
已经在朝这个方向走了

21:27.510 --> 21:29.510
但是未来前端的大方向

21:29.510 --> 21:31.510
是不是朝这个方向呢

21:31.510 --> 21:33.510
我个人不敢忘家断也

21:33.510 --> 21:35.510
但是呢我觉得

21:35.510 --> 21:37.510
面向对象竟然有这么多

21:37.510 --> 21:39.510
前端又再变得越来越复杂

21:39.510 --> 21:41.510
那么

21:41.510 --> 21:43.510
面向对象跟前端的结合

21:43.510 --> 21:45.510
我觉得是自然而然

21:45.510 --> 21:47.510
会发生的事情

21:47.510 --> 21:49.510
都是我个人的理解

21:49.510 --> 21:51.510
好 这是关于这两点

21:51.510 --> 21:53.510
咱们为什么要学习面向对象

21:53.510 --> 21:55.510
其实咱们学习对我们自身而言

21:55.510 --> 21:57.510
就是为我们的未来

21:57.510 --> 21:59.510
做考虑

21:59.510 --> 22:01.510
咱们未来的话

22:01.510 --> 22:03.510
我们越早的去接触这个面向对象

22:03.510 --> 22:05.510
越早的去理解这种模式

22:05.510 --> 22:07.510
越来越复杂

22:07.510 --> 22:09.510
面向对象呼声越来越高

22:09.510 --> 22:11.510
那么这个时候呢我们的起点

22:11.510 --> 22:13.510
就会比别人高得多

22:13.510 --> 22:15.510
这也是为什么我要在

22:15.510 --> 22:17.510
这个视频课程里边去加入

22:17.510 --> 22:18.510
这一部分内容

22:18.510 --> 22:19.510
因为这一部分内容其实很多啊

22:19.510 --> 22:21.510
东西真的很多要讲很久的

22:21.510 --> 22:23.510
就这几课

22:23.510 --> 22:25.510
比方把它做成一个章节

22:25.510 --> 22:27.510
其他里面东西很多要讲很久

22:27.510 --> 22:29.510
我说也是反复的考虑

22:29.510 --> 22:31.510
也跟其他老师也沟通过

22:31.510 --> 22:33.510
所以呢这一课我最后决定

22:33.510 --> 22:35.510
还是把面向对象这个东西

22:35.510 --> 22:37.510
好好地把讲一下

22:37.510 --> 22:39.510
当然我不会讲的太深

22:39.510 --> 22:41.510
毕竟我们是前端你明白吗

22:41.510 --> 22:42.510
毕竟不是后端

22:42.510 --> 22:43.510
因此我讲的过程中

22:43.510 --> 22:44.510
不会讲的太深

22:44.510 --> 22:45.510
我保证呢

22:45.510 --> 22:47.510
只要你之前学习的介石

22:47.510 --> 22:49.510
什么rex 五u啊那些

22:49.510 --> 22:51.510
介石动物操作没有什么问题的话

22:51.510 --> 22:53.510
这一块你学习起来你是学得懂的

22:53.510 --> 22:55.510
能够保证你学得懂

22:55.510 --> 22:57.510
当然你需要经过

22:57.510 --> 22:59.510
还要经过自身的努力

22:59.510 --> 23:01.510
你学的过程中呢

23:01.510 --> 23:03.510
学这个东西的过程中

23:03.510 --> 23:05.510
你需要多练习多思考

23:05.510 --> 23:07.510
多去自己去实践

23:09.510 --> 23:11.510
好了这次关于第一个点

23:11.510 --> 23:13.510
为什么要讲面向对象

23:13.510 --> 23:14.510
第二个点

23:14.510 --> 23:15.510
我们来说一下

23:15.510 --> 23:17.510
什么是面向对象

23:17.510 --> 23:21.020
就讲讲它的概念了

23:21.020 --> 23:23.020
之前我不是一直在吹牛吗

23:23.020 --> 23:24.020
一直在说

23:24.020 --> 23:25.020
你们之前做个开发

23:25.020 --> 23:26.020
都不是面向对象开发

23:26.020 --> 23:28.020
那什么是要面向对象

23:28.020 --> 23:30.020
真的要解释一下

23:30.020 --> 23:31.020
首先面向对象呢

23:31.020 --> 23:33.020
它的单词是从国外传过来的

23:33.020 --> 23:35.020
面向对象

23:35.020 --> 23:37.020
它的单词呢是

23:37.020 --> 23:39.020
叫做oriented

23:39.020 --> 23:41.020
oriented object

23:41.020 --> 23:43.020
它这么个单词

23:43.020 --> 23:45.020
所以说面向对象呢也简称

23:45.020 --> 23:47.020
简称

23:47.020 --> 23:49.020
OO

23:49.020 --> 23:51.020
表示的面向对象

23:51.020 --> 23:53.020
这个oriented的什么意思呢

23:53.020 --> 23:55.020
表示的是基于什么

23:55.020 --> 23:57.020
基于以什么为出发点

23:58.020 --> 24:00.020
基于什么

24:00.020 --> 24:02.020
比方说

24:02.020 --> 24:03.020
我们说

24:03.020 --> 24:05.020
三个世界不是老师有句话吗

24:05.020 --> 24:07.020
老师听说过这么一句话

24:07.020 --> 24:09.020
就是一切

24:09.020 --> 24:11.020
以经济建设为中心

24:11.020 --> 24:13.020
就是这个基于的意思

24:13.020 --> 24:15.020
一切基于经济建设

24:15.020 --> 24:16.020
就是这个意思

24:16.020 --> 24:17.020
基于什么什么

24:17.020 --> 24:19.020
以什么为出发点

24:19.020 --> 24:21.020
objects表示什么意思呢

24:21.020 --> 24:23.020
objects表示的是事物

24:23.020 --> 24:25.020
事物

24:26.020 --> 24:28.020
事物这个词就很宽泛了

24:28.020 --> 24:31.020
这个世界上有太多太多的事物了

24:31.020 --> 24:32.020
人

24:32.020 --> 24:33.020
我们用的这个笔记吧

24:33.020 --> 24:34.020
鼠标垫

24:34.020 --> 24:36.020
我周围的

24:36.020 --> 24:37.020
大家说吗

24:37.020 --> 24:38.020
我旁边放了个牙齿

24:38.020 --> 24:40.020
这个牙齿也是个事物

24:40.020 --> 24:42.020
咱们可以看见的空气

24:42.020 --> 24:44.020
或者是咱们在书中学到的一些概念

24:44.020 --> 24:46.020
都是可以算是事物

24:46.020 --> 24:47.020
事物是可以是抽象的

24:47.020 --> 24:49.020
也可以是具象的

24:49.020 --> 24:51.020
因此这个翻译我也不知道

24:51.020 --> 24:53.020
最开始是谁把它翻译过来的

24:54.020 --> 24:57.020
其实我第一次听这个词的时候

24:57.020 --> 25:00.020
对到这个英文的时候

25:00.020 --> 25:01.020
我怎么看

25:01.020 --> 25:03.020
怎么觉得不对劲

25:03.020 --> 25:05.020
怎么翻译成这个样子呢

25:05.020 --> 25:07.020
其实它这个英文是很好解释的

25:07.020 --> 25:10.020
就是一切以事物为出发点

25:10.020 --> 25:12.020
来去考虑问题

25:12.020 --> 25:14.020
一切基于事物

25:14.020 --> 25:15.020
有哪些东西

25:15.020 --> 25:16.020
有哪些事物

25:16.020 --> 25:18.020
这个系统里面有哪些事物

25:18.020 --> 25:20.020
基于这个东西去考虑问题

25:20.020 --> 25:21.020
其实它这个英文的话

25:21.020 --> 25:22.020
反而非常容易理解

25:22.020 --> 25:24.020
这个中文反而不太容易理解

25:24.020 --> 25:26.020
不过现在大家都这样说了

25:26.020 --> 25:29.020
所以我们也不会去改变它的教法

25:29.020 --> 25:31.020
这是面向对象

25:31.020 --> 25:32.020
它什么意思呢

25:32.020 --> 25:34.020
面向对象

25:34.020 --> 25:36.020
是一种编程思想

25:40.020 --> 25:43.020
它提出一切

25:43.020 --> 25:47.580
以对象

25:47.580 --> 25:49.580
以对象

25:49.580 --> 25:52.580
为切入点

25:52.580 --> 25:54.580
思考问题

25:54.580 --> 25:55.580
思考整个程序

25:55.580 --> 25:56.580
整个问题

25:56.580 --> 25:58.580
所以说面向对象

25:58.580 --> 26:00.580
不是某一个计算机语言

26:00.580 --> 26:02.580
不是说面向对象是

26:02.580 --> 26:03.580
面向对象是加碼

26:03.580 --> 26:05.580
面向对象是csh

26:05.580 --> 26:06.580
不能这样子说的

26:06.580 --> 26:08.580
面向对象是一种编程思想

26:08.580 --> 26:09.580
它指的是

26:09.580 --> 26:11.580
我们在思考一个问题的时候

26:11.580 --> 26:13.580
我们的出发点

26:13.580 --> 26:15.580
化分对象

26:15.580 --> 26:16.580
作为出发点

26:16.580 --> 26:18.580
是用这种方式来思考程序的

26:18.580 --> 26:20.580
那么这是一种编程思想

26:20.580 --> 26:21.580
还有没有其他编程思想呢

26:21.580 --> 26:22.580
实际上是有的

26:22.580 --> 26:24.580
还有其他编程思想

26:24.580 --> 26:26.580
我们常见的

26:26.580 --> 26:28.580
常见的编程思想

26:28.580 --> 26:30.580
还有就是面向过程

26:30.580 --> 26:32.580
面向过程

26:32.580 --> 26:33.580
还有是什么呢

26:33.580 --> 26:36.580
还有是韩束士

26:36.580 --> 26:38.580
韩束士编程

26:38.580 --> 26:40.580
我说一下这两个吧

26:40.580 --> 26:42.580
其实不是说

26:42.580 --> 26:44.580
面向对象里边

26:44.580 --> 26:46.580
面向过程里边

26:46.580 --> 26:47.580
其实写的是什么

26:47.580 --> 26:48.580
就是模块画

26:48.580 --> 26:50.580
最重要的就是模块画

26:50.580 --> 26:52.580
就是写模块画的代码

26:52.580 --> 26:53.580
那是不是我们写的

26:53.580 --> 26:54.580
面向对象过后

26:54.580 --> 26:55.580
就不写模块画的代码了

26:55.580 --> 26:57.580
那不是这个意思啊

26:57.580 --> 26:58.580
比方说

26:58.580 --> 26:59.580
韩束士编程

26:59.580 --> 27:00.580
那也就是说

27:00.580 --> 27:01.580
我们不使用韩束士编程的话

27:01.580 --> 27:03.580
我就不写韩束了哦

27:03.580 --> 27:04.580
那也不是这个意思啊

27:04.580 --> 27:06.580
也不是这个意思

27:06.580 --> 27:08.580
他们这三种编程思想

27:08.580 --> 27:09.580
指的是

27:09.580 --> 27:10.580
切入点

27:10.580 --> 27:12.580
我以什么样的方式

27:12.580 --> 27:13.580
作为切入点

27:13.580 --> 27:14.580
去思考问题

27:14.580 --> 27:16.580
大家发现没有

27:16.580 --> 27:17.580
我现在问大家一个问题啊

27:17.580 --> 27:22.580
开发最重要

27:22.580 --> 27:26.580
最难的是什么

27:26.580 --> 27:27.580
学开发

27:27.580 --> 27:29.580
你们都是学开发过来的

27:29.580 --> 27:30.580
已经学了那么多指示了

27:30.580 --> 27:31.580
那你回忆一下

27:31.580 --> 27:33.580
学开发最重要的

27:33.580 --> 27:34.580
最难的是什么

27:34.580 --> 27:35.580
它又难

27:35.580 --> 27:37.580
它又非常重要

27:37.580 --> 27:39.580
有同学已经说出来了

27:39.580 --> 27:40.580
是啥

27:40.580 --> 27:42.580
思维

27:42.580 --> 27:45.580
其实与法那些复杂吗

27:45.580 --> 27:46.580
你定一个数组

27:47.580 --> 27:49.580
这个数组的与法它复杂吗

27:49.580 --> 27:50.580
不复杂啊在街市里

27:50.580 --> 27:51.580
有啥复杂的呀

27:51.580 --> 27:53.580
循环的与法复杂吗

27:53.580 --> 27:55.580
循环的与法也不复杂啊

27:55.580 --> 27:57.580
我经常听说一个问题就是

27:57.580 --> 27:58.580
老师啊

27:58.580 --> 28:00.580
你讲的我都懂

28:00.580 --> 28:01.580
我都听懂了

28:01.580 --> 28:02.580
你做的你按你练习

28:02.580 --> 28:04.580
我跟着你抢我一人抢出来

28:04.580 --> 28:05.580
但是放到我自己做的话

28:05.580 --> 28:06.580
我就做不出来

28:06.580 --> 28:07.580
我就识写不出来

28:07.580 --> 28:08.580
为什么

28:08.580 --> 28:10.580
一思维没有建立起来

28:10.580 --> 28:12.580
而建立思维是

28:12.580 --> 28:14.580
学开发最重要

28:14.580 --> 28:16.580
也是最难得的这一部分

28:16.580 --> 28:18.580
而面向对象

28:18.580 --> 28:20.580
面向过程也好

28:20.580 --> 28:21.580
面向对象也好

28:21.580 --> 28:22.580
韩束是编程也好

28:22.580 --> 28:24.580
他们指的都是编程思维

28:24.580 --> 28:25.580
很多同学说

28:25.580 --> 28:27.580
老师我拿到一个程序

28:27.580 --> 28:28.580
我拿到你

28:28.580 --> 28:30.580
让我拿到一个项目的时候

28:30.580 --> 28:31.580
我无从下手

28:31.580 --> 28:33.580
不知道该怎么去下这个手

28:33.580 --> 28:34.580
为什么不能下手

28:34.580 --> 28:36.580
因为你找不到一个切入点

28:36.580 --> 28:38.580
你找不到一个切入点

28:38.580 --> 28:40.580
而这三种思维

28:40.580 --> 28:42.580
都是给你提供切入点的

28:42.580 --> 28:44.580
你以什么样的切入点

28:44.580 --> 28:46.580
来思考整个程序

28:46.580 --> 28:48.580
你用不同的思维

28:48.580 --> 28:49.580
写出来的代码

28:49.580 --> 28:51.580
是完全不一样的

28:51.580 --> 28:53.580
当然就算

28:53.580 --> 28:55.580
用了这三种思维之后

28:55.580 --> 28:56.580
用了这个面向对象

28:56.580 --> 28:57.580
或者是面向过程

28:57.580 --> 28:58.580
或者是韩束的编程

28:58.580 --> 28:59.580
用了思维过后

28:59.580 --> 29:00.580
一些细节的地方

29:00.580 --> 29:02.580
你思考的方向也不一样

29:02.580 --> 29:03.580
所以说咱们说

29:03.580 --> 29:05.580
这个世界上不存在

29:05.580 --> 29:07.580
只要是两个人写的代码

29:07.580 --> 29:08.580
肯定不会一模一样

29:08.580 --> 29:10.580
多多少少会有一些差异

29:11.580 --> 29:14.580
那么这三种编程思维

29:14.580 --> 29:16.580
它提供的是切入点

29:16.580 --> 29:18.580
什么样的切入点呢

29:18.580 --> 29:20.580
我们举个例子

29:20.580 --> 29:21.580
举个例子

29:21.580 --> 29:22.580
比方说这里

29:22.580 --> 29:24.580
就是个坦克大战

29:24.580 --> 29:27.580
游戏是最好来锻炼思维的

29:27.580 --> 29:29.580
做游戏的话

29:29.580 --> 29:30.580
这个坦克大战的

29:30.580 --> 29:31.580
做一个坦克大战

29:31.580 --> 29:33.580
你会怎么来想这个程序

29:33.580 --> 29:35.580
怎么来开发这个程序

29:36.580 --> 29:38.580
你可能是这样讲的

29:38.580 --> 29:41.580
这个程序我怎么来开发呢

29:41.580 --> 29:42.580
我首先

29:42.580 --> 29:44.580
假设在网页上做

29:44.580 --> 29:46.580
我首先建一个DIV

29:46.580 --> 29:47.580
对吧

29:47.580 --> 29:48.580
建一个DIV

29:48.580 --> 29:49.580
然后这边

29:49.580 --> 29:51.580
用一个有三个要显示的

29:51.580 --> 29:53.580
有三个东西要显示

29:53.580 --> 29:54.580
那么这边

29:54.580 --> 29:57.580
我再去建立ULLI

29:57.580 --> 29:58.580
然后这里面

29:58.580 --> 29:59.580
每一个坦克

29:59.580 --> 30:01.580
我用一个动物元素

30:01.580 --> 30:04.580
然后当我鼠标按键的时候

30:04.580 --> 30:06.580
按下上下左右

30:06.580 --> 30:08.580
就是WSDL

30:08.580 --> 30:09.580
来控制方向的时候

30:09.580 --> 30:13.580
我来控制这个些元素的运动

30:13.580 --> 30:15.580
我再写一个模块

30:15.580 --> 30:16.580
专门来写一个模块

30:16.580 --> 30:18.580
来控制敌方坦克

30:18.580 --> 30:21.580
它随机的运动等等

30:21.580 --> 30:24.580
当我按下键盘的借鉴的时候

30:24.580 --> 30:26.580
我就发出一个子弹

30:26.580 --> 30:27.580
这个子弹又是一个元素

30:27.580 --> 30:28.580
对吧

30:28.580 --> 30:29.580
也是一个元素

30:29.580 --> 30:31.580
这种方式思考问题

30:31.580 --> 30:33.580
是怎么来思考问题呢

30:33.580 --> 30:35.580
是基于它的功能

30:35.580 --> 30:37.580
也是基于流程的

30:37.580 --> 30:38.580
我先要做啥

30:38.580 --> 30:40.580
然后我要注册什么是事件

30:40.580 --> 30:42.580
是基于它的流程的

30:42.580 --> 30:44.580
那么这种基于流程的方式

30:44.580 --> 30:47.580
我们把它叫做面向过程

30:47.580 --> 30:48.580
面向过程

30:48.580 --> 30:49.580
它是基于流程的

30:49.580 --> 30:51.580
它划分模块也是

30:51.580 --> 30:53.580
划分一个一个的模块

30:53.580 --> 30:55.580
每个模块是处理某一个流程的

30:55.580 --> 30:56.580
所以说

30:56.580 --> 30:58.580
咱们写面向过程的时候

30:58.580 --> 31:00.580
你会不会去显类呢

31:00.580 --> 31:01.580
你不会去想到显类

31:01.580 --> 31:02.580
因为你的思维

31:02.580 --> 31:04.580
根本就没往这方面去想

31:04.580 --> 31:06.580
这是基于流程的

31:06.580 --> 31:08.580
基于流程的这种思维

31:08.580 --> 31:10.580
这种思维要在解决小的应用的时候呢

31:10.580 --> 31:12.580
没有什么问题

31:12.580 --> 31:14.580
那解决大型项目

31:14.580 --> 31:16.580
或者是复杂项目的时候

31:16.580 --> 31:18.580
就麻烦就来了

31:18.580 --> 31:20.580
因为在复杂或者是大型项目里边

31:20.580 --> 31:22.580
它的流程经常会发生变动

31:22.580 --> 31:25.580
每一个环节都可能会被附用

31:25.580 --> 31:26.580
之前的流程

31:26.580 --> 31:28.580
可能到了另外一个项目里面

31:28.580 --> 31:29.580
就不太适用了

31:29.580 --> 31:30.580
因此呢

31:30.580 --> 31:32.580
面向过程的这种

31:32.580 --> 31:33.580
这种方式

31:33.580 --> 31:34.580
思维开发方式呢

31:34.580 --> 31:36.580
不太适合大型项目

31:36.580 --> 31:38.580
而绝大部分前端开发者

31:38.580 --> 31:40.580
他使用的

31:40.580 --> 31:41.580
思维方式

31:41.580 --> 31:42.580
他的切入点

31:42.580 --> 31:43.580
都是基于面向过程的

31:43.580 --> 31:45.580
那么我刚才解释这个游戏的时候

31:45.580 --> 31:46.580
大家应该是

31:46.580 --> 31:47.580
深有体会

31:47.580 --> 31:49.580
大家应该是就是那么想的

31:49.580 --> 31:50.580
然后呢

31:50.580 --> 31:52.580
我再说一下寒树式编程

31:52.580 --> 31:54.580
寒树式编程大家应该是

31:54.580 --> 31:56.580
在学学前端的话

31:56.580 --> 31:58.580
应该是多多少少听说过的

31:58.580 --> 32:00.580
寒树式编程啊

32:00.580 --> 32:02.580
我先把这个记一下吧

32:02.580 --> 32:03.580
面向过程

32:03.580 --> 32:06.580
面向过程的思维方式

32:06.580 --> 32:08.580
以

32:08.580 --> 32:10.580
以功能流程

32:10.580 --> 32:13.580
为思考切入点

32:13.580 --> 32:14.580
思考了之后

32:14.580 --> 32:16.580
这些功能要经过哪些流程

32:16.580 --> 32:17.580
来进行显接

32:17.580 --> 32:18.580
来进行完成

32:18.580 --> 32:20.580
是用这个方式来

32:20.580 --> 32:21.580
进行思考

32:21.580 --> 32:23.580
来进行思考整个程序的

32:23.580 --> 32:24.580
所以说呢

32:24.580 --> 32:25.580
这种方式呢

32:25.580 --> 32:28.580
它不太适合

32:28.580 --> 32:31.580
大雄应用

32:31.580 --> 32:32.580
好

32:32.580 --> 32:33.580
下一个

32:33.580 --> 32:35.580
寒树式编程

32:35.580 --> 32:38.580
寒树式编程

32:38.580 --> 32:39.580
这个很神奇

32:39.580 --> 32:41.580
大家可能

32:41.580 --> 32:42.580
听说过寒树式编程

32:42.580 --> 32:43.580
但是呢

32:43.580 --> 32:44.580
没有自己去

32:44.580 --> 32:45.580
自己做过寒树式编程

32:45.580 --> 32:47.580
我相信大家没有做过

32:47.580 --> 32:48.580
这个寒树式编程

32:48.580 --> 32:49.580
跟我们不是说

32:49.580 --> 32:50.580
我们在街市面

32:50.580 --> 32:51.580
写个寒树

32:51.580 --> 32:52.580
就是寒树式编程的

32:52.580 --> 32:54.580
当然要不要写寒树

32:54.580 --> 32:55.580
要写寒树

32:55.580 --> 32:56.580
但是寒树式编程

32:56.580 --> 32:57.580
指的是思维方式

32:57.580 --> 32:59.580
它是以什么切入点呢

32:59.580 --> 33:03.580
以数学运算

33:03.580 --> 33:05.580
为思考切入点

33:05.580 --> 33:08.580
它是适合开拓大型项目的

33:08.580 --> 33:09.580
它

33:09.580 --> 33:10.580
甚至在有些时候

33:10.580 --> 33:12.580
比变相对象还要留

33:12.580 --> 33:13.580
这种方式

33:13.580 --> 33:14.580
只不过呢

33:14.580 --> 33:15.580
现在呢

33:15.580 --> 33:16.580
由于它还

33:16.580 --> 33:18.580
最近几年才活起来

33:18.580 --> 33:19.580
还需要一点时间

33:19.580 --> 33:20.580
它发生起来的话

33:20.580 --> 33:21.580
还需要一点时间

33:21.580 --> 33:22.580
为大家说一下

33:22.580 --> 33:23.580
寒树式编程

33:23.580 --> 33:25.580
它是怎么思考问题的

33:25.580 --> 33:26.580
而且呢

33:27.580 --> 33:28.580
寒树式编程对数学

33:28.580 --> 33:29.580
还有点要求

33:29.580 --> 33:30.580
所以说

33:32.580 --> 33:33.580
不太好说

33:33.580 --> 33:34.580
这个时候不太好说

33:34.580 --> 33:35.580
它到底能不能发展起来

33:37.580 --> 33:38.580
这里呢

33:38.580 --> 33:39.580
比方说用

33:39.580 --> 33:41.580
寒树式编程来想的话

33:41.580 --> 33:42.580
那么我会怎么

33:42.580 --> 33:43.580
来思考这个问题

33:43.580 --> 33:44.580
我压着不去

33:44.580 --> 33:45.580
看那个界面

33:45.580 --> 33:46.580
什么做出来的

33:46.580 --> 33:47.580
不是看那些坦克

33:47.580 --> 33:48.580
我就看这里面

33:48.580 --> 33:49.580
有哪些运算

33:50.580 --> 33:51.580
有碰撞运算

33:51.580 --> 33:52.580
我们可以

33:52.580 --> 33:53.580
把这两个东西

33:53.580 --> 33:54.580
看成两个方块

33:54.580 --> 33:55.580
对吧

33:55.580 --> 33:56.580
和一些障碍物之间

33:56.580 --> 33:57.580
看成两个方块

33:57.580 --> 33:58.580
还有就是

33:58.580 --> 34:00.580
我们的就是子弹

34:00.580 --> 34:02.580
子弹跟坦克

34:02.580 --> 34:03.580
也是两个方块

34:03.580 --> 34:04.580
我们也可以

34:04.580 --> 34:05.580
把子弹飞行

34:05.580 --> 34:07.580
一看都是方块

34:07.580 --> 34:09.580
就是两个举行之间

34:09.580 --> 34:12.580
他们如何来完成碰撞

34:12.580 --> 34:13.580
就是他们是否重叠

34:13.580 --> 34:15.580
他们是否有交叉

34:15.580 --> 34:16.580
我们通过

34:16.580 --> 34:17.580
一个数学运算来进行判断

34:17.580 --> 34:18.580
比方说可以

34:18.580 --> 34:19.580
可能首先会想到

34:19.580 --> 34:20.580
这个数学运算

34:20.580 --> 34:21.580
然后我待会想到

34:21.580 --> 34:22.580
一个数学运算

34:22.580 --> 34:24.580
就是位移

34:24.580 --> 34:25.580
这个子弹

34:25.580 --> 34:27.580
从一开始的位置发出去

34:27.580 --> 34:28.580
然后到达

34:28.580 --> 34:29.580
到达就是

34:29.580 --> 34:31.580
怎么样在这个画面中移动

34:31.580 --> 34:32.580
它的位移距离是多少

34:32.580 --> 34:33.580
它的速度

34:33.580 --> 34:34.580
根据速度

34:34.580 --> 34:36.580
根据时间来算它的距离

34:36.580 --> 34:38.580
我们可能会需要这个东西

34:38.580 --> 34:39.580
所以说

34:39.580 --> 34:40.580
这种思考方式

34:40.580 --> 34:42.580
就是函数式违

34:42.580 --> 34:43.580
它是用

34:43.580 --> 34:44.580
它是一切

34:44.580 --> 34:46.580
根据运算来进行运算

34:46.580 --> 34:47.580
就是我这里面

34:47.580 --> 34:48.580
有哪些运算

34:48.580 --> 34:49.580
好 这些运算之间

34:49.580 --> 34:50.580
还可以进行组合

34:50.580 --> 34:52.580
我们就不讲多了

34:52.580 --> 34:53.580
不讲的太深入了

34:53.580 --> 34:55.580
函数式编程大概了解一下

34:55.580 --> 34:56.580
我们不是说

34:56.580 --> 34:57.580
写了函数过后

34:57.580 --> 34:58.580
就是函数式编程了

34:58.580 --> 34:59.580
良罢事

34:59.580 --> 35:01.580
有兴趣的同学

35:01.580 --> 35:03.580
可以去网上

35:03.580 --> 35:04.580
摆度一下

35:04.580 --> 35:05.580
函数式编程

35:05.580 --> 35:06.580
是什么东西

35:06.580 --> 35:07.580
可以去了解一下

35:07.580 --> 35:09.580
如果有机会的话

35:09.580 --> 35:10.580
我后面

35:10.580 --> 35:11.580
会给大家做一门

35:11.580 --> 35:12.580
客家的函数的编程

35:12.580 --> 35:13.580
但是我觉得有困难

35:13.580 --> 35:14.580
因为这一块

35:14.580 --> 35:16.580
需要一些数学知识

35:17.580 --> 35:19.580
好 最后一个

35:19.580 --> 35:21.580
就说到我们的面向对象

35:21.580 --> 35:22.580
面向对象

35:22.580 --> 35:24.580
非常自然的一种思维方式

35:24.580 --> 35:26.580
它是用什么来切入点呢

35:26.580 --> 35:28.580
刚才说了自己对象

35:28.580 --> 35:29.580
严格来说的话

35:29.580 --> 35:30.580
应该是内

35:30.580 --> 35:31.580
应该是内

35:34.580 --> 35:36.580
以化分

35:36.580 --> 35:39.580
内为思考

35:39.580 --> 35:40.580
切入点

35:42.580 --> 35:44.580
这面向对象的思维方式

35:44.580 --> 35:46.580
这也是我这个程序

35:46.580 --> 35:47.580
使用的这种思维方式

35:47.580 --> 35:48.580
来做出来的

35:48.580 --> 35:50.580
好 拿到这个程序过后

35:50.580 --> 35:51.580
我想的是啥呢

35:51.580 --> 35:53.580
想的是这里面有哪些内

35:53.580 --> 35:54.580
什么叫内

35:54.580 --> 35:56.580
内就是可以产生对象的东西

35:56.580 --> 35:58.580
我们把内的概念记一下吧

35:58.580 --> 36:00.580
我以前经常说内

36:00.580 --> 36:02.580
好像没有明确的

36:02.580 --> 36:05.580
去讲内到底是一个什么东西

36:05.580 --> 36:07.580
内是

36:08.580 --> 36:09.580
很多书籍里边

36:09.580 --> 36:11.580
教程里边都是这样解释的

36:11.580 --> 36:13.580
表示可以产生

36:13.580 --> 36:16.580
对象的模板

36:16.580 --> 36:19.580
可以产生对象的模板

36:19.580 --> 36:21.580
怎么去理解这个话呢

36:21.580 --> 36:23.580
首先你要理解对象

36:23.580 --> 36:24.580
对象是什么

36:24.580 --> 36:25.580
就是事物

36:25.580 --> 36:27.580
就是真实存在的东西

36:27.580 --> 36:28.580
真实存在的东西

36:28.580 --> 36:29.580
那么什么叫内呢

36:29.580 --> 36:32.580
内其实就是对他们的分类

36:32.580 --> 36:34.580
比方说

36:34.580 --> 36:36.580
我是人

36:36.580 --> 36:37.580
我是人吧 对吧

36:37.580 --> 36:38.580
这个毫无疑问

36:38.580 --> 36:39.580
对吧 我是人

36:39.580 --> 36:41.580
然后你们也是人

36:41.580 --> 36:42.580
对不对

36:42.580 --> 36:45.580
那么我和你们是什么

36:45.580 --> 36:47.580
是一个一个的对象

36:47.580 --> 36:48.580
是真实存在的东西

36:48.580 --> 36:50.580
一个一个的对象

36:50.580 --> 36:52.580
那么内是什么呢

36:52.580 --> 36:55.580
人这个字就是内

36:55.580 --> 36:56.580
明白这个意思吗

36:56.580 --> 36:58.580
就是对我们整个的划分

36:58.580 --> 36:59.580
划分为一个内形

36:59.580 --> 37:00.580
内就是内别嘛

37:00.580 --> 37:01.580
我们整个人

37:01.580 --> 37:04.580
整个这个群体的内别就是一个内

37:04.580 --> 37:05.580
那么内是一个

37:05.580 --> 37:07.580
可以产生对象的模板

37:07.580 --> 37:09.580
什么意思呢

37:09.580 --> 37:10.580
比方说

37:10.580 --> 37:14.020
我们说人

37:14.020 --> 37:15.020
人

37:15.020 --> 37:16.020
人是什么呢

37:16.020 --> 37:18.020
人是一个内 对吧

37:18.020 --> 37:19.020
它是一个内

37:19.020 --> 37:21.020
它是个内别嘛

37:21.020 --> 37:23.020
人里边有哪些属性呢

37:23.020 --> 37:24.020
我们就

37:24.020 --> 37:25.020
现在就假设这个世界上

37:25.020 --> 37:27.020
假设我是上帝

37:27.020 --> 37:28.020
我要创建人

37:28.020 --> 37:29.020
我要创造这个世界

37:29.020 --> 37:31.020
创造一个一个的人

37:31.020 --> 37:33.020
不然我们有很多神话吗

37:33.020 --> 37:35.020
怎么中国的神话里边

37:35.020 --> 37:36.020
人是谁创建的

37:36.020 --> 37:38.020
好像女娃娘娘的吧

37:38.020 --> 37:40.020
女娃娘娘捏这个泥人

37:40.020 --> 37:43.020
把以人一个一个的创建出来

37:43.020 --> 37:44.020
好 人呢

37:44.020 --> 37:45.020
是一个概念

37:45.020 --> 37:46.020
假设这个世界上

37:46.020 --> 37:48.020
一开始并不存在人

37:48.020 --> 37:49.020
那么我是上帝

37:49.020 --> 37:51.020
我要创造人的时候

37:51.020 --> 37:53.020
在人创造出来之前

37:53.020 --> 37:54.020
我是不是就要把这个人

37:54.020 --> 37:56.020
用哪些特征要想好啊

37:56.020 --> 37:57.020
对不对 要想好

37:57.020 --> 37:58.020
这个时候人都还没有出来

37:58.020 --> 38:00.020
但是我就可以把它特征想出来

38:00.020 --> 38:01.020
好 人

38:01.020 --> 38:03.020
这个内里边有哪些特征呢

38:03.020 --> 38:05.020
有鼻子

38:05.020 --> 38:07.020
眼睛

38:07.020 --> 38:09.020
有什么嗜知

38:09.020 --> 38:11.020
对吧

38:11.020 --> 38:13.020
人可以怎么样呢

38:13.020 --> 38:15.020
人可以说话

38:15.020 --> 38:16.020
他有哪些动作呢

38:16.020 --> 38:17.020
前面是特征

38:17.020 --> 38:19.020
这是动作

38:19.020 --> 38:23.230
前面是特征

38:23.230 --> 38:24.230
人还有什么呢

38:24.230 --> 38:25.230
人还有性别

38:25.230 --> 38:26.230
特征还有性别

38:26.230 --> 38:27.230
动作 说话

38:27.230 --> 38:29.230
还有什么运动

38:29.230 --> 38:31.230
还有制造工具

38:31.230 --> 38:35.230
这些都是属于人的成员

38:35.230 --> 38:36.230
我们都知道

38:36.230 --> 38:37.230
其实特征是啥

38:37.230 --> 38:38.230
特征就是属性

38:38.230 --> 38:39.230
动作是啥

38:39.230 --> 38:40.230
动作就是方法

38:40.230 --> 38:42.230
这个时候人都还没有出来

38:42.230 --> 38:43.230
人都还没有具体出来

38:43.230 --> 38:44.230
但是呢

38:44.230 --> 38:47.230
人的模板已经出来了

38:47.230 --> 38:48.230
好 后边我创造人

38:48.230 --> 38:50.230
怎么创造呢

38:50.230 --> 38:53.230
只要我们要创建一个人

38:53.230 --> 38:55.230
只需要去溜一个

38:55.230 --> 38:58.610
溜一个人

38:58.610 --> 38:59.610
溜一个人

38:59.610 --> 39:01.610
然后再创建一个人

39:01.610 --> 39:02.610
溜一个人

39:02.610 --> 39:03.610
就完事了

39:03.610 --> 39:04.610
不同的人呢

39:04.610 --> 39:06.610
这些就是对象

39:06.610 --> 39:08.610
这些就是一个一个的对象

39:08.610 --> 39:09.610
对象是怎么来的

39:09.610 --> 39:11.610
是通过内创建出来的

39:11.610 --> 39:12.610
有了内过后

39:12.610 --> 39:13.610
我们就规定了

39:13.610 --> 39:14.610
这个内别的事物

39:14.610 --> 39:16.610
不管你是哪个对象

39:16.610 --> 39:17.610
你都拥有一些特征

39:17.610 --> 39:19.610
那么每一个对象里边

39:19.610 --> 39:21.610
他特征的值可能不一样

39:21.610 --> 39:22.610
比方说这个人

39:22.610 --> 39:25.610
这个人可能鼻子

39:25.610 --> 39:26.610
鼻子塌掉了

39:26.610 --> 39:29.610
或者是眼睛瞎了一只

39:29.610 --> 39:31.610
或者是心别是男

39:31.610 --> 39:32.610
或者是女

39:32.610 --> 39:33.610
他的值

39:33.610 --> 39:34.610
他的特征的值

39:34.610 --> 39:36.610
是可以改变的

39:36.610 --> 39:37.610
是可能会变化的

39:37.610 --> 39:38.610
就这个人

39:38.610 --> 39:39.610
他是个对象

39:39.610 --> 39:40.610
这个人也是个对象

39:40.610 --> 39:41.610
两个对象

39:41.610 --> 39:44.610
特征的值是不一样的

39:44.610 --> 39:46.610
但是他们都拥有

39:46.610 --> 39:48.610
这些特征

39:48.610 --> 39:50.610
他们都拥有这些动作

39:50.610 --> 39:51.610
比方这个意思吗

39:51.610 --> 39:52.610
内表是什么

39:52.610 --> 39:54.610
内表是一个抽象的概念

39:54.610 --> 39:56.610
是一个概念

39:56.610 --> 39:57.610
概念性的东西

39:57.610 --> 39:58.610
它并不是真实存在的

39:58.610 --> 39:59.610
但是有了这个东西过后

39:59.610 --> 40:01.610
我们可以去创建一个一个的对象

40:01.610 --> 40:03.610
你就把它想象成

40:03.610 --> 40:04.610
我们上帝

40:04.610 --> 40:05.610
你是一个上帝

40:05.610 --> 40:06.610
你在招人

40:06.610 --> 40:09.610
你在招人

40:09.610 --> 40:10.610
那么人出来之前

40:10.610 --> 40:11.610
你先把这些东西想好

40:11.610 --> 40:12.610
对不对

40:12.610 --> 40:13.610
先把这些东西想好

40:13.610 --> 40:14.610
那么到时候招人的时候

40:14.610 --> 40:16.610
就只需要去丢一个就行了

40:16.610 --> 40:17.610
所以说内是可以什么

40:17.610 --> 40:20.610
可以产生对象的模板

40:20.610 --> 40:21.610
而我们在这个游戏里边

40:21.610 --> 40:24.610
其实也是一样的道理

40:24.610 --> 40:25.610
游戏

40:25.610 --> 40:26.610
我们要做这个功能

40:26.610 --> 40:27.610
现在我们程序都还没开始入手

40:27.610 --> 40:28.610
对吧

40:28.610 --> 40:29.610
都还没开始写单

40:29.610 --> 40:30.610
但是我们可以想

40:30.610 --> 40:31.610
这里面有哪些内

40:31.610 --> 40:32.610
而有了内过后

40:32.610 --> 40:34.610
我就可以创建这些对象了

40:34.610 --> 40:36.610
比方说有这个子弹内

40:36.610 --> 40:37.610
子弹内做什么

40:37.610 --> 40:38.610
子弹内就是子弹

40:38.610 --> 40:39.610
那么我们就想

40:39.610 --> 40:40.610
子弹有哪些特征

40:40.610 --> 40:41.610
有哪些属性

40:41.610 --> 40:42.610
有哪些方法

40:42.610 --> 40:44.610
比方说坦克

40:44.610 --> 40:45.610
有几方坦克

40:45.610 --> 40:46.610
有敌方坦克

40:46.610 --> 40:47.610
这些坦克内

40:47.610 --> 40:49.610
我们可以把它想出来

40:49.610 --> 40:50.610
坦克

40:50.610 --> 40:52.610
然后这些障碍物

40:52.610 --> 40:53.610
障碍物也可以把它做成内

40:53.610 --> 40:54.610
不同的障碍物

40:54.610 --> 40:55.610
给它做成不同的内

40:55.610 --> 40:57.610
这些障碍物有什么特征

40:57.610 --> 40:59.610
让它的作标

40:59.610 --> 41:01.610
它是否能够被穿透之类的东西

41:01.610 --> 41:03.610
这些特征都可以把它做出来

41:03.610 --> 41:06.610
而不去考虑具体怎么去

41:06.610 --> 41:07.610
先做什么

41:07.610 --> 41:08.610
后做什么

41:08.610 --> 41:09.610
不去考虑这些问题

41:09.610 --> 41:11.610
这些问题我们后面再考虑

41:11.610 --> 41:13.610
而先的去做一个一个人内

41:13.610 --> 41:14.610
这有点类似于啥呢

41:14.610 --> 41:17.610
有点类似于Rex里面的模块化开发

41:17.610 --> 41:18.610
我们在学习Rex

41:18.610 --> 41:20.610
学习无诱的时候

41:20.610 --> 41:21.610
使用的是什么

41:21.610 --> 41:23.610
使用的是组建化开发

41:23.610 --> 41:24.610
对吧

41:24.610 --> 41:25.610
刚才说错了

41:25.610 --> 41:26.610
不是模块化开发

41:26.610 --> 41:28.610
而是组建式开发

41:28.610 --> 41:29.610
组建式开发的话

41:29.610 --> 41:30.610
就是把这些东西

41:30.610 --> 41:31.610
一个一个分析

41:31.610 --> 41:33.610
分成一个一个的小组建

41:33.610 --> 41:34.610
每个组建

41:34.610 --> 41:36.610
就看那个组建里边有哪些东西

41:36.610 --> 41:38.610
这个组建如何去完成它的功能

41:38.610 --> 41:39.610
因此呢

41:39.610 --> 41:41.610
用面上对象开发的话

41:41.610 --> 41:43.610
它的功能单元是内

41:43.610 --> 41:46.610
内是功能单元

41:46.610 --> 41:48.610
内是一个

41:48.610 --> 41:51.610
应该说内是最小的功能单元

41:51.610 --> 41:54.610
我们是以内来做功能单元化分的

41:54.610 --> 41:56.610
其实你看Rex里边

41:56.610 --> 41:58.610
它已经给两者结合起来了

41:58.610 --> 42:00.610
Rex的组建是啥

42:00.610 --> 42:02.610
Rex的组建不就是内吗

42:02.610 --> 42:03.610
对吧

42:03.610 --> 42:04.610
当然它有函数组建

42:05.610 --> 42:06.610
它也可以支持内组建

42:06.610 --> 42:08.610
Rex里边的组建不就是个内吗

42:08.610 --> 42:10.610
所以说我们开发

42:10.610 --> 42:11.610
用Rex开发的时候

42:11.610 --> 42:14.610
其实就是以内为单位来进行开发

42:14.610 --> 42:16.610
它强制要求你这样去做

42:16.610 --> 42:17.610
你自己感觉不到而已

42:17.610 --> 42:19.610
但是那一旦脱离到Rex的环境

42:19.610 --> 42:20.610
你就还原了

42:20.610 --> 42:21.610
一切都还原了

42:21.610 --> 42:23.610
你不会再用内来做开发了

42:23.610 --> 42:25.610
因为你的思维方式

42:25.610 --> 42:26.610
它不是面向对象的

42:26.610 --> 42:28.610
其实面向对象的思维方式

42:28.610 --> 42:29.610
是非常非常自然的

42:29.610 --> 42:30.610
非常非常自然

42:30.610 --> 42:32.610
它就是

42:33.610 --> 42:35.610
对象以内为切入点

42:35.610 --> 42:37.610
来思考整个问题

42:37.610 --> 42:39.610
这里面有哪些东西

42:39.610 --> 42:40.610
先把东西划分出来

42:40.610 --> 42:42.610
我们比方说开发

42:42.610 --> 42:43.610
比方拿到这个程序

42:43.610 --> 42:44.610
我根本就不会考虑

42:44.610 --> 42:46.610
我怎么去把它开发完成

42:46.610 --> 42:47.610
我先就说

42:47.610 --> 42:49.610
我先做一个解放坦克出来

42:49.610 --> 42:50.610
做这么一个内

42:50.610 --> 42:51.610
我把这个内完善

42:51.610 --> 42:52.610
不断的去测试

42:52.610 --> 42:53.610
好像就做出一个组建了

42:53.610 --> 42:54.610
对吧

42:54.610 --> 42:56.610
然后我再去做障碍物

42:56.610 --> 42:58.610
或者再做解放坦克

42:58.610 --> 43:00.610
或者再做这个坦克发射子弹

43:01.610 --> 43:03.610
就是我做的开发的单位

43:03.610 --> 43:05.610
是以内为单位来开发的

43:05.610 --> 43:06.610
我先把内划分出来

43:06.610 --> 43:07.610
思考里边有哪些特征

43:07.610 --> 43:08.610
有哪些动作

43:10.610 --> 43:11.610
这是第1个

43:13.610 --> 43:14.610
其实我就已经讲的差不多了

43:14.610 --> 43:15.610
对吧

43:15.610 --> 43:16.610
其实已经讲的差不多

43:16.610 --> 43:18.610
这里不用去划分这个东西了

43:18.610 --> 43:19.610
已经讲的差不多了

43:19.610 --> 43:20.610
什么是面向对象

43:20.610 --> 43:22.610
我这里就大概的介绍一下

43:22.610 --> 43:24.610
面向对象的它的思维切入点

43:24.610 --> 43:26.610
是以内为切入点

43:26.610 --> 43:28.610
来进行问题思考的

43:28.610 --> 43:29.610
不用讲得太深

43:29.610 --> 43:30.610
不用讲得太深

43:30.610 --> 43:31.610
好

43:31.610 --> 43:33.610
这是关于这个点

43:33.610 --> 43:35.610
什么是面向对象

43:35.610 --> 43:36.610
好

43:36.610 --> 43:38.610
最后我说一下如何学习

43:38.610 --> 43:41.610
如何学习

43:41.610 --> 43:43.610
如何学习

43:43.610 --> 43:45.610
我们这节课

43:45.610 --> 43:47.610
内容很多

43:47.610 --> 43:49.610
这一节课只是做了一课

43:49.610 --> 43:50.610
面向对象的概述

43:50.610 --> 43:51.610
对吧

43:51.610 --> 43:53.610
还有其他很多的内容

43:53.610 --> 43:55.610
那么这节课的流程

43:55.610 --> 43:56.610
是这个样子的

43:56.610 --> 43:58.610
我们先讲面

43:58.610 --> 44:00.610
这里语法

44:00.610 --> 44:04.110
这里面向对象

44:04.110 --> 44:05.110
不叫面向对象

44:05.110 --> 44:09.110
TS中的OP

44:09.110 --> 44:10.110
怎么叫OP呢

44:10.110 --> 44:12.110
就是面向对象编程

44:12.110 --> 44:14.110
面向对象编程

44:14.110 --> 44:16.110
我们之前的面向对象是一种思想

44:16.110 --> 44:17.110
对吧

44:17.110 --> 44:18.110
那么具体在程序里边

44:18.110 --> 44:20.110
怎么去使用它的这种思想

44:20.110 --> 44:21.110
去开发代码

44:21.110 --> 44:23.110
它的语法是什么

44:23.110 --> 44:24.110
就是面向对象编程

44:24.110 --> 44:26.110
叫做oriented

44:26.110 --> 44:28.110
oriented object

44:29.110 --> 44:31.110
program

44:33.110 --> 44:35.110
OP表示面向对象编程

44:35.110 --> 44:36.110
先讲这个

44:36.110 --> 44:38.110
先把它语法讲清楚

44:38.110 --> 44:39.110
可能在讲的过程中

44:39.110 --> 44:40.110
我会穿插一些

44:40.110 --> 44:41.110
为什么这个语法

44:41.110 --> 44:42.110
它要实现什么样的

44:42.110 --> 44:44.110
它为什么要去设置这个语法

44:44.110 --> 44:45.110
它有什么样的作用

44:45.110 --> 44:46.110
它的想法是什么

44:46.110 --> 44:47.110
可能会涉及到

44:47.110 --> 44:48.110
一点点的面向对象思想

44:48.110 --> 44:50.110
但是我们先把语法讲通

44:50.110 --> 44:51.110
讲通了过后

44:51.110 --> 44:53.110
我们思想的训练

44:53.110 --> 44:55.110
集中在后边的

44:55.110 --> 44:57.110
这个项目实战里边

44:57.110 --> 44:59.110
这个是一个小游戏

44:59.110 --> 45:01.110
一个小游戏练习

45:01.110 --> 45:02.110
这个小游戏

45:02.110 --> 45:04.110
我现在还没有想好

45:04.110 --> 45:06.110
到底一个什么样的游戏

45:06.110 --> 45:08.110
来练习这个面向对象

45:08.110 --> 45:10.110
可能是坦克大战

45:10.110 --> 45:13.110
也有可能是微信飞机大战

45:13.110 --> 45:16.110
也有可能是中国象棋

45:16.110 --> 45:18.110
我还没有想好

45:18.110 --> 45:20.110
这里其实我觉得

45:20.110 --> 45:21.110
我个人

45:21.110 --> 45:23.110
之前开发过不少的游戏了

45:23.110 --> 45:24.110
个人觉得

45:24.110 --> 45:26.110
可以能够断练面向对象

45:26.110 --> 45:27.110
这种思维的话

45:27.110 --> 45:29.110
就是象棋

45:29.110 --> 45:30.110
中国象棋

45:30.110 --> 45:32.110
但是呢

45:32.110 --> 45:34.110
以前我给学生

45:34.110 --> 45:36.110
去做过这么一个练习

45:36.110 --> 45:37.110
用中国象棋

45:37.110 --> 45:38.110
不过不是介石

45:38.110 --> 45:40.110
是一个后端语言

45:40.110 --> 45:42.110
来去做这个练习的时候

45:42.110 --> 45:43.110
发现一个问题就是

45:43.110 --> 45:44.110
很多人根本就不理解

45:44.110 --> 45:45.110
象棋的规则

45:45.110 --> 45:47.110
不了解象棋的规则

45:47.110 --> 45:50.110
可能现在的年轻人

45:50.110 --> 45:52.110
都不怎么去结束这个东西了

45:52.110 --> 45:54.110
我们小时候没有什么玩的

45:54.110 --> 45:55.110
象棋的规则

45:55.110 --> 45:57.110
大家都能够知道

45:57.110 --> 45:58.110
现在有些同学

45:58.110 --> 46:00.110
就不太清楚象棋的规则

46:00.110 --> 46:01.110
会遇到这么一个问题

46:01.110 --> 46:02.110
所以说我再考虑一下吧

46:02.110 --> 46:03.110
总之呢

46:03.110 --> 46:05.110
到时候会做一个小游戏

46:05.110 --> 46:06.110
这个小游戏不是一个demo

46:06.110 --> 46:07.110
不是一个demo

46:07.110 --> 46:09.110
它是一个完整的游戏

46:09.110 --> 46:11.110
把这个游戏完整的做出来

46:11.110 --> 46:12.110
我再想一想

46:12.110 --> 46:13.110
想一想

46:13.110 --> 46:14.110
到时候一定会有这么一个项目

46:14.110 --> 46:15.110
因为在游戏里面

46:15.110 --> 46:17.110
是最能够练习面向对象变成的

46:17.110 --> 46:19.110
面向对象的这种思维方式

46:19.110 --> 46:20.110
到时候当然

46:20.110 --> 46:21.110
大家去做这个

46:21.110 --> 46:22.110
开发这个项目的时候

46:22.110 --> 46:24.110
就会体会一下

46:24.110 --> 46:25.110
用面向对象开发

46:25.110 --> 46:27.110
跟之前的

46:27.110 --> 46:29.110
使用面向过程的那种思维

46:29.110 --> 46:30.110
那种零散的那种思维

46:30.110 --> 46:31.110
有什么样的不一样

46:31.110 --> 46:32.110
就可以体会到了

46:32.110 --> 46:34.110
咱们先讲愚法

46:34.110 --> 46:35.110
愚法不是这一部分很简单

46:35.110 --> 46:36.110
就是

46:36.110 --> 46:37.110
但是学这一部分的时候

46:37.110 --> 46:39.110
有可能会出现一个现象就是

46:39.110 --> 46:41.110
你不理解它有什么用

46:41.110 --> 46:42.110
它有什么意义

46:42.110 --> 46:43.110
那么这个没关系

46:43.110 --> 46:44.110
你学习的时候

46:44.110 --> 46:45.110
就你把它愚法记住

46:45.110 --> 46:46.110
去练习一下吧

46:46.110 --> 46:47.110
记住就行了

46:47.110 --> 46:49.110
咱们在练习的时候

46:49.110 --> 46:51.110
要把这些东西灌输进去

46:51.110 --> 46:52.110
好了

46:52.110 --> 46:54.110
这是咱们学习这一部分

46:54.110 --> 46:55.110
学习这部分的流程

46:55.110 --> 46:57.110
按照这种流程学习

46:57.110 --> 46:58.110
大家在学习的时候

46:58.110 --> 46:59.110
要坚持

46:59.110 --> 47:00.110
因为这部分

47:00.110 --> 47:01.110
确实有点难度

47:01.110 --> 47:02.110
但是不会很难的

47:02.110 --> 47:03.110
因为我不会讲得太深

47:03.110 --> 47:05.110
毕竟是咱们是前端嘛

47:05.110 --> 47:06.110
对吧

47:06.110 --> 47:07.110
基于这么一个

47:07.110 --> 47:08.110
方式来学习

47:08.110 --> 47:09.110
一个是理解

47:09.110 --> 47:11.110
就是理解老师讲的东西

47:11.110 --> 47:12.110
理解我讲的东西

47:12.110 --> 47:13.110
理解的

47:13.110 --> 47:14.110
在理解的基础上

47:14.110 --> 47:16.110
自己去产生一些想法

47:16.110 --> 47:17.110
你既然

47:17.110 --> 47:18.110
这个东西既然是这样子

47:18.110 --> 47:20.110
那我如果这样子去实现的话

47:20.110 --> 47:22.110
会有什么样的效果了

47:22.110 --> 47:24.110
我应该怎么去用这个东西呢

47:24.110 --> 47:25.110
去产生一些想法

47:25.110 --> 47:27.110
产生想法过后来再去实现

47:27.110 --> 47:28.110
去实现

47:28.110 --> 47:29.110
看一下自己的想法

47:29.110 --> 47:30.110
是不是正确的

47:30.110 --> 47:31.110
是不是确实

47:31.110 --> 47:32.110
如自己想法所说

47:32.110 --> 47:34.110
然后再回归到理解

47:34.110 --> 47:36.110
就会进一步加深理解

47:36.110 --> 47:38.110
应该是这么一种循环

47:38.110 --> 47:40.110
进一步加深理解

47:40.110 --> 47:42.110
后面就是个循环了

47:42.110 --> 47:44.110
其实学习

47:44.110 --> 47:46.110
就是反复的这样一个过程

47:46.110 --> 47:47.110
理解你所学到的东西

47:47.110 --> 47:48.110
然后产生一些想法

47:48.110 --> 47:49.110
一些新奇的想法

47:49.110 --> 47:51.110
然后再去实现

47:51.110 --> 47:52.110
这样子其实在这个过程中

47:52.110 --> 47:53.110
在这个循环过程中

47:53.110 --> 47:55.110
你就会不断的去获得

47:55.110 --> 47:56.110
成就感

47:56.110 --> 47:58.110
这个成就感对我们学习

47:58.110 --> 48:00.110
是非常非常有帮助的

48:00.110 --> 48:01.110
好了

48:01.110 --> 48:02.110
那么这节课呢

48:02.110 --> 48:03.110
罗利瓦说了这么多

48:03.110 --> 48:06.110
其实就是希望大家能够理解

48:06.110 --> 48:07.110
理解我们这里

48:07.110 --> 48:09.110
为什么要去讲这个面向对象

48:09.110 --> 48:10.110
以及什么是面向对象

48:10.110 --> 48:11.110
我们这里可能先对他

48:11.110 --> 48:12.110
推一个概述

48:12.110 --> 48:14.110
好那么咱们下一个开始呢

48:14.110 --> 48:15.110
就来具体的学习

48:15.110 --> 48:16.110
TS里边

48:16.110 --> 48:18.110
面向对象的一些与法

