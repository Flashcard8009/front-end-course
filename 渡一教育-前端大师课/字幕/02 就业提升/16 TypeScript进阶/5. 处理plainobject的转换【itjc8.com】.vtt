WEBVTT

00:00.750 --> 00:05.910
好了 上节课呢 咱们开发了这么一个屋位 这个实体内

00:06.750 --> 00:12.590
然后呢 在里边加了一些验证 好 这节课呢 我要解决另外一个问题啊

00:13.430 --> 00:19.790
不要着急啊 不要着急 做什么数据库啊 API接口 不要着急 我们先把这个实体的搞定再说

00:20.630 --> 00:25.190
我们要解决另外一个问题 什么问题呢 就是类型转换的问题

00:25.790 --> 00:32.150
有的时候呢 我们得到了对象啊 可能不是一个move的对象啊 不是通过六一个move来创建的

00:32.470 --> 00:39.150
可能是一个平面的对象 大家懂我要说什么了吗 有的有的时候呢 我们得到对象是可能是这个样子的

00:40.110 --> 00:45.350
就是这个这么个样子 能力啊 它可能是一个平面的对象

00:46.830 --> 00:53.710
可能是一个这么一个对象 然后呢 这个对象里面一次给他属性复制啊 或者说那些属性值呢 就直接写到这里边

00:54.670 --> 00:56.990
什么情况下会出现这种情况呢 就是说

00:58.270 --> 01:06.190
从科普端传过来的数据啊 从科普端传过来的数据 传过来的数据呢 他肯定是没有创建一个对象传过来 对吧

01:06.550 --> 01:12.310
就算就就算他创建了一个对象传过来 他也会变成一个平面对象 因为网络传输

01:12.830 --> 01:18.750
他是不能识别这些内的对象的 他只能识别平面对象啊 我们把它叫做

01:19.230 --> 01:20.990
我们把它叫做plane object

01:22.910 --> 01:23.510
plane object

01:24.950 --> 01:25.430
加空格

01:26.550 --> 01:34.430
就是一个平面对象 那么如果遇到这种平面对象的话 我们再来看一下啊 他的验证会怎么样 我们看一下他的验证

01:35.350 --> 01:42.070
你会发现他的验证就直接通过了 就直接通过了 我们再可以把一些属性给他去掉 把这些属性给他去掉

01:42.470 --> 01:42.790
保存

01:43.790 --> 01:53.070
啊 他验证也会通过 为什么呢 因为这些平面对象里边 他本来就没有任何的装饰器啊 没有使用任何的装饰器

01:53.510 --> 01:59.030
也没有配置任何的验证规则 所以说只能验证通过还能怎么样呢 对不对

01:59.950 --> 02:05.430
因此呢 这里这个问题啊 该怎么来解决呢 我们就需要啊 我们就需要

02:06.630 --> 02:11.590
把这个平面对象呢 转换成为movey的对象 转换成为这个对象

02:12.390 --> 02:21.350
好 怎么转换呢 按照我们以前所学应该使用什么样的方式啊 将 这里要将平面啊 就是play

02:23.230 --> 02:27.910
说实话 我说什么平面对象觉得很快啊play object 转换为

02:28.910 --> 02:30.710
转换为movey的对象

02:31.630 --> 02:37.390
有的时候我们需要这样做 那么这个转换怎么来完成呢 我们可以使用一个第三方库来完成

02:37.950 --> 02:39.310
好 我们找到第三方库啊

02:41.990 --> 02:51.750
好 你看他他他这里呢 就已经在提示里了啊 他说你这个平面对象里边呢 他是没有任何的元数据的啊 没有元数据被发现

02:52.350 --> 02:56.830
所以说呢 你这你这样子做的话是无法触犯验证的

02:57.870 --> 02:59.990
好 现在呢 我们去安装一个第三方库

03:02.530 --> 03:09.770
安装一二一add 然后名字叫做class transformer transformer

03:10.890 --> 03:16.250
好 这个库呢 我们他这两个库都是一样啊 class validator和class transformer

03:16.810 --> 03:22.210
这两个库呢 他本身都是用ts 语言写的 所以说你不需要去加什么内容库了

03:23.130 --> 03:29.290
好 有了这个库之后呢 我们就可以使用这个库里边的一个方法啊 叫做play

03:30.850 --> 03:34.050
play啊 没有正能体式没有正能体式的话 我们先导入

03:34.890 --> 03:37.250
导入这个玩意儿可能是

03:38.090 --> 03:41.130
transformer啊 然后这里面先把导入

03:42.370 --> 03:47.490
我们要使用的这个方法是使用这个函数是play to class

03:48.810 --> 03:55.290
把我们的就是要转换的目标目标内传进去 我们要转换哪个转换成什么样的内

03:56.250 --> 04:01.930
movey 传进去 好 第二个参数呢 把我们要转换的对象传进去

04:02.650 --> 04:04.290
对象是啥呢 对象是

04:07.090 --> 04:12.890
好 这样子一来呢 他返回的结果 返回的结果就是转换后的结果 好 我们来得到

04:14.130 --> 04:17.130
得到movey 得到这个转换后的结果

04:18.170 --> 04:21.730
好 我们用鼠标指着这个movey看一下啊 这里出了问题

04:22.410 --> 04:25.450
这个movey呢 他推断出来是一个movey的数组

04:26.170 --> 04:31.170
他怎么把它变成数组了呢 好 我们来看一下啊 到底是怎么回事 他为什么把它变成了数组

04:31.810 --> 04:36.810
好 这是怎么回事呢 其实啊 这个函数呢 他是有两个重债的

04:37.370 --> 04:44.050
我们点击这个函数啊 然后按鍵盘上的f12啊 f12 这样子可以转到定义

04:45.090 --> 04:52.850
好 到了定义里边去的话 我们可以看到啊 非常清楚 这里声明了内雄声明嘛 对吧啊 音这个时候点地点贴实

04:53.570 --> 04:55.850
然后这里呢 导出了两个函数

04:56.810 --> 04:57.850
就是函数的重债

04:58.610 --> 05:04.810
这两个函数呢 他们的参数呢 方式不一样啊 一个第一个呢是plain to class

05:06.050 --> 05:14.210
他有两个范形 一个是t 好 第二个v呢 这个v是啥呢 就是你要转换的对象 我要把哪个对象进行转换

05:15.010 --> 05:22.290
这个v如果满足这个约束 如果满足这个约束 那么他就认为他使用的是这个重债

05:23.290 --> 05:29.490
而这个重债呢 返回的是啥呢 你看一下 返回的是一个数组 看呗 返回的是一个数组

05:30.170 --> 05:33.650
也就是说刚才这种情况呢 他匹配到了第一个重债

05:34.450 --> 05:42.690
怎么回事呢 我们刚才传的是啥 传的是M M的内雄是啥 是不是n d 对吧 n d

05:43.330 --> 05:48.170
而nd的话 他一定是满足这个约束的 这个约束一定满足

05:48.770 --> 05:57.050
因为nd他可以满足任何约束 nd可以满足任何约束 所以说这个约束呢 他是满足的 是满足这个约束的

05:57.770 --> 06:04.450
因此呢 这里匹配到了第一个重债 那怎么办呢 其实非常非常简单啊 非常非常简单

06:04.850 --> 06:10.770
我这里呢 只需要做一个内雄断言 把这个M呢 断言成为另外一个 比方说obj

06:12.170 --> 06:18.090
断言成obj 那么这样一来了 他就无法匹配到第一个重债了 第一个重债就匹配不到了

06:18.290 --> 06:20.490
因为obj 它不是一个输出

06:21.370 --> 06:26.530
所以他就能匹配到第二个重债 而第二个重债呢 他返回的就是一个普通对象了

06:27.010 --> 06:34.090
好 我们再看一下movie 就是个普通对象的 这里呢只是简单的处理一下啊 处理一下的内雄断言 而就是

06:34.890 --> 06:40.810
ts内雄的问题 把它处理一下 好 处理好了之后呢 我们这里就可以继续编写了

06:41.250 --> 06:48.050
好 我们要验证啥呢 验证的是这个movie 对吧 我们先不着急验证啊 先不着急验证 我们先把它输出

06:48.050 --> 06:51.090
看一下 看一下这个movie输出的结果是不正确的

06:52.570 --> 06:54.890
好 保存一下啊 看一下结果

06:55.930 --> 07:02.150
这里先清空npm装 对好 看一下输出的结果是不正确的啊

07:03.390 --> 07:10.270
好 那看一下 是不是该有的属性全部有了 对吧 那些有默认值的属性也有了啊 看有默认值的属性也有了

07:11.110 --> 07:18.550
好 这就是我们通过这样子就可以完成这样子转换了啊 就可以完成转换了 好 转换之后呢我们再来验证啊 验证啥

07:18.790 --> 07:24.630
验证这个movie 你看现在可以正常的验证了 保存啊 看一下他的验证啊

07:25.750 --> 07:31.470
啊 验证完了啊 前面前面我们就不要输出了啊 就不要输出了啊 直接运行

07:32.590 --> 07:36.670
啊 验证完了过后啊 验证通过 那么像刚才那个警告没有了

07:37.470 --> 07:43.430
好 现在呢 我们把它有一个属性给他改一下啊 把这个属性改一下 注射掉 注射过后再来

07:44.150 --> 07:48.550
运行啊 运行 你看 现在呢 就出了问题了啊 就出了问题了

07:49.270 --> 07:53.550
那么现在呢 我们就可以搞定这个验证了 所以说这里呢 我们需要进行转换

07:54.430 --> 07:59.910
但是有的时候呢 转换的时候会可能会出现问题啊 可能会出现问题 比方说这个内蒙所向

08:00.790 --> 08:02.710
这个内蒙所向如果我写的是一个数字

08:03.950 --> 08:10.070
那咋办啊 想想 这个内蒙我写的是个数字啊 我们保存来看一下啊 保存

08:11.030 --> 08:17.750
他验证通过啊 验证通过 然后呢 我们先不管新验证的问题了 先不考虑什么验证的问题 我们先把这个

08:18.710 --> 08:23.270
打印出来看一下啊 打印出来看一下 然后再打印一个什么Type

08:24.830 --> 08:27.110
move move a点

08:27.790 --> 08:30.470
把这个再打印出来 咱们看一下啊 保存

08:32.980 --> 08:38.740
好 我们会发现move a呢 内蒙所向呢 就算是数字

08:39.700 --> 08:44.100
并且它的内形呢 是number 是number 这怎么回事呢

08:44.660 --> 08:52.820
啊 我们 我们在move a里边啊 电影里边 不是设置到那种所向 它的内形是支付串吗 啊 为什么现在又变成了数字了呢

08:53.940 --> 08:57.460
这个我问题我解释过的啊 我先解释过的 怎么回事呢

08:58.180 --> 09:04.180
因为你这里的内形限制是什么呢 是在编译时才有效

09:04.900 --> 09:11.860
运行的过程中 早就没了这个玩意儿 还在吗 编译过后这个玩意儿还在吗 肯定是没了

09:12.340 --> 09:15.940
编译过后不要说他了 这些玩意儿都没了啊 这些玩意儿都没了

09:16.820 --> 09:21.700
因此呢 你在运行的过程中 这里的内形信息早就丢失掉了

09:22.180 --> 09:27.700
所以说内运行的过程中 他可以是任何类型 他可能会被复制为任何类型 你看这个场景

09:28.180 --> 09:30.580
啊 这样你转换过后 他是不是变成其他内形了

09:31.460 --> 09:37.700
那么这个时候呢 我们需要在运行的时候 告诉这个啊 这个第三方库

09:39.060 --> 09:47.220
告诉他 你在做转换的时候呢 我会把你先内形告诉你 你转换的时候要满足内形的要求

09:48.020 --> 09:55.220
那怎么告诉他呢 我们就可以在move里面啊 使用使用这个装饰器啊 因为装饰器是可以被带到

09:55.700 --> 10:01.380
运行的过程中了 因此呢 装饰器呢 可以在运行过程中发挥作用

10:02.100 --> 10:07.540
因此我们在这里呢 写相应的装饰器啊 比方说他有一个装饰器要tap

10:08.820 --> 10:14.340
这个装饰器就在class transformer 这里面有一个有一个函数tap

10:14.900 --> 10:17.780
这个函数里边呢 就可以通过他来告诉

10:18.420 --> 10:20.260
class transformer这个库

10:20.740 --> 10:25.300
告诉他 我这个属性是什么类型 你当时转换的时候呢 按照这个类型来转换

10:25.940 --> 10:32.260
怎么告诉呢 这里有统一的书写格式 这里面传一个箭头函数啊 这个函数的返回返回值

10:32.820 --> 10:37.060
就是他的类型 好 这里是字不算 所以说我们这里要书写

10:37.780 --> 10:38.580
要书写书写

10:39.380 --> 10:47.460
注意 这里的s一定要大一些 不能小写啊 不能小写 为什么呢 因为在ges里边 他不存在这个东西

10:48.100 --> 10:51.620
他不存在这个东西 你在ges里面什么时候见过这个东西

10:52.180 --> 10:57.860
不存在这个东西啊 他这里那是存在这个大写的 大写的s是军 表示的是

10:59.380 --> 11:02.340
制服串的构造函数 表示制服串构造函数

11:03.060 --> 11:10.260
好 那么这里呢 下面这一个是一个数组 对吧 是一个数组 好 那么这里呢 我要通过

11:12.100 --> 11:16.500
tap来告诉他 这一块呢 是一个啥样呢 是一个

11:17.940 --> 11:20.340
array 是一个array 是一个数组

11:21.220 --> 11:25.460
好 原来说我能不能告诉他 这是一个制服串的数组呢

11:26.660 --> 11:32.740
我这里能不能告诉他是一个制服串的数组 注意 你想呗 你想呗 在ges里边

11:33.300 --> 11:36.660
存不存在制服串数组这个类型啊 存不存在

11:37.460 --> 11:43.700
不存在对吧 他是不存在的 因此呢 你通过这种方式是没办法的啊 是没有办法的

11:44.340 --> 11:45.780
好 下面继续啊

11:46.740 --> 11:52.340
tap 告诉他这个地方呢 是一个array 是一个数组

11:53.700 --> 11:56.900
啊 下面啊 这个这个地方呢 是一个

12:00.710 --> 12:04.070
这个地方是一个number 是一个数字

12:05.510 --> 12:12.820
啊 然后下面这个啊 这个地方是一个布尔 是一个布尔

12:14.420 --> 12:18.820
啊 我们一次写了啊 这里复制一下 这里布尔啊 这里布尔

12:19.460 --> 12:22.660
好 然后这里呢 是制服串啊 制服串

12:24.340 --> 12:26.020
好 下面这个也是一个制服串

12:27.700 --> 12:31.060
好 这样子写完了之后 我们再来看一下啊 再来看一下

12:34.570 --> 12:38.490
啊 他这里爆错了 他说一个啥错误了 错误了 他说

12:39.290 --> 12:40.170
reflect

12:40.730 --> 12:41.610
getmedata

12:42.410 --> 12:43.290
这个函数呢

12:43.930 --> 12:47.850
啊 他不是一个function is not function 就这个函数不存在

12:48.570 --> 12:55.210
哎 看到这个你想起了啥 想起了啥 是不是想起了啊 我们之前有一个cool

12:55.770 --> 13:02.250
叫做reflect medata 对吧 想起了这么一个cool 其实呢 这个cool啊

13:03.850 --> 13:09.770
还记得吗 同学们 我们之前学过这么一个cool啊 叫reflect medata

13:11.050 --> 13:12.890
啊 这个cool呢 实际上

13:13.850 --> 13:18.010
在这个class transformer这个cool 它会用到啊 它会用到这个cool

13:18.490 --> 13:23.530
因此呢 它要求你呢 你要把这个cool导入进来啊 你需要把这个cool导入进来

13:24.410 --> 13:30.730
啊 这个导在什么地方导入呢 看你啊 随便只要整个工程导入一次就可以了啊 因为它会向全局

13:31.050 --> 13:32.170
注入一些东西

13:32.970 --> 13:35.050
好 那么我们这里呢 就可以在这里导入吧

13:35.770 --> 13:36.090
import

13:37.130 --> 13:37.690
reflect

13:38.250 --> 13:39.210
好 这里导入不进来

13:40.010 --> 13:42.570
啊 我们还没有安装 对吧 没有安装 好 我们先安装

13:43.610 --> 13:45.370
好 这里 这里停止

13:46.650 --> 13:52.970
然后这里是用yaw add啊 然后使用安装reflect

13:53.770 --> 13:55.050
medata

13:56.090 --> 14:02.810
好 等下安装完成 好 安装完成之后呢 我们这里把这个cool导入进来啊reflect medata

14:03.210 --> 14:05.210
好 导入进来之后呢 我们再来运行

14:06.250 --> 14:07.610
npm raw deal

14:08.170 --> 14:10.780
好 稍等片刻啊

14:12.870 --> 14:18.630
好 现在输出结果了 我们再看一下输出结果这个name属性是变成制服串了 你看一下

14:19.190 --> 14:24.310
我们明明是给它的数字 但是转换过来过后就变成了制服串啊 就变成了制服串

14:24.950 --> 14:26.470
好 比如说输组这一块呢

14:27.510 --> 14:28.790
和输组又咋办呢

14:29.430 --> 14:31.270
比方说输组这一块呢 我给他

14:31.830 --> 14:35.670
不是一个制服串的输组 我给他的是一个二三四

14:36.390 --> 14:39.510
我给他这么一个输组 我们保存一下 你看他结果

14:40.470 --> 14:44.070
得到结果是啥呢 得到结果就是原封不动的结果

14:44.630 --> 14:49.990
这个显然是不满足要求的 对吧 我们要求的输组呢 应该是一个制服串输组

14:50.630 --> 14:51.990
但是这一块呢

14:52.550 --> 14:53.350
怎么办

14:53.830 --> 14:55.910
我们这里限制的是一个array

14:56.150 --> 15:02.070
他并不知道这个array 他到底是一个什么输组 因为在运行的时候内雄丢失掉了

15:02.790 --> 15:07.430
其实呢 这个官方文档啊 他说到了这个问题啊 说到了这个问题

15:08.390 --> 15:10.870
这个问题呢 官方文档建议你这样处理

15:11.350 --> 15:16.710
如果你是一个制服串 如果你是一个输组的话 建议你这里就直接输写

15:17.110 --> 15:18.870
输组每一箱的内雄

15:19.270 --> 15:20.950
比方说输组每一箱是个制服串

15:21.750 --> 15:22.710
建议你这样输写

15:23.510 --> 15:24.230
啊 这样输写

15:24.710 --> 15:26.710
下面也是一样啊 地区也是一样

15:27.350 --> 15:31.110
这里呢 只需要输写制服串 就是输组的每一箱的内雄

15:31.430 --> 15:34.870
那么他如果得到一个输组的话 他会自动帮你完成转换

15:35.830 --> 15:37.750
好 你看一下 他得到的是一个输组

15:38.550 --> 15:41.030
自动帮你完成转换啊 转换成这个样子了

15:42.390 --> 15:45.190
啊 OK啊 那咱们现在输组也搞定了

15:45.910 --> 15:50.950
好 我们再继续看 还是有问题啊 还是有问题 所以说这些问题啊 都是

15:51.670 --> 15:54.310
根源在哪呢 根源倒不是ts的问题

15:55.430 --> 15:59.990
是gs的问题啊 你说之前我怎么没有遇到这样的问题呢

16:00.310 --> 16:02.790
因为之前你根本就没有关注内雄检查

16:03.270 --> 16:05.030
啊 你认为内雄检查无所谓

16:05.430 --> 16:08.950
但是在大型项目里边 内雄检查是非常非常重要的

16:09.670 --> 16:13.030
以前你没有关注内雄检查 所以说你当然你觉得没问题

16:13.430 --> 16:18.150
但是一旦要使用内雄检查的话 借使一些弱项啊就提前出来了

16:18.710 --> 16:24.070
那么这个时候你看 我又可以给他一个一个普通的制服串 那又咋办了

16:24.710 --> 16:25.430
不是输组

16:26.390 --> 16:27.350
你看一下 保存一下

16:28.710 --> 16:29.430
不是输组

16:30.150 --> 16:34.550
这个时候你就太为难这个酷了 他做不到了啊

16:35.830 --> 16:37.110
他其实能不能做了

16:37.670 --> 16:41.670
通过某种方式也能做 只不过太过于麻烦 我们就不去考虑了

16:41.990 --> 16:43.830
那么这个时候呢 我建议大家这样处理

16:45.030 --> 16:49.030
你不是有验证库吗 对吧 你之前写了这个class validator

16:49.350 --> 16:54.150
这个验证库 你在这个验证库里边加一个验证完事 加一个验证

16:55.190 --> 16:56.950
就是验证啥呢 一是array

16:57.670 --> 16:59.350
加上这么一个验证

17:00.070 --> 17:04.790
必须是一个数 必须是一个输组啊 如果不是输组的话 给他一个错误消息

17:05.590 --> 17:06.790
那就是说啊

17:08.150 --> 17:11.430
电影内行必须是输组

17:12.550 --> 17:13.350
必须是输组

17:14.150 --> 17:17.270
啊 加上这么个验证就完事了啊 这里下面也是一样啊

17:17.670 --> 17:21.110
加上这么个验证 你可以不给我传输组 那我就验证冒错呗

17:21.670 --> 17:23.750
好 这就是电影地区地区

17:24.790 --> 17:26.150
地区必须是输组

17:27.110 --> 17:29.350
好 保存一下啊 然后再过来看一下

17:29.910 --> 17:38.630
这样子呢 虽然我允许你这样复职啊 虽然允许你这样复职 但是呢 你验证通不过啊 不让你通过验证

17:39.430 --> 17:40.790
看一下下面的验证啊

17:42.630 --> 17:43.110
保存

17:44.550 --> 17:47.670
啊 你看现在验证了通不过啊 你必须是一个输组

17:48.390 --> 17:50.070
啊 内行的必须必须要有一个

17:50.710 --> 17:51.990
好 那么现在呢

17:52.470 --> 17:59.670
验证这个库和转换 内行转换这个库呢 他们配合起来 我们就把整个实体内啊

18:00.470 --> 18:02.710
给他开发出来了啊 给他开发出来了

18:03.590 --> 18:07.190
好 有了这个实体内之后呢 我们再来说后边的事情什么

18:07.830 --> 18:08.950
保存数据库啊

18:09.510 --> 18:14.710
什么啊 API接口啊 这些东西 我们再考虑这些问题 先把实体内开发好

18:15.190 --> 18:19.830
啊 当然呢 咱们这个系统如果要完善一点的话 其实不止电影还什么

18:20.310 --> 18:28.310
愿先啊 文章用户 这些呢 都是对应一个实体内啊 一次在这里去书写这些内举完事了

18:28.630 --> 18:35.750
好 咱们先把这个实体内搞定啊 好 那么这几课呢 我们搞定了内行的转换 就是把一个play object转换成

18:36.310 --> 18:37.270
实体内的对象

18:37.990 --> 18:40.310
好 那么下几课 我们开始开发数据库

