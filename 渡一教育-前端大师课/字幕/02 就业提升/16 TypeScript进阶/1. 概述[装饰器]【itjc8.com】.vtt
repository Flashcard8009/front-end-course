WEBVTT

00:01.140 --> 00:04.140
大家好 我是杜亦教育 我也不经常讲识人远镜

00:04.140 --> 00:08.140
好 这期课呢 我们来学习装饰器

00:08.140 --> 00:11.140
这个玩意上呢

00:11.140 --> 00:14.140
首先它是一个面向对象的概念啊 这个东西

00:14.140 --> 00:18.140
它是面向对象的概念

00:18.140 --> 00:21.140
在很多的面向对象语言中都有这么一个东西

00:21.140 --> 00:24.140
像java啊 像syshark 它都有装饰器

00:24.140 --> 00:27.140
只不过呢 它们的教法不一样

00:27.140 --> 00:30.140
在java里面呢 叫做注写

00:30.140 --> 00:33.140
然后在syshark 语言里边呢 它叫做

00:33.140 --> 00:36.140
特征

00:36.140 --> 00:39.140
在ts里边把它叫做装饰器

00:39.140 --> 00:42.140
它的英文单词呢 叫做decorator

00:42.140 --> 00:45.140
decorator 就这个东西

00:45.140 --> 00:48.140
好 这个玩意呢 目前啊 我看

00:48.140 --> 00:52.140
我注意到在前端环境里边 还没有大规模的使用

00:52.140 --> 00:54.140
但是在angela 啊

00:54.140 --> 00:57.140
angela 里边已经大量使用了

00:58.140 --> 01:01.140
在react里边呢 也会用到

01:01.140 --> 01:04.140
在react里边也会用到

01:04.140 --> 01:06.140
也会用到

01:06.140 --> 01:09.140
当然它必须要前提条件的是要支持ts

01:09.140 --> 01:12.140
react的 我们之前也用react和ts

01:12.140 --> 01:15.140
做了一个小的练习 对吧

01:15.140 --> 01:18.140
做了一个紧制期的游戏

01:18.140 --> 01:21.140
那么如果react跟那个ts连着使用的话

01:21.140 --> 01:24.140
它里边也有可能会用到装饰器

01:24.140 --> 01:27.140
装饰器这个东西呢

01:27.140 --> 01:30.140
目前啊 在前端领域里边

01:30.140 --> 01:33.140
还没有大规模的使用

01:33.140 --> 01:36.140
但是呢 我发现的现象是

01:36.140 --> 01:39.140
用的越来越多了 用的越来越多了

01:39.140 --> 01:42.140
并且呢 有一些第三方库

01:42.140 --> 01:45.140
完全是基于装饰器这么一个功能来制作的

01:45.140 --> 01:48.140
而装饰器呢 目前啊

01:48.140 --> 01:51.140
目前

01:51.140 --> 01:54.140
GS本身支持装饰器

01:54.140 --> 01:57.140
支持装饰器 就在GS标准里边

01:57.140 --> 01:59.140
就有装饰器这么个东西

01:59.140 --> 02:02.140
但是呢 它还没有成为最终的标准

02:02.140 --> 02:05.140
它目前的标 我们知道啊

02:05.140 --> 02:08.140
在acma script这个组织啊 它要制定一个标准

02:08.140 --> 02:10.140
需要经过一些阶段 对吧

02:10.140 --> 02:13.140
需要经过第1个 第2个 第3个 第4个 第5个

02:13.140 --> 02:15.140
需要经过一些阶段 那么最终呢

02:15.140 --> 02:17.140
才能把这个标准确定下来

02:17.140 --> 02:21.140
那么目前的这个装饰器啊 在GS里边

02:21.140 --> 02:24.140
它是 目前是处于第2阶段

02:24.140 --> 02:28.140
目前处于建议

02:28.140 --> 02:35.510
争及 争及的第2阶段

02:35.510 --> 02:37.510
也就是说 目前的装饰器

02:37.510 --> 02:39.510
还不是最终的标准 未来呢

02:39.510 --> 02:42.510
它的语法呢 写法上

02:42.510 --> 02:45.510
以它的作用上啊 语法都可能会发生

02:45.510 --> 02:47.510
巨大的改变 但是呢

02:47.510 --> 02:51.510
现在很多的前端技术啊都已经等不及了

02:51.510 --> 02:53.510
像这个安特别是安格拉啊

02:53.510 --> 02:56.510
因为它纯粹是靠TS打减起来的

02:56.510 --> 02:58.510
这么一个框架

02:58.510 --> 03:01.510
所以说呢 它里的用到了大量的

03:01.510 --> 03:03.510
面向对象的东西

03:03.510 --> 03:04.510
而面向对象里的装饰器

03:04.510 --> 03:06.510
是一个非常非常重要的概念

03:06.510 --> 03:08.510
因此呢 安格拉现在着急得不得了

03:08.510 --> 03:10.510
一直在吹那边 吹那个

03:10.510 --> 03:12.510
acma script组织

03:12.510 --> 03:15.510
让它赶快把这个标准定下来

03:15.510 --> 03:18.510
所以说 装饰器呢

03:18.510 --> 03:20.510
不仅是现在学习有意义

03:20.510 --> 03:21.510
现在学习了之后呢

03:21.510 --> 03:23.510
我们在rex 啊 安格拉

03:23.510 --> 03:25.510
以及一些第三方的库里边呢

03:25.510 --> 03:26.510
会用到

03:26.510 --> 03:28.510
而且对于将来来说

03:28.510 --> 03:30.510
装饰器呢 也是一个

03:30.510 --> 03:32.510
可以说是一个必然的趋势吧

03:32.510 --> 03:33.510
装饰器这个东西

03:33.510 --> 03:35.510
啊 面向对象我还说不准

03:35.510 --> 03:37.510
但是装饰器

03:37.510 --> 03:39.510
我可以百分之百的肯定

03:39.510 --> 03:43.510
将来 将来一定会大量的使用

03:43.510 --> 03:45.510
那么装饰器它到底是什么东西

03:45.510 --> 03:47.510
它来解决什么样的问题呢

03:47.510 --> 03:48.510
我们首先呢

03:48.510 --> 03:50.510
对这个装饰器啊 做一个概述

03:50.510 --> 03:52.510
大概讲一讲啊

03:52.510 --> 03:54.510
给大家有这么一个印象

03:54.510 --> 03:56.510
啊 概述

03:56.510 --> 03:57.510
好 首先说

03:57.510 --> 04:01.510
它能够解决一个什么样的问题

04:01.510 --> 04:05.510
它最常见解决的问题呢是

04:05.510 --> 04:07.510
解决的问题

04:07.510 --> 04:11.510
装饰器最常见的用来解决的问题

04:11.510 --> 04:13.510
是分离关注点

04:13.510 --> 04:15.510
啊 分离关注点

04:15.510 --> 04:17.510
它怎么来分离关注点呢

04:17.510 --> 04:19.510
什么叫分离关注点呢

04:19.510 --> 04:22.510
什么情况下需要分离关注点呢

04:22.510 --> 04:24.510
好 我们来举个例子啊

04:24.510 --> 04:26.510
用一个例子来说明

04:26.510 --> 04:28.510
它到底要解决什么样的问题

04:28.510 --> 04:32.510
比方说我们这里写这么一个东西

04:32.510 --> 04:33.510
写这么一个内

04:33.510 --> 04:35.510
比方说一个用户内

04:35.510 --> 04:37.510
用户内里边呢

04:37.510 --> 04:39.510
它有这么一些属箱

04:39.510 --> 04:41.510
有一些属箱

04:41.510 --> 04:43.510
我们这里写上

04:43.510 --> 04:45.510
比方说LoginID

04:45.510 --> 04:48.510
LoginID表示的是登录账号

04:48.510 --> 04:51.510
登录账号有这么一个属箱

04:51.510 --> 04:53.510
我把这个取消掉吧

04:53.510 --> 04:54.510
我这难得去一些

04:54.510 --> 04:55.510
给它复出词了

04:55.510 --> 04:57.510
把这个取消掉啊

04:57.510 --> 04:59.510
把这个

04:59.510 --> 05:01.510
strict property initialization

05:01.510 --> 05:03.510
把取消掉啊

05:04.510 --> 05:05.510
LoginID

05:05.510 --> 05:07.510
还有一个Login password的

05:07.510 --> 05:08.510
登录密码

05:08.510 --> 05:10.510
它也是一个支付串

05:10.510 --> 05:11.510
然后用户还有啥呢

05:11.510 --> 05:13.510
还有年龄对吧

05:13.510 --> 05:14.510
还有年龄

05:14.510 --> 05:15.510
还有啥呢

05:15.510 --> 05:17.510
用户还有就是性别

05:17.510 --> 05:20.510
性别针道

05:20.510 --> 05:22.510
这个是一个

05:22.510 --> 05:23.510
比方说是一个支付串吧

05:23.510 --> 05:25.510
或者是一个质面量

05:25.510 --> 05:26.510
质面量约束

05:26.510 --> 05:30.890
男或者是女

05:30.890 --> 05:31.890
好了

05:31.890 --> 05:33.890
那么有了这个用户内之后呢

05:33.890 --> 05:34.890
我们后边呢

05:34.890 --> 05:37.890
可能会创建各种各样的用户对象

05:37.890 --> 05:40.890
有可能会创建各种各样的用户对象

05:40.890 --> 05:41.890
这个时候呢

05:41.890 --> 05:43.890
我们可能会对用户对象

05:43.890 --> 05:45.890
来做一些验证

05:45.890 --> 05:47.890
有一个用户对象

05:47.890 --> 05:49.890
我们可能会

05:49.890 --> 05:52.890
对用户对象

05:52.890 --> 05:54.890
中的数据

05:54.890 --> 05:56.890
进行验证

05:56.890 --> 05:57.890
怎么验证呢

05:57.890 --> 05:59.890
比方说

05:59.890 --> 06:00.890
账号

06:00.890 --> 06:02.890
账号呢必须是

06:02.890 --> 06:06.890
必须是3-5个支付

06:06.890 --> 06:07.890
而且呢

06:07.890 --> 06:08.890
不能出现啊

06:08.890 --> 06:09.890
就3-5个支付嘛

06:09.890 --> 06:12.890
我们先不给他起大规则

06:12.890 --> 06:14.890
好密码了

06:14.890 --> 06:16.890
密码是

06:16.890 --> 06:20.890
必须是6-12个支付

06:20.890 --> 06:22.890
6-12个支付

06:22.890 --> 06:25.890
年龄呢必须是数字

06:25.890 --> 06:27.890
必须是数字

06:27.890 --> 06:30.890
并且啊并且怎么样呢

06:30.890 --> 06:38.890
必须是0-100之间的数字

06:38.890 --> 06:40.890
必须是0-100之间的数字

06:40.890 --> 06:42.890
当然性别的话只能是男

06:42.890 --> 06:44.890
或者是女

06:44.890 --> 06:47.890
好在这个验证场景下边

06:47.890 --> 06:50.890
我们要创建一个用户

06:50.890 --> 06:51.890
我们可能有的时候呢

06:51.890 --> 06:53.890
需要对用户里面的数据

06:53.890 --> 06:54.890
进行验证

06:54.890 --> 06:56.890
那么验证结果呢

06:56.890 --> 06:58.890
他可能会得到一些

06:58.890 --> 07:00.890
验证出的错误消息

07:00.890 --> 07:02.890
验证是否通过哪个字段

07:02.890 --> 07:05.890
哪个属性验证出的问题

07:05.890 --> 07:07.890
可能会得到这么一个结果

07:07.890 --> 07:09.890
验证它会产生一个结果

07:09.890 --> 07:11.890
现在我们的问题是

07:11.890 --> 07:13.890
这个验证的代码

07:13.890 --> 07:16.890
我们应该写到哪儿

07:16.890 --> 07:18.890
这是一个很麻烦的问题

07:18.890 --> 07:19.890
大家想一想

07:19.890 --> 07:22.890
我要对一个用户的数据进行验证

07:22.890 --> 07:24.890
去验证场景我们很多了

07:24.890 --> 07:25.890
对吧

07:25.890 --> 07:27.890
我们在页面上填一个表单

07:27.890 --> 07:29.890
之后我们点提交之前

07:29.890 --> 07:31.890
是不是要对它进行验证

07:31.890 --> 07:33.890
验证场景是非常非常多的

07:33.890 --> 07:34.890
那么现在的问题

07:34.890 --> 07:36.890
就你先注意到这个点

07:36.890 --> 07:38.890
关注这个点

07:38.890 --> 07:39.890
我们有一个用户内

07:39.890 --> 07:41.890
这个用户内里面有四个属性

07:41.890 --> 07:44.890
每个属性有自己的一些规则

07:44.890 --> 07:46.890
那么我们要对这个属

07:46.890 --> 07:48.890
每个属性只能进行验证

07:48.890 --> 07:50.890
验证的时候

07:50.890 --> 07:53.890
我们应该

07:53.890 --> 07:55.890
把这些验证的代码

07:55.890 --> 07:57.890
写到什么位置

07:57.890 --> 07:59.890
在哪里进行验证

07:59.890 --> 08:02.890
这里最容易想到的第一种方式

08:02.890 --> 08:04.890
写到哪儿呢

08:04.890 --> 08:05.890
写到这儿

08:05.890 --> 08:07.890
在这里进行验证

08:07.890 --> 08:10.890
我这里就一次来判断

08:10.890 --> 08:14.890
一次用户的login ID

08:14.890 --> 08:17.890
它是不是不为空

08:17.890 --> 08:19.890
如果不为空的话

08:19.890 --> 08:21.890
我们继续判断对吧

08:21.890 --> 08:23.890
继续判断

08:23.890 --> 08:25.890
然后用户的login ID

08:25.890 --> 08:28.890
它的长度是不是小于

08:28.890 --> 08:30.890
等于5

08:30.890 --> 08:32.890
并且用户的login ID

08:32.890 --> 08:37.890
它的长度是不是大于等于3

08:37.890 --> 08:38.890
对不对

08:38.890 --> 08:39.890
如果是那种情况

08:39.890 --> 08:40.890
验证通过

08:40.890 --> 08:42.890
那么如果这种情况的话

08:42.890 --> 08:45.890
login ID验证通过

08:45.890 --> 08:48.890
如果login ID没有验证通过的话

08:48.890 --> 08:50.890
如果没有验证通过的话

08:51.890 --> 08:54.890
就输出错误消息

08:57.890 --> 08:58.890
好

08:58.890 --> 08:59.890
这种做法

08:59.890 --> 09:01.890
首先可能我们会想到这种做法

09:01.890 --> 09:03.890
或者再进行其他的验证

09:03.890 --> 09:07.890
进行其他属性的验证

09:08.890 --> 09:10.890
首先我们最容易想到的

09:10.890 --> 09:12.890
就是把验证写外边

09:12.890 --> 09:14.890
验证写外边

09:14.890 --> 09:16.890
它不是说不可以

09:16.890 --> 09:17.890
它当然可以

09:17.890 --> 09:19.890
只不过这样做有什么坏处

09:20.890 --> 09:21.890
分析一下

09:22.890 --> 09:24.890
你如果这样子写代码的话

09:24.890 --> 09:25.890
那么就意味着

09:25.890 --> 09:27.890
以后我每一次

09:27.890 --> 09:29.890
去建立一个用户对象

09:29.890 --> 09:31.890
是不是我都得去验证一次

09:31.890 --> 09:33.890
我都得去重新写一个代码

09:33.890 --> 09:35.890
那么这个太恐怖了

09:35.890 --> 09:36.890
好

09:36.890 --> 09:38.890
接下来有同学就开始来想了

09:38.890 --> 09:40.890
我们把它优化一下

09:40.890 --> 09:42.890
优化一下写成什么呢

09:42.890 --> 09:44.890
写成一个函数

09:44.890 --> 09:46.890
写成一个函数

09:46.890 --> 09:47.890
那么给它取个名字

09:47.890 --> 09:50.890
any dead user

09:50.890 --> 09:52.890
验证一个用户

09:52.890 --> 09:54.890
验证一个用户

09:54.890 --> 09:56.890
那么传一个用户对象进来

09:56.890 --> 09:58.890
给我一个用户对象

09:58.890 --> 10:00.890
那么这里呢

10:00.890 --> 10:01.890
我在对这个用户对象呢

10:01.890 --> 10:02.890
进行验证

10:02.890 --> 10:04.890
那之后无论我是

10:04.890 --> 10:05.890
创建了一个用户

10:05.890 --> 10:07.890
还是创建了多个用户

10:07.890 --> 10:08.890
是不是都可以

10:08.890 --> 10:09.890
调用函数来进行验证

10:09.890 --> 10:10.890
对吧

10:10.890 --> 10:11.890
这个能理解吧

10:11.890 --> 10:12.890
把这个用户

10:12.890 --> 10:13.890
创建了用户对象

10:13.890 --> 10:14.890
传进来

10:14.890 --> 10:15.890
那么它来进行验证

10:15.890 --> 10:16.890
好

10:16.890 --> 10:17.890
这种写法

10:17.890 --> 10:18.890
好

10:18.890 --> 10:21.890
这种写法又有什么问题呢

10:21.890 --> 10:22.890
那你说呢

10:22.890 --> 10:24.890
它还没有太大的问题

10:24.890 --> 10:25.890
这种写法

10:25.890 --> 10:26.890
没有太大的问题

10:26.890 --> 10:28.890
那它的主要问题在哪呢

10:28.890 --> 10:32.890
它把这个用户对象的验证

10:32.890 --> 10:34.890
跟它的验证逻辑

10:34.890 --> 10:38.890
跟这个用户内分离了

10:38.890 --> 10:41.890
它把它分开了

10:41.890 --> 10:42.890
分开了

10:42.890 --> 10:44.890
到底是好还是不好呢

10:44.890 --> 10:46.890
那我们来分析一下吧

10:46.890 --> 10:48.890
假设这个用户内里边

10:48.890 --> 10:50.890
有20个属性

10:50.890 --> 10:51.890
属性很多

10:51.890 --> 10:53.890
有20个属性

10:53.890 --> 10:56.890
那么我问大家一个问题

10:56.890 --> 10:59.890
在我书写这个内的时候

10:59.890 --> 11:00.890
这里需要

11:00.890 --> 11:02.890
这里需要大家好好理解

11:02.890 --> 11:05.890
在我书写这个用户内的时候

11:05.890 --> 11:07.890
我会一个一个的

11:07.890 --> 11:10.890
去写它的每一个属性

11:10.890 --> 11:13.890
那我是写属性的时候

11:13.890 --> 11:16.890
最清楚验证规则

11:16.890 --> 11:17.890
还是说

11:17.890 --> 11:20.890
我写这个函数的时候

11:20.890 --> 11:22.890
最清楚验证规则

11:22.890 --> 11:25.890
好好想想这个暴力

11:25.890 --> 11:29.890
这其实涉及到人的思维方式

11:29.890 --> 11:31.890
你在写这个属性的时候

11:31.890 --> 11:33.890
你清楚它的验证规则

11:33.890 --> 11:35.890
还是说你在写这个函数的时候

11:35.890 --> 11:38.890
清楚验证规则

11:38.890 --> 11:40.890
应该能体会到吧

11:40.890 --> 11:42.890
就这么一个小小的细节

11:42.890 --> 11:44.890
应该能体会到

11:44.890 --> 11:47.890
应该是书写这个属性的时候

11:47.890 --> 11:49.890
你是注意清楚这个属性

11:49.890 --> 11:51.890
表达了什么意识

11:51.890 --> 11:53.890
它的验证规则是啥

11:53.890 --> 11:54.890
为什么呢

11:54.890 --> 11:55.890
因为人想问题

11:55.890 --> 11:57.890
它是一个单向条的

11:57.890 --> 11:58.890
它不像计算机

11:58.890 --> 12:00.890
计算机可以同时做几件事

12:00.890 --> 12:01.890
但是人呢

12:01.890 --> 12:02.890
你如何同时做

12:02.890 --> 12:03.890
超过两件事

12:03.890 --> 12:05.890
脑袋就要晕掉

12:05.890 --> 12:07.890
所以说我在写这个内的时候

12:07.890 --> 12:08.890
我在想

12:08.890 --> 12:09.890
这个内

12:09.890 --> 12:10.890
用户内里边

12:10.890 --> 12:11.890
应该有一个登录账号

12:11.890 --> 12:12.890
你看我就把登录账号的概念

12:12.890 --> 12:13.890
就想出来了

12:13.890 --> 12:15.890
我就写了个罗写ID

12:15.890 --> 12:16.890
就表示登录账号

12:16.890 --> 12:17.890
并且呢

12:17.890 --> 12:18.890
我也想登录账号

12:18.890 --> 12:19.890
应该是一个字不串

12:19.890 --> 12:20.890
然后马上继续想

12:20.890 --> 12:21.890
登录账号的东西

12:21.890 --> 12:24.890
是不是这种符合人的思维

12:24.890 --> 12:25.890
对吧

12:25.890 --> 12:26.890
它是非常自然的一种思维

12:26.890 --> 12:28.890
我在想到它的时候

12:28.890 --> 12:30.890
跟它相关的一些东西

12:30.890 --> 12:32.890
我就全部想出来了

12:32.890 --> 12:33.890
因此呢

12:33.890 --> 12:36.890
我在书写属性的时候

12:36.890 --> 12:38.890
我是非常清楚

12:38.890 --> 12:42.890
这个属性应该有哪些验证规则

12:42.890 --> 12:44.890
这个属性表达的是什么意思

12:44.890 --> 12:46.890
它有哪些验证规则

12:46.890 --> 12:48.890
我是非常清楚的

12:48.890 --> 12:49.890
但是如果你到

12:49.890 --> 12:50.890
你把登到

12:50.890 --> 12:51.890
你把这个内写完了

12:51.890 --> 12:54.890
二十个几个属性写完了过后

12:54.890 --> 12:55.890
然后再让你去写一个

12:55.890 --> 12:57.890
函数ValidusUr

12:57.890 --> 12:59.890
让你在这里面再去想

12:59.890 --> 13:01.890
它的有哪些验证规则

13:01.890 --> 13:02.890
是不是老在一下子就蒙一下

13:02.890 --> 13:03.890
对不对

13:03.890 --> 13:04.890
马上蒙一下

13:04.890 --> 13:05.890
像我就说

13:05.890 --> 13:06.890
说到这的时候

13:06.890 --> 13:07.890
我老在那蒙了一下

13:07.890 --> 13:09.890
这个用户里面哪些属性

13:09.890 --> 13:10.890
我都忘了

13:10.890 --> 13:11.890
因为哪些属性我都忘了

13:11.890 --> 13:13.890
还不说我要去给它设置验证规则了

13:13.890 --> 13:15.890
我要去从头去看

13:15.890 --> 13:16.890
一个属性

13:16.890 --> 13:18.890
你看我们之前开发单

13:18.890 --> 13:19.890
是不是这样子的

13:19.890 --> 13:20.890
我给它写验证规则的时候

13:20.890 --> 13:21.890
我去看一下

13:21.890 --> 13:22.890
这个属性

13:22.890 --> 13:23.890
这个属性

13:23.890 --> 13:24.890
这个属性

13:24.890 --> 13:26.890
它应该是什么样的验证规则呢

13:26.890 --> 13:27.890
我要去想一想

13:27.890 --> 13:28.890
这个就是

13:28.890 --> 13:29.890
其实这是一种

13:29.890 --> 13:32.890
不是很自然的开发方式

13:32.890 --> 13:34.890
有些同学说

13:34.890 --> 13:35.890
这个验证用户

13:35.890 --> 13:37.890
它也可以写到这里边

13:37.890 --> 13:38.890
对吧

13:38.890 --> 13:39.890
Validate

13:39.890 --> 13:41.890
验证当前这个用户

13:41.890 --> 13:43.890
那么就验证Z

13:43.890 --> 13:44.890
验证Z

13:44.890 --> 13:46.890
它也是一样的问题

13:46.890 --> 13:48.890
它也是一样的问题

13:48.890 --> 13:49.890
那么这里雕用的话

13:49.890 --> 13:51.890
就是雕用的Validate

13:51.890 --> 13:54.890
对这个用户本身的数据进行验证

13:54.890 --> 13:56.890
当然这是面向对向的书写方式

13:56.890 --> 13:57.890
不过这种方式

13:57.890 --> 13:58.890
还是一样的问题

13:58.890 --> 13:59.890
就是说

13:59.890 --> 14:01.890
我在书写的属性的时候

14:01.890 --> 14:03.890
本来非常清楚规则的

14:03.890 --> 14:05.890
但是你一定要让我跑到

14:05.890 --> 14:07.890
函数里面去处理这个问题

14:07.890 --> 14:08.890
然后我就蒙了

14:08.890 --> 14:09.890
我可能要蒙一下

14:09.890 --> 14:10.890
这个时候呢

14:10.890 --> 14:12.890
相当于是我把这个问题想了两遍

14:12.890 --> 14:13.890
第一开始写属性的时候

14:13.890 --> 14:15.890
我在里面本来就出来它的验证规则

14:15.890 --> 14:17.890
结果了导致

14:17.890 --> 14:18.890
我当时就把忽略掉了

14:18.890 --> 14:20.890
然后跑到

14:20.890 --> 14:22.890
这个函数里面去书写

14:22.890 --> 14:24.890
那么也就是说

14:24.890 --> 14:25.890
我们传统这种

14:25.890 --> 14:27.890
不管是面向对象也好

14:27.890 --> 14:29.890
还是像我们面向过程的方式

14:29.890 --> 14:30.890
在这里写个函数

14:30.890 --> 14:32.890
外面写个函数来进行验证也好

14:32.890 --> 14:34.890
都会出现这样的问题

14:34.890 --> 14:35.890
什么问题呢

14:35.890 --> 14:38.890
就是关注点问题

14:38.890 --> 14:41.890
关注点的问题

14:41.890 --> 14:42.890
关注点呢

14:42.890 --> 14:44.890
往往具有这么一个特征

14:44.890 --> 14:46.890
具有这么一个特征

14:46.890 --> 14:47.890
什么意思呢

14:47.890 --> 14:48.890
就是说

14:48.890 --> 14:51.890
在定义

14:51.890 --> 14:54.890
某个东西时

14:54.890 --> 14:57.890
应该最清楚

14:57.890 --> 15:03.580
该东西的

15:03.580 --> 15:05.580
情况

15:05.580 --> 15:07.580
你在写它的时候

15:07.580 --> 15:09.580
你是注意清楚它的情况的

15:09.580 --> 15:10.580
对吧

15:10.580 --> 15:11.580
我们基于这么一个点

15:11.580 --> 15:12.580
但是呢

15:12.580 --> 15:14.580
我们在这里

15:14.580 --> 15:16.580
我们在传统的就是代码里面

15:16.580 --> 15:18.580
我们不得不把它分开

15:18.580 --> 15:20.580
不得不把它分开

15:20.580 --> 15:21.580
这是第一个问题

15:21.580 --> 15:22.580
第二个问题呢

15:22.580 --> 15:24.580
还有重复代码的问题

15:24.580 --> 15:26.580
因为这里怎么会有

15:26.580 --> 15:27.580
重复代码的问题呢

15:27.580 --> 15:33.050
我要判断用户的账号

15:33.050 --> 15:35.050
它的长度

15:35.050 --> 15:37.050
必须是3到5之间

15:39.050 --> 15:41.050
用户的账号

15:41.050 --> 15:43.050
它的长度必须是3到5之间

15:43.050 --> 15:45.050
那么这个是表示验证通过

15:45.050 --> 15:46.050
那一会儿

15:46.050 --> 15:48.050
我要判断用户密码的时候

15:48.050 --> 15:51.050
你看一下代码是不是类似的

15:51.050 --> 15:53.050
login password

15:53.050 --> 15:54.050
长度

15:54.050 --> 15:55.050
只是把它变了一个

15:55.050 --> 15:57.050
login id变成了 password对吧

15:57.050 --> 16:00.050
3和5变成了6和12

16:00.050 --> 16:01.050
对不对

16:01.050 --> 16:04.050
只是变化了这么一些东西

16:05.050 --> 16:07.050
懂我意思吗

16:09.050 --> 16:10.050
懂我意思吗

16:10.050 --> 16:11.050
那么这个时候呢

16:11.050 --> 16:13.050
其实这两个判断了

16:13.050 --> 16:15.050
这两个验证其实是差不多的

16:15.050 --> 16:17.050
好 我们继续发散

16:17.050 --> 16:18.050
发散思维

16:18.050 --> 16:21.050
那如果将来有这么一些类

16:21.050 --> 16:23.050
比方说文章类

16:24.050 --> 16:26.050
比方说文章

16:26.050 --> 16:27.050
article

16:27.050 --> 16:29.050
文章里边有标题

16:29.050 --> 16:30.050
文章的标题

16:30.050 --> 16:32.050
那么标题它也是一个字不错

16:32.050 --> 16:33.050
标题我们认为

16:33.050 --> 16:35.050
必须

16:35.050 --> 16:37.050
长度

16:37.050 --> 16:39.050
必须是

16:39.050 --> 16:41.050
4到

16:41.050 --> 16:43.050
20个字符

16:43.050 --> 16:44.050
那么这里呢

16:44.050 --> 16:46.050
我到时要对它进行验证的时候

16:46.050 --> 16:48.050
是不是我又得写一遍

16:48.050 --> 16:50.050
包括一些政则表达式的验证

16:50.050 --> 16:51.050
政则表达式的验证的话

16:51.050 --> 16:53.050
它只是政则表达式不一样

16:53.050 --> 16:55.050
它验证的方式都是一样的

16:55.050 --> 16:57.050
数字的验证

16:57.050 --> 16:58.050
飞空的验证

16:58.050 --> 16:59.050
你必须要填写

16:59.050 --> 17:00.050
飞空的验证

17:00.050 --> 17:02.050
它们都是差不多的代码

17:02.050 --> 17:04.050
但是呢我们这里

17:04.050 --> 17:06.050
只能重复书写

17:06.050 --> 17:08.050
只能重复书写

17:08.050 --> 17:09.050
那有些同学呢

17:09.050 --> 17:10.050
有可能有些想

17:10.050 --> 17:11.050
那简单啊

17:11.050 --> 17:12.050
那简单啊

17:12.050 --> 17:14.050
我把这些对字不错的长度验证

17:14.050 --> 17:16.050
我把它单独提成一个函数

17:16.050 --> 17:17.050
比如说在这里

17:17.050 --> 17:19.050
验证字不错

17:19.050 --> 17:21.050
validate

17:21.050 --> 17:23.050
验证字不错

17:23.050 --> 17:25.050
你给我一个最小长度

17:25.050 --> 17:26.050
你可以给我一个最大长度

17:26.050 --> 17:27.050
那么我来帮你

17:27.050 --> 17:29.050
然后给我一个字不错

17:29.050 --> 17:31.050
我来帮你把这个字不错来进行验证

17:31.050 --> 17:32.050
验证字

17:32.050 --> 17:33.050
但是这样子

17:33.050 --> 17:34.050
你来是不是打

17:34.050 --> 17:36.050
是破坏了这个内的结构啊

17:36.050 --> 17:37.050
这个内的结构怎么

17:37.050 --> 17:39.050
出来这么多验证的东西呢

17:39.050 --> 17:40.050
它本来有自己的

17:40.050 --> 17:41.050
很多的业务逻辑

17:41.050 --> 17:43.050
有很多的自己的事情

17:43.050 --> 17:44.050
它忙都忙不过来

17:44.050 --> 17:45.050
这个用户内里边

17:45.050 --> 17:46.050
它要做什么

17:46.050 --> 17:47.050
用户的登录啊

17:47.050 --> 17:49.050
用户的注册啊

17:49.050 --> 17:50.050
用户发布文章啊

17:50.050 --> 17:51.050
用户的权限啊

17:51.050 --> 17:53.050
用户的审核提交啊

17:53.050 --> 17:54.050
这些乱七八糟的东西

17:54.050 --> 17:56.050
它可能要做很多很多

17:56.050 --> 17:58.050
跟自己相关的事

17:58.050 --> 17:59.050
你光是验证

17:59.050 --> 18:00.050
就写了一大堆代码

18:00.050 --> 18:01.050
我还没有开始

18:01.050 --> 18:02.050
处理任何的业务逻辑

18:02.050 --> 18:03.050
那么这样子

18:03.050 --> 18:05.050
写代码是非常令人沮丧的

18:05.050 --> 18:06.050
我都没有去处理

18:06.050 --> 18:08.050
核心的业务逻辑

18:08.050 --> 18:10.050
那我这里呢

18:10.050 --> 18:13.680
我们就看到另外一个问题啊

18:13.680 --> 18:15.680
就是一个关注点的问题

18:15.680 --> 18:17.680
关注点呢

18:17.680 --> 18:19.680
我们把它那个

18:19.680 --> 18:21.680
把这个

18:21.680 --> 18:22.680
它的规则啊

18:22.680 --> 18:23.680
分立到其他地方了

18:23.680 --> 18:24.680
那么其实

18:24.680 --> 18:25.680
我们在定义它的时候

18:25.680 --> 18:27.680
最清楚它的规则

18:27.680 --> 18:28.680
好

18:28.680 --> 18:30.680
然后第二个问题

18:30.680 --> 18:31.680
第二个问题就是

18:31.680 --> 18:33.680
重复代码的问题

18:33.680 --> 18:35.680
重复代码的问题

18:35.680 --> 18:37.680
就是有些东西呢

18:37.680 --> 18:39.680
就像刚才验证规则里边

18:39.680 --> 18:40.680
它的验证方式呢

18:40.680 --> 18:41.680
是基本上是一致的

18:41.680 --> 18:43.680
很多地方都有重复

18:43.680 --> 18:45.680
那么如何来提拒重复代码

18:45.680 --> 18:47.680
好 这两个问题

18:47.680 --> 18:48.680
怎么解决呢

18:48.680 --> 18:51.680
他们产生的根源

18:51.680 --> 18:55.680
产生的根源是啥呢

18:55.680 --> 18:58.680
上述

18:58.680 --> 19:00.680
上述两个问题

19:00.680 --> 19:02.680
产生的根源

19:02.680 --> 19:04.680
这个根源大家肯定是找不到

19:04.680 --> 19:06.680
我给大家说一下再解释

19:06.680 --> 19:08.680
产生的根源是

19:08.680 --> 19:12.680
某些信息

19:12.680 --> 19:14.680
在定义时

19:14.680 --> 19:16.680
在定义

19:16.680 --> 19:18.680
定义的时候

19:18.680 --> 19:22.680
能够附加的信息量

19:22.680 --> 19:24.680
有限

19:24.680 --> 19:27.680
这才两个问题产生的根源

19:27.680 --> 19:29.680
我给它解释一下

19:29.680 --> 19:32.680
什么叫做附加的信息量有限

19:32.680 --> 19:34.680
为什么附加的信息量有限

19:34.680 --> 19:36.680
就产生了这样的问题

19:36.680 --> 19:38.680
来吧

19:38.680 --> 19:41.680
我们在写这个属性的时候

19:41.680 --> 19:43.680
这个属性名

19:43.680 --> 19:44.680
是不是个信息量

19:44.680 --> 19:45.680
属性名字叫做

19:45.680 --> 19:47.680
LoginID

19:47.680 --> 19:49.680
当然属性名它是唯一的

19:49.680 --> 19:50.680
这产生了一个信息

19:50.680 --> 19:51.680
我这里有个属性

19:51.680 --> 19:54.680
它的名字叫做LoginID

19:54.680 --> 19:57.680
属性的内形是制服创

19:57.680 --> 19:58.680
属性的内形

19:58.680 --> 19:59.680
你看现在我们产生了

19:59.680 --> 20:01.680
产生两个信息

20:01.680 --> 20:04.680
那么还有一些信息呢

20:04.680 --> 20:06.680
这个属性必须是

20:06.680 --> 20:08.680
三到五个制服

20:08.680 --> 20:09.680
这个信息

20:09.680 --> 20:11.680
我能不能告诉系统这个信息

20:11.680 --> 20:12.680
我现在有没有办法

20:12.680 --> 20:15.680
告诉系统这么一个信息呢

20:15.680 --> 20:16.680
这个信息我是没法告诉的

20:16.680 --> 20:17.680
因为属性的

20:17.680 --> 20:19.680
属写规则就是这样子

20:19.680 --> 20:20.680
一个属性名

20:20.680 --> 20:21.680
一个内形结束了

20:21.680 --> 20:22.680
如果是JS里面

20:22.680 --> 20:23.680
连这个都没有

20:23.680 --> 20:24.680
对吧

20:24.680 --> 20:25.680
连这个内形都没有

20:25.680 --> 20:27.680
它只有一个属性的名字

20:27.680 --> 20:29.680
它这个属性可能是任何字

20:29.680 --> 20:31.680
所以说还有一些信息量

20:31.680 --> 20:32.680
我们丢失掉了

20:32.680 --> 20:33.680
比方说

20:33.680 --> 20:34.680
这个属性

20:34.680 --> 20:35.680
它显示到界面上

20:35.680 --> 20:36.680
比方说

20:36.680 --> 20:39.680
它显示的提示文字是什么

20:39.680 --> 20:41.680
提示文字应该是账号对吧

20:41.680 --> 20:43.680
账号这两个字

20:43.680 --> 20:45.680
我怎么把账号这两个字

20:45.680 --> 20:46.680
这个信息

20:46.680 --> 20:48.680
告诉这个系统呢

20:48.680 --> 20:49.680
告诉这个计算机呢

20:49.680 --> 20:50.680
告诉这个语言呢

20:50.680 --> 20:51.680
我现在做不到

20:51.680 --> 20:52.680
因为属性

20:52.680 --> 20:53.680
它只能这样子写

20:53.680 --> 20:54.680
一个属性名跟内形完了

20:54.680 --> 20:55.680
它没地方写了

20:55.680 --> 20:57.680
还有一些附加信息

20:57.680 --> 20:59.680
就没有地方写了

20:59.680 --> 21:01.680
由于缺少这个信息量

21:01.680 --> 21:04.680
本来我们在定义属性的时候

21:04.680 --> 21:06.680
我非常清楚它的各种情况

21:06.680 --> 21:07.680
它的

21:07.680 --> 21:09.680
它的描述是

21:09.680 --> 21:10.680
账号

21:10.680 --> 21:11.680
比方说

21:11.680 --> 21:13.680
描述是什么

21:13.680 --> 21:15.680
账号这两个字

21:15.680 --> 21:16.680
我只能通过注释

21:16.680 --> 21:18.680
但是计算机又读不懂注释

21:18.680 --> 21:20.680
它根本就不会读注释

21:20.680 --> 21:21.680
它的描述是账号

21:21.680 --> 21:23.680
兵情了它的验证规则

21:23.680 --> 21:24.680
验证规则

21:24.680 --> 21:25.680
有两个

21:25.680 --> 21:27.680
一是避田

21:27.680 --> 21:29.680
避田

21:29.680 --> 21:31.680
二必须是3到5个制服

21:31.680 --> 21:32.680
有这些验证规则

21:32.680 --> 21:33.680
像这些信息

21:33.680 --> 21:34.680
我怎么去告诉系统

21:34.680 --> 21:36.680
我非常清楚这些信息

21:36.680 --> 21:38.680
但是我没有办法告诉系统

21:38.680 --> 21:40.680
所以说就没有办法

21:40.680 --> 21:42.680
我就必须要

21:42.680 --> 21:43.680
写单独一个函数

21:43.680 --> 21:45.680
把这个信息量了

21:45.680 --> 21:46.680
把这些信息

21:46.680 --> 21:48.680
转移到这个函数里面来

21:48.680 --> 21:50.680
然后这里验证没有通过

21:50.680 --> 21:51.680
验证没有通过

21:51.680 --> 21:52.680
我这里就输出

21:52.680 --> 21:59.680
账号不正确

21:59.680 --> 22:00.680
那么这个账号

22:00.680 --> 22:01.680
这两个字

22:01.680 --> 22:02.680
这个信息量是不是跑到这儿来了

22:02.680 --> 22:04.680
本来应该是在这儿的

22:04.680 --> 22:05.680
但是跑到这儿来了

22:05.680 --> 22:07.680
因为这没办法

22:07.680 --> 22:08.680
没办法

22:08.680 --> 22:09.680
我只能把它的信息量

22:09.680 --> 22:11.680
放到其他位置

22:11.680 --> 22:13.680
那么就之前出现的关注点

22:13.680 --> 22:14.680
发生很奇怪的现象

22:14.680 --> 22:16.680
就是这个地方造成的

22:16.680 --> 22:17.680
本来这里还有一些

22:17.680 --> 22:18.680
额外的信息的

22:18.680 --> 22:19.680
关于这个账号

22:19.680 --> 22:20.680
关于这个密码

22:20.680 --> 22:21.680
关于年龄和性别

22:21.680 --> 22:22.680
还有一些信息的

22:22.680 --> 22:23.680
但是我这里面

22:23.680 --> 22:24.680
没有办法输写信息的

22:24.680 --> 22:26.680
我只能把这些信息

22:26.680 --> 22:27.680
骑到别的地方去

22:27.680 --> 22:29.680
而且到这儿来

22:29.680 --> 22:30.680
因此呢

22:30.680 --> 22:31.680
这就造成了

22:31.680 --> 22:33.680
这样的第一个问题

22:33.680 --> 22:35.680
关注点的问题

22:35.680 --> 22:37.680
就是信息输写的位置的问题

22:37.680 --> 22:39.680
应该这样子说

22:39.680 --> 22:43.680
信息输写位置的问题

22:43.680 --> 22:45.680
如果你看这两个

22:45.680 --> 22:47.680
你都不知道我来说什么

22:47.680 --> 22:48.680
所以我这里通过这个例子

22:48.680 --> 22:50.680
详细的解释一下

22:50.680 --> 22:52.680
本来信息应该出写在这儿

22:52.680 --> 22:53.680
但是这里没法写

22:53.680 --> 22:54.680
我只能放到这儿

22:54.680 --> 22:56.680
把这些信息量

22:56.680 --> 22:58.680
好

22:58.680 --> 22:59.680
第二个问题

22:59.680 --> 23:01.680
还是由于缺少这里的

23:01.680 --> 23:03.680
缺少信息量

23:03.680 --> 23:04.680
因此呢

23:04.680 --> 23:05.680
我没有办法

23:05.680 --> 23:07.680
做一个通用的验证

23:07.680 --> 23:08.680
通用的验证

23:08.680 --> 23:09.680
我做不出来

23:09.680 --> 23:11.680
比方说

23:11.680 --> 23:12.680
如果我江南

23:12.680 --> 23:14.680
希望输写这么一个东西

23:15.680 --> 23:17.680
一个统一的验证函数

23:17.680 --> 23:18.680
叫白的点子

23:18.680 --> 23:20.680
你给我传一个啥呢

23:20.680 --> 23:22.680
你给我传一个对象进来

23:22.680 --> 23:24.680
管你这个对象是什么对象

23:24.680 --> 23:25.680
它只要是个对象

23:25.680 --> 23:27.680
只要你是一个对象

23:27.680 --> 23:28.680
我就能对你进行验证

23:28.680 --> 23:29.680
哇

23:29.680 --> 23:31.680
这个方法怎么这么神奇啊

23:31.680 --> 23:32.680
这个方法为什么这么神奇

23:32.680 --> 23:34.680
它可以这样做呗

23:34.680 --> 23:35.680
这是个对象吧

23:35.680 --> 23:36.680
对吧

23:36.680 --> 23:37.680
它是不是可以

23:37.680 --> 23:39.680
循环这个对象的所有属性

23:39.680 --> 23:41.680
可以把所有的属性

23:41.680 --> 23:43.680
是不是一个人拿出来

23:43.680 --> 23:44.680
好

23:44.680 --> 23:45.680
问题是

23:45.680 --> 23:47.680
我这里去循环

23:47.680 --> 23:49.680
属性的每一个属性的

23:49.680 --> 23:51.680
所有的属性值啊

23:51.680 --> 23:53.680
循环它所有的属性值

23:53.680 --> 23:55.680
那么属性的名字得到了

23:55.680 --> 23:57.680
然后属性的值

23:57.680 --> 23:59.680
也得到了

24:01.680 --> 24:02.680
这里爆错了

24:02.680 --> 24:04.680
这里爆错是因为

24:04.680 --> 24:06.680
这个元素具有隐释的

24:06.680 --> 24:07.680
N类型

24:07.680 --> 24:08.680
它说

24:08.680 --> 24:09.680
因为这个是个

24:09.680 --> 24:11.680
最前普通的一个对象

24:11.680 --> 24:13.680
它没有锁印签名

24:13.680 --> 24:14.680
就是没有锁印器

24:14.680 --> 24:16.680
因此它没有任何属性

24:16.680 --> 24:17.680
这个对象里面

24:17.680 --> 24:18.680
它没有任何属性

24:18.680 --> 24:19.680
你要去通过这样

24:19.680 --> 24:20.680
属性去取的话

24:20.680 --> 24:21.680
它要爆错的

24:21.680 --> 24:22.680
它要爆错的

24:22.680 --> 24:25.680
那么其实这里很简单

24:25.680 --> 24:26.680
很简单

24:26.680 --> 24:27.680
我们这里

24:27.680 --> 24:29.680
不是这样的

24:29.680 --> 24:31.680
我们把这个配置改一下

24:31.680 --> 24:34.680
关于隐释的N类

24:34.680 --> 24:35.680
隐释的N类

24:35.680 --> 24:37.680
把它去掉

24:37.680 --> 24:38.680
把这个地方去掉

24:38.680 --> 24:39.680
OK

24:39.680 --> 24:40.680
当然也可以在这里

24:40.680 --> 24:42.680
可以手动的把这个Object

24:42.680 --> 24:43.680
先转换成N类

24:43.680 --> 24:44.680
然后再去取锁印器

24:44.680 --> 24:45.680
也行

24:45.680 --> 24:46.680
然后这样子

24:46.680 --> 24:47.680
因为我们知道

24:47.680 --> 24:49.680
在循环它的每一个属性名

24:49.680 --> 24:50.680
对吧

24:50.680 --> 24:51.680
循环每一个属性名

24:51.680 --> 24:53.680
那肯定属性名是存在的

24:53.680 --> 24:54.680
所以说我们可以这样子

24:54.680 --> 24:55.680
N类

24:55.680 --> 24:59.440
跟它手动转换一下

24:59.440 --> 25:00.440
转换成N类

25:00.440 --> 25:01.440
N类型了

25:01.440 --> 25:02.440
那就无所谓了

25:02.440 --> 25:04.440
它不经过类型检查了

25:04.440 --> 25:06.440
那么这个是值

25:06.440 --> 25:07.440
好

25:07.440 --> 25:08.440
现在我们可以通过这样的代码

25:08.440 --> 25:13.330
写一个统一的验证函数

25:13.330 --> 25:15.330
写了这么一个函数之后

25:15.330 --> 25:18.330
我就可以验证任何对象

25:18.330 --> 25:19.330
假设这个世界上

25:19.330 --> 25:21.330
真的有这么一个函数

25:21.330 --> 25:22.330
哇

25:22.330 --> 25:23.330
这个世界真的是的

25:23.330 --> 25:24.330
太美好了

25:24.330 --> 25:25.330
真的是太美好了

25:25.330 --> 25:26.330
我们以后

25:26.330 --> 25:27.330
就不用去手动

25:27.330 --> 25:29.330
去写一些乱七八糟的验证了

25:29.330 --> 25:30.330
我们都可以通过

25:30.330 --> 25:32.330
这个函数来验证对象

25:32.330 --> 25:33.330
那么验证对象的时候

25:33.330 --> 25:34.330
那么我们就想

25:34.330 --> 25:35.330
如果假设

25:35.330 --> 25:37.330
我们要写这么一个函数

25:37.330 --> 25:39.330
我们可以写一个函数

25:39.330 --> 25:41.330
我们可以写一个函数

25:41.330 --> 25:43.330
我们要写这么一个函数

25:43.330 --> 25:45.330
它会遇到哪些困难

25:45.330 --> 25:47.330
我不知道你是什么样的对象

25:47.330 --> 25:48.330
你可能是个用户对象

25:48.330 --> 25:50.330
可能是一个文章对象

25:50.330 --> 25:52.330
可能是任何一个字面量对象

25:52.330 --> 25:53.330
都有可能

25:53.330 --> 25:55.330
我在循环你的时候

25:55.330 --> 25:57.330
在循环你每一个属性的时候

25:57.330 --> 25:59.330
我可以把你的属性名

25:59.330 --> 26:01.330
和属性值拿到

26:01.330 --> 26:03.330
但是我

26:03.330 --> 26:04.330
插了一个东西

26:04.330 --> 26:06.330
插了一个信息

26:06.330 --> 26:09.330
缺少该属性的

26:10.330 --> 26:12.330
验证规则

26:12.330 --> 26:13.330
我不知道这些属性

26:13.330 --> 26:15.330
有什么样的验证规则

26:15.330 --> 26:16.330
不同的验证规则

26:16.330 --> 26:18.330
我要做不同的处理

26:18.330 --> 26:20.330
我缺少了这么一些东西

26:20.330 --> 26:22.330
而这些信息

26:22.330 --> 26:24.330
是不是应该在定义属性的时候

26:24.330 --> 26:26.330
就把规则告诉他

26:26.330 --> 26:28.330
我们之前反复分析了

26:28.330 --> 26:30.330
我在定义这个属性的时候

26:30.330 --> 26:32.330
我就非常清楚

26:32.330 --> 26:34.330
它的验证规则

26:34.330 --> 26:36.330
那么我只需要

26:36.330 --> 26:37.330
在这个位置

26:37.330 --> 26:38.330
我把这些信息

26:38.330 --> 26:41.330
额外的信息

26:41.330 --> 26:43.330
把这些附加的信息

26:43.330 --> 26:46.330
给它加到这个属性上

26:46.330 --> 26:48.330
那么有了这个信息量的时候

26:48.330 --> 26:49.330
那么这里就可以把信息

26:49.330 --> 26:50.330
读出来

26:50.330 --> 26:52.330
你用了什么样的规则

26:52.330 --> 26:54.330
你是不是非空

26:54.330 --> 26:57.330
你是不是必须是

26:57.330 --> 26:58.330
多少个制服

26:58.330 --> 26:59.330
等等规则

26:59.330 --> 27:01.330
我就可以附加到这

27:01.330 --> 27:02.330
那么到时候

27:02.330 --> 27:03.330
用这个对象的时候

27:03.330 --> 27:05.330
我就可以把这些规则

27:05.330 --> 27:07.330
读出来

27:07.330 --> 27:08.330
所以说

27:08.330 --> 27:09.330
按照以前的做法

27:09.330 --> 27:11.330
困难点在哪呢

27:11.330 --> 27:13.330
以前的困难点在于

27:13.330 --> 27:14.330
这个位置

27:14.330 --> 27:16.330
它缺少了信息量

27:16.330 --> 27:17.330
我们没有办法

27:17.330 --> 27:19.330
增加额外的信息量

27:19.330 --> 27:22.330
而装饰器

27:22.330 --> 27:24.330
就是来解决问题的

27:24.330 --> 27:25.330
装饰器

27:25.330 --> 27:26.330
为什么说

27:26.330 --> 27:28.330
它能够分离关注点呢

27:28.330 --> 27:30.330
为什么能分离关注点呢

27:30.330 --> 27:31.330
我这里只需要

27:31.330 --> 27:33.330
附加上验证规则

27:33.330 --> 27:34.330
具体的验证

27:34.330 --> 27:36.330
我不在这里做了

27:36.330 --> 27:37.330
我不在这里做了

27:37.330 --> 27:39.330
而放一个统一的函数

27:39.330 --> 27:40.330
来进行处理

27:40.330 --> 27:41.330
你看

27:41.330 --> 27:42.330
这样子的话

27:42.330 --> 27:43.330
就没有打破这个优热

27:43.330 --> 27:44.330
这个内的简洁

27:44.330 --> 27:46.330
它会一直保持非常简洁

27:46.330 --> 27:48.330
那么增加的验证规则

27:48.330 --> 27:50.330
靠其他内来处理

27:50.330 --> 27:52.330
其他内来帮我处理

27:52.330 --> 27:54.330
明白这个意思吗

27:54.330 --> 27:55.330
那么本来

27:55.330 --> 27:56.330
就这个内里面

27:56.330 --> 27:57.330
有很多很多的事情

27:57.330 --> 27:58.330
它自己需要处理的

27:58.330 --> 28:00.330
你再去把验证的

28:00.330 --> 28:01.330
再把它加上

28:01.330 --> 28:03.330
那就变得非常复杂了

28:03.330 --> 28:04.330
我只需要去描述

28:04.330 --> 28:06.330
我的验证规则就行了

28:06.330 --> 28:08.330
具体的验证行为

28:08.330 --> 28:09.330
让其他内

28:09.330 --> 28:10.330
或者是其他函数

28:10.330 --> 28:12.330
来帮我进行处理

28:12.330 --> 28:14.330
就是分离关注点

28:14.330 --> 28:15.330
那么换句话说

28:15.330 --> 28:16.330
它为什么能够分离关注点

28:16.330 --> 28:17.330
就是因为

28:17.330 --> 28:18.330
它能够带来

28:18.330 --> 28:19.330
额外的信息量

28:19.330 --> 28:21.330
装饰器

28:21.330 --> 28:23.330
能够带来

28:23.330 --> 28:26.330
额外的信息量

28:26.330 --> 28:27.330
可以达到

28:27.330 --> 28:31.860
分离关注点的目的

28:31.860 --> 28:32.860
好

28:32.860 --> 28:33.860
然后这边呢

28:33.860 --> 28:35.860
如果用装饰器

28:35.860 --> 28:37.860
我们应该怎么来输写呢

28:37.860 --> 28:39.860
现在我们还没有具体的讲

28:39.860 --> 28:40.860
装饰器的代码

28:40.860 --> 28:42.860
我们可以给大家看一下

28:42.860 --> 28:43.860
装饰器的代码

28:43.860 --> 28:45.860
大概就这样输写的

28:45.860 --> 28:46.860
A塔开头

28:46.860 --> 28:48.860
比方说Require

28:48.860 --> 28:52.230
它肯定爆错

28:52.230 --> 28:53.230
现在还不能这样做

28:53.230 --> 28:54.230
肯定爆错

28:54.230 --> 28:55.230
那么表示

28:55.230 --> 28:56.230
我就干描述了

28:56.230 --> 28:57.230
你这个属性

28:57.230 --> 28:59.230
敏扬是一个置物串

28:59.230 --> 29:00.230
并且呢

29:00.230 --> 29:01.230
它是避田的

29:01.230 --> 29:02.230
它不能围空

29:02.230 --> 29:03.230
如果围空的话

29:03.230 --> 29:05.230
到时候验证通不过

29:05.230 --> 29:06.230
再比方说

29:06.230 --> 29:07.230
我还可以

29:07.230 --> 29:08.230
描述

29:08.230 --> 29:09.230
用装饰器

29:09.230 --> 29:11.230
给它进行额外的描述

29:11.230 --> 29:13.230
Range

29:13.230 --> 29:15.230
范围

29:15.230 --> 29:17.230
范围比方说

29:17.230 --> 29:20.230
范围是3-5个制服

29:20.230 --> 29:21.230
你看

29:21.230 --> 29:22.230
这是不是把

29:22.230 --> 29:23.230
额外的信息量

29:23.230 --> 29:24.230
就描述出来了

29:24.230 --> 29:25.230
你想一想

29:25.230 --> 29:26.230
这种边层

29:26.230 --> 29:27.230
是不是很舒服

29:27.230 --> 29:28.230
非常非常舒服

29:28.230 --> 29:29.230
一个账号

29:29.230 --> 29:30.230
制服串

29:30.230 --> 29:31.230
它有一些额外的信息

29:31.230 --> 29:32.230
再来

29:32.230 --> 29:35.230
它的描述制服串

29:35.230 --> 29:36.230
是账号

29:36.230 --> 29:38.230
是账号

29:38.230 --> 29:39.230
这就是装饰器

29:39.230 --> 29:40.230
看没

29:40.230 --> 29:41.230
这就是装饰器

29:41.230 --> 29:42.230
一个A卡开头

29:42.230 --> 29:44.230
后面是个名字

29:44.230 --> 29:46.230
那么同样的

29:46.230 --> 29:47.230
张立马

29:47.230 --> 29:48.230
也可以做同样的处理

29:48.230 --> 29:49.230
你看

29:49.230 --> 29:50.230
现在我们

29:50.230 --> 29:51.230
就可以在这个属性上

29:51.230 --> 29:53.230
附加了一些信息

29:53.230 --> 29:54.230
附加了这么一些信息

29:54.230 --> 29:56.230
那么从理论上来说

29:56.230 --> 29:58.230
你给它附加了信息过后

29:58.230 --> 29:59.230
将来要验证

29:59.230 --> 30:00.230
这个属性的时候

30:00.230 --> 30:01.230
是不是可以把这个信息

30:01.230 --> 30:02.230
读出来

30:02.230 --> 30:03.230
对不对

30:03.230 --> 30:04.230
我就可以把这些信息

30:04.230 --> 30:05.230
读出来

30:05.230 --> 30:06.230
读出来之后

30:06.230 --> 30:08.230
我就可以对它进行验证了

30:08.230 --> 30:09.230
因为之前缺少

30:09.230 --> 30:10.230
这样的验证信息

30:10.230 --> 30:11.230
但是现在有了

30:11.230 --> 30:12.230
我们就可以进行处理了

30:12.230 --> 30:13.230
这就是装饰器

30:13.230 --> 30:15.230
所以说说了半天

30:15.230 --> 30:17.230
一看其实就能体会到

30:17.230 --> 30:18.230
这种验证

30:18.230 --> 30:20.230
是比之前的方式

30:20.230 --> 30:22.230
要舒服很多很多

30:22.230 --> 30:24.230
因为我这里只是配置规则

30:24.230 --> 30:25.230
相当于是

30:25.230 --> 30:26.230
我在这里配置规则

30:26.230 --> 30:28.230
你看我书写账号的时候

30:28.230 --> 30:29.230
我非常清楚

30:29.230 --> 30:30.230
就是账号啊

30:30.230 --> 30:31.230
书写上

30:31.230 --> 30:32.230
配置上

30:32.230 --> 30:33.230
它有验证规则

30:33.230 --> 30:34.230
它必填啊

30:34.230 --> 30:35.230
书写上

30:35.230 --> 30:37.230
它有必须是3到5个字符

30:37.230 --> 30:38.230
书写上

30:38.230 --> 30:40.230
你把这些配置好了之后

30:40.230 --> 30:42.230
剩下的要验证用户

30:42.230 --> 30:44.230
调用一个统一的函数

30:44.230 --> 30:46.230
验证就完成了

30:46.230 --> 30:47.230
我不在这里面

30:47.230 --> 30:49.230
做任何的其他的处理

30:49.230 --> 30:50.230
明白这意思吗

30:50.230 --> 30:51.230
OK

30:51.230 --> 30:54.230
这就是装饰器它的好处

30:54.230 --> 30:55.230
所以说

30:55.230 --> 31:00.590
装饰器的作用

31:01.590 --> 31:02.590
很多时候

31:02.590 --> 31:04.590
我们使用装饰器

31:04.590 --> 31:05.590
都是为

31:05.590 --> 31:07.590
为某些

31:07.590 --> 31:11.590
某些数据

31:11.590 --> 31:13.590
提供

31:13.590 --> 31:15.590
原数据信息

31:15.590 --> 31:16.590
或者说

31:16.590 --> 31:18.590
为某些

31:18.590 --> 31:19.590
属相

31:19.590 --> 31:20.590
其实它不仅是属相

31:20.590 --> 31:21.590
还有什么

31:21.590 --> 31:22.590
还有内

31:22.590 --> 31:24.590
还有参数

31:24.590 --> 31:26.590
还有内参数

31:26.590 --> 31:30.100
当然还有方法

31:30.100 --> 31:32.100
这些东西都是

31:32.100 --> 31:34.100
面向对象里面的一些概念

31:34.100 --> 31:35.100
那么

31:35.100 --> 31:37.100
它是能够为这些东西

31:37.100 --> 31:39.100
提供原数据信息

31:39.100 --> 31:41.100
什么叫原数据信息呢

31:41.100 --> 31:43.100
这些就是原数据信息

31:43.100 --> 31:45.100
这些就是原数据

31:45.100 --> 31:47.100
原数据叫做

31:47.100 --> 31:49.100
metadata

31:49.100 --> 31:50.100
叫这个东西

31:50.100 --> 31:51.100
那么它是什么东西

31:51.100 --> 31:53.100
原数据

31:53.100 --> 31:55.100
其实它非常简单

31:55.100 --> 31:57.100
就一句话来描述

31:57.100 --> 31:58.100
它叫

31:58.100 --> 32:00.100
原数据就是

32:00.100 --> 32:03.100
描述数据的数据

32:03.100 --> 32:05.100
有点绕着

32:05.100 --> 32:07.100
就是还好

32:07.100 --> 32:09.100
你看这些是原数据

32:09.100 --> 32:10.100
它描述的是啥

32:10.100 --> 32:12.100
描述的是账号

32:12.100 --> 32:14.100
那账号是不是数据

32:14.100 --> 32:15.100
账号它也是数据对吧

32:15.100 --> 32:18.100
它是用来描述数据的数据

32:18.100 --> 32:19.100
就这些原数据

32:19.100 --> 32:20.100
它本身是数据

32:20.100 --> 32:22.100
它用来描述数据的数据

32:22.100 --> 32:24.100
就好比说我们写的

32:24.100 --> 32:25.100
atman里面

32:25.100 --> 32:26.100
我们不是写

32:26.100 --> 32:28.100
我们不是写页面吧对吧

32:28.100 --> 32:29.100
页面里边

32:29.100 --> 32:31.100
它不是有那个metadata

32:31.100 --> 32:34.100
这个原数吗对不对

32:34.100 --> 32:36.100
你可以把整个这个代码

32:36.100 --> 32:38.100
看成一个文档

32:38.100 --> 32:40.100
atman文档

32:40.100 --> 32:41.100
atman文档是不是数据

32:41.100 --> 32:43.100
它是数据嘛对不对

32:43.100 --> 32:45.100
atman文档是数据

32:45.100 --> 32:47.100
那么在描述这个文档的时候

32:47.100 --> 32:49.100
这个文档的编码

32:49.100 --> 32:50.100
UTF-8

32:50.100 --> 32:52.100
你看是不是描述数据的数据

32:52.100 --> 32:53.100
对不对

32:53.100 --> 32:57.100
这个四口尺寸是啥啥啥啥啥

32:57.100 --> 32:59.100
然后使用Ie内核

32:59.100 --> 33:01.100
把Ie内核使用A级内核

33:01.100 --> 33:03.100
Ie内核我该怎么来处理

33:03.100 --> 33:07.100
你看这些都是来描述文档的数据

33:07.100 --> 33:09.100
描述数据的数据

33:09.100 --> 33:10.100
就是原数据

33:10.100 --> 33:11.100
metadata

33:11.100 --> 33:13.100
原数据的意思

33:13.100 --> 33:14.100
能力的意思

33:14.100 --> 33:17.100
就是给一些数据

33:17.100 --> 33:18.100
一些额外信息

33:18.100 --> 33:20.100
就是原数据

33:20.100 --> 33:22.100
好这是

33:22.100 --> 33:24.100
装饰器它的主要作用

33:24.100 --> 33:26.100
就是为了给它增加一些原数据

33:26.100 --> 33:28.100
当然装饰器还不只可以做这些事

33:28.100 --> 33:31.100
但是在传统的面向对象语言里面

33:31.100 --> 33:33.100
它能够做的事情

33:33.100 --> 33:36.100
主要都是为了处理原数据

33:36.100 --> 33:38.100
好这是关于

33:38.100 --> 33:41.100
装饰器的就是一个解释

33:41.100 --> 33:43.100
然后下面我们再看一下

33:43.100 --> 33:46.100
就是装饰器的本质

33:46.100 --> 33:47.100
这个先认识一下

33:47.100 --> 33:49.100
我们后边在写代码的时候

33:49.100 --> 33:51.100
再详细的说

33:52.100 --> 33:54.100
装饰器

33:55.100 --> 33:57.100
好装饰器的本质

33:57.100 --> 34:00.100
装饰器在TS中

34:00.100 --> 34:02.100
或者在GS中

34:02.100 --> 34:04.100
也包括TS

34:04.100 --> 34:06.100
因为TS跟GS的标准史

34:06.100 --> 34:07.100
要保持一致的

34:07.100 --> 34:09.100
在GS中本身

34:09.100 --> 34:12.100
在本身它就有装饰器

34:12.100 --> 34:17.100
在GS中装饰器是一个函数

34:17.100 --> 34:19.100
它本质上就是一个函数

34:19.100 --> 34:20.100
在GS代码里面

34:20.100 --> 34:21.100
你只要书写一个函数

34:21.100 --> 34:23.100
你就可以把它当成一个装饰器来使用

34:23.100 --> 34:25.100
装饰器的本质就是一个函数

34:25.100 --> 34:27.100
你看这个require

34:27.100 --> 34:28.100
require是一个函数

34:28.100 --> 34:29.100
range也是个函数

34:29.100 --> 34:32.100
description也是个函数

34:32.100 --> 34:33.100
只不过这里好像在调用函数

34:33.100 --> 34:34.100
这里没调用是吧

34:34.100 --> 34:35.100
应该这样看

34:35.100 --> 34:37.100
require表示一个函数

34:37.100 --> 34:39.100
这个range的调用结果

34:39.100 --> 34:41.100
就这个函数的调用结果

34:41.100 --> 34:43.100
它得到了还是一个函数

34:43.100 --> 34:44.100
总之要得到一个函数

34:44.100 --> 34:46.100
这里还是一个函数

34:46.100 --> 34:48.100
总之要得到一个函数

34:48.100 --> 34:49.100
必须要得到一个函数

34:49.100 --> 34:51.100
就是装饰器的本质

34:51.100 --> 34:52.100
其实就是一个函数

34:52.100 --> 34:53.100
在GS里面

34:53.100 --> 34:54.100
再说一次

34:54.100 --> 34:57.100
它目前处于建议征集的第二阶段

34:57.100 --> 34:59.100
还没有完全成为标准

34:59.100 --> 35:00.100
但是有些框架

35:00.100 --> 35:02.100
有些裤已经在大量使用了

35:02.100 --> 35:04.100
可以保证的是

35:04.100 --> 35:06.100
未来它一定会出这个装饰器的

35:06.100 --> 35:08.100
那未来出的装饰器

35:08.100 --> 35:10.100
它到底是不是现在这个样子

35:10.100 --> 35:13.100
谁也说不清楚

35:13.100 --> 35:15.100
这个和只能拭目以待了

35:15.100 --> 35:16.100
但是我们首先把这个概念

35:16.100 --> 35:17.100
要学习出来

35:17.100 --> 35:18.100
装饰器是一个函数

35:18.100 --> 35:21.100
并且它在GS中就存在的

35:21.100 --> 35:24.100
因此装饰器

35:24.100 --> 35:25.100
换句话说

35:25.100 --> 35:26.100
这里说了一个什么问题呢

35:26.100 --> 35:31.100
装饰器是要参与运行的

35:31.100 --> 35:33.100
它不是TS里面的东西

35:33.100 --> 35:36.100
TS只是给它加了一些类型检查

35:36.100 --> 35:40.100
它实际上是GS里面的东西

35:40.100 --> 35:43.100
因此装饰器它是要参与运行的

35:43.100 --> 35:45.100
在运行过程中是有效的

35:45.100 --> 35:46.100
你想啊

35:46.100 --> 35:48.100
如果运行过程中无效了

35:48.100 --> 35:49.100
刚才说还有意义吗

35:49.100 --> 35:50.100
就没意义了

35:50.100 --> 35:51.100
如果这些变异结果里面

35:51.100 --> 35:52.100
这些数据

35:52.100 --> 35:54.100
这些信息全部丢失掉了

35:54.100 --> 35:55.100
那还有意义吗

35:55.100 --> 35:56.100
就没有意义了

35:56.100 --> 35:58.100
所以它会参与运行的

35:58.100 --> 36:00.100
这是装饰器的本质

36:00.100 --> 36:01.100
好了

36:01.100 --> 36:03.100
那么其实我们这里可能

36:03.100 --> 36:04.100
就大概的讲一下

36:04.100 --> 36:06.100
这个装饰器的这些概念

36:06.100 --> 36:08.100
首先大家从感性上

36:08.100 --> 36:10.100
能够认识到装饰器

36:10.100 --> 36:11.100
它是一个什么东西

36:11.100 --> 36:13.100
它能解决什么样的问题

36:13.100 --> 36:15.100
就是给它加一些额外的信息

36:15.100 --> 36:17.100
通常都是这样做的

36:17.100 --> 36:19.100
然后再来认识到装饰器的本质

36:19.100 --> 36:20.100
是一个函数

36:20.100 --> 36:21.100
然后装饰器

36:21.100 --> 36:22.100
这还有一个点就是

36:22.100 --> 36:25.100
装饰器可以修饰什么

36:25.100 --> 36:26.100
可以修饰啥呢

36:26.100 --> 36:28.100
可以修饰内

36:28.100 --> 36:31.100
还要可以修饰属性

36:31.100 --> 36:32.100
我叫内成员

36:32.100 --> 36:34.100
成员里面包含了属性和方法

36:34.100 --> 36:35.100
是吧

36:35.100 --> 36:37.100
属性和方法

36:37.100 --> 36:38.100
还可以修饰啥呢

36:38.100 --> 36:39.100
修饰参数

36:39.100 --> 36:41.100
我们会意思来讲

36:41.100 --> 36:43.100
它可以修饰这么一些东西

36:43.100 --> 36:45.100
装饰器都可以修饰的

36:45.100 --> 36:46.100
修饰这么一些东西

36:46.100 --> 36:47.100
好

36:47.100 --> 36:48.100
我们刚才修饰的是属性

36:48.100 --> 36:49.100
对吧

36:49.100 --> 36:51.100
其实还可以在上面修饰内

36:51.100 --> 36:53.100
修饰内也是一样的

36:53.100 --> 36:55.100
也是一样的

36:55.100 --> 36:56.100
好了

36:56.100 --> 36:58.100
那么我们这里

36:58.100 --> 36:59.100
就到这了

36:59.100 --> 37:01.100
我们大概了解一下装饰器

37:01.100 --> 37:02.100
了解之后

37:02.100 --> 37:04.100
我们再意思来学习

37:04.100 --> 37:05.100
它如何去修饰内

37:05.100 --> 37:06.100
如何修饰成员

37:06.100 --> 37:07.100
如何修饰成熟

37:07.100 --> 37:08.100
OK

37:08.100 --> 37:09.100
那咱们这里

37:09.100 --> 37:10.100
拜拜

