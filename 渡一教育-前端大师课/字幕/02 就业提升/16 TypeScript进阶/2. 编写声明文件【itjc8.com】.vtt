WEBVTT

00:00.690 --> 00:09.890
好 我们了解了声明文件的概念之后呢 我们这节课来学习如何来编写声明文件

00:09.890 --> 00:16.090
这一课呢 是我们这个章节的核心知识 然后呢那种也比较多啊

00:16.090 --> 00:23.090
这里呢 我不会把它讲得很复杂 因为声明文件这个东西呢 我们平时很少很少写

00:23.090 --> 00:28.690
就算打包生存的话 也是让他自动生存的 我们自己手动写的话很少写啊

00:28.690 --> 00:33.690
所以说 我们不会把它讲得太复杂啊 编写声明文件这一块啊

00:33.690 --> 00:39.690
我们分为两种情况 一种是手动编写 一种是手动编写

00:39.690 --> 00:47.690
一种是自动生存 自动生存 自动生存是什么情况呢 我们这里先解释一下啊

00:47.690 --> 00:55.690
自动生存 就是如果我们写的代码本身就是用ts写的 那还需要你去写声明文件吗

00:56.690 --> 01:01.690
这不需要的啊 我们先解释一下 自动生存是什么样的场景

01:01.690 --> 01:11.690
就是说工程是使用ts开发的 我们的工程比方说 我们这个代码是使用ts来开发的

01:14.690 --> 01:17.690
我们比方说写个函数吧 写个函数

01:17.690 --> 01:23.690
A number你看这是ts代码对吧 我们本身就是用ts代码书写而成的

01:23.690 --> 01:28.260
这个工程我们把其他删掉了

01:28.260 --> 01:35.260
然后呢发布时发布之后 就是编译之后

01:35.260 --> 01:44.260
也就是编译之后 编译之后 那么是解释文件

01:44.260 --> 01:50.260
你看ts代码开发的它有编译 编译完成过后是不是解释文件

01:50.260 --> 01:55.260
那么发布的时候呢 是发布ts还是发布ts

01:55.260 --> 01:59.260
肯定是发布ts 对吧 肯定是发布ts 这个毫无疑问的

01:59.260 --> 02:06.260
比方说我们现在编译 比方说npmrambild来进行编译

02:06.260 --> 02:11.260
那它编译完成 编译完成之后

02:11.260 --> 02:14.260
你看编译的结果就是一个普通的解释文件了

02:14.260 --> 02:18.260
那些类型约束啊 那些东西全部没了

02:18.260 --> 02:22.260
好 得到了一个解释文件过后 那么发布的是什么呢

02:22.260 --> 02:26.260
发布的是解释文件 发布的是解释文件

02:26.260 --> 02:28.260
你不要把ts文件发不出去了

02:28.260 --> 02:32.260
因为ts文件你发不出去 别人还不是要重新编译一次

02:32.260 --> 02:35.260
所以说我们发布的是啥呢 发布的是解释文件

02:35.260 --> 02:42.260
那么问题就来了 如果发布的文件需要被别人使用

02:42.260 --> 02:46.260
就是我们自己开发的还不是一个最终的成品

02:46.260 --> 02:51.260
开发的是一个模块 一个包 那么需要让别人来调用

02:51.260 --> 02:58.260
需要其他开发者使用 那么这就遇到问题了

02:58.260 --> 03:02.260
由于我们发布的是解释文件 那么其他的开发者

03:02.260 --> 03:06.260
要使用我们的功能 但是他可能希望的是

03:06.260 --> 03:09.260
获得类型检查 因为他可能使用的是ts开发

03:09.260 --> 03:13.260
我们把这个文件发不出去 别人来使用这个文件

03:13.260 --> 03:16.260
有类型检查吗 你看 有类型检查吗

03:16.260 --> 03:19.260
肯定是没有 对吧 肯定是没有类型检查

03:19.260 --> 03:21.260
那么这个时候怎么办呢

03:21.260 --> 03:25.260
我们如果希望别人来使用我们这个地方的东西的时候

03:25.260 --> 03:28.260
也能获得类型检查 这个时候咋办呢

03:28.260 --> 03:32.260
这个时候呢 我们就可以使用

03:32.260 --> 03:40.260
可以使用声明文件

03:40.260 --> 03:48.260
来描述发布结果中的类型

03:48.260 --> 03:51.260
就是我们的发布的结果是一个解释文件

03:51.260 --> 03:53.260
这里边是没有类型的 那么我们希望的是

03:53.260 --> 03:56.260
在这里边呢 每一个解释文件

03:56.260 --> 03:59.260
生成一个对应的声明文件

03:59.260 --> 04:01.260
来描述这里边的类型

04:01.260 --> 04:04.260
那么这个时候呢 就可以利用自动生成

04:04.260 --> 04:08.260
怎么自动生成呢 非常非常简单

04:08.260 --> 04:16.260
配置 TSConfig.json 当中的什么呢

04:16.260 --> 04:21.340
这个配置 看一下

04:21.340 --> 04:26.340
Decoration

04:26.340 --> 04:30.340
把这个配置设置为处就可以了 就完成了

04:30.340 --> 04:33.340
那么这样子呢 它就会为发布的结果

04:33.340 --> 04:39.340
生成声明文件 配置中的这个东西

04:39.340 --> 04:42.340
把它配置为处即可

04:42.340 --> 04:45.340
好 那么我们配置好 配置好了之后呢

04:45.340 --> 04:48.340
然后这里配置好了啊 配置好了之后呢

04:48.340 --> 04:52.340
我们来试一下啊 试一下它能不能去生成

04:52.340 --> 04:54.340
这个声明文件

04:54.340 --> 05:00.710
NPMDraw6 重新编译

05:00.710 --> 05:03.710
好 编译完成 我们来看一下这个文件

05:03.710 --> 05:05.710
你看一下 你看一下

05:05.710 --> 05:09.710
每一个GS啊 是不是就已经生成了对应的声明文件了

05:09.710 --> 05:12.710
对吧 就已经生成了声明文件了

05:12.710 --> 05:15.710
都是这种情况啊 非常非常简单 不需要你手动一些

05:15.710 --> 05:17.710
它自动给你生成好

05:17.710 --> 05:22.710
其实像有一些用TS写的库呢

05:22.710 --> 05:25.710
它本来打包出来就是这样的结果 你看这个库

05:25.710 --> 05:29.710
这个库 每一个GS对应一个D.TS对吧

05:29.710 --> 05:31.710
每一个GS对应一个D.TS

05:31.710 --> 05:33.710
所以说这个库呢 它就已经给你生成好了

05:33.710 --> 05:36.710
声明文件了 包括这个库

05:36.710 --> 05:39.710
这个库也是你看GS D.TS

05:39.710 --> 05:42.710
GS D.TS

05:42.710 --> 05:44.710
每一个GS文件都给你生成好了

05:44.710 --> 05:46.710
不需要你自己手动去处理

05:46.710 --> 05:50.710
这是关于这种方式啊 关于这种方式

05:50.710 --> 05:54.710
这种方式呢 其实你看刚才看到这些库里边

05:54.710 --> 05:55.710
刚才看到这些库里边

05:55.710 --> 05:57.710
还有一个文件叫做GS.MAP 对吧

05:57.710 --> 06:00.710
GS.MAP 那么这个MAP文件大家都知道

06:00.710 --> 06:05.710
应该是一个什么 就是叫原码地图 对吧

06:05.710 --> 06:07.710
GS.MAP 原码地图

06:07.710 --> 06:10.710
那么这个用于调识的啊 就是包错的时候呢

06:10.710 --> 06:12.710
我可以把对应到TS里边的代码

06:12.710 --> 06:15.710
那么这个时候呢 这个原码地图啊

06:15.710 --> 06:17.710
原码地图你可以把开启

06:17.710 --> 06:21.710
然后这里 我们可以在这里把原码地图开启

06:21.710 --> 06:23.710
这个配置好像是讲过的吧

06:23.710 --> 06:26.710
好像是在俄罗斯方块

06:26.710 --> 06:28.710
好像是在那里啊 有点印象

06:28.710 --> 06:30.710
好像是讲过的 很简单

06:30.710 --> 06:32.710
把这个配置开启就行了

06:32.710 --> 06:34.710
好 现在我们再重新编译

06:34.710 --> 06:39.660
运行啊 重新编译

06:39.660 --> 06:42.660
编译好了过了 你看一下 就有一个原码地图了

06:42.660 --> 06:46.660
这是关于这一块啊 这一块

06:46.660 --> 06:48.660
自动生成声明文件

06:48.660 --> 06:51.660
这个不是我们要讲的 因为这个东西没啥讲的 对吧

06:51.660 --> 06:53.660
如果像我们的工程是用TS写的

06:53.660 --> 06:56.660
它自动就生成了声明文件了

06:56.660 --> 06:58.660
不用我们自己不用处理

06:58.660 --> 07:01.660
我们主要是看一下手动编写

07:01.660 --> 07:06.660
好 手动编写声明文件有哪些场景呢

07:06.660 --> 07:09.660
我们首先说一下啊 第一个场景

07:09.660 --> 07:12.660
什么情况下 我们要手动编写声明文件

07:12.660 --> 07:21.660
就是对已有的库

07:21.660 --> 07:27.660
它是使用借使书写而成的

07:27.660 --> 07:30.660
它一开始根本就没有用TS写

07:30.660 --> 07:33.660
本身就是用借使书写而成的

07:33.660 --> 07:39.660
并且更改该库的代码

07:39.660 --> 07:45.660
为TS成本 成本较高

07:45.660 --> 07:47.660
就是如果我们想把它的借使代码

07:47.660 --> 07:50.660
全部改成用TS代码来做的话

07:50.660 --> 07:52.660
可能改动的比较大

07:52.660 --> 07:55.660
可能会受到大量的改动 成本比较高

07:55.660 --> 07:57.660
这种什么情况呢

07:57.660 --> 07:59.660
就是无忧 无忧

07:59.660 --> 08:02.660
下一个版本就打算把之前的代码

08:02.660 --> 08:04.660
基本上要全部重新写一次

08:04.660 --> 08:06.660
要把它变成TS

08:06.660 --> 08:09.660
也就是说之前的代码变成TS

08:09.660 --> 08:11.660
这个需要耗费大量的精力和时间

08:11.660 --> 08:13.660
成本比较高

08:13.660 --> 08:15.660
那么像这种情况下

08:15.660 --> 08:19.660
我们没有必要先暂时不着急

08:19.660 --> 08:21.660
把这个借使代码改成TS

08:21.660 --> 08:23.660
而直接使用声明文件

08:23.660 --> 08:25.660
来描述以前的借使

08:25.660 --> 08:27.660
可以先暂时这样子用

08:27.660 --> 08:29.660
当然有些地方不是很好描述

08:29.660 --> 08:31.660
因为确实一开始没有考虑到类型检查

08:31.660 --> 08:33.660
有些地方可能不是很好描述

08:33.660 --> 08:34.660
不过没关系

08:34.660 --> 08:36.660
我们把能描述的地方

08:36.660 --> 08:38.660
尽量的把它描述出来

08:38.660 --> 08:40.660
所以说我们说TS

08:40.660 --> 08:42.660
它是个见尽式的

08:42.660 --> 08:44.660
它不是说一定要要求你全盘

08:44.660 --> 08:45.660
使用类型检查

08:45.660 --> 08:46.660
它是可选的

08:46.660 --> 08:48.660
你可以一点一点的做

08:48.660 --> 08:49.660
对已有的库

08:49.660 --> 08:51.660
我们自己之前写的库

08:51.660 --> 08:53.660
是用借使写的

08:53.660 --> 08:55.660
那么不太容易把它变成TS

08:55.660 --> 08:57.660
那么这个时候

08:57.660 --> 09:00.660
可以使用声明文件

09:00.660 --> 09:02.660
可以手动编写

09:02.660 --> 09:04.660
手动编写

09:04.660 --> 09:05.660
声明文件

09:05.660 --> 09:07.660
由于它不是用TS写的

09:07.660 --> 09:09.660
你要让它自动生成声明文件

09:09.660 --> 09:10.660
就不太可能了

09:10.660 --> 09:12.660
需要力手动编写

09:12.660 --> 09:14.660
第二种情况是

09:14.660 --> 09:18.660
对一些第三方的库

09:19.660 --> 09:24.660
它们使用借使写而成

09:24.660 --> 09:29.660
并且这些第三方库

09:29.660 --> 09:32.660
没有提供声明文件

09:32.660 --> 09:34.660
遇到这种情况的时候

09:34.660 --> 09:38.660
可以手动编写声明文件

09:38.660 --> 09:40.660
不过现在第二种情况

09:40.660 --> 09:41.660
比较少了

09:41.660 --> 09:44.660
就是我们这一个章节

09:44.660 --> 09:46.660
学习声明文件的章节

09:46.660 --> 09:49.660
可能以后你不太会用得到

09:49.660 --> 09:50.660
不太会用得到

09:50.660 --> 09:52.660
但是我们多了解一点

09:52.660 --> 09:53.660
没有坏处

09:53.660 --> 09:54.660
第一种情况

09:54.660 --> 09:56.660
对以前自己写的工程

09:56.660 --> 09:58.660
这个有可能会发生

09:58.660 --> 10:00.660
之前我们公司里面

10:00.660 --> 10:01.660
自己写的一些库

10:01.660 --> 10:02.660
是用借使写的

10:02.660 --> 10:03.660
那么现在

10:03.660 --> 10:05.660
我们想做新的项目的时候

10:05.660 --> 10:07.660
想用TS来写

10:07.660 --> 10:08.660
用TS写的时候

10:08.660 --> 10:09.660
就会遇到一个问题

10:09.660 --> 10:11.660
那之前的库我要用咋了

10:11.660 --> 10:12.660
要咋了

10:12.660 --> 10:14.660
我又不想把它

10:14.660 --> 10:15.660
目前暂时还不想

10:15.660 --> 10:17.660
把它更改为TS

10:17.660 --> 10:19.660
因为这样的更改成本较高

10:19.660 --> 10:20.660
这个时候

10:20.660 --> 10:22.660
可以为以前的那些库

10:22.660 --> 10:25.660
手动的去编写声明文件

10:25.660 --> 10:26.660
第二种情况

10:26.660 --> 10:28.660
就是对一些第三方库

10:28.660 --> 10:29.660
就别人写的库

10:29.660 --> 10:31.660
不是我们公司自己的库

10:31.660 --> 10:33.660
他们也是用借使写而成的

10:33.660 --> 10:35.660
那么对于这些第三方库

10:35.660 --> 10:36.660
他们本身

10:36.660 --> 10:38.660
没有提供声明文件

10:38.660 --> 10:39.660
那么这个时候

10:39.660 --> 10:42.660
可以手动的编写声明文件

10:42.660 --> 10:43.660
第二种情况

10:43.660 --> 10:44.660
相对较少

10:44.660 --> 10:45.660
相对较少

10:45.660 --> 10:47.660
因为目前一些

10:47.660 --> 10:49.660
大部分的流行的库

10:49.660 --> 10:52.660
都已经有了声明文件了

10:52.660 --> 10:55.660
都已经给你写好了声明文件了

10:55.660 --> 10:56.660
声明文件在哪呢

10:56.660 --> 10:57.660
我们就在这个

10:57.660 --> 10:58.660
就在这

10:58.660 --> 11:00.660
就安装个Types里边的

11:00.660 --> 11:02.660
相应的库就行了

11:02.660 --> 11:04.660
比方说我们还有一些库

11:04.660 --> 11:05.660
就已经使用了

11:05.660 --> 11:07.660
自己给你写好了声明文件

11:07.660 --> 11:08.660
他自己就给你写了

11:08.660 --> 11:10.660
比方说像X小时

11:10.660 --> 11:12.660
我看这里有没有安装X小时

11:12.660 --> 11:13.660
安装的

11:13.660 --> 11:15.660
X小时里面是不是一个声明文件

11:15.660 --> 11:18.660
index.d.ts

11:18.660 --> 11:20.660
他本身就是给你声明好了的

11:20.660 --> 11:22.660
本身就是给你声明好了的

11:22.660 --> 11:24.660
所以说你连这个Types

11:24.660 --> 11:26.660
都不用安装了

11:26.660 --> 11:28.660
这是这两种情况

11:28.660 --> 11:30.660
第二种情况遇到比较少一点

11:30.660 --> 11:32.660
我们以后有可能

11:32.660 --> 11:34.660
自己手动编写声明文件

11:34.660 --> 11:36.660
绝大部分时候是第1种情况

11:36.660 --> 11:38.660
第二种情况也会遇到

11:38.660 --> 11:39.660
什么时候呢

11:39.660 --> 11:40.660
就是你使用的

11:40.660 --> 11:41.660
这个第三方库

11:41.660 --> 11:42.660
可能比较小重

11:42.660 --> 11:44.660
用的人不多

11:44.660 --> 11:45.660
以前还有也是用

11:45.660 --> 11:46.660
记者写的

11:46.660 --> 11:48.660
没有人给他去提供声明文件

11:48.660 --> 11:50.660
那你可能一定要用

11:50.660 --> 11:52.660
他的话你自己去写

11:52.660 --> 11:53.660
好了

11:53.660 --> 11:55.660
总归我们先了解一下

11:55.660 --> 11:57.660
手动编写和自动生成的

11:57.660 --> 11:59.660
他们各自的场景

11:59.660 --> 12:00.660
我们这一节课

12:00.660 --> 12:01.660
主要是讲

12:01.660 --> 12:02.660
如何来进行

12:02.660 --> 12:04.660
手动编写声明文件

12:04.660 --> 12:06.660
如何来进行手动编写

12:06.660 --> 12:07.660
其实手动编写

12:07.660 --> 12:09.660
非常非常的简单

12:09.660 --> 12:11.660
就是以前你学习了

12:11.660 --> 12:13.660
这么多TS的知识了

12:13.660 --> 12:14.660
你要编写声明文件

12:14.660 --> 12:15.660
就已经非常简单了

12:15.660 --> 12:17.660
我们这来说一下吧

12:17.660 --> 12:19.660
来举例说明

12:19.660 --> 12:20.660
手动编写的话

12:20.660 --> 12:21.660
我们首先要建立

12:21.660 --> 12:22.660
这么一个声明文件

12:22.660 --> 12:23.660
比方说

12:23.660 --> 12:26.660
我们现在做这么一个练习

12:26.660 --> 12:29.660
我把这个漏的声明

12:29.660 --> 12:30.660
漏的这个库

12:30.660 --> 12:31.660
声明文件里面

12:31.660 --> 12:32.660
漏的这个库

12:32.660 --> 12:33.660
给它删除掉

12:33.660 --> 12:34.660
我们之前安装它

12:34.660 --> 12:35.660
主要是为了安装

12:35.660 --> 12:37.660
漏的环境下面的声明文件

12:37.660 --> 12:39.660
有哪些类型

12:39.660 --> 12:41.660
我们把这个库删除掉

12:41.660 --> 12:42.660
删除掉

12:42.660 --> 12:44.660
删除掉之后

12:44.660 --> 12:45.660
我们再来看

12:45.660 --> 12:47.980
再来看

12:47.980 --> 12:48.980
我们来这里

12:48.980 --> 12:50.980
如果要打印出

12:50.980 --> 12:51.980
如果要打印出

12:51.980 --> 12:53.980
用康寿你看还能不能用

12:53.980 --> 12:55.980
还有没有康寿

12:55.980 --> 12:57.980
还有没有康寿

12:57.980 --> 12:58.980
肯定是没有了

12:58.980 --> 12:59.980
因为它现在

12:59.980 --> 13:01.980
找不到这个声明文件了

13:01.980 --> 13:02.980
它不知道这个环境下面

13:02.980 --> 13:03.980
还有这个对象

13:03.980 --> 13:04.980
它并不知道

13:04.980 --> 13:05.980
那么这个时候

13:05.980 --> 13:07.980
我们来手动的去

13:07.980 --> 13:09.980
处理一下这个问题

13:09.980 --> 13:10.980
手动的来处理

13:10.980 --> 13:11.980
怎么处理呢

13:11.980 --> 13:14.980
首先我们建立一个声明文件

13:14.980 --> 13:15.980
给它取个名字吧

13:15.980 --> 13:16.980
比方说

13:16.980 --> 13:18.980
就取一个global

13:18.980 --> 13:19.980
表示全局的

13:19.980 --> 13:20.980
随便什么名字无所谓

13:20.980 --> 13:22.980
只要你的后绝名

13:22.980 --> 13:24.980
为d.ts

13:24.980 --> 13:25.980
就可以了

13:25.980 --> 13:26.980
我们之前讲过

13:26.980 --> 13:28.980
上一节课的时候讲过

13:28.980 --> 13:29.980
声明文件

13:29.980 --> 13:31.980
你只要把位置放正

13:31.980 --> 13:32.980
就ok

13:32.980 --> 13:33.980
你只要把位置放正

13:33.980 --> 13:34.980
就ok

13:34.980 --> 13:36.980
甭管你放在哪都无所谓

13:36.980 --> 13:37.980
名字叫什么无所谓

13:37.980 --> 13:38.980
你只要把

13:38.980 --> 13:39.980
位置

13:39.980 --> 13:40.980
文件的位置放正确

13:40.980 --> 13:41.980
我们现在文件位置

13:41.980 --> 13:43.980
是在这个下面

13:43.980 --> 13:45.980
include在src下面

13:45.980 --> 13:47.980
因此放在这

13:47.980 --> 13:48.980
是没问题的

13:48.980 --> 13:50.980
好像刚才这个代码

13:50.980 --> 13:51.980
其实这个代码

13:51.980 --> 13:52.980
这么正确

13:52.980 --> 13:54.980
这个代码这么正确

13:54.980 --> 13:56.980
能不能运行

13:56.980 --> 13:58.980
肯定是可以运行的

13:58.980 --> 13:59.980
这是一个正确的介绍代码

13:59.980 --> 14:01.980
肯定是可以运行的

14:01.980 --> 14:02.980
它现在爆错

14:02.980 --> 14:03.980
并不是说

14:03.980 --> 14:05.980
它运行的时候要爆错

14:05.980 --> 14:06.980
它运行的时候

14:06.980 --> 14:07.980
反而不会爆错

14:08.980 --> 14:10.980
而是它编译通不过

14:10.980 --> 14:12.980
就是ts的编译通不过

14:12.980 --> 14:14.980
因为ts不知道

14:14.980 --> 14:15.980
我们的环境下边

14:15.980 --> 14:17.980
有这么一个全局对象

14:17.980 --> 14:18.980
扛兽

14:18.980 --> 14:20.980
还并不知道这一点

14:20.980 --> 14:21.980
那么这个时候

14:21.980 --> 14:23.980
我们只需要高速ts

14:23.980 --> 14:24.980
我们想解决的

14:24.980 --> 14:25.980
不是说运行时候的问题

14:25.980 --> 14:27.980
运行的时候没啥问题

14:27.980 --> 14:28.980
我们要解决的问题是

14:28.980 --> 14:30.980
要高速ts

14:30.980 --> 14:32.980
我们有这么一个全局对象

14:32.980 --> 14:34.980
就这么简单

14:34.980 --> 14:35.980
也就是说

14:35.980 --> 14:36.980
我们这里

14:36.980 --> 14:38.980
设计到一个问题

14:38.980 --> 14:41.980
叫做全局声明

14:41.980 --> 14:43.980
全局声明

14:43.980 --> 14:44.980
全局声明啥意思呢

14:44.980 --> 14:46.980
就是声明一些

14:46.980 --> 14:49.980
全局的对象

14:49.980 --> 14:52.980
属性 变量等等

14:52.980 --> 14:54.980
声明一些这么一些东西

14:54.980 --> 14:56.980
怎么声明呢

14:56.980 --> 14:57.980
很简单

14:57.980 --> 14:58.980
到这边来

14:58.980 --> 15:01.980
凡是你要声明一个东西

15:01.980 --> 15:02.980
你要把它暴露出来

15:02.980 --> 15:04.980
声明出来

15:04.980 --> 15:05.980
先写上这么一个关键字

15:05.980 --> 15:07.980
叫declare

15:07.980 --> 15:09.980
这表示声明

15:09.980 --> 15:10.980
我要声明

15:10.980 --> 15:12.980
我有这么一些东西

15:12.980 --> 15:14.980
好

15:14.980 --> 15:16.980
写好的关键字过后呢

15:16.980 --> 15:18.980
我们要声明一个啥

15:18.980 --> 15:19.980
我们要声明一个啥

15:19.980 --> 15:20.980
我们首先来想一想

15:20.980 --> 15:22.980
这个东西是啥

15:22.980 --> 15:24.980
这个东西是不是个对象

15:24.980 --> 15:25.980
对不对

15:25.980 --> 15:26.980
应该是个对象吧

15:26.980 --> 15:27.980
这个玩意儿

15:27.980 --> 15:28.980
是不是个对象

15:28.980 --> 15:29.980
肯定是一个对象

15:29.980 --> 15:30.980
对吧

15:30.980 --> 15:31.980
好

15:31.980 --> 15:32.980
那么我们这里

15:32.980 --> 15:35.980
就写这么一个console

15:35.980 --> 15:38.980
声明一个varm

15:38.980 --> 15:39.980
console

15:39.980 --> 15:40.980
有一个对象

15:40.980 --> 15:42.980
有这么一个对象

15:42.980 --> 15:43.980
好

15:43.980 --> 15:44.980
它的内形是啥呢

15:44.980 --> 15:45.980
好

15:45.980 --> 15:46.980
是啥呢

15:46.980 --> 15:48.980
我们可以给它约束一下

15:48.980 --> 15:50.980
它的内形是一个op

15:50.980 --> 15:51.980
比方说

15:51.980 --> 15:52.980
我们现在这样子写了之后

15:52.980 --> 15:54.980
我们再过来看一下

15:54.980 --> 15:55.980
你看

15:55.980 --> 15:56.980
包出的位置变了

15:56.980 --> 15:58.980
我们指着它

15:58.980 --> 15:59.980
你看

15:59.980 --> 16:00.980
它已经知道了

16:00.980 --> 16:02.980
它是一个对象

16:02.980 --> 16:03.980
一个op结果词

16:03.980 --> 16:04.980
对吧

16:04.980 --> 16:05.980
包这个地方

16:05.980 --> 16:06.980
它已经找到了

16:06.980 --> 16:07.980
我们来书写一下

16:07.980 --> 16:08.980
console你看

16:08.980 --> 16:09.980
它已经找到了

16:09.980 --> 16:10.980
只不过它认为

16:10.980 --> 16:11.980
它的内形是op结果词

16:11.980 --> 16:12.980
但是实际上

16:12.980 --> 16:13.980
它是不是op结果词

16:13.980 --> 16:15.980
你可以认为它是op结果词

16:15.980 --> 16:16.980
但是呢

16:16.980 --> 16:17.980
它里边有一些方法

16:17.980 --> 16:18.980
有一些方法

16:18.980 --> 16:19.980
那么现在呢

16:19.980 --> 16:20.980
包出的位置在这

16:20.980 --> 16:21.980
它告诉我

16:21.980 --> 16:22.980
op结果词里边

16:22.980 --> 16:24.980
它不存在属性

16:24.980 --> 16:26.980
不存在这个成员

16:26.980 --> 16:27.980
不存在

16:27.980 --> 16:29.980
那么这个时候很简单

16:29.980 --> 16:31.980
这里可以约束为对象

16:31.980 --> 16:33.980
可不可以约束为其他玩意

16:33.980 --> 16:35.980
能不能约束为其他玩意

16:35.980 --> 16:36.980
肯定是可以的

16:36.980 --> 16:37.980
对吧

16:37.980 --> 16:38.980
我们可以用质面量

16:38.980 --> 16:39.980
质面量对象在这里

16:39.980 --> 16:40.980
继续约束

16:40.980 --> 16:41.980
它是一个对象

16:41.980 --> 16:43.980
这个对象里面有哪些东西呢

16:43.980 --> 16:44.980
有一个函数

16:44.980 --> 16:46.980
有一个函数叫log

16:46.980 --> 16:48.980
这个函数呢

16:48.980 --> 16:49.980
有什么样的参数呢

16:49.980 --> 16:51.980
有什么样的参数

16:51.980 --> 16:53.980
比方说我要message

16:53.980 --> 16:55.980
我要输出一个值

16:55.980 --> 16:56.980
这个参数呢

16:56.980 --> 16:58.980
可以是任何类型

16:58.980 --> 16:59.980
有没有返回呢

16:59.980 --> 17:00.980
返回为卧椅的

17:00.980 --> 17:01.980
比方说

17:01.980 --> 17:02.980
我们就这样写了

17:02.980 --> 17:04.980
写了过后再过来看

17:04.980 --> 17:05.980
是不是不报错了

17:05.980 --> 17:07.980
指着这个它看一下

17:07.980 --> 17:08.980
它约束的内容

17:08.980 --> 17:09.980
你看约束的

17:09.980 --> 17:11.980
它约束这么一个内形

17:11.980 --> 17:12.980
而这个内形里边

17:12.980 --> 17:14.980
是不是有个函数

17:14.980 --> 17:16.980
这个函数要传一个参数message

17:16.980 --> 17:18.980
内形是n你

17:18.980 --> 17:20.980
返回内形卧椅的

17:20.980 --> 17:21.980
就完了

17:21.980 --> 17:22.980
它就声明好了

17:22.980 --> 17:24.980
当然这样的声明

17:24.980 --> 17:25.980
这样的声明

17:25.980 --> 17:27.980
只是在高速ts

17:27.980 --> 17:29.980
跟运行没有任何关系

17:29.980 --> 17:30.980
不要老想着

17:30.980 --> 17:31.980
它运行的时候

17:31.980 --> 17:32.980
是什么样子

17:32.980 --> 17:33.980
跟运行没有任何关系

17:33.980 --> 17:35.980
只是高速ts

17:35.980 --> 17:37.980
我们做内形检查的时候

17:37.980 --> 17:39.980
应该怎么样去检查

17:39.980 --> 17:41.980
是给ts服务的

17:41.980 --> 17:42.980
因此呢

17:42.980 --> 17:43.980
这些声明文件的东西

17:43.980 --> 17:45.980
也不会参与运行的

17:45.980 --> 17:46.980
运行的时候

17:46.980 --> 17:47.980
也不会参与的

17:47.980 --> 17:49.980
都是这么一个点

17:49.980 --> 17:50.980
那么其实呢

17:50.980 --> 17:51.980
这里logo

17:51.980 --> 17:52.980
关于这个logo呢

17:52.980 --> 17:53.980
它这个参数是可选的

17:53.980 --> 17:54.980
可以传可以不传

17:54.980 --> 17:55.980
所以说呢

17:55.980 --> 17:56.980
这里呢

17:56.980 --> 17:57.980
我们打个问号

17:57.980 --> 17:58.980
可以传可以不传

17:58.980 --> 18:00.980
就完事了

18:00.980 --> 18:01.980
注意啊

18:01.980 --> 18:02.980
在声明文件里边

18:02.980 --> 18:05.980
你不要去写任何的负责啊

18:05.980 --> 18:07.980
任何的函数实现

18:07.980 --> 18:08.980
不要去写啊

18:08.980 --> 18:10.980
它只是做内形声明的

18:10.980 --> 18:11.980
然后你在这里给它负责

18:11.980 --> 18:13.980
给这个console负责

18:13.980 --> 18:14.980
约束好类

18:14.980 --> 18:16.980
这里约束好类型之后呢

18:16.980 --> 18:18.980
你这里可以给它负责

18:19.980 --> 18:20.980
log

18:20.980 --> 18:22.980
你真的去写了这么个函数

18:22.980 --> 18:23.980
那不得了了

18:24.980 --> 18:25.980
能不能写

18:25.980 --> 18:26.980
不能写

18:26.980 --> 18:28.980
它说不允许使用

18:28.980 --> 18:29.980
初始化表达式

18:29.980 --> 18:30.980
不允许你这样做

18:30.980 --> 18:31.980
因为

18:31.980 --> 18:33.980
因为它只是声明文件

18:33.980 --> 18:34.980
只是声明内容的

18:35.980 --> 18:37.980
当然这里的做法有很多了

18:37.980 --> 18:38.980
有非常非常多

18:38.980 --> 18:39.980
比方说把这个东西

18:39.980 --> 18:40.980
变成一个接口行不行

18:40.980 --> 18:42.980
可以

18:42.980 --> 18:43.980
可以

18:43.980 --> 18:45.980
interface

18:45.980 --> 18:46.980
interface

18:46.980 --> 18:47.980
console

18:47.980 --> 18:51.480
console

18:51.480 --> 18:52.480
这样

18:52.480 --> 18:53.480
把这个提出来

18:55.480 --> 18:56.480
变成个接口

18:56.480 --> 18:58.480
那么这里console

18:58.480 --> 18:59.480
这是这种做法

18:59.480 --> 19:00.480
也可以

19:00.480 --> 19:01.480
或者把它变成大写的

19:03.480 --> 19:04.480
大写

19:04.480 --> 19:05.480
console没问题

19:05.480 --> 19:06.480
我们可以在这里面加一些

19:06.480 --> 19:08.480
加一些函数

19:08.480 --> 19:09.480
arrow

19:09.480 --> 19:10.480
message

19:10.480 --> 19:11.480
n

19:11.480 --> 19:13.480
void

19:13.480 --> 19:14.480
加一些

19:14.480 --> 19:15.480
好

19:15.480 --> 19:16.480
我们过来再看一下

19:16.480 --> 19:18.480
那么现在不仅可以使用console log

19:18.480 --> 19:20.480
还可以使用console error

19:20.480 --> 19:21.480
也可以使用了

19:21.480 --> 19:22.480
也可以使用了

19:22.480 --> 19:23.480
明白这个意思吗

19:23.480 --> 19:24.480
非常非常简单

19:24.480 --> 19:26.480
这是关于这一块

19:26.480 --> 19:27.480
这是这种写法

19:27.480 --> 19:29.480
这里我再介绍一种写法

19:29.480 --> 19:31.480
再介绍一种写法

19:31.480 --> 19:32.480
是这么写的

19:32.480 --> 19:33.480
给大家看一下

19:33.480 --> 19:34.480
这么写的

19:36.480 --> 19:37.480
这个不多

19:37.480 --> 19:38.480
我把这个地方

19:39.480 --> 19:41.480
改成name space

19:41.480 --> 19:43.480
当然没见过

19:43.480 --> 19:44.480
没见过

19:44.480 --> 19:45.480
console

19:45.480 --> 19:47.480
把这两个复制进来

19:49.480 --> 19:52.940
好

19:52.940 --> 19:53.940
这个地方

19:54.940 --> 19:56.940
这种方式还行

20:00.510 --> 20:01.510
我这里解释一下

20:01.510 --> 20:02.510
这个玩意是啥

20:02.510 --> 20:04.510
这个name space

20:04.510 --> 20:06.510
表示的是命名空间

20:06.510 --> 20:12.140
这个name space

20:12.140 --> 20:16.140
表示命名空间

20:16.140 --> 20:23.540
可以将其

20:23.540 --> 20:25.540
认为是一个对象

20:25.540 --> 20:26.540
你可以这样去想象

20:26.540 --> 20:27.540
它是一个对象

20:27.540 --> 20:30.540
命名空间中的东西

20:30.540 --> 20:34.540
命名空间中的内容

20:34.540 --> 20:38.540
必须通过命名空间

20:38.540 --> 20:39.540
然后

20:39.540 --> 20:40.540
第二

20:40.540 --> 20:42.540
成员名

20:42.540 --> 20:44.540
通过这样的方式

20:44.540 --> 20:45.540
通过这样的方式

20:45.540 --> 20:46.540
访问

20:46.540 --> 20:48.540
其实很简单的

20:48.540 --> 20:49.540
就是说

20:49.540 --> 20:50.540
加了name space过后

20:50.540 --> 20:52.540
这里变成了个命名空间

20:52.540 --> 20:53.540
这个地方

20:53.540 --> 20:55.540
表示命名空间的名字

20:55.540 --> 20:56.540
那么这个空间

20:56.540 --> 20:57.540
里边有哪些东西

20:57.540 --> 20:58.540
有一个函数

20:58.540 --> 20:59.540
有两个函数

21:00.540 --> 21:01.540
我们访问的时候

21:01.540 --> 21:02.540
就应该是

21:05.540 --> 21:06.540
通过命名空间

21:06.540 --> 21:07.540
第二

21:07.540 --> 21:08.540
然后里边的成员名

21:08.540 --> 21:09.540
再一次来访问

21:09.540 --> 21:11.540
其实很简单的

21:11.540 --> 21:12.540
其实这个玩意

21:12.540 --> 21:13.540
以前在TS

21:13.540 --> 21:15.540
早期版本里边

21:15.540 --> 21:17.540
非常非常重要

21:17.540 --> 21:18.540
因为早期版本里边

21:18.540 --> 21:19.540
那个时候

21:19.540 --> 21:21.540
ES6还没有出来

21:21.540 --> 21:23.540
还没有模块化

21:23.540 --> 21:24.540
没有模块化的时候

21:24.540 --> 21:25.540
当时我们组织

21:25.540 --> 21:27.540
模块的时候

21:27.540 --> 21:29.540
要移托于命名空间

21:29.540 --> 21:30.540
命名空间

21:30.540 --> 21:31.540
它要起很大的作用

21:31.540 --> 21:32.540
但是现在

21:32.540 --> 21:33.540
ES6出来过后

21:33.540 --> 21:34.540
这个东西

21:34.540 --> 21:35.540
越来越没用了

21:35.540 --> 21:36.540
我们平时写

21:36.540 --> 21:37.540
TS代码的时候

21:37.540 --> 21:38.540
基本上不会用它

21:38.540 --> 21:39.540
基本上不会用它

21:39.540 --> 21:41.540
官方也不建议你去使用它

21:41.540 --> 21:43.540
那么什么时候用了

21:43.540 --> 21:44.540
可能就在

21:44.540 --> 21:45.540
声明文件里边

21:45.540 --> 21:46.540
偶尔用一用

21:46.540 --> 21:47.540
用一用的命名空间

21:47.540 --> 21:48.540
它用起来很方便

21:48.540 --> 21:49.540
我们不用去定义

21:49.540 --> 21:50.540
什么变量

21:50.540 --> 21:51.540
直接用一个东西

21:51.540 --> 21:52.540
把包起来

21:52.540 --> 21:53.540
给它取个名字

21:53.540 --> 21:54.540
那么这里边的东西

21:54.540 --> 21:55.540
全部通过它来访问

21:55.540 --> 21:56.540
然后就跟这边

21:56.540 --> 21:57.540
就进行吻合了

21:57.540 --> 21:58.540
对吧

21:58.540 --> 21:59.540
刚好吻合了

21:59.540 --> 22:00.540
那么我们现在指着

22:00.540 --> 22:01.540
这个行售

22:01.540 --> 22:02.540
指着它的时候

22:02.540 --> 22:03.540
你会发现

22:03.540 --> 22:04.540
它是一个命名空间

22:04.540 --> 22:05.540
其实无所谓

22:05.540 --> 22:06.540
只要我们书写代码

22:06.540 --> 22:08.540
给它吻合就行了

22:08.540 --> 22:10.540
这是这种情况

22:10.540 --> 22:11.540
那么我们现在

22:11.540 --> 22:12.540
再来试一下

22:12.540 --> 22:13.540
再来做个练习

22:13.540 --> 22:14.540
有人说现在

22:14.540 --> 22:15.540
setTimeout

22:16.540 --> 22:17.540
setTimeout

22:17.540 --> 22:18.540
这个还不行

22:18.540 --> 22:19.540
不行

22:19.540 --> 22:20.540
因为它不知道

22:20.540 --> 22:21.540
有这个函数

22:21.540 --> 22:22.540
好

22:22.540 --> 22:23.540
我们再来一个

22:23.540 --> 22:24.540
再来声明一个

22:24.540 --> 22:26.540
全局的函数

22:26.540 --> 22:28.540
setTimeout和setInterval

22:28.540 --> 22:29.540
好

22:29.540 --> 22:30.540
来试一下

22:30.540 --> 22:31.540
继续声明

22:31.540 --> 22:32.540
Declare

22:32.540 --> 22:34.540
然后声明一个函数

22:34.540 --> 22:35.540
函数的名字

22:35.540 --> 22:37.540
函数的名字叫做

22:37.540 --> 22:39.540
setTimeout

22:39.540 --> 22:40.540
setTimeout

22:40.540 --> 22:41.540
好

22:41.540 --> 22:42.540
这个函数里边

22:42.540 --> 22:44.540
是不是有两个参数

22:44.540 --> 22:45.540
有两个参数

22:45.540 --> 22:47.540
第一个参数是什么

22:47.540 --> 22:49.540
第一个参数是一个函数

22:49.540 --> 22:50.540
对吧

22:50.540 --> 22:51.540
第一个参数是一个函数

22:52.540 --> 22:54.540
每个多号时间

22:54.540 --> 22:56.540
来进行处理的函数

22:56.540 --> 22:57.540
好

22:57.540 --> 22:58.540
第一个参数的类型

22:58.540 --> 22:59.540
它是一个函数

22:59.540 --> 23:00.540
这个函数是无参

23:00.540 --> 23:02.540
没有返回值

23:02.540 --> 23:03.540
没有返回值

23:03.540 --> 23:04.540
好

23:04.540 --> 23:05.540
第二个参数

23:05.540 --> 23:06.540
是时间

23:06.540 --> 23:07.540
对吧

23:07.540 --> 23:08.540
毫秒数

23:08.540 --> 23:10.540
mini seconds

23:10.540 --> 23:11.540
毫秒数

23:11.540 --> 23:12.540
毫秒数

23:12.540 --> 23:13.540
我们给它约束一下类型

23:13.540 --> 23:14.540
类型为啥呢

23:14.540 --> 23:16.540
类型为number

23:16.540 --> 23:17.540
好

23:17.540 --> 23:18.540
返回到类型是啥呢

23:18.540 --> 23:19.540
setTimeout

23:19.540 --> 23:20.540
返回到类型是啥

23:20.540 --> 23:21.540
返回的类型

23:21.540 --> 23:22.540
就是一个

23:22.540 --> 23:23.540
计时器

23:23.540 --> 23:25.540
是一个数字

23:25.540 --> 23:26.540
发生为number

23:26.540 --> 23:28.540
返回的是一个数字

23:28.540 --> 23:30.540
这就是setTimeout

23:30.540 --> 23:31.540
好

23:31.540 --> 23:32.540
有了这个函数之后

23:32.540 --> 23:33.540
我们看一下这里

23:33.540 --> 23:34.540
是不是不爆错了

23:34.540 --> 23:35.540
就不爆错了

23:35.540 --> 23:36.540
我们指着它

23:36.540 --> 23:37.540
你看

23:37.540 --> 23:38.540
就得到了类型检查

23:38.540 --> 23:39.540
好

23:39.540 --> 23:40.540
同样道理

23:40.540 --> 23:41.540
我们去生成

23:41.540 --> 23:42.540
去生成

23:42.540 --> 23:44.540
生成setInterval

23:44.540 --> 23:46.540
Interval

23:46.540 --> 23:47.540
好

23:47.540 --> 23:49.540
我们生明一个setInterval

23:49.540 --> 23:50.540
生明之后

23:50.540 --> 23:52.540
我们这边也可以使用

23:52.540 --> 23:53.540
setInterval

23:53.540 --> 23:55.540
是一样的

23:55.540 --> 23:56.540
好

23:56.540 --> 23:57.540
我们可以看到

23:57.540 --> 23:58.540
这两个参数

23:58.540 --> 23:59.540
第一个参数

23:59.540 --> 24:01.540
第一个参数

24:01.540 --> 24:03.540
他们

24:03.540 --> 24:04.540
第一个参数

24:04.540 --> 24:06.540
他们都有相同的返回类型

24:06.540 --> 24:07.540
对吧

24:07.540 --> 24:08.540
都有相同的返回类型

24:08.540 --> 24:09.540
因此

24:09.540 --> 24:10.540
我们可以

24:10.540 --> 24:11.540
我们可以把

24:11.540 --> 24:12.540
第一个参数

24:12.540 --> 24:13.540
提出来

24:13.540 --> 24:14.540
tab

24:14.540 --> 24:15.540
给它写个类型别名

24:15.540 --> 24:17.540
叫做

24:17.540 --> 24:19.540
tamHandler

24:19.540 --> 24:20.540
tamHandler

24:20.540 --> 24:21.540
就是一个空的函数

24:21.540 --> 24:22.540
返回类型

24:22.540 --> 24:23.540
微博异的

24:23.540 --> 24:26.540
可以这样再处理

24:26.540 --> 24:29.540
可以这样再处理

24:29.540 --> 24:31.540
也完成了

24:31.540 --> 24:32.540
好了

24:32.540 --> 24:33.540
这是关于

24:33.540 --> 24:34.540
关于这里

24:34.540 --> 24:36.540
权局声明

24:36.540 --> 24:37.540
如何来进行声明

24:37.540 --> 24:39.540
权局声明

24:39.540 --> 24:40.540
有的时候

24:40.540 --> 24:43.540
我们可能不希望进行权局声明

24:43.540 --> 24:45.540
可能不是很希望进行权局声明

24:45.540 --> 24:47.540
而是需要对某一个磨块

24:47.540 --> 24:49.540
进行声明

24:49.540 --> 24:51.540
我们再说第二个情况

24:51.540 --> 24:54.540
磨块声明

24:54.540 --> 24:55.540
就是有的时候

24:55.540 --> 24:57.540
有一些磨块安装好了

24:57.540 --> 24:59.540
那个磨块是用介石写的

24:59.540 --> 25:00.540
我们找了半天

25:00.540 --> 25:01.540
也没有找到

25:01.540 --> 25:02.540
它的类型声明

25:02.540 --> 25:03.540
它有没有类型声明

25:03.540 --> 25:04.540
找不到

25:04.540 --> 25:05.540
那么这个时候

25:05.540 --> 25:06.540
我们也需要

25:06.540 --> 25:07.540
自己去书写

25:07.540 --> 25:08.540
这个声明文件

25:08.540 --> 25:09.540
那么这个时候

25:09.540 --> 25:11.540
我们是要针对某一个磨块

25:11.540 --> 25:13.540
进行声明

25:13.540 --> 25:14.540
也就是说

25:14.540 --> 25:16.540
它不是暴露给权局使用的

25:16.540 --> 25:17.540
而是只在

25:17.540 --> 25:18.540
导入了磨块之后

25:18.540 --> 25:19.540
才能使用

25:19.540 --> 25:20.540
那么这个时候

25:20.540 --> 25:21.540
该怎么来处理

25:21.540 --> 25:22.540
我们来说一下

25:22.540 --> 25:23.540
这种情况

25:23.540 --> 25:24.540
这种情况

25:24.540 --> 25:25.540
我们来举一个例子

25:25.540 --> 25:27.540
我们这里安装一个磨块吧

25:27.540 --> 25:29.540
安装一个磨块

25:30.540 --> 25:31.540
安装啥呢

25:31.540 --> 25:32.540
安装一个

25:32.540 --> 25:34.540
NPM

25:35.540 --> 25:37.540
安装那个

25:37.540 --> 25:39.540
ATD

25:39.540 --> 25:40.540
楼大喜

25:40.540 --> 25:41.540
关于楼大喜的磨块

25:41.540 --> 25:43.540
当然应该知道吧

25:44.540 --> 25:45.540
这个磨块

25:47.540 --> 25:49.540
在很早以前

25:49.540 --> 25:50.540
在很早以前

25:50.540 --> 25:52.540
在ES5出来之前

25:52.540 --> 25:54.540
这个楼大喜这个磨块

25:54.540 --> 25:57.540
它真的非常非常好用

25:58.540 --> 25:59.540
它里面提供了

25:59.540 --> 26:01.540
很多的使用性的函数

26:01.540 --> 26:03.540
有很多使用性的函数

26:03.540 --> 26:05.540
帮助我们对数组

26:05.540 --> 26:06.540
对对箱

26:06.540 --> 26:07.540
这些乱七八糟的东西

26:07.540 --> 26:08.540
进行处理

26:08.540 --> 26:09.540
非常非常好用

26:09.540 --> 26:10.540
现在

26:10.540 --> 26:11.540
可能用的稍微少一点了

26:11.540 --> 26:12.540
因为现在

26:12.540 --> 26:13.540
对数组

26:13.540 --> 26:14.540
对对箱的操作

26:14.540 --> 26:15.540
它本身标准里面

26:15.540 --> 26:16.540
已经用了很多

26:16.540 --> 26:17.540
已经

26:17.540 --> 26:18.540
丰富了很多了

26:18.540 --> 26:19.540
所以说

26:19.540 --> 26:20.540
可能现在用的少了一些

26:20.540 --> 26:22.540
但是以前是非常非常常用的

26:22.540 --> 26:23.540
不可

26:24.540 --> 26:25.540
怎么用

26:25.540 --> 26:26.540
好了

26:27.540 --> 26:28.540
好那么现在

26:28.540 --> 26:29.540
我们来试着

26:29.540 --> 26:31.540
哎这为什么爆错

26:31.540 --> 26:32.540
抗射

26:32.540 --> 26:33.540
标识不抗射重复了

26:33.540 --> 26:34.540
对吧

26:34.540 --> 26:35.540
不是这个地方

26:35.540 --> 26:36.540
我看一下

26:37.540 --> 26:38.540
刷新一下

26:39.540 --> 26:40.540
它漏的又出来了

26:40.540 --> 26:41.540
漏的又出来了

26:41.540 --> 26:43.540
我刚才一安装的时候

26:43.540 --> 26:44.540
它发现缺失了

26:44.540 --> 26:45.540
它又把安装了

26:45.540 --> 26:46.540
我们这些

26:46.540 --> 26:47.540
那就不要了嘛

26:47.540 --> 26:48.540
全球声明我们一讲

26:48.540 --> 26:49.540
讲完了对吧

26:49.540 --> 26:50.540
我们不要了

26:53.540 --> 26:54.540
好现在

26:54.540 --> 26:56.540
我们来声明这个模块

26:56.540 --> 26:58.540
我们现在安装好了什么呢

26:58.540 --> 27:00.540
安装好了楼大喜之后

27:00.540 --> 27:01.540
楼大喜这个库

27:01.540 --> 27:02.540
安装好了之后

27:02.540 --> 27:04.540
它里面有很多很多的东西

27:04.540 --> 27:05.540
比方说

27:05.540 --> 27:06.540
我们平时是怎么用的呢

27:06.540 --> 27:08.540
平时我们是这样子用的

27:08.540 --> 27:09.540
Import

27:10.540 --> 27:12.540
from楼大喜

27:12.540 --> 27:13.540
倒入进来

27:13.540 --> 27:14.540
倒入进来过后

27:14.540 --> 27:15.540
我们就可以使用

27:15.540 --> 27:17.540
它里面的很多东西

27:17.540 --> 27:18.540
比方说

27:18.540 --> 27:20.540
the trunk这个函数

27:20.540 --> 27:21.540
这个函数

27:21.540 --> 27:22.540
它可以把怎么样呢

27:22.540 --> 27:24.540
它可以把一个数组

27:24.540 --> 27:27.540
按照这样的尺寸来进行分割

27:27.540 --> 27:29.540
分割成多个数组

27:29.540 --> 27:30.540
它可以达到这样的一个效果

27:30.540 --> 27:32.540
你看把abcd

27:32.540 --> 27:33.540
每一个分割

27:33.540 --> 27:35.540
按二来分割

27:35.540 --> 27:37.540
每一个数组有两项

27:37.540 --> 27:39.540
两项

27:39.540 --> 27:41.540
分割成多个数组

27:41.540 --> 27:42.540
它有这么一个作用

27:42.540 --> 27:43.540
比如我们用的时候是咋用的呢

27:43.540 --> 27:45.540
我们用的时候是这样用的

27:45.540 --> 27:47.540
加发线

27:47.540 --> 27:49.540
给它一个数组

27:49.540 --> 27:51.540
随便给它一个数组

27:51.540 --> 27:52.540
然后呢比方说

27:52.540 --> 27:53.540
写个二

27:53.540 --> 27:54.540
写个二

27:54.540 --> 27:55.540
然后然后给我们分割

27:55.540 --> 27:57.540
分割成为了一个新的数组

27:57.540 --> 27:58.540
6

27:58.540 --> 27:59.540
2

27:59.540 --> 28:01.540
我们以前是这样做的

28:01.540 --> 28:03.540
那现在还要包错

28:03.540 --> 28:04.540
它包到怎么错呢

28:04.540 --> 28:06.540
我们看一下

28:06.540 --> 28:08.540
它包的错误就是说

28:08.540 --> 28:10.540
这个模块呢找不到生命文件

28:10.540 --> 28:12.540
因为这个模块是用GS写的

28:12.540 --> 28:14.540
它没有任何的类型系统

28:14.540 --> 28:16.540
那么我们在TS里面

28:16.540 --> 28:18.540
无法获得

28:18.540 --> 28:19.540
完整的类型检查

28:19.540 --> 28:21.540
没办法获取类型检查

28:21.540 --> 28:22.540
那么这个时候

28:22.540 --> 28:23.540
其实你能不能使用

28:23.540 --> 28:24.540
也能使用

28:24.540 --> 28:25.540
也能使用

28:25.540 --> 28:26.540
你这样的用

28:26.540 --> 28:27.540
给它看一下吧

28:27.540 --> 28:29.540
你这样的用

28:29.540 --> 28:31.540
用古老的common GS

28:31.540 --> 28:32.540
把导入进来

28:32.540 --> 28:34.540
用这种方式把导入进来

28:34.540 --> 28:35.540
能不能用

28:35.540 --> 28:36.540
这次可以用

28:36.540 --> 28:37.540
类型为啥

28:37.540 --> 28:38.540
类型为n你

28:38.540 --> 28:39.540
以前咋用

28:39.540 --> 28:40.540
现在咋用

28:40.540 --> 28:41.540
但是呢

28:41.540 --> 28:43.540
遗憾的是你这样做了之后

28:43.540 --> 28:45.540
获得不了任何的类型检查

28:45.540 --> 28:46.540
因为它是内容是n你

28:46.540 --> 28:47.540
你想写啥写啥

28:47.540 --> 28:48.540
写错了

28:48.540 --> 28:49.540
它也不管

28:49.540 --> 28:52.540
如果你要获得完整的类型检查的话

28:52.540 --> 28:54.540
如果你要获得完整的类型检查的话

28:54.540 --> 28:55.540
那么这个时候

28:55.540 --> 28:58.540
需要给它添加生命文件

28:58.540 --> 29:00.540
好比方到这里

29:00.540 --> 29:01.540
我们在src目标下

29:01.540 --> 29:03.540
不要再新建一个文件

29:03.540 --> 29:05.540
因为

29:05.540 --> 29:10.540
no.d.ts

29:10.540 --> 29:11.540
好

29:11.540 --> 29:12.540
我们给它写个生命文件

29:12.540 --> 29:14.540
我们现在要生命的是啥

29:14.540 --> 29:15.540
生命的不是全局的

29:15.540 --> 29:17.540
这个玩意不是全局可以使用的

29:17.540 --> 29:19.540
而是导入模块过后使用的

29:19.540 --> 29:20.540
所以说呢

29:20.540 --> 29:21.540
这里呢

29:21.540 --> 29:22.540
我们要生命一个模块

29:22.540 --> 29:25.540
这里要生命模块

29:25.540 --> 29:27.540
生命模块

29:27.540 --> 29:28.540
怎么生命模块呢

29:28.540 --> 29:30.540
非常非常简单

29:30.540 --> 29:31.540
declare

29:31.540 --> 29:32.540
生命

29:32.540 --> 29:33.540
关键是module

29:33.540 --> 29:35.540
生命模块

29:35.540 --> 29:37.540
生命模块的时候呢

29:37.540 --> 29:40.540
我们这里写上模块的名字

29:40.540 --> 29:41.540
什么模块名字

29:41.540 --> 29:43.540
no.d.ts

29:43.540 --> 29:45.540
好这样子写了过后

29:45.540 --> 29:46.540
有什么好处

29:46.540 --> 29:47.540
这样子写了过后呢

29:47.540 --> 29:50.540
它的好处在于

29:50.540 --> 29:51.540
当我们去

29:51.540 --> 29:54.540
在代码中去导入这个no.d.ts的时候

29:54.540 --> 29:56.540
它查询到了生命文件中

29:56.540 --> 29:58.540
生命的这个模块

29:58.540 --> 29:59.540
就表示这个模块

29:59.540 --> 30:01.540
已经有类型定义了

30:01.540 --> 30:02.540
它会从这个

30:02.540 --> 30:05.540
它会从这里边来找它的类型定义

30:05.540 --> 30:07.540
这里边的就全是它的类型定义

30:07.540 --> 30:08.540
好

30:08.540 --> 30:09.540
那么这样子一生命之后呢

30:09.540 --> 30:10.540
你看这里不爆错了

30:10.540 --> 30:12.540
它找到了它的类型定义了

30:12.540 --> 30:14.540
那么类型定义找到了过后呢

30:14.540 --> 30:15.540
但是呢

30:15.540 --> 30:16.540
这个玩意儿

30:16.540 --> 30:18.540
这个玩意儿是啥呢

30:18.540 --> 30:19.540
这个玩意儿是啥呢

30:19.540 --> 30:21.540
它也不清楚这个玩意儿是啥

30:21.540 --> 30:23.540
这个玩意儿里边是空的

30:23.540 --> 30:24.540
啥都没有

30:24.540 --> 30:25.540
你看这里面是不是空的

30:25.540 --> 30:27.540
表示这个模块里边

30:27.540 --> 30:28.540
什么都没有

30:28.540 --> 30:30.540
什么都没有

30:30.540 --> 30:31.540
好

30:31.540 --> 30:32.540
那么现在我要做啥事呢

30:32.540 --> 30:34.540
我要在这个模块里边告诉他

30:34.540 --> 30:36.540
我们这个模块里边呢

30:36.540 --> 30:38.540
有一些函数

30:38.540 --> 30:39.540
有一些函数

30:39.540 --> 30:40.540
比方说trunk

30:40.540 --> 30:42.540
有这么一个函数

30:42.540 --> 30:43.540
好

30:43.540 --> 30:44.540
那么这里呢

30:44.540 --> 30:45.540
我就可以告诉他

30:45.540 --> 30:46.540
怎么告诉

30:46.540 --> 30:47.540
我们用这种方式来说些

30:47.540 --> 30:48.540
export

30:48.540 --> 30:49.540
导出嘛

30:49.540 --> 30:50.540
对吧

30:50.540 --> 30:52.540
模块里面肯定要不断的导出一些东西嘛

30:52.540 --> 30:53.540
它导出了什么呢

30:53.540 --> 30:55.540
导出了其中一个函数

30:55.540 --> 30:57.540
导出一个函数

30:57.540 --> 30:58.540
方形

30:58.540 --> 30:59.540
trunk

30:59.540 --> 31:00.540
trunk

31:00.540 --> 31:01.540
反核类型卧椅的

31:01.540 --> 31:03.540
先随便写吧

31:03.540 --> 31:04.540
好写到之后

31:04.540 --> 31:05.540
你看

31:05.540 --> 31:06.540
这个函数是不是有了

31:06.540 --> 31:07.540
这个函数

31:07.540 --> 31:08.540
你看它就已经有了

31:08.540 --> 31:09.540
看到没

31:09.540 --> 31:10.540
就已经有这个函数了

31:10.540 --> 31:11.540
好

31:11.540 --> 31:12.540
这个函数反核类型呢

31:12.540 --> 31:13.540
微卧椅的

31:13.540 --> 31:14.540
反核类型微卧椅的

31:14.540 --> 31:16.540
但是肯定是不满足要求的

31:16.540 --> 31:18.540
我们把这个函数完善一下

31:18.540 --> 31:20.540
完善一下这个函数

31:20.540 --> 31:21.540
那你想一想

31:21.540 --> 31:23.540
这是以前的介绍代码

31:23.540 --> 31:24.540
这个函数

31:24.540 --> 31:27.540
第一个函数应该是什么类型

31:27.540 --> 31:28.540
很简单

31:28.540 --> 31:29.540
对吧

31:29.540 --> 31:30.540
一个数组

31:30.540 --> 31:31.540
来呗

31:31.540 --> 31:33.540
第一个参数是一个数组

31:33.540 --> 31:34.540
额瑞

31:34.540 --> 31:35.540
给它个参数名

31:35.540 --> 31:36.540
额瑞

31:36.540 --> 31:37.540
好

31:37.540 --> 31:38.540
数组的类型是什么呢

31:38.540 --> 31:40.540
数组的每一项写啥

31:40.540 --> 31:42.540
什么类型的数组

31:42.540 --> 31:43.540
知不错

31:43.540 --> 31:44.540
数字

31:44.540 --> 31:46.540
还是什么类型的数组

31:46.540 --> 31:48.540
它有没有要求这个数组的类型

31:48.540 --> 31:49.540
是没要求

31:49.540 --> 31:51.540
不要求这个数组的类型

31:51.540 --> 31:54.540
因此它可以是任何类型的数组

31:54.540 --> 31:56.540
可以是任何类型的数组

31:57.540 --> 31:58.540
这是第一个参数

31:58.540 --> 32:00.540
第二个参数呢

32:00.540 --> 32:01.540
是什么呢

32:01.540 --> 32:02.540
第二个参数是一个数字

32:02.540 --> 32:04.540
我都不用管这个函数

32:04.540 --> 32:05.540
它怎么去运作的

32:05.540 --> 32:06.540
怎么去书写的

32:06.540 --> 32:07.540
无所谓

32:07.540 --> 32:09.540
我只是对它进行类型声明

32:09.540 --> 32:10.540
第二个参数是什么

32:10.540 --> 32:12.540
第二个参数是一个数字

32:12.540 --> 32:13.540
表示尺寸

32:13.540 --> 32:15.540
我要怎么来分割

32:15.540 --> 32:16.540
那么给它写个size

32:16.540 --> 32:17.540
表示第二个参数

32:17.540 --> 32:19.540
类型是number

32:19.540 --> 32:20.540
好

32:20.540 --> 32:22.540
返回的是啥呢

32:22.540 --> 32:23.540
返回的是啥

32:23.540 --> 32:25.540
你看一下

32:25.540 --> 32:27.540
返回的是啥

32:27.540 --> 32:29.540
返回的是数组的数组

32:29.540 --> 32:30.540
对吧

32:30.540 --> 32:32.540
返回的是多个数组

32:32.540 --> 32:34.540
返回的是多个数组

32:34.540 --> 32:36.540
也就是返回的是什么玩意呢

32:36.540 --> 32:38.540
返回的是any数组

32:40.540 --> 32:42.540
这个数组的每一项

32:42.540 --> 32:44.540
就这个数组的每一项

32:44.540 --> 32:46.540
仍然是一个数组

32:46.540 --> 32:47.540
好

32:47.540 --> 32:49.540
我们这样子写了过后呢

32:49.540 --> 32:50.540
有些同学呢

32:50.540 --> 32:52.540
应该能够回忆得到

32:52.540 --> 32:55.540
以前好像举过类似的例子

32:55.540 --> 32:57.540
这个位置

32:57.540 --> 32:58.540
和这个位置

32:58.540 --> 33:00.540
有没有联系啊

33:00.540 --> 33:01.540
是不是有联系的

33:01.540 --> 33:02.540
这个地方

33:02.540 --> 33:03.540
有联系的对吧

33:03.540 --> 33:05.540
那么这里的类型

33:05.540 --> 33:07.540
跟这里的类型一感一致

33:07.540 --> 33:08.540
应该是一致的

33:08.540 --> 33:10.540
但是现在的丢失了这个信息

33:10.540 --> 33:12.540
那怎么办呢

33:12.540 --> 33:13.540
犯小

33:13.540 --> 33:15.540
这个时候我们可以使用犯小

33:15.540 --> 33:16.540
什么类型的数组

33:16.540 --> 33:17.540
T类型的数组

33:17.540 --> 33:18.540
返回的是什么类型的数组

33:18.540 --> 33:21.540
也是T类型的数组的数组

33:21.540 --> 33:22.540
好了

33:22.540 --> 33:23.540
那么就写好了

33:23.540 --> 33:24.540
写好了之后

33:24.540 --> 33:25.540
我们再看这边

33:27.540 --> 33:29.540
我们传入的是一个Number类型的数组

33:29.540 --> 33:31.540
把它按2来分割

33:31.540 --> 33:32.540
你看结果

33:32.540 --> 33:34.540
看这个结果

33:34.540 --> 33:35.540
那看

33:35.540 --> 33:37.540
翻译型推断出来就是Number

33:37.540 --> 33:38.540
返回的结果

33:38.540 --> 33:39.540
就是Number数组的数组

33:39.540 --> 33:40.540
得到结果了

33:40.540 --> 33:41.540
那么最后呢

33:41.540 --> 33:42.540
我们把这个输出一下

33:42.540 --> 33:43.540
输出一下

33:43.540 --> 33:45.540
它说6AR

33:46.540 --> 33:47.540
保存

33:47.540 --> 33:48.540
好

33:48.540 --> 33:49.540
这个时候呢

33:49.540 --> 33:50.540
我们先来编译

33:50.540 --> 33:51.540
来进行编译

33:51.540 --> 33:54.500
好

33:54.500 --> 33:55.500
编译完成

33:55.500 --> 33:56.500
我们来运行这个

33:56.500 --> 33:58.500
indexer.js

33:58.500 --> 33:59.500
load

33:59.500 --> 34:00.500
dash目录下面的

34:00.500 --> 34:02.500
indexer.js

34:02.500 --> 34:03.500
运行

34:03.500 --> 34:04.500
你看

34:04.500 --> 34:05.500
结果正确了

34:05.500 --> 34:07.500
我们在编写代码期间

34:07.500 --> 34:08.500
可以获得完整的类型检查

34:08.500 --> 34:10.500
因为我们有了生命文件

34:10.500 --> 34:11.500
并且呢

34:11.500 --> 34:13.500
我们也可以获得

34:13.500 --> 34:15.500
正确的执行结果

34:15.500 --> 34:17.500
因为代码本身就是正确的

34:17.500 --> 34:18.500
但是到这里

34:18.500 --> 34:19.500
还有个小问题

34:19.500 --> 34:20.500
啥问题呢

34:20.500 --> 34:22.500
就是当我使用

34:22.500 --> 34:23.500
rwndev的时候

34:23.500 --> 34:24.500
要出问题

34:25.500 --> 34:26.500
使用这个时候

34:26.500 --> 34:27.500
它要会出问题

34:27.500 --> 34:28.500
它会爆错

34:29.500 --> 34:30.500
就是我编译的话

34:30.500 --> 34:31.500
都正常编译

34:31.500 --> 34:32.500
但是呢

34:32.500 --> 34:34.500
使用npmrwndev

34:34.500 --> 34:35.500
使用这个

34:35.500 --> 34:37.500
这个方式来运行的话

34:37.500 --> 34:38.500
它会爆错

34:38.500 --> 34:39.500
它说找不到

34:39.500 --> 34:40.500
找不到生命文件

34:41.500 --> 34:43.500
它的意思就是找不到生命文件

34:43.500 --> 34:45.500
这是怎么回事呢

34:45.500 --> 34:46.500
这是一个

34:46.500 --> 34:48.500
比较久远的问题了

34:48.500 --> 34:49.500
我们看一下

34:49.500 --> 34:51.500
package.json

34:51.500 --> 34:52.500
这个文件里边

34:52.500 --> 34:54.500
我们当时写了这么一个东西

34:54.500 --> 34:55.500
dev

34:55.500 --> 34:57.500
它运行的是啥呢

34:57.500 --> 34:59.500
当文件发生变化的时候

34:59.500 --> 35:00.500
它运行的是这个命令

35:00.500 --> 35:02.500
tsnode这个命令

35:02.500 --> 35:05.500
而这个命令的话

35:05.500 --> 35:07.500
它有一个问题

35:07.500 --> 35:08.500
因为这个命令

35:08.500 --> 35:09.500
是给它指定了

35:09.500 --> 35:11.500
一个ts文件来执行

35:11.500 --> 35:13.500
而不是使用了

35:13.500 --> 35:15.500
配置文件里边的

35:15.500 --> 35:17.500
这种编译方式

35:17.500 --> 35:18.500
配置文件里面

35:18.500 --> 35:19.500
把src目录下面

35:19.500 --> 35:21.500
所谓的一起编译

35:21.500 --> 35:22.500
但是这边呢

35:22.500 --> 35:25.500
我是要给它指定一个文件来执行

35:25.500 --> 35:28.500
在tsnode的官方文档里边

35:28.500 --> 35:30.500
我们来看一下它的官方文档

35:30.500 --> 35:31.500
像这些信息

35:31.500 --> 35:33.500
除了一些乱七八糟的问题

35:33.500 --> 35:34.500
其实大家只要去看一下

35:34.500 --> 35:35.500
它的官方文档

35:35.500 --> 35:36.500
就能搞定了

35:36.500 --> 35:38.500
比方说之前

35:38.500 --> 35:41.500
我在写生命文件的时候

35:41.500 --> 35:43.500
也会发现有这么一个问题

35:43.500 --> 35:44.500
我一想

35:44.500 --> 35:46.500
我就这么思考了

35:46.500 --> 35:47.500
就是我发现

35:47.500 --> 35:48.500
它这里爆错了

35:48.500 --> 35:49.500
就是发现它这里爆错了

35:49.500 --> 35:50.500
我会怎么想呢

35:50.500 --> 35:52.500
我说那不对啊

35:52.500 --> 35:54.500
我刚才运行bo的的时候

35:54.500 --> 35:56.500
就运行它的时候

35:56.500 --> 35:58.500
进行tsc的命令

35:58.500 --> 35:59.500
运行编译

35:59.500 --> 36:00.500
是没有我们爆错的

36:00.500 --> 36:01.500
那就说明

36:01.500 --> 36:02.500
我们的代码没问题

36:02.500 --> 36:03.500
编译能通过

36:03.500 --> 36:04.500
那编译能通过

36:04.500 --> 36:06.500
但是运行这个命令

36:06.500 --> 36:07.500
出了问题

36:07.500 --> 36:08.500
那肯定是

36:08.500 --> 36:09.500
肯定是它的问题

36:09.500 --> 36:10.500
对吧

36:10.500 --> 36:11.500
除了它还有谁呢

36:11.500 --> 36:12.500
于是我就马上

36:12.500 --> 36:13.500
去找它的官方文档

36:13.500 --> 36:14.500
看它里边

36:14.500 --> 36:15.500
有没有说到这个问题

36:15.500 --> 36:16.500
好 那它官方文档里面

36:16.500 --> 36:18.500
找啊找啊找啊找

36:18.500 --> 36:20.500
好 找到其中一个点

36:20.500 --> 36:22.500
它就说这个问题

36:22.500 --> 36:23.500
它说

36:23.500 --> 36:25.500
救命啊救命啊

36:25.500 --> 36:27.500
我的类型不见了

36:27.500 --> 36:29.500
它就来说这个问题

36:29.500 --> 36:30.500
它怎么说的呢

36:30.500 --> 36:32.500
大家看一下这段话

36:32.500 --> 36:34.500
它说我们这个库啊

36:34.500 --> 36:35.500
库的名字叫做

36:35.500 --> 36:36.500
tsload的

36:36.500 --> 36:37.500
typescriptload的

36:37.500 --> 36:39.500
它说并没有在

36:39.500 --> 36:40.500
使用配置文件里面的

36:40.500 --> 36:41.500
这几个配置

36:41.500 --> 36:43.500
files

36:43.500 --> 36:44.500
include

36:44.500 --> 36:45.500
exclude

36:45.500 --> 36:46.500
啥意思

36:46.500 --> 36:47.500
它说

36:47.500 --> 36:48.500
它没有用配置文件里面的

36:48.500 --> 36:50.500
这个东西

36:50.500 --> 36:51.500
这个东西它没有用

36:51.500 --> 36:52.500
包括什么配置啊

36:52.500 --> 36:54.500
包括明显讲过的files

36:54.500 --> 36:55.500
手动指定

36:55.500 --> 36:56.500
运行哪些文件

36:56.500 --> 36:57.500
编印哪些文件

36:57.500 --> 36:59.500
exclude

36:59.500 --> 37:01.500
排除掉哪些文件家

37:01.500 --> 37:02.500
这些配置

37:02.500 --> 37:03.500
它是没有用的

37:03.500 --> 37:05.500
它为啥不用呢

37:05.500 --> 37:07.500
它说

37:07.500 --> 37:08.500
因为呢

37:08.500 --> 37:10.500
在一个大型的工程里边

37:10.500 --> 37:12.500
我们没有必要

37:12.500 --> 37:14.500
把所有的文件

37:14.500 --> 37:15.500
在开发的过程中

37:15.500 --> 37:16.500
把所有的文件

37:16.500 --> 37:18.500
和整个工程目录

37:18.500 --> 37:19.500
来进行编印

37:19.500 --> 37:20.500
编印运行

37:20.500 --> 37:21.500
这样子呢

37:21.500 --> 37:23.500
会减慢启动的速度

37:23.500 --> 37:25.500
启动的时间

37:25.500 --> 37:26.500
因此呢

37:26.500 --> 37:29.500
作为tsload的

37:29.500 --> 37:30.500
它是

37:30.500 --> 37:32.500
根据一个启动文件

37:32.500 --> 37:33.500
来进行编印的

37:33.500 --> 37:34.500
看这个启动文件

37:34.500 --> 37:35.500
一旦哪些东西

37:35.500 --> 37:36.500
来进行编印的

37:36.500 --> 37:37.500
因此呢

37:37.500 --> 37:38.500
由于它没有去

37:38.500 --> 37:40.500
读这个配置

37:40.500 --> 37:41.500
而我们知道

37:42.500 --> 37:43.500
这个

37:43.500 --> 37:45.500
声明文件

37:45.500 --> 37:46.500
它是不是

37:46.500 --> 37:48.500
必须要写到这个配置里边

37:48.500 --> 37:50.500
这个配置指定的目录

37:50.500 --> 37:52.500
指定的目录里边

37:52.500 --> 37:53.500
写声明文件

37:53.500 --> 37:54.500
但是它由于

37:54.500 --> 37:55.500
它没有去读这个配置

37:55.500 --> 37:56.500
它就不知道

37:56.500 --> 37:57.500
声明文件在哪

37:57.500 --> 37:59.500
就是这个原因造成的

37:59.500 --> 38:00.500
所以说呢

38:00.500 --> 38:01.500
它这里

38:01.500 --> 38:02.500
告诉你怎么处理呢

38:02.500 --> 38:03.500
读了半天

38:03.500 --> 38:04.500
发现它告诉你

38:04.500 --> 38:05.500
怎么处理

38:05.500 --> 38:06.500
怎么处理呢

38:06.500 --> 38:08.500
处理的方式很简单

38:08.500 --> 38:10.500
你自己手动配置一下

38:10.500 --> 38:11.500
告诉它

38:11.500 --> 38:13.500
在编印选项配置里边

38:13.500 --> 38:15.500
告诉它声明文件的位置

38:15.500 --> 38:16.500
就完事了

38:16.500 --> 38:18.500
我们之前讲过这个配置对吧

38:18.500 --> 38:20.500
Types Roots

38:20.500 --> 38:22.500
我们手动的去告诉它

38:22.500 --> 38:24.500
声明文件在哪

38:24.500 --> 38:26.500
Types Roots

38:26.500 --> 38:27.500
总的告诉它

38:27.500 --> 38:28.500
在哪些位置呢

38:28.500 --> 38:29.500
当然我们配置了

38:29.500 --> 38:30.500
这个东西过后

38:30.500 --> 38:31.500
要把这个东西加上

38:31.500 --> 38:33.500
要把这个地方加上

38:33.500 --> 38:34.500
首先我们要去找

38:34.500 --> 38:35.500
什么

38:38.500 --> 38:39.500
Types这个文件讲

38:39.500 --> 38:41.500
还要去找啥呢

38:41.500 --> 38:42.500
还要去找

38:43.500 --> 38:44.500
我们这里

38:44.500 --> 38:45.500
刚才在这里面

38:45.500 --> 38:46.500
建议文件讲

38:46.500 --> 38:47.500
Types

38:47.500 --> 38:49.500
就是我们自己写的配置

38:49.500 --> 38:50.500
这里

38:50.500 --> 38:52.500
我们刚才

38:53.500 --> 38:54.500
刚才

38:54.500 --> 38:55.500
就是

38:55.500 --> 38:56.500
定义的模块呢

38:56.500 --> 38:57.500
是楼弹器

38:57.500 --> 38:59.500
我们用这样的目录结构

38:59.500 --> 39:00.500
就跟它上面

39:00.500 --> 39:01.500
类似的目录结构

39:01.500 --> 39:02.500
放过去

39:03.500 --> 39:04.500
好 这里面

39:04.500 --> 39:05.500
我们把它改成英Dex

39:06.500 --> 39:08.500
这也是组织下目录结构

39:08.500 --> 39:10.500
不是说必须要这样做

39:10.500 --> 39:11.500
我们只是把它

39:11.500 --> 39:12.500
组织一下目录结构

39:12.500 --> 39:14.500
表示这里的声明文件呢

39:14.500 --> 39:15.500
就是声明的是啥

39:15.500 --> 39:17.500
声明的模块是楼弹器

39:18.500 --> 39:19.500
好 配置好了

39:19.500 --> 39:20.500
过后我们这里

39:20.500 --> 39:21.500
给它这样子写

39:21.500 --> 39:22.500
还要去拿走了

39:22.500 --> 39:25.500
还要去src目录下边的

39:26.500 --> 39:28.500
Types目录下面去找

39:28.500 --> 39:29.500
好 告诉它

39:29.500 --> 39:30.500
手动的去告诉它

39:30.500 --> 39:32.500
在编印选项里面告诉它

39:32.500 --> 39:33.500
从这两个位置

39:33.500 --> 39:35.500
去找我们的声明文件

39:35.500 --> 39:36.500
好

39:36.500 --> 39:37.500
那么写好了之后

39:37.500 --> 39:38.500
我们再来看

39:38.500 --> 39:39.500
再来看

39:40.500 --> 39:42.500
这个地方我们就放到这个

39:42.500 --> 39:43.500
Types里面

39:43.500 --> 39:44.500
放进来

39:45.500 --> 39:46.500
好 写好了之后

39:46.500 --> 39:47.500
我们再来看

39:48.500 --> 39:49.500
这边

39:52.450 --> 39:54.450
NPM装

39:55.450 --> 39:56.450
运行

39:58.450 --> 39:59.450
你看是不是出来了

39:59.450 --> 40:00.450
它就能找到了

40:00.450 --> 40:01.450
像遇到这些

40:01.450 --> 40:02.450
细致目结的问题

40:02.450 --> 40:03.450
大家要知道

40:03.450 --> 40:04.450
如何去解决

40:04.450 --> 40:05.450
首先你要找到

40:05.450 --> 40:06.450
问题发生的原因

40:07.450 --> 40:08.450
好 这里

40:09.450 --> 40:10.450
模块声明

40:10.450 --> 40:11.450
也就差不多了

40:11.450 --> 40:12.450
就是把它写到模块里边

40:12.450 --> 40:13.450
其实也没上了

40:14.450 --> 40:15.450
好

40:15.450 --> 40:16.450
然后下边

40:16.450 --> 40:17.450
我再介绍一个东西

40:17.450 --> 40:18.450
叫做

40:19.450 --> 40:21.450
叫做三斜线指令

40:21.450 --> 40:22.450
三斜线

40:25.450 --> 40:29.450
三斜线指令

40:30.450 --> 40:31.450
这个指令

40:31.450 --> 40:34.450
按照TS的官方文档的说明

40:35.450 --> 40:37.450
就它的作用的话

40:37.450 --> 40:38.450
目前来说吧

40:39.450 --> 40:41.450
可能也只剩下于

40:41.450 --> 40:42.450
去引

40:42.450 --> 40:43.450
再一个

40:44.450 --> 40:45.450
记一下吧

40:45.450 --> 40:46.450
在一个

40:47.450 --> 40:49.450
声明文件中

40:50.450 --> 40:52.450
包含另一个

40:52.450 --> 40:53.450
声明文件

40:54.450 --> 40:55.450
可能它的意义

40:55.450 --> 40:56.450
也就剩下这么一点点了

40:56.450 --> 40:58.450
其他都没有什么意义了

40:58.450 --> 41:00.450
以前用的还

41:00.450 --> 41:01.450
比较多

41:01.450 --> 41:03.450
因为以前在ES6模块

41:03.450 --> 41:04.450
画出来之前

41:04.450 --> 41:07.450
它是用来联合其他文件的

41:07.450 --> 41:10.450
但是现在ES6模块画出来之后

41:10.450 --> 41:11.450
这个指令

41:11.450 --> 41:13.450
好像也就剩下这么个用处了

41:13.450 --> 41:14.450
在一个声明文件中

41:14.450 --> 41:16.450
去包含另一个声明文件

41:16.450 --> 41:18.450
这里我举个例子吧

41:18.450 --> 41:19.450
就比方说

41:19.450 --> 41:22.450
这个声明文件

41:22.450 --> 41:24.450
可能这个声明文件的位置

41:24.450 --> 41:25.450
它不在这

41:25.450 --> 41:26.450
它可能不在这

41:26.450 --> 41:28.450
它可能跑到另外一个位置去了

41:28.450 --> 41:29.450
比方跑到根木路去了

41:31.450 --> 41:33.450
我们把它移动到根木路去

41:33.450 --> 41:35.450
过后你看这边

41:35.450 --> 41:38.450
由于它现在又出现这个问题了

41:38.450 --> 41:40.450
它找不到它的声明文件了

41:40.450 --> 41:41.450
因为它的声明文件

41:41.450 --> 41:43.450
它目前的找的地方是在这里

41:43.450 --> 41:45.450
在这个Types木路下边

41:45.450 --> 41:46.450
而现在

41:46.450 --> 41:48.450
这个文件跑到外边去了

41:48.450 --> 41:49.450
所以它找不到了

41:49.450 --> 41:50.450
那么这种情况下

41:50.450 --> 41:52.450
我们可以使用

41:52.450 --> 41:53.450
三线纸令

41:53.450 --> 41:54.450
比方说这个东西

41:54.450 --> 41:56.450
Global.d.gts

41:56.450 --> 41:57.450
这个声明文件

41:57.450 --> 41:59.450
是会被ts找到的

41:59.450 --> 42:00.450
对吧

42:00.450 --> 42:01.450
这个声明文件可以被找到

42:01.450 --> 42:03.450
那么我可以在这个声明文件中

42:03.450 --> 42:06.450
把另外一个声明文件包含进来

42:06.450 --> 42:08.450
就剩下这么一个作用了

42:08.450 --> 42:09.450
我们这里可以使用一个

42:09.450 --> 42:10.450
三线纸令

42:10.450 --> 42:12.450
就是

42:12.450 --> 42:14.450
三根鞋杠加上个空格

42:14.450 --> 42:16.450
注意要加上空格

42:16.450 --> 42:17.450
三根鞋杠

42:17.450 --> 42:19.450
后边写上

42:19.450 --> 42:22.450
写上reference

42:22.450 --> 42:23.450
reference

42:23.450 --> 42:27.450
然后再写上pass

42:27.450 --> 42:28.450
路径

42:28.450 --> 42:29.450
路径在哪呢

42:29.450 --> 42:31.450
然后包含的另一个声明文件的路径

42:31.450 --> 42:33.450
那么路径从当当前位置出发

42:33.450 --> 42:35.450
这里要写相对路径

42:35.450 --> 42:37.450
返回上一级木路

42:37.450 --> 42:39.450
就是src

42:39.450 --> 42:40.450
再返回上一级木路

42:40.450 --> 42:41.450
就是根木路

42:41.450 --> 42:46.450
根木路下边的index.d.ts

42:46.450 --> 42:47.450
写上这么个东西

42:47.450 --> 42:48.450
注意这个三线纸令

42:48.450 --> 42:50.450
前边不能有任何的代码

42:50.450 --> 42:52.450
不能有任何的声明

42:52.450 --> 42:53.450
前边只能是注释

42:53.450 --> 42:54.450
或者是

42:54.450 --> 42:56.450
其他的三线纸令

42:56.450 --> 42:57.450
好这样子

42:57.450 --> 42:58.450
你写了过后你看

42:58.450 --> 42:59.450
他又补报错了

42:59.450 --> 43:00.450
他又补报错了

43:00.450 --> 43:02.450
所以说这个三线纸令

43:02.450 --> 43:04.450
目前的意义已经不大了

43:04.450 --> 43:05.450
已经不大了

43:05.450 --> 43:06.450
就可能是有这么一个意义

43:06.450 --> 43:07.450
就是有的时候

43:07.450 --> 43:09.450
我一个声明文件被读到了

43:09.450 --> 43:10.450
但是另一些声明文件

43:10.450 --> 43:12.450
可能不会被读到

43:12.450 --> 43:14.450
那么我可以在被读到的声明文件里边

43:14.450 --> 43:16.450
把另一些声明文件的东西加进来

43:16.450 --> 43:18.450
加进来

43:18.450 --> 43:20.450
好了也就差不多了

43:20.450 --> 43:21.450
也就差不多了

43:21.450 --> 43:23.450
我们这一块的

43:24.450 --> 43:27.450
如何来编写

43:27.450 --> 43:29.450
如何来编写一个声明文件

43:29.450 --> 43:30.450
就讲到这儿

43:30.450 --> 43:32.450
讲的比较简单

43:32.450 --> 43:34.450
没有涉及到太复杂的东西

43:34.450 --> 43:37.450
因为我们平时编写声明文件

43:37.450 --> 43:39.450
情况本来就少

43:39.450 --> 43:40.450
很少很少

43:40.450 --> 43:41.450
像这个楼大写

43:41.450 --> 43:42.450
我们刚才编写了

43:42.450 --> 43:43.450
楼大写的声明文件

43:43.450 --> 43:45.450
我现在把你动回去

43:46.450 --> 43:48.450
编写了这个楼大写的声明文件

43:48.450 --> 43:50.450
实际上他本来就有

43:50.450 --> 43:52.450
也常见的哭的声明

43:52.450 --> 43:54.450
他本来就有

43:54.450 --> 43:56.450
这里就是一些常见的哭

43:56.450 --> 43:57.450
像这些楼大写的哭

43:57.450 --> 43:58.450
他本来就有他的声明文件

43:58.450 --> 44:00.450
比方说我们可以安装一下

44:00.450 --> 44:02.450
可以安装一下

44:02.450 --> 44:06.270
他的声明文件

44:06.270 --> 44:08.270
我们可以安装

44:08.270 --> 44:10.270
12add

44:10.270 --> 44:12.270
然后Types

44:12.270 --> 44:13.270
本来就有人给他做了

44:13.270 --> 44:14.270
很多声明文件了

44:14.270 --> 44:15.270
把他发不到

44:15.270 --> 44:17.270
发不到这个包里边去了

44:17.270 --> 44:19.270
楼大写

44:19.270 --> 44:21.270
你看他是有的

44:21.270 --> 44:22.270
安装好了之后

44:22.270 --> 44:24.270
本来就可以使用他的声明文件了

44:24.270 --> 44:26.270
我这里都没有必要去写这些内容

44:26.270 --> 44:27.270
没有必要去写

44:27.270 --> 44:28.270
他本来就有了

44:28.270 --> 44:30.270
所以说我们在这里

44:30.270 --> 44:31.270
楼大写里边

44:31.270 --> 44:33.270
他还有很多的其他函数

44:33.270 --> 44:35.270
还有很多的其他函数

44:35.270 --> 44:36.270
为什么还只有一个

44:36.270 --> 44:38.270
我们把我们自己的商家

44:38.270 --> 44:44.020
这里有问题

44:44.020 --> 44:50.910
刚才应该是智能提示

44:50.910 --> 44:52.910
没有提示出来

44:52.910 --> 44:53.910
没有反应过来

44:53.910 --> 44:54.910
没有加载

44:54.910 --> 44:55.910
没有把他那个

44:55.910 --> 44:57.910
就是声明文件加载出来

44:57.910 --> 44:59.910
那么现在有了

44:59.910 --> 45:00.910
创客啊

45:00.910 --> 45:01.910
这些函数都有了

45:01.910 --> 45:02.910
各种各样函数都有了

45:02.910 --> 45:05.910
也就是像常见的这些

45:05.910 --> 45:06.910
第三方库

45:06.910 --> 45:07.910
他本来就有声明文件了

45:07.910 --> 45:09.910
所以说我们平时写声明文件

45:09.910 --> 45:10.910
写的很少

45:10.910 --> 45:11.910
因此这一块东西

45:11.910 --> 45:12.910
我们了解一下

45:12.910 --> 45:13.910
作为了解

45:13.910 --> 45:14.910
作为一个知识扩展就行了

45:14.910 --> 45:15.910
好了

45:15.910 --> 45:17.910
我们讲好了编写的话

45:17.910 --> 45:18.910
那么最后就是发布了

45:18.910 --> 45:20.910
我们下节课来讲发布

45:20.910 --> 45:21.910
OK

45:21.910 --> 45:22.910
那么这里可能就到这里了

45:22.910 --> 45:23.910
拜拜

