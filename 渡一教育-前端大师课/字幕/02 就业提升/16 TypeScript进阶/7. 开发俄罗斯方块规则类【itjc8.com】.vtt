WEBVTT

00:00.620 --> 00:04.620
好 咱们这节课呢 继续来讲这个游戏

00:04.620 --> 00:08.620
在继续开发之前呢 我先说一个问题吧

00:08.620 --> 00:11.620
先这里说一个问题啊 我刚才发现这么一个问题

00:11.620 --> 00:14.620
呃 这个工程呢 比方说我现在已经运行出来了啊

00:14.620 --> 00:19.620
就是这个 Webpack啊 这个开发服务器我已经打开了

00:19.620 --> 00:24.620
打开之后呢 呃 我如果在这里新加入一个类型

00:24.620 --> 00:27.620
比方说啊 我在这里边随便 随便导出一个类型吧

00:27.620 --> 00:31.620
随便写个类型 就比方说Test吧

00:31.620 --> 00:36.620
比方说有这么一个类型啊 就该取个类型别名啊 取一个

00:36.620 --> 00:39.620
Stream 制服创的类型别名Test

00:39.620 --> 00:42.620
如果我新加入一个类型的话 他这里要爆错的啊

00:42.620 --> 00:45.620
就是在开发服务器的模式下面 他是要爆错的

00:45.620 --> 00:49.620
比方说我这里去使用这个类型 随便写个啊Test

00:49.620 --> 00:52.620
去使用这个类型 大家看一下啊

00:52.620 --> 00:55.620
这里没有爆错 但是呢 在开发服务器的环境里边

00:55.620 --> 00:59.620
他是要爆错的 他爆错的原因呢 他说编印失败

00:59.620 --> 01:04.620
就是在Test编印失败 编印失败了 他就阻止了他重新刷新页面

01:04.620 --> 01:07.620
呃 这是怎么回事呢 这个原因很复杂啊

01:07.620 --> 01:11.620
我们在 Webpack里边 讲 Webpack的时候 会继续详细的说

01:11.620 --> 01:14.620
他跟这个 就是这个

01:14.620 --> 01:17.620
哎 跑哪去了呢 就这个插件

01:17.620 --> 01:20.620
就这个插件啊 不是这个插件啊 这里

01:20.620 --> 01:24.620
跟这个插件有关系 跟这个开发服务器的插件有关系

01:24.620 --> 01:28.620
跟他的编印方式有关系 就是说 如果我新加入类型的话

01:28.620 --> 01:32.620
他是得不到编印的 得不到编印的 呃 编印会失败

01:32.620 --> 01:36.620
那么这个时候怎么处理呢 其实这个Test Loader

01:36.620 --> 01:40.620
就是咱们之前安装那个夹载器 就这个夹载器

01:40.620 --> 01:43.620
对 就这个夹载器 安装这个夹载器的时候

01:43.620 --> 01:47.620
他也说到了这个问题啊 我们来看一下这个问题在哪

01:47.620 --> 01:50.620
在这个地方 Webpack 我们收一下吧

01:51.620 --> 01:54.620
对 这他说到这个问题 他说

01:54.620 --> 01:57.620
如果你想把这个Test Loader

01:57.620 --> 02:01.620
跟这个 Webpack Dev Server这个插件啊 这是个热更新的插件

02:01.620 --> 02:05.620
呃 跟他进行联用的话 你需要做这么一件事

02:05.620 --> 02:08.620
就是你要去配置一下这个Test Loader 它的

02:08.620 --> 02:12.620
其中一个配置 这个配置呢叫做Trespile Only

02:12.620 --> 02:16.620
表示的是快速转换 表示快速转换的意思

02:16.620 --> 02:19.620
呃 要把它设置为 True 才能够去

02:19.620 --> 02:22.620
跟这个 Webpack Dev Server来进行联用

02:22.620 --> 02:25.620
那么我们就按照他的这种方式啊 我这里就不展开了

02:25.620 --> 02:29.620
我们以后再讲那个 Webpack的时候 讲到这个东西

02:29.620 --> 02:32.620
讲到这个东西的时候再详细说 好吗

02:32.620 --> 02:35.620
我这里就按照他的方式呢 直接配置一下就行了啊

02:35.620 --> 02:37.620
就在这个位置 我使用Use

02:37.620 --> 02:40.620
呃 因为我如果直接使用Loader的话

02:40.620 --> 02:43.620
那么只能配置夹载器 我使用Use的话

02:43.620 --> 02:45.620
Use的配置呢 他是一个对象

02:46.620 --> 02:48.620
这个对象里边 他不仅能配置夹载器

02:48.620 --> 02:51.620
把它配置为Test Loader 还能够 还能够呢

02:51.620 --> 02:55.620
给这个夹载器呢 设置一些额外的配置项

02:55.620 --> 02:58.620
Options 给它设置一下额外的配置项

02:58.620 --> 03:01.620
呃 然后呢 这边我们就写上这个配置

03:01.620 --> 03:04.620
就这个配置啊 Trespile Only

03:04.620 --> 03:07.620
嗯 再复制一下啊

03:07.620 --> 03:09.620
Trespile 这里复制一下

03:09.620 --> 03:11.620
Trespile Only 把它设置为 True

03:12.620 --> 03:15.620
好 配置好了之后呢 咱们再来停止服务器

03:15.620 --> 03:18.620
停止这个开发服务器 清楚一下

03:18.620 --> 03:20.620
然后呢 我们再重新运行

03:20.620 --> 03:23.620
我们再来试一下啊 我把这个删掉

03:23.620 --> 03:26.620
这个删掉 然后这边呢 也该删掉

03:26.620 --> 03:28.620
删掉 我们再来试一下

03:28.620 --> 03:31.620
当我们新加入内容过后呢 会不会爆错

03:31.620 --> 03:35.770
运行出来 诶 诶 怎么回事

03:35.770 --> 03:38.770
我写错了嘛 哪个地方写错了啊

03:38.770 --> 03:41.770
呃 我说 他说我这个地方配置有问题啊

03:41.770 --> 03:44.770
写错了 又是Node Option 是写错了

03:44.770 --> 03:45.770
啊 Option 是

03:45.770 --> 03:48.770
好 保存一下啊 重新来 运行

03:48.770 --> 03:53.850
好 运行出来了 再来看一下啊

03:53.850 --> 03:57.850
呃 现在呢 我们跟之前一样来操作一次啊

03:57.850 --> 03:59.850
来操作一次 看他有没有爆错

03:59.850 --> 04:03.850
呃 我们这里呢 还是在这里新加入 加入一个内容

04:03.850 --> 04:06.850
然后在英这个社里边呢 把这个内容用起来

04:06.850 --> 04:08.850
新加入内容过后呢 我们保存一下

04:08.850 --> 04:10.850
感谢他现在不爆错了啊 现在不爆错了

04:10.850 --> 04:13.850
我们就把这个配置加上啊 这是我

04:13.850 --> 04:16.850
之前做这个配置的时候 呃 忘记了这个点

04:16.850 --> 04:19.850
我这里把它补充一下啊 把它补充一下

04:19.850 --> 04:23.850
ok 那么接下来 进入咱们这期课的正题

04:23.850 --> 04:27.850
来 继续来呗 咱们这期课要做啥呢

04:27.850 --> 04:30.850
首先说 本节课的东西有点复杂

04:30.850 --> 04:33.850
大家要有心理准备啊 但是我们不要怕他

04:33.850 --> 04:36.850
慢慢来吧啊 我们集中精力

04:36.850 --> 04:38.850
来解决这样的问题

04:38.850 --> 04:41.850
本节课要做啥呢 要做一些逻辑判断

04:43.850 --> 04:45.850
咱们的俄罗斯方块里边呢

04:45.850 --> 04:48.850
我们现在已经能够把方块做出来了

04:48.850 --> 04:50.850
并且能够控制方块的移动

04:50.850 --> 04:53.850
我们都是测试过的 对吧 能够控制方块的移动

04:53.850 --> 04:55.850
但是呢 方块的移动

04:56.850 --> 04:57.850
他是有规则的

04:58.850 --> 04:59.850
然后这里

04:59.850 --> 05:02.850
我向右移动啊 向下移动 向左移动

05:02.850 --> 05:05.850
要跑出去了 这合理吗 肯定不合理

05:05.850 --> 05:08.850
对不对 怎么能跑出去了 不能跑出去的

05:08.850 --> 05:11.850
然后向上移动 当然我们不太会向上移动

05:11.850 --> 05:12.850
向下一动

05:12.850 --> 05:14.850
他也会跑出去

05:14.850 --> 05:15.850
也会跑出去

05:15.850 --> 05:17.850
这个就不太合理了

05:17.850 --> 05:18.850
这就不太合理了

05:18.850 --> 05:20.850
向右移动也是一样

05:20.850 --> 05:21.850
他会跑出去

05:22.850 --> 05:25.850
那么在这里面呢 肯定会涉及到一个问题就是

05:25.850 --> 05:29.850
我每次移动的时候 到底能不能移动

05:29.850 --> 05:31.850
他会是涉及到这么一个问题

05:31.850 --> 05:33.850
那么当然了 这里有这个些问题

05:33.850 --> 05:35.850
里面还包含了很多很多了

05:35.850 --> 05:38.850
比方说方块旋转 我应该怎么去旋转

05:38.850 --> 05:41.850
这些都是跟数学相关的运算

05:41.850 --> 05:43.850
但是这些数学运算呢 我保证啊

05:43.850 --> 05:45.850
一定不超过小学水平

05:45.850 --> 05:48.850
一定是小学范围内的数学运算 就加建成熟

05:48.850 --> 05:52.850
只不过呢 只不过啥呢 就是这里面需要一些逻辑

05:52.850 --> 05:54.850
需要一些逻辑思维

05:54.850 --> 05:57.850
比方说旋转 比方说移动 他可能都会经过判断

05:57.850 --> 05:59.850
如果没有任何规则限制的话

05:59.850 --> 06:01.850
这个游戏也没什么玩的 对吧

06:01.850 --> 06:03.850
你就看这个方块跑来跑去啥玩的呢

06:03.850 --> 06:05.850
他肯定有一些规则的限制

06:05.850 --> 06:09.850
那么这节课呢 我们就要搞定规则的问题

06:09.850 --> 06:12.850
规则的问题 就是无论他是移动也好

06:12.850 --> 06:16.850
还是旋转也好 那么要搞定规则的问题

06:16.850 --> 06:19.850
因此呢 我们这几个开发的是

06:19.850 --> 06:24.850
俄罗斯方块的规则类 规则类

06:24.850 --> 06:27.850
我们要按照游戏里面的逻辑

06:27.850 --> 06:30.850
按照游戏规则来对他的移动也好

06:30.850 --> 06:35.850
对他的就是旋转也好 进行控制

06:35.850 --> 06:39.850
ok 那么这里呢 我们还是去新建这么一个文件

06:39.850 --> 06:43.850
这么一个文件 这个文件呢 我们给他取名为

06:43.850 --> 06:49.850
比方说啊 取名为Theras Ru

06:49.850 --> 06:53.850
俄罗斯方块的规则TS

06:53.850 --> 06:55.850
我们通过这个规则呢

06:55.850 --> 06:59.850
来控制 来控制每一个方块的移动

06:59.850 --> 07:02.850
好 也就是说这个内容我其实要做啥呢

07:02.850 --> 07:04.850
就是我先导说一个内在说

07:04.850 --> 07:08.850
Class Teras Ru

07:08.850 --> 07:14.850
好 这个内里面呢 要提供一系列的函数

07:14.850 --> 07:19.850
该内中提供一系列的函数

07:19.850 --> 07:27.850
以判断根据游戏规则

07:27.850 --> 07:30.850
判断各种情况

07:30.850 --> 07:32.850
好 这个内里面要做这么一些事

07:32.850 --> 07:34.850
因此呢 这个内里面我可以想到

07:34.850 --> 07:37.850
它只有函数 它几乎是没有什么属性的

07:37.850 --> 07:40.850
只有函数 这些函数呢 全是一些帮助函数

07:40.850 --> 07:43.850
其实呢 这一块我们甚至可以不用写类

07:43.850 --> 07:45.850
就导出一个一个的函数就完事了

07:45.850 --> 07:47.850
但是呢 我想啊 这里

07:47.850 --> 07:50.850
由于我们这个系统里边也没有什么地方

07:50.850 --> 07:52.850
能用到像这种情况了

07:52.850 --> 07:54.850
所以说我这里还是 既然咱们学一遍

07:54.850 --> 07:55.850
还是把它讲一讲

07:55.850 --> 07:58.850
就是这里的函数呢 我想把它做成净态函数

07:58.850 --> 08:01.850
就是净态的 直接通过它来调用的

08:01.850 --> 08:03.850
我们这里可以这样子写

08:03.850 --> 08:05.850
Static一个一个的函数

08:05.850 --> 08:06.850
每个地方都是个函数

08:06.850 --> 08:07.850
这个函数呢 比方说

08:07.850 --> 08:11.850
我们这里呢 首先有意想到的是一个函数叫做

08:15.850 --> 08:17.850
是否可以移动

08:17.850 --> 08:20.850
是否可以移动这么一个函数

08:20.850 --> 08:22.850
好 其实这个函数里边呢

08:22.850 --> 08:24.850
这个函数里边 我们判断啥呢

08:24.850 --> 08:26.850
判断的是 就是一个俄罗斯方块

08:26.850 --> 08:28.850
你告诉我 一个俄罗斯方块

08:28.850 --> 08:31.850
然后呢 你想把它移动到目标位置

08:31.850 --> 08:35.850
我看一下 能不能 它能不能到目标位置

08:35.850 --> 08:37.850
它能不能跑到目标位置去

08:37.850 --> 08:38.850
就做这么一件事

08:38.850 --> 08:40.850
也就是说 这个函数 它反悔啥呢

08:40.850 --> 08:41.850
反悔的就是一个步儿

08:41.850 --> 08:43.850
能移动 或不能移动

08:43.850 --> 08:44.850
就这么简单

08:44.850 --> 08:47.850
因此这个函数 我不需要去创建它的对象

08:47.850 --> 08:49.850
我只需要去这样调用

08:50.850 --> 08:52.850
然后这里面呢

08:52.850 --> 08:54.850
这个函数爆错了 是吧

08:54.850 --> 08:56.850
爆错了 是因为这里

08:56.850 --> 08:58.850
你看 哪里爆错啊

08:58.850 --> 09:02.850
方形 隐私包含 类型 引力

09:02.850 --> 09:05.850
是因为这里 这里还有写完

09:05.850 --> 09:07.850
这里先写个引力吧

09:07.850 --> 09:09.850
先让它不爆错 先让它不爆错

09:09.850 --> 09:10.850
这里

09:15.250 --> 09:17.250
不应该是方可形 对吧

09:17.250 --> 09:18.250
不应该是方可形

09:18.250 --> 09:20.250
函数 应该这样写

09:20.250 --> 09:22.250
好了 那么我到时候

09:22.250 --> 09:23.250
调用这个函数的时候呢

09:23.250 --> 09:25.250
使用開M5来进行判断

09:25.250 --> 09:26.250
来进行判断

09:26.250 --> 09:27.250
一个俄罗斯方块

09:27.250 --> 09:29.250
到底能不能移动到目标位置

09:29.250 --> 09:31.250
到底能不能移动

09:31.250 --> 09:33.250
我们通过这种方式来判断

09:33.250 --> 09:35.250
OK 那么这个函数里边

09:35.250 --> 09:37.250
这个函数里边

09:37.250 --> 09:39.250
我们要哪些参数呢

09:39.250 --> 09:41.250
比方说 我们就写这个函数

09:41.250 --> 09:42.250
这个函数来做啥

09:42.250 --> 09:44.250
这个函数用来判断

09:44.250 --> 09:49.250
判断某个形状的方块

09:49.250 --> 09:54.250
是否能够移动到目标位置

09:54.250 --> 09:56.250
因此你这个函数

09:56.250 --> 09:58.250
你需要告诉我哪些东西

09:58.250 --> 09:59.250
我才能判断了

09:59.250 --> 10:02.250
首先你要告诉我形状 对不对

10:02.250 --> 10:03.250
你这个方块是啥形状

10:03.250 --> 10:04.250
你得告诉我

10:04.250 --> 10:06.250
因此它第一个函数

10:06.250 --> 10:07.250
shape

10:07.250 --> 10:08.250
是形状

10:08.250 --> 10:09.250
类型是什么呢

10:09.250 --> 10:10.250
我们之前写的类型

10:10.250 --> 10:11.250
shape

10:11.250 --> 10:13.250
你要告诉我一个形状

10:13.250 --> 10:15.250
然后告诉我这个形状过后呢

10:15.250 --> 10:18.250
你还要告诉我这个形状

10:18.250 --> 10:19.250
然后呢

10:19.250 --> 10:20.250
你还要告诉我啥呢

10:20.250 --> 10:22.250
还要告诉我目标位置

10:22.250 --> 10:23.250
目标位置在哪

10:23.250 --> 10:25.250
目标位置呢就是个坐标

10:25.250 --> 10:30.250
target point

10:30.250 --> 10:32.250
你告诉我这两个东西

10:32.250 --> 10:33.250
你告诉我形状

10:33.250 --> 10:35.250
告诉我这个形状能不能

10:35.250 --> 10:37.250
你想把它放到哪个目标位置

10:37.250 --> 10:40.250
我判断一下能不能到那边去

10:40.250 --> 10:41.250
我就做这么一件事

10:41.250 --> 10:43.250
判断某个形状的方块

10:43.250 --> 10:45.250
是否能够移动到目标位置

10:45.250 --> 10:46.250
就这个类里边

10:46.250 --> 10:47.250
它提供了一系列的函数

10:47.250 --> 10:50.250
能做各种各样的规则的判断

10:50.250 --> 10:52.250
好 那么这个时候呢

10:52.250 --> 10:53.250
怎么来做呢

10:53.250 --> 10:55.250
首先我们想到这里面

10:55.250 --> 10:56.250
肯定有约束

10:56.250 --> 10:58.250
最容易想到的约束是啥

10:58.250 --> 11:00.250
最容易想到的约束的话

11:00.250 --> 11:02.250
它就是不能超过边界

11:02.250 --> 11:03.250
对不对

11:03.250 --> 11:04.250
这个是最容易想到的

11:04.250 --> 11:05.250
这一块

11:05.250 --> 11:06.250
你不能跑到边界外面去了

11:06.250 --> 11:08.250
像优宜东一样

11:08.250 --> 11:10.250
你不能跑到边界外面去了

11:10.250 --> 11:12.250
像上 像下

11:12.250 --> 11:13.250
都是一样

11:13.250 --> 11:15.250
你不能到边界外表去

11:15.250 --> 11:16.250
因此呢

11:16.250 --> 11:17.250
这里呢

11:17.250 --> 11:18.250
KM

11:18.250 --> 11:19.250
这里最重要的一个点

11:19.250 --> 11:22.250
就是边界判断

11:22.250 --> 11:23.250
好

11:23.250 --> 11:25.250
要判断边界

11:25.250 --> 11:28.250
那你首先得知道

11:28.250 --> 11:29.250
有多

11:29.250 --> 11:30.250
整个边界有多宽

11:30.250 --> 11:31.250
多高

11:31.250 --> 11:32.250
对不对

11:32.250 --> 11:33.250
你首先要知道这个点

11:33.250 --> 11:34.250
好

11:34.250 --> 11:35.250
怎么知道

11:35.250 --> 11:36.250
一个边界的宽高呢

11:36.250 --> 11:38.250
问题是

11:38.250 --> 11:39.250
好 有时候

11:39.250 --> 11:40.250
马上就开始想了

11:40.250 --> 11:41.250
我是不是应该获取

11:41.250 --> 11:42.250
这个动物对象

11:42.250 --> 11:44.250
获取这个动物对象的宽高

11:44.250 --> 11:45.250
不对

11:45.250 --> 11:46.250
不对

11:46.250 --> 11:47.250
因为你现在开发的是

11:47.250 --> 11:48.250
这个核心模块

11:48.250 --> 11:49.250
这个模块

11:49.250 --> 11:51.250
它是跟数据相关的

11:51.250 --> 11:53.250
跟界面没有任何关系

11:53.250 --> 11:54.250
你只需要告诉我

11:54.250 --> 11:56.250
门关里是什么界面

11:56.250 --> 11:57.250
无所谓

11:57.250 --> 11:58.250
你只要告诉我

11:58.250 --> 12:00.250
宽度有多少个格子

12:00.250 --> 12:02.250
我们的逻辑桌标有多少个

12:02.250 --> 12:03.250
几成一级的格子

12:03.250 --> 12:05.250
就像下起这样子

12:05.250 --> 12:06.250
像国际相起的样子

12:06.250 --> 12:08.250
几成一级的格子

12:08.250 --> 12:10.250
那么你告诉我这个宽高就行了

12:10.250 --> 12:12.250
因此呢

12:12.250 --> 12:15.250
我这里的宽高呢

12:15.250 --> 12:16.250
打算做一个配置

12:16.250 --> 12:18.250
做成一个配置文件

12:18.250 --> 12:19.250
当然这个配置

12:19.250 --> 12:21.250
你可以直接写到这个文件里面

12:21.250 --> 12:22.250
来写这么一个配置

12:22.250 --> 12:24.250
告诉我这个整个游戏的宽高

12:24.250 --> 12:25.250
那么我相信

12:25.250 --> 12:26.250
我相信这个宽高

12:26.250 --> 12:28.250
是有些地方还会用到

12:28.250 --> 12:29.250
因此我这里

12:29.250 --> 12:30.250
专门去建一个文件

12:30.250 --> 12:32.250
来写这么一个配置

12:32.250 --> 12:35.250
配置整个面板的宽高

12:35.250 --> 12:37.250
我们写这么一个文件

12:39.250 --> 12:40.250
游戏配置

12:40.250 --> 12:42.250
我这里就直接导出一个对象

12:42.250 --> 12:44.250
直接导出一个对象

12:44.250 --> 12:47.250
这个对象里面的宽度

12:47.250 --> 12:49.250
游戏的尺寸

12:49.250 --> 12:50.250
面板尺寸

12:50.250 --> 12:51.250
panel size

12:51.250 --> 12:53.250
面板尺寸

12:53.250 --> 12:55.250
有个宽度

12:55.250 --> 12:56.250
宽度也都宽呢

12:56.250 --> 12:57.250
比方说

12:57.250 --> 12:58.250
就举个例子吧

12:58.250 --> 13:00.250
比方说我看这里

13:00.250 --> 13:02.250
就随便举个例子

13:02.250 --> 13:03.250
就随便举个例子

13:03.250 --> 13:05.250
比方说宽度为10个格子

13:05.250 --> 13:07.250
就10个格子吧

13:07.250 --> 13:08.250
10个格子

13:08.250 --> 13:10.250
或者是20个格子

13:10.250 --> 13:12.250
高度呢

13:12.250 --> 13:14.250
10个格子吧

13:14.250 --> 13:16.250
高度也为10个格子

13:16.250 --> 13:18.250
假设我们先随便配置

13:18.250 --> 13:20.250
以后我可以改

13:20.250 --> 13:24.250
我把宽高都配置为10个格子

13:24.250 --> 13:26.250
好那么这边呢

13:26.250 --> 13:27.250
我们就可以得到

13:27.250 --> 13:30.250
整个面板的宽高是多少

13:30.250 --> 13:32.250
也就是说

13:32.250 --> 13:34.250
我一会儿呢

13:34.250 --> 13:35.250
在判断范围的时候

13:35.250 --> 13:37.250
有没有超出边界的时候

13:37.250 --> 13:39.250
判断的标准是啥

13:39.250 --> 13:41.250
判断的标准就是这两个字

13:41.250 --> 13:43.250
好那么咱们接下来想

13:43.250 --> 13:45.250
边界我们能确定的

13:45.250 --> 13:47.250
我怎么来判断

13:47.250 --> 13:50.250
是否超过边界呢

13:50.250 --> 13:52.250
怎么来判断是否超过边界

13:52.250 --> 13:54.250
那么大家看一下

13:54.250 --> 13:55.250
这个历史里边

13:55.250 --> 13:57.250
我们向左移动

13:57.250 --> 13:59.250
好到了这

13:59.250 --> 14:01.250
没有超过边界对吧

14:01.250 --> 14:02.250
没有超过边界

14:02.250 --> 14:03.250
我们再刷新一次

14:03.250 --> 14:04.250
换个颜色

14:04.250 --> 14:05.250
我们全是白色

14:05.250 --> 14:07.250
不可怎么全是白色

14:07.250 --> 14:09.250
再换个形状

14:09.250 --> 14:10.250
就它吧

14:10.250 --> 14:11.250
我们往左边移动

14:11.250 --> 14:12.250
你看一下

14:12.250 --> 14:14.250
现在有没有超过边界

14:14.250 --> 14:15.250
是没有

14:15.250 --> 14:17.250
好那么现在再往左移动

14:17.250 --> 14:19.250
是不是超过边界了

14:19.250 --> 14:21.250
那么什么叫超过边界

14:21.250 --> 14:24.250
什么叫做超过边界

14:24.250 --> 14:26.250
啥意思呢

14:26.250 --> 14:28.250
超过边界的意思是啥

14:28.250 --> 14:30.250
超过边界的意思

14:30.250 --> 14:32.250
就是指的是

14:32.250 --> 14:35.250
我们这个方块里边的

14:35.250 --> 14:37.250
是不是能够保证

14:37.250 --> 14:39.250
是不是至少有一个方块

14:39.250 --> 14:42.250
至少有一个方块的

14:42.250 --> 14:44.250
坐标

14:44.250 --> 14:47.250
至少有一个方块的坐标

14:47.250 --> 14:49.250
不在这个正常的范围之内

14:49.250 --> 14:51.250
能理解这个意思吧

14:51.250 --> 14:53.250
至少有一个方块的坐标

14:53.250 --> 14:55.250
不在这个范

14:55.250 --> 14:56.250
这个正常范围之内

14:56.250 --> 14:58.250
这就是超过边界

14:58.250 --> 14:59.250
好想到这的话

14:59.250 --> 15:00.250
你会发现

15:00.250 --> 15:01.250
我们需要得到什么数据

15:01.250 --> 15:04.250
需要得到每一个方块的坐标

15:04.250 --> 15:06.250
这里我们需要得到

15:06.250 --> 15:08.250
每一个方块的坐标

15:08.250 --> 15:11.250
好那么现在呢

15:11.250 --> 15:14.250
这是我们的目标点坐标

15:14.250 --> 15:15.250
什么叫目标位置

15:15.250 --> 15:17.250
这是一个方块的形状

15:17.250 --> 15:19.250
目标位置指的是

15:19.250 --> 15:21.250
中心点的目标位置

15:21.250 --> 15:22.250
如果这个方块跑到

15:22.250 --> 15:23.250
这个中心点过后

15:23.250 --> 15:26.250
那么它每一个小方块

15:26.250 --> 15:27.250
它的坐标是多少

15:27.250 --> 15:29.250
能明白这个意思吗

15:29.250 --> 15:30.250
就比方说

15:30.250 --> 15:31.250
我刚刚告诉你的

15:31.250 --> 15:32.250
形状我们是什么

15:32.250 --> 15:33.250
我们再说一次形状

15:33.250 --> 15:35.250
形状指的是

15:35.250 --> 15:38.250
假设中心点的坐标为0和0

15:38.250 --> 15:40.250
那么它的形状

15:40.250 --> 15:42.250
其他的方块

15:42.250 --> 15:43.250
它的坐标应该是多少

15:43.250 --> 15:44.250
这叫形状

15:44.250 --> 15:45.250
那么第二个参数是

15:45.250 --> 15:46.250
啥意思呢

15:46.250 --> 15:47.250
第二个参数是

15:47.250 --> 15:49.250
我如果把中心点

15:49.250 --> 15:51.250
放到这个坐标位置

15:51.250 --> 15:53.250
那么它有没有超过边界

15:53.250 --> 15:54.250
就这么个意思

15:54.250 --> 15:56.250
如果我把这个形状的中心点

15:56.250 --> 15:57.250
放到这个位置

15:57.250 --> 15:59.250
那么它有没有超过边界

16:00.250 --> 16:02.250
那么边界判断的话

16:02.250 --> 16:03.250
我们其实要判断啥呢

16:03.250 --> 16:07.250
首先我要先假设

16:07.250 --> 16:13.250
假设已经移动到中心点

16:13.250 --> 16:17.250
中心点已经移动到了

16:17.250 --> 16:20.250
目标位置

16:20.250 --> 16:21.250
就是这个形状的中心点

16:21.250 --> 16:23.250
引到了这个位置

16:23.250 --> 16:25.250
那么经过这个假设

16:25.250 --> 16:31.250
算出每个小方块的坐标

16:31.250 --> 16:33.250
算出每个小方块的坐标

16:33.250 --> 16:35.250
就是我假设把这个形状

16:35.250 --> 16:36.250
已经放到这个位置的

16:36.250 --> 16:38.250
那么每个形状的坐标是多少

16:38.250 --> 16:40.250
我们要把它算出来

16:40.250 --> 16:42.250
那么也就是说

16:42.250 --> 16:44.250
这里我们要得到啥呢

16:44.250 --> 16:50.070
得到一个point的数组

16:50.070 --> 16:51.070
target

16:51.070 --> 16:52.070
应该定个变量吧

16:52.070 --> 16:53.070
这里

16:53.070 --> 16:55.070
假设已经过去了

16:55.070 --> 16:58.070
target

16:58.070 --> 17:01.070
square

17:01.070 --> 17:02.070
point

17:02.070 --> 17:04.070
就是假设已经过去了

17:04.070 --> 17:06.070
那么我们假设过去了过后呢

17:06.070 --> 17:08.070
每一个小方块它的坐标是多少

17:08.070 --> 17:09.070
我们这里把它算出来

17:09.070 --> 17:11.070
那么这个什么内形呢

17:11.070 --> 17:13.070
每一个小方块的坐标

17:13.070 --> 17:15.070
那是不是个坐标的数组

17:15.070 --> 17:16.070
对不对

17:16.070 --> 17:17.070
好

17:17.070 --> 17:19.070
怎么来算呢这里

17:19.070 --> 17:21.070
怎么来算

17:21.070 --> 17:22.070
怎么来算

17:22.070 --> 17:24.070
这是我们的形状

17:24.070 --> 17:25.070
这是我们的目标中心点

17:25.070 --> 17:26.070
那我们现在就假设

17:26.070 --> 17:28.070
就到了这个中心点

17:28.070 --> 17:30.070
就到了这个中心点

17:30.070 --> 17:32.070
那么每一个形状的坐标是多少

17:32.070 --> 17:33.070
是不是可以算啊这个地方

17:33.070 --> 17:34.070
可以算

17:34.070 --> 17:35.070
跟之前的算法是一样的

17:35.070 --> 17:36.070
是可以算的

17:36.070 --> 17:37.070
这是个形状

17:37.070 --> 17:38.070
形状是一个什么

17:38.070 --> 17:40.070
就是坐标的数组对不对

17:40.070 --> 17:42.070
就是坐标的数组

17:42.070 --> 17:44.070
我们这里使用map

17:44.070 --> 17:45.070
硬设

17:45.070 --> 17:46.070
这里的算法有很多

17:46.070 --> 17:48.070
我这里使用最简单的算法

17:48.070 --> 17:49.070
map来硬设

17:49.070 --> 17:51.070
每一个形状里边

17:51.070 --> 17:53.070
每一个形状里边

17:53.070 --> 17:54.070
首先搞清楚

17:54.070 --> 17:55.070
你一定要理解形状

17:55.070 --> 17:57.070
它到底是啥

17:57.070 --> 17:59.070
形状指的是一个坐标的数组

17:59.070 --> 18:00.070
表示中心点

18:00.070 --> 18:01.070
假设中心点为0

18:01.070 --> 18:03.070
那么每一个

18:03.070 --> 18:04.070
每一个小块

18:04.070 --> 18:06.070
它的相对坐标

18:06.070 --> 18:07.070
如果把中心点

18:07.070 --> 18:08.070
放到这个位置

18:08.070 --> 18:09.070
那么每一个小块的中心点

18:09.070 --> 18:10.070
那坐标是不是变了

18:10.070 --> 18:11.070
对不对

18:11.070 --> 18:12.070
是不是变了

18:12.070 --> 18:13.070
变了

18:13.070 --> 18:14.070
变成什么值了

18:14.070 --> 18:16.070
x的值等于多少

18:16.070 --> 18:17.070
x的值等于

18:17.070 --> 18:19.070
当前这个形状

18:19.070 --> 18:21.070
如果中心点为0的时候

18:21.070 --> 18:22.070
它的x值

18:22.070 --> 18:25.070
加上中心点

18:25.070 --> 18:26.070
坐标的x

18:26.070 --> 18:27.070
然后y呢

18:27.070 --> 18:29.070
等于

18:29.070 --> 18:31.070
target point

18:31.070 --> 18:33.070
我们得到这么一个数组

18:33.070 --> 18:34.070
就是假设

18:34.070 --> 18:36.070
已经到了中心点

18:36.070 --> 18:37.070
已经到了这儿

18:37.070 --> 18:38.070
那么每一个形状

18:38.070 --> 18:39.070
形状里面

18:39.070 --> 18:40.070
每一个小块的坐标

18:40.070 --> 18:42.070
我们先把这个东西算出来

18:42.070 --> 18:44.070
这个代码一定要理解

18:44.070 --> 18:45.070
你反复看

18:45.070 --> 18:46.070
你首先要搞清楚

18:46.070 --> 18:48.070
我们在做的是啥

18:48.070 --> 18:50.070
这个形状我再说一遍

18:50.070 --> 18:52.070
这个形状指的是

18:52.070 --> 18:55.070
假设中心点的坐标为0

18:55.070 --> 18:56.070
你看我们之前

18:56.070 --> 18:57.070
做过很多形状

18:57.070 --> 18:59.070
都是假设中心点的坐标为0

18:59.070 --> 19:01.070
那么其他点的坐标是多少

19:01.070 --> 19:03.070
这叫做形状

19:03.070 --> 19:04.070
那么假设现在

19:04.070 --> 19:05.070
中心点已经跑到

19:05.070 --> 19:06.070
目标位置去了

19:06.070 --> 19:07.070
我们要把

19:07.070 --> 19:09.070
每一个小块的坐标算出来

19:09.070 --> 19:11.070
你看是不是这样子算了

19:11.070 --> 19:12.070
一定是这样子算的

19:12.070 --> 19:14.070
我们先把这个东西算出来

19:14.070 --> 19:15.070
那么也就是说

19:15.070 --> 19:16.070
现在的边界判断

19:16.070 --> 19:18.070
判断的是啥呢

19:18.070 --> 19:20.070
判断的是不是就是这个玩意

19:20.070 --> 19:22.070
判断的是它里边

19:22.070 --> 19:24.070
是不是每一个坐标

19:24.070 --> 19:26.070
都在正常范围之内

19:26.070 --> 19:28.070
判断的就是这个东西

19:28.070 --> 19:29.070
每一个坐标

19:29.070 --> 19:31.070
是不是都在正常范围之内

19:31.070 --> 19:33.070
有没有坐标跑出去了

19:33.070 --> 19:35.070
判断的就是这个玩意

19:35.070 --> 19:37.070
边界判断我们判断啥呢

19:37.070 --> 19:38.070
其实我们使用

19:38.070 --> 19:39.070
数组里面的方法

19:39.070 --> 19:41.070
就可以搞定了

19:41.070 --> 19:42.070
边界判断

19:42.070 --> 19:44.070
target square point

19:44.070 --> 19:46.070
数组里面也不是一个方法吗

19:46.070 --> 19:48.070
叫做上

19:48.070 --> 19:50.070
这个方法是什么意思

19:50.070 --> 19:54.070
表示是否有东西

19:54.070 --> 19:56.070
满足条件

19:56.070 --> 19:57.070
这个数组里面

19:57.070 --> 19:59.070
是否有其中一项满足条件

19:59.070 --> 20:02.070
那么我这里的条件写啥呢

20:02.070 --> 20:04.070
条件写啥呢

20:04.070 --> 20:06.070
条件就是看的是

20:06.070 --> 20:10.070
是否超出了边界

20:10.070 --> 20:12.070
是否超出了边界

20:12.070 --> 20:15.070
如果你超出了边界

20:16.070 --> 20:18.070
如果返回处

20:19.070 --> 20:21.070
如果返回处是不是超出了边界

20:21.070 --> 20:23.070
这里至少有一项超出了边界

20:23.070 --> 20:24.070
那么就返回什么force

20:24.070 --> 20:26.070
你不能移动到这个位置

20:26.070 --> 20:28.070
有任何一项超出的边界都不行

20:28.070 --> 20:29.070
你就不能移动了

20:29.070 --> 20:30.070
那么如果

20:30.070 --> 20:32.070
当然你出了这个判断

20:32.070 --> 20:34.070
你就是返回处

20:34.070 --> 20:35.070
懂这个意思吗

20:35.070 --> 20:36.070
所以我们只要在这里

20:36.070 --> 20:38.070
判断是否超出了边界就行了

20:38.070 --> 20:39.070
就这个小坐标

20:39.070 --> 20:40.070
他有没有超出边界

20:40.070 --> 20:42.070
那么问题就简单了

20:42.070 --> 20:43.070
怎么来判断呢

20:43.070 --> 20:44.070
他有没有超出边界呢

20:44.070 --> 20:46.070
判断一下

20:46.070 --> 20:47.070
这个代码他牵套太深了

20:47.070 --> 20:48.070
大家看着有点晕

20:48.070 --> 20:50.070
那么我们先写出来

20:50.070 --> 20:52.070
就先写出来

20:52.070 --> 20:54.070
这里边界判断

20:54.070 --> 20:56.070
这里盯个边量吧

20:56.070 --> 20:58.070
判断的结果

20:58.070 --> 21:00.070
看是否有一个东西

21:00.070 --> 21:01.070
已经超出了坐标

21:01.070 --> 21:02.070
这个数组里边

21:02.070 --> 21:04.070
是否有东西超出了坐标

21:04.070 --> 21:06.070
如果有东西超出了坐标的话

21:06.070 --> 21:08.070
那么他就返回了

21:08.070 --> 21:10.070
是返回的是处

21:10.070 --> 21:11.070
那么如果他会处的话

21:11.070 --> 21:13.070
我就返回force

21:14.070 --> 21:16.070
把这个理清楚

21:16.070 --> 21:17.070
上这个函数

21:17.070 --> 21:18.070
如果不清楚的话

21:18.070 --> 21:19.070
去看一下就是

21:19.070 --> 21:20.070
百度一下

21:20.070 --> 21:21.070
函数很简单

21:21.070 --> 21:23.070
表示满足条件的东西

21:23.070 --> 21:24.070
是否

21:24.070 --> 21:25.070
这个数组里边

21:25.070 --> 21:27.070
是否包含至少一个

21:27.070 --> 21:29.070
满足条件的东西

21:29.070 --> 21:30.070
那么如果有

21:30.070 --> 21:31.070
超出了边界的

21:31.070 --> 21:32.070
那么他就违处

21:32.070 --> 21:33.070
好怎么来判断呢

21:33.070 --> 21:35.070
边界的判断很简单

21:35.070 --> 21:37.070
对吧

21:37.070 --> 21:40.070
每一个就是坐标的x

21:40.070 --> 21:41.070
x如果小于0

21:41.070 --> 21:42.070
x可以等于0

21:42.070 --> 21:44.070
小于0

21:44.070 --> 21:46.070
超出边界

21:46.070 --> 21:48.070
或者是什么呢

21:48.070 --> 21:49.070
x是什么

21:49.070 --> 21:51.070
还有x宽度

21:51.070 --> 21:52.070
大于了什么

21:52.070 --> 21:54.070
大于了多少

21:54.070 --> 21:55.070
如果只有2

21:55.070 --> 21:57.070
如果宽度为2的话

21:57.070 --> 21:59.070
那么x的曲子是0和1

21:59.070 --> 22:00.070
如果宽度为3的话

22:00.070 --> 22:02.070
x的曲子是0,1,2

22:02.070 --> 22:03.070
因此大于多少呢

22:03.070 --> 22:04.070
大于之前我们的

22:04.070 --> 22:06.070
game config

22:06.070 --> 22:08.070
配置里边的

22:08.070 --> 22:10.070
宽度减1

22:10.070 --> 22:11.070
你看是不是这样子

22:11.070 --> 22:12.070
如果小于0

22:12.070 --> 22:13.070
或者是大于了他

22:13.070 --> 22:14.070
都表示

22:14.070 --> 22:16.070
x方向上的

22:16.070 --> 22:17.070
超出了边界

22:17.070 --> 22:19.070
然后继续判断啊

22:19.070 --> 22:20.070
y走上

22:20.070 --> 22:21.070
如果y小于0

22:21.070 --> 22:22.070
或者是

22:22.070 --> 22:24.070
y的坐标呢

22:24.070 --> 22:25.070
大于了什么

22:25.070 --> 22:26.070
game config

22:26.070 --> 22:28.070
panel size

22:28.070 --> 22:30.070
width

22:30.070 --> 22:31.070
加1

22:31.070 --> 22:32.070
不是

22:32.070 --> 22:33.070
height

22:33.070 --> 22:34.070
height减1

22:34.070 --> 22:35.070
如果有

22:35.070 --> 22:36.070
如果高度为3

22:36.070 --> 22:37.070
他曲子是

22:37.070 --> 22:39.070
y的曲子就是0,1,2

22:39.070 --> 22:40.070
高度为4

22:40.070 --> 22:42.070
y的曲子是0,1,2,3

22:42.070 --> 22:43.070
因此减1

22:43.070 --> 22:45.070
如果这个为去的话

22:45.070 --> 22:46.070
是不是超出边界了

22:46.070 --> 22:47.070
就返回去

22:47.070 --> 22:48.070
找到这个条件了

22:48.070 --> 22:50.070
否则返回force

22:50.070 --> 22:52.070
当然你可以减1些

22:52.070 --> 22:54.070
直接把表达4的结果返回

22:54.070 --> 22:55.070
也可以

22:55.070 --> 22:59.220
直接把表达4的结果返回

22:59.220 --> 23:01.220
这是边界判断这一块

23:01.220 --> 23:03.220
边界判断这一块

23:03.220 --> 23:04.220
好了

23:04.220 --> 23:05.220
我们现在

23:05.220 --> 23:06.220
先不去管其他的

23:06.220 --> 23:07.220
先搞定

23:07.220 --> 23:08.220
如果只有边界判断

23:08.220 --> 23:09.220
那么这个事情

23:09.220 --> 23:11.220
其实也没有那么复杂

23:11.220 --> 23:12.220
就判断

23:12.220 --> 23:13.220
它是否超出了边界

23:13.220 --> 23:15.220
我是否能够移动到目标点

23:15.220 --> 23:17.220
到底能不能移动

23:17.220 --> 23:18.220
好

23:18.220 --> 23:19.220
那么咱们来试一下

23:19.220 --> 23:20.220
试一下这个函数

23:20.220 --> 23:22.220
到底可不可以正常运作

23:22.220 --> 23:23.220
怎么试呢

23:23.220 --> 23:25.220
到index里边去

23:25.220 --> 23:27.220
那么现在

23:27.220 --> 23:29.220
我要更改坐标

23:29.220 --> 23:30.220
更改坐标

23:30.220 --> 23:31.220
怎么更改

23:31.220 --> 23:33.220
我可以这样子更改

23:33.220 --> 23:35.220
比方说我要

23:35.220 --> 23:36.220
得到目标的坐标

23:36.220 --> 23:38.220
我要移动到哪儿去了

23:38.220 --> 23:40.220
target

23:40.220 --> 23:41.220
point

23:41.220 --> 23:42.220
移动到

23:42.220 --> 23:44.220
我想移动到这去

23:44.220 --> 23:45.220
我先做什么了

23:45.220 --> 23:46.220
先来判断

23:46.220 --> 23:48.220
如何能不能移动

23:48.220 --> 23:49.220
if

23:49.220 --> 23:50.220
game

23:50.220 --> 23:51.220
if

23:51.220 --> 23:52.220
terrace

23:52.220 --> 23:53.220
ru

23:53.220 --> 23:55.220
它提供了一个函数

23:55.220 --> 23:57.220
can I move

23:57.220 --> 23:59.220
我是否能移动

23:59.220 --> 24:01.220
是否能移动这个函数

24:01.220 --> 24:03.220
那么把这个目标点位置

24:03.220 --> 24:05.220
把我们的形状传进去

24:05.220 --> 24:06.220
形状传进去

24:06.220 --> 24:07.220
得到当前方块的形状

24:08.220 --> 24:09.220
这个有个问题

24:09.220 --> 24:11.220
我们之前写这个方块

24:11.220 --> 24:13.220
组合那个内德时候

24:13.220 --> 24:15.220
并没有把这个形状的东西

24:15.220 --> 24:16.220
扔出来

24:16.220 --> 24:18.220
并没有把这个形状的东西扔出来

24:18.220 --> 24:19.220
所以说

24:19.220 --> 24:21.220
这里我们要处理一下

24:21.220 --> 24:23.220
需要把这个形状扔出来

24:23.220 --> 24:24.220
之前我们把它写成

24:24.220 --> 24:25.220
私有属性的

24:25.220 --> 24:27.220
我们需要把形状扔出来

24:27.220 --> 24:29.220
这个形状你肯定不能复职

24:29.220 --> 24:30.220
肯定不允许你复职的

24:30.220 --> 24:31.220
你只能得到

24:31.220 --> 24:33.220
这个形状

24:33.220 --> 24:36.780
shap

24:37.780 --> 24:39.780
把这个形状扔出来

24:39.780 --> 24:40.780
那么这里

24:40.780 --> 24:42.780
就把这个方块的形状给它

24:42.780 --> 24:44.780
形状给你

24:44.780 --> 24:45.780
然后我想移动到哪去呢

24:45.780 --> 24:47.780
我想移动到这个地方去

24:47.780 --> 24:48.780
看能不能移动

24:48.780 --> 24:50.780
如果能够移动的话

24:50.780 --> 24:52.780
如果能够移动的话

24:52.780 --> 24:53.780
我就去复职

24:53.780 --> 24:56.350
我们来试一下

24:56.350 --> 24:57.350
这是向下移动

24:57.350 --> 25:00.350
看是否能够完成

25:00.350 --> 25:01.350
向下

25:03.350 --> 25:04.350
到这就不行了

25:04.350 --> 25:05.350
为什么不行

25:05.350 --> 25:07.350
不下面还有吗

25:07.350 --> 25:08.350
注意

25:08.350 --> 25:10.350
我现在这个面板的宽度

25:10.350 --> 25:11.350
跟这个无关

25:11.350 --> 25:13.350
给我们这里的配置是无关的

25:13.350 --> 25:15.350
我们配置的是10乘以10

25:15.350 --> 25:17.350
那么按照我们之前

25:17.350 --> 25:19.350
这里的配置宽度为30

25:19.350 --> 25:21.350
高度为30的话

25:21.350 --> 25:22.350
那么实际

25:22.350 --> 25:23.350
页面上的宽度

25:23.350 --> 25:25.350
应该是300乘300

25:25.350 --> 25:26.350
我们这里看一下吧

25:26.350 --> 25:28.350
300乘300

25:28.350 --> 25:29.350
我们先做测试吧

25:29.350 --> 25:30.350
这个东西以后

25:30.350 --> 25:32.350
肯定要用代码来测试

25:32.350 --> 25:34.350
向下移动

25:34.350 --> 25:36.350
你看是不是移动不了了

25:36.350 --> 25:37.350
那么向左移动

25:37.350 --> 25:39.350
向右移动是不是一样的

25:39.350 --> 25:41.350
因此这里面

25:41.350 --> 25:43.350
其实我还可以提供

25:43.350 --> 25:45.350
很多这样的实用的函数

25:45.350 --> 25:47.350
比方说

25:47.350 --> 25:49.350
我可以这样提供

25:49.350 --> 25:52.350
移动到某一个位置去

25:52.350 --> 25:54.350
移动到某一个位置去

25:54.350 --> 25:55.350
怎么移动呢

25:55.350 --> 25:57.350
给我一个sharp

25:57.350 --> 25:58.350
或者说

25:58.350 --> 26:04.350
就直接给我一个方块

26:05.350 --> 26:06.350
直接给我一个方块

26:06.350 --> 26:07.350
我来帮你移动

26:07.350 --> 26:08.350
我来帮你移动

26:08.350 --> 26:09.350
然后给我一个方块

26:09.350 --> 26:12.350
这个方块内心就是square

26:12.350 --> 26:15.350
square group

26:15.350 --> 26:17.350
然后把你想移动到的

26:17.350 --> 26:18.350
目标位置给我

26:18.350 --> 26:19.350
你想移动到哪去

26:19.350 --> 26:21.350
我来帮你完成移动

26:21.350 --> 26:23.350
帮你完成移动

26:23.350 --> 26:25.350
反而回到市场

26:25.350 --> 26:26.350
我就直接返回一个布尔

26:26.350 --> 26:27.350
是否移动成功

26:27.350 --> 26:28.350
是否移动成功

26:28.350 --> 26:30.350
那么假設有这么一个函数

26:30.350 --> 26:31.350
这个函数怎么实现呢

26:31.350 --> 26:32.350
其实就是

26:32.350 --> 26:33.350
把刚才的代码扔过来

26:33.350 --> 26:34.350
还能做啥呢

26:34.350 --> 26:35.350
什么事情都不用做了

26:35.350 --> 26:36.350
就把刚才的函数扔过来

26:36.350 --> 26:37.350
就完成了

26:37.350 --> 26:38.350
这是我们的目标点

26:38.350 --> 26:39.350
已经给我了

26:39.350 --> 26:40.350
给我了一个目标点

26:40.350 --> 26:42.350
那么我首先判断

26:42.350 --> 26:44.350
通过this点开目

26:44.350 --> 26:45.350
通过这个函数来判断

26:45.350 --> 26:47.350
我是不是能够移动

26:47.350 --> 26:49.350
把这个形状移动到目标位置

26:49.350 --> 26:51.350
是不是能够移动过去

26:51.350 --> 26:52.350
如果能够移动的话

26:52.350 --> 26:53.350
我就重新设置

26:53.350 --> 26:54.350
它的中心点

26:54.350 --> 26:55.350
来完成

26:55.350 --> 26:56.350
当然

26:56.350 --> 26:58.350
中心点的做法是这个

26:58.350 --> 26:59.350
这个

26:59.350 --> 27:00.350
我重新设置

27:00.350 --> 27:01.350
中心点做标

27:01.350 --> 27:02.350
来完成移动

27:02.350 --> 27:03.350
最后返回处

27:03.350 --> 27:04.350
表示移动成功

27:04.350 --> 27:05.350
然后返回force

27:05.350 --> 27:06.350
表示移动失败

27:06.350 --> 27:07.350
好

27:07.350 --> 27:08.350
那么我这里

27:08.350 --> 27:09.350
通过这个函数

27:09.350 --> 27:10.350
我就可以

27:10.350 --> 27:11.350
更加简洁的

27:11.350 --> 27:12.350
让外面调用的时候

27:12.350 --> 27:13.350
更加简洁

27:13.350 --> 27:14.350
直接移动

27:14.350 --> 27:15.350
你可以判断

27:15.350 --> 27:16.350
判断之后再移动

27:16.350 --> 27:17.350
也可以调用这个函数

27:17.350 --> 27:18.350
直接移动

27:18.350 --> 27:19.350
那么外面的话

27:19.350 --> 27:20.350
我们这里

27:20.350 --> 27:21.350
就可以使用这个函数了

27:21.350 --> 27:22.350
就是

27:23.350 --> 27:24.350
这里

27:24.350 --> 27:25.350
我们使用这个函数

27:26.350 --> 27:27.350
这里

27:27.350 --> 27:28.350
我们使用这个函数

27:35.860 --> 27:36.860
移动

27:36.860 --> 27:38.860
移动的目标位置

27:38.860 --> 27:39.860
首先把terrors给你

27:39.860 --> 27:40.860
移动的目标位置

27:40.860 --> 27:42.860
x等于

27:42.860 --> 27:43.860
terrors

27:43.860 --> 27:44.860
第二

27:44.860 --> 27:45.860
share

27:45.860 --> 27:46.860
center point

27:46.860 --> 27:47.860
x

27:47.860 --> 27:48.860
然后

27:48.860 --> 27:50.860
y等于

27:50.860 --> 27:51.860
terrors

27:51.860 --> 27:52.860
center point

27:52.860 --> 27:54.860
y加1

27:54.860 --> 27:55.860
y加1

27:56.860 --> 27:57.860
好

27:57.860 --> 27:58.860
保存一下

28:00.860 --> 28:01.860
现在我们想一下一种

28:01.860 --> 28:02.860
你看是不是一样的

28:02.860 --> 28:03.860
都是一样的

28:04.860 --> 28:05.860
好

28:05.860 --> 28:06.860
为了后标调用起来

28:06.860 --> 28:07.860
更加方便

28:07.860 --> 28:08.860
我甚至可以在这里面

28:08.860 --> 28:09.860
写更多的使用函数

28:09.860 --> 28:11.860
因为它都是提供规则的

28:11.860 --> 28:12.860
对吧

28:12.860 --> 28:13.860
都是提供规则的

28:13.860 --> 28:14.860
我们可以写一些

28:14.860 --> 28:15.860
更多的使用函数

28:15.860 --> 28:16.860
比方说

28:16.860 --> 28:17.860
咱们平时在

28:17.860 --> 28:18.860
移动方块的时候

28:18.860 --> 28:19.860
一般来说

28:19.860 --> 28:20.860
不会直接

28:20.860 --> 28:21.860
把它设置到一个点

28:21.860 --> 28:22.860
一般都不会的

28:22.860 --> 28:23.860
不会直接把它

28:23.860 --> 28:24.860
移动一个点

28:24.860 --> 28:25.860
而是

28:25.860 --> 28:26.860
每次移动一格

28:26.860 --> 28:27.860
对不对

28:27.860 --> 28:28.860
我们通常情况下

28:28.860 --> 28:29.860
都是每次移动一格

28:29.860 --> 28:30.860
好

28:30.860 --> 28:31.860
那也就是说

28:31.860 --> 28:32.860
我们可以这样做

28:32.860 --> 28:33.860
可以这样做

28:33.860 --> 28:35.860
我这里定一个内详

28:35.860 --> 28:36.860
就指的是移动方向

28:37.860 --> 28:39.860
定一个美剧

28:39.860 --> 28:41.860
叫move

28:41.860 --> 28:42.860
move

28:42.860 --> 28:43.860
direction

28:43.860 --> 28:44.860
定一个移动方向

28:44.860 --> 28:46.860
方向有哪些呢

28:46.860 --> 28:47.860
上就不管了

28:47.860 --> 28:48.860
没有上这个方向

28:48.860 --> 28:49.860
因为我们

28:49.860 --> 28:51.860
现在要考虑游戏规则了

28:51.860 --> 28:53.860
是这个terrors如果是规则

28:53.860 --> 28:54.860
因此我们要考虑

28:54.860 --> 28:55.860
实际的游戏规则

28:55.860 --> 28:57.860
所以不用去那么灵活

28:57.860 --> 28:58.860
我们要考虑实际情况

28:58.860 --> 29:00.860
只有左

29:03.860 --> 29:04.860
left左

29:05.860 --> 29:06.860
没去写错了

29:06.860 --> 29:07.860
不是这样子写的

29:07.860 --> 29:08.860
我说

29:08.860 --> 29:11.860
left左右下

29:11.860 --> 29:14.860
只有左右下

29:14.860 --> 29:15.860
三个方向

29:15.860 --> 29:17.860
好 每次移动一格

29:17.860 --> 29:18.860
OK 那么这里呢

29:18.860 --> 29:19.860
我就可以这样做

29:19.860 --> 29:20.860
再写个函数

29:20.860 --> 29:22.860
这里面全是提供一些

29:22.860 --> 29:23.860
实用的函数

29:23.860 --> 29:25.860
来帮助我们去完成一些功能

29:25.860 --> 29:26.860
move

29:27.860 --> 29:29.860
好 这个函数里边呢

29:29.860 --> 29:31.860
我们需要一个参数

29:32.860 --> 29:33.860
就是

29:34.860 --> 29:35.860
direction

29:35.860 --> 29:36.860
方向

29:37.860 --> 29:39.860
好 移动方向

29:40.860 --> 29:41.860
好 写到这

29:41.860 --> 29:43.860
你看 这两个函数

29:43.860 --> 29:44.860
出现了重迷

29:45.860 --> 29:46.860
但是呢 这里我又不想

29:46.860 --> 29:47.860
给它重新命个名字

29:47.860 --> 29:48.860
因为move这个名字

29:48.860 --> 29:50.860
真的是太帅了

29:50.860 --> 29:51.860
怎么想都是

29:51.860 --> 29:52.860
应该是move这个名字

29:52.860 --> 29:53.860
我实在是

29:53.860 --> 29:55.860
没有办法去改动这个名字了

29:55.860 --> 29:56.860
改动这个名字之后

29:56.860 --> 29:57.860
外边调整起来

29:57.860 --> 29:58.860
它就要想一想

29:58.860 --> 30:00.860
这个名字不是move 是啥呢

30:00.860 --> 30:02.860
因此呢 这里怎么处理呢

30:02.860 --> 30:03.860
怎么处理

30:03.860 --> 30:05.860
我可以把这两个函数

30:05.860 --> 30:06.860
合成一个函数

30:06.860 --> 30:07.860
怎么合

30:07.860 --> 30:08.860
这样子

30:11.170 --> 30:12.170
其实我们之前

30:12.170 --> 30:13.170
应该有同学知道吧

30:13.170 --> 30:14.170
这个叫什么

30:14.170 --> 30:15.170
函数重占

30:15.170 --> 30:17.170
第一个参数

30:17.170 --> 30:18.170
第一个参数

30:18.170 --> 30:19.170
是

30:19.170 --> 30:20.170
方块

30:20.170 --> 30:21.170
方块我始终要给方块的

30:21.170 --> 30:22.170
对不对

30:22.170 --> 30:23.170
始终要给方块的

30:23.170 --> 30:24.170
第一个参数都应该是方块

30:24.170 --> 30:25.170
都是两个参数

30:26.170 --> 30:27.170
第一个参数都是方块

30:28.170 --> 30:29.170
第二个参数呢

30:29.170 --> 30:30.170
是你移动的方向

30:30.170 --> 30:31.170
那这里的第二个参数呢

30:31.170 --> 30:32.170
是一个point

30:32.170 --> 30:33.170
是一个

30:33.170 --> 30:34.170
就是

30:34.170 --> 30:35.170
坐标

30:35.170 --> 30:37.170
那么第二个参数有变化

30:37.170 --> 30:38.170
第二个参数有变化

30:39.170 --> 30:40.170
point

30:40.170 --> 30:41.170
或者是

30:41.170 --> 30:42.170
direction

30:42.170 --> 30:44.170
它有两种类型都可以

30:44.170 --> 30:45.170
你给我一个

30:45.170 --> 30:46.170
坐标

30:46.170 --> 30:47.170
你给我一个方向

30:47.170 --> 30:48.170
都可以

30:48.170 --> 30:49.170
都可以

30:49.170 --> 30:50.170
那么也就是

30:50.170 --> 30:51.170
第二参数呢

30:51.170 --> 30:52.170
我这里可以写成

30:52.170 --> 30:53.170
改个名字

30:53.170 --> 30:54.170
第一个参数

30:54.170 --> 30:55.170
Target point

30:56.170 --> 30:57.170
all

30:57.170 --> 30:58.170
direction

30:59.170 --> 31:00.170
好

31:00.170 --> 31:01.170
那么现在呢

31:01.170 --> 31:02.170
这个函数如何去实现呢

31:02.170 --> 31:03.170
现在把两个函数

31:03.170 --> 31:04.170
合并成一个函数了

31:04.170 --> 31:06.170
那么如何去实现呢

31:06.170 --> 31:07.170
判断呗

31:07.170 --> 31:08.170
对不对

31:08.170 --> 31:09.170
判断

31:09.170 --> 31:10.170
如果

31:10.170 --> 31:11.170
如果

31:11.170 --> 31:13.170
Target point

31:13.170 --> 31:14.170
all

31:14.170 --> 31:15.170
direction

31:15.170 --> 31:16.170
里边包含了什么

31:16.170 --> 31:17.170
包含了

31:17.170 --> 31:20.170
坐标里面的特征就是包含了x

31:20.170 --> 31:21.170
包含了y

31:21.170 --> 31:22.170
包含了x

31:22.170 --> 31:23.170
包含了y

31:23.170 --> 31:24.170
那么它就是一个坐标

31:24.170 --> 31:26.170
我就按照坐标的方式来处理

31:26.170 --> 31:28.170
如果它不是一个坐标

31:28.170 --> 31:30.170
它是一个就是方向的话

31:30.170 --> 31:33.170
那么我就按照方向的方式来处理

31:33.170 --> 31:34.170
所以说这里呢

31:34.170 --> 31:35.170
就看你

31:35.170 --> 31:36.170
就需要你进行判断

31:36.170 --> 31:37.170
需要你进行判断

31:37.170 --> 31:38.170
那么这个判断

31:38.170 --> 31:40.170
我希望它完成判断之后

31:40.170 --> 31:41.170
比方说

31:41.170 --> 31:42.170
我这条判断

31:42.170 --> 31:44.170
它是一个坐标的类型

31:44.170 --> 31:46.170
那么它完成了判断之后呢

31:46.170 --> 31:48.170
我希望

31:48.170 --> 31:50.170
我希望它这里就能够推导出

31:50.170 --> 31:52.170
它是一个坐标

31:52.170 --> 31:54.170
希望它能够自动进行推导

31:54.170 --> 31:55.170
那这个是什么呢

31:55.170 --> 31:57.170
有没有同学能够想到

31:57.170 --> 32:00.170
这个地方我们要用到什么知识

32:00.170 --> 32:04.170
要用到自定义的类型保护含书

32:04.170 --> 32:05.170
其实这里呢

32:05.170 --> 32:07.170
我讲到这

32:07.170 --> 32:09.170
我是强行把这些

32:09.170 --> 32:11.170
把这些东西安进来的

32:11.170 --> 32:12.170
因为我想了想去

32:12.170 --> 32:14.170
这个东西如果不安在这

32:14.170 --> 32:15.170
不知道安在哪了

32:15.170 --> 32:16.170
我也不知道安在哪了

32:16.170 --> 32:18.170
当然你没写代码的时候

32:18.170 --> 32:19.170
你当然可以把它分开写

32:19.170 --> 32:20.170
分成两个含书

32:20.170 --> 32:22.170
把含书名字写成不一样

32:22.170 --> 32:23.170
当然可以这样做

32:23.170 --> 32:25.170
但是我是强行把这个知识安过来

32:25.170 --> 32:26.170
好那么这里

32:26.170 --> 32:28.170
我们专门来写个含书

32:28.170 --> 32:29.170
进行

32:29.170 --> 32:32.170
帮助我们进行内穷保护的判断

32:32.170 --> 32:35.170
is point

32:35.170 --> 32:37.170
是不是一个坐标

32:37.170 --> 32:38.170
判断一个东西

32:38.170 --> 32:39.170
是不是个坐标

32:39.170 --> 32:41.170
传一个对象进来

32:41.170 --> 32:42.170
传一个对象进来

32:42.170 --> 32:45.670
好怎么判断呢

32:45.670 --> 32:46.670
这个判断很简单

32:46.670 --> 32:47.670
我首先要标注一下

32:47.670 --> 32:49.670
这个含书判断的是啥

32:49.670 --> 32:51.670
判断的是这个obj

32:51.670 --> 32:53.670
is point

32:53.670 --> 32:55.670
判断的是这个东西

32:55.670 --> 32:56.670
加个帽

32:56.670 --> 32:58.670
判断的是这个东西

32:58.670 --> 32:59.670
obj

32:59.670 --> 33:01.670
is point

33:01.670 --> 33:02.670
好那么怎么判断呢

33:02.670 --> 33:03.670
判断方式非常简单

33:03.670 --> 33:05.670
就type of

33:05.670 --> 33:07.670
type of obj的x

33:07.670 --> 33:09.670
是不是等于

33:09.670 --> 33:11.670
indefine

33:11.670 --> 33:13.670
并且

33:13.670 --> 33:14.670
是不是等于

33:14.670 --> 33:16.670
就看一个x就完事了

33:16.670 --> 33:18.670
一个坐标里面一定有x

33:18.670 --> 33:20.670
如果x为undefine

33:20.670 --> 33:21.670
说明他没有属性

33:21.670 --> 33:22.670
s

33:22.670 --> 33:23.670
那么他就是一个什么

33:23.670 --> 33:24.670
他就是force

33:24.670 --> 33:25.670
他就不是point

33:25.670 --> 33:26.670
否则的话就是一个point

33:26.670 --> 33:27.670
就这么简单

33:27.670 --> 33:29.670
好我们有这个辅助含书

33:29.670 --> 33:30.670
帮我们来判断

33:30.670 --> 33:31.670
它是不是个坐标

33:31.670 --> 33:32.670
好那么这里

33:32.670 --> 33:33.670
我就可以使用那个盘数了

33:33.670 --> 33:34.670
is point

33:34.670 --> 33:36.670
它是不是一个坐标呢

33:36.670 --> 33:37.670
如果它是一个坐标

33:37.670 --> 33:38.670
那么代表到这

33:38.670 --> 33:40.670
你看

33:40.670 --> 33:42.670
他就能够知道了

33:42.670 --> 33:43.670
有内形保护之后

33:43.670 --> 33:44.670
他就能知道

33:44.670 --> 33:46.670
这个地方是一个坐标

33:46.670 --> 33:47.670
好坐标怎么办

33:47.670 --> 33:49.670
坐标是不是这里的判断方式

33:49.670 --> 33:51.670
坐标就是这样的判断方式

33:51.670 --> 33:53.670
else

33:53.670 --> 33:55.670
else他就不是

33:55.670 --> 33:56.670
他就

33:56.670 --> 33:57.670
他这个地方呢

33:57.670 --> 33:58.670
代码到了这里

33:58.670 --> 34:00.670
我们再看一下他的内形

34:00.670 --> 34:02.670
他就表示了一个方向

34:02.670 --> 34:03.670
对吧表示个方向

34:03.670 --> 34:04.670
我们甚至

34:04.670 --> 34:05.670
这个辩量呢

34:05.670 --> 34:06.670
可以在这里改一下

34:06.670 --> 34:07.670
因为方向这里的代码呢

34:07.670 --> 34:09.670
稍微有点多

34:09.670 --> 34:11.670
等一下先把保存一下

34:11.670 --> 34:12.670
保存这个辩量里边

34:12.670 --> 34:13.670
它是一个方向

34:13.670 --> 34:14.670
好根据方向呢

34:14.670 --> 34:16.670
我们来设置目标

34:16.670 --> 34:18.670
来设置目标

34:18.670 --> 34:19.670
那么这里呢

34:19.670 --> 34:20.670
判断一下呗

34:20.670 --> 34:22.670
方向一共就这么四种情况

34:22.670 --> 34:23.670
direction

34:23.670 --> 34:25.670
如果等于美举

34:25.670 --> 34:29.110
direction

34:29.110 --> 34:33.110
如果等于往下

34:33.110 --> 34:35.110
如果等于往下

34:35.110 --> 34:37.110
那么这个时候呢

34:37.110 --> 34:38.110
我们怎么样呢

34:38.110 --> 34:40.110
我们的目标

34:40.110 --> 34:42.110
首先设置一个吧

34:42.110 --> 34:44.110
设置个辩量

34:44.110 --> 34:46.110
target point

34:46.110 --> 34:48.110
x

34:48.110 --> 34:51.110
x等于当前的

34:51.110 --> 34:53.110
先不做任何东西

34:53.110 --> 34:55.110
先不设置任何东西

34:55.110 --> 34:56.110
先不设置

34:56.110 --> 34:58.110
如果方向是往下的话

34:58.110 --> 34:59.110
我们的目标的作标

34:59.110 --> 35:00.110
应该是什么呢

35:00.110 --> 35:01.110
x等于

35:01.110 --> 35:03.110
当前这个方块的

35:03.110 --> 35:05.110
center point x

35:05.110 --> 35:06.110
然后呢 y呢

35:06.110 --> 35:07.110
应该等于

35:07.110 --> 35:09.110
teriors center point y

35:09.110 --> 35:10.110
加一对不对

35:10.110 --> 35:12.110
好这是往下的方向

35:12.110 --> 35:14.110
lcf

35:14.110 --> 35:16.110
direction

35:16.110 --> 35:17.110
等于目

35:17.110 --> 35:18.110
direction

35:18.110 --> 35:20.110
如果是往左的话

35:20.110 --> 35:22.110
如果是往左的话

35:22.110 --> 35:24.110
这点没有约束内向

35:24.110 --> 35:26.110
没有约束内向

35:26.110 --> 35:28.110
这个是point

35:28.110 --> 35:30.110
这是目标的作标点

35:30.110 --> 35:31.110
好如果是往左的话

35:31.110 --> 35:32.110
那么看一下

35:32.110 --> 35:33.110
这个作标是不是

35:33.110 --> 35:34.110
应该到这儿

35:34.110 --> 35:35.110
x

35:35.110 --> 35:36.110
-1

35:36.110 --> 35:38.110
y不变

35:38.110 --> 35:40.110
好如果是往右的话

35:40.110 --> 35:42.110
如果是往右的话

35:42.110 --> 35:44.110
那么这里是

35:44.110 --> 35:45.110
right

35:45.110 --> 35:46.110
如果是往右

35:46.110 --> 35:47.110
往右的话

35:47.110 --> 35:49.110
那就是x-1 y不变

35:49.110 --> 35:50.110
当然这里

35:50.110 --> 35:52.110
也只有最后的那种情况了

35:52.110 --> 35:54.110
只有最后的那种情况了

35:54.110 --> 35:55.110
好这样子的通过

35:55.110 --> 35:56.110
这种方式

35:56.110 --> 35:57.110
我是不是能把作标算出来啊

35:57.110 --> 35:58.110
就是不管你

35:58.110 --> 35:59.110
根据你移动的方向

35:59.110 --> 36:00.110
我要把你

36:00.110 --> 36:02.110
目标位置的作标算出来

36:02.110 --> 36:03.110
那么目标位置

36:03.110 --> 36:04.110
作标算出来了

36:04.110 --> 36:05.110
当前的这个

36:05.110 --> 36:07.110
teriors对向也有

36:07.110 --> 36:09.110
我们是不是在这里

36:09.110 --> 36:10.110
重新去

36:10.110 --> 36:11.110
我不用去再进行判断了

36:11.110 --> 36:13.110
没有必要再进行判断了

36:13.110 --> 36:15.110
我重新去调用这个目标方法

36:15.110 --> 36:17.110
这相当于是地规对吧

36:17.110 --> 36:18.110
自己调用自己

36:18.110 --> 36:20.110
重新去调用这个目标方法

36:20.110 --> 36:21.110
把teriors传进去

36:21.110 --> 36:23.110
然后现在传的就不是

36:23.110 --> 36:24.110
方向了

36:24.110 --> 36:25.110
传的是什么

36:25.110 --> 36:27.110
传的是作标

36:27.110 --> 36:29.110
把作标传进去

36:29.110 --> 36:30.110
我看一下

36:30.110 --> 36:31.110
找不到

36:31.110 --> 36:32.110
这里z

36:32.110 --> 36:34.110
把作标传进去

36:34.110 --> 36:36.110
然后又把它换成作标

36:36.110 --> 36:37.110
让你去判断

36:38.110 --> 36:39.110
我这个函数里面

36:39.110 --> 36:41.110
就处理了两种情况

36:41.110 --> 36:43.110
一种是你传的作标进来

36:43.110 --> 36:45.110
一种是传的方向进来

36:45.110 --> 36:46.110
甭管你最后

36:46.110 --> 36:47.110
理解代码的时候

36:47.110 --> 36:49.110
要不要使用这种方式

36:49.110 --> 36:51.110
总归你写的时候

36:53.110 --> 36:56.110
你要至少能够理解这个方式

36:56.110 --> 36:57.110
你至少知道这个方式

36:57.110 --> 36:58.110
是可以写的

36:59.110 --> 37:01.110
好写好了这个函数之后

37:01.110 --> 37:02.110
我们希望让外面

37:02.110 --> 37:03.110
调用的时候

37:04.110 --> 37:05.110
看到

37:05.110 --> 37:07.110
我们这里是有函数存在的

37:07.110 --> 37:09.110
我们给它写两个函数存在

37:09.110 --> 37:10.110
就声明一下

37:10.110 --> 37:11.110
这里有两种情况

37:11.110 --> 37:12.110
你可以使用

37:12.110 --> 37:13.110
Static

37:13.110 --> 37:14.110
因为我们很久没有

37:14.110 --> 37:15.110
用过存在了

37:15.110 --> 37:16.110
这里复习一下

37:16.110 --> 37:17.110
第一种方式

37:17.110 --> 37:19.110
是传一个teriors

37:19.110 --> 37:21.110
当然类型是square group

37:21.110 --> 37:22.110
第二个参数

37:22.110 --> 37:24.110
这里写的帽好

37:24.110 --> 37:26.110
第二个参数是

37:26.110 --> 37:27.110
作标

37:27.110 --> 37:28.110
target point

37:28.110 --> 37:29.110
作标

37:29.110 --> 37:31.110
point

37:31.110 --> 37:32.110
这第一个存在

37:33.110 --> 37:34.110
下一个

37:35.110 --> 37:36.110
下一个存在

37:37.110 --> 37:41.640
这里少写一个内容

37:41.640 --> 37:42.640
我说这么回事

37:42.640 --> 37:43.640
少写一个内容

37:43.640 --> 37:44.640
不

37:45.640 --> 37:46.640
这里也是

37:46.640 --> 37:47.640
少写一个内容

37:47.640 --> 37:48.640
存在只是声明

37:48.640 --> 37:50.640
在编译结果里面就不存在了

37:50.640 --> 37:51.640
好

37:51.640 --> 37:52.640
第二个存在是传方向

37:52.640 --> 37:53.640
direct

37:54.640 --> 37:55.640
direct

37:55.640 --> 37:56.640
传递方向

37:56.640 --> 37:57.640
好

37:57.640 --> 37:58.640
我们写好了这么两个存在

37:58.640 --> 38:00.640
然后在外面调用看一下

38:00.640 --> 38:01.640
看一下

38:01.640 --> 38:02.640
这里哪里包错

38:02.640 --> 38:03.640
我看一下哪里包错

38:04.640 --> 38:05.640
这里好像

38:05.640 --> 38:06.640
有个地方好像在包错

38:09.660 --> 38:10.660
这里

38:11.660 --> 38:12.660
哦

38:12.660 --> 38:14.660
l是怎么写条件的

38:14.660 --> 38:16.660
l是不能写条件

38:16.660 --> 38:17.660
好这边写好了

38:17.660 --> 38:19.660
那么现在我们再来看一下

38:19.660 --> 38:22.660
现在移动下就很舒服了

38:22.660 --> 38:23.660
我要向下移动

38:23.660 --> 38:25.660
根据我们的游戏规则

38:25.660 --> 38:26.660
向下移动就是移动一块

38:26.660 --> 38:27.660
对吧

38:27.660 --> 38:28.660
那么就是

38:28.660 --> 38:31.660
teriors入路

38:32.660 --> 38:33.660
你看

38:33.660 --> 38:34.660
这里有两个重斩

38:34.660 --> 38:36.660
有两种方式可以调用

38:36.660 --> 38:37.660
你可以直接设置

38:37.660 --> 38:38.660
目标做点坐标

38:38.660 --> 38:39.660
没问题

38:39.660 --> 38:41.660
也可以设置

38:41.660 --> 38:42.660
目标点方向

38:42.660 --> 38:44.660
就是你要移动的方向

38:44.660 --> 38:46.660
那么我们现在按照方向来移动

38:46.660 --> 38:48.660
调用起来就非常舒服了

38:48.660 --> 38:50.660
我们把teriors传进去

38:50.660 --> 38:51.660
然后呢

38:51.660 --> 38:53.660
目标点的方向

38:53.660 --> 38:54.660
我们使用第二个重斩

38:54.660 --> 38:55.660
方向就是目

38:55.660 --> 38:56.660
direct

38:58.660 --> 39:00.660
移动就这样移动就完事了

39:01.660 --> 39:04.800
我这里写错了吗

39:05.800 --> 39:06.800
我看一下

39:11.370 --> 39:12.370
这里

39:12.370 --> 39:14.370
我这里写错了

39:14.370 --> 39:15.370
这里写错了

39:15.370 --> 39:16.370
这个

39:16.370 --> 39:17.370
用了这个类型

39:17.370 --> 39:20.370
叫move direction

39:21.370 --> 39:22.370
这里也是

39:22.370 --> 39:24.370
我这里声名写错了

39:24.370 --> 39:26.370
那么回到这边来

39:26.370 --> 39:28.370
这里是向下移动

39:28.370 --> 39:31.370
然后这边是向上就不管了

39:31.370 --> 39:33.370
向上我们没有这个功能了

39:33.370 --> 39:35.370
向上移动也可以吧

39:35.370 --> 39:36.370
向上移动

39:36.370 --> 39:38.370
我们就用目标点的方式

39:38.370 --> 39:40.370
就不用这个方向

39:40.370 --> 39:41.370
就使用目标点

39:41.370 --> 39:42.370
x

39:42.370 --> 39:44.370
等于teriors

39:44.370 --> 39:45.370
center points

39:45.370 --> 39:46.370
x

39:46.370 --> 39:47.370
这边

39:47.370 --> 39:49.370
y的话就是teriors

39:49.370 --> 39:51.370
那我现在就很灵活了

39:51.370 --> 39:53.370
我们可以有简单的方式来调用

39:53.370 --> 39:55.370
也可以有复杂的方式

39:55.370 --> 39:57.370
这种麻烦的方式去调用

39:57.370 --> 40:00.370
就是灵活和方便都有了

40:01.370 --> 40:05.190
向右移动

40:05.190 --> 40:06.190
向右移动

40:06.190 --> 40:09.190
然后这里使用right

40:09.190 --> 40:11.190
这里我写错了

40:11.190 --> 40:13.190
应该是up

40:13.190 --> 40:15.190
向左移动

40:16.190 --> 40:19.190
向左移动left

40:19.190 --> 40:23.190
这里我们就使用left

40:23.190 --> 40:25.190
我们写成这种格式的

40:25.190 --> 40:28.190
那么外面使用的就简洁了非常多了

40:28.190 --> 40:29.190
保存

40:30.190 --> 40:31.190
看一下

40:31.190 --> 40:32.190
向下

40:32.190 --> 40:34.190
向右

40:35.190 --> 40:37.190
按钮换个位置

40:37.190 --> 40:39.190
感觉怪怪的

40:39.190 --> 40:43.080
左边换左边

40:43.080 --> 40:44.080
向左

40:44.080 --> 40:46.390
向右

40:46.390 --> 40:47.390
向上

40:47.390 --> 40:48.390
你看到没

40:48.390 --> 40:50.390
那么现在移动的范围

40:50.390 --> 40:51.390
我们就得到控制了

40:51.390 --> 40:53.390
它只能在这个范围内移动

40:53.390 --> 40:55.390
这是关于

40:55.390 --> 40:57.390
这个内的作用

40:57.390 --> 40:59.390
teriors入

40:59.390 --> 41:00.390
它来控制

41:00.390 --> 41:03.390
方块的各种变化规则

41:03.390 --> 41:05.390
当然我们现在只是写了移动

41:05.390 --> 41:06.390
只是写了移动

41:06.390 --> 41:07.390
其实移动这里

41:07.390 --> 41:10.390
我们还可以做出很多花样出来

41:10.390 --> 41:11.390
还可以做出很多花样出来

41:11.390 --> 41:13.390
比方说我们还可以写这么一个东西

41:13.390 --> 41:17.150
再写个函数

41:17.150 --> 41:18.150
叫做move

41:18.150 --> 41:19.150
directly

41:19.150 --> 41:20.150
啥意思呢

41:20.150 --> 41:22.150
就是一直移动到底

41:22.150 --> 41:24.150
不管你给我一个方向

41:24.150 --> 41:25.150
我就把它一直移动到底

41:25.150 --> 41:27.150
我们可以写出很多花样出来

41:27.150 --> 41:29.150
你会发现这些函数都非常好写

41:29.150 --> 41:30.150
因为有了一些

41:30.150 --> 41:31.150
基础的功能过后

41:31.150 --> 41:33.150
这些函数就非常好写了

41:33.150 --> 41:36.150
比方说你只需要给我一个teriors

41:37.150 --> 41:40.150
内容是square group

41:40.150 --> 41:42.150
然后给我一个方向

41:42.150 --> 41:44.150
direction

41:44.150 --> 41:46.150
moodirection

41:46.150 --> 41:47.150
我要做什么呢

41:47.150 --> 41:50.150
一直把这个方向移动到不能移动为止

41:50.150 --> 41:54.150
从当前位置移动到这个方向不能移动为止

41:54.150 --> 41:56.150
那么怎么移动呢

41:56.150 --> 41:58.150
大家注意

41:58.150 --> 42:04.150
将当前的方块移动到

42:04.150 --> 42:07.150
目标方向上

42:07.150 --> 42:09.150
目标方向的终点

42:09.150 --> 42:11.150
就是不能移动为止

42:11.150 --> 42:12.150
那么怎么移动

42:12.150 --> 42:14.150
怎么移动呢

42:14.150 --> 42:17.150
这个函数怎么实现呢

42:17.150 --> 42:19.150
其实就是一步一步的去移动

42:19.150 --> 42:21.150
移动到不能移动为止

42:21.150 --> 42:23.150
就完事了

42:23.150 --> 42:25.150
所以这个函数实现起来非常非常简单

42:25.150 --> 42:27.150
写个死循环

42:27.150 --> 42:28.150
判断一下

42:28.150 --> 42:30.150
判断啥呢

42:30.150 --> 42:32.150
判断

42:32.150 --> 42:34.150
我们之前不是有函数目无吗

42:34.150 --> 42:35.150
你去移动呗

42:35.150 --> 42:36.150
我方块给你

42:36.150 --> 42:38.150
把方向给你移动一步

42:38.150 --> 42:40.150
像这个方向上移动一步

42:40.150 --> 42:42.150
如果你移动成功了

42:42.150 --> 42:43.150
那么就继续移动

42:43.150 --> 42:45.150
如果你移动不成功

42:45.150 --> 42:46.150
如果你移动不成功

42:46.150 --> 42:48.150
那么退出循环

42:48.150 --> 42:50.150
其实我又可以把简写一下

42:50.150 --> 42:51.150
简写一下

42:51.150 --> 42:54.150
就这样子写成这样子的来嘛

42:54.150 --> 42:56.150
是不是就完了

42:56.150 --> 42:57.150
还有啥呢

42:57.150 --> 42:58.150
没啥了吧

42:58.150 --> 42:59.150
就完了

42:59.150 --> 43:01.150
这个循环什么时候结束

43:01.150 --> 43:04.150
它移动不成功的时候就结束

43:04.150 --> 43:06.150
你看这个函数是不是很简单呢

43:06.150 --> 43:08.150
有了这些基础函数的帮助

43:08.150 --> 43:10.150
那么这些函数写出来就非常非常容易了

43:10.150 --> 43:12.150
好那么咱们试一下

43:12.150 --> 43:14.150
直接移动到底

43:14.150 --> 43:16.150
那么移动到下的话

43:16.150 --> 43:19.150
我们就使用目Directly

43:19.150 --> 43:20.150
移动到下

43:20.150 --> 43:22.150
那么咱们试一下吧

43:22.150 --> 43:23.150
试一下

43:23.150 --> 43:24.150
好这边

43:24.150 --> 43:26.150
向下移动

43:26.150 --> 43:28.150
出了问题对吧

43:28.150 --> 43:30.150
目Directly

43:30.150 --> 43:33.150
这边是什么问题

43:33.150 --> 43:35.150
也不是转到定义

43:35.150 --> 43:36.150
看一下这边

43:36.150 --> 43:38.150
如果移动成功

43:38.150 --> 43:40.150
这应该是

43:40.150 --> 43:42.150
如果移动成功的话

43:42.150 --> 43:43.150
如果移动成功的话

43:43.150 --> 43:44.150
那么就继续循环对吧

43:44.150 --> 43:46.150
就继续循环

43:46.150 --> 43:47.150
如果移动失败的话

43:47.150 --> 43:49.150
那么才结束循环

43:49.150 --> 43:51.150
应该是这样子

43:51.150 --> 43:52.150
向下移动

43:52.150 --> 43:54.150
你看瞬间就下去了

43:54.150 --> 43:55.150
向左向右

43:55.150 --> 43:56.150
这下没做对吧

43:56.150 --> 43:57.150
那么试一下吧

43:57.150 --> 43:59.150
向左向右

43:59.150 --> 44:01.150
向左向右

44:01.150 --> 44:02.150
向左的话

44:02.150 --> 44:04.150
其实就是改一个函数名字

44:04.150 --> 44:06.150
向左向右

44:06.150 --> 44:09.150
好咱们来试一下

44:09.150 --> 44:10.150
向下移动

44:10.150 --> 44:11.150
向左向右

44:11.150 --> 44:12.150
向上没有做

44:12.150 --> 44:14.150
因为向上没有这个方向

44:14.150 --> 44:15.150
向下移动

44:15.150 --> 44:17.150
向左向右

44:17.150 --> 44:18.150
这些东西我们都可以去吧

44:18.150 --> 44:19.150
实现了

44:19.150 --> 44:20.150
好了

44:20.150 --> 44:21.150
那么这节课

44:21.150 --> 44:23.150
我们就搞定这个内

44:23.150 --> 44:24.150
其实这个内里边

44:24.150 --> 44:25.150
还有一些东西

44:25.150 --> 44:26.150
还要处理

44:26.150 --> 44:27.150
这个内的功能很多

44:27.150 --> 44:29.150
比方说因为方块的

44:29.150 --> 44:31.150
规则的变化有很丰富的

44:31.150 --> 44:33.150
比方说还有这个什么旋转

44:33.150 --> 44:34.150
对吧

44:34.150 --> 44:35.150
还有旋转

44:35.150 --> 44:37.150
还要考虑到什么就是

44:37.150 --> 44:39.150
考虑到这个

44:39.150 --> 44:41.150
里边就是这个面板中

44:41.150 --> 44:42.150
已经有方块了

44:42.150 --> 44:44.150
那么不能跟其他方块型重叠

44:44.150 --> 44:46.150
其实都还要处理的

44:46.150 --> 44:48.150
不过我们目前先不管那么多

44:48.150 --> 44:49.150
先把这个移动搞定

44:49.150 --> 44:51.150
移动的规则搞定

44:51.150 --> 44:52.150
好

44:52.150 --> 44:54.150
我们再把这个代码

44:54.150 --> 44:55.150
扭烂一遍

44:55.150 --> 44:56.150
扭烂一遍这个代码

44:56.150 --> 44:58.150
看一下这个代码

44:58.150 --> 44:59.150
扭烂一遍

44:59.150 --> 45:00.150
主要是

45:00.150 --> 45:02.150
这个扭烂过程主要是

45:02.150 --> 45:04.150
帮助你们自己去书写

45:04.150 --> 45:06.150
看一下这个移动代码

45:06.150 --> 45:07.150
好

45:07.150 --> 45:08.150
下边这个

45:08.150 --> 45:09.150
好

45:09.150 --> 45:10.150
这个应这个是代码

45:10.150 --> 45:14.700
看一遍

45:14.700 --> 45:15.700
好了

45:15.700 --> 45:16.700
那么下来过后

45:16.700 --> 45:17.700
这个小爷完成之后

45:17.700 --> 45:18.700
消化

45:18.700 --> 45:19.700
一定要去消化

45:19.700 --> 45:20.700
这些东西

45:20.700 --> 45:21.700
我相信

45:21.700 --> 45:23.700
对很多很多同学

45:23.700 --> 45:24.700
都是有难度的

45:24.700 --> 45:26.700
特别是

45:26.700 --> 45:27.700
我都猜到

45:27.700 --> 45:29.700
问的最多的问题

45:29.700 --> 45:30.700
应该是

45:30.700 --> 45:31.700
老师你的代码

45:31.700 --> 45:32.700
为什么要这样子写

45:32.700 --> 45:33.700
为什么不用另外一种写法

45:33.700 --> 45:34.700
为什么不这样子写

45:34.700 --> 45:35.700
为什么不这样子写

45:35.700 --> 45:37.700
当然写法有很多

45:37.700 --> 45:38.700
这里能不能不用面向对象实现

45:38.700 --> 45:39.700
完全可以

45:39.700 --> 45:41.700
也可以不用面向对象实现

45:41.700 --> 45:43.700
只不过我在讲了面向对象过后

45:43.700 --> 45:45.700
我希望给大家开辟一个思路

45:45.700 --> 45:46.700
那么这个思路

45:46.700 --> 45:47.700
大家一开始理解起来

45:47.700 --> 45:48.700
肯定是有困难的

45:48.700 --> 45:49.700
百分之百有困难

45:49.700 --> 45:50.700
这个毫无疑问

45:50.700 --> 45:52.700
需要一点时间

45:52.700 --> 45:53.700
慢慢去消化

45:53.700 --> 45:54.700
这个课程

45:54.700 --> 45:55.700
不要着急

45:55.700 --> 45:56.700
一下就把这个看完

45:56.700 --> 45:57.700
最多的效果

45:57.700 --> 45:58.700
不要浮躁

45:58.700 --> 45:59.700
每一个小节

45:59.700 --> 46:00.700
讲完了之后

46:00.700 --> 46:01.700
按照我的思维

46:01.700 --> 46:02.700
自己去写一遍

46:02.700 --> 46:03.700
有什么疑问的话

46:03.700 --> 46:04.700
就把这个视频

46:04.700 --> 46:05.700
相应的位置

46:05.700 --> 46:06.700
再去看一遍

46:06.700 --> 46:07.700
保证了

46:07.700 --> 46:08.700
每一个小节

46:08.700 --> 46:09.700
你都把它吃透

46:09.700 --> 46:10.700
理解清楚

46:10.700 --> 46:11.700
然后再看

46:11.700 --> 46:12.700
后边的小节

46:12.700 --> 46:13.700
好吧

46:13.700 --> 46:14.700
那么这以后

46:14.700 --> 46:15.700
就到这里了

46:15.700 --> 46:16.700
拜拜

