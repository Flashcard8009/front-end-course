WEBVTT

00:01.390 --> 00:05.230
Hello 大家好 我是杜英教育 微博前掌讲师 袁晋

00:05.230 --> 00:09.990
这一颗呢 我们继续来制作俄罗斯方块 这么一个项目

00:09.990 --> 00:16.990
这一颗我们要做的功能是开发旋转功能

00:16.990 --> 00:20.390
这个旋转功能呢 我们首先来分析一下

00:20.390 --> 00:24.590
我们把我之前做的这个窗截用程序打开

00:24.590 --> 00:28.190
然后呢 这个程序里边呢 这些俄罗斯方块是可以旋转的

00:28.190 --> 00:29.790
可以这样子旋转的

00:30.190 --> 00:33.390
那么旋转本质上是什么呢 我们来分析一下

00:33.390 --> 00:39.990
旋转的本质啊 其实就是改变它的什么 改变它的形状

00:39.990 --> 00:44.390
对不对 我们看这个之前的俄罗斯方块组合类

00:44.390 --> 00:48.390
你看这个组合类 它里边不是有一个属性形状 对吧

00:48.390 --> 00:52.590
这个属性形状呢 我们知道 当时我们分析的是

00:52.590 --> 00:56.390
如果啊 给他找一个中 找一个中心点

00:56.390 --> 00:59.990
这个中心点的坐标呢 如果是零和零

00:59.990 --> 01:04.990
那么它的其他方块的坐标应该是什么 这是它的形状

01:04.990 --> 01:07.290
用此来描述形状

01:07.290 --> 01:12.690
那么旋转的本质呢 其实就是根据当前的形状

01:12.690 --> 01:16.290
然后呢 产生一个新的形状

01:16.290 --> 01:20.590
所以我们把一个旋转的本质分析出来啊 在这里分析出来

01:20.590 --> 01:27.090
旋转的本质 其实是什么呢 就是根据当前形状

01:27.090 --> 01:31.490
然后呢 产生一个新的形状

01:31.490 --> 01:33.290
这个旋转的本质

01:33.290 --> 01:36.390
所以说呢 旋转本质上就是要改变它这个属性

01:36.390 --> 01:40.790
ok 我们可以在这个方块 这个类里边啊

01:40.790 --> 01:44.790
方块组合这个类里边 写上这么一个函数

01:44.790 --> 01:47.290
这个函数呢 就来帮助我们计算

01:47.290 --> 01:54.090
如何呢 根据当前的形状来进行旋转 产生一个新的形状

01:54.090 --> 01:56.190
它是通过一个计算产生的

01:56.190 --> 01:58.090
我们先不管这个计算是怎么样嘛

01:58.090 --> 02:01.390
我们以后再分析 我们先把这个函数的该写出来

02:01.390 --> 02:03.190
比方写出这么一个函数啊

02:03.190 --> 02:12.290
这个函数呢 该取个名字叫做afterrotateship

02:12.290 --> 02:16.790
就是当我们旋转之后 它产生了新的形状是什么

02:16.790 --> 02:18.290
好 写成这么一个函数啊

02:18.290 --> 02:21.090
这个函数它不需要产数 这个函数做什么呢

02:21.090 --> 02:26.790
我们再再说一次 是根据当前形状计算出新的形状

02:26.790 --> 02:28.790
计算出新的形状

02:28.790 --> 02:33.690
ok 那么根据当前形状计算出新的形状呢

02:33.690 --> 02:37.590
我们这个函数的返回类型应该是什么呢

02:37.590 --> 02:41.090
当前形状我们在函数实现过程中可以获取

02:41.090 --> 02:43.090
比如说这个函数的实现过程中

02:43.090 --> 02:46.590
我们可以通过this shape 对吧

02:46.590 --> 02:50.090
通过这样的方式来获取当前的形状

02:50.090 --> 02:53.090
那么如何来产生一个新的形状呢

02:53.090 --> 02:55.790
那么新的形状它的类型是什么呢

02:55.790 --> 02:57.090
是不是还是shap

02:57.090 --> 02:59.690
因此这个函数的返回类型啊

02:59.690 --> 03:02.090
我们该标注好是shap

03:02.090 --> 03:04.590
根据当前形状this shape

03:04.590 --> 03:08.690
来计算出一个新的形状shap

03:08.690 --> 03:10.690
好 怎么计算呢

03:10.690 --> 03:11.890
那么怎么计算呢

03:11.890 --> 03:15.190
我们首先要明确这么一个情况

03:15.190 --> 03:17.190
就是旋转的时候啊

03:17.190 --> 03:20.690
它到底是顺时针旋转还是历时针旋转

03:20.690 --> 03:22.190
那这个肯定是不一样的对吧

03:22.190 --> 03:24.390
我这里是使用的是顺时针旋转

03:24.390 --> 03:26.990
当然也可以使用历时针旋转

03:26.990 --> 03:28.790
因此为了这个程序呢

03:28.790 --> 03:31.190
更加灵活更加通用

03:31.190 --> 03:32.790
我在旋转的时候啊

03:32.790 --> 03:34.490
在计算新的形状的时候

03:34.490 --> 03:36.290
需要告诉我一个参数

03:36.290 --> 03:38.490
就是旋转的方向啊

03:38.490 --> 03:39.790
旋转的方向

03:39.790 --> 03:41.190
那么一共只有两个方向

03:41.190 --> 03:42.690
一个是顺时针

03:42.690 --> 03:44.590
一个是历时针对吧

03:44.590 --> 03:46.590
那么我们可以用个布尔来表示

03:46.590 --> 03:48.190
用一个布尔来表示

03:49.390 --> 03:52.090
比方说我们可以通过这种方式啊

03:52.090 --> 03:53.290
可以通过这种方式

03:53.290 --> 03:54.790
这里呢

03:54.790 --> 03:56.390
我给它一个属性

03:56.390 --> 03:58.590
把一个属性表示当前

03:58.590 --> 04:00.790
就是下一次的旋转方向

04:00.790 --> 04:01.890
写这么一个属性

04:01.890 --> 04:04.090
下一次的旋转方向

04:04.090 --> 04:06.290
这个属性我们把它是做为private

04:08.090 --> 04:08.790
next

04:10.790 --> 04:12.090
方向

04:12.090 --> 04:13.090
旋转方向

04:13.090 --> 04:15.990
rotate direction

04:15.990 --> 04:18.190
下一次的旋转方向

04:18.190 --> 04:19.590
是不是顺时针

04:19.590 --> 04:20.390
大家看这样的秘密吧

04:20.390 --> 04:21.890
这个秘密太长了

04:21.890 --> 04:23.890
is clock

04:23.890 --> 04:25.690
clock表示时东的意思对吧

04:25.690 --> 04:26.690
如果 is clock

04:26.690 --> 04:28.490
如果这个属性为处

04:28.490 --> 04:29.590
啊如果为处

04:29.590 --> 04:31.690
表示的是旋转的方向

04:31.690 --> 04:32.890
是顺时针

04:32.890 --> 04:33.990
如果为 force

04:33.990 --> 04:36.390
表示旋转的方向是历时针

04:36.390 --> 04:36.990
好

04:36.990 --> 04:38.290
给大家打个注释吧

04:38.290 --> 04:39.690
这个属性表示什么意思呢

04:39.790 --> 04:41.290
旋转方向

04:41.290 --> 04:46.790
旋转方向是否为顺时针

04:48.490 --> 04:49.890
是否为顺时针

04:49.890 --> 04:51.690
通过这个属性来进行判定

04:52.290 --> 04:52.690
好了

04:52.690 --> 04:54.890
我们在这里旋转的时候呢

04:54.890 --> 04:56.690
我们就根据这个属性来判断

04:56.690 --> 04:58.690
它到底是顺时针还是历时针

04:59.190 --> 05:00.690
将来如果有一天

05:00.690 --> 05:03.790
我们这个程序需要把它做成历时针旋转

05:03.790 --> 05:04.390
很简单

05:04.390 --> 05:05.990
我就把它设为 force 就行了

05:05.990 --> 05:06.990
这样做好了

05:06.990 --> 05:08.490
我们以后改动程序

05:08.590 --> 05:09.490
更加通用啊

05:09.490 --> 05:10.390
更加容易改

05:10.390 --> 05:12.090
更加容易改变这个程序

05:13.090 --> 05:13.290
好

05:13.290 --> 05:15.890
我们在这里边写这个函数来实现

05:15.890 --> 05:16.790
那么接下来呢

05:16.790 --> 05:19.690
其实也不叫数学问题吧

05:19.690 --> 05:20.390
这个问题呢

05:20.390 --> 05:22.690
其实就是靠一点逻辑思维

05:22.690 --> 05:23.490
然后靠一下

05:23.490 --> 05:25.290
我们去找一下规矩就可以了

05:26.190 --> 05:28.290
本质上就是得到一个新的形状

05:28.290 --> 05:29.990
那么我们来分析一下啊

05:29.990 --> 05:31.290
分析一下

05:31.290 --> 05:32.990
比方说我们这里画个图

05:34.990 --> 05:37.590
我们现在比方说有这么一个方块啊

05:37.690 --> 05:38.690
有这么一个方块

05:38.690 --> 05:40.090
他有四个方块组成

05:40.090 --> 05:40.690
一

05:42.290 --> 05:44.490
二啊比方个是我们的方块

05:45.990 --> 05:46.590
三

05:47.490 --> 05:49.090
画的不是很好啊

05:49.090 --> 05:50.090
讲究看吧

05:50.090 --> 05:51.990
然后这是个耳朵式方块

05:51.990 --> 05:52.990
中心点在哪呢

05:52.990 --> 05:54.890
中心点在这个这个地方啊

05:54.890 --> 05:56.390
这是他的中心点

05:56.390 --> 05:57.690
然后比方说

05:57.690 --> 05:58.690
顺时针啊

05:58.690 --> 06:00.190
我们先说顺时针

06:00.190 --> 06:02.890
顺时针旋转过后呢

06:02.890 --> 06:04.090
应该是什么呢

06:04.090 --> 06:06.090
应该是这个样子啊

06:06.190 --> 06:07.190
旋转嘛

06:07.190 --> 06:09.290
都是按照中心点来旋转啊

06:09.290 --> 06:10.890
中心点保持不变

06:11.690 --> 06:13.890
中心点的坐标保持不变

06:13.890 --> 06:16.090
然后其他的相对位置呢

06:16.090 --> 06:17.890
发生改变啊

06:17.890 --> 06:19.490
旋转之后是不是这样子

06:19.490 --> 06:20.290
对不对

06:20.290 --> 06:22.490
顺时针旋转之后呢

06:22.490 --> 06:23.690
就变成了这个样子

06:24.690 --> 06:25.590
好了

06:25.590 --> 06:27.090
那么现在呢

06:27.090 --> 06:28.790
我们来分析一下

06:28.790 --> 06:30.690
旋转之前的形状

06:30.690 --> 06:32.690
和旋转之后的形状

06:32.690 --> 06:34.290
那么他们有什么样的规律

06:34.290 --> 06:35.790
我们一个个来说

06:35.790 --> 06:36.690
那比方说

06:36.690 --> 06:39.190
我现在把这个地方呢

06:39.190 --> 06:40.790
字体太大了啊

06:40.790 --> 06:41.990
我把

06:41.990 --> 06:43.590
等一下啊

06:43.590 --> 06:48.780
把这个文字改一下

06:48.780 --> 06:49.780
改不了

06:49.780 --> 06:55.080
这个地方把文字设成微软压

06:55.080 --> 06:57.680
字体大小看一下啊

06:57.680 --> 07:00.570
是吧

07:00.570 --> 07:01.270
好

07:01.270 --> 07:02.870
比方说这是一个方块

07:02.870 --> 07:04.370
A

07:04.370 --> 07:05.570
我们用ABCD

07:05.570 --> 07:07.870
来表示数组的每一项啊

07:07.870 --> 07:08.770
ABCD

07:08.770 --> 07:10.470
来表示数组的每一项

07:10.470 --> 07:12.470
这个是B

07:12.470 --> 07:13.270
B是中心点

07:13.270 --> 07:14.670
对吧

07:14.670 --> 07:16.470
这个是C

07:16.470 --> 07:17.470
这个是D

07:22.020 --> 07:24.420
这个地方是D

07:24.420 --> 07:25.020
好

07:25.020 --> 07:29.220
那么之前旋转之前的数组有四项

07:29.220 --> 07:31.620
数组有四项ABCD

07:31.620 --> 07:32.820
旋转之后呢

07:32.820 --> 07:33.820
A跑哪来了

07:33.820 --> 07:35.420
数组的第一项跑出来了

07:35.420 --> 07:36.020
对吧

07:36.020 --> 07:37.620
数组的第一项跑出来了

07:37.620 --> 07:39.420
第二项的不变

07:39.420 --> 07:40.820
第三项呢

07:40.820 --> 07:42.020
第三项跑哪去了

07:42.020 --> 07:43.220
第三项跑这

07:43.220 --> 07:45.420
第四项跑这来了

07:45.420 --> 07:45.620
好

07:45.620 --> 07:48.620
我们来一次分析一下ABCD

07:48.620 --> 07:50.220
数组的1234项

07:50.220 --> 07:52.620
他们的座标分别是多少

07:52.620 --> 07:52.820
好

07:52.820 --> 07:55.020
来分析一下啊

07:55.020 --> 07:55.320
好

07:55.320 --> 07:57.820
首先A点的座标应该是多少呢

07:57.820 --> 08:01.620
A点的座标旋转之前应该是多少

08:01.620 --> 08:04.320
旋转之前B点肯定是零和零

08:04.320 --> 08:05.420
对吧

08:05.420 --> 08:07.020
B点肯定是零和零

08:07.020 --> 08:08.220
这个没什么好做的

08:08.220 --> 08:09.820
然后B点旋转之后呢

08:09.820 --> 08:11.720
座标它肯定还是零和零

08:11.720 --> 08:12.920
我们形状嘛

08:12.920 --> 08:15.620
形状都是假设中心点为零和零

08:15.620 --> 08:16.320
那么旋转呢

08:16.320 --> 08:17.820
是按照中心点来旋转

08:17.820 --> 08:18.520
因此呢

08:18.520 --> 08:21.220
B点旋转之后还是零和零

08:21.220 --> 08:22.820
没有变化

08:22.820 --> 08:24.420
那么A点呢

08:24.420 --> 08:26.320
A点旋转之后

08:26.320 --> 08:27.120
我们来看一下

08:27.120 --> 08:30.720
A点旋转之前是零和多少

08:30.720 --> 08:32.320
-1对不对

08:32.320 --> 08:35.120
A点旋转之前是零和-1

08:35.120 --> 08:36.820
那么旋转之后呢

08:36.820 --> 08:39.120
A点是多少了变成多少了

08:39.120 --> 08:40.820
A点变成了

08:40.820 --> 08:45.720
1和零对不对

08:45.720 --> 08:48.220
然后C点再看一下

08:48.220 --> 08:51.320
C点的话旋转之前是多少

08:51.320 --> 08:53.520
是不是零和1

08:53.520 --> 08:56.520
那么C点旋转之后呢

08:56.520 --> 08:59.620
-1和零

08:59.620 --> 09:05.920
然后D点旋转之前是-1零

09:05.920 --> 09:08.420
旋转之后多少

09:08.420 --> 09:10.820
旋转旋转之后D点

09:10.820 --> 09:11.420
那么多少呢

09:11.420 --> 09:12.520
你看这边啊

09:12.520 --> 09:13.720
就D点

09:13.720 --> 09:18.420
就应该是零和-1

09:18.420 --> 09:20.620
能不能找出规律啊

09:20.620 --> 09:22.620
之前的点的坐标

09:22.620 --> 09:25.220
在旋转之后

09:25.220 --> 09:28.020
新的坐标能不能找出规律

09:28.020 --> 09:29.420
这规律就出来了

09:29.420 --> 09:30.720
这规律是啥

09:30.720 --> 09:32.120
这规律就是

09:32.120 --> 09:36.620
如果把X当做横坐标

09:36.620 --> 09:38.520
Y当做重坐标的话

09:38.520 --> 09:40.620
那么旋转之后

09:40.620 --> 09:42.120
它的坐标应该是多少

09:42.120 --> 09:46.320
是不是-Y然后X

09:46.320 --> 09:47.520
想一想对不对

09:47.520 --> 09:48.920
就这样子

09:48.920 --> 09:49.120
好

09:49.120 --> 09:50.720
既然这样子的话

09:50.720 --> 09:51.420
于是呢

09:51.420 --> 09:53.120
这个其实规律很好找

09:53.120 --> 09:55.120
如果你是顺时针旋转

09:55.120 --> 09:56.220
很简单

09:56.220 --> 09:59.420
我把你之前的Y坐标变成-4

09:59.420 --> 10:01.520
然后把它当成横坐标

10:01.520 --> 10:02.920
把之前的横坐标标呢

10:02.920 --> 10:04.120
直接当成重坐标

10:04.120 --> 10:05.520
就完事了

10:05.620 --> 10:06.820
所以说这里呢

10:06.820 --> 10:09.420
写法非常非常简单

10:09.420 --> 10:10.420
判断一下

10:10.420 --> 10:11.620
判断一下

10:11.620 --> 10:12.420
如果

10:13.720 --> 10:15.320
This is clock

10:15.320 --> 10:17.720
如果是顺时针旋转

10:17.720 --> 10:21.220
那么返回的新的形状应该是啥呢

10:21.220 --> 10:23.020
返回的新的形状应该是啥呢

10:23.020 --> 10:26.420
就是根据当前的形状产生的

10:26.420 --> 10:27.620
形状是啥

10:27.620 --> 10:28.720
指着它看一下

10:28.720 --> 10:30.420
形状就是一个坐标的素组

10:30.420 --> 10:31.220
对不对

10:31.220 --> 10:32.720
你看这里是不是个坐标的素组

10:32.720 --> 10:33.720
ABCD

10:33.820 --> 10:35.320
每一个点就是个坐标

10:35.320 --> 10:36.420
对不对

10:36.420 --> 10:37.320
那么这个sharp

10:37.320 --> 10:38.820
就是个坐标的素组

10:38.820 --> 10:40.320
我把这个坐标的素组呢

10:40.320 --> 10:42.020
重新通过map

10:42.020 --> 10:44.120
来重新映射一下

10:44.120 --> 10:45.520
重新映射一下

10:45.520 --> 10:48.020
每一个素组的每一项就是个坐标

10:48.020 --> 10:48.620
你看

10:48.620 --> 10:50.120
素组的每一项p

10:50.120 --> 10:50.820
就是个坐标

10:50.820 --> 10:51.420
pointer

10:51.420 --> 10:53.120
它有类型推导

10:53.120 --> 10:54.620
把这个素组的

10:54.620 --> 10:55.920
每一项拿过来

10:55.920 --> 10:57.220
把它坐标拿过来

10:57.220 --> 11:00.020
返回一个新的坐标

11:00.020 --> 11:01.420
什么新的坐标呢

11:01.420 --> 11:03.220
返回的新的坐标呢

11:03.220 --> 11:05.320
它的X坐标

11:05.320 --> 11:07.520
看pointer

11:07.520 --> 11:09.120
pointer的里面的

11:09.120 --> 11:10.820
我看pointer里面的

11:10.820 --> 11:12.920
就是两个属性

11:12.920 --> 11:14.020
一个是XY对吧

11:14.020 --> 11:15.520
就是XY

11:15.520 --> 11:18.320
那么X坐标等于多少

11:18.320 --> 11:18.820
等于多少

11:18.820 --> 11:22.020
或者是我们这里推导一下

11:22.020 --> 11:23.320
我们这个样子也行

11:23.320 --> 11:24.420
因为它这样子写的话

11:24.420 --> 11:25.820
它没有提示

11:25.820 --> 11:26.320
它也不知道

11:26.320 --> 11:27.520
连返回什么东西

11:27.520 --> 11:29.720
我们可以这样子写

11:29.720 --> 11:31.020
这样子写

11:32.020 --> 11:33.420
跟它约束一下

11:33.420 --> 11:35.120
它是一个point

11:35.120 --> 11:37.220
那么这里它有提示的

11:37.220 --> 11:38.320
X坐标

11:38.320 --> 11:40.420
X坐标是多少呢

11:40.420 --> 11:41.820
按照刚才的分析

11:41.820 --> 11:43.820
应该是-Y对不对

11:43.820 --> 11:46.320
它原来的坐标的Y坐标

11:46.320 --> 11:49.120
-p.Y

11:49.120 --> 11:51.120
然后Y坐标是多少呢

11:51.120 --> 11:55.120
Y坐标是p.X

11:55.120 --> 11:56.320
这就是新的坐标

11:56.320 --> 11:58.620
然后我们把这个新的坐标返回

11:58.620 --> 12:00.420
新的坐标返回

12:00.420 --> 12:02.120
然后得到一个新的数组

12:02.120 --> 12:03.320
得到这个新的数组

12:03.320 --> 12:06.020
就是旋转之后的数组

12:06.020 --> 12:07.720
好 我们这里直接轮趟

12:07.720 --> 12:09.320
直接轮趟

12:09.320 --> 12:12.120
就把这个新的数组返回

12:12.120 --> 12:14.420
因此这是顺时针旋转

12:14.420 --> 12:16.720
然后再看历时针旋转

12:16.720 --> 12:19.220
是不是应该你想象都能想象得到

12:19.220 --> 12:21.020
应该是差不多的对不对

12:21.020 --> 12:22.320
应该是差不多的

12:22.320 --> 12:23.720
那比方说这里

12:23.720 --> 12:25.220
那就从这边到这边吧

12:25.220 --> 12:26.620
从这边到这边

12:26.620 --> 12:28.220
从右边到左边

12:28.220 --> 12:31.020
就是历时针旋转

12:31.020 --> 12:32.220
历时针旋转的话

12:32.220 --> 12:33.220
我们又来分析一下

12:33.220 --> 12:34.020
分析一两个点

12:34.020 --> 12:35.520
其实就差不多了

12:35.520 --> 12:37.420
A一开始的坐标是多少

12:37.420 --> 12:38.720
1和0

12:38.720 --> 12:40.620
旋转之后呢

12:40.620 --> 12:44.520
A的坐标是0和-1

12:44.520 --> 12:46.020
能理解吗

12:46.020 --> 12:48.220
然后C之前的坐标是多少

12:48.220 --> 12:49.920
-1和0

12:49.920 --> 12:53.820
然后旋转之后呢是0和1

12:53.820 --> 12:55.320
不写了吧

12:55.320 --> 12:56.020
D是多少呢

12:56.020 --> 12:57.420
D之前

12:57.420 --> 12:59.220
是0和-1

12:59.220 --> 13:00.620
旋转之后呢

13:00.620 --> 13:02.820
是-1和0

13:02.820 --> 13:05.020
那么如果之前是xy

13:05.020 --> 13:06.620
之后是多少

13:06.620 --> 13:07.520
是多少

13:07.520 --> 13:12.220
就是y-x

13:12.220 --> 13:12.820
对不对

13:12.820 --> 13:14.420
是这样子

13:14.420 --> 13:15.820
y直接不变拿过来

13:15.820 --> 13:18.220
然后x变成-2

13:18.220 --> 13:19.520
所以说这里很简单

13:19.520 --> 13:22.620
如果是历时针旋转的话

13:22.620 --> 13:23.620
那么这里

13:23.620 --> 13:25.620
如果是历时针旋转

13:25.620 --> 13:27.420
因此这里得到的形状

13:27.420 --> 13:29.220
就是x等于多少呢

13:29.220 --> 13:31.620
等于p点y

13:31.620 --> 13:32.420
y坐标呢

13:32.420 --> 13:33.220
新的y坐标呢

13:33.220 --> 13:35.620
等于-4的px

13:35.620 --> 13:37.020
就完事了

13:37.020 --> 13:38.520
这就是旋转之后

13:38.520 --> 13:41.220
来得到一个新的形状

13:41.220 --> 13:41.420
好

13:41.420 --> 13:42.620
我们来测试一下

13:42.620 --> 13:43.820
来测试一下

13:43.820 --> 13:44.720
看一下旋转之后

13:44.720 --> 13:45.820
得到新的形状

13:45.820 --> 13:47.420
正不正确

13:47.420 --> 13:48.020
这里呢

13:48.020 --> 13:49.120
我们再加个按钮

13:49.120 --> 13:51.020
在页面上

13:51.020 --> 13:53.420
加个按钮

13:53.420 --> 13:58.420
id为rotate旋转

13:58.420 --> 14:00.620
当然我们这里旋转呢

14:00.620 --> 14:02.220
可以来个顺时针旋转

14:02.220 --> 14:04.720
顺时针旋转

14:04.720 --> 14:08.220
可以来一个历时针旋转

14:08.220 --> 14:10.720
rotate clock

14:10.720 --> 14:15.720
历时针rotate anti clock

14:15.720 --> 14:16.520
是这样写吧

14:16.520 --> 14:18.220
应该是

14:18.220 --> 14:20.820
anti表示它相反的意思

14:21.020 --> 14:21.820
历时针旋转

14:25.220 --> 14:25.620
好

14:25.620 --> 14:26.620
写这么两个按钮

14:26.620 --> 14:28.020
我们来测试一下

14:28.020 --> 14:29.320
测试一下这两个旋转

14:29.320 --> 14:30.220
它得到的坐标

14:30.220 --> 14:31.620
我们现在只是在计算

14:31.620 --> 14:33.420
还没有去改变界面

14:33.420 --> 14:34.320
只是在计算

14:34.320 --> 14:35.220
看计算出来结构

14:35.220 --> 14:36.420
对不对

14:36.420 --> 14:37.020
这里呢

14:37.020 --> 14:38.020
我们通过

14:40.420 --> 14:48.420
btnrotate clock

14:49.420 --> 14:51.420
给它注册点击时间

14:51.420 --> 14:53.420
在点击时间里边

14:53.420 --> 14:55.420
我们看一下写对不对

14:55.420 --> 14:57.420
点击时间里边

14:57.420 --> 14:59.420
我们找到这个terrors

14:59.420 --> 15:00.420
它不是一个函数吗

15:00.420 --> 15:03.420
after rotate shape

15:03.420 --> 15:05.420
进行旋转

15:05.420 --> 15:06.420
进行旋转

15:06.420 --> 15:07.420
我们试一下

15:07.420 --> 15:09.420
我刚才直接用一个就行了

15:09.420 --> 15:11.420
因为它的顺时针历时针

15:11.420 --> 15:12.420
外面是没法控制的

15:12.420 --> 15:14.420
那个顺时针历时针

15:14.420 --> 15:15.420
是在内里边控制的

15:15.420 --> 15:16.420
外面是没法控制的

15:16.420 --> 15:17.420
我就写一个就行了

15:18.420 --> 15:20.420
得到一个新的形状

15:20.420 --> 15:22.420
那么我们把形状输出

15:30.420 --> 15:31.420
打印出来

15:31.420 --> 15:32.420
保存看一下

15:32.420 --> 15:37.180
看一下它输出的结果

15:37.180 --> 15:38.180
顺时针旋转

15:38.180 --> 15:39.180
点旋转

15:39.180 --> 15:42.180
它之后的坐标是多少呢

15:42.180 --> 15:46.180
是-00-1-1-1

15:46.180 --> 15:48.180
那么它之前的坐标

15:48.180 --> 15:49.180
我一把打出来

15:49.180 --> 15:51.180
我把它之前的坐标打出来

15:51.180 --> 15:53.180
就是terrors

15:53.180 --> 15:55.180
第二

15:55.180 --> 15:57.180
把之前的坐标打出来

15:57.180 --> 15:58.180
把之后的坐标打出来

15:58.180 --> 16:01.680
我们来看一下

16:01.680 --> 16:04.680
这里点顺时针旋转

16:04.680 --> 16:06.680
大家看一下

16:06.680 --> 16:07.680
对比一下

16:07.680 --> 16:08.680
这两个坐标系

16:08.680 --> 16:09.680
对比一下

16:09.680 --> 16:10.680
然后结合图形

16:10.680 --> 16:11.680
对比一下

16:11.680 --> 16:13.680
它的中心点在这

16:13.680 --> 16:15.680
它的中心点在这

16:15.680 --> 16:16.680
第二个

16:16.680 --> 16:17.680
那么你看一下

16:17.680 --> 16:18.680
旋转之后

16:18.680 --> 16:20.680
你看大佬里边想一想

16:20.680 --> 16:21.680
旋转之后

16:21.680 --> 16:22.680
它的坐标对不对

16:22.680 --> 16:24.680
对比一下

16:24.680 --> 16:26.680
你经过仔细的对比的话

16:26.680 --> 16:28.680
你发现它的坐标是没问题的

16:28.680 --> 16:29.680
那么说明

16:29.680 --> 16:31.680
我们这个旋转是没问题的

16:31.680 --> 16:32.680
写都要的

16:32.680 --> 16:33.680
然后呢

16:33.680 --> 16:34.680
我们在这边

16:34.680 --> 16:36.680
再把它改成

16:36.680 --> 16:37.680
再把它改成

16:37.680 --> 16:38.680
历史人

16:38.680 --> 16:39.680
把它改成force

16:39.680 --> 16:40.680
历史人旋转

16:40.680 --> 16:42.680
再来试一下

16:42.680 --> 16:43.680
这里

16:43.680 --> 16:44.680
这个

16:44.680 --> 16:45.680
把它改了

16:45.680 --> 16:48.510
就是旋转

16:48.510 --> 16:50.510
点击旋转

16:50.510 --> 16:51.510
两个坐标系

16:51.510 --> 16:52.510
你看一下

16:52.510 --> 16:54.510
得到了新的坐标

16:54.510 --> 16:55.510
对比一下

16:55.510 --> 16:56.510
在头标里面想一下

16:56.510 --> 16:58.510
现在是历史人旋转

16:58.510 --> 16:59.510
旋转之后

16:59.510 --> 17:00.510
它的中心点在这

17:00.510 --> 17:02.510
它的中心点在这

17:02.510 --> 17:04.510
我这里有印象

17:04.510 --> 17:05.510
它的中心点是在这的

17:05.510 --> 17:06.510
旋转之后

17:06.510 --> 17:07.510
你想一想

17:07.510 --> 17:09.510
是不是这个坐标系

17:09.510 --> 17:10.510
你觉得

17:10.510 --> 17:11.510
测试出来

17:11.510 --> 17:12.510
你觉得

17:12.510 --> 17:13.510
如果觉得

17:13.510 --> 17:14.510
得到了坐标系

17:14.510 --> 17:16.510
得到这个新的形状

17:16.510 --> 17:17.510
没有问题了

17:17.510 --> 17:18.510
OK

17:18.510 --> 17:20.510
那么我们就继续来写

17:20.510 --> 17:21.510
把这个理由想通

17:21.510 --> 17:22.510
这个其实

17:22.510 --> 17:23.510
也没有多复杂

17:23.510 --> 17:24.510
就是你

17:24.510 --> 17:26.510
着急下规律就行了

17:26.510 --> 17:27.510
关键点

17:27.510 --> 17:28.510
你要想到这一点

17:28.510 --> 17:29.510
就是

17:29.510 --> 17:30.510
旋转的本质

17:30.510 --> 17:32.510
就是得到一个新的形状

17:32.510 --> 17:35.510
有了这个函数之后

17:35.510 --> 17:37.510
我们要实现真正的旋转

17:37.510 --> 17:39.510
就非常非常简单了

17:39.510 --> 17:40.510
我们来再来写个函数

17:40.510 --> 17:41.510
rotate

17:41.510 --> 17:43.510
就是旋转

17:43.510 --> 17:45.510
刚才那个是帮我们计算

17:45.510 --> 17:46.510
旋转之后的形状

17:46.510 --> 17:47.510
那么现在呢

17:47.510 --> 17:49.510
我们要实现真正的旋转

17:49.510 --> 17:50.510
怎么实现的

17:50.510 --> 17:52.510
实现真正的旋转

17:52.510 --> 17:54.510
是不是就是雕用这个函数

17:54.510 --> 17:55.510
对不对

17:55.510 --> 17:57.510
雕用这个函数

17:57.510 --> 17:59.510
来得到啥呢

17:59.510 --> 18:01.510
得到这个新的形状

18:01.510 --> 18:03.510
nu shape

18:03.510 --> 18:05.510
得到新的形状

18:05.510 --> 18:07.510
得到新的形状之后呢

18:07.510 --> 18:09.510
然后怎么办

18:09.510 --> 18:11.510
就把这个新的形状

18:11.510 --> 18:13.510
是不是负责给旧的形状了

18:13.510 --> 18:14.510
把新的形状

18:14.510 --> 18:16.510
负责给旧的形状

18:16.510 --> 18:18.510
z shape

18:18.510 --> 18:21.510
nu shape

18:21.510 --> 18:23.510
稍微一

18:23.510 --> 18:24.510
就把新的形状

18:24.510 --> 18:26.510
负责给旧的形状

18:26.510 --> 18:27.510
那么接下来

18:27.510 --> 18:28.510
我们写了这个函数之后呢

18:28.510 --> 18:30.510
我们再来测试一下

18:30.510 --> 18:32.510
再来测试一下

18:32.510 --> 18:33.510
点击这个按钮

18:33.510 --> 18:34.510
我们现在就实现

18:34.510 --> 18:35.510
真正的旋转了

18:35.510 --> 18:36.510
就不是光是计算了

18:36.510 --> 18:37.510
我们要实现

18:37.510 --> 18:39.510
形状的改变

18:39.510 --> 18:41.510
terrors

18:41.510 --> 18:42.510
rotate

18:42.510 --> 18:43.510
旋转

18:43.510 --> 18:44.510
你去旋转吧

18:44.510 --> 18:46.510
保存

18:46.510 --> 18:47.510
好

18:47.510 --> 18:48.510
当我们旋转的时候

18:48.510 --> 18:50.510
我们换个方块

18:50.510 --> 18:52.510
旋转的时候

18:52.510 --> 18:54.510
点了过后没反应

18:54.510 --> 18:56.510
那么我们这里要分析一下

18:56.510 --> 18:57.510
为什么没反应呢

18:57.510 --> 18:59.510
我们确实点了

18:59.510 --> 19:01.510
没有任何反应

19:01.510 --> 19:03.510
为什么没反应呢

19:03.510 --> 19:05.510
我们之前测试过这个函数

19:05.510 --> 19:06.510
这个函数已经测试过

19:06.510 --> 19:07.510
是正确的

19:07.510 --> 19:08.510
得到了新的形状

19:08.510 --> 19:09.510
那么下面的负责

19:09.510 --> 19:10.510
就肯定没有什么问题

19:10.510 --> 19:12.510
这个是一个简单的负责

19:12.510 --> 19:13.510
拉了有啥问题呢

19:13.510 --> 19:15.510
肯定没有什么问题

19:15.510 --> 19:17.510
那问题在哪呢

19:17.510 --> 19:18.510
仔细想一想

19:18.510 --> 19:20.510
我们还少了一个东西

19:20.510 --> 19:23.510
就是你把形状负责完了

19:23.510 --> 19:26.510
这里只是一个形状而已

19:26.510 --> 19:28.510
真正要负责的是啥

19:28.510 --> 19:31.510
真正要负责的是这些squares

19:31.510 --> 19:33.510
是这些方块

19:33.510 --> 19:35.510
真正要处理的是这些方块

19:35.510 --> 19:37.510
中心点作为没有变化

19:37.510 --> 19:39.510
中心点的旋转的话

19:39.510 --> 19:41.510
不会导致中心点作为发生变化

19:41.510 --> 19:43.510
因此我们真正要处理的是

19:43.510 --> 19:45.510
这些方块的作标

19:45.510 --> 19:47.510
就是这些方块的作标

19:47.510 --> 19:49.510
那么这些方块的作标怎么处理呢

19:49.510 --> 19:51.510
跟之前的一样

19:51.510 --> 19:52.510
我们只不过的代码

19:52.510 --> 19:53.510
显得比较久了

19:53.510 --> 19:54.510
可能大家忘了

19:54.510 --> 19:55.510
就是你看

19:55.510 --> 19:57.510
之前设置中心点的时候

19:57.510 --> 19:59.510
是不是要一次去设置

19:59.510 --> 20:01.510
每一个小方块的作标

20:01.510 --> 20:02.510
对不对

20:02.510 --> 20:04.510
设置中心点的时候

20:04.510 --> 20:05.510
要一次去设置

20:05.510 --> 20:07.510
每一个小方块的作标

20:07.510 --> 20:09.510
因此这里是一样的

20:09.510 --> 20:11.510
我们

20:11.510 --> 20:13.510
可以把一个代码复制一下

20:13.510 --> 20:15.510
其实我们干脆把这个东西

20:15.510 --> 20:16.510
写成一个函数吧

20:16.510 --> 20:17.510
直接把它写成一个函数

20:17.510 --> 20:18.510
就完事了

20:18.510 --> 20:20.510
设置每一个小方块的作标

20:20.510 --> 20:22.510
写成一个私有的函数

20:22.510 --> 20:23.510
我们需要设置的时候

20:23.510 --> 20:24.510
就去调用一下

20:24.510 --> 20:28.510
set square points

20:28.510 --> 20:30.510
把它写成一个函数

20:30.510 --> 20:33.510
这是根据中心点

20:33.510 --> 20:37.510
作标以及形状

20:37.510 --> 20:42.510
设置每一个小方块的作标

20:42.510 --> 20:43.510
把之前提去出来

20:43.510 --> 20:44.510
因为我发现这个函数

20:44.510 --> 20:45.510
当初来用

20:45.510 --> 20:46.510
你看之前构造函数里面

20:46.510 --> 20:48.510
也在做这个事

20:48.510 --> 20:49.510
构造函数里面也在做这个事

20:49.510 --> 20:50.510
因此我们这里

20:50.510 --> 20:53.510
可以把它提成一个

20:53.510 --> 20:55.510
公共的函数

20:55.510 --> 20:56.510
把私有化

20:56.510 --> 20:57.510
只能内部调用

20:57.510 --> 21:00.510
整个作用其实就是这里

21:00.510 --> 21:02.510
得到这个形状

21:02.510 --> 21:05.510
然后给这个形状循环

21:05.510 --> 21:08.510
循环形状的每一个作标点

21:08.510 --> 21:10.510
以及它的锁印

21:10.510 --> 21:13.510
因为它的锁印跟小方块的锁印

21:13.510 --> 21:14.510
是一致的

21:14.510 --> 21:16.510
所以我们还得到它的锁印

21:16.510 --> 21:18.510
然后拿到每一个小方块

21:18.510 --> 21:20.510
设置每一个小方块的作标的云啥呢

21:20.510 --> 21:24.510
等于当前的中心点作标

21:24.510 --> 21:27.510
x加上形状的作标

21:27.510 --> 21:28.510
x

21:28.510 --> 21:29.510
就是之前写的代码

21:29.510 --> 21:30.510
也好好去理一下

21:30.510 --> 21:31.510
回忆一下

21:31.510 --> 21:33.510
之前写的代码

21:33.510 --> 21:35.510
有了这个函数之后

21:35.510 --> 21:36.510
那就好办了

21:36.510 --> 21:37.510
我这里

21:37.510 --> 21:39.510
就直接调用这个函数

21:39.510 --> 21:40.510
设置小方块的作标

21:40.510 --> 21:42.510
set square points

21:42.510 --> 21:43.510
好那么这里

21:43.510 --> 21:44.510
构造函数这里

21:44.510 --> 21:46.510
我这里也不用写了

21:46.510 --> 21:47.510
我这里也不用写了

21:47.510 --> 21:51.510
设置好形状之后

21:51.510 --> 21:52.510
我们在最后

21:52.510 --> 21:54.510
给它加上这么一个函数调用

21:54.510 --> 21:55.510
就完事了

21:55.510 --> 21:57.510
set square points

21:57.510 --> 21:58.510
就完事了

21:58.510 --> 21:59.510
那么这里也是一样

21:59.510 --> 22:00.510
设置好了形状过后

22:00.510 --> 22:01.510
我们调用一下

22:01.510 --> 22:03.510
这个set square points

22:03.510 --> 22:05.510
就把这些重做代码提出来

22:05.510 --> 22:06.510
提成一个函数

22:06.510 --> 22:08.510
好咱们再来看一下

22:08.510 --> 22:10.510
好 旋转

22:10.510 --> 22:12.510
你看 是不是旋转了

22:12.510 --> 22:14.510
现在是按照顺时针方向在旋转

22:14.510 --> 22:16.510
按照顺时针方向在旋转

22:16.510 --> 22:19.840
OK

22:19.840 --> 22:21.840
好 这是旋转

22:21.840 --> 22:22.840
那么再换一个方块看一下

22:22.840 --> 22:23.840
换一个方块

22:23.840 --> 22:28.630
旋转

22:28.630 --> 22:29.630
现在就在旋转了

22:29.630 --> 22:33.540
看到没

22:33.540 --> 22:34.540
好 现在

22:34.540 --> 22:35.540
我们搞定了旋转功能

22:35.540 --> 22:37.540
它现在是历时针

22:37.540 --> 22:39.540
我之前发誓了

22:39.540 --> 22:41.540
再看一下顺时针

22:41.540 --> 22:43.540
顺时针

22:43.540 --> 22:45.540
这个看得比较清楚了

22:45.540 --> 22:46.540
顺时针旋转

22:46.540 --> 22:49.880
好

22:49.880 --> 22:50.880
那么现在

22:50.880 --> 22:51.880
我们搞定了

22:51.880 --> 22:54.880
这个旋转的功能

22:54.880 --> 22:56.880
接下来还有什么事情要做呢

22:56.880 --> 22:57.880
实际上呢

22:57.880 --> 23:00.880
还有两件事情要处理

23:00.880 --> 23:02.880
这两件事情处理起来

23:02.880 --> 23:06.880
还不是那么的容易

23:06.880 --> 23:07.880
当然也不会很复杂

23:07.880 --> 23:08.880
也不会很复杂

23:08.880 --> 23:11.880
只是在我们的内的结构上

23:11.880 --> 23:13.880
可能会发生一些变动

23:13.880 --> 23:15.880
好 第一个问题

23:15.880 --> 23:17.880
什么问题呢

23:17.880 --> 23:22.880
有些方块是不旋转的

23:22.880 --> 23:25.880
哪个方块是不旋转的呢

23:25.880 --> 23:26.880
我过俄罗斯方块的话

23:26.880 --> 23:27.880
你会发现

23:27.880 --> 23:29.880
其中有些方块是不旋转的

23:29.880 --> 23:31.880
我们看一下

23:31.880 --> 23:33.880
这里看能不能随机出来

23:33.880 --> 23:34.880
这个方块

23:34.880 --> 23:35.880
你看这个方块

23:35.880 --> 23:37.880
这个方块是不旋转的

23:37.880 --> 23:38.880
那有些同学可能会觉得

23:38.880 --> 23:40.880
旋转也没事啊

23:40.880 --> 23:43.880
旋转就可能会出现一些麻烦

23:43.880 --> 23:45.880
你点击旋转看一下

23:45.880 --> 23:46.880
怎么会这样

23:46.880 --> 23:47.880
怎么会变成这样子的

23:47.880 --> 23:48.880
它怎么到处跑啊

23:48.880 --> 23:50.880
这怎么回事呢

23:50.880 --> 23:52.880
因为它的中心点在哪儿啊

23:52.880 --> 23:54.880
大家看中心点在哪儿

23:54.880 --> 23:56.880
中心点在这个位置

23:56.880 --> 23:58.880
在这个位置

23:58.880 --> 24:00.880
这是它的中心点

24:00.880 --> 24:01.880
所以说呢

24:01.880 --> 24:03.880
按照这个中心点来旋转的话

24:03.880 --> 24:04.880
就会很怪

24:04.880 --> 24:05.880
那有些同学问

24:05.880 --> 24:06.880
为什么不把这个点

24:06.880 --> 24:07.880
作为中心点

24:07.880 --> 24:08.880
注意

24:08.880 --> 24:10.880
我们整个俄罗斯方块

24:10.880 --> 24:12.880
是一个小块

24:12.880 --> 24:14.880
一个小块就是最小单位了

24:14.880 --> 24:16.880
它不存在真正意义上的一个点

24:16.880 --> 24:17.880
明白这个意思吗

24:17.880 --> 24:20.880
它一个小块就是最小单位了

24:20.880 --> 24:21.880
所以说

24:21.880 --> 24:23.880
我们总归要给一个小块

24:23.880 --> 24:24.880
作为中心点

24:24.880 --> 24:25.880
那么这种形状呢

24:25.880 --> 24:26.880
是没有

24:26.880 --> 24:28.880
这个中心点是不好给的

24:28.880 --> 24:30.880
不是很容易给

24:30.880 --> 24:31.880
那么给的时候

24:31.880 --> 24:32.880
我只能试个点中

24:32.880 --> 24:33.880
随便选一个作为中心点

24:33.880 --> 24:34.880
那么像这种方块

24:34.880 --> 24:36.880
旋转起来就感觉很怪

24:36.880 --> 24:39.880
因此有些方块是不旋转的

24:39.880 --> 24:41.880
那么还有一种情况是

24:41.880 --> 24:43.880
有些方块

24:43.880 --> 24:45.880
旋转时

24:45.880 --> 24:50.380
只有两种状态

24:50.380 --> 24:52.380
只有两种状态

24:52.380 --> 24:53.380
什么意思呢

24:53.380 --> 24:55.380
就比方说这个方块

24:55.380 --> 24:57.380
看能不能水移出来

24:57.380 --> 24:58.380
比方这个方块也是一样

24:58.380 --> 24:59.380
它旋转的时候

24:59.380 --> 25:01.380
比方说旋转

25:01.380 --> 25:02.380
这个没什么问题

25:02.380 --> 25:04.380
按照这个中心点为旋转

25:04.380 --> 25:07.380
那么在旋转的时候

25:07.380 --> 25:08.380
它变成这个样子的

25:08.380 --> 25:09.380
大家仔细看

25:09.380 --> 25:11.380
这个不是很舒服的

25:11.380 --> 25:12.380
你看了没

25:12.380 --> 25:13.380
这是横向的

25:13.380 --> 25:17.380
横向的左边有两个空白

25:17.380 --> 25:19.380
这个是横向的

25:19.380 --> 25:20.380
左边只有一个空白

25:20.380 --> 25:22.380
一般这个意思吗

25:22.380 --> 25:23.380
再看

25:23.380 --> 25:26.380
横向的两个空白

25:26.380 --> 25:27.380
横向的一个空白

25:27.380 --> 25:29.380
这个中向的顶部

25:29.380 --> 25:31.380
是抵到边了

25:31.380 --> 25:33.380
然后这个也是中向

25:33.380 --> 25:34.380
顶部了一个空白

25:34.380 --> 25:35.380
那么像这种方块

25:35.380 --> 25:37.380
其实它只有两种情况

25:37.380 --> 25:38.380
一个横着

25:38.380 --> 25:39.380
一个是竖着

25:39.380 --> 25:40.380
一个是竖着

25:40.380 --> 25:42.380
还有一种方块也是一样

25:42.380 --> 25:43.380
像这个方块也是一样

25:43.380 --> 25:44.380
旋转运气好

25:44.380 --> 25:46.380
我这里谁都想得到

25:46.380 --> 25:48.380
自己想要的方块

25:48.380 --> 25:49.380
它是按照这个点来旋转

25:49.380 --> 25:50.380
大家看一下

25:50.380 --> 25:51.380
这个点不动

25:51.380 --> 25:52.380
旋转

25:52.380 --> 25:54.380
变成这个样子

25:54.380 --> 25:55.380
没问题吧

25:55.380 --> 25:57.380
然后再旋转

25:57.380 --> 25:58.380
好

25:58.380 --> 26:00.380
你感觉跟之前的

26:00.380 --> 26:02.380
最开始的那个形状是一样的

26:02.380 --> 26:03.380
它跑上面去了

26:03.380 --> 26:05.380
所以说像有些方块

26:05.380 --> 26:06.380
它只有两种状态

26:06.380 --> 26:07.380
这两种状态的话

26:07.380 --> 26:08.380
那么也就是说

26:08.380 --> 26:10.380
它的旋转方式是这样子的

26:10.380 --> 26:11.380
先顺时针

26:11.380 --> 26:13.380
下一次旋转就立时针

26:13.380 --> 26:14.380
先顺时针

26:14.380 --> 26:16.380
下一次旋转就立时针

26:16.380 --> 26:18.380
它是用这种方式来进行旋转的

26:18.380 --> 26:20.380
你感觉这个意思吗

26:20.380 --> 26:21.380
所以说呢

26:21.380 --> 26:23.380
像这种旋转

26:23.380 --> 26:24.380
像这种方式

26:24.380 --> 26:26.380
旋转它是有很多种情况的

26:26.380 --> 26:28.380
要有的时候可能不旋转

26:28.380 --> 26:29.380
有的时候

26:29.380 --> 26:32.380
可能要不断的去改变它的旋转方向

26:32.380 --> 26:33.380
一会儿顺时针

26:33.380 --> 26:34.380
一会儿立时针

26:34.380 --> 26:37.380
那么这种情况如何处理呢

26:37.380 --> 26:38.380
这种情况如何处理

26:38.380 --> 26:40.380
我先把这个问题搞定

26:40.380 --> 26:41.380
这种情况呢

26:41.380 --> 26:44.380
你当然可以在这里边写个属性

26:44.380 --> 26:46.380
表示是否旋转这个属性

26:46.380 --> 26:47.380
写这么一个属性

26:47.380 --> 26:49.380
来处理这个问题

26:49.380 --> 26:50.380
那么会把

26:50.380 --> 26:51.380
但是你这样做的话

26:51.380 --> 26:53.380
会把这个内搞得非常非常复杂

26:53.380 --> 26:54.380
这个本来就是

26:54.380 --> 26:57.380
只做一个最简单的事情

26:57.380 --> 26:58.380
我让它去做这个旋转

26:58.380 --> 27:00.380
就已经很够意思了

27:00.380 --> 27:01.380
你还要去关心

27:01.380 --> 27:02.380
那么多的逻辑的情况

27:02.380 --> 27:04.380
不同的方块的情况

27:04.380 --> 27:05.380
那么这样子做呢

27:05.380 --> 27:06.380
会变得很复杂

27:06.380 --> 27:07.380
因此呢

27:07.380 --> 27:08.380
我不打算去改动这个内了

27:08.380 --> 27:10.380
这个内我不打算动了

27:10.380 --> 27:12.380
那我这里会怎么处理呢

27:12.380 --> 27:14.380
我这里会用这种方式处理

27:14.380 --> 27:15.380
你是一种面向对象的

27:15.380 --> 27:16.380
一种思维方式

27:16.380 --> 27:18.380
我认为呢

27:18.380 --> 27:20.380
旋转这个方法

27:20.380 --> 27:23.380
有一个通用实现

27:23.380 --> 27:25.380
我们可以这样认为

27:25.380 --> 27:27.380
Rotate方法

27:28.380 --> 27:31.380
有一种通用的实现

27:31.380 --> 27:33.380
通用的实现方式

27:33.380 --> 27:35.380
就是按照既定的方向

27:35.380 --> 27:36.380
来进行旋转

27:36.380 --> 27:37.380
就完事了

27:37.380 --> 27:38.380
就是我们刚才起来的代码

27:38.380 --> 27:40.380
就是通用实现

27:40.380 --> 27:44.380
但是不同的情况下

27:44.380 --> 27:48.380
会有不同的具体实现

27:48.380 --> 27:51.380
比方说一个像这个方块

27:51.380 --> 27:52.380
像这个方块

27:52.380 --> 27:54.380
它只有良用状态

27:54.380 --> 27:56.380
先顺十人旋转

27:56.380 --> 27:58.380
不同的情况下会有不同的实现

27:58.380 --> 28:00.380
然后还有一个填兹的方块

28:00.380 --> 28:02.380
填兹的方块

28:02.380 --> 28:04.380
那么填兹的方块

28:04.380 --> 28:05.380
它是不能旋转的

28:05.380 --> 28:07.380
也就是说不同的方块

28:07.380 --> 28:08.380
有不同的实现

28:08.380 --> 28:09.380
那么遇到这种情况

28:09.380 --> 28:11.380
我们的做法是

28:11.380 --> 28:15.380
将square group

28:15.380 --> 28:18.380
作为附类

28:18.380 --> 28:21.380
其他的方块

28:21.380 --> 28:24.380
都是它的指类

28:24.380 --> 28:26.380
我们现在要对这个结构

28:26.380 --> 28:27.380
进行更改了

28:27.380 --> 28:28.380
其他的方块

28:28.380 --> 28:30.380
全部把它做成它的指类

28:30.380 --> 28:33.380
指类可以重写

28:33.380 --> 28:36.380
重写附类的方法

28:36.380 --> 28:37.380
可以覆盖附类的方法

28:37.380 --> 28:39.380
我们把它叫做重写

28:39.380 --> 28:42.380
好,我们这样做来试一下

28:42.380 --> 28:44.380
square group作为附类

28:44.380 --> 28:45.380
那么这个地方

28:45.380 --> 28:46.380
我们就把这个类写好

28:46.380 --> 28:47.380
作为附类

28:47.380 --> 28:49.380
然后指类在哪呢

28:49.380 --> 28:51.380
我们以前没有写它的指类

28:51.380 --> 28:52.380
我们以前是怎么来

28:52.380 --> 28:54.380
制作每一个小方块的呢

28:54.380 --> 28:57.380
每一个俄罗斯方块

28:57.380 --> 28:58.380
是怎么做的呢

28:58.380 --> 28:59.380
是直接写到这的

28:59.380 --> 29:00.380
还记得吗

29:00.380 --> 29:03.380
我把每一个俄罗斯方块的形状写下来

29:03.380 --> 29:04.380
作为它的

29:04.380 --> 29:05.380
作为它的就是

29:05.380 --> 29:06.380
俄罗斯方块的

29:06.380 --> 29:08.380
来根据不同的形状

29:08.380 --> 29:10.380
来创建不同的俄罗斯方块

29:10.380 --> 29:12.380
我们之前是这样做的

29:12.380 --> 29:14.380
那么现在我们这里

29:14.380 --> 29:16.380
就不再这样做了

29:16.380 --> 29:17.380
因为这里边

29:17.380 --> 29:19.380
每一个方块

29:19.380 --> 29:20.380
因为以前的话

29:20.380 --> 29:22.380
这些方块都一样

29:22.380 --> 29:23.380
都是一样的功能

29:23.380 --> 29:24.380
那么现在的每一个方块

29:24.380 --> 29:26.380
可能会有一些差异

29:26.380 --> 29:28.380
它在做一些事情的时候

29:28.380 --> 29:30.380
比方说旋转的时候

29:30.380 --> 29:31.380
它可能会有一些差异

29:31.380 --> 29:33.380
既然有差异的话

29:33.380 --> 29:34.380
我们就把它当成

29:34.380 --> 29:36.380
不同的类型来处理

29:36.380 --> 29:38.380
那么这里我会这样子来写

29:38.380 --> 29:39.380
大家看一下

29:39.380 --> 29:41.380
跟之前的写法对比

29:41.380 --> 29:43.380
之前我只是

29:43.380 --> 29:45.380
都是创建的是什么对象

29:45.380 --> 29:47.380
创建的都是square group

29:47.380 --> 29:48.380
这个对象

29:48.380 --> 29:49.380
创建的都是这个对象

29:49.380 --> 29:50.380
那么现在呢

29:50.380 --> 29:52.380
我要去写一个一个的

29:52.380 --> 29:53.380
俄罗斯方块的纸类

29:53.380 --> 29:54.380
比方说

29:54.380 --> 29:56.380
我们这里导出

29:56.380 --> 29:58.380
我们这里导出一个class

29:58.380 --> 30:00.380
之前不是写的t shape吗

30:00.380 --> 30:01.380
我们还是用t shape

30:01.380 --> 30:03.380
表示的是

30:03.380 --> 30:05.380
一个就是

30:05.380 --> 30:07.380
t这个形状

30:07.380 --> 30:09.380
t这个形状的俄罗斯方块

30:09.380 --> 30:11.380
它变成了一个类

30:11.380 --> 30:12.380
它继承谁呢

30:12.380 --> 30:15.380
继承square group

30:15.380 --> 30:17.380
继承它

30:17.380 --> 30:19.380
好 我们这里把组设量

30:19.380 --> 30:22.380
好 写好了这个类之后

30:22.380 --> 30:25.380
咱们来分析一下

30:25.380 --> 30:27.380
这个纸类

30:27.380 --> 30:29.380
还需不需要

30:29.380 --> 30:31.380
沿用负类的构造函数

30:31.380 --> 30:33.380
因为我们知道

30:33.380 --> 30:35.380
纸类如果你不去写

30:35.380 --> 30:36.380
它的构造函数的话

30:36.380 --> 30:38.380
它沿用的是负类的构造函数

30:38.380 --> 30:40.380
那负类的构造函数

30:40.380 --> 30:41.380
里面有几个参数呢

30:41.380 --> 30:42.380
有三个

30:42.380 --> 30:44.380
一个是你要告诉我形状

30:44.380 --> 30:46.380
你要告诉我中心点坐标

30:47.380 --> 30:49.380
那么我们来分析一下

30:49.380 --> 30:50.380
这三个参数

30:50.380 --> 30:52.380
在纸类里边还需不需要

30:52.380 --> 30:54.380
你给我传递三个参数进来

30:54.380 --> 30:56.380
需不需要这个

30:56.380 --> 30:58.380
我们来分析一下

30:58.380 --> 31:00.380
中心点坐标是没问题的

31:00.380 --> 31:02.380
你必须要告诉我中心点坐标

31:02.380 --> 31:04.380
我要显示嘛

31:04.380 --> 31:06.380
颜色呢也是没问题的

31:06.380 --> 31:08.380
你要告诉我颜色

31:08.380 --> 31:10.380
那么形状呢

31:10.380 --> 31:11.380
在纸类里边

31:11.380 --> 31:12.380
你看这个类

31:12.380 --> 31:13.380
它已经明确的知道

31:13.380 --> 31:15.380
它是一个t形了

31:15.380 --> 31:17.380
它的形状坐标已经出来了

31:17.380 --> 31:18.380
就这个形状

31:18.380 --> 31:20.380
那你还需要告诉我形状吗

31:20.380 --> 31:22.380
你不需要告诉我了

31:22.380 --> 31:24.380
所以说纸类的构造函数呢

31:24.380 --> 31:25.380
我需要把负类的构造函数

31:25.380 --> 31:27.380
给它重现掉

31:27.380 --> 31:29.380
重现一下纸类的构造函数

31:29.380 --> 31:30.380
是什么呢

31:30.380 --> 31:31.380
把这个负责过来

31:31.380 --> 31:32.380
你会发现

31:32.380 --> 31:34.380
它就少了一个参数

31:34.380 --> 31:35.380
其他都一样

31:35.380 --> 31:37.380
就少了第一个参数

31:37.380 --> 31:38.380
第一个参数不要了

31:38.380 --> 31:40.380
当然这些排位是必要的

31:40.380 --> 31:42.380
这是负类油的

31:42.380 --> 31:44.380
在这个函数里边

31:44.380 --> 31:46.380
我们已经能够确定形状了

31:46.380 --> 31:49.380
因此我在纸类的构造函数里边

31:49.380 --> 31:51.380
要用负类的构造函数的时候呢

31:51.380 --> 31:53.380
第一个参数你看

31:53.380 --> 31:54.380
负类的构造函数

31:54.380 --> 31:55.380
第一个参数形状要告诉它

31:55.380 --> 31:57.380
那么形状是不是已经确定了

31:57.380 --> 31:58.380
对不对

31:58.380 --> 31:59.380
已经确定了

31:59.380 --> 32:00.380
因此呢

32:00.380 --> 32:02.380
我们这里可以把这个形状复制过来

32:02.380 --> 32:04.380
其实就是一个数组

32:04.380 --> 32:06.380
就是一个坐标传给它

32:06.380 --> 32:07.380
形状的坐标已经确定了

32:07.380 --> 32:09.380
不需要别人告诉我

32:09.380 --> 32:10.380
好

32:10.380 --> 32:11.380
中心链坐标

32:11.380 --> 32:12.380
那你要告诉我

32:12.380 --> 32:14.380
中心链坐标是一个参数

32:14.380 --> 32:16.380
中心链坐标我是不知道的

32:16.380 --> 32:18.380
那么中心链坐标直接扔给负类

32:18.380 --> 32:21.380
然后呢颜色呢也是不知道的

32:21.380 --> 32:23.380
好好看一下这个代码啊

32:23.380 --> 32:24.380
理解一下

32:24.380 --> 32:26.380
给负类里边传递了三个参数

32:26.380 --> 32:28.380
第一个参数是形状

32:28.380 --> 32:31.380
由于在纸类里边形状是已知的

32:31.380 --> 32:32.380
因此呢

32:32.380 --> 32:33.380
构造函数

32:33.380 --> 32:35.380
创建纸类对象的时候

32:35.380 --> 32:37.380
你不需要给我传递形状这个参数

32:37.380 --> 32:39.380
你只需要告诉我中心链坐标

32:39.380 --> 32:40.380
和颜色就可以了

32:40.380 --> 32:41.380
形状我是已知的

32:41.380 --> 32:42.380
我直接扔给负类

32:42.380 --> 32:44.380
让他把这个形状直接搞出负类

32:44.380 --> 32:46.380
让他去创建对象

32:46.380 --> 32:48.380
那么中心链坐标和颜色呢

32:48.380 --> 32:49.380
我是不知道的

32:49.380 --> 32:50.380
那你需要告诉我

32:50.380 --> 32:51.380
OK

32:51.380 --> 32:52.380
我就这样子呢

32:52.380 --> 32:53.380
就搞定了这个T这个形状

32:53.380 --> 32:55.380
尽管我现在还没有去重写

32:55.380 --> 32:57.380
还没有去重写旋转

32:57.380 --> 32:58.380
那个方法

32:58.380 --> 33:00.380
但是我们先把结构搞定

33:00.380 --> 33:01.380
我们现在用的新的方式

33:01.380 --> 33:02.380
来搞定形状

33:02.380 --> 33:04.380
就是做一个一个的纸类

33:04.380 --> 33:05.380
这是个纸类

33:05.380 --> 33:07.380
那么同样的道理

33:07.380 --> 33:08.380
这边呢

33:08.380 --> 33:10.380
L线也是一个纸类

33:10.380 --> 33:11.380
复制一下啊

33:11.380 --> 33:12.380
那么就一次复制的

33:12.380 --> 33:14.380
其实没什么多说的

33:14.380 --> 33:16.380
就直接复制

33:16.380 --> 33:18.380
那是L这个形状

33:18.380 --> 33:19.380
那么L一个形状

33:19.380 --> 33:21.380
把它做成那个纸类

33:21.380 --> 33:23.380
接下来继续的

33:23.380 --> 33:24.380
L迷路

33:24.380 --> 33:26.380
就是极限形状导动了

33:26.380 --> 33:30.380
就把这些东西直接复制

33:31.380 --> 33:33.380
这里直接复制

33:33.380 --> 33:35.380
L迷路搞定了

33:35.380 --> 33:38.380
一共有七个形状复制

33:38.380 --> 33:40.380
还有SS shape

33:40.380 --> 33:42.380
这个形状复制一下

33:42.380 --> 33:44.380
复制一下

33:44.380 --> 33:47.380
复制一下暂停

33:47.380 --> 33:49.380
好 继续啊

33:49.380 --> 33:55.330
这里S mirror shape

33:55.330 --> 33:58.330
形状复制一下

33:58.330 --> 34:00.330
复制一下

34:00.330 --> 34:02.330
好 这样

34:02.330 --> 34:03.330
这样

34:03.330 --> 34:05.330
这里把它复制一下

34:05.330 --> 34:07.330
纯粹是体力好了啊

34:07.330 --> 34:09.330
square shape

34:09.330 --> 34:11.330
复制一下

34:11.330 --> 34:13.330
复制一下

34:13.330 --> 34:16.710
再说一次啊

34:16.710 --> 34:18.710
我之所以要去这样做

34:18.710 --> 34:20.710
是因为我在纸类里面

34:20.710 --> 34:22.710
还有一些特殊的行为是不一样的

34:22.710 --> 34:24.710
以前的每个纸类

34:24.710 --> 34:25.710
没有纸类

34:25.710 --> 34:28.710
所有的东西处理的方式都是完全一样的

34:28.710 --> 34:30.710
那么就会导致负类边的很复杂

34:30.710 --> 34:32.710
它要应付各种各样的情况

34:32.710 --> 34:34.710
那么现在我发现了纸类的

34:34.710 --> 34:37.710
有些方块的它的情况是不一样的

34:37.710 --> 34:39.710
因此我就会把它写成一个一个的纸类

34:39.710 --> 34:42.710
让纸类去处理特殊情况

34:42.710 --> 34:44.710
负类只提供通用的方法

34:44.710 --> 34:45.710
就不像以前那样子

34:45.710 --> 34:47.710
什么到处去夹判断

34:47.710 --> 34:49.710
到处去夹各种属性

34:49.710 --> 34:50.710
夹各种条件

34:50.710 --> 34:52.710
这样做实在实际上是不好的

34:52.710 --> 34:53.710
好了 那么现在呢

34:53.710 --> 34:56.710
我就写了七个不同的纸类

34:56.710 --> 34:57.710
每一个纸类呢

34:57.710 --> 34:59.710
代表的是一个方块

34:59.710 --> 35:00.710
耳朵是方块

35:00.710 --> 35:02.710
那么现在我要

35:02.710 --> 35:03.710
水机产生耳朵是方块的时候呢

35:03.710 --> 35:04.710
以前啊

35:04.710 --> 35:07.710
我们这里保存的是一个一个一个的形状对吧

35:07.710 --> 35:08.710
那么现在不是形状了啊

35:08.710 --> 35:10.710
保存的是一个个什么

35:10.710 --> 35:11.710
一个个内

35:11.710 --> 35:12.710
你看

35:12.710 --> 35:14.710
内的名称保存到数组里边

35:14.710 --> 35:16.710
保存的是一个一个的内

35:16.710 --> 35:17.710
因此呢

35:17.710 --> 35:18.710
到最后

35:18.710 --> 35:20.710
我们来产生一个形

35:20.710 --> 35:22.710
产生一个耳朵是方块的时候

35:22.710 --> 35:23.710
啊

35:23.710 --> 35:26.710
我们从这个数组里面取出来

35:26.710 --> 35:28.710
取出来是个是啥

35:28.710 --> 35:30.710
这个是啥取出来的

35:30.710 --> 35:32.710
你看一下这个数组

35:32.710 --> 35:34.710
数组的每一项是一个内

35:34.710 --> 35:36.710
也就是是一个勾到函数

35:36.710 --> 35:37.710
因此呢

35:37.710 --> 35:39.710
你这里从数组里面取出来的

35:39.710 --> 35:41.710
本身就是一个勾到函数了

35:41.710 --> 35:43.710
它本身就是一个勾到函数了

35:43.710 --> 35:44.710
所以说呢

35:44.710 --> 35:45.710
到了这里

35:45.710 --> 35:47.710
我就不是new square group

35:47.710 --> 35:49.710
就不是new这个玩意儿了

35:49.710 --> 35:51.710
而是new一个啥呢

35:51.710 --> 35:52.710
new的是个啥呢

35:52.710 --> 35:54.710
new的是一个

35:54.710 --> 35:55.710
啊

35:55.710 --> 35:57.710
new的是一个啥呢

35:57.710 --> 35:58.710
new的是一个

35:58.710 --> 36:00.710
shade

36:00.710 --> 36:02.710
shade

36:02.710 --> 36:04.710
new的是这个东西

36:04.710 --> 36:06.710
丢的是一个形状

36:06.710 --> 36:08.710
这就是它的紫内对不对

36:08.710 --> 36:09.710
这个紫内呢是

36:09.710 --> 36:11.710
我们把所有的紫内全方的一个数组里边

36:11.710 --> 36:13.710
然后产生一个水积下标

36:13.710 --> 36:15.710
从数组里面取出一下

36:15.710 --> 36:17.710
无论你取出来哪一项

36:17.710 --> 36:18.710
都是一个紫内啊

36:18.710 --> 36:19.710
等内

36:19.710 --> 36:20.710
勾到函数

36:20.710 --> 36:22.710
取出的是一个勾到函数

36:22.710 --> 36:23.710
因此呢

36:23.710 --> 36:25.710
这里也要把它当成一个勾到函数来使用

36:25.710 --> 36:26.710
好

36:26.710 --> 36:28.710
勾到函数里面有两个参数啊

36:28.710 --> 36:29.710
有两个参数

36:29.710 --> 36:30.710
这两个参数是怎么推断出来的

36:30.710 --> 36:31.710
因为它发现

36:31.710 --> 36:33.710
这里面有共同点

36:33.710 --> 36:34.710
每一个紫内都有个共同点

36:34.710 --> 36:35.710
都是有两个参数

36:35.710 --> 36:36.710
ok

36:36.710 --> 36:37.710
那么这里呢

36:37.710 --> 36:38.710
它会让你传递两个参数

36:38.710 --> 36:40.710
一个是中心点坐标

36:40.710 --> 36:41.710
center point

36:41.710 --> 36:46.360
一个是颜色

36:46.360 --> 36:47.360
完成了

36:47.360 --> 36:48.360
好

36:48.360 --> 36:50.360
我们先把这个内结构改造一下

36:50.360 --> 36:51.360
其实这样的改造

36:51.360 --> 36:52.360
对我外面的代码

36:52.360 --> 36:54.360
不会产生任何影响

36:54.360 --> 36:55.360
因为外面的代码都是通过它

36:55.360 --> 36:57.360
来得到一个方块的

36:57.360 --> 36:58.360
那么怎么来得到方块的

36:58.360 --> 36:59.360
它不管

36:59.360 --> 37:00.360
它不管你怎么得到方块的

37:00.360 --> 37:02.360
你看这就是面向对象的好处

37:02.360 --> 37:04.360
其他一看其他的内里边

37:04.360 --> 37:05.360
包括我们之前

37:05.360 --> 37:06.360
做的这个terrors rule

37:06.360 --> 37:07.360
这个内对吧

37:07.360 --> 37:09.360
处理的都是

37:09.360 --> 37:11.360
这个负类对象

37:11.360 --> 37:12.360
那么它到底是不是负类的

37:12.360 --> 37:14.360
因为我们知道压制变形法

37:14.360 --> 37:15.360
紫内的对象

37:15.360 --> 37:17.360
也是可以传递给负类的

37:17.360 --> 37:18.360
它可以把它当成

37:18.360 --> 37:20.360
统一的处理方式来进行处理

37:20.360 --> 37:21.360
因此呢

37:21.360 --> 37:22.360
它不管

37:22.360 --> 37:23.360
它不管

37:23.360 --> 37:24.360
你只要把它当成

37:24.360 --> 37:25.360
负类对象就行了

37:25.360 --> 37:26.360
那么紫内它可以传进来

37:26.360 --> 37:27.360
但是我这个方法的

37:27.360 --> 37:28.360
实现过程中

37:28.360 --> 37:29.360
我才不管你是不是紫内

37:29.360 --> 37:30.360
是哪一个紫内

37:30.360 --> 37:31.360
跟我没关系

37:31.360 --> 37:32.360
我把它当成

37:32.360 --> 37:34.360
统一的负类来进行处理

37:34.360 --> 37:36.360
压制变形法

37:36.360 --> 37:37.360
然后这边

37:37.360 --> 37:38.360
也就是说这边的代码呢

37:38.360 --> 37:39.360
这边的代码

37:39.360 --> 37:40.360
实际上

37:40.360 --> 37:42.360
是不会影响到外边的

37:42.360 --> 37:43.360
因为得到的

37:43.360 --> 37:44.360
还是一个方块

37:44.360 --> 37:46.360
得到的还是一个方块

37:46.360 --> 37:47.360
这里呢

37:47.360 --> 37:48.360
其实我可以给它返回

37:48.360 --> 37:49.360
给它明确标注一下

37:49.360 --> 37:50.360
返回的是啥

37:50.360 --> 37:53.360
返回的是square group

37:53.360 --> 37:54.360
返回的是这个东西

37:54.360 --> 37:56.360
返回的是负类的对象

37:56.360 --> 37:57.360
你看返回的

37:57.360 --> 37:58.360
实际上是紫内的对象

37:58.360 --> 37:59.360
但是呢

37:59.360 --> 38:00.360
我可以把它标注为

38:00.360 --> 38:01.360
返回的是负类

38:02.360 --> 38:03.360
好

38:03.360 --> 38:04.360
那么这里搞定了

38:04.360 --> 38:06.360
我们看一下最多的结果

38:06.360 --> 38:07.360
向左移动

38:07.360 --> 38:08.360
向右移动

38:08.360 --> 38:09.360
向上移动

38:09.360 --> 38:10.360
向下一动

38:10.360 --> 38:11.360
向左移动

38:11.360 --> 38:12.360
向右移动

38:12.360 --> 38:13.360
我们把这里干涉

38:13.360 --> 38:14.360
用这种方式吧

38:14.360 --> 38:16.360
方便以后测试

38:16.360 --> 38:17.360
不用一个目的

38:17.360 --> 38:18.360
一个这里的

38:18.360 --> 38:20.360
就直接使用目

38:20.360 --> 38:25.950
直接使用目

38:25.950 --> 38:26.950
看一下

38:26.950 --> 38:29.950
向右 向左 向下 向上

38:29.950 --> 38:30.950
好

38:30.950 --> 38:31.950
那么这个时候要旋转

38:31.950 --> 38:32.950
再来搞定旋转

38:32.950 --> 38:33.950
你会发现

38:33.950 --> 38:34.950
这个时候搞定旋转

38:34.950 --> 38:35.950
就非常非常简单了

38:35.950 --> 38:36.950
怎么搞定呢

38:36.950 --> 38:38.950
我们就可以到这个

38:38.950 --> 38:40.950
方块里边

38:40.950 --> 38:41.950
就是这里边

38:41.950 --> 38:42.950
不是有这么多紫内吗

38:42.950 --> 38:43.950
对吧

38:43.950 --> 38:44.950
我们一个个来

38:44.950 --> 38:46.950
有什么特殊的地方呢

38:46.950 --> 38:47.950
我们就来单独来进行处理

38:47.950 --> 38:49.950
单独进行处理

38:49.950 --> 38:50.950
好

38:50.950 --> 38:51.950
比方说

38:51.950 --> 38:53.950
第一个T

38:53.950 --> 38:54.950
T这个呢

38:54.950 --> 38:55.950
好像没有什么处理的

38:55.950 --> 38:56.950
它四个

38:56.950 --> 38:58.950
它可以一直进行旋转

38:58.950 --> 38:59.950
好 再看这个L

38:59.950 --> 39:01.950
L好像也没有什么处理的

39:01.950 --> 39:02.950
再看这个Miller

39:02.950 --> 39:03.950
这个S

39:03.950 --> 39:04.950
S呢

39:04.950 --> 39:05.950
我们知道

39:05.950 --> 39:06.950
之前说过

39:06.950 --> 39:08.950
它只能有两种状态

39:08.950 --> 39:09.950
只能有两种状态

39:09.950 --> 39:10.950
要么是

39:10.950 --> 39:12.950
就是顺时针转一次

39:12.950 --> 39:13.950
历时针转一次

39:13.950 --> 39:15.950
那么这个就很简单了

39:15.950 --> 39:16.950
就很简单了

39:16.950 --> 39:17.950
怎么做

39:17.950 --> 39:18.950
怎么做呢

39:18.950 --> 39:20.950
就重写Rotate

39:20.950 --> 39:21.950
你看

39:21.950 --> 39:22.950
复内里边不是有个函数吗

39:22.950 --> 39:24.950
Rotate旋转这个函数

39:24.950 --> 39:26.950
重写这个函数

39:26.950 --> 39:28.950
重写这个函数的时候呢

39:28.950 --> 39:30.950
我们让它去转动

39:30.950 --> 39:31.950
转动

39:31.950 --> 39:34.950
调用复内的Rotate这个函数

39:34.950 --> 39:35.950
调用复内的函数

39:35.950 --> 39:36.950
让它转动

39:36.950 --> 39:38.950
你转动完了之后呢

39:38.950 --> 39:39.950
等于转动完

39:39.950 --> 39:41.950
转完了之后呢

39:41.950 --> 39:43.950
不是复内有一个属性吗

39:43.950 --> 39:44.950
你看呀

39:44.950 --> 39:45.950
复内不是有个属性吗

39:45.950 --> 39:46.950
就是旋转方向

39:46.950 --> 39:48.950
好 我现在把这个属性呢

39:48.950 --> 39:49.950
改成Protected

39:49.950 --> 39:50.950
不然的话

39:50.950 --> 39:51.950
旋转没法使用

39:51.950 --> 39:53.950
改成Protected

39:53.950 --> 39:55.950
那么旋转可以使用这个属性了

39:55.950 --> 39:57.950
好 改成这个属性之后

39:57.950 --> 39:58.950
我们在旋转里边

39:58.950 --> 40:00.950
是不是可以改变这个属性

40:00.950 --> 40:01.950
Ease Clock

40:02.950 --> 40:05.950
等于相反的Ease Clock

40:05.950 --> 40:07.950
好了 之前是顺时针

40:07.950 --> 40:08.950
就变成历时针

40:08.950 --> 40:09.950
之前是历时针的

40:09.950 --> 40:10.950
就变成顺时针

40:10.950 --> 40:12.950
好 我们来看一下

40:12.950 --> 40:13.950
这个A是这个线

40:13.950 --> 40:14.950
你看它的旋转方式

40:14.950 --> 40:16.950
你会发现它就变黄了

40:19.950 --> 40:21.950
得到这个A是这个旋转

40:27.600 --> 40:32.390
看一下啊 旋转

40:32.390 --> 40:33.390
这个地方

40:33.390 --> 40:34.390
还有一个对吧

40:34.390 --> 40:35.390
不对

40:35.390 --> 40:36.390
还有一个Mirror

40:36.390 --> 40:38.390
Mirror也要做同样的处理

40:41.390 --> 40:42.390
再来

40:42.390 --> 40:43.390
因为S有两个形状

40:43.390 --> 40:45.390
S 还有S Mirror

40:52.650 --> 40:54.650
看着啊 旋转

40:54.650 --> 40:56.650
你看 现在是不是合理多了

40:56.650 --> 40:57.650
它只有

40:57.650 --> 40:58.650
一开始顺时针

40:58.650 --> 41:00.650
然后马上变成历时针

41:00.650 --> 41:01.650
然后马上变成顺时针

41:01.650 --> 41:03.650
这样就合理多了

41:03.650 --> 41:04.650
再继续

41:04.650 --> 41:06.650
都是这种情况

41:06.650 --> 41:07.650
然后我们看一下

41:07.650 --> 41:09.650
还有一个不旋转的

41:09.650 --> 41:10.650
还有一个不旋转的

41:10.650 --> 41:11.650
还有一个NAN

41:11.650 --> 41:13.650
NAN其实也是一样的

41:13.650 --> 41:15.650
这个直线也是一样的

41:16.650 --> 41:17.650
旋转之后呢

41:17.650 --> 41:19.650
直线是顺时针 变成历时针

41:19.650 --> 41:20.650
直线是历时针 变成顺时针

41:20.650 --> 41:22.650
这是一条线的方块

41:22.650 --> 41:23.650
也是一样的情况

41:23.650 --> 41:24.650
还有一个就是

41:24.650 --> 41:27.650
填字形的Square Shape

41:27.650 --> 41:29.650
这个填字形的

41:29.650 --> 41:30.650
填字形的这个东西呢

41:30.650 --> 41:32.650
它是不旋转的

41:32.650 --> 41:33.650
它压个不旋转

41:33.650 --> 41:35.650
那么这个方块怎么办呢

41:36.650 --> 41:37.650
不旋转怎么办

41:37.650 --> 41:38.650
怎么处理

41:38.650 --> 41:39.650
不旋转的话呢

41:39.650 --> 41:41.650
还不简单吗

41:41.650 --> 41:43.650
之前不是一个计算

41:43.650 --> 41:46.650
计算旋转得到的形状

41:46.650 --> 41:49.650
计算旋转得到的形状

41:49.650 --> 41:51.650
就这个玩意儿

41:51.650 --> 41:53.650
在计算的形状

41:53.650 --> 41:55.650
我重写这个函数

41:55.650 --> 41:57.650
计算旋转形状的时候

41:57.650 --> 42:00.650
直接返回当前的形状

42:00.650 --> 42:01.650
直接返回当前的形状

42:01.650 --> 42:02.650
就完事了

42:02.650 --> 42:03.650
那么这样子呢

42:03.650 --> 42:05.650
我就不经过任何的计算

42:05.650 --> 42:07.650
直接返回当前的形状

42:08.650 --> 42:09.650
你看一下啊

42:09.650 --> 42:10.650
这样是不是就完了

42:10.650 --> 42:11.650
我看一下

42:11.650 --> 42:12.650
这个填

42:12.650 --> 42:13.650
这个方块

42:13.650 --> 42:15.650
这个我拿着去水系了

42:15.650 --> 42:16.650
拿着水系了

42:16.650 --> 42:17.650
我就直接这样子

42:17.650 --> 42:18.650
就这样子

42:18.650 --> 42:20.650
数字只有一项

42:20.650 --> 42:21.650
这数字只有一项

42:21.650 --> 42:22.650
那么你产生水系下边的时候

42:22.650 --> 42:23.650
只有这个

42:23.650 --> 42:24.650
你看选择

42:24.650 --> 42:25.650
你看

42:25.650 --> 42:26.650
现在选择出来

42:26.650 --> 42:27.650
那是不是一样的

42:27.650 --> 42:29.650
就完全一样的了

42:29.650 --> 42:30.650
OK

42:30.650 --> 42:31.650
那么这个问题呢

42:31.650 --> 42:32.650
搞定了

42:32.650 --> 42:35.650
旋转的这个不同的情况

42:35.650 --> 42:36.650
我们就搞定了

42:36.650 --> 42:38.650
以后遇到这种处理方式呢

42:38.650 --> 42:39.650
我这里其实讲的

42:39.650 --> 42:41.650
不是什么耳朵式方块啊

42:41.650 --> 42:43.650
讲的是一种通用的处理方式

42:43.650 --> 42:45.650
以后呢你写一个内的时候

42:45.650 --> 42:47.650
如果你发现这个内啊

42:47.650 --> 42:49.650
还有各种各样的情况

42:49.650 --> 42:50.650
我建议你呢

42:50.650 --> 42:52.650
写成一个一个的纸背

42:52.650 --> 42:54.650
让纸内去处理不同的情况

42:54.650 --> 42:57.650
不要全部在负累里边去判断

42:57.650 --> 42:58.650
那么而且呢

42:58.650 --> 43:00.650
这样子是非常容易扩展的

43:00.650 --> 43:01.650
这个形状我怎么办

43:01.650 --> 43:03.650
我只需要去写个纸内就行了

43:03.650 --> 43:06.650
那么可以去更赶负累的一些行为

43:06.650 --> 43:08.650
那么来实现不同的效果

43:08.650 --> 43:10.650
OK这个问题搞定了

43:10.650 --> 43:12.650
好就这个问题

43:12.650 --> 43:14.650
好下一个问题

43:14.650 --> 43:16.650
什么问题呢

43:16.650 --> 43:17.650
我们又来看

43:17.650 --> 43:18.650
还有一些问题

43:18.650 --> 43:19.650
比方说这

43:19.650 --> 43:21.650
旋转

43:21.650 --> 43:23.650
然后呢这里我怎么弄呢

43:23.650 --> 43:26.650
我这里向右移动

43:26.650 --> 43:27.650
再旋转

43:27.650 --> 43:29.650
是不是好外面去了

43:29.650 --> 43:31.650
那么这个问题怎么解决

43:31.650 --> 43:34.650
跟以前移动的时候

43:34.650 --> 43:37.650
解决方式是一样的

43:37.650 --> 43:38.650
移动的时候

43:38.650 --> 43:39.650
我们不能移动到外面去

43:39.650 --> 43:40.650
因此呢

43:40.650 --> 43:42.650
我们写了一个规则

43:42.650 --> 43:44.650
Terrace Rule

43:44.650 --> 43:46.650
那么在这个规则

43:46.650 --> 43:47.650
范围内进行移动

43:47.650 --> 43:49.650
就是你们不能跑到外面去

43:49.650 --> 43:50.650
那么现在呢

43:50.650 --> 43:52.650
旋转也是一样

43:52.650 --> 43:54.650
旋转它也有规则

43:54.650 --> 43:56.650
旋转过后能跑到外面去呢

43:56.650 --> 43:57.650
那肯定不行

43:57.650 --> 43:59.650
所以说这里旋转的时候呢

43:59.650 --> 44:01.650
我也写这么一个

44:01.650 --> 44:02.650
静态的方法

44:02.650 --> 44:04.650
那么在这个Terrace Rule

44:04.650 --> 44:05.650
这个内里边

44:05.650 --> 44:06.650
写个静态的方法

44:06.650 --> 44:07.650
Rotate

44:07.650 --> 44:08.650
我希望呢

44:08.650 --> 44:09.650
如果你要自由的旋转

44:09.650 --> 44:10.650
那没事

44:10.650 --> 44:12.650
你就用之前的做法来做

44:12.650 --> 44:13.650
如果

44:13.650 --> 44:15.650
你要按照规则来进行旋转

44:15.650 --> 44:18.650
就是在某一个框架内来进行旋转的话

44:18.650 --> 44:19.650
那么

44:19.650 --> 44:21.650
你在这个内里面去调用

44:21.650 --> 44:23.650
你告诉我你的方块是谁

44:23.650 --> 44:24.650
你要旋转哪一个方块

44:24.650 --> 44:26.650
你告诉我

44:26.650 --> 44:28.650
Square Group

44:28.650 --> 44:29.650
我管你是怎么方块

44:29.650 --> 44:30.650
我得把它当成一个

44:30.650 --> 44:32.650
统一的负责来进行处理

44:32.650 --> 44:34.650
然后你告诉

44:34.650 --> 44:36.650
也不用告诉我旋转的方向了

44:36.650 --> 44:37.650
对吧

44:37.650 --> 44:39.650
只需要告诉我这个旋转就行了

44:39.650 --> 44:40.650
返回一个布尔

44:40.650 --> 44:41.650
我会告诉你

44:41.650 --> 44:43.650
是否旋转成功

44:43.650 --> 44:44.650
那我怎么判断呢

44:44.650 --> 44:46.650
我就做这么一件事

44:46.650 --> 44:47.650
首先

44:47.650 --> 44:48.650
我通过这个里边

44:48.650 --> 44:49.650
不是一个函数吗

44:49.650 --> 44:50.650
对吧

44:50.650 --> 44:52.650
AfterRotate

44:52.650 --> 44:55.650
得到旋转之后的新的形状

44:55.650 --> 44:57.650
流泄

44:57.650 --> 44:59.650
我先调用这个函数

44:59.650 --> 45:03.650
得到旋转之后新的形状

45:03.650 --> 45:05.650
这个时候还没有真正开始旋转

45:05.650 --> 45:07.650
还没有去改变它的形状

45:07.650 --> 45:08.650
只是在计算

45:08.650 --> 45:10.650
得到来以得到新的形状

45:10.650 --> 45:12.650
得到新的形状

45:12.650 --> 45:15.650
得到了新的形状之后

45:15.650 --> 45:18.650
然后我们开吊这个函数

45:18.650 --> 45:19.650
这个函数又可以利用了

45:19.650 --> 45:21.650
告诉我你的形状

45:21.650 --> 45:23.650
告诉我你的中心点坐标

45:23.650 --> 45:25.650
我就告诉你能不能移动到这

45:25.650 --> 45:27.650
这个函数已经有了

45:27.650 --> 45:29.650
那么我就去调用这个函数

45:29.650 --> 45:31.650
判断一下

45:31.650 --> 45:32.650
if

45:32.650 --> 45:33.650
can

45:33.650 --> 45:34.650
this

45:34.650 --> 45:35.650
there

45:35.650 --> 45:36.650
is

45:36.650 --> 45:37.650
if

45:37.650 --> 45:38.650
can I move

45:38.650 --> 45:39.650
对吧

45:39.650 --> 45:41.650
然后第1个形状的函数

45:41.650 --> 45:43.650
就是把新的形状告诉你

45:43.650 --> 45:45.650
中心点坐标是什么呢

45:45.650 --> 45:47.650
中心点坐标不变

45:47.650 --> 45:48.650
中心点坐标不变

45:48.650 --> 45:50.650
得到center point

45:50.650 --> 45:52.650
因为旋转

45:52.650 --> 45:54.650
中心点坐标是不变的

45:54.650 --> 45:56.650
中心点坐标不变

45:56.650 --> 45:58.650
告诉我你新的形状

45:58.650 --> 46:00.650
那么我就能判断你能不能旋转

46:00.650 --> 46:03.650
能不能移动到这种状态

46:03.650 --> 46:05.650
如果可以的话

46:05.650 --> 46:06.650
怎么办

46:06.650 --> 46:08.650
可以的话简单了

46:08.650 --> 46:10.650
就是rotate

46:10.650 --> 46:11.650
转呗一起转

46:11.650 --> 46:12.650
else

46:12.650 --> 46:13.650
的话

46:13.650 --> 46:14.650
就不能转

46:14.650 --> 46:15.650
不能转

46:15.650 --> 46:17.650
那么就返回force

46:17.650 --> 46:19.650
能转的话就返回出

46:19.650 --> 46:20.650
好

46:20.650 --> 46:21.650
我们就写了这么一个函数

46:21.650 --> 46:22.650
通过这个函数呢

46:22.650 --> 46:23.650
其实也就是

46:23.650 --> 46:25.650
简单的做了一个判断

46:25.650 --> 46:27.650
在之前的基础上做了一个判断

46:27.650 --> 46:29.650
判断一下能不能这样处理

46:29.650 --> 46:31.650
那么通过这种方式呢

46:31.650 --> 46:33.650
我就能控制它的旋转

46:33.650 --> 46:34.650
你看一下

46:34.650 --> 46:36.650
这种答应嘛

46:36.650 --> 46:38.650
我其实呢我现在

46:38.650 --> 46:40.650
就是一步一步做出来

46:40.650 --> 46:42.650
到这里就变得那么简单了

46:42.650 --> 46:44.650
是因为我之前

46:44.650 --> 46:46.650
把事情已经分得很细了

46:46.650 --> 46:47.650
你想一想

46:47.650 --> 46:49.650
如果让你来写的话

46:49.650 --> 46:52.650
你很有可能你会这样来操作

46:52.650 --> 46:55.650
你把这两个函数给我合并在一起

46:55.650 --> 46:57.650
你把这两个函数合并在一起

46:57.650 --> 46:58.650
那么合并在那一起了过后

46:58.650 --> 46:59.650
你看这里是不是

46:59.650 --> 47:01.650
是不是就非常难以处理

47:01.650 --> 47:03.650
这里的话就很难处理到这里

47:03.650 --> 47:06.650
因为我现在要旋转

47:06.650 --> 47:08.650
我要先判断它能不能旋转

47:08.650 --> 47:09.650
我才能转

47:09.650 --> 47:11.650
但是判断能不能旋转呢

47:11.650 --> 47:12.650
你又把

47:12.650 --> 47:14.650
跟旋转又是写到一起的

47:14.650 --> 47:15.650
你跟这个旋转

47:15.650 --> 47:16.650
如果把这个函数写到这里边

47:16.650 --> 47:17.650
写到一起的

47:17.650 --> 47:18.650
那么这个功能呢

47:18.650 --> 47:20.650
我就没有办法把它拆分开

47:20.650 --> 47:21.650
没有办法来判断

47:21.650 --> 47:23.650
除非我这里写重复代码

47:23.650 --> 47:25.650
再进行一次计算

47:25.650 --> 47:27.650
否则的话我就很难得到

47:27.650 --> 47:29.650
它旋转之后的形状是什么

47:29.650 --> 47:31.650
所以说大家写代码的时候

47:31.650 --> 47:33.650
尽量把功能拆分开

47:33.650 --> 47:35.650
这样是最好的

47:35.650 --> 47:36.650
这样自然而然

47:36.650 --> 47:37.650
你在后边的操作过程中

47:37.650 --> 47:39.650
就会变得越来越简洁

47:39.650 --> 47:41.650
这代码都不用去重复书写

47:41.650 --> 47:42.650
好了

47:42.650 --> 47:44.650
有了这个Rotate函数之后

47:44.650 --> 47:47.650
我们到这里来再来进行测试

47:47.650 --> 47:49.650
这里就不是这样的调用了

47:49.650 --> 47:50.650
就应该是什么呢

47:50.650 --> 47:53.650
terraceRotate

47:53.650 --> 47:55.650
把这个方块传进去

47:55.650 --> 47:57.650
就玩笑了

47:57.650 --> 47:58.650
它告诉我是红转

47:58.650 --> 48:00.650
如果能旋转的话

48:00.650 --> 48:01.650
它就会进行旋转

48:01.650 --> 48:02.650
保存

48:02.650 --> 48:03.650
咱们再看一下

48:03.650 --> 48:08.650
向右一栋旋转

48:08.650 --> 48:11.650
向右一栋旋转

48:11.650 --> 48:13.650
向右一栋旋转

48:13.650 --> 48:14.650
再旋转

48:14.650 --> 48:15.650
你看

48:15.650 --> 48:16.650
转不动了

48:16.650 --> 48:17.650
为什么转不动呢

48:17.650 --> 48:19.650
因为再转的话就出去了

48:19.650 --> 48:20.650
再转的话就出去了

48:20.650 --> 48:22.650
这里转不动了

48:22.650 --> 48:26.650
现在就搞定了旋转的功能了

48:26.650 --> 48:27.650
旋转功能也搞定了

48:27.650 --> 48:28.650
包括左边也是一样

48:28.650 --> 48:31.650
再转动

48:31.650 --> 48:32.650
这里旋转

48:32.650 --> 48:33.650
转不动了

48:33.650 --> 48:34.650
转不动了

48:34.650 --> 48:35.650
因为如果这里要转动的话

48:35.650 --> 48:36.650
我们看一下

48:36.650 --> 48:38.650
往右一栋一栋

48:38.650 --> 48:39.650
这样转

48:39.650 --> 48:41.650
转不过去了

48:41.650 --> 48:45.650
这是关于旋转这一块的功能实现

48:45.650 --> 48:46.650
那么现在就做完了

48:46.650 --> 48:47.650
好好体会一下

48:47.650 --> 48:49.650
这一课内容了比较多

48:49.650 --> 48:51.650
而且它结构了产生了变化

48:51.650 --> 48:53.650
因此大家要好好体会一下

48:53.650 --> 48:54.650
这个旋转

48:54.650 --> 48:57.650
其实旋转本身它并不复杂

48:57.650 --> 48:58.650
旋转的本身的计算

48:58.650 --> 48:59.650
你看就这么个代码

48:59.650 --> 49:00.650
有多少呢

49:00.650 --> 49:01.650
找一下规律就出来了

49:01.650 --> 49:02.650
关键是

49:02.650 --> 49:04.650
它会代码结构的影响

49:04.650 --> 49:05.650
这个要好好体会

49:05.650 --> 49:06.650
第一个体会点

49:06.650 --> 49:08.650
为什么要把这两个分开

49:08.650 --> 49:09.650
为什么要把它们分开

49:09.650 --> 49:12.650
分开出写这是一种经验和习惯

49:12.650 --> 49:13.650
当你发现这个功能

49:13.650 --> 49:15.650
它需要经过计算

49:15.650 --> 49:18.650
又需要经过重新复制作标的处理的时候

49:18.650 --> 49:20.650
我会发现这是两个功能点

49:20.650 --> 49:22.650
我可以把它分开

49:22.650 --> 49:23.650
那么再体会一下

49:23.650 --> 49:26.650
为什么我这里要把它做成纸类

49:26.650 --> 49:28.650
为什么要把它做成纸类

49:28.650 --> 49:29.650
能不能不做纸类

49:29.650 --> 49:30.650
如果不做纸类的话

49:30.650 --> 49:31.650
你会怎么来写

49:31.650 --> 49:33.650
你会怎么写这个代码

49:33.650 --> 49:35.650
你只能在这里加属性

49:35.650 --> 49:37.650
能不能选择那个属性

49:37.650 --> 49:40.650
然后加什么呢

49:40.650 --> 49:43.650
然后在这里进行判断

49:43.650 --> 49:45.650
各种各样的情况

49:45.650 --> 49:46.650
该怎么来处理

49:46.650 --> 49:47.650
那么这样的话

49:47.650 --> 49:49.650
会把这个类做得非常非常复杂

49:49.650 --> 49:50.650
那么另外一点

49:50.650 --> 49:52.650
如果你不去写纸类

49:52.650 --> 49:54.650
不去写纸类来处理的话

49:54.650 --> 49:59.650
到这边产生这个随机方块的时候

49:59.650 --> 50:00.650
产生这个随机方块的时候

50:00.650 --> 50:02.650
你也必须要给它指定

50:02.650 --> 50:03.650
它能不能旋转

50:03.650 --> 50:05.650
那么这个地方也需要判断

50:05.650 --> 50:07.650
所以说会造成很多很多的判断

50:07.650 --> 50:09.650
那么还不如把这些差异点

50:09.650 --> 50:11.650
放到纸类里边

50:11.650 --> 50:13.650
每个纸类它非常清楚

50:13.650 --> 50:14.650
自己是什么情况

50:14.650 --> 50:15.650
那么它去重写

50:15.650 --> 50:17.650
比方说这个s

50:17.650 --> 50:18.650
这个方块

50:18.650 --> 50:19.650
它很清楚

50:19.650 --> 50:20.650
我的做表点就是这些

50:20.650 --> 50:22.650
然后我要旋转的话

50:22.650 --> 50:23.650
我就按这种方式来旋转

50:23.650 --> 50:25.650
它就非常非常的清楚

50:25.650 --> 50:27.650
所以说这一刻呢

50:27.650 --> 50:28.650
中心呢

50:28.650 --> 50:30.650
虽然实现的功能是旋转

50:30.650 --> 50:32.650
但是中心不在旋转上面

50:32.650 --> 50:33.650
而是要通过实现的功能

50:33.650 --> 50:36.650
让大家体会到这种内的结构

50:36.650 --> 50:37.650
它的分布

50:37.650 --> 50:39.650
为什么会变成这个样子

50:39.650 --> 50:40.650
为什么会用这种方式来处理

50:40.650 --> 50:42.650
因为我们讲这个游戏

50:42.650 --> 50:44.650
终点不在游戏本身

50:44.650 --> 50:45.650
而是在于

50:45.650 --> 50:46.650
它怎么去

50:46.650 --> 50:48.650
有什么样的方式

50:48.650 --> 50:49.650
去实现这样的代码

50:49.650 --> 50:50.650
OK

50:50.650 --> 50:52.650
大家好好体会

50:52.650 --> 50:53.650
好了

50:53.650 --> 50:54.650
那么这个旋转功能呢

50:54.650 --> 50:55.650
就到此结束了

50:55.650 --> 50:57.650
这里我们处理的问题就是

50:57.650 --> 50:58.650
旋转

50:58.650 --> 50:59.650
旋转

50:59.650 --> 51:00.650
不

51:00.650 --> 51:01.650
旋转

51:01.650 --> 51:04.650
不能超出边界

51:04.650 --> 51:05.650
好了

51:05.650 --> 51:06.650
那么这一刻

51:06.650 --> 51:07.650
东西呢

51:07.650 --> 51:08.650
就到此结束了

51:08.650 --> 51:09.650
还是一样

51:09.650 --> 51:10.650
每个小节完了之后呢

51:10.650 --> 51:12.650
自己去实现一遍

51:12.650 --> 51:13.650
根据我的思路

51:13.650 --> 51:14.650
自己去实现一遍

51:14.650 --> 51:15.650
把它消化了

51:15.650 --> 51:16.650
消化之后呢

51:16.650 --> 51:19.650
然后再看后边的小节

51:19.650 --> 51:20.650
OK

51:20.650 --> 51:21.650
那么这一刻到这里了

51:21.650 --> 51:22.650
拜拜

