WEBVTT

00:01.070 --> 00:08.670
Hello 大家好 我是多余教育 我们接着来讲一讲面上锂箱里面的一些知识

00:09.070 --> 00:11.870
这一刻呢 咱们来讲这个锁印器

00:12.870 --> 00:18.470
锁印器是啥呢 其实咱们之前写介石的时候啊 也经常用到

00:19.370 --> 00:22.870
怎么回事 锁印器是啥 给大家看一下啊 就这么一个代码就锁印器

00:24.070 --> 00:28.070
一个对象 一个对象 然后呢 加上两个中货号

00:29.070 --> 00:32.870
中货号里边呢 你写上一个值啊 你生成一个值

00:33.870 --> 00:38.070
然后来使用这么一个表达式的时候 你使用的其实就是锁印器

00:38.870 --> 00:44.470
咱们在开发的时候呢 有的时候我们读对象的属性啊 或者是读对象的成员

00:44.870 --> 00:50.870
不一定是使用这 是使用那个底耳的方式来读的 对吧 有可能是使用这种方式来读的

00:51.270 --> 00:56.670
那么这种方式呢 就使用的是锁印器 我们以前的教法呢 教的不是锁印器

00:56.870 --> 00:59.270
教的是啊 这是什么教法这个

01:00.470 --> 01:07.870
这个表示的是啊 在以前的时候呢 我们还叫做使用属性或者叫做成员表达式

01:09.070 --> 01:14.270
他叫做成员表达式 来举个例子吧 就比方说我们之前啊 写这么一个对象

01:17.820 --> 01:22.420
他里边有属性name啊 随便给他付个值 然后有A级 随便给他付个值

01:23.420 --> 01:24.420
然后我们要

01:25.820 --> 01:32.420
我们要得到这个对象里边所有的属性啊 得他所谓的属性 我把他所谓的属性输出

01:32.820 --> 01:39.020
我们可以使用这种方式来看啊 for for for 然后呢 这里

01:40.020 --> 01:43.020
不是for over 应该是 for in for in 循环

01:43.720 --> 01:47.520
得到这个对象里边每一个属性名啊 属性名

01:48.120 --> 01:50.920
然后得到属性名过后呢 我们直接输出

01:51.720 --> 01:57.520
这就是属性的名字对吧 属性的名字就保存在这个变量里边 我们希望把这个变量的值呢

01:57.920 --> 02:01.720
当成属性的名字来读取 那怎么做呢 就OB借

02:03.620 --> 02:06.920
中和好key 把两个输出吧 key

02:08.120 --> 02:12.120
属性名以及属性值都把输出 好 输出一下试一下吧

02:13.120 --> 02:16.320
呃这里呃np 弱

02:19.360 --> 02:20.160
啊看一下啊

02:21.160 --> 02:26.760
就这种方式呢 在ts 里边同样是支持的啊 这种方式在ts 里边同样是支持的

02:27.360 --> 02:33.560
所以通过这种方式呢 我们就可以啊动态的来读取对象里边那种 其实这个东西叫啥呢

02:33.760 --> 02:36.560
这个东西呢 就是我们这里说的所引起啊

02:37.560 --> 02:44.760
我们以前的叫做成员表达式啊 就用一个表达式来当成表达式的值呢来作为成员的名称

02:45.360 --> 02:51.760
这种状况呢 有的时候还蛮有用的 就是有的时候呢 我们需要通过一个变量

02:51.860 --> 02:56.960
这个变量的值来代表成员名称来进行动态的读取啊 还有的时候呢

02:57.060 --> 03:05.160
我们希望能够通过一个就是比方一个属性的名字很奇特啊比方说啊

03:05.260 --> 03:07.460
这里的属性名有一个属性名字叫做

03:08.860 --> 03:13.660
卖横杠pid 我的身份证号比方说有这么一个属性啊

03:14.260 --> 03:17.560
卖横杠pid 你看这样子些肯定要抱错

03:18.560 --> 03:25.660
因为它不只是那种语法 在街市里边这个我们的变量名呢 它必须是一个合法的标志服

03:26.160 --> 03:29.760
就它只能有字母 数字 加发线 多的组成

03:30.360 --> 03:33.160
那如果你要书写这样的属性名怎么办呢

03:33.960 --> 03:39.260
怎么办 你可以把这个属性名书写成制服串对吧 把它书写成制服串

03:39.660 --> 03:43.660
好 书写成制服串之后呢 那咱们就可以怎么样就可以

03:44.860 --> 03:50.660
使用这个索引表达 就是这个呃成员表达式把它读出来

03:51.060 --> 03:53.360
咱们再读一次试一下 让我看一下 那你看

03:53.960 --> 03:55.560
这个属性它也读出来了

03:56.560 --> 03:59.560
如果我们要手动的去读取呢 手动的读取

03:59.860 --> 04:02.560
我们直接输出我的身份证号 那么就可以使用

04:03.160 --> 04:08.060
中货号 my横杠pid 啊 输出 保存

04:09.060 --> 04:13.360
也没有什么问题 对吧 这是以前的做法啊 以前的做法

04:14.260 --> 04:19.560
以前里边呢 我们在es6学习内的时候啊 应该也接触过这个东西

04:19.960 --> 04:23.360
也接触过这个索引机啊 也就是成员表达式

04:23.960 --> 04:29.160
在es6里边呢 如果你写内的话 会怎么写呢 给他写一下啊

04:30.560 --> 04:34.960
一个有点内 比方说啊 一个有点内 有点内呢 我有个

04:35.660 --> 04:40.060
属性name是一个制服串 好吧 写到勾招函数里边去吧

04:40.760 --> 04:46.050
好 抓个头 我这里有一个属性啊

04:46.550 --> 04:53.550
ablic name是一个制服串 然后呢 有一个属性 age年龄是一个

04:54.550 --> 05:00.550
数字 好 接下来他有一些函数啊 有一些方法 那么这个方法呢

05:00.950 --> 05:04.750
你可以用这种方式来写 比方说啊 你可以用 say hello

05:06.350 --> 05:08.350
你可以用这种方式来写 写这么一个方法

05:09.150 --> 05:17.150
还有一种写法呢 是使用索引器来写 其实以前在ts里面本身就有啊 不是说ts新带来的东西

05:17.650 --> 05:23.250
我们这几个讲索引器呢 只是讲这种写法它的类型检查跟它相关的类型检查

05:23.650 --> 05:27.950
其实这个索引器本来也就是成员表达是 本来就是ts里面有的东西

05:28.750 --> 05:32.750
这是一种成员书写方式 还有一种书写方式呢 是啥呢

05:33.350 --> 05:38.450
在写方法的时候啊 属性当然不用说了 属性的话 如果你要做动态的属性的话

05:38.450 --> 05:43.550
以前在ts里面啊 就可以用这种方式啊 用这种方式来进行动态的属性添加

05:44.150 --> 05:48.750
那是以前的 那么一 如果是方法的话 方法的话你可以这样子写

05:49.550 --> 05:50.550
加上两个中货号

05:51.950 --> 05:53.550
然后呢 这里面写个字不错

05:54.650 --> 05:59.750
你看 这是成员方法 成员方法 你可以在两个中货号里边

06:00.150 --> 06:08.550
动态的书写上方法的名称啊 动态的书写方法名称 也就是这里的纸呢 可以来自于一个辩量啊 比如外面一个辩量

06:09.350 --> 06:09.550
呃

06:10.550 --> 06:16.870
是没舍的内 没舍的内 然后这里呢 我们书写上一个

06:19.150 --> 06:20.150
谁和乐

06:21.150 --> 06:29.350
啊 那么这里 我们把这个辩量写这 把辩量写这 同样的道理啊 这样子呢 他也能成为一个成员方法

06:29.990 --> 06:36.070
也就是说以前的gs呢 可以用这种方式来书写在嘛 这是个成员 那咱们调用一下啊调用一下

06:36.790 --> 06:38.950
定一个用户 用一个优质

06:40.070 --> 06:42.070
传入名字 传入年龄

06:42.870 --> 06:44.070
然后呢 里边方法

06:45.030 --> 06:52.070
没舍的内 没舍的内 他现在只能 他现在只知道这个东西 他是一个辩量 但是这个东西是不是方法名

06:53.510 --> 06:56.070
你能不能这样调用没舍的内

06:56.710 --> 07:02.190
能不能这样调用 哎 他这个 他这个体系在高水 该怎么去使用他 你能不能这样调用呢

07:02.790 --> 07:05.590
肯定是不行了啊 他的方法名

07:06.070 --> 07:11.070
它的方法名不是 method name而是什么呢

07:11.070 --> 07:14.070
而是这个辨量的值作为方法名

07:14.070 --> 07:17.070
把这个辨量的值作为它的成员名穿

07:17.070 --> 07:18.070
搞清楚了啊这里

07:18.070 --> 07:21.070
那么如果你用这种方式调用的话

07:21.070 --> 07:23.070
你就把方法名当成 method name

07:23.070 --> 07:24.070
因此怎么调用

07:24.070 --> 07:27.070
是用成员表达式

07:27.070 --> 07:29.070
这个成员的名字呢

07:29.070 --> 07:31.070
它是一个表达式

07:31.070 --> 07:32.070
它是一个表达式

07:32.070 --> 07:33.070
它都在提示里啊

07:33.070 --> 07:35.070
你应该用这种方式来调用这个方法

07:35.070 --> 07:36.070
它里面有个方法

07:36.070 --> 07:37.070
这个方法的值呢

07:37.070 --> 07:39.070
你应该用这种方式来调用

07:39.070 --> 07:40.070
明白这个意思吗

07:40.070 --> 07:41.070
OK

07:41.070 --> 07:42.070
那么这个怎么调用

07:42.070 --> 07:43.070
就这样调用

07:43.070 --> 07:45.070
就这样调用

07:45.070 --> 07:46.070
这样调用方法

07:46.070 --> 07:48.070
这是以前的知识

07:48.070 --> 07:50.070
不是现在的新知识

07:50.070 --> 07:52.070
好 我们这节课要看的是什么呢

07:52.070 --> 07:53.070
要看的是

07:53.070 --> 07:55.070
这种成员表达式

07:55.070 --> 07:58.070
在ts里面还叫做锁印器

07:58.070 --> 08:01.070
这种焦发的是来自于c-sharp这个语言

08:01.070 --> 08:04.070
c-sharp语言它里面有锁印器

08:04.070 --> 08:07.070
我们要看的是在ts里面

08:07.070 --> 08:10.070
对这一块的类型检查

08:10.070 --> 08:12.070
好 这里呢

08:12.070 --> 08:14.070
给大家先看一个简单的例子

08:14.070 --> 08:15.070
这里的类型检查

08:15.070 --> 08:17.070
有的时候会出一些问题的

08:17.070 --> 08:19.070
因为它是动态的

08:19.070 --> 08:20.070
好 这里呢

08:20.070 --> 08:22.070
我们有一个内

08:22.070 --> 08:24.070
用户内

08:24.070 --> 08:28.070
当我们去创建用户对象的时候

08:28.070 --> 08:29.070
没有这么问题

08:29.070 --> 08:31.070
我们可以写一个

08:31.070 --> 08:34.070
怎么样 写一个年粮

08:34.070 --> 08:36.070
当我们去读取

08:36.070 --> 08:39.070
一个用户它不存在的属性的时候

08:39.070 --> 08:41.070
当我们读取不存在的属性的时候

08:41.070 --> 08:42.070
比方说

08:42.070 --> 08:45.070
我要读取

08:45.070 --> 08:47.070
什么呢

08:47.070 --> 08:48.070
没有这个属性

08:48.070 --> 08:50.070
它会爆错 对吧

08:50.070 --> 08:52.070
但是我有可能

08:52.070 --> 08:54.070
不小心烧过了这个检查

08:54.070 --> 08:56.070
有可能会不小心烧过

08:56.070 --> 08:58.070
怎么烧过呢

08:58.070 --> 08:59.070
我把这个属性呢

08:59.070 --> 09:01.070
用另外一种方式来书写

09:01.070 --> 09:03.070
我们知道刚才演示过

09:03.070 --> 09:05.070
属性的读取呢

09:05.070 --> 09:06.070
可以用这种方式

09:06.070 --> 09:09.070
也可以使用成员表达式

09:09.070 --> 09:12.070
也可以使用成员表达式

09:12.070 --> 09:14.070
那么成员表达式这一块呢

09:14.070 --> 09:16.070
就可以书写一个字五串

09:16.070 --> 09:18.070
来表示属性的名字

09:18.070 --> 09:19.070
它已经在提示里

09:19.070 --> 09:20.070
有这么两个属性

09:20.070 --> 09:21.070
它知道有这么两个属性

09:21.070 --> 09:22.070
一个是 age

09:22.070 --> 09:23.070
一个是 name

09:23.070 --> 09:25.070
有这两个属性

09:25.070 --> 09:26.070
但是呢

09:26.070 --> 09:27.070
我现在再给它

09:27.070 --> 09:28.070
读取另外一个属性

09:28.070 --> 09:29.070
pid

09:29.070 --> 09:31.070
你会发现它不爆错了

09:31.070 --> 09:32.070
我们读书看一下

09:32.070 --> 09:33.070
当然读书的结果

09:33.070 --> 09:34.070
一定是 on the side

09:34.070 --> 09:35.070
没有这个属性

09:35.070 --> 09:36.070
因此呢

09:36.070 --> 09:37.070
我们这里可以记一笔

09:37.070 --> 09:39.070
可以记一笔

09:39.070 --> 09:41.070
在 TS 中

09:41.070 --> 09:43.070
在 TS 中

09:43.070 --> 09:46.070
默认情况下

09:46.070 --> 09:47.070
不对

09:47.070 --> 09:48.070
锁印器

09:48.070 --> 09:51.070
也就是成员表达式

09:51.070 --> 09:53.070
成员表达式

09:53.070 --> 09:56.070
做严格的

09:56.070 --> 09:59.070
严格的类型检查

09:59.070 --> 10:00.070
它不对成员表达式

10:00.070 --> 10:02.070
做严格的类型检查

10:02.070 --> 10:03.070
它为什么不做

10:03.070 --> 10:04.070
严格的类型检查呢

10:04.070 --> 10:05.070
它不是说

10:05.070 --> 10:06.070
它不能做

10:06.070 --> 10:07.070
它可以做

10:07.070 --> 10:08.070
但是它为什么

10:08.070 --> 10:09.070
不做严格的类型检查呢

10:09.070 --> 10:10.070
因为它觉得

10:10.070 --> 10:14.070
你在使用成员表达式的时候

10:14.070 --> 10:15.070
那你想一想

10:15.070 --> 10:16.070
你自己为什么要去

10:16.070 --> 10:17.070
使用这个表达式

10:17.070 --> 10:18.070
这种方式来携带吗

10:18.070 --> 10:21.070
是因为你这个成员名字

10:21.070 --> 10:22.070
是不确定的

10:22.070 --> 10:23.070
往往是不确定的

10:23.070 --> 10:25.070
这里往往会放一个辩量

10:25.070 --> 10:28.070
放一个表达式

10:28.070 --> 10:29.070
它运算的结果

10:29.070 --> 10:31.070
来作为它的成员名称

10:31.070 --> 10:32.070
但是这个时候

10:32.070 --> 10:33.070
又没有运行起来

10:33.070 --> 10:34.070
因此呢

10:34.070 --> 10:35.070
它不太能够确定

10:35.070 --> 10:37.070
你这里的算出来的值是多少

10:37.070 --> 10:38.070
你算出来

10:38.070 --> 10:40.070
一定是这个字幕算PID吗

10:40.070 --> 10:41.070
或者是其他的东西呢

10:41.070 --> 10:43.070
它不能确定

10:43.070 --> 10:44.070
不能确定你这里

10:44.070 --> 10:45.070
算出来的值多少

10:45.070 --> 10:47.070
那你既然在做这么一件事

10:47.070 --> 10:48.070
TS他想了很多

10:48.070 --> 10:49.070
他认为你这里

10:49.070 --> 10:50.070
可能就是要利用

10:50.070 --> 10:53.070
GS这种灵活的特点

10:53.070 --> 10:54.070
来做一些

10:54.070 --> 10:56.070
为非来做一些特殊的东西

10:56.070 --> 10:57.070
因此对这一块

10:57.070 --> 10:59.070
它是比较放松的

10:59.070 --> 11:01.070
允许你使用这种方式

11:01.070 --> 11:03.070
不做严格的内容检查

11:03.070 --> 11:04.070
那么为什么

11:04.070 --> 11:05.070
刚才那种做严格的检查呢

11:05.070 --> 11:06.070
要用这种方式

11:06.070 --> 11:07.070
做严格的检查呢

11:07.070 --> 11:08.070
因为你这种写法

11:08.070 --> 11:09.070
已经能确定

11:09.070 --> 11:11.070
你一定要读PID这个书信

11:11.070 --> 11:13.070
但是你又没有声明这个书信

11:13.070 --> 11:14.070
因此呢

11:14.070 --> 11:15.070
对这一块

11:15.070 --> 11:16.070
他认为你这种写法

11:16.070 --> 11:18.070
是非常容易

11:18.070 --> 11:20.070
非常大的机率

11:20.070 --> 11:21.070
是你写错了

11:21.070 --> 11:22.070
因此他做了

11:22.070 --> 11:23.070
严格的内容检查

11:23.070 --> 11:24.070
明白这个意思吗

11:24.070 --> 11:26.070
他对锁印器

11:26.070 --> 11:28.070
他没有做严格的内容检查

11:28.070 --> 11:29.070
那也就是说

11:29.070 --> 11:30.070
我们这里呢

11:30.070 --> 11:31.070
如果

11:31.070 --> 11:32.070
有些人比方说

11:32.070 --> 11:33.070
代码数学习惯

11:33.070 --> 11:35.070
他是这样子的话

11:35.070 --> 11:36.070
那就可能会遭过

11:36.070 --> 11:37.070
这个内容检查

11:37.070 --> 11:39.070
如果你希望

11:39.070 --> 11:40.070
他在这一块

11:40.070 --> 11:43.070
也做严格的内容检查

11:43.070 --> 11:44.070
那么

11:44.070 --> 11:46.070
你要去开启一个配置

11:46.070 --> 11:49.070
开启什么配置呢

11:49.070 --> 11:51.070
这个配置的名字

11:51.070 --> 11:53.070
叫做

11:53.070 --> 11:55.070
No

11:55.070 --> 11:57.070
Imperate

11:57.070 --> 11:59.070
Any

11:59.070 --> 12:00.070
For

12:00.070 --> 12:01.070
True

12:01.070 --> 12:02.070
把设为True

12:02.070 --> 12:04.070
这个配置我记一下

12:04.070 --> 12:08.150
叫做什么意思

12:08.150 --> 12:11.150
使用配置

12:11.150 --> 12:12.150
什么配置呢

12:12.150 --> 12:13.150
就这个玩意配置

12:13.150 --> 12:14.150
把设为True

12:14.150 --> 12:17.970
开启

12:17.970 --> 12:19.970
对隐私

12:19.970 --> 12:23.970
N里的检查

12:23.970 --> 12:26.970
怎么做隐私N里的检查

12:26.970 --> 12:28.970
我们一步一步来说

12:28.970 --> 12:29.970
就是说

12:29.970 --> 12:31.970
如果

12:31.970 --> 12:32.970
这里有

12:32.970 --> 12:34.970
这里算出来的一些东西

12:34.970 --> 12:35.970
就是

12:35.970 --> 12:36.970
TS

12:36.970 --> 12:37.970
他是无法确定你这里

12:37.970 --> 12:38.970
会算出一个

12:38.970 --> 12:39.970
什么样的表达式

12:39.970 --> 12:40.970
比方说这里

12:40.970 --> 12:41.970
算出来的表达式

12:41.970 --> 12:42.970
是PID

12:42.970 --> 12:44.970
那么这个PID

12:44.970 --> 12:45.970
是不是在U2里面

12:45.970 --> 12:46.970
不存在

12:46.970 --> 12:48.970
不存在怎么办

12:48.970 --> 12:50.970
不存在的话

12:50.970 --> 12:51.970
就意味着

12:51.970 --> 12:52.970
你这个东西

12:52.970 --> 12:53.970
可能是

12:53.970 --> 12:54.970
任何的结果

12:54.970 --> 12:55.970
他也不能确定

12:55.970 --> 12:56.970
这里的内形是什么

12:56.970 --> 12:58.970
如果你写个NAME

12:58.970 --> 12:59.970
写个NAME的话

12:59.970 --> 13:00.970
他能推导出来

13:00.970 --> 13:02.970
这一块内形是一个致负串

13:02.970 --> 13:04.970
如果你写个A一起

13:04.970 --> 13:05.970
他有这个东西

13:05.970 --> 13:06.970
他能推导出来

13:06.970 --> 13:08.970
这里的内形是NUMBER

13:08.970 --> 13:09.970
但是你写的

13:09.970 --> 13:10.970
可能一个不存在的东西

13:10.970 --> 13:11.970
也有可能

13:11.970 --> 13:12.970
是这里的运算

13:12.970 --> 13:13.970
运算结果

13:13.970 --> 13:14.970
是来自于一个

13:14.970 --> 13:15.970
函数的结果

13:15.970 --> 13:16.970
这里来自于一个

13:16.970 --> 13:17.970
函数的调用的返回值

13:17.970 --> 13:18.970
他无法确定

13:18.970 --> 13:20.970
这里返回的到底是啥

13:20.970 --> 13:21.970
所以说

13:21.970 --> 13:23.970
我这里只能使用NAME内形

13:23.970 --> 13:24.970
NAME内形

13:24.970 --> 13:26.970
就可以绕过内形检查

13:26.970 --> 13:27.970
那么这种NAME内形

13:27.970 --> 13:28.970
不是说

13:28.970 --> 13:30.970
我们手动标注的

13:30.970 --> 13:31.970
我们手动认为

13:31.970 --> 13:32.970
它是一个NAME内形

13:32.970 --> 13:33.970
不是的

13:33.970 --> 13:34.970
而是它

13:34.970 --> 13:36.970
根据某些情况下

13:36.970 --> 13:38.970
自己推导出来的NAME内形

13:38.970 --> 13:39.970
这就是叫做

13:39.970 --> 13:41.970
隐释NAME内形

13:41.970 --> 13:42.970
所以说

13:42.970 --> 13:44.970
我这里只能使用NAME内形

13:44.970 --> 13:45.970
NAME内形

13:45.970 --> 13:46.970
就可以绕过内形检查

13:46.970 --> 13:48.970
那么这种NAME内形

13:48.970 --> 13:49.970
不是说

13:49.970 --> 13:51.970
隐释NAME内形

13:51.970 --> 13:55.600
什么叫做隐释NAME内形

13:55.600 --> 13:58.600
隐释NAME

13:58.600 --> 13:59.600
指的是

13:59.600 --> 14:00.600
TS

14:00.600 --> 14:02.600
根据实际情况

14:02.600 --> 14:05.600
推导

14:05.600 --> 14:08.600
推导出的NAME内形

14:08.600 --> 14:10.600
不是我们手动标注的

14:10.600 --> 14:11.600
手动标注的

14:11.600 --> 14:12.600
就没什么问题

14:12.600 --> 14:13.600
但是是它根据实际情况

14:13.600 --> 14:15.600
自己推导出来的NAME内形

14:15.600 --> 14:18.600
那么这种情况下

14:18.600 --> 14:19.600
默认是

14:19.600 --> 14:20.600
不抱错的

14:20.600 --> 14:21.600
我们只有三个点

14:21.600 --> 14:22.600
有个警告

14:22.600 --> 14:24.600
但是你把这个配置开启

14:24.600 --> 14:25.600
NAME

14:25.600 --> 14:26.600
把开启

14:26.600 --> 14:28.600
那么就表示的是

14:28.600 --> 14:29.600
它是一个

14:29.600 --> 14:32.600
不能使用隐释的NAME内形

14:32.600 --> 14:33.600
开启之后

14:33.600 --> 14:34.600
它就在这里抱错了

14:34.600 --> 14:36.600
那么我们通过这种方式

14:36.600 --> 14:38.600
通过这种方式

14:38.600 --> 14:40.600
就可以更加严格的限制

14:40.600 --> 14:41.600
其实这种方式

14:41.600 --> 14:42.600
不仅仅是限制的

14:42.600 --> 14:43.600
所运气

14:43.600 --> 14:45.600
它不仅仅是限制的所运气

14:45.600 --> 14:46.600
比方说

14:46.600 --> 14:47.600
我们写这么一个东西

14:47.600 --> 14:48.600
写个函数

14:48.600 --> 14:49.600
Test

14:49.600 --> 14:52.600
随便传个参数

14:52.600 --> 14:54.600
你看这个参数T也抱错了

14:54.600 --> 14:55.600
同样的原因

14:55.600 --> 14:57.600
它具有隐释的NAME内形

14:57.600 --> 14:59.600
因为你没有给它标注内形

14:59.600 --> 15:01.600
因此它的内形是NAME

15:01.600 --> 15:02.600
它认为你这样子的

15:02.600 --> 15:03.600
你这样子开启的

15:03.600 --> 15:04.600
严格的内形检查之后

15:04.600 --> 15:06.600
它认为这样子的一些代码

15:06.600 --> 15:07.600
是有隐患的

15:07.600 --> 15:08.600
你不应该

15:08.600 --> 15:10.600
如果希望它是NAME的话

15:10.600 --> 15:11.600
你手动标注一下

15:11.600 --> 15:12.600
它是NAME

15:12.600 --> 15:14.600
这样也不会抱错了

15:14.600 --> 15:15.600
因此这个检查

15:15.600 --> 15:17.600
就这个配置

15:17.600 --> 15:18.600
它不仅仅会影响到

15:18.600 --> 15:19.600
所运气

15:19.600 --> 15:20.600
还会影响到很多地方

15:20.600 --> 15:21.600
就看你自己的

15:21.600 --> 15:23.600
如果你在项目过程中

15:23.600 --> 15:25.600
需要更加严格的内形检查

15:25.600 --> 15:26.600
怕自己

15:26.600 --> 15:27.600
有些地方

15:27.600 --> 15:28.600
本来应该有内形推导的

15:28.600 --> 15:30.600
但是结果是NAME

15:30.600 --> 15:32.600
如果你怕这种情况出现的话

15:32.600 --> 15:34.600
你可以把这个写上

15:34.600 --> 15:35.600
好吧

15:35.600 --> 15:37.600
这是我讲的这么一个配置

15:37.600 --> 15:38.600
好

15:38.600 --> 15:39.600
讲了这个配置过后

15:39.600 --> 15:40.600
你就会发现

15:40.600 --> 15:43.600
假设我们现在开启的这个配置

15:43.600 --> 15:44.600
开启的这个配置过后

15:44.600 --> 15:45.600
你看

15:45.600 --> 15:46.600
现在我这样的写字

15:46.600 --> 15:47.600
不能写了

15:47.600 --> 15:48.600
不能写了

15:48.600 --> 15:50.600
那如果

15:50.600 --> 15:51.600
如果刚才看到函数

15:51.600 --> 15:54.600
函数可以手动的标注为N

15:54.600 --> 15:55.600
函数里边

15:55.600 --> 15:57.600
我们可以手动的去标注

15:57.600 --> 15:58.600
一个参数为N

15:58.600 --> 16:00.600
来避免它抱错

16:00.600 --> 16:05.430
A B

16:05.430 --> 16:06.430
比方说我这里

16:06.430 --> 16:08.430
给A标注为N

16:08.430 --> 16:09.430
给B标注为N

16:09.430 --> 16:12.430
来避免它抱错

16:12.430 --> 16:13.430
那么现在就是

16:13.430 --> 16:15.430
显示的手动的指定N

16:15.430 --> 16:16.430
所以它不抱错了

16:16.430 --> 16:17.430
那么这个地方

16:17.430 --> 16:18.430
怎么来手动指定呢

16:18.430 --> 16:20.430
当时你可以用内形推导

16:20.430 --> 16:22.430
那这个东西反不反

16:22.430 --> 16:23.430
内形推导

16:23.430 --> 16:26.430
每次都得自己推导一次

16:26.430 --> 16:29.430
每次都得自己去推导一次

16:29.430 --> 16:30.430
哦,不对哦

16:30.430 --> 16:32.430
这里还不能用内形推导哦

16:32.430 --> 16:34.430
是它这一块抱错了

16:34.430 --> 16:36.430
是它内形内里没有限制

16:36.430 --> 16:38.430
而不是在使用的时候

16:38.430 --> 16:39.430
进行内形推导

16:39.430 --> 16:40.430
内形推导是什么

16:40.430 --> 16:41.430
内形推导是它推导

16:41.430 --> 16:42.430
推导出来一种内形

16:42.430 --> 16:44.430
你把它告诉TS

16:44.430 --> 16:46.430
它是另外一种内形

16:46.430 --> 16:47.430
告诉TS

16:47.430 --> 16:48.430
现在是这一块

16:48.430 --> 16:50.430
以这个代码写法上

16:50.430 --> 16:52.430
就不允许的存在

16:52.430 --> 16:54.430
因为推导出来是N内形

16:54.430 --> 16:56.430
它不允许推导出来是N内形

16:56.430 --> 16:58.430
那这个地方怎么来办呢

16:58.430 --> 16:59.430
怎么做呢

16:59.430 --> 17:01.430
这个地方就要使用

17:01.430 --> 17:03.430
我们这些课的锁印器

17:03.430 --> 17:05.430
其实这些课的知识非常简单

17:05.430 --> 17:07.430
非常非常的简单

17:07.430 --> 17:09.430
这个锁印器怎么写

17:09.430 --> 17:11.430
我这里的语法不好在这里寄

17:11.430 --> 17:12.430
我就直接看代码了

17:12.430 --> 17:14.430
锁印器的写法非常简单

17:14.430 --> 17:16.870
在这里

17:17.870 --> 17:19.870
这是TS的写法

17:19.870 --> 17:20.870
TS的写法

17:20.870 --> 17:22.870
两个综合号

17:22.870 --> 17:24.870
表示这里面还有成员

17:24.870 --> 17:26.870
就除了这两个成员之外

17:26.870 --> 17:28.870
都还有成员

17:28.870 --> 17:30.870
这个成员的内形是什么呢

17:30.870 --> 17:32.870
就是属性的内形

17:32.870 --> 17:33.870
属性名的内形

17:33.870 --> 17:35.870
属性名的内形

17:35.870 --> 17:36.870
当然是一个制服串

17:36.870 --> 17:37.870
对吧

17:37.870 --> 17:39.870
我们给它写一个

17:39.870 --> 17:41.870
属性名的内形是一个制服串

17:41.870 --> 17:43.870
是一个制服串

17:43.870 --> 17:46.870
我现在允许你使用锁印器

17:46.870 --> 17:49.870
通过一个制服串来进行锁印成员

17:50.870 --> 17:51.870
这个东西

17:51.870 --> 17:53.870
这个地方的内形限制

17:53.870 --> 17:55.870
都印到这里

17:55.870 --> 17:56.870
看到没

17:56.870 --> 17:57.870
这个地方的内形限制

17:57.870 --> 17:59.870
都印到这里

17:59.870 --> 18:01.870
通常这里都是写在制服串

18:01.870 --> 18:03.870
因为属性名就是制服串

18:03.870 --> 18:04.870
好

18:04.870 --> 18:06.870
帽号

18:06.870 --> 18:08.870
后面是属性值的内销

18:08.870 --> 18:10.870
属性值的内销

18:10.870 --> 18:11.870
那假设

18:11.870 --> 18:14.870
我们现在在这里属性值写个制服串

18:14.870 --> 18:15.870
你看它有

18:15.870 --> 18:16.870
这个地方不报仇

18:16.870 --> 18:18.870
这个地方报仇了

18:18.870 --> 18:19.870
啥意思

18:19.870 --> 18:21.870
属性0是制服串

18:21.870 --> 18:22.870
这个毫无疑问

18:22.870 --> 18:24.870
这里要传一个制服串

18:24.870 --> 18:27.870
那么属性值是制服串

18:27.870 --> 18:28.870
就是属性的返回值

18:28.870 --> 18:30.870
这个成员的返回值

18:30.870 --> 18:31.870
也得是制服串

18:31.870 --> 18:32.870
也得是制服串

18:32.870 --> 18:34.870
那么就意味着啥呢

18:34.870 --> 18:37.870
就一直跟这个属性是不是矛盾的

18:37.870 --> 18:38.870
因为这个属性是不是

18:38.870 --> 18:39.870
也可以这样访问

18:39.870 --> 18:40.870
对不对

18:40.870 --> 18:42.870
年龄也可以这样的访问

18:42.870 --> 18:44.870
那是不是跟这个属性矛盾了

18:44.870 --> 18:45.870
矛盾了

18:45.870 --> 18:46.870
它是number

18:46.870 --> 18:48.870
但是你这会说的这里要是制服串

18:48.870 --> 18:49.870
明白这个意思吧

18:49.870 --> 18:50.870
那么这个配置

18:50.870 --> 18:52.870
就这个的内形限制

18:52.870 --> 18:55.870
它是对内里边的所有成员

18:55.870 --> 18:57.870
进行的内形限制

18:57.870 --> 18:59.870
我们再写个函数

18:59.870 --> 19:04.560
函数都报仇了

19:04.560 --> 19:05.560
函数报仇了

19:05.560 --> 19:06.560
为什么

19:06.560 --> 19:07.560
函数是不是成员

19:07.560 --> 19:09.560
函数是不是内里边的成员

19:09.560 --> 19:10.560
我调用函数的时候

19:10.560 --> 19:11.560
我们能这样调用

19:11.560 --> 19:12.560
Say hello

19:12.560 --> 19:13.560
你想想

19:13.560 --> 19:16.260
能不能这样调用

19:16.260 --> 19:17.260
调用函数

19:17.260 --> 19:18.260
可不可以这样调用呢

19:18.260 --> 19:19.260
可以的对吧

19:19.260 --> 19:21.260
我们之前是演示过的

19:21.260 --> 19:22.260
可以这样调用函数

19:22.260 --> 19:23.260
那你想

19:23.260 --> 19:24.260
你可以发现

19:24.260 --> 19:26.260
这个锁印器的语法呀

19:26.260 --> 19:28.260
它是通用的

19:28.260 --> 19:30.260
它的范围太广了

19:30.260 --> 19:31.260
它包含了

19:31.260 --> 19:34.260
我们这个内里边所有的属性

19:34.260 --> 19:36.260
包含了这个内里边

19:36.260 --> 19:37.260
所有的成员方法

19:37.260 --> 19:39.260
所有的成员全部包含了

19:39.260 --> 19:40.260
因为所有的成员

19:40.260 --> 19:43.260
都可以使用锁印器的方式来调用

19:43.260 --> 19:45.260
因此这里的反回内形

19:45.260 --> 19:46.260
你咋写呢

19:46.260 --> 19:47.260
你咋写

19:47.260 --> 19:49.260
如果在这种场景下面

19:49.260 --> 19:50.260
你就没发写

19:50.260 --> 19:52.260
你只能写N里

19:52.260 --> 19:53.260
N里

19:53.260 --> 19:54.260
明白这个意思吗

19:54.260 --> 19:56.260
你只能写N里

19:56.260 --> 19:57.260
表示的是

19:57.260 --> 19:58.260
我这里的内形呢

19:58.260 --> 19:59.260
可以是任何内形

19:59.260 --> 20:00.260
因为它有可能是

20:00.260 --> 20:01.260
字不创

20:01.260 --> 20:02.260
有可能是数字

20:02.260 --> 20:04.260
有可能是函数

20:04.260 --> 20:05.260
可以是任何内形

20:05.260 --> 20:06.260
当然如果你不发麻烦的话

20:06.260 --> 20:07.260
你可以使用什么

20:07.260 --> 20:09.260
可以使用联合内形

20:09.260 --> 20:11.260
字不创

20:11.260 --> 20:12.260
囊本

20:12.260 --> 20:13.260
数字

20:13.260 --> 20:14.260
然后还可能是函数

20:14.260 --> 20:16.260
把这个函数的签名

20:16.260 --> 20:17.260
也写过来

20:17.260 --> 20:19.260
过一个

20:20.260 --> 20:21.260
函数

20:21.260 --> 20:22.260
这里

20:22.260 --> 20:24.260
我打上一个大扣号

20:24.260 --> 20:25.260
打上一个大扣号

20:25.260 --> 20:27.830
扣一下

20:27.830 --> 20:29.830
那这样子没问题了

20:29.830 --> 20:30.830
当然呢

20:30.830 --> 20:31.830
如果你要简单的话

20:31.830 --> 20:32.830
直接写N里

20:32.830 --> 20:33.830
好 这样子写的过后

20:33.830 --> 20:35.830
我们再来看

20:35.830 --> 20:36.830
再来看

20:37.830 --> 20:38.830
咱们EU

20:38.830 --> 20:39.830
我们会发现

20:39.830 --> 20:40.830
有些内形检查的

20:40.830 --> 20:41.830
就可以通过了

20:41.830 --> 20:42.830
就可以通过了

20:43.830 --> 20:44.830
有点

20:46.830 --> 20:49.200
这样子写了之后

20:49.200 --> 20:50.200
我们来看一下

20:50.200 --> 20:51.200
它的内形检查

20:55.050 --> 20:56.050
这里

20:56.050 --> 20:57.050
用户这里

20:57.050 --> 20:58.050
我们可以读到

20:59.050 --> 21:00.050
A几

21:00.050 --> 21:01.050
它推断出来还是Number

21:01.050 --> 21:02.050
Name

21:02.050 --> 21:03.050
推断出来还是十击

21:03.050 --> 21:04.050
字不创

21:04.050 --> 21:05.050
Say Hello

21:05.050 --> 21:06.050
推断出来是一个函数

21:06.050 --> 21:08.050
那么我们使用锁印器呢

21:09.050 --> 21:10.050
Name

21:10.050 --> 21:11.050
你看

21:11.050 --> 21:12.050
使用锁印器推断出来

21:12.050 --> 21:13.050
刚才看到没有

21:14.050 --> 21:15.050
使用锁印器推断出来

21:15.050 --> 21:16.050
Name还是字不创

21:16.050 --> 21:17.050
还是字不创

21:17.050 --> 21:19.050
这里该复制的数字

21:19.050 --> 21:20.050
是要爆错的

21:20.050 --> 21:22.050
它能推导出具体的内相

21:22.050 --> 21:23.050
那么这个时候

21:23.050 --> 21:24.050
如果你要给它复制一个

21:24.050 --> 21:26.050
不存在的成员

21:26.050 --> 21:27.050
是可以做了

21:27.050 --> 21:28.050
就可以做了

21:28.050 --> 21:29.050
PID

21:29.050 --> 21:30.050
它不爆错了

21:30.050 --> 21:31.050
因为你它发现

21:31.050 --> 21:32.050
这个东西

21:32.050 --> 21:34.050
不在它声明的成员里边

21:34.050 --> 21:35.050
属性里边没有

21:36.050 --> 21:37.050
方法里边没有

21:37.050 --> 21:38.050
但是呢

21:38.050 --> 21:40.050
有这么一个东西

21:40.050 --> 21:41.050
有这么多东西

21:41.050 --> 21:42.050
它就会应用到这

21:42.050 --> 21:44.050
应用到这里的内相推断

21:44.050 --> 21:45.050
那么也就是说

21:45.050 --> 21:46.050
这个PID它允许的使用

21:46.050 --> 21:47.050
它是字不创

21:47.050 --> 21:48.050
对不对

21:48.050 --> 21:49.050
允许的使用

21:49.050 --> 21:50.050
并且的给你

21:50.050 --> 21:51.050
你该复制

21:51.050 --> 21:52.050
可以复制为任意的字

21:52.050 --> 21:54.050
它的内相是N0

21:54.050 --> 21:56.050
你甚至可以这样子写

21:56.050 --> 21:57.050
PID

21:58.050 --> 21:59.050
甚至可以这样子写

22:00.050 --> 22:01.050
我们以前在接视里边

22:01.050 --> 22:02.050
有的时候要动态的

22:02.050 --> 22:04.050
去添加属性

22:04.050 --> 22:05.050
动态的去扩展属性

22:05.050 --> 22:07.050
做不到怎么办

22:07.050 --> 22:08.050
那么在贴视里面

22:08.050 --> 22:09.050
为什么做不到

22:09.050 --> 22:10.050
它有更严格的内相检查

22:10.050 --> 22:12.050
你可以使用锁印器的那种方式

22:13.050 --> 22:15.050
把这个东西给它开起来

22:15.050 --> 22:16.050
表示的是

22:16.050 --> 22:17.050
我这个内里边的成员

22:17.050 --> 22:18.050
拉可丰富了

22:18.050 --> 22:21.050
有NAM 有A级 有CHello

22:21.050 --> 22:23.050
还有一些我都不知道有啥成员

22:23.050 --> 22:24.050
只要它是一个

22:24.050 --> 22:26.050
只要它的锁印器

22:26.050 --> 22:27.050
有它的属性名

22:27.050 --> 22:28.050
是字不创

22:28.050 --> 22:29.050
成员名是字不创

22:29.050 --> 22:30.050
内相是N0

22:30.050 --> 22:31.050
随便

22:31.050 --> 22:32.050
随便

22:32.050 --> 22:33.050
爱加多少属性

22:33.050 --> 22:34.050
就可以加多少

22:34.050 --> 22:35.050
如果有的时候

22:35.050 --> 22:36.050
你有这样的需求的话

22:36.050 --> 22:38.050
那么就把这个配置给它加上

22:39.050 --> 22:40.050
明白这个意思吗

22:40.050 --> 22:41.050
都是加锁印器

22:43.050 --> 22:45.050
OK 这里我们可以看到

22:45.050 --> 22:47.050
我们刚才使用的是一个

22:47.050 --> 22:48.050
字不创的限制

22:48.050 --> 22:49.050
就对这个属性

22:49.050 --> 22:51.050
对这个成员名字

22:51.050 --> 22:52.050
使用的是一个字不创的限制

22:53.050 --> 22:55.050
那有没有可能是另外的内相呢

22:55.050 --> 22:56.050
可以

22:56.050 --> 22:59.880
在锁印器中

23:03.880 --> 23:04.880
键

23:05.880 --> 23:07.880
就是键子 就是成员名

23:08.880 --> 23:10.880
键的内相

23:10.880 --> 23:12.880
可以是

23:13.880 --> 23:14.880
字不创

23:15.880 --> 23:17.880
也可以是数字

23:17.880 --> 23:18.880
只能2选1

23:18.880 --> 23:20.880
2选1取得两种内相

23:21.880 --> 23:22.880
什么情况下可以是数字呢

23:22.880 --> 23:24.880
你想数组是不是就是数字

23:24.880 --> 23:25.880
数组

23:28.250 --> 23:29.250
AR

23:30.250 --> 23:32.250
NEW

23:32.250 --> 23:33.250
这个玩意啊 数组

23:33.250 --> 23:35.250
它里边是不是就写数字的

23:35.250 --> 23:37.250
对不对 就是写数字的

23:37.250 --> 23:38.250
因此呢 这里呢

23:38.250 --> 23:40.250
也可以是数字

23:40.250 --> 23:41.250
也可以是数字

23:41.250 --> 23:43.250
那么我们来举个数字的例子

23:43.250 --> 23:45.250
举个数字的例子

23:45.250 --> 23:46.250
就比方说

23:46.250 --> 23:47.250
这里呢

23:47.250 --> 23:49.250
我们就模拟个数组吧

23:49.250 --> 23:50.250
写个内

23:50.250 --> 23:51.250
写个内

23:52.250 --> 23:54.250
名字呢 叫做

23:57.250 --> 23:58.250
MyArray

23:58.250 --> 24:00.250
有这么一个内

24:00.250 --> 24:02.250
当然内物不去具体的实现

24:02.250 --> 24:03.250
不去具体的实现

24:03.250 --> 24:05.250
只是把它内相推倒给它做出来

24:06.250 --> 24:08.250
好 我在这个对相里边呢

24:08.250 --> 24:10.250
我写上这么一个数箱

24:10.250 --> 24:12.250
这个数性的名字很奇怪

24:12.250 --> 24:14.250
这个数性的名字呢

24:14.250 --> 24:16.250
名字是0

24:16.250 --> 24:18.250
这个数性的名字是0

24:18.250 --> 24:19.250
那么这个名字肯定不能

24:19.250 --> 24:20.250
不能这样子取

24:20.250 --> 24:21.250
因为在GS里面

24:21.250 --> 24:24.250
它不是一个有效的数性标识服务

24:24.250 --> 24:26.250
你不能写0等于1

24:26.250 --> 24:29.250
我考居然可以这样子写

24:29.250 --> 24:30.250
我考居然

24:30.250 --> 24:32.250
GS里面居然可以支持这样子写

24:32.250 --> 24:34.250
我之前没试过

24:34.250 --> 24:36.250
我只是想想

24:36.250 --> 24:37.250
不能这样子写

24:37.250 --> 24:38.250
在GS里面肯定是不行的

24:38.250 --> 24:40.250
我来把它编译一下

24:40.250 --> 24:42.250
编译一下看到到GS里面是啥

24:42.250 --> 24:44.250
看这里

24:44.250 --> 24:46.250
这个我确实没想到

24:46.250 --> 24:48.250
它居然可以这样子写

24:48.250 --> 24:50.250
TSC 这里我们把编译一下

24:50.250 --> 24:52.250
TSC

24:52.250 --> 24:55.250
不是 MP1Build

24:56.250 --> 24:58.250
厉害呀

24:58.250 --> 25:00.250
可以支持这样子写法

25:00.250 --> 25:02.250
你看一下

25:02.250 --> 25:04.250
到了GS里面还变成了这种写法

25:04.250 --> 25:06.250
就是当前对象使用的是什么

25:06.250 --> 25:08.250
成员表达式对吧

25:08.250 --> 25:09.250
使用成员表达式

25:09.250 --> 25:11.250
给它所应为0的位置

25:11.250 --> 25:12.250
放了一个1

25:12.250 --> 25:13.250
其实这里是所引起对吧

25:13.250 --> 25:14.250
就是它的属性名

25:14.250 --> 25:16.250
成员名字0

25:16.250 --> 25:17.250
这个名字是0

25:17.250 --> 25:19.250
给它存放一个1

25:19.250 --> 25:23.250
在TS里面居然可以这样子写

25:23.250 --> 25:25.250
我真没想到

25:25.250 --> 25:28.250
然后我这里面给它写上

25:28.250 --> 25:30.250
另外一些数组

25:30.250 --> 25:32.250
模拟一下的数组

25:32.250 --> 25:34.250
这个数组假设有三项

25:34.250 --> 25:35.250
创建我的数组

25:35.250 --> 25:36.250
我的数组只能有三项

25:36.250 --> 25:38.250
1

25:38.250 --> 25:40.250
这里随便写个

25:40.250 --> 25:41.250
然后2

25:41.250 --> 25:42.250
所应为2的

25:42.250 --> 25:44.250
当然这些也可以是支付串

25:44.250 --> 25:46.250
也可以是支付串

25:46.250 --> 25:47.250
写成支付串吧

25:47.250 --> 25:48.250
也可以是支付串

25:48.250 --> 25:49.250
可以是任何东西

25:49.250 --> 25:50.250
这个里面可以复制啥

25:50.250 --> 25:51.250
可以复制对象

25:51.250 --> 25:52.250
可以复制支付串

25:52.250 --> 25:54.250
可以复制任何类型

25:54.250 --> 25:56.250
随便写

25:56.250 --> 25:58.250
现在我写好了这么一个类

25:58.250 --> 26:00.250
那么我去使用这个类的对象的时候

26:00.250 --> 26:01.250
来使用一下

26:04.250 --> 26:06.250
我现在做的不是一个数组的功能

26:06.250 --> 26:07.250
要搞清楚

26:07.250 --> 26:08.250
现在做的不是数组的功能

26:08.250 --> 26:09.250
我只是说

26:09.250 --> 26:10.250
这个数组里面

26:10.250 --> 26:12.250
我可以怎么去用它

26:12.250 --> 26:14.250
有什么样的类型推到

26:14.250 --> 26:15.250
这里我就会发现

26:15.250 --> 26:16.250
这个数组里面

26:16.250 --> 26:18.250
我有什么三个属性

26:18.250 --> 26:20.250
那么使用这个属性的时候

26:20.250 --> 26:21.250
使用的就是啥呢

26:21.250 --> 26:23.250
使用的就是所应器

26:23.250 --> 26:24.250
就使用两个综合号

26:24.250 --> 26:25.250
里面加上所应器

26:25.250 --> 26:27.250
大家看一下所应器的类型是啥

26:28.250 --> 26:29.250
是不是支付串

26:29.250 --> 26:31.250
那么现在的所应器的类型

26:31.250 --> 26:32.250
是一个数字

26:32.250 --> 26:33.250
是一个数字

26:33.250 --> 26:34.250
当然如果我在这里

26:34.250 --> 26:35.250
写一个不存在的数字

26:35.250 --> 26:36.250
它要爆错的

26:36.250 --> 26:37.250
它要爆错的

26:37.250 --> 26:39.250
那如果我希望

26:39.250 --> 26:41.250
我这个对象它是可以扩展的

26:41.250 --> 26:43.250
它除了有前边

26:43.250 --> 26:44.250
三项固定的东西

26:44.250 --> 26:45.250
后边还可以扩展

26:45.250 --> 26:47.250
扩展出一些

26:47.250 --> 26:48.250
其他的数据

26:48.250 --> 26:49.250
比方说

26:49.250 --> 26:50.250
你可以给它复制3

26:50.250 --> 26:51.250
复制4 复制5

26:51.250 --> 26:52.250
到底复制多少

26:52.250 --> 26:53.250
其实我有所谓的

26:53.250 --> 26:55.250
那这个时候怎么办

26:55.250 --> 26:56.250
我就可以给它

26:56.250 --> 26:58.250
加上一个类型检查

26:58.250 --> 26:59.250
本来这个代码在

26:59.250 --> 27:00.250
GS面是直接认的

27:00.250 --> 27:01.250
直接认这个代码

27:01.250 --> 27:02.250
但是在TS面

27:02.250 --> 27:04.250
它发现它有隐私的

27:04.250 --> 27:05.250
N型类型

27:05.250 --> 27:06.250
隐私的它不认这个代码

27:06.250 --> 27:08.250
好 这个时候怎么办

27:08.250 --> 27:09.250
我认为这个数字

27:09.250 --> 27:10.250
可以继续扩展

27:10.250 --> 27:12.250
我这里加上一个所应器

27:12.250 --> 27:14.250
比方说

27:14.250 --> 27:15.250
该取个名字

27:15.250 --> 27:16.250
名字无所谓的

27:16.250 --> 27:17.250
这个名字只是标识一下

27:17.250 --> 27:18.250
无所谓的

27:18.250 --> 27:20.250
Number类型

27:20.250 --> 27:21.250
所应器的

27:21.250 --> 27:22.250
就是所应器

27:22.250 --> 27:23.250
两个综合号里面

27:23.250 --> 27:24.250
写的是Number类型

27:24.250 --> 27:26.250
那么整个返回的结果

27:26.250 --> 27:27.250
是一个字幕串

27:27.250 --> 27:28.250
是一个字幕串

27:28.250 --> 27:30.250
我写上这么一个东西

27:30.250 --> 27:32.250
这里

27:32.250 --> 27:34.250
所应器应该书写到最上边

27:34.250 --> 27:36.250
应该书写到最顶部

27:36.250 --> 27:37.250
所应器

27:37.250 --> 27:39.250
这里写下

27:39.250 --> 27:40.250
它一个语法上的要求

27:40.250 --> 27:43.250
就是所应器在内中

27:43.250 --> 27:45.250
在内中

27:45.250 --> 27:46.250
在内中

27:46.250 --> 27:48.250
所应器

27:48.250 --> 27:50.250
书写的位置

27:50.250 --> 27:53.250
应该是所有成员

27:53.250 --> 27:55.250
成员

27:55.250 --> 27:57.250
所有成员之前

27:57.250 --> 27:58.250
这是所应器书写的位置

27:58.250 --> 28:00.250
也就是这里

28:00.250 --> 28:02.250
比方说前面还有成员

28:02.250 --> 28:03.250
比方说前面还有成员

28:03.250 --> 28:05.250
比方说内

28:05.250 --> 28:06.250
内

28:06.250 --> 28:08.250
还有成员

28:08.250 --> 28:09.250
那么这里

28:09.250 --> 28:10.250
所应器是要报错了

28:10.250 --> 28:11.250
所应器要报错了

28:11.250 --> 28:13.250
所应器在内里边书写

28:13.250 --> 28:14.250
在内里边书写

28:14.250 --> 28:15.250
是要书写在最顶端的

28:15.250 --> 28:18.250
所有成员之前的

28:18.250 --> 28:19.250
好

28:19.250 --> 28:20.250
那么现在这样子写的过后

28:20.250 --> 28:21.250
你看

28:21.250 --> 28:22.250
我现在比方说

28:22.250 --> 28:23.250
不好的书组

28:23.250 --> 28:25.250
它默认有前面3项

28:25.250 --> 28:26.250
012

28:26.250 --> 28:27.250
那么这个书组里边

28:27.250 --> 28:29.250
除了有这些东西之外

28:29.250 --> 28:31.250
我们还可以给它扩展一些项

28:31.250 --> 28:33.250
比方说第四项是多少

28:33.250 --> 28:35.250
我举这么一个例子

28:35.250 --> 28:36.250
这样的书写要报错

28:36.250 --> 28:37.250
为什么

28:37.250 --> 28:38.250
因为它要求

28:38.250 --> 28:40.250
所应器的内情

28:40.250 --> 28:41.250
是置物串

28:41.250 --> 28:43.250
这里应该是置物串

28:43.250 --> 28:45.250
应该这个意思吧

28:45.250 --> 28:46.250
就是这里

28:46.250 --> 28:47.250
给它讲一讲

28:47.250 --> 28:48.250
所应器

28:48.250 --> 28:50.250
它是怎么来进行内情检查的

28:50.250 --> 28:53.250
可以总结一下

28:53.250 --> 28:55.250
所应器的作用

28:55.250 --> 28:56.250
所应器

28:56.250 --> 28:59.250
TS中

28:59.250 --> 29:01.250
所应器的作用

29:01.250 --> 29:03.250
第一个作用

29:03.250 --> 29:06.250
在严格的

29:06.250 --> 29:12.250
严格的检查下

29:12.250 --> 29:17.250
可以实现为内

29:18.250 --> 29:22.250
应该就是为内增加动态

29:22.250 --> 29:24.250
增加成员

29:24.250 --> 29:26.250
可以实现为内动态增加成员

29:26.250 --> 29:28.250
以前是做不到的

29:28.250 --> 29:31.250
因为以前在TS的严格内情检查之下

29:31.250 --> 29:34.250
我们是不允许为内增加成员的

29:34.250 --> 29:36.250
如果你确实有这个需求

29:36.250 --> 29:37.250
保不起一忧的时候

29:37.250 --> 29:38.250
就有这个需求

29:38.250 --> 29:40.250
如果你确实有这个需求的话

29:40.250 --> 29:42.250
你可以使用所应器

29:42.250 --> 29:44.250
来标注一下

29:44.250 --> 29:47.250
这个内里边还会有一些其他成员

29:47.250 --> 29:51.250
下一个

29:51.250 --> 29:55.250
可以实现动态的

29:55.250 --> 30:01.250
动态的操作内成员

30:01.250 --> 30:02.250
什么叫动态的操作内成员

30:02.250 --> 30:04.250
就是我们之前演示的

30:04.250 --> 30:05.250
你的内成员

30:05.250 --> 30:06.250
我也不知道操作的是啥

30:06.250 --> 30:07.250
可能只是一个表达

30:07.250 --> 30:09.250
可能放在一个变量里边

30:09.250 --> 30:10.250
这个变量里边

30:10.250 --> 30:12.250
记住了我要操作的属性

30:12.250 --> 30:14.250
操作的函数

30:14.250 --> 30:15.250
操作的方法

30:15.250 --> 30:16.250
但是我并不知道

30:16.250 --> 30:17.250
这个变量到底指示啥

30:17.250 --> 30:18.250
那么这个时候

30:18.250 --> 30:20.250
如果你使用的话

30:20.250 --> 30:22.250
在严格的内情检查下边

30:22.250 --> 30:23.250
就加了这个

30:23.250 --> 30:25.250
加了这个就是检查之后

30:25.250 --> 30:26.250
它会包错了

30:26.250 --> 30:28.250
如果你确实希望这样做

30:28.250 --> 30:30.250
那么你可以使用所应器

30:30.250 --> 30:32.250
所应器这个位置

30:32.250 --> 30:34.250
其实咱们在TS里边

30:34.250 --> 30:36.250
用的不是很多

30:36.250 --> 30:38.250
但是我还是要讲

30:38.250 --> 30:40.250
你讲这一块

30:40.250 --> 30:42.250
最后我要讲一个东西

30:42.250 --> 30:44.250
就是关于所应器的内相

30:44.250 --> 30:46.250
咱们之前说

30:46.250 --> 30:48.250
所应器它可以是一个

30:48.250 --> 30:49.250
制服串

30:49.250 --> 30:51.250
也可以是一个数字

30:51.250 --> 30:53.250
可以是这两个内相之一

30:53.250 --> 30:54.250
但是大家

30:54.250 --> 30:57.250
这个地方考验大家的基础来了

30:57.250 --> 31:00.250
基本功扎不扎实

31:00.250 --> 31:02.250
我们使用所应器

31:02.250 --> 31:05.250
也就是成员表达式的时候

31:05.250 --> 31:07.250
制服串和数字

31:07.250 --> 31:09.250
其实是一样的

31:09.250 --> 31:10.250
是一样的

31:10.250 --> 31:12.250
它们都最终的结果

31:12.250 --> 31:14.250
数字的结果其实是制服串的

31:14.250 --> 31:15.250
给大家看一个例子

31:15.250 --> 31:16.250
这是一道面试题

31:16.250 --> 31:18.250
以前介石的知识

31:18.250 --> 31:20.250
不是跟TS没有什么关系

31:20.250 --> 31:22.250
是介石的知识

31:22.250 --> 31:24.250
有道面试题它是这样的温的

31:24.250 --> 31:26.250
这里有个数组

31:26.250 --> 31:29.250
有这么一个数组

31:29.250 --> 31:31.250
这个数组里边

31:31.250 --> 31:33.250
我放了这么一个东西

31:33.250 --> 31:38.270
在TS里面要标准一下

31:38.270 --> 31:39.270
要标准一下

31:40.270 --> 31:42.270
这里它是个什么数组

31:42.270 --> 31:43.270
Number数组

31:43.270 --> 31:45.270
Number类型的数组

31:45.270 --> 31:47.270
这个数组里边

31:47.270 --> 31:50.270
我放入一个字

31:50.270 --> 31:53.270
然后我再用这个数型

31:53.270 --> 31:56.270
放入一个字

31:56.270 --> 31:59.270
在TS里面

32:00.270 --> 32:02.270
这样子

32:02.270 --> 32:05.270
我把它设置为n例

32:05.270 --> 32:07.270
在TS里面没发写

32:07.270 --> 32:09.270
在TS里面没发写这个代码

32:09.270 --> 32:10.270
好

32:10.270 --> 32:11.270
给它设置为n例

32:11.270 --> 32:12.270
OK

32:12.270 --> 32:14.270
我在字幕串里面再放置一个字

32:14.270 --> 32:16.270
再放置一个字

32:16.270 --> 32:18.270
然后呢

32:18.270 --> 32:19.270
我现在问

32:19.270 --> 32:21.270
它现在问你

32:21.270 --> 32:25.270
我输出AR0

32:25.270 --> 32:27.270
它的值是多少

32:27.270 --> 32:28.270
我输出这个值

32:28.270 --> 32:29.270
它的值是多少

32:29.270 --> 32:30.270
其实就问你

32:30.270 --> 32:32.270
它的结果就是1还是3

32:32.270 --> 32:33.270
输多少呢

32:33.270 --> 32:39.330
咱们来看一下

32:39.330 --> 32:41.330
看一下它输出的值

32:41.330 --> 32:43.330
它输出的结果是3

32:43.330 --> 32:45.330
怎么回事呢

32:45.330 --> 32:47.330
怎么输出的结果变成3了呢

32:47.330 --> 32:49.330
这咋回事

32:49.330 --> 32:51.330
大家想一个道理

32:51.330 --> 32:53.330
在GS里边

32:53.330 --> 32:57.330
实际上所有的成员名

32:57.330 --> 32:59.330
所有的成员名都是支付串

32:59.330 --> 33:01.330
这是以前的知识的

33:01.330 --> 33:03.330
可能大家可能忘记了

33:03.330 --> 33:07.330
就在GS中

33:07.330 --> 33:10.330
所有的成员名

33:10.330 --> 33:14.330
本质上都是支付串

33:14.330 --> 33:15.330
都是支付串

33:15.330 --> 33:17.330
不存在什么数字成员名的

33:17.330 --> 33:18.330
不存在的

33:18.330 --> 33:20.330
所有的成员名都是支付串

33:20.330 --> 33:23.330
如果使用数字

33:23.330 --> 33:26.330
作为成员名

33:26.330 --> 33:28.330
如果你使用的是这么方式

33:28.330 --> 33:29.330
数字作为成员名

33:29.330 --> 33:31.330
你看这里使用的是数字

33:31.330 --> 33:33.330
作为相当于是读下的属性

33:33.330 --> 33:35.330
属性的名字是0

33:36.330 --> 33:38.330
如果使用数字作为成员名

33:38.330 --> 33:43.330
会自动转换为支付串

33:43.330 --> 33:44.330
就是有的时候

33:44.330 --> 33:45.330
一写的带嘛

33:45.330 --> 33:47.330
写的写的可能写云的

33:47.330 --> 33:48.330
就可能忘记了这一点

33:48.330 --> 33:50.330
那么在GS里边

33:50.330 --> 33:51.330
在GS里边

33:51.330 --> 33:53.330
你是不可能忘记这一点的

33:53.330 --> 33:55.330
因为它不停的在提示里

33:55.330 --> 33:56.330
比方刚才我这里

33:56.330 --> 33:58.330
规定为一个number的数数

33:58.330 --> 33:59.330
一个number的数数

33:59.330 --> 34:01.330
你看它这里报错了

34:01.330 --> 34:04.330
就说在GS里边

34:04.330 --> 34:05.330
你的锁印器

34:05.330 --> 34:07.330
你要么是数字

34:07.330 --> 34:08.330
要么是支付串

34:08.330 --> 34:09.330
除非你手动声明

34:09.330 --> 34:10.330
可以写支付串

34:10.330 --> 34:11.330
可以写数字

34:11.330 --> 34:13.330
否则的话只能写其中一种

34:13.330 --> 34:14.330
只能写其中一种

34:14.330 --> 34:15.330
比方说

34:15.330 --> 34:17.330
我们自己写个锁印器

34:17.330 --> 34:18.330
刚才的

34:18.330 --> 34:19.330
随便写吧

34:19.330 --> 34:21.330
我这里只是举一个语法的意思的

34:21.330 --> 34:22.330
一个内A

34:22.330 --> 34:23.330
内A

34:23.330 --> 34:25.330
我里边写了一个锁印器

34:25.330 --> 34:27.330
这个锁印器是数字

34:27.330 --> 34:28.330
是数字

34:28.330 --> 34:29.330
那么返回了结果

34:29.330 --> 34:32.330
比方说是一个支付串

34:32.330 --> 34:33.330
比方说

34:33.330 --> 34:34.330
A里边的成员

34:34.330 --> 34:36.330
所有的成员

34:36.330 --> 34:38.330
名字成员名是数字

34:38.330 --> 34:40.330
成员的值是支付串

34:40.330 --> 34:41.330
这样标注一下

34:41.330 --> 34:43.330
我这里创建一个A的对象

34:43.330 --> 34:47.710
然后使用锁印器的时候

34:47.710 --> 34:48.710
我这里

34:48.710 --> 34:49.710
如果你写支付串

34:49.710 --> 34:50.710
它报错的

34:50.710 --> 34:51.710
它报错的

34:51.710 --> 34:52.710
它说

34:52.710 --> 34:53.710
你这里

34:53.710 --> 34:55.710
因为它没有写支付串的锁印器

34:55.710 --> 34:56.710
因此

34:56.710 --> 34:57.710
它这里推到出来是N内行

34:57.710 --> 35:00.710
它不允许推到出来是N内行

35:00.710 --> 35:02.710
因为我们这里有这个检查

35:02.710 --> 35:03.710
有这个检查

35:03.710 --> 35:05.710
如果我这里写数字

35:05.710 --> 35:07.710
那里没问题了

35:07.710 --> 35:08.710
然后复制啥

35:08.710 --> 35:10.710
复制为一个支付串

35:10.710 --> 35:11.710
你看这里都对上了

35:11.710 --> 35:15.710
锁印器的值内行

35:15.710 --> 35:16.710
锁印器的

35:16.710 --> 35:18.710
锁印器的名称

35:18.710 --> 35:19.710
锁印器的名称的内行

35:19.710 --> 35:21.710
锁印器的值

35:21.710 --> 35:22.710
锁印器值的内行

35:22.710 --> 35:23.710
就对上了

35:23.710 --> 35:24.710
在TS里面

35:24.710 --> 35:25.710
你是不容易犯

35:25.710 --> 35:27.710
刚才那种代码的错误的

35:27.710 --> 35:28.710
这是锁印器

35:28.710 --> 35:29.710
那如果

35:29.710 --> 35:30.710
如果我这里

35:30.710 --> 35:32.710
该写两个锁印器

35:32.710 --> 35:35.710
可不可以呢

35:35.710 --> 35:36.710
POP

35:36.710 --> 35:39.710
支付串

35:39.710 --> 35:40.710
支付串

35:40.710 --> 35:41.710
发挥的也是个支付串

35:41.710 --> 35:43.710
可不可以这样子写呢

35:43.710 --> 35:44.710
可以的

35:44.710 --> 35:45.710
没问题

35:45.710 --> 35:46.710
那么现在它又支持了

35:46.710 --> 35:48.710
既可以支持数字

35:48.710 --> 35:49.710
作为锁印器

35:49.710 --> 35:50.710
也可以支持支付串

35:50.710 --> 35:52.710
作为锁印器

35:52.710 --> 35:53.710
那么这个东西

35:53.710 --> 35:54.710
匹配到这

35:54.710 --> 35:56.710
这个东西匹配到这

35:56.710 --> 35:57.710
但是这里

35:57.710 --> 35:58.710
有一个小的细节

35:58.710 --> 36:00.710
大家注意一下

36:00.710 --> 36:01.710
看着

36:01.710 --> 36:07.900
这样的报处

36:07.900 --> 36:09.900
为什么它有报处

36:09.900 --> 36:11.900
你想一个逻辑

36:11.900 --> 36:12.900
这个逻辑

36:12.900 --> 36:13.900
所以说真的是TS

36:13.900 --> 36:15.900
它不是给你制造麻烦的

36:15.900 --> 36:17.900
当有错误产生的话

36:17.900 --> 36:19.900
它就觉得这里一定是有隐患的

36:19.900 --> 36:21.900
一定是有隐患

36:21.900 --> 36:24.900
它为什么要这样的报处呢

36:24.900 --> 36:26.900
想想这个道理

36:26.900 --> 36:28.900
我们之前说过

36:28.900 --> 36:30.900
在JS里边

36:30.900 --> 36:33.900
不存在

36:33.900 --> 36:35.900
数字作为成员密

36:35.900 --> 36:37.900
它最终都是支付串

36:37.900 --> 36:39.900
作为成员密

36:39.900 --> 36:40.900
也就是说

36:40.900 --> 36:42.900
如果你这样子要求了

36:42.900 --> 36:44.900
你要求啥呢

36:44.900 --> 36:46.900
你要求你这里的

36:46.900 --> 36:48.900
如果你是个数字的话

36:48.900 --> 36:51.900
这个代码在JS里边

36:51.900 --> 36:53.900
本质上是啥

36:53.900 --> 36:55.900
本质上就是支付串

36:55.900 --> 36:57.900
它本质上就是支付串

36:57.900 --> 36:59.900
那你这样做了过后

36:59.900 --> 37:00.900
虽然你说的

37:00.900 --> 37:02.900
这里数字作为锁印的时候呢

37:02.900 --> 37:03.900
是支付串

37:03.900 --> 37:05.900
但是真正的结果里边呢

37:05.900 --> 37:07.900
它其实是支付串啊

37:07.900 --> 37:08.900
这个名字

37:08.900 --> 37:09.900
这个东西

37:09.900 --> 37:11.900
你写数字只是愚法堂而已

37:11.900 --> 37:13.900
它可以让你简单书写一下

37:13.900 --> 37:15.900
最终会转换成支付串的

37:15.900 --> 37:17.900
那转换成支付串之后

37:17.900 --> 37:18.900
转换成支付串之后

37:18.900 --> 37:20.900
它又要求支付串是Number的一项

37:20.900 --> 37:21.900
是不是矛盾了

37:21.900 --> 37:23.900
是不是矛盾了

37:23.900 --> 37:26.900
因此这里就会出现矛盾

37:26.900 --> 37:28.900
因此TS

37:28.900 --> 37:30.900
认为你这样子写

37:30.900 --> 37:31.900
隐患又出现了

37:31.900 --> 37:33.900
你虽然说的你说

37:33.900 --> 37:35.900
数字作为锁印的时候

37:35.900 --> 37:37.900
是支付串

37:37.900 --> 37:39.900
但是呢实际上数字本来就

37:39.900 --> 37:41.900
这个成员名字本来就是支付串

37:41.900 --> 37:43.900
而支付串又是Number

37:43.900 --> 37:44.900
它就矛盾了

37:44.900 --> 37:46.900
因此它不让你这样去做

37:46.900 --> 37:48.900
因此它有这么一个规则

37:48.900 --> 37:49.900
在TS中

37:49.900 --> 37:51.900
由于数字本来就是支付串

37:51.900 --> 37:53.900
本质上会转换成支付串

37:53.900 --> 37:55.900
在TS中

37:57.900 --> 38:00.900
如果某个内

38:00.900 --> 38:03.900
使用了

38:03.900 --> 38:08.900
使用了两种内型的锁印器

38:08.900 --> 38:09.900
什么叫两种内型

38:09.900 --> 38:11.900
就是锁印器的内型可以是支付串

38:11.900 --> 38:13.900
也可以是数字

38:13.900 --> 38:16.900
它又要求

38:16.900 --> 38:23.900
两种锁印器的直内型必须匹配

38:23.900 --> 38:25.900
必须匹配

38:25.900 --> 38:27.900
就这两个内型的直必须匹配

38:27.900 --> 38:28.900
最好是一样

38:28.900 --> 38:30.900
如果可不可以不一样

38:30.900 --> 38:31.900
可以不一样

38:31.900 --> 38:33.900
不一样的话就一个需求的细节

38:33.900 --> 38:35.900
就一个细节就是Number内型

38:35.900 --> 38:38.900
它这里的内型必须是它的直内型

38:38.900 --> 38:39.900
比如说它的直内型

38:39.900 --> 38:41.900
它就有这么一个要求

38:41.900 --> 38:43.900
就这么一个要求

38:43.900 --> 38:45.900
比方说我这里

38:45.900 --> 38:47.900
Number内型我要求

38:47.900 --> 38:49.900
比方说

38:49.900 --> 38:51.900
一个B

38:51.900 --> 38:53.900
比方说

38:53.900 --> 38:55.900
它的内型必须是个B

38:55.900 --> 38:56.900
一个B的内的对象

38:56.900 --> 38:58.900
那么这里我可以使用Object的

38:58.900 --> 38:59.900
这样没问题的

38:59.900 --> 39:01.900
就这个内象必须是它的直内想

39:01.900 --> 39:02.900
你想这个道理

39:02.900 --> 39:03.900
你自己想

39:03.900 --> 39:04.900
好好理一下这个道理

39:04.900 --> 39:05.900
是不是这个道理

39:05.900 --> 39:07.900
因为它只有是它的直内想过后

39:07.900 --> 39:09.900
才是安全的

39:09.900 --> 39:11.900
因为数字本质上就是支付串

39:11.900 --> 39:13.900
所以说它也得是它

39:13.900 --> 39:15.900
它也得是一个它

39:15.900 --> 39:17.900
B也得是一个Object的对象

39:17.900 --> 39:18.900
也得是一个对象

39:18.900 --> 39:20.900
必须是它的直内想

39:20.900 --> 39:21.900
好

39:21.900 --> 39:24.900
这是关于锁印器这一块

39:24.900 --> 39:25.900
锁印器这一块的知识

39:25.900 --> 39:27.900
其实我们用的不是很多

39:27.900 --> 39:28.900
其实医生呢

39:28.900 --> 39:30.900
医生带着大家

39:30.900 --> 39:31.900
回忆一下

39:31.900 --> 39:33.900
回忆一下之前介石这一块的知识

39:33.900 --> 39:35.900
主要是介石的知识

39:35.900 --> 39:36.900
那么我们这几颗讲的

39:36.900 --> 39:37.900
只要指示

39:37.900 --> 39:39.900
在介石的这种写法基础上

39:39.900 --> 39:41.900
做一些内容的检查

39:41.900 --> 39:43.900
你可以使用锁印器

39:43.900 --> 39:45.900
好 这是这几颗的内容

39:45.900 --> 39:47.900
一个锁印器的想知识

39:47.900 --> 39:49.900
好 那么这一颗到这里了

39:49.900 --> 39:50.900
拜拜

