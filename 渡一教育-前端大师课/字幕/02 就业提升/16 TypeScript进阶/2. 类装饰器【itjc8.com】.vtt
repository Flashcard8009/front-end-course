WEBVTT

00:00.940 --> 00:02.940
好 那么咱们这节课开始

00:02.940 --> 00:06.440
也开始具体来学习装饰器的代码

00:06.440 --> 00:08.440
如何来进行书写

00:08.440 --> 00:11.440
咱们前面说过 装饰器这个东西呢

00:11.440 --> 00:15.440
它可以修饰内 修饰属性 修饰方法

00:15.440 --> 00:18.440
修饰方法的参数

00:18.440 --> 00:21.440
好 那么在这节课呢

00:21.440 --> 00:25.440
我们就来学习它如何来修饰一个内

00:25.440 --> 00:28.440
这节课设计到知识点还蛮多的

00:28.440 --> 00:30.440
我这里又想了

00:30.440 --> 00:33.440
如果要做一个实际有意义的练习呢

00:33.440 --> 00:36.440
好像在学习的过程中

00:36.440 --> 00:39.440
还不太容易找到这样子

00:39.440 --> 00:41.440
一种有实际意义的练习

00:41.440 --> 00:43.440
否则的话 它会变得很复杂

00:43.440 --> 00:45.440
因此呢 咱们学习的时候

00:45.440 --> 00:47.440
用这种学习方式

00:47.440 --> 00:49.440
先来学习它的语法

00:49.440 --> 00:51.440
把它的语法有这么一个概念

00:51.440 --> 00:53.440
知道它该怎么来操作

00:53.440 --> 00:55.440
学习的语法之后呢

00:55.440 --> 00:57.440
在本章节后边呢

00:57.440 --> 00:59.440
会加重一些练习

00:59.440 --> 01:02.440
好吧 OK 我们这里呢

01:02.440 --> 01:04.440
首先学习的是内装饰期

01:04.440 --> 01:07.440
就是装饰期用来修饰内

01:07.440 --> 01:10.440
我们始终记住装饰期的本质

01:10.440 --> 01:14.440
装饰期的本质是一个函数

01:14.440 --> 01:17.440
但是呢 这个函数的格式

01:17.440 --> 01:20.440
在TS里边 它是有要求的

01:20.440 --> 01:22.440
GS 是没有内型检查

01:22.440 --> 01:24.440
GS没有内型检查 它没有什么要求

01:24.440 --> 01:26.440
但是在TS里边

01:26.440 --> 01:28.440
它加了一些内型的约束

01:28.440 --> 01:30.440
有一些参数的数量啊

01:30.440 --> 01:32.440
参数的内型啊

01:32.440 --> 01:34.440
这个函数的参数内型啊

01:34.440 --> 01:36.440
这些东西都是有一些约束的

01:36.440 --> 01:38.440
所以说 我们了

01:38.440 --> 01:42.440
学习装饰期的时候

01:42.440 --> 01:44.440
它修饰不同的东西

01:44.440 --> 01:46.440
它这个函数的格式呢

01:46.440 --> 01:47.440
都是有点差异的

01:47.440 --> 01:48.440
在TS里边有差异

01:48.440 --> 01:50.440
在GS里边它没有要求

01:50.440 --> 01:53.440
首先是 它如果修饰内的话

01:53.440 --> 01:56.440
首先它本质是一个函数

01:56.440 --> 01:59.440
该函数 应该这样说

01:59.440 --> 02:02.440
内装饰期的本质是一个函数

02:02.440 --> 02:07.440
该函数接收一个参数

02:07.440 --> 02:10.440
表示内本身

02:10.440 --> 02:13.440
也就是构造函数本身

02:13.440 --> 02:14.440
构造函数本身

02:14.440 --> 02:15.440
因为我们知道

02:15.440 --> 02:16.440
内在GS里边

02:16.440 --> 02:18.440
本质上就是一个函数 对吧

02:18.440 --> 02:19.440
它就是一个构造函数

02:19.440 --> 02:21.440
它本身是一个愚法堂恶意

02:21.440 --> 02:23.440
所以说 这个参数

02:23.440 --> 02:24.440
它表示内

02:24.440 --> 02:26.440
它就表示的是一个构造函数

02:26.440 --> 02:27.440
好 我们直接来代码吧

02:27.440 --> 02:29.440
在代码中来举这个例子

02:29.440 --> 02:30.440
好 我们比方说

02:30.440 --> 02:32.440
我们这里写这么一个内

02:32.440 --> 02:34.440
随便写个内

02:34.440 --> 02:36.440
写这么一个内

02:36.440 --> 02:38.440
就A吧

02:38.440 --> 02:40.440
其他里面也没有啥属性

02:40.440 --> 02:41.440
没有啥属性

02:41.440 --> 02:42.440
好 比方说

02:42.440 --> 02:45.440
我要给这个内加一个装饰器

02:45.440 --> 02:47.440
那么这个装饰器呢

02:47.440 --> 02:49.440
就是以A打开头

02:49.440 --> 02:50.440
使用的时候

02:50.440 --> 02:51.440
是以A打开头

02:51.440 --> 02:53.440
我们再记一笔

02:53.440 --> 02:55.440
使用装饰器

02:55.440 --> 02:57.440
使用装饰器时

02:57.440 --> 02:59.440
它的愚法是

02:59.440 --> 03:00.440
A打开头

03:00.440 --> 03:03.440
然后是装饰器名

03:03.440 --> 03:04.440
装饰器名

03:04.440 --> 03:05.440
总之

03:05.440 --> 03:07.440
A打后边的东西

03:07.440 --> 03:08.440
一定是一个函数

03:08.440 --> 03:10.440
一定要得到一个函数

03:10.440 --> 03:12.440
这样子说

03:12.440 --> 03:14.440
得到一个函数

03:14.440 --> 03:15.440
就是A打后边的东西

03:15.440 --> 03:17.440
一定是要是一个函数

03:17.440 --> 03:18.440
并且函数的格式呢

03:18.440 --> 03:20.440
要满足要求

03:20.440 --> 03:22.440
现在我们使用的是内装饰器

03:22.440 --> 03:23.440
因此呢

03:23.440 --> 03:25.440
我就必须要写这么一个函数

03:25.440 --> 03:27.440
比方Test

03:27.440 --> 03:30.440
我们就必须要写这么一个函数

03:30.440 --> 03:31.440
函数名字呢

03:31.440 --> 03:33.440
叫做Test

03:33.440 --> 03:35.440
这个函数有没有参数呢

03:35.440 --> 03:37.440
这个函数有没有参数

03:37.440 --> 03:38.440
在ts里面

03:38.440 --> 03:39.440
它无所谓

03:39.440 --> 03:40.440
ts它没有类型检查

03:40.440 --> 03:41.440
它无所谓

03:41.440 --> 03:42.440
但是呢

03:42.440 --> 03:43.440
在ts里面

03:43.440 --> 03:44.440
它有类型检查

03:44.440 --> 03:46.440
它有严格的约数

03:46.440 --> 03:47.440
因此呢

03:47.440 --> 03:48.440
它要求这个函数

03:48.440 --> 03:50.440
必须要接受一个参数

03:50.440 --> 03:51.440
这个参数呢

03:51.440 --> 03:52.440
表示内本身

03:52.440 --> 03:53.440
好

03:53.440 --> 03:54.440
于是呢

03:54.440 --> 03:55.440
这里要接受一个参数

03:55.440 --> 03:56.440
我们随便写个吧

03:56.440 --> 03:57.440
Target

03:57.440 --> 03:59.440
这个参数什么意思

03:59.440 --> 04:01.440
这个参数表示的是

04:01.440 --> 04:02.440
内

04:02.440 --> 04:03.440
它是一个内

04:03.440 --> 04:04.440
现在呢

04:04.440 --> 04:05.440
它抱错

04:05.440 --> 04:06.440
有几个地方有错误

04:06.440 --> 04:07.440
首先地的错误

04:07.440 --> 04:08.440
这里

04:08.440 --> 04:09.440
它有影视的any类型

04:09.440 --> 04:10.440
你没有对它进行类型约数

04:10.440 --> 04:11.440
那不行

04:11.440 --> 04:13.440
你必须要对它进行约数

04:13.440 --> 04:15.440
约数为啥呢

04:15.440 --> 04:17.440
它的约数方式呢

04:17.440 --> 04:18.440
这里

04:18.440 --> 04:20.440
它必须要是一个内

04:20.440 --> 04:21.440
那么整

04:21.440 --> 04:23.440
这里是一个问题

04:23.440 --> 04:25.440
如何

04:25.440 --> 04:27.440
在ts中

04:27.440 --> 04:28.440
ts中

04:28.440 --> 04:31.440
如何约数一个变量

04:31.440 --> 04:34.440
或者是参数为内

04:34.440 --> 04:36.440
如何约数它为一个内

04:36.440 --> 04:38.440
有两种办法

04:38.440 --> 04:40.440
这里有两种办法

04:40.440 --> 04:41.440
第一种办法

04:41.440 --> 04:42.440
使用方式

04:42.440 --> 04:43.440
你想啊

04:43.440 --> 04:44.440
内

04:44.440 --> 04:47.440
内的本质是不是就是一个函数

04:47.440 --> 04:48.440
对不对

04:48.440 --> 04:50.440
内的本质它就是一个函数

04:50.440 --> 04:51.440
所以说

04:51.440 --> 04:52.440
函数的内型是啥

04:52.440 --> 04:53.440
函数内型是不是

04:53.440 --> 04:54.440
大写的F对吧

04:54.440 --> 04:55.440
方式

04:55.440 --> 04:56.440
所以说这里的约数呢

04:56.440 --> 04:57.440
我们可以使用

04:57.440 --> 04:58.440
方式

04:58.440 --> 04:59.440
方式

04:59.440 --> 05:00.440
用这种约数

05:00.440 --> 05:02.440
没问题

05:02.440 --> 05:03.440
好

05:03.440 --> 05:04.440
但是这种约数呢

05:04.440 --> 05:05.440
它的范围过于宽广

05:05.440 --> 05:06.440
太过于宽广了

05:06.440 --> 05:08.440
因为

05:08.440 --> 05:09.440
因为

05:09.440 --> 05:10.440
一个普通的方法

05:10.440 --> 05:11.440
一个普通的函数

05:11.440 --> 05:13.440
它也是一个方式

05:13.440 --> 05:14.440
也是一个方式

05:14.440 --> 05:15.440
所以说呢

05:15.440 --> 05:16.440
还有第二种约数方式

05:16.440 --> 05:17.440
在TS里面

05:17.440 --> 05:19.440
更加严格的约数方式

05:19.440 --> 05:21.440
是使用这种愚法

05:21.440 --> 05:23.440
这种愚法

05:23.440 --> 05:25.440
new

05:25.440 --> 05:27.440
参数

05:27.440 --> 05:29.440
然后返回的是一个

05:29.440 --> 05:31.440
不解的词

05:31.440 --> 05:33.440
通过这样的愚法

05:33.440 --> 05:34.440
来表示

05:34.440 --> 05:36.440
这是一个勾造函数

05:36.440 --> 05:37.440
它可以创建对象的

05:37.440 --> 05:39.440
一个这么一个内

05:39.440 --> 05:40.440
通过这个愚法

05:40.440 --> 05:41.440
来约数一个内

05:41.440 --> 05:42.440
这个愚法呢

05:42.440 --> 05:43.440
目前应该是没有建过的

05:43.440 --> 05:45.440
在TS里面还有这种愚法

05:45.440 --> 05:46.440
来表示

05:46.440 --> 05:47.440
这个参数呢

05:47.440 --> 05:48.440
它是一个内

05:48.440 --> 05:49.440
好

05:49.440 --> 05:50.440
我们可以这样子来约数

05:50.440 --> 05:52.440
new

05:52.440 --> 05:53.440
返回的是一个

05:53.440 --> 05:54.440
不解的词

05:54.440 --> 05:55.440
也就是说

05:55.440 --> 05:56.440
这个东西

05:56.440 --> 05:57.440
可以怎么样呢

05:57.440 --> 05:58.440
可以创建它的对象的

05:58.440 --> 06:00.440
是可以创建它的对象的

06:00.440 --> 06:01.440
比方说在代码里边

06:01.440 --> 06:02.440
我们可以通过

06:02.440 --> 06:03.440
new一个target

06:03.440 --> 06:04.440
你看

06:04.440 --> 06:05.440
new一个target

06:05.440 --> 06:07.440
就可以再创建一个对象

06:07.440 --> 06:09.440
它允许的这样的书写

06:09.440 --> 06:11.440
如果你约数为方形

06:12.440 --> 06:13.440
方形的

06:13.440 --> 06:15.440
它就不允许你这样子写了

06:15.440 --> 06:16.440
因为它不知道

06:16.440 --> 06:18.440
这是一个什么样的函数

06:18.440 --> 06:19.440
它是不是可以

06:19.440 --> 06:20.440
创建对象的函数

06:20.440 --> 06:21.440
它就不清楚了

06:21.440 --> 06:23.440
所以说你这里呢

06:23.440 --> 06:25.440
我建议大家使用这样的

06:25.440 --> 06:26.440
约数

06:26.440 --> 06:29.440
来表达这是一个内

06:29.440 --> 06:30.440
好

06:30.440 --> 06:31.440
我们这里这个函数

06:31.440 --> 06:32.440
做一件事

06:32.440 --> 06:33.440
非常非常简单

06:33.440 --> 06:34.440
做这么一件事就行了

06:34.440 --> 06:36.440
仔细把这个参数输出

06:36.440 --> 06:37.440
输出一下这个参数

06:37.440 --> 06:39.440
看它输出的结果是啥

06:40.440 --> 06:42.440
好 这里还有一个错误

06:42.440 --> 06:43.440
我们指着它看一下

06:43.440 --> 06:44.440
它说

06:44.440 --> 06:46.440
这TS给你提示的

06:46.440 --> 06:48.440
它说装饰器

06:48.440 --> 06:50.440
它目前呢

06:50.440 --> 06:52.440
还没有成为注意中的标准

06:52.440 --> 06:54.440
有可能在江南版本中

06:54.440 --> 06:56.440
有可能会变化

06:56.440 --> 06:57.440
它的使用方式

06:57.440 --> 06:58.440
它的功能

06:58.440 --> 07:00.440
有可能会变化

07:00.440 --> 07:01.440
它问你

07:01.440 --> 07:03.440
确定你现在要使用装饰器吗

07:03.440 --> 07:05.440
如果你确定的话

07:05.440 --> 07:07.440
它告诉你去设置这个东西

07:07.440 --> 07:08.440
叫做

07:08.440 --> 07:09.440
experimental表示

07:09.440 --> 07:11.440
试验性质的

07:11.440 --> 07:13.440
decorator装饰器

07:13.440 --> 07:15.440
开启试验性质的装饰器

07:15.440 --> 07:17.440
把这个选项开启就行了

07:17.440 --> 07:18.440
好 我们这里

07:18.440 --> 07:20.440
到配置文件里边去

07:20.440 --> 07:21.440
这里呢

07:21.440 --> 07:24.440
我们把它设置为处

07:24.440 --> 07:25.440
也就是说

07:25.440 --> 07:26.440
我们这里记一笔

07:26.440 --> 07:29.440
要在TS中使用装饰器

07:29.440 --> 07:32.440
在TS中

07:32.440 --> 07:35.440
要使用装饰器

07:35.440 --> 07:39.440
需要开启这个选项

07:39.440 --> 07:41.440
需要开启这个选项

07:41.440 --> 07:43.440
因为它怕你

07:43.440 --> 07:45.440
主要是为了提示你

07:45.440 --> 07:46.440
这个地方有可能将来

07:46.440 --> 07:48.440
标准可能会变化

07:48.440 --> 07:50.440
让你小心一点

07:50.440 --> 07:53.440
好 其实我们现在装饰器就写好了

07:53.440 --> 07:55.440
那么现在设计到另外一个问题

07:55.440 --> 07:59.440
这个函数是在什么时候运行的

07:59.440 --> 08:01.440
装饰器的函数

08:01.440 --> 08:02.440
装饰器本质就是一个函数

08:02.440 --> 08:03.440
它就是一个函数

08:03.440 --> 08:04.440
这个函数是一个内

08:04.440 --> 08:06.440
用这个东西来约束一个内

08:06.440 --> 08:07.440
因为它是构造函数

08:07.440 --> 08:08.440
对吧

08:08.440 --> 08:10.440
那么它是什么时候运行的

08:10.440 --> 08:12.440
这里我们记录一下

08:12.440 --> 08:16.440
装饰器的运行时间

08:16.440 --> 08:21.440
装饰器函数的运行时间

08:21.440 --> 08:23.440
运行时间点

08:23.440 --> 08:25.440
运行时间是什么呢

08:25.440 --> 08:31.440
运行时间是在内定义后

08:31.440 --> 08:36.440
在内定义后就会直接运行

08:36.440 --> 08:38.440
内定义后直接运行

08:38.440 --> 08:41.440
所以说这个函数

08:41.440 --> 08:42.440
它的运行时间点

08:42.440 --> 08:44.440
不是要等到它创建对象的时候才运行

08:44.440 --> 08:46.440
而是你定义这个内之后

08:46.440 --> 08:48.440
它马上就会运行这个函数

08:48.440 --> 08:49.440
马上就会运行

08:49.440 --> 08:51.440
好 咱们来看一下

08:51.440 --> 08:54.950
好 现在我们NPM装

08:54.950 --> 08:57.950
看一下有没有这个输出

08:57.950 --> 08:58.950
装饰器里面有没有输出

08:58.950 --> 09:00.950
你看 输出了结果

09:00.950 --> 09:01.950
结果是啥

09:02.950 --> 09:04.950
这个Target的指示啥

09:04.950 --> 09:05.950
是不是就把A传进来了

09:05.950 --> 09:07.950
它会自动的去

09:07.950 --> 09:09.950
它发现这里有装饰器

09:09.950 --> 09:11.950
定义完这个内之后

09:11.950 --> 09:14.950
它就会把这个装饰器的函数

09:14.950 --> 09:15.950
进行调用

09:15.950 --> 09:19.950
并且把这个内作为参数传进来

09:19.950 --> 09:20.950
接下来我们来看一下

09:20.950 --> 09:22.950
它的编译结果

09:22.950 --> 09:23.950
它的编译结果

09:23.950 --> 09:24.950
我们说装饰器

09:24.950 --> 09:26.950
它是会参与运行的

09:26.950 --> 09:27.950
它不是说

09:27.950 --> 09:28.950
是TS里面

09:28.950 --> 09:30.950
内情检查系统的面东西

09:30.950 --> 09:32.950
它本身就是TS里面的东西

09:32.950 --> 09:33.950
它是会参与运行的

09:33.950 --> 09:35.950
因此我们把它编译一下

09:35.950 --> 09:37.950
看一下编译结果里边

09:37.950 --> 09:39.950
它会变成什么样子

09:39.950 --> 09:41.950
看一下编译结果

09:41.950 --> 09:45.840
要看一下

09:45.840 --> 09:47.840
这个编译结果里边

09:47.840 --> 09:49.840
它生成了一段代码

09:49.840 --> 09:51.840
生成了一段代码

09:51.840 --> 09:53.840
这个代码

09:53.840 --> 09:56.840
我们不用过多的

09:56.840 --> 09:58.840
不用过多的去看代码

09:58.840 --> 10:00.840
它到底在做什么

10:00.840 --> 10:03.840
我这里就这样子来说吧

10:03.840 --> 10:05.840
我就这样子来说

10:05.840 --> 10:09.840
这个地方生成了一个函数

10:09.840 --> 10:11.840
它生成了一个函数

10:11.840 --> 10:13.840
这个函数里边

10:13.840 --> 10:14.840
你看这是函数

10:14.840 --> 10:17.840
它叫函数体

10:17.840 --> 10:18.840
这个函数里边

10:18.840 --> 10:20.840
它具体在做什么事

10:20.840 --> 10:21.840
我们先不去管它

10:21.840 --> 10:22.840
这个代码看着

10:22.840 --> 10:24.840
因为它是压缩过后的

10:24.840 --> 10:25.840
它仅仅过后的代码

10:25.840 --> 10:26.840
这是编译结果

10:26.840 --> 10:28.840
看上去不是那么容易阅读

10:28.840 --> 10:29.840
都没有关系

10:29.840 --> 10:30.840
我们来看一下

10:30.840 --> 10:32.840
只要认清楚它是一个函数

10:32.840 --> 10:34.840
然后这个函数

10:34.840 --> 10:36.840
它这里接收了四个函数

10:36.840 --> 10:37.840
我们只看前面两个

10:37.840 --> 10:40.840
第一个函数是一个装饰期的数组

10:40.840 --> 10:41.840
它是一个数组

10:41.840 --> 10:43.840
你要传一个数组进来

10:43.840 --> 10:45.840
然后装饰期本质上是啥

10:45.840 --> 10:46.840
是不是就是函数

10:46.840 --> 10:47.840
对不对

10:47.840 --> 10:49.840
你把装饰期的数组传给我

10:49.840 --> 10:50.840
然后这个topics

10:50.840 --> 10:52.840
表示你要装饰的目标

10:52.840 --> 10:54.840
我们现在是装饰的是内

10:54.840 --> 10:55.840
装饰的是内

10:55.840 --> 10:57.840
我们只看前两个参数就行了

10:57.840 --> 10:58.840
这是一个函数

10:58.840 --> 11:01.840
这个函数它接收这么两个参数

11:01.840 --> 11:03.840
好那么这就是我们刚才

11:03.840 --> 11:04.840
自己写的函数

11:04.840 --> 11:06.840
只是把内型检查

11:06.840 --> 11:08.840
内型约束给我去掉了

11:08.840 --> 11:09.840
好接下来看这

11:09.840 --> 11:11.840
你看是不是一个内

11:11.840 --> 11:14.840
它把它保存那个变量A里边

11:14.840 --> 11:15.840
一个内A

11:15.840 --> 11:17.840
然后这里你看

11:17.840 --> 11:19.840
从在调用这个函数

11:19.840 --> 11:22.840
调用这个函数的时候

11:22.840 --> 11:24.840
把这个装饰期

11:24.840 --> 11:27.840
这个函数是不是传进去了

11:27.840 --> 11:29.840
特色这个函数传进去了

11:29.840 --> 11:31.840
你看函数的调用时间

11:31.840 --> 11:33.840
函数的调用时间

11:33.840 --> 11:36.840
是不是在内定义之后直接调用的

11:36.840 --> 11:37.840
你看一下

11:37.840 --> 11:38.840
是不是这样的道理

11:38.840 --> 11:39.840
函数的调用时间

11:39.840 --> 11:42.840
就是在内之后直接调用这个函数

11:42.840 --> 11:44.840
把这个函数传进去

11:44.840 --> 11:46.840
那么在这个函数里边

11:46.840 --> 11:48.840
它会调用这个特色函数

11:48.840 --> 11:50.840
最后再传了一个A

11:50.840 --> 11:51.840
A是不是函数的参数

11:51.840 --> 11:52.840
对不对

11:52.840 --> 11:53.840
这个函数的参数

11:53.840 --> 11:55.840
就是我们装饰的目标

11:55.840 --> 11:56.840
它把这个A传进去

11:56.840 --> 11:58.840
然后最后在这里边

11:58.840 --> 11:59.840
在这里边

11:59.840 --> 12:01.840
它就会去运行

12:01.840 --> 12:03.840
我们传进去的函数

12:03.840 --> 12:05.840
就会运行传进去的函数

12:05.840 --> 12:07.840
并且把装饰的结果

12:07.840 --> 12:09.840
重新给F值

12:09.840 --> 12:10.840
我们以后再说这个

12:10.840 --> 12:12.840
重新复制的情况

12:12.840 --> 12:14.840
总之我们现在要讲的

12:14.840 --> 12:16.840
你至少要能认识到一点

12:16.840 --> 12:18.840
装饰期函数的运行时间

12:18.840 --> 12:21.840
是在内定义后直接运行

12:21.840 --> 12:23.840
直接运行了

12:23.840 --> 12:25.840
了解了这一点之后

12:25.840 --> 12:27.840
我们再来看另外一个问题

12:27.840 --> 12:29.840
就是装饰期

12:29.840 --> 12:31.840
本质上是一个函数

12:31.840 --> 12:33.840
那么这个内装饰期

12:33.840 --> 12:35.840
它函数的返回值

12:35.840 --> 12:37.840
可以是什么东西

12:37.840 --> 12:39.840
内装饰期

12:39.840 --> 12:41.840
装饰期

12:41.840 --> 12:44.840
可以具有的返回值

12:44.840 --> 12:46.840
第一种情况 void

12:46.840 --> 12:48.840
它可以返回一个 void

12:48.840 --> 12:49.840
就是不返回任何东西

12:49.840 --> 12:51.840
那么这种情况

12:51.840 --> 12:53.840
这种情况就没什么好说的了

12:53.840 --> 12:55.840
就是什么都不做

12:55.840 --> 12:57.840
就把函数运行连接完事了

12:57.840 --> 12:59.840
其他的事情什么都不做

12:59.840 --> 13:04.840
仅运行函数

13:04.840 --> 13:11.840
第二个情况是返回一个新的内

13:11.840 --> 13:12.840
那么这种情况

13:12.840 --> 13:22.840
会将新的内替换掉装饰目标

13:22.840 --> 13:24.840
它会进行这么一个处理

13:24.840 --> 13:26.840
它会将新的内替换掉装饰目标

13:26.840 --> 13:29.840
当然这种情况是比较的少见的

13:29.840 --> 13:31.840
但是我们要了解一下

13:31.840 --> 13:32.840
了解一下这种情况

13:32.840 --> 13:34.840
现在我们装饰期函数

13:34.840 --> 13:36.840
它没有返回任何东西

13:36.840 --> 13:38.840
那么只是简单的把函数运行一遍

13:38.840 --> 13:40.840
把这个扣到函数传给你

13:40.840 --> 13:41.840
你爱做啥做啥

13:41.840 --> 13:42.840
你这里想做啥做啥

13:42.840 --> 13:44.840
你可以往这个扣到函数里边

13:44.840 --> 13:46.840
什么圆形里边添一些东西

13:46.840 --> 13:49.840
可以做任何你想做的事情

13:50.840 --> 13:52.840
然后我们如果

13:52.840 --> 13:53.840
这个内里边

13:53.840 --> 13:54.840
这个函数里边

13:54.840 --> 13:59.840
如果返回了东西的话

13:59.840 --> 14:00.840
不要返回一个1

14:00.840 --> 14:01.840
行不行

14:01.840 --> 14:03.840
不允许你这样做的

14:03.840 --> 14:05.840
你不能返回一个数字

14:05.840 --> 14:08.840
它说不是一个合法的格式

14:08.840 --> 14:09.840
你返回个字无算

14:09.840 --> 14:10.840
行不行

14:10.840 --> 14:11.840
不不行

14:11.840 --> 14:12.840
你要返回

14:12.840 --> 14:13.840
要么不返回

14:13.840 --> 14:14.840
要返回的话

14:14.840 --> 14:16.840
只能返回一个内

14:16.840 --> 14:17.840
返回一个新的内

14:17.840 --> 14:19.840
内本字上就是扣到函数

14:19.840 --> 14:20.840
没有什么特别的

14:20.840 --> 14:22.840
我们就该返回一个内

14:22.840 --> 14:23.840
一个匿名内

14:23.840 --> 14:24.840
然后呢

14:24.840 --> 14:26.840
比方说返回内B

14:26.840 --> 14:28.840
该返回这个B

14:28.840 --> 14:29.840
好 咱们来试一下

14:29.840 --> 14:31.840
来试一下

14:31.840 --> 14:32.840
好 这里

14:32.840 --> 14:34.840
我们来创建一个A的对象

14:34.840 --> 14:36.840
创建一个A的对象

14:36.840 --> 14:38.840
我们这里写的是A

14:38.840 --> 14:40.840
那么我们在运行

14:40.840 --> 14:42.840
把输出啥呢

14:42.840 --> 14:44.840
输出这个A

14:44.840 --> 14:45.840
我们来看一下

14:45.840 --> 14:48.840
它到底是不是A的对象

14:48.840 --> 14:49.840
把我保存一下

14:49.840 --> 14:51.840
我们这里NPM状

14:51.840 --> 14:53.840
对 运行出来

14:53.840 --> 14:56.840
来看一下这个A是啥

14:56.840 --> 14:57.840
看到没

14:57.840 --> 14:59.840
它最终变成了什么

14:59.840 --> 15:01.840
变成了内B了

15:01.840 --> 15:02.840
变成了内B了

15:02.840 --> 15:04.840
所以说我们这里的装饰器

15:04.840 --> 15:06.840
可以做出很多丰富的效果

15:06.840 --> 15:08.840
我们觉得这个A

15:08.840 --> 15:09.840
功能不够强

15:09.840 --> 15:12.840
我们可以给它增强一些功能

15:12.840 --> 15:13.840
简单

15:13.840 --> 15:14.840
我们在这里写个B

15:14.840 --> 15:16.840
让它去继承

15:16.840 --> 15:18.840
继承什么Target

15:18.840 --> 15:20.840
Target是不是就是这个A

15:20.840 --> 15:22.840
就是传进来这个内

15:22.840 --> 15:24.840
就是传进来这个内

15:24.840 --> 15:25.840
因此我们去继承它

15:25.840 --> 15:27.840
然后给它增强一些功能

15:27.840 --> 15:29.840
然后返回来就是它的指内了

15:29.840 --> 15:30.840
返回来就是它的指内

15:30.840 --> 15:32.840
那明白这个意思了

15:32.840 --> 15:34.840
这是返回内的情况

15:34.840 --> 15:35.840
它是可以返回内的

15:35.840 --> 15:36.840
返回内过后

15:36.840 --> 15:38.840
之后你用的时候

15:38.840 --> 15:39.840
看上去好像是A

15:39.840 --> 15:42.840
但是实际上已经被T完成了B了

15:42.840 --> 15:44.840
已经被T完成这个类的

15:44.840 --> 15:46.840
我不是很建议大家

15:46.840 --> 15:49.840
在TS里面去使用这个功能

15:49.840 --> 15:51.840
因为如果你在TS里面

15:51.840 --> 15:53.840
去使用这个功能的话

15:53.840 --> 15:54.840
会导致一个结果就是

15:54.840 --> 15:56.840
得不到内循检查

15:56.840 --> 15:57.840
得不到内循检查

15:57.840 --> 15:59.840
比方说

15:59.840 --> 16:00.840
比方说

16:00.840 --> 16:03.840
这个A里边有一个属相

16:03.840 --> 16:04.840
有个属相

16:04.840 --> 16:05.840
随便写吧

16:05.840 --> 16:07.840
PLP1

16:07.840 --> 16:09.840
这不算有个属相

16:09.840 --> 16:11.840
那么这个时候你就已经发现了

16:11.840 --> 16:13.840
它这里爆错了

16:13.840 --> 16:14.840
它为什么爆错了

16:14.840 --> 16:16.840
它说

16:16.840 --> 16:17.840
它说怎么回事呢

16:17.840 --> 16:18.840
你这个装饰器

16:18.840 --> 16:20.840
它觉得在TS里面会爆错

16:20.840 --> 16:22.840
TS里面肯定不会这样检查的

16:22.840 --> 16:24.840
它说你这样子做

16:24.840 --> 16:25.840
会导致一个问题

16:25.840 --> 16:28.840
你这个内里面有这个属相

16:28.840 --> 16:29.840
但是你这个装饰器里面

16:29.840 --> 16:31.840
返回到内B里面

16:31.840 --> 16:33.840
它认为没有这个属相

16:33.840 --> 16:35.840
没有PLP

16:35.840 --> 16:37.840
没有这个属相

16:37.840 --> 16:39.840
所以说它认为你这样

16:40.840 --> 16:42.840
它可能会导致一个情况

16:42.840 --> 16:45.840
你这一返回了一个新的内

16:45.840 --> 16:46.840
那么新的内

16:46.840 --> 16:48.840
到时候我这里可以使用这个属相

16:48.840 --> 16:49.840
因为它内循检查

16:49.840 --> 16:51.840
它发现创建了一个A的对象

16:51.840 --> 16:52.840
它检查出来

16:52.840 --> 16:54.840
它可以有这个属相

16:54.840 --> 16:56.840
但是实际上我用的不是A的对象

16:56.840 --> 16:57.840
用的是B的对象

16:57.840 --> 16:58.840
而B的对象里面

16:58.840 --> 16:59.840
它认为没有这个属性的

16:59.840 --> 17:00.840
所以它就爆错了

17:00.840 --> 17:02.840
它认为这样做太危险了

17:02.840 --> 17:04.840
但实际上

17:04.840 --> 17:06.840
实际上B有没有这个属性的

17:06.840 --> 17:07.840
在这个场景下边

17:07.840 --> 17:08.840
它是有这个属性的

17:08.840 --> 17:10.840
因为它是继承了

17:10.840 --> 17:11.840
它继承了

17:11.840 --> 17:13.840
但是TS为什么不知道呢

17:13.840 --> 17:16.840
因为装饰器它是通用的

17:16.840 --> 17:18.840
装饰器是通用的

17:18.840 --> 17:19.840
它不知道这个装饰器

17:19.840 --> 17:21.840
凭什么这里就一定是A呢

17:21.840 --> 17:22.840
它有可能是这样的

17:22.840 --> 17:23.840
这种情况

17:23.840 --> 17:25.840
有一个内地

17:25.840 --> 17:27.840
它说也可以用这个装饰器

17:27.840 --> 17:29.840
也可以用这个装饰器

17:29.840 --> 17:30.840
所以也可以用

17:30.840 --> 17:33.840
因此在这个内地里面

17:33.840 --> 17:35.840
它这里就传了一个地进去

17:35.840 --> 17:37.840
定义了这个内过后

17:37.840 --> 17:38.840
它传了一个地进去

17:38.840 --> 17:40.840
把这个地的内替换成了内B

17:40.840 --> 17:43.840
这里A它就会把A传进去

17:43.840 --> 17:44.840
所以说这里是动态的

17:44.840 --> 17:46.840
是在运行的过程中动态决定的

17:46.840 --> 17:48.840
它这个东西到底是

17:48.840 --> 17:49.840
到底是啥

17:49.840 --> 17:51.840
我其实是不知道的

17:51.840 --> 17:52.840
因此它不能确定

17:52.840 --> 17:54.840
B里面一定有这个属性

17:54.840 --> 17:56.840
因此它就会出现一些隐患

17:56.840 --> 17:58.840
因此我不建议大家

17:58.840 --> 17:59.840
使用这种方式

17:59.840 --> 18:00.840
聊一下就行了

18:00.840 --> 18:01.840
直到有这么一种事情

18:01.840 --> 18:02.840
可以做

18:02.840 --> 18:03.840
可以做就行了

18:03.840 --> 18:06.840
装饰器是可以用到各个地方的

18:06.840 --> 18:07.840
好了

18:07.840 --> 18:09.840
那么现在我们能够理解的

18:09.840 --> 18:11.840
就是说装饰器

18:11.840 --> 18:14.840
它本质上就是一个函数

18:14.840 --> 18:16.840
它能够接受一个参数

18:16.840 --> 18:18.840
这个参数就是内的

18:18.840 --> 18:19.840
就是内本身

18:19.840 --> 18:22.840
我们这里该约束了一下内本身

18:22.840 --> 18:24.840
然后我们在装饰器里边

18:24.840 --> 18:26.840
可以进行对这个内

18:26.840 --> 18:27.840
进行各种各样的操作

18:27.840 --> 18:29.840
各种各样的处理

18:29.840 --> 18:31.840
这里我们再关注一下这个点

18:31.840 --> 18:34.840
就是关于构造函数的约束

18:34.840 --> 18:35.840
这个其实约束的是啥

18:35.840 --> 18:37.840
约束的就是一个构造函数

18:37.840 --> 18:38.840
它必须是一个构造函数

18:38.840 --> 18:39.840
也就是换句话说

18:39.840 --> 18:42.840
它就必须是一个内

18:42.840 --> 18:44.840
我们再使用6这个关键字

18:44.840 --> 18:45.840
对它进行约束的时候

18:45.840 --> 18:46.840
你看这个小货号

18:46.840 --> 18:49.840
其实就表示构造函数的参数

18:49.840 --> 18:52.840
我现在的约束只是告诉它说

18:52.840 --> 18:55.840
我约束的这个构造函数

18:55.840 --> 18:57.840
它必须是一个无参的构造函数

18:57.840 --> 18:58.840
你看了没

18:58.840 --> 19:00.840
它必须是一个无参的构造函数

19:00.840 --> 19:03.840
那如果这个内它是有参数的呢

19:03.840 --> 19:05.840
它是有参数的怎么办呢

19:05.840 --> 19:11.840
比方说publicplp2

19:11.840 --> 19:13.840
它有一个参数

19:13.840 --> 19:14.840
你看这里是不是爆错了

19:14.840 --> 19:16.840
它不满足约束了

19:16.840 --> 19:18.840
它倒是想把这个A传过去

19:18.840 --> 19:21.840
但是由于约束不匹配

19:21.840 --> 19:23.840
它这里说的是没有参数

19:23.840 --> 19:25.840
结果你给了我一个参数

19:25.840 --> 19:26.840
你给了我一个参数

19:26.840 --> 19:28.840
而且这个参数是支付串

19:28.840 --> 19:31.840
那么这个时候怎么处理呢

19:31.840 --> 19:33.840
这里交给大家一个小技巧

19:33.840 --> 19:36.840
这个小技巧倒不是装饰器这一块的知识

19:36.840 --> 19:38.840
是因为我们之前没有讲这一块东西

19:38.840 --> 19:40.840
把补充上

19:40.840 --> 19:42.840
在约束构造函数的时候

19:42.840 --> 19:45.840
如果你要更加的通用

19:45.840 --> 19:47.840
就说我这个约束

19:47.840 --> 19:49.840
要能够适应各种构造函数

19:49.840 --> 19:50.840
一个参数我要能满足

19:50.840 --> 19:52.840
两个参数也要能满足

19:52.840 --> 19:53.840
三个参数

19:53.840 --> 19:54.840
四个参数没有参数

19:54.840 --> 19:55.840
都要能满足

19:55.840 --> 19:56.840
那怎么来约束

19:56.840 --> 19:58.840
只要你是一个内就行了

19:58.840 --> 19:59.840
我管理几个参数

19:59.840 --> 20:00.840
怎么约束呢

20:00.840 --> 20:01.840
很简单

20:01.840 --> 20:03.840
就在参数这个位置

20:03.840 --> 20:05.840
参数这个位置

20:05.840 --> 20:07.840
写上这么一个东西

20:07.840 --> 20:08.840
生于参数

20:08.840 --> 20:09.840
什么要生于参数

20:09.840 --> 20:11.840
就随便你几个都行

20:11.840 --> 20:14.840
显然是生于参数

20:14.840 --> 20:16.840
约束一下参数的内容

20:16.840 --> 20:18.840
生于参数我们知道

20:18.840 --> 20:20.840
生于参数在介石里面是个啥

20:20.840 --> 20:21.840
是个数组对吧

20:21.840 --> 20:22.840
是个数组

20:22.840 --> 20:24.840
那么这里我约束一下

20:24.840 --> 20:26.840
它是个N内型的数组

20:26.840 --> 20:27.840
那么现在就可以了

20:27.840 --> 20:29.840
你一个参数没问题

20:29.840 --> 20:32.840
没有参数没问题

20:32.840 --> 20:34.840
两个参数没问题

20:34.840 --> 20:35.840
是不是都能匹配

20:35.840 --> 20:37.840
是不是都能匹配这样的

20:37.840 --> 20:38.840
这样的结构

20:38.840 --> 20:40.840
这个技巧大家要学会

20:40.840 --> 20:41.840
在TS里面

20:41.840 --> 20:43.840
如何约束一个构造函数

20:43.840 --> 20:44.840
使用这种方式

20:44.840 --> 20:45.840
参数呢

20:45.840 --> 20:47.840
如果你要更加通用的话

20:47.840 --> 20:48.840
参数的随意

20:48.840 --> 20:49.840
如果你要限制参数的话

20:49.840 --> 20:50.840
再参数这里写

20:50.840 --> 20:51.840
表示构造函数

20:51.840 --> 20:53.840
必须要有几个参数

20:54.840 --> 20:56.840
这是关于这一块

20:56.840 --> 20:58.840
我们这节课

20:58.840 --> 21:00.840
只讲语法

21:00.840 --> 21:01.840
你可能不太清楚

21:01.840 --> 21:03.840
这个东西到底有什么实际的含义

21:03.840 --> 21:04.840
但是没关系

21:04.840 --> 21:05.840
我们先把语法搞清楚

21:05.840 --> 21:06.840
它本质上就是个函数

21:06.840 --> 21:07.840
接受一个内

21:07.840 --> 21:09.840
什么时候运行这个函数

21:09.840 --> 21:11.840
调用这个函数的事

21:11.840 --> 21:13.840
就运行这个函数

21:13.840 --> 21:15.840
那么比方说

21:15.840 --> 21:17.840
有的时候

21:17.840 --> 21:19.840
我们需要加入一些

21:19.840 --> 21:21.840
额外的信息

21:22.840 --> 21:24.840
给这个装饰器加入一些

21:24.840 --> 21:25.840
额外的信息

21:25.840 --> 21:27.840
我们装饰器不是上一课说过吗

21:27.840 --> 21:28.840
它就是来描述一些

21:28.840 --> 21:30.840
额外的信息的

21:30.840 --> 21:32.840
现在我能不能加额外信息

21:32.840 --> 21:33.840
你能不能像这样的

21:33.840 --> 21:35.840
加额外信息

21:35.840 --> 21:37.840
就是

21:37.840 --> 21:39.840
比方说

21:39.840 --> 21:41.840
这是一个内

21:41.840 --> 21:43.840
随便该加一些信息吧

21:43.840 --> 21:45.840
能不能加额外信息呢

21:45.840 --> 21:47.840
加不了

21:47.840 --> 21:48.840
为什么加不了

21:48.840 --> 21:49.840
来分析一下

21:49.840 --> 21:50.840
为什么加不了

21:50.840 --> 21:52.840
这里在做什么

21:52.840 --> 21:54.840
这里是不是函数调用

21:54.840 --> 21:56.840
把这个函数调用

21:56.840 --> 21:59.840
返回的结果

21:59.840 --> 22:01.840
作为它的装饰器

22:01.840 --> 22:03.840
那你想一想

22:03.840 --> 22:05.840
首先这里有好多问题

22:05.840 --> 22:06.840
第一个问题

22:06.840 --> 22:08.840
这个内形是不匹配

22:08.840 --> 22:09.840
对不对

22:09.840 --> 22:10.840
它本来要求一个

22:10.840 --> 22:11.840
这个函数的

22:11.840 --> 22:12.840
第一个函数是要求

22:12.840 --> 22:13.840
要求的是啥

22:13.840 --> 22:14.840
要求的是一个内

22:14.840 --> 22:16.840
结果你给我一个制服串

22:16.840 --> 22:17.840
内形不匹配

22:17.840 --> 22:19.840
再说了

22:19.840 --> 22:21.840
这个函数的返回结果

22:21.840 --> 22:22.840
是啥

22:22.840 --> 22:24.840
调用这个函数返回的结果

22:24.840 --> 22:25.840
是啥

22:25.840 --> 22:27.840
是不是一个 void

22:27.840 --> 22:28.840
也就是

22:28.840 --> 22:29.840
undefend

22:29.840 --> 22:31.840
它没有任何返回结果

22:31.840 --> 22:32.840
那没有任何

22:32.840 --> 22:34.840
undefend能不能作为装饰器

22:34.840 --> 22:36.840
不能作为装饰器

22:36.840 --> 22:37.840
因此你这里

22:37.840 --> 22:38.840
是不能这样写的

22:38.840 --> 22:39.840
你这样写可以

22:39.840 --> 22:41.840
因为它本身就是个函数

22:41.840 --> 22:42.840
它满足装饰器的要求

22:42.840 --> 22:43.840
装饰器要求

22:43.840 --> 22:44.840
它是一个函数

22:44.840 --> 22:46.840
并且它只能有一个参数

22:46.840 --> 22:49.840
是一个内

22:49.840 --> 22:51.840
一个参数接受一个内

22:51.840 --> 22:52.840
满足要求

22:52.840 --> 22:54.840
但是你一旦使用了函数调用

22:54.840 --> 22:56.840
那么就必须要要求

22:56.840 --> 22:58.840
这个函数的返回结果

22:58.840 --> 23:00.840
要满足这个要求

23:00.840 --> 23:01.840
明白这个意思吗

23:01.840 --> 23:03.840
这就是在调用函数

23:03.840 --> 23:05.840
表示这个函数的返回结果

23:05.840 --> 23:07.840
要满足这种格式的要求

23:07.840 --> 23:08.840
那如果我要写成

23:08.840 --> 23:10.840
这种格式该怎么做呢

23:10.840 --> 23:12.840
我们可以这样来处理

23:12.840 --> 23:16.850
大家看着

23:17.850 --> 23:18.850
你不是就需要

23:18.850 --> 23:19.850
给我传个字幕串吗

23:19.850 --> 23:20.850
我给你个字幕串

23:20.850 --> 23:24.850
这个函数我返回一个方式

23:26.850 --> 23:27.850
你看一下

23:27.850 --> 23:29.850
这么满足的要求了

23:29.850 --> 23:30.850
这么满足的要求了

23:30.850 --> 23:31.850
我们来想一想这个逻辑

23:31.850 --> 23:33.850
应该好理解吧

23:33.850 --> 23:34.850
总之装饰器这个位置

23:34.850 --> 23:36.850
它必须要要求是一个函数

23:36.850 --> 23:38.850
并且它要对函数格式

23:38.850 --> 23:39.850
也有要求

23:39.850 --> 23:40.850
这是内装饰器

23:40.850 --> 23:42.850
内装饰器要求函数的格式

23:42.850 --> 23:44.850
必须要有一个参数

23:44.850 --> 23:45.850
我管理这个函数怎么来的

23:46.850 --> 23:48.850
这里可以通过一个

23:48.850 --> 23:50.850
调用函数的表达式

23:50.850 --> 23:52.850
这个函数的返回结果

23:52.850 --> 23:54.850
你看是满足要求的

23:54.850 --> 23:56.850
这函数的返回结果满足要求的

23:56.850 --> 23:57.850
这也没问题

23:57.850 --> 24:00.850
总之你这里要给它这么一个

24:00.850 --> 24:02.850
就是满足要求的函数就行了

24:02.850 --> 24:04.850
管理是怎么给的

24:04.850 --> 24:06.850
你可以直接给一个函数

24:06.850 --> 24:08.850
也可以给一个函数调用

24:08.850 --> 24:09.850
把函数调用的返回结果

24:09.850 --> 24:11.850
那么满足要求就行

24:11.850 --> 24:13.850
也一样

24:13.850 --> 24:14.850
明白这个意思吗

24:14.850 --> 24:15.850
好那么这个函数里面

24:15.850 --> 24:16.850
是不是就可以

24:16.850 --> 24:17.850
既可以得到这个字幕串

24:17.850 --> 24:18.850
又可以得到这个内了

24:18.850 --> 24:20.850
我们就可以做一些

24:20.850 --> 24:21.850
丰富的处理的

24:22.850 --> 24:24.850
我们先认识语法

24:26.850 --> 24:29.850
然后再说一个问题

24:29.850 --> 24:32.850
就是多装饰器的情况

24:33.850 --> 24:36.850
多个装饰器的情况

24:37.850 --> 24:38.850
那么这种情况

24:38.850 --> 24:40.850
那就是多个函数

24:40.850 --> 24:41.850
就多个函数

24:41.850 --> 24:43.850
这多个函数怎么来调用

24:43.850 --> 24:45.850
它的调用顺序是什么

24:46.850 --> 24:48.850
好这里呢比方说

24:48.850 --> 24:50.850
我这里写这么

24:51.850 --> 24:53.850
两个

24:53.850 --> 24:55.850
两个装饰器

24:55.850 --> 24:56.850
Test

24:56.850 --> 24:57.850
或者是第1

24:57.850 --> 24:59.850
装饰器第1装饰器

24:59.850 --> 25:01.850
当然了约数一下

25:01.850 --> 25:03.850
约数一下

25:03.850 --> 25:04.850
Target

25:04.850 --> 25:05.850
为什么呢

25:07.850 --> 25:09.850
如果写到麻烦的话

25:09.850 --> 25:11.850
你可以订一个啥呢

25:11.850 --> 25:14.850
你可以订一个类型别名

25:14.850 --> 25:16.850
对吧类型别名

25:18.850 --> 25:19.850
Cons

25:19.850 --> 25:21.850
抓个Target

25:21.850 --> 25:22.850
订一个类型别名

25:22.850 --> 25:24.850
只要你是各招函数就行

25:24.850 --> 25:25.850
我们这里

25:28.680 --> 25:29.680
订一个类型别名

25:29.680 --> 25:31.680
那么这里就使用类型别名了

25:31.680 --> 25:32.680
类型别名的好处

25:32.680 --> 25:34.680
就可以减上我们类型别数的代码书写

25:34.680 --> 25:36.680
好那么这里呢

25:37.680 --> 25:38.680
第1

25:38.680 --> 25:39.680
OK

25:39.680 --> 25:40.680
好这里

25:40.680 --> 25:41.680
ConsLog

25:41.680 --> 25:42.680
输出第1

25:42.680 --> 25:44.680
然后我们再写的装饰器

25:44.680 --> 25:45.680
刚刚写第2

25:45.680 --> 25:46.680
Target

25:46.680 --> 25:47.680
Cons

25:47.680 --> 25:48.680
抓个Target

25:49.680 --> 25:51.680
然后ConsLog

25:51.680 --> 25:52.680
第2

25:53.680 --> 25:54.680
好这里

25:55.680 --> 25:56.680
第2

25:56.680 --> 25:58.680
我们现在要研究的是啥

25:58.680 --> 25:59.680
拿个先输出

25:59.680 --> 26:00.680
打个后输出的问题

26:01.680 --> 26:02.680
保存

26:02.680 --> 26:03.680
看一下

26:04.680 --> 26:06.680
它输出的顺序是第2第1

26:07.680 --> 26:09.680
如果我这里装饰器的使用上

26:09.680 --> 26:10.680
换一下

26:11.680 --> 26:12.680
换一下保存

26:13.680 --> 26:15.680
它输出的是第1第2

26:16.680 --> 26:17.680
那么明白这个意思吗

26:17.680 --> 26:19.680
装饰器的运行

26:19.680 --> 26:21.680
这个函数的运行顺序是什么顺序

26:22.680 --> 26:25.680
是从下到上以此运行

26:25.680 --> 26:28.680
从下到上以此运行

26:28.680 --> 26:30.680
它这么一个运行顺序

26:31.680 --> 26:32.680
这是关于这个点

26:32.680 --> 26:33.680
在装饰器

26:33.680 --> 26:36.680
它的运行顺序取决于这个装饰器

26:36.680 --> 26:38.680
怎么去使用它的

26:39.680 --> 26:41.680
然后

26:42.680 --> 26:44.680
我们再看另外一个场景

26:44.680 --> 26:45.680
就是我们之前解释过了

26:45.680 --> 26:46.680
这个东西是

26:46.680 --> 26:48.680
我们可以这样来调用

26:48.680 --> 26:49.680
这样来调用

26:49.680 --> 26:51.680
把当前一个函数来调用

26:51.680 --> 26:53.680
当时函数调用的时候

26:53.680 --> 26:54.680
也就是说

26:54.680 --> 26:56.680
这个第1它返回的结果

26:57.680 --> 26:58.680
必须是一个装饰器

26:58.680 --> 26:59.680
你看调用函数

26:59.680 --> 27:01.680
得到调用函数的返回结果

27:01.680 --> 27:03.680
那么第1的返回结果必须是一个装饰器

27:04.680 --> 27:05.680
我们来这样子写

27:05.680 --> 27:07.680
返回这么一个函数

27:07.680 --> 27:12.360
好 这里

27:13.360 --> 27:17.140
好 我们现在这样子写

27:17.140 --> 27:19.140
这是一道面试题

27:19.140 --> 27:20.140
我就是会讲这个

27:21.140 --> 27:22.140
这是一道面试题

27:22.140 --> 27:24.140
也要搞清楚它们的运行顺序

27:25.140 --> 27:26.140
这里

27:26.140 --> 27:27.140
我们第2

27:27.140 --> 27:32.370
这里写错了

27:32.370 --> 27:33.370
没有函数

27:34.370 --> 27:35.370
第2

27:35.370 --> 27:36.370
第1

27:36.370 --> 27:40.580
Decl

27:40.580 --> 27:41.580
Rator

27:42.580 --> 27:44.580
这是第2

27:44.580 --> 27:45.580
Decl

27:45.580 --> 27:46.580
是第2

27:46.580 --> 27:47.580
Decl

27:48.580 --> 27:49.580
好

27:50.580 --> 27:52.580
现在的输出顺序是什么呢

27:54.580 --> 27:55.580
现在的输出顺序

27:56.580 --> 27:57.580
咱们来看一下结果

27:59.580 --> 28:01.580
我写 这里写错了

28:01.580 --> 28:02.580
这里写错了

28:02.580 --> 28:03.580
这里是第2 Decl

28:03.580 --> 28:04.580
保存一下

28:04.580 --> 28:05.580
再看结果

28:06.580 --> 28:07.580
通过这个结果

28:07.580 --> 28:08.580
你应该能想到

28:08.580 --> 28:10.580
它的运行顺序是什么

28:11.580 --> 28:12.580
先输出第1 第2

28:12.580 --> 28:14.580
然后再输出第2 Decl

28:14.580 --> 28:15.580
再输出第1 Decl

28:16.580 --> 28:17.580
怎么回事呢

28:17.580 --> 28:18.580
其实很简单

28:18.580 --> 28:19.580
很简单

28:20.580 --> 28:21.580
首先它这里

28:21.580 --> 28:22.580
运行的两个函数

28:23.580 --> 28:24.580
运行的两个函数

28:25.580 --> 28:26.580
哪两个函数

28:26.580 --> 28:27.580
第1这个函数

28:27.580 --> 28:28.580
运行的时候

28:28.580 --> 28:29.580
是不是得到它

28:29.580 --> 28:30.580
输出第1

28:30.580 --> 28:31.580
再运行第2

28:31.580 --> 28:32.580
得到它

28:33.580 --> 28:34.580
好 运行的第1 第2之后

28:34.580 --> 28:36.580
是不是得到了两个装饰器

28:36.580 --> 28:37.580
你看 第1个装饰器

28:37.580 --> 28:38.580
第2个装饰器

28:38.580 --> 28:40.580
运行第1函数

28:40.580 --> 28:41.580
得到

