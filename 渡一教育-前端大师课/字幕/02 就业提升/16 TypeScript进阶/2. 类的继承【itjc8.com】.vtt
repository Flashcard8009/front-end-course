WEBVTT

00:00.940 --> 00:04.940
好 我们这些课来讲内的继承

00:04.940 --> 00:08.940
其实内的继承大家以前也用到过

00:08.940 --> 00:11.940
reaction里边我们的组件不是个内吗

00:11.940 --> 00:13.940
对不对 它去继承谁呢

00:13.940 --> 00:16.940
继承reaction component 对吧

00:16.940 --> 00:19.940
它继承reaction里面提供了另外一个内

00:19.940 --> 00:22.940
就内之间是可以有继承的关系的

00:22.940 --> 00:24.940
那么这里我们首先说一下

00:24.940 --> 00:27.940
就是为什么会形成内的继承

00:27.940 --> 00:29.940
继承的作用到底是什么

00:29.940 --> 00:32.940
继承的作用

00:32.940 --> 00:34.940
继承的作用

00:34.940 --> 00:35.940
什么作用呢

00:35.940 --> 00:41.940
就继承可以描述内与内之间的关系

00:41.940 --> 00:45.940
内与内之间的关系

00:45.940 --> 00:48.940
就是有的时候我们系统中有很多的内相

00:48.940 --> 00:49.940
其实一个内是啥

00:49.940 --> 00:51.940
一个内就是一个内相

00:51.940 --> 00:54.940
就是我们自己该定义的一个内相

00:54.940 --> 00:57.940
这些内相之间它是有关系的

00:57.940 --> 00:59.940
就比方说咱们的游戏里边

00:59.940 --> 01:02.940
这个坦克大战里边

01:02.940 --> 01:06.940
比方说坦克和敌方坦克

01:06.940 --> 01:08.940
几方坦克

01:08.940 --> 01:10.940
他们这几个概念之间

01:10.940 --> 01:11.940
几个内相之间

01:11.940 --> 01:13.940
他们实际上是有关系的

01:13.940 --> 01:14.940
是有关联的

01:14.940 --> 01:22.940
比方说坦克和几方坦克

01:23.940 --> 01:24.940
玩家坦克

01:24.940 --> 01:25.940
玩家坦克

01:25.940 --> 01:27.940
以及敌方坦克

01:27.940 --> 01:29.940
这里我们比方说

01:29.940 --> 01:30.940
这里有三个内

01:30.940 --> 01:31.940
对不对

01:31.940 --> 01:32.940
有三个内

01:32.940 --> 01:34.940
那么这三个内之间有没有关系

01:34.940 --> 01:36.940
肯定是有关系的

01:36.940 --> 01:38.940
这种关系在我们现实世界里边

01:38.940 --> 01:41.940
可以用这种发生来描述

01:41.940 --> 01:43.940
就是说玩家坦克

01:43.940 --> 01:45.940
是坦克

01:45.940 --> 01:47.940
对不对

01:47.940 --> 01:49.940
敌方坦克

01:49.940 --> 01:51.940
是坦克

01:52.940 --> 01:54.940
你看是不是可以这样的描述

01:54.940 --> 01:56.940
玩家坦克是一个内

01:56.940 --> 01:58.940
坦克也是一个内

01:58.940 --> 01:59.940
但是玩家坦克呢

01:59.940 --> 02:00.940
它是坦克

02:00.940 --> 02:01.940
敌方坦克呢

02:01.940 --> 02:02.940
是坦克

02:02.940 --> 02:04.940
在现实世界里边

02:04.940 --> 02:06.940
凡是可以这样子来描述的话

02:06.940 --> 02:07.940
有某个东西

02:07.940 --> 02:09.940
是某一个东西

02:09.940 --> 02:10.940
两个东西都是名词

02:10.940 --> 02:11.940
一个名词

02:11.940 --> 02:13.940
是另外一个名词

02:13.940 --> 02:15.940
而且这两个又是内

02:15.940 --> 02:16.940
那么他们之间

02:16.940 --> 02:18.940
就可以形成继承关系

02:18.940 --> 02:20.940
就在语意上的话

02:20.940 --> 02:22.940
这个含义就是这样的含义

02:22.940 --> 02:24.940
我们把总结一下

02:24.940 --> 02:28.940
如果A和B是内

02:28.940 --> 02:29.940
都是内

02:29.940 --> 02:30.940
他们都是一个内想

02:30.940 --> 02:31.940
自己定义的一个内

02:31.940 --> 02:33.940
class

02:33.940 --> 02:34.940
并且呢

02:34.940 --> 02:37.940
并且可以描述为

02:37.940 --> 02:39.940
A4B

02:39.940 --> 02:41.940
A4B

02:41.940 --> 02:43.940
则

02:43.940 --> 02:45.940
A和B

02:45.940 --> 02:48.940
A和B形成继承关系

02:48.940 --> 02:49.940
怎么继承呢

02:49.940 --> 02:51.940
继承的关系具体来说

02:51.940 --> 02:53.940
下面可以有下面的

02:53.940 --> 02:54.940
各种各样的描述

02:54.940 --> 02:56.940
之后咱们再讲

02:56.940 --> 02:57.940
具体的代码的时候

02:57.940 --> 02:58.940
我用下面的

02:58.940 --> 02:59.940
任何一种描述

02:59.940 --> 03:00.940
大家要知道是什么意思

03:00.940 --> 03:02.940
如果A和B都是内

03:02.940 --> 03:03.940
他们是两个内

03:03.940 --> 03:05.940
并且可以描述为

03:05.940 --> 03:07.940
A4B

03:07.940 --> 03:08.940
玩家坦克

03:08.940 --> 03:09.940
是坦克

03:09.940 --> 03:11.940
那么A和B形成继承关系

03:11.940 --> 03:13.940
就有下面这种集中说法

03:13.940 --> 03:15.940
B是负内

03:15.940 --> 03:16.940
A4

03:16.940 --> 03:18.940
子内

03:18.940 --> 03:20.940
坦克是负内

03:20.940 --> 03:22.940
玩家坦克是质内

03:22.940 --> 03:24.940
还有下面那种说法

03:24.940 --> 03:25.940
有很多

03:25.940 --> 03:27.940
他们当然都是相对于说的

03:27.940 --> 03:30.940
A和B之间来进行描述的

03:30.940 --> 03:34.940
B派生A

03:34.940 --> 03:36.940
B派生A

03:36.940 --> 03:38.940
然后呢

03:38.940 --> 03:42.940
A继承自B

03:42.940 --> 03:44.940
A继承自B

03:44.940 --> 03:45.940
这也是一种说法

03:45.940 --> 03:46.940
负内子内

03:46.940 --> 03:48.940
就是父亲和儿子的关系

03:48.940 --> 03:50.940
就是B生了

03:50.940 --> 03:53.940
A可以去继承B

03:53.940 --> 03:54.940
就是这么个意思

03:54.940 --> 03:56.940
非常的自然

03:56.940 --> 03:57.940
然后还有什么说法呢

03:57.940 --> 03:59.940
还有下面那种说法

03:59.940 --> 04:02.940
就是说

04:02.940 --> 04:05.940
B是A的

04:05.940 --> 04:08.940
机内

04:08.940 --> 04:09.940
就是它基础内

04:09.940 --> 04:11.940
它里边有的东西呢

04:11.940 --> 04:12.940
B里面有的东西

04:12.940 --> 04:14.940
A里面也有

04:15.940 --> 04:16.940
然后反过来呢

04:16.940 --> 04:17.940
就是

04:17.940 --> 04:22.940
A是B的派生内

04:22.940 --> 04:24.940
这三种说法表达的

04:24.940 --> 04:27.940
都是同一个含义

04:27.940 --> 04:28.940
你将来呢

04:28.940 --> 04:29.940
可能在不同的书记上

04:29.940 --> 04:32.940
或者是不同的环境下面

04:32.940 --> 04:33.940
会听到不同的说法

04:33.940 --> 04:35.940
那么都是指的一个含义

04:35.940 --> 04:36.940
都描述的是

04:36.940 --> 04:38.940
他们之间是继承关系

04:38.940 --> 04:39.940
其实继承关系呢

04:39.940 --> 04:41.940
是非常非常自然的

04:41.940 --> 04:42.940
非常非常自然的

04:42.940 --> 04:44.940
比方说男人和人

04:44.940 --> 04:46.940
是不是继承关系

04:46.940 --> 04:47.940
也要判断两个东西

04:47.940 --> 04:48.940
是不是继承关系

04:48.940 --> 04:50.940
就看能不能这样的描述

04:50.940 --> 04:51.940
能不能这样的描述

04:51.940 --> 04:53.940
男人是不是人

04:53.940 --> 04:54.940
那肯定是人嘛

04:54.940 --> 04:55.940
对吧 肯定是人

04:55.940 --> 04:57.940
那他们之间就有继承关系

04:57.940 --> 04:59.940
男人继承制

04:59.940 --> 05:00.940
人

05:00.940 --> 05:02.940
男人继承制人

05:02.940 --> 05:04.940
人派生男人

05:04.940 --> 05:05.940
人是腹内

05:05.940 --> 05:06.940
男人是脂内

05:06.940 --> 05:08.940
然后呢

05:08.940 --> 05:11.940
人是男人的机内

05:11.940 --> 05:14.940
男人是人的派生男

05:14.940 --> 05:16.940
就可以这样的描述

05:16.940 --> 05:18.940
这是继承关系

05:18.940 --> 05:20.940
它的语异上的含义

05:20.940 --> 05:21.940
它描述的是什么呢

05:21.940 --> 05:24.940
描述的是内与内之间的关系

05:24.940 --> 05:25.940
内情之间

05:25.940 --> 05:27.940
是有可能会产生关系的

05:27.940 --> 05:30.940
这是关于继承的含义

05:30.940 --> 05:33.940
好 那么知道继承含义之后呢

05:33.940 --> 05:34.940
继承有什么意义呢

05:34.940 --> 05:35.940
在我们的开发过程中

05:35.940 --> 05:37.940
继承有什么意义呢

05:37.940 --> 05:40.940
如果

05:41.940 --> 05:42.940
A

05:42.940 --> 05:44.940
继承字

05:44.940 --> 05:45.940
B

05:45.940 --> 05:46.940
如果A继承了B

05:46.940 --> 05:47.940
B是腹内

05:47.940 --> 05:48.940
A是脂内

05:48.940 --> 05:49.940
则

05:49.940 --> 05:52.940
A中自动拥有

05:52.940 --> 05:55.940
B中的所有成员

05:55.940 --> 05:57.940
这就是继承的好处

05:57.940 --> 05:59.940
它其实在很多时候呢

05:59.940 --> 06:00.940
在我们代码层面的话

06:00.940 --> 06:02.940
可以减少很多的重复代码

06:02.940 --> 06:03.940
比方说

06:03.940 --> 06:05.940
像刚才这个例子里边

06:05.940 --> 06:07.940
像这个例子

06:07.940 --> 06:09.940
像这个例子里边

06:09.940 --> 06:11.940
几方坦克和几方坦克

06:11.940 --> 06:12.940
他们都是坦克

06:12.940 --> 06:13.940
他们有没有共同的行为

06:13.940 --> 06:14.940
共同的属性

06:14.940 --> 06:15.940
这都有啊

06:15.940 --> 06:17.940
他们都有坐标对吧

06:17.940 --> 06:19.940
都有移动速度

06:19.940 --> 06:20.940
还有都有啥呢

06:20.940 --> 06:22.940
还都可以发射子弹

06:22.940 --> 06:23.940
对不对

06:23.940 --> 06:24.940
还都可以发射子弹

06:24.940 --> 06:25.940
有没有不同点呢

06:25.940 --> 06:26.940
当然有不同点

06:26.940 --> 06:27.940
比方说

06:27.940 --> 06:29.940
几方坦克呢

06:29.940 --> 06:30.940
几方坦克

06:30.940 --> 06:31.940
他可以

06:31.940 --> 06:33.940
人可以控制他移动

06:33.940 --> 06:34.940
而几方坦克呢

06:34.940 --> 06:35.940
是自动移动的对不对

06:35.940 --> 06:36.940
他也有不同点

06:36.940 --> 06:37.940
因此呢

06:37.940 --> 06:38.940
他们有共同的行为

06:38.940 --> 06:40.940
共同的一些属性的话

06:40.940 --> 06:41.940
我们就可以

06:41.940 --> 06:43.940
把他们抽象成一个附类

06:43.940 --> 06:44.940
把他们

06:44.940 --> 06:45.940
这些共同的行为

06:45.940 --> 06:46.940
提取成一个附类

06:46.940 --> 06:48.940
无论是几方坦克

06:48.940 --> 06:49.940
还是敌方坦克

06:49.940 --> 06:51.940
他们都是坦克

06:51.940 --> 06:52.940
你看玩家坦克

06:52.940 --> 06:53.940
是坦克

06:53.940 --> 06:54.940
敌方坦克也是坦克

06:54.940 --> 06:55.940
所以说

06:55.940 --> 06:56.940
我们可以形成

06:56.940 --> 06:58.940
这么一种继承关系

06:58.940 --> 07:02.450
可以形成这么一种继承关系

07:02.450 --> 07:03.450
好 这里呢

07:03.450 --> 07:04.450
我给大家画一下

07:04.450 --> 07:05.450
画一下一个图

07:05.450 --> 07:07.450
在马格当里面

07:07.450 --> 07:09.450
其实是可以画图的

07:09.450 --> 07:10.450
这个插件

07:10.450 --> 07:11.450
这个插件呢

07:11.450 --> 07:12.450
我看一下

07:12.450 --> 07:13.450
叫做

07:14.450 --> 07:15.450
马格当

07:15.450 --> 07:16.450
Preview Enhanced

07:16.450 --> 07:18.450
就是马格当的

07:18.450 --> 07:19.450
遇难增强

07:19.450 --> 07:20.450
这个插件

07:20.450 --> 07:22.450
安东的人蛮多的

07:22.450 --> 07:23.450
安东这个插件之后呢

07:23.450 --> 07:24.450
你可以在这里面

07:24.450 --> 07:25.450
在这里面

07:25.450 --> 07:26.450
马格当里面

07:26.450 --> 07:27.450
就可以写代码

07:27.450 --> 07:28.450
写在代码里面

07:28.450 --> 07:29.450
进行画图

07:29.450 --> 07:30.450
这个代码呢

07:30.450 --> 07:32.450
给他命名为PUML

07:32.450 --> 07:34.450
命名成这个名字

07:34.450 --> 07:35.450
然后在这里面

07:35.450 --> 07:36.450
就可以画图了

07:36.450 --> 07:37.450
首先写上一个指令

07:37.450 --> 07:39.450
叫Start UML

07:39.450 --> 07:41.450
这些都是小技巧

07:41.450 --> 07:42.450
UML

07:42.450 --> 07:43.450
然后呢

07:43.450 --> 07:45.450
这里面就可以画图了

07:45.450 --> 07:46.450
比方说我们这里要描述

07:46.450 --> 07:48.450
三个内之间的关系

07:48.450 --> 07:50.450
他们之间的继承关系

07:50.450 --> 07:51.450
可以这样的描述

07:51.450 --> 07:53.450
坦克是附内对吧

07:53.450 --> 07:54.450
坦克是附内

07:54.450 --> 07:56.450
有个东西去继承它

07:56.450 --> 07:57.450
哪个东西呢

07:58.450 --> 08:00.450
有个东西叫做Player

08:00.450 --> 08:02.450
就是我们玩家的坦克

08:02.450 --> 08:03.450
要去继承这个内

08:03.450 --> 08:04.450
好 这样子呢

08:04.450 --> 08:05.450
就把关系描述出来了

08:05.450 --> 08:06.450
它是附内

08:06.450 --> 08:07.450
它是指内

08:07.450 --> 08:09.450
它 继承于它

08:09.450 --> 08:10.450
通过这样的描述过后

08:10.450 --> 08:11.450
你看一下马克档

08:11.450 --> 08:13.450
我们把它说小一点

08:13.450 --> 08:14.450
看一下马克档

08:14.450 --> 08:15.450
它是正常的图形

08:15.450 --> 08:16.450
你看

08:16.450 --> 08:17.450
它是正常的这个图形

08:17.450 --> 08:19.450
这个C表示啥意思

08:19.450 --> 08:20.450
这个C就表示的是

08:20.450 --> 08:21.450
这里有个内对吧

08:21.450 --> 08:23.450
这里是Player Tank

08:23.450 --> 08:25.450
它通过一个空心箭头往上指

08:25.450 --> 08:27.450
以后大家看到这种图形

08:27.450 --> 08:29.450
这是一种标准的画法

08:29.450 --> 08:32.450
这种统一签膜语言

08:32.450 --> 08:33.450
就是这个UML

08:33.450 --> 08:35.450
就是统一签膜语言的意思

08:35.450 --> 08:37.450
在统一签膜语言里边

08:37.450 --> 08:38.450
它规定了很多图形

08:38.450 --> 08:39.450
它的标准画法

08:39.450 --> 08:41.450
比方说这里用的是内图

08:41.450 --> 08:42.450
内的关系图

08:42.450 --> 08:44.450
那么这可以通过这种画法

08:44.450 --> 08:46.450
几方坦克 玩家坦克

08:46.450 --> 08:48.450
基层字

08:48.450 --> 08:50.450
一个空心箭头表示基层

08:50.450 --> 08:52.450
基层字附内 Tank

08:52.450 --> 08:54.450
好 那么咱们再继续一些

08:54.450 --> 08:56.450
除了几方坦克之外

08:56.450 --> 08:57.450
还有一个坦克

08:57.450 --> 08:59.450
还有一个坦克

08:59.450 --> 09:01.450
然后是敌方坦克

09:01.450 --> 09:04.450
Any Tank

09:05.450 --> 09:07.450
敌方坦克 也许基层坦克

09:07.450 --> 09:09.450
于是呢 几方坦克

09:09.450 --> 09:10.450
和敌方坦克

09:10.450 --> 09:12.450
他们公共的东西都有的东西

09:12.450 --> 09:13.450
是不是可以放到

09:13.450 --> 09:15.450
坦克这个内里边

09:15.450 --> 09:17.450
对不对 就可以放到这里边

09:17.450 --> 09:19.450
所以说如果形成代码格式的话

09:19.450 --> 09:21.450
就是这样的格式 关掉

09:21.450 --> 09:23.450
把这个打开

09:23.450 --> 09:26.450
这里面我们写个代码

09:26.450 --> 09:29.450
比方说这里 Tank

09:29.450 --> 09:32.450
这是个附内

09:32.450 --> 09:33.450
我们直接导出吧

09:33.450 --> 09:35.450
Export

09:35.450 --> 09:36.450
Class

09:36.450 --> 09:38.450
Tank

09:38.450 --> 09:39.450
这是个附内

09:39.450 --> 09:41.450
那么还有两个纸类

09:41.450 --> 09:43.450
Export

09:43.450 --> 09:44.450
Class

09:44.450 --> 09:47.450
几方坦克 Player Tank

09:47.450 --> 09:49.450
然后敌方坦克

09:49.450 --> 09:51.450
Class

09:51.450 --> 09:52.450
Any

09:52.450 --> 09:54.450
我们做的不是要做这个游戏

09:54.450 --> 09:56.450
不是要做这个游戏

09:56.450 --> 09:57.450
而是通过这个游戏

09:57.450 --> 09:59.450
来解释他们类之间的关系

09:59.450 --> 10:00.450
然后这个东西

10:00.450 --> 10:02.450
就去继承 Tank

10:02.450 --> 10:05.450
然后这个东西也去继承 Tank

10:05.450 --> 10:07.450
继承 Tank

10:07.450 --> 10:08.450
那么既然继承了 Tank

10:08.450 --> 10:10.450
它 Tank里面的公共成员

10:10.450 --> 10:13.450
就是他们坦克里面的成员

10:13.450 --> 10:15.450
在这两个类里边也会自动拥有

10:15.450 --> 10:17.450
这样子就可以提取一些公共的代码

10:17.450 --> 10:19.450
比方说 Tank里面有哪些成员

10:19.450 --> 10:21.450
可以想象的到就是坐标

10:21.450 --> 10:22.450
无论你是坦克

10:22.450 --> 10:23.450
都有一个坐标

10:23.450 --> 10:25.450
一个坐标位置 对吧

10:25.450 --> 10:26.450
X 坐标

10:26.450 --> 10:27.450
Y 坐标

10:27.450 --> 10:29.450
这里为什么爆错

10:29.450 --> 10:31.450
爆错原因是没有出实化

10:31.450 --> 10:32.450
随便出实化一个吧

10:32.450 --> 10:33.450
这些不是重点

10:33.450 --> 10:34.450
我们主要是看他的成员

10:34.450 --> 10:35.450
有没有继承过来

10:35.450 --> 10:37.450
那么现在这两个类里边

10:37.450 --> 10:38.450
啥都没有

10:38.450 --> 10:40.450
我们去建一个几方坦克

10:40.450 --> 10:42.450
就是玩家的坦克

10:43.450 --> 10:45.450
New一个 Player Tank

10:45.450 --> 10:46.450
创建一个玩家坦克

10:46.450 --> 10:47.450
你看一下P里面

10:47.450 --> 10:49.450
是不是有了X 有了Y 对不对

10:49.450 --> 10:51.450
就有了这两个了

10:51.450 --> 10:54.450
这是关于继承的作用

10:54.450 --> 10:55.450
它主要是

10:55.450 --> 10:57.450
我们这边记一下吧

11:00.450 --> 11:01.450
继承的作用主要是

11:01.450 --> 11:02.450
继承之后

11:02.450 --> 11:04.450
它会拥有附列的所有成员

11:05.450 --> 11:08.450
这是关于继承的第一个点

11:09.450 --> 11:10.450
好 接下来

11:10.450 --> 11:11.450
我们来看一下

11:11.450 --> 11:13.450
继承里边有哪些代码

11:13.450 --> 11:15.450
可以去操作的

11:15.450 --> 11:16.450
可以去操作

11:16.450 --> 11:18.450
因为完成继承的话很简单

11:18.450 --> 11:20.450
咱们之前都用过

11:20.450 --> 11:21.450
在React的时候

11:21.450 --> 11:22.450
都用过这个继承

11:22.450 --> 11:24.450
用Extend来完成继承

11:24.450 --> 11:25.450
好 继承里边

11:25.450 --> 11:27.450
其实还有一些东西可以玩的

11:27.450 --> 11:28.450
就是平时玩的

11:28.450 --> 11:30.450
我们没有太注意

11:30.450 --> 11:31.450
我们一个个说

11:31.450 --> 11:35.450
首先是成员的重写

11:35.450 --> 11:36.450
成员的重写

11:36.450 --> 11:38.450
这是什么意思呢

11:38.450 --> 11:39.450
举个例子

11:39.450 --> 11:41.450
坦克这里

11:41.450 --> 11:43.450
比方说

11:43.450 --> 11:46.450
坦克这里有初始位置

11:46.450 --> 11:48.450
假设有初始位置

11:48.450 --> 11:50.450
如果是在附列里边

11:50.450 --> 11:51.450
坦克的初始位置

11:51.450 --> 11:52.450
因为我不知道

11:52.450 --> 11:54.450
它到底是什么样的坦克

11:54.450 --> 11:55.450
所以说这里初始位置

11:55.450 --> 11:56.450
它写的话

11:56.450 --> 11:57.450
我也不知道怎么写

11:57.450 --> 11:59.450
我就给它写个零零

11:59.450 --> 12:01.450
但是如果是几方坦克的话

12:01.450 --> 12:03.450
如果是几方坦克的话

12:03.450 --> 12:06.450
它有更加确定的初始位置

12:06.450 --> 12:08.450
因为我们玩坦克大战

12:08.450 --> 12:10.450
它出生的位置都是一样的

12:10.450 --> 12:13.450
你看几方坦克

12:13.450 --> 12:15.450
几方坦克出来就是在这个位置

12:15.450 --> 12:16.450
我们再打开一次

12:16.450 --> 12:18.450
你看出来还是在这个位置

12:18.450 --> 12:20.450
所以它的出生位置是固定的

12:20.450 --> 12:21.450
因此x y

12:21.450 --> 12:23.450
我们可以给它一个默认值

12:23.450 --> 12:25.450
在几方坦克里边

12:25.450 --> 12:27.450
我们可以给它重新复制一个默认值

12:27.450 --> 12:29.450
所以在这里面

12:29.450 --> 12:31.450
我再写一个x number

12:31.450 --> 12:33.450
给它复制为

12:33.450 --> 12:36.450
比方说20 y number

12:36.450 --> 12:38.450
给它复制为20

12:38.450 --> 12:39.450
这样子一来

12:39.450 --> 12:41.450
我们要看一下

12:41.450 --> 12:43.450
输出

12:43.450 --> 12:46.450
p.x和p.y

12:46.450 --> 12:47.450
那么输出多少呢

12:47.450 --> 12:49.450
就应该输出的是

12:49.450 --> 12:51.450
20和20

12:51.450 --> 12:52.450
这也就是说

12:52.450 --> 12:53.450
这两个成员

12:53.450 --> 12:54.450
就这两个属性

12:54.450 --> 12:56.450
把负累的属性给它覆盖掉了

12:56.450 --> 12:58.450
覆盖掉了负累的属性

12:58.450 --> 13:01.450
这个过程叫做重写

13:01.450 --> 13:02.450
就是

13:02.450 --> 13:05.450
指内中使用和

13:05.450 --> 13:11.450
就是覆盖和负累的成员

13:11.450 --> 13:13.450
这个概念就叫做重写

13:13.450 --> 13:15.450
重写

13:15.450 --> 13:18.450
重写也叫做overwrite

13:18.450 --> 13:20.450
overwrite

13:21.450 --> 13:22.450
重写

13:22.450 --> 13:23.450
指内里面

13:23.450 --> 13:24.450
跟负累里面有相同的成员

13:24.450 --> 13:26.450
那么就把负累的成员覆盖掉了

13:26.450 --> 13:28.450
当然前提条件是

13:28.450 --> 13:30.450
你创建的是指内的对象

13:30.450 --> 13:32.450
你这里去创建一个tank对象

13:32.450 --> 13:34.450
那它的结果还是0和0

13:34.450 --> 13:35.450
好 咱们来看一下

13:35.450 --> 13:37.450
看一下它的运行结果

13:37.450 --> 13:39.450
我把这个大脑杆都写到那边去吧

13:39.450 --> 13:41.450
写到那个index里面去

13:41.450 --> 13:43.450
这样子可以直接运行

13:43.450 --> 13:45.450
我们运行一下

13:45.450 --> 13:47.450
运行一下

13:47.450 --> 13:49.450
NpnRoundDev

13:49.450 --> 13:53.080
好 看一下

13:53.080 --> 13:55.080
你看 20 20

13:55.080 --> 13:56.080
我们最终看一下

13:56.080 --> 13:58.080
它生成的它编印的结果

13:58.080 --> 14:01.080
看一下它编印的结果

14:01.080 --> 14:06.290
NpnRoundDev

14:06.290 --> 14:08.290
看一下编印的结果

14:08.290 --> 14:09.290
编印的结果里面

14:09.290 --> 14:11.290
我们看到它就是

14:11.290 --> 14:14.290
一个普普通通的内

14:14.290 --> 14:16.290
然后有继承关系

14:16.290 --> 14:17.290
因为这个继承关系

14:17.290 --> 14:19.290
就是GS里面

14:19.290 --> 14:21.290
GS里面它也有的继承关系

14:21.290 --> 14:23.290
不是说只有TS还有

14:23.290 --> 14:24.290
GS本身就有

14:24.290 --> 14:26.290
我们以前写react的时候

14:26.290 --> 14:28.290
也是用了继承啊 对不对

14:28.290 --> 14:29.290
好 那你看一下

14:29.290 --> 14:30.290
它这个代码

14:30.290 --> 14:31.290
代码是不是没有什么好

14:31.290 --> 14:32.290
没有什么特别的 对不对

14:32.290 --> 14:34.290
就是腹内里面

14:34.290 --> 14:36.290
把xy复制成0

14:36.290 --> 14:38.290
就是我们这边的默认值

14:38.290 --> 14:39.290
这边的默认值

14:39.290 --> 14:41.290
把这个物件删掉吧

14:41.290 --> 14:42.290
这个物件里面

14:42.290 --> 14:44.290
我就写到index里面

14:44.290 --> 14:46.290
好 我们这边的默认值

14:46.290 --> 14:47.290
它编印的结果呢

14:47.290 --> 14:48.290
就变成了

14:48.290 --> 14:50.290
在构造函数里面给它复制

14:50.290 --> 14:52.290
在构造函数里面的默认值

14:52.290 --> 14:54.290
就变成了构造函数

14:54.290 --> 14:55.290
构造函数的值

14:55.290 --> 14:57.290
相当于把它覆盖掉了

14:57.290 --> 14:58.290
但是在覆盖的时候

14:58.290 --> 14:59.290
大家要注意一下

14:59.290 --> 15:00.290
比方说

15:00.290 --> 15:02.290
我这里的number

15:02.290 --> 15:04.290
能不能给它换一个类型呢

15:04.290 --> 15:05.290
我们试一下

15:05.290 --> 15:07.290
试一下能不能换一个类型

15:07.290 --> 15:09.290
给它写成一个字幕串

15:09.290 --> 15:10.290
行不行

15:10.290 --> 15:12.290
这样子是不行的 你看

15:12.290 --> 15:13.290
它说

15:13.290 --> 15:16.290
你要做这里一个同名的属像

15:16.290 --> 15:17.290
腹内里面有这个属像

15:17.290 --> 15:18.290
是number

15:18.290 --> 15:19.290
没有这个属像

15:19.290 --> 15:20.290
x

15:20.290 --> 15:21.290
那么一把类型给它编了

15:21.290 --> 15:22.290
它是不允许的

15:22.290 --> 15:24.290
你想象这个道理

15:24.290 --> 15:26.290
你想一想这个道理

15:26.290 --> 15:28.290
有没有可能需要做这件事情

15:28.290 --> 15:30.290
这件事情合不合逻辑

15:30.290 --> 15:32.290
实际上是不合逻辑的

15:32.290 --> 15:34.290
比方说啊

15:34.290 --> 15:35.290
我们说

15:35.290 --> 15:37.290
基层的概念是什么呢

15:37.290 --> 15:38.290
是什么东西

15:38.290 --> 15:39.290
是什么

15:39.290 --> 15:41.290
玩家坦克

15:41.290 --> 15:42.290
是坦克

15:42.290 --> 15:44.290
那么坦克有的特征

15:44.290 --> 15:46.290
是不是玩家坦克一定有

15:46.290 --> 15:48.290
想象这个道理

15:48.290 --> 15:49.290
帅哥

15:49.290 --> 15:50.290
帅哥他也是人嘛

15:50.290 --> 15:51.290
那人有的特征

15:51.290 --> 15:53.290
是不是帅哥他一定有

15:53.290 --> 15:54.290
对不对

15:54.290 --> 15:57.290
所以既然这个东西是负类

15:57.290 --> 15:58.290
他的特征呢

15:58.290 --> 16:00.290
是所有的籽类都通用的

16:00.290 --> 16:03.290
都是公有的

16:03.290 --> 16:05.290
那么他里面的特征

16:05.290 --> 16:06.290
是什么类型

16:06.290 --> 16:08.290
籽类他一定是什么类型

16:08.290 --> 16:09.290
比方说

16:09.290 --> 16:11.290
人的名字是一个制服串

16:11.290 --> 16:13.290
如果人的名字是一个制服串

16:13.290 --> 16:14.290
你不能说

16:14.290 --> 16:15.290
你是帅哥

16:15.290 --> 16:16.290
你是人

16:16.290 --> 16:17.290
你的名字是一个数字

16:17.290 --> 16:18.290
你就算是数字

16:18.290 --> 16:20.290
也是数字制服串

16:20.290 --> 16:21.290
那么意外的意思嘛

16:21.290 --> 16:22.290
对不对

16:22.290 --> 16:23.290
所以说

16:23.290 --> 16:25.290
这里呢是不允许你去修改他的类型的

16:25.290 --> 16:27.290
那修改的类型的逻辑说不通

16:27.290 --> 16:28.290
因此呢

16:28.290 --> 16:29.290
你这样的代码呢

16:29.290 --> 16:30.290
他是会被判定为失败的

16:30.290 --> 16:32.290
你这样做是不行的

16:32.290 --> 16:33.290
不行

16:33.290 --> 16:34.290
不能这样去做

16:34.290 --> 16:35.290
好

16:35.290 --> 16:36.290
如果有一天啊

16:36.290 --> 16:37.290
假设啊

16:37.290 --> 16:38.290
假设

16:38.290 --> 16:40.290
但是这个假设很奇怪了

16:40.290 --> 16:41.290
比方帅哥

16:41.290 --> 16:43.290
他特别有个性

16:43.290 --> 16:44.290
他的名字就一定要是Number

16:44.290 --> 16:45.290
他就不能是数字

16:45.290 --> 16:47.290
他就不能是制服串

16:47.290 --> 16:48.290
比方说

16:48.290 --> 16:50.290
我们来聊这么一个场景啊

16:50.290 --> 16:51.290
我们就来采纲

16:51.290 --> 16:56.660
人的名字是制服串

16:56.660 --> 17:01.660
但是帅哥的名字是数字

17:01.660 --> 17:03.660
他特别吧

17:03.660 --> 17:04.660
他行为艺术

17:04.660 --> 17:06.660
他是名字是数字

17:06.660 --> 17:07.660
那么想一想这个逻辑

17:07.660 --> 17:09.660
这个逻辑还是不同

17:09.660 --> 17:10.660
我们就强行认为

17:10.660 --> 17:13.660
帅哥的名字有可能是数字

17:13.660 --> 17:14.660
那么这个逻辑

17:14.660 --> 17:15.660
为什么不通

17:15.660 --> 17:16.660
大家想一想

17:16.660 --> 17:18.660
首先我们确定一个点

17:18.660 --> 17:20.660
帅哥他是不是人

17:20.660 --> 17:21.660
他是不是人

17:21.660 --> 17:22.660
是一个人对不对

17:22.660 --> 17:23.660
好

17:23.660 --> 17:24.660
我们先把这个点确定下来

17:24.660 --> 17:25.660
再看这句话

17:25.660 --> 17:28.660
这句话是不是错了

17:28.660 --> 17:30.660
凭什么说人的名字是制服串呢

17:30.660 --> 17:31.660
帅哥的名字

17:31.660 --> 17:32.660
帅哥也是人啊

17:32.660 --> 17:33.660
帅哥的名字他就不是制服串

17:33.660 --> 17:34.660
他就是数字

17:34.660 --> 17:36.660
所以说这句话就错了

17:36.660 --> 17:37.660
这句话的意思是啥

17:37.660 --> 17:39.660
人的名字是制服串

17:39.660 --> 17:40.660
货

17:40.660 --> 17:41.660
数字

17:41.660 --> 17:43.660
这样是不是正确了

17:43.660 --> 17:44.660
对不对

17:44.660 --> 17:45.660
所以说这个逻辑啊

17:45.660 --> 17:47.660
这个逻辑一定要

17:47.660 --> 17:48.660
一定要是通的

17:48.660 --> 17:49.660
不然的话你这样子的

17:49.660 --> 17:50.660
你这样子的话

17:50.660 --> 17:51.660
逻辑就不通

17:51.660 --> 17:52.660
你这个前后矛盾的

17:52.660 --> 17:54.660
因为他有个前提条件

17:54.660 --> 17:55.660
就是帅哥是人

17:55.660 --> 17:56.660
他们是有基层关系的

17:56.660 --> 17:57.660
帅哥是人

17:57.660 --> 17:58.660
那这个

17:58.660 --> 17:59.660
你看这三条语句

17:59.660 --> 18:01.660
他们之间是矛盾的

18:01.660 --> 18:02.660
人的名字是制服串

18:02.660 --> 18:03.660
凭什么帅哥是人啊

18:03.660 --> 18:04.660
那他的名字

18:04.660 --> 18:05.660
为什么是数字呢

18:05.660 --> 18:06.660
所以说要么

18:06.660 --> 18:07.660
第一句话有问题

18:07.660 --> 18:08.660
要么第二句话有问题

18:08.660 --> 18:09.660
明白这个意思吗

18:09.660 --> 18:11.660
所以说他这里为什么

18:11.660 --> 18:12.660
他想的很细的

18:12.660 --> 18:13.660
他为什么要这里

18:13.660 --> 18:14.660
我给你忘了说

18:14.660 --> 18:15.660
不是来仙子里

18:15.660 --> 18:16.660
就趴里去

18:16.660 --> 18:17.660
做一些莫名其妙的事情

18:17.660 --> 18:19.660
这个逻辑是说不通的

18:19.660 --> 18:21.660
因此咱们记彼啊

18:21.660 --> 18:24.660
在继承的关系里中

18:24.660 --> 18:26.660
就是

18:26.660 --> 18:28.660
子内成员

18:28.660 --> 18:30.660
不能改变

18:30.660 --> 18:34.660
父内成员的内容

18:34.660 --> 18:35.660
或者说

18:35.660 --> 18:36.660
子内的同名

18:36.660 --> 18:37.660
跟父内同名的成员

18:37.660 --> 18:38.660
内心要匹配

18:38.660 --> 18:39.660
所以说

18:39.660 --> 18:41.660
我们把这句话加上

18:41.660 --> 18:42.660
这句话加上

18:42.660 --> 18:43.660
就是重写的时候

18:43.660 --> 18:44.660
这个规则大家注意

18:44.660 --> 18:46.660
当然重写呢

18:46.660 --> 18:49.660
不仅仅是可以重写属性

18:49.660 --> 18:51.660
不仅仅是可以重写属性

18:51.660 --> 18:52.660
还可以重写方法

18:52.660 --> 18:53.660
都是一样的

18:53.660 --> 18:54.660
重写的是什么

18:54.660 --> 18:55.660
重写的是成员

18:55.660 --> 18:57.660
坦克里边

18:57.660 --> 18:58.660
坦克里边

18:58.660 --> 19:00.660
所有的坦克都有一个

19:00.660 --> 19:02.660
函数

19:02.660 --> 19:03.660
都有一个函数

19:03.660 --> 19:04.660
这个函数呢

19:04.660 --> 19:05.660
表示

19:05.660 --> 19:07.660
发射子弹

19:07.660 --> 19:08.660
发射子弹

19:09.660 --> 19:11.660
发射子弹

19:11.660 --> 19:13.660
假设有这么一个函数

19:13.660 --> 19:14.660
好

19:14.660 --> 19:15.660
几方坦克呢

19:15.660 --> 19:16.660
他也要发射子弹

19:16.660 --> 19:17.660
但是他发射子弹

19:17.660 --> 19:18.660
可能要快一些

19:18.660 --> 19:19.660
不是我们

19:19.660 --> 19:20.660
坦克大战里边

19:20.660 --> 19:21.660
当然我个游戏没做

19:21.660 --> 19:22.660
坦克大战里边

19:22.660 --> 19:23.660
他可以减一些

19:23.660 --> 19:24.660
什么

19:24.660 --> 19:26.660
吃一些猩猩

19:26.660 --> 19:28.660
吃一些东西

19:28.660 --> 19:29.660
吃了东西过后

19:29.660 --> 19:30.660
发射子弹

19:30.660 --> 19:31.660
它会有变化

19:31.660 --> 19:32.660
因此

19:32.660 --> 19:33.660
几方坦克

19:33.660 --> 19:34.660
他的发射子弹

19:34.660 --> 19:35.660
可能比较特殊

19:35.660 --> 19:37.660
他需要重新去

19:37.660 --> 19:39.660
实现一下这个方法

19:39.660 --> 19:40.660
当然有些同学

19:40.660 --> 19:41.660
可能没有玩过

19:41.660 --> 19:42.660
坦克大战对吧

19:42.660 --> 19:44.660
有些红白鸡的游戏很老了

19:44.660 --> 19:45.660
秀子

19:45.660 --> 19:46.660
比方几方坦克呢

19:46.660 --> 19:48.660
他也去实现这个方法

19:48.660 --> 19:49.660
也去实现方法

19:49.660 --> 19:50.660
比方说

19:50.660 --> 19:51.660
几方

19:54.660 --> 19:55.660
就是玩家

19:55.660 --> 19:57.660
玩家坦克发射子弹

19:57.660 --> 19:58.660
他可能实现的方式

19:58.660 --> 19:59.660
有点不一样

19:59.660 --> 20:01.660
而敌方坦克呢

20:01.660 --> 20:03.660
他也有可能会发射子弹

20:03.660 --> 20:05.660
敌方坦克发射子弹

20:05.660 --> 20:06.660
他实现的方法

20:06.660 --> 20:07.660
方式呢

20:07.660 --> 20:08.660
也有可能不一样

20:08.660 --> 20:09.660
那么你看

20:09.660 --> 20:10.660
我在指内里边

20:10.660 --> 20:12.660
在指内里边

20:12.660 --> 20:14.660
去写了这个方法

20:14.660 --> 20:15.660
那么就相当于是

20:15.660 --> 20:16.660
把负累的方法呢

20:16.660 --> 20:18.660
给他覆盖掉了

20:18.660 --> 20:19.660
给他覆盖掉了

20:19.660 --> 20:20.660
好

20:20.660 --> 20:21.660
咱们来看一下

20:21.660 --> 20:22.660
我们在

20:22.660 --> 20:24.660
这里调用方法

20:24.660 --> 20:25.660
秀子

20:25.660 --> 20:26.660
它不是有函数吗

20:26.660 --> 20:27.660
来调用一下

20:27.660 --> 20:29.660
人品装

20:31.660 --> 20:32.660
你看

20:32.660 --> 20:33.660
调一下

20:33.660 --> 20:34.660
它运行的时候呢

20:34.660 --> 20:35.660
运行的是

20:35.660 --> 20:37.660
玩家坦克

20:37.660 --> 20:38.660
运行的是玩家坦克

20:38.660 --> 20:40.660
就几方坦克发射子弹

20:40.660 --> 20:41.660
运行的是这么一个函数

20:41.660 --> 20:43.660
运行的是指内的函数

20:43.660 --> 20:45.660
运行的是指内的函数

20:45.660 --> 20:46.660
OK

20:46.660 --> 20:48.660
这是关于这个点

20:48.660 --> 20:49.660
方法之间

20:49.660 --> 20:50.660
也可以覆盖掉

20:50.660 --> 20:51.660
也可以覆盖

20:52.660 --> 20:53.660
好

20:53.660 --> 20:55.660
我们再继续看

20:55.660 --> 20:56.660
成员的重写

20:56.660 --> 20:58.660
那么也就是说

20:58.660 --> 20:59.660
无论

20:59.660 --> 21:01.660
无论是属性

21:02.660 --> 21:04.660
还是方法

21:04.660 --> 21:07.660
指内都可以覆盖

21:09.660 --> 21:12.660
都可以对覆内的相应

21:13.660 --> 21:15.660
成员进行重写

21:15.660 --> 21:16.660
重写

21:16.660 --> 21:17.660
但是重写的时候

21:17.660 --> 21:19.660
但是重写时

21:21.660 --> 21:23.660
需要保证

21:23.660 --> 21:24.660
需要保证什么

21:24.660 --> 21:26.660
类型的匹配

21:27.660 --> 21:29.660
就是你重写属性也好

21:29.660 --> 21:30.660
重写方法也好

21:30.660 --> 21:31.660
都要保证类型的匹配

21:31.660 --> 21:33.660
那么刚才我们写了个方法

21:33.660 --> 21:34.660
比方说

21:34.660 --> 21:35.660
比方说

21:35.660 --> 21:38.660
咱们在写这个Player Tank的时候

21:38.660 --> 21:41.660
这个方法里面多了个参数

21:41.660 --> 21:42.660
比方说多了个参数

21:42.660 --> 21:44.660
Speed

21:44.660 --> 21:45.660
Speed

21:45.660 --> 21:46.660
就是子弹速度

21:46.660 --> 21:48.660
子弹速度

21:48.660 --> 21:49.660
子弹怎么说

21:49.660 --> 21:51.660
子弹单词是啥

21:51.660 --> 21:53.660
Ballet

21:53.660 --> 21:54.660
好像是这个

21:54.660 --> 21:56.660
Ballet

21:57.660 --> 21:59.660
那就子弹速度吧

21:59.660 --> 22:00.660
我就写个P

22:00.660 --> 22:02.660
子弹Speed

22:03.660 --> 22:04.660
速度

22:04.660 --> 22:05.660
它是一个Number

22:05.660 --> 22:06.660
它发射子弹的时候

22:06.660 --> 22:07.660
要告诉我一个

22:07.660 --> 22:09.660
要告诉我一个参数子弹速度

22:09.660 --> 22:10.660
你看马上就爆错了

22:10.660 --> 22:11.660
因为函数不匹配

22:11.660 --> 22:12.660
你看到没

22:12.660 --> 22:13.660
函数不匹配

22:13.660 --> 22:14.660
成员不匹配

22:14.660 --> 22:16.660
这就是我们之前说的这个问题

22:16.660 --> 22:17.660
说的这个问题

22:17.660 --> 22:18.660
还是一样的

22:18.660 --> 22:20.660
还是一样的原因

22:20.660 --> 22:21.660
就是说

22:22.660 --> 22:24.660
敷类是坦克

22:24.660 --> 22:26.660
坦克是所有工友的东西

22:26.660 --> 22:27.660
坦克可以发射子弹

22:27.660 --> 22:28.660
那发射子弹他没有参数

22:28.660 --> 22:30.660
那么子弹也不能有参数

22:30.660 --> 22:31.660
也不能有参数

22:31.660 --> 22:32.660
那如果

22:33.660 --> 22:35.660
如果子弹需要参数的话

22:35.660 --> 22:36.660
怎么办

22:37.660 --> 22:39.660
如果子弹需要参数的话怎么办

22:39.660 --> 22:40.660
那么腰膜

22:40.660 --> 22:42.660
你敷了也得加这个参数

22:43.660 --> 22:45.660
要么敷了也得加这个参数

22:45.660 --> 22:46.660
腰膜呢

22:46.660 --> 22:47.660
都不加

22:48.660 --> 22:49.660
那如果说

22:49.660 --> 22:50.660
有这种情况

22:50.660 --> 22:52.660
几方坦克发射子弹要参数

22:53.660 --> 22:54.660
敌方坦克发生子弹

22:54.660 --> 22:55.660
又不要参数

22:55.660 --> 22:56.660
那面对这种情况

22:56.660 --> 22:57.660
又怎么处理呢

22:58.660 --> 23:00.660
两种处理办法

23:00.660 --> 23:01.660
第一种

23:01.660 --> 23:02.660
负责的方法不要了

23:02.660 --> 23:04.660
因为差异过大

23:04.660 --> 23:05.660
差异过大

23:05.660 --> 23:07.660
它就不是共同的特征了

23:07.660 --> 23:09.660
他们两个都有发射子弹的动作

23:09.660 --> 23:10.660
但是呢

23:10.660 --> 23:11.660
实际上完全不一样

23:11.660 --> 23:13.660
就是他的格式都完全不一样

23:13.660 --> 23:15.660
就是雕用方法的方式

23:15.660 --> 23:16.660
都完全不一样

23:16.660 --> 23:17.660
因此他们不是共同的特征

23:17.660 --> 23:19.660
就不应该放到负类里面

23:19.660 --> 23:20.660
这是第一种

23:20.660 --> 23:21.660
第二种

23:21.660 --> 23:23.660
如果他们的逻辑含义是一样的

23:23.660 --> 23:25.660
然后都是发射子弹

23:25.660 --> 23:27.660
其实也可以放到负类里面

23:27.660 --> 23:29.660
那么负类里面保持无参

23:29.660 --> 23:30.660
然后呢

23:30.660 --> 23:31.660
把你需要的参数

23:31.660 --> 23:32.660
做成属性

23:32.660 --> 23:33.660
把你需要的参数

23:33.660 --> 23:34.660
做成属性

23:34.660 --> 23:35.660
子弹速度

23:38.660 --> 23:39.660
把他做成属性

23:42.660 --> 23:43.660
把他做成属性

23:43.660 --> 23:44.660
那么这里是不是不需要参数了

23:44.660 --> 23:46.660
这里可以通过属性搞定了

23:46.660 --> 23:47.660
按理说的

23:47.660 --> 23:48.660
这个逻辑上也说得通

23:48.660 --> 23:50.660
因为他子弹速度

23:50.660 --> 23:53.660
本身就可以作为玩家坦克的一个属性

23:53.660 --> 23:54.660
对吧

23:54.660 --> 23:55.660
是可以作为属性的

23:55.660 --> 23:57.660
因此他逻辑上也是说得通的

23:58.660 --> 24:00.660
当然有些同学可能会想

24:00.660 --> 24:01.660
子弹速度

24:01.660 --> 24:02.660
敌方坦克也有子弹速度

24:02.660 --> 24:03.660
对吧

24:03.660 --> 24:04.660
敌方坦克也有子弹速度

24:04.660 --> 24:05.660
那么子弹速度

24:05.660 --> 24:06.660
是不是公有的东西

24:06.660 --> 24:07.660
应该放到负类里面了

24:07.660 --> 24:09.660
其实也行

24:09.660 --> 24:11.660
我只是举这么个例子

24:11.660 --> 24:12.660
主要是说明

24:12.660 --> 24:13.660
说明这个

24:13.660 --> 24:15.660
函数的重写

24:15.660 --> 24:17.660
他是要看内行的

24:17.660 --> 24:18.660
同样的

24:18.660 --> 24:19.660
这些成员的重写

24:19.660 --> 24:20.660
都是要看内行的

24:20.660 --> 24:21.660
内行的必须匹配

24:21.660 --> 24:22.660
这是关于

24:22.660 --> 24:24.660
成员的重写

24:25.660 --> 24:28.660
成员的重写的时候

24:28.660 --> 24:29.660
就是

24:29.660 --> 24:30.660
大家要注意一下

24:30.660 --> 24:32.660
就使用了基层关系过后

24:32.660 --> 24:34.660
要注意Z

24:34.660 --> 24:36.660
Z关键值

24:36.660 --> 24:38.660
的

24:38.660 --> 24:40.660
要注意Z关键值

24:40.660 --> 24:42.660
这个关键值有什么好注意的呢

24:42.660 --> 24:43.660
我这里写一句话

24:43.660 --> 24:44.660
然后再来解释

24:44.660 --> 24:46.660
在基层关系中

24:46.660 --> 24:48.660
关系中

24:48.660 --> 24:50.660
Z的指向

24:50.660 --> 24:51.660
是动态的

24:51.660 --> 24:52.660
什么要动态的

24:52.660 --> 24:54.660
就是指的是

24:54.660 --> 24:57.660
雕用成员

24:57.660 --> 24:59.660
雕用方法是

24:59.660 --> 25:02.660
根据具体的

25:02.660 --> 25:04.660
雕用者

25:04.660 --> 25:06.660
哪个对象在雕用这个方法

25:06.660 --> 25:08.660
根据具体的雕用者

25:08.660 --> 25:10.660
确定Z的指向

25:10.660 --> 25:12.660
Z的指向是动态的

25:12.660 --> 25:13.660
我举个例子吧

25:13.660 --> 25:15.660
比方说

25:15.660 --> 25:17.660
这里

25:17.660 --> 25:19.660
这里

25:19.660 --> 25:20.660
坦克里边

25:20.660 --> 25:21.660
比方说

25:21.660 --> 25:22.660
里边有一个

25:22.660 --> 25:24.660
函数

25:24.660 --> 25:26.660
叫做

25:26.660 --> 25:28.660
Hello

25:28.660 --> 25:29.660
坦克里边

25:29.660 --> 25:30.660
打个招呼吧

25:30.660 --> 25:32.660
给大家打个招呼

25:32.660 --> 25:33.660
这里打招呼的时候

25:33.660 --> 25:35.660
我们就输出

25:35.660 --> 25:37.660
一个支付串

25:37.660 --> 25:39.660
我是一个

25:39.660 --> 25:40.660
坦克

25:40.660 --> 25:41.660
我是一个坦克

25:41.660 --> 25:42.660
比方说

25:42.660 --> 25:43.660
这里

25:43.660 --> 25:45.660
我们再加一个属性吧

25:45.660 --> 25:47.660
坦克的名字

25:47.660 --> 25:49.660
一个支付串

25:49.660 --> 25:50.660
默认为

25:50.660 --> 25:52.660
默认为坦克

25:52.660 --> 25:54.660
然后这边呢

25:54.660 --> 25:56.660
这边呢

25:56.660 --> 25:58.660
放到腹内里边

25:58.660 --> 26:00.660
放到腹内里边

26:00.660 --> 26:01.660
坦克的名字

26:01.660 --> 26:03.660
放到腹内里边

26:03.660 --> 26:04.660
然后这个

26:04.660 --> 26:05.660
几方坦克呢

26:05.660 --> 26:07.660
几方坦克去重写这个名字

26:07.660 --> 26:09.660
重写这个名字

26:09.660 --> 26:11.660
Name

26:11.660 --> 26:13.660
这是玩家坦克

26:13.660 --> 26:15.660
坦克

26:15.660 --> 26:16.660
你看啊

26:16.660 --> 26:18.660
这个几方坦克里边

26:18.660 --> 26:19.660
已经被重写了

26:19.660 --> 26:20.660
好

26:20.660 --> 26:21.660
然后呢

26:21.660 --> 26:22.660
敌方坦克

26:22.660 --> 26:23.660
也是啊

26:23.660 --> 26:24.660
也是一样Name

26:24.660 --> 26:25.660
怎么算

26:25.660 --> 26:26.660
重写啊

26:26.660 --> 26:27.660
这敌方坦克

26:27.660 --> 26:28.660
看一下啊

26:28.660 --> 26:30.660
其他的属性不用关注

26:30.660 --> 26:31.660
不用关注其他的属性

26:31.660 --> 26:32.660
我们其他属性

26:32.660 --> 26:33.660
可以扔掉啊

26:33.660 --> 26:34.660
都可以扔掉

26:34.660 --> 26:36.660
其他属性不用关注

26:36.660 --> 26:38.660
这些东西也不用关注

26:38.660 --> 26:40.660
我们尽量把它

26:40.660 --> 26:41.660
缩减一下啊

26:41.660 --> 26:43.660
来看一下

26:43.660 --> 26:45.660
这个shallow在腹内里边

26:45.660 --> 26:47.660
是这么一种关系啊

26:47.660 --> 26:48.660
这两个Name呢

26:48.660 --> 26:49.660
去继承了腹内

26:49.660 --> 26:51.660
腹内里边有个共有的函数

26:51.660 --> 26:52.660
shallow

26:52.660 --> 26:53.660
它的招呼

26:53.660 --> 26:55.660
我是一个什么呢

26:55.660 --> 26:56.660
我是一个独去

26:56.660 --> 26:58.660
动态的独去

26:58.660 --> 27:01.660
当前对象的Name属性

27:01.660 --> 27:03.660
我是一个这么一个坦克

27:03.660 --> 27:04.660
就行了

27:04.660 --> 27:05.660
打个招呼就完事了

27:05.660 --> 27:06.660
好

27:06.660 --> 27:07.660
接下来呢

27:07.660 --> 27:08.660
给大家看一下

27:08.660 --> 27:10.660
我在

27:10.660 --> 27:12.660
下边去使用这个

27:12.660 --> 27:13.660
Player Tank的时候

27:13.660 --> 27:15.660
就是几方坦克的时候

27:15.660 --> 27:16.660
我们调用什么呢

27:16.660 --> 27:18.660
调用它的里面的shallow

27:18.660 --> 27:20.660
它会输出什么

27:20.660 --> 27:22.660
输出的是坦克

27:22.660 --> 27:24.660
还是玩家坦克呢

27:24.660 --> 27:25.660
输出的是啥呢

27:25.660 --> 27:27.660
有一些同学可能会觉得

27:27.660 --> 27:29.660
你这个z是写到哪了呢

27:29.660 --> 27:31.660
写到这个tank这个内里边的

27:31.660 --> 27:32.660
因此呢

27:32.660 --> 27:34.660
他读的是tank这个内里边的成员

27:34.660 --> 27:36.660
Name得到的是tank

27:36.660 --> 27:37.660
不对啊

27:37.660 --> 27:39.660
不应该是这样去看

27:39.660 --> 27:40.660
z的指向是动态的

27:40.660 --> 27:42.660
就是当我们雕用的时候

27:42.660 --> 27:44.660
才能确定z的指向

27:44.660 --> 27:45.660
哪个在雕用

27:45.660 --> 27:47.660
雕用的人是啥

27:47.660 --> 27:49.660
雕用的人是

27:49.660 --> 27:51.660
Player Tank

27:51.660 --> 27:53.660
是这个那个对象

27:53.660 --> 27:54.660
因此呢

27:54.660 --> 27:56.660
它在雕用shallow的时候

27:56.660 --> 27:58.660
相当于是

27:58.660 --> 28:00.660
z的指向这个p

28:00.660 --> 28:02.660
它是Player Tank的对象

28:02.660 --> 28:03.660
你明白这个意思吗

28:03.660 --> 28:04.660
好

28:04.660 --> 28:05.660
我们来看一下

28:06.660 --> 28:08.660
我是一个玩家坦克

28:08.660 --> 28:10.660
答应出来了

28:10.660 --> 28:11.660
这个的指

28:11.660 --> 28:12.660
因此Z的指向

28:12.660 --> 28:13.660
运行的过程中

28:13.660 --> 28:14.660
运行这个shallow

28:14.660 --> 28:16.660
Z的指向指向谁呢

28:16.660 --> 28:18.660
指向的是玩家坦克

28:18.660 --> 28:19.660
这个搞清楚

28:19.660 --> 28:20.660
那么同样的道理

28:20.660 --> 28:22.660
如果这里是animate tank的话

28:22.660 --> 28:23.660
看一下

28:23.660 --> 28:25.660
那么运行出来又是个敌方坦克

28:25.660 --> 28:27.660
Z的指向是动态的

28:27.660 --> 28:29.660
大家注意这一点

28:29.660 --> 28:30.660
好

28:30.660 --> 28:31.660
这是关于

28:32.660 --> 28:34.660
Z关键字

28:34.660 --> 28:35.660
还有呢

28:35.660 --> 28:37.660
还有一个点呢就是

28:37.660 --> 28:40.420
下面

28:40.420 --> 28:42.420
我们再开一个来写吧

28:42.420 --> 28:44.420
就是内雄匹配

28:44.420 --> 28:46.420
就是在基层关系里边

28:46.420 --> 28:48.420
如何来匹配内雄

28:48.420 --> 28:50.420
其实还是一样的

28:50.420 --> 28:52.420
压纸变形法

28:52.420 --> 28:54.420
分变

28:54.420 --> 28:56.420
变形法

28:56.420 --> 28:58.420
压纸变形法

28:58.420 --> 29:00.420
也叫做指结构变形法

29:00.420 --> 29:01.420
什么行业呢

29:01.420 --> 29:02.420
具体来说就是

29:02.420 --> 29:04.420
在内的系统里边

29:04.420 --> 29:06.420
如何来进行内雄匹配呢

29:06.420 --> 29:08.420
纸内的对象

29:08.420 --> 29:10.420
始终

29:10.420 --> 29:12.420
始终可以复职

29:12.420 --> 29:14.420
给负类

29:14.420 --> 29:16.420
负类的

29:16.420 --> 29:18.420
始终可以匹配负类内雄

29:18.420 --> 29:20.420
始终可以复制给负类

29:20.420 --> 29:22.420
为什么呢 你想一想这个道理

29:22.420 --> 29:23.420
负类的成员

29:23.420 --> 29:25.420
是不是跟纸内来说

29:25.420 --> 29:27.420
纸内的成员一定是

29:27.420 --> 29:29.420
大于等于负类的

29:29.420 --> 29:30.420
对不对

29:30.420 --> 29:32.420
纸内基层和负类嘛

29:32.420 --> 29:34.420
那么负类里面有的东西他都有

29:34.420 --> 29:36.420
他还有自己特别的东西

29:36.420 --> 29:38.420
因此呢 纸内的成员

29:38.420 --> 29:40.420
一定是大于等于负类的

29:40.420 --> 29:42.420
负类下要求的特征

29:42.420 --> 29:44.420
纸内里面肯定是全部具有的

29:44.420 --> 29:46.420
因此呢 纸内对象是可以

29:46.420 --> 29:48.420
复制给负类的

29:48.420 --> 29:50.420
举个例子啊 比方说 这里

29:50.420 --> 29:52.420
好 这里

29:52.420 --> 29:54.420
我们这个给这个

29:54.420 --> 29:56.420
长量P 先制一下

29:56.420 --> 29:58.420
先制为什么呢 Tank

29:58.420 --> 30:00.420
你看一下 这样复制行不行

30:00.420 --> 30:01.420
所以可以

30:01.420 --> 30:03.420
可以复制

30:03.420 --> 30:05.420
Player Tank 他也是个坦克嘛

30:05.420 --> 30:07.420
他拥有坦克的所有特征

30:07.420 --> 30:09.420
因此呢 根据压制变形法

30:09.420 --> 30:11.420
复制为这个 给这个变量

30:11.420 --> 30:13.420
虽然这个变量要求的内形是 Tank

30:13.420 --> 30:15.420
但是Player Tank可以堪诚是一个坦克

30:15.420 --> 30:17.420
这个逻辑上也说了通的

30:17.420 --> 30:19.420
我这里面要保存什么呢

30:19.420 --> 30:21.420
保存一个坦克 那

30:21.420 --> 30:23.420
玩家坦克是不是坦克吗

30:23.420 --> 30:25.420
他肯定是坦克 那可以保存进去啊

30:25.420 --> 30:27.420
所以说没有任何问题

30:27.420 --> 30:29.420
好 那这里 Say hello 叔叔啥呢

30:29.420 --> 30:31.420
叔叔是坦克还是玩家坦克呢

30:31.420 --> 30:34.420
这里呢 大家可能又要搞晕了啊

30:34.420 --> 30:36.420
要搞晕了 不要晕

30:36.420 --> 30:38.420
一切都按照逻辑来想

30:38.420 --> 30:40.420
一切按照逻辑来想

30:40.420 --> 30:42.420
他的真实的东

30:42.420 --> 30:44.420
他里面保存的东西

30:44.420 --> 30:46.420
是不是玩家坦克

30:46.420 --> 30:48.420
保存的 他里面保存的真实的东西

30:48.420 --> 30:50.420
是不是玩家坦克

30:50.420 --> 30:52.420
所以一定是玩家坦克

30:52.420 --> 30:54.420
因为你看这里 六个玩家坦克

30:54.420 --> 30:56.420
把玩家坦克的对象保存进来了

30:56.420 --> 30:58.420
所以他里面真实的东西是玩家坦克

30:58.420 --> 31:00.420
因此在运行的时候

31:00.420 --> 31:02.420
他肯定还是玩家坦克

31:02.420 --> 31:04.420
你看 还是玩家坦克

31:04.420 --> 31:06.420
所以说 这里呢

31:06.420 --> 31:08.420
这个内形限制呢

31:08.420 --> 31:10.420
只是我刚才那个意思呢

31:10.420 --> 31:12.420
只是告诉大家

31:12.420 --> 31:14.420
指内的对象是可以负责负的内形的

31:14.420 --> 31:16.420
它并不影响真实的执行

31:16.420 --> 31:18.420
并不影响真实的执行

31:18.420 --> 31:20.420
好 那么接下来

31:20.420 --> 31:22.420
我们再来看一个情况

31:22.420 --> 31:24.420
这里的情况比较多

31:24.420 --> 31:26.420
好像规则很复杂的样子

31:26.420 --> 31:28.420
但是一切都是符合逻辑的

31:28.420 --> 31:30.420
你大家不用去使劲背

31:30.420 --> 31:32.420
应该把他的逻辑理解清楚

31:32.420 --> 31:34.420
比方说玩家坦克里边

31:34.420 --> 31:36.420
玩家坦克里边比方说

31:36.420 --> 31:38.420
有这么一个属性

31:38.420 --> 31:40.420
还剩多少条命

31:40.420 --> 31:42.420
我们

31:42.420 --> 31:44.420
坦克

31:44.420 --> 31:46.420
坦克不能使的过后又可以出现

31:46.420 --> 31:48.420
出现这次就减少一条命

31:48.420 --> 31:50.420
knives

31:50.420 --> 31:52.420
knives

31:52.420 --> 31:54.420
是这样写吧

31:54.420 --> 31:56.420
knives

31:56.420 --> 31:58.420
好 多好 就是个knives吧

31:58.420 --> 32:00.420
表示一个数字

32:00.420 --> 32:02.420
比方说默认有五条命

32:02.420 --> 32:04.420
那么大家看一下

32:04.420 --> 32:06.420
我们不是说要去做这个游戏

32:06.420 --> 32:08.420
只是说来解释这个

32:08.420 --> 32:10.420
继承的这种关系

32:10.420 --> 32:12.420
我这个变量P

32:12.420 --> 32:14.420
能不能使用

32:14.420 --> 32:16.420
你看你已经提示你的

32:16.420 --> 32:18.420
能不能使用knives呢

32:18.420 --> 32:20.420
能不能使用knives

32:20.420 --> 32:22.420
要发现使用不了

32:22.420 --> 32:24.420
为啥使用不了

32:24.420 --> 32:26.420
逻辑 这里面全是逻辑

32:26.420 --> 32:28.420
它不是故意来围难你

32:28.420 --> 32:30.420
为什么使用不了

32:30.420 --> 32:32.420
你这个变量P

32:32.420 --> 32:34.420
这个东西

32:34.420 --> 32:36.420
你跟它约束的内情是啥

32:36.420 --> 32:38.420
是坦克

32:38.420 --> 32:40.420
于是它里面只能使用

32:40.420 --> 32:42.420
坦克里面贡献的东西

32:42.420 --> 32:44.420
它只能使用

32:44.420 --> 32:46.420
坦克里面贡献的东西

32:46.420 --> 32:48.420
坦克不是贡献的东西

32:48.420 --> 32:50.420
它就不敢用

32:50.420 --> 32:52.420
为什么不敢用

32:52.420 --> 32:54.420
因为它不能确定

32:54.420 --> 32:56.420
你跟它负责的一定是

32:56.420 --> 32:58.420
几方坦克

32:58.420 --> 33:00.420
比如说 这里是个变量

33:00.420 --> 33:02.420
你写着写着 改了它的值

33:02.420 --> 33:04.420
丢了一个animate tank

33:04.420 --> 33:06.420
那这里面有没有knives

33:06.420 --> 33:08.420
对不对 是不是没有knives

33:08.420 --> 33:10.420
那你这样做是不是不安全的

33:10.420 --> 33:12.420
对不对 是不是不安全

33:12.420 --> 33:14.420
所以说呢

33:14.420 --> 33:16.420
这里的内情检查是这样处理的

33:16.420 --> 33:18.420
你既然说了

33:18.420 --> 33:20.420
它是一个通用的坦克

33:20.420 --> 33:22.420
那么它里面可以保存玩家坦克

33:22.420 --> 33:24.420
也可以保存敌方坦克

33:24.420 --> 33:26.420
那我只能使用

33:26.420 --> 33:28.420
有的东西

33:28.420 --> 33:30.420
特殊的东西我不敢用

33:30.420 --> 33:32.420
因为万一里变了怎么办

33:32.420 --> 33:34.420
万一发生了莫名其妙的事

33:34.420 --> 33:36.420
或者说这个东西你是从一个函数

33:36.420 --> 33:38.420
雕用返回的一个对象

33:38.420 --> 33:40.420
保存进来了

33:40.420 --> 33:42.420
我怎么知道你到底是一个什么坦克呢

33:42.420 --> 33:44.420
我不知道

33:44.420 --> 33:46.420
因此它不敢让你去使用特殊的东西

33:46.420 --> 33:48.420
但是使用共同的东西是安全的

33:48.420 --> 33:50.420
无论你是啥坦克

33:50.420 --> 33:52.420
只要你是坦克 一定有name

33:52.420 --> 33:54.420
一定有 say hello

33:54.420 --> 33:56.420
现在的内情让它自动推倒

33:56.420 --> 33:58.420
或者说你自己手中给它内行

33:58.420 --> 34:00.420
复制为player tank

34:00.420 --> 34:02.420
给它复制为这个内行

34:02.420 --> 34:04.420
那么能不能使用life

34:04.420 --> 34:06.420
肯定是可以的 已经确定了

34:06.420 --> 34:08.420
你是一个几方坦克了

34:08.420 --> 34:10.420
所以说允许你这样去使用

34:10.420 --> 34:12.420
这样子做是安全的

34:12.420 --> 34:14.420
把这个东西一定要理解清楚

34:14.420 --> 34:16.420
一定要理解清楚

34:16.420 --> 34:18.420
好 如果刚才是这种情况

34:18.420 --> 34:20.420
刚才如果是这种情况

34:20.420 --> 34:22.420
那么如果我确实

34:22.420 --> 34:24.420
使用life这个属性

34:24.420 --> 34:26.420
又怎么办呢

34:26.420 --> 34:28.420
你应该进行判断

34:28.420 --> 34:30.420
判断它是不是一个玩家坦克

34:30.420 --> 34:32.420
因为只有玩家坦克

34:32.420 --> 34:34.420
才有这个属性

34:34.420 --> 34:36.420
因此这里要判断

34:36.420 --> 34:38.420
怎么判断 变亮屁

34:38.420 --> 34:40.420
instance

34:40.420 --> 34:42.420
应该都是学习过的 对吧

34:42.420 --> 34:44.420
跟介石是一样的

34:44.420 --> 34:46.420
是不是某一个内行

34:46.420 --> 34:48.420
player tank

34:48.420 --> 34:50.420
其实这个判断是啥呢

34:50.420 --> 34:52.420
不过呢 这里呢

34:52.420 --> 34:54.420
我们不打算去讲那么多关于

34:54.420 --> 34:56.420
一些原性电的东西

34:56.420 --> 34:58.420
而是从语异上来了解

34:58.420 --> 35:00.420
这个instance

35:00.420 --> 35:02.420
你可以看作是啥呢

35:02.420 --> 35:04.420
看作是三个字

35:04.420 --> 35:06.420
是不是

35:06.420 --> 35:08.420
这个变亮是不是一个玩家坦克

35:08.420 --> 35:10.420
如果是的话

35:10.420 --> 35:12.420
你看

35:12.420 --> 35:14.420
life自动就出来了

35:14.420 --> 35:16.420
为什么能出来

35:16.420 --> 35:18.420
这个地方有个内行保护

35:18.420 --> 35:20.420
就是说他当他满足一定条件的时候

35:20.420 --> 35:22.420
他就能够把他的内行

35:22.420 --> 35:24.420
确定化

35:24.420 --> 35:26.420
以这样的判断 如果这个条件满足

35:26.420 --> 35:28.420
到了第18号代码

35:28.420 --> 35:30.420
他的内行一定确定了

35:30.420 --> 35:32.420
确定就是玩家坦克了

35:32.420 --> 35:34.420
因此这里

35:34.420 --> 35:36.420
它就把它当成了player tank

35:36.420 --> 35:38.420
但是在衣服外面

35:38.420 --> 35:40.420
它这个屁呢 就是个tank

35:40.420 --> 35:42.420
它非常智能的

35:42.420 --> 35:44.420
所以说我们可以通过这种方式

35:44.420 --> 35:46.420
来判断

35:46.420 --> 35:48.420
屁是不是player tank

35:48.420 --> 35:50.420
好 我们这里讲到了这么一个点

35:50.420 --> 35:52.420
就是说

35:52.420 --> 35:54.420
纸内的对象可以复制给负累的内向

35:54.420 --> 35:56.420
其实在这里

35:56.420 --> 35:58.420
在面向对象中 这里有一种教法

35:58.420 --> 36:00.420
面向对象中

36:04.420 --> 36:06.420
这种现象

36:06.420 --> 36:08.420
叫做理事替换原则

36:08.420 --> 36:10.420
理事替换原则

36:12.420 --> 36:14.420
理事是一个人

36:14.420 --> 36:16.420
他提出了这么一个原则

36:16.420 --> 36:18.420
他觉得这个原则是符合逻辑的

36:18.420 --> 36:20.420
是合理的

36:20.420 --> 36:22.420
就是纸内的对象始终可以复制给负累

36:22.420 --> 36:24.420
在tx中使用的是压制变形的话

36:24.420 --> 36:26.420
那当然没有任何问题

36:26.420 --> 36:28.420
这是关于内雄匹配这一块

36:28.420 --> 36:30.420
当然呢 我们刚才也用到了这一点

36:30.420 --> 36:32.420
就是有的时候 它是一个负累的内雄

36:32.420 --> 36:34.420
我们需要判断它具体的内雄的时候

36:34.420 --> 36:36.420
具体的纸内内雄的时候

36:36.420 --> 36:38.420
可以使用instance of

36:38.420 --> 36:40.420
instance of来判断

36:40.420 --> 36:42.420
好 我们这里输出一下吧

36:42.420 --> 36:44.420
console log

36:44.420 --> 36:46.420
pdlnf

36:46.420 --> 36:48.420
保存

36:48.420 --> 36:50.420
看一下 读条密

36:50.420 --> 36:52.420
那如果它是一个敌方坦克呢

36:52.420 --> 36:54.420
你看 它是一个敌方坦克

36:54.420 --> 36:56.420
因为这个判断就很安全

36:56.420 --> 36:58.420
它就不会爆错

36:58.420 --> 37:00.420
是敌方坦克的话 你看

37:00.420 --> 37:02.420
它就没有进不了那个判断

37:02.420 --> 37:04.420
所以说有的时候呢

37:04.420 --> 37:06.420
如果需要

37:06.420 --> 37:08.420
判断一个

37:08.420 --> 37:10.420
数据的

37:10.420 --> 37:12.420
具体内雄

37:12.420 --> 37:14.420
具体的具体纸内内雄

37:14.420 --> 37:16.420
它是一个负累的内雄

37:16.420 --> 37:18.420
跟它约束为一个负累的内雄

37:18.420 --> 37:20.420
需要判断一下它是不是具体的

37:20.420 --> 37:22.420
某个纸内内雄

37:22.420 --> 37:24.420
具体的内雄是啥

37:24.420 --> 37:26.420
那么这个时候呢 可以使用

37:26.420 --> 37:28.420
instance of

37:28.420 --> 37:30.420
可以使用这个关键字来进行判断

37:30.420 --> 37:32.420
好 这是关于

37:32.420 --> 37:34.420
内雄匹配这一块的知识

37:34.420 --> 37:36.420
好 下一个

37:36.420 --> 37:38.420
基层这里呢 还有一个知识

37:38.420 --> 37:40.420
是在咱们基础部分

37:40.420 --> 37:42.420
就TS的基础部分的时候呢

37:42.420 --> 37:44.420
有个缺失的一个点

37:44.420 --> 37:46.420
这里把补充完整

37:46.420 --> 37:48.420
protected

37:48.420 --> 37:50.420
就是这是一个修饰服

37:50.420 --> 37:52.420
修饰服

37:52.420 --> 37:54.420
我们之前呢 学过了一些

37:54.420 --> 37:56.420
内里面的修饰服对吧

37:56.420 --> 37:58.420
哪些修饰服呢

37:58.420 --> 38:00.420
read only

38:00.420 --> 38:02.420
这个表示指读修饰服

38:02.420 --> 38:04.420
指读修饰服

38:04.420 --> 38:06.420
然后呢

38:06.420 --> 38:08.420
这一些全线

38:08.420 --> 38:10.420
访问全线修饰服

38:10.420 --> 38:12.420
访问全线修饰服

38:12.420 --> 38:14.420
有三个

38:14.420 --> 38:16.420
private表示私有的

38:16.420 --> 38:18.420
只能在内里边

38:18.420 --> 38:20.420
可以访问的成员

38:20.420 --> 38:22.420
public表示公共的

38:22.420 --> 38:24.420
只能在所有地方都可以访问的成员

38:24.420 --> 38:26.420
还有一个修饰服呢

38:26.420 --> 38:28.420
叫做protected

38:28.420 --> 38:30.420
这叫做受保护的

38:30.420 --> 38:32.420
protected

38:32.420 --> 38:34.420
它是受保护的

38:34.420 --> 38:36.420
成员

38:36.420 --> 38:38.420
无论你是修饰方法也好

38:38.420 --> 38:40.420
还是修饰

38:40.420 --> 38:42.420
属性也好

38:42.420 --> 38:44.420
都表示

38:44.420 --> 38:46.420
成员都可以

38:46.420 --> 38:48.420
那么这个成员呢

38:48.420 --> 38:50.420
被protected修饰的成员呢

38:50.420 --> 38:52.420
只能在自身

38:52.420 --> 38:54.420
和指内中

38:54.420 --> 38:56.420
访问

38:56.420 --> 38:58.420
只能在自身这个内里边

38:58.420 --> 39:00.420
或者是这个内的指内里边可以访问

39:00.420 --> 39:02.420
外边的访问不了

39:02.420 --> 39:04.420
举个例子吧

39:04.420 --> 39:06.420
比如说这里

39:06.420 --> 39:08.420
坦克这里

39:08.420 --> 39:10.420
我如果

39:10.420 --> 39:12.420
如果给这个name

39:12.420 --> 39:14.420
给这个name

39:14.420 --> 39:16.420
设置了一个

39:16.420 --> 39:18.420
访问修饰服

39:18.420 --> 39:20.420
设置了这个访问修饰服

39:20.420 --> 39:22.420
那么你看一下

39:22.420 --> 39:24.420
咱们在外边的时候还能访问吗

39:24.420 --> 39:26.420
这里

39:26.420 --> 39:28.420
你看外边是不是访问不了了

39:28.420 --> 39:30.420
访问不了这个东西了

39:30.420 --> 39:32.420
另外呢

39:32.420 --> 39:34.420
这里

39:34.420 --> 39:36.420
这里为什么能访问

39:36.420 --> 39:38.420
指内里边为什么能访问

39:38.420 --> 39:40.420
因为指内给它重写的又把它公开了

39:40.420 --> 39:42.420
你看访问修饰服没有写

39:42.420 --> 39:44.420
又把这个成员公开了

39:44.420 --> 39:46.420
所以说这里指内可以访问了

39:46.420 --> 39:48.420
如果缺紧以为它的指内的话

39:48.420 --> 39:50.420
它就可以访问了

39:50.420 --> 39:52.420
因为它这里把它公开了

39:52.420 --> 39:54.420
通常一般情况下

39:54.420 --> 39:56.420
不会去分改它的访问修饰服

39:56.420 --> 39:58.420
所以访问修饰服还是把它写上

39:58.420 --> 40:00.420
然后呢我们就发现

40:00.420 --> 40:02.420
这个成员外边的是访问不了的

40:02.420 --> 40:04.420
外边是访问不了的

40:04.420 --> 40:06.420
只有在内自身里边

40:06.420 --> 40:08.420
你看自身里边可以访问

40:08.420 --> 40:10.420
指内里边怎么能访问呢

40:10.420 --> 40:12.420
我们试一下吧

40:12.420 --> 40:14.420
假设我们不写这个

40:14.420 --> 40:16.420
不写这个

40:16.420 --> 40:18.420
试一下

40:18.420 --> 40:20.420
你看

40:20.420 --> 40:22.420
指内可以访问

40:22.420 --> 40:24.420
腹内可以访问

40:24.420 --> 40:26.420
指内也可以访问

40:26.420 --> 40:28.420
所以说这是这个

40:28.420 --> 40:30.420
访问修饰服的作用

40:30.420 --> 40:32.420
当然我们现在这个例子呢

40:32.420 --> 40:34.420
没有举到一个合适的例子

40:34.420 --> 40:36.420
不过这个应该很好理解

40:36.420 --> 40:38.420
就是在控制访问权限的

40:38.420 --> 40:40.420
一说你就明白了

40:40.420 --> 40:42.420
自身和指内可以访问

40:42.420 --> 40:44.420
然后这个访问修饰服跟其他修饰服

40:44.420 --> 40:46.420
一样

40:46.420 --> 40:48.420
它在编译结果里边

40:48.420 --> 40:50.420
怎么样

40:50.420 --> 40:52.420
编译结果里边

40:52.420 --> 40:54.420
有没有这个访问修饰服呢

40:54.420 --> 40:56.420
NPM装

40:56.420 --> 40:58.420
标的

40:58.420 --> 41:00.420
看一下吧

41:00.420 --> 41:03.740
编译完成

41:03.740 --> 41:05.740
看一下这里边

41:05.740 --> 41:07.740
访问修饰服全部没了

41:07.740 --> 41:09.740
因为这个访问修饰服是

41:09.740 --> 41:11.740
TS的东西

41:11.740 --> 41:13.740
是TS的东西

41:13.740 --> 41:15.740
因此在介石里面

41:15.740 --> 41:19.180
自然没有

41:19.180 --> 41:21.180
然后呢

41:21.180 --> 41:23.180
我们再来看一下

41:23.180 --> 41:25.180
我们刚才好像我忘讲了一个东西

41:25.180 --> 41:27.180
就是在

41:27.180 --> 41:29.180
重写的时候

41:29.180 --> 41:31.180
重写的时候呢还有这么一个

41:31.180 --> 41:33.180
我想我忘了讲了我这里想起来的

41:33.180 --> 41:35.180
还有SUPER关键字

41:35.180 --> 41:37.180
关键字

41:37.180 --> 41:39.180
在指内中

41:39.180 --> 41:41.180
在指内中

41:41.180 --> 41:43.180
特别是函数里边

41:43.180 --> 41:45.180
指内的方法中

41:45.180 --> 41:47.180
或者是构造函数里边

41:47.180 --> 41:49.180
因为这个SUPER呢我们在构造函数里边

41:49.180 --> 41:51.180
经常在写对吧很少在方法里边写

41:51.180 --> 41:53.180
表示的是负累的含义对不对

41:53.180 --> 41:55.180
在指内的方法中

41:55.180 --> 41:57.180
可以使用SUPER

41:57.180 --> 41:59.180
关键字

41:59.180 --> 42:01.180
读取负累

42:01.180 --> 42:03.180
资源

42:03.180 --> 42:05.180
读取负累成员

42:05.180 --> 42:07.180
好咱们来试一下

42:07.180 --> 42:09.180
这个是什么意思

42:09.180 --> 42:11.180
这里呢我把它

42:11.180 --> 42:13.180
稍微的改动一下

42:13.180 --> 42:15.180
对

42:15.180 --> 42:17.180
放小一点啊

42:17.180 --> 42:19.180
文字太大了看着

42:19.180 --> 42:21.180
你看着牢火我看着牢火

42:21.180 --> 42:23.180
好这里呢敌方坦克

42:23.180 --> 42:25.180
我们扔这吧敌方坦克扔这

42:25.180 --> 42:27.180
然后几方坦克这里

42:27.180 --> 42:29.180
我们在这里呢在TES里边

42:29.180 --> 42:31.180
比方TES这个含书啊

42:31.180 --> 42:33.180
随便举个例子

42:33.180 --> 42:35.180
TES这个含书呢我要做成跟这个shallow

42:35.180 --> 42:37.180
含书一样的效果

42:37.180 --> 42:39.180
但是呢我这里不想写重新去写一次shallow了

42:39.180 --> 42:41.180
不想重新去写一次shallow

42:41.180 --> 42:43.180
那么怎么办呢我在这里就可以调用

42:43.180 --> 42:45.180
或者是我在运行的过程中

42:45.180 --> 42:47.180
我需要去调用一下啊

42:47.180 --> 42:49.180
某一个负累的某一个含书

42:49.180 --> 42:51.180
我们这里可以调用shallow

42:51.180 --> 42:53.180
调用负累的含书

42:53.180 --> 42:55.180
调用负累的含书

42:55.180 --> 42:57.180
好然后呢

42:57.180 --> 42:59.180
这里里边

42:59.180 --> 43:01.180
保存一下啊

43:01.180 --> 43:03.180
我们看一下运行结果

43:03.180 --> 43:05.180
NPM装

43:05.180 --> 43:08.550
我们应该调用TES对吧

43:08.550 --> 43:10.550
应该调用TES

43:10.550 --> 43:12.550
TES是player的

43:12.550 --> 43:14.550
看一下

43:14.550 --> 43:16.550
去掉

43:16.550 --> 43:18.550
这里写成player tank

43:18.550 --> 43:21.860
保存一下

43:21.860 --> 43:23.860
我们看到他就输出了我是一个坦克

43:23.860 --> 43:25.860
就相当于是调用了什么

43:25.860 --> 43:27.860
调用了shallow了对不对

43:27.860 --> 43:29.860
调用了shallow了

43:29.860 --> 43:31.860
好有些同学说为什么输出的是我是一个坦克

43:31.860 --> 43:33.860
为什么输出的不是

43:33.860 --> 43:35.860
几方坦克呢

43:35.860 --> 43:37.860
因为我这里把这个重写去掉了

43:37.860 --> 43:39.860
我要重写加上吧

43:39.860 --> 43:41.860
我要重写加上

43:41.860 --> 43:43.860
几方坦克

43:43.860 --> 43:45.860
玩家坦克

43:45.860 --> 43:47.860
保存

43:47.860 --> 43:49.860
看一下

43:49.860 --> 43:51.860
这是super

43:51.860 --> 43:53.860
OK这里有些同学问了

43:53.860 --> 43:55.860
就说

43:55.860 --> 43:57.860
你这个地方写super可以

43:57.860 --> 43:59.860
能不能写z是呢

43:59.860 --> 44:01.860
能不能写z是

44:01.860 --> 44:03.860
那么可不可以写z是你想想

44:03.860 --> 44:05.860
这个也行

44:05.860 --> 44:07.860
因为这是负累的东西

44:07.860 --> 44:09.860
我爸爸的东西肯定是我的

44:09.860 --> 44:11.860
肯定毫无疑问

44:11.860 --> 44:13.860
我爸爸的东西也是我的

44:13.860 --> 44:15.860
所以说我可以写z

44:15.860 --> 44:17.860
两者是一样的

44:17.860 --> 44:19.860
但是有些情况下

44:19.860 --> 44:21.860
他们是有区别的

44:21.860 --> 44:23.860
什么情况下的

44:23.860 --> 44:25.860
这种情况

44:25.860 --> 44:27.860
如果紫内

44:27.860 --> 44:29.860
我的爸爸有了shallow

44:29.860 --> 44:31.860
我又去覆盖了紫内的函数

44:31.860 --> 44:33.860
我也有个shallow

44:33.860 --> 44:35.860
我也有个shallow

44:35.860 --> 44:37.860
然后我这里面输出个啥呢

44:37.860 --> 44:39.860
就随便输出吧

44:39.860 --> 44:41.860
啦啦啦

44:41.860 --> 44:43.860
这是我自己的shallow函数

44:43.860 --> 44:45.860
我覆盖了负累的

44:45.860 --> 44:47.860
那么这个时候z和super就有区别了

44:47.860 --> 44:49.860
比方z去调用shallow

44:49.860 --> 44:51.860
和super去调用shallow

44:51.860 --> 44:53.860
那么调用的函数是不一样的

44:53.860 --> 44:55.860
是不一样的

44:55.860 --> 44:57.860
这个super

44:57.860 --> 44:59.860
通过super是调用shallow

44:59.860 --> 45:01.860
调用的是负累的函数

45:01.860 --> 45:03.860
调用的是负累的函数

45:03.860 --> 45:05.860
而通过z去调用的shallow

45:05.860 --> 45:07.860
调用的是紫内的我自己的这个函数

45:07.860 --> 45:09.860
只有在发生这种重现的时候

45:09.860 --> 45:11.860
才有

45:11.860 --> 45:13.860
他们才有差别

45:13.860 --> 45:15.860
如果这里没有重写的话

45:15.860 --> 45:17.860
两个是一样的

45:17.860 --> 45:19.860
这应该很简单吧

45:19.860 --> 45:21.860
我自己和我爸爸的

45:21.860 --> 45:23.860
因为现在有两个东西

45:23.860 --> 45:25.860
之前我这里没有

45:25.860 --> 45:27.860
我爸爸的就是我的

45:27.860 --> 45:29.860
我们再看一下这种情况

45:29.860 --> 45:31.860
两个是不一样的

45:31.860 --> 45:33.860
这里关于super的关键值

45:33.860 --> 45:35.860
我想起来把它补充一下

45:35.860 --> 45:37.860
ok 其实关于

45:37.860 --> 45:39.860
继承这一块

45:39.860 --> 45:41.860
差不多有这么一规则了

45:41.860 --> 45:43.860
最后我们再看一下面向对象里面的

45:43.860 --> 45:45.860
继承的两个特征

45:45.860 --> 45:47.860
叫做

45:47.860 --> 45:49.860
继承的传递性

45:49.860 --> 45:51.860
和单根性

45:51.860 --> 45:53.860
继承的传递性和单根性

45:53.860 --> 45:55.860
我们反过来说吧

45:55.860 --> 45:57.860
单根性好理解一点

45:57.860 --> 45:59.860
单根性和传递性

45:59.860 --> 46:01.860
好 首先说单根性

46:01.860 --> 46:03.860
这里很简单

46:03.860 --> 46:05.860
就是

46:05.860 --> 46:07.860
每个人内

46:07.860 --> 46:09.860
最多只能

46:09.860 --> 46:11.860
拥有

46:11.860 --> 46:13.860
一个附内

46:13.860 --> 46:15.860
就是单根性

46:15.860 --> 46:17.860
你只能有一个附型

46:17.860 --> 46:19.860
怎么能有多个附型呢

46:19.860 --> 46:21.860
哪里的规律有问题啊

46:21.860 --> 46:23.860
不能说

46:23.860 --> 46:25.860
我的爸爸

46:25.860 --> 46:27.860
不能说我的爸爸门

46:27.860 --> 46:29.860
这个说法是有问题的

46:29.860 --> 46:31.860
那比方说像这里

46:31.860 --> 46:33.860
player tank

46:33.860 --> 46:35.860
继承的tank

46:35.860 --> 46:37.860
class A

46:37.860 --> 46:39.860
他又去继承A

46:39.860 --> 46:41.860
能继承吗

46:41.860 --> 46:43.860
加个A 能继承吗

46:43.860 --> 46:45.860
不行 内只能继承一个内

46:45.860 --> 46:47.860
就只能扩展一个内

46:47.860 --> 46:49.860
只能去派承一个内

46:49.860 --> 46:51.860
因此这是继承的单根性

46:51.860 --> 46:53.860
关于这个特性

46:53.860 --> 46:55.860
其实很多年下来

46:55.860 --> 46:57.860
一直要讨论

46:57.860 --> 46:59.860
有的时候

46:59.860 --> 47:01.860
确实感觉到我要继承

47:01.860 --> 47:03.860
多个更舒服一点

47:03.860 --> 47:05.860
就是我这个对象

47:05.860 --> 47:07.860
有另外几个内的

47:07.860 --> 47:09.860
特征我都要

47:09.860 --> 47:11.860
可能写代码的时候要方便一点

47:11.860 --> 47:13.860
但是这么多年下来

47:13.860 --> 47:15.860
一直以来

47:15.860 --> 47:17.860
都没有打破这个单根性

47:17.860 --> 47:19.860
为什么呢

47:19.860 --> 47:21.860
因为反复的讨论结果就是

47:21.860 --> 47:23.860
如果你打破了这个单根性

47:23.860 --> 47:25.860
逻辑就有问题了

47:25.860 --> 47:27.860
就有逻辑的问题

47:27.860 --> 47:29.860
因为我们现实世界分类的话

47:29.860 --> 47:31.860
是一个塑状的结构

47:31.860 --> 47:33.860
不会有交叉

47:33.860 --> 47:35.860
因此你这样子来处理的话

47:35.860 --> 47:37.860
就会有逻辑的问题

47:37.860 --> 47:39.860
所以说一直以来

47:39.860 --> 47:41.860
咱们系统里面都是保持这个单根性

47:41.860 --> 47:43.860
以更加简洁的方式

47:43.860 --> 47:45.860
来描述整个内的结构

47:45.860 --> 47:47.860
内之间的关系

47:47.860 --> 47:49.860
好 这是关于单根性

47:49.860 --> 47:51.860
那如果你在GS里面要实现

47:51.860 --> 47:53.860
一个对象里面

47:53.860 --> 47:55.860
有很多其他对象的特征

47:55.860 --> 47:57.860
混入了解一下

47:57.860 --> 47:59.860
MX了解一下

47:59.860 --> 48:01.860
GS里面实现这些东西是非常方便的

48:01.860 --> 48:03.860
也不需要去

48:03.860 --> 48:05.860
一拓继承去完成

48:05.860 --> 48:07.860
当我们用面向对象的话

48:07.860 --> 48:09.860
就要严格去遵守

48:09.860 --> 48:11.860
面向对象的这些规定

48:11.860 --> 48:13.860
好 另外一个是传递型

48:13.860 --> 48:15.860
传递型

48:15.860 --> 48:17.860
这个很好理解

48:17.860 --> 48:21.860
如果A是B的附类

48:21.860 --> 48:27.860
并且B是C的附类

48:27.860 --> 48:31.860
可以认为A

48:31.860 --> 48:35.860
也是C的附类

48:35.860 --> 48:37.860
相当于是

48:37.860 --> 48:39.860
财产的

48:39.860 --> 48:41.860
就是传家宝的遗传

48:41.860 --> 48:43.860
传家宝的一代一代传下去

48:43.860 --> 48:45.860
A里面有的东西

48:45.860 --> 48:47.860
B里面也有

48:47.860 --> 48:49.860
那么B里面有的东西

48:49.860 --> 48:51.860
C里面也有

48:51.860 --> 48:53.860
由于B已经继承了A

48:53.860 --> 48:55.860
所以说B里面的东西

48:55.860 --> 48:57.860
因此我们也可以说

48:57.860 --> 48:59.860
A也是C的附类

48:59.860 --> 49:01.860
但这不是多继承

49:01.860 --> 49:03.860
还是单纯性

49:03.860 --> 49:05.860
它只能继承一个附类

49:05.860 --> 49:07.860
你可以认为A是C的爷爷

49:07.860 --> 49:09.860
只不过我们的教法上

49:09.860 --> 49:11.860
也可以把它叫做A

49:11.860 --> 49:13.860
也可以认为是谁的附类

49:13.860 --> 49:15.860
只是间接性

49:15.860 --> 49:17.860
好 这比方在这里

49:17.860 --> 49:19.860
有玩家坦克

49:19.860 --> 49:21.860
有敌方坦克

49:21.860 --> 49:23.860
敌方坦克里面

49:23.860 --> 49:25.860
有那个坦克的

49:25.860 --> 49:27.860
就是要打多少次

49:27.860 --> 49:29.860
这个坦克才能爆炸

49:29.860 --> 49:31.860
你看一下敌方坦克

49:31.860 --> 49:33.860
敌方坦克有个特点

49:33.860 --> 49:35.860
有些坦克打几次才能爆炸

49:35.860 --> 49:37.860
坦克有什么动作

49:37.860 --> 49:39.860
打几次

49:39.860 --> 49:41.860
有些坦克只能打一次

49:41.860 --> 49:43.860
所以说这个敌方坦克

49:43.860 --> 49:45.860
有这么一个属相

49:45.860 --> 49:47.860
生命值

49:49.860 --> 49:51.860
Health

49:51.860 --> 49:53.860
Number

49:53.860 --> 49:55.860
默认为一

49:55.860 --> 49:57.860
默认为打一次就会爆炸

49:57.860 --> 49:59.860
那比方说

49:59.860 --> 50:01.860
有一个敌方坦克

50:01.860 --> 50:03.860
名叫Boss

50:03.860 --> 50:05.860
Boss Tank

50:05.860 --> 50:07.860
它也是个敌方坦克

50:07.860 --> 50:09.860
它继承至敌方坦克

50:09.860 --> 50:11.860
Animate Tank

50:11.860 --> 50:13.860
它继承至敌方坦克

50:13.860 --> 50:15.860
那么我就可以把Health重写

50:15.860 --> 50:17.860
重写为几呢 重写为三

50:17.860 --> 50:19.860
它要打三次才能爆炸

50:19.860 --> 50:21.860
可以做一些其他的事情

50:21.860 --> 50:23.860
那么我们来看一下这个继承关系

50:23.860 --> 50:25.860
那么现在这个继承关系

50:25.860 --> 50:27.860
变成了这个样子

50:27.860 --> 50:29.860
我之前不是画了一个东西吗

50:29.860 --> 50:31.860
变成了这个样子

50:31.860 --> 50:33.860
Animate Tank

50:33.860 --> 50:37.750
然后这里

50:37.750 --> 50:39.750
这样子

50:39.750 --> 50:41.750
然后Boss Tank

50:41.750 --> 50:43.750
我们的Boss

50:43.750 --> 50:45.750
它也是一个敌方坦克

50:45.750 --> 50:47.750
来看一下

50:47.750 --> 50:49.750
变成这么一种继承关系

50:49.750 --> 50:51.750
A

50:51.750 --> 50:53.750
B

50:53.750 --> 50:55.750
SB的附类

50:55.750 --> 50:57.750
B是C的附类

50:57.750 --> 50:59.750
那么C里边拥有什么东西

50:59.750 --> 51:01.750
拥有B的东西

51:01.750 --> 51:03.750
也拥有A的东西

51:03.750 --> 51:07.130
所以说我们在写代码的时候

51:07.130 --> 51:09.130
就会发现

51:09.130 --> 51:11.130
我们去溜一个Boss Tank

51:11.130 --> 51:13.130
你会发现

51:13.130 --> 51:15.130
它这里边有

51:15.130 --> 51:17.130
Animate Tank

51:17.130 --> 51:19.130
也有Animate Tank

51:19.130 --> 51:21.130
这是非常好理解的

51:21.130 --> 51:23.130
OK 这是关于

51:23.130 --> 51:25.130
继承这一块的知识

51:25.130 --> 51:27.130
就讲到这了

51:27.130 --> 51:29.130
下去好好想一想

51:29.130 --> 51:31.130
因为这些东西我讲的时候

51:31.130 --> 51:33.130
可能跟以前

51:33.130 --> 51:35.130
因为继承的东西跟以前介石一样的

51:35.130 --> 51:37.130
它写法上是一样的

51:37.130 --> 51:39.130
没多少区别

51:39.130 --> 51:41.130
只是现在多了一些访问修饰服而已

51:41.130 --> 51:43.130
重写了跟以前介石也是一样的概念

51:43.130 --> 51:45.130
只不过现在我讲的过程中

51:45.130 --> 51:47.130
更多的是从面向对象的

51:47.130 --> 51:49.130
含义的角度去讲这个东西

51:49.130 --> 51:51.130
因此会造成

51:51.130 --> 51:53.130
有些同学可能不太适应

51:53.130 --> 51:55.130
不适应的同学多去想一想

51:55.130 --> 51:57.130
多去想想这个逻辑含义

51:57.130 --> 51:59.130
然后下来去写这么一个内结构

51:59.130 --> 52:01.130
不用去运行运行都不用运行

52:01.130 --> 52:03.130
你写一下这个结构

52:03.130 --> 52:05.130
它写出来你是怎么样去设计这个结构的

52:05.130 --> 52:07.130
怎么样去设计这个继承关系的

52:07.130 --> 52:09.130
去多去想一想

52:09.130 --> 52:11.130
OK 那么咱们这期课就到这了

