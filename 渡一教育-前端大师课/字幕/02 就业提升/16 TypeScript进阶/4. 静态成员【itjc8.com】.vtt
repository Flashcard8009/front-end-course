WEBVTT

00:01.330 --> 00:04.330
大家好 我是独一教育 微博前掌讲师 元静

00:04.330 --> 00:07.330
好 咱们接着来聊 接着来聊

00:07.330 --> 00:11.330
这节课呢 我们继续来聊面向对象的一关相关知识

00:11.330 --> 00:15.330
这节课呢 咱们聊一聊这个概念 叫静态成员

00:15.330 --> 00:21.330
静态成员 其实这个东西不是TS里面新的东西了

00:21.330 --> 00:23.330
是以前GS本身就有的

00:23.330 --> 00:25.330
GS里面本身就有

00:25.330 --> 00:28.330
所以说有些同学应该是至少听说过

00:28.330 --> 00:31.330
如果你没有听说过的话 因为没有关系

00:31.330 --> 00:35.330
我这一回会详细的讲 什么叫静态成员呢

00:35.330 --> 00:38.330
我先看这个问题 什么是静态成员

00:38.330 --> 00:52.330
静态成员是指内附着在内上的成员

00:52.330 --> 00:56.330
成员是什么 成员就包含了属性 包含了方法

00:56.330 --> 01:01.330
附着在内上的成员 如果是在GS里面

01:01.330 --> 01:09.330
应该就这么说 属于某个构造寒树的成员

01:09.330 --> 01:13.330
我们知道构造寒树用来做什么呢 用来创建对象的

01:13.330 --> 01:17.330
但是有些成员他不是附着在对象上面的

01:17.330 --> 01:20.330
他不是属于对象的 是属于构造寒树的

01:20.330 --> 01:22.330
属于某个构造寒树的成员

01:22.330 --> 01:27.330
这种情况 其实大家应该是见过的

01:27.330 --> 01:33.330
比方说 这个Lumber

01:33.330 --> 01:36.330
这个玩意其实就是一个构造寒树

01:36.330 --> 01:38.330
它就是一个构造寒树

01:38.330 --> 01:41.330
我们平时写数字的时候

01:41.330 --> 01:45.330
我们知道可以直接书写一个数字

01:45.330 --> 01:50.330
也可以通过6一个Lumber来创建一个数字对象

01:50.330 --> 01:52.330
这两种方式都是可以的 对吧

01:52.330 --> 01:54.330
这些是基础的东西 不再展开讲了

01:54.330 --> 01:56.330
总之这是一个构造寒树

01:56.330 --> 02:00.330
我们以前的学习的成员

02:00.330 --> 02:03.330
很多的时候都是附属在对象上面的

02:03.330 --> 02:05.330
比方说n n点啥

02:05.330 --> 02:07.330
这里面是一些方法 一些成员

02:07.330 --> 02:11.330
但是有些成员他是属于构造寒树的

02:11.330 --> 02:13.330
比方说这个Lumber 他是个构造寒树

02:13.330 --> 02:15.330
那么Lumber的成员里边

02:15.330 --> 02:18.330
你看他其实也有一些成员

02:19.330 --> 02:22.330
比方说我们把判断意思n a n

02:22.330 --> 02:24.330
像这个寒树

02:24.330 --> 02:27.330
这个寒树他不是在数字上面

02:27.330 --> 02:29.330
你不能说n点意思n a n

02:29.330 --> 02:31.330
不对 对吧 不对

02:31.330 --> 02:33.330
应该是属于构造寒树的

02:33.330 --> 02:35.330
像有些成员他是属于构造寒树的

02:35.330 --> 02:37.330
这是个方法来判断某一个数字

02:37.330 --> 02:40.330
是不是n a n 是不是非数字

02:40.330 --> 02:43.330
或者这里面还有一个构造寒树的成员

02:43.330 --> 02:45.330
就是max value

02:46.330 --> 02:49.330
表示在GS中 数字的最大值

02:49.330 --> 02:52.330
我们最大可以取得多少位的数字

02:52.330 --> 02:54.330
书书看一下吧

02:54.330 --> 02:56.330
这个数字很大了

02:56.330 --> 02:59.330
它需要科学技术法才能表示出来

02:59.330 --> 03:01.330
我运行出来看一下

03:01.330 --> 03:03.330
大家会发现 这个数字已经很大了

03:03.330 --> 03:06.330
1.79 类似于1.79

03:06.330 --> 03:10.330
乘以多少乘以10的308次方

03:10.330 --> 03:12.330
它最大可以支持这么大的数字

03:12.330 --> 03:14.330
这就是静态成员

03:14.330 --> 03:17.330
静态成员它是附属在构造寒树上面的

03:17.330 --> 03:19.330
其实如果你把它当成一个类的话

03:19.330 --> 03:21.330
你把它当成一个类

03:21.330 --> 03:23.330
因为我们知道GS里面

03:23.330 --> 03:26.330
构造类的本质是什么

03:26.330 --> 03:29.330
类的本质是不是就是构造寒树

03:29.330 --> 03:31.330
它就是构造寒树

03:31.330 --> 03:33.330
所以说你完全可以把它当成

03:33.330 --> 03:35.330
附属在类上的成员

03:35.330 --> 03:37.330
就是静态成员

03:37.330 --> 03:39.330
它是通过类去调用的

03:39.330 --> 03:41.330
而不是通过对相去调用的

03:41.330 --> 03:43.330
像这种成员就是静态成员

03:43.330 --> 03:45.330
那么什么时候我们会

03:45.330 --> 03:47.330
使用到静态成员呢

03:47.330 --> 03:49.330
举个例子吧

03:49.330 --> 03:50.330
举个例子

03:50.330 --> 03:52.330
比方说

03:52.330 --> 03:54.330
比方说

03:54.330 --> 03:56.330
我们有这么一个类

03:56.330 --> 03:58.330
写下这么一个类

03:58.330 --> 03:59.330
优质

03:59.330 --> 04:00.330
一个用户类

04:00.330 --> 04:02.330
用户类里边有什么呢

04:02.330 --> 04:04.330
有罗锦ID

04:04.330 --> 04:05.330
就登录了帐号

04:05.330 --> 04:07.330
是一个支付串

04:08.330 --> 04:10.330
然后呢登录了密码

04:10.330 --> 04:12.330
罗锦Password

04:12.330 --> 04:14.330
登录的密码也是个支付串

04:14.330 --> 04:16.330
刚才我们用这种方式来写

04:16.330 --> 04:17.330
写构造寒树

04:17.330 --> 04:18.330
Shorter

04:18.330 --> 04:20.330
罗锦ID

04:20.330 --> 04:22.330
我们知道

04:22.330 --> 04:24.330
构造寒树就是属性的

04:24.330 --> 04:26.330
属性列表是可以用愚法堂

04:26.330 --> 04:28.330
写到这个位置的

04:28.330 --> 04:29.330
Public

04:29.330 --> 04:31.330
罗锦ID

04:31.330 --> 04:33.330
支付串

04:33.330 --> 04:35.330
下一个参数

04:35.330 --> 04:37.330
罗锦Password

04:37.330 --> 04:39.330
支付串

04:39.330 --> 04:41.330
假设有这么一个对相

04:41.330 --> 04:42.330
有这么一个类

04:42.330 --> 04:44.330
我当然可以去创造他的对相

04:44.330 --> 04:45.330
对吧

04:45.330 --> 04:47.330
那么这个创造对相的含义表示什么呢

04:47.330 --> 04:49.330
表示新建一个用户

04:49.330 --> 04:51.330
新建一个用户

04:51.330 --> 04:52.330
你看这样子

04:52.330 --> 04:54.330
新建一个用户

04:54.330 --> 04:56.330
创造这个构造寒树的

04:56.330 --> 04:58.330
创造对相的含义表示

04:58.330 --> 05:00.330
新建一个用户

05:00.330 --> 05:02.330
那可以把它理解成注册吧

05:02.330 --> 05:04.330
表示新注册一个用户

05:04.330 --> 05:05.330
新注册一个用户

05:05.330 --> 05:07.330
但是有的时候呢

05:07.330 --> 05:08.330
我要判断用户

05:08.330 --> 05:09.330
比方说这个用户里面

05:09.330 --> 05:10.330
还有一些其他信息

05:10.330 --> 05:11.330
用户的姓名

05:11.330 --> 05:12.330
Public

05:12.330 --> 05:13.330
姓名

05:13.330 --> 05:14.330
Name

05:14.330 --> 05:15.330
还有用户的年龄

05:15.330 --> 05:16.330
Public

05:16.330 --> 05:17.330
Age

05:17.330 --> 05:18.330
Number

05:18.330 --> 05:19.330
等等等等

05:19.330 --> 05:20.330
总之我们可以新建一个用户

05:20.330 --> 05:21.330
通过构造寒树

05:21.330 --> 05:23.330
但是有的时候呢

05:23.330 --> 05:25.330
比方说我现在要做登录

05:25.330 --> 05:27.330
要做登录

05:27.330 --> 05:28.330
登录吗

05:28.330 --> 05:30.330
他肯定是一个方法对不对

05:30.330 --> 05:32.330
他肯定是一个方法

05:32.330 --> 05:33.330
那么这个方法呢

05:33.330 --> 05:34.330
我们看一下啊

05:34.330 --> 05:35.330
方法呢

05:35.330 --> 05:36.330
我们给他写成一个罗锦

05:36.330 --> 05:37.330
表示登录

05:37.330 --> 05:39.330
登录要传递什么

05:39.330 --> 05:40.330
一个账号密码

05:40.330 --> 05:41.330
对不对

05:41.330 --> 05:43.330
要传递一个账号密码

05:43.330 --> 05:45.330
罗锦ID你要给我

05:45.330 --> 05:47.330
账号的告诉我呗

05:47.330 --> 05:48.330
密码

05:48.330 --> 05:50.330
要告诉我

05:50.330 --> 05:51.330
我给你返回啥呢

05:51.330 --> 05:53.330
如果登录成功的话

05:53.330 --> 05:55.330
如果登录成功

05:55.330 --> 05:57.330
我就给你返回一个用户对象

05:57.330 --> 05:59.330
给你返回一个用户对象

05:59.330 --> 06:00.330
如果登录失败

06:00.330 --> 06:01.330
我就给你返回一个

06:01.330 --> 06:03.330
Undefend

06:03.330 --> 06:05.330
我又写这么一个寒树

06:05.330 --> 06:08.330
假设我先默认登录失败吧

06:08.330 --> 06:10.330
默认登录失败

06:10.330 --> 06:12.330
好我写这么一个寒树

06:12.330 --> 06:14.330
那么这个寒树呢

06:14.330 --> 06:16.330
他是属于谁的呢

06:16.330 --> 06:19.330
属于的是内还是对象的呢

06:19.330 --> 06:20.330
想一想

06:20.330 --> 06:22.330
你说这个寒树我要怎么调用啊

06:22.330 --> 06:24.330
我是不是必须要创建一个用户对象

06:24.330 --> 06:25.330
才能调用啊

06:25.330 --> 06:26.330
对不对

06:26.330 --> 06:29.330
好那么现在问题就来了

06:29.330 --> 06:32.330
我现在要调用这个登录寒树

06:32.330 --> 06:35.330
我必须得创建一个用户对象

06:35.330 --> 06:36.330
才能调用

06:36.330 --> 06:38.330
那你觉得合理吗

06:38.330 --> 06:41.330
我现在就是要得到一个用户对象

06:41.330 --> 06:43.330
我要登录我也不是要注册

06:43.330 --> 06:44.330
我要注册的话

06:44.330 --> 06:46.330
我会新创建一个用户

06:46.330 --> 06:47.330
这个没问题啊

06:47.330 --> 06:49.330
我告诉你账号

06:49.330 --> 06:50.330
告诉你密码

06:50.330 --> 06:52.330
告诉你姓名和年龄

06:52.330 --> 06:54.330
来创建一个新建一个用户

06:54.330 --> 06:56.330
但是我现在要登录

06:56.330 --> 06:58.330
我干嘛要去新建一个用户呢

06:58.330 --> 06:59.330
这就很奇怪

06:59.330 --> 07:00.330
对不对

07:00.330 --> 07:02.330
这个逻辑上说不通

07:02.330 --> 07:03.330
但是那个登录呢

07:03.330 --> 07:05.330
它确实又是跟用户相关的

07:05.330 --> 07:08.330
是跟用户相关的一些操作

07:08.330 --> 07:10.330
所以说我把它写到用户那里边

07:10.330 --> 07:11.330
也非常合理

07:11.330 --> 07:12.330
这就遇到麻烦了

07:12.330 --> 07:14.330
就那是于啥呢

07:14.330 --> 07:16.330
那是于我要判断一个数字

07:16.330 --> 07:18.330
是不是NAN

07:18.330 --> 07:19.330
是不是NAN

07:19.330 --> 07:21.330
我应该怎么去判断呢

07:21.330 --> 07:23.330
我不应该用一个数字来判断

07:23.330 --> 07:24.330
它是不是NAN

07:24.330 --> 07:25.330
我不能这样子写吧

07:25.330 --> 07:27.330
我不能N点

07:27.330 --> 07:28.330
也是NAN

07:28.330 --> 07:29.330
这个太怪了

07:29.330 --> 07:31.330
我要判断另外一个数字是不是NAN

07:31.330 --> 07:33.330
我不应该是这种逻辑

07:33.330 --> 07:35.330
不应该是通过一个数字去判断

07:35.330 --> 07:37.330
而应该是什么呢

07:37.330 --> 07:40.330
通过它的构造函数

07:40.330 --> 07:42.330
构造函数里边提供一个功能

07:42.330 --> 07:44.330
判断一个数字是不是NAN

07:44.330 --> 07:46.330
应该是这种方式来判断

07:46.330 --> 07:47.330
同样的道理

07:47.330 --> 07:49.330
这里也是一样

07:49.330 --> 07:51.330
我这里是一个用户

07:51.330 --> 07:53.330
用户肯定有相关的操作

07:53.330 --> 07:54.330
就登录

07:54.330 --> 07:55.330
但是登录呢

07:55.330 --> 07:57.330
我现在又不能创建用户对象

07:57.330 --> 07:59.330
因为创建用户对象表示的含义是

07:59.330 --> 08:00.330
新建一个用户

08:00.330 --> 08:01.330
表示注册

08:01.330 --> 08:03.330
那现在登录怎么办

08:03.330 --> 08:05.330
我是不是应该这样子来做

08:05.330 --> 08:07.330
最好是应该是提供这种操作方式

08:07.330 --> 08:09.330
user.login

08:09.330 --> 08:11.330
这才是它最好的操作方式

08:11.330 --> 08:13.330
我把帐号给你

08:13.330 --> 08:14.330
传过去

08:14.330 --> 08:16.330
我把密码给你传过去

08:16.330 --> 08:17.330
如果登录成功

08:17.330 --> 08:19.330
你给我返回一个结果

08:19.330 --> 08:21.330
给我返回一个结果

08:21.330 --> 08:23.330
这个结果有可能是NDI

08:23.330 --> 08:25.330
有可能是一个用户对象

08:25.330 --> 08:27.330
如果是NDI的话表示登录失败

08:27.330 --> 08:30.330
帐号密码错误

08:30.330 --> 08:32.330
如果是一个用户对象的话

08:32.330 --> 08:33.330
表示登录成功

08:33.330 --> 08:35.330
它就会把用户对象给我

08:35.330 --> 08:37.330
应该是这么一个逻辑

08:37.330 --> 08:40.330
所以说呢

08:40.330 --> 08:42.330
我得把这个login

08:42.330 --> 08:43.330
这个成员

08:43.330 --> 08:45.330
把它加到哪儿去呢

08:45.330 --> 08:47.330
不是对象上面

08:47.330 --> 08:48.330
不是像以前的样子

08:48.330 --> 08:50.330
像这些成员在对象里边

08:50.330 --> 08:52.330
就是我要创建用户对象过后

08:52.330 --> 08:54.330
我才拥有这些成员

08:54.330 --> 08:55.330
而是这个成员

08:55.330 --> 08:57.330
是附属在内里边了

08:57.330 --> 08:59.330
附属在这里边了

08:59.330 --> 09:01.330
所以这里咋做

09:01.330 --> 09:02.330
咋做

09:02.330 --> 09:04.330
只需要在前边

09:04.330 --> 09:06.330
加上一个关键字

09:06.330 --> 09:07.330
Static

09:07.330 --> 09:09.330
表示静态的

09:09.330 --> 09:11.330
那么这样子一来呢

09:11.330 --> 09:12.330
就相当于是

09:12.330 --> 09:15.330
把这个东西附属在它上面

09:15.330 --> 09:16.330
就相当于是

09:16.330 --> 09:17.330
这种代码写法

09:17.330 --> 09:19.330
就相当于是这种写法

09:19.330 --> 09:21.330
以前老的街市里边

09:21.330 --> 09:22.330
就这种写法

09:22.330 --> 09:23.330
User.login

09:23.330 --> 09:25.330
给它复制为一个函数

09:25.330 --> 09:26.330
方可写

09:26.330 --> 09:28.330
就这个函数

09:28.330 --> 09:32.960
相当于是这种写法

09:32.960 --> 09:33.960
当TS里面

09:33.960 --> 09:35.960
它不允许你这样写

09:35.960 --> 09:36.960
TS里面

09:36.960 --> 09:37.960
它这个成员是不存在的

09:37.960 --> 09:38.960
它不允许你这样写

09:38.960 --> 09:40.960
但GS里面是可以这样写的

09:40.960 --> 09:42.960
这就相当于是这种写法了

09:42.960 --> 09:43.960
把这个成员

09:43.960 --> 09:45.960
是加到构造函数上面的

09:45.960 --> 09:46.960
那么这样子

09:46.960 --> 09:47.960
在TS里边

09:47.960 --> 09:50.960
也就是在ES6的新语法里边

09:50.960 --> 09:52.960
它建议你这么书写

09:52.960 --> 09:53.960
写一个内的时候

09:53.960 --> 09:54.960
如果一个成员

09:54.960 --> 09:56.960
不管你是属相也好

09:56.960 --> 09:58.960
还是一个方法也好

09:58.960 --> 09:59.960
无所谓

09:59.960 --> 10:00.960
只要你这个成员

10:00.960 --> 10:02.960
你希望把它附属在

10:02.960 --> 10:04.960
内上面

10:04.960 --> 10:06.960
你只需要在这个成员前边

10:06.960 --> 10:08.960
加上Static就可以了

10:08.960 --> 10:10.960
只要加上这个东西就可以了

10:10.960 --> 10:11.960
因此

10:11.960 --> 10:12.960
这个函数的调用

10:12.960 --> 10:14.960
是要通过内名去调用的

10:14.960 --> 10:15.960
内名去调用

10:15.960 --> 10:16.960
那么调用成功

10:16.960 --> 10:17.960
返回个用户对象

10:17.960 --> 10:19.960
返回过来就行了

10:19.960 --> 10:21.960
这是关于静态成员

10:21.960 --> 10:23.960
调用方式是通过内名调用的

10:23.960 --> 10:24.960
那么对象

10:24.960 --> 10:26.960
如果是个对象的话

10:26.960 --> 10:27.960
能不能调用

10:27.960 --> 10:29.960
我们留一个

10:30.960 --> 10:32.960
留一个用户对象

10:32.960 --> 10:34.960
随便写

10:35.960 --> 10:36.960
新名

10:36.960 --> 10:37.960
随便写

10:38.960 --> 10:39.960
年龄

10:41.960 --> 10:42.960
随便写

10:42.960 --> 10:44.960
这个用户对象里边你看

10:44.960 --> 10:45.960
它就没有这个逻辑了

10:45.960 --> 10:46.960
没有这个函数了

10:46.960 --> 10:48.960
因为这个函数是附属在

10:48.960 --> 10:49.960
内上面的

10:49.960 --> 10:50.960
明白这个意思吧

10:50.960 --> 10:51.960
好

10:51.960 --> 10:52.960
我们这里记一笔

10:52.960 --> 10:53.960
其实这是以前的知识了

10:53.960 --> 10:55.960
以前介石的知识

10:55.960 --> 10:56.960
并不是TS新增的

10:56.960 --> 10:58.960
ES6本身就知识这个东西

10:58.960 --> 11:00.960
不然我们编译一下吧

11:00.960 --> 11:01.960
编译一下

11:03.960 --> 11:05.960
TSC

11:05.960 --> 11:06.960
N片

11:10.960 --> 11:14.980
编译一下看它生存的结果

11:14.980 --> 11:15.980
你看

11:15.980 --> 11:17.980
是不是ES6里面本身就有的

11:18.980 --> 11:19.980
并不是什么新语法

11:19.980 --> 11:20.980
并不是TS里面的新语法

11:20.980 --> 11:22.980
本身它就知识这个东西

11:22.980 --> 11:23.980
罗锦

11:23.980 --> 11:24.980
好

11:24.980 --> 11:25.980
那么比方说

11:25.980 --> 11:29.980
比方说咱们来做一个完整的例子吧

11:29.980 --> 11:31.980
来做一个完整的例子

11:31.980 --> 11:32.980
这里我们先把记笔

11:32.980 --> 11:33.980
先记笔过后

11:33.980 --> 11:34.980
我们来做一个完整的例子

11:35.980 --> 11:39.980
使用Static修饰的成员

11:40.980 --> 11:42.980
是静态成员

11:42.980 --> 11:44.980
这里有些说法

11:44.980 --> 11:46.980
有种说法叫实力成员

11:47.980 --> 11:48.980
实力成员

11:48.980 --> 11:49.980
这么叫实力成员

11:49.980 --> 11:51.980
也叫做对象成员

11:51.980 --> 11:53.980
这些成员是

11:53.980 --> 11:57.980
属于某个内的对象

11:57.980 --> 11:58.980
它是属于对象的

11:58.980 --> 11:59.980
比方说

11:59.980 --> 12:00.980
像这个

12:01.980 --> 12:02.980
像这个东西

12:03.980 --> 12:04.980
这些东西

12:04.980 --> 12:06.980
这些属性就是实力成员

12:06.980 --> 12:07.980
实力是什么

12:07.980 --> 12:08.980
实力就是对象的意思

12:08.980 --> 12:10.980
我要创建内的对象过后

12:10.980 --> 12:11.980
我才拥有这些成员

12:11.980 --> 12:13.980
这是实力成员

12:13.980 --> 12:14.980
还有一种非实力成员

12:14.980 --> 12:16.980
就是静态成员

12:16.980 --> 12:18.980
它跟实力成员是相对的

12:18.980 --> 12:20.980
也叫做非实力成员

12:21.980 --> 12:27.980
它是属于某个内

12:27.980 --> 12:28.980
属于某个内

12:28.980 --> 12:30.980
它就不是属于对象的了

12:30.980 --> 12:31.980
是属于某个内的

12:31.980 --> 12:32.980
这是静态成员

12:32.980 --> 12:33.980
比方说像这个

12:33.980 --> 12:35.980
它就是静态成员

12:36.980 --> 12:37.980
好

12:37.980 --> 12:39.980
接下来我们来做一个练习

12:39.980 --> 12:40.980
做一个练习

12:41.980 --> 12:42.980
这个用户里边

12:42.980 --> 12:46.980
我们给它提供一些属性

12:46.980 --> 12:47.980
提供一个方法

12:47.980 --> 12:49.980
这个方法就是

12:50.980 --> 12:51.980
打个招呼

12:53.980 --> 12:54.980
提供一个方法

12:54.980 --> 12:55.980
这个方法

12:55.980 --> 12:56.980
我们输出啥呢

12:56.980 --> 12:59.980
输出Z

13:00.980 --> 13:02.980
大家好

13:02.980 --> 13:03.980
我叫

13:03.980 --> 13:04.980
我叫啥

13:04.980 --> 13:06.980
我叫ZS.NET

13:08.980 --> 13:09.980
我叫这个

13:09.980 --> 13:10.980
然后呢

13:11.980 --> 13:13.980
今年多少岁了

13:13.980 --> 13:15.980
今年ZS.AG

13:15.980 --> 13:17.980
多少岁了

13:17.980 --> 13:20.980
我的账号是

13:20.980 --> 13:22.980
密码我就不显示了

13:22.980 --> 13:27.980
账号是ZS.NojinID

13:27.980 --> 13:29.980
这是我的账号

13:29.980 --> 13:30.980
好

13:30.980 --> 13:31.980
我们来试一下

13:31.980 --> 13:32.980
我们来试一下

13:32.980 --> 13:35.980
我现在创建三个用户

13:35.980 --> 13:40.310
先创建三个用户

13:40.310 --> 13:41.310
U1

13:41.310 --> 13:42.310
六一个U字

13:42.310 --> 13:44.310
创建第一个用户

13:44.310 --> 13:45.310
NojinID U1

13:45.310 --> 13:46.310
NojinPassword

13:46.310 --> 13:47.310
随便写

13:48.310 --> 13:49.310
新名

13:51.310 --> 13:52.310
王富贵

13:54.310 --> 13:55.310
年龄十一

13:59.010 --> 14:00.010
第二个用户

14:00.010 --> 14:01.010
第二个用户

14:01.010 --> 14:03.010
六U字U2

14:03.010 --> 14:04.010
U2

14:04.010 --> 14:05.010
新名的话

14:05.010 --> 14:06.010
这是

14:08.010 --> 14:09.010
坤坤

14:11.010 --> 14:13.010
这里十八

14:13.010 --> 14:14.010
差不多

14:14.010 --> 14:15.010
再创建一个对象

14:15.010 --> 14:16.010
U3

14:16.010 --> 14:17.010
六一个U字

14:18.010 --> 14:19.010
U3

14:19.010 --> 14:20.010
然后123

14:20.010 --> 14:22.010
再来个旺财

14:22.010 --> 14:25.220
年龄

14:25.220 --> 14:26.220
二十二

14:26.220 --> 14:27.220
随便写

14:27.220 --> 14:28.220
好

14:28.220 --> 14:29.220
创建这么三个用户

14:29.220 --> 14:30.220
那么分别来打个招呼

14:32.220 --> 14:33.220
你看这些成员

14:33.220 --> 14:35.220
包括这些函数

14:35.220 --> 14:37.220
这些函数里面使用的成员

14:37.220 --> 14:40.220
他们都是依附于对象的

14:40.220 --> 14:41.220
目前的这些成员

14:41.220 --> 14:43.220
都是依附于对象的

14:43.220 --> 14:44.220
NpnR

14:44.220 --> 14:48.000
好

14:48.000 --> 14:49.000
这个没问题吧

14:49.000 --> 14:50.000
这个应该很简单

14:50.000 --> 14:51.000
对吧

14:51.000 --> 14:53.000
我们把这一步完成

14:53.000 --> 14:54.000
然后接下来了

14:54.000 --> 14:55.000
我们来完成登录

14:55.000 --> 14:57.000
来完成登录

14:57.000 --> 14:58.000
我们假设

14:58.000 --> 14:59.000
按照这样的逻辑的话

14:59.000 --> 15:00.000
我们假设

15:00.000 --> 15:02.000
每一次新建一个用户

15:02.000 --> 15:03.000
六一个

15:03.000 --> 15:04.000
表示什么意思

15:04.000 --> 15:06.000
表示一个新的东西产生了

15:06.000 --> 15:07.000
对吧

15:07.000 --> 15:08.000
一个新的东西产生了

15:08.000 --> 15:09.000
六一个

15:09.000 --> 15:10.000
我们就表示

15:10.000 --> 15:12.000
一个新的用户产生了

15:12.000 --> 15:14.000
一个新的用户产生了

15:14.000 --> 15:15.000
所以说

15:15.000 --> 15:17.000
我们以后要登录的时候

15:17.000 --> 15:19.000
我要看一下

15:19.000 --> 15:20.000
我要怎么完成登录

15:20.000 --> 15:22.000
我们系统中有哪些用户

15:22.000 --> 15:25.000
我们需要把每一次新建的用户

15:25.000 --> 15:27.000
装到一个数组里边

15:27.000 --> 15:28.000
当然这个操作

15:28.000 --> 15:29.000
不应该在这里做

15:29.000 --> 15:30.000
不应该在这里做

15:30.000 --> 15:32.000
应该在这个用户内里边做

15:32.000 --> 15:34.000
因为这是跟用户相关的操作

15:34.000 --> 15:37.000
我希望把每一次新建的用户

15:37.000 --> 15:39.000
都保存到一个数组里边

15:39.000 --> 15:40.000
OK

15:40.000 --> 15:41.000
那么这里

15:41.000 --> 15:43.000
我们应该去得到一个数组

15:43.000 --> 15:45.000
我们可以在用户内里边

15:45.000 --> 15:47.000
写上一个私有的属性

15:47.000 --> 15:49.000
私有的属性

15:49.000 --> 15:51.000
不需要让外面看到的

15:51.000 --> 15:52.000
一个私有的Private

15:52.000 --> 15:53.000
一个数组

15:53.000 --> 15:56.000
这个数组保存了所有的用户

15:56.000 --> 15:57.000
User

15:57.000 --> 15:59.000
它的内想是一个用户的数组

15:59.000 --> 16:01.000
它保存了所有的用户

16:01.000 --> 16:02.000
默认是空的

16:02.000 --> 16:04.000
大家想一想这个道理

16:04.000 --> 16:07.000
好好想一想

16:07.000 --> 16:09.000
这个成员

16:09.000 --> 16:11.000
这个数组

16:11.000 --> 16:14.000
应该是实力的成员

16:14.000 --> 16:16.000
还是静态成员

16:16.000 --> 16:18.000
给大家一点时间

16:18.000 --> 16:20.000
好好考虑一下

16:20.000 --> 16:22.000
它应该是实力成员

16:22.000 --> 16:24.000
还是静态成员

16:24.000 --> 16:27.000
好好考虑一下

16:27.000 --> 16:30.000
那你要想一想

16:30.000 --> 16:34.000
如果它是一个实力成员的话

16:34.000 --> 16:37.000
我们应该怎么去调用它

16:37.000 --> 16:40.000
应该去怎么调用它

16:40.000 --> 16:42.000
是不是要通过对象来调用它

16:42.000 --> 16:44.000
这就很奇怪了

16:44.000 --> 16:46.000
如果是实力成员的话

16:46.000 --> 16:48.000
那么就意味着

16:48.000 --> 16:49.000
这个U1

16:49.000 --> 16:51.000
假设把它收成公共了

16:51.000 --> 16:52.000
假设把它收成公共了

16:52.000 --> 16:54.000
外面能访问

16:54.000 --> 16:56.000
那么这个U1的User

16:56.000 --> 16:59.000
和这个U2的User是不一样的

16:59.000 --> 17:02.000
我们知道每个对象有自己的成员

17:02.000 --> 17:04.000
它的成员值都是不一样的

17:04.000 --> 17:05.000
它们互不干扰

17:05.000 --> 17:07.000
那这三个东西是不是不一样的

17:07.000 --> 17:10.000
而我们逻辑上是不是要要求一样的

17:10.000 --> 17:11.000
对不对

17:11.000 --> 17:13.000
要求一样的

17:13.000 --> 17:14.000
因此呢

17:14.000 --> 17:17.000
这里作为实力成员不太好

17:17.000 --> 17:21.000
这里应该是跟用户相关的所有的用户

17:21.000 --> 17:23.000
就是我们注册的系统里面

17:23.000 --> 17:27.000
注册的所有用户都放在这个数组里面

17:27.000 --> 17:29.000
我们调用的时候应该怎么调用呢

17:29.000 --> 17:31.000
应该是User.User

17:31.000 --> 17:33.000
我们这个系统里面

17:33.000 --> 17:36.000
用户跟用户相关的所有的用户

17:36.000 --> 17:39.000
所有的用户保持在这个数组里面

17:39.000 --> 17:41.000
应该是附着在这个内里面的

17:41.000 --> 17:43.000
因为内只有一个嘛

17:43.000 --> 17:45.000
内只有这个User对不对

17:45.000 --> 17:46.000
没有其他的了

17:46.000 --> 17:47.000
而对象可以有很多个

17:47.000 --> 17:49.000
对象可以不断的产生的

17:49.000 --> 17:51.000
所以说这里呢

17:51.000 --> 17:53.000
应该是作为静态成员存在

17:53.000 --> 17:55.000
静态成员存在

17:55.000 --> 17:57.000
Static静态成员

17:57.000 --> 18:01.000
我们每一次创建一个用户之后

18:01.000 --> 18:03.000
创建一个用户之后

18:03.000 --> 18:09.000
都要把用户需要将新建的用户

18:09.000 --> 18:13.000
新建的用户加入到数组中

18:13.000 --> 18:15.000
我们比方要做这么一个操作

18:15.000 --> 18:18.000
每一次要创建的用户呢

18:18.000 --> 18:21.000
通过勾到函数就会创建一个新种用户对不对

18:21.000 --> 18:25.000
把新创建的用户加入到数组里面

18:25.000 --> 18:27.000
好这个时候有了这个数组

18:27.000 --> 18:29.000
这个数组怎么调用

18:29.000 --> 18:33.000
你看看User.User

18:33.000 --> 18:34.000
你看数组就出来了

18:34.000 --> 18:37.000
它是静态成员附属在内上面的

18:37.000 --> 18:39.000
这里就说是个数组

18:39.000 --> 18:45.000
铺起U1U2U3都可以一式写进去

18:45.000 --> 18:47.000
当然了这个代码是写到外边的

18:47.000 --> 18:50.000
我现在希望把这个代码写到哪儿了

18:50.000 --> 18:53.000
写到这里面

18:53.000 --> 18:55.000
这里面咋写

18:55.000 --> 18:57.000
首先有两个问题要考虑

18:57.000 --> 18:59.000
有两个问题要考虑

18:59.000 --> 19:01.000
第一个问题

19:01.000 --> 19:05.000
铺起这里边写啥

19:05.000 --> 19:07.000
新建的用户是啥

19:07.000 --> 19:09.000
新建的用户是个对象

19:09.000 --> 19:11.000
那么在勾到函数里边

19:11.000 --> 19:14.000
如何来获取当前创建的对象

19:14.000 --> 19:16.000
如何来获取

19:16.000 --> 19:19.000
不要血蒙了

19:19.000 --> 19:21.000
我们现在这是勾到函数

19:21.000 --> 19:23.000
勾到函数里边

19:23.000 --> 19:25.000
如何获取当前的对象

19:25.000 --> 19:26.000
是不是ZS

19:26.000 --> 19:27.000
对不对

19:27.000 --> 19:28.000
只要ZS看一下

19:28.000 --> 19:30.000
它这里面显示出来

19:30.000 --> 19:31.000
ZS是啥

19:31.000 --> 19:34.000
这个ZS就是当前新创建的用户对象

19:34.000 --> 19:35.000
你看ZS里边

19:35.000 --> 19:36.000
有楼线ID

19:36.000 --> 19:37.000
有A级

19:37.000 --> 19:38.000
有Name

19:38.000 --> 19:40.000
这个ZS就是我们新创建的对象

19:40.000 --> 19:42.000
所以说这里铺起啥

19:42.000 --> 19:44.000
铺起ZS

19:44.000 --> 19:45.000
这个搞清楚

19:45.000 --> 19:47.000
我们要把当前的对象

19:47.000 --> 19:49.000
加入到这个数组里边

19:49.000 --> 19:51.000
那么加入到数组里边的时候

19:51.000 --> 19:53.000
大家再看

19:53.000 --> 19:54.000
这个UrS

19:54.000 --> 19:55.000
这是个属性

19:55.000 --> 19:57.000
能不能这样子调用

19:57.000 --> 20:00.000
能不能这样子调用

20:00.000 --> 20:01.000
不能

20:01.000 --> 20:02.000
为什么不能

20:02.000 --> 20:04.000
因为这是一个静态属性

20:04.000 --> 20:06.000
静态属性是附着在哪儿的

20:06.000 --> 20:08.000
附着在内意上边的

20:08.000 --> 20:10.000
而你这个ZS是啥

20:10.000 --> 20:12.000
ZS表示的是当前对象

20:12.000 --> 20:14.000
它是新建这个用户

20:14.000 --> 20:16.000
而不是这个内

20:16.000 --> 20:17.000
所以说

20:17.000 --> 20:19.000
它这里面根本没有这个实力成员

20:19.000 --> 20:22.000
它说UrS是一个静态成员

20:22.000 --> 20:24.000
它是附属在内意上边的

20:24.000 --> 20:26.000
而不是当前对象上边的

20:26.000 --> 20:28.000
所以说这里是要报错的

20:28.000 --> 20:30.000
这种代码的到GS里面

20:30.000 --> 20:31.000
它不甩理的

20:31.000 --> 20:32.000
它管理杂写

20:32.000 --> 20:33.000
无所谓的

20:33.000 --> 20:35.000
但是在TS里面

20:35.000 --> 20:36.000
是不允许这样的解法

20:36.000 --> 20:38.000
因为这种解法一定无出问题

20:38.000 --> 20:40.000
百分之百出问题

20:40.000 --> 20:41.000
因此它还提示的

20:41.000 --> 20:42.000
应该怎么办

20:42.000 --> 20:44.000
以后遇到这种提示很简单

20:44.000 --> 20:46.000
提示很简单就是把ZS

20:46.000 --> 20:48.000
改成内就行了

20:48.000 --> 20:49.000
改成内

20:49.000 --> 20:51.000
你明白这个意思吗

20:51.000 --> 20:52.000
在勾造函数里边

20:52.000 --> 20:54.000
这个ZS

20:54.000 --> 20:56.000
这个ZS表示的是当前对象

20:56.000 --> 20:58.000
表示当前对象

20:58.000 --> 20:59.000
好

20:59.000 --> 21:00.000
我们就把ZS

21:00.000 --> 21:02.000
加到这个数组里边了

21:02.000 --> 21:04.000
咱们再来输出一下

21:04.000 --> 21:05.000
我们来看一下

21:05.000 --> 21:07.000
创建了三个对象过后

21:07.000 --> 21:09.000
创建了三个对象过后

21:09.000 --> 21:10.000
我们来看一下这个数组

21:10.000 --> 21:11.000
我们直接创建

21:11.000 --> 21:12.000
我都不保存了

21:12.000 --> 21:13.000
我直接创建

21:13.000 --> 21:14.000
创建过后

21:14.000 --> 21:16.000
三个对象过后

21:16.000 --> 21:17.000
我们来输出一下

21:17.000 --> 21:18.000
这个数组的长度

21:18.000 --> 21:21.000
UrS

21:21.000 --> 21:23.000
看一下

21:23.000 --> 21:25.000
你看

21:25.000 --> 21:27.000
我把这个数组输出过后

21:27.000 --> 21:28.000
里面就显示的

21:28.000 --> 21:31.570
这里面保存了三个对象

21:31.570 --> 21:32.570
好

21:32.570 --> 21:34.570
现在我们已经把这些对象

21:34.570 --> 21:35.570
加到这个数组里边了

21:35.570 --> 21:37.570
那么现在我们来去实现

21:37.570 --> 21:39.570
这个登录

21:39.570 --> 21:43.200
去实现这个登录方法

21:43.200 --> 21:44.200
来吧

21:44.200 --> 21:45.200
来写一下

21:45.200 --> 21:46.200
这是罗锦函数

21:46.200 --> 21:47.200
好

21:47.200 --> 21:48.200
这里面怎么来实现呢

21:48.200 --> 21:50.200
其实罗锦登录

21:50.200 --> 21:52.200
他把账号传给你的

21:52.200 --> 21:53.200
把密码传给你的

21:53.200 --> 21:54.200
对吧

21:54.200 --> 21:56.200
你就从通过这个账号密码

21:56.200 --> 21:58.200
去看一下这个数组里边

21:59.200 --> 22:01.200
有满足条件的用户对象

22:01.200 --> 22:02.200
把它找出来

22:02.200 --> 22:03.200
好

22:03.200 --> 22:04.200
怎么找呢

22:04.200 --> 22:05.200
可以用这种方式

22:05.200 --> 22:06.200
UrS

22:06.200 --> 22:08.200
找到这个数组

22:08.200 --> 22:09.200
你看

22:09.200 --> 22:10.200
这是静态成员

22:10.200 --> 22:11.200
通过内区雕用

22:11.200 --> 22:12.200
静态成员

22:12.200 --> 22:13.200
这个数组里边

22:13.200 --> 22:15.200
有一个函数叫做fand

22:15.200 --> 22:16.200
去找

22:16.200 --> 22:17.200
找什么呢

22:17.200 --> 22:19.200
里面要传一个回调函数

22:19.200 --> 22:20.200
传一个回调函数

22:20.200 --> 22:22.200
这个回调函数就是一个条件

22:22.200 --> 22:24.200
看满足条件的用户

22:24.200 --> 22:25.200
给你找出来

22:25.200 --> 22:26.200
好

22:26.200 --> 22:28.200
把每一个用户对象传给你

22:28.200 --> 22:29.200
然后你看一下

22:29.200 --> 22:30.200
这个用户对象里边

22:30.200 --> 22:32.200
这个用户的账号

22:32.200 --> 22:34.200
是不等于这个账号

22:34.200 --> 22:36.200
用户的密码

22:36.200 --> 22:38.200
并且用户的密码

22:38.200 --> 22:39.200
是不等于

22:40.200 --> 22:42.200
罗锦帕斯尔了

22:43.200 --> 22:45.200
如果账号等于传递的账号

22:45.200 --> 22:46.200
如果密码了

22:46.200 --> 22:47.200
等于登录的密码

22:47.200 --> 22:48.200
那么找到过后

22:48.200 --> 22:50.200
他会把用户对象返回

22:50.200 --> 22:52.200
你看他返回的是啥

22:52.200 --> 22:54.200
返回的是一个用户对象

22:54.200 --> 22:56.200
或者是undefined

22:56.200 --> 22:57.200
如果没有找到

22:57.200 --> 22:58.200
就是undefined

22:58.200 --> 22:59.200
如果找到了

22:59.200 --> 23:01.200
他就会把这个用户对象返回给你

23:01.200 --> 23:02.200
OK

23:02.200 --> 23:04.200
那我直接把这个返回就行了

23:04.200 --> 23:06.200
直接把这个函数返回就行了

23:06.200 --> 23:07.200
好

23:07.200 --> 23:08.200
这个登录其实就写完了

23:08.200 --> 23:09.200
非常非常简单

23:09.200 --> 23:11.200
那咱们来试一下

23:11.200 --> 23:12.200
这里我创建了三个用户

23:12.200 --> 23:14.200
那么现在我们来登录

23:14.200 --> 23:15.200
试一下

23:15.200 --> 23:16.200
首先

23:16.200 --> 23:17.200
我们得到一个结果

23:17.200 --> 23:19.200
results

23:19.200 --> 23:21.200
通过user.login

23:21.200 --> 23:23.200
你看我不用创建对象

23:23.200 --> 23:24.200
它哪需要创建对象

23:24.200 --> 23:26.200
哪需要去新建用户呢

23:26.200 --> 23:28.200
它是看一下已有的用户

23:28.200 --> 23:29.200
里面有没有满足条件的

23:29.200 --> 23:31.200
它不需要去新建用户

23:31.200 --> 23:32.200
所以说

23:32.200 --> 23:34.200
这里是一个静态的

23:34.200 --> 23:35.200
传递个帐号进去

23:35.200 --> 23:36.200
u11

23:36.200 --> 23:38.200
密码123

23:38.200 --> 23:39.200
123

23:39.200 --> 23:40.200
看它返回啊

23:40.200 --> 23:41.200
返回的就是

23:41.200 --> 23:42.200
要么是一个undefined

23:42.200 --> 23:43.200
要么是一个用户

23:43.200 --> 23:45.200
当然你这里可以判断一下

23:45.200 --> 23:46.200
可以判断一下

23:46.200 --> 23:47.200
我这里直接输出了

23:47.200 --> 23:49.200
把这个results直接输出

23:49.200 --> 23:51.200
保存看一下结果

23:51.200 --> 23:52.200
你看

23:52.200 --> 23:53.200
登录成功

23:53.200 --> 23:55.200
说明得到了用户对象

23:55.200 --> 23:56.200
我这样可以

23:56.200 --> 23:57.200
用这种方式

23:57.200 --> 23:59.200
判断一下也可以

23:59.200 --> 24:00.200
判断一下

24:00.200 --> 24:03.200
如果results有值

24:03.200 --> 24:04.200
就表示它是一个用户

24:04.200 --> 24:07.200
那么results.shallow

24:07.200 --> 24:08.200
这里有内情保护

24:08.200 --> 24:10.200
如果你经过这个判断过后

24:10.200 --> 24:11.200
它都到了这里

24:11.200 --> 24:12.200
它就知道了

24:12.200 --> 24:13.200
你看它就知道了

24:13.200 --> 24:14.200
它是个用户

24:14.200 --> 24:15.200
它不可能是undefined

24:15.200 --> 24:16.200
因为undefined的话

24:16.200 --> 24:17.200
进不了这个判断

24:17.200 --> 24:18.200
好

24:18.200 --> 24:20.200
再来看保存一下

24:20.200 --> 24:21.200
OK

24:21.200 --> 24:22.200
我们得到这个用户了

24:22.200 --> 24:23.200
好

24:23.200 --> 24:24.200
我们换一个账号密码

24:24.200 --> 24:25.200
U2保存一下

24:27.200 --> 24:29.200
那么也得到这个用户了

24:29.200 --> 24:30.200
然后我们再换一个

24:30.200 --> 24:31.200
不存在的

24:31.200 --> 24:32.200
U4

24:33.200 --> 24:34.200
就没有任何东西

24:34.200 --> 24:35.200
登录失败

24:35.200 --> 24:36.200
L4

24:38.200 --> 24:39.200
输出

24:39.200 --> 24:41.200
登录失败

24:41.200 --> 24:43.200
账号或密码

24:44.200 --> 24:45.200
密码不正确

24:45.200 --> 24:46.200
输出

24:47.200 --> 24:48.200
保存

24:48.200 --> 24:49.200
OK

24:49.200 --> 24:50.200
就完成了

24:50.200 --> 24:51.200
看到没

24:51.200 --> 24:52.200
这就是一个登录的这么一个

24:52.200 --> 24:53.200
这么一个场景

24:53.200 --> 24:54.200
来告诉大家

24:54.200 --> 24:55.200
静态成员

24:55.200 --> 24:56.200
是怎么回事

24:56.200 --> 24:57.200
始终记住

24:57.200 --> 24:58.200
静态成员

24:58.200 --> 25:00.200
它是附属在

25:00.200 --> 25:02.200
是附属在内上面的

25:02.200 --> 25:04.200
而不是附属在对象上面

25:05.200 --> 25:06.200
好 这里面

25:06.200 --> 25:07.200
下面还有一个

25:07.200 --> 25:08.200
一个问题就是

25:10.200 --> 25:11.200
静态

25:12.200 --> 25:15.200
方法中的z

25:15.200 --> 25:17.200
静态方法中的z

25:17.200 --> 25:18.200
我们知道实力方法中

25:18.200 --> 25:19.200
什么叫实力方法

25:19.200 --> 25:21.200
就通过对象去交流的方法

25:21.200 --> 25:22.200
像这种方法

25:22.200 --> 25:23.200
就是实力方法

25:24.200 --> 25:26.200
实力方法中的z指向是什么

25:26.200 --> 25:27.200
指向的是什么

25:27.200 --> 25:29.200
当前对象

25:30.200 --> 25:33.200
实力方法中的z

25:33.200 --> 25:36.200
指向的是当前对象

25:36.200 --> 25:38.200
指向的是当前对象

25:40.900 --> 25:44.900
而静态方法中的z

25:44.900 --> 25:45.900
指向的是什么呢

25:45.900 --> 25:47.900
就不是当前对象了

25:47.900 --> 25:48.900
哪有对象

25:48.900 --> 25:50.900
它根本不需要通过对象去访问

25:50.900 --> 25:52.900
通过的是内去访问

25:52.900 --> 25:55.900
因此静态方法中的z指向的是

25:55.900 --> 25:57.900
当前内

25:57.900 --> 25:59.900
指的是内

25:59.900 --> 26:00.900
也就是说

26:00.900 --> 26:02.900
我在静态函数里边

26:02.900 --> 26:04.900
静态函数里边

26:04.900 --> 26:05.900
静态方法中

26:05.900 --> 26:06.900
要获取这个优热式

26:06.900 --> 26:07.900
我除了用这种方式之外

26:07.900 --> 26:09.900
还可以用什么方式

26:09.900 --> 26:12.900
这里还可以写z

26:12.900 --> 26:14.900
因为z指的就是

26:14.900 --> 26:16.900
z还可以推让的内形

26:17.900 --> 26:18.900
这个内

26:18.900 --> 26:19.900
这个内

26:19.900 --> 26:20.900
这个type of

26:20.900 --> 26:21.900
我们的关键字

26:21.900 --> 26:22.900
在ts里边啥意思呢

26:22.900 --> 26:23.900
我们还没有学

26:23.900 --> 26:24.900
还没有学

26:24.900 --> 26:25.900
没关系

26:25.900 --> 26:26.900
我就可以把它认为

26:26.900 --> 26:27.900
这个内

26:27.900 --> 26:28.900
这个优热

26:28.900 --> 26:29.900
你要这个意思吗

26:29.900 --> 26:32.900
这是关于z的关键字

26:32.900 --> 26:33.900
在静态方法中

26:33.900 --> 26:34.900
还是指向问题

26:34.900 --> 26:35.900
现在我们保持一下

26:35.900 --> 26:37.900
仍然是没有任何问题的

26:37.900 --> 26:38.900
照好密码不正确

26:38.900 --> 26:39.900
来换个正确的

26:39.900 --> 26:41.900
优杀

26:42.900 --> 26:43.900
是一样的

26:43.900 --> 26:44.900
一样的

26:44.900 --> 26:45.900
没有什么区别

26:45.900 --> 26:47.900
所以大家用静态方法的时候

26:47.900 --> 26:48.900
一定要小心

26:48.900 --> 26:49.900
在静态方法里边

26:49.900 --> 26:51.900
z指向的是内

26:51.900 --> 26:52.900
而不是对象

26:52.900 --> 26:53.900
因为根本就

26:53.900 --> 26:55.900
可能任何一个对象都没有

26:55.900 --> 26:56.900
可能没有任何对象

26:56.900 --> 26:58.900
因为它直接是通过内来调用的

26:58.900 --> 26:59.900
你在哪里去找对象呢

26:59.900 --> 27:01.900
没有当前对象这一说

27:01.900 --> 27:03.900
只是它指的是内

27:03.900 --> 27:05.900
大家注意着一点

27:06.900 --> 27:09.900
这是关于静态方法中的z

27:09.900 --> 27:11.900
把这个地方说一下

27:12.900 --> 27:14.900
其实静态成员就差不多了

27:14.900 --> 27:16.900
最后我们还是来介绍一个

27:16.900 --> 27:18.900
模式

27:18.900 --> 27:19.900
设计模式

27:19.900 --> 27:21.900
又来一个新的模式了

27:21.900 --> 27:23.900
叫做单立模式

27:23.900 --> 27:25.900
单立模式

27:25.900 --> 27:26.900
来看一下这种模式

27:26.900 --> 27:27.900
它是什么意思

27:27.900 --> 27:28.900
指的是什么

27:28.900 --> 27:30.900
什么一种情况

27:30.900 --> 27:32.900
把这个注释掉

27:32.900 --> 27:34.900
我们来下边去

27:34.900 --> 27:35.900
单立模式

27:35.900 --> 27:37.900
它是为了解决这么一种场景

27:37.900 --> 27:40.900
就是有些对象的整个系统

27:40.900 --> 27:42.900
它最多只能产生一个

27:42.900 --> 27:50.100
某些内的对象

27:50.100 --> 27:52.100
在系统中

27:52.100 --> 27:54.100
最多只能有一个

27:54.100 --> 27:55.100
可以没有

27:55.100 --> 27:56.100
但是你有的话

27:56.100 --> 27:58.100
最多只能有一个

27:58.100 --> 28:00.100
你不可能有多个对象

28:00.100 --> 28:01.100
是不合理的

28:01.100 --> 28:03.100
那么为了避免它

28:03.100 --> 28:06.100
随意的去新创建对象

28:06.100 --> 28:08.100
我们就可以使用单立模式

28:08.100 --> 28:10.100
为了避免

28:10.100 --> 28:13.100
避免开发者造成

28:13.100 --> 28:19.100
随意创建多个内对象的错误

28:19.100 --> 28:22.100
可以使用单立模式

28:22.100 --> 28:24.100
进行强约数

28:24.100 --> 28:27.100
它不可能创建多个对象

28:27.100 --> 28:28.100
那么怎么办呢

28:28.100 --> 28:30.100
如何来做一种模式出来

28:30.100 --> 28:31.100
让它不可能创建多个对象

28:31.100 --> 28:32.100
最多只能创建一个

28:32.100 --> 28:33.100
怎么办呢

28:33.100 --> 28:34.100
就要使用静态的

28:34.100 --> 28:35.100
静态成员

28:35.100 --> 28:37.100
是一种非常非常巧妙的办法

28:37.100 --> 28:39.100
例子的话

28:39.100 --> 28:40.100
很多了其实单立

28:40.100 --> 28:43.100
比方说这个中国象棋

28:43.100 --> 28:45.100
这个棋盘

28:45.100 --> 28:47.100
棋盘你可以使个内吧

28:47.100 --> 28:48.100
对不对

28:48.100 --> 28:49.100
棋盘可以使个内吧

28:49.100 --> 28:51.100
比方说我们写个棋盘内

28:51.100 --> 28:52.100
class

28:52.100 --> 28:53.100
再取个名字

28:53.100 --> 28:54.100
board

28:54.100 --> 28:56.100
棋盘内

28:56.100 --> 28:57.100
棋盘内里边呢

28:57.100 --> 28:59.100
它有哪些属性呢

28:59.100 --> 29:01.100
有棋盘的宽度

29:01.100 --> 29:03.100
Number比方随便写一个

29:03.100 --> 29:06.100
棋盘的高度

29:06.100 --> 29:08.100
Number随便写一个

29:08.100 --> 29:10.100
600

29:10.100 --> 29:11.100
700

29:11.100 --> 29:13.100
还有什么属性呢

29:13.100 --> 29:17.100
再来写一个棋盘的方法

29:17.100 --> 29:18.100
有一个方法

29:18.100 --> 29:21.100
初始化棋盘

29:21.100 --> 29:23.100
直接输出吧

29:23.100 --> 29:28.100
初始化棋盘

29:28.100 --> 29:30.100
写这么一个方法

29:30.100 --> 29:32.100
好了我写好这么一个棋盘

29:32.100 --> 29:33.100
内过后呢

29:33.100 --> 29:35.100
当然我要创建一个棋盘的时候

29:35.100 --> 29:36.100
我会怎么创建

29:36.100 --> 29:37.100
我会这样子创建

29:37.100 --> 29:39.100
比New一个board

29:39.100 --> 29:40.100
创建棋盘

29:40.100 --> 29:41.100
一会儿呢

29:41.100 --> 29:42.100
我有可能不小心

29:42.100 --> 29:44.100
我又需要棋盘这项的时候

29:44.100 --> 29:45.100
我有可能需要这样的带嘛

29:45.100 --> 29:47.100
New一个board

29:47.100 --> 29:48.100
那你看整个系统中

29:48.100 --> 29:49.100
是不是有两个棋盘呢

29:49.100 --> 29:50.100
对不对

29:50.100 --> 29:51.100
有两个棋盘

29:51.100 --> 29:53.100
合理吗

29:53.100 --> 29:55.100
是不是不合理

29:55.100 --> 29:56.100
不合理

29:56.100 --> 29:58.100
比方说棋盘内里边还有

29:58.100 --> 30:00.100
一个棋式的数组

30:00.100 --> 30:01.100
现在没有写棋式内

30:01.100 --> 30:02.100
那无所谓吧

30:02.100 --> 30:03.100
就这样吧

30:03.100 --> 30:05.100
那这样子肯定是不合理的

30:05.100 --> 30:06.100
因为咱们这个游戏

30:06.100 --> 30:07.100
整个这个游戏里边

30:07.100 --> 30:09.100
棋盘只能有一个

30:09.100 --> 30:11.100
我们目前没有设计到多个棋盘

30:11.100 --> 30:13.100
如何来避免去创造一些

30:13.100 --> 30:14.100
没有意义的对象

30:14.100 --> 30:15.100
创造那么多干嘛呢

30:15.100 --> 30:16.100
我们只需要一个

30:16.100 --> 30:18.100
让整个

30:18.100 --> 30:19.100
整个这个游戏

30:19.100 --> 30:21.100
只有一个棋盘对象产生

30:21.100 --> 30:22.100
这种场景还有很多

30:22.100 --> 30:23.100
比方说

30:23.100 --> 30:25.100
比如说播放器

30:25.100 --> 30:27.100
我要在我们的系统里边

30:27.100 --> 30:28.100
加个功能就是播放器

30:28.100 --> 30:29.100
播放器呢

30:29.100 --> 30:30.100
我要要求他

30:30.100 --> 30:32.100
每一个无论你是什么时候

30:32.100 --> 30:33.100
你要么没有打开

30:33.100 --> 30:34.100
打开的话

30:34.100 --> 30:35.100
只能有一个窗口

30:35.100 --> 30:37.100
不可能有多个播放器

30:37.100 --> 30:38.100
同时打开

30:38.100 --> 30:39.100
比如说有些播放器

30:39.100 --> 30:40.100
我记得QQ

30:40.100 --> 30:42.100
好像QQ影音就是这样做的

30:42.100 --> 30:43.100
对吧

30:43.100 --> 30:44.100
还有一些播放器也是这样做的

30:44.100 --> 30:45.100
就是他只能有一个窗口

30:45.100 --> 30:46.100
播放器窗口

30:46.100 --> 30:48.100
还比方说配置

30:48.100 --> 30:50.100
咱们的一些系统的配置

30:50.100 --> 30:51.100
这配置呢

30:51.100 --> 30:52.100
也是个对象

30:52.100 --> 30:53.100
通过一个配置内

30:53.100 --> 30:54.100
来产生的对象

30:54.100 --> 30:55.100
我们也希望

30:55.100 --> 30:56.100
他不能产生多个配置

30:56.100 --> 30:57.100
只能有一个配置

30:57.100 --> 30:59.100
面对这样一些场景

30:59.100 --> 31:00.100
就是说

31:00.100 --> 31:01.100
某一个内

31:01.100 --> 31:02.100
他只能有

31:02.100 --> 31:03.100
某一个内的对象

31:03.100 --> 31:04.100
他在系统中

31:04.100 --> 31:06.100
最多只能有一个

31:06.100 --> 31:07.100
那么又不能让开发者

31:07.100 --> 31:08.100
随即创建

31:08.100 --> 31:09.100
怎么办呢

31:09.100 --> 31:10.100
给他看一下

31:10.100 --> 31:11.100
单立模式

31:11.100 --> 31:12.100
他是怎么做的

31:12.100 --> 31:14.100
他非常的巧妙

31:14.100 --> 31:16.100
第一步

31:16.100 --> 31:18.100
首先要把你这个东西给搞定

31:18.100 --> 31:20.100
你不能随便去创建

31:20.100 --> 31:21.100
新的对象

31:21.100 --> 31:22.100
因为你只要一六

31:22.100 --> 31:24.100
只要你使用这个关键字

31:24.100 --> 31:25.100
一个新的对象

31:25.100 --> 31:26.100
刷就产生了

31:26.100 --> 31:27.100
一讯六一下

31:27.100 --> 31:28.100
啪

31:28.100 --> 31:29.100
又产生一个新的对象

31:29.100 --> 31:30.100
这样子肯定不行的

31:30.100 --> 31:32.100
因此我第一步

31:32.100 --> 31:35.100
先把构造函数给你私有化

31:36.100 --> 31:37.100
构造函数给你成

31:37.100 --> 31:39.100
变成Private的

31:39.100 --> 31:41.100
没见过对吧

31:41.100 --> 31:42.100
如果构造函数

31:42.100 --> 31:44.100
居然还可以把它变成私有的

31:44.100 --> 31:45.100
可以的

31:45.100 --> 31:46.100
可以的

31:46.100 --> 31:47.100
没问题的

31:47.100 --> 31:48.100
在面向的一样远远远

31:48.100 --> 31:50.100
这种作单立模式都要这样做

31:50.100 --> 31:52.100
把构造函数给你私有了过后

31:52.100 --> 31:53.100
你看

31:53.100 --> 31:55.100
你还能通过六来创建吗

31:55.100 --> 31:56.100
肯定不行了

31:56.100 --> 31:58.100
他说构造函数是私有的

31:58.100 --> 31:59.100
你根本就不能创建他

31:59.100 --> 32:01.100
你只能在这个内的内部

32:02.100 --> 32:04.100
所以说你这里没办法了

32:04.100 --> 32:06.100
外面是不可能使用六来创建的

32:06.100 --> 32:08.100
这就是强越数理

32:08.100 --> 32:09.100
那么问题来了

32:09.100 --> 32:11.100
外边不能使用六来创建

32:11.100 --> 32:13.100
那咋办呢

32:13.100 --> 32:14.100
那怎么来创建这个对象呢

32:14.100 --> 32:16.100
那现在一个对象都不能创建吗

32:16.100 --> 32:17.100
怎么办

32:17.100 --> 32:18.100
你看着

32:18.100 --> 32:20.100
我用这种方式

32:20.100 --> 32:22.100
先定一个私有的

32:22.100 --> 32:24.100
静态的成员

32:24.100 --> 32:27.100
取个名字就叫做下发先拨的吧

32:27.100 --> 32:29.100
随便取个名字

32:29.100 --> 32:30.100
它的内形呢

32:30.100 --> 32:32.100
内形是拨的

32:33.100 --> 32:34.100
是一个棋盘

32:34.100 --> 32:36.100
一个静态成员的棋盘

32:36.100 --> 32:38.100
这个成员就表示咱们系统中

32:38.100 --> 32:40.100
唯一的那个棋盘

32:40.100 --> 32:42.100
唯一的那个棋盘对象

32:42.100 --> 32:43.100
它的内形是对象

32:43.100 --> 32:44.100
是拨的对象

32:46.100 --> 32:48.100
它是可选的

32:48.100 --> 32:50.100
它是可选的

32:50.100 --> 32:52.100
就说可以没有值

32:52.100 --> 32:54.100
我们知道加上问号表示可选

32:54.100 --> 32:55.100
可选属性对吧

32:55.100 --> 32:56.100
表这个属性没有值

32:56.100 --> 32:58.100
也就是说它的值有可能是拨

32:58.100 --> 32:59.100
有可能是undefined

32:59.100 --> 33:01.100
那当然它拨人就是undefined

33:01.100 --> 33:02.100
对不对

33:02.100 --> 33:05.100
写好这么一个私有的静态的属性

33:05.100 --> 33:06.100
它的内形呢

33:06.100 --> 33:07.100
是一个对象

33:07.100 --> 33:08.100
是一个棋盘对象

33:08.100 --> 33:11.100
这就是系统里面唯一的那个棋盘对象

33:11.100 --> 33:13.100
因为它是附属在内上面的

33:13.100 --> 33:14.100
所以说

33:14.100 --> 33:15.100
这个东西是唯一的

33:15.100 --> 33:17.100
只有这么一个属性

33:17.100 --> 33:19.100
好 接下来

33:19.100 --> 33:21.100
当然光写这个东西还没用

33:21.100 --> 33:22.100
怎么来创建对象呢

33:22.100 --> 33:24.100
怎么来创建对象

33:25.100 --> 33:26.100
还可以这样子写

33:28.100 --> 33:29.100
public

33:29.100 --> 33:30.100
或者是不写public

33:30.100 --> 33:31.100
默认值就是public

33:31.100 --> 33:34.100
写个standic

33:34.100 --> 33:36.100
然后写上一个函数名

33:36.100 --> 33:39.100
比方说craze board

33:39.100 --> 33:41.100
创建一个棋盘

33:41.100 --> 33:43.100
写上这么一个函数

33:43.100 --> 33:44.100
这个函数呢

33:44.100 --> 33:47.100
它返回的结果是一个棋盘

33:47.100 --> 33:50.100
返回的结果是一个棋盘

33:50.100 --> 33:53.480
好 我先写

33:53.480 --> 33:54.480
这个函数我先写

33:54.480 --> 33:56.480
写完了过后再来解释

33:56.480 --> 33:57.480
我这个函数打写呢

33:57.480 --> 33:58.480
判断一下

33:58.480 --> 34:01.480
如果z is board

34:01.480 --> 34:02.480
这个东西有值

34:02.480 --> 34:05.480
直接返回z is board

34:05.480 --> 34:07.480
如果这个东西没有值

34:07.480 --> 34:10.480
OK 我给它创建z is board

34:10.480 --> 34:12.480
new一个board

34:12.480 --> 34:14.480
new一个board

34:14.480 --> 34:18.860
然后返回z is board

34:18.860 --> 34:20.860
好了 写完了

34:21.860 --> 34:22.860
写完了之后

34:22.860 --> 34:23.860
大家再看

34:23.860 --> 34:25.860
我之后要创建一个棋盘

34:25.860 --> 34:27.860
在外边要得到一个棋盘

34:27.860 --> 34:29.860
我该怎么来写呢

34:29.860 --> 34:31.860
我可能一开始会尝试一下

34:31.860 --> 34:32.860
这种写法

34:32.860 --> 34:33.860
board

34:33.860 --> 34:35.860
会尝试一下

34:35.860 --> 34:36.860
会发现它马上爆错了

34:36.860 --> 34:37.860
不准力这样用

34:37.860 --> 34:38.860
看 强约速力

34:38.860 --> 34:40.860
不准力这样用

34:40.860 --> 34:41.860
那咋办呢

34:41.860 --> 34:42.860
我找来找去

34:42.860 --> 34:44.860
只能找一下它的静态成员里边

34:44.860 --> 34:46.860
其实在做面向对象开发的时候

34:46.860 --> 34:47.860
经常都是这样子

34:47.860 --> 34:48.860
有的时候

34:48.860 --> 34:51.860
你创建一个别人的力的对象

34:51.860 --> 34:53.860
你发现它不让你创建

34:53.860 --> 34:54.860
不让你创建怎么办呢

34:54.860 --> 34:55.860
马上通过内成员

34:55.860 --> 34:57.860
看一下有没有静态的方法

34:57.860 --> 34:58.860
来帮你创建

34:58.860 --> 35:00.860
好 点了一下

35:00.860 --> 35:01.860
create board

35:01.860 --> 35:02.860
你看方法是不是出来了

35:02.860 --> 35:04.860
创建一个board

35:04.860 --> 35:06.860
当我们去调用这个方法的时候

35:06.860 --> 35:07.860
你看一下

35:07.860 --> 35:09.860
它反回的就是一个board的对象

35:09.860 --> 35:10.860
反回一个board的对象

35:10.860 --> 35:12.860
就是一个棋盘对象

35:12.860 --> 35:13.860
这个方法里面做了一个判断

35:13.860 --> 35:14.860
判断啥呢

35:14.860 --> 35:16.860
判断这个私有的静态成员

35:16.860 --> 35:18.860
是不是已经有质

35:18.860 --> 35:20.860
已经有了一个对象

35:20.860 --> 35:21.860
如果有的话

35:21.860 --> 35:22.860
直接把这个对象返回给你

35:22.860 --> 35:24.860
我就不再去新建了

35:24.860 --> 35:26.860
如果这个东西没有值

35:26.860 --> 35:28.860
我给它复制一个新建的对象

35:28.860 --> 35:30.860
然后返回给你

35:30.860 --> 35:32.860
因此你会看到这么一个现象

35:32.860 --> 35:34.860
我这里无论去调用

35:34.860 --> 35:36.860
多少次这个方法

35:36.860 --> 35:38.860
得到的都是同一个对象

35:38.860 --> 35:40.860
我们调用两次

35:40.860 --> 35:42.860
我们输出B1

35:42.860 --> 35:44.860
是不是等于B2的

35:44.860 --> 35:46.860
老春

35:46.860 --> 35:48.860
我们来看一下

35:48.860 --> 35:51.860
你看 设置为了变成了2

35:51.860 --> 35:53.860
B1是等于B2的

35:53.860 --> 35:55.860
两个是完全一样的

35:55.860 --> 35:57.860
明白了吧

35:57.860 --> 35:59.860
这就是单立模式

35:59.860 --> 36:00.860
非常简单

36:00.860 --> 36:02.860
它是通过一个静态的函数

36:02.860 --> 36:05.860
静态方法来创建一个board对象

36:05.860 --> 36:07.860
通过静态方法来创建

36:07.860 --> 36:09.860
注意方法中的Race关键字

36:09.860 --> 36:11.860
指向了深内board

36:11.860 --> 36:12.860
而不是对象

36:12.860 --> 36:14.860
Race既然是指向内

36:14.860 --> 36:16.860
那么内里面是不是可以使用静态成员

36:16.860 --> 36:17.860
对不对

36:17.860 --> 36:19.860
没问题

36:19.860 --> 36:22.860
这里其实有些同学还会有一些

36:22.860 --> 36:24.860
就是其他的写法

36:24.860 --> 36:26.860
有些同学很聪明

36:26.860 --> 36:28.860
他发现了还有一些其他的写法

36:28.860 --> 36:30.860
什么写法就是不用这个

36:30.860 --> 36:32.860
不用这个

36:32.860 --> 36:34.860
这个地方

36:34.860 --> 36:36.860
就是公共的

36:36.860 --> 36:38.860
给它加上一个

36:38.860 --> 36:40.860
加上个啥呢

36:40.860 --> 36:42.860
Rate Only

36:42.860 --> 36:44.860
然后这里直接给它复出指

36:46.860 --> 36:48.860
直接给它复出一个出指

36:48.860 --> 36:50.860
留一个board

36:51.860 --> 36:53.860
这样子可不可以

36:53.860 --> 36:55.860
这样子是不是也可以

36:55.860 --> 36:57.860
Single Board

36:57.860 --> 36:58.860
Single Board

36:58.860 --> 37:00.860
就是唯一的那个期盘

37:00.860 --> 37:02.860
期盘对象

37:02.860 --> 37:03.860
这里我们直接

37:03.860 --> 37:04.860
甚至不用内形了

37:04.860 --> 37:06.860
内形可能它自动推断

37:06.860 --> 37:07.860
这样子也可以

37:07.860 --> 37:08.860
因为第一呢

37:08.860 --> 37:11.860
我就怎么来使用Single Board

37:11.860 --> 37:12.860
第二呢

37:12.860 --> 37:15.860
也是这个通过属性来得到Single Board

37:15.860 --> 37:16.860
那么看看两个是不是一样的

37:16.860 --> 37:18.860
所以一定是一样的

37:18.860 --> 37:20.860
一定是一样的

37:24.860 --> 37:26.860
为什么要加上Rate Only呢

37:26.860 --> 37:28.860
为啥要加上Rate Only

37:28.860 --> 37:30.860
为了防止啥呢

37:30.860 --> 37:32.860
为了防止

37:32.860 --> 37:34.860
你这里如果不加Rate Only的话

37:34.860 --> 37:37.860
那么它有没有可能重新复辞

37:37.860 --> 37:39.860
它有没有可能重新给它复辞

37:39.860 --> 37:41.860
重新给它复辞

37:41.860 --> 37:42.860
有没有可能

37:42.860 --> 37:44.860
当然有可能给它重新复辞

37:44.860 --> 37:46.860
但是实际上在这个例子中

37:46.860 --> 37:48.860
在这个例子中不太可能

37:48.860 --> 37:49.860
因为这个例子中

37:49.860 --> 37:50.860
它的构造含书是私有化的

37:50.860 --> 37:51.860
你怎么复辞呢

37:51.860 --> 37:52.860
你咋复辞

37:52.860 --> 37:53.860
你复辞

37:53.860 --> 37:54.860
你没法创建对象

37:54.860 --> 37:55.860
你咋复辞呢

37:55.860 --> 37:57.860
你不能创建对象

37:57.860 --> 37:59.860
所以说你也没法复辞

37:59.860 --> 38:01.860
因此在这个场景里边

38:01.860 --> 38:02.860
不加Rate Only呢

38:02.860 --> 38:04.860
其实也没什么事

38:04.860 --> 38:05.860
也没什么事

38:05.860 --> 38:07.860
但是我建议大家最好加上

38:07.860 --> 38:09.860
要防止有籽类的情况

38:09.860 --> 38:10.860
万一它还有籽类的

38:10.860 --> 38:12.860
我给它复辞一个籽类的对象

38:12.860 --> 38:14.860
尽量还是把它加上

38:15.860 --> 38:17.860
越懂力加上

38:17.860 --> 38:19.860
表示不能给它重新复辞

38:19.860 --> 38:21.860
它这个籽就是从头到尾就完事了

38:21.860 --> 38:23.860
当然这种写法

38:23.860 --> 38:24.860
跟刚才那种写法

38:24.860 --> 38:25.860
实际上是有区别的

38:25.860 --> 38:26.860
还是有区别的

38:26.860 --> 38:27.860
区别在哪呢

38:27.860 --> 38:29.860
就是这种写法

38:29.860 --> 38:31.860
它是在最一开始的时候

38:31.860 --> 38:33.860
就会创建一个棋盘

38:33.860 --> 38:36.860
而不是在我们需要棋盘对象的时候

38:36.860 --> 38:37.860
创建

38:37.860 --> 38:39.860
你看程序一开始的时候

38:39.860 --> 38:41.860
哪怕我没有运行这两行代

38:41.860 --> 38:43.860
这个棋盘也创建了

38:44.860 --> 38:47.860
我不是说我们需要用棋盘的时候

38:47.860 --> 38:48.860
才去创建

38:48.860 --> 38:49.860
这是它第一个问题

38:49.860 --> 38:50.860
第二个问题

38:50.860 --> 38:52.860
就是说如果

38:52.860 --> 38:53.860
创建棋盘的时候

38:53.860 --> 38:54.860
还要写很多的代码

38:54.860 --> 38:56.860
比方说还要写一些异布的

38:56.860 --> 38:58.860
还要写乱七八糟的一大堆东西

38:58.860 --> 39:00.860
还可能涉及到一大堆的事情要做

39:00.860 --> 39:01.860
那么这个地方就写不了

39:01.860 --> 39:03.860
因为这个地方只能写个表达式

39:03.860 --> 39:04.860
给它复一个出纸

39:04.860 --> 39:06.860
没有办法写很多的代码

39:06.860 --> 39:08.860
所以说这种做法

39:08.860 --> 39:09.860
可以做

39:09.860 --> 39:10.860
简单的场景下可以做

39:10.860 --> 39:12.860
只不过咱们平时用的最多的

39:13.860 --> 39:16.860
就是用的最多的单粒模式

39:16.860 --> 39:18.860
是使用下面那种写法

39:21.740 --> 39:23.740
就是之前那种写法

39:24.740 --> 39:25.740
总之单粒模式

39:25.740 --> 39:27.740
它要通过静态方法

39:27.740 --> 39:28.740
来完成创建

39:28.740 --> 39:30.740
而不是直接创建

39:30.740 --> 39:32.740
你如果让你直接创建的话

39:32.740 --> 39:33.740
你会创建很多个了

39:33.740 --> 39:34.740
这样子

39:34.740 --> 39:35.740
我们整个系统中

39:35.740 --> 39:36.740
只有一个期盘

39:37.740 --> 39:39.740
OK 这是关于静态成员

39:39.740 --> 39:41.740
这一块的指示

39:41.740 --> 39:43.740
这一块东西是比较简单的

39:43.740 --> 39:44.740
你只需要记住

39:44.740 --> 39:45.740
实力成员是什么意思

39:45.740 --> 39:46.740
精彩成员是什么意思

39:46.740 --> 39:48.740
属于一样race的指向

39:48.740 --> 39:50.740
然后学习一下单粒模式

39:50.740 --> 39:51.740
这个模式是怎么来

39:51.740 --> 39:53.740
发挥它的强约速率

39:53.740 --> 39:54.740
让我们整个系统中

39:54.740 --> 39:56.740
某个内只能产生一个对象

39:56.740 --> 39:57.740
它是怎么做的

39:58.740 --> 40:00.740
这是关于这一部分

40:00.740 --> 40:01.740
到这里了

40:02.740 --> 40:03.740
拜拜

