WEBVTT

00:01.070 --> 00:05.670
这节课呢是咱们装饰器这一张的最后一节课了

00:05.930 --> 00:10.290
我们这节课呢补充一些知识啊补充一些前面没讲到的知识

00:10.550 --> 00:12.850
其实前面的知识呢是最核心的内容

00:13.110 --> 00:15.670
就特别是内装饰器和成员装饰器

00:16.170 --> 00:17.210
已经了这个裤

00:17.710 --> 00:20.790
已经了这两个裤啊都是咱们这一张的中央内容

00:21.550 --> 00:25.910
这节课的东西呢都是一些细致默写的东西平时用的不多

00:26.170 --> 00:29.230
但是呢以后将来呢可能会发挥作用

00:29.630 --> 00:31.790
所以说这里呢来做个补充啊

00:32.310 --> 00:34.870
这一刻呢我们补充这么三个知识

00:35.370 --> 00:36.650
第一个知识呢

00:37.170 --> 00:39.470
是说一下参数

00:40.230 --> 00:41.010
装饰器

00:42.550 --> 00:44.850
第二个知识呢是说一下关于

00:46.130 --> 00:46.890
TS

00:47.410 --> 00:48.170
自动

00:48.690 --> 00:49.450
注入的

00:49.970 --> 00:50.730
元数据

00:51.510 --> 00:56.630
第三个呢是说一下关于一个面向对象的设计模式啊叫做

00:56.890 --> 00:57.650
AOP

00:58.630 --> 00:59.910
好我们来一个个讲吧

01:00.170 --> 01:02.470
首先是第一个啊参数装饰器

01:02.730 --> 01:04.270
这一块了解一下就行了

01:04.510 --> 01:07.590
因为参数装饰器这一块呢

01:07.850 --> 01:09.630
他需要在一个

01:10.390 --> 01:12.710
非常特殊的场景才有可能会用到

01:12.970 --> 01:14.750
什么场景呢就比方说

01:15.010 --> 01:15.790
依赖注入

01:16.290 --> 01:17.830
但是依赖注入了

01:18.590 --> 01:21.670
需要一个很大型的项目可能才会用到

01:21.930 --> 01:26.030
而且呢这是跟后端相关的一种技术

01:26.490 --> 01:30.370
我们学前端没有必要在这个阶段去了解这个东西啊

01:30.630 --> 01:32.170
如果有兴趣的同学啊

01:32.430 --> 01:35.770
有兴趣的同学可以去网上收一下关于依赖注入

01:36.530 --> 01:37.550
依赖注入

01:37.810 --> 01:39.850
也叫做依赖导致

01:40.110 --> 01:41.130
依赖导致

01:43.740 --> 01:45.260
依赖导致

01:46.540 --> 01:52.940
这个东西呢我就不过多的讲解了给大家提出这么一个名词大家有兴趣的话可以去查一查看一看

01:53.700 --> 01:56.780
那参数装饰器呢往往在这个时候会发挥作用

01:57.240 --> 01:58.780
其他的时候呢

01:59.040 --> 02:01.600
作用不是很大啊不是很大

02:02.120 --> 02:03.640
我们来看一下参数装饰器吧

02:04.160 --> 02:06.200
好参数装饰器呢他要求

02:08.000 --> 02:09.280
当然装饰器都是韩数对吧

02:09.540 --> 02:10.560
要求韩数

02:11.580 --> 02:13.120
有三个参数

02:14.400 --> 02:15.160
哪三个参数呢

02:15.680 --> 02:16.440
第一个参数

02:16.960 --> 02:18.240
如果

02:18.500 --> 02:20.540
既然是参数那肯定是方法对吧

02:20.800 --> 02:22.840
如果方法是静态的

02:23.360 --> 02:24.120
那么

02:24.380 --> 02:25.660
则为

02:25.880 --> 02:26.880
内本身

02:27.920 --> 02:30.720
如果方法是实力方法

02:31.760 --> 02:33.040
实力方法就是

02:33.300 --> 02:38.160
我们也叫做成员方法也叫做对象方法总之是通过对象去调用的

02:38.420 --> 02:39.760
如果是这样的方法的话

02:40.020 --> 02:42.000
那么这个第一个参数软折

02:42.260 --> 02:43.020
则为

02:43.280 --> 02:44.800
内的元凶

02:45.320 --> 02:47.360
跟之前是一样的跟之前

02:47.620 --> 02:50.700
那个属相给之前那个方法那一块是一样的

02:51.220 --> 02:52.500
好第一个参数啊

02:52.760 --> 02:54.800
第二个参数是方法名称

02:56.320 --> 02:57.400
第三个参数是

02:58.160 --> 02:59.200
参数

03:01.000 --> 03:03.040
在参数列表中的索义

03:03.800 --> 03:08.160
在参数列表中的索义就是目前你修饰

03:08.400 --> 03:10.200
你装饰的那个参数

03:10.460 --> 03:12.520
是第几个参数就这么个意思

03:13.280 --> 03:14.040
好咱们来

03:14.300 --> 03:15.840
写一下吧咱们来写一下

03:16.600 --> 03:20.200
比方说这个里边我们给他写这么一个内

03:21.980 --> 03:24.440
呃用户啊就随便写个内法

03:24.640 --> 03:25.540
比方说mess

03:25.840 --> 03:26.940
mess

03:27.640 --> 03:30.340
这个内里边呢有一个方法啊

03:30.340 --> 03:32.540
求和啊求和上

03:33.240 --> 03:34.740
然后传两个参数 a

03:35.240 --> 03:36.240
和参数b

03:37.940 --> 03:39.540
方案会呢反而就是a加比

03:40.740 --> 03:43.940
好然后第二个参数呢我给他加一个装饰器啊

03:43.940 --> 03:44.940
再加一个装饰器

03:45.540 --> 03:47.940
我们这样子写这样子写看着要舒服一点啊

03:48.080 --> 03:50.340
也可以直接在前面写也可以啊

03:50.740 --> 03:53.240
这里加个装饰器比方说test吧

03:53.540 --> 03:53.940
test

03:54.340 --> 03:55.140
这么一个装饰器

03:55.740 --> 03:57.640
当然现在没有这个装饰器他肯定要抱错

03:57.640 --> 03:59.340
那我们现在写这么一个装饰器吧

03:59.740 --> 04:00.840
写这么一个装饰器

04:01.240 --> 04:03.540
好这个装饰器呢他是一个函数

04:03.540 --> 04:04.940
他有三个参数

04:04.940 --> 04:05.940
第一个参数呢

04:06.040 --> 04:07.940
pocket就把稍微n了吧

04:08.440 --> 04:10.140
好第二个参数呢是

04:10.340 --> 04:12.240
是什么方法的名字对吧

04:12.240 --> 04:13.140
mess

04:14.940 --> 04:16.140
伺服串方法名字

04:16.440 --> 04:18.340
第三个参数呢是锁印第级

04:18.340 --> 04:22.040
就是你目前装饰的参数是第几个参数

04:22.040 --> 04:23.640
index number

04:24.940 --> 04:26.540
好写好过后你看不抱错了

04:26.540 --> 04:28.040
因为这个方法的格式呢

04:28.140 --> 04:30.240
这个函数的格式满足

04:30.640 --> 04:32.840
参数装饰器的要求

04:33.740 --> 04:35.140
好那么也是一样啊

04:35.440 --> 04:37.740
在定义好这个内置后呢

04:37.740 --> 04:39.540
他马上就会调用这个函数

04:39.740 --> 04:40.540
咱们来看一下啊

04:40.540 --> 04:41.840
这个函数我们输出啊

04:41.840 --> 04:43.240
一次输出tockets

04:43.640 --> 04:45.240
然后再输出messor的

04:45.740 --> 04:47.240
然后再输出index

04:48.240 --> 04:49.040
再输出他们

04:49.440 --> 04:50.540
保存我们看一下

04:52.040 --> 04:53.340
npm.dev

04:54.940 --> 04:56.640
好运行出来看一下啊

04:58.240 --> 04:58.840
你看

04:59.640 --> 05:01.340
这是元雄对象

05:01.740 --> 05:03.640
这是方法名称

05:03.840 --> 05:05.240
这是第几个参数

05:05.240 --> 05:06.540
下标从零开始

05:06.540 --> 05:07.540
那么是第二个

05:07.540 --> 05:08.140
对吧

05:08.140 --> 05:08.840
第二个

05:09.240 --> 05:10.840
好你具体要做什么事情

05:10.840 --> 05:12.040
那你随便去作为

05:12.240 --> 05:13.940
比如比方说你要去验的这个参数

05:13.940 --> 05:15.240
必须要飞空啊

05:15.240 --> 05:17.140
那么你可以加一些元数据

05:17.440 --> 05:18.540
去质疑去处理

05:18.840 --> 05:20.140
我这里不展开了啊

05:20.540 --> 05:22.540
这是关于参数装饰器

05:23.440 --> 05:24.340
实际上有些同学呢

05:24.340 --> 05:26.140
可能会认为参数装饰器呢

05:26.840 --> 05:27.740
需要验证啊

05:27.740 --> 05:29.940
特别是在去验证一些参数的时候

05:29.940 --> 05:30.940
会发挥一些作用

05:31.440 --> 05:32.540
确实是这样子

05:32.940 --> 05:33.340
只不过呢

05:33.340 --> 05:34.640
在ts里边

05:34.840 --> 05:36.040
本来ts

05:36.540 --> 05:38.740
他就有验证功能啊

05:38.740 --> 05:40.240
就有检查功能

05:40.840 --> 05:42.840
虽然这种检查是在编译时代的

05:42.840 --> 05:44.440
但是我们函数调用

05:44.440 --> 05:47.040
往往都是在编译时代手动调用的

05:47.440 --> 05:48.740
往往都是手动调用的

05:48.840 --> 05:50.640
因此你手动调用函数的时候呢

05:50.640 --> 05:52.540
往往都能够获得内容检查

05:52.740 --> 05:54.240
所以说参数这一孔呢

05:54.940 --> 05:57.340
在ts里面肯定是有一些意义的

05:57.340 --> 05:59.640
比方说你要给他传递个n内容

06:00.040 --> 06:01.640
他忽略要内容检查

06:01.840 --> 06:04.040
那么就把检查要带到运行的时代

06:04.340 --> 06:06.440
那么运行时候要检查的话

06:06.540 --> 06:07.740
就需要这个装饰器

06:09.040 --> 06:10.240
其他的时候呢

06:10.240 --> 06:10.940
我觉得

06:11.140 --> 06:13.540
如果是验证的规则来看的话

06:13.840 --> 06:16.040
其他的时候用处真补大

06:16.240 --> 06:17.240
用处真补大

06:17.840 --> 06:19.440
好我们这里了解一下就行了啊

06:19.440 --> 06:21.540
有这么个参数装饰器知道的

06:21.540 --> 06:22.940
有这么个东西存在就行了

06:23.140 --> 06:24.840
他其之最大的作用就是

06:25.140 --> 06:27.040
做依赖注入的时候很有用

06:27.240 --> 06:28.440
但是我们现在呢

06:28.640 --> 06:30.140
肯定不会涉及到依赖注入

06:31.140 --> 06:32.340
这里了解一下就行了

06:33.040 --> 06:34.440
好我们再来看说啊

06:34.440 --> 06:35.740
再来说一下第二个知识点

06:36.840 --> 06:38.340
就是关于ts里面啊

06:38.340 --> 06:39.940
自动注入的元数据

06:40.140 --> 06:41.340
这一块什么意思

06:42.040 --> 06:43.740
就是在ts里面呢

06:43.940 --> 06:45.040
如果

06:46.240 --> 06:46.940
如果

06:47.640 --> 06:48.840
安装啊

06:48.940 --> 06:50.040
安装了这个库

06:50.440 --> 06:52.640
我们之前说过这个库叫做reflect

06:54.040 --> 06:55.040
metadata

06:55.840 --> 06:58.140
如果你安装了这个库啊

06:58.240 --> 07:00.840
并且导入了该库

07:01.540 --> 07:02.940
这库你导入进来了

07:03.340 --> 07:04.240
并且

07:04.940 --> 07:06.140
啊就是

07:07.540 --> 07:09.740
在某些啊在某个

07:10.340 --> 07:12.040
属性或者叫成员吧

07:12.040 --> 07:13.140
某个成员

07:13.640 --> 07:14.140
上

07:14.740 --> 07:16.940
添加了元数据

07:19.220 --> 07:20.220
再并且

07:20.820 --> 07:21.820
还有很多条件

07:22.120 --> 07:23.020
再并且

07:23.220 --> 07:24.820
你启用了啊

07:24.820 --> 07:26.220
启用了一个配置

07:26.220 --> 07:27.120
什么配置呢

07:27.620 --> 07:29.320
这个配置的名称叫做这个

07:29.620 --> 07:30.420
amat

07:30.920 --> 07:32.020
decorator

07:32.720 --> 07:33.520
metadata

07:34.220 --> 07:35.420
amat就生长

07:35.520 --> 07:38.620
生长装饰器的元数据啊

07:38.720 --> 07:40.820
如果你把这个配置启用了啊

07:40.920 --> 07:41.920
还有很多条件

07:43.020 --> 07:44.920
如果你把这个东西设置了

07:44.920 --> 07:46.420
就是启用了这个东西

07:47.020 --> 07:47.620
则

07:48.820 --> 07:49.720
ts

07:50.020 --> 07:52.120
在编译结果中

07:53.120 --> 07:53.720
会

07:54.120 --> 07:54.720
将

07:55.220 --> 07:57.120
约束的内形

07:58.620 --> 08:00.420
作为元数据

08:01.120 --> 08:02.020
加入到

08:02.420 --> 08:04.420
啊加入到相应为止

08:05.220 --> 08:06.120
相应为止

08:06.820 --> 08:08.820
说了半天啥意思呢

08:09.420 --> 08:10.120
啥意思

08:10.120 --> 08:11.120
我们来举个例子吧

08:12.620 --> 08:13.920
嗯比方说

08:13.920 --> 08:16.520
我们还是一个用户的用户类为例子

08:16.820 --> 08:17.820
class user

08:18.020 --> 08:19.120
啊有一个用户类

08:19.820 --> 08:21.120
这个用户类里边呢

08:21.120 --> 08:23.420
我给他写这么一个属性

08:23.920 --> 08:26.120
啊一个属性的名字的叫做某键id啊

08:26.120 --> 08:26.920
随便写吧

08:27.420 --> 08:28.920
某键id字不算啊

08:28.920 --> 08:30.720
然后呢年龄啊

08:30.720 --> 08:32.020
number number

08:32.820 --> 08:34.320
哈现在呢

08:34.320 --> 08:35.920
我导入了这个

08:36.120 --> 08:38.320
啊reflagdata

08:38.620 --> 08:39.520
导入了他

08:39.820 --> 08:43.720
然后呢我又给他加了一个就是装饰器啊

08:43.720 --> 08:45.920
reflagdata

08:45.920 --> 08:47.820
加了一个转就是元数据啊

08:47.820 --> 08:48.920
就随便写一个吧

08:49.820 --> 08:50.620
就随便写一个

08:51.020 --> 08:52.220
你给他加了元数据

08:53.420 --> 08:55.320
给他呢也加了元数据啊

08:55.320 --> 08:56.320
都加了一些元数据

08:56.320 --> 08:57.320
随便加了一些

08:58.020 --> 08:59.720
然后我们现在编译一下啊

08:59.720 --> 09:01.620
编译一下看他生存的结果

09:03.660 --> 09:04.060
好

09:05.660 --> 09:06.360
可以啊

09:06.960 --> 09:08.060
npm转

09:08.760 --> 09:09.260
build

09:10.560 --> 09:12.360
啊编译看他生存的结果啊

09:14.650 --> 09:16.050
好在生存的结果里边

09:16.050 --> 09:17.950
我们找到这个index的介绍

09:18.150 --> 09:19.950
找到他看一下

09:21.350 --> 09:22.950
这些单码的乱七八糟的

09:22.950 --> 09:23.650
看上去呢

09:23.650 --> 09:25.750
好像不是很清楚啊

09:25.950 --> 09:27.450
好像不是很清楚

09:27.650 --> 09:28.550
没关系

09:28.650 --> 09:30.650
我们来看一下他下边这个单码

09:30.650 --> 09:32.150
就看他下边这个单码就行了

09:33.050 --> 09:35.550
这是我们家的元数据对吧

09:35.950 --> 09:37.850
看呗这是我们家的元数据

09:38.350 --> 09:38.850
啊

09:39.050 --> 09:40.150
加到哪的呢

09:40.250 --> 09:41.950
把这个元数据加到哪的呢

09:41.950 --> 09:43.650
加到优热的就是

09:43.950 --> 09:44.850
原型

09:45.250 --> 09:46.650
上面然后呢

09:46.650 --> 09:47.450
加那个啥呢

09:47.450 --> 09:48.250
哪个属性呢

09:48.250 --> 09:49.150
哪个成员呢

09:49.150 --> 09:50.650
挪进id这个成员

09:51.350 --> 09:51.750
这里呢

09:51.750 --> 09:53.150
我也加了个元数据

09:53.350 --> 09:53.750
然后呢

09:53.750 --> 09:55.050
加到这个这个属

09:55.050 --> 09:56.450
再加到这个原型上面

09:56.550 --> 09:57.850
然后哪个成员呢

09:57.850 --> 09:59.850
成员是A级

10:00.250 --> 10:00.950
年龄

10:02.050 --> 10:03.350
年龄元数据

10:03.950 --> 10:05.050
然后你会发现

10:05.050 --> 10:07.550
除了我们加了这个元数据之外

10:08.050 --> 10:09.850
他还给你加了个元数据

10:10.650 --> 10:12.050
他还给你加个元数据

10:12.350 --> 10:13.150
metadata

10:14.650 --> 10:16.350
他为什么会给你加这个元数据呢

10:16.650 --> 10:18.450
啊他为什么会给你加这个元数据呢

10:18.450 --> 10:20.350
就是因为你开启了这个东西

10:20.950 --> 10:22.950
开启的amnist decorator

10:23.350 --> 10:24.150
metadata

10:24.850 --> 10:26.950
当你开启了他的时候

10:27.550 --> 10:29.150
他会把什么东西加进去

10:29.150 --> 10:30.550
作为元数据加进去了

10:30.750 --> 10:31.450
他会把

10:32.550 --> 10:34.950
你这个字段的内型加进去

10:35.050 --> 10:36.850
你看我们之前是不是约束为制服串

10:36.850 --> 10:37.350
对吧

10:37.650 --> 10:38.850
把他约束为制服串

10:39.250 --> 10:39.950
然后呢

10:40.050 --> 10:41.350
他就把他加了一个

10:41.750 --> 10:43.850
加到这个把个制服串加进去了

10:44.550 --> 10:46.350
那么这个t值的值是什么呢

10:46.350 --> 10:48.050
就相当于是用这种方式加进去了

10:48.550 --> 10:50.350
t值的值t的值

10:50.550 --> 10:52.550
他的一个特殊的名字叫design

10:52.950 --> 10:54.350
冒号 type

10:54.550 --> 10:56.650
是他的特殊的特殊的一个建值

10:57.050 --> 10:58.050
这边也是一样

10:58.250 --> 10:59.350
对于A级这个属性

10:59.350 --> 11:01.150
他也加了一个元数据啊

11:01.650 --> 11:03.550
t值是design type

11:04.250 --> 11:05.650
值呢是number

11:06.850 --> 11:08.250
也就是说什么呢

11:08.950 --> 11:10.050
也就是说什么意思呢

11:10.350 --> 11:12.750
这样一来啊这样一来

11:14.150 --> 11:16.650
ts的内型检查

11:17.450 --> 11:19.950
内型检查啊

11:20.450 --> 11:21.550
或者叫做内型检查

11:21.550 --> 11:22.750
或者叫内型约束

11:23.950 --> 11:25.450
将有机会

11:26.550 --> 11:30.990
在运行时进行

11:32.790 --> 11:35.490
我们以前的内型检查也好

11:36.090 --> 11:37.690
内型约束也好

11:37.990 --> 11:40.090
全部是在编译的时胎

11:40.090 --> 11:41.690
就是运行的时候根本就没有了

11:41.690 --> 11:44.190
对吧我们之前也看过代码

11:44.390 --> 11:45.690
就是把它编译出来过后

11:45.690 --> 11:48.990
你会发现对他的内型约束全部消失了

11:49.590 --> 11:51.790
但是一旦有了元数据之后

11:51.990 --> 11:54.090
他可以把这些内型的信息

11:54.190 --> 11:55.690
放到元数据里边

11:55.690 --> 11:57.290
因为介石啊

11:57.290 --> 11:59.090
将来他一定会支持元数据的

11:59.190 --> 12:00.890
那就一定会支持装饰器的

12:01.090 --> 12:02.890
现在还没有成为一个正式的标准

12:02.990 --> 12:04.290
因此你看生成的代码

12:04.690 --> 12:06.390
生成的代码是没有装饰器的啊

12:06.390 --> 12:07.890
因为他现在还没有成为标准

12:07.990 --> 12:09.490
当他成为标准那一天

12:10.290 --> 12:11.590
我们可以想象得到

12:12.290 --> 12:13.890
就可以用这种方式

12:13.990 --> 12:16.890
把这些内型的信息放到元数据里边

12:17.290 --> 12:20.090
那么元数据是可以在运行的过程中

12:20.090 --> 12:21.090
读取到的

12:21.590 --> 12:22.390
也就是说

12:22.690 --> 12:23.590
这个地方呢

12:23.590 --> 12:26.390
我们为什么花那么多时间去讲这个装饰器

12:27.090 --> 12:28.690
这就意味着未来

12:28.890 --> 12:30.190
在不远的将来

12:30.290 --> 12:32.990
一旦元数据成为标准之后

12:33.090 --> 12:34.990
你看他现在已经在做这个事了

12:35.190 --> 12:37.090
只是呢现在做了

12:37.590 --> 12:40.690
很多第3方库还没有去真正的去使用他

12:40.690 --> 12:43.690
啊有一小部分库在使用使用这个东西

12:44.090 --> 12:46.190
因为他加了元数去是可以把读出来的

12:46.290 --> 12:48.090
可以读取这个罗写id的内型

12:48.090 --> 12:48.990
就是只不错

12:48.990 --> 12:49.890
可以把读出来的

12:50.390 --> 12:51.890
有一小部分的库

12:52.490 --> 12:54.290
都已经开始在用这个东西了

12:54.990 --> 12:58.090
可以想象到得到将来如果元数据

12:58.490 --> 13:00.390
或者叫这就是装饰器

13:01.190 --> 13:03.190
真正的成为标准之后呢

13:03.990 --> 13:06.490
那么ts他的内型检查

13:06.690 --> 13:08.590
是可以在运行时完成的

13:08.790 --> 13:10.590
不是说一定只能在编译试探

13:10.990 --> 13:13.190
在运行时现在就已经有这个机会了

13:13.190 --> 13:13.790
你看到没

13:13.990 --> 13:15.590
他已经把这个信息加入到

13:15.990 --> 13:17.190
加入到元数据了

13:17.590 --> 13:18.190
那么将来呢

13:18.190 --> 13:20.390
我们就可以读读他的运行的时候

13:20.390 --> 13:21.590
我们就可以读到啊

13:21.590 --> 13:23.690
你这个地方设计的时候啊

13:23.690 --> 13:24.590
设计的时候

13:24.590 --> 13:25.390
他的内详

13:26.290 --> 13:26.690
是什么呢

13:26.690 --> 13:27.390
是只不错

13:27.690 --> 13:28.390
设计的时候

13:28.390 --> 13:29.690
他的内详是

13:29.990 --> 13:30.590
Lumber

13:30.890 --> 13:32.690
我们就可以得到他原始的内型了

13:33.290 --> 13:34.090
明白这个意思吗

13:34.290 --> 13:34.890
说到这里呢

13:34.890 --> 13:36.090
大家了解一下啊

13:36.090 --> 13:38.590
目前的意义还不大啊

13:38.590 --> 13:39.490
意义还不大

13:39.490 --> 13:40.390
但将来呢

13:40.390 --> 13:42.490
我觉得我个人认为这个东西呢

13:43.090 --> 13:45.190
一定会成为一个非常重要的东西

13:46.490 --> 13:47.090
一切呢

13:47.090 --> 13:48.890
就等待等待什么呢

13:48.890 --> 13:52.490
等待装饰器成为正式的标准

13:53.390 --> 13:54.690
我觉得应该很快了啊

13:54.690 --> 13:55.990
不是今年下半年

13:55.990 --> 13:57.090
应该就是明年了

13:57.690 --> 13:58.590
我觉得大概不大

13:58.590 --> 14:00.190
大概率的话应该是今年

14:00.390 --> 14:02.490
大概率今年就能够成为标准了

14:03.490 --> 14:04.190
这是这一部分

14:04.190 --> 14:05.090
我补充一下啊

14:05.090 --> 14:06.290
就关于这个配置

14:06.490 --> 14:08.690
他可以让ts设计的内型

14:08.790 --> 14:10.190
就你这里设计的内型

14:10.490 --> 14:12.190
把它注入到元数据里面去

14:14.200 --> 14:14.400
好

14:14.400 --> 14:15.800
然后下一个啊

14:15.800 --> 14:18.400
下一个是关于lplp

14:18.600 --> 14:20.100
这是一种编程方式

14:20.900 --> 14:22.400
这是一种编程方式

14:23.200 --> 14:25.700
他是面向对向你开发的一种

14:27.900 --> 14:30.900
属于面向对向开发

14:31.900 --> 14:35.100
这种编程方式呢

14:35.100 --> 14:36.100
他指的是什么呢

14:36.400 --> 14:37.100
指的是

14:37.800 --> 14:38.300
将

14:39.800 --> 14:42.400
将一些在业务中

14:43.300 --> 14:46.100
共同出现的

14:46.800 --> 14:47.700
功能块

14:49.200 --> 14:50.000
分开

14:51.500 --> 14:52.500
横向切分

14:53.500 --> 14:54.700
横向切分

14:56.100 --> 14:56.800
以达到

14:57.900 --> 14:58.500
以达到

14:58.900 --> 15:00.800
分离关注点的目的

15:01.900 --> 15:03.300
说到很抽象

15:03.500 --> 15:04.400
具体是咋意思呢

15:04.400 --> 15:05.400
我给大家举个例子

15:05.900 --> 15:06.900
其实我们这个例子呢

15:06.900 --> 15:07.800
之前已经做过的

15:08.600 --> 15:09.300
什么例子呢

15:10.000 --> 15:10.600
比方这

15:12.580 --> 15:14.180
有一个用户

15:14.480 --> 15:15.580
比方说注册

15:16.180 --> 15:16.980
注册用户

15:18.960 --> 15:22.160
注册用户里边需要填写这么一些信息

15:23.060 --> 15:23.860
登录账号

15:25.760 --> 15:26.760
登录密码

15:29.160 --> 15:29.760
然后呢

15:31.060 --> 15:31.760
连银

15:32.760 --> 15:34.060
然后身份证号

15:34.660 --> 15:35.660
填写一大堆信息

15:36.860 --> 15:37.660
接下来呢

15:37.660 --> 15:39.660
我们要对这个注册的用户啊

15:40.860 --> 15:41.860
保存啊

15:41.860 --> 15:43.260
就是完成注册

15:43.460 --> 15:45.460
就是保存我们写个方法save

15:47.660 --> 15:48.660
写个方法save

15:49.560 --> 15:51.260
就是这个方法要做什么事情呢

15:52.560 --> 15:53.560
将用户

15:54.660 --> 15:56.660
保存到数据库

15:58.060 --> 15:59.960
好我们来研究一下这个场景啊

16:00.860 --> 16:03.660
当我们要去保存一个用户对象的时候

16:03.660 --> 16:06.260
就把当前那个用户对象保存到数据库

16:06.660 --> 16:08.460
我们要去做这件事的时候

16:09.260 --> 16:10.660
有一个前提条件

16:11.060 --> 16:12.360
就是他的验证呢

16:12.760 --> 16:14.060
必须要能够通过

16:14.160 --> 16:16.360
要能够通过验证才行啊

16:16.360 --> 16:18.160
比方说你的账号

16:18.160 --> 16:20.060
你没有起填写那不行

16:20.360 --> 16:21.860
你密码没有填写那不行

16:22.260 --> 16:24.360
连银为复述不行啊

16:24.360 --> 16:25.560
身份证号呢

16:25.560 --> 16:27.560
不格式不正确也不行

16:27.560 --> 16:29.560
比方还有邮箱啊邮箱

16:30.460 --> 16:31.360
懂这个意思吧

16:31.960 --> 16:34.160
好那么这里呢是不是要验证啊

16:34.160 --> 16:35.560
要进行验证处理

16:36.360 --> 16:38.060
好验证通过之后

16:39.860 --> 16:42.060
通过后保存数据库

16:43.560 --> 16:44.860
好我们这里呢

16:44.860 --> 16:46.360
重点关注验证

16:47.560 --> 16:49.660
验证了这个这个动作

16:49.760 --> 16:51.060
他是属于什么呢

16:51.460 --> 16:54.160
业务啊属于业务逻辑啊

16:54.160 --> 16:55.460
具体有什么样的验证规则

16:55.460 --> 16:57.660
不同的对象他有规则是不一样的

16:57.860 --> 16:59.660
这要看你开发的功能是什么

16:59.860 --> 17:01.660
因此他是跟功能相关的

17:01.660 --> 17:03.560
他是属于业务的翻筹

17:04.560 --> 17:06.760
但是呢这个功能呢是不是经常出现

17:07.460 --> 17:09.860
在我们整个系统中用户要验证

17:09.860 --> 17:11.560
你发布文章就不验证了吗

17:11.660 --> 17:13.160
发布文章也得验证啊

17:13.360 --> 17:16.860
啊在比方说你发布评论也得验证啊

17:16.860 --> 17:18.260
你上传一个图片啊

17:18.260 --> 17:20.260
还要验证图片的格式大小

17:20.260 --> 17:22.060
对吧尺寸也得验证

17:22.360 --> 17:23.560
我们这个验证呢

17:23.560 --> 17:26.060
你会发现整个我们的业务功能中

17:26.360 --> 17:27.760
经常都出现

17:28.460 --> 17:29.760
经常都出现的问题

17:29.760 --> 17:31.760
而且这个代码还非常繁琐

17:32.360 --> 17:33.160
很繁琐的

17:33.160 --> 17:35.060
你看别看这里只有五个属性

17:35.060 --> 17:36.160
你一个个来呗

17:36.360 --> 17:37.360
全部都要飞空

17:38.160 --> 17:39.260
五个判断跑不了

17:39.960 --> 17:42.560
然后这里还有支付出长度的限制

17:42.560 --> 17:43.160
跑不了

17:43.360 --> 17:44.660
有可能还有证者表达是

17:44.760 --> 17:46.260
那又是个判断跑不了

17:46.360 --> 17:48.460
要写一大堆代码的进行验证

17:48.960 --> 17:50.860
一是非常非常繁琐

17:51.160 --> 17:53.360
二是呢有很多的验证呢

17:53.360 --> 17:54.960
他的规则都是共通的

17:55.660 --> 17:58.460
所以说我们本来是中向的

17:58.760 --> 18:00.160
来看待这个业务的

18:00.160 --> 18:02.960
就这个业务一开始做什么再做什么再做什么

18:02.960 --> 18:04.160
是一个中向的过程

18:04.660 --> 18:05.460
从上到下

18:05.560 --> 18:06.460
这么一个过程

18:06.960 --> 18:09.460
我们把其中一块抽离出来

18:10.160 --> 18:11.560
哪一块呢比方说就验证

18:12.060 --> 18:13.060
验证的功能呢

18:13.060 --> 18:14.560
我们专门把它抽离出来

18:14.560 --> 18:15.960
因为这一块一是复杂

18:15.960 --> 18:17.260
二是经常都要用

18:17.760 --> 18:18.460
三是呢

18:18.760 --> 18:20.060
写起来非常繁琐

18:20.660 --> 18:21.660
因此而且

18:21.860 --> 18:24.160
这一块他本来就可以抽离出来了

18:24.260 --> 18:26.160
因此我们可以把这一块功能

18:26.660 --> 18:27.960
无论你是发布文章

18:28.260 --> 18:31.060
还是填写评论还是注册用户

18:31.260 --> 18:32.660
还是填写一个什么表达

18:33.160 --> 18:34.860
他们里面都有一些共同的东西

18:34.860 --> 18:38.560
于是我们把整个的验证处理全部抽离出来

18:39.160 --> 18:40.660
那么我们可以认为

18:40.760 --> 18:42.760
就像你可以把整个业务呢

18:42.760 --> 18:46.260
想象成一个从上到下的一个垂直的东西

18:46.960 --> 18:48.560
然后把其中一块啊

18:48.560 --> 18:49.360
一个小块

18:49.860 --> 18:50.760
验证这一块

18:50.760 --> 18:52.160
它是这个垂直的一部

18:52.260 --> 18:53.760
垂直业务的一部分

18:53.860 --> 18:54.860
把它抽离出来

18:55.160 --> 18:57.260
你可以把它看成是一个切面

18:58.060 --> 18:58.960
在这个切面上

18:58.960 --> 19:00.660
我们只关心验证

19:00.860 --> 19:02.460
其他的东西都不管

19:02.760 --> 19:03.960
其他东西你自己去处理

19:04.060 --> 19:06.660
我不管我只关心这个切面上的验证

19:07.260 --> 19:08.760
这就是面向切面面层

19:08.960 --> 19:11.260
怎么抽离出来就要考装时期

19:11.660 --> 19:12.860
你看我们之前是不是做过的

19:13.060 --> 19:15.060
我来这里配置验证规则啊

19:15.860 --> 19:17.260
配置各种验证规则

19:17.960 --> 19:21.060
然后谁来完成验证

19:21.560 --> 19:23.460
我这只是在配置规则而已

19:23.560 --> 19:24.460
谁在完成验证

19:24.460 --> 19:25.760
有另外一个方法

19:25.960 --> 19:27.560
validate是吧

19:27.560 --> 19:28.060
对吧

19:28.560 --> 19:30.360
有另外一个方法来完成验证

19:30.560 --> 19:32.860
那么这个方法就是从这个业务中

19:32.860 --> 19:34.260
抽离出来的方法

19:35.060 --> 19:36.860
这样子一抽离的好处在于

19:37.260 --> 19:38.460
重复代码没了

19:38.960 --> 19:40.060
重复代码就是这样

19:40.060 --> 19:41.560
你重复了一去验证的一些代码

19:41.560 --> 19:43.860
判断循环这些东西全部没了

19:44.160 --> 19:44.860
全部抽离出来

19:44.860 --> 19:47.460
形成了一个公共的函数

19:48.460 --> 19:49.560
然后这个方法呢

19:49.760 --> 19:51.260
只处理数据库

19:51.260 --> 19:52.760
只要你验证通过啊

19:52.860 --> 19:54.160
只要你我们可以在这里

19:55.260 --> 19:55.960
判断一下啊

19:55.960 --> 19:57.560
如果validate啊

19:57.960 --> 19:59.660
z把当事件对象团进去

19:59.860 --> 20:00.960
如果验证通过

20:01.160 --> 20:02.460
保存数据库就完事了

20:02.960 --> 20:04.260
那么具体怎么去验证

20:04.960 --> 20:06.060
已经抽离出去了

20:06.760 --> 20:08.660
这个验证的就可以看成是

20:09.260 --> 20:12.760
一套复杂的业务逻辑的一个横切面

20:13.160 --> 20:15.060
啊我们只关心这个横切面

20:15.460 --> 20:16.860
然后剩下的事情呢

20:17.260 --> 20:19.360
啊你该怎么处理怎么处理

20:19.860 --> 20:21.460
我把这个把这个横切面

20:21.560 --> 20:22.360
提序出来

20:22.360 --> 20:23.560
这就是lp

20:24.460 --> 20:27.460
啊在一些业务中出现了共同的出现的

20:27.460 --> 20:30.260
功能块然后验证进行横向切分

20:30.360 --> 20:31.360
把这个提出来

20:31.660 --> 20:33.260
然后形成一个单独的模块

20:33.660 --> 20:34.460
那么这样子呢

20:34.460 --> 20:36.460
就达到了分离关注点的目的

20:36.860 --> 20:38.060
为什么要分离关注点

20:38.260 --> 20:40.860
我们关注点关注的越精准越好

20:41.260 --> 20:44.560
我们关注点关注的功能越少越好

20:44.960 --> 20:45.860
如果你想啊

20:45.860 --> 20:47.560
一个函数里面要做很多很多的事

20:47.560 --> 20:48.960
那这个函数一定很复杂

20:49.260 --> 20:50.760
如果这个函数只做一件

20:50.860 --> 20:52.160
那么一件事情的话

20:52.960 --> 20:54.060
关注点很集中

20:54.160 --> 20:55.060
我们写这个函数呢

20:55.060 --> 20:57.160
也会变得非常容易不太容易出错

20:57.760 --> 21:00.360
好这个函数本来要做很多很多大量的验证的

21:00.360 --> 21:02.160
但是验证我现在不关了

21:02.360 --> 21:03.760
我只需要去调整一下这个方法

21:03.760 --> 21:05.360
来完成通过验证就行了

21:05.560 --> 21:07.260
好剩下的事情呢我就接着处理

21:07.360 --> 21:09.360
我只处理保存数据库

21:09.760 --> 21:10.560
那么这个函数呢

21:10.560 --> 21:12.860
一下子就变得非常非常简单了

21:13.460 --> 21:16.760
好这也是面向对向里边的一个思想啊

21:16.760 --> 21:18.860
给大家介绍一下啊介绍一下

21:19.160 --> 21:21.160
拓展一下知识面叫做aop

21:21.160 --> 21:22.660
啊他的全称呢叫做

21:24.160 --> 21:25.060
aspect

21:25.960 --> 21:26.660
aspect

21:27.260 --> 21:29.860
啊然后是orated

21:30.460 --> 21:33.360
rented表示面向什么东西啊

21:33.360 --> 21:35.860
我们知道面向对象是oriented object

21:35.860 --> 21:37.560
对吧这个是aspect

21:37.560 --> 21:38.960
aspect就是切面的意思

21:38.960 --> 21:40.260
一个层面的意思

21:40.460 --> 21:42.260
只处理其中一个层面

21:43.260 --> 21:44.960
oriented programming

21:45.660 --> 21:46.960
programming

21:47.960 --> 21:49.960
啊这是他的全称啊aop

21:50.160 --> 21:51.260
了解一下就行了啊

21:52.260 --> 21:53.460
好ok啊咱们

21:54.360 --> 21:56.460
装饰器这一张就结束了啊

21:56.460 --> 21:58.460
终点是然而终点是然内

21:58.960 --> 21:59.660
成员

22:00.160 --> 22:00.760
以及呢

22:01.260 --> 22:02.460
很重要的这么一个库

22:03.260 --> 22:04.060
啊下面两个库呢

22:04.060 --> 22:05.060
大家也要熟悉

22:05.060 --> 22:06.860
因为我们后边的项目实战里边

22:07.160 --> 22:07.760
要用到

22:08.360 --> 22:09.760
有了装饰器过后呢

22:09.760 --> 22:11.260
至少啊你能够

22:12.060 --> 22:13.260
实际的体会到

22:13.360 --> 22:16.260
怎么了就是我们验证是不是变得简单了

22:16.460 --> 22:19.060
验证的我们只需要在那里面去配置规则啊

22:19.060 --> 22:21.860
用那个库用的用这个库就可以搞定了

22:22.260 --> 22:24.660
以后呢要做平面对象

22:24.960 --> 22:27.160
和那个就是

22:27.860 --> 22:29.360
类的对象的转换的话

22:29.360 --> 22:30.360
可以使用这个库

22:30.860 --> 22:32.360
如果要制定一些

22:32.760 --> 22:34.560
元数据的话可以使用这个库

22:34.960 --> 22:36.260
啊我们至少呢

22:36.260 --> 22:38.460
你得学会这些库该如何去使用

22:39.160 --> 22:41.760
好了那么本张的知识到时结束了啊

22:42.360 --> 22:42.960
拜拜

