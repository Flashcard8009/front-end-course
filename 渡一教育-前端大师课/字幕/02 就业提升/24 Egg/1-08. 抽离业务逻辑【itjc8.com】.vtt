WEBVTT

00:00.110 --> 00:03.950
这节课咱们讲一讲那个业务逻辑层啊

00:03.950 --> 00:10.610
之前呢我打算了把业务逻辑层和那个数据访问层就数据库相关的东西呢

00:10.610 --> 00:12.650
放到一个章节里面

00:12.650 --> 00:17.010
但想来想去好像也没有什么复杂的啊就干脆直接弄到第一章了

00:17.010 --> 00:23.410
首先我们回归一下三层架构啊以及我们现在不是学了MVC嘛对吧

00:23.410 --> 00:28.770
搞清楚了啊三层架构跟MVC到底有什么区别呢啊他们之间有什么关系呢

00:28.770 --> 00:33.890
实际上他们之间谈区别不要去谈这个问题因为他们之间就不是一个东西

00:33.890 --> 00:35.430
完全不是一码事

00:35.430 --> 00:36.970
是怎么回事呢是这样子啊

00:36.970 --> 00:38.750
咱们的三层架构呢

00:38.750 --> 00:41.570
就是一个试图层对吧试图层主要负责什么

00:41.570 --> 00:43.870
负责负责跟那个

00:43.870 --> 00:50.530
提供接口啊或者是提供就进行渲染总之跟界面相关对吧来处理请求等等等等

00:50.530 --> 00:53.610
事情的都在试图层去完成

00:53.610 --> 00:58.730
业务逻辑层呢他主要负责处理业务逻辑啊比方说什么登陆驻车啊

00:58.730 --> 01:01.050
过去那个什么地区啊等等等等

01:01.050 --> 01:04.610
数据访问层的主要是负责跟数据库打交道

01:04.610 --> 01:05.890
这就是三层架构

01:05.890 --> 01:07.950
那我们的MVC是什么东西呢

01:07.950 --> 01:13.330
MVC呢他是在试图层里边东西啊我们把试图层进一分化有一个

01:13.330 --> 01:18.710
部分的C他专门用来处理请求啊一个v呢他专门用来进行模办引擎

01:18.710 --> 01:24.070
选啊提供模办引擎来渲染业面一个M呢他主要来组装数据啊

01:24.070 --> 01:27.650
那么这个数据呢他可以是数据库来这个数据库但是呢也可以来

01:27.650 --> 01:32.770
来自于业务逻辑层也可以来自于自己去组装无所谓但他这里的含义一定是跟

01:32.770 --> 01:34.310
试图相关的

01:34.310 --> 01:35.590
没有意思吧

01:35.590 --> 01:36.350
有些

01:36.350 --> 01:39.670
教程里边呢有些视频里边就是

01:39.670 --> 01:41.730
解释的不是很清楚啊

01:41.730 --> 01:42.750
说这个M

01:42.750 --> 01:45.310
啊就是数据层你可以是

01:45.310 --> 01:48.630
但是就算你跟那个数据访问层的模型一模一样

01:48.630 --> 01:49.930
哪怕一模一样

01:49.930 --> 01:51.970
但是呢他的含义都不一样

01:51.970 --> 01:56.070
含义是什么这里的模型是指的是交给试图去宣传的模型

01:56.070 --> 01:57.610
他叫做UI模型

01:58.590 --> 02:00.270
好这里给他区分一下

02:00.270 --> 02:01.810
那么这里呢

02:01.810 --> 02:05.850
就说一道啊有一个理论性的东西了就是

02:05.850 --> 02:08.310
MVC是用来干嘛的

02:08.310 --> 02:12.410
其实咱们软件工程里边很多地方的设计也好思想也好

02:12.410 --> 02:14.150
他都是为了降低复杂度

02:14.150 --> 02:16.410
但降低复杂度呢有很多方式

02:16.410 --> 02:18.810
比方说最常见的就是解呕对不对

02:18.810 --> 02:21.970
把呕和解开你看是多成里边不是有很多事情吗

02:21.970 --> 02:24.630
处理请求啊路由匹配

02:24.630 --> 02:26.110
模型宣啊模型

02:26.570 --> 02:29.530
获取还有什么那个试图宣展

02:29.530 --> 02:31.290
对吧有很多很多的事情

02:31.290 --> 02:34.330
那么这件事情呢我尽量把它分开啊分开去做

02:34.330 --> 02:38.010
尽量让他们不要产生过强的呕和

02:38.010 --> 02:40.890
那么一块东西出了问题或者是一块东西的改变

02:40.890 --> 02:44.210
不会影响到另外一块东西啊主要是出于这么一个目的

02:44.210 --> 02:46.450
于是呢在试图程形成了MVC模式

02:48.250 --> 02:51.970
我们在服务器端如果说使用了MVC模式主要都是为了

02:51.970 --> 02:55.010
降低服务端宣展的复杂度

02:55.070 --> 02:56.470
主要是出于这么一个目的

02:57.110 --> 03:00.790
那如果说我不使用服务端宣展

03:00.790 --> 03:03.470
我就使用单眼用程去的原式的模式

03:03.470 --> 03:07.390
有没有必要用MVC呢可以用也可以不用

03:07.390 --> 03:10.190
那如果说你用的话至少这个V它不存在了

03:11.710 --> 03:14.990
是不是不存在这个V的啊或者是这个V是极度弱化了

03:14.990 --> 03:17.710
对不对因为不需要你服务端去宣展任何东西的

03:17.710 --> 03:19.070
你把清台页面给我就行了

03:19.070 --> 03:20.550
然后全部交给界也是去宣展

03:22.390 --> 03:23.950
这是这个MVC

03:24.010 --> 03:25.850
那为什么要去使用三层架构呢

03:25.850 --> 03:28.690
三层架构是为了降低整个系统的复杂度

03:28.690 --> 03:31.610
你看整个系统从更高的角度来看

03:31.610 --> 03:33.210
看整个系统的话

03:33.210 --> 03:34.610
我们就把MVC直接忽略了

03:34.610 --> 03:37.610
我就看我就认为整个是跟试图相关的操作

03:37.610 --> 03:40.050
跟业务逻辑相关的操作跟数据相关的操作

03:40.050 --> 03:42.650
对吧在整个系统层面来进行分化

03:44.050 --> 03:46.850
这就是咱们也学到后边啊

03:47.690 --> 03:51.210
特别是工作几年之后也想往价格方向发展

03:51.210 --> 03:57.750
你会越来越感觉到整个软件的设计上啊

03:57.750 --> 04:00.310
就是先从一个非常非常高的角度去看它

04:00.310 --> 04:01.350
它变得极其简单

04:01.350 --> 04:03.470
一个三层架构的图都非常非常简单

04:03.470 --> 04:04.750
极其简单

04:04.750 --> 04:08.830
然后针对每一个整体的划分里边

04:08.830 --> 04:10.590
到了每一个划分部分

04:10.590 --> 04:12.310
然后进一步进一分化

04:12.310 --> 04:13.670
就是大问题一转小问题

04:13.670 --> 04:15.510
小问题再转小问题

04:15.510 --> 04:17.150
然后就变成一个完整的系统

04:18.130 --> 04:21.690
整个大型架构也无非就是这么一种过程

04:21.690 --> 04:23.930
但是这里边是遇到很多的知识

04:25.370 --> 04:28.370
这是关于三层架构MVC我说一下

04:28.370 --> 04:31.130
接下来我们说一下这个在AIR中处理业务逻辑

04:33.210 --> 04:36.450
就是我们在之前在AIR里边只有个MVC

04:36.450 --> 04:37.490
它没有什么三层架构

04:37.490 --> 04:38.810
没有业务逻辑层

04:38.810 --> 04:41.010
没有业务逻辑层会出一个什么问题呢

04:41.010 --> 04:41.890
那假设有一天

04:42.850 --> 04:46.050
你看我们在这里玩的挺Happy的在这里

04:48.050 --> 04:49.050
做远程访问

04:49.050 --> 04:51.050
远程访问去拿数据

04:51.050 --> 04:53.130
那这个东西是不是跟业务就偶和了

04:53.130 --> 04:54.690
你凭什么知道是远程访问的

04:54.690 --> 04:56.410
那万一我们现在要存数据库呢

04:57.850 --> 05:00.170
当然如果说你这里用到了远程访问

05:00.170 --> 05:03.250
一般来说你的公司里边都是有专业的后端的

05:03.250 --> 05:06.810
他们做了后端服务器提供了业务逻辑

05:06.810 --> 05:09.010
他们把业务逻辑给你做完了

05:09.010 --> 05:11.690
那么这个时候需不需要业务逻辑层呢

05:11.690 --> 05:12.730
那就看具体情况

05:12.730 --> 05:14.650
我觉得没有什么必要了

05:14.650 --> 05:16.050
三层架构没有什么必要了

05:16.070 --> 05:18.230
因为你的数据库呢比较简单

05:18.230 --> 05:20.950
主要是处理业非业务类的数据库

05:20.950 --> 05:22.350
你的业务逻辑也没有

05:22.350 --> 05:22.550
对吧

05:22.550 --> 05:24.990
你写什么业务逻辑层的就个MVC够了

05:26.030 --> 05:29.670
那如果说整个系统都是你要里面前端来写

05:29.670 --> 05:31.070
因为公司太小了

05:31.070 --> 05:34.430
你后端都没有全部前端搞定吧

05:34.430 --> 05:36.110
而且呢这个项目也不复杂

05:36.110 --> 05:37.990
可能你做一些业务逻辑

05:37.990 --> 05:38.750
那么那个时候呢

05:38.750 --> 05:41.270
你再去考虑要不要写一个业务逻辑层啊

05:41.270 --> 05:43.150
当然了我建议你书写

05:43.170 --> 05:44.090
但在Agg里面呢

05:44.090 --> 05:47.210
因为他是做一个大型的服务器应用的

05:47.210 --> 05:48.970
这么一套方案

05:48.970 --> 05:50.810
所以他肯定要考虑这一点

05:50.810 --> 05:51.690
包括业务逻辑

05:51.690 --> 05:53.010
包括我们后边还要说的数据库

05:53.010 --> 05:54.170
他都要考虑进去

05:54.170 --> 05:55.770
他全部要把它进行标准化

05:55.770 --> 05:56.690
我们说个Agg

05:56.690 --> 05:58.170
他就是一套标准的流程

05:58.170 --> 05:59.170
其他没啥了

05:59.890 --> 06:00.610
他怎么做的呢

06:00.610 --> 06:03.490
他就是让你呢创建了业务逻辑的时候呢

06:03.490 --> 06:04.970
创建就是创建Service

06:04.970 --> 06:07.010
在哪里创建了固定地方

06:08.290 --> 06:09.610
固定地方在这

06:09.610 --> 06:10.770
Service

06:10.770 --> 06:11.330
服务

06:12.310 --> 06:13.150
业务的服务

06:14.230 --> 06:15.550
那么这个里边就写啥了

06:15.550 --> 06:16.590
就写模块

06:17.310 --> 06:19.630
一个模块就是一个服务

06:19.630 --> 06:21.030
就是一个业务逻辑

06:21.030 --> 06:22.310
那每一个服务市场呢

06:22.310 --> 06:23.230
我们看一下这里的蛋吧

06:23.230 --> 06:24.190
过来我们直接扶着过来

06:25.470 --> 06:26.430
点零零零星间啊

06:26.430 --> 06:26.750
楼口

06:28.510 --> 06:29.470
站过来你看一下吧

06:30.390 --> 06:31.750
怎么写的写的方式呢

06:31.750 --> 06:33.150
非常非常简单

06:33.150 --> 06:34.270
导入一个Agg

06:34.270 --> 06:35.150
Agg里边他提供了

06:35.150 --> 06:36.990
之前一个里边说提供了一个Controller

06:36.990 --> 06:37.310
对不对

06:37.310 --> 06:39.030
现在提供Service

06:39.030 --> 06:39.550
这是个什么

06:39.550 --> 06:40.830
这是个内

06:40.890 --> 06:42.250
然后呢我们去继承它

06:42.250 --> 06:42.690
对吧

06:42.690 --> 06:43.090
最后呢

06:43.090 --> 06:44.530
把这个继承的内导出

06:44.530 --> 06:46.530
这就是我们的业务逻辑内

06:46.530 --> 06:47.930
当然那你也可以这样子写

06:48.690 --> 06:49.650
你是不是可以这样子写

06:50.850 --> 06:51.650
写个匿名的

06:52.850 --> 06:54.170
跟那个Controller写一样

06:54.170 --> 06:55.330
尽量减减嘛

06:55.330 --> 06:56.570
是不是可以这样子写都行啊

06:56.570 --> 06:57.690
都行

06:57.690 --> 07:00.010
那么这里边就是提供各种方法

07:00.010 --> 07:00.490
对吧

07:00.490 --> 07:01.690
提供各种方法

07:01.690 --> 07:03.250
然后我们获取所有的省份

07:03.250 --> 07:04.370
我们这里边不是用到了

07:04.370 --> 07:05.650
获取所有省份吗

07:05.650 --> 07:06.050
对不对

07:06.050 --> 07:07.930
获取所有省份是不是拿到了

07:07.930 --> 07:09.210
当然那同理呢

07:09.270 --> 07:10.950
我们还可以写别的业务逻辑

07:10.950 --> 07:11.790
业务逻辑的模块

07:12.430 --> 07:14.510
这就是业务逻辑

07:14.510 --> 07:15.910
那么通过这个代码的阅读

07:15.910 --> 07:17.910
我们可以看到有这么一些特点

07:17.910 --> 07:19.310
首先Service这个模块

07:19.310 --> 07:20.590
必须放在那个目录

07:20.590 --> 07:21.510
AppService里边

07:21.510 --> 07:22.310
跟Controller一样

07:22.310 --> 07:23.870
有一个专门的目录

07:23.870 --> 07:24.590
然后呢

07:24.590 --> 07:26.150
Service模块必须要导出一个

07:26.150 --> 07:27.990
继承至Service的内

07:27.990 --> 07:29.110
必须要导出这个内

07:29.110 --> 07:30.830
那么这个内有什么用呢

07:30.830 --> 07:33.150
Agg他会在每一次请求

07:33.150 --> 07:34.030
注意时间点

07:34.030 --> 07:35.510
他不是全局的

07:35.510 --> 07:38.110
他是每一次请求到达到过后

07:38.130 --> 07:39.850
他会创建这个内的实力

07:40.890 --> 07:42.010
他会去溜一下这个内

07:43.450 --> 07:44.330
就创建这个实力

07:45.370 --> 07:45.930
然后呢

07:45.930 --> 07:47.850
我们在内里边呢

07:47.850 --> 07:49.050
因为他继承至Service

07:49.050 --> 07:50.090
所以他继承至Service

07:50.090 --> 07:51.370
Service里面包含了一些属性

07:51.370 --> 07:52.250
你就可以用了

07:52.250 --> 07:53.410
在这里边是可以用的

07:53.410 --> 07:54.090
什么属性呢

07:54.090 --> 07:55.690
Context不解释了吧

07:56.490 --> 07:57.570
App不解释吧

07:57.570 --> 07:59.570
Agg的全局应用

07:59.570 --> 08:00.410
这是Context

08:00.410 --> 08:02.290
为什么他能过去到Context

08:02.290 --> 08:04.050
因为他是每一次请求创建

08:04.050 --> 08:04.810
而每一次请求

08:04.810 --> 08:05.930
就是一个商家文

08:05.930 --> 08:06.410
对吧

08:06.410 --> 08:07.930
所以他能过去到Context

08:07.990 --> 08:09.470
然后Config配置

08:09.470 --> 08:10.430
是不是都可以用

08:10.430 --> 08:12.390
你看我们这里边是不是用到App

08:12.390 --> 08:13.350
里边是有Agg小时

08:13.350 --> 08:14.790
我们之前注入的对吧

08:14.790 --> 08:17.430
在App.js里面是注入的Agg小时

08:17.430 --> 08:19.110
然后这里边使用的是Config

08:19.110 --> 08:20.630
都可以用的这里边

08:20.630 --> 08:21.990
这还可以用Context都可以用

08:23.110 --> 08:25.150
然后我这里得到省份过后就返回

08:26.030 --> 08:26.990
那么同样的例子呢

08:26.990 --> 08:29.230
我们就可以在这里边来写上一些别的

08:29.230 --> 08:29.830
比较多

08:29.830 --> 08:32.630
我们在控制器里边

08:32.630 --> 08:34.030
还用了哪些业务逻辑

08:34.030 --> 08:36.110
是不是要获取什么

08:36.110 --> 08:38.450
获取那个做登录

08:38.450 --> 08:39.810
登录是不是一个业务逻辑

08:39.810 --> 08:40.970
一个典型的业务逻辑

08:40.970 --> 08:41.610
对吧

08:41.610 --> 08:42.770
用户登录

08:42.770 --> 08:44.010
还有什么呢

08:46.130 --> 08:47.770
用户登录

08:48.890 --> 08:50.130
一个登录

08:50.130 --> 08:51.930
没有助销类似的吧

08:51.930 --> 08:53.170
没有了吧

08:53.170 --> 08:54.210
还包括那个什么了

08:54.210 --> 08:55.570
还包括那个就是

08:57.370 --> 08:57.930
互安曼

08:57.930 --> 08:58.330
对吧

08:58.330 --> 08:59.450
我是谁

08:59.450 --> 09:00.810
这些东西那我都把它写到业

09:00.810 --> 09:02.130
受到服务层

09:02.130 --> 09:03.850
都是业务逻辑

09:03.850 --> 09:05.090
那么专业的

09:05.110 --> 09:07.390
专业的成本来做专业的事情

09:07.390 --> 09:09.190
我们这里的导出

09:09.190 --> 09:10.590
这边我们提供两个方法

09:10.590 --> 09:12.590
一个是登录

09:12.590 --> 09:13.270
你给我一个什么

09:13.270 --> 09:14.950
login id 账号

09:14.950 --> 09:17.110
一个login password

09:17.110 --> 09:18.470
给我一个账号立马

09:18.470 --> 09:20.110
那么我来进行登录

09:20.110 --> 09:20.270
好

09:20.270 --> 09:20.790
那么这边呢

09:20.790 --> 09:23.630
我们把之前的代码稍微copy一下

09:23.630 --> 09:24.310
登录

09:24.310 --> 09:24.830
哎呀啊

09:26.030 --> 09:27.070
这是UL地址

09:28.110 --> 09:28.630
登录成功

09:28.630 --> 09:29.150
登录出来

09:29.150 --> 09:29.870
复制过来吧

09:29.870 --> 09:30.230
复制过来

09:30.230 --> 09:30.750
我再慢慢改

09:31.730 --> 09:33.850
它生产一个UL地址

09:33.850 --> 09:35.570
请求这里

09:35.570 --> 09:36.250
这里

09:36.250 --> 09:36.810
然后呢

09:36.810 --> 09:37.610
这个post

09:37.610 --> 09:38.530
UL

09:38.530 --> 09:39.450
这边呢

09:39.450 --> 09:40.890
这边是request body

09:40.890 --> 09:43.250
这边应该尽量避免跟请求相关

09:44.370 --> 09:44.890
这边呢

09:44.890 --> 09:46.730
就是生产一个login id

09:46.730 --> 09:48.730
login password

09:48.730 --> 09:50.250
我这里没有去验证

09:50.250 --> 09:51.690
也没去做业务逻辑验证

09:52.570 --> 09:54.170
因为我这里本身就没有处理业务

09:54.170 --> 09:56.090
你都是交给别的服务器处理

09:56.090 --> 09:56.610
对吧

09:56.610 --> 09:57.890
都要真正的后端处理的

09:58.870 --> 10:00.670
这边得到

10:00.670 --> 10:02.590
如果说有数据

10:04.430 --> 10:05.110
如果说有数据

10:05.110 --> 10:06.910
我们在这里先解一下吧

10:08.350 --> 10:12.240
这是不好看

10:12.240 --> 10:13.840
先因为或许到它的data

10:13.840 --> 10:15.640
直接或许到它的data

10:15.640 --> 10:17.440
那么这边直接看code

10:17.440 --> 10:18.560
如果code是有值的话

10:18.560 --> 10:19.840
是登录失败的

10:19.840 --> 10:20.400
对不对

10:20.400 --> 10:21.520
那么登录失败的话

10:21.520 --> 10:23.600
到底具体什么原因失败

10:23.600 --> 10:24.840
具体什么原因失败

10:24.840 --> 10:25.840
那我们这里就

10:26.680 --> 10:28.440
就直接返回Force

10:28.440 --> 10:29.120
表示登录失败

10:30.720 --> 10:33.120
可能我就会把整个返回

10:33.120 --> 10:34.480
我就把整个返回

10:34.480 --> 10:35.760
算了算了

10:35.760 --> 10:36.760
就返回Force

10:36.760 --> 10:37.320
登录失败

10:39.320 --> 10:40.080
看一下

10:40.080 --> 10:40.720
这里就去了了

10:42.080 --> 10:44.440
然后要是登录成功

10:44.440 --> 10:45.040
登录成功的话

10:45.040 --> 10:46.240
我把整个用户返回

10:49.520 --> 10:50.440
把整个用户返回

10:50.440 --> 10:51.680
总之你们自己去测试一下

10:51.680 --> 10:52.200
自己去写

10:53.040 --> 10:54.160
登录

10:54.160 --> 10:55.560
然后还有个什么呢

10:55.560 --> 10:57.240
还有就是户外卖

10:57.240 --> 10:57.760
我是谁

10:59.040 --> 10:59.520
我是谁

10:59.840 --> 11:00.560
你给我一个什么了

11:00.560 --> 11:01.200
给我一个token

11:03.400 --> 11:05.080
我来判断我到底是谁

11:05.080 --> 11:06.120
我给你返回一个用户

11:06.120 --> 11:07.160
如果说

11:07.160 --> 11:08.200
不存在这样的用户

11:08.200 --> 11:09.840
或者是默契等等的原因

11:09.840 --> 11:10.280
我就可以返回

11:10.280 --> 11:11.040
我给你返回

11:11.040 --> 11:12.200
我是谁

11:12.200 --> 11:13.760
然后我这边把这个复制一下

11:14.960 --> 11:15.760
稍微感动一下

11:17.600 --> 11:18.800
这边呢

11:18.800 --> 11:19.840
就不是或许哭泣了

11:19.840 --> 11:21.520
token就已经传过来了

11:21.520 --> 11:22.880
如果说没有这个token

11:22.880 --> 11:24.280
没有这个token的话

11:24.280 --> 11:25.240
那么我是谁

11:25.240 --> 11:25.680
我是哪儿

11:28.230 --> 11:28.710
谁也不是

11:30.030 --> 11:30.790
然后接下来

11:30.810 --> 11:32.810
我就是去获取通用员成获取

11:33.810 --> 11:34.290
Yes

11:36.800 --> 11:38.320
这里请求这个例子

11:38.320 --> 11:38.720
然后呢

11:38.720 --> 11:40.920
headers里边加上一个token

11:40.920 --> 11:41.800
获取到结构

11:41.800 --> 11:42.600
如果说这个

11:43.400 --> 11:45.360
data code有值表示有错误

11:45.360 --> 11:46.200
有错误的话

11:46.200 --> 11:46.920
那么我是谁呢

11:46.920 --> 11:47.360
我是哪儿

11:49.240 --> 11:50.400
是有问题的

11:50.400 --> 11:52.240
如果说没有值的话

11:52.240 --> 11:54.080
如果说没有问题

11:54.080 --> 11:54.680
没有问题的话

11:54.680 --> 11:55.400
我就给你返回

12:00.440 --> 12:01.760
户外卖是不是写好了

12:01.820 --> 12:04.620
就把这些东西处理的全部放到业务逻辑

12:04.620 --> 12:06.340
那么将来一个好处是什么呢

12:06.340 --> 12:07.620
将来如果说

12:07.620 --> 12:09.820
我不是后端处理的

12:09.820 --> 12:12.100
后端可能人缘离职了

12:12.100 --> 12:14.100
我现在要你前端自己去做数据库

12:14.100 --> 12:15.460
自己来维护

12:15.460 --> 12:17.140
那么这些就不再是远程寝宴了

12:17.140 --> 12:18.580
你变成个数据库打交道了

12:18.580 --> 12:18.940
对不对

12:20.140 --> 12:21.060
是不是这里要改

12:21.060 --> 12:22.940
那么又需不需要动controller

12:22.940 --> 12:24.100
需不需要动mvc里边

12:24.100 --> 12:24.660
任何东西

12:24.660 --> 12:25.500
不需要

12:25.500 --> 12:27.900
你只需要改动这个业务逻辑就可以了

12:27.900 --> 12:28.940
对吧

12:28.940 --> 12:29.900
你要那意思

12:29.900 --> 12:30.580
就是什么意思

12:31.560 --> 12:32.560
你懂的

12:32.560 --> 12:33.880
那么创建好了

12:33.880 --> 12:34.880
service过后

12:34.880 --> 12:36.360
你就可以使用service

12:36.360 --> 12:37.000
怎么使用了

12:37.000 --> 12:38.320
非常非常简单

12:38.320 --> 12:40.000
每一个请求过来过后

12:40.000 --> 12:41.480
看到这里边有几个service

12:41.480 --> 12:43.280
它就创建几个service的实力

12:43.280 --> 12:45.360
然后把这些实力全部保存到contact

12:45.360 --> 12:46.680
service里边

12:46.680 --> 12:47.680
比方说

12:47.680 --> 12:49.160
咱们的app文件夹下面

12:49.160 --> 12:50.280
service文件夹下面

12:50.280 --> 12:51.360
有这么一些service

12:51.360 --> 12:53.360
有个指文件夹t1.js

12:53.360 --> 12:54.240
一个service

12:54.240 --> 12:56.560
这个service文件夹下面

12:56.560 --> 12:57.560
还有这个

12:57.560 --> 12:58.760
这里

12:58.940 --> 12:59.940
画的不是很好

13:00.940 --> 13:01.940
再画到这

13:01.940 --> 13:05.860
好了

13:05.860 --> 13:06.860
这就不错了

13:07.860 --> 13:09.060
service文件夹下面

13:09.060 --> 13:10.060
还有t2 t3

13:10.060 --> 13:11.060
那么

13:11.060 --> 13:12.860
到时候一个请求来了过后

13:13.860 --> 13:15.500
a可能他就会在contact

13:15.500 --> 13:16.500
service里边

13:16.500 --> 13:18.500
加上sarb文件夹

13:18.500 --> 13:19.500
t1

13:19.500 --> 13:20.540
跟那个controller是一样的

13:20.540 --> 13:21.540
service t2

13:21.540 --> 13:22.540
service t3

13:22.540 --> 13:23.740
那我具体怎么过去了

13:23.740 --> 13:25.540
比方说我在controller里边

13:25.540 --> 13:26.660
我怎么过去呢

13:26.660 --> 13:27.460
contact

13:27.460 --> 13:29.460
通过contact service里边

13:29.460 --> 13:30.580
说可以过去到local

13:30.600 --> 13:31.600
对吧

13:31.600 --> 13:32.600
我们这里有个local

13:32.600 --> 13:33.600
是不是可以过去到

13:33.600 --> 13:34.600
对吧

13:34.600 --> 13:35.600
那电话的方法就完事了

13:35.600 --> 13:36.600
就这么简单

13:36.600 --> 13:37.600
咱们来看一下吧

13:37.600 --> 13:39.600
比方说我们在那个home里边

13:39.600 --> 13:41.600
接下来我们就不再是这样子写的

13:41.600 --> 13:42.600
怎么写的呢

13:42.600 --> 13:43.600
就是这样子写的

13:44.600 --> 13:45.600
contact

13:45.600 --> 13:46.600
调service

13:46.600 --> 13:47.600
调什么local

13:47.600 --> 13:49.600
get provinces

13:49.600 --> 13:50.600
是吧

13:50.600 --> 13:51.600
说可以这样写

13:51.600 --> 13:52.600
咱们马上看一下

13:52.600 --> 13:53.600
看一下结果

13:53.600 --> 13:54.600
MPF装

13:54.600 --> 13:58.000
给

13:58.000 --> 13:59.000
运一下

13:59.000 --> 14:05.510
这边我登录一下吧

14:05.510 --> 14:06.510
有点

14:07.510 --> 14:09.510
出问题了

14:09.510 --> 14:11.510
怎么出问题了

14:11.510 --> 14:16.140
get service is not a function

14:16.140 --> 14:17.140
service

14:17.140 --> 14:19.140
get provinces

14:19.140 --> 14:21.140
is not a function

14:21.140 --> 14:22.140
我看一下

14:23.140 --> 14:25.140
local

14:25.140 --> 14:27.140
get provinces

14:27.140 --> 14:28.140
我写错了吗

14:28.140 --> 14:29.140
单词

14:29.140 --> 14:34.240
我这单词写错了

14:34.240 --> 14:35.240
保证写单词

14:35.240 --> 14:36.240
小心

14:37.240 --> 14:39.240
这里又出问题了

14:39.240 --> 14:40.240
看一下

14:40.240 --> 14:45.240
这里

14:45.240 --> 14:46.240
这里我就

14:46.240 --> 14:47.240
得到了就是

14:47.240 --> 14:48.240
直接就是一个provinces

14:48.240 --> 14:49.240
得到就是

14:49.240 --> 14:50.240
直接是个provinces

14:50.240 --> 14:51.240
我们直接把

14:51.240 --> 14:52.240
放在这就行了

14:53.240 --> 14:54.240
保证

14:54.240 --> 14:55.240
小心

14:55.240 --> 14:56.240
代码呢

14:56.240 --> 14:57.240
看上去呢

14:57.240 --> 14:58.240
好像没有什么减少

14:58.240 --> 15:00.240
主要为了不是减少代码

15:00.240 --> 15:02.240
主要为了是解偶

15:02.240 --> 15:03.240
那么我们现在是把

15:03.240 --> 15:04.240
这个获取

15:04.240 --> 15:06.240
省份数据的逻辑

15:06.240 --> 15:08.240
是不是放到了service里面

15:08.240 --> 15:11.240
将来这个逻辑有任何的变化

15:11.240 --> 15:13.240
那么都可以只需要改动service

15:13.240 --> 15:14.240
而不去改动control

15:14.240 --> 15:15.240
一样的意思吧

15:15.240 --> 15:16.240
主要是解偶

15:16.240 --> 15:17.240
解开偶和

15:18.240 --> 15:19.240
这是关于这一块

15:19.240 --> 15:21.240
然后接着我们接往后看

15:21.240 --> 15:22.240
有一些

15:22.240 --> 15:24.240
它为了就是让你使用方便的

15:24.240 --> 15:25.240
它还给你提供了一种

15:25.240 --> 15:27.240
简单的写法

15:27.240 --> 15:29.240
就是z context可以去掉

15:29.240 --> 15:31.240
你直接使用z service

15:31.240 --> 15:32.240
这是个别名

15:32.240 --> 15:34.240
它跟z context service

15:34.240 --> 15:35.240
是完全一样的

15:35.240 --> 15:37.940
是不是一样的

15:37.940 --> 15:38.940
完全一样的

15:38.940 --> 15:40.940
另外最后一点就是

15:40.940 --> 15:42.940
你不仅是在

15:42.940 --> 15:43.940
因为我们知道

15:43.940 --> 15:44.940
在control里面

15:44.940 --> 15:46.940
是可以获取到service

15:46.940 --> 15:47.940
也可以获取到context

15:47.940 --> 15:48.940
因为context里面有service

15:48.940 --> 15:50.940
而且在我们service

15:50.940 --> 15:51.940
本身里面

15:51.940 --> 15:53.940
是不是也可以获取到context

15:53.940 --> 15:54.940
我们先说了

15:54.940 --> 15:55.940
也可以获取到context

15:55.940 --> 15:56.940
那么这里面

15:56.940 --> 15:57.940
它也有service

15:58.940 --> 15:59.940
是不是在service里面

15:59.940 --> 16:01.940
也可以获取到service

16:01.940 --> 16:02.940
或者说我们在service里面

16:02.940 --> 16:03.940
也可以用简单的写法

16:03.940 --> 16:04.940
也可以获取到service

16:04.940 --> 16:05.940
那么这样的有什么意义呢

16:05.940 --> 16:06.940
意义主要在于

16:06.940 --> 16:08.940
你可以在这个service里面

16:08.940 --> 16:10.940
去调用别的service

16:10.940 --> 16:12.940
是不是可以去调用别的service

16:12.940 --> 16:14.940
联合起来做一些事情

16:14.940 --> 16:16.940
因为有些业务逻辑是要从用的

16:16.940 --> 16:18.940
好那么接下来我就把写完吧

16:18.940 --> 16:20.940
楼口这里是不是有写改写的

16:20.940 --> 16:21.940
然后user登录

16:21.940 --> 16:23.940
登录的话我们在这儿

16:23.940 --> 16:25.940
我们找那个user里面登录

16:25.940 --> 16:27.940
登录的话我们在这里就不是

16:27.940 --> 16:29.940
不再是直接去请求了

16:29.940 --> 16:30.940
我们直接通过什么呢

16:30.940 --> 16:33.940
通过service

16:33.940 --> 16:34.940
user

16:34.940 --> 16:35.940
叫什么

16:35.940 --> 16:36.940
login登录

16:36.940 --> 16:38.940
登录的时候给它传递账号

16:38.940 --> 16:40.940
账号就是这里的账号密码

16:41.940 --> 16:45.250
账号密码

16:46.250 --> 16:47.250
把账号密码传过去

16:47.250 --> 16:49.250
当然那边是接受了两个参数

16:49.250 --> 16:50.250
如果说那边接受了谁的对象的话

16:50.250 --> 16:52.250
你把整个对象传过去

16:52.250 --> 16:54.250
好了那么拿到的是什么呢

16:54.250 --> 16:56.250
拿到的是一个readout对吧

16:56.250 --> 16:58.250
拿到的是登录过后的用户

16:58.250 --> 16:59.250
那么这个用户看一下有没有值

16:59.250 --> 17:01.250
有值的话就登录成功了

17:01.250 --> 17:02.250
对不对登录成功

17:02.250 --> 17:04.250
有值的话就登录成功

17:04.250 --> 17:05.250
因为那边是返回

17:05.250 --> 17:06.250
要么返回force

17:06.250 --> 17:08.250
要么返回一个对象对吧

17:08.250 --> 17:09.250
登录成功怎么办呢

17:09.250 --> 17:10.250
登录成功

17:11.250 --> 17:13.250
我就这样子

17:13.250 --> 17:15.250
然后让我首先设置一下

17:17.250 --> 17:19.250
这里还需要给它一个token对吧

17:19.250 --> 17:21.250
还需要给它个token

17:21.250 --> 17:22.250
我这里说一下吧

17:22.250 --> 17:23.250
实际上当你很多时候

17:23.250 --> 17:25.250
这个token可能会让你前端来做

17:25.250 --> 17:26.250
但是也不一定

17:26.250 --> 17:27.250
有可能后端给你做好了

17:27.250 --> 17:28.250
那么我现在就是

17:28.250 --> 17:29.250
直接是后端做好的

17:29.250 --> 17:31.250
那我这里就在这里

17:31.250 --> 17:33.250
给它返回吧

17:33.250 --> 17:35.250
登录成功过后

17:35.250 --> 17:36.250
我不仅返回

17:36.250 --> 17:38.250
要给你返回数据

17:38.250 --> 17:40.250
给返回个对象吧

17:41.250 --> 17:42.250
Uther

17:42.250 --> 17:44.250
来至于Risp

17:44.250 --> 17:45.250
对吧

17:45.250 --> 17:47.250
然后token直接返回给你

17:47.250 --> 17:48.250
token为什么呢

17:48.250 --> 17:50.250
token为Risp

17:50.250 --> 17:51.250
为这个对吧

17:51.250 --> 17:53.820
直接把

17:53.820 --> 17:54.820
请求这个远程地址

17:54.820 --> 17:56.820
获取到的响应头里边的

17:56.820 --> 17:58.820
这个token直接给你

17:58.820 --> 17:59.820
放到对象里面

17:59.820 --> 18:00.820
对吧

18:00.820 --> 18:01.820
让它就是让控制器

18:01.820 --> 18:02.820
它没有敢

18:02.820 --> 18:03.820
无法敢知道

18:03.820 --> 18:05.820
我到底是怎么完成能路的

18:05.820 --> 18:06.820
无所谓

18:06.820 --> 18:07.820
你只要给我账号密码

18:07.820 --> 18:08.820
我就给你一个结果对吧

18:08.820 --> 18:10.820
你剩下的事情不用管了

18:10.820 --> 18:11.820
好了

18:11.820 --> 18:12.820
那么现在我们写成这个样子

18:12.820 --> 18:14.820
这边我就得到是result

18:14.820 --> 18:16.820
如果说result有值

18:16.820 --> 18:17.820
叫登录成功

18:17.820 --> 18:18.820
登录成功的话

18:18.820 --> 18:19.820
我这里的token是什么呢

18:19.820 --> 18:21.820
token就是result

18:21.820 --> 18:22.820
token

18:22.820 --> 18:23.820
对吧

18:23.820 --> 18:24.820
这边

18:24.820 --> 18:26.820
得到了返回的对象里边

18:26.820 --> 18:27.820
不是一个token吗

18:27.820 --> 18:28.820
好

18:28.820 --> 18:29.820
把它放在这

18:29.820 --> 18:30.820
然后它就重进去了

18:30.820 --> 18:31.820
登录

18:31.820 --> 18:34.820
登录失败呢

18:34.820 --> 18:37.710
这边来

18:37.710 --> 18:39.710
很登录失败

18:39.710 --> 18:40.710
下面登录成功

18:40.710 --> 18:41.710
登录失败呢

18:41.710 --> 18:42.710
我们就设计一个模型

18:42.710 --> 18:44.710
result

18:44.710 --> 18:45.710
就是登录

18:45.710 --> 18:46.710
错误消息是怎么来的

18:46.710 --> 18:47.710
错误消息是

18:47.710 --> 18:49.710
账号密码不正确

18:49.710 --> 18:51.710
账号多一吗

18:51.710 --> 18:52.710
不正确

18:52.710 --> 18:53.710
这是给仕途的用的

18:53.710 --> 18:55.710
账号就是这里的账号

18:55.710 --> 18:56.710
没什么问题

18:56.710 --> 18:58.710
选择这个模板

18:58.710 --> 18:59.710
好

18:59.710 --> 19:00.710
完成了

19:00.710 --> 19:01.710
登录就搞定了

19:01.710 --> 19:03.710
现在我们来看一下登录行不行

19:03.710 --> 19:04.710
模型

19:05.710 --> 19:06.710
有什么

19:06.710 --> 19:08.710
先来个错误的

19:08.710 --> 19:09.710
没问题

19:09.710 --> 19:10.710
123

19:10.710 --> 19:11.710
123

19:11.710 --> 19:14.080
这里拨错了

19:14.080 --> 19:16.080
这个解决吧

19:16.080 --> 19:18.080
说啥呢

19:18.080 --> 19:20.080
嗯

19:20.080 --> 19:22.080
Cannot read the property

19:22.080 --> 19:25.080
of authorization of undefend

19:25.080 --> 19:28.080
它说从一个undefend里边

19:28.080 --> 19:30.080
result

19:30.080 --> 19:32.080
我这里已经得到这个data了

19:32.080 --> 19:33.080
所以说不能再这样得到

19:33.080 --> 19:34.080
得到的话

19:34.080 --> 19:35.080
它就得不到headers了

19:35.080 --> 19:36.080
对吧

19:36.080 --> 19:39.080
那么这边应该是data的code

19:39.080 --> 19:41.080
这边应该是data的data

19:42.080 --> 19:43.080
好

19:44.080 --> 19:48.060
放心

19:48.060 --> 19:49.060
放心

19:49.060 --> 19:51.060
123

19:51.060 --> 19:52.060
好

19:52.060 --> 19:53.060
没问题了

19:53.060 --> 19:54.060
登录成功了

19:54.060 --> 19:55.060
好

19:55.060 --> 19:56.060
那么登录

19:56.060 --> 19:57.060
现在我们再来搞定

19:57.060 --> 19:58.060
这个就是

19:58.060 --> 19:59.060
互外卖

19:59.060 --> 20:00.060
那么这也是一个业务逻辑

20:00.060 --> 20:01.060
我是谁

20:01.060 --> 20:02.060
你给我一个token

20:02.060 --> 20:03.060
我给你

20:03.060 --> 20:04.060
我是谁

20:04.060 --> 20:05.060
或者是根据id

20:05.060 --> 20:06.060
来找到用户

20:06.060 --> 20:07.060
等等都行

20:07.060 --> 20:08.060
比方说我们这里的

20:08.060 --> 20:09.060
得到一个token

20:09.060 --> 20:10.060
那么接下来

20:10.060 --> 20:11.060
通过这个token

20:11.060 --> 20:12.060
contact里边

20:12.060 --> 20:13.060
有什么

20:13.060 --> 20:14.060
有service

20:14.060 --> 20:15.060
里边什么

20:15.060 --> 20:16.060
get

20:17.060 --> 20:18.060
user

20:18.060 --> 20:20.060
互

20:20.060 --> 20:22.060
我把token给的

20:22.060 --> 20:23.060
你给我返回什么

20:24.060 --> 20:26.060
你给我返回一个

20:26.060 --> 20:27.060
用户

20:27.060 --> 20:28.060
对不对

20:28.060 --> 20:29.060
用户要么就有值

20:29.060 --> 20:30.060
要么就没有值

20:30.060 --> 20:32.060
如果说用户没有值的话

20:33.060 --> 20:34.060
如果用户没有值的话

20:34.060 --> 20:36.060
你回登录去

20:36.060 --> 20:37.060
去登录

20:37.060 --> 20:39.060
没什么好说的

20:39.060 --> 20:40.060
如果说用户有值的话

20:40.060 --> 20:41.060
那么这里就不需要了

20:41.060 --> 20:42.060
对吧

20:42.060 --> 20:43.060
用户有值的话

20:43.060 --> 20:44.060
我们就把

20:44.060 --> 20:45.060
干嘛呢

20:45.060 --> 20:46.060
不需要了

20:46.060 --> 20:47.060
不需要了

20:47.060 --> 20:48.060
这些东西都不需要了

20:48.060 --> 20:49.060
就是local是有账

20:49.060 --> 20:51.060
把用户给他就行了

20:52.060 --> 20:53.060
对吧

20:53.060 --> 20:54.060
变成这样了

20:54.060 --> 20:55.060
干嘛

20:55.060 --> 20:56.060
保存

20:56.060 --> 20:57.060
刷新

20:57.060 --> 20:58.060
刷新

20:58.060 --> 20:59.060
没有任何问题

20:59.060 --> 21:00.060
好了

21:00.060 --> 21:01.060
这就是这里

21:01.060 --> 21:02.060
业务层的体系

21:02.060 --> 21:03.060
就是把一些

21:03.060 --> 21:04.060
功能性质的

21:04.060 --> 21:05.060
跟业务相关的

21:05.060 --> 21:06.060
提到service上

21:06.060 --> 21:07.060
当然我这里的

21:07.060 --> 21:08.060
有点

21:08.060 --> 21:09.060
有点似不像

21:09.060 --> 21:10.060
为什么呢

21:10.060 --> 21:11.060
因为我们现在的业务逻辑

21:11.060 --> 21:13.060
根本就不似在我们这儿

21:13.060 --> 21:15.060
我们的业务逻辑在哪儿呢

21:15.060 --> 21:17.060
在我之前那边的服务器上

21:17.060 --> 21:18.060
在这儿

21:18.060 --> 21:20.060
所以在这个服务器上

21:20.060 --> 21:21.060
我们就好必说

21:21.060 --> 21:22.060
我写了一个后端

21:22.060 --> 21:23.060
你们在这里调用

21:23.060 --> 21:25.060
我那边才是一真正的业务逻辑

21:25.060 --> 21:26.060
你们只是远程访问而已

21:26.060 --> 21:27.060
你们的业务逻辑

21:27.060 --> 21:29.060
只是远程访问我的业务逻辑而已

21:29.060 --> 21:30.060
但是如果说

21:30.060 --> 21:31.060
这样的分块

21:31.060 --> 21:32.060
之后其实还是有个好处的

21:32.060 --> 21:33.060
就将来

21:33.060 --> 21:34.060
如果说我的业务逻辑

21:34.060 --> 21:35.060
不给你们提供了

21:37.060 --> 21:38.060
范围太大

21:38.060 --> 21:39.060
你们不用去动这些东西

21:39.060 --> 21:41.060
你们自己把这些地方

21:41.060 --> 21:42.060
实现就完事

21:42.060 --> 21:43.060
你自己去实现就完事

21:43.060 --> 21:45.060
表示该用数据过去

21:45.060 --> 21:46.060
用数据过

21:47.060 --> 21:48.060
好了

21:48.060 --> 21:49.060
这就是这里的我地方

21:49.060 --> 21:50.060
我说一下

