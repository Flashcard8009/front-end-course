WEBVTT

00:00.050 --> 00:03.370
简单的说一下这个Aegre的生命周期

00:03.890 --> 00:07.210
它里边给你提供了很多的生命周期函数

00:07.470 --> 00:09.530
让你在启动应用之后呢

00:09.770 --> 00:12.850
可以在不同的时期去做一些不同的事情

00:13.610 --> 00:15.670
但是根据我的经验呢

00:15.930 --> 00:20.790
因为我每一次看到一个新的技术啊我都会看一下它的文档

00:21.290 --> 00:23.610
看到文档过后呢我在脑袋里边去想一想

00:23.850 --> 00:25.650
根据我过往的开发经验

00:26.170 --> 00:28.210
它会在什么样的场景下去使用

00:28.770 --> 00:31.010
想来想去呢这个生命周期这些

00:31.270 --> 00:32.050
钩子函数啊

00:33.070 --> 00:34.610
实际上我们的应用场景呢

00:35.130 --> 00:37.690
很少很少啊所以说简单的说一下就可以了

00:38.190 --> 00:44.590
它怎么回事呢就是说你可以在app.js里边我们之前呢在这里的导出了一个函数对吧

00:44.850 --> 00:47.910
那么它是说如果说呢你想去

00:48.170 --> 00:53.290
参与这个Aegre生命周期的话那么你要导出的就不是函数了啊就是一个类

00:53.550 --> 00:55.090
那么这里呢我们之前还

00:55.550 --> 00:58.630
加了这个locals属性对吧那么我们把这个属性的放这吧

00:59.130 --> 01:01.190
把这个locals属性放到extend里边

01:02.210 --> 01:02.730
放到这

01:04.510 --> 01:05.270
locals

01:07.070 --> 01:07.590
放到这

01:10.040 --> 01:14.920
当然这边能不能写呢也可以写啊就是把它导出的导出成了什么呢导出了一个类

01:15.680 --> 01:17.720
一个简单的一个普通的一个类就行了

01:17.980 --> 01:22.840
类的构造函数里边呢它会给你传入因为类它本质上也是一个函数嘛对不对

01:23.060 --> 01:28.220
所以说呢它会给你传入app跟之前一样啊之前那个函数不是传入一个app嘛对不对

01:28.480 --> 01:32.820
那么这里呢我们就可以把这个app呢保存到这个属性里边去保存在类的属性里边去

01:33.340 --> 01:34.100
这个类里边呢

01:34.620 --> 01:38.980
也可以在它的圆形上边提供很多的那个生命周期都是函数

01:39.480 --> 01:44.600
那么这些函数呢我们一名字呢就是比较按照他的名字来命名就可以了

01:44.860 --> 01:48.700
我这里给他列举了有的六个生命周期函数啊我们看一下就行了

01:49.460 --> 01:51.500
一个呢是这个config

01:51.760 --> 01:52.540
willload

01:53.040 --> 01:53.560
什么意思呢

01:53.820 --> 01:56.620
就是说我们那个配置文件呢它已经夹载完毕了

01:57.140 --> 02:00.220
啊就是已经即将夹载啊它已经合并的

02:00.480 --> 02:03.300
合并到config配置里边去了但是呢还没有生效

02:03.800 --> 02:08.140
这个时候呢你就可以如果说你有什么事情要做的话你可以在这个函数里边写

02:08.660 --> 02:11.220
那么这个函数里边我们我想了一项

02:11.480 --> 02:13.280
可以做什么上来比方说我们就可以把这个

02:13.780 --> 02:16.340
我们这里不是配置的一个keyz嘛对吧

02:18.140 --> 02:18.640
在这

02:19.420 --> 02:20.440
不是配置了这么一个keyz吗

02:20.960 --> 02:22.740
那么这个keyz呢是固定的对不对

02:22.840 --> 02:23.860
一般是写实的

02:24.120 --> 02:28.980
但是呢如果说你要你的安全性要求特别特别高

02:30.260 --> 02:32.820
防止什么呢防止这个文件被泄露

02:33.340 --> 02:35.140
这个文件一泄露是不是key就泄露了

02:35.380 --> 02:35.900
对不对

02:36.160 --> 02:40.760
防止这个文件被泄露那怎么办了你可以生成一个连你自己都不知道的key

02:41.260 --> 02:42.820
那么这里呢我就给他举个例子啊

02:43.320 --> 02:45.880
就是我们找到这个keyz啊给他拼接上一个制服串

02:46.140 --> 02:52.780
这个制服串呢是一个随机的六位制服串啊这种写法呢我以前讲过啊不再重复了你可以在浏览器里面运行一下非常简单的

02:53.820 --> 02:56.380
就通过这样子呢生成一个随机制服是给他拼接进去

02:56.640 --> 03:00.720
那么这样子呢每一次启动的时候是不是就是个key的值都不一样

03:00.980 --> 03:02.780
对吧每一次服务器启动都不一样

03:03.540 --> 03:05.340
好处是什么的好处是特别安全

03:06.100 --> 03:07.900
哪怕你的服务器被攻陷了

03:08.420 --> 03:09.420
这key被暴露了

03:09.940 --> 03:13.020
他都不会导致啊key被泄露因为key根本就不是这个key

03:13.280 --> 03:17.620
是我们拼接的随机制服串啊特别安全但是呢有一说一

03:18.380 --> 03:20.180
如果说你真的服务器都被攻陷了

03:21.160 --> 03:24.080
那还是key的问题吧肯定就不是key的问题了啊

03:24.440 --> 03:29.360
那就是很多东西全部暴露在外面了啊数据库啊这种都可能暴露在外面啊所以非常危险

03:29.800 --> 03:32.360
服务器是一般是不能不允许被攻陷的啊

03:33.800 --> 03:40.800
呃这是这个点啊当然呢这个如果说这样子也不好的地方在什么呢不好的地方在于你每一次启动服务

03:41.440 --> 03:45.560
比方说服务器啊有更新啊有上传的新的文件要重新启动服务器

03:45.880 --> 03:48.120
重新启动服务器呢导致的key就全部失效了

03:48.580 --> 03:53.860
就导致什么的都导致了用户那边的登录信息啊保持了登录状态全部丢失掉了因为key不一样了

03:54.380 --> 03:57.780
啊所以说呢一般我们也不会这样做啊我就举个例子

03:58.300 --> 04:02.700
然后第二个生命转据函数是deadload这个时候呢就是配置已经加载完毕了

04:03.380 --> 04:07.700
啊这个函数可以上面这个函数必须是同步啊前面的后面的后边的函数都可以是一步的

04:08.500 --> 04:09.700
也可以做一些一步的事情

04:10.180 --> 04:13.540
比方说你这个时候呢配置已经加载完毕了你可以把最终的配置保存起来

04:14.180 --> 04:17.420
好第三个生命转据函数就是we're ready那么这个时候呢

04:18.140 --> 04:25.780
指的是worker啊我们不是要有很多worker进程吗worker进程呢还没有真正的要开始准备工作啊还没有准备好

04:26.180 --> 04:32.380
那么即将准备好那么这个时候呢你可以做什么事呢比方说你可以做一些初始化的操作

04:33.060 --> 04:38.980
什么初始化的操作呢比方说你要接收用户的上传文件对吧你把用户的上传的图片啊上传的头像

04:39.300 --> 04:43.900
放到一个文件夹里边去那么这个文件夹到底存不存在呢你可以在这里做一些初始化的

04:44.640 --> 04:47.000
比如说这个判断一下啊我这里全是尾代嘛啊

04:48.360 --> 04:55.000
读一个配置啊这个配置不是已经完成了吗对吧配置里边可以写个配置啊就是用户保存到哪个文件夹下边

04:55.240 --> 05:03.480
上传的文件那么里有个配置啊这里呢就看一下这个配置这个文件夹存不存在如果不存在的话我们创建这个文件夹啊就做这么一些初始化的操作

05:04.320 --> 05:04.840
再比如说

05:05.720 --> 05:11.680
数据库里边可能会有一些初始的数据对不对那么这个时候呢可以做一些初始数据的操作都可以在这里做

05:12.660 --> 05:15.780
啊第四个呢就是worker已经准备就绪了

05:16.540 --> 05:20.640
那么这个时候worker进程已经启动了但是呢这个时候呢端口还没有监听

05:21.140 --> 05:27.300
还没有监听端口还不具备处理请求的能力只是我可已经结束了啊这个时候要做什么事情呢

05:27.560 --> 05:37.540
我想想去想不到目前也想不到什么事情可以做啊在具体的应用中如果说你知道你知道有这么个点就行了啊如果说有这样的一个时间点你想做一些事情的话在这里去完成

05:38.520 --> 05:44.360
第五个呢是应用启动完成那么这个时候呢就是端口已经被监听了已经具备了处理请求的能力

05:44.920 --> 05:52.340
啊就这里可以接收请求了那么这个时候要做什么事情呢你可以去做比方说这个时候呢你可以模拟一个请求啊发生一个请求到本机

05:52.600 --> 05:58.480
啊来去测试一下这个端口到底没有真正的监听啊有没有能够处理处理请求是不是正常可以去

05:58.980 --> 06:01.260
呃请求一下试一下

06:02.020 --> 06:07.660
啊第六点呢就是应用气象关闭比方说我们要停止了啊停止的时候呢你可以他会运行这个函数

06:08.420 --> 06:14.300
明白就这么一些东西啊就是生命这些函数那么官方建议的在这些生命这些函数里面不用去

06:14.560 --> 06:16.500
做一些太耗时的操作

06:17.380 --> 06:22.740
因为框架的启动的时候呢会有一个超时检测啊如果说你长时间这个框架都没有启动起来

06:23.260 --> 06:25.060
会导致个这一次的启动就失败了

06:25.680 --> 06:29.120
所以说呢你不要去做一些太过于超时的操作啊

06:29.960 --> 06:33.880
ok 那么这一生命这些函数呢你会发现的按照这样的定义呢他只会运行一次

06:34.320 --> 06:37.680
在一个应用启动期间他只会运行一次他不会反复运行

06:39.200 --> 06:42.720
所以说呢更多的时候其实我们用那个什么插件啊

06:43.280 --> 06:44.960
用什么那个中间键

06:45.640 --> 06:48.800
用什么那个控制都可以解决绝当无分问题了啊

06:49.120 --> 06:51.520
像如果说有遇到一些启动的过程中

06:52.140 --> 06:55.820
要做那么一次的操作了你可以在这里边去考虑一下啊

06:56.060 --> 06:57.740
就说你中间键插件

06:59.260 --> 07:01.500
或者是control都不能解决问题

07:02.540 --> 07:05.740
而且呢你这个这个事情呢只做只做一次啊

07:05.740 --> 07:09.300
那么你可以考虑在生命这些函数里边某一个合适的时期

07:09.300 --> 07:10.100
把它加速进去

07:10.940 --> 07:13.220
好这就是生命这些函数啊简单的说一下就可以了

