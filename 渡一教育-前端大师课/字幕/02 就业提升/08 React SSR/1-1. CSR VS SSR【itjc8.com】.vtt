WEBVTT

00:00.690 --> 00:04.370
同学们 咱们这门课呢就来学习

00:04.770 --> 00:09.210
在前端领域比较神奇的啊 传说中的SSR

00:09.410 --> 00:12.210
我们这门课是针对reactor ssr

00:12.210 --> 00:15.170
其实你reactor学习之后呢 我有的也差不多

00:15.730 --> 00:19.330
那么这些课呢 我们首先来看一下 什么是SSR

00:19.330 --> 00:22.210
那到底是一个什么东西啊

00:22.210 --> 00:24.210
听着很厉害的样子

00:24.210 --> 00:25.890
咱们首先看一下啊

00:26.050 --> 00:31.250
SSR呢 它这个东西是针对了个CSR而言的

00:31.250 --> 00:33.250
那么我们首先看一下CSR

00:33.250 --> 00:37.250
其实CSR呢 我们咋之前呢 只是没有特别体责概念

00:37.250 --> 00:40.450
大家平时在开发的时候啊 开发reactor应用的时候呢

00:40.450 --> 00:42.450
其实就用的是CSR

00:42.450 --> 00:44.850
它什么意思呢 叫client side rendering

00:44.850 --> 00:47.650
叫做客户端渲染

00:47.650 --> 00:49.650
那么是什么一种情况呢

00:49.650 --> 00:53.650
就是咱们之前呢 用什么脚授架 什么污蜜介石对吧

00:53.810 --> 00:55.810
还有什么create react app

00:55.810 --> 00:59.410
那么像中用这些脚授架 去搭建一个工程的话

00:59.410 --> 01:01.410
那么它搭建出来的

01:01.410 --> 01:05.410
如果你不去做改动的话 基本上就是CSR

01:05.410 --> 01:09.410
CSR是一个非常常见 也是非常传统

01:09.410 --> 01:11.410
当然传统是相对而言啊

01:11.410 --> 01:15.410
相对于我们新前端来说啊 比较传统的一个

01:15.410 --> 01:17.410
呃 开发方式

01:17.410 --> 01:19.410
你们以后呢 到公司里边可能是

01:19.410 --> 01:21.410
大部分时候呢 都用的是CSR

01:22.370 --> 01:24.370
那么我们来看一下啊

01:24.370 --> 01:26.370
CSR它是一个什么样的情况

01:26.370 --> 01:28.370
就是我们浏览 就是我们写好代码之后

01:28.370 --> 01:30.370
部署到服务器

01:30.370 --> 01:32.370
就是我们的代码肯定要部署到服务器的

01:32.370 --> 01:34.370
把我们生成的页面也好

01:34.370 --> 01:38.370
还有GS CSS还有什么图片这些东西

01:38.370 --> 01:40.370
全部部署到服务器

01:40.370 --> 01:42.370
那么现在呢 我们打开一个浏览器

01:42.370 --> 01:44.370
去访问服务器

01:44.370 --> 01:46.370
那么通过一个域名去访问服务器

01:46.370 --> 01:48.370
那么就会第一步就会产生一个请求

01:48.370 --> 01:50.370
到服务器请求啥呀 请求页面

01:50.370 --> 01:52.370
而服务器呢 干嘛呢

01:52.370 --> 01:54.370
它就会给你一个页面 不过呢

01:54.370 --> 01:56.370
这个页面呢 只是一个空页面

01:56.370 --> 01:58.370
还记得吗 你们在写reggit应用的时候

01:58.370 --> 02:00.370
那么这个页面上 是不是只有一个DIV

02:00.370 --> 02:02.370
DIV ID为入词嘛

02:02.370 --> 02:04.370
对啊 我们打开发的是单页应用程序

02:04.370 --> 02:06.370
只有这么一个东西

02:06.370 --> 02:08.370
好 那么这里边东西有没有

02:08.370 --> 02:10.370
啥都没有 服务器给你返回的就是这个东西

02:10.370 --> 02:12.370
一个 当然还有一些

02:12.370 --> 02:14.370
其他的ATM元素啊

02:14.370 --> 02:16.370
中间呢 只有一个DIV

02:16.370 --> 02:18.370
一个空页面 啥都没有

02:18.370 --> 02:20.370
给扭烂器

02:20.370 --> 02:22.370
当然呢 还包括一些JS啊

02:22.370 --> 02:24.370
CSS啊这些东西

02:24.370 --> 02:26.370
那么扭烂器要一把渲染出来

02:26.370 --> 02:28.370
这就是客户端的渲染

02:28.370 --> 02:30.370
好 那么客户端的渲染呢

02:30.370 --> 02:32.370
它是一个什么样的情况呢

02:34.370 --> 02:36.370
我们来看一下啊

02:36.370 --> 02:38.370
下面一个详细流程

02:38.370 --> 02:40.370
它是这么一个情况

02:40.370 --> 02:42.370
首先呢 扭烂器发送的请求到服务器

02:42.370 --> 02:44.370
有第一步 第二步呢 服务器返回一个页面

02:44.370 --> 02:46.370
但是没有任何那种 就是一个DIV

02:46.370 --> 02:48.370
会出一个什么状态的 一个白屏状态

02:48.370 --> 02:50.370
为什么是白屏呢 因为这个东西

02:50.370 --> 02:52.370
啥都没有啊 它里边啥都没有

02:52.370 --> 02:54.370
所以扭烂器渲染不出来 它没那种

02:54.370 --> 02:56.370
那么这个时候呢 扭烂器在渲染页面的过程中呢

02:56.370 --> 02:58.370
发现了一些外链接 比方说

02:58.370 --> 03:00.370
CSS啊 还有图片

03:00.370 --> 03:02.370
一开始没有什么图片

03:02.370 --> 03:04.370
还有JS

03:04.370 --> 03:06.370
那么像这个时候呢 它扭烂器会去请求

03:06.370 --> 03:08.370
CSS 去请求JS

03:08.370 --> 03:10.370
我们之前学过了 为派个打包

03:10.370 --> 03:12.370
当然这些教授家呢

03:12.370 --> 03:14.370
也是利用为派的打包 打包成了一些JS

03:14.370 --> 03:16.370
那么扭烂器呢 会去请求这些JS

03:16.370 --> 03:18.370
比方说邦道JS

03:18.370 --> 03:20.370
请求了这些JS过程呢 服务器

03:20.370 --> 03:22.370
收到这个请求 又给它响应一个

03:22.370 --> 03:24.370
因为这个图啊 画得比较

03:24.370 --> 03:26.370
简略啊 只画了一个响应空页面

03:26.370 --> 03:28.370
其实扭烂器还有后续请求的

03:28.370 --> 03:30.370
还有后续的请求JS CSS

03:30.370 --> 03:32.370
那么请求完了过后呢

03:32.370 --> 03:34.370
服务器就响应对应的资源

03:34.370 --> 03:36.370
然后呢 扭烂器拿到JS过后

03:36.370 --> 03:38.370
是不是开始执行JS

03:38.370 --> 03:40.370
那么这个时候呢 就进行一大堆事情的啊

03:40.370 --> 03:42.370
进入REx的组建的生命周期

03:42.370 --> 03:44.370
然后呢 开始宣兰组建生成什么

03:44.370 --> 03:46.370
虚拟动物节点

03:46.370 --> 03:48.370
然后呢 再把虚拟动物节点

03:48.370 --> 03:50.370
硬设到真实的动物节点

03:50.370 --> 03:52.370
然后呢 扭烂器呢 最后才能宣兰出

03:52.370 --> 03:54.370
可见的页面

03:54.370 --> 03:56.370
也就是说扭烂器呢 它这样子做呢

03:56.370 --> 03:58.370
它会长期处于一个白屏状态

03:58.370 --> 04:00.370
就是它不好的地方

04:00.370 --> 04:02.370
从什么时候开始

04:02.370 --> 04:04.370
从服务器给它页面过后

04:04.370 --> 04:06.370
它就是白屏 它没有东西

04:06.370 --> 04:08.370
然后呢 要去

04:08.370 --> 04:10.370
经过一大堆事情 重新去请求JS

04:10.370 --> 04:12.370
就是REx生命周期

04:12.370 --> 04:14.370
最后呢 REx一启动

04:14.370 --> 04:16.370
把这些事情做完了

04:16.370 --> 04:18.370
把我们的东西呢 宣兰到哪儿

04:18.370 --> 04:20.370
宣兰到我们的DIV里边

04:20.370 --> 04:22.370
扭烂器才能看得到

04:22.370 --> 04:24.370
也就是说这个内部的东西啊

04:24.370 --> 04:26.370
这个DIV内部的东西

04:26.370 --> 04:28.370
是靠JS搞定的

04:28.370 --> 04:30.370
JS宣兰出来的

04:30.370 --> 04:32.370
这就是我们之前传统的

04:32.370 --> 04:34.370
单页应用程序 它的做法

04:34.370 --> 04:36.370
因此它第一个缺点啊

04:36.370 --> 04:38.370
就是扭烂器呢 可能会长期处于

04:38.370 --> 04:40.370
网速够快的话 可能感觉还好一点

04:40.370 --> 04:42.370
如果说网速稍微慢一点

04:42.370 --> 04:44.370
或者是那个

04:44.370 --> 04:46.370
或者是那个 就是

04:46.370 --> 04:48.370
我们这个页面上的东西太多了

04:48.370 --> 04:50.370
组件太多了

04:50.370 --> 04:52.370
REx执行需要一段时间

04:52.370 --> 04:54.370
那么在这个时间内

04:54.370 --> 04:56.370
就是有两个点 一个是呢

04:56.370 --> 04:58.370
请求JS这段时间 白屏

04:58.370 --> 05:00.370
另一个点呢 是执行JS

05:00.370 --> 05:02.370
执行JS就是需要时间

05:02.370 --> 05:04.370
它要宣兰这个组件

05:04.370 --> 05:06.370
那么它也处于白屏

05:06.370 --> 05:08.370
都容易找成白屏

05:08.370 --> 05:10.370
给用户的直观感受就是要

05:10.370 --> 05:12.370
白一会才会显示出来

05:12.370 --> 05:14.370
可能会用户体验就不太好

05:14.370 --> 05:16.370
这是第一个问题

05:16.370 --> 05:18.370
第二个问题呢 是

05:18.370 --> 05:20.370
不利于SEO

05:20.370 --> 05:22.370
什么叫SEO 就是搜索引擎

05:22.370 --> 05:26.370
而search engine optimization

05:26.370 --> 05:28.370
就是搜索引擎优化

05:28.370 --> 05:30.370
搜索引擎优化是怎么意思呢

05:30.370 --> 05:32.370
就是我们的搜索引擎

05:32.370 --> 05:34.370
像百度啊 谷歌啊

05:34.370 --> 05:36.370
要拿去我们的页面 比方说我们的页面地址

05:36.370 --> 05:38.370
我们有一个页面的域名

05:38.370 --> 05:40.370
最终发布上去的是这个

05:40.370 --> 05:42.370
都一

05:42.370 --> 05:44.370
要抗

05:44.370 --> 05:46.370
那么我们的页面在这上面

05:46.370 --> 05:48.370
那么搜索引擎呢 它会去看

05:48.370 --> 05:50.370
从供电网络去找我们的页面

05:50.370 --> 05:52.370
找到页面过后呢 它会搜索引擎

05:52.370 --> 05:54.370
搜索引擎

05:54.370 --> 05:56.370
它会拿到页面元代

05:56.370 --> 05:58.370
页面元代

05:58.370 --> 06:00.370
但是呢 不好意思

06:00.370 --> 06:02.370
由于它去拿页面元代码的时候

06:02.370 --> 06:04.370
它会去访问服务器 对吧

06:04.370 --> 06:06.370
服务器给它的是什么页面

06:06.370 --> 06:08.370
给它的是一个空页面 啥都没有

06:08.370 --> 06:10.370
它要运行GS过后

06:10.370 --> 06:12.370
它才能知道这个页面的内容

06:12.370 --> 06:14.370
但是搜索引擎能不能运行GS呢

06:14.370 --> 06:16.370
目前的搜索引擎呢

06:16.370 --> 06:18.370
它具备一定的运行GS的能力

06:18.370 --> 06:20.370
不过呢 你不要太指望

06:20.370 --> 06:22.370
也不要太指望 搜索引擎不太喜欢这种页面的

06:22.370 --> 06:24.370
因此呢 大部分搜索引擎呢

06:24.370 --> 06:26.370
它拿到这个页面过后一看

06:26.370 --> 06:28.370
啥都没有

06:28.370 --> 06:30.370
那就认为你啥都没有

06:30.370 --> 06:32.370
其实你有很多内容的

06:32.370 --> 06:34.370
但是这些内容呢 是需要靠GS运行过后

06:34.370 --> 06:36.370
react 启动 然后呢 不停的渲染出来了

06:36.370 --> 06:38.370
对吧 但是搜索引擎呢

06:38.370 --> 06:40.370
由于它运行GS的能力非常有限

06:40.370 --> 06:42.370
因此呢 它不知道

06:42.370 --> 06:44.370
你这个网页上面还有其他的内容

06:44.370 --> 06:46.370
它就认为你只有一个DIV

06:46.370 --> 06:48.370
因此呢 你这个网页呢

06:48.370 --> 06:50.370
在搜索引擎上面 它认为你给它的是一个空网

06:50.370 --> 06:52.370
也啥都没有

06:52.370 --> 06:54.370
当然你在搜索引擎里边一搜

06:54.370 --> 06:56.370
就搜不出来 啥都搜不出来

06:56.370 --> 06:58.370
可能只搜出一个网站标题

06:58.370 --> 07:00.370
没有 这是不利于搜索引擎优化

07:00.370 --> 07:02.370
当然了 对于这样的页面

07:02.370 --> 07:04.370
搜索引擎呢 它肯定不会给你

07:04.370 --> 07:06.370
往前排名的 就是你搜索一个关键字

07:06.370 --> 07:08.370
你再排名的是比较靠后的

07:08.370 --> 07:10.370
不要认为百度 它就是

07:10.370 --> 07:12.370
虽然说百度是面向那个

07:12.370 --> 07:14.370
面向那个就是

07:14.370 --> 07:16.370
资金优化 对吧

07:16.370 --> 07:18.370
但是实际上呢 它还是

07:18.370 --> 07:20.370
要靠一些页面那种来支撑的

07:20.370 --> 07:22.370
然后你没有任何页面那种也无效

07:22.370 --> 07:24.370
说都不利于搜索引擎优化

07:24.370 --> 07:26.370
这它最重要的两个问题

07:26.370 --> 07:28.370
好 那么如何来解决这两个问题呢

07:28.370 --> 07:30.370
就是使用服务端旋转

07:30.370 --> 07:32.370
其实服务端旋转

07:32.370 --> 07:34.370
才是一个老技术

07:34.370 --> 07:36.370
它才不是新技术

07:36.370 --> 07:38.370
最早的时候

07:38.370 --> 07:40.370
像用java开发程序

07:40.370 --> 07:42.370
那个时候还没有那种职业前端

07:42.370 --> 07:44.370
前端都是比较边缘化的一个职业

07:44.370 --> 07:46.370
那个时候呢 其实就是服务端旋转

07:46.370 --> 07:48.370
那些开发java的呀

07:48.370 --> 07:50.370
开发pgp的 开发csharp的

07:50.370 --> 07:52.370
它就是用的是服务端旋转

07:52.370 --> 07:54.370
那个时候还没有打到完全的

07:54.370 --> 07:56.370
彻底的就是前后端分离

07:56.370 --> 07:58.370
只不过呢 目前我们学习的服务端旋转呢

07:58.370 --> 08:00.370
跟以前的 最传统的服务端旋转呢

08:00.370 --> 08:02.370
是有一些区别的

08:02.370 --> 08:04.370
它整体的结构上是有一些区别的

08:04.370 --> 08:06.370
我们后边讲到的时候呢

08:06.370 --> 08:08.370
我还会想起说

08:08.370 --> 08:10.370
我们现在出列看一下

08:10.370 --> 08:12.370
什么叫服务端旋转

08:12.370 --> 08:19.680
我这里写错了 是吧

08:19.680 --> 08:21.680
这里叫服务端旋转

08:21.680 --> 08:23.680
什么意思呢

08:23.680 --> 08:25.680
我们来看一下这个流程

08:25.680 --> 08:27.680
它就不太一样了

08:27.680 --> 08:29.680
浏览器寻求服务器

08:29.680 --> 08:31.680
服务器给它的就不是一个空页面了

08:31.680 --> 08:33.680
给它的就是一个完整的页面

08:33.680 --> 08:35.680
那么完整的页面拿到之后呢

08:35.680 --> 08:37.680
浏览器直接把这个页面宣传出来了

08:37.680 --> 08:39.680
当然这个是个比较处理的图

08:39.680 --> 08:41.680
咱们来详细看一下

08:41.680 --> 08:43.680
详细的流程

08:43.680 --> 08:45.680
第一步呢 浏览器方向寻找服务器

08:45.680 --> 08:47.680
没什么问题 一样的

08:47.680 --> 08:49.680
第二步呢 服务器反回一个

08:49.680 --> 08:51.680
ATM页面一样的 不一样的地方在这

08:51.680 --> 08:53.680
这个ATM页面呢

08:53.680 --> 08:55.680
不是一个空的ATM页面

08:55.680 --> 08:57.680
它不是这个样子的

08:57.680 --> 08:59.680
它里面包含了完整的一开始

08:59.680 --> 09:01.680
应该显示的内容

09:01.680 --> 09:03.680
比如说新闻列表啊

09:03.680 --> 09:05.680
导航男啊 这些东西

09:05.680 --> 09:07.680
全部给你宣传出来了

09:07.680 --> 09:09.680
那么由于它ATM里面是不是有内容

09:09.680 --> 09:11.680
那么浏览器拿到这个页面过后

09:11.680 --> 09:13.680
是不是已经有内容了

09:13.680 --> 09:15.680
那么这个时候呢 就已经显示出空页面了

09:15.680 --> 09:17.680
你看第三步就不一样了

09:17.680 --> 09:19.680
第三步之前呢 是处于白屏状态

09:19.680 --> 09:21.680
因为没内容 那现在有内容

09:21.680 --> 09:23.680
它直接就宣传出来了

09:23.680 --> 09:25.680
页面内容了

09:25.680 --> 09:27.680
它不会处于白屏

09:27.680 --> 09:29.680
但是后续还没完

09:29.680 --> 09:31.680
这个时候呢 因为它还有

09:31.680 --> 09:33.680
很多GS 对吧 但是呢

09:33.680 --> 09:35.680
页面内容已经显示出来了

09:35.680 --> 09:37.680
用户已经在浏览了 已经在看页面了

09:37.680 --> 09:39.680
那么这个时候呢 浏览器再去

09:39.680 --> 09:41.680
悄悄的发送CSS图片

09:41.680 --> 09:43.680
GS的寝求

09:43.680 --> 09:45.680
因为页面上有图片吧

09:45.680 --> 09:47.680
那么这两者呢 又发送寝求到服务器

09:47.680 --> 09:49.680
但是呢 不要忘记

09:49.680 --> 09:51.680
这个时候呢 用户已经在浏览页面了

09:51.680 --> 09:53.680
再给浏览器

09:53.680 --> 09:55.680
浏览器再一次开始GS 执行GS

09:55.680 --> 09:57.680
执行Rx的代码

09:57.680 --> 09:59.680
那么接下来呢 后续的宣传

09:59.680 --> 10:01.680
不要忘了用户点了过后 又是什么样的操作

10:01.680 --> 10:03.680
通过挑转网页

10:03.680 --> 10:05.680
就是不刷新的挑转网页

10:05.680 --> 10:07.680
就是用路由嘛

10:07.680 --> 10:09.680
那么就怎么操作

10:09.680 --> 10:11.680
那么后续的东西全部交给浏览器的接管了

10:11.680 --> 10:13.680
服务器它只是给你初始化一个页面效果

10:13.680 --> 10:15.680
剩下的事情交给浏览器宣传

10:15.680 --> 10:17.680
这就是SSR

10:17.680 --> 10:19.680
那么这种做法呢

10:19.680 --> 10:21.680
相对来说就比较好一点了

10:21.680 --> 10:23.680
它就解决了这两个问题

10:23.680 --> 10:25.680
它不会处于白屏

10:25.680 --> 10:27.680
白屏上来是肯定不会出现的

10:27.680 --> 10:29.680
因为最一开始就显示出一面了

10:29.680 --> 10:31.680
为什么处于白屏呢

10:31.680 --> 10:33.680
其实这还有一个原因

10:33.680 --> 10:35.680
就是有些用户的电脑

10:35.680 --> 10:37.680
它的配置呢

10:37.680 --> 10:39.680
不太好

10:39.680 --> 10:41.680
它可能是比较老的配置的

10:41.680 --> 10:43.680
浏览器可能版本比较新

10:43.680 --> 10:45.680
但是呢 电脑呢比较老了

10:45.680 --> 10:47.680
比方我们做开发的电脑一般都是配置的

10:47.680 --> 10:49.680
但是实际上很多的家庭呢

10:49.680 --> 10:51.680
它的电脑的配置呢

10:51.680 --> 10:53.680
可能就一两千块钱

10:53.680 --> 10:55.680
可能并不高

10:55.680 --> 10:57.680
因为它平时也不怎么用 平时都玩手机

10:57.680 --> 10:59.680
在电脑上呢

10:59.680 --> 11:01.680
可能一些手机也用的比较卡了

11:01.680 --> 11:03.680
那么这个时候呢

11:03.680 --> 11:05.680
它指讯介绍的速度就更慢了

11:05.680 --> 11:07.680
但是现在呢 我们在服务器端

11:07.680 --> 11:09.680
把月米卡渲染出来

11:09.680 --> 11:11.680
因为我们服务器呢

11:11.680 --> 11:13.680
是可以自行丢化的

11:13.680 --> 11:15.680
我们可以买一些比较好的服务器

11:15.680 --> 11:17.680
就是压力 以前的服务器没什么压力

11:17.680 --> 11:19.680
我就给了一个空页面

11:19.680 --> 11:21.680
现在的服务器多了一些压力的

11:21.680 --> 11:23.680
它要去帮它确展出一个完整的页面结果

11:23.680 --> 11:25.680
一个完整的页面结果呢

11:25.680 --> 11:27.680
拿给客户端

11:27.680 --> 11:29.680
那么这样子呢 就服务器帮它做了

11:29.680 --> 11:31.680
帮浏览器做了

11:31.680 --> 11:33.680
以前就是这样做的

11:33.680 --> 11:35.680
以前就是用加瓦服务器啊

11:35.680 --> 11:37.680
PAGPRC下午服务器

11:37.680 --> 11:39.680
那么给它把页面确展好

11:39.680 --> 11:41.680
然后扔过去

11:41.680 --> 11:43.680
那是不是说这种情况就打破了

11:43.680 --> 11:45.680
前后端分离

11:45.680 --> 11:47.680
那么这种方式呢 就是服务端宣的

11:47.680 --> 11:49.680
它的缺点呢 就是开发了

11:49.680 --> 11:51.680
相对麻烦一点

11:51.680 --> 11:53.680
咱们的这门客

11:53.680 --> 11:55.680
SSR呢

11:55.680 --> 11:57.680
应该说是一个极大成者

11:57.680 --> 11:59.680
前边里面学习到

11:59.680 --> 12:01.680
很多的前端知识

12:01.680 --> 12:03.680
都要用到这里

12:03.680 --> 12:05.680
因此呢 这位门客

12:05.680 --> 12:07.680
学习的难度高不高

12:07.680 --> 12:09.680
完全取决于你前边

12:09.680 --> 12:11.680
掌握的东西 扎不扎实

12:11.680 --> 12:13.680
你掌握的越扎实

12:13.680 --> 12:15.680
那么这门客的难度就越低

12:15.680 --> 12:17.680
你掌握的越

12:17.680 --> 12:19.680
越模糊

12:19.680 --> 12:21.680
那么这门客的难度就越高

12:21.680 --> 12:23.680
就看你前面掌握的如何了

12:23.680 --> 12:25.680
咱们呢 打开了了解了一下

12:25.680 --> 12:27.680
就是CSR和SSR

12:27.680 --> 12:29.680
其实呢 要解决这两个问题啊

12:29.680 --> 12:31.680
SSR呢 是其中一种办法

12:31.680 --> 12:33.680
还有一种办法

12:33.680 --> 12:35.680
叫做预选的PrayRender

12:35.680 --> 12:37.680
那么预选呢

12:37.680 --> 12:39.680
我们后边SSR

12:39.680 --> 12:41.680
讲完了之后呢 给大家说一下

12:41.680 --> 12:43.680
那东西比较简单的

12:43.680 --> 12:45.680
但是预选呢 还是有一个问题

12:45.680 --> 12:47.680
他解决不了白拼状态

12:47.680 --> 12:49.680
他能有利于SEO

12:49.680 --> 12:51.680
但是他解决不了白拼

12:51.680 --> 12:53.680
你看SSR 他肯定是能解决白拼的

12:53.680 --> 12:55.680
同时呢 他也是利于SEO的

12:55.680 --> 12:57.680
为什么呢 因为

12:57.680 --> 12:59.680
搜索引擎一看

12:59.680 --> 13:01.680
给他的内容就已经有结果了

13:01.680 --> 13:03.680
搜索引擎他不管你什么样是不样是

13:03.680 --> 13:05.680
他主要是拿结果 拿内容

13:05.680 --> 13:07.680
给他的内容了

13:07.680 --> 13:09.680
那么SSR呢

13:09.680 --> 13:11.680
解决到其中一种方案

13:11.680 --> 13:13.680
还有另一种方案 咱们讲完了之后再说

13:13.680 --> 13:15.680
好 接下来我们来看一下我们的课程结构

13:15.680 --> 13:17.680
就我们这么课怎么讲

13:17.680 --> 13:19.680
咱们这么课呢 主要是

13:19.680 --> 13:21.680
两个方面来讲

13:21.680 --> 13:23.680
应该是分成两张

13:23.680 --> 13:25.680
第一张呢 我们主要是

13:25.680 --> 13:27.680
解决

13:27.680 --> 13:29.680
一个理论问题

13:29.680 --> 13:31.680
就是他怎么来的SSR

13:31.680 --> 13:33.680
他怎么出来的

13:33.680 --> 13:35.680
那么这一部分呢 就会用到很多很多的知识

13:35.680 --> 13:37.680
之前学到很多知识会用的

13:37.680 --> 13:39.680
主要是理解SSR

13:39.680 --> 13:41.680
它的原理是怎么回事

13:41.680 --> 13:43.680
它怎么来解决问题

13:43.680 --> 13:45.680
其实SSR的原理特别简单

13:45.680 --> 13:47.680
就是服装渲染

13:47.680 --> 13:49.680
但是呢 在服装渲染的过程中

13:49.680 --> 13:51.680
它会产生非常非常多的问题

13:51.680 --> 13:53.680
因为服系的环境呢 毕竟跟客户端不太一样

13:53.680 --> 13:55.680
还要解决很多很多的细节问题

13:55.680 --> 13:57.680
那么这第一步呢 就第一个章节呢

13:57.680 --> 13:59.680
咱们是手动的搭建工程

13:59.680 --> 14:01.680
从零开始

14:01.680 --> 14:03.680
一步一步把SSR的工程搭建起来

14:03.680 --> 14:05.680
需要这个SSR的能力

14:05.680 --> 14:07.680
那么这一部分学习完了过后

14:07.680 --> 14:09.680
你基本上理解SSR

14:09.680 --> 14:11.680
到底是怎么回事

14:11.680 --> 14:13.680
你们以后在公司里边呢

14:13.680 --> 14:15.680
用SSR的时候呢 实际上不太会

14:15.680 --> 14:17.680
手动搭建工程的 那个太漏了

14:17.680 --> 14:19.680
太浪费时间了 解决的问题太多了

14:19.680 --> 14:21.680
我们一般会用脚踹架

14:21.680 --> 14:23.680
就是一些现成的框架

14:23.680 --> 14:25.680
帮我们完成 比方说像污蔑介石

14:25.680 --> 14:27.680
和那个Negas的介石

14:27.680 --> 14:29.680
到时候呢 我们选择一个吧

14:29.680 --> 14:31.680
选择一个 因为最近呢 我看那个污蔑介石

14:31.680 --> 14:33.680
就更新了 之前我们用的是

14:33.680 --> 14:35.680
2.0的版本 对吧 现在变成3.0了

14:35.680 --> 14:37.680
改动了我还没具体去看

14:37.680 --> 14:39.680
前段时间刚更新的

14:39.680 --> 14:41.680
而且那3.0的 目前还没有

14:41.680 --> 14:43.680
SSR的功能

14:43.680 --> 14:45.680
可能到时候呢 我们如果说选择

14:45.680 --> 14:47.680
污蔑的话 可能还要得用

14:47.680 --> 14:49.680
2.0的版本 好吧

14:49.680 --> 14:51.680
到时候我们再说吧 到底用哪一个

14:51.680 --> 14:53.680
这里是我们的课程结构

14:53.680 --> 14:55.680
主要分成两张来讲 先讲理论

14:55.680 --> 14:57.680
然后再讲那个就是脚踹架

14:57.680 --> 14:59.680
用了脚踹架之后呢 你基本上

14:59.680 --> 15:01.680
关心的 他帮你做完了

15:01.680 --> 15:03.680
然后呢 我们这个

15:03.680 --> 15:05.680
SSR呢 我再说一下

15:05.680 --> 15:07.680
大家呢 这个东西呢

15:07.680 --> 15:09.680
得了解一下

15:09.680 --> 15:11.680
提高一下评 就是以后出去

15:11.680 --> 15:13.680
面试啊 就业的竞争力

15:13.680 --> 15:15.680
这个玩意儿有没有那么的重要呢

15:15.680 --> 15:17.680
实际上呢 没有那么的重要

15:17.680 --> 15:19.680
为什么呢 我跟大家说一下

15:19.680 --> 15:21.680
因为呢 我们的

15:21.680 --> 15:23.680
开发了分成两种

15:23.680 --> 15:25.680
就是你们以后开发前段

15:25.680 --> 15:27.680
分成两个大块

15:27.680 --> 15:29.680
一个呢 是前台开发

15:29.680 --> 15:33.310
前台开发是什么意思呢

15:33.310 --> 15:35.310
就你开发的就是

15:35.310 --> 15:37.310
开发的结果呢 是面向用户的

15:37.310 --> 15:40.750
面向用户的

15:40.750 --> 15:42.750
另外一个呢 是中后台开发

15:42.750 --> 15:44.750
中后的开发呢 主要是

15:44.750 --> 15:46.750
面向管理员的

15:46.750 --> 15:48.750
面向管理员的

15:48.750 --> 15:50.750
就是面向内部用户的

15:50.750 --> 15:52.750
有可能是公司内部用户

15:52.750 --> 15:54.750
有可能是别的公司的内部用户

15:54.750 --> 15:56.750
那么面向用户的呢

15:56.750 --> 15:58.750
肯定要

15:58.750 --> 16:00.750
肯定要满足的两个条件

16:00.750 --> 16:02.750
就是用户体验

16:02.750 --> 16:04.750
你不能长时间摆平

16:04.750 --> 16:06.750
另外一个呢 你还要得

16:06.750 --> 16:08.750
利语SEO 利语搜索引擎优化

16:08.750 --> 16:10.750
就面向

16:10.750 --> 16:12.750
面向用户的

16:12.750 --> 16:14.750
那么面向用户的

16:14.750 --> 16:16.750
有可能有手机应用对吧

16:16.750 --> 16:18.750
App 要用移动转开发

16:18.750 --> 16:20.750
可能有小程序 当然也可以用我们的页面

16:20.750 --> 16:22.750
那如果说我们的页面的话

16:22.750 --> 16:24.750
有不少的技术

16:24.750 --> 16:26.750
可以面向用户 比方说传统的

16:26.750 --> 16:28.750
也比较传统的了

16:28.750 --> 16:30.750
多页应用程序

16:30.750 --> 16:32.750
另外呢 就是单页应用 SPA

16:32.750 --> 16:34.750
那么 SPA 的这一块呢

16:34.750 --> 16:36.750
才会用到

16:36.750 --> 16:38.750
才有可能会用到

16:38.750 --> 16:40.750
有两种方案 一个是 Prefetch

16:40.750 --> 16:42.750
另一种方案呢 就是 SSR

16:42.750 --> 16:44.750
就是 SSR 的话只是在开发

16:44.750 --> 16:46.750
前台应用的时候

16:46.750 --> 16:48.750
面向用户的时候

16:48.750 --> 16:50.750
我们可能会使用 SSR

16:50.750 --> 16:52.750
而中后台开发

16:52.750 --> 16:54.750
摆平就摆平呗

16:54.750 --> 16:56.750
因为中后台开发的话

16:56.750 --> 16:58.750
面向的是管理员

16:58.750 --> 17:00.750
内部用户 它的用户的群体呢

17:00.750 --> 17:02.750
本来就比较小

17:02.750 --> 17:04.750
它不太在乎这个东西

17:04.750 --> 17:06.750
它只在乎功能使不使用

17:06.750 --> 17:08.750
摆平一会 少量的 少量的摆平时间

17:08.750 --> 17:10.750
是可以接受的

17:10.750 --> 17:12.750
而且呢 面向的

17:12.750 --> 17:14.750
就是中后台的话

17:14.750 --> 17:16.750
它也不掺乎 SEO

17:16.750 --> 17:18.750
就算搜索引擎想去读它的页面

17:18.750 --> 17:20.750
它还不让它读 对吧

17:20.750 --> 17:22.750
我们知道可以告诉搜索引擎

17:22.750 --> 17:24.750
要读我的页面

17:24.750 --> 17:26.750
因此呢 面向管理员的时候

17:26.750 --> 17:28.750
中后台开发的时候 实际上是根本没有什么

17:28.750 --> 17:30.750
这两个问题的

17:30.750 --> 17:32.750
摆平问题不存在

17:32.750 --> 17:34.750
而且呢 SEO 的问题也不存在

17:34.750 --> 17:36.750
因此呢 面向中后台开发的时候

17:36.750 --> 17:38.750
根本就不需要 SSR

17:38.750 --> 17:40.750
所以 SSR 应用了仅在这一块

17:40.750 --> 17:42.750
面向前台的时候

17:42.750 --> 17:44.750
又可以用传统的方式

17:44.750 --> 17:46.750
也可以用这种方式

17:46.750 --> 17:48.750
甚至呢 还可以用那种

17:48.750 --> 17:50.750
还可以让后端开发人员帮你完成

17:50.750 --> 17:52.750
你前端都不用管了

17:52.750 --> 17:54.750
后端开发人员用传统的方式给你渲染页面

17:54.750 --> 17:56.750
就是它的用方式很多

17:56.750 --> 17:58.750
那么 SSR 只是其中一种方式

17:58.750 --> 18:00.750
因此呢 用的呢

18:00.750 --> 18:02.750
没有那么的

18:02.750 --> 18:04.750
广泛

18:04.750 --> 18:06.750
因此呢 你们以后呢

18:06.750 --> 18:08.750
只在一种比较特定的情况下

18:08.750 --> 18:10.750
才会用到 SSR

18:10.750 --> 18:12.750
往往是什么呢 往往是大公司

18:12.750 --> 18:14.750
大公司的前后台的分离是比较彻底的

18:14.750 --> 18:16.750
后端它只给你提供接口

18:16.750 --> 18:18.750
它啥都不给你提供

18:18.750 --> 18:20.750
你渲染页面

18:20.750 --> 18:22.750
因此呢 渲染页面的可能得前端来做

18:22.750 --> 18:24.750
前端来做的话

18:24.750 --> 18:26.750
你如果说没有让你选择用传统的方式

18:26.750 --> 18:28.750
不用用接快乐的方式

18:28.750 --> 18:30.750
那么你就得用那个 SSR

18:30.750 --> 18:32.750
对吧

18:32.750 --> 18:34.750
好 这是关于这一块

18:34.750 --> 18:36.750
咱们说 SSR 的定位

18:36.750 --> 18:38.750
因此呢 大家学习这个压力

18:38.750 --> 18:40.750
尽管它这门客可能难度比较高

18:40.750 --> 18:42.750
但是呢 也不用太大的压力

18:42.750 --> 18:44.750
毕竟呢 它应用的贩子或者是只有那么窄

18:44.750 --> 18:46.750
但是呢 你学习过后

18:46.750 --> 18:48.750
对你进入大公司 肯定是有帮助的

18:48.750 --> 18:50.750
好 接下来呢 看一下

18:50.750 --> 18:52.750
前置知识

18:52.750 --> 18:54.750
就咱们学习这门客

18:54.750 --> 18:56.750
它要学哪些前置知识

18:56.750 --> 18:58.750
一个呢 是 这个东西少不了

18:58.750 --> 19:00.750
既然是两个环境 一个是浏览器端开发

19:00.750 --> 19:02.750
就是什么

19:02.750 --> 19:04.750
外表API

19:04.750 --> 19:06.750
ATM5的API

19:06.750 --> 19:08.750
还有什么呢 就是那个

19:08.750 --> 19:10.750
动物啊 这些东西

19:10.750 --> 19:12.750
还有一个是露的环境

19:12.750 --> 19:14.750
这个很重要

19:14.750 --> 19:16.750
浮物器啊 怎么去来

19:16.750 --> 19:18.750
就是

19:18.750 --> 19:20.750
来处理各种路由啊 这些东西呢

19:20.750 --> 19:22.750
你都得学习

19:22.750 --> 19:24.750
然后呢 接下来是ATTP协议

19:24.750 --> 19:26.750
当然这个东西是必须学学的

19:26.750 --> 19:28.750
就知道怎么样啊 浏览器跟

19:28.750 --> 19:30.750
浮览器端是怎么样进行交互的

19:30.750 --> 19:32.750
那么这个玩意儿 你了解的越深刻

19:32.750 --> 19:34.750
那么这个门客的学习难度就越低

19:34.750 --> 19:36.750
你了解的越粗略

19:36.750 --> 19:38.750
那么这个门客的学习难度就越高

19:38.750 --> 19:40.750
还有当然 还有构建工具

19:40.750 --> 19:42.750
因为我们要设计到第一部分

19:42.750 --> 19:44.750
构建工程 肯定WePAC是需要的

19:44.750 --> 19:46.750
那么WePAC的深度理解

19:46.750 --> 19:48.750
另外一个呢 就是REx全家统

19:48.750 --> 19:50.750
因为我们学习的是REx

19:50.750 --> 19:52.750
服务专宣上

19:52.750 --> 19:54.750
REx得学会 其他就没了

19:54.750 --> 19:56.750
这是我们的全日日识

19:56.750 --> 19:58.750
这是这几刻啊 咱们简单介绍一下

19:58.750 --> 20:00.750
这两个部分 SSR和

20:00.750 --> 20:02.750
CSR

20:02.750 --> 20:04.750
下期课开始呢 咱们就开始一步一步的

20:04.750 --> 20:06.750
从第一个部分开始来搭建我们的工程

