WEBVTT

00:00.560 --> 00:03.120
咱们来继续说这个静态话

00:03.640 --> 00:07.460
静态话分两种一种纯静态话我们讲过了对吧

00:07.720 --> 00:11.060
还有一种SSG 那么这一块咱们还是在学习这个SSG

00:11.560 --> 00:12.860
好 纯静态话呢

00:13.120 --> 00:15.160
静态话呢 我们首先总结一下

00:15.920 --> 00:18.480
它发生的时间在什么时候呢 一定要注意啊

00:18.740 --> 00:20.280
静态话发生的时间

00:22.320 --> 00:25.900
是在那个MX build的时候 叫构建的时候

00:26.160 --> 00:30.000
而不是在运行的时候 运行的时候就静态话就已经结束了

00:30.220 --> 00:31.020
就已经结束了

00:31.280 --> 00:34.860
那么到底要不要静态话是谁来决定的 是那个自动的

00:35.380 --> 00:37.940
优化工具 自动优化器 才帮你决定

00:38.440 --> 00:39.740
你如果说一个组建

00:40.240 --> 00:44.080
我们一个这里边 如果说一个组建 他就是一个普普通通的组建

00:44.340 --> 00:46.640
OK 他默默的就不会把他进行静态话

00:46.900 --> 00:48.680
对吧 默的就会进行静态话

00:49.200 --> 00:50.480
好 如果说

00:51.240 --> 00:54.840
那么这个组建 我们不是一个纯粹的组建的

00:55.100 --> 00:57.640
我把这些东西删掉吧 干上来的东西删掉

01:00.980 --> 01:05.320
好 如果说他不是一个

01:05.580 --> 01:07.120
纯粹的组建 他就有数据的

01:07.380 --> 01:09.420
一开始要加载数据的 你看这个movies

01:10.180 --> 01:13.260
那么要加载数据的时候呢 我们就不希望他

01:13.780 --> 01:14.800
进行静态话了

01:15.060 --> 01:17.860
因为你这个玩意儿一静态话就不好整了

01:18.120 --> 01:20.700
那么这里呢 比方说我们这里呢 要获取电影

01:20.940 --> 01:22.480
对吧 电影不是立即获取出来的

01:22.980 --> 01:24.280
他要等一会才能获取出来

01:24.780 --> 01:26.060
那么我们以前是怎么做的

01:26.320 --> 01:28.880
以前是给这个组建加上一个

01:29.180 --> 01:30.220
叫做那个

01:30.960 --> 01:32.920
load data 对吧 一个静态数据

01:33.180 --> 01:37.180
那么希望呢 在宣展的时候呢 先把静态数据宣展完了

01:37.180 --> 01:38.040
过后呢 再去宣

01:38.040 --> 01:40.340
就是静态数据呢 运行完了之后

01:40.860 --> 01:43.420
再去运行这个组建 那么那个时候呢 就有数据了

01:45.220 --> 01:47.020
同样的 类似的方式

01:47.260 --> 01:51.340
那么如果说 我们对某一个组建 要加载一部分数据

01:51.620 --> 01:53.340
那么才能进行宣展的时候呢

01:53.500 --> 01:56.220
那么这个时候的静态话呢 就不能是纯静态话了

01:56.340 --> 01:58.700
就不能先直接确弹组建它的 先加载数据

01:59.020 --> 02:01.020
那么这个时候呢 我们就要用到SSG

02:01.020 --> 02:02.620
叫Server Static Generator

02:03.100 --> 02:04.860
那么这个东西呢 我们来看一下

02:05.100 --> 02:06.220
它有两个部分

02:06.660 --> 02:08.620
有两个关键的函数

02:08.780 --> 02:12.460
一个呢 叫做Get Static Props

02:13.500 --> 02:15.300
那么这个函数呢 它是

02:17.100 --> 02:20.740
当静态话之前会运行

02:21.740 --> 02:23.260
就是我们再说直败点

02:23.380 --> 02:25.260
当宣展组建之前会运行

02:25.940 --> 02:27.460
组建之前会运行

02:27.960 --> 02:30.160
还有另外一个呢 另外我们下节课讲

02:30.160 --> 02:33.160
Gator Static Passage

02:33.720 --> 02:35.800
那么它也是要确展组建之前会运行

02:35.960 --> 02:38.400
我们来下节课来说这个东西 它会解决什么样的问题

02:38.920 --> 02:41.680
那么这一点呢 这个目前的新版本

02:41.680 --> 02:43.560
跟之前的版本呢 就有很大差异了

02:44.000 --> 02:45.520
之前的版本给大家说一下

02:45.520 --> 02:47.760
如果说你去百度啊 或者看到有什么博客啊

02:47.760 --> 02:48.800
说到Dex的介绍

02:49.120 --> 02:52.960
那么之前的那个就是API里边

02:52.960 --> 02:53.640
它是这样子

02:53.880 --> 02:56.040
它是呢 这个这么一个组建啊 这个组建

02:58.080 --> 02:59.520
比方说这个名字叫配级吧

03:00.400 --> 03:02.640
那么之前的做法呢 就有点类似于我们的

03:02.640 --> 03:04.560
类似就是那个low data啊

03:04.560 --> 03:06.160
是给它加一个静态属性

03:06.160 --> 03:08.200
叫做Get Initial

03:09.000 --> 03:11.200
叫做什么 Initial Props

03:11.720 --> 03:13.040
给它加这么一个方法

03:13.560 --> 03:15.440
给它加这么一个方法来进行运行

03:15.760 --> 03:17.480
好 那么现在呢 这个官方的建议

03:17.480 --> 03:18.680
你都不要使用这个玩意了

03:18.680 --> 03:21.440
使用它新改版的这个方式

03:22.960 --> 03:23.800
好 我要擦掉

03:28.240 --> 03:30.240
好 那么继续啊

03:30.560 --> 03:32.320
那么现在我们新版里边呢

03:32.320 --> 03:33.520
它让你怎么做呢

03:33.520 --> 03:35.880
就是如果说的一个组建在宣展之前

03:36.680 --> 03:38.920
那么在服务端需要加载一些数据

03:38.920 --> 03:39.800
才能进行宣展

03:40.560 --> 03:42.320
那么你现在的做法是这样子

03:42.760 --> 03:45.040
你直接export啊 导出

03:45.520 --> 03:47.360
导出呢 因为已经有个模型导出了

03:47.360 --> 03:49.240
对吧 那么你后边只能具名导出

03:49.240 --> 03:50.760
用那个普通导出

03:51.120 --> 03:52.560
导出一个异部函数

03:52.960 --> 03:56.760
这个函数的名字叫做Get Static Props

03:57.880 --> 03:59.600
对吧 这导出这么一个函数

03:59.920 --> 04:02.520
那么它在服务期中它就会运行这个函数

04:02.760 --> 04:05.760
并且呢 把这个函数的返回结果呢

04:05.880 --> 04:08.440
当做属性加载到页面里边去

04:08.600 --> 04:10.000
我们咱们呢 先来看一下

04:10.160 --> 04:11.520
这个函数会不会运行

04:12.280 --> 04:13.360
那么它要返回什么呢

04:13.360 --> 04:14.200
它要返回这个东西

04:14.320 --> 04:16.280
这么一种结构 规定好的

04:16.680 --> 04:19.280
返回一个对象 那个对象里边有个属性叫做Props

04:20.560 --> 04:21.240
Props

04:21.440 --> 04:22.560
那么这个属性呢有什么

04:22.680 --> 04:24.800
那么这个属性里边写什么 那随便了

04:25.180 --> 04:26.700
比方说我们要得到数据

04:26.700 --> 04:27.740
得到哪些数据

04:27.740 --> 04:29.620
那么这个对象里边有哪些东西

04:29.620 --> 04:30.620
那随便 自定义

04:30.860 --> 04:32.460
整体来 咱们先随便写一个吧

04:32.460 --> 04:33.340
先随便写一个

04:34.700 --> 04:35.660
那么我们写好了

04:35.660 --> 04:36.620
我们把那个刷掉

04:38.060 --> 04:38.780
接下来呢

04:38.780 --> 04:40.300
我们在这里输出一个

04:40.300 --> 04:42.540
输出一个Get Static Props

04:42.540 --> 04:44.580
咱们先来看一下 走一下这个流程

04:45.020 --> 04:46.340
那么现在我们写好了

04:46.660 --> 04:50.580
只要这个自动优化器发现了某一个页面

04:50.580 --> 04:52.100
这东西必须在页面里面

04:52.300 --> 04:53.540
无论是这个东西还是这个东西

04:53.540 --> 04:54.340
我们下里头讲的

04:54.520 --> 04:56.680
它都必须要在页面组件里边

04:56.680 --> 04:57.680
你不能在App里边

04:58.120 --> 04:59.120
你不能在App里边

04:59.320 --> 05:00.880
你必须要在页面组件里边

05:02.000 --> 05:03.480
而且其他组件都不行

05:03.480 --> 05:04.400
它是怎么回事呢

05:04.400 --> 05:05.280
它是这么一个道理

05:05.280 --> 05:05.880
就是说

05:05.880 --> 05:08.400
因为我们最终是访问到页面

05:08.400 --> 05:08.640
对吧

05:08.640 --> 05:09.440
我们浏览器

05:09.440 --> 05:11.680
就是服务器端最终是要给它一个页面

05:11.680 --> 05:13.840
那么这个页面需要哪些数据呢

05:13.840 --> 05:15.480
你应该完整的加载出来

05:15.480 --> 05:17.240
因为你这个页面需要哪些数据

05:17.240 --> 05:18.240
你肯定是知道的

05:18.240 --> 05:19.560
那么你要完整的加载出来

05:19.560 --> 05:20.720
那是这么一个意识

05:21.120 --> 05:22.920
那么现在我们看一下

05:23.140 --> 05:24.540
那么这个函数什么时候运行

05:24.540 --> 05:25.340
还是一样的

05:25.900 --> 05:27.220
在next build的时候

05:27.220 --> 05:29.540
就开发模式这些东西都是失销的

05:29.540 --> 05:31.460
开发模式它就会把它当成服务端渲染

05:31.460 --> 05:32.460
每次要运行

05:32.460 --> 05:33.580
但是 build

05:33.580 --> 05:36.140
真正的起作用是在next build的时候

05:36.140 --> 05:36.820
好 咱们再试一下

05:37.380 --> 05:39.180
我们运行npm run build

05:39.180 --> 05:40.180
也就是next build

05:41.020 --> 05:41.780
我们来看一下

05:41.780 --> 05:43.020
刚才那句话有没有输出

05:54.670 --> 05:55.590
我们再来看一下

05:55.590 --> 05:56.630
看一下一个代码

05:56.630 --> 05:59.030
就是一个普通导出一个异部函数

06:00.010 --> 06:03.130
然后它会在build的时候运行这个函数

06:05.410 --> 06:06.610
那么现在你看

06:06.610 --> 06:07.490
现在不一样了

06:07.490 --> 06:09.090
现在这个move is这个页面

06:09.810 --> 06:11.410
它把它变成这么一个东西了

06:11.410 --> 06:12.530
变成这么一个东西了

06:12.530 --> 06:13.250
这是什么

06:13.250 --> 06:14.570
SSG

06:14.570 --> 06:15.850
服务端渲染

06:15.850 --> 06:16.450
服务端渲染

06:16.450 --> 06:18.210
它这个API肯定是服务端渲染的

06:18.210 --> 06:18.730
对吧

06:18.730 --> 06:21.930
API就是肯定是我们传统的方式

06:21.930 --> 06:24.170
SSR

06:24.170 --> 06:24.810
因为为什么

06:24.810 --> 06:27.250
因为API每次都必须要运行

06:27.350 --> 06:28.230
那么但是呢

06:28.230 --> 06:29.270
这个move is

06:29.270 --> 06:30.750
还把它变成了SSG

06:30.750 --> 06:32.630
表示服务端静态生成

06:33.710 --> 06:34.310
那么这个时候

06:34.310 --> 06:34.870
我们来看一下

06:34.870 --> 06:37.070
之前有没有运行这个get static props

06:37.070 --> 06:37.750
是不是有

06:37.750 --> 06:38.350
对吧

06:38.350 --> 06:40.150
那么输出了这么一句话

06:40.150 --> 06:40.470
说明了

06:40.470 --> 06:42.630
这个海朔已经运行了

06:42.630 --> 06:42.790
好

06:42.790 --> 06:44.030
接着我们再来看

06:44.030 --> 06:45.470
那么现在我们再用这个东西

06:45.470 --> 06:46.310
把起动起来

06:46.310 --> 06:47.230
npm start

06:48.270 --> 06:49.030
起动起来

06:49.030 --> 06:49.470
你看一下

06:49.470 --> 06:51.790
后续访问这个move is叶变

06:51.790 --> 06:54.430
需不需要运行这个方法

06:54.930 --> 06:56.490
我看一下

06:56.490 --> 06:57.210
啊

06:57.210 --> 06:57.850
localhost

06:59.850 --> 07:00.330
move is

07:01.610 --> 07:01.890
好

07:01.890 --> 07:02.810
访问这个啊

07:02.810 --> 07:03.370
我来刷新

07:04.570 --> 07:05.530
再刷新

07:05.530 --> 07:06.410
再刷新

07:06.410 --> 07:07.210
请求了很多次啊

07:07.210 --> 07:07.610
对吧

07:07.610 --> 07:08.450
那么这里呢

07:08.450 --> 07:10.410
有没有运行啊

07:10.410 --> 07:11.730
有没有运行啊

07:11.730 --> 07:14.410
他这里给你显示那个proxy

07:14.410 --> 07:15.570
proxy没关系

07:15.570 --> 07:16.410
那么现在有没有运行

07:16.410 --> 07:18.050
这个get static props

07:18.050 --> 07:18.850
有没有运行这个

07:18.850 --> 07:19.890
是不再运行的

07:19.890 --> 07:20.610
对吧

07:20.610 --> 07:22.010
那么我们再来看一下啊

07:22.010 --> 07:22.930
如果说我在这里

07:24.490 --> 07:25.530
服务端这里啊

07:25.530 --> 07:26.570
输出一个render

07:26.570 --> 07:28.490
move is render

07:28.490 --> 07:30.170
那么这里要不要运行的

07:30.170 --> 07:30.770
咱们来看一下

07:31.890 --> 07:33.170
我们都是关注服务端啊

07:33.170 --> 07:33.850
再重新打包

07:41.180 --> 07:42.100
那么

07:42.100 --> 07:43.300
大家可以想一想

07:43.300 --> 07:44.180
这里要不要运行

07:45.460 --> 07:46.580
要不要运行

07:46.580 --> 07:48.460
其实他也不会运行了

07:48.460 --> 07:49.540
也不会运行了

07:49.540 --> 07:50.900
为什么也不会运行了呢

07:50.900 --> 07:52.660
因为他已经静态化了

07:52.660 --> 07:53.500
他已经静态化了

07:53.500 --> 07:54.620
其实他跟蠢静态化

07:54.620 --> 07:55.980
唯一的区别就在于

07:55.980 --> 07:57.340
这种静态化的方式呢

07:57.340 --> 07:58.260
他会先运行

07:58.280 --> 07:59.720
他如果说有这么一个含书

07:59.720 --> 08:01.560
他会先运行这个含书

08:01.560 --> 08:03.840
然后再去渲染逐渐

08:03.840 --> 08:05.240
就这么一个区别

08:05.240 --> 08:06.640
先让我们再看一下

08:06.640 --> 08:11.440
刷新刷新刷新刷新刷新刷新刷新刷新

08:11.440 --> 08:11.600
好

08:11.600 --> 08:12.400
那么现在我们看一下

08:12.400 --> 08:13.160
这里有没有运行

08:13.160 --> 08:14.360
什么都没运行

08:14.360 --> 08:16.760
服务端都不再也不会渲染逐渐了

08:16.760 --> 08:17.960
因为它是静态化的

08:17.960 --> 08:18.720
他会怎么样呢

08:18.720 --> 08:20.600
他直接给你这个atmail

08:20.600 --> 08:22.080
因为他生成了atmail了

08:22.080 --> 08:23.440
你看move is

08:23.440 --> 08:24.720
他直接给这个atmail

08:24.720 --> 08:26.760
他直接把他扔给你就完事了

08:26.760 --> 08:27.720
它是这么一回事

08:27.740 --> 08:29.620
那么那客户端肯定要运行的

08:29.620 --> 08:31.980
客户端肯定要运行这个move is

08:31.980 --> 08:34.340
但是客户端是运行不了这个的

08:34.340 --> 08:35.220
这种含书

08:35.220 --> 08:36.780
该含书

08:36.780 --> 08:39.660
该含书只可能

08:41.620 --> 08:43.460
在服务端运行

08:43.460 --> 08:45.500
绝对不可能在客户端运行的

08:45.500 --> 08:46.500
也就是这个含书里边

08:46.500 --> 08:47.940
你可以玩什么东西出来

08:47.940 --> 08:49.500
你可以写各种各样的代码

08:49.500 --> 08:50.020
这个里边

08:50.020 --> 08:51.420
甚至你可以直接读数据户

08:51.420 --> 08:54.140
如果说你数据户也集成在这个工程里边

08:54.140 --> 08:56.100
那么你可以直接读数据户了在这里

08:56.160 --> 08:57.920
因为它只有服务端代码可以运行

08:57.920 --> 09:00.800
另外就是这个含书

09:00.800 --> 09:04.000
该含书运行在什么时候

09:04.000 --> 09:05.520
在组建宣传之前

09:09.040 --> 09:15.360
该含书只能在必有的期间运行

09:15.360 --> 09:16.960
而不是每一次请求运行

09:16.960 --> 09:17.520
必有的期间

09:17.520 --> 09:18.960
就是必有的时候

09:18.960 --> 09:20.760
然后运行这个含书拿到数据

09:20.760 --> 09:22.640
然后再宣传组建

09:22.640 --> 09:24.000
那么现在我们再关注

09:24.060 --> 09:25.460
这个数据跑哪去了

09:27.020 --> 09:29.140
那么这个数据是怎么回事呢

09:29.140 --> 09:29.700
挨在来说

09:31.460 --> 09:33.540
这个数据它是这样子

09:33.540 --> 09:36.100
它会把你返回的不是个对象吗

09:36.100 --> 09:37.180
对象里面不是一个属性吗

09:37.180 --> 09:37.660
Prob's

09:37.660 --> 09:38.340
有些人说

09:38.340 --> 09:41.540
那为什么不干脆直接返回这个对象就行了

09:41.540 --> 09:43.260
它是有这么一个考虑

09:43.260 --> 09:44.260
将来可能会

09:44.260 --> 09:45.780
因为这个是在服端运行的

09:45.780 --> 09:48.020
将来它可能会多加一些属性

09:48.020 --> 09:50.300
跟服端的一些其他功能配合

09:50.300 --> 09:51.220
所以说我们

09:51.240 --> 09:52.960
它目前只做了这么一个属性

09:52.960 --> 09:53.520
Prob's

09:53.520 --> 09:56.000
那么现在它会这样子

09:56.000 --> 09:59.120
它会让你返回了对象里面的Prob's属性

10:00.480 --> 10:01.920
返回的对象中

10:01.920 --> 10:06.480
返回的对象中的Prob's属性

10:06.480 --> 10:08.280
将被混合到

10:10.000 --> 10:11.120
混合到

10:11.120 --> 10:12.160
混合到哪儿

10:12.160 --> 10:16.680
混合到整个组建属性中

10:16.680 --> 10:18.440
什么叫整个组建属性

10:18.440 --> 10:20.120
如果说你有App组建

10:20.300 --> 10:21.500
如何你这么一个App组建

10:21.500 --> 10:23.700
那么这个就是整个组建属性

10:23.700 --> 10:24.540
整个组建属性里面

10:24.540 --> 10:26.380
我们是不是看到有很多东西

10:26.380 --> 10:26.820
有什么呢

10:26.820 --> 10:29.380
我们之前看到过的有Component

10:29.380 --> 10:30.660
表示我要渲染的页面

10:30.660 --> 10:31.420
对吧

10:31.420 --> 10:32.580
然后还有什么呢

10:32.580 --> 10:34.780
还有那个就是Rotor

10:34.780 --> 10:35.380
还有Rotor

10:35.380 --> 10:35.980
对不对

10:35.980 --> 10:38.300
表示我们的路由

10:38.300 --> 10:38.620
对不对

10:38.620 --> 10:39.580
我们的路由

10:39.580 --> 10:40.740
还有一些别的玩意儿

10:40.740 --> 10:43.540
那么其中有一个属性叫做配级

10:43.540 --> 10:45.220
Datas

10:45.220 --> 10:46.660
就是我们整个组建的属性

10:46.660 --> 10:48.660
它把方法运行完了过来

10:48.660 --> 10:49.580
要渲染的组建

10:49.580 --> 10:52.680
整个组建的属性有这么一些Component

10:52.680 --> 10:54.520
表示的是我们要渲染的页面

10:54.520 --> 10:55.800
页面组建

10:55.800 --> 10:57.880
然后Rotor表示我们的路由

10:57.880 --> 10:58.920
然后配级Datas

10:58.920 --> 10:59.680
配级Datas是什么

10:59.680 --> 11:01.600
是一个空对象

11:01.600 --> 11:04.640
里面啥都没有

11:04.640 --> 11:05.960
那么这个配级Datas

11:05.960 --> 11:09.320
它就会混合进这个东西

11:09.320 --> 11:11.040
它就会混合到这个里面

11:11.040 --> 11:11.840
就会把这个东西

11:11.840 --> 11:14.080
混合到这个配级Datas里面

11:14.080 --> 11:15.360
就这么一个意思

11:15.360 --> 11:16.800
所以说我们页面要的是什么

11:16.800 --> 11:18.320
我们页面往往要的是这个东西

11:18.320 --> 11:18.800
像这些东西

11:19.540 --> 11:20.820
页面它本身就是自己

11:20.820 --> 11:22.140
还不需要这个东西

11:22.140 --> 11:23.180
然后页面路由

11:23.180 --> 11:25.100
它可以使用UseRotor

11:25.100 --> 11:26.540
我之前做过的

11:26.540 --> 11:28.060
在这

11:28.060 --> 11:29.420
UseRotor

11:29.420 --> 11:31.460
那么这里面后面可以找到Rotor

11:31.460 --> 11:32.940
其实它也不需要

11:32.940 --> 11:35.220
因为真正需要的是这个东西

11:35.220 --> 11:37.740
因此我们把这个App组建改造一下

11:37.740 --> 11:40.740
我们这里就不把生命的属性全部传给它了

11:40.740 --> 11:41.540
而只要什么

11:41.540 --> 11:43.140
配级Datas

11:43.140 --> 11:44.540
配级Probs

11:44.540 --> 11:46.540
选错了

11:46.540 --> 11:47.380
配级Probs

11:47.440 --> 11:49.920
那么我们这里放过去

11:49.920 --> 11:51.760
把配级Probs传过去

11:51.760 --> 11:52.680
没问题吧

11:52.680 --> 11:54.680
那么现在我们这里的型号就不用管它了

11:54.680 --> 11:55.520
然后我们回到这里

11:55.520 --> 11:58.160
我们现在在这里输出一下

11:58.160 --> 11:59.880
Probs

11:59.880 --> 12:01.240
我们在这里输出一下

12:01.240 --> 12:02.120
Probs

12:02.120 --> 12:02.840
你看一下

12:02.840 --> 12:04.520
我们这里的函数反回的结果

12:04.520 --> 12:06.440
它就会混入到配级Probs

12:06.440 --> 12:07.240
配级Probs

12:07.240 --> 12:08.480
是不是来现场组建的时候

12:08.480 --> 12:10.480
是不是先传给App

12:10.480 --> 12:12.560
App又传给我们的Control

12:12.560 --> 12:14.680
那么我们之后就可以这样认为

12:14.680 --> 12:16.120
这里反回了这个东西

12:16.140 --> 12:18.860
它就直接到这个这个组建里边去了

12:18.860 --> 12:19.020
好

12:19.020 --> 12:20.100
咱们再试一下

12:20.100 --> 12:24.540
现在我们再重新Build

12:24.540 --> 12:28.260
然后我们再Rampuild

12:29.460 --> 12:30.100
一定要注意

12:30.100 --> 12:31.980
像Render在服务端

12:31.980 --> 12:33.180
在Render的时候

12:33.180 --> 12:35.100
和这个就是在Build的时候

12:35.100 --> 12:36.660
才会运行这两个

12:36.660 --> 12:38.020
后续已经静态化了

12:38.020 --> 12:38.980
变成静态一面了

12:38.980 --> 12:40.540
它不再运行了

12:40.540 --> 12:41.900
OK

12:41.900 --> 12:43.340
那么这里呢

12:43.340 --> 12:44.380
咱们看一下

12:44.380 --> 12:46.260
打包完成

12:46.260 --> 12:47.140
打包完成

12:47.160 --> 12:48.360
那么你看一下

12:48.360 --> 12:50.120
是不是在Build的时候运行了这个

12:50.120 --> 12:51.520
Build的时候是不是运行了渲染

12:51.520 --> 12:53.840
Movies Render 都要A等于B等于R

12:53.840 --> 12:55.720
那么我们再看后续

12:55.720 --> 12:58.880
NPM Start

12:58.880 --> 13:00.920
它这样做了就是为了提高效率

13:00.920 --> 13:02.240
刷新

13:02.240 --> 13:03.200
你看

13:03.200 --> 13:03.880
再刷新

13:03.880 --> 13:05.360
但是这东西客户端肯定要运行

13:05.360 --> 13:07.240
Movies Render客户端肯定要运行的

13:07.240 --> 13:09.240
因为它要接管后续渲染

13:09.240 --> 13:10.720
然后我们看服务器有没有运行

13:10.720 --> 13:11.600
是没有运行

13:11.600 --> 13:13.360
因为服务器给力的就是静态一面

13:13.360 --> 13:14.920
就像我们之前画的一张图

13:14.920 --> 13:17.440
它不再进行服务端渲染的

13:17.540 --> 13:19.380
而不是进行我们传统的SSR

13:19.380 --> 13:21.660
直接把静态一面扔给你

13:21.660 --> 13:22.860
只不过现在多了一个步骤

13:22.860 --> 13:24.260
就是加载数据

13:24.260 --> 13:27.700
而且它这个东西是不是会传到我们这里

13:27.700 --> 13:28.820
对吧

13:28.820 --> 13:30.860
那么接下来怎么玩

13:30.860 --> 13:31.340
接下来怎么玩

13:31.340 --> 13:32.380
我们先看一下这个

13:32.380 --> 13:34.500
客户端这里为什么也能得到数据

13:34.500 --> 13:35.940
你不说这个数据是服务器

13:35.940 --> 13:36.820
对吧

13:36.820 --> 13:38.340
这个客户端也没有运行这个方法

13:38.340 --> 13:39.980
它怎么能得到数据的

13:39.980 --> 13:41.260
我们在点击右键

13:41.260 --> 13:42.500
查看一面元代

13:42.500 --> 13:44.180
我们可以看到静态一面里面

13:44.180 --> 13:46.100
它给你加了这么一个东西

13:46.160 --> 13:47.480
配级Prob's

13:47.480 --> 13:48.200
它没

13:48.200 --> 13:49.760
所以加了这么一个东西

13:49.760 --> 13:50.720
加了这么一个东西

13:50.720 --> 13:52.080
它是不是就可以拿到数据了

13:52.080 --> 13:52.360
对吧

13:52.360 --> 13:53.840
就可以拿到数据了

13:53.840 --> 13:55.080
是这么一回事

13:55.080 --> 13:55.840
是这么一回事

13:55.840 --> 13:57.200
那么这里配级Prob's

13:57.200 --> 13:59.920
它有点类似于我们以前的Ridax里面的

13:59.920 --> 14:01.440
就是数据脱水

14:01.440 --> 14:03.200
服务端把数据扔到客户端

14:03.200 --> 14:07.000
客户端再把数据注入到自己的数据里边

14:07.000 --> 14:07.560
那么它就

14:07.560 --> 14:09.760
客户端就可以拿到这个数据了

14:09.760 --> 14:10.440
OK

14:10.440 --> 14:12.560
那么这里我们还另外再说一点

14:12.560 --> 14:13.160
另外再说一点

14:13.160 --> 14:14.680
就是关于一面切换

14:14.740 --> 14:16.420
如果说我没有访问手页

14:16.420 --> 14:18.380
没有访问电影

14:18.380 --> 14:20.540
我一开始是访问手页的

14:20.540 --> 14:22.100
我一开始访问的是手页

14:22.100 --> 14:23.860
访问的不是电影页

14:23.860 --> 14:26.540
那么我们切换到电影能拿到这个数据吗

14:26.540 --> 14:27.420
切换到电影

14:27.420 --> 14:29.020
你看我也能拿到这个数据

14:29.020 --> 14:30.020
这就奇怪了

14:30.020 --> 14:32.220
因为我访问的是手页

14:32.220 --> 14:33.140
我访问的是手页

14:33.140 --> 14:34.900
我们查看元代吧

14:34.900 --> 14:36.380
访问的是手页的时候

14:36.380 --> 14:38.180
这个地方是没有数据的

14:38.180 --> 14:39.060
是没有数据的

14:39.060 --> 14:40.220
手页哪有这个数据

14:40.220 --> 14:41.740
配级Prob's是没有的

14:41.740 --> 14:43.180
没有A等于B等于2

14:43.200 --> 14:45.040
那么我们现在是无刷新跳转

14:45.040 --> 14:46.600
没有请求服务器

14:46.600 --> 14:48.800
那么我们是不数据脑海的呢

14:48.800 --> 14:49.760
他是做了这么一个处理

14:49.760 --> 14:51.480
大家稍微聊一下就行了

14:51.480 --> 14:53.160
他在生成静态页面的时候

14:53.160 --> 14:55.560
就是有当年使用SSG的时候

14:55.560 --> 14:57.520
他会在生成静态页面的时候

14:57.520 --> 14:59.160
他会做这么两个事

14:59.160 --> 14:59.760
生成

15:01.200 --> 15:04.080
一个是生成ATM

15:04.080 --> 15:06.400
一个是生成一个接生格式

15:06.400 --> 15:08.120
那么这个接生格式的文件是什么

15:08.120 --> 15:08.840
我们来看一下吧

15:10.080 --> 15:11.400
看一下一个接生格式的文件

15:13.920 --> 15:15.120
在无位置接生

15:15.120 --> 15:15.960
你看没

15:15.960 --> 15:17.480
非常简单

15:17.480 --> 15:19.680
这个接生的就是把数据

15:19.680 --> 15:21.360
用一个接生格式放在这

15:21.360 --> 15:22.680
然后呢

15:22.680 --> 15:23.880
然后我们来看一下

15:25.440 --> 15:26.360
看一个网络请求

15:28.680 --> 15:30.280
那么双信是手页

15:30.280 --> 15:32.080
我们把这个东西关了

15:32.080 --> 15:32.880
然后点击电影

15:34.520 --> 15:35.080
点击电影

15:35.840 --> 15:36.760
那么你看接生

15:38.240 --> 15:39.400
所以把这个数据拿到了

15:39.400 --> 15:41.400
他是通过一个请求去拿到这个数据的

15:41.400 --> 15:42.040
是这么回事

15:43.020 --> 15:45.020
好

15:45.020 --> 15:45.820
这是关于这一块

15:46.940 --> 15:48.260
那么这里我们再继续写

15:49.060 --> 15:50.500
那现在知道这一点了之后

15:51.020 --> 15:52.780
接下来我们要写怎么来写电影

15:52.780 --> 15:53.660
电影数据

15:53.660 --> 15:54.540
那就非常简单了

15:54.540 --> 15:54.940
对吧

15:54.940 --> 15:55.820
我们这里导入

15:56.620 --> 15:57.180
Gate

15:58.940 --> 15:59.380
Front

15:59.380 --> 16:00.780
来自于哪里呢

16:02.380 --> 16:03.220
Services

16:03.220 --> 16:04.420
Movies Service

16:04.420 --> 16:05.420
这里Gate Movie

16:06.860 --> 16:07.180
好

16:07.180 --> 16:08.780
接下来我们在这里调用这个

16:09.500 --> 16:10.380
Gate Movies

16:11.360 --> 16:12.720
就第一页吧

16:12.720 --> 16:13.360
就第一页

16:14.160 --> 16:15.240
Await

16:15.240 --> 16:16.040
等待他

16:16.040 --> 16:17.320
然后拿到一个电影结果

16:17.320 --> 16:17.600
对吧

16:17.600 --> 16:18.800
拿到一个响应结果

16:18.800 --> 16:19.920
那么我们该返回什么呢

16:19.920 --> 16:21.000
返回的是电影数据

16:21.000 --> 16:21.480
对吧

16:21.480 --> 16:22.320
电影数据

16:22.320 --> 16:23.480
那我们这里呢

16:23.480 --> 16:24.280
就给他写个

16:24.280 --> 16:25.240
Data

16:25.240 --> 16:26.000
电影数据

16:26.000 --> 16:26.720
或者是Movies

16:27.720 --> 16:29.240
那么这个Risb叫Data

16:29.240 --> 16:30.200
对吧

16:30.200 --> 16:31.440
那么接下来这是个数据

16:31.440 --> 16:32.360
我们在这里可以解构

16:33.600 --> 16:34.360
Movies

16:34.360 --> 16:35.560
那么我们这里要选两个数据

16:35.560 --> 16:36.120
就行了

16:36.120 --> 16:36.600
对吧

16:36.600 --> 16:37.280
选那个数据

16:37.280 --> 16:37.920
到这里呢

16:37.920 --> 16:38.840
我们再看一下

16:38.900 --> 16:39.420
Ul

16:40.540 --> 16:41.780
这人我们就可以使用

16:41.780 --> 16:42.620
Li

16:42.620 --> 16:43.340
不不

16:43.340 --> 16:45.140
Movies.Map

16:45.940 --> 16:46.140
M

16:47.020 --> 16:48.140
每一个就生成一个Li

16:49.140 --> 16:49.500
Li

16:52.620 --> 16:53.460
每个Li里边

16:53.460 --> 16:54.580
那我们写个link

16:54.580 --> 16:56.580
链接超链接

16:56.580 --> 16:57.140
超链接

16:57.140 --> 16:58.300
那我们先暂时不写吧

16:58.300 --> 17:00.460
我们就直接一个

17:00.460 --> 17:01.260
实变元素吧

17:01.260 --> 17:03.220
我们直接来一个实变元素

17:03.220 --> 17:03.900
实变元素的话

17:03.900 --> 17:05.220
我们里边显示

17:05.220 --> 17:05.740
M点

17:05.840 --> 17:06.240
怎么

17:08.560 --> 17:09.280
M点

17:09.280 --> 17:09.960
内

17:09.960 --> 17:10.240
对吧

17:12.240 --> 17:13.640
我怎么写成无忧的写法

17:13.640 --> 17:14.640
M点

17:14.640 --> 17:16.040
电影的名称

17:16.040 --> 17:16.840
对吧

17:16.840 --> 17:17.440
OK

17:17.440 --> 17:17.880
那么这里呢

17:17.880 --> 17:19.000
我们还可以给他一个什么

17:19.000 --> 17:20.040
keyz

17:20.040 --> 17:20.800
keyz

17:20.800 --> 17:22.360
该是M点

17:22.360 --> 17:23.880
ID

17:23.880 --> 17:24.240
行了

17:24.240 --> 17:25.520
那我们就写好了

17:25.520 --> 17:26.160
接下来我们再来看

17:29.680 --> 17:30.440
Build

17:30.440 --> 17:30.880
RoundBuild

17:43.120 --> 17:43.760
好

17:43.760 --> 17:45.000
那么这里呢完成

17:45.000 --> 17:45.480
完成

17:46.160 --> 17:47.200
那么现在我们来看一下

17:47.200 --> 17:48.360
我们的形成的静态

17:48.360 --> 17:49.000
静态页面

17:51.600 --> 17:52.120
静态页面

17:52.120 --> 17:53.400
Movies

17:53.400 --> 17:56.560
你看Movies里边是不是就把这些数据全部加进来了

17:56.560 --> 17:58.400
数据全部加进来了

17:58.400 --> 17:59.680
而且呢

17:59.680 --> 18:01.840
我们的就是整个接上格式的数据

18:01.840 --> 18:02.640
就是我们这个

18:02.640 --> 18:04.040
这个地方返回的数据呢

18:04.040 --> 18:06.680
他把它放到了一面的配级data里边

18:06.680 --> 18:07.520
配级property

18:07.520 --> 18:09.280
配级property里边

18:09.280 --> 18:12.440
那么方便的在客户端重现这个数据

18:12.440 --> 18:14.760
对于客户端毕竟要接管后续现在

18:14.820 --> 18:16.780
他必须要知道出属化数据是什么

18:16.780 --> 18:18.060
然后这个接上格式呢

18:18.060 --> 18:19.700
你看这里边也有数据

18:19.700 --> 18:21.140
那么这个是防止

18:21.140 --> 18:22.660
离开是访问的不是这个页面

18:22.660 --> 18:23.500
访问的是别的页面

18:23.500 --> 18:24.820
别的页面是没这个数据的

18:24.820 --> 18:25.940
那么挑了这个页面的时候

18:25.940 --> 18:27.460
会自动去加在这个接上

18:27.460 --> 18:29.060
把这个数据还原

18:29.060 --> 18:29.660
OK

18:29.660 --> 18:31.100
那么现在呢就特别厉害了

18:31.100 --> 18:31.820
现在特别厉害了

18:31.820 --> 18:33.500
我们来看一下吧

18:33.500 --> 18:34.140
npm start

18:35.860 --> 18:36.620
npm start

18:38.620 --> 18:39.020
运行

18:40.220 --> 18:41.060
运行出来过后了

18:41.060 --> 18:42.020
我们在这里刷新一下

18:42.800 --> 18:44.800
那么现在呢

18:44.800 --> 18:46.640
那我们把这个稍微处理一下吧

18:46.640 --> 18:49.080
把这个把这个模板啊

18:49.080 --> 18:50.080
稍微处理一下

18:50.080 --> 18:51.200
这里我们放个div

18:53.200 --> 18:54.360
太靠边了

18:54.360 --> 18:55.640
加个style吧

18:55.640 --> 18:56.360
简单处理一下

18:57.360 --> 18:57.720
配定

18:58.840 --> 19:01.080
来个试试吧

19:01.080 --> 19:01.600
重新来一试

19:03.440 --> 19:05.360
因为现在我们没有用调试模式

19:05.360 --> 19:06.360
没有用开发模式

19:06.360 --> 19:07.120
那开发模式呢

19:07.120 --> 19:07.800
这里边呢

19:07.800 --> 19:09.840
就跟那个传统的ssr一样

19:09.840 --> 19:11.160
开发模式下面就不一样了

19:11.220 --> 19:12.340
因为它要调试

19:12.340 --> 19:14.260
所以它每次都会运行这个函数

19:14.260 --> 19:15.420
把这个函数返回结果

19:15.420 --> 19:16.340
得到结果之后呢

19:16.340 --> 19:17.500
再来渲染

19:17.500 --> 19:18.820
这个开发模式里面的情况

19:20.140 --> 19:23.740
npm run build

19:23.740 --> 19:24.500
那有些同学说

19:24.500 --> 19:26.420
那这个东西只能在服务器运行的吧

19:26.420 --> 19:28.340
那么我们客户端要接管后续的渲染

19:28.340 --> 19:29.340
后续的处理呢

19:29.340 --> 19:31.180
那你就用user face吧

19:31.180 --> 19:31.340
对吧

19:31.340 --> 19:33.460
我们之前的那个副作用处理的hook

19:33.460 --> 19:35.700
或者是用那个内图件的

19:35.700 --> 19:37.300
就是component did mount

19:37.300 --> 19:37.540
对吧

19:37.540 --> 19:38.900
这东西就会接管后续处理

19:40.620 --> 19:42.500
所以大家为什么建议你

19:42.520 --> 19:44.760
不要之前跟我们学习reactor的时候

19:44.760 --> 19:47.080
它建议你不要用使用那个什么的

19:47.080 --> 19:47.520
不要

19:48.800 --> 19:51.880
建议你不要使用那个component real mount

19:51.880 --> 19:53.080
为什么就不建议你不要使用

19:53.080 --> 19:53.880
因为那个玩意儿

19:53.880 --> 19:56.200
它会在服务端运行也会在客户端运行

19:56.200 --> 19:58.400
那么终于非常非常容易出问题

19:58.400 --> 20:01.800
这些时候

20:01.800 --> 20:02.080
ok

20:04.120 --> 20:04.360
好

20:04.360 --> 20:05.520
那么现在呢

20:05.520 --> 20:05.880
消耗了

20:07.080 --> 20:10.960
我们start

20:10.960 --> 20:11.080
好

20:11.080 --> 20:12.080
双心

20:12.080 --> 20:12.640
那么注意啊

20:12.640 --> 20:14.000
现在是静态一面哦

20:14.000 --> 20:14.760
那怎么来看呢

20:14.760 --> 20:15.640
是不是静态一面

20:15.700 --> 20:16.900
我们现在看着啊

20:16.900 --> 20:19.180
我们直接把这个gsh该进用了

20:20.460 --> 20:21.020
加把sql

20:21.020 --> 20:22.260
都不允许它运行的

20:22.260 --> 20:23.980
不准它运行gsh的

20:23.980 --> 20:24.100
好

20:24.100 --> 20:25.380
咱们来看一下吧

20:25.380 --> 20:26.140
双心

20:26.140 --> 20:26.540
你看

20:26.540 --> 20:28.100
真正可以得到这个页面的

20:28.100 --> 20:29.020
真正可以得到这个页面的

20:29.020 --> 20:30.420
gsh执行不了了啊

20:30.420 --> 20:31.180
gsh啥都没有

20:31.180 --> 20:32.340
啥都没法执行

20:32.340 --> 20:32.740
但是呢

20:33.780 --> 20:34.780
看页面是没问题的

20:34.780 --> 20:35.940
这就是

20:35.940 --> 20:37.500
在服务端那边已经处理好了

20:37.500 --> 20:38.340
不仅处理好了

20:38.340 --> 20:38.980
它的处理方式

20:38.980 --> 20:41.380
那就不是传统的那种ssr的方式

20:41.380 --> 20:43.620
而是先就把数据加到页面里面

20:43.620 --> 20:44.860
给你形成静态一面

20:44.880 --> 20:46.280
你直接拿静态一面就行了

20:46.280 --> 20:47.920
这就是我们里面最开始学的那个

20:47.920 --> 20:49.160
atm和ssr

20:49.160 --> 20:50.560
相当于是服务端

20:50.560 --> 20:51.760
它一个智能机器人啊

20:51.760 --> 20:53.160
给你写好了一个静态一面

20:53.160 --> 20:54.720
你直接访问那个静态一面就完了

20:54.720 --> 20:55.720
效率非常非常高

20:55.720 --> 20:56.640
高度下人

20:56.640 --> 20:58.400
你看这个页面在码里面

20:58.400 --> 20:59.160
数据全中有

20:59.160 --> 20:59.840
对吧

20:59.840 --> 21:00.600
ok

21:00.600 --> 21:01.880
接式还是要打开啊

21:01.880 --> 21:03.520
毕竟要接管后期线上

21:03.520 --> 21:04.160
那么现在呢

21:04.160 --> 21:05.760
只是看到一个一个的单独的页面

21:05.760 --> 21:07.120
没有接管后期线上的

21:07.120 --> 21:07.920
啊

21:07.920 --> 21:10.240
那么其实你看看看上去还是没问题的

21:10.240 --> 21:11.200
那为什么还能还原呢

21:11.200 --> 21:12.160
因为它刷新了

21:12.160 --> 21:12.960
接式不存在了

21:12.960 --> 21:13.520
所以说

21:15.600 --> 21:16.960
它每次都刷新啊

21:16.960 --> 21:18.000
哪怕你接式全部进用

21:18.000 --> 21:19.120
它也是可以显示的

21:19.120 --> 21:20.800
至少一开始显示没问题

21:20.800 --> 21:22.160
那如果说你后面有时间的话

21:22.160 --> 21:22.720
就处理不了

21:23.800 --> 21:24.600
ok

21:24.600 --> 21:25.800
好那么这里是关于这个

21:27.880 --> 21:31.200
这个就是ssg的第一个部分啊

21:31.200 --> 21:32.360
我们解决了这个问题

21:32.360 --> 21:33.240
那么下一回下一回

21:33.240 --> 21:34.760
我们来解决另外一个问题啊

