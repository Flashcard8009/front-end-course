WEBVTT

00:00.000 --> 00:09.840
ok 我们这节课的话来看一下这个req中 它的这个性能优化相关的这个策略啊 这节课咱们主要看这个eager state

00:10.640 --> 00:16.560
啊 这边的话这道面试题啊 它让你谈一谈req中这个eager state 它的策略是什么

00:17.200 --> 00:20.240
ok 好来 我们这节课来给大家介绍一下啊

00:20.880 --> 00:29.120
好 req 的话 它作为一款这种重运行使的这种框架 它内部的话是有很多这个性能优化相关的这个api的

00:29.600 --> 00:34.720
这个我们在之前的话是不是也介绍过 对不对啊 在这个req中

00:35.680 --> 00:39.600
有很多和这个性能优化

00:40.560 --> 00:49.520
相关的api啊 比如说有点些呢 这边我直接拿过来 我们之前学过什么 这边有这个shooter component update

00:50.480 --> 00:53.120
对吧 还有这个pure component

00:53.760 --> 00:58.080
然后req 点memo use memo 以及这个use callback

00:58.880 --> 01:04.560
啊 这些这个性能优化的这种 api 可以让我们这个开发者啊 在这个数学代码的时候

01:05.120 --> 01:12.000
手动的考虑 哪些地方可以就是进行这个性能优化啊 然后接下来使用这些对应的这个 api

01:13.280 --> 01:20.480
好 那为什么会出现这些 api 实际上它的本质是因为就是咱们的req 它是一款应用性的这个框架

01:20.960 --> 01:23.440
它不像这个view 或者这个swilt

01:24.160 --> 01:30.800
像view和swilt 它实际上它可以在编译的时候 它做出一些这个优化 但是这个req 它不行

01:31.280 --> 01:38.080
这部分工作它呢 必须交给这个开发者来完成啊 好 那这个开发者调用这些

01:38.880 --> 01:44.800
api 实际上的话 它内部是在干嘛呢 内部的话实际上就在命中req 内部的这个

01:45.520 --> 01:58.640
性能优化策略 okay 实际上实际上开发者调用上面的这个 api

02:00.560 --> 02:09.520
内部是在干嘛 内部是在命中这个req 然后的这个性能优化策略

02:13.980 --> 02:20.060
明白吧啊 你无论是调哪个 api 其实最终目的是为了什么呢 是为了命中它内部的这个性能优化策略

02:20.940 --> 02:26.700
这个req 内部的这个性能优化策略有点些呢 它在它的内部的话有两大策略

02:27.100 --> 02:30.220
一个就是我们这几颗要介绍的这个eager state

02:31.500 --> 02:33.900
另外一个什么呢 另外一个是我们下几颗要介绍的

02:34.620 --> 02:42.060
build out 啊 这两个策略 okay 好 那我们这边我们来看个例子啊 比如说我们这边的话有这么一个代码

02:44.370 --> 02:47.410
好 我这边直接把这个例子啊 我直接把他拿过来

02:49.580 --> 02:58.180
我们在这个代码里面把他跑一下啊 okay 保存 保存啊 这边要渲染一下 我们这边

02:59.380 --> 03:08.260
把这儿 okay 好 这边我们来看一下 这边的话有两个逐渐 首先的话这个的话是副逐渐

03:10.500 --> 03:13.060
这个是副逐渐 这个是值逐渐

03:14.900 --> 03:23.870
ok 好 然后在这个副逐渐里面 副逐渐里面的话 这边维护了一个状态啊 这边一开始的话这个初始只是0

03:24.430 --> 03:33.150
好 然后下这边第一次这个就每次啊 每次这个副逐渐渲染的时候 这边会打印句话啊 这边就是app render 大家这边会打印出这个

03:34.190 --> 03:42.270
nam啊 好 然后接下来这边这个试图 试图里面的话 这边渲染出了这个值逐渐啊 值逐渐很简单啊 值逐渐这边就是

03:43.070 --> 03:49.230
反回一个span 然后同样值逐渐每次渲染的时候 我们这边会打印一个啊 敲到 render

03:49.950 --> 03:59.790
也就是我们这边第五行和第十二行 主要就是看这个副逐渐和值逐渐 他们渲染了多少次啊 好 然后接下来这边这个副逐渐

04:00.190 --> 04:04.110
点击的时候 我们会把什么呢 我们会把这个纳姆更新为这个一

04:05.070 --> 04:09.150
更新为一啊 就固定的更新为一 ok 好 我们这边保存一下

04:09.790 --> 04:12.430
保存了之后 然后这样我们这边在榴栏期这边来看一下

04:15.660 --> 04:18.620
好 我说的啊 我们到这边来看一下

04:19.580 --> 04:20.780
好 这边控制台

04:21.740 --> 04:25.420
东西刷新 你看第一次 第一次的话 app render 零

04:25.980 --> 04:31.500
然后敲的 render 啊 这个什么没问题啊 对了 一开始的话这个副逐渐啊 渲染

04:31.900 --> 04:35.180
然后这个值逐渐也渲染 然后我们这边对应着这个代码来看

04:36.860 --> 04:39.340
对应着这个代码 我把这个代码截个图

04:40.460 --> 04:44.540
稍等啊 我就代码截个图 我们对应着来看

04:48.110 --> 04:50.110
好 然后回到这边

04:51.070 --> 04:56.510
ok 好 第一次第一次的话 你看这边这个副主件这边 app render 然后一开始那么是零

04:56.590 --> 04:59.470
所以这边打印出零 对不对 好 然后接下来的话这边

05:00.510 --> 05:05.470
呃 敲的敲的话 这边敲的 render 没问题 好 然后接下来的话 我们这边点击一下

05:07.150 --> 05:09.790
点击一下之后 让这个 app render 一

05:10.510 --> 05:12.350
因为你这边的话把这个更新成一了

05:13.070 --> 05:17.310
对不对 更新成一之后让 app render 啊 这边是一 然后这个敲的

05:17.710 --> 05:19.630
因为你这边副主件重新渲染了

05:20.110 --> 05:23.150
副主件重新渲染了 然后就在这边直主件 是不是也重新渲染

05:23.550 --> 05:28.430
对不对 好 然后接下来 我再点击 我再点击的话 这边是不是仍然是一

05:29.870 --> 05:33.070
对不对 仍然是一 好 那我们来看一下 接下来会怎么样

05:34.270 --> 05:40.190
接下来 走 你会发现这一次的话 就只有 app 就是只有副主件

05:40.750 --> 05:41.550
重新渲染了

05:42.430 --> 05:48.990
哎 只有副主件 可不可以啊 根据这的答应 只有副主件重新渲染了 直主件的话 他就没有再重新渲染了

05:50.190 --> 05:55.790
可能 这个的话 实际上他就已经命中了react 内部的这个优化策略了

05:56.670 --> 05:58.430
命中了什么优化策略 我们一会再来说

05:59.710 --> 06:04.430
这一次的话 这个直主件就没有渲染了 而但是这个副主件他还是渲染了一次

06:05.150 --> 06:09.630
对不对 你看明明这边这个数字是多少 这个是一 这个也是一 两个都是一

06:09.950 --> 06:14.670
但是副主件还重新渲染了一次 好 然后接下来我们这边再继续 走

06:15.150 --> 06:18.110
我现在点击了 点击了 点击了很多次了

06:18.590 --> 06:22.030
你会发现 现在的话 是不是连副主件也不重新渲染了

06:22.830 --> 06:30.350
对不对啊 副主件也不重新渲染了 ok 好 那我们这边就把这个例子 我拿到我们的这个放到我们的笔记里面

06:35.410 --> 06:43.250
好 我们把这个这个例子放过来 放过来之后 然后接下来 我们这边来记录一下啊 在上面的这个代码中

06:44.930 --> 06:48.290
代码中啊 渲染结果如下

06:49.090 --> 06:50.210
好 第一次

06:51.170 --> 06:55.810
首次渲染 首次渲染这边是渲染出什么

06:56.770 --> 07:00.210
我看一下 首次渲染是不是这个 这两个

07:02.210 --> 07:05.410
对不对 首次渲染是渲染出这两个

07:06.290 --> 07:11.970
呃 app render 零 然后敲的 render 好 然后接下来的话第一次点击

07:15.700 --> 07:20.820
第一次点击 好 第一次点击之后 然后接下来这边变成什么

07:21.700 --> 07:27.220
这边呢 是不是变成一对不对 然后敲的 render 好 然后接下来的话第二次点击

07:30.560 --> 07:36.800
第二次点击 好第二次点击的话 然后接下来是什么 接下来是不是就这次就只有副主件重新渲染

07:37.280 --> 07:40.480
对不对 app render 1 好 然后接下来第三次

07:42.000 --> 07:47.440
第三次以及之后的这个点击啊 不会

07:48.400 --> 07:53.920
有这个答应 对不对 也就是说副主件和指主件都没重新学的

07:55.040 --> 07:59.760
啊 那么上面这个例子的话 实际上就涉及到了 我们这边要介绍的这两种

08:00.320 --> 08:01.520
性能优化策略

08:01.520 --> 08:02.000
ok

08:04.080 --> 08:09.200
上面的这个例子 实际上就涉及到了

08:09.680 --> 08:13.600
啊 就是我们所提到的

08:15.600 --> 08:19.040
内部的两种性能优化策略

08:21.790 --> 08:24.110
那两种呢 一种是这个eager state

08:24.670 --> 08:29.230
对啊 然后一种是这个bill out 首先在第二次答应的时候

08:30.590 --> 08:34.270
在第二次答应的时候

08:34.670 --> 08:39.310
你看第二次答应的时候 是不是只答应了这个副主件 是不是只主件

08:39.870 --> 08:45.790
就是这个敲的这个就是这个指主件啊 敲的这个主件 是不是他没有答应

08:45.950 --> 08:49.710
没有答应说明他没有确认的吗 对不对 在第二次答应的时候

08:50.190 --> 08:54.350
并没有答应这个敲的 render

08:56.270 --> 09:03.470
此时实际上实际上是命中了什么的命中了这个bill out

09:04.910 --> 09:09.070
这个策略好命中这个该策略的这个主件

09:10.270 --> 09:15.310
命中该策略的主件的这个指主件

09:16.990 --> 09:18.510
他会干嘛呢 会跳过

09:19.790 --> 09:21.790
会跳过这个reconcile

09:23.820 --> 09:27.340
会跳过这个啊 会跳过这个过程 也就是说

09:28.220 --> 09:30.700
也就是说这个指主件

09:31.580 --> 09:37.660
指主件不会进入这个 render

09:38.460 --> 09:38.940
接着

09:39.980 --> 09:43.420
怎么样 这是这个bill out策略啊 我们下节课会介绍

09:43.980 --> 09:47.500
好 然后接下来 嗯 之后的第三次

09:48.700 --> 09:52.060
啊 以及之后的这个点击

09:53.420 --> 09:59.740
这边就改成后面吧 后面的第三次啊 以及之后的点击是没有任何输出

10:00.700 --> 10:05.580
没有任何输出 说明什么 说明这个app

10:06.140 --> 10:12.940
这个你的副主件 以及你的这个跳的指主件 是不是都没有进入这个 render阶段

10:14.860 --> 10:22.860
对了 都没虚然 此时命中的就是什么呢 命中的就是我们一会儿要介绍的这个e-curve state

10:24.700 --> 10:25.900
啊 命中了这个策略

10:27.340 --> 10:31.180
好 这个呢 它是一种发生在这个状态更新

10:31.740 --> 10:34.300
就是更新时的一种优化策略

10:35.740 --> 10:46.160
这是一种发生于触发状态更新时的这个优化策略

10:48.080 --> 10:56.320
好 如果命中了该策略啊 如果命中了该策略啊 然后此次更新

10:58.000 --> 11:02.080
不会进入这个scaler

11:02.800 --> 11:10.400
scaler阶段更不会进入什么呢 更不会进入render阶段

11:12.080 --> 11:14.960
看不看 这是它的这个e-curve state

11:15.360 --> 11:20.560
你如果命中了这种策略的话 它这个 我们说了这边就是你前面是不是会先有一个这个调度

11:21.440 --> 11:27.520
对不对 它不会进入到这个调度阶段scaler 不会进入 然后后面的话也没有怎么 render 之类的

11:27.840 --> 11:32.960
啊 当然scaler本身就是属于这个render其中的一个部分对吧

11:33.680 --> 11:40.320
ok 好 然后接下来我们这边我们就来看一下啊 这些课我们就来看一下这个e-curve state

11:41.120 --> 11:49.940
策略啊 这个e-curve state这个策略 它实际上它的这个逻辑是很简单的

11:50.500 --> 11:56.660
啊 该策略 该策略的逻辑啊 其实是很简单的

11:57.620 --> 12:02.740
它是干嘛呢 就是如果某个状态更新前后

12:04.180 --> 12:05.300
没有变化

12:06.500 --> 12:14.660
那么就可以什么呢 可以跳过这个后续的后续的更新流程

12:16.180 --> 12:23.300
ok 好 我们知道就是这个state 它是基于什么 是不是基于这个update计算出来的啊 这个我们之前讲过

12:23.780 --> 12:28.500
对不对 那你这个计算过程发生在这个render 阶段的这个begin work

12:29.460 --> 12:35.460
那这个e-curve state的话 它是把这个计算过程直接提前到了这个scaddle 阶段之前

12:36.180 --> 12:40.900
啊 比你的这个render 之前还要还要找啊 state

12:41.940 --> 12:44.500
是这个基于什么呢 基于这个update

12:45.220 --> 12:49.780
计算出来的 这个我们之前讲过对不对 好 然后这个计算过程

12:52.020 --> 12:58.100
计算过程发生在什么呢 发生在render 的这个begin work

13:00.020 --> 13:07.460
啊 而这个e-curve state 折射将这个计算过程

13:08.420 --> 13:12.260
计算过程提前到了这个scaddle

13:13.700 --> 13:14.980
scaddle之前

13:15.300 --> 13:19.300
scaddle之前实行

13:19.860 --> 13:22.740
ok 因为我们刚刚说了这个 它压根就不会进入这个scaddle

13:23.220 --> 13:29.060
对不对 所以它比这个scaddle还早啊 那就比你的那个那个scaddle过了之后那个是什么

13:29.540 --> 13:35.540
它两个整reconciler 对吧 比你的这个reconciler 那个阶段还要早

13:36.180 --> 13:37.140
对不对 ok

13:38.020 --> 13:43.220
好 但是你这边的话你注意 就这个策略的话它有一个前这个前提

13:43.700 --> 13:49.300
什么前提呢 就你当前的这个fiberload 它不存在这个代值型的这个更新

13:50.100 --> 13:55.940
为什么呢 因为你如果不存在这个代值型的这个更新的话 那你当前的这个更新就是第一个更新

13:56.580 --> 13:59.220
那即便你的这个计算出来的这个state

13:59.780 --> 14:06.820
啊 它这个有变化 那它也可以作为什么 是不是也可以作为后续update的一个这个基础state来使用

14:07.620 --> 14:09.460
对吧 啊 该策略

14:09.940 --> 14:13.540
该策略有一个前提条件

14:14.820 --> 14:19.620
怎么呢 那就是当前的这个fiberload

14:20.340 --> 14:27.090
当前的fiberload不存在这个代值型的

14:28.370 --> 14:34.800
代值型代值型的这个更新

14:36.080 --> 14:39.920
啊 因为我们说过这个update它可能会存在一些这个代值型的一些更新

14:40.880 --> 14:45.840
对不对啊 那现在的话这边的话 它这个前提条件就是你当前的这个fiberload

14:46.080 --> 14:48.480
没有就是需要这个执行的这种update

14:48.880 --> 14:50.800
没有需要执行的这种更新

14:51.440 --> 14:55.280
啊 因为为什么呢啊 因为如果不存在

14:56.560 --> 15:00.400
不存在这个代值型的这个更新

15:00.640 --> 15:05.520
那么当前的更新就是什么 就是第一个更新

15:06.240 --> 15:12.640
啊 这个逻辑好理解吧 对吧 没有没有这个代值型的更新

15:12.640 --> 15:17.760
那我当前更新肯定就是这个作为整个这个update的这个第一个更新

15:17.760 --> 15:24.160
对不对啊 那么计算出来的 那么计算出来的这个state

15:24.160 --> 15:26.720
即便你有变化

15:26.720 --> 15:30.560
啊 你没有变化的话就命中这个一个state了

15:30.560 --> 15:35.040
这就直接复用了对吧 啊 只即便有变化也没关系

15:35.040 --> 15:39.600
那也可以什么呢 也可以作为这个后续

15:40.320 --> 15:42.640
后续更新的这个基础

15:43.600 --> 15:45.920
基础state来使用

15:48.060 --> 15:51.020
没有吧啊 所以它就有这么一个前提条件啊

15:51.580 --> 15:56.220
好 那我们这边我们来看个例子啊 例如在这个使用

15:57.260 --> 16:00.940
UserState触发更新的时候

16:05.040 --> 16:09.120
触发更新的时候啊 然后对应的这个dispatch

16:10.080 --> 16:11.680
dispatch setState

16:13.200 --> 16:19.090
然后逻辑入下 好把这块代码把它拿过来

16:25.790 --> 16:27.550
好 这里呢 大家可以看一下

16:29.310 --> 16:32.190
啊 大家可以看这里 这里的话这边

16:32.750 --> 16:37.310
这边的话是不是就在计算一个state对不对啊 基于这个action

16:37.310 --> 16:41.070
提前计算这个state 计算了之后 然后接下来这边

16:41.070 --> 16:45.710
当前的这个update 我们之前是不是讲过那个update它的一个数据结构

16:46.270 --> 16:51.550
对吧 好 然后当前的这个update 大家这边的话标记啊 这边还是一个state

16:51.550 --> 16:56.910
为q 然后update点一个state啊 这边等于你计算出来的一个state

16:56.910 --> 17:00.990
好 然后接下来这里 这里的话实际上就是在进行这个判断了

17:00.990 --> 17:05.550
啊 如果为q代表什么呢 代表就是你的这个state没有变化

17:05.550 --> 17:08.750
啊没有变化的话 它就命中了这个一个state策略

17:08.750 --> 17:13.150
它就不会再进入这个scheduler这个schedule阶段了

17:13.230 --> 17:19.630
ok 在上面的代码中 在上面的代码中首先

17:21.390 --> 17:32.590
通过什么呢 通过这个方法对吧 通过这个方法来提前计算这个state

17:33.470 --> 17:41.150
计算完成后 计算完成后 然后在当前的这个update上面

17:41.230 --> 17:49.150
然后进行标记 这里所说的标记就是把这个has一个state设置为q

17:49.150 --> 17:55.310
啊 然后顺便把这个一个state存出什么呢 存出你这个计算出来的这个值啊

17:55.310 --> 17:59.710
好 然后之后 之后使用什么呢 使用这个

18:00.830 --> 18:02.590
意识啊 意识这个方法

18:04.510 --> 18:09.870
使用这个啊 然后判断什么呢 判断前后状态

18:09.950 --> 18:16.110
就更新后的状态吗 更新后的这个状态是否有变化

18:18.190 --> 18:20.190
如果进入eve

18:21.310 --> 18:27.310
进入eve 说明什么 说明更新前后 更新前后

18:29.310 --> 18:31.950
前后的这个状态没有变化

18:33.150 --> 18:37.710
啊那么此时就会什么呢 就会命中这个一个

18:37.950 --> 18:39.950
一个state

18:41.630 --> 18:46.590
一个state策略 对不对 这个时候就会命中这个策略啊

18:46.590 --> 18:50.670
那不会进入 不会进入scale

18:51.310 --> 18:53.630
接着啊 连调度都不会调度

18:54.430 --> 18:56.510
ok好 即使不委屈

18:57.870 --> 18:59.790
即便不委屈

19:01.070 --> 19:03.950
不委屈的话呢 没办法复用 对吧 不会进入这个

19:04.510 --> 19:07.390
就是没有命中这个一个state 但是也不亏

19:08.190 --> 19:13.550
是不是也不亏 为什么呢啊 因为你这边的话 我们说了他有个前提条件

19:13.950 --> 19:16.510
就他这个不存在这个带执行的更新

19:17.230 --> 19:21.470
那么不存在带执行的更新的话 那你这边的话 计算出来的就是什么

19:21.470 --> 19:26.750
所以计算出来的就是作为后续更新的这个第一个这个更新状态

19:27.230 --> 19:29.310
对不对 说即便不委屈

19:30.030 --> 19:31.870
由于

19:32.030 --> 19:40.030
这个前的更新是什么呢 是该这个fiber load的这个第一个

19:41.230 --> 19:43.870
更新啊 第一个更新

19:44.510 --> 19:49.950
因此可以作为什么 是不可以作为这个后续

19:51.230 --> 19:53.230
更新的这个基础

19:54.030 --> 19:56.030
基础state

19:56.430 --> 19:58.590
对不对 可以作为这个基础state

19:59.070 --> 20:04.350
所以这就是为什么在这个fc这个update的这个数据里面

20:04.350 --> 20:08.910
它有这个hasEagerState以及这个eagerState制断了这个原因啊

20:10.110 --> 20:13.870
因此这就是为什么在fc

20:14.990 --> 20:18.750
fc就方形component 函数组件 在fc

20:19.870 --> 20:21.790
组件类型

20:21.790 --> 20:24.430
组件类型的这个update

20:25.390 --> 20:31.070
里面啊 有什么呢 有这个hasEagerState

20:33.070 --> 20:40.270
以及这个eagerState啊 制断的这个原因

20:41.230 --> 20:45.790
还记得吧 我们之前讲那个update的时候啊 这个你如果是这个

20:46.510 --> 20:50.110
这个函数组件 它的那个对应的那个update

20:50.110 --> 20:51.710
它这边是有这两个制断的

20:52.430 --> 20:53.790
对不对 HasEagerState

20:53.790 --> 20:57.630
forced 这边EagerState 默认是这个nau

20:57.630 --> 20:59.230
它这两个制断拿来干嘛的

20:59.230 --> 21:03.390
它这边呢 就是在做这个eagerState这个优化策略的时候

21:04.110 --> 21:05.550
它这边是会用到的

21:06.110 --> 21:06.430
OK

21:07.470 --> 21:10.990
好 这是关于这个eagerState 它这边这个内部

21:12.030 --> 21:13.710
好 然后接下来这边还有个问题

21:14.430 --> 21:19.550
什么问题呢 就是在上面的这个代码里面啊 就是这 这啊

21:20.270 --> 21:23.230
就这个啊 这里 在这里的代码的话

21:23.230 --> 21:25.710
然后有一个比较奇怪的就是第二次点击

21:27.150 --> 21:29.150
第二次点击 第二次点击的话

21:29.150 --> 21:31.950
实际上你看第一次点击的时候 是不是已经把这个nam

21:31.950 --> 21:34.830
是不是已经更新成一了 对不对

21:34.830 --> 21:36.190
它已经更新成一了

21:36.910 --> 21:38.110
已经更新成一的话

21:38.110 --> 21:40.270
那照理说第二次点击的话

21:40.270 --> 21:42.190
这边就不应该在干嘛呀

21:42.190 --> 21:44.030
这不应该在打印了 对不对

21:44.030 --> 21:46.030
你这个副主件也没有必要再更新了呀

21:46.030 --> 21:48.110
为什么这个副主件还会再更新一次呢

21:48.270 --> 21:49.790
然后之后的话就不会有任何打印了

21:50.430 --> 21:52.030
之后副主件就不会再更新了

21:52.030 --> 21:53.950
而且是不会再重新渲染了

21:53.950 --> 21:54.990
但是你第二次的话

21:54.990 --> 21:57.550
你这个副主件还要重新渲染一次啊

21:57.550 --> 21:58.510
这个比较奇怪

22:00.930 --> 22:01.250
在

22:03.650 --> 22:05.490
上面的这个实例中

22:06.530 --> 22:07.410
比较奇怪的

22:08.210 --> 22:10.930
比较奇怪的是什么呢

22:10.930 --> 22:12.050
是这个第二次

22:13.170 --> 22:14.850
第二次点击

22:15.810 --> 22:17.730
在这个第二次

22:18.690 --> 22:20.610
点击之前

22:20.610 --> 22:23.250
nam已经为多少

22:23.250 --> 22:24.370
已经为一了

22:24.370 --> 22:25.570
但是什么呢

22:25.570 --> 22:26.930
但是这个副主件

22:27.970 --> 22:31.570
仍然是重新渲染了一次

22:33.330 --> 22:33.890
对不对

22:33.890 --> 22:35.170
仍然重新渲染一次

22:35.170 --> 22:36.610
那么为什么这种情况

22:37.250 --> 22:39.330
它没有命中这个一个state策略呢

22:40.370 --> 22:42.370
为什么这种情况

22:43.650 --> 22:47.250
没有命中一个state策略

22:48.450 --> 22:49.570
我们知道后面的话

22:49.570 --> 22:51.250
它就是命中了一个state

22:51.250 --> 22:51.570
对不对

22:51.570 --> 22:53.570
你第三次以及之后的这个点击

22:53.570 --> 22:55.170
它没有任何的打印

22:55.170 --> 22:56.930
它这边就是命中了这个

22:56.930 --> 22:57.970
一个state策略

22:57.970 --> 22:59.170
但关键是这边第二次

22:59.730 --> 23:01.170
第二次的话为什么没有命中

23:01.170 --> 23:03.010
第二次我们说第二次命中的是什么

23:03.010 --> 23:05.170
第二次命中的是bailout

23:05.170 --> 23:05.570
对吧

23:05.570 --> 23:06.930
命中的是这个策略

23:06.930 --> 23:07.890
好那为什么呢

23:08.530 --> 23:09.490
ok是这样子的

23:11.250 --> 23:13.170
就我们知道这个fiber load

23:13.170 --> 23:14.050
它分成什么

23:14.130 --> 23:17.090
这分成current和这个wip两种

23:17.810 --> 23:18.210
对不对

23:18.210 --> 23:20.850
这种之前讲那个双方冲的时候就讲过

23:20.850 --> 23:22.930
fiber load分为什么呢

23:22.930 --> 23:28.770
分为current和这个wip两种

23:28.770 --> 23:29.490
ok

23:29.490 --> 23:30.290
好那这边的话

23:30.290 --> 23:31.730
它这个在上面的判断中

23:32.610 --> 23:35.490
在上面的这个判断中

23:36.370 --> 23:37.010
实际上

23:37.890 --> 23:39.170
实际上会

23:40.530 --> 23:41.730
就是上面判断你看这边

23:41.730 --> 23:42.770
这边有个什么

23:42.770 --> 23:43.730
这边是不是有个这个

23:46.210 --> 23:46.530
对不对

23:47.250 --> 23:48.370
我们把这个先粘过来

23:50.210 --> 23:52.130
这边里面括号里面的这个

23:52.130 --> 23:53.090
我们就省略了

23:53.810 --> 23:55.090
在上面的判断中

23:55.090 --> 23:56.610
实际上会对什么呢

23:56.610 --> 23:57.890
实际上会对

23:58.450 --> 24:00.050
这个current

24:01.650 --> 24:03.730
current和这个wip

24:04.370 --> 24:07.090
都进行判断

24:07.890 --> 24:08.690
判断他们什么呢

24:08.690 --> 24:09.490
判断的条件

24:10.530 --> 24:12.850
判断的条件为

24:13.730 --> 24:14.370
这两个

24:15.090 --> 24:16.770
这两个fiber load

24:17.730 --> 24:18.450
他们的什么呢

24:18.450 --> 24:19.490
他们的这个nance

24:20.770 --> 24:23.490
nance必须要为什么呢

24:23.490 --> 24:25.250
要为这个no nance

24:27.470 --> 24:28.030
看到没有

24:28.030 --> 24:29.070
你看这边

24:29.070 --> 24:31.310
fiber点nance

24:31.310 --> 24:31.870
等于什么呢

24:31.870 --> 24:32.830
等于no nance

24:33.390 --> 24:35.310
对这个就是你当前的fiber嘛

24:35.310 --> 24:36.910
好 and and alternate

24:37.630 --> 24:38.190
alternate

24:38.190 --> 24:38.910
然后去下这边

24:38.910 --> 24:40.270
等于空或者什么呢

24:40.270 --> 24:41.630
或者这个alternate

24:41.630 --> 24:42.670
等于no nance

24:42.670 --> 24:43.550
那这个alternate

24:43.710 --> 24:45.150
是不是就是你的这个web

24:45.870 --> 24:46.350
对不对

24:46.350 --> 24:47.070
反正他们两个

24:47.070 --> 24:48.430
就是一个是当前的

24:48.430 --> 24:50.190
一个是指向另外一个嘛

24:50.190 --> 24:50.670
对不对

24:50.670 --> 24:51.230
所以这边呢

24:51.230 --> 24:53.150
必须两个都为这个no nance

24:53.710 --> 24:55.310
那么对于这个第一次更新

24:57.790 --> 24:59.550
对于第一次更新

25:00.190 --> 25:00.830
当你这个

25:01.390 --> 25:03.630
当begin work

25:04.510 --> 25:05.070
开始前

25:06.110 --> 25:09.470
你的这个currentness和这个webness

25:09.470 --> 25:10.110
一开始是吧

25:10.110 --> 25:11.550
都不是no nance

25:12.350 --> 25:12.750
对吧

25:13.310 --> 25:13.950
current

25:14.910 --> 25:16.110
点nance

25:16.910 --> 25:17.470
和什么呢

25:17.470 --> 25:18.590
和这个web

25:20.030 --> 25:21.550
web点nance

25:22.350 --> 25:23.230
他们都不是

25:24.670 --> 25:26.190
都不是这个no

25:27.070 --> 25:27.390
nance

25:28.030 --> 25:28.430
第一次

25:28.990 --> 25:29.230
好

25:29.230 --> 25:29.790
然后接下来

25:29.790 --> 25:31.550
当你的这个begin work

25:31.550 --> 25:32.190
执行后

25:34.480 --> 25:36.000
当begin work

25:36.720 --> 25:37.840
执行后

25:37.840 --> 25:39.760
那么你这个webness

25:39.760 --> 25:41.360
它会被重置为什么呢

25:41.360 --> 25:44.000
它会被重置为这个no nance

25:44.000 --> 25:44.400
但是呢

25:44.400 --> 25:46.320
你这个current点nance

25:46.320 --> 25:47.120
它的话

25:47.120 --> 25:47.760
还不是

25:48.400 --> 25:48.720
ok

25:49.680 --> 25:50.960
当begin work执行后

25:50.960 --> 25:51.600
你的web

25:52.320 --> 25:53.440
web点nance

25:53.440 --> 25:54.160
web点nance

25:54.160 --> 25:54.640
web的话

25:54.640 --> 25:56.800
就是那个内存里面的那个verge点

25:57.600 --> 25:58.160
你记住吗

25:58.160 --> 25:59.200
就我们之前讲那个

25:59.680 --> 26:01.040
双缓冲的时候

26:01.040 --> 26:02.480
web不是内存里面的那个

26:02.480 --> 26:03.120
current的话

26:03.120 --> 26:03.920
你可以把它

26:03.920 --> 26:06.080
想象成这个前缓冲区

26:06.080 --> 26:07.840
我们当时以那个显卡

26:08.320 --> 26:08.720
是吧

26:08.720 --> 26:10.080
以显卡举的例子

26:10.080 --> 26:11.120
一个是前缓冲区

26:11.120 --> 26:12.480
一个是后缓冲区

26:12.480 --> 26:13.120
ok

26:13.200 --> 26:13.680
web的话

26:13.680 --> 26:14.480
就是后缓冲区

26:15.440 --> 26:15.680
好

26:15.680 --> 26:16.880
这边这个web点nance

26:17.760 --> 26:18.480
它会干嘛呢

26:18.480 --> 26:20.480
它会被重置为这个no nance

26:22.980 --> 26:27.380
它会被重置为no nance

26:28.820 --> 26:29.540
但是

26:29.540 --> 26:30.260
这个current

26:31.380 --> 26:32.740
current nance

26:33.300 --> 26:33.780
并不会

26:37.280 --> 26:37.840
并不会

26:39.120 --> 26:39.840
ok

26:39.840 --> 26:40.080
好

26:40.080 --> 26:41.440
那它们两个要在什么呢

26:41.440 --> 26:44.560
它们两个要在这个commit阶段完成后

26:44.560 --> 26:46.640
才会进行这个互换

26:46.640 --> 26:47.840
这个我们之前在讲那个

26:47.840 --> 26:48.560
commit的时候

26:48.560 --> 26:50.000
我们是不是也说过

26:50.000 --> 26:50.880
对不对

26:50.880 --> 26:53.680
这个current和这个web

26:54.640 --> 26:55.360
会在什么呢

26:55.360 --> 26:58.640
会在这个commit这个阶段

26:59.840 --> 27:00.560
这个之后

27:01.600 --> 27:03.440
才进行互换

27:04.640 --> 27:05.440
对吧

27:05.440 --> 27:10.080
这就是为什么第二次没有命中

27:11.280 --> 27:14.080
没有命中这个1根

27:14.800 --> 27:15.680
state

27:16.640 --> 27:18.240
的这个原因

27:19.360 --> 27:20.240
看了没有

27:20.240 --> 27:20.800
它有一个

27:20.800 --> 27:22.240
因为它有两个fiber node

27:23.040 --> 27:24.960
一个的话重置为这个no nance了

27:24.960 --> 27:26.080
但是另外一个没有

27:26.800 --> 27:27.600
没有的话说

27:27.600 --> 27:29.600
但是你这边判断条件又是什么

27:29.600 --> 27:31.120
判断条件是不是又是

27:31.120 --> 27:32.400
两个必须都是no nance

27:33.040 --> 27:33.680
所以这边的话

27:33.680 --> 27:34.240
它第二次的话

27:34.240 --> 27:35.920
它没有命中这个1根state

27:36.800 --> 27:37.520
ok

27:37.520 --> 27:40.480
那为什么后面的又命中了呢

27:40.480 --> 27:41.120
对吧

27:41.120 --> 27:41.760
那么

27:42.480 --> 27:46.720
为什么后面的点击又命中了呢

27:49.410 --> 27:49.730
对吧

27:49.730 --> 27:51.330
你要不命中就都不命中

27:51.330 --> 27:52.610
那你就一直都不命中

27:52.610 --> 27:53.170
对不对

27:53.170 --> 27:53.810
为什么呢

27:53.810 --> 27:55.090
原因很简单

27:55.090 --> 27:56.050
因为你这边的话

27:56.050 --> 27:56.530
你后面

27:57.410 --> 27:57.890
首先的话

27:57.890 --> 28:00.050
你这边就是上一次点击

28:00.050 --> 28:03.010
你没有命中这个1根state策略

28:03.010 --> 28:03.570
但是呢

28:03.570 --> 28:04.530
它命中了什么呢

28:04.530 --> 28:07.410
它命中了这个bio out策略

28:08.610 --> 28:11.410
虽然上一次点击

28:12.370 --> 28:15.730
没有命中这个1根state

28:16.850 --> 28:19.330
1根state策略

28:19.330 --> 28:21.250
但是命中了

28:22.290 --> 28:23.090
命中了什么呢

28:23.090 --> 28:24.450
命中了这个bio out

28:25.730 --> 28:26.690
bio out策略

28:28.290 --> 28:29.010
ok

28:29.010 --> 28:33.090
那么对于这个命中了这个bio out策略的这个fc

28:33.090 --> 28:34.130
它会执行什么呢

28:34.130 --> 28:36.930
它会执行这个bio out hooks方法

28:38.450 --> 28:41.330
对于命中了bio out

28:41.490 --> 28:42.850
我们下节可来讲

28:44.050 --> 28:47.730
对于命中了这个bio out策略的这个fc

28:48.290 --> 28:49.570
它会执行什么呢

28:49.570 --> 28:51.490
会执行这个bio out

28:52.610 --> 28:53.810
然后 hooks方法

28:55.250 --> 28:55.810
ok

28:55.810 --> 28:58.610
好来我们来看一下这个方法的这个代码评断

28:58.610 --> 28:59.410
把他拿过来

29:04.320 --> 29:05.040
好在这里

29:05.600 --> 29:06.240
ok

29:06.240 --> 29:07.600
你注意看最后一句

29:08.080 --> 29:09.120
看最后一句

29:09.120 --> 29:12.000
他这边在执行这个bio out hooks的时候

29:12.000 --> 29:14.240
他这边是不是有一个remove length

29:14.960 --> 29:17.120
大家把这个当前的current点length

29:17.120 --> 29:18.400
把他传进去

29:18.400 --> 29:19.200
对不对

29:19.200 --> 29:20.160
在执行

29:22.540 --> 29:30.350
在执行这个bio out hooks方法的时候

29:31.470 --> 29:32.590
然后最后一句

29:34.270 --> 29:35.230
会将什么呢

29:35.230 --> 29:38.110
会将当前这个fiber load的

29:38.670 --> 29:39.310
得什么呢

29:39.310 --> 29:40.350
得这个length

29:40.910 --> 29:41.550
是不是一出

29:42.990 --> 29:43.710
对不对

29:43.710 --> 29:44.110
一出

29:44.830 --> 29:47.630
所以你这边就是第二次点击之后

29:47.630 --> 29:48.910
那你整个这个

29:48.910 --> 29:50.910
这一轮更新完成之后

29:50.910 --> 29:53.230
那你的这个web length和current length

29:53.230 --> 29:55.150
是不是就都是no length了

29:55.150 --> 29:55.950
对不对

29:55.950 --> 29:56.590
因此

29:59.660 --> 30:00.140
因此

30:01.340 --> 30:05.900
当这一轮更新完成后

30:06.460 --> 30:09.100
你的这个current点length

30:10.700 --> 30:11.500
和什么呢

30:11.500 --> 30:14.460
和这个web点length

30:15.180 --> 30:15.900
就什么呢

30:15.900 --> 30:19.420
就均为这个no length

30:20.940 --> 30:21.900
均为no length

30:21.900 --> 30:23.340
所以他在后续

30:23.340 --> 30:23.740
因此

30:24.540 --> 30:28.860
所以在这个后续的这个点击中

30:30.060 --> 30:32.220
就会命中什么呢

30:32.220 --> 30:33.820
命中这个eager step

30:35.260 --> 30:35.660
车轮

30:36.700 --> 30:37.180
没有没有

30:37.740 --> 30:39.340
命中这个eager step车轮

30:39.340 --> 30:42.060
那他的这个整个就不会再更新了

30:43.020 --> 30:43.740
好

30:43.740 --> 30:45.980
这就是关于这个eager step

30:45.980 --> 30:46.940
这边的话

30:46.940 --> 30:47.980
大家可以看一下

30:48.860 --> 30:50.380
这边两种车轮

30:50.380 --> 30:51.500
这个eager step

30:51.500 --> 30:52.060
他这个呢

30:52.060 --> 30:53.740
其实逻辑还是比较清晰的

30:53.740 --> 30:54.140
对不对

30:54.140 --> 30:55.340
就你前后没有变化

30:55.340 --> 30:56.620
那我这边就跳过

30:56.620 --> 30:58.460
后续的这个更新流程

30:58.460 --> 30:59.260
OK

30:59.980 --> 31:00.220
好

31:00.220 --> 31:02.060
我们把这个整体来看一下

31:02.060 --> 31:05.100
谈一谈这个react中的这个eager step

31:05.100 --> 31:06.140
策略是什么

31:06.140 --> 31:07.580
这边把这个

31:07.580 --> 31:09.260
称考单我把拿过来

31:09.260 --> 31:15.710
这边的话

31:16.670 --> 31:17.470
看一下

31:17.470 --> 31:18.750
在react内部

31:18.750 --> 31:22.030
性能优化策略可以分为eager step策略

31:22.030 --> 31:23.870
和这个bailout策略

31:25.710 --> 31:27.870
eager step的核心逻辑是什么呢

31:27.870 --> 31:31.070
它是某个状态更新前后没有变化

31:31.070 --> 31:33.790
它就可以跳过这个后续的更新流程

31:34.350 --> 31:37.950
它把这个状态的计算提前到了这个schedule

31:37.950 --> 31:40.030
这个阶段之前就在这里

31:40.030 --> 31:41.470
这个我们刚刚看了的

31:41.470 --> 31:43.070
是不是在这对不对

31:43.070 --> 31:46.270
在这里的话就已经在计算这个新的这个state了

31:46.270 --> 31:47.070
计算了之后

31:47.070 --> 31:49.470
大家就在这边给当前的这个update

31:49.470 --> 31:50.750
做一个标记

31:50.750 --> 31:51.390
对吧

31:51.390 --> 31:52.910
大家在这边看一下

31:52.910 --> 31:54.190
这边这个eaf

31:54.190 --> 31:57.070
看一下是否能够命中一个state策略

31:58.670 --> 31:59.070
OK

31:59.630 --> 31:59.950
好

31:59.950 --> 32:01.310
然后如果命中了这个策略

32:01.310 --> 32:04.030
它就不会进入到这个schedule阶段

32:04.030 --> 32:04.350
对吧

32:04.350 --> 32:06.910
直接使用上一次的这个状态

32:06.910 --> 32:07.710
这个策略的话

32:07.710 --> 32:08.670
它有个前提

32:08.670 --> 32:10.830
就是当前的这个fiber load

32:10.910 --> 32:13.070
它不存在带执行的这个更新

32:13.070 --> 32:14.270
注意

32:14.270 --> 32:14.990
OK

32:14.990 --> 32:15.550
好

32:15.550 --> 32:16.510
然后有些面试提论

32:16.510 --> 32:17.950
它还会考你这个

32:17.950 --> 32:19.550
其实就是我们刚才讲的这个

32:19.550 --> 32:21.550
就刚才讲的这个

32:22.910 --> 32:23.790
就这边

32:23.790 --> 32:26.110
它比如说它给你这么一段代码

32:26.110 --> 32:27.230
给你这么一段代码之后

32:27.230 --> 32:28.510
然后它这边问你

32:28.510 --> 32:29.630
它这边每次点击

32:29.630 --> 32:31.790
为什么第一次点击是这个样子

32:31.790 --> 32:33.310
第二次点击是这样子

32:33.310 --> 32:35.550
第三次以及之后的点击是这个样子

32:37.150 --> 32:37.790
很多同学呢

32:37.790 --> 32:40.270
就是这边这个第二次就不太清楚

32:41.070 --> 32:41.870
你如果就

32:41.870 --> 32:43.630
就是没有这种第二次的这种现象

32:43.630 --> 32:45.390
直接第一次是这个样子

32:45.390 --> 32:47.550
之后的话不会有点这个打印

32:47.550 --> 32:49.790
那很多同学能够打得出来

32:49.790 --> 32:50.030
对吧

32:50.030 --> 32:51.950
因为你这边没有更新嘛

32:51.950 --> 32:52.590
这边没有更新

32:52.590 --> 32:54.190
所以后面的话不会有打印

32:54.190 --> 32:54.510
对吧

32:54.510 --> 32:55.550
这个很多同学能打出来

32:55.550 --> 32:56.590
但是关键是你看

32:56.590 --> 32:57.870
这次点击了之后

32:57.870 --> 32:59.470
人家这边还会多出一个什么

32:59.470 --> 33:02.030
所以这个附属键还会再渲染一次

33:02.030 --> 33:02.750
对吧

33:02.750 --> 33:04.670
这个的话很多同学就不知道为什么了

33:04.670 --> 33:07.710
实际上就和它内部的这个策略

33:07.710 --> 33:10.270
和它这个内部的代码有关系

33:10.350 --> 33:11.070
对吧

33:11.070 --> 33:11.790
实际上就是什么

33:11.790 --> 33:12.590
实际上就是你这边

33:13.630 --> 33:15.150
这边它的这个判断条件

33:15.150 --> 33:16.670
它必须是当前的fiber

33:16.670 --> 33:18.270
以及它的那个对应的

33:18.270 --> 33:19.630
另外一个fiber

33:19.630 --> 33:21.630
这两个这个都是no lance

33:22.430 --> 33:22.910
ok

33:22.910 --> 33:24.910
那为什么之后的话又命中这个

33:25.790 --> 33:27.550
这个eager stator呢

33:27.550 --> 33:28.430
因为之后的话

33:28.430 --> 33:29.950
因为你刚才的话没有命中

33:29.950 --> 33:31.390
但是刚才你命中了什么

33:31.390 --> 33:33.150
刚才你命中了这个bailout

33:33.950 --> 33:36.110
bailout人家它执行bailout对应的

33:36.110 --> 33:37.390
bailout hooks

33:37.390 --> 33:39.230
里面的话会把另外一个

33:39.230 --> 33:41.230
没有驱除nance的那个fiber

33:41.230 --> 33:42.990
把它的这个nance给它驱除掉

33:43.630 --> 33:44.110
对不对

33:44.110 --> 33:44.750
所以之后的话

33:44.750 --> 33:46.510
它就可以命中eager stator

33:47.230 --> 33:47.550
ok

33:48.750 --> 33:49.070
好

33:49.070 --> 33:52.990
这就是关于这个eager stator这个策略

33:54.030 --> 33:54.270
好

33:54.270 --> 33:55.630
这期课的话就到这里

33:55.630 --> 33:57.150
下期课再见

