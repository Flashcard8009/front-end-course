WEBVTT

00:00.180 --> 00:06.180
上节课的话我们讲了react中性能优化策略

00:06.180 --> 00:11.180
我们说这个react内部它有两个性能优化策略

00:11.180 --> 00:13.180
一个的话是eagle state

00:13.180 --> 00:15.180
另外一个的话是bailout

00:15.180 --> 00:19.180
那么我们上节课的话把这个eagle state给大家介绍了一下

00:19.180 --> 00:23.180
那么这节课的话我们就来看一下这个bailout

00:23.180 --> 00:29.180
这边这个面试题让你谈一谈react中bailout策略

00:29.180 --> 00:31.180
好来我们一起来看一下

00:31.180 --> 00:34.180
那么我们在前面学习这个beginwork的时候

00:34.180 --> 00:38.180
我们知道beginwork它的作用主要是生成什么

00:38.180 --> 00:42.180
是不是主要是生成这个webfibreload的这个字

00:42.180 --> 00:44.180
这个fibreload对吧

00:44.180 --> 00:50.680
前面我们学习这个beginwork的时候

00:50.680 --> 00:52.680
beginwork的时候

00:52.680 --> 00:59.680
我们知道这个beginwork的作用

00:59.680 --> 01:01.680
主要是生成什么呢

01:01.680 --> 01:06.680
生成这个webfibreload的这个字

01:06.680 --> 01:11.120
字fibreload

01:11.120 --> 01:12.120
OK

01:12.120 --> 01:15.120
那么你要实现就是要实现这个目的

01:15.120 --> 01:16.120
要达到这个目的

01:16.120 --> 01:19.120
让它存在两条路径

01:19.120 --> 01:25.120
要达到这个目的存在两种路径

01:25.120 --> 01:27.120
或者说两种方式

01:27.120 --> 01:29.120
两种方式

01:29.120 --> 01:30.120
两种方式呢

01:30.120 --> 01:31.120
那首先的话

01:31.120 --> 01:33.120
第一个就是我们之前所讲的

01:33.120 --> 01:36.690
通过reconcile

01:36.690 --> 01:38.690
通过reconcile流程

01:38.690 --> 01:41.690
生成

01:41.690 --> 01:46.690
生成这个字fibreload对吧

01:46.690 --> 01:47.690
第二种

01:47.690 --> 01:50.690
第二种的话就是通过这个命中

01:50.690 --> 01:52.690
这个bailout

01:52.690 --> 01:55.690
bailout策略

01:55.690 --> 01:57.690
来附用

01:57.690 --> 01:59.690
来附用

01:59.690 --> 02:04.770
附用指这个fibreload

02:04.770 --> 02:05.770
看一看

02:05.770 --> 02:07.770
那我们之前讲的是那种路径

02:07.770 --> 02:09.770
是不是我们之前讲的是这种路径

02:09.770 --> 02:10.770
对吧

02:10.770 --> 02:11.770
那我们这边就要来看一下

02:11.770 --> 02:13.770
这边命中bailout

02:13.770 --> 02:14.770
命中这个策略

02:14.770 --> 02:16.770
它附用这个指fibreload

02:16.770 --> 02:17.770
是如何这个

02:17.770 --> 02:19.770
就如何能够命中这个策略

02:19.770 --> 02:20.770
好

02:20.770 --> 02:21.770
我们前面的话

02:21.770 --> 02:22.770
我们讲过

02:22.770 --> 02:24.770
所有的变化都是有什么呢

02:24.770 --> 02:27.770
是不是都是有自变量的改变造成的

02:27.770 --> 02:28.770
对吧

02:28.770 --> 02:30.770
在前面

02:30.770 --> 02:31.770
在前面

02:31.770 --> 02:32.770
我们讲过

02:32.770 --> 02:35.770
所有的这个变化

02:35.770 --> 02:37.770
都是有什么呢

02:37.770 --> 02:39.770
都是有自变量

02:39.770 --> 02:40.770
还记得吧

02:40.770 --> 02:41.770
这个很早之前讲的了

02:41.770 --> 02:43.770
好像是前面

02:43.770 --> 02:44.770
第一节课吗

02:44.770 --> 02:45.770
第二节课讲的

02:45.770 --> 02:46.770
好像是第二节课

02:46.770 --> 02:47.770
是吧

02:47.770 --> 02:49.770
所有的变化都是什么呢

02:49.770 --> 02:53.770
都是有这个自变量的这个改变造成的

02:53.770 --> 02:56.770
那么这个在react中

02:56.770 --> 02:58.770
在react中

02:58.770 --> 02:59.770
自变量有哪些呢

02:59.770 --> 03:01.770
自变量的话有这么一些

03:01.770 --> 03:03.770
首先你state

03:03.770 --> 03:05.770
你逐渐内部的状态

03:05.770 --> 03:06.770
对吧

03:06.770 --> 03:07.770
它可以算是一个自变量

03:07.770 --> 03:08.770
还有什么呢

03:08.770 --> 03:11.770
还有就是你传入的probs

03:11.770 --> 03:13.770
你传入的probs

03:13.770 --> 03:16.770
还有一个就是context

03:16.770 --> 03:18.770
主要就是这三个

03:18.770 --> 03:19.770
OK

03:19.770 --> 03:20.770
因此的话就是

03:20.770 --> 03:22.770
是否命中这个buildout

03:22.770 --> 03:26.770
主要也是围绕这三个变量展开的

03:26.770 --> 03:28.770
因此

03:28.770 --> 03:32.770
是否命中buildout

03:32.770 --> 03:38.770
主要也是围绕这三个变量

03:38.770 --> 03:41.770
这三个变量展开的

03:41.770 --> 03:42.770
好

03:42.770 --> 03:45.770
然后整体的这个工作流程

03:45.770 --> 03:46.770
如下

03:46.770 --> 03:47.770
好

03:47.770 --> 03:48.770
我们来看一下

03:48.770 --> 03:49.770
这边有张图

03:49.770 --> 03:51.770
我把这张图拿过来

03:51.770 --> 03:52.770
稍等啊

03:52.770 --> 03:54.770
这边老是

03:54.770 --> 03:56.770
最近这个这个

03:56.770 --> 03:59.770
它老是会卡住

03:59.770 --> 04:00.770
OK

04:00.770 --> 04:01.770
来看一下

04:01.770 --> 04:03.770
这个是不是我们之前讲的

04:03.770 --> 04:05.770
这个begin walk的图

04:05.770 --> 04:06.770
对不对

04:06.770 --> 04:07.770
好

04:07.770 --> 04:08.770
begin walk这个图

04:08.770 --> 04:09.770
你看它这边复用

04:09.770 --> 04:10.770
复用的话

04:10.770 --> 04:11.770
主要是在什么时候呢

04:11.770 --> 04:13.770
主要是在update的时候

04:13.770 --> 04:15.770
mount存不存在什么复用

04:15.770 --> 04:16.770
mount不存在吗

04:16.770 --> 04:18.770
mount你是出自渲染吗

04:18.770 --> 04:19.770
对不对

04:19.770 --> 04:20.770
mount你出自渲染

04:20.770 --> 04:21.770
这边就直接就过来了

04:21.770 --> 04:22.770
所以mount不存在

04:22.770 --> 04:23.770
主要是什么呢

04:23.770 --> 04:25.770
主要是update

04:25.770 --> 04:26.770
update

04:26.770 --> 04:27.770
然后接下来这边的话

04:27.770 --> 04:28.770
有两次

04:28.770 --> 04:30.770
这边首先就会判断

04:30.770 --> 04:31.770
是否能复用

04:31.770 --> 04:32.770
如果是

04:32.770 --> 04:33.770
这边进行复用

04:33.770 --> 04:35.770
复用这边还会判断一个

04:35.770 --> 04:36.770
优化的这个程度

04:36.770 --> 04:37.770
如果否

04:37.770 --> 04:38.770
否的话

04:38.770 --> 04:39.770
然后接下来过来

04:39.770 --> 04:40.770
过来

04:40.770 --> 04:41.770
然后根据这个web talk

04:41.770 --> 04:42.770
区别进行对待

04:42.770 --> 04:43.770
然后完事之后

04:43.770 --> 04:45.770
然后又会判断一次

04:45.770 --> 04:47.770
是否可以复用

04:47.770 --> 04:48.770
如果是

04:48.770 --> 04:49.770
这边那走这边

04:49.770 --> 04:51.770
我们之前的话讲的是什么

04:51.770 --> 04:52.770
我们之前讲的是不知道

04:52.770 --> 04:53.770
下面

04:53.770 --> 04:54.770
对不对

04:54.770 --> 04:55.770
这个流程途

04:55.770 --> 04:56.770
我们是往下面走的

04:56.770 --> 04:57.770
就我们在讲那个

04:57.770 --> 04:58.770
begin walk的时候

04:58.770 --> 05:00.770
那这边如果能复用

05:00.770 --> 05:01.770
过来

05:01.770 --> 05:02.770
过来之后

05:02.770 --> 05:03.770
然后判断这个优化程度

05:03.770 --> 05:05.770
如果优化程度高

05:05.770 --> 05:07.770
直接跳过指数的这个

05:07.770 --> 05:08.770
begin walk

05:08.770 --> 05:10.770
如果优化程度低

05:10.770 --> 05:11.770
那么他这会

05:11.770 --> 05:12.770
这边会复用

05:12.770 --> 05:14.770
指数的这个web load

05:14.770 --> 05:15.770
ok

05:15.770 --> 05:17.770
好我们这边来看一下

05:17.770 --> 05:19.770
从上图

05:19.770 --> 05:21.770
可以看出

05:21.770 --> 05:24.770
在进入这个begin walk

05:25.770 --> 05:27.770
begin walk

05:27.770 --> 05:29.770
后会有什么

05:29.770 --> 05:31.770
说会有两次

05:31.770 --> 05:33.770
是否命中

05:34.770 --> 05:36.770
bello out策略的

05:36.770 --> 05:38.770
这个相关判断

05:38.770 --> 05:41.140
对

05:41.140 --> 05:42.140
会有两次

05:42.140 --> 05:44.140
这边的话是第一次判断

05:44.140 --> 05:45.140
这边的话是第二次判断

05:45.140 --> 05:46.140
还有就什么呢

05:46.140 --> 05:47.140
还有它是发生在

05:47.140 --> 05:49.140
这个更新阶段

05:49.140 --> 05:51.140
从上图可以看出

05:52.140 --> 05:54.140
bello out

05:55.140 --> 05:57.140
是否命中

05:57.140 --> 05:59.140
发生在什么

05:59.140 --> 06:01.140
发生在update阶段

06:02.140 --> 06:03.140
对吧

06:03.140 --> 06:05.140
在进入begin walk后

06:05.140 --> 06:06.140
会有两次

06:06.140 --> 06:07.140
是否命中这个

06:07.140 --> 06:09.140
bello out策略的相关判断

06:09.140 --> 06:10.140
ok

06:10.140 --> 06:11.140
好

06:11.140 --> 06:13.140
所以接下来我们就围绕这两次

06:13.140 --> 06:14.140
这边首先是

06:14.140 --> 06:15.140
第一次判断

06:15.140 --> 06:17.140
它有哪些条件

06:17.140 --> 06:18.140
好

06:18.140 --> 06:19.140
然后接下来的话

06:19.140 --> 06:21.520
第二次判断

06:21.520 --> 06:22.520
它有哪些条件

06:22.520 --> 06:24.520
我们这边依次来看一下

06:24.520 --> 06:25.520
首先的话是

06:25.520 --> 06:26.520
第一次

06:26.520 --> 06:28.520
第一次判断发生在什么时候

06:28.520 --> 06:30.520
是发生在刚刚进入

06:30.520 --> 06:31.520
这边这个update

06:31.520 --> 06:32.520
是否刚刚过来

06:32.520 --> 06:33.520
对不对

06:33.520 --> 06:35.520
第一次判断

06:35.520 --> 06:37.520
第一次判断

06:37.520 --> 06:38.520
发生在

06:38.520 --> 06:39.520
这个

06:39.520 --> 06:41.520
确定了

06:41.520 --> 06:43.520
确

06:43.520 --> 06:45.520
确定了是什么呢

06:45.520 --> 06:47.520
是这个update

06:47.520 --> 06:49.520
update后

06:49.520 --> 06:50.520
然后接下来的话

06:50.520 --> 06:51.520
ok

06:51.520 --> 06:52.520
这边begin work

06:52.520 --> 06:54.520
确定了这个update后

06:54.520 --> 06:57.520
立马就会

06:57.520 --> 06:59.520
立马就会

06:59.520 --> 07:00.520
进行这个

07:00.520 --> 07:02.520
是否

07:02.520 --> 07:04.520
能够复用

07:04.520 --> 07:07.520
能够复用的这个判断

07:07.520 --> 07:08.520
好了

07:08.520 --> 07:09.520
接下来它这边

07:09.520 --> 07:10.520
有些什么条件呢

07:10.520 --> 07:11.520
总结起来的话

07:11.520 --> 07:14.520
有这么四个条件

07:14.520 --> 07:17.520
有这么四个

07:17.520 --> 07:18.520
首先

07:18.520 --> 07:19.520
第一个就是

07:19.520 --> 07:21.520
这个old props

07:21.520 --> 07:23.520
是否全等于

07:23.520 --> 07:25.520
new props

07:25.520 --> 07:27.520
好这个呢你的这个next context

07:27.520 --> 07:29.520
next context是什么

07:29.520 --> 07:31.520
我们知道这个整个react

07:31.520 --> 07:33.520
它的这个context API

07:33.520 --> 07:35.520
它是有更新的

07:35.520 --> 07:37.520
对吧它之前的话有个老板的

07:37.520 --> 07:39.520
现在的话有一个新板的

07:39.520 --> 07:40.520
所以它这边是

07:40.520 --> 07:42.520
确定这个老板的这个

07:42.520 --> 07:44.520
是否有没有变化

07:44.520 --> 07:45.520
好然后还有就是什么呢

07:45.520 --> 07:47.520
还有就是这个fiber load

07:47.520 --> 07:49.520
它的这个type

07:49.520 --> 07:50.520
有没有变化

07:50.520 --> 07:53.520
最后就是当前这个fiber load

07:53.520 --> 07:55.520
它没有这个更新发生

07:55.520 --> 07:57.520
我们一个一个来看一下

07:57.520 --> 08:02.620
我们把它拿过来

08:02.620 --> 08:08.300
按着按着看一下

08:08.300 --> 08:10.300
好首先的话是第一个

08:10.300 --> 08:12.300
这个old props

08:12.300 --> 08:15.300
要全等于这个new props

08:15.300 --> 08:16.300
你注意

08:16.300 --> 08:19.300
这里的话它是做的是一个全等比较

08:19.300 --> 08:20.300
注意

08:20.300 --> 08:23.300
这里是做的一个

08:23.300 --> 08:26.300
全等比较

08:26.300 --> 08:27.300
它这边要求什么呢

08:27.300 --> 08:28.300
要求就是你这边

08:28.300 --> 08:30.300
我们的那个render

08:30.300 --> 08:32.300
render的话它实际上返回的是什么

08:32.300 --> 08:34.300
实际上返回的是不是这个

08:34.300 --> 08:35.300
create element的方法

08:35.300 --> 08:37.300
执行的这个结果

08:37.300 --> 08:38.300
实际上拿到的是一个什么

08:38.300 --> 08:40.300
拿到的是一个react元素

08:40.300 --> 08:41.300
对不对

08:41.300 --> 08:43.300
主件在

08:43.300 --> 08:45.300
render之后

08:45.300 --> 08:49.300
拿到的是一个react

08:50.300 --> 08:51.300
元素

08:51.300 --> 08:52.300
对吧

08:52.300 --> 08:53.300
好那接下来的话

08:53.300 --> 08:54.300
它这边就会针对这个

08:54.300 --> 08:56.300
两个react元素

08:56.300 --> 09:00.300
它进行一个这个pops属性的这个比较

09:00.300 --> 09:02.300
因此

09:02.300 --> 09:04.300
这里的比较

09:04.300 --> 09:06.300
就是针对什么呢

09:06.300 --> 09:09.300
针对这个前后

09:09.300 --> 09:12.300
react元素的这个pops

09:12.300 --> 09:16.620
pops属性

09:16.620 --> 09:19.620
进行一个比较

09:19.620 --> 09:20.620
ok

09:20.620 --> 09:22.620
如果你的这个pops

09:22.620 --> 09:25.620
每一项属性都没有变化

09:25.620 --> 09:28.620
那这边它会认为就是没有变化

09:28.620 --> 09:32.620
如果pops属性

09:32.620 --> 09:40.140
每一项都没有变化

09:40.140 --> 09:44.140
会被认为是一样的

09:44.140 --> 09:46.140
但是这边的话你注意

09:46.140 --> 09:48.140
这边它有个注意点

09:48.140 --> 09:49.140
什么注意点呢

09:49.140 --> 09:52.140
就是你每一次在这个重新

09:52.140 --> 09:53.140
render的时候

09:53.140 --> 09:54.140
它会生成一个什么

09:54.140 --> 09:57.140
会生成一个全新的这个对象

09:57.140 --> 09:58.140
对不对

09:58.140 --> 09:59.140
但是

09:59.140 --> 10:03.140
这里有一个注意点

10:03.140 --> 10:05.140
就是每一次

10:05.140 --> 10:08.140
render的这个时候

10:08.140 --> 10:09.140
就你主件

10:09.140 --> 10:10.140
每一次主

10:10.140 --> 10:11.140
这个主件

10:11.140 --> 10:12.140
render的时候

10:12.140 --> 10:15.840
它会生成

10:15.840 --> 10:19.840
会生成一个全新的

10:19.840 --> 10:22.840
全新的对象引用

10:22.840 --> 10:24.840
因此这个

10:24.840 --> 10:27.840
older props和new props

10:27.840 --> 10:30.840
它实际上它是并不会全的

10:30.840 --> 10:31.840
因此

10:31.840 --> 10:38.840
older props和new props

10:38.840 --> 10:41.840
并不会全的

10:41.840 --> 10:42.840
对吧

10:42.840 --> 10:43.840
所以实际的话

10:43.840 --> 10:46.840
它是没有办法命中bill out的

10:47.840 --> 10:48.840
实施

10:48.840 --> 10:53.840
没有办法命中bill out

10:54.840 --> 10:56.840
那既然你这种就是

10:56.840 --> 10:57.840
每次都是生成的

10:57.840 --> 10:58.840
一个新的对象引用

10:58.840 --> 10:59.840
那每次

10:59.840 --> 11:00.840
它们都没有办法

11:00.840 --> 11:01.840
这个做全等

11:01.840 --> 11:02.840
这个比较

11:02.840 --> 11:03.840
那你这边

11:03.840 --> 11:04.840
那你这个还有

11:04.840 --> 11:06.840
就什么时候能够全等呢

11:06.840 --> 11:07.840
它这边实际上

11:07.840 --> 11:08.840
只有当什么呢

11:08.840 --> 11:09.840
只有当这个

11:09.840 --> 11:10.840
复fiber load的

11:10.840 --> 11:11.840
命中这个bill out

11:11.840 --> 11:12.840
策略的时候

11:13.840 --> 11:14.840
只有当

11:15.840 --> 11:17.840
复fiber load

11:17.840 --> 11:21.340
命中这个bill out

11:22.340 --> 11:23.340
策略的时候

11:24.340 --> 11:26.340
命中这个bill out策略

11:26.340 --> 11:27.340
实

11:27.340 --> 11:28.340
然后复用

11:28.340 --> 11:31.340
这个直fiber load

11:32.340 --> 11:34.340
那在这个直

11:34.340 --> 11:37.340
在这个直fiber load

11:38.340 --> 11:40.340
的这个beginwork中

11:41.340 --> 11:43.340
beginwork中

11:43.340 --> 11:45.340
这个old props

11:45.340 --> 11:47.340
才有可能

11:48.340 --> 11:49.340
才有可能和什么呢

11:49.340 --> 11:52.340
和这个new props

11:52.340 --> 11:53.340
全等

11:53.340 --> 11:55.340
这点的话一定要注意

11:55.340 --> 11:56.340
OK

11:56.340 --> 11:57.340
就是当你的这个

11:57.340 --> 11:58.340
复fiber load

11:58.340 --> 11:59.340
命中这个bill out

11:59.340 --> 12:01.340
那你在复用这个直

12:01.340 --> 12:03.340
这个fiber load的时候

12:03.340 --> 12:05.340
那你这个直的fiber load

12:05.340 --> 12:06.340
它在beginwork中

12:06.340 --> 12:08.340
它这个这个old props

12:08.340 --> 12:09.340
和这个new props

12:09.340 --> 12:10.340
才有可能全等

12:10.340 --> 12:11.340
你普通的话

12:11.340 --> 12:12.340
你这种对象的话

12:12.340 --> 12:14.340
它这边每次生成的都是一个

12:14.340 --> 12:16.340
新的这个对象引用

12:16.340 --> 12:17.340
OK

12:19.340 --> 12:20.340
接下来下一个

12:20.340 --> 12:23.340
下一个的话是这个negacy context

12:24.340 --> 12:25.340
这个

12:26.340 --> 12:28.340
这个negacy context

12:28.340 --> 12:31.340
negacy context

12:31.340 --> 12:33.340
这个它指的是什么呢

12:33.340 --> 12:34.340
它指的是

12:34.340 --> 12:36.340
old context api

12:36.340 --> 12:38.340
指的是

12:38.340 --> 12:40.340
old context api

12:43.340 --> 12:45.340
我们知道这个整个react中

12:45.340 --> 12:47.340
它的这个context api

12:47.340 --> 12:49.340
它是经历过一次重构的

12:49.340 --> 12:51.340
为什么要重构

12:51.340 --> 12:52.340
实际上这个重构

12:52.340 --> 12:54.340
很大一部分原因就是

12:54.340 --> 12:56.340
与这个bill out策略相关

12:56.340 --> 12:58.340
这个的话我们在下一小节

12:58.340 --> 13:00.340
下一小节我们专门来看一下

13:00.340 --> 13:02.340
关于这个

13:02.340 --> 13:04.340
context api和这个bill out

13:04.340 --> 13:07.340
策略之间的这个关系

13:07.340 --> 13:09.340
我们这边简单记一下嘛

13:09.340 --> 13:10.340
指的是

13:10.340 --> 13:12.340
old context api

13:12.340 --> 13:14.340
context api

13:14.340 --> 13:16.340
然后重构过一次

13:16.340 --> 13:18.340
重构过一次

13:18.340 --> 13:19.340
之所以

13:19.340 --> 13:21.340
重构

13:21.340 --> 13:23.340
就是和什么呢

13:23.340 --> 13:26.340
就是和这个bill out策略相关

13:27.340 --> 13:29.340
这个的话我们在下一小节

13:29.340 --> 13:31.340
再来进行这个介绍

13:31.340 --> 13:32.340
OK

13:32.340 --> 13:33.340
好那第三个

13:33.340 --> 13:36.340
第三个的话是看你的这个fiber load

13:36.340 --> 13:37.340
这个type

13:37.340 --> 13:39.340
它有没有变化

13:39.340 --> 13:40.340
OK

13:40.340 --> 13:42.340
它这边就是你这边的话不能有变化

13:42.340 --> 13:43.340
啊

13:43.340 --> 13:45.340
这里

13:45.340 --> 13:47.340
所指的

13:47.340 --> 13:49.340
这个fiber load

13:49.340 --> 13:51.340
点这个type

13:51.340 --> 13:53.340
没有变化

13:53.340 --> 13:54.340
指的是什么呢

13:54.340 --> 13:55.340
指的是

13:55.340 --> 13:56.340
不能

13:56.340 --> 13:58.340
就是不能

13:58.340 --> 14:00.850
比如说

14:00.850 --> 14:01.850
不能

14:01.850 --> 14:03.850
发生

14:03.850 --> 14:04.850
例如什么呢

14:04.850 --> 14:07.850
例如从这个div

14:07.850 --> 14:09.850
变为这个比如说p

14:09.850 --> 14:11.850
啊这种变化

14:11.850 --> 14:15.930
啊不能有吗

14:15.930 --> 14:16.930
不能有

14:16.930 --> 14:18.930
OK那指的是这个

14:18.930 --> 14:19.930
啊指的是不能有

14:19.930 --> 14:21.930
比如说你从div变成p

14:21.930 --> 14:23.930
这种它是不是就type发生改变了

14:23.930 --> 14:24.930
对不对

14:24.930 --> 14:25.930
OK

14:25.930 --> 14:27.930
好人家这边有个这个细节

14:27.930 --> 14:28.930
大家要注意啊

14:28.930 --> 14:30.930
比如说我这边有这么一个代码

14:30.930 --> 14:35.260
function

14:35.260 --> 14:37.260
啊这个呢它是一个组件

14:37.260 --> 14:39.260
好然后接下来我在组件里面

14:39.260 --> 14:41.260
我这边定义了一个什么呢

14:41.260 --> 14:43.260
定义了一个这个细组件

14:43.260 --> 14:45.260
啊这边比如说一个div

14:45.260 --> 14:50.620
div啊比如这边是啊

14:50.620 --> 14:52.620
翘的

14:52.620 --> 14:54.620
啊这边return

14:54.620 --> 14:56.620
return 翘的

14:56.620 --> 14:58.620
OK

14:58.620 --> 15:00.620
你注意一下这个代码

15:00.620 --> 15:01.620
这个代码的话

15:01.620 --> 15:03.620
我的这个翘的细组件

15:03.620 --> 15:05.620
是在哪里定义的

15:05.620 --> 15:06.620
我这翘的细组件

15:06.620 --> 15:08.620
是不是在app里面定义的

15:08.620 --> 15:10.620
那你每次这个app

15:10.620 --> 15:12.620
你这个

15:12.620 --> 15:14.620
定了之后他是不是都会

15:14.620 --> 15:16.620
创建新的这个翘的引药

15:16.620 --> 15:19.770
对了

15:19.770 --> 15:21.770
因此对于这个翘的来讲的话

15:21.770 --> 15:24.770
他的这个fiberload的这个type

15:24.770 --> 15:26.770
它始终是变化的

15:26.770 --> 15:28.770
所以它是没有办法命中这个bill out的

15:28.770 --> 15:29.770
大家一定要注意啊

15:29.770 --> 15:32.770
你不要在组件内部定义这个组件

15:32.770 --> 15:34.770
比如你去面试的时候别人问到你

15:34.770 --> 15:35.770
对吧

15:35.770 --> 15:37.770
为什么最好不要在组件内部再定义组件

15:37.770 --> 15:39.770
实际上你这边就可以从这个

15:39.770 --> 15:42.770
这个这个这个方向去回答

15:42.770 --> 15:43.770
所以你这样子的话

15:43.770 --> 15:46.770
无法命中他的这个bill out这个策略

15:46.770 --> 15:47.770
对不对

15:47.770 --> 15:49.770
好在上面的代码中

15:49.770 --> 15:52.770
在上面的代码中

15:52.770 --> 15:56.770
我们在app组件中

15:56.770 --> 15:57.770
定义了什么呢

15:57.770 --> 16:01.140
定义了这个翘的

16:01.140 --> 16:03.140
定义了这个翘的组件

16:03.140 --> 16:04.140
那么

16:04.140 --> 16:06.140
app

16:06.140 --> 16:08.140
app每次

16:08.140 --> 16:10.140
扔掉之后

16:10.140 --> 16:12.140
都会创建什么

16:12.140 --> 16:13.140
是不是新的

16:13.140 --> 16:15.140
是不是翘的

16:15.140 --> 16:17.140
的这个运用

16:17.140 --> 16:18.140
对不对

16:18.140 --> 16:20.140
因此

16:20.140 --> 16:21.140
对于

16:21.140 --> 16:23.140
翘的

16:23.140 --> 16:24.140
来讲

16:24.140 --> 16:27.140
这个fiber node

16:27.140 --> 16:30.140
fiber node点这个type

16:30.140 --> 16:34.860
始终是变化的

16:34.860 --> 16:39.860
无法命中这个bill out

16:39.860 --> 16:40.860
策略

16:40.860 --> 16:41.860
OK

16:41.860 --> 16:42.860
所以我们要注意什么

16:42.860 --> 16:43.860
因此

16:43.860 --> 16:45.860
尽量就不要

16:45.860 --> 16:47.860
因此不要再

16:47.860 --> 16:49.860
组建内部

16:49.860 --> 16:50.860
再什么呢

16:50.860 --> 16:54.180
再定义组件

16:54.180 --> 16:55.180
以免什么呢

16:55.180 --> 16:58.180
以免无法命中

16:58.180 --> 17:02.000
这个优化策略

17:02.000 --> 17:05.000
不要有这样的邪法

17:05.000 --> 17:06.000
这是第三点

17:06.000 --> 17:07.000
好

17:07.000 --> 17:09.000
然后接下来的话第四点

17:09.000 --> 17:10.000
第四点的话就是

17:10.000 --> 17:11.000
当前

17:11.000 --> 17:13.000
当前这个fiber node

17:13.000 --> 17:15.000
没有更新

17:15.000 --> 17:16.000
这个发生

17:16.000 --> 17:17.000
好

17:17.000 --> 17:18.000
我们知道

17:18.000 --> 17:20.000
这个当前fiber node

17:20.000 --> 17:22.000
它没有更新发生

17:22.000 --> 17:23.000
意味着什么

17:23.000 --> 17:24.000
所以意味着这个

17:24.000 --> 17:26.000
没有state发生变化

17:26.000 --> 17:27.000
对吧

17:27.000 --> 17:31.080
当前

17:31.080 --> 17:33.080
当前fiber node

17:33.080 --> 17:37.080
没有发生更新

17:37.080 --> 17:39.080
则意味着什么

17:39.080 --> 17:41.080
意味着什么state

17:41.080 --> 17:44.080
没有发生变化

17:44.080 --> 17:45.080
对不对

17:45.080 --> 17:46.080
实际上在原码里面的话

17:46.080 --> 17:47.080
经常会有就是

17:47.080 --> 17:49.080
判断是否有这个更新

17:49.080 --> 17:51.080
这个就是条件判断

17:51.080 --> 17:53.080
举个例子

17:53.080 --> 17:56.080
这个是一段原码片段

17:56.080 --> 17:59.670
比如这边

17:59.670 --> 18:02.670
你看这边就经常会去检查

18:02.670 --> 18:05.670
检查你这边是否有这个更新存在

18:05.670 --> 18:06.670
看到没有

18:06.670 --> 18:07.670
例如

18:07.670 --> 18:12.880
例如在原码中

18:12.880 --> 18:15.880
经常会存在

18:15.880 --> 18:19.880
是否有更新的检查

18:23.410 --> 18:25.410
你如果就是没有更新

18:25.410 --> 18:26.410
不存在更新的话

18:26.410 --> 18:27.410
那你是不是意味着

18:27.410 --> 18:29.410
state肯定没有变化

18:29.410 --> 18:30.410
对不对

18:30.410 --> 18:31.410
因为你只有更新

18:31.410 --> 18:33.410
才会带来state的变化

18:33.410 --> 18:34.410
这个没问题

18:34.410 --> 18:35.410
对吧

18:35.410 --> 18:36.410
你都没有更新

18:36.410 --> 18:37.410
没有更新的话

18:37.410 --> 18:38.410
这边不存在更新

18:38.410 --> 18:39.410
不存在更新那你的state

18:39.410 --> 18:40.410
所以就不会变化

18:40.410 --> 18:41.410
不会变化的话

18:41.410 --> 18:42.410
那接下来我就可以考虑

18:42.410 --> 18:45.410
是不是这边就命中策略

18:45.410 --> 18:47.410
命中性能优化策略

18:47.410 --> 18:48.410
在原码里面

18:48.410 --> 18:50.410
经常有这样的检查

18:50.410 --> 18:51.410
好

18:51.410 --> 18:54.410
然后当以上这个条件都满足时

18:54.410 --> 18:55.410
注意哦

18:55.410 --> 18:57.410
它不是说满足其中一条

18:57.410 --> 19:01.410
它是上面4个条件都要满足

19:01.410 --> 19:07.410
当以上条件都满足的时候

19:07.410 --> 19:08.410
会干嘛呢

19:08.410 --> 19:11.410
会命中

19:11.410 --> 19:13.410
build out策略

19:13.410 --> 19:15.410
会命中策略

19:15.410 --> 19:16.410
命中

19:16.410 --> 19:18.410
该策略后

19:18.410 --> 19:20.410
会执行什么呢

19:20.410 --> 19:22.410
会执行一个叫做build out

19:22.410 --> 19:25.410
然后 on already

19:25.410 --> 19:28.420
ready

19:28.420 --> 19:32.860
finish the work

19:32.860 --> 19:34.860
这名字很长

19:34.860 --> 19:36.860
它会执行这么一个方法

19:36.860 --> 19:37.860
在这个方法里面

19:37.860 --> 19:38.860
它会干嘛呢

19:38.860 --> 19:40.860
你看这张图

19:40.860 --> 19:43.860
它会进一步的判断你的优化程度

19:43.860 --> 19:44.860
根据你的优化程度

19:44.860 --> 19:47.860
是跳过指数的begin work

19:47.860 --> 19:49.860
还是复用指数的fiber load

19:49.860 --> 19:51.860
OK

19:51.860 --> 19:53.860
会执行该方法

19:53.860 --> 19:57.860
在该方法中

19:57.860 --> 20:01.860
会进一步的判断

20:01.860 --> 20:05.860
判断这个优化程度

20:05.860 --> 20:09.860
根据优化程度

20:09.860 --> 20:13.860
优化程度

20:13.860 --> 20:15.860
优化程度

20:15.860 --> 20:18.860
优化程度来决定

20:18.860 --> 20:21.860
是这个复用

20:21.860 --> 20:23.860
这就是指数

20:23.860 --> 20:26.860
就是整颗指数

20:26.860 --> 20:29.860
整颗指数都命中

20:29.860 --> 20:31.860
这个build out

20:31.860 --> 20:34.860
还是这个指数

20:34.860 --> 20:36.860
就是克龙

20:36.860 --> 20:38.860
克龙指数

20:38.860 --> 20:39.860
或者说复用

20:39.860 --> 20:44.860
复用指数的fiber load

20:44.860 --> 20:46.860
它会做这么一个判断

20:46.860 --> 20:49.860
比如我们看到的代码片段

20:49.860 --> 20:50.860
在这里

20:50.860 --> 20:56.250
在这边

20:56.250 --> 20:58.250
你看它这边会做这么一个判断

20:58.250 --> 21:00.250
如果进到这个衣服

21:00.250 --> 21:01.250
进到这个衣服

21:01.250 --> 21:02.250
进到这个衣服说明什么呢

21:02.250 --> 21:04.250
说明整颗指数都命中了

21:04.250 --> 21:06.250
这个build out策略

21:06.250 --> 21:08.250
如果没有进

21:08.250 --> 21:09.250
没有进的话

21:09.250 --> 21:11.250
它就是没有命中的build out

21:11.250 --> 21:12.250
但是它这边

21:12.250 --> 21:13.250
它就是指数命中了

21:13.250 --> 21:14.250
那这边

21:14.250 --> 21:15.250
它可以干嘛呢

21:15.250 --> 21:17.250
可以复用它的指数

21:17.250 --> 21:19.250
可以复用它的指数

21:19.250 --> 21:20.250
说这边

21:20.250 --> 21:23.200
这边它通过

21:23.200 --> 21:25.200
walk imprograms

21:25.200 --> 21:27.200
这个childnance

21:27.200 --> 21:28.200
这个walk imprograms是什么

21:28.200 --> 21:30.200
这个其实就是当前的

21:30.200 --> 21:31.200
这边这个

21:31.200 --> 21:34.900
walk imprograms

21:34.900 --> 21:35.900
这个就是什么

21:35.900 --> 21:37.900
当前的这个webfiberload

21:37.900 --> 21:38.900
对不对

21:38.900 --> 21:40.900
这个实际上就是web

21:41.900 --> 21:43.900
这个实际上就是

21:43.900 --> 21:46.900
这个webfiberload

21:46.900 --> 21:47.900
对吧

21:47.900 --> 21:49.900
通过这个东西

21:49.900 --> 21:51.900
通过这个webfiberload

21:51.900 --> 21:53.900
它的这个childnance

21:53.900 --> 21:54.900
就可以干嘛呢

21:54.900 --> 21:57.900
就可以快速

21:57.900 --> 21:59.900
快速的这个排查

21:59.900 --> 22:02.900
当前的这个fiberload

22:02.900 --> 22:05.900
当前的这个fiber

22:05.900 --> 22:06.900
这个节点

22:06.900 --> 22:07.900
它的什么呢

22:07.900 --> 22:10.900
它的这个整颗指数

22:10.900 --> 22:12.900
是否存在

22:12.900 --> 22:13.900
更新

22:13.900 --> 22:15.900
如果不存在

22:15.900 --> 22:17.900
直接干嘛

22:17.900 --> 22:19.900
是不是直接跳过

22:19.900 --> 22:23.900
跳过整颗指数

22:23.900 --> 22:24.900
对吧

22:24.900 --> 22:29.420
跳过整颗指数的这个beginwork

22:29.420 --> 22:30.420
看到没有

22:30.420 --> 22:31.420
这其实也解释了什么呢

22:31.420 --> 22:33.420
解释了为什么react

22:33.420 --> 22:34.420
它每次更新

22:34.420 --> 22:36.420
它都要生成一颗

22:36.420 --> 22:38.420
完整的这个fiberload

22:38.420 --> 22:39.420
fibertree

22:39.420 --> 22:44.890
但是它性能并不差的这个原因

22:44.890 --> 22:47.890
这其实也解释了

22:47.890 --> 22:48.890
为什么

22:48.890 --> 22:50.890
这个每次

22:51.890 --> 22:53.890
每次react更新

22:53.890 --> 22:56.890
都会生成一颗

22:56.890 --> 23:00.890
完整的这个fibertree

23:00.890 --> 23:05.890
但是性能上并不差的原因

23:05.890 --> 23:08.890
并不差的原因

23:08.890 --> 23:09.890
OK

23:09.890 --> 23:10.890
它内部的话

23:10.890 --> 23:12.890
会有这么一些优化手段

23:12.890 --> 23:14.890
在里面

23:14.890 --> 23:16.890
这是关于这个第一次判断

23:16.890 --> 23:17.890
还有就是你注意这个

23:17.890 --> 23:19.890
第一次判断它是什么呢

23:19.890 --> 23:20.890
就是要当

23:20.890 --> 23:21.890
这个上面我们不是说了

23:21.890 --> 23:22.890
四个条件吗

23:22.890 --> 23:23.890
对不对

23:23.890 --> 23:24.890
四个条件

23:24.890 --> 23:26.890
这四个条件必须都要满足

23:26.890 --> 23:27.890
这边

23:27.890 --> 23:29.890
以上条件都满足

23:29.890 --> 23:31.890
我把这个给你加粗

23:31.890 --> 23:32.890
它必须都满足

23:32.890 --> 23:33.890
不是说

23:33.890 --> 23:35.890
就是满足其中一个就行了

23:35.890 --> 23:38.890
都满足它才会命中这个build out

23:38.890 --> 23:39.890
这是第一次

23:39.890 --> 23:40.890
在这边

23:40.890 --> 23:41.890
第一次

23:41.890 --> 23:43.890
然后如果没有命中呢

23:43.890 --> 23:44.890
我们刚才是不是命中

23:44.890 --> 23:45.890
命中人家走下来

23:45.890 --> 23:47.890
下来人家这边看这个优化程度

23:47.890 --> 23:48.890
对不对

23:48.890 --> 23:49.890
优化程度高

23:49.890 --> 23:50.890
跳过指数的beginwork

23:50.890 --> 23:51.890
否则的话

23:51.890 --> 23:53.890
复用指数的这个fabernode

23:53.890 --> 23:54.890
如果没有命中

23:54.890 --> 23:56.890
没有命中人家走这边

23:56.890 --> 23:57.890
走这边的话

23:57.890 --> 23:58.890
根据这个web tag

23:58.890 --> 23:59.890
区别对待

23:59.890 --> 24:00.890
然后接下来这边

24:00.890 --> 24:02.890
是不是还会给你第二次机会

24:02.890 --> 24:03.890
对不对

24:03.890 --> 24:04.890
说接下来这边

24:04.890 --> 24:06.890
第二次判断

24:06.890 --> 24:08.890
如果第一次

24:08.890 --> 24:10.890
没有命中

24:10.890 --> 24:11.890
build out

24:11.890 --> 24:12.890
撤离

24:12.890 --> 24:14.890
然后则会什么呢

24:14.890 --> 24:17.890
则会根据这个target

24:17.890 --> 24:19.890
target的这个不同

24:19.890 --> 24:21.890
然后进入

24:21.890 --> 24:24.890
不同target

24:24.890 --> 24:27.890
就进入这个不同的这个处理逻辑

24:27.890 --> 24:30.890
进入不同的处理逻辑

24:30.890 --> 24:32.890
对不对

24:32.890 --> 24:34.890
之后还会

24:34.890 --> 24:37.890
再进行

24:37.890 --> 24:40.890
第二次的这个

24:40.890 --> 24:41.890
这个什么呢

24:41.890 --> 24:43.890
是否能够复用的判断

24:43.890 --> 24:47.890
还会进行第二次的这个判断

24:47.890 --> 24:48.890
那第二次的话

24:48.890 --> 24:52.840
它会有两种可能

24:52.840 --> 24:54.840
第二次

24:54.840 --> 24:57.840
第二次判断的时候

24:57.840 --> 25:04.280
会有两种命中的可能

25:04.280 --> 25:05.280
那两种呢

25:05.280 --> 25:07.280
第一种的话是开发者

25:07.280 --> 25:12.280
使用的性能优化的这个API

25:12.280 --> 25:13.280
然后第二种是什么

25:13.280 --> 25:16.280
第二种是虽然有更新

25:16.280 --> 25:17.280
你有更新

25:17.280 --> 25:21.280
这是state没有变化

25:21.280 --> 25:22.280
对吧

25:22.280 --> 25:23.280
我有更新

25:23.280 --> 25:24.280
关于有更新

25:24.280 --> 25:25.280
但是我state没有变化

25:25.280 --> 25:26.280
你回忆一下

25:26.280 --> 25:28.280
我们上节可举的那个例子

25:28.280 --> 25:29.280
我这边的话

25:29.280 --> 25:30.280
就是后面的话

25:30.280 --> 25:31.280
是不是都是更新成一

25:31.280 --> 25:32.280
对不对

25:32.280 --> 25:34.280
我这边就直接写死了

25:34.280 --> 25:35.280
都是更新成一

25:35.280 --> 25:36.280
那你这边的这个state

25:36.280 --> 25:37.280
是不是没有变化

25:37.280 --> 25:38.280
对吧

25:38.280 --> 25:40.280
所以它命中了这个build out

25:40.280 --> 25:41.280
好

25:41.280 --> 25:42.280
来我们这边

25:42.280 --> 25:43.280
一个一个来看

25:43.280 --> 25:45.280
首先第一个

25:45.280 --> 25:48.280
是开发者使用的性能优化API

25:48.280 --> 25:49.280
这个是第二个

25:49.280 --> 25:54.340
好

25:54.340 --> 25:55.340
我们首先先看第一个

25:55.340 --> 25:56.340
好

25:56.340 --> 25:57.340
第一个的话这边

25:57.340 --> 26:00.100
这边的话

26:00.100 --> 26:02.100
开发者在这个使用

26:02.100 --> 26:04.100
性能优化API的背后

26:04.100 --> 26:05.100
它的实质是什么呢

26:05.100 --> 26:06.100
实质的话

26:06.100 --> 26:08.100
实际上它是更改

26:08.100 --> 26:10.100
就是命中build out策略的

26:10.100 --> 26:11.100
这个条件

26:11.100 --> 26:13.100
什么条件呢

26:13.100 --> 26:14.100
你回忆一下

26:14.100 --> 26:15.100
就是在第一次

26:15.100 --> 26:19.100
在第一次判断的时候

26:19.100 --> 26:20.100
这个默认

26:20.100 --> 26:21.100
是对什么

26:21.100 --> 26:23.100
是对这个props

26:23.100 --> 26:27.100
进行全等比较

26:27.100 --> 26:28.100
对不对

26:28.100 --> 26:29.100
你看我们这边

26:29.100 --> 26:30.100
是不是进行一个

26:30.100 --> 26:31.100
这个全等比较

26:31.100 --> 26:33.100
你要满足这个条件的话

26:33.100 --> 26:36.100
实际上是比较困难的

26:36.100 --> 26:38.100
要满足

26:38.100 --> 26:40.100
这个条件

26:40.100 --> 26:45.100
实际上是比较困难的

26:45.100 --> 26:46.100
OK

26:46.100 --> 26:48.100
那这个性能优化

26:48.100 --> 26:52.100
这个API的这个工作原理

26:52.100 --> 26:54.100
它是干什么的呢

26:54.100 --> 26:58.100
主要就是改写

26:58.100 --> 27:00.100
这个判断条件

27:00.100 --> 27:03.250
OK

27:03.250 --> 27:04.250
它直接把它改成什么呢

27:04.250 --> 27:06.250
直接把它改成全比较

27:06.250 --> 27:08.250
改成全比较

27:08.250 --> 27:09.250
我们举个例子

27:09.250 --> 27:10.250
比如什么呢

27:10.250 --> 27:14.250
比如这个react.memo

27:14.250 --> 27:16.250
这个我们之前讲过的

27:16.250 --> 27:17.250
对不对

27:17.250 --> 27:18.250
你通过这个API

27:18.250 --> 27:19.250
创建的这个fc

27:19.250 --> 27:22.250
它对应了这个fiberload的这个target

27:22.250 --> 27:23.250
为什么呢

27:23.250 --> 27:25.250
为这个memo component

27:25.250 --> 27:27.250
通过

27:27.250 --> 27:30.750
改API

27:30.750 --> 27:33.750
创建的这个fc

27:33.750 --> 27:36.750
对应的这个target

27:36.750 --> 27:38.750
就fiberload

27:38.750 --> 27:41.750
fiberload.target

27:41.750 --> 27:42.750
为什么呢

27:42.750 --> 27:44.750
为这个memo

27:44.750 --> 27:47.750
memo component

27:47.750 --> 27:49.750
它在这个beginwork

27:49.750 --> 27:51.750
在beginwork中

27:51.750 --> 27:53.750
然后对应的这个

27:53.750 --> 27:56.750
对应的这个处理逻辑

27:56.750 --> 27:58.750
乳下

27:58.750 --> 28:01.750
我们来看一下

28:01.750 --> 28:03.750
把这儿拿过来

28:03.750 --> 28:08.940
这边

28:08.940 --> 28:10.940
这边是它对应的这个处理逻辑

28:10.940 --> 28:12.940
你让它这边就变成了什么呢

28:12.940 --> 28:15.940
它这边就变成了一个这个钱比较

28:15.940 --> 28:16.940
可不可以啊

28:16.940 --> 28:18.940
它这边就变成了个钱比较

28:18.940 --> 28:20.940
那你这边让它的整个这个

28:20.940 --> 28:22.940
是否命中了这个条件

28:22.940 --> 28:24.940
就变成了乳下

28:24.940 --> 28:30.320
因此是否命中

28:30.320 --> 28:34.320
build out策略的这个条件

28:34.320 --> 28:36.320
就变成了

28:36.320 --> 28:39.320
乳下三个

28:39.320 --> 28:40.320
哪三个呢

28:40.320 --> 28:41.320
首先第一个

28:41.320 --> 28:43.320
不存在更新

28:43.320 --> 28:44.320
第二个

28:44.320 --> 28:47.320
经过比较

28:47.320 --> 28:48.320
经过比较后

28:48.320 --> 28:50.320
这个props

28:50.320 --> 28:53.270
没有变化

28:53.270 --> 28:54.270
OK

28:54.270 --> 28:55.270
所以这边的比较呢

28:55.270 --> 28:59.420
它是一个钱比较

28:59.420 --> 29:00.420
它是个钱比较

29:00.420 --> 29:01.420
还有什么呢

29:01.420 --> 29:03.420
还有就是这边关于这个Ref

29:03.420 --> 29:04.420
可不可以啊

29:04.420 --> 29:08.370
这边有个Ref的这个判断

29:08.370 --> 29:10.370
它这边如果Ref不变

29:10.370 --> 29:12.370
这边你如果这个props

29:12.370 --> 29:13.370
比较没有变化

29:13.370 --> 29:14.370
那并且什么呢

29:14.370 --> 29:15.370
Ref是不变

29:15.370 --> 29:16.370
它就会命中

29:16.370 --> 29:18.370
所以这边第三个就是什么呢

29:18.370 --> 29:22.370
Ref没有发生改变

29:22.370 --> 29:23.370
OK

29:23.370 --> 29:26.370
如果同时满足

29:26.370 --> 29:30.370
上面这三个条件

29:30.370 --> 29:35.370
就会命中这个build out

29:35.370 --> 29:37.370
命中这个build out策略

29:37.370 --> 29:38.370
你看它这边执行什么

29:38.370 --> 29:39.370
是build out

29:39.370 --> 29:41.370
I'm already finished work

29:41.370 --> 29:43.370
对不对

29:43.370 --> 29:47.370
执行这个方法

29:47.370 --> 29:48.370
那你看这边

29:48.370 --> 29:49.370
这边的话相较于

29:49.370 --> 29:51.370
刚才我们的第一次判断

29:51.370 --> 29:52.370
那第二次判断

29:52.370 --> 29:53.370
它实际上就

29:53.370 --> 29:55.370
更加容易命中了

29:55.370 --> 29:56.370
对不对

29:56.370 --> 29:59.370
相较于第一次判断

29:59.370 --> 30:03.370
第二次判断这个props

30:03.370 --> 30:05.370
采用的是什么

30:05.370 --> 30:09.370
是不是钱比较进行判断

30:09.370 --> 30:16.370
因此能够更加容易命中

30:16.370 --> 30:18.370
这个build out

30:18.370 --> 30:19.370
OK

30:19.370 --> 30:21.370
这是关于这个react memo

30:21.370 --> 30:22.370
实际上那个

30:22.370 --> 30:24.370
那个class component

30:24.370 --> 30:25.370
实际上也是一样的

30:25.370 --> 30:27.370
class component

30:27.370 --> 30:28.370
它有个优化手段是什么呢

30:28.370 --> 30:29.370
是不是就是

30:29.370 --> 30:31.370
shadow component update

30:31.370 --> 30:34.370
或者pure component

30:34.370 --> 30:35.370
对不对

30:35.370 --> 30:36.370
它背后的话

30:36.370 --> 30:38.370
实际上也是把它改成钱比较

30:38.370 --> 30:40.370
还是改成钱比较

30:40.370 --> 30:41.370
我这边来看一下

30:41.370 --> 30:42.370
你看这边

30:42.370 --> 30:44.370
shadow equal

30:44.370 --> 30:46.370
钱比较

30:46.370 --> 30:51.830
例如再来看个例子

30:51.830 --> 30:57.210
比如class component

30:57.210 --> 31:00.210
class component

31:00.210 --> 31:01.210
内组件

31:01.210 --> 31:04.210
内组件的优化手段

31:04.210 --> 31:05.210
优化手段

31:05.210 --> 31:07.210
经常会

31:07.210 --> 31:08.210
涉及到什么

31:08.210 --> 31:13.210
涉及到pure component

31:13.210 --> 31:15.210
你可以用这个

31:15.210 --> 31:16.210
对吧

31:16.210 --> 31:17.210
或者什么呢

31:17.210 --> 31:18.210
或者用这个

31:18.210 --> 31:20.210
shadow

31:20.210 --> 31:24.540
shadow component

31:24.540 --> 31:26.540
shadow component

31:26.540 --> 31:28.540
这个update

31:28.540 --> 31:29.540
我们在讲的时候

31:29.540 --> 31:30.540
我们就说这个pure component

31:30.540 --> 31:31.540
背后做的事情

31:31.540 --> 31:32.540
实际上就是在

31:32.540 --> 31:33.540
干嘛

31:33.540 --> 31:34.540
就在做它

31:34.540 --> 31:35.540
就在判断

31:35.540 --> 31:36.540
是否这边要更新

31:36.540 --> 31:37.540
对不对

31:37.540 --> 31:39.540
那接下来再往下面走呢

31:39.540 --> 31:40.540
再往下面走

31:40.540 --> 31:41.540
实际上就是

31:41.540 --> 31:42.540
你这边在比较的时候

31:42.540 --> 31:43.540
它做的是一个钱比较

31:43.540 --> 31:44.540
钱比较

31:44.540 --> 31:45.540
然后加这边

31:45.540 --> 31:46.540
它命中了这个

31:46.540 --> 31:47.540
build out策略

31:47.540 --> 31:49.540
来我们这边来看一下

31:51.540 --> 31:54.540
这两个api

31:54.540 --> 31:56.540
实际上

31:56.540 --> 31:57.540
背后

31:57.540 --> 31:59.540
也是

31:59.540 --> 32:00.540
优化什么呢

32:00.540 --> 32:02.540
优化这个命中

32:02.540 --> 32:06.540
build out策略

32:06.540 --> 32:08.540
就背后的话也是在

32:08.540 --> 32:10.540
也是在这个优化

32:10.540 --> 32:11.540
这个命中

32:11.540 --> 32:15.540
build out策略的方式

32:15.540 --> 32:16.540
ok

32:16.540 --> 32:17.540
它在这个

32:17.540 --> 32:18.540
class component的

32:18.540 --> 32:19.540
这个beginwork下面

32:19.540 --> 32:20.540
它有这样子的代码

32:20.540 --> 32:26.920
在这个class component

32:27.920 --> 32:29.920
component的这个beginwork

32:30.920 --> 32:32.920
beginwork

32:33.920 --> 32:35.920
beginwork方法中

32:35.920 --> 32:37.920
有如下的代码

32:37.920 --> 32:42.280
有这个

32:42.280 --> 32:47.600
这边

32:47.600 --> 32:48.600
它这边

32:48.600 --> 32:49.600
这边是不是就是

32:49.600 --> 32:50.600
走的是build out

32:50.600 --> 32:51.600
对不对

32:51.600 --> 32:52.600
然后加这边

32:52.600 --> 32:53.600
这边它会有一个什么

32:53.600 --> 32:54.600
它会有一个这个

32:54.600 --> 32:55.600
should update

32:55.600 --> 32:57.600
会有这么一个变量

32:57.600 --> 32:58.600
好

32:58.600 --> 32:59.600
这个变量

32:59.600 --> 33:02.420
这个变量

33:02.420 --> 33:03.420
这个变量

33:03.420 --> 33:04.420
受什么呢

33:04.420 --> 33:05.420
这个方法

33:09.420 --> 33:10.420
受一个方法

33:10.420 --> 33:12.420
这个方法叫做这个check

33:12.420 --> 33:13.420
check

33:13.420 --> 33:14.420
然后should

33:14.420 --> 33:16.420
然后component

33:18.420 --> 33:19.420
component update

33:19.420 --> 33:21.420
在这个react研码里面

33:21.420 --> 33:23.420
这个方法名这些都很长

33:23.420 --> 33:24.420
都很长

33:24.420 --> 33:25.420
它有个好处

33:25.420 --> 33:27.420
好处就是你看它的方法名

33:27.420 --> 33:28.420
你大致就知道

33:28.420 --> 33:29.420
这个方法在做什么

33:29.420 --> 33:30.420
对吧

33:30.420 --> 33:32.420
但就是比较长

33:32.420 --> 33:36.310
它会受这个方法的影响

33:36.310 --> 33:37.310
来我们来看一下

33:37.310 --> 33:39.310
这个方法的相关代码

33:39.310 --> 33:41.310
这边把它拿过来

33:41.310 --> 33:48.140
这边把它拿过来

33:48.140 --> 33:50.140
然后这里

33:50.140 --> 33:51.140
这边的话

33:51.140 --> 33:52.140
你看它这里

33:52.140 --> 33:53.140
这里的话

33:53.140 --> 33:54.140
它也是做一个什么

33:54.140 --> 33:55.140
是不是也是做一个

33:55.140 --> 33:56.140
这个钱比较

33:56.140 --> 33:57.140
对不对

33:57.140 --> 33:59.140
如果是这个pure component

33:59.140 --> 34:00.140
这边就做一个什么

34:00.140 --> 34:01.140
你看

34:01.140 --> 34:02.140
shadow equal

34:02.140 --> 34:03.140
对不对

34:03.140 --> 34:06.460
也是做一个这个钱比较

34:06.460 --> 34:07.460
通过

34:07.460 --> 34:08.460
上面的代码

34:08.460 --> 34:13.240
我们可以看出

34:13.240 --> 34:14.240
可以看出什么呢

34:14.240 --> 34:16.240
就是你的这个shadow

34:18.240 --> 34:19.240
shadow update

34:19.240 --> 34:20.240
应该这么说

34:20.240 --> 34:22.240
就是这个pure component

34:27.370 --> 34:28.370
这边

34:28.370 --> 34:30.370
pure component

34:30.370 --> 34:31.370
通过什么呢

34:31.370 --> 34:33.370
通过钱比较

34:33.370 --> 34:35.370
来决定

34:35.370 --> 34:36.370
来决定什么字

34:36.370 --> 34:40.370
来决定这个shadow update的字

34:41.370 --> 34:44.370
来决定这个shadow update的字

34:44.370 --> 34:48.370
来决定shadow update的字

34:48.370 --> 34:52.370
而这个shadow update的字

34:52.370 --> 34:53.370
又什么呢

34:53.370 --> 34:55.370
又影响了

34:55.370 --> 34:57.370
又决定了

34:57.370 --> 34:58.370
又决定了

34:58.370 --> 35:01.370
是否能够命中

35:01.370 --> 35:03.370
这个build out策略

35:04.370 --> 35:05.370
对不对

35:05.370 --> 35:06.370
说到背后的话

35:06.370 --> 35:07.370
实际上就是这里

35:07.370 --> 35:08.370
这边的话

35:08.370 --> 35:09.370
进行的是一个钱比较

35:09.370 --> 35:10.370
OK

35:10.370 --> 35:13.370
这是首先关于这个API

35:13.370 --> 35:14.370
就是开发者用了

35:14.370 --> 35:16.370
这个性能优化的这个API

35:16.370 --> 35:17.370
你要知道他背后

35:17.370 --> 35:19.370
实际上在做什么事情

35:19.370 --> 35:21.370
他背后的实际上就是改写

35:21.370 --> 35:23.370
命中这个build out策略的

35:23.370 --> 35:25.370
这么一个判断条件

35:25.370 --> 35:27.370
让他就是命中这个build out

35:27.370 --> 35:29.370
更加容易了

35:29.370 --> 35:30.370
对吧

35:30.370 --> 35:31.370
而第二个

35:31.370 --> 35:33.370
第二个的话是虽然有更新

35:33.370 --> 35:35.370
但是你的这个state

35:35.370 --> 35:36.370
没有变化

35:36.370 --> 35:41.790
我们在那个

35:41.790 --> 35:42.790
第一次判断的时候

35:42.790 --> 35:43.790
大家还记不记得

35:43.790 --> 35:45.790
这个第四个条件

35:45.790 --> 35:47.790
第四个条件

35:47.790 --> 35:48.790
第四个条件是什么

35:48.790 --> 35:49.790
第四个条件是不是

35:49.790 --> 35:50.790
这个当前的这个fiber load

35:50.790 --> 35:52.790
没有更新发生

35:52.790 --> 35:53.790
对不对

35:53.790 --> 35:54.790
在第一次

35:55.790 --> 35:57.790
在第一次进行

35:57.790 --> 35:59.790
判断的时候

36:01.790 --> 36:03.790
其中有一个

36:04.790 --> 36:06.790
有一个条件

36:06.790 --> 36:07.790
是什么呢

36:07.790 --> 36:09.790
是当前的这个fiber load

36:11.790 --> 36:13.790
没有更新发生

36:13.790 --> 36:15.790
那你没有更新的话

36:15.790 --> 36:16.790
肯定就是什么

36:16.790 --> 36:18.790
你的这个state就不会发生改变

36:18.790 --> 36:19.790
对不对

36:19.790 --> 36:20.790
不过还有

36:20.790 --> 36:21.790
这边的话

36:21.790 --> 36:23.790
没有更新就

36:23.790 --> 36:26.790
意味着state

36:26.790 --> 36:28.790
没有改变

36:28.790 --> 36:31.790
但是还有一种情况

36:31.790 --> 36:34.620
什么情况呢

36:34.620 --> 36:37.620
那就是有更新

36:37.620 --> 36:41.620
但是更新前后

36:41.620 --> 36:44.620
计算出来的这个state

36:45.620 --> 36:47.620
仍然没有变化

36:47.620 --> 36:52.300
仍然没有变化

36:52.300 --> 36:54.300
那么这种情况下的话

36:54.300 --> 36:55.300
它也是可能就是

36:55.300 --> 36:57.300
会命中这个billout策略

36:59.300 --> 37:00.300
比如说在这里

37:00.300 --> 37:02.300
比如这个fc

37:02.300 --> 37:03.300
例如

37:03.300 --> 37:05.300
在这个fc

37:05.300 --> 37:07.300
的这个beginwork

37:07.300 --> 37:10.670
beginwork中

37:10.670 --> 37:12.670
然后有如下一段逻辑

37:12.670 --> 37:16.670
如下一段逻辑

37:16.670 --> 37:18.670
我们这边来看一下

37:18.670 --> 37:19.670
我们说了就是

37:19.670 --> 37:21.670
之前我们讲那个hook的时候

37:21.670 --> 37:22.670
我们说过

37:22.670 --> 37:23.670
你这边每个hook的话

37:23.670 --> 37:24.670
那这边的话

37:24.670 --> 37:25.670
会有一个什么方法

37:25.670 --> 37:27.670
是会有一个这个叫做

37:27.670 --> 37:30.670
叫做那个render with hook

37:30.670 --> 37:31.670
对不对

37:31.670 --> 37:32.670
render with hook

37:32.670 --> 37:33.670
然后既然它方法类的话

37:33.670 --> 37:34.670
它会执行这个

37:34.670 --> 37:36.670
组建render的这个逻辑

37:36.670 --> 37:37.670
其中它这边的话

37:37.670 --> 37:38.670
会执行这个方法

37:38.670 --> 37:40.670
叫做update function component

37:40.670 --> 37:42.670
会执行这个方法

37:42.670 --> 37:43.670
这个方法的话

37:43.670 --> 37:44.670
你看这一块

37:44.670 --> 37:45.670
这一块

37:45.670 --> 37:46.670
这一块的话

37:46.670 --> 37:47.670
就是在判断

37:47.670 --> 37:50.670
是否能够命中这个build out策略

37:50.670 --> 37:52.670
判断能否这个命中

37:52.670 --> 37:54.670
那这边是否能够命中的话

37:54.670 --> 37:55.670
取决于什么

37:55.670 --> 37:56.670
是否取决于它

37:56.670 --> 37:57.670
对不对

37:57.670 --> 37:58.670
你这边应该看得懂

37:58.670 --> 37:59.670
current不等于 not

37:59.670 --> 38:01.670
current不等于 not

38:01.670 --> 38:02.670
说明什么

38:02.670 --> 38:03.670
说明你当前的话

38:03.670 --> 38:04.670
是有这个

38:04.670 --> 38:05.670
当前的这个fiber的

38:05.670 --> 38:06.670
对吧

38:06.670 --> 38:07.670
然后接下来这边

38:07.670 --> 38:08.670
是否取决于这个

38:08.670 --> 38:10.670
did receive update

38:10.670 --> 38:11.670
对不对

38:11.670 --> 38:15.050
在上面的代码中

38:15.050 --> 38:18.050
上面的代码中

38:18.050 --> 38:21.050
是否能够命中

38:21.050 --> 38:24.050
这个build out策略

38:24.050 --> 38:25.050
取决于什么呢

38:25.050 --> 38:27.050
取决于它

38:27.050 --> 38:28.050
对不对

38:28.050 --> 38:29.050
它的值决定你

38:29.050 --> 38:30.050
是否能够命中

38:30.050 --> 38:31.050
那接下来

38:31.050 --> 38:32.050
这个值是如何决定的

38:32.050 --> 38:34.050
接下来

38:34.050 --> 38:36.050
我们来看一下

38:36.050 --> 38:41.050
这个值是如何决定的

38:41.050 --> 38:43.050
这边我把这个

38:43.050 --> 38:44.050
对呢

38:44.050 --> 38:49.880
这个代码片段拿过来

38:49.880 --> 38:50.880
你看这里

38:50.880 --> 38:51.880
这里的话

38:51.880 --> 38:52.880
比较你的新的state

38:52.880 --> 38:54.880
和你之前这个 hook 上面

38:54.880 --> 38:56.880
所存储的这个state

38:56.880 --> 38:57.880
比较两个什么

38:57.880 --> 38:58.880
是比较两个

38:58.880 --> 39:00.880
是否这个相同

39:00.880 --> 39:01.880
对不对

39:01.880 --> 39:02.880
大家根据什么

39:02.880 --> 39:03.880
根据这个新的状态

39:03.880 --> 39:04.880
和你以前的状态

39:04.880 --> 39:05.880
进行比较

39:05.880 --> 39:06.880
如果状态的话

39:06.880 --> 39:09.880
没有发生这个改变

39:09.880 --> 39:10.880
那我这边就干嘛

39:10.880 --> 39:11.880
我这边是不是就命中

39:11.880 --> 39:13.880
这个build out策略

39:13.880 --> 39:14.880
对不对

39:14.880 --> 39:15.880
就我们刚才这边说的

39:15.880 --> 39:16.880
还有一种情况

39:16.880 --> 39:17.880
就是它虽然有更新

39:17.880 --> 39:19.880
但是更新前后

39:19.880 --> 39:21.880
计算出来的这个state

39:21.880 --> 39:23.880
仍然没有变化

39:23.880 --> 39:25.880
那此时

39:27.880 --> 39:33.880
就也会命中build out策略

39:33.880 --> 39:34.880
对不对

39:34.880 --> 39:36.880
你看这边

39:36.880 --> 39:37.880
新的状态

39:37.880 --> 39:38.880
new state

39:38.880 --> 39:39.880
和你的这个 hook

39:39.880 --> 39:41.880
点这个memo state

39:41.880 --> 39:42.880
两个进行比较

39:42.880 --> 39:43.880
比较之后

39:43.880 --> 39:44.880
然后加这边

39:44.880 --> 39:46.880
根据比较这个结果

39:46.880 --> 39:48.880
来去这个决定

39:48.880 --> 39:50.880
是否命中build out策略

39:50.880 --> 39:51.880
如果没有命中

39:51.880 --> 39:52.880
没有命中的话

39:52.880 --> 39:53.880
没关系

39:53.880 --> 39:54.880
没有命中这边就进入什么

39:54.880 --> 39:56.880
就进入reconcel的这个流程

39:56.880 --> 39:57.880
对吧

39:57.880 --> 39:59.880
进入reconcel流程

39:59.880 --> 40:00.880
ok

40:00.880 --> 40:03.880
这就是关于这个第二次判断

40:03.880 --> 40:04.880
第二次判断

40:04.880 --> 40:05.880
主要就是这两个

40:05.880 --> 40:06.880
你要么就是

40:06.880 --> 40:08.880
使用了这个性能优化一篇

40:08.880 --> 40:09.880
要么的话

40:09.880 --> 40:11.880
就是你更新后你的state

40:11.880 --> 40:12.880
没有发生变化

40:12.880 --> 40:14.880
第二次了就是在这里

40:14.880 --> 40:15.880
在这里

40:15.880 --> 40:16.880
如果命中了

40:16.880 --> 40:18.880
那接下来就和之前是一样的

40:18.880 --> 40:19.880
如果没有命中

40:19.880 --> 40:20.880
没有命中后面就是走

40:20.880 --> 40:21.880
走你的什么

40:21.880 --> 40:22.880
reconcel

40:22.880 --> 40:23.880
对吧

40:23.880 --> 40:25.880
你看这边这个带嘛

40:25.880 --> 40:27.880
没有命中

40:27.880 --> 40:30.880
没有命中这边是不是走你的这个reconcel

40:30.880 --> 40:31.880
对不对

40:31.880 --> 40:32.880
ok

40:32.880 --> 40:35.880
这就是关于整个react中

40:35.880 --> 40:37.880
这个build out策略

40:37.880 --> 40:39.880
它的这种两次判断

40:39.880 --> 40:40.880
好

40:40.880 --> 40:42.880
来我们来看一下这道题

40:42.880 --> 40:44.880
谈一谈react中

40:44.880 --> 40:45.880
build out策略

40:45.880 --> 40:48.880
那你这边其实就可以根据什么呢

40:48.880 --> 40:51.880
根据我这个画的这个图

40:51.880 --> 40:52.880
来讲一讲

40:52.880 --> 40:53.880
对吧

40:53.880 --> 40:56.880
首先它这边是发生在update阶段

40:56.880 --> 40:57.880
mount的话它是不存在的

40:57.880 --> 40:58.880
对吧

40:58.880 --> 40:59.880
mount你是初次这个渲染

40:59.880 --> 41:01.880
update更新的时候

41:01.880 --> 41:02.880
更新的时候

41:02.880 --> 41:03.880
然后接下来这边有两次

41:03.880 --> 41:04.880
这边第一次

41:04.880 --> 41:06.880
有些什么样的条件

41:06.880 --> 41:07.880
好

41:07.880 --> 41:08.880
然后如果命中了

41:08.880 --> 41:09.880
对吧

41:09.880 --> 41:10.880
然后加这边

41:10.880 --> 41:11.880
它会看你的优化程度

41:11.880 --> 41:13.880
优化程度根据高和低

41:13.880 --> 41:14.880
如果高

41:15.880 --> 41:16.880
如果低的话

41:16.880 --> 41:18.880
就附用指数的fabre load

41:18.880 --> 41:19.880
好

41:19.880 --> 41:20.880
如果第一次没有命中

41:20.880 --> 41:21.880
然后加过来

41:21.880 --> 41:23.880
过来根据这个web tag

41:23.880 --> 41:24.880
然后接下来

41:24.880 --> 41:25.880
根据这个不同

41:25.880 --> 41:26.880
进行不同处理之后

41:26.880 --> 41:27.880
然后加这边是不是

41:27.880 --> 41:29.880
还会再判断一次

41:29.880 --> 41:30.880
对吧

41:30.880 --> 41:31.880
再判断一次的话

41:31.880 --> 41:32.880
那这边有两种可能

41:32.880 --> 41:33.880
一种的话

41:33.880 --> 41:34.880
是这个开发者

41:34.880 --> 41:36.880
使用了这个新能优化的这种API

41:36.880 --> 41:37.880
第二种的话

41:37.880 --> 41:38.880
就是你这边

41:38.880 --> 41:39.880
你的这个更新

41:39.880 --> 41:41.880
我state算出来

41:41.880 --> 41:42.880
它没有改变

41:42.880 --> 41:43.880
那什么也有可能

41:43.880 --> 41:44.880
会命中

41:44.880 --> 41:45.880
对不对

41:45.880 --> 41:46.880
OK

41:46.880 --> 41:47.880
好我们这边呢

41:47.880 --> 41:48.880
把这个参考单

41:48.880 --> 41:54.620
把它过来

41:54.620 --> 41:55.620
放到这里

41:55.620 --> 41:56.620
啊这边

41:56.620 --> 41:57.620
两次判断

41:57.620 --> 41:58.620
第一次判断

41:58.620 --> 41:59.620
OK这是第一次判断

41:59.620 --> 42:00.620
这边第一次判断

42:00.620 --> 42:02.620
它这边是以上条件都满足

42:02.620 --> 42:03.620
好

42:03.620 --> 42:04.620
然后加这边第二次判断

42:04.620 --> 42:05.620
第二次判断的话

42:05.620 --> 42:06.620
然后有两种可能性

42:06.620 --> 42:08.620
一种是使用这个新能优化API

42:08.620 --> 42:09.620
第二种的话

42:09.620 --> 42:10.620
是虽然有更新

42:10.620 --> 42:11.620
但是state

42:11.620 --> 42:13.620
没有发生变化

42:13.620 --> 42:14.620
好不好

42:14.620 --> 42:15.620
OK

42:15.620 --> 42:17.620
这就是关于这个

42:17.620 --> 42:18.620
Bailout

42:18.620 --> 42:20.620
这种新能优化这种策略

42:20.620 --> 42:21.620
大家下来的话

42:21.620 --> 42:22.620
可以再看一下

42:22.620 --> 42:23.620
OK

42:23.620 --> 42:25.620
这期课的话就到这里

42:25.620 --> 42:26.620
再见

