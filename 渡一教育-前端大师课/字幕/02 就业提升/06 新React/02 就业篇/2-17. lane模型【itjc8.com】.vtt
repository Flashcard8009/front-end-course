WEBVTT

00:00.000 --> 00:03.640
OK 这节课的话 我们来看一下关于这个内模型

00:04.640 --> 00:09.640
好 这边的话有道面识题 他问你是否了解过这个react中的这个内模型

00:10.240 --> 00:17.280
还有就是为什么要从之前的这个expiration time 啊 以前是这个模型转为这个内模型

00:17.880 --> 00:21.480
OK 所以说我们这节课的话 我们就来介绍一下关于这个内模型

00:22.000 --> 00:28.880
我们主要从这么几个方面来介绍 首先第一个就是关于这个react和什么呢 和这个scheduler

00:30.640 --> 00:31.520
scheduler

00:33.000 --> 00:40.000
scheduler 啊 优先级的这个介绍 好 第二个就是什么呢 第二个就是这个expiration

00:41.980 --> 00:45.620
expiration time啊 就这个这个模型

00:47.300 --> 00:51.100
好 第三个的话就是我们这边要介绍的内模型

00:51.860 --> 00:57.700
OK 我们从这三个点啊 分别来给大家介绍一下啊 循序见尽的啊 一点一点来看

00:58.420 --> 00:59.700
首先呢 我们来先看第一个

01:00.540 --> 01:05.980
react和scheduler 优先级啊 这个是优先级这个介绍

01:07.860 --> 01:14.500
ok 好 我们之前的话是不是已经介绍过scheduler了 对吧 啊 之前我们已经

01:15.860 --> 01:27.500
已经介绍过scheduler啊 那我们说过就是这个react团队的话 他是把这个就是打算把这个scheduler什么进行独立发布的

01:28.340 --> 01:32.100
对吧react团队是打算

01:33.700 --> 01:34.940
将这个scheduler

01:36.340 --> 01:48.260
scheduler进行独立这个发布啊 那么在这个react内部的话 他还会有一个力度更细的优先级算法 这个的话就是内模型

01:50.060 --> 01:56.020
在react内部还会有一个什么呢 还会有一个力度

01:56.260 --> 02:03.860
更细的 更细的这个优先级算法 这个就是内模型

02:06.620 --> 02:15.740
啊 那我们首先看一下就是这两套模型他们的一个转换方式啊 接下来我们来看一下这个两套模型

02:16.620 --> 02:17.820
两套优先级模型

02:19.500 --> 02:21.100
的一个转换

02:24.060 --> 02:29.340
啊 首先你要搞清楚啊 为什么会有两套 因为这个scheduler他是要打算是独立发布的

02:30.060 --> 02:34.940
对不对 他是要独立发布的 所以他这边让他和那个react他并不是说就是共通的

02:35.340 --> 02:39.900
所以这边在react内部的话他还会维护一个这个自己的这个优先级的这个算法

02:40.300 --> 02:46.380
那回头的话他会和什么呢 和会和这个scheduler里面的优先级他会有一个这个可以转换的这种关系

02:46.940 --> 02:47.180
ok

02:48.700 --> 02:50.060
啊 在这个scheduler

02:51.260 --> 02:55.100
在scheduler内部拥有什么呢拥有

02:56.060 --> 03:00.380
拥有五种啊 拥有五种这个优先级

03:01.660 --> 03:02.380
啊 这五种

03:03.420 --> 03:04.060
我把他拿过来

03:07.220 --> 03:07.540
这边

03:08.580 --> 03:13.620
你看一下啊 这个这个第一个不算啊 第一个是no这个purity啊 这个是0

03:14.020 --> 03:18.740
那加这边后面 你看后面呢 是不是一共有五种 这个呢是immediate

03:19.460 --> 03:23.380
啊purity 然后接下来这个是idol这个purity

03:23.700 --> 03:26.100
ok 那么作为一个独立的包

03:26.980 --> 03:29.940
他要考虑到什么呢 他要考虑到这个通用性

03:30.660 --> 03:32.100
对不对 作为

03:35.310 --> 03:35.790
作为

03:37.870 --> 03:39.950
作为一个独立的包

03:41.390 --> 03:44.990
需要考虑到什么呢 需要考虑到通用性

03:45.870 --> 03:47.550
啊 那么这个scheduler

03:50.110 --> 03:50.910
scheduler

03:52.590 --> 03:55.550
scheduler和这个react

03:56.030 --> 03:58.190
他们的这个优先级啊 并不共同

03:59.630 --> 04:00.350
优先级

04:02.430 --> 04:04.510
优先级并不共同

04:05.630 --> 04:07.870
明白吧 那在这个react内部

04:08.030 --> 04:10.510
react内部的话 他是会有四种优先级

04:11.870 --> 04:13.070
在这个react内部

04:16.830 --> 04:19.310
有四种优先级

04:20.590 --> 04:22.430
哪四种呢 啊 如下四种

04:26.100 --> 04:26.660
啊 这边

04:27.380 --> 04:28.100
把他过来

04:28.740 --> 04:33.950
啊 这里

04:34.910 --> 04:39.870
啊 你可以看一下这里 这里的话有一个discrete event priority

04:40.270 --> 04:43.470
啊 这个是continuous event priority

04:43.630 --> 04:46.750
然后还有就是default event priority idle event

04:47.070 --> 04:50.830
你可以看到这个的话 基本上是什么呢 基本上是什么和事件相关的

04:51.470 --> 04:56.990
对不对啊 由于就是在react中 他不同的这个交互对应的这个事件

04:57.310 --> 04:58.990
啊 他产生的这个update

04:59.230 --> 05:01.070
他的这个优先级是不同的

05:01.550 --> 05:04.110
啊 所以这个优先级的话 他与这个事件相关

05:04.350 --> 05:06.910
所以他也被称之为这个event priority

05:09.230 --> 05:10.030
这边 由于

05:12.510 --> 05:14.670
由于什么呢 由于react中

05:16.110 --> 05:18.430
react中 呃不同的交互

05:20.030 --> 05:23.630
不同的交互啊对应的这个事件

05:24.750 --> 05:25.230
毁掉

05:27.390 --> 05:29.390
中产生的这个

05:29.950 --> 05:30.510
update

05:31.710 --> 05:33.470
会有这个不同的优先级

05:35.310 --> 05:37.710
ok啊 因此这个优先级

05:39.390 --> 05:41.870
优先级与什么呢 与事件有关

05:43.550 --> 05:47.230
对吧 你不同类型的这个事件 他的这个优先级是不一样的啊

05:47.390 --> 05:50.110
所以他这边上也被称之为这个event priority

05:51.070 --> 05:52.350
因此 这里

05:53.150 --> 05:54.430
因此在这个react

05:55.550 --> 05:58.590
在react内部的这个优先级

05:59.870 --> 06:00.430
也被

06:01.390 --> 06:04.030
称之为什么呢 也被称之为这个event

06:04.510 --> 06:05.150
poverty

06:06.830 --> 06:07.870
poverty

06:09.550 --> 06:09.790
ok

06:10.350 --> 06:13.710
那各种这种优先级他的含义啊 各种

06:14.430 --> 06:16.030
优先级的这个含义

06:18.110 --> 06:19.070
含义 留下

06:20.510 --> 06:21.630
好 我这边我把他拿过来

06:26.780 --> 06:27.260
这里

06:27.660 --> 06:31.020
好 你看比如说第一个 第一个是discreteevent priority

06:31.180 --> 06:33.020
他对应的是啊 离散事件

06:33.420 --> 06:37.260
那比如你什么click呀 input呀这些啊 这些都是离散事件

06:37.660 --> 06:38.140
ok

06:38.380 --> 06:41.820
好 然后接下来的话 这边这个continuous

06:42.300 --> 06:44.700
啊 这个应该是叫做continuous

06:45.260 --> 06:46.620
啊 然后event priority

06:46.780 --> 06:48.300
他对应的是连续事件

06:48.540 --> 06:50.780
对啊 什么drag 然后加mouse move

06:50.940 --> 06:51.580
screw

06:51.740 --> 06:52.460
touch move

06:52.700 --> 06:53.980
好 这个呢是默认

06:54.300 --> 06:56.220
defaultevent priority

06:56.540 --> 06:57.740
啊 这个是默认的

06:57.980 --> 07:00.060
这个他是比如说通过这个计时器

07:00.620 --> 07:01.980
这个周期性出发的

07:02.460 --> 07:04.300
啊 然后这种情况下产生了这个

07:04.540 --> 07:05.020
update

07:05.260 --> 07:07.340
他不属于交互产生的update

07:07.580 --> 07:08.780
啊 所以他是默认的

07:09.020 --> 07:10.940
还有一个是idleevent priority

07:11.100 --> 07:13.180
对应的是这个空闲情况的优先级

07:13.820 --> 07:14.220
ok

07:14.460 --> 07:15.900
说在这个react内部

07:16.540 --> 07:18.460
啊 他对应了这个优先级是这个样子的

07:19.260 --> 07:21.020
那这里的话有的同学就会问了

07:21.180 --> 07:23.820
他说那这个和你讲的这个内模形有啥关系呢

07:24.140 --> 07:25.500
对吧 你刚才不是说内模形吗

07:25.500 --> 07:27.100
这边怎么又搞出来一个这个

07:27.740 --> 07:29.020
这个事件类型的啊

07:29.180 --> 07:30.860
搞出来一个这个event priority

07:31.420 --> 07:33.660
你仔细观察一下他的值

07:34.220 --> 07:34.700
同学们

07:35.340 --> 07:36.380
你仔细观察他的

07:36.780 --> 07:37.580
看一下他的值

07:37.820 --> 07:40.860
你会发现每一个event priority

07:41.020 --> 07:42.460
他对应的值就是一个什么

07:42.620 --> 07:44.060
说对应的值就是一个net

07:44.620 --> 07:45.020
对不对

07:45.020 --> 07:46.700
但具体什么是net我们一会再来说

07:46.940 --> 07:49.260
啊 但是你会发现这边每一个事件

07:49.660 --> 07:52.060
他的优先级啊每一个事件优先级

07:52.220 --> 07:54.220
对应的一个值就是一个net

07:54.700 --> 07:55.820
看到没有啊

07:57.100 --> 07:57.740
在上面

07:57.980 --> 08:01.580
在上面的代码中

08:02.860 --> 08:04.140
我们还可以

08:05.420 --> 08:06.460
观察出

08:06.700 --> 08:07.980
一件事情

08:08.220 --> 08:11.820
什么呢 就是不同级别的这个

08:11.820 --> 08:13.100
event priority

08:14.380 --> 08:16.700
对应的是什么呢

08:16.940 --> 08:19.500
对应的是不同的这个net

08:20.780 --> 08:22.060
对不对

08:22.060 --> 08:23.340
对应的是不同的net

08:23.340 --> 08:23.580
啊

08:23.580 --> 08:24.620
好

08:24.620 --> 08:27.180
那接下来的话我们这边就要来看一下

08:27.260 --> 08:28.380
转换了啊

08:28.380 --> 08:29.180
既然

08:30.220 --> 08:31.900
既然这个react

08:32.620 --> 08:34.300
与这个scheduler

08:35.580 --> 08:36.380
scheduler

08:36.380 --> 08:37.580
他们的这个优先级

08:38.140 --> 08:40.300
这并不互通对不对

08:40.300 --> 08:41.980
不互通啊那么

08:43.100 --> 08:44.540
这里就会干嘛呢

08:44.540 --> 08:48.140
就会涉及到一个转换的问题

08:50.380 --> 08:51.420
转换的问题

08:51.420 --> 08:53.500
那么整体的话他会经历两次

08:53.500 --> 08:54.620
这个两次转换

08:55.580 --> 08:56.940
整体会

08:56.940 --> 08:59.500
经历两次

08:59.500 --> 09:00.540
转换

09:00.540 --> 09:01.660
那第一次

09:01.660 --> 09:02.540
第一次是什么呢

09:02.540 --> 09:04.700
第一次是先把这个net

09:04.700 --> 09:07.180
转换为event priority

09:09.390 --> 09:12.590
首先是将net

09:12.590 --> 09:14.110
转为

09:14.110 --> 09:16.190
这个event

09:16.190 --> 09:19.810
priority

09:19.810 --> 09:20.210
ok

09:20.210 --> 09:21.330
啊当我这边只

09:21.330 --> 09:22.530
这边的转换指的是什么

09:22.530 --> 09:24.130
指的是就是把这个

09:24.130 --> 09:25.890
react的这个

09:25.890 --> 09:26.690
优先级

09:26.770 --> 09:28.690
转成这个scheduler的优先级

09:28.690 --> 09:29.890
应该这样子说

09:29.890 --> 09:30.850
应该这样子说

09:30.850 --> 09:31.570
啊

09:31.570 --> 09:32.050
这里

09:32.850 --> 09:33.570
分为什么呢

09:33.570 --> 09:34.610
分为这么两个

09:34.610 --> 09:35.970
一个是react

09:36.610 --> 09:39.890
优先级转为scheduler

09:41.650 --> 09:42.370
scheduler

09:44.530 --> 09:45.730
scheduler

09:47.410 --> 09:48.210
的优先级

09:50.300 --> 09:50.780
对吧

09:50.780 --> 09:52.540
啊另外一个的话是这个scheduler

09:54.060 --> 09:56.060
scheduler的优先级

09:56.780 --> 09:57.420
转为

09:58.620 --> 10:02.510
react的优先级

10:02.510 --> 10:04.190
这分成这两种情况

10:04.190 --> 10:04.670
对不对

10:04.670 --> 10:06.430
啊那我们首先先来看一下

10:06.430 --> 10:10.030
先来看一下这个

10:10.030 --> 10:11.230
把他加粗

10:11.230 --> 10:11.790
回头的话

10:11.790 --> 10:12.670
一会儿再来看这个

10:14.110 --> 10:14.910
放到这下面

10:17.520 --> 10:17.760
ok

10:18.560 --> 10:22.240
好这个react优先级转成这个scheduler

10:22.240 --> 10:23.520
scheduler的优先级

10:23.520 --> 10:24.480
那么他的的话

10:24.480 --> 10:26.800
整体的话会经历这个两次转换

10:26.800 --> 10:29.600
首先的话是先把这个net

10:29.600 --> 10:31.600
转为这个event priority

10:31.600 --> 10:32.800
啊涉及到的

10:33.680 --> 10:35.200
涉及到的

10:36.160 --> 10:36.880
这个方法

10:37.600 --> 10:38.160
如下

10:39.360 --> 10:40.160
ok

10:40.160 --> 10:41.120
好我们这边来看一下

10:43.150 --> 10:44.030
好把他拿过来

10:47.230 --> 10:47.550
这边

10:48.110 --> 10:49.630
你看这边他接受的是一个什么

10:49.630 --> 10:51.150
是不是接受的是个nance

10:51.150 --> 10:52.910
对吧这边应该是叫nance

10:52.910 --> 10:53.630
对你的

10:53.630 --> 10:54.430
nance

10:54.430 --> 10:56.110
啊这边接受一个nance

10:56.110 --> 10:57.150
接受一个nance之后

10:57.150 --> 10:57.790
然后加这边的话

10:57.790 --> 10:59.390
根据你的nance返回什么

10:59.390 --> 11:02.110
说返回这个不同的这个event priority

11:03.150 --> 11:03.870
对不对

11:03.870 --> 11:05.070
哎这首先第一步

11:05.070 --> 11:05.870
啊第二步

11:06.830 --> 11:08.110
第二步的话就是将

11:10.560 --> 11:12.880
将这个event priority

11:14.980 --> 11:17.620
然后转换为scheduler

11:18.420 --> 11:20.660
啊scheduler的优先级

11:21.460 --> 11:22.740
啊然后方法

11:22.740 --> 11:23.220
如下

11:26.610 --> 11:27.890
啊这边我把他过来

11:33.600 --> 11:34.480
啊这里

11:34.480 --> 11:35.280
你看这边呢

11:35.280 --> 11:37.200
他是一个event

11:37.200 --> 11:38.560
event priority

11:38.560 --> 11:39.360
啊拿到之后

11:39.360 --> 11:41.040
然后接下来的话根据你这个

11:41.040 --> 11:44.080
就是这边根据你不同的这个event priority

11:44.080 --> 11:45.360
然后回头给他转成什么呢

11:45.360 --> 11:46.640
转成这个scheduler的

11:46.720 --> 11:47.360
这个优先级

11:48.080 --> 11:48.720
可不可以

11:48.720 --> 11:50.080
好比我们举个例子吗

11:50.080 --> 11:50.960
啊举个例子

11:50.960 --> 11:53.280
假设比如说有一个这个点击事件

11:53.840 --> 11:54.080
啊

11:54.640 --> 11:55.280
举个例子

11:57.700 --> 11:59.460
举一个例子

12:03.090 --> 12:05.970
假设啊假设我们现在的话有一个点击事件

12:07.890 --> 12:08.450
假设

12:10.290 --> 12:13.730
现在有一个点击事件

12:14.370 --> 12:15.250
啊然后接下来的话

12:15.250 --> 12:16.850
这边的话这个在unclick

12:17.970 --> 12:19.010
unclick中

12:19.650 --> 12:21.570
是会对应对应有一个什么

12:21.570 --> 12:24.610
是对应有一个这个回调

12:25.650 --> 12:29.250
回调函数来触发这个更新

12:30.210 --> 12:31.010
对吧你点击嘛

12:31.010 --> 12:32.770
点击肯定会有一个unclick嘛

12:32.770 --> 12:35.010
那unclick肯定会有一个回调函数吗

12:35.010 --> 12:37.250
这个回调函数会触发一个更新吗

12:37.250 --> 12:37.810
对不对

12:37.810 --> 12:39.490
啊那接下来这个是属于什么

12:39.490 --> 12:40.530
那我们这边我们来看一下

12:41.810 --> 12:42.450
click

12:42.450 --> 12:45.570
他是不是属于这个discrete event priority

12:46.130 --> 12:47.410
对不对啊这个

12:49.890 --> 12:51.570
该更新

12:52.610 --> 12:53.810
属于什么呢

12:53.810 --> 12:56.610
属于这个discrete event priority

12:56.610 --> 12:56.930
好

12:56.930 --> 13:00.370
然后经过上面的两套

13:01.170 --> 13:05.730
转换规则进行转换之后

13:06.450 --> 13:09.890
最终得到的这个scheduler

13:10.610 --> 13:14.450
scheduler对应的优先级

13:14.450 --> 13:15.090
就是什么呢

13:15.090 --> 13:15.570
就是这个

13:17.600 --> 13:19.680
呃就是这个啊

13:22.740 --> 13:23.700
就这个啊

13:23.700 --> 13:25.540
immediate scheduler

13:25.540 --> 13:26.900
这个powerage

13:26.900 --> 13:28.260
啊得到就是这个

13:28.260 --> 13:29.940
啊他这边这边的话他是

13:29.940 --> 13:32.420
我看这边他是拿到这个event

13:32.420 --> 13:34.020
这边传入了这个next names

13:34.020 --> 13:36.580
这边应该是拿到的是event priority

13:36.580 --> 13:37.380
那拿到之后

13:37.380 --> 13:39.860
然后这样这边呢进行不同的复制

13:39.860 --> 13:41.700
啊你看这这边这边复的值是那个啊

13:41.700 --> 13:44.100
是这个scheduler对应的优先级

13:44.580 --> 13:45.940
对吧我刚才还看错了

13:45.940 --> 13:48.100
他这边对应的是这个scheduler对应的优先级

13:48.100 --> 13:48.660
看怎么样

13:48.660 --> 13:50.580
immediate scheduler priority

13:50.660 --> 13:52.820
这个user blocking scheduler priority

13:53.460 --> 13:54.020
对不对啊

13:54.020 --> 13:55.540
这边进行这个不同的复制

13:56.260 --> 13:58.820
ok啊这边就是一个点击事件啊

13:58.820 --> 14:00.340
最终的话他在这个

14:00.340 --> 14:02.340
转成这个scheduler的优先级的时候

14:02.340 --> 14:04.020
最终转出来的是这个

14:04.020 --> 14:06.100
immediate scheduler priority

14:06.660 --> 14:06.980
ok

14:07.860 --> 14:09.060
好那接下来的话

14:09.060 --> 14:09.700
还有个就是什么呢

14:09.700 --> 14:12.020
还有一个就是这个scheduler优先级

14:12.020 --> 14:12.900
转为什么呢

14:12.900 --> 14:14.900
转为这个react优先级

14:14.900 --> 14:16.580
啊这个的话也是可以转的啊

14:16.580 --> 14:18.180
这边的话这个转换逻辑入下

14:18.900 --> 14:21.780
转换就相关的代码

14:21.780 --> 14:24.340
相关的代码入下

14:24.340 --> 14:28.380
好把他拿过来

14:28.380 --> 14:34.140
好在这边

14:34.140 --> 14:35.260
啊你看这边

14:35.260 --> 14:37.340
这边就是他这个转换相关的代码

14:37.340 --> 14:40.620
啊这边他是一个scheduler priority

14:40.620 --> 14:43.180
啊那这边根据你这个不同的这个级别

14:43.180 --> 14:45.180
对吧那家最终我返回什么

14:45.180 --> 14:47.820
是返回这个不同的这个event priority

14:47.820 --> 14:49.260
对不对你看这边

14:49.260 --> 14:50.780
返回的是event priority

14:50.780 --> 14:52.860
event priority是不是就是这个

14:52.860 --> 14:54.460
react内部的这个优先级了

14:55.100 --> 14:55.740
对不对

14:55.740 --> 14:59.420
ok啊他们之间的话是可以进行这个相互转换的

14:59.420 --> 15:00.700
啊好

15:00.700 --> 15:02.780
然后接下来的话我们需要来看一个问题

15:03.900 --> 15:04.940
什么问题呢

15:04.940 --> 15:06.860
就是你这边的话优先级算法

15:06.860 --> 15:08.060
因为你一次

15:08.060 --> 15:09.660
比如你这边的话可能会涉及到

15:09.660 --> 15:11.660
就是在同一时间是不是会有很多更新

15:12.300 --> 15:13.900
对不对啊这里

15:16.270 --> 15:19.950
啊会涉及到一个问题

15:19.950 --> 15:20.590
什么问题呢

15:20.590 --> 15:21.790
就是在同一时间

15:22.510 --> 15:27.950
可能存在很多的这个更新

15:27.950 --> 15:30.510
啊那么这边的话就会存在

15:30.510 --> 15:32.190
就是究竟先去更新哪一个

15:32.190 --> 15:37.310
究竟先去更新哪一个

15:37.310 --> 15:39.950
啊所有他这边是不是才有了这个

15:39.950 --> 15:41.310
优先级的这个概念

15:41.310 --> 15:44.030
对不对才会有了优先级的概念

15:44.030 --> 15:45.870
啊就你不同类型的这个更新

15:45.870 --> 15:47.150
他的优先级是不一样的

15:47.150 --> 15:49.470
啊所以我们这边涉及到的这个问题是

15:49.470 --> 15:50.030
什么呢

15:50.030 --> 15:51.630
就是你需要从

15:51.630 --> 15:54.990
众多啊众多的这个update

15:54.990 --> 15:55.710
这个更新中

15:56.830 --> 15:58.430
啊就众多的

15:58.430 --> 16:02.910
有有这个优先级的这个update

16:02.910 --> 16:04.350
中选出

16:06.510 --> 16:09.550
选出一个优先级最高的

16:10.510 --> 16:11.790
啊第二个是什么呢

16:11.790 --> 16:13.790
第二个就是表达这个p

16:14.910 --> 16:15.550
p的概念

16:16.510 --> 16:18.590
啊就我在更新的时候

16:18.590 --> 16:20.110
我是一批一批更新的

16:20.110 --> 16:22.270
啊不是我每次只做一个更新

16:22.270 --> 16:23.950
如果有些更新是相同的话

16:23.950 --> 16:25.150
我这边可以就是把他

16:25.150 --> 16:26.430
看作是同一批

16:26.430 --> 16:27.470
同一批更新

16:27.470 --> 16:28.990
然后接下来的话这边就是

16:28.990 --> 16:30.910
啊同时处理了就可以了

16:30.910 --> 16:33.150
ok主要就是要解决这两个问题

16:33.150 --> 16:35.070
好了这个react

16:35.070 --> 16:36.830
他在这个表达方式上面的话

16:36.830 --> 16:38.910
他实际上精力了两次迭代

16:40.190 --> 16:43.070
react在表达

16:43.070 --> 16:46.910
表达方式上面

16:47.310 --> 16:49.390
实际上这个精力了

16:50.350 --> 16:52.910
精力了两次迭代

16:53.790 --> 16:55.790
ok第一次的话就是什么

16:55.790 --> 16:57.390
第一次就是基于这个

16:57.390 --> 16:58.270
expiration

17:00.190 --> 17:03.150
expiration time的这个算法

17:04.590 --> 17:06.510
啊现在的话最新的就是什么呢

17:06.510 --> 17:07.630
最新的就是基于这个

17:09.630 --> 17:10.750
基于内的算法

17:11.390 --> 17:13.470
啊好了我们一个一个来看

17:13.470 --> 17:15.150
我们首先先来看这个

17:15.150 --> 17:16.270
expiration time

17:17.070 --> 17:19.230
最在最早期的时候react的话

17:19.230 --> 17:20.990
采用的就是啊这种模型

17:21.870 --> 17:22.430
为什么呢

17:22.430 --> 17:24.430
因为最早期的话这个scheduler

17:24.430 --> 17:25.870
里面就是这么设计的

17:25.870 --> 17:27.790
我们之前在讲这个scheduler的时候

17:27.790 --> 17:28.990
是不是讲过这个问题

17:29.630 --> 17:30.030
对不对

17:31.150 --> 17:35.070
react早期采用的

17:37.440 --> 17:38.720
采用的就是什么呢

17:38.720 --> 17:39.840
采用的就是这个

17:39.840 --> 17:44.160
expiration time的这个算法

17:45.120 --> 17:48.080
ok这一点和这个scheduler

17:49.040 --> 17:51.920
scheduler里面的这个设计

17:51.920 --> 17:53.200
设一致的

17:54.640 --> 17:55.520
来我们来回顾一下

17:56.240 --> 17:57.520
在这个scheduler

17:58.640 --> 18:00.160
在scheduler中

18:00.160 --> 18:01.680
是不是设计了五个优先级

18:02.240 --> 18:02.800
对不对

18:02.800 --> 18:04.400
设计了五种

18:07.090 --> 18:08.770
五种优先级

18:09.330 --> 18:10.930
好了接下来不同的优先级

18:10.930 --> 18:11.890
它会对应什么

18:11.890 --> 18:14.050
会对应这个不同的这个timeout

18:15.330 --> 18:17.250
不同的优先级

18:17.810 --> 18:19.970
会对应不同的

18:20.690 --> 18:21.330
timeout

18:22.690 --> 18:23.250
对不对

18:23.250 --> 18:23.810
还记得吧

18:23.810 --> 18:25.890
我们之前讲那个scheduler的时候

18:25.890 --> 18:27.570
那首先根据你的优先级

18:27.570 --> 18:28.770
让给那个不同的

18:28.770 --> 18:30.450
就给那个timeout复制

18:31.010 --> 18:31.650
对吧

18:31.650 --> 18:31.970
好

18:31.970 --> 18:32.850
然后接下来的话

18:34.210 --> 18:34.610
最终

18:35.730 --> 18:37.970
最终会对应什么呢

18:37.970 --> 18:41.890
对应这个不同的这个expiration time

18:42.770 --> 18:45.570
然后这个task

18:45.570 --> 18:46.930
就你的这个任务

18:46.930 --> 18:47.890
根据什么呢

18:47.890 --> 18:48.690
根据这个

18:49.650 --> 18:51.650
expiration timeout

18:52.450 --> 18:53.570
来进行什么呢

18:53.570 --> 18:55.250
来进行这个任务的排序

18:58.190 --> 18:59.310
在scheduler里面

18:59.310 --> 19:00.350
它是不是就这样子来做了

19:00.990 --> 19:01.710
对不对

19:01.710 --> 19:02.910
它那么早期的时候

19:02.910 --> 19:03.870
这个在react中

19:04.510 --> 19:05.390
早期的时候

19:06.110 --> 19:07.950
在这个react中

19:08.670 --> 19:09.790
延续了这种设计

19:10.750 --> 19:11.470
延续了

19:12.670 --> 19:13.790
这种设计

19:14.510 --> 19:15.630
那你这个update

19:16.430 --> 19:17.870
update的优先级

19:19.710 --> 19:20.510
优先级

19:20.510 --> 19:21.470
它与什么呢

19:21.470 --> 19:23.070
与这个触发事件

19:23.870 --> 19:25.470
触发事件的

19:25.470 --> 19:26.350
当前时间

19:27.950 --> 19:30.110
以及优先级

19:31.310 --> 19:33.310
对应的这个延迟时间

19:34.510 --> 19:35.070
延迟

19:37.070 --> 19:38.430
时间啊相关

19:39.230 --> 19:40.190
这样子的算法的话

19:40.190 --> 19:41.790
实际上它是比较简单易懂的

19:42.350 --> 19:42.750
对不对

19:43.470 --> 19:44.990
这样的算法

19:45.630 --> 19:47.070
实际上是

19:47.870 --> 19:50.430
比较简单易懂的

19:50.670 --> 19:52.750
你看我们之前在讲那个scheduler的时候

19:53.150 --> 19:54.590
你看那个就是优先级

19:54.590 --> 19:56.190
它首先设计了五种优先级

19:56.510 --> 19:57.950
那根据不同的优先级

19:57.950 --> 19:59.230
给这个timeout复辞

19:59.630 --> 20:00.430
然后回头的话

20:00.430 --> 20:00.990
你这边的话

20:00.990 --> 20:02.110
这个不同的这个任务

20:02.430 --> 20:04.270
它就会有这个expiration time

20:04.750 --> 20:06.350
大家根据这个来排序

20:06.750 --> 20:08.670
这个呢是实际上是比较简单易懂的

20:09.470 --> 20:10.590
那你每当进入

20:12.620 --> 20:15.180
每当进入这个scheduler的时候

20:16.700 --> 20:20.620
每当进入这个scheduler的这个时候

20:21.260 --> 20:22.220
啊就会什么呢

20:22.220 --> 20:23.980
就会选出

20:25.340 --> 20:27.420
就会选出这个优先级

20:28.700 --> 20:31.820
优先级最高的这个update

20:32.780 --> 20:34.540
进行一个调度

20:36.380 --> 20:37.180
那你这边的话

20:38.220 --> 20:38.620
呃

20:41.490 --> 20:44.290
选出这个优先级最高的这个update

20:44.290 --> 20:45.570
实际上它就会对这个

20:45.570 --> 20:47.010
整个这个所有的update

20:47.010 --> 20:47.970
是不是进行一个排序

20:48.530 --> 20:49.490
对排序的话

20:49.490 --> 20:50.050
然后基于什么

20:50.050 --> 20:51.010
是不是就是基于这个

20:51.250 --> 20:52.290
expiration time

20:52.290 --> 20:53.890
就针对这个来进行排序

20:53.890 --> 20:54.610
排序了之后

20:54.610 --> 20:55.570
然后这样我就可以

20:55.570 --> 20:57.730
非常方便的选出这个优先级最高的

20:58.850 --> 21:00.210
那方便是方便

21:00.210 --> 21:01.570
但是这种算法的话

21:01.570 --> 21:03.890
它在表示这个p的这个概念上

21:03.890 --> 21:05.250
它实际上不够灵活

21:06.690 --> 21:07.970
但是这种算法

21:08.930 --> 21:09.570
在什么呢

21:09.570 --> 21:11.650
在表示这个p

21:13.090 --> 21:14.770
p的这个概念上

21:15.490 --> 21:16.450
它不够灵活

21:20.080 --> 21:21.200
比如举个例子

21:21.200 --> 21:22.960
就是在expiration time

21:22.960 --> 21:24.800
那么这个模型的这个算法里面

21:24.800 --> 21:25.840
它有这么一个表达

21:27.120 --> 21:29.760
在基于expiration time

21:30.560 --> 21:32.320
模型的这个算法中

21:33.520 --> 21:35.200
有如下的表达

21:37.570 --> 21:39.170
它这里面的话有这么一举代吗

21:39.730 --> 21:40.770
给大家可以看一下

21:41.890 --> 21:42.690
好吧 拿过来

21:46.800 --> 21:47.440
然后这里

21:47.440 --> 21:47.840
你看

21:48.400 --> 21:50.960
is update include in bench

21:51.520 --> 21:52.240
它等于什么呢

21:52.240 --> 21:54.480
等于 priority of update

21:54.480 --> 21:56.000
大于等于 priority

21:56.000 --> 21:57.040
这个 priority

21:57.200 --> 21:57.760
of bench

21:58.400 --> 21:59.360
而这个什么意思呢

21:59.920 --> 22:02.640
它这个 priority of update

22:04.640 --> 22:06.000
这个的话表示的是

22:06.000 --> 22:07.840
当前update的优先级

22:10.610 --> 22:11.810
表示的是

22:12.370 --> 22:16.530
当前update的优先级

22:17.250 --> 22:19.330
而这个 priority of bench

22:20.770 --> 22:22.450
它表达的是什么呢

22:22.450 --> 22:23.970
它代表的是

22:24.450 --> 22:25.090
这个p

22:27.420 --> 22:31.660
p对应的这个优先级下限

22:32.540 --> 22:33.180
也就是说

22:34.380 --> 22:35.420
也就是说

22:35.420 --> 22:37.580
当前的这个update

22:38.220 --> 22:40.220
只要这个大于

22:41.740 --> 22:46.060
大于等于这个 priority of bench

22:46.620 --> 22:47.500
就会什么呢

22:47.500 --> 22:51.180
就会被划分为同一匹

22:53.300 --> 22:55.940
划分为同一匹

22:58.930 --> 23:00.050
比如这边取个例子

23:00.050 --> 23:00.770
这边有个图

23:03.280 --> 23:04.000
把他拿过来

23:05.280 --> 23:05.840
在这里

23:06.960 --> 23:08.880
比如我这边的话有六个更新

23:09.280 --> 23:12.080
U0 U1 U2 U3 U4 U5

23:12.080 --> 23:13.040
六个更新

23:13.040 --> 23:14.000
好 然后接下来

23:14.000 --> 23:15.040
我这边就根据什么呢

23:15.040 --> 23:16.960
根据你这个 priority of update

23:16.960 --> 23:18.800
就当前的这个优先级

23:18.800 --> 23:19.680
是否大于

23:19.680 --> 23:21.680
是否大于这个 priority of bench

23:22.240 --> 23:23.600
这个的话它是个下限值吗

23:24.240 --> 23:25.760
对吧 我刚才说它是个下限值

23:25.760 --> 23:27.280
好 只要你大于这个值

23:27.280 --> 23:27.920
大于这个值

23:27.920 --> 23:28.960
我这边就把你

23:29.120 --> 23:30.880
划分到这一批

23:30.880 --> 23:32.160
然后这边的话

23:32.160 --> 23:33.280
就是划分到这一批

23:33.840 --> 23:34.160
对不对

23:34.160 --> 23:35.200
那这边是不是就是出现了

23:35.200 --> 23:37.280
你这个更新这个p的这个概念

23:37.280 --> 23:37.600
对不对

23:37.600 --> 23:38.960
这个是第一批更新

23:39.680 --> 23:40.720
这个是第二批更新

23:41.520 --> 23:43.280
反正就是两批更新嘛

23:43.280 --> 23:43.600
对吧

23:43.600 --> 23:44.560
这边就是两批更新

23:44.960 --> 23:45.200
OK

23:46.000 --> 23:47.360
但是你这样子的表的话

23:47.360 --> 23:49.040
实际上是存在一个问题的

23:50.640 --> 23:52.080
但是此时

23:52.720 --> 23:55.680
就会存在一个问题

23:56.400 --> 23:57.520
什么问题呢

23:57.600 --> 23:58.160
如何

24:00.000 --> 24:01.760
如何将

24:01.760 --> 24:02.960
某一范围

24:04.080 --> 24:05.600
某一范围的

24:05.600 --> 24:06.880
某几个

24:07.760 --> 24:08.320
优先级

24:09.120 --> 24:09.680
化为

24:13.380 --> 24:14.180
化为

24:14.180 --> 24:14.740
同一批

24:17.230 --> 24:18.590
这个你如何做的

24:18.590 --> 24:19.390
什么意思呢

24:19.390 --> 24:20.510
不用你看这里

24:20.510 --> 24:21.070
看这张图

24:24.660 --> 24:26.100
好 同样还是刚才的

24:26.980 --> 24:28.820
同样还是刚才的这个6个

24:28.820 --> 24:29.300
对不对

24:29.300 --> 24:30.260
但是我现在的话

24:30.260 --> 24:30.900
我想什么呢

24:30.900 --> 24:32.740
我想要这个u1 u2

24:32.740 --> 24:33.700
u3 u4

24:33.700 --> 24:34.980
他们是同一批

24:35.540 --> 24:36.980
你看以前的这种表达方式

24:36.980 --> 24:37.540
能不能做的

24:38.180 --> 24:40.020
以前的表达方式是没有做的

24:40.020 --> 24:41.460
就是没办法做的了

24:41.460 --> 24:42.260
对不对

24:42.260 --> 24:43.380
在上图中

24:44.820 --> 24:46.900
我们想要什么呢

24:46.900 --> 24:49.540
想要将这个u1

24:50.580 --> 24:51.300
然后u2

24:52.180 --> 24:52.660
u3

24:53.460 --> 24:55.060
和这个u4

24:55.620 --> 24:58.260
说化分为同一批

24:59.060 --> 25:00.020
对不对

25:00.020 --> 25:01.460
但是以前的

25:02.740 --> 25:03.460
以前的这个

25:05.540 --> 25:06.580
expiration time

25:09.010 --> 25:09.890
time模型

25:11.410 --> 25:12.530
是无法做到了

25:14.210 --> 25:15.890
无法做到了

25:16.530 --> 25:16.930
为什么

25:17.970 --> 25:18.770
这张这个的话

25:18.770 --> 25:19.810
你是非常困难的

25:20.450 --> 25:21.890
为什么没办法做到呢

25:21.890 --> 25:22.610
糾其原因

25:25.490 --> 25:28.930
糾其原因是因为什么呢

25:28.930 --> 25:31.250
你的这个expiration time

25:31.250 --> 25:32.050
这个模型

25:32.850 --> 25:35.410
它的这个优先级算法

25:35.490 --> 25:37.330
优先级算法

25:37.330 --> 25:39.890
偶和了这个优先级

25:41.570 --> 25:45.250
偶和了优先级和这个p的概念

25:47.860 --> 25:48.420
对不对

25:48.420 --> 25:50.340
它把这个优先级和p

25:50.340 --> 25:51.860
它把它偶和到一起了

25:52.420 --> 25:53.380
那因此的话

25:53.380 --> 25:56.660
限制了模型的这个表达能力

25:57.860 --> 25:58.500
对不对

25:58.500 --> 25:59.380
你优先级

26:00.100 --> 26:02.340
优先级算法的这个本质

26:02.900 --> 26:03.620
是干嘛呢

26:03.620 --> 26:05.060
是为这个update

26:06.020 --> 26:06.740
进行

26:08.830 --> 26:10.910
进行一个排序

26:10.910 --> 26:11.550
但是

26:13.150 --> 26:16.110
但是这个expiration time模型

26:16.750 --> 26:21.150
在完成这个排序的这个同时

26:21.870 --> 26:22.910
是不是还默认的

26:23.870 --> 26:26.910
还默认的画定了p

26:29.500 --> 26:29.820
对不对

26:29.820 --> 26:30.700
你看上面这张图

26:31.260 --> 26:33.580
我这边让我把这个排序排好了之后

26:33.580 --> 26:34.140
然后接下来

26:34.140 --> 26:36.300
我这个模型expiration time

26:36.300 --> 26:37.020
这边是不是默认

26:37.020 --> 26:39.180
默认就把这个p就已经划分好了

26:39.740 --> 26:40.060
对不对

26:40.060 --> 26:41.740
你只要比较大于这个值的

26:41.740 --> 26:42.620
这边是一批

26:42.620 --> 26:44.140
小于这个值的是一批

26:44.620 --> 26:45.340
但我现在呢

26:45.340 --> 26:46.460
我这边想要比如说

26:46.460 --> 26:48.060
U1U2U3U4

26:48.060 --> 26:50.220
他们我想把它划分成同一批

26:50.220 --> 26:50.780
你这个的话

26:50.780 --> 26:51.900
你就没办法表达了

26:52.700 --> 26:53.020
对不对

26:53.660 --> 26:54.780
所以说你在表达这个

26:55.340 --> 26:56.620
就是表达就是这种

26:57.260 --> 26:58.780
就是将某一范围的

26:58.780 --> 27:00.060
某几个优先级

27:00.060 --> 27:01.100
划为同一批

27:01.500 --> 27:02.540
在这个上面的话

27:02.540 --> 27:04.380
它实际上是有一定局限性的

27:04.940 --> 27:05.500
OK

27:05.820 --> 27:07.420
所以基于这个原因

27:07.420 --> 27:08.540
引入了什么呢

27:08.540 --> 27:09.500
引入了内模型

27:11.180 --> 27:11.660
因此

27:12.460 --> 27:16.060
基于上述的原因

27:17.180 --> 27:17.980
react中

27:18.700 --> 27:19.340
引入了

27:20.300 --> 27:21.980
引入了内模型

27:23.740 --> 27:23.980
OK

27:24.700 --> 27:25.500
那你这边的话

27:25.500 --> 27:27.980
和这个expiration time相同

27:27.980 --> 27:29.660
你不管引入什么模型

27:29.660 --> 27:31.180
你首先要解决的问题

27:31.180 --> 27:31.980
是不是这两个问题

27:31.980 --> 27:32.700
你必须要解决

27:33.740 --> 27:34.060
对不对

27:36.460 --> 27:37.020
不管

27:38.860 --> 27:39.340
不管

27:40.060 --> 27:40.860
新引入

27:41.500 --> 27:42.220
什么模型

27:43.500 --> 27:44.220
什么模型

27:44.780 --> 27:45.420
必须

27:46.060 --> 27:46.940
要保证

27:47.900 --> 27:48.380
以下

27:49.980 --> 27:50.780
两个问题

27:52.220 --> 27:52.860
得到解决

27:54.620 --> 27:56.300
得到解决

27:57.100 --> 27:57.980
哪两个问题呢

27:57.980 --> 27:59.180
首先第一个就是

27:59.180 --> 27:59.980
以优先级

28:01.340 --> 28:03.500
以优先级为依据

28:04.460 --> 28:06.140
对这个update

28:06.860 --> 28:07.340
进行

28:08.860 --> 28:10.140
进行一个排序

28:11.580 --> 28:12.060
对吧

28:12.060 --> 28:12.940
第二个是什么

28:14.380 --> 28:14.860
第二个什么

28:14.860 --> 28:16.300
就是表达这个p的概念

28:17.100 --> 28:17.660
对吧

28:17.660 --> 28:18.540
那上面这个

28:18.540 --> 28:20.540
从众多的这个优先级update中

28:20.540 --> 28:21.660
选出一个优先级最高的

28:21.660 --> 28:23.180
这个本质上其实也就是排序

28:23.740 --> 28:24.540
你排了去之后

28:24.540 --> 28:25.180
你这样的人是不是

28:25.180 --> 28:26.780
可以选出一个优先级最高的

28:26.780 --> 28:27.340
对吧

28:27.340 --> 28:28.380
所以和这的说法

28:28.380 --> 28:29.100
是不冲突的

28:29.660 --> 28:30.380
是一个意思

28:30.380 --> 28:31.420
第二个就是什么呢

28:31.420 --> 28:31.900
第二个就是

28:31.900 --> 28:33.020
表达p的这个概念

28:33.980 --> 28:34.220
好

28:34.220 --> 28:35.420
来我们来看一下

28:35.420 --> 28:36.060
首先的话

28:36.060 --> 28:37.500
针对这个第一个问题

28:39.870 --> 28:41.470
针对第一个问题

28:41.470 --> 28:42.910
那么在这个内模形中

28:45.090 --> 28:45.810
内模形中

28:46.610 --> 28:48.610
它这边的话有很多内

28:49.250 --> 28:50.610
在这个内模形中

28:51.410 --> 28:52.130
设置了

28:53.010 --> 28:55.010
很多的这个内

28:55.890 --> 28:57.810
然后每一个内

28:58.850 --> 29:00.530
实际上是什么呢

29:00.530 --> 29:02.450
是一个二进之数

29:04.050 --> 29:05.570
这个我们之前在那个

29:05.570 --> 29:07.570
看那个位运算的时候

29:07.570 --> 29:09.330
实际上我们对这个内

29:09.330 --> 29:10.290
是不是也介绍过了

29:11.090 --> 29:11.650
对吧

29:11.650 --> 29:12.530
它每一个内的话

29:12.530 --> 29:13.970
它实际上是一个二进之数

29:14.850 --> 29:15.810
通过二进之

29:17.170 --> 29:19.890
通过二进之来表达

29:21.250 --> 29:21.810
优先级

29:22.370 --> 29:23.650
那你这个越低

29:25.890 --> 29:27.650
越低的这个位

29:28.290 --> 29:29.650
然后代表的什么呢

29:29.650 --> 29:30.930
代表这个越高

29:32.370 --> 29:34.130
越高的优先级

29:34.930 --> 29:35.330
例如

29:36.290 --> 29:37.650
比如说这里

29:38.850 --> 29:39.570
我把这边

29:39.570 --> 29:40.690
我把他过来

29:40.690 --> 29:42.130
这个也是原码片段

29:42.130 --> 29:44.050
我每次摘的都是原码片段

29:44.450 --> 29:45.090
ok

29:45.090 --> 29:46.290
那比如在这里

29:46.290 --> 29:47.490
这里的话在上面

29:50.370 --> 29:52.530
在上面的这个代码冲

29:52.530 --> 29:54.610
那这个synconet

29:54.610 --> 29:56.050
syncos不同步的意思

29:56.050 --> 29:56.850
对不对

29:56.850 --> 29:57.890
那synconet

29:57.890 --> 29:58.610
它是什么呢

29:58.610 --> 30:00.210
是最高优先级

30:02.850 --> 30:04.930
然后你的这个offscreen

30:06.130 --> 30:07.010
它是什么呢

30:07.090 --> 30:08.930
它是最低优先级

30:10.610 --> 30:10.930
ok

30:10.930 --> 30:12.450
那针对这个第一个问题

30:12.450 --> 30:13.650
啊如何进行排序

30:13.650 --> 30:15.330
那这边是不是就得到解决了

30:15.330 --> 30:15.730
对

30:15.730 --> 30:17.490
我在设置每一个nand的时候

30:17.490 --> 30:19.090
这边就根据你的位不同

30:19.090 --> 30:20.210
我这边是不是会

30:20.210 --> 30:21.730
就是会有不同的这个排序

30:22.530 --> 30:22.770
对不对

30:23.410 --> 30:23.730
好

30:23.730 --> 30:24.370
然后接下来的话

30:24.370 --> 30:25.890
对于这个第二个问题

30:27.970 --> 30:29.090
对于第二个问题

30:29.090 --> 30:30.610
那这边的话这个内模型

30:31.330 --> 30:36.690
内模型能够非常灵活的表达

30:39.060 --> 30:40.740
表达这个p的概念

30:42.340 --> 30:43.700
比如说我们这边我们举个例子

30:45.300 --> 30:46.180
比方你看这个代码

30:50.160 --> 30:50.720
比如这里

30:52.240 --> 30:54.240
比如说这边这边的话有一个半期

30:54.240 --> 30:55.040
一开始是0

30:55.600 --> 30:58.080
啊人家这边有个内A有个内B

30:58.640 --> 30:59.520
啊这两个是什么呢

30:59.520 --> 31:01.040
这两个是不相0的优先级

31:01.520 --> 31:01.760
对不对

31:01.760 --> 31:03.120
你看这边这个1在这里

31:03.120 --> 31:04.560
啊这边这个1在这里

31:04.560 --> 31:05.920
啊这两个是完全不相0的

31:05.920 --> 31:06.640
就不像这边

31:07.280 --> 31:08.480
啊不像这边对不对

31:08.480 --> 31:10.320
完全不相0的两个优先级

31:10.400 --> 31:11.600
好那这样我这边要把它

31:11.600 --> 31:12.720
纳入到同一批里面

31:12.720 --> 31:14.640
我这边是不是只需要做卫运算就可以了

31:15.440 --> 31:15.840
对不对

31:15.840 --> 31:17.360
我只需要做这种卫运算

31:17.360 --> 31:19.280
啊这卫运算的话之前在讲

31:19.280 --> 31:20.880
react中的这个卫运算

31:20.880 --> 31:22.480
那几颗里面是讲过的

31:23.360 --> 31:23.920
对不对

31:23.920 --> 31:24.960
哎你看是不是就

31:24.960 --> 31:28.320
很好的解决了之前那个expiration time

31:28.320 --> 31:30.160
那个模型里面的这个问题

31:30.960 --> 31:31.440
对不对

31:31.440 --> 31:32.960
就是在这个表达p

31:33.520 --> 31:34.240
这个概念上面

31:34.240 --> 31:35.760
它不太灵活的这个问题

31:35.760 --> 31:37.680
就很好的得到了这个解决

31:38.560 --> 31:38.800
OK

31:40.400 --> 31:41.920
好那接下来的话

31:41.920 --> 31:43.600
这边关于这个内模型啊

31:43.600 --> 31:44.400
这边介绍了

31:44.400 --> 31:46.320
那接下来我们来看一下这道题啊

31:46.320 --> 31:49.440
是否了解过这个react中的内模型

31:49.440 --> 31:52.960
为什么要从之前的expiration time模型

31:52.960 --> 31:54.720
转换为内模型

31:55.360 --> 31:57.600
那相信这个的话你也应该能够

31:57.600 --> 31:59.200
就是很好的回答这道题了

31:59.760 --> 32:01.600
好这边上来看一下这个参考答案

32:05.410 --> 32:06.610
啊把参考答案拿过来

32:07.730 --> 32:10.850
啊好在react中有一套这个独立的

32:10.850 --> 32:12.930
力度更细的这个优先级算法

32:13.010 --> 32:14.290
啊它是这个内

32:14.290 --> 32:16.130
它是基于这个位运算的

32:16.130 --> 32:18.370
每一个内它是一个32位啊

32:18.370 --> 32:19.970
32bit的这个integer

32:20.610 --> 32:21.410
对吧

32:21.410 --> 32:23.010
32位的这个整数

32:23.010 --> 32:25.490
那不同的优先级对应了不同的内

32:25.490 --> 32:26.850
越低的位代表什么

32:26.850 --> 32:28.450
代表这个优先级越高

32:29.330 --> 32:31.650
啊那早期的话react没有使用内模型

32:31.650 --> 32:32.770
而是采用了什么

32:32.770 --> 32:33.890
expiration time

32:34.530 --> 32:36.690
对吧但是这种算法的话

32:36.690 --> 32:39.890
它偶和了优先级和p的这两个概念

32:39.890 --> 32:41.970
限制了模型的表达的力

32:42.050 --> 32:43.810
你优先级的话本质上是为这个

32:44.370 --> 32:45.730
update排序的

32:45.730 --> 32:48.050
但是你这个expiration time这个模型

32:48.050 --> 32:49.490
它在排序的同时

32:49.490 --> 32:50.210
还把什么

32:50.210 --> 32:52.210
是不是还把p给你划分好了

32:52.930 --> 32:53.730
对不对啊

32:53.730 --> 32:55.330
但是你这边这个内模型

32:55.330 --> 32:57.010
它就不存在这个问题啊

32:57.010 --> 32:58.610
因为它基于这个位运算

32:58.610 --> 33:00.770
所以它在这个p的这个划分上面

33:00.770 --> 33:02.210
它是更加灵活的

33:02.210 --> 33:03.730
对不对我想要把那个

33:03.730 --> 33:04.450
拉入一个p

33:05.010 --> 33:06.290
ok的对不对

33:06.290 --> 33:07.650
完全没有问题啊

33:08.290 --> 33:11.730
好这就是关于这个这个react中这个内模型

33:12.290 --> 33:14.050
为什么这个要转成内模型

33:14.610 --> 33:17.010
以前这个expiration time模型

33:17.010 --> 33:18.130
究竟有什么样的问题

33:18.770 --> 33:20.610
这边给大家做了一个介绍

33:21.250 --> 33:22.610
好下来的话

33:22.610 --> 33:23.970
大家可以自己再看一下

33:24.850 --> 33:26.370
好这期课就到这里

33:26.370 --> 33:27.330
再见

