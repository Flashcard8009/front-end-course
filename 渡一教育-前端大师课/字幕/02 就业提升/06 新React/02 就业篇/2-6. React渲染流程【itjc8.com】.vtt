WEBVTT

00:00.180 --> 00:05.180
这节课的话 咱们来看一下react的渲染流程

00:05.180 --> 00:08.180
这个的话仍然是一道面试题

00:08.180 --> 00:12.180
它问你是否了解react整体的渲染流程

00:12.180 --> 00:14.180
里面有哪些阶段

00:14.180 --> 00:16.180
这个的话 实际上你上节课

00:16.180 --> 00:19.180
如果听了react整体架构的话

00:19.180 --> 00:20.180
这个渲染流程的话

00:20.180 --> 00:23.180
实际上你大致也是能够说出来的

00:23.180 --> 00:25.180
它主要就分成那三块

00:25.180 --> 00:28.180
调度器 协调器和渲染器

00:28.180 --> 00:31.180
那么这节课的话 我们来具体来看一下

00:31.180 --> 00:35.180
具体来看一下每一块的它这个组件

00:35.180 --> 00:38.180
它具体会做什么样的事情

00:38.180 --> 00:39.180
好 我们在前面的话

00:39.180 --> 00:41.180
我们总结就是现代前端框架

00:41.180 --> 00:44.180
它实际上都可以总结为一个公式

00:44.180 --> 00:52.180
现代前端框架都可以总结为一个公式

00:52.180 --> 00:53.180
什么公式呢

00:53.180 --> 00:58.320
这是Ui等于一个F

00:58.320 --> 01:02.320
F 然后下这边State

01:02.320 --> 01:06.320
对吧 首先通过State算出Ui

01:06.320 --> 01:08.320
那算出Ui 注意这个Ui的话

01:08.320 --> 01:13.320
并非真实的渲染到页面上的Ui

01:13.320 --> 01:16.320
它这里所指的算出来的Ui

01:16.320 --> 01:17.320
实际上是什么呢

01:17.320 --> 01:21.320
实际上就是虚拟多摸对Ui的描述

01:21.320 --> 01:22.320
所以你上一步

01:22.320 --> 01:25.320
就这个公式实际上还可以进行拆分

01:25.320 --> 01:30.320
上面的公式还可以进行一个拆分

01:30.320 --> 01:32.320
这个我们之前是不是也说了的

01:32.320 --> 01:36.320
对吧 你可以拆分成这两步

01:36.320 --> 01:37.320
把它拿过来

01:37.320 --> 01:40.320
一个是根据质变量的变化

01:40.320 --> 01:42.320
算出Ui的变化

01:42.320 --> 01:44.320
然后接下来根据Ui的变化

01:44.320 --> 01:48.320
是否执行具体宿主环境的API

01:48.320 --> 01:49.320
对不对

01:49.320 --> 01:51.320
好 那接下来这边对应的公式

01:51.320 --> 01:56.700
对应的公式你这边就可以拆成两步

01:56.700 --> 01:57.700
那两个呢

01:57.700 --> 01:58.700
首先第一个

01:58.700 --> 02:00.700
这边是一个State

02:00.700 --> 02:01.700
这个State的话

02:01.700 --> 02:02.700
大家等于什么呢

02:02.700 --> 02:04.700
等于一个Reconcile

02:04.700 --> 02:06.700
协调

02:06.700 --> 02:08.700
大家这边Update

02:08.700 --> 02:09.700
Update就是更新

02:09.700 --> 02:10.700
这个是什么呢

02:10.700 --> 02:13.700
这个是通过Reconciler

02:13.700 --> 02:15.700
Reconciler

02:15.700 --> 02:20.700
记以算出这个最新的状态

02:20.700 --> 02:23.700
好 然后接下来这边ConstUi

02:23.700 --> 02:24.700
等于什么呢

02:24.700 --> 02:26.700
这边Commit

02:26.700 --> 02:28.700
这边是State

02:28.700 --> 02:30.700
就根据你上一步这边

02:30.700 --> 02:32.700
计算出来的这个State

02:32.700 --> 02:35.700
然后计算出最终的这个Ui

02:35.700 --> 02:41.480
根据上一步

02:41.480 --> 02:44.480
计算出来的这个State

02:44.480 --> 02:46.480
然后接下来的话

02:46.480 --> 02:48.480
渲染出Ui

02:48.480 --> 02:51.480
渲染出Ui

02:52.480 --> 02:53.480
OK

02:53.480 --> 02:55.480
那整个对应到react里面

02:55.480 --> 02:58.480
它就是两个大的阶段

02:58.480 --> 03:01.480
对应到react里面

03:01.480 --> 03:04.480
就是两大阶段

03:04.480 --> 03:07.790
哪两大阶段呢

03:07.790 --> 03:10.790
首先第一个叫做Render阶段

03:10.790 --> 03:11.790
Render的话

03:11.790 --> 03:12.790
这个直接翻译这个Render

03:12.790 --> 03:13.790
是不是渲染的意思

03:13.790 --> 03:14.790
对不对

03:14.790 --> 03:15.790
它甚至为渲染阶段

03:15.790 --> 03:17.790
但它这个渲染阶段

03:17.790 --> 03:18.790
不是说真实的

03:18.790 --> 03:20.790
渲染这个真实的动物

03:20.790 --> 03:21.790
而是指什么呢

03:21.790 --> 03:23.790
而是指就是你把最终的

03:23.790 --> 03:24.790
虚拟动物

03:24.790 --> 03:26.790
它的那个层次结构

03:26.790 --> 03:27.790
把它计算出来

03:27.790 --> 03:28.790
OK

03:28.790 --> 03:30.790
这个阶段它主要要做的就是

03:30.790 --> 03:33.790
调和这个虚拟动物

03:33.790 --> 03:35.790
然后接下来计算出

03:35.790 --> 03:37.790
这个最终

03:37.790 --> 03:40.790
要渲染出来的

03:40.790 --> 03:42.790
这个虚拟动物

03:42.790 --> 03:43.790
OK

03:43.790 --> 03:44.790
这是称之为Render阶段

03:44.790 --> 03:45.790
好

03:45.790 --> 03:47.790
接下来的话有个Commit阶段

03:47.790 --> 03:49.790
Commit阶段它这个是什么呢

03:49.790 --> 03:52.790
就是根据上一步

03:52.790 --> 03:55.790
计算出来的这个虚拟动物

03:55.790 --> 03:57.790
虚拟动物

03:57.790 --> 04:01.790
渲染具体的UI

04:01.790 --> 04:02.790
看了没有

04:02.790 --> 04:03.790
整体来讲的话

04:03.790 --> 04:05.790
对应两大阶段

04:05.790 --> 04:06.790
好

04:06.790 --> 04:07.790
接下来的话

04:07.790 --> 04:08.790
每个阶段的话

04:08.790 --> 04:10.790
它对应不同的组件

04:10.790 --> 04:12.790
每个阶段

04:12.790 --> 04:14.790
每个阶段

04:14.790 --> 04:17.790
对应不同的组件

04:17.790 --> 04:18.790
好

04:18.790 --> 04:19.790
接下来我这边有个图

04:19.790 --> 04:21.790
大家看一下这张图

04:21.790 --> 04:23.790
这边

04:23.790 --> 04:25.790
对应的话就是这个样子的

04:25.790 --> 04:26.790
首先

04:26.790 --> 04:28.790
第一个你这边是Render阶段

04:28.790 --> 04:30.790
这边的话是Commit阶段

04:30.790 --> 04:32.790
那Render阶段的话

04:32.790 --> 04:33.790
这边对应了什么呢

04:33.790 --> 04:34.790
对应了三大阶

04:34.790 --> 04:35.790
对应两个组件

04:35.790 --> 04:37.790
一个是Scalier

04:37.790 --> 04:39.790
一个是Reconceptor

04:39.790 --> 04:41.790
对应这两个东西

04:41.790 --> 04:43.790
而这个Commit阶段

04:43.790 --> 04:44.790
它对应的是什么呢

04:44.790 --> 04:46.790
它对应的是Render

04:46.790 --> 04:47.790
Render阶段

04:47.790 --> 04:48.790
这个就是渲染器

04:48.790 --> 04:49.790
好

04:49.790 --> 04:50.790
把这三个阶段的话

04:50.790 --> 04:51.790
我们来看一下

04:51.790 --> 04:52.790
首先的话

04:52.790 --> 04:53.790
第一个是调度器

04:53.790 --> 04:54.790
也就是我们上面

04:54.790 --> 04:57.790
所写的Scalier阶段

04:57.790 --> 04:58.790
OK

04:58.790 --> 04:59.790
那这个调度器

04:59.790 --> 05:00.790
它主要是什么呢

05:00.790 --> 05:01.790
它主要它的作用就是

05:01.790 --> 05:03.790
调度任务

05:03.790 --> 05:04.790
对吧

05:04.790 --> 05:06.790
为这个任务

05:06.790 --> 05:08.790
然后排序

05:08.790 --> 05:12.170
优先级

05:12.170 --> 05:14.170
让什么呢

05:14.170 --> 05:17.170
让优先级高的任务

05:17.170 --> 05:21.170
先进入到Reconceptor

05:21.170 --> 05:24.170
Reconceptor

05:24.170 --> 05:25.170
OK

05:25.170 --> 05:27.170
这是这个调度器

05:27.170 --> 05:28.170
它的这个作用

05:28.170 --> 05:29.170
好

05:29.170 --> 05:30.170
然后接下来的话是什么呢

05:30.170 --> 05:32.170
接下来的话是协调器

05:32.170 --> 05:33.170
协调器的话

05:33.170 --> 05:35.170
这边就是Reconceptor

05:35.170 --> 05:38.480
Reconceptor

05:38.480 --> 05:40.480
CiAir

05:40.480 --> 05:42.480
R Reconceptor

05:42.480 --> 05:43.480
那协调器

05:43.480 --> 05:44.480
协调的话

05:44.480 --> 05:45.480
它主要是做什么呢

05:45.480 --> 05:46.480
它首先它第一步

05:46.480 --> 05:48.480
它要生成这个fiber

05:48.480 --> 05:50.480
生成fiber对象

05:50.480 --> 05:51.480
OK

05:51.480 --> 05:53.480
这个fiber我们之前是不介绍过的

05:53.480 --> 05:54.480
对吧

05:54.480 --> 05:56.480
这边你要生成这个fiber

05:56.480 --> 05:57.480
好那还有一个就是什么呢

05:57.480 --> 05:59.480
还有一个就是收集副作用

05:59.480 --> 06:01.920
收集副作用

06:01.920 --> 06:03.920
什么叫做副作用

06:03.920 --> 06:04.920
所谓副作用的话

06:04.920 --> 06:05.920
就是你针对这个

06:05.920 --> 06:07.920
当前的这个fiber节点

06:07.920 --> 06:09.920
你要做什么样的这个操作

06:09.920 --> 06:11.920
比如说你这边是要做

06:11.920 --> 06:12.920
这个更新操作

06:12.920 --> 06:14.920
还是要做三处操作

06:14.920 --> 06:15.920
还是要做什么操作

06:15.920 --> 06:17.920
这边你要去收集

06:17.920 --> 06:19.920
这个的话我们统称为副作用

06:19.920 --> 06:22.920
找出哪些节点

06:22.920 --> 06:26.920
找出哪些节点发生的变化

06:26.920 --> 06:29.550
OK

06:29.550 --> 06:30.550
然后打上什么呢

06:30.550 --> 06:33.550
打上不同的flex

06:33.550 --> 06:36.550
就是打上这个不同的这个标记

06:36.550 --> 06:38.550
好然后接下来这个著名的

06:38.550 --> 06:41.550
著名的这个def算法

06:41.550 --> 06:43.550
也是什么呢

06:43.550 --> 06:46.550
也是在这个组建中

06:46.550 --> 06:48.550
然后执行的

06:48.550 --> 06:49.550
注意我再上强调

06:49.550 --> 06:51.550
这边所说的组建值得就是

06:51.550 --> 06:52.550
这个什么调度器啊

06:52.550 --> 06:53.550
协调器啊

06:53.550 --> 06:56.550
这边整体把它称为一个组建

06:56.550 --> 06:58.550
不是说你平时写的那个

06:58.550 --> 07:00.550
那个就是渲染页面的那个组建

07:00.550 --> 07:01.550
不是

07:01.550 --> 07:03.550
这是协调器

07:03.550 --> 07:06.550
最后一个最后一个就是渲染器

07:06.550 --> 07:07.550
渲染器的话对应的就是

07:07.550 --> 07:12.310
上面这边这个Render

07:12.310 --> 07:14.310
对吧Render

07:14.310 --> 07:15.310
Render就是什么呢

07:15.310 --> 07:17.310
这个的话就是根据

07:17.310 --> 07:19.310
协调器

07:19.310 --> 07:20.310
根据协调器

07:20.310 --> 07:24.310
计算出来的虚拟断码

07:24.310 --> 07:27.310
然后同步的渲染

07:27.310 --> 07:28.310
节点

07:28.310 --> 07:31.310
到这个仕图上

07:31.310 --> 07:32.310
OK

07:32.310 --> 07:33.310
就最后一步

07:33.310 --> 07:35.310
这一步的话它是同步的

07:35.310 --> 07:37.310
而且它必须同步

07:37.310 --> 07:38.310
为什么

07:38.310 --> 07:39.310
你如果不同步的话

07:39.310 --> 07:41.310
那用户看到的那个界面

07:41.310 --> 07:43.310
它是不是就是表现会不一致

07:43.310 --> 07:44.310
对不对

07:44.310 --> 07:45.310
一部分显示出来了

07:45.310 --> 07:46.310
就是一部分变了

07:46.310 --> 07:47.310
一部分没有变

07:47.310 --> 07:48.310
这个是不可能的

07:48.310 --> 07:49.310
对不对

07:49.310 --> 07:50.310
说渲染器的话

07:50.310 --> 07:51.310
它这边它是同步的

07:51.310 --> 07:52.310
这两块

07:52.310 --> 07:53.310
就是这个

07:53.310 --> 07:54.310
这两块的话

07:54.310 --> 07:56.310
它是可以就是中断的

07:56.310 --> 07:57.310
它是可以中断的

07:57.310 --> 07:58.310
OK

07:58.310 --> 07:59.310
好

07:59.310 --> 08:01.310
这是关于整个

08:01.310 --> 08:03.310
整个这个reactor

08:03.310 --> 08:05.310
它的两大阶段

08:05.310 --> 08:07.310
Render阶段和commit阶段

08:07.310 --> 08:08.310
好

08:08.310 --> 08:09.310
那接下来的话

08:09.310 --> 08:11.310
我们这边我们来看个例子

08:11.310 --> 08:13.310
接下来

08:13.310 --> 08:16.310
我们来看一个例子

08:16.310 --> 08:17.310
通过这个例子

08:17.310 --> 08:18.310
我们来看一下

08:18.310 --> 08:20.310
就是这三个模块

08:20.310 --> 08:23.310
它是如何进行配合工作的

08:23.310 --> 08:24.310
好

08:24.310 --> 08:25.310
我这边的话

08:25.310 --> 08:26.310
我这边写了一个组件

08:26.310 --> 08:28.310
大家看一下

08:28.310 --> 08:30.310
这个组件的话非常简单

08:30.310 --> 08:32.310
我这边就不创建

08:32.310 --> 08:34.310
reactor项目了

08:34.310 --> 08:35.310
大家就这样子看一下

08:35.310 --> 08:36.310
好吧

08:36.310 --> 08:38.310
这边首先我这边

08:38.310 --> 08:39.310
声明了一个状态

08:39.310 --> 08:40.310
counter

08:40.310 --> 08:41.310
再加这边update counter

08:41.310 --> 08:43.310
初始值的话是0

08:43.310 --> 08:44.310
好

08:44.310 --> 08:45.310
然后接下来的话

08:45.310 --> 08:46.310
这边有个ur

08:46.310 --> 08:47.310
ur下面一个button

08:47.310 --> 08:49.310
接下来三个例

08:49.310 --> 08:50.310
好

08:50.310 --> 08:51.310
首先这边这个例

08:51.310 --> 08:52.310
例的话这边是1×counter

08:52.310 --> 08:53.310
2×counter

08:53.310 --> 08:54.310
3×counter

08:54.310 --> 08:55.310
那一开始

08:55.310 --> 08:56.310
counter的初始值是0

08:56.310 --> 08:58.310
那接下来这三个是不是都是0

08:58.310 --> 08:59.310
对不对

08:59.310 --> 09:00.310
好

09:00.310 --> 09:02.310
那接下来你这边点击这个button

09:02.310 --> 09:03.310
点击button的话

09:03.310 --> 09:04.310
它做的事情是什么呢

09:04.310 --> 09:07.310
它做的事情是把这个counter加加

09:07.310 --> 09:09.310
你看这边counter加1

09:09.310 --> 09:10.310
对不对

09:10.310 --> 09:12.310
counter它是个自变量

09:12.310 --> 09:13.310
这个概念的话

09:13.310 --> 09:14.310
我们之前就讲过了

09:14.310 --> 09:16.310
它是个自变量

09:16.310 --> 09:17.310
它发生变化之后

09:17.310 --> 09:19.310
那接下来你整个这个UI

09:19.310 --> 09:20.310
是不是也会发生变化

09:20.310 --> 09:21.310
对不对

09:21.310 --> 09:22.310
大家这边就会渲染出什么呢

09:22.310 --> 09:23.310
这边就会渲染出1

09:23.310 --> 09:24.310
这边渲染出2

09:24.310 --> 09:26.310
这边渲染出3

09:26.310 --> 09:27.310
对不对

09:27.310 --> 09:28.310
你如果再加再加的话

09:28.310 --> 09:29.310
这个变成2

09:29.310 --> 09:30.310
2的话这边就是2

09:30.310 --> 09:31.310
4

09:31.310 --> 09:32.310
6

09:32.310 --> 09:33.310
对不对

09:33.310 --> 09:34.310
OK

09:34.310 --> 09:35.310
这是我们这个代码

09:35.310 --> 09:36.310
好

09:36.310 --> 09:38.310
那将当这个用户点击

09:38.310 --> 09:39.310
这个按钮的时候

09:39.310 --> 09:41.310
那接下来我们这边的话

09:41.310 --> 09:42.310
来看一下它这个

09:42.310 --> 09:43.310
这几个模块

09:43.310 --> 09:45.310
它是如何进行协调的

09:45.310 --> 09:47.310
现在我们把这个目光

09:47.310 --> 09:49.310
集中到这个模块上面

09:49.310 --> 09:50.310
那当用户

09:50.310 --> 09:54.330
当用户

09:54.330 --> 09:57.330
点击按钮时

09:57.330 --> 09:59.330
那首先是什么呢

09:59.330 --> 10:01.330
首先是由这个scheduler

10:01.330 --> 10:03.330
进行任务的协调

10:04.330 --> 10:05.330
首先

10:07.330 --> 10:08.330
是由什么呢

10:08.330 --> 10:10.330
是由这个scheduler

10:11.330 --> 10:15.330
进行任务的协调

10:15.330 --> 10:16.330
OK

10:16.330 --> 10:17.330
好

10:17.330 --> 10:18.330
然后你这边的话

10:18.330 --> 10:19.330
就是这个虚线框

10:19.330 --> 10:21.330
就你这边这个虚线框

10:21.330 --> 10:22.330
整个这个虚线框

10:22.330 --> 10:24.330
虚线框里面的这个工作流程

10:24.330 --> 10:27.330
它是可以随时被中断的

10:27.330 --> 10:29.330
或者说扔点阶段吧

10:29.330 --> 10:30.330
扔点阶段

10:30.330 --> 10:32.330
也就是虚线框

10:32.330 --> 10:34.330
虚线框内

10:34.330 --> 10:37.330
扔点阶段的这个工作流程

10:38.330 --> 10:40.330
是可以

10:40.330 --> 10:43.330
随时被以下

10:43.330 --> 10:45.330
这个原因

10:45.330 --> 10:46.330
中断的

10:46.330 --> 10:48.330
OK哪些原因呢

10:48.330 --> 10:49.330
比如说第一个

10:49.330 --> 10:52.330
有其他更高优先级的任务

10:53.330 --> 10:57.330
其他更高优先级的任务

10:57.330 --> 10:59.330
需要执行

10:59.330 --> 11:00.330
或者什么呢

11:00.330 --> 11:03.330
当前的这个time slice

11:03.330 --> 11:05.330
就当前的这个时间切片

11:05.330 --> 11:09.330
没有剩余的时间

11:09.330 --> 11:10.330
OK或者什么呢

11:10.330 --> 11:13.330
或者发生了其他错误

11:15.330 --> 11:17.330
就如果出现这些情况的话

11:17.330 --> 11:18.330
我这边的话

11:18.330 --> 11:20.330
扔点阶段的这个工作

11:20.330 --> 11:23.330
它是可以随时进行这个中断

11:23.330 --> 11:25.330
那你这个扔点阶段

11:25.330 --> 11:26.330
就这个虚线框

11:26.330 --> 11:28.330
虚线框这个里面的这个工作

11:28.330 --> 11:31.330
它是在内存里面进行的

11:31.330 --> 11:32.330
注意

11:32.330 --> 11:34.330
上面这个扔点

11:34.330 --> 11:36.330
扔点阶段

11:36.330 --> 11:38.330
扔点阶段的这个工作

11:38.330 --> 11:43.330
是在内存里面进行的

11:43.330 --> 11:45.330
不会什么呢

11:45.330 --> 11:49.330
不会更新这个宿主环境

11:49.330 --> 11:52.330
宿主环境UI

11:52.330 --> 11:54.330
你更新这个宿主环境UI是什么

11:54.330 --> 11:55.330
是不是commit阶段

11:55.330 --> 11:57.330
是不是由这个Renderer来做的

11:57.330 --> 11:58.330
对不对

11:58.330 --> 11:59.330
我这边这一块

11:59.330 --> 12:01.330
它是在内存里面做的

12:01.330 --> 12:03.330
所以因此就是这个阶段

12:03.330 --> 12:06.330
因此这个阶段

12:07.330 --> 12:10.330
即使这个工作流程

12:10.330 --> 12:14.330
反复被这个中断

12:14.330 --> 12:17.330
用户也什么呢

12:17.330 --> 12:20.330
也不会看到什么呢

12:20.330 --> 12:23.330
就是更新不完全的

12:23.330 --> 12:27.330
或者说不完整的这个UI

12:27.330 --> 12:29.330
这个对用户是没有影响的

12:29.330 --> 12:32.330
用户始终看到的是完整的UI

12:32.330 --> 12:33.330
对不对

12:33.330 --> 12:35.330
你这一块它是在内存里面进行的

12:35.330 --> 12:36.330
好

12:36.330 --> 12:41.220
然后接下来当这个scheduler

12:41.220 --> 12:45.220
当这个scheduler

12:45.220 --> 12:47.220
这个调度完成后

12:47.220 --> 12:50.220
调度完成后

12:50.220 --> 12:51.220
将什么呢

12:51.220 --> 12:54.220
将任务交给reconsider

12:54.220 --> 12:58.040
交给reconsider

12:58.040 --> 12:59.040
那这个reconsider

12:59.040 --> 13:00.040
它就需要干嘛呢

13:00.040 --> 13:03.040
它就需要计算出新的UI

13:03.040 --> 13:04.040
对不对

13:04.040 --> 13:06.480
reconsider

13:06.480 --> 13:12.480
就需要计算出新的UI

13:12.480 --> 13:13.480
当这个UI的话

13:13.480 --> 13:14.480
目前仍然是什么

13:14.480 --> 13:16.480
是仍然是在内存里面

13:16.480 --> 13:17.480
好

13:17.480 --> 13:18.480
最后

13:18.480 --> 13:19.480
最后就有什么呢

13:19.480 --> 13:22.480
最后就有

13:22.480 --> 13:24.480
这个render

13:24.480 --> 13:26.480
render

13:26.480 --> 13:27.480
就渲染期

13:27.480 --> 13:29.480
然后最后就有

13:29.480 --> 13:30.480
这个render

13:30.480 --> 13:32.480
同步进行什么呢

13:32.480 --> 13:34.480
进行渲染

13:34.480 --> 13:35.480
更新操作

13:35.480 --> 13:37.480
反复强调

13:37.480 --> 13:38.480
就是你render那的话

13:38.480 --> 13:39.480
它是同步的

13:39.480 --> 13:40.480
这个是同步的

13:40.480 --> 13:42.480
前面这个它是异步

13:42.480 --> 13:43.480
而且可以打断的

13:43.480 --> 13:44.480
最后这个

13:44.480 --> 13:46.480
最后就是这边

13:46.480 --> 13:47.480
这边的话

13:47.480 --> 13:48.480
因为它是在调用

13:48.480 --> 13:51.480
真实的数主环境的API

13:51.480 --> 13:52.480
再进行渲染

13:52.480 --> 13:53.480
所以它这个的话

13:53.480 --> 13:54.480
是同步的

13:54.480 --> 13:55.480
这个是同步的

13:55.480 --> 13:56.480
好

13:56.480 --> 13:57.480
我们这边有张图

13:57.480 --> 13:59.480
我把这张图拉过来

13:59.480 --> 14:00.480
好

14:00.480 --> 14:01.480
这边的话

14:01.480 --> 14:03.480
如下图

14:03.480 --> 14:04.480
说是

14:04.480 --> 14:07.180
OK

14:07.180 --> 14:08.180
你看这边

14:08.180 --> 14:09.180
render阶段

14:09.180 --> 14:10.180
首先你这边

14:10.180 --> 14:11.180
Count

14:11.180 --> 14:13.180
Count等于Count加1

14:13.180 --> 14:14.180
这是不是这个任务

14:14.180 --> 14:15.180
对不对

14:15.180 --> 14:16.180
好

14:16.180 --> 14:17.180
让我这个scheduler

14:17.180 --> 14:18.180
就对这个任务

14:18.180 --> 14:19.180
进行调度

14:19.180 --> 14:20.180
把这个任务交给什么呢

14:20.180 --> 14:22.180
交给这个reconceler

14:22.180 --> 14:23.180
好

14:23.180 --> 14:24.180
reconceler

14:24.180 --> 14:25.180
然后接到这个任务之后

14:25.180 --> 14:26.180
它就开始干嘛

14:26.180 --> 14:27.180
它是不是就开始

14:27.180 --> 14:28.180
这个计算出新的UI

14:28.180 --> 14:29.180
对

14:29.180 --> 14:30.180
比如这个例

14:30.180 --> 14:31.180
从0变成1

14:31.180 --> 14:32.180
这边变成2

14:32.180 --> 14:33.180
这边变成3

14:33.180 --> 14:34.180
把这个新的UI

14:34.180 --> 14:35.180
把它计算出来

14:35.180 --> 14:36.180
计算出来之后

14:36.180 --> 14:37.180
然后接下来

14:37.180 --> 14:38.180
把这个计算结果交给什么

14:38.180 --> 14:40.180
就交给这个render

14:40.180 --> 14:41.180
你注意

14:41.180 --> 14:42.180
它这边在变的时候

14:42.180 --> 14:43.180
它这边呢

14:43.180 --> 14:45.180
会标记这个flag

14:45.180 --> 14:47.180
它会做一个flag的这个标记

14:47.180 --> 14:49.180
然后回头在这个render

14:49.180 --> 14:50.180
这边

14:50.180 --> 14:51.180
它就干嘛呢

14:51.180 --> 14:52.180
它这边呢

14:52.180 --> 14:53.180
就是进行这个update操作

14:53.180 --> 14:54.180
执行这个

14:54.180 --> 14:56.180
dorm更新的这个操作

14:56.180 --> 14:57.180
看到没有

14:57.180 --> 14:58.180
整体的流程的话

14:58.180 --> 15:00.180
实际上就是这样子

15:00.180 --> 15:02.180
整体就这样子

15:02.180 --> 15:03.180
OK

15:03.180 --> 15:05.180
好那把这个整体的流程

15:05.180 --> 15:06.180
大致过了一下之后

15:06.180 --> 15:07.180
那接下来的话

15:07.180 --> 15:08.180
我们这几颗还有个任务

15:08.180 --> 15:10.180
就是我们把每一块

15:10.180 --> 15:11.180
我们大致抽出来

15:11.180 --> 15:12.180
我们看一下

15:12.180 --> 15:13.180
首先

15:13.180 --> 15:15.180
第一个是调度器

15:15.180 --> 15:16.180
然后接下来

15:16.180 --> 15:17.180
第二个

15:17.180 --> 15:18.180
第二个是什么呢

15:18.180 --> 15:22.180
第二个是这个协调器

15:22.180 --> 15:23.180
第三个

15:23.180 --> 15:25.180
第三个是渲染器

15:25.180 --> 15:26.180
你这边的话

15:26.180 --> 15:27.180
你这个

15:27.180 --> 15:28.180
它面试题

15:28.180 --> 15:30.180
它问你这个整体渲染流程

15:30.180 --> 15:31.180
你基本上

15:31.180 --> 15:32.180
这个流程应该说出来

15:32.180 --> 15:33.180
实际上就已经

15:33.180 --> 15:34.180
回答了

15:34.180 --> 15:35.180
它所问的问题了

15:35.180 --> 15:36.180
对不对

15:36.180 --> 15:37.180
但是我们这边的话

15:37.180 --> 15:39.180
我期望同学们就是能够

15:39.180 --> 15:41.180
多说一些就多说一些

15:41.180 --> 15:42.180
对不对

15:42.180 --> 15:43.180
我不仅把这个

15:43.180 --> 15:44.180
每个流程

15:44.180 --> 15:45.180
它经过了一些组件

15:45.180 --> 15:47.180
然后把它这个回答出来

15:47.180 --> 15:48.180
然后每个组件的话

15:48.180 --> 15:49.180
我还可以大致的

15:49.180 --> 15:51.180
描述一下

15:51.180 --> 15:52.180
对不对

15:52.180 --> 15:53.180
好那接下来的话

15:53.180 --> 15:54.180
我们这边一个一个来看

15:54.180 --> 15:56.180
我们首先的话来看什么呢

15:56.180 --> 15:58.180
首先的话来看这个调度器

15:58.180 --> 16:00.180
调度器

16:00.180 --> 16:02.180
调度器

16:02.180 --> 16:03.180
调度器的话

16:03.180 --> 16:04.180
它的主要任务的话

16:04.180 --> 16:07.180
就是对任务进行一个调度

16:07.180 --> 16:09.180
它在这个react 16

16:09.180 --> 16:11.180
版本之前它是没有的

16:11.180 --> 16:12.180
对吧

16:12.180 --> 16:13.180
这个我们上去可以讲过了

16:13.180 --> 16:15.180
在这个react 16版本之前

16:15.180 --> 16:16.180
它是采用了

16:16.180 --> 16:18.180
Stank Reconsider

16:18.180 --> 16:19.180
它没有这个

16:19.180 --> 16:21.180
没有这个调度器

16:21.180 --> 16:23.180
所以就是所有的任务

16:23.180 --> 16:25.180
它只能这个同步自行

16:25.180 --> 16:26.180
不能中断

16:26.180 --> 16:29.180
所以这也就导致了你这个动画

16:29.180 --> 16:31.180
或者这个高优先级的这个更新

16:31.180 --> 16:34.180
它得不到这个即时的这种响应

16:34.180 --> 16:36.180
导致就是在这个视觉上面

16:36.180 --> 16:39.180
产生这个卡顿的这个现象

16:39.180 --> 16:40.180
对吧

16:40.180 --> 16:41.180
那这个react的话

16:41.180 --> 16:43.180
为了就是解决这个问题

16:43.180 --> 16:44.180
它从16版本开始

16:44.180 --> 16:46.180
它就在这个架构上面

16:46.180 --> 16:47.180
做了两大更新

16:47.180 --> 16:49.180
哪两大更新呢

16:49.180 --> 16:51.180
一个是引入这个fiber

16:51.180 --> 16:52.180
fiber的话

16:52.180 --> 16:54.180
你可以把它看作是一种数据结构

16:54.180 --> 16:55.180
这个我们马上下节课

16:55.180 --> 16:57.180
我们还会讲fiber

16:57.180 --> 16:58.180
fiber的话

16:58.180 --> 16:59.180
它看作是一种数据结构

16:59.180 --> 17:00.180
它可以打断

17:00.180 --> 17:01.180
对吧

17:01.180 --> 17:02.180
另外一个就是什么

17:02.180 --> 17:04.180
另外一个就是新增了这个schedule

17:04.180 --> 17:05.180
对吧

17:05.180 --> 17:07.180
我们这边记一下

17:07.180 --> 17:09.180
这个在react

17:10.180 --> 17:12.180
v16

17:12.180 --> 17:14.180
版本之前

17:14.180 --> 17:15.180
然后接下来

17:15.180 --> 17:17.180
采用的是什么

17:17.180 --> 17:18.180
stack

17:19.180 --> 17:21.180
stack架构

17:21.180 --> 17:24.180
然后所有任务只能什么呢

17:24.180 --> 17:26.180
只能同步

17:27.180 --> 17:29.490
进行

17:29.490 --> 17:30.490
对吧

17:30.490 --> 17:33.490
无法被打断

17:33.490 --> 17:34.490
这就导致什么呢

17:34.490 --> 17:37.490
这就导致

17:37.490 --> 17:40.490
导致这个浏览器

17:40.490 --> 17:42.490
可能会出现

17:42.490 --> 17:45.490
丢真的现象

17:45.490 --> 17:46.490
对吧

17:46.490 --> 17:48.490
从而导致卡顿

17:48.490 --> 17:51.490
表现出卡顿

17:51.490 --> 17:53.490
OK

17:53.490 --> 17:55.490
然后这个react

17:55.490 --> 17:57.490
为了解决这个问题

17:57.490 --> 18:00.800
为了解决这个问题

18:00.800 --> 18:03.800
然后从这个v16

18:03.800 --> 18:05.800
版本开始

18:05.800 --> 18:07.800
这个从架构上面

18:07.800 --> 18:09.800
架构上面

18:09.800 --> 18:13.800
进行了2大更新

18:13.800 --> 18:14.800
哪2大更新呢

18:14.800 --> 18:17.800
首先第1个就是引入fiber

18:17.800 --> 18:18.800
对吧

18:18.800 --> 18:19.800
你引入了fiber之后

18:19.800 --> 18:20.800
然后接下来的话

18:20.800 --> 18:22.800
fiber和fiber之间

18:22.800 --> 18:23.800
通过练表的形式

18:23.800 --> 18:24.800
把它串起来

18:24.800 --> 18:25.800
串起来之后

18:25.800 --> 18:26.800
它是可以被打断的

18:26.800 --> 18:28.800
就是你这边在进行

18:28.800 --> 18:30.800
就是这个调和的时候

18:30.800 --> 18:32.800
reconcile的时候

18:32.800 --> 18:33.800
调和的时候

18:33.800 --> 18:35.800
它是可以打断的

18:35.800 --> 18:36.800
第2个就是什么呢

18:36.800 --> 18:38.800
第2个就是新增了

18:38.800 --> 18:41.800
新增了scheduler

18:41.800 --> 18:42.800
对吧

18:42.800 --> 18:43.800
新增了scheduler之后

18:43.800 --> 18:45.800
让所有的任务有了什么呢

18:45.800 --> 18:47.800
有了优先级的这个概念

18:47.800 --> 18:48.800
这样的话

18:48.800 --> 18:50.800
你这个紧急的任务的话

18:50.800 --> 18:52.800
它可以优先执行

18:52.800 --> 18:53.800
这边你要注意

18:53.800 --> 18:55.800
就是scheduler的话

18:55.800 --> 18:57.800
实际上在浏览器的这个API中

18:57.800 --> 19:00.800
它是有这种类似的原生实现的

19:01.800 --> 19:07.800
scheduler在浏览器的原生

19:08.800 --> 19:10.800
原生API中

19:10.800 --> 19:13.800
实际上是有

19:14.800 --> 19:17.800
有类似的实现的

19:17.800 --> 19:19.800
那这个API就是什么呢

19:19.800 --> 19:21.800
这个API

19:21.800 --> 19:24.800
API就是request

19:24.800 --> 19:28.180
idle callback

19:28.180 --> 19:29.180
request

19:29.180 --> 19:30.180
idle

19:30.180 --> 19:33.810
callback

19:33.810 --> 19:34.810
callback

19:35.810 --> 19:36.810
OK

19:36.810 --> 19:38.810
这边大家可以看一下

19:38.810 --> 19:40.810
我把这边打开

19:41.810 --> 19:43.810
这边对应的是mdn

19:43.810 --> 19:45.810
把这个地址放到笔记里面

19:50.300 --> 19:52.300
把它放到这边

19:52.300 --> 19:53.300
这个是mdn

19:53.300 --> 19:54.300
前面加一个

19:55.300 --> 19:57.300
这边是mdn

19:57.300 --> 20:00.610
它的这个链接

20:00.610 --> 20:02.610
这边让我们回到mdn

20:02.610 --> 20:03.610
我们这边来看一下

20:03.610 --> 20:05.610
这个window.request

20:05.610 --> 20:06.610
idle callback

20:06.610 --> 20:08.610
这个方法它是什么呢

20:08.610 --> 20:10.610
它是插入一个函数

20:10.610 --> 20:12.610
这个函数的话将在浏览器

20:12.610 --> 20:14.610
空闲时期被调用

20:14.610 --> 20:15.610
看到没有

20:15.610 --> 20:17.610
会在空闲时期被调用

20:17.610 --> 20:19.610
这是开发者能够什么呢

20:19.610 --> 20:21.610
能够在主事件循环上

20:21.610 --> 20:24.610
执行后台和低优先级这个工作

20:24.610 --> 20:26.610
然后我们这边来看一下

20:26.610 --> 20:27.610
这个使用

20:27.610 --> 20:29.610
它这边那是request

20:29.610 --> 20:30.610
idle callback

20:30.610 --> 20:32.610
这边传入一个什么呢

20:32.610 --> 20:33.610
传入一个callback

20:33.610 --> 20:35.610
就是你的回调函数

20:35.610 --> 20:36.610
那这个回调函数

20:36.610 --> 20:38.610
会在什么时候执行呢

20:38.610 --> 20:40.610
这回调函数就会在你这个

20:41.610 --> 20:42.610
比如你每一帧

20:42.610 --> 20:43.610
每一帧他这个渲染完

20:43.610 --> 20:45.610
他是不是有这个剩余时间

20:45.610 --> 20:46.610
对了

20:46.610 --> 20:49.610
它就会在这个剩余时间之后执行

20:49.610 --> 20:51.610
因为我们之前讲过

20:51.610 --> 20:52.610
是上几个吧

20:52.610 --> 20:54.610
我们讲过这个浏览器

20:54.610 --> 20:57.610
它每个16.66毫秒是比较渲染

20:57.610 --> 20:58.610
对不对

20:58.610 --> 20:59.610
那它有的时候的话

20:59.610 --> 21:00.610
它这个渲染

21:00.610 --> 21:02.610
花不了那么长时间

21:02.610 --> 21:03.610
对不对

21:03.610 --> 21:04.610
它可能几毫秒就渲染完了

21:04.610 --> 21:05.610
那剩下的时间

21:05.610 --> 21:06.610
它就干嘛呢

21:06.610 --> 21:09.610
你这边它就可以调用这个API

21:09.610 --> 21:10.610
执行它的这个

21:10.610 --> 21:13.610
就是你传入的这个callback

21:13.610 --> 21:14.610
OK

21:14.610 --> 21:16.610
来我们这边我们来看一下吧

21:16.610 --> 21:17.610
我们来看一下

21:17.610 --> 21:18.610
我们举个例子

21:19.610 --> 21:21.610
我们这边还是新建一个

21:21.610 --> 21:26.390
我们在桌面上

21:26.390 --> 21:28.390
index.html

21:28.390 --> 21:33.660
我们这边的话script

21:33.660 --> 21:34.660
我们这边怎么做呢

21:34.660 --> 21:36.660
我们这边就调window

21:36.660 --> 21:38.660
window.callback

21:38.660 --> 21:40.660
叫做request

21:40.660 --> 21:43.660
request.idlecallback

21:43.660 --> 21:45.660
这边需要你传入一个callback

21:45.660 --> 21:46.660
对不对

21:46.660 --> 21:48.660
那接下来我们这边方形

21:48.660 --> 21:53.000
callback

21:53.000 --> 21:54.000
OK

21:54.000 --> 21:56.000
那接下来我们把这个callback

21:56.000 --> 21:57.000
我们把它传过来

21:57.000 --> 21:58.000
传过来之后

21:58.000 --> 22:00.000
然后再在这个callback里面

22:00.000 --> 22:01.000
说什么呢

22:01.000 --> 22:02.000
在callback里面

22:02.000 --> 22:03.000
它这边这个callback

22:03.000 --> 22:05.000
就你这个回调函数这边

22:05.000 --> 22:06.000
它接受一个参数

22:06.000 --> 22:08.000
你看一下

22:08.000 --> 22:09.000
这边callback

22:09.000 --> 22:11.000
它这边有一个options

22:11.000 --> 22:13.000
我看是不是这个

22:13.000 --> 22:14.000
不是

22:14.000 --> 22:16.000
这个options是

22:16.000 --> 22:17.000
我看一下

22:17.000 --> 22:18.000
这个是这边

22:18.000 --> 22:20.000
这边这个options

22:20.000 --> 22:22.000
还有一个timeout

22:22.000 --> 22:23.000
我记得这个

22:23.000 --> 22:24.000
这里

22:24.000 --> 22:25.000
这边这个callback

22:25.000 --> 22:27.000
这callback接受一个什么

22:27.000 --> 22:28.000
接受一个叫做

22:28.000 --> 22:30.000
idle.net这个参数

22:30.000 --> 22:31.000
这个参数的话

22:31.000 --> 22:33.000
可以获取当前空前时间

22:33.000 --> 22:35.000
以及这个回调

22:35.000 --> 22:37.000
是否在超时时间前

22:37.000 --> 22:38.000
以执行的这个状态

22:38.000 --> 22:39.000
我们这边

22:39.000 --> 22:40.000
我们把这个

22:40.000 --> 22:42.440
我们把拿过来

22:42.440 --> 22:43.440
我们在这边

22:43.440 --> 22:44.440
把拿过来

22:44.440 --> 22:45.440
拿过来之后

22:45.440 --> 22:46.440
然后接下来我们这边

22:46.440 --> 22:47.440
我们来打印一下

22:49.440 --> 22:51.440
这边那就是当前增

22:51.440 --> 22:55.460
当前增

22:56.460 --> 22:57.460
当前增

22:57.460 --> 22:59.460
汇制完毕后

23:00.460 --> 23:03.460
汇制完毕后

23:03.460 --> 23:06.460
所剩余的时间

23:06.460 --> 23:09.220
ok

23:09.220 --> 23:10.220
它这玩意的话

23:10.220 --> 23:11.220
它是一个对象

23:11.220 --> 23:13.220
就这个idle.net

23:13.220 --> 23:14.220
它是个对象

23:14.220 --> 23:15.220
对象里面的话

23:15.220 --> 23:16.220
它有一个什么呢

23:16.220 --> 23:18.220
有一个这个叫做timeout remaining

23:18.220 --> 23:20.220
这边你可以点过去看

23:20.220 --> 23:22.220
这边我们点过来看

23:23.220 --> 23:25.220
它这边会有一个这个

23:25.220 --> 23:27.220
timeout remaining

23:27.220 --> 23:29.220
它是这个返回一个时间

23:29.220 --> 23:31.220
用来表示当前

23:31.220 --> 23:32.220
闲至周期

23:32.220 --> 23:34.220
预估剩余的这个好秒数

23:34.220 --> 23:36.220
说你这边可以直接掉这个

23:37.220 --> 23:38.220
掉这个方法

23:40.220 --> 23:41.220
ok

23:41.220 --> 23:42.220
当前增

23:42.220 --> 23:43.220
汇制完毕之后

23:43.220 --> 23:44.220
剩余的这个时间

23:44.220 --> 23:45.220
好

23:45.220 --> 23:46.220
然后回头的话

23:46.220 --> 23:47.220
这边我们再来掉什么呢

23:47.220 --> 23:51.190
再来掉它

23:51.190 --> 23:52.190
对吧

23:52.190 --> 23:53.190
再来掉它

23:53.190 --> 23:54.190
保存一下

23:54.190 --> 23:55.190
保存了之后

23:55.190 --> 23:56.190
然后接下来我们这边的话

23:56.190 --> 23:57.190
我们把它打开

23:57.190 --> 24:01.360
我们看一下

24:01.360 --> 24:02.360
你看这边

24:02.360 --> 24:04.360
这边它就会不停的打印

24:04.360 --> 24:06.360
我们最开始剩这个6毫秒

24:06.360 --> 24:07.360
再加这个14多

24:07.360 --> 24:08.360
再加这边

24:08.360 --> 24:10.360
这边这有点奇怪

24:10.360 --> 24:11.360
对不对

24:11.360 --> 24:14.360
为什么这边接近50毫秒了

24:14.360 --> 24:15.360
50毫秒

24:15.360 --> 24:16.360
这边的话

24:16.360 --> 24:17.360
又是12对不对

24:17.360 --> 24:18.360
15

24:18.360 --> 24:19.360
31

24:19.360 --> 24:20.360
49

24:20.360 --> 24:21.360
有一些的话

24:21.360 --> 24:22.360
它会干嘛

24:22.360 --> 24:23.360
有一些的话

24:23.360 --> 24:24.360
它会接近于50毫秒

24:24.360 --> 24:26.360
这个究竟是怎么回事呢

24:26.360 --> 24:30.570
这边是这样子的

24:30.570 --> 24:32.570
就是浏览器

24:32.570 --> 24:33.570
就虽然

24:34.570 --> 24:36.570
虽然每一针

24:36.570 --> 24:39.570
汇制的这个时间

24:39.570 --> 24:40.570
约为什么呢

24:40.570 --> 24:44.570
约为16.66毫秒

24:44.570 --> 24:45.570
对不对

24:45.570 --> 24:46.570
但是

24:46.570 --> 24:51.570
如果屏幕没有刷新

24:51.570 --> 24:52.570
比如像我们这边

24:52.570 --> 24:53.570
我们这边你看

24:53.570 --> 24:54.570
就是个空白的屏幕

24:54.570 --> 24:55.570
啥都没有

24:55.570 --> 24:56.570
对吧

24:56.570 --> 24:57.570
啥都没有的话

24:57.570 --> 24:58.570
那这边是不是就屏幕没有刷新

24:58.570 --> 24:59.570
屏幕没有刷新的话

24:59.570 --> 25:02.570
那么浏览器会安排

25:02.570 --> 25:05.570
这个就是长度

25:05.570 --> 25:10.570
为50毫秒左右的空线时间

25:10.570 --> 25:12.570
因为你没有刷新嘛

25:12.570 --> 25:13.570
对不对

25:13.570 --> 25:16.570
那为什么是50毫秒呢

25:16.570 --> 25:20.570
为什么是50毫秒

25:20.570 --> 25:21.570
这个的话是

25:21.570 --> 25:23.570
根据这个研究报告表明

25:23.570 --> 25:25.570
就用户进行操作之后

25:25.570 --> 25:28.570
你这个100毫秒以内的

25:28.570 --> 25:29.570
这种响应

25:29.570 --> 25:32.570
给用户的这种感觉都是瞬间发生的

25:32.570 --> 25:34.570
所以你像这个空线

25:34.570 --> 25:36.570
这个时间设置为50

25:36.570 --> 25:37.570
那么浏览器

25:37.570 --> 25:38.570
这个就是接下来的话

25:38.570 --> 25:39.570
它还剩下什么

25:39.570 --> 25:42.570
是不是还剩下这个50毫秒

25:42.570 --> 25:45.570
可以处理这个用户的响应

25:45.570 --> 25:46.570
对不对

25:46.570 --> 25:49.570
用户的话不会感觉到这个延迟

25:49.570 --> 25:52.570
根据研究报告

25:52.570 --> 25:54.570
报告表明

25:54.570 --> 25:57.070
什么呢

25:57.070 --> 25:59.070
就是100毫秒

25:59.070 --> 26:01.070
就用户操作之后

26:01.070 --> 26:04.070
用户操作之后

26:04.070 --> 26:09.070
这个100毫秒以内的这个响应

26:09.070 --> 26:11.070
给用户的感觉

26:11.070 --> 26:14.070
用户的感觉都是什么呢

26:14.070 --> 26:18.070
都是这个瞬间发生的

26:18.070 --> 26:20.070
也就是说

26:20.070 --> 26:21.070
也就是说

26:21.070 --> 26:25.070
不会感受到延迟

26:25.070 --> 26:27.070
不会感受到延迟感

26:27.070 --> 26:30.070
不会感受到延迟感

26:30.070 --> 26:32.070
因此将什么呢

26:32.070 --> 26:35.070
将这个空线时间

26:35.070 --> 26:40.070
空线时间设置为50

26:40.070 --> 26:42.070
那么浏览器

26:42.070 --> 26:44.070
依然

26:44.070 --> 26:46.070
依然还剩下什么

26:46.070 --> 26:49.070
还剩下50毫秒

26:49.070 --> 26:50.070
可以什么

26:50.070 --> 26:56.860
可以处理这个用户的操作响应

26:56.860 --> 26:58.860
不会让用户感到什么

26:58.860 --> 27:00.860
不会让用户感到延迟

27:00.860 --> 27:06.860
不会让用户感到就是延迟

27:06.860 --> 27:07.860
ok

27:07.860 --> 27:09.860
说你这边可以看到这边

27:09.860 --> 27:11.860
如果一旦你这个没有刷新

27:11.860 --> 27:12.860
对吧

27:12.860 --> 27:14.860
你这个这个屏幕没有什么刷新

27:14.860 --> 27:15.860
没有什么要改变了

27:15.860 --> 27:16.860
说他这边是什么呢

27:16.860 --> 27:17.860
是50

27:17.860 --> 27:18.860
你看后面基本都是50了

27:18.860 --> 27:19.860
看到没有

27:19.860 --> 27:21.860
后面基本都是50了

27:21.860 --> 27:23.860
但没有超过50的

27:23.860 --> 27:25.860
最大是不是就是50了

27:25.860 --> 27:26.860
对不对

27:26.860 --> 27:27.860
也就是你什么意思呢

27:27.860 --> 27:28.860
就是你本来是

27:28.860 --> 27:31.860
每隔16.66毫秒要汇制下一次吗

27:31.860 --> 27:32.860
对不对

27:32.860 --> 27:35.860
每隔16.66毫秒就要重新汇制

27:35.860 --> 27:37.860
但是你现在让你屏幕

27:37.860 --> 27:38.860
就没有什么动画效果

27:38.860 --> 27:39.860
说他就每隔什么的

27:39.860 --> 27:41.860
每隔这个基本50毫秒

27:41.860 --> 27:43.860
他这边应该是100

27:43.860 --> 27:44.860
应该是100

27:44.860 --> 27:45.860
他这边50毫秒

27:45.860 --> 27:46.860
剩下50毫秒

27:46.860 --> 27:48.860
然后接下来去处理其他的东西

27:48.860 --> 27:49.860
ok

27:49.860 --> 27:50.860
看到没有

27:50.860 --> 27:53.860
那我如果我把这换一下

27:53.860 --> 27:54.860
刷新一下

27:54.860 --> 27:56.860
现在是不是依然是50

27:56.860 --> 27:57.860
对吧

27:57.860 --> 27:58.860
先依然是50

27:58.860 --> 28:00.860
我们现在我们把这个改一下

28:00.860 --> 28:01.860
改一下

28:01.860 --> 28:03.860
我们让他屏幕有刷新

28:03.860 --> 28:05.860
如何让他有刷新

28:05.860 --> 28:06.860
如何让他有刷新

28:06.860 --> 28:08.860
我们把那个上级和那个小球的例子

28:08.860 --> 28:10.860
是不是拿过来就可以了

28:10.860 --> 28:11.860
对吧

28:11.860 --> 28:13.860
我们把那个上级和小球的例子

28:13.860 --> 28:15.860
把这带马拿过来

28:15.860 --> 28:16.860
好

28:16.860 --> 28:17.860
然后接下来这边的

28:17.860 --> 28:19.860
style

28:19.860 --> 28:22.860
这边这个小球

28:22.860 --> 28:28.340
把它绑一个动画

28:28.340 --> 28:29.340
那你这样子的话

28:29.340 --> 28:30.340
你屏幕是不是就会有刷新

28:30.340 --> 28:31.340
对吧

28:31.340 --> 28:32.340
好来接下来

28:32.340 --> 28:33.340
我们再来看一下

28:33.340 --> 28:34.340
重新刷新一下

28:34.340 --> 28:35.340
你看

28:35.340 --> 28:37.340
那现在的话基本就是隔多少

28:37.340 --> 28:39.340
隔10多毫秒

28:39.340 --> 28:40.340
对不对

28:40.340 --> 28:41.340
基本就是隔10多毫秒

28:41.340 --> 28:43.340
就不会再出现那种50了

28:43.340 --> 28:44.340
为什么

28:44.340 --> 28:46.340
因为你屏幕要需要刷新啊

28:46.340 --> 28:47.340
对不对

28:47.340 --> 28:50.340
需要刷新来让这个动画

28:50.340 --> 28:52.340
非常流畅的播放出来

28:52.340 --> 28:55.100
对不对

28:55.100 --> 28:57.100
这是这个

28:57.100 --> 28:59.100
把这个

28:59.100 --> 29:01.100
把这个打印

29:01.100 --> 29:02.100
把它

29:02.100 --> 29:04.100
把这个注射掉吧

29:04.100 --> 29:06.100
免了它一直的打印

29:06.100 --> 29:07.100
好

29:07.100 --> 29:09.100
这是关于这个

29:09.100 --> 29:11.100
request

29:11.100 --> 29:12.100
idol callback

29:12.100 --> 29:15.310
我们这边呢

29:15.310 --> 29:17.310
实际上还可以通过这个

29:17.310 --> 29:19.310
通过这个去模拟这个scheduler

29:19.310 --> 29:21.310
比如我们回到这边

29:21.310 --> 29:22.310
回到这边

29:22.310 --> 29:24.310
我们把刚才写的这些注射掉

29:24.310 --> 29:26.310
刚才写的那个例子

29:26.310 --> 29:28.310
好那接下来下面

29:28.310 --> 29:30.310
通过什么呢

29:30.310 --> 29:32.310
通过这个request idol callback

29:32.310 --> 29:36.310
去模拟scheduler

29:36.310 --> 29:39.310
scheduler的这个工作

29:39.310 --> 29:41.310
流程

29:41.310 --> 29:42.310
怎么模拟呢

29:42.310 --> 29:43.310
比如说现在的话

29:43.310 --> 29:45.310
我这边const

29:45.310 --> 29:47.310
一个这个task

29:47.310 --> 29:49.310
task list

29:49.310 --> 29:52.310
这边是一个空数组

29:52.310 --> 29:53.310
这个数组它就是什么呢

29:53.310 --> 29:57.310
这个就是存放任务的对立

29:57.310 --> 30:00.750
存放

30:00.750 --> 30:02.750
存放任务的这个对立

30:02.750 --> 30:04.750
好

30:04.750 --> 30:05.750
然后回头的话

30:05.750 --> 30:06.750
我这边的话

30:06.750 --> 30:08.750
首先的话我把它这个推入任务

30:08.750 --> 30:12.380
推入任务

30:12.380 --> 30:13.380
然后这边的话

30:13.380 --> 30:14.380
我写个for换

30:14.380 --> 30:17.820
net一个i等于一个0

30:17.820 --> 30:19.820
i小于一个比如说

30:19.820 --> 30:21.820
小于等于一个10

30:21.820 --> 30:23.820
ok

30:23.820 --> 30:24.820
好然后接下来

30:24.820 --> 30:26.820
我往这个task list里面

30:26.820 --> 30:28.820
点push

30:28.820 --> 30:29.820
因为它是个数组

30:29.820 --> 30:30.820
对对

30:30.820 --> 30:31.820
push的话

30:31.820 --> 30:32.820
这个任务任务

30:32.820 --> 30:33.820
我就用一个这个

30:33.820 --> 30:34.820
件头函数

30:34.820 --> 30:36.820
ok

30:36.820 --> 30:37.820
那接下来每个函数

30:37.820 --> 30:38.820
就是一个任务

30:38.820 --> 30:40.820
比如这边cancel

30:40.820 --> 30:42.820
cancel.log

30:42.820 --> 30:44.820
比如这边是执行

30:44.820 --> 30:47.820
执行任务

30:47.820 --> 30:48.820
执行任务

30:48.820 --> 30:51.820
这边是downer

30:51.820 --> 30:52.820
downer i

30:52.820 --> 30:53.820
我们这边i等于1吧

30:53.820 --> 30:54.820
等于1

30:54.820 --> 30:56.820
执行这个任务

30:56.820 --> 30:57.820
这边i等于1

30:57.820 --> 30:58.820
这边就是执行任务1

30:58.820 --> 30:59.820
执行任务2

30:59.820 --> 31:01.820
我这边现在有这么10个任务

31:01.820 --> 31:03.820
好有这么10个任务之后

31:03.820 --> 31:04.820
然后接下来

31:04.820 --> 31:05.820
我们这边我们来执行它

31:05.820 --> 31:09.780
好

31:09.780 --> 31:11.780
接下来

31:11.780 --> 31:13.780
接下来

31:13.780 --> 31:15.780
我们想要什么呢

31:15.780 --> 31:18.780
想要执行任务

31:18.780 --> 31:19.780
那想要执行任务

31:19.780 --> 31:20.780
我想在什么呢

31:20.780 --> 31:21.780
想在这个

31:21.780 --> 31:22.780
每一帧

31:22.780 --> 31:23.780
你每一帧渲染之后

31:23.780 --> 31:25.780
不是有剩余时间吗

31:25.780 --> 31:26.780
对

31:26.780 --> 31:29.780
每一帧渲染完毕

31:29.780 --> 31:32.780
有这个剩余时间

31:32.780 --> 31:33.780
剩余时间

31:33.780 --> 31:35.780
然后接下来

31:35.780 --> 31:39.780
如果时间充足

31:39.780 --> 31:40.780
我们就怎么了

31:40.780 --> 31:43.780
我们就执行任务

31:43.780 --> 31:45.780
然后如果时间不充足

31:45.780 --> 31:48.780
我们这边把这个注释换下行

31:48.780 --> 31:52.780
如果时间不充足

31:52.780 --> 31:53.780
那就干嘛呢

31:53.780 --> 31:55.780
那就先渲染

31:55.780 --> 31:56.780
对不对

31:56.780 --> 31:59.780
那么就在这个下一帧

31:59.780 --> 32:02.780
下一帧渲染后

32:02.780 --> 32:04.780
渲染后

32:04.780 --> 32:06.780
在接着执行

32:06.780 --> 32:07.780
你看这个思想的话

32:07.780 --> 32:09.780
是不是就和那个scheduler

32:09.780 --> 32:10.780
那个思想是一样的

32:10.780 --> 32:11.780
对不对

32:11.780 --> 32:12.780
进行一个任务的这个调度

32:12.780 --> 32:13.780
好

32:13.780 --> 32:14.780
那我们这边就使用什么呢

32:14.780 --> 32:15.780
就使用window

32:15.780 --> 32:18.780
window.request

32:18.780 --> 32:20.780
idocallback

32:20.780 --> 32:22.780
对吧

32:22.780 --> 32:23.780
好

32:23.780 --> 32:24.780
然后加这边的这个方形

32:24.780 --> 32:26.780
然后callback

32:26.780 --> 32:29.090
OK

32:29.090 --> 32:30.090
好

32:30.090 --> 32:31.090
把这个callback的话

32:31.090 --> 32:32.090
把它丢过去

32:32.090 --> 32:33.090
丢过去之后

32:33.090 --> 32:34.090
然后接下来这边

32:34.090 --> 32:36.090
执行你要做的事情

32:36.090 --> 32:37.090
执行任务

32:37.090 --> 32:41.420
执行任务

32:41.420 --> 32:44.700
OK

32:44.700 --> 32:45.700
好

32:45.700 --> 32:46.700
这边该怎么写

32:46.700 --> 32:47.700
这边你可以首先打印一下

32:47.700 --> 32:48.700
我们这边还是

32:48.700 --> 32:49.700
把刚才那个

32:49.700 --> 32:50.700
把它打印出来

32:50.700 --> 32:52.700
这边这个idol9

32:52.700 --> 32:56.070
idol dead9

32:56.070 --> 32:57.070
对吧

32:57.070 --> 32:59.070
大家这边这个打印

33:00.070 --> 33:02.070
当前正剩余的这个时间

33:02.070 --> 33:04.960
OK

33:04.960 --> 33:05.960
好打印完了之后

33:05.960 --> 33:06.960
然后接下来

33:06.960 --> 33:07.960
我们这边这个wild

33:07.960 --> 33:12.490
我们写个wild循环

33:12.490 --> 33:13.490
写个wild循环

33:13.490 --> 33:14.490
wild这边什么呢

33:14.490 --> 33:15.490
wild你这边

33:15.490 --> 33:18.490
这个剩余的这个时间

33:18.490 --> 33:19.490
他干嘛呢

33:19.490 --> 33:21.490
他如果大于零

33:21.490 --> 33:22.490
大于零是不是说明

33:22.490 --> 33:23.490
还有剩余的时间

33:23.490 --> 33:25.490
and and 什么呢

33:25.490 --> 33:28.490
task list 点认识

33:28.490 --> 33:29.490
并且什么呢

33:29.490 --> 33:30.490
并且你这个

33:30.490 --> 33:32.490
任务列表里面还有任务

33:32.490 --> 33:33.490
对不对

33:33.490 --> 33:34.490
这个循环条件

33:34.490 --> 33:36.490
就是还有剩余时间

33:36.490 --> 33:38.490
我们写到写到这里面

33:41.490 --> 33:42.490
还有

33:42.490 --> 33:44.490
还有剩余时间

33:44.490 --> 33:46.490
然后并且

33:46.490 --> 33:48.490
这个任务列表

33:48.490 --> 33:50.490
任务列表

33:50.490 --> 33:51.490
还有任务

33:51.490 --> 33:52.490
OK

33:52.490 --> 33:53.490
那就干嘛呢

33:53.490 --> 33:54.490
那接下来

33:54.490 --> 33:55.490
我们就从这个任务列表里面

33:55.490 --> 33:56.490
我们取出来一个

33:56.490 --> 33:59.490
task 点task list

33:59.490 --> 34:01.490
然后接下来shift

34:01.490 --> 34:04.490
这边 const 一个task

34:04.490 --> 34:06.490
是不是取出一个任务

34:06.490 --> 34:07.490
取出一个任务

34:07.490 --> 34:08.490
他取出来是什么

34:08.490 --> 34:09.490
我们这边是不是推进去了

34:09.490 --> 34:10.490
是一个一个的函数

34:10.490 --> 34:11.490
那你这边取出来

34:11.490 --> 34:12.490
是不是也是函数

34:12.490 --> 34:13.490
取出来之后

34:13.490 --> 34:15.490
然后加这边task

34:15.490 --> 34:17.490
是不是执行

34:17.490 --> 34:18.490
对不对

34:18.490 --> 34:19.490
执行

34:19.490 --> 34:20.490
执行完了之后

34:20.490 --> 34:21.490
然后加如果这个

34:21.490 --> 34:23.490
他退出这个wild

34:23.490 --> 34:24.490
他什么时候会退出wild

34:24.490 --> 34:25.490
这个wild

34:25.490 --> 34:27.490
什么时候会退出这个wild

34:27.490 --> 34:29.490
要么是不是就是时间不够了

34:29.490 --> 34:30.490
要么是不是就是你这个

34:30.490 --> 34:32.490
任务执行完了

34:32.490 --> 34:33.490
对不对

34:33.490 --> 34:34.490
那你如果这个

34:34.490 --> 34:35.490
退出这个wild

34:35.490 --> 34:37.490
有一种可能是任务还有

34:37.490 --> 34:38.490
但是时间不够了

34:38.490 --> 34:39.490
所以你这边

34:39.490 --> 34:42.860
他需要进行个判断

34:42.860 --> 34:45.860
if 这边task

34:45.860 --> 34:46.860
就你退出了之后

34:46.860 --> 34:47.860
你还需要判断

34:47.860 --> 34:49.860
他是否还有任务

34:49.860 --> 34:51.860
退出

34:51.860 --> 34:53.860
退出

34:53.860 --> 34:56.860
上面的这个wild

34:56.860 --> 34:57.860
后

34:57.860 --> 34:59.860
有一种情况

34:59.860 --> 35:00.860
有一种情况

35:00.860 --> 35:01.860
是什么呢

35:01.860 --> 35:03.860
是这个就是时间不够了

35:03.860 --> 35:07.370
就当前正

35:07.370 --> 35:11.370
当前正的这个时间不够了

35:11.370 --> 35:12.370
对不对

35:12.370 --> 35:14.370
但是任务

35:14.370 --> 35:17.370
但是任务列表中

35:17.370 --> 35:19.370
任务列表中

35:19.370 --> 35:20.370
还有什么

35:20.370 --> 35:22.370
还有剩余任务

35:22.370 --> 35:23.370
对不对

35:23.370 --> 35:25.370
那下还有剩余任务怎么办

35:25.370 --> 35:27.370
这边继续

35:27.370 --> 35:30.370
window.request.idolcallback

35:30.370 --> 35:31.370
对不对

35:31.370 --> 35:32.370
对不对

35:32.370 --> 35:35.370
那我们这边就是在下一阵

35:35.370 --> 35:39.370
那么我们就在下一阵

35:39.370 --> 35:41.370
空闲时间

35:41.370 --> 35:43.370
然后再什么呢

35:43.370 --> 35:46.370
再继续执行任务

35:46.370 --> 35:48.370
是不是就应该是这样子

35:48.370 --> 35:49.370
对不对

35:49.370 --> 35:51.370
好 那我们这边来看一下

35:51.370 --> 35:52.370
这边刷新一下

35:52.370 --> 35:55.370
当前正剩余这个8.4秒

35:55.370 --> 35:57.370
然后家所有任务是不是执行完了

35:57.370 --> 35:58.370
对不对

35:58.370 --> 35:59.370
因为我们这个任务

36:00.370 --> 36:01.370
对不对

36:01.370 --> 36:02.370
那我们这边的话

36:02.370 --> 36:03.370
我们来

36:03.370 --> 36:04.370
我们手动的把这个任务

36:04.370 --> 36:07.370
比如说我们这边给他加点这个延迟

36:07.370 --> 36:09.370
好 比如说我这边写一个这个

36:09.370 --> 36:10.370
手动延迟

36:10.370 --> 36:12.370
方形

36:12.370 --> 36:13.370
方形DNA

36:13.370 --> 36:18.220
好 这边接受一个什么呢

36:18.220 --> 36:21.220
接受一个duration

36:21.220 --> 36:22.220
接受一个duration

36:22.220 --> 36:24.220
然后家这边进行一个延迟

36:24.220 --> 36:26.220
Const一个start

36:26.220 --> 36:30.220
等于一个date.nau

36:30.220 --> 36:31.220
好 然后家这边

36:31.220 --> 36:32.220
做一个什么呢

36:32.220 --> 36:34.220
做一个wile

36:34.220 --> 36:36.220
这个wile的话什么都不做

36:36.220 --> 36:39.220
这边就是date.nau

36:39.220 --> 36:42.220
然后剪什么呢

36:42.220 --> 36:44.220
剪这个start

36:44.220 --> 36:45.220
要什么呢

36:45.220 --> 36:47.220
要小于这个duration

36:47.220 --> 36:48.220
只要你这边

36:48.220 --> 36:50.220
当前时间剪这个start

36:50.220 --> 36:52.220
小于你这边延长的时间

36:52.220 --> 36:54.220
我这边就一直在wile里面

36:54.220 --> 36:55.220
对吧

36:55.220 --> 36:56.220
好 那接下来我这边

36:56.220 --> 36:58.220
我这边推入的每一个任务

36:58.220 --> 36:59.220
我这边加一个什么呢

36:59.220 --> 37:00.220
加一个delay

37:00.220 --> 37:01.220
对不对

37:01.220 --> 37:02.220
手动的话

37:02.220 --> 37:03.220
比如这个任务需要花费

37:03.220 --> 37:04.220
这个10毫秒

37:04.220 --> 37:06.220
好 那接下来我们这边

37:06.220 --> 37:07.220
再来看一下

37:07.220 --> 37:08.220
你看刚才

37:08.220 --> 37:09.220
刚才那是不是

37:09.220 --> 37:10.220
所有都在一帧里面

37:10.220 --> 37:11.220
就执行完了

37:11.220 --> 37:12.220
你现在再刷新一下

37:12.220 --> 37:14.220
你看 当前剩于14.4

37:14.220 --> 37:16.220
执行了任务1 任务2

37:16.220 --> 37:18.220
当前剩于4.5

37:18.220 --> 37:19.220
执行了任务3

37:19.220 --> 37:20.220
当前剩于8.4

37:20.220 --> 37:22.220
执行了任务4

37:22.220 --> 37:23.220
看到没有

37:23.220 --> 37:24.220
我这边那是不是

37:24.220 --> 37:26.220
就是把这个不同的任务

37:26.220 --> 37:27.220
穿插到什么

37:27.220 --> 37:29.220
都穿插到了不同帧里面去

37:30.220 --> 37:31.220
对不对

37:31.220 --> 37:32.220
你看这边

37:32.220 --> 37:33.220
OK

37:33.220 --> 37:35.220
这个的话就是什么呢

37:35.220 --> 37:37.220
这个的话就是request

37:37.220 --> 37:39.220
IdoCallback

37:39.220 --> 37:41.220
OK 浏览器其实原生

37:41.220 --> 37:43.220
就有类似的实现

37:43.220 --> 37:45.220
但是react团队它没有用

37:46.220 --> 37:47.220
对不对

37:47.220 --> 37:48.220
它没有用

37:48.220 --> 37:49.220
虽然

37:51.220 --> 37:53.220
虽然浏览器

37:53.220 --> 37:54.220
有什么呢

37:54.220 --> 37:56.220
有类似的这个API

37:58.220 --> 38:01.220
但是react团队

38:01.220 --> 38:05.220
并没有使用该API

38:05.220 --> 38:06.220
为什么呢

38:06.220 --> 38:08.220
原因很简单

38:08.220 --> 38:09.220
就是因为这个API

38:09.220 --> 38:11.220
它有兼容性问题

38:11.220 --> 38:14.220
因为该这个API

38:14.220 --> 38:17.220
存在兼容性问题

38:18.220 --> 38:19.220
因此

38:19.220 --> 38:22.220
这个react团队

38:22.220 --> 38:25.220
就是自己实现了一套

38:26.220 --> 38:28.220
这样的机制

38:29.220 --> 38:31.220
这个就是什么呢

38:31.220 --> 38:33.220
这个就是调度器

38:33.220 --> 38:35.220
scheduler

38:35.220 --> 38:37.720
OK

38:37.720 --> 38:39.720
这个就是scheduler

38:39.720 --> 38:41.720
根据react团队的想法

38:41.720 --> 38:44.720
它们后期的话是会把scheduler

38:44.720 --> 38:46.720
这个包单独进行发行的

38:46.720 --> 38:48.720
变成一个独立的包

38:48.720 --> 38:49.720
那这个也就意味着什么呢

38:49.720 --> 38:51.720
意味着就是你这个scheduler

38:51.720 --> 38:54.720
它不仅仅是只能在react里面用

38:54.720 --> 38:56.720
你如果比如说有其他的这个项目

38:56.720 --> 38:58.720
涉及到了什么呢

38:58.720 --> 39:00.720
涉及到了这个任务调度的这个需求

39:00.720 --> 39:02.720
那么你就可以使用什么

39:02.720 --> 39:04.720
就可以使用这个scheduler

39:04.720 --> 39:06.720
这个调度器

39:06.720 --> 39:07.720
对不对

39:07.720 --> 39:08.720
后期

39:08.720 --> 39:10.720
后期react团队

39:11.720 --> 39:13.720
打算单独发行

39:14.720 --> 39:17.720
单独发行这个scheduler

39:18.720 --> 39:20.720
这意味着

39:20.720 --> 39:23.720
这意味着调度器

39:23.720 --> 39:25.720
不仅仅

39:25.720 --> 39:27.720
只能

39:27.720 --> 39:29.720
只能

39:29.720 --> 39:31.720
在这个react中

39:31.720 --> 39:33.720
使用

39:33.720 --> 39:35.720
凡是

39:35.720 --> 39:39.720
凡是有涉及到这个任务调度

39:39.720 --> 39:42.720
凡是有涉及到任务调度的这个

39:42.720 --> 39:45.720
任务调度需求的这个项目

39:45.720 --> 39:47.720
都可以

39:47.720 --> 39:48.720
使用

39:48.720 --> 39:49.720
是不是scheduler

39:49.720 --> 39:52.860
对

39:52.860 --> 39:53.860
对的

39:53.860 --> 39:55.860
只要你有这个任务调度的需求

39:55.860 --> 39:56.860
都可以使用

39:56.860 --> 39:59.860
这是关于这个调度器

39:59.860 --> 40:00.860
ok

40:00.860 --> 40:02.860
这调度器

40:02.860 --> 40:03.860
好

40:03.860 --> 40:04.860
然后接下来的话

40:04.860 --> 40:05.860
我们来看什么呢

40:05.860 --> 40:07.860
接下来我们来看一下这个协调器

40:07.860 --> 40:09.860
协调器的话对呢就是

40:09.860 --> 40:10.860
这边

40:10.860 --> 40:13.860
就是你Render的这个第二阶段

40:14.860 --> 40:16.860
协调器

40:16.860 --> 40:19.860
协调器是这个Render

40:19.860 --> 40:22.860
注意我这边Render是指的是这个阶段

40:22.860 --> 40:23.860
就这边

40:23.860 --> 40:24.860
这个阶段

40:24.860 --> 40:25.860
Render阶段

40:25.860 --> 40:26.860
这边叫做Render

40:26.860 --> 40:28.860
ok这边多了个ER

40:28.860 --> 40:29.860
ok

40:29.860 --> 40:30.860
Render

40:30.860 --> 40:31.860
好

40:31.860 --> 40:33.860
这个协调器的话是Render

40:33.860 --> 40:35.860
这个阶段

40:35.860 --> 40:39.940
的这个第二阶段工作

40:39.940 --> 40:40.940
它主要是干嘛的呢

40:40.940 --> 40:43.940
这个阶段的话就是你这个内阻键

40:43.940 --> 40:45.940
以及这个寒宿阻键本身

40:45.940 --> 40:47.940
它会在这个阶段被调用

40:47.940 --> 40:49.940
内阻键

40:49.940 --> 40:51.940
或者寒宿阻键

40:51.940 --> 40:53.940
本身

40:53.940 --> 40:55.940
就是在这个阶段

40:55.940 --> 40:57.940
被调用的

40:57.940 --> 40:59.940
ok

40:59.940 --> 41:02.450
好

41:02.450 --> 41:04.450
在我们上个阶段就是这个

41:04.450 --> 41:05.450
scheduler

41:05.450 --> 41:06.450
这个阶段

41:06.450 --> 41:07.450
这个阶段的话

41:07.450 --> 41:08.450
它的这个调度结果

41:08.450 --> 41:10.450
根据这个调度结果不同

41:10.450 --> 41:12.450
我们这边这个

41:12.450 --> 41:13.450
协调器的话

41:13.450 --> 41:15.450
它可能就是它的起点

41:15.450 --> 41:16.450
是不一样的

41:16.450 --> 41:18.450
根据这个scheduler

41:18.450 --> 41:20.450
调度

41:20.450 --> 41:22.450
结果的不同

41:22.450 --> 41:24.450
那这个协调器

41:24.450 --> 41:26.450
也就是这个reconsider

41:26.450 --> 41:28.450
它的这个起点

41:28.450 --> 41:30.450
起点

41:30.450 --> 41:32.450
可能是不同的

41:32.450 --> 41:34.450
它有可能是什么呢

41:34.450 --> 41:36.450
有可能是这个perform

41:36.450 --> 41:38.450
perform

41:38.450 --> 41:40.450
think

41:40.450 --> 41:41.450
think

41:41.450 --> 41:43.450
然后这个work

41:43.450 --> 41:45.450
and这个root

41:45.450 --> 41:46.450
ok 这个是什么呢

41:46.450 --> 41:48.450
这个是同步更新流程

41:48.450 --> 41:50.450
同步

41:50.450 --> 41:52.450
更新流程

41:52.450 --> 41:53.450
也有可能是什么呢

41:53.450 --> 41:56.450
也有可能是这个perform

41:56.450 --> 42:01.400
然后concurrent

42:01.400 --> 42:02.400
concurrent

42:02.400 --> 42:04.400
然后work

42:04.400 --> 42:07.420
unroot

42:07.420 --> 42:08.420
这个是什么呢

42:08.420 --> 42:12.430
这个就是并发更新流程

42:12.430 --> 42:14.430
并发更新流程

42:14.430 --> 42:16.430
就取决于你那个scheduler

42:16.430 --> 42:18.430
这个调度的这个结果

42:18.430 --> 42:20.430
最终它是走这个同步更新流程

42:20.430 --> 42:22.430
还是并发更新流程

42:22.430 --> 42:24.430
然后接下来它这边分别

42:24.430 --> 42:26.430
这两个的话对应两个方法

42:26.430 --> 42:28.430
分别对应什么呢

42:28.430 --> 42:30.430
这边大家可以看一下

42:30.430 --> 42:32.430
这边就是perform

42:32.430 --> 42:33.430
think work on root

42:33.430 --> 42:37.260
它会执行这个方法

42:37.260 --> 42:38.260
这个是perform

42:38.260 --> 42:40.260
think work on root

42:40.260 --> 42:42.260
它这边这边会执行这个

42:42.260 --> 42:43.260
work loop

42:43.260 --> 42:44.260
think

42:44.260 --> 42:45.260
这个同步

42:45.260 --> 42:46.260
对不对

42:46.260 --> 42:48.260
只要你这个work in progress

42:48.260 --> 42:49.260
不等于空

42:49.260 --> 42:51.260
它这边就会调perform

42:51.260 --> 42:52.260
unit of work

42:52.260 --> 42:53.260
然后接下来如果是什么呢

42:53.260 --> 42:56.260
如果是你这个concurrent

42:56.260 --> 42:58.260
concurrent的话它就会执行这个

42:58.260 --> 43:02.340
它就会执行这个

43:02.340 --> 43:03.340
因为发现这两个的话

43:03.340 --> 43:04.340
实际上就多了一个什么

43:04.340 --> 43:06.340
就多了一个这个scheduler

43:06.340 --> 43:08.340
也有的这个区别

43:08.340 --> 43:09.340
对不对

43:09.340 --> 43:10.340
就多了这么一个区别

43:10.340 --> 43:14.030
好这边的话需要解释一下

43:14.030 --> 43:16.030
因为这边是从原码里面

43:16.030 --> 43:17.030
直接拿出来的

43:17.030 --> 43:19.030
拿了这个代码片段出来

43:19.030 --> 43:20.030
所以这边需要解释一下

43:20.030 --> 43:23.030
这个比如这个work in progress

43:23.030 --> 43:25.030
这个究竟是什么

43:25.030 --> 43:27.030
它work in progress这个边的话

43:27.030 --> 43:28.030
它实际上代表什么呢

43:28.030 --> 43:30.030
代表的是你不是那个fiber

43:30.030 --> 43:32.030
fiber最终你要使用这个fiber

43:32.030 --> 43:34.030
去描述你的这个

43:34.030 --> 43:35.030
动物结构吗

43:35.030 --> 43:37.030
我们描述的那个动物结构

43:37.030 --> 43:39.030
我们称之为fiber tree

43:39.030 --> 43:41.030
我们一点一点来理

43:41.030 --> 43:43.030
就是新的架构

43:43.030 --> 43:45.030
新的架构

43:45.030 --> 43:46.030
使用什么

43:46.030 --> 43:47.030
使用fiber

43:47.030 --> 43:48.030
fiber本质是什么

43:48.030 --> 43:50.030
所以本质是对象

43:50.030 --> 43:51.030
对吧

43:51.030 --> 43:54.030
使用fiber来描述

43:54.030 --> 43:56.030
动物结构

43:56.030 --> 43:57.030
那么最终

43:57.030 --> 44:00.030
最终需要形成一颗什么

44:00.030 --> 44:03.030
一颗fiber tree

44:03.030 --> 44:05.030
没问题吧

44:05.030 --> 44:06.030
就你这个fiber这个对象

44:06.030 --> 44:08.030
最终它还是要形成一个什么

44:08.030 --> 44:09.030
形成一个树的结构

44:09.030 --> 44:11.030
只不过这颗树的话是通过什么

44:11.030 --> 44:12.030
就通过链表

44:12.030 --> 44:14.030
就是链接在一起的

44:14.030 --> 44:15.030
对不对

44:15.030 --> 44:17.030
只不过

44:17.030 --> 44:19.030
只不过

44:19.030 --> 44:21.030
这颗树

44:21.030 --> 44:23.030
是通过什么呢

44:23.030 --> 44:26.030
就是通过链表的形式

44:26.030 --> 44:30.500
串联在一起的

44:30.500 --> 44:31.500
OK

44:31.500 --> 44:33.500
那这个walking progress

44:33.500 --> 44:34.500
它就代表什么呢

44:34.500 --> 44:36.500
它就代表当前的fiber节点

44:36.500 --> 44:41.770
walking progress

44:41.770 --> 44:47.770
代表的是当前的fiber节点

44:47.770 --> 44:49.770
我们称之为fiber load

44:49.770 --> 44:50.770
好

44:50.770 --> 44:51.770
然后接下来的话

44:51.770 --> 44:54.770
你这边只要你这个walking progress

44:54.770 --> 44:55.770
它不为空

44:55.770 --> 44:57.770
有这个fiber节点

44:57.770 --> 44:58.770
对不对

44:58.770 --> 45:00.770
然后接下来它就会把这个fiber节点

45:00.770 --> 45:02.770
传入到perform unit

45:02.770 --> 45:03.770
walk

45:03.770 --> 45:05.770
传入到这个方法里面

45:05.770 --> 45:08.770
那这个方法也是干什么的呢

45:08.770 --> 45:09.770
这个方法

45:09.770 --> 45:10.770
这个方法的话

45:10.770 --> 45:14.770
它会创建下一个fiber load

45:14.770 --> 45:21.770
方法会创建下一个fiber load

45:21.770 --> 45:23.770
就是我们这边整个fiber

45:23.770 --> 45:24.770
比如说

45:24.770 --> 45:25.770
之前讲那个fiber那个

45:25.770 --> 45:26.770
大家还记不记得

45:26.770 --> 45:28.770
我比较这边画个图吧

45:28.770 --> 45:30.770
比如这边的话一个div

45:30.770 --> 45:31.770
对吧

45:31.770 --> 45:32.770
一开始的话

45:32.770 --> 45:33.770
比如说是在这个fiber节点

45:33.770 --> 45:34.770
好

45:34.770 --> 45:35.770
接下来下一个

45:35.770 --> 45:36.770
比如说这边

45:36.770 --> 45:38.770
下面有个h1

45:38.770 --> 45:40.770
这个是div

45:40.770 --> 45:43.770
这个是div

45:43.770 --> 45:45.770
下面有个h1

45:45.770 --> 45:46.770
那接下来的话

45:46.770 --> 45:47.770
我这边让你

45:47.770 --> 45:51.770
刚开始的这个walking progress

45:51.770 --> 45:53.770
对应的是这个fiber节点

45:53.770 --> 45:54.770
你把这个fiber节点

45:54.770 --> 45:55.770
传到什么呢

45:55.770 --> 45:56.770
传到这个方法里面

45:56.770 --> 45:57.770
那接下来

45:57.770 --> 45:58.770
它就会根据你这个节点

45:58.770 --> 45:59.770
然后接下来创建什么

45:59.770 --> 46:01.770
创建下一个fiber load

46:01.770 --> 46:03.770
并且

46:03.770 --> 46:05.770
并且还会做什么事情呢

46:05.770 --> 46:07.770
并且的话还会将

46:07.770 --> 46:13.590
并且还会将

46:13.590 --> 46:21.900
以创建

46:21.900 --> 46:25.900
还会将以创建的fiber load

46:25.900 --> 46:30.970
连接起来

46:30.970 --> 46:31.970
通过什么呢

46:31.970 --> 46:32.970
通过比如说

46:32.970 --> 46:33.970
fiber load

46:33.970 --> 46:35.970
然后return

46:35.970 --> 46:36.970
然后sabling

46:36.970 --> 46:38.970
我们之前看到那个fiber节点

46:38.970 --> 46:39.970
fiber节点

46:39.970 --> 46:40.970
是不是就是通过这些

46:40.970 --> 46:41.970
串联起来的

46:41.970 --> 46:42.970
对不对

46:42.970 --> 46:44.970
从而形成

46:44.970 --> 46:47.970
从而形成

46:47.970 --> 46:49.970
一个练表

46:49.970 --> 46:53.970
结构的fiber tree

46:53.970 --> 46:54.970
喵喵

46:54.970 --> 46:55.970
OK

46:55.970 --> 46:57.970
那如果这个walking progress

46:57.970 --> 46:59.970
如果为空了

46:59.970 --> 47:01.970
说明什么

47:01.970 --> 47:03.970
说明你是不是已经没有

47:03.970 --> 47:05.970
下一个fiber节点了

47:05.970 --> 47:07.970
说明已经没有

47:07.970 --> 47:10.970
下一个fiber节点

47:10.970 --> 47:12.970
这边叫做fiber load

47:12.970 --> 47:14.970
也就是说明

47:14.970 --> 47:16.970
也就是说明

47:16.970 --> 47:18.970
整棵树

47:18.970 --> 47:19.970
什么树

47:19.970 --> 47:21.970
fiber tree

47:21.970 --> 47:23.970
整棵fiber tree

47:23.970 --> 47:24.970
这个树

47:24.970 --> 47:26.970
整棵fiber tree

47:26.970 --> 47:27.970
这个树

47:27.970 --> 47:29.970
整棵fiber tree

47:29.970 --> 47:30.970
整棵fiber tree

47:30.970 --> 47:31.970
这个树

47:31.970 --> 47:32.970
已经

47:32.970 --> 47:35.970
构建完毕

47:35.970 --> 47:37.970
是不是说明这个

47:37.970 --> 47:38.970
对不对

47:38.970 --> 47:40.970
好然后上面两个方法

47:40.970 --> 47:43.970
上面两个方法

47:43.970 --> 47:46.970
唯一的区别

47:46.970 --> 47:48.970
唯一的区别

47:48.970 --> 47:49.970
就是什么的

47:49.970 --> 47:50.970
就是这个

47:50.970 --> 47:54.410
should yield

47:54.410 --> 47:55.410
就是是否调用了

47:55.410 --> 47:56.410
就是

47:56.410 --> 47:58.410
是否调用了

47:58.410 --> 48:00.410
should yield的方法

48:00.410 --> 48:02.410
这个方法它是哪个吗

48:02.410 --> 48:04.410
它就是表明了是否可以中断

48:04.410 --> 48:06.410
该方法

48:06.410 --> 48:08.410
该方法

48:08.410 --> 48:13.940
该方法表明

48:13.940 --> 48:16.940
表明了是否可以

48:16.940 --> 48:18.940
中断

48:18.940 --> 48:19.940
OK

48:19.940 --> 48:21.940
这是关于这个

48:21.940 --> 48:22.940
上面这个代码

48:22.940 --> 48:25.940
进行了一个简单的解释

48:26.940 --> 48:28.940
然后我们现在我们知道

48:28.940 --> 48:30.940
perform unit

48:30.940 --> 48:31.940
它的话是

48:31.940 --> 48:33.940
创建这个下一个fiber load

48:33.940 --> 48:34.940
对不对

48:34.940 --> 48:35.940
好它这边的话在

48:35.940 --> 48:36.940
创建的时候

48:36.940 --> 48:38.940
实际上它整体的这个工作

48:38.940 --> 48:41.940
它可以分成两个部分

48:41.940 --> 48:43.940
这个perform unit

48:43.940 --> 48:44.940
walk

48:44.940 --> 48:49.940
在创建下一个fiber load

48:49.940 --> 48:51.940
的时候

48:51.940 --> 48:53.940
整体上面的

48:53.940 --> 48:56.940
整体上的这个工作

48:56.940 --> 48:58.940
流程

48:59.940 --> 49:00.940
可以

49:00.940 --> 49:01.940
分为什么

49:01.940 --> 49:03.940
分为两大块

49:04.940 --> 49:05.940
雷兰那块

49:05.940 --> 49:07.940
一个是这个d

49:08.940 --> 49:10.940
就是d阶段

49:10.940 --> 49:11.940
第二个是什么

49:11.940 --> 49:12.940
第二个是g

49:12.940 --> 49:14.940
g来的阶段

49:14.940 --> 49:16.940
一个是d阶段

49:16.940 --> 49:18.940
一个是g这个阶段

49:18.940 --> 49:19.940
那接下来

49:19.940 --> 49:21.940
每个阶段我们大致来看一下

49:21.940 --> 49:23.940
来看一下这个d阶段

49:23.940 --> 49:25.940
做了些什么

49:25.940 --> 49:27.940
那这个g阶段

49:27.940 --> 49:29.940
做了些什么

49:29.940 --> 49:32.940
我们首先来看这个d阶段

49:32.940 --> 49:33.940
d阶段的话

49:33.940 --> 49:35.940
它首先是从host root fiber

49:35.940 --> 49:37.940
它开始向下

49:37.940 --> 49:40.940
向下进行一个便利

49:40.940 --> 49:42.940
它便利的原则是什么呢

49:42.940 --> 49:45.940
便利的原则是深度优先

49:45.940 --> 49:46.940
什么叫做深度优先

49:46.940 --> 49:47.940
比如说我这边

49:47.940 --> 49:51.440
我们来画个图

49:51.440 --> 49:52.440
比如说我这边

49:52.440 --> 49:53.440
我这边的话

49:53.440 --> 49:55.440
现在有这么一个结构

49:55.440 --> 49:57.440
这边的话

49:57.440 --> 49:58.440
下面有一个

49:58.440 --> 49:59.440
然后接下来的话

49:59.440 --> 50:00.440
这边有一个

50:00.440 --> 50:01.440
好

50:01.440 --> 50:02.440
然后接下来这边

50:02.440 --> 50:03.440
这边的话有一个

50:03.440 --> 50:05.440
这边的话有一个

50:05.440 --> 50:06.440
ok

50:06.440 --> 50:07.440
那它便利的话

50:07.440 --> 50:08.440
深度优先是什么呢

50:08.440 --> 50:09.440
就是比如说先从这

50:09.440 --> 50:10.440
对一

50:10.440 --> 50:11.440
然后再这边

50:11.440 --> 50:12.440
二

50:12.440 --> 50:13.440
二的话你看这边

50:13.440 --> 50:14.440
是不是就有分支了

50:14.440 --> 50:15.440
对不对

50:15.440 --> 50:16.440
究竟是往这个右边走

50:16.440 --> 50:17.440
还是往下走

50:17.440 --> 50:18.440
深度优先

50:18.440 --> 50:19.440
所以说这边的话

50:19.440 --> 50:20.440
应该是先便

50:20.440 --> 50:21.440
先到这

50:22.440 --> 50:23.440
明白吧

50:23.440 --> 50:24.440
先到这

50:24.440 --> 50:25.440
这的话还能不能再下

50:25.440 --> 50:26.440
这没有下面了

50:26.440 --> 50:27.440
对不对

50:27.440 --> 50:28.440
再去干嘛呢

50:28.440 --> 50:29.440
再去旁边

50:29.440 --> 50:30.440
这边是4

50:30.440 --> 50:31.440
完事之后

50:31.440 --> 50:32.440
然后接下来整个

50:32.440 --> 50:33.440
这一块是不是

50:33.440 --> 50:34.440
都无法再往下了

50:34.440 --> 50:35.440
对不对

50:35.440 --> 50:36.440
那接下来整个

50:36.440 --> 50:37.440
这个指数就完了

50:37.440 --> 50:38.440
完了之后

50:38.440 --> 50:39.440
然后加这边

50:39.440 --> 50:40.440
5

50:40.440 --> 50:41.440
这个就叫做

50:41.440 --> 50:42.440
深度优先

50:42.440 --> 50:43.440
不要不要

50:43.440 --> 50:47.610
好

50:47.610 --> 50:48.610
我们这边

50:48.610 --> 50:49.610
我们来记录一下

50:49.610 --> 50:50.610
就是D

50:51.610 --> 50:52.610
D阶段

50:52.610 --> 50:53.610
它会干嘛呢

50:53.610 --> 50:54.610
它会从

50:55.610 --> 50:57.610
会从这个host

50:58.610 --> 50:59.610
host root fiber

51:00.610 --> 51:01.610
然后开始

51:01.610 --> 51:03.610
然后这个向下

51:04.610 --> 51:05.610
向下

51:05.610 --> 51:06.610
然后以什么呢

51:06.610 --> 51:08.610
以这个深度优先

51:09.610 --> 51:10.610
的这个原则

51:11.610 --> 51:13.610
进行一个便利

51:13.610 --> 51:14.610
好

51:14.610 --> 51:15.610
然后便利到的

51:16.610 --> 51:17.610
便利到的

51:17.610 --> 51:18.610
每一个

51:18.610 --> 51:20.610
这个fiber load

51:21.610 --> 51:22.610
然后执行什么呢

51:22.610 --> 51:24.610
执行这个begin

51:24.610 --> 51:26.610
beginwork方法

51:30.260 --> 51:31.260
这个beginwork方法

51:31.260 --> 51:32.260
它会干嘛呢

51:32.260 --> 51:33.260
它会根据

51:33.260 --> 51:35.260
传入的这个fiber load的节点

51:35.260 --> 51:37.260
创建下一级fiber load

51:38.260 --> 51:40.260
该方法

51:40.260 --> 51:42.260
会根据

51:42.260 --> 51:44.260
传入的

51:44.260 --> 51:46.260
这个fiber load

51:46.260 --> 51:48.260
然后创建

51:48.260 --> 51:52.790
下一级

51:52.790 --> 51:54.790
下一级的这个fiber load

51:57.740 --> 51:58.740
ok

51:58.740 --> 51:59.740
那此时的话

51:59.740 --> 52:01.740
可能存在两种情况

52:01.740 --> 52:02.740
此时

52:02.740 --> 52:03.740
可能

52:03.740 --> 52:04.740
存在

52:04.740 --> 52:05.740
两种情况

52:06.740 --> 52:07.740
那种情况呢

52:07.740 --> 52:08.740
就是你首先的话

52:08.740 --> 52:09.740
下一级

52:09.740 --> 52:11.740
只有一个元素

52:11.740 --> 52:16.270
下一级只有一个元素的话

52:16.270 --> 52:17.270
那这个begin

52:17.270 --> 52:19.270
beginwork方法

52:20.270 --> 52:22.270
然后会创建

52:22.270 --> 52:25.270
创建对应的这个fiber load

52:26.270 --> 52:28.270
然后并与什么呢

52:28.270 --> 52:30.270
并与这个walking

52:31.270 --> 52:32.270
walking

52:32.270 --> 52:34.270
这个progress

52:35.270 --> 52:36.270
这个连接

52:39.160 --> 52:40.160
ok 这是这种情况

52:40.160 --> 52:42.160
比我们这边我们举个例子

52:42.160 --> 52:48.800
比如说它是这样子的

52:48.800 --> 52:50.800
这边是gst

52:51.800 --> 52:52.800
这边是这样子的

52:52.800 --> 52:53.800
一个ur

52:56.180 --> 52:57.180
ur下面一个什么呢

52:57.180 --> 52:59.180
ur下面一个li

52:59.180 --> 53:01.680
一个li

53:01.680 --> 53:02.680
那这边的话

53:02.680 --> 53:03.680
它就会干嘛呢

53:03.680 --> 53:04.680
它就会创建这个

53:04.680 --> 53:06.680
力所对应的这个fiber load

53:07.680 --> 53:09.680
这里就会

53:09.680 --> 53:10.680
创建

53:10.680 --> 53:11.680
li

53:11.680 --> 53:14.680
对应的这个fiber load

53:14.680 --> 53:18.210
ok

53:18.210 --> 53:19.210
创建了之后

53:19.210 --> 53:20.210
然后接下来

53:20.210 --> 53:22.210
做如下的连接

53:23.210 --> 53:24.210
做出

53:24.210 --> 53:26.210
如下的

53:26.210 --> 53:27.210
连接

53:27.210 --> 53:28.210
它怎么连接呢

53:28.210 --> 53:29.210
它就会这样子

53:29.210 --> 53:31.210
就你这边的这个li

53:31.210 --> 53:33.210
力对应的这个fiber

53:33.210 --> 53:34.210
对吧 让它通过什么呢

53:34.210 --> 53:35.210
通过这个return

53:35.210 --> 53:36.210
然后指向什么呢

53:36.210 --> 53:38.210
指向这个ur

53:38.210 --> 53:40.210
urfiber

53:41.210 --> 53:43.210
通过这种方式进行连接

53:43.210 --> 53:44.210
这urfiber就是什么呢

53:44.210 --> 53:46.210
就是你这个walking programs

53:46.210 --> 53:47.210
叫它上一级吗

53:48.210 --> 53:49.210
上一级

53:49.210 --> 53:50.210
ok

53:50.210 --> 53:51.210
好 还有一种情况是什么呢

53:51.210 --> 53:52.210
还有一种情况是

53:52.210 --> 53:54.210
就是下一级有多个

53:54.210 --> 53:55.210
这个元素

53:55.210 --> 54:00.120
下一级

54:01.120 --> 54:04.120
下一级有多个

54:04.120 --> 54:05.120
元素

54:05.120 --> 54:07.120
那么这时

54:07.120 --> 54:09.120
这个beginwalk

54:10.120 --> 54:11.120
beginwalk方法

54:11.120 --> 54:13.120
会一次

54:14.120 --> 54:15.120
一次创建

54:15.120 --> 54:18.120
所有的这个指fiber

54:19.120 --> 54:20.120
指fiber load

54:20.120 --> 54:21.120
那并且

54:21.120 --> 54:22.120
通过什么呢

54:22.120 --> 54:24.120
通过这个sabling

54:24.120 --> 54:26.120
sabling

54:26.120 --> 54:28.120
连接到一起

54:29.120 --> 54:30.120
ok

54:30.120 --> 54:31.120
然后每个

54:31.120 --> 54:33.120
每个这个指fiber

54:33.120 --> 54:36.880
指fiber load

54:36.880 --> 54:37.880
也会什么呢

54:37.880 --> 54:40.880
也会和这个walking programs

54:41.880 --> 54:44.880
walking programs

54:45.880 --> 54:47.880
然后连接

54:47.880 --> 54:48.880
因为这个walking programs

54:48.880 --> 54:49.880
对于他们来讲

54:49.880 --> 54:50.880
是不是就是他们的fiber

54:51.880 --> 54:52.880
对不对

54:52.880 --> 54:53.880
我们这边仍然是

54:53.880 --> 54:54.880
假设有这样的结构

54:55.880 --> 54:56.880
假设这边

54:56.880 --> 54:58.880
这边也还是接视差

54:58.880 --> 55:00.880
假设有这样的结构

55:00.880 --> 55:01.880
这边这个ur

55:01.880 --> 55:02.880
ur下面的话

55:02.880 --> 55:05.450
有多个力

55:05.450 --> 55:06.450
有多个力

55:06.450 --> 55:07.450
好 那接下来

55:07.450 --> 55:08.450
这个时候的话

55:08.450 --> 55:09.450
它就会干嘛呢

55:09.450 --> 55:10.450
这个时候它就会创建

55:10.450 --> 55:12.450
三个力对应的fiber load

55:12.450 --> 55:15.820
此时

55:15.820 --> 55:17.820
此时会创建

55:17.820 --> 55:19.820
三个力

55:19.820 --> 55:20.820
三个力

55:20.820 --> 55:23.820
对应的fiber load

55:25.820 --> 55:27.820
然后连接

55:27.820 --> 55:29.820
情况如下

55:29.820 --> 55:32.140
就这里

55:32.140 --> 55:33.140
这里的话

55:33.140 --> 55:35.140
首先这个力

55:35.140 --> 55:36.140
然后第一个力

55:36.140 --> 55:38.140
比我们叫做力零fiber

55:38.140 --> 55:39.140
对吧

55:39.140 --> 55:40.140
就第一个力的fiber

55:40.140 --> 55:41.140
那它的这个sabling

55:42.140 --> 55:43.140
等于什么呢

55:43.140 --> 55:44.140
等于一个这个力

55:44.140 --> 55:45.140
一fiber

55:47.140 --> 55:48.140
对吧

55:48.140 --> 55:49.140
它的这个sabling

55:49.140 --> 55:50.140
它隔壁

55:50.140 --> 55:52.140
好 那叫这个力一

55:52.140 --> 55:54.140
力一fiber

55:54.140 --> 55:56.140
点这个sabling

55:56.140 --> 55:57.140
它等于什么呢

55:57.140 --> 55:58.140
它等于一个力二

55:59.140 --> 56:01.140
力二fiber

56:01.140 --> 56:02.140
对吧

56:02.140 --> 56:03.140
所有的这个

56:03.140 --> 56:04.140
紫fiber

56:04.140 --> 56:05.140
一次连接

56:06.140 --> 56:09.140
所有的紫fiber

56:10.140 --> 56:13.140
一次连接

56:13.140 --> 56:14.140
好 然后接下来

56:14.140 --> 56:15.140
下一步

56:15.140 --> 56:18.770
下一步的话就是紫fiber

56:18.770 --> 56:19.770
紫fiber

56:19.770 --> 56:20.770
还需要和什么呢

56:20.770 --> 56:21.770
还需要和这个

56:23.770 --> 56:24.770
复fiber

56:25.770 --> 56:26.770
连接

56:26.770 --> 56:28.770
就你这边的这个力零fiber

56:30.770 --> 56:31.770
它这个点

56:32.770 --> 56:33.770
return

56:33.770 --> 56:34.770
应该等于什么

56:34.770 --> 56:35.770
所以ur

56:36.770 --> 56:37.770
对

56:37.770 --> 56:38.770
urfiber

56:38.770 --> 56:39.770
好 还有什么呢

56:39.770 --> 56:40.770
还有就是这个

56:41.770 --> 56:42.770
力一

56:43.770 --> 56:44.770
然后还有什么呢

56:44.770 --> 56:45.770
还有这个力二

56:46.770 --> 56:47.770
他们的话这个return

56:47.770 --> 56:48.770
是不是都应该是指向这个

56:48.770 --> 56:49.770
urfiber

56:50.770 --> 56:51.770
对不对

56:52.770 --> 56:53.770
它就是这样子的

56:53.770 --> 56:55.770
执行这个毕竟方法

56:55.770 --> 56:56.770
主要就做了这个事情

56:56.770 --> 56:59.770
创建下一级fiber

57:00.770 --> 57:01.770
好 由于它采用的是

57:01.770 --> 57:03.770
这个深度优先的这个原则

57:03.770 --> 57:06.770
说如果它无法再往下便利的时候

57:06.770 --> 57:07.770
它会进入到什么呢

57:07.770 --> 57:09.770
会进入到这个归的这个阶段

57:09.770 --> 57:11.770
注意 由于

57:12.770 --> 57:14.770
由于采用的是

57:14.770 --> 57:16.770
就是深度优先

57:17.770 --> 57:20.770
深度优先的原则

57:20.770 --> 57:24.770
因此无法再往下

57:24.770 --> 57:26.770
走的时候

57:26.770 --> 57:27.770
会干嘛呢

57:27.770 --> 57:30.770
会进入到归阶段

57:31.770 --> 57:33.770
归阶段

57:33.770 --> 57:35.770
归阶段

57:35.770 --> 57:36.770
那归阶段

57:36.770 --> 57:37.770
归阶段的话

57:37.770 --> 57:38.770
它会调用什么呢

57:38.770 --> 57:40.770
它会调用这个complete work

57:40.770 --> 57:41.770
方法

57:41.770 --> 57:43.770
来处理这个fiber load

57:43.770 --> 57:47.230
归阶段

57:47.230 --> 57:49.230
会调用什么呢

57:49.230 --> 57:51.230
调用这个complete

57:51.230 --> 57:53.230
complete work

57:53.230 --> 57:55.230
你注意刚才第阶段是什么

57:55.230 --> 57:56.230
第阶段它是不是

57:56.230 --> 57:57.230
begin work

57:57.230 --> 57:58.230
对不对

57:58.230 --> 57:59.230
那归阶段

57:59.230 --> 58:01.230
归阶段的话是complete work

58:01.230 --> 58:02.230
complete work

58:02.230 --> 58:03.230
它这个方法

58:03.230 --> 58:04.230
会调用这个方法

58:04.230 --> 58:05.230
来干嘛呢

58:05.230 --> 58:06.230
来处理

58:06.230 --> 58:09.230
来处理fiber load

58:09.230 --> 58:11.230
然后做一些什么呢

58:11.230 --> 58:13.230
做一些副作用的收集

58:14.230 --> 58:16.230
副作用的收集

58:20.140 --> 58:21.140
ok

58:21.140 --> 58:23.140
那你如果某一个fiber load

58:23.140 --> 58:25.140
它执行了这个complete

58:25.140 --> 58:26.140
方法之后

58:26.140 --> 58:28.140
如果存在这个兄弟元素

58:28.140 --> 58:30.140
那么它就会进入到

58:30.140 --> 58:32.140
兄弟元素的这个地的这个阶段

58:32.140 --> 58:34.140
那如果不存在这个兄弟元素

58:34.140 --> 58:37.140
那么就会进入到这个副元素

58:37.140 --> 58:40.140
就副的fiber load的这个归的这个阶段

58:41.140 --> 58:43.140
当某个

58:44.140 --> 58:45.140
一会会有图

58:45.140 --> 58:47.140
可能大家现在听到有点晕

58:47.140 --> 58:48.140
是不是

58:48.140 --> 58:49.140
我一会会有张图

58:49.140 --> 58:51.140
把这边把这边寄完的

58:51.140 --> 58:53.140
当某个这个fiber load的

58:53.140 --> 58:55.140
执行完了

58:55.140 --> 58:57.140
这个complete work

58:58.140 --> 58:59.140
work

58:59.140 --> 59:00.140
方法后

59:00.140 --> 59:04.140
如果存在兄弟元素

59:04.140 --> 59:06.840
那么就会什么呢

59:06.840 --> 59:09.840
就会进入到

59:09.840 --> 59:12.840
兄弟元素的这个

59:12.840 --> 59:13.840
地阶段

59:13.840 --> 59:17.150
地阶段

59:17.150 --> 59:19.150
那如果不存在

59:19.150 --> 59:22.780
兄弟元素

59:22.780 --> 59:24.780
兄弟元素

59:24.780 --> 59:25.780
就会什么呢

59:25.780 --> 59:29.780
就会进入副fiber

59:29.780 --> 59:32.780
副fiber load

59:32.780 --> 59:34.780
副fiber load的这个归阶段

59:34.780 --> 59:37.930
OK

59:37.930 --> 59:39.930
它这边对应的代码的话就是

59:39.930 --> 59:41.930
大致就是这样子的

59:41.930 --> 59:44.930
把这个代码我把它拿过来

59:44.930 --> 59:46.930
大致就是这样子的

59:46.930 --> 59:52.930
你看这边

59:52.930 --> 59:54.930
perform unit of work

59:54.930 --> 59:55.930
那这边的话是

59:55.930 --> 59:57.930
传入一个fiber load

59:57.930 --> 59:59.930
传入一个fiber load之后

59:59.930 --> 01:00:00.930
先执行什么呢

01:00:00.930 --> 01:00:02.930
先执行begin work

01:00:02.930 --> 01:00:04.930
先执行begin work

01:00:04.930 --> 01:00:06.930
接下来看它有没有指源数

01:00:06.930 --> 01:00:08.930
有指源数它深度优先吗

01:00:08.930 --> 01:00:09.930
深度优先

01:00:09.930 --> 01:00:11.930
接下这个指源数

01:00:11.930 --> 01:00:13.930
是不是又进行perform unit of work

01:00:13.930 --> 01:00:14.930
对不对

01:00:14.930 --> 01:00:15.930
接下这个指源数

01:00:15.930 --> 01:00:16.930
是不是又执行这个

01:00:16.930 --> 01:00:17.930
begin work

01:00:17.930 --> 01:00:18.930
如果没有指源数

01:00:18.930 --> 01:00:19.930
没有指源数的话

01:00:19.930 --> 01:00:21.930
接下这边就执行什么了

01:00:21.930 --> 01:00:23.930
这边就执行complete work

01:00:23.930 --> 01:00:25.930
因为你不能再往下走了吗

01:00:25.930 --> 01:00:26.930
深度优先嘛

01:00:26.930 --> 01:00:27.930
对不对

01:00:27.930 --> 01:00:28.930
那就执行complete work

01:00:28.930 --> 01:00:30.930
执行完complete work之后

01:00:30.930 --> 01:00:31.930
然后接下来再看什么

01:00:31.930 --> 01:00:33.930
再看它有没有兄弟元素

01:00:33.930 --> 01:00:34.930
那接下来就走什么呢

01:00:34.930 --> 01:00:36.930
就走兄弟元素

01:00:36.930 --> 01:00:37.930
看了没有

01:00:37.930 --> 01:00:38.930
好来我们这边

01:00:38.930 --> 01:00:39.930
我们来看张图

01:00:39.930 --> 01:00:43.500
最后我们来看张图

01:00:43.500 --> 01:00:45.500
最后我们来看一张图

01:00:45.500 --> 01:00:47.500
看这张图你就懂了

01:00:47.500 --> 01:00:49.500
把这张图我把它拿过来

01:00:49.500 --> 01:00:51.500
稍等啊

01:00:51.500 --> 01:00:53.500
稍等我这边卡住了

01:00:53.500 --> 01:00:55.500
好

01:00:55.500 --> 01:00:57.500
把这张图我把它拿过来

01:00:57.500 --> 01:01:00.700
OK

01:01:00.700 --> 01:01:01.700
这边大家看一下

01:01:01.700 --> 01:01:03.700
假设我们这边有这样的结构

01:01:03.700 --> 01:01:04.700
这边这个div

01:01:04.700 --> 01:01:05.700
下面有一个p

01:01:05.700 --> 01:01:06.700
p下面有ur

01:01:06.700 --> 01:01:08.700
ur下面三个力

01:01:08.700 --> 01:01:09.700
很简单的这个结构

01:01:09.700 --> 01:01:10.700
对不对

01:01:10.700 --> 01:01:11.700
好首先的话你看这边

01:01:11.700 --> 01:01:13.700
首先它这边用链表

01:01:13.700 --> 01:01:14.700
这个

01:01:14.700 --> 01:01:15.700
这个穿起来了

01:01:15.700 --> 01:01:16.700
对不对

01:01:16.700 --> 01:01:17.700
穿起来了之后

01:01:17.700 --> 01:01:18.700
然后接下来我们这边来看一下

01:01:18.700 --> 01:01:19.700
你首先这边

01:01:19.700 --> 01:01:20.700
第一个是begin work

01:01:20.700 --> 01:01:22.700
完事之后往下走

01:01:22.700 --> 01:01:23.700
往下走就是什么呢

01:01:23.700 --> 01:01:26.700
就是这个p的begin work

01:01:26.700 --> 01:01:27.700
p走完了之后

01:01:27.700 --> 01:01:29.700
然后p还能不能往下走

01:01:29.700 --> 01:01:30.700
p下面是没有了

01:01:30.700 --> 01:01:31.700
然后接下来注意

01:01:31.700 --> 01:01:33.700
第三个就是complete work

01:01:33.700 --> 01:01:36.700
就执行当前结点的complete work

01:01:36.700 --> 01:01:38.700
你看和刚才说的这句话是一样的

01:01:38.700 --> 01:01:39.700
对不对

01:01:39.700 --> 01:01:41.700
当某个fiber load的执行

01:01:41.700 --> 01:01:44.700
它这边要执行complete work方法

01:01:44.700 --> 01:01:45.700
执行了之后

01:01:45.700 --> 01:01:47.700
然后如果存在兄弟元素

01:01:47.700 --> 01:01:48.700
兄弟元素

01:01:48.700 --> 01:01:51.700
就进入到兄弟元素的地阶段

01:01:51.700 --> 01:01:52.700
接下来的话这边

01:01:52.700 --> 01:01:54.700
complete work执行完了之后

01:01:54.700 --> 01:01:55.700
来到兄弟元素

01:01:55.700 --> 01:01:56.700
来到ur

01:01:56.700 --> 01:01:59.700
第四个是begin work

01:01:59.700 --> 01:02:00.700
begin work完了之后

01:02:00.700 --> 01:02:01.700
看能不能往下走

01:02:01.700 --> 01:02:02.700
能往下走

01:02:02.700 --> 01:02:03.700
接下来这边力

01:02:03.700 --> 01:02:05.700
力这边是begin work

01:02:05.700 --> 01:02:07.700
完事之后力完了之后

01:02:07.700 --> 01:02:08.700
力还能不能往下走

01:02:08.700 --> 01:02:09.700
不能往下走

01:02:09.700 --> 01:02:10.700
不能往下走

01:02:10.700 --> 01:02:12.700
执行力的complete work

01:02:12.700 --> 01:02:14.700
接下来这边

01:02:14.700 --> 01:02:15.700
兄弟元素

01:02:15.700 --> 01:02:16.700
对不对

01:02:16.700 --> 01:02:18.700
一次是这样子走了

01:02:18.700 --> 01:02:19.700
所以你可以看到

01:02:19.700 --> 01:02:20.700
这个DIV的话

01:02:20.700 --> 01:02:21.700
它的begin work它是

01:02:21.700 --> 01:02:22.700
第一个执行的

01:02:22.700 --> 01:02:23.700
但是它的complete work

01:02:23.700 --> 01:02:26.700
确实是最后一个执行

01:02:27.700 --> 01:02:28.700
妙妙

01:02:28.700 --> 01:02:29.700
最后一个执行

01:02:30.700 --> 01:02:31.700
好 接下来这边

01:02:31.700 --> 01:02:32.700
你注意这边的话

01:02:33.700 --> 01:02:34.700
它react内部

01:02:34.700 --> 01:02:36.700
它会有一些优化路径

01:02:36.700 --> 01:02:37.700
所以这边

01:02:37.700 --> 01:02:38.700
针对这种文本节点

01:02:38.700 --> 01:02:39.700
比如Hello

01:02:39.700 --> 01:02:41.700
Ample, Peer, Banana

01:02:41.700 --> 01:02:42.700
这种文本节点

01:02:42.700 --> 01:02:43.700
这种的话

01:02:43.700 --> 01:02:46.700
是没有对应的fiber load的

01:02:46.700 --> 01:02:47.700
所以我这边

01:02:47.700 --> 01:02:49.700
就画出他们的fiber load

01:02:50.700 --> 01:02:51.700
这点注意

01:02:51.700 --> 01:02:52.700
但整体的流程的话

01:02:52.700 --> 01:02:53.700
就是这样子的

01:02:54.700 --> 01:02:56.700
整体流程就这样子的

01:02:56.700 --> 01:02:57.700
你这边

01:02:57.700 --> 01:02:58.700
你先把这张图看一下

01:02:58.700 --> 01:02:59.700
看完之后

01:02:59.700 --> 01:03:00.700
你回头再来看我这边的

01:03:00.700 --> 01:03:01.700
这个描述

01:03:01.700 --> 01:03:02.700
你就明白了

01:03:02.700 --> 01:03:03.700
你看包括这里

01:03:03.700 --> 01:03:05.700
这边比如创建三个力

01:03:05.700 --> 01:03:06.700
三个力的return

01:03:06.700 --> 01:03:08.700
对应的都是ur

01:03:08.700 --> 01:03:09.700
你看和这张图

01:03:09.700 --> 01:03:10.700
是对上的

01:03:10.700 --> 01:03:11.700
对不对

01:03:11.700 --> 01:03:12.700
对上的

01:03:13.700 --> 01:03:15.700
这就是关于这个协调器

01:03:15.700 --> 01:03:16.700
那总结一下

01:03:16.700 --> 01:03:17.700
协调器的话

01:03:17.700 --> 01:03:18.700
其实主要就是什么

01:03:18.700 --> 01:03:19.700
它主要就是

01:03:19.700 --> 01:03:20.700
这边它要生成

01:03:20.700 --> 01:03:22.700
对应的fiber节点

01:03:22.700 --> 01:03:23.700
接下来还有什么

01:03:23.700 --> 01:03:25.700
还就是进行fiber的调和

01:03:25.700 --> 01:03:26.700
在生成

01:03:27.700 --> 01:03:29.700
这边在创建fiber节点的时候

01:03:29.700 --> 01:03:30.700
它分成什么

01:03:30.700 --> 01:03:32.700
分成地阶段和硅阶段

01:03:32.700 --> 01:03:33.700
对不对

01:03:34.700 --> 01:03:35.700
但它调和的话

01:03:35.700 --> 01:03:36.700
涉及到的就是这个

01:03:36.700 --> 01:03:37.700
地符算法

01:03:37.700 --> 01:03:38.700
这个我们后面再说

01:03:38.700 --> 01:03:39.700
我们这边实际上

01:03:39.700 --> 01:03:40.700
只是说了什么

01:03:40.700 --> 01:03:41.700
只是说了就是

01:03:41.700 --> 01:03:42.700
这个协调器

01:03:42.700 --> 01:03:44.700
它在创建fiber节点的时候

01:03:44.700 --> 01:03:45.700
这两大阶段

01:03:46.700 --> 01:03:47.700
这个后面还会说

01:03:47.700 --> 01:03:48.700
就是关于这个

01:03:48.700 --> 01:03:50.700
BeginWalk和CompleteWalk

01:03:50.700 --> 01:03:51.700
我们还会说

01:03:51.700 --> 01:03:52.700
BeginWalk里面

01:03:52.700 --> 01:03:54.700
究竟具体做了些什么

01:03:54.700 --> 01:03:55.700
CompleteWalk里面

01:03:55.700 --> 01:03:57.700
具体究竟做了什么

01:03:58.700 --> 01:04:00.700
这是关于这个协调器

01:04:00.700 --> 01:04:02.700
最后一个是

01:04:02.700 --> 01:04:03.700
渲染器

01:04:04.700 --> 01:04:06.700
最后一个是渲染器

01:04:06.700 --> 01:04:07.700
最后的话

01:04:07.700 --> 01:04:08.700
这边它就是什么

01:04:08.700 --> 01:04:10.700
它就是commit阶段了

01:04:10.700 --> 01:04:11.700
对不对

01:04:11.700 --> 01:04:13.700
渲染器对应的英语是什么

01:04:13.700 --> 01:04:14.700
Render

01:04:14.700 --> 01:04:15.700
Render

01:04:15.700 --> 01:04:17.700
工作的这个阶段

01:04:17.700 --> 01:04:19.700
被称之为什么呢

01:04:19.700 --> 01:04:21.700
被称之为

01:04:21.700 --> 01:04:23.700
commit阶段

01:04:23.700 --> 01:04:24.700
ok

01:04:24.700 --> 01:04:26.700
那这个阶段它会做什么呢

01:04:26.700 --> 01:04:27.700
这个阶段的话

01:04:27.700 --> 01:04:29.700
它会将各种副作用

01:04:31.700 --> 01:04:33.700
该阶段

01:04:34.700 --> 01:04:37.700
会将各种副作用

01:04:37.700 --> 01:04:39.700
然后commit

01:04:39.700 --> 01:04:40.700
到什么呢

01:04:40.700 --> 01:04:42.700
到这个数组环境中

01:04:42.700 --> 01:04:47.530
数组环境的这个UI中

01:04:48.530 --> 01:04:49.530
ok

01:04:49.530 --> 01:04:50.530
你不同的这个数组环境

01:04:50.530 --> 01:04:51.530
它调用的这个

01:04:51.530 --> 01:04:53.530
API它是不一样的

01:04:53.530 --> 01:04:54.530
对不对

01:04:54.530 --> 01:04:55.530
好

01:04:55.530 --> 01:04:56.530
然后这边要说一下

01:04:56.530 --> 01:04:57.530
就是前面的这个

01:04:57.530 --> 01:04:59.530
scheduler和reconcealer

01:04:59.530 --> 01:05:01.530
它被称之为这个Render阶段

01:05:01.530 --> 01:05:02.530
那这个阶段的话

01:05:02.530 --> 01:05:04.530
是在内存中运行

01:05:04.530 --> 01:05:05.530
它是可以被打断的

01:05:05.530 --> 01:05:07.530
随便打断无所谓

01:05:07.530 --> 01:05:08.530
但是你这个

01:05:08.530 --> 01:05:09.530
渲染器这个阶段

01:05:09.530 --> 01:05:11.530
这个commit阶段

01:05:11.530 --> 01:05:12.530
一旦开始

01:05:12.530 --> 01:05:13.530
它就会同步执行

01:05:13.530 --> 01:05:15.530
直到完成

01:05:15.530 --> 01:05:16.530
注意哦

01:05:16.530 --> 01:05:18.530
相较于

01:05:18.530 --> 01:05:20.530
之前的Render阶段

01:05:22.530 --> 01:05:24.530
这个commit阶段

01:05:24.530 --> 01:05:26.530
一旦开始

01:05:26.530 --> 01:05:28.530
相较于之前这个

01:05:28.530 --> 01:05:29.530
Render阶段

01:05:29.530 --> 01:05:31.530
可以被打断

01:05:32.530 --> 01:05:34.530
commit阶段

01:05:34.530 --> 01:05:36.530
一旦开始

01:05:36.530 --> 01:05:37.530
就会什么呢

01:05:37.530 --> 01:05:39.530
就会同步执行

01:05:39.530 --> 01:05:41.530
直到什么呢

01:05:41.530 --> 01:05:43.530
直到完成

01:05:44.530 --> 01:05:48.540
直到完成这个渲染

01:05:48.540 --> 01:05:49.540
明白吧

01:05:49.540 --> 01:05:50.540
OK

01:05:50.540 --> 01:05:51.540
它是同步的

01:05:51.540 --> 01:05:52.540
反复强调

01:05:52.540 --> 01:05:55.300
我把这个加出

01:05:55.300 --> 01:05:56.300
OK

01:05:56.300 --> 01:05:57.300
好

01:05:57.300 --> 01:05:58.300
整个这个渲染器的话

01:05:58.300 --> 01:06:00.300
它可以分成三个指阶段

01:06:00.300 --> 01:06:02.300
整个渲染器

01:06:04.300 --> 01:06:06.300
这个渲染过程中

01:06:06.300 --> 01:06:07.300
渲染过程中

01:06:07.300 --> 01:06:09.300
可以分为

01:06:09.300 --> 01:06:11.300
三个指阶段

01:06:11.300 --> 01:06:18.010
哪三个指阶段呢

01:06:18.010 --> 01:06:20.010
对应的分别是这三个

01:06:20.010 --> 01:06:21.010
我直接拿过来

01:06:21.010 --> 01:06:22.010
这边

01:06:22.010 --> 01:06:25.010
一个是before motation

01:06:25.010 --> 01:06:27.010
一个是motation

01:06:27.010 --> 01:06:29.010
最后一个是layout

01:06:29.010 --> 01:06:31.010
这边是阶段

01:06:31.010 --> 01:06:33.010
对应的是这三个阶段

01:06:33.010 --> 01:06:34.010
对应的话

01:06:34.010 --> 01:06:35.010
这边有张图

01:06:35.010 --> 01:06:36.010
这边我把这张图

01:06:36.010 --> 01:06:42.140
我把他拿过来

01:06:43.140 --> 01:06:44.140
出来了

01:06:44.140 --> 01:06:45.140
吓我一跳

01:06:45.140 --> 01:06:47.140
对应的是这个

01:06:47.140 --> 01:06:48.140
首先的话

01:06:48.140 --> 01:06:50.140
这边判断是否有这个副作用

01:06:50.140 --> 01:06:51.140
如果没有副作用

01:06:51.140 --> 01:06:52.140
没有副作用

01:06:52.140 --> 01:06:53.140
这边他还会有一个

01:06:53.140 --> 01:06:54.140
fiber tray的切换

01:06:54.140 --> 01:06:56.140
这个我们在后面讲

01:06:56.140 --> 01:06:57.140
fiber

01:06:57.140 --> 01:06:59.140
就是讲fiber双缓存的时候

01:06:59.140 --> 01:07:00.140
我们就会说

01:07:00.140 --> 01:07:01.140
他会有这么一个步骤

01:07:01.140 --> 01:07:03.140
进行fiber tray的切换

01:07:03.140 --> 01:07:04.140
切换了之后

01:07:04.140 --> 01:07:06.140
然后加这边就完成了

01:07:06.140 --> 01:07:07.140
对吧

01:07:07.140 --> 01:07:08.140
完成

01:07:08.140 --> 01:07:09.140
完成之后

01:07:09.140 --> 01:07:11.140
然后加这边就调度新的更新

01:07:11.140 --> 01:07:12.140
相当于这边的话

01:07:12.140 --> 01:07:13.140
又回到什么

01:07:13.140 --> 01:07:14.140
又回到skeleton了

01:07:15.140 --> 01:07:16.140
如果有副作用

01:07:16.140 --> 01:07:17.140
有副作用的话

01:07:17.140 --> 01:07:18.140
这边就会经历

01:07:18.140 --> 01:07:19.140
before motation

01:07:20.140 --> 01:07:22.140
motation完了之后

01:07:22.140 --> 01:07:23.140
fiber tray进行切换

01:07:23.140 --> 01:07:25.140
那最后这个nilt

01:07:25.140 --> 01:07:26.140
nilt完了之后

01:07:26.140 --> 01:07:28.140
相当于就是渲染完毕了

01:07:28.140 --> 01:07:29.140
渲染完毕之后

01:07:29.140 --> 01:07:31.140
大家这边调度新的更新

01:07:33.140 --> 01:07:34.140
记住就是这边的话

01:07:34.140 --> 01:07:36.140
我们这边这三个

01:07:36.140 --> 01:07:37.140
这三大组件

01:07:37.140 --> 01:07:38.140
我们在这一节的话

01:07:38.140 --> 01:07:40.140
主要是就是大致介绍了一下

01:07:40.140 --> 01:07:41.140
这三大组件

01:07:41.140 --> 01:07:43.140
个子是干什么用的

01:07:43.140 --> 01:07:44.140
后面的话

01:07:44.140 --> 01:07:45.140
我们基本上就是什么

01:07:45.140 --> 01:07:46.140
基本上就是围绕

01:07:46.140 --> 01:07:48.140
这三大组件展开

01:07:48.140 --> 01:07:49.140
后面的话

01:07:49.140 --> 01:07:50.140
我们就挨着来讲

01:07:50.140 --> 01:07:51.140
比较调度器

01:07:51.140 --> 01:07:53.140
它如何进行调度的

01:07:53.140 --> 01:07:54.140
协调器

01:07:54.140 --> 01:07:55.140
它如何进行调合的

01:07:55.140 --> 01:07:56.140
对

01:07:56.140 --> 01:07:57.140
它的那个begin walk

01:07:57.140 --> 01:07:58.140
complete walk

01:07:58.140 --> 01:07:59.140
究竟在做什么

01:07:59.140 --> 01:08:01.140
这个渲染器

01:08:01.140 --> 01:08:02.140
这个每个阶段

01:08:02.140 --> 01:08:03.140
对吧

01:08:03.140 --> 01:08:04.140
每个阶段

01:08:04.140 --> 01:08:05.140
究竟在做什么

01:08:05.140 --> 01:08:06.140
这几个的话

01:08:06.140 --> 01:08:07.140
主要是带着大家

01:08:07.140 --> 01:08:09.140
把这个渲染流程

01:08:09.140 --> 01:08:10.140
把它过一遍

01:08:10.140 --> 01:08:11.140
大家知道

01:08:11.140 --> 01:08:13.140
有这么三大组件

01:08:13.140 --> 01:08:14.140
每个组件的话

01:08:14.140 --> 01:08:15.140
大致在做什么事情

01:08:15.140 --> 01:08:17.140
大家心里有个数

01:08:17.140 --> 01:08:18.140
OK

01:08:18.140 --> 01:08:20.140
实际上你把这几个听了之后

01:08:20.140 --> 01:08:21.140
你这边的话

01:08:21.140 --> 01:08:23.140
实际上已经可以和面试关聊很多了

01:08:23.140 --> 01:08:24.140
对不对

01:08:24.140 --> 01:08:27.140
这几个实际上是非常重要的一节课

01:08:27.140 --> 01:08:29.140
你把这几个听了之后

01:08:29.140 --> 01:08:30.140
你针对整个react

01:08:30.140 --> 01:08:32.140
你可能不知道它里面的细节

01:08:32.140 --> 01:08:33.140
比如这个调度器

01:08:33.140 --> 01:08:34.140
它具体是怎么调度的

01:08:34.140 --> 01:08:35.140
协调器

01:08:35.140 --> 01:08:36.140
它具体是怎么调合的

01:08:36.140 --> 01:08:37.140
细节你不太清楚

01:08:37.140 --> 01:08:39.140
但是它整体的这种架构

01:08:39.140 --> 01:08:41.140
你是不是就已经清楚了

01:08:41.140 --> 01:08:42.140
对不对

01:08:42.140 --> 01:08:44.140
你就可以和面试关聊了

01:08:44.140 --> 01:08:46.140
这是关于整个react

01:08:46.140 --> 01:08:47.140
渲染流程

01:08:48.140 --> 01:08:49.140
最后的话

01:08:49.140 --> 01:08:51.140
还是关于整体解答

01:08:51.140 --> 01:08:52.140
整体解答的话

01:08:52.140 --> 01:08:53.140
我这边就直接把这边

01:08:53.140 --> 01:08:54.140
我的这个单

01:08:54.140 --> 01:08:57.640
我把它过来

01:08:57.640 --> 01:08:59.640
把它放到这边

01:08:59.640 --> 01:09:01.640
这边可以看一下

01:09:01.640 --> 01:09:02.640
react的整体渲染流程

01:09:02.640 --> 01:09:04.640
可以分成两大阶段

01:09:04.640 --> 01:09:05.640
Render和Commit

01:09:05.640 --> 01:09:06.640
Render的话

01:09:06.640 --> 01:09:08.640
它是在内存中运行

01:09:08.640 --> 01:09:09.640
易不可中断

01:09:09.640 --> 01:09:11.640
Commit它是同步不可中断

01:09:11.640 --> 01:09:12.640
好

01:09:12.640 --> 01:09:13.640
在这边的话

01:09:13.640 --> 01:09:15.640
两大阶段又分成了三大组件

01:09:15.640 --> 01:09:16.640
调度器

01:09:16.640 --> 01:09:17.640
它是属于Render阶段

01:09:17.640 --> 01:09:18.640
协调器

01:09:18.640 --> 01:09:19.640
它也是Render阶段

01:09:19.640 --> 01:09:21.640
是不是第二阶段的工作

01:09:21.640 --> 01:09:22.640
渲染器

01:09:22.640 --> 01:09:24.640
渲染器的话就是Commit阶段

01:09:24.640 --> 01:09:26.640
各自的一个任务

01:09:27.640 --> 01:09:33.640
这就是关于react整体的渲染流程

01:09:33.640 --> 01:09:34.640
大家下来的话

01:09:34.640 --> 01:09:37.640
可以把这些课的内容

01:09:37.640 --> 01:09:39.640
自己的话再看一下

01:09:40.640 --> 01:09:41.640
好吧

01:09:41.640 --> 01:09:43.640
这些课的话差不多就到这里

01:09:43.640 --> 01:09:44.640
再见

01:09:45.640 --> 01:09:46.640
谢谢大家

