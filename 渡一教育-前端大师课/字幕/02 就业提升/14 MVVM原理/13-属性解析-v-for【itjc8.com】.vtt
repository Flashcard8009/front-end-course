WEBVTT

00:02.610 --> 00:04.610
哈喽 大家好啊

00:05.610 --> 00:08.610
这一集我们正式来开始说微缝

00:08.610 --> 00:09.610
微缝缝

00:09.610 --> 00:11.610
还是在说微缝缝之前

00:11.610 --> 00:13.610
我们先创建一个新的文件

00:14.610 --> 00:18.620
好卡

00:18.620 --> 00:20.620
卡住了

00:21.620 --> 00:23.620
这得稍等一下

00:23.620 --> 00:27.620
我看一下得重启一下这个软件

00:29.620 --> 00:37.420
我重启一下这个软件

00:38.420 --> 00:41.420
好了 我们新建一个微缝缝

00:41.420 --> 00:43.420
就叫微缝

00:46.730 --> 00:49.730
我们这微缝里面有一个什么呢

00:49.730 --> 00:51.730
对于一个微缝的处置话

00:53.730 --> 00:54.730
微缝

00:56.730 --> 00:58.730
微缝

00:58.730 --> 01:00.730
需要传什么呢 咱们待会再说

01:00.730 --> 01:02.730
需要传什么咱们待会再说

01:03.730 --> 01:05.730
咱现在看一下

01:05.730 --> 01:07.730
看一下我如果写微缝的话 我要怎么写

01:10.730 --> 01:12.730
比如说这块有一个URI

01:13.730 --> 01:17.360
然后这里面有LRI 是吧

01:18.360 --> 01:20.360
我如果写这样的

01:20.360 --> 01:22.360
括号

01:22.360 --> 01:23.360
T

01:23.360 --> 01:24.360
IN

01:24.360 --> 01:25.360
LEASE

01:25.360 --> 01:27.360
可以吧 我是说有LEASE的

01:30.360 --> 01:32.360
是吧 是不是可以 有这个 是吧

01:32.360 --> 01:34.360
然后呢 我们来写一个

01:35.360 --> 01:37.360
姓名

01:38.360 --> 01:39.360
然后

01:39.360 --> 01:41.360
KEY的A

01:42.360 --> 01:44.360
倒号

01:44.360 --> 01:45.360
年龄

01:45.360 --> 01:49.760
KEY的B

01:50.760 --> 01:52.760
这是一个模板 是吧

01:52.760 --> 01:54.760
它不是一个正经的标签

01:54.760 --> 01:55.760
正经的标签没有这样的 是吧

01:55.760 --> 01:56.760
没有什么微缝 是吧

01:56.760 --> 01:58.760
也没有这么里面的东西 是吧

01:58.760 --> 02:01.760
所以说呢 这个东西是一个虚拟的

02:01.760 --> 02:04.760
而且你这个LEASE有多长呢

02:04.760 --> 02:06.760
它就得出来多少个 是吧

02:06.760 --> 02:08.760
我不能用原来的节点 是吧

02:08.760 --> 02:11.760
我得生成一堆节点 是吧

02:11.760 --> 02:13.760
我得生成一堆节点 是吧

02:13.760 --> 02:16.760
我生成的这些节点不是我们原来写的

02:18.760 --> 02:21.760
我们生成的节点不是我们原来写的

02:23.760 --> 02:24.760
所以说这个节点

02:24.760 --> 02:27.760
我们只能在逻辑中存在

02:27.760 --> 02:31.760
生成的节点都是由这个节点生成的

02:31.760 --> 02:35.760
所以说这块会有一个比较经典的一个逻辑

02:35.760 --> 02:38.760
这块会有一个比较经典的逻辑

02:38.760 --> 02:43.260
VUE呢 它给在这里面隐藏了一下

02:43.260 --> 02:45.260
VUE里面给它隐藏了一下

02:45.260 --> 02:49.260
但是它本质上一般情况下都有这样的逻辑

02:49.260 --> 02:52.260
像有的同学如果了解红黑树的话

02:52.260 --> 02:54.260
你们应该能够知道一点

02:54.260 --> 02:56.260
比如说 这个是外层的节点

02:56.260 --> 02:57.260
这个是UL

02:59.260 --> 03:02.260
然后我们希望是下面有三个Li

03:02.260 --> 03:05.260
但是是这个微缝形式

03:05.260 --> 03:08.260
我希望通过这一个Li生成三个Li

03:08.260 --> 03:10.260
你说怎么生成

03:10.260 --> 03:14.960
我再生成两个

03:14.960 --> 03:18.910
不能这样吧

03:18.910 --> 03:19.910
因为它是模板

03:19.910 --> 03:21.910
我还得把它直给改了

03:21.910 --> 03:23.910
然后下回再改的时候

03:23.910 --> 03:25.910
我就再也找不到什么

03:25.910 --> 03:27.910
再也找不到原来的那个模板了

03:27.910 --> 03:29.910
我到了时候想改我都没法改

03:29.910 --> 03:31.910
所以这种情况下怎么办

03:31.910 --> 03:33.910
Li三个还是得生成的

03:34.910 --> 03:36.910
但是过去的那个

03:36.910 --> 03:38.910
我也不扔过去的这个

03:38.910 --> 03:40.910
我变成一个虚拟的Li

03:44.180 --> 03:46.180
这个我给它变成一个虚拟的Li

03:48.180 --> 03:49.180
它变成个虚拟

03:49.180 --> 03:52.180
真实的节点是UL,Li,Li,Li

03:52.180 --> 03:54.180
但是因为这三个Li都是它生成的

03:54.180 --> 03:57.180
所以这三个Li在微弄的上

03:57.180 --> 03:59.180
是挂在这个的下面

03:59.180 --> 04:01.180
微弄的上是挂在这个的下面

04:01.180 --> 04:03.180
在微弄的里面是UL

04:03.180 --> 04:05.180
UL下面下是一个虚拟的

04:05.180 --> 04:07.180
模板Li

04:07.180 --> 04:09.180
然后这个模板Li下面是

04:09.180 --> 04:11.180
三个真正的Li

04:11.180 --> 04:13.180
在真正的节点上

04:13.180 --> 04:15.180
就是一个UL下面有三个Li

04:15.180 --> 04:17.180
这样的话

04:17.180 --> 04:19.180
如果你对Li进行修改了的话

04:19.180 --> 04:21.180
我可以重新的根据这个模板

04:21.180 --> 04:23.180
我可以基于这个虚拟节点

04:23.180 --> 04:25.180
重新的再生成

04:25.180 --> 04:27.180
下面的Li

04:27.180 --> 04:29.180
有了它在

04:29.180 --> 04:31.180
我就能生成很多个新的Li

04:31.180 --> 04:33.180
是吧,因为模板在它这里

04:33.180 --> 04:35.180
对吧,你生成了这种Li之后

04:35.180 --> 04:37.180
你的模板就没了

04:37.180 --> 04:39.180
是吧,key,list

04:39.180 --> 04:41.180
那些东西就全都没了是吧

04:41.180 --> 04:43.180
所以下面这个Li只是一个生成品

04:43.180 --> 04:45.180
我们通过上面这个Li

04:45.180 --> 04:47.180
来进行归纳和管理

04:47.180 --> 04:49.180
这就是一个虚拟的

04:49.180 --> 04:51.180
在外界你看不到是吧

04:51.180 --> 04:53.180
在外界UL下面就是三个Li

04:53.180 --> 04:55.180
然后真正的微弄意

04:55.180 --> 04:57.180
它通过一些手法

04:57.180 --> 04:59.180
把这个Li合并到UL里去

04:59.180 --> 05:01.180
但是实际上

05:01.180 --> 05:03.180
在各种框架里面

05:03.180 --> 05:05.180
如果遇到这种情况

05:05.180 --> 05:07.180
手选的方式就是生成一个虚拟道

05:07.180 --> 05:09.180
虚拟节点

05:09.180 --> 05:11.180
对于节点来说

05:11.180 --> 05:13.180
它都是个虚拟道

05:13.180 --> 05:15.180
它是一个虚拟的节点

05:15.180 --> 05:17.180
这个虚拟的节点

05:17.180 --> 05:19.180
只起到一个收纳的作用

05:19.180 --> 05:21.180
把下面这些收纳在一起

05:21.180 --> 05:23.180
然后把他们这些共用的东西

05:23.180 --> 05:25.180
都写在这个虚拟的节点里面

05:25.180 --> 05:27.180
把他们共用的东西都写在这个虚拟节点里面

05:28.180 --> 05:30.180
比如说他们那些属性

05:30.180 --> 05:32.180
都写在这个虚拟的节点里面

05:32.180 --> 05:34.180
是一个这样的一个方式

05:34.180 --> 05:36.180
当然这个虚拟的节点的

05:36.180 --> 05:38.180
最后可以和UL进行合并

05:38.180 --> 05:40.180
但是我们不做这个合并

05:40.180 --> 05:42.180
我们来把经典的这种写法

05:42.180 --> 05:43.180
给大家来写出来

05:43.180 --> 05:45.180
这个是一个比较经典的写

05:45.180 --> 05:47.180
那怎么来写

05:47.180 --> 05:49.180
还是刚才都已经

05:49.180 --> 05:51.180
能够分析ATT2了是吧

05:51.180 --> 05:53.180
能够分析ATT2了

05:53.180 --> 05:55.180
然后我们除了分析猫头之外

05:55.180 --> 05:57.180
我们再来分析Vifl

05:57.180 --> 05:58.180
Vifl

06:11.220 --> 06:13.220
如果有这个东西的存在

06:15.220 --> 06:17.220
如果有这个Vifl的存在

06:17.220 --> 06:19.220
代表着我们需要

06:19.220 --> 06:21.220
用Vifl的方式

06:21.220 --> 06:23.220
我用Vifl

06:33.290 --> 06:34.290
你想想

06:34.290 --> 06:35.290
我们得通过什么东西

06:35.290 --> 06:36.290
创建出来

06:37.290 --> 06:38.290
Vm不用说了

06:38.290 --> 06:40.290
是必须得传的是吧

06:40.290 --> 06:41.290
iMint也不说了

06:41.290 --> 06:42.290
必须得传的是吧

06:42.290 --> 06:44.290
然后我们传一个Pirate

06:44.290 --> 06:46.290
三件课是吧

06:46.290 --> 06:48.290
这就是我们这里面传进来

06:48.290 --> 06:49.290
我都给它传进去

06:49.290 --> 06:51.290
然后再有一个

06:51.290 --> 06:53.290
就是Vifl里的直

06:53.290 --> 06:55.290
你那个人传的就是吧

06:55.290 --> 06:56.290
这是Vifl里的直

06:56.290 --> 06:57.290
一般都是咋的

06:57.290 --> 06:58.290
比如这样是吧

06:58.290 --> 06:59.290
T

07:03.140 --> 07:04.140
因利死是吧

07:04.140 --> 07:05.140
一般都是这样的

07:05.140 --> 07:07.140
把这个直给传进去

07:08.140 --> 07:14.980
iMint.getTribute

07:14.980 --> 07:15.980
Vi

07:15.980 --> 07:19.770
是吧

07:19.770 --> 07:21.770
这样的四个直

07:21.770 --> 07:22.770
那我们把这个四个直

07:22.770 --> 07:24.770
作为它的参数

07:24.770 --> 07:31.340
Vi

07:31.340 --> 07:33.340
iMintPirate

07:33.340 --> 07:35.340
这个呢给它取个名字

07:35.340 --> 07:37.340
取个名字叫什么

07:37.340 --> 07:38.340
叫data

07:39.340 --> 07:40.340
这里面实际上是它的

07:40.340 --> 07:41.340
这个命令是吧

07:41.340 --> 07:42.340
指令是吧

07:42.340 --> 07:44.340
你就要instruction

07:44.340 --> 07:47.720
instruction是

07:47.720 --> 07:48.720
这里面的一个指令

07:48.720 --> 07:50.720
这里面的一个指令

07:50.720 --> 07:51.720
那刚才怎么说

07:51.720 --> 07:53.720
我们需要把之前的

07:53.720 --> 07:55.720
这个节点变成一个虚拟节点

07:55.720 --> 07:58.720
let一个vertial node

07:58.720 --> 08:00.720
等于New一个

08:00.720 --> 08:02.720
node

08:02.720 --> 08:10.940
首先是iMint.nodeName

08:10.940 --> 08:12.940
这是第一个节点是吧

08:12.940 --> 08:14.940
iMint.nodeName

08:14.940 --> 08:15.940
我们刚才这个节点是啥

08:15.940 --> 08:17.940
我们把nodeName就写进来

08:17.940 --> 08:19.940
然后iMint.node写进来

08:19.940 --> 08:20.940
这都没三个说

08:20.940 --> 08:22.940
这些都是必须点写的

08:22.940 --> 08:23.940
然后求准这一块

08:23.940 --> 08:25.940
我添一个空

08:25.940 --> 08:27.940
然后tyx的这一块

08:27.940 --> 08:28.940
我也添了空

08:28.940 --> 08:29.940
是吧

08:29.940 --> 08:31.940
没记错是吧

08:31.940 --> 08:35.410
这不是node

08:35.410 --> 08:41.280
是vnode

08:41.280 --> 08:43.280
这个vnode它得import

08:43.280 --> 08:45.280
import

08:45.280 --> 08:48.280
vnode

08:48.280 --> 08:50.280
from

08:50.280 --> 08:55.040
上级目录下的

08:55.040 --> 08:57.040
上级目录下的

08:57.040 --> 09:00.040
vnode.gs

09:00.040 --> 09:01.040
是吧

09:01.040 --> 09:04.040
这有了vnode

09:04.040 --> 09:06.040
然后tyx的这之后是啥

09:06.040 --> 09:10.480
data parent的这些东西

09:10.480 --> 09:12.480
data

09:12.480 --> 09:14.480
data是啥

09:14.480 --> 09:16.480
data我存个啥

09:16.480 --> 09:20.480
data

09:20.480 --> 09:22.480
我们这个里面还真得用

09:22.480 --> 09:24.480
我们先写个空

09:24.480 --> 09:26.480
待会来玩说

09:26.480 --> 09:28.480
然后parent

09:28.480 --> 09:30.480
然后node太好

09:30.480 --> 09:32.480
看好了我虚拟节点

09:32.480 --> 09:34.480
不是真实的

09:34.480 --> 09:35.480
没有这个节点对吧

09:35.480 --> 09:37.480
写个零

09:37.480 --> 09:39.480
一是标签

09:39.480 --> 09:41.480
三是文本我写个零

09:41.480 --> 09:43.480
表示这个节点没有异

09:43.480 --> 09:45.480
这个节点是个虚拟

09:45.480 --> 09:46.480
然后看好了

09:46.480 --> 09:47.480
这个有个data

09:47.480 --> 09:48.480
我们又来存什么呢

09:48.480 --> 09:50.480
我还真是需要用一下

09:50.480 --> 09:52.480
就是我来存一下

09:52.480 --> 09:54.480
这个东西的值

09:54.480 --> 09:55.480
这个东西

09:55.480 --> 09:56.480
这个标签里面

09:56.480 --> 10:00.480
引用了我的哪一个变量

10:00.480 --> 10:02.480
比如说

10:02.480 --> 10:04.480
你这个key

10:04.480 --> 10:06.480
in list

10:06.480 --> 10:08.480
你说它引的是谁

10:08.480 --> 10:10.480
引的是这个list

10:10.480 --> 10:12.480
引的是这个list

10:12.480 --> 10:14.480
所以说我希望能够解析一下

10:14.480 --> 10:15.480
这个东西

10:15.480 --> 10:17.480
我要把这个list给它解析出

10:17.480 --> 10:19.480
我们这里面一般都是三段的

10:19.480 --> 10:20.480
左中右这么三段

10:20.480 --> 10:22.480
所以我希望把这个list

10:22.480 --> 10:23.480
这个东西给它解析出

10:23.480 --> 10:25.480
把list的这个东西给解析出

10:25.480 --> 10:27.480
但是我们现在还没有

10:27.480 --> 10:29.480
一个解析这样的东西的语法

10:29.480 --> 10:30.480
我写一个

10:30.480 --> 10:32.480
方式

10:32.480 --> 10:34.480
get word

10:34.480 --> 10:37.480
to loaded

10:37.480 --> 10:42.820
instructions

10:42.820 --> 10:44.820
我们在这里面先存一下

10:44.820 --> 10:47.820
很有可能就会有用

10:47.820 --> 10:49.820
light

10:49.820 --> 10:51.820
instructions

10:51.820 --> 10:53.820
instructions

10:53.820 --> 10:55.820
instructream

10:55.820 --> 10:58.820
先把它的两边的这个控制的区调

10:58.820 --> 11:02.130
split

11:02.130 --> 11:04.130
控制

11:04.130 --> 11:07.130
用控制来签

11:07.130 --> 11:11.130
然后我们这个如果

11:11.130 --> 11:13.130
insight the length

11:13.130 --> 11:18.460
我们希望是等于三的是吧

11:18.460 --> 11:20.460
或者是

11:20.460 --> 11:22.460
insight

11:22.460 --> 11:24.460
e这个位置

11:24.460 --> 11:25.460
不等于

11:25.460 --> 11:26.460
in

11:26.460 --> 11:28.460
且

11:28.460 --> 11:30.460
insight

11:30.460 --> 11:31.460
e这个位置

11:31.460 --> 11:33.460
不等于

11:33.460 --> 11:35.460
off

11:35.460 --> 11:36.460
我要是便利的话

11:36.460 --> 11:37.460
这边要没有in

11:37.460 --> 11:38.460
要没有off是吧

11:38.460 --> 11:40.460
我们假设说只支持这种写法

11:40.460 --> 11:41.460
我们现在就是

11:41.460 --> 11:42.460
只支持这种写法

11:42.460 --> 11:43.460
有同学说

11:43.460 --> 11:45.460
你这边可能有很多的这个语法

11:45.460 --> 11:47.460
但是我们没法的是讲

11:47.460 --> 11:48.460
为什么呢

11:48.460 --> 11:50.460
因为他们这种语法解析

11:50.460 --> 11:51.460
是专门的一种学科

11:51.460 --> 11:54.460
语法解析是专门的一种学科

11:54.460 --> 11:57.460
如果你在学校里学过编译原理的话

11:57.460 --> 11:59.460
你要知道编译原理

11:59.460 --> 12:01.460
要想做一个语法解析

12:01.460 --> 12:03.460
要写成千上万

12:03.460 --> 12:05.460
我们是不能用这种正规的方式

12:05.460 --> 12:07.460
来写语法解析的

12:07.460 --> 12:08.460
要不然的话就写不完

12:08.460 --> 12:09.460
我们有穷自动机

12:09.460 --> 12:10.460
无穷自动机

12:10.460 --> 12:11.460
三元是四元是这种

12:11.460 --> 12:12.460
语法分析

12:12.460 --> 12:13.460
词法分析

12:13.460 --> 12:15.460
什么这个

12:15.460 --> 12:17.460
这样的这个语异分析

12:17.460 --> 12:18.460
我们没法这么写

12:18.460 --> 12:19.460
所以说

12:19.460 --> 12:21.460
其实这个VUE

12:21.460 --> 12:22.460
很大的一部分

12:22.460 --> 12:24.460
有很大的一部分的代码

12:24.460 --> 12:25.460
再做这个编译

12:25.460 --> 12:26.460
再做这个编译

12:26.460 --> 12:28.460
如果你在学校里面

12:28.460 --> 12:31.460
有过这种学习经历的话

12:31.460 --> 12:33.460
你可以尝试着来写一下

12:33.460 --> 12:35.460
GS的编译器

12:35.460 --> 12:36.460
GS的编译器

12:36.460 --> 12:39.460
如果你要是没有这个经历的话

12:39.460 --> 12:41.460
或者是学校里面不教这些

12:41.460 --> 12:42.460
或者是会编编译学的

12:42.460 --> 12:43.460
一点都不好的话

12:43.460 --> 12:44.460
那就算了

12:44.460 --> 12:46.460
这个东西可以不会

12:46.460 --> 12:48.460
编译原理这种东西可以不会

12:48.460 --> 12:50.460
它跟算法什么的也不相关

12:50.460 --> 12:51.460
编译是一套单独的理论

12:52.460 --> 12:55.460
我们就不按编译的方式去写

12:55.460 --> 12:57.460
编译的方式写的话

12:57.460 --> 12:58.460
我们今年也写完了

12:58.460 --> 13:00.460
因为一套编译的程序是

13:00.460 --> 13:02.460
既相当之前

13:02.460 --> 13:03.460
而且又相当大的

13:03.460 --> 13:05.460
我们就假设

13:05.460 --> 13:07.460
我们只支持这种句型

13:07.460 --> 13:09.460
我们现在就只能以指令式来做

13:09.460 --> 13:10.460
不能以编译式来做

13:10.460 --> 13:11.460
指令式来做的话

13:11.460 --> 13:13.460
就必须得有固定的句型

13:13.460 --> 13:15.460
编译式来做的话

13:15.460 --> 13:17.460
只要符合语法就OK

13:17.460 --> 13:19.460
如果要是

13:20.460 --> 13:22.460
不符合以上的条件的话

13:22.460 --> 13:28.140
那就刨出一个iR

13:28.140 --> 13:30.140
然后rechange

13:30.140 --> 13:32.140
insights

13:32.140 --> 13:34.140
这就是我们把这三段弄出来了

13:34.140 --> 13:36.140
是吧

13:36.140 --> 13:38.140
那我这个none

13:38.140 --> 13:40.140
我要放入的是

13:40.140 --> 13:42.140
load date

13:42.140 --> 13:44.140
instraction

13:44.140 --> 13:46.140
传入去了之后我要

13:46.140 --> 13:47.140
第二节

13:47.140 --> 13:48.140
二号

13:48.140 --> 13:49.140
零号

13:49.140 --> 13:50.140
一号

13:50.140 --> 13:51.140
二号是吧

13:51.140 --> 13:52.140
我要的是lease

13:52.140 --> 13:54.140
这个节点和

13:54.140 --> 13:56.140
哪一个

13:56.140 --> 13:57.140
属性

13:57.140 --> 13:58.140
或者是哪一个变量

13:58.140 --> 14:00.140
进行了关联

14:00.140 --> 14:01.140
它用到的是哪一个属性

14:01.140 --> 14:03.140
或者哪一个变量

14:03.140 --> 14:05.140
我要拿到这个

14:05.140 --> 14:06.140
这是一个virtual node

14:06.140 --> 14:08.140
是吧

14:08.140 --> 14:09.140
然后呢

14:09.140 --> 14:11.140
我们让这个virtual node

14:11.140 --> 14:13.140
instructions

14:13.140 --> 14:15.140
等于instructions

14:15.140 --> 14:16.140
这是

14:16.140 --> 14:17.140
它特有的是吧

14:17.140 --> 14:19.140
我们之前就是定义了存放指令的

14:19.140 --> 14:21.140
存放模板的存放环境变量

14:21.140 --> 14:23.140
这会用到了一个

14:23.140 --> 14:25.140
用它来存一下

14:25.140 --> 14:27.140
然后

14:27.140 --> 14:28.140
怎么样

14:28.140 --> 14:30.140
我得让我的副级

14:30.140 --> 14:32.140
把我当前的节点给它删了

14:32.140 --> 14:33.140
是吧

14:33.140 --> 14:35.140
我当前的节点是这样的

14:35.140 --> 14:36.140
是吧

14:36.140 --> 14:38.140
这个节点我们说了是个虚拟

14:38.140 --> 14:39.140
我要创建出来

14:39.140 --> 14:40.140
你这个例子里面有两个

14:40.140 --> 14:42.140
那我就创建出来两个iR

14:42.140 --> 14:43.140
你这个例子里面有三个

14:43.140 --> 14:45.140
我就创建出来三个iR

14:45.140 --> 14:47.140
总之虚拟的我们得给它删掉

14:47.140 --> 14:49.140
虚拟的我们得给它删掉

14:49.140 --> 14:50.140
怎么删

15:05.940 --> 15:07.940
把我们这个当前给移除掉

15:07.940 --> 15:09.940
移除掉了之后

15:09.940 --> 15:11.940
因为有一些bug

15:11.940 --> 15:13.940
因为这种是我们得补充回来一个

15:13.940 --> 15:14.940
就像我这个

15:14.940 --> 15:16.940
我把它给移除了是吧

15:16.940 --> 15:18.940
我把它给移除了之后

15:18.940 --> 15:20.940
就只剩下一个倒不及点

15:20.940 --> 15:22.940
就只剩下一个倒不及点

15:22.940 --> 15:24.940
它会删除一个标下的一点

15:24.940 --> 15:25.940
还会跟

15:25.940 --> 15:28.940
还会连带着删除一个文本节点

15:28.940 --> 15:31.940
我们为了让它这个结构保持一致

15:31.940 --> 15:33.940
为了让这个结构保持一致

15:33.940 --> 15:36.940
我们在这边再加过来一个文本节点

15:36.940 --> 15:40.770
Appendure Chill

15:40.770 --> 15:41.770
其实加的一块一个

15:41.770 --> 15:42.770
没有什么意义

15:42.770 --> 15:43.770
但是我们为了就是

15:43.770 --> 15:45.770
跟过去保持一致

15:45.770 --> 15:46.770
Create

15:46.770 --> 15:47.770
不是iR

15:47.770 --> 15:49.770
CreatePython

15:51.770 --> 15:52.770
什么也没有

15:53.770 --> 15:55.770
就是一个空的文本节点

15:55.770 --> 15:57.770
来占一个节点的位置

15:59.770 --> 16:01.770
这块我就完成了一个

16:01.770 --> 16:03.770
最基本的一个添加这个节点

16:03.770 --> 16:05.770
然后最后我转移回去

16:06.770 --> 16:08.770
一个Virtual Note

16:08.770 --> 16:09.770
这样的话

16:09.770 --> 16:10.770
我这个Virtual Note

16:10.770 --> 16:12.770
就是一个节点了是吧

16:12.770 --> 16:13.770
然后我所有的节点

16:13.770 --> 16:15.770
都要在我这个之下

16:15.770 --> 16:16.770
我的所有的节点

16:16.770 --> 16:17.770
都要在我这个之下

16:18.770 --> 16:20.770
那我要创建几个节点呢

16:20.770 --> 16:21.770
还不知道是吧

16:22.770 --> 16:23.770
我要创建几个节点

16:23.770 --> 16:24.770
不知道是吧

16:24.770 --> 16:25.770
我得分析的出来

16:25.770 --> 16:26.770
这个属性了

16:26.770 --> 16:27.770
我才能知道

16:27.770 --> 16:28.770
我要创建几个节点是吧

16:28.770 --> 16:30.770
那我们来用一个方法

16:37.770 --> 16:39.770
我们来分析一下这个体令

16:44.210 --> 16:45.210
传入

16:52.210 --> 16:54.650
我们把这几个东西传进去

16:55.650 --> 16:57.650
我要来分析一下

16:57.650 --> 16:58.650
这个指令

16:58.650 --> 16:59.650
到底都

16:59.650 --> 17:00.650
要做些什么

17:01.650 --> 17:05.020
那我把这几个写这里吧

17:09.580 --> 17:10.580
好吧

17:10.580 --> 17:11.580
首先第一个

17:11.580 --> 17:12.580
首先第一个

17:12.580 --> 17:14.580
我要把这个指令给他弄出来

17:14.580 --> 17:15.580
Inside

17:16.580 --> 17:17.580
等于

17:18.580 --> 17:20.580
把这个指令给他解析一下

17:25.320 --> 17:26.320
然后呢

17:26.320 --> 17:27.320
我们让这个

17:27.320 --> 17:28.320
把这个值给他拿到

17:28.320 --> 17:30.320
我们刚才说的这个2号

17:30.320 --> 17:32.320
是他这里面这个值是吧

17:32.320 --> 17:34.320
那他对应的对象是哪一个

17:34.320 --> 17:35.320
是吧

17:35.320 --> 17:36.320
我们得给他弄

17:36.320 --> 17:37.320
data set

17:38.320 --> 17:39.320
等于getValue

17:40.320 --> 17:42.630
是吧

17:42.630 --> 17:43.630
用到这个

17:43.630 --> 17:44.630
工具了是吧

17:44.630 --> 17:45.630
getValue

17:46.630 --> 17:48.630
Vm的data

17:48.630 --> 17:49.630
从这里面去取

17:49.630 --> 17:50.630
取谁

17:51.630 --> 17:54.070
取谁呢

17:54.070 --> 17:57.070
也不一定非得从这里面去取是吧

17:58.070 --> 17:59.070
Vm的

18:01.070 --> 18:02.070
Vm的啥呀

18:02.070 --> 18:04.070
Vm的data

18:06.700 --> 18:07.700
是吧

18:07.700 --> 18:08.700
哎

18:08.700 --> 18:11.460
取谁

18:11.460 --> 18:12.460
我看到了

18:12.460 --> 18:14.460
这里传的是个数组

18:14.460 --> 18:15.460
啊

18:15.460 --> 18:16.460
这里不是数组是吧

18:16.460 --> 18:23.190
对

18:24.190 --> 18:25.190
对

18:26.190 --> 18:27.190
取谁呢

18:28.190 --> 18:30.190
Inside20

18:30.190 --> 18:34.100
是吧

18:34.100 --> 18:36.100
他分成了三个部分

18:36.100 --> 18:38.100
0,1,2是吧

18:38.100 --> 18:39.100
我们取的是

18:39.100 --> 18:40.100
20个部分是吧

18:41.100 --> 18:43.100
我们从这个对象里面来取

18:43.100 --> 18:44.100
例子

18:44.100 --> 18:45.100
看看能不能取得到

18:45.100 --> 18:46.100
看能不能取得

18:46.100 --> 18:47.100
如果

18:48.100 --> 18:49.100
如果取不到

18:50.100 --> 18:52.990
如果取不到

18:52.990 --> 18:53.990
怎么办

18:53.990 --> 18:55.990
throw new arrow

18:56.990 --> 19:02.120
把这个 arrow 就给它拋出来

19:02.120 --> 19:03.120
告诉我们错了

19:03.120 --> 19:04.120
我们取不到这个

19:07.120 --> 19:08.120
然后呢

19:08.120 --> 19:09.120
如果能取得到

19:09.120 --> 19:10.120
如果能取得到

19:11.120 --> 19:13.120
那我们就复运会来辨识一下

19:13.120 --> 19:17.520
乱七个 i 等于

19:17.520 --> 19:18.520
i 小于

19:19.520 --> 19:20.520
data set

19:21.520 --> 19:22.520
的乱子

19:22.520 --> 19:23.520
乱子

19:25.520 --> 19:26.520
能取得到

19:26.520 --> 19:28.520
那我们就得创建节点了是吧

19:28.520 --> 19:30.520
每一个节点

19:30.520 --> 19:31.520
每去到一个数

19:31.520 --> 19:33.520
我得能创建出来一个节点是吧

19:33.520 --> 19:35.520
line 一个临时的一个道目等于

19:35.520 --> 19:37.520
document.creatElement

19:40.960 --> 19:42.960
我这个里面是个例子是吧

19:42.960 --> 19:43.960
我这里面拿出来之后

19:43.960 --> 19:44.960
起码得是个例子是吧

19:44.960 --> 19:46.960
我每拿出来一个例子

19:46.960 --> 19:48.960
每拿出来一个对象

19:48.960 --> 19:50.960
我就要创建出来一个节点是吧

19:50.960 --> 19:52.960
创建出来一个啥呢

19:52.960 --> 19:56.960
aliment.node name

19:56.960 --> 19:57.960
是吧

19:58.960 --> 19:59.960
我这个当前这个节点

19:59.960 --> 20:00.960
是什么tata标签

20:00.960 --> 20:01.960
我是li

20:01.960 --> 20:02.960
那我就创建出来

20:02.960 --> 20:03.960
n-li

20:03.960 --> 20:05.960
我要是一个是div

20:05.960 --> 20:06.960
我就创建出来n-div

20:06.960 --> 20:07.960
是吧

20:07.960 --> 20:09.960
总之随我这个标签

20:09.960 --> 20:10.960
是吧

20:10.960 --> 20:11.960
随我当前那个标签

20:11.960 --> 20:13.960
然后里面的内容

20:13.960 --> 20:15.960
time.dom

20:15.960 --> 20:17.960
the

20:17.960 --> 20:19.960
inner.html

20:19.960 --> 20:20.960
等于

20:21.960 --> 20:23.960
inner.html

20:24.960 --> 20:25.960
我这里面

20:25.960 --> 20:26.960
主板里面有啥

20:26.960 --> 20:27.960
你这里面就有啥

20:27.960 --> 20:28.960
我这里面有啥

20:28.960 --> 20:29.960
你这里面就是

20:31.960 --> 20:32.960
然后

20:32.960 --> 20:34.960
然后我就不得了

20:34.960 --> 20:35.960
你们看

20:38.530 --> 20:39.530
我这边是li的是吧

20:39.530 --> 20:41.530
比如说我创建出来两个

20:43.530 --> 20:44.530
创建出来两个

20:44.530 --> 20:46.530
你说我们这两个li

20:46.530 --> 20:47.530
这两个li

20:47.530 --> 20:50.530
下面是不是就都有key这个东西

20:51.530 --> 20:53.530
是不是都有都能访问到key

20:53.530 --> 20:54.530
是吧

20:54.530 --> 20:55.530
但是这两个li里面

20:55.530 --> 20:56.530
虽然都能访问到key

20:56.530 --> 20:58.530
但是他们key的值一样

20:59.530 --> 21:01.530
他这个key的值明显是不一样的

21:01.530 --> 21:02.530
是吧

21:02.530 --> 21:03.530
他的key的a很能是pan

21:03.530 --> 21:04.530
他的key的a是monkey

21:04.530 --> 21:05.530
是吧

21:05.530 --> 21:07.530
这两个key根本就不是一个对象

21:08.530 --> 21:09.530
是吧

21:09.530 --> 21:10.530
为啥

21:10.530 --> 21:11.530
虽然都叫key

21:11.530 --> 21:13.530
他们key是全局的

21:13.530 --> 21:14.530
不是全局的

21:14.530 --> 21:15.530
是吧

21:15.530 --> 21:17.530
是他们局部变量

21:17.530 --> 21:19.530
是他们局部变量的

21:19.530 --> 21:21.530
他这个也是他们局部变量

21:21.530 --> 21:22.530
这个里面的key

21:22.530 --> 21:24.530
也是他这个局部变量的

21:25.530 --> 21:26.530
他key的作用运能

21:26.530 --> 21:28.530
只能做到这个标签里

21:28.530 --> 21:29.530
他key的作用运能

21:29.530 --> 21:30.530
也只能做到这个标签里

21:30.530 --> 21:31.530
是吧

21:31.530 --> 21:32.530
每一个key只能做到

21:32.530 --> 21:33.530
每个标签里

21:33.530 --> 21:34.530
这个时候

21:34.530 --> 21:36.530
就真正的用到了

21:37.530 --> 21:40.530
我要给大家说的这个env

21:41.530 --> 21:43.530
来写一个line

21:43.530 --> 21:44.530
一个env

21:49.530 --> 21:50.530
来干嘛呢

21:50.530 --> 21:51.530
我们来分析一下

21:51.530 --> 21:52.530
来分析一下

22:05.890 --> 22:07.890
我们把这个什么东西传进呢

22:07.890 --> 22:08.890
insight0

22:11.710 --> 22:13.710
然后data side i

22:15.710 --> 22:16.710
是吧

22:16.710 --> 22:18.710
因为我这个是di的这个值了

22:18.710 --> 22:19.710
是吧

22:19.710 --> 22:20.710
然后i

22:21.710 --> 22:23.710
引代个都在序号上

22:23.710 --> 22:24.710
来写一下这个方法

22:34.460 --> 22:35.460
这三个值

22:35.460 --> 22:37.460
这三个值还挺多

22:38.460 --> 22:39.460
头一个值呢

22:39.460 --> 22:40.460
我们还得分析一下是吧

22:40.460 --> 22:42.460
第一个我们相当于是

22:44.460 --> 22:45.460
instructions

22:45.460 --> 22:46.460
前面是这个指令

22:46.460 --> 22:48.460
是这个t不key的

22:48.460 --> 22:49.460
然后呢是他对用这个值

22:49.460 --> 22:50.460
他的value是多少

22:50.460 --> 22:51.460
是吧

22:51.460 --> 22:52.460
然后呢

22:52.460 --> 22:53.460
最后一个是一个他的序列

22:53.460 --> 22:54.460
引代个4

22:56.460 --> 22:58.460
我们首先要判断的是

22:58.460 --> 22:59.460
前面这个是不是代块号

23:00.460 --> 23:02.460
因为我们这前面的可以

23:02.460 --> 23:03.460
key

23:03.460 --> 23:04.460
扩号key

23:04.460 --> 23:05.460
是吧

23:05.460 --> 23:06.460
也可以不代扩号

23:07.460 --> 23:08.460
这样是不是也行

23:08.460 --> 23:09.460
是吧

23:09.460 --> 23:10.460
代扩号呢

23:10.460 --> 23:12.460
我还可以key多号

23:12.460 --> 23:13.460
index

23:13.460 --> 23:14.460
是吧

23:14.460 --> 23:15.460
不是这样都行是吧

23:15.460 --> 23:17.460
所以呢我首先看他代不代扩号

23:18.460 --> 23:20.460
我什么样看他代不代扩号

23:21.460 --> 23:22.460
用一个政策来判断

23:23.460 --> 23:24.460
其实这些啊

23:24.460 --> 23:26.460
都是应该用什么来判断的

23:26.460 --> 23:27.460
都是应该用

23:27.460 --> 23:29.460
编译原理的方式来判断

23:30.460 --> 23:31.460
但是呢

23:32.460 --> 23:33.460
我们没有办法

23:33.460 --> 23:35.460
实在是没有办法来从头到尾

23:35.460 --> 23:36.460
来讲编译原理

23:36.460 --> 23:37.460
因为那种实在是

23:38.460 --> 23:39.460
太多太多太多了

23:42.670 --> 23:43.670
下方线啊

23:43.670 --> 23:44.670
dauler

23:45.670 --> 23:46.670
这样

23:47.670 --> 23:48.670
这样

23:48.670 --> 23:52.580
总之啊

23:52.580 --> 23:54.580
他是有多个这东西组成的

23:54.580 --> 23:56.580
加了之后是一个诱惑号

23:58.580 --> 23:59.580
他得带有这个东西

24:00.580 --> 24:01.580
点test

24:03.580 --> 24:04.580
来判断一下instruction

24:05.580 --> 24:07.580
如果他是代扩号

24:07.580 --> 24:08.580
我要把这个编号给扒下去

24:09.580 --> 24:15.970
先把他左右的这个痛惹削掉

24:16.970 --> 24:17.970
然后instruction

24:17.970 --> 24:19.970
等于instruction

24:19.970 --> 24:20.970
第二subsprint

24:21.970 --> 24:22.970
从第一位

24:23.970 --> 24:24.970
拖到

24:24.970 --> 24:25.970
点lans建议

24:26.970 --> 24:28.970
拖到倒置第一位

24:29.970 --> 24:30.970
这样的话

24:30.970 --> 24:31.970
我们把这个编号给干掉

24:31.970 --> 24:32.970
把编号给干掉

24:33.970 --> 24:34.970
这就剩下

24:34.970 --> 24:35.970
要么就是

24:35.970 --> 24:36.970
这种结构了

24:37.970 --> 24:38.970
t

24:38.970 --> 24:39.970
要么就是

24:39.970 --> 24:40.970
t.index

24:41.970 --> 24:42.970
t.index

24:42.970 --> 24:44.970
剩下这样就行事了

24:44.970 --> 24:46.970
然后light a piece

24:46.970 --> 24:47.970
等于

24:48.970 --> 24:49.970
instruction

24:49.970 --> 24:51.970
点play的倒号

24:53.970 --> 24:54.970
因为

24:54.970 --> 24:56.970
中间可能有多个属性的倒号

24:56.970 --> 24:57.970
可以开吗

24:57.970 --> 24:58.970
用多个属性的倒号可以开

25:00.970 --> 25:01.970
这是一个piece

25:02.970 --> 25:03.970
然后呢

25:03.970 --> 25:04.970
我们看这个if

25:07.980 --> 25:08.980
keys.lans

25:09.980 --> 25:10.980
等于1

25:12.980 --> 25:13.980
是不可能的是吧

25:14.980 --> 25:16.980
四周我们用一个iR

25:16.980 --> 25:23.840
然后呢

25:23.840 --> 25:25.840
我们来创建一个obj对象

25:27.840 --> 25:29.840
创建一个obj这样的对象

25:29.840 --> 25:30.840
看好了

25:30.840 --> 25:31.840
如果

25:31.840 --> 25:32.840
如果

25:33.840 --> 25:36.410
如果

25:37.410 --> 25:39.410
keys.lans

25:39.410 --> 25:40.410
lans

25:40.410 --> 25:41.410
等于1

25:42.410 --> 25:44.410
它就只有一个属性是吧

25:44.410 --> 25:45.410
obj

25:47.410 --> 25:48.410
keys0

25:49.410 --> 25:50.410
这是属性名是吧

25:53.410 --> 25:54.410
等于y6

25:56.410 --> 25:57.410
没啥问题是吧

25:57.410 --> 25:59.410
如果你只有一个对象的话

25:59.410 --> 26:00.410
那一定是

26:00.410 --> 26:02.410
我给你往这边复制是吧

26:03.410 --> 26:04.410
比如说

26:04.410 --> 26:05.410
如果只有

26:05.410 --> 26:06.410
t.index

26:06.410 --> 26:07.410
t.list

26:07.410 --> 26:08.410
t

26:08.410 --> 26:09.410
指带的就是那个值是吧

26:10.410 --> 26:11.410
是指带的是

26:11.410 --> 26:12.410
这个对象是吧

26:12.410 --> 26:13.410
这个t

26:13.410 --> 26:14.410
应该是指带的是这个对象

26:15.410 --> 26:16.410
如果

26:20.130 --> 26:21.130
keys.lans

26:25.490 --> 26:26.490
等于2

26:29.890 --> 26:30.890
是大于等于1

26:31.890 --> 26:33.890
如果它不但大于等于1

26:33.890 --> 26:34.890
还大于等于2

26:34.890 --> 26:35.890
怎么样

26:35.890 --> 26:37.890
说明它这里有可能是这种情况是吧

26:37.890 --> 26:39.890
t.index

26:40.890 --> 26:41.890
有可能是这种情况

26:41.890 --> 26:42.890
那我们怎么办

26:43.890 --> 26:47.220
怎么办

26:47.220 --> 26:48.220
obj

26:50.220 --> 26:53.220
keys1.t

26:54.220 --> 26:55.220
等于index

26:55.220 --> 26:56.220
是吧

26:56.220 --> 26:57.220
它的第二位

26:58.220 --> 26:59.220
就得是index

26:59.220 --> 27:01.220
它的第二位就得是index

27:02.220 --> 27:03.220
这样的话

27:03.220 --> 27:05.220
我们把这两个值都放到这个Object

27:05.220 --> 27:06.220
是吧

27:06.220 --> 27:07.220
都放到obj里

27:07.220 --> 27:08.220
return

27:09.220 --> 27:10.220
这个obj是啥

27:11.220 --> 27:13.220
obj就是它的局部辨量

27:13.220 --> 27:14.220
你发现了吗

27:14.220 --> 27:15.220
这个p

27:16.220 --> 27:17.220
和这个index

27:18.220 --> 27:20.220
是这个li的局部辨量

27:21.220 --> 27:22.220
别的li跟它的不一样

27:23.220 --> 27:24.220
是吧

27:24.220 --> 27:25.220
它也不是全局的

27:25.220 --> 27:26.220
这些值也不是全局的

27:26.220 --> 27:27.220
是吧

27:27.220 --> 27:28.220
每一个li里面都有自己的

27:28.220 --> 27:29.220
这是它的局部辨量

27:30.220 --> 27:31.220
我们把这个局部辨量

27:31.220 --> 27:32.220
最后付给这个dnv

27:34.220 --> 27:35.220
把这个局部辨量

27:36.220 --> 27:37.220
付给它这个env

27:38.220 --> 27:40.220
然后我们把这个env给设置进去

27:40.220 --> 27:41.220
给设置进去

27:42.220 --> 27:43.220
设置到哪里去

27:45.220 --> 27:46.220
time到吗点

27:47.220 --> 27:48.220
set a tribute

27:51.600 --> 27:52.600
set a tribute

27:54.600 --> 27:55.600
env

27:56.600 --> 27:59.910
json的strf

28:04.460 --> 28:06.460
我把这个env的这个值

28:06.460 --> 28:08.460
设置到这个dnv里面去

28:08.460 --> 28:09.460
设置到这个dnv里面去

28:10.460 --> 28:11.460
然后我让

28:13.970 --> 28:14.970
parent

28:15.970 --> 28:16.970
dnv

28:16.970 --> 28:17.970
我让付离

28:17.970 --> 28:19.970
把这个节点给加进去

28:23.050 --> 28:24.050
parent child

28:25.050 --> 28:28.380
time到

28:29.380 --> 28:30.380
我们把这个

28:33.400 --> 28:34.400
获取局部辨量

28:35.400 --> 28:38.610
然后

28:41.240 --> 28:43.240
将辨量

28:45.940 --> 28:46.940
设置到

28:47.940 --> 28:48.940
dnv

28:49.940 --> 28:50.940
然后将这个

28:50.940 --> 28:51.940
用这个付给

28:51.940 --> 28:52.940
把这个新方件的

28:52.940 --> 28:53.940
dnv给添加进去

28:53.940 --> 28:54.940
付给把这个新建设

28:54.940 --> 28:55.940
dnv添加进去

28:56.940 --> 28:57.940
然后这是一个新的dnv

28:57.940 --> 28:58.940
是吧

28:58.940 --> 28:59.940
我们light一个

28:59.940 --> 29:00.940
result site

29:02.940 --> 29:03.940
我们把这个新的

29:03.940 --> 29:04.940
这个dnv添进去

29:04.940 --> 29:05.940
result site

29:06.940 --> 29:07.940
点push

29:08.940 --> 29:09.940
time到

29:10.940 --> 29:12.940
然后一个复运还下来

29:12.940 --> 29:13.940
我这个复集的这个节点

29:13.940 --> 29:14.940
就会有一群

29:14.940 --> 29:15.940
这个

29:15.940 --> 29:16.940
东西了是吧

29:17.940 --> 29:18.940
我return

29:19.940 --> 29:20.940
result site

29:22.940 --> 29:23.940
然后

29:23.940 --> 29:24.940
上面

29:24.940 --> 29:25.940
我们也用这个来接下来

29:25.940 --> 29:26.940
light一个

29:27.940 --> 29:28.940
result site

29:29.940 --> 29:31.940
但是实际上

29:31.940 --> 29:32.940
没有太所谓了

29:32.940 --> 29:33.940
是吧

29:33.940 --> 29:34.940
因为我们这些节点

29:34.940 --> 29:36.940
都已经放上去了

29:36.940 --> 29:37.940
我们这些节点都已经放上去了

29:37.940 --> 29:38.940
这个时候

29:38.940 --> 29:39.940
我们来说你这个

29:39.940 --> 29:40.940
下门没有违动的呢

29:40.940 --> 29:41.940
对吧

29:41.940 --> 29:42.940
我们下门这块

29:42.940 --> 29:43.940
是不是现在还没有违动的呢

29:43.940 --> 29:44.940
对吧

29:44.940 --> 29:45.940
你别着急

29:45.940 --> 29:46.940
我们还没有开始生成

29:46.940 --> 29:47.940
违动

29:48.940 --> 29:50.940
这块还没有开始生成违动

29:50.940 --> 29:51.940
解析到这的时候

29:51.940 --> 29:52.940
你想想

29:52.940 --> 29:54.940
这个解析是从哪解析

29:54.940 --> 29:56.940
是自上至下解析的是吧

29:56.940 --> 29:58.940
刚解析到这

29:58.940 --> 29:59.940
是吧

29:59.940 --> 30:00.940
还没解析到这

30:00.940 --> 30:01.940
是吧

30:01.940 --> 30:02.940
我们刚刚解析到这

30:02.940 --> 30:03.940
只不过解析到这的时候

30:03.940 --> 30:04.940
夸夸夸给它生成了

30:04.940 --> 30:06.940
三个节点而已

30:06.940 --> 30:07.940
还没有解析到下一层呢

30:07.940 --> 30:09.940
所以我们不用担心

30:09.940 --> 30:10.940
我们只负责

30:10.940 --> 30:11.940
把这个虚拟节点

30:11.940 --> 30:13.940
给它返回右边

30:13.940 --> 30:14.940
我们把这个虚拟节点

30:14.940 --> 30:15.940
返回右边

30:15.940 --> 30:18.250
也就是说

30:18.250 --> 30:19.250
在我们这里的时候

30:19.250 --> 30:20.250
这个虚拟节点

30:20.250 --> 30:21.250
我要给它

30:21.250 --> 30:22.250
return到

30:24.250 --> 30:25.250
一直return到这

30:26.250 --> 30:31.350
用vnode来解析

30:32.350 --> 30:33.350
我看这个vnode

30:33.350 --> 30:34.350
它是不是我

30:34.350 --> 30:36.350
接收到了虚拟节点

30:37.350 --> 30:38.350
我如果这个是个

30:38.350 --> 30:39.350
虚拟节点

30:39.350 --> 30:40.350
我这个ri

30:40.350 --> 30:41.350
如果是

30:41.350 --> 30:42.350
被背后修饰的话

30:42.350 --> 30:43.350
我要把它变成个

30:43.350 --> 30:44.350
虚拟节点对吧

30:44.350 --> 30:45.350
我给它返回来

30:45.350 --> 30:46.350
如果

30:46.350 --> 30:47.350
它是虚拟节点

30:47.350 --> 30:48.350
就代表

30:48.350 --> 30:49.350
我这个节点

30:49.350 --> 30:50.350
已经在里面

30:50.350 --> 30:51.350
创建完了

30:51.350 --> 30:52.350
是吧

30:52.350 --> 30:53.350
如果不是虚拟节点的话

30:53.350 --> 30:54.350
它在干的下面

30:54.350 --> 30:59.670
这个方式

31:00.670 --> 31:01.670
所以说

31:01.670 --> 31:02.670
这个虚拟节点的话

31:02.670 --> 31:04.670
在这个Annelise

31:04.670 --> 31:05.670
Tribute这里面

31:05.670 --> 31:06.670
就已经给它付上值

31:07.670 --> 31:08.670
如果没付值的话

31:08.670 --> 31:09.670
代表的是

31:09.670 --> 31:10.670
它不是虚拟节点

31:10.670 --> 31:12.670
往下面还继续走

31:12.670 --> 31:14.670
如果上面都已经付上值了

31:14.670 --> 31:15.670
那我下面就

31:15.670 --> 31:16.670
这一块就不用再给它

31:16.670 --> 31:17.670
创建新的节点了

31:17.670 --> 31:18.670
因为我这块直接

31:18.670 --> 31:19.670
把这个虚拟节点

31:19.670 --> 31:20.670
返回回来

31:20.670 --> 31:21.670
对吧

31:21.670 --> 31:22.670
还记着吧

31:22.670 --> 31:23.670
在vfo里面

31:23.670 --> 31:24.670
我们创建了虚拟节点

31:24.670 --> 31:25.670
我们在这创建了

31:25.670 --> 31:26.670
虚拟节点

31:26.670 --> 31:27.670
然后给它返回来回去

31:27.670 --> 31:31.690
是一个这样的结果

31:31.690 --> 31:32.690
然后

31:32.690 --> 31:33.690
然后

31:34.690 --> 31:35.690
然后

31:35.690 --> 31:37.690
我要给这块来设置一个

31:38.690 --> 31:39.690
值

31:42.700 --> 31:44.700
Element的NodeType

31:45.700 --> 31:46.700
等于1

31:46.700 --> 31:47.700
什么意思

31:47.700 --> 31:48.700
它是标签是吧

31:49.700 --> 31:50.700
并且

31:50.700 --> 31:51.700
Element

31:52.700 --> 31:53.700
Gate

31:53.700 --> 31:54.700
Tribute

31:55.700 --> 31:56.700
ENV

31:57.700 --> 31:58.700
什么

31:58.700 --> 31:59.700
啥意思

31:59.700 --> 32:00.700
你这个标签

32:00.700 --> 32:01.700
不但是标签

32:01.700 --> 32:02.700
而且你这个标签

32:02.700 --> 32:03.700
还有ENV

32:03.700 --> 32:04.700
属性

32:04.700 --> 32:05.700
那怎么办

32:08.210 --> 32:09.210
我要让

32:09.210 --> 32:10.210
Vnode点

32:10.210 --> 32:11.210
ENV

32:20.260 --> 32:21.260
我要让它属性合并

32:21.260 --> 32:22.260
我还没有写

32:23.260 --> 32:24.260
Vnode的ENV

32:24.260 --> 32:26.260
可能本身就有一个环境

32:26.260 --> 32:28.260
它本身可能就有一些参数

32:28.260 --> 32:29.260
然后

32:29.260 --> 32:30.260
加上我们

32:30.260 --> 32:31.260
如果标签上

32:31.260 --> 32:32.260
它有新的参数

32:32.260 --> 32:33.260
对吧

32:33.260 --> 32:34.260
标签上

32:34.260 --> 32:35.260
它有新的参数

32:35.260 --> 32:36.260
就比如说

32:36.260 --> 32:37.260
我们

32:37.260 --> 32:38.260
vfo嘛

32:38.260 --> 32:39.260
对吧

32:39.260 --> 32:40.260
vfo里面

32:40.260 --> 32:41.260
我再来一个vfo

32:41.260 --> 32:44.020
来个啥呢

32:44.020 --> 32:45.020
来个P标签

32:45.020 --> 32:46.020
是吧

32:46.020 --> 32:47.020
Vgfo

32:50.020 --> 32:51.020
来一个

32:52.020 --> 32:53.020
什么呢

32:53.020 --> 32:54.020
Type

32:56.460 --> 32:57.460
IN

32:58.460 --> 32:59.460
key的粒子

33:01.460 --> 33:02.460
假如说key里面有粒子

33:02.460 --> 33:03.460
是吧

33:03.460 --> 33:05.460
那你说我这个P标签里面

33:05.460 --> 33:06.460
P标签里面

33:06.460 --> 33:07.460
是不是既能访问到

33:07.460 --> 33:09.460
我这个里面的东西

33:09.460 --> 33:10.460
也能访问到

33:10.460 --> 33:11.460
上面是里面的东西

33:11.460 --> 33:12.460
所以它应该有一个

33:12.460 --> 33:14.460
属性的合并

33:14.460 --> 33:16.460
它就得有一个属性的合并

33:16.460 --> 33:17.460
它就有个属性的合并

33:17.460 --> 33:18.460
所以呢

33:18.460 --> 33:20.460
我们用一个Murge Tribute

33:20.460 --> 33:21.460
就是这个Vnode

33:21.460 --> 33:23.460
它本身的

33:23.460 --> 33:24.460
严为

33:25.460 --> 33:27.460
在Murge上

33:28.460 --> 33:29.460
我们

33:29.460 --> 33:31.460
这个里面的严为

33:31.460 --> 33:34.780
刚才给它转换成字幕串了是吧

33:34.780 --> 33:36.780
我再给它转换成对象

33:36.780 --> 33:37.780
这个Murge Tribute

33:37.780 --> 33:38.780
我们没有

33:38.780 --> 33:39.780
是吧

33:39.780 --> 33:40.780
我们在这里来写一下

33:40.780 --> 33:41.780
expert

33:42.780 --> 33:43.780
Murge Tribute

33:44.780 --> 33:45.780
其实一个OBGA1

33:45.780 --> 33:46.780
一个OBGA2

33:47.780 --> 33:48.780
就是两个OBGA

33:49.780 --> 33:50.780
那这两个

33:50.780 --> 33:51.780
到底来怎么来Murge

33:51.780 --> 33:52.780
其实非常简单

33:54.780 --> 33:55.780
如果

33:56.780 --> 33:57.780
OBGA1

33:57.780 --> 33:58.780
等于空

33:58.780 --> 33:59.780
那就直接返回

33:59.780 --> 34:00.780
Return一个

34:01.780 --> 34:02.780
OBGA2吗

34:02.780 --> 34:03.780
不行啊

34:03.780 --> 34:04.780
可以克隆一个OBGA

34:04.780 --> 34:10.580
克隆这个方法我没有

34:10.580 --> 34:12.580
然后说这个克隆方法怎么写

34:12.580 --> 34:14.580
这个时候有很多同学就

34:15.580 --> 34:16.580
开始

34:16.580 --> 34:17.580
掌钱自己的能力是吧

34:18.580 --> 34:19.580
克隆

34:19.580 --> 34:20.580
说你这个来一个

34:20.580 --> 34:21.580
来一个OBGA

34:22.580 --> 34:23.580
怎么克隆呢

34:23.580 --> 34:25.580
说接森点

34:25.580 --> 34:26.580
Pars

34:28.580 --> 34:29.580
然后

34:31.580 --> 34:36.370
接森点Pars

34:38.370 --> 34:39.370
接森点Spunify

34:39.370 --> 34:40.370
OBGA

34:41.370 --> 34:42.370
说这种方式就可以

34:43.370 --> 34:44.370
但是这种方式

34:44.370 --> 34:46.370
其实是有局限的

34:46.370 --> 34:48.370
这种方式是有局限的

34:48.370 --> 34:49.370
什么样的形态有局限的

34:49.370 --> 34:50.370
跟大家说

34:51.370 --> 34:52.370
为什么会有局限

34:53.370 --> 34:55.370
这个无法合并代理对象

35:01.240 --> 35:02.240
无法合并代理对象

35:02.240 --> 35:04.240
就比如说我们这个GunLate

35:05.240 --> 35:08.870
这个VM的GunLate

35:10.870 --> 35:11.870
他又想跟别人合并的话

35:11.870 --> 35:12.870
你就合并不了

35:13.870 --> 35:14.870
就合并不了

35:14.870 --> 35:15.870
不信你回去试试

35:16.870 --> 35:17.870
咱待会有时间的话

35:17.870 --> 35:18.870
咱试一下

35:18.870 --> 35:19.870
看一下

35:20.870 --> 35:21.870
这边摸这一地点吗

35:21.870 --> 35:23.870
你要是用VM去合并的话

35:23.870 --> 35:24.870
你合并不了

35:25.870 --> 35:26.870
咱可以先这么写着

35:26.870 --> 35:27.870
你先试一下

35:27.870 --> 35:28.870
你先看一下

35:28.870 --> 35:29.870
用VM合并的话

35:29.870 --> 35:30.870
你一个都合并不进去

35:30.870 --> 35:32.870
那克隆怎么写

35:33.870 --> 35:34.870
克隆怎么写

35:34.870 --> 35:36.870
克隆其实还是

35:36.870 --> 35:40.870
有一些比较好的一些写法的

35:41.870 --> 35:42.870
给大家来写一个吧

35:47.620 --> 35:48.620
我们这个管子就要

35:48.620 --> 35:49.620
Easy克隆了

35:49.620 --> 35:59.350
方式

36:00.350 --> 36:03.430
克隆

36:03.430 --> 36:04.430
克隆我们要分

36:04.430 --> 36:05.430
克隆数组

36:05.430 --> 36:06.430
还是克隆对象

36:07.430 --> 36:08.430
如果

36:10.430 --> 36:11.430
如果

36:11.430 --> 36:12.430
OB接

36:12.430 --> 36:14.430
Instance of

36:14.430 --> 36:15.430
Array

36:16.430 --> 36:17.430
怎么办

36:17.430 --> 36:18.430
Else

36:19.430 --> 36:20.430
Beef

36:25.240 --> 36:26.240
Else有什么

36:26.240 --> 36:27.240
OB接

36:27.240 --> 36:29.240
Instance of

36:29.240 --> 36:31.240
Object怎么办

36:31.240 --> 36:32.240
Else呢

36:32.240 --> 36:33.240
它不是数字

36:33.240 --> 36:34.240
也不是对象

36:34.240 --> 36:35.240
就是一个普通的东西

36:35.240 --> 36:36.240
对吧

36:36.240 --> 36:37.240
那我就直接

36:38.240 --> 36:39.240
你传进来个E

36:39.240 --> 36:40.240
那我Return一个E

36:40.240 --> 36:41.240
这个E肯定不是你个E

36:41.240 --> 36:42.240
对吧

36:42.240 --> 36:43.240
如果

36:44.240 --> 36:45.240
我们先来写个简单的

36:45.240 --> 36:47.240
如果是OB接

36:47.240 --> 36:49.240
Object的喜欢怎么办

36:49.240 --> 36:50.240
我再来写

36:50.240 --> 36:51.240
Return

36:51.240 --> 36:52.240
克隆

36:53.240 --> 36:54.240
Object

36:54.240 --> 36:57.580
它吗

36:57.580 --> 36:58.580
Return

36:58.580 --> 36:59.580
克隆一个Object

37:02.580 --> 37:03.580
那我在下面来写一个

37:04.580 --> 37:05.580
方式

37:06.580 --> 37:07.580
克隆

37:07.580 --> 37:08.580
Object

37:09.580 --> 37:10.580
那我就

37:10.580 --> 37:11.580
你这里有Object的

37:11.580 --> 37:12.580
我也创建一个吧

37:12.580 --> 37:13.580
是吧

37:13.580 --> 37:15.580
Result等于一个空

37:15.580 --> 37:16.580
空间是吧

37:16.580 --> 37:17.580
light names

37:17.580 --> 37:18.580
看好了

37:18.580 --> 37:19.580
我刚才说

37:20.580 --> 37:21.580
你EZ

37:21.580 --> 37:22.580
克隆

37:22.580 --> 37:23.580
没有办法直接得到

37:23.580 --> 37:24.580
它的这个

37:24.580 --> 37:26.580
代理对象的所有的数据

37:26.580 --> 37:28.580
那我在这里面怎么得到

37:28.580 --> 37:29.580
在这里怎么得到

37:30.580 --> 37:31.580
用这个方式

37:31.580 --> 37:32.580
Object

37:32.580 --> 37:33.580
点

37:33.580 --> 37:34.580
get

37:34.580 --> 37:35.580
own

37:35.580 --> 37:36.580
property

37:36.580 --> 37:37.580
names

37:38.580 --> 37:39.580
Object

37:40.580 --> 37:41.580
这样的话

37:41.580 --> 37:42.580
即使你那些属性

37:42.580 --> 37:43.580
能是代理的属性

37:43.580 --> 37:45.580
它也能访问到

37:45.580 --> 37:46.580
这种方法

37:46.580 --> 37:48.580
无法合并代理对象

37:48.580 --> 37:49.580
对象是代理的

37:49.580 --> 37:51.580
然后你拿这个跟别人合并去

37:51.580 --> 37:52.580
你合并不了

37:53.580 --> 37:54.580
有的同学都不知道

37:54.580 --> 37:55.580
什么是合并对象

37:55.580 --> 37:57.580
我们可以简单的说一下

37:57.580 --> 37:58.580
比如说A冒号1

37:58.580 --> 37:59.580
B冒号2

38:00.580 --> 38:01.580
然后合一个

38:01.580 --> 38:04.580
AC冒号3

38:05.580 --> 38:07.580
D冒号4

38:07.580 --> 38:08.580
这样的话怎么合并

38:09.580 --> 38:11.580
合并为一个对象

38:11.580 --> 38:13.580
A冒号1

38:13.580 --> 38:14.580
B冒号2

38:14.580 --> 38:16.580
C冒号3

38:16.580 --> 38:18.580
D冒号4

38:19.580 --> 38:21.580
把多个对象的属性和值

38:21.580 --> 38:22.580
合并成一个对象

38:22.580 --> 38:24.580
就是多重的

38:24.580 --> 38:25.580
环境变量里的这个值

38:25.580 --> 38:26.580
合并在一起

38:26.580 --> 38:27.580
然后

38:27.580 --> 38:28.580
如果要是有重复的

38:28.580 --> 38:29.580
比如说B冒号3

38:29.580 --> 38:30.580
重复了

38:31.580 --> 38:33.580
那就是B冒号3

38:33.580 --> 38:35.580
后来的覆盖前面

38:35.580 --> 38:36.580
就是现在子的

38:36.580 --> 38:37.580
当前的这个的

38:38.580 --> 38:39.580
有一个属性B

38:39.580 --> 38:41.580
然后我再上一层有个属性B

38:41.580 --> 38:42.580
那我当前层的

38:42.580 --> 38:43.580
肯定覆盖外层

38:43.580 --> 38:44.580
内层覆盖外层

38:44.580 --> 38:46.580
是一个覆盖的关系

38:47.580 --> 38:48.580
用这种方法

38:48.580 --> 38:49.580
就能拿得到

38:49.580 --> 38:51.580
所有的代理对象的属性

38:51.580 --> 38:53.580
能拿到代理对象的属性

38:53.580 --> 38:55.580
然后再来一个风行环

38:57.580 --> 38:59.580
Light一个i等于0

39:00.580 --> 39:01.580
i

39:01.580 --> 39:02.580
小于

39:02.580 --> 39:04.580
Names的Lands

39:06.580 --> 39:08.580
我就便利所有的属性

39:08.580 --> 39:09.580
对吧

39:09.580 --> 39:10.580
Results

39:12.890 --> 39:13.890
Names

39:14.890 --> 39:15.890
是吧

39:15.890 --> 39:16.890
我这个Result对于

39:16.890 --> 39:18.890
大家这个值是吧

39:18.890 --> 39:19.890
等于啥呀

39:19.890 --> 39:20.890
地规

39:20.890 --> 39:21.890
可能

39:21.890 --> 39:22.890
OBG

39:24.890 --> 39:25.890
Names

39:26.890 --> 39:27.890
如果是个对象的话

39:27.890 --> 39:28.890
你可不可以给我

39:28.890 --> 39:29.890
克隆出来一个新的对象

39:29.890 --> 39:30.890
如果是属性的话

39:30.890 --> 39:32.890
你就直接把属性给我

39:32.890 --> 39:33.890
我就直接封上值

39:33.890 --> 39:34.890
对吧

39:34.890 --> 39:35.890
所以我这个最后一定

39:38.460 --> 39:39.460
这个我可以的

39:40.460 --> 39:41.460
这一块

39:41.460 --> 39:43.460
是相当于是一个地规

39:44.460 --> 39:46.460
它又地规到它的负累去

39:46.460 --> 39:48.460
如果是属性就直接返回

39:48.460 --> 39:50.460
就相当于没有这个函数

39:50.460 --> 39:51.460
我直接给它封上值了

39:51.460 --> 39:52.460
如果是对象

39:52.460 --> 39:53.460
那更得调这个

39:53.460 --> 39:54.460
是吧

39:54.460 --> 39:55.460
如果是对象的话

39:55.460 --> 39:56.460
就直接就调这个了之后

39:56.460 --> 39:57.460
又会调一个

39:57.460 --> 39:58.460
可能OBG

39:58.460 --> 40:00.460
就又进入新的一层克隆去

40:00.460 --> 40:01.460
如果是个数组

40:01.460 --> 40:02.460
调这个的话也没有问题

40:02.460 --> 40:03.460
是吧

40:03.460 --> 40:05.460
一会我们还得写克隆数据

40:05.460 --> 40:07.460
这就是一个克隆对象

40:07.460 --> 40:09.460
我们再来写个克隆数据

40:15.820 --> 40:17.820
克隆数据其实也超级简单

40:18.820 --> 40:20.820
Light一个Result

40:21.820 --> 40:23.820
等于New一个

40:23.820 --> 40:24.820
Rid

40:24.820 --> 40:26.820
OBG的Light

40:32.840 --> 40:33.840
OBG的Light

40:35.840 --> 40:37.840
说进这么长的数据

40:37.840 --> 40:38.840
然后还是

40:39.840 --> 40:40.840
Light i等于0

40:40.840 --> 40:42.840
i小于

40:42.840 --> 40:43.840
OBG有点Light

40:46.840 --> 40:48.840
便利原来数组的每一个

40:48.840 --> 40:49.840
然后我现在Result

40:50.840 --> 40:51.840
这是我新创建的

40:51.840 --> 40:52.840
等于啥

40:52.840 --> 40:53.840
克隆

40:53.840 --> 40:54.840
OBG

40:58.840 --> 40:59.840
数组力的每一个元素

40:59.840 --> 41:00.840
我也得给它克隆一份

41:00.840 --> 41:02.840
放到我对象的位置上

41:02.840 --> 41:04.840
如果你这个是个

41:04.840 --> 41:05.840
值

41:05.840 --> 41:06.840
数字或者字符算

41:06.840 --> 41:07.840
那就直接返回来

41:07.840 --> 41:09.840
如果你这个数组里面是对象

41:09.840 --> 41:10.840
那就去克隆去

41:10.840 --> 41:12.840
如果数组里面是数组

41:12.840 --> 41:13.840
那就继续克隆

41:17.430 --> 41:19.430
这块的逻辑很不好想

41:19.430 --> 41:21.430
这块的逻辑很不好想

41:21.430 --> 41:23.430
但是你们必须得会

41:23.430 --> 41:26.430
这三段克隆是经典的克隆算法

41:26.430 --> 41:28.430
这三段的克隆

41:28.430 --> 41:30.430
是一个很经典的克隆算法

41:30.430 --> 41:31.430
然后我们在这块

41:31.430 --> 41:33.430
如果它是Rid的话

41:34.430 --> 41:35.430
RidCent

41:36.430 --> 41:37.430
克隆

41:38.430 --> 41:39.430
Rid

41:40.430 --> 41:41.430
OBG

41:42.430 --> 41:43.430
你会发现一个是警察的

41:43.430 --> 41:45.430
这种邪法很省心

41:46.430 --> 41:47.430
是吧

41:47.430 --> 41:49.430
你只要是不出在这个范围里面

41:49.430 --> 41:51.430
我就非常的省心

41:51.430 --> 41:52.430
以至于

41:52.430 --> 41:54.430
我根本就没有想象到

41:54.430 --> 41:55.430
它有多少层有多少分支

41:55.430 --> 41:56.430
是吧

41:56.430 --> 41:58.430
只要你出不了我这三个的范围

41:58.430 --> 42:00.430
我就可以这么用

42:00.430 --> 42:01.430
我就可以这么用

42:03.430 --> 42:04.430
然后我们这个

42:04.430 --> 42:06.430
如果OBGA1

42:06.430 --> 42:07.430
反而会来这个末日

42:07.430 --> 42:09.430
这块OBGA1为功能的话

42:09.430 --> 42:10.430
那就克隆返回一个OBGA2

42:11.430 --> 42:13.430
一为功合并了之后

42:13.430 --> 42:14.430
那就OBGA2是啥

42:14.430 --> 42:15.430
就是啥

42:15.430 --> 42:16.430
if

42:19.580 --> 42:20.580
OBGA2

42:21.580 --> 42:22.580
等于功

42:22.580 --> 42:23.580
怎么办

42:24.580 --> 42:25.580
RidCent

42:25.580 --> 42:27.580
克隆一个

42:27.580 --> 42:29.950
OBGA1

42:30.950 --> 42:33.780
对吧

42:33.780 --> 42:34.780
然后如果了

42:34.780 --> 42:35.780
都不为功

42:35.780 --> 42:36.780
来着一个Rid造的

42:36.780 --> 42:38.780
创建一个新的一个对象

42:38.780 --> 42:39.780
然后呢

42:39.780 --> 42:40.780
我们对这个新的对象

42:40.780 --> 42:41.780
来进行一些操作

42:41.780 --> 42:43.780
来次OBGA1

42:43.780 --> 42:45.780
A TTRS

42:48.220 --> 42:49.220
拿出来

42:49.220 --> 42:51.220
它的全部的属性

42:51.220 --> 42:52.220
该从

42:56.810 --> 42:58.810
OBGA1

42:58.810 --> 43:02.950
OBGA2

43:02.950 --> 43:03.950
第二

43:03.950 --> 43:05.950
该从PROBORNAMES

43:05.950 --> 43:06.950
OBGA1

43:06.950 --> 43:10.740
然后呢

43:10.740 --> 43:11.740
再拿出来一个

43:11.740 --> 43:12.740
OBGA2的A TTRS

43:12.740 --> 43:13.740
是吧

43:13.740 --> 43:14.740
对

43:17.180 --> 43:18.180
然后呢

43:18.180 --> 43:19.180
先把这个1的属性

43:19.180 --> 43:21.180
往这个空的上面复制一遍

43:22.180 --> 43:24.180
再一个i等于0

43:24.180 --> 43:25.180
i小鱼

43:26.180 --> 43:27.180
i

43:27.180 --> 43:28.180
OBGA1

43:28.180 --> 43:30.180
A TTRS的烂色

43:30.180 --> 43:31.180
i加加

43:33.180 --> 43:34.180
然后呢

43:34.180 --> 43:35.180
往上面复制一遍

43:35.180 --> 43:36.180
Result

43:37.180 --> 43:38.180
OBGA1

43:38.180 --> 43:39.180
A TTRS

43:39.180 --> 43:40.180
i

43:41.180 --> 43:42.180
等于

43:42.180 --> 43:43.180
OBGA1

43:44.180 --> 43:45.180
的

43:46.180 --> 43:47.180
OBGA1

43:47.180 --> 43:48.180
A TTRS

43:49.180 --> 43:50.180
对吧

43:50.180 --> 43:51.180
然后

43:51.180 --> 43:52.180
复制

43:52.180 --> 43:53.180
再来放第二个

43:56.640 --> 43:57.640
来的一个i等于0

43:57.640 --> 43:58.640
i小鱼

43:58.640 --> 44:01.640
OBGA2的A TTRS的烂色

44:03.640 --> 44:04.640
i加加

44:04.640 --> 44:05.640
如果有相同的属性呢

44:05.640 --> 44:06.640
那就覆盖

44:06.640 --> 44:07.640
是吧

44:07.640 --> 44:08.640
后面的覆盖

44:08.640 --> 44:09.640
前面的天天地

44:09.640 --> 44:10.640
是吧

44:10.640 --> 44:11.640
OBGA2 TTRS

44:14.640 --> 44:15.640
等于

44:15.640 --> 44:16.640
OBGA2

44:16.640 --> 44:17.640
的

44:18.640 --> 44:19.640
OBGA2

44:19.640 --> 44:20.640
A TTRS

44:21.640 --> 44:29.650
这样呢

44:29.650 --> 44:30.650
我们就搞定了合并

44:30.650 --> 44:31.650
是吧

44:31.650 --> 44:32.650
然后return

44:33.650 --> 44:34.650
Result

44:35.650 --> 44:36.650
这样的话呢

44:36.650 --> 44:37.650
我们就能

44:37.650 --> 44:38.650
抹制的两个属性

44:38.650 --> 44:39.650
抹制的两个属性

44:39.650 --> 44:40.650
然后回过头来

44:41.650 --> 44:42.650
我希望通过这个

44:42.650 --> 44:43.650
抹制的方法

44:44.650 --> 44:45.650
抹制的方法

44:45.650 --> 44:46.650
是从哪儿引来的

44:46.650 --> 44:49.020
跑不下来的

44:50.020 --> 44:54.000
Import

44:59.620 --> 45:03.850
通过

45:03.850 --> 45:04.850
我希望通过

45:04.850 --> 45:05.850
抹制的这个方法

45:06.850 --> 45:07.850
来把这个属性

45:07.850 --> 45:08.850
给它合并进来

45:09.850 --> 45:10.850
合并进来

45:10.850 --> 45:11.850
vnode的ENV

45:12.850 --> 45:13.850
否则

45:14.850 --> 45:15.850
有心的就合并

45:15.850 --> 45:16.850
否则的话呢

45:16.850 --> 45:17.850
它就传承

45:17.850 --> 45:18.850
否则的话就传承

45:19.850 --> 45:20.850
vnode的ENV

45:21.850 --> 45:22.850
等于

45:22.850 --> 45:23.850
Mod

45:24.850 --> 45:26.850
vnode的ENV

45:27.850 --> 45:28.850
多少

45:30.850 --> 45:31.850
我看它有没有Pirate

45:32.850 --> 45:33.850
有Pirate的话

45:33.850 --> 45:34.850
合并Pirate的

45:35.850 --> 45:36.850
ENV

45:37.850 --> 45:38.850
就是继承了

45:38.850 --> 45:39.850
否则的话

45:39.850 --> 45:40.850
合并一个裤

45:42.850 --> 45:43.850
否则的话

45:43.850 --> 45:44.850
合并一个裤

45:44.850 --> 45:45.850
这样的话

45:45.850 --> 45:46.850
我们就能把

45:46.850 --> 45:47.850
vnode的这一块

45:47.850 --> 45:48.850
给合并上来

45:49.850 --> 45:50.850
我们来看一下

45:50.850 --> 45:51.850
现在这个结果

45:55.440 --> 45:56.440
有地方报错了

45:59.390 --> 46:00.390
DateSide就是报错了

46:00.390 --> 46:01.390
是吧

46:01.390 --> 46:02.390
我们来看一下

46:02.390 --> 46:03.390
这是哪一个文件

46:03.390 --> 46:04.390
这个是

46:04.390 --> 46:05.390
vfo是吧

46:08.660 --> 46:09.660
vfo是哪一块

46:09.660 --> 46:12.660
analyst is in struggle 是吧

46:13.660 --> 46:14.660
这会儿报错了是吧

46:14.660 --> 46:15.660
我们来看一下

46:15.660 --> 46:16.660
来打印一下

46:16.660 --> 46:17.660
console

46:19.660 --> 46:20.660
点log

46:21.660 --> 46:22.660
insight

46:23.660 --> 46:24.660
我们来看一下

46:24.660 --> 46:25.660
这个现在的值都是什么

46:28.620 --> 46:30.620
0,1,2 是吧

46:30.620 --> 46:32.620
这个t list都没有 是吧

46:32.620 --> 46:33.620
我乱写了刚才

46:34.620 --> 46:40.680
这块有一块是我乱写的

46:41.680 --> 46:46.040
是吧

46:46.040 --> 46:47.040
这个list

46:47.040 --> 46:48.040
你看

46:48.040 --> 46:49.040
就放上来

46:49.040 --> 46:51.040
这个list都放上来

46:51.040 --> 46:53.040
下面我什么都不能做

46:53.040 --> 46:54.040
为啥

46:54.040 --> 46:55.040
结点生成好了

46:55.040 --> 46:57.040
人家自己就能软的

46:57.040 --> 46:58.040
结点生成好了

46:58.040 --> 47:00.040
他自己就能软的

47:00.040 --> 47:01.040
所以说

47:01.040 --> 47:02.040
下面都不能做

47:02.040 --> 47:03.040
他就已经

47:03.040 --> 47:05.040
可以展示出来的

47:05.040 --> 47:06.040
为啥

47:06.040 --> 47:07.040
看好了

47:07.040 --> 47:08.040
我刚才

47:08.040 --> 47:09.040
这个生成的结点

47:09.040 --> 47:10.040
是虚拟结点

47:10.040 --> 47:11.040
这个是在哪

47:11.040 --> 47:12.040
构建

47:12.040 --> 47:13.040
啥

47:13.040 --> 47:14.040
构建虚拟道路

47:14.040 --> 47:15.040
是吧

47:15.040 --> 47:16.040
构建虚拟道路

47:16.040 --> 47:17.040
刚刚构建到这

47:17.040 --> 47:18.040
是吧

47:18.040 --> 47:19.040
我们本来都没有

47:19.040 --> 47:20.040
放到下面是吧

47:20.040 --> 47:21.040
我们就把下面的

47:21.040 --> 47:23.040
结点给它生成了

47:23.040 --> 47:24.040
我们就给它

47:24.040 --> 47:25.040
下面生成了

47:25.040 --> 47:26.040
所以这个时候

47:26.040 --> 47:27.040
构建到下面的时候

47:27.040 --> 47:29.040
它也能正常的构建

47:29.040 --> 47:30.040
然后在渲染的时候

47:30.040 --> 47:31.040
它也能正常的渲染

47:32.040 --> 47:33.040
因为它正常的构建

47:33.040 --> 47:34.040
它就能正常的渲染

47:34.040 --> 47:35.040
是吧

47:36.040 --> 47:37.040
所以我们这就

47:37.040 --> 47:38.040
搞定了一本

47:38.040 --> 47:39.040
这个v4的

47:39.040 --> 47:41.040
显示就能显示了

47:41.040 --> 47:42.040
但是现在

47:42.040 --> 47:43.040
还有点不行

47:43.040 --> 47:44.040
就是哪不行

47:44.040 --> 47:45.040
我这个v4的一些

47:45.040 --> 47:47.040
直修改了之后

47:47.040 --> 47:48.040
v4的一些直修改了之后

47:48.040 --> 47:50.040
它不会跟他改

47:50.040 --> 47:51.040
那我们下一节

47:51.040 --> 47:52.040
来讲

47:52.040 --> 47:54.040
v4的这些直修改了之后

47:54.040 --> 47:56.040
我们如何来进行修改

47:56.040 --> 47:57.040
如何让这得进行修改

47:57.040 --> 47:58.040
就像现在

47:58.040 --> 47:59.040
我这个

47:59.040 --> 48:00.040
太似的点

48:00.040 --> 48:01.040
啥来着

48:01.040 --> 48:02.040
例子的是吧

48:02.040 --> 48:03.040
点Push

48:03.040 --> 48:04.040
比如说

48:04.040 --> 48:05.040
我再推一个

48:06.040 --> 48:07.040
A

48:07.040 --> 48:09.040
直为道

48:10.040 --> 48:11.040
然后B

48:11.040 --> 48:12.040
你眼里面是21

48:17.550 --> 48:18.550
Prowlt

48:18.550 --> 48:20.550
A4 Node Defend

48:20.550 --> 48:23.760
是吧

48:23.760 --> 48:24.760
它这个直

48:24.760 --> 48:26.760
它这个直能射进去

48:26.760 --> 48:27.760
但是它修改不了

48:27.760 --> 48:28.760
这些地方的时候

48:28.760 --> 48:29.760
它还会爆粗

48:29.760 --> 48:30.760
所以说

48:30.760 --> 48:31.760
有一些的地方

48:31.760 --> 48:32.760
我们还不能弄

48:32.760 --> 48:33.760
有一些地方

48:33.760 --> 48:34.760
我们还不能弄

48:34.760 --> 48:35.760
你现在改了之后

48:35.760 --> 48:36.760
它也没有办法软点

48:36.760 --> 48:37.760
是吧

48:37.760 --> 48:38.760
在软的时候

48:38.760 --> 48:39.760
爆了个粗

48:39.760 --> 48:40.760
所以说

48:40.760 --> 48:41.760
一旦改了

48:41.760 --> 48:43.760
它主要是哪里的原因

48:43.760 --> 48:44.760
你一旦改了

48:44.760 --> 48:45.760
数组的话

48:45.760 --> 48:47.760
它节点得变

48:47.760 --> 48:48.760
是吧

48:48.760 --> 48:49.760
节点不变

48:49.760 --> 48:50.760
你就想直接去渲染

48:50.760 --> 48:51.760
你看

48:51.760 --> 48:53.760
我们这块Prowlt

48:53.760 --> 48:54.760
变了之后

48:54.760 --> 48:55.760
我就想直接去软点

48:55.760 --> 48:56.760
对的

48:56.760 --> 48:57.760
能软点得了吗

48:57.760 --> 48:58.760
它也软点不了

48:58.760 --> 48:59.760
是吧

48:59.760 --> 49:00.760
为啥

49:01.760 --> 49:03.760
你这个节点

49:03.760 --> 49:04.760
没有心

49:04.760 --> 49:05.760
你就想直接重新渲染

49:05.760 --> 49:06.760
重新渲染之后

49:06.760 --> 49:07.760
还是那两个节点

49:07.760 --> 49:08.760
是吧

49:08.760 --> 49:09.760
重新渲染之后

49:09.760 --> 49:10.760
也只剩那两个节点

49:10.760 --> 49:12.760
我这个Prowlt不是

49:12.760 --> 49:13.760
没有Prowlt

49:13.760 --> 49:17.220
好了

49:17.220 --> 49:18.220
这块下一节

49:18.220 --> 49:19.220
给我们来说

49:19.220 --> 49:20.220
所以说

49:20.220 --> 49:21.220
我们还没有讲

49:21.220 --> 49:22.220
怎么来更新节点

49:22.220 --> 49:23.220
我们还没有来说

49:23.220 --> 49:24.220
怎么更新节点

49:24.220 --> 49:25.220
所以这块

49:25.220 --> 49:26.220
现在是没有意义的

49:26.220 --> 49:27.220
这块是没有意义的

49:27.220 --> 49:28.220
好了

49:28.220 --> 49:29.220
我们这一集

49:29.220 --> 49:30.220
主要来说了

49:30.220 --> 49:31.220
vivo是如何让它

49:31.220 --> 49:33.220
显示在这个节面上的

49:33.220 --> 49:34.220
两个就来显示

49:34.220 --> 49:35.220
两个

49:35.220 --> 49:36.220
三个就来显示三个

49:36.220 --> 49:37.220
下一集

49:37.220 --> 49:38.220
我们来说

49:38.220 --> 49:39.220
对vivo这种

49:39.220 --> 49:40.220
例子的进行修改

49:40.220 --> 49:41.220
比如说铺式

49:41.220 --> 49:42.220
比如说泡沫

49:42.220 --> 49:43.220
这样的操作了之后

49:43.220 --> 49:45.220
我们如何来动态的

49:45.220 --> 49:46.220
来进行显示

49:46.220 --> 49:47.220
这个内容

49:47.220 --> 49:48.220
我们下一集来说

