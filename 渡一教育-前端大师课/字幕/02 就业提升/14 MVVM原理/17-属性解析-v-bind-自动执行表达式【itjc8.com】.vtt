WEBVTT

00:01.460 --> 00:03.460
哈喽 大家好

00:03.460 --> 00:06.460
这集我们来说这个code.js

00:06.460 --> 00:11.460
我们如何根据一个对象

00:11.460 --> 00:14.460
我给它生成出来 上面声明的这些东西

00:14.460 --> 00:16.460
来看一下

00:16.460 --> 00:18.460
这个函数名叫什么来着

00:18.460 --> 00:20.460
generated code 是吧

00:20.460 --> 00:22.460
export

00:22.460 --> 00:23.460
function

00:23.460 --> 00:25.460
generated code

00:25.460 --> 00:28.460
我们就来做一个这个方法

00:28.460 --> 00:30.460
我把这个attr传进来

00:30.460 --> 00:33.460
我把这个attr传进来

00:33.460 --> 00:36.460
然后我就能给它生成一个code代码

00:36.460 --> 00:39.460
最开始我这个code什么都没有

00:39.460 --> 00:42.460
然后我要便利它这个对象

00:42.460 --> 00:44.460
light a type

00:44.460 --> 00:49.150
in opg

00:49.150 --> 00:51.150
oattr

00:51.150 --> 00:54.910
然后呢

00:54.910 --> 00:56.910
我们要把这个code加进来 是吧

00:56.910 --> 00:57.910
声明

00:57.910 --> 00:59.910
怎么声明

00:59.910 --> 01:01.910
是不是light

01:01.910 --> 01:03.910
一个的名字 是吧

01:03.910 --> 01:07.120
type

01:07.120 --> 01:09.120
加上

01:09.120 --> 01:13.780
等于

01:13.780 --> 01:15.780
加上

01:15.780 --> 01:17.780
json.stream.fi

01:17.780 --> 01:20.780
obj.type 是吧

01:20.780 --> 01:28.500
attr type 是吧

01:28.500 --> 01:30.500
加上

01:30.500 --> 01:35.500
这就是一个声明 是吧

01:35.500 --> 01:36.500
light

01:36.500 --> 01:38.500
一个名字

01:38.500 --> 01:39.500
等于

01:39.500 --> 01:41.500
后面写的这张代码 是吧

01:41.500 --> 01:43.500
这是一个对象的阶层形式 是吧

01:43.500 --> 01:45.500
要不然我们写对象也是这样写 是吧

01:45.500 --> 01:47.500
这就是它的这个代码

01:47.500 --> 01:49.500
代码

01:49.500 --> 01:51.500
然后我们最后

01:51.500 --> 01:53.500
return code

01:53.500 --> 01:54.500
是吧

01:54.500 --> 01:56.500
声明这一块没有我们想象那么难 是吧

01:56.500 --> 01:57.500
声明这块

01:57.500 --> 01:58.500
比如说你这里面有啥

01:58.500 --> 02:00.500
我们这里面都声明啥的

02:00.500 --> 02:02.500
这里面是吧

02:02.500 --> 02:04.500
我们要的是一个这种结构 是吧

02:04.500 --> 02:08.460
它这块声明完了之后

02:08.460 --> 02:15.030
就会变成这样

02:15.030 --> 02:17.030
light content

02:17.030 --> 02:19.030
等于pander

02:19.030 --> 02:20.030
分号

02:20.030 --> 02:24.050
第二行

02:24.050 --> 02:27.050
light description

02:27.050 --> 02:29.050
等于这个

02:29.050 --> 02:30.050
分号

02:30.050 --> 02:31.050
第三行

02:31.050 --> 02:33.050
这种代对象的

02:33.050 --> 02:35.050
light obj

02:35.050 --> 02:37.050
等于

02:37.050 --> 02:40.810
这样

02:40.810 --> 02:50.300
后面就先杀了先不写了

02:50.300 --> 02:52.300
是吧

02:52.300 --> 02:54.300
我只要这个json.stream.fi

02:54.300 --> 02:56.300
你后面即使是个对象

02:56.300 --> 02:57.300
也没有关系

02:57.300 --> 02:59.300
它也会写的什么

02:59.300 --> 03:00.300
它也会写的什么

03:00.300 --> 03:03.300
这样的话我们就出现了声明的这种

03:03.300 --> 03:05.300
声明的代码

03:05.300 --> 03:06.300
我们这个generated code

03:06.300 --> 03:08.300
就是在这里面用

03:08.300 --> 03:13.470
把它引进来

03:13.470 --> 03:15.470
这个好像不在这里了 是吧

03:15.470 --> 03:17.470
import

03:17.470 --> 03:19.470
generated code

03:19.470 --> 03:21.470
from

03:21.470 --> 03:22.470
上级目录下的

03:22.470 --> 03:24.470
上级目录下的

03:24.470 --> 03:26.470
code.js

03:26.470 --> 03:30.230
把这个

03:30.230 --> 03:32.230
code弄出来的

03:32.230 --> 03:34.230
然后我们就开始怎么样

03:34.230 --> 03:36.230
准备拼组

03:36.230 --> 03:37.230
这个准备拼组这块

03:37.230 --> 03:38.230
也有点

03:38.230 --> 03:40.230
稍微复杂点地方

03:40.230 --> 03:42.230
咱们看一下

03:42.230 --> 03:44.230
我来一个light result

03:44.230 --> 03:47.670
说实话

03:47.670 --> 03:48.670
这是我们要返回的

03:48.670 --> 03:49.670
复讯完

03:49.670 --> 03:51.670
它有两个式子 是吧

03:51.670 --> 03:52.670
它有两个式子

03:52.670 --> 03:54.670
light i

03:54.670 --> 03:56.670
小鱼

03:56.670 --> 03:58.670
expression list

03:58.670 --> 04:00.670
lens

04:00.670 --> 04:01.670
它有两个式子

04:01.670 --> 04:02.670
但是你这两个式子

04:02.670 --> 04:03.670
都是基于这个环境的

04:03.670 --> 04:05.670
所以这个生成的是

04:05.670 --> 04:06.670
环境代码

04:06.670 --> 04:08.670
env code

04:09.670 --> 04:11.670
这是个环境的代码

04:11.670 --> 04:12.670
并不是执行

04:12.670 --> 04:14.670
判断对册的代码

04:14.670 --> 04:15.670
然后这样

04:15.670 --> 04:19.180
咱们light一个set

04:19.180 --> 04:20.180
v

04:20.180 --> 04:22.180
expression list i

04:23.180 --> 04:24.180
点

04:24.180 --> 04:26.180
index of冒号

04:26.180 --> 04:29.870
为啥要有这个冒号

04:29.870 --> 04:31.870
是不是你这个里面

04:31.870 --> 04:32.870
判断的时候

04:32.870 --> 04:34.870
是不是因为判断

04:34.870 --> 04:35.870
判断的时候

04:35.870 --> 04:36.870
你是用冒号隔开的

04:36.870 --> 04:37.870
是吧

04:37.870 --> 04:38.870
我现在分析的

04:38.870 --> 04:39.870
我每一个表达式

04:39.870 --> 04:40.870
是一段这个是吧

04:40.870 --> 04:41.870
最开始我是用

04:41.870 --> 04:42.870
多少号隔开的

04:42.870 --> 04:43.870
变成了

04:43.870 --> 04:44.870
第一个表达式

04:44.870 --> 04:45.870
和这样的

04:45.870 --> 04:46.870
第二个表达式

04:46.870 --> 04:47.870
是吧

04:47.870 --> 04:48.870
这个里面有个冒号是吧

04:48.870 --> 04:49.870
冒号左门是属性

04:49.870 --> 04:50.870
冒号右门是

04:50.870 --> 04:51.870
里面的表达式是吧

04:51.870 --> 04:54.870
所以我们要用冒号再拆分一下

04:54.870 --> 04:57.870
咱先找一下冒号的位置

04:57.870 --> 04:59.870
咱先找一下冒号的位置

04:59.870 --> 05:00.870
然后呢

05:00.870 --> 05:01.870
if

05:01.870 --> 05:05.760
set

05:05.760 --> 05:06.760
大于负义

05:06.760 --> 05:07.760
代表啥

05:07.760 --> 05:09.760
有冒号

05:09.760 --> 05:11.760
else

05:11.760 --> 05:13.760
代表的是没有冒号是吧

05:13.760 --> 05:14.760
那没有冒号就相当于

05:14.760 --> 05:15.760
直接是属性是吧

05:15.760 --> 05:16.760
如果我这块

05:16.760 --> 05:17.760
如果我这块

05:17.760 --> 05:19.760
我写的直接就是这个

05:19.760 --> 05:20.760
是吧

05:20.760 --> 05:21.760
就是有画号

05:21.760 --> 05:22.760
虽然有画号

05:22.760 --> 05:23.760
冒号

05:23.760 --> 05:24.760
那这个right

05:24.760 --> 05:25.760
我相当于什么

05:25.760 --> 05:26.760
直接引动的这个是吧

05:26.760 --> 05:28.760
现在直接引动的这个是吧

05:28.760 --> 05:33.760
就直接往上拼就行

05:33.760 --> 05:34.760
所以这样的话

05:34.760 --> 05:35.760
就result加等于

05:35.760 --> 05:38.760
这是没有冒号的情况下

05:38.760 --> 05:39.760
express

05:39.760 --> 05:40.760
list

05:40.760 --> 05:42.760
i

05:42.760 --> 05:43.760
加

05:43.760 --> 05:44.760
冒号

05:44.760 --> 05:46.760
因为它这里面

05:46.760 --> 05:48.760
可能是多个的

05:48.760 --> 05:49.760
是吧

05:49.760 --> 05:50.760
所以我们要用冒号隔开

05:50.760 --> 05:51.760
我们用冒号隔开

05:51.760 --> 05:52.760
有个属性来之后

05:52.760 --> 05:53.760
我们把这个冒号给夹着

05:53.760 --> 05:54.760
有了这个冒号

05:54.760 --> 05:55.760
有了属性之后

05:55.760 --> 05:56.760
我们要把冒号夹着

05:56.760 --> 05:57.760
代表同时

05:57.760 --> 05:58.760
你最后不多个冒号吗

05:58.760 --> 05:59.760
没有关系

05:59.760 --> 06:00.760
我最后再把最后一个

06:00.760 --> 06:01.760
冒号给的去掉

06:01.760 --> 06:04.760
result的lense是大于0

06:04.760 --> 06:08.760
那我们就result

06:08.760 --> 06:11.760
等于result的substream

06:11.760 --> 06:14.760
0到result的lense

06:14.760 --> 06:15.760
简移

06:15.760 --> 06:17.760
把最后这个冒号给的去掉

06:17.760 --> 06:19.760
再return去掉

06:19.760 --> 06:26.850
把这个冒号给的去掉

06:26.850 --> 06:28.850
然后我们再看另一种情况

06:28.850 --> 06:30.850
刚才说的是没有冒号的

06:30.850 --> 06:33.850
然后看有冒号的

06:33.850 --> 06:35.850
这就不好弄了是吧

06:35.850 --> 06:37.850
有冒号的时候是个表达式

06:37.850 --> 06:39.850
然后这个表达式

06:39.850 --> 06:41.850
我们先拿出来一部分

06:41.850 --> 06:43.850
light一个code

06:43.850 --> 06:47.440
咱们什么呢

06:47.440 --> 06:48.440
express

06:48.440 --> 06:49.440
list

06:49.440 --> 06:50.440
i

06:50.440 --> 06:51.440
点

06:51.440 --> 06:53.440
substream

06:53.440 --> 06:55.440
点substream

06:55.440 --> 06:58.440
side加1

06:58.440 --> 07:00.440
side是冒号的位置是吧

07:00.440 --> 07:02.440
加1是冒号下一个部分的位置

07:02.440 --> 07:04.440
冒号的下一个部分就是

07:04.440 --> 07:05.440
这个的开始了是吧

07:05.440 --> 07:07.440
这个表达式的开始了是吧

07:07.440 --> 07:09.440
side加1

07:09.440 --> 07:10.440
code

07:10.440 --> 07:17.820
expression

07:17.820 --> 07:21.820
expression list

07:21.820 --> 07:22.820
i

07:22.820 --> 07:25.820
点lense

07:25.820 --> 07:27.820
把这个冒号的后半段给的

07:27.820 --> 07:28.820
结举下来

07:28.820 --> 07:30.820
把冒号的后半段给的结举下来

07:30.820 --> 07:32.820
这个是我们的code

07:32.820 --> 07:36.650
结举下来之后是这一段

07:36.650 --> 07:37.650
是吧

07:37.650 --> 07:38.650
是这一段

07:38.650 --> 07:40.650
我们就拿到了code

07:40.650 --> 07:41.650
拿到了code之后

07:41.650 --> 07:44.650
我希望怎么样

07:44.650 --> 07:47.650
结合

07:47.650 --> 07:49.650
上面的环境

07:49.650 --> 07:51.650
声明代码

07:51.650 --> 07:53.650
然后来

07:53.650 --> 07:55.650
验证

07:55.650 --> 07:57.650
这个结果

07:57.650 --> 07:59.650
表达式

07:59.650 --> 08:01.650
是否成立

08:01.650 --> 08:02.650
是吧

08:02.650 --> 08:03.650
所以我这个时候

08:03.650 --> 08:05.650
我希望code里面

08:05.650 --> 08:07.650
我有个

08:07.650 --> 08:09.650
expression

08:09.650 --> 08:10.650
方式

08:10.650 --> 08:13.650
判断了A字触

08:13.650 --> 08:15.650
我希望有个这么一个神奇的方法

08:15.650 --> 08:17.650
可以让我判断是否A字触

08:17.650 --> 08:19.650
然后表达式

08:19.650 --> 08:21.650
expression

08:21.650 --> 08:23.650
然后传进了一个环境

08:23.650 --> 08:26.650
环境的代码

08:26.650 --> 08:27.650
怎么判断

08:27.650 --> 08:28.650
我们先假定

08:28.650 --> 08:30.650
默认的时候都是force

08:30.650 --> 08:32.650
好了 假定

08:32.650 --> 08:33.650
这是刚才这种情况

08:33.650 --> 08:34.650
先假定默认的时候是force

08:34.650 --> 08:36.650
不许是force

08:36.650 --> 08:38.650
然后light一个code

08:38.650 --> 08:40.650
最开始用env出使化

08:40.650 --> 08:42.650
非常用env

08:42.650 --> 08:44.650
是不是最开始得先声明

08:44.650 --> 08:45.650
要不然你这里面

08:45.650 --> 08:46.650
用的所有的变量

08:46.650 --> 08:47.650
我这里都没有

08:47.650 --> 08:48.650
是吧

08:48.650 --> 08:50.650
然后code

08:50.650 --> 08:52.650
这块加等于

08:52.650 --> 08:53.650
什么

08:53.650 --> 08:55.650
声明上面都有了是吧

08:56.650 --> 08:58.650
efo左框号

08:58.650 --> 09:00.650
加上expression

09:00.650 --> 09:02.650
加上

09:02.650 --> 09:04.650
扩回

09:04.650 --> 09:06.650
画框号

09:06.650 --> 09:08.650
布尔

09:08.650 --> 09:09.650
等于

09:09.650 --> 09:11.650
处

09:11.650 --> 09:13.650
是吧

09:13.650 --> 09:14.650
你把这个拼起来是吧

09:14.650 --> 09:16.650
efo这个表达式

09:16.650 --> 09:17.650
成立的话

09:17.650 --> 09:18.650
我就把布尔给它扶成处

09:18.650 --> 09:19.650
看到了吗

09:19.650 --> 09:21.650
变成了一段这样的

09:21.650 --> 09:23.650
然后我让它执行

09:23.650 --> 09:24.650
efo

09:24.650 --> 09:27.090
code

09:27.090 --> 09:28.090
return

09:28.090 --> 09:30.090
布尔执行

09:30.090 --> 09:32.090
我们这块如果成立了的话

09:32.090 --> 09:33.090
这个布尔就被改成处了

09:33.090 --> 09:34.090
如果不成立的话

09:34.090 --> 09:35.090
还是它的force

09:35.090 --> 09:37.090
我就return布尔执行

09:37.090 --> 09:38.090
我写了个这么个方法

09:38.090 --> 09:39.090
是不是挺好玩啊

09:39.090 --> 09:40.090
这玩意

09:40.090 --> 09:41.090
如果我们

09:41.090 --> 09:43.090
不自己来写编译的这些功能

09:43.090 --> 09:45.090
如果我们不自己写来

09:45.090 --> 09:48.090
不自己来写这个编译的功能

09:48.090 --> 09:49.090
我们最好的技用的方式

09:49.090 --> 09:51.090
就是把它拼成代表

09:51.090 --> 09:53.090
然后用efo

09:53.090 --> 09:54.090
同学们

09:54.090 --> 09:56.090
如果你没有学过编译原理的话

09:56.090 --> 09:57.090
我建议你们

09:57.090 --> 09:58.090
不用去学

09:58.090 --> 09:59.090
千万不要去学

09:59.090 --> 10:02.090
不要在这个上面浪费大量的时间

10:02.090 --> 10:03.090
等你以后

10:03.090 --> 10:04.090
这些东西都很熟悉了之后

10:04.090 --> 10:06.090
有足够的充足的时间的话

10:06.090 --> 10:07.090
你再想学

10:07.090 --> 10:08.090
再去学学

10:08.090 --> 10:09.090
否则的话

10:09.090 --> 10:10.090
你会把大量的时间

10:10.090 --> 10:11.090
都弄在这个上面

10:11.090 --> 10:12.090
编译不是

10:12.090 --> 10:13.090
你们一天两天

10:13.090 --> 10:14.090
就能学得了的

10:14.090 --> 10:16.090
在学校里要学一个学期

10:16.090 --> 10:17.090
而且还

10:17.090 --> 10:19.090
没有什么特别大的成效

10:19.090 --> 10:20.090
就像我毕业设计

10:20.090 --> 10:22.090
我就写了一套编译的一个

10:22.090 --> 10:24.090
我的编译是编译的射口

10:24.090 --> 10:26.090
我写了一套编译器

10:26.090 --> 10:27.090
非常的复杂

10:27.090 --> 10:28.090
非常的复杂

10:28.090 --> 10:29.090
所以咱们课堂里

10:29.090 --> 10:31.090
也没有办法讲编译

10:31.090 --> 10:32.090
它毕竟和前端

10:32.090 --> 10:33.090
这个知识也不太挂够

10:33.090 --> 10:34.090
它这个编译

10:34.090 --> 10:37.090
是个单本的一个学课方向

10:37.090 --> 10:38.090
所以你不用去

10:38.090 --> 10:40.090
想编译上是怎么写的

10:40.090 --> 10:42.090
我们就用evo这种方式

10:42.090 --> 10:44.090
来用一个比较快速的方法

10:44.090 --> 10:45.090
来替代

10:45.090 --> 10:46.090
就好

10:47.090 --> 10:49.090
然后我们来说这个efo

10:49.090 --> 10:51.090
然后就是efo

10:51.090 --> 10:53.090
就判断了是吧

10:53.090 --> 10:54.090
a自出

10:54.090 --> 10:56.090
我们先传进去表达式

10:56.090 --> 10:57.090
x的prison

11:02.460 --> 11:04.460
我们表达式是code是吧

11:04.460 --> 11:07.460
然后环境辨量是en vcode是吧

11:08.460 --> 11:10.460
然后如果成立呢

11:11.460 --> 11:12.460
如果成立呢

11:13.460 --> 11:14.460
成立就

11:14.460 --> 11:16.460
把它左门这个属性给它填进去是吧

11:16.460 --> 11:18.460
把它左门属性给填进去是吧

11:18.460 --> 11:20.460
result加等于

11:20.460 --> 11:21.460
它左门这个还进什么

11:22.460 --> 11:24.460
成立的话就把这个right给它附在这是吧

11:24.460 --> 11:26.460
这个式子只要成立

11:26.460 --> 11:28.460
那我就把这个属性给它填上去是吧

11:28.460 --> 11:29.460
如果成立的话

11:29.460 --> 11:32.460
那就是xprisonist

11:32.460 --> 11:34.460
i.sublist

11:35.460 --> 11:37.460
0到side

11:37.460 --> 11:43.590
原来最后加个动画

11:44.590 --> 11:46.590
因为我们最后把这个动画删掉

11:47.590 --> 11:48.590
这个就是一个

11:49.590 --> 11:51.590
让它执行这一块的内容

11:51.590 --> 11:53.590
让它来执行这一块的内容

11:53.590 --> 11:54.590
判断

11:54.590 --> 11:56.590
这个东西需不需要设置上去

11:56.590 --> 11:58.590
需要需不需要设置上去

11:59.590 --> 12:00.590
我们来执行一块看看

12:04.700 --> 12:05.700
可能solo有点low

12:05.700 --> 12:06.700
result

12:07.700 --> 12:08.700
是吧

12:08.700 --> 12:09.700
我们来执行一下

12:10.700 --> 12:14.670
是吧

12:14.670 --> 12:15.670
这边打进了一个right

12:15.670 --> 12:16.670
跟我们返回了一个right

12:18.670 --> 12:19.670
那这边就是

12:19.670 --> 12:21.670
这边肯定是a字出了是吧

12:21.670 --> 12:22.670
肯定是a字出了

12:23.670 --> 12:25.670
那我们来改一下这个里面的值

12:27.670 --> 12:28.670
让它

12:29.670 --> 12:31.670
我让它补录成立

12:32.670 --> 12:33.670
让它补录成立

12:33.670 --> 12:35.670
它也是一个复杂的式子是吧

12:35.670 --> 12:36.670
也是个复杂的式子

12:37.670 --> 12:38.670
是吧

12:38.670 --> 12:39.670
它就变成了

12:39.670 --> 12:41.670
我们可以用这样的方式

12:41.670 --> 12:43.670
来把这个东西给它完成

12:43.670 --> 12:44.670
我们可以用这样的方式

12:44.670 --> 12:46.670
来把属性重新进行渲染

12:46.670 --> 12:48.670
重新进行渲染

12:49.670 --> 12:50.670
这就是vgb的这一块

12:50.670 --> 12:51.670
vgb的这一块

12:51.670 --> 12:52.670
大概就是这么一个

12:52.670 --> 12:53.670
实现的逻辑

12:53.670 --> 12:54.670
咱们肯定没有人家

12:54.670 --> 12:56.670
真正的原码写的那么细

12:57.670 --> 12:59.670
但是我们把这个功能基本上实现

12:59.670 --> 13:00.670
把这个功能基本上实现

13:01.670 --> 13:02.670
那就是vgb的了

13:02.670 --> 13:03.670
那我们下一集

13:03.670 --> 13:04.670
我们来说vgb

13:04.670 --> 13:05.670
好吧

13:05.670 --> 13:06.670
我们下一集来说

