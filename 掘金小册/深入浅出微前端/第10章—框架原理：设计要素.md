在之前的课程中讲解了几种常用微前端方案的设计示例，在示例中讲解了如何将微应用通过不同的技术进行聚合，从而帮助大家理解各自方案的特性。当然，这些示例并不是完整的微前端解决方案，完整的解决方案不仅需要考虑如何进行微应用的聚合，还需要考虑微应用在运行时能否根据业务需求进行实时通信、能否互不干扰、能否做到良好的用户体验等。在微前端方案概述中简单提到了一些通用 JavaScript 库设计的微前端框架（例如 qiankun、wujie），因此本文主要讲解设计一个完善的微前端框架需要考虑哪些设计要素。当然，在此之前还会讲解一些浏览器运行原理，旨在帮助大家了解微前端框架设计的原理依据。

> 温馨提示：本课程讲解的设计要素由作者自行理解并归纳总结得出，并不是社区的标准。在学习的过程中，大家也可以尝试按照自己的理解将一个复杂的技术进行分解，有助于降低技术的学习复杂度。


## MPA 导航

如果项目是在 MPA 的模式下，则前端应用天然可以做到小型应用的拆分，微应用只需要考虑如何根据导航进行跳转，此时不存在多个微应用同时并存的情况，因此不需要考虑互相之间的隔离。浏览器自身会处理微应用的加载和卸载，例如大家在面试中经常会被问到在浏览器地址栏中输入 URL 地址，浏览器的整个工作过程（这里不讲解页面渲染和 JS 解析的过程）：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd9d66b39fb74b229eaece51205ef668~tplv-k3u1fbpfcp-zoom-1.image)

> 温馨提示：上述图例是在多进程架构的情况下。在运行资源相对紧张的情况下，例如低端的安卓手机中，网络服务也可以是 Browser 进程中的一个处理线程。

从标签页的地址栏输入 URL 开始，整个页面的导航过程都是由浏览器的 Browser 进程进行协调管控，除此之外，如果在 Renderer 进程中发起新的导航（例如用户点击链接标签进行跳转或者使用 JavaScript 执行 `window.location = "https://new.site.com"`），Renderer 进程会通过 IPC 告知 Browser 进程重复上述处理步骤，如果新导航处理的是不同站点的页面信息，则 Browserer 进程会启动新的 Renderer 进程进行页面渲染。不管是新开标签页还是提交导航，页面被加载后都会有生命周期的概念，如下所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/440aa671d6fd473590ac1d1fd508327e~tplv-k3u1fbpfcp-zoom-1.image)

从浏览器导航的整个过程和生命周期可以发现，不管是新开标签页、切换标签页、关闭标签页、在应用中进行新的导航、后退/前进导航以及页面长时间处于非激活的状态，浏览器的内部运行机制都可以很好的管理应用的生命周期，并且会自动处理应用的加载、卸载以及缓存等和导航息息相关的工作。除此之外，在安全隔离方面，浏览器内部还会通过站点隔离（Renderer 进程隔离）、跨源隔离、浏览上下文（组）隔离以及 V8 Isolate 隔离来处理应用之间的独立运行，保证运行的互不干扰，不仅可以做到应用之间的 JS 全局执行上下文、DOM 节点和 CSS 渲染隔离，还可以防止被恶意网站进行攻击。

> 温馨提示：关于 V8 Isolate 的概念，可以在下一个课程的 V8 隔离中进行了解。


## SPA 设计

如果在 SPA 模式下加载多个独立的微应用，这些微应用本身将处于同一个 Renderer 进程内，并且还会处于同一个浏览上下文和 V8 Isolate 中，因此微应用之间无法做到浏览器级别的导航、安全隔离、性能优化以及缓存处理，并且在 SPA 模式下多个微应用还可以共存，切换标签页会通过浏览器进行隔离处理，而切换 SPA 的路由则仍然可以使得多个微应用并存。总结来说，在 SPA 模式下微应用之间的切换并不是靠 Browser 进程进行处理，而是靠 Renderer 进程中的 JavaScript 逻辑进行处理，此时浏览器内部的运行机制无法起到细粒度的管控作用，需要额外处理以下一些问题：

-   状态：根据自定义逻辑来管控微应用的状态，包括（预）加载、加载、卸载、（预）渲染等
-   隔离：在同一个浏览上下文中进行 DOM 和 JS 隔离
-   性能：例如支持微应用的预加载、预渲染和缓存，微应用之间的资源共享
-   通信：如果几个微应用同时并存，如何实现微应用之间的通信

为了使微前端尽可能的模拟浏览器自身的运行机制，需要设计一个通用的 JavaScript 框架，这个框架可以协助主应用快速接入并管理不同的微应用，如下所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76dd21cb74644f30ae5519d1f28ed8d0~tplv-k3u1fbpfcp-zoom-1.image)

在 SPA 模式下主应用主要包含导航和内容设计，通过导航来切换路由，并可以通过微前端框架来控制内容区提供的 DOM 容器实现各个微应用的加载和卸载。微前端框架可以像浏览器处理标签页变化（甚至是地址栏的 URL 变化）那样来处理主应用导航的路由变化，从而控制微应用的加载、卸载和缓存处理。在微应用运行的过程中，微前端框架还需要额外处理微应用之间的互相隔离、微应用的性能优化以及通信等，而微应用本身则需要根据微前端框架提供的状态变更来处理自身的加载和卸载等。

> 温馨提示：JavaScript 通用库的设计粒度是框架开发者需要考虑的重要问题，例如是否需要使用 Monorepo 的设计结构，将上述的几个设计要素进行分包设计，从而方便开发者单独使用这些能力。除此之外，可以在库的基础上进行再次封装，提供一整套的 React / Vue 技术栈的解决方案，包括主应用和微应用的开发模板、微应用渲染的封装组件等，这些在后续的工程化课程和解决方案课程中会详细讲解。


## 状态

qiankun 内部的应用状态变更主要依赖 single-spa，single-spa 框架类似于浏览器应用的生命周期管理。由于应用状态管理本身属于 JavaScript 逻辑层面的设计内容，因此会在后续的微前端框架设计课程中进行详细讲解，在框架原理课程中不进行过多介绍。

## 隔离

在隔离技术中，本课程会先通过 V8 的 Isolate 和 Context 隔离示例带领大家了解浏览器中 JavaScript 的隔离本质。在 V8 隔离的基础上，会重点讲解以下几种隔离方案：

-   **iframe 隔离：** 空白页（`src="about:blank"`） iframe 隔离和服务端同源的 iframe 隔离方案设计。不仅可以利用不同的浏览上下文实现彻底的微应用隔离，与普通 iframe 方案而言，还可以解决白屏体验问题，是微前端框架实现隔离的重要手段；
-   **iframe + Proxy 隔离：** 解决空白页 iframe 隔离无法调用 `history` API 的问题，并可用于解决 iframe 方案中无法处理的 URL 状态同步问题；
-   **快照隔离：** 浏览器无法兼容 Proxy 时，可以通过简单的快照实现 `window` 变量的隔离，但是这种隔离方案限制较多，例如无法实现主子应用的隔离，无法实现多个微应用并存的隔离。当然大多数场景是一个时刻运行一个微应用，因此是一种兼容性良好的隔离方案；
-   **CSS 隔离：** 如果主应用和微应用同处于一个 DOM 上下文，那么需要考虑 CSS 样式的隔离处理。课程中会重点讲解 Shadow DOM 实现 CSS 隔离的示例以及产生的弊端。

在后续的微前端框架设计课程中，JS 隔离会使用 iframe + Proxy 以及快照隔离（降级方案）方案进行设计，CSS 隔离则不做过多设计，采用 iframe 的天然隔离能力。

> 温馨提示：如果要考虑 iframe 中的 Modal 模态框相对于主应用进行居中处理，通用的微前端框架会考虑将微应用的 DOM 渲染放在主应用的 DOM 环境中，从而避免在 iframe 中渲染 DOM 产生的隔离问题。但是这种设计需要额外考虑很多设计因素，例如 CSS 样式隔离、DOM 卸载时的 Event 事件处理等。如果在 iframe 中渲染 DOM 则可以享受浏览器底层带来的一系列应用周期管理能力。如果不需要考虑实现非常通用的微前端框架，那么可以定制 Modal 组件，从而根据业务使其在 iframe 中相对于主应用进行居中处理。

## 性能

浏览器和服务器为了提升应用的加载性能，不断的开放了更多相关的功能，包括 Resource Hints（DNS Prefetch、Preconnect、Prefetch、Prerender）、Preload、Early Hints 等。除此之外，在应用缓存方面还可以做到多级缓存设计，包括 Memory Cache、Service Worker & Cache、Disk Cache、HTTP 缓存、 HTTP2 / Push 缓存、CDN 缓存和代理缓存等。除了上述一些功能，还可以从微应用本身出发进行性能优化，包括资源共享、预加载和预渲染等。本课程接下来会讲解部分技术。

## 通信

主子应用之间可以通过观察者模式或者发布订阅模式实现通信，如果是跨域的 iframe 则可以通过 `window.postMessage` 实现通信，如果是同域的 SPA 应用，则可以通过浏览器原生的 `EventTarget` 或者自定义通信对象。本课程接下来会讲解通信方式的实现示例。


## 小结

本小节主要参考浏览器内部的运行机制来讲解 SPA 模式下的微前端框架设计要素，包括状态、隔离、性能以及通信等几个部分，微前端框架本质上是一个通用的 JavaScript 库设计，在接下来的课程中重点讲解这些设计要素的原理。