序言
--

JavaScript 引擎是有着一定复杂度的软件，如果说为了研究引擎的实现，开始就想着从无到有实现一个引擎，几乎是不可能的。

对引擎制作过程中涉及的知识点逐一展开学习，无疑是正确的。但如果在此之前毫无准备，很可能会迷失在知识网络中，事倍功半。

如果有个方式，可以使用较少的时间，先获得「原来引擎内部大致如此」的感觉，再进行系统性地学习，就可以事半功倍 - 分析一个实现简单清晰，功能相对完备的引擎的源码，就是这样的方式。

QuickJS 是由著名程序员 [Fabrice Bellard](https://en.wikipedia.org/wiki/Fabrice_Bellard "https://en.wikipedia.org/wiki/Fabrice_Bellard") 编写的 JavaScript 引擎，对于想学习引擎内部实现的我们而言，它具有下面这些特点：

*   使用语法相对简单的 C 语言编写（相较 C++ 等其他语言）
    
*   主体部分仅 5.4 万行 C 代码，与 v8 相比少之又少
    
*   支持到 ES2020 的语法
    
*   Hello World 程序仅占用约 210KB 内存（Node.js 约 20M）
    

这些特点，可以树立我们学习引擎实现的信心，方便我们将注意力更多地放在引擎的核心功能上，花费较少的时间了解到引擎内部执行的全貌。

本课程会结合 QuickJS 引擎的源码，循序渐进地向大家展示 JavaScript 引擎的核心工作原理。希望大家学习完本课程后，有如苏轼的《观潮》所言「到得还来别无事，庐山烟雨浙江潮」

约定
--

大家的知识背景往往不同，为了避免在行文时陷入漫无目的的展开，本课程在叙述时会假定读者已经具有下面的编程经验：

*   可以熟练地使用 JavaScript 编写程序，并接触过 TypeScript
    
*   使用 C 语言至少编写并成功运行过 Hello World 程序
    
*   使用过任意的 Linux 发行版、macOS、WSL
    

另外，本课程在行文上还包含了下面一些约定：

*   在对一些技术进行介绍时，会尽量列出它们的英文关键字，方便读者后续利用 Google 继续学习
    
*   在需要对一些技术点进行解释时，会列出包含了相对专业的解释的外链地址。当然，为了保持行文的紧凑和连贯性，也可能会节选一些外链中的内容
    
*   关注大小写是一个非常好的编程习惯，但除非特殊说明，quickjs 和 QuickJS 都表示 QuickJS 引擎
    
*   「引擎」若没有特别说明，都指的是 quickjs 引擎
    

章节说明
----

本课程会按下图所示的脉络，向大家循序渐进地介绍 QuickJS 的内部实现：

![outline.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb1b7cb452b44379b2292ec47034bc58~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=1796&h=2225&s=280683&e=jpg&b=f2f2f2)

在准备工作中，我们将配置开发和调试引擎所需的环境，回顾编译 C 语言涉及的基本知识，对引擎编译过程中使用的一些工具和参数作出解释。目的是让大家可以先把引擎跑起来，玩儿起来。

接着我们开始介绍指令的执行方式。或许有同学会疑问「为何先介绍指令的执行，而不是先介绍指令的生成？」

因为引擎的核心功能为了完成用户编写的计算任务。能够接受使用 JS 源码编写的计算任务，只是为了方便开发者而提供的编程接口、提高人机交互性而已，直接编写字节码理论上也是可以的。

当然，有效的人机交互也是必要的，真就直接编写字节码的话，其效率可想而知。所以在介绍完指令的执行之后，我们会继续介绍指令的生成方式。

在介绍指令执行与指令生成之前，我们会一起使用 TypeScript 分别实现一个原型虚拟机和一个原型解析器，以便大家先了解这两个关键组件的核心原理，再对照学习 QuickJS 的源码实现。

「好之者不如乐之者」为了辅助源码的学习，我们最后会进入两个实践章节，一起为引擎增加 2 个新的实用功能，体验一把开发引擎的乐趣：

*   GC Dump，将引擎在运行阶段受 GC 管理的对象导出，并在 Chrome DevTools 中查看导出结果
    
*   Instr Debugger，为引擎加上断点调试的功能，具有类似 v8 inspector 的效果
    

言而总之，学习 JS 引擎是有趣的，选择 QuickJS 着手是有效的。事不宜迟，让我们即刻出发。