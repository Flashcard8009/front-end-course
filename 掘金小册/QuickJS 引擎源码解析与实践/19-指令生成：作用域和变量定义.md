本节将介绍作用域在引擎层面的实现，以及引擎如何确定变量所属的作用域并进行变量的定义。

作用域
---

作用域表示变量的活动范围，JS 中有下面几种作用域，按其中定的变量的活动范围由大到小分别为：

*   全局作用域，其中变量的活动范围为整个应用程序的生命周期，即 [globalThis](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis")
    
*   模块作用域，如果是以 ESM 执行的模块，那么会有一个模块作用域，其中变量的活动范围和模块对象的生命周期相同（一般来说也是整个应用程序的声明周期）
    
*   函数作用域，使用 `var` 定义的变量具有函数作用域，活动范围是函数体内
    
*   块级作用域，使用 `let` 或 `const` 定义的变量具有块级作用域，活动范围被限制在块级语句内
    

### 全局作用域

全局作用域中的变量并非静态的，通常会由引擎运行的宿主往其中注入一些变量，类似函数 [js\_std\_add\_helpers](https://github.com/hsiaosiyuan0/quickjs/blob/4b8cc2711bc5023eee90ae46e922a29ab33dbb39/libs/quickjs-libc.c#L3581 "https://github.com/hsiaosiyuan0/quickjs/blob/4b8cc2711bc5023eee90ae46e922a29ab33dbb39/libs/quickjs-libc.c#L3581") 中的操作：

    void js_std_add_helpers(JSContext *ctx, int argc, char **argv) {
      // ...
      global_obj = JS_GetGlobalObject(ctx);
    
      console = JS_NewObject(ctx);
      JS_SetPropertyStr(ctx, console, "log",
                        JS_NewCFunction(ctx, js_print, "log", 1));
      // ...
    }
    

上面的代码演示了在全局作用域下注入 `console.log` 实现，其中的 `global_obj` 即 [JSContext::global\_obj](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/def.h#L296 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/def.h#L296")。

正因为全局变量这样的动态性，使其无法在静态解析阶段对其中的变量的存在性进行校验。但应用程序访问了未定义的全局变量又是一个引擎必须汇报的异常。

于是校验的动作被延迟到程序的运行阶段，成为运行时异常 - 当变量逐级向上查找到全局作用域仍未发现时，则会抛出异常 `ReferenceError`：

    function f() {
      a;
    }
    
    f(); // ReferenceError: 'a' is not defined
    

在解析过程中会逐级向上看作用域中是否存在变量，如果均未发现变量，则生成指令 [OP\_get\_var](https://github.com/hsiaosiyuan0/quickjs/blob/fc0383e2dbef784040da1f0e49ae2711984d3fea/src/vm/exec.c#L732 "https://github.com/hsiaosiyuan0/quickjs/blob/fc0383e2dbef784040da1f0e49ae2711984d3fea/src/vm/exec.c#L732")。指令对应的操作函数 [JS\_GetGlobalVar](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/vm/vm.c#L735 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/vm/vm.c#L735") 会查看全局对象 `globalThis` 上是否存在同名的 own property，不存在则会抛出异常。

### 模块作用域

从模块作用域开始，引擎就需要解析其中定义的变量。

前文提到模块作用域复用了函数作用域的实现，这点可以在函数 `__JS_EvalInternal` 中得到印证：

    JSValue __JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
                              const char *input, size_t input_len,
                              const char *filename, int flags, int scope_idx) {
      // ...
      fd = js_new_function_def(ctx, NULL, TRUE, FALSE, filename, 1);
      // ...
      push_scope(s); /* body scope */
      fd->body_scope = fd->scope_level;
      // ...
      err = js_parse_program(s);
      // ...
    }
    

可以看到首先创建了一个 `JSFunctionDef` 实例，然后将模块的代码当成其函数体进行解析。

### 函数作用域

函数相关的作用域需要分开来看：

*   函数间的作用域关系
    
*   函数内的作用域关系
    

考虑下面的代码：

    function outer() {
      // 1
      var a;
    
      function inner() {
        // 2
        var b;
    
        {
          // 3
          let c;
        }
      }
    }
    

*   作用域 1 和 2 表示函数间的作用域关系
    
*   作用域 2 和 3 表示函数内的作用域关系
    

函数间的作用域联系是通过 `JSFunctionDef::parent` 记录的，即每个函数定义会记录它的父级函数。

函数定义的实例 `JSFunctionDef` 通过调用函数 [js\_new\_function\_def](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L1137 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L1137")，该函数支持通过参数 `parent` 传递父级函数定义。

函数内的作用域信息在结构体 `JSFunctionDef` 中也有相应的字段记录：

    typedef struct JSFunctionDef {
      // ...
      int scope_level; /* index into fd->scopes if the current lexical scope */
      int scope_first; /* index into vd->vars of first lexically scoped variable */
      int scope_size;  /* allocated size of fd->scopes array */
      int scope_count; /* number of entries used in the fd->scopes array */
      JSVarScope *scopes;
      JSVarScope def_scope_array[4];
      int body_scope; /* scope of the body of the function or eval */
      // ...
    }
    

*   `def_scope_array` 预分配了 4 个 `JSVarScope` 实例
    
*   `scopes` 为函数内的作用域信息，最初为预分配的 `def_scope_array`
    
*   `scope_level` 表示 `scopes` 中的元素索引，起始值为 `0`，在解析内层作用域的时候该值会递增
    
*   为了减少内存分配的次数，`scopes` 的容量每次会多申请一些，通过 `scope_size` 表示其大小，实际使用的数量通过字段 `scope_count` 记录
    
*   `body_scope` 表示函数体的作用域
    

当我们需要确定一个变量是否已定义时：

*   通过可以通过字段 `scopes` 可以得到函数内的作用域关系
    
*   通过字段 `parent` 可以拿到其父级函数定义
    
*   继续通过父级函数定义中的字段 `scopes` 来访问父级函数内的作用域，以此类推逐级向上
    

函数内的作用域信息通过 `JSVarScope` 来表示：

    typedef struct JSVarScope {
      int parent; /* index into fd->scopes of the enclosing scope */
      int first;  /* index into fd->vars of the last variable in this scope */
    } JSVarScope;
    

`parent` 表示当前作用域的上一级作用域在当前函数定义的 `scopes` 中的索引

`js_new_function_def` 函数在创建 `JSFunctionDef` 实例时，就已将其初始的 `scope_count` 设置为了 1，表示将索引为 0 的 scope 留给通过 `var` 定义的变量、以及函数的形参。

在解析函数体之前，或者解析函数内的块语句之前，都会通过调用函数 [push\_scope](https://github.com/hsiaosiyuan0/quickjs/blob/3d4b0ef8273738db3d86031fa0c791a58f635784/src/parse/scope.c#L98 "https://github.com/hsiaosiyuan0/quickjs/blob/3d4b0ef8273738db3d86031fa0c791a58f635784/src/parse/scope.c#L98") 开启一个新的嵌套作用域：

    int push_scope(JSParseState *s) {
      if (s->cur_func) {
        JSFunctionDef *fd = s->cur_func;
        int scope = fd->scope_count;
        /* XXX: should check for scope overflow */
        if ((fd->scope_count + 1) > fd->scope_size) { // 1
          // ...
        }
        fd->scope_count++;                            // 2
        fd->scopes[scope].parent = fd->scope_level;   // 3
        fd->scopes[scope].first = fd->scope_first;    // 4
        emit_op(s, OP_enter_scope);                   // 6
        emit_u16(s, scope);
        return fd->scope_level = scope;               // 5
      }
      return 0;
    }
    

上面的代码对应的解释为：

*   首先确认 `scopes` 的容量是否足够，如果不够的话则先对其进行扩容
    
*   位置 `2` 处将 `scopes` 中使用到的元素数量加一
    
*   设置新作用域的 `parent` 字段为当前作用域在 `scopes` 中的索引，即位置 `3` 处
    
*   位置 `4` 处的操作似乎是关联的作用域中的变量信息
    
*   位置 `5` 处将当前作用域的索引设置为新创建的作用域
    
*   注意位置 `6` 处输出了指令 `OP_enter_scope`，现在只需了解在指令生成的第 1 阶段会输出该指令
    

形参的解析
-----

形参的解析按复杂度分 2 种情况：

*   简单形参的解析
    
        function f(a, b) {}
        
    
*   复杂形参的解析，即包含了默认值、[Spread](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax") 或者解构
    
        // 默认值
        function f(a, b = 1) {}
        
        // Spread
        function f(a, ...b) {}
        
        // 解构
        function f({ a, b }) {}
        
    

形参的解析工作通过函数 `js_parse_function_decl2` 中的 [while](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L385 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L385") 循环来完成，解析过程中会：

*   根据函数是否仅包含简单参数而设置 `JSFunctionDef::has_simple_parameter_list`，后续指令优化的时候会用到这个标记
    
*   根据函数形参列表中是否包含初始化表达式（是否有 `=`）而设置 `JSFunctionDef::has_parameter_expressions`
    
    通过 [调用](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L369 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L369") 函数 [js\_parse\_skip\_parens\_token](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/vardec.c#L8 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/vardec.c#L8") 会往前预读一部分内容，来判断形参列表中是否出现符号 `=`
    

如果仅包含简单形参，那么会使用函数 [add\_arg](https://github.com/hsiaosiyuan0/quickjs/blob/3d4b0ef8273738db3d86031fa0c791a58f635784/src/parse/scope.c#L241 "https://github.com/hsiaosiyuan0/quickjs/blob/3d4b0ef8273738db3d86031fa0c791a58f635784/src/parse/scope.c#L241") 将参数信息添加到 `JSFunctionDef::args` 数组中

如果非简单形参列表，则：

*   先 [调用](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L427 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L427") `define_var` 定义变量，var kind 为 [JS\_VAR\_DEF\_LET](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/parse.h#L511 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/parse.h#L511")
    
*   再 [调用](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L431 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L431") `add_arg` 添加形参信息
    
*   然后 [输出](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L441 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L441") 指令 `OP_scope_put_var_init`
    

### define\_var

我们先通过函数 `define_var` 看一下变量定义的方式：

    int define_var(JSParseState *s, JSFunctionDef *fd, JSAtom name,
                   JSVarDefEnum var_def_type) {
      // ...
    
      switch (var_def_type) {
      case JS_VAR_DEF_WITH:
        //...
      // 1
      case JS_VAR_DEF_LET:
      case JS_VAR_DEF_CONST:
      case JS_VAR_DEF_FUNCTION_DECL:
      case JS_VAR_DEF_NEW_FUNCTION_DECL:
        // 3
        idx = find_lexical_decl(ctx, fd, name, fd->scope_first, TRUE);
        if (idx >= 0) {
          // ...
            // 4
            redef_lex_error:
              /* redefining a scoped var in the same scope: error */
              return js_parse_error(s,
                                    "invalid redefinition of lexical identifier");
          // ...
        }
        // ...
        idx = add_scope_var(ctx, fd, name, var_kind);
        // ...
        break;
      // ...
      // 2
      case JS_VAR_DEF_VAR:
      }
    }
    

上面的代码包含的信息为：

*   首先通过 `switch` 根据不同的 `var_def_type` 选择不同的处理方式
    
*   其次可以看到位置 `1` 和位置 `2` 分别表示 `let|const` 定义的变量以及 `var` 定义的变量
    
*   使用 `let|const` 定义的变量在同一个作用域下变量名是不可以重复的，位置 `3` 和 `4` 配合则可以完成这样的校验
    

并且我们也可以看出 `define_var` 是一个高阶函数，内部组合了几个函数的功能，以达到诸如校验变量是否重复定义的功能。

### find\_lexical\_decl

在上面的代码中可以大致看出函数 [find\_lexical\_decl](https://github.com/hsiaosiyuan0/quickjs/blob/3d4b0ef8273738db3d86031fa0c791a58f635784/src/parse/scope.c#L81 "https://github.com/hsiaosiyuan0/quickjs/blob/3d4b0ef8273738db3d86031fa0c791a58f635784/src/parse/scope.c#L81") 的作用 - 找到同名的变量。

为了理解查找的过程，我们需要先了解 `JSVarDef` 结构：

    typedef struct JSVarDef {
      JSAtom var_name;
      /* index into fd->scopes of this variable lexical scope */
      int scope_level;
      /* during compilation:
          - if scope_level = 0: scope in which the variable is defined
          - if scope_level != 0: index into fd->vars of the next
            variable in the same or enclosing lexical scope
         in a bytecode function:
         index into fd->vars of the next
         variable in the same or enclosing lexical scope
      */
      int scope_next;
      // ...
    } JSVarDef;
    

`JSVarDef` 可以存放 `let|const` 和 `var` 定义的变量，为了节约内存复用了 `scope_level` 字段：

*   当存放的是 `var` 定义的变量时，`scope_level` 的值为 0，且 `scope_next` 表示 `var` 定义时的作用域在 `JSFunctionDef::scopes` 中的索引
    
*   当存放的是 `let|const` 定义的变量时，`scope_level` 的值为变量定义时的作用域，而 `scope_next` 则表示词法位置上一个通过 `let|const` 定义的变量、其定义在 `JSFunctionDef::vars` 中的索引
    
*   至于变量定义到底是 `var` 还是 `let|const` 则可以通过字段 `JSVarDef::is_lexical` 来区分
    

接着我们看一下 `JSVarScope` 结构：

    typedef struct JSVarScope {
      int parent; /* index into fd->scopes of the enclosing scope */
      int first;  /* index into fd->vars of the last variable in this scope */
    } JSVarScope;
    

*   `parent` 字段很明显表示父级作用域在 `JSFunctionDef::scopes` 中的索引
    
*   `first` 字段表示当前作用域中最后一个通过 `let|const` 定义的变量其定义在 `JSFunctionDef::vars` 中的索引
    

我们可以结合下图理解 `JSVarDef` 和 `JSVarScope` 的关系：

![var_scope.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1811cd08b3294317b628999fad620a6b~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=1400&h=638&s=93268&e=png&b=fffdfd)

*   左侧表示使用 `let|const` 定义的 `JSVarDef` 会通过 `scope_next` 字段跨作用域串联在一起
    
*   右侧表示作用域之间通过 `parent` 连接，且 `first` 字段指向的是作用域中最后一个使用 `let|const` 定义的 `JSVarDef`
    

现在我们可以理解函数 `find_lexical_decl` 中的内容：

    int find_lexical_decl(JSContext *ctx, JSFunctionDef *fd, JSAtom name,
                          int scope_idx, BOOL check_catch_var) {
      while (scope_idx >= 0) {
        JSVarDef *vd = &fd->vars[scope_idx];
        if (vd->var_name == name &&
            (vd->is_lexical || (vd->var_kind == JS_VAR_CATCH && check_catch_var)))
          return scope_idx;
        scope_idx = vd->scope_next;
      }
    
      if (fd->is_eval && fd->eval_type == JS_EVAL_TYPE_GLOBAL) {
        if (find_lexical_global_var(fd, name))
          return GLOBAL_VAR_OFFSET;
      }
      return -1;
    }
    

*   该函数的调用场景被限定在查找是否已存在名为 `name` 的通过 `let|const` 定义的变量，所以 `scope_idx` 其实是变量定义在 `JSFunctionDef::vars` 中的索引
    
*   也因为上面的原因，循环中的 `scope_next` 也表示变量定义在 `JSFunctionDef::vars` 中的索引
    
*   所以循环的作用是从 `scope_idx` 的变量开始，往上查找通过 `let|const` 定义的变量中是否存在名为 `name` 的变量
    

代码中 `GLOBAL_VAR_OFFSET` 是一个常量：

    #define GLOBAL_VAR_OFFSET 0x40000000
    

表示的是定义在全局的变量，这样的常量是如何选取的呢？这就要看下另一个常量：

    #define JS_MAX_LOCAL_VARS 65536
    

`JS_MAX_LOCAL_VARS` 表示局部变量的最大个数，其 16 进制表示为：`0x010000`，也就是需要 3 个字节来存放，而 `JSFunctionDef::vars` 的索引使用的是 4 字节长度：

    typedef struct JSFunctionDef {
      // ...
      JSVarDef *vars;
      // ...
    }
    

多出的一个字节则被引擎作为了标记位，当前只使用了最高位和次高位：

宏定义

16 进制

2 进制

`GLOBAL_VAR_OFFSET`

`0x40000000`

`1000000000000000000000000000000`

`ARGUMENT_VAR_OFFSET`

`0x20000000`

`0100000000000000000000000000000`

### add\_scope\_var 和 add\_var

`define_var` 函数中如果完成了所需的校验，则会调用 `add_scope_var` 或者 `add_var` 将变量定义追加到 `JSFunctionDef::vars` 中。

其实 `add_scope_var` 内部也会调用 `add_var`，两者的区别为：

*   `add_var` 只负责将变量定义追加到 `JSFunctionDef::vars` 中，当然追加之前会给定义的字段都赋上默认值，此时 `JSVarDef::scope_level` 的值为 0，刚好表示通过 `var` 定义的变量
    
*   `add_scope_var` 会在 `add_var` 返回的变量定义上将其字段进行调整，用于表示通过 `let|const` 定义的变量
    
    调整包括将 `JSVarDef::scope_level` 设置为变量实际定义的作用域，将 `JSVarDef::scope_next` 设置为前一个通过 `let|const` 定义的变量在 `JSFunctionDef::vars` 中的索引
    
        int add_scope_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name,
                          JSVarKindEnum var_kind) {
          int idx = add_var(ctx, fd, name);
          if (idx >= 0) {
            JSVarDef *vd = &fd->vars[idx];
            vd->var_kind = var_kind;
            vd->scope_level = fd->scope_level;
            vd->scope_next = fd->scope_first;
            fd->scopes[fd->scope_level].first = idx;
            fd->scope_first = idx;
          }
          return idx;
        }
        
    

### 默认值

默认值的解析在 `js_parse_function_decl2` 中的 [L449](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L449 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L449") 处：

    int label;
    
    fd->has_simple_parameter_list = FALSE;
    has_opt_arg = TRUE;
    
    if (next_token(s))
      goto fail;
    
    label = new_label(s);
    emit_op(s, OP_get_arg);
    emit_u16(s, idx);
    emit_op(s, OP_dup);
    emit_op(s, OP_undefined);         // 1
    emit_op(s, OP_strict_eq);         // 2
    emit_goto(s, OP_if_false, label); // 3
    emit_op(s, OP_drop);
    if (js_parse_assign_expr(s))      // 4
      goto fail;
    set_object_name(s, name);
    emit_op(s, OP_dup);
    emit_op(s, OP_put_arg);
    emit_u16(s, idx);
    emit_label(s, label);             // 5
    emit_op(s, OP_scope_put_var_init);
    emit_atom(s, name);
    emit_u16(s, fd->scope_level);
    

上面代码输出的是实现默认值功能的指令序列，作用类似下面的伪代码：

    // 将下面的代码
    function f(a = 1 + 1) {}
    
    // 转换成
    function f(a) {
      if (a === undefined) {
        a = 1 + 1;
      }
    }
    

转换后的代码需要：

1.  判断实参是否为 `undefined`，如果为真，则进行下一步，否则进度第 3 步
    
2.  执行初始化表达式，并将表达式的结果赋值给对应参数
    
3.  执行原本函数体中的内容
    

对照上面生成字节码序列中的内容：

*   位置 `1`、`2` 和 `3` 的作用是，将 `undefined` 压入操作数栈，通过指令 `OP_strict_eq` 对比实参是否和其相等，如果不等，则跳到 `label` 处继续执行
    
*   位置 `4` 则是解析初始化表达式，生成对应的字节码序列
    
*   位置 `4` 和位置 `5` 之间则是将初始化表达式的值赋给对应的参数
    
*   位置 `5` 往下则是函数体原本需要执行的内容
    

这里比较有趣的实现是对 label 的处理，label 表示目标位置的字节码相对函数体字节码序列的首地址的偏移量：

![label.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/606622ad43de453993a03e19ecb9e5ff~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=296&h=602&s=31897&e=png&b=fbfbfb)

结合上图，当我们解析并生成了 label 时，并不能知道目标指令位置的偏移量，换句话说因为初始化表达式还未被解析，我们并不能知道它的指令序列长度（在 `label_5` 处时，它与 `opcode_5` 之间的指令序列还未生成）。

为了解决上面的问题，引擎引入了 label，它是存放在 `JSFunctionDef::label_slots` 数组中的元素，作用类似一个占位符。上面代码中的 `label` 则是 `JSFunctionDef::label_slots` 数组中的元素的索引，所以：

*   对于位置 3 来说，得到的是 `label` 在 `JSFunctionDef::label_slots` 数组中的元素的索引
    
*   到了位置 5 处，则根据 `label` 的表示的索引找到 `JSFunctionDef::label_slots` 数组中对应的元素，更新其字段 `LabelSlot::pos` 为相应的偏移量
    

### 解构

解构的主要解析工作依靠函数 [js\_parse\_destructuring\_element](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/vardec.c#L193 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/vardec.c#L193") 来完成：

    int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                                       int hasval, int has_ellipsis,
                                       BOOL allow_initializer) {
      // ...
      label_parse = new_label(s);
      label_assign = new_label(s);
    
      start_addr = s->cur_func->byte_code.size;
      if (hasval) {
        /* consume value from the stack */
        emit_op(s, OP_dup);
        emit_op(s, OP_undefined);
        emit_op(s, OP_strict_eq);
        emit_goto(s, OP_if_true, label_parse);
        emit_label(s, label_assign);
      } else {
        emit_goto(s, OP_goto, label_parse);
        emit_label(s, label_assign);
        /* leave value on the stack */
        emit_op(s, OP_dup);
      }
      // ...
      if (s->token.val == '{') {
        // ...
      } else if (s->token.val == '[') {
        // ...
      }
      // ...
      if (s->token.val == '=' && allow_initializer) {
        label_done = emit_goto(s, OP_goto, -1);
        if (next_token(s))
          return -1;
        emit_label(s, label_parse);
        if (hasval)
          emit_op(s, OP_drop);
        if (js_parse_assign_expr(s))
          return -1;
        emit_goto(s, OP_goto, label_assign);
        emit_label(s, label_done);
        has_initializer = TRUE;
      }
      // ...
    }
    

上面的代码中有两个 label，并且会根据 `hasval` 参数生成不同的字节码，为了里面这段逻辑，我们可以先观察下面的代码：

    // 1
    ({ a } = b);
    // 2
    ({ d: { a } = b } = c);
    

注意上面的出现在不同位置的 `{ a } = b` 其中的 `=` 后的 `b` 表示的语义是不同的：

*   `1` 中的 `=` 表示赋值表达式中的右值
    
*   `2` 中的 `=` 则表示解构中的默认值
    

虽然它们的语义不同，但是由于共用的类似的语法，引擎就选择在函数 `js_parse_destructuring_element` 中一并完成了对两者的解析，通过参数 `hasval` 来区分两者：

*   当 `hasval` 为真时表示解构中的默认值
    
*   反之，当 `hasval` 为假时表示赋值表达式中的右值
    

我们继续看为什么需要两个 label，表达式可以按 `=` 一分为二，左边表示赋值，右边则表示求值，按语义来说，我们应该先完成右侧的求值，再进行左侧的赋值，但由于解析的过程是由左往右依次解析，所以引擎采用了 label 进行跳转：

![destruct.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26016e57882d401e8a3b66400f4a60ff~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=1010&h=626&s=43460&e=png&b=fefefe)

现在再看上面的指令序列生成逻辑应该会变得清晰起来：

*   如果 `hasval` 为真，则需要判断栈顶元素是否为 undefined，如果是，则需要跳转到 `label_parse` 处执行计算默认值的指令序列
    
*   如果 `hasval` 为假，则直接跳转到 `label_parse` 处执行计算右值的指令序列，当然在计算完右值后，还会有对应的指令 [跳转回](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/vardec.c#L600 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/vardec.c#L600") `label_assign` 完成赋值：
    
        if (js_parse_assign_expr(s))
          return -1;
        emit_goto(s, OP_goto, label_assign);
        
    

跳转回 `label_assign` 完成赋值后，指令会接着往下进行，为了避免重复进入到右侧的求值指令序列，通过 `label_done` 进行跳转：

![destruct_done.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27b490ed7aee45ceaa7d38791643218e~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=1160&h=626&s=58735&e=png&b=fefefe)

### Rest property

Rest property 可以将解构模式中剩余的属性都存放到其中，下面是取值 [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#rest_property "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#rest_property") 中的例子：

    const { a, ...others } = { a: 1, b: 2, c: 3 };
    console.log(others); // { b: 2, c: 3 }
    

如果让我们来设计引擎的实现，可以使用类似下面的伪代码：

    // 1
    const _obj = { a: 1, b: 2, c: 3 };
    const a = _obj["a"];
    
    // 2
    const _ex = ["a"];
    const others = {};
    for (const key of Object.keys(_obj)) {
      if (!_ex.includes(key)) others[k] = _obj[k];
    }
    

上面代码中第 1 部分很好理解，我们把属性的结构处理成属性的赋值即可。

第 2 部分则需要分步来看：

1.  首先是通过 `_ex` 保存了需要剔除的属性名
    
2.  先给 `others` 创建一个空对象
    
3.  遍历 `_obj` 的 own properties，将不在 `_ex` 中的属性拷贝到 `others` 中
    

上面这的处理方式最重要的其实是 `_ex` 的信息收集，只需在静态阶段分析出需要剔除的属性即可。但实际上，由于 JS 预发的动态性，引擎无法在静态阶段完成需剔除的属性的收集，考虑下面的代码：

    const key = "z";
    const { [key]: foo } = { z: "bar" };
    
    console.log(foo); // "bar"
    

可见由于属性的名称可以源自一个表达式的结果这一语法特性，导致静态阶段的属性收集难以完成。为了解决这个问题，引擎在上面的伪代码的基础上进行了一些调整：

    const _ex = {}; // 1
    const _obj = { a: 1, b: 2, c: 3 };
    const a = _obj["a"];
    _ex["a"] = null; // 2
    
    const others = {};
    for (const key of Object.keys(_obj)) {
      if (!_ex.hasOwnProperty(key)) others[k] = _obj[k]; // 3
    }
    

上面的变更包括：

1.  如果使用了 rest property 的话，则会创建一个对象 `_ex` 用于保存需要剔除的属性
    
2.  同样，如果使用的 rest property，那么会在每条属性解构的下方生成一段设置 `_ex` 属性的指令
    
3.  到了循环内部，使用 `_ex` 的属性作为过滤条件即可
    

理解了上面的伪代码后，再看引擎的源码其中一些初看晦涩的内容就显得比较好理解：

    int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                                       int hasval, int has_ellipsis,
                                       BOOL allow_initializer) {
      // ...
      if (s->token.val == '{') {
        if (next_token(s))
          return -1;
        // ...
        /* throw an exception if the value cannot be converted to an object */
        emit_op(s, OP_to_object);
        if (has_ellipsis) {                            // 1
          /* add excludeList on stack just below src object */
          emit_op(s, OP_object);
          emit_op(s, OP_swap);
        }
      }
      // ...
      while (s->token.val != '}') {
        // ...
        if (prop_type == PROP_TYPE_IDENT) {
          // `PROP_TYPE_IDENT` forms `prop:` if there is either `[` or `{`
          // next to it, then the following maybe the nested destruction
          if ((s->token.val == '[' || s->token.val == '{') &&
              ((tok1 = js_parse_skip_parens_token(s, &skip_bits, FALSE)) == ',' ||
                tok1 == '=' || tok1 == '}')) {
            // ...
          }
          if (prop_name == JS_ATOM_NULL) {             // 2
            emit_op(s, OP_to_propkey2);
            if (has_ellipsis) {
              /* define the property in excludeList */
              emit_op(s, OP_perm3);
              emit_op(s, OP_null);
              emit_op(s, OP_define_array_el);
              emit_op(s, OP_perm3);
            }
            /* source prop -- source source prop */
            emit_op(s, OP_dup1);
          }
        }
        // ...
      }
    }
    

上面的代码中：

*   位置 `1` 处会根据是否有 rest property 选择是否生成 `_ex` 对象，紧跟 `_ex` 对象创建指令的是指令 `OP_swap`，也就是说操作数栈的内容为：
    
        -> Top
        _ex, src
        
    
*   位置 `2` 处使用指令 `OP_define_array_el` 将需要剔除的属性放入 `_ex` 对象设置其值为 `null`
    
    `OP_to_propkey2` 指令执行后，操作数栈中的内容为：
    
        -> Top
        _ex, src, propKey
        
    
    `OP_define_array_el` 要求操作数栈中的内容为：
    
        -> Top
        targetObj, propKey, propVal
        
    
    所以生成了指令 `OP_perm3` 翻转操作数栈中的元素：
    
        -> Top
        src, _ex, propKey
        
    
    然后 `OP_null` 压入待设置的属性值：
    
        -> Top
        src, _ex, propKey, propVal(null)
        
    
    指令 `OP_define_array_el` 执行完毕后只会将属性值弹出：
    
        -> Top
        src, _ex, propKey
        
    
    再利用指令 `OP_perm3` 将元素翻转回去：
    
        -> Top
        _ex, src, propKey
        
    

### get\_lvalue

在负责解析解构语法的函数 `js_parse_destructuring_element` 中使用了一个名为 [get\_lvalue](https://github.com/hsiaosiyuan0/quickjs/blob/3d4b0ef8273738db3d86031fa0c791a58f635784/src/parse/lval.c#L107 "https://github.com/hsiaosiyuan0/quickjs/blob/3d4b0ef8273738db3d86031fa0c791a58f635784/src/parse/lval.c#L107") 的函数，该函数在引擎实现的其他位置也被多次使用。

观察下面的例子：

    const a = { b: 1 };
    const c = { b: 2 };
    ({ b: a.b } = c);
    console.log(a.b); // 2
    

想象我们需要解析上面的解构语法，从左往右单看 `a.b` 这样一个属性访问表达式，从语义上来说它既可以是读取属性，也可以是设置属性（我们当前的例子），需要结合上下文才可以区分这两种语义。

语义虽有两种，但由于是相同的语法，我们只需按读取属性来解析即可，等上下文信息完善了、如果是设置属性的语义，再进行转换即可。我们结合 `get_lvalue` 在解构时的使用方式：

    int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                                       int hasval, int has_ellipsis,
                                       BOOL allow_initializer) {
      // ...
              if (js_parse_left_hand_side_expr(s))       // 1
                goto prop_error;
            lvalue:
              if (get_lvalue(s, &opcode, &scope, &var_name, &label_lvalue,
                             &depth_lvalue, FALSE, '{')) // 2
                goto prop_error;
              /* swap ref and lvalue object if any */
              if (prop_name == JS_ATOM_NULL) {           // 3
                switch (depth_lvalue) {                  // 4
                case 1:
                  /* source prop x -> x source prop */
                  emit_op(s, OP_rot3r);
                  break;
                case 2:
                  /* source prop x y -> x y source prop */
                  emit_op(s, OP_swap2); /* t p2 s p1 */
                  break;
                case 3:
                  /* source prop x y z -> x y z source prop */
                  emit_op(s, OP_rot5l);
                  emit_op(s, OP_rot5l);
                  break;
                }
              } else {
                switch (depth_lvalue) {
                case 1:
                  /* source x -> x source */
                  emit_op(s, OP_swap);
                  break;
                case 2:
                  /* source x y -> x y source */
                  emit_op(s, OP_rot3l);
                  break;
                case 3:
                  /* source x y z -> x y z source */
                  emit_op(s, OP_rot4l);
                  break;
                }
              }
            // ...
            if (prop_name == JS_ATOM_NULL) {             // 5
              /* computed property name on stack */
              /* XXX: should have OP_get_array_el2x with depth */
              /* source prop -- val */
              emit_op(s, OP_get_array_el);
            } else {
              /* named property */
              /* XXX: should have OP_get_field2x with depth */
              /* source -- val */
              emit_op(s, OP_get_field);
              emit_u32(s, prop_name);
            }
      // ...
    }
    

在上面的代码中：

*   位置 `1` 处就表示我们例子中解析 `a.b`
    
*   到了位置 `2` 时，指令序列中已经包含了 `a.b` 表达式对应的指令序列，指令序列的最后一个指令是 `OP_get_field`
    
    因为是属性访问，`OP_get_field` 之前的指令就是将待操作对象压入操作数栈
    

这样对 `a.b` 的解析就完成了，但是很明显，当前的指令有点问题，因为结合上下文的语义，我们并不是要访问属性，而是要设置属性。这时就需要 `get_lvalue` 函数出手了，它可以返回「对应的写入指令序列」所需的信息。

这里需要插入介绍一下什么是「对应的写入指令序列」：

*   比如，我们要为读取变量设计一个指令 `OP_my_get_val`，很明显这个指令需要的参数是：变量名，变量作用域
    
*   如果我们需要为写入变量设计一个指令 `OP_my_set_val`，很明显这个指令需要的参数是：变量名，变量作用域，待设置的值
    

我们发现这对指令可以看成是对应的，因为它们都是操作变量，参数也差不多。这时变量操作的例子，属性操作也是类似。

由于 C 语言不支持多返回值，调用函数 `get_lvalue` 时使用操作符 `&` 修饰的参数类似我们在其他高级语言中使用的 Outer parameters，这些参数就是「对应的写入指令序列」所需的信息，交给下方的 [put\_lvalue](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/vardec.c#L468 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/vardec.c#L468") 调用来生成相关的指令序列。

回到 `get_lvalue` 函数，其中一个不太好理解的参数是 `depth_lvalue`，我们可以结合上面的代码片段来理解：

*   `prop_name == JS_ATOM_NULL` 的分支表示属性是 [Computed property](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#computed_property_names "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#computed_property_names")，那么当执行到位置 `3` 时操作数栈中的内容为：
    
        -> Top
        source, propName_src
        
    
*   位置 `4` 会根据 `depth_lvalue` 生成不同的操作数翻转指令，通过查看函数 `get_lvalue` 的实现：
    
        case OP_get_field:    // 1
         name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
         depth = 1;
         break;
        // ...
        case OP_get_array_el: // 2
         depth = 2;
         break;
        
    
    可以看出：
    
    *   如果属性名是静态的（位置 `1`），则 `depth` 为 1
        
        因为操作数栈中有待访问的对象：
        
            -> Top
            source, propName_src, dest
            
        
    *   如果属性名是计算的（位置 `2`），则 `depth` 为 2
        
        因为操作数栈中有待访问的对象和计算后的属性名
        
            -> Top
            source, propName_src, dest, propName_dest
            
        
    
    这就和上面的注释中的 `x`、`y` 对应上了（因为其他指令访问指令也可能造成操作数栈的增长，所以使用了更加通用的命名）
    

了解这些之后，生成操作数翻转指令的作用也就显而易见，比如对于：

    ({ b: a.b } = c);
    

*   需要先通过 `c.b` 取出属性值，再通过 `a.b` 设置属性值
    
*   上面代码中的位置 `5` 就是取出 source 对象的属性（`c.b`），这就要求相关的操作数需要位于操作数栈顶，很明显当前是 `x`、`y` 之流，所以需要借助翻转指令
    

变量定义
----

变量定义的解析入口调用在函数 `js_parse_statement_or_decl` 中：

    __exception int js_parse_statement_or_decl(JSParseState *s, int decl_mask) {
      // ...
      case TOK_LET:
      case TOK_CONST:
      haslet:
        if (!(decl_mask & DECL_MASK_OTHER)) {
          js_parse_error(
              s, "lexical declarations can't appear in single-statement context");
          goto fail;
        }
        /* fall thru */
      case TOK_VAR:
        if (next_token(s))
          goto fail;
        if (js_parse_var(s, TRUE, tok, FALSE))
          goto fail;
        if (js_parse_expect_semi(s))
          goto fail;
        break;
      // ...
    }
    

可见 `var`、`let|const` 的解析都是通过函数 `js_parse_var` 完成：

    __exception int js_parse_var(JSParseState *s, int parse_flags, int tok,
                                 BOOL export_flag) {
    // ...
      for (;;) {
        if (s->token.val == TOK_IDENT) { // 1
          // ...
        } else {
          // 2
          if ((s->token.val == '[' || s->token.val == '{') &&
              js_parse_skip_parens_token(s, &skip_bits, FALSE) == '=') {
            // ...
          }
          // ...
        }
        if (s->token.val != ',')
          break;
        if (next_token(s))
          return -1;
      }
    // ...
    }
    

位置 `1` 和 `2` 分别表示通过变量名和解构来定义变量，解构我们已经在上文介绍过，下面我们看通过变量名定义的方式：

    __exception int js_parse_var(JSParseState *s, int parse_flags, int tok,
                                 BOOL export_flag) {
    // ...
      for (;;) {
        if (s->token.val == TOK_IDENT) { // 1
          // ...
          if (js_define_var(s, name, tok))
            goto var_error;
          // ...
          if (s->token.val == '=') { // 3
            // ...
          } else {
            // ...
            if (tok == TOK_LET) { // 2
              /* initialize lexical variable upon entering its scope */
              emit_op(s, OP_undefined);
              s->loc = loc;
              emit_op(s, OP_scope_put_var_init);
              emit_atom(s, name);
              emit_u16(s, fd->scope_level);
            }
          }
        }
        // ...
      }
    // ...
    }
    

*   在位置 `1` 处使用了上文介绍过的函数 `js_define_var` 定义了变量
    
*   位置 `2` 处的指令未来会在函数 [resolve\_scope\_var](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/optim.c#L373 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/optim.c#L373") 中被优化掉
    
*   位置 `3` 处是当变量定义包含了初始化表达式时的解析操作
    

继续看看位置 `3` 展开的内容：

    if (s->token.val == '=') {
      if (next_token(s))
        goto var_error;
    
      loc = LOC(s->token.line_num, s->token.col_num);
      if (tok == TOK_VAR) {
        /* Must make a reference for proper `with` semantics */
        int opcode, scope, label;
        JSAtom name1;
    
        emit_op(s, OP_scope_get_var);                   // 1
        emit_atom(s, name);
        emit_u16(s, fd->scope_level);
        if (get_lvalue(s, &opcode, &scope, &name1, &label, NULL, FALSE, '=') < 0)                                // 2
          goto var_error;
        if (js_parse_assign_expr2(s, parse_flags)) {    // 3
          JS_FreeAtom(ctx, name1);
          goto var_error;
        }
        set_object_name(s, name);
        s->loc = loc;
        put_lvalue(s, opcode, scope, name1, label, PUT_LVALUE_NOKEEP, FALSE);                                         // 4
      } else {
        if (js_parse_assign_expr2(s, parse_flags))      // 5
          goto var_error;
        set_object_name(s, name);
        s->loc = loc;
        emit_op(s, (tok == TOK_CONST || tok == TOK_LET) // 6
                        ? OP_scope_put_var_init
                        : OP_scope_put_var);
        emit_atom(s, name);
        emit_u16(s, fd->scope_level);
      }
    }
    

对于 `var` 定义的变量来说：

*   先通过位置 `1` 生成指令 `OP_scope_get_var`，目的是传参给位置 `2` 处的 `get_lvalue`
    
*   位置 `2` 处返回的 `opcode` 为 `OP_get_ref_value`。`get_lvalue` 会将执行时的最后一条指令 `OP_scope_get_var` [剔除](https://github.com/hsiaosiyuan0/quickjs/blob/3d4b0ef8273738db3d86031fa0c791a58f635784/src/parse/lval.c#L160 "https://github.com/hsiaosiyuan0/quickjs/blob/3d4b0ef8273738db3d86031fa0c791a58f635784/src/parse/lval.c#L160")，并生成指令 `OP_scope_make_ref`，该指令有个参数 `label`，会先借由 `get_lvalue` 的出参 `&label` 返回
    
*   位置 `3` 处进行初始化表达式的解析
    
*   位置 `4` 生成相应的变量赋值指令序列，并更新 `&label`，因此指令 `OP_scope_make_ref` 的参数 `label` 会将初始化表达式的指令序列也包含在内，目的是方便后续的指令优化
    

对于 `let|const` 定义的变量来说：

*   先通过位置 `5` 进行初始化表达式的解析
    
*   接着位置 `6` 生成对应的变量赋值指令序列
    

函数作用域解析
-------

函数内的作用域解析操作在函数 [js\_parse\_function\_decl2](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L185 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L185") 中进行，该函数的内容比较多，作用域相关的操作为：

1.  [解析形参](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L351 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L351")
    
2.  如果形参中包含了表达式（比如解构包含了默认值），那么会：
    
    1.  多产生一个 [作用域](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L381 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L381")
        
    2.  [存放](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L509 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L509") 表达式引入的变量定义
        
3.  压入函数体 [作用域](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L556 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L556") 并开始函数体的解析
    

在确定形参中是否包含了表达式时，使用了函数 [js\_parse\_skip\_parens\_token](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/vardec.c#L8 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/vardec.c#L8") 进行 [预读](https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L369 "https://github.com/hsiaosiyuan0/quickjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L369")：

    /* if there is an '=' inside the parameter list, we
        consider there is a parameter expression inside */
    js_parse_skip_parens_token(s, &skip_bits, FALSE);
    if (skip_bits & SKIP_HAS_ASSIGNMENT)
      fd->has_parameter_expressions = TRUE;
    if (next_token(s))
      goto fail;
    

前面我们提到索引为 0 的作用域用于存放函数体内使用 `var` 定义的变量，这些变量信息解析后存放在 `JSFunctionDef::vars` 数组中。

形参定义的存放位置分这几种情况：

*   简单形参、即单个标识符的情况，参数信息存放在 `JSFunctionDef::args` 数组中，`JSFunctionDef::vars` 数组中并不存放
    
*   如果是简单形参，但是包含了表达式（默认值），则参数信息会同时存放在 `JSFunctionDef::args` 数组和 `JSFunctionDef::vars` 数组中，后者关联的作用域索引为 1
    
*   如果包含了解构，但是解构中没有没有表达式（比如默认值），那么参数信息会同时存在于 `JSFunctionDef::args` 数组和 `JSFunctionDef::vars` 数组中，后者关联的作用域索引为 0
    
    不过受限于引擎的解析方式 `JSFunctionDef::args` 数组中的相应定义的 `var_name` 为 `null`
    
*   如果包含了解构，且解构中包含了表达式（比如默认值），那么参数信息会同时存在于 `JSFunctionDef::args` 数组和 `JSFunctionDef::vars` 数组中，后者关联的作用域索引为 1
    
    不过受限于引擎的解析方式 `JSFunctionDef::args` 数组中的相应定义的 `var_name` 为 `null`
    

上面的描述其实也是「解构」只是语法糖在引擎层面的印证：

    function f({ a }) {}
    // 等价于
    function f(_a) {
      var { a } = _a;
    }
    
    function f({ a } = {}) {}
    // 等价于
    function f(_a) /* implicit scope_1 { let { a } = _a } */ {}
    

我们以下面的代码为例，结合图例分析：

    function f(a, b, { c, d } = {}) {
      var e;
      var f;
      let g = 1;
      let h = 2;
      {
        let i = 3;
      }
    }
    

对应的作用域关系为：

![var_scope_union.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82479665a1ae440f84b3f6d85317d413~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=782&h=1164&s=92599&e=png&b=fefcfc)

上图即为[「符号表 - Symbol table」](https://en.wikipedia.org/wiki/Symbol_table "https://en.wikipedia.org/wiki/Symbol_table")，简单来说就是记录变量和它们所在作用域之间的映射关系。

1.  `a` 和 `b` 是一般的形参，所以它们的定义位于 `JSFunctionDef::args` 数组中
    
2.  `c` 和 `d` 是形参中解构引入的变量，由于使用了初始化表达式，它们的定义位于 `JSFunctionDef::vars` 数组中，并关联到作用域 S1
    
3.  `e` 和 `f` 是函数体中使用 `var` 定义的变量，它们的定义位于 `JSFunctionDef::vars` 数组中，关联的作用域是 S0
    
4.  `g` 和 `h` 是函数体中使用 `let` 定义的变量，定义位于 `JSFunctionDef::vars` 数组中，关联的作用域是 S2
    
5.  `i` 定义位于 `JSFunctionDef::vars` 数组中，关联的作用域是 S3
    
6.  由于 `g`，`h` 和 `i` 都是 `let` 定义的变量，它们通过字段 `JSVarDef::scope_next` 连接
    
7.  S3 的父级作用域为 S2，再往上是 S0（[并不是 S1](https://github.com/hsiaosiyuan0/slowjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L540 "https://github.com/hsiaosiyuan0/slowjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L540")），S1 的父级是 S0
    
8.  `JSFunctionDef::args` 中也是有 `c` 和 `d` 的定义的，不过其中的 `var_name` 为 `null`（因为解构）
    
    由于 `c` 和 `d` 不在 S0 中，会接着在 S0 也 [加入](https://github.com/hsiaosiyuan0/slowjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L522 "https://github.com/hsiaosiyuan0/slowjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L522") 它们的定义，并且在运行阶段将实参 [拷贝](https://github.com/hsiaosiyuan0/slowjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L525 "https://github.com/hsiaosiyuan0/slowjs/blob/1c3fe499f5a48cacccc59e57474d9acb4b07a981/src/parse/func.c#L525") 到 S0 中
    

形参中使用了表达式，那么会创建一个作用域 S1 将其引入的变量定义到其中，这就使得函数体作用域就会从索引 2 开始。

校验变量是否重复定义是通过上面提到的函数 [define\_var](https://github.com/hsiaosiyuan0/slowjs/blob/3d4b0ef8273738db3d86031fa0c791a58f635784/src/parse/scope.c#L276 "https://github.com/hsiaosiyuan0/slowjs/blob/3d4b0ef8273738db3d86031fa0c791a58f635784/src/parse/scope.c#L276") 完成的，当解析到 `let a = 1` 时进入：

      case JS_VAR_DEF_LET:
      case JS_VAR_DEF_CONST:
      case JS_VAR_DEF_FUNCTION_DECL:
      case JS_VAR_DEF_NEW_FUNCTION_DECL:
        // 1
        idx = find_lexical_decl(ctx, fd, name, fd->scope_first, TRUE);
        if (idx >= 0) {
          // ...
            redef_lex_error:
              /* redefining a scoped var in the same scope: error */
              return js_parse_error(s,
                                    "invalid redefinition of lexical identifier");
          // ...
        }
        // ...
        // 2
        if (find_var_in_child_scope(ctx, fd, name, fd->scope_level) >= 0) {
          return js_parse_error(s, "invalid redefinition of a variable");
        }
    

上面代码中的逻辑为：

1.  先通过函数 `find_lexical_decl` 看是否之前的词法位置上已经定义过变量，这些变量通过 `scope_next` 连接，如果找到则抛出异常
    
2.  如果上一步未见异常，那么使用 `find_var_in_child_scope` 遍历 `JSFunctionDef::vars` 中使用 `var` 定义的变量，看其定义时所在的作用域是否为当前的子作用域
    

结合上面这 2 点，以及再之前的 7、8，可以理解引擎当前的一个小 Bug：

    function f({ a } = {}) {
      let a = 1; // 1
      console.log(a);
    }
    
    f({});
    

上面代码会正常打印 1，而在其他引擎中会报错 `Uncaught SyntaxError: Identifier 'a' has already been declared`，这是因为解析到 `let a` 时：

1.  首先位置 `1` 之前的词法位置上并未定义 `a`
    
2.  通过 `find_var_in_child_scope` 可以找到变量 `a`，但是它的作用域为 S1，并不是当前 S2 的子作用域
    

案例分析
----

下面我们通过对几个实例案例的分析来加深对上文的理解

### `var a = 1`

进入 `js_parse_var` 后，会先通过 `define_var` 进行对变量定义进行语法校验，并且将变量以及作用域的信息记录到 `JSFunctionDef::vars` 和 `JSFunctionDef::scopes` 中。

随后在 `js_parse_var` 中就会进入指令生成阶段，`var a = 1` 会进入 `js_parse_var` 中的逻辑：

    static __exception int js_parse_var(JSParseState *s, int parse_flags, int tok,
                                        BOOL export_flag)
    {
        // ...
          if (s->token.val == '=') {
            if (next_token(s))
              goto var_error;
    
            loc = LOC(s->token.line_num, s->token.col_num);
            if (tok == TOK_VAR) {
              /* Must make a reference for proper `with` semantics */
              int opcode, scope, label;
              JSAtom name1;
    
              emit_op(s, OP_scope_get_var);
              emit_atom(s, name);
              emit_u16(s, fd->scope_level);
              if (get_lvalue(s, &opcode, &scope, &name1, &label, NULL, FALSE, '=') <
                  0)
                goto var_error;
              if (js_parse_assign_expr2(s, parse_flags)) {
                JS_FreeAtom(ctx, name1);
                goto var_error;
              }
              set_object_name(s, name);
              s->loc = loc;
              put_lvalue(s, opcode, scope, name1, label, PUT_LVALUE_NOKEEP, FALSE);
            }
            // ...
          }
        // ...
    }
    

首先生成下面的指令序列：

    OP_scope_get_var name scope_level
    

然后调用 `get_lvalue`，该函数会将最后一条指令替换成：

    OP_scope_make_ref name label scope_level
    

此处 `get_lvalue` 返回的 `opcode` 是 `OP_get_ref_value`。然后会调用 `js_parse_assign_expr2` 解析初始化表达式部分，指令序列会变成：

    OP_scope_make_ref name label scope_level
    init ops
    

> `init ops` 表示初始化表达式对应的指令序列

接着调用 `put_lvalue`，传入的 `opcode` 为 `OP_get_ref_value`，会生成下面的指令序列：

        OP_scope_make_ref name label:x scope_level
        init ops
        OP_label:x
    x:  OP_nop
        OP_put_ref_value
    

`OP_put_ref_value` 是 `put_lvalue` 根据传入的 `opcode` 为 `OP_get_ref_value` 生成的。`put_lvalue` 接收的 `opcode` 都为 `get` 系列的指令，然后在函数内部会替换成这些 `get` 指令对应的 `set` 指令

上面的指令序列就是在 phase1 阶段生成的，在函数实例化的时候，会进入到 phase2 阶段，进入下面的调用进行指令优化：

    js_create_function -> resolve_variables -> resolve_scope_var
    

    static __exception int resolve_variables(JSContext *ctx, JSFunctionDef *s)
    {
        // ...
        case OP_scope_make_ref: {
          int label;
          LabelSlot *ls;
          var_name = get_u32(bc_buf + pos + 1);
          label = get_u32(bc_buf + pos + 5);
          scope = get_u16(bc_buf + pos + 9);
          ls = &s->label_slots[label];
          ls->ref_count--; /* always remove label reference */
          pos_next = resolve_scope_var(ctx, s, var_name, scope, op, &bc_out, bc_buf,
                                       ls, pos_next);
          JS_FreeAtom(ctx, var_name);
        } break;
        // ...
    }
    

可见此处 `resolve_scope_var` 调用时的参数即 pass1 阶段中`OP_scope_make_ref` 指令的参数。

接着执行 `resolve_scope_var` 函数中的相关逻辑：

    static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
                                 JSAtom var_name, int scope_level, int op,
                                 DynBuf *bc, uint8_t *bc_buf,
                                 LabelSlot *ls, int pos_next)
    {
        // ...
        case OP_scope_make_ref:
          // ...
          if (label_done == -1 && can_opt_put_ref_value(bc_buf, ls->pos)) {
            int get_op;
            if (var_idx & ARGUMENT_VAR_OFFSET) {
              get_op = OP_get_arg;
              var_idx -= ARGUMENT_VAR_OFFSET;
            } else {
              if (s->vars[var_idx].is_lexical)
                get_op = OP_get_loc_check;
              else
                get_op = OP_get_loc;
            }
            pos_next = optimize_scope_make_ref(ctx, s, bc, bc_buf, ls, pos_next,
                                               get_op, var_idx);
          }
        // ...
    }
    

通过 `can_opt_put_ref_value` 判断是否可以进行优化，这里的 `ls->pos` 就是 `OP_scope_make_ref` 中 `label` 指向的位置，即 `nop` 指令的位置。`can_opt_put_ref_value` 的实现为：

    static BOOL can_opt_put_ref_value(const uint8_t *bc_buf, int pos)
    {
      int opcode = bc_buf[pos];
      return (bc_buf[pos + 1] == OP_put_ref_value &&
              (opcode == OP_insert3 || opcode == OP_perm4 || opcode == OP_nop ||
               opcode == OP_rot3l));
    }
    

可见 `can_opt_put_ref_value` 判断的是 `pos` 处的下一个指令，此处因为是 `OP_nop` 所以是满足条件的。

随后会进入到 `optimize_scope_make_ref` 函数的优化逻辑，且传入的 `get_op` 为 `OP_get_loc`，并且也传入了 `OP_scope_make_ref` 指令中的 label。

回顾下 phase1 生成的指令序列是：

        OP_scope_make_ref name label:x scope_level
        init ops
        OP_label:x
    x:  OP_nop
        OP_put_ref_value
    

`optimize_scope_make_ref` 函数内部将 `nop/OP_put_ref_value` 称为 instruction pair，函数内部会将 \[OP\_label,instructionpair\]\[OP\\\_label, instruction pair\]\[OP\_label,instructionpair\] 范围内的指令（7 个字节）优化掉：

1.  先是在原本 `OP_label` 处的位置生成 `get_op` 对应的赋值指令。比如 `OP_get_loc` 对应的 `OP_put_loc`
    
2.  将 `[OP_label, instruction pair]` 之间除上一步的指令的字节位置都替换成 `OP_nop`
    

因此优化后的指令会变成：

        OP_scope_make_ref name label:x scope_level
        init ops
        OP_put_loc var_idx
    x:  OP_nop
        OP_nop
    

引擎中通过两个 buffer 分别存储不同阶段的指令序列，其中 `bc_buf` 存放 phase1 阶段生成的指令，`bc` 会存放 phase2 的指令（phase1 阶段的指令优化后的内容）。

上面的修改是发生在 `bc_buf` 中，然后 `bc` 的生成会在 `OP_scope_make_ref` 下一个指令的位置，即 `init ops` 处继续进行。

phase2 阶段的优化方式简单来说：

1.  依次读取 `bc_buf` 中的字节码，根据不同地指令进行优化
    
2.  不过优化有时会先写入到 `bc_buf` 中，待随后优化写入到 `bc` 中，当然有时也会直接写入到 `bc` 中
    

### `var a`

与有初始化表达式不同，单独地通过 `var` 声明一个变量并不会生成指令，因为在函数调用时，会先将其中定义的变量都初始化为 `undefined`

    static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                                   JSValueConst this_obj, JSValueConst new_target,
                                   int argc, JSValue *argv, int flags)
    {
      // ...
      for(i = 0; i < b->var_count; i++)
          var_buf[i] = JS_UNDEFINED;
      // ...
    }
    

### `let a = 1`

与 `var a = 1` 类似，会在 `js_parse_var` 中被处理，先通过 `define_var` 来判断变量是否已定义，并且会记录变量的定义信息，比如变量所属的作用域等。

随后进入到指令生成阶段：

    static __exception int js_parse_var(JSParseState *s, int parse_flags, int tok,
                                        BOOL export_flag)
    {
        // ...
          if (s->token.val == '=') {
            if (next_token(s))
              goto var_error;
    
            loc = LOC(s->token.line_num, s->token.col_num);
            if (tok == TOK_VAR) {
              // ...
            } else {
              if (js_parse_assign_expr2(s, parse_flags))
                goto var_error;
              set_object_name(s, name);
              s->loc = loc;
              emit_op(s, (tok == TOK_CONST || tok == TOK_LET)
                             ? OP_scope_put_var_init
                             : OP_scope_put_var);
              emit_atom(s, name);
              emit_u16(s, fd->scope_level);
            }
          }
        // ...
    }
    

可见 `js_parse_assign_expr2` 先生成初始化部分的指令，然后生成 `OP_scope_put_var_init` 指令，指令序列类似：

    init ops
    OP_scope_put_var_init name scope_level
    

上面就是 phase1 阶段生成的指令，到了 phase2 阶段，会在 `resolve_scope_var` 函数中将 `OP_scope_put_var_init` 进行替换：

    static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s, JSAtom var_name,
                                 int scope_level, int op, DynBuf *bc,
                                 uint8_t *bc_buf, LabelSlot *ls, int pos_next) {
        // ...
        case OP_scope_put_var_init:
          is_put = (op == OP_scope_put_var || op == OP_scope_put_var_init);
          if (var_idx & ARGUMENT_VAR_OFFSET) {
            dbuf_putc(bc, OP_get_arg + is_put);
            dbuf_put_u16(bc, var_idx - ARGUMENT_VAR_OFFSET);
          } else {
            if (is_put) {
              if (s->vars[var_idx].is_lexical) {
                if (op == OP_scope_put_var_init) {
                  /* 'this' can only be initialized once */
                  if (var_name == JS_ATOM_this)
                    dbuf_putc(bc, OP_put_loc_check_init);
                  else
                    dbuf_putc(bc, OP_put_loc);
                } else {
                  dbuf_putc(bc, OP_put_loc_check);
                }
              } else {
                dbuf_putc(bc, OP_put_loc);
              }
            } else {
              if (s->vars[var_idx].is_lexical) {
                dbuf_putc(bc, OP_get_loc_check);
              } else {
                dbuf_putc(bc, OP_get_loc);
              }
            }
            dbuf_put_u16(bc, var_idx);
          }
          break;
        // ...
    }
    

替换后的指令序列为：

    init ops
    OP_put_loc var_idx
    

### `let a`

`let a` 对应的指令会进入函数 `js_parse_var` 中的下面逻辑：

    static __exception int js_parse_var(JSParseState *s, int parse_flags, int tok,
                                        BOOL export_flag)
    {
        // ...
          if (s->token.val == '=') {
            // ...
          } else {
            if (tok == TOK_CONST) {
              js_parse_error(s, "missing initializer for const variable");
              goto var_error;
            }
            if (tok == TOK_LET) {
              /* initialize lexical variable upon entering its scope */
              emit_op(s, OP_undefined);
              s->loc = loc;
              emit_op(s, OP_scope_put_var_init);
              emit_atom(s, name);
              emit_u16(s, fd->scope_level);
            }
            // ...
          }
        // ...
    }
    

因此 phase1 阶段生成的指令序列是：

    OP_undefined
    OP_scope_put_var_init name scope_level
    

并且我们知道 `OP_scope_put_var_init` 会在 phase2 阶段会优化，变成：

    OP_undefined
    OP_put_loc var_idx
    

在上面为 `var a` 生成指令的时候，我们已经知道在运行阶段进入函数调用时，会先将函数中的变量都初始化为 `undefined`，那么这里为什么还需要一条 `OP_undefined` 指令呢

这其实是为了迎合标准中的规定，使用 `let|const` 定义的变量在可以被访问之前必须先被初始化，比如下面的代码会报错：

    function f() {
      let a = b, // Uncaught ReferenceError: Cannot access 'b' before initialization
        b;
    }
    f();
    

为了能够对上面的代码进行报错，引擎会在进入到作用域中时，对作用域中使用 `let|const` 定义的变量重新赋值为一个内部值 `uninitialized`。

这样在访问变量时，如果值为 `uninitialized` 时报错即可，也是因为变量被设置成了 `uninitialized`，需要额外的 `OP_undefined/OP_put_loc` 将变量值再设置为 `undefined`。

### `let { a } = {}`

左值的处理还是在 `js_parse_var` 中，根据读入的不同 `token` 来采取不同地操作:

*   当 `token` 为 `ident` 的时候，匹配诸如 `let a = 1` 变量声明
    
*   当 `token` 为 `[, {` 的时候，匹配诸如 `let { a } = 1` 的解构声明
    

此处的情况会进入到解构声明的处理中，也就是通过 `js_parse_destructuring_element` 来生成用于解构的指令序列，由于传入的 `hasval` 为 `true`，会先生成下面的指令序列：

            dup
            is_undefined
            if_true8 17
        8:  to_object
    

然后由于使用的是对象解构，会继续生成指令 `OP_to_object` 将栈顶元素转换成对象。

继续调用 `js_parse_property_name`，返回的 `prop_type` 是 `PROP_TYPE_VAR` 表示要声明变量。

接着生成访问右值对象属性的指令 `OP_get_field2`，此时指令序列变为：

            dup
            is_undefined
            if_true8 17
        8:  to_object
            OP_get_field2 prop_name
    

接着会进入到赋值指令序列的生成：

    static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                                            int hasval, int has_ellipsis,
                                            BOOL allow_initializer)
    {
        // ...
        set_val:
          if (tok) {
            if (js_define_var(s, var_name, tok))
              goto var_error;
            scope = s->cur_func->scope_level;
          }
          if (s->token.val == '=') { /* handle optional default value */
            // ...
          }
          /* store value into lvalue object */
          s->loc = loc;
          put_lvalue(s, opcode, scope, var_name, label_lvalue,
                     PUT_LVALUE_NOKEEP_DEPTH, (tok == TOK_CONST || tok == TOK_LET));
          if (s->token.val == '}')
            break;
          /* accept a trailing comma before the '}' */
          if (js_parse_expect(s, ','))
            return -1;
        // ...
    }
    

首先通过 `js_define_var`（内部会调用 `define_var`）来判断变量是否可以定义，并且记录变量定义的相关信息。

继续调用 `put_lvalue` 传入的 `opcode` 为 `OP_scope_get_var`，会生成下面的指令序列：

            dup
            is_undefined
            if_true8 17
        8:  to_object
            OP_get_field2 prop_name
            OP_scope_put_var_init name scope
    

我们已经知道 `OP_scope_put_var_init` 会在 phase2 阶段中被优化，变为：

            dup
            is_undefined
            if_true8 17
        8:  to_object
            OP_get_field2 prop_name
            OP_put_loc var_idx
    

### `var { a } = {}`

与上一节类似 `var { a } = {}` 也是在 `js_parse_var` 函数中被处理，通过 `js_parse_destructuring_element` 生成下面的指令序列：

            dup
            is_undefined
            if_true8 17
        8:  to_object
    

其中的 `OP_to_object` 指令是因为此处是对象的解构，需要将栈顶元素转换成对象。

同样地调用 `js_parse_property_name` 会返回 `prop_type` 为 `PROP_TYPE_VAR` 表示要声明变量。

接着因为下面的分支命中：

    static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                                            int hasval, int has_ellipsis,
                                            BOOL allow_initializer)
    {
        // ...
            if (!tok || tok == TOK_VAR) {
              /* generate reference */
              /* source -- source source */
              emit_op(s, OP_dup);
              emit_op(s, OP_scope_get_var);
              emit_atom(s, prop_name);
              emit_u16(s, s->cur_func->scope_level);
              goto lvalue;
            }
        // ...
    }
    

生成下面的指令序列：

            dup
            is_undefined
            if_true8 17
        8:  to_object
            OP_dup
            OP_scope_get_var prop_name scope_level
    

`goto lvalue;` 的位置会调用函数 `get_lvalue`，`get_lvalue` 会将最后一条指令，此处即 `OP_scope_get_var` 进行替换，生成带 label 的 `OP_scope_make_ref` 指令，且 label 会指向 `init op` 指令序列的下一条指令。

`get_lvalue` 的返回值中，`opcode` 是 `OP_get_ref_value`，后续会传递给 `put_lvalue`，`depth_lvalue` 设置为 `2`，因此生成一条 `OP_rot3l` 指令。

接着生成 `OP_get_field` 指令，此时指令序列为：

            dup
            is_undefined
            if_true8 17
        8:  to_object
            OP_dup
            OP_scope_make_ref name label scope_level
            OP_rot3l
            OP_get_field prop_name
    

接着因为有初始化表达式，会通过 `js_parse_assign_expr` 生成 `init ops` 指令序列，然后调用 `put_lvalue` 生成复制指令序列.

调用 `put_lvalue` 传入的 `opcode` 为 `OP_get_ref_value`，因此最后生成的指令序列为：

            dup
            is_undefined
            if_true8 17
        8:  to_object
            OP_dup
            OP_scope_make_ref name label scope_level
            OP_rot3l
            OP_get_field prop_name
            OP_label
            OP_put_ref_value
    

上面为 phase2 阶段生成的指令。

在进入到 phase2 后，即 `resolve_scope_var` 函数的 `OP_scope_make_ref` 指令的处理逻辑后，因为 `can_opt_put_ref_value` 判断为否，不会进入到 `optimize_scope_make_ref` 的优化中，而是下面的逻辑：

    static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
                                 JSAtom var_name, int scope_level, int op,
                                 DynBuf *bc, uint8_t *bc_buf,
                                 LabelSlot *ls, int pos_next)
    {
        // ...
        if (var_idx >= 0) {
          // ...
          switch (op) {
          case OP_scope_make_ref:
            if (!(var_idx & ARGUMENT_VAR_OFFSET) &&
                s->vars[var_idx].var_kind == JS_VAR_FUNCTION_NAME) {
              // ...
            } else if (label_done == -1 && can_opt_put_ref_value(bc_buf, ls->pos)) {
              // ...
            } else {
              /* Create a dummy object with a named slot that is
                a reference to the local variable */
              if (var_idx & ARGUMENT_VAR_OFFSET) {
                // ...
              } else {
                dbuf_putc(bc, OP_make_loc_ref);
                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                dbuf_put_u16(bc, var_idx);
              }
            }
            break;
          }
        }
    }
    

将 `OP_scope_make_ref` 指令替换为 `OP_make_loc_ref` 指令

因此经过 phase2 后指令序列变为：

            dup
            is_undefined
            if_true8 17
        8:  to_object
            OP_dup
            OP_make_loc_ref var_name var_idx
            OP_rot3l
            OP_get_field prop_name
            OP_label
            OP_put_ref_value
    

### `var { a: { b } } = {}`

我们可以直接打印 phase1 阶段的指令：

    ;;   var { a: { b } } = {};
    
            line_num 2
            undefined
            dup
            undefined
            strict_eq
            if_true 0:78
            label 1:22
       22:  to_object
            get_field2 a
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            nop
            to_object
            dup
            scope_make_ref b,4:65,1
            rot3l
            get_field b
            label 4:65
       65:  put_ref_value
    

我们来分析为什么有很多 `nop`。

还是从 `js_parse_var` 开始看起，进入 `js_parse_destructuring_element` 解析解构语法，其中形参 `hasval` 并不表示是否有初始化值，而是右值是否已经存在于操作数栈顶。

首先解析的左侧外层的 `a` 的解构。由于解析是从左往右的过程，所以如果有初始化值的话，默认值对应的指令序列会在最下方，因此会引入跳转指令，这样就比较好理解开头的一部分指令序列：

    START:      line_num 2
                undefined
                dup
                undefined
                strict_eq
                if_true INIT
                label ASSIGN
    

然后由于存在嵌套的解构，对于嵌套的解构来说，其右值为当前的属性值，即 `get_field2 a`：

    START:      line_num 2
                undefined
                dup
                undefined
                strict_eq
                if_true INIT
                label ASSIGN
    

接着继续调用 `js_parse_destructuring_element` 来解析嵌套的解构，并且 `hasval` 为 `true`：

    START:      line_num 2
                undefined
                dup
                undefined
                strict_eq
                if_true INIT
                label ASSIGN
    
    ASSIGN:     to_object
                get_field2 a
    
    START1:     dup
                undefined
                strict_eq
                if_true INIT1
                label ASSIGN1
    

由于 `b` 右侧不再需要继续解构，因此会生成对变量作用域来源进行确定的指令：

    scope_get_var prop_name scope_level
    

`scope_get_var` 指令随即会被 `js_parse_destructuring_element` 中的 `lvalue` 部分替换成：

    scope_make_ref name label scope_level
    rot3l
    get_field prop_name
    

接着进入内层解构的 `set_val` 部分：

    SET_VAL1:   label
                OP_put_ref_value
                drop
    

到这里内层的解构就处理完成，整体指令序列为：

    START:      line_num 2
                undefined
                dup
                undefined
                strict_eq
                if_true INIT
                label ASSIGN
    
    ASSIGN:     to_object
                get_field2 a
    
    START1:     dup
                undefined
                strict_eq
                if_true INIT1
                label ASSIGN1
    
    ASSIGN1:    to_object
                dup
                scope_make_ref name label scope_level
                rot3l
                get_field b
    
    SET_VAL1:   label
                OP_put_ref_value
                drop
    

然后会返回到上层的解构处理逻辑中，接着就开始处理初始化表达式对应的指令序列：

                drop        
                goto DONE       // DONE
                label INIT
    
    INIT:       drop
                object
                goto ASSIGN
                label DONE
    
    DONE:       line_num 3
                return_undef
    

加上 `INIT` 的标签后，与开头的 `if_true INIT` 指令呼应，而在 `INIT` 指令序列之前，还生成了 `goto DONE` 指令，这样来避免重复执行 INIT 部分的指令序列。

现在可以开始解释为什么中间会有一串 `nop` 了，在 `js_parse_destructuring_element` 函数的末尾有这样的逻辑：

      if (s->token.val == '=' && allow_initializer) {
        // ...
      } else {
        /* normally hasval is true except if
           js_parse_skip_parens_token() was wrong in the parsing */
        //        assert(hasval);
        if (!hasval) {
          js_parse_error(s, "too complicated destructuring expression");
          return -1;
        }
        /* remove test and decrement label ref count */
        memset(s->cur_func->byte_code.buf + start_addr, OP_nop,
               assign_addr - start_addr);
        s->cur_func->label_slots[label_parse].ref_count--;
        has_initializer = FALSE;
      }
    

也就是说，如果右侧没有初始化表达式，那么开头这些指令序列（例子中 `START1` 部分的指令序列）就会被替换成 `nop`：

    OP_dup                  // 1
    OP_undefined            // 1
    OP_strict_eq            // 1
    OP_if_true label_parse  // 5
    label ASSIGN            // 5
    

指令后面注释中的数字表示这些指令所占的字节数，可以看到它们合计 13 个，与上面的 `nop` 数目一致。

可以将 phase1 阶段的指令简化为：

    START:      line_num 2
                undefined
                dup
                undefined
                strict_eq
                if_true INIT
                label ASSIGN
    
    ASSIGN:     to_object
                get_field2 a
    
    
    ASSIGN1:    to_object
                dup
                scope_get_var prop_name scope_level
                rot3l
                get_field b
    
    SET_VAL1:   label
                OP_put_ref_value
                drop
    
                drop         # 第一层
                goto DONE
                label INIT
    
    INIT:       drop
                object
                goto ASSIGN
                label DONE
    
    DONE:       line_num 3
                return_undef
    

可以将 `js_parse_destructuring_element` 生成的指令总结成下面几个段：

    START?: if_true INIT
    
    ASSIGN: # 解构赋值，所以赋值段一定存在
            # ...
            goto DONE # 有 INIT 才有 goto DONE
    
    INIT?: 
    
    DONE?: 
    

> `?` 表示可选

*   当存在 INIT 时，就会有 4 个段
    
*   当不存在 INIT 时，仅有 ASSIGN 一个段
    

小结
--

本节我们介绍了作用域在引擎层面的实现，并且结合几个实际案例加深了理解：

*   作用域实现中比较关键的两点为：1. 作用域之间的关联形式 2. 作用域内的变量元信息的记录形式
    
*   作用域可以看成是链式结构，按词法顺序进行链接，确定变量是否定义的方式就是顺着链式结构往上查找
    
*   形参中的解构、默认值之类的语法在引擎层面看来就是语法糖 - 对照展开的 JS 代码生成相应的字节码即可
    
*   形参中包含解构可能会引入隐藏的作用域，目的是起到变量隔离的作用，源自语言标准的要求
    

下一节我们将在本节内容的基础上介绍闭包的实现方式。